# 「TAOI-1」拼凑的断音

## 题目背景

> flick tap flick tap 面を滑って \
> swipe tap swipe tap 「A.R→T」\
> flick tap flick tap 開いて叩いて \
> swipe swipe swipe swipe …もう嫌だな \
> ズルズル 糸が呟く

## 题目描述

你的面前有 $n$ 个音符，它们的动听程度由数列 $\{a_n\}$ 描述。

现在有 $n$ 种魔法，第 $i$ 种魔法会让 $a_i$ 增加 $s(s \gt 0)$。每种魔法的成功几率都为 $\dfrac{p}{q}$，并且彼此独立。

求在施加魔法情况下，最终最动听的音符的动听程度（即，$\max\limits_{i=1}^n a_i$）的期望。

**本题目有 Special Judge，你可以用两种不同的方式输出答案，具体见【输出格式】处**。

## 说明/提示

### 数据范围

**本题采用捆绑测试**。

- Subtask 1（20 points）：$n \leq 15$。
- Subtask 2（15 points）：保证 $\forall i \in [1, n), a_i \leq a_{i+1}$，$a_n \geq a_{n-1}+s$。
- Subtask 3（15 points）：保证 $\forall i,j\in[1,n], a_i = a_j$。
- Subtask 4（50 points）：无特殊限制。

对于所有测试数据，$1 \leq n \leq 10^5$，$1 \leq p \lt q \leq 10^7$，$1 \leq a_i,s \leq 10^7$。

### 样例解释

注意到两个样例的输入相同，区别仅在于输出格式不同。

以下列举了所有可能的魔法施加情况和其对应的最大值以及出现概率：

| 魔法情况 | 动听度最大值 | 出现概率 | 对期望的贡献 |
| :------: | :----------: | :------: | :----------: |
|${\color{black}1},{\color{black}2},{\color{black}3}$|$3$|$\dfrac{8}{27}$|$\dfrac{8}{9}$|
|${\color{red}3},{\color{black}2},{\color{black}3}$|$3$|$\dfrac{4}{27}$|$\dfrac{4}{9}$|
|${\color{black}1},{\color{red}4},{\color{black}3}$|$4$|$\dfrac{4}{27}$|$\dfrac{16}{27}$|
|${\color{black}1},{\color{black}2},{\color{red}5}$|$5$|$\dfrac{4}{27}$|$\dfrac{20}{27}$|
|${\color{red}3},{\color{red}4},{\color{black}3}$|$4$|$\dfrac{2}{27}$|$\dfrac{8}{27}$|
|${\color{red}3},{\color{black}2},{\color{red}5}$|$5$|$\dfrac{2}{27}$|$\dfrac{10}{27}$|
|${\color{black}1},{\color{red}4},{\color{red}5}$|$5$|$\dfrac{2}{27}$|$\dfrac{10}{27}$|
|${\color{red}3},{\color{red}4},{\color{red}5}$|$5$|$\dfrac{1}{27}$|$\dfrac{5}{27}$|

可得，最终的答案为 $\dfrac{35}{9}$。

+ 若使用第一种输出方式，它的值约为 $3.888889$。
+ 若使用第二种输出方式，可以发现 $554580200 \times 9 \equiv 35 \pmod {998244353}$。

## 样例 #1

### 输入

```
3 1 3 2
1 2 3```

### 输出

```
1
3.888889```

## 样例 #2

### 输入

```
3 1 3 2
1 2 3```

### 输出

```
2
554580200```

# 题解

## 作者：FFTotoro (赞：8)

## 前言

比赛结束前 $13$ 分钟登陆做题，$8$ 分钟解决完这一题就润去 CF 了……

## 解法

本题需要一些计算期望值的数学基础。

考虑哪些数最终可能成为最大值：显然，数 $x$ 只有满足 $x+s\ge \max\limits_{i=1}^n{a_i}$ 实施了魔法后才可能成为最大值。

于是，我们可以得到这样一个算法流程：

- 将整个数列 $a$ **降序**（从大到小）排序，令 $c$ 为期望值；

- 对于 $i=1,2,\ldots,n$，执行如下算法：

  - 如果 $a_i+s\ge a_1$，那么有 $\left(1-\dfrac{p}{q}\right)^{i-1}$ 的概率这个数前面的数都没有实施魔法，然后在这个前提条件下，这个数成为最大的数的概率是 $\left(1-\dfrac{p}{q}\right)^{i-1}\dfrac{p}{q}$，$c\leftarrow c+\left(1-\dfrac{p}{q}\right)^{i-1}\dfrac{p}{q}(a_i+s)$；
  - 否则，这个数不可能成为最大数，退出循环；
  
- 计算出除了上面所有情况的概率和，剩下的所有情况中最大值就是原来的最大值 $a_1$，$c$ 加上该情况的期望即可。

具体实现中可以使用一个变量 $w$ 来维护流程中“前面的数都没有实施魔法”的概率。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int qpow(int a,int b){
  int r=1;
  while(b){
    if(b&1)r=r%mod*a%mod;
    a=a%mod*a%mod; b>>=1;
  }
  return r;
} // 快速幂，用于计算逆元
main(){
  ios::sync_with_stdio(false);
  int n,p,q,s,c=0,w=1; cin>>n>>p>>q>>s;
  (p*=qpow(q,mod-2))%=mod; vector<int> a(n);
  for(auto &i:a)cin>>i;
  sort(a.begin(),a.end(),greater<int>()); // 降序排序
  for(int i:a){
    if(i+s<a[0])break; // 该数不可能成为答案，退出循环
    (c+=w*p%mod*(i+s)%mod)%=mod; // 维护期望值
    (w*=(mod+1-p)%mod)%=mod; // 维护概率
  } // 执行算法流程
  cout<<"2\n"<<(c+w*a[0]%mod)%mod<<endl;
  return 0;
}
```

---

## 作者：MasCotangent (赞：6)

# P9217 「TAOI-1」拼凑的断音 题解
[题目传送门](https://www.luogu.com.cn/problem/P9217)

------------
## 思路
一道很不错的数学题。

直接暴力枚举每种可能情况肯定超时，所以我们需要一些新的思路。

注意到题目只需求**最大值**的期望，且音符顺序显然不影响结论。故我们可以先对音符动听程度进行排序。然后从大至小遍历音符，定义音符  $a_i$  的权值是**它的魔法生效且原动听度比它大的音符的魔法均不生效**的概率乘以**在这一条件下所有音符动听度的最大值**。显然，这个最大值等于  $ \max(a_i+s,a_n)$。

容易证明，这样计算出的每个音符权值之和就是题目所求期望值。
## AC 代码
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n,s,a[100001];
    double ans=0,p,q,num;
    bool flag1=true,flag2=true;
    cin>>n>>p>>q>>s;
    num=p/q;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(i>1&&a[i]!=a[i-1]) flag1=false;
        if(i>1&&a[i]<a[i-1]) flag2=false; //Subtask 2,3特判
    }
    cout<<1<<'\n';//采用输出方法1
    if(a[n]-a[n-1]<s) flag2=false;
    if(flag1){
        cout<<a[1]+s;
        return 0;
    }//特判
    if(flag2){
        cout<<fixed<<setprecision(12)<<(a[n]+s)*(p/q)+a[n]*(1.0-p/q);
        return 0;
    }//特判
    sort(a+1,a+n+1);//排序
    for(int i=n;i>=1;i--){
        if(a[i]+s>a[n]) ans=ans+num*(a[i]+s);
        else ans=ans+num*a[n];               //累加答案
        num=num*(1-p/q);//计算概率
    }
    ans=ans+pow((1-p/q),n)*a[n];//记得加上所有魔法均不生效的概率
    cout<<fixed<<setprecision(12)<<ans;//输出，注意精度
    return 0;
}
```


---

## 作者：ccg12345 (赞：4)

## P9217拼凑的断音题解
#### [题目传送门](https://www.luogu.com.cn/problem/P9217)
## 大体思路
我的思路是先排序，再从大到小考虑 $\rm a_i$，到 $\rm a_i$ 的概率为 $( 1 - \frac{p}{q}) ^ {i - 1}\times \frac{p}{q}$。

$\rm a_i$ 对期望的贡献再乘上  $\rm{max}(a_i + s, a_n)$ 即可。**最后再加上所有魔法都不成功的概率 $\times a_n$，即:**

$$(1 - (1 - \frac{p}{q}) - (1 - \frac{p}{q})^2\  \cdots \ -  (1 - \frac{p}{q})^{n - 1}) \times a_n $$

**化简为:**

$$ a_n \times (1 - \frac{p}{q})^n$$


### 大家最爱的代码~

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x*f;
}//快读
int a[100005];
int main()
{
    int n, p, q, s;
    double k, ans, t;
    n = read(), p = read(), q = read(), s = read();
    k = 1.0 * p / q;//魔法成功概率
    t = 1.0 - k;
    for(register int i = 1; i <= n; i++)
        a[i] = read(); 
    sort(a + 1, a + n + 1);//排序
    ans = a[n] + s;
    for(register int i = n - 1; i >= 1; i--)
        ans += pow(t, n - i) * max(a[i] + s, a[n]);
    ans *= k;
    ans += a[n] * pow(t, n);
    printf("1\n");//采用第一种输出方式
    printf("%f", ans);
    return 0;
}
```

---

## 作者：0x282e202e2029 (赞：3)

刚橙名（就是因为 TAOI）的蒟蒻（Amorphophallus konjac）的第一篇题解！

[题目传送门](https://www.luogu.com.cn/problem/P9217)
## 【题意】
给定一个数列 {$a_n$}，其中每个数都有 $\frac{p}{q}$ 的可能加上特定数 $s$。求在**所有**的可能中，数列中**最大值**的**期望值**。
## 【分析】
在这样的情况下，将每种可能全枚举一遍的“枚猴王”行为是不可取的。因此，蒟蒻想出了这样的策略：

第一步：将数组 `sort` 一遍。

第二步，我们来看一下，对于第 $k$ 个数 $a_k$，有两种可能性：

**第一种可能，这个数加上了 $s$，变为 $a_k + s$，此时数组的最大值只有可能为 $a_k + s$ 或 $a_n$。即，此时数组的最大值应为 $\max(a_k + s,a_n)$。（概率为 $\frac{p}{q}$）**

**第二种可能，这个数保持原样，计算上一个数所对应的值。（概率为 $1 - \frac{p}{q}$）**

**综合起来，写成函数形式就是：** 
$$f(k) = \frac{p}{q} \cdot \max(a_k + s,a_n) + (1 - \frac{p}{q}) \cdot f(k - 1)$$
其中， $k$ 代表当前取到第几个数。当 $k = 0$ 时，$f(k)$ 取值为 $a_n$（因为此时最大值就是 $a_n$）。

那么我们就可以顺利写出代码了。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 100005;
int n, s, a[MAXN];//非要定义一个MAXN 
double p, q;
double f(int k)//k代表枚举到数组的第几项 
{
	if(!k)//k == 0的高级写法
	{
		return a[n];
	}
	return p * max(a[k] + s, a[n]) + (1 - p) * f(k - 1);//递归调用自己，同上式
} 
int main()
{
	cin >> n >> p >> q >> s;
	p = p / q;//将p赋值为成功几率
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	sort(a + 1, a + n + 1);//先排序 
	cout << "1\n" << fixed << setprecision(6) << f(n);//输出，保留6位小数
	return 0;
}
```

###### 洛谷管理员 kkksc03 提醒您请勿抄袭！

[AC记录](https://www.luogu.com.cn/record/108122532)

---

## 作者：gyyyyx (赞：1)

我服了，写漏了个取模，调了我半天。

[题面](https://www.luogu.com.cn/problem/P9217)

这里提供一个较慢的做法。

看到期望，考虑对于每一个可能的最大值都计算一遍出现的概率。

设**原序列**最大值为 $mx$，**施加了魔法后**的序列的**可能**最大值为 $k$，显然 $mx\leq k\leq mx+s$。

设 $cnt_x$ 表示**原序列**中 $x$ 出现的次数，$sum_x$ 表示**原序列**中**大于等于 $x$ 的数**出现的次数。

分两种情况：

1. $mx=k$，此时要使所有满足 $a_i>mx-s$ 的魔法**都失效**。
	
	显然概率为 $(\frac{q-p}{q})^{sum_{mx-s+1}}$。
	
	因此对答案的贡献为 $(\frac{q-p}{q})^{sum_{mx-s+1}}\cdot mx$。

2. $mx<k$，此时要使所有满足 $a_i>k-s$ 的魔法**都失效**，并且所有满足 $a_i=k-s$ 的魔法**至少有一个成功**。
	
	显然前者概率为 $(\frac{q-p}{q})^{sum_{k-s+1}}$，和第一种情况一样。
	
	要计算后者概率，考虑计算满足条件的魔法**全都失效**的概率，再用 $1$ 去减。计算可知为 $1-(\frac{q-p}{q})^{cnt_{k-s}}$。
	
	则两者皆满足的概率为 $(\frac{q-p}{q})^{sum_{k-s+1}}(1-(\frac{q-p}{q})^{cnt_{k-s}})=(\frac{q-p}{q})^{sum_{k-s+1}}-(\frac{q-p}{q})^{sum_{k-s}}$。
    
    因此对答案的贡献为 $((\frac{q-p}{q})^{sum_{k-s+1}}-(\frac{q-p}{q})^{sum_{k-s}})k$。

所以答案就是 $(\frac{q-p}{q})^{sum_{mx-s+1}}\cdot mx+\sum\limits_{k=mx+1}^{k\leq mx+s}((\frac{q-p}{q})^{sum_{k-s+1}}-(\frac{q-p}{q})^{sum_{k-s}})k$。

因为精度问题，第一种只会输出 $0$，考虑用第二种输出方式，写一个逆元就行了。

然后注意一下细节：$mx$ 可能小于 $s$，这会导致 $mx-s+1$ 是负数，因此要加个判断。

时间复杂度 $O(\log_2mod+n+mx+s)$。

完整代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mod 998244353
#define N 100005
#define M 10000005
using namespace std;
int n,p,q,s,mx,cnt[M],sum[M];LL f[N],ans;
LL fpow(LL a,int b){
	if(!b) return 1;
	LL t(fpow(a,b>>1));
	if(b&1) return t*t%mod*a%mod;
	return t*t%mod;
}
int main(){
	scanf("%d%d%d%d",&n,&p,&q,&s);
	for(int i(1);i<=n;++i){int a;scanf("%d",&a);mx=max(mx,a);++cnt[a];}
	for(int i(mx);i;--i) sum[i]=sum[i+1]+cnt[i];
	LL x((q-p)*fpow(q,mod-2)%mod);f[0]=1;for(int i(1);i<=n;++i) f[i]=f[i-1]*x%mod;
	for(int t(max(mx-s+1,1));t<=mx;++t) (ans+=(f[sum[t+1]]-f[sum[t]]+mod)%mod*(t+s)%mod)%=mod;//这里t代表的是k-s
	printf("2\n%lld\n",(ans+f[max(sum[mx-s+1],1)]*mx%mod)%mod);
	return 0;
}
```

最后跑了 $245ms$，好慢啊o(╥﹏╥)o

---

## 作者：Register_int (赞：1)

直接计算不太好做，可以考虑枚举最大值。设数列中有 $c_x$ 个数 $=x$、$t_x$ 个数 $\le x$，数列的最大值为 $k$，$P=1-\dfrac pq$。分为两种情况考虑：

1. 当前的所有操作都没有让最大值超过 $k$。

这种情况下易知，所有 $>k-s$ 的数的魔法都无法成功施展，因此概率为 $P^{n-t_{k-s}}$，期望为 $k\times P^{n-t_{k-s}}$。

2. 当前的操作让最大值变为了 $i+s$。

该情况出现，当且仅当等于 $i$ 的数至少有一个成功施展魔法，并且 $>i$ 的数都无法成功施展魔法。答案为 $\left(1-P^{c_i}\right)\times P^{n-t_i}$。

综上，答案为：

$$k\times P^{n-t_{k-s}}+\sum^k_{i=k-s+1}\left(1-P^{c_i}\right)\times P^{n-t_i}$$

直接计算即可，时间复杂度 $O(n\log V+V)$ 或 $O(n\log V)$。然后你可以发现这种方法很复杂，所以恭喜我喜提最劣解！

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned int uint;

const int MAXN = 1e5 + 10;
const int MAXM = 1e7 + 10;
const int mod = 998244353;

inline 
ll qpow(ll b, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = res * b % mod;
		b = b * b % mod, p >>= 1;
	}
	return res;
}

int n, s, a[MAXN], cnt[MAXM], k;

ll p, q, ans;

int main() {
	scanf("%d%lld%lld%d", &n, &p, &q, &s), p = (mod + 1 - p * qpow(q, mod - 2) % mod) % mod;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), cnt[a[i]]++, k = max(k, a[i]);
	for (int i = 1; i <= k - s; i++) cnt[i] += cnt[i - 1]; ans = qpow(p, k < s ? n : n - cnt[k - s]) * k % mod;
	for (int i = max(1, k - s + 1); i <= k; i++) {
		ans = (ans + (mod + 1 - qpow(p, cnt[i])) * qpow(p, n - cnt[i] - cnt[i - 1]) % mod * (i + s) % mod) % mod;
		cnt[i] += cnt[i - 1];
	}
	printf("2\n%lld", ans);
}
```

赞美良心出题人，甚至给了实数输出。难度大概黄左右？

---

## 作者：LHQing (赞：0)

#### 解题思路

首先将 $a$ 排序，因为可以发现此题与每个数的先后顺序无关。设 $f=\dfrac pq$，$g=1-f$。

枚举最后被选中 $+s$ 的位置 $k$。由于这个位置被选中，概率为 $f$，而又因为这是最后一个被选中的，后面每一个都不能被选，概率为 $g^{n-k}$。根据乘法原理，此时总出现概率为 $fg^{n-k}$。而此时最大值为 $\max(a_k+s,a_n)$（因为排序后的 $a_k+s$ 一定不小于 $a_{1\sim k-1}(+s)$ ），又 $a_n$ 为 $a_{k+1\sim n}$ 的最大值，所以此时最大值即为两者中最大值。综上，这种情况对答案的贡献是 $\max(a_k+s,a_n)fg^{n-k}$。

最后还要注意一种情况，即一个都不选。对答案贡献为 $a_ng^n$，加上即可。

#### 代码

```
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e5 + 10;
const int mod = 0x3b800001;

int n, s, p, q, g, ans;
int f, rf;
int a[maxn];

int power(int a, int b) {
    int r = 1, temp = a;
    while (b) {
        if (b & 1) r = r * temp % mod;
        b >>= 1;
        temp = temp * temp % mod;
    }
    return r;
}

int inv(int p, int q) {
    return p * power(q, mod - 2) % mod;
}

signed main() {
    cin >> n >> p >> q >> s;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + 1 + n);
    g = __gcd(p, q), p /= g, q /= g;
    f = inv(p, q), rf = inv(q - p, q);
    int k = n;
    while (k) {
        ans = (ans + max(a[k] + s, a[n]) % mod * f % mod * power(rf, n - k) % mod) % mod;
        k--;
    }
    ans = (ans + a[n] % mod * power(rf, n) % mod) % mod;
    cout << 2 << endl;
    cout << ans << endl;
    return 0;
}
```

---

## 作者：是青白呀 (赞：0)

将 $a_i$ 从大到小排序，考虑每个位置的动听值施加魔法后若能达到最大值，对答案的贡献。

对于 $k\in [1,n]$，若 $a_k+s>a_1$，则该位置的动听值施加魔法后可能变为序列最大值，其条件为它前面的所有位置的值都没有被施加魔法（否则增加同一个 $s$ 后前面的一定更大），而后面位置是否被施加魔法无所谓。故该位置对答案的贡献为 $\displaystyle (a_k+s)\times(1-\frac{p}{q})^{k-1}\times\frac{p}{q}$。

若 $a_k+s\leq a_1$，则即使该点施加魔法，值也不比 $a_i$ 大，最大值仍然是 $a_i$。故该位置对答案的贡献为 $\displaystyle a_1\times(1-\frac{p}{q})^{k-1}\times\frac{p}{q}$。

最后别忘了加上均未施加魔法的情况对答案的贡献。

```cpp
#include<bits/stdc++.h>
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int N=1e5+5,inf=1e9+7;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
#define Qingbai666
int n,p,q,s;
int v[N];
bool cmp(int x,int y){
	return x>y;
}
int main(){
	read(n),read(p),read(q),read(s);
	rep(i,1,n)
	    read(v[i]);
	sort(v+1,v+n+1,cmp);
	double ans=0,num=1;
	rep(i,1,n){
		ans+=double(max(v[1],v[i]+s))*double(p)/double(q)*num;
		num*=double(q-p)/double(q);
	}
	ans+=double(v[1])*num;
	printf("1\n%.10lf",ans);
	return 0;
} 
```

---


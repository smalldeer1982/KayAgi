# [信息与未来 2016] 方格取数

## 题目描述

在 $n$ 行 $m$ 列的方格矩阵中，每个方格都包含一个数字。小明可以从任意方格出发开始移动。每次移动可以移到与当前方格有一条边相邻的方格（即向上、下、左或右方向移动 $1$ 格，且不能移出边界）。除此之外，你移动到的方格中的数字必须比当前方格中的数字更大。

请你帮助小明编程规划移动路径，使路径上经过的所有数字之和最大。

## 说明/提示

### 样例 $\textbf 1$ 解释
样例数据 1 对应的矩阵如下。图中路径数字之和 $4+5+7+8=24$。
$$
\begin{array}{|c|c|c|c|c|}\hline 
9 & 7 & 10 & 10 & 8\\\hline
2 & 9 & 2 & 5 &3\\\hline
2 & 5 & \red5 & \red7 & 7\\\hline
5 & 8 & \red4 & \red8 & 5\\\hline
\end{array}
$$
### 数据范围
$1\le n,m\le 100,1\le s\le 19997$。
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4 5 97```

### 输出

```
24```

## 样例 #2

### 输入

```
40 50 1```

### 输出

```
47```

# 题解

## 作者：Max_robot (赞：1)

这道题数据量很大，我们一条一条梳理。

#### 方格

注意到这道题方格里的数需要自己算出来，所以我们按照题目中的代码写一下就好了，问题应该不是很大。


```cpp
for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			s=(s*345)%19997;
			a[i][j]=(s%10)+1;
		}
	}
```

#### 搜索

这题的算法就是搜索，但是用记忆化搜索可以不重不漏的搜，然后里面可能参杂着一点动态规划的元素吧。

然后怎么搜就是文章的重点了。

首先，我们判断这个点我们是不是已经找到了，如果是，我们就直接返回，否则就继续。

然后我们枚举上下左右四个方向，我们可以用两个数组来表示四个方向。然后呢，判断四个方向是否都是成立的。如果成立，就判断这个点原来的数是不是比四个方向的数大，如果大就交换。

我们再来讲判断条件。判断条件就简单了。首先看这个点是不是在方格里面，然后判断这个点的元素是不是比我们要算的点的元素要大。如果都满足，比较就行了。如何比较请看上一段。


```cpp
long long dx[4]={-1, 1, 0, 0}, dy[4]={0, 0, -1, 1};
long long f(int x, int y) {
    if(dp[x][y]) return dp[x][y];
    dp[x][y]=a[x][y];
    for(int i=0;i<4;i++){
        int nx=x+dx[i], ny=y+dy[i];
        if (nx>=1 && nx<=n && ny>=1 && ny<=m && a[nx][ny]>a[x][y]){
            dp[x][y]=max(dp[x][y], f(nx, ny)+a[x][y]);
        }
    }
    return dp[x][y];
}
```


#### 答案

注意哈，题目没有固定起点和终点，所以我们就不能直接输出。而是找方格里面的最大值输出。


```cpp
for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)	
			ans=max(ans,f(i,j));
```

#### 代码

把代码拼一拼就好了，注释放在下面了。


```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long n, m, s;
long long a[1010][1010];
long long dp[1010][1010];//每个点的答案
long long dx[4]={-1, 1, 0, 0}, dy[4]={0, 0, -1, 1};//四个方向
long long ans;//最终答案
long long f(int x, int y) {
    if(dp[x][y]) return dp[x][y];//如果早就找到了，那就直接返回这个答案
    dp[x][y]=a[x][y];//把这个点的答案先初始化成这个点的数
    for(int i=0;i<4;i++){//枚举四个方向
        int nx=x+dx[i], ny=y+dy[i];//坐标
        if (nx>=1 && nx<=n && ny>=1 && ny<=m && a[nx][ny]>a[x][y]){//如果成立
            dp[x][y]=max(dp[x][y], f(nx, ny)+a[x][y]);//看我从哪个方向过来最划算
        }
    }
    return dp[x][y];//返回这个点的答案
}
int main(){
    cin>>n>>m>>s;//输入答案
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			s=(s*345)%19997;//构造方格里面的数
			a[i][j]=(s%10)+1;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)	
			ans=max(ans,f(i,j));//寻找答案
	cout<<ans<<endl;//输出答案
    return 0;//结束程序
}
```

---


# [信息与未来 2016] 素数分解

## 题目描述

素数，又称质数，是指除 $1$ 和其自身之外，没有其他约数的正整数。例如，$2,3,5,7,13$ 都是质数，而 $4,9,12,18$ 则不是。

虽然素数不能分解成除 $1$ 和其自身之外整数的乘积，但却可以分解成更多素数的和。你需要编程求出一个正整数最多能分解成多少个互不相同的素数的和。

## 说明/提示

### 样例 $\textbf 1$ 解释
$21=2+3+5+11$。
### 数据范围
$10\le n\le 200$。

**保证有解。**
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
21```

### 输出

```
4```

## 样例 #2

### 输入

```
128```

### 输出

```
9```

# 题解

## 作者：lizhixun (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/B4141)

### $\texttt{Description}$

给定一个正整数 $n$，求出 $n$ 最多可以分成多少个不同素数的和。

### $\texttt{Solution}$

由于 $n \le 200$，数据范围很小，于是我们直接暴力筛出 $200$ 以内的素数然后 DFS 选或不选即可。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n, k, pr[205], maxn = INT_MIN;

bool prime(int x) {
	if (x < 2) return 0;
	for (int i = 2; i <= x / i; i++) 
		if (x % i == 0) return 0;
	return 1;	
}

void dfs(int step, int sum, int num) {
	if (sum > n) return; // 剪枝
	if (sum == n) {
		maxn = max(maxn, num);
		return;
	}
	if (step == k + 1) return;
	dfs(step + 1, sum, num); // 不选
	dfs(step + 1, sum + pr[step], num + 1); // 选
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	for (int i = 2; i <= 200; i++) {
		if (prime(i) == true) pr[++k] = i;
	}
	
	dfs(1, 0, 0);
	cout << maxn << endl;
	
	return 0;
}
```

---


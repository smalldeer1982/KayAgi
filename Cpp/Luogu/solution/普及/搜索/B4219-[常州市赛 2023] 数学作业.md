# [常州市赛 2023] 数学作业

## 题目背景

搬运自 <http://czoj.com.cn/p/676>。数据为民间数据。

## 题目描述

今天小 X 的数学老师带领大家学习了斐波那契序列：

斐波那契序列指的是这样一个数列：$\{1,2,3,5,8,13,21,34\}$。从第 $3$ 个数开始，每个数都是前两个数的和，比如 $8=3+5,34=13+21$。数列里的数叫做斐波那契数。

一个数 $n$ 的斐波那契表示是指把 $n$ 写成若干个互不相同的斐波那契数的和。一个数可以有多种不同的斐波那契表示。比如 $14$ 有三种斐波那契表示：$14=1+13,14=1+5+8,14=1+2+3+8$。数学老师给小 X 留下了一个数学作业，她告诉小 X 一个正整数 $n$，想让小 X 算出 $n$ 有多少种不同的斐波那契表示。

小 X 请你帮助他完成他的数学作业。

## 说明/提示

|测试点编号|$n$|
|:-:|:-:|
|$1\sim5$|$1\le n\le 10^4$|
|$6\sim8$|$1\le n\le 10^9$|
|$9\sim10$|$1\le n\le 10^{12}$|

## 样例 #1

### 输入

```
14```

### 输出

```
3```

## 样例 #2

### 输入

```
1110```

### 输出

```
21```

## 样例 #3

### 输入

```
1000000000000```

### 输出

```
283392```

# 题解

## 作者：CJR_Rain (赞：2)

思路：预处理 $n$ 以内所有不重复的斐波那契数，然后进行 DFS 枚举所有取或不取的可能。

代码：

```cpp
#include <bits/stdc++.h>

#define IS std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define OS std::cout.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define srnd srand((unsigned int)time(0))
#define rnd rand()
#define save(x) std::fixed << std::setprecision(x)
#define set_0(x) memset(x, 0, sizeof(x))
#define set_false(x) memset(x, false, sizeof(x))
#define set_true(x) memset(x, true, sizeof(x))
#define set_nega1(x) memset(x, -1, sizeof(x))
#define set_Iinf(x) memset(x, 0x7f, sizeof(x))
#define set_Finf(x) memset(x, 7e4, sizeof(x));
#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)
#define low_bit(x) (x & (-x))
#define __DEBUG__ puts("DEBUG")

using namespace std;

vector <long long> fib;

int dfs(int search, long long cnt) {
    
    if(cnt == 0) {
        
        return 1;
    }
    
    int res = 0;
    
    for(int i = search; i < fib.size(); ++i) {
        
        if(cnt - fib[i] < 0) {
            
            return res;
        }
        
        res += dfs(i + 1, cnt - fib[i]);//不降原则保证选数不重复
    }
    
    return res;
}

signed main() {
    
    IS;
    OS;
    
    long long n;
    cin >> n;
    
    fib.push_back(1);
    fib.push_back(2);
    
    while(fib.back() <= n) {
        
        fib.push_back(fib[fib.size() - 1] + fib[fib.size() - 2]);
    }
    
    fib.pop_back();
    
    cout << dfs(0, n);
    
    return 0;
}
```
然而 $10^{12}$ 内不重复的斐波那契数有 $58$ 个，上述代码又是 $O(2^n)$ 级别的时间复杂度，绝对 TLE 。

## 所以我们需要剪枝

剪枝1：设数列 $k$ 包含 $n$ 以内所有不重复的斐波那契数，然后定义一个变量 $sum=\sum{k}$，在 DFS 搜到 $k$ 中第 $i$ 个数时，$sum=sum-k_i$，代表搜完这个数后 $k$ 中还能搜的数之和。那么设 $t$ 等于已经取的数之和，如果 $n-t>sum$，就可以直接剪枝掉了。

得出代码:


```cpp
#include <bits/stdc++.h>

#define IS std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define OS std::cout.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define srnd srand((unsigned int)time(0))
#define rnd rand()
#define save(x) std::fixed << std::setprecision(x)
#define set_0(x) memset(x, 0, sizeof(x))
#define set_false(x) memset(x, false, sizeof(x))
#define set_true(x) memset(x, true, sizeof(x))
#define set_nega1(x) memset(x, -1, sizeof(x))
#define set_Iinf(x) memset(x, 0x7f, sizeof(x))
#define set_Finf(x) memset(x, 7e4, sizeof(x));
#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)
#define low_bit(x) (x & (-x))
#define __DEBUG__ puts("DEBUG")

using namespace std;

vector <long long> fib;//对应k
long long sum_fib = 0;//对应sum

int dfs(int search, long long sum) {//这里跟文中讲得不一样，参数sum = n - t
    
    if(sum <= 0 || sum_fib < sum || search >= fib.size()) {//剪枝1
        
        return sum == 0 ? 1 : 0;
    }
    
    sum_fib -= fib[search];
    int res = dfs(search + 1, sum - fib[search]) + dfs(search + 1, sum);
    sum_fib += fib[search];//利用回溯实现
    
    return res;
}

signed main() {
    
    IS;
    OS;
    
    long long n;
    cin >> n;
    
    fib.push_back(1);
    fib.push_back(2);
    
    while(fib.back() <= n) {
        
        fib.push_back(fib[fib.size() - 1] + fib[fib.size() - 2]);
    }
    
    fib.pop_back();
    
    sum_fib = accumulate(fib.begin(), fib.end(), 0ll);

    cout << dfs(0, n);

    return 0;
}
```

交上去一看，还是 TLE ，为什么？因为 $k$ 是单调递增且增速极快的，我们又是从 $k_1$ 开始一个一个搜，就使得在搜 $k$ 中的前几个数时，$sum$ 相对下降得太慢且 $t$ 相对上升得太慢。这样一来，剪枝形同虚设。

我们可以发现，现在 TLE 的原因是 $k$ 单调递增且增速极快，于是提出剪枝2：将 $k$ 反转，使得 $k$ 的性质变成单调递减且降速极快，并且由于没有改动 $k$ 内元素，答案不变。

得出AC代码:

```cpp
#include <bits/stdc++.h>

#define IS std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define OS std::cout.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define srnd srand((unsigned int)time(0))
#define rnd rand()
#define save(x) std::fixed << std::setprecision(x)
#define set_0(x) memset(x, 0, sizeof(x))
#define set_false(x) memset(x, false, sizeof(x))
#define set_true(x) memset(x, true, sizeof(x))
#define set_nega1(x) memset(x, -1, sizeof(x))
#define set_Iinf(x) memset(x, 0x7f, sizeof(x))
#define set_Finf(x) memset(x, 7e4, sizeof(x));
#define lc(x) (x << 1)
#define rc(x) (x << 1 | 1)
#define low_bit(x) (x & (-x))
#define __DEBUG__ puts("DEBUG")

using namespace std;

vector <long long> fib;//对应k
long long sum_fib = 0;//对应sum

int dfs(int search, long long sum) {//这里跟文中讲得不一样，参数sum = n - t
    
    if(sum <= 0 || sum_fib < sum || search >= fib.size()) {//剪枝1
        
        return sum == 0 ? 1 : 0;
    }
    
    sum_fib -= fib[search];
    int res = dfs(search + 1, sum - fib[search]) + dfs(search + 1, sum);
    sum_fib += fib[search];//利用回溯实现
    
    return res;
}

signed main() {
    
    IS;
    OS;
    
    long long n;
    cin >> n;
    
    fib.push_back(1);
    fib.push_back(2);
    
    while(fib.back() <= n) {
        
        fib.push_back(fib[fib.size() - 1] + fib[fib.size() - 2]);
    }
    
    fib.pop_back();
    
    sum_fib = accumulate(fib.begin(), fib.end(), 0ll);
    reverse(fib.begin(), fib.end());//剪枝2
    
    cout << dfs(0, n);

    return 0;
}
```

---

## 作者：joshua0729 (赞：1)

# B4219 [常州市程序设计小能手 2023] 数学作业 题解
#### [题目传送门](https://www.luogu.com.cn/problem/B4219)
## 思路
先输入 $n$，将小于等于 $n$ 的所有斐波那契数提前初始化好，存在数组中。也可以提前用打表处理好。然后用 DFS 对于每一个斐波那契数进行选或不选的搜索即可。
```cpp
void dfs(int i,int sum){
    if(sum+a[i]==n){
        ans++;
        break;
    }
    dfs(i+1,sum);
    dfs(i+1,sum+a[i]);
}
```
但是，观察一下数据范围：数据范围是 $n\le10^{12}$，而小于等于 $10^{12}$ 的斐波那契数共有大约 $58$ 个，但是我们的算法复杂度为 $O(2^n)$，显然直接就 TLE 了。

于是我们就得想一个优化方法。
## 优化
### 使用前缀和优化
我们可以创建前缀和数组 $h$ 使 $h_i$ 表示数列 $f$ 从 $f_0$ 到 $f_{i-1}$的和，若当前选择的斐波那契数和 $s$ 加上后面所有斐波那契数的和还是小于 $n$，则直接退出搜索。
```cpp
    if(i>=m){
			continue;
		}//我这里是模拟递归
```

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

struct node{
	int i;
	ll s;
};
int main(){
	ll n;
	cin>>n;
	vector<ll> fib;
	if(n>=1){
		fib.push_back(1);
	}
	if(n>=2){
		fib.push_back(2);
		ll a=1,b=2;
		while(1){
			ll c=a+b;
			if(c>n) break;
			fib.push_back(c);//计算数列
			a=b;
			b=c;
		}
	}
	reverse(fib.begin(),fib.end());//反转数列

	int m=fib.size();

	if(m==0){//特判
		if(n==0) cout<<1;
		else cout<<0;
		return 0;
	}
	vector<ll> prefix(m+1,0);//前缀和数组
	for(int i=m-1;i>=0;i--){
		prefix[i]=fib[i]+prefix[i+1];//计算前缀和
	}

	stack<node> st;

	st.push({0,n});//初始化栈

	ll ans=0;

	while(!st.empty()){
		node temp=st.top();
		st.pop();
		int i=temp.i;
		ll s=temp.s;

		if(s==0){//如果s=0，答案+1
			ans++;
			continue;
		}
		if(i>=m){//如果i>=m，跳过
			continue;
		}

		if(fib[i]>s){//如果当前数大于s，将当前数入栈
			st.push({i+1,s});
		}
		else{
			if((i+1<m)?prefix[i+1]<s:0<s){//如果当前数小于s，将当前数入栈，将当前数的下一个数入栈
				st.push({i+1,s-fib[i]});
			}
			else{//如果当前数小于s，将当前数入栈，将当前数的下一个数入栈
				st.push({i+1,s});
				st.push({i+2,s-fib[i]});
			}
		}
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：yuzhonglin (赞：1)

## 解题思路
> **注意：$1 \le n \le 10¹²$**

首先我们要知道如何求解斐波那契数列的第  $n$  项，代码如下。

```cpp
f[1]=f[2]=1;
for(int i=2;i<=60;i++)
{
  f[i]=f[i-1]+f[i-2];
}
```


---


搜索部分非常简单，我们需要记录**目前枚举的斐波那契数的总和 $sum$** 和 **上一个斐波那契数位置（下标） $last$**。需要注意的是，每个斐波那契数只能用一次，所以我们在 for 循环枚举时就需要从在区间 $[1,last-1]$ 里**从大到小**进行枚举，可以看作构建了一个递减的序列，不会重复（方便后面优化）。


```cpp
void dfs(long long sum,int last)
{
  if(sum==n)
  {
    ans++; //计数器累加 
    return; 
  }

  for(int i=last;i>=1;i--) 
  {
    if(sum+f[i]<=n) //基本判断条件 
    {
      dfs(sum+f[i],i-1); //直接记录 i-1 
    }
  }
}

```


---


显然，这样写会超时，时间复杂度已经达到 $O(2^n)$，而 $10¹²$ 中有 $58$ 个斐波那契数，复杂度为 $O(2⁵⁸)$，需要加上剪枝。

当我们从大到小枚举到斐波那契数列中第  $i$  个数，令 $k=f[1]+f[2]+...+f[i-1]$ 那么当 $n-sum>k$ 时就无法继续进行枚举。

## 代码演示


```cpp
#include<bits/stdc++.h>
#define LL long long
#define inf 0x3f3f3f3f
using namespace std;

const int N=1e2+10;
long long n,f[N]={1,1},ss[N]={1,2};
int ans,len;
// f数组为斐波那契数列，ss数组为前缀和数组，len是数组f的长度 

void dfs(long long sum,int last)
{
	if(n-sum>ss[last]) return;
	//剪枝 
	if(sum==n)
	{
		ans++; //计数器累加 
		return; 
	}
	for(int i=last;i>=1;i--)
	{
		if(sum+f[i]<=n) //判断条件 
		{
			dfs(sum+f[i],i-1); 
			//搜索 
		}
	}
}

int main()
{
	cin>>n;
	
	for(int i=2;i<=60;i++)
	{
		f[i]=f[i-1]+f[i-2];
		ss[i]=f[i]+ss[i-1];
		if(f[i]>=n) //大于时，记录长度并退出 
		{
			len=i;
			break;
		}
	}
		
	dfs(0,len); 
	
	cout<<ans<<endl;
	
	return 0;
}


```

---

## 作者：2789617221guo (赞：1)

## 做法
- 斐波那契+DFS+前缀和剪枝。
## 思路
先输入 $n$，将小于等于 $n$ 的所有**斐波那契数**提前初始化好。然后用 DFS 对于每一个斐波那契数进行**选**或**不选**的搜索即可。

由于数据最大为 $n\le 10^{12}$，而小于等于 $10^{12}$ 的斐波那契数共有 58 个左右，但是我们的算法复杂度为 $O(2^n)$，肯定会超时的。

于是我们就得想几个优化思路。

### 剪枝 1：前缀和
我们可以使 $h_i$ 表示斐波那契数列 $f$ 中从 $f_1$ 到 $f_i$ 的和，若当前选择的斐波那契数和 $s$ 加上后面所有斐波那契数的和还是无法达到答案 $n$，则直接退出搜索。
```cpp
if(h[x]-h[t]+s<n) return;//其中x为斐波那契数的个数，t为当前在第几个数
```
但是，这个剪枝方法加上去后，在第三个样例极限数据中还是会超时。我们需要另想他法。
### 剪枝 2：反向搜索
我们可以考虑从第 $x$ 个斐波那契数开始搜索，从大的数往小的数搜索，同样设 $h$ 为前缀和数组，则有如下剪枝条件：若 $h_i+s<n$ 则直接 `return`。因为后面可以搜索的数加上当前的和还是无法达到 $n$，所以不如直接退出循环减少分支。 由于我们是从大到小搜索斐波那契数的，所以我们每次都可以加当前最大的数，减少后面的分支，从而减少了用时。

经过这次剪枝优化后，我们的代码就不会超时了。
## 代码
```cpp
#include <bits/stdc++.h>
#define endl '\n'
#define ll   long long

using namespace std;

const int INF = 0x3f3f3f3f;
const double EPS = 1e-8;

ll n, a[105], h[105], x, ans;

void init() {
    a[1] = 1;
    a[2] = 2;
    h[1] = 1;
    h[2] = 3;
    x = 2;
    for (int i = 3; a[i - 1] <= n; i++) {
        a[i] = a[i - 1] + a[i - 2];
        h[i] = h[i - 1] + a[i];
        x++;
    }
    // cout << x << endl;
}

void dfs(int t, ll s) {
    if (s > n) return;
    if (t == 0) {
        if (s == n) ans++;
        return;
    }
    if (h[t] < n - s) return;
        // 不选
    dfs(t - 1, s);
        // 选
    if (s + a[t] > n) return;
    dfs(t - 1, s + a[t]);
}

int main() {
    cin >> n;
    init();
    dfs(x, 0);
    cout << ans << endl;
    return 0;
}
```
## AC 记录
[AC，用时 40ms，内存 680.00KB。](https://www.luogu.com.cn/record/207891916)

---

## 作者：sfb1363II (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4219)

## Solution

首先我们可以通过第三个样例来大胆猜测答案并不会特别大，写一个 $O(ans)$ 的搜索就能通过这题，其实就是把前 $n$ 个斐波那契数从大到小一个一个尝试搜索。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=70;
int n,len,res;
int a[N],f[N];
void dfs(int dep,int pos){
    if(dep>n) return;
    if(dep==n){
        res++;
        return;
    }
    for(int i=pos;i>=1;i--)
        if(!f[i]&&(n-dep-a[i])<a[i]*2){
            f[i]=1;
            dfs(dep+a[i],i-1);
            f[i]=0;
        }
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    len=3;a[1]=1;a[2]=2;
    while(a[len-1]<=n){
        a[len]=a[len-1]+a[len-2];
        len++;
    }
    dfs(0,len-1);
    cout<<res<<"\n";
    return 0;
}
```

---

## 作者：Moco_jof (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4219)

# 题目大意
给定一个 $n$ ，算出 $n$ 有多少种不同的斐波那契表示。
# 基本思路
- [ ] $50$ 分代码。
- [ ] $100$ 分代码。
## 50分
先把斐波那契序列打表到一个数组里，然后直接粗暴地 DFS。
### 代码

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#define ll long long
using namespace std;
ll ans,n;
vector<ll> fv;
bool cm[65];
void dfs(ll sum,ll t){
    if(sum>n){
        return;
    }
    if(sum==n){
        ++ans;
        return;
    }
    for(ll i=t+1;i<fv.size();++i){
        if(!cm[i]){
            cm[i]=1;
            dfs(sum+fv[i],i);
            cm[i]=0;
        }
    }
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    fv.push_back(1),fv.push_back(2);
    while(fv[fv.size()-1]<=n){
        ll k=fv[fv.size()-1]+fv[fv.size()-2];
        fv.push_back(k);
    }//打表
    dfs(0,-1);
    cout<<ans;
    return 0;
}
```
[记录详情](https://www.luogu.com.cn/record/212240202)

- [x] $50$ 分代码
- [ ] $100$ 分代码
## 100分
来个剪枝，来个前缀和，当前面的比剩下的少时，剪。
### 代码

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#define ll long long
using namespace std;
ll ans,n;
vector<ll> fv;
bool cm[65];
ll num[65];
void dfs(ll len,ll sum){
    if(sum>n){
        return;
    }
    if(num[len]<n-sum){
        return;
    }//剪枝
    if(sum==n){
        ++ans;
        return;
    }
    for(ll i=len;i>=1;--i){
        dfs(i-1,sum+fv[i-1]);
    }
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    fv.push_back(1),fv.push_back(2);
    num[1]=1;
    num[2]=3;
    while(fv[fv.size()-1]<=n){
        ll k=fv[fv.size()-1]+fv[fv.size()-2];
        fv.push_back(k);
        num[fv.size()]=num[fv.size()-1]+k;//前缀和
    }
    dfs(fv.size(),0);
    cout<<ans;
    return 0;
}
```
[记录详情](https://www.luogu.com.cn/record/212257782)

- [x] $50$ 分代码。
- [x] $100$ 分代码。

---

## 作者：liguangjun2023 (赞：0)

#### 解题思路
1. 典型的利用深搜算法求组合数量。
2. 因为数值比较大，必须剪枝。
3. 因为斐波那契数列的增长比较快，前面的小整数比较多，所以从后向前计算，结合前缀和，剪枝的效果比较好。
4. 如果不从后向前剪枝只能得到 $50$ 分，实际上，本题主要难点在于结合斐波那契数列数据的特点，从后向前搜索，考虑剩余数值和进行剪枝操作。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=65;
ll n,ans,a[N],len,nm[N];
void dfs(ll q,ll p,ll sm){
	//常规剪枝
	if(sm>n)
		return;
	//重要剪枝：剩余所有数值和不能满足要求，剪枝。
	if(nm[q]<n-sm)
		return;
	//收集答案
	if(sm==n){
		ans+=1;
		return ;
	}
	for(ll i=q;i>=1;i--){
 		dfs(i-1,p+1,sm+a[i]);
	}
}
int main(){
	cin>>n;
	a[1]=1,	a[2]=2,	nm[1]=1,	nm[2]=3,	len=2;
	for(ll i=3;a[i-1]<=n;i++){
		a[i]=a[i-1]+a[i-2];
		nm[i]=nm[i-1]+a[i];
		len+=1;
	}
	dfs(len,1,0);
	cout<<ans;
	return 0;
}
```

---


# [yLCPC2024] B. 找机厅

## 题目背景

扶苏正在出发去打 mai！

但是商场内部实在太复杂了，她在里面迷路了。已经在地铁站迷路过一次的扶苏看着商场的地图实在是不懂怎么走，你能帮帮她吗？

## 题目描述

给定一个 $n$ 行 $m$ 列的 $01$ 矩阵，记矩阵第 $i$ 行第 $j$ 列的格子是 $(i, j)$（$1 \leq i \leq n$，$1 \leq j \leq m$）。

你要从矩阵的左上角出发到达右下角。行走规则如下：

- 如果你在格子 $(i, j)$，你下一步只能走到：$(i - 1, j)$、$(i + 1, j)$、$(i, j - 1)$、$(i, j + 1)$ 四个格子的其中之一。
- 任意时刻你不能走出这个矩阵，即你的位置 $(i, j)$ 必须时刻满足 $1 \leq i \leq n$，$1 \leq j \leq m$。
- 如果你想从一个格子走到另一个格子，除了满足上述的要求外，还必须保证：这两个格子对应的数字不同。即：写着 $0$ 的格子只能走到写着 $1$ 的格子，反之亦然。

你每走一步就需要花费一个单位的时间。你需要用最短的时间从 $(1, 1)$ 到达 $(n, m)$。除了给出最短时间外，你还必须给出一种可行的最短用时的行走方法。

## 样例 #1

### 输入

```
2
2 2
01
11
2 2
01
10```

### 输出

```
-1
2
RD```

# 题解

## 作者：XingnoYi (赞：10)

**超详细的题解！**

前言：**~~当一个音游人看到这场比赛，他的内心……~~**

**这题调了足足 $3$ 个小时，全是细节错误。**

**要不是 VS Code，我估计这辈子都调不出来。**

如下 `big` 代表 `long long`。
# 思路分析：
## 子问题 $1$：
问题简述：找出起点到终点的最短路径长度。

这应该很好想，就是一道 BFS 的模板题，和 [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) 比较相似。

如果你不会 BFS，可以看一下[概述](https://blog.csdn.net/Arabot_/article/details/129708713)。

## 子问题 $2$：
问题概述：输出该最短路径的行走方式。

在纯 BFS 中应该无法直接回溯找到路径的。
### 1.  $\text{ways}$ 数组：


------------

我们可以加入数组 $\text{ways}[i][j]$，该数组表示**这个格子是由上一个格子从什么方向到达的**，以方便路径逆推。

用样例举例：
```
01
10
```

该图的**一种** $\text{ways}$ 数组表示如下：
```
0 R 
D D
```

你会发现，这幅图最短路径的的走法就是 $(1,1)\to (1,2) \to (2,2)$，即 `RD`。

你也许会问：**这只是起点到终点的走法，那 BFS 最后已经到终点了，怎么用这个数组来找路径呢？**

### 2. 逆推求路径：


------------

想一想，你走到终点了，那只需要从终点开始，记录每个点的 $\text{ways}$ 值，再往反方向走，直到走回起点为止。

这样，只需要将记录的 $\text{ways}$ 值**反向输出**即可。

如何反向输出？

可以用**栈**或**字符串**。

我使用的是栈的方法。

同样地，以该图举例：
```
0 R 
D D
```

1. 最开始我们在 $(2,2)$。
2. 此时，$\text{ways}[i][j] = \text{D}$，我们可以将其压入栈中。
3. `D` 方向的反方向为 `U`，于是我们向上走，回到 $(1,2)$。
4. 重复 $2$ 和 $3$ 操作直到回到 $(1,1)$。

## BFS 函数的代码：
```cpp
void bfs(big sx,big sy) // bfs 模板
{
	queue <Node> q;
	q.push(Node({sx,sy}));
	dis[sx][sy] = 0;
	vis[sx][sy] = 1;
	while(!q.empty())
	{
		Node pos=q.front();
		q.pop();
		if(pos.x == n && pos.y == m)
		{
			printf("%lld\n",dis[n][m]);
            // 因为需要逆序输出，这里用一个栈存储路径。
            // 用字符串反向输出也可以。
            stack <big> st;
            big ex = n,ey = m;
            while((ex != 1) || (ey != 1))
            {
                st.push(ways[ex][ey]); // 正向存储
                big back = (ways[ex][ey]+2)%4; // 反向回溯
                ex += to[back][0], ey += to[back][1]; // 回溯
            }
            while(!st.empty())
            {
                putchar(path[st.top()]); // 反向输出路径
                st.pop();
            }
            putchar('\n');
			return;
		}
		big ax = pos.x, ay = pos.y;
		for(big i = 0;i < 4;i++)
		{
			big nowx = ax+to[i][0], nowy = ay+to[i][1]; 
			if((vis[nowx][nowy] == 0) && (mapp[nowx][nowy] != mapp[ax][ay]) && (1 <= ax && ax <= n && ay >= 1 && ay <= m)) 
            {
                ways[nowx][nowy] = i;
				dis[nowx][nowy] = dis[ax][ay]+1;
				vis[nowx][nowy] = 1;
                q.push(Node({nowx,nowy}));
            }
		}
	}
    // 若没有到终点就无法继续了，说明无解。
    printf("-1\n");
}
```
# 坑点简述：
~~气死我了……~~
## 坑点 $1$： 
关于方向数组，一般有 $2$ 种写法：

1. 用 $2$ 个数组存 $\Delta x$ 和 $\Delta y$。
2. 用 $1$ 个二维数组同时存一个数对 $(\Delta x,\Delta y)$。

当使用第 $2$ 种方向时，一定要注意数组两个维度的定义。

对比如下代码：
```cpp
to[4][2]={1,0,0,1,-1,0,0,-1};
big nowx = ax+to[i][0], nowy = ay+to[i][1]; 
```

```cpp
to[2][4]={1,0,0,1,-1,0,0,-1};
big nowx = ax+to[0][i], nowy = ay+to[1][i]; 
```
乍一看是不是没什么区别？

**其实第一种是对的。**
![](https://cdn.luogu.com.cn/upload/image_hosting/aofhj5n7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/xm28rsc0.png)

看一下 VS Code 中对两种数组的概况描述。

`to[4][2]` 这种定义是一个 $4$ 行 $2$ 列的数组，每行存一个数对 $(\Delta x,\Delta y)$，表示增减值。

而 `to[2][4]` 这种定义是一个 $2$ 行 $4$ 列的数组，每行存一个数组，分别表示 $\Delta x$ 和 $\Delta y$。

很显然，第二种方案的 $(\Delta x,\Delta y)$ 就变成了：
```
(1,-1)
(0,0)
(0,0)
(1,-1)
```
是错误的。

一般来说，我们都会输入 $4$ 个数对，而不是分两行输入，所以我推荐用 $\text{to}[4][2]$ 来存储。

## 坑点 $2$：

多测清空时不要用 `memset()`，也不要直接全部清空。

应该先确定大小再清空。

## 坑点 $3$：

在循环判断是否回到起点时，所用的判断条件为：
```cpp
while((ex != 1) || (ey != 1)) // 坑点3：用或而不是且。
```
不过要很好地避免此类问题，可以用：
```cpp
while(!((ex == 1) && (ey == 1)))
```
# 完整代码：
```cpp
#include <iostream>
#include <queue>
#include <stack>
#define big long long
using namespace std;
struct Node{
	big x,y;
};
big T,n,m,to[4][2]={1,0,0,1,-1,0,0,-1}; // 坑点1：方向数组应用。二维数组应用 [4][2] 而不是 [2][4]。
char path[5]={'D','R','U','L'}; // 方向要对应，为简化代码，采用逆时针存储方向。
big ways[3004][3004],dis[3004][3004];
// ways[i][j] 表示这个格子是由上一个格子从什么方向到达的（以方便路径逆推）。
// dis[i][j] 表示该点到起点的距离。
bool vis[3004][3004],mapp[3004][3004]; // 是否到达过；存地图
void bfs(big sx,big sy) // bfs 模板
{
	queue <Node> q;
	q.push(Node({sx,sy}));
	dis[sx][sy] = 0;
	vis[sx][sy] = 1;
	while(!q.empty())
	{
		Node pos=q.front();
		q.pop();
		if(pos.x == n && pos.y == m)
		{
			printf("%lld\n",dis[n][m]);
            // 因为需要逆序输出，这里用一个栈存储路径。
            // 用字符串反向输出也可以。
            stack <big> st;
            big ex = n,ey = m;
            while((ex != 1) || (ey != 1)) // 坑点3：用或而不是且。
            {
                st.push(ways[ex][ey]); // 正向存储
                big back = (ways[ex][ey]+2)%4; // 反向回溯
                ex += to[back][0], ey += to[back][1]; // 回溯
            }
            while(!st.empty())
            {
                putchar(path[st.top()]); // 反向输出路径
                st.pop();
            }
            putchar('\n');
			return;
		}
		big ax = pos.x, ay = pos.y;
		for(big i = 0;i < 4;i++)
		{
			big nowx = ax+to[i][0], nowy = ay+to[i][1]; 
			if((vis[nowx][nowy] == 0) && (mapp[nowx][nowy] != mapp[ax][ay]) && (1 <= ax && ax <= n && ay >= 1 && ay <= m)) 
            {
                ways[nowx][nowy] = i;
				dis[nowx][nowy] = dis[ax][ay]+1;
				vis[nowx][nowy] = 1;
                q.push(Node({nowx,nowy}));
            }
		}
	}
    // 若没有到终点就无法继续了，说明无解。
    printf("-1\n");
}
int main()
{
    scanf("%lld\n",&T);
    while(T--)
    {
        scanf("%lld %lld\n",&n,&m);
        // 坑点2：先输入再清空，降低复杂度。
        for(big i = 0;i <= n;i++)
        {
            for(big j = 0;j <= m;j++)
            {
                vis[i][j] = 0;
                dis[i][j] = ways[i][j] = 0;
            }
        }
	    for(big i = 1;i <= n;i++)
	    {
	    	for(big j = 1;j <= m;j++)
            {
                // 注意读入 '\n' 导致答案错误
                char ch = getchar();
				while(ch != '0' && ch != '1')
                {
                    ch = getchar();
                }
				mapp[i][j] = ch-'0';
            }
	    }
        if((mapp[n-1][m] == mapp[n][m]) && (mapp[n][m-1] == mapp[n][m])) // 小小优化
        {
            printf("-1\n");
            continue;
        }
        bfs(1,1);
    }
	return 0;
} 
```

---

## 作者：Unpretentious_Day (赞：5)

题目链接：[P10234 [yLCPC2024] B. 找机厅](https://www.luogu.com.cn/problem/P10234) 

# 题目简述

给定一个 $n$ 行 $m$ 列的 $01$ 矩阵，记矩阵第 $i$ 行第 $j$ 列的格子是 $(i,j)$。

要从 $(1,1)$ 走到 $(n,m)$，行走时只能向四个方向走，不能走出矩阵，且当移动时需保证：当前格子与将要走到的格子所对应的数不同。每走一步花费一个单位的时间，求可行方案的最短用时。

# 分析

~~这种题不一眼就是搜索题吗？~~

这道题既然是让我们求最短用时，显然是需用 BFS 解决。BFS 的搜索过程是一层一层向外拓展，因此非常适合最少用时问题。

在使用 BFS 搜索途中，我们可以使用 `past[i][j]` 来记录 $(i,j)$ 的上一个经过的点。同时，需要一个 `vis[i][j]` 用来标记 $(i,j)$ 是否访问过。最后搜索完毕后，如果可以，我们就可以利用 `past[i][j]` 倒序输出方案。

# 易错点

1. 不能使用 `string` 记录路径，否则内存会爆。
2. 相信有人会疑问为什么要用 `past` 数组倒序记录路径，而不正序记录？如果正序记录，则会出现一个格子走向若干个格子的情况，但如果用倒序，则不会出现这种情况。
3. 对 `vis` 数组初始化应用循环，而不是用 `memset` 初始化。如果使用 `memset`，你会意外地发现超时了。原因：`memset` 是对整个指定范围进行字节填充，但是 `vis` 数组太大。因此我们只需对需要使用的部分初始化。

# Code: 

完整代码：

```cpp 
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e3 + 5;
struct node {
	int x, y;
	node(int xx = 0, int yy = 0) {
		x = xx, y = yy;
	}
};
node past[maxn][maxn]; //记录上一个经过的点
int n, m, tox[6] = { 1, -1, 0, 0 }, toy[6] = { 0, 0, 1, -1 };
bool Map[maxn][maxn]; //由于是01矩阵，因此bool型足矣
int cnt[maxn][maxn], vis[maxn][maxn]; //cnt[i][j]:到(i,j)的时间
inline char getdir(int tx, int ty) { //通过坐标差转换成方向
	if (tx == -1 && !ty) return 'U';
	if (tx == 1 && !ty) return 'D';
	if (!tx && ty == -1) return 'L';
	if (!tx && ty == 1) return 'R';
}
queue<node>q;
inline void Print(node x){ //倒序输出
	string ans = "";
	printf("%d\n",cnt[x.x][x.y]);
	while(past[x.x][x.y].x != -1 && past[x.x][x.y].y != -1){
		node p = past[x.x][x.y];
		ans += getdir(x.x - p.x, x.y - p.y);
		x = p;
	}
	for(int i = ans.size() - 1; i >= 0; --i){
		printf("%c",ans[i]);
	}
	printf("\n");
}
inline void bfs() {
	q.push(node(1, 1));
	past[1][1] = node(-1, -1);
	vis[1][1] = 1;
	while (!q.empty()) {
		node now = q.front();
		q.pop();
		if(now.x == n && now.y == m){ //已到达
			Print(now);
			return;
		}
		for (int i = 0; i < 4; ++i) { //向四个方向行走
			int tx = now.x + tox[i], ty = now.y + toy[i];
			if (tx >= 1 && tx <= n && ty >= 1 && ty <= m) {
				//判断边界
				if(Map[now.x][now.y] != Map[tx][ty]){
					//检查两个格子的值是否不相同
					if (!vis[tx][ty]) {
						//检查是否访问过
						vis[tx][ty] = 1;
						cnt[tx][ty] = cnt[now.x][now.y] + 1;
						past[tx][ty] = now;
						q.push(node(tx, ty));
					}
				}
			}
		}
	}
	printf("-1\n");
}
inline void solve() {
	int t;
	scanf("%d", &t);
	while (t--) {
		char x;
		scanf("%d%d", &n, &m);
		//由于是多组数据，所以需要对vis初始化
		for(int i = 1; i <= n; ++i)
			for(int j = 1; j <= m; ++j)
				vis[i][j] = 0;
		for (int i = 1; i <= n; ++i)
			for (int j = 1; j <= m; ++j) {
				scanf(" %c", &x);
				Map[i][j] = x == '1' ? 1 : 0;
			}
		//小小的特判
		if ((Map[1][1] == Map[1][2] && Map[1][1] == Map[2][1]) || (Map[n][m] == Map[n - 1][m] && Map[n][m] == Map[n][m - 1])) {
			printf("-1\n");
			continue;
		}
		bfs();
		while (!q.empty())
			q.pop();
	}
}
int main() {
	solve();
	return 0;
}
```

---

## 作者：xhhhh36 (赞：4)

[传送门](https://www.luogu.com.cn/problem/P10234)

用 bfs 解决。从 $(1,1)$ 为起点，$(n,m)$ 为终点，每次走到和当前点不同的点。开一个 $ans$ 数组，存走过的路径。如果能走到终点，就从终点的 $ans$ 数组回溯到起点，再输出路径。如果不能就输出无解。

tips：为了防止多组数据卡常，$vis$ 数组可以开一个时间戳。
# AC code
```cpp
#include <bits/stdc++.h>
#define pa pair<int,int>
#define x first
#define y second
using namespace std;
int t,n,m,a[2005][2005],tmp[2005][2005],q,cnt,ans[2005][2005];
int v[2005][2005];
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0};
void ask(int n,int m)
{
	if (n==1&&m==1) return;
	ask(n-dx[tmp[n][m]],m-dy[tmp[n][m]]);
	if (tmp[n][m]==0) cout<<"R";
	else if (tmp[n][m]==1) cout<<"L";
	else if (tmp[n][m]==2) cout<<"U";
	else cout<<"D";
}
void bfs()
{
	queue<pa> q;
	q.push({1,1});
	++cnt;
	ans[1][1]=0;
	ans[n][m]=-1;
	while (!q.empty())
	{
		pa t=q.front();
		q.pop();
		for (int i=0;i<4;i++)
		{
			int xx=t.x+dx[i],yy=t.y+dy[i];
			if (xx>0&&xx<=n&&yy>0&&yy<=m&&v[xx][yy]!=cnt&&a[t.x][t.y]!=a[xx][yy])
			{
				q.push({xx,yy});
				ans[xx][yy]=ans[t.x][t.y]+1;
				v[xx][yy]=cnt;
				tmp[xx][yy]=i;
			}
		}
	}
	cout<<ans[n][m]<<endl;
	if (ans[n][m]!=-1)
	{
		ask(n,m);
		cout<<endl;
	}
}
signed main()
{
	cin>>t;
	while (t--)
	{
		cin>>n>>m;
		for (int i=1;i<=n;i++)
		{
			for (int j=1;j<=m;j++)
			{
				char b;
				cin>>b;
				a[i][j]=b-'0';
			}
		}
		bfs();
	}
	return 0;
}
```

---

## 作者：xiaoshumiao (赞：3)

一道 BFS 板子题，和 P1135 有点像，只不过多了一维。

有一个问题，就是怎么记录路线？

也比较简单，就是开一个 $to_{i,j}$ 记录是从哪个方向到 $(i,j)$ 的（$\texttt{D,U,L,R}$）。BFS 的时候记录即可。输出时从 $to_{n,m}$ 倒序输出。

核心代码：
```cpp
const int N=2010,dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
const char g[4]={'D','U','R','L'};
int n,m,mp[N][N]; bool vis[N][N]; char to[N][N];
struct P { int x,y,d; };
void print(int x,int y) {//输出，这里使用了递归
  if(x==1&&y==1) return;
  if(to[x][y]=='R') print(x,y-1);
  if(to[x][y]=='L') print(x,y+1);
  if(to[x][y]=='U') print(x+1,y);
  if(to[x][y]=='D') print(x-1,y);
  printf("%c",to[x][y]);
}
int bfs() {
  queue<P>q; q.push((P){1,1,0});
  while(!q.empty()) {
	P p=q.front(); q.pop();
	if(p.x==n&&p.y==m) return p.d;//到达终点
	for(int i=0;i<4;i++) {
	  int x=p.x+dx[i],y=p.y+dy[i];
	  if(x>=1&&x<=n&&y>=1&&y<=m&&mp[p.x][p.y]!=mp[x][y]&&!vis[x][y])
		vis[x][y]=true,to[x][y]=g[i],q.push((P){x,y,p.d+1});//记录 to 数组
    }
  }
  return -1;
}
```

---

## 作者：Guizy (赞：3)

求最短用时就不细讲了，只讲如何存路径。

对于搜到的每一个点，开一个 $lst$ 数组，$lst_{x,y}$ 表示 到 $(x,y)$ 的最优解的上一步是从哪里走过来的。输出路径的时候用递归就行。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int Max=3001;
int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
int _,n,m,a[Max][Max];

char ch[Max][Max];
bool vis[Max][Max];
string str;

struct node{
    int x,y,step;
}lst[Max][Max];

void print(int nx,int ny){//递归求路径
    if(nx==1&&ny==1) return;//到起点就返回
    else{
        int xx=lst[nx][ny].x,yy=lst[nx][ny].y;
        print(xx,yy);
        if(xx-nx==-1) putchar('D');
        if(xx-nx==1)  putchar('U');
        if(yy-ny==-1) putchar('R');
        if(yy-ny==1)  putchar('L');
    }
}

void bfs(){//正常 BFS 模板
    queue<node>q;
    q.push({1,1,0});
    vis[1][1]=1;
    while(!q.empty()){
        node temp=q.front(); q.pop();
        if(temp.x==n&&temp.y==m){
            printf("%d\n",temp.step);
            print(n,m); printf("\n");
            return ;
        }
        for(int i=0;i<4;i++){
            int tx=temp.x+dx[i],ty=temp.y+dy[i];
            if(a[tx][ty]!=a[temp.x][temp.y]&&tx>0&&ty>0&&tx<=n&&ty<=m&&!vis[tx][ty]){
                vis[tx][ty]=1;
                lst[tx][ty]={temp.x,temp.y,0};//记录 lst 数组
                q.push({tx,ty,temp.step+1});
            }
        }
    }
    puts("-1");
}

int main(){
    
    scanf("%d",&_);
    while(_--){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                vis[i][j]=0;
            }
        }
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                cin>>ch[i][j],a[i][j]=ch[i][j]-'0';
        bfs();
    }

    return 0;
}
```

---

## 作者：Walrus (赞：1)

显然用 bfs 解决，只需要记录路径，最后直接输出即可，不需要二次 bfs。注意最后是倒着走回去的。其实难点就在输出路径上，其他都是板子。

处理：
```cpp
q.push({1, 1});
ans[1][1] = 0;
while(q.size()) {
	int x = q.front().fir,
		y = q.front().sec;
	q.pop();
	if(vis[x][y])
		continue;
	vis[x][y] = 1;
	for(int i = 0; i < 4; ++i) {
		int X = x + dx[i], Y = y + dy[i];
		if(!(vis[X][Y] || X <= 0 || Y <= 0 || X > n || Y > m || c[x][y] == c[X][Y]))
			ans[X][Y] = ans[x][y] + 1, pre[X][Y] = i, q.push({X, Y});
	}
}
```
路径：
```cpp
string res;
mp[0] = 'R', mp[1] = 'L', mp[2] = 'D', mp[3] = 'U';
int xx = n, yy = m;
while(xx != 1 || yy != 1) {
	if(pre[xx][yy] == 0)
		res += mp[pre[xx][yy]], --yy;
	else if(pre[xx][yy] == 1)
		res += mp[pre[xx][yy]], ++yy;
	else if(pre[xx][yy] == 2)
		res += mp[pre[xx][yy]], --xx;
	else
		res += mp[pre[xx][yy]], ++xx;
}
reverse(res.begin(), res.end());
cout << res << '\n';
```

理论上是不会 T 的，T 在 #3 的人多半是因为多组数据 bfs 没弄 $vis$ 时间戳导致的（赛时 11 发的经验），而不是某些题解说的什么字符串导致的。

---

## 作者：Zhuluoan (赞：1)

## 题目简述
给定一个 $n$ 行 $m$ 列的 $01$ 矩阵，每次可以花费 $1$ 的时间移动到邻近的上下左右的四个格子，求从 $(1,1)$ 点到 $(n,m)$ 的最少时间，并给出具体路径。

## 题目分析
### 第一问
易发现是 BFS 模板题，在这里不多说。

### 第二问
我们首先考虑正着记录，即记录每一个点转移到了哪一个点，但是我们发现并不可行，因为它的下个点并不唯一。于是我们反着考虑，定义 $pre_{i,j}$ 为**这个格子是从哪一个点转移过来的**，由 BFS 的过程可知，$pre_{i,j}$ 是唯一的。

接下来就好做了，我们可以从终点回溯到起点，用一个循环即可，但要注意的是方向要反着来，因为是从终点往回走。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+10,INF=99999999;
int n,m,a[N][N],dis[N][N],vis[N][N],t;
pair<int,int> pre[N][N];
queue<pair<int,int>> q;
int tx[4]={1,-1,0,0};
int ty[4]={0,0,1,-1};
string s;
stack<char> path;
void solve()
{
    cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		for(int j=1;j<=m;j++)
		{
			a[i][j]=s[j-1]-'0';
			dis[i][j]=INF;
			vis[i][j]=0;
		}
	} 
	q.push({1,1});
	dis[1][1]=0;
	while(!q.empty())//BFS
	{
		
		int x=q.front().first;
		int y=q.front().second;
		q.pop();
		for(int i=0;i<4;i++)
		{
			int nx=x+tx[i];
			int ny=y+ty[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&a[x][y]!=a[nx][ny]&&!vis[nx][ny])
			{
				vis[nx][ny]=1;
				dis[nx][ny]=dis[x][y]+1;
				pre[nx][ny]={x,y};//记录
				q.push({nx,ny});
			}
		}
	}
	cout<<(dis[n][m]==INF?-1:dis[n][m])<<"\n";
	if(dis[n][m]==INF) return;
	int x=n,y=m;
	while(!(x==1&&y==1))//注意不是x!=1&&y!=1
	{
		int nx=pre[x][y].first;
		int ny=pre[x][y].second;
		if(nx==x-1&&ny==y) path.push('D');
		if(nx==x+1&&ny==y) path.push('U');
		if(nx==x&&ny==y-1) path.push('R');
		if(nx==x&&ny==y+1) path.push('L');
		x=nx,y=ny;
	}
	while(!path.empty())//用栈输出
	{
		cout<<path.top();
		path.pop();
	}
	cout<<"\n";
	return;
}
int main()
{
	ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>t;
    while(t--)
    {
    	solve();
	}
	return 0;
}
```

---

## 作者：InversionShadow (赞：1)

第一眼 bfs 模板，第二眼记录不对劲。

把 bfs 板子套上，重点是怎么记录路径。如果用 `string` 的话会 MLE 或 TLE 在第三个点。所以我们要用 `char` 记录。具体地，如果当前 $(x,y)$ 可以移动到 $(nx,ny)$，那么我们记录一个 $id$ 数组，表示从 $(x,y)$ 到 $(nx,ny)$ 是 `U` 还是 `D` 以及 `L` 和 `R`。

统计答案的时候就从 $(n,m)$ 反向“回溯”到 $(1,1)$，具体实现可以看代码。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e3 + 100;

const int dx[] = {1, -1, 0, 0};
const int dy[] = {0, 0, 1, -1};

int t, n, m, inf, dis[N][N], id[N][N];
char c[N][N], ans[N][N];
bool vis[N][N];
//string ans[N][N];

struct Node {
  int x, y;
};

queue<Node> q;
stack<char> s;

void bfs() {
  while (!q.empty()) {
    q.pop(); 
  }
  q.push({1, 1});
  dis[1][1] = 0;
  while (!q.empty()) {
    auto u = q.front();
    q.pop();
    for (int i = 0; i < 4; i++) {
      int nx = u.x + dx[i];
      int ny = u.y + dy[i];
      if (nx >= 1 && ny >= 1 && nx <= n && ny <= m && c[u.x][u.y] != c[nx][ny] && !vis[nx][ny]) {
        dis[nx][ny] = dis[u.x][u.y] + 1;
        q.push({nx, ny});
        id[nx][ny] = i;
        vis[nx][ny] = 1;
      }
    }
  }
}

void solve() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> c[i][j];
      dis[i][j] = 1e9;
      vis[i][j] = 0;
    }
  }
  inf = dis[1][1];
  bfs();
  if (dis[n][m] == inf) { 
    cout << "-1\n";
    return ;
  }
  cout << dis[n][m] << endl;
  int nowx = n, nowy = m;
  while (!s.empty()) {
    s.pop();
  }
  while (1) {
    if (nowx == 1 && nowy == 1) {
      break;
    }
    int p = id[nowx][nowy]; // 对应字符串数组
    // bfs 中时从 (x,y) 到 (nx,ny) 是怎么走的，现在就是从 (nx,ny) 回到 (x,y)，所以要用减法
    if (p == 0) s.push('D');
    if (p == 1) s.push('U');
    if (p == 2) s.push('R');
    if (p == 3) s.push('L');
    int lx = dx[p], ly = dy[p];
    nowx -= lx, nowy -= ly;
  }
  while (!s.empty()) { // 反向输出
    cout << s.top();
    s.pop();
  }
  cout << '\n';
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> t;
  while (t--) {
    solve();
  }
  return 0;
}
```

---

## 作者：CaiZi (赞：1)

## [yLCPC2024] 找机厅 题解
**[题目链接](https://www.luogu.com.cn/problem/P10234)**
### 题意理解
给定一个 $01$ 矩阵，每次可以向 $4$ 个方向走，但走到的位置的数字必须和当前的位置的数字不同，求从 $(1,1)$ 到 $(n,m)$ 的最短路和行走方案。
### 题目分析
本题没有边权，如果没有 $01$ 矩阵限制，显然直接跑一遍 BFS 即可。有了 $01$ 矩阵限制，那么就在入队的时候判断就好了。

至于行走方案，我们对每个位置记录下走到该位置的方向，然后用 DFS 从 $(n,m)$ 推到 $(1,1)$ 再反向输出即可。
### 代码展示
时间复杂度 $O(\sum n\times m)$，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,dis[2001][2001],x,y,dx[]={1,0,-1,0},dy[]={0,1,0,-1},fx,fy;
bitset<2001>q[2001];
char s;
pair<int,int>path[2001][2001];
queue<pair<int,int>>g;
inline void dfs(int a=n,int b=m){
	if(a==1&&b==1){
		return;
	}
	dfs(a-path[a][b].first,b-path[a][b].second);
	if(path[a][b].first==1){
		putchar('D');
	}
	else if(path[a][b].first==-1){
		putchar('U');
	}
	else if(path[a][b].second==1){
		putchar('R');
	}
	else{
		putchar('L');
	}
	return;
}
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d %d",&n,&m);
		for(int i=1;i<=n;i++){
			getchar();
			for(int j=1;j<=m;j++){
				s=getchar();
				q[i][j]=s-'0';
				dis[i][j]=INT_MAX;
			}
		}
		g.push(make_pair(1,1));
		dis[1][1]=0;
		while(!g.empty()){
			x=g.front().first;
			y=g.front().second;
			g.pop();
			for(int i=0;i<=3;i++){
				fx=x+dx[i];
				fy=y+dy[i];
				if(q[fx][fy]!=q[x][y]&&1<=fx&&fx<=n&&1<=fy&&fy<=m&&dis[fx][fy]==INT_MAX){
					dis[fx][fy]=dis[x][y]+1;
					path[fx][fy]=make_pair(dx[i],dy[i]);
					g.push(make_pair(fx,fy));
				}
			}
		}
		if(dis[n][m]==INT_MAX){
			printf("-1\n");
		}
		else{
			printf("%d\n",dis[n][m]);
			dfs();
			putchar('\n');
		}
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/150145757)**

---

## 作者：封禁用户 (赞：1)

## 思路
裸的 $01$ 迷宫，代码在下面哦！就是用广度优先搜索稳定搜索，~~有的同志就用深度优先搜索老是超时~~。

-----

但既然非要讲的话，那我就讲讲关于这道题的广度优先搜索吧。

首先，我们要将输入的字符串转化为数字。紧接着我们就要开始搜索了（谨记，要判断 $n$ 与 $m$ 是否都是 $1$，如果是，那么就直接输出 $0$）。

在搜索中，我们要有存储坐标 $(x,y)$、步数 $(step)$、自己是从谁那里拓展来的 $(pre)$ 以及当前走的方向 $(dire)$。

好，这样的话，我们就可以从初始状态 $(x = y = 1)$。开始枚举每一个方向，只要值异或之后与其相等，那么可以走，所以这里要么是终点，要么不是终点。如果是，那么就输出存的步数。然后倒着递归输出其路径。如果不是终点的话，那么就拓展我们前面所说的所有状态。


## 代码

非常的简单，但要是实在要看，~~那我也没有办法~~。

```cpp

#include<bits/stdc++.h>
using namespace std;
struct node
{
	int x , y;
	int step;
	int pre;
	char sx;//当时脑抽随便想的名字
}answer[4000001];
char f1[2001][2001];
int f[2001][2001];
bool vis[2001][2001];
int n , m;
int dx[] = {0 , 0 , 1 , -1};
int dy[] = {-1 , 1 , 0 , 0};
void DG(int t)//裸的回溯输出
{
	if(t == -1)
	return ;
	DG(answer[t].pre);
	if(answer[t].sx != 'P')
	cout << answer[t].sx;
}
void bfs()//裸的
{
	answer[1].step = 0;
	answer[1].x = 1;
	answer[1].y = 1;
	answer[1].pre = -1;
	answer[1].sx = 'P';
	int st = 1 , op = 1;
	while(st <= op)
	{
		for(int i = 0;i < 4;++ i)
		{
			int tx = answer[st].x + dx[i];
			int ty = answer[st].y + dy[i];
			if(tx && tx <= n && ty && ty <= m && !vis[tx][ty] && f[tx][ty] == (f[answer[st].x][answer[st].y] ^ 1))
			{
				vis[tx][ty] = true;
				if(tx == n && ty == m)
				{
					cout << answer[st].step + 1 << endl;
					DG(st);
					if(dx[i] == -1)
					cout << 'U';
					else if(dx[i] == 1)
					cout << 'D';
					else if(dy[i] == -1)
					cout << 'L';
					else 
					cout << 'R';
					return ;//递归找路径
				}
				else
				{
					++ op;//裸的
					answer[op].step = answer[st].step + 1;
					answer[op].x = tx;
					answer[op].y = ty;
					answer[op].pre = st;//记录前导
					if(dx[i] == -1)
					answer[op].sx = 'U';
					else if(dx[i] == 1)
					answer[op].sx = 'D';
					else if(dy[i] == -1)
					answer[op].sx = 'L';
					else 
					answer[op].sx = 'R';//记录路径
				}
			}
		}
		++ st;
	}
	cout << -1;
}
int main()
{
	int t;
	cin >> t;
	while(t --)
	{
		cin >> n >> m;
		memset(vis , 0 , sizeof(vis));
		for(int i = 1;i <= n;++ i)
		{
			for(int j = 1;j <= m;++ j)
			{
				cin >> f1[i][j];
				f[i][j] = (f1[i][j] & 15);
			}
		}
		vis[1][1] = true;
		if(n == 1 && m == 1)//裸的预处理
		{
			cout << 0;
			continue;
		}
		bfs();
		cout << endl;
	}
    return 0;//裸的 return 0;
}
```
~~记得点个赞哩~~

---

## 作者：jqQt0220 (赞：0)

看到“最短用时”，第一时间想到 bfs。

bfs 大部分应该都会写，所以主要难点在求路径。我们可以用 pair 或者结构体存一个坐标，然后存每个点的前缀，最后用栈从最后倒推输出就行了。这里存前缀可以直接用二维数组或者用 map。

很丑的赛时代码：
```cpp
/*
皇帝的新缺省源
*/
struct pos//这里采用结构体存坐标
{
    int x,y;
    pos(){}
    pos(int _x,int _y):x(_x),y(_y){}//构造函数，冒号后面的就与 x=_x,y=_y 等价
};
bool operator==(pos _x,pos _y){return _x.x==_y.x&&_x.y==_y.y;}
bool operator!=(pos _x,pos _y){return !(_x==_y);}
const int _mxn=2e3+5;
pos pre[_mxn][_mxn];//存前缀的数组
int n,m,a[_mxn][_mxn];
int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
bool vis[_mxn][_mxn];
int as;
void bfs(int sx,int sy)//正式开始搜索
{
    queue<pos> q;
    pos nw(sx,sy);
    q.push(nw),vis[nw.x][nw.y]=true;
    while(!q.empty())
    {
        nw=q.front();q.pop();
        if(nw==pos(n,m))//到了
        {
            stack<pos> path;//栈存路径
            path.push(nw);
            while(nw!=pos(1,1))//往前推
            {
                nw=pre[nw.x][nw.y];
                path.push(nw);
            }
            cout<<path.size()-1<<endl;//输出时间
            int x,y;
            int tx=path.top().x,ty=path.top().y;path.pop();
            while(!path.empty())//输出路径
            {
                x=tx,y=ty;
                tx=path.top().x,ty=path.top().y;path.pop();
                if(pos(x-1,y)==pos(tx,ty))
                    cout<<"U";
                if(pos(x+1,y)==pos(tx,ty))
                    cout<<"D";
                if(pos(x,y-1)==pos(tx,ty))
                    cout<<"L";
                if(pos(x,y+1)==pos(tx,ty))
                    cout<<"R";
            }
            cout<<endl;
            return;
        }
        for(int i=0;i<4;i++)//遍历四个方向
        {
            pos nx(nw.x+dx[i],nw.y+dy[i]);
            if(nx.x<1||nx.x>n||nx.y<1||nx.y>m)//越界
                continue;
            if(vis[nx.x][nx.y])//走过了
                continue;
            if(a[nw.x][nw.y]!=a[nx.x][nx.y])//俩格子不同
            {
                pre[nx.x][nx.y]=nw;//前缀存上
                q.push(nx),vis[nx.x][nx.y]=true;//进队列，标访问
            }
        }
    }
    cout<<-1<<endl;//到不了
}
int main()
{
    ___();
    int _;//数据组数
    cin>>_;
    while(_--)
    {
        cin>>n>>m;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
            {
                char c;
                cin>>c;
                a[i][j]=c-'0';
                vis[i][j]=false;//一块直接初始化（多测不清零，爆零两行泪）
            }
        bfs(1,1);//开搜
    }
    return 0;//完美结束 QwQ
}
```

[赛时交了 11 发才过（](https://www.luogu.com.cn/record/list?pid=P10234&user=678175&contestId=159440)

---

## 作者：Flaw_Owl (赞：0)

# 题目分析

对我来说，看到题目第一件事要做的就是找到题目关键词，然后开始**缝合模板**。

我们不难发现整道题目的中心是“从地图的左上角走到地图的右下角”，并且行动方式是“上下左右移动”。看起来非常像 **BFS**。

# 思考 BFS

在 BFS 的基础上，我们进一步去找行动条件：“这两个格子对应的数不同”。你当然可以去写一个函数来用简单的 `if` 语句判断，但由于本题的地图只有 $0$ 和 $1$ 两种数字，更简单的做法是利用**异或**，即你新走到的地块数字和你原来地块的数字的异或值为 $1$，写法会更加精简。

## BFS 板子

```cpp
// 代码仅展示 BFS 相关的关键代码。
#include <queue>
#include <tuple>

const int maxN = 2e3 + 5;

int T;
int n, m;

// 定义方向数组
const int dirX[4] = {0, 0, 1, -1};
const int dirY[4] = {1, -1, 0, 0};

int a[maxN][maxN];    // 地图
bool vis[maxN][maxN]; // 记录访问过的节点

// 判断是否越过边界
bool inBounds(int x, int y)
{
    return x >= 1 && x <= n && y >= 1 && y <= m;
}

// BFS
void BFS()
{
    // 用 tuple 三元组存储 { x 坐标， y 坐标，花费时间}
    queue<tuple<int, int, int>> q;
    q.push({1, 1, 0});
    vis[1][1] = true;
    while (!q.empty())
    {
        int x, y, time;
        tie(x, y, time) = q.front();
        q.pop();

        // 向上下左右四个方向延拓
        for (int i = 0; i < 4; i++)
        {
            int newX = x + dirX[i];
            int newY = y + dirY[i];
            if (inBounds(newX,newY) && a[newX][newY] ^ a[x][y] && !vis[newX][newY])
            {
                // 到达终点，这里因为已经走了一步了，实际上时间要 +1
                if (newX == n && newY == m)
                {
                    printf("%lld\n", time + 1);
                    return;
                }
                vis[newX][newY] = true;
                q.push({newX, newY, time + 1});
            }
        }
    }
    printf("-1\n"); // 走不到要输出 -1
}
```

值得注意的是，为了严谨，我们应当考虑题目的临界条件：如果 $n$ 和 $m$ 都恰好为 $1$，也就是起点恰好和终点重合，我们应当如何输出呢？不过这道题的描述部分没有给出解释，经过我的测试它也不作为一个测试点。但大家还是要在做题的时候保持对临界条件的敏感性。

# 如何输出题目的路径

测试之后，我们的 BFS 板子准确无误。那么我们来到了题目的第二问难点：如何输出这个最短用时的路径？显然，BFS 不能通过回溯找到每次的走法。说到回溯，我们可以考虑 DFS，但是 DFS 不够快，很有可能 TLE。

一种思考方式是，我们将 `tuple` 扩展为四元组，额外增加一个字符串用于记录每一个节点的走法，在最后的时候输出即可。然而，无论如何进行优化，仍然会出现 TLE 的问题。这是因为写入字符串本身就会占用时间，而从一个点到其他的点的路径非常多，如果在“**碰壁**”的过程中记录字符串，难免超时。

因此，我们又回到了原点：如何在 BFS 的基础上，通过回溯来找到当前这个解法的路径？我的思路是由链表启发而来：链表的每个节点都会存在两个指针，一个指向前一个节点，一个指向后一个节点。我们利用这种设计，存储每一次合法走法的前一步，这样就可以达到回溯的目的。要注意倒序输出，所以我们可以引入一个栈来解决。

## 回溯

```cpp
// 代码仅展示回溯路径相关的关键代码。
#include <stack>

const string temp = "ULDR"; // 与方向数组一一对应

// 用三元组tuple记录每一个地块的前一个地块
// 参数分别为{x 坐标，y 坐标，方向}
// 其中方向表示从前一个地块到达当前地块的朝向
tuple<int, int, int> pre[maxN][maxN];

stack<char> st;

void path(int x, int y)
{
    // 用栈来记录每一步的路径
    while (!(x == 1 && y == 1))
    {
        int nowX, nowY, turn;
        tie(nowX, nowY, turn) = pre[x][y];
        st.push(temp[turn]);
        x = nowX;
        y = nowY;
    }
    // 输出
    while(!st.empty())
    {
        putchar(st.top()); // 用 putchar() 优化输出
        st.pop();
    }
    printf("\n");
}
  
// ……省略 BFS 的部分代码
        for (int i = 0; i < 4; i++)
        {
            // ……
            if (inBounds(newX, newY) && a[newX][newY] ^ a[x][y] && !vis[newX][newY])
            {     
                pre[newX][newY] = {x, y, i}; // 记录上一步的走法
                if (newX == n && newY == m)
                {
                    printf("%lld\n", time + 1);
                    path(n, m); // 输出路径
                    return;
                }
                // ……
            }
        }
```

写到这里，本题就基本完成了。我们也可以愉快地给这道题定性：**基础 BFS + 回溯写法**~~（名字是我乱起的）~~

# 易错点

下面给出笔者在不断的 WA 中发现的一些易错点，不仅针对这一题，在其他的类似题中也非常容易出错。

## 方向数组要与方向表示一一对应

指的是代码中如下的部分：

```cpp
const int dirX[4] = {-1, 0, 1, 0};
const int dirY[4] = {0, -1, 0, 1};
const string temp = "ULDR";
```

因为在数学二维坐标系中（也是现实中）原点在左下角，而数组表示中原点在左上角，对笔者来说非常容易搞混，是值得格外注意的地方。而这里的方向数组是数组的表示（原点在左上角），字母是现实的表示（原点在左下角）。

## 慎用 memset()

笔者一开始由于有多组询问，写法是每次调用 BFS 的时候都使用 `memset()` 清空 `vis` 数组，于是不幸 TLE。这是因为 `memset()` 实际上相当于直接清空整个 $2005 \times 2005$ 的数组，而有些部分我们根本用不到，会导致降低效率。

那么更有效率的做法就是在每次输入地图的时候顺便将 `vis` 数组置零，这样只要清空我们用到的 $n \times m$ 的部分，如下：

```cpp
for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
            {
                char ch = getchar();
                while (ch != '0' && ch != '1')
                    ch = getchar();
                a[i][j] = ch - '0';
                vis[i][j] = 0;
            }
```
## 关于回溯函数中的判定条件

在回溯函数中，我们需要判断是不是已经回到了起点，这时候笔者犯了一个很典的错误：`while(x != 1 && y != 1)`。

正确的写法是 `while(x != 1 || y != 1)`，或者我觉得更好理解的 `while(!(x == 1 && y == 1))`。

以上的错误都是一些很小也很蠢的错误，但是会在我们组合板子的过程中让我们疲于修改细节而不是快速确定大方向上是否正确。希望各位以我为鉴。~~毕竟正式比赛的时候就因为方向搞晕了而没 AC。~~

# AC 代码

```cpp
/**
 * @file P10234 [yLCPC2024] B. 找机厅
 * @author Flaw_Owl
 * @brief 常规 BFS 板子，回溯路径的写法值得注意
 * @date 2024-03-21
 */

#include <iostream>
#include <cctype>
#include <queue>
#include <tuple>
#include <stack>

using namespace std;

// 快读
int read()
{
    int x = 0, f = 1;
    char ch = 0;
    while (!isdigit(ch))
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (isdigit(ch))
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

const int maxN = 2e3 + 10;

// 定义方向数组和方向
const int dirX[4] = {-1, 0, 1, 0};
const int dirY[4] = {0, -1, 0, 1};
const string temp = "ULDR";

int T;
int n, m;

int a[maxN][maxN];                    // 地图
bool vis[maxN][maxN];                 // 记录访问过的节点
tuple<int, int, int> pre[maxN][maxN]; // 前一个访问的地块
stack<char> st;                       // 用栈保存路径

/**
 * @brief
 * 用于 BFS 判断是否越过边界
 * @param x 当前 x 坐标
 * @param y 当前 y 坐标
 * @return true
 * @return false
 */
bool inBounds(int x, int y)
{
    return x >= 1 && x <= n && y >= 1 && y <= m;
}

/**
 * @brief
 * 用于回溯找到路径
 */
void path(int x, int y)
{
    // 用栈来记录每一步的路径
    while (!(x == 1 && y == 1))
    {
        int nowX, nowY, turn;
        tie(nowX, nowY, turn) = pre[x][y];
        st.push(temp[turn]);
        x = nowX;
        y = nowY;
    }
    // 输出
    while (!st.empty())
    {
        putchar(st.top()); // 用 putchar() 优化输出
        st.pop();
    }
    printf("\n");
}

/**
 * @brief
 * 宽度优先搜索 BFS 板子
 */
void BFS()
{
    // 用 tuple 三元组存储 {x 坐标，y 坐标，花费时间}
    queue<tuple<int, int, int>> q;
    q.push({1, 1, 0});
    vis[1][1] = true;
    while (!q.empty())
    {
        int x, y, time;
        tie(x, y, time) = q.front();
        q.pop();

        // 向上下左右四个方向延拓
        for (int i = 0; i < 4; i++)
        {
            int newX = x + dirX[i];
            int newY = y + dirY[i];
            if (inBounds(newX, newY) && a[newX][newY] ^ a[x][y] && !vis[newX][newY])
            {
                // 到达终点，这里因为已经走了一步了，实际上时间要 +1
                pre[newX][newY] = {x, y, i};
                if (newX == n && newY == m)
                {
                    printf("%d\n", time + 1);
                    path(n, m);
                    return;
                }
                vis[newX][newY] = true;
                q.push({newX, newY, time + 1});
            }
        }
    }
    printf("-1\n");
}

// 主函数
int main()
{
    T = read();
    while (T--)
    {
        n = read();
        m = read();
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
            {
                char ch = getchar();
                while (ch != '0' && ch != '1')
                    ch = getchar();
                a[i][j] = ch - '0';
                vis[i][j] = 0;
            }
        BFS();
    }
    return 0;
}
```

---

## 作者：HHC883 (赞：0)

# P10234 [yLCPC2024] B. 找机厅 题解
## 题目分析
很明显，本题是一道广度优先搜索。由于广搜总是优先寻找与当前最接近的点，所以得到的一定是最短路。

形象地说：广搜就是先找距离为 $1$ 的，再找距离为 $2$ 的，以此类推。

由于越近的点越先被搜索到，所以符合“先进先出”，故可以用队列模拟。

至于题目要求的“如果你想从一个格子走到另一个格子，除了满足上述的要求外，还必须保证：这两个格子对应的数字不同”，只需要简单地判断一下下一个点与当前点上的数字是否相同即可，相同即跳过。

至于记录所需时间，用一个 $stp$ 数组记录即可。

另外，若要输出路线，可以使用一个 $pre$ 数组记录当前点的上一个点（也就是前驱），输出的时候使用递归反向输出即可。

记得注意细节：一个点只能被搜一次，所以要用一个 $vis$ 数组记录某个点是否已经被搜过；还要注意判断搜索的点是否超出了边界。

由于每个点只会被搜到一次，所以对于每组数据，时间复杂度是 $O(n \times m)$ 的，可以证明 $T$ 不会过大，可以通过题目。
## 参考代码
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
int t,n,m,stp[(int)2e3+5][(int)2e3+5];
char mp[(int)2e3+5][(int)2e3+5];
int dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};
bool vis[(int)2e3+5][(int)2e3+5];
struct point{
	int x,y;
} pre[(int)2e3+5][(int)2e3+5];
queue<point> q;
void print(point p,point last){
	if(p.x==0) return;
	print(pre[p.x][p.y],p);
	if(last.x==-1) return;
	if(last.x-p.x==1) cout<<'D';
	else if(last.x-p.x==-1) cout<<'U';
	else if(last.y-p.y==1) cout<<'R';
	else cout<<'L';
}
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;i++) cin>>mp[i]+1;
		memset(stp,-1,sizeof stp);
		memset(vis,false,sizeof vis);
		q.push(point{1,1});
		vis[1][1]=true;
		while(!q.empty()){
			point now=q.front();q.pop();
			for(int i=0;i<4;i++){
				int nx=now.x+dx[i],ny=now.y+dy[i];
				if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis[nx][ny]&&mp[nx][ny]!=mp[now.x][now.y]){
					vis[nx][ny]=true;
					stp[nx][ny]=stp[now.x][now.y]+1;
					pre[nx][ny]=now;
					q.push(point{nx,ny});
				}
			}
		}
		if(stp[n][m]!=-1){
			cout<<stp[n][m]+1<<endl;
			print(point{n,m},point{-1,-1});
			cout<<endl;
		}
		else cout<<-1<<endl;
	}
	return 0;
}

```

---

## 作者：Lian_zy (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P10234)

# 题目分析
这是一道广度优先搜索题。

如果不会广搜的话自己上百度去。

记录路径只需要使用一个前缀数组记录最后递归输出路径就好了，这样会节省很多空间。

# 总结 & 代码
Bfs、输入、输出的复杂度为 $O(nm)$，$T$ 次复杂度为 $O(Tnm)$。
``` cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 2e3 + 10, dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1};
queue<int> qx, qy;
bool vis[maxn][maxn];
char str[maxn][maxn], last[maxn][maxn];
int T, n, m, nx, ny, ux, uy, dis[maxn][maxn];
void print(int x, int y) {
	if (last[x][y] == 'N') return ;
	if (last[x][y] == 'R') print(x, y - 1);
	if (last[x][y] == 'L') print(x, y + 1);
	if (last[x][y] == 'U') print(x + 1, y);
	if (last[x][y] == 'D') print(x - 1, y);
	printf("%c", last[x][y]);
	return ;
} 
void Bfs(int sx, int sy) {
	qx.push(sx), qy.push(sy);
	dis[sx][sy] = 0;
	vis[sx][sy] = true;
	last[sx][sy] = 'N';
	while (qx.size()) {
		ux = qx.front();
		uy = qy.front();
		qx.pop(), qy.pop();
		for (int i = 1; i <= 4; i++) {
			nx = ux + dx[i - 1];
			ny = uy + dy[i - 1];
			if (nx < 1 || nx > n || ny < 1 || ny > m || vis[nx][ny] || str[nx][ny] == str[ux][uy]) continue;
			vis[nx][ny] = true;
			dis[nx][ny] = dis[ux][uy] + 1;
			if (i == 1) last[nx][ny] = 'R';
			if (i == 2) last[nx][ny] = 'L';
			if (i == 3) last[nx][ny] = 'U';
			if (i == 4) last[nx][ny] = 'D';
			qx.push(nx);
			qy.push(ny);
		}
	}
	return ;
}
int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d %d", &n, &m);
		for (int i = 1; i <= n; i++) {
			scanf(" %s", str[i] + 1);
			for (int j = 1; j <= m; j++) {
				dis[i][j] = -1;
				vis[i][j] = false;
			}
		}
		Bfs(1, 1);
		if (~dis[n][m]) {
			printf("%d\n", dis[n][m]);
			print(n, m);
			putchar(10);
		} else puts("-1");
	}
	return 0;
}
```

---

## 作者：chatoudp (赞：0)

考虑 DFS，每次进行移动，都记录方向。
然后你就会 TLE。

正解：

使用 BFS。

如何判断点 $x$，$y$ 往下一个点 $nx$，$ny$ 是否可走：

1、在地图内。

2、能更新距离。

3、与点 $x$，$y$ 的值相反。

代码：

```cpp
if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&dis[nx][ny]>dis[hx][hy]+1&&mp[nx][ny]!=mp[hx][hy])
```

如何输出路径：

用 $ch$ 数组记录每个点是由怎么走来的，最后递归输出。

代码：

```cpp
void prt(int x,int y){
	if(x==1&&y==1) return;
	if(ch[x][y]=='R') prt(x,y-1);
	if(ch[x][y]=='L') prt(x,y+1);
	if(ch[x][y]=='U') prt(x+1,y);
	if(ch[x][y]=='D') prt(x-1,y);
	printf("%c",ch[x][y]);
}
```

接下来是完整 AC 代码，~~请乱抄袭~~请勿抄袭：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int t,dis[2005][2005],n,m;
bool vis[2005][2005];
char mp[2005][2005],ch[2005][2005];
int dx[]={0,0,-1,1};
int dy[]={1,-1,0,0};
char g[]={'R','L','U','D'};
queue<pair<int,int> > q,qq;
void prt(int x,int y){
	if(x==1&&y==1) return;
	if(ch[x][y]=='R') prt(x,y-1);
	if(ch[x][y]=='L') prt(x,y+1);
	if(ch[x][y]=='U') prt(x+1,y);
	if(ch[x][y]=='D') prt(x-1,y);
	printf("%c",ch[x][y]);
}
void bfs(){
	q=qq;
	q.push({1,1});
	while(!q.empty()){
		int hx=q.front().first,hy=q.front().second; q.pop();
		for(int i=0;i<4;i++){
			int nx=hx+dx[i];
			int ny=hy+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&dis[nx][ny]>dis[hx][hy]+1&&mp[nx][ny]!=mp[hx][hy]){
				dis[nx][ny]=dis[hx][hy]+1;
				ch[nx][ny]=g[i];
				q.push({nx,ny});
				if(nx==n&&ny==m) return;
			}
		}
	}
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				cin>>mp[i][j];
		memset(dis,0x3f,sizeof(dis));
		dis[1][1]=0;
		vis[1][1]=1;
		bfs();
		if(dis[n][m]==0x3f3f3f3f) printf("-1\n");
		else{
			printf("%d\n",dis[n][m]);
			prt(n,m);
			printf("\n");
		}
	}
	return 0;
}

```

开始我比赛时用 DFS 获得了 TLE，改成广搜，成功 AC。

---

## 作者：sansesantongshun (赞：0)

这题要求的是从 $(1,1)$ 到 $(n,m)$ 的最短距离，很显然可以用宽搜来做。

首先这题是要输出上下左右的，所以需要预处理一下上下左右。

然后就是正常的宽搜。这里需要开一个数组记录走过的距离，还需要一个数组记录最优方案是从哪个方向走到这个格子。

至于输出，采用逆向递归输出就行。

其他详细的写在注释里了。

$\color{#52C41A}AC$ 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,x,y,xx,yy,b[2005][2005],c[2005][2005],dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};//b:距离数组 c:方向数组
queue<pair<int,int> > q;
char a[2005][2005],jg[4]={'U','D','L','R'};//上下左右，与dx，dy一一对应
void print(int x,int y)//递归输出
{
	if (x+y!=2)//递归边界
	{
		int xx,yy;
		xx=x-dx[c[x][y]];
		yy=y-dy[c[x][y]];
		print(xx,yy);
		cout<<jg[c[x][y]];//先回溯后输出
	}
}
int main()
{
	cin>>t;
	while (t--)
	{
		scanf("%d%d",&n,&m);
		for (int i=1;i<=n;++i)
		for (int j=1;j<=m;++j)
		{
			cin>>a[i][j];
			b[i][j]=-1;//没搜过的预处理成-1
		}
		b[1][1]=0;
		q.push(make_pair(1,1));
		while (!q.empty())//宽搜
		{
			x=q.front().first;
			y=q.front().second;
			q.pop();
			for (int i=0;i<4;++i)//4个方向
			{
				xx=x+dx[i];
				yy=y+dy[i];
				if (0<xx && xx<=n && 0<yy && yy<=m && a[xx][yy]!=a[x][y] && b[xx][yy]==-1)//不越界，可以走，没被访问过
				{
					b[xx][yy]=b[x][y]+1;
					c[xx][yy]=i;//记录方向
					if (xx==n && yy==m)//搜到终点
					{
						while (!q.empty())
						q.pop();//多测不清空，爆0两行泪
						break;
					}
					q.push(make_pair(xx,yy));
				}
			}
		}
		cout<<b[n][m]<<'\n';
		if (b[n][m]!=-1)//有解
		{
			print(n,m);//输出具体方案
			cout<<'\n';
		}
	}
}
```

---

## 作者：ACtheQ (赞：0)

本题恶心呀！！！！！！

赛事因为这题吃了一次罚时。

注意到要求最短路，且 $1 \le n,m \le 2\times 10^3$，考虑使用 $O(nm)$ bfs。

用 bfs 把从起点到每个点的最短路记下来。

重点是如何记下来路径，可以发现如果正着记路径，会出现一个点走向很多个点的情况，倒着记录路径就没有问题。

例如：

$lst_{x,y}$ 就代表到达点 $x,y$ 的上一步是那个点。

让后从终点倒这把路径推出来就行了。

bfs 中判断越界或有没有被经过的函数：

```c++
bool check(int x,int y)
{
	if(x<1||x>n||y<1||y>m||dis[x][y]!=-1) return false;
	return true;
}
```

这里的 $dis_{x,y}$ 表示从起点到达点 $x,y$ 的距离是多少。

当 $dis_{x,y}$ 为 $-1$ 时，代表点 $x,y$ 没有被访问过，这样能省一个标记数组。

bfs 代码：

```c++
int bfs(int sx,int sy)
{
	queue<pair<int,int>> q;
	q.push(make_pair(sx,sy));
	if(!check(sx,sy)) return -1;
	dis[sx][sy]=0;
	lst[sx][sy]=make_pair(-1,-1);
	while(!q.empty())
	{
		pair<int,int> u=q.front();
		q.pop();
		int x=u.first;
		int y=u.second;
		for(int i=0;i<4;i++)
		{
			int fx=x+dx[i];
			int fy=y+dy[i];
			if(check(fx,fy)&&maps[fx][fy]!=maps[x][y])
			{
				q.push(make_pair(fx,fy));
				dis[fx][fy]=dis[x][y]+1;
				lst[fx][fy]=make_pair(x,y);
				if(fx==n&&fy==m) return dis[fx][fy];
			}
		}
	}
	return -1;
}
```

倒着查询路径：

```c++
vector<pair<int,int>> step;
int x=n;
int y=m;
while(true)
{
  step.push_back(make_pair(x,y));
  if(lst[x][y]==make_pair(-1,-1)) break;
  pair<int,int> news=lst[x][y];
  x=news.first;
  y=news.second;
}
reverse(step.begin(),step.end());
```
最后一行代码是让路径正过来。

输出路径代码：
```c++
for(int i=1;i<step.size();i++)
		{
			pair<int,int> tp=step[i];
			pair<int,int> ls=step[i-1];
			int x=tp.first;
			int y=tp.second;
			int lsx=ls.first;
			int lsy=ls.second;
			//cout<<x<<" "<<y<<" "<<lsx<<" "<<lsy<<" ";
			if(x==lsx)
			{
				if(y>lsy) cout<<"R";
				else cout<<"L";
			}
			else
			{
				if(x>lsx) cout<<"D";
				else cout<<"U";
			}
		}
		cout<<endl;
```

完整代码：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=2e3+5;
int n,m;
int dis[N][N];
char maps[N][N];
int dx[]={1,-1,0,0};
int dy[]={0,0,1,-1};
pair<int,int> lst[N][N]; 
bool check(int x,int y)
{
	if(x<1||x>n||y<1||y>m||dis[x][y]!=-1) return false;
	return true;
}
int bfs(int sx,int sy)
{
	queue<pair<int,int>> q;
	q.push(make_pair(sx,sy));
	if(!check(sx,sy)) return -1;
	dis[sx][sy]=0;
	lst[sx][sy]=make_pair(-1,-1);
	while(!q.empty())
	{
		pair<int,int> u=q.front();
		q.pop();
		int x=u.first;
		int y=u.second;
		for(int i=0;i<4;i++)
		{
			int fx=x+dx[i];
			int fy=y+dy[i];
			if(check(fx,fy)&&maps[fx][fy]!=maps[x][y])
			{
				q.push(make_pair(fx,fy));
				dis[fx][fy]=dis[x][y]+1;
				lst[fx][fy]=make_pair(x,y);
				if(fx==n&&fy==m) return dis[fx][fy];
			}
		}
	}
	return -1;
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		memset(dis,-1,sizeof dis);
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++) cin>>maps[i][j];
		}
		int ans=bfs(1,1);
		cout<<ans<<endl;
		if(ans==-1) continue;
		vector<pair<int,int>> step;
		int x=n;
		int y=m;
		while(true)
		{
			step.push_back(make_pair(x,y));
			if(lst[x][y]==make_pair(-1,-1)) break;
			pair<int,int> news=lst[x][y];
			x=news.first;
			y=news.second;
		}
		reverse(step.begin(),step.end());
		for(int i=1;i<step.size();i++)
		{
			pair<int,int> tp=step[i];
			pair<int,int> ls=step[i-1];
			int x=tp.first;
			int y=tp.second;
			int lsx=ls.first;
			int lsy=ls.second;
			//cout<<x<<" "<<y<<" "<<lsx<<" "<<lsy<<" ";
			if(x==lsx)
			{
				if(y>lsy) cout<<"R";
				else cout<<"L";
			}
			else
			{
				if(x>lsx) cout<<"D";
				else cout<<"U";
			}
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

**郑重声明：本人没有 AC，但思路可以借鉴。所以仅给出部分重要代码。**

这道题看到“最短时间到达 $(n, m)$”，而且还是一个表，~~还有查看题目标签，~~
就可以知道这道题的最优解法就是 **BFS**，即广度优先搜索。

这道题非常经典，和 [P2895](https://www.luogu.com.cn/problem/P2895) 的处理方法相似，定义一个结构体，结构体里是每个点的坐标和数。注意是数，所以我们要将每个数字字符转成数。用这个结构体来作为队列的结构。然后从 $(0, 0)$ 点开始向下搜索。注意在进入队列的时候要将这三个元素归并到结构体队列中，所以我们需要如下操作强制转换：
```cpp
q.push((Node){0, 0, a[0][0]});
```
这样就实现了将三个元素弹入队列。也可以用 ```make_pair```，但是用结构体更容易理解。

然后进行 BFS，取出每个队列元素的坐标，然后把偏值加上，注意如果偏值超过了范围，即 $x<0,y<0,x>n-1,y>m-1$，就是无效操作，需要跳过。还有就是这个点的最小步数被赋值过了，也要跳过。然后记录每个点所用的步数。最后输出 $(n-1,m-1)$ 的最小步数即可。实现如下：
```cpp
void solve()
{
    memset(ans1, -1, sizeof(ans1));
    ans2 = "";
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
        {
        	cin >> tp[i][j];
        	a[i][j] = tp[i][j] - '0';
		}
    q.push((Node){0, 0, a[0][0]});
    ans1[0][0] = 0;
    while (!q.empty())
    {
        Node u = q.front();
        int ux = u.x, uy = u.y;
        q.pop();
        for (int i = 0; i < 4; i++)
        {
            int x = ux + wk[i][0], y = uy + wk[i][1];
            if (x < 0 || y < 0 || x > n || y > m || a[x][y] == a[ux][uy] || ans1[x][y] != -1) continue;
            ans1[x][y] = ans1[ux][uy] + 1;
            q.push((Node){x, y});
        }
    }
    cout << ans1[n-1][m-1] << endl;
    if (ans1[n-1][m-1] != -1)
    {
    	print(0, 0);
        cout << endl;
	}
}
```
其中 ```print(0, 0);``` 就已经开始进行输出路线操作了。这里我们还是要计算偏值，如果记录偏值以后的坐标和原来的坐标步数相差 $1$，就进行输出操作，输出对应的路线，然后继续往下一层拓展，最后拓展到 $(n-1,m-1)$ 结束。当然还要注意是否越界。

这里过于简单，不展示代码，请读者自行编写。

---

## 作者：AKPC (赞：0)

**前言：**

你知道一个人懂字符串（@[wxzzzz](/user/749630)），另一个不懂（就是我），差距有多大吗？我把他先写完 bfs，bfs 没有问题，但是前者写完后就秒过了，但是由于字符串的问题，我的复杂度被卡了，不是 bfs 写不起，而是卡字符串问题更有性价比。这件事情对我今后碰见输出字符串的问题做一个警醒，也是我近来第一次月赛没切黄题。

~~事实：G<B（大雾）。~~

**思路**

遇见这种迷宫最短路径问题当然是跑 bfs。对于两个格子之间能不能走，判断他们的点权异或起来是否等于 $1$ 即可。因为 bfs 的性质，对于一个 $(1,1)\to(x,y)$，最早跑出来的路径一定最优。对于本题，考虑每个节点记录一个祖先，即搜到这的上一个点，这样更能保证复杂度。

代码不放了，注意字符串操作 `S=<char>+S` 复杂度 $\Theta(n)$，而 `+=` 是 $\Theta(1)$，不要像我那么蠢吃 $27$ 次罚时（笑）。

---


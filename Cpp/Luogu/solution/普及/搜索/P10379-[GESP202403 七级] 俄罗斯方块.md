# [GESP202403 七级] 俄罗斯方块

## 题目描述

小杨同学用不同种类的俄罗斯方块填满了一个大小为 $n \times m$ 的网格图。

网格图由 $n \times m$ 个带颜色方块构成。小杨同学现在将这个网格图交给了你，请你计算出网格图中俄罗斯方块的种类数。  
如果两个同色方块是四连通（即上下左右四个相邻的位置）的，则称两个同色方块直接连通；若两个同色方块同时与另一个同色方块直接或间接连通，则称两个同色方块间接连通。一个俄罗斯方块由一个方块和所有与其直接或间接连接的同色方块组成。定义两个俄罗斯方块的种类相同当且仅当通过**平移**其中一个俄罗斯方块可以和另一个俄罗斯方块重合；如果两个俄罗斯方块颜色不同，仍然视为同一种俄罗斯方块。

例如，在如下情况中，方块 $1$ 和方块 $2$ 是同一种俄罗斯方块，而方块 $1$ 和方块 $3$ **不是**同一种俄罗斯方块。

![](https://cdn.luogu.com.cn/upload/image_hosting/ttv3nmgs.png)

## 说明/提示

| 子任务 | 分数 | $n,m \leq$ | 特殊约定 | 
| :-: | :-: | :-: | :-: |
| $1$ | $30$ | $20$ | 所有俄罗斯方块大小不超过 $5 \times 5$ |
| $2$ | $30$ | $500$ | 所有俄罗斯方块大小均为 $1 \times x$ 或 $x \times 1$ 类型，其中 $x$ 是任意正整数|
| $3$ | $40$ | $500$ | 无 |

对全部的测试数据，保证 $1 \leq n, m \leq 500$，$1 \leq a_{i,j} \leq n \times m$。

## 样例 #1

### 输入

```
5 6
1 2 3 4 4 5
1 2 3 3 4 5
1 2 2 3 4 5
1 6 6 7 7 8
6 6 7 7 8 8
```

### 输出

```
7```

# 题解

## 作者：_ckx_ (赞：19)

## 题目大意
给定一个 $n \times m$ 的矩阵，求其中不同种类的方块的数量。

定义方块为几个相邻且颜色相同的点组成的连通块。

定义两个方块种类不同为两个方块形状不相同，颜色随意。

## 思路

先考虑如何判断两个方块是否相同：

定义两个方向数组 $dx$ 和 $dy$。

可以发现我们只需要判断遍历这两个方块时每个方向是否相等就行了，可以用 `string` 来存储。

最后用 `map` 来标记就行了。

这里给大家介绍一下 `unordered_map`：内部不用排序，插入和查找均摊情况下是 $\mathcal{O}(1)$ 复杂度，最坏 $\mathcal{O}(n)$，在数据量不多的情况下比 `map` 快一些。

## code
```cpp
#include <bits/stdc++.h>
#define umap unordered_map
using namespace std;
typedef long long ll;

int n ,m;
const int N = 510;
int a[N][N];
int vis[N][N];
umap<string ,int> mp;

//方向数组 
int dx[] = {1 ,0 ,-1 ,0};
int dy[] = {0 ,1 ,0 ,-1};

void dfs(int x ,int y ,string &s/*&s:取s的地址，可以在函数里直接修改*/)
{
	for (int i = 0;i < 4;i++)
	{
		int nx = x + dx[i];
		int ny = y + dy[i];
		
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m) //越界判断 
		{
			if (vis[nx][ny] || a[nx][ny] != a[x][y]) continue; //访问过或者颜色不一可以直接跳过 
			s += char(i + '0'); 
			vis[nx][ny] = 1; //标记 
			dfs(nx ,ny ,s);
			//不用回溯，因为不会再次访问 
		}
	}
	s += ' '; //注意：最后要加一个空格，因为转弯地点会发生改变，加空格为了区分不同的转弯地点 
}

int main()
{
	scanf("%d%d",&n ,&m);
	
	for (int i = 1;i <= n;i++)
	{
		for (int j = 1;j <= m;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	
	int ans = 0;
	for (int i = 1;i <= n;i++)
	{
		for (int j = 1;j <= m;j++)
		{
			if (!vis[i][j]) //没被走过就走 
			{
				vis[i][j] = 1;
				
				string s = "";
				dfs(i ,j ,s);
				
				if (!mp[s]) //如果没有这种方块就加一个种类 
				{
					ans++;
				}
				mp[s] = 1; //标记 
			}
		}
	}
	
	printf("%d\n",ans);
	
	return 0;
}
```

---

## 作者：__rnfmabj__ (赞：7)

## First 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P10379)

给定一个 $n \times m$ 的数字矩阵，其中相互联通且数字相等的区块是一个方块；当两个方块可以通过平移重合时，就成这两个方块是同一种方块，求出其中有多少种不同的方块

## Second 理清思路
首先我们可以一眼看出这题需要用洪水填充的 DFS 算法，然后的问题就是**如何去判断区块的形状**，~~我估计大部分人也是因为这个打开题解的~~。

其实仔细想想,我们是在用 DFS ，所以**最终同种区块遍历出来的序列的相对状态一定是唯一的**，也就是说，我们在当前这个点向下一个点转移的时候，**朝向哪的方向是一定的**。

这里我们可以用 ```string``` 来存储遍历出来方向的的序列~~其实本来我想用 ```int``` ,但是会爆~~，然后扔进一个 ``set`` 里面（因为 ``set`` 有自动去重的功能），最终输出这个 ``set`` 的大小就可以了

## Code
（大部分细节都放在代码注释里了，可以自己理解一下）

ps.善用偏移量和边界框可以有效减少代码复杂度

```cpp
//蒟蒻第一篇题解，望通过
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e2+10;

int mapp[N][N],n,m;//mapp是原数组
bool vis[N][N];//标记数组
int py[5][2]={{0,0},{0,1},{0,-1},{1,0},{-1,0}};//偏移量
set<string> st;//记录答案
string s;//记录转向

void dfs(int x,int y){//洪水填充
	for (int i=1;i<=4;i++){
		int next_x=x+py[i][0],next_y=y+py[i][1];//下一个点的坐标

		if (mapp[next_x][next_y]==-1 || vis[next_x][next_y])
			continue;//如果越界或已被遍历过,就退出
		if (mapp[next_x][next_y]!=mapp[x][y])
			continue;//颜色不同也直接退出
		
		s+=i;//记录朝向
		vis[next_x][next_y]=1;//打上标记
		dfs(next_x,next_y);//进入下一次遍历
		//这里不需要回溯,因为我们不会再次进入这次遍历
	}
	s+=' ';
/*注意这里一定要加上一个空格，因为转向的位置不一样
例如：
2 3 3 1 1
3 3 2 1 1
其中 3 的区块和 1 的区块的转向序是一样的，只能用转向时插入空格区分*/
}
void read(){
	cin>>n>>m;
	for (int i=0;i<=n+1;i++)
		for (int j=0;j<=m+1;j++)
			if (i==0 || j==0 || i==n+1 || j==m+1)mapp[i][j]=-1;//如果是边界直接添加一层-1
			else cin>>mapp[i][j];//否则就正常读入
}
void cz(){
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (!vis[i][j]){
				vis[i][j]=1;//打上标记
				s="";//初始化
				dfs(i,j);
				st.insert(s);//将转向序插入
			}
}
signed main(){
	read();//读入
	cz();
	cout<<st.size();//输出答案
	return 0;
}
```

---

## 作者：Peiyuan (赞：5)

~~这次 GESP 7级 竟然没考 dp！~~

这里介绍一下考场上想出来的比较直接的做法。

## 思路

一看就知道这道题可以用 `floodfill` 解决，但是需要在此基础上修改……于是，我就干脆用一个 `pair` 存储俄罗斯方块里点的相对坐标。用一个 `vector` 存储这些点构成的俄罗斯方块，因为每个一样的形状都是从左上角开始遍历的，所以可以记原点 $(sx,sy)$ 为 $(0,0)$，这样所有形状一样的序列也就一样了（遍历点的顺序也是一样的）。再把这个 `vector` 扔进 `set` 里，达到去重的目的。具体看代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[505][505];
bool vis[505][505];
int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
vector<pair<int,int>> t;
set<vector<pair<int,int>>> lst;
struct node{
	int x,y;
};
void bfs(int sx,int sy){
	queue<node> q;
	q.push({sx,sy});
	t.clear();
	while(q.size()){
		node c=q.front();q.pop();
		t.push_back({c.x-sx,c.y-sy});
		for(int i=0;i<4;i++){
			int nx=c.x+dx[i],ny=c.y+dy[i];
			if(nx>0&&nx<=n&&ny>0&&ny<=m&&!vis[nx][ny]&&a[nx][ny]==a[sx][sy]){
				vis[nx][ny]=1;
				q.push({nx,ny});
			}
		}
	}
	lst.insert(t);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) scanf("%d",&a[i][j]);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!vis[i][j]) bfs(i,j);
		}
	}
	printf("%d\n",lst.size());
	return 0;
}
```

---

## 作者：sillation (赞：5)

[题目通道](https://www.luogu.com.cn/problem/P10379)
-----
使用[洪水填充法](https://blog.csdn.net/qq_42785250/article/details/127546391)从每个未扫描过的点开始填充，得到一个数字相同的图形。判断此图形是否有相同图形。求出不同图形的个数。

### 思路：
- 如何填充。和 DFS 差不多。建立两个方向数组 $dx$ 和 $dy$。一个二维数组 $v$ 用于标记是否填充过。如果下一个填充点未出界未访问过**并与此填充的数字相同**，就填充。

- 如何判断填充完的图形是否有相同图形。首先可以想到用 map 最快最方便。然后考虑用 string 来储存填充的每个数字，记住拐角时一定要在字符串里加个空格，方便区分。每次使用完后记得初始化。**不要回溯**。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s[505][505],v[505][505],ans;
map<string ,int> MP;
string as;
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};  //方向数组
void dfs(int x,int y){
	for(int i=0;i<4;i++){
		int tx=x+dx[i],ty=y+dy[i];
		if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&v[tx][ty]==0&&s[tx][ty]==s[x][y]){//判断合法
			as+=(i+'0');
			v[tx][ty]=1;//标记
			dfs(tx,ty);
		}
	}
	as+=' ';
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>s[i][j];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(v[i][j]==0){//没填充过就填充
				v[i][j]=1;
				as="";
				dfs(i,j);
				if(MP[as]==0) ans++;
				MP[as]=1;//标记
			}
		}
	}
	cout<<ans;
	return 0;
}


```

---

## 作者：lukepanpyz (赞：3)

## 题目大意
输入一个 $n$ 行 $m$ 列由数字组成的矩阵，求矩阵中数字（颜色）不同且形状不同的四方向连通块的个数。
## 思路
本体考虑使用深度优先搜索（DFS）中的连通块算法，先求出每个联通快，再将每个连通块中的数字的相对位置（$x$ 坐标相对位置：当前 $x$ 坐标 $-$ 起始 $x$ 坐标，$y$ 坐标相对位置同理。对于每一个连通块中的每一个数字的 $xy$ 坐标的相对位置，将它们各存储到一个 pair 中。）各存储在一个 vector 数组中，并将所有 vector 数组存储在一个 set 容器中用于去重。最后输出 set 容器的大小即可。
## AC Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[505][505],sx,sy;
vector<pair<int,int> > e;
set<vector<pair<int,int> > > st;
void dfs(int ini,int x,int y)
{
	e.push_back(make_pair(x - sx,y - sy));
	a[x][y] = 0;
	if(a[x - 1][y] == ini)
	{
		dfs(ini,x - 1,y);
	}
	if(a[x + 1][y] == ini)
	{
		dfs(ini,x + 1,y);
	}
	if(a[x][y - 1] == ini)
	{
		dfs(ini,x,y - 1);
	}
	if(a[x][y + 1] == ini)
	{
		dfs(ini,x,y + 1);
	}
}
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			cin >> a[i][j];
		}
	}
	for(int i = 1;i <= n;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			if(a[i][j] != 0)
			{
				sx = i;
				sy = j; 
				dfs(a[i][j],i,j);
				st.insert(e);
				e.clear();
			}
		}
	}
	cout << st.size();
	return 0; 
}
```

---

## 作者：Sicosuki (赞：2)

还没看到有哈希做法，我来写一个。
# 题意
给出一个 $n \times m$ 的矩阵，求其中形状不同的连通块的个数。
# 哈希做法
哈希做法的优势在于，不需要记录或对比具体的形状，只需要记录这个连通块内的点的坐标即可。

首先还是照常 dfs 搜索找连通块，每找到一个连通块就对该连通块进行一次哈希，同时记录答案。

需要注意的一点是要在记录坐标的过程中记录最小的横纵坐标，然后在哈希的时候把每一个坐标都减去这个最小坐标，相当于把连通块挪到了坐标原点。这样子保证了形状一样的连通块的坐标是相同的。

具体内容见代码，代码使用的是双哈希。
# CODE
```
#include <bits/stdc++.h>
#define leg(x,k) (1 <= x && x <= k)
using namespace std;
const int ma = 510;
int n,m,a[ma][ma],col,ix,iy,ans;
int rnd1[ma],rnd2[ma];
int dx[4] = {0,1,0,-1};
int dy[4] = {1,0,-1,0};
bool t[ma][ma];
queue <pair<int,int>> q;
map <pair<int,int>,bool> mp;
mt19937 ra(time(0));//随机数生成，使用 rand 替换也可以 
void dfs(int x,int y)
{
	for(int i = 0; i < 4; i++)
	{
		int ux = x + dx[i];
		int uy = y + dy[i];
		if(leg(ux,n) && leg(uy,m) && a[ux][uy] == col && !t[ux][uy])
		{
			q.push({ux,uy});
			t[ux][uy] = 1;
			ix = min(ix,ux);iy = min(iy,uy);//记录坐标边界 
			dfs(ux,uy);
		}
	}
}
void work(int x,int y)
{
	t[x][y] = 1,col = a[x][y],q.push({x,y});
	ix = x;iy = y;
	dfs(x,y);
	int h1 = 0,h2 = 0;
	while(!q.empty())//对于储存的坐标进行哈希 
	{
		int c = q.front().first;
		int d = q.front().second;
		q.pop();
		c -= ix;d -= iy;//移动坐标 
		h1 += rnd1[c] ^ rnd2[d];
		h2 ^= rnd1[c] * rnd2[d];
	}
	if(!mp.count({h1,h2}))
		mp[{h1,h2}] = 1,ans++;
}
signed main()
{
	for(int i = 0; i <= 500; i++)
		rnd1[i] = ra(),rnd2[i] = ra();//初始化哈希
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			cin >> a[i][j];
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(!t[i][j])
				work(i,j);
	cout << ans;
}
```

---

## 作者：zhchz (赞：2)

## 题意简述
给定一个由不同颜色的方块组成的网格图，要求计算网格图中不同俄罗斯方块种类的数量。这里的“俄罗斯方块种类”指的是通过平移可以重合的方块组合，而颜色不同的方块仍然可以视为同一种俄罗斯方块。
## 代码思路
1. 遍历网格图中的每个方块。
2. 如果当前方块还没有被访问过，以这个方块为起点进行深度优先搜索，寻找所有与之相连的同色方块。
3. 将这些方块的信息编码成一个形状，并统计种类。
4. 最后，输出答案。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<math.h>
#include<string>
#include<string.h>
#include<set>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define check(a,b) (a>=1 && a<N && b>=1 && b<N) // 检查坐标是否越界
using namespace std;

const int N=501; // 网格的最大大小
int n,m,mp[N][N]; // n 和 m 为网格的行数和列数，mp 存储每个方块的颜色
int stx,sty,shape; // stx 和 sty 为起始坐标，shape 用于存储方块形状的编码
bool vis[N][N]; // vis 用于标记方块是否被访问过
int dx[10]={0,0,1,-1}; // 方向数
int dy[10]={1,-1,0,0};
set<int> shapes; // 存储所有不同俄罗斯方块形状的集合

// 深搜，用于找到与(x,y)相连的同色方块，并编码形状
void dfs(int x,int y,int color){
	vis[x][y]=1; // 标记当前方块为已访问
	shape=shape*bas+(x-stx)*n+(y-sty); // 编码当前方块的形状
	for(int i=0;i<4;i++){ // 遍历四个方向
		int nx=x+dx[i],ny=y+dy[i]; // 计算下一个坐标
		if(!check(nx,ny)) continue; // 如果坐标不在网格内，则跳过
		if(mp[nx][ny]==color && !vis[nx][ny]){ // 如果找到同色且未访问的方块
			dfs(nx,ny,color); // 递归搜索
		}
	}
	return;
}

int main(){
	cin>>n>>m; // 输入网格的行数和列数
	for(int i=1;i<=n;i++) // 输入网格的颜色信息
		for(int j=1;j<=m;j++)
			cin>>mp[i][j];
	for(int i=1;i<=n;i++){ // 遍历每个方块
		for(int j=1;j<=m;j++)
			if(!vis[i][j]){ // 如果当前方块未访问
				stx=i,sty=j,shape=0; // 设置起始坐标和形状编码
				dfs(i,j,mp[i][j]); // 从当前方块开始深度优先搜索
				shapes.insert(shape); // 将找到的形状加入集合
			}
	}
	cout<<shapes.size(); // 输出不同形状的数量
	return 0;
}
```

---

## 作者：Rindong (赞：2)

# 题意

给定一个 $n \times m$ 大小的数字矩阵 $a$，其中四连通且数字一样的被视为一个方块；方块 $A$ 与方块 $B$ 被视为同类型的方块仅当 $A$ 经过任意上下左右移动可以和 $B$ 重叠，题目就是问矩阵中有多少个不同类型的方块。

# 思路

显然要使用 dfs 搜索，定义布尔数组 $vis[i][j]$ 用于表示 $a_{ij}$ 是否被搜索过。

为了确定每个方块的形状，我们定义一个字串变量 $path$ 用于记录我们走过的路径；定义无序集合 $uset$ 用于记录我们搜索到的每一个形状，只要每次搜索结束，把 $path$ 插入 $uset$ 最后输入集合的大小即可。

# 代码

小技巧：定义方向数组 $dir$ 可以省去很多麻烦，将矩阵 $a$ 周围填充 $0$ 可以免去边界判断的麻烦。

```cpp
#include <iostream>
#include <unordered_set>
#include <string>
using namespace std;
#define MAX_N 505
int dir[4][2] = { //坐标偏移量数组
	{ -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 }
};
int arr[MAX_N][MAX_N] = { 0 };
bool vis[MAX_N][MAX_N] = { 0 };
unordered_set<string> uset;
//大法师 当前 x，y 当前图形开始 x，y 当前图形颜色 走过的路径
void dfs(int x, int y, int sx, int sy, int color, string& path) {
	vis[x][y] = true; //标记走过了
	path += to_string(x - sx); //记录与初始坐标的偏移量
	path += to_string(y - sy);
	//遍历四个方向
	for (int i = 0; i < 4; i++) {
		int dx = x + dir[i][0];
		int dy = y + dir[i][1];
		//不能走到下一步
		if (vis[dx][dy] || arr[dx][dy] != color) continue;
		dfs(dx, dy, sx, sy, color, path);
	}
}
int main() {
	int n, m;
	scanf("%d%d", &n, &m);
	for (int x = 1; x <= n; x++) for (int y = 1; y <= m; y++) scanf("%d", &arr[x][y]);
	for (int x = 1; x <= n; x++) for (int y = 1; y <= m; y++) {
		if (vis[x][y]) continue;
		string str;
		dfs(x, y, x, y, arr[x][y], str);
		uset.insert(str);
	}
	printf("%d", uset.size());
	return 0;
}
```

---

## 作者：TPJX (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P10379)

### 解题思路
#### 本题考点： 深度优先搜索（DFS）

本题的核心目标是在一个网格图中，找出所有不同形状的俄罗斯方块的种类数量。因为颜色相同的俄罗斯方块，即使形状一样，如果它们彼此不相连，也会被认为是不同的方块。
#### 具体步骤
1. 四连通区域检测：对每个单元格，如果它还没有被访问，我们将从该单元格启动一个深度优先搜索（DFS），来标记所有与之**连通的同色方块**。
2. 标准化形状：对于通过 DFS 找到的每个连通块（即一个俄罗斯方块），我们将它的形状标准化。可以通过记录方块相对于左上角方块的相对位置来完成。所有位置坐标减去最小行和最小列，得到一个形状的唯一表示。
3. 使用一个集合来存储所有已经标准化的形状，每次 DFS 完成后，检查当前形状是否已存在于集合中。如果不存在，则新增。
4. 计数：集合的**大小**即为不同俄罗斯方块的种类数。
#### 实现细节
- 对于每个未访问的单元格，使用 DFS 搜索所有连通的同色方块。
- 使用一个集合来记录所有方块的唯一形状。
- 使用二维数组记录每个单元格是否被访问过。
- Python 代码有递归深度限制的问题，Python 默认的递归深度很低（通常是 1000 左右），而在大规模的深度优先搜索中，尤其是在大网格上执行 DFS 时，很容易超过这个限制。我们可以用栈来实现 DFS。
### 代码
#### C++
```cpp
#include <iostream>
#include <vector>
#include <set>
#include <string>
#include <algorithm>
using namespace std;

int n, m;
vector<vector<int>> grid;
vector<vector<bool>> visited;
set<string> shapes;

int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};

void dfs(int r, int c, vector<pair<int, int>>& cells) {
    visited[r][c] = true;
    cells.push_back({r, c});
    for (int d = 0; d < 4; ++d) {
        int nr = r + dr[d];
        int nc = c + dc[d];
        if (nr >= 0 && nr < n && nc >= 0 && nc < m && !visited[nr][nc] && grid[nr][nc] == grid[r][c]) {
            dfs(nr, nc, cells);
        }
    }
}

string normalizeShape(vector<pair<int, int>>& cells) {
    int min_r = n, min_c = m;
    for (auto& cell : cells) {
        min_r = min(min_r, cell.first);
        min_c = min(min_c, cell.second);
    }
    sort(cells.begin(), cells.end(), [&](const pair<int, int>& a, const pair<int, int>& b) {
        if (a.first - min_r != b.first - min_r)
            return (a.first - min_r) < (b.first - min_r);
        return (a.second - min_c) < (b.second - min_c);
    });
    string shape;
    for (auto& cell : cells) {
        shape += to_string(cell.first - min_r) + "_" + to_string(cell.second - min_c) + ";";
    }
    return shape;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    grid.resize(n, vector<int>(m));
    visited.resize(n, vector<bool>(m, false));

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> grid[i][j];
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (!visited[i][j]) {
                vector<pair<int, int>> cells;
                dfs(i, j, cells);
                string shape = normalizeShape(cells);
                shapes.insert(shape);
            }
        }
    }

    cout << shapes.size() << endl;

    return 0;
}

```
#### Python（使用栈实现 DFS）
```python
def dfs_stack(r, c):
    stack = [(r, c)]
    cells = []
    while stack:
        cr, cc = stack.pop()
        if visited[cr][cc]:
            continue
        visited[cr][cc] = True
        cells.append((cr, cc))
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            nr, nc = cr + dr, cc + dc
            if 0 <= nr < n and 0 <= nc < m and not visited[nr][nc] and grid[nr][nc] == grid[r][c]:
                stack.append((nr, nc))
    return cells

def normalize_shape(cells):
    min_r = min(c[0] for c in cells)
    min_c = min(c[1] for c in cells)
    cells = sorted((c[0] - min_r, c[1] - min_c) for c in cells)
    return ";".join(f"{x}_{y}" for x, y in cells)

n, m = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(n)]
visited = [[False] * m for _ in range(n)]
shapes = set()

for r in range(n):
    for c in range(m):
        if not visited[r][c]:
            cells = dfs_stack(r, c)
            shape = normalize_shape(cells)
            shapes.add(shape)

print(len(shapes))

```
AC 记录：
|语言|链接|
| -----------: | -----------: |
|Python|[Link](https://www.luogu.com.cn/record/157885178)|
|C++|[Link](https://www.luogu.com.cn/record/157883173)|

---

## 作者：mozhao (赞：1)

# 题意描述：
给定一个由不同颜色的方块组成的网格图，要求计算网格图中不同俄罗斯方块种类的数量。这里的“俄罗斯方块种类”指的是通过平移可以重合的方块组合，而颜色不同的方块仍然可以视为同一种俄罗斯方块。

## 主体思路：
1.遍历网格图中的每个方块。

2.如果当前方块还没有被访问过，以这个方块为起点进行深度优先搜索，寻找所有与之相连的同色方块。

3.将这些方块的信息编码成一个形状，并统计种类。

4.最后，输出答案。

### AC代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll ll;
int n,m,a[505][505]={},vis[505][505]={};
map<string,int>mp;
int x2[5]= {1,0,-1,0};
int y2[5]= {0,1,0,-1};
void dfs(int x,int y,string &s) {
	for(int i=0; i<4; i++){
		int dx=x+x2[i];
		int dy=y+y2[i];
		if (dx>=1&&dx<=n&&dy>=1&&dy<=m) {
			if(vis[dx][dy]||a[dx][dy]!=a[x][y]) {
				continue;
			}
			s=s+char(i+'0');
			vis[dx][dy]=1;
			dfs(dx,dy,s);
		}
	}
	s+=' ';
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			cin>>a[i][j];
		}
	}
	int ans=0;
	for (int i=1; i<=n; i++) {
		for (int j=1; j<=m; j++) {
			if(!vis[i][j]) {
				vis[i][j]=1;
				string s;
				dfs(i,j,s);
				if(!mp[s]) {
					ans++;
				}
				mp[s]=1;
			}
		}
	}
	cout<<ans;
	return 0;
}
```
### 完结散花！

---

## 作者：yfl20130101 (赞：1)

### 思路
我们用 `dfs` 求出每个块的样子，然后通过用：当前 $x$ 坐标 $-$ 起始 $x$ 坐标 $+$ 当前 $y$ 坐标 $-$ 起始 $y$ 坐标编码每一个俄罗斯方块，存入 `set` 中。因为 `set` 能够去重，所以最后输出 `set` 的大小即可。详见代码。
### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<vector>
#include<set>
using namespace std;
int n,m,minx,miny,a[505][505],vis[505][505],dx[4]={0,0,-1,1},dy[4]={-1,1,0,0};
bool cmp(const pair<int,int>&x,const pair<int,int>&y){
	if(x.first-minx!=y.first-minx){
		return (x.first-minx)<(y.first-minx);
	}
	return (x.second-miny)<(y.second-miny);
}
void dfs(int x,int y,vector<pair<int,int> >&v){
	vis[x][y]=1;
	v.push_back({x,y});
	for(int i=0;i<4;i++){
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&vis[xx][yy]==0&&a[xx][yy]==a[x][y]){
			dfs(xx,yy,v);
		}
	}
}
string zh(vector<pair<int,int> >&v){
	minx=n,miny=m;
	for(auto x:v){
		minx=min(minx,x.first);
		miny=min(miny,x.second);
	}
	sort(v.begin(),v.end(),cmp);
	string ans;
	for(auto x:v){
		ans+=to_string(x.first-minx)/*数字转string*/+"zheshifengefu"+to_string(x.second-miny)+"zheshijieshufu"; 
	}
	return ans;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	set<string>els;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!vis[i][j]){
				vector<pair<int,int> >v;
				dfs(i,j,v);
				string s=zh(v);
				els.insert(s);
			}
		}
	}
	cout<<els.size();
	return 0;
}
```

---

## 作者：Lycd0719 (赞：1)

## 题意
给你一张图，让你判断有多少形状相同的方块。
## 思路
set 的去重就是好

循环遍历图中的每一个点，如果没有被访问过，先  dfs，找出整个方块，放入一个 vector 中。

把每一个方块平移到左上角，然后放入一个 set 中，自动去处形状相同的方块。

最后输出 set 的长度

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000][1000];
int vis[1000][1000];
vector< pair<int, int> > e;
set<vector<pair<int, int> > > s;
int dx[] = { 1,0,-1,0 };
int dy[] = { 0,1,0,-1 };
int n, m;
void dfs(int x, int y) {
	vis[x][y] = 1;
	int i, j, k;
	e.push_back({ x,y });
	for (i = 0; i < 4; i++) {
		int tx = x + dx[i];
		int ty = y + dy[i];
		if (tx >= 1 && tx <= n && ty >= 1 && ty <= m && vis[tx][ty] == 0 && a[tx][ty] == a[x][y]) {
			dfs(tx, ty);
		}
	}
}
void go() {
	int minx = INT_MAX, miny = INT_MAX;
	for (auto x : e) {
		minx = min(minx, x.first);
		miny = min(miny, x.second);
	}
	for (int i = 0; i < e.size(); i++) {
		e[i].first -= minx;
		e[i].second -= miny;
	}
	sort(e.begin(), e.end());
	s.insert(e);
}
signed main() {
	
	cin >> n >> m;
	int i, j, k;
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= m; j++) {
			cin >> a[i][j];
		}
	}
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= m; j++) {
			if (vis[i][j] == 0) {
				e.clear();
				dfs(i, j);
				go();
			}
		}
	}
	cout << s.size();
}
```

---

## 作者：linjinkun (赞：1)

其实就是个搜索。

由于题目~~太过复杂~~我太逊了看不太懂，所以在这提供题意简述。

### 题意简述

有一个大小为 $n \times m$ 的矩阵，请找出所有不重复连通块的数量。

定义两个连通块是重复的，当且仅当这两个连通块的形状完全相同。举个例子：
```
1 1 1 
1 1
```

```
2 2 2 
2 2 
```

这两个连通块是重复的。

------------
### 思路：
第一步：泛洪找出所有连通块。

额……应该不用多说了吧。

第二步：将每个连通块的形状记录下来。

我们发现，可以将每个连通块的对应位置记录下来，存到 ```vector``` 里，判重只需要看两个 ```vector``` 里的元素是否一样就行，可以用 ```set```。

代码（细节、注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 505;
int a[N][N];
int vis[N][N];
vector<pair<int,int>>e;//存位置
set<vector<pair<int,int>>>s;//去重
int qx,qy;
int dx[] = {0,0,1,-1};//搜索必备
int dy[] = {1,-1,0,0};
int n,m;
void dfs(int x,int y)//这个搜索板子不用多说了吧
{
	e.push_back({x-qx,y-qy});//qx是当前找到的连通块起点的x坐标，qy是当前找到的连通块起点的y坐标，(x-qx,y-qy)就是(x,y)的相对位置
	for(int i = 0;i<4;i++)
	{
		int r = x+dx[i],c = y+dy[i];
		if(r>=1&&r<=n&&c>=1&&c<=m&&vis[r][c] == 0&&a[x][y] == a[r][c])
		{
			vis[r][c] = 1;
			dfs(r,c);
		}
	}
}
signed main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1;i<=n;i++)
	{
		for(int j = 1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	for(int i = 1;i<=n;i++)
	{
		for(int j = 1;j<=m;j++)
		{
			if(vis[i][j] == 0)//当前点没有被访问过
			{
				qx = i;//记下来
				qy = j;
				vis[i][j] = 1;//一定要标记
				dfs(i,j);
				s.insert(e);//把这个连通块的所有点的位置放进s去重
				e.clear();//多册不清空，爆零两行泪
			}
		}
	}
	printf("%d",s.size());//去过重之后，输出有几个连通块不重复
	return 0;
}
```

---

## 作者：wumingwei (赞：0)

# 思路
显而易见是一道 DFS 搜索题，我们可以对每一个连通块从**左上角**开始 DFS，用 `vector<pair<int><int> > v` 来存储每个搜索到的点对于左上角的点得相对位置，再用 `map` 来存储每种连通块是否遇到过。

注意，当我们的方向数组**顺序唯一**时，我们对于同一种连通块的 `v` 也是**唯一**的。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=503;
map<vector<pair<int,int> >,bool> p;
int n,m,xx,yy,z,sum;
int a[N][N];
int fx[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
bool book[N][N];
vector<pair<int,int> > v;
void dfs(int x,int y)
{
	v.push_back(make_pair(x-xx,y-yy));
	book[x][y]=1;
	for(int i=0;i<4;i++)
	{
		int nx=x+fx[i][0],ny=y+fx[i][1];
		if(!book[nx][ny]&&a[nx][ny]==z)
		{
			dfs(nx,ny);
		}
	}
}
int main()
{
	std::ios::sync_with_stdio(false);
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(!book[i][j])
			{
				v.clear();
				xx=i,yy=j,z=a[i][j];
				dfs(i,j);
				if(p[v]==0)
				{
					p[v]=1;
					sum++;
				}
			}
		}
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：llqw (赞：0)

### 题目大意
说了一大堆，其实题意很朴素，就是告诉你一个矩阵，相邻的同一种颜色被统称为一种图形，颜色不同，但形状相同的图形是一种图形，现在问你这个矩形中有多少种图形。

### 思路
可以立刻想到这是一个 Flood Fill（洪水填充）DFS 算法，但问题也随之而来，如何判断两种图形是不是同一图形？也就是去重问题，说到去重，大家应该会~~立马~~想到 `set`，不仅去重还排序，那我们又如何用 `set` 去存储一个图形呢？很简单，直接把这个图形所有节点扔进去，并让这些节点保持有序，这样，下一次遇见这种图形，`set` 直接就去掉了，最后的答案就是 `set.size()`。剩下的就是一些模板了。请结合注释理解代码。

### Code


```cpp
#include<bits/stdc++.h>
#define ll long long
#define MAXN 1000
using namespace std;
ll n,m;
ll a[MAXN][MAXN];//原数组
ll vis[MAXN][MAXN];//标记访问
ll movex[4]={1,0,-1,0};
ll movey[4]={0,1,0,-1};
//位移数组
vector<pair<ll,ll>>g;//图形
set<vector<pair<ll,ll>>>s;//去重 set
void dfs(ll x,ll y){//Blood Fill模板
	vis[x][y]=1;//标记起点
	g.push_back({x,y});//加入图形
	for(ll i=0;i<4;i++){
		ll nownx=x+movex[i],nowny=y+movey[i];//加上位移量
		if(nownx>=1 and nownx<=n and nowny>=1 and nowny<=m and vis[nownx][nowny]==0 and a[nownx][nowny]==a[x][y])dfs(nownx, nowny);
      //判断是否越界，是否访问过，是否是同一种颜色
	}
}
void work(){
	ll minx=INT_MAX,miny=INT_MAX;
	for(ll i=0;i<g.size();i++) minx=min(minx,g[i].first),miny=min(miny,g[i].second);
	for(ll i=0;i<g.size();i++) g[i].first-=minx,g[i].second-=miny;
	sort(g.begin(),g.end());//让图形变得有序才能去重
	s.insert(g);//直接扔进去
}
void init(){
	cin>>n>>m;
	for(ll i=1;i<=n;i++)
		for(ll j=1;j<=m;j++)
			cin>>a[i][j];
}
void ma(){
	for(ll i=1;i<=n;i++)//遍历每一个位置
		for(ll j=1;j<=m;j++){
			if(vis[i][j]==0){//如果没有被访问过就以此节点为起点，发动 flood fill
				g.clear();//记得清空
				dfs(i,j);//发动搜索
				work();//记录
			}
		}
}
int main() {
	init();
	ma();
	cout<<s.size();//s里面有多少个元素即为答案
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/159694219)

---


# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# 题解

## 作者：Crazily (赞：77)

老师出了一张pj模拟卷

第二题就是这玩意。。。。

考场上的我一看到进制转换就瘫了。。。。。

考完之后才又去写了一遍

发现它的核心思想并不是题目所说的那样去判断不同进制的“波浪”

逆向思维一下

其实我们应该先生成所给范围内的波浪数

（就是把每个波浪数打出来存进一个装‘重数’的数组里）

然后直接遍历数组输出想要的重数的数就行啦

这样不仅不会超时而且代码也更容易实现

（咋考试时就想不到呢。。。。。。）

本人拙码：

```
#include<bits/stdc++.h>
using namespace std;
int a,b,l,r,c,t,x;
int v[10000005];//存储重数 
int main(){
	memset(v,0,sizeof(v));
	scanf("%d%d%d%d%d",&a,&b,&l,&r,&c);
	for(int k=a;k<=b;++k){
		for(int i=1;i<k;++i){
			for(int j=0;j<k;++j){
				if(i!=j)//不能是相同的数波浪
				{
				x=0;
				t=0;
				while(x<=r){
					if(t%2==0){
						x=x*k+i;
						++t;
					}
					else{
					    x=x*k+j;
					    ++t;
					}
					if(x>=l&&x<=r) ++v[x];
				}
				}
			}
		}
	}
	for(int i=l;i<=r;++i){
		if(v[i]==c) printf("%d\n",i);
	}
} 
```

---

## 作者：Star_Wind (赞：21)

对于蒟蒻来说，这种题，管他神马数学法，呵呵，直接暴力

不过为了~~装逼~~显出风度

还是开了个子程序

所以思路很简单，依次枚举判断，用b数组标记起来就可以了

而且个人觉得代码似乎没有用到进制？

不多说了，构造大家都会，利用波浪数的特性求出t，再标记一下

附上AC代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<algorithm>
#define inf 700000000
using namespace std; 
int k,l,r,jl,jr,a[40],b[10000010],len,t;
void make(int x)
{
    for(int i=1;i<x;i++)
      for(int j=0;j<x;j++)
      if(i!=j)
      {
           len=0;
           t=0;
           while(t<r)
           { 
               len++;
               if(len%2==0) a[len]=i;
               else a[len]=j;
               t=t*x+a[len];
               if(t>r) break;
               b[t]++;
           }
      } 
}
int main()
{
    cin>>jl>>jr>>l>>r>>k;
    for(int i=jl;i<=jr;i++) 
      make(i);
    for(int i=l;i<=r;i++)
      if(b[i]==k) printf("%d\n",i);
    return 0;
}
```


---

## 作者：zhuangzhenhao168 (赞：9)

谁说暴力不能过啦？

我就是用暴力过的！
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int a,b,c,d,e;

bool h(int k,int l){  //判断每一个数k的l进制是不是波浪数
    int x,y,z,w;
    x=k%l;
    k/=l;
    y=k%l;
    k/=l;
    if(x==y){
        return 0;
    }
    while(k){
        z=k%l;
        k/=l;
        if(z!=x){
            return 0;
        }
        if(k){
            w=k%l;
            k/=l;
            if(w!=y){
                return 0;
            }
        }
    }
    return 1;
}

bool f(int k){     //得出每一个数的重数
    int s=0;
    for(int i=a;i<=b;i++){
        if(h(k,i)){
            s++;
            if(s>e){
                return 0;
            }
        }
    }
    if(s==e){
        return 1;
    }
    return 0;
}

int main(){
    cin>>a>>b>>c>>d>>e;
    for(int i=c;i<=d;i++){  //枚举每一个十进制数
        if(f(i)){
            cout<<i<<endl;
        }
    }
    return 0;
}
   
```
完美收官～～～


---

## 作者：千梦羽翼 (赞：8)

这题用穷举法肯定是不行的，必须要反过来想，生成波浪数，然后再判断。

------------
生成部分：
- for (i=a;i<=b;i++)   穷举a到b进制
- for (j=1;j<=i-1;j++) 第1个数 所以是从1开始   
- for (k=0;k<=i-1;k++) 第2个数 所以是从0开始 
- - - - 
生成第二部分：
```cpp
x=0;t=0;    x和t交替产生波浪数
     while (x<=d)
       {
        if (t%2==0) 为了交替放数（用devc++自己调一下就知道了）
         {
          x=x*i+j;
          t++;
         }
        else
         if  (t%2==1)
           {
          x=x*i+k;
          t++;
           }
```
- - - - 
判断：
if (x>=c &&x<=d) q[x]++; 
- - - - 
已通过：
```cpp
#include<bits/stdc++.h>
using namespace std;  
int ans,a,b,e,c3,c,d,i,x,j,j2,k,t,m;  
int  q[10000005];
int main()  
  {  
  cin>>a>>b>>c>>d>>m;
 for (i=a;i<=b;i++)   
   for (j=1;j<=i-1;j++)    
    for (k=0;k<=i-1;k++)  
	 if (j!=k)    
   {
     x=0;t=0;   
     while (x<=d)
       {
        if (t%2==0)
         {
          x=x*i+j;
          t++;
         }
        else
         if  (t%2==1)
           {
          x=x*i+k;
          t++;
           }
       if (x>=c &&x<=d) q[x]++;  
       }
    }
      for (i=c;i<=d;i++)  
        if (q[i]==m) cout<<i<<endl;
   return 0;
}  

```

---

## 作者：黄琪2019 (赞：8)

```
序言：
 我们都是阴沟里的虫子,但总还是得有人仰望星空

						——刘慈欣 《三体》
```

蒟蒻本来想要使用暴力可是分析数据，暴力肯定不行

考虑是否可以模拟，发现虽然不能纯模拟，但可以使用波浪数的特性求出t，再标记一下

话不多说上代码：
```cpp
#include<bits/stdc++.h>//万能头
#define inf 700000000//防爆
using namespace std; 
int k,t1,w1,t,w,a[40],b[10000010],n,tt;//k表示要找的波浪数的重数 ,t和w表示进制的范围（2-32）,t1和w1表示指定的范围（1-100000001）
```
以上为定义和头文件没有什么好解释的，主要是这些数组和变量最好使用自己比较熟悉的，方便检查
```cpp
void m(int x){//x是进制，一次函数（一次性函数，只用一次的函数）
    for(int i=1;i<x;i++){
    	for(int j=0;j<x;j++){//双重循环 
    		if(i!=j){//如果i==j结果就是11111...或22222...就不是波浪数
				n=1;//更新
				t=1;//更新
				while(tt<w1){ 
					if(n%2==0) a[n]=i;
					else a[n]=j;//利用波浪数的特性ijijij...（比如131313(i=1;j=3)，132132132...(i=11;j=12)）
					tt=tt*x+a[n];//利用波浪数的特性求出t，再入桶（桶排序思想）一下
					if(tt>w1) break;//大于结尾的数字退出,防止b数组爆RE 
					b[tt]++;//入桶（桶排序思想）
					n++;//及得跟新
				}
	   		} 
		}
	}
}
```
以上是主要程序，需要注意的是先判断tt是否大于w1然后再入桶，不然b数组爆RE 

蒟蒻就死在了b数组爆RE了一次
```cpp
int main(){
	cin>>t>>w>>t1>>w1>>k;//读入
	for(int i=t;i<=w;i++) {
    	m(i);
	}
    for(int i=t1;i<=w1;i++){
    	if(b[i]==k) printf("%d\n",i);//输出，记得加特判
	}
	return 0;//完美结束
}//有一处错误，为了防止抄袭，各神犇看懂思路后找一找，评论区告诉我哦
```


---

## 作者：Skywalker_David (赞：5)

进制1-32，数值1-10000000，一个一个算肯定不现实

(1)直接找到a,b在k进制下的数字最多能达到多少位数

(2)每一位数从1到k，两个循环构造在(1)条件下的波浪数,看是否在a,b范围内

(3)开一个hash数组存贮每一个数的重数

```cpp

#include<iostream>
using namespace std;
int x, y, a, b, k;
short Hash[10000001];//占两个字节，减少内存
int Len(int x, int k){
    int cnt = 0;
    while (x){
        x /= k;
        ++cnt;
    }
    return cnt;
}
int make(int a, int b, int len, int k){
    //在k进制范围下计算构造波浪数的值
    int x = 0, i;
    for (i = 1; i <= len; i++){
        if (i & 1)
            x = x*k + a;
        else
            x = x*k + b;
    }
    return x;
}
void Search(int k){
    int l = Len(a, k), r = Len(b, k), i, j, u;
    //数字首位不为零，构造波浪数，减少计算次数
    for (i = 1; i < k; i++)
    for (j = 0; j < k; j++){
        if (i == j) continue;
        for (u = l; u <= r; u++){
            int num = make(i, j, u, k);
            if (num >= a&&num <= b) Hash[num]++;
        }
    }
}
int main(){
    cin >> x >> y >> a >> b >> k;
    for (int i = x; i <= y; i++)
        Search(i);
    for (int i = a; i <= b; i++)
    if (Hash[i] == k)
        cout << i << endl;
    return 0;
}
```delphi

---

## 作者：Y_B_Y (赞：4)

## 构造数+判断几重

### 1.判断几重

用$yes[k]$表示十进制为k的数再规定进制内波浪的重数

### 2.构造

依据波浪数的定义,所以我们可以枚举那两个交替转换的数(如$121212$中的$12$),然后就循环构造,每次循环再转换为十进制,假设为$m$,则$yes[m]++$,而且我们发现如果那个数为$12$那么它的长度一定为偶数,但是为奇数时也可以,所以每循环构造一次时去掉第一位所生成的数也为这次循环所构造的数(如$1212$时,$212$也是它构造出来的波浪数)

转化十进制

1.$k$进制的第$i$位的数$j$转化为十进制所表示的数就是$j*k^{i-1}$
,如三进制的121212的第3位转化为十进制就是$2*3^{3-1}$,即18

2.整个k进制数转化为十进制就是把每一位转化的数加起来

### 3.判断输出

循环从范围开始到范围结束如果重数是题目要求的就输出

注意转化位其他进制是波浪数的十进制数不一定是波浪数(如题目中的300)

主要还是放在代码里讲

```cpp
#include<bits/stdc++.h>
using namespace std;
#define j1 jjj//j1是关键字
int j1,j2,st,ed,num;//前两个数表示进制的范围，第三与第四个数表示指定的范围，第五个数表示要找的波浪数的重数
int yes[10000001];//上面讲了
bool b[10000001]; //这是为了防止同一进制构造的数重复
int main()
{
	cin>>j1>>j2>>st>>ed>>num;//输入
	for(int p=j1;p<=j2;p++)
	{
		memset(b,0,sizeof(b));//不同的进制可以构造不同的数
		for(int i=0;i<=p-1;i++)//枚举第一个数
		{
			for(int j=0;j<=p-1;j++)//枚举第二个数
			{
				if(i==j) continue;//两数不能相等
				int tot=0;//记录构造出的数转化为十进制表示的数
				for(int l=1;l<=10;l++)
				{
					if(tot+j*pow(p,2*l-2)<=ed/*要小于范围最大值*/&&l>1) //去掉,注意去掉时,不需要更新tot的值,因为构造好只有一个数去掉就不能再构造了(如121212去掉1为21212,是波浪数,但对于12它不能继续构造了),所以不需要记录(记录是为了下一次构造直接加上新增加的两个数构成新构造的数所对应的十进制数,如121212,只要讲第5,6位的1,2转化位十进制再加上前面表示1212对应的十进制的tot就表示了121212对应的十进制),第一次循环时不能去第一位,因为一个数不是波浪数
					{
					if(!b[tot+(int)(j*pow(p,2*l-2))]) yes[tot+int(j*pow(p,2*l-2))]++;//如果没有重复,对应的十进制波浪重数加1
					b[tot+(int)(j*pow(p,2*l-2))]=1;//构造过了,记录,防止重复
				    }
					if(tot+i*pow(p,2*l-1)+j*pow(p,2*l-2)<=ed)//两个数都加上去,且要小于范围最大值
					{
					 tot+=i*pow(p,2*l-1)+j*pow(p,2*l-2);//tot的用处上面有讲
					 if(!b[tot])yes[tot]++;//没有重复,对应十进制波浪的重数+1
					 b[tot]=1;//记录
				    }
					else break;//大于范围,结束
				}
			}
		}
	}
	for(int p=st;p<=ed;p++) if(yes[p]==num) cout<<p<<endl;//找到合适的输出
		return 0;
}
```


---

## 作者：小越越 (赞：4)

一道挺简单的题吧，但是在考试的时候出到原题都没做出来。。。

思路楼下大佬都讲得很清楚，就是先构造各个进制下的波浪数，最后再扫一遍，判断给定范围内的数值是否符合要求，不用哈希直接开1e7的数组也可以过。

这题有几个坑点：１一位数是波浪数，比如十进制下的5，十一进制下的A，都是可以算的。２一对数是指不相等的两个数，在循环的时候要加一个判断。

交了无数次。。。


代码：
```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N = 1e7+10;
int a, b, l, r, w;
int s[2], v[N];

int main()
{
    cin >> a >> b >> l >> r >> w;
    for (int i = a; i <= b; i++){
        for (int j = 1; j < i; j++)
            for (int k = 0; k < i; k++)
                if (j != k){
                    int now = j, id = 1;
                    s[0] = j; s[1] = k;
                    while (now <= r){
                        v[now]++;
                        now = now*i+s[id];
                        id ^= 1;
                    }
                }
    }
    for (int i = l; i <= r; i++)
        if (v[i] == w)
            cout << i << endl;
    return 0;
}
```

---

## 作者：expnoi (赞：3)

比较详细的解法。

思路：这题不要想其他的，就找出他的突破点。我们不妨反着来推他。

我们设这个数为x

那么，我们在用它的时候，一定要保证他是合法的（波浪数）。

那么我们应该怎么构造这个数呢？

枚举i和j。分别表示波浪数里的两个数。

i和j的边界都是最多进制数k。

k一定≤32.

那聪明的同学肯定会有问题了。

11进制及以上的进制都是有用字母表示的，怎么办？

我们可以用数字代替。这并不会影响他的效果，反而会更加方便。

我们再用一个变量kk表示他的几位数，他的作用是枚举他是第几个数位了，以方便我们选择加上i还是j。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int a,b,l,r,c,kk,x,v[10000005];
int main()
{
    memset(v,0,sizeof(v));
    a=read();
    b=read();
    l=read();
    r=read();
    c=read();
    for(int k=a;k<=b;k++)//枚举进制
    {
        for(int i=1;i<k;i++)//枚举波浪的第一位
        {
            for(int j=0;j<k;j++)//枚举波浪的第二位
            {
                if(i!=j)//不能是相同的数波浪
                {
                    x=0;//x表示本次构造的波浪数
                    kk=0;
                    while(x<=r)//循环直到超过了上限
                    {
                        if(kk%2==0)//波浪的第一位
                        {
                            x=x*k+i;//在x的末尾添上i
                            kk++;
                        }
                        else//波浪的第二位
                        {
                            x=x*k+j;//在x的末尾添上j
                            kk++;
                        }
                        if(x>=l&&x<=r)
                        {
                            v[x]++;//对应的数字处记录的波浪重数+1
                        }
                    }
                }
            }
        }
    }
    for(int i=l;i<=r;++i)
    {
        if(v[i]==c)
        {
            write(i);
            puts("");
        }
    }
}
```

---

## 作者：qiubai11 (赞：3)

## 这道是签到题
- 但是我花了很久时间没写出来
悲伤，这里记录一下思维的过程吧
[牛客练习赛74](https://ac.nowcoder.com/acm/contest/9700)

```cpp WA
#include<iostream>
#include<cstdio>
using namespace std;
int a[100000];
int main()
{
    int n;
    int i;
    int cnt=0,b=0,c=0,d=0;
    scanf("%d",&n);
    for(i=0; i<n; i++)
    {
        scanf("%d",&a[i]);
    }
    if(n<3)
    {
        printf("NO");
        return 0;
    }
    for(i=0; i<n-2; i++)
    {
        if(a[i]+a[i+2]==2*a[i+1])
            cnt++;
        else
            break;
    }
     for(i=0; i<n-2; i++)
    {
        if(a[i]*a[i+2]==a[i+1]*a[i+1])
           b=1;
        else
            break;
    }
     for(i=0; i<n-2; i+b+)
    {
        if(a[i+1]%a[i]==a[i+2]%a[i+1])
            c=1;
        else
            break;
    }
    if(dengcha==1)
        printf("YES");
    else
        printf("NO");
    return 0;
}
```
这里是想着用累加滚动的形式把题目做出来，后来发现自己卡了很久就烂尾了

------------
这里贴一下dl的代码 AC
```cpp
#include<stdio.h>
long long a[100005];
int main(){
    int n,i,cont=0,b=0,c=0;
    scanf("%d",&n);
    for(i=0;i<n;i++){
      scanf("%lld",&a[i]);
    }
    if(n<3){
        printf("NO");
        return 0;
    }
    int p=0;//p相当于是一个旗帜；
    for(i=0;i<n-2;i++){
      if(2*a[i+1]==a[i]+a[i+2]){
       
         cont++;
         if(cont==n-2){
           p=1;
           printf("YES");
           return 0;} //一定要return 0，不然输出好多个yes
         }
      }
      for(i=0;i<n-2;i++){
      //cont=0;
      if(a[i+1]*a[i+1]==a[i+2]*a[i]){
         b++;
         if(b==n-2){
            p=1;
            printf("YES");
            return 0;}
           }
      }
      for(i=0;i<n-2;i++){
      cont=0;
      if(a[i+1]%a[i]==a[i+2]%a[i+1]){
         c++;
         if(c==n-2){
            p=1;
            printf("YES");
            return 0;
           }
      }
    }
    if(p==0){
        printf("NO");
    }
    return 0;
}
```
- 然后就转变思想，找不同 WA
                          
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long a[100005];
int main()
{
    int n;
    int i;
    int b=0,c=0,d=0;
    scanf("%d",&n);
    for(i=0; i<n; i++)
    {
        scanf("%lld",&a[i]);
    }

    for(i=0; i<n-2; i++)
    {
        if(a[i]+a[i+2]!=2*a[i+1])
            break;
        else
            d=1;
    }

     for(i=0; i<n-2; i++)
    {
        if(a[i]*a[i+2]!=a[i+1]*a[i+1])
            break;
        else
            b=1;
    }

     for(i=0; i<n-2; i++)
    {
        if(a[i+1]%a[i]!=a[i+2]%a[i+1])
            break;
        else
            c=1;
    }

    if(d==1||b==1||c==1)
        printf("YES\n");
    else
        printf("NO\n");
    return 0;
}

```
  这个时候我还没意识到自己每个循环里非常大的问题
  那就是 如果我输入的数列里前面几个是满足数列要求，但是后面不满足的话，我的旗帜也变了且后面无法改变，导致答案错误，
  虽然测试显示我通过了90%的样例，但是千万就不要觉得这个是小问题啊！！！
  后来在dz'的帮助下我成功发现了自己的思维的漏洞
  
 
  ```cpp AC
#include<iostream>
#include<cstdio>
using namespace std;
long long a[100005];
int main()
{
    int n;
    int i;
    int b=1,c=1,d=1;
    scanf("%d",&n);
    for(i=0; i<n; i++)
    {
        scanf("%lld",&a[i]);
    }

    for(i=0; i<n-2; i++)
    {
        if(a[i]+a[i+2]!=2*a[i+1])
            {d=0;break;} //加个break 时间min ；但是这道题然并卵
    }

     for(i=0; i<n-2; i++)
    {
        if(a[i]*a[i+2]!=a[i+1]*a[i+1])
            {b=0;break;}
    }

     for(i=0; i<n-2; i++)
    {
        if(a[i+1]%a[i]!=a[i+2]%a[i+1])
            {c=0;break;}
    }

    if(d||b||c)
        printf("YES\n");
    else
        printf("NO\n");
    return 0;
}

```
  这个思维就是如果我找到了不同，就直接改标记，不用考虑相同的情况，旗帜没变嘛！！
  
  这个思想转变非常非常重要 要引起重视！！！

  再if / else形式判断旗子输出来
  
  最后把dzdl的快读代码摆出来，供以后碰到时间限制太死的情况用；
  时间排序 快读《scanf《cin；
  
  
```cpp
#include<bits/stdc++.h>
int n,f1=1,f2=1,f3=1;
int a[100005];
template <typename  T>inline void read(T&x){
    T f=1;x=0;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    x*=f;
}
int main(){
    read(n);
    for(int i=1;i<=n;i++)read(a[i]);
    int A=a[2]-a[1],C=a[2]%a[1]; //建立两个基准数，树为标准
    for(int i=3;i<=n;i++){
        if(a[i]-a[i-1]!=A)f1=0;
        if(a[i]*a[1]!=a[i-1]*a[2])f2=0; /*等比要变一下，不能直接简单相除，细节处理*/
        if(a[i]%a[i-1]!=C)f3=0;
    }
    if(f1||f2||f3)printf("YES\n");
    else printf("NO\n");
    return 0;
}
```



 
             
                     

---

## 作者：Qwdb (赞：1)

# **P1112 波浪数 题解**

## [移步至博客阅读效果更佳](https://qwdb.github.io/post/P1112/)

[题目链接](https://www.luogu.com.cn/problem/P1112)

序言：~~以后想不出序言说什么就放一句名言吧~~

     我们都是阴沟里的虫子,但总还是得有人仰望星空

							——刘慈欣 《三体》

### 1. 入手程序
第一步，分析数据，暴力肯定不行

第二部，考虑是否可以模拟，发现虽然不能纯模拟，但可以使用...

#### 构造法

### 2. 编程思路
所谓的构造法，指的是逆向的通过枚举或其他方法来构造出题目要求的数或情况

具体到这一题，就是枚举i进制下j，k轮流出现构成的波浪数的存在并存到对应重数数组下

最后将题目要求的重数输出出来

#### 注意：
1. 一位数也可以是波浪数
2. 波浪数轮流出现的两个数不能一样
3. 波浪数不一定要是“ababab...”形式，也可以是“abababa...”形式
4. 一个波浪数不一定一定要在十进制下是波浪数
### 3. AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int m[10000005];//存重数 
int a,b,c,d,e;
int main()
{
	cin>>a>>b>>c>>d>>e;
	for(int i=a;i<=b;i++)//在i进制下 
	{
		for(int j=0;j<i;j++)//枚举第一个数 
		{
			for(int k=1;k<i;k++)//枚举第二个数 
			{
				if(j!=k)//两数不能一样 
				{
					int v1=0;//构造用 
					int v2=0;//计数 用 
					while(v1<=d)
					{
						//循环用两个数构造 
						if(v2%2==0)
						{
							v1=v1*i+j;
						}
						else
						{
							v1=v1*i+k;
						} 
						v2++;
						if(v1>=c && v1<=d)
						{
							m[v1]++;//如果是波浪数，存到对应位置 
						}
					}
				}
			}	
		} 
	}
	for(int i=c;i<=d;i++)
	{
		if(m[i]==e)//如果有题目要求的重数，输出
		{
			cout<<i<<endl;	
		} 
	}
	return 0;
}
```
### 我是千文杜博，记住我呦~~
#### The end

---


# 01迷宫

## 题目描述

有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

## 说明/提示

对于样例，所有格子互相可达。

- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 50$；
- 对于 $50\%$ 的数据，$m \leq 5$；
- 对于 $60\%$ 的数据，$n,m \leq 100$；
- 对于 $100\%$ 的数据，$1\le n \leq 1000$，$1\le m \leq 100000$。

## 样例 #1

### 输入

```
2 2
01
10
1 1
2 2
```

### 输出

```
4
4
```

# 题解

## 作者：1124828077ccj (赞：827)

胰，怎么没人说DFS，谁说DFS过不了，看以下AC代码，搜索过了标记一下，下次搜索时就不用在找一次了

```cpp

#include<cstdio>
#include<cstring>
int n,m,ans[100002],x,y,f[1002][1002];
char s[1002][1002];
void dfs(int r,int c,int z,int lll){
    if (r<0 || r>=n || c<0 || c>=n || f[r][c]!=-1 || s[r][c]-'0'!=z)return;
    f[r][c]=lll;ans[lll]++;
    dfs(r-1,c,!z,lll);dfs(r+1,c,!z,lll);dfs(r,c-1,!z,lll);dfs(r,c+1,!z,lll);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=0;i<n;i++)
    scanf("%s",s[i]);
    memset(f,-1,sizeof(f));
    for (int i=0;i<m;i++)
    {
        scanf("%d%d",&x,&y);x--;y--;
        if (f[x][y]==-1)dfs(x,y,s[x][y]-'0',i);else ans[i]=ans[f[x][y]];
    }
    for (int i=0;i<m;i++)
    printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：钟情暴力 (赞：355)

水平不高，写这题时遇到不少问题，所以发个题解看看能不能帮到大家找到忽视的地方。

刚开始看到这题就觉得应该用宽搜来做，于是直接打了一个宽搜程序，如下：



```cpp
#include<bits/stdc++.h>
using namespace std;
int _map[1001][1001];
bool flag[1001][1001];
struct mg
{
    int x,y;
}q[1000001];
//超时3个点 
int main()
{
    int sx,sy,i,j,n,m,l,nx,ny,k,f,r,sum;
    int dx[4]={0,0,-1,1};
    int dy[4]={1,-1,0,0};
    char ch;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            cin>>ch;
            if(ch=='1') _map[i][j]=1;
            else _map[i][j]=0;
        }
    for(l=1;l<=m;l++)
    {
        cin>>sx>>sy;
        sum=1;
        f=1;
        r=1;
        q[f].x=sx;
        q[f].y=sy;
        memset(flag,true,sizeof(flag));
        flag[sx][sy]=false;
        while(f<=r)
        {
            for(k=0;k<4;k++)
            {
                nx=q[f].x+dx[k];
                ny=q[f].y+dy[k];
                if(flag[nx][ny]&&nx>=1&&nx<=n&&ny>=1&&ny<=n&&((_map[nx][ny]==0&&_map[q[f].x][q[f].y]==1)||(_map[nx][ny]==1&&_map[q[f].x][q[f].y]==0)))
                {
                    r++;
                    sum++;
                    flag[nx][ny]=false;
                    q[r].x=nx;
                    q[r].y=ny;
                }
            }
            f++;
        }
        cout<<sum<<endl;
    }
    return 0;
}
```
然后悲惨的超时3个点。。。很明显，这题数据很大，读一组查一遍必然爆炸。此时应该加以优化，于是就有了以下程序：


```cpp
#include<bits/stdc++.h>
using namespace std;
char _map[1001][1001];//_map数组保存地图 
int flag[1001][1001],a[1000001];//a数组要开大一点，刚开始开a[1001]错了3个点 
//flag数组保存各个点所在的连通图，以及是否已经处理过，a数组保存各个连通图的大小
struct mg
{
    int x,y;
}q[1000001];
int main()
{
    int sx,sy,i,j,n,m,l,nx,ny,k,f,r,sum,d;
    int dx[4]={0,0,-1,1};
    int dy[4]={1,-1,0,0};//四个方向
    scanf("%d %d",&n,&m);//n是正方形地图边长，m是数据组数 
    memset(a,0,sizeof(a));
    memset(flag,0,sizeof(flag)); //你可以无视这两行memset
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            cin>>_map[i][j];//读入地图 
    d=0;//d用来保存当前是在第几个连通图中 
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(flag[i][j]==0)//如果当前位置不在已知连通图中（还未处理过） 
            {
                d++;//记录当前所在连通图数 
                f=1;
                r=1;
                q[f].x=i;
                q[f].y=j;
                flag[i][j]=d;
                sum=1;//初始化
                while(f<=r)
                {
                    for(k=0;k<4;k++)
                    {
                        nx=q[f].x+dx[k];
                        ny=q[f].y+dy[k];
                        if(flag[nx][ny]==0&&nx>=1&&nx<=n&&ny>=1&&ny<=n&&((_map[nx][ny]=='1'&&_map[q[f].x][q[f].y]=='0')||(_map[nx][ny]=='0'&&_map[q[f].x][q[f].y]=='1')))
                        //如果新位置能走且在地图上 
                        {
                            r++;
                            sum++;//计数器累加 
                            flag[nx][ny]=d;//标记新位置在第d个连通图中 
                            q[r].x=nx;
                            q[r].y=ny;//更新位置 
                        }
                    }
                    f++;
                }
                a[d]=sum;//保存当前连通图能移动到多少格 
            }
    for(i=1;i<=m;i++)
    {
        cin>>sx>>sy;//读入询问 
        cout<<a[flag[sx][sy]]<<endl;//直接查找答案并输出 
    }
    return 0;
}
```
本人刚开始将数组开小了，然后WA 4个点满脸懵。思想借鉴吸取了之前的一些题解，就是将初始地图分割成一个个联通图。
注意：如果整张图全是1或全是0的话连通图数量会极大，数组开小会WA，直接一遍遍搜索会超时。

第一次发题解语言表述可能不好请多包涵。。。


---

## 作者：杨稳健 (赞：230)

本人萌新一只，这道题在AC之前交了35遍，做了三天，中间夹杂着做了两道题，深有感触啊啊啊啊！！应该是踩了一遍所有的坑，所以发篇题解纪念一下！（我会告诉你们我因为过了这道题在家疯狂拍桌子然后出去吃了顿火锅纪念一下？？）

------------
比较菜所以用的最简单的bfs。理所当然的三个点都超时。（因为数组开的不够大还有两个是错的）

文中的wb，tp都是自己的好老师哈哈哈，每次害怕自己的变量在循环中重复就会出现他俩的名字呢哈哈哈。

这里w，b用来判断前后位置是否字符不相同，也就是0或1。
xx yy两个队列用来储存搜索点的坐标。
map数组储存了整张地图。
book数组标记点是否到达过，这里它是不用多次重置的，因为联通块的思想就是当我一整块搜索完了之后他们中的成员就不用第二次搜索，从而提高效率。
step就用来储存每个点能到达多少个点啦~~
inx，iny就用来储存在搜索中，每一个联通块中的每个成员。

```cpp
#include<cstdio>
#include<cstdlib>
#include<queue>
#include<iostream>
using namespace std;
queue<int >xx;
queue<int >yy;
char w,b;
char map[1001][1001];
int book[1001][1001]={};
int step[1001][1001]={};
int inx[1001]={};
int iny[1001]={};
int n,m;
int sum=1;
int bfs(int ,int );
int i,j;
int main()
{
    scanf("%d%d",&n,&m);
    for(int t=1;t<=n;t++)
    {
        for(int p=1;p<=n;p++)
                    cin >> map[t][p];
    }
    for(int t=1;t<=m;t++)
    {
            scanf("%d%d",&inx[t],&iny[t]);
    }
    for(int b=1;b<=m;b++)
    {
            for(int w=1;w<=1000;w++)
            for(int b=1;b<=1000;b++)
            {
                    book[w][b]=0;
                    step[w][b]=0;
                    sum=1;
            }
    	xx.push(inx[b]);
    	yy.push(iny[b]);
    	printf("%d\n",bfs(inx[b],iny[b]));
    }
    getchar();
    getchar();
    return 0;
}
int bfs(int x,int y)
{
     int move[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
     book[x][y]=1;
     int nx,ny;
     while(xx.size()!=0 && yy.size()!=0)
     {       
             xx.pop();
             yy.pop();
     for(int t=0;t<4;t++)
      {
             
             nx=x+move[t][0];
             ny=y+move[t][1];
             w=map[x][y];
             b=map[nx][ny];
             if(book[nx][ny]==0 && w!=b && nx>0 && ny>0 && nx<=n && ny<=n)
             {                  
                                
                                sum++;
                                book[nx][ny]=1;
                                step[nx][ny]=step[x][y]+1;
                                xx.push(nx);
                                yy.push(ny);
             }
      }
      x=xx.front();
      y=yy.front();
     }
     return sum;
}

```
------------
之后的两天就疯狂查错，发现是自己inx，iny数组开的过于小，应该开到m的范围也就是100000。
并且为了提高性能加入联通块这个思想。
即在进行bfs的过程中，对于每一个搜索到的点都记录，搜索结束之后，刚刚记录的所有点可到达的位置都相同。
举个例子：
一个池塘里，在任意一点放入一条鱼，它可以游到的位置是整个池塘，无论你选择从东边放入还是西边，是从正中间还是某一个对你有特殊意义的点。

还没理解也没关系，例子多得是：
你想去认识学校中所有的大佬，你需要从你的班级去到整个学校所有的班级，如果我们并不关注路径过程，结果一定是你去到了所有年级的所有班级，但无论你是小学三年级还是初中三年级亦或是高三年级，你都会去到每一个班里。
联通块如果各位看完还是不能理解的话，作为菜鸡确实找不到什么更形象的例子了，麻烦各位移步百度。
然后附上AC代码，里面会再次解释。
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
#include<iostream>
using namespace std;
queue<int >xx;
queue<int >yy;
char w,b;
char map[1001][1001];
int book[1001][1001]={};
int step[1001][1001]={};
int in[1000001][3];
int inx;
int iny;
int n,m;
int bfs(int ,int );
int i,j;
int main()
{
    scanf("%d%d",&n,&m);
    for(int t=1;t<=n;t++)
    {
        for(int p=1;p<=n;p++)
                    cin >> map[t][p];
    }//注意：这里读入我也调试了超级久
    //好像因为洛谷的原因
    //如果使用scanf（%c）用getchar（）；吸收字符的时候会出现一些些问题，
    /*for(int t=1;t<=n;t++)
    {
        for(int p=1;p<=n;p++)
                    printf("%c",map[t][p]);
            printf("\n");
    }*/
    //这个注释用来看看自己的map到底有没有输对，毕竟只有地图对了才有可能做题，地图上我就查了一天，要不是有大佬告诉我getchar（）不好使，我可能会和scanf（）对刚一整天
    for(int t=1;t<=m;t++)
    {
            scanf("%d%d",&inx,&iny);
            if(book[inx][iny]==0)
            {
                bfs(inx,iny);
                printf("%d\n",step[inx][iny]);
            }
            else
            {
                printf("%d\n",step[inx][iny]);
            }
            //这里发现可以读一个查一个，于是就没有再用整个数组存进来然后重头再扫一次。
    }
    getchar();
    getchar();
    return 0;
}
int bfs(int x,int y)
//咳咳！这里是折腾我最久的地方了
{
     int flag=1;
     //flag是因为实在想不到别的好的变量名去存可以到的地点的个数，后来发现flag貌似和sum一样
     int nx,ny;
     int move[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
     int sum=1;
     in[flag][1]=x;
     in[flag][2]=y;
     book[x][y]=1;
     xx.push(x);
     yy.push(y);
     //这里一定要记得标记起点和将起点的坐标放进队列，这里也看了好久才发现。
     while(xx.size()!=0 && yy.size()!=0)
     {       
             xx.pop();
             yy.pop();
     for(int t=0;t<4;t++)
      {
             nx=x+move[t][0];
             ny=y+move[t][1];
             w=map[x][y];
             b=map[nx][ny];
             if(book[nx][ny]==0 && w!=b && nx>0 && ny>0 && nx<=n && ny<=n)
             {                  
                                flag++;
                                in[flag][1]=nx;
                                in[flag][2]=ny;
                                book[nx][ny]=1;
                                xx.push(nx);
                                yy.push(ny);
                                sum++;
             }
      }
      x=xx.front();
      y=yy.front();
     }
     //上面都是简单的bfs，但是记得过程中要记录每一个能到的点。这里的book是不用重置的哦。
     for(int u=1;u<=flag;u++)
     {
             step[in[u][1]][in[u][2]]=sum;
     }
     //再将每一个成员能到的点的个数分别记录下来！他们能到的个数都一样哦~~
     return sum;
}

```
------------
整篇完结！
代码习惯不太好各位见谅，表述不清各位也多多包涵，如果真的看不懂可以看看其他大佬的题解，说的都超级简单易懂。


---

## 作者：RiverHamster (赞：152)

> 这是一篇发布于2017.11.19的早期题解，已经修改

楼下都说这题是什么并查集什么的，其实DFS联通块就可以了，没有那么复杂，速度也快。

[使用Markdown链接获取更好的阅读效果](https://www.zybuluo.com/RiverHamster/note/956433) **完整代码见链接中**

`时间：216ms` `单个点时间：68ms` `空间：36MB`

`时间复杂度` $O(n^2+m)$

## 主要思路

很容易就可以发现，所有**连接在一起的格子的答案是一样的**。

所以，只需要用DFS找到所有的联通块，联通块内所有的格子的答案都是这个联通块的格子数目。

## 程序实现

记录每个格子是否被搜过（在某个连通块中）。

两重循环，如果这格没搜过就从这个格子开始搜。

每搜到一个格子当前答案加1，**数组记录当前格子位置**，每次都向4个方向的满足条件的格子扩展。

搜完一块后把数组记录的格子的答案赋成连通块总的格子数。

读入时有个小技巧，对于二维字符数组a，`scanf("%s",a[i]+1)`可以以1下标读入一行。

(gets,strlen等同理，如`strlen(s+1)`1下标字符串长度）

## Code

```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++) if(!v[i][j]){ //枚举格子，没有访问过就DFS
        v[i][j]=true;                   //这格被访问
        now=0;                          //总数记为0
        dfs(i,j);                       //从这格开始搜索
        for(int i=1;i<=now;i++) f[ans[i][0]][ans[i][1]]=now; //依次赋值，重复使用并没有问题
    }
```
```cpp
#define nx x+dx[i] //增量数组表示下一个的x
#define ny y+dy[i] //增量数组表示下一个的y
#define check(x,y) (x>0&&x<=n&&y>0&&y<=n) //越界检查

void dfs(int x,int y){
    now++; //记录答案
    ans[now][0]=x,ans[now][1]=y; //记录连通块的格子
    for(int i=0;i<4;i++){ //搜索下一格
        if(check(nx,ny)&&!v[nx][ny]&&a[x][y]!=a[nx][ny]){
            //越界、访问、颜色判断
            v[nx][ny]=true; //记录访问状态
            dfs(nx,ny);     //下一格
        }
    }
}
```

## 一些问题（修改部分）
- 为什么复杂度是对的

每个格子都只被搜过一次，复杂度当然是对的，你TLE可能是你的复杂度问题。

- 为什么不会爆栈

OJ上栈空间和内存相等。本机评测可以在 Windows 上使用
`g++ a.cpp -o a -Wl,stack=268435456`编译成$256$MiB栈空间调试，自行网上搜索“g++ Windows 扩栈”。

---

## 作者：H_Bryan (赞：119)

# 01迷宫 标准并查集写法

很显然这是一道求连通块的题目，只需构造点到节点一一映射：

(i,j)=i*n+j;

即可套用并查集，效率也比较高。
## 代码

### dfs版本
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000005],h[1000005],n;//f[i]表示i节点的父节点,
                            //h[i]表示i节点及其子节点的连通块数
int st[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
char s[1005][1005];
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}//查
void unionn(int x,int y)//并
{
    int r1=find(x),r2=find(y);
    if(r1!=r2)h[r1]+=h[r2],f[r2]=f[r1];
}
int dfs(int fi,int fj)
{
    if(f[fi*n+fj]!=-1)return find(fi*n+fj);
    f[fi*n+fj]=fi*n+fj,h[fi*n+fj]=1;//构造映射
    for(int k=0;k<4;k++)
    {
        int i=fi+st[k][0],j=fj+st[k][1];
        if(i>=0&&i<n&&j>=0&&j<n&&s[fi][fj]!=s[i][j])unionn(fi*n+fj,dfs(i,j));
    }
    return find(fi*n+fj);
}
int main()
{
    int t;
    scanf("%d%d",&n,&t);
    memset(f,-1,4*n*n);
    for(int i=0;i<n;i++)scanf("%s",s[i]);
    int i,j;
    while(t--)
    {
        scanf("%d%d",&i,&j);
        printf("%d\n",h[dfs(i-1,j-1)]);
    }
    return 0;
}
```
### 循环版本
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000005],h[1000005],n;//f[i]表示i节点的父节点,
                            //h[i]表示i节点及其子节点的连通块数
char s[2][1005];//滚动数组
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}//查
void unionn(int x,int y)//并
{
    int r1=find(x),r2=find(y);
    if(r1!=r2)h[r1]+=h[r2],f[r2]=f[r1];
}
int main()
{
    int t;
    scanf("%d%d",&n,&t);
    for(int i=0;i<n;i++)
    {
        scanf("%s",s[i&1]);
        for(int j=0;j<n;j++)
        {
            f[i*n+j]=i*n+j,h[i*n+j]=1;//构造映射
            if(i!=0&&s[(i-1)&1][j]!=s[i&1][j])unionn((i-1)*n+j,i*n+j);
            if(j!=0&&s[i&1][j-1]!=s[i&1][j])unionn(i*n+j,i*n+j-1);
        }
    }
    int i,j;
    while(t--)
    {
        scanf("%d%d",&i,&j);
        printf("%d\n",h[find((i-1)*n+j-1)]);
    }
    return 0;
}
```

---

## 作者：学委 (赞：101)

## 思路

见题意，由于每次只向四个方向尝试移动，所以可采用深搜（状态为坐标）。

然而数据规模中，n<=1000，m<=100000，如果每次输入坐标时重新走一次将会超时。

再想想，每一次搜索会找到一个区块，该区块中所有点的答案都相同，所以，答案可以存在一个数组里——

___

题目每给出一个坐标，

先判断该坐标是否已有答案（通过前面已给出的点搜索获得的），

是则直接输出，否则往下搜索。

搜索是这样的：先重置 $pl$（$pl$ 是当前区块的点的数量，因此它也表示当前区块的答案，$lin[1]$ ~ $lin[pl]$ 里面将会存储当前区块内所有点的坐标），

在一趟深搜过程中，每到一个新的点就 ++$pl$，并将该点的坐标存在临时数组里，搜索结束后再依据坐标数组把答案数组的对应位置填上 $pl$。一次深搜结束，置 $pl$ 为 $0$。

不能在深搜内部染色，因为过程中并不知道区域内到底有多少连通点。

___

## 具体解释

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001][1001];//01数组 
int res[1001][1001];//答案数组 
int lin[1000001][2];//临时的坐标数组 
int n, m, pl;//pl是当前区块连通的点数 
int b[4][2] = {{0,1},{1,0},{0,-1},{-1,0}}; //上下左右四方向的深搜，很有用

void dfs(int x, int y){
    pl++;//来到一个新的点，下面存储该点坐标 
    lin[pl][0] = x; 
    lin[pl][1] = y;
    res[x][y] = 1;//这个点已经走过了，只是为了防止一趟深搜内部走重复点，所以不需要赋为pl 
    for(int i = 0; i <= 3; i++){
        int u = x + b[i][0];//[u][v]即为目的地 
        int v = y + b[i][1];
        if(u < 1 || u > n || v < 1 || v > n)//超出边界？ 
            continue;
        if(res[u][v] > 0) continue;//走到过了 ？ 
        if(a[u][v] == a[x][y]) continue;//根据题意，并不能走？ 
        dfs(u, v);//以上条件都不满足才向下搜索 
    }
}

int main(){
    memset(res, 0, sizeof(res));//清空答案数组 
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            scanf("%1d", &a[i][j]);//%1d，限字宽，读入方便 
    for(int i = 1; i <= m; i++){
        pl = 0;//重置pl 
        int x, y;
        scanf("%d %d", &x, &y);
        if(res[x][y] > 0){//已经有答案 
            printf("%d\n", res[x][y]);
            continue;
        }
        dfs(x, y);
        for(int j = 1; j <= pl; j++)
            res[lin[j][0]][lin[j][1]] = pl; //依据坐标数组，为答案数组填上pl 
        printf("%d\n", pl);
    }
    return 0;
}
```

---

## 作者：ZERORUSH (赞：96)

### 这题呢，本人调了一个下午（中间还有吃饭打游戏什么的），差点半路夭折，最后还是写出来了。
思路：联通块染色

~~忙人就别看下面做题经历了~~

看到题目的时候，我先打了一个常规的dfs，3个点TLE（这个很正常），想了半天dfs不好去优化（染色整片联通块）（dalao勿喷，juruo是真的想不出来），就又打了个bfs来优化，辛辛苦苦打完后变成了WA三个点，WA的一声就哭了出来，最后，我终于找到了问题：
# for循环范围！！！
我在NOIP赛场上就夭折于此。。。

废话不多说了，上代码
```cpp
#include<iostream>
using namespace std;
char map[1001][1001];
int n,m,sx,sy,book[1001][1001],next[4][2]={1,0,0,1,-1,0,0,-1};
struct p1141{int x,y;}p[1000001];
void bfs(int x,int y)//基本的bfs，可以不用函数，个人习惯
{
	int ans=1,h=0,t=1,tx,ty;
	p[h].x=x;
	p[h].y=y;
	book[x][y]=1;
	while(h<t)
	{
		for(int k=0;k<=3;k++)
		{
			tx=p[h].x+next[k][0];
			ty=p[h].y+next[k][1];
			if(tx<1||ty<1||tx>n||ty>n||book[tx][ty]!=0||map[p[h].x][p[h].y]==map[tx][ty]) continue;
			p[t].x=tx;
			p[t].y=ty;
			book[tx][ty]=1;
			ans++;
			t++;
		}
		h++;
	}
	for(int j=0;j<t;j++)//将队列中的所有联通块染色，我原来写成j<=t了，所以就WA了。。。
	    book[p[j].x][p[j].y]=ans;
	return;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		    cin>>map[i][j];//读图
	for(int i=1;i<=m;i++)
	{
	    cin>>sx>>sy;//询问
		if(book[sx][sy]!=0) cout<<book[sx][sy]<<endl;//如果是查找过的联通块就直接输出
		else 
		{
			bfs(sx,sy);
			cout<<book[sx][sy]<<endl;
		}
	}
	return 0;
}
```
最好不要直接抄代码，先理解思路再自己打一遍。

没有仔细地去翻有没有相同思路的题解，望审核过。

不喜勿喷。

---

## 作者：Created_equal1 (赞：57)

事实上，本题不一定非要用搜索算法来解决。可以使用并查集来解决。

我们可以发现所有上下左右联通并且数字不同的方格在一个联通块内。我们可以使用并查集来维护这些联通块。

然后输出的时候就是输出该方格所在的联通快的点的个数。

```cpp


#include <string>
#include <iostream>

using namespace std;

const size_t Max_N(1050);

size_t N;
unsigned int M;
string Map[Max_N];

inline
unsigned int Really(const unsigned int &i, const unsigned int &j)
{
    return (i - 1) * N + j;
}

int dx[] = {+1, -1, +0, +0};
int dy[] = {+0, +0, +1, -1};

unsigned int Father[Max_N * Max_N];
unsigned int Cnt[Max_N * Max_N];
unsigned int a, b;
unsigned int x, y;

unsigned int Get_Father(const unsigned int &v)
{
    return Father[v] == v ? v : Father[v] = Get_Father(Father[v]);
}

int main()
{
    cin >> N >> M;
    for (size_t i = 1;i <= N;++i)
    {
        cin >> Map[i];
        Map[i] = "0" + Map[i];
    }
    
    for (size_t i = 1;i <= N * N;++i)
        Father[i] = i, Cnt[i] = 1;
    for (size_t i = 1;i <= N;++i)
        for (size_t j = 1;j <= N;++j)
            for (size_t k = 0;k != 4;++k)
            {
                a = i + dx[k];
                b = j + dy[k];
                if (a >= 1 && a <= N && b >= 1 && b <= N)
                    if (Map[i][j] != Map[a][b])
                    {
                        x = Get_Father(Really(i, j));
                        y = Get_Father(Really(a, b));
                        if (x != y)
                        {
                            Father[y] = x;
                            Cnt[x] += Cnt[y];
                        }
                    }
            }
    
    while (M--)
    {
        scanf("%u%u", &a, &b);
        printf("%u\n", Cnt[Get_Father(Really(a, b))]);
    }
    
    return 0;
}

```

---

## 作者：囧人232 (赞：55)

蒟蒻不会bfs，用的dfs=v=//蒟蒻第一次写题解希望对大家有帮助

纯暴力 对于查询的点进行dfs，每次找到一个没有标记过的点，使ans++，并对该点打上标记进行dfs。

这样的做法是正确的但是会t3个点

那么我们的dfs该如何改进呢？

重新审视下我们的dfs，发现对于已经查过的点，他还是会进行重复的dfs,那么是不是记录一下查询过点的答案，就能过了呢？

并不是23333，还是会t3个点==

重新看下题目对于任意两个点A,B，如果a能遍历到b那么b一定能遍历到a，b能遍历到的点数一定与a相等

所以//大优化来了

对于每一个点能遍历到的所有的点，将其染成同种颜色，然后查询时只需要查询该点颜色对应的ans即可//时间复杂度差不多降低了一个大常数

然后就AC了

最后附代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int g[1001][1001],f[1001][1001],d[1000005];//d数组就是在下的优化，每种颜色对应的答案
int n,m,k,ans,cnt=1;
string c;
void init()
{
    ans=0;
   /* for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    f[i][j]=0;*/
}
void dfs(int x,int y)
{
    ans++;
    f[x][y]=cnt;
    if(!f[x-1][y]&&((x-1)>=1)&&(g[x-1][y]!=g[x][y]))dfs(x-1,y);
        if(!f[x+1][y]&&((x+1)<=m)&&(g[x+1][y]!=g[x][y]))dfs(x+1,y);
            if(!f[x][y-1]&&((y-1)>0)&&(g[x][y-1]!=g[x][y]))dfs(x,y-1);
                if(!f[x][y+1]&&((y+1)<=m)&&(g[x][y+1]!=g[x][y]))dfs(x,y+1);
                d[cnt]=ans;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
    {
        cin>>c;
        //scanf("%s",c);
        m=c.size();
        for(int j=0;j<m;j++)
         g[i][j+1]=c[j]-'0';
    }
    for(int i=1;i<=k;i++)
    {
        init();
        int a,b;
        scanf("%d%d",&a,&b);
        if(!f[a][b])
        {
        dfs(a,b);
        cnt++;
        }
        printf("%d\n",d[f[a][b]]);
    }
    return 0;
}
```

---

## 作者：Dilute (赞：27)

#蒟蒻的题解

##诶我发现好像我特别喜欢用DFS做BFS的题目 ~~是因为我懒得写BFS~~

###我给大家带来的是一种在染色的基础上做的非常神奇的酷似并查集有不是并查集的写法

###但是在这里我先给大家看一下一般的代码的发展历程

###第一个 70分（TLE2、9、10） 暴力染色

###总体思路：直接收到一个点，直接染色

###（PS：由于懒得改变量名了，ans表示的是判重）

###（PS2：因为并不是满分写法，所以在这里就不给出注释）

```cpp
#include<bits/stdc++.h>

using namespace std;

int s[1010][1010];
int opt[6][3] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
int cou;
int ans[1010][1010];
int n;

void dfs(int x, int y){
    if(x > n || x < 1 || y > n || y < 1) return ;
    if(ans[x][y] > -1) return ;
    cou++;
    ans[x][y] = 0;
    for(int i = 0; i < 4; i++){
        if(s[x+opt[i][0]][y+opt[i][1]] != s[x][y])
            dfs(x+opt[i][0], y+opt[i][1]);
    }
}

int main(){
    memset(ans, -1, sizeof(ans));
    int m;
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i++){
        char str[1010];
        scanf("%s", &str);
        for(int j = 1; j <= n; j++){
            s[i][j] = str[j-1] - 48;
        }
    }
    for(int i = 1; i <= m; i++){
        int x, y;
        cou = 0;
        scanf("%d %d", &x, &y);
        dfs(x, y);
        printf("%d", cou);
        memset(ans, -1, sizeof(ans));
    }
}
```
RP++++++++++++++分割线++++++++++++++RP

第二种 记忆化搜索 80分（TLE2、10）

###这种写法的思路就是在第一种的基础上进行记忆化，在每次染色染好之后就去遍历一遍，如果发现这个点是刚刚搜索过的点，那么久直接把答案存储到对应的ans中

```cpp
#include<bits/stdc++.h>

using namespace std;

int s[1010][1010];
int opt[6][3] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
int cou;
int ans[1010][1010];
int n;

void dfs(int x, int y){
    if(x > n || x < 1 || y > n || y < 1) return ;
    if(ans[x][y] > -1) return ;
    cou++;
    ans[x][y] = 0;
    for(int i = 0; i < 4; i++){
        if(s[x+opt[i][0]][y+opt[i][1]] != s[x][y])
            dfs(x+opt[i][0], y+opt[i][1]);
    }
}

int main(){
    memset(ans, -1, sizeof(ans));
    int m;
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i++){
        char str[1010];
        scanf("%s", &str);
        for(int j = 1; j <= n; j++){
            s[i][j] = str[j-1] - 48;
        }
    }
    for(int i = 1; i <= m; i++){
        int x, y;
        cou = 0;
        scanf("%d %d", &x, &y);
        if(ans[x][y] > 0){
            printf("%d\n", ans[x][y]);
            continue;
        }
        dfs(x, y);
        printf("%d\n", cou);
        for(int u = 1; u <= n; u++){
            for(int v = 1; v <= n; v++){
                if(ans[u][v] == 0) ans[u][v] = cou;
            }
        }
    }
}
```

RP++++++++++++++分割线++++++++++++++RP


##最后，压轴的方法出现了！

###没错就是一开始说的AC算法（那个诡异的似并查集而非并查集的算法）

###它的思路是，在第二种的基础上，新增一个genx、geny，来存储当前这个点它的根在哪里，这样就可以在DFS染色的同时把这两个给存好，那么这样子以来，ans数组中只有第一次询问的点中存有答案，其它的地方都可以被认为是仅仅指向着那里

###上代码~~~

```cpp
#include<bits/stdc++.h>

using namespace std;

int s[1010][1010];
int opt[6][3] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
int cou; // 用来存储当前染色到了多少个点 
int ans[1010][1010];
int n;
int genx[1010][1010];
int geny[1010][1010];
int curx, cury; // 用来存储当前 

void dfs(int x, int y){ // 染色用的DFS函数 
    if(x > n || x < 1 || y > n || y < 1) return ; // 越界判断 
    if(ans[x][y] > -1) return ; // 判重（此时ans是两用的，既是存储答案用，也可以拿来判重） 
    cou++;
    genx[x][y] = curx; // 诡异的似并查集而非并查集 
    geny[x][y] = cury; // 就是设置当前点的gen在哪里，方便后面来查找这个点对应的答案 
    ans[x][y] = 0;  // 标记一下当前点 
    for(int i = 0; i < 4; i++){
        if(s[x+opt[i][0]][y+opt[i][1]] != s[x][y])
            dfs(x+opt[i][0], y+opt[i][1]);
    }
}

int main(){
    memset(ans, -1, sizeof(ans)); // 这里为什么要初始化成-1呢？因为 这样子方便后面判重（后面设为0来判重） 
    memset(genx, 0, sizeof(genx));
    memset(geny, 0, sizeof(geny));
    int m;
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= n; i++){ // 读入，不多讲了 
        char str[1010];
        scanf("%s", &str);
        for(int j = 1; j <= n; j++){
            s[i][j] = str[j-1] - 48;
        }
    }
    for(int i = 1; i <= m; i++){
        int x, y;
        cou = 0;
        scanf("%d %d", &x, &y);
        if(ans[genx[x][y]][geny[x][y]] > 0){ // 判断当前点是不是以前搜索过的 
            printf("%d\n", ans[genx[x][y]][geny[x][y]]);
            continue;
        }
        curx = x;
        cury = y;
        dfs(x, y); // 染色 
        printf("%d\n", cou);
        ans[x][y] = cou; // 这里要注意一下：必须把自己的gen也设成自己，否则如果后面问同一个点输就错了
        genx[x][y] = x;
        geny[x][y] = y;
    }
} // 耗时45分钟终于写完了。。。
```

---

## 作者：Pz_Old (赞：23)

```cpp  
#include<bits/stdc++.h>
using namespace std;
int vis[1005][1005],tmp[1000005][2];
int sx,sy,n,m,a[1005][1005];
int dx[5]={0,1,-1,0,0},dy[5]={0,0,0,1,-1},cnt;
void dfs(int x,int y) {
	if(x<1||x>n||y<1||y>n) return;//出界
	if(vis[x][y]) return;//走过了
	cnt++;//记一下 
	tmp[cnt][0]=x;//记一下这个地方的坐标 ，铺垫 骚操作 
	tmp[cnt][1]=y;
	vis[x][y]=1;//我来过了 
	for(int i=1;i<=4;i++)
	{
		if(a[x][y]!=a[x+dx[i]][y+dy[i]])//能走么？ 
		dfs(x+dx[i],y+dy[i]);//去下一个 地方康康 
	}//这个题不用回复“点”的状态 
}
int main(){
	memset(vis,0,sizeof(vis));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++){
		char x;
		cin>>x;//蒟蒻的数据点，一个一个来 
		a[i][j]=x-'0';//确保地图的纯净性 
	}
	for(int i=1;i<=m;i++){
		int e,b;
		cin>>e>>b;
		cnt=0;
		if(vis[e][b]>0){//这里我来过么？ 
			cout<<vis[e][b]<<endl;//来过就能直接输出 
			continue;
		}
		dfs(e,b);//没来过就刷一遍 
		for(int i=1;i<=cnt;i++)
			vis[tmp[i][0]][tmp[i][1]]=cnt;//刷完了就是答案 
		cout<<cnt<<endl;//骚操作，去过的地方都是互相连通的
		//所以在这区域内的点都是这个答案 ，修改了vis数组正好记着，骚的一批 
	}
	return 0;
}
	
	

```


---

## 作者：Zero神 (赞：21)

###  _[原题链接](https://www.luogu.org/problemnew/show/P1141)_ 
 
------------

# 题意：

 **有一个仅由数字0与1组成的n×n格迷宫。若你位于0上，那么你可以移动到相邻4格中是1的位置上，同样若你位于1上，那么你可以移动到相邻4格中是0的位置上。现在给定你此时所处的位置，求出该位置出发，最多能到多少个格子上去(个数包括起点)**
 
 **例如：**
 
 **0 1 ~~1 0 1~~**
 
 **0 1 1 ~~1 0~~**
 
 **1 0 0 1 0**
 
 **从第1行第3列出发，最多能经过5个格子(划横线位置)，就输出4**
 



------------
#  思路：
**注意:因为给出的位置达到了10w级别，故不可暴力对每个位置进行搜索，会出现3个点的TLE**

观察后容易发现，**如果某两个位置属于同一个连通块，则这两个位置的可达格子数相同**,如上例，再从第2行第4列出发，仍然最多经过5个格子，因为该地图具有双向性(规则为0->1 1->0 正可达，反必可达),即若a可达b,则b也可达a。故而，**同属一个连通块的点，具有相同的可达格子数。**


------------

**因此，可以建立一个数组$blocks[N][N]$, 记录从位置$(i,j)$出发可达的格子数量,只需执行连通块个数次的搜索，即可填满该数组。**

**做法如下,对每个连通块进行搜索，分别统计每个连通块包含的格子数，对当前连通块，记录该连通块内点的坐标，当对该连通块搜索完毕时，为该连通块内所有的点统一赋值为统计的格子数**


------------

**AC完整代码如下:**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;
const int dx[] = {0,0,-1,1};
const int dy[] = {-1,1,0,0};
struct node{
    int x,y;
};
char maze[N][N];
int vis[N][N],block[N][N];//访问数组和记录(i,j)所属连通块的格子数量
int n,m,a,b,ans;
void bfs(){
    node now,nx;
    queue<node> q;
    vector<node> pos;//记录连通块内的格子坐标
    q.push({a,b});
    vis[a][b] = 1;
    ans = 1;//计数连通块内的格子数量
    while(!q.empty()){
        now = q.front(),q.pop();
        pos.push_back(now);
        for(int i = 0; i < 4; i++){
            nx.x = now.x+dx[i],nx.y = now.y+dy[i];
            if(!maze[nx.x][nx.y]||vis[nx.x][nx.y]||maze[now.x][now.y]==maze[nx.x][nx.y]) continue;
            vis[nx.x][nx.y] = 1;
            ans++;
            q.push(nx);

        }
    }
    //该连通块搜索完毕，赋值即可
    for(auto v : pos) block[v.x][v.y] = ans;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++) scanf("%s",maze[i]+1);//下标从1开始
    while(m--){
        scanf("%d%d",&a,&b);
        if(!block[a][b]) bfs();//若a,b所在连通块还没搜索过，执行搜索
        printf("%d\n",block[a][b]);
    }
    return 0;
}

```



    

---

## 作者：jiangXxin (赞：17)

这道题，~~其实那么一看，还就是一个裸的BFS~~，但是看到询问的次数那么多，如果每一次询问再去BFS，那么结果可想而知。

我记得我们的老师说过一句话，如果有非常多的询问，眼看着一定会超时，那么就需要考虑把答案存起来，所以这个题就可以把答案存起来，然后当它询问时，就可以直接输出答案了。

先来看一下这道题最初的思想模板：

```cpp
#include<iostream>
#include<cmath>
#include<queue>
#include<cstring>
using namespace std;
const int N=1100;
int mp[N][N];//表示全图
bool pd[N][N];//判断走过没有
int ans[N][N];//从mp[i][j]出发能过的点
int dx[4]={0,1,-1,0};
int dy[4]={1,0,0,-1};
int n,m;
struct node
{
    int x,y;
};
int bfs(int x,int y)
{
    int ans=1;
    deque <struct node> que;
    struct node now;
    now.x=x;
    now.y=y;
    pd[x][y]=true;
    que.push_back(now);
    while(!que.empty())
    {
        now=que.front();
        que.pop_front();
        for(int i=0;i<4;i++)
        {
            int nx=now.x+dx[i];
            int ny=now.y+dy[i];
            if(mp[nx][ny]==mp[now.x][now.y])
            {
                continue;
            }
            if(nx<1||ny<1||nx>n||ny>n)
            {
                continue;
            }
            if(pd[nx][ny]==true)
            {
                continue;
            }
            struct node next;
            next.x=nx;
            next.y=ny;
            ans++;
            pd[nx][ny]=true;
            que.push_back(next);
        }
    }
    return ans;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            char c;
            cin>>c;
            if(c=='0')
            {
                mp[i][j]=0;
            }
            else
            {
                mp[i][j]=1;
            }
        }
    }
    for(int i=1;i<=m;i++)
    {
        memset(pd,false,sizeof(pd));
        int bx,by;
        cin>>bx>>by;
        cout<<bfs(bx,by)<<endl;
    }
    return 0;
}

```
是挺暴力的对吧，然后就T了3个点，然后我们就来想一下记录答案，其实它讲的是要找最大的路线，当我们求到了这个最大值之后，它沿途所经过的所有的点答案就都是相同的，所以当我们BFS时，每一次选取了点之后，我们就可以再开一个队列用来存取沿途的点，最后当我们求得答案时，就可以把他们全部拿出来赋值。
这样想，好像是优化了不少，但是看一下代码：

```cpp
#include<iostream>
#include<cmath>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=1100;
int mp[N][N];//表示全图
bool pd[N][N];//判断走过没有
int ans[N][N];//从mp[i][j]出发能过的点
int dx[4]={0,1,-1,0};
int dy[4]={1,0,0,-1};
int n,m;
struct node
{
    int x,y;
};
int bfs(int x,int y)
{
    int sum=1;
    deque <struct node> que;
    deque <struct node> que2;//存取沿途的点
    struct node now;
    now.x=x;
    now.y=y;
    pd[x][y]=true;
    que.push_back(now);
    while(!que.empty())
    {
        now=que.front();
        que2.push_back(now);
        que.pop_front();
        for(int i=0;i<4;i++)
        {
            int nx=now.x+dx[i];
            int ny=now.y+dy[i];
            if(mp[nx][ny]==mp[now.x][now.y])
            {
                continue;
            }
            if(nx<1||ny<1||nx>n||ny>n)
            {
                continue;
            }
            if(pd[nx][ny]==true)
            {
                continue;
            }
            if(ans[nx][ny]>0)
            {
                sum=ans[nx][ny];
                while(!que2.empty())
                {
                    int xx=que2.front().x;
                    int yy=que2.front().y;
                    ans[xx][yy]=sum;
                    que2.pop_front();
                }
                return sum;
            }
            struct node next;
            next.x=nx;
            next.y=ny;
            sum++;
            pd[nx][ny]=true;
            que.push_back(next);
        }
    }
    while(!que2.empty())
    {
        int xx=que2.front().x;
        int yy=que2.front().y;
        ans[xx][yy]=sum;
        que2.pop_front();
    }
    return sum;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            char c;
            cin>>c;
            //scanf("%c",&c);
            if(c=='0')
            {
                mp[i][j]=0;
            }
            else
            {
                mp[i][j]=1;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(ans[i][j]==0)
            {
                memset(pd,false,sizeof(pd));
                ans[i][j]=bfs(i,j);
            }
        }
    }
    for(int i=1;i<=m;i++)
    {
        int bx,by;
        scanf("%d%d",&bx,&by);
        printf("%d\n",ans[bx][by]);
    }
    return 0;
}

```

最终结果就是T两个，做了这个优化结果还不能够全对，那让我们来看一下问题，每一次判断这个点是否被计算过，其实并不需要把判断数组都清零，因为如果这个点的判断数组是真，那么这个点一定是被搜索过，那么就没有必要去再搜了，这样就可以跳过许多步骤。

改进之后的代码：

```cpp
#include<iostream>
#include<cmath>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=1100;
int mp[N][N];//表示全图
bool pd[N][N];//判断走过没有
int ans[N][N];//从mp[i][j]出发能过的点
int dx[4]={0,1,-1,0};
int dy[4]={1,0,0,-1};
int n,m;
struct node
{
    int x,y;
};
int bfs(int x,int y)
{
    int sum=1;
    deque <struct node> que;
    deque <struct node> que2;
    struct node now;
    now.x=x;
    now.y=y;
    pd[x][y]=true;
    que.push_back(now);
    //que2.push_back(now);
    while(!que.empty())
    {
        now=que.front();
        que2.push_back(now);
        que.pop_front();
        for(int i=0;i<4;i++)
        {
            int nx=now.x+dx[i];
            int ny=now.y+dy[i];
            if(mp[nx][ny]==mp[now.x][now.y])
            {
                continue;
            }
            if(nx<1||ny<1||nx>n||ny>n)
            {
                continue;
            }
            if(pd[nx][ny]==true)
            {
                continue;
            }
            if(ans[nx][ny]>0)
            {
                sum=ans[nx][ny];
                while(!que2.empty())
                {
                    int xx=que2.front().x;
                    int yy=que2.front().y;
                    ans[xx][yy]=sum;
                    que2.pop_front();
                }
                return sum;
            }
            struct node next;
            next.x=nx;
            next.y=ny;
            sum++;
            pd[nx][ny]=true;
            que.push_back(next);
        }
    }
    while(!que2.empty())
    {
        int xx=que2.front().x;
        int yy=que2.front().y;
        ans[xx][yy]=sum;
        que2.pop_front();
    }
    return sum;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            char c;
            cin>>c;
            //scanf("%c",&c);
            if(c=='0')
            {
                mp[i][j]=0;
            }
            else
            {
                mp[i][j]=1;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(pd[i][j]==true)
            {
                continue;
            }
            if(ans[i][j]==0)
            {
                //memset(pd,false,sizeof(pd));
                ans[i][j]=bfs(i,j);
            }
        }
    }
    for(int i=1;i<=m;i++)
    {
       // memset(pd,false,sizeof(pd));
        int bx,by;
        //cin>>bx>>by;
        scanf("%d%d",&bx,&by);
       // cout<<bfs(bx,by)<<endl;
        //int bfans=bfs(bx,by);
        printf("%d\n",ans[bx][by]);
        //ans[bx][by]=bfans;
    }
    return 0;
}

```

**这样子就可以AC了。**

**再来想一下还有没有其它的标记方法**，

我们刚才用的都是在结果才开始返回去标记，那么我们是否可以考虑边跑边更新标记呢？答案是肯定的，我们每一次BFS的，肯定答案是相同的，**两个点答案不同原因就是它们不属于同一块**，
所以我们大致可以用map映射每一块的答案，最后输入询问点时，就可以直接输出这个点的映射答案就可以了.

```cpp
#include<iostream>
#include<cmath>
#include<queue>
#include<cstring>
#include<cstdio>
#include<map>
using namespace std;
const int N=1020;
int mp[N][N];//表示全图
bool pd[N][N];//判断走过没有
int ans[N][N];//从mp[i][j]出发能过的点
int dx[4]={0,1,-1,0};
int dy[4]={1,0,0,-1};//方向
int n,m;
int pn;//这个是第几个可以走的
map<int,int> mapp;
struct node
{
    int x,y;
};
int bfs(int x,int y)
{
    int sum=1;
    deque <struct node> que;
    struct node now;
    now.x=x;
    now.y=y;
    pd[x][y]=true;
    ans[x][y]=pn;//标记
    que.push_back(now);
    while(!que.empty())
    {
        now=que.front();
        que.pop_front();
        for(int i=0;i<4;i++)
        {
            int nx=now.x+dx[i];
            int ny=now.y+dy[i];
            if(mp[nx][ny]==mp[now.x][now.y])//是相同的，不走
            {
                continue;
            }
            if(nx<1||ny<1||nx>n||ny>n)//越界，不走
            {
                continue;
            }
            if(pd[nx][ny]==true)//走过的，不走
            {
                continue;
            }
            struct node next;
            next.x=nx;
            next.y=ny;
            sum++;//方案数加一
            pd[nx][ny]=true;//标记
            ans[nx][ny]=pn;//标记
            que.push_back(next);
        }
    }
    return sum;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            char c;
            cin>>c;
            if(c=='0')
            {
                mp[i][j]=0;
            }
            else
            {
                mp[i][j]=1;
            }
        }
    }//存图

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(pd[i][j]==true)//搜过了
            {
                continue;
            }
            else//这个点是第一次搜索
            {
                pn++;
                mapp[pn]=bfs(i,j);//映射答案
            }
        }
    }
    for(int i=1;i<=m;i++)
    {
        int bx,by;
        scanf("%d%d",&bx,&by);
        printf("%d\n",mapp[ans[bx][by]]);//输出对应的值
    }
    return 0;
}

```

**其实这个方法是可以再进一步优化的，细心想一下就可以看到**

---

## 作者：Michael_Jordan (赞：15)

这道题有很多的思路，BFS，DFS，并查集等。这里给大家提供一下BFS解法。

方法很简单，BFS的层层递进就可以了
```cpp
#include<bits/stdc++.h>//万头
using namespace std;
int n,m,x,y;
struct queue
{
	char c;
	bool is;
}a[1000][1000];
int quex[1000002],quey[1000002],l=1,r=0;
int dx[5]={0,0,0,-1,1},dy[5]={0,-1,1,0,0};
//定义一坨东西
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf(" %c",&a[i][j].c);
	//输入
	while(m--)
	{
		scanf("%d%d",&x,&y);
		quex[++r]=x;
		quey[r]=y;//将输入点压入队列
		a[x][y].is=1;//输入点已走过
		int cnt=1;//记录有几种方法
		while(l<=r)
		{
			for(int k=1;k<=4;k++)
			{
				int tx=quex[l]+dx[k],ty=quey[l]+dy[k];
				if(tx<1||tx>n||ty<1||ty>n) continue;
				if(a[tx][ty].c==a[quex[l]][quey[l]].c) continue;
				if(a[tx][ty].is==1) continue;//判断
				a[tx][ty].is=1;
				quex[++r]=tx;
				quey[r]=ty;//将当前点推入队列
				cnt++;//方法++
			}
			l++;//已经搜完，出队
		}
		printf("%d\n",cnt);//输出
		l=1,r=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				a[i][j].is=0;
	}
	return 0;
}

```
不过这只是70分，要全对必须要加优化。

首先，再开一个ans数组，来记录当前点的值，先从（1，1）点搜一遍，ta走过的点一定和1，1点一样，然后再给每一个走过的点赋上值就可以了。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y;
struct queue
{
	char c;
	bool is;
}a[1002][1002];
int quex[1000002],quey[1000002],l=1,r=0;
int dx[5]={0,0,0,-1,1},dy[5]={0,-1,1,0,0};
int ans[1002][1002];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf(" %c",&a[i][j].c);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i][j].is==1) continue;
			l=1,r=0;
			quex[++r]=i;
			quey[r]=j;//将输入点压入队列
			a[i][j].is=1;//输入点已走过
			int cnt=1;//记录有几种方法
			while(l<=r)
			{
				for(int k=1;k<=4;k++)
				{
					int tx=quex[l]+dx[k],ty=quey[l]+dy[k];
					if(tx<1||tx>n||ty<1||ty>n) continue;
					if(a[tx][ty].c==a[quex[l]][quey[l]].c) continue;
					if(a[tx][ty].is==1) continue;//判断
					a[tx][ty].is=1;
					quex[++r]=tx;
					quey[r]=ty;//将当前点推入队列
					cnt++;//方法++
				}
				l++;//已经搜完，出队
			}
			ans[i][j]=cnt;
			for(int i=1;i<=r;i++)ans[quex[i]][quey[i]]=cnt;//优化在这里！！！一定要看清楚！！！
		}
	while(m--)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",ans[x][y]);
	}
	return 0;
}

```

---

## 作者：rubatotree (赞：15)

### UPD：

蒟蒻的第一篇题解，审了几天终于过了，感动。**题解修改后还要重审？？？**

**前置技能：并查集**

此题的思路和`P3958 奶酪`思路较为相似。

## 并查集解法
并查集求联通块。这题其实连搜索都用不上，并查集稳稳的，不会TLE了。

当时我用dfs做的这题，在TLE的问题上纠结了好几天，最后好不容易才记忆化AC了。过了一个月，我惊奇地发现，这题可以用**并查集**做！

用并查集做，更容易理解，更好写。

翻了下题解，发现题解里有一篇是一样的解法，但是几乎没有解释。这里把做法解释一下。

### 一 绕开二维并查集
我们将联通的所有块放入一个集合中。

由于二维并查集比较难写，我们可以绕开二维并查集。

首先讲一下将二维坐标转换为数字的方法。由于最大坐标是有限($x,y<n$)(当$x,y$从$0$开始)的，所以我们可以将其中一个坐标乘上$n$，再加上另一个坐标。这样，每个坐标都不会重复。在我的程序中，坐标从$0$开始。我转换的方法是：
$$a=ny+x$$
其中，$a$为得出的数字。代码实现如下：
```cpp
inline int vti(int y, int x) { return y * n + x; }
```

### 二 将联通块放于一个集合中
如何将联通块放入一个集合中？

我们可以遍历整张图。

对于每个点，当它的坐标$x>0$时，检测它和左侧的块是否联通。如果联通，则并入一个集合中。

当它的坐标$y>0$时，检测它和上方的块是否联通。如果联通，则并入一个集合中。

可以画张图模拟一下这个过程。当遍历完整张图后，所有联通块中的所有块就都在一个集合中了。

代码实现：
```cpp
for(int i = 0; i < n; i++)	//遍历y坐标
	for(int j = 0; j < n; j++)	//遍历x坐标 
	{
		if(i > 0) if(map[i][j] != map[i - 1][j]) Union(vti(i, j), vti(i - 1, j)); //如果和上面联通，合并 
		if(j > 0) if(map[i][j] != map[i][j - 1]) Union(vti(i, j), vti(i, j - 1)); //如果和左边联通，合并 
	}
```

### 三 求出每个联通块中块的个数
我们这里使用一个num数组计数。

```cpp
int num[maxn * maxn];	//根节点中储存块数 
```

遍历整张图，对于每个块，将它所在集合的代表“拥有”的块数+1。代码实现：
```cpp
for(int i = 0; i < n; i++)
	for(int j = 0; j < n; j++)
		num[Find(vti(i,j))]++;	//对于每个块，将其集合的块数量+1。
```
### 四 回答每个询问
有了前面的并查集操作，这一把就简单多了。直接输出num数组中询问坐标的**根节点**所“拥有”的块数即可。

**注意一定要查询根节点！其他的节点是没有存储块数的。**

代码实现：
```cpp
while(m--)	//神奇的方法，重复m次，可以省去i。m以后没必要用，所以可以这样做。 
{
	int x,y;
	scanf("%d %d",&y,&x);			//询问时也是先行后列，即先y后x。 
	printf("%d\n",num[Find(vti(y - 1,x - 1))]);	//O(1)获取联通块数量。由于读入时下标从0开始，所以输出的时候下标也应该从0开始。 
}
```

### 五 完整代码
辛辛苦苦写的题解，就不要抄代码了吧。~~**小心粽名**~~
```cpp
#include <cstdio>

const int maxn = 1010;

int n,m;

char map[maxn][maxn];	//地图 

int uset[maxn * maxn],	//并查集 
	num[maxn * maxn];	//根节点中储存块数 

/*并查集模板*/
int Find(int e) { return e == uset[e] ? e : uset[e] = Find(uset[e]); }
void Union(int e,int f) { uset[Find(f)] = Find(e); }
 
/*用一些神奇的方法将坐标转换为int*/
inline int vti(int y, int x) { return y * n + x; }

int main()
{
    scanf("%d %d",&n,&m);		//读入n和m 
    for(int i = 0; i < n; i++)	//遍历y坐标
    {
    	scanf("%s",map[i]);			//顺便读入地图。个人不是很喜欢用getchar。 
		for(int j = 0; j < n; j++)	//遍历x坐标 
		{
			num[vti(i,j)] = 0;			//顺便初始化
			uset[vti(i,j)] = vti(i,j);	//初始化并查集。自行思考为什么可以在这里初始化。 
			if(i > 0) if(map[i][j] != map[i - 1][j]) Union(vti(i, j), vti(i - 1, j)); //如果和上面联通，合并 
			if(j > 0) if(map[i][j] != map[i][j - 1]) Union(vti(i, j), vti(i, j - 1)); //如果和左边联通，合并 
		}
	}
	for(int i = 0; i < n; i++)		//遍历y坐标
		for(int j = 0; j < n; j++)	//遍历x坐标
			num[Find(vti(i,j))]++;	//对于每个块，将其集合的块数量+1。 
	while(m--)	//神奇的方法，重复m次，可以省去i。m以后没必要用，所以可以这样做。 
	{
		int x,y;
		scanf("%d %d",&y,&x);			//询问时也是先行后列，即先y后x。 
		printf("%d\n",num[Find(vti(y - 1,x - 1))]);	//O(1)获取联通块数量。由于读入时下标从0开始，所以输出的时候下标也应该从0开始。 
	}
    return 0;
}
```

---

## 作者：LiRewriter (赞：15)

楼下大佬说该做法并不是并查集，只是酷似并查集。在下觉得大概就是并查集，只不过是经过特殊处理的并查集。如果没有记错的话，Kruskal似乎也是用这种并查集维护的。

这道题的第一个难点是如何输入。这里在下参考了楼下大佬，大都是输入一个字符串然后依次读入。在下还是naive。

来看看这种并查集，与一般并查集不同的是，我们用fa[x]维护：1）如果x是根节点那么就维护该集合元素数量的相反数 2）否则表示其根节点序号

那么这种并查集的相关函数就会略有变化：

初始化

```cpp
for(int i = 1; i <= n; ++i) fa[i] = -1;
```
查找
```cpp
int find(int x) {
    return fa[x] < 0 ? x : fa[x] = find(fa[x]); //路径压缩
}
```
合并
```cpp
void uni(int x, int y) {
    int xx = find(x), yy = find(y);
    if(xx == yy) return;
    fa[xx] += fa[yy]; 
    fa[yy] = x; 
}
```
来读一下题，我们发现题目中要求的是某一节点可达的点的个数。而其本质就是询问一个集合的元素个数。因此用这种并查集就可以方便的维护。


而想要将二维问题放到并查集中维护，首先需要将其hash为一维。

```cpp
int gethash(int x, int y) {
    return (x - 1) * n + y - 1;
}
```

于是就这样完成了。不过速度略有些慢，1000ms+。

AC代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define MAXN 1003
int fa[MAXN * MAXN]; //并查集主体 
int n, m;
int gethash(int x, int y) { //hash函数 
    return (x - 1) * n + y - 1;
}
int dx[4] = {0, 1, -1, 0}; 
int dy[4] = {-1, 0, 0, 1};//方向 
int find(int x) { //并查集查找 
    return fa[x] < 0 ? x : fa[x] = find(fa[x]);
}
void uni(int x, int y) { //并查集合并 
    int xx = find(x), yy = find(y);
    if(xx == yy) return;
    fa[xx] += fa[yy];
    fa[yy] = x; 
}
bool map[MAXN][MAXN]; //地图 
bool vis[MAXN][MAXN]; //表示某一个点是否被搜索过 
int xx, yy, hash, tmp;
void dfs(int x, int y, int frox, int froy, int type) { //一个平淡无奇的DFS 
    hash = gethash(x, y);
    for(int i = 0; i < 4; ++i) {
        xx = x + dx[i], yy = y + dy[i];
        if(xx < 1 || yy < 1 || xx > n || yy > n) continue;
        if(!(map[xx][yy] ^ type)) continue;  //下一个与这个不一样 
        tmp = gethash(xx, yy);
        if(frox != -1 &&find(hash) == find(tmp)) continue; //已在一个集合中 
        uni(hash, tmp);
        vis[xx][yy] = 1; 
        dfs(xx, yy, x, y, map[xx][yy]);
    }
}
int main() {
    cin>>n>>m;
    string s;
    for(int i = 1; i <= n; ++i) {
        cin>>s; 
        for(int j = 0; j < s.size() ;++j) {
            map[i][j+1] = s[j] - '0';
        }
    }
    for(int i = 0; i <= n * n; ++i) fa[i] = -1; //并查集初始化 
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= n; ++j) {
            if(!vis[i][j]) {
                dfs(i, j, -1, -1,map[i][j]);
            }
        }
    }
    int x, y, ans;
    while(m--) {
        cin>>x>>y;
        ans = find(gethash(x, y));
        cout<<-fa[ans]<<endl; //根节点权值相反数 = 集合元素个数 
    }
    return 0;
}
```

---

## 作者：shame_djj (赞：14)

[原题链接【01迷宫】](https://www.luogu.org/problem/P1141)

本题 tarjan AK！！！

**智商不够，算法来凑**

这题打眼一看，强连通分量，板子啊！！

我从看到这题，到AC这题，一共只花了七分钟，比起他们一个个调好几天好多了（滑稽~滑稽~~）

即使我的算法很慢，但是能过，而且肯定能过，这是经过分析的，tarjan的O(n)在这里是O(n2)，稳过。

也许我的算法并不是最快的，但是我写这段代码的用时绝对是最短的，所以写这篇题解的目的就是让自己记住这种方法，也鼓励一下大家这样做。

快速的普通算法很难写时，直接用高级的数据结构或高级算法切过去。

至于如何用tarjan做此题，这就非常简单了：

		1、建模，对于相邻的能互相到达的点对，直接建双向边

		2、tarjan跑一遍，用size数组记录一下强连通分量的大小

		3、查询时，只要输出所属的强连通分量的size就好了

什么？你说你不会tarjan求强连通分量？

请转这里[【模板】缩点](https://www.luogu.org/problem/P3387)

代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

inline int read() {
    char c = getchar(); int x = 0, f = 1;
    for (; c > '9' || c < '0'; c = getchar()) if (c == '-') f = -1;
    for (; c >='0' && c <='9'; c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return x * f;
}

int a[1010][1010];
int n, m;
int num (int x, int y) {
    return x * n - n + y;
}

int fx[4] = {0, 0, 1, -1};
int fy[4] = {1, -1, 0, 0};
int dx, dy;

int size[1000010] ,id[1000010], dfn[1000010], low[1000010], gg, cnt, k;
int ver[10000010], nxt[10000010], head[1000010], tot;
int stack[1000010], top, x, y;
bool ins[1000010];

void add (int u, int v) {
    ver[++ tot] = v;
    nxt[tot] = head[u];
    head[u] = tot;
}

void tarjan (int x) {
    dfn[x] = low[x] = ++ cnt;
    stack[++ top] = x;
    ins[x] = 1;
    for (register int i = head[x]; i; i = nxt[i]) {
        if (!dfn[ver[i]]) {
            tarjan (ver[i]);
            low[x] = min (low[x], low[ver[i]]);
        }
        else if (ins[ver[i]])
            low[x] = min (low[x], dfn[ver[i]]);
    }
    if (dfn[x] == low[x]) {
        ++ gg;
        do {
            k = stack[top --];
            ins[k] = 0;
            id[k] = gg;
            size[gg] ++;
        } while (x != k);
    }
}

void djj () {
    n = read(), m = read();
    for (register int i = 1; i <= n; i ++)
        for (register int j = 1; j <= n; j ++)
            scanf ("%1d", &a[i][j]);
    for (register int i = 1; i <= n; i ++)
        for (register int j = 1; j <= n; j ++)
            for (register int k = 0; k < 4; k ++) {
                dx = i + fx[k], dy = j + fy[k];
                if (dx < 1 || dy < 1 || dx > n || dy > n)
                    continue;
                if (a[i][j] != a[dx][dy])
                    add (num (i, j), num (dx, dy));
            }
    for (register int i = 1; i <= num (n, n); i ++)
        if (!dfn[i]) tarjan (i);
}

void lxy () {
    for (; m; m --) {
        x = read(), y = read();
        printf ("%d\n", size[id[num (x, y)]]);
    }
}

void djj_lxy () {
    djj (), lxy ();
    exit (0);
}

int main() {
    djj_lxy ();
}

```
码风鬼畜，但请勿抄袭

就这样，我们开开心心的拿tarjan算法求了个强连通分量，然后开开心心地AC了这道简单而又难调的bfs神仙题

一遍AC，非常舒服~~

但其实，如果是让半年前的我来做这题，也得在bfs这儿卡上几天。

所以说，在OI的路上，我们学习了一个又一个强力的算法，

蓦然回首，当时是看到就手抖，不敢做的提高-题，

现在竟是几分钟就能切掉的小黄题。

我想这份取得巨大进步的喜悦也是我们学OI的最大的回报之一。

祝大家新 Noip rp ++

也希望自己能更努力一些，能在这条路上走的更远。

# 加油！

---

## 作者：路人甲2003 (赞：11)

# 01迷宫 二维并查集做法
  一开始这道题在bfs训练里，于是直接打了一个朴素的BFS，自信满满的提交
  
  由于并非标答，在此不对代码进行解释
  ```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[1005][1005],b[1005][1005];
int jg[1005][1005];
int m,n,x[4]={1,-1,0,0} ,y[4]={0,0,1,-1},sx,sy,tot;
queue<int> c;
void bfs()
{
    memset(b,0,sizeof(b));tot=1;
    c.push(sx);c.push(sy);b[sx][sy]=1;
    while(!c.empty())
    {
        int p=c.front();c.pop();
        int q=c.front();c.pop();
        if(jg[p][q]) {tot=jg[p][q];return;}
        for(int i=0;i<=3;++i)
        {
            if(p+x[i]>=1&&p+x[i]<=n&&q+y[i]>=1&&q+y[i]<=n
            &&!b[p+x[i]][q+y[i]]&&a[p][q]^a[p+x[i]][q+y[i]])
            {
                b[p+x[i]][q+y[i]]=1;
                c.push(p+x[i]);c.push(q+y[i]);++tot;
            }
        }
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        if(b[i][j])jg[i][j]=tot;
    }
} 
int main()
{
    char fz;
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        cin>>fz;
        if(fz=='0') a[i][j]=0;
        else a[i][j]=1;
    }
    for(int i=1;i<=m;++i)
    {
        cin>>sx>>sy;
        bfs();
        cout<<tot<<endl;
    }
    return 0;
}
```
结果——TLE2,9,10

事实证明，本题数据量大，读入一个查找一个必然超时.

之后就一直想优化方式，想到无论之后的查找有多少，这张迷宫地图都不会改变。所以在存图时就可以把图中的0,1区块算出来，查找时直接利用。

而如何将01区块找出来——当然要用并查集了

因为~~我懒得把并查集压回一维~~，干脆就用二维并查集做了。
题解区好像没有神犇写二维并查集的题解~~至少我没见过~~，所以本蒟蒻简单讲一下二维并查集吧
# 二维并查集详解
二维并查集比起一维并查集来说，它需要维护两个变量（x和y）(因为只用一个变量无法保存父节点的横纵坐标值）。
```cpp
//建立并查集
struct node{
    int x,y;
}a[1005][1005];
//初始化
void start()
{
    for(int i=1;i<=1000;++i)
    for(int j=1;j<=1000;++j)
    {
        a[i][j].x=i;
        a[i][j].y=j;
    }
}
```
## 查找父节点&路径压缩
并查集路径压缩，即为寻找自己的代表，如果代表为自己，则返回自己，否则向上寻找自己的代表并将其指向整棵树的根节点。
先上代码
```cpp
node  find(int p,int q)//查找a[p][q]的代表
{
    if(a[p][q].x==p //x坐标相同
    &&a[p][q].y==q)//y坐标相同
    return a[p][q];
    else
    {
        node k1=find(a[p][q].x,a[p][q].y);//向上寻找
        return a[p][q]=k1;//路径压缩
    }
}
```
#### 假设目前有这样一个情况
- 结点   x       y   
- k     p.x     p.y
- p     q.x     q.y
- q     q.x     q.y


#### 跟着代码走一遍

1. a[k.x][k.y].x==p.x==q.x!=k.x,if false
1. find(a[k.x][k.y]),即find(p)，进入下一层调用
1. a[p.x][p.y].x==q.x==q.x!=p.x,if false
1. find(a[p.x][p.y]),即find(q)，进入下一层调用
1. a[q.x][q.y].x==q.x&&a[q.x][q.y].y==q.y,if true,返回上一层
1. a[p.x][p.y]=q,p更新为q的值，返回上一层
1. a[k.x][k.y]=p=q,k更新为p，即q的值，返回主函数

#### 结果如下
- 结点   x       y   
- k     q.x     q.y
- p     q.x     q.y
- q     q.x     q.y

## 合并两个集合
并查集合并集合，即寻找两个集合的代表，并将其中一个集合的代表指向另一个集合。

先上代码
```cpp
void unionn(int p,int q,int n,int r)//合并a[p][q]与a[n][r]
{
    node k1=find(a[p][q]);
    node k2=find(a[n][r]);//查找结点的代表
    if(k1.x!=k2.x||k1.y!=k2.y)//两点不在同一个集合中
    a[k2.x][k2.y]=k1;//合并集合
}

```
合并操作与一维并查集差距不大，解释下最后一句，因为k2保存的就是a[p][q]的根节点的值，所以a[k2.x][k2.y]就是a[p][q]的根结点。
## 二维并查集完整代码
```cpp
//建立并查集
struct node{
    int x,y;
}a[1005][1005];
//初始化
void start()
{
    for(int i=1;i<=1000;++i)
    for(int j=1;j<=1000;++j)
    {
        a[i][j].x=i;
        a[i][j].y=j;
    }
}
node find(int p,int q)//查找a[p][q]的代表
{
    if(a[p][q].x==p //x坐标相同
    &&a[p][q].y==q)//y坐标相同
    return a[p][q];
    else
    {
        node k1=find(a[p][q].x,a[p][q].y);//向上寻找
        return a[p][q]=k1;//路径压缩
    }
}
void unionn(int p,int q,int n,int r)//合并a[p][q]与a[n][r]
{
    node& k1=find(a[p][q]);
    node& k2=find(a[n][r]);//查找结点的代表
    if(k1.x!=k2.x||k1.y!=k2.y)//两点不在同一个集合中
    //a[k2.x][k2.y]=k1;//合并集合
    k1=k2;
}
```
由于本人是蒟蒻，不会把它封装在结构体中，所以直接发了


------------
# 回归正题
对于本题而言，只用单纯的并查集不能完成题目要求，因为朴素的并查集仅仅通过根节点的信息无法得出这棵树的结点个数。

那么怎么办呢？

**答案是——在并查集中维护结点个数！**

维护方法是：在结构体中维护变量tot，一开始初始化为1，并在每一次合并集合时把两棵树的根节点的tot值加起来。

路径压缩时不需要动tot，因为路径压缩不改变结点数。

二代代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x, y, tot;
    bool z;
}a[1085][1085];
node find(node k)
{
    if(a[k.x][k.y].x==k.x&&a[k.x][k.y].y==k.y) return k;
    else return a[k.x][k.y]=find(a[k.x][k.y]);
}
void unionn(node k,node l)
{
    node k1,k2;
    k1=find(k);
    k2=find(l);
    if(k1.x!=k2.x||k1.y!=k2.y)	
    {
        a[k1.x][k1.y].tot+=a[k2.x][k2.y].tot; 
        a[k2.x][k2.y]=k1;
    }
}
int main()
{
    int m,n,b,c;
    char k;
    cin>>m>>n;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        a[i][j].x=i;a[i][j].y=j;a[i][j].tot=1;
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        cin>>k;
        if(k=='1') a[i][j].z=1;
        if(i-1>=1&&a[i-1][j].z^a[i][j].z) unionn(a[i-1][j],a[i][j]);
        if(j-1>=1&&a[i][j-1].z^a[i][j].z) unionn(a[i][j-1],a[i][j]);
    }
    for(int i=1;i<=m;++i)
    {
        scanf("%d%d",&b,&c);
        printf("%d\n",find(a[b][c]).tot);
    }
    return 0;
}
```
结果：全部RE

后来发现m,n打反了。。。

三代代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x, y, tot,z;
}a[1020][1020];
node find(int p,int q)
{
    if(a[p][q].x==p&&a[p][q].y==q) return a[p][q];
    else return a[p][q]=find(a[p][q].x,a[p][q].y);
}
void unionn(int p,int q,int n,int r)
{
    node k1,k2;
    k1=find(p,q);
    k2=find(n,r);
    if(k1.x!=k2.x||k1.y!=k2.y)	
    {
        a[k1.x][k1.y].tot+=a[k2.x][k2.y].tot; 
        a[k2.x][k2.y].x=k1.x;
        a[k2.x][k2.y].y=k1.y;
        //a[k2.x][k2.y]=k1;
    }
}
int main()
{
    int m,n,b,c;
    char k;
    cin>>n>>m;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        a[i][j].x=i;a[i][j].y=j;a[i][j].tot=1;a[i][j].z=0;
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        cin>>k;
        if(k=='1') a[i][j].z=1;
        if(i-1>=1&&a[i-1][j].z^a[i][j].z) unionn(i,j,i-1,j);
        if(j-1>=1&&a[i][j-1].z^a[i][j].z) unionn(i,j,i,j-1);
    }
    
    for(int i=1;i<=m;++i)
    {
        scanf("%d%d",&b,&c);
        printf("%d\n",find(b,c).tot);
    }
    return 0;
}
```
结果：全部WA
 
没办法，只能下了一个数据点。
试着跑了一遍，发现问题在于原来的01图并没有保存下来，而是在路径压缩的过程中被改变了。
## 注意：如果要用二维并查集维护其他内容，绝对不能直接将结构体赋值！！！
最后，将路径压缩的代码改成单项赋值——AC！

在此单独放上二维并查集单项赋值代码
```cpp
//建立并查集
struct node{
    int x, y, tot,z;//此处可使用自己需要维护的变量
}a[1020][1020];
//初始化
void start()
{
    for(int i=1;i<=1000;++i)
    for(int j=1;j<=1000;++j)
    {
        a[i][j].x=i;
        a[i][j].y=j;
        a[i][j].tot=1;
    }
}
node find(int p,int q)//查找a[p][q]的代表
{
    if(a[p][q].x==p&&a[p][q].y==q) return a[p][q];//x，y坐标相同
    else
    {
    	node k1=find(a[p][q].x,a[p][q].y);//向上寻找
    	a[p][q].x=k1.x;
    	a[p][q].y=k1.y;//单独赋值
    	return k1;//路径压缩
    }
}
void unionn(int p,int q,int n,int r)//合并a[p][q]与a[n][r]
{
    node k1,k2;
    k1=find(p,q);
    k2=find(n,r);//查找结点的代表
    if(k1.x!=k2.x||k1.y!=k2.y)	//两点不在同一个集合中
    {
        a[k1.x][k1.y].tot+=a[k2.x][k2.y].tot; 
        a[k2.x][k2.y].x=k1.x;
        a[k2.x][k2.y].y=k1.y;//合并集合
    }
}
```
# 最后——AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x, y, tot,z;
}a[1020][1020];//建立并查集
node find(int p,int q)//路径压缩
{
    if(a[p][q].x==p&&a[p][q].y==q) return a[p][q];
    else
    {
    	node k1=find(a[p][q].x,a[p][q].y);
    	a[p][q].x=k1.x;
    	a[p][q].y=k1.y;
    	return k1;
    }
    //else return a[p][q]=find(a[p][q].x,a[p][q].y);
}
void unionn(int p,int q,int n,int r)//合并
{
    node k1,k2;
    k1=find(p,q);
    k2=find(n,r);
    if(k1.x!=k2.x||k1.y!=k2.y)	
    {
        a[k1.x][k1.y].tot+=a[k2.x][k2.y].tot; 
        a[k2.x][k2.y].x=k1.x;
        a[k2.x][k2.y].y=k1.y;
        //a[k2.x][k2.y]=k1;
    }
}
void start(int n)//初始化
{
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        a[i][j].x=i;
        a[i][j].y=j;
        a[i][j].tot=1;
        a[i][j].z=0;
    }
}
int main()
{
    int m,n,b,c;
    char k;
    cin>>n>>m;
    start(n);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    {
        cin>>k;
        if(k=='1') a[i][j].z=1;//读入
        if(i-1>=1&&a[i-1][j].z^a[i][j].z) unionn(i,j,i-1,j);
        if(j-1>=1&&a[i][j-1].z^a[i][j].z) unionn(i,j,i,j-1);
        //一边读入一边合并，节省码量与常数
    }
    for(int i=1;i<=m;++i)
    {
        scanf("%d%d",&b,&c);
        printf("%d\n",find(b,c).tot);
    }
    return 0;
}
```
p.s.这是本蒟蒻第一次发题解，如果那里讲的不够清楚，可以在评论区给我提意见

copy不是好习惯，我希望各位注重自己掌握的算法，而不是ac率
## 2019.4.20

---

## 作者：kenlig (赞：10)

非常难受了可以说..一道普及/提高-的水题
我居然改了3天 提交了20次！！
我太弱了！！


正文开始：

分析题目：
这道题一眼就能看出来是个搜索题（DP？不存在的）。那么一个显然的做法就是：把图存起来，对于每一个询问都进行一次dfs。显然这TLE了。（70分做法）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<map>
#include<set>
#include<queue>
#define INF 0x3f3f3f3f
#define inf 0x3f
#define ll long long
using namespace std;
queue<int> q;
int n,m,x,a[1001][1001],y,dx[]={-1,1,0,0},dy[]={0,0,-1,1},sum,vis[1001][1001],ans[1001]; 
char c;
int dfs(int x,int y){
    vis[x][y]=1;
    for(int i=0;i<4;i++){
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(a[x][y]==1){
            if(xx>0&&yy>0&&xx<=n&&yy<=n&&a[xx][yy]==0&&vis[xx][yy]==0) {
                sum++;
                dfs(xx,yy);
            }
        }
        if(a[x][y]==0){
            if(xx>0&&yy>0&&xx<=n&&yy<=n&&a[xx][yy]==1&&vis[xx][yy]==0) {
                sum++;
                dfs(xx,yy);
            }
        }
    }
    return sum;
}
int main(){ 
    sum=1;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            vis[i][j]=0;
            cin>>c;
            if(c=='0') a[i][j]=0;
            if(c=='1') a[i][j]=1;
        }
    }
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        ans[i]=dfs(x,y);
        sum=1;
        for(int j=1;j<=n;j++){
            for(int k=1;k<=n;k++){
                vis[j][k]=0;
            }
        }
    }
    for(int i=1;i<=m;i++){
        cout<<ans[i]<<endl;
    }
    return 0;
}

```

那么如何做到AC呢？
首先分析题目：

若你位于一格0上，那么你可以移动到相邻 4 格中的某一格 1 上，同样若你位于一格1上，那么你可以移动到相邻 4 格中的某一格 0 上。

那么我们可以做一个设想：对于每一个点，从这个点出发能到达的所有的点是一个值sum，那么从他能到达的任意一点出发，也能有一个值sum，并且这两个值相等。
但是！如果从这个点A出发到达不了的点B，那么这个点B的答案和A不同。
我们可以把他理解成一个连通块。
巨坑：数组要开1e6，不然坐等WA或者RE吧qwq.

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<map>
#include<set>
#include<queue>
#define INF 0x3f3f3f3f
#define inf 0x3f
#define ll long long
using namespace std;
queue<int> q;
int n,m,x,a[1001][1001],y,dx[]={-1,1,0,0},dy[]={0,0,-1,1},sum,vis[1001][1001],ans[1000001],num[1000001];
int k;
char c;
void dfs(int x,int y,int k){
    vis[x][y]=k;
    for(int i=0;i<4;i++){
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(a[x][y]==1){
            if(xx>0&&yy>0&&xx<=n&&yy<=n&&a[xx][yy]==0&&vis[xx][yy]==0) {
                sum++;
                dfs(xx,yy,k);
            }
        }
        if(a[x][y]==0){
            if(xx>0&&yy>0&&xx<=n&&yy<=n&&a[xx][yy]==1&&vis[xx][yy]==0) {
                sum++;
                dfs(xx,yy,k);
            }
        }
    }
}
int main(){ 
    k=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            vis[i][j]=0;
            cin>>c;
            if(c=='0') a[i][j]=0;
            if(c=='1') a[i][j]=1;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(vis[i][j]==0){
                k++;
                sum=1;
                dfs(i,j,k);
                num[k]=sum;
            }
        }
    }
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        int qwq=vis[x][y];
        ans[i]=num[qwq];
    }
    for(int i=1;i<=m;i++){
        cout<<ans[i]<<endl;
    }
    return 0;
}

```


---

## 作者：PhantasmDragon (赞：8)

一道十分淳朴善良的广搜题，我却用了深搜。

注意数据范围，大得邪恶。。

只需要加一个记忆化就能不TLE了：）

用广搜同理，也需要记忆化。

数组也要开大一点。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
char maze[1000][1000];
int used[1000][1000];
int ans[1000002];
int N,M;
void dfs(int x,int y,char now,int marker)
{
    if(x>N-1||x<0||y>N-1||y<0||now==maze[x][y]||used[x][y]!=-1)
    {
        return;
    }
    used[x][y]=marker;//记忆化
    ans[marker]++;//还是记忆化
    dfs(x+1,y,maze[x][y],marker);
    dfs(x-1,y,maze[x][y],marker);
    dfs(x,y-1,maze[x][y],marker);
    dfs(x,y+1,maze[x][y],marker);
}
void solve()
{
    scanf("%d %d",&N,&M);
    for(int i=0;i<N;i++)
    {
        scanf("%s",maze[i]);
    }
    memset(used,-1,sizeof(used));
    for(int i=0;i<M;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        x--;
        y--;
        if(used[x][y]!=-1)//如果有计算过，直接使用
        {
            ans[i]=ans[used[x][y]];
        }
        else
        {
            dfs(x,y,'#',i);
        }
    }
    for(int i=0;i<M;i++)
    {
        printf("%d\n",ans[i]);
    }
}
int main()
{
    solve();
}
```

---

## 作者：Marginal_world (赞：8)

# **各位大佬们好！！！**
###### 本人新晋萌新一枚，当时看到此题时也是一头雾水，后来询问了师兄后了解到了新知识
[强连通分量](https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/7448759?fr=aladdin)

###### 假设成为一个图，在内部寻找可行性点，如果a可到b，b可到c，那么a就一定可到c！！
了解后，倍感无力。这就是知（da）识（lao）的力量

AC代码如下——
```cpp
#include<bits/stdc++.h>//最喜欢的万能头
using namespace std;
int n,m;
char a[1005][1005];//注意一定要开char，否则会炸，后果自负
int b[1005][1005];//记录有没有走过
int i,j,ans[100005];//记录答案
int x,y;//提供的下标
int mx[4]={0,0,1,-1};//四个方向寻找
int my[4]={1,-1,0,0};
void dfs(int x,int y,int p,int i){
	if(x<0||x>=n||y<0||y>=n||b[x][y]!=-1||a[x][y]-48!=p)//如果不在范围内，或是找过或是数字不正确
	return;
	b[x][y]=i;//这一步很关键，下面叙述
	ans[i]++;//加一个点
	for(int k=0;k<4;k++){
		int kx=x+mx[k];
		int ky=y+my[k];
		dfs(kx,ky,!p,i);//dfs常用套路，!p是为了变换数字
	}
}
int main(){
	cin>>n>>m;
	for(i=0;i<n;i++)
	scanf("%s",&a[i]);
	memset(b,-1,sizeof(b));//清空，其实是废的
	for(i=0;i<m;i++){
		cin>>x>>y;//输入
		x--,y--;//因为数组从0开始读，给的下标从1开始
		if(b[x][y]==-1)
		dfs(x,y,a[x][y]-48,i);//符合条件就dfs
		else
		ans[i]=ans[b[x][y]];//最关键的一步！！如果已经走过，意味着本轮搜索结束，答案就是上一步的i，也就是b数组存在的第二意义。（承接上文b[x][y]=i;）
	}
	for(i=0;i<m;i++)
	cout<<ans[i]<<endl;//完美输出
	return 0;
}
```
我认为本题主要还是考察对强连通分量的理解，代码难度不大
# 大佬不喜勿喷！！

---

## 作者：维迭生 (赞：5)

　　这道题以前把我给坑死了，交了两页的评测记录。我把爆炸的原因总结了一下，主要是：  
　　第一，这题考读入。我一开始看它数据规模很大就直接用了scanf，结果换行符一直卡在那，我搜出来所有结果都是１或０（取决于我的ans初始化是多少...）
后来用了如下代码：  
```
    char ch;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>ch; 
            if(ch=='0')maze[i][j]=0;
            else maze[i][j]=1;
        }
    }
```  
　　这才正确打入了迷宫。当然，假如你嫌cin太慢，你也可以用这个：  
  ```
for(int i=1;i<=n;i++)
for(int j=1;j<=n;j++){
	char c;
	c=getchar();
	if(c < 32){
      j--;
      continue ;//是换行符或空格
	}
	else{
    	maps[i][j]=c-'0';//不是换行符
	}
}
```
　　就是自己写有点容易出错而已。  
  　　第二，算法问题。这题很容易想到搜索，想必做这道题的时候大家都做过或多或少几道搜索题了，具体方法不必我详述。我是用了**STL**里的队列广搜做的。第一次是想走一次就把走过的点做标记，bfs完了之后遍历一遍，把ans存到vis数组里：  
		
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int MAXN=1001;
const int MAXM=100001;
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int n,m,ans;
int a[MAXM],maze[MAXN][MAXN],thesame[MAXN][MAXN];
queue<pair<int,int> >q;
int bfs(int sx , int sy , int i ){
    if(thesame[sx][sy]>0){
        return thesame[sx][sy];
    }
    while(!q.empty())
        q.pop();
    q.push(make_pair(sx,sy));
    thesame[sx][sy]=-i;
    ans++;
    while(!q.empty()){
        int x=q.front().first;
        int y=q.front().second;
        q.pop();
        for(int j=0;j<4;j++){
            int a=x+dx[j];int b=y+dy[j];
            if(a<=n&&a>=1&&b<=n&&b>=1&&!thesame[a][b]&&maze[x][y]+maze[a][b]==1){
                ans++;
                thesame[a][b]=-i;
                q.push(make_pair(a,b));
            }
        }
    }
    for(int q=1;q<=n;q++)
        for(int w=1;w<=n;w++){
            if(thesame[q][w]<0)
                thesame[q][w]=ans;
        }
    return ans;
} 
int main(){
    char ch;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>ch; 
            if(ch=='0')maze[i][j]=0;
            else maze[i][j]=1;
        }
    }
    for(int i=1;i<=m;i++){
        int sx,sy;
        cin>>sx>>sy;
        ans=0;
        a[i]=bfs(sx,sy,i);
    }
    for(int i=1;i<=m;i++)
        printf("%d\n",a[i]);
    return 0;
}
```
　　然后超时两个点，比不存要多过一个点，但那还是超时！**TLE**！  
  　　其实，算法里的遍历迷宫复杂度是**O($n^2$)**,显然会超时，解决超时的办法，就是牺牲空间复杂度：并不把每一次搜索的结果都记录在vis数组里，而是单独开一个flag数组用来记录第**i**次搜索搜到的格子，并把ans保存在另一个数组$a[MAXM]$ 里，以额外$(n^2+m)$的空间，换得了时间。  
　　全代码如下：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int MAXN=1001;
const int MAXM=1000001;
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int n,m,ans;
int a[MAXM],maze[MAXN][MAXN];//thesame[MAXN][MAXN];
int flag[MAXN][MAXN];
bool vis[MAXN][MAXN];
queue<pair<int,int> >q;
int bfs(int sx , int sy , int i ){
    if(flag[sx][sy]>0)	//假如我已经搜索过了，就不必搜了
        return a[flag[sx][sy]];
    while(!q.empty())   //先清空队列，也可以用q.erase()
        q.pop();
    q.push(make_pair(sx,sy));
    flag[sx][sy]=i;		//记录当前所搜到的所有格子都为第i次搜到的
    vis[sx][sy]=true;
    ans++;
    while(!q.empty()){		//标准stl队列使用模板
        int x=q.front().first;
        int y=q.front().second;
        q.pop();
        for(int j=0;j<4;j++){
            int a=x+dx[j];int b=y+dy[j];
            if(a<=n&&a>=1&&b<=n&&b>=1&&!vis[a][b]&&maze[x][y]+maze[a][b]==1){
                ans++;
                flag[a][b]=i;
                vis[a][b]=true;
                q.push(make_pair(a,b));
            }
        }
    }
    return ans;
} 
int main(){
    char ch;			//素质的读入
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>ch; 
            if(ch=='0')maze[i][j]=0;
            else maze[i][j]=1;
        }
    }
    for(int i=1;i<=m;i++){
        int sx,sy;
        scanf("%d %d",&sx,&sy);		//查询
        ans=0;
        a[i]=bfs(sx,sy,i);
    }
    for(int i=1;i<=m;i++)			//输出
        printf("%d\n",a[i]);
    return 0;
}			//end
```

---

## 作者：yubing_lml (赞：4)

NO.7 困扰了蒟蒻几天的**超时谜团终于解开**了！一开始，用的BFS，不出所料几个点TLE ┭┮﹏┭┮ 后来，改成BFS也超时 ┭┮﹏┭┮ （可能是没有记忆化导致的，毕竟搜索深度太大），最后，看到题解里连通块的概念，就去搜资料写了一下，终于守得云开见月明！

### 简单来说，这道题我用了**DFS**和**连通块**两个方法。大致思路如下：

变量有些多，但是还是很好理解哒~主要的就是用**mark数组标记点(i,j)属于哪个连通图（从1开始计数）**。初始时各点的mark值均为0。每输入一个坐标点，就判断该点的mark值是否为0，如果是，说明该点的值还没有被计算过，那就创建一个新的连通图，并调用dfs将属于这个连通图的所有点找到，这个找点的过程就是把mark值置为当前连通图的标号的过程。dfs过后，所有属于该连通图的点的mark值都变成该连通图的标号no。

通过上述的描述我们发现，还需要一个数组来**存储每个连通图的值，liantong数组**（注意该数组的大小，如果太小则会RE）实现这一功能。这样就实现了对点的记忆化搜索。

关于连通块这个概念，其实我在调试过程中已经隐隐约约发现，只要从一个点出发，寻找可达点，那么所有这条寻找路径上的点均彼此可达，它们的计算值也就相等。之前mark都是用来做真假标记的，这次巧用了一下，竟有奇效！


### AC代码~
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;

char ch;
int n, m, row, col;
int a[1003][1003]; //长度为n*n的矩阵
int mark[1003][1003];//mark标记该点的值是第几个连通图遍历过
int change[4][2] = { {-1,0},{1,0},{0,1},{0,-1} };  //相邻四个格子
int liantong[1000003]; //第i个连通图的值

int dfs(int ss, int ee)
{
	int ans = 1; //开始只可以到达自己
	int nx, ny;
	for (int i = 0; i < 4; i++) //左右下上四个点
	{
		nx = ss + change[i][0];
		ny = ee + change[i][1];
		if (nx<1 || nx>n || ny<1 || ny>n)
			continue;
		if (mark[nx][ny] !=0)
			continue;
		if (a[nx][ny] + a[ss][ee] == 1)
		{
			mark[nx][ny] = mark[ss][ee];
			ans += dfs(nx, ny);
		}
	}
	return ans;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
		{
			cin >> ch;
			a[i][j] = ch - '0';
		}
	int no = 0;
	memset(mark, 0, sizeof(mark));
	while (m--)
	{
		cin >> row >> col;
		if (mark[row][col] == 0)
		{
			no++;
			mark[row][col] = no;
			liantong[no] = dfs(row, col);
			cout << liantong[no] << endl;
		}
		else
			cout << liantong[mark[row][col]] << endl;
	}
	return 0;
}
```


---

## 作者：二哥啃菜包 (赞：4)

这题我们一想好像可以直接bfs每一个访问。嗯对，没错，但好像死了。。。。
完美的T掉三个点。

考虑满分做法，一想。嗯？这题像是有联通块的影子。
俗话说得好：
### 没有并查集不能解决的联通块。
哈哈于是就出现了神奇的并查集做法。。
但观摩了各位大佬的并查集后觉得好麻烦。

我们首先肯定要将并查集压回一维。
不然太难做。
### 那么具体怎么做呢？

哦脑子一动，请观察一波图：

设f[编号]为并查集他爸爸

1 2 3 4

5 6 7 8

9 10 11 12......

f[编号]好像和i，j有点关系
，设m为横着的个数

一推发现
## 编号$=(i-1)*m+j$
那么就完成了。棒棒，快夸夸我。
```#include<cstdio>
#include<queue>
#include<iostream>
using namespace std;
int n,m;
#define N 1005
int u,v;
struct node{
	int x,y;
	char w;
};
queue<node> q;
char map[N][N];
bool vis[N][N];
int f[N*N],a[N*N];//a为可到达的点数，f为爹
int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
int getf(int x){
	if(f[x]==x)return x;
	else return f[x]=getf(f[x]);
}
void bfs(int cx,int cy){
	q.push((node){cx,cy,map[cx][cy]});
	vis[cx][cy]=1;
	while(!q.empty()){
		node t=q.front();q.pop();
		for(int i=0;i<4;++i){
			int x=dx[i]+t.x;int y=dy[i]+t.y;
			if(x>n || x<1 || y>n || y<1 || vis[x][y]==1)continue;
			if(map[x][y]!=t.w){
				int t1=getf((x-1)*n+y);
				int t2=getf((t.x-1)*n+t.y);
				if(f[t1]!=f[t2]){
					q.push((node){x,y,map[x][y]});
					a[f[t2]]+=a[f[t1]];
					f[t1]=f[t2];
					vis[x][y]=1;
				}
			}
		}
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			f[(i-1)*n+j]=(i-1)*n+j;
			a[(i-1)*n+j]=1;//
			cin>>map[i][j];
		}
	}
	for(int i=1;i<=n;++i)
		for (int j=1;j<=n;++j)
		if (!vis[i][j]) bfs(i,j);
	for(int i=1;i<=m;++i){
		cin>>u>>v;//之前被scanf卡了好久好久
		printf("%d\n",a[getf((u-1)*n+v)]); 
	}
	return 0；
}
```

---

## 作者：sqc1999 (赞：4)

这道题其实挺简单的，典型的BFS，但是数据有点大，刚开始后两个点一直过不了，看了 野菜花 的题解后才AC了。

```cpp

#include<iostream>  
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
struct point {int x,y;};
int a[2000][2000],n,m,c=0,b[100001],v[2000][2000];
int bfs(point p)
{
    int cnt=0;
    queue<point> q;
    q.push(p);
    v[p.x][p.y]=c;
    while (q.size()>0)
    {
        point t;
        t=q.front();
        q.pop();
        cnt++;
        if (t.x+1<=n&&v[t.x+1][t.y]==0&&a[t.x+1][t.y]!=a[t.x][t.y])
        {
            point tt;
            tt.x=t.x+1;
            tt.y=t.y;
            v[t.x+1][t.y]=c;
            q.push(tt);
        }
        if (t.x-1>0&&v[t.x-1][t.y]==0&&a[t.x-1][t.y]!=a[t.x][t.y])
        {
            point tt;
            tt.x=t.x-1;
            tt.y=t.y;
            v[t.x-1][t.y]=c;
            q.push(tt);
        }
        if (t.y+1<=n&&v[t.x][t.y+1]==0&&a[t.x][t.y+1]!=a[t.x][t.y])
        {
            point tt;
            tt.x=t.x;
            tt.y=t.y+1;
            v[t.x][t.y+1]=c;
            q.push(tt);
        }
        if (t.y-1>0&&v[t.x][t.y-1]==0&&a[t.x][t.y-1]!=a[t.x][t.y])
        {
            point tt;
            tt.x=t.x;
            tt.y=t.y-1;
            v[t.x][t.y-1]=c;
            q.push(tt);
        }
    }
    return cnt;
}
int main()
{
    ios::sync_with_stdio(false);
    memset(v,0,sizeof(v));
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
        {
            char c;
            cin>>c;
            a[i][j]=(int)c-48;
        }
    for (int i=1;i<=m;i++)
    {
        point p;
        cin>>p.x>>p.y;
        if (v[p.x][p.y]>0) cout<<b[v[p.x][p.y]]<<"\n";
        else
        {
            c++;
            b[c]=bfs(p);
            cout<<b[c]<<"\n";
        }
    }
    return 0;
} 

```
ps:不要被这么长一串的东西吓到了，上面四个if其实是“复制+粘贴+稍稍修改”的结果。


---

## 作者：a526955194 (赞：4)

一个个搜会爆  所以可以用一个数组来记录目标坐标是否被搜过

（因为一次深搜过的点的答案是相同的）

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
int n,m,i,j,k,x,y,xx,yy,f[1205][1015],ff[1105][1205],h,t,tt,c[1000105],d[1000105];
char s[1205][1105];
int p[4]={0,0,1,-1};
int q[4]={1,-1,0,0}; 
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1; i<=n; i++)
        for (j=1; j<=n; j++)
            cin>>s[i][j];
    for (k=1; k<=m; k++)
    {
        scanf("%d%d",&x,&y);
        if (f[x][y]>0)
        {
            printf("%d\n",ff[x][y]);
            continue;
        }
        tt++;
        h=0; t=1;
        c[1]=x;
        d[1]=y;
        f[x][y]=tt;
        while (h<t)
        {
            h++;
            for (i=0; i<=3; i++)
            {
                xx=c[h]+p[i];
                yy=d[h]+q[i];
                if (f[xx][yy]==0 && xx<=n && xx>=1 && yy<=n && yy>=1 && s[xx][yy]!=s[c[h]][d[h]])
                {
                    t++;
                    c[t]=xx;
                    d[t]=yy;
                    f[xx][yy]=tt;
                }
            }
        }
        for (i=1; i<=t; i++)
            ff[c[i]][d[i]]=t;
        printf("%d\n",ff[x][y]);
    }
    return 0;
}
```

---

## 作者：zhl001 (赞：3)

满怀信心用dfs咔咔过了这个题之后一看

~~？？题解代码这么少？？~~

但是，我还是用了另一个新奇的思路的——记忆化搜索而且码风也比较好懂，下面是思路：

- 输入每次要开始的点，如果没有找过这个点所在的区域，就遍历一边这个区域，然后用belong数组记录这个点属于那一块，用size记录这一块的大小

- 对于已经遍历过的点，就只需要输出 所在区域的 大小

ok原理已经明白，然后注意数组大小不要开错就行~~（我经常被大小卡。。）~~
上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int Max=1001;
bool mmap[Max][Max];
int n,m,x,y,cnt,a,b,t,d[4][2]={{0,1},{0,-1},{1,0},{-1,0}},vis[Max][Max],belong[Max][Max],size[Max*Max];
queue <int> q;
int dfs(int x,int y,int flag)
{
	int ans=1;
	vis[x][y]=1;
	for(int i=0;i<4;i++)
	{
		int xx=x+d[i][0],yy=y+d[i][1];
		if(xx<1||xx>n||yy<1||yy>n||mmap[xx][yy]==flag)
		continue;
		if(!vis[xx][yy])
		{
			belong[xx][yy]=cnt;
			ans+=dfs(xx,yy,!flag);
		}
	}
	return ans;
}
int main()
{
	char ch;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>ch;
			if(ch=='0')
			{
				mmap[i][j]=0;
			}
			else 
			{
				mmap[i][j]=1;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		if(!vis[x][y])
		{
			cnt++;
			belong[x][y]=cnt;
			size[cnt]=dfs(x,y,mmap[x][y]);
			printf("%d\n",size[cnt]);
		}
		else 
		{
			printf("%d\n",size[belong[x][y]]);
		}
		
	}
	return 0;
}
```
管理大大，辛苦您了(90°鞠躬:）)

---

## 作者：Garrison (赞：3)

最开始我想的是直接暴力深搜，但是很显然有三个点TLE

而且坑人的是好像还不能用scanf
```
#include<bits/stdc++.h>
using namespace std;
int a[5]{0,0,1,-1};
int b[5]{1,-1,0,0};
char maze[1010][1010];
bool flag[1010][1010];
int total,x,y,n,m;
inline void search(int x,int y)
{
	flag[x][y]=1;
	++total;
	for(register int i=0;i<4;++i){
		if(!flag[x+a[i]][y+b[i]]&&maze[x][y]!=maze[x+a[i]][y+b[i]]&&x+a[i]<=n&&x+a[i]>=1&&y+b[i]<=n&&y+b[i]>=1)
			search(x+a[i],y+b[i]);
	}
}
inline void mem(bool x[1010][1010]){
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j)
			x[i][j]=0;
}
int main()
{
	//std::ios::sync_with_stdio(false);
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;++i)
		for(int j=1;j<=n;++j){
			cin>>maze[i][j];
		}
	for(register int i=1;i<=m;++i){
		cin>>x>>y;
		total=0;
		search(x,y);
		mem(flag);
		cout<<total<<endl;
	}
	return 0;
}
```
后来呢，发现迷宫中被划分出来很多个连通图，每个连通图中的次数是一样的，所以我把深搜改了一下。加了一个将同一个连通图蹦到一块的函数，不过很显然没有优化。（超时了2个点）
```
#include<bits/stdc++.h>
using namespace std;
int a[5]{0,0,1,-1};
int b[5]{1,-1,0,0};
char maze[1010][1010];
bool flag[1010][1010];
int ans[1010][1010];
int total,x,y,n,m;
inline void search(int x,int y)
{
	flag[x][y]=1;
	++total;
	for(register int i=0;i<4;++i){
		if(!flag[x+a[i]][y+b[i]]&&maze[x][y]!=maze[x+a[i]][y+b[i]]&&x+a[i]<=n&&x+a[i]>=1&&y+b[i]<=n&&y+b[i]>=1)
			search(x+a[i],y+b[i]);
	}
}
inline void liant(int x,int y)
{
	flag[x][y]=0;
	ans[x][y]=total;
	for(register int i=0;i<4;++i){
		if(flag[x+a[i]][y+b[i]]&&maze[x][y]!=maze[x+a[i]][y+b[i]]&&x+a[i]<=n&&x+a[i]>=1&&y+b[i]<=n&&y+b[i]>=1){
			liant(x+a[i],y+b[i]);
		}
	}
}
int main()
{
	//std::ios::sync_with_stdio(false);
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j){
			std::cin>>maze[i][j];
		}
	for(register int i=1;i<=m;++i){
		scanf("%d%d",&x,&y);
		if(!flag[x][y]){
			total=0;
			search(x,y);
			liant(x,y);
		}
		printf("%d\n",ans[x][y]);
	}
	return 0;
}
```
于是我就开始了~~5分钟的优化之旅~~漫长的优化之旅

其实可以另外开一个数组存每个连通图块同样的方案数，在一个函数中就可以将其存放，没必要像方法二一样用两个函数了！
```
#include<bits/stdc++.h>
using namespace std;
int a[5]{0,0,1,-1};
int b[5]{1,-1,0,0};
char maze[1010][1010];
bool flag[1010][1010];
int ans[1020100];
int iss[1010][1010];
int total,x,y,n,m,d=1;
inline void search(int x,int y)
{
	flag[x][y]=1;
	iss[x][y]=d;
	++total;
	for(register int i=0;i<4;++i){
		if(!flag[x+a[i]][y+b[i]]&&maze[x][y]!=maze[x+a[i]][y+b[i]]&&x+a[i]<=n&&x+a[i]>=1&&y+b[i]<=n&&y+b[i]>=1)
			search(x+a[i],y+b[i]);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;++i)
		for(register int j=1;j<=n;++j){
			std::cin>>maze[i][j];
		}
	for(register int i=1;i<=m;++i){
		scanf("%d%d",&x,&y);
		if(iss[x][y]==0)
		{
			total=0;
			search(x,y);
			ans[d++]=total;
		}
		cout<<ans[iss[x][y]]<<endl;
	}
	return 0;
}
```
完美AC
求过


---

## 作者：Clouder (赞：3)

# 大致题意
相邻格子不同为连通，计算每个点所在的连通块大小。
# 想法
我采用了并查集的做法。
开一个辅助数组记录连通块大小，每次合并的时候更新父亲节点的大小即可。


> 一个点先与它上面的点判定，若判定连通则加入上方点所属的块中。 
>
> 再与左边的点判定，若连通则再将两个块合并。

总体复杂度$O(n^3)$，其中并查集不加优化复杂度为$O(n)$，使用路径压缩+按节点大小合并优化并查集，将并查集复杂度降低为近似$O(1)$，总体复杂度近似为$O(n^2)$。
## 并查集优化
### 路径压缩
每次查找的时候，将路径上的所有儿子的父亲改写为最原始的祖宗。这样下次就可以直接找到祖宗。
实现：

```cpp
inline int find(const int &x)
{
    return fa[x] == x ? x : fa[x] = find(fa[x]);//路径压缩
}
```
通俗写法：

```cpp
inline int find(const int &x)
{
    if(fa[x] == x)//找到无父亲的节点，即为祖宗
    	return x;
    fa[x] = find(fa[x]);
    return fa[x];
}
```
### 按秩合并
思考：
有2个块需要合并，那么将小块接在大块的后面能够让整体复杂度更优。
可以将每个祖宗及其所有儿子看做一棵树，那么节点到根的距离就是查找父亲需要的次数。
将小树并入大树，可以避免树的深度过深。
这个rnk数组保存的是树的深度的上界。
通常写法：

```cpp
const int maxn = 10000000;
int rnk[maxn],fa[maxn];//rnk为该节点所在子树的深度
inline void unite(const int &x,const int &y)
{
	//合并x与y的块
	int t1 = find(x),t2 = find(y);//找到各自的祖宗
	if(t1 == t2)
		return;
	if(rnk[t1] == rnk[t2])
	{
		//此时两树深度相等，随便合并
		fa[t1] = t2;
		++rnk[t2];//合并后深度增加
	}
	else if(rnk[t1] > rnk[t2])
		fa[t2] = t1;
	else
		fa[t1] = t2;
}
```
## 总结
路径压缩和按秩合并都能将并查集复杂度降为$O(logn)$，而两者一起使用能够降为$O(log^*n)$。
|$n$|$log^*n$ |
|--|--|
|(−∞, 1]|0|
|(1, 2]|1|
|(2, 4]|2|
|(4, 16]|3|
|(16, 65536]|4|
|(65536, 2^65536]|5|
(数据转自[链接](https://blog.csdn.net/johnny901114/article/details/80721436)，个人认为这篇博文讲并查集讲得相当不错。)

# 代码
因为按秩合并需要额外数组，而在此数量级下开数组的消耗可能比优化更大……
于是借用了题目中维护的“连通块大小”，即节点个数，进行了按size合并的优化。
```cpp
#include <cstdio>
using namespace std;
#define getId(x, y) (((x - 1) * n) + y) //将二维的点赋予一个一维的别名
int fa[1001000];
int h[1001000];
char all[2][1010];
int n, m, i, j;
//读入优化
inline char nc()
{
    static char buf[400000], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 400000, stdin), p1 == p2) ? EOF : *p1++;
}
void read(char *s)
{
    static char c;
    for (c = nc(); c != '1' && c != '0'; c = nc());
    for (; c == '0' || c == '1'; *++s = c, c = nc());
}
void read(int &r)
{
    static char c;  r = 0;
    for (c = nc(); c > '9' || c < '0'; c = nc());
    for (; c >= '0' && c <= '9'; r = (r << 1) + (r << 3) + (c ^ 48), c = nc());
}
//并查集
inline int find(const int &x)
{
    return fa[x] == x ? x : fa[x] = find(fa[x]);//路径压缩
}
inline void unite(const int &a, const int &b)
{
    int t1 = find(a), t2 = find(b);
    if (t1 == t2)
        return;
    h[t1] > h[t2] ? fa[t2] = t1, h[t1] += h[t2] : fa[t1] = t2, h[t2] += h[t1]; //类似按秩合并的做法，合并同时将儿子的大小加入父亲的大小中
}
//
int main()
{
    read(n);
    read(m);
    int n2 = n * n;
    for (int i = 1; i <= n2; ++i)
        fa[i] = i, h[i] = 1; //初始化每个点都是单独的联通块，大小为1
    
    int now = 0, pre = 1;
    //第一行特判，不需要与上一行作比较
    i = 1;
    read(all[now]);
    for (j = 2; j <= n; ++j)//j从2开始，可以略过第一个格子，最左上角的格子无需判断
        if (all[now][j] != all[now][j - 1])
            unite(getId(i, j), getId(i, j - 1));

    for (i = 2; i <= n; ++i)
    {
        now ^= 1;//使用滚动数组
        pre ^= 1;
        read(all[now]);
        if (all[now][1] != all[pre][1])
            unite(getId(i, 1), getId(i - 1, 1));//第一个格子无需与左边判断
        for (j = 2; j <= n; ++j)
        {
            if (all[now][j] != all[now][j - 1]) //因为是按行按列遍历，实际上只需要处理每个点的上方点和左边点的合并
                unite(getId(i, j), getId(i, j - 1));
            if (all[now][j] != all[pre][j])
                unite(getId(i, j), getId(i - 1, j));
        }
    }
    int x, y;
    for (i = 1; i <= m; ++i)
    {
        read(x);
        read(y);
        printf("%d\n", h[find(getId(x,y))]);
    }
    return 0;
}
```



---

## 作者：Fading (赞：3)


**这道题真的把我气的......**

一开始：不就是BFS嘛！

后来：怎么0分？

再后来：T了3个！

最后：还是用记忆化BFS吧！

先讲讲最水的思路：

**一个一个格子广搜，开一个队列记录一些搜过的坐标。**


```cpp
procedure bfs(x0,y0:longint);
var dl:array[1..100000,1..2] of longint;
    i,j,x,y,h,t:longint;
begin
  h:=0; t:=1; dl[1,1]:=x0; dl[1,2]:=y0; 
  o:=1;//记录可以到几个点，别忘记了自己！
  for i:=1 to n do for j:=1 to n do hash[i,j]:=false;//记录这个点是否走过，不然会死循环+答案错误
  hash[x0,y0]:=true;
repeat
    inc(h);
    for i:=1 to 4 do
    begin
      x:=dx[i]+dl[h,1];  //dx、dy表示上下左右的x、y变化量
      y:=dy[i]+dl[h,2];
      if (map[x,y]=map[dl[h,1],dl[h,2]]) //如果与之前的数一样，不可以走，退出~
      or (x=0) or (y=0) or (x=n+1) or (y=n+1)
        or hash[x][y]   //判断边界以及是否走过
      then continue;
      inc(t);
      dl[t,1]:=x; dl[t,2]:=y;
      hash[x,y]:=true;
      inc(o);
    end;
  until h>=t;
end;
```
然后就华丽丽的T了3个点。。。

原来把hash赋值的时候太耗时了...

看来以后不要使用fillchar(memset)了，太费时间了

只需要在最后的时候改一下即可



for i:=1 to h do 

    hash[dl[i][1],dl[i][2]]:=false;

更快更省时！

然而只有80分，还有两个T！

忍无可忍的我只能用记忆化了。。。


因为题目让我们求可以跳到多少个点，所以一次BFS下来，所有队列中的点可以到达的点数都是最终求出的结果（即为o）

那么一次BFS可以顺带求出很多点的答案了。


```cpp
 for i:=1 to h do begin
    as[dl[i][1],dl[i][2]]:=false;
    jiyi[dl[i][1],dl[i][2]]:=o;//记忆化
  end;
```
完整代码如下：
```cpp
const dx:array[1..4] of longint=(0,1,0,-1);
      dy:array[1..4] of longint=(-1,0,1,0);
var i,j,k,o,p,m,n,b,g,q1,q2:longint;
    map,jiyi:array[0..1005,0..1005] of longint;
    s:ansistring;
    as:array[0..1[001,0..1001] of boolean; 
procedure bfs(x0,y0:longint); 
var dl:array[1..200001,1..2] of longint;
    i,j,x,y,h,t:longint;
begin
  h:=0; t:=1; dl[1,1]:=x0; dl[1,2]:=y0; o:=1;
  as[x0,y0]:=true;
  repeat
    inc(h);
    for i:=1 to 4 do
    begin
      x:=dx[i]+dl[h,1];
      y:=dy[i]+dl[h,2];
      if (map[x,y]=map[dl[h,1],dl[h,2]])
      or (x=0) or (y=0) or (x=n+1) or (y=n+1)
```
or as[x][y]
```cpp
      then continue;
      inc(t);
      dl[t,1]:=x; dl[t,2]:=y;
      as[x,y]:=true;
      inc(o);
    end;
  until h>=t;
  for i:=1 to h do begin
    as[dl[i][1],dl[i][2]]:=false;
    jiyi[dl[i][1],dl[i][2]]:=o;
  end;
end;
begin
  readln(n,m);
  for i:=1 to n do
    begin
      readln(s);
      for j:=1 to length(s) do
        map[i,j]:=ord(s[j])-48;//注意一下，这里需要字符串处理！！！
    end;
  for i:=1 to n do for j:=1 to n do jiyi[i,j]:=-1; 
  for i:=1 to m do
  begin
    readln(q1,q2);
    if jiyi[q1,q2]<>-1 then begin writeln(jiyi[q1,q2]); continue; end;//如果这个点在之前已经（顺带）求过了，那么直接输出！
    bfs(q1,q2); //广搜
    writeln(o); //输出
  end;
end.
```

---

## 作者：chenxuanting (赞：2)

刚做完这道题，感觉肺都要气炸了

我看了题解改了一点，然后改的过程中，我发现

woc，我大于号写成小于号了

然后把我原来的代码拷贝回来，改了不等号后

WTF，竟然对了

~~你说我气不气~~

好了不扯那么远

目录

1.思路

2.错误记录

3.你们最喜欢的代码

一.思路

用dfs，同时每次都标记一个数字，这样可以节省时间，不然.......

你会TLE   ~~TIME LEFTED EXCCEED(时间剩余超限）~~

同时拿个数组记录个数~~不然就白标记了~~

二.错误记录

1.10个WA（就是不等号写反了）

0分

2.10个AC

改完之后就对了

三.新鲜出炉的AC代码

对了还有我的代码风格比较奇特，望理解

代码如下

```
#include<cstdio>
#include<iostream>
using namespace std;
int n,m;
char a[1005][1005];
int vis[1005][1005];
int ans[100005];
int sign;
int now;
int posx,posy;
void dfs(int x,int y,char s)
{
	if(x<1||x>n||y<1||y>n){
		return;
	}
	if(vis[x][y]!=0){
		return;
	}
	if(s==a[x][y]){
		return;
	}
	vis[x][y]=sign;
	s=a[x][y];
	now+=1;
	dfs(x+1,y,s);
	dfs(x-1,y,s);
	dfs(x,y-1,s);
	dfs(x,y+1,s);
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int i1=1;i1<=n;i1++){
			cin>>a[i][i1];
		}
	}
	for(int i=1;i<=m;i++){
		cin>>posx>>posy;
		now=0;
		if(vis[posx][posy]==0){
			sign++;
			dfs(posx,posy,'3');
			ans[sign]=now;
			cout<<now;
		}else{
			cout<<ans[vis[posx][posy]];
		}
		cout<<endl;
    }
    return 0;//结束
}
```


---

## 作者：unauthorized (赞：2)

```cpp
#include<iostream>
using namespace std;
int a[1000001],n,m,co=0,sum;
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
bool map[1001][1001];
int flag[1001][1001]={0};
void bfs(int x,int y){
/*广搜 大概就是搜索到周围走不动了位置 
然后flag是记录该点属于第几块连通区域，
这一片连通区域属于同一个flag(=co)
而a[flag]则记录该连通区域的连通点数量(sum) 
这样通过点坐标x,y找到flag 再找到a[flag]=sum就是答案
*/
	sum++;
	for(int i=0;i<4;++i){
		int nx=x+dx[i],ny=y+dy[i];
		if(flag[nx][ny])continue;
		if(nx>=0&&nx<n&&ny>=0&&ny<n){
			//cout<<"1.sum="<<sum<<",x="<<nx<<",y="<<ny<<",co="<<co<<",flag="<<flag[nx][ny]<<endl;
			//cout<<x<<" "<<y<<" "<<map[x][y]<<endl;
			if(map[nx][ny]==!map[x][y]){
			    flag[nx][ny]=co;
				//cout<<"2.x="<<nx<<",y="<<ny<<",co="<<co<<",flag="<<flag[nx][ny]<<endl;
				bfs(nx,ny);
			}
		}
	}
	//cout<<"x="<<x<<",y="<<y<<",flag="<<flag[x][y]<<endl;
}
int main(){
	cin>>n>>m;
	char c;
	for(int i=0;i<n;++i){
		for(int j=0;j<n;++j){
			cin>>c;
			if(c=='0')map[i][j]=0;
			else map[i][j]=1;
		}
	}
	for(int i=0;i<n;++i){
		for(int j=0;j<n;++j){
			if(!flag[i][j]){//该区域与之前区域不连通
				co++;sum=0;//故而co++ 标识新区域
				//cout<<"now,x="<<i<<",y="<<j<<endl;
				//cout<<"now,co="<<co<<endl;
				flag[i][j]=co;
				//cout<<"a new bfs"<<endl;
				bfs(i,j);
				a[co]=sum;
			}
		}
	}
	int x,y;
	for(int i=0;i<m;++i){
		cin>>x>>y;
		cout<<a[flag[x-1][y-1]]<<endl;
	}
}
```
emm第一次发代码…规格啥的不懂orz
用的广搜叭233
被坑的点在于输入…0110啥的应该用char处理比较好…否则01=1 10（bool下）=1…整整找了半个小时orz
其他的就…常规(?
广搜 co是color缩写，染房间那种题过来的(


---

## 作者：cghsncg (赞：2)

# 01迷宫-深搜
~~第一次在洛谷发题解，菜~~

------------

首先这道题是求最多通过的方格数，很明显，求的是连通区域我们可以直接通过dfs搜索他所需点的联通区并且对所有联通区域用flag标记，对r[flag]进行++操作，并且每次dfs之前对flag进行更新~~~


------------
**dfs部分代码**
```cpp
ll dfs(ll m,ll n)
{
    for(ll i=0;i<4;i++)
    {
        if(m+z[i]>=1&&m+z[i]<=a&&n+y[i]>=1&&n+y[i]<=a&&q[m+z[i]][n+y[i]]==0&&p[m+z[i]][n+y[i]]!=p[m][n])//判断是否可以走
        {
            q[m+z[i]][n+y[i]]=flag;
            r[flag]++;
            dfs(m+z[i],n+y[i]);
        }
    }
}
```
对于所有要求的话可以分为两步，检查他是否在已存在的联通区域中
**代码**
```cpp
 for(c=1;c<=b;c++)
    {
        scanf("%lld %lld",&m,&n);
        if(q[m][n])//假如标记了就直接输出
        {
            printf("%lld\n",r[q[m][n]]+1);
        }
        else{
                flag++;//记住联通区域标记
q[m][n]=flag;
        dfs(m,n);
        printf("%lld\n",r[flag]+1);

        }
    }

```


**最后附上所有代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll q[1010][1010],r[10000010];
char p[1010][1010];
ll flag=0;
ll z[4]={0,0,1,-1};
ll y[4]={1,-1,0,0};
ll a;
ll dfs(ll m,ll n)
{
    for(ll i=0;i<4;i++)
    {
        if(m+z[i]>=1&&m+z[i]<=a&&n+y[i]>=1&&n+y[i]<=a&&q[m+z[i]][n+y[i]]==0&&p[m+z[i]][n+y[i]]!=p[m][n])
        {
            q[m+z[i]][n+y[i]]=flag;
            r[flag]++;
            dfs(m+z[i],n+y[i]);
        }
    }
}
int main()
{
    ll b,c,d,m,n;
    cin>>a>>b;
    getchar();
    for(c=1;c<=a;c++)
    {
       scanf("%s",p[c]+1);
    }
    for(c=1;c<=b;c++)
    {
        scanf("%lld %lld",&m,&n);
        if(q[m][n])
        {
            printf("%lld\n",r[q[m][n]]+1);
        }
        else{
           flag++;
           q[m][n]=flag;
        dfs(m,n);
        printf("%lld\n",r[flag]+1);
        }
    }
}

```
   **by shncg**                       

---

## 作者：hawkii (赞：2)

不知道各位蒟蒻是不是和我一样，喜欢看短的答案！！

- 用string读入01矩阵；
- bfs中常用vis矩阵，更改为联通块s矩阵，当i=0时，未被搜索过，当i>0时对应第i次询问找到的点，arr对应第i次询问返回值，每搜到新的点填入对应次数i；
- 当询问的点已经被搜过，则直接返回arr[第几次搜到的点]的值；
- 用bfs时，注意数列元素数量可能超过整个矩阵点的数量，设置成400005，四倍点数量。

------------
**下面附上AC代码(稍微压了下行，40行)**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,i,j,x,y,frot,rear;
bool a[1005][1005];
int b[400005][2],arr[400005],s[1005][1005];
int main()
{
    scanf("%d %d\n",&n,&m);
    string s0;
    for(i=1; i<=n; i++){
        getline(cin,s0);
        for(j=0;j<n;j++)
            a[i][j+1] = s0[j]-'0';
    }
    for(i=1; i<=m; i++){
        scanf("%d %d\n",&x,&y);
        if(s[x][y]!=0) {arr[i] = arr[s[x][y]];continue;}
        b[0][0] = x,b[0][1] = y;
        s[x][y]=i;
        frot = 0,rear = 1;
        int xx,yy;
        while(rear - frot > 0){
            xx = b[frot][0],yy = b[frot][1];
            if(a[xx][yy] != a[xx][yy+1] && yy+1<=n && s[xx][yy+1]==0)
                {b[rear][0]=xx,b[rear++][1]=yy+1;s[xx][yy+1]=i;}
            if(a[xx][yy] != a[xx][yy-1] && yy-1>0 && s[xx][yy-1]==0)
                {b[rear][0]=xx,b[rear++][1]=yy-1;s[xx][yy-1]=i;}
            if(a[xx][yy] != a[xx-1][yy] && xx-1>0 && s[xx-1][yy]==0)
                {b[rear][0]=xx-1,b[rear++][1]=yy;s[xx-1][yy]=i;}
            if(a[xx][yy] != a[xx+1][yy] && xx+1<=n && s[xx+1][yy]==0)
                {b[rear][0]=xx+1,b[rear++][1]=yy;s[xx+1][yy]=i;}
            frot++;
        }
        arr[i]=rear;
    }
    for(i=1;i<=m;i++)
        cout << arr[i] << endl;
    return 0;
}
```

---

## 作者：灯芯糕 (赞：2)

# 指针大法好！！

## 看见前面大佬都用广搜，我推荐一款指针加深搜：

## 这一题我们可以定义一个指针数组，把能相互到达的格子的指针指向同一个地址，这样就能同时改变多个格子的到达数。

# 主要步骤：
```cpp
int m,n,tot[100000],c[100000],d[100000];//c,d数组为 m 的横纵坐标 
char ch;int *a[1001][1001];int b[1002][1002];//定义指针 
for(;m>=1;m--){
		cin>>c[m]>>d[m];
		if(a[c[m]][d[m]]){//若指针指向的地址有数，即走过了便直接输出。 
			cout<<*a[c[m]][d[m]]<<endl;//就是记忆搜索 
			continue;
		}
		f(c[m],d[m]);//搜索 
		cout<<tot[m]<<endl;
		tot=0;//记得归0 
	}
```
# 深搜函数：
```cpp
void f(int i,int j){//深搜 
	a[i][j]=&tot[m];//让这个格子的指针，指向累加数； 
	tot[m]++;//累加答案； 
	for(int o=0;o<=3;o++)
		if(i+x[o]>0&&i+x[o]<=n&&j+y[o]>0&&j+y[o]<=n&&!a[i+x[o]][j+y[o]])//走过的不走，不能越界 
		    if(b[i+x[o]][j+y[o]]!=b[i][j])//题目要求 
		        f(i+x[o],j+y[o]);//继续搜索
```
# 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,tot[100000],c[100000],d[100000];//c,d数组为 m 的横纵坐标 
char ch;int *a[1001][1001];int b[1002][1002];//定义指针 
int x[4]={1,0,-1,0};//四个方位 ； 
int y[4]={0,1,0,-1};//方便对比； 
void f(int i,int j){//深搜 
	a[i][j]=&tot[m];//让这个格子的指针，指向累加数； 
	tot[m]++;//累加答案； 
	for(int o=0;o<=3;o++)
		if(i+x[o]>0&&i+x[o]<=n&&j+y[o]>0&&j+y[o]<=n&&!a[i+x[o]][j+y[o]])//走过的不走，不能越界 
		    if(b[i+x[o]][j+y[o]]!=b[i][j])//题目要求 
		        f(i+x[o],j+y[o]);//继续搜索
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)//输入 
			scanf("%1d",&b[i][j]);
	for(;m>=1;m--){
		cin>>c[m]>>d[m];
		if(a[c[m]][d[m]]){//若指针指向的地址有数，即走过了便直接输出。 
			cout<<*a[c[m]][d[m]]<<endl;//就是记忆搜索 
			continue;
		}
		f(c[m],d[m]);//搜索 
		cout<<tot[m]<<endl;//(输出，圆满)
	}
    return 0;
}
```
### 这是我的[博客空间](https://www.luogu.org/space/show?uid=111334)，发的题解和一些洛谷技巧都在里面。

### 另外，本人真的只是一个弱弱的萌新，7月份才入信息组，发的题解讨论等级不高，新人可看。

---

## 作者：sdgmwjy (赞：2)

看到各位dalao们在写题解，忍不住想写一下了233。

总的来说，这个题也算是一个比较基础的bfs了（当然dalao们有更加NB的骚操作），反正我是以蒟蒻的想法来想。

不过，这个题有一些**注意点**：

1.注意**输入**，从样例数据可以看出，迷宫输入是

01
10
不是
0 1
1 0
所以不可以用数组直接输入（我当时就掉进去了233，我想你既然过来看题解了，应该也注意到了，没注意到现在也注意到了233）

2.前面dalao提过，用bfs一定要**记忆化**，否则TLE没商量（我的记忆化很粗暴，各位dalao们吐槽吧。。。）

3.我是用手打bfs，所以有队列数组的问题，这个一定要**开大**[滑稽]，不开大的结果看讨论区我发的吧。。

4...................**∞**需要你自己发现了

附代码（应该比较适合蒟蒻理解）：

```cpp
#include<iostream>
using namespace std;
const int dx[4]={-1,0,0,1},dy[4]={0,-1,1,0};
int n,m,q[5000001][2],v[1001][1001],t=0,sum[100001];
bool map[1001][1001];                        //定义乱七八糟。。。。。。
void bfs(int x,int y)
{
    if(v[x][y]!=0)
    {
        cout<<sum[v[x][y]]<<endl;
        return;
    }
    t++;                                    //我的粗暴的记忆化
    int head=0,tail=1,s=1;
    q[0][0]=x;
    q[0][1]=y;
    v[x][y]=t;
    while(head<tail)                        //比较中规中矩的bfs
    {
        int xx=q[head][0],yy=q[head][1];
        for(int i=0;i<4;i++)
        {
            int xxx=xx+dx[i],yyy=yy+dy[i];
            if(xxx>=1&&xxx<=n&&yyy>=1&&yyy<=n)    //防越界
            {
                if(map[xxx][yyy]!=map[xx][yy]&&v[xxx][yyy]==0)
                {
                    q[tail][0]=xxx;
                    q[tail][1]=yyy;                //入队
                    v[xxx][yyy]=t;                //记录是否被访问
                    s++;
                    tail++;
                }
            }
        }
        head++;
    }
    cout<<s<<endl;
    sum[t]=s;                                    //粗暴的记忆。。。
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        string s;
        cin>>s;                                //注意1.中说的。。。
        for(int j=1;j<=n;j++)
        {
            if(s[j-1]=='0')
            {
                map[i][j]=false;
            }
            else
            {
                map[i][j]=true;
            }
        }
    }
    for(int i=0;i<m;i++)
    {
        int x,y;
        cin>>x>>y;
        bfs(x,y);                                //没用返回值的，直接在里面输出的
    }
    return 0;
}
就这些了，dalao就不要看了，蒟蒻（本人）瑟瑟发抖ing......
```

---

## 作者：Sino_E (赞：2)

```cpp
//最简单的解释：两个连在一起的01点，0能到的点，1也能到。这些01点就可以组成一个01块，01块的每个点所能到达的01数量都是相等的。 
//所以就是求多少个01块的大小的问题。 
//因此最好用广搜。
//之后询问调取即可。避免了DFS算法中O(N*M)的复杂度。 
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1010;
const int MQ=N*N;

int n,m; 
bool maze[N][N];//迷宫描述 
int block[N][N];//所属的块 
int ans[N*N];//块的大小 
int tag=1;//块的计数 

struct Dot{
    int x,y;
}que[MQ];
int head,tail,qlen;
inline void ins(Dot a){
    que[tail++]=a;
    tail%=MQ,qlen++; 
}
inline Dot del(){
    Dot ret=que[head++];
    head%=MQ,qlen--;
    return ret;
}//队列 

int test[][2]={{0,-1},{0,1},{1,0},{-1,0}};
void bfs(int x,int y){
    Dot a;
    a.x=x,a.y=y;
    ins(a);
    while(qlen){
        a=del();
        ans[tag]++;//增加块的大小 
        int nx,ny;
        for(int i=0;i<4;i++){
            nx=a.x+test[i][0],ny=a.y+test[i][1];
            if(nx>=0&&nx<n&&ny>=0&&ny<n&&!block[nx][ny]&&maze[nx][ny]==!maze[a.x][a.y]){//这里块的描述也起到一个标记数组的作用 
                block[nx][ny]=tag;
                Dot b=a;
                b.x=nx;
                b.y=ny;
                ins(b);
            }
        }
    }
}

int main(){
    cin>>n>>m;
    char ch[N];
    for(int i=0;i<n;i++){
        scanf("%s",ch);
        for(int j=0;j<n;j++){
            maze[i][j]=ch[j]-'0';
        }
    }
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            if(!block[i][j]){
                block[i][j]=tag;
                bfs(i,j);
                tag++;//深搜起点 
            }
    int a,b;
    for(int i=0;i<m;i++){
        scanf("%d%d",&a,&b);
        printf("%d\n",ans[block[a-1][b-1]]);//调取询问，输出所属的块的大小即可 
    } 
    return 0; 
}
```

---

## 作者：f112358 (赞：2)

给下面的题解加一个注释，不多解释了..代码：




    

```cpp
//
//  main.cpp
//  01maze_bfs
//
//  Created by Leonardo Cullen.
//  Copyright © 2017 Leonardo Cullen. All rights reserved.
//
#include <iostream>
#include <queue>
#include <cstring>
#include <cstdio>
using namespace std;
bool matrix[1005][1005];//代表矩阵（0／1）；
int vis[1005][1005];//vis数组中存这个点在第几次搜索中访问过
int dx[4]={0,0,1,-1};//行变化量
int dy[4]={-1,1,0,0};//列变化量
int n,m;//m行n列
long int ans[1000000];//第ans[i]为第i次搜索的结果
queue <int> qx,qy;//行队列，列队列
int x,y;
queue <bool>now;//状态队列（当前所处的点是0还是1）
void bfs(int turn,int i,int j)//从点(i,j)开始进行第turn次搜索（turn为所给出的第几个数据）
{
    qx.push(i);//初始点入队
    qy.push(j);
    vis[i][j]=turn;//这个点在第turn次搜索中访问过
    now.push(matrix[i][j]);//当前状态入队
    long int sum=1;//sum为可到达的点数
    while(!qx.empty())//队非空
    {
        for(int w=0;w<4;w++)//四种走法
        {
            int a=qx.front()+dx[w];
            int b=qy.front()+dy[w];
            if(a>=1&&a<=n&&b>=1&&b<=n&&!vis[a][b]&&matrix[a][b]!=now.front())//若满足条件（注：若vsi[a][b]非零则真，本次搜索结果不可能包括曾经到过的点）
            {
                qx.push(a);
                qy.push(b);//点入队
                now.push(matrix[a][b]);//状态入队
                sum++;//点数加一
                vis[a][b]=turn;//该点在第turn次搜索中访问过
            }
        }
        qx.pop();
        qy.pop();
        now.pop();//出队
    }
    ans[turn]=sum;//存储第turn次的结果
    return ;
}
int main(int argc, const char * argv[])
{
    cin>>n>>m;
    register int i,j;//不用register也不会T
    char c;;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            cin>>c;
            if(c=='1') matrix[i][j]=true;//存矩阵（地图）
        }
    }
    for(i=1;i<=m;i++)
    {
        cin>>x>>y;
        if(!vis[x][y]) bfs(i,x,y);//如果这个点曾经没有到过，就搜一遍
        else ans[i]=ans[vis[x][y]];//要是曾经到过，就将曾经第几次到的那个答案作为本次答案
    }
    for(i=1;i<=m;i++)
    {
        cout<<ans[i]<<endl;//输出
    }
    return 0;
}

```

---

## 作者：zhan8822 (赞：2)

一定要用BFS，用DFS爆栈，就算加深度限制也不行，亲身试验为证。





```cpp
#include <cstdio>
#define X gx[head]+dx[i]
#define Y gy[head]+dy[i]
int dx[]={-1,1,0,0},dy[]={0,0,-1,1};
int c[2000][2000],d[2000][2000];
int gx[1000000],gy[1000000];
char g[2000][2000];
int i,j,m,n,s,x,y,head,tail;
void bfs(int x,int y,int z)
{
    head=1;tail=1,gx[head]=x,gy[head]=y,d[gx[head]][gy[head]]=z;
    while (head<=tail)
    {
        for (int i=0;i<4;i++)
            if ((X>0) && (X<=n) && (Y>0) && (Y<=n) && (d[X][Y]!=z) && (g[gx[head]][gy[head]]!=g[X][Y]))
                tail++,gx[tail]=X,gy[tail]=Y,d[X][Y]=z;
        head++;
    }
    c[x][y]=tail;
    for (int i=1;i<=tail;i++)
        c[gx[i]][gy[i]]=tail;
    return;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
    {
        getchar();
        for (j=1;j<=n;j++)
            g[i][j]=getchar()-48;
    }
    for (i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        if (c[x][y]==0)
            bfs(x,y,i);
        printf("%d\n",c[x][y]);
    }
    return 0;
}
```

---

## 作者：王鹏PRO (赞：2)

**来一篇Java语言的题解**


------------

### 分析

1. 图的遍历
2. 标有0或者1交替遍历
3. 多个起点

### 思路：
**BFS + Union-Find**

从起点开始BFS，将可以遍历到的格子，合并为一个集合，集合中格子的个数
就是求解。

注意：
1. 可以从1个起点，也可以从多个起点进行BFS遍历
2. 多个起点遍历过程中可能会重合，当两个或者多个点集合重合的时候，合并成一个集合，避免重复的BFS
3. 为了便于并查集的使用，引入了二维数组坐标与一维数组坐标相互转化

### 知识点
1. 并查集（Union-Find）
可以考察图中点的联通性，在此基础上加入计数功能，记录图中一个父节点（起点）所在的集合中所有元素的个数，供最后ans，同时可以利用遍历过的结果，避免重复计算（某种程度上就是DP）
2. 坐标转化
```java
二维坐标转一维坐标：  
	    int index = x * n + y;

一维坐标转转一维坐标：
            int i = index / n;
            int j = index % n;
```
3. BFS遍历
- 从起点开始BFS，在当前点的四个方向进行遍历寻找可能的下一步
- 必须是四个方向中未访问的点，{-1, 0}, {0, -1}, {0, 1}, {1, 0}
- 必须是下一点的value值与当前所在的点value不同：1-->0 或者 0-->1


### 代码实现

1. 快速Union-Find，有两个主要的方法
- int find(int c)   	

	递归查询节点c的父节点
    
```java
    private static int find(int c) {
        if (c == p[c]) return c;
        return p[c] = find(p[c]);
    }

```


- void union(int c1,int c2)

	将节点c1、c2合并到同一个父节点并计数

```java
    private static int find(int c) {
        if (c == p[c]) return c;
        return p[c] = find(p[c]);
    }

    private static void union(int c1, int c2) {
        int p1 = find(c1);
        int p2 = find(c2);
        if (p1 == p2) return;
        if (p1 > p2) {
            p[p1] = p2;
            cnt[p2] += cnt[p1];
        } else {
            p[p2] = p1;
            cnt[p1] += cnt[p2];
        }
    }
```




------------


### 完整代码

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.StringTokenizer;

import static java.lang.Integer.parseInt;

public class Main {
    private static int n, m, size;
    private static boolean[][] data;
    private static boolean[] visited;
    private static int[] p, cnt;
    private static final int[][] offset = new int[][]{{-1, 0}, {0, -1}, {0, 1}, {1, 0}};
    private static final ArrayDeque<Integer> queue = new ArrayDeque<>();

    public static void main(String[] args) throws Exception {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(in.readLine());
        n = parseInt(st.nextToken());
        m = parseInt(st.nextToken());
        size = n * n;
        data = new boolean[n][n];
        visited = new boolean[size];
        for (int i = 0; i < n; i++) {
            String ins = in.readLine();
            for (int j = 0; j < n; j++) {
                data[i][j] = (ins.charAt(j) == '0');
            }
        }
        p = new int[size];
        for (int i = 0; i < size; i++) {
            p[i] = i;
        }
        cnt = new int[size];
        Arrays.fill(cnt, 1);
        StringBuffer ans = new StringBuffer();
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(in.readLine());
            int x = parseInt(st.nextToken()) - 1;
            int y = parseInt(st.nextToken()) - 1;
            int index = x * n + y;
            if (!visited[index]) bfs(x, y);
            ans.append(cnt[find(index)]).append('\n');
        }
        System.out.println(ans.toString());
    }

    private static void bfs(int x, int y) {
        int index = x * n + y;
        visited[index] = true;
        queue.add(index);
        while (!queue.isEmpty()) {
            int start = queue.poll();
            int i = start / n;
            int j = start % n;
            for (int[] next : offset) {
                int nextX = i + next[0];
                int nextY = j + next[1];
                if (nextX < 0 || nextX >= n) continue;
                if (nextY < 0 || nextY >= n) continue;
                int nextI = nextX * n + nextY;
                if (!visited[nextI] && data[i][j] != data[nextX][nextY]) {
                    visited[nextI] = true;
                    union(start, nextI);
                    queue.add(nextI);
                }
            }
        }
    }

    private static int find(int c) {
        if (c == p[c]) return c;
        return p[c] = find(p[c]);
    }

    private static void union(int c1, int c2) {
        int p1 = find(c1);
        int p2 = find(c2);
        if (p1 == p2) return;
        if (p1 > p2) {
            p[p1] = p2;
            cnt[p2] += cnt[p1];
        } else {
            p[p2] = p1;
            cnt[p1] += cnt[p2];
        }
    }
}

```


---

## 作者：xiejinhao (赞：2)

# P1141 01迷宫 题解 

## ~~好像还是挺水的~~

题目的意思就是要我们求输入点的联通块点数


**前言**：
------------

### **引理**：
		如果从一个0可以到一个1，那么这个0和这个1就是联通的，他们的联通块点数是相同的；如果一个1可以到一个0，结论也是一样的。

### **证明**：
		如果某一个0可以到某一个1，那么这个1也一定可以到这个0；
        我们说这个0和1之间有一条“联通的路径”，路径上的联通块点数相同，那么这条路径延伸出去的联通块点数也相同：
        即对于两个不同的点可以互相到达（如一个0和一个1），它们的联通块点数相同。
        证毕。
        
        

**思路分析**：
------------
- 我们知道，求联通块点数可以选择$DFS$和$BFS$，并且$DFS$比$BFS$要快一些。

### 那么先讲DFS：

1. 我们知道，对与每一组询问数据都是特殊的，因为它们的编号不同(随循环变量改变)。那么这有什么用呢？上面引理已经说到，如果两个点是联通的，那它们能到的点数是相同的，所以我们就可以用每一组询问编号来标记每一次询问走到过的点，如果后面又在访问过那么我们就可以让 $vis[i][j]$（访问数组）直接指向访问过这个点$(i,j)$的那组数据编号，这样我们不仅实现了在线算法，还实现了标记所有联通块
1. 剩下的就是“走迷宫”问题了：下一个点与当前点符号相同(即0与0；1与1)的，不能走；越界的不能走；访问过的不能走。

至此，用$DFS$完成此题已经足够了。

~~扔代码~~

```cpp
#include<cstdio>
#include<string>
using namespace std;
int n,m,x,y,k[1001][1001],ans[100001];
char s[1001][1001];
inline bool check(int x,int y)
{
    if(x>n || y>n || x<0 || y<0 || k[x][y])
        return false;
    return true;
}
inline void dfs(int _0or1,int i,int x,int y)
{
    if(_0or1!=s[x][y]-'0' || !check(x,y)) return;
    k[x][y]=i; ans[i]++;
    dfs(!_0or1,i,x-1,y);dfs(!_0or1,i,x+1,y);
    dfs(!_0or1,i,x,y-1);dfs(!_0or1,i,x,y+1);
  //!_0or1 的意思是传到下一个点的符号与当前不同
  //若当前 _0or1 是0,则!_0or1=1;反之亦然
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
        scanf("%s",s[i]);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        --x;--y; 
  //输入字符从0,0开始存的
  //另一种存图方式看bfs
        if(!k[x][y])
            dfs(s[x][y]-'0',i,x,y);
        else ans[i]=ans[k[x][y]];
        printf("%d\n",ans[i]);
    }
    return 0;
}
```


### BFS：

- 思路与$DFS$是大同小异的，那么上面是用字符数组存的图，下面$bfs$我就写一个用$bool$数组存的图好了($int$存也可以)

```cpp
#include<cstdio>
#include<queue>
using namespace std;

const int dx[]={0,0,1,-1},
		  dy[]={1,-1,0,0};
		  
const int N=1010;
const int M=100010;		  

struct rec {
	bool op; //存符号 
	int x,y; //存坐标 
	//int root;
};

bool a[N][N];
int vis[N][N],ans[M];
int n,m;

void bfs(int x,int y,int s) {
	queue<rec> p;  rec l;
	l.x=x, l.y=y, l.op=a[x][y];
	p.push(l); vis[x][y]=s;
	while(p.size()) {
		rec now=p.front(); p.pop();
		for(int i=0;i<4;i++) {
			int rex=now.x+dx[i],
				rey=now.y+dy[i];
			if(rex<1 || rey<1 || rex>n || rey>n) continue;
			if(a[rex][rey]==now.op || vis[rex][rey]) continue;
			vis[rex][rey]=s;
			rec next; next.x=rex, next.y=rey, next.op=!now.op;
			ans[s]++; p.push(next);
		}
	}
	return;
}

int main() {
	
	scanf("%d %d\n",&n,&m);
    //这里输入必须严格按照这种方式 
	//scanf("%d %d\n",&n,&m); 不写 \n 会炸 
	//每输入一行不读入 \n 会炸
	//因为读入字符 有一个'\n'（换行符） 而数字不会 
	for(int i=1;i<=n;i++,scanf("\n")) 
	  for(int j=1;j<=n;j++) {
	  	char c;
	  	scanf("%c",&c);
	  	if(c=='1') a[i][j]=1;		
	  }

	for(int i=1;i<=m;i++) {
		int x,y;
		scanf("%d %d",&x,&y);
		if(!vis[x][y]) ans[i]=1,bfs(x,y,i);
		else ans[i]=ans[vis[x][y]];
		printf("%d\n",ans[i]);
	}    
	
	return 0;
}
```


$END$
------------
**评测记录**：

$DFS$:[01迷宫DFS评测记录](https://www.luogu.org/recordnew/show/18747377)

$BFS$:[01迷宫BFS评测记录](https://www.luogu.org/recordnew/show/20235933)

~~警告已改正~~






---

## 作者：spsp23 (赞：1)

都说这道题要用并查集，

可看了半天题解中也没有并查集。

本蒟蒻就来一发并查集吧。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005][1005];//存值 
int e[1005][1005];//副图，有记录是否走过和记录父亲值的作用。 
int fa[1005][1005];//并查集
int n,m,maxe,xx,yy,ii,jj,i,j,xxx,yyy;
int x[]={0,1,0,-1};
int y[]={1,0,-1,0};
int dfs(int p,int q,int z){//p,q记录当前x,y坐标；z记录是0还是1；
	int ee=1;
	for(int k=0;k<4;k++){//四个方向
	  int xk=p+x[k],yk=q+y[k];
	  if(a[xk][yk]==(z^1)//是否可以走；  
	    && (e[fa[xk][yk]/1001][fa[xk][yk]%1001]==-1)yi
        //这个点是否属于已经搜过的并查集； 
	    && (xk<=n) && (xk>=1) && (yk<=n) && (yk>=1)){//边界；
	     fa[xk][yk]=i*1001+j,e[xk][yk]=0;
	     ee+=dfs(xk,yk,z^1);}	
	}
	  
    return ee;
}
int main(){
	memset(a,-1,sizeof(a));
	memset(e,-1,sizeof(e));
	scanf("%d%d",&n,&m);	
	for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)
        scanf("%1d",&a[i][j]),fa[i][j]=1001*i+j;//状态压缩；
    for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)
        if(e[fa[i][j]/1001][fa[i][j]%1001]==-1){
          e[i][j]=0;
		  e[i][j]=dfs(i,j,a[i][j]);	
		  }
   for(i=1;i<=m;i++){
      scanf("%d%d",&xx,&yy);
      xxx=fa[xx][yy]/1001;
      yyy=fa[xx][yy]%1001;
	  printf("%d\n",e[xxx][yyy]);}//输出时别忘了输出它父亲的值；
	return 0;
}
```
本蒟蒻是把一次搜索过的节点当成一个并查集；

这样就可以缩短因重复搜索，赋值而t;

速度还可以；

不当之处，请巨佬指出；

---

## 作者：huangx607087 (赞：1)

非STL党福利
这是我写的第二篇题解
典型的BFS

不多说，上代码，代码中有详细解释
```cpp
#include <bits/stdc++.h> 
using namespace std;
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0}; //4个方向 
int n,m,q[935000][2];//n和m，队列q，其中第二维0代表横坐标，1代表纵坐标 
int h[900000];//记录连通图,(并查集,h[1]表示第一个集合(也就是连通图)中的点数) 
char g[1035][1035];//输入0,1,由于中间没有空格,就用char了 
int v[1035][1035];//记录这个点是否被访问过,.v[a][b]的值就是ab这个点在第v[a][b]个图中,属于第v[a][b]个集合 
int T=0;	//现在正在处理第T个集合(连通图) 
int main()
{
	int i,j,k;
	scanf("%d%d",&n,&m);//输入 不多说 
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++) cin>>g[i][j];
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
		{
			if(!v[i][j])//如果i.j这个点还没有被访问过 ,那我们就开始吧! 
			{
				++T;//存入新的集合 
				int f=1,r=1;//队头和队尾 
				q[1][0]=i,q[1][1]=j;//初始点入队 
				v[i][j]=T;//标记这个点在第T个集合中 
				while(f<=r) 
				{
					int X=q[f][0],Y=q[f][1];//先存入这个点的坐标 
					for(k=0;k<4;k++)//4个方向枚举 
					{
						if(X+dx[k]<=n&&X+dx[k]>0&&Y+dy[k]<=n&&Y+dy[k]>0&&!v[X+dx[k]][Y+dy[k]]&&g[X][Y]!=g[X+dx[k]][Y+dy[k]])
						{
							//这个点没出界并且这个点还没被访问过
							//在这里注意一下,一旦访问过一个点,必定就是结果,因为这是连通图,(集合)
							//可以证明每个点只能属于一个集合
							/*
							for example:
							证明 
							假如某个点 既属于1集合，又属于 2集合
							那么1,2集合中的点可以相互到达
							1,2集合是同一个集合 
							*/ 
							q[++r][0]=X+dx[k];//这个点入队 
							q[r][1]=Y+dy[k];
							v[q[r][0]][q[r][1]]=T;//记录这个点是第T个集合 
						}
					} 
					++f;//搜索下一个,.队头+1(push我不会用,我是非STL党) 
				}
				h[T]=r;//所以综上,这个集合内有r个点!不是f!这是队列为空,我设置的f=r+1 
			}
		}
	for(i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);//分别输入xy，开始询问 
		printf("%d\n",h[v[x][y]]);//查找xy这个点属于第v[x][y]个集合，第v[x][y]个集合里有h[v[x][y]] 个点，直接输出即可 
	}
	return 0;
}

```
最后祝愿自己能在2019年AKNOIP~~(苦逼的自己是江苏高考最后一届，无法复读)~~

---

## 作者：zhengrunzhe (赞：1)

~~裸的图论题~~

### 题意：n*n01矩阵，上下左右0->1 1->0 m次询问求(x,y)所在的连通块点数

连通块就用tarjan求强连通分量解决好了

点(x,y)转化为编号(x-1)*n+y，二维转一维

scc[x]表示编号为x的点所在的强连通分量编号

size[c]表示编号为c的强连通分量的大小

然后套模板就好了，每次询问输出size即可

建边复杂度O(4*n²)，tarjan复杂度O(5n²)，询问复杂度O(m)
```cpp
#include<stack>
#include<cstdio>
#include<utility>
#include<algorithm>
#define id(x,y) (x-1)*n+y //二维坐标转一维编号
#define exist(x,y) x&&x<=n&&y&&y<=n //判断越界
using namespace std;
const int N=1e3+10,S=N*N;
const short fx[4]={-1,1,0,0},fy[4]={0,0,-1,1};
int n,m;
char map[N][N];
int head[S],cnt;
pair<int,int>e[S<<2]; //每个点最多能往上下左右建四条边，边的数组要开4n²
inline const void addedge(int u,int v)
{
	e[++cnt]=make_pair(v,head[u]);
	head[u]=cnt;
}
stack<int>s;
int dfn[S],low[S],scc[S],size[S],tot;
inline const void tarjan(int u)
{
	int v;low[u]=dfn[u]=++cnt;s.push(u);
	for (int i=head[u];i;i=e[i].second)
		if (!dfn[v=e[i].first])tarjan(v),low[u]=min(low[u],low[v]);
		else if (!scc[v])low[u]=min(low[u],dfn[v]);
	if (low[u]!=dfn[u])return;tot++;
	do v=s.top(),s.pop(),size[scc[v]=tot]++;while (u^v);
}
inline const void tarjan()
{
	cnt=0;
	for (int i=1;i<=n*n;i++)
		if (!dfn[i])
			tarjan(i);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			scanf(" %c",&map[i][j]);
	int x,y;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			for (int k=0;k<4;k++)
				if (x=i+fx[k],y=j+fy[k],exist(x,y)&&map[i][j]^map[x][y])
					addedge(id(i,j),id(x,y));
	tarjan();
	while (m--)
		scanf("%d%d",&x,&y),
		printf("%d\n",size[scc[id(x,y)]]);
	return 0;
}
```

---

## 作者：Meatherm (赞：1)

（忙人请跳过分割线内的部分）

================分割线===================

在故事开始之前，我要给大家讲一个故事。

从前，有一个蒟蒻。他不会BFS，题解也写的令他懵逼。于是，他决定--写题解！


================分割线===================


好的各位朋友，现在，题解正式开始。

我的题解跟其他人想法差不多，就是搜联通块。**一个联通块内的格子能到达的格子数是相等的。**（好好想想）假设A格子只能到达B格子和C格子，则B只能到达A/C，C只能到达A/B。

**每一次DFS，则会搜出一个完整的联通块，我们给这个联通块的每一个格子打上一个专属于这个联通块的标记。**再设立一个数组，表示每个联通块的标记代表的值（**即能到达的格子数**）。

于是询问时，只需要输出询问格子的标记所代表的值。

时间复杂度:$O(2^n)$。

下面贴代码，会进行更加详细的注释。

```
# include <bits/stdc++.h>//万能头文件不解释
using namespace std;
char a[1001][1001];//保存地图
int n,m;//如题目所述
bool vst[1001][1001];//判断是否访问（避免死搜出不来）
int ls[1000323];//数组要开大一点！ls保存每一个标记对应的格子数
int lian[1001][1001];//标记
int sum,liansum;//sum是本次搜索（即当前联通块）的格子数量，liansum是当前联通块数量
int fx[5]={2,1,-1,0,0};
int fy[5]={2,0,0,-1,1};//方便搜索
void dfs(int x,int y)//DFS
{
	if(x<1||x>n||y<1||y>n)return;//检查越界
	sum++;//当前联通块的格子数量增加
	vst[x][y]=true;//当前的格子访问过了
	lian[x][y]=liansum;//打标记
	for(int i=1;i<=4;i++)//搜索相邻四格
		if(a[x+fx[i]][y+fy[i]]!=a[x][y]&&!vst[x+fx[i]][y+fy[i]])//判断
			dfs(x+fx[i],y+fy[i]);//继续搜索
	return;//好习惯
}
int main()//主函数
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);//优化I/O常数（C++流）
	cin>>n>>m;//
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
			cin>>a[i][j];//读入地图
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=n;j++)
		if(!vst[i][j])//从第一个格子开始搜联通块
		{
			++liansum;//当前联通块++
			sum=0;//清零，为本次搜索做准备
			dfs(i,j);//从当前格子开始搜
			ls[liansum]=sum;//保存这个联通块标记对应的格子数量
		}
	int t1,t2;
	for(register int i=1;i<=m;i++)
		cin>>t1>>t2,cout<<ls[lian[t1][t2]]<<"\n";//\n是换行符。只需输出询问格子的标记所代表的值即可。
	return 0;//好习惯
}
```

感谢您的阅读。请勿直接抄袭代码。如果本篇题解有不足之处，请在评论区指出或私信我。最后，贴出[我的博客](https://www.luogu.org/blog/108949/)！

---

## 作者：CodinPnda (赞：1)

## 前言
作为一个小蒟蒻，这道01迷宫真的是打得我快死。不过总算是做出来了，于是我决定发题解纪念一下（撒花~）
## 思路
这道题实际上思路并不会很难，但是代码实现起来极其麻烦（至少对于我这种蒟蒻来说）。
我一开始直接针对每一次查询进行一次广搜，毫无意外，直接崩掉QAQ，于是我就稍微想了一下，发现对于任意一个格子s1，如果从s1出发，能够到达另外一个格子s2，那么从s2出发，也一定能到达s1，同理可得，从s1出发能够到达的所有点，从s2也能够到达。

于是这道题的思路就非常清晰了。

定义查询quiry:=dfs(x, y)，dfs(x, y)用于查询从坐标为(x, y)的格子出发，能到达多少个格子。

首先，我们创建一个队列q用于存放所有的查询，然后在每次从队列中取出一个查询(x0, y0)，判断该查询是否已经有答案，如果没有，就进行一次广搜，广搜过程中如果到达一个同样在查询队列中的格子，那么将其存入一个临时数组。广搜完毕后，将临时数组中的所有查询的答案都设置为dfs(x0, y0)，并把这些查询全部做一次标记，表明它们已经有了答案。

## 一点小小的优化
一开始我虽然有了思路，但是还是不知道代码应该怎么写（毕竟是个蒟蒻QAQ），想了很久才想出来。为了各位不要掉坑里，于是我把几个可以优化的点也说出来吧

1、每次广搜完之后，不需要复原地图，因为下一次广搜一定不会到达这次广搜能搜到的格子。

2、把答案存在地图上（相信我，这会省掉你一大堆时间）

## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int q[100001][2], map[1001][1001][3], qi[1000001][2];
int qr=1, n, m, temp1 = 1, value1;
int jg[100001][2];
char temp[1001];

int gs(int i, int j){
    int front = 1, rear = 2, k[2], value;
    qi[1][0] = i;
    qi[1][1] = j;
    jg[temp1][0] = i;
    jg[temp1++][1] = j;
    
    while(front < rear){
        k[0] = qi[front][0];
        k[1] = qi[front++][1];
        map[k[0]][k[1]][1] = 2; 
        value = map[k[0]][k[1]][0];
        if(map[k[0]][k[1]+1][0] != value && map[k[0]][k[1]+1][1] != 2 && k[1]+1 <= n && k[1]+1 > 0){
            qi[rear][0] = k[0];
            qi[rear++][1] = k[1]+1;
            if(map[k[0]][k[1]+1][1] == 1){
                jg[temp1][0] = k[0];
                jg[temp1++][1] = k[1]+1;
            }
            map[k[0]][k[1]+1][1] = 2;
        }
        if(map[k[0]][k[1]-1][0] != value && map[k[0]][k[1]-1][1] != 2 && k[1]-1 <= n && k[1]-1 > 0){
            qi[rear][0] = k[0];
            qi[rear++][1] = k[1]-1;
            if(map[k[0]][k[1]-1][1] == 1){
                jg[temp1][0] = k[0];
                jg[temp1++][1] = k[1]-1;
            }
            map[k[0]][k[1]-1][1] = 2;
        }
        if(map[k[0]-1][k[1]][0] != value && map[k[0]-1][k[1]][1] != 2 && k[0]-1 <= n && k[0]-1 > 0){
            qi[rear][0] = k[0]-1;
            qi[rear++][1] = k[1];
            if(map[k[0]-1][k[1]][1] == 1){
                jg[temp1][0] = k[0]-1;
                jg[temp1++][1] = k[1];
            }
            map[k[0]-1][k[1]][1] = 2;
        }
        if(map[k[0]+1][k[1]][0] != value && map[k[0]+1][k[1]][1] != 2 && k[0]+1 <= n && k[0]+1 > 0){
            qi[rear][0] = k[0]+1;
            qi[rear++][1] = k[1];
            if(map[k[0]+1][k[1]][1] == 1){
                jg[temp1][0] = k[0]+1;
                jg[temp1++][1] = k[1];
            }
            map[k[0]+1][k[1]][1] = 2;
        }
        
    }
    return front-1;
}

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> temp;
        for(int j = 1; j <= n; j++) map[i][j][0] = (int)(temp[j-1] - '0');
        for(int j = 0; j < n; j++) temp[j] = ' ';
    }
    for(int i = 1; i <= m; i++) cin >> q[i][0] >> q[i][1];
    for(int i = 1; i <= m; i++) map[q[i][0]][q[i][1]][1] = 1;

    while(qr <= m){
        if(map[q[qr][0]][q[qr][1]][2] != 0){qr++;continue;}
        value1 = gs(q[qr][0], q[qr][1]);
        for(int i = 1; i < temp1; i++){
            map[jg[i][0]][jg[i][1]][2] = value1;
        }
        qr++;
        temp1 = 1;
    }
    for(int i = 1; i <= m; i++){
        cout << map[q[i][0]][q[i][1]][2] << endl;
    }
    return 0;
}
```
懒得写注释，将就着看一下吧QAQ

---

## 作者：Nugine (赞：1)

## 题目描述

有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻4格中的某一格11上，同样若你位于一格1上，那么你可以移动到相邻4格中的某一格0上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

[此处题面链接](https://www.luogu.org/problem/show?pid=P1141)

## 思路

显然，题目要求我们对于给定的图求联通块大小，用DFS或并查集可过。

+ DFS+记忆化
  
    这种做法要求询问时进行DFS，有点惰性求值的意思，然而我不想写。。。

+ 并查集

    两次预处理，分别对横向和竖向进行union操作。

    在预处理时，每次查根的时间近似O(1)。

    预处理时间复杂度O(n^2)。

    对于每个查询，消耗时间近似O(1)，总时间复杂度O(m)。

    估测一下，总时间大约是 2 * (1e3) ^ 2 + 1e5，即1e6的数量级，可行。

## AC代码

```C++
#include <iostream>
using namespace std;

#define rep(i, s, e) for (i = s; i < e; ++i)
const int N = 1000 + 2;

struct Set {
    Set *root;
    int num;
    char value;
} maze[N][N];

Set *root(Set *p) {
    if (p->root == p)
        return p;
    Set *r = p->root;
    if (r->root == r)
        return r;
    return p->root = root(r);
}

void merge(Set *r1, Set *r2) {
    if (r1 == r2)
        return;
    r2->root = r1;
    r1->num += r2->num;
}

int n;

void init() {
    int i, j;
    Set *p;

    rep(i, 0, n) {
        rep(j, 0, n) {
            p = &maze[i][j];
            cin >> p->value;
            p->root = p;
            p->num = 1;
        }
    }

    Set *pu, *pl;

    rep(i, 1, n) {
        rep(j, 0, n) {
            pu = &maze[i - 1][j];
            p = &maze[i][j];
            if (pu->value != p->value) {
                merge(root(pu), root(p));
            }
        }
    }

    rep(i, 0, n) {
        rep(j, 1, n) {
            pl = &maze[i][j - 1];
            p = &maze[i][j];
            if (pl->value != p->value) {
                merge(root(pl), root(p));
            }
        }
    }
}

int main() {
    // ios::sync_with_stdio(false);
    int m, i, j;
    cin >> n >> m;

    init();

    // rep(i, 0, n) {
    //     rep(j, 0, n) { cout << maze[i][j].num << ' '; }
    //     cout << endl;
    // }

    while (m--) {
        cin >> i >> j;
        cout << root(&maze[i - 1][j - 1])->num << endl;
    }
    return 0;
}

```

## 细节

查询中输入的i,j不是数组下标，需要-1.

用getchar和putchar会谜之RE，我选择死亡。

没关标准流同步不会TLE。

不要忘记注释掉调试代码。。。

---

## 作者：AllenChuQAQ (赞：1)

我就很纳闷，为什么标签明明是**DFS**却在试炼场里面放到了**广度优先搜索**总之，用DFS总是没问题的。  

---
主要用的思路就是
1. 输入（其实代码中的int可以改为bool）
2. 生成全对的比对数组（对照组）好好配合程序，理解理解
3. 深搜（四个方向都搜一次，同时还要满足你0和1）
4. 输出  

没错，就是这么的简单。半点优化都不要就可以AC。  
~~香喷喷的~~代码呈上

---
```cpp
//LuoGu 1141
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;
int map[1001][1001], m, n, _1_map [1001][1001], _2_map [1001][1001], cur_p = 2, x, y, c__1_map[1001][1001], c__2_map[1001][1001],sum;
vector<int> value;
char in[1001];
int DFS(int _x, int _y, int mode)//如果mode == 1，就说明你要挪到一个数字为1的方格上面，反之同理
{
    if (_x >= 0 && _y >= 0 && _x < n && _y < n)//边界
    {
        if (mode == 1)//判断数字了呵（敲黑板）
        {
            if (_1_map[_x][_y] == 0)
            {
                return sum;
            }
            else if (_1_map[_x][_y] == 1)
            {
                _1_map[_x][_y] = cur_p;//四周DFS
                DFS(_x + 1, _y, 1);
                DFS(_x - 1, _y, 1);
                DFS(_x, _y + 1, 1);
                DFS(_x, _y - 1, 1);
                sum++;
                return sum;
            }
            else
            {
                return sum;
            }
        }
        else if (mode == 2)//同上
        {
            if (_2_map[_x][_y] == 0)
            {
                return sum;
            }
            else if (_2_map[_x][_y] == 1)
            {
                _2_map[_x][_y] = cur_p;
                DFS(_x + 1, _y, 2);
                DFS(_x - 1, _y, 2);
                DFS(_x, _y + 1, 2);
                DFS(_x, _y - 1, 2);
                sum++;
                return sum;
            }
            else
            {
                return sum;
            }
        }
        else 
        {
            return sum;
        }
    }
    else 
    {
        return sum;//以免万一，其实没有啥事都不会发生
    }
}
int main()
{
    value.push_back(-1);//从1开始是个好习惯
    value.push_back(-1);
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        cin >> in;
        for (int j = 0; j < n; j++)
        {
            map[i][j] = in[j] - '0';
        }
    }
    for (int i = 0; i < n; i++)//生成全对的两种可能的样例，直接来进行对比就好了(敲黑板，全程序的精髓）该记得记一记啊～～
    {
        for (int j = 0; j < n; j++)
        {
            if (map[i][j] == (i + j) % 2)
            {
                _1_map[i][j] = true;
                _2_map[i][j] = false;
            }
            else 
            {
                _1_map[i][j] = false;
                _2_map[i][j] = true;
            }
        }
    }
    memcpy(c__1_map, _1_map, n * 1001 * 4);//copy * 1
    memcpy(c__2_map, _2_map, n * 1001 * 4);//copy * 2
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            sum = 0;
            if (_1_map[i][j] == 1)
            {
                value.push_back(DFS(i, j, 1));//直接记值
                cur_p++;
            }
            else if (_2_map[i][j] == 1)
            {
                value.push_back(DFS(i, j, 2));//直接记值
                cur_p++;
            }
        }
    }
    for (int i = 0; i < m; i++)//输出即可
    {
        cin >> x >> y;
        if (_1_map[x - 1][y - 1] >= 2)
        {
            cout << value[_1_map[x - 1][y - 1]] << endl;
        }
        else if (_2_map[x - 1][y - 1] >= 2)
        {
            cout << value[_2_map[x - 1][y - 1]] << endl;
        }
    }
    return 0;
}
```

---

## 作者：JustinRochester (赞：1)

**【吐槽】**
------------

本蒟蒻觉得这题应该BFS就可以直接过了吧...

感觉题解区的其他人都是大犇，我都根本没想到那么多...

------

**【分析】**
-----------

题目中很显然n的范围比较小，而m的范围比较大。所以不可能对于每次询问都进行查询，只得一开始就算好，然后对于每次询问直接输出答案。(如果对于每次查询都进行一次计算，计算时间为O(n^2)，总时间为O(m*n^2)，绝对炸)

于是一定在查询前就得计算好，然后直接输出。

接着，我们分析每步最多移动多少个位置:

如果存在点P、Q、R，P、Q相连，Q、R相连，P^Q==1，Q^R==1，则三个块的步数都是3(暂不考虑其他点)。

以此类推，从任意一点P开始，则所有与P相邻的、值异或的点最后能达到的步数都是一样的。而步数则可以视为从P开始能拓展的最大面积。

你会很巧妙地发现:计算步数的方法和BFS完全一样。

因此，我们就对每个点进行是否访问过标记，如果相邻点中有满足值异或且还未访问过的点，则加入队列中。(避免一个点被计算多次)访问的最大步数即是加入该队列中的点的个数。

那么一个及其简(bao)单(li)的算法模型就构造出来了:

首先，对迷宫进行输入

其次，对于每个没访问过的点，拓展它的面积，并将沿途的点和它的步骤都更新为最大面积

最后，只要对于每次询问都输出答案即可

------

**【代码】**
------------

那本蒟蒻就放代码了:

```cpp
#include<cstdio>
#include<cctype>
#include<queue>
using namespace std;
int n,pace[1002][1002]={0};
//只有步数才是我们需要的，那其他就没必要存为全局变量了
int read(){
	int abs=0;char c=getchar();
    while(!isdigit(c)) c=getchar();
	while(isdigit(c)) abs=abs*10+c-'0',c=getchar();
	return abs;
}//读入优化(介于询问那么多次...)
void getpace(){
	int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
    //移动方式
	char c=getchar();
	bool map[1002][1002],can[1002][1002]={0};
    //map存迷宫
    //can==1表示还未访问过，否则已经访问或走不通(边界)
	for(int i=0;i<n*n;i++){
		while(c!='1'&&c!='0') c=getchar();
		map[i/n+1][i%n+1]=(c=='1');
        //输入为1时存为1，否则存为0
		can[i/n+1][i%n+1]=1;
		c=getchar();
	}
	for(int i=0;i<n*n;i++){
		if(!can[i/n+1][i%n+1]) continue;
        //已经访问过，则不必计算其步骤了
        //在别的点的沿途上计算过了
		int tot=0;//计算步骤
		queue<int> qx,qy,rx,ry;
		qx.push(i/n+1);
        qy.push(i%n+1);
        can[i/n+1][i%n+1]=0;
		while(qx.size()){
			tot++;
			int x=qx.front(),y=qy.front();
			rx.push(x);//rx中存沿途的点的x
            ry.push(y);//同上
			qx.pop();
            qy.pop();
			for(int j=0;j<4;j++){
				int nx=x+dx[j],ny=y+dy[j];
				if(can[nx][ny]&(map[nx][ny]^map[x][y])){
                //该点满足拓展条件
                	qx.push(nx);
                    qy.push(ny);
                    can[nx][ny]=0;
                }
                
			}
		}
		while(rx.size()){
			pace[rx.front()][ry.front()]=tot;
			rx.pop();ry.pop();
		}//更新步数
	}
}
int main(){
	n=read();int m=read();
	getpace();
	while(m--) printf("%d\n",pace[read()][read()]);
	return 0;
}
```

---

## 作者：Esuan24 (赞：1)

我与楼下某位大佬的错误原因大概是一样的，就是每次bfs后memset了下bool数组，然后，卒。

当我翻翻题解发现。。。居然没一个人写洪水填充的思路，所以我这个蒟蒻就屁颠屁颠跑过来写个题解。

我的思路是先用bfs遍历n\*m的矩阵来求出从这一步出发，记录每一个**能被覆盖的点**，然后用一个栈和一个scc数组来记录这个点所在的scc（连通块）；然后在遍历时，如果发现这个点已经在某个scc中，就走下一个点。话不多说，上代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
queue<int> q;
stack<int> s;
int n,scc[1001][1001],m,a1[100001],b1[100001],m1;
bool vis[1001][1001],b[1001][1001];
int dx[4]= {-1,0,1,0},dy[4]= {0,1,0,-1};
string c;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
inline bool pd(int x,int y) {
    if(x<1||x>n)return 0;
    if(y<1||y>n)return 0;
    if(vis[x][y])return 0;
    return 1;
}
inline void bfs(int a2,int b2) {
    q.push(a2);
    q.push(b2);
    vis[a2][b2]=1;
    int x,y,step=1;
    while(!q.empty()) {
        x=q.front();
        q.pop();
        y=q.front();
        q.pop();
        s.push(y);
        s.push(x);
        for(int i=0; i<4; i++) {
            int x1=x+dx[i],y1=y+dy[i];
            if(!pd(x1,y1)||(b[x][y]==b[x1][y1]))continue;
            q.push(x1);
            q.push(y1);
            vis[x1][y1]=1;
            ++step;
        }
    }
    int ans=step,x1=0,y1=0;
    while(!s.empty()) {
        x1=s.top();
        s.pop();
        y1=s.top();
        s.pop();
        scc[x1][y1]=ans;
    }
}
int main() {
    n=read();m=read();
    for(re int i=1; i<=n; i++) {
        cin>>c;
        m1=c.size();
        for(int j=0; j<m1; j++)
            b[i][j+1]=c[j]-'0';
    }
    for(re int i=1; i<=m; i++) {
        a1[i]=read(),b1[i]=read();
    }
    for(re int i=1; i<=n; i++) {
        for(re int j=1; j<=n; j++) {
            if(!scc[i][j]) {
                bfs(i,j);
            }
            //cout<<scc[i][j];
        }
        //cout<<endl;
    }
    //cout<<endl;
    for(re int i=1; i<=m; i++)
        if(scc[a1[i]][b1[i]])cout<<scc[a1[i]][b1[i]]<<endl;
        else cout<<0<<endl;
    return 0;
}
```

---

## 作者：ZZY彧 (赞：1)

如果普通的搜索，会超时

所以要用到记忆化搜索

如果一个点被扩展过，那么它的值就是起点的值


接下来，我们将借用程序给大家分析

标程——（by：楼元培、张喆彧）

const e:array[1..4,1..2] of longint=((-1,0),(0,-1),(1,0),(0,1));

```cpp
var a,f:array[0..1000,0..1000] of char;
f1:array[0..1000,0..1000] of boolean;
d:array[0..1000,0..1000] of longint;  //d数组表示
b,c:array[0..1000000] of longint;
i,j,n,m,x,y:longint;
procedure sc(x,y:longint);  //宽搜程序
 var t,w,x1,y1,i,sum:longint;
  begin
   t:=1;w:=1;b[t]:=x;c[t]:=y;sum:=0;f1[x,y]:=true;
   if d[x,y]<>-1 then exit;
   while t<=w do
    begin
    inc(sum);
     for i:=1 to 4 do
      begin
       x1:=b[t]+e[i,1];
       y1:=c[t]+e[i,2];
       if (x1>=1) and (y1>=1) and (x1<=n) and (y1<=n) and (f1[x1,y1]=false) then  //判断有没有越界和有没有做过
       case a[b[t],c[t]] of
        '0': if a[x1,y1]='1' then  //如果上一个点为0，那么这个点必须为1
             begin
             w:=w+1;
             b[w]:=x1;
             c[w]:=y1;
             f1[x1,y1]:=true;
             end;
        '1': if a[x1,y1]='0' then  //如果上一个点为1，那么这个点必须为0
             begin
             w:=w+1;
             b[w]:=x1;
             c[w]:=y1;
             f1[x1,y1]:=true;
             end;
        end;
       end;
       a[b[t],c[t]]:='2';
      t:=t+1;
     end;
     for i:=1 to w do
      d[b[i],c[i]]:=sum;  //记忆化
   end;
 begin
  readln(n,m);
  fillchar(d,sizeof(d),255);
  for i:=1 to n do
   begin
    for j:=1 to n do
     read(a[i,j]);
    readln;
   end;
   f:=a;
   for i:=1 to n do
     for j:=1 to n do sc(i,j);  //每个点都搜一遍
  for i:=1 to m do
   begin
    readln(x,y);
    writeln(d[x,y]);
   end;
end.
```

---

## 作者：Toxic_Obsidian (赞：1)

这道题题解没有仔细研究过（因为太多了）QAQ

然而DFS是坠吼的（吼吼），于是，我研究出来一种O(n^2+m)的方法（不知道有没有dalao发过）

简单来说就是枚举所有节点，如果没有访问过，就压入队列，然后DFS这个节点求联通块。

当这个节点调用的DFS全部返回以后，就让整个队列里的元素的CAN\_VIS=队列的size()。


然后查询的时候直接对于每个点都是O(1)，加起来就是O(m)啦，总的复杂度就是O(n^2+m)。


思路讲的差不多，下面附上源码


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <vector>
#include <string>
using namespace std;
const int maxn=1000+10;

struct nood{
    int x,y;
};

bool graph[maxn][maxn];
bool vis[maxn][maxn];
int cn[maxn][maxn];
int n,m;
int x,y;
queue<nood> q;

void opr(const int& i,const int& j){                ///这里是萌萌的DFS函数
    if(i==0||i==n+1||j==0||j==n+1) return;        ///界限
    q.push((nood){i,j});                                  ///调用函数时此节点是没有被访问过的，可以直接push了
    vis[i][j]=true;
    if(!vis[i+1][j] && graph[i+1][j]!=graph[i][j]) opr(i+1,j);
    if(!vis[i-1][j] && graph[i-1][j]!=graph[i][j]) opr(i-1,j);
    if(!vis[i][j+1] && graph[i][j+1]!=graph[i][j]) opr(i,j+1);
    if(!vis[i][j-1] && graph[i][j-1]!=graph[i][j]) opr(i,j-1);
}



int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){                        ///这里我用的是string输入，我在自己电脑上调试时用getchar()会读入m后的换行符
        string s;
        cin>>s;
        for(int j=0;j<n;j++){
            graph[i][j+1]=s[j]-'0';
        }
    }

    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(!vis[i][j]&&!graph[i][j]){
                opr(i,j);
                int s=q.size();
                while(!q.empty()){              ///不用担心q未被清空
                    nood tmp=q.front();
                    cn[tmp.x][tmp.y]=s;
                    q.pop();
                }
            }
        }
    }

    for(int i=1;i<=m;i++){
        cin>>x>>y;
        cout<<cn[x][y]<<endl;
    }

    return 0;
}
```

---

## 作者：XZYQvQ (赞：1)

此题搜索。。。

对于在一个联通块里的点，它们的答案相同。

所以标记不同颜色。

选定一个点，从这个点dfs遍历到的点全部设为一个颜色，并且把这个点设置为该颜色的根节点，并把根节点的答案设置为刚刚dfs遍历到的节点数量。


对于每次查询，我们根据这个点的颜色，找到该颜色的根节点，输出根节点的答案即可。


代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
bool inb(bool&dig){char c=getchar();while(!isdigit(c))c=getchar();dig=c-'0';}
int n,m,ans[1005][1005],col[1005][1005],ch[1000005],cw[1000005],cnt;
bool mp[1005][1005];
int dfs(int h,int w)
{
    if(h<1||w<1||h>n||w>n)return 0;
    if(col[h][w])return 0;
    if(ans[h][w])return ans[h][w];
    ans[h][w]=1,col[h][w]=cnt;
    if(mp[h][w]^mp[h-1][w])ans[h][w]+=dfs(h-1,w);
    if(mp[h][w]^mp[h+1][w])ans[h][w]+=dfs(h+1,w);
    if(mp[h][w]^mp[h][w-1])ans[h][w]+=dfs(h,w-1);
    if(mp[h][w]^mp[h][w+1])ans[h][w]+=dfs(h,w+1);
    return ans[h][w];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)inb(mp[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(!col[i][j])cnt++,dfs(i,j),ch[cnt]=i,cw[cnt]=j;
    for(int i=1,a,b;i<=m;i++)
        scanf("%d%d",&a,&b),printf("%d\n",ans[ch[col[a][b]]][cw[col[a][b]]]);
    return 0;
}
```

---

## 作者：mingx1 (赞：1)

正正经经的并查集+DFS，比较死板，不过也比较好理解。

看了楼下的几位方法都不是正规并查集，（当然代码确实比我这个简单一些）

所以我来发一个

并查集部分的源码来自于




```cpp
http://blog.csdn.net/sysucph/article/details/7263010
#include<iostream>
#include<cstring>
#include<string>
using namespace std;
struct father（记录每个点的父节点）
{
    int x,y;
} ;
father fa[1005][1005];
int num[1005][1005];
int n,m,x,y;
int a[1005][1005];
bool visit[1005][1005];（是否被访问过）
int dx[4]={1,-1,0,0};int dy[4]={0,0,1,-1};
father find(father t)（递归查找父节点并进行路径压缩）
{
     if(fa[t.x][t.y].x!=t.x && fa[t.x][t.y].y!=t.y)
      fa[t.x][t.y]=find(fa[t.x][t.y]);
      return fa[t.x][t.y];
}
void dfs(int x,int y)（深度优先搜索部分）
{
    visit[x][y]=1;
    num[fa[x][y].x][fa[x][y].y]++;
    for(int i=0;i<4;i++)
        {
            if(!visit[x+dx[i]][y+dy[i]] && a[x+dx[i]][y+dy[i]]+a[x][y] == 1)
            {        
                 fa[x+dx[i]][y+dy[i]]=find(fa[x][y]);
                dfs(x+dx[i],y+dy[i]);
            }
        }
}
int cou(int x,int y)（这个函数其实没啥用，只是让主函数显得短一点）
{
    if(fa[x][y].x==0 && fa[x][y].y==0)
        {
            fa[x][y].x=x;
            fa[x][y].y=y;
            dfs(x,y);
        }
    return num[fa[x][y].x][fa[x][y].y];
}
int main()
{
    memset(a,1,sizeof(a));
    string s[1005];（原谅本人不是竞赛党，只是个大一的喳喳，学的只是老师教的c++，所以gets（）什么的函数都不会用..所以用了这种很蠢的办法.）
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
        for(int j=1;j<=n;j++)
            a[i][j]=s[i][j-1]-'0';
    }
    for(int i=1;i<=m;i++)
    {
        cin>>x>>y;
        cout<<cou(x,y)<<endl;
    }
}
```

---

## 作者：fl_334 (赞：1)

一看这题就是裸裸的搜索呵






```cpp
const xx : array[1..4, 1..2] of integer = (
        (-1, 0), (0, -1), (1, 0), (0, 1)
    );
type fx = record
    x, y : longint;
end;      //横纵下标
var
    n, m, i, j, k, count, x, y: longint;
    a : array[1..1000, 1..1000] of char;
    used : array[1..1000, 1..1000] of boolean;
    f : array[1..1000, 1..1000] of longint;
    q : array[1..1000000] of fx;
    xy: fx;
function ok(x, y:longint): boolean;
begin
    if ( x >= 1 ) and ( x <= n ) and (y >= 1) and (y<=n) then exit(true);
    exit(false);
end;
procedure dfs(x, y:longint);
var
    xy : fx;
    i : longint; 
begin
    //writeln('x:',x,',y:',y,',count:',count);
    for i:=1 to 4 do
    begin
        if ok(x + xx[i, 1], y + xx[i, 2]) and ( not used[x + xx[i, 1], y + xx[i, 2]] ) and (a[x, y] <> a[x +xx[i, 1], y + xx[i, 2]] ) then
        begin
            used[x + xx[i, 1], y + xx[i, 2]] := true;
            inc(count);
            xy.x := x + xx[i, 1];
            xy.y := y + xx[i, 2];
            q[count] := xy;
            dfs(x + xx[i, 1], y + xx[i, 2]);
        end;
    end;
end;
begin
    count := 1;
    fillchar(used, sizeof(used), false);
    readln(n, m);
    for i:=1 to n do
    begin
        for j:=1 to n do
        begin
            read(a[i, j]);
        end;
        readln;
    end;
    for i:=1 to n do
        for j:=1 to n do
        begin
            if not used[i, j] then 
            begin
                //初始化
                count := 1;        //初始化
                xy.x := i;
                xy.y := j;
                q[count] := xy;
                used[i, j] := true;
                //搜索
                dfs(i, j);
                //填值
                for k:=1 to count do
                begin
                    f[q[k].x, q[k].y] := count;              //把一个01区域内的填值
                end;
            end;
        end;
    for i:=1 to m do
    begin
        readln(x, y);
        writeln(f[x, y]);      
    end;
end.
```

---

## 作者：mollnn (赞：1)

**本程序采用先刷len表，然后直接查表的方式。可以在限定时间内通过。对于部分不完全数据，一边查表一边刷表的完全记忆方式可能更快。注释足够详尽。**

```cpp
/////////////////////////
// 0-1 Maze Solution (C++)
//   (lg) 1141.cpp
//  Author: Mollnn.F
/////////////////////////
// 0-1迷宫 解决方案 (C++)
//       洛谷1141
//     作者：Mollnn.F
//  完全注释版 
/////////////////////////
// 注意
// 1.本程序中使用了全局变量、STL库和宏。 
//   您可能不习惯使用以上技术方法。 
// 2.本程序采用先刷len表，然后直接查表的方式。
//   对于部分不完全数据，一边查表一边刷表的
//   完全记忆方式可能更快。
///////////////////////// 
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
using namespace std;
/////////////////////////
```
/\* 全局变量定义 \*/

```cpp
int n,m; //数目 
int si,sj; //用于临时保存起点 
char map[1005][1005],used[1005][1005];//0-1记录图和访问记录 
int len[1005][1005];//从当前点能走的最大长度 
```
/\* 访问点管理 \*/
vector <int>v; //单向容器，用于储存这一次访问过的点

#define geti(x) x/10000 // 宏，用于从int坐标和中分离出i,j


    
    

```cpp
#define getj(x) x%10000 // 同上 
/////////////////////////
// 深搜函数 
int dfs(int i,int j) //当前点的i,j 
{
    char ck=!map[i][j]; //check，标识这一次要寻找的点的0-1值 
    v.push_back(i*10000+j);//访问了这个点，将其推到容器中 
    int cnt=1;//访问计数器，1代表自身点 
    used[i][j]=1;//置位，将自身设置为已经被访问 
    //以下if语句，前两个条件为越界检查，3是检查是否走过
    //  4是检查0-1值是否符合条件，全部通过就进一步搜索 
    // 四句话分别是四个方向，不多解释 
    if( i-1>=0 && i-1<n&& used[i-1][j]==0 && map[i-1][j]==ck )
        cnt+=dfs(i-1,j);
    if( i+1>=0 && i+1<n&& used[i+1][j]==0 && map[i+1][j]==ck )
        cnt+=dfs(i+1,j);
    if( j-1>=0 && j-1<n&& used[i][j-1]==0 && map[i][j-1]==ck )
        cnt+=dfs(i,j-1);
    if( j+1>=0 && j+1<n&& used[i][j+1]==0 && map[i][j+1]==ck )
        cnt+=dfs(i,j+1);
    //注意这里与多数深搜的差别，因为每个点只要碰一次，所以无需把used复位 
    return cnt;
}
int main()
{
    scanf("%d%d",&n,&m); //输入总数 
    int i,j,l,tmp,st; //i,j,l循环变量
    // st用于临时记录dfs的结果
    // tmp用于临时储存pop出来的坐标 
    for(i=0;i<n;i++)
    {
        scanf("%s",&map[i]); //输入矩阵 
        for(j=0;j<n;j++)
            map[i][j]-='0'; //因为是字符，所以要-'0' 
    }
    memset(len,0,sizeof(len)); //初始化len数组
    //遍历每一个点来确定len 
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            if(len[i][j]==0) //如果没有设置过len，就dfs 
            {
                st=dfs(i,j); //开始深搜 
                while(!v.empty()) //遍历这一次访问的所有点 
                {
                    tmp=v[v.size()-1]; //取出坐标 
                    len[geti(tmp)][getj(tmp)]=st; //设置len 
                    v.pop_back(); //删除这个点 
                }
            }
        }
    }
    for(i=0;i<m;i++)
    {
        scanf("%d%d",&si,&sj); //输入坐标 
        printf("%d\n",len[--si][--sj]); //输出len值 
    }
    return 0;
}
```

---

## 作者：plazum (赞：1)

注意到，能够互相到达的点的能够到达的点数是一样多的，这样整个棋盘就像是分成了许多块，每一块中的点给出的答案都是一样的，这样就可以用一张表保存棋盘上每个点能够到达的点数，每次搜索后把当前搜索走过的所有点在表上记录答案，下次查询到这一块的点时就不用重新搜索了。

```cpp

#include<stdio.h>
#include<memory.h>
const int dx[]={0,1,0,-1};
const int dy[]={1,0,-1,0};
int n,m,i,j,x,y;
unsigned char a[1000][1000];
int f[1000][1000];
bool v[1000][1000];//v for visit
int xy[1000000][2];
int bfs(int x,int y)
{
    if(f[x][y]+1)return f[x][y];
    int s=0,head=0,tail=1,tx,ty;
    **xy=x;xy[0][1]=y;
    v[x][y]=true;
    while(head<tail){
        for(int i=0;i<4;i++){
            if((tx=xy[head][0]+dx[i])>=0&&tx<n&&(ty=xy[head][1]+dy[i])>=0&&ty<n
               &&!v[tx][ty]&&a[xy[head][0]][xy[head][1]]^a[tx][ty])
                v[tx][ty]=true,xy[tail][0]=tx,xy[tail][1]=ty,tail++;
        }
        head++;
        s++;
    }
    for(int i=0;i<tail;i++)f[xy[i][0]][xy[i][1]]=s;
    return s;
}
int main()
{
    scanf("%d%d ",&n,&m);
    memset(f,-1,sizeof(int)*1000*n);
    for(;i<n;i++){for(j=0;j<n;j++)a[i][j]=getchar()-'0';getchar();}
    for(i=0;i<m;i++){
        scanf("%d%d",&x,&y);
        printf("%d\n",bfs(x-1,y-1));
    }
    
    return 0;
}

```

---

## 作者：野菜汤 (赞：1)

题解：

01迷宫这道题出的非常好，说难不难，说易不易，所以本人很负责的对此题进行讲解。首先，请不要考虑使用回溯搜索，这样最多只能拿80分，还有两个测试点会因为递归深入过大所以爆表。那么这题很明显就是为广搜的初学者准备的了！

再讲一下思路呵，其实就是简单模式的广搜，再加上一些优化。那么这里重点讲一优化：因为同一条路线中，任何一个点所能延伸出的路就只是这一条线而已，那么就在每一次读入的时候，看看它所在的点是否处于某个已走过的路线当中，如果是就直接输出。 那么请看一下标程。

```delphi
const a:array[1..4]of shortint=(0,-1,0,1);
      b:array[1..4]of shortint=(-1,0,1,0);
var l:array[0..1001,0..1001]of longint;
    road:array[0..1000,0..1000] of longint;
    s:ansistring;
    c:array[1..1000000,1..2] of longint;
    d:array[1..100000] of longint;
    i,j,o,m,n,m1,n1,x1,y1,x,y:longint;
procedure dg(p,q,o:longint);
var i:longint;
begin
  c[1,1]:=p;c[1,2]:=q;
  m1:=1;n1:=2;
  while m1<n1 do begin
  for i:=1 to 4 do begin
    x:=c[m1,1]+a[i];
    y:=c[m1,2]+b[i];
    if (x>0)and(x<=n)and(y>0)and(y<=n){判断是否越界}
    and(road[x,y]<>road[c[m1,1],c[m1,2]])and(l[x,y]=0){判断能不能走且有没有走过}
    then begin
      c[n1,1]:=x;
      c[n1,2]:=y;
      l[x,y]:=o;
      inc(n1);
    end;end;
  inc(m1);
  end;
  d[o]:=n1-1;
end;
begin
  readln(n,m);
  for i:=1 to n do begin{因为迷宫的数据之间没有空格，所以用字符串读入然后转换}
    readln(s);
    for j:=1 to n do
    val(s[j],road[i,j]);
  end;
  for i:=1 to m do begin
    read(x1,y1);{每一次读入后就直接处理}
    if l[x1,y1]=0 then begin{如果没有走过就进行广搜}
    l[x1,y1]:=i;
    dg(x1,y1,i);
    end;
    write(d[l[x1,y1]]);writeln;{最后打印相应的答案}
  end;
end.
```
就是这么简单，只需要套用基本的广搜的模式，再加上一些优化，即可通过。那么在这里提醒一下，千万不要在每一次广搜之前，把记录的数组（也就是标程中的c数组）清空，这样会脱很长一段时间，导致程序无法通过！


---

## 作者：theHermit (赞：1)

好几次终于A掉了
首先回顾一下本题题意：

从一个点出发最多能走到多少个格子(包括自身)

那我们只需要利用bfs到目标点距离为最小值的特性，

通过染色法(标记)，记录走过的格子，也就可以求得解

但如果直接用bfs是A不掉本题的...会卡3个点

此时就需要记忆化搜索(选一种基础STL结构记录)+bfs就可以了~

不懂的可以继续看代码~ 注释已经写得很全了~

**如有不足之处，欢迎批评指正，谢谢~**

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
const int MAXSIZE_N=1000;
const int MAXSIZE_M=100000;
struct state{
    int x;
    int y;
};//养成好习惯~结构体有利于我们调整程序

bool IsUsed[MAXSIZE_N][MAXSIZE_N];//记录迷宫bfs的遍历状态
bool maze[MAXSIZE_N][MAXSIZE_N];//maze用于记录迷宫本身
int lookUpTable[MAXSIZE_N][MAXSIZE_N]={0};//建立查询表，记忆化搜索

int n,m;
int cnt=0;//记录可走的格子数

state dir[4]={{1,0},{-1,0},{0,1},{0,-1}};

void InitAll()
{
//    memcpy(maze,neverMaze,sizeof(neverMaze));
//    memcpy(IsUsed,neverUsed,sizeof(neverUsed));//速度过慢
    cnt=0;
}

bool IsSafe(state now,state next)
{
    return(next.x>=0&&next.x<n&&next.y>=0&&next.y<n)//在范围内
    &&(maze[next.x][next.y]!=maze[now.x][now.y])//题目定义的规则,只能0->1或1->0
    &&(IsUsed[next.x][next.y]!=true);//没有染过色or没走过
}


void bfs(state start)
{
    queue<state> Q;
    queue<state> memoryPos;//用于记忆化搜索，记录走过的点，提高速度
    IsUsed[start.x][start.y]=true;
    cnt++;
    Q.push(start);
    memoryPos.push(start);
    while(!Q.empty()){
        state now=Q.front();
        Q.pop();
        for(int i=0;i<4;i++){
            state next=now;
            next.x+=dir[i].x;
            next.y+=dir[i].y;
            if(IsSafe(now,next)){
                IsUsed[next.x][next.y]=true;
                memoryPos.push(next);
                cnt++;
                Q.push(next);
            }
        }
    }
    while(!memoryPos.empty())
    {
        state next=memoryPos.front();
        //把走过的点都记到表中
        memoryPos.pop();
        lookUpTable[next.x][next.y]=cnt;
    }
}

int main()
{
    std::ios::sync_with_stdio(false);//加快输入流的速度
    cin>>n>>m;
    string in[n];
    state start[m];
    for(int i=0;i<n;i++)    cin>>in[i];
    for(int i=0;i<m;i++){
        cin>>start[i].x>>start[i].y;
        start[i].x-=1;//调整输入的坐标到从零开始的坐标
        start[i].y-=1;
    }

    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            if(in[i][j]=='0')
                maze[i][j]=false;//输入的0记为false
            else
                maze[i][j]=true;//1记为true
        }
    }

    for(int i=0;i<m;i++)
    {
        if(lookUpTable[start[i].x][start[i].y]!=0){
            cout<<lookUpTable[start[i].x][start[i].y]<<'\n';//建立查询表
            continue;
        }

        InitAll();//开始是用memcpy初始化IsUsed的..后来发现染色法其实根本不需要重新初始化，但还是保留了函数
        bfs(start[i]);//对每个输入的点进行bfs
        cout<<cnt<<'\n';
    }
    return 0;
}

```


---

## 作者：约修亚_RK (赞：1)

好像写得长了一点orz

手抽写了个只有一个元素的结构体请无视orz


思路是这样的：找出每一组互相连通的格子，并给它们附上标记。具来说就是从第一个点循环到最后一个点，如果这个点还没有标记的话就对这个点bfs一波。


bfs里面要做的事情就是上下左右寻找可以走的点并且加入队列，弹出队列的时候给这个点附上标记并且在对应标记的计数数组里加一，当然如果已经有标记就直接continue掉。可以在push的条件中加上对应点没有标记，可以省一点空间，不过我懒得写（


查询阶段就非常轻松了，只需要拿对应方格的标记值到计数数组里查一下就结束了。


[codec]

/\* P1141

\* Au: SJoshua

\*/



    

```cpp
#include <cstdio>
#include <queue>
using namespace std;
struct block {
    int type;
} status[1001][1001];
int n, m, count[1001*1001];
char map[1001][1001];
void scan(int a, int b, int flag) {
    queue < pair <int, int> > q;
    q.push(make_pair(a, b));
    while (!q.empty()) {
        pair <int, int> tmp = q.front();
        q.pop();
        int x = tmp.first;
        int y = tmp.second;
        if (status[x][y].type) {
            continue;
        }
        count[flag]++;
        status[x][y].type = flag;
        if (x+1 < n && map[x+1][y] != map[x][y]) {
            q.push(make_pair(x+1, y));
        }
        if (y+1 < n && map[x][y+1] != map[x][y]) {
            q.push(make_pair(x, y+1));
        }
        if (x-1 >= 0 && map[x-1][y] != map[x][y]) {
            q.push(make_pair(x-1, y));
        }
        if (y-1 >= 0 && map[x][y-1] != map[x][y]) {
            q.push(make_pair(x, y-1));
        }
    }
}
int main(void) {
    int type = 0;
    scanf("%d %d", &n, &m);
    for (int k = 0; k < n; k++) {
        scanf("%s", map[k]);
    }
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            if (!status[k][i].type) {
                scan(k, i, ++type);
            }
        }
    }
    for (int k = 0; k < m; k++) {
        int x, y;
        scanf("%d %d", &x, &y);
        printf("%d\n", count[status[x-1][y-1].type]);
    }
    return 0;
}
[/codec]
```

---

## 作者：Rapiz (赞：1)

终于AC了……这道水题居然交了N遍，感觉自己还需要大努力！

象征性说下思路：bfs求连通分量，bfs时记录一下已经扩展的节点数。记录每个连通分量扩展的节点数。

```cpp

#include<cstdio>
#include<iostream>
#include<cctype>
#include<queue>
using namespace std;
const int MAXN=1000+1;
bool map[MAXN][MAXN];
int n,m,v[MAXN][MAXN],ans[MAXN*MAXN],now=0;
inline bool check(int x,int y){
    return 1<=x&&x<=n&&1<=y&&y<=n;
}
struct POS{
    int x,y;
    POS(int _x,int _y):x(_x),y(_y){};
};
queue<POS> q;
int bfs(POS p,int cur){ //返回连通分量的点数，传入点和本次连通分量编号 
    int cnt=0;
    cnt++;
    v[p.x][p.y]=cur;
    q.push(p);
    while(!q.empty()){
        p=q.front();
        q.pop();
        for(int dx=-1;dx<=1;dx++) for(int dy=-1;dy<=1;dy++) 
        if(dx*dy==0&&check(p.x+dx,p.y+dy)&&v[p.x+dx][p.y+dy]==0&&map[p.x][p.y]!=map[p.x+dx][p.y+dy]) {
            cnt++;
            v[p.x+dx][p.y+dy]=cur;
            q.push(POS(p.x+dx,p.y+dy));
        }
    }
    return cnt;
}
int main(){
    scanf("%d%d",&n,&m);
    getchar();
    for(int i=1;i<=n;i++,getchar()) for(int j=1;j<=n;j++) map[i][j]=getchar()-'0';
    //for(int i=1;i<=n;i++,printf("\n")) for(int j=1;j<=n;j++) printf("%d",map[i][j]);
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(v[i][j]==0) ans[++now]=bfs(POS(i,j),now);
    while(m--){
        int i,j;
        scanf("%d%d",&i,&j);
        printf("%d\n",ans[v[i][j]]);
    }
}
//为了减少常数开销，dfs和bfs都应该在将节点放入队列/调用栈前检查节点是否合法并标记vis[] 
//注意如果执行上述优化，初始化队列时要先对源点进行检查/标记/计算。 

```

---

## 作者：Kevin5308 (赞：0)

其实这道题目的思想就是**bfs**，有些困难的是数据太大，不能裸搜

因为当（x1,y1）和（x2,y2）是**连通**的时候，它们的答案**必定相等**

所以我们就将搜到的点的答案都记录下来，到时候直接拿出来用就可以了！

## $Code$
```pascal
const dx:array[1..4] of longint=(0,1,0,-1);
      dy:array[1..4] of longint=(1,0,-1,0);
var n,m,xx,yy,i,j:longint;
    ans,a:array[0..1001,0..1001] of longint;
    f:array[0..1001,0..1001] of boolean;
    b:array[0..1000001] of record x,y:longint; end;
    k:char;

procedure bfs(x1,y1:longint);
  var h,t,i,t1,t2:longint;
  begin
    h:=0;t:=1;
    b[1].x:=x1;
    b[1].y:=y1;//本人的程序刚开始前面加了fillchar就TLE……
    f[x1][y1]:=true;
    while(h<t)do
    begin
      inc(h);
      for i:=1 to 4 do
      begin
        t1:=b[h].x+dx[i];
        t2:=b[h].y+dy[i];
        if (t1<1) or (t1>n) or (t2<1) or (t2>n) then continue;
        if (not f[t1][t2]) and (1-a[b[h].x][b[h].y]=a[t1][t2]) then
        begin
          inc(t);
          b[t].x:=t1;
          b[t].y:=t2;
          f[t1][t2]:=true;
        end;
      end;
    end;
    for i:=1 to t do ans[b[i].x][b[i].y]:=t;//将已经走过的点的答案保存下来
  end;

begin
  readln(n,m);
  for i:=1 to n do
  begin
    for j:=1 to n do
    begin
      read(k);
      a[i][j]:=ord(k)-48;
    end;
    readln;
  end;
  fillchar(ans,sizeof(ans),255);
  for i:=1 to n do//先全部扫一遍
    for j:=1 to n do
      if not f[i][j] then bfs(i,j);
  for i:=1 to m do
  begin
    readln(xx,yy);
    writeln(ans[xx][yy]);
  end;
end.
```
第一次发题解，如有更好的建议，欢迎在评论区留言哦~~

---

## 作者：YYX26362 (赞：0)

由于之前没接触过这种类型的DFS题，一开始做的时候思考了不少时间，不过想明白之后就知道用DFS连通块做就好了，和[P1454](https://www.luogu.org/problem/P1454)圣诞夜的极光 有点类似，都属于一边循环遍历一边搜索遍历的类型。区别在于这道题需要把答案存到另一个数组中，方便访问。
```cpp
void dfs1 (int x , int y)
{
    if (x <= 0 || x > n || y <= 0 || y > n) return;
    if (to[x][y]) return; //去重
    to[x][y] = -1; //打标记
    cnt++; //统计连通的块数
    int t = map[x][y];
    for (int i = 1 ; i <= 4 ; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (map[nx][ny] != t)
            dfs1(nx , ny); // 搜索下一级
    }
}
```
先通过第一个DFS灌水找出所有连通的位置，并打上标记
```cpp
void dfs2 (int x , int y)
{
    if (x <= 0 || x > n || y <= 0 || y > n) return;
    if (to[x][y] != -1) return; //去重
    to[x][y] = cnt; //替换
    for (int i = 1 ; i <= 4 ; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        dfs2(nx , ny); //搜索下一级
    }
}
```
调用第二的DFS，把遍历过打了标记的to数组替换为连通块数

------------
下面是完整代码
```cpp
#include <iostream>
using namespace std;
int n , m , cnt = 0;
int map[1005][1005];
int to[1005][1005];
int dx[5] = {0,0,0,1,-1};
int dy[5] = {0,1,-1,0,0};

void dfs1 (int x , int y)
{
    if (x <= 0 || x > n || y <= 0 || y > n) return;
    if (to[x][y]) return;
    to[x][y] = -1;
    cnt++;
    int t = map[x][y];
    for (int i = 1 ; i <= 4 ; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (map[nx][ny] != t)
            dfs1(nx , ny);
    }
}
void dfs2 (int x , int y)
{
    if (x <= 0 || x > n || y <= 0 || y > n) return;
    if (to[x][y] != -1) return;
    to[x][y] = cnt;
    for (int i = 1 ; i <= 4 ; i++)
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        dfs2(nx , ny);
    }
}

int main ( )
{
    cin >> n >> m;
    for (int i = 1 ; i <= n ; i++)
        for (int j = 1 ; j <= n ; j++)
        {
            char a;
            cin >> a;
            map[i][j] = a =='0'? 0 : 1;
		}
    for (int i = 1 ; i <= n ; i++)
        for (int j = 1 ; j <= n ; j++)
        {
            if (!to[i][j])
            {
                cnt = 0;
                dfs1(i , j);//灌水并统计数量
                dfs2(i , j);//遍历并把cnt写入to
            }
        }
    for (int i = 1 ; i <= m ; i++)
    {
        int x , y;
        cin >> x >> y;
        cout << to[x][y] << endl;//访问to
    }
    return 0;
}
```
最后算下来时间复杂度约O(4*n^2 + m)，只要不卡常数还是能AC的。



---

## 作者：yly8848 (赞：0)

## 写在前面
经过三次的优化,终于AC了

+ 第一次: 用int数组存的数据,读数据的时候就花费了很多时间,两个测试点超时.**改用char数组**
+ 第二次: 相同的格子数用访问标记去记录,用了两个for, 超时.**使用指针**
+ 第三次: 每次bfs的访问标记都用memset去清0了, 第二个测试点超时.**去除memset**

## 思路

很明显,题目问那个点, 我们用bfs跑一遍就可以了,但是凡是能**互相连通可达**的点答案都是一样的. 跑完一遍,记录下来即可.

但是我看到很多人都是用一个数组去存这些点,最后才一个一个地去记录.
**既然都是用c++为何不用指针?** 让这些点的记录都指向同一块地址就可以了呀!

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;

char a[1001][1001];            //地图
bool flag[1001][1001]={false}; //访问标记

int* b[1001][1001]={NULL};    //区域格子数 指针
int cnt[1001][1001]={0};     // 区域格子数,其实是为了生成不同的地址,
// 如果直接在 函数里 int cnt; 编译器可能每次都给你分配同一个地址

int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};

struct node{
	int x,y;

	node(int a,int b){
		this->x=a;
		this->y=b;
	}
};

int bfs(int x,int y,int n){

	queue<node> q;

	q.push(node(x,y));
	flag[x][y]=true;
	cnt[x][y]=1;


	b[x][y] = &cnt[x][y];

	while(!q.empty()){
		node p =q.front();
		q.pop();

		for(int i=0;i<4;i++){
			int dirx = p.x+dir[i][0];
			int diry = p.y+dir[i][1];

			if(dirx<0||dirx>=n||diry<0||diry>=n) continue;

			if(a[dirx][diry]+a[p.x][p.y]==97&&flag[dirx][diry]==false){

				q.push(node(dirx,diry)); //可行,入队
				flag[dirx][diry]=true;   //访问标记

				b[dirx][diry]=&cnt[x][y]; //指向记录个数地址
				cnt[x][y]++;              //数量+1
			}

		}
	}
	return cnt[x][y];

}


int main(){

	int n,m,x,y;
	cin>>n>>m;
	for(int i=0;i<n;i++){
		scanf("%s",a[i]);
	}

	for(int i=0;i<m;i++){
		cin>>x>>y;
		x--;
		y--;
		if(b[x][y]!=NULL){
			cout<<*b[x][y]<<endl;
		}else{
			cout<<bfs(x,y,n)<<endl;
		}
	}

}
```



---

## 作者：zcyaya (赞：0)

因为把1E6写成1E5而WA了一个点始终调不出来的zcy是屑（确信）
## 思路分析
既然0可以到1，1可以到0，不难发现两个格子间的到达是双向的，而且从某点能到达的所有点（包括自身）构成的集合中任意两点都能互相到达，换言之，这是一个（因为无向图所以无所谓强不强）联通分量。
### 看看数据规模1E5次询问所以肯定不能在线……
-  DFS找到连通分量

- 对同一个连通分量里的各自染同一种颜色

- 把染过色的图扫一遍记录每种颜色的格子数目

- 对每组询问查表即可
## 代码实现



```cpp
for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++)
		if (!ts[i][j]) {
			dfs(i, j, graph[i][j]);
			index++;
		}
```


------------


```cpp
void dfs(int x, int y, char val) {
	vis[x][y] = 1;
	ts[x][y] = index;
	if ((!ts[x + 1][y]) && x + 1 <= n && graph[x + 1][y] != val && (!vis[x + 1][y])) dfs(x + 1, y, graph[x + 1][y]);
	if ((!ts[x - 1][y]) && x - 1 >= 1 && graph[x - 1][y] != val && (!vis[x - 1][y])) dfs(x - 1, y, graph[x - 1][y]);
	if ((!ts[x][y + 1]) && y + 1 <= n && graph[x][y + 1] != val && (!vis[x][y + 1])) dfs(x, y + 1, graph[x][y + 1]);
	if ((!ts[x][y - 1]) && y - 1 >= 1 && graph[x][y - 1] != val && (!vis[x][y - 1])) dfs(x, y - 1, graph[x][y - 1]);
	vis[x][y] = 0;
}
```
index是一个记录颜色的全局变量，初值为1，在每次找到一个新连通分量时加一

ts数组是染色后的图，而vis数组用于dfs

只对ts为0的点dfs保证了不会在同一个联通块上重复走来走去


------------
```cpp
for (int i = 1; i <= n; i++)
	for (int j = 1; j <= n; j++)
		color[ts[i][j]]++;
for (int i = 1; i <= m; i++) {
	int a, b;
	scanf("%d%d", &a, &b);
	printf("%d\n", color[ts[a][b]]);
}
```
这里就是对颜色计数，再处理每一组询问
## 完整代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n, m, index = 1, ts[1021][1021], vis[1021][1021];
int color[1000021];
char graph[1021][1021];

void dfs(int x, int y, char val);

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			cin >> graph[i][j];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (!ts[i][j]) {
				dfs(i, j, graph[i][j]);
				index++;
			}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			color[ts[i][j]]++;
	for (int i = 1; i <= m; i++) {
		int a, b;
		scanf("%d%d", &a, &b);
		printf("%d\n", color[ts[a][b]]);
	}
	return 0;
}

void dfs(int x, int y, char val) {
	vis[x][y] = 1;
	ts[x][y] = index;
	if ((!ts[x + 1][y]) && x + 1 <= n && graph[x + 1][y] != val && (!vis[x + 1][y])) dfs(x + 1, y, graph[x + 1][y]);
	if ((!ts[x - 1][y]) && x - 1 >= 1 && graph[x - 1][y] != val && (!vis[x - 1][y])) dfs(x - 1, y, graph[x - 1][y]);
	if ((!ts[x][y + 1]) && y + 1 <= n && graph[x][y + 1] != val && (!vis[x][y + 1])) dfs(x, y + 1, graph[x][y + 1]);
	if ((!ts[x][y - 1]) && y - 1 >= 1 && graph[x][y - 1] != val && (!vis[x][y - 1])) dfs(x, y - 1, graph[x][y - 1]);
	vis[x][y] = 0;
}
```

---

## 作者：wuyinyu (赞：0)

# **说明：** 
   刚开始题意理解有误，提议要求找出所有能够到达的就行，没有一趟下来所能到达的最大块数的限制，以至于使用了DFS搜索，时间上超时了几个测试点，用BFS搜索更简单，但懒得改了，就用深度写了，当练手了

## 思路：## 
用DFS从起始点一直搜索到无法再走，定义数组vis保存块是否走过，how保存块数，几个if加switch判断行走方向并迭代以及判断下一个需要的地块数字即可。

## ps:去掉注释部分则为如果要求一躺下来则能走过的最多块数

------------
附上代码：
```cpp
#include <iostream>
#include <cstdio> 
#include <queue>
#include <cstring>
#define N 100001
using namespace std;
int Mig[1001][1001];//迷宫 
int vis[1001][1001];//标记 
int star[N][2];
char MG[1001];
int much=1,how=1;//记录格子数 


/*
	有几个测试点没通过，后来发现是找所有能够到达的块，而不是一趟下来最多 
	题意理解错误，还是广度更方便，但懒得改了
	去掉注释就是一趟下来最多的快数 
*/
void dfs(int n,int star_x,int star_y)
{
	vis[star_x][star_y]=1;
	switch(Mig[star_x][star_y])
	{
		case 1://如果当前点为1，则四个方向进行搜索 
			if(Mig[star_x+1][star_y]==0&&vis[star_x+1][star_y]==0&&star_x+1<=n)
			{
				how++;
				dfs(n,star_x+1,star_y);
			//	vis[star_x+1][star_y]=0;
			
			}
			if(Mig[star_x-1][star_y]==0&&vis[star_x-1][star_y]==0&&star_x-1>0)
			{
				how++;
				dfs(n,star_x-1,star_y);
			//	vis[star_x-1][star_y]=0;
			
			} 
			if(Mig[star_x][star_y-1]==0&&vis[star_x][star_y-1]==0&&star_y-1>0)
			{
				how++;
				dfs(n,star_x,star_y-1);
			//	vis[star_x][star_y-1]=0;
			
			}
			if(Mig[star_x][star_y+1]==0&&vis[star_x][star_y+1]==0&&star_y+1<=n)
			{
				how++;
				dfs(n,star_x,star_y+1);
			//	vis[star_x][star_y+1]=0;

			}
			//若四个方向都走不了
		//	vis[star_x][star_y]=0;
		//	if(how>much)
		//		much=how;
		//	how--; 
			break;
		case 0:
			if(Mig[star_x+1][star_y]==1&&vis[star_x+1][star_y]==0&&star_x+1<=n)
			{
				how++;
				dfs(n,star_x+1,star_y);
		//		vis[star_x+1][star_y]=0;
			}
			if(Mig[star_x-1][star_y]==1&&vis[star_x-1][star_y]==0&&star_x-1>0)
			{
				how++;
				dfs(n,star_x-1,star_y);
		//		vis[star_x-1][star_y]=0;
			} 
			if(Mig[star_x][star_y-1]==1&&vis[star_x][star_y-1]==0&&star_y-1>0)
			{
				how++;
				dfs(n,star_x,star_y-1);
		//		vis[star_x][star_y-1]=0;
			}
			if(Mig[star_x][star_y+1]==1&&vis[star_x][star_y+1]==0&&star_y+1<=n)
			{
				how++;
				dfs(n,star_x,star_y+1);	
		//		vis[star_x][star_y+1]=0;
			}
			//若四个方向都走不了 
		//	vis[star_x][star_y]=0;
	//		if(how>much)
		//		much=how; 
			break;
	} 
	
}
int main() 
{
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",MG);
		for(int j=1;j<=n;j++)
			Mig[i][j]=MG[j-1]-'0';	
	}
	for(int i=1;i<=m;i++)
		scanf("%d %d",&star[i][0],&star[i][1]);
	for(int i=1;i<=m;i++)
	{
		memset(vis,0,sizeof(vis));
		dfs(n,star[i][0],star[i][1]);
	//	printf("%d\n",much);
		printf("%d\n",how);
		much=1,how=1;
	}
		
	return 0;
}
```

---

## 作者：cheater__ (赞：0)

来一波常规bfs加查看优化
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define maxn 1111

struct node
{
	int x,y;
	char d;
}q[9999999];//memset卡时间，数组开大防止越界

struct pos
{
	int x,y;
}f[1000110];

int v[maxn][maxn],sum,sx,sy,tx[5] = {0,-1,1,0,0},ty[5] = {0,0,0,-1,1},vsum[maxn][maxn];
char a[maxn][maxn];
int tot;

void bfs()
{
	sum = 1;
	int heap = 0,tail = 1;
	q[1].x = sx,q[1].y = sy,q[1].d = a[sx][sy],v[sx][sy] = tot;
	while(heap < tail)
	{
		heap++;
		for(int i=1;i<=4;i++)
		{
			int xx = q[heap].x + tx[i];
			int yy = q[heap].y + ty[i];
			if(q[heap].d == '1')
			{
				if(!v[xx][yy] && a[xx][yy] == '0')
				{
					tail++;
					v[xx][yy] = tot;
					q[tail].x = xx,q[tail].y = yy,q[tail].d = a[xx][yy];
					sum++;
				}
			}
			if(q[heap].d == '0')
			{
				if(!v[xx][yy] && a[xx][yy] == '1')
				{
					tail++;
					v[xx][yy] = tot;
					q[tail].x = xx,q[tail].y = yy,q[tail].d = a[xx][yy];
					sum++;
				}
			}
		}
	}
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
			scanf("%s",a[i]+1);
	for(int k=1;k<=m;k++)
	{
		tot++;//!!!!!重点，用不同的数字表示不同的联通块，比并查集快
		scanf("%d%d",&sx,&sy);
		if(!v[sx][sy])
		{
			bfs();
			f[tot].x = sx,f[tot].y = sy;
			vsum[sx][sy] = sum;
			printf("%d\n",sum);
		}
		else
			printf("%d\n",vsum[f[v[sx][sy]].x][f[v[sx][sy]].y]);
	}
	return 0;
}
```
第二第九第十个点没有优化前tle，优化后100ms以下

---

## 作者：inexistent (赞：0)

本以为这道题是水题，以为是最初学bfs时候的迷宫最短路，题目都没看就打了一半。回过头看了一眼

却发现题目大相径庭，完全不同。

看完题目以后打了第2个版本，暴力广搜，结果50分，剩下的几个点都TLE了。

于是开始在我的子程序里检测每一次广搜完之后的访问路径。（也就是visited数组）。结果惊奇的发现，

连续的一段访问路径总是一样的。

题目的精髓在于，同一个连通块中能到达的格子数一定是一样的！这些格子互相联通，则都能互相到达。

所以，标记整个连通块。如果已经标记过了，那么就不需要再bfs一遍了。大大降低了复杂度。

这道题的空间不是问题，重要的是时间。所以，记忆是个很好的选择。

样例数据比较弱，要细调的话最好自己造一个4x4的数据来调。


- 耗时/内存     240ms , 16800kb


```cpp
//This program is written by QiXingZhi 

#include <cstdio>
#include <cstring>

//m比较大，用上快读会好一点。 
inline void read(int &x){
    int w=1; char ch=0;
    x=0;
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    x=x*w;
}

void write(int x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar((int)x%10+'0');
}
 
//建立一个坐标类，包含x,y坐标 
struct POS { int x,y; };

#define MAX_N    1001
const int plusx[]={1,-1,0,0};
const int plusy[]={0,0,1,-1};      //四个方向的坐标变化，在广搜的时候依次加上就好了 
char G[MAX_N][MAX_N];  //输入的图          
int ans[MAX_N][MAX_N];  //记录每一个点能访问的点的个数，也就是答案要求的 
bool b[MAX_N][MAX_N];  //是否访问过，在bfs中用到
/*
 * b数组不用清零，清零会用去大量的时间
 * 之所以不用清零是因为，不同的连通块是不可能遍历到的，所以相对于每一个连通块，b的值都为0，清零是没有意义的 
 */ 
bool used[MAX_N][MAX_N];  //记录是否访问过此格点 
POS q[1000001];  //广搜的队列，每次都会覆盖，所以也不用清零 
POS rmb[1000001]; //记忆的数组，remember，不是人民币！ 
int n,m,h,t,sum;

inline void push(int x,int y) {
    if(x>n || x<1 || y<0 || y>=n) return;  //判断出界 
    if(b[x][y]) return;  //是否访问 
    
    //推入队列，bfs的基本套路 
    t++;
    q[t].x = x;
    q[t].y = y;
    b[x][y] = 1;
    
    sum++;    /* 将能够访问的总点数+1 */ 
    
    rmb[sum].x = x;
    rmb[sum].y = y;
    /* 
     * 这里理论上应该新开辟一个变量来做rmb数组的头，但是由于rmb数组的头一定就是当前能访问
     * 节点的总数，所以就直接调用了sum。
     * rmb也顺便调用了POS类来记录x坐标与y坐标 
     */ 
}

inline void bfs(int x, int y) {
    //init 
    h = 0, t = 0;
    sum = 0;
    
    //推入起点，一定不能忘。 
    push(x,y);
    
    while(h<t) {
        h++;
        for(int i=0; i<4; i++) {
            /*
             * 1只能走到0,0只能走到1，所以意味着只能走到值不相等的点。
             * 当前坐标加上变化坐标 与 当前坐标 比较，如果不相等，意味着可以走 
             */ 
            if(G[q[h].x+plusx[i]][q[h].y+plusy[i]]!=G[q[h].x][q[h].y]) 
                push(q[h].x+plusx[i], q[h].y+plusy[i]);
        }
    }
    
    for(int i=1; i<=sum; i++) {
        //遍历记忆的所有访问过的点，将ans的值设定为sum 
        ans[rmb[i].x][rmb[i].y] = sum;
        //并将这个访问过的节点设置为访问过 
        used[rmb[i].x][rmb[i].y] = 1;
    }
}

int main()
{
    read(n),read(m);
    for(int i=1; i<=n; i++) 
        scanf("%s", G[i]);
    for(int i=1; i<=n; i++) 
        for(int j=0; j<n; j++) 
            if(!used[i][j]) bfs(i,j);      //如果至今未访问过当前格点，则广搜遍历这个格点，求出连通块 
    for(int i=0; i<m; i++) {
        int x,y;
        read(x), read(y);
        write(ans[x][y-1]); putchar('\n');
        //c++的字符串是从0开始的，所以在调用的时候，需要先将y坐标-1，统一标准。 
    }
    return 0;
}
```

---

## 作者：陈新月 (赞：0)

思路：

这道题的话深搜会爆栈，所以还是用BFS更好一些，因为想到了是连通块，所以用了并查集，在并查集的处理上，又用到了哈希思想，我们把一个二维坐标HASH为一个数，假设当前处于i行j列，那么他的哈希值就是（i-1)\*n+j,其实这点就相当于给每一点进行了编号，第一行1,2，....n,第二行n+1，n+2 ...... 2n，所以我们就可以进行一维的并查集，在一开始，将并查集的父亲设为其自己，在之后，当我们在bfs的过程中，我们在扩展每一步时，就将扩展节点的父亲设为当前节点，我们对于每一个连通块只进行一次BFS，若查询到某个连通块时，如果这个点在之前已经被询问过，就直接返回答案，如果没有，我们再检查这个点的父亲是否为他自己，如果是其自己，则说明其所属的连通块未被BFS过，我们就对他进行扩展，如果其父亲不是他自己，则说明此节点已经被搜过，那么我们便找到他的第一代祖先，返回此祖先的答案就可以了，因为他被计算过了。


另外，源代码中有两个函数cul\_num()与ID()，前一个是将坐标化数值，后一个是将数值化坐标，都用了inline，因为可以加快速度


测试数据时间最长的一个点为228ms, 算是比较快的，下面贴代码，部分重要细节已经注释，如果有哪些不懂得地方，可以给我留言














          
```cpp
#include<bits/stdc++.h>
#define N 1009
using namespace std;
int n;
int G[N][N];                                     //图数组 
int tx[] = {0,1,0,-1};                         //转向数组 
int ty[] = {1,0,-1,0};
bool inque[N][N];                              //是否被扩展过 
int fa[N*N];                                     //并查集数组，因为是二维转一维，所以要开N*N 
int d[N][N];                                   //记忆化数组 
struct point{                                   //点坐标 
    int x,y;
    point(int xx,int yy){
        x = xx;
        y = yy;
    }
};
int read(){                                     //优化读数 
    int x = 0;
    char ch = getchar();
    while(ch < '0' || ch > '9')ch = getchar();
    while(ch >= '0' && ch <= '9'){
        x = x * 10 + ch -'0';
        ch = getchar();
    }
    return x;
}
int getf(int now){                            //带路径压缩的并查集，返回第一代祖先的哈希值 
    if(fa[now] == now)return now;
    else return fa[now] = getf(fa[now]);
}
inline point ID(int now){                         //将哈希值转化为坐标，返回的是一个上面定义的坐标结构体 
    int x = now/n;
    int y = now%n;
    if(y == 0){
        y = n;
    }
    else x = x+1;
    return point(x,y);
}
inline int cul_num(int x,int y){         //将坐标转化为数值，类似于哈希 
    return (x-1)*n+y;
}
int bfs(int x,int y){                    //宽搜函数 
    if(d[x][y]){                         //如果d[x][y]不为0，则是被扩展过的节点，直接返回答案 
        return d[x][y];
    }
    if(fa[cul_num(x,y)] != cul_num(x,y)){    //如果节点(x,y)的祖先不是其自己，则此点也被
                                             //扩展过，则返回其第一代祖先的连通块大小 
        point v = ID( getf( cul_num(x,y) ) );  //计算（x,y）点哈希值再转入并查集查找，之后
                                               //将返回的数值重新转回点坐标 
        d[x][y] = d[v.x][v.y];                 //记忆化 
        return d[v.x][v.y];
    }
    int siz = 1;                              //下面为正常宽搜步骤 
    queue<point> que;
    que.push(point(x,y));
    while(que.size()){
        point now = que.front();
        que.pop();
        inque[now.x][now.y] = true;
        for(int i = 0; i < 4; i++){
            int xx = now.x+tx[i];
            int yy = now.y+ty[i];
            if(xx >= 1 && xx <= n && yy >= 1 && yy <= n && G[now.x][now.y] != G[xx][yy] && !inque[xx][yy]){
                siz++;
                que.push(point(xx,yy));
                inque[xx][yy] = 1;                             //此点被扩展，进行记录 
                fa[cul_num(xx,yy)] = cul_num(now.x,now.y);     //将扩展的节点父亲设为now 
            }
        }
    }
    d[x][y] = siz;                                       //记忆化 
    return siz;                                            //返回答案 
}
int main(){
    int m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n;  i++){
        string s;
        cin >> s;
        int len = s.length();
        for(int j = 0; j < len;j++){
            if(s[j] == '0')G[i][j+1] = 0;
          else G[i][j+1] = 1;
          fa[(i-1)*n+j+1] = (i-1)*n+j+1;               //并查集初始化 
        }
    }
    while(m--){
        int x = read(),y = read();
        printf("%d\n",bfs(x,y));                    //输出答案 
    }
    return 0;
}
```

---

## 作者：Nightfury12366 (赞：0)

###我的天，实在是忍不住要写题解了，啊啊啊，本蒟蒻加上了记忆化也还是TLE第二个点，提交了很多很多次，还是想不通为什么超时，最后才想明白原来是memset啊！！！这道题不应该用memset也没有用memset的必要，用了就TLE没跑的

啊啊啊，咱们来结合代码看一下吧，思路还是基础的广搜，许多细节需要注意一下，请大佬们原谅本蒟蒻的中二题解

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<queue>
#include<cstring>
#include<cstdio>
#define N 1001
#define LL long long
using namespace std;
bool map[N][N];
//记忆搜索
//（此处说一下，平常写广搜都会定义一个bool vis[N][N]; 然后每执行完一次广搜就会加上一句memset(vis,false,sizeof vis)来初始化，但
//这样既费时也没有太大意义，因为记忆数组remenber里就能代替它的功能，由广搜原理可知，从一个连通图并不能搜到另一个独立的
//连通图，所以只要这个记忆数组就能代替vis[N][N]的全部功能，大大节约了时间）
LL remenber[N][N]; 
 LL ans[N*N];  //储存每个联通块的大小（也就是数量）
int n, m, xxx, yyy;
LL num = 0;//表示第几个联通块
int dx[] = { 1,0,-1,0 };   
int dy[] = { 0,1,0,-1 };
struct node   //每一个节点用结构体会比较方便
{
    int x;
    int y;
    bool info; //解释一下，这个是每个节点的对应map[x][y]的值
};
LL bfs(int x, int y) //开始广搜
{
    //bool vis[N][N];
    LL sum = 0;
    queue<node>q;
    node s;
    s.x = x; s.y = y;
    sum++; num++;
    s.info = map[x][y];
    //vis[x][y] = true;
    remenber[x][y] = num;
    q.push(s);
    while (!q.empty())
    {
        node u;
        u = q.front();
        q.pop();
        for (int i = 0; i < 4; i++)
        {
            if (u.x + dx[i] < 1 || u.x + dx[i] > n || u.y + dy[i] < 1 || u.y + dy[i] > n || remenber[u.x + dx[i]][u.y + dy[i]])  //判断越界与重复
                continue;
            node t;
            t.x = u.x + dx[i]; t.y = u.y + dy[i]; t.info = map[t.x][t.y];
            if (map[u.x][u.y] != map[t.x][t.y])
            {
                remenber[t.x][t.y] = num;
                //vis[t.x][t.y] = true; //以前的错误示范，嗯对，他没用了
                sum++;
                q.push(t);
            }
        }
    }
    ans[num] = sum;
    return sum;
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)//输入输出
    {
        string s;
        cin >> s;
        for (int j = 1; j <= n; j++)
            map[i][j] = s[j - 1] - '0';
    }
    for (int i = 0; i < m; i++)
    {
        cin >> xxx >> yyy;
        if (!remenber[xxx][yyy])
        {
            cout << bfs(xxx, yyy) << endl;
            //memset(vis, false, sizeof vis);  //哈哈哈哈，以前就是这样TLE的呵呵
        }
        else
            cout << ans[remenber[xxx][yyy]] << endl;  //直接输出这个联通块对应的值
    }
    //system("pause");
    return 0;
}
```

---

## 作者：SKTT1Faker (赞：0)

这首一道典型的宽搜题。


我们每进行一次所搜索，就把路径上所有的点设为true（搜过），最后把点都变成点数（相互的）


如例：      （t为搜过，f为未搜） 第一张为行进图，第二张为数量图

101
011
100
一开始：f f f               0 0 0

f f f               0 0 0

f f f               0 0 0

第一次：t f f               1 0 0

f f f                0 0 0

f f f                0 0 0

第二次：t t f                2 2 0

t f f                2 0 0

f f f                0 0 0

第三次：t t t              6 6 6

t t f               6 6 0

t f f               6 0 0

第四次：t t t               7 7 7

t t f               7 7 0

t t f               7 7 0(第一条路径结束）

第五次 ：t t t             7 7 7

t t t              7 7 1

t t f               7 7 0

第六次： t t t              7 7 7

t t t              7 7 2

t t t              7 7 2




```cpp
var
a,b,i,j,h,w:longint;
c:array[1..1000000,1..2] of longint;   
g:array[1..100000,1..2] of longint;
m:array[0..1001,0..1001] of boolean;----------判断有没有搜过
n:array[0..1001,0..1001] of char;
d:array[1..1000,1..1000] of longint;------------记录 
procedure k(x,y:longint;v:char);-------------宽搜
begin
if (x>0)and(x<=a)and(y>0)and(y<=a) then begin-----------防止越界
h:=h+1；
c[h,1]:=x;
c[h,2]:=y;
if v='1' then v:='0' else v:='1';--------------把当前的数变成相反的
m[x,y]:=true;-------------搜过了
if (n[x+1,y]=v) and (m[x+1,y]=false) then k(x+1,y,v);
if (n[x-1,y]=v) and (m[x-1,y]=false) then k(x-1,y,v);
if (n[x,y+1]=v) and (m[x,y+1]=false) then k(x,y+1,v);
if (n[x,y-1]=v) and (m[x,y-1]=false) then k(x,y-1,v);------------向四面八方搜
end;
end;
begin
readln(a,b);
for i:=1 to a do
begin
for j:=1 to a do
read(n[i,j]);
readln end;------------char输入，看不懂某些人为啥字符串输入，再分开
for i:=1 to a do
for j:=1 to a do
if m[i,j]=false then 
begin
h:=0;
k(i,j,n[i,j]);
for w:=1 to h do-----------千万不要清零，会超时
d[c[w,1],c[w,2]]:=h;
end;
for i:=1 to b do
readln(g[i,1],g[i,2]);
for i:=1 to b do
writeln(d[g[i,1],g[i,2]]);
end.

```

---

## 作者：minamikotori (赞：0)

直接从（1,1）点开始枚举。 若当前节点没有被标记就从当前节点开始bfs完能经过的所有点， 组成一个连通图。

又因为一个联通图里的所有点都可以互相到达。所以可到达的点数相等。

所以在从（x，y）点开始bfs时， 将其作为这个连通图的代表元。

然后查询的时候就直接输出要查询的点的代表元的cnt值就可以了。

最坏的情况应该是o（2n^2） 所以跑的还是比较快。

最后naive的输出就可以了。

下面附上代码

···



    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
typedef long long Lovelive;
using namespace std;
inline void scan(int &x) {
    int f = 1; x = 0;char c = getchar();
    while(c > '9' || c < '0') {if(c == '-') f= -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x*10 + c - '0', c = getchar();
    f*x;
}
int g[1010][1010], n, m;
char a[1010][1010];
bool vis[1010][1010];
int xx[]={1, 0, -1, 0}, yy[]={0, 1 ,0 ,-1};
struct node {
    int x, y;
};
node fa[1010][1010];
bool check(int x, int y) {
    if(x>n||y>n||x<1||y<1) return false;
    return true;
}
void bfs(int x, int y) {
    node s; node res; queue<node>q; int cnt=1;
    s.x=x; s.y=y; q.push(s); vis[x][y]=1; fa[x][y].x=x; fa[x][y].y=y;
    while(!q.empty()) {
        res=q.front(); q.pop(); 
        for(int i=0; i<4; i++) {
            s.x=res.x+xx[i]; s.y=res.y+yy[i];
            if(check(s.x, s.y) && !vis[s.x][s.y] && (a[res.x][res.y]+a[s.x][s.y]-'0'-'0')==1) cnt++, q.push(s), vis[s.x][s.y]=1, fa[s.x][s.y].x=x, fa[s.x][s.y].y=y;
        }
    }
    g[x][y]=cnt;    
}
int main() {
    scan(n); scan(m);
    for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) cin>>a[i][j];
    for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) if(!vis[i][j]) bfs(i, j);
//    for(int i=1; i<=n; i++) for(int j=1; j<=n; j++) cout<<g[i][j]<<" ";
//    cout << endl;
    while(m--) {
        int x, y; scan(x); scan(y);
        printf("%d\n", g[fa[x][y].x][fa[x][y].y]);
    }
    return 0;
}
···
```

---

## 作者：Akashicw (赞：0)

/\*同一个联通分量里面的所有位置它能到达的区域是一样多的。

求出每一个联通分量，并赋值一样的结果即可\*/



            

    
   
 
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int a[1010][1010],v[1010][1010];//方阵 ,v为标志数组 
int n,m,num;
int b[10010];
char c[1010];
int f[][2]={{-1,0},{1,0},{0,-1},{0,1}};//四个方向 
struct node{
    int x,y;
}cur,nxt; 
//queue<node> q;
node q[1000005];//用数组代替queue队列 
void bfs(int sx,int sy)
{
    int front,tail;//标志数组队列的前后位置 
    front=0;tail=1;
    cur.x=sx;
    cur.y=sy;
    q[front]=cur;// 把开始的格子入队列
    num=1;
    v[sx][sy]=1;
    while(front<tail)
    {
        cur=q[front];
        front++;        
        for(int i=0;i<4;i++)//4个方向
        {
            nxt.x=cur.x+f[i][0];
            nxt.y=cur.y+f[i][1];
            if(a[cur.x][cur.y]+a[nxt.x][nxt.y]==1&&!v[nxt.x][nxt.y])
            {
                num++;
                q[tail++]=nxt;
                v[nxt.x][nxt.y]=1;
            }
        } 
    }
    for(int i=0;i<tail;i++)//所有进入队列的，都位于同一个联通分量里面 
        v[q[i].x][q[i].y]=num;
}
int main()
{
    int i,j;
    int sx,sy;
    scanf("%d%d",&n,&m);
    for(i=0;i<=n+1;i++)
        for(j=0;j<=n+1;j++)
        a[i][j]=2;//设为2，不需要再判断越界 
    for(i=1;i<=n;i++) 
    {    
        scanf("%s",c);//输入方阵，因无空格，用字符输入再转换
        for(j=1;j<=n;j++)
         a[i][j]=c[j-1]-'0';
    }
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        if(!v[i][j]) bfs(i,j);//
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&sx,&sy);        
        printf("%d\n",v[sx][sy]); 
    } 
}
```

---


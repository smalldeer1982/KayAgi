# 驾车旅游

## 题目描述

如今许多普通百姓家有了私家车，一些人喜爱自己驾车从一个城市到另一个城市旅游。自己驾车旅游时总会碰到加油和吃饭的问题，在出发之前，驾车人总要想方设法得到从一个城市到另一个城市路线上的加油站的列表，列表中包括了所有加油站的位置及其每升的油价（如 $3.25$ 元/L）。驾车者一般都有以下的习惯：

1. 除非汽车无法用油箱里的汽油达到下一个加油站或目的地，在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来；
2. 在第一个停下的加油站总是将油箱加满；
3. 在加油站加油的同时，买快餐等吃的东西花去 $20$ 元。
4. 从起始城市出发时油箱总是满的。
5. 加油站付钱总是精确到 $0.1$ 元（四舍五入）。
6. 驾车者都知道自己的汽车每升汽油能够行驶的里程数。

现在要你帮忙做的就是编写一个程序，计算出驾车从一个城市到另一个城市的旅游在加油和吃饭方面最少的费用。

## 样例 #1

### 输入

```
600
40  8.5  128  3
200  3.52
350  3.45
500  365```

### 输出

```
13133.2```

# 题解

## 作者：Okimoto (赞：25)

# P1180
##### 原本以为是一道朴素的深搜+模拟，然鹅……


------------
### 算法：深搜+模拟+~~题意纠正~~
#### 本题除读题和理解题意之外难度极低……
###### ~~（题意正确的话这道题该是红/橙题）~~
## Before AC
做题之前先纠正一下题意：
1. 在每一个停下的加油站总是将油箱加满（不是第一个）
2. 输出时将答案保留十分位。（不必四舍五入）

好了，理解清楚了题意，这道题~~瞬间变红题~~。

还有几个需要注意的点：
1. 输入是实数的，有可能是浮点数。
2. 深搜剪枝更加保险。$(n ≤ 50)$
3. 司机恰饭还要20元。
4. “不少于最大容量的一半”，即为大于等于，而不是大于。
5. 记得加上出发时加油的钱！
6. 可以把起点、终点作为一个加油站，简化问题。

别抄题解o：
```cpp
// By Sublime Text 3
// P1180, by Okimoto
// No copy, pls.
#include <stdio.h>
#include <math.h>
using namespace std;
struct stn
{
	double loc;
	double prc;
};
stn gas[64];
int dis, n;
double vol, per, cst, ans;
bool flg = true;
void dfs(double ful, int loc, double sum){
	if(loc == n + 1){
		if(flg){
			ans = sum;
			flg = false;
		}
		else if(sum < ans){
			ans = sum;
		}
		return;
	}
	if((gas[loc + 1].loc - gas[loc].loc) / per > ful){
		sum += 20;
		sum += gas[loc].prc * (vol - ful);
		ful = vol;
		ful -= (gas[loc + 1].loc - gas[loc].loc) / per;
		dfs(ful, loc + 1, sum);
	}
	else if(ful < vol / 2){
		dfs(ful - (gas[loc + 1].loc - gas[loc].loc) / per, loc + 1, sum);
		sum += 20;
		sum += gas[loc].prc * (vol - ful);
		ful = vol;
		ful -= (gas[loc + 1].loc - gas[loc].loc) / per;
		dfs(ful, loc + 1, sum);
	}
	else{
		ful -= (gas[loc + 1].loc - gas[loc].loc) / per;
		dfs(ful, loc + 1, sum);
	}
}
int main(int argc, char const *argv[])
{
	scanf("%d", &dis);
	scanf("%lf %lf %lf %d", &vol, &per, &cst, &n);
	for(int i = 1; i <= n; i ++)
		scanf("%lf %lf", &gas[i].loc, &gas[i].prc);
	gas[n + 1].loc = dis;
	gas[0].loc = 0;
	dfs(vol, 0, 0);
	printf("%.1lf", ans + cst);
	return 0;
}
// 你能看到我，是我最大的心愿♥
```


---

## 作者：花椒酱 (赞：12)

#### **（ 题目及数据略(o°ω°o) ）**
```cpp

#include<algorithm>
#include<iostream>
#include<fstream>
#include<cstdio>
using namespace std;

int n;
double s,c,each,init,ans,km[55]={0},pr[55]={0};
//s:总距离  c:最大容量 each： 每升油行驶的公里数 
//init： 汽车在出发地加满油箱的钱  n:线路上加油站的数目(不包含出发、目的地)

void comp(int jyz,double money,double last){
	//jyz：正在考虑的加油站  money：目前花的钱  last：油箱现在剩的油
	if(jyz>n){
		if(money<ans) ans=money;
	}
	else{
		if(money>ans) return;//剪枝 
	
		else{
			last-=(km[jyz]-km[jyz-1])/each;
		
			if(last*each<km[jyz+1]-km[jyz]){
				comp(jyz+1,money+20+pr[jyz]*(c-last),c);	
			}//必须加油 
		
			else if(last*2<c){
				comp(jyz+1,money+20+pr[jyz]*(c-last),c);
				comp(jyz+1,money,last);	
			}//可加可不加 
		
			else comp(jyz+1,money,last);//不加 
		}
	}
}

int main(){
	cin>>s>>c>>each>>init>>n;
	ans=init;
	km[n+1]=s;
	for(int i=1;i<=n;i++){
		cin>>km[i]>>pr[i];
		ans+=pr[i]*c+20;
	}
	comp(1,init,c);
	printf("%.1lf",ans);
	return 0;
}

```

---

## 作者：最喜欢saber了 (赞：9)

这题好像属于搜索模拟，但我是用dfs做的，说实话，这道题的变量是真的多，(我光看题就看了很久)，至于具体实现还是在代码中实现吧。

```cpp

//以下是此题的条件
//除非汽车无法用油箱里的汽油达到下一个加油站或目的地，
//在油箱里还有不少于最大容量一半的汽油时，
//驾驶员从不在加油站停下来；
//在第一个停下的加油站总是将油箱加满；
//在加油站加油的同时，买快餐等吃的东西花去20元。
//从起始城市出发时油箱总是满的。
//加油站付钱总是精确到0.1元(四舍五入)。
//驾车者都知道自己的汽车每升汽油能够行驶的里程数。
#include<algorithm>
#include<cstring>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<cctype>
#include<cstdio>
#include<queue>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &x){
    x=0;T f=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
    x*=f;
}//读入优化，也没啥用
const int maxa = 100,inf = 0x3f3f3f;
double dis,L,km,val,d[maxa],v[maxa],ans=inf;
//dis: 从出发地到目的地的距离
//L:汽车油箱的最大容量
//km:汽车每升油能行驶的公里数
//val:是汽车在出发地加满油箱时的费用
//d[maxa]:从出发地到某一个加油站的距离
//v[maxa]:该加油站汽油的价格(单位：元)。
//ans：答案
int n;
void dfs(int to,double you,double cost){//to为当前加油站序号， you为当前油量， cost为已花钱数 
	if(cost>ans)return;//剪枝
	if(to==n+1){
		ans=min(ans,cost);
		return;
	}
	if(you*km>=d[to+1]-d[to]){//若油够
		if(you*2>=L){//不加油
			dfs(to+1,you-(d[to+1]-d[to])/km,cost);
		}
		else{//加油
			dfs(to+1,you-(d[to+1]-d[to])/km,cost);
			dfs(to+1,L-(d[to+1]-d[to])/km,cost+20+(L-you)*v[to]);
		}
	}
	else{//若油够
		dfs(to+1,L-(d[to+1]-d[to])/km,cost+20+(L-you)*v[to]);
	}
}
int main(){
	scanf("%lf",&dis);
	scanf("%lf%lf%lf%d",&L,&km,&val,&n);
	for(int i=1;i<=n;++i)scanf("%lf%lf",&d[i],&v[i]);
	d[n+1]=dis;//标记终点
	dfs(1,L-d[1]/km,val);//dfs
	printf("%.1lf",ans);
	return 0;
}
```
求过
	
请记住，我太弱了

---

## 作者：HappyKai (赞：4)

## 题目概括：
驾驶员要从起点开向终点。中途如果油不够到达下一个加油站会去加油，或有少于总容量的一半，也可能会加油。
加油是要收费的，同时还要叫饭费。
让你求出最少的开销。
驾驶员的车一开始的总容量告诉你了，加油站数告诉你了……万事俱备，只缺思路……。

------------

## 解题思路：
dfs搜索每个加油站，每个有两种选择加油或不加油。 用dfs(当前开销，当前加油站，剩余容量)表示。从起点到第1个加油站，从第1个加油站到第2个……深度优先搜索最小值，将最小值保存在答案中。

------------

## 标准程序：
```cpp	
#include <bits/stdc++.h>
using namespace std;
double ans,cost[10010];
double dis,L,km,first_cost;//总长，总容量，每升行驶km（km），n个加油站，准备工作时的开销，答案。 
int a[10010],s[10010],n;//每个加油站相距路程，每个加油站的价格（我包了）。 
void dfs(double payed,int i,double oil) {//当前开销，当前所在加油站，剩余石油 
	if(payed >= ans) {
		return ;//如果当前开销大雨了历史最小开销，肯定不能成功破纪录。 
	}
	if(i == n + 1) {
		ans = min(ans,payed);//更新历史记录。 
		//我不服，再试一次！（回到上一次的第15或18行if）。 
		return ; 
	}
	if(oil * km >= a[i + 1]) {
		if(oil * 2 >= L){//大于等总容量的一半，等同于oil > L / 2，但是更好地保留了精度。 
			dfs(payed,i + 1,oil - a[i + 1] / km);//不用加油。
			//因为题目中说在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来。 
			//当前开销，油还剩下（当前剩余容量 - 消耗的能量）。 
		}else {
			dfs(payed,i + 1,oil - a[i + 1] / km);//不加油的情况。
			//当前开销，油还剩下（当前剩余容量 - 消耗的能量）。 
			dfs(payed + 20 + (L - oil) * cost[i],i + 1,L -  a[i + 1] / km);//加油的情况。 
			//当前开销 + 饭费 + 加油费，油还剩下（总容量 - 消耗的能量），因为在加油站里充满油了。 
		}
	}else {
		dfs(payed + 20 + (L - oil) * cost[i],i + 1,L - 	a[i + 1] / km);//要加油。 
		//当前开销 + 饭费 + 加油费，油还剩下（总容量 - 消耗的能量），因为在加油站里充满油了。 
	}
}
int main() {
	ans = 10000000.000000;//取最大值 
	cin >> dis >> L >> km >> first_cost >> n;//服务员~点单。 
	for(int i = 1;i <= n;i++) {
		cin >> s[i] >> cost[i];//再来一份 
		a[i] = s[i] - s[i - 1];//要存储的时加油站之间的路程，不是到起点的路程，用这个加油站到起点的距离-上一个加油站到起点的距离=从上一个加油站到这个加油站的距离。
	}
	a[n + 1] = dis - s[n];//将终点也加入加油站，方便操作。 
	//但cost不用赋值，本来初始化就是0。
	dfs(first_cost,1,L - a[1] / km);//深度优先搜索，开始从起点到达第一个加油站，剩余L - a[1] / km（L），开销为first_cost。 
	printf("%.1lf",ans);//嗯……是时候买单了…… 
	return 0;
}
```

---

## 作者：ljk123 (赞：4)

# 不一样的清奇思路：（动归解法）
### （~~一开始拿到这道题，压根不知道是搜索题，虽然数据很小，一看就不是动规题，但脑子一发热就想用动归解~~)
### （~~谁叫教练不开网啊！！！！<悲愤交加-ing>只能在家交题解了~~）
**当然，虽然A了这道题，但解法不一定对，请各位大佬多多指教！**
## 思路：（用之前的最小费用更新i点的最小费用）
**假设从j点到i点：**

**1.如果耗油大于一半，就直接更新i点的最小费用；**

**2.将i点看作j点与i+1点的中转站，如果耗完油箱里的油还不能到i+1站,定要到i站先加油（条件一的变化）,则更新i站的最小费用 **

**注：1·不要忘了加油要快餐费；2·每次加就加满，所以费用差就是走距离差所耗的油的钱**

**下面是丑陋的代码，请各位大佬不要喷**

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1006;
int n,t;
double ans,c,l,s,f[N],d[N],o[N],x;
//ans:答案（最小费用）,d数组(存个各加油站的距离<d[0]:起点，0;d[n+1]:终点，读入的s>)
//o数组（存到每个加油站的最小费用）,c:油箱大小 ,x:临时变量,l:每升油能跑的长度 
int main()
{
	memset(o,0x4f,sizeof(o));
	scanf("%lf%lf%lf%lf%d",&s,&c,&l,&o[0],&n);
	d[0]=0; d[n+1]=s;
	for(int i=1;i<=n;++i) scanf("%lf%lf",&d[i],&f[i]);//读入 
	for(int i=1;i<=n;++i){
		for(int j=0;j<i;++j){
			x=(d[i]-d[j])*1.0000000/l;//x代表所消耗的油 
			if(x>c*0.500000&&x<=c*1.0000)
			    o[i]=min(o[i],o[j]+(d[i]-d[j])*1.0000000/l*f[i]+20);
			//若剩油小于一半，并且能走到，就更新最小费用 
			else if(x<=c*1.0000&&(d[i+1]-d[j])*1.0000/l>c) o[i]=min(o[i],o[j]+(d[i]-d[j])*1.0000000/l*f[i]+20);
			// 将i当成中转站，若从j站出发,耗完油箱里的油还不能到i+1站,则更新i站的最小费用 
		}
	}ans=99999999.9999;
	for(int i=0;i<=n;++i){
		if(s-d[i]<=c*l) ans=min(ans,o[i]);
		else if((d[n]-d[i]<c*0.5000*l)&&(s-d[n]<=c*l+1e-6)) ans=min(ans,o[i]+(d[n]-d[i])*1.000000/l*f[n]+20);
	}//求到终点的最小费用 
	printf("%.1lf",ans); 
	return 0;
}
```
这篇题解叫搜索来说难度较大，仅仅为提供一种思路；

如果思路正确，管理员可加强一下数据

---

## 作者：贞白铁战逸 (赞：4)

# 如楼上所说，这道题要用的变量很多。。。。。。
##  做题需耐心，为便于理解，我尽量用英文标记了各个变量。 
   **回归本题，在每一个加油站只有两种决策, 加, 或不加。 **
   
   **限制条件是油量过半时不加， 所以整个dfs函数还是很好写。**
     
   **另外剪枝也很容易想， 裸的最优性剪枝。 若花费的钱已经超过最优解，回溯。**
     
   **下面是代码：**
   ```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;
int n;
double len, vmax, speed, firs, ans = 999999999;
struct node
{
	double dis, cost;
}a[100];
void dfs(int to, double gas, double money)//to为当前加油站序号， gas为当前油量， money为已花钱数 
{
	if (money > ans) return; //剪枝 
	if (to == n + 1)
	{
		ans = min(ans, money);
		return;
	}
	if (gas * speed >= a[to + 1].dis - a[to].dis) //若油够，就有两种选择 
	{
		if (gas * 2 >= vmax) dfs(to + 1, gas - (a[to + 1].dis - a[to].dis) / speed, money);//油量大于一半， 不加 
		else//不然就加或不加都搜一遍 
		{
			dfs(to + 1, gas - (a[to + 1].dis - a[to].dis) / speed, money);
			dfs(to + 1, vmax - (a[to + 1].dis - a[to].dis) / speed, money + 20 + (vmax - gas) * a[to].cost); 
		}
	}
	else 
	dfs(to + 1, vmax - (a[to + 1].dis - a[to].dis) / speed, money + 20 + (vmax - gas) * a[to].cost);//油不够， 加 
}
int main()
{
	int i, j, k, l;
	scanf("%lf", &len);//路的总长度 
	scanf("%lf %lf %lf %d", &vmax, &speed, &firs, &n);//分别是油箱最大容量， 车的“性能”， 已经花了的钱， 加油站数 
	a[0].dis = 0;
	for (i = 1; i <= n; i++)
	    scanf("%lf %lf", &a[i].dis, &a[i].cost);
	a[n + 1].dis = len;//注意把终点也标好坐标 
	dfs(1, vmax - a[1].dis / speed, firs);//开始dfs 
	printf("%.1lf", ans);
}
```

---

## 作者：DоsLikе (赞：3)

# P1180驾车旅游
### 题目描述&样例输入/输出:[这里](https://www.luogu.com.cn/problem/P1180)


初次看到本题，我想到了[旅行家的预算](https://www.luogu.com.cn/problem/P1016)这道题，当时觉得这题可能也是一个贪心。

仔细读了几遍题，哦，原来是个搜索啊。（准确来说算法标签应当加一个模拟）。

------------


### 题目思路：
根据题目描述给出的条件进行模拟：

可以分为以下几种情况

1.如果可以~~平安~~到达下一个：

(1).如果油箱里的油大于总容积的一半：不在本加油站加油

(2)如果油箱里的油小于总容积的一半：可以在本加油站加油，也可以不在本加油站加油



2.如果无法到达下一个：必须在本加油站加油


如下图所示
![描述](https://s3.ax1x.com/2020/12/18/rYL2a6.png)



------------

题目代码

```
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
double s,maxs,every,start;//总路程，容积，每升油能跑的路程，开始时的钱数 
int n;//加油站数量 
struct node{//加油站"节点" 
	double s;//该加油站距起点的距离 
	double num;//该加油站油价 
} arr[55]; 
double ans=0x3f3f3f;//先将ans赋予正无穷 
void dfs(int id,double oil,double anss){//dfs(当前加油站编号，当前油量，当前花的钱) 
	if(anss>ans)return;//如果当前花的钱已经大于当前最小值了，就可以进行剪枝 
	if(id==n+1){//总结答案 
		ans=min(ans,anss);
		return;
	}
	if(oil*every>=(arr[id+1].s-arr[id].s)){//如果当前剩下的油量足以支撑到下一个加油站 
		if(oil*2>=maxs)dfs(id+1,oil-(arr[id+1].s-arr[id].s)/every,anss);//如果当前油量大于 总容积1/2，就意味着不能在本加油站加油 
		else{//否则的话 
			dfs(id+1,maxs-(arr[id+1].s-arr[id].s)/every,anss+20+(maxs-oil)*arr[id].num);//可以加油 
			dfs(id+1,oil-(arr[id+1].s-arr[id].s)/every,anss);//也可以不加油 
		}
	}
	else{//如果不能支撑到下一个加油站 
		dfs(id+1,maxs-(arr[id+1].s-arr[id].s)/every,anss+20+(maxs-oil)*arr[id].num);//必须加油 
	}
}
int main(){
	cin>>s;
	cin>>maxs>>every>>start>>n;
	for(int i=1;i<=n;i++){
		cin>>arr[i].s>>arr[i].num;	
	}//输入 
	arr[n+1].s=s;//因为会搜到最后一个加油站节点，则最后一个+1就应当是目的地 
	dfs(1,maxs-arr[1].s/every,start);//开始进行搜索 
	printf("%.1f",ans);//输出 
	
	return 0;
} 


```


大家也一起“加油”吧！





---

## 作者：yoyiETO (赞：2)

今天期末考试了，能水一篇题解不容易呢/cy

首先定义问题的解：**每个加油站加油还是不加油**。

这样暴力枚举时间复杂度是$O(2^n)$,而$n≤50$,最大会达到$16$位数!所以需要**剪枝优化**，从题目上基本看的出来。

剪枝1：剩余油量<一半或不够到下一个加油站则加油，如果油量≥一半且能到达则不加。

剪枝2：如果现在花费 ≥已有最优方案就停止（ 第7行）

**AC Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
double l,c,k,m,a[51],b[51],ans=0x3f3f3f3f;
int n;
void dfs(int cur,double pre,double s)
{
	if(s>=ans) return;//可行性剪枝 
	if(cur>n){//到达目的地，更新ans 
		ans=s;
		return;
	}
	double dis=a[cur+1]-a[cur];//和下一个加油站的距离 
	if(pre<c/2||pre*k<dis)//加油 
		dfs(cur+1,c-dis/k,s+(c-pre)*b[cur]+20);//吃饭还有20元 
	if(pre*k>=dis)//不加油
		dfs(cur+1,pre-dis/k,s); 
}
int main()
{
	cin>>l>>c>>k>>m>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i];// a[i]为距离，b[i]为每个加油站油的单价 
	a[n+1]=l;//把终点当做一个加油站处理 
	dfs(1,c-a[1]/k,m);
	printf("%.1f",ans);//保留一位小数 
    return 0;
}
```

---

## 作者：姬海棠果 (赞：2)

本题使用回溯求解。

问题关键是加油的策略。

两个情况：

一：车里面的油不够到下一站，那么必须在本站加油。

二：车里面的油可以到很多站，那么要逐个尝试，注意油量大于一般的时候是不可以加油的，所以是尝试所以半油不可到，但是全油可到的站。

 
那么情况二就是回溯求解的状态树里面的分支。

 
【参考代码】

   
```cpp
#include<stdio.h>
int n;
double dis,cap,km,c,minc=0xFFFFFFF;
double station[51][3]={0};
void init()
{
    scanf("%lf",&dis);
    scanf("%lf%lf%lf%d",&cap,&km,&c,&n);
    for(int i=1;i<=n;i++)
        scanf("%lf%lf",&station[i][1],&station[i][2]);   
}
void dfs(int stop,double cost)
{
    if(station[stop][1]+cap*km>=dis)
    {
        if(cost<minc) minc=cost;
        return;
    }
    int num=stop+1;
    while(num<n && station[num+1][1]<=station[stop][1]+cap*km &&
            station[num][1]<=station[stop][1]+cap*km/2)  num++;
    if(num==n || station[num+1][1]>station[stop][1]+cap*km)
        dfs(num,cost+20+(station[num][1]-station[stop][1])/km*station[num][2]);
    while(num<=n && station[num][1]<=station[stop][1]+cap*km/2)
        num++;
    while(num<=n && station[num][1]<=station[stop][1]+cap*km)
    {
        dfs(num,cost+20+(station[num][1]-station[stop][1])/km*station[num][2]);
        num++;
    }
}
int main()
{
    init();
    dfs(0,c);
    printf("%.1lf\n",minc);
}
参考：http://blog.sina.com.cn/s/blog_5f50d0c20100jikc.html
```

---


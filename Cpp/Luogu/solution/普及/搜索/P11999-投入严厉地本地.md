# 投入严厉地本地

## 题目背景

在本题中，对于一个字符串 $x$，我们定义：

- $|x|$ 表示 $x$ 的长度，空字符串长度为 $0$。
- $x_{i \sim j}$ 表示 $x$ 的第 $i$ 个字符到第 $j$ 个字符按顺序连接以后形成的子串，例如 $\texttt{abcd}_{2 \sim 4} = \texttt{bcd}$。
- $y$ 是 $x$ 的前缀当且仅当存在一个 $p$ 满足 $x_{1 \sim p} = y$。
- $y$ 是 $x$ 的后缀当且仅当存在一个 $p$ 满足 $x_{p \sim |x|} = y$。

字符串的字符集是小写字母集合，即字符串仅由小写字母构成。

## 题目描述

给定两个字符串 $s, t$，和一个参数 $k$。此外有一个映射规则集合 $f = \{(\lambda_i, \gamma_i) | i = 1,2,3,\dots m\}$。其中 $\lambda_i$ 是长度为 $k$ 的字符串，$\gamma_i$ 是一个长度为 $1$ 的字符串，或一个空字符串，$\lambda_i$ 互不相同，$m$ 是映射规则的数量。

已知对于映射规则集合 $f$，$s$ 可以按如下流程生成字符串 $t$：

1. 令 $i = 1$。
2. 如果 $i > |s|$，生成结束。
3. 如果存在一个 $j \in [1, m]$ 使得 $\lambda_j$ 是 $s_{1 \sim i}$ 的后缀，则令 $t := t \circ \gamma_j$，这里 $:=$ 表示赋值，$\circ$ 表示字符串拼接。
4. 如果对任何的 $j \in [1, m]$ 都有 $\lambda_j$ 不是 $s_{1 \sim i}$ 的后缀，则令 $t:=t \circ s_{i \sim i}$。
5. 令 $i := i + 1$，返回 $2$。

现在，给定 $s$ 和由它生成的字符串 $t$，以及参数 $k$，你需要给出一个映射规则集合 $f$，使得 $s$ 按映射规则 $f$ 生成的字符串是 $t$。

## 说明/提示

### 样例 1 解释

第一组数据规则共三条（用 $\epsilon$ 表示空字符串）：
- $\texttt{abc} \to \texttt{x}$
- $\texttt{bcd} \to \epsilon$
- $\texttt{cde} \to \texttt{z}$。

过程如下：

| $s$ 的前缀 | 匹配规则 | $t$ 的变化 |
| :-: | :-: | :-:|
| $\texttt{a}$ | |$\texttt{a}$
| $\texttt{ab}$ | | $\texttt{ab}$ |
| $\texttt{abc}$ |$\texttt{abc} \to \texttt{x}$| $\texttt{abx}$|
| $\texttt{abcd} $ | $\texttt{bcd} \to \epsilon$ | $\texttt{abx}$ |
| $\texttt{abcde}$ | $\texttt{cde} \to \texttt{z}$ | $\texttt{abxz}$ |

### 数据规模与约定

- 对 $30\%$ 的数据，保证 $|s| \leq 4$，字符串只有 $\texttt{a},\texttt b$ 两个字符。
- 对 $100\%$ 的数据，保证 $1 \leq T \leq 10$，$1 \leq k \leq |s|$，$1 \leq |t| \leq |s| \leq 7$，$s,t$ 只含小写字母，数据保证存在一个数量小于 $50$ 条的映射规则使得 $s$ 可以按规则映射到 $t$。

## 样例 #1

### 输入

```
3
abcde
abxz
3
ab
a
1
ab
ab
1```

### 输出

```
3
(abc,x)
(bcd,)
(cde,z)
2
(a,a)
(b,)
1
(a,a)```

# 题解

## 作者：SnowFlavour (赞：1)

# 题意

要求将一个字符串 $S$ 的每一个前缀的长度为 $k$ 的后缀替换成一个字符得到 $T$，求可行的映射。

# 题解

注意到 $|S|$ 和 $|T|$ 都非常小，显然可以用指数或者阶乘复杂度的算法过掉。

于是我们就想到可以枚举映射关系，可是这样有点太麻烦。考虑到很多枚举的状态根本没有用处，比如一个字符串 `abcdefg`，枚举 `iakioi` 这样的后缀就根本不可能有用。

因此考虑只关注每一个后缀的映射，还是以 `abcdefg` 为例，假如 $k = 3$，我们就只用关心 `abc`，`bcd`，`cde`，`def`，`efg` 五个字符串即可。

现在考虑如果每一个字符串都映射到一个字符，那么最终的 $T$ 的长度应该和 $S$ 相等。但是 $|T| \le |S|$，因此全都映射到字符不一定可行。

但是题目要求我们可以把某一个后缀替换成空字符，这也就启发我们，只要枚举替换成空字符的后缀即可。具体而言，可以二进制枚举。

那么怎么才能算是可行的方案呢？这里，我们要考虑到本题的映射关系是多对一的，也就是多个后缀可以映射到同一个字符，但是一个后缀只能映射到一个字符。

比如说当 $S$ 为 `abab`，$T$ 为 `ac` ，$k=2$ 时，我们可以发现一种可行的映射方式为 $ab \to \epsilon$，$ba \to c$。但是如果我们令 $ab \to c$，那么在后面的时候，由于整个 $T$ 都被扫完了，所以应该有 $ab \to \epsilon$，于是出现了冲突。

因此，我们只需要枚举以后，尝试找到映射就行。一个简单的方法是用 map，当扫描到一个后缀 $x$，此时应该将这个位置映射到 $c$ 时，处理方法如下：

1. 在 map 中没有找到 $x$，直接添加一个映射 $x \to c$。
2. 在 map 中找到 $x$ 并且和 $c$ 相同，继续。
3. 在 map 中找到 $x$，但是和 $c$ 不同，这个方式不行，退出。

注意一个细节：如何区分 map 中的“空字符”和“没有映射关系”？不能直接用`\0` 作为空字符，因为如果你没有找到映射关系，map 也会返回一个 `\0`，这样就乱套了。一个简单的方式是利用一个特殊符号（比如 `*`） 代替空字符。
# 代码
```cpp
#include <bitset>
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;
template <typename T1, typename T2> using umap = unordered_map<T1, T2>;
inline string get(string s, int fr, int to) {
    string tmp = "";
    for (int i = fr; i <= to; i++) tmp.push_back(s[i]);
    return tmp;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        string s, t;
        cin >> s >> t;
        int k, n = s.size(), m = t.size();
        t = t + "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0";
        cin >> k;
        umap<string, char> mp;
        for (int i = 0; i < (1 << n); i++) {
            if (__builtin_popcount(i >> (k - 1)) != (n - m)) continue;
            // cout << bitset<7>(i) << endl;
            mp.clear();
            int pnt = k;
            for (int j = k; j <= n; j++) {
                string nw = get(s, j - k, j - 1);
                if (i & (1 << (j - 1))) {
                    if (mp[nw] && mp[nw] != '*') goto FAIL;
                    mp[nw] = '*';
                    continue;
                }
                if (mp[nw] && (mp[nw] != t[pnt - 1])) goto FAIL;
                mp[nw] = t[(pnt++) - 1];
            }
            cout << mp.size() << endl;
            for (auto it : mp) {
                if (it.second != '*') cout << "(" << it.first << "," << it.second << ")" << endl;
                else cout << "(" << it.first << "," << ")" << endl;
            }
            break;
        FAIL:;
        }
    }
}
```

---

## 作者：reinforest (赞：1)

在本文中，字符串的下标从 $0$ 开始。

已知 $|S|,|T| \leq 7$，一眼暴搜。

发现所有的操作序列中的 $\lambda$ 只能是长度为 $k$ 的 $S$ 中连续字串，因此我们可以直接忽略 $m \leq 50$ 的限制。

我们把所有可能的 $\lambda$ 存在一个结构体数组里面，然后进行暴搜。

在代码中：

- `?` 表示这个操作的 $\gamma$ 还没有确定。
- ` ` 表示这个操作的 $\gamma$ 为空。
- `*` 表示这个操作被删除。
- 其余的就是小写字母，与题目相同。

在代码中，我们首先令所有的 $\gamma$ 为 `?`。

设当前搜到 $S$ 中的第 $i$ 位，此时的生成字符串为 $now$，其长度为 $len$。

首先找到 $\lambda _{pos}$ 满足 $\lambda _{pos} = S_{i-k+1 \sim i}$ 相等，然后进行分类讨论：

- 如果不存在 $pos$ 或者 $\gamma _{pos} =$ `*`，令下一层的 $now \leftarrow now+S_i$。
- 如果 $\gamma _{pos} =$ ` `，令下一层的 $now \leftarrow now$。
- 如果 $\gamma _{pos}$ 是个小写字母，令下一层的 $now \leftarrow now + \gamma _{pos}$。此时可以加一个剪枝，判断下一层的 $now$ 是否是 $T$ 的前缀。
- 如果 $\gamma _{pos} =$ `?`，那么这个操作还没有确定，$\gamma _{pos}$ 可以为 $T_{len}$，` `，或者 `*`（当且仅当 $S_i = T_{len}$），分别进行搜索即可。

本题细节较多，码量较大。这是赛时代码，写得比较冗余。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll T,k,ocnt;
struct node{
    string l;
    char ch;
}opt[15];
string s,t;
map<string,bool> mp;
void init(){
    for(int i=0;i<15;i++){
        opt[i].l.clear();
        opt[i].ch='?';
    }
    s.clear();
    t.clear();
    mp.clear();
    ocnt=0;
}
bool ise(ll o,ll cur){
    if(cur<k)return false;
    ll len=opt[o].l.length();
    for(int i=1;i<=k;i++){
        if(s[cur-i]!=opt[o].l[len-i]){
            return false;
        }
    }
    return true;
}
bool dfs(ll dep,string nw){
    if(dep>=s.length()){
        if(nw!=t)return false;
        ll cnt=0;
        for(int i=1;i<=ocnt;i++){
            if(opt[i].ch!='?' && opt[i].ch!='*'){
                cnt++;
            }
        }
        cout<<cnt<<"\n";
        for(int i=1;i<=ocnt;i++){
            if(opt[i].ch==' '){
                cout<<"("<<opt[i].l<<",)\n";
            }else if(opt[i].ch!='?' && opt[i].ch!='*'){
                cout<<"("<<opt[i].l<<","<<opt[i].ch<<")\n";
            }
        }
        return true;
    }
    ll pos=-1;
    for(int i=1;i<=ocnt;i++){
        if(ise(i,dep+1)){
            pos=i;
        }
    }
    bool ret=false;
    if(pos==-1 || opt[pos].ch=='*'){
        ret|=dfs(dep+1,nw+s[dep]);
    }else{
        if(opt[pos].ch==' '){
            ret|=dfs(dep+1,nw);
        }else if(opt[pos].ch!='?'){
            if(nw.length()==t.length() || opt[pos].ch!=t[nw.length()])return false;
            ret|=dfs(dep+1,nw+opt[pos].ch);
        }else{
            opt[pos].ch=' ';
            ret|=dfs(dep+1,nw);
            if(ret)return true;
            if(nw.length()<t.length()){
                opt[pos].ch=t[nw.length()];
                ret|=dfs(dep+1,nw+opt[pos].ch);
                if(ret)return true;
                if(s[dep]==t[nw.length()]){
                    opt[pos].ch='*';
                    ret|=dfs(dep+1,nw+s[dep]);
                }
            }
            opt[pos].ch='?';
        }
    }
    return ret;
}
string sub(ll l,ll r){
    string ret="";
    for(int i=l;i<=r;i++){
        ret+=s[i];
    }
    return ret;
}
void work(){
    init();
    cin>>s>>t>>k;
    ll len=s.length();
    for(int i=0;i<len-k+1;i++){
        mp[sub(i,i+k-1)]=true;
//        cout<<sub(i,i+k-1)<<"\n";
    }
    for(auto it=mp.begin();it!=mp.end();it++){
        if(it->second){
            opt[++ocnt].l=it->first;
        }
    }
    dfs(0,"");
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>T;
    while(T--){
        work();
    }
    return 0;
}
/*
1
abcde
abxz
3
*/
```

---

## 作者：ydzr00000 (赞：0)

由于 $\lambda_i$ 的长度是固定为 $k$，每个 $\lambda_i$ 映射的 $\gamma_i$ 是唯一确定的，所以 $s$ 经 $f$ 映射的结果 $t$ 可以改写为如下形式：

1. 置 $t$ 为空串。
2. 将 $s$ 的前 $k-1$ 个位置追加到 $t$ 的末尾。
3. 依次对 $s$ 的每一个长度为 $k$ 的连续子串 $s_{[i,i+k-1]}$，找到是否存在 $j$ 使得 $\lambda_j = s_{[i,i+k-1]}$。如果存在 $j$，将 $\gamma_j$ 追加到 $t$ 的末尾；否则将 $s_{i+k-1}$ 追加到 $t$ 的末尾。

由于 $|\gamma_j|\leq 1$，所以对于一个子串 $s_{[i,i+k-1]}$，不存在一个与其相同的 $\lambda_j$ 时会将 $s_{i+k-1}$ 加入 $t$ 的末尾，存在与其相同的 $\lambda_j$ 且 $\gamma_j = s_{i+k-1}$ 时同样会将 $s_{i+k-1}$ 加入 $t$ 的末尾，二者的效果完全相同！

据此，我们可以得出：存在一种 $f$ 使得 $\lambda_j$ 为 $s$ 中全部长度为 $k$ 的连续子串。

证明很简单，考虑反证法。如果存在 $\lambda_j$ 使得 $s$ 不存在一个长度为 $k$ 的连续子串是 $\lambda_j$，那么这对 $(\lambda_j, \gamma_j)$ 就是无用映射，可以直接去除；如果存在一个 $s$ 中对应的长度为 $k$ 的连续子串 $s_{[i,i+k-1]}$ 没有与其相同的 $\lambda_j$，那么构建 $(\lambda_j, \gamma_j) = (s_{[i,i+k-1]}, s_{i+k-1})$ 与原 $f$ 效果相同。

设 $t'$ 为 $t$ 中从第 $k$ 个位置开始的后缀，将 $s$ 中的所有长度为 $k$ 的子串赋予一个编号，并设这些子串构成集合 $U$，设 $p_i$ 表示 $s_{[i,i+k-1]}$ 对应的编号。

先搜出 $U$ 中对应到空字符的一部分，考虑检验这样的对应方式是否合法。

按照 $v = 1, 2, \cdots, |s|-k+1$ 的顺序，同时设指针 $r = 1$。如果 $p_v$ 对应到空字符，跳过；否则 $p_v$ 会对应到 $t'_r$，同时令 $r\gets r+1$。如果 $r$ 不为 $|t'|$，那么说明长度不符合；否则，检验每一个编号是否只对应唯一的字符，而没有对应多种字符即可。

设 $n = |s| - k + 1$，则时间复杂度为 $\mathcal{O}(2^nn)$，应该可以增强到 $|s|\leq 18$。

代码就不放了，实现难度不高。

---


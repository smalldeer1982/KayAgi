# 走迷宫

## 题目描述

有一个 $m\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。

优先顺序：左上右下。**数据保证随机生成。**


## 说明/提示

数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。

## 样例 #1

### 输入

```
5 6
1 0 0 1 0 1
1 1 1 1 1 1
0 0 1 1 1 0
1 1 1 1 1 0
1 1 1 0 1 1
1 1
5 6```

### 输出

```
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)```

# 题解

## 作者：ybb756032937 (赞：127)

#C++题解

##基本思路：搜索 标记 打表 AC

###代码呈上：

```cpp
#include<iostream>//个人不建议使用万能头文件，容易报错；（本篇代码使用了，编译通不过）
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
int sum[50000][2];//用来记录每步的坐标；
int ax,ay,bx,by,k,pd;//ax，ay代表起点，bx，by代表终点，k是步数；
int cx[4]={0,-1,0,1};
int cy[4]={-1,0,1,0};//四个方向，左上右下；
bool temp[17][17];//标记：已经走过的路；
int map[17][17];//地图：1可走，0不可走；
void print()//输出函数；
{
    if(pd==0)//pd：判断是否有解，有解=1，无解=0；
    {
        pd=1; 
    }
    for(int h=0;h<=k-1;h++)
    cout<<"("<<sum[h][0]<<","<<sum[h][1]<<")"<<"->"; //输出中途步骤；
    cout<<"("<<bx<<","<<by<<")"<<endl;//输出终点；
}
void walk(int x,int y)//搜索回溯主体；
{
    if(x==bx&&y==by)//到达边界；
    {
        print();//输出解；
        return;
    }
    else
    {
        for(int i=0;i<=3;i++)
        if(map[x+cx[i]][y+cy[i]]==1&&temp[x+cx[i]][y+cy[i]]==0)//判断下一步是否可以走，一方面判断路是否可走，另一方面判断自己是否走过这条路；
        {
            temp[x][y]=1;//走过的路打上标记；
            sum[k][0]=x;
            sum[k][1]=y;//记录当前的坐标
            k++;//步数加1；
            walk(x+cx[i],y+cy[i]);
            temp[x][y]=0;
            k--;
            //回溯，这里的sum可以不用恢复；
        }
    }
}
int main()
{
    int m,n;//矩阵长宽；
    cin>>m>>n;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            cin>>map[i][j];//输入地图；
            
    cin>>ax>>ay;//起点；
    cin>>bx>>by;//终点；
    walk(ax,ay);//开始搜索；
    if(pd==0)//判断是否有解，如果没有解，输出-1；
    cout<<"-1";
    return 0;
}
```
经典的搜索题，输出增加了一个路径，当然只需要增加个二维数组也就OK了；

##题还是有一些小陷阱：

1.做题之后忘记判断是否有解；

2.题目对搜索前进的方向有要求：左上右下，对于不需要输出路径的题，方向是没有要求的，（方向可能会影响效率，但是不会影响到最后的结果）但是对于有路径的题，方向可能会影响解的顺序；

3.k（步数）是否偏移；

（以上是贴主~~费了半天力没有做对~~的错误，大牛原谅我0.0）


##这里再给大家一个基本的深搜模板：

```cpp
int search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```
###整个模板有几个地方需要注意：


1.第一个if是符合输出解的条件，第二个if是符合进一步搜索的条件；


2.下一步搜索时，不是使用return search(t+1)，直接search(t+1);（新手可能会注意不到这个关键的地方，以至于每次写完不知道为什么只得到一个答案就返回主程序了）


3.for循环之后的if可以是多个;

4.for循环边界，例如：

1>方向是四个，那么边界肯定就是4；（帖主用3，是因为从0开始的）

2>素数环需要尝试1至20，那么边界就是20；


如果想要了解更多的知识，请关注我的博客（~~觉得鄙人题解写的可以的也可以进来点个赞呐，亲~~）：https://www.luogu.org/blog/AHacker/


(近期贴主还会在博客更新**搜索**的详细解释)


---

## 作者：JCZhang (赞：55)

# 很有意思的题

好吧，我承认我是很 傻 ，在这道题上犯了很 傻 的错误！！！数组开小了，一定要注意。

其实太简单了······qwq

讲解

好吧 开始我神奇的讲解


这道题其实就是DFS暴力，跟另外一道题很像 Luogu p1605


做法跟他差不多就好


不同点差不多就是：


顺序，左上右下


要输出到达的点，而不是次数


第一个简单解决，就是这样



```cpp
    search(deep+1,x, y - 1);//left
            search(deep+1,x - 1, y);//up
            search(deep+1,x, y + 1);//right
            search(deep+1,x + 1, y);//down
```
调整顺序就行了

至於第二个问题，我一开始设了一个set数组，意在与：我到达一个可行的点，就在set数组里标记一下，到最后，我到达中终点了，也就是



```cpp
    if(x==enx&y==eny){
        show();
        return;
    }
```
调用show()函数，show()函数内我我要输出set数组的值，但是我怎么输出呐？我的set数组是一个二维数组,也就是说，走的路径不一定都是顺著走的，也就是我的很多点记录的值都不会被正确的输出，於是，在每一条输出中，我有些店的顺序错了。为了解决，我设置了两个一维数组，记录到达的点的（x，y）坐标,这样的话，就可以解决此问题了，当然，deep就是为此而设置的！！！

下面是代码，应该很好理解


    
```cpp
    #include<iostream>
    #include<algorithm>
    int map[1001][1001] = { 0 };
    int set[1001][1001] = { 0 };
    int bingx[1001] = { 0 }, bingy[1001] = { 0 };
    int m, n,begx,begy,enx,eny;
    bool binga;
    inline void show(int p) {
        binga = 1;
        for(int i=0;i<p;i++)
                std::cout <<"("<< bingx[i] << "," << bingy[i] << ")->";
        std::cout << "(" << enx << "," << eny << ")";
        std::cout << std::endl;
    }
    inline void get() {
        int i, j;
        std::cin >> m >> n;
        for (i = 1; i <= m; i++)
            for (j = 1; j <= n; j++)
                std::cin >> map[i][j];
        std::cin >> begx >> begy >> enx >> eny;
    }
    inline void search(int deep,int x, int y) {
        if (x < 1 || y < 1 || x>m || y>n) {
            return;
```
}//防止越界情況
        if (x == enx&&y == eny) {

            show(deep);

            return;

}//如果完成了一次愉快的到达，那麽就需要調用show()函數来输出路径


```cpp
        if (map[x][y] == 1) {
            bingx[deep] = x; bingy[deep] = y;
            map[x][y] = 0;//防止走重
            search(deep+1,x, y - 1);//left
            search(deep+1,x - 1, y);//up
            search(deep+1,x, y + 1);//right
            search(deep+1,x + 1, y);//down
            map[x][y] = 1;//回溯的路程
        }
    }
    int main() {
        get();
        if (map[enx][eny] == 0) {
            std::cout << "-1";
            return 0;
        }
        search(0, begx, begy);
        if (binga == 0)std::cout << "-1";
        return 0;
    }
```
** 注意：设置终点无法走的特判。**

OK,就这样吧


如果还有问题,就私信我吧



---

## 作者：okey (赞：38)

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[17][17],s[17][17],n,m,bx,by,ex,ey;
const string c[16]={"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15"};
//c用来将整数下标对应字符串的转换 
bool flag;//标记是否输出过解 
void dfs(int bx,int by,string ans){
    if(bx==ex&&by==ey){cout<<ans<<endl;flag=1;}//输出解并标记有路可走 
    int d[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//四个方向搜索 
    for(int i=0;i<4;i++){
        int x=bx+d[i][0],y=by+d[i][1];        
        if(a[x][y]==1&&s[x][y]==0){
            s[x][y]=s[bx][by]+1;//深搜 
            dfs(x,y,ans+"->"+"("+c[x]+","+c[y]+")");//将经历过的点串联起来 
            s[x][y]=0;//回溯 
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)cin>>a[i][j];
    cin>>bx>>by>>ex>>ey;s[bx][by]=1;    
    dfs(bx,by,"("+c[bx]+","+c[by]+")");//起点(bx,by) 
    if(!flag)cout<<-1<<endl;    
    return 0;
}
```

---

## 作者：Clover_INF (赞：28)

# 这是一道基础的深搜的题
## 本题其实并不难，但我实际上交了第2遍才过，下面列出本题的大坑。
1.如果没有解要输出-1。

2.搜索前进的方向要遵循左上右下的优先顺序。


其实深搜可以写成两种形式，递归和递推形式，但实际上本人跟喜欢递归形式的，因为它好些，方便查错，易于理解。

下面附上基本的回溯模板

```cpp
void search(int t)
{
    if(满足输出条件)
    {
        输出解;
    }
    else
    {
        for(int i=1;i<=尝试方法数;i++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                search(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```

所以我们现在就只需要解决输出和回溯的方法。

本题不同于洛谷P1605 迷宫，要输出路径，所以要开一个数组记录一下节点，考录到二维数组太浪费空间。我开了一个结构体，记录了当下x,y的坐标。

```cpp
struct node
{
	int x, y;
} b[197];
```
因为不能重复，所以我们可以把走过的路“堵上墙”，还有数组不能越界，可以像这样判断
```cpp
if(! a[x1][y1] && x1 >= 1 && x1 <= n && y1 >= 1 && y1 <= m) {
			if(x1 == x2 && y1 == y2) total++;
			else search(k + 1, x1, y1, x2, y2, n, m);
		}
```
但实际上为了代码的简易程度，我们大可不必这样做。大家都玩过森林冰火人走迷宫吧，我们为什么不能像它那样在最外围搞堵墙呢。

然后附上题解。

```cpp
#include<cstdio>
struct node
{
	int x, y;
} b[197];
int a[16][16], x[4] = {0, -1, 0, 1}, y[4] = {-1, 0, 1, 0}, flag;
//x[],y[]是行走的方式，flag是是否有解的标志。

void print(int n)
{
	flag = 1;
	for(int i = 1; i <= n; i++)
	{
		if(i < n) printf("(%d,%d)->", b[i].x, b[i].y);
		else printf("(%d,%d)\n", b[i].x, b[i].y);
	}
}

void search(int n, int x1, int y1, int x2, int y2)
{
	for(int i = 0; i < 4; i++)
	{
		a[x1][y1] = 0;//堵墙
		x1 += x[i];
		y1 += y[i];
		if(a[x1][y1]) {
			b[n].x = x1;
			b[n].y = y1;
			if(x1 == x2 && y1 == y2) print(n);
			else search(n + 1, x1, y1, x2, y2);
		}
		x1 -= x[i];
		y1 -= y[i];
		a[x1][y1] = 1;//回溯
	}
}

int main()
{
	int n, m, x1, y1, x2, y2;
	scanf("%d%d", &m, &n);
	for(int i = 1; i <= m; i++)
	    for(int j = 1; j <= n; j++)
	        scanf("%d", &a[i][j]);
	scanf("%d %d\n%d %d", &x1, &y1, &x2, &y2);
	b[1].x = x1; b[1].y = y1;
	search(2, x1, y1, x2, y2);
	if(! flag) printf("-1");
	return 0;
}
```


---

## 作者：MoXiaodu (赞：10)

### 前言
>记得这是我第一篇写的题解了（没过），那时候我只是一个可耐的小萌新（虽然现在也是），我一定要弥补这段空缺！

------------
### 题目描述

有一个$m* n$格的迷宫(表示有$m$行、$n$列)，其中有可走的也有不可走的，如果用$1$表示可以走，$0$表示不可以走，文件读入这$m* n$个数据和起始点、结束点(起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号)。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息(用$-1$表示无路)。

优先顺序：$左上右下$

------------
### 思路：
看完题目，发现要输出路径，当然用DFS好点啦（规定了顺序）。所以我们只需要根据题目意思进行DFS就OK惹（在搜索过程中记录路径）

下面看到代码！
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int m,n,q1,q2,z1,z2,num[8005][2],h[5]={0,0,-1,0,1},l[5]={0,-1,0,1,0};
//num：路径存储 h：行移动 l:列移动（按题目顺序）q：起点 z：终点
int c=1,yes=0;
//c:层数 yes：有没有走到终点
bool a[20][20],b[20][20];//a：地图 b：是否走过
void print(int ww)//输出路径
{
	for(int i=1;i<ww;i++)
	{
		cout<<"("<<num[i][1]<<","<<num[i][2]<<")"<<"->";
	}
	cout<<"("<<num[ww][1]<<","<<num[ww][2]<<")"<<endl;
}
void ss()
{
	if(num[c][1]==z1&&num[c][2]==z2)//如果到了终点就输出路径
	{
		yes=1;print(c);return;
	}
	for(int i=1;i<=4;i++)
	{
		//从四个方向找
		if(num[c][1]+h[i]>=1&&num[c][2]+l[i]>=1&&num[c][1]+h[i]<=m&&num[c][2]+l[i]<=n)
		{
			if(a[num[c][1]+h[i]][num[c][2]+l[i]]==1&&b[num[c][1]+h[i]][num[c][2]+l[i]]==0)//可以走
			{
				b[num[c][1]+h[i]][num[c][2]+l[i]]=1;
				num[c+1][1]=num[c][1]+h[i];num[c+1][2]=num[c][2]+l[i];c++;
				ss();
				b[num[c][1]][num[c][2]]=0;c--;//回溯
			}
		}
	}
}

int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		cin>>a[i][j];
	}//读入地图
	cin>>q1>>q2>>z1>>z2;
   //读入起点与终点
	num[1][1]=q1;num[1][2]=q2;
	b[q1][q2]=1;
	ss();//搜索
	if(yes==0)cout<<"-1";//没有找到任何一个路劲输出"-1"
	return 0;
}
```


---

## 作者：梦回还 (赞：8)

赛后一个月练练stl挺好的（那个……我跟楼下是一伙的，不是砸场子的！）

一个淳朴的大暴力被我玩成了花，现场教学如何重定义运算符qwq~

（Ps：为我的好基友打个call，想用轻松水过的请转楼下）



```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct Point{
    int x,y;
    Point(int x=0,int y=0):x(x),y(y){}//这是先将Point中的x和y初始化成零，后面的Point（）就是默认0，如果有值比如说Point（1，0）就是把申明变量中的x变为1，y赋为0
};
Point p[5],st[300];//一个方位数组，一个栈存取先前结果
int n,m,top;
bool f[16][16],book[16][16],pre;//标记迷宫与是否走过
Point s,t;//起点终点不解释
istream& operator >> (istream &in,Point &a)
{
    in >> a.x >> a.y;
    return in;
}
//重定义>>运算符为读入Point的x，y值并返回
ostream& operator << (ostream &out,Point &a)
{
    out << "(" << a.x << "," << a.y << ")" ;
    return out;
}
//重定义<<运算符为输出Point的x，y值并带好括号与标点
Point operator + (const Point &a,const Point &b){
    Point c(a.x+b.x,a.y+b.y);
    if(c.x>0&&c.x<=n&&c.y>0&&c.y<=m&&!book[c.x][c.y]&&f[c.x][c.y]) return c;
        else return Point();
}
//高端操作，将判断条件内置与两个Point的和中，如果不符合就强制返回（0，0）
bool operator == (const Point &a,const Point &b){
    return a.x==b.x&&a.y==b.y;
}
//重定义==为两个Point完全相等
void dfs(Point x)
{
    if(x==Point()) return;//把重置为0的点滤掉
    st[++top]=x;
    book[x.x][x.y]=1;
    if(x==t)
    {
        pre=1;//不要忘记-1的情况！！！
        cout << st[1];
        for(int i=2;i<=top;i++)
            cout << "->" << st[i];
        cout << "\n";
        book[x.x][x.y]=0;top--;
        return;
    }
    for(int i=0;i<4;++i)
        dfs(x+p[i]);
    book[x.x][x.y]=0;top--;
}
//重定义完直接使用，美滋滋
int main()
{
    p[0]=Point(0,-1);
    p[1]=Point(-1,0);
    p[2]=Point(0,1);
    p[3]=Point(1,0);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            scanf("%d",&f[i][j]);
    cin >> s >> t;
    dfs(s);
    if(!pre) printf("-1");
}
```

---

## 作者：_n_u_l_l_ (赞：8)

# C++ DFS
## 典型的搜索题，使用深搜就可解决

### 一般情况
首先看题，在不考虑输出路径的情况下这就是一个**普通的搜索**。

对于一般情况来说我们只需要对当前位置向四周搜索就行了。

这时我们需要考虑3点：
1.对于达到终点的情况；
2.对于该点是否能走的情况

对于1.这是我们~~递龟~~递归的终点，在到达这里时便可以结束搜索

而对于2.我们要判断该点是否可走。对于迷宫中的0和已走过的点（避免单一路径中重复输出）不能走，因此使用一个二维数组来存放。

以下代码
```cpp
void dfs(int x,int y)
{
    if(x==ex&&y==ey)
    {
      //到达终点
    }
    for(int i=0;i<4;i++)
    {
        if(vis[x+mx[i]][y+my[i]]==1)//判断该点可走
            continue;
        vis[x+mx[i]][y+my[i]]=1；//标记
        dfs(x+mx[i],y+my[i]);
        vis[x+mx[i]][y+my[i]]=0;//删除标记，方便下次搜索
    }
}
```


------------

### 对于路径储存
我们通过看题目还可以知道：

本题目除了常规的深搜外还要**记录搜索路径**。因此我们使用Vector来存储（相当于一个可以伸缩的数组）。

我们将每一个搜索的点都放入数组中，退出时删除。
在搜到重点时输出
以下代码
```cpp
#include<iostream>
#include<cstdio>
#include<vector>

using namespace std;

const int mx[4]={0,-1,0,1}；//搜索方向
const int my[4]={-1,0,1,0};

int m,n;//迷宫大小
int sx,sy,ex,ey;//起点终点
bool flag=0;
bool map[20][20]={{0},{0}};//迷宫
bool vis[20][20]={{0},{0}};//判断可走

vector <int> px;//存放路径
vector <int> py;

void ini();
void dfs(int x,int y)
{
    if(x==ex&&y==ey)//到达终点
    {
        flag==1?printf("\n"):flag=1;
        for(unsigned int i=0;i<px.size()-1;i++)//顺序输出
        {
            cout<<"("<<px[i]<<","<<py[i]<<")"<<"->";
        }
        cout<<"("<<ex<<","<<ey<<")";
    }
    for(int i=0;i<4;i++)
    {
        if(vis[x+mx[i]][y+my[i]]==1)
            continue;
        vis[x+mx[i]][y+my[i]]=1;
        px.push_back(x+mx[i]);//加入队列
        py.push_back(y+my[i]);
        dfs(x+mx[i],y+my[i]);
        vis[x+mx[i]][y+my[i]]=0;
        px.pop_back();
        py.pop_back();
    }
}

int main()
{
    ini();
    dfs(sx,sy);
    if(!flag)//判断是否有路
        printf("-1");
    return 0;
}

void ini()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            int temp;
            scanf("%d",&temp);
            map[i][j]=(temp==1?true:false);
            if(map[i][j]==0)vis[i][j]=1;
        }
        getchar();
    }
    scanf("%d%d",&sx,&sy);
    getchar();
    scanf("%d%d",&ex,&ey);
    for(int i=0;i<=m+1;i++)
        vis[i][0]=1,vis[i][n+1]=1;
    for(int i=0;i<=n+1;i++)
        vis[0][i]=1,vis[m+1][i]=1;
    px.push_back(sx);
    py.push_back(sy);
    vis[sx][sy]=1;
    cerr<<"finish";
}
```


---

## 作者：Karry5307 (赞：7)

### 个人评估：这是一道练习STL(Standard Template Library,即标准模板库)的好题，现场演示容器的使用方法
# 算法：DFS,DFS,DFS!
#### 先展示一下一些容器的定义
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
list<pii>l;
list<pii>temp;
list<pii>ntemp;
map<pii,bool>mmap;
```
为了简便，这里利用了typedef弄了一下，创建了三个list容器，一个用来储存解，两个副本，还创建了一个map，即映射表容器，记录一个坐标是否被走过。
#### 普通变量定义篇
```cpp
int vx[4]={0,-1,0,1},vy[4]={-1,0,1,0};
int length,width,startx,starty,endx,endy;
bool mp[15][15],has_solution;
```
vx，vy记录了横纵坐标，注意搜索方向！！！length，width记录地图的长度和宽度，startx，starty记录了起点坐标，endx，endy记录了终点，mp记录地图，has_solution记录有解与否
#### 普通函数篇
```cpp
inline bool isin(int minn,int num,int maxn)
{
	return num>=minn&&num<=maxn;	
}
inline void print_path()
{
	has_solution=1;
	while(!l.empty())
	{
		temp.push_back(l.front());
		ntemp.push_back(l.front());
		l.pop_front();
	}
	while(!ntemp.empty())
	{
		l.push_back(ntemp.front());
		ntemp.pop_front();
	}
	while(temp.size()!=1)
	{
		cout<<'('<<temp.front().first<<','<<temp.front().second<<")->";
		temp.pop_front();	
	}
	cout<<'('<<temp.front().first<<','<<temp.front().second<<")\n";
	temp.pop_front();
}
```
isin函数判断书否越界，print_path输出解，注意！这里使用了两个副本，副本的使用见P1019单词接龙题解，如果能输出解，就证明有解，第一个while中，将解拷贝到两个副本里，第二个while将副本拷贝回来，最后一个while输出了解。大家也可以试试迭代器。qwq......
#### dfs篇
```cpp
inline void dfs(int x,int y)
{
	int xx,yy;
	for(register int i=0;i<4;i++)
	{
		xx=x+vx[i];
		yy=y+vy[i];
		if(isin(1,xx,length)&&isin(1,yy,width)&&!mmap[make_pair(xx,yy)]&&mp[xx][yy])
		{
			l.push_back(make_pair(xx,yy));
			mmap[make_pair(xx,yy)]=1;
			if(xx==endx&&yy==endy)
			{
				print_path();
			}
			else
			{
				dfs(xx,yy);
			}
			mmap[make_pair(xx,yy)]=0;
			l.pop_back();
		}
	}
}
```
xx，yy是记录新的坐标的变量，if中说的是xx，yy不越界，且此坐标没走过，并且可以走。后面是经典的回溯，即STL容器的回溯，学过DFS的大佬们都知道的。。。。
#### 主程序篇
```cpp
int main()
{
	cin>>length>>width;
	for(register int i=1;i<=length;i++)
	{
		for(register int j=1;j<=width;j++)
		{
			cin>>mp[i][j];
		}
	}
	cin>>startx>>start>>endx>>endy;
	l.push_back(make_pair(startx,starty));
	mmap[make_pair(startx,starty)]=1;
	dfs(startx,starty);
	if(!has_solution)
	{
		cout<<-1;
	}
} 
```
首先输入长度和宽度和地图，再输入起点终点坐标，接着处理了起点，进行了dfs，最后特判，如果没有解，输出-1！

---

## 作者：Horizon20182201 (赞：6)

  蒟蒻第一次发题解，有点小紧张······
  
  这题用搜索，深搜宽搜都能做
  
  ~~我比较喜欢深搜，所以我就用的它~~
  
  这道题的思路是
  
  1、从起始点开始
  
  2、依次深搜（每一步的坐标都要标记）
  
  3、到达目的地（但有时候还不能到）
  
  4、输出每一步坐标
  
  以下是代码，代码里会有较为详细的介绍呢qwq
  
```
#include<bits/stdc++.h>
using namespace std;

int mmap[20][20],//地图 
	m,n,//地图尺寸 
	a,b,//起始点坐标 
	c,d,//终止点坐标 
	s1[120],s2[120],//记录每一步的坐标 
	sum=1,//走的步数 
	dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//四个方向 

bool flag=false;//判断有没有可行的路 

void dfs(int x,int y){//深搜 
	if ((x==c)&&(y==d))//如果到达了目的地 
	{
		cout<<"("<<s1[0]<<","<<s2[0]<<")";//输出起始点 
		for (int i=1;i<sum;i++)
		  cout<<"->("<<s1[i]<<","<<s2[i]<<")";//输出每一步 
		cout<<endl;
		flag=true;//表示有可行的路 
		return;//返回 
	}
	else//如果没有到达 
	{
		for (int i=0;i<4;i++)//尝试四种方向 
		{
			int xx=x+dir[i][0],yy=y+dir[i][1];//新坐标 
			if (mmap[xx][yy]!=0)//如果新坐标有用 
			{
				mmap[xx][yy]=0;//标记已走过 
				s1[sum]=xx;s2[sum]=yy;//记录新坐标 
				sum++;//多走一步 
				dfs(xx,yy);//继续深搜 
				sum--;//回溯 
				mmap[xx][yy]=1;//取消标记 
			}
		}
	}
}

int main()
{
	cin>>m>>n;//输入 
	for (int i=0;i<=m+1;i++)//打边框 
	  for (int j=0;j<=n+1;j++)
	    mmap[i][j]=0;
	for (int i=1;i<=m;i++)//输入 
	  for (int j=1;j<=n;j++)
	    cin>>mmap[i][j];
	cin>>a>>b>>c>>d;//输入 
	mmap[a][b]=0;//起始点标记 
	s1[0]=a;s2[0]=b;//起始点坐标标记 
	dfs(a,b);//开始深搜 
	if (!flag)//如果没有可行的路 
	  cout<<"-1"<<endl;
	return 0;
}
```
  其实吧，你也可以选择不打边框，但你就会多许多判断语句
 
  但我个人还是选择了打边框（即使它会占用一定时间与空间）
  
  因为我觉得，C++也是一门语言，它也有属于它的文学美，在保证性能的前提下，我们也要像写作文一样，让我们的代码更富美感。
  
  ~~QAQ~~

---

## 作者：Kelin (赞：4)

方向    上左右下


```cpp
#include<bits/stdc++.h>
#define r(i,a,b); for(i=a;i<=b;i++)
using namespace std;
int a[20][20],xy[300][3],s,x2,y2;
int print(int t)
{
```
int q
```cpp
    r(q,1,t-1)    printf("(%d,%d)->",xy[q][1],xy[q][2]);
    printf("(%d,%d)\n",x2,y2); 
}
void f(int i,int j,int t)
{
    if(!a[i][j])    return;
    if(i==x2&&j==y2)    {s=1;print(t);return;}
    xy[t][1]=i;xy[t][2]=j;a[i][j]=0;
    f(i-1,j,t+1);
    f(i,j-1,t+1);
    f(i,j+1,t+1);
    f(i+1,j,t+1);
    xy[t][1]=0;xy[t][2]=0;a[i][j]=1;
}
int main()
{
    int i,j,n,m,x1,y1;
    cin>>n>>m;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            cin>>a[i][j];
    cin>>x1>>y1>>x2>>y2;
    f(x1,y1,1);
    if(!s)    printf("-1");
return 0;
}
```

---

## 作者：jhdonghj (赞：3)

#### **基本思路：dfs**

这题感觉就基本上裸dfs修改一下限制条件之后再写个输出函数和路径数组就好了

感觉我的代码可读性还不错，过来分享一波

```cpp
#include<bits/stdc++.h>
using namespace std;

struct point	//结构体存储点信息
{
	int x, y;
}st, ed;
int m, n, mp[15][15], vis[15][15];		//mp为地图,vis为访问标记
int sd[4][2] = { {0,-1},{-1,0},{0,1},{1,0} };		//注意前后顺序，左上右下
bool cango = false;		//有解标记
vector<point> step;		//路径数组

bool operator==(point a, point b) {		//为了代码可读性用重载运算符
	return a.x == b.x && a.y == b.y;
}

void print() {
	cout << '(' << step[0].x << ',' << step[0].y << ')';
	for (int i = 1; i < step.size(); i++) {
		cout << "->(" << step[i].x << ',' << step[i].y << ')';
	}
	cout << endl;
	return;
}

bool check(point a) {		//判断传入点能否走通
	return 1 <= a.x && a.x <= m && 1 <= a.y && a.y <= n &&
		!vis[a.x][a.y] && mp[a.x][a.y];
}

void dfs(point a) {
	if (a == ed) {
		cango = true;	//标记有解
		print();		//输出
		return;
	}
	point tmp;
	for (int i = 0; i < 4; i++) {
		tmp.x = a.x + sd[i][0], tmp.y = a.y + sd[i][1];
		if (check(tmp)) {
			//执行下一次搜索，并标记相关数据
			step.push_back(tmp);
			vis[tmp.x][tmp.y] = 1;
			dfs(tmp);
			vis[tmp.x][tmp.y] = 0;
			step.pop_back();
		}
	}
	return;
}

int main() {
	//输入
	cin >> m >> n;
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++)
			cin >> mp[i][j];
	cin >> st.x >> st.y >> ed.x >> ed.y;
	//dfs开始
	vis[st.x][st.y] = 1;
	step.push_back(st);
	dfs(st);
	//判断是否有解,无解输出-1
	if (!cango)
		cout << -1 << endl;
	return 0;
}
```


---

## 作者：YUANJI_THE_NOOB (赞：3)

# DFS是不可战胜的！！！
代码很烦，但适合新手。
废话不说，直接上代码：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int m,n,sx,sy,ex,ey,flag;
int matrix67[105][105];//地图
int book[105][105];//标记数组
int next[4][2]={{0,-1},
				{-1,0},
				{0,1},
				{1,0}};//枚举方向
int nx[1005],ny[1005];//记录路径
void dfs(int x,int y,int step){
	int p,i,j;
	int tx,ty;
	if(x==ex&&y==ey){//判断是否到达
		p=step;
		flag=1;
		cout<<"("<<sx<<","<<sy<<")";//输出起点
		for(j=1;j<p;j++)
			cout<<"->("<<nx[j]<<","<<ny[j]<<")";
     //输出路径中每一个点
		cout<<endl;
		return;//返回
	}
	for(i=0;i<4;i++){
		tx=x+next[i][0];
		ty=y+next[i][1];
  		//计算下一个点的坐标
		if(tx<1||tx>m||ty<1||ty>n)
			continue;
  		//判断越界
		if(matrix67[tx][ty]==1&&book[tx][ty]==0){
			book[tx][ty]=1;
			nx[step]=tx;ny[step]=ty;
  			//标记走过
			dfs(tx,ty,step+1);//尝试下一个点
			book[tx][ty]=0;
			nx[step]=0;ny[step]=0;
  			//取消标记
		}
	}
	return;
}
int main(){
	 int i,j;
    cin>>m>>n;
    for(i=1;i<=m;i++)
    	for(j=1;j<=n;j++)
    		cin>>matrix67[i][j];
    cin>>sx>>sy>>ex>>ey;//输入
    book[sx][sy]=1;//标记起点，以免重复
    dfs(sx,sy,1);
    if(!flag)cout<<"-1"<<endl;//特判
	 return 0;
}
```


---

## 作者：公主殿下MIKU (赞：2)

很水的一道dfs题，只需在搜索过程中加个数组记录路径就行
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,x[180],y[180];
int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//方向左上右下的顺序
bool b[16][16];
int nx,ny,fx,fy;
int a[16][16];
bool flag;
void dfs(int sx,int sy,int k)//sx,sy表示现在走到的位置，k表示现在走的步数
{
    x[k]=sx;
    y[k]=sy;
    if(sx==fx&&sy==fy)//走到终点，将路径输出
    {
        flag=1;//有解，标记
        cout<<'('<<x[1]<<','<<y[1]<<')';
        for(int i=2;i<=k;i++)
        cout<<"->("<<x[i]<<','<<y[i]<<")";
        cout<<endl;
        return ;
    }
    for(int i=0;i<=3;i++)//四个方向,用数组应该比4个dfs好看吧
    {
        nx=sx+dir[i][0];
        ny=sy+dir[i][1];;
        if(nx<=0||nx>n||ny>m||ny<=0||!a[nx][ny]||b[nx][ny]) continue;//判断越界
        b[sx][sy]=1;
        dfs(nx,ny,k+1);
        b[sx][sy]=0;
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    cin>>a[i][j];
    cin>>nx>>ny>>fx>>fy;
    dfs(nx,ny,1);
    if(!flag) cout<<-1;
    return 0;
}
```

---

## 作者：夏色祭 (赞：2)

#大难（shui）题

#这难度是假的吧！！！辣眼睛！！！

#这大概是最基础的dfs了（可为毛通过率连三分之一都不到）

以上属于个人吐糟，请无视

#华丽丽的分割线

**---------------------------------------------------------------------------------**

裸的dfs，用dfs去遍历每条路，在这过程中用两个数组记录下坐标，再用一个数组记录当前点有没有去过（当然障碍一开始就要赋成去过），然后每到新的一个点就把上一个点赋成去过，就这样每次往四个方向(具体方向的排列，请看楼下的题解)拓展，直到到达终点，然后输出。

AC代码：

```cpp
const
  x:array[1..4]of longint=(0,-1,0,1);
  y:array[1..4]of longint=(-1,0,1,0);//四个方向
var
  b:array[0..16,0..16]of boolean;
  p,q:array[0..1000]of longint;
  n,m,i,j,zz,x1,y1,x2,y2:longint;
  pd:boolean;
procedure print(x:longint);
var
  i:longint;
  begin
    write('(',x1,',',y1,')->');
    for i:=1 to x-1 do 
      write('(',p[i],',',q[i],')->');
    writeln('(',x2,',',y2,')');//最后一个点要单独输出
  end;
procedure try(k,l,r:longint);
var
  t,i,j:longint;
  begin
    if (l=x2)and(r=y2) then //到达终点
      begin
        pd:=true;
        print(k-1);//输出
        exit;
      end;
    for t:=1 to 4 do 
      begin
        i:=l+x[t];
        j:=r+y[t];
        if not b[i,j] then continue;//如果已经去过就不能再去了
        b[l,r]:=false;//把当前点赋成去过
        p[k]:=i;
        q[k]:=j;//记录路径
        try(k+1,i,j);
        b[l,r]:=true;
        p[k]:=0;
        q[k]:=0;//回溯
      end;
  end;//dfs
begin
  readln(n,m);
  for i:=1 to n do 
    begin
      for j:=1 to m do 
        begin
          read(zz);
          if zz=1 then b[i,j]:=true;
        end;
      readln;
    end;
  readln(x1,y1,x2,y2);
  for i:=0 to m+1 do 
    begin
      b[0,i]:=false;
      b[n+1,i]:=false;
    end;
  for i:=0 to n+1 do 
    begin
      b[i,0]:=false;
      b[i,m+1]:=false;
    end;//把外围一圈围上障碍，防止出界
  pd:=false;
  try(1,x1,y1);
  if not pd then write(-1);//不能到达则输出-1
end.
```

---

## 作者：Actinoi (赞：1)

这个题就是一个经典的DFS题目。注释比较多，就不详解了。欢迎各位大佬对代码批评指正。
```c
//by Actinoi
//2018-12-16
#include <iostream>
using namespace std;
struct node{
	int x,y;
};
node path[226];//定义结构体存储路径 
int a[16][16]; //存储迷宫 
int dx[4]={0,-1,0,1};
int dy[4]={-1,0,1,0};
int cnt;//记录path的当前下标 
int ans=0;//存储答案 
int m,n,startx,starty,endx,endy;//m*n格的迷宫以及起点与终点的坐标 
bool cango(int x,int y){//判断是否能走 
	if(x>=1&&x<=m&&y>=1&&y<=n&&a[x][y]){//判断是否出界并判断值 
		return true;
	}
	return false;
}
void print(){//输出函数 
	cout<<"("<<path[1].x<<","<<path[1].y<<")";//输出起点 
	for(int i=2;i<=cnt;i++){
		cout<<"->("<<path[i].x<<","<<path[i].y<<")";//输出余剩路径 
	}
	cout<<endl; 
}
void DFS(int x,int y){
	if(x==endx&&y==endy){//到达终点 
		ans++;
		print();//打印路径 
		return;
	} 
	for(int i=0;i<4;i++){//左上右下走 
		int nx=x+dx[i];
		int ny=y+dy[i];//原始量加偏移量
		if(cango(nx,ny)){//判断是否能走 
			a[nx][ny]=0;//标记，避免走重复
			int temp=cnt;//记录cnt
			cnt++; 
			path[cnt].x=nx;
			path[cnt].y=ny;//存储路径
			DFS(nx,ny);
			a[nx][ny]=1;//恢复现场，避免影响其它方案 
			cnt=temp;//恢复现场 
		}  
	}
}
int main(){
	cin>>m>>n;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];//读入棋盘 
		}
	}
	cin>>startx>>starty>>endx>>endy;//读入起点与终点坐标 
	a[startx][starty]=0;//避免重复走起点 
	cnt++;
	path[cnt].x=startx;
	path[cnt].y=starty;
	DFS(startx,starty);
	if(ans==0){//没有一条可行的路则输出-1
		cout<<-1;
	}
	return 0;
}
```

---

## 作者：Enderturtle (赞：1)

本蒟蒻又来发题解了

emm
我看楼上的大佬用stl都是重载

那我就用题解里没有并且不用重载的stack来做吧

（细节在代码中）

```cpp
#include<bits/stdc++.h>
using namespace std;

bool flag=false;
bool ma[15][15];
int a[15][15];
int newx[]={0,-1,0,1};//注意题目描述,顺序左上右下
int newy[]={-1,0,1,0};
int s,t;
int qq=0;
pair<int,int> p;//pair用来储存坐标
stack<pair<int,int> > q;//q表示目前的从起点开始的所有的坐标的stack
stack<pair<int,int> > st;//倒瓶stack,下面会说

void dfs(int x, int y)
{
    ma[x][y]=true;
    p.first=x;
    p.second=y;
    q.push(p);//这里可以用make_pair代替
    if(x==s&&y==t)
    {
        flag=true;
        if(qq!=0) cout<<endl;
        qq++;//这个可以无视233，纯粹只是为了让最后一行不输出回车
        while(!q.empty())
        {
            st.push(q.top());//先将q的所有元素倒瓶到st里,保证有序
            q.pop();
        }
        while(st.size()>1)//因为起点是没有->的,所以>1
        {
            cout<<'('<<st.top().first<<','<<st.top().second<<')'<<"->";//有序输出
            q.push(st.top());//再倒回到q栈里，回复原有序列，即栈顶为最新到达的坐标（当然，这里终点就不放进去了）
            st.pop();//清空st栈
        }
        cout<<'('<<st.top().first<<','<<st.top().second<<')';
        st.pop();//终点输出完毕
        ma[x][y]=false;
        return;        
    }
    for(int i=0;i<4;i++)//标准DFS
    {
        int nx=x+newx[i];
        int ny=y+newy[i];
        if(a[nx][ny]==1 && ma[nx][ny]==false)
        {
            dfs(nx,ny);
        }
    }
    q.pop();//别忘了这里需要回溯清空
    ma[x][y]=false;
    return;
}

int main()
{
    int n,m;
    scanf("%d%d",&m,&n);
    for(int i=0;i<=(n+1);i++)//不用判断边界的写法
    {
        ma[0][i]=true;
        ma[m+1][i]=true;
    }
    for(int i=0;i<=(m+1);i++)//不用判断边界的写法x2
    {
        ma[i][0]=true;
        ma[i][n+1]=true;
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
        }
    }
    int x,y;
    scanf("%d%d",&x,&y);
    scanf("%d%d",&s,&t);
    dfs(x,y);
    if(flag==false) cout<<-1;//flag标记
    return 0;
}
```
其实倒瓶的stack可以通过封装完成~~（然而本蒟蒻并不会stack的封装，只会倒瓶）~~有兴趣的同学可以百度

最后一句话，stl是真的好用~~（C++选手不用白不用）~~


---

## 作者：陈昶旭 (赞：1)

解决方案：

1.肯定是搜索(dfs/bfs)

2.有四个方向

3.定义dx[]和dy[](详见代码)

4.先定义各种奇奇怪怪的东西

5.然后再打一下打印过程

6.开始搜索

7.注意方向及顺序

8.坐标分为横坐标和纵坐标

9.所以用struct好一些(或者用pair<int,int>)

10.搜索时按照四个方向

11.对于每个方向，要递归一下

12.不要忘了回溯

13.注意搜索时坐标有条件，map数组也有条件(详见代码)

14.主函数别忘了初始化

15.提交，WA，前两个点错了

16.为什么为什么(要判断，定义一个flag)

17.最后输出-1

18.提交，AC

奉上代码


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int dx[4]={0,-1,0,1};
int dy[4]={-1,0,1,0};
struct Find_Way
{
    int x,y;
};
Find_Way s,t,way[1001];
int map[16][16],cnt;
int n,m;
bool flag;
void print()
{
    flag=1;
    printf("(%d,%d)",s.x,s.y);
    for(int i=1;i<=cnt;i++) printf("->(%d,%d)",way[i].x,way[i].y);
    printf("\n");
    return;
}
void dfs(Find_Way k)
{
    int i,j;
    if(k.x==t.x&&k.y==t.y)
    {
        print();
        return;
    }
    for(i=0;i<4;i++)
    {
        int x1=k.x+dx[i],y1=k.y+dy[i];
        if(x1>=1&&x1<=m&&y1>=1&&y1<=n&&map[x1][y1])
        {
            cnt++;
            way[cnt].x=x1;
            way[cnt].y=y1;
            map[x1][y1]=0;
            dfs(way[cnt]);
            map[x1][y1]=1;
            cnt--;
        }
    }
    return;
}
int main()
{
    int i,j;
    scanf("%d%d",&m,&n);
    for(i=1;i<=m;i++)
    for(j=1;j<=n;j++)
    scanf("%d",&map[i][j]);
    scanf("%d%d",&i,&j);s.x=i;s.y=j;
    scanf("%d%d",&i,&j);t.x=i;t.y=j;
    map[s.x][s.y]=0;
    dfs(s);
    if(!flag) printf("-1\n");
    return 0;
```
}//一道简单的dfs，为什么是普及/提高-

---

## 作者：租酥雨 (赞：1)

1、搜索方向：左上右下

2、起点终点相同时输出-1

3、起始点记得保存，并设置为不可用

以上三点在讨论里面已经有大神讲得很清楚了，大家一定要注意，越是难度比较低的题目，大家就越是要注重细节。

因为是求所有路径也不求最短路径所以自然是DFS，用map数组存放地图信息，用vis数组表示该点是否有走过。注意！DFS一定要回溯！

有一个问题是如何存储路径，我的想法就是开一个二维数组存放，搜到终点时写一个函数来控制输出，也就是把这个数组打出来就好了。这里不需要回溯，因为这并不表示一个状态，在之后原路径会被新的数据覆盖。

然后就是状态表达，写4个DFS自然会影响程序的可阅读性，所以可以用两个数组存放每一步的状态变化，直接for循环枚举就好了。

（这道题是真心简单我觉得我讲的很耐心了）

以下是代码





        


```cpp
#include<cstdio>
#define rg register
using namespace std;
int rex[300],rey[300];
int n,m;
int x1,y1,x2,y2;
int map[16][16];
bool vis[16][16];
int u[4]={0,-1,0,1},v[4]={-1,0,1,0};
bool ans;
inline int gi()
{
    int x=0;
    char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
inline void print(int x)
{
    printf("(%d,%d)",x1,y1);
    for (rg int k=2;k<=x;k++)
      printf("->(%d,%d)",rex[k],rey[k]);
    printf("\n");
    ans=true;
}
inline void dfs(int i,int j,int t)
{
    for (rg int k=0;k<4;k++)
    {
        rg int x=i+u[k],y=j+v[k];
        if (x<1||x>n||y<1||y>m) continue;
        if (map[x][y]==0) continue;
        if (vis[x][y]==1) continue;
        vis[x][y]=1;
        rex[t+1]=x;rey[t+1]=y;
        if (x==x2&&y==y2) print(t+1);
        dfs(x,y,t+1);
        vis[x][y]=0;
    }
}
int main()
{
    n=gi();m=gi();
    for (rg int i=1;i<=n;i++)
      for (rg int j=1;j<=m;j++)
        map[i][j]=gi();
    x1=gi(),y1=gi(),x2=gi(),y2=gi();
    if (map[x1][y1]==0||map[x2][y2]==0||(x1==x2&&y1==y2))
    {
        printf("-1");
        return 0;
    }
    rex[1]=x1;rey[1]=y1;
    vis[x1][y1]=1;
    dfs(x1,y1,1);
    if (!ans) printf("-1");
    return 0;
} 

```

---

## 作者：Sooke (赞：1)

比较裸的深搜。起初看到 n 和 m ＜ 15，我还以为使用暴搜会爆，然而移动得到的答案具有后续性，除了暴搜实在没有办法了，因此敲了一个暴搜竟然没有超过时间限制。

与楼下不同，我将答案的字符串直接放到参数，递归的时候当即进行字符串处理，答案正确时直接输出答案就可以了，不用麻烦地建一个数组最后来花循环来输出。详细地请看代码，~~还敲了一份字符串版的数字表~~。

另外，可能本题比较麻烦的就是移动的优先程度了。我们先罗列上下左右移动的情况：

向上移动：行减小，列不变

向下移动：行增加，列不变

向左移动：行不变，列减小

向右移动：行不变，列增加

按照输出字典序，行是第一关键字，其次才是列。因此，向上移动优先程度最高，左右其次，向下移动最低。

不要忘记没有方案的情况。运用布尔变量即可解决。

```cpp
#include <iostream>
#define f(i , n) for(int i=1 ; i <= n ; i++)
using namespace std;
const string c[15]={"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14"};
int n , m , ax , ay , bx , by;
bool p=true;
void NextStep(int x , int y , bool a[15][15] , string s)
{
    if(!a[x][y] || x <= 0 || x > n || y <= 0 || y > m) return;
    a[x][y]=false;
    if(x == bx && y == by) cout << s << endl , p=false;
    NextStep(x-1 , y , a , s+"->("+c[x-1]+","+c[y]+")");
    NextStep(x , y-1 , a , s+"->("+c[x]+","+c[y-1]+")");
    NextStep(x , y+1 , a , s+"->("+c[x]+","+c[y+1]+")");
    NextStep(x+1 , y , a , s+"->("+c[x+1]+","+c[y]+")");
    a[x][y]=true; //注意这一步必不可少，回溯的基本操作
}
int main()
{
    bool a[15][15];
    cin >> n >> m;
    f(i , n)
        f(j , m)
            cin >> a[i][j];
    cin >> ax >> ay >> bx >> by;
    NextStep(ax , ay , a , "("+c[ax]+","+c[ay]+")");
    if(p) cout << -1;
    return 0;
}
```

---

## 作者：xiaohua0574 (赞：1)

本题是经典的DSF

首先需要仔细模拟确定行走方向，左下右上（下面很多方向都错了，不知道是不是测试数据修改过，本题也不需要chr把超过10的数据48处理）

然后按方向搜索就行，达到目标的输出行走路径即可。


```cpp
var
  n,m,i,j,sum:longint;
  a:array[0..16,0..16] of longint; //迷宫地图信息存储
  x1,y1:longint;
  dy:array[1..4] of integer=(-1,0,1,0); //注意dy控制的是左右
  dx:array[1..4] of integer=(0,-1,0,1); //dx控制的上下
  x,y:array[1..225] of longint;
procedure search(t:longint);
  var i:longint;
  begin
    if (x[t-1]=x1) and (y[t-1]=y1) then  //达到目标坐标，则输出路径
        begin
          sum:=sum+1;  //统计能走通的路径数量
          for i:=1 to t-2 do write('(',x[i],',',y[i],')->'); 
          writeln('(',x[t-1],',',y[t-1],')');
        end
    else
      begin
        for i:=1 to 4 do //按左上右下四个方向搜索
          if a[x[t-1]+dx[i],y[t-1]+dy[i]]=1 then 
           begin
             x[t]:=x[t-1]+dx[i];
             y[t]:=y[t-1]+dy[i];
             a[x[t],y[t]]:=0;
             search(t+1); //递归搜索
             a[x[t],y[t]]:=1; //回溯
           end;
      end;
  end;
begin
  readln(m,n);
  for i:=1 to m do
    begin
      for j:=1 to n do
         read(a[i,j]);
      readln;
    end;
  readln(x[1],y[1]);
  readln(x1,y1);
  a[x[1],y[1]]:=0; //起点赋值0，防止再次被搜索经过
  search(2);
  if sum=0 then writeln('-1'); //没有路径，就输出-1
end.

```

---

## 作者：1124828077ccj (赞：1)

//嗯，这个其实不难，主要是方向不好判断谁先谁后，建议题目更改，不过同学们可以看看我的程序，就知道方向了

```cpp
#include <cstdio> 
int m,n,s[17][17],q[17][17],q1,w,e,r,x[200],y[200],ccj; 
void print(int ll){ 
    for (int i=0;i<ll-1;i++) 
    printf("(%d,%d)->",x[i],y[i]); 
    printf("(%d,%d)\n",x[ll-1],y[ll-1]); 
    ccj=1; 
} 
void chenchangjie(int bb,int cc,int l){ 
    if (bb==e && cc==r)print(l); 
    if (bb-1>=0 && !q[bb-1][cc] && s[bb-1][cc]){x[l]=bb-1;y[l]=cc;q[bb-1][cc]=1;chenchangjie(bb-1,cc,l+1);}// 往上
    if (cc-1>=0 && !q[bb][cc-1] && s[bb][cc-1]){x[l]=bb;y[l]=cc-1;q[bb][cc-1]=1;chenchangjie(bb,cc-1,l+1);}// 往左
    if (cc+1<=n && !q[bb][cc+1] && s[bb][cc+1]){x[l]=bb;y[l]=cc+1;q[bb][cc+1]=1;chenchangjie(bb,cc+1,l+1);}// 往右
    if (bb+1<=m && !q[bb+1][cc] && s[bb+1][cc]){x[l]=bb+1;y[l]=cc;q[bb+1][cc]=1;chenchangjie(bb+1,cc,l+1);}// 往下
    q[bb][cc]=0; 
} 
int main() 
{ 
    scanf("%d%d",&m,&n); 
    for (int i=1;i<=m;i++) 
    for (int o=1;o<=n;o++)scanf("%d",&s[i][o]); 
    scanf("%d%d%d%d",&q1,&w,&e,&r); 
    x[0]=q1;y[0]=w;q[q1][w]=1; 
    chenchangjie(q1,w,1); 
    if (!ccj)printf("-1"); 
    return 0; 
}
```

---

## 作者：野菜汤 (赞：1)

题解：

这一题不用说，是每一个搜索初学者都要做的，那么，我们要做的就是进一步的优化，那么先看一下一下标程。仅供参考！

```delphi
const a:array[1..4]of longint=(0,-1,0,1);
b:array[1..4]of longint=(-1,0,1,0);
var l:array[1..100,1..2]of longint;
    road:array[-2..15,-2..15] of longint;
    i,j,o,m,n,m1,n1,m2,n2:longint;c:boolean;
procedure qiang(m,n:longint);{作为一步优化的过程}
begin
  for i:=0 to n+1 do begin
  road[1,i]:=0;road[m+1,i]:=0;end;
  for i:=0 to m+1 do begin
    road[i,1]:=0;road[i,n+1]:=0;end;
end;
function  pd(x,y,z:longint):boolean;
begin
  pd:=true;
  if road[x+a[z],y+b[z]]=0 then pd:=false;
  if road[x+a[z],y+b[z]]=2then pd:=false;
end;
procedure dg(p,q,sum:longint);
var i:longint;
begin
  if (p=m1)and(q=n1)then
  begin
  if l[2,1]=0 then exit;
  for i:=1 to sum-1 do begin{那么这里使用的chr的运用是每个人必须要写的，因为在洛谷上的标答的数字在大于10以上的数时，就会变成其他符号，所以需要转换一下}
    write('(',chr(l[i,1]+48),',',chr(l[i,2]+48),')','->');c:=true; end;
    write('(',chr(m1+48),',',chr(n1+48),')');  writeln;
  exit;
  end;
  for i:=1 to 4 do
    if pd(p,q,i)  then
  begin
    l[sum,1]:=p;
    l[sum,2]:=q;
    road[p,q]:=2;
    dg(p+a[i],q+b[i],sum+1);
    road[p,q]:=1;
    l[sum,1]:=0;
    l[sum,2]:=0;
  end;

end;
begin
  readln(m,n);
  qiang(m,n);
  for i:=1 to m do
    for j:=1 to n do begin read(road[i,j]);end;
  readln(m,n);readln(m1,n1);
  dg(m,n,1);if c=false then begin write('-1'); end;
end.
```
首先，以上程序我就不做过多的文字解释了，反正大家都懂。

那么我再解释一下‘qiang’那个过程，这是一步优化，他将现有地图的四周都铺成了一道墙，那么在回溯搜索的是后，使判断更容易也使程序更快了。

那么就这些了，还请大家自己好好参悟理解。


---

## 作者：SNiFe (赞：1)

\_这道题就是裸地DFS，很简单啊，只需要加个回溯，来一个ansx【】和ansy【】记录路径就好了。注意DFS顺序（**左！上！右！下**）和输出格式。附上代码+详细批注：\_


```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;
const int N=1200;
int map[N][N],n,m,ansx[N],ansy[N],xt,yt,xs,ys,flag=0,t=0;
bool visit[N][N];
void print(int k)//输出 
{
    for(int i=1;i<=k-1;i++)
    {
        printf("(%d,%d)->",ansx[i],ansy[i]);
    }
    printf("(%d,%d)\n",xt,yt);
    flag=1;//判断 
}
void dfs(int x,int y,int t)
{
    if(x==xt&&y==yt)//找到一个 
    {
        print(t+1);
    }
    ansx[t+1]=x,ansy[t+1]=y;//记录路径 
    visit[x][y]=1;//标记 
    if(!visit[x][y-1]&&y-1>=1&&map[x][y-1]==1)dfs(x,y-1,t+1);
    if(!visit[x-1][y]&&x-1>=1&&map[x-1][y]==1)dfs(x-1,y,t+1);
    if(!visit[x][y+1]&&y+1<=m&&map[x][y+1]==1)dfs(x,y+1,t+1);
    if(!visit[x+1][y]&&x+1<=n&&map[x+1][y]==1)dfs(x+1,y,t+1);//清晰明了+可爱的DFS 
    visit[x][y]=0;//回溯 
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        scanf("%d",&map[i][j]);
    }
    scanf("%d%d%d%d",&xs,&ys,&xt,&yt);
    if(map[xs][ys]==0||map[xt][yt]==0||xs==xt&&ys==yt)
    {
        printf("-1");return 0;
    }
    dfs(xs,ys,0);//开始搜索 
    if(flag==0)printf("-1");
}
//打完收工
```

---

## 作者：codeboyzzb (赞：0)

## ~~LIFAN:~~ 这道题的DFS思想太浓烈啦!
* * *
首先,我们引进一个新概念叫 **$vector$中的$make$_$pair$**
***
程序如下:

![make_pair](https://s2.ax1x.com/2019/05/28/VmxR78.png)

> 运用$typedef$语法，调出$pair$和$vector$函数, 最后用$xiaobian$这个~~单词~~词组把$pair$存下来。
* * *
思路如下:
![](https://s2.ax1x.com/2019/05/28/Vmzduq.png)
* * *
代码顺序:
-
* 输入
* DFS
* 特判

代码如下:

1.首先是输入
![](https://s2.ax1x.com/2019/05/28/VnSEq0.png)
程序:
```cpp
cin>>m>>n;
for(int i = 1; i <= m; i++)
	for(int j = 1; j <= n; j++)
	{
		cin>>Maze[i][j];
		Maze[i][j] -= '0';
	}
```
***
2.其次是DFS
![](https://s2.ax1x.com/2019/05/28/VnSco8.png)
程序:
```cpp
int dfs(int x,int y)
{
    if(1 == Maze[y][x])
    {
        if(y == ey && x ==ex)
        {
            dump_road();
            printf("->(%d,%d)",ey,ex);
            printf("\n");
            ans++;
            return 1;
        }
        Maze[y][x] = '$';
        ss.push_back(make_pair(y,x));
        dfs(x-1,y);
        dfs(x,y-1);	
        dfs(x+1,y);
        dfs(x,y+1);
        //左上右下
        Maze[y][x] = 1;
        ss.pop_back();
    }
    return 0;
}
```
3.输入输出
![](https://s2.ax1x.com/2019/05/28/VnSxyR.png)
程序:
```cpp
void dump_road()
{
    printf("(%d,%d)",ss[0].first,ss[0].second);
    for(int i = 1; i < ss.size(); i++)
        printf("->(%d,%d)",ss[i].first,ss[i].second);
    return;
}
```
> 好了,这道题就到这里,拜拜~~

特别感谢:

![](https://imgchr.com/content/images/system/logo_1552414290509_0e48b5.png)![](https://cdn.luogu.com.cn/fe/logo.png?35e6d0796eab39c4bf304d03e6d332c0)![](data:image/jpeg;base64,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74FgMISvv/66WY+T/S6FhYVYt24dhgwZcsGfuWigK4qC1157DXPmzGnXOe9ERBRZubm56NevH2655RZ88MEH+NOf/tSs4LHb7Rg9ejRcLhesViumTLkFf/vb+9i0aROGDh2KKVOmYP369Ty724by8vKwatUqTJ48+aKn8i96kVwQBEyaNAlnzpzB448/ziY5IqI4kZaWhoEDB+Kzzz7DO++80+yjSPXBI1dffTUEQcA777yLzZs3ITU1Df369cO7776Ljz/+WO/dixtZWVlYuHAhJk2a9N3X5ZVm8Pl8yrPPPqtkZmaqz8nj4uLi4orhJUmSYrPZFKPR2OI/K4qiYrPZFJvNpoii2Oj1DAaD7vsWLysrK0t59tlnFZ/P15yoVpoV6Gqor1u3TsnLy9N9J7m4uLi4uOJ5de7cWXnuueeaHeYtCnRFUZRAIKBs2LBBKSws1H1nubi4uLi44nEVFRUpr732mhIIBFoS0S0LdEVRFFmWla1btypjx469pFM1XFxcXFxcXOcvo9GojBs3Tvn73/+uyLLc0nhWLtrlfjFHjhzBmjVr8Nxzz7FZjoiIqBUyMjIwa9YsPPDAA9pDYFrqkgMdALxeL95++208/fTT2LJlCx/oQkRE1AJmsxnDhw/HnDlzcMMNNzT5+NfmalWgq44dO4aXX34ZL774Inbs2BGxx8URERHFA6PRiMLCQsyYMQPTpk1rcjZ7S7VJoAPh5+ru27cP69evx4YNG7Bjxw54vV693zMiIqKoYbFY0K9fP0yZMgVTp05Ft27d2uyJbG0W6CpZlnH48GG888472LRpE7Zt24YTJ07wqJ2IiBKS0WhEdnY2rrzySkycOBHXX3898vLy2vzRqm0e6A3V19fjq6++wieffIK///3v+OKLL3Ds2DE4nU4EAoE2mW9LREQULQRBgNFohN1u18brDhs2DFdffTUuv/xyJCcnR27bkQz0hlwuF44dO4bdu3ejoqICu3btwtdff40TJ06guroabrcbgUBAe7wdERFRNJMkCUajUXvka05ODrp27YqCggIUFBSgd+/eyM3Nhc1ma5d6/h949FXmpzXIlwAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNi0wMy0yMlQxNjo1ODo0MSswODowMEChyf4AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTYtMDMtMjJUMTY6NTg6NDErMDg6MDAx/HFCAAAATnRFWHRzb2Z0d2FyZQBJbWFnZU1hZ2ljayA2LjguOS0xMCBRMTYgeDg2XzY0IDIwMTYtMDItMjMgaHR0cDovL3d3dy5pbWFnZW1hZ2ljay5vcmeI5u0FAAAAGHRFWHRUaHVtYjo6RG9jdW1lbnQ6OlBhZ2VzADGn/7svAAAAGHRFWHRUaHVtYjo6SW1hZ2U6OkhlaWdodAA2MTaKpinBAAAAGHRFWHRUaHVtYjo6SW1hZ2U6OldpZHRoADEwMDDHNKI/AAAAGXRFWHRUaHVtYjo6TWltZXR5cGUAaW1hZ2UvcG5nP7JWTgAAAA90RVh0VGh1bWI6OlNpemUAMEJClKI+7AAAABJ0RVh0VGh1bWI6OlVSSQBmaWxlOi8vwXeLzwAAAABJRU5ErkJggg==)

---

## 作者：caoshirui (赞：0)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int d[4][2]={{0,-1},{-1,0},{0,1},{1,0}};
int n,m,a1,a2,b1,b2,t,x[110],y[110],g[110][110];
void init(){
	for(int i=0;i<=m+1;i++){
		g[0][i]=0;g[n+1][i]=0;
	}
	for(int i=0;i<=n+1;i++){
		g[i][0]=0;g[i][m+1]=0;
	}
}
void out(int i){
	cout<<'('<<a1<<','<<a2<<')';
	for(int j=1;j<=i;j++){
		cout<<"->"<<'('<<x[j]<<','<<y[j]<<')';
	}
	cout<<endl;
	t++;
}
void mg(int i,int xx,int yy){
	for(int j=0;j<4;j++){
		x[i]=xx+d[j][0];
		y[i]=yy+d[j][1];
		if(g[x[i]][y[i]]==1){
			g[x[i]][y[i]]=0;
			if(x[i]==b1&&y[i]==b2) out(i);
			else 
			mg(i+1,x[i],y[i]);
			g[x[i]][y[i]]=1;
		}
	}
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin>>g[i][j];
		}
	cin>>a1>>a2>>b1>>b2;
	init();
	g[a1][a2]=0;
	mg(1,a1,a2);
	if(t==0)cout<<"-1";
}
```

---

## 作者：JustinRochester (赞：0)

@梦回还  @刘备

蒟蒻向机房里“显然可得”大佬和“弱得水解”大佬请安

---

**【分析】**
--

这里主要提一下，边界坐标 $m,n \leq 15$

那么很显然的，单个坐标只需要 $4$ 个二进制位即可

因此，我们可以把横坐标左移 $15$ 位或上纵坐标 $(x<<4|y)$ 直接表示坐标 ( 左移 $4$ 位后，后 $4$ 位一定为 $0000_{(2)}$ )

使用的时候右移 $4$ 位直接取 $x$ ，与上 $15(01111_{(2)})$ 直接取 $y$ 即可

所以，图啊，访问标记啊都只需要一维，栈啊之类的也只需要一个维护上述方式表示的坐标即可

---

下面讲一下细节

对于一个点 $(i,j)$ ，如果可访问直接在图上打个标记 $Map_{i,j}=1$

如果我们把 $Map$ 初始化为全 $0$ ,坐标从 $(1,1)$ 存到 $(n,m)$ 的话，一定不会访问到边界之外导致访问无效内存
```cpp
	people &me=LRJ;
    //想一想，为什么？
```

那么，我们首先直接判定能不能访问起始点，不能就跳

接下来，把所有能访问且还未访问的点加入栈中，找到终点了就把栈里面的全部输出即可

其他一些细节就看本蒟蒻的代码吧

---

**【代码】**
--

那本蒟蒻就放 ~~我码风极丑的~~  代码了

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c) for(register int a=b;a<=c;a++)
#define g(a,b,c) for(register int a=b;a>=c;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
typedef long long int ll;
typedef unsigned long long int ull;
inline ll read(){
    register ll ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^'0'),c=getchar();
    return neg?-ans:ans;
}//以上全是条件反射的结果
int Cur=0;
char S[1<<20];
inline void print(int x){
	if(x<0) S[Cur++]='-',x=-x;
	int Stack[20]={0},Size=0;
	while(x) Stack[Size++]=x%10,x/=10;
	f(i,0,Size-1) S[Cur+i]=Stack[Size-1-i]+48;
	Cur+=Size;
}//输出优化，讲究
int M,N,Start,End,Dir[]={-1,-16,1,16};
//M N 如题，Start 起始点， End 终点
//Dir 方向 {-1,-(1<<4),1,(1<<4)}
bool Map[300]={0},Vis[300]={0};
void pre(){
	M=read(); N=read();
	f(i,1,M) f(j,1,N) Map[i<<4|j]=(read()==1);
	Start=read()<<4; Start|=read();
	End=read()<<4; End|=read();
}
int Stack[900],Size=0;
void outit(){
	S[Cur++]='('; print(Stack[0]>>4); S[Cur++]=','; print(Stack[0]&15); S[Cur++]=')';
	f(i,1,Size-1){
		S[Cur++]='-'; S[Cur++]='>';
		S[Cur++]='('; print(Stack[i]>>4); S[Cur++]=','; print(Stack[i]&15); S[Cur++]=')';
	}
	S[Cur++]='\n';
}
bool dfs(int pos){
	bool b=0;//判定能否走到终点
	Stack[Size++]=pos;
	if(pos==End) { outit(); Size--; return 1; }
	Vis[pos]=1;
	f(i,0,3) if( Map[pos+Dir[i]]&(!Vis[pos+Dir[i]]) ) b|=dfs(pos+Dir[i]);
	Size--;
	Vis[pos]=0;
	return b;
}
void output() { puts(S); }
int main(){
	pre();
	if(!Map[Start]) print(-1);//起点就不能走
	else if(!dfs(Start)) print(-1);//不能走到终点
	output();
	return 0;
}
```

---

## 作者：2x6_81 (赞：0)

好像没有人用**queue**的，那就来水一发：

基本方法：**dfs**

思路：走路，回溯（实际上就是**暴力**）

基本函数：
```
void dfs(int x,int y)
{
	dfs(x,y-1);
    dfs(x-1,y);
    dfs(x,y+1);
    dfs(x+1,y);
}
```
高大上一点：
```
int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};
void dfs(int x,int y)
{
	int tx,ty;
	for(reg int k=0;k<4;++k)
	{
		tx=x+dir[k][0];
		ty=y+dir[k][1];
		if(!vis[tx][ty])
		{vis[tx][ty]=1,dfs(tx,ty),vis[tx][ty]=0;}
	}
	return;
}
```
注意：
1. 要审题：优先**左上右下**
2. **优先左上右下**
3. **优先左上右下**

重要的事情说三遍

还有，**queue.pop()** 是把队头弹出，不是队尾。

如果要弹出队尾，挨个弹：
```
void queue_pop()
{
	for(reg int i=1;i<road.size();++i)
	road.push(road.front()),road.pop();//头一个元素到最后
	road.pop();//最后一个跑到队头,弹出
}
```
代码：
```
#include <iostream>
#include <stdio.h>
#include <queue>//queue头文件
using namespace std;
#define reg register
struct per
{
	int x,y;
    //在C语言中,struct里是不能定义函数的
    //但这是C++,所以可以有函数
	per(int xx,int yy)
	{x=xx;y=yy;}
    //构造一个结构体,省去了定义另一个结构体
};
int map[20][20];//地图
//注意,这里没有编译错误是因为没有引进map
//如果用万能头文件,里头就会有map的头文件<map>
//那样就会编译错误
//所以个人不建议用万能头文件
bool b=0,vis[20][20];
//b:是否有解
//vis:是否访问过,回溯用的
queue<per> road;
//road:经过的路
int m,n,fx,fy,ex,ey;
//m:行数
//n:列数
//fx:from x,起点的x坐标
//fy:from y,起点的y坐标
//ex:end x,终点的x坐标
//ey:end y,终点的y坐标
bool in(int x,int y)
{
	return x<1 or x>m or y<1 or y>n or !map[x][y];
}//判断是否可以走
void print()
{
    printf("(%d,%d)",road.front().x,road.front().y),road.push(road.front()),road.pop();//输出终点位置
	for(reg int i=1;i<road.size();++i)
	printf("->(%d,%d)",road.front().x,road.front().y),road.push(road.front()),road.pop();//把队头的后面一个到前面来
}//输出函数,自己写的
void queue_pop()
{
	for(reg int i=1;i<road.size();++i)
	road.push(road.front()),road.pop();
	road.pop();
}//将队尾弹出
int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};
//分别代表左,上,右,下
void dfs(int x,int y)
{
	if(in(x,y)) return;
	if(x==ex and y==ey) {b=1; print(); queue_pop(); return;}
	road.push(per(x,y));
    //记下这个坐标可以走
	int tx,ty;
    //tx:即将走到的x坐标
    //ty:即将走到的y坐标
	for(reg int k=0;k<4;++k)
	{
		tx=x+dir[k][0];
		ty=y+dir[k][1];
		if(!vis[tx][ty])
		{vis[tx][ty]=1,dfs(tx,ty),vis[tx][ty]=0;}
        //标记,回溯
	}
	queue_pop();
    //弹出最后一个元素
	return;
}
int input()
{
	int re=0;char c=getchar();
	while(c<'0' or c>'9') c=getchar();
	while(c>='0' and c<='9') re=(re<<3)+(re<<1)+(c^48),c=getchar();
	return re; 
}//Fast Input
int main()
{
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
//输入
	m=input();n=input();
	for(reg int i=1;i<=m;++i)
	for(reg int j=1;j<=n;++j)
	map[i][j]=input();
	fx=input(),fy=input();
	ex=input(),ey=input();
	vis[fx][fy]=1;
    //一定要标记,不能不写
    //否则程序会认为你这个点没走过
    //这一个小地方就会导致 WA 8个点
    //(当然,这是我的代码)
	if(map[fx][fy]==0 or map[ex][ey]==0)
	{printf("-1\n"); return 0;}
    //这个可以不用,判断起点终点是不是可以走的
	dfs(fx,fy);//深度优先搜索
	if(!b) printf("-1\n");
    //判断是否有解
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```
```
时间：25ms
空间：932KB
```
[快读快输出的模板](https://www.luogu.org/blog/1212121is-prime/read-and-write)

---
最后，给不会**queue**的同学一点点小福利：

```
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;
#define reg register
struct per
{
	int x,y;
}s[1010];//路
int map[20][20];
bool b=0,vis[20][20];
int l;
//l:表示路的长度
int m,n,fx,fy,ex,ey;
bool in(int x,int y)
{
	return x<1 or x>m or y<1 or y>n or !map[x][y];
}
void print()
{
	printf("(%d,%d)",s[0].x,s[0].y);
	for(reg int i=1;i<l;++i)
	printf("->(%d,%d)",s[i].x,s[i].y);
	putchar('\n');
}
int dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};
void dfs(int x,int y)
{
	if(in(x,y)) return;
	s[l].x=x,s[l].y=y;
	++l;//长度++
	if(x==ex and y==ey) {b=1; print(); --l; return;}
	int tx,ty;
	for(reg int k=0;k<4;++k)
	{
		tx=x+dir[k][0];
		ty=y+dir[k][1];
		if(!vis[tx][ty])
		{vis[tx][ty]=1,dfs(tx,ty),vis[tx][ty]=0;}
	}
	--l;//长度--
	return;
}
int input()
{
	int re=0;char c=getchar();
	while(c<'0' or c>'9') c=getchar();
	while(c>='0' and c<='9') re=(re<<3)+(re<<1)+(c^48),c=getchar();
	return re; 
}
int main()
{
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	m=input();n=input();
	for(reg int i=1;i<=m;++i)
	for(reg int j=1;j<=n;++j)
	map[i][j]=input();
	fx=input(),fy=input();
	ex=input(),ey=input();
	vis[fx][fy]=1;
	if(map[fx][fy]==0 or map[ex][ey]==0)
	{printf("-1\n"); return 0;}
	dfs(fx,fy);
	if(!b) printf("-1\n");
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```
```
时间：28ms
空间：848KB
```
以上代码请读者自行理解

-----

---

## 作者：QianhanOfficial (赞：0)

```cpp
//发现下面没有vector的题解 来一发
#include<cstdio>
#include<iostream>
#include<vector>
using namespace std;

vector<int> v1;//储存横坐标
vector<int> v2;//储存纵坐标

int n, m, sx, sy, fx, fy;
//m行 n列 sx起点横坐标 sy起点纵坐标 fx终点横坐标 fy终点纵坐标
int a[20][20];//地图
bool yeah, vis[20][20];//yeah是判断是否没有办法到达 vis是痕迹数组

void print()//打印答案
{
	yeah = true;//如果运行了这个函数 那么一定是有路径的 所以就不输出-1
	int t = v1.size() - 1;//t作为经过的点的个数
	for(int i = 0; i < t; i++) printf("(%d,%d)->", v1[i], v2[i]);//输出路上的每一个点
	printf("(%d,%d)\n", fx, fy);//输出终点
	return;
}

void dfs(int x, int y)//标准dfs
{
	if(x == fx && y == fy)//到达终点
	{
		print();//打印
		return;
	}
	
	if(x - 1 >= 1 && a[x - 1][y] && !vis[x - 1][y])//向左走
	{
		v1.push_back(x - 1);//vector中加入选择的坐标
		v2.push_back(y);//别忘了纵坐标
		vis[x - 1][y] = true;//设置走过
		dfs(x - 1, y);//递归dfs
		vis[x - 1][y] = false;//复原
		v1.pop_back();//别忘了弹出这个点的坐标
		v2.pop_back();
	}
	//以下除了方向不同 其他的都类似
	if(y - 1 >= 1 && a[x][y - 1] && !vis[x][y - 1])
	{
		v1.push_back(x);
		v2.push_back(y - 1);
		vis[x][y - 1] = true;
		dfs(x, y - 1);
		vis[x][y - 1] = false;
		v1.pop_back();
		v2.pop_back();
	}
	
	if(y + 1 <= n && a[x][y + 1] && !vis[x][y + 1])
	{
		v1.push_back(x);
		v2.push_back(y + 1);
		vis[x][y + 1] = true;
		dfs(x, y + 1);
		vis[x][y + 1] = false;
		v1.pop_back();
		v2.pop_back();
	}
	
	if(x + 1 <= m && a[x + 1][y] && !vis[x + 1][y])
	{
		v1.push_back(x + 1);
		v2.push_back(y);
		vis[x + 1][y] = true;
		dfs(x + 1, y);
		vis[x + 1][y] = false;
		v1.pop_back();
		v2.pop_back();
	}
}

int main()
{
	scanf("%d%d", &m, &n);
	for(int i = 1; i <= m; i++)
	{
		for(int j = 1; j <= n; j++)
		{
			scanf("%d", &a[i][j]);//存图
		}
	}
	scanf("%d%d%d%d", &sx, &sy, &fx, &fy);//输入起点终点
	v1.push_back(sx);//首先加入起点坐标
	v2.push_back(sy);
	vis[sx][sy] = true;//千万别忘了起点访问过！否则会重复！
	dfs(sx, sy);//从起点开始搜索
	if(!yeah) printf("-1");//如果从头到尾没有找到路径 yeah的值不会改变 就输出-1
	return 0;
}
//这个程序主要就是利用vector的随意加入弹出的特性 数据范围也不大 空间能够承受
//重点是用vector的思路特别清晰 写出来也有助于对dfs的理解
```

---

## 作者：刘备 (赞：0)

比赛前一个月练练暴力总是好的

这一题就是裸的DFS，注意**左上右下**。

直接上代码吧，细节都在代码中。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define pp pair<int,int>//个人喜好，爱用pair
using namespace std;
int dx[4]={0,-1,0,1};
int dy[4]={-1,0,1,0};
pp s,t,way[1001];//way表示路径
int map[16][16],cnt;//地图map和路径的长度cnt，输出要用
int n,m;
bool pd;
//养成好习惯，先看主程序!!!
void print()
{
    pd=1;
    printf("(%d,%d)",s.first,s.second);
    for(int i=1;i<=cnt;i++) printf("->(%d,%d)",way[i].first,way[i].second);
    printf("\n");
    return;
}
void dfs(pp k)
{
    int i,j;
    if(k==t)
    {
        print();
        return;
```
}//找到就输出并返回
```cpp
    for(i=0;i<4;i++)
    {
        int x1=k.first+dx[i],y1=k.second+dy[i];
        if(x1>=1&&x1<=m&&y1>=1&&y1<=n&&map[x1][y1])
        {
            way[++cnt]=make_pair(x1,y1);
            map[x1][y1]=0;
            dfs(way[cnt]);
            map[x1][y1]=1;//记得回溯
            cnt--;
        }
    }
    return;
}
int main()
{
    int i,j;
    scanf("%d%d",&m,&n);
    for(i=1;i<=m;i++)
        for(j=1;j<=n;j++) scanf("%d",&map[i][j]);
    scanf("%d%d",&i,&j); s=make_pair(i,j);
    scanf("%d%d",&i,&j); t=make_pair(i,j);
    map[s.first][s.second]=0;
    dfs(s);
    if(!pd) printf("-1\n");//如果没有输出过就说明根本到不了，直接输出-1
    return 0;
}
```

---

## 作者：姚文涛？ (赞：0)

自古搜索出奇迹，不多说看代码(注释全在代码中)：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<sstream>
#include<algorithm>
#include<queue>
#include<vector>
#include<string>
using namespace std;
int n,m,start_x,start_y,finish_x,finish_y;
bool visit[101][101],flag=false;
int map[101][101];
int ans[10001][2];//用一个ans的二维数组的[1]保存行,[2]保存列，方便打印。
int dir[4][2]={
    {-1,0},{0,-1},{0,1},{1,0}//定义方向,即上下左右。
};
void print(int total){//输出路线。
    cout<<"("<<start_x<<","<<start_y<<")->";
    for(int i=1;i<total;i++){
        cout<<"("<<ans[i][1]<<","<<ans[i][2]<<")->";//用一个ans的二维数组的[1]保存行,[2]保存列，方便打印。
    }
    cout<<"("<<ans[total][1]<<","<<ans[total][2]<<")"<<endl;
}
bool CanMove(int x,int y){
    if(x>=1&&x<=n&&y>=1&&y<=m&&map[x][y]!=0)return true;//判断下一步有没有出界，和是否可以继续走下一步。
    return false;
}
void search(int x,int y,int total){
    int next_x,next_y;
    if(x==finish_x&&y==finish_y){//如果到达终点，则标志旗设为true,打印。
        flag=true;
        print(total);
        return;
    }
    for(int i=0;i<4;i++){
        next_x=x+dir[i][0];
        next_y=y+dir[i][1];
        if(CanMove(next_x,next_y)&&!visit[next_x][next_y]){//判断下一步可不可走,和有没有被走过。
            total++;//计步+1。
            ans[total][1]=next_x;ans[total][2]=next_y;//保存路线,ans数组的[1]保存行,[2]保存列。
            visit[next_x][next_y]=true;//设此点为经过。
            search(next_x,next_y,total);
            visit[next_x][next_y]=false;//状态回溯。
            ans[total][1]=0;ans[total][2]=0;//状态回溯。
            total--;//状态回溯。
        }
    }
}
int main(){
        cin>>n>>m;//读入迷宫大小。
        memset(visit,false,sizeof(visit));//初始化bool的数组。
        for(int i=1;i<=n;i++){//读入迷宫。
            for(int j=1;j<=m;j++){
                cin>>map[i][j];
            }
        }
        cin>>start_x>>start_y;//读入起始位置。
        cin>>finish_x>>finish_y;//读入终点位置。
        visit[start_x][start_y]=true;//当前初始位置标记为经过了。
        search(start_x,start_y,0);//开始搜索。
        if(!flag)cout<<-1<<endl;//若没有一条完整的路线则输出-1。
    return 0;
}
```

---


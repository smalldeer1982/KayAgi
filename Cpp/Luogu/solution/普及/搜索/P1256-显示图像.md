# 显示图像

## 题目描述

古老的显示屏是由 $N \times M$ 个像素（Pixel）点组成的。一个像素点的位置是根据所在行数和列数决定的。例如 $P(2,1)$ 表示第 $2$ 行第 $1$ 列的像素点。那时候，屏幕只能显示黑与白两种颜色，人们用二进制 $0$ 和 $1$ 来表示。$0$ 表示黑色，$1$ 表示白色。当计算机发出一个指令：$P(x,y)=1$，则屏幕上的第 $x$ 行第 $y$ 列的阴极射线管就开始工作，使该像素点显示白色，若 $P(x,y)=0$，则对应位置的阴极射线管不工作，像素点保持黑色。在某一单位时刻，计算机以 $N \times M$ 二维 $01$ 矩阵的方式发出显示整个屏幕图像的命令。

例如，屏幕是由 $3 \times 4$ 的像素点组成，在某单位时刻，计算机发出如下命令：

$$\begin{pmatrix}
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 1 \\
0 & 1 & 1 & 0 \\
\end{pmatrix}$$

对应屏幕显示应为：

![](https://cdn.luogu.com.cn/upload/image_hosting/cwg2di9s.png)

假设放大后，一个格子表示一个像素点。

由于未知的原因，显示黑色的像素点总是受显示白色的像素点的影响——可能是阴极射线管工作的作用。并且，距离越近，影响越大。这里的距离定义如下：

设有像素点 $P_1(x_1,y_1)$ 和像素点 $P_2(x_2,y_2)$，则它们之间的距离 $D(P_1,P_2)=|x_1-x_2|+|y_1-y_2|$。

在某一时刻，计算机发出显示命令后，科学家们期望知道，每个像素点和其最近的显示白色的像素点之间的最短距离是多少——科学家们保证屏幕上至少有一个显示白色的像素点。

上面的例子中，像素 $P(1,1)$ 与最近的白色像素点之间的距离为 $3$，而像素 $P(3,2)$ 本身显示白色，所以最短距离为 $0$。


## 说明/提示

- 对于 $30\%$ 的数据：$N\times M \le 10000$；
- 对于 $100\%$ 的数据：$N\times M \le 182^2$。

## 样例 #1

### 输入

```
3 4
0001
0011
0110
```

### 输出

```
3 2 1 0
2 1 0 0
1 0 0 1
```

# 题解

## 作者：封禁用户 (赞：35)

这题真的坑，~~虽然我一遍AC了~~


题解区兜了一圈，好像都是写搜索的。。


呦呵，这不是暴力吗？？

----

[原题链接](https://www.luogu.com.cn/problem/P1256)

题面我看了好几遍才看懂（~~出题人能不能直截了当一点啊~~），其实就是一句话：

>每个像素点和其最近的显示白色的像素点之间的最短距离是多少。


---

只要分两种情况考虑：

1.$a_{i,j}$为$1$，也就是当前像素点为白像素点。

这简单，里$a{i,j}$最近的白像素点不就是自己吗？

所以，最短距离为$0$。

2.$a_{i,j}$为$0$，也就是当前像素点为黑像素点。

暴力就是在这里，去寻找白像素点，求出最短距离。


----

考虑清楚了，那就想一想怎么暴力吧。

要是双重循环枚举每个像素点然后进行处理那肯定是不行的，复杂度太高了，会TLE的。

我想到的是：

用$b$数组存储当前像素点的信息，用$a$数组存储当前像素点与白色像素点之间的最短距离。

双重循环。

如果$b_{i,j}=true$，是白像素点，$a_{i,j}=0$，双重循环，将每个黑像素点和当前白像素点的距离计算出来，然后跟先前的数作比较，比Ta小，就替换。

注意，$a$数组的初始值要很大。

- 如何计算两个像素点之间的距离


![](https://cdn.luogu.com.cn/upload/image_hosting/31g9i9n2.png)

观察一下这张图，两点之间的最短路径和什么有关呢？

图$1$：

最短路径为$3$。

$abs($橙圈所在行$-$绿圈所在行$)+abs($橙圈所在列$-$绿圈所在列$=(2-1)+(4-2)=1+2=3$

图$2$：

最短路径为$2$。

$abs($橙圈所在行$-$绿圈所在行$)+abs($橙圈所在列$-$绿圈所在列$=(4-3)+(3-2)=1+1=2$

图$3$：

最短路径为$5$。

$abs($橙圈所在行$-$绿圈所在行$)+abs($橙圈所在列$-$绿圈所在列$=(4-2)+(4-1)=2+3=5$

发现什么了吗？

验证一下。

图$4$：

最短路径为$5$。

$abs($橙圈所在行$-$绿圈所在行$)+abs($橙圈所在列$-$绿圈所在列$=(4-1)+(3-1)=3+2=5$

由此得出：

$a_{i,j}$和$a_{k,t}$的最短路径为，$abs(i-k)+abs(j-t)$。



好啦，那我们开始暴力吧！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[183][183],d;
bool b[183][183];
char s[183];
void f(int x,int y) {
    int i=1;
    while(i<=n) {
        for(int j=1; j<=m; ++j) {
            if(b[i][j]==true) continue;
            d=abs(x-i)+abs(y-j);
            a[i][j]=min(a[i][j],d);
        }
        ++i;
    }
}
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; ++i) 
        for(int j=1; j<=m; ++j) {
        	scanf("%d",&b[i][j]);
            if(b[i][j+1]==true) a[i][j+1]=0;
            else a[i][j+1]=1e9;
        }
    for(int x=1; x<=n; ++x)
        for(int y=1; y<=m; ++y) {
            if(b[x][y]) {
                int k=1;
                while(k<=n) {
                    for(int j=1; j<=m; ++j) {
                        if(b[k][j]==true) continue;
                        d=abs(x-k)+abs(y-j);
                        a[k][j]=min(a[k][j],d);
                    }
                    ++k;
                }
            }
        }
    for(int i=1; i<=n; ++i) {
        for(int j=1; j<=m; ++j) printf("%d ",a[i][j]);
        printf("\n");
    }
    return 0;
}
```

我谔谔，为什么输入怪怪的啊~

然后，就发现了一个巨坑无比的东西，输入！

这是样例：

$in$

```cpp
3 4
0001
0011
0110
```

$out$

```cpp
3 2 1 0
2 1 0 0
1 0 0 1
```

您仔细看，有什么不同？？

恍然大悟，输入的矩阵中数字之间没有空格！！

（~~我差点气得吐血，我可是调了一上午啊~~

这样，就得用字符串读入：

```cpp
for(int i=1; i<=n; ++i) {
    scanf("%s",s);
    for(int j=0; j<m; ++j) {
        b[i][j+1]=s[j]-'0';
        if(b[i][j+1]==true) a[i][j+1]=0;
        else a[i][j+1]=1e9;
    }
}
```

就这样，意料之中地AC了……

~~（写得算详细，喜欢就给个赞吧~~~

---

## 作者：pantw (赞：20)

看到楼下全是BFS的做法，顿时觉得自己脑回路神奇。。。


这里是一个DP/递推的做法。


往4个方向DP即可，因为最短路一定在这些方向上产生。


```cpp
#include <cstdio>
#include <cstring>
#define maxn 1010
#define Lovelive long long
#define INF 0x3F3F3F3F
#define min(a, b) ((a)<(b)?(a):(b))

char map[maxn][maxn];
int f[4][maxn][maxn];
int ans;
int n, m;

int main() {
    freopen("gochess.in", "r", stdin);
    freopen("gochess.out", "w", stdout);
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%s", map[i] + 1);
    memset(f, 0x3f, sizeof f);
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            if(map[i][j] == '1') for(int k = 0; k < 4; k++) f[k][i][j] = 0;
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            if(!f[0][i][j]) continue;
            f[0][i][j] = min(f[0][i-1][j], f[0][i][j-1]);
            if(f[0][i][j] != INF) f[0][i][j]++;
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = m; j >= 1; j--) {
            if(!f[1][i][j]) continue;
            f[1][i][j] = min(f[1][i-1][j], f[1][i][j+1]);
            if(f[1][i][j] != INF) f[1][i][j]++;
        }
    }
    for(int i = n; i >= 1; i--) {
        for(int j = 1; j <= m; j++) {
            if(!f[2][i][j]) continue;
            f[2][i][j] = min(f[2][i+1][j], f[2][i][j-1]);
            if(f[2][i][j] != INF) f[2][i][j]++;
        }
    }
    for(int i = n; i >= 1; i--) {
        for(int j = m; j >= 1; j--) {
            if(!f[3][i][j]) continue;
            f[3][i][j] = min(f[3][i+1][j], f[3][i][j+1]);
            if(f[3][i][j] != INF) f[3][i][j]++;
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            ans = min(min(f[0][i][j], f[1][i][j]), min(f[2][i][j], f[3][i][j]));
            printf("%d ", ans);
        }
        putchar('\n');
    }
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

---

## 作者：Hydra_ (赞：18)

本蒟蒻的博客 [柴犬首相的blog](http://blog.csdn.net/qq\_39670434)

## 分析 ##

这道题目求最短路径长度啊，真是似曾相识，是不是就，一看就成了一个广度优先搜索了？没错，这就是一道广度优先搜索的模板题。

**有人会不服**

有人会说，为啥不能用深搜，深搜的的代码可简单了。但是看这个数据，N\*M<=182^2，如果深搜就会超时，说不定那个就爆栈了。

**思路**

这道题我们只需要先把所有值为1的点距离设为0（初始化），将其位置依次进队，依次扩展没有计算过距离的点，每次拓展都队头后移，那么队头到1点的距离+1就是拓展的点的距离（广度优先搜索的基本思想，用队列维护）。

## 代码 ##


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct MAP
{
    int x,y;
}a[1000010];
//维护一个队列来记录进队顺序
bool f[1010][1010];
//标记这个点有没有被搜索过。
int d[1010][1010];
//这个点就是，用来存最短距离的，初值全部为0；
int dx[5]={0,0,0,-1,1},dy[5]={0,-1,1,0,0};
//direct！！方向数组是个小技能，学会能发挥很大的威力
int tail=0,head=0;
//队头和队尾
int main()
{
    memset(f,true,sizeof(f));
    //初始化全部标为true，访问过。
    scanf("%d%d",&n,&m);
    //读入啊
    for(int i=1;i<=n;i++)
    {
        string s;
        cin>>s;
        //读入本行的所有元素
        for(int j=0;j<s.size();j++)
        if(s[j]=='0')
        f[i][j+1]=false;
        //如果是0就标记为没有访问过，反过来说，就是把所有1都标记为访问过了
        else
        {
            d[i][j+1]=0;
            //初始化距离0；
            f[i][j+1]=true;
            //访问过啦
            a[++tail].x=i;
            a[tail].y=j+1;
            //入队
        }
    }
    //按队列顺序开始搜索
    for(head=1;head<=tail;head++)//枚举队首
    {
        for(int i=1;i<=4;i++)
        //用direct数组来向四方扩展。
        {
            int xx=a[head].x+dx[i],yy=a[head].y+dy[i];
            //方向数组的用处就在这里了
            if(!f[xx][yy])
            //如果没有被访问过
            {
                d[xx][yy]=d[a[head].x][a[head].y]+1;
                //这个点的距离=队头距离+1；
                f[xx][yy]=true;
                //标记访问过
                a[++tail].x=xx;
                a[tail].y=yy;
                //入队。
            }
        }
    }
    //d数组就是距离，现在可以输出了
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        printf("%d ",d[i][j]);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：Atmizz (赞：10)

### 思路：BFS+STL
首先，我们先建一个结构体，表示队列中点的坐标和到最近 ' 1 ' 的距离。然后惹，就是建立一个队列，然后把扫到的 ' 1 ' 放入队列中，进入到 BFS函数**（** 我喜欢用STL，因为STL好写，~~**STL大法好**~~**）**。现在就开始找周 围的'0',找四周的，然后就把他们放到队列里，然后惹再去找别的，直到队列为空。
### code：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>

using namespace std;

int n,m,a[183][183];
//输出的结果 
int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};
//方位移动
bool v[183][183];
//表示是否访问过 
char b[183][183];
//输入的矩阵 

struct node
{
	int x,y,d;//xy表示坐标，d表示距离 
};
queue<node> q;
void bfs()
{
	node net,now;
	while(!q.empty()) {
		now=q.front();	//取队首元素 
		q.pop();
		int x=now.x, y=now.y, d=now.d;
		a[x][y]=d;	//找最小值，当前走到的一定是最小值 
		for(int i=0;i<4;++i) {	//取最小者 
			int dx=x+xx[i],dy=y+yy[i];
			if(dx>=1 && dx<=n && dy>=1 && dy<=m && !v[dx][dy] && b[dx][dy]=='0') {
				v[dx][dy]=1;	//置1，已经访问过了 
				net.x=dx;net.y=dy;net.d=d+1;//一步一步的+ 
				q.push(net);	//入队 
			}
		}
	}
}

int main()
{
	node qq;
	scanf("%d%d",&n,&m);
	memset(v,0,sizeof v);//初始化为0，都没访问过 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j) {
			cin>>b[i][j];
			if(b[i][j]=='1') {
				qq.x=i;qq.y=j;qq.d=0;
				q.push(qq);	//如果是‘1’，距离就是0 
				v[i][j]=1;	//为‘1’的肯定访问过 
			}
			a[i][j]=99999999;		//每一个都设为一个极大值 
		}
	bfs();		//开始广搜 
	for(int i=1;i<=n;++i) {		//输出矩阵 
		for(int j=1;j<=m;++j)
			printf("%d ",a[i][j]);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：LOFTER_OI (赞：9)

看没人写暴力
蒟蒻打了一个暴力
暴力做法
很厉害
不会爆
蒟蒻不会;
```
#include<bits/stdc++.h> //万能头
using namespace std;
int n,m,i,j,z=0,d,b,c;
int dx[4]={1,-1,0,0};    
int dy[4]={0,0,-1,1};    //方向
string s;
int main()
{
    //freopen("bit.in","r",stdin);
    //freopen("bit.out","w",stdout);
    scanf("%d%d",&n,&m);   //输入
    int a[n+3][m+3];
    bool pd[n+3][m+3];
    for(i=1;i<=n;i++)
    {
        cin>>s;
        for(j=0;j<m;j++)
        {
            if(s[j]=='0') a[i][j+1]=10000000;  //是0就给一个大值
                else 
                {
                    a[i][j+1]=0;     //不然为0；
                    pd[i][j+1]=1;    //标记
                }
        }
    }
    for(z=0;z<10000;z++)        //暴力解题
    {
        for(i=1;i<=n;i++)
            for(j=1;j<=m;j++)
            {
                if(a[i][j]==z)
                {
                    for(d=0;d<4;d++)
                    {
                        b=i+dx[d];c=j+dy[d];
                        if(b>0&&b<=n&&c>0&&b<=n&&pd[b][c]==0&&a[b][c]>z)
                            a[b][c]=z+1;
                    }
                }
            }	
            
        }
    for(i=1;i<=n;i++)          //输出
    {
        for(j=1;j<=m;j++)
            printf("%d ",a[i][j]);
            printf("\n");
    }	
}
```
希望能帮你！！！

---

## 作者：zhengrunzhe (赞：8)

### 最强正解:

K-D Tree

简洁题意：给定n*m01矩阵，求所有位置的距离最近的1的曼哈顿距离

这个东西显然可以用kdtree去做

把1的点坐标插入到kdtree中，0完全可以不管它

之后所有的坐标都在kdtree中查询

时间复杂度O(nm√(nm))=182^3

~~但是这个东西实质是在kdtree上A*，容易被卡，我也不知道我为什么不开O2T一个点~~

```cpp
#include<cstdio>
#include<algorithm>
using std::abs;
using std::max;
using std::min;
using std::nth_element;
const int N=190,K=2,INF=2147483647;
int n,m,f,cnt;
struct point
{
	int d[K];
	inline point(int x=0,int y=0){d[0]=x;d[1]=y;}
	inline const bool operator<(const point &p)const
	{
		return d[f]<p.d[f];
	}
	inline const friend int manhattan(const point &x,const point &y)
	{
		int dis=0;
		for (int i=0;i<K;i++)dis+=abs(x.d[i]-y.d[i]);
		return dis;
	}
}a[N*N];
template<int k>class KD_Tree
{
	private:
		struct tree
		{
			tree *son[2];
			point range,mn,mx;
			inline const void pushup()
			{
				for (int i=0;i<k;i++)
					mx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i])),
					mn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i]));
			}
			inline const int fmin(const point &x)
			{
				int f=0;
				for (int i=0;i<k;i++)
					f+=max(mn.d[i]-x.d[i],0)+max(x.d[i]-mx.d[i],0);
				return f;
			}
		}*root,memory_pool[N*N],*tail,*null;
		inline const void init()
		{
			tail=memory_pool;
			null=tail++;
			null->son[0]=null->son[1]=null;
			for (int i=0;i<k;i++)null->mn=INF,null->mx=-INF;
		}
		inline tree *spawn(const point &x)
		{
			tree *p=tail++;
			p->range=p->mn=p->mx=x;
			p->son[0]=p->son[1]=null;
			return p;
		}
		inline tree *build(int l,int r,int d)
		{
			if (l>r)return null;
			int mid=l+r>>1;f=d;
			nth_element(a+l,a+mid,a+r+1);
			tree *p=spawn(a[mid]);
			if (l==r)return p;
			p->son[0]=build(l,mid-1,(d+1)%k);
			p->son[1]=build(mid+1,r,(d+1)%k);
			p->pushup();
			return p;
		}
		int mn;
		inline const void query(tree *p,const point &x)
		{
			mn=min(mn,manhattan(p->range,x));
			int f[2]={INF,INF};
			if (p->son[0]!=null)f[0]=p->son[0]->fmin(x);
			if (p->son[1]!=null)f[1]=p->son[1]->fmin(x);
			bool t=f[0]>=f[1];
			if (f[t]<mn)query(p->son[t],x);t^=1;
			if (f[t]<mn)query(p->son[t],x);
		}
	public:
		inline const void build()
		{
			init();root=build(1,cnt,0);
		}
		inline const int query(int x,int y)
		{
			mn=INF;query(root,point(x,y));return mn;
		}
};
KD_Tree<K>kdt;
int main()
{
	scanf("%d%d",&n,&m);char x;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (scanf(" %c",&x),x^48)
				a[++cnt]=point(i,j);
	kdt.build();
	for (int i=1;i<=n;putchar('\n'),i++)
		for (int j=1;j<=m;j++)
			printf("%d ",kdt.query(i,j));
	return 0;
}
```

---

## 作者：野菜汤 (赞：3)

题解：

首先，这题显示图像，也是为了广搜的初学者所准备的，这题也是出的十分的精妙，可谓牢牢抓住了广搜的精髓。那么此题何解请看以下解释；

那么我们若是要解决此题，先从他如何搜索开始。其实也不难，就是从为白色点的所有点作为起始点，然后先进行一次广搜，然后再在已经广搜过一次的点上再来一次，如此反复，知道得出答案。那么用样例来模拟一下就是这样的：


第一次：

[color=red]0 0 1 0

0 1 0 0

1 0 0 1[/color]


第二次：

[color=red]0 2 1 0

2 1 0 0

1 0 0 1[/color]


第三次：

[color=red]3 2 1 0

2 1 0 0

1 0 0 1[/color]

这样子应该足够清晰明了了吧，那么就请看以下标程。

```delphi
const a:array[1..4]of shortint=(0,-1,0,1);
      b:array[1..4]of shortint=(-1,0,1,0);
var road,jj:array[0..182,0..182]of longint;
    s:ansistring;
    c:array[1..35000,1..2] of longint;
    i,j,o,m,n,m1,n1,x1,y1,x,y,p,q:longint;
procedure dg(p,q,o:longint);
var i:longint;
begin
  while m1<n1 do begin{正常的广搜模式}
  for i:=1 to 4 do begin
    x:=c[m1,1]+a[i];
    y:=c[m1,2]+b[i];
    if (x>0)and(x<=n)and(y>0)and(y<=m)
    and(jj[x,y]=0)
    then begin
      c[n1,1]:=x;c[n1,2]:=y;
      jj[x,y]:=jj[c[m1,1],c[m1,2]]+1;
      inc(n1);
    end;end;
  inc(m1);
  end;
end;
begin
  readln(n,m);
  for i:=1 to n do begin
    readln(s);{因为这里跟01迷宫一样，数字中间没有空格，所以先读入成字符串然后再转换到数组中}
    for j:=1 to m do begin
    val(s[j],road[i,j]);
    if road[i,j]=1 then begin {为了后续处理的需要，记录所有白点的总数，因为是广搜，所以将他们的位置都记录到数组中}
    jj[i,j]:=1;
    inc(p);
    c[p,1]:=i;
    c[p,2]:=j;end;
    end;
  end;
  m1:=1;{头指针为1}
  n1:=p+1;{为指针为所有白点总数加1}
  dg(c[1,1],c[2,1],p);{开始广搜}
  for i:=1 to n do begin
    for j:=1 to m do write(jj[i,j]-1,' ');writeln;end;
end.
```
因为这里除了做处理的时候需要些技巧之外，其他都是套用广搜的模式，所以对于变量与数组我也不做多余的解释了。

这题可谓集广搜之精华，所以同学们不能一味的抄题解，而是要好好参悟才行！


---

## 作者：絵梨衣 (赞：2)

# 暴力思路
**注释很详细,暴力的时间取决于亮点,也就是1的个数**

~~luogu的数据很水,所以暴力过没问题~~

**暴力时间要超过1s
搜索时间在100ms以内(搜索大法好)**
```
/*
bit思路:存图的时候把亮光的点用结构体统一存下坐标
如: a[1].x=4,a[1].y=1;方便后面求距离
*/
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#define ll long long
#define maxn 2147483647
using namespace std;
int n,m,cnt,qus,ans=maxn;
int maps[1001][1001],anss[1001][1001];
inline int read(){
	int sign=1;
	char ch;
	while((ch=getchar())<'0'||ch>'9')if(ch=='-')sign=-1;
	int res=ch-'0';
	while((ch=getchar())>='0'&&ch<='9')res=res*10+ch-'0';
	return res*sign;
}
struct node{
	int sx,sy;
}a[1001000];//这个结构体的作用是记录亮光的坐标 
void init()//输入函数 
{
	n=read(),m=read();	
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		scanf("%1d",&maps[i][j]);//注意输入格式无空格.......orz....... 
		if(maps[i][j]==1)//记录亮光坐标 
		{
			cnt++;
			a[cnt].sx=i;
			a[cnt].sy=j;
		}
	}
}
void put()//输出函数 
{
	
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		cout<<anss[i][j]<<" ";
		cout<<endl;
	}
}
void solve()//解题函数 
{
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		if(maps[i][j]==0)//从头开始找非亮光点 
		{
			for(int k=1;k<=cnt/2;k++)//对于每一个点便历所有点的坐标 
			{
				if(a[k].sy==a[k-1].sy&&k>=2)continue; 
				qus=abs(i-a[k].sx)+abs(j-a[k].sy);求距离 
				ans=min(qus,ans); 
			}
			anss[i][j]=ans;
			ans=maxn;
			qus=0;
		}
	}
}
int main()
{
	freopen("bit.in","r",stdin);
	freopen("bit.out","w",stdout);//不要抄题解哦
	init();
	solve();
	put();
	return 0;
}
```


---

## 作者：dinghongyu (赞：0)

### 来一波广（宽）搜题解
### 思路：从“1”开始搜（肯定的，不然会TLE），每次将路径更为最小值，然后输出。
#### 代码：
```cpp
#include <bits/stdc++.h>
#define clr(x) memset(x,0,sizeof(x))
using namespace std;
int dx[] = {1,-1,0,0};
int dy[] = {0,0,-1,1};
int n,m,p;
bool a[183][183];
int _1[33125][2];
int que[100001][2];
int dis[183][183];
bool f[183][183];
char c;
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)
	    for (int j = 1;j <= m;j++)
	        dis[i][j] = 33124;
	for (int i = 1;i <= n;i++)
	    for (int j = 1;j <= m;j++)
	    {
			cin >> c;
			a[i][j] = c - '0';
			if (a[i][j])
			    _1[++p][0] = i,_1[p][1] = j,dis[i][j] = 0;                      //找“1”，存储
		}
	for (int i = 1;i <= p;i++)
	{
		int x = _1[i][0],y = _1[i][1];
		int head = 1,tail = 2;
		clr(f);
		f[x][y] = 1;
		que[head][0] = x;
		que[head][1] = y;       //初始化
		while (head < tail)
		{
			for (int j = 0;j < 4;j++)
			{
				int tx = que[head][0] + dx[j];
				int ty = que[head][1] + dy[j];
				if (tx > 0 && tx <= n && ty > 0 && ty <= m && !f[tx][ty] && !a[tx][ty] && dis[que[head][0]][que[head][1]] + 1 < dis[tx][ty])                              //判断+剪枝（若路径已经更长就不用继续扩）
				{
					f[tx][ty] = 1;
					que[tail][0] = tx;
					que[tail++][1] = ty;
					dis[tx][ty] = dis[que[head][0]][que[head][1]] + 1;
				}
			}
			head++;
		}           //广搜
	}               //从每个“1”开始
	for (int i = 1;i <= n;i++,puts(""))
	    for (int j = 1;j <= m;j++)
	        cout << dis[i][j] << " ";
	return 0;
}
```

---

## 作者：彭骐飞 (赞：0)

下面发一个Pas题解：

这一题是为所有点求最短距离的题，所以可以有以下的做法：

- 深度优先搜索（DFS）；

- 宽（广）度优先搜索（BFS）。


DFS思路：

- 先读入，并找出哪些是白色的，将最短距离f[i,j]设为0；

- 循环，是白色就DFS；

- 将数组f输出。

子程序DFS：

- 循环，加上方向增量值后如果那里是黑的，且距离更短就更新f，再DFS。


详见代码：

```pascal
const dx:array[1..4] of longint=(0,0,1,-1);
dy:array[1..4] of longint=(1,-1,0,0);                                                         //方向增量值dx,dy
var f:array[0..200,0..200] of longint;                                                        //状态数组，f[i,j]表示像素点i,j的最短距离
a:array[0..200,0..200] of boolean;
n,m,i,j:longint;
s:string;
procedure dfs (x,y,s:longint);                                                                  //深搜，x,y表示点的横纵坐标，s表示改点的最短距离
var i:longint;
    begin
    for i:=1 to 4 do
    if not a[x+dx[i],y+dy[i]] and (f[x+dx[i],y+dy[i]]>s+1) then            //加上方向增量值后如果那里是黑的，且距离更短
        begin
    f[x+dx[i],y+dy[i]]:=s+1;                                                                 //更新f
    dfs(x+dx[i],y+dy[i],s+1);                                                                //DFS下一轮
        end;
    end;
begin
    readln(n,m);
    fillchar(a,sizeof(a),true);
    fillchar(f,sizeof(f),127);                                                                  //初始化
    for i:=1 to n do
        begin
    readln(s);
    for j:=1 to m do
        begin
    a[i,j]:=(s[j]='1');
    if a[i,j] then f[i,j]:=0;
        end;
        end;                                                                                      //读入的字符串处理
    for i:=1 to n do
        for j:=1 to m do
        if f[i,j]=0 then dfs(i,j,0);                                                         //DFS
    for i:=1 to n do
        begin
    for j:=1 to m do
    write(f[i,j],' ');
    writeln;
        end;                                                                                      //输出
end.
```
结果：

评测结果：Unaccepted                     得分：30

提交时间：2017-05-05 14:13            耗时：538ms

内存：8781kb                                    评测机：美国的Wallace

编译信息 编译成功 没有编译信息

分点信息（鼠标移到方块上有详细信息）

#1 AC 0ms/8703kB

#2 AC 0ms/8703kB

#3 AC 538ms/8781kB

#4 TLE
#5 TLE
#6 TLE
#7 TLE
#8 TLE
#9 TLE
#10 TLE

当当当当当！完美的爆了7个点，超时！！！


好了，经过这一番折腾，我改过自新，用了正解：BFS（宽（广）度优先搜索）：

BFS思路：

- 初始化；

- 读入，将白色的点先入队，并将信息存入数组f，x[i,j]改为0；

- BFS，头指针h+1，循环；

- 将即将出队的点的坐标加上方向增量值，若未入队，则尾指针t+1，保存该点的数据，将最短路径x更改为x[f[h,1],f[h,2]]+1，并设为不能走了（进度一样，先找到该点就是最快的）；

- 当所有成员全部出队时，退出循环。


详见代码：

```pascal
const dx:array[1..4] of longint=(0,0,1,-1);
dy:array[1..4] of longint=(1,-1,0,0);                         //方向增量值dx,dy
var x:array[1..200,1..200] of longint;
a:array[0..200,0..200] of boolean;
f:array[1..34000,1..2] of longint;
n,m,i,j,h,t:longint;
s:string;
begin
    readln(n,m);
    fillchar(a,sizeof(a),true);
    t:=0;                                                               //初始化
    for i:=1 to n do
        begin
    readln(s);
    for j:=1 to m do
        begin
    a[i,j]:=(s[j]='1');
    if a[i,j] then
        begin
    t:=t+1;
    f[t,1]:=i;
    f[t,2]:=j;
    x[i,j]:=0;                                                         //是白色就入队并保存数据
        end;
        end;
        end;
    h:=0;
    repeat                                                           //开始BFS
    h:=h+1;
    for i:=1 to 4 do                                             //枚举4个方向
    if not a[f[h,1]+dx[i],f[h,2]+dy[i]] then           //如果走后的位置还没被找到过
        begin
    t:=t+1;
    f[t,1]:=f[h,1]+dx[i];
    f[t,2]:=f[h,2]+dy[i];                                        //保存数据
    x[f[t,1],f[t,2]]:=x[f[h,1],f[h,2]]+1;                    //记录该点的最短距离
    a[f[t,1],f[t,2]]:=true;                                       //该点被标记为找到了
        end;
    until h=t;                                                      //当所有点出队时就退出
    for i:=1 to n do
        begin
    for j:=1 to m do
    write(x[i,j],' ');
    writeln;
        end;                                                      //输出
end.
```

如有问题需要修正请私信我，完善之后即可获得一封感谢的（私）信。

<https://www.luogu.org/space/show?uid=11358>


---


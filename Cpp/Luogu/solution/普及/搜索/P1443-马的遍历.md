# 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。


## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

## 样例 #1

### 输入

```
3 3 1 1
```

### 输出

```
0    3    2    
3    -1   1    
2    1    4    ```

# 题解

## 作者：shajjl (赞：1599)

# STL大法好！！

## 取百家所长成一家之言！！

介绍一下用STL模板库 <queue>来广搜这道题
  
广搜什么的自然不同我介绍；
我来介绍一下非常好用但没人用的 
### pair

```
queue<pair<int,int> > q;
```

它可以将两种数据类型的值组合成一个值存入  
队列中大体是这样操作：

```
queue<pair<int,int> > q;//定义

q.push(make_pair(x,y));//入队
//取队首
xx=q.front().first;//第一个值
yy=q.front().second;//第二个值

q.pop();//出队
```
个人认为带头文件的33行代码还是很短的(>_<

上代码：
```
#include<iostream>//P1443
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const int dx[8]={-1,-2,-2,-1,1,2,2,1};
const int dy[8]={2,1,-1,-2,2,1,-1,-2};//8个方向
queue<pair<int,int> > q;
int f[500][500];//存步数
bool vis[500][500];//走没走过
int main()
{
	int n,m,x,y;
	memset(f,-1,sizeof(f));memset(vis,false,sizeof(vis));
	cin>>n>>m>>x>>y;
	f[x][y]=0;vis[x][y]=true;q.push(make_pair(x,y));
	while(!q.empty())
	{
		int xx=q.front().first,yy=q.front().second;q.pop();//取队首并出队
		for(int i=0;i<8;i++)
		{
			int u=xx+dx[i],v=yy+dy[i];
			if(u<1||u>n||v<1||v>m||vis[u][v])continue;//出界或走过就不走
		    vis[u][v]=true;q.push(make_pair(u,v));f[u][v]=f[xx][yy]+1;
		}
	}
	for(int i=1;i<=n;i++)
	 {for(int j=1;j<=m;j++)printf("%-5d",f[i][j]);printf("\n");}//注意场宽！！
	return 0;
}
```

顺手留赞，感谢φ(>ω<*) 

---

## 作者：永遠の愛 (赞：613)

## 看到这道题就兴致勃勃地用起了BFS
在这篇题解之前，你得先知道一个东西，它叫广度优先搜索（BFS）（当然可以不用宽搜的啦）

广度优先搜索就是宽搜。与深搜不同，若把深搜基本思想改为深度越小的结点越先得到扩展，就是广度优先搜索。宽搜常常用队列queue实现，这里我们就不得不涉及一些STL了 ~~（编程太难了，我们来学习珂学吧！）~~：

queue的定义方法是：

```cpp
//queue+<数据类型>+队列名称；例：
queue <int> q;//<>是不能少的
```

另外，这里有一些特殊队列，不展开细讲，大家可以上网咨询：

```cpp
deque <int> q;//双端队列
priority_queue <int> q;//优先队列（可以自动排序）
```
关于队列的一些STL命令：

```cpp
q.push(a);//将a插入到队尾
q.pop();//队首出列
q.empty()//判断队列是否为空
q.front();//队首
q.back();//队尾
```

其它命令大家也可以上网搜~

队列的基本思想：先进先出，这也导致无法从队列中间插入数据 （就像你食堂打饭不能插队，否则食堂大妈会给予你手抖攻击）。

上面一段摘自我的[博客](https://www.luogu.com.cn/blog/goldy/qian-tan-cha-zhao-yu-sou-suo)，内容可借鉴，不可抄袭！

之后我们就来康康这道题吧！

~~（别跟我说你连马走日字都不知道）~~

首先来定义队列，我们可以定两个队列（q、q1）分别表示行和列，当然也可以在一个队列中数据类型用pair，这个我[这篇文章](https://www.luogu.com.cn/blog/goldy/qian-tan-cha-zhao-yu-sou-suo)里也有，就四把两个数据变成一个数据组了啦~

用pair定义是这样的：
```cpp
queue < pair<int,int> > q;
```
这里我就用简单一点的两个队列，pair你们自行研究啦！ ~~（当然你要用结构体我也不拦你，只要你不被绕进去）~~

然后定义两个~~压行~~快捷的数组，表示马移动的方向：
```cpp
int dx[8]={-2,-2,2,2,1,-1,1,-1};
int dy[8]={-1,1,-1,1,2,-2,-2,2};
```
自己推推也能出来的啦~ ~~（别跟我说你连马走日字都不知道）~~

在定义两个数组，一个记录答案，这个不用说，还有一个比较重要，记录这个点是否被访问过，要是没有这个数组就会一直一直死循环（就是每个点被访问无数次）。这个数组一般用vis（表示visit，~~当然我随便用了个a，毕竟这是我的码风~~）定义名称。

当然，为了快捷一点，我们可以把ans数组全部清-1，这样没有访问到的点就不改变答案数字（开始马所在的位置当然归0啦）。

然后程序主体来了：

## CODE
```cpp
while(!q.empty()){//判断（其中一个）队列是否为空
	for(int i=0;i<8;i++){//八方向哦（别跟我说你连马走日字都不知道）
		int tx=q.front()+dx[i];//关于行，把队首取出，加上数组中的方向
		int ty=q1.front()+dy[i];//同上（
		if(tx>0&&tx<=n&&ty>0&&ty<=m&&a[tx][ty]==0){//判断是否越界，是否访问过此点
			a[tx][ty]=1;//标记为访问过
			ans[tx][ty]=ans[q.front()][q1.front()]+1;//这一格的答案数字是前面一格（队首）加上1
			q.push(tx);
			q1.push(ty);//行列推入队列，基本操作
		}
	}
	q.pop();
	q1.pop();//出队基本操作，要不然也是死循环
}
```
然后我们的程序主要部分就OK~\(≧▽≦)/~啦！

最后搞一下输出：
```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		printf("%-5d",ans[i][j]);
	}
	printf("\n");
}
```
本来我是用setw场宽做的，结果它给你来个WA，卡了一会儿。 ~~（但是网上一搜就有了鸭）~~

# 最后附上完整代码吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
queue<int>q,q1;
int a[401][401],ans[401][401];
int dx[8]={-2,-2,2,2,1,-1,1,-1};
int dy[8]={-1,1,-1,1,2,-2,-2,2};
int main(){
	memset(ans,-1,sizeof(ans));
	int n,m,startx,starty;
	cin>>n>>m>>startx>>starty;
	q.push(startx);
	q1.push(starty);
	ans[startx][starty]=0;
	a[startx][starty]=1;
	while(!q.empty()){
		for(int i=0;i<8;i++){
			int tx=q.front()+dx[i];
			int ty=q1.front()+dy[i];
			if(tx>0&&tx<=n&&ty>0&&ty<=m&&a[tx][ty]==0){
				a[tx][ty]=1;
				ans[tx][ty]=ans[q.front()][q1.front()]+1;
				q.push(tx);
				q1.push(ty);
			}
		}
		q.pop();
		q1.pop();
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%-5d",ans[i][j]);
		}
		printf("\n");
	}
	return 0;
}

```
求赞（づ￣3￣）づ╭❤～！

---

## 作者：YE110W_No1 (赞：321)

###用queue写了一个bfs 没人发的话我就发一下 代码简洁易懂 只用了8ms过

```cpp
#include <cstdio>
#include <string.h>
#include <cmath>
#include <queue>
using namespace std;
struct xy{
    int x,y;
}node,Top;
const int dx[4]={1,-1,2,-2};
const int dy[4]={1,-1,2,-2};//虽说一共16个方向 但是在程序中有具体判断
int a[401][401];
bool b[401][401];
int n,m;
void bfs(int x,int y,int step){
    a[x][y] = step;
    b[x][y] = false;
    queue<xy> Q;//构建队列
    node.x = x;
    node.y = y;
    Q.push(node);//起始点入队
    while (!Q.empty()){
        Top=Q.front();//取出队首点
        Q.pop();//队首点出队
            for (int i=0;i<4;i++)
                for (int j=0;j<4;j++)
                    if (abs(dx[i])!=abs(dy[j])){//判断方向
                        int NewX=Top.x+dx[i];
                        int NewY=Top.y+dy[j];
                        if (NewX<1||NewX>n||NewY<1||NewY>m) continue;//判断越界
                        if (b[NewX][NewY]){//使用布尔数组保证每个点只入队一次 时间复杂度明显低于DFS
                            node.x=NewX;
                            node.y=NewY;
                            Q.push(node);
                            b[NewX][NewY] = false;//标记已入队
                            a[NewX][NewY] = a[Top.x][Top.y]+1;//路径+1
                        }
                    }
    }
}
int main(){
    memset(b,true,sizeof(b));
    memset(a,-1,sizeof(a));
    int x,y;
    scanf("%d%d%d%d" ,&n ,&m ,&x ,&y );
    bfs(x,y,0);
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++)
            printf("%-5d", a[i][j]);//注意场宽 我在这被卡了两次= =
        printf("\n");
    }
    return 0;
}
```

---

## 作者：CXY07 (赞：286)

一只蒟蒻的第一篇题解，一道裸的广搜，用 $BFS$ 队列做的，只用了$4ms$。

其实就是把棋盘上的每一个点按照规则入队，第一次到达该点时的步数一定是最优步数（废话）

我觉得最需要注意的就是程序中 $que$ 数组的大小，尝试开 $20000$ 后在第九个点$RE$了，过了好久才发现问题 $0.0$

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct queue_
{
	int x,y;//一个结构体，x，y是队列该位置放的点的x，y值
} que[160010];//这里一定要注意数组大小，我在这里RE了两次！！
int head=0,tail=1,get[401][401],n,m,sx,sy;
int fx[16]={2,-2,2,-2,-1,1,-1,1},fy[16]={1,1,-1,-1,2,2,-2,-2};//方向
int main()
{
	cin>>n>>m>>sx>>sy;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			get[i][j]=-1;//初始化
	get[sx][sy]=0;//第一个点入队
	que[1].x=sx;
	que[1].y=sy;
	while(head<tail)
	{
		head++;//头指针加1
		int s=get[que[head].x][que[head].y]+1;//这个s是指扩展到新点时所需要的最少步数，就是上一个点的步数加1
		for(int i=0;i<8;++i)
		{
			int nx=que[head].x+fx[i],ny=que[head].y+fy[i];//扩展新点
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&get[nx][ny]==-1)//没有超出棋盘并且没有走过
			{
				tail++;
				que[tail].x=nx;
				que[tail].y=ny;//新点入队
				get[nx][ny]=s;//标记到达该点的最小步数
			}
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=m;++j)
			printf("%-5d", get[i][j]);//输出，注意格式
		cout<<endl;
	}
	return 0; //华丽丽地结束
}
```


如果有错误或者有更好的办法，欢迎大佬们赐教 $QWQ$

蒟蒻的题解就这么结束啦，值得纪念

## 2019.8.1 UPD
~~考古~~

嗯......蒟蒻的第一篇题解，现在来看还是有很多地方说得不够清楚，所以现在 $update$ 一下，并把之前一些有问题的地方改掉了。

首先，是数组大小的问题，请注意数据的范围，$1<n,m<=400$，也就是说，这个棋盘最大将是 $400 × 400$，而如果数据正好 $n == 400$ 且 $m == 400$，则此时共有$160000 (400^2)$个点，又题目需要我们求出到达所有点的步数，也就是**所有点都需要入队一次**，那么需要 $160000 (400^2)$ 的数组大小。

也就是说，如果数据更大一些，我的代码应该是过不了的 ~~幸好数据水~~

还有一个，$Julao$ 们说可以用 $STL$ ，是的没错，的确可以用，并且这样在本题中还可以忽略爆数组的可能，超级便利。但是当时的我不知道怎么用 ~~qwq~~ ,现在补上

对于一些不知道 $queue$ 和 $pair$ 的童鞋，~~这边推荐您上网自行度娘的呢~~

这里的 $pair$ 可以用结构体来代替，看个人喜好

还有一点，之前我在更新的时候，把 $get$ 数组的判断放在了前面，这样有时候是会 $RE$ 的

```cpp
if(get[nx][ny]==-1&&nx>=1&&nx<=n&&ny>=1&&ny<=m)
```
应改为
```cpp
if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&get[nx][ny]==-1)
```

$STL$ 版本代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 410;
const int fx[10]={0,2,-2,2,-2,-1,1,-1,1},fy[10]={0,1,1,-1,-1,2,2,-2,-2};//方向

int n,m,stx,sty;
int dis[MAXN][MAXN];
queue<pair<int,int> > Q;//本题不需要担心爆数组

int main () {
	scanf("%d%d%d%d",&n,&m,&stx,&sty);
	memset(dis,-1,sizeof dis);//初始化
	dis[stx][sty] = 0;
	Q.push(make_pair(stx,sty));//第一个点入队
	while(Q.size()) {
		int x = Q.front().first,y = Q.front().second;
		for(register int i = 1,newx,newy;i <= 8; ++i) {
			newx = x + fx[i]; newy = y + fy[i];//扩展新点
			if(newx >= 1 && newx <= n && newy >= 1 && newy <= m && dis[newx][newy] == -1) {//没有超出棋盘并且没有走过
				dis[newx][newy] = dis[x][y] + 1;//标记到达该点的最小步数
				Q.push(make_pair(newx,newy));//新点入队
			}
		}
		Q.pop();
	}
	for(register int i = 1;i <= n; ++i)	{
		for(register int j = 1;j <= m; ++j) 
			printf("%-5d", dis[i][j]);//输出，注意格式
		puts("");//相当于cout << endl
	}
	return 0;
} 
```

不过 $STL$ 版本的略慢，要 $40ms$。

以上就是对本题解的一些补充，如果各位还有疑惑，可以在评论里提出

~~（补充一下，我在评论里说的意思是爆数组，不是栈溢出，打DFS打多了脑子有点问题qwq）~~

准初三的 $OIer$ ，请多关照

---

## 作者：学无止境 (赞：148)

23行AC代码！~~（个人认为很短了）~~


但提交后 **4ms**  **AC** 大感惊讶，来分享一下——


马有八个方向，存数组比if——if——if——if...好得多（见代码mx[ ]，my[ ]）


还有要注意n行m列，给的出发坐标先给的行！（可能只有我因为这个WA？）


再注意越界判断要在访问数组之前


既然是BFS标签，就用朴素的BFS啦，（但其实效率差不多是最高的了）


PS：用到了iomanip头文件中的setw（）函数控制对齐.（我就是不用printf函数）


**Code：**


```cpp
#include<bits/stdc++.h>     //万能库（其实是为了压行~）
using namespace std;
int b,e=2,a[410][410],pro[410*410][2],mx[8]={2,-2,2,-2,-1,1,-1,1},my[8]={1,1,-1,-1,2,2,-2,-2},n,m,x,y;
int main()
{
    cin>>n>>m>>x>>y;
    memset(a,0xff,sizeof(a));//初始值：-1 
    pro[1][0]=x,pro[1][1]=y,a[x][y]=0;
    while(b++<e-1)//头端加1并判断 
    for(int i=0;i<8;i++)
    {
        int xx=pro[b][0]+mx[i],yy=pro[b][1]+my[i];//先求坐标判断后再用数组访问 
        if(xx>0&&yy>0&&xx<=n&&yy<=m&&a[xx][yy]==-1)
        pro[e][0]=xx,pro[e++][1]=yy,a[xx][yy]=a[pro[b][0]][pro[b][1]]+1;//添加到bfs数组尾端 
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        cout<<left<<setw(5)<<a[i][j];//控制行距 
        cout<<endl;
    }    
    return 0;
} 
```


---

## 作者：momentous (赞：127)

此题为广搜模板题,但有一些变形

我在题解里面翻了一会,并没有找到特别好理解的方法

在此发一篇简单、易懂的题解

也是写一下自己对广度优先搜索的理解

Step1
-----
读入长、宽,和马的初始位置坐标

并将其压入队尾

开始 bfs

Step2
-----
在队列不为空时,一直提取队列中的第一个元素

并进行拓展,将拓展得到的节点压入队尾

重复操作 Step2

Step3
-----
根据数字的长短输出空格即可

代码
----
注释代码中有,可自行查看
```Cpp
#include<cstdio>
#include<queue>
/*
  <queue> 队列头文件
  用到的函数:
    1:队列名称.front();
      返回队列中的第一个元素
    2:队列名称.pop();
      删除队列中的第一个元素
    3:队列名称.empty();
      检查队列是否为空
        若为空,返回 true
        否则返回 false
    4:队列名称.push(...);
      将括号内元素插入到队列末尾
*/
using namespace std;
queue<int> qx,qy,qstep;
/*
  qx队列用来存放 x 坐标
  qy队列用来存放 y 坐标
  qstep队列用来存放 步数
*/
int n,m,X,Y,a[500][500];
/*
  n 为长, m 为宽
  X,Y代表马从哪里开始跳
  a[][]用来存放最终解
*/
bool vis[500][500];
/*
  vis初始为false
  vis用来判断这个点是否走过
    根据广搜的性质,一个点被第一个搜到一定是最优解
*/
int xx[9]={0,-1,-2,-2,-1,1,2,2,1};
int yy[9]={0,-2,-1,1,2,2,1,-1,-2};
/*
  xx[],yy[]表示马的8种跳法所带来 x 轴和 y 轴的变化
*/
void Print(int x)
{
    int Ws=0;
    if(x==0) printf("    ");//特判,0占一位
    else
    {
        while(x>0)
        {
            ++Ws;// 位数+1
            x/=10;// x/=10 相当于将x的最后一位删除
        }
        for(int S=1;S<=5-Ws;++S)//向左对齐,输出 5-位数 个空格
            printf(" ");
    }
}
void bfs()
{
    int x,y,step;
    while(qx.empty()==0)
    {
        x=qx.front();//返回 qx 第一个元素的值
        y=qy.front();//返回 qy 第一个元素的值
        step=qstep.front();//返回 qstep 第一个元素的值
        a[x][y]=step;
        /*
          广搜的最优性质
        */
        qx.pop();qy.pop();qstep.pop();
        /*
          将 qx,qy,qstep 的第一个元素弹出
        */
        for(int i=1;i<=8;++i)
        {
            if(x+xx[i]>=1 && x+xx[i]<=n && y+yy[i]>=1 && y+yy[i]<=m && vis[x+xx[i]][y+yy[i]]==0)
            /*
              判断是否出界 以及该点是否被访问过
            */
            {
                vis[x+xx[i]][y+yy[i]]=1;//该点被访问
                qx.push(x+xx[i]);//压入新的 x 坐标
                qy.push(y+yy[i]);//压入新的 y 坐标
                qstep.push(step+1);//走到该点又要一步
            }
        }
    }
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&X,&Y);//读入
    qx.push(X);//将初始位置 x 坐标压入队列
    qy.push(Y);//将初始位置 y 坐标压入队列
    qstep.push(0);//初始位置只要走 0 步
    vis[X][Y]=1;//坑点,要将初始位置设为走过,否则会出现回跳现象
    bfs();//将任务交给广搜
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
            if(!vis[i][j]) printf("-1   ");//若该点未走到过,则输出 -1 以及3个空格
            else
            {
                printf("%d",a[i][j]);//输出那个数
                Print(a[i][j]);//输出对应的空格数
            }
        printf("\n");//回车
    }
    return 0;
}
```
感谢各位的观看

---

## 作者：__gcd (赞：91)

刚开始做的时候用的dfs，相信很多人都是这么做的。
```
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y;
int dx[8]={2,-2,2,-2,-1,1,-1,1};
int dy[8]={1,1,-1,-1,2,2,-2,-2};
// 标记马的行走方向 
int ans[401][401];//每个点的步数 
int check(int a,int b)
//检查是否越界 
{
    if(a<1||a>n||b<1||b>m)
        return 0;
    return 1;
}
void dfs(int a,int b,int sum)
//a和b是当前搜到的坐标，sum为步数 
{
    int nx,ny;
    ans[a][b]=sum;//将答案标记 
    for(int i=0;i<8;i++)
    //搜索八个方向 
	{
        nx=a+dx[i];
        ny=b+dy[i];
        //扩展新点 
        if(check(nx,ny)&&(sum+1<ans[nx][ny]||ans[nx][ny]==-1))
		//步数比原先搜到的小或没搜到过 
            dfs(nx,ny,sum+1);//搜索下一个 
    }
}
int main()
{
    cin>>n>>m;
    cin>>x>>y;
    memset(ans,-1,sizeof(ans));//初始化 
    dfs(x,y,0);//搜索 
    for(int i=1;i<=n;i++)
	{
        for(int j=1;j<=m;j++)
            printf("%-5d",ans[i][j]);
        cout<<endl;
    }//输出 
    return 0;
}
```
结果果然TLE了。


------------

### 那么大家有没有想过：为什么会TLE呢？
我们都知道dfs是一条路搜到黑，所以不可以保证最开始搜到的就是最近点。也就是说，我们在遍历的过程中，结果是在不断更新的。

那么就是说我们把马所有可能走的路径全都搜索了一遍，有很多搜索都是累赘的。


------------

### 所以能不能有一种办法，避免这种累赘搜索，一次就可以找到最优步数？
这时候就要拿出bfs（广度优先搜索）了。

先贴一张bfs的模板
```
void bfs()
{
	 初始化，初始状态存数组; 
	 int head=0,tail=1，que[max_size];//构建队列
	 标记初始点 
	 while(head<tail)
	 {
	 	head++;//指向待扩展结点
		for(i=1;i<=maxi;++i)
		{
			if(满足条件||不重复)
			{
				tail++;
				将新节点存入队列
			}	
		}
	}
}
```

可以拿张纸模拟一下整个搜索的过程，可以发现，广搜每步搜索离初始点的步数都是相等的。

### 那么最先搜到的不就是最近的吗？
大家现在可以打开编程软件，照着模板打一遍bfs，再对比一下我的程序，说不定可以AC哦。


------------
全代码双手奉上
```
#include<iostream>
#include<cstring>
using namespace std;
bool vis[410][410];
//vis标记是否走过 
int n,m;
int ans[410][410];
int dx[8]={2,1,1,2,-1,-2,-2,-1};
int dy[8]={1,2,-2,-1,2,1,-1,-2};
struct Queue{
	int x,y;
}que[40010];//构建bfs的队列 
int check(int x,int y)
{
	if(x<1||x>n||y<1||y>m)
		return 0;
	return 1;
}//判断越界 
void bfs(int x,int y)
//x,y为初始坐标 
{
	int head=0,tail=1;//队列头尾指针 
	int sum=0;//步数清零 
	que[1].x=x;que[1].y=y; 
	//初始点入队 
	vis[x][y]=true;
	//将初始点标记 
	ans[x][y]=0;
	while(head<tail)//搜完了就退出 
	{
		head++;//头指针指向待扩张点 
		sum=ans[que[head].x][que[head].y]+1;
		//标记步数 
		for(int i=0;i<8;i++)
		{
			int nx=que[head].x+dx[i];
			int ny=que[head].y+dy[i];
			//扩展新点 
			if(check(nx,ny)&&!vis[nx][ny])
			//如果没走过 
			{
				tail++;
				que[tail].x=nx;que[tail].y=ny;
				//将两个点入队 
				vis[nx][ny]=true;
				//标记为搜过 
				ans[que[tail].x][que[tail].y]=sum;
				//标记步数 
			}
		}
	}
}
int main()
{
	int x,y;
	cin>>n>>m>>x>>y;
	memset(ans,-1,sizeof(ans));//初始化 
	bfs(x,y);//搜索 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			printf("%-5d",ans[i][j]);
		cout<<endl;
	}//输出 
	return 0;
}
```
祝大家早日红名awa

---

## 作者：lxzy_ (赞：84)

## 对于初学搜索算法的OIer这是一道不错的练习题。

---

$$\color{red}\text{First：选择解决方案：}$$

从一个点出发，搜寻另外的点，这明显是一道关于搜索的题目。至于用到深搜还是广搜，见下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/g3ki07dn.png)


从上图我们看到，BFS专门用于解决求两点之间最短路的问题，而DFS是用来解决求一个点到另一个点路径总数的问题。显然地，这题用到的是BFS。

---

$$\color{green}\text{Second：注意事项}$$

### $1.$

~~这道题不像广搜板子题那么好打，~~ 其坐标偏移量毒瘤的很。“马走日，象走田”，在棋盘上，马按照“日”字的走法移动，对应到我们的数组大概是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/1s3zco2a.png)

（PS:其中红色为出发点，黄色为可到达的点）

我们发现，从$a[4][6]$出发，可到达的点为：$a[2][5]$、$a[3][4]$、$a[2][7]$、$a[3][8]$、$a[5][4]$、$a[6][5]$、$a[6][7]$、$a[5][8]$。也就是说，坐标偏移量为：
```cpp
int dx[8]={-2,-2,-1,-1,2,2,1,1};
int dy[8]={1,-1,2,-2,1,-1,2,-2};
```
### $2.$

~~出题人认为题目太水而加入了毒瘤的输出格式~~

其实输出格式挺简单的，可以使用$printf$

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=m;j++)
    {
    	printf("%-5d",a[i][j]);//C/C++左对齐场宽
    }
    printf("\n");
}
```

也可以使用$cout$：

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=m;j++)
    {
		cout<<left<<setw(5)<<a[i][j]。//C++左对齐场宽
	}
    cout<<endl;
}
```

不过记得要加上：
```cpp
#include<iomanip>
```

好的，该说的都说完了，下面开干！

---

$$\color{purple}\text{Third：Code}$$

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<iomanip>
using namespace std;
const int N=501;

int a[N][N];//定义501*501的储存答案的数组

struct point{
	int x;
	int y;
	int t;
};//广搜结构体，对于每一个点，要储存它的横坐标(x坐标)，纵坐标(y坐标)，当前所走的步数

queue<point> que;//广搜必备队列，C++STL万岁O(∩_∩)O~~
int n,m,sx,sy;//棋盘边界、出发点坐标。

int dx[8]={-2,-2,-1,-1,2,2,1,1};
int dy[8]={1,-1,2,-2,1,-1,2,-2};//坐标偏移量

int main()
{
	memset(a,-1,sizeof(a));//答案数组全部赋值-1，能达到就改为当前步数，不能改就直接输出。
	scanf("%d%d%d%d",&n,&m,&sx,&sy);
	a[sx][sy]=0;//切记，一定要把起点赋值为0，否则全WA
    
    //广搜
	que.push((point){sx,sy,0});//将起点放入队列
	while(!que.empty())//只要还有可以走的点，就继续执行
	{
		point f=que.front();//将当前点拿出来
		que.pop();//扔掉当前点
        
		for(int i=0;i<=7;i++)//遍历当前点所能走到的其它点
		{
			int nx=f.x+dx[i];
			int ny=f.y+dy[i];//通过坐标偏移量得到可以走的点的坐标
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&a[nx][ny]==-1)//当前点既没超出棋盘范围又还没有走过
			{
				a[nx][ny]=f.t+1;//这个点的答案就是上一个点的答案+1辣
				que.push((point){nx,ny,f.t+1});//当前点可行，我们将其放入队列
			}
		}
	}
    //滑稽的输出
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			printf("%-5d",a[i][j]);
		}
		printf("\n");
	}
	return 0;//完美~^_^
}
```

---

## 作者：K2sen (赞：26)

# P1443
### 所属知识点：BFS
[传送门](https://www.luogu.org/problem/P1443)
## 题意 :
给你一个矩阵和一匹马一开始的位置.然后问你在这个矩阵里边跳到每一个点需要多少步.

## 思路：
因为一匹马从一个点可以跳到的位置如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/9w40mavm.png)

画的不好请见谅...

我们就可以开始进行bfs了，最好的板子题.

然后最后输出的时候因为要留5个长宽.

可以这样搞：
```cpp
	cout << setw(5) << std::left << maze[i][j];
```

##code：
```cpp
#include <bits/stdc++.h>
#include <queue>
#define N 100010
#define M 1010
#define _ 0

using namespace std;
struct node {
	int x, y, bushu;
};
int m, n, x, y;
int u[8]= {1, 2, 2, 1, -1, -2, -2, -1};
int v[8]= {-2, -1, 1, 2, 2, 1, -1, -2};
int maze[401][401];
queue<node> q;

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void bfs(int r, int t) {
	memset(maze, -1, sizeof(maze));
	maze[r][t] = 0;
	q.push((node) {r, t, 0});
	while (!q.empty()) {
		node a = q.front();
		q.pop();
		for (int i = 0; i <= 7; i++) {
			int fx = a.x + u[i];
			int fy = a.y + v[i];
			if (fx >= 1 && fx <= n && fy >= 1 && fy <= m && maze[fx][fy] == -1) {
				maze[fx][fy] = a.bushu + 1;
				q.push((node) {fx, fy, a.bushu + 1}); 
			}
		}
	}
}

int main() {
	n = read(), m = read(), x = read(), y = read();
	bfs(x, y);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) 
			cout << setw(5) << std::left << maze[i][j];
		puts("");
	}
	return 0^_^0;
}
```

---

## 作者：哥66666 (赞：21)

一开始我用深搜，查到一个更新一个点，结果。。。。。。炸了。两个AC，其他全是TLE。所以深搜害人不深啊。

我后来还是用回了宽搜。

宽搜很简单，先有定义头指针ltop和尾指针rtop，和判断这个位置有没有走过的bz，还有一个队列a[1..400,1..3]。a[i,1]记录x坐标，a[i,2]记录y坐标，a[i,3]记录第几步。

主要部分思路如下

一开始尾指针inc(rtop),从a[top,1],a[top,2]开始发展，如果可以走（走了之后不超范围并且没走过）就inc(ltop)和更新a[ltop]

代码如下：

```cpp
var
        fx:array[1..8,1..2]of longint=((1,2),(2,1),(-1,2),(-2,1),(1,-2),(2,-1),(-1,-2),(-2,-1));
        bz:array[1..400,1..400] of boolean;
        a:array[1..100000,1..3] of longint;
        f:array[0..401,0..401] of longint;
        i,j,x,y,n,m,ltop,rtop:longint;
begin
        fillchar(f,sizeof(f),$FF);
        fillchar(bz,sizeof(bz),1);
        read(n,m,x,y);
        f[x,y]:=0;
        bz[x,y]:=false;
        a[1,1]:=x;
        a[1,2]:=y;
        a[1,3]:=0;
        ltop:=1;
        while ltop>rtop do
        begin
                inc(rtop);
                for i:=1 to 8 do
                        if (a[rtop,1]+fx[i,1]<=n) and (a[rtop,1]+fx[i,1]>0) and (a[rtop,2]+fx[i,2]<=m) and (a[rtop,2]+fx[i,2]>0) and bz[a[rtop,1]+fx[i,1],a[rtop,2]+fx[i,2]] then
                        begin
                                inc(ltop);
                                a[ltop,1]:=a[rtop,1]+fx[i,1];
                                a[ltop,2]:=a[rtop,2]+fx[i,2];
                                a[ltop,3]:=a[rtop,3]+1;
                                f[a[ltop,1],a[ltop,2]]:=a[ltop,3];
                                bz[a[ltop,1],a[ltop,2]]:=false;
                        end;
        end;
        for i:=1 to n do
        begin
                for j:=1 to m do
                begin
                        write(f[i,j]);
                        if (f[i,j]<10) and (f[i,j]>=0) then write('    ');
                        if ((f[i,j]<100) and (f[i,j]>=10)) or (f[i,j]=-1) then write('   ');
                        if (f[i,j]<1000) and (f[i,j]>=100) then write('  ');
                        if (f[i,j]>=1000) then write(' ');
                end;
                writeln;
        end;
end.
```

---

## 作者：Social_Zhao (赞：12)

## 万年之后，我来二刷这题

> 马飞斜日象飞田，炮打翻山兵向前

上一次，我用的是妇孺皆知的百度优先搜索（$BFS$）算法。

如果我这次还用$BFS$，

> 那还有什么意义呢？——熊粪山

那如果用大佬优先搜索（$DFS$）呢？

> 那还是人吗？——熊粪山

好的我们开始。

这道题，我的思路是：

# $SSSP$

把整个棋盘看成一张图，每个点可以向周围的八个方向连边。但是$SSSP$算法众多，本题用哪一种呢？

我们来计算一下。

读一读数据范围：

> 1<$n$,$m$<=400

最坏情况下，有$400^2$即$1.6 \times 10^5$个点。又因为每个点放射出八条边，所以有$1.28 \times 10^6$条边。

$Floyd$：$O(n^3)$？不可能，$Floyd$是求所有点对最短路的，用来求$SSSP$太不值了。

$Bellman-Ford$：$O(nm)$？也不可能。这样计算次数会达到$204800000000$级别。$T$飞

$S_{hort} P_{ath} F_{ast} A_{lgorithm}$：$O(km)$？这个倒是可以。$k$的**平均值**是$2$，是一种很优秀的算法。但是,我们这可是网格图啊！这时候，$SPFA$又退化到了$O(nm)$。稳稳$T$飞。$SPFA$又死了。

因此，我们选择

### ~~希望（雾）~~ 堆优化$Dijkstra$：$O(n+m)\log n$，时间上是可以接受的。

如果你不会$Dijkstra$，建议你参考这些文章：

- [洛谷日报#90：[刷题永动机]浅谈$Dijkstra$](
https://www.luogu.org/blog/ztyluogucpp/qian-tan-dijkstra)
- 《信息学奥赛一本通 **·** 提高篇》

核心代码：

```cpp
inline void Dijkstra(int st)
{
	priority_queue<pair<int,int> >q;
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[st]=0;
	q.push(make_pair(0,st));
	while(q.size()) {
		int minn=q.top().second;
		q.pop();
		if(vis[minn]) continue;
		vis[minn]=1;
		for(int i=h[minn];i;i=e[i].nxt) {
			int y=e[i].v;
			int z=e[i].dis;
			if(dis[y]>dis[minn]+z) {
				dis[y]=dis[minn]+z;
				q.push(make_pair(-dis[y],y));
			}
		}
	}
}
```

## 那么都想到这样了，怎么将这张棋盘转化为图呢？

稍微思考一下，都可以发现，我们是可以把一个二维数组拍成一维的（降维打击）如：

| (1,1) | (1,2) | (1,3) |
| :----------: | :----------: | :----------: |
| **(2,1)** | **(2,2)** | **(2,3)** |
| **(3,1)** | **(3,2)** | **(3,3)** |

可以拍成：

| (1,1) | (1,2) | (1,3) | (2,1) | (2,2) | (2,3) | (3,1) | (3,2) | (3,3) |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |

找规律，二维数组中的$I$行$J$列被拍到一维数组中是第$M*(i-1)+j$个

### 即$MAP(i,j)=M*(i-1)+j$。

于是，它周围八个点的位置也可以找到。注意判断越界

建图的问题解决了。

核心代码：

```cpp
for(register int i=1;i<=n;i++) {
	for(register int j=1;j<=m;j++) {
		for(int k=1;k<=8;k++) {
			int nx=i+dirx[k],ny=j+diry[k];
			if(nx>0&&nx<=n&&ny>0&&ny<=m) {
				//printf("(%d,%d)->(%d,%d)\n",i,j,nx,ny);
				addedge(MAP(i,j),MAP(nx,ny));
				addedge(MAP(nx,ny),MAP(i,j));
			}
		}
	}
}
```

剩下的就简单了。我们先以$MAP(x,y)$为源点求$SSSP$，然后一个两重循环，输出$dis[MAP(i,j)]$。完事

关于输出：我用的是$printf$。左对齐，所以带参数： $\text{\%-5d}$

放全代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MaxN=160005;
int n,m;
int x,y;
struct Edge {
	int v,nxt,dis;
}e[MaxN*8*2];
int h[MaxN],vis[MaxN],k=1;
int dis[MaxN];
int dirx[9]={0,1,2,-1,-2,1,2,-1,-2};
int diry[9]={0,2,1,-2,-1,-2,-1,2,1};

inline int MAP(int a,int b) { return m*(a-1)+b; }
inline void addedge(int u,int v)
{
	e[k].v=v;
	e[k].dis=1;
	e[k].nxt=h[u];
	h[u]=k++;
}

inline void Dijkstra(int st)
{
	priority_queue<pair<int,int> >q;
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[st]=0;
	q.push(make_pair(0,st));
	while(q.size()) {
		int minn=q.top().second;
		q.pop();
		if(vis[minn]) continue;
		vis[minn]=1;
		for(int i=h[minn];i;i=e[i].nxt) {
			int y=e[i].v;
			int z=e[i].dis;
			if(dis[y]>dis[minn]+z) {
				dis[y]=dis[minn]+z;
				q.push(make_pair(-dis[y],y));
			}
		}
	}
}

int main()
{
	cin>>n>>m>>x>>y;
	for(register int i=1;i<=n;i++) {
		for(register int j=1;j<=m;j++) {
			for(int k=1;k<=8;k++) {
				int nx=i+dirx[k],ny=j+diry[k];
				if(nx>0&&nx<=n&&ny>0&&ny<=m) {
					//printf("(%d,%d)->(%d,%d)\n",i,j,nx,ny);
					addedge(MAP(i,j),MAP(nx,ny));
					addedge(MAP(nx,ny),MAP(i,j));
				}
			}
		}
	}
	//cout<<k<<endl;
	Dijkstra(MAP(x,y));
	//cout<<MAP(x,y)<<endl;
	for(register int i=1;i<=n;i++) {
		for(register int j=1;j<=m;j++) {
			printf("%-5d",dis[MAP(i,j)]==0x3f3f3f3f?-1:dis[MAP(i,j)]);
		}
		printf("\n");
	}
}
```

撒花

---

## 作者：JeffWang2019 (赞：9)

# bfs模板题目

bfs（广度优先搜索）需要一个队列来实现，算法就是在队列不为空的情况下，访问每一个点，访问后**将与该点连接的所有点加入队列尾部，再将该点从队首退出**。

```cpp
struct node
{
	int x,y,step;
}st;
queue<node>zjl;
```


同时要建两个表示方向的数组，本题可以这么建：

```cpp
int dx[8]={2,2,1,1,-1,-1,-2,-2},dy[8]={1,-1,2,-2,2,-2,1,-1};
```
用2、1、-1、-2是因为马走日字，同一个下标的dx和dy相互对应，表示每一种走法

这题就很适用bfs，dfs根本没有用

下面让我们用代码来实现：

```cpp
#include <bits/stdc++.h>//古老的万能头
using namespace std;//加了这个才能使用queue
int mp[402][402];//记录棋盘
int dx[8]={2,2,1,1,-1,-1,-2,-2},dy[8]={1,-1,2,-2,2,-2,1,-1};//前面已讲过
int n,m;
struct node
{
	int x,y,step;
}st;
queue<node>zjl;//我有个好友姓名拼音首字母是zjl，所以这里引用一下（嘻嘻）
void bfs() //大头来了
{
	zjl.push(st); //将起始坐标入队
	mp[st.x][st.y]=0;//记录原点步数为0，显然
	while(!zjl.empty())//只要队列不为空就一直循环
	{
		node t=zjl.front(); //临时变量t
		zjl.pop();//队首已经存在t里了，可以出队
		for(int i=0;i<8;i++)//走每种情况
		{
			int xx=t.x+dx[i];//走后的x坐标
			int yy=t.y+dy[i];//走后的y坐标
			if(xx<1||yy<1||xx>n||yy>m)//边界
			{
				continue;
			} 
			if(mp[xx][yy]!=-1) //已访问
			{
				continue;
			}
			mp[xx][yy]=t.step+1;//步数加一
			zjl.push((node){xx,yy,t.step+1});//将新能遍历的格子入队
		}
	}
}
int main()//主函数
{
    memset(mp,-1,sizeof(mp));//先全初始化为-1与题目呼应
	scanf("%d%d%d%d",&n,&m,&st.x,&st.y);//读入
	bfs();//执行bfs函数
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
            //双重循环输出
			printf("%-5d",mp[i][j]);//注意输出的格式
		}
		printf("\n");//记得换行
	}
	return 0;
}
```

## 各位看官，你们觉得怎么样？

---

## 作者：sinsop90 (赞：8)

 ~~这是本蒟蒻的第一篇题解,若写得不好请大家原谅~~

还有,我还是六年级www,年级算小的oler了

 接下来我们来谈谈正经的话题,这是一道特别简单的BFS题,我们只需要注意一下以下几点即可（听说有人在这题上犯了3个低级错误(~~就是我~~）
1.马的方向总共有8个:分别是 {{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}}

2.如果马到不了那一个位置就输出"-1"

3.输出左对齐,宽五格。

# ~~没了~~，就是那么简单

我个人用的是STL里的队列,不想用手动模拟了,太麻烦了(极其懒)

首先,我们要开一个结构体来存放每一个位置的坐标,所以就有了下面这个代码(狂汗ing)

```
struct node{
	int x,y,steps;//steps就是走在那个点需要的最少步数
};
```
(其他定义(队列,bool vis[1005][1005]）就不用讲了吧

```
struct node{
	int x,y,steps;
};
queue <node> Q;//队列 
bool vis[1005][1005]={false};//vis就是代表那一个位置有没有走过,开始全赋为false,true就代表走过了
int n,m; 
int x1,y1;
int ans[1005][1005];//其实就是map,存步数
int fx[8][2] = {{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};//马的8个方向 
```
接着，我们就来看看最核心的bfs思想
## code:
```
void bfs(){
	node tmp;
	tmp.x = x1;
	tmp.y = y1;
	tmp.steps = 0;
	vis[x1][y1] = true;//将起点值先赋进去 
	Q.push(tmp);
	while(!Q.empty()){
		node t=Q.front();
		for(int i=0;i<=7;i++){
			int xx = t.x+fx[i][0];//马下一步的坐标 
			int yy = t.y+fx[i][1];
			if(xx>=1&&xx<=n && yy>=1&&yy<=m && !vis[xx][yy]){//判断是不是在地图内,看看有没有走过 
				tmp.x = xx;
				tmp.y = yy;
				tmp.steps = t.steps+1
				Q.push(tmp);
				vis[xx][yy] = true;
			}
		}
		ans[t.x][t.y] = t.steps;//记录 
		Q.pop();
	}
}
```
具体看注释吧

另外还需要注意的是输出:输出左对齐,宽五格。
```
for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%-5d",ans[i][j]); //输出左对齐,宽五格。 
		}
		cout<<endl;
	}
```
所以说整个AC代码如下:
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
struct node{
	int x,y,steps;
};
queue <node> Q;//队列 
bool vis[1005][1005]={false};
int n,m; 
int x1,y1;
int ans[1005][1005];
int fx[8][2] = {{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2},{-1,-2}};//马的8个方向 
void bfs(){
	node tmp;
	tmp.x = x1;
	tmp.y = y1;
	tmp.steps = 0;
	vis[x1][y1] = true;//将起点值先赋进去 
	Q.push(tmp);
	while(!Q.empty()){
		node t=Q.front();
		for(int i=0;i<=7;i++){
			int xx = t.x+fx[i][0];//马下一步的坐标 
			int yy = t.y+fx[i][1];
			if(xx>=1&&xx<=n && yy>=1&&yy<=m && !vis[xx][yy]){//判断是不是在地图内,看看有没有走过 
				tmp.x = xx;
				tmp.y = yy;
				tmp.steps = t.steps+1
				Q.push(tmp);
				vis[xx][yy] = true;
			}
		}
		ans[t.x][t.y] = t.steps;//记录 
		Q.pop();
	}
}
int main(){
	cin>>n>>m>>x1>>y1;
	memset(ans,-1,sizeof(ans));
	bfs();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%-5d",ans[i][j]); //输出左对齐,宽五格。 
		}
		cout<<endl;
	}
	return 0;
}
```
谢谢大家的理解,如果有问题可以直接提出!

---

## 作者：Goodenough (赞：7)

[P1443~~妈的~~马的便历](https://www.luogu.org/problem/P1443)

（来自一个蒟蒻的小学生）
### STL大法好！
## BFS大法好！

------------
bfs，STL库中的queue特别好用~~其实是不会用数组模拟~~\
跑得也挺快，平均4ms~~最慢10ms~~\
上代码啦
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct node{
	int x,y,step;
}t1,t2;//数据类型存每个点的横、纵坐标和最早到达的步数
int n,m,qx,qy,map[405][405];//最后的答案
int dx[8]={-1,-2,-2,-1,1,2,2,1},dy[8]={-2,-1,1,2,-2,-1,1,2};//8个方向
bool vis[405][405];//是否到达过
queue<node> que;//队列
int main(){
	scanf("%d%d%d%d",&n,&m,&qx,&qy);
	memset(map,-1,sizeof(map));
	t1.x=qx,t1.y=qy,t1.step=0;//将起始点设置
	vis[qx][qy]=1;//起始点标记已走过
	que.push(t1);//起始点入队
	while(!que.empty()){
		t1=que.front();que.pop();//队列取头
		map[t1.x][t1.y]=t1.step;//将到达此点的最少步数存入答案
		for(int i=0;i<8;i++){//8个方向走一遍
			t2.x=t1.x+dx[i],t2.y=t1.y+dy[i],t2.step=t1.step+1;
			if(t2.x<1||t2.x>n||t2.y<1||t2.y>m) continue;//防止越界
			if(!vis[t2.x][t2.y]){
				vis[t2.x][t2.y]=1;//标记
				que.push(t2);//入队
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			printf("%-5d",map[i][j]);//5格左对齐格式
		puts("");//换行
	}
	return 0;
}
```
第一次写题解，写得不好请见谅O(∩_∩)O

---

## 作者：Error_Eric (赞：6)

一道正常的广搜……

运用了结构体模拟队列，打包数据，非常适合~~抄袭~~像我这样的蒟蒻学习bfs用。~~（但是为啥他们都用深搜呢？这难道不是宽度优先搜索专题的吗）~~虽然说深搜加上了剪枝也可以过，但是广搜在一些数据较大的题目中还是很实用的。

上代码：

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>

using namespace std;

const int dirx[9]={0, 1,-1, 2,-2, 1,-1, 2,-2};//马守八方的8种x坐标的变化
const int diry[9]={0, 2, 2, 1,-1,-2,-2,-1, 1};//相应的8种y坐标的变化
const int MaxN=400;const int MaxM=400;const int tat=999999999;//数据范围&模拟最大值
int vis[MaxN][MaxM],map[MaxN][MaxM];
//   来过没有     最小需几步
int Fx,Fy,n,m;//从哪里开始，几行，几列

struct node{
	int x;int y;int step;//我在哪，走了几步
}que[MaxN*MaxM+50];//最多的扩展只有160000，加上50是好习惯

bool judge(int xx,int yy){//越界判断&已经遍历判断
	if(xx>0&&xx<=n&&yy>0&&yy<=m&&vis[xx][yy]==0) return 1;
												 return 0;
}

void start(){//初始化
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			map[i][j]=tat;
		}
	}
}

void ending(){//输出
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i==Fx&&j==Fy)		printf("0    ");//初始点特判
			else if(map[i][j]==tat)	printf("-1   ");
			else 	printf("%-5d",map[i][j]);	
		}
		printf("\n");
	}
	return ;
}

void bfs(int x,int y){
	int head=0,tail=0;
	node now,next;
	now.x=x;now.y=y;now.step=0;//初始化
	que[tail++]=now;
	while(head<tail){
		now=que[head++];//出队 
		for(int i=1;i<=8;i++){//马守八方 
			next=now;		//copy 
			next.x+=dirx[i];	//x 
			next.y+=diry[i];	//y
			if(judge(next.x,next.y)){//在棋盘内&没被走过 
				vis[next.x][next.y]=1;//标记 
				map[next.x][next.y]=(++next.step);//步数++ 
				que[tail++]=next;//入队 
			}
		}
	}
}
int main(){
	cin>>n>>m>>Fx>>Fy; //scanf("%d %d %d %d",&n,&m,&Fx,&Fy);
	start();
	bfs(Fx,Fy);
	ending();
	return 0;
} 

//#Error_Eric
```
That's all……

---

## 作者：梦里调音 (赞：6)

哇，非常满意的一波广搜

这题很经典的bfs啊。

	首先，我们要明确“马走日，象走田”（顺口说出来了awa）

	所以，马的走法有八种
    
    其次，根据bfs的性质：走完就可以封路了
    
    最后，声明：本人习惯以平面直角坐标系的第四象限为基础建立图
    
    所以~~~也许坐标比较奇葩（我习惯就好qwq）
    
代码里也有注释，你们加油

```cpp
#include <bits/stdc++.h>
using namespace std;
int s[401][401];
bool a[401][401];
int head,end;
int sx[10000001],sy[10000001],sc[10000001];//纵坐标，横坐标，层数 
int dy[]={0,-2,-2,-1,1,2, 2, 1,-1};//八个方向的变化坐标
int dx[]={0,-1, 1, 2,2,1,-1,-2,-2};
int main(){
	int i,j,k,m,n,y,x;
	cin>>n>>m>>y>>x;
	head=1;
	end=2;
	sx[1]=x;//由起点开始拓展
	sy[1]=y;
	for(head=1;head<end;head++)//注意是小于，不能等于，用while也可以
		for(i=1;i<=8;i++){
			int xx=sx[head]+dx[i];//下一步 
			int yy=sy[head]+dy[i];
			if(xx<1||xx>m||yy<1||yy>n||a[yy][xx]==1)continue;//不能走或走过
			a[yy][xx]=1;//走过就封路 
			sx[end]=xx;//下一步可走，确认 
			sy[end]=yy;
			sc[end]=sc[head]+1;//层数++ 
			end++;
		}
	for(i=1;i<=end;i++)s[sy[i]][sx[i]]=sc[i];//存数
	s[y][x]=0;
	for(i=1;i<=n;i++){//输出
		for(j=1;j<=m;j++)
			if(i==y&&j==x)printf("%-5d",s[i][j]);
			else if(s[i][j]==0)printf("%-5d",-1);
				else printf("%-5d",s[i][j]);
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：median_dxz (赞：6)

这里给大家小小的普及一下广搜。（建议先掌握深搜）个人觉得luogu里这题可以用来入门。


##深搜与广搜的搜索模式

首先，我们就这道题而言，深搜的话，应该是这样：

尝试8个方向的一个->尝试新坐标8个方向的一个->…………->返回尝试下一个方向……

也就是说，作为一棵树，我们先尝试一个分支，没分支了再返回寻找下一个分支继续。于是可以用来穷举所以情况。

这里吐槽一句，我第一次不知不觉写成深搜了。。。ovo。


但是广搜我们知道它可以用来找到最小路径。。我们看一下它的搜索过程：

尝试8个方向的一个->尝试8个方向的另一个……尝试完所有八个方向，从新的八个坐标开始……搜索到结果，结束。

也就是说，作为一棵树，我们先尝试完所有第一层，第二层，知道找到答案为止，这样可以找到最短路径，为什么呢，假设这个马走到X,Y要跳3步，我们先尝试了所有走零步，一步，两步的情况，所以在第三步的情况搜索到的就是最优答案。


##广搜的代码模式

我讲的不是很清楚，上面建议先看过其他广搜材料的再看看。

现在讲一下广搜的代码模式

首先说明，尽管广搜概念上看起来很像需要递归，但实际上这样应该是写不出来的，或者写着写着就写成深搜了。。

因为实际上**广搜是靠队列进行的**个人概念弄懂后代码还是一脸懵比，所以来讲一下这个代码模式，希望对大家有帮助。


首先，我们需要一个队列，其实就是一个数组。还需要两个变量，就b,t吧，代表队列头和队列尾。

我们把马看做一个点，有八个方向可以走，我们就扩展八个节点，同时用一个while循环来控制搜索，条件b<=t,意思是队列不是空的时候进行。

什么叫队列不为空呢？其实在搜索过程中，我们会不断扩展队列尾，但是队列头用过之后我们就会+1，这样当所有节点扩展完后，队列搜完就是全部搜完了。其实就是把要搜索的节点全找出来，同时一个一个搜过去。

之后扩展节点并且加入队列，就完成了。


##注意

1.队列要开大一点

2.需要有一个结构，分别是x，y和步数

3.由于广搜不需要回溯，故要有一个数组标记已走过的点


##代码

```pascal
type
  dl=record
    x,y,bs:longint;//x,y,step
  end;

var sc,bz:array[1..1000,1..1000]of longint;//输出，标志
  cd:array[1..50000]of dl;//队列
  fx:array[1..8,1..2]of longint=((2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2));//八个方位
  n,m,i,j,qx,qy:longint;//棋盘长，宽，计数ij，起点坐标
  te:ansistring;

procedure search(x,y:longint);
var hx,hy:longint;//变化后x,y
  b,e,k:longint;//begin,end,计数
begin
  b:=1;e:=1;
  cd[1].bs:=0;
  cd[1].x:=x;
  cd[1].y:=y;
  while(b<=e)do begin
    for k:=1 to 8 do begin
      hx:=cd[b].x+fx[k][1];
      hy:=cd[b].y+fx[k][2];
      if(hx>=1)and(hx<=n)and(hy>=1)and(hy<=m)and(bz[hx,hy]=0)then begin
        inc(e);
        bz[hx,hy]:=1;
        cd[e].x:=hx;
        cd[e].y:=hy;
        cd[e].bs:=cd[b].bs+1;
        sc[hx,hy]:=cd[e].bs;
      end;
    end;
    inc(b);
  end;
  exit;
end;

begin
  readln(n,m,qx,qy);
  fillchar(bz,sizeof(bz),0);
  search(qx,qy);

  for i:=1 to n do begin
  for j:=1 to m do begin
    if(sc[i,j]=0)then
    sc[i,j]:=-1;
  end;

  sc[qx,qy]:=0;

  end;
  for i:=1 to n do begin
  for j:=1 to m do begin
     str(sc[i,j],te);                         //感谢 @hz1624917200 的输出优化方案
     write(te,'':5-length(te));
   end;
      writeln;
   end;
  readln;readln;
end.

```

---

## 作者：inexistent (赞：6)

很明显是一道bfs，但是打法好像和别的题解不太相同。我个人比较习惯这种打法。

输入地图大小以及起点位置。

本来的搜索题都需要开一个判是否走到过的数组，但这到题既然要求最后输出整一张图，所以

也就可以将这两个合二为一了。也就是说，只要最后的数组中记录的值大于0，则这个点已经走过了。

之前一直卡在第二个点上，其他都AC了。后来检测了才发现h已经超过t了。把while的判断写成

h<t 而不要写 h<=t， 因为h在下一轮还会再++。

具体不再赘述，批注在代码中的注释中。

```cpp
#include <cstdio>
#include <cstring>      //memset所需 

struct Horse{
    int x,y,f;          //x,y是坐标，f是目前的步数 
}q[200000];             //结构体，广搜的队列。 

int h,t;                 //队列的头尾指针 
int n,m,X,Y;
int ans[500][500];

inline void push(int x, int y)
{
    if(x>n || x<1 || y>m || y<1) return;     //判断是否出界 
    if(ans[x][y]!=-1) return;                //并没有访问过这个点 
    
    //将当前位置推入队列 
    t++;     
    q[t].x = x;
    q[t].y = y;
    q[t].f = q[h].f + 1;     
    ans[x][y] = q[h].f;           //由于第一个点不需要跳，所以去头指针的步数。（也可以是尾指针的步数-1） 
}

int main()
{
    scanf("%d%d%d%d", &n, &m, &X, &Y);
    memset(ans, -1, sizeof(ans));     //刚开始全都未访问，用memset将整个数组清成-1 
    push(X,Y);                        //这一步非常容易忘，首先将起点推入队列 
    while(h<t) {                      //是 <  而不是 <= ， 因为在本轮中还需要 h++ 
        h++;                          //头指针向右移动 
        push(q[h].x + 1, q[h].y - 2);
        push(q[h].x + 2, q[h].y - 1);
        push(q[h].x + 2, q[h].y + 1);
        push(q[h].x + 1, q[h].y + 2);
        push(q[h].x - 1, q[h].y - 2);
        push(q[h].x - 2, q[h].y - 1);
        push(q[h].x - 2, q[h].y + 1);
        push(q[h].x - 1, q[h].y + 2);
        //八个方向都可以跳。 
    }
    
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) printf("%-5d", ans[i][j]); //printf支持左对齐输出 
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：zhaowangji (赞：5)

自从学了宽搜到现在，从未用过STL写要带有多个参数的题
（有次跟同学说，结果他回我不还是你不会嘛。。。）

说实话用STL写还真是挺麻烦的

队列的类型是结构体（push的时候也要push结构体）
记录横纵坐标和步数

然后最好用增量数组免得一大堆if


```cpp
#include<iostream>
#include<queue>
#include<iomanip>
#include<string.h>
using namespace std;
int m,n;
int a[407][407];
bool vis[407][407];
int dx[8]={-2,-1,1,2,2,1,-1,-2};//记得是马，一开始写成普通的了
int dy[8]={1,2,2,1,-1,-2,-2,-1};
struct node{
	int x;
	int y;
	int s;
};
queue<node> q;
node ma;
void bfs()
{
	q.push(ma);//初始入队
	while(!q.empty())//队不空
	{
		node nm=q.front();//取出队首
		for(int i=0;i<8;i++)
		{	//增量数组枚举每个可能的点
			int nx=nm.x+dx[i];
			int ny=nm.y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis[nx][ny])//判断在棋盘内以及没有走过
			{
				vis[nx][ny]=true;//标记为走过
				a[nx][ny]=nm.s+1;//步数是上一步的步数加一
				node qm;
				qm.x=nx;
				qm.y=ny;
				qm.s=nm.s+1;
				q.push(qm);//把当前点入队
			}
		}
		q.pop();
	}
}
int main()
{
	cin>>n>>m;//读入别读反了
	cin>>ma.x>>ma.y;//一开始马的坐标
	ma.s=0;//步数此时为0
	memset(a,-1,sizeof(a));//假设全部无法到达
	a[ma.x][ma.y]=ma.s;//起始点
	vis[ma.x][ma.y]=true;//标记走过了
	bfs();//宽搜
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		cout<<left<<setw(5)<<a[i][j];
		cout<<endl;//记得前面有left（我也不知道为什么必须要有）
	}
	return 0;
}
```

我找了半小时的错，看了五六份题解，没想到是场宽控制有问题！！！

---

## 作者：innocent__ (赞：5)

呃~~~   
作为一个毛都没长齐的蒟蒻，让我题解好难
写A+B也不好意思，便拿这一题开刀了
 _ _ _ __ _ _ _ 
###### 两条华丽的分割线~~~~~
------------


看了看宽搜较多，就写深搜了~~(宽搜不会)~~
# 言归正转
用宽搜写， 时间会超.400*400的图，一个个搜过去，天塌了也搜不完!!!
### 所以要剪枝,剪枝,剪枝!! 
(重要的事说三遍)

下面是代码,不要抄,~~我换成字符了~~
```c++
#include<bits/stdc++.h>//万能头大法
using namespace std;
int dx[8]={-2,-1,1,2,2,1,-1,-2},dy[8]={-1,-2,-2,-1,1,2,2,1};//八个儿子
int ans[550][550];
int m,n,sx,sy;
void dfs(int x,int y,int sum)
{
	if(sum>500)return;//掐指算了算,就算马从（0,0）跳到（400,400）也绝不会大于它（不懂的自己去实践一下）(算是个剪枝吧)
    ans[x][y]=sum;
    for(int i=0;i<8;i++)
    {
        int yy=y+dy[i],xx=x+dx[i];
        if(x<1||x>n||y<1||y>m)continue; 
        if(sum+1<ans[xx][yy]||ans[xx][yy]==-1)
            dfs(xx,yy,sum+1);
    }//找八个儿子
}
int main()
{
    cin>>n>>m>>sx>>sy;
    memset(ans,-1,sizeof(ans));//初始化
    dfs(sx,sy,0);
    for (int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(i==sx&&j==sy)cout<<0<<"    "; //当它本身就是起点时,输出0
            else if(ans[i][j]==0)printf("%-5d",-1);
            else printf("%-5d",ans[i][j]);
        }
        cout<<endl;
    }//完美的输出
    return 0;
}
  
```
呃,写完了,~~提一下,我没换成字符~~，管理员大大，求过求过


---

## 作者：CCCPKeay (赞：4)

BFS解法挺简单的.

此题就是一个BFS搜索,下面讲思路.

## 思路:

因为规定棋盘大小,我们就在这个n*m的棋盘上遍历并将棋盘上每个坐标赋上最小值,
我们先声明一个Map数组memset将Map初始化为-1,方便我们以后的遍历,因为BFS每次更新可行的状况数那当我们每次遍历到棋盘上的一个坐标就将Map赋为这个坐标的状况数,Map[xx][yy]=next.t.(xx,yy为遍历坐标)(next.t为更新状况数).

## 代码:

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
const int N=400+40;
int Map[N][N];
int n,m,startx,starty;
int dirx[8]={1,2,2,1,-1,-2,-2,-1};//马的移动方式 
int diry[8]={-2,-1,1,2,-2,-1,1,2};
struct Node 
{
	int x,y,t;
};
void bfs()
{
	Map[startx][starty]=0;//起点当然是0步 
	queue<struct Node> que;
	struct Node now;
	now.x=startx;now.y=starty;now.t=0;//startx,starty起点坐标,now.t计数 
	que.push(now);
	while(!que.empty())
	{
		now=que.front();
		que.pop();
		for(int i=0;i<8;i++)//八个方向 
		{
			int xx=dirx[i]+now.x;
			int yy=diry[i]+now.y;
			if(xx<1||xx>n||yy<1||yy>m) continue;//边界 
			if(Map[xx][yy]!=-1) continue;//-1为没有到达过,如果不是-1那就到达过就continue; 
			struct Node next;
			next.x=xx;next.y=yy;next.t=now.t+1;
			Map[xx][yy]=next.t;//xx,yy为我们此次遍历到棋盘的xx,yy坐标,next.t为我们遍历到此点的步数. 
			que.push(next);
		} 
	}
	return;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&startx,&starty);//n,m棋盘,startx,starty起始点 
	memset(Map,-1,sizeof(Map));//将Map初始化为-1方便以后判断 
	bfs();
	for(int i=1;i<=n;i++)//输出 
	{
		for(int j=1;j<=m;j++)
		{
			printf("%-5d",Map[i][j]);
		}
		printf("\n");
	} 
	return 0;
}
```


---

## 作者：Yoshinow2001 (赞：4)

\_(:\_」∠)\_萌新第一次写题解xx（反正没什么人看x）（难得好好写一次题于是就想写个题解2333333

呐 反正分组都写是bfs了 那就bfs好啦…

嘛就是从他给你的起点开始广搜，这样子路径就一定是最短的

然后就是这题要注意下输出格式x

说是左对齐就左对齐（这个不知道可以去查下（Orz话说我刚知道还有这种操作xxx

那么下面是代码x


```cpp
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=405;
queue<int>wx,wy;
int n,m,x,y,x1,y1,x2,y2,w[maxn][maxn],f[8][2]={{1,2},{-1,2},{2,1},{-2,1},
                                     {1,-2},{-1,-2},{2,-1},{-2,-1}};
int main(){
    scanf("%d%d%d%d",&n,&m,&x,&y);
    w[x][y]=1;wx.push(x);wy.push(y);
    while(!wx.empty()){
        x1=wx.front();y1=wy.front();wx.pop();wy.pop();
        for(int i=0;i<8;i++){
            x2=x1+f[i][0];y2=y1+f[i][1];
            if(x2<1||x2>n||y2<1||y2>m||w[x2][y2])continue;
            w[x2][y2]=w[x1][y1]+1;wx.push(x2);wy.push(y2);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)printf("%5-d",w[i][j]-1);
```
/\*因为w[][]其实多算了一但是又不想初始化于是就这样子好了x\*/
```cpp
        printf("\n");
    }
    return 0;
}
/*撒花x*/
```

---

## 作者：「QQ红包」 (赞：4)

这道题其实是到大水题。裸的广搜。

```cpp

#include <cstdio>//原谅我懒 
#include <iostream>
struct que  
{  
    int x;  
    int y;  
    int s;  
}qu[400100];  
using namespace std;
int main()
{
    int xx,yy,n,m,i,j,h,r,xxx,yyy,x1,y1,x,y;//习惯一开头就把所有变量定好 
    int a[251][251];
    int next[8][2]={{2,1},{2,-1},{-2,-1},{-2,1},{1,2},{1,-2},{-1,2},{-1,-2}}; 
    cin >>n>>m>>xx>>yy;//输入，cin很慢但是这道题没关系。 
    h=0; //队首赋值为0 
    r=1;//队尾赋值为1 
    qu[1].x=xx;
    qu[1].y=yy;//入队 
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        a[i][j]=-1; 
    }//初始化 
    a[xx][yy]=0; 
    while (h<r)
    {
        h++;//对首+1 
        for(i=0;i<=7;i++)
        {
               xxx=qu[h].x+next[i][0];
               yyy=qu[h].y+next[i][1];
               if ((xxx>0)&&(yyy>0)&&(xxx<=n)&&(yyy<=m)&&(a[xxx][yyy]==-1))//满足条件 
               {
                a[xxx][yyy]=a[qu[h].x][qu[h].y]+1;
                r++;
                qu[r].x=xxx;
                qu[r].y=yyy;
            }
        }
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        printf("%-5d",a[i][j]);  
        printf("\n"); 
    }
    return 0;
}

```

---

## 作者：vectorwyx (赞：3)

### **BFS大法好！**
### **STL大法好！**
### **printf大法好！**



------------
通过填涂颜色，我们了解了BFS的最基础用法：遍历

而这道题紧承填涂颜色，又使我们了解了BFS的另一个用法：

**求步数**

这也是十分重要的用法，建议大家在AC后多多温习。


------------
要想弄清楚一个算法的用途，首先要明确其原理。

我们知道BFS是**逐层推进**的，每一层都包含上一层的点所能到达的位置。

特别地，第一层的点只有一个，即起点。


------------


诶？好像有什么发现！

要想到达第$n$层的点，必须先到达第$n-1$层的点。

而从第$n-1$层“跳”到第$n$层的操作不就是一次移动吗？

这样一直推下去，我们可以得到一个很重要的结论：

**从第1层到达第$n$层需要移动$n-1$次**。

也就是**从起点到达任意一个点，移动的次数为$k-1$次**。

其中$k$为该点所在的层数。

而**移动的次数就是**我们**所求的步数**啊！


------------
因此，用BFS求步数的思路就确定好了，即：

先开一个二维数组，全部**初始化为-1**，用来记录步数。

然后，从起点开始进行BFS。

对于所搜索到的每一个点，找到它在二维数组中对应的元素。

把元素的值修改为**层数-1**。

最后按行输出二维数组即可

------------
怎样记录层数呢？

由于BFS是按照每一层的点来进行下一步的搜索的，

那我们每搜到一个点，它**所需的步数就是上一个点所需步数+1**

因此我们只需要**把起点标记为0**就可以用**类似递推的方法**实现了

------------

这里再介绍一下两个好用的函数：
* 1.$memset$ 这个函数相信大家都不陌生。在这道题中我们将用它把ans数组的元素全部赋-1值，这样就不需要再使用标记数组，直接在ans数组里操作即可


------------

* 2.$printf$ printf是C语言的输出，而它在C++中依然具有不容小觑的作用。printf有两个好处：

		一是速度比cout快，尤其是当数据量超过1e5时将会cout几条街 
	    二是操作非常简单。
		    比如保留小数点后n位，cout不仅得引用头文件   
            iomanip（习惯用万能头的选手当我没说），还
            要写一串控制符。而printf就没那么多麻烦：直
            接在控制符中加一个.n就行了。很方便有木有？
		    场宽和左对齐也是特别直接：printf("%-5d",a[i][j]);
            对比一下那又长又繁琐有慢吞吞的cout，是不是好处多多？

## （printf大法好！）


------------

OK，了解完这些，把BFS的STL板子贴上再改一改就行了

## （STL大法好！）
------------

**代码来了~**：
```
#include<iostream> 
#include<cstdio>//欲用printf，先引stdio库
#include<queue>//STL大法好！
using namespace std;
int dx[]={ 1, 1,-1,-1, 2, 2,-2,-2};//马所能到达的位置
int dy[]={-2, 2,-2, 2,-1, 1,-1, 1};
int a[405][405];//ans数组，存储步数
int main(){
	queue<int> x;//x存储点所在的行
	queue<int> y;//y存储点所在的列
	int n,m,x1,y1,xx,yy;
	cin>>n>>m>>x1>>y1;
	memset(a,-1,sizeof(a));//全部赋值-1
	x.push(x1);//压入起始点的横坐标
	y.push(y1);//压入起始点的纵坐标
	a[x1][y1]=0;//特殊处理
	while(!x.empty()){
		xx=x.front();//当前马所在的位置
		yy=y.front();
		for(int i=0;i<8;++i){
			int tx=xx+dx[i];//马能跳到的位置
			int ty=yy+dy[i];
			if(tx>0&&tx<=n&&ty>0&&ty<=m&&a[tx][ty]==-1){//判断是否越界、是否跳到过
				x.push(tx);//压入新点
				y.push(ty);
				a[tx][ty]=a[xx][yy]+1;//更改跳到的点
			}
		}
		x.pop();//弹出
		y.pop();
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			printf("%-5d",a[i][j]);//printf大法好！
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：山海无风 (赞：3)

### ~~事实上是因为不会bfs~~
说一下思路，走一遍棋盘上每个位置，可以走的就记录步数，不可以走就保留原来状态（就是把棋盘初始化为-1）

**上代码**
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define end sb
using namespace std;
int n,m,a,b;
int vis[401][401]={-1};
int dx[]={-1,1,2,2,-1,1,-2,-2};
int dy[]={-2,2,-1,1,2,-2,-1,1};//八个方向 
void bfs(int x,int y,int deep)
{
	vis[x][y]=deep;
	for(int i=0;i<8;i++)
	{
		if(x<1||x>n||y<1||y>m) continue; 
		if(vis[x+dx[i]][y+dy[i]]>deep+1||vis[x+dx[i]][y+dy[i]]==-1) bfs(x+dx[i],y+dy[i],deep+1);
		//如果当前答案步数比本次搜索步数大，说明上次dfs得到的答案不是最优解，就再次搜索 
	}
}
int main()
{
	memset(vis,-1,sizeof(vis));//初始化为-1，节省一次判断 
	cin>>n>>m;
	cin>>a>>b;
	bfs(a,b,0);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
	    {
            printf("%-5d",vis[i][j]);//对齐输出 
            if(j==m) cout<<endl;
		}
}
```
## But
**T了一个点，所以需要加一个减枝**
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define end sb
using namespace std;
int n,m,a,b;
int vis[401][401]={-1};
int dx[]={-1,1,2,2,-1,1,-2,-2};
int dy[]={-2,2,-1,1,2,-2,-1,1};//八个方向 
void bfs(int x,int y,int deep)
{
	vis[x][y]=deep;
	for(int i=0;i<8;i++)
	{
		if(deep>532) return;//减枝 
		if(x<1||x>n||y<1||y>m) continue; 
		if(vis[x+dx[i]][y+dy[i]]>deep+1||vis[x+dx[i]][y+dy[i]]==-1) bfs(x+dx[i],y+dy[i],deep+1);
		//如果当前答案步数比本次搜索步数大，说明上次dfs得到的答案不是最优解，就再次搜索 
	}
}
int main()
{
	memset(vis,-1,sizeof(vis));//初始化为-1，节省一次判断 
	cin>>n>>m;
	cin>>a>>b;
	bfs(a,b,0);
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
	    {
            printf("%-5d",vis[i][j]);//对齐输出 
            if(j==m) cout<<endl;
		}
}
```
**其他一样，就加了个“if(deep>532) return;”的语句，解释一下，数据最大是400*400的矩阵，按最差的情况考虑，从左上角走到右下角，就是400/3*4步，大概就是532步**

~~数学差不知道想得对不对~~

#### 最后建议一下数据大的时候还是乖乖写bfs，dfs太容易爆了



---

## 作者：Anita_Hailey (赞：3)

# P1443 马的遍历


作为广搜习题，用队列轻松水过

直接上代码
```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=440;
int n,m,op,cl;
struct Node{
	int x,y,sum;
}queue[N*N];//通过队列实现广搜
int chess[N][N];//这是最后的答案
int dx[9]={0,1,2,2,1,-1,-2,-2,-1};//选择马跳的方向，自己画一下，十分简单
int dy[9]={0,2,1,-1,-2,-2,-1,1,2};
void bfs(){//个人觉得还是在另加一个函数显得更好看Q_Q
	while(op<cl){
		op++;
		for(int i=1;i<=8;i++){
			int x=queue[op].x;//定义变量时注意位置，我在这错了一次
			int y=queue[op].y;
			x=x+dx[i];
			y=y+dy[i];
			if(x>0&&y>0&&x<=n&&y<=m&&(chess[x][y]==-1)){//判断是否越界及是否被跳过
				cl++;
				queue[cl].x=x;
				queue[cl].y=y;
				queue[cl].sum=queue[op].sum+1;
				chess[x][y]=queue[cl].sum;
			}
		}
	}
}
int main(){
	cin>>n>>m;
	int x,y;
	cin>>x>>y;
	memset(chess,-1,sizeof(chess));
	op=0,cl=1;//进行广搜前的初始化
	chess[x][y]=0;//要在马的位置上步数赋为零，不然会回马枪
	queue[cl].x=x;//马所在位置入队
	queue[cl].y=y;
	queue[cl].sum=0;
	bfs();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%-5d",chess[i][j]);//血与泪的教训没仔细看题....
		}
		cout<<endl;
	}
}
```


---

## 作者：Owen_codeisking (赞：3)

哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈12ms基本上没人比我更厉害了（我查了一下有一个7ms的）

这道题是经典搜索题，用step记录马的八个方向，所谓暴力出奇迹qwq

废话少说，看代码。



```cpp
#include <iostream>
#include <cstring>
#include <queue>//STL
using namespace std;
int used[410][410],a[410][410];//used记录有没有被走过，a记录步数
int n,m,p,r,step[8][2]={{-1,-2},{-2,-1},{-2,1},{-1,2},{1,2},{2,1},{2,-1},{1,-2}};//n,m如输入，step是马的八个方向
void Bfs()
{
    int x,y,u,v;
    queue<int> q;//队列
    used[p][r]=1;
    a[p][r]=0;//初始化
    q.push(p),q.push(r);//进入队列
    while(!q.empty())//经典STL BFS模板
    {
        x=q.front(),q.pop();
        y=q.front(),q.pop();//读取数据
        //cout<<x<<" "<<y<<endl;
        for(int k=0;k<8;k++)
        {
            u=x+step[k][0];
            v=y+step[k][1];//枚举八个方向
            //cout<<u<<" "<<v<<endl;
            if(u<1||u>n||v<1||v>m)//如果不符合就continue
                continue;
            if(used[u][v]==0)//如果走过了就不操作
            {
                used[u][v]=1;//已经走过
                a[u][v]=a[x][y]+1;//加步数
                //cout<<u<<" "<<v<<endl;
                q.push(u),q.push(v);//进入队列
            }
        }
    }
}
int main()
{
    memset(used,0,sizeof(used));
    memset(a,-1,sizeof(a));//初始化数据
    cin>>n>>m>>p>>r;//输入
    Bfs();//广搜
    for(int i=1;i<=n;i++)//令人蛋疼的输出
    {
        for(int j=1;j<m;j++)//数字+空格共5个字节，-1时有3个空格，2有4个空格，100有2个空格等
        {
            if(a[i][j]>=10000) cout<<a[i][j];
            else if(a[i][j]<10000&&a[i][j]>=1000) cout<<a[i][j]<<" ";
            else if(a[i][j]<1000&&a[i][j]>=100) cout<<a[i][j]<<"  ";
            else if(a[i][j]==-1||(a[i][j]>=10&&a[i][j]<100)) cout<<a[i][j]<<"   ";
            else cout<<a[i][j]<<"    ";//坑爹的else if
        }
        cout<<a[i][m]<<endl;//不输出空格
    }
    return 0;//拜拜程序
}
```

---

## 作者：Night_Aurora (赞：3)

很简单的广搜——一开始把map全设成-1，然后第一个点=0，

以后走日字找每个值为-1的点并设成步数+1，这样就会自动跳出BFS了









```cpp
#include <stdio.h>
int Map[400][400];
int N,M;
int Sx,Sy;
int List[160000];
int Lh,Ld;
#define Stuck(h,l,s)    {List[Ld]=(h)*1000+l+(s)*1000000;++Ld;}   
#define Pop(h,l,s)        {l=List[Lh]%1000;h=(List[Lh]/1000)%1000;s=List[Lh]/1000000;++Lh;}
#define Null()        (Lh>=Ld)                    //这三个是压缩存储并模拟队列的宏，因为宏速度比函数快得多
#define IsVPt(h,l)        (h>=0&&l>=0&&h<N&&l<M)  //判断点是否合法
void AroundPt(int x,int y,int nm,int &tx,int &ty)  //轮流输出8个日字可以走到的点
{
    switch(nm)
    {
    case 0:tx=x-1;ty=y-2;return;
    case 1:tx=x+1;ty=y-2;return;
    case 2:tx=x-1;ty=y+2;return;
    case 3:tx=x+1;ty=y+2;return;
    case 4:tx=x-2;ty=y-1;return;
    case 5:tx=x+2;ty=y-1;return;
    case 6:tx=x-2;ty=y+1;return;
    case 7:tx=x+2;ty=y+1;return;
    }
    return;
}
void BFS(int nx,int ny)
{
    --nx,--ny;
    int wix,wiy,wiz;
    for(wix=0;wix<N;++wix)
        for(wiy=0;wiy<M;++wiy)
            Map[wix][wiy]=-1;    // 开始设成-1
    int ns=0;
    Map[nx][ny]=0;   //第一个点插入（这里BFS顺序是这样的——先设map数值然后再插入到队列）
    Stuck(nx,ny,0);   //插入到队列，前面步数是0也保存
    while(!Null())  //直到队列空了为止
    {
        Pop(nx,ny,ns);  //取出一个
        for(wiz=0;wiz<8;++wiz)
        {
            AroundPt(nx,ny,wiz,wix,wiy); 
            if(IsVPt(wix,wiy)&&Map[wix][wiy]==-1)  //如果这个点没访问过(=-1)且合法(不会超出棋盘)
            {Map[wix][wiy]=ns+1;Stuck(wix,wiy,ns+1);}  //设好map在插入队列
        }
    }
}
void Input()
{
    scanf("%d %d %d %d",&N,&M,&Sx,&Sy);
}
int main()
{
    Input();
    BFS(Sx,Sy);
    int wia,wib;
    for(wia=0;wia<N;++wia)
    {
        for(wib=0;wib<M;++wib)
            printf("%-5d",Map[wia][wib]);
        putchar('\n');
    }
    return 0;
}

```

---

## 作者：hz1624917200 (赞：3)

可以不用visited数组来存是否访问过的

只要在初始化的时候吧map数组设成-1，在拓展的时候检查是不是-1就行了。

还有，pascal输出还是很强大啊，下面代码两句代替四个判断，还是大爱 pascal ……

下附代码：

[codep]


```cpp
program p1443;
type
  point=record
    x,y:longint;
  end;
const
  dir:array[1..8,1..2] of longint=((1,2),(1,-2),(-1,2),      //马走日的方向
    (-1,-2),(2,1),(2,-1),(-2,1),(-2,-1));
var
  n,m,i,j,sx,sy:longint;
  h,t,x,y,newx,newy:longint;                //bfs专用……
  map:array[1..250,1..250] of longint;
  q:array[1..80000] of point;
  te:string;         //输出优化，下面有
begin
  fillchar(map,sizeof(map),255);       //fillchar 255 赋值后整个数组就变成-1啦！
  readln(n,m,sx,sy);
  map[sx,sy]:=0;  //起始点不走就到了
  t:=1; h:=0;
  q[t].x:=sx; q[t].y:=sy;
  while h<t do
    begin
      inc(h);
      x:=q[h].x;
      y:=q[h].y;
      for i:=1 to 8 do
        begin
          newx:=x+dir[i,1];
          newy:=y+dir[i,2];
          if (newx>=1) and (newx<=n) and (newy>=1) and
            (newy<=m) and (map[newx,newy]=-1) then     //这里就可以少一个visited啦
              begin
                map[newx,newy]:=map[x,y]+1;
                inc(t);
                q[t].x:=newx; q[t].y:=newy;
              end;
        end;
    end;
  for i:=1 to n do
    begin
      for j:=1 to m do
        begin
          str(map[i,j],te);                         //输出优化：把数字转成字符串，按长度补空位
          write(te,'':5-length(te));
        end;
      writeln;
    end;
end.
[/codep]
```

---

## 作者：ws_pt2 (赞：3)

广搜。。。

竟然没有Pascal的代码。。。

就因为数组大小和输出要求卡了我和我同学好久。

代码如下，注视在里面

```cpp

(
const
 dx:array[1..8] of longint=(2,1,-1,-2,-2,-1,2,1);
 dy:array[1..8] of longint=(-1,-2,-2,-1,1,2,1,2);//马跳的时候坐标发生的变化，顺序没要求，只要x和y对起来就行
var
 s:array[1..233,1..233] of longint;//这是最后要用来输出的数组
 h:array[1..233333,1..2] of longint;//队列
 bz:array[1..233,1..233] of boolean;//判断是否搜过
 n,m,x,y,i,j,p:longint;
procedure guangsou(c,d:longint);//看过程名就知道是干什么吧
var i,j,t,w,x,y:longint;
begin
 bz[c,d]:=false;
 t:=1; w:=1;
 h[t,1]:=c; h[t,2]:=d;
 s[c,d]:=1;
 repeat
 for i:=1 to 8 do //八个方向
 begin
  x:=h[t,1]+dx[i]; y:=h[t,2]+dy[i];
  if (x>0)and(x<=n)and(y>0)and(y<=m)and bz[x,y] then
  begin
   inc(w);
   h[w,1]:=x;
   h[w,2]:=y;
   bz[x,y]:=false;//入队
   s[x,y]:=s[h[t,1],h[t,2]]+1;//步数+1
  end;
 end;
 inc(t);
 until t>w;
end;
begin
 readln(n,m,x,y);
 fillchar(s,sizeof(s),0);
 fillchar(bz,sizeof(bz),true);
 guangsou(x,y);
 for i:=1 to n do
 begin
  for j:=1 to m do
   begin
    write(s[i,j]-1);//先往外输，再单独判断空格的数量
    if (s[i,j]-1<10)and(s[i,j]-1>=0)then write('    ');//四个空格，我在这里说明大家就不用再数了
    if ((s[i,j]-1<100)and(s[i,j]-1>=10))or(s[i,j]-1=-1) then write('   ');//三个空格
    if (s[i,j]-1<1000)and(s[i,j]-1>=100) then write('  ');//俩空格
    if s[i,j]-1>=1000 then write(' ');//一个
   end;
  writeln;//换行
 end;
end.
Pascal就这特点，没法和C++那样"%-5d"就行，所以只能这么单独判断。
主要就是考察搜索和输出。。。。。。。。。


---

## 作者：SW_Wind (赞：3)

具体的楼下说的已经很清楚了

我就说点关于格式化输出的

printf()函数大家都知道

如果这么用

printf("%d", 233);

就只会输出“233”

然而如果在“%d”中间加一个数字，就会自动按位补0，如：

printf("%5d", 233);

会输出“  233”（233前面多了两个空格）

因为默认是右对齐，所以会在左边补0

要想左对齐的话，在5的前面加一个负号即可，如：

printf("%-5d", 233);

这样就会输出"233  "（空格出现在233后面）

同理，若要格式化输出小数也是这样。

例如
printf("%-5.2f", 1.5);//保留两位小数左对齐，不够5位补空格

输出：1.50

这样逼格才显得高(手动滑稽)


---

## 作者：zqiceberg (赞：2)

### 算法
bfs( )

### 分析

用dist[N][N]记录距离，所有点初始化成-1

手写队列

队头元素取出来，8个方向遍历判断合法性

每次入队的时候，距离设置为前一个点的距离+1

注意printf()左对齐是"%-5d"

### 代码

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <fstream>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 410, M = N * N;

PII q[M];
bool st[N][N];
int dist[N][N];

int sx, sy;
int n, m;

//8个方向的坐标变化
int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};

void bfs()
{
    //手写队列
    int hh = 0, tt = 0;
    q[0].x = sx, q[0].y = sy;   //左上角入队，步数是0
    dist[sx][sy] = 0;
    st[sx][sy] = true;
    
    while (hh <= tt)
    {   
        PII t = q[hh++];       //队头出队
        //printf("---%d %d   %d\n", t.x, t.y, g[t.x][t.y].x);

        for (int i = 0; i < 8; i++)  //8个方向遍历
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a <= 0 || a > n || b <= 0 || b > m) continue;  //合法性剪枝
            if (st[a][b]) continue;                            //已搜索过剪枝

            ++tt;
            q[tt].x = a, q[tt].y = b;                          //新的点入队，步数为上一步的步数+1
            dist[a][b] = dist[t.x][t.y] + 1;
            st[a][b] = true;
        }
    }
}

int main()
{
    //freopen("horse.in", "r", stdin);

    cin >> n >> m >> sx >> sy;

    memset(dist, -1, sizeof dist);  //步数初始化成-1，这样不能到达的点，步数就是-1了

    bfs();

    for(int i = 1; i <= n; i++)     //输出结果
    {
        for (int j = 1; j <= m; j++)
            printf("%-5d", dist[i][j]);   //注意printf左对齐
        puts("");
    }
}

```

---

## 作者：AkiwaZawa (赞：2)

##    模板题

    本来想用DFS来写这道题，但是突然发现不能用dfs，那只会求到每一点的步数，而不是最快的步数，所以我用了bfs（广搜）寻找这一点能够到达的所有点。

    确定了算法，接下来就是输出格式的问题了。

    

------------

### （左对齐，宽5格，不能到达则输出-1）
    那么我们就来确定宽度
    
    若m为要求长度
    
###    printf： %md （右对齐）
###    printf： %-md（左对齐）

###    cout：cout<<left<<setw(m)<<"输出的东西"<<endl;(左对齐)

###          cout<<right<<setw(m)<<"输出的东西"<<endl;(右对齐)


------------

解决了输出的问题，那么本题就是一道模板题了


首先让马的起点坐标入队，然后在8个方向上扩展。

那么到达每个点需要的步数就是到达这个点之前一个点的步数+1），用a[i][j]记录到达点(i,j)的步数。

搜到最后，如果有a[i][j]为0且(i,j)不是起点，就把它变为-1，然后输出。


## 打上代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int s[402][402];//存数
int bx[401*401];
int by[401*401];
int fx[8]={-1,-2,-1,-2,1,2,1,2},//八个方向
    fy[8]={2,1,-2,-1,2,1,-2,-1};//马走的方向
int n,m;
void bfs(int x,int y)
{
    s[x][y]=0;
    int dx,dy;
    int head=0,tail=1;//初始化指针
    bx[1]=x,by[1]=y;//记录下位置
    do
    {
        head++;//头指针加一
        for(int i=0;i<=7;++i)
        {
            dx=bx[head]+fx[i];//寻找
            dy=by[head]+fy[i];
            if(dx>=1&&dx<=n&&dy>=1&&dy<=m&&s[dx][dy]<0)
            //判断
            {
                ++tail;//尾指针加一更新
                bx[tail]=dx;
                by[tail]=dy;
                s[dx][dy]=s[bx[head]][by[head]]+1;//前一步加一
            }
        }
 
    }while(head<tail);
}
void print()
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
          cout<<left<<setw(5)<<s[i][j];//左对齐
        cout<<endl;
    }
}
int main()
{
    memset(s,-1,sizeof(s));
    cin>>n>>m;
    int x,y;
    cin>>x>>y;
    bfs(x,y);
    print();
    return 0;
}


```


---

## 作者：DistanceRain (赞：2)

~~本来想用dfs做最后自闭开始bfs的蒟蒻~~\
首先声明:本篇题解码风清奇，也不是正常bfs（神佬勿喷）\
不多废话，本题是一道比较简单的bfs，唯一需要注意的地方是如何在地图中标记是第几次跳到该位置的，我使用的方法是mapa[x+mx[i]][y+my[i]]=mapa[x][y],就是在入队的时候就把步数标记好，由起跳点次数+1。\
Code:
```cpp
#include <bits/stdc++.h>
using namespace std ; 
int a , b , x , y ,mapa[401][401];
int mx[9] = {0,1,2,2,1,-1,-2,-2,-1} , my[9] = {0,2,1,-1,-2,-2,-1,1,2} ;
queue <int> horsex ;
queue <int> horsey ;
void bfs (int x , int y ) {
	if (!horsex.empty()){
		horsex.pop();
		horsey.pop();
	}
	for (int i=1;i<=8;i++){
		if(x+mx[i]>0&&x+mx[i]<=a&&y+my[i]>0&&y+my[i]<=b&&mapa[x+mx[i]][y+my[i]]==0){
			horsex.push(x+mx[i]);
			horsey.push(y+my[i]);
			mapa[x+mx[i]][y+my[i]] = mapa[x][y]+1;//标记步数
		}
	}
	if (horsex.empty()){
		return;
	}
	bfs(horsex.front(),horsey.front());
}
int main () {
	cin >> a >> b >> x >> y ;
	horsex.push(x);
	horsey.push(y);
	bfs(horsex.front(),horsey.front());
	for (int i=1;i<=a;i++){
		for (int j=1;j<=b;j++){
			if (i==x&&j==y){//注意起始点也是0，特别处理不要输出成-1
				cout << "0    ";
			}else if(mapa[i][j]==0){
				cout <<"-1   ";
			}else {
				printf("%-5d",mapa[i][j]);
			}
		}
		cout << endl ;
	}
	return 0;
}
```


---

## 作者：薛定谔的彪 (赞：2)

宽度优先搜索学了3,4,天，今天略有一点体会，这种算法常用于最短路径的求解！
宽度搜索：无非就是横向搜索
即：从起始节点v1去访问v1的子节点，直达v1的子节点被访问完毕
然后在对v1第一个节点的子节点遍历，遍历完成后，再接着是对v1的第二的节点的子节点全部遍历.....................................以此类推！


实现方法：
便是队列，原因如下：
队列具有先进先出的性质，符合宽度搜索的要求！（深度搜索需要的是递归）
队列可以用数组来模拟，而前提是有足够多的Node（节点），这里的节点一般用结构体来表示！
一句话：满足条件就压入队列，没满足条件就过！直到队列里没有节点便是结束的时候了！

基本思路（一定要弄清楚head和tail值！从而实现对队列的入列和出列）：先是对其中任一个节点放入列队（数组实现的话就是head）因为需要去寻找节点的子节点。（寻找子节点就是对满足条件的点再次放入队列，但是tail要加1）。


------------
  代码如下·~~~~~~~~~~~~马的遍历
------------
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;
struct queue {
	int x,y;
} que[40001];//注意节点的个数，防止卡数据
int fx[8]= {2,-2,2,-2,-1,1,-1,1},fy[8]= {1,1,-1,-1,2,2,-2,-2}; //方向
int a[401][401];
int head=0,tail=1,m,n,x,y,tx,ty;
int main() {
	for(int i=1; i<=400; i++)
		for(int j=1; j<=400; j++)
			a[i][j]=-1;
	cin>>m>>n>>x>>y;
	a[x][y]=0;
	que[tail].x=x;  //无论马从哪里开始，始终把他的位置设置为第一个节点
	que[tail].y=y;
	while(head<tail) {
		head++;
		int s=a[que[head].x][que[head].y]+1;
		for(int ii=0; ii<8; ii++) {
			tx=que[head].x+fx[ii];
			ty=que[head].y+fy[ii];//扩展新点
			if(a[tx][ty]==-1&&tx>=1&&tx<=m&&ty>=1&&ty<=n) { //没有走过并且没有超出棋盘
				tail++;
				que[tail].x=tx;
				que[tail].y=ty;//新点入队
				a[tx][ty]=s;//标记到达该点的最小步数
			}	
		}
	}
	for(int i=1; i<=m; ++i) {
		for(int j=1; j<=n; ++j)
			printf("%-5d", a[i][j]);//输出，注意格式
		cout<<endl;
	}
	return 0;
}
```

------------


---

## 作者：Neil1110 (赞：2)

完全没必要开多大的数组，一个队列就完事了啊喂。先把棋盘全都初始化为-1（步数），然后记录一下步数，之后每次在原先步数上+1就行了。因为第一次到一个点的时候肯定是步数最少的，所以只需要判断一下那个点是不是-1。至于最后的输出部分，百度一下就行了2333

```cpp

#include<iostream>
#include<queue>
#include<iomanip>
using namespace std;
const int maxn=201;
int map[maxn][maxn];
int n,m,move[8][2]={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};
struct point 
{
    int x,y,n;
} p;
queue<point> q;
int main()
{
    int i,j;
    cin>>n>>m;
    for(i=0;i<n;i++)
        for(j=0;j<m;j++)
            map[i][j]=-1;
    cin>>p.x>>p.y;
    p.x--;
    p.y--;
    map[p.x][p.y]=0;
    q.push(p);
    while(!q.empty())
    {
        point temp;
        for(i=0;i<8;i++)
        {
            temp=q.front();
            int x=temp.x+move[i][0];
            int y=temp.y+move[i][1];
            if(x<0||x>n||y<0||y>m||map[x][y]!=-1)
                continue;
            temp.x+=move[i][0];
            temp.y+=move[i][1];
            temp.n++;
            q.push(temp);
            map[temp.x][temp.y]=temp.n;
        }
        q.pop();
    }
    for(i=0;i<n;i++)
    {
        for(j=0;j<m;j++)
            cout<<setiosflags(ios::left)<<setw(5)<<map[i][j];
        cout<<endl;
    }
    return 0;
}

```

---

## 作者：CancerGary (赞：2)

这道题用广度优先搜索即可。

c++代码，使用了STL的队列。

printf("%-5d",map[i][j]) 代表左对齐5格输出【%5d 则是右对齐】

这说明要详细了解语言特性，内置的功能没有必要再重新实现一遍【考试时时间紧张的话可以节省很多时间】

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int map[250][250];
int pos[8][2]={{-2,-1},{-1,-2},{1,-2},{-2,1},{-1,2},{2,-1},{1,2},{2,1}};
int n,m,x,y,i,j,x0,y0,k;
queue<int> qx,qy;
int main(){
    cin >>n>>m>>x>>y;
    memset(map,-1,sizeof(map));    
    map[x][y]=0;
    qx.push(x);qy.push(y);
    while (qx.size()>0){
        x0=qx.front();y0=qy.front();qx.pop();qy.pop();
        for (k=0;k<8;k++) if (x0+pos[k][0]>=1&&x0+pos[k][0]<=n&&y0+pos[k][1]>=1&&y0+pos[k][1]<=m&&\
            map[x0+pos[k][0]][y0+pos[k][1]]==-1){
            qx.push(x0+pos[k][0]);qy.push(y0+pos[k][1]);
            map[x0+pos[k][0]][y0+pos[k][1]]=map[x0][y0]+1;
        }
    }
    for (i=1;i<=n;i++){
        for (j=1;j<=m;j++) printf("%-5d",map[i][j]);
        printf("\n");
    }
}

```

---

## 作者：空·白 (赞：2)

这题真是太~~恶心~~了,这个左对齐真的是要逼疯我，但是程序还是很好写的。（C++自带STL就很完美，不用考虑队列怎么写）

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
queue <int> que;	//记录横坐标
queue <int> q;		//记录纵坐标
int s[410][410];	//标记有没有走过
int ans[410][410];	//记录答案
int d[8][2]={{2,1},{1,2},{-1,2},{-2,1},{2,-1},{-2,-1},{1,-2},{-1,-2}};	//马走的方向
int n,m;
void bfs(int x,int y)
{
	while(!que.empty())
	{
		x=que.front();
		y=q.front();
		que.pop();
		q.pop();
		for(int i=0;i<8;i++)
		{
			int xx,yy;
			xx=x+d[i][0];
			yy=y+d[i][1];
			if(xx>=1&&xx<=n&&yy>=1&&yy<=m&&ans[xx][yy]==0&&s[xx][yy]==0)	//判定坐标在不在棋盘内，还有走没走过
			{
				s[xx][yy]=1;	//标记走过
				ans[xx][yy]=ans[x][y]+1;	//存储答案
				que.push(xx);
				q.push(yy);
			}
		}
	}
}
int main()
{
	int x,y;
	cin>>n>>m>>x>>y;
	s[x][y]=1;	
	que.push(x);
	q.push(y);
	bfs(x,y);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(ans[i][j]==0)
			{
				if(i==x&&j==y)
				{
					ans[i][j]=0;	//起点记为0
				}
				else
				ans[i][j]=-1;	//到不了的地方记为-1
			}
		} 
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cout<<left<<setw(5)<<ans[i][j];
		}
		cout<<endl;
	}
}
```


---

## 作者：Punny (赞：2)

## 这个题解的目的是向大家介绍pair

### pair类似于像结构体一样是一种模板类型，其中包含两个数据值，两个数据的类型可以不同如pair<int,int>x表示的是“x”的2两个int类型的数据其中的两个int类型的数据可以用x.first与x.second来调用

定义：
```cpp
pair<int,int>x(常数,常数);

x=make_pair(常数,常数);

pair<int,int>x x.first=常数,x.second=常数;

由于定义过于繁琐，可以用typedef简化

typedef pair<int,int> P_air;

P_air pro(常数,常数);
```
用法：

可以看一段代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main () {
  pair <string,double> product1 ("tomatoes",3.25);
  pair <string,double> product2;
  pair <string,double> product3;

  product2.first = "lightbulbs";     // type of first is string
  product2.second = 0.99;            // type of second is double

  product3 = make_pair ("shoes",20.0);

  cout << "The price of " << product1.first << " is $" << product1.second << "\n";
  cout << "The price of " << product2.first << " is $" << product2.second << "\n";
  cout << "The price of " << product3.first << " is $" << product3.second << "\n";
  return 0;
}
```

输出：
```cpp
The price of tomatoes is $3.25
The price of lightbulbs is $0.99
The price of shoes is $20
```

在写bfs的时候pair也可以适用于队列：

```cpp
queue<pair<int,int> >q
q.push(make_pair(sum,num));
int x=q.front().second;
```

本题代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,bx,by,sum;
int mp[401][401];
int tx[8]={2,-2,2,-2,-1,1,-1,1},ty[8]={1,1,-1,-1,2,2,-2,-2};
bool v[401][401];
bool check(int a,int b){
    if(a>0&&b>0&&a<=n&&b<=m&&!v[a][b]) return 1;
    return 0;
}
void bfs(){
    queue<pair<int,int> >q;
    q.push(make_pair(bx,by));
    v[bx][by]=1;
    while(q.size()){
        int x=q.front().first,y=q.front().second;
        q.pop();
         for(int i=0;i<=7;i++){
         	int X=x+tx[i],Y=y+ty[i];
         	if(check(X,Y)){
         		v[X][Y]=1;
         		mp[X][Y]=mp[x][y]+1;
                 q.push(make_pair(X,Y));	
             }
         }
    }
}
int main(){
    scanf("%d%d%d%d",&n,&m,&bx,&by);
    memset(mp,0xff,sizeof(mp));
    mp[bx][by]=0;
    bfs();
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            printf("%-5d",mp[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```
把数组全赋值为-1用队列来bfs从8个方向进行，看是否能不能到达，如果可以把搜到的位置在数组中赋值是第几次搜的（每次8个方向搜完一次8个方向后就增加次数），记得判重。输出因为要向左靠齐，用%5d是向右，所以要用%-5d。

[pair参考文献](https://blog.csdn.net/xywlpo/article/details/6458867)


---

## 作者：Umaru (赞：2)

蒟蒻刚刚学bfs 很经典的bfs题

简单易懂8ms朴素bfs

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<queue> 
#include<algorithm>
#define space1 "    ";//曾经尝试用这种方法输出空格 
#define space2 "   ";//后来发现不如直接printf简单 
using namespace std;
struct point{
    int x;
    int y;
    int step;
    point (int x,int y,int step) :x(x),y(y),step(step) {}
};//其实用两个队列分别装xy的话也可以不用结构体 
const int maxn = 500;//不要开小了
const int dx[]={-1,-2,-2,-1,1,2,2,1};
const int dy[]={-2,-1,1,2,2,1,-1,-2};
int st,ed;
int map[maxn][maxn]; 
bool vis[maxn][maxn];
int n,m;
void bfs(int st,int ed){
    queue<point> q;
    q.push(point(st,ed,0));
    while(!q.empty()){
        point np=q.front();
        q.pop();
        vis[np.x][np.y]=true;
        np.step++;
        for(int i=0;i<8;++i){
            point nw=np;
            nw.x+=dx[i];
            nw.y+=dy[i];
            if(nw.x>n||nw.y>m||nw.x<1||nw.y<1||vis[nw.x][nw.y])
                continue;
            map[nw.x][nw.y]=nw.step;
            vis[nw.x][nw.y]=true;//之前没有这句 在这里卡了很久
            //这句必须有 
            //不同起步可能指向相同节点 必须操作后马上就标记避免重复入队 不要担心重复标记 标了没事 不标肯定死
            q.push(nw);
        }
    }
}
int main(){
    memset(map,-1,sizeof(map));
    cin>>n>>m>>st>>ed; 
    map[st][ed]=0; 
    bfs(st,ed);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            printf("%-5d",map[i][j]);//只会printf控制固定行输出。。。 
        }
        putchar(10); //10是换行符（"\n"）的ascii码 
    }
    return 0; 
}
```

---

## 作者：YangHao (赞：2)

经典的一道bfs，我个人认为难度只有普及-，大神勿喷.
用ans数组保存答案，初始值为-1，也可以用它来判断是否入队. 具体见注释. 


附上无O2耗时0ms简洁代码.

```
//By YangHao QQ2034329047
#include <cstdio>
#include <cstdlib>
#include <cstring>

int n, m; //地图规模
int sx, sy; //初始坐标
int qx[160010]; //队列，懒得写结构体
int qy[160010];
int ans[410][410]; //答案数组
int st, ed;
					//偏移量
int fx[10] = {-2, -2, -1, 1, 2, 2, 1, -1};
int fy[10] = {-1, 1, 2, 2, 1, -1, -2, -2};

int main()
{
	scanf ("%d%d%d%d"，&n, &m, &sx, &sy);
    //初始化
	memset (qx, 0，sizeof (qx)); qx[1] = sx;
	memset (qy, 0, sizeof (qy)); qy[1] = sy;
	memset (ans, -1, sizeof (ans)); ans[sx][sy]　= 0; //起点步数为0
	st = 1; ed = 2;
	while (st != ed) //bfs
	{
		int xx = qx[st], xy = qy[st];
		for (int i = 0; i < 8; ++i)
		{
			int nx = xx + fx[i], ny = xy + fy[i];
			//判断边界，以及是否存在更优路径
            if (nx < 1 || nx > n || ny < 1 || ny > m || (ans[nx][ny] <= ans[xx][xy] + 1 && ans[nx][ny] + 1))
				continue;
            //更新答案
			ans[nx][ny] = ans[xx][xy] + １;
            //重新入队
			qx[ed] = nx; qy[ed++] = ny；
		}
		++st;
	}
	for (int i = 1; i <= n; ++i)
	{
    	//注意输出格式
		for (int j = 1; j <= m; ++j)
			printf ("%-5d", ans[i][j]);
		puts ("");
	}
}
```

---

## 作者：ylsoi (赞：1)

一道典型的广度优先搜索的题目，从给定的起点开始出发，因为题目满足费用（走的步数）与搜索的层数成正比，所以第一次搜索到时所花费的步数即为最优的。然后我们可以在队列的结构体中再定义一个变量step来记录目前走到这个点所需要的步数，当拓展节点的时候，队列尾的步数即为队列首的步数加一，但是有还有特殊的情况，就是最后发现为零时（当然不是起点啦）就要输出-1；

附上代码如下

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
using namespace std;
const int maxn=400+10;
int m,n,startx,starty,a[maxn][maxn],ans[maxn][maxn];
bool s[maxn][maxn];
struct tt
{
    int x;
    int y;
    int step;
}t[maxn*maxn];
int xx[9]={0,1,2,2,1,-1,-2,-1,-2};//这个很显然是定义八个不同的方向
int yy[9]={0,2,1,-1,-2,2,1,-2,-1};
void bfs()
{
    int head=0,tail=1;
    t[1].x=startx;t[1].y=starty;
    s[startx][starty]=1;t[1].step=0;
    while(head<tail)
    {
        head++;//指向要拓展的节点
        for(int i=1;i<=8;i++)
        {
            int x1=t[head].x+xx[i],y1=t[head].y+yy[i];
            if(x1>=1&&x1<=m&&y1>=1&&y1<=n&&s[x1][y1]==0)
            {
                s[x1][y1]=1;
                tail++;
                t[tail].x=x1;
                t[tail].y=y1;
                t[tail].step=t[head].step+1;//将目前这个坐标的步数+1；
                ans[x1][y1]=t[tail].step;//将步数计入答案数组
            }
        }
    }
}
int main()
{
    scanf("%d%d%d%d",&m,&n,&startx,&starty);
    bfs();
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if((i!=startx||j!=starty)&&ans[i][j]==0)//目前点的横坐标或者纵坐标只要有一个不等于起点并且该值等于0的时候，我们就可以输出-1啦啦啦
            printf("%-5d",-1);
            else printf("%-5d",ans[i][j]);
        }
        printf("\n");
    }
    return 0;
}

```

---

## 作者：攀岩高手 (赞：1)

**标准BFS解法**

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
struct note // 这里定义一个结构体存BFS队列
{
    int x;
    int y;
    int step; // 当前步数
} que[160000];
int n, m, x, y;
int head = 1, tail = 1;
int a[401][401];
const int next[8][2] = {{2, 1},  {1, 2}, {-2, -1}, {-1, -2}, {2, -1}, {-1, 2}, {-2, 1}, {1, -2}}; // next数组存下一步的相对位置
int main()
{
    int tx, ty;
    scanf("%d%d%d%d", &n, &m, &x, &y); // 读入数据
    memset(a, -1, sizeof a); // 初始化数组，全部标记为-1
    que[tail].x = x;
    que[tail].y = y;
    que[tail].step = a[x][y] = 0; // 设置起点的坐标，并把起点标记为0
    tail++; // 插入起点后，队尾+1
    while (head < tail) // 开始BFS
    {
        for (int k = 0; k < 8; k++) 遍历马的8种情况
        {
            // 计算马下一步的坐标
            tx = que[head].x+next[k][0];
            ty = que[head].y+next[k][1];
            if (tx < 1 || tx > n || ty < 1 || ty > m) continue; // 如果以越界，直接执行下一种情况
            if (a[tx][ty] == -1) 如果这个点标记为-1，即未走过
            {
                // 插入这个点的坐标
                que[tail].x = tx;
                que[tail].y = ty;
                que[tail].step = a[tx][ty] = que[head].step+1; // 把此点的步数设为此点父亲的步数+1
                tail++;
            }
        }
        head++; // 执行完毕，父亲出队
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
            printf("%-5d", a[i][j]); // 输出
        printf("\n");
    }
    return 0;
}
```

---

## 作者：_J_C_ (赞：1)

呐。分组都说广搜了，我还能怎么办……

我也很无奈啊。。直接上代码

代码是标准广搜……好像不太方便说原理？

来个例子（最喜欢例子了）

0次操作

0 -1 -1

-1 -1 -1

-1 -1 -1


1次操作

0 -1 -1

-1 -1 1

-1 1 -1


2次操作

0 -1  2

-1 -1 1

2 1 -1

3次操作

0  3   2

3 -1  1

2  1 -1


4次操作

0  3  2

3 -1 1
2  1  4


接下来不管怎么操作都走不到中间那个点了

#//”它没有机会了“



代码比较难解释……也比较不雅观

实在不行就先理解上面的吧



```cpp
#include <iostream>
using namespace std;
struct point
{
    int x,y;
    bool operator==(point &p)
    {
        return p.x == x&&p.y == y;
    }
};//一个小小的辅助类
int iMap[400][400];//地图，用来输出
int n,m;
int MoveX[]={-1,-2,-2,-1,1,2,2,1};//马的移动方式，领悟一下？
int MoveY[]={-2,-1,1,2,2,1,-1,-2};
point Point[2][10000];
int bP(0);
int main()
{
    cin>>n>>m;
    for(int i(0);i!=n;++i)
        for(int a(0);a!=m;++a)
            iMap[i][a]=-1;//先把地图全部标记为走不到
    {
        point p;//临时变量，有强迫症的我在边上加了两个大括号限制作用域QAQ去了也没事
        cin>>p.x>>p.y;
        --p.x;--p.y;
        Point[bP][0]=p;
    }
    int iEnd[2]={1,1};
    int iCount(0);
//这里关于bp的使用非常奇特（这么自夸真的好吗）
//bp%2就是表示当前的节点
//(bp+1%)2表示输出节点到的数组
    while(iEnd[bP%2]!=0)
    {
        int iE(0);
        for(int i(0);i<iEnd[bP%2];++i)
        {
            iMap[Point[bP % 2][i].x][Point[bP % 2][i].y]=iCount;
            point OpenP;
            for(int a(0);a!=8;++a)
            {
                OpenP.x=Point[bP % 2][i].x+MoveX[a];
                if(OpenP.x<0||OpenP.x>n)
                    continue;
                OpenP.y=Point[bP % 2][i].y+MoveY[a];
                if(OpenP.y<0||OpenP.y>m)
                    continue;
                if(iMap[OpenP.x][OpenP.y]!=-1)
                    continue;
                bool bFind(false);
                for (int b(0); b != iE; ++b)
                {
                    if (Point[(bP + 1) % 2][b] == OpenP)
                    {
                        bFind = true;
                        break;
                    }
                }
                if(!bFind)
                    Point[(bP+1) % 2][iE++]=OpenP;
            }
        }
        ++bP;
        iEnd[bP % 2]=iE;
        ++iCount;
    }
    for(int i(0);i!=n;++i)
    {
        for(int a(0);a!=m;++a)
            printf("%-5d",iMap[i][a]);
        printf("\n");
    }
    system("pause");
    return 0;
}
希望对你有所帮助，能让你理解哦
```

---

## 作者：梧桐灯 (赞：1)

此题用BFS

由于C++的功能十分强大，所以我用queue队列

其实很简单






```cpp
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
queue <short> x; //定义横坐标队列
queue <short> y; //定义纵坐标队列
int n,m,a[405][405]; //存放步数
const int zh[8][2]={ //状态转移数组
    {1,2},
    {1,-2},
    {-1,2},
    {-1,-2},
    {2,1},
    {2,-1},
    {-2,1},
    {-2,-1}
};
void bfs(){
    int i,j,u,xx,yy;
    while(!(x.empty())){ //一直循环到队列为空
        xx=x.front();
        yy=y.front();
        x.pop(); //出队
        y.pop(); //出队
        for(u=0;u<8;u++){
            i=xx+zh[u][0]; 
            j=yy+zh[u][1];
            if(i>=1 && i<=n && j>=1 && j<=m && !(a[i][j])){ //判断是否越界或已经遍历过
                x.push(i); //入队
                y.push(j); //入队
                a[i][j]=a[xx][yy]+1; //步数为上一次加1
            }
        } //这个for循环用来把马跳到没有遍历到的地方去
    }
}
int main(){
    int p,q;
    scanf("%d %d %d %d",&n,&m,&p,&q);
    x.push(p); //横坐标入队
    y.push(q); //纵坐标入队
    a[p][q]=1; //步数从1开始，方便判断
    bfs(); //广搜
    for(p=1;p<=n;p++){
        for(q=1;q<=m;q++)
            printf("%-5d",a[p][q]?a[p][q]-1:-1); //输出步数时要减1
        printf("\n");
    }
    return 0;
}

```

---

## 作者：fl_334 (赞：1)




```cpp
const
        max_len=50000;
        sz:array[1..8,1..2]of longint=((1,2),(1,-2),(-1,2),(-1,-2),(2,1),(2,-1),(-2,1),(-2,-1));                   //控制行列
type
        jl=record
                x,y,count:longint;
        end;
        queue=record
                a:array[0..max_len]of jl;
                head,tail:longint;
        end;
var
        q:queue;
        i,j,k,n,m,aa,b:longint;
        bb:array[0..205,0..205]of boolean;
        sum:array[0..205,0..205]of longint;               //记忆数组
//pop，push等函数自己尝试写
function yuejie(x,y:longint):boolean;
begin
        if (x<=0) or (y<=0) or (x>n) or (y>m) then exit(true)
        else exit(false);
end;
function search(xx,yy:longint):longint;
var
        pre,next:jl;
        i:longint;
begin
        pre.x:=aa;
        pre.y:=b;
        pre.count:=0;
        push(q,pre);
        sum[xx,yy]:=0;
        while not isempty(q) do
        begin
                pre:=pop(q);
                for i:=1 to 8 do
                        if (not yuejie(pre.x+sz[i,1],pre.y+sz[i,2])) and
                        (sum[pre.x+sz[i,1],pre.y+sz[i,2]]=-1) then
                        begin
                                next.x:=pre.x+sz[i,1];
                                next.y:=pre.y+sz[i,2];
                                next.count:=pre.count+1;
                                sum[next.x,next.y]:=next.count;
                                push(q,next);
                        end;
        end;
        exit(-1);
end;
begin
        readln(n,m,aa,b);
        fillchar(bb,sizeof(bb),true);
        q.head:=0;
        q.tail:=0;
        for i:=1 to n do
                for j:=1 to m do
                        sum[i,j]:=-1;               //初始化哒
        search(aa,b);                         //搜索大法好
        for i:=1 to n do
        begin
                for j:=1 to m do
                begin
                        k:=sum[i,j];              
                        write(k);                              //输出要注意，当时我wa了好久，后来偷偷看了一下题解。。。。。Pascal党们注意了
                        if (k<10) and (k>=0) then write('    ');             //4个空格
                        if ((k<100) and (k>=10)) or (k=-1) then write('   ');      //三
                        if (k<1000) and (k>=100) then write('  ');    //二
                        if (k>=1000) then write(' ');          //一个
                end;
                writeln;
        end;
end.

```

---

## 作者：墨凝而止 (赞：1)

[color=spearmint]本题的思路，与“显示图像”的思路基本相同。

本题采用广度优先搜索，先从马的起点出发，向八个方向拓展，并将拓展的点坐标计入一个队列中。在搜索中，另建一个记录数组，标志最少走的步数。每一个拓展的点的记录数为被拓展点的记录数加一。另，先将马本然位置记为1，以供区别。头尾指针相遇后，搜索结束，每一个可行点皆被填以最少步数加一。既然不可行点输出-1，如此正中下怀。在输出时，每一个点输出其数值减一，即可。

同时建议，掌握如此方法，“显示图像”（1256）亦可以完成，以供磨刀。[/color]

初二
墨凝  执笔


---

## 作者：LikeJ (赞：1)

## ***马的遍历***
**题目描述**
有一个n*m的棋盘(1<n,m<=400)，在某个点上有一个马,要求你计算出马到达棋盘上任意一个点最少要走几步
**输入格式**
一行四个数据，棋盘的大小和马的坐标
**输出格式**
一个n**乘**m的矩阵，代表马到达某个点最少要走几步（左对齐，宽5格，不能到达则输出-1）
**输入输出样例**
**输入**
3 3 1 1
**输出** 
0    3    2    
3    -1   1    
2    1    4    
**分析**
这道题我们可以用深搜（BFS）
很简单，不会BFS的可以参考[
骑士旅行（BFS）](https://blog.csdn.net/weixin_45524309/article/details/103429413)
**AC代码**
```cpp
#include<iostream>
#include<cstdio>
int n,m,x1,y1,head,tail,a[405][405],b[405][405],st[160005][3];
int dx[9]={0,1,1,-1,-1,2,2,-2,-2};//八个方向
int dy[9]={0,2,-2,2,-2,1,-1,1,-1};
void bfs()
{
	while(head<tail)//BFS模板
	{
		head++;
		for(int i=1;i<=8;i++)//八个方向
		 {
		 	int x=st[head][0]+dx[i],y=st[head][1]+dy[i];
		 	if(x>=1&&x<=n&&y>=1&&y<=m)//是否出界
		 	 if(a[x][y]==0)//是否被标记过
		 	  {
		 	  	tail++;
		 	  	a[x][y]=1;//标记
		 	  	b[x][y]=st[tail][2]=st[head][2]+1;//赋值
			    st[tail][0]=x;//更新坐标
			    st[tail][1]=y;
			  }
		 }
	}
}
using namespace std;
int main()
{
	cin>>n>>m;
	cin>>x1>>y1;
	a[x1][y1]=1;//标记
	st[1][0]=x1;st[1][1]=y1;//坐标
	tail=1;//初值
	bfs();
	for(int i=1;i<=n;i++)
	{
	 for(int j=1;j<=m;j++)
	  if(a[i][j]!=0)printf("%-5d",b[i][j]);//输出需要
	   else printf("%-5d",-1);
	 cout<<endl;
	}
}
```
## ***谢谢***

---

## 作者：oistr (赞：1)

蒟蒻第一次发bfs的题解。

**upd：刚刚提交之后发现有一点错误，修正了错误，故重新提交**

**再次upd：发现一些地方讲的不是很清楚，补充一下——2019-08-23**

典型的跳马问题。

dfs不剪枝会超时，所以bfs ~~（蒟蒻不会剪枝）~~。

现在结合下面的广搜模版讲一下这题的搜索过程。

首先，一次搜索即可完成，用con[i][j]存储到点(i,j)的步数。在搜索过程中顺便更新到达每个点的步数。

将初始节点（起点）$(sx,sy)$ 入队。（**STL的queue同样适用于自定义的结构体**）

然后进入循环部分。每一次先将当前状态$(x,y)$ 出队并记录，然后循环遍历每种可能的情况（以 $(nx,ny)$ 记）：

**提示：此处使用了两个常量数组movx和movy记录 $(x,y)$ 做八方向扩充时x，y可能的变化。这样化二重循环为一重，使代码看起来简洁清晰。**

如果 $(nx,ny)$ 越界或被选过，直接continue掉。

注意此处本来应该开一个 $bool$ 型的 $vis$ 数组， $vis[i][j]$ 表示 $(i,j)$ 有没有被选过，但是此处可以直接看 $con[nx][ny]$ 是不是0即可。是0则能选，否则不能。

接下来，将 $(nx,ny)$ 入队，令 $con[nx][ny]=con[x][y]+1$ 即可。

但是需要注意的是**如果 $(x,y)$ 是起点时不可break**。如果break将会少更新一些点的步数。

最后是输出。 **注意输出格式！** 

还需要注意几个特判：

①出发点应该输出0，而不是 $con[sx][sy]$ 。

②题目要求没有到达的点输出-1，而这里是0，应该特判。

然后就可以 $AC$ 了！

代码：
```
#include <iostream>
#include <cstdio>
#include <queue>//不建议用万能头
using namespace std;
struct Point
{
	int x;
	int y;
};//结构体存储点
queue<Point> q;//STL队列
int n,m,sx,sy;//n,m是范围，sx,sy是初始状态
int con[401][401];
int movx[8]={1,-1,-2,-2,-1,1,2,2};//8方向扩充
int movy[8]={2,2,1,-1,-2,-2,-1,1};
bool out(int _x,int _y)//判断是否越界，写成函数更清晰
{
	return _x<1||_y<1||_x>n||_y>m;
}
bool finish(int __x,int __y)//判断是否到终点
{
	return __x==sx&&__y==sy;
}
void output()
{//输出，强烈注意！不要被卡输出格式！
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(finish(i,j))
			{//终点输出0
				printf("0    ");
				continue;
			}
			else if(!con[i][j])
			{//注意题目要求没有到的均输出-1，因此除了终点以外的0应该全部转化为-1输出
				printf("-1   ");
				continue;
			}
			printf("%-5d",con[i][j]);//注意格式
		}
		cout<<endl;
	}
}
void bfs()//bfsbfsbfsbfsbfsbfsbfsing
{
	q.push((Point){sx,sy});//初始节点入队，这里用强制类型转换将一个Point类型压入。这样可以使程序看起来简洁明了。
	while(!q.empty())//队列为空时自动返回
	{
		Point now=q.front();
		q.pop();//记录下当前节点，并将其出队
		for(int i=0;i<8;i++)
		{
			int nx=now.x+movx[i];
			int ny=now.y+movy[i];//扩充新节点
			if(out(nx,ny))//越界，被选过均continue掉
			{
				continue;
			}
			if(con[nx][ny])
			{
				continue;
			}
        con[nx][ny]=con[now.x][now.y]+1;//到达这个点的步数是到达上一个点的步数加1
			q.push((Point){nx,ny});//这个节点入队
		}
	}
}
int main()
{
	cin>>n>>m>>sx>>sy;//输入数据
	bfs();//bfs一下
	output();//输出
	return 0;
}
```

### 附上一个万能的bfs框架
```cpp
#include <queue>
using namespace std;
queue<int> q;//以int为例，可以是其他的类型
void bfs()
{
	q.push(初始状态);
	while(!q.empty())
	{
		当前状态=q.front();
		q.pop();
		for(int i=1;i<=当前状态产生子节点的可能;i++)
		{
			if(新子节点不符合条件)
			{
				continue;
			}
			if(新子节点与已产生节点重复)
			{
				continue;
			}
			if(新子节点是目标节点)
			{
				输出结果;
				break; //此处不一定break，视情况而定（比如本题就不是）
			}
			q.push(新子节点);
		 } 
	}
}
```

---

## 作者：白天 (赞：1)

[color=spearmint]本题的思路，与“显示图像”的思路基本相同。

本题采用广度优先搜索，先从马的起点出发，向八个方向拓展，并将拓展的点坐标计入一个队列中。在搜索中，另建一个记录数组，标志最少走的步数。每一个拓展的点的记录数为被拓展点的记录数加一。另，先将马本然位置记为1，以供区别。头尾指针相遇后，搜索结束，每一个可行点皆被填以最少步数加一。既然不可行点输出-1，如此正中下怀。在输出时，每一个点输出其数值减一，即可。

同时建议，掌握如此方法，“显示图像”（1256）亦可以完成，以供磨刀。[/color]

初二
墨凝  执笔




最后的输出很恶心，注意一下

我的代码打的很笨但是能过，c++的

```cpp
for (i=1;i<=n;i++)
    {
        for (j=1;j<=m;j++)
        {
            cout<<ans[i][j];
            if (ans[i][j]<10 && ans[i][j]>=0)
                cout<<"    ";
            if ((ans[i][j]<100 && ans[i][j]>=10) || ans[i][j]==-1)
                cout<<"   ";
            if (ans[i][j]<1000 && ans[i][j]>=100)
                cout<<"  ";
            if (ans[i][j]>=1000)
                cout<<" ";
        }        
        cout<<endl;
    }
```
以下是全部代码，我没有写写注释的习惯，抱歉，不懂的看初二那位大神写的，方法一样的
```cpp
#include<iostream>
#include<string.h>
#include<algorithm>
#include<vector>
using namespace std;
struct nod{int x;int y;int step;};
vector<nod> duilie;
nod now,nex;
int j,n,m,ans[208][208],i,x,y,k;
int main()
{
    cin>>n>>m>>now.x>>now.y;
    memset(ans,-1,sizeof(ans));
    ans[now.x][now.y]=0;
    now.step=0;
    duilie.push_back(now);
    for (i=0;i<duilie.size();i++)
    {
        now=duilie[i];
        for (x=-2;x<=2;x++)
        for (y=-2;y<=2;y++)
        if (abs(x)+abs(y)==3)
            if (now.x+x>0 && now.y+y<=m && now.y+y>0 && now.x+x<=n)
            if (ans[now.x+x][now.y+y]==-1)
            {
                nex.x=now.x+x;
                nex.y=now.y+y;
                nex.step=now.step+1;
                ans[now.x+x][now.y+y]=nex.step;
                duilie.push_back(nex);
            }
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=m;j++)
        {
            cout<<ans[i][j];
            if (ans[i][j]<10 && ans[i][j]>=0)
                cout<<"    ";
            if ((ans[i][j]<100 && ans[i][j]>=10) || ans[i][j]==-1)
                cout<<"   ";
            if (ans[i][j]<1000 && ans[i][j]>=100)
                cout<<"  ";
            if (ans[i][j]>=1000)
                cout<<" ";
        }        
        cout<<endl;
    }
} 

```

---

## 作者：Leaved_ (赞：0)

~~不想用STL的同学看过来~~

# 手写队列+pair专属福利

大佬们都是把方向存在两个一维数组里，我存了一个二维数组

go[i][0] -> 横坐标

go[i][1] -> 纵坐标

Ps：注释在代码里

Code：
```cpp
#include<bits/stdc++.h>

using namespace std;

#define ll long long
#define f(i,a,b) for(int (i)=(a);i<=(b);++i)
#define mk(a,b) make_pair((a),(b))
#define P pair<int,int>
#define s(x) scanf("%lld",&(x))
#define p(x) printf("%lld ",(x))
#define fi first
#define se second
// sonil 特色 define 懒人优化 

int go[9][2]={{1,2},{1,-2},{2,1},{2,-1},{-1,2},{-1,-2},{-2,1},{-2,-1}};
//存方向 

int n,m,now_x,now_y;
int ans[410][410];
// ans 存答案 

P q[1000010];

bool ma[10010][10010];

void input() {
	s(n);s(m);
	s(now_x);s(now_y);
	//起始路径 
	f(i,1,n) {
		f(j,1,m) {
			ans[i][j]=-1;
			//初始化 -1 好用又省劲 
		}
	}
}

void Bfs() {
	ans[now_x][now_y]=0;
	ma[now_x][now_y]=true; 
	//起点初始化
	int head=1,tail=1;
	q[head].fi=now_x;
	q[head].se=now_y;
	//队列初始化 
	while(head<=tail) {
		int x2=q[head].fi;
		int y2=q[head].se;
		head++; //出队 
		f(i,0,7) {
			//枚举方向 
			int x1=x2+go[i][0];
			int y1=y2+go[i][1];
			//新点坐标 
			if (ma[x1][y1]||x1<1||x1>n||y1<1||y1>m) continue;//剪枝 
			ma[x1][y1]=true;
			tail++;
			q[tail].first=x1;
			q[tail].second=y1;
			//入队 
			ans[x1][y1]=ans[x2][y2]+1;
			//因为每个点只能走一次，所以不用取min，取了反而WA 
		}
	}
}

void output() {
	Bfs();
	f(i,1,n) {
		f(j,1,m) {
			printf("%-5d",ans[i][j]);//控制输出不多说 
		}
		cout<<endl;//一定要换行！！！ 
	}
}

int main() {
	input();
	output();
	return 0;
}

// sonil 特色 主函数 

```



---

## 作者：IOyuk1Nya (赞：0)

这道题是一道无脑BFS题，STL队列就行了。
```c
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,t;
}; 
int a[405][405],n,m,x,y;
bool vis[405][405];
int xx[8]={1,-1,2,-2,1,-1,2,-2},
	yy[8]={2,-2,1,-1,-2,2,-1,1};
inline void bfs(int x,int y,int ex,int ey){//对每个点找最短路径
	queue<node>q;
	q.push(node{x,y,0});
	while(!q.empty()){
		node u=q.front();
		q.pop();
		if(u.x==ex&&u.y==ey){
			a[ex][ey]=u.t;
			return;
		}
		for(int i=0;i<8;i++){
			int dx=xx[i]+u.x;
			int dy=yy[i]+u.y;
			if(vis[dx][dy]) continue;
			if(dx<1||dx>n||dy<1||dy>m) continue;
			vis[dx][dy]++;
			q.push(node{dx,dy,u.t+1});
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>x>>y;
	memset(a,-1,sizeof a);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			memset(vis,0,sizeof vis);
			bfs(x,y,i,j);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			printf("%-5d",a[i][j]);
		}
		
	}
	return 0;
}
```
一开始当最短路径来做，对每个点BFS，结果很显然T了两个点。。。
双重循环的复杂度太高了。。。
```c
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
}; 
int a[405][405],n,m,x,y;
bool vis[405][405];//visited数组防止重复
int xx[8]={1,-1,2,-2,1,-1,2,-2},
	yy[8]={2,-2,1,-1,-2,2,-1,1};//方向数组
inline void bfs(int x,int y,int t){
	a[x][y]=t;
	vis[x][y]=1;
	queue<node>q;
	q.push(node{x,y});//初始情况入队
	while(!q.empty()){
		node u=q.front();//取队首
		q.pop();
		for(register int i=0;i<8;i++){
			int dx=xx[i]+u.x;
			int dy=yy[i]+u.y;
			if(vis[dx][dy]) continue;
			if(dx<1||dx>n||dy<1||dy>m) continue;
			vis[dx][dy]=1;
			q.push(node{dx,dy});
			a[dx][dy]=a[u.x][u.y]+1;//每一步加一
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);//cin黑科技
	cin>>n>>m>>x>>y;
	memset(a,-1,sizeof a);
	memset(vis,0,sizeof vis);//初始化
	bfs(x,y,0);//BFS！
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			printf("%-5d",a[i][j]);//输出
		}
		printf("\n");
	}
	return 0;
}


```
然后就愉快的AC啦

~~蒟蒻第一篇题解QAQ~~

---

## 作者：AcerMo (赞：0)

priority_queue优化bfs
```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,sx,sy;
int dis[1000][1000];
struct edge
{
    int x;
    int y;
    int cost;
    bool friend operator < (edge a,edge b)
    {
        return a.cost>b.cost;
    }
};
int ask(int a,int b)
{
    return (a-1)*m+b;
}
int bfs()
{
    int vis[500][500]={0};
    int fx[8][2]={{1,2},{1,-2},{-1,-2},{-1,2},{2,1},{-2,1},{-2,-1},{2,-1}};
    memset(dis,-1,sizeof(dis));
    priority_queue<edge>q;
    edge now;
    now.x=sx;now.y=sy;now.cost=0;
    vis[sx][sy]=1;
    dis[sx][sy]=0;
    q.push(now);
    while (q.size())
    {
        now=q.top();q.pop();
        dis[now.x][now.y]=now.cost;
        for (int i=0;i<8;i++)
        {
            if (now.x+fx[i][1]>n||now.y+fx[i][0]>m||vis[now.x+fx[i][1]][now.y+fx[i][0]]||now.x+fx[i][1]<1||now.y+fx[i][0]<1) continue;
            vis[now.x+fx[i][1]][now.y+fx[i][0]]=1;
            edge t={now.x+fx[i][1],now.y+fx[i][0],now.cost+1};
            q.push(t); 
        }
    }
    return 0;
}
int main()
{
    scanf("%d %d %d %d",&n,&m,&sx,&sy);
    bfs();
    int ans=ask(sx,sy);
    for (int i=1;i<=n;i++){
        for (int j=1;j<=m;j++)
            printf("%-5d", dis[i][j]);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：czx20030930 (赞：0)

这题我写的是优先队列的广搜，代码自我感觉还算简洁


```cpp
#include <iostream>
#include <queue>
using namespace std;
int map[401][401], n, m, x, y;//map用来储存每个点的最少步数
struct point {
    int x, y;
    friend bool operator<(point a, point b) {//优先队列，步数少的考前
        return map[a.x][a.y] > map[b.x][b.y];
    }
};
priority_queue <point> q;
bool ok(int a,int b) {//判断一个点是否在界内并且没有访问过
    return a && b && a <= n && b <= m && map[a][b] == -1;
}
int main() {
    int i, j, k;
    int search[8][2] = {{-1, -2},
                        {-2, -1},
                        {-2, 1},
                        {-1, 2},
                        {1,  2},
                        {2,  1},
                        {2,  -1},
                        {1,  -2}};//每次可以走8个方向
    cin >> n >> m >> x >> y;
    for (i = 1; i <= n; i++)
        for (j = 1; j <= m; j++)
            map[i][j] = -1;//初始化为－1
    map[x][y] = 0;
    point a;
    a.x = x;
    a.y = y;
    q.push(a);//a代表初始点
    while (!q.empty()) {
        a = q.top();
        q.pop();
        for (i = 0; i < 8; i++)
            if (ok(a.x + search[i][0], a.y + search[i][1])) {//8个方向一个一个找
                map[a.x + search[i][0]][a.y + search[i][1]] = map[a.x][a.y] + 1;
                point f;
                f.x = a.x + search[i][0];
                f.y = a.y + search[i][1];
                q.push(f);//每找到一个界内的未访问的点，将其推入队列中
            }
    }
    for (i = 1; i <= n; i++) {
        for (j = 1; j < m; j++) {
            printf("%-5d", map[i][j]);//输出
        }
        printf("%d\n", map[i][j]);
    }
    return 0;
}

```

---


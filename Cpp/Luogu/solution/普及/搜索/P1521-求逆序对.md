# 求逆序对

## 题目描述

我们说$(i,j)$ 是 $a_1,a_2,\cdots,a_N$ 的一个逆序对，当且仅当 $i<j$ 且 $a_i>a_j$。例如 $[2,4,1,3,5]$ 的逆序对有 $3$ 个，分别为 $(1,3),(2, 3), (2, 4)$。现在已知 $N$ 和 $K$，求 $1,2,3,\cdots,N$ 的所有特定排列，使得这些排列的逆序对的数量恰好为 $K$。输出这些特定排列的数量。

例如 $N=5$，$K=3$ 的时候，满足条件的排列有 $15$ 个，它们是：


- $[1, 2, 5, 4, 3]$；    
- $[1, 3, 4, 5, 2]$；   
- $[1, 3, 5, 2, 4]$；   
- $[1, 4, 2, 5, 3]$；   
- $[1, 4, 3, 2, 5]$；   
- $[1, 5, 2, 3, 4]$；   
- $[2, 1, 4, 5, 3]$；   
- $[2, 1, 5, 3, 4]$；   
- $[2, 3, 1, 5, 4]$；   
- $[2, 3, 4, 1, 5]$；
- $[2, 4, 1, 3, 5]$；    
- $[3, 1, 2, 5, 4]$；   
- $[3, 1, 4, 2, 5]$；   
- $[3, 2, 1, 4, 5]$；   
- $[4, 1, 2, 3, 5]$。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $N \le 100$，$K \le N\times (N-1)/2$。

## 样例 #1

### 输入

```
5 3```

### 输出

```
15```

# 题解

## 作者：小周猪猪 (赞：86)

貌似这道题不需要求前缀和,滚动数组之类的优化吧...

其实这是一道递推（说的高级一点就是DP）

我们就设f[i][j]为前i个数字(即1-i)构成逆序对数为j的方案总数

这么怎么转移么......emmmm.....我们可以尝试着用递推的思路去推一下

假设当前枚举是这个二维数组的下标分别是i和j，又有那么可以知道，插入的数字是i，以及计算完了前i个数字的逆序对方案书，用(形象)的方式去表示，就是:
########（超形象的吧）

当插入的这个数字在这个这串数字的末尾时：就是：########i,此时这串数列的逆序对方案数就是前i-1的方案数，因为在末尾，和任何一个数都不构成逆序对，即f[i-1][j]

同理：当插入的位置为######i#时，i和后面的一个数字构成了一个逆序对，那么必然是f[i-1][j-1],即逆序对的个个数需要减去1，数字的个数不变.

同理，接下来便是：f[i-1][j-2],f[i-1][j-3],f[i-1][j-4]......

直到：i########,循环到第i-1次的时候，方案数是f[i-1][j-i-1]

因此，我们可以得到：
$$f[i][j]=sum(f[i-1][j-k])0≤k≤i-1$$

至于sum是什么玩意儿，也就是求和的嘛...

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int N,K;
int f[5000][5000];
int main()
{
	cin>>N>>K;
	f[1][0]=1;
	f[2][1]=1;
	f[2][0]=1;
	f[0][0]=1;
	for (int i=3;i<=N;i++)
		for (int j=0;j<=K;j++)
		    for (int k=0;k<=i-1&&j-k>=0;k++)
				f[i][j]=(f[i-1][j-k]+f[i][j])%10000;//记得取模
	cout<<f[N][K]<<endl;
	return 0; 
} 
```


---

## 作者：易极feng (赞：30)

楼上大神的题解与我的思路大致相同，建议先阅读他的题解。

在此提及其中最重要的优化。（而那位大神没有讲清楚）

上述第二个转移方程： f[i,j]=sum{f[i-1,j],f[i-1,j-1],f[i-1,j-2].....f[i-1,j-i+1]}

从而可得f[i][j-1]=sum{f[i-1][j-2],f[i-1][j-3]....f[i-1][j-i]}

可以发现f[i][j]=f[i-1][j]+f[i-1][j-1]-f[i-1][j-i]

转移时直接如此即可。

另外我使用了滚动，那就把核心代码贴出来吧。

```cpp
f[0][0]=1;
    for(i=1;i<=n;i++)
        for(j=0;j<=k;j++){
            if(j){
                if(j>=i)f[i&1][j]=(f[(i-1)&1][j]+f[i&1][j-1]-f[(i-1)&1][j-i])%mod;
                else f[i&1][j]=(f[(i-1)&1][j]+f[i&1][j-1])%mod;
            }
            else f[i&1][j]=f[(i-1)&1][j];
        }
```
**由于涉及到减法与取模，最后千万加上这一句。**

```cpp
f[n&1][k]=(f[n&1][k]%mod+mod)%mod; 
```

---

## 作者：grass8cow (赞：23)

~~小 学 奥 数 的 荣 耀~~

考虑 $f_{i,j}$ 为 $1$ 到 $i$ 所有全排列里逆序对数量为 $j$ 的情况数。我们能发现，从 $1$ 到 $i-1$ 的全排列里插入$i$，$i$是最大的数，所以排在它后面的数有多少个，新增的逆序对就有多少个。这个新增的值，最小是 $0$，此时的 $i$ 在最右边；最大是 $i-1$，此时的 $i$ 在最左边。所以就有 DP 转移方程：

$f_{i,j}=\sum_{k=max(0,j-(i-1))}^{j} f_{i-1,k}$

其中初始化 $f_{i,0}=1(1<=i<=n)$

part 1：

那么就可以得到以下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,mod=10000,f[101][5001],i,j,k;
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		f[i][0]=1;
		for(j=1;j<=min(i*(i-1)/2,m);j++)//j大于m的f[i][j]影响不到f[n][m]的值
		{
			for(k=max(0,j-i+1);k<=j;k++)//k小于0时数组会越界 
			{
				f[i][j]=(f[i][j]+f[i-1][k])%mod;//整个代码的核心 
			}
		 }
	}
	cout<<f[n][m];
	return 0;
}
```
空间复杂度：$O(N^3)$ 

时间复杂度：$O(N^4)$（最高用时：121ms）

然后我们就A了这道题。

part 2：

但这道题还有更优秀的做法。

考虑采用前缀和的思想，设：

$s_{i,j}=\sum_{k=0}^j f_{i,k}$

则能发现：

$s_{i-1,j}-s_{i-1,max(0,j-i)}=\sum_{k=max(0,j-(i-1))}^{j} f_{i-1,k}$

所以：

$f_{i,j}=s_{i-1,j}-s_{i-1,max(0,j-i)}$

于是，复杂度得到了优化。
```
#include<bits/stdc++.h>
using namespace std;
int n,m,mod=10000,f[101][5001],i,j,k,s[101][5001];
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		f[i][0]=1;s[i][0]=1;
		for(j=1;j<=min(i*(i-1)/2,m);j++)//j大于m的f[i][j]影响不到f[n][m]的值
		{
			s[i-1][j]=s[i-1][j-1]+f[i-1][j];
			f[i][j]=(s[i-1][j]-(j-i<0?0:s[i-1][j-i])+mod)%mod; 
		 }
	}
	cout<<f[n][m];
	return 0;
}
```
空间复杂度：$O(N^3)$ 

时间复杂度：$O(N^3)$（最高用时：9ms） （是不是快了很多？）

part 3:

变态教练让你只能开一维数组，怎么办？

没关系，我们可以采用滚动数组，也就是所谓刷表法。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,mod=10000,f[5001],i,j,k,s[5001];
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		f[0]=1;s[0]=1;//s属于上一行，f属于这一行 
		for(j=1;j<=min(i*(i-1)/2,m);j++)//j大于m的f[i][j]影响不到f[n][m]的值
		{
			s[j]=s[j-1]+f[j];//这里的s与f都是i-1行的值 
			f[j]=(s[j]-(j-i<0?0:s[j-i])+mod)%mod;//这时的f是这一行的值 
		 }
	}
	cout<<f[m];//相当于f[n][m]
	return 0;
}
```
空间复杂度：$O(N^2)$ 

时间复杂度：$O(N^3)$（最高用时：6ms）

小学奥数里的部分思想其实等同于 DP。

如有疑惑可在评论区留言，我会尽全力解答。

---

## 作者：望眼浮云 (赞：8)

~~双倍经验题！~~

这题不就是P2513的数据缩小版吗

这道题直接暴力就能过，但我还是当P2513讲吧。

首先设立状态：f[i][j] 表示i个数逆序对数量为j的个数

转移方程：f[i][j]=∑(s=0,1,...,i-1) f[i-1][j-s]

解释一下这个方程：当有i-1个数时，有j-1个逆序对时，添加第i个数，必有一个位置刚好使逆序对数+1，即可转移到f[i][j]。同理j-2,j-3……j-(i-1),因为只有i-1个数，所以最多到j-(i-1),当然也可能不增加逆序对，即j-0;

但是这样转移需要O(n)的复杂度，这是无法承受的（这题可以过，P2513不行）。

下面用到前缀优化：

转移状态是连续的，记sum[i][j]=f[i][0]+f[i][1]+……+f[i][j];

转移方程就变为：f[i][j]=sum[i-1][j]-(j>i?sum[i-1][j-i]:0)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[1005][1005],sum[10005]; //f[i][j] 表示i个数逆序对数量为j的个数，sum[i]记录前缀，这里优化了一下空间，减了一维
int main()
{
    scanf("%d%d",&n,&k);
    f[0][0]=1;  //初始状态
    for(int i=0;i<=k;i++) sum[i]=1;  //初始指为1
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=k;j++)
            if(j>=i) f[i][j]=(sum[j]-sum[j-i]+10000)%10000; //状态转移，要加10000再取模，不然可能小于0
            else f[i][j]=sum[j]%10000; 
        sum[0]=f[i][0]%10000;  
        for(int j=1;j<=k;j++)   
            sum[j]=(f[i][j]+sum[j-1])%10000; //更新sum，用于下一轮状态转移
    }
    printf("%d",f[n][k]);
}
```

---

## 作者：王奕瑜 (赞：6)

### 算法：递推$+$前缀和优化
------------
- 关于不优化的方法，某人已经说的很清楚了，那我就发一篇用前缀和优化的题解吧。
- 至于为什么要优化，因为不优化的时间复杂度为$O(nk^2)$，在本题勉强还行，但要是数据大一点（如[P2513](https://www.luogu.com.cn/problem/P2513)），那就必须要用前缀和优化了，时间复杂度为$O(nk)$。
- 同样的，我们要建立一个数组$f[i][j]$，表示$i$的全排列中，逆序对为$j$的个数。
- 显然，当$i$放在末尾时，方案数为$f[i-1][j]$,当$i$位于倒数第二的位置时，方案数为$f[i-1][j-1]$,$……$，当$i$放在最前面，方案数为$f[i-1][j-i+1]$，那么，我们就可以写出：
$$f[i][j]=\sum_{k=0}^{min(i-1,j)}f[i-1][j-k]$$
- 再将这和式子变简（$fu$）单（$za$）一点，可得：
$$f[i][j]=\sum_{k=max(j-i+1,0)}^jf[i-1][k]$$
- 那么我们就可以设一个变量$sum$,使得：
$$sum=\sum_{k=max(j-i+1,0)}^jf[i][k]$$
- 这样，我们每次只需要让$sum$加上$f[i-1][j]$，在使$f[i][j]=sum$即可。
- 以为就这样结束了？不可能的。我们再来看一下求$sum$的式子（~~其实是我想再玩一下$Markdown$~~）：
$$sum=\sum_{k=max(j-i+1,0)}^jf[i][k]$$
- 我们发现，当$j-i+1≥0$时，$sum$要开始往右移了，所以$sum$每次都要减去$f[i-1][j-i+1]$。
- $Markdown$玩完了，可以发代码了：
```cpp
#include <cstdio>
using namespace std;
void in(int &n){//快读
	n=0;int f=1;char c=getchar();
	while (c<'0'||'9'<c){if (c=='-')f*=-1;c=getchar();}
	while ('0'<=c&&c<='9'){n=n*10+(c-'0');c=getchar();}
	n*=f;
}
const int M=10000;
int f[1005][5005];//f[i][j]表示i的全排列中，逆序对为j的个数
int main(){
	int n,m;
	in(n);in(m);//读入
	f[1][0]=1;//初始化，1的全排列只有1种，且逆序对的数量为0
	for (int i=2;i<=n;i++){//注意从i=2开始
 		int sum=0;
		for (int j=0;j<=m;j++){
			sum=(sum+f[i-1][j])%M;f[i][j]=sum;//更新sum和f[i][j]
			if (j-i+1>=0)sum=(sum-f[i-1][j-i+1]+M)%M;
			//sum右移，注意取模后sum-f[i-1][j-i+1]可能为负数
		}
	}
	printf ("%d",f[n][m]);//输出
	return 0;
}

```

---

## 作者：凯特琳 (赞：4)

构造f[i,j]表示（1..i）的全排列中，逆序对为j个的排列共有几个

我们首先手动模拟打表一下

```cpp
f[1,0]=1    f[2,0]=1    f[3,0]=1    f[4,0]=1
                f[2,1]=1    f[3,1]=2    f[4,1]=3
                                f[3,2]=2    f[4,2]=5
                                f[3,3]=1    f[4,3]=6
                                                f[4,4]=5
                                                f[4,5]=3
                                                f[4,6]=1
```
表中有很多性质
比如：i的全排列中逆序对的个数是0..i\*(i-1)/2：其实这是因为i的全排列中总共有i\*(i-1)/2个数对，当这些数对全都是逆序对的时候，就得到了逆序对的最大值,

再比如：对于一个i，他的f[i,j]是关于f[i,i\*(i-1)/4]呈现中心对称的（f[4,2]和f[4,4]、f[4,1]和f[4,5]、f[4,0]和f[4,6]关于f[4,3]对称）：其实这是因为数对总数为i\*(i-1)/2,而一个数对要么是逆序对要么是顺序对，那么我们求i的全排列中逆序对个数有j个，

等价于求i的全排列中顺序对有i\*(i-1)/2-j个，显而易见，对于N的全排列   顺序对有K个这样的排列个数，和逆序对有K个这样的排列个数，是相等的于是我们有了f[i,j]=f[i, i\*(i-1)/2-j]于是对称中心就是f[i,i\*(i-1)/4]；

最后一个重要的性质也就是我们的DP状态转移方程就是：

if i>j then f[i,j]:=sum{f[i-1,0],f[i-1,1],f[i-1,2].....f[i-1,j]}

else f[i,j]:=sum{f[i-1,j],f[i-1,j-1],f[i-1,j-2].....f[i-1,j-i+1]}

当i>j的时候，我们枚举i的全排列的第一位的数字，如果是1，那么就要求剩下i-1个数中有j个全排列，如果是2，要求剩下i-1个数中有i-2个全排列，依次类推，得到了第一个方程

当i<=j的时候,由于i的全排列中最大的数字是i，所以把i放到第一位上，由第一位最多能能产生i-1个逆序对，把1放到第一位上能产生0个逆序对，所以i-1-1+1=i-1，这时的f[i,j]就要由f[i-1,j]开始算上他自己，总共i-1项的和。


AC代码：

```delphi

var f:array[1..100,-1..10000]of longint;
var i,j,n,k:longint;
begin
read(n,k);
fillchar(f,sizeof(f),0);
f[1,0]:=1;f[1,1]:=0;
f[2,0]:=1;f[2,1]:=1;//初始化
for i:=3 to n do
begin
for j:=0 to i*(i-1)div 4 do//从0计算到对称中心
if j<i then//第一种方式转移
f[i,j]:=(f[i,j-1]+f[i-1,j]) mod 10000//因为f[i,j]里面统计的是类似于前缀和的一个东西，f[i,j]只比f[i,j-1]多了f[i-1,j]这一项
else//第二种方式转移
f[i,j]:=(f[i,j-1]+f[i-1,j]-f[i-1,j-i])mod 10000;//这时求和的项数确定了，就是i-1项，于是f[i,j]比f[i,j-1]多了f[i-1,j]这一项，少了f[i-1,j-i]这一项
for j:=i*(i-1)div 4 +1 to i*(i-1) div 2 do//对称的把剩下的一半copy完
f[i,j]:=(f[i,i*(i-1)div 2 -j])mod 10000;//这里可以不用mod10000
end;
writeln((f[n,k]+10000)mod 10000);//防坑输出，因为有的时候，a、b都是正数，但是a mod b布吉岛怎么是负数了。详见P2267，这道题
end.//如果你得了40分，那么用这样一个防坑输出法，你会惊奇的发现你AC啦

```

---

## 作者：Schwarzkopf_Henkal (赞：3)

由于这道题中的序列只是1-n的全排列，所以对于动态规划的转移便变得十分方便。

我们发现，我们往已有的序列中添加一个数，这个数一定大于已有序列中的所有数，所以如果放在最后，逆序对数量增加了0，放在倒数第二的位置，逆序对增加了1，如果放在了最前面则逆序对数量增加原序列的长度。

所以我们简单地定义状态为长度为$i$的序列中，混乱度为$j$的序列个数。状态转移方程为：
$$dp[i][j]+=dp[i-1][j-k](0<=k<=i-1\&j-k>=0)$$
最简单的版本很好想，这里不再放出代码，然后我们学习将原本$O(n^2m)$复杂度的算法利用前缀和加速成$O(nm)$。

很显然的，状态转移方程需要的状态是一个连续的段，所以我们开一个数组保存前缀和并在需要的时候调用即可。代码如下：

```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
long long dp[2][5005],pre[2][5005],n,c;//滚动数组储存状态和前缀和。
bool p;
int main(){
    std::cin>>n>>c;
    dp[1][1]=1;//显然的，长度为1逆序对为0的个数为1。
    for(int j=1;j<=c+1;j++)
        pre[1][j]=1;//初始化
    for(int i=2;i<=n;i++){
        for(int j=1;j<=c+1;j++){ //为方便前缀和，我把逆序对数量都往上加了1
            dp[p][j]=(pre[!p][j]-pre[!p][max(j-i,0)]+10000)%10000;//调用前缀和
            pre[p][j]=(pre[p][j-1]+dp[p][j]+10000)%10000;//防止玄学模运算出现玄学错误。
        }//记录前缀和
        p=!p;
    }
    std::cout<<dp[!p][c+1];
}
```


---

## 作者：JasonZRY (赞：2)

这是道dp

方程很容易得出：f[i][j]=f[i-1][j-i+1]+f[i-1][j-i+2]+……+f[i-1][j]

时间复杂度：O(n^3)

但可以优化为O(n^2)

因为f[i][j]=f[i-1][j-i+1]+f[i-1][j-i+2]+……+f[i-1][j]

f[i][j-1]=f[i-1][j-i]+f[i-1][j-i+1]+f[i-][j-i+2]+……+f[i-1][j-1]

这两个式子有许多重复项

所以可以合并为f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-i]

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,k,dp[105],f[105][5000];
int main(){
    cin>>n>>k;
	f[0][0]=f[1][0]=1;
    for(int i=2;i<=n;i++){
        dp[i]=dp[i-1]+i-1;
        for(int j=0;j<=dp[i];j++){
            f[i-1][j]%=10000;
            if(j<=dp[i]/2){
                f[i][j]=f[i-1][j]+f[i][j-1];
                if(j>=i)f[i][j]-=f[i-1][j-i];
            }
            else f[i][j]=f[i][dp[i]-j];
        }
    }
    cout<<f[n][k]%10000;
    return 0;
}
```


---

## 作者：greenheadstrange (赞：2)

由于只求方案数，且 **N≤100** 所以不、很容易想到DP

定义f[i][j]为1到i的排列中逆序对为j个的数量。

该怎么转移呢？

在任意一个1到i-1排列中插入i可能产生0，1，2……i-1个逆序对。

![](https://cdn.luogu.com.cn/upload/pic/62754.png)

这样的复杂度是 O(N^2*M)

注意到转移枚举的那一维可以用前缀和加速，复杂度便降为O(NM)

但是前缀和为MLE，所以用滚动数组来优化。

下面是本蒟蒻的代码：

```cpp

#include<bits/stdc++.h>
#define mod 10000
using namespace std;
int n,m;
int f[105][100005],sum[1000005];
int main(){
//	freopen("count.in","r",stdin);
//	freopen("count.out","w",stdout);
	scanf("%d%d",&n,&m);
	f[0][0]=1;
	for(int i=1;i<=n;i++){
		sum[0]=f[i-1][0];
		for(int j=1;j<=m;j++)sum[j]=(sum[j-1]+f[i-1][j])%mod;
		for(int j=0;j<=m;j++)
			if(j>=i)f[i][j]=(f[i][j]+sum[j]-sum[j-i]+mod)%mod;
			else f[i][j]=sum[j];
	}
//	for(int i=1;i<=n;i++){
//		for(int j=0;j<=m;j++)cout<<f[i][j]<<" ";
//		cout<<"\n";
//	}		
	printf("%d",f[n][m]);
	return 0;
}

```
在这里提醒大家一下：

在DP的时候一定不要让数组越界，同时由于负数，取余时要加mod（本蒟蒻就是因为这个而，所以这道题0分，没有AK这次考试）

```cpp

if(j>=i)f[i][j]=(f[i][j]+sum[j]-sum[j-i]+mod)%mod;

```


---

## 作者：Vocanda (赞：1)

## 分析

首先我们先分析最简单的情况：

1、如果$n$个数都是正序排列，那么肯定是没有逆序的情况的。

2、如果$n$个数全部都是逆序排列，那么每个数都比后边的数大，也就是逆序。那么很容易就能知道这种情况下一共有$1+2+3+……+n-1$种。

根据以上两个基础情况，我们就可以推出来动规状态转移方程：

我们定义$f[i][j]$数组表示前$i$个数组成的序列，共有$j$个逆序对的情况数，那么根据上边的情况，首先是一号方程：

$$f[i][j] = f[i-1][j]+f[i-1][j-1]+...+f[i-1][j-i+1]$$
这里表示的是前$i$个数组成的有$j$个逆序对的情况就是前$i-1$个数的所有可能的情况求和。因为现在$i$是最大的数，所以我们把$i$放到$1\to i-1$的序列中，可以让$i$的位置改变从而增加$0\to i-1$对逆序对，那么一号方程就求出来了。

然后是二号方程：
$$f[i][j-1] = f[i-1][j-1]+f[i-1][j-2]+...+f[i-1][j-i]$$
其含义与一号方程一样，就是逆序对个数减少了一个，我们把一号和二号方程合并，就能够得出来总的方程：
$$f[i][j] = f[i-1][j]+f[i][j-1]-f[i-1][j-i]$$
这就是状态转移方程。

唯一需要注意的一点就是：因为状态转移方程最后需要减去一个$f[i-1][j-i]$，所以必须保证$i\le j$避免出现负数下标，同时在循环的过程中，我们应该记录前$i$个数总的方案数，假如逆序对个数$j$比他大，那么就直接跳出当前的循环，也算一种时间效率的优化吧。

## 代码
```cpp


#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e2+10;
int f[maxn][maxn*maxn];
int sum,n,k;
const int Mod = 10000;
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i){
		f[i][0] = 1;//初始化正序时没有逆序对的情况数为1
	}
	for(int i=1;i<=n;++i){
		sum+=i-1;//前i个数u最大逆序对数
		for(int j=1;j<=k;++j){
			if(j>sum)break;//当前逆序对比最大情况还要大就跳出循环
			f[i][j] = (f[i-1][j]+f[i][j-1])%Mod;
			if(j>=i)
				f[i][j] = (f[i][j]-f[i-1][j-i]+Mod)%Mod;//记得边加边取模
		}
	}
	printf("%d",f[n][k]);
	return 0;
}

```

---


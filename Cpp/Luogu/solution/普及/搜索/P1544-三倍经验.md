# 三倍经验

## 题目描述

数字金字塔由 $n$ 行整数组成，第 $i(1\le i\le n)$ 行有 $i$ 个数字，一个示例如下。  
```text
        7
      3   9
    8   1   0
  2   7   4   4 
4   5   2   6   5
```  
现在你在金字塔的顶部（第一行），你希望走到金字塔的底部（第 $n$ 行），每一步你只能走向当前所在位置的左下方的数字或者右下方的数字。同时作为一个强大的小朋友，你可以选择金字塔中的不多于 $k$ 个数字让他们成为原来的 $3$ 倍。  

你会收集你路上经过的所有位置上的数字，最后的得分即为收集的数字之和，求最大得分。

## 说明/提示

对于 $30\%$ 的数据，满足 $k\le n\le 6$，并且对于任意 $1\le i\le n$，$1\le j\le i$ 满足 $0\le a_{i,j}\le 100$；  
对于 $100\%$ 的数据，满足 $1\le n\le100$，$0\le k\le \dfrac{n(n+1)}{2}$，且对于任意 $1\le i\le n$，$1\le j\le i$ 满足 $|a_{i,j}|\le 10^9$。

## 样例 #1

### 输入

```
5 3
7
3 9
8 1 0
2 7 4 4
4 5 2 6 5```

### 输出

```
75```

# 题解

## 作者：Wind_Smiled (赞：28)

## 题意
给定一个 $n$ 阶的数字金字塔，可以使 $k$ 个数变为原来的三倍。每次移动可以到达左下或右下的点，求路径最大的总值。

### 分析
显然是一个记忆化搜索。由于在 $k$ 次修改下的值的更改，`dp` 要用三维。第三维记录修改 $p$ 次。

数据范围：$|a_{i,j}| \le 10^{9}$。对于乘三的操作结束之后累加必定会爆 `int`，所以要开 `long long`。共有 $n$ 层，故最多有 $\min(n,k)$ 次有效操作。数组类型和大小确定。

~~由于我比较废，所以在给了初始化之后还建了一个访问数组，实际上可以改掉的。~~

对于每一个点的查询，有两种情况：

1.次数未用尽，可以继续修改；

2.次数已用尽，不可继续修改。

故分类讨论两种情况，对于每种情况取最大值，可以遍历每一种情况。

对于 1：

在本次修改扩大三倍，对左下、右下进行搜索。

对于 2：

在本次修改中不进行更改，对左下、右下进行搜索。

由于修改过后可能会存在下面修改更优的情况，将情况 2 置于情况 1 下方再次取一遍最大值即可，以表述当前位置保留操作次数不进行修改的情况。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
long long a[105][105];
long long f[105][105][105];//记忆化搜索数组 
bool v[105][105][105];//访问数组 
long long ans;
long long dfs(int i,int j,int p){
    if(i<0||i>n||j<0||j>n){//越界 
    	return 0;
	}
	if(v[i][j][p]){//查询过 
		return f[i][j][p];
	}
    else{
    	if(p!=k){//可继续修改 
    		f[i][j][p]=max(f[i][j][p],dfs(i+1,j,p+1)+a[i][j]*3);//修改至三倍 
    		f[i][j][p]=max(f[i][j][p],dfs(i+1,j+1,p+1)+a[i][j]*3);
		}
    	f[i][j][p]=max(f[i][j][p],dfs(i+1,j,p)+a[i][j]);//重新归类 
    	f[i][j][p]=max(f[i][j][p],dfs(i+1,j+1,p)+a[i][j]);
    	v[i][j][p]=1;//标记访问 
		return f[i][j][p];
    }
}
int main(){
	scanf("%d%d",&n,&k);
	if(k>n){//有效操作次数下调 
		k=n;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			scanf("%lld",&a[i][j]);
		}
	}
	memset(f,-0x3f,sizeof(f));//初始化避免记忆化过程中修改取最大值时遇到比原数大的情况 
	ans=dfs(1,1,0);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：QianRan_GG (赞：16)

题意已经很清楚了，不再赘述。

## 解题思路

先不考虑乘三倍的情况。  
将金字塔中每一个数看作一个点。  

我们用 $dp_{i,j}$ 来表示走到第 $i$ 行第 $j$ 个点时走过的最大得分。  
因为点（$i,j$）是从点（$i - 1, j$）和点（$i - 1,j - 1$）走来，所以易得状态转移方程式：

$$
dp_{i,j} = \max(dp_{i - 1,j}, dp_{i - 1, j - 1}) + a_{i, j}
$$

然后考虑乘三倍的情况。  
用 $dp_{i,j,l}$ 来表示走到第 $i$ 行第 $j$ 个点，乘 $l$ 次三倍时走过的最大得分。
结合不考虑乘三倍情况的状态转移方程式，易得最终状态转移方程式：

$$
dp_{i, j, l} = 
\begin{cases}
	dp_{i, j, l} = \max(dp_{i - 1, j, l}, dp_{i - 1, j - 1, l}) + a_{i, j}, (l = 0) \\
    dp_{i, j, l} = \max(dp_{i, j ,l}, dp_{i - 1, j, l - 1} + a_{i, j} \times 3, dp_{i - 1, j - 1, l - 1} + a_{i, j} \times 3), \text{Otherwise.}
\end{cases}
$$
以上是代码核心部分。
在搜索时要记得套两层循环（$j$ 和 $k$），应为存在负数，所以不是乘三倍的次数越多越好。
```cpp
k = min(k, n); // 不然可能导致没搜到k次，值为-3e9的情况。 
for(int j = 1; j <= n; ++ j)
	for(int l = 0; l <= k; ++ l)
		maxm = max(maxm, dp[n][j][l]); 
cout << maxm;
```

最后要记得在开始时把数组初始化。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 105; 
int n, k;
ll a[N][N], dp[N][N][5505], maxm = -3e9;
signed main()
{
	//输入 
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> k;
	//初始化 
	for(int i = 1; i <= n; ++ i)
		for(int j = 0; j <= n; ++ j)
			for(int l = 0; l <= k; ++ l)
				dp[i][j][l] = -3e9; //a[i][j]最小是-1e9，还要乘3，所以设为-3e9(记得开long long）。 
	//边输入边做dp 
	for(int i = 1; i <= n; ++ i)
		for(int j = 1; j <= i; ++ j)
		{
			cin >> a[i][j];
			for(int l = 0; l <= k && l <= i; ++ l)
			{
				if(l == 0)
					dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
				else
				{
					dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
					dp[i][j][l] = max(dp[i][j][l], max(dp[i - 1][j][l - 1], dp[i - 1][j - 1][l - 1]) + a[i][j] * 3);
				}
			}
		}
	k = min(k, n); // 不然可能导致没搜到k次，值为-3e9的情况。
	//搜索答案 
	for(int j = 1; j <= n; ++ j)
		for(int l = 0; l <= k; ++ l)
			maxm = max(maxm, dp[n][j][l]);
	//输出 
	cout << maxm;
	return 0;
}
```


---

## 作者：FQR_ (赞：11)

[题目传送门](/problem/P1544)

## 题目大意

与[P1216 数字三角形](/problem/P1216)相似，但是本题可以选择不超过 $k$ 个数，使它们的值变成原来的 $3$ 倍。

## 思路

从顶部走到底部，会经过 $n$ 个点。当 $k>n$ 时，我们只需要修改路径上的 $n$ 个点即可。因此当 $k>n$ 时，我们可以把 $k$ 的值变为 $n$。这样，我们就可以使 $n,k$ 同阶。

假设有 $k+1$ 层相同的数字三角形，编号为 $0\sim k$。从第 $0$ 层数字三角形的顶部开始走。在一个点上，我们可以走到与它同层，且在它左下方或右下方的点。如果这个点不在最底层，我们还可以走向它的下一层，且在它左下方或右下方的点。

向下走一层，可以视为将走到的点所对应的值变成原来的 $3$ 倍，即使用了一次修改的机会。有 $k+1$ 层数字三角形，显然走了不超过 $k$ 层。这样就可以满足题目中"选择不超过 $k$ 个数，使它们的值变成原来的 $3$ 倍"的条件。

容易发现，第 $p$ 层的点，用了 $p$ 次修改机会。

考虑如何推出状态转移方程。

我们用 $f_{i,j,p}$ 表示走到 $(i,j,p)$（第 $p$ 层，第 $i$ 行，第 $j$ 列）的最大得分。

如果现在走到了点 $(i,j,p)$，那么我们可以：

* 不走向下一层：走到 $(i+1,j,p)$ 或 $(i+1,j+1,p)$。
* 向下走一层：走到 $(i+1,j,p+1)$ 或 $(i+1,j+1,p+1)$。

如果不走向下一层，我们就加上到达的点所对应的值。否则加上到达的点所对应的值的 $3$ 倍。

即可得到转移方程：

```cpp
f[i+1][j][p]=max(f[i+1][j][p],f[i][j][p]+a[i+1][j]);
f[i+1][j+1][p]=max(f[i+1][j+1][p],f[i][j][p]+a[i+1][j+1]);
f[i+1][j][p+1]=max(f[i+1][j][p+1],f[i][j][p]+a[i+1][j]*3);
f[i+1][j+1][p+1]=max(f[i+1][j+1][p+1],f[i][j][p]+a[i+1][j+1]*3);
```

最后，我们取走到每一层的底部得分的最大值即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n' 
#define ll long long
const ll inf=1e18;
ll f[110][110][110];
ll a[110][110];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int n,k;
    cin>>n>>k;
    if(k>n) k=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++) cin>>a[i][j];
    for(int i=1;i<=n;i++)
     for(int j=1;j<=i;j++)
      for(int p=0;p<=k;p++)
       f[i][j][p]=-inf;//将所有点初始值设为无穷小
       
    f[1][1][0]=a[1][1];//走到(1,1)处用了0次乘三的机会，即(1,1)没变成三倍
    f[1][1][1]=a[1][1]*3;//走到(1,1)处用了1次乘三的机会，即(1,1)变成了三倍

    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            for(int p=0;p<=k;p++)//遍历 k+1 层的每一个点
            {
                f[i+1][j][p]=max(f[i+1][j][p],f[i][j][p]+a[i+1][j]);
                f[i+1][j+1][p]=max(f[i+1][j+1][p],f[i][j][p]+a[i+1][j+1]);
                f[i+1][j][p+1]=max(f[i+1][j][p+1],f[i][j][p]+a[i+1][j]*3);
                f[i+1][j+1][p+1]=max(f[i+1][j+1][p+1],f[i][j][p]+a[i+1][j+1]*3);
            }
    ll ans=-inf;
    for(int i=1;i<=n;i++) for(int p=0;p<=k;p++) ans=max(ans,f[n][i][p]);//取每一层底部的最大值
    cout<<ans;

    return 0; 
}
```

---

## 作者：xiaoxiaoxia (赞：6)

# Part 1 题目思路
这道题跟数字三角形比较类似，只是可以选一部分点获得三倍经验，根据无后效性，很明显用动态规划来做。那这道题二维的状态一定无法很好的转移，我们就可以加一维表示第 $i$ 行第 $j$ 列用 $l$ 次操作的最大得数。

那么我们可以得到可以从四个方向转移过来

- 从该位置的的左上方走过来且左上方的数不乘 $3$。
- 从该位置的的左上方走过来且左上方的数乘 $3$。
- 从该位置的的右上方走过来且左上方的数不乘 $3$。
- 从该位置的的右上方走过来且左上方的数乘 $3$。 

可以将动态转移方程化简成如下的求和形式：

$$
\begin{aligned}
f_{i-1,j-1,k} &= \max\left(\sum_{s=0}^{k} f_{i,j,s}+a_{i-1,j-1},\sum_{s=0}^{k-1} f_{i,j,s}+a_{i-1,j-1}\times 3 \right) \\
f_{i-1,j,k} &= \max\left(\sum_{s=0}^{k} f_{i,j,s}+a_{i-1,j},\sum_{s=0}^{k-1} f_{i,j,s}+a_{i-1,j}\times 3 \right)
\end{aligned}
$$

# Part 2 代码部分
```cpp
#include<bits/stdc++.h>
#define MAXN 110
using namespace std;
int n,m;
long long f[MAXN][MAXN][MAXN],a[MAXN][MAXN],ans=-0x3f3f3f3f;
int main()
{
	memset(f,-0x3f3f3f3f,sizeof(f));//初始化 
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		f[n][i][0]=a[n][i];
		f[n][i][1]=a[n][i]*3;
	}
	for(int i=n;i>=2;i--)
	{
		for(int j=1;j<=i;j++)
		{
			for(int k=0;k<=n-i+2 and k<=m;k++)//转移方程 
			{
				f[i-1][j-1][k]=max(f[i-1][j-1][k],f[i][j][k]+a[i-1][j-1]);
				f[i-1][j-1][k+1]=max(f[i-1][j-1][k+1],f[i][j][k]+a[i-1][j-1]*3);
				f[i-1][j][k]=max(f[i-1][j][k],f[i][j][k]+a[i-1][j]);
				f[i-1][j][k+1]=max(f[i-1][j][k+1],f[i][j][k]+a[i-1][j]*3);
			}
		}
	}
	for(int i=0;i<=min(n,m);i++)
	{
		ans=max(f[1][1][i],ans);//求答案 
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：sto_5k_orz (赞：4)

在做此题之前，建议先 AC 了 [P1216](https://www.luogu.com.cn/problem/P1216)。

考虑在 P1216 的基础上再开一维 $k$，空间 $O(n^2\times k)$，512 MB 还是可行的。

$dp_{i,j,k}$ 表示当前走到 $(i,j)$，用了 $k$ 次三倍经验的最大收益。

那么只需要讨论在 $(i,j)$ 要不要用三倍经验即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 105; int dp[N][N][N * N / 2], a[N][N]; int n, k;
signed main() {
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= i; j++)
            cin >> a[i][j];
    memset(dp, -0x3f, sizeof dp);
    dp[1][1][0] = a[1][1]; dp[1][1][1] = a[1][1] * 3;
    for(int i = 2; i <= n; i++)
        for(int j = 1; j <= i; j++) {
            for(int l = 0; l <= min(k, i); l++)
                dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
            for(int l = 1; l <= min(k, i); l++)
                dp[i][j][l] = max(dp[i][j][l], max(dp[i - 1][j][l - 1], dp[i - 1][j - 1][l - 1]) + a[i][j] * 3);
        }
    int ans = -1e18;
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= k; j++)
            ans = max(ans, dp[n][i][j]);
    cout << ans;
    return 0;
}
```

（以下时间空间均为最大的数据点）

时效：139ms，空间 465.00MB

真大，虽然 AC 了。

考虑如何优化。

显然使用三倍经验的次数 $\leq n$，所以可以只枚举 $n$ 次。

最坏复杂度 $O(n^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 105; int dp[N][N][N], a[N][N]; int n, k;
signed main() {
    ios::sync_with_stdio(0);
    cin >> n >> k; k = min(k, n);
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= i; j++)
            cin >> a[i][j];
    memset(dp, -0x3f, sizeof dp);
    dp[1][1][0] = a[1][1]; dp[1][1][1] = a[1][1] * 3;
    for(int i = 2; i <= n; i++)
        for(int j = 1; j <= i; j++) {
            for(int l = 0; l <= min(k, i); l++)
                dp[i][j][l] = max(dp[i - 1][j][l], dp[i - 1][j - 1][l]) + a[i][j];
            for(int l = 1; l <= min(k, i); l++)
                dp[i][j][l] = max(dp[i][j][l], max(dp[i - 1][j][l - 1], dp[i - 1][j - 1][l - 1]) + a[i][j] * 3);
        }
    int ans = -1e18;
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= k; j++)
            ans = max(ans, dp[n][i][j]);
    cout << ans;
    return 0;
}
```

时效：9ms 空间：9.36MB

非常快，直接进最优解第一页第八名。

---

## 作者：wdgm4 (赞：4)

我是从底部往上搜的。

## 思路

由于我们可以走向当前所在位置的左下方的数字或者右下方的数字，那么考虑一个不在顶部的位置可以从哪几个位置走过来，~~显然~~可以从当前所在位置的的左上方或者右上方走过来。

考虑完上面的，然后思考如何用 `dp` 做。

这道题用二维 `dp` 肯定是无法解决的，那我们就可以加一维,$dp_{i,j,l}$ 表示第 $i$ 行第 $j$ 列用 $l$ 次操作的最大得数。

那么可以分四种情况：

1. 从该位置的的左上方走过来且左上方的数不乘 $3$。

2. 从该位置的的左上方走过来且左上方的数乘 $3$。

3. 从该位置的的右上方走过来且左上方的数不乘 $3$。

4. 从该位置的的右上方走过来且左上方的数乘 $3$。

在代码中就是：

```cpp
f[i-1][j-1][k]=max(f[i-1][j-1][k],f[i][j][k]+a[i-1][j-1]);
f[i-1][j-1][k+1]=max(f[i-1][j-1][k+1],f[i][j][k]+a[i-1][j-1]*3);
f[i-1][j][k]=max(f[i-1][j][k],f[i][j][k]+a[i-1][j]);
f[i-1][j][k+1]=max(f[i-1][j][k+1],f[i][j][k]+a[i-1][j]*3);
```

由于 $a_{i,j}$ 的值可能是负数，需要给 `f` 数组初始化成一个十分小的负数即可。

## code

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define MAXN 110
using namespace std;
int n,m;
long long f[MAXN][MAXN][MAXN],a[MAXN][MAXN],ans=-0x3f3f3f3f;
int main(){
	memset(f,-0x3f3f3f3f,sizeof(f));
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		f[n][i][0]=a[n][i];
		f[n][i][1]=a[n][i]*3;
	}
	for(int i=n;i>=2;i--){
		for(int j=1;j<=i;j++){
			for(int k=0;k<=n-i+2 and k<=m;k++){
				f[i-1][j-1][k]=max(f[i-1][j-1][k],f[i][j][k]+a[i-1][j-1]);
				f[i-1][j-1][k+1]=max(f[i-1][j-1][k+1],f[i][j][k]+a[i-1][j-1]*3);
				f[i-1][j][k]=max(f[i-1][j][k],f[i][j][k]+a[i-1][j]);
				f[i-1][j][k+1]=max(f[i-1][j][k+1],f[i][j][k]+a[i-1][j]*3);
			}
		}
	}
	for(int i=0;i<=min(n,m);i++){
		ans=max(f[1][1][i],ans);
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：Elairin176 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P1544)        
这题的题解只有一个，唯一的一个居然还是 dp。      
所以来一发记忆化搜索题解。        
首先，普通的 dfs 很容易写，我们遍历以下几个值：$x,y,l$。它表示在 $(x,y)$ 这个点已经用了 $l$ 次“三倍经验”。        
这样，我们每次递归分类讨论，将 $l=k$ 的分一类，反过来再分一类即可。         
直接对 $x,y,l$ 进行记忆化就可以，用 $dp_{x,y,l}$ 表示每次的最大值。          
但是，我们发现，在 $100\%$ 的数据中，$\left|a_i\right|\le10^9$。      
所以，要开 long long，但是 $n\times n\times \frac{n\times(n-1)}{2}$ 的空间一定会 MLE。     
我们考虑到，在一个金字塔上每步一定都会往下一层，所以如果在全部路径上使用“三倍经验”也只是使用了 $n$ 次。       
所以，我们无需将 $l$ 的范围定义到 $[0,\frac{n\times(n-1)}{2}]$ 中，只需为 $[0,n]$ 即可。      
这样，代码就很好想了。    
[CODE](https://www.luogu.com.cn/paste/2cnzfhip)

---

## 作者：Genius_Star (赞：1)

### 坑点：

要开 long long 啊~

要在 DP 的时候赋值为极小值啊~

要在统计 $\max$ 的变量里赋值为极小值啊~

（坑点数据：$|a_{i,j}|\le 10^9$，$a_{i,j}$ 是有可能为负数的~）
### 题意描述：
给出一个数字三角形，你需要从三角形的顶部走到底部，一步只能走左下方或者右下方，你可以将其中不超过 $k$ 个数字变为原来的 $3$ 倍，求收集的最大数字之和。（题意不要理解错了哈，每一个数字只能操作一次）
### 旧题回顾：
[P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)

还记得上述的题目吗？~~这一定是你们初学动态规划时做的题目~~

这题很容易看出来，我们可以设 $dp_{i,j}$ 表示走到 $i$ 行第 $j$ 个数字时，可以得到的最大数字和。

那么可以推出 $dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-1})+a_{i,j}$，其中 $a$ 表示存数字三角形的数组。

### 数字三角形代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,a[N][N],dp[N][N],ans=0;
int main(){
	memset(dp,0,sizeof(dp));
	cin>>n;
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=i;j++)
	    cin>>a[i][j];
	dp[1][1]=a[1][1];
	for(int i=2;i<=n;i++)
	  for(int j=1;j<=(n-(n-i));j++)
		dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+a[i][j],(i==n?ans=max(ans,dp[i][j]):ans=0);
	cout<<ans<<'\n';
	return 0;
}
```
### 该题思路：
对于该题，多了一个条件，就是可以将其中最多 $k$ 个数变为原来的三倍，如果按照原来的思路，可以在“数字三角形”中的最大数字和的数字路径中，选择其中最大的 $k$ 个数变为原来的三倍，是不是可行了~

答案自然是 No！

这样不一定是最优解，我举一个例子，如以下的数字三角形：
```cpp
5
1 8
9 1 3
```
如果按照原来的递推式，我们走过的是 $5 \to 8 \to 3$，这样答案是 $16$，如果 $k=1$ 的话，我们肯定将 $8$ 扩大三倍，得出 $5+8 \times 3 +3=32$，但是我们有着更好的路径。

我们可以走 $5 \to 1 \to 9$，这样不扩大的话答案只有 $15$，但是我们可以将答案扩大三倍，那么就是 $5+1+9\times3=33$，这样的话是比 $32$ 大的，所以原来的思路是错误的。

现在我们要重新思考新的思路！

因为这题如果用二维的话有些不好表示（~~其实可以滚动一下数组的~~），所以我们再加上一维，$dp_{i,j,s}$ 表示在数字三角形第 $i$ 行第 $j$ 个数时进行了 $t$ 次三倍操作的最大数字和。

很明显，我们可以发现这个状态可以由 $4$ 个其他的状态转移过来：

1. 从上方走过来乘了三倍。

2. 从上方走过来不乘三倍。

3. 从右上方走过来乘了三倍。

4. 从右上方走过来不乘三倍。

那么我们可以枚举 $t$，这样的时间复杂度为 $O(n^2k)$。

然后就是我们进行 $dp$ 数组的初始化，因为每一个数字只能操作一次。

所以我们已知的是：

$dp_{n,i,0}=a_{n,i},dp_{n,i,1}=a_{n,i} \times 3(i \le n)$。

这样就可以得到状态转移方程：

$dp_{i-1,j-1,t}=\max(dp_{i-1,j-1,t},dp_{i,j,t}+a_{i-1,j-1})$。

$dp_{i-1,j-1,t+1}=\max(dp_{i-1,j-1,t+1},dp_{i,j,t}+a_{i-1,j-1} \times 3)$。

$dp_{i-1,j,t}=\max(dp_{i-1,j,t},dp_{i,j,t}+a_{i-1,j})$。

$dp_{i-1,j,t+1}=\max(dp_{i-1,j,t+1},dp_{i,j,t}+a_{i-1,j} \times 3)$。

这样这题我们就算是解决了。
### 解决代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
const int N=105,M=5060;
ll n,a[N][N],dp[N][N][M],k,ans=LONG_LONG_MIN;
int main(){
	memset(dp,-127,sizeof(dp));
	n=read(),k=read();
	for(ll i=1;i<=n;i++)
	  for(ll j=1;j<=i;j++)
	    a[i][j]=read();
	for(ll i=1;i<=n;i++){
		dp[n][i][0]=a[n][i];
		dp[n][i][1]=a[n][i]*3;
	}
	for(ll i=n;i>=2;i--){
		for(ll j=1;j<=n;j++){
			for(ll t=0;t<=(n-i+2)&&t<=k;t++){
				dp[i-1][j-1][t]=max(dp[i-1][j-1][t],dp[i][j][t]+a[i-1][j-1]);
				dp[i-1][j-1][t+1]=max(dp[i-1][j-1][t+1],dp[i][j][t]+a[i-1][j-1]*3);
				dp[i-1][j][t]=max(dp[i-1][j][t],dp[i][j][t]+a[i-1][j]);
				dp[i-1][j][t+1]=max(dp[i-1][j][t+1],dp[i][j][t]+a[i-1][j]*3);
			}
		}
	}
	for(ll i=0;i<=min(n,k);i++)
	  ans=max(ans,dp[1][1][i]);
	write(ans);
	putchar('\n');
	return 0;
}
```
额，建议大家自己推一遍吧，禁止抄袭……

---

## 作者：ccg12345 (赞：1)

## 思路
看到这道题的时候我是联想到了不久前做的一道题：[P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)，区别是这道题可以选择一些点，并获得三倍经验，由此联想到用动态规划。

Q：如何在不联想其他题的情况下想到动态规划？

A：可以先逆推试一试，然后发现一个很重要的特点：**无后效性**，由此想到动态规划。

## 具体实现方式

首先我们记 $f_{i, j, k}$ 为走到 $(i, j, k)$ 的最大得分。

先考虑更简单的题目：即不考虑乘三倍的情况，那么每一个点都由其左上与右上走下来，故得到状态转移方程：
$$ dp_{i, j} = max(dp_{i - 1, j}, dp_{i - 1, j - 1}) + a_{i, j} $$

再去考虑乘三倍的情况：

只能是从四个方向转移过来。

1. 从该位置的的左上方走过来且左上方的数不乘 $3$。

2. 从该位置的的右上方走过来且左上方的数不乘 $3$。

3. 从该位置的的左上方走过来且左上方的数乘 $3$。

4. 从该位置的的右上方走过来且左上方的数乘 $3$。

那么就可以得到状态转移方程：

$$ dp_{i - 1, j, k} = max(dp_{i - 1, j, k}, dp_{i, j, k} + a_{i - 1, j}) $$

$$ dp_{i - 1, j - 1, k} = max(dp_{i - 1, j - 1, k}, dp_{i, j, k} + a_{i - 1, j - 1}) $$

$$ dp_{i - 1, j, k + 1} = max(dp_{i - 1, j, k + 1}, dp_{i, j, k} + a_{i - 1, j} \times 3) $$

$$ dp_{i - 1, j - 1, k + 1} = max(dp_{i - 1, j - 1, k + 1}, dp_{i, j, k} + a_{i - 1, j - 1} \times 3) $$

得出了动态方程，代码自然不在话下。

写完后便信心满满地提交上去。

咦，$40pts$？

~~十年 OI 一场空，不开 `long long` 见祖宗。~~

附代码：

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, a[105][105], dp[105][105][105], ans;
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
        x = x * 10 + ch - '0', ch = getchar();
    return x*f;
}
signed main() 
{
    memset(dp, -0x3f, sizeof(dp));//先将每个值都赋一个极小值
    n = read(), m = read();
    for(register int i = 1; i <= n; i++)
		for(register int j = 1; j <= i; j++)
			a[i][j] = read();
    for(register int i = 1; i <= n; i++)
	{
		dp[n][i][0] = a[n][i];
		dp[n][i][1] = a[n][i] * 3;
	}
    for(register int i = n; i >= 2; i--)
		for(register int j = 1; j <= i; j++)
			for(register int k = 0; i + k - 2 <= n && k <= m; k++)
			{
				dp[i - 1][j][k] = max(dp[i - 1][j][k], dp[i][j][k] + a[i - 1][j]);
				dp[i - 1][j - 1][k] = max(dp[i - 1][j - 1][k], dp[i][j][k] + a[i - 1][j - 1]);
				dp[i - 1][j][k + 1] = max(dp[i - 1][j][k + 1], dp[i][j][k] + a[i - 1][j] * 3);
				dp[i - 1][j - 1][k + 1] = max(dp[i - 1][j - 1][k + 1], dp[i][j][k] + a[i - 1][j - 1] * 3);
			}
    for (int i = 0; i <= min(n, m); i++)//有效操作次数最多只有min(n, m)
		ans = max(dp[1][1][i], ans);
    printf("%lld\n", ans); 
    return 0;
}
```


---

## 作者：CSPJ10pts (赞：1)

相似铺垫题目：[数字三角形](https://www.luogu.com.cn/problem/P1216)

建议大家先做上面那题，因为此题相当于上面一题的加强版。

## 题意

数字金字塔由 $n$ 行整数组成，第 $i$ 行有 $i$ 个数字。现在你在金字塔的第一行，你希望走到金字塔的第 $n$ 行，每一步你只能走向当前所在位置的左下方的数字或者右下方的数字。同时，你可以选择金字塔中的不多于 $K$ 个数让他们成为原来的 $3$ 倍。你会收集你路上经过的所有位置上的数字，最后的得分即为收集的数字之和，求最大得分。

## 分析

很明显是一道动态规划的题目。$dp_{i,j,k}$ 代表走到第 $i$ 行 $j$ 列且已经改变了 $k$ 次数时所取数和的最大值。我们从金字塔的底部模拟从每个格子向上走向上更新，于是我们分四种情况：

+ 第一种情况：向上走但不改变数。$dp_{i-1,j,k}=\max(dp_{i-1,j,k}, dp_{i,j,k} + a_{i-1,j})$。

+ 第二种情况：向左上走但不改变数。$dp_{i-1,j-1,k}=\max(dp_{i-1,j-1,k}, dp_{i,j,k} + a_{i-1,j-1})$。

+ 第三种情况：向上走但改变数。$dp_{i-1,j,k+1}=\max(dp_{i-1,j,k+1}, dp_{i,j,k} + a_{i-1,j} \times 3)$。

+ 第四种情况：向左上走但改变数。$dp_{i-1,j-1,k+1}=\max(dp_{i-1,j-1,k+1}, dp_{i,j,k} + a_{i-1,j-1} \times 3)$。

边界条件为 $dp_{n,i,0} = a_{n,i}, dp_{n,i,1} = a_{n,i} \times 3$。

有一点值得注意，那就是在一个金字塔里最多使用的改变数的次数为 $K$ 和 $n$ 中的最小值。所以数组不用开到 $n^2 \times K$，$n^3$ 就可以了。

还有 $dp$ 数组最开始要初始化到负极大，因为 $a_{i,j}$ 可能为负数。

最后，不要忘记开 long long！

## 代码

```
#include <iostream>
#include <cstring>
using namespace std;
#define int long long
int n, K, a[110][110], dp[110][110][110], maxn = -0x3f3f3f3f;
signed main() {
    memset(dp, -0x3f, sizeof(dp));
    cin >> n >> K;
    for (int i = 1; i <= n; i++) for (int j = 1; j <= i; j++) cin >> a[i][j];
    for(int i = 1; i <= n; i++) dp[n][i][0] = a[n][i], dp[n][i][1] = a[n][i] * 3;
    for (int i = n; i >= 2; i--) {
		for (int j = 1; j <= i; j++) {
			for (int k = 0; k <= n - i + 2 && k <= K; k++) {
				dp[i - 1][j][k] = max(dp[i - 1][j][k], dp[i][j][k] + a[i - 1][j]);
				dp[i - 1][j - 1][k] = max(dp[i - 1][j - 1][k], dp[i][j][k] + a[i - 1][j - 1]);
				dp[i - 1][j][k + 1] = max(dp[i - 1][j][k + 1], dp[i][j][k] + a[i - 1][j] * 3);
				dp[i - 1][j - 1][k + 1] = max(dp[i - 1][j - 1][k + 1], dp[i][j][k] + a[i - 1][j - 1] * 3); // 四种情况更新
			}
		}
	}
    for (int i = 0; i <= min(K, n); i++) maxn = max(dp[1][1][i], maxn); // 最终答案
    cout << maxn << endl; 
    return 0;
}
```

[通过记录~](https://www.luogu.com.cn/record/111887508)

---

## 作者：hh__hh (赞：1)

## 算法 1

动态规划 $O(n^3)$。

本题是一道典型的动态规划问题，我们可以用 $f\left(i,j\right)$ 表示到达第 $i$ 行第 $j$ 列时最大的得分。 由于每一次只能向下走一格或向右下方走一格，所以第 $i$ 行第 $j$ 列的状态只能从 $f\left(i-1,j-1\right)$ 和 $f\left(i-1,j\right)$ 转移过来。

但是，本题要求我们可以选择最多 $k$ 个数字将其乘 $3$ ，那么我们可以用变量 $s\left(i,j\right)$ 表示从第 $1$ 行第 $1$ 列到第 $i$ 行第 $j$ 列的路径中选择的数字的集合，集合中的数字可以被选择 $0$ 次或 $1$ 次。

由于 $s\left (i,j \right)$ 中最多只有 $i$ 个数字，所以我们可以用一个二进制数来表示 $s\left (i,j \right)$ 中每个数字的选择情况。

例如，如果 $s\left(3,2\right)={a_{1,1},a_{2,1},a_{2,2}}$，并且我们选择了 $a_{1,1}$ 和 $a_{2,2}$，那么我们可以用二进制数 $101$ 来表示 $s\left(3,2\right)$。 

那么我们可以用变量 $g\left(i,j\right)$ 表示从第 $1$ 行第 $1$ 列到第 $i$ 行第 $j$ 列的路径中选择的数字的二进制表示的和。例如，如果 $s(3,2)$ 中的数字被选择了，那么 $g\left (3,2 \right)$ 的值就应该是 $5$。

接下来考虑状态转移方程。当我们从 $f\left (i-1,j\right)$ 转移过来时，我们只需要将 $s\left(i,j \right)$ 设置成 $s\left (i-1,j\right)$ 即可。

当我们从 $f\left(i-1,j-1\right)$ 转移过来时，我们需要将 $s\left(i,j \right)$ 设置成 $s\left(i-1,j-1 \right)$ 并且将 $a_{i,j}$ 加入到 $s\left(i,j\right)$ 中。

但是，由于 $s\left(i,j \right)$ 中最多只能包含 $i$ 个数字，所以我们需要选择一个数字从 $s\left(i-1,j-1\right)$ 中删除，使得加入 $a_{i,j}$ 后 $s\left(i,j\right)$ 中的数字个数不超过 $i$。

我们可以用堆来维护 $s\left(i,j\right)$。具体来说，我们先将 $s\left (i-1,j-1\right)$ 中的数字全部加入到小根堆 $H$ 中，然后将 $a_{i,j}$ 加入到 $H$ 中。

接下来，我们可以用 $O(i)$ 的时间复杂度在 $H$ 中找到一个数字删除，使得  $H$ 中剩余的数字个数不超过 $i$，并且计算出从 $s\left(i-1,j-1\right)$ 到 $s\left(i,j\right)$ 的差值 $d$。

然后，我们将 $s\left(i-1,j-1\right)$ 中的数字全部加入到  $s\left(i,j\right)$ 中，再将 $a_{i,j}$ 加入到 $s\left(i,j\right)$ 中，最后将 $g\left(i,j\right)$ 的值更新为 $g\left(i-1,j-1\right)+d$。

### 时间复杂度

状态总数为 $O\left(n^2\right)$，状态转移的复杂度为 $O\left(n\right )$，堆的操作的总复杂度为 $O\left(n^2\log n\right)$，所以总时间复杂度为  $O\left(n^3\log n\right)$。

-----------------------------------------------------------------

## 算法 2

动态规划优化 $O\left( n^3\right )$。

在算法1中，我们用堆来维护 $s\left ( i,j\right )$，时间复杂度为 $O\left (n^2+\log n \right)$。但是，我们可以用线性时间复杂度求出从 $s\left(i-1,j-1\right)$ 到 $s\left(i,j\right)$ 的差值 $d$，并且不需要使用堆。

具体来说，我们可以用两个指针 $p$ 和 $q$ 来遍历 $s\left ( i - 1,j - 1 \right )$ 和 $s\left ( i,j \right )$。

如果 $s\left(i-1,j-1\right)$ 中的某个数字比 $a_{i,j}$ 小，那么我们就将这个数字加入到 $s\left (i,j \right)$ 中，否则就将 $a_{i,j}$ 加入到 $s\left(i,j\right) $中。

当 $s\left(i,j\right )$ 中的数字个数超过 $i$ 时，我们就可以从 $s\left ( i,j \right )$ 中删除一个数字，使得 $s\left(i,j\right )$ 中数字的个数不超过 $i$。

假设我们要删除数字 $x$，那么我们可以在 $p$ 到 $q$ 的区间中找到最小的 $p'$，使得 $s\left (i-1,j-1 \right){p'}=x$，然后将 $p$ 到 $p'-1$ 和 $p'+ 1$ 到 $q$ 的数字全部加入到 $s\left(i,j\right)$ 中，最后将     $s\left(i,j \right)$ 的值更新为 $g\left (i-1,j-1\right ) +a_{i,j} - x$。

### 时间复杂度

状态总数为 $O\left(n^2\right)$，状态转移的复杂度为 $O\left(n\right)$，所以总时间复杂度为 $O\left(n^3\right)$。

--------------------------------------------------------------------

代码自己打，我就不放了。


---


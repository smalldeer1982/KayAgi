# 点的移动

## 题目描述

平面上有 $N$ 个整数坐标点。如果将点 $(x_0,y_0)$ 移动到 $(x_1,y_1)$，则需要的代价为 $|x_0-x_1|+|y_0-y_1|$。求使得 $K(K=1, \cdots ,N)$ 个点在同一位置上最少需要的代价。

## 样例 #1

### 输入

```
4
15 14
15 16
14 15 
16 15```

### 输出

```
0
2
3
4```

# 题解

## 作者：enceladus (赞：23)

只有两篇题解，那窝来水一篇题解QAQ。

![](https://img.shields.io/badge/By-enceladus-orange.svg)



------------
[安利博客](https://www.cnblogs.com/enceladus-return0/)

[题目传送门](https://www.luogu.org/problemnew/show/P1632)


------------

先说一下我犯得一个严重错误。题目没读清。让输出移动k个点的，而不是n个。一定要 
## 认真读题 
啊。


------------
这个题是暴力枚举，可是，为什么可以。

下面让我们想一下这个；

>则需要的代价为|x0-x1|+|y0-y1|。求使得K(K=1,…,N)个点在同一位置上最少需要的代价。

最优的点的横纵坐标一定来源于已知点的横纵坐标

为什么这么说呢，联想两点之间线段最短，如果有两个点，把它们移动到一个点上，最优解是移动到他两个连线的线段上。


比方说下面的图


![](https://cdn.luogu.com.cn/upload/pic/32080.png)


1是一个最优点，而根据**曼哈顿距离的计算公式**，我们可以发现，最优点2与最优点1是**等效**的。

我们考虑找到每两个点的最优点，这些点的最优点又会在最优点连城的线段上。


![](https://cdn.luogu.com.cn/upload/pic/32081.png)


而这个点，又可以经过转化，转到一个横纵坐标已知的点上。

而且就算是多边形也没有关系啊。

![](https://cdn.luogu.com.cn/upload/pic/32082.png)

最优点一定在网格区域内，网格区域的点又可以转化位已知的点的横纵坐标。


现在就证明了枚举横纵坐标的 _正确性_ 了



------------


下面还有有一个要注意的点。本人的最大值付为了0x7fffff；
然后


看看这个QAQ

![](https://cdn.luogu.com.cn/upload/pic/32083.png)




${\Huge\color{Salmon}{Make-sure-your-maximum-is-the-maximum}}$ 

付成0x7fffffff就可以了。


------------


${\color{Green}{By}}$

${\color{Green}{enceladus}}$

最后献上本人丑陋的代码,(代码有锅，勿抄，不要变棕啊）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define INF 0x7fffffff
#define ll long long
#define IL inline
#define R register
using namespace std;
ll ans[57];
int x[57],y[57];
long long l[57];
ll tot=0;
int mx,my; 
int n;

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>x[i]>>y[i];
        ans[i]=0x7fffffff;
    }  
	    for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=n;k++)
			{
			    for(int t=1;t<=n;t++) 
			    {
			    	l[t]=abs(x[t]-x[j])+abs(y[t]-y[k]);
				}
				tot=0;
				sort(l+1,l+1+n);
			    for(int i=1;i<=n;i++) 
				{
				    tot+=l[i];
				    ans[i]=min(ans[i],tot); 
			    }
			}	
		} 
	for(int i=1;i<=n;i++)
	{
		cout<<ans[i]<<endl;
	}
	return 0;
}
```


---

## 作者：ghj1222 (赞：17)

其实只需要开三重循环

根据OI中的一个重要的原理

> 给定一个序列a，求一个数x使得$\sum |a_i-x|$最小，那么这个数是序列a的中位数
>
> 证明略

然后既然是中位数，一定是数列中的数，类比到这题，聚集到的点的横纵坐标一定都存在于某些点上，所以O(n^2)枚举聚集到哪个点。  
然后求出所有点到这个聚集点的距离，sort一下，求一个前缀和，更新ans数组即可，预计复杂度$O(n^3\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;

struct coord
{
	int x, y;
} a[55];

int n, ans[55], dis[55];

int main()
{
	scanf("%d", &n);
	memset(ans, 0x3f, sizeof(ans));
	for (int i = 1; i <= n; i++)
		scanf("%d%d", &a[i].x, &a[i].y);
	for (int x = 1; x <= n; x++)
		for (int y = 1; y <= n; y++)
		{
			for (int p = 1; p <= n; p++)
				dis[p] = abs(a[p].x - a[x].x) + abs(a[p].y - a[y].y);
			sort(dis + 1, dis + 1 + n, less<int>());
			for (int p = 1; p <= n; p++)
			{
				dis[p] += dis[p - 1];
				ans[p] = min(ans[p], dis[p]);
			}
		}
	for (int i = 1; i <= n; i++)
		printf("%d\n", ans[i]);
	return 0;
}

```

---

## 作者：王奕瑜 (赞：6)

## 算法：暴力
- **前言**：因本人语文不好，我本来以为是**求$n$个点到同一位置上最少需要的代价**，后来又认为是**前$k$个点到同一位置上最少需要的代价**，最后才发现题目说的是$k$**个点到同一位置上最少需要的代价**，在此也提醒各位千万**要把语文学好**。

------------

- 看到题解里有一篇$O(n^3\log n)$的题解了，我就在他的基础上再说一下为什么最后的$\text{ansx}$与$\text{ansy}$一定是序列$\text{x}$与序列$\text{y}$里的数。
- 因为$\text{ansx}$如果是序列$\text{x}$里的数，则**至少**有$1$个点在水平方向上不需要移动。同理，$\text{ansy}$如果是序列$\text{y}$里的数，则**至少**有$1$个点在竖直方向上不需要移动。用这样的方法可以使代价最小。
- 所以，我们用$O(n^2)$的时间枚举每个**横坐标属于序列$\text{x}$，纵坐标属于序列$\text{y}$** 的点，计算$n$个点到这个点的距离$\text{dis}_k$，排序后将前$k$个$\text{dis}$值相加与$\text f_k$比较取$\min$，最后$i$个点到同一位置上最少需要的代价就是$\text f_i$。
- 最后，提醒要将$\text f$初始化。

------------

### 代码
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
void in(int &n)//快读
{
    n=0;int f=1;char c=getchar();
    while (c<'0'||'9'<c){if (c=='-')f*=-1;c=getchar();}
    while ('0'<=c&&c<='9'){n=n*10+(c-'0');c=getchar();}
    n*=f;
}
int a[55],b[55],dis[55],f[55]; 
//a[i],b[i]记录每个点的坐标
//dis[i],f[i]的意思见上文
int intabs(int n){return n>0?n:-n;}//手写abs
int main()
{
    int n;in(n);
    for (int i=0;i<n;i++)in(a[i]),in(b[i]),f[i]=1<<30;
    //读入，记住要对f进行初始化
    for (int i=0;i<n;i++)
        for (int j=0;j<n;j++)
        {
            for (int k=0;k<n;k++)
            dis[k]=intabs(a[k]-a[i])+intabs(b[k]-b[j]);
            //计算n个点到这个点的距离
            sort(dis,dis+n);//排序
            for (int k=0;k<n;k++)
                dis[k]+=(k==0)?0:dis[k-1],f[k]=min(f[k],dis[k]);
                //记录前k个点的dis值的和，并更新f数组
        }
    for (int i=0;i<n;i++)printf ("%d\n",f[i]);//输出
    return 0;
}

```

------------
    
### 广告
- 推荐一下这位同学的博客（因$azy$本人要求，已将巨佬改为萌新）：
- $1. $[$azy$萌新的博客](https://www.luogu.com.cn/blog/3355406081azy/)

---

## 作者：szhqwq (赞：4)

## 题目大意

依次给出 $N$ 个点 $(1 \le N \le 50)$，问你当前所给你点在同一位置上的最小代价，题目很良心的告诉了求代价的公式 $|x_0-x_1|+|y_0-y_1|$ 
这就是从点 $(x_0,y_0)$ 到 $(x_1,y_1)$ 的代价。

## 分析

这道题我们就使用两个数组输入 $x$ 坐标与 $y$ 坐标，两个数组来求代价，求代价时就将公式带入其中,将每个点的代价存入一个数组里，然后排序一下，再使用一个变量来存当前所给你的点的最小代价，因为是最小代价，所以要与答案数组取一个 $\min$，再将答案存进答案数组，最后输出即可。

AC code

```cpp
#include <bits/stdc++.h>
#define int long long
#define AC return 0
#define M(a) memset(a,INF,sizeof a)
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define per(i,l,r) for(int i=r;i>=l;i--)
#define il inline
using namespace std;

const int N=1010,INF=1e9+7;

int n;
int x[N],y[N],Ans[N],a[N];

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	M(Ans);
	cin>>n;
	rep(i,1,n) cin>>x[i]>>y[i];
	rep(i,1,n) 
		rep(j,1,n) {
			int sum=0;
			rep(k,1,n) a[k]=abs(x[k]-x[i])+abs(y[k]-y[j]);
			sort(a+1,a+n+1);
			rep(k,1,n) sum+=a[k],Ans[k]=min(Ans[k],sum);
		}
	rep(i,1,n) cout<<Ans[i]<<endl;
	AC;
}
```

---

## 作者：Morax2022 (赞：3)

# P1632 点的移动 题解
**先读题**

首先，题目告诉我们给定 $n$ 个点，求将 $k(k = 1,2...n)$ 个点移到一个位置最小的代价，$n \le 50$，所以我们可以毫不犹豫上暴力求中位数。

- 那中位数是个啥呢？

**中位数**，又称中点数，中值。中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小（来自[百度](https://baike.baidu.com/item/%E4%B8%AD%E4%BD%8D%E6%95%B0/3087401?fr=aladdin)）


------------


- 那又如何去求呢？

**暴搜，纯纯的暴搜。**

我的思路是跑一个三重循环，第一，二重跑每一个点的横，纵坐标，第三重去枚举中间每个点到此点距离，计算需要的代价，用数组存起来，快排一下，将距离数组由小到大排好，最后再循环跑一遍对于每一个 $k$ 的最小就搞定了。

------------

虽然非常暴力，时间复杂度是 $O(n^3)$ 但是对于本题非常~~水~~小的数据，也能够 AC 了。

## 上代码
```c
#include<bits/stdc++.h>
using namespace std;
int n, x[101], y[101], co[101], dis[101] = {0};//x,y数组存坐标，co数组计算结果，dis记录枚举的距离
int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> x[i] >> y[i];
	memset(co, 0x3f, sizeof co);//将最值数组初始化一个最大值
	int i, j, k;//分别用来枚举第一个点，第二个点，每个点到此点距离
	int sum = 0;//用来存对于将i个点移到一个位置需要的代价 
	for(i = 1; i <= n; i++)
	{
		for(j = 1; j <= n; j++)
		{
			for(k = 1; k <= n; k++)
			dis[k] = abs(x[k] - x[i]) + abs(y[k] - y[j]);//计算距离
			sort(dis + 1,dis + n + 1);//sort默认从小到大排序
			for(int i = 1; i <= n; i++)//比较出对于每一个i最值的 
			sum += dis[i], co[i] = min(co[i], sum);
			sum = 0;//一定要初始化！！！
		}
	}
	for(int i = 1; i <= n; i++) 
	cout << co[i] << endl;//输出
	return 0; //圆满结束
}
```
这是本蒟蒻的第一篇题解，希望可以帮到大家，有做的不好的地方望谅解。


---

## 作者：inexistent (赞：3)

我的解法貌似更暴力，用了四重循环……

之前一直想不通为什么坐标一定在x[i], y[j]上面，但其实仔细一想确实。x[i], y[j]意味着最终的点一定会在一个出现过的x坐标与y坐标上面。可以利用反证法，如果最终的点不在x[i], y[j]上，意味着最终的点所在的x坐标与y坐标在所有点中根本没有出现过。而这样的点肯定不会优，因此只需要N^2枚举一下就好了

```cpp
	read(n);
	for(int i = 1; i <= n; ++i) read(x[i]), read(y[i]);
	for(int k = 1; k <= n; ++k){   //枚举个数
		ans = INF;
		for(int i = 1; i <= n; ++i){   //x坐标
			for(int j = 1; j <= n; ++j){   //y坐标
				for(int p = 1; p <= n; ++p)   //各个点到这个点的距离
                	d[p] = abs(x[p]-x[i])+abs(y[p]-y[j]);	
				sort(d+1,d+n+1);
				tmp = 0;
				for(int p = 1; p <= k; ++p) tmp += d[p];
				ans = Min(ans, tmp);
			}
		}
		printf("%d\n",ans);
	}
	return 0;
```

---

## 作者：AlicX (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/solution/P1632)

拿到这道题，相信大家都没有什么头绪，于是，~~你打开了题解~~


## 切入正题

本题题目看起来十分复杂，其实静下心来一想，算法就十分明显了，这分明是道暴搜模板题，数据 $N \le 50$，根据一个简单的定理：只要保证每两个点之间距离最短，那么，就一定能保证结果最优（贪心思想，很简单的一个小定理，非常容易证明）。

那么代码怎么实现呢？

实际上很简单，用三重循环，第一重，枚举第一个点，第二重枚举第二个点，第三重枚举这两个点之中的那个点，计算它们的曼哈顿距离，用一个数组存起来，sort排序，用变量计算最小值，记在答案数组中，最后输出即可。

AC code

```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
typedef pair<int,int> pii;
const int N=110;
int n;
int x[N],y[N];//横纵坐标 
int f[N],s[N];//s 临时数组（存储i点和j点到k点的曼哈顿距离） f答案数组 
bool cmp(int a,int b){//按从小到大排序 
	return a<b;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];//输入 
	memset(f,0x3f,sizeof f);//初始化为无穷大 
	for(int i=1;i<=n;i++){//枚举第一个点 
		for(int j=1;j<=n;j++){//枚举第二个点 
			memset(s,0,sizeof s);//可要可不要 
			for(int k=1;k<=n;k++){//枚举中间的点 
				s[k]=abs(x[k]-x[i])+abs(y[k]-y[j]);
			}
			int cnt=0;//累加变量 
			sort(s+1,s+n+1,cmp);//排序 
			for(int i=1;i<=n;i++) cnt+=s[i],f[i]=min(f[i],cnt);//每加一次便取min 
		}
	}
	for(int i=1;i<=n;i++) cout<<f[i]<<endl;//输出 
	return 0;//养成良好习惯 ->自信AC 
}
```
$$The \ end$$

---

## 作者：Kiloio (赞：1)

# 中位数的题  
**简单**来说，中位数就是所有数中**中间的**那一个。  
中位数满足一个**重要的**性质：所有数到这个数的**距离最小**。  
  
举个简单例子：    
例如 $1$ $3$ $5$ 这个数列，**中位数**为$3$，此时所有点到$3$的距离为$4$。最短的距离也为$4$。  
  
### 开始BB正解
  
接下来，就用**两个循环**模拟 $X$ 和 $Y$ 坐标，**暴力求出中位数**。$n^2$时间。    

每次模拟时，求每个点到中位数点的**距离（既是题面所说的代价）**，再排序一遍。   

**排序后更新$ans$数组（答案数组），程序中再加了一个前缀和优化。**  

时间复杂度**看**起来 ~~极危~~ 不大乐观，但$n$**最大**$50$，不慌。   

**Code：**
```
#include <bits/stdc++.h>
using namespace std; 
long long n,sum[60],ans[60];//sum为前缀和数组，ans为答案数组 
struct node{
	int x,y;
}a[60];
int main(){
	cin>>n;
	for(int i=1; i<=n; i++){
		ans[i]=INT_MAX;//初始化答案数组，便于后面min操作 
	}
	for(int i=1; i<=n; i++){
		scanf("%lld%lld",&a[i].x,&a[i].y);
	}
	for(int i=1; i<=n; i++){
		for(int j=1; j<=n; j++){
			for(int l=1; l<=n; l++){
				sum[l]=abs(a[l].x-a[i].x)+abs(a[l].y-a[j].y);//不要忘了abs（绝对值） 
			}
			sort(sum+1,sum+1+n);
			for(int l=1; l<=n; l++){
				sum[l]=sum[l]+sum[l-1];//求前缀和
				ans[l]=min(ans[l],sum[l]);//更新答案数组 
			}
		}
	}
	for(int i=1; i<=n; i++){
		cout<<ans[i]<<endl;
	}
	return 0;
}
```


---

## 作者：mot1ve (赞：1)

话说这题看了题解半小时才明白是个啥，现在才理顺整个思路。大部分题解没有详细的说明整个题的做题思路，我做一些补充。

首先为什么答案的 $x$ 坐标一定属于给出的 $x$ 坐标之中的一个，答案的 $y$ 坐标一定属于给出的 $y$ 坐标之中的一个？

我们先考虑这个问题，假如在数轴上有一些点，现在让你找出一个点到这些点距离和最小，要怎么做呢？

显然是取中位数，这个很好证明，不再赘述。那么我们把 $x$ 坐标和 $y$ 坐标分别看，在二维平面中，找 $n$ 个点之间距离和最小的一个点就是这 $n$ 个数的 $x$ 坐标的中位数和 $y$ 坐标的中位数对应的那个点。

所以我们得出了这个结论。那么我们可以枚举了。 $O(n^2)$ 的时间复杂度枚举这个点的坐标。

我们现在只是锁定了枚举范围，但并不知道最小的值是多少，所以还要再来一层循环计算到其他点到我们当前枚举的这个答案点 $(x_i,y_i)$ 的距离。最小值肯定就是我们要求的答案了。

由于题目比较恶心，让我们分别求出i个点到同一位置的最小距离和。那么还要在最外层枚举当前是要求几个点到同一位置的最小距离和。

我们在求几个点到同一位置的最小距离和的时候可以排序之后再累加求和，$i$ 个点到同一位置的最小距离和肯定是排序之后的前 $i$ 项。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=0x3f3f3f3f;
int n,minn=INF,temp;
int x[100010],y[100010],dis[100010];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
    }
    for(int t=1;t<=n;t++)
    {
    	minn=INF;
    	for(int i=1;i<=n;i++) 
    	{
    		for(int j=1;j<=n;j++)
    		{
    			for(int k=1;k<=n;k++)//其他点到这个点的距离 
    			{
    				dis[k]=abs(x[k]-x[i])+abs(y[k]-y[j]);
				}
				sort(dis+1,dis+1+n);
				temp=0;
				for(int k=1;k<=t;k++)
				{
					temp+=dis[k];
				}
				minn=min(minn,temp);
			}
		}
		printf("%d\n",minn)
	}
	return 0;
}
```

---

## 作者：Frozen_Ladybug (赞：0)

题意：$N$ 个坐标均为整数的点，将其移动至同一个点上的最小所需代价。代价 $d=\vert x_1-x_2\vert + \vert y_1-y_2\vert$，也就是水平距离加上竖直距离。

首先考虑两个点，连成一条线段。很容易知道最优点就在这条线段上的任意一个点；原因就是两点之间线段最短。

接下来我们考虑一个三角形，找到每两个点的最优点，这些点的最优点又会在最优点连成的线段上——即三角形内部。若移动至三角形外一点，则代价会更高。

同理，多边形类似可知是一样的（我自己归纳了一部分，过程就不详细写了，和前面差不太多）。这样就可以将原题中的点顺次围成多边形，在多边形中任意选一个点作为参考点，再算就简单了。

于是我想到了动态规划：每次加一个点，以这个点为参考点算——这个新答案与之前有关，也就是我们的转移方程。

而且这道题点的个数并不大，只有 $50$，所以暴力肯定不会超时。但是如果是较大的范围，比如 $1\times 10^4$ 这种，就一定需要优化了。

最开始将 $dp$ 数组中所有数赋值为最大值就行了。

接下来给出代码：

```c
#include<bits/stdc++.h>
using namespace std;
int x[55],y[55],l[55],n,dp[55]={0x7fffffff};//将dp数组全部初始化为最大,dp[i]表示从第i个点出发的最小值
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);//读入
    for(int j=1;j<=n;j++)
        for(int k=1;k<=n;k++){
            int tot=0;
            for(int i=1;i<=n;i++) l[i]=abs(x[i]-x[j])+abs(y[i]-y[k]);//l[i]表示i点到j和k点的距离,因为要多次使用,不初始化也没问题
            sort(l+1,l+1+n);//排序,默认从小到大
            for(int i=1;i<=n;i++) {
                tot+=l[i];//将当前的总数加上这个距离
                dp[i]=min(dp[i],tot);//第i个点的dp值取最小
            }
        }
    for(int i=1;i<=n;i++) printf("%d\n",dp[i]);//输出
    return 0;//结束
}
```

---

## 作者：yezl (赞：0)

首先概括一下题意，大概就是给你 $ n $ 个点的 $ x,y $ 坐标，然后让你求当有 $ i $ 个点时（ $ i $ 从1开始到 $ n $ ）要让这 $ i $ 个点移到同一点（可以不是它们自己）所花费的最小代价（步数）。

**类似题目推荐：**
 1. [P1862 输油管道问题](https://www.luogu.com.cn/problem/P1862)
 2. [P1889 士兵站队](https://www.luogu.com.cn/problem/P1889)
 
 当然上面两题只是方法类似，都是中位数，但是更加简单，~~想刷题的小伙伴可以去尝试~~，~~时隔多年~~我回来写这题的题解，但是我一脸茫然地看着我原来的代码，开始了沉思，~~这......我写的都是什么意思呀~~，于是我花了一段时间重新理解了一下，意思大概是枚举横纵坐标，用 $ ans $ 数组吧每个方案的最小值存下来，然后输出就行了，但是具体的证明还请各位查看[曼哈顿距离的计算公式](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092?fr=aladdin)的详细解答。
 
 对了，这里我顺便说一下关于 $ \texttt{cstring} $ 库里的 $ \texttt{memset} $ 函数的数组初始化，格式： $ \texttt{memset(数组名,数值,sizeof(数组名))} $  ，**注意：** $ \texttt{memset} $ 能初始化的值只有 $ \texttt{0,0xcf,0x7f,0x3f,-1\;\;(0xcf：极小值,0x3f和0x7f：极大值)} $ ，为什么这里不是0x7f7f7f7f四个呢？因为 $ \texttt{memset} $ 是按字节初始化的，直接加入字节里，所以只有这4个可以初始化，$ \texttt{int} $ 类型是四个字节O。还有当数组后面要直接计算用时最好用 $ 0x3f,0x7f $ 此时可能会越界。
 
 ### 不多说，直接上代码：
 
 ```c
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=60;
int x[N],y[N],b[N],ans[N],n,temp;
int main()
{
	scanf("%d",&n);
	memset(ans,0x7f,sizeof(ans));
	for(int i=1;i<=n;i++)
		scanf("%d %d",&x[i],&y[i]);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=n;k++)
				b[k]=abs(x[i]-x[k])+abs(y[j]-y[k]);
			sort(b+1,b+n+1);
			for(int k=1;k<=n;k++)
			{
				temp+=b[k];
				ans[k]=min(temp,ans[k]);
			}
			temp=0;
		}
	}
	for(int i=1;i<=n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

希望可以帮到大家。

---

## 作者：mengdai (赞：0)

看到没有题解自己来一发。

C++
一开始想的是枚举各个矩形内的点坐标

然后发现若要价值最小，移动到的点的x,y坐标必须是给出点中的某一个x,y坐标

因此，我们只要枚举每一个x,y然后将每一个点都去移动一次，找出移动k个点的时候，最小的移动代价即可。

那么我们在这题中可以用一个三重循环，因为N的值并不大，只有50，三重循环并不会TLE。这里用三重循环的作用是方便计算每一个点移动的代价，详见代码。

===================================================================================

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int x[55],y[55],d[55],ans[55];
int i,j,k,n;
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>x[i]>>y[i];
    }
    for(k=1;k<=n;k++){
        ans[k]=9999999999;
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            for(k=1;k<=n;k++){
                d[k]=abs(x[k]-x[i])+abs(y[k]-y[j]);
            }
            sort(d+1,d+n+1);
            int s=0;
            for(k=1;k<=n;k++){
                s=s+d[k];
                if(s<ans[k]){
                    ans[k]=s;
                }
            }
        }
    }
    for(k=1;k<=n;k++){
        cout<<ans[k]<<endl;
    }
    return 0;
}
```

---


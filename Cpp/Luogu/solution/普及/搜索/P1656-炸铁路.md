# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？


## 样例 #1

### 输入

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6```

### 输出

```
1 2
5 6```

# 题解

## 作者：kkksc03 (赞：598)

解题思路：

即求图中的桥（割边）

可以使用Tarjan算法


由于本题范围很小，枚举即可

枚举一条边，将这条边去掉后随便选一个点进行FloodFill，或者说从这个点开始进行DFS或BFS遍历，看是否能遍历到所有的点。

如果不可以则这条边为割边，否则不是。


---

## 作者：abruce (赞：197)

### 楼顶tarjan不太详细啊，我来讲详细一点吧


------------
  

先上代码，代码中有讲解   
```cpp
#include <bits/stdc++.h>
using namespace std;
int maps[151][151];//邻接矩阵，简单易懂
struct Edge {
    int x,y;
} E[5001];//这是存答案的，用邻接表存，应该不用解释
int dfn[151],low[151],n,m,id,cnt,f[151];/*这些数组的含义：
dfn:
{
下标：点编号
内存的值：深度优先搜索时第几个遍历
}
low:
{
下标：点编号
内存的值：这个点能通过它的子孙到达的dfn值最小的点的dfn
}
f:
{
下标：点标号
内存的值：它遍历的上一个点
}
变量的含义：
n:结点个数
m:边个数
id:用于dfn标记
cnt:用于邻接表存图
*/
bool cmp(struct Edge a,struct Edge b) {
    if(a.x==b.x)return a.y<b.y;
    return a.x<b.x;
}//因题目要求，边要排序，要做这道题的人应该都知道cmp
void addEdge(int x,int y) {
    E[++cnt].x=x;
    E[cnt].y=y;
}//addedge函数，存入邻接表
void tarjan(int x) {
    int c=0,y;
    dfn[x]=low[x]=++id;
    for(register int i=1; i<=n; i++) {
        if(!maps[x][i])continue;//首先要有边
        y=i;//处理对象
        if(dfn[y]&&y!=f[x])low[x]=min(low[x],dfn[y]);//如果是它爸爸，割边就没有用了，好好理解
        if(!dfn[y]) {//如果找到祖先还有什么用呢
            f[y]=x;//不是祖先就认爸爸
            tarjan(y);//dfs过程
            low[x]=min(low[x],low[y]);//回溯时带着爸爸更新low
            if(low[y]>dfn[x])addEdge(x,y);//是割边，就加入吧
        }
    }
}//tarjan部分，证明在下面
int main() {
    int x,y;
    cin>>n>>m;
    for(register int i=1; i<=m; i++) {
        cin>>x>>y;
        maps[x][y]=maps[y][x]=1;//存边
    }
    for(register int i=1; i<=n; i++) {
        if(!dfn[i])tarjan(i);//tarjan
    }
    sort(E+1,E+cnt2+1,cmp);//sort大法好
    for(register int i=1; i<=cnt; i++) {
        cout<<min(E[i].x,E[i].y)<<' '<<max(E[i].x,E[i].y)<<endl;//输出
    }
    return 0;//程序结束了，证明开始了
}
```

![](https://cdn.luogu.com.cn/upload/pic/46966.png)  
这是一个图 图中有边  
![](https://cdn.luogu.com.cn/upload/pic/46972.png)
深度优先遍历后（描绿的边为遍历过的边）  
dfn值和f值已固定  
low值暂时为它自己  
接下来我们看看能不能有边回到它的祖先**但不是它的父亲**的结点  
于是我们继续**回溯**（因为搜完了返回）  
![](https://cdn.luogu.com.cn/upload/pic/46974.png)
发现结点7可以回到结点2  
于是它的low值立刻被改为2  
![](https://cdn.luogu.com.cn/upload/pic/46975.png)
一路上它的**除了1和2**的其他祖先low值都被改成了2  
后面搜索结束  
我们发现2-3-4-5-6-7这些结点都有至少两条完全不同的路通往这些结点（2、3、4、5、6、7）中的其它结点（也就是点双联通）   
但是1、8不是  
我们发现图中的割边（把这条边去掉，图不联通）有几条呢？  
很明显有（1-2）、（7-8）两条
我们来看看它们low值有什么关系呢？  
我们发现**祖先的low值都比子孙的小**  
也就是说子孙不能到达祖先以上的结点，除了这条边就再无去路  
如果这条边没了呢？子孙岂不是不能到达祖先及其以上的点咯。  
这条边就可以把图分成祖先和子孙两个不联通的区域，这就是割边

#### 推荐题目：P3387 P3388

------------
### 完结撒花


---

## 作者：hsfzLZH1 (赞：65)

$Tarjan$ 的题解

此题所求的是无向图中的所有割边。

对于一个联通的无向图，我们可以从一个节点开始，保证一个节点不遍历两次，可以形成一棵 $DFS$ 树，定义遍历到这个节点的次序为这个节点的时间戳（用 $dfn$ 表示），这样的dfn编号有一个神奇的性质：在 $DFS$ 树中，一个节点的时间戳一定小于他的子树中的所有节点。

定义 $low[i]$ 为不经过 $i$ 和父节点的连边在 $DFS$ 树上可以（直接或间接）访问到的最小的时间戳，在更新的时候顺便维护 $low$ 的值。根据 $dfn$ 的性质，如果 $low[child]>dfn[father]$ ，则不经过 $father，child$ 不能访问到更小的时间戳，那么边 $\langle child,father\rangle$就是割边。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=10010;
int n,m,x,y,index_,dfn[maxn],low[maxn],ans,a;//index_代表当前的时间戳
vector<int>G[maxn];//存边的数据结构：邻接表
struct Edge{int from,to;}edge[maxn];//答案的边，最后需要排序
bool cmp(const Edge a,const Edge b){if(a.from!=b.from)return a.from<b.from;return a.to<b.to;}//答案边的比较函数
inline void add_edge(int x,int y){edge[ans].from=min(x,y);edge[ans].to=max(x,y);ans++;}//在答案中加入一条边
void dfs(int cur,int fa)//cur是当前节点，fa是他的父亲
{
    int child;
    dfn[cur]=++index_;//计算当前节点的时间戳
    low[cur]=dfn[cur];//当前可以访问到的最早时间戳肯定是自己的时间戳
    for(int i=0;i<G[cur].size();i++)//遍历cur的所有出点
    {
        child=G[cur][i];
        if(dfn[child]&&child!=fa)low[cur]=min(low[cur],dfn[child]);//如果访问到了不是父亲节点的节点，更新low的值
        if(!dfn[child])//如果这个节点之前没有被访问过
        {
            dfs(child,cur);//进行一次dfs过程
            if(dfn[cur]<low[child])add_edge(cur,child);//如果满足条件，在答案序列中加入这条边
            low[cur]=min(low[cur],low[child]);//更新low的值
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++)scanf("%d%d",&x,&y),G[x].push_back(y),G[y].push_back(x);
    for(int i=1;i<=n;i++)if(!dfn[i])dfs(i,i);//图可能不连通，初始时fa是i不会出现问题
    sort(edge,edge+ans,cmp);//将答案序列排个序
    for(int i=0;i<ans;i++)printf("%d %d\n",edge[i].from,edge[i].to);//输出
    return 0;
}
```
同时建议同学们去做一下洛谷的模板题【割点】，注意求割点时应该是 $low[child]\ge dfn[father]$ ，因为如果还是可以遍历到父亲节点的时候这个child也是割点。

-------------

感谢 [@刀与玫瑰](https://www.luogu.org/space/show?uid=135950) 提供的 hack 数据，本代码在有重边时会出错，如：

```
2 2
1 2
2 1
```

此时断开边 $\langle 1,2 \rangle$ ， $1,2$ 两点仍连通，则 $\langle 1,2\rangle$ 不为割边。

处理方法是在遍历一个点的所有出边时，如果在第一次之外还回到了父亲结点，则按像计算儿子结点的方法一样用父亲结点的值更新当前结点的值。

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
const int maxn=10010;
int n,m,x,y,index_,dfn[maxn],low[maxn],ans,a;
vector<int>G[maxn];
struct Edge{int from,to;}edge[maxn];
bool cmp(const Edge a,const Edge b){if(a.from!=b.from)return a.from<b.from;return a.to<b.to;}
inline void add_edge(int x,int y){edge[ans].from=min(x,y);edge[ans].to=max(x,y);ans++;}
void dfs(int cur,int fa)
{
    int child;
    dfn[cur]=++index_;
    low[cur]=dfn[cur];
    bool vis=false; 
    for(int i=0;i<G[cur].size();i++)
    {
        child=G[cur][i];
        if(dfn[child])
		{
			if(child==fa&&!vis)vis=true;
			else low[cur]=min(low[cur],dfn[child]);
		}
        if(!dfn[child])
        {
            dfs(child,cur);
            if(dfn[cur]<low[child])add_edge(cur,child);
            low[cur]=min(low[cur],low[child]);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++)scanf("%d%d",&x,&y),G[x].push_back(y),G[y].push_back(x);
    for(int i=1;i<=n;i++)if(!dfn[i])dfs(i,i);
    sort(edge,edge+ans,cmp);
    for(int i=0;i<ans;i++)printf("%d %d\n",edge[i].from,edge[i].to);
    return 0;
}
```

---

## 作者：嗯。 (赞：36)

  作为标签党，首先点开标签：模拟~~没毛病~~ 最短路~~想不出来~~ 搜索~~还行~~ 图论~~废话~~.
  
  于是想了想搜索：枚举每个铁路被炸，然后dfs由各个点开始遍历，看能否到达每个点，然而觉得好麻烦，于是~~放弃~~
  
  接下我又想到了并查集~~xjb 瞎鸡巴~~的做法，emm，先枚举一条边被炸，然后合并其他边连的点，看是否有点不是同一个祖先，有就直接NO了。
  
  时间复杂度貌似是O（m^2）刚好卡到，~~美滋滋~~
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,baba[151],b[151];
struct zhzs
{
    int x;
    int y;
}a[5001];
inline bool zh(zhzs x,zhzs y)
{
    if(x.x==y.x)
    return x.y<y.y;
    return x.x<y.x;
}//结构体排序
inline int find(int x)//找爸爸（祖先）
{
    if(baba[x]==x)
    return x;
    return baba[x]=find(baba[x]);
}
inline void he(int x,int y)//并查集合并操作
{
    int x1=find(x),y1=find(y);
    baba[y1]=baba[x1];
}
int main() 
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);//加速cin cout的
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>a[i].x>>a[i].y;
        if(a[i].y<a[i].x)//不这样貌似有些数据过不了
        swap(a[i].x,a[i].y);
    }
    sort(a+1,a+m+1,zh);//题目要求输出的a，b从小到大，所以先排好序
    for(int i=1;i<=m;i++)
    {
        int f=0;
        for(int j=1;j<=n;j++)
        baba[j]=j;//初始化
        for(int j=1;j<=m;j++)
        {
            if(j!=i)//模拟炸铁路
            he(a[j].x,a[j].y);//合并其他边
        }
        for(int j=2;j<=n;j++)
        if(baba[find(j)]!=baba[find(j-1)])//只要有祖先不一样的就有问题
        {
            cout<<a[i].x<<" "<<a[i].y<<endl;
            break;
        }
    }
    return 0;
}
```

---

## 作者：cz2zxy (赞：31)

此题可用并查集求解

因为并查集可用来快速判断图中的任意两点之间是否连通

思路：枚举每条边，删去这条边后将其余边的所有节点加入并查集，判断此时图是否连通，如果不连通，则此边满足题意

过程中注意初始化

附上代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=151,M=5001;
int n,m,par[N],rank[N],tot;
struct edge{
    int u,v;
}e[M];
edge a[M];
bool cmp(const edge &a,const edge &b)    //调用c++中的sort函数将边按题目要求进行排序 
{                                        //自定义cmp函数 ，具体原理是什么我也说不清 
    if(a.u<b.u)return 1;
    if(a.u>b.u)return 0;
    return a.v<b.v;
}
int find(int x)                            //查找结点 x 的根 
{
    if(par[x]==x)return x;
    return par[x]=find(par[x]);            //路径压缩 
}
void unite(int x,int y)                    //将 x 和 y 并入同一集合 
{
    x=find(x);y=find(y);
    if(rank[x]<rank[y])par[x]=y;
    else{
        par[y]=x;
        if(rank[x]==rank[y])++rank[x];
    }
}
void check(int t)        //删除第t条边图是否不连通 
{
    int i,j,k,u,v,reap;
    memset(rank,0,sizeof(rank));//初始化 
    for(i=1;i<=n;i++) par[i]=i;//初始化 
    for(i=1;i<=m;i++)if(i!=t&&find(e[i].u)!=find(e[i].v))unite(e[i].u,e[i].v);
    //若第 i(i!=t)条边的两个结点不在同一集合内，则将这两点并入同一集合 
    for(reap=find(1),i=2;i<=n;i++)if(find(i)!=reap)//结点 i 不在集合内，即图是不连通的 
    {
        a[++tot]=e[t];        //答案边，tot:符合条件的边数 
        break;                //退出循环 
    }
}
int main()
{
    int i,j,k,u,v,t;
    //freopen("station1.in","r",stdin);
    scanf("%d%d",&n,&m);//读入数据 
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&e[i].u,&e[i].v);//读入数据 
        if(e[i].u>e[i].v)t=e[i].u,e[i].u=e[i].v,e[i].v=t;//预先将a和b按要求交换 
    }
    for(i=1;i<=m;i++)check(i);    //枚举每条边，看删除后图是否不连通
    sort(a+1,a+tot+1,cmp);        //将边按要求排序 
    for(i=1;i<=tot;i++)printf("%d %d\n",a[i].u,a[i].v);//输出答案 
    return 0;
}
```

---

## 作者：HRLYB (赞：16)

## 隆重介绍：tarjan算法求双连通分量（无向图缩点）。

### 背景

把题解翻了个底朝天，还没有这种方法的，所以就来补一发。

在做这道题之前，我刚做完了另外一道双连通分量的题目：

[P2860 [USACO06JAN]冗余路径Redundant Paths](https://www.luogu.org/problemnew/show/P2860)

一读题，他们的思路是一样的：

	建的图都是无向图，而且都是求双连通分量。
    
    只不过那一道题求的是双连通分量的数目，这一道题是求双连通分量之间的边。
    
### 关于双连通分量

可能有的同学还不知道双连通分量是什么，我在这里就简单介绍一下。

我们知道，通常的tarjan算法，是在有向图上进行操作，通过缩点将一个有向有环图变成一个有向无环图（DAG）~~还不知道tarjan算法的同学请出门右转百度~~

而有向无环图上的每一个“点”就是一个强联通分量。

但是如果在有向图上，普通的tarjan算法就不行了。

~~你问我为什么？因为是双向建边啊，普通的tarjan会陷入死循的~~

#### 那么怎么办呢？

用vis数组打标记显然不行，会与已有的标记重复。

那么我只建一条边呢？

```cpp
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        g[x].push_back(y);//我只建了一次边
    }
```
然后你就会挂掉……

![](https://cdn.luogu.com.cn/upload/pic/60670.png )

#### 所以，就该我们的改良tarjan出场啦！（咳咳，正文）

	
	解决的方法就是，当同一条无向边的两条有向边的其中一条走过时，把另一条同时赋值为走过（双向边标记）。这需要一个神奇的公式：^1。 举例来说，0^1=1,1^1=0; 2^1=3,3^1=2; 4^1=3,3^1=4......相信大家已经都发现了规律。而建边的时候，一条无向边的两条有向边刚好相差1，问题解决！

	不过要注意，我的num（边的初始值）赋值为1，这是用来凑数字的。所以边是从第2，3条；第4,5条......这样下去的（0,1条加进去应该也可以，也可以试试）
    
呐，这就是解决的办法！

```cpp
//在tarjan里长这样

for(int i=head[u];i;i=e[i].next )
        if(!sign[i]){
            sign[i]=true,sign[i^1]=true;//sign数组用于标记边是否走过
            int v=e[i].v ;
            if(!dfn[v]){
                tarjan(v);
                if(low[v]<low[u])low[u]=low[v];
            }
            else {
                if(vis[v]){
                    if(low[v]<low[u])low[u]=low[v];
                }
            }
    }
```


可能有的同学又会有疑问了：走过的边标记，难道和只建一条边不是一样吗？每条边都遍历了一次啊

这个就涉及到tarjan自身的dfs序的问题了。不信的话大家可以手模一下，你会发现他们实际上遍历的顺序不一样。当且仅当采用标记法，那么遍历的顺序是严格的dfs序而且保证同一个强连通分量的所有点一定在同一个点集（color）内。这就是双向边标记的正确性的证明。

### 关于[P1656 炸铁路](https://www.luogu.org/problemnew/show/P1656)

这道题的思路我已经在一开始时说过了。

以样例为例，

![](https://s2.ax1x.com/2019/06/11/V2iSPK.md.jpg)

那么显而易见的，如果uim将军想要切断一条能使两个城市分离的铁路，那么切断的那一条应满足如下条件：

#### 必须是连接两个双连通分量的边

在上图中，就是连接两个蓝圈的边（ 1 ,2 和 5 ,6 ）

这条边是可以暴力枚举查找的。

```cpp
   
int k=1;
for(int i=1;i<=n;i++){//枚举每个点
        for(int j=head[i];j;j=e[j].next ){
            int v=e[j].v ;//枚举每个点所能到达的点
            if(color[v]!=color[i]){//假如这两点不在同一双连通分量内，则他们的连边一定是题目要求的边
            	edge_ans[k].from =(v<i?v:i);//edge_ans用于存题目要求的边
            	edge_ans[k++].to =(v>i?v:i); 
            }
        }
    }
```
这样子就可以找出我们所要求的边了。

#### 但是，你以为结束了吗？还没有！

注意我们是双向建边的，所以会有两个同样的输出。如：

	1 2
    1 2
    5 6
    5 6
    
我是在输出时处理掉的。

另外我们的k多加了一，在排序时要减去。

```cpp
    sort(edge_ans+1,edge_ans+k-1,cmp);
    for(int i=1;i<k;i+=2)printf("%d %d\n",edge_ans[i].from ,edge_ans[i].to );//i+=2,奇怪的处理方式（但是有用）
```

~~（我是不会告诉你们我被这些小细节卡了十几分钟的）~~

#### 细节真的非常、非常、非常重要！

### 以下是AC代码

```cpp
#include<bits/stdc++.h>
#define maxn 100010
using namespace std;
struct edge{
    int u,v,next;
}e[maxn];//结构体存边
int sum=1,head[maxn];
void add(int u,int v){
    sum+=1;
    e[sum].u =u;
    e[sum].v =v;
    e[sum].next =head[u];
    head[u]=sum;
}//邻接表存图
int deep,num,top,low[maxn],dfn[maxn],stac[maxn],color[maxn];
bool vis[maxn],sign[maxn];
void tarjan(int u){
    deep+=1;
    dfn[u]=deep;
    low[u]=deep;
    top++;
    vis[u]=true;
    stac[top]=u;
    for(int i=head[u];i;i=e[i].next )
        if(!sign[i]){
            sign[i]=true,sign[i^1]=true;
            int v=e[i].v ;
            if(!dfn[v]){
                tarjan(v);
                if(low[v]<low[u])low[u]=low[v];
            }
            else {
                if(vis[v]){
                    if(low[v]<low[u])low[u]=low[v];
                }
            }
    }
    if(low[u]==dfn[u]){
        num+=1;
        vis[u]=false;
        color[u]=num;
        while(stac[top]!=u){
            color[stac[top]]=num;
            vis[stac[top]]=false;
            top--;
        }
        top--;
    }
}//“改良”tarjan
int n,m,ans;
struct edge_out{
	int from,to;
}edge_ans[maxn];//结构体存答案
bool cmp(edge_out a,edge_out b){
	if(a.from ==b.from )return a.to <b.to ;
	else return a.from <b.from ;
}//自定义比较函数
int main(){
    scanf("%d%d",&n,&m);
    int x,y;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i])tarjan(i);
    
    int k=1;
    for(int i=1;i<=n;i++){
        for(int j=head[i];j;j=e[j].next ){
            int v=e[j].v ;
            if(color[v]!=color[i]){
            	edge_ans[k].from =(v<i?v:i);
            	edge_ans[k++].to =(v>i?v:i); 
            }
        }
    }
    sort(edge_ans+1,edge_ans+k-1,cmp);
    for(int i=1;i<k;i+=2)printf("%d %d\n",edge_ans[i].from ,edge_ans[i].to );
    return 0;//完结散花！
}
```
悄咪咪地说一句：管理员大大辛苦啦，求通过！

---

## 作者：Zekrom (赞：13)

有了kkk的题解不知道自己的过不过得了  
~~还是得蹭一蹭~~  
显然数据范围允许使用枚举的方法  
当然tarjan算法能更快求出桥边  
为了满足题目的输出要求  
对桥边排序一下即可  
上代码 
```cpp
#include<iostream>
#include<cstdio>
#define N 160
#define	M 10010
#include<algorithm>
using namespace std;
int n,m,tot,cnt,dfn[N],head[N],num,tx,ty,low[N];
struct Edge{
	int u,v,next;
}edge[M];
struct Bridge{
	int u,v;  
}bridge[M];
bool cmp1(Bridge s1,Bridge s2){
	if(s1.u==s2.u)return s1.v<s2.v;
	return s1.u<s2.u;
}
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return  x*f;
}
inline void add(int x,int y){edge[++tot].u=x;edge[tot].v=y;edge[tot].next=head[x];head[x]=tot;}
void tarjan(int x,int in_edge){
	dfn[x]=low[x]=++num;
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].v;
		if(!dfn[y]){
			tarjan(y,i);
			low[x]=min(low[x],low[y]);
			if(dfn[x]<low[y]){
				if(x>y)tx=y,ty=x;
				else tx=x,ty=y;  //保证u<v
				bridge[++cnt].u=tx;bridge[cnt].v=ty;
			}
		}
		else if(i!=(in_edge^1))
			low[x]=min(low[x],dfn[y]);
	}
}
int main()
{
	n=read(),m=read();tot=1;
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i,0);
	sort(bridge+1,bridge+1+cnt,cmp1);//对桥边排序
	for(int i=1;i<=cnt;i++)
		printf("%d %d\n",bridge[i].u,bridge[i].v);
	return 0;
}

```


---

## 作者：zztlen (赞：13)

邻接表+SPFA+sort排序==AC
---

思路很简单，因为只炸一次，所以枚举每个点炸后还能否从起点到终点，不能的话就是一种答案。
```c
#include<bits/stdc++.h>
using namespace std;
int n,m,h[100001],x[10001],k,y[10001],num,vis[100001],ans[100001];
struct p2p{
    int a1,a2;
}a[200001];
struct pp{
    int nxt,dis,to;
}e[2000001];
bool cmp(p2p l,p2p r)
{
     if(l.a1==r.a1)
     return l.a2<r.a2;
     else
     return l.a1<r.a1;
}
void add(int f,int to)
{
    e[++num].nxt=h[f];
    e[num].to=to;
    e[num].dis=1;
    h[f]=num;
}//邻接表
void dfs(int x,int y)
{
    memset(ans,127,sizeof(ans));
    memset(vis,0,sizeof(vis));
    queue<int>q;
    q.push(x);
    ans[x]=0;
    vis[x]=1;
    while(!q.empty())
    {
        int w=q.front();
        q.pop();
        vis[w]=0;
        for(int i=h[w];i;i=e[i].nxt)
        {
            if(e[i].to==y&&w==x)
            continue;
            if(ans[e[i].to]>ans[w]+e[i].dis)
            {	
                ans[e[i].to]=ans[w]+e[i].dis;
                if(vis[e[i].to]==0)
                {
                    vis[e[i].to]=1;
                    q.push(e[i].to);
                }
            }
        }
    }//SPFA
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>x[i]>>y[i];
        add(x[i],y[i]);
        add(y[i],x[i]);
    }
    for(int	i=1;i<=m;i++)
    {
        dfs(x[i],y[i]);
        if(ans[y[i]]>100000000)
        {
            k++;
            a[k].a1=min(x[i],y[i]);
            a[k].a2=max(y[i],x[i]);
        }
    }//枚举
    sort(a+1,a+1+k,cmp);//排序
    for(int i=1;i<=k;i++)
    cout<<a[i].a1<<" "<<a[i].a2<<endl;
}
```

---

## 作者：北海_Beihai (赞：12)

# 本题正解：DFS求桥
所谓桥，就是无向图中如果删去这条边就会使图不连通的边。

另外，关于lambda表达式详见[这里](https://msdn.microsoft.com/zh-cn/library/dd293608.aspx)

上代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
inline int read(){	//快读
	char c;
	while((c=getchar())<48||c>57);
	int ret=c-48;
	while((c=getchar())>47&&c<58) ret=ret*10+c-48;
	return ret;
}
struct edge{
    int x,y;
};
int n,m,cnt,pre[200];
vector<int> g[200];
vector<edge> ans;	//记录结果
int dfs(int u,int fa){	//DFS求桥
    int lowu=pre[u]=++cnt;
    for(auto v:g[u]) //等同于 for(int i=0;i<g[u].size();i++){int v=g[u][i];/*...*/}
    	if(!pre[v]){
            int lowv=dfs(v,u);
            lowu=min(lowu,lowv);
            if(lowv>pre[u]) ans.push_back(u>v?edge{v,u}:edge{u,v});	//编号小的放前面
        }else if(pre[v]<pre[u]&&v!=fa) lowu=min(lowu,pre[v]);
    return lowu;
}
int main(){
	n=read();
	m=read();
	for(int i=1;i<=m;i++){	//建图
        int x=read(),y=read();
        g[x].push_back(y);
        g[y].push_back(x);
	}
	dfs(1,-1);	//求桥
	sort(ans.begin(),ans.end(),[&](const edge& a,const edge& b){return a.x<b.x||a.x==b.x&&a.y<b.y;});	//lambda表达式，这里相当于一个比较函数
	for(auto i:ans) printf("%d %d\n",i.x,i.y);
	return 0;
}
```

---

## 作者：浅色调 (赞：10)

###Kruskal特殊生成树###

**思路：**开始以为这是道送分题木，直接统计入度为0的不就好了吗？结果撸好代码一交只对了1个点，再仔细看题，发现不能这样做。题目要求的其实是有向图中的割边，正解应该是Tarjan，但是这道题数据如此之小，直接暴力搜索或者各种奇技淫巧来做。我这里用的是类似于Kruskal的算法来做的，实际上就是对边双关键字排序(因为输出要求)，然后枚举删除的一条边，按照Kruskal的方法去做看是否能生成生成树，若不能则输出一个答案(调试并查集调了我好久，太菜了～～)。时间复杂度O(m2)，完全能过。

**代码：**

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
using namespace std;
#define ll long long
#define il inline
#define inf 233333333
int n,m,fla,fa[250],tot;
struct edge{
int a,b;
}e[5200];
il bool cmp(edge a,edge b)
{
    if(a.a<b.a)return 1;
    if(a.a==b.a&&a.b<b.b)return 1;
    return 0;
}
il int find(int x)
{
    if(fa[x]!=x)fa[x]=find(fa[x]);
    return fa[x];
}
il void unionn(int x,int y)
{
    int a=find(x),b=find(y);
    if(a!=b)fa[a]=b,tot++;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
    scanf("%d%d",&e[i].a,&e[i].b);
    if(e[i].a>e[i].b)swap(e[i].a,e[i].b);
    }
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;i++)
    {
        tot=0;
        for(int j=1;j<=n;j++)fa[j]=j;
        for(int j=1;j<=m;j++){
        if(i!=j)unionn(e[j].a,e[j].b);
        if(tot==n-1)break;
        }
        if(tot!=n-1)printf("%d %d\n",e[i].a,e[i].b);
    }
    return 0;
}
```

---

## 作者：Sakura_Peng (赞：3)

原本是按照最短路的标签找题目来做的，~~没错tarjan我不会~~

然后就找到了这一题，但是仔细看看题目其实我认为用并查集来做会更易于理解简单一点吧。

我们来循环枚举每条铁路，然后每次把除了这条铁路外的其他铁路的点都用并查集存储起来。这个时候再用并查集来判断根节点为自己的结点有多少个

**如果根结点等于自己数量大于等于2（则说明至少有两颗子树），就说明如果不将这条铁路连起来会产生有结点不能通行，**

再输出。

输出有个坑点<a,b>，首先要按照a的大小顺序，如果a相同就按b的大小顺序。

而且如果a>b就要交换顺序，不交换顺序只能拿70。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
int n,a[1001][3],fa[1001],m,top;
struct CZP
{
	int x,y;
}c[10001];
int find(int x)
{
	if (x==fa[x])
	return x;
	else
	fa[x]=find(fa[x]);
	return fa[x];
}  //并查集路径压缩
int he(int x,int y)
{
	int x1=find(x),y1=find(y);
	if (x1!=y1)
	fa[y1]=x1;
}  //并查集将两个子树合并
void cs()
{
	for (int i=1;i<=n;i++)
	fa[i]=i;
	return ;
}
int cmp(CZP a,CZP b)
{
	if (a.x==b.x)
	return a.y<b.y;
	else
	return a.x<b.x;
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++)
		scanf("%d%d",&a[i][0],&a[i][1]);
		for (int i=1;i<=m;i++)
		{
			cs();
		    for (int j=1;j<=m;j++)
		    {
				if (i!=j)  //把除了是当前子树的树其他的都合并起来
					he(a[j][0],a[j][1]);
			}
			int t=0;
			for (int j=1;j<=n;j++)
			if (fa[j]==j)
			t++;
			
			if (t>=2)  //如果子树数量大于2就说明肯定有结点没有连接在一起
			{
				if(a[i][0]<a[i][1])
		    c[++top].x=a[i][0],c[top].y=a[i][1];
		    else
		     c[++top].x=a[i][1],c[top].y=a[i][0];  //注意<a,b>中a和b的大小顺序
		}
		}
		sort(c+1,c+top+1,cmp);  //按照题目要求排序输出
		for (int i=1;i<=top;i++)
		printf("%d %d\n",c[i].x,c[i].y);
		return 0;
}
```

---

## 作者：RPChe_ (赞：3)

首先申明，这是本蒟蒻在洛谷发的第一篇题解（呵呵呵）


------------
这是一道tarjan求桥（割边）的题目，但因为数据的原因，好像暴力dfs和暴力spfa都能过。

先看tarjan，因为之前的题解都写得很详细了所以直接给出关键部分
```cpp
void tarjan(int x,int fa)//当前点和其父节点
{
    dfn[x]=index1;
    low[x]=index1;
    index1++;
    for(int i=head[x];i!=-1;i=e[i].next)
    {
        if(!dfn[e[i].b])
        {
            tarjan(e[i].b,x);
            low[x]=min(low[x],low[e[i].b]);
            if(dfn[x]<low[e[i].b])//判断
            {
            	t++;
            	ans[t].a=min(x,e[i].b);
            	ans[t].b=max(e[i].b,x);
            }
        } else if(fa!=e[i].b) {
        	low[x]=min(low[x],dfn[e[i].b]);
    	}
    }
}//码风丑陋
```

顺便看一看复杂度O（n+m）和时间3ms

然后是暴力spfa，先建图，然后列举每条铁路被炸，并用spfa（或dfs）判断，附上20分bug代码（不想改了）
```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
priority_queue<int,vector<int>,greater<int> > pq;
struct sss{
    int a,b,v,next;
}e[500001];
int k=1,head[500001],dis[500001],vis[500001],f[500001];
int m,n;
void add(int a,int b,int v)//建图
{
    e[k].a=a;
    e[k].b=b;
    e[k].v=v;
    e[k].next=head[a];
    head[a]=k;
    k++;
}
void spfa(int x)//spfa
{
    dis[x]=0;
    vis[x]=1;
    pq.push(x);
    while(!pq.empty())
    {
        int temp=pq.top();
        pq.pop();
        vis[temp]=0;
        for(int i=head[temp];i!=-1;i=e[i].next)
        {
            if(dis[e[i].b]>dis[e[i].a]+e[i].v&&f[i]==0)
            {
                dis[e[i].b]=dis[e[i].a]+e[i].v;
                if(vis[e[i].b]==0)
                {
                    vis[e[i].b]=1;
                    pq.push(e[i].b);
                }
            }
        }
    }
}
int check()//判断
{
	for(int i=1;i<=n;i++)
	{
		if(dis[i]>=999999)
		return 1;
	}
	return 0;
}
int main()
{
    memset(head,-1,sizeof(head));
    cin>>m>>n;
    for(int i=1;i<=n;i++)
    {
        int a,b;
        cin>>a>>b;
        add(a,b,1);
        add(b,a,1);
    }
    for(int i=1;i<=m*2;i+=2)
    {
    	memset(f,0,sizeof(f));
    	memset(dis,9999999,sizeof(dis));
    	f[i]=1;
    	f[i+1]=1;
    	spfa(1);
    	if(check()==1)
    	cout<<min(e[i].a,e[i].b)<<" "<<max(e[i].a,e[i].b)<<endl;
	}
    return 0;
}
```
比tarjan还长，看一看复杂度O(mn^2)时间22ms ~~好慢~~ 如果用dfs应该会更慢。

对了，这道题好像还可以用kruskal，这里就不展示代码了，直接看复杂度O（m2）和时间3ms ~~好像也挺快~~

所以应该是tarjan优于kruskal优于暴力spfa

所以，要针对题目使用最合适的解法


---

## 作者：I_promise (赞：3)

这题范围好小。。。1亿多的复杂度居然能过。。

入正题

看到楼下大佬们的高深算法，本蒟蒻自叹不如

我用的方法是BFS

模拟每一条路都炸一次的情况，用BFS判断是否全联通

若不为全联通，则此路可以炸，输出

道路可先排序，避免字典序的问题

时间复杂度O(mn^2)，可能空跑的比较多，所以AC

代码如下：

···pas



```cpp
var a,b:array[1..5000] of longint;//道路下标
    c:array[1..150,1..150] of longint;//图
    d:array[1..150] of longint;//队列
    f:array[1..150] of boolean;//判断每个城市是否有路联通
    i,j,n,m,head,tail:longint;
procedure sort(l,r: longint);//道路快排，在此不多叙述
var i,j,x,y,z: longint;
begin
  i:=l;  j:=r;
  x:=a[(l+r) div 2]; z:=b[(l+r) div 2];
  repeat
    while (a[i]<x)or(a[i]=x)and(b[i]<z) do inc(i);
    while (x<a[j])or(a[j]=x)and(b[j]>z) do dec(j);
           if not(i>j) then
             begin
                y:=a[i]; a[i]:=a[j]; a[j]:=y;
                y:=b[i]; b[i]:=b[j]; b[j]:=y;
                inc(i); j:=j-1;
             end;
         until i>j;
         if l<j then sort(l,j);
         if i<r then sort(i,r);
      end;
begin
  read(n,m);//读入
  for i:=1 to m do
  begin
    read(a[i],b[i]);
    if a[i]>b[i] then
    begin
      j:=a[i]; 
      a[i]:=b[i];
      b[i]:=j;
    end;//题目要求输出时a<b,所以在这里预先调换好
    c[a[i],b[i]]:=1;
    c[b[i],a[i]]:=1;
  end;
  sort(1,m);//道路快排
  for i:=1 to m do
  begin
    f[1]:=false;
    for j:=2 to n do f[j]:=true;//从第一个城市开始BFS
    c[a[i],b[i]]:=0;
    c[b[i],a[i]]:=0;//炸掉铁路
    head:=0; tail:=1;
    d[1]:=1;//第一个城市入队
    repeat
      head:=head+1;
      for j:=1 to n do
      if (c[d[head],j]=1)and(f[j]) then//是否有路通向其他城市，若有路，则城市入队
      begin
        f[j]:=false;//城市get
        tail:=tail+1;//尾指针+1
        d[tail]:=j;//入队
      end;
    until head>=tail;
    for j:=1 to n do
    if f[j] then break;
    if f[j] then writeln(a[i],' ',b[i]);//若有城市没有遍历到，则输出这条铁路
    c[a[i],b[i]]:=1;
    c[b[i],a[i]]:=1;//补回铁路
  end;
end.
```
···

代码时间复杂度较高，勿喷


---

## 作者：天下至菜 (赞：2)

比较简单的题目

感觉不需要什么解释，就在代码里打一点注释

并查集做法

```
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,k) for(ll i=j;i<=k;i++)
#define F2(i,j,k) for(ll i=j;i>=k;i--)
using namespace std;
const ll N=155;
const ll M=5e3+5;
ll read(){//快读 
	ll f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){sum=(sum<<1)+(sum<<3)+(ch^48);ch=getchar();}
	return f*sum;
}
ll n,m,fa[N],a[M],b[M],cnt;
void cl(){F(i,1,n)fa[i]=i;}//对父亲数组进行清空 
struct node{ll x,y;}t[M];
ll find(ll x){if(x!=fa[x])fa[x]=find(fa[x]);return fa[x];}//找祖先 
ll cmp(node x,node y){if(x.x==y.x)return x.y<y.y;return x.x<y.x;}//按a大小排序，若a相同则按b排 
int main(){
	n=read();m=read();
	F(i,1,m){a[i]=read();b[i]=read();if(a[i]>b[i]){ll tt=a[i];a[i]=b[i];b[i]=tt;}} 
	F(i,1,m){
		cl();
		F(j,1,m){//并查集 
			if(i!=j){
				ll x=find(a[j]),y=find(b[j]);//找祖先 
				if(x!=y)fa[x]=y;//若祖先不同就合并 
			}
		}
		F(j,1,n-1)if(find(j)!=find(j+1)){t[++cnt].x=a[i];t[cnt].y=b[i];break;}//若有点的祖先不相同，则这种情况是合法的 
	}
	sort(t+1,t+cnt+1,cmp);
	F(i,1,cnt)printf("%lld %lld\n",t[i].x,t[i].y);
	return 0;
}
```
爆搜做法
```
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,k) for(ll i=j;i<=k;i++)
#define F2(i,j,k) for(ll i=j;i>=k;i--)
using namespace std;
const ll N=155;
const ll M=5e3+5;
ll read(){//快读 
	ll f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){sum=(sum<<1)+(sum<<3)+(ch^48);ch=getchar();}
	return f*sum;
}
ll n,m,head[N],tot,a[M],b[M],v[N],cnt;
struct node{ll to,next;}t[M<<1];
struct node2{ll x,y;}jl[M];
void add(ll x,ll y){t[++tot].to=y;t[tot].next=head[x];head[x]=tot;}//建边 
ll cmp(node2 x,node2 y){if(x.x==y.x)return x.y<y.y;return x.x<y.x;}//按a排序，若a相同则按b排序 
void dfs(ll x,ll fath){v[x]=1;for(ll i=head[x];i;i=t[i].next)if(t[i].to!=fath&&!v[t[i].to])dfs(t[i].to,x);}//dfs遍历 
int main(){
	n=read();m=read();
	F(i,1,m){a[i]=read();b[i]=read();if(a[i]>b[i]){ll tt=a[i];a[i]=b[i];b[i]=tt;}}
	F(i,1,m){
		memset(head,0,sizeof(head));memset(v,0,sizeof(v));tot=0;//清空数组 
		F(j,1,m)if(i!=j)add(a[j],b[j]),add(b[j],a[j]);//建边 
		dfs(1,1);//以1为起始遍历点 
		F(j,1,n)if(!v[j]){jl[++cnt].x=a[i];jl[cnt].y=b[i];break;}//若有点未被遍历到，则这种情况合法
	}
	sort(jl+1,jl+cnt+1,cmp);
	F(i,1,cnt)printf("%lld %lld\n",jl[i].x,jl[i].y);
	return 0;
}
```


---

## 作者：Iowa_BattleShip (赞：2)

刚看这题时，只觉得这题怎么这么简单，记一下入度为0的点不就ok了？然后就火急的跑去敲代码，一交，怎么才拿了一个点？？回去好好看题目又结合题解，我才知道这是找割线(佩服自己的读题能力……)。不过这题其实不用什么并查集压缩或是什么Tu啥的算法，因为数据比较小，我们可以直接枚举每一条边，并割掉它，然后就遍历一遍图，看能否连通，不行就加到keyroad里面，具体还是看代码吧

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct bi{//用来记录keyroad的结构体，定结构体主要是为了排序方便
    int x,y;
};
bi b[5010];
int a[200][5010],c[200][200],v[200];//这里我用的是邻接矩阵存储，主要是因为我邻接表打的不多，怕一不小心就搞错，就用了矩阵
int comp(bi c,bi d)//sort的comp函数，定义如何排序结构体，其实也可以在结构体里重载<来实现，不过一般我习惯用comp
{
    if(c.x==d.x)
        return c.y<d.y;
    return c.x<d.x;
}
void dfs(int x)//用深搜遍历整个图
{
    int i;
    v[x]=1;//记录这个点已经走过
    for(i=1;i<=a[x][0];i++)//把能走的点全部走一边
        if(!v[a[x][i]])
            dfs(a[x][i]);
    return;
}
int main()
{
    int i,j,n,m,x,y,k,l=0,p;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        a[x][++a[x][0]]=y;//为了节约空间就用无用的0下标来储存度
        a[y][++a[y][0]]=x;
    }
    for(i=1;i<=n;i++)//开始枚举每条边
        for(j=1;j<=a[i][0];j++)
            if(a[i][j]&&!c[i][a[i][j]]&&!c[a[i][j]][i])//如果有路且没有删过
            {
                c[i][a[i][j]]=c[a[i][j]][i]=1;//c数组是用来记录这条边有没有被删过，因为图是无向图，以减少枚举数量
                for(k=1;k<=a[a[i][j]][0];k++)//找到对应的点所指向这个点的下标
                    if(a[a[i][j]][k]==i)
                        break;
                p=a[i][j];//记录原来对应点
                a[i][j]=a[p][k]=0;//删去这条边，因为没有0这个点，所以定为0
                dfs(1);//深搜遍历
                a[i][j]=p;//回溯，把边连回上去
                a[p][k]=i;
                p=0;
                for(k=1;k<=n;k++)//搜每个点，看有没有经过，没有就说明这条边是keyroad，将其加入答案，同时进行v数组清零
                {
                    if(!v[k]&&!p)
                    {
                        b[++l].x=min(i,a[i][j]);
                        b[l].y=max(a[i][j],i);
                        p=1;
                    }
                    v[k]=0;
                }
            }
    sort(b+1,b+l+1,comp);//排序答案
    for(i=1;i<=l;i++)
        printf("%d %d\n",b[i].x,b[i].y);//最后输出，end
    return 0;
}
```

---

## 作者：清风我已逝 (赞：1)

不会Tarjan怎么办？

n，m(1<=n<=150, 1<=m<=5000)

可以观察到数据很小

完全可以对每一个边进行一次SPFA

```cpp
#include<bits/stdc++.h>

#define N 50005

using namespace std;


int n,m,tot,head[N];

struct node{
	int u,v;
}sx[N];
struct snode{
	int to,next;
}e[N];
void add(int u,int v){
	e[++tot].to=v;e[tot].next=head[u];head[u]=tot;
	e[++tot].to=u;e[tot].next=head[v];head[v]=tot;
}

bool cmp(node A,node B){
	if(A.u!=B.u) return A.u<B.u;
	else return A.v<B.v;
}

bool spfa(int x,int y){
	bool vis[N];int d[N];
	memset(vis,0,sizeof(vis));memset(d,0x7f,sizeof(d));
	queue<int>q;q.push(x);d[x]=0;vis[x]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u],v;i,v=e[i].to;i=e[i].next){
			if(u!=x||v!=y){
				if(d[v]>100000){
					d[v]=1;q.push(v);vis[v]=1;
				}
			}
		}
	}for(int i=1;i<=n;i++){
		if(d[i]>100000) return true;
	}return false;
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>sx[i].u>>sx[i].v;
		int a=sx[i].u,b=sx[i].v,c;
		if(a>b) {
			sx[i].u=b;sx[i].v=a;
		}
		add(sx[i].u,sx[i].v);
	}sort(sx+1,sx+1+m,cmp);
	for(int i=1;i<=m;i++){
		if(spfa(sx[i].u,sx[i].v)==1){
			cout<<sx[i].u<<" "<<sx[i].v<<"\n";
		}
	}return 0;
}
```

---

## 作者：方方小逗逼 (赞：1)

关键路径，pascal的一发题解，

模拟，搜索，迪杰斯特拉（算半个动规吧，最短路的算法，但这里不用来求最短路），

模拟：模拟它炸铁路；

搜索：搜索它炸铁路的所有可能，穷举i(i<=n)，将a[i]到b[i]视为非通路；

迪杰斯特拉：求1点能否到达每一个点，若能，则任意两点至少可以通过1点联通；若不能，则铁路i为关键路径(一组解)。

```cpp
var
  a,b,d,e,f,g:array [1..1000] of longint;
  c:array [1..150,1..150] of longint;
  n,m,i,j,k,h,hh:longint;
begin
  read(n,m);
  for i:=1 to m do
  begin
    read(a[i],b[i]);
    c[a[i],b[i]]:=1;
    c[b[i],a[i]]:=1;
  end;
  for k:=1 to m do
  begin
    c[a[k],b[k]]:=0;
    c[b[k],a[k]]:=0;
    fillchar(d,sizeof(d),0);
    fillchar(e,sizeof(e),0);
    d[1]:=1;
    for i:=1 to n do e[i]:=c[1,i];
    e[1]:=1;
    e[n+1]:=1;
    for i:=1 to n-1 do
    begin
      for j:=1 to n+1 do
        if (d[j]=0)and(e[j]=1) then break;
      if j=n+1 then
      begin
        inc(h);
        if a[k]<b[k] then
        begin
          f[h]:=a[k];
          g[h]:=b[k];
        end
          else
        begin
          f[h]:=b[k];
          g[h]:=a[k];
        end;
        break;
      end;
      d[j]:=1;
      for hh:=1 to n do
        if c[j,hh]=1 then e[hh]:=1;
    end;
    c[a[k],b[k]]:=1;
    c[b[k],a[k]]:=1;
  end;
  for i:=1 to h-1 do
    for j:=i+1 to h do
      if (f[i]>f[j])or(f[i]=f[j])and(g[i]>g[j]) then
      begin
        k:=f[i];
        f[i]:=f[j];
        f[j]:=k;
        k:=g[i];
        g[i]:=g[j];
        g[j]:=k;
      end;
  for i:=1 to h do writeln(f[i],' ',g[i]);
end.

```

---

## 作者：lych (赞：1)

由于本题数据不是很强，所以枚举每一条边，看看删掉以后会不会有两个城市不连通。建议使用克鲁斯克算法。

```delphi
var
  f:array[0..200] of longint;
  n,m,i,j,x1,y1:longint;
  x,y:array[0..5000] of longint;
function getfather(xx:longint):longint;
begin
  if f[xx]=xx then exit(xx) else
    f[xx]:=getfather(f[xx]);
  exit(f[xx]);
end;//并查集路径压缩
procedure swap(var a,b:longint);
var
  t:longint;
begin
  t:=a;
  a:=b;
  b:=t;
end;//交换两个元素
procedure qsort(r,l:longint);
var
  i,j,m1,m2:longint;
begin
  i:=r; j:=l;
  m1:=x[(i+j) shr 1];
  m2:=y[(i+j) shr 1];
  repeat
    while (x[i]<m1) or (x[i]=m1) and (y[i]<m2) do inc(i);
    while (x[j]>m1) or (x[j]=m1) and (y[j]>m2) do dec(j);
    if i<=j then
      begin
        swap(x[i],x[j]);
        swap(y[i],y[j]);
        inc(i); dec(j);
      end;
  until i>j;
  if i<l then qsort(i,l);
  if r<j then qsort(r,j);
end;//快排
begin
  readln(n,m);
  for i:=1 to m do
    begin
      readln(x[i],y[i]);
      if x[i]>y[i] then swap(x[i],y[i]);//令x[i]<=y[i]
    end;
  qsort(1,m);
  for i:=1 to m do
    begin
      for j:=1 to n do
        f[j]:=j;//建立n棵树
      for j:=1 to m do
        if i<>j then//不能有i这条边
          begin
            x1:=getfather(x[j]);
            y1:=getfather(y[j]);
            if x1<>y1 then//不是同一颗树
              f[y1]:=f[x1];//合并
          end;
      x1:=getfather(1);//1所在的树的根节点
      for j:=2 to n do
        if f[getfather(j)]<>x1 then//不同的树
          begin
            writeln(x[i],' ',y[i]);
            break;//输出并退出
          end;
    end;
end.
```

---

## 作者：坚决杀毒2008 (赞：1)

从运行时间来看，本题数据根本没有题面说的那么大……

所以STL想怎么用怎么用。可以用堆(prioriry\_queue)结合pair轻松实现题目从小到大排序输出的要求。

每次选定一条边，把它去除后对图进行dfs判断连通性，若无法连通将边两个参数(from,to)加入堆（输入边时把编号小的点当作from记录）。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<map>
#include<vector>
#include<queue>
using namespace std;
int n,m,vis[205],ans;
typedef pair<int,int> P;
priority_queue<P,vector<P>,greater<P>  >pque;
vector<int> g[205];
struct edge
{
    int from;
    int to;
}e[5001];
void dfs(int v,int b)
{
    vis[v]=1;
    int from=e[b].from,to=e[b].to;
    for(int i=0;i<g[v].size();i++)
    {
        if(v==e[b].from&&g[v][i]==e[b].to)continue;
        if(vis[g[v][i]])continue;
        dfs(g[v][i],b);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        e[i].from=min(a,b),e[i].to=max(a,b);
        g[a].push_back(b);
        g[b].push_back(a);
    }
    for(int i=1;i<=m;i++)
    {
        memset(vis,0,sizeof(vis));
        dfs(1,i);
        for(int j=1;j<=n;j++)
        {
            if(!vis[j])
            {
                pque.push(make_pair(e[i].from,e[i].to));
                break;
            }
        }
    }
    while(!pque.empty())
    {
        P p = pque.top();
        pque.pop();
        printf("%d %d\n",p.first,p.second);
    }
    return 0;
}
```

---

## 作者：Ydkwia (赞：0)

对于此题，由于习惯性没有先看数据大小就直接去想题了，导致一开始就认为很难，结果一看数据大小，才5000  QAQ ，想都没想就直接暴力枚举了。



------------
答题思路就是利用并查集来判断每一条边是否可行~~可放炸弹~~。

首先枚举每一条边，然后假设把这条边炸了，再来一轮并查集，判断一下剩下的边是否能连通~~判断一下是否所有的**祖先是否相同~~，若连通，则说明炸着条边没用；若不连通，则说明炸着条边有用。

至于输出顺序，可以在读进来时排个序，也可以在答案算出来后再排序，根据个人习惯而定。

时间复杂度o(m^2) 尽管效率不高，但数据范围小，还是能过的。

以下是代码
```cpp
#include<bits/stdc++.h>

using namespace std ;

int fa[ 222 ] , n , m , x , y , z ;

int read_h[ 5555 ] , read_t[ 5555 ] , num[ 5555 ] ;

bool cmp( int x , int y )
{
	
	return ( ( read_h[ x ] < read_h[ y ] ) || ( ( read_h[ x ] == read_h[ y ] ) && ( read_t[ x ] < read_t[ y ] ) ) ) ;
	
}

int find( int now )
{
	
	if ( ! fa[ now ] ) return now ;
	
	fa[ now ] = find( fa[ now ] ) ;
	
	return fa[ now ] ;
	
}

int main()
{
	
	scanf( "%d%d" , &n , &m ) ;
	
	for ( int i = 1 ; i <= m ; i ++ ) 
	{
		
		scanf( "%d%d" , &read_h[ i ] , &read_t[ i ] ) , num[ i ] = i ;
		
		if ( read_h[ i ] > read_t[ i ] ) swap( read_h[ i ] , read_t[ i ] ) ;
		
	}
	
	sort( num + 1 , num + 1 + m , cmp ) ;

	for ( int i = 1 ; i <= m ; i ++ )
	{
		
		memset( fa , 0 , sizeof( fa ) ) ;
	
		for ( int j = 1 ; j <= m ; j ++ )
			if ( i - j )				
				if ( find( read_h[ num[ j ] ] ) != find( read_t[ num[ j ] ] ) ) fa[ find( read_t[ num[ j ] ] ) ] = find( read_h[ num[ j ] ] ) ;
						
		int ans = - 1 ;
						
		for ( int j = 1 ; j <= n ; j ++ )
			if ( ! fa[ j ] ) ans ++ ;
			
		if ( ans ) printf( "%d %d\n" , read_h[ num[ i ] ] , read_t[ num[ i ] ] ) ;
		
	}
	
	return 0 ;			
			
}









```


---


# 正方形计数

## 题目描述

给定平面上 $N$ 个点，你需要计算以其中 $4$ 个点为顶点的正方形的个数。注意这里的正方形边不一定需要和坐标轴平行。


## 说明/提示

对于 $20\%$ 的数据，满足 $1\leq N\leq 20$。

对于 $100\%$ 的数据，满足 $1\leq N\leq 500$，$-50\leq X_i, Y_i\leq 50$，点不会重合。

## 样例 #1

### 输入

```
7
0 0
0 1
1 0
1 1
1 2
2 1
2 2```

### 输出

```
3```

# 题解

## 作者：Huami360 (赞：28)

不知道为什么$O(n^4)$的玄学方法能过，正解显然是$O(n^2)$的，枚举对角线，然后算出另外两点判断存不存在。

关键就在怎么通过对角线算出另外两点的坐标。

先贴公式。
```
int midx = (x[i] + x[j]) / 2;
int midy = (y[i] + y[j]) / 2;            
int x1 = midx - (midy - y[i]), y1 = midy + (midx - x[i]);
int x2 = midx + (midy - y[i]), y2 = midy - (midx - x[i]);
```
$(x[i],y[i]),(x[j],y[j])$是对角线的两个点，

$(x1,y1),(x2,y2)$是我们算出来的另两个点的坐标。

怎么来的呢？

如图，
![](https://cdn.luogu.com.cn/upload/pic/33411.png)

黑点是我们枚举的对角线，红点就是我们要算的另外两点。

我们算出对角线的重点$(midx,midy)$。

然后做几条辅助线，如图：
![](https://cdn.luogu.com.cn/upload/pic/33412.png)

图中的$OC$,$OB$是垂直于$x$轴和$y$轴，并不一定垂直于正方形的边。

易得△$ABO$ ≌ △$DCO$，于是，这两个三角形以$AB$,$CD$为底的高也相等，现在是不是就能理解这个公式了。

贴代码$O(n^2)$常数小
```cpp
#include <cstdio>
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
int n, ans;
int x[60000], y[60000], vis[1100][1100], xs[1100][1100];
int main(){
	Open("count");
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i){
		scanf("%d%d", &x[i], &y[i]);
		x[i] = (x[i] + 51) << 1; //防止负数和小数
		y[i] = (y[i] + 51) << 1;
		vis[x[i]][y[i]] = 1;
	}
	for(int i = 1; i < n; ++i)
		for(int j = i + 1; j <= n; ++j){
            int midx = (x[i] + x[j]) / 2;
            int midy = (y[i] + y[j]) / 2;            
            int x1 = midx - (midy - y[i]), y1 = midy + (midx - x[i]);
            int x2 = midx + (midy - y[i]), y2 = midy - (midx - x[i]);
            if(x1 <= 0) continue; if(x2 <= 0) continue;
            if(y1 <= 0) continue; if(y2 <= 0) continue; 
            if(vis[x1][y1] && vis[x2][y2]) ++ans;
        }
	printf("%d\n", ans >> 1);
	return 0;
}

```

---

## 作者：MZW_BG (赞：20)

[题面](https://www.luogu.org/problemnew/show/P1665)

这是一道大水题

当然，可以用搜索什么的过，但是会慢一点

那么我们来理一理思路

我们枚举每一个可能正方形的对角线

首先我们有这样的一个正方形：

![](https://img-blog.csdnimg.cn/20190505153343764.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTczNjY4,size_16,color_FFFFFF,t_70)

其中黑色的两个点是确定的，我们要得到另外两个红点的坐标……

~~使用毕达哥拉斯平方定理！使用锐角三角正切函数！求出斜率！暴力代入！~~ 这些方法会损精度的……

我们要用一种挺巧妙的方法：

连原来的两个点，求出中点：

![](https://img-blog.csdnimg.cn/20190505154138298.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTczNjY4,size_1,color_FFFFFF,t_70)

然后从终点向x,y轴各引一条垂线与正方形的边相交

我们很容易就会证到

![](https://img-blog.csdnimg.cn/20190505154958697.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTczNjY4,size_16,color_FFFFFF,t_70)
图中两个上色的三角形全等。

然后就很容易明白两条蓝线等长了啦QωQ

上面那条蓝线就是中点和另一个点的纵坐标差，

下面那条就是中点和待求点的横坐标差了，

酱紫就可以由中点坐标求到两个红点的纵坐标了嘛！

求横坐标也是如此啦……

---

然后呢，接下来有两种做法：

第一是用哈希表来找求出来的两个红点有没有出现过

第二是用一个布尔数组来存每个坐标是否有点

当然哈希会省点内存而且能处理带小数的情况

但是我很懒QωQ就用第二种了

---

还要注意一点！

在枚举时会把原来当过红点的点重新算一遍

所以最终答案要除以二



```cpp
#include<cstdio>
#include<cstring>
using namespace std;
struct point
{
	int x,y;//为什么不用double呢？因为由全等可以证明：当一个正方形两点都在整数坐标上时，
	//其他两点也会在整点上
}a[510];
bool v[310][310];
int main()
{
	int n;scanf("%d",&n);
	int ans=0;
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y),
		(a[i].x+=51)<<=1,(a[i].y+=51)<<=1,//防止负数，另外还要防止中点出现小数坐标
		v[a[i].x][a[i].y]=1;
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			int xmid=(a[i].x+a[j].x)>>1,ymid=(a[i].y+a[j].y)>>1;//中点的坐标
			int x1=xmid-(a[i].y-ymid),y1=ymid-(xmid-a[i].x);//这是下面那个点
			int x2=xmid+(a[i].y-ymid),y2=ymid+(xmid-a[i].x);//上面那个点明显就是反过来的啦
			if(0<=x1&&x1<=300&&0<=y1&&y1<=300&&0<=x2&&x2<=300&&0<=y2&&y2<=300)
				if(v[x1][y1]&&v[x2][y2])ans++;
		}
	printf("%d",ans>>1);
	return 0;
}
```

有问题欢迎私信哦QωQ

---

## 作者：枫羽晨 (赞：9)

考试的时候发现大法师也可以过，思路并不难，就是直接暴力搜索，搜两个定点，计算３、４是否存在就可以了

我是按照第一个点在第二个点左上方（平行也算）进行寻找，尽量避免了重复寻找，同时节省一下时间。

蒟蒻第一次发题解。

```cpp
#include<bits/stdc++.h>
#define IL inline
#define open(s) freopen(s".in", "r", stdin);// freopen(s".out", "w", stdout);
#define ll long long
#define ull unsigned long long
#define max(a, b) a > b ? a : b;
#define min(a, b) a < b ? a : b;
using namespace std;

int n, ans;
int mp[110][110];
bool b[500][500];
struct date
{
    int x, y;
}a[510];
date c[110];

IL int read();
IL bool cmp(date, date);
IL void check();
void dfs(int, int);

int main()
{
    n = read();
    for (int i=1; i<=n; ++i)
    {
        a[i].x = read(); a[i].y = read();
        a[i].x += 50; a[i].y += 50;
        b[a[i].x][a[i].y] = 1;
    }
    sort(a+1, a+n+1, cmp);
    dfs(0, 1);
    cout << ans << endl;
    return 0;
}

void dfs(int x, int j)
{
    if (x == 2)
    {
        check();
        return;
    }
    for (int i=j; i<=n; ++i)
    {
        if (x > 0 && c[0].x == a[i].x) continue;
        if (x > 0 && c[0].y < a[i].y) continue;
        c[x] = a[i];
        dfs(x+1, i+1);
    }
}

void check()
{
	int ax, ay;
	ax = c[0].y + c[0].x - c[1].y;
	ay = c[1].x + c[0].y - c[0].x;
	int bx, by;
	bx = c[1].x + c[0].y - c[1].y;
	by = c[1].x - c[0].x + c[1].y;
	if (b[ax][ay] && b[bx][by])
		ans++;
}

bool cmp(date x, date y)
{
	if (x.x < y.x) return 1;
	else if (x.x == y.x) return x.y < y.y;
	return 0;
}

int read()
{
    int i = 1, j = 0;
    char x = getchar();
    while (x < '0' || '9' < x)
    {
        if (x == '-') i = -1;
        x = getchar();
    }
    while ('0' <= x && x <= '9')
    {
        j = j * 10 + x - '0';
        x = getchar();
    }
    return i*j;
}
```

---

## 作者：封禁用户 (赞：7)

题意已经很清楚了，就是给你几个点，让你找正方形。

初看题目，第一个想到的肯定是暴力。

复杂度：$O(n^4)$

就是套个四重循环，枚举四个点，判断他们之间的距离是否相等。

都知道，两点之间的距离公式为欧几里得距离，即$\sqrt{(x1-x2)^2+(y1-y2)^2}$ ，那就开始暴力吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
double d1,d2,d3,d4;
struct eee {
    int a,b;
};
eee t[10001];
inline bool cmp(eee x,eee y) {
    if(x.a!=y.a) return x.a<y.a;
    else return x.b<y.b;
}
int main() {
    scanf("%d",&n);
    for(int i=1; i<=n; ++i) scanf("%d%d",&t[i].a,&t[i].b),t[i].a+=50,t[i].b+=50;
    sort(t+1,t+n+1,cmp);
    for(register int i=1; i<n-2; ++i)
        for(register int j=i+1; j<n-1; ++j)
            for(register int k=j+1; k<n; ++k)
                for(register int q=k+1; q<=n; ++q) {
                    d1=sqrt((t[j].a-t[i].a)*(t[j].a-t[i].a)+(t[j].b-t[i].b)*(t[j].b-t[i].b));
                    d2=sqrt((t[k].a-t[i].a)*(t[k].a-t[i].a)+(t[k].b-t[i].b)*(t[k].b-t[i].b));
                    d3=sqrt((t[q].a-t[j].a)*(t[q].a-t[j].a)+(t[q].b-t[j].b)*(t[q].b-t[j].b));
                    d4=sqrt((t[q].a-t[k].a)*(t[q].a-t[k].a)+(t[q].b-t[k].b)*(t[q].b-t[k].b));
                    if(d1==d2&&d2==d3&&d3==d4) m++;
                }
    printf("%d\n",m);
    return 0;
}
```

代码很壮观，但是分数不好看，只有50。

~~估计是数据加强过了。~~

正解，应该是计算几何。

复杂度：$O(n^2)$

思路是确定两个点，然后通过找规律判断其余两个点是否存在。

![](https://cdn.luogu.com.cn/upload/image_hosting/jdyrtzmy.png)

看一下这张图，理解一下规律：

若点$A$ 的坐标用$a,aa$ 表示，点$B$ 的坐标用$b,bb$ 表示,点$C$ 和点$D$ 也以此类推，则：
```cpp
c=bb-aa+a;
cc=a-b+aa;
d=b+bb-aa;
dd=a-b+bb;
```

（注意四个点不一定是图上的点）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long q,p,d,dd,e,ee,c,cc,f,ff,a[5001],b[5001];
bool k[5001][5001];
int main() {
    scanf("%d",&n);
    for(int i=1; i<=n; i++) {
        cin>>q>>p;
        a[i]=q+50;
        b[i]=p+50;
        k[a[i]][b[i]]=true;//标记每个点的位置
    }
    for(int i=1; i<=n; ++i) {
        for(int j=1; j<=n; ++j) {
            if(i==j) continue;
            c=a[i];
            cc=b[i];
            f=a[j];
            ff=b[j];
            d=ff-cc+c;
            dd=c-f+cc;
            e=f+ff-cc;
            ee=c-f+ff;
            if(e==d&&dd==ee||e<0||d<0||ee<0||dd<0) continue;//这句一定要加上，数据范围有坑！
            if(k[d][dd]==true&&k[e][ee]==true) m++;//若两个点存在，方案数+1
        }
    }
    printf("%d\n",m/4);//算了4次，就除以四
    return 0;
}
```

>希望管理员能将数据范围修改一下，卡了我30多次，是因为数组越界。

---

## 作者：lamboo (赞：4)

本道题目的关键在于——找规律

我们只需要两个点的对角线

就可以求出另外两个点


规律：

设第一个点的坐标为x1，y1

第二个点的坐标为x2，y2

第三个点的坐标为x3，y3

第四个点的坐标为x4，y4

那么
 
x3:=y2-y1+x1;y3:=x1-x2+y1;  

x4:=x2+y2-y1;y4:=x1-x2+y2;

附代码：

var n,x,y,i,x1,x2,x3,x4,y1,y2,y3,y4,minx,miny,maxx,maxy,sum:longint;

```cpp
    f:array[-500..500,-500..500] of boolean;
begin
readln(n);
minx:=maxlongint;maxx:=-maxlongint;
miny:=maxlongint;maxy:=-maxlongint;  //赋初值
for i:=1 to n do
  begin
  readln(x,y);
  f[x,y]:=true;  //表示这个点出现过了
  if x<minx then minx:=x;  //行最小
  if x>maxx then maxx:=x;  //行最大
  if y<miny then miny:=y;  //列最小
  if y>maxy then maxy:=y;  //列最大
  end;
for x1:=minx to maxx do  //暴力枚举
  for y1:=miny to maxy do if f[x1,y1] then  //枚举第一个点的位置
    for x2:=minx to maxx do
      for y2:=miny to maxy do
        if ((x1<>x2) or (y1<>y2)) and (f[x2,y2]) then  //枚举第二个点的位置，并判断有没有和第一个点重复
          begin
          x3:=y2-y1+x1;y3:=x1-x2+y1;  //找规律得出第三个点
          x4:=x2+y2-y1;y4:=x1-x2+y2;  //找规律得出第四个点
          if (f[x3,y3]) and (f[x4,y4]) and ((x3<>x4) or (y3<>y4)) then sum:=sum+1;  //判断第三第四个点有没有出现且是否重复
          end;
writeln(sum div 4);  //每个正方形找了4次，所以 div 4
end.
```

---

## 作者：贞白铁战逸 (赞：3)

##     我用了STL中的set做这题。
  ** 在平面直角坐标系中，只要知道两个点的坐标，就能以此为边作两个三角形。
    设两点坐标为（x1, y1）,（x2, y2），那么另外两点坐标有两种情况： **
    
    1.（x1-y2+y1, y1+x2-x1）， （x2-y2+y1, y2+x2-x1）。
    
    2.（x1+y2-y1, y1-x2+x1）， （x2+y2-y1, y2-x2+x1）。
    
   **将读入的点存入集合，再判断另外两点是否也在集合中。
   另外，代码中会重复计算，所以最后结果要除以4.
   一下是代码： **

------------
```
#include <cstdio>
#include <set>
#include <iostream>
using namespace std;
double a[2000][2000], v[2000][2000], maxx = 0;
struct node
{
	int x, y;
};
bool operator < (node q, node w)
	{
	    if (q.x != w.x) return q.x > w.x;
	    else return q.y > w.y;
	} 
set <node> q;
set <node>::iterator it1, it2, fz1, fz2;//迭代器别忘了定义
int n, m;
int main()
{
	int i, j, k, l, x, y, s = 0;
	int x1, y1, x2, y2;
	scanf("%d", &n);
	for (i = 1; i<=n; i++)
	{
		scanf("%d %d", &x, &y);
	    q.insert((node){x, y});//将点存入集合
	}
	fz1 = q.end();
	fz1--;
	for (it1 = q.begin(); it1!=fz1; it1++)
	{
	    fz2 = it1;
	    fz2++;
		for (it2 = fz2; it2!=q.end(); it2++)
	    {
	    	x1 = (*it1).x;
	    	y1 = (*it1).y;
	    	x2 = (*it2).x;
	    	y2 = (*it2).y;
	    	node v1 = (node){x1-y2+y1, y1+x2-x1}, v2 = (node){x2-y2+y1, y2+x2-x1};//判断第一种情况
	    	if (q.count(v1) == 1 && q.count(v2) == 1) s++;
	    	node r1 = (node){x1+y2-y1, y1-x2+x1}, r2 = (node){x2+y2-y1, y2-x2+x1};//判断第二种情况
	    	if (q.count(r1) == 1 && q.count(r2) == 1) s++;
		}
	}
	printf("%d", s/4);//结果除以4
}
```


------------



---

## 作者：Tgotp (赞：3)

#正方形计数1665

\*方法

先排序，按横坐标大小排序，若是一样，则把纵坐标大的排前面；

然后判定是否正方形，四边相等且对角线相等就一定是咯-此时就ans++；

`'
    
      
    
```cpp
    #include<iostream>
    #include<algorithm>
    #include<cstdio>
    using namespace std;
    const int N = 500 + 5;
    int a[N],b[N],r[N],n,s1,s2,s3,s4,s5,s6,ans; //s1,s2,s3,s4是四条边，s5,s6为两条对角线，ans记录答案个数
    bool cmp(int x,int y)  //排序
    {  
        if(a[x]!=a[y]) return a[x]<a[y];  
        return b[x]>b[y];  
    }  
    int len(int a,int b,int c,int d) //计算长度，勾股定律，但是都要开根，所以可以省去，直接比较平方 
    {
        return (c-a)*(c-a)+(d-b)*(d-b);  
    }  
    int main()
    {
        cin>>n;
        for(int i=0;i<n;i++)
        {
            scanf("%d%d",&a[i],&b[i]);
            r[i]=i;
        }
        sort(r,r+n,cmp);
        for(int i=0;i<n;i++)
        {
            for(int j=i+1;j<n;j++)
            {
                s1=len(a[r[i]],b[r[i]],a[r[j]],b[r[j]]);
                if(!s1)continue;
                for(int k=j+1;k<n;k++)
                {
                    s2=len(a[r[i]],b[r[i]],a[r[k]],b[r[k]]);
                    if(s1==s2)
                    for(int h=k+1;h<n;h++)
                    {
                        s3=len(a[r[k]],b[r[k]],a[r[h]],b[r[h]]);
                        s4=len(a[r[j]],b[r[j]],a[r[h]],b[r[h]]);
                                            s5=len(a[r[i]],b[r[i]],a[r[h]],b[r[h]]);
                                            s6=len(a[r[j]],b[r[j]],a[r[k]],b[r[k]]);
                        if(s2==s3 && s3==s4 && s5==s6) ans++;
                    }
                }
            }
        }
        cout<<ans; //输出答案
        return 0; 
}' `
```

---

## 作者：xiaozeyu (赞：2)

这只是一道普及-，

这只不过是

![](https://cdn.luogu.com.cn/upload/image_hosting/txj0eqrf.png)

**范围这么小，just so so--**

但是如果扩展一下，那就变得有意思了，一些方法就不能了

![](https://cdn.luogu.com.cn/upload/image_hosting/86n3t9xr.png)

这时就体现了**哈希等方法**的重要性，比赛时就需要这些能力来应对

**二维数组直接爆炸**

2* 10^3可以直接遍历

**x,y,就要用上next！**

```cpp
nxt[i]=m_hash[value];
m_hash[value]=i;
```

巧妙地像存路径一样把x+y相同的点联系起来，更快地处理

当然在这之前还要：

```cpp
struct m_point
{
	int x,y;
	bool operator <(const m_point &rhs) const
	{
		return x==rhs.x?y<rhs.y:x<rhs.x;
	}
}s[maxn],tmp;
                                
```

```cpp
int m_hash[array_size],nxt[maxn],n;
int f(int x,int y){return abs(x+y);}
void get_hash(int i){
	int value=f(s[i].x,s[i].y);
	nxt[i]=m_hash[value];
	m_hash[value]=i;
}
```

**如何取用呢？？** 

```cpp
bool check(int x,int y)
{
	int value=f(x,y),buckets=m_hash[value];
	while(buckets!=-1)
	{
		if((s[buckets].x==x)&&s[buckets].y==y) return true;
		buckets=nxt[buckets];
	}
	return false;
}
```
这在大范围中很好用

**因为边是双向的，所以最后输出答案要/2**


# 上代码



------------


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=6e3+10,array_size=2e4+10;
struct m_point
{
	int x,y;
	bool operator <(const m_point &rhs) const
	{
		return x==rhs.x?y<rhs.y:x<rhs.x;
	}
}s[maxn],tmp;
int m_hash[array_size],nxt[maxn],n;
int f(int x,int y){return abs(x+y);}
void get_hash(int i){
	int value=f(s[i].x,s[i].y);
	nxt[i]=m_hash[value];
	m_hash[value]=i;
}
bool check(int x,int y)
{
	int value=f(x,y),buckets=m_hash[value];
	while(buckets!=-1)
	{
		if((s[buckets].x==x)&&s[buckets].y==y) return true;
		buckets=nxt[buckets];
	}
	return false;
}
int new_x,new_y;
int main()
{
	freopen("rect.in","r",stdin);
	freopen("rect.out","w",stdout);
	cin>>n;int ans=0;
	memset(nxt,-1,sizeof nxt),memset(m_hash,-1,sizeof m_hash);
	for(int i=0;i<n;i++) cin>>s[i].x>>s[i].y;
	sort(s,s+n);
	for(int i=0;i<n;i++) get_hash(i);
	for(int i=0;i<n;i++)
		for(int j=i+1;j<n;j++)
		{
			tmp.x=s[j].x-s[i].x,tmp.y=s[j].y-s[i].y;
			new_x=s[i].x+tmp.y,new_y=s[i].y-tmp.x;
			if(!check(new_x,new_y)) continue;
			new_x=s[j].x+tmp.y,new_y=s[j].y-tmp.x;
			if(!check(new_x,new_y)) continue;
			ans++;
		}
	cout<<ans/2;
	return 0;
}

```


---

## 作者：Error_Eric (赞：2)

#### 前言

wow这道题还可以写题解！

#### 正文

我其实是想给新手们分享一下 ``#define`` 的作用，不喜勿喷。

其实这道题很暴力的，我们所需只是一些~~解析几何的基础知识~~和循环嵌套的基础知识。

思路：暴力枚举正方形的一个对角线的两个端点，求出另外两个端点的位置，判断是否存在即可。


借鉴了楼上的楼上的楼上的题解的优化思路（输入数据扩大防止出现小数和负数）

知识点：``#define`` 的用法：

>\#define 命令是 C 语言中的一个宏定义命令 ,它用来将一个标识符定义为一个字符串 , 该标识符被称为宏名, 被定义的字符串称为替换文本。该命令有两种格式:一种是简单的宏定义, 另一种是带参数的宏定义.
--[百度百科](https://baike.baidu.com/item/define/577777?fr=aladdin)

$Code:$

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#define zx_x (x[i]+x[j])/2 //重心的x坐标
#define zx_y (y[i]+y[j])/2 //重心的y坐标
#define dot3_x zx_x-(zx_y-y[i]) //dot3的x坐标
#define dot3_y zx_y+(zx_x-x[i]) //dot3的y坐标
#define dot4_x zx_x+(zx_y-y[i]) //dot4的x坐标
#define dot4_y zx_y-(zx_x-x[i]) //dot4的y坐标
#define legal (dot3_x>=0 and dot3_y>=0 and dot4_x>=0 and dot4_y>=0) //坐标合法
#define ok legal and map[dot3_x][dot3_y] and map[dot4_x][dot4_y] //存在这样的正方形
int n,ans,x[5000+50],y[5000+50],map[11100][11100];
int main(){
	scanf("%d",&n);//输入
	for(int i=1;i<=n;++i)//听说使用++i代替i++可以卡常
		scanf("%d%d",&x[i],&y[i]),x[i]=(x[i]+1000)<<1,y[i]=(y[i]+1000)<<1,map[x[i]][y[i]]=1;//输入,扩大,标记；
	for(int i=1;i<n;++i)//暴力枚举
		for(int j=i+1;j<=n;++j) ans+=(ok);//更新答案
	printf("%d\n",ans/2);//输出
	return 0;//结束
}

```

如果不使用 ``#define`` ,代码是这样的：

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
int n,ans,x[5000+50],y[5000+50],map[11100][11100];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d%d",&x[i],&y[i]),x[i]=(x[i]+1000)<<1,y[i]=(y[i]+1000)<<1,map[x[i]][y[i]]=1;
	for(int i=1;i<n;++i)
		for(int j=i+1;j<=n;++j) ans+=(((x[i]+x[j])/2-((y[i]+y[j])/2-y[i])>=0 and (y[i]+y[j])/2+((x[i]+x[j])/2-x[i])>=0 and (x[i]+x[j])/2+((y[i]+y[j])/2-y[i])>=0 and (y[i]+y[j])/2-((x[i]+x[j])/2-x[i])>=0) and map[(x[i]+x[j])/2-((y[i]+y[j])/2-y[i])][(y[i]+y[j])/2+((x[i]+x[j])/2-x[i])] and map[(x[i]+x[j])/2+((y[i]+y[j])/2-y[i])][(y[i]+y[j])/2-((x[i]+x[j])/2-x[i])]);
	printf("%d\n",ans/2);
	return 0;
}

```

---

## 作者：龙神哈迪斯 (赞：2)

## Sol
大家为什么要暴力模拟啊

为什么要用哈希啊

map虽然慢，但它是我们的好伙伴啊

O(n^2)的枚举正方形的一条边，然后通过手玩计算出其余两点坐标，看看是否在map中存在，由于正方形有四条边，每条边在枚举时都会记到一次，所以ans要除以4

至于点对就丢到pair里，pair在放到map里验证

由于考虑很少有这样的使用，所以写篇题解

然后就是激动人心的放代码时间了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
#define ll long long
#define rg register
#define pii pair<int,int> 
const int N=20000;
const int _=1005;
inline int read()
{
	char ch='!';int z=1,num=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')z=-1,ch=getchar();
	while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return z*num;
}
int n;
ll ans;
struct ha{
	int x,y;
	bool operator < (const ha &A)const{
		return y>A.y;
		if(y==A.y)return x<A.x;
	}
}e[_],g[5];
inline bool check(int a,int b,int x,int y)
{
	g[1]=e[a];g[2]=e[b];g[3]=e[x];g[4]=e[y];
	sort(g+1,g+5);
	rg double l1=(g[1].x-g[2].x)*(g[1].x-g[2].x)+(g[1].y-g[2].y)*(g[1].y-g[2].y);
	rg double l2=(g[2].x-g[4].x)*(g[2].x-g[4].x)+(g[2].y-g[4].y)*(g[2].y-g[4].y);
	rg double l3=(g[3].x-g[4].x)*(g[3].x-g[4].x)+(g[3].y-g[4].y)*(g[3].y-g[4].y);
	rg double l4=(g[1].x-g[3].x)*(g[1].x-g[3].x)+(g[1].y-g[3].y)*(g[1].y-g[3].y);
	if(l1!=l2||l1!=l3||l1!=l4||l2!=l3||l2!=l4||l3!=l4)return 0;
	l1=(g[1].x-g[4].x)*(g[1].x-g[4].x)+(g[1].y-g[4].y)*(g[1].y-g[4].y);
	l2=(g[2].x-g[3].x)*(g[2].x-g[3].x)+(g[2].y-g[3].y)*(g[2].y-g[3].y);
	if(l1!=l2)return 0;
	return 1;
}
void Get30()
{
	for(rg int i=1;i<=n;++i)
		for(rg int j=i+1;j<=n;++j)
			for(rg int k=j+1;k<=n;++k)
				for(rg int t=k+1;t<=n;++t)
					if(check(i,j,k,t))ans++;
	cout<<ans<<endl;
}
map<pii,bool>gg;
pair<int,int>T[_],A,B;
void Work()
{
	for(rg int i=1;i<=n;++i)
	{
		for(rg int j=i+1;j<=n;++j)
		{
			rg int a=T[i].first,x=T[j].first;
			rg int b=T[i].second,y=T[j].second;
			if(a>x)swap(x,a),swap(y,b);
			if(b>=y)
			{
				rg int aa=a+b-y,bb=b+x-a;
				rg int xx=x+b-y,yy=y+x-a;
				A.first=aa;A.second=bb;
				B.first=xx;B.second=yy;
				if(gg[A]&&gg[B])ans++;
				aa=x-b+y,bb=y-x+a;
				xx=a-b+y,yy=b-x+a;
				A.first=aa;A.second=bb;
				B.first=xx;B.second=yy;
				if(gg[A]&&gg[B])ans++;
			}
			else
			{
				rg int aa=x+b-y,bb=y+x-a;
				rg int xx=a+b-y,yy=b+x-a;
				A.first=aa;A.second=bb;
				B.first=xx;B.second=yy;
				if(gg[A]&&gg[B])ans++;
				aa=a-b+y,bb=b-x+a;
				xx=x-b+y,yy=y-x+a;
				A.first=aa;A.second=bb;
				B.first=xx;B.second=yy;
				if(gg[A]&&gg[B])ans++;
			}
		}
	}
	printf("%lld\n",ans/4);
}
int main()
{
	n=read();
	for(rg int x,y,i=1;i<=n;++i)
	{
		x=read()+N,y=read()+N;
		e[i]=(ha){x,y};
		T[i].first=x;T[i].second=y;
		gg[T[i]]=1;
	}
	if(n<=30)Get30();
	else Work();
	return 0;
}

```

---

## 作者：zhangziyi_xshsnoi (赞：1)

# ~~简单~~的三垂直问题
## **引入**
学过全等三角形的都知道三垂直

![三垂直](https://cdn.luogu.com.cn/upload/image_hosting/83fnezv9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图 
$AB=AC$且$AB \perp BC,AM\perp MB,CN\perp BN,BMN$三点共线

则易证$AM=BN,MB=CN$

## **把他用到坐标中，与正方形结合**

如图一

坐标系上有两点$A,B$。$A(2,4),B(4,0)$;

![01](https://cdn.luogu.com.cn/upload/image_hosting/sgbtl08f.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


如图二

坐标系上有另外两点C,D

![02](https://cdn.luogu.com.cn/upload/image_hosting/wa1bm7im.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$C(6,6),D(8,2)$使四边形ACBD为正方形

如图三

坐标系上另有两点C',D'

![03](https://cdn.luogu.com.cn/upload/image_hosting/y7ju4jq1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$C'(-2,2),D'(0,-2)$使四边形AC'BD'也是正方形

```cpp
struct node
{
	int x,y;
}num[3000];

A(num[i].x,num[i].y) B(num[j].x,num[j].y);
```

若使ABCD为正方形
则

```
C(num[i].x±(num[i].x-num[j].x),num[i].y±(num[j].y-num[i].y))

D（num[j].x±(num[i].x-num[j].x),num[j].y±(num[j].y-num[i].y)）
```

所以这道$\color{purple} \text{\textbf{黄题}}$最后只要判断C点，D点是否存在就行了


------------

# **上DM**
```cpp

#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int w=1,q=0;char ch=' ';
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')w=-1,ch=getchar();
    while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
    return w*q;
}//快读
struct node
{
	int x,y;
}num[3000];
map<pair<int,int>,int >mapp;//因为坐标有负数，所以用map+pair
int n,tot=0,ans=0;
int main()
{
	//freopen("rect.in","r",stdin);
	//freopen("rect.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{ 
		int a,b;
		a=read(),b=read();
		num[i].x=a,num[i].y=b;
		mapp[make_pair(a,b)]=1; 
	} 
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			int u,v;
			u=num[i].x-num[j].x;
			v=num[j].y-num[i].y;
			if(mapp[make_pair(num[i].x+v,num[i].y+u)]==1&&mapp[make_pair(num[j].x+v,num[j].y+u)]==1)
				ans++;
			if(mapp[make_pair(num[i].x-v,num[i].y-u)]==1&&mapp[make_pair(num[j].x-v,num[j].y-u)]==1)
				ans++;
		}
	printf("%d",ans/4);//一个正方形重复四遍，所以要除以4
}
```
//重新审核

//增加了Latex，求通过

//<蒟蒻的第一篇题解>

---

## 作者：柒命九陨_ (赞：1)

暴力枚举，看到题解里居然 O(n ^ 4) 算法都能过，惊了……

当时看到数据决定使用的是 O(n ^ 3) 算法：

1. 输入时坐标统一 +100 以处理负数，用 vis[x][y] = 1 记录(x, y)这个地方有点；

2. 先排序，借鉴下面题解的方法，也可以开结构体，按横坐标大小排序，若是一样，则把纵坐标大的排前面；

3. 枚举 3 个顶点，然后算出第 2 个点对于第 1 个点的横纵坐标相对位置，然后用第三个点和这个相对位置求出第四个点的位置，这样保证了一对对边平行且相等；

4. 这样，四个点的位置都知道了，用两点间距离公式求出这个四边形的对角线和一组邻边，易证 **对角线相等且一组邻边相等的平行四边形是正方形** 。

5. 最后要注意三重循环的起始与结束，避免重复情况。

详见代码：

```cpp
#include <queue>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 500 + 10;
int vis[maxn][maxn], x[maxn], y[maxn], r[maxn];

inline int Dist(int a, int b, int c, int d) {
  return (c - a) * (c - a) + (d - b) * (d - b);
}

inline bool Cmp(int a, int b) {  
  if( x[a] != x[b] ) return x[a] < x[b];
  return y[a] > y[b];
}

int main(int argc, char const *argv[])
{
  int n = 0, ans = 0;
  scanf("%d", &n);
  for(int i = 1; i <= n; ++i) {
    scanf("%d%d", &x[i], &y[i]);
    r[i] = i, x[i] += 200, y[i] += 200, vis[x[i]][y[i]] = 1;
  }
  sort(r + 1, r + n + 1, Cmp);
  for(int i = 1; i <= n; ++i) {
    for(int j = i + 1; j <= n; ++j) {
      int dx = x[r[i]] - x[r[j]], dy = y[r[i]] - y[r[j]];
      for(int k = j + 1; k <= n; ++k) {
        int tx = x[r[k]] - dx, ty = y[r[k]] - dy;
        if( !vis[tx][ty] ) continue;
        int e = Dist(x[r[i]], y[r[i]], tx, ty);
        int f = Dist(x[r[j]], y[r[j]], x[r[k]], y[r[k]]);
        int a = Dist(x[r[i]], y[r[i]], x[r[j]], y[r[j]]);
        int b = Dist(x[r[i]], y[r[i]], x[r[k]], y[r[k]]);
        if( e == f && a == b ) ++ans;
      }
    }
  }
  printf("%d\n", ans);

  printf("_______________________________________________\n");
  printf("Process Exited Correctly With A Return Value 0.\n");
  return 0;
}
```

---

## 作者：Konnyaku_LXZ (赞：0)

这题比较简单，思路看一眼就很明确了。

我们知道，当正方形的一条边确定以后，这个正方形有且仅有两种状态。所以很容易想到，双重循环枚举两个点组成正方形的一条边，然后分别计算出两种状态下的正方形的其他两点的坐标，判断是否有一个点的坐标刚好在这里即可。

由于坐标可能是负数，所以读入的时候将他们全都加上 $500$ 来保证非负。

时间复杂度：$O(N^2)$。

那么问题来了，如何计算剩下两点的坐标呢？我们由正方形想到等腰直角三角形，想到三垂直。于是我们可以通过构造三垂直，证明全等的方法来算出剩下两点的坐标，具体过程在这里就不演示了。

设枚举的两点坐标为 $A(x1,y1),B(x2,y2)$ ，则以 $AB$ 为边的正方形 $ABCD$ 中 $C,D$ 点的坐标分别为

$C1(x2+y1-y2,y2+x2-x1),D1(x1+y1-y2,y1+x2-x1)$

$C2(x2+y2-y1,y2+x1-x2),D2(x1+y2-y1,y1+x1-x2)$

最后记得答案要除以 $4$ 。因为一个正方形有四条边，我们枚举到每一条边的时候答案都会加一，所以一个正方形算了 $4$ 次，最终答案要除以 $4$。

Code:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<queue>
#include<stack>
#include<cmath>
using namespace std;

const int MAXN=1050;
typedef long long LL;

struct node{
	int x;
	int y;
};

int N,t[MAXN][MAXN],Ans=0;
node a[MAXN];

void Init(){
	memset(t,0,sizeof(t));
	scanf("%d",&N);
	for(int i=1;i<=N;i++) scanf("%d%d",&a[i].x,&a[i].y),a[i].x+=500,a[i].y+=500,t[a[i].x][a[i].y]++;
}

void Solve(){
	for(int i=1;i<=N;i++)
		for(int j=i+1;j<=N;j++){
			int x1=a[i].x,y1=a[i].y,x2=a[j].x,y2=a[j].y;
			int x3=x1+y1-y2,y3=y1+x2-x1,x4=x2+y1-y2,y4=y2+x2-x1;
			int x5=x1+y2-y1,y5=y1-x2+x1,x6=x2+y2-y1,y6=y2-x2+x1;
			if(x3>=0&&y3>=0&&x4>=0&&y4>=0&&t[x3][y3]&&t[x4][y4]) Ans++;
			if(x5>=0&&y5>=0&&x6>=0&&y6>=0&&t[x5][y5]&&t[x6][y6]) Ans++;
		}
	Ans/=4;
}

void Print(){
	cout<<Ans<<endl;
}

int main(){
	Init();
	Solve();
	Print();
	return 0;
}
```

---

## 作者：Youngsc (赞：0)

[Youngsc](http://youngscc.github.io/)


面对如此之小的规模我竟然用了哈希。

输入点时用哈希存起来

枚举一条对角线，然后搜寻另一条对角线，看它的两点是否在图中。

###代码

```cpp
# include <algorithm>
# include <iostream>
# include <cstdio>
# include <cstring>
# include <queue>
# define R register
# define LL long long
# define mod 10000007
# define fl float

using namespace std;

int n,m,ans;

fl p[1010][2];

struct pp{int x,y;pp *pre;}*hs[10000007];

inline int in(int &a) {
    R char c = getchar();  R int x = 0,f = 1;
    while(!isdigit(c)) {if(c == '-') f = -1;c = getchar();}
    while(isdigit(c)) x = x * 10 + c - '0',c = getchar();
    a = x*f;
    return x*f;
}

inline int has(R int x,R int y){x++,y++;return abs((x*x%mod*13%mod+y*y%mod*137%mod*y%mod)%mod);}//我的丑陋哈希
inline bool search(R int x,R int y){//寻找
    R int d = has(x,y);
    R pp *t = hs[d];
    while(t){
        if(t->x == x&&t->y == y) return 1;
        t = t->pre;
    }
    return 0;
}

int main(){
    // while(in(n)){
        // ans = 0;
        in(n);
        for(R int i = 0;i <= 10000006; ++i)  hs[i] = NULL;
        R int x,y;
        for(R int i = 1;i <= n; ++i){
            in(x),in(y);
            p[i][0] = (fl)x,p[i][1] = (fl)y;
            R int d = has(x,y);
            R pp *ne = new pp;
            *ne = (pp){x,y,hs[d]};
            hs[d] = ne;
        }
        for(R int i = 1;i <= n; ++i)
            for(R int j = i+1;j <= n; ++j){
                R fl x1 = (p[i][0]+p[j][0]+p[i][1]-p[j][1])/2.0;//另两个点的坐标
                R fl x2 = (p[i][0]+p[j][0]+p[j][1]-p[i][1])/2.0;
                R fl y1 = (p[i][1]+p[j][1]+p[j][0]-p[i][0])/2.0;
                R fl y2 = (p[i][1]+p[j][1]+p[i][0]-p[j][0])/2.0;
                if(x1-(int)x1||x2-(int)x2||y1-(int)y1||y2-(int)y2) continue;//小数就跳过，反正不可能有
                R int a = (int)x1,b = (int)x2,c = (int)y1,d = (int)y2;
//                printf("%d %d %d %d\n",a,b,c,d);
                if(search(a,c)&&search(b,d)) ans++;
            }
        printf("%d\n",ans/2);//一个正方形会被枚举两次
    }
```

---

## 作者：huangjunqi1 (赞：0)

这道题好像可以枚举四个顶点……

但正解应该是哈希……

先将每个点的横坐标乘以100+纵坐标当作k值，再设计H(k)的函数

统计答案时枚举两个点坐标（一条边上的），再用数学方法算出另外两个点坐标，查找这两个是否存在，若存在，则ans+1

输出ans即可

```cpp
#include<cstdio>
#include<algorithm>
#define mo 1428571
#define an 40001
using namespace std;
int num,next[10000],head[3000000],key[10000],x[10000],y[10000];
void listi(int k,int x)
{
    num++;
    next[num]=head[k];
    head[k]=num;
    key[num]=x;
}
void insert(int x,int y)
{
    int x1=x*an+y;
    int k=x1%mo+mo;
    listi(k,x1);
}
int lists1(int k,int x)
{
    int i=head[k];
    while (i!=0)
    {
        if (key[i]==x) 
        {
            return 1;
        }
        i=next[i];    
    }
    return 0;
}
int search(int x,int y)
{
    int x1=x*an+y;
    int k=x1%mo+mo;
    return lists1(k,x1);
} 
int main()
{
    num=0;
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d",&x[i],&y[i]);
        insert(x[i],y[i]);
    }
    long long ans=0;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
        {
            int x1=x[i],y1=y[i],x2=x[j],y2=y[j];
            if (i==j||x[i]>=x[j]||y[i]>y[j]) continue;
            int y3=y1-x2+x1,x3=x1-y1+y2,y4=y2-x2+x1,x4=x2-y1+y2;
            if (search(x3,y3)&&search(x4,y4)) ans++;
        }
    printf("%d\n",ans);
    return 0;
}
```

---


# 过家家

## 题目描述

有 $2n$ 个小学生来玩过家家游戏，其中有 $n$ 个男生，编号为 $1$ 到 $n$，另外 $n$ 个女生，编号也是 $1$ 到 $n$。每一个女生可以选择一个和她不吵嘴的男生来玩，除此之外，如果编号为 $X$ 的女生的朋友（也是女生，且编号为 $Y$）不和编号为 $Z$ 的男生吵嘴，那么 $X$ 也可以选择 $Z$。此外，朋友关系是可以传递的，比如 $a$ 和 $b$ 是朋友，$b$ 和 $c$ 是朋友，那么我们可以认为 $a$ 和 $c$ 也是朋友。注意，一个男生可以被多个女生选择为玩伴。

当每一位女生都选择了玩伴，那么他们会开始新一轮游戏。在每一轮后，每个女生都会开始去找一个新的男生做玩伴（以前没选过）。而且每一个女生最多能强制 $k$ 个男生接受，无论他们以前是否吵嘴。

现在你的任务就是确定这 $2n$ 个小学生最多能玩几轮游戏。


## 样例 #1

### 输入

```
4 5 1 2
1 1
2 3
3 2
4 2
4 4
1 4
2 3
```

### 输出

```
3
```

# 题解

## 作者：NewSjf (赞：31)

楼下提到过可以用并查集来做,所以我来贡献一篇并查集的题解  
用并查集基本上就是线性时间复杂度,而且代码少,也比较好理解  
这道题我们男生和女生的关系与女生和女生之间的关系分开建图  
最后大概能得到这么一副关系图  
![](https://s2.ax1x.com/2019/08/23/mrnUrd.png)  
女生之间会形成几个联通快  
同一个联通快中的任何一个女生都能选择连接到这个联通快的男生  
例如最左边的那个联通快,因为每个女生每次选择不同的男生  
可以看出每个女生都有三种选择,因而游戏进行三轮  
同理右边那个最多进行两轮  
而中间那个孤立的点一轮都无法进行  
但是题目中又说 _每一个女生最多能强制k个男生接受_  
例如当k=2时候  
![](https://s2.ax1x.com/2019/08/23/mrnBIP.png)  
游戏就能多进行两轮,那么这个孤立的点也能进行两轮游戏了  
我们在计算答案的时候,先不考虑k,得到每个联通快能进行的游戏轮数  
然后再取最小值,记为ans.  
那么考虑k之后的最终答案就是min(ans+k,n)  
具体代码如下,短小精悍  
```cpp
#include<iostream>
#include<cstring>
#define MAXN 100000
using namespace std;
int n,m,k,f,pre[MAXN],num[MAXN],ans=2147483647;
bool maps[500][500]; 
struct node{int from,to;
}edge1[MAXN],edge2[MAXN];
int find(int x){return x==pre[x]?x:pre[x]=find(pre[x]);} 
void merge(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx!=fy)pre[fx]=fy;
}
int main()
{
	cin>>n>>m>>k>>f;
	for(int i=1;i<=n;i++)pre[i]=i;
	for(int i=1;i<=m;i++)cin>>edge1[i].from>>edge1[i].to; //女from 和 男to 从不吵架 
	for(int i=1;i<=f;i++)cin>>edge2[i].from>>edge2[i].to;  //女from 和 女to 是朋友 
	for(int i=1;i<=f;i++)merge(edge2[i].from,edge2[i].to);//朋友关系用并查集处理联通情况 
	for(int i=1;i<=m;i++)
		if(!maps[find(edge1[i].from)][edge1[i].to])       //要记录每个联通快连接的不同编号的男生数目,用maps标记防止重复计数 
			num[find(edge1[i].from)]++,  //记录每个联通快的共享男生数目
			maps[find(edge1[i].from)][edge1[i].to]=true;
	for(int i=1;i<=n;i++)
		if(num[i])ans=min(ans,num[i]); //取最小 
	ans=min(ans+k,n);  //考虑k之后的答案,最大值有可能会超过n,这显然是不行的 
	cout<<ans<<endl;
}
```


---

## 作者：theStarMaster (赞：10)

# 过家家

## 题目大意（自认为较为简单的理解方式）

有 $n$ 个人打农药 ，共有 $n$ 个英雄， 每个人都有一个自己的英雄库 ， 互为好友的可共享英雄 ， 每个人还拥有可买 $k$ 个英雄的点券 ， 求一个人能用的英雄最少为多少（一个英雄打一局，所以英雄最少的玩家打完后就不开心了所以就结束对局了） 。

## 分析 ：

首先这题一看便知是并查集，但是怎么并 / 查 ， 是个问题，我是一上来便直接硬上带权并查集然而在并的时候就发现英雄重叠不好处理，所以立刻陷入沉思。为避免英雄重复所以每个人和英雄并查集不能通用，所以我们便用并查集维护好友，先将每个人的英雄离线下来，在后面合并好友后，在开个桶打个标记将英雄都加到并查集联通快的代表节点（祖宗）上，标记防止算重，最后对于每个桶枚举找最小值 ，因为 $k$ 自己能买的英雄量是固定的但总共只有 $n$ 个英雄所以最后统计答案为 $min(minn+k , n)$ 。

代码如下

------

```cpp
#warning by StarMaster
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std ;

const int MM = 10000 ;
int n , fa[MM * 10]  , m , k , minn = 1e6 , f , num[MM * 10] ;
bool vis[MM][MM] ;

struct node
{
	int x , y ;
}a[MM * 10] ;

inline int min(int a , int b)
{
	return a < b ? a : b ;
}

inline int read()
{
	int x = 0 , f = 1 ;
	char ch = getchar() ;
	while(ch > '9' or ch < '0')
	{
		if(ch == '-') f = -1 ;
		ch = getchar() ;
	}
	while(ch >= '0' and ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar() ;
	}
	return x * f ;
}

inline int Find(int x)
{
	if(x == fa[x]) return x ;
	else return fa[x] = Find(fa[x]) ;
}

int main()
{
	n = read() , m = read() , k = read() , f = read() ;
	for(int i = 1 ; i <= n ; i ++)
	{
		fa[i] = i ;
	}
	for(int i = 1 ; i <= m ; i ++)
	{
		a[i].x = read() , a[i].y = read() ;
	}
	for(int i = 1 ; i <= f ; i ++)
	{
		int x = read() , y = read() ;
		fa[Find(x)] = Find(y) ;
	}
	for(int i = 1 ; i <= m ; i ++)
	{
	    if(!vis[Find(a[i].x)][a[i].y])
	    {
	    	num[Find(a[i].x)] ++ ;//累加祖宗节点英雄量
	    	vis[Find(a[i].x)][a[i].y] = 1 ;//标记防止算重
	    }
	}
	for(int i = 1 ; i <= n ; i++)
	{
		if(num[i]) minn = min(minn , num[i]) ;//找最小值
	}
	cout << min(minn + k , n) ;//最小值加 k，与 n 取 min
	return 0 ;
}
```


------------


完结撒花(* ^ ▽ ^ *) 



---

## 作者：Rikka__ (赞：5)

~~大家好，我非常喜欢使用 STL，所以用 Bitset 过了这个题 。~~


### 题意
对于每个女生及与其朋友节点划分为一个联通块，答案就是每个联通块相连的男生数加上可强制接受的数量的最小值 。

但是可能会出现答案的值多于男生数量的情况，所以我们要将答案和男生人数去一个最小值 。

--------------

### 思路 
可以很容易的想到用并查集去维护女生的联通块，但是男生怎么处理 ?

于是我想到了 Bitset，这样我们可以很方便的存储与女生节点相连的男生有谁，维护与联通块相连的男生时只用将联通的女生节点的 Bitset 按位或起来就可以很快的维护答案了 。

------------

我们可以想一想这道题使用 Bitset 的优点 ：

- 操作方便，直接将两个 Bitset 或一下就行
- 不用去重，不用判断两个女生节点可以直接接受同一个男生，因为或起来之后相同的位置不会有新增贡献。

~~（于是我就拿了个最优解。。~~

-------------------

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define _ =read()
int read(){
    int x=0,f=1;
	char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
bitset<260> s[260];
int n;
int m;
int f;
int k;
int fa[260];
int find(int x){ return fa[x]==0?fa[x]=x:fa[x]==x?x:fa[x]=find(fa[x]);}
signed main(){
	n _;
	m _;
	k _;
	f _;
	for(int x,y,i=1;i<=m;++i){
		x _;
		y _;
		s[x][y]=1;
	}
	for(int i=1,x,y;i<=f;++i){
		x _;
		y _;
		int fx=find(x);
		int fy=find(y);
		s[fx]|=s[fy];
		s[fy]|=s[fx];
		if(fx!=fy) fa[fy]=fa[x];
	}
	int ans=INT_MAX;
	for(int i=1;i<=n;i++){
		s[i]|=s[find(i)];
	}
	
	for(int i=1;i<=n;++i) ans=min(ans,int(s[i].count()+k));
	cout<<min(ans,n);
	return 0;
}

```
9.11 Update：感谢 @Whitharm 提供的 hack , （ 未在最后使一个并查集内的节点的 bitset 统一 ） 已对代码进行了修改 。


---

## 作者：nomonick (赞：5)

# 题解 P1682 【过家家】

不得不说这道题是真的有点水。

一道用并查集可以爆切的题目。

首先看一张图（点加粗的的是女生，反之是男生）（这是题目的样例）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hhhnca0z.png)

$1$ 和 $4$，$2$ 和 $3$ 间的连线表示她们是朋友。

由于题目中所描述的：
	
       如果编号为X的女生的朋友(也是女生，且编号为Y)不和编号为Z的男生吵嘴，那么X也可以选择Z
       
那么由 $1$ 和 $4$ 组成的朋友关系就是的她们可以和 $5$，$6$，$8$ 一起玩，所以有三种选择。

而 $2$ 和 $3$ 就能和 $6$，$7$ 一起玩，所以只有两种选择。

而但游戏进行完第二轮之后，$2$ 和 $3$ 就无法在和别人完，所以游戏就结束了。

而又强行让 $k$ 个人来玩，所以这道题就是用并查集把女生们通过朋友关系连成几个连通块，再把所有连通块可以选的男生个数的最小值取出来记为 $res$。 

而最终的答案一定要把结果与最大游戏轮数 $n$ 取较小值

$$
ans = \min(res+k,n)
$$


# code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 2e2 + 75;
const int inf = 1e9 + 50;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,m,k,f,ans = inf;
int fa[SIZE];
bool vis[SIZE][SIZE];

inline int get_root(int u)
{
	return fa[u] == u ? u : fa[u] = get_root(fa[u]);
}

inline bool pd(int u,int v)
{
	return get_root(u) == get_root(v) ? true : false;
}

inline void merge(int u,int v)
{
	pd(u,v) ?  : fa[u] = get_root(v);
}

inline void add(int u)
{
	for (int i = 1; i <= n; ++i)
		if (vis[u][i])
			vis[get_root(u)][i] = true;
}

int main()
{
	n = read();m = read();k = read();f = read();
	for (int i = 1; i <= n; ++i) fa[i] = i;
	for (int i = 1; i <= m; ++i)
	{
		int x = read(),y = read();
		vis[x][y] = true;
	}
	for (int i = 1; i <= f; ++i) merge(read(),read());
	for (int i = 1; i <= n; ++i) add(i);
	for (int i = 1; i <= n; ++i)
		if (fa[i] == i)
		{
			int res = 0;
			for (int j = 1; j <= n; ++j)
				if (vis[i][j])
					res++;
			ans = min(ans,res);
		}
	ans = min(ans+k,n);
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：zcxxnqwq (赞：3)

根据题目，由于女生之间的朋友关系可以相互传递，考虑并查集。

之后首先想到的操作就是对于输入的每一对女生关系，用并查集将女生划分为若干连通块。

然后发现对于一个连通块及与其相连的男生，在该连通块内最多进行的游戏轮数即连接的男生数目，所以应在加入男生时同步记录当前与连通块相连的男生数 $cnt$，而为了避免重复，引入数组 $vis(i,j)$ 标记男生j是否已经在以第i个女生为父亲节点的连通块中。

最后遍历每个连通块，得到最小的 $cnt$ 即为答案 $ans$。

由于每个女生可以强制选择 $k$ 个男生进行游戏，故在其余连通块中的男生足够多的情况下可以进行 $ans+k$ 轮游戏，而由于**最多只能进行 $n$ 轮游戏**，需要特判，即 $ans=min(ans+k,n)$。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
inline int read(){
	register int x=0,f=1;
	register char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f; 
}
const int N=300;
int n,m,k,ff;
int x[N*N],y[N*N];
int f[N],cnt[N];
bool vis[N][N];
inline int getf(int x){
	if(f[x]==x) return x;
	return f[x]=getf(f[x]);		
}
signed main(){
	n=read(),m=read(),k=read(),ff=read();
	for(register int i=1;i<=n;i++) f[i]=i;
	for(register int i=1;i<=m;i++) x[i]=read(),y[i]=read();
	for(register int i=1;i<=ff;i++){
		int x=read(),y=read();
		f[getf(x)]=getf(y);//合并连通块 
	}
	for(register int i=1;i<=m;i++){
		int fx=getf(x[i]);
		if(vis[fx][y[i]]) continue;
		vis[fx][y[i]]=1,cnt[fx]++;
	}
	int ans=1e9;
	for(register int i=1;i<=n;i++) ans=min(cnt[getf(i)],ans);//对每个父亲节点进行统计 
	printf("%d",min(ans+k,n));
	return 0;
}
```
求通过！！！

---

## 作者：天上一颗蛋 (赞：3)

## P1682 过家家

题目描述
有2n个小学生来玩过家家游戏,其中有n个男生,编号为1到n,另外n个女生,编号也是1到n.每一个女生可以先选择一个和她不吵嘴的男生来玩,除此之外,如果编号为X的女生的朋友(也是女生,且编号为Y)不和编号为Z的男生吵嘴,那么X也可以选择Z.此外,朋友关系是可以传递的,比如a和b是朋友,b和c是朋友,那么我们可以认为a和c也是朋友.

当每一位女生都选择了玩伴,那么他们会开始新一轮游戏.在每一轮后,每个女生都会开始去找一个新的男生做玩伴(以前没选过).而且每一个女生最多能强制k个男生接受,无论他们以前是否吵嘴.

现在你的任务就是确定这2n个小学生最多能玩几轮游戏.

输入输出格式
输入格式：
第一行有4个整数n,m,k,f(3<=n<=250,0<m<n*n,0<=f<n).

n表示有2n个小学生,其中n个男生n个女生.

接下来m行,每行包含2个数字a,b表示编号为a的女生和编号为b的男生从没吵嘴过.

再接下来f行,每行包含2个数字c,d表示编号为c的女生和编号为d的女生是朋友.

输出格式：
对于每组数据,输出一个整数,表示2n个小学生最多能玩几轮.

---
这一题和[P3153 [CQOI2009]跳舞 ](https://www.luogu.org/problemnew/show/P3153)几乎是一模一样，那篇题解可以[看这里](https://www.luogu.org/blog/QVQ/solution-p3153)，建图 + 最大流 + 二分即可得到答案，这里不在赘述，写这篇题解是要解决题目中**连通性**的问题

题目中有提到过，**朋友关系是可以传递的,比如a和b是朋友,b和c是朋友,那么我们可以认为a和c也是朋友**，据此我们有两个思路：

1.并查集

2.Floyd

# 并查集是否可行

虽然我很擅长并查集，但是很可惜，并查集的做法在这题并不是特别适用：理由如下：

并查集的最大用处是，利用父亲这一概念很方便的**判断两元素是否处于同一集合**，但通过某一节点，我们不能很快确定其他节点是否与他在一集合内，唯一想到的方法是遍历所有节点，一一判断是否属于同一集合，比较麻烦，故不适用并查集。

# Floyd是否可行

Floyd算法可以判断图的联通性，伪代码大概如下：

```cpp
for(所有节点（作为中间点）){
	for(所有节点（作为起点）){
    	for(所有节点（作为终点）){
        	if(起点与中间点联通 && 中间点与终点联通)
            起点与终点联通
        	}
    	}
	}
```

这就是**传递闭包**，能适用与这题，理由如下：

利用传递闭包，我们在处理完关系之后可以得到一个二维数组，可以很容易的判断两点是否联通

所以我们使用**Floyd传递闭包**，解决关系问题，不过要对上述伪代码做适当修改：（男孩B和女孩A玩 && 女孩A和女孩C是朋友）---> 男孩和女孩C玩

所以我们得到代码：

```cpp
void Floyd(){
    for(int k = num + 1;k <= 2 * num;k++){//所有女孩
        for(int i = 1;i <= num;i++){//所有男孩
            for(int j = num + 1;j <= 2 * num;j++){//所有女孩
                dance[i][j] |= dance[i][k] && dance[k][j];//男孩选女孩（建图是也是先男孩再连女孩）
                }
            }
        }
    }
    
    
//主函数部分
    for(int i = 1;i <= nr;i++){
        u = RD();v = RD();
        dance[v][u + num] = 1;//女孩编号 + num
        }
    for(int i = 1;i <= nf;i++){
        u = RD();v = RD();
        dance[u + num][v + num] = dance[v + num][u + num] = 1;
        }
    Floyd();
```

最后二分多次建图跑最大流验证答案即可

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 100019,INF = 1e9;
int num,k,nr,nf,nume = 1;
int dance[190][190];
int frind[190][190];
int s,t,maxflow;
int head[maxn << 2];
struct Node{
    int v,dis,nxt;
    }E[maxn << 3];
void add(int u,int v,int dis){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    E[nume].dis = dis;
    head[u] = nume;
    }
int d[maxn];
bool bfs(){
    queue<int>Q;
    memset(d,0,sizeof(d));
    d[s] = 1;
    Q.push(s);
    while(!Q.empty()){
        int u = Q.front();Q.pop();
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(E[i].dis && !d[v]){
                d[v] = d[u] + 1;
                if(v == t)return 1;
                Q.push(v);
                }
            }
        }
    return 0;
    }
int Dinic(int u,int flow){
    if(u == t)return flow;
    int rest = flow,k;
    for(int i = head[u];i;i = E[i].nxt){
        int v = E[i].v;
        if(d[v] == d[u] + 1 && rest && E[i].dis){
            k = Dinic(v,min(rest,E[i].dis));
            if(!k)d[v] = 0;
            E[i].dis -= k;
            E[i ^ 1].dis += k;
            rest -= k;
            }
        }
    return flow - rest;
    }
void build(int a){
    memset(head,0,sizeof(head));
    nume = 1;
    for(int i = 1;i <= num;i++){
        add(s,i,a);
        add(i,s,0);//源点到每个♂
        add(i + num,i + 2 * num,k);
        add(i + 2 * num,i + num,0);//♀分两部
        add(i + 2 * num,t,a);
        add(t,i + 2 * num,0);//女到汇点
        }
    for(int i = 1;i <= num;i++){
        for(int j = num + 1;j <= 2 * num;j++){
            if(dance[i][j]){
                add(i,j + num,1);
                add(j + num,i,0);
                }
            else{
                add(i,j,1);
                add(j,i,0);
                }
            }
        }
    }
bool check(int mid){
    build(mid);
    maxflow = 0;
    int flow = 0;
    while(bfs())while(flow = Dinic(s,INF))maxflow += flow;
    if(maxflow == mid * num)return 1;
    return 0;
    }
int search(int l,int r){
    int ans;
    while(l <= r){
        int mid = l + r >> 1;
        if(check(mid))l = mid + 1,ans = mid;
        else r = mid - 1;
        }
    return ans;
    }
void Floyd(){
    for(int k = num + 1;k <= 2 * num;k++){
        for(int i = 1;i <= num;i++){
            for(int j = num + 1;j <= 2 * num;j++){
                dance[i][j] |= dance[i][k] && dance[k][j];
                }
            }
        }
    }
int main(){
    num = RD();nr = RD();k = RD();nf = RD();
    s = num * 4 + 19;t = s + 1;
    int u,v;
    for(int i = 1;i <= nr;i++){
        u = RD();v = RD();
        dance[v][u + num] = 1;
        }
    for(int i = 1;i <= nf;i++){
        u = RD();v = RD();
        dance[u + num][v + num] = dance[v + num][u + num] = 1;
        }
    Floyd();
    printf("%d\n",search(0,num + k));
    return 0;
    }
```

---

## 作者：BillYang (赞：3)

大家都用的并查集做的？

这道题类似于【CQOI2009】跳舞

可以使用二分+拆点+最大流的方法进行操作

将每一个女生拆成两个点，一个管理吵架的，一个管理不吵架的。

拆成的两个点之间连边，容量为k，表示最多选k个不吵架的。

男生和女生之间需要连边，如果不互相吵架，连向第二个点，否则连向第一个点，容量为1。

将每个男生与女生第二个点分别与源汇点相连，容量为二分出来的mid，表示让他们条mid次舞。

接下来跑一次最大流，检验跑出来的答案是否==n\*mid，若相等，说明可以跳mid次舞，需要将二分下界上调，否则上界下调。

最终输出二分的Right即可。

贴上又臭又长的代码

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
inline const int Get_Int() {
    int num=0,bj=1;
    char x=getchar();
    while(x<'0'||x>'9') {
        if(x=='-')bj=-1;
        x=getchar();
    }
    while(x>='0'&&x<='9') {
        num=num*10+x-'0';
        x=getchar();
    }
    return num*bj;
}
const int maxn=5005;
struct Edge {
    int from,to,cap,flow;
};
struct Dinic {
    int n,m,s,t;
    vector<Edge>edges;
    vector<int>G[maxn];
    bool vst[maxn];
    int dist[maxn],Current[maxn]; //dist表层次 Current表当前弧下标 
    void init(int n) {
        this->n=n;
        edges.clear();
        for(int i=1; i<=n; i++)G[i].clear();
    }
    void AddEdge(int from,int to,int cap) {
        edges.push_back((Edge) {
            from,to,cap,0
        });
        edges.push_back((Edge) { //反向边 
            to,from,0,0
        });
        m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool Bfs() { //Bfs求出层次图 
        memset(vst,0,sizeof(vst));
        memset(dist,0,sizeof(dist));
        queue<int>Q;
        Q.push(s);
        dist[s]=0;
        vst[s]=1;
        while(!Q.empty()) {
            int Now=Q.front();
            Q.pop();
            for(int i=0; i<G[Now].size(); i++) {
                Edge& e=edges[G[Now][i]];
                int Next=e.to;
                if(!vst[Next]&&e.cap>e.flow) { //在残量网络中建层次图 
                    vst[Next]=1;
                    dist[Next]=dist[Now]+1;
                    Q.push(Next);
                }
            }
        }
        if(vst[t])return true;
        else return false; //层次图不能建到汇点,已无增广路 
    }
    int Dfs(int Now,int a) { //a是可增广量 
        if(Now==t||a==0)return a;
        int flow=0;
        for(int& i=Current[Now]; i<G[Now].size(); i++) { //引用传边,直接从上一次考虑的弧增广 
            Edge& e=edges[G[Now][i]];
            int Next=e.to;
            if(dist[Now]+1!=dist[Next])continue; //不在层次图中
            int Nextflow=Dfs(Next,min(a,e.cap-e.flow)); //将后面遍历完成
            if(Nextflow>0) {
                e.flow+=Nextflow;
                edges[G[Now][i]^1].flow-=Nextflow; //反向弧
                flow+=Nextflow;
                a-=Nextflow;
                if(a==0)break; 
            } 
        }
        return flow;
    }
    int MaxFlow(int s,int t) {
        this->s=s;
        this->t=t;
        int flow=0;
        while(Bfs()) { //不断建立层次图,不能建立时退出 
            memset(Current,0,sizeof(Current));
            flow+=Dfs(s,0x7fffffff/2); //Dfs增广 
        }
        return flow;
    }
} dinic;
int n,m,k,f,map[505][505];
void Floyd() {
    for(int k=n+1; k<=2*n; k++)
        for(int i=1; i<=n; i++)
            for(int j=n+1; j<=2*n; j++)
                map[i][j]=map[i][j]||(map[i][k]&&map[k][j]);
}
int main() {
    n=Get_Int();
    m=Get_Int();
    k=Get_Int();
    f=Get_Int();
    for(int i=1; i<=m; i++) {
        int y=Get_Int(),x=Get_Int();
        map[x][n+y]=1;
    }
    for(int i=1; i<=f; i++) {
        int x=Get_Int(),y=Get_Int();
        map[n+x][n+y]=map[n+y][n+x]=1;
    }
    Floyd();
    int Left=0,Right=250;
    while(Left<=Right) {
        int mid=(Left+Right)>>1;
        dinic.init(4*n+5);
        for(int i=1; i<=n; i++)dinic.AddEdge(3*n+2,i,mid);
        for(int i=1; i<=n; i++)dinic.AddEdge(2*n+i,3*n+3,mid),dinic.AddEdge(n+i,2*n+i,k);
        for(int i=1; i<=n; i++)
            for(int j=1; j<=n; j++)
                if(map[i][n+j])dinic.AddEdge(i,2*n+j,1);
                else dinic.AddEdge(i,n+j,1);
        if(dinic.MaxFlow(3*n+2,3*n+3)>=n*mid)Left=mid+1;
        else Right=mid-1;
    }
    printf("%d\n",Right);
    return 0;
}
```

---

## 作者：robin2333 (赞：3)

这题其实并不难，**也可以不用到网络流相关知识**（当然，网络流是一种更通用的方法）。

考虑到点之间存在这两种关系

1. 男生和女生之间，可以在一起
2. 女生和女生之间，是朋友

我们对这两种关系**分别建图**。

易得，由于题目朋友关系的传递性，我们可以用Floyd或并查集预处理好这些“小团体”。

对于一个小团体内部，可以共享男生。易得如果女生这边只存在这个小团体，游戏进行的次数等于这个小团体共同能够连接的男生个数。

我们处理出所有小团体单独能进行的游戏次数，全局取min即可。

注意到我们还没有考虑k，易得k直接与前面的答案累加再与n取min即可，因为只要这个数小于n，给一次强行连接的机会，一定能把游戏延长一回合。

还是放一下代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 255;

int n,m,k,f;
bool g[maxn][maxn];
bool g2[maxn][maxn]; 
int x,y;
bool vis[maxn];
bool que[maxn];
int numa,numb;
int kokona = 0x3f3f3f3f;

int get_ans(int numa,int numb){
	return numa;
}

void floyed(){
	for (int k=1;k<=n;k++){
		for (int i=1;i<=n;i++){
			for (int j=1;j<=n;j++){
				if(g2[i][k] & g2[k][j])g2[i][j] = true;
			}
		}
	}
}
int main(){
	cin>>n>>m>>k>>f;
	for (int i=1;i<=m;i++){
		cin>>x>>y;
		g[x][y] = true;
	}
	for (int i=1;i<=f;i++){
		cin>>x>>y;
		g2[x][y] = true;
		g2[y][x] = true;
	}
	for (int i=1;i<=n;i++)g2[i][i]=true;
	floyed();
	for (int i=1;i<=n;i++){
		if(vis[i])continue;
		for (int i=1;i<=n;i++)que[i]=false;
		numa=numb=0;
		for (int j=1;j<=n;j++){
			if(g2[i][j]){
				vis[j] = true;
				numb++;
				for (int k=1;k<=n;k++){
					if(g[j][k]){
						if(!que[k]){
							que[k] = true;
							numa++;
						}
					}
				}
			}
		}
		kokona = min(kokona,get_ans(numa,numb));
	}
	cout<<min(kokona+k,n)<<endl;
	return 0;
}
```

---

## 作者：glorious_dream (赞：1)

### 题目大意：

有 $n$ 个男生和 $n$ 个女生，每次女生可以选择一个不会吵架的男生来玩，且可以强制 $k$ 个男生跟她玩，求最多能玩多少轮。

### 算法讲解：

首先，可以发现有合并女生的操作，可以想到用并查集来维护。

考虑两个女生是朋友，把她们用并查集加在一起，形成一个联通块。在每一个联通块内，女生可以选择任何一个男生玩。这样假设一共形成 $x$ 个联通块，那么答案就是这 $x$ 个联通块中的可匹配数量的最小值。

最后别忘了加上 $k$ 与 $n$ 比较，答案是较小的那个值。

### 总代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
const int M = 1e5+10;
int f[M],vis[500][500],cnt[M];
int n,m,k,t,ans=INT_MAX;
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
struct dat{
	int x,y;
}a[M];
signed main(){
	n=read(),m=read(),k=read(),t=read();
	for(re int i(1) ; i<=n ; ++i) f[i] = i;
	for(re int i(1) ; i<=m ; ++i) a[i].x=read(),a[i].y=read();
	for(re int i(1) ; i<=t ; ++i){
		int x=read(),y=read();
		int fx=find(x),fy=find(y);
		if(fx == fy) continue;
		f[fx] = fy;
	}
	for(re int i(1) ; i<=m ; ++i){
		if(!vis[find(a[i].x)][a[i].y]){
			cnt[find(a[i].x)]++;
			vis[find(a[i].x)][a[i].y]=1;
		}
	}
	for(re int i(1) ; i<=n ; ++i) if(cnt[i]) ans=min(ans,cnt[i]);
	printf("%d",min(ans+k,n));
	return 0;
}

```


---

## 作者：Xu_brezza (赞：0)

# 题意：

有 $n$ 个男生 $n$ 个女生，编号都是 $1$ 到 $n$。
男生和女生直接有不讨厌关系，那二者可以一起玩。女生和女生有朋友关系，女生的朋友的不讨厌的男生也可以和女生玩。当所有女生都找到玩伴（也可以是多对一），是一轮游戏，然后可以找其他玩伴进行下一轮，问最多进行几轮。还有就是每个女生可以强制选 $k$ 个玩伴。

# 分析：

作为我自己做出来的蓝题，有点小激动。

首先这个题意之下隐藏了什么呢？显然是一个图，其中可以分为女生之间的连边和男女之间的连边。那么对于女生之间的连边，显然她们构成的连通块可以到达彼此任意相连的男生，那么对于这个连通块，我们最多可以有 $cnt$ 次游戏，每次都是多对一，其中 $cnt$ 为连通块向男生连出的出边数量。

再看这个强制选，其实也没啥，就是答案次数加上 $k$ ，因为每个女生都可以再选 $k$ 个，那不就是再进行 $k$ 轮也就是总数加上 $k$ 吗。

由此我们总结出算法：并查集维护女生连通块，统计女生连通块与男生连边数量，取最小值（因为所有女生都要玩），再加上 $k$ ，还不能超过 $n$ 因为女生最多和 $n$ 个男生玩 $n$ 次对吧。

管理大大求过QWQ。

```cpp
#include<cstdio>
#include<algorithm>
#include<climits>
using namespace std;
const int N = 255;
struct qwq{
	int u,v;
}bg[N*N],gg[N];
int fa[N],check[N][N],cnt[N],n,m,f,k;
inline int findfa(int x){return fa[x] == x ? x : fa[x] = findfa(fa[x]);}
signed main(){
	scanf("%d%d%d%d",&n,&m,&k,&f);
	for(int i=1;i<=n;++i)fa[i] = i;
	for(int i=1;i<=m;++i)scanf("%d%d",&bg[i].u,&bg[i].v);
	for(int i=1;i<=f;++i){
		scanf("%d%d",&gg[i].u,&gg[i].v);
		int x = findfa(gg[i].u),y = findfa(gg[i].v);//女生合并 
		if(x != y)fa[x] = y; 
	}
	for(int i=1;i<=m;++i){
		int x = findfa(bg[i].u),y = bg[i].v;//取出男女qwq 
		if(!check[x][y]){//统计该女生连通块连多少个男生 
			check[x][y] = 1;
			cnt[x]++;
		}
	}
	int ans = INT_MAX;
	for(int i=1;i<=n;++i)ans = cnt[i] ? min(ans,cnt[i]) : ans;
	ans += k;
	printf("%d",min(ans,n)); 
}
```


---


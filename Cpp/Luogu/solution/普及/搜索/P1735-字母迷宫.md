# 字母迷宫

## 题目描述

打败了 DIABLO，Mini 进入了迷宫。这是个奇怪的迷宫，迷宫的每一个地点要么有一个用来传送的门，要么是障碍。Mini 现在站在迷宫的原点处，但是眼看远在 $(N,N)$ 的公主就要被转移，Mini 心情焦急万分，为了能最快地到达公主处救出公主，Mini 希望能走一条最快的路径。注意，Mini 可以把迷宫的 $(1,1)$ 或 $(1,N)$ 或 $(N,1)$ 处当作原点。

迷宫里，某些地点会有门，将门激活，Mini 就会被传送到某个地点，当然，魔王 Bill 只创造了三种门，所以迷宫里最多有就只有三种门，而且在这个迷宫中要到达下一个点必须通过门。。（什么逻辑 TUT。。）

在迷宫中，可能会遇到的三种门分别如下：

- 时空之门，Mini 可以往上下左右四个方向中的任意一个方向传送一格；
- 海洋之门，Mini 可以往上下左右四个方向中的任意一个方向传送两格；
- 天堂之门，Mini 需要停留一步，聚气，然后可以往左上左下右上右下四个方向中的任意一个方向传送一格。

当然，使用每一个门都算作一步。

当然还有障碍，如果有障碍，那么这个点没有门且这个点不能被传送到。

但是，魔王 Bill 有可能创造出了一个完全无法到达 $(N,N)$ 的迷宫，所以，当从三个原点出发都无法到达 $(N,N)$ 时，请输出 `No answer`。注意，原点算作一步（Mini 一开始站在 $(1,1)$ 或 $(1,N)$ 或 $(N,1)$ 的位置，然后走一步到原点，所以原点算作一步）。


## 说明/提示

对于 $100\%$ 的数据，$0\le N\le 1200$。

## 样例 #1

### 输入

```
3
A*C
*AC
ACA```

### 输出

```
No answer```

## 样例 #2

### 输入

```
3
AAA
CAA
AAA```

### 输出

```
3
```

# 题解

## 作者：_Liyx_ (赞：9)

## 思路
第一眼是一道 BFS，直到看到了天堂之门。所以用 DFS 写了一下，直接 TLE40。[记录](https://www.luogu.com.cn/record/164837185)

相信各位停留在 A 处和 B 处的代码都会写，所以来讲一下停留在 C 处的代码。

在 C 处要停一步再走，所以可以定义一个 $flag$，当到了 C 处时，判断 $flag$ 是否为 $1$，**如果为 $0$，将 $flag$ 修改为 $1$**，并将步数也加 $1$，然后重新加入到队列里，这样可以做到停一步的效果；如果为 $1$，说明已经停留过了，所以正常的进行 BFS 就好了。

最后放上 AC 代码。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
char a[1205][1205];
bool vis[1205][1205];
int d1[2][5]={{1,0,-1,0},{0,1,0,-1}};
int d3[2][5]={{1,1,-1,-1},{-1,1,1,-1}};
struct node{
	int x,y,step;
	bool flag;
};
bool flag;
void bfs(){
	queue<node> q;
	if(a[1][1]!='*') q.push(node{1,1,1,0});
	if(a[1][n]!='*') q.push(node{1,n,1,0});
	if(a[n][1]!='*') q.push(node{n,1,1,0});
	while(!q.empty()){
		node now=q.front();
		q.pop();
		if(now.x==n&&now.y==n){
			//标记 
			flag=1;
			cout<<now.step;
			return;
		}
		if(a[now.x][now.y]=='A'){
			for(int i=0;i<4;i++){
				int xx=now.x+d1[0][i],yy=now.y+d1[1][i];
				if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy]&&a[xx][yy]!='*'){
					vis[xx][yy]=1;
					q.push(node{xx,yy,now.step+1,0});
				}
			}
		}
		else if(a[now.x][now.y]=='B'){
			for(int i=0;i<4;i++){
				//在B处会传送2格，乘以2 
				int xx=now.x+2*d1[0][i],yy=now.y+2*d1[1][i];
				if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy]&&a[xx][yy]!='*'){
					vis[xx][yy]=1;
					q.push(node{xx,yy,now.step+1,0});
				}
			}
		}
		else if(a[now.x][now.y]=='C'){
			//对于聚气的处理 
			if(now.flag==0){
				q.push(node{now.x,now.y,now.step+1,1});
				continue;
			}
			
			//flag不为0则正常进行BFS 
			for(int i=0;i<4;i++){
				int xx=now.x+d3[0][i],yy=now.y+d3[1][i];
				if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy]&&a[xx][yy]!='*'){
					vis[xx][yy]=1;
					q.push(node{xx,yy,now.step+1,0});
				}
			}
		}
	}
	
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) cin>>a[i][j];
	//如果a[n][n]本身为障碍则无解 
	if(a[n][n]=='*'){
		cout<<"No answer";
		return 0;
	}
	bfs();
	//如果没有输出则无解 
	if(flag==0){
		cout<<"No answer";
		return 0;
	}
	return 0;
}
```

---

## 作者：vеctorwyx (赞：6)

#### 菜鸡的思路（仅供参考）

#### 咱虽然没AC（就当他是数据问题）但咱的思路~~应该是对的（所以不要脸的发了篇紫题题解）~~

这题很怪你既要听话又要不听话

不听话是指不要真按题目说的搜（TLE警告）

听话是指C门（~~别管它叫啥名~~）聚气你还这得停下来等一步（不停的话时间顺序就乱了）但是。。~~不停能骗70分~~（咱也不知道咋搞的）

倒着搜~~其实不难~~，就是看搜到的点是什么字母（对应的移动关系）与当前点是否相符（特殊处理聚气）相当于视频倒放（倒着想问题）

最后还是放上我60分的代码
```
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
int n;
char a[1210][1210];
bool b[1210][1210];
int dx1[5]={0,0,0,1,-1};
int dy1[5]={0,1,-1,0,0};
int dx2[5]={0,0,0,2,-2};
int dy2[5]={0,2,-2,0,0};
int dx3[5]={0,1,-1,1,-1};
int dy3[5]={0,1,-1,-1,1}; 
struct node
{
	int x,y,tim;
	bool tim_c;
}qwq;
int mintime1=-1,mintime2=-1,mintime3=-1;
queue<node>q;
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	cin>>a[i][j];
	if(n==1&&a[0][0]!='*')
	{
		cout<<1;
		return 0;
	}
	if(a[n-1][n-1]=='*'||(a[0][n-1]=='*'&&a[0][0]=='*'&&a[n-1][0]=='*'))
	{
		cout<<"No answer";
		return 0;
	}
	qwq.x=n-1;
	qwq.y=n-1;
	qwq.tim=0;
	q.push(qwq);
	while(!q.empty())
	{
		qwq=q.front();
			if(qwq.tim_c)//聚气处理
			{
				qwq.tim_c=0;
				qwq.tim++;
				q.push(qwq);
				q.pop();
				continue; 
			} 
			if((qwq.x==0&&qwq.y==0)||(qwq.x==0&&qwq.y==n-1)||(qwq.x==n-1&&qwq.y==0))//搜到起点
			{
				cout<<qwq.tim+1;
				return 0;
			}
			for(int i=1;i<=4;i++)
			{		
				qwq=q.front();
				qwq.x+=dx1[i];
				qwq.y+=dy1[i];
				qwq.tim++;
				if(qwq.x>=0&&qwq.x<n&&qwq.y>=0&&qwq.y<n&&b[qwq.x][qwq.y]==0&&a[qwq.x][qwq.y]=='A')//来自A门
				{
					q.push(qwq);
					b[qwq.x][qwq.y]=1;
				}
			}
			for(int i=1;i<=4;i++)
			{
				qwq=q.front();
				qwq.x+=dx2[i];
				qwq.y+=dy2[i];
				qwq.tim++;
				if(qwq.x>=0&&qwq.x<n&&qwq.y>=0&&qwq.y<n&&b[qwq.x][qwq.y]==0&&a[qwq.x][qwq.y]=='B')//来自B门
				{
					q.push(qwq);
					b[qwq.x][qwq.y]=1;
				}
			}
			for(int i=1;i<=4;i++)
			{
				qwq=q.front();
				qwq.x+=dx3[i];
				qwq.y+=dy3[i];
				qwq.tim++;
				qwq.tim_c=1;
				if(qwq.x>=0&&qwq.x<n&&qwq.y>=0&&qwq.y<n&&b[qwq.x][qwq.y]==0&&a[qwq.x][qwq.y]=='C')//来自C门
				{
					q.push(qwq);
					b[qwq.x][qwq.y]=1;
				}
			}
			q.pop();
		}
		cout<<"No answer";
        	return 0;
	}
```
~~代码咋样能不能过不重要~~

重要的是给别人提供思路（~~万一别人看了我的思路AC了呢~~）

---

## 作者：sccc_ (赞：3)

## 思路   
一道 bfs 的题。  
在 AB 传送门处都很简单，普通的方向数组一写就行了。  
难点在 C 处传送门的时候需要停留一步。   
所以我们可以定义一个 $f$ 表示当前是否停留过。
- 当 $f$ 为 $0$ 时，说明未停留，$f$ 标记为一，并将步数加一，压进队列中。  
- 当 $f$ 为 $1$ 时，说明停留了一步，继续搜索即可。

其余正常 bfs。
***
```c++
#include <bits/stdc++.h>
using namespace std;

int n;
char a[1205][1205];
bool vis[1205][1205];
int minn = 1e9;
int dx[] = {0, 0, -1, 1, 0, 0, -2, 2, 1, 1, -1, -1};
int dy[] = {-1, 1, 0, 0, -2, 2, 0, 0, 1, -1, 1, -1};

struct node
{
	int x, y;
	int step;
	bool f;
};

bool check(int x, int y)
{
	return (x >= 1 and x <= n and y >= 1 and y <= n and vis[x][y] == 0 and a[x][y] != '*'); 
}

void bfs (int sx,int sy)
{
	queue<node> q;
	memset (vis, 0, sizeof vis);
	if(a[sx][sy] == '*')
		return ;
	if (a[sx][sy] == 'C')
		q.push ({sx, sy, 1, 0});
	else
		q.push ({sx, sy, 1, 1});
	while (!q.empty())
	{
		node u = q.front();
		q.pop();
		if (a[u.x][u.y] == 'A')
		{
			for (int i = 0; i < 4; i ++)
			{
				int xx = u.x + dx[i];
				int yy = u.y + dy[i];
				if (check (xx, yy))
				{
					vis[xx][yy] = 1;
					q.push ({xx, yy, u.step + 1, 0});
					if (xx == n and yy == n)
					{
						minn = min (minn, u.step + 1);
						return ;
					}
				}
			}
		}
		else if (a[u.x][u.y] == 'B'){
			for (int i = 4; i < 8; i ++)
			{
				int xx = u.x + dx[i];
				int yy = u.y + dy[i];
				if (check (xx, yy))
				{
					vis[xx][yy] = 1;
					q.push ({xx, yy, u.step + 1, 0});
					if (xx == n and yy == n)
					{
						minn = min (minn, u.step + 1);
						return ;
					}
				}
			}
		}
		else if (a[u.x][u.y] == 'C')
		{
			if (u.f == 0)
				q.push ({u.x, u.y, u.step + 1, 1});
			else
			{
				for (int i = 8; i < 12; i ++)
				{
					int xx = u.x + dx[i];
					int yy = u.y + dy[i];
					if (check (xx, yy))
					{
						vis[xx][yy] = 1;
						q.push ({xx, yy, u.step + 1, 0});
						if (xx == n and yy == n)
						{
							minn = min (minn, u.step + 1);
							return ;
						}
					}
				}
			}
		}
	}
}
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i ++)
	{
		for (int j = 1; j <= n; j ++)
		{
			cin >> a[i][j];
		}
	}
	if (a[n][n] == '*')
	{
		puts("No answer");
		return 0;
	}
	bfs (1, 1);
	bfs (1, n);
	bfs (n, 1);
	if (minn == 1e9)
		puts("No answer");
	else
		cout << minn;
	return 0;
}
```

---

## 作者：Z_AuTwT (赞：3)

## 思路：

看到这题一眼跑广搜，但是转眼天堂之门，欸为什么要加2？

好像没法广搜（不满足广搜特性），咋办？~~凉拌。~~

该怎么让它满足广搜特性（先搜到的是最优的）。

欸，我们是不是可以将队列换成优先队列让先搜到的最优。好像是的欸，优先队列启动！

## 代码：

```c++
#include<bits/stdc++.h>
using namespace std;
int ans[1210][1210],nxt[4][2]={1,0,0,1,-1,0,0,-1},nxt1[4][2]={2,0,0,2,-2,0,0,-2},nxt2[4][2]={1,1,1,-1,-1,-1,-1,1},n;
char maps[1210][1210];
struct node{
    int x,y,step;
    friend bool operator<(const node X,const node Y){
        return X.step>Y.step;
    }
};
void bfs(){
    priority_queue<node> que;
    if(maps[1][1]!='*') que.push({1,1,1}),ans[1][1]=1;
    if(maps[1][n]!='*') que.push({1,n,1}),ans[1][n]=1;
    if(maps[n][1]!='*') que.push({n,1,1}),ans[n][1]=1;
    while(!que.empty()){
        node Now=que.top();
        que.pop();
        if(Now.x==n&&Now.y==n){
            cout<<Now.step;
            exit(0);
        }
        if(maps[Now.x][Now.y]=='A'){
            for(int i=0;i<4;i++){
                node Next=Now;
                Next.x+=nxt[i][0];
                Next.y+=nxt[i][1];
                Next.step++;
                if(Next.x>=1&&Next.x<=n&&Next.y>=1&&Next.y<=n&&Next.step<ans[Next.x][Next.y]&&maps[Next.x][Next.y]!='*'){
                    ans[Next.x][Next.y]=Next.step;
                    que.push(Next);
                }
            }
        }else if(maps[Now.x][Now.y]=='B'){
            for(int i=0;i<4;i++){
                node Next=Now;
                Next.x+=nxt1[i][0];
                Next.y+=nxt1[i][1];
                Next.step++;
                if(Next.x>=1&&Next.x<=n&&Next.y>=1&&Next.y<=n&&Next.step<ans[Next.x][Next.y]&&maps[Next.x][Next.y]!='*'){
                    ans[Next.x][Next.y]=Next.step;
                    que.push(Next);
                }
            }
        }else{
            for(int i=0;i<4;i++){
                node Next=Now;
                Next.x+=nxt2[i][0];
                Next.y+=nxt2[i][1];
                Next.step+=2;
                if(Next.x>=1&&Next.x<=n&&Next.y>=1&&Next.y<=n&&Next.step<ans[Next.x][Next.y]&&maps[Next.x][Next.y]!='*'){
                    ans[Next.x][Next.y]=Next.step;
                    que.push(Next);
                }
            }
        }
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            ans[i][j]=1e9;
            cin>>maps[i][j];
        }
    }
    bfs();
    cout<<"No answer";
}
```

---

## 作者：xujingyu (赞：2)

## 题意

有一个地图，到不同的点可以走到不同的位置，三个起点选一个，求最小时间走到终点。

## 解法

直接广搜即可。

在每个起点都搜一次，对于三个门，各自判断进队。

注意：

1. 出生地不可以是 `*`；
2. 聚气会加时间；
3. 初始时间为 $1$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,minn = 1e9;
int sx[4] = {0,0,1,-1};
int sy[4] = {-1,1,0,0};
int hx[4] = {0,0,2,-2};
int hy[4] = {-2,2,0,0};
int tx[4] = {1,-1,1,-1};
int ty[4] = {-1,1,1,-1};
char c[1201][1201];
bool vis[1201][1201];
struct node
{
	int x,y,step;
};
queue <node> q;

void bfs(int x,int y)
{
	if(c[x][y] == '*') return;
	q.push((node){x,y,1});
	vis[x][y] = true;
	while(!q.empty())
	{
		node f = q.front();
		q.pop();
		if(f.x == n && f.y == n){minn = min(minn,f.step);break;}//到达终点
		int nx,ny;
		if(c[f.x][f.y] == 'A')//时空门
		{
			for(int i = 0;i < 4;i++)
			{
				nx = f.x + sx[i];
				ny = f.y + sy[i];
				if(nx < 1 || nx > n || ny < 1 || ny > n || vis[nx][ny] || c[nx][ny] == '*') continue;
				vis[nx][ny] = true;
				q.push((node){nx,ny,f.step + 1});
			}
		}
		else if(c[f.x][f.y] == 'B')//海洋门
		{
			for(int i = 0;i < 4;i++)
			{
				nx = f.x + hx[i];
				ny = f.y + hy[i];
				if(nx < 1 || nx > n || ny < 1 || ny > n || vis[nx][ny] || c[nx][ny] == '*') continue;
				vis[nx][ny] = true;
				q.push((node){nx,ny,f.step + 1});
			}
		}
		else//天堂门
		{
			for(int i = 0;i < 4;i++)
			{
				nx = f.x + tx[i];
				ny = f.y + ty[i];
				if(nx < 1 || nx > n || ny < 1 || ny > n || vis[nx][ny] || c[nx][ny] == '*') continue;
				vis[nx][ny] = true;
				q.push((node){nx,ny,f.step + 2});
			}
		}
	}
	return;
}

signed main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i++)
	for(int j = 1;j <= n;j++)
	cin >> c[i][j];
	bfs(1,1);
	memset(vis,0,sizeof(vis));//记得重置
	while(!q.empty()) q.pop();
	bfs(1,n);
	memset(vis,0,sizeof(vis));
	while(!q.empty()) q.pop();
	bfs(n,1);
	if(minn != 1e9) printf("%d",minn);
	else printf("No answer");
	return 0;
}
```

---

## 作者：_yang_yi_bo_ (赞：2)

本题思路：进行三次 BFS，每次的起点分别是 $(1,1),(1,n),(n,1)$。

每次进行 BFS 前，需要判断起点是不是障碍物，如果是，可以返回一个极大值。

接着我们来处理传送门：

`A` 类与 `B` 类传送门比较好处理：每遇到 `A` 类 与 `B` 类传送门就向外扩展，注意 `B` 走两步时只能往一个方向走，而且可以穿墙。

接着来说一下 `C` 类：因为需要停留一步才能使用，我们可以在结构体里用一个 `bool` 变量 `f` 存储是否停留了一步，是则按正常方法往外走，否则往队列里放入原来的坐标，步数要加 $1$，要将 `f` 标记为走过。

注意每次 BFS 后要清空方向数组。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=1e9;
char c[1205][1205];
bool vis[1205][1205];
int dx[12]={1,0,-1,0,2,0,-2,0,1,1,-1,-1};
int dy[12]={0,1,0,-1,0,2,0,-2,1,-1,1,-1};
struct kkk{
	int x,y,s;
	bool f;
};
void bfs(int sx,int sy){
	queue<kkk> q;
	if(c[sx][sy]=='C'){
		q.push({sx,sy,1,0});
	}else if(c[sx][sy]=='*'){
		return;
	}else{
		q.push({sx,sy,1,1});
	}while(!q.empty()){
		kkk u=q.front();
		q.pop();
		if(c[u.x][u.y]=='A'){
			for(int i=0;i<4;i++){
				int xx=u.x+dx[i],yy=u.y+dy[i];
				if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy]&&c[xx][yy]!='*'){
					vis[xx][yy]=1;
					q.push({xx,yy,u.s+1,0});
					if(xx==n&&yy==n){
						ans=min(ans,u.s+1);
						return;
					}
				}
			}
		}else if(c[u.x][u.y]=='B'){
			for(int i=4;i<8;i++){
				int xx=u.x+dx[i],yy=u.y+dy[i];
				if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy]&&c[xx][yy]!='*'){
					vis[xx][yy]=1;
					q.push({xx,yy,u.s+1,0});
					if(xx==n&&yy==n){
						ans=min(ans,u.s+1);
						return;
					}
				}
			}
		}else{
			if(u.f==0){
				q.push({u.x,u.y,u.s+1,1});
			}else{
				for(int i=8;i<12;i++){
					int xx=u.x+dx[i],yy=u.y+dy[i];
					if(xx>=1&&xx<=n&&yy>=1&&yy<=n&&!vis[xx][yy]&&c[xx][yy]!='*'){
						vis[xx][yy]=1;
						q.push({xx,yy,u.s+1,0});
						if(xx==n&&yy==n){
							ans=min(ans,u.s+1);
							return;
						}
					}
				}
			}
		}
	}
}void init(){
	memset(vis,0,sizeof vis);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>c[i][j];
		}
	}if(c[n][n]=='*'){
		cout<<"No answer";
		return 0;
	}
	bfs(1,1);
	init();
	bfs(1,n);
	init();
	bfs(n,1);
	if(ans==1e9){
		cout<<"No answer";
	}else{
		cout<<ans;
	}
	return 0;
}
```

本蒟蒻的第一篇题解，求管理大大过审。

---

## 作者：luogu_MeiFengqi (赞：0)

#### 前言：
第一眼看到这道题，第一反应是从终点倒着宽搜，结果只有七十分，错误代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int a[1210][1210];
int dxy[3][3][8]={{{0,0,1,-1},{1,-1,0,0},{4}},{{0,0,2,-2},{2,-2,0,0},{4}},{{-1,-1,-1,0,0,1,1,1},{1,0,-1,1,-1,1,0,-1},{8}}};
bool vis[1210][1210];
struct node{
	int x,y,step;
	bool operator < (const node &b)const{
		return step>b.step;
	}
};
priority_queue<node> q;
bool flag=0;
bool fj(int x,int y)
{
    if(x==1&&y==1) return 1;
    if(x==1&&y==n) return 1;
    if(x==n&&y==1) return 1;
    return 0;
}
bool pd(int x,int y)
{
    if(x>=1&&x<=n&&y>=1&&y<=n&&!vis[x][y]&&a[x][y]!=0) return 0;
    return 1;
}
void bfs()
{
    q.push({n,n,0});
	while(!q.empty())
    {
        node cur=q.top(); q.pop();

        int nx=cur.x,ny=cur.y,nt=cur.step;
        if(fj(nx,ny))
        {
            flag=1;
            printf("%lld\n",nt);
            return;
        }

        for(int i=0;i<dxy[a[nx][ny]-1][2][0];i++)
        {
            int cx=nx+dxy[a[nx][ny]-1][0][i];
            int cy=ny+dxy[a[nx][ny]-1][1][i];
            if(!pd(cx,cy))
            {
                if(a[cx][cy]==3) q.push({cx,cy,nt+2});
                else q.push({cx,cy,nt+1});
                vis[cx][cy]=1;
            }
        }
    }
}
signed main(){
    cin >> n;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        char z;
        scanf("%c",&z);
        if(z=='A') a[i][j]=1;
        else if(z=='B') a[i][j]=2;
        else if(z=='C') a[i][j]=3;
    }
    if(a[n][n]!=0)
    {
        vis[n][n]=1;
        bfs();
    }
    if(!flag)
    cout << "No answer";
    return 0;
}
```
调了近三四个小时，还是没调对。
#### 正解：
后来，重构代码，思路如下：
宽搜三个起点，记录步数最小值，最后判断，如果标记不等于原值，则输出次数；反之，无解。

再补充一点，因有可能需暂停一次，故将普通队列改为优先队列。

在此基础上，搜索三次，以三个起点为起点开始宽搜即可。
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
int ans=INT_MAX;
char a[1210][1210];
bool vis[1210][1210];
struct node{
	int x,y,t;
	bool operator<(const node &a)const{
		return a.t<t;
	}
};
priority_queue<node> q;
void bfs(int x,int y){
	q.push({x,y,1});
	while(!q.empty())
	{
		node cur=q.top(); q.pop();
		int cx=cur.x,cy=cur.y,ct=cur.t;
		
		if(vis[cx][cy]||cx<1||cx>n||cy<1||cy>n||a[cx][cy]=='*') continue;
		vis[cx][cy]=1;
		
		if(cx==n&&cy==n){
			ans=min(ans,ct);
			return ;
		}
		if(a[cx][cy]=='A'){
			q.push({cx+1,cy,ct+1});
			q.push({cx-1,cy,ct+1});
			q.push({cx,cy+1,ct+1});
			q.push({cx,cy-1,ct+1});
		}
		if(a[cx][cy]=='B'){
			q.push({cx+2,cy,ct+1});
			q.push({cx-2,cy,ct+1});
			q.push({cx,cy+2,ct+1});
			q.push({cx,cy-2,ct+1});
		}
		if(a[cx][cy]=='C'){
			q.push({cx+1,cy+1,ct+2});
			q.push({cx-1,cy+1,ct+2});
			q.push({cx+1,cy-1,ct+2});
			q.push({cx-1,cy-1,ct+2});
		}
	}
}
void get(int x,int y)
{
	bfs(x,y);
	memset(vis,0,sizeof vis);
	while(!q.empty()) q.pop();
}
signed main()
{
	cin >> n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin >> a[i][j];
		}
	}
	get(1,1);
	get(n,1);
	get(1,n);
	if(ans<INT_MAX) printf("%lld",ans); 
	else printf("No answer");
	return 0;
}
```

---


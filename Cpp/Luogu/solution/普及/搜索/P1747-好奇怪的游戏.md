# 好奇怪的游戏

## 题目背景

《爱与愁的故事第三弹·shopping》娱乐章。

调调口味来道水题。


## 题目描述

爱与愁大神坐在公交车上无聊，于是玩起了手机。一款奇怪的游戏进入了爱与愁大神的眼帘：\*\*\*（游戏名被打上了马赛克）。这个游戏类似象棋，但是只有黑白马各一匹，在点 $x_1,y_1$ 和 $x_2,y_2$ 上。它们得从点 $x_1,y_1$ 和 $x_2,y_2$ 走到 $(1,1)$。这个游戏与普通象棋不同的地方是：马可以走“日”，也可以像象走“田”。现在爱与愁大神想知道两匹马到 $(1,1)$ 的最少步数，你能帮他解决这个问题么？

注意不能走到 $x$ 或 $y$ 坐标 $\le 0$ 的位置。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 数据，$1\le x_1,y_1,x_2,y_2 \le 20$。

## 样例 #1

### 输入

```
12 16
18 10```

### 输出

```
8 
9```

# 题解

## 作者：snaptrap (赞：253)

书上说这道题无法使用数学方法，因为有两种走法。我偏不信，只用了一个小时就推算出了一个公式：
# s4=s3+s2+(x+y-s2*3)/4;
- 解释一下，x代表行坐标，y代表列坐标
- s1是x与y的差
- s2是s1除以4的余数
- s3是s1除以4的商
- s4是最终得数

这个公式适用于所有除了(1,2)和(2,1)的情况，就是(10^8,10^9)也能求出正确答案。首先我们画一条对角线，沿着对角线让马走象步，所用步数最少。所以我们要想办法让处在对角线以外的马飞入对角线。因为象步相对比“飞日”快（不绝对，“飞日”在某些情况下比较精确），所以用象步慢慢逼近对角线，再用“飞日”准确插入到对角线中，步数一定最少。

如果本来就在对角线上，即x==y，那么飞到(1,1)的步数为x/2（x>=3，其余加特判）。飞入对角线只需看行列的差是否是4的倍数（拿(16,12)举例，象步即(x-2,y+2)，移项得(x+4,y)，x-y=4,4是4的倍数，所以可以直接飞入对角线），若有余数，则飞到象步所能飞到的最大位置，用“飞日”飞。
飞入对角线的步数为**(x-y)/4+余数**，两者相加就可求出最短路径。

```cpp
#include <cstdio>
int i,j,k,m,n,l,o,p,x,y;
int sum(int x,int y)
{
	int t,i,j,s1,s2,s3,s4;
	if(x<y)//有可能x<y,所以交换一下以便求差
	{
		t=x; 
		x=y;
		y=t;
	}
	if(x==2&&y==1) return 2;
	else if(x==2&&y==2) return 3;
    //这两个点过不去，特殊判定
	s1=x-y;//求差
	s2=s1%4;//余数
	s3=s1/4;//商
	s4=s3+s2+(x+y-s2*3)/4;
	return s4;
    /*细节：发现这个return s4不写，函数仍然返回s4的
    值因为定义在函数内部（包括main()）的变量用栈来分
    配空间，所以有时是随机数。
    在函数外部的变量用static
    分配，值总是0。函数的返回值在栈底（返回给
    main()，c++用ESP做栈寄存器），这个s4恰好就是栈
    底，如果没有定义变量的话栈底就是随机数了
    所以不写return也可以，大家可以试一试*/
 } 
int main()
{
	int a,b,c,d;
	scanf("%d%d",&a,&b);
	printf("%d\n",sum(a,b));
	scanf("%d%d",&c,&d);
	printf("%d",sum(c,d));
} 
```

我熬夜写的，可能有些啰嗦，恳求管理员帮忙挂在首页！

---

## 作者：做梦想Peach (赞：117)

这是一道裸的广搜（BFS）！！！（~~**较水**~~）

意思就是分别从两个马的位置一直到搜到（1,1）为止，在过程中累加步数，得到最优解。


看到许多大佬用的都是系统里的队列，没什么手动模拟队列的题解，今天窝这个蒟蒻就来发一篇手动模拟队列的题解吧。

如果不会广搜可以看一下这个：[戳我](https://www.cnblogs.com/fnlingnzb-learner/p/9052169.html)

闲话少叙，直接上代码。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;//头文件
bool vis[105][105];
int X,Y;
int dx[15]={-2,-1,1,2,2,2,2,1,-1,-2,2,-2},
	dy[15]={2,2,2,2,1,-1,-2,-2,-2,-2,1,-1};//因为有十二个方向，所以要写两个方向增量。
struct Node {
	int x,y;
	int step;
}queue[1100];//结构体，分别保存(x,y)，和当前最小步数。
void bfs(int X,int Y) {//开始搜！！！
	int head=0,tail=1,nx,ny;//head为头指针，tial为尾指针，nx为新的点的X轴，ny为新的点的Y轴。
	queue[1].x=X;
	queue[1].y=Y;
	queue[1].step=0;
	vis[X][Y]=true;//初始化。
	while (head<tail) {
		head++;
		for (int i=0;i<12;i++) {//枚举十二个点。
			nx=queue[head].x+dx[i];
			ny=queue[head].y+dy[i];
			if ((nx>=1&&nx<101)&&(ny>=1&&ny<101)&&vis[nx][ny]==false) {	//判断这个点是否可取。
			    tail++;
				queue[tail].x=nx;
				queue[tail].y=ny;
				queue[tail].step=queue[head].step+1;
				vis[nx][ny]=true;//保存这个点，以及步数。
				if (nx==1&&ny==1) {//判断是否到达了终点。
					printf ("%d\n",queue[tail].step);//输出
					return;
				}
			}
		}
	}
    return;//好习惯。
}
int main () {
	scanf ("%d%d",&X,&Y);
	bfs (X,Y);
	memset (vis,false,sizeof(vis));//注意一定要重新初始化！！！
	scanf ("%d%d",&X,&Y);
	bfs (X,Y);
	return 0;
}
```
**结束啦！！！**

**祝大家能平安的度过这场疫情。**

**~~来都来了，点个赞再走吧-_-~~**

---

## 作者：Billy●Herrington (赞：73)

大家好，我是**世界第一蒟蒻**（~~普及初赛都没参加过~~）czdh


这是本蒟蒻第一次发布题解qwq

好，我们先来看一看题目

既然是**最短路**，那当然首选BFS了  
因为DFS是一路走到头，直到走不了再后退一步，一般用来灌水或回溯qwq

但是，这个游戏中的马，不同于普通的马（马：我可是一个非同寻常的~~人~~马！），因为，这匹666的马，可以走“日”字，也可以走“田”字。

## 一般的马是这样的：

![](https://cdn.luogu.com.cn/upload/pic/26698.png )


P.S.作者太懒了 图丑勿喷
再P.S. K表示列，I表示行

## 但游戏中的马还可以这么走：

![](https://cdn.luogu.com.cn/upload/pic/26682.png )

P.S.(这个，，，~~图好像更丑啊~~）

所以，关于方向，应该这么写：

```
int dx[12]={1,1,2,2,2,2,-1,-1,-2,-2,-2,-2};
int dy[12]={-2,2,-2,-1,1,2,-2,2,-1,1,-2,2};
//d,既方向（direction）的缩写
```

好，现在方向我们知道了，那么应该怎么走呢？

我是从（1，1）开始，一直找到（x，y）

## 下面祭上代码：

```C++
#include <iostream>
#include <cstdio>
#include <queue>//STL队列头文件 
using namespace std ;
struct Node
{
	int x,y,step ;
	Node (int a=0,int b=0,int c=0) 
	{
		x=a;y=b;step=c;//x，y表示当前坐标，step表示是第多少步 
	}
}; 
bool VIS[60][60];//VIS数组表示当前一点是否访问过 
queue <Node> q;//我还是喜欢用STL啊qwq 
int dx[12]={1,1,2,2,2,2,-1,-1,-2,-2,-2,-2},dy[12]={-2,2,-2,-1,1,2,-2,2,-1,1,-2,2},nx,ny;
//d,既方向（direction）的缩写，nx与ny是输入的坐标（也就是马的位置），之所以是全局变量是因为bfs函数里要调用它们两个 
int  bfs (int x,int y)
{
	q.push(Node(x,y,0));//push()进队列函数 
	VIS[x][y]=true;//将当前点设为已访问 
	while(!q.empty())//empty()检测队列是否为空 
	{
		Node cur=q.front();//front()取队头元素 
		q.pop ();//删除队头元素 
		for (int k=0;k<12;k++) 
		{
			int ex=cur.x+dx[k],ey=cur.y+dy[k];//ex,ey既队头元素的拓展 
			if(ex>=1&&ey>=1&&ex<=50&&ey<=50&&!VIS[ex][ey])
			{
            	 //if语句判断条件的位置不能颠倒
                 //如果颠倒，将会越界访问
				q.push(Node(ex,ey,cur.step+1));
                //将这点进队
				VIS[ex][ey]=true;
                //标记为已访问
			}
			if(ex==nx&&ey==ny)return cur.step+1;
            //如果找到了，就返回
		} 
	}
}
int main()
{
	cin>>nx>>ny;
	cout<<bfs(1,1)<<endl;//从（1,1）开始查找 
	memset(VIS,0,sizeof(VIS));//清空VIS数组
	while(!q.empty())q.pop();//清空队列
	cin>>nx>>ny ;
	cout<<bfs(1,1)<<endl;
	return 0;
}
```

这是本蒟蒻第一次发布题解，若有不好请多包涵qwq

---

## 作者：_xcc_ (赞：29)

这是一道bfs模版题，思路是分别从两个马的位置一直到搜到（1,1）为止，在过程中累加步数，根据广搜层层拓展的原理可知最先搜到（1,1）时一定是最优解 

思路和楼下的大佬们差不多对吧，其实我主要想说说C++STL队列的应用，~~懒人必备~~，具体见代码注释 
```
#include<iostream>
#include<queue> //使用STL队列的头文件
#include<cstring>
using namespace std;
int x1,y1,x2,y2;
struct node{
	int x,y;
	int s;
};
//棋盘上一个点定为一个整体，x y为坐标，s为到这点所需最短步数
int dx[12]={2,2,-2,-2,-1,-1,1,1,-2,-2,2,2};
int dy[12]={2,-2,2,-2,-2,2,-2,2,1,-1,1,-1};
//枚举田字、日字的12种走法
bool b[1000][1000]; //记录点是否走过，防止重复拓展
queue<node> q; //定义一个队列，类型为node，queue是关键字，< >里填变量类型，也可以是int、float等等，q是队列名
int bfs(int x,int y) //广搜函数，x y为起点坐标
{
	node a;
	a.x=x,a.y=y,a.s=0; 
	q.push(a);
    //先初始化，把起点步数设为0，放入队列，用STL是不是很方便简洁
	do{
		a=q.front(); //引用队首元素，注意并不删除
		q.pop(); //队首元素出队
		for(int i=0;i<12;i++) //枚举12种走法
		{
			node c; //c记录下一步走到的点
			c.x=a.x+dx[i],c.y=a.y+dy[i];
			if(c.x>=1 && c.y>=1 && b[c.x][c.y]==false)
			{
				if(c.x==1 && c.y==1){
					return c.s; //到（1,1）就直接返回结果
				}
				b[c.x][c.y]=true; //记录此点已走过
				c.s=a.s+1; //这一点的最短步数=上一层（也就是拓展出它的那个点，点a）的最短步数+1步
				q.push(c); //把新拓展的c点放入队列
			}
		}
	}while(!q.empty()); //当队列不为空时继续
}
int main()
{
	cin>>x1>>y1>>x2>>y2;
	cout<<bfs(x1,y1)<<endl; //第一匹马
	memset(b,0,sizeof(b));
	while(!q.empty()) q.pop();
    //千万记得b这个标记数组要清零，而且搜到（1，1）时队列可能还没空，要清空
	cout<<bfs(x2,y2); //第二匹马
	return 0;
}
```
总结下STL队列的用法：
```
queue<int> a; //定义一个int类型的队列a
a.front(); //返回队列a的队首元素，并不删除
a.pop(); //删除队首元素（出队）
a.push(x); //将x入队
a.empty(); //检查a是否为空，空则返回true
```

---

## 作者：_yjh (赞：21)

## **这道题，我们可以用  三种方法  来实现。**
```cpp
1.queue 队列

2.deque 双向队列

3.vector 伪队列(向量)

```
~~__都属于STL库__~~


------------


## **进入正题：什么是**[**队列**](http://buhuibaidu.me/?s=C++队列)
```cpp
队列是一种特殊的线性表，
特殊之处在于：它只允许在表的前端进行删除操作，只允许在表的后端进行插入操作；
队列是一种操作受限制的线性表；
进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。
队列的数据元素又称为队列元素。
在队列中插入一个队列元素称为入队，
从队列中删除一个队列元素称为出队。
因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。
/*摘自 https://jingyan.baidu.com/article/b2c186c80ff8b7c46ff6ff50.html */
```
## __马的12个方向__
![](http://www.bbvdd.com/d/2019082412351818u.png)
```cpp
const int dx[]={2,2,2,2,1,1,-1,-1,-2,-2,-2,-2};
const int dy[]={-2,-1,1,2,-2,2,-2,2,-2,-1,1,2};
```

------------
## **queue、deque、vector 使用方法汇总**
### **#1 queue 队列(我的[另一篇题解](https://www.luogu.org/blog/yjhqinghia/solution-p1746)也有介绍)**
- 引入头文件 **queue**
```cpp
#include<queue>
```
- 定义一个 任何类型的队列 **(如int)**
```cpp
queue <类型名> 队列名;
```
- 使用 **库中的函数** 对其进行操作
```
//基本操作
/*定义一个队列q*/
#1 q.push(变量名); 将变量插入队尾
#2 q.pop(); 弹出队首的元素
#3 q.front(); 访问队首元素
#4 q.back(); 访问队尾元素
#5 q.empty(); 判断队列是否为空,是则返回true
#6 q.size(); 返回队中元素的个数
```

**#2 deque 双向队列**
- 引入头文件 **deque**
```cpp
#include<deque>
```
- 定义一个 任何类型的队列 **(如int)**
```cpp
deque <类型名> 队列名;
```
- 使用 **库中的函数** 对其进行操作
```
//基本操作
/*定义一个队列q*/ 
#1 q.empty(); 判断队列是否为空，是则返回true
#2 q.push_front(变量名); 将变量从队头入队
#3 q.push_back(变量); 将变量从队尾入队
#4 q.front(); 返回队头元素
#5 q.back(); 返回队尾元素
#6 q.pop_front(); 将队头元素弹出
#7 q.pop_back; 将队尾元素弹出
#8 q.clear(); 将队列清空
```

**#3 vector vector(伪队列)**
- 引入头文件 **vector**
```cpp
#include<vector>
```
- 定义一个 任何类型的向量 **(如int)**
```cpp
dueue <类型名> 向量名;
```
- 使用 **库中的函数** 对其进行操作
```
//基本操作
/*定义一个向量vec*/ 
#1 vec.push_back(变量名); 在向量尾部插入变量
#2 vec[0]; 使用下标访问元素
#3 vec.insert(vec.begin()+i,变量名); 在第i个元素后面插入变量;
#4 vec.erase(vec.begin()+2); 删除第3个元素
#5 vec.erase(vec.begin()+i,vec.end()+j); 删除区间[i,j-1];区间从0开始
#6 vec.size(); 返回向量大小
#7 vec.clear(); 清空向量 vec
```


------------
## **AC 代码**
**这里只给出 queue AC代码，其他的大致相同**
```cpp
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
struct Pos
{
	int x,y;
};
queue <Pos> q; //定义队列
const int n=20;
const int dx[]={2,2,2,2,1,1,-1,-1,-2,-2,-2,-2};
const int dy[]={-2,-1,1,2,-2,2,-2,2,-2,-1,1,2}; //定义12个方向
int x,y,tx,ty,a_x,a_y,b_x,b_y,dis[21][21],ans_a,ans_b;
bool vis[21][21];
int bfs(int sx,int sy)
{
	memset(vis,false,sizeof(vis));
	memset(dis,false,sizeof(dis)); //每次清空
	while(!q.empty()) q.pop();
	q.push((Pos){sx,sy}); //加入队列
	vis[sx][sy]=true;
	while(!q.empty())
	{
		x=q.front().x;
		y=q.front().y;
		q.pop();
		if(x+y==2) return dis[1][1];
		for(int i=0;i<12;i++)
		{
			tx=x+dx[i];
			ty=y+dy[i];
			if(tx<=0||tx>n||ty<=0||ty>n) continue;
			if(vis[tx][ty]==true) continue;
			dis[tx][ty]=dis[x][y]+1;
			vis[tx][ty]=true;
			q.push((Pos){tx,ty}); //弹出
		}
	}
}
int main()
{
	cin>>a_x>>a_y>>b_x>>b_y;
	ans_a=bfs(a_x,a_y);
	ans_b=bfs(b_x,b_y);
	cout<<ans_a<<endl;
	cout<<ans_b<<endl; //输出
	return 0;
}
```

---

## 作者：Battereamer (赞：17)

看到楼上的大爷们都是BFS写法，本蒟蒻决定在退役之前写一篇可以过审的题解

## 记忆化搜索

我们记录一个数组dp[ i ][ j ]表示走到(i, j)这个位置的最小步数，每次开始向下一层搜索时，先比较当前步数是否大于dp[ i ][ j ]，如果大于，即代表已经有更优的解了，也不必再更新后面的点了。

另外注意判掉边界就行了。

代码如下：（增量数组有点长罢了）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 23;
const int zl[12][2] = {{-1, -2}, {-2, -2}, {-2, -1}, {-1, 2}, {-2, 2}, {-2, 1}, {1, 2}, {2, 2}, {2, 1}, {1, -2}, {2, -2}, {2, -1}};
int dp[N][N];
int _x, _y, __x, __y;

void dfs(int x, int y, int step) {
	if(dp[x][y] <= step) return;
	if(dp[x][y] > step) dp[x][y] = step;
	for(int i = 0; i < 12; i++) {
		int xx = x + zl[i][0], yy = y + zl[i][1];
		if(xx < 1 || xx > 20 || yy < 1 || yy > 20) continue;
		dfs(xx, yy, step + 1);
	}
}

int main() {
	memset(dp, 0x3f, sizeof(dp));
	dfs(1, 1, 0);
	scanf("%d%d%d%d", &_x, &_y, &__x, &__y);
	printf("%d\n", dp[_x][_y]);
	printf("%d\n", dp[__x][__y]);
}
```

另外尽量避免使用x1、y1这样的变量哦！

---

## 作者：不一样的雾水 (赞：6)

# 这叫单调队列？  
## 这道题目就是考你仔不仔细！
我们看，黑马和白马的行动方式是相同的，所以其实就是两个数据点。于是我们就有了主程序：  
```pascal
begin
  readln(n,m);
  readln(x,y);
  writeln(got(n,m));//got就是答案。
  writeln(got(x,y));
end.
```  
好了，我们接下来先考虑普通情况：  
一般来说我们的两个坐标，每走一次会-1或-2。对吧？  
那么，我们可以让他们中的较大值每次减2，最终变成1。如果是偶数，就只减一次1（当然要加一步）。这样，我们的步数就确定了。  
```pascal
function got(c,d:longint):longint;
begin
  got:=(max(c,d)) div 2;//本来是+1的，但是因为最后走到（1,1）不是（0,0），所以不加
end;
```
这样子，我们可以得60分。当然，我们有一些特殊情况。  
1.两个坐标都比3小。这时我们必须要往外走。也就是说，会多用几步。
```pascal
  if (c=2) and (d=2) then exit(3);
  if (c=1) and (d=2) then exit(2);
  if (c=2) and (d=1) then exit(2);
```  
2.最大值为偶数，要加一步。因为我们要牺牲一步让他变成奇数（-1为偶数）。
```pascal
if (max(c,d) mod 2=1) then
  got:=(max(c,d)) div 2+1;
```
3.如果最大值减最小值是奇数，也要加一步。
```pascal
if ((max(c,d)-min(c,d)) mod 2=1) then
  got:=(max(c,d)) div 2+1;
```
比较费解？  
其实很简单。我们最快的方法当然是横纵每次都-2，但是如果最大值减最小值不是偶数，就意味着我们需要牺牲一步使得他们的差值变成偶数。这样子我们就多了一步。  
完整的代码（我是反着写的，也能AC）  
声明：这真的不是打表，以上的特殊情况都是需要讨论的。  
```pascal
program vvv;
var
  n,m,x,y:longint;
  o,z:longint;
function max(a,b:longint):longint;
begin
  if a>b then exit(a) else exit(b);
end;
function min(a,b:longint):longint;
begin
  if a>b then exit(b) else exit(a);
end;
function got(c,d:longint):longint;
begin
  if (c=2) and (d=2) then exit(3);
  if (c=1) and (d=2) then exit(2);
  if (c=2) and (d=1) then exit(2);
  if ((c*2>max(c,d)) and (d*2>max(c,d))) then
    begin
      got:=(max(c,d)) div 2;
      exit;
    end;
  if ((max(c,d)-min(c,d)) mod 2=0) or (max(c,d) mod 2=1) then
  begin
    got:=(max(c,d)) div 2;
    exit;
  end;
  got:=(max(c,d)) div 2+1;
end;
begin
  readln(n,m);
  readln(x,y);
  writeln(got(n,m));
  writeln(got(x,y));
end.
```
就是这样了，最简单的题解，学过选择结构就能用。希望得到支持~

---

## 作者：Hokage (赞：5)

## 这是一道基本的广搜题
### 我将介绍两种写法。
### 写法1：
1.这次马有两种走法，第一种是走“日”，第二种是走“田”。

所以在这里，我建了一个 pos 数组，其中下标除以 2 余 0 的表示横坐标的变化，除以 2 余 1 的下标表示纵坐标的变化。

如下
```
pos[24]={2,1,1,2,-2,1,-1,2,2,-1,1,-2,-1,-2,-2,-1,2,2,2,-2,-2,2,-2,-2};
```
2.我建了一个 vis 布尔型数组表示走过没走过。

true 表示走过，false 表示没走过。

3.分别以输入坐标为出发点，走到（1,1）为止。

4.注意在第一轮遍历后，一定要清空 vis 与队列~~~

下面见代码：
```
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;

const int N=1005;
int vis[N][N];
char _map[N][N];
int a,b,c,d;
int n;
int pos[24]={2,1,1,2,-2,1,-1,2,2,-1,1,-2,-1,-2,-2,-1,2,2,2,-2,-2,2,-2,-2};

struct Node
{
	int x,y;//横坐标，纵坐标。
	int step;//总步数。
};

queue<Node> q;//定义队列 q。

void bfs(int a,int b)
{
	Node t,nt;
	t.x=a;t.y=b;t.step=0;//附初始值
	q.push(t);//进队列
	while(!q.empty())
	{
		t=q.front();q.pop();
		if(t.x==1&&t.y==1)//找到情况
		{
			cout<<t.step<<endl;
			return ;
		}
		for(int i=0;i<12;i++)//12种情况
		{
			nt.x=t.x+pos[2*i];
			nt.y=t.y+pos[2*i+1];
			nt.step=t.step+1;
			if(nt.x<1||nt.y<1) continue;//越边界
			if(vis[nt.x][nt.y]) continue;//走过了
			vis[nt.x][nt.y]=1;
			q.push(nt); //如果可以走，才进入队列
		}
	}
}

int main()
{
	cin>>a>>b;
	bfs(a,b);
	memset(vis,0,sizeof(vis));
	while(!q.empty()) q.pop();
   //初始化很重要
	cin>>c>>d;
	bfs(c,d);
	return 0;
}
```
抄袭可耻，严禁复制。



---

## 作者：蔡俊黠 (赞：5)

#### 大家好我是深搜党
那就来个记忆化搜索吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y,f[30][30];
//f[i][j]:从i,j走到1,1所需的最小步数 
int dx[13]={0,-2,-2,+2,+2,-1,-1,+1,+1,-2,-2,+2,+2};
int dy[13]={0,-1,+1,-1,+1,-2,+2,-2,+2,-2,+2,-2,+2};
//马字8个方向，田字4个方向 
void dfs(int x,int y,int step) //记忆化搜索，走到x,y花了step步 
{
	f[x][y]=step; //更新最小步数 
	for (int i=1;i<=12;i++) //12个方向走一遍 
	{
		int xx=x+dx[i];
		int yy=y+dy[i];
		if (xx>=1&&xx<=20&&yy>=1&&yy<=20&&(f[xx][yy]==0||f[xx][yy]>step+1)) dfs(xx,yy,step+1);
		//如果没超出边界并且xx,yy可以被更新，就继续走 
	}
}
int main()
{
	for (int i=1;i<=2;i++)
	{
		scanf("%d%d",&x,&y);
		memset(f,0,sizeof(f));
		dfs(x,y,0); //走到x,y需要0步 
		printf("%d\n",f[1][1]); //最后输出 
	}
	return 0;
} 
```
我爱深搜，我爱深搜，我爱深搜！
等我哪天遇到非BFS不可的题目了我再写BFS(•‾̑⌣‾̑•)✧˖° 

---

## 作者：Sakura_Peng (赞：5)

题意说是可以走田也可以走日，那么就说明有12个方向：

```c
int dx[12]={2,-2,2,-2,1,1,-1,-1,2,2,-2,-2};//横坐标添加
int dy[12]={2,2,-2,-2,2,-2,2,-2,1,-1,1,-1};//纵坐标添加
```
还有这道题就是明显的BFS啊....

DFS和BFS在选择算法的最大区别就是：

DFS主要是在让你求所有的结果时多用

而BFS则是让你求一个最优解所用（因为BFS一层一层搜索，肯定最后是最优解）

这道题也一样的，从题干能够看出，是让求两匹马到1,1的最少步数。

###最少最少最少！

这道题整体的思路是：

从马开始所在的坐标开始搜索，搜索这个点到每一个点的最短步数。最后输出1,1这个坐标点的最短步数就OK了。

而且如果我们自己在图上推如何去求最短步数便可得（推导过程略，自力更生丰衣足食）

当前的结点的父节点+1的值，因此便可以直接使用BFS进行移动，然后把12个方向分别分成这一行的当前节点的12的子节点（如果12个方向符合不超出边界且没走过的情况），然后依次向下，直到所有的都过一遍。

我觉得这样讲有点晕，但是真的就是这样，仔细推敲一下就可以了。

上代码：

```c
#include <stdio.h>
#include <string.h>
int dx[12]={2,-2,2,-2,1,1,-1,-1,2,2,-2,-2};
int dy[12]={2,2,-2,-2,2,-2,2,-2,1,-1,1,-1}; //横纵坐标的方向 
int b[1001][1001],que[100001][3],a[1001][1001]; //b为判断是否走过，que为队列，a为最少步数 
int BFS(int x,int y)
{
    int tail=1,head=0;
    que[tail][0]=x;
    que[tail][1]=y;
    b[x][y]=1;   //初始化，第一个结点，即马的初始坐标先入队列 
    do
    {
        head++;
        for (int i=0;i<12;i++)
        {
            int x1=que[head][0]+dx[i]; //位置转换后的横坐标 
            int y1=que[head][1]+dy[i];  //位置转换后的纵坐标 
            if (x1>=1 && x1<=50 && y1<=50 & y1>=1 && b[x1][y1]==0)  //如果不出边界且这个地方没走过的话 
            {
                tail++; 
                que[tail][0]=x1;
                que[tail][1]=y1; //将新的结点入队列 
                b[x1][y1]=1;    //标记走过 
                a[x1][y1]=a[que[head][0]][que[head][1]]+1; //原本坐标的最少步数移了一步即为移动后坐标的步数 
            }
        }
    }while (head<tail);    //如果队列不为空 
    return a[1][1]; //最后调用a[1][1]即为1,1的最短路径 
}
int main()
{
    int x1,y1,i,j;
    scanf("%d%d",&x1,&y1); //输入第一个马的坐标 
    printf("%d\n",BFS(x1,y1)); //输出搜索的值 
    memset(b,0,sizeof(b)); 
        memset(que,0,sizeof(que));
            memset(a,0,sizeof(a)); //注意！！！这里我被坑了！一定要把所有再赋为初值！ 
scanf("%d%d",&x1,&y1);  //输入第二个马的值 
printf("%d\n",BFS(x1,y1)); //输出搜索的值 
return 0;
}
```
有个地方需要注意，就是在搜索时的边界，因为是要把所有的点都搜索一遍，所以就变成一个最大值，这里看了讨论区大佬所述！万分感谢！

我在想这道题目时有个地方有点卡壳，就是在

```c
a[x1][y1]=a[que[head][0]][que[head][1]]+1;
```
这里我原本写的是

```c
a[x1][y1]=que[head][2]+1;
```
这里的que[head][2]当前节点的步数，但是这时发现这样写莫名不对，然后就一直改，最后发现是因为有BUG，也是自己脑子抽筋了，因为这样写的话你的que[head][2]并没有赋上值，所以一直都0。

###这里就是蒟蒻题解的全部内容，望各位多多关照！


---

## 作者：whiteqwq (赞：4)

看着下面的题解都是bfs的，dfs来一发。

思路：直接搜，如果比之前这个点的步数少就替换。

搜索时使用方向矢量，节省了代码长度。

（注：（各种变量名字含义）

a, b, c, d -> 两匹马的坐标

f[i][j] -> 到达第i行j列需要的步数+1（f[1][1]为1）

dx[],dy[] -> 方向矢量）

	#include<bits/stdc++.h>//万能头
    using namespace std;
    int a,b,c,d,f[25][25],dx[13]={0,2,2,2,2,1,1,-1,-1,-2,-2,-2,-2},dy[13]={0,2,1,-1,-2,2,-2,2,-2,2,1,-1,-2};//前面已经说过了，不解释（貌似已经解释了QWQ）
    void dfs(int x,int y,int s){//到达第x行y列，步数为x
        f[x][y]=s;//标记
        for(int u=1;u<=12;u++){//开始拓展
            int ux=x+dx[u],uy=y+dy[u];//找到坐标
            if(ux<1||ux>20||uy<1||uy>20)//判边界
                continue;
            if(f[ux][uy]==0||f[ux][uy]>s+1)//可以拓展
                dfs(ux,uy,s+1);//拓展
        }
    }
    int main()
    {	scanf("%d%d%d%d",&a,&b,&c,&d);
        dfs(a,b,1);
        printf("%d\n",f[1][1]-1);
        memset(f,0,sizeof(f));//别忘清0
        dfs(c,d,1);
        printf("%d\n",f[1][1]-1);
        return 0;
    }


---

## 作者：aptx4869 (赞：4)

看楼下的全都是搜索，给出一个很简单的做法

从（1,1）忘外走，走到3步及以上时，会发现步数的分布呈现"\_|"形

所以对于五行五列以后的，O(1)判断即可

即：ans1=min(x1/2,y1/2);

ans2同上

至于五行五列以内，可以直接打表 ^\_^

    f[1][1]=0;

    f[2][3]=f[3][2]=f[3][3]=1;

    f[2][2]=f[3][4]=f[4][3]=3;

其他的是2..,

不过，对于联系搜索的童鞋而言，写写搜索也不错O(∩\_∩)O~


---

## 作者：Wider (赞：3)

菜鸟标准BFS无优化


```cpp
#include<iostream>
#include<cstring>
using namespace std;
int x1,x2,y1,y2;
int px[13]={0,2,-2,2,-2,1,1,-1,-1,2,2,-2,-2};//十二个方向
int py[13]={0,2,2,-2,-2,2,-2,2,-2,1,-1,1,-1};//十二个方向
struct que//队列
{
    int x;
    int y;
}q[10010];
int h,t,ans=0;
int num[100][100];//记录步数
int vis[100][100];
int bfs(int xn,int yn)//广搜
{
    memset(vis,0,sizeof(vis));
    memset(num,0,sizeof(vis));
    h=0;
    t=1;
    vis[xn][yn]=1;
    q[t].x=xn;
    q[t].y=yn;
    num[xn][yn]=0;
    while(h<t)
    {
        h++;
        if(q[h].x==1&&q[h].y==1)
        return num[1][1];
        for(int i=1;i<=12;i++)
        {
            int cx=q[h].x+px[i];
            int cy=q[h].y+py[i];
            if(cx>0&&cy>0&&vis[cx][cy]!=1)
            {
                t++;
                q[t].x=cx;
                q[t].y=cy;
                vis[cx][cy]=1;
                num[cx][cy]=num[q[h].x][q[h].y]+1;//当扫到下一个点时步骤数++
            }
        }
    }
}
int main()
{
    cin>>x1>>y1>>x2>>y2;
    cout<<bfs(x1,y1)<<endl<<bfs(x2,y2)<<endl;
    return 0;
}
```

---

## 作者：king_xbz (赞：2)

这是一道适合初学搜索的人刷的一道广搜题，然而我写了个神奇的双向队列，估计我是唯一用双向队列写的这道题的人吧。

因为有两匹马，一白一黑，所以我本意是想用单个deque代替两个queue。

然而看了题解，发现好像queue也可以做，看来还是我想多了

具体说这道题之前，我们先来简单了解一下双向队列这个东东（就当是科普了）。

首先，双向队列（deque）是STL中的一个容器

定义的方法如下：
```cpp
#include<deque>
deque <int>q;
```
注意，头文件是deque而不是queue（当然也可以像我一样直接bits/stdc++。.h行天下）

接下来是操作;

顾名思义，双向队列是可以进行头尾同时操作的队列，其进出和vector有些相似
```
q.push_back();//从尾进
q.push_front();//从头进
q.pop_back();//从尾出
q.pop_front();//从头出
q.empty()//是否为空
```
相比queue，deque还有特殊的功能：
```cpp
q.clear()//一键清空队列；
cout<<q[1];//随机访问；
```
deque就像是综合了queue和vector优点的神器！

接下来我们回到这道题，看看deque的特性如何在这体现。
先康康定义
```cpp
int a[hs][hs];
struct node
{
	int x;
	int y;
	int minns;
};
//结构体封装，更方便！
int sa[13]={0,2,2,-2,-2,-1,-1,1,1,-2,-2,2,2};//用数组预存能走的12个方向，
int sb[13]={0,2,-2,2,-2,-2,2,-2,2,1,-1,1,-1};//省的到时候不停的if—else
int xa,xb,ya,yb;
deque <node>m;今天的主角，双向队列
inline int bfs(int x,int y);
```
接下来是广搜程序
```cpp
inline int bfs(int x,int y)
{
	node n;
	n.x=x;//横坐标
	n.y=y;//纵坐标
	n.minns=0;//最短路
	m.push_back(n);//从尾进
	do
	{
		n=m.front();
		m.pop_front();//从头出（注意别从尾出了，这样队列就变成栈了）
		for(fint i=1;i<=12;i++)
		{
		node o;
		o.x=n.x+sa[i];
		o.y=n.y+sb[i];//跳马
		if(o.x==1&&o.y==1&&a[o.x][o.y]==0)
		return o.minns;
		else
		if(o.x>=1&&o.y>=1&&a[o.x][o.y]==0)
		{
		a[o.x][o.y]=1;
		o.minns=n.minns+1;//最短路增加
		m.push_back(o);//接着进队
	    }
	    }
    }
    while(!m.empty());
}
```
还是比较基础易懂的。
最后是异常简洁的主程序
```cpp
signed main()
{
	cin>>xa>>ya>>xb>>yb;
	cout<<bfs(xa,ya)<<endl;第一匹马
	memset(a,0,sizeof(a));//快速清空数组，省去循环嵌套
	m.clear();deque的一键清空特性
	cout<<bfs(xb,yb);第二匹马
	return 0;
} 
```
好了，这样就结束了，如果想更好了解deque，建议做做->[P1886](https://www.luogu.com.cn/problem/P1886)

[P1886AC代码点我](https://www.luogu.com.cn/paste/rczjks1o)

祝大家AC愉快！


---

## 作者：小菜鸟 (赞：2)

来自一个DFS党的…………………………………………深搜版题解？？？？？~~我不会写BFS~~
直接把深搜版马的遍历搬过来  ~~数据小所以还是AC了~~
上代码。。。
```cpp
#include<bits/stdc++.h>//懒于记头文件的孩纸~~
using namespace std;
int step,hx1,hy1,hx2,hy2;
short a[21][21];//棋盘
void move(int x,int y)//跳马
{
    if(x>20||x<1||y>20||y<1)return;//若跳出则返回
    if(a[x][y]!=-1 && step >= a[x][y])return;//若已跳到过或有更小结果则返回
    a[x][y]=step;//保存步数
    ++step;//步数上升
    move(x+2,y+1);//遍历可到的位置
    move(x+2,y-1);
    move(x-2,y+1);
    move(x-2,y-1);
    move(x+1,y+2);
    move(x+1,y-2);
    move(x-1,y+2);
    move(x-1,y-2);
    move(x+2,y+2);//这四行新加的
    move(x+2,y-2);
    move(x-2,y+2);
    move(x-2,y-2);
    --step;//还原步数
}
int main()
{
    memset(a,-1,sizeof(a));
    cin>>hx1>>hy1>>hx2>>hy2;
    move(1,1);//从(1,1)开始倒推
    cout<<a[hx1][hy1]<<endl<<a[hx2][hy2];
}
```

---

## 作者：cxy004 (赞：2)

很简单的BFS，从(1,1)点逆推就行了

边界设为(max(x1,x2)+2)\*(max(y1,y2)+2)

我这里为了用STL的队列把每个点的x坐标和y坐标都减1

```cpp
#include<cstdio>
#include<queue>
using namespace std;

const int t[12][2]={{-2,-2},{-2,2},{2,-2},{2,2},{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};
int a,b,x1,x2,y1,y2,f[23][23];
queue<int>q;

int main()
{
    scanf("%d%d%d%d",&x1,&y1,&x2,&y2);a=(x1>x2?x1:x2+2);b=(y1>y2?y1:y2)+2;
    for(int i=0;i<a;++i) for(int j=0;j<b;++j) f[i][j]=-1;f[0][0]=0;
    for(q.push(0);q.size();q.pop())
    {
      int x=q.front()/b,y=q.front()%b;
      for(int i=0;i<=11;++i)
      {
        int fx=x+t[i][0],fy=y+t[i][1];
        if((fx>=0)&&(fy>=0)&&(fx<a)&&(fy<b)&&(f[fx][fy]==-1)) {f[fx][fy]=f[x][y]+1;q.push(fx*b+fy);}
      }
    }
    printf("%d\n%d",f[x1-1][y1-1],f[x2-1][y2-1]);
    return 0;
}
```

---

## 作者：Hexarhy (赞：2)

### 这道题目比较基础，适合新手练BFS

那么新学BFS的蒟蒻现在就通过写题解练练手~

思路：

1）我用stl的queue存储，并且注意判断越界（虽然越界我并不知道判<=50有什么用可我还是AC）；

2）用一个bool数组记录是否去过这个点，判重；注意不需回溯还原；

3）bfs一组数据后，要记得清零和清空队列（注意queue是没有clear()函数）；

4）bfs过程就是枚举下一个点，符合要求就return，否则就在现在这个点的步数+1；

5）一个很坑的地方：**这里不要用while()，要用do-while()**~~然鹅我并不知道为什么这样做QAQ~~

具体看注释吧！

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
//STL大法好！！！STO
#include<cstring>
using namespace std;
struct node
{
	int x,y,tot;//tot是存储步数，x和y是坐标
};
//养成const的好习惯
const int dx[12]={2,2,-2,-2,-1,-1,1,1,-2,-2,2,2};
const int dy[12]={2,-2,2,-2,-2,2,-2,2,1,-1,1,-1};
const int ok=1200;
bool f[ok][ok];//判重，避免重复走
queue <node> q;
int bfs(int x,int y)
{
	node now;//初始化为起点
	now.x=x;
	now.y=y;
	now.tot=0;
	q.push(now);
	do//说过了，上面
	{
		now=q.front();
		q.pop();
		for(int i=0;i<12;i++)//枚举方向
		{
			node next;//枚举下一个点的位置
			next.x=now.x+dx[i];
			next.y=now.y+dy[i];
			if(next.x>=1 && next.y>=1 && !f[next.x][next.y])//判越界和判重
			{
				if(next.x==1 && next.y==1)
				 return next.tot;//符合要求返回
				f[next.x][next.y]=true;//标记，后面不用还原
				next.tot=now.tot+1;//上面说过
				q.push(next);
			}
		}
	}while(!q.empty());
}
char clear(void)
{
//记得清空f和队列
	memset(f,0,sizeof(f));
	while(!q.empty())
	 q.pop();
	return '\n';//十分省事的方法
}
int main()
{
	int x1,x2,y1,y2;
	cin>>x1>>y1>>x2>>y2;
	cout<<bfs(x1,y1)<<clear()<<bfs(x2,y2);//既清空又换行
	return 0;
}
```

---

## 作者：lych (赞：2)

看到本题，果断BFS

因为考虑到数据范围，可以先求出所有点到1,1的距离，然后直接输出

广搜求距离应该都会吧，只要做小小的改动就可以了

具体思路见标程：

```cpp
const
  fang:array[1..12,1..2] of longint=
    ((-2,-2),(-2,2),(2,-2),(2,2),(-2,-1),(-2,1),
    (-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1));//坐标数组，表示下一步可以跳到的位置
var
  h:array[0..1000,1..2] of longint;//队列数组，因为数据，其实400就够了
  f:array[-1..100,-1..100] of boolean;//表示有没有走过的boolean数组
  a:array[0..100,0..100] of longint;//表示该点走到1，1的最小距离
  i,j,head,tail,x,xx,y,yy:longint;
begin
  head:=0;
  tail:=1;
  h[1,1]:=1;
  h[1,2]:=1;
  for i:=1 to 20 do
    for j:=1 to 20 do
      f[i,j]:=true;
  f[1,1]:=false;
  while head<tail do
    begin
      inc(head);
      x:=h[head,1];
      y:=h[head,2];//将原点赋到x，y中，方便后面，也简化了代码
      for i:=1 to 12 do//枚举12个方向
        begin
          xx:=x+fang[i,1];
          yy:=y+fang[i,2];//走到的位置
          if f[xx,yy] then//不需要判断边界，因为边界都是false
            begin
              f[xx,yy]:=false;
              inc(tail);
              h[tail,1]:=xx;
              h[tail,2]:=yy;
              a[xx,yy]:=a[x,y]+1;//关键，将最短的路径保存下来
            end;
        end;
    end;
  readln(x,y);
  writeln(a[x,y]);
  readln(x,y);
  writeln(a[x,y]);//由于a数组已经保存了最短步数，所以直接输出即可
end.
```

---

## 作者：Aehnuwx (赞：1)

这道题几乎是一道 BFS 的模板题，唯一的不同大概只是移动规则有 12 个吧。

思路很容易想到：输入后**一遍** BFS 预处理出 $ (1, 1) $ 到所有点的最少步数（之所以不是所有点到 $ (1, 1) $ 到所有点的最少步数，是因为那样就要进行两次 BFS 了。大家可以自行思考一下），随后输出即可（题解中有些 dalao 用了两遍 BFS，我认为不必要）。

具体细节在代码中。

$ \rm code $

```cpp
# include <bits/stdc++.h>
using namespace std;
const int _move[12][2] = {{-2, -2}, {-2, -1}, {-2, 1}, {-2, 2}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -2}, {2, -1}, {2, 1}, {2, 2}}; // 移动规则的常量数组，个人不习惯写 dx[] 和 dy[]
const int maxN = 20 + 10; //这也是个人的习惯
struct Node {
    int x, y;
}q[maxN * maxN * 12]; //定义一个类型为 Node 的队列 q，目的是存放所有的状态
int ans[maxN][maxN], X1, Y1, X2, Y2; //ans数组存放(1, 1) 到所有点的最少步数，同时它还可以起到标记每个点是否走到过（后面的代码中有解释）。至于为什么X1 Y1 X2 Y2 这些变量用了大写，大家可以看看https://www.cnblogs.com/Patt/p/5518524.html，此处不再阐述
void bfs();
int main() {
    scanf("%d%d%d%d", &X1, &Y1, &X2, &Y2);
    bfs(); // BFS
    printf("%d\n%d", ans[X1][Y1], ans[X2][Y2]);
    return 0;
}
void bfs() {
    int head = 1, tail = 1; //先定义队首和队尾
    memset(ans, -1, sizeof(ans)); //之所以把ans数组全部定义为-1，是因为如果定义成0，就无法起到标记的作用了。因为 (1, 1) 是起点，所以ans[1][1]=0；而标记为没有到过的点的ans值如果也是0，那你就无法确认这个点到底是起点还是没有到过了。语言有些繁琐，大家将就着看看吧。
    ans[1][1] = 0;
    q[tail].x = 1, q[tail ++].y = 1; //记住tail要自加
    while(head < tail) { //只有当head<tail时，才有必要继续跑 BFS
        int x = q[head].x;
        int y = q[head ++].y; //取出队首的点，开始向 12 个方向扩展
        for(int i = 0; i < 12; i ++) {
            int _x = x + _move[i][0]; 
            int _y = y + _move[i][1]; //生成新的点
            if(_x < 1 || _x > 20 || _y < 1 || _y > 20 || ans[_x][_y] >= 0) continue; //先要判断这个点是否超出了棋盘的范围以及这个点是否到过
            q[tail].x = _x, q[tail ++].y = _y; //如果上面的判断都没有问题，那么就将这个点存进队列，tail自加。
            ans[_x][_y] = ans[x][y] + 1; //ans数组也要进行修改
        }		
    }
}
```

码字不易，望管理员和各位 OIer 多多支持，谢谢。

---

## 作者：喝烘箱 (赞：1)

这个题目背景真的好奇怪。。。      
其实这就是一道毫无新意的广搜。。。（根本不需要用到优先队列）
建立一个队列，然后不断搜索，直到第一次找到$( 1 , 1 )$这个位置 。

每一次搜索的时候我们需要知道当前马的位置，还有这个马已经走了几步。  
所以我们的队列里的每一个元素需要储存三个数，两个表示坐标，一个表示马已经走的步数。    
用一个结构体来模拟
```
    struct three
    {
        int i,j,time;
    };
    
    queue<three> sea;

```
 用$i$和$j$来表示马的位置，$time$来表示马走的步数，建立队列$sea$。
 
 之后用一个数组来储存马下一步走的方向，每一次搜索一个位置时，将他所有的方向搜索一遍，将并未走到过的并且没有超出圈定的区域的位置入队。
 
 这样的话就会需要一个数组来判重      
 还有就是我们需要确定这个圈定的范围，即找出可以让马最小步数走到所有位置的范围。
 
 但事实上这个范围非常容易找到，我们只需要适当的开大一点数组就可以了，因为我们可以很轻松的知道，这个超神的马在走到周围的位置时步数一定是这样的。
 
|   |   |   |   |    |   |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  | 1步 | 1步 | 2步 | 1步 | 1步 |
|  | 1步 | 2步 | 2步 | 2步 | 1步 |
|  | 2步 | 2步 | 马 | 2步 | 2步 |
|  | 1步 | 2步 | 2步 | 2步 | 1步 |
|  | 1步 | 1步 | 2步 | 1步 | 1步 |

所以这个马只要有一个$5$ X $ 5$的空间，即向上两行，向右两行能够行走，那么它就能遍历到周围所有的位置。。。

所以我们就只需要将数组上界开大个2，右界也开大个2就可以了

然后就显得十分美滋滋了。。。   
这个题就显得毫无难度了。。。

有一个小技巧，就是这个马可以走的方向实在是太多了，如果一个个手打的话怕不是要给累死，所以我们可以定义一个数组$dir$，来表示这个马可以走的方向
```
	int dir[12][2]={-1,-2,1,2,-1,2,1,-2,2,-1,2,1,-2,-1,-2,1,-2,-2,2,2,2,-2,-2,2};
```
这之后马（位置 $x$,$y$）要走的话就只需要访问$x+dir[i][0] , y+dir[i][1]$这一个位置就行了

请见代码
```
#include<cstdio>
#include<algorithm>
#include<cstring> 
#include<queue>
using namespace std;
int n,x,y;
int dir[12][2]={-1,-2,1,2,-1,2,1,-2,2,-1,2,1,-2,-1,-2,1,-2,-2,2,2,2,-2,-2,2};

bool ss[25][25];

struct three
{
    int i,j,time;
};

queue<three> sea;

bool judge(int i,int j)
{
    if(!ss[i][j])
    {
        if(i<=x&&j<=y&&i>=1&&j>=1)
        {
            return true;
        }
    }
    return false;
}

void bfs()
{
    while(!sea.empty())
    {
        int nowx=sea.front().i;
        int nowy=sea.front().j;
        int time=sea.front().time;//将队首元素取出
        sea.pop();//删除队首元素
        
        for(int i=0;i<12;i++)
        {
            int nexx=nowx+dir[i][0];
            int nexy=nowy+dir[i][1];
 //(nexx,nexy)为马下一步可走的位置，如果经判断该位置合法，就走到那个位置
            if(judge(nexx,nexy))//判断这个位置是否合法
            {
            	if(nexx==1&&nexy==1)//只要走到了指定位置，说明这个马走完了
                {
                    printf("%d\n",time+1);
					//所以输出走到该点的步数，因为time是走到上一个点的步数，所以输出time+1
                    //为接下来的马的搜索还原状态
                    while(!sea.empty())
                    {
                        sea.pop();
                    }
                    memset(ss,0,sizeof(ss));
                    return;
                }
                three so;
                so.i=nexx;
                so.j=nexy;
                ss[nexx][nexy]=1;
                so.time=time+1;
                sea.push(so);//将该可行位置入队
            }
        }
    }
}

int main()
{
    for(int please=1;please<=2;please++)
    {
        scanf("%d %d",&x , &y);
        three sw;
        sw.i=x;
        sw.j=y;
        sw.time=0;
        sea.push(sw);
        ss[x][y]=1;
        x+=4;
        y+=4;
        bfs();

    }
    
    return 0;
    
}
```

---

## 作者：WSEDSWZD (赞：1)

近乎广搜基本模板的一道水题....

就是一道求最短路径，想不通为啥普及/提高-的难度

可能就是多了四个方向吧...

直接上代码，注释在代码里。```cpp
```
#include<iostream>
#include<cstring>//memset的头文件
using namespace std;
int dir[12][2]={{2,1},{1,2},{-1,2},{-2,1},{-1,-2},{-2,-1},{1,-2},{2,-1},{2,2},{-2,-2},{2,-2},{-2,2}};//多了四个方向
int x0,x1,y0,y1;//起点
int f,r;//f是尾指针，r是头指针
int flag[100][100];//判重
struct node
{
    int x,y,dep;
}q[100000];//手写队列
void bfs(int i,int j)
{
    f=-1;
    r=0;
    q[0].x=1;
    q[0].y=1;
    q[0].dep=0;//队列初始化
    while(f<r)
    {
        node temp=q[++f];//取队头
        if(temp.x==i&&temp.y==j)
        {
            cout<<temp.dep<<endl;
            return;//到了就输出然后返回
        }
        for(int k=0;k<12;k++)
        {
            int nx=temp.x+dir[k][0];
            int ny=temp.y+dir[k][1];//12个方向
            if(nx<=0||ny<=0||nx>20||ny>20)continue;//出界
            if(flag[nx][ny]==0)
            {
                flag[nx][ny]=1;//标记
                r++;
                q[r].x=nx;
                q[r].y=ny;
                q[r].dep=temp.dep+1;//入队
            }
        }
    }
}
int main()
{
    cin>>x0>>y0>>x1>>y1;
    bfs(x0,y0);//先搜第一个
    memset(flag,0,sizeof(flag));
    memset(q,0,sizeof(q));//搜完第一个要清空
    bfs(x1,y1);//搜第二个
    return 0;//结束
}```
```

---

## 作者：Ofnoname (赞：1)

# 本蒟蒻的第一篇题解

本题并不难，没有什么坑。

基本思想是用广搜

不过我是从（1，1）搜到（SX,SY）（倒过来搜）
```
#include <cstdio>
#include <queue>
#include <cstring>		
//<cstring>里使用memset函数。
using namespace std;

const int MAX=25;
int SX,SY,ans,f[MAX][MAX];
//SX,SY是输入的终止点坐标，ans是答案，f用来存从（1，1）每一步的结果 
queue <int> qx,qy;
int dx[12]={2,-2,2,-2,1,1,-1,-1,2,2,-2,-2};
int dy[12]={2,2,-2,-2,2,-2,2,-2,1,-1,1,-1};
//保存12个方向 

void BFS()
//广搜函数，在main里被调用 
{
	while (!qx.empty())
	//开始广搜之前已经把（1，1）入队，不会在开始出现空队 
	{
		int x=qx.front();
		int y=qy.front();
		qx.pop();    qy.pop();
		//取队首，删队首 
		for (int i=0; i<12; i++)
		{			 
			int Tx=x+dx[i];
			int Ty=y+dy[i];
			//枚举12个方向，列出枚举后坐标 
			if (Tx==SX && Ty==SY)
			{
				//已经走到答案处就停止 
				ans=f[x][y]+1;
				return;
			}
			if (Tx>0 && Ty>0 && !f[Tx][Ty])
			{
				//（Tx>0）保证Tx不越界 
				qx.push(Tx);
				qy.push(Ty);
				f[Tx][Ty]=f[x][y]+1;
			}
		}
	}
}

int main()
{
	for (int i=1; i<=2; i++)
	//两次输入，两次相同算法 
	{
		scanf("%d%d",&SX,&SY);
		memset(f,0,sizeof(f));//重置f数组，方便下次使用 
		qx=qy=queue <int>();//充值两个坐标队列 ，方便下次使用 
		qx.push(1); qy.push(1);//把起始坐标入队 
		BFS();
		printf("%d\n",ans);
	}
	return 0; 
} 
```
由于SX,SY都在20以内，所以懒得判断棋盘上限；
直接把MAX开稍大一点，到25，就可以了

---

## 作者：我没有小白 (赞：1)

首先，楼下题解跟我不一样（我用的while而他用了do while手动滑稽）
这是一道很好的板子题，下面是bfs板子，给你们拿去用吧
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a,b,tot;
int vis[50][50];
int dx[12]={-1,-2,-2,-2,-2,-1,1,2,2,2,2,1};
int dy[12]={2,2,1,-1,-2,-2,-2,-2,-1,1,2,2};
int head,tail;
int q[500][4];
void debug()
{
    for(int i=1;i<=20;i++)
    {
        for(int j=1;j<=20;j++)
            cout<<vis[i][j];
        cout<<endl;
    }	
}
void bfs()
{
    q[1][0]=a;
    q[1][1]=b;
    q[1][2]=0;
    while(head<tail)
    {
        head++;
        for(int i=0;i<12;i++)
        {
            int xx=q[head][0]+dx[i];
            int yy=q[head][1]+dy[i];
            if(xx>0&&xx<=20&&yy>0&&yy<=20&&!vis[xx][yy])
            {
                tail++;
                vis[xx][yy]=1;
                q[tail][0]=xx;
                q[tail][1]=yy;
                q[tail][2]=q[head][2]+1;
                if(q[tail][0]==1&&q[tail][1]==1)
                    cout<<q[tail][2]<<endl;
            }
        }
    }
}
int main()
{
    for(int i=1;i<=2;i++)
    {
        head=0;
        tail=1;
        memset(vis,0,sizeof(vis));
        memset(q,0,sizeof(q));
        cin>>a>>b;
        bfs();
    }
}
```

---

## 作者：Harry_Potter (赞：1)

我们可以将问题转化为从1，1开始走到点xl，yl和点x2，y2分别需要的步数。


首先将点(1，1)加入队列中，之后进行bfs。

在 bfs时，只要依次枚举队列中的每一项，并枚举这一项的
所有后继节点（日+田共12种）。如果后继节点没有被访问过，则将距离记为当前距离+1并标记为访问过，加入队列末尾。

假如两个点都被访问过，则结束bfs，输出这两个点的答
案。

时间复杂度O(x * y)


代码如下，有注释
**请不要抄**

```cpp
#include <iostream>

int x1,y1,x2,y2,l,r,qx[100010],qy[100010],dis[110][110],X,Y;
using namespace std;

const int dx[]={-2,-2,-1,-1,1,1,2,2,-2,-2,2,2};
const int dy[]={1,-1,2,-2,2,-2,1,-1,2,-2,2,-2};



int main()
{
    cin>>x1>>y1>>x2>>y2;
    l=1;
    r=1;
    qx[1]=1;
    qy[1]=1;
    for(;l<=r;l++)
    {
    	X=qx[l];
    	Y=qy[l];
    	if(dis[x1][y1]&&dis[x2][y2])
    	break;
    	for( int i=0;i<12;i++ )
    	{
    		if(X+dx[i]>0&&Y+dy[i]>0&&!dis[X+dx[i]][Y+dy[i]])
    		{
    			dis[X+dx[i]][Y+dy[i]]=dis[X][Y]+1;
    			r++;//队列长度+1 
    			qx[r]=X+dx[i];
    			qy[r]=Y+dy[i];
    		}
    		
    	}
    }
	cout<<dis[x1][y1]-1<<endl;
	cout<<dis[x2][y2]-1<<endl;
	return 0;
}
```

---

## 作者：早右昕 (赞：1)

# 没有人反过来做？


从（1，1）到（x，y)，直接预处理：


---

略作修改的楼下(@Wanna1\_Peng )的代码：


```cpp

/*
  Моя сила!
*/
#include<cmath>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<set>
#include<map>
#include<stack>
#include<deque>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;

int dx[12]= {2,-2,2,-2,1,1,-1,-1,2,2,-2,-2};
int dy[12]= {2,2,-2,-2,2,-2,2,-2,1,-1,1,-1};
int b[21][21],que[1001][2],a[21][21];
void BFS() {
  int x=1,y=1;
  int tail=1,head=0;
  que[tail][0]=x;
  que[tail][1]=y;
  b[x][y]=1;
  do {
    head++;
    for (int i=0; i<12; i++) {
      int x1=que[head][0]+dx[i];
      int y1=que[head][1]+dy[i];
      if (x1>=1 && x1<=20 && y1<=20 & y1>=1 && b[x1][y1]==0) {
        tail++;
        que[tail][0]=x1;
        que[tail][1]=y1;
        b[x1][y1]=1;
        a[x1][y1]=a[que[head][0]][que[head][1]]+1;
      }
    }
  } while (head<tail);
}
int main() {
  BFS();
  int x,y;
  while(cin>>x>>y) {
    cout<<a[x][y]<<endl;
  }
  return 0;
}


```

---

## 作者：YWY_wys (赞：1)

##关于本题（最短路解法）

- 题意：


就是棋子可以走“日”也可以走“田”，现给你两个这样的棋子的坐标，问：棋子到（1,1）的最短距离


- 题解：


第一眼看到这个题，我想到了bfs。确实，这题的标程应该是bfs。但是不知道大家注意到没有，为什么给了两颗棋子的坐标而不是一颗？如果让你求三颗四颗乃至n颗呢？我的题解就是关于这个问题的。

棋子到（1,1）的最短距离不就是（1,1）到棋子的最短距离吗?  问题转化为（1,1）到棋子的最短路。——**单源最短路**。


那么问题来了，如何将棋盘抽象成图呢？


我们先给每个坐标一个编号。这里提供一种将坐标转化为序号的方法：num（x，y）=（i-1）\*m+y（m为棋盘的列数）；使用这个就可以完成编号操作（枚举每个点）。那么如何建边呢？这里不再多说，只提供一个常用的思路：在建无向图时，可将无向边看成两个反向的有向边（这样我们就可以只考虑每个点他自身与哪些点建边，而不重不漏）；


问题至此解决   再梳理一遍思路：

1. 输入

2. 建边

3. 单源最短路

4. 输出

- code
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int maxm=30005;
const int maxn=905;
const int dx[12]={2,-2,2,-2,1,1,-1,-1,2,2,-2,-2};//方向数组 
const int dy[12]={2,2,-2,-2,2,-2,2,-2,1,-1,1,-1};
struct e{
    int u,v,next;
}edge[maxm];//前向星 
int x1,x2,y1,y2;
int cnt;
int head[maxn],dis[maxn];
bool inq[maxn];
queue<int> q;
void adde(int u,int v){//u，v之间建一条u->v的有向边 
    edge[++cnt]=(e){u,v,head[u]};
    head[u]=cnt;
}
int getnum(int x,int y){return (x-1)*30+y;}
bool in(int x,int y){//判断（x，y）是否在棋盘里 
    if(x>30||x<1||y>30||y<1) return false;
    return true;
}
void spfa(int s){//单源最短路 
    memset(dis,0x3f,sizeof dis);
    q.push(s);
    inq[s]=true;
    dis[s]=0;
    while(q.size()){
        int u=q.front();
        q.pop();
        inq[u]=false;
        for(int i=head[u];i;i=edge[i].next){
            int v=edge[i].v;
            if(dis[v]>dis[u]+1){
                dis[v]=dis[u]+1;
                if(!inq[v]){
                    q.push(v);
                    inq[v]=true;
                }
            }
        }
    }
}
void inite(){//建图 
    for(int i=1;i<=30;i++)
        for(int j=1;j<=30;j++)
            for(int k=0;k<12;k++){
                int x=i+dx[k],y=j+dy[k];
                if(in(x,y)) adde(getnum(i,j),getnum(x,y));
            }
}
int main(){
    scanf("%d%d",&x1,&y1);
    scanf("%d%d",&x2,&y2);
    inite();
    spfa(1);
    printf("%d\n",dis[getnum(x1,y1)]);
    printf("%d\n",dis[getnum(x2,y2)]);
}
```


---

## 作者：zhych (赞：1)

    










```cpp
const
    MAX_LEN = 400;
type 
    dataType = record //记录类型
        x : Integer;             //坐标x
        y : Integer;            //坐标y
        count : longint;    //共跳了几步
    end;
    queue = record  //队列
        head : longint;
        tail : longint;
        a : array[0..MAX_LEN - 1] of dataType;
    end;
    direction = array[1..12, 1..2] of integer;//可能跳到的12种方向的坐标
const 
    dir : direction = (
            (-1, -2), (-2, -1), (-2, 1), (-1, 2),
            (1, -2), (2, -1), (2, 1), (1, 2),
            (-2, -2), (-2, 2), (2, -2), (2, 2)
        );    
var
    q : queue;
    x1,y1,x2,y2 : integer;
    jumped : array[1..100, 1..100] of boolean;//判断是否跳过的布尔型数组
procedure init(var q:queue);//队列初始化
begin
    q.head := 0;
    q. tail := 0;
end;
function isEmpty(var q : queue): boolean;//队列判空
begin
    if q.head = q.tail then exit(true);
    exit(false);
end;
procedure push_back(var q : queue;data : dataType);//入队列
begin
    if ((q.tail + 1) mod MAX_LEN) <> q.head then 
    begin
        q.a[q.tail] := data;
        q.tail := (q.tail + 1) mod MAX_LEN;//巧妙的方法可以自己举例子试一试
    end;
end;
function pop_back(var q : queue): dataType;//出队列
var
    tmp: dataType;
begin
    if not isEmpty(q) then 
    begin
        tmp := q.a[q.head];
        q.head := (q.head + 1) mod MAX_LEN;
        exit(tmp);
    end;
    tmp.count := -1;
    exit(tmp);
end;
function canJump(x, y : integer): boolean;//判断是否跳过此点
begin
    if (x >= 1) and (x <= 20) and (y >=1) and (y <= 20) then exit(true);
    exit(false);
end;
function search(x, y:integer; d:direction; n :integer): longint;//广度优先搜索
var
    cur, next: dataType;
    i : integer;
begin
    cur.x := x;
    cur.y := y;
    cur.count := 0;
    jumped[x, y] := true;
    push_back(q, cur);
    while not isEmpty(q) do
    begin
        cur := pop_back(q);
        //writeln(cur.x, ' ', cur.y);
        if (cur.x = 1) and (cur.y = 1) then exit(cur.count);
        for i := 1 to n do
        begin
            if canJump( cur.x + d[i, 1], cur.y + d[i, 2] ) and not jumped[cur.x + d[i, 1], cur.y + d[i, 2]] then
            begin
                next.x := cur.x + d[i, 1];
                next.y := cur.y + d[i, 2];
                jumped[next.x, next.y] := true;
                next.count := cur.count + 1;
                push_back(q, next);
            end;
        end;
    end;
    exit(-1);
end;
begin
    readln(x1, y1);
    readln(x2, y2);
    init(q);
    fillchar(jumped, sizeof(jumped), false);
    writeln(search(x1, y1, dir, 12));
    init(q);
    fillchar(jumped, sizeof(jumped), false);
    writeln(search(x2, y2, dir, 12));
end.
```

---

## 作者：墨凝而止 (赞：1)

```delphi
const
 way:array[1..12,1..2] of longint=((-2,-2),(-2,2),(2,-2),(2,2),(-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1));{坐标xy增量（需注意）}
var
a:array[0..1000,0..1000]of longint;
b:array[0..1000000,1..2]of longint;{队列}
i,j,x,y,n,x1,x2,y1,y2,o:longint;
procedure gs;{广搜}
var i,j,k,l,p,q:longint;
begin
p:=1;q:=2;{头尾指针}
b[p,1]:=1;b[p,2]:=1;{录入起点}
repeat
for i:=1 to 12 do
begin
k:=b[p,1]+way[i,1];l:=b[p,2]+way[i,2];{加上增量}
if (k>0)and(l>0)and(a[k,l]=0)and(k<=20)and(l<=20){未越界，且未走过} then
begin
b[q,1]:=k;{记录}
b[q,2]:=l;{记录}
a[k,l]:=a[b[p,1],b[p,2]]+1;
inc(q);
end;
end;
inc(p);
until p=q;
end;
begin
read(x1,y1);
read(x2,y2);
a[1,1]:=1;{防止重新走过}
gs;
writeln(a[x1,y1]-1);
writeln(a[x2,y2]-1);
end.
```
[color=green]此题为最为经典的广搜。因n<=20，故采用直接全部填充。采用从（1,1）逆推。是为解。[/color]


---

## 作者：千反田 (赞：0)

本蒟蒻又~~无耻~~地来发题解了

一道~~很水的~~广搜模板题（想不通为啥普及/提高-的难度）

首先打出x，y增量
```cpp
const int add_x[13]={0,2,2,-2,-2,-1,-1,1,1,-2,-2,2,2},
          add_y[13]={0,2,-2,2,-2,-2,2,-2,2,1,-1,1,-1};
```
由于该题没有边界（~~本蒟蒻看不出来~~）

所以只需判断坐标是否为非负数且有没有遍历过就行了
```cpp
if(X>0&&Y>0&&!trace[X][Y])
```
基本上代码就出来了

233

```
#include<bits/stdc++.h>
#define inf INT_MAX
#define N 1005
#define Num 1000005//个人习惯
using namespace std;
const int add_x[13]={0,2,2,-2,-2,-1,-1,1,1,-2,-2,2,2},
          add_y[13]={0,2,-2,2,-2,-2,2,-2,2,1,-1,1,-1};//x，y增量
struct coordinate
{
	int x,y;
}que[Num],black,white;//结构体，que为队列，black，white为白马黑马起始位置
bool trace[N][N];//判断该点是否遍历过
int t[Num];//存放步数的队列
int BFS(int x,int y)
{
	int head=0,tail=1;
	que[1].x=x;
	que[1].y=y;//入队
	while(head<tail)
	{
		++head;
		for(int i=1;i<=12;++i)
		{
			int X=que[head].x+add_x[i];
			int Y=que[head].y+add_y[i];
			if(X>0&&Y>0&&!trace[X][Y])//如果该点合法
			{
				++tail;
				trace[X][Y]=true;
				que[tail].x=X;
				que[tail].y=Y;//入队，标记
				t[tail]=t[head]+1;//该节点的步数等于它父亲节点的步数+1
				if(X==1&&Y==1)//如果搜到了
				 return t[tail];//返回
			}
		}
	}
}
int main()
{
	scanf("%d%d%d%d",&black.x,&black.y,&white.x,&white.y);
	printf("%d\n",BFS(black.x,black.y));//查询第一次
	memset(trace,false,sizeof(trace));
	printf("%d",BFS(white.x,white.y));//查询第二次
    return ~~(0-0);//卖萌求通过
}
```



---

## 作者：NF_水饺 (赞：0)

在棋盘上走最短路，第一个想到的可行解法就是BFS

马有12种可行方向：日字走8种，田字有4种

两匹马可以分开走（只是求最短路），地图还算小，跑2次BFS基本没可能超时

```
#include<iostream>
#include<cstring>
using namespace std;
int xx,yy,x0,y0;
struct data
{
    int x,y,t;
}q[400+10];
bool vis[20+10][20+10];
const int dx[]={2,1,-1,-2,-2,-1,1,2,2,2,-2,-2};
const int dy[]={1,2,2,1,-1,-2,-2,-1,2,-2,-2,2};
//直接存方向，到时候两边坐标加上这个方向即可实现移动
void clear()
{
    memset(vis,0,sizeof(vis));
    memset(q,0,sizeof(q));
}
//两次bfs之间清空一次队列和标记
int bfs(int a,int b)
{
    vis[a][b]=1;
    q[1].x=a;
    q[1].y=b;
    q[1].t=0;
    int head=1,tail=1;
    while(head<=tail)
    {
        data exp=q[head++];
        for(int i=0;i<12;i++)
        {
            int nx=exp.x+dx[i],ny=exp.y+dy[i];
            if(nx<1||ny<1||nx>20||ny>20||vis[nx][ny]) continue;
            vis[nx][ny]=1;
            tail++;
            q[tail].x=nx;
            q[tail].y=ny;
            q[tail].t=exp.t+1;
            if(nx==1&&ny==1) return q[tail].t;
        }
    }
}
//手打队列的BFS写法
int main()
{
    cin>>xx>>yy>>x0>>y0;
    cout<<bfs(xx,yy)<<endl;
    clear();
    cout<<bfs(x0,y0)<<endl;
    return 0;
 } 
 ```
PS.两个常量数组可以方便完成马的移动，比逐行移动更快捷便利


---

## 作者：fl_334 (赞：0)

```delphi

           果断广搜咩,pas党们别哭。。。（用队列写广搜的崩溃pa们）
const   max_len=400;
        xx:array[1..12,1..2]of longint=((-2,-1),(-2,1),(-1,2),(-1,-2),(2,1),(1,2),(2,-1),(1,-2),(-2,-2),(-2,2),(2,2),(2,-2));
//数组控制行列
type
        yy=record
        count,x,y:longint;
        end;
        queue=record
                head,tail:longint;         //头尾指针
                a:array[0..max_len]of yy;
                end;//数组

var
        i,j,n,k:longint;
        x1,y1,x2,y2:longint;
        q:queue;
        b:array[0..100,0..100]of boolean;

function buyuejie(x,y:longint):boolean;
begin
        if (x>0) and (y>0) and (x<=20) and (y<=20) then exit(true)
        else exit(false);
end;                         //判断越界与否
下面给出核心代码     
function search(xxx,yyy:longint):longint;
var
        pre,next:yy;
begin
        pre.x:=xxx;
        pre.y:=yyy;
        pre.count:=0;
        push(q,pre);
        while not isempty(q) do
        begin

                pre:=pop(q);
                if (pre.x=1) and (pre.y=1) then exit(pre.count);
                for i:=1 to 12 do
                if buyuejie(pre.x+xx[i,1],pre.y+xx[i,2])
                then if (b[pre.x+xx[i,1],pre.y+xx[i,2]]) then      //判断条件
                begin
                        next.x:=pre.x+xx[i,1];
                        next.y:=pre.y+xx[i,2];
                        b[next.x,next.y]:=false;
                        next.count:=pre.count+1;
                        push(q,next);        //push自己尝试去写
                end;
        end;
end;

begin
        readln(x1,y1);
        readln(x2,y2);
        q.head:=0;
        q.tail:=0;
        fillchar(b,sizeof(b),true);
        writeln(search(x1,y1));
        q.tail:=0;
        q.head:=0;
        fillchar(b,sizeof(b),true);
        writeln(search(x2,y2));        //输出
end.

```

---


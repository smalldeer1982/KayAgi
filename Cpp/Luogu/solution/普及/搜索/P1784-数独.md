# 数独

## 题目描述

数独是根据 $9 \times 9$ 盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含 $1 - 9$ ，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。

芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。

这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。

据介绍，目前数独游戏的难度的等级有一到五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的等级。他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。

## 说明/提示

2022-04-17 @farteryhr 贡献了三组 hack 数据。加入了其中两组。第三组过强（来源：<https://www.dcc.fc.up.pt/~acm/sudoku.pdf>），放在下边供自测。

```
9 0 0 8 0 0 0 0 0
0 0 0 0 0 0 5 0 0 
0 0 0 0 0 0 0 0 0 
0 2 0 0 1 0 0 0 3
0 1 0 0 0 0 0 6 0
0 0 0 4 0 0 0 7 0
7 0 8 6 0 0 0 0 0 
0 0 0 0 3 0 1 0 0 
4 0 0 0 0 0 2 0 0 
```

输出

```
9 7 2 8 5 3 6 1 4 
1 4 6 2 7 9 5 3 8 
5 8 3 1 4 6 7 2 9 
6 2 4 7 1 8 9 5 3 
8 1 7 3 9 5 4 6 2 
3 5 9 4 6 2 8 7 1 
7 9 8 6 2 1 3 4 5 
2 6 5 9 3 4 1 8 7 
4 3 1 5 8 7 2 9 6 
```

## 样例 #1

### 输入

```
8 0 0 0 0 0 0 0 0 
0 0 3 6 0 0 0 0 0 
0 7 0 0 9 0 2 0 0 
0 5 0 0 0 7 0 0 0 
0 0 0 0 4 5 7 0 0 
0 0 0 1 0 0 0 3 0 
0 0 1 0 0 0 0 6 8 
0 0 8 5 0 0 0 1 0 
0 9 0 0 0 0 4 0 0```

### 输出

```
8 1 2 7 5 3 6 4 9 
9 4 3 6 8 2 1 7 5 
6 7 5 4 9 1 2 8 3 
1 5 4 2 3 7 8 9 6 
3 6 9 8 4 5 7 2 1 
2 8 7 1 6 9 5 3 4 
5 2 1 9 7 4 3 6 8 
4 3 8 5 2 6 9 1 7 
7 9 6 3 1 8 4 5 2```

# 题解

## 作者：stone_juice石汁 (赞：666)

## 我来凑热闹了OvO
其实我刷完这道题的时候，看到有一些DALAO做的方法差不多哎，但是都不是很详细，一部分人可能看不懂哦..。
所以，**我写的以下题解会超多**，做好心理准备吧。QWQ


------------
### 数独规则（懂规则的可以跳过）
按照百度上的说法是这样子的：

**数独**是源自18世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，**并满足每一行、每一列、每一个粗线宫（3×3）内的数字均含1-9，不重复。**


![](https://cdn.luogu.com.cn/upload/pic/49247.png)


**如上图**

重点部分我都用黑体标出来了。规则是这样的，虽然数独是需要逻辑推算的，但是对于计算机来说，就直接枚举每个格子的可能性就可以了（真暴力...）。那么我们如何通过程序实现呢？


------------
### 判断重复
数独要求每一行、每一列、每一个3×3方阵内的数字，不重复。

**行和列重复判断**是相当简单的。我们可以定义两个bool型二维数组，当此行（或列）填充数字时，我们可以直接把这行的这个数字打上true表示有数字了。

```
//譬如第一行第三列填入数字2
bool p[][],l[][];//p:行,l:列;
p[1][2]=l[3][2]=true;
```
如果后面再填充数字，就判断此行（或列）是否填过这个数字即可。

### 重点：判断方阵中数字重复

如果判断方阵中数字重复？怎样用行列来表示是几方阵成了个问题。但是不用怕，我们有van能的数学。

观察下面这个数独：

![](https://cdn.luogu.com.cn/upload/pic/49247.png)

可以看到，每过3列，方阵的序号+1，每过3行，方阵的序号+3。

于是我们有了这样的表达式：
```

方阵序号=（行数-1）/3*3+（列数-1）/3+1
//注意！行数列数要-1，因为3的整数倍数/3会比原方阵大1，不能满足上述需求。
```
如果填充了数字，就用这个表达式把相应方阵的相应数字打上true标记就可以了。


------------
**有了上述方法，就可以写个深搜函数来解决问题了！**

至于剩下的，代码里批注讲哦！上代码！

```
//stone_juice P1784 数独 
#include <bits/stdc++.h>//华丽的开头~ 
using namespace std;
int sd[11][11];//数独方阵定义 
bool p[11][11],l[11][11],fz[11][11];//行（排？），列，方阵。 
void _out()//优美地输出~ 
{
	for(int i=1;i<=9;i++)
	{	
  		for(int j=1;j<=9;j++)
			cout<<sd[i][j]<<" ";
		cout<<endl;
	}
	exit(0);//注意，此处要用exit(0)。用return的话不会退出dfs函数，会增加运算量。 
}
void dfs(int x,int y)//神奇的深搜~
{
	if(sd[x][y]!=0)//如果原来这个位置有数字，跳过。 
		if(x==9&&y==9)_out();//当行列都为9，填充完成，输出~
		else if(y==9)dfs(x+1,1);//当列数为9，搜索下一排。 
		else dfs(x,y+1);//搜下一列啦~ 
	else//原来的地方没有数字，准备填充！ 
		for(int i=1;i<=9;i++)
			if((!p[x][i])&&(!l[y][i])&&(!fz[(x-1)/3*3+(y-1)/3+1][i]))
			//判断是不是重复了。方法题解有讲！ 
			{
				sd[x][y]=i;//填充！ 
				p[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=true;//打上标记。 
				if(x==9&&y==9)_out();//全部填完！输出~ 
				else if(y==9)dfs(x+1,1);//同上！搜下一行。
				else dfs(x,y+1);//搜下一列！ 
				sd[x][y]=0; //恢复标记。 
				p[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=false;//恢复标记。 
			}
}
int main()
{
	for(int i=1;i<=9;i++)
		for(int j=1;j<=9;j++)
		{
			int t;//定义tmp（防止下面代码太长？） 
			cin>>t;//炫酷地输入 
			if(t!=0)
				p[i][t]=l[j][t]=fz[(i-1)/3*3+(j-1)/3+1][t]=true;
			//填充的不是0的话，表示原来有数字了。打上标记。	
			sd[i][j]=t;//填充进数独。 
		}	
	dfs(1,1);//搜搜搜！ 
	return 0;//完美地结束~ 
}
```
### 虽然我的方法不是最优解，但是看我写的这么认真，各位DALAO给个赞呗！祝愿你们早日AC!!
```
#include <致管理员：我不小心把图弄挂了...请重新审核一下吧谢谢QWQ>
```

---

## 作者：misayap (赞：219)

//普通的搜索，先将所有格都判为true，其中不为零的判为false，为达到不重复的目的要将坐标的二维数组拆成行列格三个一维数组，

//每个一维数组再加上当前的数组形成二维，搜索即可。

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
int a[10][10];
bool h[10][10],l[10][10],g[10][10];//行，列，第几个格子
void print()//输出函数 
{
    for(int i=1;i<=9;i++)
    {
        for(int j=1;j<=9;j++)
            printf("%d ",a[i][j]);
        printf("\n");
    }
    exit(0);
}
void dfs(int x,int y)//深搜 
{
    if(a[x][y]!=0)//9*9中不为零的数直接跳过 
    {
        if(x==9&&y==9) 
            print();//搜索结束后输出 
        if(y==9) //行到顶端后搜索列 
            dfs(x+1,1); 
        else //搜索行 
            dfs(x,y+1);
    }
    if(a[x][y]==0)//等于零时 
    {
        for(int i=1;i<=9;i++)
        { 
            if(h[x][i]&&l[y][i]&&g[(x-1)/3*3+(y-1)/3+1][i])
            {
                a[x][y]=i;
                h[x][i]=false;//此格被占 (行） 
                l[y][i]=false;//同上 （列） 
                g[(x-1)/3*3+(y-1)/3+1][i]=false;//同上 （格子） 
                if(x==9&&y==9) //同a[x][y]!=0时                    
                    print();
                if(y==9) dfs(x+1,1); else dfs(x,y+1);
                a[x][y]=0;//当前格退出 
                h[x][i]=true;
                l[y][i]=true;
                g[(x-1)/3*3+(y-1)/3+1][i]=true;
            }
        } 
    }
}
int main()
{
    memset(h,true,sizeof(h));
    memset(l,true,sizeof(l));
    memset(g,true,sizeof(g));
    for(int i=1;i<=9;i++)
    {
        for(int j=1;j<=9;j++)
        {
            scanf("%d",&a[i][j]);
            if(a[i][j]>0)
            {
                h[i][a[i][j]]=false;//表示格子上有数 
                l[j][a[i][j]]=false;//同上 
                g[(i-1)/3*3+(j-1)/3+1][a[i][j]]=false;//同上 
            }
        }
    } 
    dfs(1,1);
    return 0;
}
```

---

## 作者：钱逸凡 (赞：125)



~~做完靶形数独发现可以水经验，还能水题解~~
## 对于数独问题dancing links是很好的选择
先梳理一下关系：
1. 每个点只能填一个数
1. 每个行只能填每种数各一个
1. 每个列只能填每种数各一个
1. 每个宫只能填每种数各一个

#### 于是我们把点对应成一个集合，包含4个元素，分别表示对应的数，行，列，宫。然后精确覆盖即可。
直接上代码吧，注释应该算比较详尽的。
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define mx 100100//其实不用这么大只要大于729*324即可 
int sum=0;
int a[10][10];//每个点的数
inline int Read(){
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}//快读好习惯 
struct DLX{
	int n,m,cnt;//矩阵的长，宽，点的数量
	int l[mx],r[mx],u[mx],d[mx],row[mx],col[mx];//每个点的左，右，上下，行，列信息 
	int h[mx];//每行的头结点 
	int s[mx];//每列的结点数 
	int ansk[mx];//ansk[] 装答案（选了哪几行）
	void init(int _n,int _m){
		n=_n,m=_m;
		int i;
		for(i=0;i<=m;i++){
			r[i]=i+1;l[i]=i-1;u[i]=d[i]=i;
		}
		r[m]=0;//m右边是0 
		l[0]=m;//0左边是m 
		memset(h,-1,sizeof(h));
		memset(s,0,sizeof(s));
		cnt=m+1;//开始时有m个结点（0结点和各列头结点） 
	}//初始化，生成每列的头
	void link(int R,int C){
		s[C]++;
		row[cnt]=R;
		col[cnt]=C;
		u[cnt]=C;
		d[cnt]=d[C];
		u[d[C]]=cnt;
		d[C]=cnt;
		if(h[R]<0)h[R]=r[cnt]=l[cnt]=cnt;//该行没有别的点,把第一个加入的点作为该行的行头结点 
		else{
			r[cnt]=h[R];
			l[cnt]=l[h[R]];
			r[l[h[R]]]=cnt;
			l[h[R]]=cnt;
		}
		cnt++;
	}//在r行c列插入点
	void remove(int c){
		r[l[c]]=r[c],l[r[c]]=l[c];
		for(int i=d[c];i!=c;i=d[i]){
			for(int j=r[i];j!=i;j=r[j]){
				u[d[j]]=u[j];
				d[u[j]]=d[j];
				s[col[j]]--;
			}
		}
	}//删除c列和c列上有点的行
	void resume(int c){
		for(int i=u[c];i!=c;i=u[i]){
			for(int j=l[i];j!=i;j=l[j]){
				u[d[j]]=j;
				d[u[j]]=j;
				s[col[j]]++;
			}
		}
		r[l[c]]=c;
		l[r[c]]=c;
	}//恢复c列和c列上有点的行
	bool dance(int deep){
		if(r[0]==0){
			int x,y,v;
			for(int i=0;i<deep;i++){
			x=(ansk[i]-1)/9/9;
			y=(ansk[i]-1)/9%9;
			v=(ansk[i])%9;//把行信息转换成对应的点的值 
			if(v==0)v=9;//防止9的倍数%9==0 
			a[x][y]=v;
			}
			return 1;//只要找一组解 
		}
		int c=r[0];
		for(int i=r[0];i!=0;i=r[i])if(s[i]<s[c])c=i;//找到点最少的列
		remove(c);
		for(int i=d[c];i!=c;i=d[i]){
			ansk[deep]=row[i];
			for(int j=r[i];j!=i;j=r[j]) remove(col[j]);
			if(dance(deep+1)==1)return 1;//只要找一组解 
			for(int j=l[i];j!=i;j=l[j]) resume(col[j]);
		}
		resume(c); 
		return false;
	}
}dlx;
int main(){
	dlx.init(729,324);
	//729:
	//9^4种情况对应9^4行;
	//324:
	//对应数独的规则:每个格子，每行，每列，每个九宫只能填1~9各一次 
	//对于第m列：
	//若m在[1,81]表示在(m/9，m%9)填数 
	//若m在[81*1,81*2]在第1+（m-81）/9行填1+（m-81）%9 
	//若m在[81*2,81*3]在第1+（m-81*2）/9列填1+（m-81*2）%9 
	//若m在[81*3,81*4]在第1+（m-81*3）/9宫填1+（m-81*3）%9
	int x;
	int o;
	for(int i=0;i<=8;i++){
	 	for(int j=0;j<=8;j++){
	 	a[i][j]=x=Read();
		 for(int k=1;k<=9;k++){
		 	if(x!=k&&x!=0)continue;//已经填好的点就不用考虑了 
		 	o=i*9*9+j*9+k;
		 	dlx.link(o,i*9+j+1);
		 	dlx.link(o,i*9+81+k);
		 	dlx.link(o,j*9+81*2+k);
		 	dlx.link(o,81*3+(i/3*3+j/3)*9+k);//把点对应成行（集合） 
		 }
		 }
	 }
	 dlx.dance(0);
	for(int i=0;i<=8;i++){
		for(int j=0;j<=8;j++)printf("%d ",a[i][j]);
		printf("\n");
	}
	return 0;
}
```
看不懂可以发讨论

# ~~求赞~~ 
另外，如果想练dancing links 可以试一下[靶形数独](https://www.luogu.org/problemnew/show/P1074)和[八皇后](https://www.luogu.org/problemnew/show/P1219)

---

## 作者：悠逸 (赞：48)

~~这里是一个被吐槽把C++写出pascal风格的蒟蒻~~~~

嗯，这是一道很好的搜索题~~模拟题~~

 _（竟然没有**模拟题解**，鄙人来补白下）_ 
 
 思路：模拟一个憨厚人~~（鄙人）~~做数独过程
 （效率挺高的，4ms，比同袍的快多了）
 
 详情见代码~
 
 ```cpp
#include<cstring>
#include<string>
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
#include <cstdlib>
//BY cxj
using namespace std;
int xy;//用来判断 是否已找到结果 
int a[10][10],v[10][10],bx[10][10],by[10][10],bg[10][10];
//a:地图，
//bx：某行某数是否被调用过，
//by：某列某数是否被调用过，
//v:该点是否可改 ,      
//bg:某宫某数是否被调用过

int q(int x,int y,int s,int ss) 
 //改x,y宫s数是否被调用过，1：用过；0：没有 
{
	if (x<=3&&y<=3)
        bg[1][s]=ss;
        
    if (x<=3&&y>3&&y<=6)
        bg[2][s]=ss;
    
	if (x<=3&&y>6)
        bg[3][s]=ss;
        
    if (x>3&&x<=6&&y<=3)
        bg[4][s]=ss;
    
	if (x>3&&x<=6&&y>3&&y<=6)
        bg[5][s]=ss;
        
    if (x>3&&x<=6&&y>6)
        bg[6][s]=ss;
    
	if (x>6&&y<=3)
        bg[7][s]=ss;
        
    if (x>6&&y>3&&y<=6)
        bg[8][s]=ss;
    
	if (x>6&&y>6)
        bg[9][s]=ss;
	
	return 0;
}

int p(int x,int y,int s) 
//查x,y宫s数是否被调用过
{
	if (x<=3&&y<=3)
        return bg[1][s];
        
    if (x<=3&&y>3&&y<=6)
        return bg[2][s];
    
	if (x<=3&&y>6)
        return bg[3][s];
        
    if (x>3&&x<=6&&y<=3)
        return bg[4][s];
    
	if (x>3&&x<=6&&y>3&&y<=6)
        return  bg[5][s];
        
    if (x>3&&x<=6&&y>6)
        return bg[6][s];
    
	if (x>6&&y<=3)
        return bg[7][s];
        
    if (x>6&&y>3&&y<=6)
        return  bg[8][s];
    
	if (x>6&&y>6)
        return bg[9][s];
    
	return 0;
}

int dfs(int x,int y)//逐个排查 
{
    if (x==10||xy==1)//找到答案，结束过程 
       {
       	xy=1;
       	return 0;
       }
    //cout<<"A"<<endl;
    if (a[x][y]==0) 
        {
		for (int i=1;i<=9;i++)
            if (bx[x][i]==0 && by[y][i]==0 && (!p(x,y,i)))
            	{
            	   	a[x][y]=i;
            	   	bx[x][i]=1;
            	   	by[y][i]=1;
            	   	q(x,y,i,1);
            	   	
            	   	if (y==9)
            	   	   	dfs(x+1,1);
            	   	else
            	   	   	dfs(x,y+1);
            	   	
            	   	if (xy==1)
       				   return 0;
            	   	   	  
            	   	bx[x][i]=0;//回溯 
            	   	a[x][y]=0;
            	   	by[y][i]=0;
            	   	q(x,y,i,0);
            	}
            } 
    else
    {
        if (y==9)//换行 
            dfs(x+1,1);
        else
            dfs(x,y+1);
        
        if (xy==1)
       		return 0;
    }
    
    return 0;
}

int main()
{
    for (int i=1;i<=9;i++)
        for (int j=1;j<=9;j++)
            {
            	cin>>a[i][j];
            	
            	if (a[i][j]!=0)//处理固定点 
            	   {
            	   	v[i][j]=2;
            	   	bx[i][a[i][j]]=1;
            	   	by[j][a[i][j]]=1;
            	   	q(i,j,a[i][j],1);
            	   }
            }
    
    xy=0; 
    dfs(1,1);
    
    //cout<<endl;
    for (int i=1;i<=9;i++)//输出 
        {
        	for (int j=1;j<=9;j++)
        	    cout<<a[i][j]<<" ";
        	cout<<endl;
        }
    
    return 0;
}

```

~~（这风格多整齐，多美观，多易看~）~~

---

## 作者：tommymio (赞：31)

### [**先献上我的提交记录**](https://www.luogu.org/record/show?rid=14818081)

我现在还觉得，数独的依靠算法建立的正解是位运算+dfs剪枝，所以我这次又下意识的敲了这种写法，没开o2跑了14ms(~~这道题直接被我写成了蓝题~~)

这道题的数据是很水的，只有3个点，所以一般的搜索应该也能过。但是我看了一遍题解以及最优提交记录，发现不是打表就是DLX，还有一些玄学优化，而且码长也都比较长，~~这使本蒟蒻找到了一些优越感~~。

9*9的数独，常规做法时间复杂度很高，如果是POJ3074的数据还很容易TLE。所以我们采用位运算来存储当前位置是否能填下这个数字，便于处理。

1.对于每行，每列，每个九宫格，我们使用一个9位二进制数(全局int变量)存下哪些数还可以填(后文用1表示可以填，代码中会提到原因)

2.对于每个位置，将该位置所在行，列，九宫格的二进制数做&(位与)运算，可以得到该位置可填哪些数。(因为根据数独规则，在该行不能填，定然不能填，符合&运算的短路性质)

e.g:![](http://a3.qpic.cn/psb?/V12x6gxp2Qovw7/HXNgb5V5eH8tpCO97JAYkm6NqoQey9.D56BB8Pa0PTQ!/c/dL4AAAAAAAAA&ek=1&kp=1&pt=0&bo=wQAQAQAAAAARF*A!&tl=1&vuin=2407675849&tm=1545220800&sce=60-2-2&rf=0-0)

上图中被框住的位置，它所在行$row$所能填的数字(1,2,4,5,7,8,9)，9位二进制数表示[111011011]，所在列$col$所能填的数字(1,2,3,5,6,7,8),9位二进制数表示[011110111],其所在九宫格$grid$所能填的数字(1,2,3,4,5,7,8),9位二进制数表示[011011111]。
综合得出该位置可填(1,2,5,7,8),也可通过计算得出$row$&$col$&$grid$=[011010011],得出相同结果。

3.一个位置填上某个数后，把该位置所在的行,列,九宫格记录的对应二进制位改为0，表示不可填入该数字，回溯时改回1，(同bool数组)。

4.盲目搜索耗费时间，如果是人来填数独肯定选能填数字最少的位置，所以我们可以优先搜索这些位置。但切忌搜索时枚举所有的位置和可填的数字，这样会重复遍历同一状态的搜索树，降低搜索效率。

建议看完这些思想后先自己动手敲一遍，如果是做完了看题解的也权当了解一下，印象会更深刻，毕竟与DLX这样的数据结构相比,以及直接抄题解相比，算法思想的锻炼才是最重要的。

代码飞来~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int row[9],col[9],grid[9];//000000000~111111111	可行性数组 1表示可以填 
//2^9=32*16=512		2^8+5=256+5=261
int cnt[512],num[261];//二进制数中含有1的个数(各个状态中可选择的数的个数)	lowbit对应的hash
int rec[9][9];
inline int g(int x,int y){//很灵性的公式 
	return ((x/3)*3)+(y/3);
}
void flip(int x,int y,int z){//对该位置填z后的回溯和标记(xor) 
	//未标记->标记->未标记(xor的可逆性) 
	row[x]^=1<<z;//1<<z=pow(2,z)
	col[y]^=1<<z;
	grid[g(x,y)]^=1<<z;
}
bool dfs(int now){//当前有now个数可填的状态 
	if(!now)	return true;//填完了
	int temp=10,x,y;
	for(int i=0;i<9;++i){
		for(int j=0;j<9;++j){
			if(rec[i][j])	continue;
			int val=row[i]&col[j]&grid[g(i,j)];//该位置上可以填的数的个数
			if(!val)	return false;//1个也不能填，回溯
			if(temp>cnt[val]){//temp取当前位置可以填的最少的数的个数，并记录下这个位置
				temp=cnt[val];
				x=i;y=j;
			}
		}
	}
	//(x,y)可以填的数的个数
	int val=row[x]&col[y]&grid[g(x,y)];
	for(;val;val-=val&(-val)){
		int z=num[val&(-val)];
//		rec[x][y]=z;//Error
		rec[x][y]=z+1; //之所以加1与二进制标记数组的定义有关 
		flip(x,y,z);
//		flip(x,y,z-1);//Error 
		if(dfs(now-1))	return true;
		rec[x][y]=0;
		flip(x,y,z);
//		flip(x,y,z-1);//Error 
	}
	return false;//无解，返回上一层 
}
int main(){
	for(int i=0;i<(1<<9);++i){
		//i的二进制数中含有1的个数 即各个状态中可选择的数的个数
		//预处理降低时间复杂度
		//e.g:cnt[100010001(二进制数)] = 3
		for(int j=i;j;j-=j&(-j)){
			++cnt[i];
		}
	}
	for(int i=0;i<9;++i){
		//lowbit(1 << i)的hash,能找出lowbit(1 << i)所对应的第一个1的位置 
		num[1<<i]=i;
	}
	for(int i=0;i<9;++i){
		//初始化行，列，九宫格标记数组
		//每个数都可以填 
		row[i]=col[i]=grid[i]=(1<<9)-1;
	}
	for(int i=0;i<9;++i){
		for(int j=0;j<9;++j){
			scanf("%d",&rec[i][j]);
		}
	}
	//初始化计数器 
	int tot=0;
	for(int i=0;i<9;++i){
		for(int j=0;j<9;++j){
			if(rec[i][j]) flip(i,j,rec[i][j]-1);//进行标记	之所以 -1与flip函数的定义有关 
			else	++tot;//如果rec[i][j]是0，表示该位置还没有填数 
		}
	}
	dfs(tot);
//	printf("\n");
	for(int i=0;i<9;++i){
		for(int j=0;j<9;++j){
			printf("%d ",rec[i][j]);
		}
		printf("\n");
	}
	return 0;
} 
```








---

## 作者：芷陌陌吖 (赞：22)

~~请不要直接复制粘贴程序~~
# 本人习惯使用大括号{}，请谅解(*￣︶￣)
首先，此为一个搜索题，本人第一次没有使用递归，而是用for循环去判断每一位：
```cpp
  for (int i=1;i<=9;i++)
  {
    for (int j=1;j<=9;j++)
    {
      //判断
    }
  }
```
这种方法是不对的，因为你在每一个试数时，当无法填入数的时候，就必须倒回去重填前面的数，但如果使用循环，修改循环变量的值很容易出错，所以需要使用函数递归。代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<algorithm>
#include<sstream>        //头文件 
using namespace std;
int a[10][10],t,w,v; 
void sc()  //输出函数 
{ 
	for (int i=1;i<=9;i++)
	{
		for (int j=1;j<=9;j++)
		{
			cout<<a[i][j]<<" ";
		}
		cout<<endl;
	}
}
void ts(int i,int j)  //填数函数 
{
	if(i==10&&j==1)  //如果每个格子都填过了，就去输出 
	{
		sc();  //输出 
		exit(0);
	}
	if (a[i][j]==0)  //如果这个格子没有被填过 
	{
		for (int h=1;h<=9;h++)  //从1到9查看哪一个数可以填入 
		{
			t=0;
			for (int m=1;m<=9;m++)  //行判断 
			{
				if (a[i][m]==h)  //如果h出现过，说明该值不合法 
				{
					t=1;
					break;
				}
			}
			if (t==0)
			{
				for (int m=1;m<=9;m++)  //列判断 
				{
					if (a[m][j]==h)  //同38行 
					{
						t=1;
						break;
					}
				}
				if (t==0)
				{
					w=i;               //寻找3*3矩阵范围 
					v=j;
					while (w%3!=1)
					{
						w--;
					}
					while (v%3!=1)
					{
						v--;
					}
					for (int y=w;y<=w+2;y++)  //3*3矩阵判断 
					{
						for (int z=v;z<=v+2;z++)
						{
							if (a[y][z]==h)  //同38行 
							{
								t=1;
								break;
							}
						}
					}
					if (t==0)             //如果h的值合法 
					{
						a[i][j]=h;        //将a[i][j]赋值为h 
						if (j+1>9)		  //填写下一个格子 
						{
							ts(i+1,1);
							a[i][j]=0;    //（必要）将a[i][j]归0 
						} 
						else	
						{
							ts(i,j+1);
							a[i][j]=0;    //同83行 
						}							
					}
				}
			} 
		}		
	}
	else
	{
		if (j+1>9)		    //同79行 
		{
			ts(i+1,1);      //（重点）不需要把a[i][j]归0 
		} 
		else	
		{
			ts(i,j+1);     //同99行 
		}
	} 
}
int main()
{
	for (int i=1;i<=9;i++)          //输入 
	{
		for (int j=1;j<=9;j++)
		{
			cin>>a[i][j];
		}
	}
	ts(1,1);       //填写九宫格 
	return 0;
}
```
****程序重点：****
1、a[i][j]的值是否归0；
2、本程序的递归不能在i==9&&j==9退出，否则a[9][9]无法填写。

本题的讲解就到这里，喜欢就去点赞哟！有问题请在讨论区提问。谢谢大家！(〃'▽'〃)

---

## 作者：笃行 (赞：19)

本题的搜索方式大致都差不多。

在这里考虑减少dfs的层数，用while跳过已知数位。

另外楼下有用对二进制补位的方式进行搜索的dalao，但是实现起来比较麻烦。根据二进制的思想，用二进制的第i位是0或1来表示数字是否已出现。

可以用 | 运算符进行标记，用 ^ 运算符去标记，用 & 运算符进行判重，这样只需要一维的数组。

注意。本题第一个点如果9->1枚举会比较慢，所以还是从1->9枚举，这样就可以0msA掉这道题。

```cpp
#include<cstdio>
#define z(i) (1<<i)
#define g(x,y) (3*((x-1)/3)+(y-1)/3+1)
int h[10],l[10],s[10],f[10][10],ok,sum=81;
int read()
{
    int _=0,___=1;char __=getchar();
    while(__<'0'||__>'9'){if(__=='-')___=-1;__=getchar();}
    while(__>='0'&&__<='9'){_=_*10+__-'0';__=getchar();}
    return _*___;
}
void out()
{
    for(int i=1;i<=9;i++)
      {
          for(int j=1;j<=9;j++)
            printf("%d ",f[i][j]);
          printf("\n");
      }
}
void dfs(int x,int y,int tot)
{
    while(f[x][y])
      {
          y++;
          if(y>9) x++,y=1;
      }
    for(int i=1;i<=9;i++)
      {
          if(h[x]&z(i)||l[y]&z(i)||s[g(x,y)]&z(i)) continue;
          f[x][y]=i; h[x]|=z(i); l[y]|=z(i); s[g(x,y)]|=z(i);
          if(tot==sum) ok=1;
          else dfs(x,y,tot+1);
          if(ok) return ;
          f[x][y]=0; h[x]^=z(i); l[y]^=z(i); s[g(x,y)]^=z(i);
      }
}
int main()
{
    for(int i=1;i<=9;i++)
      for(int x,j=1;j<=9;j++)
        {
          f[i][j]=x=read();
          if(!x)continue;
          h[i]|=z(x); l[j]|=z(x); s[g(i,j)]|=z(x);
          sum--;
        }    
    dfs(1,1,1);
    out();
    return 0;
}
```

---

## 作者：3493441984zz (赞：17)

# $Dancing$   $links$真是个好东西$qwq$

### 刚学完就来水题解。。。希望能给大家一些帮助


------------
# 回归正题：

其实舞蹈链就是模板，但是难在哪呢？就是怎么把问题转化为舞蹈链能解决的问题：精确覆盖，重复覆盖等

所以这篇题解详细讲一下舞蹈链对于数独问题的建模

#### 那么我们先思考，数独的要求有哪些？

$1$、每一格只能填一个数

$2$、每一行每种数只能填一个

$3$、每一列每种数只能填一个

$4$、每一宫每种数只能填一个

那么这就可以像舞蹈链解决精确覆盖问题一样解决了，那么重点来了，**怎么构造矩阵**


------------

### $1$、矩阵中的列：

#### 我们首先要解决第一个约束条件，那么$9*9$数独中一共有$81$格，我们转换为$81$列

第$1$列表示$(1,1)$填了一个数

第$2$列表示$(1,2)$填了一个数

第$3$列表示$(1,3)$填了一个数

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$10$列表示$(2,1)$填了一个数

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$81$列表示$(9,9)$填了一个数

这样的话，我们就用了$81$列完成了第一个约束条件

#### 我们接下来要解决第二个约束条件，那么$9*9$数独中一共有$9$行，每行可以填$9$个数字，我们又转换为$81$列


第$1$列表示第$1$行填了数字$1$

第$2$列表示第$1$行填了数字$2$

第$3$列表示第$1$行填了数字$3$

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$10$列表示第$2$行填了数字$1$

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$81$列表示第$9$行填了数字$9$

这样的话，我们就又用了$81$列完成了第二个约束条件

#### 我们接下来要解决第三个约束条件，与第二个条件类似的，$9*9$数独中一共有$9$列，每列可以填$9$个数字，我们又转换为$81$列


第$1$列表示第$1$列填了数字$1$

第$2$列表示第$1$列填了数字$2$

第$3$列表示第$1$列填了数字$3$

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$10$列表示第$2$列填了数字$1$

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$81$列表示第$9$列填了数字$9$

这样的话，我们就又用了$81$列完成了第三个约束条件

#### 我们接下来要解决最后一个约束条件，$9*9$数独中一共有$9$个宫，每宫可以填$9$个数字，我们又转换为$81$列


第$1$列表示第$1$宫填了数字$1$

第$2$列表示第$1$宫填了数字$2$

第$3$列表示第$1$宫填了数字$3$

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$10$列表示第$2$宫填了数字$1$

$\qquad\qquad\quad\vdots$

$\qquad\qquad\quad\vdots$

第$81$列表示第$9$宫填了数字$9$

这样的话，我们就又用了$81$列完成了最后一个约束条件

### 最后，我们就用了$324$列来保证了每个约束条件


------------
### $2$、矩阵中的行

我们分两类，一种是一开始填了数字的，和没填的

#### 对于填了数字的格子

我们举个例子：$(2,1)$中填了一个数$7$

那么我们就要把这个转换为上面的限制条件,即：

$1$、$(2,1)$中填了一个数字

$2$、第$2$行填了一个数字$7$

$3$、第$1$列填了一个数字$7$

$4$、第一宫填了一个数组$7$

我们分别与相应的列相连就可以了

#### 对于没填数字的格子

我们举个例子：$(4,5)$中数字为$0$

那么我们就要枚举这个格子的所有情况：

这个格子填 $1$，像上面一样与矩阵中对应列相连

这个格子填 $2$，像上面一样与矩阵中对应列相连

这个格子填 $3$，像上面一样与矩阵中对应列相连

$\qquad\qquad\qquad\quad\quad\vdots$

$\qquad\qquad\qquad\quad\quad\vdots$

那么最后，表示$(4,5)$这个格子填了一个数的列的所有元素都是$1$，这就保证了，我填了一个数$1$后，这个点就不会再填其他数了（删除列操作，不多$bb$）

### 那么$9*9$数独一共有$81$个格子，最坏的的情况下，每个格子都是$0$，那么每个格子都要有$9$种情况，所以就会有$729$行



------------
# 总结：

我们最后把一个$9*9$的数独转换为了一个$729*324$的矩阵，最后就开始舞蹈链模板啦~~~（岂不是美滋滋~~~）

####  接下来是美滋滋的代码时间~~~
~~~cpp
#include<iostream>
#include<cstdio>
#include<vector>
#define N 11
#define M 236200                       
using namespace std;
int head,cnt;
int g[N][N],u[M],d[M],l[M],r[M],row[M],col[M],num[M],ans[M];
vector<int> v[M];
void Init()
{
	for(int i=0;i<=324;++i)
	{
		u[i]=i;
		d[i]=i;
		l[i]=i-1;
		r[i]=i+1;
	}
	l[head]=324;
	r[324]=head;
	cnt=325;
}
void Addrow(int x)
{
    int first=cnt;
    for(int i=0;i<v[x].size();++i)
    {
        int j=v[x][i];
        u[cnt]=u[j];
        d[u[j]]=cnt;
        u[j]=cnt;
        d[cnt]=j;
        l[cnt]=cnt-1;
        r[cnt]=cnt+1;
        col[cnt]=j;
        row[cnt]=x;
        ++num[j];
        ++cnt;
    }
    l[first]=cnt-1;
    r[cnt-1]=first;
}
void Remove(int x)
{
    r[l[x]]=r[x];
    l[r[x]]=l[x];
    for(int i=d[x];i!=x;i=d[i])
        for(int j=r[i];j!=i;j=r[j])
        {
            u[d[j]]=u[j];
            d[u[j]]=d[j];
            --num[col[j]];
        }
}
void Restore(int x)
{
    for(int i=u[x];i!=x;i=u[i])
        for(int j=l[i];j!=i;j=l[j])
        {
            d[u[j]]=j;
            u[d[j]]=j;
            ++num[col[j]];
        }
    r[l[x]]=x;
    l[r[x]]=x;
}
bool Dance(int dep)
{
    if(r[head]==head)
    {//cout<<"sdadad\n";
    	int x,y,z;
    	//cout<<"dep:"<<dep<<endl;
    	for(int i=0;i<dep;++i)
    	{
    		//printf("%d ",ans[i]);
    		x=(ans[i]-1)/9/9;
    		y=(ans[i]-1)/9%9;
    		z=ans[i]%9;
    		if(!z)
    			z=9;//cout<<x<<" "<<y<<" "<<z<<endl;
    		g[x][y]=z;
		}
    	return 1;
	}  
	
    int now=r[head];
    for(int i=r[head];i!=head;i=r[i])
        if(num[i]<num[now])
            now=i;
           // cout<<now<<" ";
    Remove(now);
    for(int i=d[now];i!=now;i=d[i])
    {
    	//cout<<"as\n";
    	ans[dep]=row[i];
        for(int j=r[i];j!=i;j=r[j])
            Remove(col[j]);
        if(Dance(dep+1))
            return 1;
        for(int j=l[i];j!=i;j=l[j])
            Restore(col[j]);
    }
    Restore(now);
    return 0;
}
int main()
{
	Init();
	for(int i=0;i<9;++i)
		for(int j=0;j<9;++j)
		{
			scanf("%d",&g[i][j]);	
			for(int k=1;k<=9;++k)
			{
				if(g[i][j]!=k&&g[i][j])
					continue;
				int x=i*9*9+j*9+k;
				v[x].push_back(i*9+j+1);
				v[x].push_back(i*9+81+k);
				v[x].push_back(j*9+81*2+k);
				v[x].push_back(81*3+(i/3*3+j/3)*9+k);
				Addrow(x);
			}
		}
		
	Dance(0);
	for(int i=0;i<9;++i)
	{
		for(int j=0;j<9;++j)
			printf("%d ",g[i][j]);
		printf("\n");	
	}
	return 0;
			
}
~~~



---

## 作者：_J_C_ (赞：14)

### ~~**多么好的一道dancing links x模板题啊，就被你们深搜过掉了，真是暴殄天物**~~


首先，dancing links x并不是一个专门用来做数独的算法（虽然总是被用来做数独，而且好像是速度最快的数独算法），而是一个用来求精确覆盖问题的算法。

什么叫精确覆盖呢？

举个例子：

0 1 0 0 1

1 0 1 0 0

0 0 1 1 0

0 0 0 1 0

精确覆盖就是选出其中任意行，使得叠加后每列有且只有一个1

对于上例，选出第一、二、四行是（唯一）一个合法的选择；而若选出第一、二、四行，虽然每列都有1，但是第4列出现了两个1，故不合法

那么如何把数独转换成一个精确覆盖问题呢？

当数独完成时，每行、每列、特定九个九宫格内都有所有的1-9九个数字，而且每个数字出现且仅出现一次。

我们写四个宏将四个状态（下面有解释）对应起来：

```cpp

#define EXIST(x, y) ((x) * 9 + (y) + 1)
#define COL(x, v) (81 + EXIST(x, v - 1))
#define ROW(y, v) (81 + COL(y, v))
#define BLOCK(i, v) (81 + ROW(i, v))

```

EXIST(x,y)表示第x行y列有数字，这个状态是为了防止数字重复填入同一个空

COL(x,v)表示第x行有数字v，这个状态是为了保证第x行有数字v（话说COL是列的意思来着，不过问题不大）

ROW(y,v)类似与COL

BLOCK(i,v)编号为i的九宫格块内有数字v


九宫格的编号：

1 1 1 2 2 2 3 3 3

1 1 1 2 2 2 3 3 3

1 1 1 2 2 2 3 3 3

4 4 4 5 5 5 6 6 6

4 4 4 5 5 5 6 6 6

4 4 4 5 5 5 6 6 6

7 7 7 8 8 8 9 9 9

7 7 7 8 8 8 9 9 9

7 7 7 8 8 8 9 9 9

换成计算式就是:(X,Y) -> (X / 3 * 3 + Y / 3)

上面的式子是成立的，因为除号是向下取整的……

建模就建好了。

至于DLX嘛……百度吧，记得找一篇图比较多的博客去参悟（有图好说话）。

(DLX实现各有不同吧……下面的代码还是稍加注释了)

```cpp

#include <cstdio>
#include <cstdlib>

#define EXIST(x, y) ((x) * 9 + (y) + 1)
#define COL(x, v) (81 + EXIST(x, v - 1))
#define ROW(y, v) (81 + COL(y, v))
#define BLOCK(i, v) (81 + ROW(i, v))

const int MaxPoint(312345);//DLX中节点的最大数

int map[9][9], line[4];
int iEndPolicy, px[MaxPoint], py[MaxPoint], pv[MaxPoint];//这个用于将DLX中的行转换成实际的状态（即第几行第几列填什么）

namespace my
{
	int choose[MaxPoint];//用来存放答案，即选了哪几行
	class DLX
	{
	public:
		int col[MaxPoint], row[MaxPoint], cnt_col[325];//col为节点所处的列数，row为节点所处的行数，cnt_col[x]为第x行的节点数（未删除的）
		int L[MaxPoint], R[MaxPoint], U[MaxPoint], D[MaxPoint];//含义分别是 左 右 上 下， 用于实现DLX的
		
		void init(int _col)//初始化：需要初始化链表的列指针
		{
			for (int i(0); i <= _col; ++i)
			{
				L[i] = i - 1;
				R[i] = i + 1;
				U[i] = i;
				D[i] = i;
				
				row[i] = 0;
				col[i] = i;
				cnt_col[i] = 0;
			}
			L[0] = _col;
			R[_col] = 0;
			NextRow = 0;//即下一行
			end = _col + 1;//end是下一个未分配的节点
		}
		
		void addrow(int ele[], int sz)//ele中的元素必须是升序排列的，这样子处理非常方便
		{
			int first(end), front(end);
			for (int i(0); i != sz; ++i)
			{
				U[end] = U[ele[i]];//建立新一行的链表，并与上一行相关连
				D[end] = ele[i];
				D[U[ele[i]]] = end;//ele[i]即列的编号，也是列顶部元素的编号（注意初始化时的操作）
				U[ele[i]] = end;
				R[front] = end;
				L[end] = front;
				col[end] = ele[i];
				++cnt_col[ele[i]];
				row[end] = NextRow;
				front = end++;
			}
			L[first] = front;//首尾循环处理
			R[front] = first;
			++NextRow;
		}

#define FOR(i, A, s) for (int i(A[s]); i != s; i = A[i])		
//这个宏的含义是沿着编号s的节点开始按着指定方向A进行遍历（注意，s不会被遍历到）
		void remove(int c)
		{
			L[R[c]] = L[c];//删除操作，代码短但其实挺复杂的……百度吧←←
			R[L[c]] = R[c];
			FOR (i, D, c)
			{
				FOR (j, R, i)
				{
					U[D[j]] = U[j];
					D[U[j]] = D[j];
					--cnt_col[col[j]];
				}
			}
		}
		
		void restore(int c)
		{
			FOR (i, U, c)//类似删除操作，只是操作次序相反
			{
				FOR (j, L, i)
				{
					U[D[j]] = j;
					D[U[j]] = j;
					++cnt_col[col[j]];
				}
			}
			L[R[c]] = c;
			R[L[c]] = c;
		}
		
		bool dfs(int dep)
		{
			if (R[0] == 0)//覆盖完毕了
			{
				for (int i(0); i != dep; ++i)
				{
					int p(choose[i]);
					map[px[p]][py[p]] = pv[p];
				}
				return true;
			}
			int min(2123456789), c;
			FOR (i, R, 0)
			{
				if (cnt_col[i] < min)
				{
					min = cnt_col[i];
					c = i;
				}
				if (cnt_col[i] == 0)//第i列无法被覆盖（先前决策失误）
				{
					return false;
				}
			}
			
			remove(c);//删除第c列
			FOR (i, D, c)
			{
				FOR (j, R, i) remove(col[j]);//删除第j行所有元素
				
				choose[dep] = row[i];
				if (dfs(dep + 1)) return true;
				
				FOR (j, L, i) restore(col[j]);//恢复操作
			}
			restore(c);
			return false;
		}
		
		void print()//调试用的……
		{
			printf("\n");
			FOR (i, R, 0)
			{
				FOR (j, D, i)
				{
					printf("%d ", row[j]);
				}
				printf("\n");
			}
			printf("\n");
		}
		
		int end;
		int NextRow;
	}dlx;
}


;


int main()
{
	my::dlx.init(324);
	for (int i(0); i != 9; ++i)
	{
		for (int j(0); j != 9; ++j)
		{
			scanf("%d", &map[i][j]);
		}
	}
	for (int i(0); i != 9; ++i)
	{
		for (int j(0); j != 9; ++j)
		{
			for (int k(1); k <= 9; ++k)
			{
				if (map[i][j] == 0 || map[i][j] == k)
				{
					line[0] = EXIST(i, j);//建立DLX模型
					line[1] = COL(i, k);
					line[2] = ROW(j, k);
					line[3] = BLOCK((i / 3 * 3 + j / 3), k);
					my::dlx.addrow(line, 4);
					px[iEndPolicy] = i;
					py[iEndPolicy] = j;
					pv[iEndPolicy] = k;
					++iEndPolicy;
				}
			}
		}
	}
	my::dlx.dfs(0);
	for (int i(0); i != 9; ++i)
	{
		printf("%d", map[i][0]);
		for (int j(1); j != 9; ++j) printf(" %d", map[i][j]);
		printf("\n");
	}
	system("pause");
	return 0;
}

```

---

## 作者：VenusM1nT (赞：13)

最近在学$DLX$，既然是数独就来用用吧……

参考了蓝书和一个dalao的题解，总算是会打代码了……55555

考虑怎么套上$DLX$的框架，即在矩阵中选取若干行，使每列有且仅有一个“$1$”，所以我们把行看作决策，把每个决策用一个三元组$(r,c,v)$表示，代表要将$(r,c)$这个位置填上$v$这个数，那么总决策数就是$r\times c\times v$，在这题中是$9\times 9\times 9 = 729$

然后考虑列，列代表的是任务，一共有$4$种任务，分别是：

> $Slot(r,c)$代表$(r,c)$要有数字

> $Row(r,x)$代表第$r$行要有数字$x$

> $Col(c,x)$代表第$c$列要有数字$x$

> $Sub(t,x)$代表第$t$宫要有数字$x$

因此一共有$r\times c\times 4 = 9\times 9\times 4=324$种任务

最后我们考虑矩阵中有几个“$1$”，因为一行对应$4$个任务，所以$1$的个数应该是$729\times 4=2916$

由此，我们得到了一个$729\times 324$，有$2916$个$1$的矩阵，对它跑一遍$DLX$，然后把求出的答案填到数独上即可

见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt,fst[500005],siz[500005];
int n,m,a[15][15],u[500005],d[500005],l[500005],r[500005],row[500005],col[500005],ans[500005];
void Init()
{
    for(int i=0;i<=m;i++)
    {
        l[i]=i-1;
        r[i]=i+1;
        u[i]=i;
        d[i]=i;
    }
    r[m]=0;
    l[0]=m;
    memset(fst,-1,sizeof(fst));
    memset(siz,0,sizeof(siz));
    cnt=m;
}
void Link(int R,int C)
{
    siz[C]++;
    row[++cnt]=R;
    col[cnt]=C;
    u[cnt]=C;
    d[cnt]=d[C];
    u[d[C]]=cnt;
    d[C]=cnt;
    if(!~fst[R]) fst[R]=r[cnt]=l[cnt]=cnt;
    else
    {
        r[cnt]=fst[R];
        l[cnt]=l[fst[R]];
        r[l[fst[R]]]=cnt;
        l[fst[R]]=cnt;
    }
}
void Remove(int C)
{
    r[l[C]]=r[C];
    l[r[C]]=l[C];
    for(int i=d[C];i!=C;i=d[i])
    {
        for(int j=r[i];j!=i;j=r[j])
        {
            u[d[j]]=u[j];
            d[u[j]]=d[j];
            siz[col[j]]--;
        }
    }
}
void Resume(int C)
{
    for(int i=u[C];i!=C;i=u[i])
    {
        for(int j=l[i];j!=i;j=l[j])
        {
            u[d[j]]=j;
            d[u[j]]=j;
            siz[col[j]]++;
        }
    }
    r[l[C]]=C;
    l[r[C]]=C;
}
bool Dance(int dep)
{
    if(!r[0])
    {
        for(int i=1;i<dep;i++)
        {
            int x=(ans[i]-1)/9/9+1,y=(ans[i]-1)/9%9+1,z=(ans[i]-1)%9+1;
            a[x][y]=z;//将求出的答案填入数独
        }
        return 1;
    }
    int C=r[0];
    for(int i=r[0];i;i=r[i]) if(siz[i]<siz[C]) C=i;
    Remove(C);
    for(int i=d[C];i!=C;i=d[i])
    {
        ans[dep]=row[i];
        for(int j=r[i];j!=i;j=r[j]) Remove(col[j]);
        if(Dance(dep+1)) return 1;
        for(int j=l[i];j!=i;j=l[j]) Resume(col[j]);
    }
    Resume(C);
    return 0;
}
int main()//以上为DLX
{
    n=729;
    m=324;//行列
    Init();
    for(int i=1;i<=9;i++)
    {
        for(int j=1;j<=9;j++)
        {
            scanf("%d",&a[i][j]);
            for(int k=1;k<=9;k++)
            {
                if(a[i][j]!=k && a[i][j]) continue;
                int id=((i-1)*9+(j-1))*9+k;
                int c1=(i-1)*9+(j-1)+1,c2=81+(i-1)*9+k,c3=81*3+(j-1)*9+k,c4=81*2+(((i-1)/3)*3+((j-1)/3))*9+k;
                Link(id,c1);
                Link(id,c2);
                Link(id,c3);
                Link(id,c4);//连接行列
            }
        }
    }
    Dance(1);
    for(int i=1;i<=9;i++)
    {
        for(int j=1;j<=9;j++) printf("%d ",a[i][j]);
        puts("");
    }
    return 0;
}
```

---

## 作者：我杀文化课 (赞：8)

# 本蒟蒻的第一个题解

其实拿到这个题，我是一开始是 ~~极不情愿~~ 非常开心的。

然后就是进入了一帆顺水的开心敲码时间。（大概十分钟）

结果，调试了一下午......

突然，机房来了几个帅气强大的学长，我在死亡深渊之中看到了一丝希望！

学长一看见这个题，张口就是"我只会做红题"，再加以好久没打过深搜一口回绝，虽然最后他还是看了我的代码。

然而第一个直呼：”如此好的代码怎么会有错！"就逃了。

后来请来了搜索大佬，结果搜索大佬也是没找到问题。最后两眼冒火着盯着我大叫："我不是来打代码的！！"又逃了。

最后还是老师找到了。

声明：我知道诸位帮我调代码的大佬都是很强的，我没有任何不尊敬之意。


# ------------
## 言归正传

其实这个题思路很简单，就是一波裸深搜。具体见图，

![](https://cdn.luogu.com.cn/upload/pic/64685.png)


每个区域都可以通过数学计算得到。这就为打表建立了基础。

//向上取整，区域从左到右，从上到下。我们可以称下面的表为特征码，例如，对于一个点（x，y）。当ceil（x/3）==1，ceil（y/3）==1时，那么这个点一定处于区域一中

区域1 x/3=1 y/3=1

区域2 x/3=2 y/3=1

区域3 x/3=3 y/3=1

区域4 x/3=1 y/3=2

区域5 x/3=2 y/3=2

区域6 x/3=3 y/3=2

区域7 x/3=1 y/3=3

区域8 x/3=2 y/3=3

区域9 x/3=3 y/3=3

~~个人认为还是很好懂的。~~

#### 方法一比较省时间，不过有点冗长，因为我太弱了！

# 方法一

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;
int a[11][11],t[4][4];
int h[10][10],l[10][10],f[10][10];//分别代表行，列，块 
void dfs(int x,int y)
{
	if(x==10)
	{
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=9;j++)
				printf("%d ",a[i][j]);
			printf("\n");
		}
		exit(0);
	} //满足条件时输出 
	int nx=x,ny=y+1;//计算下一个要搜索的点。
	if(ny==10) 
	{
		nx=x+1;
		ny=1;//行动列不动，ny越界时nx加一。
	} 
	if(a[x][y]==0)
		for(int i=1;i<=9;i++)
		{
		 if(!h[x][i] && !l[y][i] && !f[t[(int)ceil((double)x/3)][(int)ceil((double)y/3)]][i])
		 {
		  a[x][y]=i;
		  h[x][i]=1; l[y][i]=1; f[t[(int)ceil((double)x/3)][(int)ceil((double)y/3)]][i]=1;
			 dfs(nx,ny);
		 	 a[x][y]=0;
		 	 h[x][i]=0; 
             l[y][i]=0; 
             f[t[(int)ceil((double)x/3)][(int)ceil((double)y/3)]][i]=0;//返回时撤回标记和填上的数 
			}
		}//如果满足条件，则进行填数。注意：（double）必须加，因为y是int型，否则ceil不会起作用，如果不理解算式可以参见上面的图表。 
	else dfs(nx,ny);//如果这个数不为零，说明是题目给的，直接跳过。 
}
int main()
{
	t[1][1]=1; t[2][1]=2; t[3][1]=3;
	t[1][2]=4; t[2][2]=5; t[3][2]=6;
	t[1][3]=7; t[2][3]=8; t[3][3]=9;//打表，具体调用方法见dfs（）处 
	for(int x=1;x<=9;x++)
	for(int y=1;y<=9;y++)
	{
		scanf("%d",&a[x][y]);//读入 
		if(a[x][y]!=0)
		{
		h[x][a[x][y]]=1;
		l[y][a[x][y]]=1;
		f[t[(int)ceil((double)x/3)][(int)ceil((double)y/3)]][a[x][y]]=1;
		}//对于题目给出进行标记。 
	}	
	dfs(1,1);
}
```


------------

#### 其实方法二和方法一差不多，只不过条件判断时用的是整体性更高的函数，更加易懂。


# 方法二

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;
int a[11][11];
bool sl(int x,int z)
{
	for(int i=1;i<=9;i++)
		if(a[x][i]==z)//固定x，枚举y 
			return 0;
	return 1;
}//搜索竖列 
bool hl(int y,int z)
{
	for(int i=1;i<=9;i++)
		if(a[i][y]==z)//固定y，枚举x 
			return 0;
	return 1;
}//搜索横列 
bool k(int x,int y,int z)
{
	for(int i=x*3-2;i<=x*3;i++)
	for(int j=y*3-2;j<=y*3;j++)//此处算式可以自己尝试，刚好搜索一个九宫格，不懂可参见上方图表。 
		if(a[i][j]==z)//九宫格中枚举x，y 
			return 0;
	return 1;
}//搜索块 
void dfs(int x,int y)
{
	if(x==10)
	{
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=9;j++)
				printf("%d ",a[i][j]);
			printf("\n");
		}
		exit(0);
	}//满足条件时输出 
	int nx=x,ny=y+1;
	if(ny==10)//计算下一个要搜索的点。
	{
		nx=x+1;
		ny=1;
	}//行动列不动，ny越界时nx加一。
	if(a[x][y]==0)
		for(int i=1;i<=9;i++)
		{
			if(sl(x,i) && hl(y,i) && k((int)ceil((double)x/3),(int)ceil((double)y/3),i))
			{
			 a[x][y]=i;
			 dfs(nx,ny);
		 	 a[x][y]=0;//撤销标记 
			}
		}//如果满足条件，则进行填数。注意：（double）必须加，因为y是int型，所以ceil不会起作用，如果不理解算式可以参见上面的图表。
	else dfs(nx,ny);
}
int main()
{
	for(int x=1;x<=9;x++)
	for(int y=1;y<=9;y++)
		scanf("%d",&a[x][y]);//读入	
	dfs(1,1);//从（1,1）开始 
}
```

### 这就是本蒟蒻的题解，谢谢诸位支持！

### 有什么不懂或我的不足可以评论区提出，谢谢！！


---

## 作者：SovietPower✨ (赞：6)

经典的dfs问题

做法和别的题解不太一样，发一下我的代码

用了一个group 9\*9 数组来表示(x,y)所在的3\*3小区域(学自YL老师)

```cpp
#include<cstdio>
using namespace std;
const int N=10;
const int group[9][9]=
{
    0,0,0,1,1,1,2,2,2,
    0,0,0,1,1,1,2,2,2,
    0,0,0,1,1,1,2,2,2,
    3,3,3,4,4,4,5,5,5,
    3,3,3,4,4,4,5,5,5,
    3,3,3,4,4,4,5,5,5,
    6,6,6,7,7,7,8,8,8,
    6,6,6,7,7,7,8,8,8,
    6,6,6,7,7,7,8,8,8
};//代表9个3*3的区域 
bool row[N][N],col[N][N],gr[N][N];
//row[i][j]:判断第i行是否出现过数字j
//col[i][j]:判断第i列是否出现过数字j
//gr[i][j]:判断区域i是否出现过数字j 
int sudoku[N][N];//数独 
bool check(int x,int y,int w)
{
    if(row[x][w]||col[y][w]||gr[group[x][y]][w])//若该行 或 该列 或 该3*3区域出现过w 
      return 0;//不能填充w 
    return 1;//可填充 
}
void dfs(int x,int y)
{
    if(x==9)//如果此时棋盘满足约束，则输出 
    {
        for(int i=0;i<9;i++)
        {
            for(int j=0;j<9;j++)
              printf("%d ",sudoku[i][j]);
            printf("\n");
        }
        return;
    }
    int nxtx=x,nxty=y+1;//计算下一个状态 
    if(nxty==9)
      ++nxtx,nxty=0;
    if(sudoku[x][y]!=0)//原来就有数字，直接跳过 
      dfs(nxtx,nxty);
    else//原来没有数字，枚举所有可能：填充1-9 
    {
        for(int j=1;j<=9;j++)
            if(check(x,y,j))
            {
                row[x][j]=col[y][j]=gr[group[x][y]][j]=1;
              sudoku[x][y]=j;
                dfs(nxtx,nxty);//搜索下一状态 
                sudoku[x][y]=0;//回溯，复原棋盘 
                row[x][j]=col[y][j]=gr[group[x][y]][j]=0;
          }
    }
}
int main()
{
    for(int i=0;i<9;i++)
      for(int j=0;j<9;j++)
      {
            int a;
            scanf("%d",&a);
            if(a==0) continue;
            row[i][a]=1;//第i行已有a 
            col[j][a]=1;//第j列已有a 
            gr[group[i][j]][a]=1;//i行j列所在区域 已有a 
            sudoku[i][j]=a;//填充入sudoku 
      }
    dfs(0,0);
    return 0;
}
```

---

## 作者：Tingle (赞：4)

~~看完所有的题解之后发现没有人用二进制，我就知道我的机会来了（手动滑稽）~~


## 在做这一题之前你所需要知道的二进制操作

```cpp
x << y//相当于x * pow(2,y)
lowbit(x)//找到x的二进制中最小的1的位置
1 & 1 = 1
0 & 1 = 0
0 & 0 = 0
//没有了
```


------------
&emsp;&emsp;关于这一题，line,rool,cell三个数组(均初始化为111111111(二进制))分别用来存这一行、列、九宫格（以0开始，方便九宫格的操作）还可以存的数有哪些，存在相对应的二进制位上。

&emsp;&emsp;为了得到某一个格子的可以填的数，只需要一个get函数就可以解决。
```cpp
inline int get(int x,int y){
	return line[x]&roll[y]&cell[x/3][y/3];
}
```
# 最重要的，注意dfs的顺序(剪枝必备)
&emsp;&emsp;就像我们平时做数独一样，从可以填的数最少的格子开始枚举（这一题其实不需要，但是[靶形数独](https://www.luogu.org/problem/P1074)一定是要这样剪枝的（可能是强度的问题））

&emsp;&emsp;话不多说,上代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define _ 0
const int N=9;
int a[N][N];
int line[N],roll[N],cell[N/3][N/3];
int map[1<<N],once[1<<N];//map是为了得到lowbit的对应的位数,once方便找这一格可以填的数的个数
inline void init(){
	for(int i=0;i<N;i++)
		line[i]=roll[i]=(1<<N)-1;
	for(int i=0;i<3;i++)
		for(int j=0;j<3;j++)
			cell[i][j]=(1<<N)-1;
}
inline int lowbit(int x){//定义lowbit函数
	return x&(-x);
}
inline int get(int x,int y){//定义get函数,前面已经介绍过
	return line[x]&roll[y]&cell[x/3][y/3];
}
bool dfs(int cnt){
	if(!cnt) return true;
	int minn=10;
	int x,y;
	for(int i=0;i<N;i++)
		for(int j=0;j<N;j++){
			if(a[i][j]==0)
			if(minn>once[get(i,j)]) x=i,y=j,minn=once[get(i,j)];
		}//找到可填的数最少的一格
	int xx=get(x,y);
	for(int i=xx;i;i-=lowbit(i)){
		int l=map[lowbit(i)];
		a[x][y]=l+1;
		line[x] -= 1 << l;
		roll[y] -= 1 << l;
		cell[x/3][y/3] -= 1 << l;
		if(dfs(cnt-1)) return true;
		line[x] += 1 << l;
		roll[y] += 1 << l;
		cell[x/3][y/3] += 1 << l;
		a[x][y]=0;
	}
	return false;
}
int main(){
	for(int i=0;i<9;i++){//初始化map
		map[1<<i]=i;
	}
	for(int i=0;i<(1<<N);i++){//初始化once
		int s=0;
		for(int j=i;j;j-=lowbit(j)){
			s++;
		}
		once[i]=s;
	}
	init();//初始化line,roll,cell
	for(int i=0;i<N;i++)
		for(int j=0;j<N;j++){
			scanf("%d",&a[i][j]);
		}
	int cnt=0;
	for(int i=0;i<N;i++)
		for(int j=0;j<N;j++){
			if(!a[i][j]) cnt++;
			else{
				int t=a[i][j]-1;
				line[i]-=1<<t;
				roll[j]-=1<<t;
				cell[i/3][j/3]-=1<<t;
			}
		}
	dfs(cnt);
	for(int i=0;i<N;i++){
		for(int j=0;j<N;j++)
			printf("%d ",a[i][j]);
		putchar('\n');
	}
	return ~~(0^_^0);//卖个萌祝大家AK 2019CSP-S2（J2）
}
```

---

## 作者：mot1ve (赞：3)

适合萌新看，代码难度比较低，说明一下如何判断一个数字是否在一个大九宫格内重复出现，设九宫格序号从左往右为012，345，678.九宫格序号=行序号/3*3+列序号/3；因为我这里下标是从0开始的，从1开始就不一样了，这个可以画个图推一下。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int mp[10][10],vx[10][10],vy[10][10],vc[10][10];//mp存每个框里的数，vx存行上的数，vy存列上的数，vc判断一个大九宫格里有没有重复数字。
void dfs(int x,int y)//x，y为坐标
{
	if(x==9)//到达边界，我是从0开始读入的，所以最后一行的下标是8，x==9时说明填完了，又从下一行开始搜索了，这时候直接输出数独表就行了。
	{
		for(int i=0;i<9;i++)
		{
			for(int j=0;j<9;j++)
			{
				cout<<mp[i][j]<<" ";
			}
			cout<<endl;
		}
		return;
	}
	if(y==9)//我是一行一行搜索的，第一行搜索完的时候最后一列下标是8，y==9时说明这一行已经搜索完了，开始搜索下一行，即dfs(x+1，0)。
	{
		dfs(x+1,0);
	}
	if(mp[x][y])//如果这一个格子有数字了，所以不需要填，从下一列开始搜索
	{
		dfs(x,y+1);
	}
	else for(int i=1;i<=9;i++)//依次枚举1-9
	{
		if(!vx[x][i]&&!vy[y][i]&&!vc[x/3*3+y/3][i])//如果这一行没有i，这一列也没有i，并且i没有在这个九宫格里出现过，那么当前可以选择这个数（不过不能确定是这个数）
		{
			vx[x][i]=1;
			vy[y][i]=1;
			vc[x/3*3+y/3][i]=1;
			mp[x][y]=i;
			dfs(x,y+1);//从下一列开始搜索
			vx[x][i]=0;//回溯
			vy[y][i]=0;
			vc[x/3*3+y/3][i]=0;
			mp[x][y]=0;
			
		}
	}
}
int main()
{
	for(int i=0;i<9;i++)//读入数独表，同时标记
	{
		for(int j=0;j<9;j++)
		{
			cin>>mp[i][j];
			vx[i][mp[i][j]]=1;
			vy[j][mp[i][j]]=1;
			vc[i/3*3+j/3][mp[i][j]]=1;
		}
	}
	dfs(0,0);
	return 0;
} 

---

## 作者：la_un_ty (赞：3)

# 这一道题的主要思路是：搜索+模拟

模拟部分：

数独大家应该都玩过，不懂的话看这$\downarrow$

$$\large\textbf{数独的规则}$$
$$\begin{matrix} |\ \ \ \ \text{在一个9}\times\text{9的方格中，给你一些数字，你需要将它填满，}\ \ |\\|\text{使每行，每列，以及每一个3}\times\text{3的小方格中的9个数不重复。}|\end{matrix}$$
$$$$


规则看完后，我们开始模拟。

------------
## $\textbf{模拟部分}$

设$h[i][j]$表示第$i$行的$j$这个数有没有出现过。

$l[i][j]$表示第$i$列的$j$这个数有没有出现过。

$lb[i][j]$表示第$i$个小方格中$j$这个数有没有出现过。

于是我们就需要计算一下一个点在哪一个小方格中。大佬的经验告诉我们，用坐标算会死的很惨。所以我们可以开一个数组$m$.

$m[i][j]$表示$(i,j)$这个点所在小方格的编号。

```cpp
//应该可以看懂
int m[9][9]={1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             };
```


------------
## 搜索部分
使用$posi[i]$表示第$i$个空方格的横坐标，$posj[i]$表示第$i$个空方格的纵坐标坐标。

读入时存储一下，再用$dfs(0)$开始搜索即可，比较好理解

更多详见注释。

```cpp

#include<bits/stdc++.h>
using namespace std;
int a[9][9],h[10][10],l[10][10],lb[10][10],posi[100],posj[100],top=0;
int m[9][9]={1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             };
void prt(){
    for(int i=0;i<9;i++){
        for(int j=0;j<9;j++)
            printf("%d ",a[i][j]);
        printf("\n");
    }
}
void dfs(int dep){
    if(dep>top) prt(),exit(0);//数独已经填满
    int i=dep;
    for(int j=1;j<=9;j++){//轮流枚举1~9。高能警告
        if(h[posi[i]][j]/*j在当前行存在*/||l[posj[i]][j]/*j在当前列存在*/||lb[m[posi[i]][posj[i]]][j]/*j在当前小方格存在*/)continue;
        else{
            a[posi[i]][posj[i]]=j;//填上一个数
            h[posi[i]][j]=l[posj[i]][j]=lb[m[posi[i]][posj[i]]][j]=1;//更新标记
            dfs(dep+1);//继续往下搜
            a[posi[i]][posj[i]]=0;//搜完回来清零
            h[posi[i]][j]=l[posj[i]][j]=lb[m[posi[i]][posj[i]]][j]=0;//清零标记
        }
    }
    
}
int main(){
    for(int i=0;i<9;i++)for(int j=0;j<9;j++){
        scanf("%d",&a[i][j]);
        if(!a[i][j]) posi[++top]=i,posj[top]=j;//记录坐标
        else h[i][a[i][j]]=l[j][a[i][j]]=lb[m[i][j]][a[i][j]]=1;//该数已存在
    }
    dfs(1);
    return 0;
} 
```

---

## 作者：眠ㅤㅤㅤ (赞：3)

用数字 num = 0 ~ 80 代表当前位置，那么当前坐标就是（num / 9, num % 9）。

所属宫格左上角的坐标就是（num / 3 x 3，num / 3 x 3）, 类似于一个向下取整的过程。

```cpp
#include<bits/stdc++.h>
using namespace std;

int Map[9][9];
bool End;

/* 判断当前位置当前数字可不可用 */
bool Judg(int posx, int posy, int num) {
	/* 当前行与列的判断 */
    for (int tra = 0; tra < 9; tra++)
        if (Map[posx][tra] == num || Map[tra][posy] == num)
            return false;
            
    /* 所属的九宫的判断 */
    int tmpx = posx / 3 * 3, tmpy = posy / 3 * 3;
    for (int stepx = 0; stepx < 3; stepx++)
        for (int stepy = 0; stepy < 3; stepy++)
            if (Map[tmpx + stepx][tmpy + stepy] == num)
                return false;
    return true;
}

void Print() {
    for (int posx = 0; posx < 9; posx++) {
        for (int posy = 0; posy < 9; posy++)
            printf("%d ", Map[posx][posy]);
        puts("");
    }
}

void DFS(int now) {
    if (End)
        return;
    /* 获取当前所在位置 */
    int posx = now / 9, posy = now % 9;
    
    /* 如果已填过则跳过 */
    if (Map[posx][posy]) {
        DFS(now + 1); return;
    }
    
    /*     填完了     */
    if (now == 81) {
        Print(); End = true; return;
    }
    /* 在当前位置填数字 */
    for (int num = 1; num <= 9; num++)
        if (Judg(posx, posy, num)) {
            Map[posx][posy] = num;
            DFS(now + 1);
            Map[posx][posy] = 0;
        }
}

int main() {
    for (int posx = 0; posx < 9; posx++)
        for (int posy = 0; posy < 9; posy++)
            scanf("%d", &Map[posx][posy]);
    DFS(0);
}
```

---

## 作者：yzz2016 (赞：3)

                
    
                           
 
         
```cpp
#include<cstdio>
#include<cmath>
int h[10]={},hs[10]={},zs[10]={},xj[5][5]={},hq[10]={};
int ans=-1,st[10],a[10][10];
void make()   //更新ans
{
    int sum=0,i,j;
    for (i=1;i<5;i++)
      {for (j=i;j<11-i;j++)
        sum+=(a[i][j]+a[10-i][j])*(5+i);
       for (j=i+1;j<10-i;j++)
        sum+=(a[j][i]+a[j][10-i])*(5+i);
        }
    sum+=a[5][5]*10;   
    if (sum>ans) ans=sum;
}
void dfs(int k)  //搜索部分
{
     if (k==10) make(); // k=10表示九行都搞定了，开始算分
     else
     {
      int x,y,j,pos,p,i=st[k]; //i表示第i行，j表示第j列
      x=511-h[i];//511（10）=111，111，111（2），故此行的意思是将第i行缺位取出来  此时x中1表示缺位，y与x同
      y=x&-x; //y是取出本行第一个缺位，在这一次搜索里就搜索这个缺位(去掉右数第一位1左边的数    111110000---->10000)
      h[i]|=y;//下一次搜索时，这一位已填，故把缺位补上
      j=(int)log2(y)+1; //j就是y用二进制表示1所在的位数，即j列
      pos=511-(hs[i]|zs[j]|xj[(i-1)/3][(j-1)/3]); //这一步是取出可以填哪些数
      while (pos>0)
      {p=pos&-pos;  //取出可以填的一个数
       pos-=p;       //去掉已填的数
       a[i][j]=(int)log2(p)+1; //填入a中
       hs[i]|=p;    //修改hs，zs，xj，这个数已用过,‘或’写成‘+’也行
       zs[j]|=p;
       xj[(i-1)/3][(j-1)/3]|=p;
       if (x==y) dfs(k+1);//若x=y，则这一行只有一个空，即现在已填的空，故搜索k+1
       else dfs(k); //若x<>y，则这一行还有空没填，继续搜索这一行
       hs[i]-=p; //搜索完，还原hs，zs，xj
       zs[j]-=p;
       xj[(i-1)/3][(j-1)/3]-=p;
       };
       h[i]-=y;  //s搜索完，还原h[i]
       };
}
int main()
{
  freopen("B.in","r",stdin);
  freopen("B.out","w",stdout);
    int i,j,p0;
    for (i=1;i<10;i++)
      for (j=1;j<10;j++)
        {scanf("%d",&a[i][j]); //读入数独，数组a记的是数独。
         if (a[i][j]>0)
           {h[i]|=1<<(j-1);  //数组h记的是某一行填数情况
                       //h[i]写成二进制，第j位为0，表示a[i][j]=0,即没填   同理第j位为1，表示a[i][j]>0,已填数
            p0=1<<(a[i][j]-1); //p0写成二进制，第k位为1，表示数字k已用过
            if (((hs[i]&p0)!=0)||((zs[j]&p0)!=0)||((xj[(i-1)/3][(j-1)/3]&p0)!=0))
            {printf("-1\n");return 0;};  //这个判断是看数独有没有错，即某一行（列，九宫格）是否有同一数字出现两次
            hs[i]|=p0;  //数组hs记的是某一行数字用的情况
                       //hs[i]写成二进制，第j位为0，表示i行，j没用过 同理第j位为1，表示i行，j用过
            zs[j]|=p0;    //数组zs记的是某一列（纵行）数字用的情况，意义同hs
            xj[(i-1)/3][(j-1)/3]|=p0; //数组xj记的是某一小九宫格数字用的情况，意义同hs
            }        //九个小九宫格分别是   xj[0][0] xj[0][1] xj[0][2]
        //xj[1][0] xj[1][1] xj[1][2]
        // xj[2][0] xj[2][1] xj[2][2]
          else hq[i]++;}  //数组hq记的是某一行缺数的个数，唯一的优化的组成部分。
    for (i=1;i<10;i++) st[i]=i;         //数组st记的是搜索各行的顺序，就是先搜哪一行，再搜哪一行
    for (i=1;i<9;i++)                 //此部分是按各行空缺数的个数将st从小到大排序
      for (j=i+1;j<10;j++)            //使得一会搜的时候，先搜缺数少的行，这也就是唯一的优化
       if (hq[st[i]]>hq[st[j]])
         {st[i]^=st[j];               //交换两数位运算版
          st[j]^=st[i];
          st[i]^=st[j];}
    for (i=1;hq[st[i]]==0;i++);         //考虑到某一行缺数可能为0，故先找到缺数的行
    dfs(i);                          //开始搜索
    printf("%d\n",ans);               //ans就是答案
    return 0;
}

```

---

## 作者：Qiu233 (赞：3)








```cpp
//主要思路不难
//有以下要注意的：
//数独是有初始的几个点的
//这是一个二维的平面，和传统深搜的深度不同，这里需要参数x和y，但是原理是一样的，只需要列不断自增，然后对换行进行处理就好了
//效率还不错吧。。。
#include <iostream>
using namespace std;
//数独的地图
char sudoku[10][10];
//把整个数独分解为九个单位
//通过坐标获取所属单位在t中的索引
//0不使用
char rect[10][10] =
{
    { 0, 0,0,0, 0,0,0, 0,0,0 },
    { 0, 1,1,1, 2,2,2, 3,3,3 },
    { 0, 1,1,1, 2,2,2, 3,3,3 },
    { 0, 1,1,1, 2,2,2, 3,3,3 },
    { 0, 4,4,4, 5,5,5, 6,6,6 },
    { 0, 4,4,4, 5,5,5, 6,6,6 },
    { 0, 4,4,4, 5,5,5, 6,6,6 },
    { 0, 7,7,7, 8,8,8, 9,9,9 },
    { 0, 7,7,7, 8,8,8, 9,9,9 },
    { 0, 7,7,7, 8,8,8, 9,9,9 },
};
//t保存了第x个单位，数字y是否已经使用
//r保存了第x行，数字y是否已经使用
//c保存了第x列，数字y是否已经使用
bool t[10][10], r[10][10], c[10][10];
//是否已经求出结果
bool comp = false;
//检查，包括越界检查和对现有的值进行检查
//还有对 行 列 以及每一宫的数字占用情况进行检查
bool check(char x, char y, char v)
{
    if (x > 0 && y > 0 && x <= 9 && y <= 9 && sudoku[x][y] == 0)
        if (!r[x][v] && !c[y][v] && !t[rect[x][y]][v])
            return true;
    return false;
}
void dfs(char x, char y)
{
    if (comp)return;//已经完成，不再进行计算
    if (sudoku[x][y])//已经有值，直接对下一个进行搜索 这里是输入时已经确定的数字，深搜过程中设置的值不会被这里检查到
    {
        char sx = x, sy = y + 1;
        if (sy == 10)sy = 1, sx++;//换行处理
        dfs(sx, sy);
    }
    else
    {
        for (char i = 1; i <= 9; i++)
        {
            if (check(x, y, i))//剪枝，不对已经占用的数字进行搜索
            {
                //保存状态
                r[x][i] = c[y][i] = t[rect[x][y]][i] = true;//包括 行 列 以及所属宫的数字 占用
                sudoku[x][y] = i;
                char sx = x, sy = y + 1;
                if (sy == 10)sy = 1, sx++;//换行处理
                dfs(sx, sy);
                //清理状态
                sudoku[x][y] = 0;
                r[x][i] = c[y][i] = t[rect[x][y]][i] = false;//去掉对 行 列 所属宫对应的数字占用
            }
        }
    }
    if (x == 10)//深搜到底了，x出现溢出
    {
        for (size_t i = 1; i <= 9; i++)//输出
        {
            for (size_t j = 1; j <= 9; j++)
                cout << (int)sudoku[i][j] << " ";
            cout << endl;
        }
        comp = true;//完成，不再进行搜索
        return;
    }
}
int main()
{
    for (size_t i = 1; i <= 9; i++)//输入数据
    {
        for (size_t j = 1; j <= 9; j++)
        {
            int v;
            cin >> v;
            sudoku[i][j] = v;
            if (v > 0)
                r[i][v] = c[j][v] = t[rect[i][j]][v] = true;//设置占用情况
        }
    }
    dfs(1, 1);
    return 0;
}
```

---

## 作者：hhrq (赞：2)

## 思路

这道题可以用DFS做，从左上到右下搜索每一个格子。如果数字不为0则跳过，为0则寻找合适的答案，然后记得要回溯。当达到边界时，输出即可。

## 实现

可以用bool数组来记录此行（列）（宫）出现过的数字，而且定义一个int类型的二维数组判断是哪个宫的。

```cpp
int a[12][12], m[12][12] = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};
bool flag1[12][12], flag2[12][12], flag3[12][12];
```

定义后进行深搜。

```cpp
void dfs(int x, int y)
{
	if(x == 10 && y == 1)//如果到达边界
	{
		for(int i = 1;i < 10;i++)//则输出
		{
			for(int j = 1;j < 10;j++)
				cout << a[i][j] << " ";
			puts("");
		}
		return;
	}
	int xn = x, yn = y + 1;//向右搜索一个格子
	if(yn == 10)//如果到达边界，则换行
	{
		xn++;
		yn = 1;
	}
	if(a[x][y] != 0) dfs(xn, yn);//如果这个格子已经填数，则搜索下一个
	else 
	{
		for(int i = 1;i <= 9;i++)//循环寻找答案
		{
			if(flag1[x][i] == 0 && flag2[y][i] == 0 && flag3[m[x][y]][i] == 0)//如果这个数字在此行此列此宫都没有出现过
			{
				a[x][y] = i;//填入
				flag1[x][i] = 1;//记录已经出现
				flag2[y][i] = 1;
				flag3[m[x][y]][i] = 1;
				dfs(xn, yn);//继续深搜
				a[x][y] = 0;//进行回溯
				flag1[x][i] = 0;
				flag2[y][i] = 0;
				flag3[m[x][y]][i] = 0;
			}
		}
	}
}
```

然后就完成啦。

完整版code

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

int a[12][12], m[12][12] = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};
bool flag1[12][12], flag2[12][12], flag3[12][12];

void dfs(int x, int y)
{
	if(x == 10 && y == 1)
	{
		for(int i = 1;i < 10;i++)
		{
			for(int j = 1;j < 10;j++)
				cout << a[i][j] << " ";
			puts("");
		}
		return;
	}
	int xn = x, yn = y + 1;
	if(yn == 10)
	{
		xn++;
		yn = 1;
	}
	if(a[x][y] != 0) dfs(xn, yn);
	else 
	{
		for(int i = 1;i <= 9;i++)
		{
			if(flag1[x][i] == 0 && flag2[y][i] == 0 && flag3[m[x][y]][i] == 0)
			{
				a[x][y] = i;
				flag1[x][i] = 1;
				flag2[y][i] = 1;
				flag3[m[x][y]][i] = 1;
				dfs(xn, yn);
				a[x][y] = 0;
				flag1[x][i] = 0;
				flag2[y][i] = 0;
				flag3[m[x][y]][i] = 0;
			}
		}
	}
}

int main()
{
	for(int i = 1;i < 10;i++)
		for(int j = 1;j < 10;j++)
		{
			cin >> a[i][j];//循环输入
			int g = m[i][j];//g为a[i][j]所在的宫
			if(a[i][j] != 0)//如果已经填数
			{
				flag1[i][a[i][j]] = 1;//记录已出现
				flag2[j][a[i][j]] = 1;
				flag3[g][a[i][j]] = 1;
			}
		}
	dfs(1, 1);//从左上角第一个进行深搜
 	return 0;//结束程序
}

```

---

## 作者：zqiceberg (赞：2)

### 算法
dfs(), 剪枝

### 分析
每一行不能重复，每一列不能重复，每一个小九宫格不能重复

每一行用row[N]，二进制数表示[1-9]能不能填

每一列用col[N]，二进制数表示[1-9]能不能填

每一个小九宫格用cell[3][3]，二进制数表示[1-9]能不能填

```cpp
int get(int x, int y)
{
    //哪一个数可以用
    return row[x] & col[y] & cell[x / 3][y / 3];
}
```

### 剪枝
优化搜索顺序，先找到最小分支的点，进行优化

行、列、小九宫格，不能重复，用位运算优化




### 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <fstream>

using namespace std;

const int N = 9, M = 1 << N;

//打表
//ones[M]快速的求出来状态里有多少个1,map[]log2k
int ones[M], map[M];
int row[N], col[N], cell[3][3];
int g[N][N];

void init()
{   
    //初始化每一位都是1，1代表可以用，1-9都可以用
    for (int i = 0; i < N; i++) 
        row[i] = col[i] = (1 << N) - 1;
        
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++) 
            cell[i][j] = (1 << N) - 1;
}

//辅助函数
//当前在x,y是把t填上，还是删掉（填就是dfs，删掉就是恢复现场的过程）
//1表示能用，0表示不能用
void draw(int x, int y, int t, bool is_set)
{   
    if (is_set) g[x][y] = t + 1; //t是0-8
    else g[x][y] = 0;
    
    int v = 1 << t;
    if (!is_set) v = -v;   //如果是清空操作，取反

    row[x] -= v;
    col[y] -= v;
    cell[x / 3][y / 3] -= v;
}

int lowbit(int x)
{
    return x & -x;
}

int get(int x, int y)
{
    //哪一个数可以用
    return row[x] & col[y] & cell[x / 3][y / 3];
}

bool dfs(int cnt)
{
    if (!cnt) return true;   //当前没有空格了，就找到合法方案

    int minv = 10;
    int x, y;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (g[i][j] == 0)
            {
                int state = get(i, j);
                if (ones[state] < minv)    //每个二进制数里1的个数
                {
                    minv = ones[state];
                    x = i, y = j;
                }
            }

	//剪枝，优化搜索顺序，从分支最少的进行枚举
    //循环完，xy存的是分支数量最少的格子
    //先看下这个格子能枚举哪个数
    int state = get(x, y);
    for (int i = state; i; i -= lowbit(i))
    {
        int t = map[lowbit(i)];  //lowbit(i)返回2的k次方，map一下，把2的k次方映射成k
        draw(x, y, t, true);
        if (dfs(cnt - 1)) return true; //dfs下一层
        draw(x, y, t, false);
    }
   
    return false;
}

int main()
{
    //freopen("shudu.in", "r", stdin);

    for (int i = 0; i < N; i++) map[1 << i] = i;//2的i次幂作为下标，存的值为i
    for (int i = 0; i < 1 << N; i++)
        for (int j = 0; j < N; j++)
            ones[i] += i >> j & 1;   //每个数二进制表示有多少个1

    init();
    int cnt = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            cin >> g[i][j];

    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            if (g[i][j])
            {
                draw(i, j, g[i][j] - 1, true);
            }
            else
                cnt++;

    dfs(cnt);

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
            cout << g[i][j] << ' ';
        puts("");
    }
  
    return 0;
}


```

---

## 作者：谁是鸽王 (赞：2)

## 【题解】数独(养生题)+搜索总结

暴力DFS，但是我的代码比较短，供大家参考。

[优雅的暴力——搜索算法小结](https://www.cnblogs.com/winlere/p/10328654.html)

不过我还用了随机化搜索，这种搜索思想可以防止被毒瘤出题人卡掉。有兴趣的可以看一下我的一篇总结里面写了搜索的一些技巧。

对于实现，我的思路是...不好说，但是这样写搜索又快又稳还短。

```cpp
//@winlere
#include <cstdio>
#include <algorithm>

using namespace std;
const int maxn=11;
int line[maxn][maxn],row[maxn][maxn];
int blok[maxn][maxn],loc[maxn][maxn];
int mp[maxn][maxn],seed[maxn];

void dfs(const int&x,const int&y){
      if(x>9) {
	    for(register int t=1;t<=9;++t,putchar('\n'))
		  for(register int i=1;i<=9;++i)
			printf("%d ",mp[t][i]);
	    exit(0);
      }
      if(y>9) return dfs(x+1,1);
      if(mp[x][y]) return dfs(x,y+1);
      for(register int t0=1,t=seed[t0];t0<=9;++t0,t=seed[t0])
	    if(!line[x][t]&&!row[y][t]&&!blok[loc[x][y]][t])
		  line[x][t]=mp[x][y]=row[y][t]=blok[loc[x][y]][t]=t,
			dfs(x,y+1),
			line[x][t]=mp[x][y]=row[y][t]=blok[loc[x][y]][t]=0;
}

int main(){
      for(register int t=1;t<=9;++t) seed[t]=t;
      srand(19260817);
      random_shuffle(seed+1,seed+10);
      for(register int t=1;t<=9;++t)
	    for(register int i=1,t1;i<=9;++i)
		  scanf("%1d",&t1),loc[t][i]=3*((t-1)/3)+(i+2)/3,mp[t][i]=blok[loc[t][i]][t1]=line[t][t1]=row[i][t1]=t1;
      dfs(1,1);
}

```





---

## 作者：Doubeecat (赞：2)

这一道题是一个经典的搜索题目，有多种解法：`DLX`，`位运算优化`等。  
但是我们从最简单的思路开始思考：  

- 对于每个位置判断这边是否能填上数
- 如果可以，就填上，并且搜索，搜完回溯  

由此，我们可以写出一份非常暴力的代码：
```cpp
#include <cstdio>
#include <cctype>
#include <queue>
#include <stack>
#include <cmath>
#include <iostream>
#include <cstring>
#include <vector>
#include <bitset>
#include <algorithm>
#define MAXN 11
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
#define cg(x,y) (x-1)/3*3+(y-1)/3+1
#define MOD 80112002
using namespace std;

inline int read() {
    int a=0,f=1;char v=getchar();
    while(!isdigit(v)) {if (v == '-') {f = -1;}v = getchar();}
    while (isdigit(v)) {a = a * 10 + v - 48;v = getchar();}
    return a * f;
}

int pre[MAXN][MAXN];
bool line[MAXN][MAXN],len[MAXN][MAXN],gong[MAXN][MAXN];

//方阵序号=（行数-1）/3*3+（列数-1）/3+1
//cg(x,y)指(x,y)在哪个方格中

void print() {
	for (int i = 1;i <= 9;++i) {
		for (int j = 1;j <= 9;++j) {
			printf("%d ",pre[i][j]);
		}
		printf("\n");
	}//打印方案
	exit(0);//这边的目的是为了能在dfs函数中快速退出，加快效率
}

bool check(int k,int x,int y) {
	if (line[x][k]) {
		return false;//在行中进行查找，能否填入这个数
	}
	if (len[y][k]) {
		return false;//在列中进行查找，能否填入这个数
	}
	if (gong[cg(x,y)][k]) {
		return false;//在宫中进行查找，能否填入这个数
	}
	return true;
}

void dfs(int x,int y) {
	if (pre[x][y]) {
		if (x == 9 && y == 9) {
			print(); //如果搜完了，直接打印
		}
		else if (y == 9) {
			dfs(x+1,1);//如果搜到最后一行，返回第一行搜
		}
		else {
			dfs(x,y+1);//往下一列搜索
		}
	}
	else {
		for (int i = 1;i <= 9;++i) {
			if (check(i,x,y)) {
				pre[x][y] = i;
				line[x][i] = len[y][i] = gong[cg(x,y)][i] = 1;//标记选择了i
				if (x == 9 && y == 9) {
					print(); 
				}
				else if (y == 9) {
					dfs(x+1,1);
				}
				else {
					dfs(x,y+1);
				}
				pre[x][y] = 0;
				line[x][i] = len[y][i] = gong[cg(x,y)][i] = 0;//回溯
			}
		}
	}
}

int main() {
	for (int i = 1;i <= 9;++i) {
		for (int j = 1;j <= 9;++j) {
			pre[i][j] = read();
			if (pre[i][j]) {
				line[i][pre[i][j]] = len[j][pre[i][j]] = gong[cg(i,j)][pre[i][j]] = true;//标记这边有一个数
			} 
		}
	} 
	dfs(1,1);
	return 0;
}
```
代码很朴素，但是由于本题数据较简单，可以以一个优秀的时间复杂度通过，但是如果想要锻炼自己的搜索剪枝能力，可以移步[UVA1309](https://www.luogu.org/problemnew/show/UVA1309)，这题是16*16的数独，更加考验搜索剪枝能力。

---

## 作者：comfort (赞：2)

本蒟蒻第一次发题解，多多包涵。

经典的深搜，比较简单，分两部分说

一.主程，读入，再命名一个flag数组标记即可


二.dfs函数，这里用一维变量，从左上到右下扫一遍（不用剪枝，数据很小）
   
   1.先判断要不要操作（有没有值）
   
   2.出口（即扫完了）
   
   3.开始用行列九宫格扫，由于是一维，还要生成x，y来代表行列。九宫格打表生成
   
   4.回溯。
   
   
   
   
**在讲一哈深搜b**（资料来自度娘）

深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次；
采用的搜索方法的特点是尽可能先对纵深方向进行搜索。

深度优先遍历图的方法是，从图中某顶点v出发：

（1）访问顶点v；

（2）依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；

（3）若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。

**再附个基本模板**

void DFS ( int n )

{

     if ( 满足结束条件,即搜索到终点 )
     
         return ;
         
     else
     
         DFS ( n + 1 );
}

**上代码**


#include<bits/stdc++.h>

using namespace std;

int a[10][10];

int m[10][10]={

	{0,0,0,0,0,0,0,0,0,0},
    {0,1,1,1,2,2,2,3,3,3},
    {0,1,1,1,2,2,2,3,3,3},
    {0,1,1,1,2,2,2,3,3,3},
    {0,4,4,4,5,5,5,6,6,6},
    {0,4,4,4,5,5,5,6,6,6},
    {0,4,4,4,5,5,5,6,6,6},
    {0,7,7,7,8,8,8,9,9,9},
    {0,7,7,7,8,8,8,9,9,9},
    {0,7,7,7,8,8,8,9,9,9}
};

bool f1[10][10],f2[10][10],f3[10][10];

void dfs(int t)
{
   
   if(t>81) {
   
    	for(int i=1;i<=9;i++){
        
	       for(int j=1;j<=9;j++){
           
		      cout<<a[i][j]<<" ";
		   }
           
		   cout<<endl;
	       
	    }  
	       return ;
           
	}  
	int x=(t-1)/9+1;
    
	int y=(t-1)%9+1; 
    
    if(a[x][y]){
    
    	dfs(t+1);
        
    	return ;
        
	}
	for(int i=1;i<=9;i++){
    
		if(!f1[x][i]&&!f2[y][i]&&!f3[m[x][y]][i]){
        
			a[x][y]=i;
            
			f1[x][i]=f2[y][i]=f3[m[x][y]][i]=true;
            
			dfs(t+1);
            
			a[x][y]=0;
            
			f1[x][i]=f2[y][i]=f3[m[x][y]][i]=false;
            
		}
	} 
    
}
int main(){

	for(int i=1;i<=9;i++)
    
	   for(int j=1;j<=9;j++){
       
	   	    cin>>a[i][j];
            
	   	    if(!a[i][j]) continue;
            
	   	    else{
	   	  	    f1[i][a[i][j]]=true;
                
				f2[j][a[i][j]]=true;
                
		    	f3[m[i][j]][a[i][j]]=true;
                
		    }
	   }
       
	dfs(1);
	       
	return 0;
}

---

## 作者：矢志不渝 (赞：2)

深搜算法
------------
		这里用了一个数组next[x][y]表示数字所在宫
		sum表示是否出现了解
    	bookx[][],booky[][]表示是否在行列中已用过这个数
    	booka[][]表示是否在宫格中用过这个数
        不理解可以查阅《啊哈算法》
        （其实和别的搜索一样，只是多一个标记参数）
        ![数独基本常识](C:\Users\Administrator\Desktop)
        上图就是数独的一般格式，当然，里面是有数字的
        ![数独](C:\Users\Administrator\Desktop)
        上述数独答案是什么呢？？？
        
```cpp
#include<cstdio>
int bookx[10][10],booky[10][10],booka[10][10],sun;//标记行 列 宫
bool sum=true;
int a[10][10];
int next[10][10]={{},
				  {0,1,1,1,4,4,4,7,7,7},				      					  {0,1,1,1,4,4,4,7,7,7},
                  {0,1,1,1,4,4,4,7,7,7},
                  {0,2,2,2,5,5,5,8,8,8},
                  {0,2,2,2,5,5,5,8,8,8},					 
                  {0,2,2,2,5,5,5,8,8,8},            
                  {0,3,3,3,6,6,6,9,9,9},					  
                  {0,3,3,3,6,6,6,9,9,9},
                  {0,3,3,3,6,6,6,9,9,9}}; //这个数组表示宫
void print()//输出函数
{
    int i,j;
    for(i=1;i<=9;i++)
    {
        for(j=1;j<=9;j++)
        {
            printf("%d ",a[i][j]);
        }
        printf("\n");
    }
    return;
}
void dfs(int x,int y)深搜主体，先搜列再搜行
{
    int i,k,t;
    t=next[x][y];//t表示所在宫
    if(x==10)//行搜完，已发现解
    {
        print();
        sum=false;
        return;
    }
    if(y==10)//列搜完，转下一行
    {
        dfs(x+1,1);
        return;
    }	
    if(sum)//未发现解（已发现解就不用搜了）
    {
        if(a[x][y]==0)//若这个是空（不是空不用填了，注意！！！）
        {
            for(i=1;i<=9;i++)遍历九种可能
            {
                if(bookx[x][i]==0 && booky[y][i]==0 && booka[t][i]==0 )//若未标记
                {
                    a[x][y]=i;//填数
                    bookx[x][i]=1;//标记
                    booky[y][i]=1;
                    booka[t][i]=1;
                    dfs(x,y+1);//下一个空
                    if(!sum) return;//已发现解，返回，不用再搜
                    a[x][y]=0;//注意，一定要赋回零，不然结果就会错
                    bookx[x][i]=0;//取消标记
                    booky[y][i]=0;
                    booka[t][i]=0;
                }
            }
        }
        else 
        
        {
            dfs(x,y+1);//如果不是空，跳过即可
            return;
        }
    }
    return;	
}
int main()
{
	int i,j,k,t;
	for(i=1;i<=9;i++)
	{
		for(j=1;j<=9;j++)
		{
			scanf("%d",&a[i][j]);//读入并标记行 列 宫
			k=a[i][j];t=next[i][j];
			if(a[i][j]!=0)
			{
				bookx[i][k]=1;
				booky[j][k]=1;
				booka[t][k]=1;
			}
		}
	}
	dfs(1,1);//开始深搜
	return 0;
}
```
一定注意，上输代码中的a[x][y]==0一定要加上
拜......

---

## 作者：艾蕾 (赞：2)

，四个变量储存是否可放很明显这题用dfs可以过，搜到9 9就开始输出 9 9 的值最后判断

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][10],b[10][10],c[10][10],d[10][4][4],e[10]={0,9,9,9,9,9,9,9,9,9};
//b【10】【10】储存某数字是否在某行出现过，c 【10】【10】储存列，d储存 某个九宫格，e储存剩余数的个数 
void search(int x,int y){
    if(x==9&&y==9){//搜索到9 9时输出 
        for(int i=1;i<=8;i++){
            for(int j=1;j<=8;j++) cout<<a[i][j]<<" ";
            cout<<a[i][9];
            cout<<endl;
        }
        for(int i=1;i<=8;i++) cout<<a[9][i]<<" ";
        a[9][9]=0;//因为到9 9就输出了结果，9 9不确定有没有值，所以统一清零再找未出现的数
            for(int i=1;i<=9;i++)
                for(int j=1;j<=9;j++){
                    if(a[i][j]) e[a[i][j]]--;
                    else for(int i=1;i<=9;i++) if(e[i]) cout<<i;
```
}//找到未出现的某数输出

```cpp
    }
    if(!a[x][y]){
        for(int k=1;k<=9;k++)
            if(!b[k][x]&&!c[k][y]&&!d[k][(x-1)/3+1][(y-1)/3+1]){//判断是否可放 
                a[x][y]=k;
                b[k][x]=1;
                c[k][y]=1;
                d[k][(x-1)/3+1][(y-1)/3+1]=1;
                if(y<9) search(x,y+1);
                else search(x+1,1);
                a[x][y]=0;
                b[k][x]=0;
                c[k][y]=0;
                d[k][(x-1)/3+1][(y-1)/3+1]=0;//回溯 
        }
    }
    else if(y<9) search(x,y+1);//搜索下一位置 
    else search(x+1,1);//到行尾搜索下一行 
}
int main(){
    for(int i=1;i<=9;i++)
        for(int j=1;j<=9;j++){
            cin>>a[i][j];
            if(a[i][j]){
                b[a[i][j]][i]=1;
                c[a[i][j]][j]=1;
                d[a[i][j]][(i-1)/3+1][(j-1)/3+1]=1;
            }
        }
    search(1,1);
    return 0;
}
```

---

## 作者：doby (赞：2)

这道题比较无聊，思路不是很好找……

要注意如何判断，然后dfs即可……

竟然不会超时233333333……

找完八十一~~难~~步就可以输出并退出了……

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
int f[9][9],xx[9][9],yy[9][9],flag=0,a,out,fh;//f记录所有数，xx记录行，yy记录列
char cc;
int read()
{
    out=0,fh=1,cc=getchar();
    if(cc=='-'){fh=-1;}
    while(cc>'9'||cc<'0'){cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
void print()//输出整个数独……
{
    for(int i=0;i<9;i++)
    {
        for(int j=0;j<9;j++)
        {
            printf("%d ",f[i][j]);
        }
        printf("\n");
    }
}
int check(int x,int y,int num)//找当前所在宫中是否有与num重复的
{
    x=x/3*3,y=y/3*3;
    for(int i=0;i<3;i++)
    {
        for(int j=0;j<3;j++)
        {
            if(f[x+i][y+j]==num)
            {
                return 0;
            }
        }
    }
    return 1;
} 
void dfs(int step)
{
    if((step==81)&&(flag==0))//找完八十一步
    {
        flag=1;//其实flag已经没用了
        print();//输出结果
        exit(0);//退出所有程序，所以flag一点用都没有……
    }
    if(f[step/9][step%9]){dfs(step+1);}//读进来的时候已经有数了……
    else
    {
        for(int i=1;i<10;i++)
        {
            if((xx[step/9][i-1]==0)&&(yy[step%9][i-1]==0)&&(check(step/9,step%9,i)))//没有重复(的意思)
            {
                f[step/9][step%9]=i,//填上去
                xx[step/9][i-1]=1,//为什么用i-1记录i呢……
                yy[step%9][i-1]=1;//主要是因为我只想开9*9，不影响理解……
                dfs(step+1);//找到了，继续找下一步
                f[step/9][step%9]=0,//拆掉所有标记(套路)
                xx[step/9][i-1]=0,
                yy[step%9][i-1]=0;
            }
        }
    }
}
int main()
{
    for(int i=0;i<9;i++)
    {
        for(int j=0;j<9;j++)
        {
            a=read();
            if(a)
            {
                xx[i][a-1]=1,//标记已经出现过了
                yy[j][a-1]=1;
            }
            f[i][j]=a;
        }
    }
    dfs(0);
    return 0;
}
```

---

## 作者：Deny_小田 (赞：2)

小田又来发题解了。


本期题解很水很水，楼下的代码我优化了一下，也添加了许多注释，帮助各位OIer理解（楼下勿喷！）


咦我加了freopen居然还AC了。。。大家可以把freopen去掉。


楼下思路梳理：

数独是9×9的，不大（比起POJ的16×16已经很仁慈了。。。），于是暴搜。


DFS的参数n是一个数而不是坐标，用n求出的x和y才是坐标：x = n/9; y = n%9;


用一个循环，枚举1~9的数字，发现可以，DFS下一个。

检查可以的函数：bool Judge（int n,int k）;


行和列的检查根据上5行的坐标递推公式可以递推出来。


九宫格递推公式：fx = x/3\*3;  fy = y/3\*3;


flag是一个宝贝！之前我尝试不用flag，结果连样例都没有通过。。。


然后就基本上没有什么注意的了，其余普通的东西留给大家思考（跟说的像是你做的似的。。。@Deny\_小田）



看代码：





    
```cpp
#include <cstdio>
#define Size 9
int Num[Size][Size],flag = 1;
bool Judge(int n,int k){
    int x = n/Size,y = n%Size,fx = (x/3)*3,fy = (y/3)*3;
    for(int i = 0; i < Size; i++){
        if(Num[i][y] == k) return false;    //列不变，行从上到下扫描，发现有一样的，说明 k 不可以
        if(Num[x][i] == k) return false;    //行不变，列从左到右扫描，发现有一样的，说明 k 不可以
    }
    for(int i = fx; i < fx+3; i++) for(int j = fy; j < fy+3; j++) if(Num[i][j] == k) return false;
        // i 从左到右扫描，j 从上到下扫描，恰好能扫描整个九宫格
    return true;    //三种情况都保证数独成立，成功 
}
void DFS(int n){
    int x = n/Size,y = n%Size;
    if(n >= Size*Size) flag = 0;
    else{
        if(Num[x][y] != 0) DFS(n+1);    // /Size 为行 %Size 为列。  
        else if(flag){
            for(int i = 1; i <= Size; i++){        // i 为填补的数字 
                if(Judge(n,i)){ Num[x][y] = i; DFS(n+1); }        //判断 i 可以，DFS下一个。充分应用递归 
            }
            if(flag) Num[x][y] = 0; 
        }
    }
}
int main(){
    freopen("sudoku.in","r",stdin);
    for(int i = 0; i < Size; i++) for(int j = 0; j < Size; j++) scanf("%d",&Num[i][j]);
    DFS(0);
    for(int i = 0; i < Size; i++){
        for(int j = 0; j < Size; j++){
            printf("%d ",Num[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：AgrumeStly (赞：2)

### 欢迎回来
#### 欢迎回到_TNT_ BOOM大讲堂！

今天我们来讲 $P1784$数独 这道题

首先明白数独是什么？

*懂得跳过*


	数独（shù dú）是源自18世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3*3）内的数字均含1-9，不重复 。
    
    数独盘面是个九宫，每一宫又分为九个小格。在这八十一格中给出一定的已知数字和解题条件，利用逻辑和推理，在其他的空格上填入1-9的数字。使1-9每个数字在每一行、每一列和每一宫中都只出现一次，所以又称“九宫格”。

好的，明白了以后，我们想一想，计算机如何实现填数独$???$

首先，我们先明确，这道题是$dfs$,所以我们得先写出dfs函数，但是在这个过程中，我遇到了一个困难，就是如何判断某个数字在某一宫里的关系，我想到了一个方法，就是定义一个数组m，来存放每一宫的关系。

不好画图，直接那程序写出来了：

```cpp
int m[10][10] =
{
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}
};
```
通过这样的方法，我们就有办法知道某一宫的关系了！

话不多说，上$AC$代码：

详细的看注释。

```cpp
#include<cstdio>
//#include<cstdlib>
using namespace std;

int a[11][11]; //用来存九宫数独的数字 
bool flag1[11][11], flag2[11][11], flag3[11][11];

// flag1[i][j]代表第i行,值为j的数是否使用
// flag2[i][j]代表第i列,值为j的数是否使用
// flag3[i][j]代表第i宫,值为j的数是否使用

int m[10][10] =
{
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}
}; //用来帮助我们定位第几宫；
//将第i宫数字初始化为i，我们就可以根据m的下标直接定位是第几宫 

void dfs(int x, int y)
{
	if(x == 10 && y == 1) //x表示行，y表示列，10行1列表示数独已经填满 
	{
		for(int i = 1; i <= 9; i++) //数独填满，输出即可 
		{
			for(int j = 1; j <= 9; j++)
				printf("%d ", a[i][j]);
			puts("");
		}
		//puts(""),system("pause");
		return;
	}
	int x_new = x, y_new = y + 1; //(x_new,y_new)表示(x,y)的下一个格子的位置 
	if(y_new == 10) //若列数不满十,则行数不变列数加1;若列数满十,则行数加1,列数变为1 
	{
		x_new++;
		y_new = 1;
	}
	if(a[x][y]) //若(x,y)原来有数字 
		dfs(x_new, y_new); //递归枚举下一个格子 
	else //若(x,y)原来没有数字，枚举所有可能：填充1-9
	{
		for(int i = 1; i <= 9; i++)
		{//若第x行 or 第y列 or 第m[x][y]宫 出现值为i的数字，则跳过 
			if(flag1[x][i] || flag2[y][i] || flag3[m[x][y]][i])
				continue;
			a[x][y] = i; //x行y列m[x][y]宫都没有出现数字i，则a[x][y]可以填i 
			flag1[x][i] = flag2[y][i] = flag3[m[x][y]][i] = true;
			// a[x][y]可以填i后，x行y列m[x][y]宫都出现了数字i，赋值为true 
			dfs(x_new, y_new); //递归枚举下一个格子 
			flag1[x][i] = flag2[y][i] = flag3[m[x][y]][i] = false; 
			//下一次递归还要用这些标记，所以每次用完要清零 
			a[x][y] = 0; // 可删来让学生查错，回溯
		}
	}
}

int main()
{
	for(int i = 1; i <= 9; i++)
		for(int j = 1; j <= 9; j++)
		{
			scanf("%d", &a[i][j]);
			if(a[i][j] == 0) continue;
//输入的同时根据输入的结果将flag1、flag2、flag3三个数字初始化 
			flag1[i][a[i][j]] = true; 
			flag2[j][a[i][j]] = true;
			flag3[m[i][j]][a[i][j]] = true;
		}
	dfs(1, 1);
	
	return 0;
}

```

好了，本期_TNT_ BOOM 大讲堂就说到这里了。

## $Bye Bye!$

---

## 作者：孙宇辰 (赞：2)

###深度优先搜索###

深搜的典型题目

用数组标记是否可以在某个格子放某个数可以快很多倍，不用每次都去for循环搜索横竖与宫格。//这个方法可以加快时间啊！！！

附上ac代码：
```
#include <cstdio>
using namespace std;
struct NODE{                                                                                                                                                                 防抄袭
	int x, y;
}b[85];
int a[10][10];
int ling;
int flag=0;
bool ma[10][10],mb[10][10],mc[10][10];
bool check (int x, int y, int s)
{
	if (ma[x][s]==0&&mb[y][s]==0&&mc[(x-1)/3*3+(y+2)/3][s]==0)
		return 1;
	return 0;
}
void dfs (int cnt)
{
	if (cnt == ling+1)                                                                                    防抄袭
	{
		flag=1;
		return;
	}
	int x = b[cnt].x;
	int y = b[cnt].y;
	for (int i = 1; i <= 9; i++)
	    if (check (x, y, i)==true)
		{
			a[x][y] = i;
			ma[x][i]=1;
			mb[y][i]=1;
			mc[(x-1)/3*3+(y+2)/3][i]=1;
			dfs (cnt+1);
			if(flag) return;
			a[x][y] = 0;
			ma[x][i]=0;
			mb[y][i]=0;
			mc[(x-1)/3*3+(y+2)/3][i]=0;
		}
}
int main()
{
	for (int i = 1; i <= 9; i++)
		for (int o = 1; o <= 9; o++)
		{
			scanf ("%1d", &a[i][o]);//
			if (a[i][o]==0)
			{
				ling++;
				b[ling].x=i;
				b[ling].y=o;
			}
			else
			{
				ma[i][a[i][o]]=1;
				mb[o][a[i][o]]=1;
				mc[(i-1)/3*3+(o+2)/3][a[i][o]]=1;
			}
		}
	dfs (1);
	for (int i = 1; i <= 9; i++)
	{
		for (int o = 1; o <= 9; o++)
			printf ("%d", a[i][o]);
		printf ("\n");
	}
	return 0;
}
```

---

## 作者：yangyujia18 (赞：1)

众所周知~~也有可能是我太弱了还可能是我懒~~，2维的dfs是很难的  
所以我们要把这个搜索降成一维~~其实根本不用~~  
最简单的其实就是直接拉成一条~~我也不会别的~~  
然后输入时标注原来就有的点不搜  
搜到一个时把它记在数组中，并把行列九宫格的这个数置为用过  
~~可是怎么判断一个点在哪个行列九宫格呢~~  
~~行=（坐标-1）/9，列=坐标%9，九宫格打表~~  
搜不了就返回，搜到终点就输出结束  
```cpp
#include<bits/stdc++.h>
using namespace std;
int suduko[100];
bool line[15][15],roll[15][15],gong[15][15];
const int sg[100]={0,
				   1,1,1,2,2,2,3,3,3,
				   1,1,1,2,2,2,3,3,3,
				   1,1,1,2,2,2,3,3,3,
				   4,4,4,5,5,5,6,6,6,
				   4,4,4,5,5,5,6,6,6,
				   4,4,4,5,5,5,6,6,6,
				   7,7,7,8,8,8,9,9,9,
				   7,7,7,8,8,8,9,9,9,
				   7,7,7,8,8,8,9,9,9};
bool dfs(int cur)
{
	if(cur==82)
	{
		for(int i=0;i<=8;i++)
		{
			for(int j=1;j<=9;j++)
				cout<<suduko[i*9+j]<<' ';
			cout<<endl;
		}
		return true;
	}
	if(suduko[cur]!=0)
		return dfs(cur+1);
	for(int i=1;i<=9;i++)
	{
		if(!line[(cur-1)/9+1][i]&&!roll[cur%9][i]&&!gong[sg[cur]][i])
		{
			line[(cur-1)/9+1][i]=true;
			roll[cur%9][i]=true;
			gong[sg[cur]][i]=true;
			suduko[cur]=i;
			if(dfs(cur+1))
				return true;
			line[(cur-1)/9+1][i]=false;
			roll[cur%9][i]=false;
			gong[sg[cur]][i]=false;
			suduko[cur]=0;
		}
	}
	return false;
}
int main()
{
	memset(line,false,sizeof(line));
	memset(roll,false,sizeof(roll));
	memset(gong,false,sizeof(gong));
	for(int i=1;i<=81;i++)
	{
		cin>>suduko[i];
		if(suduko[i]!=0)
		{
			line[(i-1)/9+1][suduko[i]]=true;
			roll[i%9][suduko[i]]=true;
			gong[sg[i]][suduko[i]]=true;
		}
	}
	dfs(1);
	return 0;
}
```


---

## 作者：反比例函数 (赞：1)

一道并不怎么需要剪枝的DFS搜索题。

鉴于我的搜索方式过于奇葩，决定写一篇题解。

数独是一个比较经典的DFS题，至于连数独都没玩过的，仔细看题目描述。

我的DFS函数甚至没用到x和y，只有一个变量dep解决。（天知道当时的我怎么这么中二想了个无比奇特的办法）

看代码吧：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int a[10][10],b[10][10];
bool f(int dep)//判重函数
{	int x=dep/9,y=dep%9;//用dfs函数中的算法把x和y算出来
	for(int j=0;j<9;j++)
	  if(a[x][j]==a[x][y]&&j!=y) return false;//竖行相冲，不能填
	for(int j=0;j<9;j++)
	  if(a[j][y]==a[x][y]&&j!=x) return false;//横行相冲，不能填
	int xx=x/3*3,yy=y/3*3;
    //不要觉得/3*3等于啥没干，这样可以算出所在的小九宫格，原因自行思考（提示：int形变量除法的特点）
	for(int i=xx;i<xx+3;i++)
	  for(int j=yy;j<yy+3;j++)
	    if(a[i][j]==a[x][y]&&i!=x&&j!=y) return false;//小九宫格内相冲，不能填
	return true;//如果前三种情况都不相冲，就可以填
}
int dfs(int dep)//暴搜函数，并没有用void是个人习惯
{	if(dep==81)//如果搜完了
	{	for(int i=0;i<9;i++)
		  for(int j=0;j<9;j++) b[i][j]=a[i][j];//存下来
		  return 0;}//跳出去
	int x=dep/9,y=dep%9;
    //手动算算可以知道，这是从左上开始每次走完一行的搜索方法，其实质与将xy放在形参里面无异。
	if(a[x][y]==0)//如果这个空没填
	{	for(int i=1;i<=9;i++)//从1到9每个试试
	  	{	a[x][y]=i;//填上
			if(f(dep)) dfs(dep+1);}//只要不冲突，就搜下一层
		a[x][y]=0;}//回溯
	else dfs(dep+1);//如果这个空填过了，直接看下一个。
	return 0;
}
int main()
{
	int i,j;
	//freopen("1.in","r",stdin);
	memset(b,0,sizeof(b));
	for(i=0;i<9;i++)
	  for(j=0;j<9;j++)
	    cin>>a[i][j];
	dfs(0);//最开始时在第0层
    for(i=0;i<9;i++)
	{	for(j=0;j<9;j++)
		  cout<<b[i][j]<<' ';//输出
		cout<<endl;}}
}
```

---

## 作者：Ousmane_Dembele (赞：1)

先做靶形数独再做这题简直就是双倍经验……
直接把代码复制一下删除点内容再输出就ok了
下面根据该题我已通过的题解改编


------------
简单来说，如果除了那一行全都不考虑，那么假设有6个0，那就有720种可能，但是如果只有4个0就只有24种可能，显然化简了很多。当然，还可以更化简，那就是枚举每一个0，从行列方格三个角度判断1-9中有多少可能的情况。这样能最大限度的保证最优，但是我们的方案已经够了。

代码（注释但不保证对）：
```

#include<bits/stdc++.h>
using namespace std;
struct node{
    int rank;//这个rank和number是排序用的，x和y是判断先设哪个的
    int number;
    int x;
    int y;
}px[10],nows[82];//81个就够了
int score[10][10]=
{{0,0,0,0,0,0,0,0,0,0},
{0,6,6,6,6,6,6,6,6,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,9,10,9,8,7,6},
{0,6,7,8,9,9,9,8,7,6},
{0,6,7,8,8,8,8,8,7,6},
{0,6,7,7,7,7,7,7,7,6},
{0,6,6,6,6,6,6,6,6,6}};  
int sudoku[10][10],cnt; 
bool flag;
int ans=-1; 
int calc(){//这个应该看得懂吧
    //int t=0;
    //for(int i=1;i<=9;i++)
       // for(int j=1;j<=9;j++)
         //   t+=score[i][j]*sudoku[i][j];
    // if(t==2799){
         for(int i=1;i<=9;i++){
           for(int j=1;j<=9;j++)
               cout<<sudoku[i][j]<<' ';
             cout<<endl;
         }
    exit(0);
    // }
    //return t;
}
int dfs(int count){
    if(count==cnt+1){
        //ans=max(ans,calc());//到了就计算
        calc();
        return 0;
    }
    //if((81-count)*10+calc()>=ans)return 0;
    //for(int i=a;i<=9;i++)
    //cout<<"i"<<endl;
       //for(int j=b;j<=9;j++){
    int i=nows[count].x;//我原来的TLE代码改编
    int j=nows[count].y;
           for(int k=1;k<=9;k++){//同一列同一行同一方格有这个数了
               if(row[i][k]==true||cal[j][k]==true||area[(i-1)/3*3+1+(j-1)/3][k]==true)continue;
               sudoku[i][j]=k;
               row[i][k]=true;
               cal[j][k]=true;
               area[(i-1)/3*3+1+(j-1)/3][k]=true;
               //if(j==9)
               dfs(count+1);
               //else dfs(i,j+1,cnt+1);
               row[i][k]=false;//回溯
               cal[j][k]=false;
               area[(i-1)/3*3+1+(j-1)/3][k]=false;
          }
     //  }
}
bool cmp(node a,node b){
    return a.number<b.number;//
}
int main(){
    int good=0;
    for(int i=1;i<=9;i++)px[i].rank=i;
    for(int i=1;i<=9;i++)
       for(int j=1;j<=9;j++){ 
           int y;
           cin>>y;
           sudoku[i][j]=y;
           if(y==0){
               px[i].number++;
               continue;
           }
           row[i][y]=true;
           cal[j][y]=true;
           area[(i-1)/3*3+1+(j-1)/3][y]=true;
           //good++;
       }
    sort(px+1,px+10,cmp);
    //dfs(1,1,good);
    for(int i=1;i<=9;i++){
       for(int j=1;j<=9;j++){
           if(sudoku[px[i].rank][j]==0){
               nows[++cnt].x=px[i].rank;
               nows[cnt].y=j;
           }
       }
    }//for(int i=1;i<=cnt;i++)cout<<nows[i].x<<" "<<nows[i].y<<endl;
    dfs(1);
    // for(int i=1;i<=9;i++){
    //   for(int j=1;j<=9;j++)
    //       cout<<sudoku[i][j]<<" ";
    //   cout<<endl;
    // }
    cout<<ans;
    return 0;
}

```

---

## 作者：孙宇辰 (赞：1)

### 时间优化（空间换时间），具体详见代码中注释
```
#include <cstdio>
using namespace std;
struct NODE{
    int x, y;
}b[85];//存储需要dfs的点的坐标 
int a[10][10];//存储数独 
int ling;//零的个数 
int flag=0;//见dfs中作用 
bool ma[10][10],mb[10][10],mc[10][10];//标记行列宫是否可填某数（空间换时间） 
bool check (int x, int y, int s)
{
    if (ma[x][s]==0&&mb[y][s]==0&&mc[(x-1)/3*3+(y+2)/3][s]==0) 
        return 1;//若横行数列宫格都满足填入的条件则填入
    return 0;//否则不能填 
}//判断坐标(x,y)是否可以填入s这个值 
void dfs (int cnt)
{
    if (cnt == ling+1)
    {
        flag=1;//由于输入保证有且只有一组解，所以找到后可直接返回。
        return;//flag=1表示找到正解，以保证连续返回，不再浪费时间。 
    }//判断条件，若已经填入了所有需填的数，则说明找到了一组正解,返回 
    int x = b[cnt].x;
    int y = b[cnt].y;//坐标的赋值 
    for (int i = 1; i <= 9; i++)//for循环尝试所有可能 
        if (check (x, y, i)==true)
        {
            a[x][y] = i;
            ma[x][i]=1;
            mb[y][i]=1;
            mc[(x-1)/3*3+(y+2)/3][i]=1;//临时认为(x,y)填i 
            dfs (cnt+1);//向下一层搜 
            if(flag) return;//上述flag连续返回的执行 
            a[x][y] = 0;
            ma[x][i]=0;
            mb[y][i]=0;
            mc[(x-1)/3*3+(y+2)/3][i]=0;//返回后发现(x,y)不能填i，取消之前的标记 
        }
}//核心部分 
int main()
{
    for (int i = 1; i <= 9; i++)
        for (int o = 1; o <= 9; o++)
        {
            scanf ("%1d", &a[i][o]);//这样可以做到一位一位读入 
            if (a[i][o]==0)//若这个位置为0 
            {
                ling++;//ling统计需要填入数的格子的数目 
                b[ling].x=i;
                b[ling].y=o;//b数组存储需要搜索的格子的坐标,所以用到了结构体 
            }
            else//否则(即这个位置有确定的值) 
            {
                ma[i][a[i][o]]=1;//标记横行不能填哪些数 
                mb[o][a[i][o]]=1;//标记纵列不能填哪些数 
                mc[(i-1)/3*3+(o+2)/3][a[i][o]]=1;//标记宫格不能填哪些数 
            }
        }//输入 
    dfs (1);//开始搜索！ 
    for (int i = 1; i <= 9; i++)
    {
        for (int o = 1; o <= 9; o++)
            printf ("%d", a[i][o]);
        printf ("\n");
    }//输出答案 
    return 0;//完美地结束了！ 
}
```

---

## 作者：Violette (赞：1)

### 主要部分大概就是模拟+深搜。

模拟可以用暴力实现。

模拟部分：
```cpp
int map[10][10]=
{{},
{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};
//判断9个宫的情况，打表完成
```
#### 有一个要注意的点：第一行，第一列要赋值为零。

然后是dfs的部分：
```cpp
void dfs(int x,int y)//深搜 
{
	if(y>9)//判断换行的情况 
	{
		x++;
		y=1;
	}
	if(x>9){//最后一行已经搜完，开始输出 
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=9;j++) 
				cout<<a[i][j]<<" ";
			cout<<endl;//不要忘了换行。。 
		}
		return;
	}
	if(a[x][y]>0) dfs(x,y+1);
	else
	{
		for(int i=1;i<=9;i++)
		{
				if(flag1[x][i]) continue;
				if(flag2[y][i]) continue;
				if(flag3[map[x][y]][i]) continue;
				flag1[x][i]=true;// true代表用过
				flag2[y][i]=true;
				flag3[map[x][y]][i]=true;
				a[x][y]=i;
				dfs(x,y+1);
				flag1[x][i]=false;// false代表没用过
				flag2[y][i]=false;
				flag3[map[x][y]][i]=false;
		}
		a[x][y]=0;//注意要把a[x][y]清零 
	}
}
```
思路也不算很复杂，主要考验代码能力。。。

主函数中，循环输入，判断是否填了数。

最后，从第一行，第一列搜索就大功告成了。

完整代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[10][10];
bool flag1[10][10],flag2[10][10],flag3[10][10];
// flag1[i][j]代表第i行,值为j的数是否使用
// flag2[i][j]代表第i列,值为j的数是否使用
// flag3[i][j]代表第i宫,值为j的数是否使用 
int map[10][10]=
{{},
{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};
//判断9个宫的情况，打表完成 

void dfs(int x,int y)//深搜 
{
	if(y>9)//判断换行的情况 
	{
		x++;
		y=1;
	}
	if(x>9){//最后一行已经搜完，开始输出 
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=9;j++) 
				cout<<a[i][j]<<" ";
			cout<<endl;//不要忘了换行。。 
		}
		return;
	}
	if(a[x][y]>0) dfs(x,y+1);
	else
	{
		for(int i=1;i<=9;i++)
		{
				if(flag1[x][i]) continue;
				if(flag2[y][i]) continue;
				if(flag3[map[x][y]][i]) continue;
				flag1[x][i]=true;// true代表用过
				flag2[y][i]=true;
				flag3[map[x][y]][i]=true;
				a[x][y]=i;
				dfs(x,y+1);
				flag1[x][i]=false;// false代表没用过
				flag2[y][i]=false;
				flag3[map[x][y]][i]=false;
		}
		a[x][y]=0;//注意要把a[x][y]清零 
	}
}
int main()  
{
	for(int x=1;x<=9;x++)
		for(int y=1;y<=9;y++)
		{
			cin>>a[x][y];
			if(a[x][y]==0) continue;
			flag1[x][a[x][y]]=true;
			flag2[y][a[x][y]]=true;
			flag3[map[x][y]][a[x][y]]=true;//此格已填数 
		}
	dfs(1,1);//从第一行，第一列开始搜索 
	return 0;
}
```


------------
~~p.s.用这道题的代码稍微做一点修改可以拿到[P1074](https://www.luogu.org/problem/P1074)
70到80分。。~~

---

## 作者：清风我已逝 (赞：1)

dfs进阶水题（才3个测试点）

思路：
	
    从每一行的第一个开始搜，同时确保这一个满足条件
    
    vis1[10][10],vis2[10][10],vis3[10][10]
    
    三个标记数组
    	vis1[i][j]第i行的j数是否被使用
    	vis2[i][j]第i列的j数是否被使用
        vis3[i][j]第i组的j数是否被使用（共9组）
        

奉上代码：
```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
int a[10][10],vis1[10][10],vis2[10][10],vis3[10[10];

inline void print(){
	for(int i=1;i<=9;i++){
		for(int j=1;j<=9;j++)
			printf("%d ",a[i][j]);
		printf("\n");
	}
	exit(0);//结束程序
}

inline void dfs(int x,int y){
	if(x==9&&y==10) print();//打印输出
	if(y==10){x+=1,y=1;}//换行
	if(a[x][y]==0){	int tp=0;//特判
		for(int j=1;j<=9;j++){
		int tp1=((x-1)/3)*3,tp2=(y-1)/3,ttp=tp1+tp2;//ttp为第几组
if(vis1[x][j]==0&&vis2[y][j]==0&&vis3[ttp][j]==0)
{
vis1[x][j]=vis2[y][j]=1;a[x][y]=j;vis3[ttp][j]=1;
tp=1;dfs(x,y+1);
vis1[x][j]=vis2[y][j]=0;a[x][y]=0;vis3[ttp][j]=0;
}
		}if(tp==0) return;//判断，如果不可行，回溯
	}else dfs(x,y+1);
}
int main()
{
	for(int i=1;i<=9;i++)
		for(int j=1;j<=9;j++){
			scanf("%d",&a[i][j]);
			vis1[i][a[i][j]]=1;vis2[j][a[i][j]]=1;
			vis3[((i-1)/3)*3+(j-1)/3][a[i][j]]=1;
		}
	dfs(1,1);
}
```
代码风格奇特，请勿抄袭。

---

## 作者：强力人 (赞：1)

#本题很明显是深搜+回溯

首先定义bool型的行，列，3×3的方格（全部改为false）；

读入，最好行和列都从0~8读入（好处下面讲），读入时将输入的数置为true；

##重点来了：知道行和列怎么计算3×3的方格的序号？

###如果你用0~8读入的行和列，方格序号=3\*(行序号/3)+(列序号/3)+1！！！;

然后从（0,0）开始dfs；

深搜详情见代码内；

输出时注意要换行和打空格；

下面是AC代码。

（做完后可以试试poj2676，也是数独，不过输入输出有点不同）




```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int g[9][9];//读数用的方格
bool h[9][10]={false},l[9][10]={false},b[10][10]={false},flag=false;//行，列，3×3的方格（第一个【9】为序号第二个【10】为1~9这些数字）
void dfs(int x,int y)
{
    int f,m,n,i,j,k;
    if(flag==true)//如果已经输出了，返回就行
    {
        return;
    }
    if(x==9)//当搜到第九行时，输出（0~8输入）
    {
        for(j=0;j<9;j++)
        {
            for(k=0;k<9;k++)
            {
                printf("%d ",g[j][k]);
            }
            printf("\n");
        }
        flag=true;//置标记
        return;
    }
    if(g[x][y]!=0)
    {
        if(y+1<9)
        {
            dfs(x,y+1);
        }
        else
        {
            dfs(x+1,0);
        }
    }
    else
    {
        f=3*(x/3)+(y/3)+1;
        for(i=1;i<=9;i++)
        {
            if(h[x][i]==false&&l[y][i]==false&&b[f][i]==false)//判断
            {
                g[x][y]=i;
                h[x][i]=true;
                l[y][i]=true;
                b[f][i]=true;
                if(y+1<9)
                {
                    dfs(x,y+1);
                }
                else
                {
                    dfs(x+1,0);
                }
                g[x][y]=0;//回溯改回来
                h[x][i]=false;
                l[y][i]=false;
                b[f][i]=false;
            }
        }
    }
}
int main()
{
    int a,i,j,c,k,f,t;
    memset(h,false,sizeof(h));
    memset(l,false,sizeof(l));
    memset(b,false,sizeof(b));
    for(j=0;j<9;j++)
    {
        for(k=0;k<9;k++)
        {
            scanf("%d",&g[j][k]);
            h[j][g[j][k]]=true;//置标记
            l[k][g[j][k]]=true;
            f=3*(j/3)+(k/3)+1;
            b[f][g[j][k]]=true;
        }
    }
    flag=false;
    dfs(0,0);
    return 0;
}
```

---

## 作者：yyandy (赞：0)

### 这道题普通搜索也能过
本蒟蒻想法：记录所有的空格子的坐标到数组

然后用桶来判重

但是，粗线格怎么判重呢？

首先粗线格有九个

![](https://cdn.luogu.com.cn/upload/image_hosting/2xcqicae.png)

为了方便，我们开一个【0-3】【0-3】的数组

怎么判断坐标x1,y1在哪个粗线格里呢？

是x1/3 y1/3 里吗，不是

于是，应该调整为（x1-1）/3+1 (y1-1)/3+1

代码（满分），有解释：

```cpp
#include<iostream> 
using namespace std;
int t1[100][100],t2[100][100],t3[20][20][20],i,j,k,x1[1000],y1[1000],n=9,a[100][100];
//t1对行判重，t2对列判重,t3对粗线格判重
bool p;
inline void dfs(int b)//当前已经填好了b格
{
	int i,j;
	if (x1[b]==100&&y1[b]==100)//填完了
	{
		for (i=1;i<=n;++i){
		for (j=1;j<n;++j)
		cout<<a[i][j]<<" ";
		cout<<a[i][n]<<endl;
	}
	p=1;//找到一个正确答案
	}
	if (p) return;//如果有答案了，退出，节省时间
	for (i=1;i<=9;++i)
    //
	{
    
		if (t1[x1[b+1]][i]==0&&t2[y1[b+1]][i]==0&&t3[(x1[b+1]-1)/3+1][(y1[b+1]-1)/3+1][i]==0)
		{
		t1[x1[b+1]][i]=1;//行
		t2[y1[b+1]][i]=1;//列
		t3[(x1[b+1]-1)/3+1][(y1[b+1]-1)/3+1][i]=1;//边界
		a[x1[b+1]][y1[b+1]]=i;
		dfs(b+1);
		a[x1[b+1]][y1[b+1]]=0;
		t1[x1[b+1]][i]=0;
		t2[y1[b+1]][i]=0;
		t3[(x1[b+1]-1)/3+1][(y1[b+1]-1)/3+1][i]=0;	
		if (p)return;
		}
	}
}
int main()
{
	for (i=1;i<=9;++i)
	for (j=1;j<=9;++j)
	{
		cin>>a[i][j];
		if (a[i][j]==0)
		{
        //如果是空的，那么记录行列坐标
			++k;
			x1[k]=i;
			y1[k]=j;
            
		}
		else
		{
        //如果有数
			t1[i][a[i][j]]=1;
         //标记行
			t2[j][a[i][j]]=1;
            //标记列
			t3[(i-1)/3+1][(j-1)/3+1][a[i][j]]=1;
            //标记粗线格
		}
	}
	x1[k+1]=100;
	y1[k+1]=100;
	//边界
	dfs(0);
   //从0开始很重要，否则第一个空格会跳过
}
```


---


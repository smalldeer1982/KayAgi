# 快速求和

## 题目背景

2023-10-08 update: 新增两组 hack。

2023-12-16 update: 新增两组 hack。

## 题目描述

给定一个数字字符串，用最小次数的加法让字符串等于一个给定的目标数字。每次加法就是在字符串的某个位置插入一个加号。在里面要的所有加号都插入后，就像做普通加法那样来求值。

例如，考虑字符串`12`，做 $0$ 次加法，我们得到数字 $12$。如果插入 $1$ 个加号，我们得到 $3$，因此，这个例子中，最少用 $1$ 次加法就得到数字 $3$。

再举一例，考虑字符串`303`和目标数字 $6$，最佳方法不是`3+0+3`。而是`3+03`。能这样做是因为一个数的前导 $0$ 不会改变它的大小。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le \operatorname{len}(s)\le40$，$1 \leq n\le10^5$。

## 样例 #1

### 输入

```
99999
45
```

### 输出

```
4
```

# 题解

## 作者：kkksc03 (赞：253)

用一个数组如s[i,j]表示i到j的数值，变步长的搜索k个加号，k不断递增，判断在k个加号的情况下能否达到所要的值，若能就输出k并退出


---

## 作者：hnzzlxs01 (赞：61)

2024-1-24 update：修正了一些自己描述上的锅，感谢 [20220621Soren](https://www.luogu.com.cn/user/841638) 的指正。


2024-10-9 update：修正了一处笔误。

2024-11-7 uodate：修正了一处代码上的不稳定，感谢 [mc116](https://www.luogu.com.cn/user/1263338) 的指正。

**[题目传送门](https://www.luogu.com.cn/problem/P1874)**

想写这篇题解的原因主要是发现题解区没有大佬非常详细地解释状态转移方程是怎么推出来的，在理解时花了不少功夫。因此写一发题解！

## 题意简述
给你一个数字字符串 $s$ 和一个整数 $ret$，通过在字符串中加加号的方式将字符串中的数字相加，求出最少需要加几个加号来使字符串所代表的表达式结果为 $ret$。如果无法做到，输出 $-1$。

## 所需变量
$dp(i,s)$ 表示以第 $i$ 个数结尾，和为 $s$ 所需的最小加号数。

$num(i,j)$ 表示数字字符串 $s$ 从 $i$ 到 $j$ 的数值。

## 解题过程及思路
### 1：得出 $num$ 数组
```cpp
for (int i = 1; i <= len; i++) {
    	for (int j = i; j <= len; j++) {
        	num[i][j] = num[i][j - 1] * 10 + (s[j - 1] - '0');
    	}
}
```
这里应该很好理解。

### 2：初始化 $dp$ 数组（解释在代码中）
```cpp
memset(dp, 0x3f, sizeof(dp));// 设置 dp 的最大值（因为要找最小值）
dp[0][0] = -1;// 如果长度为 0，和为 0，不需要加加号就可以使和为 0，但第一次算会加 1，因此初始状态dp[0][0]设为 -1
```

### 3：推理状态转移方程

首先很容易发现可用的阶段为字符串 $s$ 的每一位。

因此枚举字符串 $s$ 的每一位，再枚举从 $0$ 到目标 $ret$ 的和，最后枚举从 $0$ 到 $i$ 前一位的 $j$。

到此，转移方程即可推出：

令以第 $i$ 位结尾，和为 $k$ 的最小加号数（`dp[i][k]`）为**将当前第 $j$ 位加上加号**（`dp[j][k - num[j + 1][i]] + 1`）和**第 $j$ 位不加加号**（`dp[i][k]`）的最小值。

写成公式就是下面这个样子：

$$dp(i,k) \gets \min \limits_{j < i} dp(j,k-num(j+1,i))+1$$

等等，第 $j$ 位加加号的最小值是怎么推出来的（也是我写时最大的疑惑）？

解释如下：

- 首先由于是第 $j$ 位，所以 $dp$ 的第一维填 $j$；

- 其次，由于 $k$ 加上了加号，所以应该找它的上一个状态，也就是以 $j$ 结尾，以 $k$ 减去从 $j + 1$ 到 $i$ 的值（`num[j + 1][i]`）为和的加号数（也就是 `dp[j][k - num[j + 1][i]]`）。

- 最后由于加上了加号，所以结果加上 $1$。

但如果这样写，$O(len^2ret)$ 的复杂度有可能会超时。如何优化呢？我们可以考虑**剪枝**。具体方法在下面的代码及注释中。

相应代码如下（也有注释）：
```cpp
for (int i = 1; i <= len; i++) {// 遍历字符串的每一位
    for (int k = 0; k <= ret; k++) {// 遍历和，从 0 到目标 ret
        for (int j = i - 1; j >= 0 && num[j + 1][i] <= ret; j--) {// 从后往前枚举 i 之前的加号数
        // 如果从 j + 1 到 i 的数大于指定的 ret，就跳出该层循环，避免超时
            if (k >= num[j + 1][i]) {// 如果从 j + 1 到 i 的数大于所枚举的k，就不处理
                dp[i][k] = min(dp[i][k], dp[j][k - num[j + 1][i]] + 1);
                // 以第 i 位结尾，和为 k 的最小加号数为将当前第 j 位加上加号 (dp[j][k - num[j + 1][i]] + 1) 和第 j 位不加加号 (dp[i][k]) 的最小值
                // 至于第 j 位加上加号 (dp[j][k - num[j + 1][i]] + 1) 的值为什么是这个，解释如下：
                // 首先由于是第 j 位，所以第一维填 j
                // 其次，由于 k 加上了加号，所以应该找它的上一个状态，也就是以 j 结尾、以 k 减去从 j + 1 到 i 的值再加 1 为和的加号数
                // 因此第j位的和应为 k 减去从 j + 1 到 i（从枚举的i之前的数 j 到 i ）的数字值（也就是num[j + 1][i]）
                // 最后由于加上了加号，所以结果加上 1
            }
        }
    }
}
```

### 4：得出最终状态

我们的结果应该是 $dp(len,ret)$。如果 $dp(len,ret)$ 大于最大可能的加号数（也就是 $s$ 的最大长度 $40$），说明不能让 $s$ 等于 $ret$，返回 $-1$，否则返回 $dp(len,ret)$。
```cpp
if (dp[len][ret] < 45) {
    cout << dp[len][ret];
} else cout << -1;
```

最后附上全部代码（有注释）：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int maxn = 1e5 + 5;

string s;
int ret;
int num[45][maxn];
int dp[45][maxn];
// dp[i][s]表示使用字符串前i位、和为s的最小加号数

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> s >> ret;
    int len = s.size();
    for (int i = 1; i <= len; i++) {
        for (int j = i; j <= len; j++) {
            num[i][j] = num[i][j - 1] * 10 + (s[j - 1] - '0');
        }
    }// 处理从 i 到 j 的数字为多少，很好理解
    memset(dp, 0x3f, sizeof(dp));// 设置 dp 的最大值（因为要找最小值）
    dp[0][0] = -1;// 如果长度为 0，和为 0，不需要加加号就可以使和为 0，但第一次算会加 1，因此初始状态dp[0][0]设为 -1
    // 这样可以使第一个值直接为 k 的状态为 0，也就是不加加号
    for (int i = 1; i <= len; i++) {// 遍历字符串的每一位
        for (int k = 0; k <= ret; k++) {// 遍历和，从 0 到目标 ret
            for (int j = i - 1; j >= 0 && num[j + 1][i] <= ret; j--) {// 从后往前枚举 i 之前的加号数
            // 如果从 j + 1 到 i 的数大于指定的 ret，就跳出该层循环，避免超时
                if (k >= num[j + 1][i]) {// 如果从 j + 1 到 i 的数大于所枚举的k，就不处理
                    dp[i][k] = min(dp[i][k], dp[j][k - num[j + 1][i]] + 1);
                    // 以第 i 位结尾，和为 k 的最小加号数为将当前第 j 位加上加号 (dp[j][k - num[j + 1][i]] + 1) 和第 j 位不加加号 (dp[i][k]) 的最小值
                    // 至于第 j 位加上加号 (dp[j][k - num[j + 1][i]] + 1) 的值为什么是这个，解释如下：
                    // 首先由于是第 j 位，所以第一维填 j
                    // 其次，由于 k 加上了加号，所以应该找它的上一个状态，也就是以 j 结尾、以 k 减去从 j + 1 到 i 的值为和的加号数
                    // 因此第 j 位的和应为 k 减去从 j + 1 到 i（从枚举的i之前的数 j 到 i ）的数字值（也就是num[j + 1][i]）
                    // 最后由于加上了加号，所以结果加上 1
                }
            }
        }
    }
    if (dp[len][ret] < 45) {
        cout << dp[len][ret];
    } else cout << -1;
    // 如果dp[len][ret]大于最大可能的加号数（45），说明不能让s等于ret，返回-1
    return 0;
}
```

---

## 作者：foryou_ (赞：37)

upd on 2023/12/22：修改了代码，现已通过所有 hack 数据。

---

首先定义状态：

- 令 $dp_{i,j}$ 表示前 $i$ 个数字要变成 $j$ 所需要的最少加号个数。

- 同时，我们还需要一个辅助数组：令 $num_{i,j}$ 表示 $i \sim j$ 的数字组成的数（不添加加号）。

然后进行转移。

显然可以枚举每个添加加号的位置 $i$，再枚举当前位置与上一个添加加号的位置的距离 $k$，然后枚举前 $i$ 个数要变成的数 $j$，于是易得转移方程：

$$
dp_{i,j}=\min(dp_{i,j},dp_{i-k,j-num_{i-k+1,i}}+1)
$$

朴素转移即可。

注意特判 $dp_{len,n}>len$（$len$ 表示字符串 $s$ 的长度）的情况。

时间复杂度 $O(n \times len)$。

需要注意字符串中的 $0$ 需要剔除，在全 $0$ 的情形下会影响答案。

代码：

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;

string str;
int s,n,tot;
int a[100031];
int num[55][55];
int dp[55][100031];
bool z;

signed main(){
    srand(time(0));
	cin>>str>>s;
	n=str.size();
	for(int i=0;str[i];i++){
		if(str[i]!='0') z=1;
		if(z) a[++tot]=str[i]-'0';
	}
	for(int i=1;i<=tot;i++){
		num[i][i]=a[i];
		for(int j=i;j-i<=11&&j<=tot;j++)
			num[i][j]=num[i][j-1]*10+a[j];
	}
	for(int i=0;i<=tot+1;i++)
	    for(int j=0;j<=s+1;j++)
	        dp[i][j]=0x7fffffff;
	dp[0][0]=0;
	for(int i=1;i<=tot;i++)
		for(int k=1;k<=11;k++)
			if(i>=k)
				for(int j=num[i-k+1][i];j<=s;j++)
					dp[i][j]=min(dp[i][j],dp[i-k][j-num[i-k+1][i]]+1);
	if(dp[tot][s]>tot) cout<<-1;
	else cout<<dp[tot][s]-1;
	return 0;
}
```

---

## 作者：andyli (赞：9)

设 $d_{i,j}$ 表示通过前 $i$ 个数获得 $j$ 所需最少加号数，则可以枚举转移：
$d_{k, j+x} = \min(d_{k, j+x}, d_{i,j}+1)$，其中 $i<k\le n$，$x$ 表示 $\left(i,k\right]$ 这一段字符串表示的数。

在数据未修复前 #3 需要特判掉。  

```cpp
#include "all.hpp"

int main() {
    dR(str, s);
    dR(int, m);
    int n = len(s);
    VECI(d, n + 1, m + 1, inf<int>);
    d[0][0] = -1;
    _for (i, n)
        _for (j, m + 1)
            if (d[i][j] != inf<int>) {
                int x = 0;
                _for (k, i + 1, n + 1) {
                    x = x * 10 + s[k - 1] - '0';
                    if (j + x > m)
                        break;
                    chkmin(d[k][j + x], d[i][j] + 1);
                }
            }
    if (d[n][m] == inf<int>)
        writeln(-1);
    else
        writeln(d[n][m]);
    return 0;
}
```

---

## 作者：Steve_xh (赞：4)

# 题面

[题目传送门](https://www.luogu.com.cn/problem/P1874)

**题目大意：**

给你一个字符串 $s$ 和一个整数 $n$，每次操作可以在 $s$ 的整数与整数间的空位中添加一个加号，求最少需要多少次操作可以使得最终的表达式 $s$ 运算结果为 $n$。如果无法使其变为 $n$ 则输出 $-1$。

# 思路

考虑使用深搜。枚举不同的最小加号数量，并使用一个数组 `pls[i]` 记录 $s_{i+1}$ 是否添加加号，再进行搜索。每次搜索完毕后，记录被加号分割的数字，全部加起来判断是否等于 $n$ 即可。同时，也不能漫无目的地搜，我们需要一些剪枝方法。

**剪枝一：**

因为提前确定加号数量，因此需要判断是否当前加号数量已经达到预期，避免无穷尽搜下去。（注：这个剪枝同时也是搜索最基本的剪枝。）

**剪枝二：**

搜索过程中，难免会遇到 `pls={0,0,0,...}` 或 `pls={1,1,1,...}` 的情况，在某些时候这些情况是要被排除的，因此需要进行判断。考虑传参过程中加入 `bx` 变量，若 `bx` 为 $1$，则表示后面的情况只能每一位添加加号，否则不满足预定要求。

**剪枝三：**

由于多个加号分割一个数只会让这个数变得更小，而在枚举加号数量过程中肯定是要从小到大枚举，如果搜索时间过久还没有搜到答案，那么肯定是无法到达 $n$ 的，直接输出 $-1$ 并退出程序即可。（注：这是个很玄学的剪枝，如果不加这个剪枝会超时一个点，这个人还被这个点卡了半小时。）

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n;
bool pls[45];
clock_t st;
int tonum(string n){//将字符串转换为数字
	int reans=0;
	for(int i=0;i<n.size();i++)
		reans=reans*10+(n[i]-'0');
	return reans;
}
bool dfs(int p,int now,int len,bool bx){
	if(clock()-st>=9888){//剪枝三
		cout<<-1;
		exit(0);
	}
	if(now>=len){//剪枝一
		string cut[45];
		int l=1;
		for(int i=0;i<s.size();i++){
			cut[l]+=s[i];
			if(pls[i])
				l++;
		}
		int reans=0;
		for(int i=1;i<=l;i++)
			reans+=tonum(cut[i]);
		return reans==n;
	}
	if(!bx&&dfs(p+1,now,len,s.size()-p-1<=len))//剪枝二，无需再多搜一个分支
		return true;
	pls[p]=true;
	bool reans=dfs(p+1,now+1,len,bx);
	pls[p]=false;
	return reans;
}
int main(){
	cin.tie(0)->sync_with_stdio(false);//由于要用string所以这个人就勉为其难地不用scanf和printf了
	cout.tie(0);
	cin>>s>>n;
	st=clock();
	for(int i=0;i<s.size();i++){//枚举可能的答案，i为必须要添加加号的数量
		memset(pls,false,sizeof(pls));
		if(dfs(0,0,i,i==0)){
			cout<<i;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}
```

---

## 作者：ncwzdlsd (赞：4)

设计状态：$f(i,j)$ 表示前 $i$ 个数字组成 $j$ 的最小操作数。

转移操作中需要用到一段子串表示的数，可以 $O(\text{len}^2(s))$ 预处理 $s(i,j)$ 表示区间 $[i,j]$ 表示的数。

枚举最后位置 $i$、最后一个加号的位置 $j$、要得到的数 $k$，

状态转移：
$$
f(i,k+s(i-j+1,i))=\min(f(i,k+g(i-j+1,i)),(i-j,k)+1)
$$
枚举时可以进行最优化剪枝优化时间复杂度。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

char a[50];
int n,len,f[45][100001];
ll s[50][50];

int main()
{
	cin>>(a+1)>>n;
	if(n==0&&len==40) cout<<1,exit(0);
    len=strlen(a+1);
    memset(f,0x3f3f3f3f,sizeof f);
    for(int i=1;i<=len;i++) s[i][i]=a[i]-'0';
    for(int i=1;i<=len;i++)
        for(int j=i+1;j<=len;j++)
            s[i][j]=s[i][j-1]*10+s[j][j];
    f[0][0]=-1;
    for(int i=1;i<=len;i++)
        for(int j=1;j<=i&&s[i-j+1][i]<=n;j++)
            for(int k=0;k<=n;k++)
                if(f[i-j][k]!=0x3f3f3f3f&&k+s[i-j+1][i]<=n)  
                    f[i][k+s[i-j+1][i]]=min(f[i][k+s[i-j+1][i]],f[i-j][k]+1);
    cout<<(f[len][n]==0x3f3f3f3f?-1:f[len][n]);
    return 0;
}
```

> PS：截至题解发布时，测试点 `#3` 数据仍有错误（即代码中的特判），建议管理员更改数据。

---

## 作者：fengjian (赞：4)

动归。初始时建立一个数组SUM[I,J]表示原字符串中I到J位表示的数字，J-I≤6.

用F[I,J,K]表示用前I个字符，最后一个加数长为7-J，表示出数字K的加号个数（如果不能表示则为+∞）

I≤6时，

J<>I,F[I,J,K]=F[I-1,J,K-SUM[i,j]+SUM[i-1,j]]

J=I，F[I,J,K]=min(F[I,J,K],F[I-1,X,K-SUM[i,j]]+1) X=1..I-1

I＞6时，

J<>6,F[I,J,K]=F[I-1,J+1,K-SUM[i,j+i-6]+SUM[i-1,j+i-6]]

J=6,F[I,J,K]=min（F[I,J,K],F[i-1,X,K-SUM[i,i]]+1） X=1..6

难理解的话，画一个简单的SUM数表用笔算算即可.

初始 f[0,J,0]:=0;

最后看F[length(s),1..6,n]的最小值.

循环的I=40,J=6,K<100000.实际K不可能每次都从1-100000，所以实际耗时不大.

最后注意特判.


---

## 作者：Walrus (赞：3)

2023-12-16 update：修正了自己 code 的锅，并删除了一些废话，感谢 [WRYYY](https://www.luogu.com.cn/user/333709) 的指正。

## 题意
给你一个字符串 $s$，再给你一个整数 $n$，问你可不可以通过一些操作使得这个字符串的值等于 $n$。

- 操作的定义为在此字符串中添加加号，使得其将原串分成几部分。
- 字符串的值定义为各个被分割成的子串所代表的数字和。

## 思路
看到字符串长度最多 $40$，考虑搜索。

如果直接枚举加号位置，时间复杂度会达到 $O(2^{s.size()})$，显然我们需要考虑剪枝。

- 注意到大部分搜索都会有一个**最优性剪枝**，当前添加的加号数量已经超过答案，直接跳出搜索。

这一个优化显然是不行的，我们需要想其它剪枝，观察一个数，这里以 $1919810$ 为例子。

我们尝试添加一些加号。

- $1+919810=919811$
- $19+19810=19829$
- $191+9810=10001$

观察到，这些数的和都没有原数大，所以我们得出结论。

- 添加加号后会将总和变小。

于是我们得出另一个重要剪枝：

- **如果当前字符串被加号分隔成的各个子串的和已经小于了要求的 $n$，则一定不可能再有其他方案可使当前值增大到 $n$。**

还有一个，对于一些 Hack 数据，我们可以去掉它的前导零，因为前导零不会对答案产生任何影响，直接去掉即可，希望不会有新的 Hack 数据来卡。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, ans = INT_MAX, num;
string a;
string b;
bool tp, zero; 
void dfs(string s, int x) {
    int sum = 0, k = 0;
    while (isdigit(s[k])) {
        sum = sum * 10 + s[k] - '0';
        k++;
    }
    for (int i = k; i < s.size(); i++) {
        if (s[i] == '+') {
            i++;
            num = 0;
            while (isdigit(s[i])) {
                num = num * 10 + s[i] - '0';
                i++;
            }
            i--;
            sum += num;
        }
    }
    if (sum < n)
        return;
    if(x > ans)
    	return;
    if (sum == n) {
        ans = min(ans, x);
        return;
    }
    for (int i = 1; i < s.size(); i++) {
        if (s[i - 1] != '+' && s[i] != '+') {
            string ss;
            for (int j = 0; j < i; j++) ss += s[j];
            ss += '+';
            for (int j = i; j < s.size(); j++) ss += s[j];
            dfs(ss, x + 1);
        }
    }
}
signed main() {
    cin >> a >> n;
    for(int i = 0;i < a.size();i++) {
    	if(a[i] != '0')
    		zero = 1;
    	if(zero)
    		b += a[i];
	}
    dfs(b, 0);
    if (ans > 1e9)
        puts("-1");
    else
        cout << ans;
    return 0;
}

---


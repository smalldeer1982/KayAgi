# 火炬

## 题目描述

2008 北京奥运会，你想成为四川汶川的一名火炬手，经过层层选拔，终于到了最后一关。

这一关是一道很难的题：任意给定一个正整数 $N$，求一个最小的正整数 $M$，使得 $N \times M$ 的十进制表示形式里只含有 `1` 和 `0`。


## 说明/提示

$1\le N\le 10^5$

## 样例 #1

### 输入

```
12```

### 输出

```
925```

# 题解

## 作者：Manjusaka丶梦寒 (赞：36)

既然大家都已经说过了，这题是个爆搜，那为啥要把代码写这么长啊。
没搞懂各位大佬们搜的啥？
直接把 0和1 组成的数搜出来不就好了。
要想判断是不是最优解的话，先搜0，再搜1，实在不放心排一下序。
我的代码，应该不叫简单可读吧。
```cpp
/*.........................
作者：Manjusaka
时间：2018/7/11
题目：P1988 火炬
..........................*/

#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue> 
using namespace std;
long long n,tot,a[1000000];
void dfs(long long x)
{
    a[++tot]=x;
    if(x>9e17)return;
    for(int i=0;i<=1;i++)
        dfs(x*10+i);
}
int main()
{
    scanf("%lld",&n);
    dfs(1);
    sort(a+1,a+1+tot);
    for(int i=1;i<=tot;i++)
    {
        if(a[i]%n==0)
        {
            cout<<a[i]/n;
            return 0;
        }
    }
    printf("No Solution");
}
```

---

## 作者：_cmh (赞：10)

真就简单的DFS了/fad

这种题，直接爆搜，每次分两种情况：

1.下一位是 $0$ 的。代码：$dfs(now\times10,\texttt{bits}+1);$

2.下一位是 $1$ 的。代码：$dfs(now\times10+1,\texttt{bits}+1);$

边界判断：定义 $\texttt{bits}$ ，为当前位数。如果 $\texttt{bits}==20$ ，则 $return$ 。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
long long n,minn;
void dfs(long long now,int bits){
	if(bits==20) return;
	if(now%n==0&&(now<minn||minn==0)) minn=now; 
	dfs(now*10,bits+1);
	dfs(now*10+1,bits+1);
}
int main(){
	cin>>n;
	dfs(1,1);
	if(minn) cout<<minn/n;
	else cout<<"No Solution";
    return 0;
}
```

求赞！

---

## 作者：love_saber (赞：7)

翻了半天题解，看大家没有人证明为什么一定有解，在这里补一发证明

证明：对于任意正整数$P$，都可以找到一个正整数$M$，使得$P \times M$是形如$10001$这样的每位上都只有$0$或$1$的十进制数

### 对于$3\not|\ P$

首先，对于$3\not|\ P$，$\frac{1}{P}$显然为有理数，所以其一定是有限小数，或者无限循环小数。

#### 对于$\frac{1}{P}$是有限小数

对于$\frac{1}{P}$是有限小数，$\frac{1}{P}=0.xxxx...$，所以，$\frac{1}{P}=\frac{xxxx...}{10000....}$

所以 $P\times xxxx...=10000...$，有解

#### 对于$\frac{1}{P}$是无限小数

对于$\frac{1}{P}$是无限小数，$\frac{1}{P}=\frac{m}{9...90...0}$（~~小学数学~~）



------------


$emm$,我详细写一下吧（此处是例子，神犇请跳过）

对于$\frac{1}{P}=0.21(368)$

$0.21(368)=\frac{21+0.(368)}{100}$

$0.(368)=\frac{1000*0.(368)-0.(368)}{1000-1}=\frac{368}{999}$

所以$0.21(368)=\frac{21+0.(368)}{100}=\frac{21+\frac{368}{999}}{100}=\frac{m}{99900}$


------------



所以，对于$\frac{1}{P}$是无限小数，$\frac{1}{P}=\frac{m}{9...90...0}$（小学数学）

记 $tmp=9...90...0$(就那个分母）

所以 $P\times m=tmp(9...90...0)$

$9|tmp$并且$3 \not|\ P$

所以$9|m$

所以$P\times \frac{m}{9}=1...10...0$，成立

**所以对于任意不被$3$整除的正整数$P$，都可以找到一个正整数$M$使之满足条件**

### 对于$3| P$

$P=3^{q}\times k,3\not|\ k$

对于$k$，由上述结论，我们可以找到一个$m'$，使得$k\times 
m'=tmp$

$(tmp=1...10...0)$

那么，我们把$tmp$这串数连续复制$3^q$次，形成一个新数$key$，可以证明，这个数既是$tmp$的倍数，也是$3^q$的倍数，同时只由$0$或$1$构成

#### 是$tmp$的倍数

$key=tmp\times 100...0100...01$

形如 $123123123=123\times 1001001$

#### 是$3^q$的倍数


$key/tmp=10..010..010..01$（总共有$3^q$个$1$,每个$1$之间有好多$0$）

$=(10...010...01)\times(10.....010......010......01.....)$

因为$3|(10...010...01)$所以只要证明(10.....010......010......01.....)是$3^{q-1}的倍数就行了$



------------


形如要证明$10101010101010101$是$3^2$的倍数

$10101010101010101=(10101)*(1000001000001)$

因为$3|10101$所以只要证明1000001000001是$3^{2-1}$的倍数就行了



所以$key$满足条件

**所以对于任意被$3$整除的正整数$P$，都可以找到一个正整数$M$使之满足条件**

### 综上所述

**对于任意正整数$P$，都可以找到一个正整数$M$，使得$P \times M$是形如$10001$这样的每位上都只有$0$或$1$的十进制数**

问题得证

所以不存在$No\ \ Solution$

最后贴个代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll a[1000000];

ll tot=0;
void dfs(ll x){
    a[++tot]=x;
    if(x>1e18)return;
    dfs(x*10);
    dfs(x*10+1);
}

int main(){
	ll n;
	scanf("%lld",&n);
	dfs(1);
	sort(a+1,a+tot+1);
	for(int i=1;i<=tot;i++){
		if(a[i]%n)continue;
		printf("%lld %lld\n",a[i]/n,a[i]);
		return 0;
	}
	return 0;
}
```


---

## 作者：王兴澄 (赞：7)

一道披着搜索外衣的数论题，仔细观察就会发现所有合法乘积都是某个数的二进制，因此我们只要从小到大枚举二进制第一个能够整除n的数所得的商就是正解；

PS：所有数据都有解，洛谷数据水啊；

捧上代码

```cpp
//orz zzy ccd syx fpy 
#include<iostream>  
#include<cstring>  
#include<cstdio>  
using namespace std;  
long long n;  
long long a[1000005]={0};  
bool f(long long k)  
{  
    int t=0;
    a[0]=0;  
    while(k)  
    {  
    a[++t]=k%2;  
    k/=2;  
    }  
    long long ans=0;  
    for(long long i=t;i>=1;i--)ans=ans*10+a[i];  
    if(ans%n==0){printf("%lld",ans/n);return 1;}  
    return 0;  
}  
int main(){  
    scanf("%lld",&n);  
    f(n);  
    for(long long i=1;;i++)  
    {  
        if(f(i))return 0;  
    }  
    return 0;  
}
```

---

## 作者：梦回还 (赞：6)

被楼下说准了，没错，这就是一题披着数论外衣的爆搜题。

但是……因为我比较蒟吧，我始终没想到爆搜乘积（怕崩）

事实证明，枚举完全不会炸，顶多十几位……

然后本蒟蒻~~开创了新的方法~~爆搜M！

开始想到DFS，嗯……数据好记录，搜几层才停心里没点谱

BFS可谓OK，但是第一次搜到的非最优解，70差评

干脆暴力BFS：3秒90分，最后一个点TLE，再次差评

最后，还是限制深度的好（为大佬们递代码





```cpp
#include<queue>
#include<cstdio>
#include<climits>
#include<cstring>
#include<algorithm>
#define ull unsigned long long
using namespace std;
const int N = 100005;
int n, top, deep;
ull mul[30], ans = ULONG_MAX;//防爆装置
struct Node {//结构体保留信息
    ull x; int left, step;
}a;
queue<Node> q;
void bfs() {//真诚广搜
    mul[1] = 1;
    for(int i = 2; i < 20; i++) mul[i] = mul[i - 1] * 10ll;//预处理乘积
    for(int i = 1; i <= 9; i++) 
        if((i * n) % 10 == 0 || (i * n) % 10 == 1) {
            a.left = (i * n) / 10;
            a.x = i; a.step = 1;
            q.push(a);//第一位不可能为0
        }
    while(!q.empty()) {
        Node u = q.front(); q.pop();
        if(!u.left) ans = min(ans, u.x), deep = u.step;//限制深度大法好
        if(deep && u.step >= deep) continue;
        for(int i = 0; i <= 9; i++) 
            if((i * n + u.left) % 10 == 0 || (i * n + u.left) % 10 == 1) {
                a.left = (i * n + u.left) / 10; a.step = u.step + 1; 
                a.x = u.x + (mul[a.step] * i); q.push(a);
            }
    }
    return ;
}
int main() {
    scanf("%d", &n);
    bfs();
    if(ans == ULONG_MAX) printf("No Solution");
        else printf("%lld", ans);//判断无解，清纯不做作
    return 0;
}
```

---

## 作者：Liu45318 (赞：5)

题解 P1988 【火炬】

[题目传送门~~~](https://www.luogu.com.cn/problem/P1988)

[安利一波博客~~~](https://www.luogu.com.cn/blog/LJLZS/#)

这题很多大佬都是用dfs或者枚举做的，这里想要给大家介绍一种新的方法：**构造法**

为什么呢？让我们分析一波题目：“使得N×M的十进制表示形式里只含有 1 和 0”，咱们设这个得数为S，那么这个S其实是要在极其特殊的情况下才可以满足题意要求的。所以我们如果枚举M，那么其实很多次循环都是浪费掉的，~~如果这道题目数据没那么氵~~很容易TLE

那么这个时候就要引出今天的新方法构造法啦！！！

构造法的思路和题目是刚好相反的，这题要枚举M，我们偏不，我们**枚举结果S**！！！

具体思路如下： 首先定义一个数组，用类似高精的方式做一个伪二进制数，每次将这个数加一，然后判断这个数是否可以被N整除，如果可以，那么就说明已经找到M了，输出就完了

话不多说，上代码！！！

```cpp
#include<iostream>
#include<cmath>
using namespace std;

short a[1001],l=1000; 
unsigned long long b;

int main()
{
	int n;
	cin>>n;
	
	while (1)
	{
		a[1000]++; //将s加一，继续构造
		int j=1000;
		while (a[j]==2)
		{
			a[j]=0;
			a[--j]++;
		}
		if (a[l-1]==1) l--; //进位
		
		b=0;
		for (int i=l;i<=1000;i++)
			b=b*10+a[i]; //由于数据弱，每次循环把b构造一次就行
		//cout<<b<<endl;
		
		if (b%n==0)
		{
			cout<<b/n; //输出解
			return 0;
		}
	}
}
```


---

## 作者：hmh13951417981 (赞：4)

题意：
任意给定一个正整数N求一个最小的正整数M

使得N * M的十进制表示形式里只含有1和0。

我们不妨转化为：找一个用１和０组成的能整除Ｎ的最小数Ｒ，输出Ｒ／Ｎ

于是我们要做的就是从小到大穷举十进制数Ｒ再判断能否整除

既然求最小值则类似于宽搜，对于一个数Ｒ，如果Ｒ能整除Ｎ则直接输出，否则拓展为Ｒ＊１０和Ｒ＊１０＋１，得到井然有序的序列

举例：１－＞１０　１１－＞１００　１０１　１１０　１１１　以此类推


------------


一共需要穷举多少个呢？　ｌｏｎｇ　ｌｏｎｇ　范围够大了，到２０位数字

每一位取０或１　一共能得到２^２０个数字　

为了避免卡常　可以设置到２＾２０｜３　

如果超过这个范围还没搜到，就输出无解　~~本题数据很水都有解，可安心食用~~


------------

```c
#include<bits/stdc++.h>
using namespace std;
int n,f,r;
long long q[(1<<20)|3]; 
int main()
{	cin>>n;
	q[0]=1;／／第一个数是１
	while(f<=((1<<20)|3)){
		if(q[f]%n==0){
			cout<<q[f]/n;／／能整除则直接输出
			return 0;
		}
		q[++r]=q[f]*10;
		q[++r]=q[f++]*10+1;／／拓展
	}
	cout<<"No Solution";／／无解
    return 0;
}  
```


---

## 作者：xiaozeyu (赞：4)

# 这道题目还可以，可以进制转换直接过，思路清晰

------------

### K只有0和1，所以K可以用二进制数来表示

### 所以我们只要枚举出范围内所有的带0和1的数，若%n==0，就是答案

------------

## 这道题目千万不要想多了 上代码---
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,ans,k,c[100],num;//long long定义，2进制数不会爆
int main()
{
	cin>>n;//输入
	if(n==0)//特判n=0
	{
		cout<<"1";
		return 0;
	}
	for(int i=1;i<=300000;i++)//枚举1-300000，不爆long long
	{
		ans=0,k=0,num=i;//重置
		while(num)//十进制先转二进制
		{
			ans++;
			c[ans]=num%2;
			num/=2;
		}
		for(int j=ans;j>=1;j--)//将字符串转换为长整型
			k=k*10+c[j];
		if(k%n==0)//k=N*M,k中也只有0.1，求出了M
		{
			ans=k/n;
			cout<<ans;//输出
			return 0;//直接结束
		}
	}
	cout<<"no solution";//仍未找到，输出no solution
	return 0;
}
```


---

## 作者：HoshiuZ (赞：3)

## 思路
本来的思路是错误的（无法判无解）。然后问了教练的方法。真妙。。

宽搜，初始队头为$1$，每次将队头乘$10$和乘$10$再加$1$进行拓展，若拓展到的数是$n$的倍数时，那这个就是解，将其除以$n$后输出即可。但是如何判断无解呢？

以样例为例。
首先只有队头$1$（括号内代表这个数%n的值）

![](https://cdn.luogu.com.cn/upload/image_hosting/qolj65kp.png)

然后乘$10$和乘$10$加$1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/im2avbgc.png)

没有是$n$的倍数的，于是继续拓展。队头变为$10$，继续拓展。

![](https://cdn.luogu.com.cn/upload/image_hosting/ehmbjf1q.png)

没有，继续拓展，队头变为$11$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2xo8654e.png)

没有，继续拓展，队头变为$100$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ig4hn910.png)

此刻发现，对$n$取余的值出现了重复，那么这出现重复的结点就无须向下扩展了。因为要求的是最小的$m$值，而上面有比其更小的对$n$取余为相同值得数，所以这出现重复的$1000$与$1001$两点无须入队。继续拓展，队头变为$101$。（边权为$-1$代表该点未入队）

![](https://cdn.luogu.com.cn/upload/image_hosting/rbm02ahi.png)

$1010$与$1011$对$n$取余的值为$2$和$3$，发现与上面的出现了重复，所以这两点无须入队。队头变为$110$，继续拓展。
![](https://cdn.luogu.com.cn/upload/image_hosting/y7c5asq2.png)

没有，继续拓展，队头变为$111$。

![](https://cdn.luogu.com.cn/upload/image_hosting/nk4sflgt.png)

没有，继续拓展，队头变为$1101$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jkmi2q5n.png)

重复，不入队。继续扩展，队头变为$1100$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wqpnff5a.png)

重复，不入队。继续拓展，队头变为$1110$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wosjhr4t.png)

发现$11100(0)$，于是$11100÷12=925$即为解。

将样例模拟一遍后，那么算法就显而易见了。每次拓展两个点，若为解直接存为答案，跳出搜索。若对$n$取余的值没有重复，那么就入队。因为对$n$取余的的值得个数一共就$n$个（$0$、$1$、$2$……$n-1$），所以当无解时，始终不会有取余为$0$的点，取余为其它的点被标记后，向下拓展的点遍不会入队，所以总会使得$head>tail$，也就是宽搜结束的。最后搜到了就输出，没搜到输出无解，即可。

**注意开longlong!!!**
## 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

bool vh[1000010];
long long que[1000010],n,ans=-1;

void bfs() {
	int head=1,tail=1;
	que[head]=1;
	while(head<=tail) {
		long long q_1=que[head]*10,q_2=que[head]*10+1;
		if(!(q_1%n)) {
			ans=q_1/n;
			break;
		}
		if(!(q_2%n)) {
			ans=q_2/n;
			break;
		}
		if(!vh[q_1%n]) que[++tail]=q_1;
		if(!vh[q_2%n]) que[++tail]=q_2;
		head++;
	}
}
	
int main() {
	cin>>n;
	
	bfs();
	
	if(ans!=-1) cout<<ans<<endl;
	else cout<<"No Solution"<<endl;
	
	return 0;
}
```


---

## 作者：luckydrawbox (赞：2)

在这题极水的数据下，$N\times M$ 在十进制下不会超过 $18$ 位 ~~（既然题目标签没有高精就可以大胆猜测最大没越过 long long）~~，所以只包含 $0$ 和 $1$ 的数最多只有 $2^{18}=262144$ 个，于是我们可以把这些数全部 dfs 找出来，对所有符合条件的 $M$ 取最小值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long m=1e18;//提前赋个极大值
void dfs(long long now)
{
	if(now>1e18)
		return;
	if(now*10%n==0)
		m=min(m,now*10/n);
	if((now*10+1)%n==0)
		m=min(m,(now*10+1)/n);
	dfs(now*10);
	dfs(now*10+1);
}
int main()
{
    cin>>n;
    dfs(1);
    if(m==1e18)
    	cout<<"No Solution"<<endl;
    else
    	cout<<m<<endl;
	return 0;
}
```

## 福利

[双倍经验](https://www.luogu.com.cn/problem/UVA1189)&&[三倍经验](https://www.luogu.com.cn/problem/P2841)

---

## 作者：银河AI (赞：0)

### 温馨提示
~~不开 $\sout{long}$ $\sout{long}$ 见祖宗~~

### 解题思路

看到只有 $0$ 和 $1$ 这两个数

应该很容易想到二进制

我们考虑将 $[1,10^6]$ 这个区间内的数全部转化成二进制（不要问我右端为什么是 $10^6$，要问就是以防万一开大10倍）

我们将转化成的二进制数看作为十进制数，这样就得到了只有 $0$ 和 $1$ 的数
（**千万记得开 $long$ $long$**）

然后我们判断这个数是否是 $n$ 的倍数，如果是就输出 $x/n$（x是那个二进制数）

如果都判完了还没有输出，那么就注定无解

接下来放 $AC$ 代码

### AC代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m;
int main(){
	scanf("%lld",&n);
	if(n==0){printf("1");return 0;}
	for(int i=1;i<=1000000;i++){
		ll c[1000001];
		ll s=i,len=0,x=0;
		while(s){
			c[++len]=s%2;
			s/=2;
		}
		for(ll j=len;j>=1;j--) x=x*10+c[j];
		if(x%n==0){
			printf("%lld",x/n);
			return 0;
		}
	}
	printf("No Solution");
}
```


---

## 作者：天才颓废学家 (赞：0)

## 数据jio造！

经查验，此题数据没有无解情况。这让~~擅长骗分~~的我极度不适！

[铁证](https://www.luogu.com.cn/record/41103945)

好，好，好，打住，我们进入正题。

## 题意分析及坑点

给你一个数$N$，试找出一个只含有$0$和$1$的数，使得此数与$N$相除余数等于零，输出**此数与N的商**，注意是**商**！~~然鹅不判无解也可以。~~

## 思路分析与具体实现

拿到题目的第一感觉就是暴力(事实上正解也是暴力)。从$1$做到@！*&%￥#+，第一个符合条件的数就是解。但~~显然~~这样的算法是会超时的，具体代码我也不再赘述了。

#### 如何改进呢

看到题目中“使得$N×M$的十进制表示形式里只含有$1$和$0$”，不难发现这样枚举时**枚举到的含其他数字的数都是浪费时间**如何防止这样的浪费呢？我们可以**只判断仅含0,1的数，即构造。考虑运用DFS。**
我们可以可以一位一位地构造，每做一位就判断一位，并**除第一位外先搜0，再搜1，** 这样可以保证第一个搜到的即为最小。

~~Talk is cheap,show me the code.~~`

```pascal
//大家在考场中遇到DP/结论题，一定要写对拍，不然很可能会挂qwq。
var
 n:longint;
 ans:int64;
function min(a,b:int64):int64;
begin
 if a<b then exit(a)
  else exit(b);
end;
procedure dfs(sum:int64; t:longint);
begin
 if t>19 then exit; //边界条件如果位数太长，（应该）会有其它更优解，退出（亲测，19位刚刚好）
 if (sum mod n=0) then begin ans:=min(sum,ans);  if ans=0 then ans:=sum; exit; end; //判断结果是否合法（双保险更靠谱）
 dfs(sum*10,t+1);
 dfs(sum*10+1,t+1); //双保险更靠谱
 exit;
end;
begin
 readln(n);
 ans:=0;
 dfs(1,1);
 if ans<>0 then writeln(ans div n)
  else writeln('No Solution');
end.
```

此外还有一种不用搜索的方法，对于一些不喜爱用递归的巨佬，**二进制生成法** 也是一个不错的选择，它的原理与$DFS$类似，但代码难度较高，本蒟蒻调了好久，不过它（似乎）能避免栈溢出（？）

~~Talk is cheap,show me the code.~~

```pascal
var
 a,c:array[0..30]of longint;
 n,i,j,x,k:longint;
function check:boolean;
var
 j,x:longint;
begin
 x:=0;
 for j:=20 downto 1 do 
  x:=(x*10+a[j]) mod n;
 exit(not(x=0));
end;
begin
 read(n);
 while a[20]=0 do //边界条件（哨兵）
  begin //二进制生成法
   i:=1;
   while a[i]=1 do
    begin
     a[i]:=0;
     inc(i);
    end;
   a[i]:=1; //进位
   if check then continue; //判断是否合法
   x:=0; j:=i; //记录答案
   for j:=20 downto 1 do 
    begin
     c[j]:=(a[j]+x*10) div n;
     x:=(x*10+a[j]) mod n; //用数组输出，防止爆精
    end;
  break;
 end;
 if a[20]<>0 then begin writeln('No Solution'); halt; end; //判断无解
 j:=30;
 while (c[j]=0) and (j>1) do dec(j); //判断位数
 for i:=j downto 1 do write(c[i]);
end.
```

本篇题解到此差不多就结束了，如有出锅请指正。

## $Thank\;you\;for\;your\;reading!$

%%%orz sto%%%


---

## 作者：UperFicial (赞：0)

# $dfs$

$update\ 9/27:$ 删去了一无意义内容，望管理重新审核！/kel

### 前言

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/P1988)。

题目简短，好评。

### 题目大意

给定一个正整数 $n$，求一个最小正整数 $m$，使得 $n$ 和 $m$ 的乘积的每一位只有 $0$ 和 $1$。

### 解题思路

第一个想法是暴力，暴力枚举一个 $m$，再判断乘积是否合法，但这样显然会妥妥的 $T$ 飞。

我们可以倒过来想，求一个最小的只含 $0$ 和 $1$ 的正整数并且是 $n$ 的 $m$ 倍。通俗来讲就是可以整除 $n$，商就是 $m$。

但怎么求只含 $0$ 和 $1$ 的正整数呢？我们可以把所有的只包含 $0$ 和 $1$ 的正整数全都枚举出来，挨个试，看看能否整除 $n$，商就是 $m$。

这就用到了~~暴力的~~ $dfs$。

对于一个新的 $x$，我们放在一个 $vector$ 中，之后以这个 $x$ 去拓展两个数：

- 末位加了个 $0$：其实就是 $10x$，$dfs(10\times x)$。

- 末位加了个 $1$：在 $10x$ 的基础上 $+1$，$dfs(10\times x+1)$。

递归结束条件当然就是当 $x$ 大于一个尽可能大的数时就返回。

最后把 $vector$ 中的每个元素排序，这是因为 $m$ 要求最小，自然的被除数也应该尽量的小。

但这样只能得 $30pts$：

- 再来看一眼数据范围：$n\le 10^5$——

	> $10$ 年 $OI$ 一场空，不开 $\boxed{?}\ \ \boxed{?}$ 见祖宗。
    
- 再看一眼题面：若无解输出 `No Solution`。

$Code:$

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
typedef long long ll;
ll n;
vector<ll>a;
void dfs(ll x)
{
	a.push_back(x);
	if(x>9e17)return;
	dfs(x*10);
	dfs(x*10+1);
	return;
}
int main()
{
	scanf("%lld",&n);
	dfs(1);
	sort(a.begin(),a.end());
	for(register int i=0;i<a.size();i++) 
	{
		if(a[i]%n==0) 
		{
			printf("%lld\n",a[i]/n);
			return 0;
		}
	} 
	puts("No Solution");
	return 0;
}
```
$$\texttt{The End.by UF}$$



---

## 作者：K0stlin (赞：0)

## 爆搜+优化

本来以为是数论难题，后来随便打了个暴力。。。

_思路_：
	先将n质因数中的2和5补全（分别×5 ×2），就会组成⑩，而n的质因数中没有2和5了，再进行二进制枚举剩下的n的乘积。

CODE：
```cpp
#include<cstdio>
typedef long long ll;
int n,a[1005];
ll s,ans=1;
ll f(ll x){//二进制乘积转换
	s=0;a[0]=0;
	while(x){
		a[++a[0]]=x&1;//二进制优化，相当于x%2
		x>>=1;//二进制优化，相当于x/=2
	}
	for(int i=a[0];i>=1;--i)
		s=(s<<3)+(s<<1)+1ll*a[i];//二进制优化，相当于s=s*10+1ll*a[i]
	return s;
}
int main(){
	scanf("%d",&n);
    	while(n%10==0)n/=10;//此处注意：n*10的答案与n相同。为了防止答案末尾有0，非最优，故如是。
	while(!(n&1)){ans*=5;n>>=1;}//有2补5，成10
	while(n%5==0){ans<<=1;n/=5;}//有5补2，成10
	for(ll i=1;i<=3000000;++i)//从小到大枚举由0和1组成的乘积————f(i)（此处3000000差不多是本机时间上限）
		if(f(i)%n==0){printf("%lld\n",1ll*f(i)/n*ans);return 0;}//如果f(i)可以当n的乘积，那么用另一个因数*ans即为答案。
	printf("No Solution\n");//无解（应该没有此情况）
	return 0;
}
```
-完-

---

## 作者：qytqytqy (赞：0)

这题虽然说N是小于等于十万的，但没说答案的范围啊......
所以开long long很重要！
如果这题只能想到从1开始暴搜，时间肯定会爆。

所以不能从乘的数去想。

那么我们可以自然地考虑到枚举结果。由于答案是由0和1组成的，所以只需枚举0和1，最大为18位数，时间复杂度为O（2^18），即262144，不会超时。


正确性：由于每个数由0到1枚举，所以保证组成的数也由小到大，第一个符合要求的即为最小值。

code：~~这种枚举码风极度丑陋，不喜勿喷~~
```#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long i,n,j,k,l,m,o,p,d,f,g,h,w,e,r,t,z,x,c,v;
int main()
{
	cin>>n;
	for(z=0;z<=1;z++)
	    for(x=0;x<=1;x++)
	        for(c=0;c<=1;c++)
	                for(v=0;v<=1;v++)
	                    for(w=0;w<=1;w++)
	                        for(e=0;e<=1;e++)
	                            for(r=0;r<=1;r++)
								    for(t=0;t<=1;t++)
	                                    for(d=0;d<=1;d++)
	                                        for(f=0;f<=1;f++)
	                                            for(g=0;g<=1;g++)
	                                                for(h=0;h<=1;h++)
	                                                    for(i=0;i<=1;i++)
	                                                        for(j=0;j<=1;j++)
	                                                            for(k=0;k<=1;k++)
	                                                                for(l=0;l<=1;l++)
	                                                                    for(o=0;o<=1;o++)
	                                                                        for(p=0;p<=1;p++)
	                                                                            for(m=0;m<=1;m++)
	                                                                                if((z*1000000000000000000+x*100000000000000000+c*10000000000000000+v*1000000000000000+w*100000000000000+e*10000000000000+r*1000000000000+t*100000000000+d*10000000000+f*1000000000+g*100000000+h*10000000+i*1000000+j*100000+k*10000+l*1000+o*100+p*10+m)%n==0&&(z*1000000000000000000+x*100000000000000000+c*10000000000000000+v*1000000000000000+w*100000000000000+e*10000000000000+r*1000000000000+t*100000000000+d*10000000000+f*1000000000+g*100000000+h*10000000+i*1000000+j*100000+k*10000+l*1000+o*100+p*10+m)!=0){cout<<(z*1000000000000000000+x*100000000000000000+c*10000000000000000+v*1000000000000000+w*100000000000000+e*10000000000000+r*1000000000000+t*100000000000+d*10000000000+f*1000000000+g*100000000+h*10000000+i*1000000+j*100000+k*10000+l*1000+o*100+p*10+m)/n;return 0;}//判断
	cout<<"No Solution";
	return 0;
}


---


# [NOI2011] 道路修建

## 题目描述

在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。

每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。
 
 ![](https://cdn.luogu.com.cn/upload/pic/2604.png) 

由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。


## 说明/提示

对于 $100\%$ 的数据，$1\leq a_i, b_i\leq n$，$0\leq c_i\leq10^6$，$2\leq n\leq 10^6$。
|测试点编号|$n=$|
|:-:|:-:|
|$1$|$2$|
|$2$|$10$|
|$3$|$100$|
|$4$|$200$|
|$5$|$500$|
|$6$|$600$|
|$7$|$800$|
|$8$|$1000$|
|$9$|$10^4$|
|$10$|$2\times 10^4$|
|$11$|$5\times 10^4$|
|$12$|$6\times 10^4$|
|$13$|$8\times 10^4$|
|$14$|$10^5$|
|$15$|$6\times 10^5$|
|$16$|$7\times 10^5$|
|$17$|$8\times 10^5$|
|$18$|$9\times 10^5$|
|$19,20$|$10^6$|



## 样例 #1

### 输入

```
6
1 2 1
1 3 1
1 4 2
6 3 1
5 2 1```

### 输出

```
20```

# 题解

## 作者：Melon_Musk (赞：57)

[道路修建题面](https://www.luogu.com.cn/problem/CF1219G)

## 题面描述

给出一棵树，告诉你每条边对答案的贡献为边两边联通块大小差的绝对值乘上边权，让你求出所有边的贡献之和。

如果没有听懂的话也可以继续看下面的分析。

## 分析

样例是这样的一颗树

![。](https://cdn.luogu.com.cn/upload/image_hosting/cpjndwbn.png)

可以手推一下这个例子让你更清楚的理解题意。

由于考虑每条边上的贡献仅由边权和边两边的联通块大小确定，而我们只要知道任意一边的联通块的大小，通过 n-联通块大小 即可得知另一块连通块地大小。

所以我们使用$size_i$记录以i为根的子树的大小，那么一条边上的贡献就是
$$dist_{i,j}*|size[i]-(n-size[i])|=dist_{i,j}*|size[i]*2-n|$$
直接用dfs求解即可

## 完整代码

直接按分析简单模拟即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=10000010;
ll n,cnt,ans;
ll size[maxn],head[maxn];
struct node
{
	int w,to,nt;
}e[maxn*2];
void add(int x,int y,int z)
{
	cnt++;
	e[cnt].to=y;
	e[cnt].nt=head[x];
	e[cnt].w=z;
	head[x]=cnt;
}
void dfs(int x,int fa)
{
	size[x]=1;
	for(int i=head[x];i;i=e[i].nt)
	{
		int to=e[i].to;
		if(fa==to) continue;
		dfs(to,x);
		size[x]+=size[to];
		ans+=e[i].w*abs(2*size[to]-n);
	}
} 
int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	dfs(1,0);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：一只书虫仔 (赞：22)

[P2052 [NOI2011]道路修建](https://www.luogu.com.cn/problem/P2052)

[Best watch in the blog](https://www.luogu.com.cn/blog/Shuchong/solution-p2052)

### $\text{Part 1}$ 题外话

传说中 NOI 的送分题，卡了我三天

今天才知道卡了我三天的原因是 `scanf` 没加 `&` ……（感谢二亚姐姐帮我揪出这个错误）

### $\text{Part 2 Solution}$

这题真毒瘤！居然还能卡我好几个做法！

我的第一个想法：用数组模拟链表树，从 $a$ 这一侧计数长度 $\text{tot\_a}$，从 $b$ 这一侧计数长度 $\text{tot\_b}$ ，再用公式算出 $\text{ans}$ ，然后，就有了下面的代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

struct node {
	long long val, next;
} e[1000086 * 2];

long long head[1000086], n, m, c[1000086], tot_a = 0, tot_b = 0, a[1000086], b[1000086];

void add (long long f, long long s) {
	e[++m] = (node) {s, head[f]};
	head[f] = m;
}

void dfs (long long cur, long long fa) {
	tot_a++;
	for (long long i = head[cur]; i > 0; i = e[i].next) {
		if (e[i].val == fa) continue;
		dfs(e[i].val, cur);
	}
}

int main () {
	long long n, ans = 0;
	scanf("%lld", &n);
	for (long long i = 1; i < n; i++) {
		scanf("%lld%lld%lld", &a[i], &b[i], &c[i]);
		add(a[i], b[i]), add(b[i], a[i]);
	}
	for (long long i = 1; i < n; i++) {
		dfs(a[i], b[i]);
		tot_b = n - tot_a;
		ans += abs(tot_a - tot_b) * c[i];
		tot_a = 0, tot_b = 0;
	}
	printf("%lld", ans);
	return 0;
}
```

你会发现得了 $45$ 分，[Link](https://www.luogu.com.cn/record/33493990)，TLE 了好多点。

这 很 正 常，因为看看和蔼可亲的数据范围。

所以正解应该是怎么办的呢？正解写出来比较麻烦，我就注释在我的代码里了，代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

struct node { // a node
	long long val, len, next; // value of this node, length of this node, next node of this node
} e[1000086 * 2]; // node [e]

long long head[1000086], sum[1000086], n, m, ans = 0; // root now, [sum], n, length of the tree, answer

void addEdge (long long u, long long v, long long len) {
	e[++m].next = head[u]; // son
	e[m].val = v; // value
	e[m].len = len; // length
	head[u] = m; // length of the tree
}

// addEdge : u --len-- v

void dfs (long long cur, long long father) {
	sum[cur] = 1; // report [sum]
	for (long long i = head[cur]; i; i = e[i].next) // for i to i.next
		if (e[i].val != father) { // son != father
			dfs(e[i].val, cur); // dfs again
			ans += abs(sum[e[i].val] - (n - sum[e[i].val])) * e[i].len; // calc ans
			sum[cur] += sum[e[i].val]; // calc [sum]
		}
}

// dfs the tree

int main () {
	scanf("%lld", &n); // scan
	for (long long i = 1, u, v, len; i < n; i++) { // only n - 1
		scanf("%lld%lld%lld", &u, &v, &len); // scan
		addEdge(u, v, len); // u --len-- v
		addEdge(v, u, len); // v --len-- u
	} // scan + add stop, then dfs
	dfs(1, 0); // from 1 to dfs (father is 0 because 1 doesn't have father)
	printf("%lld", ans); // print the ans
	return 0; // goodbye the code
}
```

[AC Link](https://www.luogu.com.cn/record/33558569)

### $\text{Part\ 3}$ 总结

突然发现这是我第一个 A 掉的 NOI 题，兴奋来得太突然，最后一想连 `&` 都能卡我三天，果真是我太菜。

这题主要的考点就是 **数组模拟链表树** 和 **dfs**，只要了解了树的基本概念，再加上细心，这题其实就出来了。仔细一想，还真的是 NOI 送分题。

All right，基本就是这样。

---

## 作者：Aw顿顿 (赞：10)

起先以为是一道图论，但是细细看题发现这题满足 $n$ 个点和 $n-1$ 条边且连通，那么此题需要处理的是一棵树。

## 题意概括

题目即要我们按照以下规则求出所有边的贡献之和：

$$S_{e}=|n-2\times size_v|\times w_u$$

这个式子的意义在于，每一个边的贡献，就可以严格按照题目的说明，转化为左右两边的点数之差乘上边权。


## 解法分析

由于一共有 $n$ 个点，对于某一边子树的 $size_v$ 来说，另一边显然有 $n-size_v$ 个点，也就是说两边之差实际上可以表示为：

$$|n-size_v-size_v|=|n-2\times size_v|$$

那么我们所需要做的，显然就是去找出每一个点的 $size$，在这一点上，我们考虑使用 $\texttt{DFS}$ 进行求解。同归递归进行搜索的具体的步骤如下：

- 对于每一个点，令其初始 $size$ 为 $1$，即包含自己。
- 如果目前搜索的相邻边通向儿子，那么继续下一轮的搜索，在递归后进行答案的累加。
- 用递归的结果更新当前节点的 $size$。

## 代码实现

实现的过程中注意以下几点：

- 由于是一颗树，因此建边是无向的（换言之双向的）。
- 答案可能会爆 $\texttt{long\ long}$。
- 递归不能重复搜索到自己的父亲，否则会出不来。

那么给出 AC 代码可供对拍调试使用。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1000005 
using namespace std;
int n,cnt,h[N],ans,s[N];
struct Edge{
    int v,w,nxt;
}e[N<<1];
void add(int u,int v,int w){
    e[++cnt].v=v;e[cnt].w=w;
    e[cnt].nxt=h[u];h[u]=cnt;
}void dfs(int x,int fa){
	s[x]=1;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v,w=e[i].w;
		if(v!=fa){
			dfs(v,x);
			ans+=abs(n-2*s[v])*w;
			s[x]+=s[v];
		}
	}
}signed main(){
	scanf("%lld",&n);
	for(int i=1;i<n;i++){
		int u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		add(u,v,w);add(v,u,w);
	}dfs(1,1);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：奔波儿霸 (赞：9)

#### 吐槽一下

我开了$-O2$优化结果跑的更慢了什么鬼？？？！！！

我怕不是吸了一口``毒氧气``

**不要脸的放上我的博客，欢迎大家[前来面基](http://www.cnblogs.com/bljfy/)**

#### 题目大意

给定一棵有$n$个节点的树，树中有${n-1}$条边，每条边花费的价格是这条边两侧的点的数量的差的绝对值和这条边长度的积。求这棵树的总花费。

#### 解题思路

以节点$1$作为这棵树的根节点，~~其实选哪个都可以~~从题中可以得出一个基本的结论，一条边的两边的点的数量分别等于终点节点儿子的数量$+1$和起点节点祖先的数量。我们可以通过遍历整棵树将每个节点儿子的数量预处理出来。

在预处理的同时可以进行统计。到最后输出Ans就可以

#### 附上代码

当然不能少了代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define int long long

using namespace std;

const int maxn = 1e6+3;
int n, fir[maxn], nx[maxn<<1], u[maxn<<1], v[maxn<<1], w[maxn<<1], s[maxn], Ans;
bool vis[maxn];
inline int DFS(int x, int fr) {
    if(s[x] != 1) return s[x];
    int k = fir[x];
    while (k != -1) {
        if(fr != v[k]) {
            s[x] += DFS(v[k], x);
            Ans += abs(n-2*s[v[k]]) * w[k];
        }
        k = nx[k];
    }
    return s[x];
}

main() {
    scanf("%lld", &n);
    memset(fir, -1, sizeof(fir));
    fill(s+1, s+1+n, 1);
    for(int i=1; i<=(n-1)*2; i++) {
        scanf("%lld%lld%lld", &u[i], &v[i], &w[i]);
        nx[i] = fir[u[i]];
        fir[u[i]] = i;
        u[i+1] = v[i], v[i+1] = u[i], w[i+1] = w[i];
        i++;
        nx[i] = fir[u[i]];
        fir[u[i]] = i;
    }
    vis[1] = 1;
    DFS(1, 1);
    printf("%lld", Ans);
}
```

---

## 作者：kradcigam (赞：5)

首先对于一棵树，他肯定是一个**连通图**。

所以，对于一条边 $(x,y)$，$x$ 连的节点个数 $-$ $y$ 连的节点个数 $=$ $($ $n$ $-$ $y$ 连的节点个数 $)$ $-$ $y$ 连的节点个数

因为这张图是连通的，所以**所有节点不在 $x$ 那端，就在 $y$ 那端**。

我们回到树，我们可以 $O(n)$ 的时间遍历一遍树，并求出 $size$。

大家可以看看我的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &FF) {
	T RR = 1; FF = 0; char CH = getchar();
	for (; !isdigit(CH); CH = getchar())if (CH == '-')RR = -1;
	for (; isdigit(CH); CH = getchar())FF = (FF << 1) + (FF << 3) + (CH ^ 48);
	FF *= RR;
}
const int N = 1e6 + 10;
vector<pair<int, int> >v[N];
ll sz[N], ans, n;
void dfs(int x, int fa) {
	sz[x] = 1;//求size
	for (auto i : v[x]) {
		if (i.first != fa) {
			dfs(i.first, x);
			sz[x] += sz[i.first];
			ans += 1ll * i.second * abs(sz[i.first] - (n - sz[i.first]));//上面的方法
		}
	}
}
int main() {
	read(n);
	for (int i = 1; i < n; i++) {
		int x, y, z;
		read(x); read(y); read(z);
		v[x].push_back(make_pair(y, z));
		v[y].push_back(make_pair(x, z));
	} dfs(1, 0);
	cout << ans;
	return 0;
}
```

---

## 作者：philosopherchang (赞：4)

**题目直译：**

一棵树，每条边的权值等于长度×abs（以其中一个端点为根节点的子树的节点个数-余下节点个数），求这棵树的边权值之和。

**核心代码**

随便选一个点为根节点进行dfs，每个节点的子树的节点个数等于其所有子节点的子树的节点个数之和再+1，size[u]=(for循环所有连边）size[edge[i].v]+1;在算每个节点的子树节点个数时，同时记录答案ans+=(long long)abs(size[v]-(n-size[v]))*edge[i].dis;(n-size[v])是另一个端点所连接的节点个数。

```cpp
void dfs(int u,int fa)
{
	size[u]=1;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].v;
		if(v!=fa)
		{
			dfs(v,u);
			ans+=(long long)abs(size[v]-(n-size[v]))*edge[i].dis;
			size[u]+=size[v];
		}
	}
}
```
~~乍一看有点像树p~~

完整代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int n,m,cnt,size[1000001],t,head[1000001];
long long ans;
struct node{
	int dis,next,v;
}edge[2000001];
void add(int u,int v,int w)
{
	edge[++cnt].next=head[u];
	edge[cnt].v=v;
	edge[cnt].dis=w;
	head[u]=cnt;
}
void dfs(int u,int fa)
{
	size[u]=1;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].v;
		if(v!=fa)
		{
			dfs(v,u);
			ans+=(long long)abs(size[v]-(n-size[v]))*edge[i].dis;
			size[u]+=size[v];
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n-1;i++)
	{
		int x,y,w;
		cin>>x>>y>>w;
		add(x,y,w);
		add(y,x,w);
	}
	dfs(1,0);
	cout<<ans;
}
```

---

## 作者：Manjusaka丶梦寒 (赞：4)

博客阅读戳这里：[戳我!戳我!](https://www.cnblogs.com/rmy020718/p/9416193.html)

先说一下暴力解法，既然给出了每一条边，那么我们可以每一次处理两个点的时候，当做这两个点之间的边不存在，那样的话就相当于将这个图分成了两部分，然后判断一下，某一部分的点的数量，化简一下计算代价的式子可以得出：代价=|总点数-2*某一边的点数|。

这题有一个坑：答案需要用long long类型

预计得分：``40``
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>
#include <map>
using namespace std;
#define N int(1e6+2)
#define mod 998244353
#define LL long long
LL a[N],n,T,l,r,ans;
LL x[N],y[N],z[N];
struct ahah{
    int nxt,to;
    LL dis;
}edge[N];
int head[N],tot;
void add(int x,int y,int z)
{
    edge[++tot].nxt=head[x],edge[tot].to=y,edge[tot].dis=z,head[x]=tot;
}
bool vis[N];
int dfs(int x,int sum)
{
    queue<int> que;
    que.push(x); 
    while(!que.empty())
    {
        int temp=que.front();
        que.pop(),sum++,vis[temp]=1;
        for(int i=head[temp];i;i=edge[i].nxt)
        {
            if(temp==l&&edge[i].to==r)continue;
            if(!vis[edge[i].to])que.push(edge[i].to);
        }
        
    }
    return sum;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)scanf("%lld%lld%lld",&x[i],&y[i],&z[i]),add(x[i],y[i],z[i]),add(y[i],x[i],z[i]);
    for(int i=1;i<=n;i++)
    {
        l=x[i],r=y[i];
        ans+=abs(n-2*dfs(x[i],0))*z[i];
        for(int i=1;i<=n;i++)vis[i]=0;
    }
    printf("%lld",ans);
}
```

正解：题目中说到n个点n-1条边那么自然想到这是一棵树咯，一颗无根树，我们可以给它随意定义一个根，这里定义1号为根，然后判断每个节点的子树有多少个节点(也就是说将这个点和它的父节点切断后某一侧会有多少个节点,仔细想想,是吧)。

然后通过dfs来计算每一条边的消耗代价。
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>
#include <map>
using namespace std;
#define N int(2e6+2)
#define mod 998244353
#define LL long long
LL a[N],n,T,l,r,ans;
LL x[N],y[N],z[N],siz[N];
struct ahah{
    int nxt,to;
    LL dis;
}edge[N];
int head[N],tot;
void add(int x,int y,int z)
{
    edge[++tot].nxt=head[x],edge[tot].to=y,edge[tot].dis=z,head[x]=tot;
}
bool vis[N];
int dfs(int s,int fa)
{
    vis[s]=1;
    for(int i=head[s];i;i=edge[i].nxt)
    {
        if(edge[i].to!=fa)    //不能再次向父节点连边避免重复计算。
        {
            ans+=abs(siz[1]-2*siz[edge[i].to])*edge[i].dis;        
            dfs(edge[i].to,s);
        }
    }
}
void prepare(int u,int list)
{
    for(int i=head[u];i;i=edge[i].nxt)
        if(edge[i].to!=list)     //先计算子节点含节点数目,再加上就好了。 
            prepare(edge[i].to,u),siz[u]+=siz[edge[i].to];
}
int read()
{
    int sum=0,fg=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')fg=-1;c=getchar();}
    while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}
    return sum*fg;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        siz[i]=1;        //初始时每个节点只含有自己1个 
        x[i]=read();y[i]=read();z[i]=read();
        add(x[i],y[i],z[i]),add(y[i],x[i],z[i]);
    }
    siz[n]=1;
    prepare(1,1);
    for(int i=1;i<=n;i++)
        if(!vis[i])dfs(i,i);    //判断是否重复。 
    printf("%lld",ans);
}
```

---

## 作者：Isprime (赞：3)

题目上来就是 $n$ 个国家 $n-1$ 条道路，显然是一棵树。

那我们把样例扭曲一下，变成一棵以 $1$ 为根的树。

![](https://cdn.luogu.com.cn/upload/image_hosting/k0f9il7f.png)

假如我们要求红边的费用，通过看上面这张图很容易可以发现费用就是该边边权乘以**以儿子为根的子树的总结点数和整棵树中其他结点数的差的绝对值**。其它边同理。所以只需要求出这个东西就好了。

然后进一步我们可以发现整棵树中其他结点数就是 $n$ 减去以儿子为根的子树的总结点数，所以我们现在只需要求以每个节点为根的子树的总结点数，这东西 dfs 跑一遍就好了，然后再来一遍 dfs 统计每条边的费用。

答案要开 long long.

Code

```cpp
#include <cstdio>
#include <cmath>
using namespace std;
const int MAXN=1000005;
inline int read() {
	int res=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0'; ch=getchar();}
	return res*f;
}
int n,ecnt;
long long ans=0;
int head[MAXN];
int tot[MAXN];
struct Edge {
	int next,to,dis;
}e[MAXN<<1];
inline void add(int from,int to,int dis) {
	e[++ecnt].next=head[from];
	e[ecnt].to=to;
	e[ecnt].dis=dis;
	head[from]=ecnt;
}
inline void dfs1(int x,int fa) {
	tot[x]=1;
	for(register int i=head[x];i;i=e[i].next) {
		if(e[i].to==fa) continue;
		dfs1(e[i].to,x);
		tot[x]+=tot[e[i].to];
	}
}
inline void dfs2(int x,int fa) {
	for(register int i=head[x];i;i=e[i].next) {
		if(e[i].to==fa) continue;
		ans+=abs(tot[e[i].to]-(n-tot[e[i].to]))*(long long)e[i].dis;
		dfs2(e[i].to,x);
	}
}
signed main() {
	n=read();
	for(register int u,v,w,i=1;i<n;++i) {
		u=read(); v=read(); w=read();
		add(u,v,w); add(v,u,w);
	}
	dfs1(1,0);
	dfs2(1,0);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：_ajthreac_ (赞：2)

## 0.绪论
最近有些颓废，于是就刷到了这样一道大水题……     
~~所以我就来水题解加咕值了 **（[顺便宣传博客园](https://www.cnblogs.com/juruoajh/)）**~~
## 1.解法
看到题面第一眼被吓了一下，还以为是求最优方案之类的 ~~（我果然还是太菜了）~~，不过看了第二眼就可以发现：他其实只是给出边的长度让你统计所有**边权=两端点数差$\times$边长**之和。           
可以采取简单的搜索过掉此题。         
按照正常的搜法，记录每个点的子树大小```siz[i]```，同时统计答案```ans+=abs(n-2*siz[v])*e[i].wei```。
## 2.细节
$ans$会爆$int$，注意```#define int LL```，可以自行算一下。~~（当然像我一样懒得算的也可以实践出真知）~~
## 3.代码
此处给出代码主体部分（再提醒一遍记得LL！）     
缺省源去[这里](https://www.cnblogs.com/juruoajh/p/12632444.html)找。      
```cpp
#define N 1000010
int n,ans,siz[N];
//siz[i]表示点i的子树大小（也就是这条边一端的点数） 
struct Edge {
	int to,nxt,wei;
}e[N<<1];
int head[N],cnt;
inline void ade(int u,int v,int w){
	e[++cnt].to=v;
	e[cnt].wei=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
void DFS(int now,int fa){
	siz[now]=1;
	for(rg int i=head[now];i;i=e[i].nxt){
		int v=e[i].to;
		if(v!=fa){
			DFS(v,now);
			//一条边的边权：abs(siz[v]-(n-siz[v]))*e[i].wei 
			ans+=abs(n-2*siz[v])*e[i].wei;
			siz[now]+=siz[v];
		}
	}
}
signed main(){
	Read(n);
	for(rg int i=1;i<n;i++){
		int u,v,w;
		Read(u),Read(v),Read(w);
		ade(u,v,w),ade(v,u,w);
	}
	DFS(1,0);//随便找一个点当根搜索 
	cout<<ans<<endl;
	return 0;
}
```
完结撒花~

---

## 作者：罗闻章1 (赞：2)

分析$:$
星球上有$N$个国家。在各个国家之间建设$N-1$双向道路使得国家之间连通。  
每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有$2$个和$4$个国家，如果该道路长度为$1$，则费用为$1×|4-2|=2$。
![](https://cdn.luogu.com.cn/upload/pic/2604.png)  
请对于给定的建造方案，计算出所需要的费用。
输入格式
输入的第一行包含一个整数$N$的国家的数量，国家从$1$到$N$编号。  
接下来$N-1$行描述道路建设情况，其中第$i$行包含三个整数 $a_i,b_i,c_i,$表示第$i$条双向道路修建在$a_i,b_i$两个国家之间$,$长度为$c_i$。  
对于$45\%$的数据$:2\leq N \leq10^4$  
对于$100\%$的数据$:2\leq N\leq10^6,1\leq a_i,b_i\leq N,0\leq c_i\leq10^6$

分析$:$  
因为只修$N-1$条道路,所以,它一定会连成一个树.  
又因为它一个点有可能连$10^6-1$个点,也有可能只连$1$个点,所以必须要有一种可变长度数组的数据结构.  
第一个想到的就是$vector,$但是蒟蒻不会用$.$于是就只能当一个葡萄架下的狐狸假装说$vector$很慢了ToT(好像$vector$真的很慢,没有数据结构能比他慢了)  
还有什么能模拟$vector$呢$?$
### [指针](https://www.luogu.com.cn/blog/Luo-is-LWZ080805/Adjacency-table) $!!!$
这里就选数组模拟指针了$.$  
因为我们不需要在两个边之间插入一条边,所以只需要保存头就可以了
```
       ┏━━━━┓  ┏━━━━┓
       ┃ x  ┃  ┃ x  ┃
       ┣━━━━┫  ┣━━━━┫
*head━━> to ┃┏━> to ┃┏>NULL
       ┣━━━━┫┃ ┣━━━━┫┃
       ┃*nxt┣┛ ┃*nxt┣┛
       ┗━━━━┛  ┗━━━━┛
```
但指针还是慢,最后我们用数组模拟指针来做,还有优化的空间.  
这就有了[邻接表笔记](https://www.luogu.com.cn/blog/Luo-is-LWZ080805/lin-jie-biao)里代码的方法$.$

45分做法$:O(N^2)$  
在邻接表的基础上爆搜

加一下记忆化搜索叭  
100分做法$:O(N)$
```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
using namespace std;
#define NR 1000002
#define MR 1000002
struct edge{
	int to,nxt,w;
}g[2*MR];
int gsz;
int fte[NR];
long long ans;
bool flag[NR];
int n;
void addedge(int u,int v,int w){
	g[++gsz]=(edge){v,fte[u],w};
	fte[u]=gsz;
}
int dfs(int x){
	flag[x]=1;//记忆化
	int sum=1;
	for(int i=fte[x];i;i=g[i].nxt){
		int y=g[i].to;
		if(flag[y])continue;//如果已经搜过了就跳过
		int num=dfs(y);
		ans+=1ll*abs(n-2*num)*g[i].w;
		sum+=num;
	}return sum;
}
int main(){ 
	scanf("%d",&n);
	for(int i=1;i<n;++i){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		addedge(u,v,w);
		addedge(v,u,w);
	}
	dfs(1);
	printf("%lld\n",ans);
	return 0;
}
```
最后，推广一下[博客](https://www.luogu.com.cn/blog/Luo-is-LWZ080805/)：里面有背包问题模板与一些图论的知识点，欢迎各位提高组的dalao吊打。  
吊打也是爱！
# 谢谢各位!

---

## 作者：renhr2002 (赞：1)

这道题，我最开始审题出了点问题，之后把代码完全重构了一遍。我总觉得这题思路不算难，洛谷DFS就能过。

不过，据说NOI2011赛场上写DFS会爆栈，只得75分，于是我又用BFS写了一遍，实测不开O2会TLE4个点，开O2能过，然而，即使TLE4个点变80也比DFS爆栈变75强，另外，我发现没有BFS的题解，我就来HNO3一发吧。

注意本题题意为先建树，再求解，不能用并查集一条一条地加边，那样只能得5分（只有1边，费用为0）。

1. DFS做法：随便找一点做根，向下搜索求出各个节点子树大小，顺便求出每条边的费用，因为其中一边大小是S，另一边必是N-S，所以直接求N-2S的绝对值即可。

2. BFS做法:还是随便找一根，先从根至叶求出第二次穷举的顺序，在从叶至根求子树大小、以及边的费用。

附注代码：

1. 审错题，5pts:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long
#define maxn 1024000
int n;
int fa[maxn];
ll siz[maxn];
ll ans;
void init()
{
	for(int i=1;i<=n;i++)
	{
		fa[i]=i;
		siz[i]=1;
	}
	return;
}
int find(int x)
{
	if(fa[x]==x)
	{
		return x;
	}else
	{
		siz[fa[x]]+=siz[x];
		siz[x]=0;
		return fa[x]=find(fa[x]);
	}
}
void merge(int x,int y)
{
	int fx=find(x);
	int fy=find(y);
	fa[fx]=fy;
	siz[fy]+=siz[fx];
	siz[fx]=0;
	return;
}
int main()
{
	scanf("%d",&n);
	init();
	for(int i=1;i<n;i++)
	{
		int x,y;
		ll z;
		scanf("%d%d%lld",&x,&y,&z);
		x=find(x);
		y=find(y);
		ans+=z*abs(siz[x]-siz[y]);
		merge(x,y);
	}
	printf("%lld\n",ans);
	return 0;
}
```

2. DFS版“正解”，OJ上AC，NOI2011上75pts:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long
#define maxn 1024000
int n;
struct node
{
	int to;
	int nxt;
	ll val;
}nd[2*maxn];
int head[maxn],cnt;
ll siz[maxn];
ll ans;
void init()
{
	memset(head,-1,sizeof(head));
	cnt=1;
	return;
}
void add(int x,int y,ll z)
{
	nd[cnt].to=y;
	nd[cnt].nxt=head[x];
	nd[cnt].val=z;
	head[x]=cnt++;
	return;
}
void dfs(int x,int rt)
{
	siz[x]=1;
	for(int i=head[x];i!=-1;i=nd[i].nxt)
	{
		int t=nd[i].to;
		if(t!=rt)
		{
			dfs(t,x);
			siz[x]+=siz[t];
			ans+=nd[i].val*abs(n-2*siz[t]);
		}
	}
	return;
}
int main()
{
	init();
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int x,y;
		ll z;
		scanf("%d%d%lld",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	dfs(1,0);
	printf("%lld\n",ans);
	return 0;
}
```

3. BFS版“正解”，开O2能过，不开80pts（我为了卡常数，码了快读，但依然TLE4个点）:

```cpp
// luogu-judger-enable-o2
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long
#define maxn 1024000
int n;
struct node
{
    int to;
    int nxt;
    ll val;
}nd[2*maxn];
int head[maxn],cnt;
int dep[maxn];
ll siz[maxn];
ll ans;
queue<int>q;
char str;
struct point
{
    int x;
    int dep;
    friend bool operator < (point a,point b)
    {
        return a.dep<b.dep;
    }
}po;
priority_queue<point>p;
template<class X> void read(X &x)
{
    x=0;
    int f=1;
    while(!isdigit(str))
    {
        if(str=='-')
        {
            f=-1;
        }
        str=getchar();
    }
    while(isdigit(str))
    {
        x*=10;
        x+=str-'0';
        str=getchar();
    }
    x*=f;
    return;
}
void init()
{
    memset(head,-1,sizeof(head));
    cnt=1;
    return;
}
void add(int x,int y,ll z)
{
    nd[cnt].to=y;
    nd[cnt].nxt=head[x];
    nd[cnt].val=z;
    head[x]=cnt++;
    return;
}
void bfs()
{
    q.push(1);
    memset(dep,0x3f,sizeof(dep));
    for(int i=1;i<=n;i++)
    {
        siz[i]=1;
    }
    po.x=1;
    dep[1]=0;
    po.dep=0;
    p.push(po);
    while(q.size())
    {
        int x=q.front();
        q.pop();
        for(int i=head[x];i!=-1;i=nd[i].nxt)
        {
            int t=nd[i].to;
            if(dep[t]==0x3f3f3f3f)
            {
                q.push(t);
                dep[t]=dep[x]+1;
                po.x=t;
                po.dep=dep[t];
                p.push(po);
            }			
        }
    }
    while(p.size())
    {
        po=p.top();
        p.pop();
        int x=po.x;
        for(int i=head[x];i!=-1;i=nd[i].nxt)
        {
            int t=nd[i].to;
            if(dep[t]==dep[x]+1)
            {
                siz[x]+=siz[t];
                ans+=nd[i].val*abs(n-2*siz[t]);
            }
        }
    }
    return;
}
int main()
{
    init();
    read(n);
    for(int i=1;i<n;i++)
    {
        int x,y;
        ll z;
        read(x),read(y),read(z);
        add(x,y,z);
        add(y,x,z);
    }
    bfs();
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：zhn_666 (赞：1)

    
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#define N 1000005  
#define ll long long  
using namespace std;
int n;
long long ans;
int cnt=0;//cnt 为边数 
struct edge
{
int to,len,next;//to 为起点，next为下一个点，len 为权值 
}e[N*2];//邻接表 
int size[N],last[N];   
inline void insert(int u,int v,int len)  
{  
    e[++cnt].to=v;
    e[cnt].len=len;
    e[cnt].next=last[u];
    last[u]=cnt; //存入 
    e[++cnt].to=u;
    e[cnt].len=len;
    e[cnt].next=last[v];
    last[v]=cnt;  //双向道路，正反各一遍 
```
}//邻接表的存入
```cpp
void dfs(int x,int fa)  
{  
    size[x]=1;  
    for (int i=last[x];i;i=e[i].next)  
    {  
        if (e[i].to==fa) continue;  
        dfs(e[i].to,x);  
        size[x]+=size[e[i].to];  
        ans+=(ll)e[i].len*abs(n-2*size[e[i].to]);  
    }  
}  
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
         int u,v,len;  
        scanf("%d%d%d",&u,&v,&len);
        insert(u,v,len);  
    }
    dfs(1,0);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：lwhllw (赞：1)

讲细一点的话，可以发现，每次查询的两个点必定在树上有直接点连边。那么将这一条边删去，整个树就分成两个集合，一个是被拆的节点的子树，还一个集合就是另外的节点，用dfs预处理出每个节点的儿子数量就行了。


```cpp
const maxn=100010;
var ans:int64;
    i,j,k,l,m,n,tot:longint;
    size:array[1..maxn]of longint;
    v:array[1..maxn]of boolean;
    head,first,depth,next,last,value:array[1..maxn*2]of longint;
procedure adds(x,y,val:longint);
begin
    inc(tot);
    next[tot]:=head[x];
    head[x]:=tot;
    last[tot]:=y;
    first[tot]:=x;
    value[tot]:=val;
end;
procedure init;
var i,x,y,va:longint;
begin
    readln(n);
    for i:=1 to n-1 do
    begin
      readln(x,y,va);
      adds(x,y,va);
      adds(y,x,va);
    end;
    fillchar(v,sizeof(v),true);
end;
procedure dfs(i,d:longint);
var j,k,num:longint;
begin
    v[i]:=false;j:=head[i];size[i]:=1;
    depth[i]:=d;
    while j<>0 do
    begin
      k:=last[j];
      if v[k] then
      begin
        dfs(k,d+1);
        inc(size[i],size[k]);
      end;
      j:=next[j];
    end;
end;
procedure swap(var x,y:longint);
var k:longint;
begin
    k:=x;x:=y;y:=k;
end;
procedure work;
var i,j,k,x,y:longint;
begin
    dfs(1,1);
    for i:=1 to n-1 do
    begin
      j:=i*2;
      x:=first[j];
      y:=last[j];
      if depth[x]<depth[y] then swap(x,y);
      inc(ans,abs(size[x]-(n-size[x]))*value[j]);
    end;
    writeln(ans);
end;
begin
    init;
    work;
end.

```

---

## 作者：wyqwq (赞：0)

## 蒟蒻的思路
第一眼看错题目，以为是左右两边编号的abs*w[i]，心想这就是一道大水题

写到一半发现结论里是左右两边的节点数量，思考了一下，对于任意树上边，可以在dfs的时候统计子树大小，同时根据公式 _**abs（n-size[v]-siz[v])*w[i]**_ 计算每条边的贡献，选取的根节点不失一般性

## 一点减少码量的结论
对于每一个连边（不包括父边）都可以在循环内就计算出来，因为地球人都知道乘法加法满足结合律~~（感觉我和没说一样）~~

## Solution
**蒟蒻认为与其会做一道题，不如使用一种思维方式来解决问题**

### 如何想到这样一个算法？

树？保证联通只有一种方式

答案唯一？~~（题目就是骗人）~~发现两端节点个数固定，与统计顺序无关

### 如何实现？

如何统计答案？根据公式计算

如何进行dfs？通过自下而上维护子树大小来带入公式

### 想完这些，就可以轻松AC了

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=1000003;

int n,cnt,head[maxn],siz[maxn];
struct edge{
	int next,to,w;
}e[maxn<<1];
long long ans=0;

inline int read(){
	int f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}

inline void add(int u,int v,int w){
	e[++cnt].next=head[u];
	e[cnt].to=v;
	e[cnt].w=w;
	head[u]=cnt;
}

void dfs(int now,int fz）{
	siz[now]=1;
	for(int i=head[now];i;i=e[i].next){
		int v=e[i].to;
		if(v==fz)continue;
		dfs(v,now);
		ans+=(long long)abs(n-2*siz[v])*e[i].w;
		siz[now]+=siz[v];
	}
}

int main(){
	n=read();
	for(int i=1;i<n;i++){
		int x=read（）;
		int y=read（）;
		int z=read（）;
		add(x,y,z);
		add(y,x,z);
	}
	dfs(1,1);
	cout<<ans;
	return 0;
}
```
请勿尝试直接复制提交，否则你会收获一个可爱的CE

---

## 作者：盧鋅 (赞：0)

树型结构，n个点会有n-1条边。所以每一条边都是桥emmm（没一点意义）
但是性质及其明显，这条边一边有r个点，另一边定有n-r个点，
（题目忽略两个端点，都减一即可，毫无意义）
所以很容易得出

边权=(long long)abs(size[v]-(n-size[v]))*edge[i].dis

至此证毕

解法链式前向星挂边，然后DFS一下求每个点的size（儿子数），

```
size[u]=1；
int e,v;
for(e=first[u];v=go[e],e;e=next[e]){
   if(v!=father)dfs(v,father);
   size[u]+=size[v];
}

```
~~剩下的代码懒得弄了。~~

求边权加到dfs里即可，单独拿出来for一遍应该也不会TLE。

~~这题好水~~

**别忘了开long long！！！！！**

---

## 作者：cold_cold (赞：0)

[安利一波博客](https://www.cnblogs.com/cold-cold/p/10029766.html)

每个边的实际花费费用为道路的权乘以道路两端的国家个数之差的绝对值，那么如果我们预处理每个点的子树的大小siz

通过树的遍历来遍历每一条边，因为是从我们求siz时使用的根出发，那么对于u->v的一条边，v的那一头的国家数量就是siz[v],而u的那一头的国家数量就是n-siz[v]

我们将两个数相减取绝对值abs(siz[v]-n+siz[v])，再乘以边权，就是每个边的实际花费费用

注意：不开long long 似乎要WA

总体实现如下：

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
inline int read()
{
    register int p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=1000100;
int n,u,v,w,siz[N],head[N],cnt=0;
long long ans=0;
struct EDGE{int nxt,val,to;}e[N<<1];
void add(int u,int v,int w){e[++cnt]=(EDGE){head[u],w,v};head[u]=cnt;}
void dfs(int u,int fa)
{
	siz[u]=1;
	for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(fa!=v)
	{
		dfs(v,u);
		siz[u]+=siz[v];
	}
}
void dfs2(int u,int fa)
{
	for(int i=head[u],v=e[i].to;i;i=e[i].nxt,v=e[i].to) if(fa!=v)
	{
		ans+=(abs(siz[v]-n+siz[v])*1ll*e[i].val);
		dfs2(v,u);
	}
}
int main()
{
//	freopen("input","r",stdin);
//	freopen("output","w",stdout);
	n=read();
	for(int i=1;i<n;i++)
	{
		u=read(),v=read(),w=read();
		add(u,v,w);add(v,u,w);
	}
	dfs(1,-1);
	dfs2(1,-1);
	printf("%lld",ans);
    return 0;
}
```


---

## 作者：顾z (赞：0)

水题.......(老年退役选手只能做水题压压惊。)

假设当前边的两部分的点的数量分别为$x,y$,则当我们遍历的时候

$y=size[v],x=n-size[v]$     ($v$为当前遍历到的儿子节点)

那么我们得到的就是$|n-2\times size[v]| \times w[i]$($w[i]$为当前边的边权)

注意边权要开 $long \ long$

``代码``

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define R register
#define lo long long

using namespace std;

const int gz=1e6+8;

inline void in(R int &x)
{
	R int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}

int head[gz],tot,size[gz],n;

lo ans;

struct cod{int u,v;lo w;}edge[gz<<1];

inline void add(R int x,R int y,R lo z)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	edge[tot].w=z;
	head[x]=tot;
}

void dfs(R int u,R int fa)
{
	size[u]=1;
	for(R int i=head[u];i;i=edge[i].u)
	{
		if(edge[i].v==fa)continue;
		dfs(edge[i].v,u);
		size[u]+=size[edge[i].v];
		ans+=(lo)(abs(n-2*size[edge[i].v])*edge[i].w);
	}
}

int main()
{
	in(n);
	for(R int i=1,x,y;i<n;i++)
	{
		lo z;
		in(x),in(y),scanf("%lld",&z);
		add(x,y,z),add(y,x,z);
	}
	dfs(1,0);
	printf("%lld\n",ans);
}
```



---

## 作者：大表哥 (赞：0)

数据略水，dfs版本


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define LOCAL
//记得加符号LOCAL 
using namespace std;
const int MAX=1000000;
int node[MAX+100],to[MAX*2+100],W[MAX*2+100],next[MAX*2+100],p=1;//邻接表
int sontree[MAX+100];//以各节点为根的子树大小
int fa[MAX+100];//顺便记下父亲 
int getint(){
    char ch = getchar(); int x = 0;
    while (ch < '0'|| ch > '9') ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x;
```
}//读入优化

void putint(long long x){

    if (x > 9) putint(x / 10);

    putchar(x % 10 + '0');

}//输出优化


```cpp
void ins(int a,int b,int c)
{
    next[p]=node[a]; node[a]=p; to[p]=b; W[p]=c;
    p++;
```
}//加入一条边

```cpp
int getstree(int x,int f)
{
    int a=node[x];
    while(a){
        if(to[a]!=f){
            fa[to[a]]=x;
            sontree[x]+=getstree(to[a],x);
        }
        a=next[a];
    }
    sontree[x]++;
    return sontree[x];
```
}//求子树大小（顺带记父亲）

```cpp
int main()
{
    #ifdef LOCAL
    freopen("balance.in","r",stdin);
    freopen("balance.out","w",stdout);
    #endif
    int n;
    n=getint();
    int a,b,c;
    for(int i=0;i<n-1;i++)
    {
        a=getint(); b=getint(); c=getint();
        ins(a,b,c); ins(b,a,c);
    }
    getstree(1,1);
    long long ans=0;
    for(int i=1;i<=n;i++)
    {
        a=node[i];
        while(a){
            if(to[a]!=fa[i]){
                b=sontree[to[a]];
                c=n-b;
                ans+=abs(b-c)*W[a];
            }
            a=next[a];
        }
    }
    putint(ans);
    return 0;
}
```

---


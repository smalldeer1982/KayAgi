# 增进感情

## 题目背景

小明和小红的感情，是慢慢发展起来的。


## 题目描述

他们对对方分别有一个好感值。定义两人的亲密程度为两人的好感值之和。

如果他们的亲密程度达到 $v$，则他们将走到一起。他们以后的生活将取决于两人的好感值之差的绝对值，这个值越小，他们的生活将越幸福。

现在，他们对对方的好感值都为 $0$，小明有 $n$ 件事可以干，每件事可以增加他对小红的好感 $a_i$ 点，并且增加小红对他的好感 $b_i$ 点。（可能为负数）

小明可以任选一些事做，请你帮小明求出怎样才能让他们的生活更加幸福（求出两人在一起的前提下，好感值之差的最小绝对值即可）。


## 说明/提示

#### 数据范围与约定

- 对于 $20\%$ 数据，保证 $n  \le 10$。
- 对于 $100\%$ 数据，保证 $1 \le n \le 30$，$1 \le \left\vert a_i\right\vert,\left\vert b_i\right\vert \le 100$。

## 样例 #1

### 输入

```
4 15
5 6
-1 8
7 2
1 0
```

### 输出

```
3```

# 题解

## 作者：defense (赞：29)

### 说好数据弱的呢？！QWQ
这道题是一道暴搜题。但如果不剪枝，只能拿20分（被“数据比较弱”欺骗）
* 主要思路:记录每一次做掉事情，加上去！
* 剪枝1：当Minn已经最小的时候，就不需要再搜索了，即 $abs(xiaoming,xiaohong)=0$(~~如果这个不知道建议初中重读~~)
* 剪枝2：应为我的题解用了一个数组记录选与不选，随意改选的在前面已经选过了，不需要循环再跑一遍，所以可用一个变量记录上次搜索到的位置，这样就可以避免重复。
### ~~管理员大大最帅了！！！！~~
看我讲那么详细，让我过呗！
#### code：
```
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int m,v,a[30],b[30],minn=100000,ga,gb;//m,v，a,b如题意，minn纪录最小值，ga,gb分别记录两人的好感
bool used[30];//判断是否做过这件事
void dfs(int deep){//deep记录上次搜索的位置
	if(ga+gb>v){//如果可以在一起
		minn=min(abs(ga-gb),minn);//更新值
	}
	if(minn==0){//最小极值
		return;
	}
    for(int i=deep;i<m;i++){//开始搜索！
    	if(used[i]==0){//没做过
    		used[i]=1;//设为做过
    		ga+=a[i];//加！！
    		gb+=b[i];
    		dfs(i+1);//继续搜！！！
    		ga-=a[i];//减！！
    		gb-=b[i];
    		used[i]=0;//回溯
		}
	}
}
int main(){
	scanf("%d%d",&m,&v);
	for(int i=0;i<m;i++){
		scanf("%d%d",&a[i],&b[i]);
	}
	dfs(0);
	if(minn==100000){//永远无法在一起（出题人太狠毒了）
		printf("-1");
		return 0;
	}
	printf("%d",minn);
	return 0;//功德圆满
}
```
### ~~管理员大大最帅了！！！！~~


---

## 作者：封禁用户 (赞：6)

爆搜最香了。

感觉有点像01背包（？

对于每件事，我们可以选择干或者不干，如果干就将好感值处理一下，当所有的事都搜完之后，记录最小值$minn$ 。

最终答案就是$minn$ 了。

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
int a[105],b[105],n,v,minn=1e9;
void dfs(int x,int y,int k)
{
	if(minn==0)
    	return ;//
    if(k>n)
    {
        if(x+y>=v)
            minn=min(minn,abs(x-y));
        return;//搜完了，就记录minn
    }
    dfs(x+a[k],y+b[k],k+1);//取
    dfs(x,y,k+1);//不取
    return ;
}
int main()
{
    scanf("%d%d",&n,&v);
    for(int i=1;i<=n;++i)
        scanf("%d%d",&a[i],&b[i]);
    dfs(0,0,1);//一开始好感值都是0
    if(minn<1e9)
        printf("%d\n",minn);
    else
        printf("-1\n");
    return 0;
}
```

---

## 作者：Eraine (赞：4)

# 1 题目简介
[P2080 增进感情](https://www.luogu.com.cn/problem/P2080)

**题目大纲**

小明有 $n$ 件事情可以做。第 $i$ 件事情 $a_{i}$ 和 $b_{i}$ 分别表示做了这件事情之后小明对小红的好感度和小红对小明的好感度。做了第 $i$ 件事情，它们的亲密程度将加上 $a_{i}$ 和 $b_{i}$ 。小明对小红的总好感度为做的每件事情小明对小红好感度之和。小红对小明的总好感度为做的每件事情小红对小明好感度之和。小明希望能在亲密程度 $≥v$ 的基础上，使对对方的好感度之和的绝对值的差最小。

**题目难度**
内容（搜索->深度搜索优先）|实际难度
:-:|:-:
思路难度|乙
DFS难度|丙
剪枝难度|戊
总难度|丙
# 2 思路分析
这一题，用的是一个常规的思路——DFS（深度搜索优先）。那，如何DFS呢？

**思路分析**

注意到了原题中“小明有 $n$ 件事可以干”说明，对于任意一件事情，只能有两种状态，即干，或者不干。诶，由以上的推导，我们想到，既然每件事情有2种情况，那我岂不是只要把所有的可能都枚举一遍，就可以啦？！思路固然没错。怎么枚举呢？其实啊， $n$ 件事，我们可以用分治的思想，每一个DFS的结点即是操控某一个状态（或者说，某一件事的某一个状态）。还有，他需要求的是差的绝对值的最小值，并且和 $≥v$ 。所以，我们每次取最小值的时候，需要在前面判断和是否大于等于 $v$ ，然后差取绝对值与当前最小值作比较。若比当前最小值还来的小，则最小值改成绝对值，否则，执行下一步骤。在这里需要注意的是：判断后面不能加上 $return;$ 。因为如果当前节点执行这一步操作完毕，则需要执行下一个节点，并不是像一般的取最小值的操作，因为一般取最小值，都要等到最后一个节点执行完毕才取最小值。而这个不一样。因为我们看到数据范围 $1≤n≤30$ ，这种代码的时间复杂度为 $O(2^{n})$ ，容易超时。这个剪枝会在后面讲到。接下来就是分治。很简单，利用分治的思想，把当前事情未做和当前事情有做两种情况枚举出来。简单吧
***
**前置变量**

先解释一下，这些变量是什么含义。
变量|性质|含义
:-:|:-:|:-:
$n$|全局 $int$ 变量|有几件事
$w$|全局 $int$ 变量|题目中的 $v$
$a$|全局 $int$ 数组|储存每件事的 $a_{i}$ 和 $b_{i}$
$minx$|全局 $int$ 变量|最小值
$v$|$search-dfs$ $int$ 变量|当前选择第几件事
$sum$|$search-dfs$ $int$ 变量|选择的事情当前之和
$cha$|$search-dfs$ $int$ 变量|选择的事情当前之差的绝对值
**DFS**

首先先来一波DFS的函数
```cpp
	if(sum>=w){//当和大于w时
		minx=min(minx,abs(cha));//储存最小值
	}
	if(v>n)return;//难道还要做这n件事以外的事情吗
	search_dfs(v+1,sum,cha);//这件事情没做
	search_dfs(v+1,sum+a[v][0]+a[v][1],cha+a[v][0]-a[v][1]);//这件事情做了
```
**剪枝**

这里的剪枝很简单，也很重要。就是当 $minx == 0$ 时，就没有必要在重复了。 
# 3 AC代码

```cpp
#include<iostream>
using namespace std;
long long n,w,a[36][2],minx;
inline long long abs(int v){return v>=0?v:-v;}
inline void search_dfs(long long v,long long sum,long long cha){
	if(minx==0)return;//剪枝1
	if(sum>=w){//当和大于w时
		minx=min(minx,abs(cha));//储存最小值
	}
	if(v>n)return;//难道还要做这n件事以外的事情吗
	search_dfs(v+1,sum,cha);//这件事情没做
	search_dfs(v+1,sum+a[v][0]+a[v][1],cha+a[v][0]-a[v][1]);//这件事情做了
}
int main(){
	cin>>n>>w;
	minx=2000500000;
	for(int i=1;i<=n;i++)cin>>a[i][0]>>a[i][1];
	search_dfs(1,0,0);
	if(minx!=2000500000)cout<<minx;//有可执行法案
	else cout<<-1;//无可执行方案
	return 0;
}
```


---

## 作者：Sea_Level (赞：4)

### 说好的数据弱呢？

这道题是一个练习dfs的好题，只要加一些剪枝就可以了。但是不加剪枝就会TLE。

#### 思路：

搜索，如果感情大于v就和之前的最小感情差比大小，然后搜索没有做过的事情，一个个去搜索。

奉上代码：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,v,ans=0x7ffffff,xm[50],xh[50],vis[100],suma=0,sumb=0;//xm，xh，n，m，如题意，ans是两人感情的最小差值，vis用来记录是否做过这件事，suma和sumb分别记录小明和小红对对方的好感值（待会搜索要用）。
void dfs(int asdf){//asdf是上次搜索到的事件的位置（是第几件事）
	if(suma+sumb>v){//如果互相的好感值大于v
		ans=min(abs(sumb-suma),ans);//算出最小的差值
	}
	if(ans==0){//如果已经是0了那就不能再减了，所以直接return。（不加这个就TLE一个点）
		return ;
	}
	for(int i=asdf;i<=n;i++){//从上次搜索的位置开始循环，这样会省很多时间。
		if(vis[i]==0){//如果没做过这件事
			vis[i]=1;//把它变成做过
			suma+=xm[i];//加上对对方的好感值
			sumb+=xh[i];
			dfs(i+1);//继续搜索
			suma-=xm[i];//回溯，减掉
			sumb-=xh[i];
			vis[i]=0;//再变成没做过
		}
	}
} 
int main(){
	cin>>n>>v;
	for(int i=1;i<=n;i++){
		cin>>xm[i]>>xh[i];
	}
	dfs(0);//从0开始，不能从1开始，因为小明不一定一定要做第一件事。
	if(ans==0x7ffffff){//如果还是0x7ffffff（0x7ffffff是int的最大值）
		cout<<-1<<endl;//说明不能在一起，输出-1
	}else{//如果可以在一起
		cout<<ans<<endl;//输出最小差值
	}
	return 0;//功德圆满，华丽结束
}
```


---

## 作者：Laser_Crystal (赞：3)

### 暴力出神马来着……
这道题我第一眼看到就想到了dfs，但是今天刚好是我小学信息老师的生日，所以我用一下他教我的方法

总的思路就是二进制模拟，把n件事看成长度为n的二进制序列，然后进行累加，每加一次总的情况就改变一次，所以这个效率是O（n²）的，但剪剪枝也能过

放代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,v;
int a[40],b[40],f[40];
int p,q,ans;
int main()
{
  ans=210000000;
  scanf("%d%d",&n,&v);
  for(int i=0; i<n; i++)
    scanf("%d%d",&a[i],&b[i]);
  memset(f,0,sizeof(f));
  while(f[n]==0)//这个就是二进制模拟啦
  {
    f[0]++;//在最低位累加
    for(int i=0; i<n; i++)//就像我们平时搞二进制是一样的啦
    {
      f[i+1]+=f[i]/2;
      f[i]%=2;
    }
    if(f[n]) break;//特判（不加的话每次输出0）
    p=q=0;
    for(int i=0; i<n; i++)
      if(f[i])//增加好感（这出题人……虐狗ing）
      {
        p+=a[i];
        q+=b[i];
      }
    if((p+q)>=v)
      if(abs(p-q)<ans)
        ans=abs(p-q);
    if(ans==0)//剪枝
    {
      cout<<0;
      return 0;
    }
  }
  if(ans==210000000) cout<<-1;//哈哈哈如果他们不在一起
  else cout<<ans;
  return 0;
}
```
最后再聊聊，这题目背景让我这只单身蒟蒻深感不安啊（做个题目还要被塞狗粮）

---

## 作者：Juvenile (赞：3)

## **只能说这道题很水，看到马上~~dfs暴力~~**

都说了数据比较弱。。。~~无语~~

但如果你不判mn==0时return的情况 ——恭喜TLE

二话不说上代码


------------
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[31][2];//用二维数组来存小明,小红当前做事能获得的好感度
int n,v;
int mn=1e9;//死命往大里开
//不嫌麻烦abs函数可以自己写一个
void dfs(int cur,int s1,int s2)
{
	if(mn==0) return;
    if(cur>n)
    {
        if(s1+s2>=v && abs(s1-s2)<mn)
            mn=abs(s1-s2);
        return;
    }
    dfs(cur+1,s1+a[cur][1],s2+a[cur][2]);
    dfs(cur+1,s1,s2);
}

int main()
{
	cin>>n>>v;
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i][1],&a[i][2]);
	dfs(1,0,0);
	if(mn!=1e9) cout<<mn<<endl;//判断是否有解
	else cout<<"-1";
	return 0;
}
```


------------
### ~~最后声明，本人只是蒟蒻一枚~~


---

## 作者：MY（一名蒟蒻） (赞：2)

这题是一道比较裸的DFS，适合用来练习DFS。

对于每一件事，窝们有做和不做两种选择，分别搜索。比较**好感值达到v时**，minn的**最小值**，因为**任意数的绝对值大于等于0**（~~布吉岛建议翻翻初一上学期数学书~~），所以如果minn == 0就可以直接返回啦。

具体注释详见代码。

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
int za,zb,a[40],b[40],n,v,minn=99999999,book[40]; 
void dfs(int step)
{
	if(za+zb > v) {minn=min(abs(za-zb),minn);}//大于v，比较最小值
	if(minn == 0) return ;//等于0返回
	for(int i=step;i<n;i++)
	{
		if(book[i] == 0)//没使用过
		{
			book[i]=1;//标记
			za+=a[i];//加上好感值
			zb+=b[i];
			dfs(i+1);//继续搜索
			book[i]=0;//回溯
			za-=a[i];
			zb-=b[i];
		}
	}
}
int main()
{
//	freopen("work.in","r",stdin);freopen("work.out","w",stdout);
	scanf("%d %d",&n,&v);
	for(int i=0;i<n;i++) scanf("%d %d",&a[i],&b[i]);
	dfs(0);
	if(minn == 99999999) printf("-1");//如果好感值达不到v
	else printf("%d",minn);//达到输出minn
//	fclose(stdin);fclose(stdout);
	return 0;
}
```

---

## 作者：违规用户名U56916 (赞：2)

话说这道题我交了20多遍生生把AC率降到1/3以下~~悲哀~~

这道题我用了背包的思想

费用是他们这件事贡献之和，价值对一个人的贡献减去另一个人的贡献

然后优化一下在DP过程中只要找到了零直接输出

AC代码如下
```
#include<bits/stdc++.h>
using namespace std;
int f[100001],tot;
struct A{
    int w,v;
}a[101];
bool cmp(A i,A j){
    return i.w>j.w;
}
int main(){
    int N,V,ans=0x3f3f3f;
    cin>>N>>V;
    for(int i=1;i<=N;i++){
        int c,b;
        cin>>c>>b;
        a[i].v=b-c;
        a[i].w=c+b;
        if(c+b>0) 
        tot+=a[i].w;
    }
    if(tot<V) {cout<<"-1";return 0;}
    memset(f,0x3f3f3f,sizeof(f));
    f[0]=0;
    sort(a+1,a+N+1,cmp);
    for(int i=1;i<=N;i++){
        for(int j=tot;j>=a[i].w;j--){
            if(abs(f[j-a[i].w]+a[i].v)<abs(f[j])){
                 f[j]=f[j-a[i].w]+a[i].v;
                 if(f[j]==0&&j>=V){
                     cout<<"0";
                     return 0;
                 }
            }
        }
    }
    for(int i=V;i<=tot;i++){
         if(abs(f[i])<ans) ans=abs(f[i]);
    }
    if(ans==0x3f3f3f) cout<<"-1";
    else cout<<ans<<endl;
    return 0;
} 
```

最后说一句这题干对单身狗的我很虐啊！！！！！！！

---

## 作者：Cult_style (赞：1)

## 算法：$DFS$+剪枝
用不着什么高级的剪枝，直接判断如果已经为最好情况（好感之差为0）就$return$就行了。

$DFS$思路：

每次传递一个参数$x$,表示当前为第几个数。

分两种情况：
- 选第$x$个操作
- 不选第$x$个操作

如果选，那么小明对小红的好感值加$a_x$,小红对小明的好感值加$b_x$,然后就递归：$DFS(x+1)$

不选的话，直接递归：$DFS(x+1)$

思路就是这样，代码如下：

```
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define maxn 35
using namespace std;
int n,c;
int a[maxn],b[maxn];
int ans=inf,sum[3];
void dfs(int x){
	if(sum[1]+sum[2]>c){
		ans=min(ans,abs(sum[1]-sum[2]));
	}
	if(x>n||ans==0){
		return;
	}
	sum[1]+=a[x];
	sum[2]+=b[x];
	dfs(x+1);
	sum[1]-=a[x];
	sum[2]-=b[x];
	dfs(x+1);

}
int main(){
	scanf("%d%d",&n,&c);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);
	}
	dfs(1);
	if(ans!=inf)printf("%d",ans);
	else puts("-1");
	
	return 0;
}
```



---

## 作者：UperFicial (赞：1)

# 水 $dfs$

快 $NOIp$ 了，一面写写题解增加 $rp$，一面练练搜索放爆 $0$。

**题目大意**

有 $n$ 件事，第 $i$ 件事可以让小明获得 $a_i$ 点好感，让小红获得 $b_i$ 点好感，问做了任意件事后是否可以让小明和小红的好感度之和 $\ge v$？若可以，输出好感度最小差值。

**题目做法**

为了方便，我们设小明的好感度为 $sum_a$，小红的好感度为 $sum_b$。

考虑第 $i$ 件事，它有两种选择：

- 不肝。

- 肝。

如果是不肝，那么就直接考第 $(i+1)$ 件事儿就行了；

如果要肝，那么第 $i$ 件事儿就可以让 $sum_a+a_i,sum_b+b_i$。

当这一轮肝完了，根据题意要判断 $sum_a+sum_b$ 与 $v$ 的大小，如果可以，那么将最终答案 $ans$ 与这一轮的贡献 $\mid sum_a-sum_b \mid$ 之间取最小值，最后的最小差值就是 $ans$。

而 $n\le 30$ 的数据范围又在预示这我们明显是个爆搜题。

$dfs$ 有 $3$ 个参数：

- $i$：目前到了第 $i$ 件事。

- $sum_a$：小明的好感度。

- $sum_b$：小红的好感度。

递归边界为 $i>n$，这是因为只有当第 $n$ 件事也搞完的时候才能判断好感度之和与 $v$ 的关系。

然而，当我信心慢慢地提交上去：$100pts\to90pts$，$T$ 了一个点。

没事儿，开 $O(2)$ 吸个氧！$90pts\to 90pts$，还是 $T$ 了/kk。

接着，便发现可以剪枝！
 
如果目前的 $ans$ 已经是最小值 $0$ 时，往后的搜索已经没有意义，因为已经找出了最小值！

----

$AC$ 记录：[$\mathcal{Link}$](https://www.luogu.com.cn/record/38227338)。

$Code:$

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=40;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
}
int n,v,a[MAXN],b[MAXN],ans=1e9;
int abs(int x)
{
	if(x<0) x=-x;
	return x;
}
void dfs(int i,int sum_a,int sum_b)
{
	if(i>n)
	{
		if(sum_a+sum_b>=v) ans=min(ans,abs(sum_a-sum_b));
		return;
	}
	if(!ans) return;
	dfs(i+1,sum_a,sum_b);
	dfs(i+1,sum_a+a[i],sum_b+b[i]);
	return;
}
int main()
{
	n=read(),v=read();
	for(register int i=1;i<=n;i++) a[i]=read(),b[i]=read();
	dfs(1,0,0);
	if(ans==1e9) puts("-1");
	else printf("%d\n",ans);
	return 0;
}
```

$$\texttt{The End.by UF}$$

---

## 作者：zhzzhzzzz (赞：1)

翻翻日历，距离 $NOI\space Online\space Round\space 2\space$还有一个周左右。。。

~~赶快练练暴搜，万一再爆零就不好看了QAQ~~

智颓么了，那随机跳吧

嗯？增进感情，~~看起来棒极了我没女票~~

那就让我这个无关紧要人等说说这道乱七八糟的暴搜吧！

首先先上70pts代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() //随手快读好习惯
{
    int x = 0, f = 1;
    char ch = getchar();
    if (ch == '-')
        ch = getchar(), f = -1;
    while (ch < '0' || ch > '9')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}
int n, v;
int minn = 998244353; //虽然不知道怎么回事反正就它了
int things[31][2];    //记录小明小红这对**做当前事情时能获得的好感值
void dfs(int now, int love_xm, int love_xh)
{
    if (now > n)//如果做够了n件事
    {
        if (love_xm + love_xh >= v && abs(love_xm - love_xh) < minn)//根据题意写表达式
            minn = abs(love_xm - love_xh);//更新最小绝对值
        return;
    }
    dfs(now + 1, love_xm + things[now][0], love_xh + things[now][1]);//继续做下去
    dfs(now + 1, love_xm, love_xh);//这件事不做了，类似01背包转移
}
int main()
{
    n = read(), v = read();
    for (int i = 1; i <= n; i++)
        things[i][0] = read(), things[i][1] = read();
    dfs(1, 0, 0);
    if (minn != 998244353)//如果最小值改变
        printf("%d\n", minn);//就输出最小值
    else
        puts("-1");//连变没变肯定就是没成
    return 0;
}
```

期望得分100pts，实际70pts

我****。。

直到看到题解里某位神仙说：

>注意如果最小值为 $0$ 的时候你不退出，就会喜提 **TLE**

为什么呢？因为绝对只具有非负性啊！！！

再来一遍\爆筋\爆筋

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read() //随手快读好习惯
{
    int x = 0, f = 1;
    char ch = getchar();
    if (ch == '-')
        ch = getchar(), f = -1;
    while (ch < '0' || ch > '9')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}
int n, v;
int minn = 998244353; //虽然不知道怎么回事反正就它了
int things[31][2];    //记录小明小红这对**做当前事情时能获得的好感值
void dfs(int now, int love1, int love2)
{
    if (minn == 0)
        return;
    if (now > n)//如果做够了n件事
    {
        if (love1 + love2 >= v && abs(love1 - love2) < minn)//根据题意写表达式
            minn = abs(love1 - love2);//更新最小绝对值
        return;
    }
    dfs(now + 1, love1 + things[now][1], love2 + things[now][2]);//继续做下去
    dfs(now + 1, love1, love2);//这件事不做了，类似01背包转移
}
int main()
{
    n = read(), v = read();
    for (int i = 1; i <= n; i++)
        things[i][1] = read(), things[i][2] = read();
    dfs(1, 0, 0);
    if (minn != 998244353)//如果最小值改变
        printf("%d\n", minn);//就输出最小值
    else
        puts("-1");//连变没变肯定就是没成
    return 0;
}
```

期望100pts，实际80pts

我就很纳闷，为什么会WA两个点呢？。。

于是随手把快读删了改成scanf。

~~草A了~~

~~随手快读不是好习惯*~~

AC代码奉上：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, v;
int minn = 998244353; //虽然不知道怎么回事反正就它了
int things[31][2];    //记录小明小红这对**做当前事情时能获得的好感值
void dfs(int now, int love1, int love2)
{
    if (minn == 0)
        return;
    if (now > n)//如果做够了n件事
    {
        if (love1 + love2 >= v && abs(love1 - love2) < minn)//根据题意写表达式
            minn = abs(love1 - love2);//更新最小绝对值
        return;
    }
    dfs(now + 1, love1 + things[now][1], love2 + things[now][2]);//继续做下去
    dfs(now + 1, love1, love2);//这件事不做了，类似01背包转移
}
int main()
{
    scanf("%d%d", &n, &v);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &things[i][1], &things[i][2]);
    dfs(1, 0, 0);
    if (minn != 998244353)//如果最小值改变
        printf("%d\n", minn);//就输出最小值
    else
        puts("-1");//连变没变肯定就是没成
    return 0;
}
```

最后附艰辛历程QAQ

![](https://cdn.luogu.com.cn/upload/image_hosting/2zcr3ek9.png)

---

## 作者：SKTT1Faker (赞：1)

这道题是深搜。（一开始我还真没看出来）

由于数据比较水，那就暴力吧。当然，可以加几个小优化（代码中会提到）；

每种事情可以有两种状态，干了和不干

我们从第一件事开始，一步步搜下去








```cpp
var
  a,b,i,ans:longint;
  marray:boolean;      //这是是否可以达到在一起的程度（一脸坏笑）
  n:array[1..30] of boolean;
  m:array[1..30,1..2] of longint;
procedure dfs(x,y,z:longint);
var
  k:boolean;
  love:longint;
begin
  k:=false;       //这个是是否在当前状态可以在一起
  if x+y>=b then
  begin
    k:=true;
    marray:=true;
  end;
  love:=abs(x-y);
  if k then
  begin
    if love=0 then         //小优化，0是最小的好感度差的绝对值
    begin
      write(0);
      halt;
    end;
                   // 本来我在这里加一个如果ans<love就退出的剪枝，可后来是错的，因为可能有负数
  if love<ans then ans:=love;
  end;
  if z>a then exit;          //注意退出
  dfs(x+m[z,1],y+m[z,2],z+1);
  dfs(x,y,z+1);
end;
begin
  ans:=maxlongint;
  readln(a,b);
  for i:=1 to a do
  readln(m[i,1],m[i,2]);
  dfs(0,0,1);
  if marray then write(ans) else write(-1);
end.
不要拆散cp哦
```

---

## 作者：Kohakuwu (赞：0)

# 打算用分治递归做

## 题解前的一些~~废话~~
这是我第一次写题解qwq，各位大佬们不喜勿喷qwq！求求管理小哥哥小姐姐能让我通过qwq，谢谢！

这一题，其实爆搜没有问题。隔壁题解说数据强大的都是没有优化（？）。

看到这里大多题解都是用搜索做的，那我就用递归+分治做一个吧！

首先呢，我们要搞清楚，我们是要求出小明小红的最小亲密值之差，想到这里，由于我是一个蒟蒻，~~不会dfs~~，所以呢，我就尝试着用递归写一个程序，想去提交碰碰运气，没想到，过了。所以，事实证明，题目的数据真的很水诶！

## 题目思路
没读题的先回去读题哦！

首先，按照分治的基本做法，我们将题目中的每一次递归分为两个操作：

1. 这件事不要做
1. 这件事要做

于是呢，我们递归的雏形就已经展现出来啦~

```cpp
inline void baosou(int num,int xm,int xh)
{
	if(num==n+1)
	{
		if(xm+xh>=v)minn=abs(xm-xh)<minn?abs(xm-xh):minn;
		return ;
	}
	baosou(num+1,xm,xh);
	baosou(num+1,xm+m[num],xh+h[num]);
}
```
## 完整代码

最后呢，放上我的完整代码。本代码是在C++ 17&&O2的情况下运行的，非常险，第五个测试点本人944ms才过的，如果测试机状态不好的话，~~建议多提交几遍碰碰运气~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,v;//如题所示 
int m[31],h[31];//储存每次输入的数据 
int minn=1000000001;//储存最终答案 
inline void baosou(int num,int xm,int xh)//参数分别为 事件的下标 此时小明的亲密度 小红的亲密度 
{
	if(num==n+1)
	{
		if(xm+xh>=v)minn=abs(xm-xh)<minn?abs(xm-xh):minn;
		//这里不用原版min是为了优化（？不知道有没有作用 qwq） 
		return ;
	}
	//敲黑板！！！ 
	baosou(num+1,xm,xh);//这件事不做 
	baosou(num+1,xm+m[num],xh+h[num]);//这件事做！ 
}
int main()
{
	cin>>n>>v;
	for(int i=1;i<=n;i++)cin>>m[i]>>h[i];
	baosou(1,0,0);
	if(minn==1000000001)cout<<-1;
	else cout<<minn;
}
```
## 总结

这道题目正常方法应该是搜索，可是考场上如果想不出来的话，建议先写爆搜，然后再写正经方法，好歹能骗分。以上都是个人的经验，仅供参考。

感谢大家耐心读完题解！点个赞再走吧！你们的鼓励是我的动力哦！

---

## 作者：百里狂生 (赞：0)

题目链接：https://www.luogu.com.cn/problem/P2080

这道题目的数据非常强大！是一道dfs的经典题目。

乍一看，这道题似乎和一个普通的全排列有点相似：全排列（https://www.luogu.com.cn/problem/P1706） 要求枚举出1~n个数的所有排列可能，而这道题就是要让两个数组：a（小明对小红的好感）和b（小红对小明的好感）进行全排列，但是很明显这样一定会超时！看看数据范围！冗杂的计算会大大拖慢程序的速度！

我们慢慢来说。


------------
**一、初步的dfs**

初步建立一个状态：如果小明的所有事情都做完了，那么搜索也就要开始从栈顶部回溯了，即return。如果还没有做完所有的事情，那么就继续搜索。定义一个for循环，循环变量从i到n，对a和b数组进行全排列，初步的dfs函数如下：

```cpp
void dfs(int step)
{
	if(step>n)  ///小明的事情做完了 
		return; ///返回 
	if(m+h>v)
		together=true;  ///在一起了，在main里只用判断together的真假性就可以了  
	minn=min(abs(m-h),minn); 
	else
	{
		for(int i=0;i<n;i++)
		{
			if(visited==0)  ///visited[i]表示第i件事情有没有被做 ，1表示做了，0表示没做 
			{
				visited[i]=1;  ///标记为已做 
				m+=a[i];
				h+=b[i];  ///小明(m)和小红(h)双方的亲密值增加 
				dfs(step+1);  ///继续就当前状态搜索 
				visited[i]=0;  ///回溯 dfs的经典步骤 可以在全排列中见到 
				m-=a[i];
				h-=b[i]; 
			} 
		}
	} 
}
```


很明显这样的算法消耗时间很长，会TLE很多，这时候需要进行剪枝。

**二、剪枝**

剪枝分为可行性剪枝和最优性剪枝，其目的都是为了减少不必要的搜索，我们一个一个来讲。

**1、可行性剪枝**

可行性剪枝是一种常见的剪枝方法，他的主要目的是为了减去不可行的方法，从而达到节省时间的目的。比如：你有10块钱吃早餐，早餐有很多种，每一种早餐有不同的价格，假设你需要吃3份早餐，那么需要对所有的早餐情况进行搜索，如果还只吃了一份早餐钱就不够了，那么就剪枝，即退出此次搜索，这样由一个父节点延伸出来的搜索方案都将会被剪掉，因为这种方案不可行。

**2、最优性剪枝**

最优性剪枝在很多程序的某些地方~~神出鬼没~~，嗯，我是指出现的非常隐蔽，以至于你识别不出这是一种剪枝。这种剪枝的主要目的是减去不优的方案，比如：你仍然有10块钱吃早餐，早餐的情况和上面的一样，但是假设你可以吃∞份早餐，要在不超过总钱数的情况下吃更多的早餐，如果此时已经找出一种最好的方案，在另外一个父节点延伸出来的搜索树上发现用相同的钱数买的早餐数量更少，那么这整个树都不需要搜索了，因为这棵树没有比最有解更优。

那么我们如何进行剪枝呢？

**方案一**

仔细观察程序不难发现：我们的for循环的循环变量i每次都是从0重新开始排列的，然而在step以前的位置已经计算过了，没有必要再算第二次，并且这些地方已经在visited里面标为了true，不能再排列了。

我们可以把循环变量i的初值定位step，让i直接从step开始接着上一次的继续进行搜索，是可行性剪枝。

```cpp
else
{
	for(int i=step;i<n;i++) //让 i 从step开始是可行性剪枝 
	{///因为step以前的事做了之后的结果已经算出来了，不会可能会can==0  
		if(can[i]==0)  ///这件事还没有被做 
		{
			can[i]=1;  ///将第can[i]件事变为 true 表示这件事已经做了  
			m+=a[i];
			h+=b[i]; ///将双方的亲密值进行增长  	
			dfs(step+1); ///进行下一步搜索 
			m-=a[i];
			h-=b[i];  
			can[i]=0;  ///回溯 dfs的经典步骤
		} 
	}
} 
```
但是效果很明显，这个剪枝的力度并不是很强！

**方案二**

在方案一的基础上我们来考虑一下能否进行最优性剪枝。不难看出：只有在大于v的时候才有可能出现最优解，所以可以考虑把计算minn值放到if(m+h>v)的里面。

与此同时，我们还可以考虑去掉together。因为在程序的开头定义的minn值是比较大的，如果两人的亲密值没有超过v，minn的值是不会发生改变的，所以可以去掉together这个值。

**方案三**

方案二其实是在为方案三做铺垫，minn的值在进行最优的计算，那么这个最优值最大是多少呢？是0，即当minn值为0时进行return或直接输出，节省时间。此时minn==0就是一种新的结束状态，可以把一开始的step>n的判断去掉了。修改的代码见终结程序。



------------
终结程序：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,v,a[30],b[30],minn=100000,m,h; ///minn一开始要设定一个很大的值，不然就会产生永久的cout<<"-1"<<endl; 导致程序结果错误 
bool visited[30];//判断是否做过这件事
void dfs(int step)
{
	if(m+h>v) ///当亲密值到达v的时候，就到了一起 
		minn=min(abs(m-h),minn); ///计算差值 这个差值计算得有个限制，把计算放在这个if里面是最优性剪枝 
	if(minn==0) ///如果已经好到了极点，那么绝对值只差应该为 0，这个就是最终的状态
		return;
        for(int i=step;i<n;i++)
	{
    	        if(visited[i]==0)
		{
    		      visited[i]=1;
    		      m+=a[i];
    		      h+=b[i];
    		      dfs(i+1);
		         visited[i]=0;
    		      m-=a[i];
    		      h-=b[i];	
		}
	}
}
int main()
{
	cin>>n>>v;
	for(int i=0;i<n;i++)
		cin>>a[i]>>b[i];
	dfs(0);
	if(minn==100000)
	{///亲密值未发生改变 没有在一起   
		cout<<"-1";
		return 0;
	}
	cout<<minn;
	return 0;
}
```



------------
**结语**

这种数据范围很小但是数据点却很刚强的题目告诉我们要养成随时剪枝的习惯，在考试的时候只有一次机会，样例只是题目的冰山一角，想要让程序抵得过任何数据的冲击，就要学会剪枝，运用剪枝！

祝好！

---

## 作者：冰桨 (赞：0)

这道题是一个简单的搜索，爆搜这个行为做还是不做，用sum存储好感总度，只有sum>v的时候才进行abs操作，stepa，stepb表示好感分度，注意若ans==0时可以跳出去了，只是个小小的优化，但是卡第五个测试点。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
const int N=1010101;
int n,v,gooda[N],goodb[N],ans=0x7fffffff;
void dfs(int x,int stepa,int stepb,int sum){
	if(ans==0) return;
	if(sum>=v){
		ans=min(ans,abs(stepa-stepb));
	}
	if(x<=n){
		dfs(x+1,stepa+gooda[x],stepb+goodb[x],sum+gooda[x]+goodb[x]);
		dfs(x+1,stepa,stepb,sum);
	}
}
int main(){
	scanf("%d%d",&n,&v);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&gooda[i],&goodb[i]);
	dfs(1,0,0,0);
	if(ans!=0x7fffffff)
	printf("%d\n",ans);
	else
	printf("-1\n");
    return 0;
}
```


---

## 作者：Mychael (赞：0)

数据很水，我写的也很水；

DFS
对于每一件事情，有做与不做两种选择，强行很水地暴力了一把。。。。

刚开始有一个点TLE了，仔细想想，最优方案也不过是0，那么搜到0直接输出结束程序

终于过了




```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=35,INF=1000000000;
int ming[maxn],hong[maxn],N,V,ans=INF;
int read()
{
    int out=0,flag=1;
    char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out*flag;
}
void dfs(int deep,int x,int y)
{
    if(deep>N)
    {
        int t;
        if(x+y>=V&&(t=abs(x-y))<ans)
            ans=t;
        if(ans==0)
        {
            cout<<ans<<endl;
            exit(0);
        }
        return;
    }
    dfs(deep+1,x+ming[deep],y+hong[deep]);
    dfs(deep+1,x,y);
}
int main()
{
    N=read();
    V=read();
    for(int i=1;i<=N;i++)
    {
        ming[i]=read();
        hong[i]=read();
    }
    dfs(1,0,0);
    if(ans!=INF) cout<<ans<<endl;
    else cout<<-1<<endl;
    return 0;
}

```

---


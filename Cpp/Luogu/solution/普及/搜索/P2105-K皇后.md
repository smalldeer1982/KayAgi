# K皇后

## 题目描述

小 Z 最近捡到了一个 $n$ 行 $m$ 列的棋盘，棋盘上的格子的横纵坐标从 $1$ 开始编号，他想在棋盘上摆放 $K$ 个皇后。他想知道在他摆完这 $K$ 个皇后之后，棋盘上还有多少个格子是不会被攻击到的。

**注意：一个皇后会攻击到这个皇后所在的那一行，那一列，以及两条对角线。**

## 说明/提示

- 对于 $30\%$ 的数据，$1\le n,m\le 5\times10^3$，$1\le K\le 500$；
- 对于另外 $10\%$ 的数据，$K=1$；
- 对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^4$，$1\le K\le 500$。

## 样例 #1

### 输入

```
12 13 6
10 4
12 10
1 1
2 3
3 2
2 6```

### 输出

```
25```

# 题解

## 作者：gujialiang123 (赞：46)

感觉我的可能是最简洁明了的了

简述一下思路

一行一行扫，如果当前行有国王直接跳过，否则遍历每个国王，每个国王对当前行有三个影响，一是对当前行和他列数相同的格子有攻击，二是他所占有的两条对角线可能会攻击到当前格子，这里要判断一下对角线延伸到当前行列数是否越界（在1-m中间），使用一个flag数组标记当前行每个位置是否被攻击到，每行遍历时开一个sum每次初始化为m，如果当前循环中已经没有被攻击过就sum--。

看到有人用memset每次清空flag，这里不需要，我们可以把flag定义为int类型，然后用当前行数作为标记，如果flag[i]不等于当前行数那就是没有攻击过，然后把这个位置的值赋成当前行的行数。

这样复杂度就是严格o(n*k),完全可以接受。

代码如下，比较短

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[501],y[501],n,m,k;
int flag[20001],vis[20001],sum,ans;
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++) cin>>x[i]>>y[i],vis[x[i]]=1;
	for(int i=1;i<=n;i++)
	{
		if(vis[i]) continue;//当前行有国王直接跳过
		sum=m;
		for(int j=1;j<=k;j++)
		{
			if(flag[y[j]]!=i) sum--;//当前国王控制的列数
			flag[y[j]]=i;
			if(x[j]<i)//当前国王在当前行上方
			{
				if(y[j]+i-x[j]>=1&&y[j]+i-x[j]<=m) 
				{//右下方向对角线
					if(flag[y[j]+i-x[j]]!=i) sum--;
					flag[y[j]+i-x[j]]=i;
				}
				if(y[j]-i+x[j]>=1&&y[j]-i+x[j]<=m) 
				{//左下方向对角线
					if(flag[y[j]-i+x[j]]!=i) sum--;
					flag[y[j]-i+x[j]]=i;
				}
			}
			else //当前国王在当前行下方
			{
				if(y[j]+(x[j]-i)>=1&&y[j]+(x[j]-i)<=m)
				{//右下方向对角线
					if(flag[y[j]+(x[j]-i)]!=i) sum--;
					flag[y[j]+(x[j]-i)]=i;
				}
				if(y[j]-(x[j]-i)>=1&&y[j]-(x[j]-i)<=m)
				{//左下方向对角线
					if(flag[y[j]-(x[j]-i)]!=i) sum--;
					flag[y[j]-(x[j]-i)]=i;
				}
			}
		}
		ans+=sum;
	}
	cout<<ans;
 } 
```


---

## 作者：彩虹猫 (赞：42)

# 题解 P2105 【K皇后】

这道题还是比较考验思维含量的。

我相信很多人都是这样点进来的：刚刚学完DFS，兴致勃勃的A掉了[P1219 八皇后](https://www.luogu.org/problem/P1219)，在推荐题目里面发现了“k皇后”“还是n皇后”等等奇怪的题目，以为和八皇后差不多，~~于是顺便赚双倍经验~~就点进来了。

阅读题面：哈，DFS裸题，水！

再阅读数据范围：

>对于 100%的数据，1 ≤ n，m ≤ 20000，1 ≤ k ≤ 500。

……


好，言归正传。


对于这道题，我们首先读入每个皇后的坐标。不同于DFS先枚举每个皇后，再枚举皇后能攻击到的点——**我们先枚举每一行，再判断这一行有几个格子被攻击。**

接下来是具体步骤：

1. 对于有皇后所在的那一行，直接跳过；

1. 如何判断一行格子的情况：

首先用一个bool数组存储这一行格子是否被攻击；

**其次，对于每一个皇后，若其在这一行的上方，则可能攻击到的格子有两个：$y \pm (i-x)$**（x，y均为皇后坐标）

**同理，若其在这一行的下方，则可能攻击到的格子也有两个：$y \pm (x-i) )$**（x，y为皇后坐标）

下面放一张图辅助理解：

![](https://cdn.luogu.com.cn/upload/pic/67131.png)


同时，对这些坐标进行排除，若y坐标$<1$或$>m$则不符合。

最后，遍历bool数组，记录sum。

3. $ans+=sum$，得出答案。

下面放上代码：（可能有一些代码段与第一篇题解相像，~~毕竟是对着第一篇题解敲的~~）

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c>'9'||c<'0') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {x=x*10+c-'0'; c=getchar();}
    return x*f;
}
inline void out(int x)
{
    if(x>=10){
        out(x/10);
    }
    putchar(x%10+'0');
}
int x[505],y[505];
int r[20005],q[20005];
int main()
{
//    ios::sync_with_stdio(false);
    int n,m,k;
    n=read(); m=read(); k=read();
    for(register int i=1;i<=k;i++)
    {
        x[i]=read(); y[i]=read();
        r[x[i]]=1;
    }
    int ans=0,sum;
    for(register int i=1;i<=n;i++)
    {
        if(r[i]==1) continue;
        memset(q,0,sizeof(q));
        sum=0;
        for(register int j=1;j<=k;j++)
        {
            q[y[j]]=1;
            if(x[j]<i)   //y[j] +/- (i-x[j])
            {
                if(y[j]+(i-x[j])<=m) q[y[j]+(i-x[j])]=1;
                if(y[j]-(i-x[j])>=1) q[y[j]-(i-x[j])]=1;
            }
            else   //y[j] +/- (x[j]-i)
            {
                if(y[j]+(x[j]-i)<=m) q[y[j]+(x[j]-i)]=1;
                if(y[j]-(x[j]-i)>=1) q[y[j]-(x[j]-i)]=1;
            }
        }
        for(register int j=1;j<=m;j++)
        {
            if(q[j]==0) sum++;
        }
        ans+=sum;
    }
    out(ans);
    return 0;
}
```


时间复杂度 $ O(n(m+k)) $

## THE END

### 觉得好点个赞再走吧（逃


---

## 作者：mot1ve (赞：34)

纯暴力

可以发现 从左下角到右上角的对角线x坐标和y坐标关系为：x+y=定值

从左上角到右下角对角线x坐标和y坐标关系为：x-y+20000=定值

为什么要加20000？因为比如说当x=1，y=1000的时候，x-y是负数，会导致数组越界
所以要加上20000防止数组越界，那么我们的数组就要开的比数据范围大一些了。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int h[2010000],l[2010000],xie1[4020000],xie2[4020000];
int x,y,n,m,k;
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
	{
		scanf("%d%d",&x,&y);
		h[x]=1;
		l[y]=1;
		xie1[x+y]=1;
		xie2[x-y+22000]=1;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(h[i])
		continue;
		for(int j=1;j<=m;j++)
		{
			if(l[j]||xie1[i+j]||xie2[i-j+22000])
			continue;
			else ans++;
		}
	}
	cout<<ans;
	return 0;
}

---

## 作者：zqiceberg (赞：19)

### 算法一 DFS模板，无剪枝，TLE，40分
```cpp
#include <iostream>
#include <cstdio>
#include <fstream>

using namespace std;

const int N = 2e4 + 10;

char g[N][N];
int row[N], col[N], dg[N * 10], udg[N * 10];
int n, m, k;
int res;

int main()
{
//	freopen("khuanghou.in", "r", stdin);
	cin >> n >> m >> k;
	
	while (k--)
	{
		int x, y;
		cin >> x >> y;
		row[x] = col[y] = dg[x + y] = udg[y - x + n + m] = 1;
	}
	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (row[i] || col[j] || dg[i + j] || udg[j - i + n + m]) res++;

	cout << n * m - res << endl;

	return 0;
}


```


算法二 DFS+剪枝

每一行枚举，皇后出现就直接下一行
对于每一行，枚举k个皇后位置，进行竖线、双斜线的交叉，计算每一行被攻击掉的点
每一行剩下没有攻击的点加起来，就是res
算法复杂度O(n * k) 
2e4 * 5e2 = 1e7 

```cpp
#include <iostream>
#include <cstdio>
#include <fstream>
#include <algorithm>
#include <cstring>

using namespace std;

typedef pair<int, int> PII;

const int N = 2e4 + 10, M = 510;

PII q[M];
int row[N], col[N], dg[N * 10], udg[N * 10];
int n, m, k;
int res;
int flag[N];

int main()
{
//	freopen("khuanghou.in", "r", stdin);
	cin >> n >> m >> k;
	
	for (int i = 0; i < k; i++)
	{
		int x, y;
		cin >> x >> y;
		q[i].first = x, q[i].second = y;
		row[x] = col[y] = dg[x + y] = udg[y - x + n + m] = 1;
	}
		
	for (int i = 1; i <= n; i++)
	{
		if (row[i]) continue;           //整行垮掉 
		
		int sum = m;
		
		for (int j = 0; j < k; j++)
		{
			int a = q[j].first, b = q[j].second;   //皇后坐标(a,b) 
			
			if (flag[b] != i) sum--;
			flag[b] = i;
			 
			if (a < i)	                           //(a,b)在i行上方
			{
				if (b - (i - a) >= 1)  //45度斜线
				{
					if (flag[b - (i - a)] != i) sum--;
					flag[b - (i - a)] = i;
				}
				if (b + (i - a) <= m)  //135度斜线 
				{
					if (flag[b + (i - a)] != i) sum--;
					flag[b + (i - a)] = i;
				}
			}
			if (i < a)                 //(a,b)在i行下方 
			{
				if (b + (a - i) <= m)  //45度斜线 
				{
					if (flag[b + (a - i)] != i) sum--;
					flag[b + (a - i)] = i;
				}				
				if (b - (a - i) >= 1)  //135度斜线
				{
					if (flag[b - (a - i)] != i) sum--;
					flag[b - (a - i)] = i;
				}
			}
		}
		
		res += sum;
	}
	
	cout << res << endl;

	return 0;
}

```


PS：尝试了6个小时的优化，实在弄不出来了，借鉴了一下前人的题解，发现这个思路真的很好

比如，原先是逐行逐列，然后看和k个皇后的关系，直接n^2
这个方法呢，是O(n)枚举行（带剪枝的），然后应对稀疏矩阵，每一列不是一个一个枚举，而是枚举k这个数据只有500个点的关系

有一个问题困扰我很久，没有A出来，就是不同的皇后可能对一行的的点，进行多次攻击，这让我没做出来

解决的方法是，flag[b] != i, 看这个列的标记数组的值，是否为i，如果不是，就说明，这列b没被这行i交叉过

很多地方，就标记的数组，都有这种用法，很飘逸

忍不住，打一个题解出来


---

## 作者：Ofnoname (赞：10)

我依然是为了哈希而找到此题，但是却没有发现和哈希有任何关系(我太菜了)。

于是我发现$N$只有区区20000。即使是$O(N^2)$的做法，只要常数较小，就可以通过此题。

我的思路是依次看每一行，分析每一个皇后对这一行的影响并使用桶储存下来，最后扫描桶更新答案。

每次判断应是$O(N*K)$，但是扫描桶是$O(N*M)$的。好在这一步常数小不会TLE。

跑了2000多ms，算是很慢的了。但是这已经足够了。

```cpp
#include <bits/stdc++.h>
#define legal(x) ((1<=(x))&&((x)<=M))
//判断x是否在这一列之内，，超出范围应舍去
#define MAX (20000+5)
using namespace std;

int N,M,K,ans,dx[MAX],dy[MAX];
bool T[MAX];//桶

inline void read(int &a)
{
    register char c=getchar(); 
    for (a=0; c<'0'||'9'<c; c=getchar());
    for (; '0'<=c && c<='9'; c=getchar())
        a=(a<<3)+(a<<1)+(c^48);
}

int main()
{
    read(N); read(M); read(K);
    for (register int i=1; i<=K; i++)
        read(dx[i]), read(dy[i]);
    for (register int i=1; i<=N; i++)
    {
        memset(T,0,sizeof(T));//每次初始化桶
        for (register int j=1; j<=K; j++)
        {
            if (dx[j]==i) {T[0]=1; break;}//1：本行有皇后，都不能放置了
            if (legal(dx[j]+dy[j]-i)) T[dx[j]+dy[j]-i]=1;
            if (legal(i-dx[j]+dy[j])) T[i-dx[j]+dy[j]]=1;
			//2：两个对角线的影响，这里的坐标用dx和dy构成的一次函数表示
            T[dy[j]]=1;//3：同列的影响
        }
        if (T[0]) continue;//如果是情况1则不更新答案
        for (register int j=1; j<=M; j++)
            if (!T[j]) ans++;//这里还可以放置
    }
    printf("%d",ans); return 0;
}
```



---

## 作者：LittleZ (赞：9)

这道题首先可以想到暴力方法，开n\*m的哈希，模拟每个棋子的放置，其中行、列和2条对角线各要模拟一遍，时间O(k\*(m+n))，统计答案要O(m\*n)，总计O(k\*(m+n)+m\*n)，空间O(n\*m)，可以得30%的分。

对于k=1，则计算行、列和对角线上一共有多少格子被覆盖，时间O(1)，空间O(1)，可以再得10%的分。

再看16M的空间，显然不能开n\*m的哈希，尝试只开m的哈希。

用ans记录答案，对于每一行，我们共享一个哈希h，h[i]表示该行第i格的状况；初始剩余棋子t=m，穷举每个棋子，可以计算这个棋子与这一行的相交情况，在处理相交时分类：

1.该棋子覆盖整个一行，则t=0，退出循环

2.该棋子相交的格子在这行没有被覆盖过，则t-1，该格标记为覆盖

3.该棋子相交的格子在这行被覆盖过，t不变

每行完后ans+t。

小技巧：为了防止重复清空h，可以打上时间戳，第i行中，h[j]=i表示j被覆盖，否则表示在以前被覆盖（这一行没被覆盖）。

时间O(n\*k)，空间O(m)，可以得100%的分数。

```cpp

#include <cstdio>
#include <cstdlib>
#include <cstring>
using namespace std;
int x[501],y[501],h[20001];
int main()
{
    int n,m,k,i,j,ans,t;
    scanf("%d%d%d",&n,&m,&k);
    memset(h,0,sizeof(h));
    for (i=1;i<=k;i++) scanf("%d%d",&x[i],&y[i]);
    ans=0;
    for (i=1;i<=n;i++)
    {
        t=m;
        for (j=1;j<=k;j++)
            if (x[j]==i)
            {
                t=0;
                break;
            } else
            {
                if (h[y[j]]!=i)
                {
                    h[y[j]]=i;
                    t--;
                }
                if ((i+y[j]-x[j])>0 && (i+y[j]-x[j])<=m && h[i+y[j]-x[j]]!=i)
                {
                    h[i+y[j]-x[j]]=i;
                    t--;
                }
                if ((y[j]+x[j]-i)>0 && (y[j]+x[j]-i)<=m && h[y[j]+x[j]-i]!=i)
                {
                    h[y[j]+x[j]-i]=i;
                    t--;
                }
            }
        ans+=t;
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：fyx_Catherine (赞：6)

### 这是一道数学+思维的题目
这道题直接爆搜显然是不行的。

正确思路：先枚举行，然后再枚举每个皇后，判断每个皇后对当前行是否有贡献，注意一下边界就行；主要就是要知道一个点、斜率和另一个点的横坐标，求另一个点的纵坐标。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
int read(){
    int a=0,k=1;char c=getchar();
    while (!isdigit(c)){if (c=='-')k=-1;c=getchar();}
    while (isdigit(c)){a=a*10+c-'0';c=getchar();}
    return a*k;
}
int n,m,k,x[20005],y[20005];
bool b[20005],vis[20005];
int main(){
    n=read();m=read();k=read();
    for(int i=1;i<=k;i++){
	x[i]=read();y[i]=read();
	b[x[i]]=true;
    }
    int ans=0;
    for(int i=1;i<=n;i++){
	if(b[i]) continue;
	memset(vis,false,sizeof(vis));//初始化vis数组为0
	int cnt=m;
	for(int j=1;j<=k;j++){
	    if(vis[y[j]]==false) cnt--;
	    vis[y[j]]=true;
	    int sy=i-x[j]+y[j];//斜率为1
	    if(sy>=1&&sy<=m&&vis[sy]==false){cnt--;vis[sy]=true;} 
	    int ty=x[j]-i+y[j];//斜率为-1
	    if(ty>=1&&ty<=m&&vis[ty]==false){cnt--;vis[ty]=true;}
	}
	ans+=cnt;//ans每次加上cnt的值
    }
    printf ("%d\n",ans);
    return 0;
}珍爱生命，请勿抄袭！

```
求通过（qwq）

---

## 作者：封禁用户 (赞：4)

### 一道暴力的好题，优化一下就好了
- 1. 这题的攻击范围处理方式跟8皇后是一样的  
定义V1[],V2[],V3[],V4[]。分别表示  
V1这一行有没有被攻击  
V2这一列有没有被攻击  
V4这一正对角线是否被攻击  
V3这一反对角线是否被攻击
- 2. 在处理对角线是不难发现一条正对角线上点（x,y）  
x-y+n是定值  
反对角线  
x+y是定值  
请读者自行画图理解
- 3 然后遍历每个点  
在这里要优化一下  
循环遍历的时候一旦发现这一行已经被攻击了那就不用再去遍历了continue即可    在代码中体现出来了
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,k;
int ans;
bool V1[100004],V2[100004],V3[100004],V4[100004];
inline int read()

{  

   int s=0,w=1;  

   char ch=getchar();  

   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}  

   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();  

   return s*w;  

}  
int main()
{
    n=read();
    m=read();
    k=read();
    int x,y;
    for(int i=1;i<=k;i++)
    {
        x=read();
        y=read();
        V1[x]=1;
        V2[y]=1;
        V3[x-y+n]=1;
        V4[x+y]=1;

    }
    for(int a=1;a<=n;a++)
    {   if(V1[a]==1)continue;//主要优化
        for(int b=1;b<=m;b++)
        {
            if(V2[b]==1)continue;//以下都是判断是否合法
        if(V4[a+b])continue;
        if(V3[a-b+n])continue;
        ans++;//合法则ans++;
        }
    }
    printf("%d",ans);
    return 0;
}
```  



---

## 作者：raincity (赞：3)


## 分析

拿到题目，最简单的想法是每输入一个皇后，直接做标记。最后扫一遍棋盘即可得到答案。看到数据范围，n,m<=20000,光扫一遍棋盘就会超时。但最大的问题不是这一点，而是：**空间会爆！**



2e4*2e4=4e8=400000000字节，约400MB，远超32MB的空间限制。即使使用状态压缩也需要50MB。故我们需要把数组降维。

显然不能存下整个棋盘。那能不能一行一行地解决呢？答案是肯定的。若这一行有皇后，则一定全都会被攻击；如果没有，则将每一个皇后的左右斜线各计算一遍，使用大小为m的标记数组即可。再用大小为n的数组标记哪几行有皇后即可。

## 解答

使用结构体存储每一个皇后：

```cpp
struct queen{
	int x,y;//坐标
}a[K];
```

则：第j个皇后在第i行的三个位置分别为：

k1=a[j].y-a[j].x+i,k2=a[j].x+a[j].y-i,k3=a[j].y。

时间复杂度O(nk)。可以通过本题。

### CODE
```cpp
#include<bits/stdc++.h>
#define N 20100
#define K 600
using namespace std;
bool attack[N],havequeen[N];
int n,m,k,sum;//sum为被攻击的位置个数，答案为n*m-sum
struct queen{
	int x,y;
}a[K];
int main(){
	freopen("queen.in","r",stdin);
	freopen("queen.out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=k;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		havequeen[a[i].x]=true;
	}
	for(int i=1;i<=n;i++){
		if(havequeen[i]){
			sum+=m;
		} 
		else{
			memset(attack,false,sizeof(attack));
			for(int j=1;j<=k;j++){
				if(attack[a[j].y]==false){
					attack[a[j].y]=true;
					sum++;
				} 
				int k1=a[j].y-a[j].x+i,k2=a[j].x+a[j].y-i;
				if(k1>=1&&k1<=m&&!attack[k1]){
					attack[k1]=true;
					sum++;
				}
				if(k2>=1&&k2<=m&&!attack[k2]){
					attack[k2]=true;
					sum++;
				} 
			}
		}
	}
	cout<<n*m-sum<<endl;
	return 0;
}
```


---


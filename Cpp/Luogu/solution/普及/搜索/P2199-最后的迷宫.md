# 最后的迷宫

## 题目背景

哈利•波特作为三强争霸赛的第四名选手，历尽艰险闯到了最后一关——迷宫。

现在，迷宫里只剩下哈利和塞德里克了，哈利只有在塞德里克前面拿到奖杯，才能赢得比赛。哈利只要能看到奖杯，就可以用飞来咒拿到它，所以，现在的问题是哈利如何能尽早地看到奖杯。


## 题目描述

哈利的视力非常好，他能从迷宫的一端沿直线看到迷宫的另一端（但他只能看八个方向——东北，东，东南，南，西南……），而且他跑得非常快，跑一步（向上、下、左、右移动一格）只需要 $1\text{s}$。但迷宫是不透光的，而且，要烧掉迷宫的墙也不容易，所以哈利决定绕到一个能够看到奖杯的地方。现在，哈利希望你能帮他确定最短需要多长时间才能拿到奖杯。


## 说明/提示

对于 $30\%$ 的数据，有 $N\times M\le100$；

对于 $60\%$ 的数据，有 $N\times M\le1600$；

对于 $100\%$ 的数据，有 $N\times M\le16384$。

询问数据对数不超过 $512$。


## 样例 #1

### 输入

```
3 4
OXXO
XXOO
XOOO
3 2 2 4
3 3 1 1
0 0 0 0
```

### 输出

```
1
Poor Harry
```

# 题解

## 作者：Alanalan (赞：22)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 16385
const int INF=0x3f3f3f3f;
const int dx[]={0,0,1,-1};
const int dy[]={1,-1,0,0};
const int ddx[]={0,0,1,1,1,-1,-1,-1};
const int ddy[]={1,-1,-1,0,1,-1,0,1};
string s[N];//n*m<=16000
vector<int> dis[N];
struct node
{
    int x,y;
};
int n,m;
queue<node> q;
bool ok(int x,int y)
{
    return x>=0 && x<n && y>=0 && y<m && s[x][y]=='O';
}
void bfs(int sx,int sy)
{
    for(int i=0;i<n;++i)
        for(int j=0;j<m;++j)
            dis[i][j]=INF;
    q.push(node{sx,sy});
    dis[sx][sy]=0;
    while(!q.empty())
    {
        int x=q.front().x;
        int y=q.front().y;
        q.pop();
        for(int i=0;i<4;++i)//四个方向
        {
            int xx=x+dx[i];
            int yy=y+dy[i];
            if(ok(xx,yy) && dis[xx][yy]==INF)
            {
                dis[xx][yy]=dis[x][y]+1;
                q.push(node{xx,yy});
            }
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;++i)
    {
        cin>>s[i];
        dis[i].resize(m+1);//规定每个vector长度
    }
    int sx,sy,ex,ey;
    while(cin>>ex>>ey>>sx>>sy)
    {
        if(!ex&&!ey&&!sx&&!sy) break;
        --ex;--ey;--sx;--sy;
        bfs(sx,sy);
        int ans=dis[ex][ey];
        for(int i=0;i<8;++i)
        {
            int x=ex,y=ey;
            while(ok(x+ddx[i],y+ddy[i]))
            {
                x+=ddx[i];
                y+=ddy[i];
                ans=min(ans,dis[x][y]);
            }
        }
        if(ans==INF) puts("Poor Harry");
        else printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：_wakeup (赞：15)

# 洛谷P2199

[题目链接](https://www.luogu.com.cn/problem/P2199)
### 一、题意分析
根据题面我们可以知道
1. 基本信息：哈利在一个 $N\times M$ 的迷宫中，他需要移动以**看到**奖杯，赢得比赛。哈利可以向上下左右四个方向行走**一格**，他移动的非常快，行走一格只需要 $1s$，也可以向东，东北，东北，西......八个方向看。迷宫的状态有两种：一种是空地，可以行走，在该题中用大写字母 O 来表示；另一种是墙，不可以行走，在该题中用大写字母 X 来表示。哈利不可以透过墙看到奖杯。
1. 题目需求：题目让我们求出哈利**看到**奖杯的**最短时间**。
1. 输入和输出信息：首先输入 $N$ 和 $M$，然后输入一个高为 $N$，宽为 $M$ 的矩阵。题目有多组测试数据，每一组测试数据会给出奖杯的坐标和哈利的坐标，共有四个数，当这四个数均为 $0$ 时，输入结束。对于每一组测试数据，如果哈利可以看到奖杯，那么输出哈利行走的最短时间；如果哈利无法看到奖杯，那么输出 `Poor Harry`.

### 二、思路说明
做题要有一个好习惯：先看数据范围。

对于 $100\%$ 的数据 $N\times M \le 16384$。这很巧妙，因为数据可以是 $N = 1,M = 16384$，这样用二维数组存储肯定会 MLE，所以要用一维数组存储。二维转一维的方式是求出目前输入的字符是第几个被输入的，可以得出第 $i$ 行第 $j$ 列的字符便是第 $(i-1)\times M + j$ 个输入的。

搞定了存储问题，接下来是处理那些地方可以**看到**奖杯。

奖杯是不会动，那么每个能看见奖杯的位置也是不变的，可以提前将能看见奖杯的位置找出来，在 $v$ 数组中打上标记，这样可以使不用每走一步就要判断一次能否看到奖杯。

当这些问题全部解决完之后，便是用 bfs 遍历哈利所有可以走的点,第一次走到能看见奖杯的地方便已经得出最优解，这也是为何不适用 dfs 的原因，dfs 在求最短路径时时间复杂度较高，效率远不如 bfs.
#### 三、小坑

多测不清空，报零两行泪。

如果哈利和奖杯的位置一样，那么直接输出 $0$ 即可，不必再进行其它操作。

如果哈利一开始就能看到奖杯，也是直接输出 $0$ 即可，要注意的是这里也是要清空的。

[ 代码](https://www.luogu.com.cn/paste/1qdj38xd)

---

## 作者：2c_s (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P2199)

## 思路

一道很明显的 bfs 题。

数据是 $N\times M\le 16384$，所以普通的二维存图肯定会 MLE。这时我们考虑用一维来存图。

输入之后将图转化为一维进行搜索，每次搜索都要向 $8$ 个方向看是否有金色飞贼或自己位于金色飞贼处，是的话直接输出步数、跳出循环即可。如果直到队列清空都没找到，输出 ``Poor Harry``，进行下一轮访问。

- 注意每次读入时，先读入飞贼位置，再读入本体位置。

- 向四周环顾的时候不要用搜索，直接 $8$ 个方向找即可（毕竟没有谁的视线是拐弯的）。

- 每次找的时候注意清空 $vis$ 标记数组和队列。

- 注意本体飞的时候有 $4$ 个方向，而视线是 $8$ 个。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+10;
int n,m,sx,sy,ex,ey;
char mp[N];//存图数组。
bool vis[N];//标记数组。
struct node{
	int x,y,step;
};queue<node>q;
const int dx[]={1,1,-1,1,0,-1,0,-1};
const int dy[]={0,1,0,-1,1,1,-1,-1};
bool check(int x,int y){
	if(x<1||x>n||y<1||y>m||mp[(x-1)*m+y]=='X')return 0;
	else return 1;
}
bool look(int stx,int sty){//向 8 个方向看是否能找到。
	for(int i=0;i<8;++i){
		int xx=dx[i]+stx;
		int yy=dy[i]+sty;
		while(check(xx,yy)){//只要没越界就一直找。
			if(xx==ex&&yy==ey)return 1;
			xx+=dx[i];
			yy+=dy[i];
		}
	}
	return 0;//没找到返回。
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j)cin>>mp[(i-1)*m+j];
	}
	while(1){
		scanf("%d%d%d%d",&ex,&ey,&sx,&sy);
		if(sx==sy&&sy==ex&&ey==ex&&ex==0)return 0;//如果输入全为零，结束。
		while(q.size())q.pop();//清空上次搜索的记录，否则会 WA。
		memset(vis,0,sizeof vis);
		q.push({sx,sy,0});
		vis[(sx-1)*m+sy]=1;
		bool flag=1;
		while(q.size()){
			node now=q.front();
			q.pop();
			if(now.x==ex&&now.y==ey||look(now.x,now.y)){
				printf("%d\n",now.step);
				flag=0;//找到了就返回，需要记录一下。
				break;
			}
			for(int i=0;i<8;i+=2){
				int xx=now.x+dx[i];
				int yy=now.y+dy[i];
				if(!check(xx,yy)||vis[(xx-1)*m+yy])continue;
				q.push({xx,yy,now.step+1});
				vis[(xx-1)*m+yy]=1;//记得标记当前已经搜索到的位置。
			}
		}
		if(flag)printf("Poor Harry\n");//没找到，输出。
	}
	return 0;
}
```

[AC 记录（O2）](https://www.luogu.com.cn/record/116847197)

---

## 作者：gnim (赞：5)

思路：把能看到奖杯的地方标记，然后 bfs，直到走到第一个被标记过的点。

二维数组可以用 `vector` 开。

上代码咯（有注释）

```cpp
#include<iostream>
#include<queue>
#define hh(i,a,b) for (int i=(a);i<=(b);++i)
#define rep(i,n) for (int i=1;i<=n;++i)
#define lop(i,n) for (int i=n;i;--i)
#define hp(i,a,b) for (int i=max((a),(b));i>=min((b),(a));--i)
#define pii pair<int,int>
#define X first
#define Y second
using namespace std;
int dx[]={0,0,-1,1,-1,-1,1,1};
int dy[]={1,-1,0,0,-1,1,-1,1};
vector<vector<char> >map;
vector<vector<int> >vis;
int n,m;
char tmp[155555];
int bfs(int x,int y){//Bfs模板
	queue<pii>q;
	q.push({x,y});
	if (vis[x][y]==-1) return 0;
	vis[x][y]=1;
	while(!q.empty()){
		pii tmp=q.front();q.pop();
		int x=tmp.X,y=tmp.Y;
		hh(i,0,3){
			int nx=dx[i]+x,ny=dy[i]+y;
			if (nx>=1&&nx<=n&&ny>=1&&ny<=m&&map[nx][ny]!='X'){
				if (vis[nx][ny]==-1) return vis[x][y];
				if (vis[nx][ny]==0) q.push({nx,ny}),vis[nx][ny]=vis[x][y]+1;
			}
		}
	} 
	return -1;
}
template<typename T>
void change(vector<vector<T> >&p){//开二维数组需要用&传值操作
	vector<vector<T> >_(n+5,vector<T>(m+5));
	p=_;
}
void r(int a,int b,int i){//把奖杯看到的地方标记一下
	while(a>=1&&a<=n&&b>=1&&b<=m&&map[a][b]!='X')vis[a][b]=-1,a+=dx[i],b+=dy[i];
    //除非走到头，否则一直走
}
main(){
	cin>>n>>m;
	change(map);change(vis);
	rep(i,n){
		scanf("%s",tmp+1);
		rep(j,m) map[i][j]=tmp[j];
	}
	int a,b,c,d;
	while(cin>>a>>b>>c>>d,a&&b&&c&&d){//判断是否都为0
		for (auto &V:vis) for(auto &v:V)v=0;//清空数组
		hh(i,0,7) r(a,b,i);//把每个方向都标记
		int tmp=bfs(c,d);
		if(tmp==-1) puts("Poor Harry");
		else cout<<tmp<<'\n';
	}
   return 0;
}
```

---

## 作者：Xswarx_XL (赞：5)

[题目链接](https://www.luogu.com.cn/problem/P2199)

前言：本篇只讲述最低级的二维做法（能过），若想学更高级，符合绿题难度的一维做法，请前往别处，除程序外，其余地方和数据修改前一样，大佬勿看勿喷。

# 题目大意：

就是问你从起点开始，哈利要至少向四个方向移动多少格（且期间只能走在空地上），所在的点才能和终点（即奖杯位置）成一条竖线，横线或斜线并中间不能有墙隔着。

# 解题思路：

所谓“最后的迷宫”，想必是一道典型迷宫问题，求最少移动次数，再一看算法，果然，广搜没得跑了。

那普通的广搜是怎么评到绿题的呢？

想必肯定是这题别出心裁的截止条件了。

至于广搜的模板，自己去打吧，不用说，这个终止条件，我们可以写一个函数去判断，设好八个方向的数组，遍历八个方向，利用这个方向数组，我们可以推出这个点周围八个方向的点，沿着这个方向（方向始终不变，保持一条直线），只要推出来的点不是墙，就一直推，出界为止。中途如果遇到了奖杯，函数直接返回终止搜索。

最后，注意一个点搜索后要记录进数组，以免重复搜索。

而且，有多组数据哦。

本题程序（请勾上洛谷自配的优化选项，避免超时）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sx,sy,ex,ey,dx[8]={-1,1,0,0,-1,1,-1,1},dy[8]={0,0,-1,1,-1,1,1,-1};
char a[16384][8005];
queue<int>x;
queue<int>y;
queue<int>s;
bool check(int q,int p){return q>=1&&q<=n&&p>=1&&p<=m;}
bool look(int mx,int my){
	if(mx==ex&&my==ey)
		return true;
	for(int i=0;i<8;i++){
		int ux=mx+dx[i],uy=my+dy[i];
		while(check(ux,uy)&&a[ux][uy]=='O'){
			if(ux==ex&&uy==ey)
				return true;
			ux+=dx[i],uy+=dy[i];
		}
	}
	return false;
}
void bfs(){
	bool f[n+1][m+1];
	memset(f,0,sizeof(f));
	while(!x.empty()) x.pop();
	while(!y.empty()) y.pop();
	while(!s.empty()) s.pop();
	x.push(sx);
	y.push(sy);
	s.push(0);
	while(!x.empty()){
		int ox=x.front(),oy=y.front(),os=s.front();
		if(look(ox,oy)){
			cout<<os<<"\n";
			return;
		}
		for(int i=0;i<4;i++){
			int px=ox+dx[i],py=oy+dy[i];
			if(check(px,py)&&f[px][py]==0&&a[px][py]!='X')
				x.push(px),y.push(py),s.push(os+1),f[px][py]=1;
		}
		x.pop(),y.pop(),s.pop();
	}cout<<"Poor Harry\n";
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>ex>>ey>>sx>>sy;
	while(!(sx==0&&sy==0&&ex==0&&ey==0)){
		bfs();
		cin>>ex>>ey>>sx>>sy;
	}
	return 0;
}
```

# 小结

上述程序已[通过](https://www.luogu.com.cn/record/114946367)，请安心食用。

本题其实并~~不~~难，考验广搜的熟练度。

讲一下为什么不用深搜用广搜：

- 广搜不会超时。
- 广搜只要终止搜索，即是最优解；但是深搜地毯式搜索，要搜所有的情况，时间复杂度不够优秀。


---

## 作者：嚯呀嚯呀 (赞：4)

**P党福利！！！**

这道题是一道搜索的水题，如果没有这个数据范围的话，估计都变成黄题了吧

对于100%的数据,有N*M<=16384

正常情况下为了防备出现极端情况(n=1,m=16384)，我们要把数组开到16500*16500，但是这样是不行了，会爆内存

**于是乎我们用到了Pascal的动态数组**

定义(在var下面写) a:array of longint;
这样我们就定义了一个一维的动态数组，只要在下面程序中写setlength(a,x)就可以开一个0到x-1的一维数组

二维数组的话map:array of array of longint;     
setlength(map,n,m)就可以开一个0到n-1,  0到m-1的二维数组，多维的同理

这样的话，我们就可以根据n,m的大小动态的开数组，很方便哦

**有一点要注意**，**动态数组无法用fillchar更新，会出现216错误(一般保护性错误)**

再针对题目讲一点吧，我的做法是把能望到奖杯的位置先提前标记好，然后宽搜，只要走到标记过的位置就退出输出解(因为是宽搜，所以先得出来的解必定是最优解)

亮出我丑陋的代码，大佬们随便看看
```
var
  bi:boolean;
  ans,head,tail,a1,a2,xx,yy,x,y:longint;
  i,j,m,n,k,p:longint;
  map:array of array of char;
  check:array of array of longint;
  s:array[1..8]of longint=(-1,-1,0,1,1,1,0,-1);
  t:array[1..8]of longint=(0,1,1,1,0,-1,-1,-1);
  sx:array[1..4]of longint=(-1,0,1,0);
  sy:array[1..4]of longint=(0,1,0,-1);
  fx,fy,num:array[0..20000]of longint;
begin
  readln(n,m);
  setlength(map,n+1,m+1);
  setlength(check,n+1,m+1);
  for i:=1 to n do
    begin
      for j:=1 to m do
        read(map[i,j]);
      readln;
    end;
  while true do
    begin
      readln(xx,yy,x,y);
      if (xx=0)and(yy=0)and(x=0)and(y=0) then break;
      for i:=0 to n do
       for j:=0 to m do
         check[i,j]:=0;


      check[xx,yy]:=2;
      for i:=1 to 8 do
        if (xx+s[i]>=1)and(xx+s[i]<=n)and(yy+t[i]>=1)and
           (yy+t[i]<=m)and(map[xx+s[i],yy+t[i]]='O') then
          begin
            a1:=xx; a2:=yy;
            while (a1+s[i]>=1)and(a1+s[i]<=n)and(a2+t[i]>=1)and
                  (a2+t[i]<=m)and(map[a1+s[i],a2+t[i]]='O') do
              begin
                a1:=a1+s[i]; a2:=a2+t[i];
                check[a1,a2]:=2;
              end;
          end;
      {for i:=1 to n do
        begin
          for j:=1 to m do
            write(check[i,j]);
          writeln;
        end;}
      if check[x,y]=2 then
        begin
          writeln(0); continue;
        end;
      head:=0; tail:=1; fx[1]:=x; fy[1]:=y; num[1]:=0; check[x,y]:=1;
      bi:=false;
      while head<tail do
        begin
          inc(head);
          for i:=1 to 4 do
            if (fx[head]+sx[i]>=1)and(fx[head]+sx[i]<=n)and
               (fy[head]+sy[i]>=1)and(fy[head]+sy[i]<=m)and
               (check[fx[head]+sx[i],fy[head]+sy[i]]<>1)and
               (map[fx[head]+sx[i],fy[head]+sy[i]]='O')then
              begin
                if check[fx[head]+sx[i],fy[head]+sy[i]]=2 then
                  begin
                    ans:=num[head]+1; bi:=true; break;
                  end
                else
                  begin
                    inc(tail); fx[tail]:=fx[head]+sx[i];
                    fy[tail]:=fy[head]+sy[i]; num[tail]:=num[head]+1;
                    check[fx[tail],fy[tail]]:=1;
                  end;
              end;
          if bi=true then break;
        end;
      if bi=true then
        writeln(ans)
      else
        writeln('Poor Harry');
    end;
end.
```

---

## 作者：BigRooster (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2199)

题目要求我们只要看到奖杯就判定为找到答案，所以我们可以逆向思考，将“看到奖杯”转化为“来到奖杯 $8$ 个方向上。我们将此步骤作为预处理，随后使用广搜即可解决问题。

最近题目描述更改，改为 $n \times m \leq 16384$，为了防止像 $n=1,m=16384$ 这种卡二维数组的数据，我们需要把地图压成一维。

但是像我这种懒人，肯定不愿意再把所有使用数组的地方都改一遍，因此，我们选择用宏定义来把两个下标转化为一个。

```cpp
#define a(x,y) aa[(x-1)*m+y]
#define b(x,y) bb[(x-1)*m+y]
#define used(x,y) use[(x-1)*m+y]
```

需要注意宏的名称不能和数组名称相同。

然后将所有使用二维数组的地方用宏代替（宏定义时不能用中括号）。

```cpp
#include<bits/stdc++.h>
#define a(x,y) aa[(x-1)*m+y]
#define b(x,y) bb[(x-1)*m+y]
#define used(x,y) use[(x-1)*m+y]
using namespace std;
int aa[16385];
int bb[16385];
int n,m;
int x,y,k,l;
int dx2[4]={-1,1,0,0};
int dy2[4]={0,0,-1,1};
int dx[8]={-1,1,0,0,-1,-1,1,1};
int dy[8]={0,0,-1,1,-1,1,-1,1};
int bfs(int x,int y)
{
	queue<pair<pair<int,int>,int>>q;
	bool use[16385];
	memset(use,false,sizeof(use));
	q.push(make_pair(make_pair(x,y),0));
	while(!q.empty())
	{
		auto it=q.front();
		auto x=it.first.first;
		auto y=it.first.second;
		auto s=it.second;
		if(a(x,y)==2)
			return s;
		for(int i=0;i<4;i++)
		{
			auto xx=x+dx2[i];
			auto yy=y+dy2[i];
			auto ss=s+1;
			if(a(xx,yy)&&(!used(xx,yy)))
				used(xx,yy)=true,q.push(make_pair(make_pair(xx,yy),ss));
		}
		q.pop();
	}
	return -1;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	//ofstream cout("P2199.txt",ios::out);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		char c;
		for(int j=1;j<=m;j++)
			cin>>c,a(i,j)=b(i,j)=(c=='O'?1:0);
	}
	x=y=k=l=1;
	while(true)
	{
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				a(i,j)=b(i,j);
		cin>>x>>y>>k>>l;
		if(x==0&&y==0&&k==0&&l==0) return 0;
		for(int i=0;i<8;i++)
		{
			int ii=x,jj=y;
			while(a(ii,jj)!=0)
			{
				a(ii,jj)=2;
				ii+=dx[i];
				jj+=dy[i];
			}
		}
		int answer=bfs(k,l);
		if(answer==-1)
			cout<<"Poor Harry\n";
		else
			cout<<answer<<"\n";
	}
}
```

就能过……吗？

不能。

因为我们压成了一维，所以不能访问 $a_{x,y}(x=0)$ 和 $a_{x,y}(y=0)$ 等原来存在的位置，因为压成一维后所有图中的点是相连的，不存在二维数组中 $y=0$ 等的位置，所以在判断出界时需要做一些更改。

```cpp
if(xx&&yy&&xx<=n&&yy<=m)
	if(a(xx,yy)&&(!used(xx,yy)))
		used(xx,yy)=true,q.push(make_pair(make_pair(xx,yy),ss));
```

可以看出，就是加了坐标的判断，同理，主函数内的奖杯转化也需要进行更改。

```cpp
bool judge(int x,int y)
{
	if(x&&y&&x<=n&&y<=m)
		return (b(x,y)!=0);
	return false;
}
while(judge(ii,jj))
{
	a(ii,jj)=2;
	ii+=dx[i];
	jj+=dy[i];
}
```

更改后得到通过本题的代码。

```cpp
#include<bits/stdc++.h>
#define a(x,y) aa[(x-1)*m+y]
#define b(x,y) bb[(x-1)*m+y]
#define used(x,y) use[(x-1)*m+y]
using namespace std;
int aa[16385];
int bb[16385];
int n,m;
int x,y,k,l;
int dx2[4]={-1,1,0,0};
int dy2[4]={0,0,-1,1};
int dx[8]={-1,1,0,0,-1,-1,1,1};
int dy[8]={0,0,-1,1,-1,1,-1,1};
bool judge(int x,int y)
{
	if(x&&y&&x<=n&&y<=m)
		return (b(x,y)!=0);
	return false;
}
int bfs(int x,int y)
{
	queue<pair<pair<int,int>,int>>q;
	bool use[16385];
	memset(use,false,sizeof(use));
	q.push(make_pair(make_pair(x,y),0));
	while(!q.empty())
	{
		auto it=q.front();
		auto x=it.first.first;
		auto y=it.first.second;
		auto s=it.second;
		if(a(x,y)==2)
			return s;
		for(int i=0;i<4;i++)
		{
			auto xx=x+dx2[i];
			auto yy=y+dy2[i];
			auto ss=s+1;
			if(xx&&yy&&xx<=n&&yy<=m)
				if(a(xx,yy)&&(!used(xx,yy)))
					used(xx,yy)=true,q.push(make_pair(make_pair(xx,yy),ss));
		}
		q.pop();
	}
	return -1;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	//ofstream cout("P2199.txt",ios::out);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		char c;
		for(int j=1;j<=m;j++)
			cin>>c,a(i,j)=b(i,j)=(c=='O'?1:0);
	}
	x=y=k=l=1;
	while(true)
	{
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				a(i,j)=b(i,j);
		cin>>x>>y>>k>>l;
		if(x==0&&y==0&&k==0&&l==0) return 0;
		for(int i=0;i<8;i++)
		{
			int ii=x,jj=y;
			while(judge(ii,jj))
			{
				a(ii,jj)=2;
				ii+=dx[i];
				jj+=dy[i];
			}
		}
		int answer=bfs(k,l);
		if(answer==-1)
			cout<<"Poor Harry\n";
		else
			cout<<answer<<"\n";
	}
}
```

---

## 作者：LakeArcFox (赞：3)

数据范围是NxM<=16384，虽然经过其他dalao的测试是可以用1600x1600的二维数组存下的，但在不知道这一点的情况下，保险起见最好把二维坐标用一维表示吧。其他地方变化不大，只是搜索的时候要进行转化。

题目所求是看到奖杯至少走几步，所以首先从终点开始向八个方向搜索，把能看到奖杯的点直接标记一下。

起点时间记为0，在BFS过程中可以直接求出到其它点需要的时间，如果发现队首的点所表示的位置已经可以看到奖杯了，直接输出这个点的时间就好了。

下面是代码(风格很差并且很水):
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;

int cg[32768],zd[32768],ti[32768],inq[32768];
char s[32768];
int n,m,sx,sy,ex,ey,sp,ep,resu,rex,rey;
int dirx[8]={-1,-1,0,1,1,1,0,-1},diry[8]={0,-1,-1,-1,0,1,1,1};
//八个方向
queue<int> q;

//把二维转化成一维，比如宽度为7的时候，(1,1)就是1，(1,2)就是2，(2,1)就是8
int dtos(int x,int y)
{
    if(x<1||x>n||y<1||y>m) return 0;
    //这个表示点越界了就不要计算了
    int k=m*(x-1)+y;
    resu=k;
    //为了方便用全局变量存了结果
    if(k<1||k>m*n) return 0;
    return k;
}

//把一维转化成二维，结果存在全局变量里(谁让我不知道怎么返回两个值)
int stod(int k)
{
    rex=(k-1)/m+1;
    rey=k-(rex-1)*m;
}

int main()
{
//	freopen("1.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",&s);
        for(int j=0;j<m;j++)
            if(s[j]=='O') cg[m*(i-1)+j+1]=1;
            else cg[m*(i-1)+j+1]=0;
        //读入时标记能不能到达，直接二维转一维表示了
    }
    while(1)
    {
        scanf("%d%d%d%d",&ex,&ey,&sx,&sy);
        if(!ex) break;
        
        //下面四行都是重新开始一个新的情况
        while(!q.empty()) q.pop();
        memset(zd,0,sizeof(zd));
        memset(ti,0,sizeof(ti));
        memset(inq,0,sizeof(inq));
        
        //从终点向八个方向搜索
        for(int i=0;i<8;i++)
        {
            int ix=ex,iy=ey;
            while(dtos(ix,iy))//函数已经带有对是否越界的判断
            {
                if(!cg[resu]) break;
                //撞墙就不要继续搜了
                zd[resu]=1;
                ix+=dirx[i];
                iy+=diry[i];
            }
        }
        //起点入队，inq表示这个点访问过了
        q.push(dtos(sx,sy));
        inq[dtos(sx,sy)]=1;
        ti[dtos(sx,sy)]=0;
        while(!q.empty())
        {
            int t=q.front();
            if(zd[t])
            {
                printf("%d\n",ti[t]);
                goto next;
                //结束后就去读取下一组数据
            }
            q.pop();
            
            //把一维转成二维进行BFS
            stod(t);
            int tx=rex,ty=rey;
            
            //用一个变量暂存这个点的一维坐标表示，否则重复执行dtos函数的时候resu的值会被改变
            int sno=dtos(tx,ty);
            for(int i=0;i<8;i+=2)//只能向四个方向走而不是八个!
            {
                if(dtos(tx+dirx[i],ty+diry[i]))
                {
                    if(!inq[resu]&&cg[resu])
                    {
                        ti[resu]=ti[sno]+1;
                        inq[resu]=1;
                        q.push(resu);
                    }
                }
            }
        }
        printf("Poor Harry\n");
        next:
        ;
    }
    return 0;
}

```

---

## 作者：Leap_Frog (赞：2)

## P2199最后的迷宫（题解）

题目传送门：[点我](https://www.luogu.org/problemnew/show/P2199)

主要思路：  
- 把可以结束的点记录下来。
- 从起点出发，[广搜](https://www.cnblogs.com/fnlingnzb-learner/p/9052169.html)。

注意点：  
注意不用走的情况。

代码：~~刚好一百行，强迫症患者的福音~~
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
struct point
{
	ll x,y,step;
	point() {x=0;y=0;step=0;}
	point(ll a,ll b,ll c):x(a),y(b),step(c) {}
};
const ll xxx[4]={-1,1,0,0},yyy[4]={0,0,-1,1};
const ll dx[8]={0,0,-1,1,-1,1,-1,1},dy[8]={-1,1,0,0,-1,-1,1,1};
ll n,m;
point s,e;
vector<bool>b[17005],end[17005],vis[17005];
inline bool Ok(point a)
{
	if(a.x>=1&&a.x<=n&&a.y>=1&&a.y<=m&&b[a.x][a.y]) return true;
	return false;
}
inline void In()
{
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=n;i++)
	{
		b[i].clear();b[i].push_back(true);
		for(ll j=1;j<=m;j++)
		{
			char a;
			cin>>a;
			if(a=='O') b[i].push_back(true);
			if(a=='X') b[i].push_back(false);
		}
	}
}
inline void csearch()
{
	for(ll i=1;i<=n;i++)
	{
		end[i].clear();
		for(ll j=0;j<=m;j++) end[i].push_back(false);
	}
	for(ll i=0;i<8;i++)
	{
		point p=s;
		while(Ok(p)) {end[p.x][p.y]=true;p.x+=dx[i];p.y+=dy[i];}
	}
}
inline ll bfs()
{
	queue<point>q;
	q.push(point(e.x,e.y,1));
	if(end[e.x][e.y]) return 0;
	for(ll i=1;i<=n;i++)
	{
		vis[i].clear();
		for(ll j=0;j<=m;j++) vis[i].push_back(false);
	}
	while(!q.empty())
	{
		point t=q.front();q.pop();
//		printf("%lld %lld:%lld\n",t.x,t.y,t.step);
		for(ll i=0;i<4;i++)
		{
			point now=point(t.x+xxx[i],t.y+yyy[i],t.step+1);
			if(!Ok(now)) continue;
			if(vis[now.x][now.y]) continue;
			if(end[now.x][now.y]) return t.step;
			q.push(now);
			vis[now.x][now.y]=true;
		}
	}
	return -1;
}
inline void work()
{
	csearch();
	ll ans=bfs();
	if(ans==-1) printf("Poor Harry\n");
	else printf("%lld\n",ans);
//	for(ll i=1;i<=n;i++)
//	{
//		for(ll j=1;j<=m;j++) cout<<b[i][j];
//		printf("\n");
//	}
//	printf("\n");
//	for(ll i=1;i<=n;i++)
//	{
//		for(ll j=1;j<=m;j++) cout<<end[i][j];
//		printf("\n");
//	}
//	printf("\n");
}
int main()
{
//	freopen("&tmp.in","r",stdin);
	In();
	while(scanf("%lld%lld%lld%lld",&s.x,&s.y,&e.x,&e.y)==4&&(s.x||s.y||e.x||e.y)) work();
	return 0;
}
```
~~[没有广告](https://daniu.blog.luogu.org/)~~

---

## 作者：2011FYCCCTA (赞：1)

# [原题](https://www.luogu.com.cn/problem/P2199)

刚开始以为还挺水。

---
### 1. 题意

哈利在迷宫中寻找奖杯，只要他在八个方向中且不穿墙的情况下看到了奖杯，就算找到。哈利可以上下左右移动，求要找到奖杯的最少移动次数。若无法看到（奖杯或**自己**被围起来），输出 `Poor Harry`。

---
### 2. 思路

很明显，本题用广搜解决。

但本题有三个问题：

1. 空间。

	题目中只给定了 $N \times M \le 16384$，这时候如果用静态数组为防止如 $N = 1 , M = 16384$ 这样的极端数据，需要开到 $16384 \times 16384$，会爆，因此我用了动态数组。

2. 判断是否看到奖杯。

	若每走一步判断一次时间复杂度太高了，可以从奖杯位置开始遍历 $8$ 个方向所能看到的位置，并用一个数组记录。
    
3. 判断是否奖杯或自己被围起来
	
    很简单，若广搜完没有看到，就是奖杯或自己被围起来了。

**注意：动态数组下标从 $0$ 开始，注意将输入的坐标减一。**

接下来，就是敲一遍广搜模板的事了。

---
### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int nx[] = {1 , 0 , 0 , -1 , 1 , 1 , -1 , -1};
const int ny[] = {0 , 1 , -1 , 0 , 1 , -1 , 1 , -1};
struct Node
{
    int x , y , t;
};
int n , m , cx , cy , bx , by;
vector<vector<char>> maze;
vector<vector<bool>> book;
vector<vector<bool>> see;

void book_init()
{
    for (int i = 0 ; i < n ; i++)
        for (int j = 0 ; j < m ; j++) book[i][j] = false;
    return;
}

void see_init()
{
    for (int i = 0 ; i < n ; i++)
        for (int j = 0 ; j < m ; j++) see[i][j] = false;
    return;
}

int bfs()
{
    queue<Node> q;
    q.push((Node){bx , by , 0}); 
    book_init(); book[bx][by] = true;
    while (!q.empty())
    {
        Node now = q.front();
        q.pop();
        if (see[now.x][now.y]) return now.t;
        for (int i = 0 ; i < 4 ; i++)
        {
            int tx = now.x + nx[i] , ty = now.y + ny[i];
            if (tx >= 0 && tx < n && ty >= 0 && ty < m && !book[tx][ty] && maze[tx][ty] == 'O')
            {
                q.push((Node){tx , ty , now.t + 1});
                book[tx][ty] = true;
            }
        }
    }
    return -1;
}

int main()
{
    cin >> n >> m;
    for (int i = 0 ; i < n ; i++)
        for (int j = 0 ; j < m ; j++)
        {
            char c; cin >> c;
            //一起开空间
            if (!j)
            {
                maze.push_back(*new vector<char>);
                book.push_back(*new vector<bool>);
                see.push_back(*new vector<bool>);
            }
            maze[i].push_back(c); book[i].push_back(false); see[i].push_back(false);
        }

    while (true)
    {
        cin >> cx >> cy >> bx >> by;
        if (!cx) break;
        --cx; --cy; --bx; --by; //减一不能忘！

        maze[cx][cy] = 'C';
        see_init();
        for (int i = 0 ; i < 8 ; i++)
        {
            int tx = cx , ty = cy;
            to:
            tx += nx[i] , ty += ny[i];
            if (tx >= 0 && tx < n && ty >= 0 && ty < m && maze[tx][ty] == 'O') {see[tx][ty] = true; goto to;}
        }
        int ans = bfs();
        if (ans == -1) cout << "Poor Harry";
        else cout << ans;
        cout << endl;
    }
    return 0; 
}
```

---


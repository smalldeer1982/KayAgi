# Mzc和男家丁的游戏

## 题目背景

mzc 与 djn 的第二弹。

## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁（做过上一弹的都知道）。他把她们召集在了一起，他们决定玩捉迷藏。现在 mzc 要来寻找他的男家丁，大家一起来帮忙啊！

由于男家丁数目不多，再加上 mzc 大大的找人水平很好，所以一次只需要找一个男家丁。


## 说明/提示

$3 \leq m,n \leq 2000$。

由于 mzc 大大十分着急，所以他只能等待 $1s$。

## 样例 #1

### 输入

```
5 6
.#..#.
....#.
d.....
#####.
m.....
```

### 输出

```
12```

# 题解

## 作者：_yjh (赞：28)

 **本题解是STL加广搜**


------------
**阅读本题解大于需要 3-5min ，[$\color{lightgreen}{\text{My blog }}$](https://www.luogu.org/blog/yjhqinghua/solution-p2084) 阅读效果更佳。**
- - - - - - -
## **介绍一下萌新难以理解的知识点**

___1.队列___

使用 **queue(队列)** 的步骤
- 引入头文件 **<queue>**
  ```cpp
#include<queue>
``` 
- 定义一个 **任何类型的队列** (如int)
  ```cpp 
queue <类型名> 变量名;
``` 
- 使用 **库中的函数** 对其进行操作
  ```cpp
//基本操作
/*定义一个队列变量q*/
#1 q.push(变量); 将变量插入队尾
#2 q.pop(); 弹出队首的元素
#3 q.front(); 访问队首元素
#4 q.back(); 访问队尾元素
#5 q.empty(); 判断队列是否为空,是则返回true
#6 q.size(); 返回队中元素的个数
``` 
 ___2.广度优先搜索___
  
  ```cpp
广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。 
                                                                                     ---By搜狗百科
```

 
 ------------
## **思路**
```
一道迷宫最短路的模板题。
我这是一种标准的 STL队列+广搜 的做法。

  ```


------------
## **Code(杜绝抄袭，共建和谐洛谷)**
  
```cpp
#include<iostream>
#include<queue>
using namespace std;
struct Pos
{
    int x,y;
}; //坐标点定义
queue <Pos> q;
int n,m,x,y,tx,ty,dis[1001][1001],s_a,s_b,t_a,t_b;
const int dx[]={1,-1,0,0};
const int dy[]={0,0,1,-1};
char mp[1001][1001];
bool vis[1001][1001]; //方向等变量的定义
int bfs(int sx,int sy)
{
    q.push((Pos){sx,sy});
    vis[sx][sy]=true;
    while(!q.empty())
    {
        x=q.front().x;
        y=q.front().y; 
        q.pop();  //弹出队列
        if(mp[x][y]=='m') return dis[x][y];
        for(int i=0;i<4;i++)
        {
            tx=x+dx[i];
            ty=y+dy[i];
            if(tx<=0||tx>n||ty<=0||ty>m) continue;
            if(mp[tx][ty]=='#'||vis[tx][ty]==true) continue; //不符合条件，跳过
            dis[tx][ty]=dis[x][y]+1;
            vis[tx][ty]=true;
            q.push((Pos){tx,ty});
        }
    }
    return -1;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
        	cin>>mp[i][j];
        	if(mp[i][j]=='d')
        	{
        		s_a=i;
        		s_b=j; //获取起点坐标
			}
		}
    int c;
    c=bfs(s_a,s_b);
    if(c==-1)cout<<"No Way!"<<endl;
	else cout<<c<<endl; //这里可以压缩一下 
    return 0;
}
```
### [运行时间 969ms，空间20.64mb](https://www.luogu.org/record/24667709)
------------

附赠给大家一个广搜模板：
  ```cpp
int bfs(int sx,int sy)
{
    q.push((Pos){sx,sy}); //起点加入队列
    vis[sx][sy]=true; //标记
    while(!q.empty()) 
    {
        x=q.front().x;
        y=q.front().y; //获取起始坐标
        q.pop(); //弹出队列
        if(符合条件) return ans(答案); 
        for(int i=0;i<走法;i++)
        {
            tx=x+dx[i];
            ty=y+dy[i];
            if(符合条件) continue;
            if(符合条件) continue; //符合条件跳过循环
            /*
                           可行,执行该部分语句
                                                      */
            q.push((Pos){tx,ty}); //加入队列
        }
    }
}
```


------------
## 最后给大家推荐几道搜索的题
                              
[P1443 马的遍历](https://www.luogu.org/problem/P1443)
                              
[P1746离开中山路](https://www.luogu.org/problem/P1746)
                          
[P1747好奇怪的游戏](https://www.luogu.org/problem/P1747)
         


  


---

## 作者：MY（一名蒟蒻） (赞：15)

### 原创作品，谢谢支持！

看了题解区各位大佬的做法，蒟蒻的窝表示看不太懂（因为窝太蒻了，煤油针对某篇题解的意思）。简单地说，这是一道**广搜**打卡题，刚学广搜的窝就想水一波题解，帮助和窝一样的萌新学习广搜，同时帮助自己加深印象。

---
**思路：**

1. 将出发点作为当前点加入队列；
2. 从当前点向四个方向拓展，将遍历到的所有状态加入队列；
3. 若遍历到终点，退出循环，输出答案（用step储存），结束程序；
4. 否则将队首出队，更新当前点，重复2，直到搜索到终点；
5. 若无法搜到终点，输出无解。

---

**详细注释见代码**

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
//定义队列，x储存行，y储存列，step存步数
struct note{int x,y,step;}que[4000010];
//定义记录数组,n,m,和出发点
int book[2010][2010],n,m,x,y;
char home[2010][2010];//地图
int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//方向数组
bool f;
int main()
{
	scanf("%d %d",&n,&m);//读入
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) 
		{
			cin >> home[i][j]; 
			if(home[i][j] == 'm') {x=i; y=j;} //记录出发点
		}
	int head=1,tail=1;
	que[tail].x=x;que[tail].y=y;que[tail].step=0;//将出发点入队
	tail++;book[x][y]=1;//标记状态
	while(head < tail)
	{
		for(int i=0;i<4;i++)
		{
			int nx=que[head].x+next[i][0];
			int ny=que[head].y+next[i][1];
            		//越界退出
			if(nx < 1 || nx > n || ny < 1 || ny > m) continue;
			if(home[nx][ny] != '#' && !book[nx][ny])//未遍历到当前点
			{
				book[nx][ny]=1;//标记为已遍历
				que[tail].x=nx;que[tail].y=ny;//将当前点入队
				que[tail].step=que[head].step+1; 
				tail++;
			}
			if(home[nx][ny] == 'd') {f=true; break;}//找到终点，退出
		}
		if(f) break;
		head++;//将队首出队
	}
    	//输出
	if(f) printf("%d",que[tail-1].step);//这里为什么要tail-1，请读者诸君思考
	else printf("No Way!");
	return 0;
}
```

---

### 感谢您的阅读，祝您早日AK IOI！

---

## 作者：Sun_Qixuan (赞：6)

#### 相信各位同志发现，这一道题是一个标准的BFS

#### 进入正题......

```cpp
#include <bits/stdc++.h>

using namespace std;

char mp[2000][2000];int vis[2000][2000],next[4][2]={{-1,0},{1,0},{0,-1},{0,1}};//定义地图，vis是记录走过的格子。 
//next是走下一步的坐标变化 
int cnt,flag=0;//定义步数和判断是否到达终点的变量 

struct Node//结构体，定义一个节点 
{
	int x,y,s;//定义这一个节点的坐标(x,y)，以及走到这个节点的步数。 
	
	Node(int _x,int _y,int _s)
	{
		x=_x;y=_y;s=_s;
	}//这里只是一种简洁的方法，也可以直接在BFS（）里赋值 
};

int BFS()//广搜函数 
{
	queue <Node> v;int n,m,sx,sy;cin>>n>>m;
	//定义一个STL库里的队列，和地图长宽以及起始地点 
	for(int i=0;i<n;i++) 
	    for(int j=0;j<m;j++)
	    {
	        cin>>mp[i][j];//输入地图 
			
			if(mp[i][j]=='m')
			{
				sx=i;sy=j;//如果发现了起点那就将起始地点变量赋值 
			} 
        }
    Node temp_cci(sx,sy,0);v.push(temp_cci);//将起始地点压入队列 
    
    while(!v.size()==0) 
    {
    	Node head=v.front();v.pop();//将这一个节点记录到head里，准备往下搜索 
    	
    	if(mp[head.x][head.y]=='d')//如果head已经是终点 
    	{
    		cnt=head.s;flag=1;break;//那就给这两个变量赋值，并break 
		}
		
		for(int i=0;i<4;i++)//往下搜索 
		{
			int tx=head.x+next[i][0];//往一个方向的x坐标变化 
			int ty=head.y+next[i][1];//往一个方向的y坐标变化
			//结成一个点 
			if(tx<0||ty<0||tx>=n||ty>=m||vis[tx][ty]==1||mp[tx][ty]=='#') continue;
			//如果超出边界，点已经被走过，是障碍，全部跳过(毫不留情) 
			Node temp(tx,ty,head.s+1);v.push(temp);vis[tx][ty]=1;//如果没有被跳过，那就把点压入队列，准备下一次搜索 
		}
	}
}

int main()
{
	BFS(); 
	
	if(flag) cout<<cnt;//如果找到了终点，输出步数 
	
	else cout<<"No Way!";//没有？输出No Way(注意N和W要大写) 
}
```
### 请勿抄袭，否则..
### ---------------祝通过---------------

---

## 作者：mulberror (赞：3)

既然没有用stl的题解，那么我就来一发stl(queue)的题解。

我们把queue中定义每一个单元的类型设置成（以下这个玩意）：

```cpp
struct block{
    int x,y,step;//x，y代表坐标，step表示走到这一格的最少个数
};
```
--------

那么接下来就是简单的宽（广）搜了，大致思路：每一次去取出队首，并弹出，在用队首来更新旁边的点。

**注：c++的队列本身就是循环队列，所以不需要考虑mle的问题，而且代码写起来还挺短的。**

```cpp
#include<bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
struct block{
	int x,y,step;
};//结构体
queue<block>q;//设置队列
const int dx[4]={0,-1,0,1};
const int dy[4]={1,0,-1,0};//方向数组
int n,m,sx,sy,vis[2005][2005];//vis减少搜索次数
int mp[2005][2005];
void bfs() {
	ms(vis,1);
	while (!q.empty()) q.pop();
	q.push({sx,sy,0}); vis[sx][sy]=0;
	while (!q.empty()) {
		block kkk=q.front();//取队首，不要吐槽变量名
		q.pop();
		for (int i=0;i<4;i++) {
			int nx=dx[i]+kkk.x,ny=dy[i]+kkk.y;
			if (mp[nx][ny]==1||nx<1||nx>n||ny<1||ny>m||!vis[nx][ny]) continue;
			if (mp[nx][ny]==2) { printf("%d\n",kkk.step+1); return;}//判断是否合法
			vis[nx][ny]=0;
			q.push({nx,ny,kkk.step+1});//再次塞进队列中
		}
	}
	printf("No Way!\n");//如果没有答案，那么输出noway。
}
int main() {
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) {
		for (int j=1;j<=m;j++) {
			char ch; cin>>ch;
			if (ch=='m') sx=i,sy=j;
			if (ch=='#') mp[i][j]=1;
			if (ch=='d') mp[i][j]=2;
		}
	}
	bfs();
	return 0;
}
```

---

## 作者：空清虚 (赞：2)

蒟蒻之又回来搜索。。。

$\color{white}\texttt{啊！这道题怎么这么难！高性能！2000 * 2000的迷宫！搜索能过？？？}$

这是第一感觉。。。（感觉自己越发菜）

~~管他呢，打完bfs再说~~

然后进入了bfs，~~一些基础判断和过程跳过~~

过程不重要，重要的是一个神秘的处理

首先，我们明白，bfs就是把每一个状态再产生新的状态，直到得到答案，或是没有答案退出

在产生状态的过程中，先到先得

什么意思呢？

如：你有个状态可以在第五个单位时间到达（5,5），但是，有另外一个状态在第七个单位时间到达（5,5），那么，至少后一个状态绝对不是最优解，可以直接将其删除。那么，最早到的肯定是该位置到终点的最优解。

在搜索的过程中，先出现的肯定是排在前面处理的，根据上文，我们可以直接对该位置进行bool二维数组标记（排除反复横跳等浪费时间且找不到最优解的状态），后面的非最优状态皆会因bool数组而删除掉，从而大大减少时间复杂度，~~有那么一丢丢像SPFA？~~（然后一道黄题就。。。）

不对，还没有A！！！

以下为本人亲身经历：

啊啊啊啊！bfs正常啊！没有问题啊！

等一下，没有答案是怎么处理的？ 。。。。。。

默默在return；上加上printf（“No Way!”）；

（太久没有打迷宫题引发的bfs惨案QAQ~~~）在这里提醒一下大家！

下面奉上~~神圣的dalao的~~代码：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
char map[2100][2100];
int n,m,sx,sy,xx[4]={1,0,-1,0},yy[4]={0,1,0,-1};
bool p[2100][2100];
void bfs()
{
    queue<int>x,y,b;
    x.push(sx),y.push(sy),b.push(0);
    while (!x.empty())
    {
        int dx=x.front(),dy=y.front(),by=b.front();
        x.pop(),y.pop(),b.pop();
        for (int i=0;i<4;i++)
        {
            int fx=dx+xx[i],fy=dy+yy[i];
            if (p[fx][fy]||map[fx][fy]=='#'||fx<1||fx>n||fy<1||fy>m)
                continue;
            if (map[fx][fy]=='d')
            {
                printf("%d",by+1);
                return;
            }
            else
            {
                p[fx][fy]=1;
                x.push(fx),y.push(fy),b.push(by+1);
            }
        }
    }
    printf("No Way!");
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
        {
            scanf("%1s",&map[i][j]);
            if (map[i][j]=='m') sx=i,sy=j;
        }
    bfs();
    return 0;
}
```

~~惬意地水了一篇题解~~

再三申明我的原则（在前面的题解底部看）

---

## 作者：ALSaoBen (赞：2)

##既然没有人打手写队列,那我就来水一波手写队列.
不多BB
直接干货带注释
```cpp
#include<bits/stdc++.h>
using namespace std ;

int n,m;
char ll[2006][2006];
int a[2006][2006];
int u[4]={0,-1,0,1};
int v[4]={-1,0,1,0};
int walk[2006][2006];
int que[4000006][3];

inline int read()//读优不解释
{
	register int res=0,flag=1;
	register char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		{
			flag=-1;
		}
		ch=getchar();
	}
	while(isdigit(ch))
	{
		res=(res<<3)+(res<<1)+(ch^48);
		ch=getchar();
	}
	return flag*res;
}

inline void bfs(register int x,register int y)
{
	register int head=0,tail=1;
	que[tail][0]=x;
	que[tail][1]=y;
	que[tail][2]=0;//在传统广搜手写队列基础上开一个第三项,记录步数
	walk[x][y]=1;
	do
	{
		head++;
		register int dx=que[head][0];
		register int dy=que[head][1];
		register int step=que[head][2];//步数与坐标一起进行处理
		for(register int i=0;i<=3;++i)
		{
			register int uu=dx+u[i];
			register int vv=dy+v[i];
			if(walk[uu][vv]==0&&uu<=n&&uu>0&&vv<=m&&vv>0)
			{
				walk[uu][vv]=1;
				tail++;
				que[tail][0]=uu;
				que[tail][1]=vv;
				que[tail][2]=step+1;//更新步数
				if(a[uu][vv]==1)
				{
					printf("%d\n",step+1);//注意要加1
					return ;
				}
			}
		}
	}while(head<tail);
	printf("No Way!\n");
	return ;
}

int main()
{
	register int x,y;
	n=read();
	m=read();
	for(register int i=1;i<=n;++i)
	{
		for(register int j=1;j<=m;++j)
		{
			cin>>ll[i][j];
			if(ll[i][j]=='m')
			{
				x=i;
				y=j;
			}
			if(ll[i][j]=='#')
			{
				walk[i][j]=1;
			}
			if(ll[i][j]=='d')
			{
				a[i][j]=1;
			}
		}
	}
    
	bfs(x,y);
    
	return 0;
}
```

---

## 作者：野原葵 (赞：2)

这是一道简单的BFS
```pascal
type data=record
            pre:longint;
            x,y:integer;
          end;
var i,j,n,m,t,h,x1,y1:longint;
    a:array[0..2001,0..2001] of char;
    f:array[1..2000003] of data;
    d:array[1..4,1..2] of longint=((1,0),(0,1),(-1,0),(0,-1));
procedure scanf;
begin
  readln(n,m);
  for i:=1 to n do
  begin
    for j:=1 to m do 
    begin 
      read(a[i][j]);
      if a[i][j]='m' then
      begin x1:=i;y1:=j;end;//找起点
    end;
    readln;
  end;
end;
procedure bfs;
var i,xx,yy:longint;
begin
  f[1].x:=x1;f[1].y:=y1;t:=1;a[x1][y1]:='#';
  while h<>t do
  begin
    inc(h);
    for i:=1 to 4 do
    begin
      xx:=f[h].x+d[i,1];yy:=f[h].y+d[i,2];
      if (xx>=1)and(xx<=n)and(yy>=1)and(yy<=m)and(a[xx][yy]<>'#') then 
      begin 
        inc(t);
        f[t].x:=xx;f[t].y:=yy;f[t].pre:=f[h].pre+1;
        if a[xx][yy]='d' then begin writeln(f[t].pre);halt;end;//如果找到就输出
        a[xx][yy]:='#';//标记为走过
      end;
    end;
  end;
end;
begin
  scanf;
  bfs;
  writeln('No Way!');
end.
```

---

## 作者：leiron (赞：2)

//看到楼下代码都很长，萌新感到很害怕，并决定水一发题解

很明显，这是一道bfs走迷宫题，不过目标点不止一个，引发了我们许多遐想（雾

不过很快就能想到既然我们把“#”和走过的点标记成1，何不对目标点做些标记？

上代码

```cpp
#include<iostream>
using namespace std;
int vis[3000][3000],m,n,rx,ry,x,y,dx[6]={1,0,-1,0},dy[6]={0,1,0,-1}；
int q[1000100][3];//访问数组，方向数组和手动队列，队列一定要开准 大了mle 小了re 
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        char s;cin>>s;
        if(s=='#')vis[i][j]++;
        if(s=='d')vis[i][j]=1<<10;//我们可以把目标设成一个好认的数 
        if(s=='m'){
            x=i;y=j;//起始点 
        }
    }
    q[1][0]=x;q[1][1]=y;q[1][2]=0;//初始化 
    int head=0,tail=1;
    while(head<tail)//bfs开始 
    {
        head++;
        for(int i=0;i<4;i++)
        {
            int lx=q[head][0]+dx[i],ly=q[head][1]+dy[i];
            if(vis[lx][ly]>=10)//判断是否为标记的目标 
            {
                cout<<q[head][2]+1;return 0;
            }
            if(!vis[lx][ly]&&lx>0&&ly>0&&lx<=n&&ly<=m)//判断能否访问 
            {
                vis[lx][ly]++;
                tail++;
                q[tail][0]=lx;q[tail][1]=ly;q[tail][2]=q[head][2]+1;//入队 
            }
        }
    }
    cout<<"No Way!";//没找到人 不要忘了这句 
    return 0;
}//萌新学识浅，还请多多指教
```

---

## 作者：空·白 (赞：1)

一题非常简单的广搜，尽管我一开始忘了无解的情况，但是这并不影响我AC（~~实际上还是有一些影响的~~）。

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int t=0,n,M;
int f[2010][2010];	//存地图；
int ans[2010][2010];	//存答案
int d[4][2]={{1,0},{0,1},{-1,0},{0,-1}};	//每次走的方向
queue<int > que;	//横坐标
queue<int > q;		//纵坐标
void bfs(int x,int y)
{
	int xx,yy;
	while(que.empty()==0)
	{	
		x=que.front();
		y=q.front();
		que.pop();
		q.pop();
		if(f[x][y]==2)		//判断找到了没有
		{
			cout<<ans[x][y];
			t=1;	//表示找到了
			break;
		}
		for(int i=0;i<4;i++)
		{
			xx=x+d[i][0];
			yy=y+d[i][1];
			if(f[xx][yy]!=1&&xx>=0&&xx<=n-1&&yy>=0&&yy<=M-1&&ans[xx][yy]==0)
			{
				que.push(xx);
				q.push(yy);
				if(f[x][y]==0)
				{
					f[x][y]=1;
				}
				ans[xx][yy]=ans[x][y]+1;
			}
		}
	}
	if(t==0)	//无解
	{
		cout<<"No Way!";
	}
}
int main()
{
	int x,y;
	string s;
	cin>>n>>M;
	for(int i=0;i<=n-1;i++)
	{
		cin>>s;
		for(int j=0;j<=M-1;j++)		//初始化地图
		{
			if(s[j]=='.')
			{
				f[i][j]=0;
			}
			if(s[j]=='#')
			{
				f[i][j]=1;
			}
			if(s[j]=='d')
			{
				f[i][j]+=2;
			}
			if(s[j]=='m')
			{
				f[i][j]=1;
				x=i;
				y=j;
			}
		}
	}
	que.push(x);
	q.push(y);
	bfs(x,y);
}
```


---

## 作者：royzhu (赞：1)

这道题并不难 （dalao都这么觉得）

蒟蒻的我都可以一遍AC

思路：

跑一遍宽（广）搜

```cpp
#include<cstdio>
int sx,sy,ex,ey,n,m;//sx,sy是起点坐标，ex，ey是终点坐标
char a[2100][2100];//表
struct lol{int x,y,t;} d[4100000];
int dx[4]={0,1,0,-1};//x的偏移量 
int dy[4]={1,0,-1,0};//y的偏移量 （两偏移量组成，上，下，左，
void dfs()
{
    int tou=1,wei=2;//tou记录当前点，wei记录当前点走的点 
    d[tou].x=sx;d[tou].y=sy;d[tou].t=0;//把初始点记录下来，把初始步刷0 
    while(tou!=wei) 
    {
        for(int i=0;i<4;i++)//四个方向 
        {
            int x=d[tou].x+dx[i];// 当前点x加偏移量 
            int y=d[tou].y+dy[i];// 当前点y加偏移量
            if(x==ex&&y==ey){printf("%d",d[tou].t+1);return;}//到终点输出 
            if(x>=1&&x<=n&&y>=1&&y<=m&&a[x][y]=='.')//如果当前点走的点没超n记录当前点走的点
            {
                a[x][y]='#';//封点 
                d[wei].x=x;d[wei].y=y;d[wei].t=d[tou].t+1;wei++;
            }
        }tou++;
    }
    printf("No Way!");//如果搜完还没到终点输出No Way!
}
int main()
{
    scanf("%d %d",&n,&m);//输入 
    for(int i=1;i<=n;i++)
    {
        scanf("%s",a[i]+1);//要用%s读，用%c读不行，%c会读回车 
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]=='m')sx=i,sy=j;//找起点 
            if(a[i][j]=='d')ex=i,ey=j;//找终点 
        } 
    }
    a[sx][sy]=1;//封起点 
    dfs();
}
//看完题解可以试试1746 离开中山路
```

---

## 作者：Nick丶12138 (赞：1)

/\*
楼下大神们代码都看不懂（我太蒻了）

所以就自己打一遍

思路如下：

全图找一次起点和终点

记录开始点和结束点的位置

搜索一遍就没了

\*/


```cpp
#include<cstdio>
#include<cstring>
char ma[2001][2001];//图 
int fx[4]={1,0,-1,0};//偏移量 
int fy[4]={0,1,0,-1};//同上 
struct node{int x,y,t;}q[4100000];//(x,y)坐标，c是步数 
int n,m,sx,sy,ex,ey;
void dfs()
{
    int tou=1,wei=2;//接下来几句就是一般的搜索了 
    q[tou].x=sx;q[tou].y=sy;//第一步在起点开始 
    q[tou].t=0;//走到起点需要0步 
    while(tou!=wei)
    {
        for(int i=0;i<4;i++)//四个方向可以走 
        {
            int xx=q[tou].x+fx[i];//xx等于当前步q[tou].x，fx[i]是偏移量 
            int yy=q[tou].y+fy[i];//同上理 
            if(xx==ex&&yy==ey){printf("%d",q[tou].t+1);return;}//如果走到重点，输出当前步数加1（因为走到终点也算一步），然后结束 
            if(xx<1||xx>n||yy<1||yy>m||ma[xx][yy]=='#') continue;//如果出界或者不能走，跳过 
            ma[xx][yy]='#';//走过了封路 
            q[wei].x=xx;//走 
            q[wei].y=yy;//走 
            q[wei].t=q[tou].t+1;//步数加一 
            wei++;//继续 
        }
        tou++;//继续 
    }
    printf("No Way!");//运行到这里证明找不到路了 
}
int main()
{
    scanf("%d %d",&n,&m);//输入 
    for(int i=1;i<=n;i++) scanf("%s",ma[i]+1);//输入 
    for(int i=1;i<=n;i++)//找起点终点，记录 
    {
        for(int j=1;j<=m;j++)
        {
            if(ma[i][j]=='m')
            {
                sx=i;
                sy=j;
            }
            if(ma[i][j]=='d')
            {
                ex=i;
                ey=j;
            }
        }
    }
    dfs();
    return 0;
}
```

---

## 作者：Lokawa (赞：0)

发现没有pascal题解，水一发

一道很典型的广搜


```cpp
const
dx:array[1..4] of longint=(0,1,0,-1);
dy:array[1..4] of longint=(1,0,-1,0);
var
n,m,i,j,h,t,x,y,x1,y1,x2,y2:longint;
f:array[1..4000000] of longint;
a:array[1..2000,1..2000] of boolean;
ch:char;
b:array[1..4000000,1..2] of longint;
begin
  readln(n,m);
  for i:=1 to n do
  begin
    for j:=1 to m do
    begin
      read(ch);
      if ch='#' then a[i,j]:=false else a[i,j]:=true;//用布尔数组存该点能否走到
      if ch='d' then
      begin
        x2:=i;
        y2:=j;
      end;//储存男家丁位置
      if ch='m' then
      begin
        x1:=i;
        y1:=j;
      end;//储存Mzc位置
    end;
    readln;
  end;
  h:=0;
  t:=1;
  f[t]:=0;
  b[t,1]:=x1;
  b[t,2]:=y1;
  while h<=t do//广搜begin
  begin
    inc(h);
    for i:=1 to 4 do
    begin
      x:=b[h,1]+dx[i];
      y:=b[h,2]+dy[i];//四个方向搜索
      if (x>0) and (y>0) and (x<=n) and (y<=m) and a[x,y] then//判断能否走到和是否走到过
      begin
        a[x,y]:=false;//标记已走过
        inc(t);
        b[t,1]:=x;
        b[t,2]:=y;
        f[t]:=f[h]+1;//进队列
        if (x=x2) and (y=y2) then
        begin
          writeln(f[t]);
          halt;
        end;//到达目的地输出，跳出程序
      end;
    end;
  end;
  writeln('No Way!');//广搜结束后还没跳出程序即证明无法到达
end.
一遍AC！
```

---

## 作者：doby (赞：0)

bfs+hash过关……

不是很难……

```cpp
#include<iostream>
#include<cstdlib>
using namespace std;
int sum,data[2000007],list[2000007]={0},next[2000007]={0},u,tim[3000000],qs[3000000],a[2009][2009],head=0,tail=1,n,m,t,c,cnt=0,x,y,x1,y1,x2,y2,x3,y3,fx[4]={1,0,-1,0},fy[4]={0,1,0,-1};
char k;
int hash(int h)//hash
{
    sum=abs(h%1000007),u=list[sum];
    while(u){if(data[u]==h){return 0;}u=next[u];}
    data[++cnt]=h,next[cnt]=list[sum],list[sum]=cnt;
    return 1;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>k;//输入+处理
            if(k=='#'){a[i][j]=1;}
            if(k=='.'){a[i][j]=0;}
            if(k=='m'){x1=i,y1=j;}
            if(k=='d'){x2=i,y2=j;}
        }
    }
    qs[1]=x1*10000+y1,tim[1]=0;//存入初始状态
    while(head<tail)
    {
        head++,x=qs[head]/10000,y=qs[head]-x*10000,t=tim[head];//取出状态
        for(int i=0;i<4;i++)
        {
            x3=x+fx[i],y3=y+fy[i];//走出一步
            if(x3<1||x3>n||y3<1||y3>m||a[x3][y3]==1){continue;}//出界+障碍
            if(x3==x2&&y3==y2){cout<<t+1;return 0;}//得出结果
            if(hash(x3*10000+y3)){tail++,qs[tail]=x3*10000+y3,tim[tail]=t+1;}//入队
        }
    }
    cout<<"No Way!";
    return 0;
}
```

---

## 作者：Kwork (赞：0)

简单而典型的广搜，基础题目，不要问我为什么交了那么多次【-\_-】，我太弱了。

好吧，没什么技巧，唯一要注意的是队列不要开太大，免得MLE。

真的没什么好说的。让我水一发。------

---------------------------------------------------------------------------------------------------------------------





```cpp
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int maxn=2000+20;
int n,m,map[maxn][maxn],d[maxn][maxn];
int que[(maxn*maxn)][3],head,tail;
int move[20][4],tx,ty,sx,sy;
void write(int n){
    if(n>9) write(n/10);
    putchar((n % 10)+'0');
    return;
}
void init(){
    move[1][1]=1,move[1][2]=0;
    move[2][1]=-1,move[2][2]=0;
    move[3][1]=0,move[3][2]=1;
    move[4][1]=0,move[4][2]=-1;
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n+1;i++)
        for(int j=0;j<=m+1;j++){
            map[i][j]=-1;
            d[i][j]=1234567890;
        }
    char s[maxn];
    for(int i=1;i<=n;i++){
        scanf("%s",s);
        for(int j=0;j<m;j++){
            if(s[j]=='.') map[i][j+1]=0;
            if(s[j]=='d') map[i][j+1]=0,tx=i,ty=j+1;
            if(s[j]=='m') map[i][j+1]=0,sx=i,sy=j+1;
        }
    }
    return;
}
void tool(int x,int y,int d){
    printf("%d %d %d\n",x,y,d);
}
void bfs(){
    head=tail=0;
    d[sx][sy]=0;
    que[tail][1]=sx,que[tail][2]=sy;
    ++tail;
    while(head<tail){
        int x=que[head][1];
        int y=que[head][2];
        if(x==tx && y==ty){
            write(d[x][y]);
            return;
        }
        ++head;
        //tool(x,y,d[x][y]);
        for(int i=1;i<=4;i++){
            int px=x+move[i][1];
            int py=y+move[i][2];
            if(map[px][py]==-1) continue;
            if(d[px][py]>(d[x][y]+1)){
                d[px][py]=d[x][y]+1;
                que[tail][1]=px;
                que[tail][2]=py;
                ++tail;
            }
        }
    }
    printf("No Way!");
    return;
}
void test(){
    putchar('\n');
    printf("%d %d %d %d",sx,sy,tx,ty);
}
int main(){
    init();
    bfs();
    //test();
    return 0;
}
```

---


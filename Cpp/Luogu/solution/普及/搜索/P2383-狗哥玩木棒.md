# 狗哥玩木棒

## 题目背景

狗哥又趁着语文课干些无聊的事了...


## 题目描述

现给出一些木棒长度，那么狗哥能否用给出的木棒(木棒全用完)组成一个正方形呢？


## 说明/提示

狗哥快抓狂了


## 样例 #1

### 输入

```
3
4 1 1 1 1 
5 10 20 30 40 50 
8 1 7 2 6 4 4 3 5```

### 输出

```
yes
no
yes```

# 题解

## 作者：DDOSvoid (赞：24)

明显DFS

提供一种特殊的dfs思路

既然要拼成一个正方形，那么所有木棍的长度总和一定能被4整除，如果不能，直接输出“no”

注释和思路都在代码里

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxn 21
using namespace std;
int w[5],a[maxn],t,n,sum;
bool f;
void dfs(int q){
    if(f)return ;
    if(q==n+1){//如果能搜到这最后一层，则代表可以组成正方形 
        f=1;
        return ;
    }
    for(int i=1;i<=4;i++)
        if(w[i]>=a[q]){
            w[i]-=a[q];
            dfs(q+1);
            w[i]+=a[q];
        }
}
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        sum=0;f=0;
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]),sum+=a[i];
        if(sum%4){
            cout<<"no"<<endl;
            continue;
        }
        for(int i=1;i<=4;i++)
            w[i]=sum/4;//w数组代表正方形的4条边 
        sort(a+1,a+n+1,greater<int>());//一定要从大到小排序，先放长度大的木棍，一种优化思想，排序0ms，不排序的40ms 
        dfs(1);
        if(f)cout<<"yes"<<endl;
        else cout<<"no"<<endl;
    }
}
```

---

## 作者：BlueArc (赞：13)

本题有两种搜索对象:

1.木棒,需记录拼好的木棒数，当前的和，不太好写

# 2.正方形,记录条边的长度，非常好写，很方便剪枝

所以搜正方形的话代码又短思维难度又小

还有一个细节，一般来说，搜索前/\*排序\*/一下可以使条理清晰，而且在本题速度也会快

因为从大到小排序的话可以尽早判断到不合法，及时退出

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
int A[25];
int m;
ll sum;//这个sum记录的是正方形的边长 
bool dfs(int now,ll a,ll b,ll c,ll d)
{
 if(now==m+1) {if(a==b&&b==c&&c==d&&a==sum) return true;}//木棒用完了，判断 
 if(a>sum||b>sum||c>sum||d>sum) return false;//某一边大于正方形边长了 
 if(dfs(now+1,a+A[now],b,c,d)) return true;//枚举当前木棒加到那条边上 
 if(dfs(now+1,a,b+A[now],c,d)) return true;
 if(dfs(now+1,a,b,c+A[now],d)) return true;
 if(dfs(now+1,a,b,c,d+A[now])) return true;
 return false;  
}
int main()
{
 int T;
 cin>>T;
 while(T--)
 {
  cin>>m;
   sum=0;
  for(int i=1;i<=m;i++) {cin>>A[i];sum+=A[i];}
  if(sum%4) {cout<<"no"<<endl;continue;}//Impossible 
  else sum/=4;
  sort(A+1,A+1+m,greater<int>());//从大到小排序 
  bool ok=dfs(1,0,0,0,0);
  if(ok) cout<<"yes"<<endl;
  else cout<<"no"<<endl;         
 }   
 return 0; 
}

```

---

## 作者：yingjz (赞：5)

呵呵，这是![搜狗截图20180930164005.png](https://i.loli.net/2018/09/30/5bb08c86e91b0.png)的题目，其实是一道暴搜题，相信大家都会写。

但是，它之所以能被评为![搜狗截图20180930164005.png](https://i.loli.net/2018/09/30/5bb08c86e91b0.png)是因为纯粹的暴搜是无法过了这题的，需要加一些 **剪枝**。

---

![搜狗截图20180930164758.png](https://i.loli.net/2018/09/30/5bb08dca30930.png)

这是我的提交记录，可以看到，从一开始的 `TLE` 到 `AC`，时间差距是巨大的，甚至同样 `AC` 的代码也有 5 倍时间的差距。这都是剪枝的操作所导致的。

---

先来讲讲怎么从 `TLE` 到 `AC`，这是我暴搜最初的版本：
```c++
bool dfs(int t, int l1, int l2, int l3, int l4){ //t 表示当前到第几个棍子了，l1,l2,l3,l4分别是正方形的四条边的长度，返回值表示是否可行
    if (t == n + 1){return (l1 == l2 && l2 == l3 && l3 == l4);}
    if (dfs(t+1, l1 + a[t], l2, l3, l4)) return true;
    if (dfs(t+1, l1, l2 + a[t], l3, l4)) return true;
    if (dfs(t+1, l1, l2, l3 + a[t], l4)) return true;
    if (dfs(t+1, l1, l2, l3, l4 + a[t])) return true;
    return false;
}
```

这个暴搜没有经过任何优化，我们需要考虑优化的动机。我们发现，有一些状态是 **没有必要枚举下去的**，举个例子，如果 $sum = \Sigma a_i$，$sum$ 不是 4 的倍数，那么显然不能拼成正方形；进一步，如果 `l1,l2,l3,l4` 中的某个数大于 $sum \over 4$，显然应该返回 `false`，没有必要枚举下去。

加了这两个优化，代码就 `AC` 了哈。

---

还能不能进一步优化呢？
思考刚才那个剪枝，因为剪枝肯定是越早越好，如果我们把棍子按照长度降序排列，那么剪枝的时间肯定会有所提前。这个优化可以把时间优化到原来的 $1 \over 5$。
至于我的那个 `CE`，是因为降序排序时 `sort(a+1, a+1+n, greater<int>() )` 写成了 `sort(a+1, a+1+n, greater<int> )`，话说难道我以前都写错了QAQ？

---

## 作者：公主殿下MIKU (赞：5)

dfs作为暴力算法，有时候剪枝好了可以骗很多分，因此一定要多思考剪枝，注释够详细了吧QAQ~
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[21],nxt[21],lenth,sum;
bool vis[21];
int flag;
bool cmp(int x,int y) {
	return x>y;
}
void dfs(int k,int last,int rest) {//k为拼到第几根，last为上次用的是第几根木棍，rest表示该木料剩余多少 
	int i;
	if(!rest) {
		if(k==4) {
			flag=1;
			return ;
		}
		for( i=1; i<=m; i++)
			if(!vis[i])
				break;
		vis[i]=1;
		dfs(k+1,i,lenth-a[i]);
		vis[i]=0;
		if(flag) return ;
	}
	int l=last+1,r=m,mid;//二分查找第一根比剩余短的木棍 
	while(l<r) {
		mid=(l+r)/2;
		if(a[mid]<=rest) r=mid;
		else l=mid+1;
	}
	for( i=l; i<=m; i++) {
		if(!vis[i]) {
			vis[i]=1;
			dfs(k,i,rest-a[i]);
			vis[i]=0;
			if(flag) return ;
		}
	}

}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>m;
		sum=0;
		for(int j=1; j<=m; j++) {
			cin>>a[j];
			sum+=a[j];
		}
		if(sum%4!=0) {//如果不能被4整除，边长一定不是整数，肯定拼不出
			printf("no\n");
			continue;
		}
		fill(vis+1,vis+21,0);//多组数据，要初始话 
		sort(a+1,a+m+1,cmp);//按从大到小排列，先用大的，小的肯定比大的灵活，能不用就不用，贪心思想
		for(int j=1; j<=m; j++)
			nxt[j]=j;
		for(int j=m-1; j; j--)
			if(a[j]==a[j+1]) nxt[j]=nxt[j+1];//因为木棍可能有相同的，所以开个nxt数组，一根不行的话可以直接去找下一根不一样长度的
		lenth=sum/4;//正方形边长
		if(a[1]>lenth) {//如果第一根木棍就比边长大，也拼不出
			printf("no\n");
			continue;
		}
		flag=0;
		vis[1]=1;
		dfs(1,1,lenth-a[1]);
		vis[1]=0;
		if(flag==1) printf("yes\n");
		else printf("no\n");
	}
}
```

---

## 作者：Zhou_SY (赞：4)

一看题目直接打了一个暴力模拟QWQ

思路：每条边都试

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int a[21];
bool findanswer;
void dfs(int p,int x,int y,int z,int w)
{
	if(findanswer)return;
	if(p>n)
	{
		if(x==y&&y==z&&z==w)printf("yes\n"),findanswer=1;
		return;
	}
	
	dfs(p+1,x+a[p],y,z,w);
	dfs(p+1,x,y+a[p],z,w);
	dfs(p+1,x,y,z+a[p],w);
	dfs(p+1,x,y,z,w+a[p]);
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		findanswer=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		dfs(2,a[1],0,0,0);
		if(!findanswer)printf("no\n");
	}
	return 0;
}
```
正在骄傲的我看到了两个TLE~~QAQ~~

拿了80分的我马上想到第一个剪枝的方法：

---
用sum累加和，因为边长都是相等的正整数，所以sum必定是4的倍数
---

代码如下：

```cpp
for(int i=1;i<=n;i++)scanf("%d",&a[i]),sum+=a[i];
if(sum%4)
{
	printf("no\n");
	continue;
}
```
再次提交，T2硬是跟我过不去，再次TLE

于是又诞生了第二个剪枝的方法：

---
既然sum是4的倍数，那么sum/4也就是正方形的边长，如果枚举的四条边里面有一条大于sum/4就return掉，大大减少了运行时间
---

代码如下改正：

```cpp
if(findanswer||x>sum||y>sum||z>sum||w>sum)return;
```

放上AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int a[21],sum;
bool findanswer;
void dfs(int p,int x,int y,int z,int w)
{
	if(findanswer||x>sum||y>sum||z>sum||w>sum)return;
	if(p>n)
	{
		if(x==y&&y==z&&z==w)printf("yes\n"),findanswer=1;
		return;
	}
	
	dfs(p+1,x+a[p],y,z,w);
	dfs(p+1,x,y+a[p],z,w);
	dfs(p+1,x,y,z+a[p],w);
	dfs(p+1,x,y,z,w+a[p]);
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		sum=0;
		findanswer=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]),sum+=a[i];
		if(sum%4)
		{
			printf("no\n");
			continue;
		}
		sum/=4;
		dfs(1,0,0,0,0);
		if(!findanswer)printf("no\n");
	}
	return 0;
}
```

代码已经检验过，请放心食用

![](https://cdn.luogu.com.cn/upload/image_hosting/40ouf6bj.png)

---

## 作者：EDqwq (赞：3)

[蒟蒻的博客](https://www.luogu.com.cn/blog/294562/)

### 本蒟蒻写题解的经验不多，如有错误请多多包涵！  

#### 裸dfs + 一丁点剪枝（甚至可以说连剪枝都不是）

#### 看着大家在那里疯狂的剪枝。我只想说，你们太惨了，剪了半天枝根本没用。

首先审题要求拼成正方形，我们回想一下正方形有什么特点：

1. 四个角是直角

1. 四个边相等

第一个好像没啥用，第二个就有用了！我们可以直接判断所有边的和是否是 4 的倍数，如果否，输出 no 。

本人测试过，不加这个 "剪枝" 会 WA 一个点。

那么这个剪枝的代码是什么呢？

```
if(all % 4 != 0){
	cout<<"no"<<endl;
	continue;
}
```

是的，就只有这么一点。

好了，坑点解释完了，下面我们就来讲思路吧：

1. 直接深搜，用一个数组存储当前每个边的长度，如果剩下的长度大于当前我们正在搜的边就直接跳过，也就是 **if(sum - bian[i] < a[dep])continue;** (当然可以不用 continue ，直接判断即可）

1. 当所有边都搜完了之后，也就是 dep > m 之后，我们标记不让它继续搜，并且return。

1. 然后判断是否被标记，被标记代表可以，输出 "yes" 否则输出 "no"。

1. 最后记住要初始化和 return 0 。其实对于后者，前者更加重要。

ok ，坑点说完了，思路告诉你们了，下面我们就

### 上代码啦！(更加详细解释在代码里面！)

~~蒟蒻的代码~~

```
#include<bits/stdc++.h>//万能头

#define M 1000// define 定义数据大小

using namespace std;

int t;//数据组数 
int m,a[M + 5];//如题意 
int all;//所有边的和 
int sum;//all / 4（每边长度） 
int bian[5];//每个边现在多少 
bool flag;//搜完了吗 (标记)

void dfs(int dep){//基本深搜
	if(flag)return ;//如果被标记就返回
	if(dep > m){//如果搜完了就标记并且返回
		flag = true;
		return ;
	}
	for(int i = 1;i <= 4;i ++){//四条边，1到4深搜
		if(sum - bian[i] >= a[dep]){//如果剩余的可以放下这条边
			bian[i] += a[dep];//放下
			dfs(dep + 1);//递归
			bian[i] -= a[dep];//回溯
		}
	}
}

int main(){
	cin>>t;//多组数据
	for(int i = 1;i <= t;i ++){
		all = sum = 0;//初始化（下面一行也是）
		flag = false;
		cin>>m;
		for(int j = 1;j <= m;j ++)cin>>a[j],all += a[j];//按要求输入
		if(all % 4 != 0){// "剪枝" ，如果不是 4 的倍数就直接输出 "no"
			cout<<"no"<<endl;
			continue;
		}
		sum = all / 4;
		dfs(1);//深搜
		if(flag)cout<<"yes"<<endl;//判断是否标记
		else cout<<"no"<<endl;
	}
	return 0;//养成好习惯，你懂滴
}
```

好了，这篇题解到此结束，感谢大家的支持，是否可以给个赞呢？

###### ~~求给过~~

~~你咋还不走，题解结束了！~~

---

## 作者：高木木 (赞：2)

###  **此题为DFS题，~~对于你们这些神犇来说应该是很简单的~~我剪枝剪了很长时间！**！

### 我的思路是：

### 设总木棍长为 n ，如果能组成正方形，那么正方形的边长一定是总木棍长 n 的四分之一，因此只需要搜索三次看能否组成四个等长的边（边长为 n/4 ）( 有三个边能组成了，其余的木棍肯定也能组成第四条边。)，能的话就输出 “yes” ，不能就输出 “no” 。

### 详细解释在代码中（建议从主函数往后慢慢看）：


```cpp

// 据说 inline 会加快速度（然而貌似没什么软用）。
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x)
{
	x=0;int p=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') p=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	x*=p;
}
int n,m,a[21],g;
bool vis[21],xx;//  xx 用来记录能否组成一个正方形的边。 vis 用来记录木棍是否用到过。
inline void dfs(int x,int y,int z)// x 表示当前用木棍组成的正方形边长。y 表示正方形实际边长。z 用来记录搜索的位置，可以加快速度。
{
	if(x==y)// 如果得到了正方形边长，直接退出搜索。
	{
		xx=1;// 记录是否组成。
		g=1;// 能组成则 +1，不能组成则 +0。
		return ;
	}
	for(int i=z;i<=m;i++)
	{
		if(!vis[i]&&!xx)
		{
			vis[i]=1;
			dfs(x+a[i],y,i+1);
			if(xx) return ;// 直接退出。防止多余的回溯。
			vis[i]=0;
		}
	}
}
inline void work()
{
	for(int i=1;i<=n;i++)
	{
		memset(vis,0,sizeof(vis));xx=0;// 每次循环都要还原。
		int ans=0,num=0;
		read(m);
		for(int j=1;j<=m;j++)
		{
			read(a[j]);
			ans+=a[j];
			if(a[j]==a[j-1]) num++;
		}
		if(ans%4!=0)// 如果总边长不是 4 的倍数，肯定不能组成正方形。
 		{
			cout<<"no"<<endl;
			continue;	
		}
		ans/=4;// ans 正方形实际边长。
		int now=0;// 记录能组成正方形的边的个数。
		for(int k=1;k<=3;k++)
		{
			dfs(0,ans,1);
			if(!g) break;
			now+=g;
			g=0;xx=0;
		}// 有三个边能组成了，其余的木棍肯定也能组成第四条边。加快速度（貌似没什么软用）。
		if(now==3)
		{
			cout<<"yes"<<endl;
		}
		else cout<<"no"<<endl;
	}
}
int main()
{
	read(n);
	work();// 跳转！
	return 0;
}
```
// 华丽AC！

---

## 作者：Mychael (赞：1)

DFS搜索

基本思路：

1‘要想拼正方形，所有木棒长度总和一定是正方形的周长。故所有木棒长度总和不是4的倍数或最长木棒大于正方形边长，输出no

2’若满足1‘中的条件，对于每条边进行dfs，尝试能否用剩余木棒拼出这条边

3'若已拼出三条边，由于满足1’条件，第四条边一定能拼出，直接输出yes


代码如下：




        
        
        
        
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=25,maxm=20005;
int M,N;                                              //N为木棍总数，M为边长
int stick[maxn];                                 //木棍长度
bool flag,used[maxn];                       //flag表示是否拼出当前边,used表示该木棍是否使用
int read()                                          //读入优化
{
    int out=0;
    char c=getchar();
    while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out;
}
void dfs(int u,int tot)
{
    if(tot==M)
    {
        flag=true;
        return;
    }
    for(int i=1;i<=N;i++)
        if(!used[i]&&tot+stick[i]<=M)
        {
            used[i]=true;
            dfs(i,tot+stick[i]);
            if(flag) return;
            used[i]=false;
        }
}
int main()
{
    int T=read(),u,Max=-1;
    while(T--)
    {
        N=read();
        M=0;
        Max=-1;
        for(int i=1;i<=N;i++)
        {
            stick[i]=read();
            M+=stick[i];
            Max=max(Max,stick[i]);
        }
        if(M%4!=0){cout<<"no"<<endl;continue;}   //判定是否为4的倍数
        M/=4;
        if(Max>M) {cout<<"no"<<endl;continue;}    //最长棍大于边长肯定不行
        fill(used,used+maxn,false);
        flag=false;                                              //1号边
        used[1]=true;
        dfs(1,stick[1]);
        if(!flag){cout<<"no"<<endl;continue;}
        for(u=1;u<=N;u++) if(!used[u]) break; //2号边
        flag=false;
        used[u]=true;
        dfs(u,stick[u]);
        if(!flag){cout<<"no"<<endl;continue;}
        for(u=1;u<=N;u++) if(!used[u]) break; //3号边
        flag=false;
        used[u]=true;
        dfs(u,stick[u]);
        if(!flag){cout<<"no"<<endl;continue;}
        cout<<"yes"<<endl;                              //4号边一定可以拼出
    }
    return 0;
}

```

---

## 作者：JosephDai (赞：1)

看了看其他大佬的题解，感觉我的思路还是有些与众不同的
具体想法：
	1、对于每组数据，取它们的和，如果对4取模不等于0（也就是不能组成正方形），直接输出“no”；
    2、搜索中，对于每种情况特殊处理（解释都在代码注释里了）
    
    
```
#include <iostream>
#include <cstring>
using namespace std;
int s;
int m;
int n;
bool vis[10001];
int a[10001];
bool flag;
void dfs(int ans,int sum){//sum是目前已经组成了的边数，ans则是目前第sum+1条边组成的情况（即边的长度）
	if(flag){//如果这组数据已经可以组成一个正方形了，自然不用继续搜索
		return;
	}
	if(ans>s){//当前边的长度超过了正方形边长，即这种解法不能组成正方形的一边
		return;
	}
	if(ans==s){
		dfs(0,sum+1);//可以组成正方形的一边，开始搜索下一条边的组成方案
	}
	if(sum==4){//正方形的四条边都好了，标记，退出
		flag=1;
		return;
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			vis[i]=1;
			dfs(ans+a[i],sum);//没什么好解释了，dfs模板
			vis[i]=0;
		}
	}
}
int main(){
	cin>>m;
	while(m--){
		s=0;
		flag=0;
		memset(a,0,sizeof(0));
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			s+=a[i];
		}
		if(s%4!=0){
			cout<<"no"<<endl;
			continue;
		}
		s/=4;
		dfs(0,0);
		if(flag){
			cout<<"yes"<<endl;
		}
		else{
			cout<<"no"<<endl;
		}
	}
	return 0;
}
```

对了对了，反对抄袭题解，共创和谐洛谷！

---

## 作者：Gino_Hong (赞：0)

```cpp
//练剪枝的好题 做法都在注释里啦
//本人非常热衷使用stl c党勿喷
//~~画外音：那你数组有本事用array啊~~
//我的做法是用所有木条去组成四条同等长度的边 
#include<bits/stdc++.h>
#pragma GCC optimize(3)//stl优化 
#pragma G++ optimize(O2)//还是优化 
using namespace std;
int a[25],m,dis;//dis为正方形边长 
bool vis[25];
bool dfs(int len,int dnum,int num){
    //len当前边的长度 dnum边的条数 num使用的木条数 
    if(dnum==4&&num==m&&len==0) return true;
    //如果当前已经组成4条边 并且用完了所有的木条 并且当前边长度为0则表示找到答案 
    for(int i=0;i<m;i++)
        if(!vis[i]){
            if(len+a[i]<dis){//如果当前边加上这跟木条的长度小于正方形边长 
                vis[i]=true;
                if(dfs(len+a[i],dnum,num+1)) return true;//找到答案立即return 
                vis[i]=false;
            }else if(len+a[i]==dis&&dnum+1<=4){//对dnum剪枝 如果大于4没必要再做 
                vis[i]=true;
                if(dfs(0,dnum+1,num+1)) return true;
                vis[i]=false;
            }
        } 
    return false;
}
int main(void){
    ios::sync_with_stdio(false);//输入输出优化 
    cin.tie(0);//输入优化 
    int t;
    cin>>t;
    while(t--){
        cin>>m;
        fill(vis,vis+25,false);//stl的填充函数 
        for(int i=0;i<m;i++) cin>>a[i];
        int sum=accumulate(a,a+m,0);//stl的求和函数 
        int _max=*max_element(a,a+m);//stl的求极值函数 
        dis=sum/4;//算边长 
        if(sum%4) cout<<"no"<<endl;//如果总和不能被4整除则无法组成正方形 
        else if(_max>dis) cout<<"no"<<endl;//如果最大边大于边长也无法组成 
        else if(dfs(0,0,0)) cout<<"yes"<<endl;
        else cout<<"no"<<endl;//一开始这行没有都能得70 这数据水的很迷 
    }
}
```

---

## 作者：zxj200408 (赞：0)

/\*做了两个小时，累死，借鉴了楼下的dalao，写了半天暴力，终于找出了搜索的套路\*/

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
int t,n,a[10000],p[10000],sum,flag;
int MAX=-1000000000;
bool cmp(int x,int y)
{
    return x>y;
}
void dfs(int x)
{
    if(flag) return;//如果为1了，能输出yes，不需要继续搜了，退出
    if(x==n+1)//到了这一层，就意味着所有的木棍都用完了
    {
        flag=1;
        return;
    }
    for(int i=1;i<=4;i++)
     {
         if(a[x]<=p[i])
         {
             p[i]-=a[x];//滚动x
             dfs(x+1);//搜下一根
             p[i]+=a[x];//回溯，重新再来。。。。。
         }
     }
}
int main()
{
    cin>>t;
    while(t--){//最好就用这样的，方式输入多组数据，一般这样的题就只需要边输入边输出。
        cin>>n;
        sum=0;flag=0;//sum记录总和，flag做标记！！！！
        for(int j=1;j<=n;j++){
            cin>>a[j];
            sum+=a[j];
```
}//叠加
```cpp
        sort(a+1,a+n+1,cmp);//从大到小排序
        memset(p,0,sizeof(p));//给数组附个初值
        for(int i=1;i<=4;i++)
            p[i]=sum/4;
        dfs(1);//从一开始
        if(flag)//相当于flag==1
            cout<<"yes"<<endl;
        else cout<<"no"<<endl;
    }
    return 0;
}
```

---

## 作者：ylsoi (赞：0)

这个题目不是和小木棍（加强版）一样的吗，做法也几乎是一样的，只是不需要枚举长度罢了，因为长度可以直接算出来的

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int maxm=20+10;
int n,m,a[maxm],sum,maxx;
bool vis[maxm];
bool cmp(int a,int b){return a>b;}
bool find(int s,int k,int x,int beg)//s为当前的和，k为当前已经拼好了几根木棒，x为我们所需要的和，beg为当前搜索的起点
{
    if(k==4)return 1;//如果我们当前已经搜索满了4根的话，就可以直接返回1了
    for(register int i=beg;i<=m;++i)
        if(!vis[i] && s+a[i]<=x)当前所选的值不要是选过的并且和不可以大于x
        {
            vis[i]=1;
            if(s+a[i]<x && find(s+a[i],k,x,i+1))return 1;
            if(s+a[i]==x && find(0,k+1,x,1))return 1;
            vis[i]=0;
            if(s==0 || s+a[i]==x)return 0;//如果是第一根或者是最后一根选择失败的话，我们就可以直接return 0，因为第一根总是要选的，最后一根如果也选不成的话，如果用比他小的来替代的话，肯定也是不行的
            while(a[i]==a[i+1])++i;//相同的木棒如果选择失败了，就可以一直跳了
        }
    return 0;
}
void read(int &x)
{
    int sum=0;
    char c=getchar();
    while(c<'0' || c>'9')c=getchar();
    while(c>='0' && c<='9')
    {
        sum=sum*10+c-'0';
        c=getchar();
    }
    x=sum;
}
int main()
{
    //freopen("sticks.in","r",stdin);
    //freopen("sticks.out","w",stdout);
    read(n);
    for(register int ca=1;ca<=n;++ca)
    {
        read(m);
        for(register int i=1;i<=m;++i)
        {
            read(a[i]);
            sum+=a[i];
            maxx=max(maxx,a[i]);
        }
        if(sum%4)printf("no\n");//如果这个数据不可以被4整除的话我们就可以不要它了；
        else if(maxx>sum/4)//如果其中的最大值也大于它除以4的值的话，我们也可以直接输出no了
        printf("no\n");
        else
        {
            sort(a+1,a+m+1,cmp);
            if(find(0,0,sum/4,1))
            printf("yes\n");//搜索成功就可以yes了
            else printf("no\n");//不成功就可以no了
        }
        memset(vis,0,sizeof(vis));
        sum=0;
        maxx=0;
    }
    return 0;
}
```

---

## 作者：方方小逗逼 (赞：0)

支持Pascal，看到没有Pascal的题解，来一发

很简单，无脑dfs，算普及-吧，可没人编，加一点优化，将木棒的长度相加，求总和s，如果s mod 4<>0，直接跳出，在dfs过程中，一旦有一条边超过s mod 4就别再做下去了

```cpp
var
  n,m,i,j,k,s:longint;
  a:array [1..20] of longint;
  b:array [1..4] of longint;
procedure f(l,r:longint);
begin
  if j=1 then exit;
  if b[r]>s then exit;
  if (b[1]=b[2])and(b[2]=b[3])and(b[3]=b[4])and(b[1]=s) then
  begin
    j:=1;
    exit;
  end;
  if l<=n then
  begin
    b[1]:=b[1]+a[l];
    f(l+1,1);
    b[1]:=b[1]-a[l];
    b[2]:=b[2]+a[l];
    f(l+1,2);
    b[2]:=b[2]-a[l];
    b[3]:=b[3]+a[l];
    f(l+1,3);
    b[3]:=b[3]-a[l];
    b[4]:=b[4]+a[l];
    f(l+1,4);
    b[4]:=b[4]-a[l];
  end;
end;
begin
  read(m);
  for k:=1 to m do
  begin
    read(n);
    for i:=1 to n do read(a[i]);
    s:=0;
    for i:=1 to n do s:=s+a[i];
    if s mod 4<>0 then writeln('no')
      else
    begin
      s:=s div 4;
      j:=0;
      f(1,1);
      if j=0 then writeln('no')
        else writeln('yes');
    end;
    for i:=1 to n do a[i]:=0;
    for i:=1 to 4 do b[i]:=0;
  end;
end.

```

---


# 于是他错误的点名开始了

## 题目背景

XS中学化学竞赛组教练是一个酷爱炉石的人。

他会一边搓炉石一边点名以至于有一天他连续点到了某个同学两次，然后正好被路过的校长发现了然后就是一顿欧拉欧拉欧拉（详情请见已结束比赛 CON900）。

## 题目描述

这之后校长任命你为特派探员，每天记录他的点名。校长会提供化学竞赛学生的人数和名单，而你需要告诉校长他有没有点错名。（为什么不直接不让他玩炉石。）

## 说明/提示

- 对于 $40\%$ 的数据，$n\le 1000$，$m\le 2000$。
- 对于 $70\%$ 的数据，$n\le 10^4$，$m\le 2\times 10^4$。
- 对于 $100\%$ 的数据，$n\le 10^4$，$m≤10^5$。

---

$\text{upd 2022.7.30}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
5  
a
b
c
ad
acd
3
a
a
e
```

### 输出

```
OK
REPEAT
WRONG
```

# 题解

## 作者：花千树 (赞：176)

# map的练手题
## map轻松搞定~~
这道题可以给大家练练STLmap的用法，让大家感受STL的方便QAQ

看到楼下没有map的好题解（就是精简的）~~（可能我眼睛不好）~~

比什么字典树不简单多了QAQ

先把所有的人名字存起来，使用map，这样可以建立从名字到数的映射，标记为1，然后扫一遍，如果为1，输出OK，同时将1更新为2，如果遇到为2，输出REPEAT，如果为0，说明没有，输出WRONG，不就行了？


时间复杂度O(n+m);

具体解释&&map的介绍见代码：

```
#include<map>
#include<cmath>
#include<stack>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
map<string,int>a; //map定义，相当于数组的升级版，表示string到int的映射，举个简单例子，可以用a["OK"]=1;进行赋值（说白了就是括号里的数据类型是map<>前面的，=的后面就是map<>后面的数据类型）
string s;//用于读入的字符串
int n,m;
int main(){
    cin>>n;
    while(n--){//因为是n+m就可以了，所以直接n--，--QWQ
    	cin>>s;
    	a[s]=1;//直接这样赋值
    }
    cin>>m;
    while(m--){
    	cin>>s;
    	if(a[s]==1){puts("OK");a[s]=2;}//前面讲的很清楚，不赘述了
    	else if(a[s]==2)puts("REPEAT");//输出
    	else puts("WRONG");
    }
	return 0;//完美的过程，不是吗？
}
```

---

## 作者：一座城·守一人 (赞：100)

## $n^2$过百万，暴力碾标算      
#### ——chen_zhe
**这道题，主要就是暴力搜索每个人名存不存在，如果存在的判断一下有没有被点到过，被点到过，就输出“REPEAT”，没有就输出“OK”**
### 暴力，交上去：[50分](https://www.luogu.org/record/show?rid=12253938)
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct student{
    string name;//记录每个学生的名字.
    bool get;//记录每一个学生有没有被点到.
};
student ss[10005];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){//初始化
        cin>>ss[i].name;
        ss[i].get=true;
    }
    int m;
    cin>>m;
    for(int i=1;i<=m;i++){//每次点名判断
        string nam;
        bool judge=false;
        cin>>nam;
        for(int j=1;j<=n;j++){//从第一个学生开始暴力
            if(nam==ss[j].name&&ss[j].get==false){//点到了,但是之前点过
                cout<<"REPEAT"<<endl;
                judge=true;//有这个学生
            }
            if(nam==ss[j].name&&ss[j].get==true){//点到了,之前没点过
                cout<<"OK"<<endl;
                judge=true;
                ss[j].get=false;//点过了
            }
        }
        if(judge==false){//没有这个学生
            cout<<"WRONG"<<endl;
        }
    }
    return 0;
}
```
#### 代码分析：
输出以后没有马上跳出循环，而是继续等到j循环结束后才开始枚举第二个学生.
### 改进,交上去,[90分](https://www.luogu.org/record/show?rid=12253955)
#### 代码分析:
1. 读入没有优化,加入`ios:sync_with_stdio(false)`提高`cin>>`的读入速度;
1. 开$O_2$优化;
1. 将`<<endl;`换成`'\n';`(一般后者要比前者快上8.5倍)
1. 玄学优化:在头文件前加入预处理指令:
```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
```
### 交上去,惊不惊喜?[还是90分!](https://www.luogu.org/record/show?rid=12266794)
第十个测试点永远超时,输出下载下来一看(输入由于文件太大不能下载):
```
WRONG
WRONG
......(下面99998行均是WRONG);
```
如果这样用暴力搜索绝对超时!
## 这下不行了,别的优化方法已经用到极致了,再用就得优化代码了.
### 二分
#### 首先把所有的学生的名字排序,每当点到一个同学的时候二分查找看这个同学的名字是否合法,不合法直接输出"WRONG".如果合法就再看这个同学的名字是否点到过
### 代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct student {
	string name;
	bool get;
};
student ss[10005];
bool operator <(student a,student b) {//重载运算符,sort要用
	return a.name<b.name;
}
int sea_rch(int l,int r,string a) {//二分搜索
	int mid=l+(r-l)/2;
	if(ss[mid].name==a)return mid;//找到,返回该学生名字下标
	if(l>r)return -1;
	else if(ss[mid].name>a)return sea_rch(l,mid-1,a);//递归方式写二分,大家应该都能看懂
	else return sea_rch(mid+1,r,a);
}
int main() {
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>ss[i].name;
		ss[i].get=true;
	}
	int m;
	cin>>m;
	sort(ss+1,ss+n+1);//排序,二分前重要的一步
	for(int i=1; i<=m; i++) {
		string nam;
		cin>>nam;
		bool judge=false;
		int j=sea_rch(1,n,nam);//下标
		if(j==-1) {//没找到
			cout<<"WRONG\n";
		} else {
			if(ss[j].get==false) {//找到但是点过
				cout<<"REPEAT\n";
				judge=true;
			} else if(ss[j].get==true) {//找到而且没有点过
				cout<<"OK\n";
				judge=true;
				ss[j].get=false;
			}
		}
	}
	return 0;
}
```
### [满分](https://www.luogu.org/record/show?rid=12274839)
### 时间下降了三倍.
## 最后用两句 dd大牛 的话来结束整篇题解:
### 1.“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。
### 2.失败不是什么丢人的事情，从失败中全无收获才是。

---

## 作者：ZJH365 (赞：80)

           Trie树（字典树）
在[博客](https://47488.blog.luogu.org/qian-tan-trie-shu-zi-dian-shu-post)内食用更佳

更新：加了4副图(之前手滑删了)

一、引入

字典是干啥的？查找字的。

字典树自然也是起查找作用的。查找的是啥？单词。

看以下几个题：

1、给出n个单词和m个询问，每次询问一个单词，回答这个单词是否在单词表中出现过。

答：简单！map，短小精悍。

好。下一个

2、给出n个单词和m个询问，每次询问一个前缀，回答询问是多少个单词的前缀。

答：map，把每个单词拆开。

judge：n<=200000，TLE！

这就需要一种高级数据结构——Trie树（字典树）

二、原理

在本篇文章中，假设所有单词都只由小写字母构成

对cat，cash，app，apple，aply，ok 建一颗字典树，建成之后如下图所示

![](https://cdn.luogu.com.cn/upload/pic/72443.png)


由此可以看出：

1、字典树用边表示字母

2、有相同前缀的单词公用前缀节点，那我们可以的得出每个节点最多有26个子节点（在单词只包含小写字母的情况下）

3、整棵树的根节点是空的。为什么呢？便于插入和查找，这将会在后面解释。

4、每个单词结束的时候用一个特殊字符表示，图中用的‘′，那么从根节点到任意一个‘’所经过的边的所有字母表示一个单词。

三、基本操作

A、insert，插入一个单词

1.思路

  从图中可以直观看出，从左到右扫这个单词，如果字母在相应根节点下没有出现过，就插入这个字母；否则沿着字典树往下走，看单词的下一个字母。

  这就产生一个问题：往哪儿插？计算机不会自己选择位置插，我们需要给它指定一个位置，那就需要给每个字母编号。

  我们设数组trie[i][j]=k，表示编号为i的节点的第j个孩子是编号为k的节点。

 什么意思呢？

 这里有2种编号，一种是i，k表示节点的位置编号，这是相对整棵树而言的；另一种是j，表示节点i的第j的孩子，这是相对节点i而言的。

 不理解？看图

 还是单词cat，cash，app，apple，aply，ok 

注意这里相同字母的编号可能不同

 ![](https://cdn.luogu.com.cn/upload/pic/72444.png)

 我们就按输入顺序对其编第一种号，红色表示编号结果。因为先输入的cat，所以c，a，t分别是1,2,3，然后输入的是cash，因为c，a是公共前缀，所以从s开始编，s是4，以此类推。

 第二种编号，相对节点的编号，紫色表示编号结果。

因为每个节点最多有26个子节点，我们可以按他们的字典序从0——25编号，也就是他们的ASCLL码-a的ASCLL码。

注意这里相同字母的编号相同

![](https://cdn.luogu.com.cn/upload/pic/72447.png)

 实际上每个节点的子节点都应该从0编到——25，但这样会发现许多事根本用不到的。比如上图的根节点应该分出26个叉。节约空间，用到哪个分哪个。

 这样编号有什么用呢？

回到数组trie[i][j]=k。 数组trie[i][j]=k，表示编号为i的节点的第j个孩子是编号为k的节点。

那么第二种编号即为j，第一种编号即为i，k

2、代码

```cpp
void insert()//插入单词s
{
    len=strlen(s);//单词s的长度
    root=0;//根节点编号为0
    for(int i=0;i<len;i++)
    {
        int id=s[i]-'a';//第二种编号
        if(!trie[root][id])//如果之前没有从root到id的前缀 
                    trie[root][id]=++tot;//插入，tot即为第一种编号
        root=trie[root][id];//顺着字典树往下走
    }
}
```
B、search，查找

查找有很多种，可以查找某一个前缀，也可以查找整个单词。

再次我们以查找一个前缀是否出现过为例讲解

1、思路

  从左往右以此扫描每个字母，顺着字典树往下找，能找到这个字母，往下走，否则结束查找，即没有这个前缀；前缀扫完了，表示有这个前缀。

2、代码
```cpp
bool find()
{
    len=strlen(s);
    root=0;//从根结点开始找
    for(int i=0;s[i];i++)
    {
        int x=s[i]-'a';//
        if(trie[root][x]==0)   return false;//以root为头结点的x字母不存在，返回0 
        root=trie[root][x];//为查询下个字母做准备，往下走 
    }
    return true;//找到了
}
```

3、如果是查询某个单词的话，我们用bool变量 v[i]表示节点i是否是单词结束的标志。

    那么最后return的是v[root],所以在插入操作中插入完每个单词是，要对单词最后一个字母的v[i]置为true，其他的都是false

4、如果是查询前缀出现的次数的话，那就在开一个sum[]，表示位置i被访问过的次数，

   那么最后return的是sum[root]，插入操作中每访问一个节点，都要让他的sum++

   这里前缀的次数是标记在前缀的最后一个字母所在位置的后一个位置上。

  比如:前缀abc出现的次数标记在c所在位置的后一个位置上，

 ![](https://cdn.luogu.com.cn/upload/pic/72448.png)

四、完整代码

1、查询是否出现


复制代码
/*
  trie tree的储存方式：将字母储存在边上，边的节点连接与它相连的字母 
  trie[rt][x]=tot:rt是上个节点编号，x是字母，tot是下个节点编号 
*/ 
```cpp
/*
  trie tree的储存方式：将字母储存在边上，边的节点连接与它相连的字母 
  trie[rt][x]=tot:rt是上个节点编号，x是字母，tot是下个节点编号 
*/ 
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define maxn 2000010
using namespace std;
int tot=1,n;
int trie[maxn][26];
//bool isw[maxn];查询整个单词用
void insert(char *s,int rt)
{
    for(int i=0;s[i];i++)
    {
        int x=s[i]-'a';
        if(trie[rt][x]==0)//现在插入的字母在之前同一节点处未出现过 
        {
            trie[rt][x]=++tot;//字母插入一个新的位置，否则不做处理 
        }
        rt=trie[rt][x];//为下个字母的插入做准备  
    }
    /*isw[rt]=true;标志该单词末位字母的尾结点，在查询整个单词时用到*/
}
bool find(char *s,int rt)
{
    for(int i=0;s[i];i++)
    {
        int x=s[i]-'a';
        if(trie[rt][x]==0)return false;//以rt为头结点的x字母不存在，返回0 
        rt=trie[rt][x];//为查询下个字母做准备 
    }
    return true;
    //查询整个单词时，应该return isw[rt] 
}
char s[22];
int main()
{
    tot=0;
    int rt=1;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        insert(s,rt);
    }
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        if(find(s,rt))printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}

数组模拟
```
2、查询前缀出现次数


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int trie[400001][26],len,root,tot,sum[400001];
bool p;
int n,m; 
char s[11];
void insert()
{
    len=strlen(s);
    root=0;
    for(int i=0;i<len;i++)
    {
        int id=s[i]-'a';
        if(!trie[root][id]) trie[root][id]=++tot;
        sum[trie[root][id]]++;//前缀保存 
        root=trie[root][id];
    }
}
int search()
{
    root=0;
    len=strlen(s);
    for(int i=0;i<len;i++)
    {
        int id=s[i]-'a';
        if(!trie[root][id]) return 0;
        root=trie[root][id];
    }//root经过此循环后变成前缀最后一个字母所在位置
    return sum[root];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        insert();
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        cin>>s;
        printf("%d\n",search());
    }
}

数组模拟
```
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
char s[11];
int n,m;
bool p;
struct node
{
    int count;
    node * next[26];
}*root;
node * build()
{
    node * k=new(node);
    k->count=0;
    memset(k->next,0,sizeof(k->next));
    return k;
}
void insert()
{
    node * r=root;
    char * word=s;
     while(*word)
    {
        int id=*word-'a';
        if(r->next[id]==NULL) r->next[id]=build();
        r=r->next[id];
        r->count++;
        word++;
    }
}
int search()
{
    node * r=root;
    char * word=s;
    while(*word)
    {
        int id=*word-'a';
        r=r->next[id];
        if(r==NULL) return 0;
        word++;
    }
    return r->count;
}
int main()
{
    root=build();
    scanf("%d",&n);
    for(int i=1;i<=n;i++) 
    {
            cin>>s;
            insert();
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        cin>>s;
        printf("%d\n",search());
    }
}
```

五、模板题

hdu 1251 统计难题 http://acm.hdu.edu.cn/showproblem.php?pid=1251

codevs 4189 字典 http://codevs.cn/problem/4189/

作者：xxy
出处：http://www.cnblogs.com/TheRoadToTheGold/
本文版权归作者和博客园共有，欢迎转载，但转载时请保留此段声明。

---

## 作者：Niko (赞：58)

看到没有c++的非指针trie，交一个

(反正指针我不会写（个人讨厌指针（11101001）））


关于trie的实现

楼下的楼下讲得很清楚了


判断重复就是找到一次完整单词就使该节点的cnt++，若果该节点cnt不为0的话说明点过一次名，那么输出  "REPEAT"




```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,m;
struct node{
    int cnt;
    int son[26];
    bool have;
    node(){
        cnt=0;
        memset(son,false,sizeof son);
        have=false;
    }
}trie[800000];
int num=0;
void insert(char *s)
{
    int v,len=strlen(s);
    int u=0;
    for(int i=0;i<len;i++)
    {
        v=s[i]-'a';
        if(!trie[u].son[v])
            trie[u].son[v]=++num
            ;
        u=trie[u].son[v];
    }
    trie[u].have=1;
}
int find(char *s)
{
    int v,u=0,len=strlen(s);
    for(int i=0;i<len;i++)
    {
        v=s[i]-'a';
        if(!trie[u].son[v])return 3;
        u=trie[u].son[v];
    }
    if(!trie[u].have)return 3;
    if(!trie[u].cnt)
    {
        trie[u].cnt++;
        return 1;
    }
    return 2;
}
int main()
{
    char name[100];
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%s",name);
        insert(name);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;++i)
    {
        scanf("%s",name);
        int p=find(name);
        if(p==1)
            puts("OK");
        else if(p==2)
            puts("REPEAT");
        else if(p==3)
            puts("WRONG");
    }
    return 0;    
}

```

---

## 作者：Ciyang (赞：20)

### 声明:
此题解非正常Trie,推荐先学习最普通的Trie并了解指针的使用
### 废话:
很早之前就想到了一种字典树,节点存储字符串,代表Trie树上以某字符开头的所有子树最长公共前缀.好像说的不清楚,那就再听我仔细讲解吧    
写题解的上午有了灵感,然后根据思路模拟了一下,可行性挺高的.  
写完代码后提交AC,跑了最优解第四,然而前三用的hash算法没法比啊.   
我现暂且命名它为~~Ciyang_Trie~~(Lumpy_Trie块状字典树),怀疑已经有人发明过了.  
代码比普通的复杂一些,我使用了指针.    
按任意顺序插入abcd,abcde,bcde,bcef四个字符串的Trie树长这样:   
![Trie01](https://cdn.luogu.com.cn/upload/pic/48086.png)   
红色节点代表有插入的字符串结尾的节点.
### 证明:
通过与比较普通指针版和非指针版Trie来证明一下可行性.   
指针版Trie可使用动态内存,缺点是每个节点只保存一个字符,而同时又要保存26个子节点的指针,会有大量的空指针来占用额外的内存,且new节点多了,内存分配常数较大.   
为了减少常数,可以自己写new方法来分配,但无论是什么数据,只要稍带随机性,就会有很多只有一个子节点的节点,这无疑有25个空指针浪费内存.    
非指针版常数小,但空间分配也是很大的问题.
然而仍有很多一条链的树,空间最大浪费N\*25啊...~~先不说影响美观~~而且时间复杂度依然很高,毕竟查询也是O(N).       
Lumpy_Trie的复杂度是会改变的,就是对一条链情况的优化,理论最大时间复杂度是O(N)带有一些常数.    
Lumpy_Trie缺点是写起来比普通的更复杂,优点是经得起大数据考量,而且插入最小是O(1),空间上也少了很多空指针. 
Lumpy_Trie巧妙利用字符串指针,赋值、继承等操作只需要指针或长度变化就好了.   
#### 太多证明不如一句代码,我放上代码继续分析.     
### 解析:  
节点的结构体,相比普通Trie多了length和字符串指针:  
```cpp
#define clear(a) memset(a, 0, sizeof(a))
#define copy(a, b) memcpy(a, b, sizeof(a))
    struct Lumpy_Tnode {
    	const char *pStr;
        //指向当前存储字符串首元素
		int length, isEnd;
        //length存储字符串的长度 isEnd代表是否是结尾节点
		Lumpy_Tnode *children[26];
        //26个子节点
		inline Lumpy_Tnode() {
			pStr= 0, length= isEnd= 0, clear(children);
		}
		inline Lumpy_Tnode(const char *str, int len, int end) {
			pStr= str, length= len, isEnd= end, clear(children);
		}
        //构造函数
	} mNode;
```

#### 插入操作:    
使用递归和循环,判断比较多,先看代码(看起来常数很大)      

```cpp
	inline void insert(const char *str, int length, Lumpy_Tnode *bNode) {
    //str是指针,指向当前插入字符串的第一个元素
		if(!length) {
        //字符串长度为0代表结尾
        //其实是为了优化代码美观,当作递归边界
			bNode->isEnd= 1;
			return;
		}
		int ch= str[0] - 'a';
		if(bNode->children[ch]) {
        //子节点已存在
			bNode= bNode->children[ch];
			register int sptr= 0;
			while(sptr < length && sptr < bNode->length && bNode->pStr[sptr] == str[sptr]) ++sptr;
            //循环来找当前字符串和节点存储的字符串最长前缀
			if(sptr != bNode->length) {
            //节点存储的字符串不是插入字符串的子串
				Lumpy_Tnode *nNode= new Lumpy_Tnode(bNode->pStr + sptr, bNode->length - sptr, bNode->isEnd);
                //拆树,运用字符串指针连续地址的特性来操作
				copy(nNode->children, bNode->children), clear(bNode->children);
                //继承原有子节点的各种信息
				bNode->isEnd= 0, bNode->children[bNode->pStr[sptr] - 'a']= nNode;
                //清空原有节点,重新初始化
			}
			bNode->length= sptr;
            //更新当前节点存储的字符串长度,从而更改当前存储的字符串
			insert(str + sptr, length - sptr, bNode);
		}
		else
			bNode->children[ch]= new Lumpy_Tnode(str, length, 1);
            //不存在当前首字母的子节点,直接new并且赋值
            //因为是指针操作,所以不需要O(n)复制字符串,理论上复杂度O(3)?
		return;
	}
    //调用方式:insert(插入字符串, 字符串长度, Trie根节点);
```

如果代码看懂了,第一反应可能认为指针操作有问题.   
的确插入的字符串在插入后就不能进行改变了,所以就只要开一个char\[N\]\[K\]的数组来保存输入的字符串,K为最长字符串的长度.  
相比较空间复杂度总体仍然较小,其实是把原来每个节点存的char放到了一起,每个节点多了一个指针.(不过创建的节点更少了,所以浪费空间少)   
这其中其实有个很巧妙的事,树上的一条链可能指向的地址是连续的.仔细想了想,其实也有空间浪费,不管是节点上还是树上的最长公共前缀都只指向一个字符串,其他字符串中相同的字符占用的空间就永远浪费掉了,这句话不懂没事,因为这个浪费造成的影响很小.    
如果代码都没看懂,还有图解:  

1. 向空树插入abc,再插入ab:      
![Trie02](https://cdn.luogu.com.cn/upload/pic/48101.png)
2. 再向此树插入ac:     
![Trie03](https://cdn.luogu.com.cn/upload/pic/48103.png) 

解释一下图2:   
比较ab和ac,最长公共前缀为a   
新建一个字符串指针指向ab中b的节点,长度为1,继承ab的颜色和ab的子节点.   
清空ab的子节点,颜色改为黑(黑表示不为结尾节点),ab的首字母b子节点指向b.  
在我实现时,先更改长度使ab变为a,再向a中插入c.   
因为没有首字母为c的子节点,直接new一个新的.  

#### 查找操作:

```cpp
	inline int find(const char *str, int length, Lumpy_Tnode *bNode) {
		if(!length) {
        //递归到查找的字符串长度为0
        //判断当前节点是否为结尾,是否是第一次查询
			if(bNode->isEnd == 1) return bNode->isEnd++;
			return bNode->isEnd;
		}
		int ch= str[0] - 'a';
		if(bNode->children[ch]) {
			bNode= bNode->children[ch];
			if(length < bNode->length) return 0;
            //自带剪枝,若当前查找字符串长度小于当前公共前缀,那么字典树中不存在当前查找的字符串
			register int sptr= 0;
			while(sptr < bNode->length && bNode->pStr[sptr] == str[sptr]) ++sptr;
			if(sptr != bNode->length) return 0;
            //最长公共前缀必须是当前查找的字符串的子串
			return find(str + sptr, length - sptr, bNode);
		}
		return 0;
        //没有子节点,字典树中不存在当前查找的字符串
	}
    //调用方式:find(查询字符串, 字符串长度, Trie根节点);
```

比插入的代码简单多了,并且自带剪枝,所以比较快.
### 完整代码:
#### (开启O2)用时: 127ms / 内存: 4248KB
#### (关闭O2)用时: 144ms / 内存: 4128KB

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
#define clear(a) memset(a, 0, sizeof(a))
#define copy(a, b) memcpy(a, b, sizeof(a))
struct Lumpy_Trie {
	struct Lumpy_Tnode {
		const char *pStr;
		int length, isEnd;
		Lumpy_Tnode *children[26];
		inline Lumpy_Tnode() {
			pStr= 0, length= isEnd= 0, clear(children);
		}
		inline Lumpy_Tnode(const char *str, int len, int end) {
			pStr= str, length= len, isEnd= end, clear(children);
		}
	} mNode;
	inline void insert(const char *str, int length, Lumpy_Tnode *bNode) {
		if(!length) {
			bNode->isEnd= 1;
			return;
		}
		int ch= str[0] - 'a';
		if(bNode->children[ch]) {
			bNode= bNode->children[ch];
			register int sptr= 0;
			while(sptr < length && sptr < bNode->length && bNode->pStr[sptr] == str[sptr]) ++sptr;
			if(sptr != bNode->length) {
				Lumpy_Tnode *nNode= new Lumpy_Tnode(bNode->pStr + sptr, bNode->length - sptr, bNode->isEnd);
				copy(nNode->children, bNode->children), clear(bNode->children);
				bNode->isEnd= 0, bNode->children[bNode->pStr[sptr] - 'a']= nNode;
			}
			bNode->length= sptr;
			insert(str + sptr, length - sptr, bNode);
		}
		else
			bNode->children[ch]= new Lumpy_Tnode(str, length, 1);
		return;
	}
	inline int find(const char *str, int length, Lumpy_Tnode *bNode) {
		if(length == 0) {
			if(bNode->isEnd == 1) return bNode->isEnd++;
			return bNode->isEnd;
		}
		int ch= str[0] - 'a';
		if(bNode->children[ch]) {
			bNode= bNode->children[ch];
			if(length < bNode->length) return 0;
			register int sptr= 0;
			while(sptr < bNode->length && bNode->pStr[sptr] == str[sptr]) ++sptr;
			if(sptr != bNode->length) return 0;
			return find(str + sptr, length - sptr, bNode);
		}
		return 0;
	}
} t;
char allstr[10001][51], tmp[51];
int n;
int main() {
	scanf("%d", &n);
	for(register int i= 0; i < n; i++) {
		scanf("%s", allstr[i]);
		t.insert(allstr[i], strlen(allstr[i]), &t.mNode);
	}
	scanf("%d", &n);
	for(register int i= 0, j; i < n; i++) {
		scanf("%s", tmp);
		j= t.find(tmp, strlen(tmp), &t.mNode);
		switch(j) {
			case 0: printf("WRONG\n"); break;
			case 1: printf("OK\n"); break;
			case 2: printf("REPEAT\n"); break;
		}
	}
	return 0;
}
```

最需要注意的事,要用数组保存输入的字符串,不能更改!!!
### 后续:
我写的常数可能挺大,希望dalao们试试各种卡常优化...  
不知道能不能搞个大事情,~~这个字典树出名了别忘了Ciyang~~(出名我就女装了)  
又想了一下,应该很容易改成可持久化Trie.   
如果这个算法早就有人发明了告诉我一下.   

希望题解能过!!!

---

## 作者：TJor (赞：14)

用“P2580 于是他错误的点名开始了”这道题，来说一下trie树吧。

trie树也称字典树，就是你查字典的方法，先是第一个字母，然后第二个，第三个。。。以此类推，把很多个字符串合并成一棵树，如下图所示：
![](https://cdn.luogu.com.cn/upload/pic/15663.png)
图上的单词有：
```
BB
BC
C
DDA
DDC
```
现在你会发现，原来查找一个单词需要搜索n×s（单词长度）遍，而现在只用查找s遍就可以了。省去了大量的时间。
但是会占一些空间，相当于每棵树会有26个节点，也就是你需要开26倍的空间，下面，我们来具体实现一下trie树的插入与查询过程
首先构造结构体：
```
struct node
{
    int cnt;//这个节点的编号
    bool done;//这个名字是否叫过
    bool isend;//这个节点是不是一个单词的最后一个字母
    int next[26];//next[i]表示当前节点i字母（0是a，1是b，以此类推）子节点的编号，如果没有这个字母的子节点就是0
    node()//结构体中赋值
    {
        done=0;
        isend=0;
        memset(next,0,sizeof(next));
    }	
}tree[MAXN];//构建数组，注意多倍数内存
```
这个应该没有什么难的，特别说一下next数组，以刚才的图为例，如果根节点编号是0，最上面的BCD子节点编号分别是1,2,3，那么tree[0].next[1]=1,tree[0].next[3]=3
然后就是插入了
现在，开始是一颗空树，只有孤零零的一个根节点，上面什么也没有
![](https://cdn.luogu.com.cn/upload/pic/15667.png)
我们先记录一个total，代表节点个数，还有一个last，代表上一个节点的序号
然后，你插入AB这个字符串
开始插入A，A的cnt是++total，1,1的last是0，tree[0].next[0]=1.
然后插入B，cnt=++total=2,last=1
tree[1].next[1]=2.
因为B是一个字符串的最后一位，所以标记B
![](https://cdn.luogu.com.cn/upload/pic/15674.png)
然后插入新的一个字符串：ACD
开始是A，发现tree[0].next[0]!=0了，说明已经构建过节点了，直接last=tree[0].next[0]=1
然后是C，发现tree[1].next[2]==0,构造新的节点
cnt=++total=3,last=3.
![](https://cdn.luogu.com.cn/upload/pic/15676.png)
然后如上插入D，同样标记D
![](https://cdn.luogu.com.cn/upload/pic/15677.png)
构造就完成了，变成代码是这个样子
```
void insert(string s)
{
    int l=s.size();//取字符串长度
    int last=0;
    for(int i=0;i<l;i++)
    {
        if(tree[last].next[s[i]-'a']==0)//如果没有节点
        {
            total++;
            tree[total].cnt=total;//构建节点
            tree[last].next[s[i]-'a']=total;
            last=total;
        }
        else//有节点就直接往下
            last=tree[last].next[s[i]-'a'];
        if(i==l-1)//最后一个标记一下
            tree[last].isend=1;
    }
    return ;
}
```
然后就是查询了
判断一个字符串是否在这个书上
1、如果当前字符串的一个字符没有在树上出现，则是wrong
2、如果当前字符串最后一个字符上没有结束标记，则是wrong
3、如果这个字符串已经被找过，也就是最后一个节点的done是1，那么是repeat
4、剩下情况就是OK了
查询过程就是last=tree[last].next[s[i]-'a'];
贴上代码：
```
int find(string s)
{
    int l=s.size();
    int last=0;
    for(int i=0;i<l;i++)
    {
        if(tree[last].next[s[i]-'a']==0)//判定1
            return 0;
        last=tree[last].next[s[i]-'a'];
    }
    if(!tree[last].isend)//判定2
        return 0;
    if(tree[last].done)//判定3
        return 2;
    tree[last].done=1;
    return 1;//判定4
}
```
好了，到了这里，如果你是认认真真看题解，并且认认真真思考过的，马么你应该会做了，如果你对自己有足够的信心，那么就看上面的代码，把自己的程序写出来，自己调试，如果你实在写不出来，就看下面的代码吧！
```
#include <bits/stdc++.h>
#define MAXN 1000010
using namespace std;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar())
        if(ch=='-')
            f=-1;
    for(;isdigit(ch);ch=getchar())
        x=x*10+ch-'0';
    return x*f;
}
struct node
{
    int cnt;
    bool done;
    bool isend;
    int next[26];
    node()
    {
        done=0;
        isend=0;
        memset(next,0,sizeof(next));
    }	
}tree[MAXN];
int total=0;
void insert(string s)
{
    int l=s.size();
    int last=0;
    for(int i=0;i<l;i++)
    {
        if(tree[last].next[s[i]-'a']==0)
        {
            total++;
            tree[total].cnt=total;
            tree[last].next[s[i]-'a']=total;
            last=total;
        }
        else
            last=tree[last].next[s[i]-'a'];
        if(i==l-1)
            tree[last].isend=1;
    }
    return ;
}
int find(string s)
{
    int l=s.size();
    int last=0;
    for(int i=0;i<l;i++)
    {
        if(tree[last].next[s[i]-'a']==0)
            return 0;
        last=tree[last].next[s[i]-'a'];
    }
    if(!tree[last].isend)
        return 0;
    if(tree[last].done)
        return 2;
    tree[last].done=1;
    return 1;
}
int main()
{
    int n,m;
    string s;
    n=read();
    for(int i=1;i<=n;i++)
    {
        cin>>s;
        insert(s);
    }
    m=read();
    for(int i=1;i<=m;i++)
    {
        cin>>s;
        int p=find(s);
        if(p==0)
            cout<<"WRONG"<<endl;
        if(p==1)
            cout<<"OK"<<endl;
        if(p==2)
            cout<<"REPEAT"<<endl;
    }
    return 0;
}

```
trie树是一个经典的字符串算法，后面还有更难的KMP，AC自动机，能独立写trie树是一个重要的技能，所以大家一定不要粘代码，一定要自己切断网线以后手打一遍。

~~愿公孙离与你同在~~

---

## 作者：森郁暮歌_ (赞：10)

---
### 前记
---

仅仅是一些 ~~废话~~ 我个人的体会，dalao们可以略过

第一篇题解，一定程度上说明本蒟蒻和大犇之间的距离缩短了0.1E-10000000个OI单位，但同时，这0.1E-10000000也象征了我自身的一些进步吧

从学习题解到将自己的思考写出来和大家分享，是一件快乐而有意义的事情

---
### 提醒
---

适合有一定STL学习基础的C++程序猿学习

但由于本蒟蒻不懂高深的算法，只能分享一下自己的简单算法了

---
### 正文
---

看到这道题，第一感觉没有想到什么高深的算法，而是 ~~低俗的~~ 暴力

于是拉到数据范围，感觉有点悬，思考怎么优化......

**暴力的想法**是先储存学生名字，然后一个个查找点的名是否出现过或是不存在。

容易看出，n+m的复杂度是不可避免的，那么是否有一种算法能够快速地查找是否已经出现过重复呢？

标记数组有这种类似的功能，但无法标记string类型，而且太耗内存

于是想到利用C++的STL库**map**的功能来实现


蒟蒻的代码就此诞生：

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
map<string,int>mp;
string s;
int n,m;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
    	cin>>s;		//注意string类型输入不能用scanf 
        mp[s]++;		//map用法同数组，方便吧~
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        cin>>s;
        if(mp[s]==1) {		//在名单中但未被点到 
			printf("OK\n");
			mp[s]++;			//已点到 
		}
        else if(mp[s]==2) printf("REPEAT\n");	//重复了 
        else printf("WRONG\n");		//没出现过 
    }
    return 0;
}
```









---

## 作者：mzq667 (赞：9)

发一个数组Trie树的题解，跑了300ms，空间30.0MB，请放心食用。

本题是一个Trie树模板题，插入操作不必说，只在字符串结尾加上存在标记即可；查询操作返回的三种状态则可以加入一个布尔变量，判断是否已被查询过。

多说无益，下附代码：

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <cmath>
#define re register
struct Trie{
    bool count; int next[26]; bool exist; //exist表示此处是否为一个单词；count表示此单词是否已被查询。
}a[500100]; int top(1);
char str[60]; int n, m;
char buf[10000], *p = buf, *end = buf; int lent; //不要在意读入优化，使用scanf("%d") 与 scanf("%s") 对应相应读入即可。
inline char getChar() {
    if(p == end) {
        if(feof(stdin)) return '\0';
        p = buf, end = buf + fread(buf, 1, 10000, stdin);
    }
    return *(p++);
}
inline void getString(char* str) {
    lent = 0; char _c;
    while (!isalpha(_c = getChar()));
    do str[lent++] = _c;
    while (isalpha(_c = getChar()));
    str[lent] = '\0';
    return ;
}
inline void getNum(int& x) {
    x = 0; char c;
    while(!isdigit(c = getChar()));
    do x = x * 10 + (c - '0');
    while(isdigit(c = getChar()));
    return ;
}
inline void Trie_insert() {//普通insert操作，将字符串一一加入字典中
    int num(0), root = 1;
    for (re int i = 0; str[i]; ++i) {
        num = str[i] - 'a';
        if(!a[root].next[num]) a[root].next[num] = ++top;
        root = a[root].next[num];
    }
    a[root].exist = true;
    return ;
}
inline int Trie_search() {//普通search操作，查询是否存在该字符串
    int num(0), root = 1;
    for (re int i = 0; str[i]; ++i) {
        num = str[i] - 'a';
        if(!a[root].next[num]) return 0;  //若无法查询到后继的字母，直接退出
        root = a[root].next[num];
    }
    if(!a[root].exist) return 0;  //若此处不存在字符串，返回“WRONG”
    else if(a[root].count) return 2;  //若此处字符串已被查询，返回“REPEAT”
    a[root].count = true;  //若以上均不满足，说明合法
    return 1;  //此字符串标记为已查询，返回“OK”
}
int main() {
    //freopen("Trie_Tree.in", "r", stdin);本地测试用
    getNum(n);
    for (re int i = 1; i <= n; ++i) {  //插入
        memset(str, 0, sizeof str);
        getString(str);
        Trie_insert();
    }
    getNum(m);
    scanf("%d", &m);
    for (re int i = 1; i <= m; ++i) {  //查询
        memset(str, 0, sizeof str);
        getString(str);
        int tmp = Trie_search();
        if(tmp == 0) printf("WRONG\n");  //分类讨论
        else if(tmp == 1) printf("OK\n");
        else if(tmp == 2) printf("REPEAT\n");
    }
    return 0;
}
```

---

## 作者：wjy666 (赞：8)

没人用pbds??

介绍一下pb\_ds库中的hash\_table，很多时候都比map快，(虽然在洛谷上一点也不明显)

hash\_table有cc\_hash\_table和gp\_hash\_table2种

gp\_hash\_table稍快一些，但是cc\_hash\_table有去重功能，这里采用gp\_hash\_table

上代码

```cpp
#include<cstdio>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp> //这2行是pbds头文件
#include<cstring>
#define For(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
using namespace __gnu_pbds; //也是头文件
int read(){
    int l=1,x=0; char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if (ch=='-') ch=getchar(),l=-1;
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*l;
}
gp_hash_table<string,int> pb;
int main(){
    int n=read(); char c[60];
    For(i,1,n) scanf("%s",c),pb[c]=1;
    int m=read();
    For(i,1,m) {
        scanf("%s",c);
        if (pb[c]==1) pb[c]=2,printf("OK\n");
        else if (pb[c]==2) printf("REPEAT\n");
        else printf("WRONG\n"); //操作都跟map差不多
    }
    return 0;
}
```

---

## 作者：Burnside (赞：6)

哎 虽然是$Trie$树的板子 但是还是想拿字符串哈希搞一搞

一开始模了$1000000009$ 结果只有$60$分 可能出题人也意识到了随便用哈希可以轻松水过 就卡了一下

但这又怎能阻挡我的脚步？于是同时模了$1000000009$和$1000000007$ 轻松水过（~~数据有待加强~~

代码精简 轻松易读

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<string>
#include<cstdlib>
#include<set>
template<typename _sp>
inline void qread(_sp &_x){
    char _ch=getchar(),_lst=' ';
    while(_ch<'0'||_ch>'9') _lst=_ch,_ch=getchar();
    while(_ch>='0'&&_ch<='9') _x=(_x<<3)+(_x<<1)+(_ch^48),_ch=getchar();
    if(_lst=='-') _x=-_x;
}
template<typename _sp>
inline _sp mmax(_sp __a,_sp __b){
    return __a>__b?__a:__b;
}
template<typename _sp>
inline _sp mmin(_sp __a,_sp __b){
    return __a<__b?__a:__b;
}
template<typename _sp>
inline _sp mabs(_sp __x){
    return __x>0?__x:(-__x);
}
template<typename _sp>
inline void mswap(_sp &__a,_sp &__b){
    _sp __t=__a;__a=__b;__b=__t;
}
template<typename _sp>
inline _sp mlowbit(_sp __x){
    return __x&(-__x);
}
const long long LINF=0x3f3f3f3f3f3f3f3fll;
const int INF=0x3f3f3f3f;
const double eps=1e-8;
const int Mod1=10000009;
const int Mod2=10000007;
int n,m;
std::string s[10005];
std::set<int>a1,b1,a2,b2;
inline int hash1(std::string s){
	int base=131,len=s.length();
	long long tmp=0;
	for(register int i=0;i<len;i++) tmp=(1ll*tmp*base+s[i])%Mod1;
	return tmp;
}
inline int hash2(std::string s){
	int base=131,len=s.length();
	long long tmp=0;
	for(register int i=0;i<len;i++) tmp=(1ll*tmp*base+s[i])%Mod2;
	return tmp;
}
int main(){
	qread(n);
	for(register int i=1;i<=n;i++) std::cin>>s[i];
	for(register int i=1;i<=n;i++){
		a1.insert(hash1(s[i]));
		a2.insert(hash2(s[i]));
	}
	qread(m);
	for(register int i=1;i<=m;i++){
		std::string c;
		std::cin>>c;
		int x1=hash1(c),x2=hash2(c);
		if(b1.count(x1)&&b2.count(x2)) puts("REPEAT");
		else if(a1.count(x1)&&a2.count(x2)){
			puts("OK");
			b1.insert(x1);
			b2.insert(x2);
		}
		else puts("WRONG");
	}
	return 0;
}

```


码风太丑不喜勿喷（

---

## 作者：lzpclxf (赞：6)

qwq！为什么！木有非结构体非指针的题解怎么阔以！所以， 我来辽~咻咻咻~
[题面](https://www.luogu.org/problemnew/show/P2580)
来分析， 我们可以先建一棵树，来存储整个名单， 然后再判断
```cpp
for (int i = 1; i <= n; i++) {
		root = 0;
		cin >> ch;
		int len = strlen (ch);
		for (int j = 0; j < len; j++) {
			int nu = ch[j] - 'a';
			if (!tr[root][nu]) tr[root][nu] = ++tot;
			root = tr[root][nu];
		}
		f[root] = 1;
	}
```
这一段代码是具体的存储的过程， f数组用来存储整个单词被用过几次。可以自己分析品味一哈， 这个root变量到最后存储的其实就是您目前存储的单词的最后一个字母， 也就是代表了这个单词的结束， 所以直接用root这个变量来表示这个单词被用过几次即可。
```cpp
for (int j = 0; j < len; j++) {
			int nu = ch[j] - 'a';
			if (!tr[root][nu]) {
				printf ("WRONG\n");
				break;
			}
			root = tr[root][nu];
			if (j == len - 1 && f[root] == 2) printf ("REPEAT\n");
			if (j == len - 1 && f[root] == 1) f[root] = 2,printf ("OK\n"); 
		}
```
查询， 根据题目意思， 按要求输出， 并且要注意换行， 大写之类的细节性问题。要注意， 每一次判断到最后的时候， 判断是否是被用过， 没有被用过的， 需要标记表示应经用过了

再就是root这个变量每次都要更新~~（我真的调了好久）~~

完整代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
char ch[800000];
int n, m, tr[8000000][26], s, root, tot, f[8000000];
int main () {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++) {
		root = 0;
		cin >> ch;
		int len = strlen (ch);
		for (int j = 0; j < len; j++) {
			int nu = ch[j] - 'a';
			if (!tr[root][nu]) tr[root][nu] = ++tot;
			root = tr[root][nu];
		}
		f[root] = 1;
	}
	scanf ("%d", &m);
	for (int i = 1; i <= m; i++) {
		root = 0;
		cin >> ch;
		int len = strlen (ch);
		for (int j = 0; j < len; j++) {
			int nu = ch[j] - 'a';
			if (!tr[root][nu]) {
				printf ("WRONG\n");
				break;
			}
			root = tr[root][nu];
			if (j == len - 1 && f[root] == 2) printf ("REPEAT\n");
			if (j == len - 1 && f[root] == 1) f[root] = 2,printf ("OK\n"); 
		}
	}
	return 0;
}
```


---

## 作者：RPZXG (赞：3)

作为一个菜鸡我也就发一些这种用STL轻松解掉的题


------------
言归正传，看到这道题思路非常清晰，很显然就是用到——set（在<set>库中）。我们只需要把每一个同学的名字存到集合里，然后对于老师点到的每一个名字，把他从原集合中删除并加入到另一个集合（专门存储已经点到过的人，然后进行循环搞定
  c++代码附上
  ```cpp
#include <set>
#include <iostream>
#include <string>
using namespace std;
int n,m;
string temp;
set<string> s1,s2;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>temp;
        s1.insert(temp);
    }
    cin>>m;
    while(m--)
    {
        cin>>temp;
        if(s1.count(temp)==1)
        {
            cout<<"OK"<<endl;
            s2.insert(temp);
            s1.erase(temp);
        }
        else if(s2.count(temp)==1) cout<<"REPEAT"<<endl;
        else cout<<"WRONG"<<endl;
    }
    return 0;
}

```
这里由于我是用苹果电脑所以不大方便，头文件其实直接#include <bits/stdc++.h>就可以，比较省事
  

------------
这道题就说完了
针对集合我来普及一些基本操作：                                 
  1.定义一个集合：set<数据类型> 名称；（后文假设名称为s）  
  2.在一个集合中插入元素：s.insert(temp);  
  3.在一个集合中删除元素：s.erase(temp);   
  4.查找集合中的元素（返回值只能为1或0根据数学中集合的性质）s.count(temp);  
  5.时间复杂度的问题：都是O（logn），所以不用担心RE
  

------------
最后。。第一篇题解希望管理员给个通过

---

## 作者：览遍千秋 (赞：3)

CCF开放STL真是好。

STL的map是映射，我们可以用map搞定此题，其余见注释

---
```cpp
#include<iostream>
#include<cstdio>
#include<map>
#include<string>
using namespace std;
map <string,bool> mp;
int n,m;
string a;
int main()
{
    cin>>n;
    for(register int i=1;i<=n;i++)
    {
        cin>>a;
        mp[a]=0;
    }//先读入名单并建立映射关系，一开始全部没有点过
    cin>>m;
    for(register int i=1;i<=m;i++)
    {
        cin>>a;
        if(mp.count(a)==0)//如果并没有这个人
            printf("WRONG\n");//输出错误
        else
            if(mp[a]==0)//如果这个人没被点过
                {printf("OK\n");mp[a]=1;}//输出正确并设其为点过
            else
                printf("REPEAT\n");//否则输出重复
    }
    return 0;
}
```

---

## 作者：Rye_Catcher (赞：3)

此题可以用STL中的map做，但是了解一下Trie树这个数据结构也是必须的。

Trie树（又称字典树）有以下特点：

1. 根节点不包含字符，除它之外的每一个节点都包含**一个**字符。

2. 从根节点到某一节点，路径上经过所有字符连起来为该节点对应字符串

3. 每个节点的子节点包含字符不同，也就意味着字符是可以公用的


于是我们用这样一个结构体表示每一个节点：

在本题中可以用动态数组vector贮存每个子节点


    
```cpp
             struct node{
            char c;//该点对应字符
            vector<struct node*>s;//储存儿子
            int tag;//标记是否为某一字符串结尾
            int rep; //应题目要求判断是否重复
           }*root=new struct node;
```
当然字典树有两个函数必不可少，分别是add(插入)和query（查询）。
具体怎么实现还看代码：


    
    
    
    
```cpp
    #include <cstdio>
    #include <iostream>
    #include <cstdlib>
    #include <vector>
    #include <string>
    using namespace std;
    struct node{
        char c;
        vector<struct node*>s;
        int tag;
        int rep; 
    }*root=new struct node;
    void add(string str)
    {
        struct node*p=root;
        for(int i=0;i<str.length();i++)
        {
            int j;
            for(j=0;j<p->s.size();j++)
              if(p->s[j]->c==str[i])break;//如果找到对应公用字符
            if(j==p->s.size())//如果遍历完后没找到新建一个
            {
                struct node *newnode =new struct node;
                newnode->c=str[i];
                newnode->s.clear();
                newnode->tag=0;
                newnode->rep=0; 
                p->s.push_back(newnode);
                p=newnode;
            }
            else p=p->s[j];
        } 
        p->tag=1;//标志此节点为一字符串结尾
    }
    int query(string str)
    {
        struct node*p=root;
        for(int i=0;i<str.length();i++)
        {
            int j;
            for(j=0;j<p->s.size();j++)  
                if(p->s[j]->c==str[i]) 
                     {break;}
            if(j==p->s.size()) //如果遍历完后没找到
               return 0;
            p=p->s[j];
        }
        if(p->rep!=3)
        {
            p->rep=3;return p->tag;//找到的字符可能只是某一前缀而非整个字符串，所以需要一个tag标记
        }
        else if(p->rep==3)return p->rep;
    }
    int main()
    {
        int n,m;
        char tag[50];
        cin>>n;
        root->s.clear();
        for(int i=1;i<=n;i++)
        {
            string str;
            cin>>str;
            add(str);
        }
        cin>>m;
        for(int i=1;i<=m;i++)
        {
            string str;
            cin>>str;
            int flag=query(str);
            if(flag==0)puts("WRONG");
            else if(flag==1)puts("OK");
            else if(flag==3)puts("REPEAT");
        }
        return 0;
}
```

---

## 作者：eexyz (赞：2)

明显hash，还是最基础的。即好想又好实现。
但一个显然不够。            
所以我就写了三个。（q , r , t , ec , ed , ef ) 
```c++
#include<bits/stdc++.h>
using namespace std;
short q[10000007],r[10000009],t[10000011];
int main(){
	register int n,m,l,ec,ed,ef,i,j;//register
	register char s[51];
	ios::sync_with_stdio(false);//提速
	cin>>n;
	for(i=0;i<n;++i){
		cin>>s;
		l=strlen(s);
		ec=0;
		ed=0;
		ef=0;
		for(j=0;j<l;++j){
			ec=(ec<<5)+(ec<<2)+ec;
			ed=(ed<<6)+(ed<<1)+ed;
			ef=(ef<<5)+(ef<<3)+ef;
			s[j]-='A';
			ec+=s[j];
			ed+=s[j];
			ef+=s[j];
			ec%=10000007;
			ed%=10000009;
			ef%=10000011;
		}
		q[ec]=1;
		r[ed]=1;
		t[ef]=1;
	}
	cin>>m;
	for(i=0;i<m;++i){
		cin>>s;
		l=strlen(s);
		ec=0;
		ed=0;
		ef=0;
		for(j=0;j<l;++j){
			ec=(ec<<5)+(ec<<2)+ec;
			ed=(ed<<6)+(ed<<1)+ed;
			ef=(ef<<5)+(ef<<3)+ef;
			s[j]-='A';
			ec+=s[j];
			ed+=s[j];
			ef+=s[j];
			ec%=10000007;
			ed%=10000009;
			ef%=10000011;
		}
		if(!q[ec]||!r[ed]||!t[ef]){
			putchar('W');
			putchar('R');
			putchar('O');
			putchar('N');
			putchar('G');
		}
		else if(q[ec]==1||r[ed]==1||t[ef]==1){
			putchar('O');
			putchar('K');
			++q[ec];
			++r[ed];
			++t[ef];
		}
		else{
			putchar('R');
			putchar('E');
			putchar('P');
			putchar('E');
			putchar('A');
			putchar('T');
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：晚安晚安 (赞：2)

## 运用广泛的存字符串算法：Trie树

trie树是本蒟蒻学的第一个数据结构~~如果数组不算的话~~，过了挺久了，回来发篇题解说下trie树的心得（如果还没学习trie树基础的可以先在网上学学）。

trie树，运用的是用树来存字符串，而其最大的操作性就是每一个cnt值，也就是每个已经建立的存在的节点。对于这个cnt值可以干很多事情，可以多开一个数组利用cnt存某个你想要的结果，或者是做个记号。具体可以到我blog找名字叫string的文章，那是一个典型的例子。

当干完这道模板题，就可以做做“阅读理解p3879”，然后，就可以结束trie的基本学习了。
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

char s[100];
int cnt = 1;

struct node
{
    int ch[26];
    int word;
    
}trie[1000000];

void build(char x[])
{
    int len = strlen(x);
    int now = 1;
    for(int i = 0; i < len; ++i)
    {
        if(!trie[now].ch[x[i]-'a'])
            trie[now].ch[x[i]-'a'] = ++cnt;
        now = trie[now].ch[x[i]-'a'];
    }
    trie[now].word = 1;
}

void check(char x[])
{
    int len = strlen(x);
    int now = 1;
    for(int i = 0; i < len; ++i)
    {
        if(!trie[now].ch[x[i]-'a']){printf("WRONG\n");return;}
        now = trie[now].ch[x[i]-'a'];
    }
    if(trie[now].word == 1){printf("OK\n");++trie[now].word;return;}
    else if(trie[now].word == 0){printf("WRONG\n");return;}
    else {printf("REPEAT\n");return;}
}

int main()
{
    int n, m;
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i)
    {
        scanf("%s", s);
        build(s);
    }
    scanf("%d", &m);
    for(int i = 1; i <= m; ++i)
    {
        scanf("%s", s);
        check(s);
    }
    return 0;
}
```

---

## 作者：Allons—y (赞：2)

//这道题可以用set来解决（用map的大佬勿喷），定义两个set，一个用于存放所有人名，用于判断人名是否存在。另一个用于存放被点到的人名，用于判断是否重复

```cpp
#include<iostream>
#include<set>
using namespace std;
int main(){
    set<string> s1;//定义set
    set<string> s2;//定义set
    int a,b;
    string x,y;
    cin>>a;//输入人数
    for(int i=0;i<a;i++)
    {
        cin>>x;//输入人名
        s1.insert(x);
    }
    cin>>b;//输入被点到的人数
    for(int i=0;i<b;i++)
    {
        cin>>y;//输入人名
        if(s1.count(y)==1&&s2.count(y)==1)//如果此人名存在并且已经出现过了
        {
            cout<<"REPEAT"<<endl;//输出
        }
        else if(s1.count(y)==1){//如果此人名存在
            s2.insert(y);
            cout<<"OK"<<endl;//输出
        }
        else if(s1.count(y)==0){//如果此人名不存在
            cout<<"WRONG"<<endl;//输出
        }
    }
    return 0;
}
```

---

## 作者：Henry_he (赞：2)

发现居然没有pascal的hash题解……

感觉本题有故意卡hash的嫌疑

如果hash数组贴着数据就很容易冲突

所以我们要好不吝啬的开大数组

```cpp
var num:array[0..1000006]of longint;//hash数组
    hash:array[0..1000006]of string;
    s:string;
    n,i,j,k,m:longint;
begin
  readln(n);
  for i:=1 to n do
  begin
    readln(s);
    k:=0;
    for j:=1 to length(s) do
      k:=(k*97+ord(s[j]))mod 1000007;//hash函数一点要设计好
    while length(hash[k])<>0 do//解决冲突
      k:=(k+1) mod 1000007;
    hash[k]:=s;
  end;
  readln(m);
  for i:=1 to m do//查找判断
  begin
    readln(s);
    k:=0;
    for j:=1 to length(s) do
      k:=(k*97+ord(s[j]))mod 1000007;
    while (length(hash[k])<>0)and(hash[k]<>s) do
      k:=(k+1)mod 1000007;
    if length(hash[k])<>0 then
    begin
      inc(num[k]);
      if num[k]>1 then writeln('REPEAT')
                  else writeln('OK');
    end
    else writeln('WRONG');
  end;
end.
本题其实并不难，只要注意一些坑人的细节就是一道字符串hash的模板
```

---

## 作者：风浔凌 (赞：2)

## trie字典树  P2580 
#### 只是写的稍微详细了一些。。。不知道会不会给通过。。

#### 如果没有通过的话就当我自己总结了好了qwq 

字典树，又称单词查找树，Trie树，是一种树形结构，
是一种哈希树的变种。典型应用是用于统计，
排序和保存大量的字符串（但不仅限于字符串），
所以经常被搜索引擎系统用于文本词频统计。
它的优点是：利用字符串的公共前缀来减少查询时间
，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 
//以上来自于百度百科

虽然说有通过指针实现的，但是还是数组最方便了

也就是通过一种树形结构来保存字符串（比如如下图片（又是百度的图））（逃）
![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=27e168080fb30f242197e451a9fcba26/d62a6059252dd42a745cc2c2033b5bb5c9eab806.jpg)

下面以这道题来简单地解说一下这种trie数据结构吧
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#define MAXN 100100
using namespace std;
int n,m;
char s[MAXN<<2],ss[MAXN<<2];
int son[26][MAXN<<2],last[MAXN<<2],visit[MAXN<<2];
//因为是树的数组结构......所以数组要开的大一点 
int main(){
	scanf("%d",&n);
	int cur,cnt=1;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		//输入的字符数组从1开始（而不是0） 
		int len=strlen(s+1);
		//因为是从一开始，所以是要加一的（0也算） 
		cur=1;
		//注意每次都要从根节点（也就是1）开始走 
        //根节点是没有字符储存的
		for(int j=1;j<=len;j++)
		{
			if(!son[s[j]-'a'][cur])
			   son[s[j]-'a'][cur]=++cnt;
			   //如果当前节点cur的子节点s[j-'a']还没有被赋值，就赋予它一个新的节点num 
			   //如果被赋予值了就顺着他往下走
			cur=son[s[j]-'a'][cur];
			//这里不能写成cnt，会WA的，因为走完了之后是还会回来的 
		 } 
		 last[cur]=i;
		 //这里表示的是cur节点代表的是i字符数组的最后一个节点
         //方便下面查找
	}
    //以上是建树操作
    //下面是查询~~
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",ss+1);
		cur=1;
		int len=strlen(ss+1);
        //同上
		for(int j=1;j<=len;j++)
		   cur=son[ss[j]-'a'][cur];
           //找到这个字符数组最后面一个字符所在的节点位置
			if(last[cur]){
            //如果last数组对应的有值，那么就说明这个节点在建树的时候已经存在了，那么就说明该名字合法
				if(!visit[cur])  printf("OK\n");
                //如果这个节点还没有被访问过
				else   printf("REPEAT\n");
                //如果已经访问过了
				visit[cur]=1;
			}  else printf("WRONG\n");
            //没有赋值，说明不存在某一个字符串的最后一位为cur，所以该名字不合法
	}
	return 0;
} 
```

---

## 作者：Kio_ (赞：1)

## 这题要用STL和Trie树？
并不用。
                                   
 一开始，我们很容易就会有这样的思路：  

定义一个结构体（string a与bool b，代表各个学生的名字以及是否被点到名）对于每个点名，我们只要在学生姓名表中for一遍，如果找到了，就再看这个名字是否已经被点到了，如果已经点到，就输出REPART；如果没有，就标记（标记为已点过，即b=1）,并输出OK。如果一趟没有找到，就输出WRONG。     

这种思路比较容易想到。于是，我就把这个程序写了出来，成功了一半（50分）。~~（其余点全部TLE）~~      
以下是我第一次写的程序：~~(可直接跳过）~~
```
#include<iostream>
#include<cstring>
using namespace std;
struct s
{
    string a;
    bool b;
}a[10233];//学生
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i].a;
        a[i].b=false;
    }//输入数据，并初始化a[i].b为未标记
    int n1;//相当于本题中的m
    string b1;//本题中老师点到的名字
    cin>>n1;//输入m
    for(int i=0;i<n1;i++)//对于每个老师点到的名字进行操作
    {
        bool pd=false;//判断是否存在这个名字
        cin>>b1;//输入名字
        for(int i=0;i<n;i++)//for一遍
        {
            if(a[i].a==b1)//如果找到
            {
                if(a[i].b==false)//再判断是否查找过
                {
                    cout<<"OK"<<endl;
                    a[i].b=true;//标记为已查找
                    pd=true;//标记为此名字存在
                }
                else//这个名字查找过
                {
                    cout<<"REPEAT"<<endl;
                    pd=true;//标记为此名字存在
                }
            }
        }
        if(pd==false)cout<<"WRONG"<<endl;//如果没找到，输出WRONG
    }
    return 0;///////////////////////////
}
```


那么，如何优化这个程序呢？     
我们知道，如果对于每个b1都for一遍整个学生表,就会造成较高的时间复杂度。所以，为降低时间复杂度，我们可以创建一个string数组b来存放已点到的学生名字（这样就也不需要结构体了），每次先查找这个b数组，如果查找到，输出REPART；没有就再在原表里找。

第二个程序:（多拿了10分，当前：60分）~~(及格了）~~
```
#include<iostream>
#include<cstring>
using namespace std;

string a[10233];
string b[10233];//用于存放已点到的学生名
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
    }
    int n1;
    string b1;
    int i1=0;//用来管理b数组
    cin>>n1;
    for(int i=0;i<n1;i++)
    {
        bool pd=false;
        cin>>b1;
        for(int i=0;i<=i1;i++)//从b数组里开始差找
        {
            if(b[i]==b1)//如果在b数组里找到，即已点过
            {
                pd=true;
                cout<<"REPEAT"<<endl;
                break;
            }
        }
        if(pd==false){//如果b数组里没有，即没点过
        for(int i=0;i<=n;i++)
        {
            if(a[i]==b1)
            {
                cout<<"OK"<<endl;
                pd=true;
                i1++;
                b[i1]=b1;//将b1存入b数组，即标记为已找过
                break;
            }
        }
        if(pd==false)cout<<"WRONG"<<endl;
       }
    }
    return 0;
}
```


事实证明，我们还需要优化。  

我们发现，学生名字的数量有很多，但同一长度的学生名字的数量就大大减少了。     
所以，对于每一个b1，我们可以从它的长度入手，找与它长度相等的一层名字。这样就可以再次降低时间复杂度，达到标准！

看，不需要什么复杂的Trie树和STL吧~    
~~(虽然我承认用map会更快也更方便一些）~~     
我们使用sort+cmp来对a数组排序。   
  
  最终AC代码如下：     
  ```
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int m[233];//创建m数组，用于分层。m[i]表示长度为i的名字的最后位置。如，一串名字a,aa,aaa,aaa,abc,m[3]存储的就是4。
string a[10233];
string b[10233];
bool cmp(string a,string b)//cmpsort，以长度为关键字排序
{
    return a.size()<b.size();
}
int main()
{
    int n;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
    }
    sort(a,a+n,cmp);//排序
    for(int i=0;i<n;i++)//分层。
    {
        m[a[i].size()]=i;//不断更新当前层的最后位置，所得即为当前层的最后一个元素。
    }
    m[0]=-1;
    int n1;
    string b1;
    int i1=0;
    cin>>n1;
    for(int i=0;i<n1;i++)
    {
        bool pd=false;
        cin>>b1;
        int len5=b1.size();//获取b1的长度
        for(int i=0;i<=i1;i++)
        {
            if(b[i]==b1)
            {
                pd=true;
                cout<<"REPEAT"<<endl;
                break;
            }
        }
        if(pd==false){
        for(int i=m[len5-1];i<=m[len5];i++)//使i从上一层的最后一个元素的位置，到这一层最后一个元素的位置结束。i不设为m[len5-1]+1是因为会出错。（未知原因）
        {
            if(a[i]==b1)
            {
                cout<<"OK"<<endl;
                pd=true;
                i1++;
                b[i1]=b1;
                break;
            }
        }
        if(pd==false)cout<<"WRONG"<<endl;
       
    }
    }
    return 0;//华丽结束！
}
```



---

## 作者：Punny (赞：1)

**来一发蒟luo的字典树**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000001;
int trie[maxn][26],tot=1,end[maxn],x;
void insert(char* str)
{
	int len=strlen(str),p=1;
	for(int k=0;k<len;k++)
	{
		int ch=str[k]-'a';
		if(trie[p][ch]==0) trie[p][ch]= ++tot;
		p=trie[p][ch];
	}
	end[p]=1;
}
int search(char* str)
{
	int len=strlen(str),p=1;
	for(int k=0;k<len;k++)
	{
		p=trie[p][str[k]-'a'];
		if(p==0)
		return 0;
	}
	x=p;
	return end[p];
}
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		char str[maxn];
		cin>>str;
		insert(str);
	}
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		char str[maxn];
		cin>>str;
		if(search(str)==1)
		{
			printf("OK\n");
			end[x]++;
		}
		else
		if(search(str)>1)
		printf("REPEAT\n");
		else
		printf("WRONG\n");
	}
	return 0;
}
```
在search的那里把OK的字符的end++就可以了



---

## 作者：Stella_Yan (赞：1)

这题看楼下的大佬都是用的trie树之类的东东

其实可以用**STL的map**水过去

就是说map < string,int > mm,然后mm["名字"]等于1就代表只点了一次,等于2代表重复了,等于0代表根本没这个人

贴代码:

```cpp
#include<iostream>
#include<map>
#include<string>
using namespace std;
map<string,int>mm;//定义mm,
int main()
{
	int n,m;
	string a;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		mm[a]=1;//有这个人就赋值为1
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>a;
		if(mm[a]==1)//等于1代表第一次点名
		{
			cout<<"OK"<<endl;
			mm[a]++;//mm[a]++就是把它变成2,代表点过了
		}
		else if(mm[a]==2)//等于2就代表重复了
		{
			cout<<"REPEAT"<<endl;
		}
		else//如果不重复也不正确,就代表根本没这个人,因为没这个人,所以我们没给它赋值,
		{
			cout<<"WRONG"<<endl;
		}
	}
}
```
---

很久之前(2018/3/10),我发了一篇map的题解,

很久之后(2018/7/12),我学会了Trie树(字典树)

字典树许多大佬都会了 ~~我不是大佬~~ ,这题的主要难点在于repeat的判断,一般的字典树每次判断都是yes/no,这一题需要判重,有一个方法就是再开一个bool数组。

楼下大佬用了结构体,但是我把结构体去掉了。

亲测 128ms/29MB,可放心食用。(当时map是600多ms)

具体分析看代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>//各种头文件
using namespace std;
const int MAXN=500010;
const int MAXZ=26;
int ch[MAXN][MAXZ];//ch[u][i]代表树上第u个节点的第i个字符指针指向的节点。
bool b[MAXN]={0};//判断某个节点是否为一个单词的结尾，如果不要这个的话，一个串是另一个的前缀就会误判。
bool b2[MAXN]={0};//判断一个串是否被重复访问(重复点名)
int tot=1;//节点个数。
void insert(char *s)//插入
{
	int len=strlen(s);//保存串的长度,避免重复计算。
	int u=1;//u为根节点。
	for(int i=0;i<len;i++)
	{
		int c=s[i]-'a';
		if(!ch[u][c])//如果在树上找不到单词的一个字母,
			ch[u][c]=++tot;//就新建一个节点存储进去。
		u=ch[u][c];
	}
	b[u]=true;//存储完后标记这个单词的结尾。
}
int find(char *s)//查找
{
	int len=strlen(s);
	int u=1;
	for(int i=0;i<len;i++)//查找与插入很像
	{
		int c=s[i]-'a';
		if(!ch[u][c])//如果找不到字母就直接返回0了。
			return 0;
		u=ch[u][c];
	}
	if(b[u])//要判断是否为结尾，如果不加的话那么abc和ab都会返回1。
		if(b2[u])//b2[u]为true说明点过一次了。
			return 2;
		else
		{
			b2[u]=1;//否则就标记点过名。
			return 1;
		}
	return 0;
}
int main()
{
	int n;
	char s[1024];//名字
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);
		insert(s);//读入and插入。
	}
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);
		int f=find(s);//用一个变量存储查询结果(不存储会出现玄学错误)
		if(f==0)
		{
			printf("WRONG\n");
		}	
		else if(f==1)
		{
			printf("OK\n");	
		}
		else if(f==2)
		{
			printf("REPEAT\n");	//根据结果判断点名对错。
		}
	}
    return 0;//结束。
}
```

---

## 作者：whatismyname0 (赞：1)

分析一下题意可以发现，点名有三种情况：

1. 点名正确且没点过；

2. 点名正确但点过了；

3. 点名错误；

思考一下可得：

可以用两个能够查询的数据结构存储，一个存班上所有人，一个存班上未点名的人。

但是因为点名可能重复，在那些内部元素可能具有相等键值的数据结构来说处理较麻烦，
那么我们理所当然地就想到了：

**set**

时间复杂度表面上是 $O(n+m)$ ，但算上 $set$ 查询的时间复杂度 $O(\log n)$ ，所以应是 $O(m\log n)$ 的时间复杂度，约 $10^6$ 轻松跑过。

代码如下：
```cpp
#include<iostream>
#include<string>
#include<set>
using namespace std;
set<string>dm,rp;//dm为全班名字；rp是未点名的
int n,m;
int main()
{
	cin>>n;
	for (int i=0;i<n;i++)
	{
		string t;
		cin>>t;
		dm.insert(t);
		rp.insert(t);
	}
	cin>>m;
	for (int i=0;i<m;i++)
	{
		string t;
		cin>>t;
		if (dm.find(t)!=dm.end())//有这个人
		{
			if (rp.find(t)!=rp.end())
			{
				rp.erase(rp.find(t));//从未点名名单中去掉
				cout<<"OK\n";
			}
			else cout<<"REPEAT\n";//被校长拉出去训话
		}
		else cout<<"WRONG\n";
	}
}
```
是不是特别短？

---

## 作者：Wow_Goodjob (赞：1)

本篇题解1452ms（不开O2）/30.92MB请放心~~抄袭~~食用

Wow 看到满屏的指针，当时我就震惊了。

貌似没有c++递归建trie树+map的题解，怎么办，自己写一篇呗。

------------以上是废话

既然如此，就先来简单的介绍一下map吧。

map是一种容器形似map<类型A,类型B>(map名)

他可以在内部提供一个一对一的通道（红黑树），来分别记录每一个值
在本篇题解中我们有map<string,int>kk;用kk[s]来表示字符串s是否已经出现过。

然后是以递归为核心的trie树

同样有两段函数：建树与查找

```cpp
void build(int now,int i)//建树
{
	if(i>n-1)
	{
		num[now]++;
		return;
	}
	if(p[now][s[i]-'a']==0)
	   p[now][s[i]-'a']=++tot;
	build(p[now][s[i]-'a'],i+1);
}

int find(int now,int i)//查找
{
	if(i>n-1)  
		return num[now];
	if(p[now][s[i]-'a'])  return find(p[now][s[i]-'a'],i+1);
	else return 0;
}
```
在上面的代码中tot表示字符串中每一个字符的编号，s是我们的字符串，p数组就是我们的trie树了，其中第一维表示字符在字符串中的位置，弟二维
表示的则为字符的种类

然后是主函数
```cpp
for(int i=1;i<=np;i++)
	{
		cin>>s;
		n=s.size();
		bool k;
		int ol=find(0,0);
		if(ol==0) k=false;
		else k=true;
		if(!k)
		  printf("WRONG\n");
		else if(k&&kk[s]==0)//s没有出现过 
		  {
		  printf("OK\n");
		  kk[s]=1;
		  }
		else if(k&&kk[s]==1)//s已经出现过
		  printf("REPEAT\n");
	}
```

通过查找对应的值是否为0来确定该名字是否有这么一个人
如果没有直接输出WRANG

如果有且没有被点过，就输出OK,并把其在map中的状态改为出现过了

如果有且没有被点过，就输出REPEAT。

~~附：炉石是个好游戏(逃~~


---

## 作者：huang_yue (赞：1)

这是一个有轻微bug的程序，但是由于洛谷的数据比较弱（没有任何错误的名字出现过两次以上），该程序可以AC。不信，试一下下面的数据：

1
a
4
b
b
b
b
该程序将会输出WRONG, WRONG, OK, REPEAT。错因和修复方法见下。

它的工作原理如下：用map&lt;string, int&gt;来存储每个字符出现的“次数”。每一个在名字表里出现的名字的“次数”都会被置为-2，原因是一旦碰到未出现的名字，在map上使用[]的时候，会先将这个名字的“次数”置为0，再使得出现次数-1（见代码）时就成为了-1。

    
    
```cpp
    #include<iostream>
    #include<string>
    #include<algorithm>
    #include<map>
    using namespace std;
    map<string, int> ss; //存储“次数”
    int main() {
        int w; cin >> w;
        for (int i = 0; i < w; ++i) {
            string k; cin >> k;
            ss[k] = -2; //读入，“次数”置为-2
        }
        int q; cin >> q;
        for (int i = 0; i < q; ++i) {
            string k; cin >> k;
            if (--ss[k] != -3) { //正确的“次数”为-2，则--之后应为-3
                //< -3是减了多次，应输出REPEAT； > -3也就是-1的情况
                cout << (ss[k] < -3 ? "REPEAT\n" : "WRONG\n");
            } else {
                cout << "OK\n";
            }
        }
        return 0;
    }
```
但是，当WRONG的名字出现多次，以至于ss[k]在自减的过程中达到-3的时候，就会出现开始提到的问题。那么解决的方案也是有的，而且有两个：
1. 使用map::count == 0来判断是否在名字表中。

原来本人未采用这个方法的原因是以为count是O(N)的，但是C++ reference上写着（http://www.cplusplus.com/reference/map/map/count/）:

"Complexity: Logarithmic in size." (时间复杂度O(log N))

所以可以放心使用。

2. 将ss[k]置为-100000000（或者其他小值）。

根据数据范围，即使错误答案重复出现m次，也不会有任何问题。


---

## 作者：little_gift (赞：1)

** 看到某同学在拿这题练trie,然后看了看只有pbds的hash,于是我就写个pbds的tree **

** 思路:正常思路(两个set,分别保存名字和点到的名字) **


```cpp
#include <cstdio>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp> //俩头文件
using namespace std;
int n, m;
char st[50];
string st1;
__gnu_pbds::tree < string, __gnu_pbds::null_type > m1, m2; //用法类似于map,如果要用set把map的value设置为__gnu_pbds::null_type即可.
int main()
{
    scanf("%d", &n);    
    for (register int i = n + 1; --i; ) //奇异的循环
    {
        scanf("%s", st); //听说string读入很慢
        m1.insert(st); //存在的名字
    }
    scanf("%d", &m);
    for (register int i = m + 1; --i; )
    {
        scanf("%s", st);
        st1 = st;
        if (m1.find(st1) == m1.end()) puts("WRONG"); //如果在m1中无法找到st,则表示该同学不存在.
        else if (m2.find(st1) == m2.end()) puts("OK"); //如果在m1中找到了但是m2中找不到,表示点名无误.
        else puts("REPEAT"); //如果都不是表示重复.
        m2.insert(st1); //事实上如果该同学不存在或者重复是不用insert的,不过insert了似乎也不会有误
    }
    return 0;
}
```

---

## 作者：richardchen (赞：1)

**STL~~**

/\*在本题中，可以开两个映射，第一个存下名字是否正确·，第二个存名字出现过没有\*/

```cpp
#include<cstdio>
#include<iostream>
#include<map>
using namespace std;
int n,m;
string z;
map<string,bool>a,b;//a存是否正确，b存是否出现过
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
       cin>>z;
       a[z]=true;//存所有人的名字
    }
    cin>>m;
    for(int i=1;i<=m;i++)
    {
       cin>>z;
       if(!a.count(z)) cout<<"WRONG"<<endl;//如果a里面没有z就是错误（一开始忘
       else{                                                         //了输出endl，全WA了，一直没弄明
           if(!b.count(z)){                                     //白咋回事，忽然发现是too many 
                                                                         //or too few lines...）
               cout<<"OK"<<endl;//没被点过，就OK，并打上标记
               b[z]=true;
           }
           else cout<<"REPEAT"<<endl;//被点过，就REPEAT
       }
    }
}
```

---

## 作者：zhengrunzhe (赞：1)

tire树:

这里提供一个指针建树(但跟楼下的不一样)

STL卡了我半天:

1.vector存子节点

2.string存字符串

3.cin读入,cout输出

第一遍去掉string----TLE90分

第二遍去掉cin/out-----终于过了

(vector懒得换掉了)

详情见代码:

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
const int N=100001;
struct trie //trie树的结构
{
    bool f1,f2; 
    //f1表示一个节点是否为名字的末尾(即从根节点到该节点组成的字符串是否为一个出现过的名字)
    //f2表示在点名的时候，一个名字是否被点过(即判断是否REPEAT) 
    char ch;int num; //ch是该节点代表的字母,num是编号 
    vector<trie*>son;  //用vector存子节点(被卡得厉害) 
    trie(char cc,int numb)  //构造函数 
        {ch=cc;num=numb;f1=f2=0;}
}*t[N*50]; 
int n,m,cnt;
char s[50];
void add(int p,int k,char a[50])  //添加一个字符串进树，k是当前要插入的字符的下标，所以a[k]表示当前要插入的字符 
{
    if (k==strlen(a))  //如果已经添加完毕，那么这个节点就可以标记为是单词的末尾 
        {t[p]->f1=1;return;}
    char x=a[k];
    for (int i=0;i<t[p]->son.size();i++)  //找出该节点的子节点中哪个是要插入的
        if (t[p]->son[i]->ch==x)
            {add(t[p]->son[i]->num,k+1,a);break;} //因为已经存在一个节点为要插入的字母，所以不用新开一个点存，就继续往下执行 
    //如果没有存在已经与要插入的字母相同的节点: 
    cnt++; //表示新构建的点的编号 
    t[cnt]=new trie(x,cnt);  //新建一个节点，代表要插入的字母，编号为cnt 
    t[p]->son.push_back(t[cnt]);   //把这个点纳入当前访问的节点的子节点中 
    add(cnt,k+1,a);  //继续往下执行 
}
char* run(int p,int k,char a[50])  //跑一遍查询 
{
    if (k==strlen(a))  //如果该字符串已经遍历完毕 
        if (t[p]->f1)  //如果到当前所在的节点形成的字符串是提供的名字 
            if (t[p]->f2){return "REPEAT";}  //如果已经被点到了就返回REPEAT 
            else {t[p]->f2=1;return "OK";}  //如果还未被点到就OK 
        else return "WRONG";  //虽然该字符串的所有字母都在树中，但不在名单中，就WRONG 
    for (int i=0;i<t[p]->son.size();i++)  //继续往下执行 
        if (t[p]->son[i]->ch==a[k])
            {return run(t[p]->son[i]->num,k+1,a);break;}
    return "WRONG";
}
int main()
{
    scanf("%d",&n);
    t[0]=new trie('.',0);  //建立超级根节点，无意义，用于连接 
    while (n--)
        scanf("%s",s),add(0,0,s);  //一个个添加进树 
    scanf("%d",&m);
    while (m--)
        scanf("%s",s),printf("%s\n",run(0,0,s));  //查询 
    return 0;
}
```

---

## 作者：OIer991215 (赞：1)

这时候stl的功能就体现出来了。

我用的stl是 set（集合），比大部分题解好写也好懂。

```cpp
#include<bits/stdc++.h>
using namespace std;
set<string> q,p;
string in;
int n,m,num;
int main()
{
    cin>>n;
    for( int i=1; i<=n; i++ )
    {
        cin>>in;
        q.insert(in);  //集合一存储册子上的人名 
    }
    cin>>m;
    for( int i=1; i<=m; i++ )
    {
        num=p.size();           //记录下 集合二中的元素个数 
        cin>>in;
        if( q.count(in) > 0 )  //判断集合一中有没有这个人 
        {
            p.insert(in);      //存进集合二 
            if(p.size() - num == 0)  //如果集合二 有这个人名，则集合二元素个数不变 
                cout<<"REPEAT"<<endl;
            else                    //如果集合二 没有这个人名，则集合二元素数量会发生变动 
                cout<<"OK"<<endl;
        }
        else
            cout<<"WRONG"<<endl;
    }
    return 0;
}
```

---

## 作者：Jμdge (赞：1)

为什么这道题就没有朴素点的trie呢？整面整面霸屏的指针trie可是会让入门的同学很慌张的啊！于是发一个0指针的trie模板

首先当然还是要先附个trie树详解：

[trie树入门，有图有文](http://www.cnblogs.com/cherish_yimi/archive/2009/10/12/1581666.html)

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int M=5e5+100;
string s;
int n,m,cnt;
int t[M][26];
int flag[M];
//flag[i]记录i号节点可能的三种状态：
// 0---不存在该人
// 1---存在该人且没被点过名
// 2---存在该人但已被点过名

int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	while(n--){
		cin>>s;
		int now=0,len=s.length();
        //trie树构造
		for(int i=0;i<len;++i){
			int tmp=s[i]-'a';
			if(!t[now][tmp])
				t[now][tmp]=++cnt;
			now=t[now][tmp];
		}
		flag[now]=1;
	}
	cin>>m;
	while(m--){
		cin>>s;
		int now=0,len=s.length();
		bool rig=true;
        //trie树里找人，rig表示trie树中有没有该字符串当前缀
		for(int i=0;i<len;++i){
			int tmp=s[i]-'a';
			if(!t[now][tmp]){
				rig=false;
				break;
			}
			now=t[now][tmp];
		}
		if(rig && flag[now]){
			if(flag[now]==1){
				++flag[now]; //flag++表示已经点过名了
				printf("OK\n");
			}
			else{ //不然肯定重复
				printf("REPEAT\n");
			}
		}
		else{ //查无此人输出wrong
			printf("WRONG\n");
		}
	}
	return 0;
}

```


然后这就差不多是一道trie树的模板程序了吧。

---

## 作者：ezoiHY (赞：1)

这是一道trie的模板题
但是为何要随波逐流
呵呵呵呵
这是SET的做法
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<set>

using namespace std;

set<string> s,ss;
int n,m;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		string sss;
		cin>>sss;
		s.insert(sss);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		string sss;
		cin>>sss;
		if(s.count(sss)){
			if(ss.count(sss)){
				puts("REPEAT");
			}else{
				ss.insert(sss);
				puts("OK");
			}
		}else{
			puts("WRONG");
		}
	}
}
```

---

## 作者：赖胤旗0709 (赞：1)

# 来自**C++**的嘲讽ing

### 我用的是另一个STL~~~set

看到很多人用map，trie树，还有鬼畜的二分快排

很明显是 _（我）_ 垃 _（不）_ 圾 _（会）_ 

用两个set，一个存名单，一个存点过的人。第二次读进来的字符串find分别在两个set嗖一下就过了呢

因为find是从头到尾一个个判断，所以如果没有就是返回最后的迭代器end，手动判一下返回值是不是就可以了

时间当然是O（n+m）~~[为了显摆，find时间就不算了QAQ]~~

Do you want to know more？（我英语并不好）看代码吧！

代码：
```cpp
#include<iostream>

#include<cstdio>

#include<set>

std::set< std::string>a,b;//好像是红黑树，反正奇快无比，每个元素只有一个，亦能记录存入次数->这儿比较好[set详解](https://www.cnblogs.com/caiyishuai/p/8646345.html)

std::string str;

int n,m;

int main()

{
 	
       std::scanf("%d",&n);
    
 	   for(register int i=1;i<=n;++i)
    
 	   {
    
 		std::cin>>str;
        
 		a.insert(str); //名单的set
        
       }
       std::scanf("%d",&m);
    
       for(register int i=1;i<=m;++i)
   
       {
      
             std::cin>>str;
      
             if(a.find(str)!=a.end()&&b.find(str)==b.end())//上面说的查+判
      
             {
       	 
                 std::printf("OK\n");
    	   
                 b.insert(str); //点过set
		
             }
      
	         else   if(a.find(str)!=a.end()&&b.find(str)!=b.end()) std::printf("REPEAT\n");
	         if(a.find(str)==a.end()) std::printf("WRONG\n");
	    }
}

```


---

## 作者：HyperLuXury (赞：0)

其实这题不用那么麻烦，直接用二分加快排就行了
```pascal
var n,m,i,x:longint;s:string;
f:array[1..10000] of boolean;
a:array[1..10000] of string;
procedure sort(l,r:longint);//快排（pascal自带的）
      var
         i,j:longint;x,y:string;
      begin
         i:=l;//头指针
         j:=r;//尾指针
         x:=a[(l+r) div 2];
         repeat
           while a[i]<x do
            inc(i);
           while x<a[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
function find(s:string):longint;//二分函数
var t,w,mid:longint;
begin
t:=1;//头指针
w:=n;//尾指针
while t<=w do
  begin
  mid:=(t+w) div 2;//中间一个数的位置
  if a[mid]=s then exit(mid)//找到则返回位置
  else if a[mid]>s then w:=mid-1//尾指针向前挪
  else t:=mid+1;//头指针向后挪
  end;
exit(-1);
end;
begin
readln(n);
for i:=1 to n do readln(a[i]);
sort(1,n);//对a数组进行快排
readln(m);
for i:=1 to m do
  begin
  readln(s);//读入名字
  x:=find(s);//找到当前这个名字在a数组中是第几个
  if x>-1 then//-1表示找不到，大于-1表示找得到
    begin
    if f[x] then writeln('REPEAT') else writeln('OK');//f数组记录这个名字是否点过
  f[x]:=true;//将当前这个名字标为已点过
    end
  else writeln('WRONG');//找不到则输出WRONG
  end;
end.


```


---

## 作者：罗旅洲 (赞：0)

/\*
给一个不用指针，用链式前向星写的TRIE，当初只为省空间

\*/

```cpp
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Rep(i,a,b) for(register int i=a;i>=b;--i)
const int maxx=5000001;
using namespace std;
int be[maxx],ne[maxx],to[maxx],e=0,cnt=0;    //cnt表示节点编号，e表示边的编号
void add(int x,int y){
    to[++e]=y;
    ne[e]=be[x];
    be[x]=e;
}
struct node{
    char x;                    //x:当前节点所存的字符
    bool vis,end;            //vis 是否REPEAT  end是否为名字结尾
}trie[maxx];
char name[56];
void insert(char *s){            //插入操作
    int pos=0,len=strlen(s),i=0,flag;
    For(i,0,len-1){    
        flag=0;
        for(int j=be[pos];j;j=ne[j]){
            int go=to[j];
            if(trie[go].x==s[i]){            //找到已有相同节点，就把位置赋给pos
                flag=1;
                pos=go;
                break;
            }
        }
        if(!flag) {add(pos,++cnt); pos=cnt; trie[pos].x=s[i];}//没有找到就新建节点，单向边！
        if(i==len-1) trie[pos].end=1;        //标记结束
    }
}
int query(char *s){
    int pos=0,len=strlen(s),i=0,flag;
    For(i,0,len-1){
        flag=0;
        for(int j=be[pos];j;j=ne[j]){
            int go=to[j];
            if(trie[go].x==s[i]){
                pos=go;
                flag=1;
                break;
            }
        }
        if(!flag) return 0;                //没找到就返回0
        if(i==len-1)
            if(trie[pos].end){            //判断是否REPERT
                if(!trie[pos].vis) {trie[pos].vis=1; return 1;}        
                else return 2;
            }
            else return 0;
    }
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("input.in", "r", stdin);
    freopen("output.out", "w", stdout);
#endif
    int n,m,k;
    scanf("%d",&n);
    For(i,1,n){
        scanf("%s",name);
        insert(name);
    }
    scanf("%d",&m);
    For(i,1,m){
        scanf("%s",name);
        k=query(name);
        if(k==1) puts("OK");
        else if(!k) puts("WRONG");
        else puts("REPEAT");
    }
    return 0;
}

```

---

## 作者：__dper__ (赞：0)

看到没有c++的trie，交一个

首先关于trie的实现，是非常好理解的

其实就是一个节点呢，有好多好多儿子，每个儿子就对应着一个字符，比如字符串“abc”吧，在trie树中的搜索过程就是从根结点开始，

如果有代表‘a’的孩子，且该孩子不为空，那我们就走向那个节点

接着再找有没有表示‘b’ 的节点 同理有继续走，没有跳出

...
关于判重，一开始我想维护两棵trie结果mle了... 于是老老实实如果在trie上找到了这个字符串，就在这个字符串的结尾cnt+1，下一次再找到这个节点，发现cnt>1，那就是数重了


```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct trie{
    char _data;
    trie *_child[28];//trie的孩子 
    int _cnt;//以该点为结尾的字符串个数 
};
trie * create(){//动态分配加初始化不解释 
    trie *_ret = (trie *)malloc(sizeof(trie));
    _ret->_data = 0;
    for(int i = 0 ; i < 28 ; i++){
        _ret->_child[i] = NULL;
    }
    _ret->_cnt = 0;
    _ret->color = 0;
    return _ret;
}
void insert(trie *_root,char *_in){//插入 
    trie *node = _root;
    char *point = _in;
    while(*point){
        if( node->_child[ *point - 'a' ] == NULL){
            node->_child[ *point - 'a' ] = create();
        }
        node = node->_child[ *point - 'a'];
        point++;
    }
}

int search(trie *_root,char *in){//查找，维护cnt 
    trie *node = _root;
    char *point = in;
    while(*point){
        if(node->_child[ *point - 'a'] == NULL){
            return 0;
        }
        else{
            node = node->_child[ *point - 'a'];
        }
        point++;
    }
    node->_cnt++;
    return node->_cnt;
}
trie *rot;
int main(){
    rot = create();
    int n,m;
    char input[100];
    scanf("%d",&n);
    for(int i = 0 ; i < n ; i++){
        scanf("%s",input);
        insert(rot,input);
    }
    scanf("%d",&m);
    for(int j = 0 ; j < m ; j++){
        scanf("%s",input);
        int _cnt = search(rot,input);
        if(_cnt==0){
            printf("WRONG\n");
        }
        else if(_cnt==1){
            printf("OK\n");
        }
        else{
            printf("REPEAT\n");
        }
    }
    return 0;
}
```

---

## 作者：ws_fuweidong (赞：0)

map大法好！

stl大法好！！

用map来储存字符串s是否出现过，是否正确

代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<map>
#include<cstdio>
using namespace std;
map<string,int> a;
int main(){
    int n; scanf("%d",&n);
    for (int i=1;i<=n;i++){
        string s;
        cin>>s;
        a[s]=1;//表示字符串s是正确的
    }
    int m; scanf("%d",&m);
    for (int i=1;i<=m;i++){
        string s;
        cin>>s;
        if (a[s]==0) {//不正确
            printf("WRONG\n");
            continue;
        }
        if (a[s]==1){
            printf("OK\n");
            a[s]++;//出现一次了
            continue;
        }
        if (a[s]>1) printf("REPEAT\n");
    }
    return 0;
}
```

---

## 作者：hibiki (赞：0)

维护一个trie树，在每个单词的末端节点用count数组记录这个节点当前的状态。效率O(m\*maxlength).

```pascal
Var
    n,i,m,cnt,tt:longint;
    t:ansistring;
    trie:array[0..500010,'a'..'z'] of longint;
    count:array[0..500010] of longint; //0代表不是终点，1代表是终点，2代表已经被点到一次
Procedure add(t:ansistring);
    var
        now,i:longint;
    begin
        now:=0;
        for i:=1 to length(t) do begin
            if trie[now,t[i]]<>0 then now:=trie[now,t[i]] else begin
                inc(cnt);
                trie[now,t[i]]:=cnt;
                now:=cnt;
            end;
        end;
        inc(count[now]);
    end;
Function search(t:ansistring):longint;
    var
        now,i:longint;
    begin
        now:=0;
        for i:=1 to length(t) do begin
            if trie[now,t[i]]<>0 then now:=trie[now,t[i]] else exit(0);
        end;
        if count[now]=1 then begin
            inc(count[now]);
            exit(1);
        end else exit(count[now]);
    end;
Begin
    readln(n);
    fillchar(count,sizeof(count),0);
    for i:=1 to n do begin
        readln(t);
        add(t);
    end;
        readln(m);
    for i:=1 to m do begin
        readln(t);
        tt:=search(t);
        if tt=1 then writeln('OK');
        if tt=2 then writeln('REPEAT');
        if tt=0 then writeln('WRONG');
    end;
End.
```

---

## 作者：神姬2016 (赞：0)

排序之后二分查找比较快的。。。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio> 
using namespace std;
#define GY 10005
struct node{
    char s[61];
    bool d;
}a[GY];
int cmp(const void *a,const void *b){
    node p=*(node *)a,q=*(node *)b;
    return strcmp(p.s,q.s);
}
int main(){
    int n,i,j,m;
    char x[61];
    cin>>n;
    for(i=0;i<n;i++)
        scanf("%s",a[i].s);
    cin>>m;
    qsort(a,n,sizeof(a[0]),cmp);
    for(i=0;i<m;i++){
        scanf("%s",x);
        int h=0,r=n;
        while(h+1<r){
            int mid=(h+r)/2;
            if(strcmp(a[mid].s,x)==0){
                h=mid;
                break;
            }
            if(strcmp(a[mid].s,x)>0) r=mid;
            else h=mid;
        }
        if(strcmp(a[h].s,x)==0)
        if(a[h].d==false){
            printf("OK\n");
            a[h].d=true;
        }else printf("REPEAT\n");
        else printf("WRONG\n");
    }
    return 0;
}
```

---

## 作者：宇道人 (赞：0)

# 关于Too many or too few lines的解决方案


	如果你的提交出现WA的原因是Too many or too few lines，那么注意一下你是否出现以下情况：
    1.调试输出未删除
    2.是不是加了文件忘记删
    3.C++的朋友不要用getline读入字符串，直接用cin

评测环境比较玄学，我开始就是直接用getline读入的字符串，本地和洛谷IDE上跑的结果都没问题，但是一提交到OJ上就十个点全WA，原因是Too many or too few lines。后来我把getline换成了cin，就直接AC了。



------------
至于为什么会这样我也不知道，但是如果你出现了Too many or too few lines的情况可以看看你是不是用了getline进行读入。

------------



这里是WA的代码（部分）
```cpp
int main()
{
    int n=0,m=0;
    trie t;
    string str;
    cin>>n;getchar();
    for(int i=0;i<n;i++){
        getline(cin,str);    //这里用了getline，于是就高高兴兴的WA了
        t.insert(str);
        str.clear();
    }
    cin>>m;getchar();
    for(int i=0;i<m;i++){
        getline(cin,str);
        int ans = t.find(str);
        if(ans == 0)cout<<"WRONG";
        else if(ans == 1)cout<<"REPEAT";
        else if(ans == 2)cout<<"OK";
        str.clear();
        cout<<endl;
    }

    return 0;
}
```

这里是完整AC代码，字典树我是用动态内存实现的可能写的比较冗长，将就着看看吧

```
#include<iostream>
#include<cstdio>
#include<string>
#include<vector>
#include<iterator>
using namespace std;

struct node
{
    char value;   //元素的值
    bool word;  //是否为单词节点
    bool ifind;    //节点是否被作为单词而访问
    vector<node*>son;

    node(){
        value = 0;
        word = false;
        ifind = false;
    }

    ~node(){
    	vector<node*>::iterator it;
    	for(it = son.begin();it!=son.end();it++){
            delete *it;
    	}
    }
};

class trie
{
public:
    node root;

public:
    int insert(string &str);
    int find(string &str);
};

int trie::insert(string &str)
{
    string::iterator it;
    node *p = &root;
    for(it=str.begin();it!=str.end();it++){
        bool k =false;  //子节点中是否含有与待检测字符匹配的
        vector<node*>::iterator vit;
        for(vit = p->son.begin();vit != p->son.end();vit++){
            if(*it == (*vit)->value){
                k = true;
                p = (*vit);
                break;
            }
        }
        if(k == false){
            p->son.push_back(new node);
            p = *(p->son.end()-1);
            p->value = *it;
        }
    }
    p->word = true;
    return 0;
}

int trie::find(string &str)
{
    string::iterator it;
    node *p =&root;
    for(it=str.begin();it!=str.end();it++){
        bool k = false; // 是否找到匹配的字符
        vector<node*>::iterator vit;
        for(vit = p->son.begin();vit != p->son.end();vit++){
            if(*it == (*vit)->value){
                 k =true;
                 p = (*vit);
                 break;
            }
        }
        if(k == false)return 0;
    }
    if(p->word == false)return 0;
    else if(p->ifind == true)return 1;
    else {
        p->ifind = true;
        return 2;
    }
}


int main()
{
    int n=0,m=0;
    trie t;
    string str;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>str;
        t.insert(str);
        str.clear();
    }
    cin>>m;
    for(int i=0;i<m;i++){
        cin>>str;
        int ans = t.find(str);
        if(ans == 0)cout<<"WRONG";
        else if(ans == 1)cout<<"REPEAT";
        else if(ans == 2)cout<<"OK";
        str.clear();
        cout<<endl;
    }

    return 0;
}
```


---


# 2038年问题

## 题目描述

网络时代，机会与危机共存。“千年虫”解决之后，会不会有新的“虫”出现？回答是肯定的，“2038年”就是一个新的关卡。

也许大家都已经知道计算机的2000年问题是什么概念，但是什么时候又冒出来一个2038年问题的呢？

用C语言编制的程序不会碰到2000年问题，但是会有2038年问题。这是因为，大多数C语言程序都使用到一个叫做“标准时间库”的程序库，这个时间库用一个标准的4字节也就是32位的形式来储存时间信息。

当初设计的时候，这个4字节的时间格式把1970年1月1日凌晨0时0分0秒作为时间起点，这时的时间值为0。以后所有的时间都是从这个时间开始一秒一秒累积得来的。

比方说如果时间已经累积到了919642718这个数值，就是说这时距离1970年1月1日凌晨0时0分0已经过去了919642718秒，换算一下就应该是1999年2月21日星期天16时18分38秒。

这样计算时间的好处在于，把任意两个时间值相减之后，就可以很迅速地得到这两个时间之间相差的秒数，然后你可以利用别的程序把它换算成明白易懂的年月日时分秒的形式。

一个4字节也就是32位的存储空间的最大值是2147483647，请注意！2038年问题的关键也就在这里———当时间一秒一秒地跳完2147483647那惊心动魄的最后一秒后，它就会转为负数也就是说时间无效。那一刻的准确的时间为2038年1月19日星期二晚上03:14:07，之后所有用到这种“标准时间库”的C语言程序都会碰到时间计算上的麻烦。

你要解决的问题是，现有一台计算机，表示时间的变量长度为N位。给定一个“时间起点”，求出对于这个“时间起点”时间，最后的有效时间是什么时候。


## 说明/提示

对于50%的数据 变量的位数<=16;

对于所有数据，变量长度<=32,数据组数<=1000,0<=年份<=10000


## 样例 #1

### 输入

```
1                             
16 2000 1 1 0 0 0```

### 输出

```
2000 1 1 9 6 7```

## 样例 #2

### 输入

```
2
32 1970 1 1 0 0 0
32 2015 11 8 8 30 0```

### 输出

```
2038 1 19 3 14 7
2083 11 26 11 44 7```

# 题解

## 作者：αnonymous (赞：46)

发现c++党都是先确定年份，再确定月份及以下时间~~，感到震惊~~

其实可以直接从秒开始往年推，先把秒加上最大限度的时间，再把秒化为分，以此类推

### 核心
计算天数时需考虑到月份和年份（每月天数不同，闰年和平年不同），所以需一次次推，天数减去当月的天数后，将月份加1，如果月份大于12,年份加1
```cpp
#include <iostream>
using namespace std;
long long t,y,m,d,h,mi,s,len;//变量依次代表数据组数，年，月，天，小时，分钟，秒，时间的变量长度
long long n[33];
int mo[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
void check(){//判断闰年，并修改2月天数
	if((y%4==0&&y%100!=0)||y%400==0)
		mo[2]=29;
	else
		mo[2]=28;
}
int main(){
	int i,j;
	long long k;
	n[1]=1;//记忆化搜索,直接调用相应长度的二进制数的值
	for(i=2;i<=32;i++)
		n[i]=n[i-1]*2;
	cin>>t;
	while(t--){
		cin>>len>>y>>m>>d>>h>>mi>>s;
		s+=n[len]-1;//注意这里需要减1，因为不能计时到最大长度
		k=s/60;//化成分钟数
		s%=60;//化简后的秒数
		mi+=k;
		k=mi/60;//化成小时
		mi%=60;//化简后的分钟
		h+=k;
		k=h/24;
		h%=24;
		d+=k;
		if(m==2)//前方高能,先判断闰年
			check();
		while(d>mo[m]){
			d-=mo[m];//减去当月的天数
			m++;//月份+1
			if(m>12){//年份+1
				m=1;
				y++;
			}
			if(m==2)//月份为2时，要检查闰年和平年
				check();
		}
		cout<<y<<" "<<m<<" "<<d<<" "<<h<<" "<<mi<<" "<<s<<endl;//输出
	}
	return 0;//功德圆满
}
```


---

## 作者：clyoyo (赞：11)

思路有所不同，我来发个P党的题解~

将输入时间的日，时，分，秒都化作秒数，加上2^变量长度-1，这样做就相当于化作这个月的1号0点0分0秒

然后按月枚举，从总时间中减去每个月的秒数，算出年和月，减完以后再算日，时，分，秒


附上代码：


```cpp
var i,t,l,y,m,d,h,mm,s:longint;
    sum:int64;
    x:array[1..12] of longint=(31,28,31,30,31,30,31,31,30,31,30,31);
    z:array[0..31] of longint;
function ys(n:longint):longint;//返回n月的秒数
begin
  ys:=86400;
  if ((y mod 400=0) or (y mod 100<>0)) and (y mod 4=0) and (m=2) then 
    exit(ys*29) else exit(ys*x[n]);
end;
begin
  z[0]:=0;
  for i:=1 to 31 do 
    z[i]:=z[i-1]*2+1;//算2^31
  readln(t);
  for i:=1 to t do
  begin
    readln(l,y,m,d,h,mm,s);
    sum:=z[l-1]+(d-1)*86400+h*3600+mm*60+s;//将日 时 分 秒 都化作秒数
    while ys(m)<=sum do//按月枚举
    begin
      sum:=sum-ys(m);
      inc(m);
      if m=13 then begin m:=1; inc(y); end;
    end;
    d:=sum div 86400+1;
    h:=(sum mod 86400) div 3600;
    mm:=(sum mod 3600) div 60;
    s:=sum mod 60;
    writeln(y,' ',m,' ',d,' ',h,' ',mm,' ',s);
  end;
end.
```

---

## 作者：DoloresL (赞：6)

额(⊙o⊙)…

主要就是耐心的模拟

必要的说明 在代码上都有注释


```cpp
//P2655 2038年问题
//2017.2.6 

#include <iostream>
#include <cstdio>
int const daysec =  24 * 60 * 60;   //一天的秒数 
int const monthday[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};   //每个月的天数 
using namespace std;

int tt;
long long time0;
int year0, month0, day0, hour0, minute0, second0;

int d(int year){   //求在year这一年有多少天 
    if (year % 100 == 0 && year % 400 != 0) return 365;
    if (year % 4 == 0) return 366;
    return 365;
}

void add(){
    for (int i = 1; i < month0; i++){
        if (d(year0) == 366 && i == 2)
            time0 = time0 + 29 * daysec;
        else time0 = time0 + monthday[i] * daysec;
    }
    time0 = time0 + (day0 - 1) * daysec;   //要减去1 
    time0 = time0 + hour0 * 60 * 60;
    time0 = time0 + minute0 * 60;
    time0 = time0 + second0;
    
    return ;
} 

int main(){
    scanf("%d", &tt);
    for (int i0 = 0; i0 < tt; i0++){
        cin >> time0;
        scanf("%d%d%d%d%d%d", &year0, &month0, &day0, &hour0, &minute0, &second0);
        time0 = (1 << time0 - 1) - 1;   //还剩多少秒要处理 
        int year = year0;
        
        add();
        
        //确定年 
        while (true){
//            cout << year << ": " << d(year) << endl;
            if (time0 - d(year) * daysec < 0) break;
            time0 = time0 - d(year) * daysec;
            year++;
        }
        
        //确定月 
        int month;
        for (int i = 1; i <= 12; i++){
//            cout << i << endl;
            if (i == 2 && d(year) == 366){   //若是闰年的二月 则特殊对待 
                if (time0 - 29 * daysec < 0){
                    month = i;
                    break;
                }
                time0 = time0 - 29 * daysec;
            }
            else{
                if (time0 - monthday[i] * daysec < 0){
                    month = i;
                    break;
                }
                time0 = time0 - monthday[i] * daysec;
            }
        }
        
        //确定天
        int day = time0 / daysec + 1;   //要加1 因为天数从1开始记 
        time0 = time0 % daysec;
        
        //确定时 
        int hour = time0 / (60 * 60);
        time0 = time0 % (60 * 60);
        
        //确定分
        int minute = time0 / 60;
        time0 = time0 % 60;
        
        //确定秒
        int second = time0;
        
        printf("%d %d %d %d %d %d\n", year, month, day, hour, minute, second); 
    }
    
    return 0;
}
```

P.S:
我一开始做的时候 把time0命名为time

本机没有报错

然而提交时RE


---

## 作者：VectorChange (赞：6)

[点我传送至原题](https://www.luogu.com.cn/problem/P2655)

模拟题，大致思路就是从秒往上推，在月的时候用 while 枚举月份天数。当然，一定要记得判定闰年二月，我采取了函数更新二月月份。当然，该题还可以从年份往下退，但我认为从年往下推比较麻烦，有兴趣的读者可以试试。

以下是代码，仅供参考：

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct Time{
	ll Year;
	ll Month;
	ll Day;
	ll Hour;
	ll Min;
	ll Sec;
}Time;
ll T,Long;
int Mth[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};//打表各月天数
void check(){
	if((Time.Year%4==0&&Time.Year%100!=0)||Time.Year%400==0) Mth[2]=29;
	else Mth[2]=28;
}
int main(){
  scanf("%d",&T);
  while(T--) {
    scanf("%d%d%d%d%d%d%d",&Long,&Time.Year,&Time.Month,&Time.Day,&Time.Hour,&Time.Min,&Time.Sec);
    Long=pow(2,Long-1)-1;
    Time.Sec+=Long;
    Time.Min+=Time.Sec/60;
    Time.Sec%=60;
    Time.Hour+=Time.Min/60;
    Time.Min%=60;
    Time.Day+=Time.Hour/24;
    Time.Hour%=24;
    if(Time.Month==2) check();
    while(Time.Day>Mth[Time.Month]){
      Time.Day-=Mth[Time.Month];
      Time.Month++;
      if(Time.Month>12){
      	Time.Month=1;
      	Time.Year++;
      }
      if(Time.Month==2) check();
    }
  printf("%d %d %d %d %d %d\n",Time.Year,Time.Month,Time.Day,Time.Hour,Time.Min,Time.Sec);
  }
  return 0;
}
```


---

## 作者：EgLund (赞：3)

来一发比较 unique 的题解。

### 思路

我们直接往后跳天，先跳年，再跳月，随后是日，时，分，秒。

注意跳时候的向前进位。

我们逐步分析代码。

### 代码分析

#### 1.用到的基本函数

```cpp
bool leap(int x){if(x%100==0 && x%400!=0)return 0;if(x%4==0)return 1;return 0;}
bool isleakedday()
{
	if
	(
		((month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12) && day==32)
	||	((month==4 || month==6 || month==9 || month==11) && day==31)
	||	(month==2 &&  day==(leap(year)?30:29))
	)return 1;
	else return 0;
}
bool isbeforeFeb()
{
	return !(month>2);
}
int monthcnt()
{
	if(month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12)return 31;
	if(month==4 || month==6 || month==9 || month==11)return 30;
	if(month==2)return (leap(year)?29:28);
	return 0;
}
int yearcnt()
{
	if(leap(year))
	{
		if(isbeforeFeb())return 366;
		return 365;
	}
	else if(leap(year+1))
	{
		if(isbeforeFeb())return 365;
		return 366;
	}
	else return 365;
}
```

`leap`：判断闰年。

`isleakedday`：判断是否需要从日向月进位，即是否跨过月末。

`isbeforeFeb`：是否在二月之前，主要用于跳年时判断跳过的天数是 $365$ 还是 $366$，即函数 `yearcnt`。

`monthcnt`：某年某月的天数。用于跳月是判断跳了多少天。

`yearcnt`：见 `isbeforeFeb`。

#### 2.跳时间

以跳秒为例。

```cpp
int secondlen()
{
	return 1;
}
void jumpsecond()
{
	c-=secondlen();
	second++;
	if(second==60)minute++,second=0;
	if(minute==60)hour++,minute=0;
	if(hour==24)day++,hour=0;
	if(isleakedday())day=1,month++;
	if(month==13)month=1,year++;
	//cout<<"jump a second to";output();
}
```

`secondlen`：一秒的长度（单位：秒）。

`jumpsecond`：跳 $1$ 秒。

具体实现：

1. 减少剩余时间。
2. 考虑不进位的情况，将表示秒的变量 $second$ 加 $1$。
3. 进位。依次考虑：秒向分，分向时，时向天，天向月，月向年。

后面跳分、时、天、月、年类似。

#### 3.主函数内实现

```cpp
signed main()
{
	int t;cin>>t;while(t--){
	cin>>d>>year>>month>>day>>hour>>minute>>second;
	c=(1<<d-1)-1;
	while(c>=yearlen())jumpyear();
	while(c>=monthlen())jumpmonth();
	while(c>=daylen())jumpday();
	while(c>=hourlen())jumphour();
	while(c>=minutelen())jumpminute();
	while(c>=secondlen())jumpsecond();
	cout<<year<<' '<<month<<' '<<day<<' '<<hour<<' '<<minute<<' '<<second<<endl;
		
}}
```

这里是 `secondlen` 系列函数的另一种用法：判断是否足够跳过这段时间。

#### 4.总代码

```cpp
#include<iostream>
#define int long long
using namespace std;
int year,month,day,hour,minute,second;int d,c;

void output(){printf("%d/%d/%d/%d/%d/%d with %d day last\n",year,month,day,hour,minute,second,c);}

bool leap(int x){if(x%100==0 && x%400!=0)return 0;if(x%4==0)return 1;return 0;}

bool isleakedday()
{
	if
	(
		((month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12) && day==32)
	||	((month==4 || month==6 || month==9 || month==11) && day==31)
	||	(month==2 &&  day==(leap(year)?30:29))
	)return 1;
	else return 0;
}
bool isbeforeFeb()
{
	return !(month>2);
}
int monthcnt()
{
	if(month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12)return 31;
	if(month==4 || month==6 || month==9 || month==11)return 30;
	if(month==2)return (leap(year)?29:28);
	return 0;
}
int yearcnt()
{
	if(leap(year))
	{
		if(isbeforeFeb())return 366;
		return 365;
	}
	else if(leap(year+1))
	{
		if(isbeforeFeb())return 365;
		return 366;
	}
	else return 365;
}

int secondlen()
{
	return 1;
}
void jumpsecond()
{
	c-=secondlen();
	second++;
	if(second==60)minute++,second=0;
	if(minute==60)hour++,minute=0;
	if(hour==24)day++,hour=0;
	if(isleakedday())day=1,month++;
	if(month==13)month=1,year++;
	//cout<<"jump a second to";output();
}

int minutelen()
{
	return 60;
}
void jumpminute()
{
	c-=minutelen();
	minute++;
	if(minute==60)hour++,minute=0;
	if(hour==24)day++,hour=0;
	if(isleakedday())day=1,month++;
	if(month==13)month=1,year++;
	//cout<<"jump a minute to";output();
}

int hourlen()
{
	return 60*60;
}
void jumphour()
{
	c-=hourlen();
	hour++;
	if(hour==24)day++,hour=0;
	if(isleakedday())day=1,month++;
	if(month==13)month=1,year++;
	//cout<<"jump a hour to";output();
}

int daylen()
{
	return 24*60*60;
}
void jumpday()
{
	c-=daylen();
	day++;
	if(isleakedday())day=1,month++;
	if(month==13)month=1,year++;
	//cout<<"jump a day to";output();
}

int monthlen()
{
	return monthcnt()*daylen();
}
void jumpmonth()
{
	c-=monthlen();
	month++;
	if(month==13)month=1,year++;
	//cout<<"jump a month to";output();
}

int yearlen()
{
	return yearcnt()*daylen();
}
void jumpyear()
{
	c-=yearlen();
	year++;
	//cout<<"jump a year to";output();
}

signed main()
{
	int t;cin>>t;while(t--){
		cin>>d>>year>>month>>day>>hour>>minute>>second;
		c=(1<<d-1)-1;
		while(c>=yearlen())jumpyear();
		while(c>=monthlen())jumpmonth();
		while(c>=daylen())jumpday();
		while(c>=hourlen())jumphour();
		while(c>=minutelen())jumpminute();
		while(c>=secondlen())jumpsecond();
		cout<<year<<' '<<month<<' '<<day<<' '<<hour<<' '<<minute<<' '<<second<<endl;
		
}}
```

---

## 作者：sfd158 (赞：3)

这是一道有点麻烦的模拟题

```cpp

#include<cstdio>
const int mouth[]={0,31,28,31,30,31,30,31,31,30,31,30,31};//枚举每个月的天数
bool is_ok(int x)//判断是否是闰年
{
    if(x%100==0 && x%400!=0)return 0;
    if(x%4==0)return 1;
    return 0;
}
int main()
{
    int i,n,npxk,mlt=1,j,k,y,m,d,h,min,sec,yy,mm,dd,hh,minn,secc,sum_1;
    scanf("%d",&npxk);
    for(i=0;i<npxk;i++)//循环次数
    {
        mlt=1;
        scanf("%d%d%d%d%d%d%d",&k,&y,&m,&d,&h,&min,&sec);
        mlt=(1<<k-1)-1;//可以存储的最大时间
        yy=y+mlt/31536000;//确定年份
        mlt%=31536000;
        for(j=y;j<yy;j++)
            if(is_ok(j))
                mlt-=86400;//对y年到yy年中的闰年进行特殊处理
        sum_1=(d-1)*86400+h*3600+min*60+sec;
        for(j=1;j<m;j++)
            sum_1+=mouth[j]*86400;
        if(is_ok(y) && m>2)sum_1+=86400;
        mlt+=sum_1;
        if(is_ok(yy))//年份进位
        {
            if(mlt>=31622400)
            {
                yy++;
                mlt-=31622400;
            }
        }
        else
        {
            if(mlt>=31536000)
            {
                yy++;
                mlt-=31536000;
            }
        }
        sum_1=0;
        for(mm=1;mm<=12;mm++)//确定月份
        {
            if(mm!=2)sum_1+=mouth[mm]*86400;
            else
            {
                if(is_ok(yy))sum_1+=29*86400;
                else sum_1+=28*86400;
            }
            if(sum_1>mlt)break;
        }
        for(j=1;j<mm;j++)
            if(j!=2)mlt-=mouth[j]*86400;
            else
            {
                if(is_ok(yy))mlt-=29*86400;
                else mlt-=28*86400;
            }
        dd=mlt/86400+1;//确定天数
        mlt%=86400;
        hh=mlt/3600;//确定小时
        mlt%=3600;
        minn=mlt/60;//确定分
        mlt%=60;
        secc=mlt;//确定秒
        printf("%d %d %d %d %d %d\n",yy,mm,dd,hh,minn,secc);//输出结果
    }
    return 0;
}

```

---

## 作者：Flagship (赞：2)

我来发一个java的吧  ~~~~其实都差不多~~~~
### 我的思路就是先把当前时间拨回到该年的1月1日0时0分0秒
### 然后再算出对应的年月日


------------
```java
import java.util.Scanner;

public class Main {
    static int month[]=new int[]{0,31,28,31,30,31,30,31,31,30,31,30,31};//每个月的天数
    public static void main(String[] args){
        Scanner input=new Scanner(System.in);
        int n=input.nextInt();
        int y,m,d,h,min,s,t;//年月日时分秒
        long bit;
        long ones=1,onemin=60,oneh=onemin*60,oneday=oneh*24,sum,overs;
        for(int i=0;i<n;i++){
            t=input.nextInt()-1;
            bit=(int)Math.pow(2,t)-1;
            y=input.nextInt();
            m=input.nextInt();
            d=input.nextInt();
            h=input.nextInt();
            min=input.nextInt();
            s=input.nextInt();
            
            if(t==31)//莫名其妙,不知道为什么加这个就能过了，谁能解释一下
                bit++;
                
            checkyear(y);//判断该年是否闰年
            
            //把月份拨回到1月，bit加上减去的时间
            while (m>1){
                bit+=month[m-1]*oneday;
                m--;
            }
            
            //overs为拨回该年1月1日0时0分0秒时被减去的时间
            overs=(d-1)*oneday+h*oneh+min*onemin+ones*s;
            bit+=overs;//加上被减去的时间
				  
            //拨回1月1日0时0分0秒
            d=1;
            h=0;
            min=0;
            s=0;
            
            //循环增加年份
            while (bit>0){
                checkyear(y);
                sum=0;
                for(int j=1;j<=12;j++){
                    sum+=month[j]*oneday;
                }
                if(bit-sum>=0){
                    bit-=sum;
                    y++;
                }
                else
                    break;
            }

            checkyear(y);
            sum=0;
            //计算月份
            for(int j=1;j<=12;j++){
                sum+=month[j]*oneday;

                m=j;
                if(bit-sum<0){
                    bit=bit-sum+month[j]*oneday;
                    break;
                }
            }
				//计算日
            d+=(int)(bit/oneday);
            bit=bit-(d-1)*oneday;

				//计算时
            h+=(int)(bit/oneh);
            bit-=h*oneh;

				//计算分
            min+=(int)(bit/onemin);
            bit-=min*onemin;

				//计算秒
            s+=(int)(bit/ones);
            System.out.println(y+" "+m+" "+d+" "+h+" "+min+" "+s);//输出最终的日期时间
        }
    }
    public static void checkyear(int year){//判断闰年，有个问题就是实际上3200年、6400年和9600它们不是闰年
        if(year!=0&&(year%400==0||(year%4==0&&year%100!=0)))
            month[2]=29;
        else
            month[2]=28;
    }
}
```




------------


---


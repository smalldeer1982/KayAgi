# 传教

## 题目背景

写完暑假作业后，bx2k去找pear玩。pear表示他要去汉中传教，于是bx2k准备跟着去围观。


## 题目描述

pear把即将接受传教的人排成一行，每个人从左到右的编号为1-n。每个人有一个信仰值，一开始所有人的信仰值为0。接着pear会做以下两件事之一：

1.pear向连续的一段人群传教。具体来说，pear会使第l个人到第r个人之间的所有人的信仰值增加k。

2.pear想知道某一段人的信仰值之和来得知泉岭精神是否深入人心。具体来说，pear会问bx2k第l个人到第r个人之间所有人的信仰值之和。

身为一个泉岭精神的信徒，bx2k自然会帮pear来算。但是bx2k太笨了，根本不会算。于是他想找你来帮忙。


## 说明/提示

【样例说明】

一开始所有人的信仰值都为0，所以答案为0。到第五个操作时，五个人的信仰值分别为0,7,7,15,6。则答案为7+15=22


【数据范围与约定】

对于1-3测试点，n,m<=10

对于4-5测试点，n,m<=10^3

对于6-8测试点，没有传教操作。

对于所有测试点，n<=10^9,m<=10^3,0<l<=n,0<r<=n,k<=10


## 样例 #1

### 输入

```
5 5
2 1 2
1 4 4 2
1 2 4 7
1 4 5 6
2 3 4```

### 输出

```
0
22```

# 题解

## 作者：zhylj (赞：12)

这题是可以用线段树做的。

虽然$n\leq 10^9$

可以发现，真正需要用到的节点很少，故动态开点，只有需要用到的时候才新建节点。

这里我在下放标记的时候新建节点，因为每操作/查询一个节点都需要先下放标记。

时间复杂度$O(m\log n)$，空间复杂度$O(m\log n)$左右，拥有所有题解里面最优的理论复杂度~~和最大的常数所以甚至跑的更慢~~

```
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

struct node {
    ll data, tag;
    node *lc, *rc;

    node () {
        data = 0, lc = rc = NULL;
    }

    void pushup() {
        data = 0;
        if(lc) data += lc->data;
        if(rc) data += rc->data;
    }

    void pushtag(int l, int r) {
        if(!lc) lc = new node;
        if(!rc) rc = new node;
        int mid = (l + r) >> 1;
        lc->data += (mid - l + 1) * tag, lc->tag += tag;
        rc->data += (r - mid) * tag, rc->tag += tag;
        tag = 0;
    }

} *st = new node;

void modify(node *cur, int l, int r, int ql, int qr, ll k) {
    cur->pushtag(l, r);
    if(ql <= l && r <= qr) {
        cur->data += (r - l + 1) * k;
        cur->tag = k;
    } else {
        int mid = (l + r) >> 1;
        if(ql <= mid) modify(cur->lc, l, mid, ql, qr, k);
        if(qr > mid) modify(cur->rc, mid + 1, r, ql, qr, k);
        cur->pushup();
    }
}

ll query(node *cur, int l, int r, int ql, int qr) {
    cur->pushtag(l, r);
    if(ql <= l && r <= qr) {
        return cur->data;
    }
    int mid = (l + r) >> 1; ll ans = 0;
    if(ql <= mid) ans += query(cur->lc, l, mid, ql, qr);
    if(qr > mid) ans += query(cur->rc, mid + 1, r, ql, qr);
    return ans;
}

int main() {
    int n, m, opt, x, y; ll z;
    cin >> n >> m;
    while(m--) {
        cin >> opt;
        if(opt == 1) {
            cin >> x >> y >> z;
            modify(st, 1, n, x, y, z);
        } else {
            cin >> x >> y;
            cout << query(st, 1, n, x, y) << endl;
        }
    }
    return 0;
}

```

---

## 作者：Sea_Level (赞：11)

### 题解 P2781 【传教】

题意很明了，我就不多说了。这道题的难点在于如何累加。由于数据范围很大，所以我们可以先把l,r,k都存下来等到询问的时候再计算。

首先我们先把简单的（传教时的操作）写出来，代码就不放了。

好了，接下来就是计算询问的结果（询问，重点）

如果一段区间在l~r，那么就将其间的所有元素都加上k。由此我们得到式子：

$ans+=(long long)k[j]*(min(rx,r[j])-max(lx,l[j])+1)$

解释：这里还要判断只有一部分重叠的情况，如果两段区间不是完全重合的那就取重合的部分，尾部肯定要取最小，头部肯定要取最大。如果是完全重合这段代码也适用。这里要强制转换成long long。

完整代码：

```cpp
#include<iostream>
using namespace std;
int n,m,l[1010],r[1010],k[1010],cnt=0,f=0;//l，r，k3个数组是题目中所说的传教的范围和增加的信仰值，cnt是l,r,k3个数组的下标，f是判断是传教还是询问。
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>f;
		long long ans=0;//和，记得开long long
		if(f==1){//如果是传教
			cnt++;
			cin>>l[cnt]>>r[cnt]>>k[cnt];//这里不能直接用i，因为f可能是2，就会出错
		}else{//如果不是传教，是询问
			int lx,rx;//询问区间的头和尾
			cin>>lx>>rx;
			for(int j=1;j<=cnt;j++){
				if(lx<=r[j]&&rx>=l[j]){//如果有重叠
					ans+=(long long)k[j]*(min(rx,r[j])-max(lx,l[j])+1);//累加，记得强制转换成long long，不然只有80分
				}
			}
			cout<<ans<<endl;
		}
	}
	return 0;//拜拜！
}
```


---

## 作者：Jasonggg15 (赞：5)

**本人蒟蒻，不足之处望各位大佬海涵并不吝赐教**

如果每传教一次就做一次数组下标l到r各加k的操作，明显会超时，所以可以先将每次传教的范围及增加的信仰值k先存下，询问时再累加输出

奉上代码：
```cpp
#include<iostream>

using namespace std;
int n,m,p,l[1005],r[1005],k[1005],sum;
int ll,rr;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>p;
        if(p==1)//t=1,传教 
        {
            sum++;
            cin>>l[sum]>>r[sum]>>k[sum];//先存下传教的范围及增加的信仰值k 
        }
        else//t=2,询问 
        {
            long long ans=0;//注意此处long long 
            cin>>ll>>rr;
            for(int j=1;j<=sum;j++) 
        	{
            	if(ll<=r[j]&&rr>=l[j])//判断询问范围是否与之前记录的每一次传教范围有重合部分  
                {
                    ans+=(long long)k[j]*(min(rr,r[j])-max(ll,l[j])+1);
					//如果有，ans+=重合范围长度*对应信仰值k 
                }
        	}
            cout<<ans<<endl;//输出 
        }
    }
    return 0; 
}
```
注意体会 **ans+=(long long) k[j]*(min(rr,r[j])-max(ll,l[j])+1);**

ans+=对应信仰值k*重合范围长度

~~管理员大大给过啊~~

---

## 作者：s_r_f (赞：5)

我们先分析一下这道题。

由于有 10^9 个人，所以一些 nlogn 数据结构就被排除了。

(写线段树的同志们对不起啦，只有50分啊)


但是它的操作和询问次数很小，

所以我们可以不用维护每个人的信仰值，

而是采取对每个操作来进行统计答案。


直接暴力 m^2 就可以过了。


但注意到答案可能超过 int 的范围，所以我们要用long long.


代码如下：





    
            
            
```cpp
#include <bits/stdc++.h>
#define M 1010
#define LL long long
using namespace std;
inline int read(){
    int x = 0,f = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c <='9' && c >='0') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void Put(LL x){
    LL k = 0,lx = x;char put[30];
    if (lx ==0) putchar('0');
    if (lx < 0) putchar('-'),lx = -lx;
    while (lx)  put[++k] = (lx % 10) + '0',lx /= 10;
    while (k)   putchar( put[ k-- ] );
    putchar('\n');
}
inline LL L(int l1,int r1,int l2,int r2){
    int ll = max(l1,l2),rr = min(r1,r2);
    return (ll <= rr) ? (rr - ll + 1) : 0;
}
int n,m;
int doit[M],l[M],r[M],k[M];
int main(){
    n = read(),m = read();
    for (int i = 1; i <= m; ++i){
        doit[i] = read(),l[i] = read(),r[i] = read();
        if (doit[i] == 1) k[i] = read(); // add
        else k[i] = -1; // ask
    }
    for (int i = 1; i <= m; ++i)
        if (k[i] == -1){
            LL ans = 0;
            for (int j = 1; j < i; ++j)
                if (k[j] != -1){
                    ans += L(l[i],r[i],l[j],r[j]) * k[j];
                }
            Put(ans);
        }
    return 0;
}
```

---

## 作者：Adove (赞：2)

这题打眼一看，线段树？

n<=1e9!!!!

算了

m好像很小

m^2算法可做

每次枚举之前的区间，能取相交的部分就取，乘上作加法的权值即可

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=1005;

int n,m,px[MAXN<<1];
struct rpg{
	int l,r,x;
}c[MAXN<<1];

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		int p,l,r,x;
		scanf("%d",&p);
		if(p==1){
			scanf("%d%d%d",&l,&r,&x);
			c[i]={l,r,x};
		}else{
			scanf("%d%d",&l,&r);long long sum=0;
			c[i]={l,r};
			for(int j=1;j<i;++j){
				if(c[j].x&&min(c[j].r,c[i].r)-max(c[j].l,c[i].l)+1>0)
					sum+=(long long)(min(c[j].r,c[i].r)-max(c[j].l,c[i].l)+1)*c[j].x;
			}printf("%lld\n",sum);
		}
	}return 0;
}
```

思考：如果m<=1e6呢？

我们可以离散化+离线线段树+标记区间长度

---

## 作者：winmt (赞：1)

楼下题解貌似“驴头不对马嘴”！这才是正解！

注意到m非常小，我们可以考虑每个传教操作对询问操作的贡献。

即某个询问的答案直接跟前面所有修改操作求个交集就好了。

时间复杂度：O(m^2)

【AC代码】



```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int ql[1111],qr[1111];
ll qk[1111];
ll x(int l,int r,int x,int y)
{
    if(y<r)
    {
        swap(l,x);
        swap(r,y);
    }
    if(x>r)return 0;
    return r-max(l,x)+1;
}
int main()
{
    int i,j,k,m,n,l,r,u,tot=0;
    ll ans;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&l,&r);
        if(u==1)
        {
            scanf("%d",&k);
            tot++;
            ql[tot]=l;
            qr[tot]=r;
            qk[tot]=k;
        }
        else
        {
            ans=0;
            for(j=1;j<=tot;j++)
            {
                ans+=x(ql[j],qr[j],l,r)*qk[j];
            }
            cout<<ans<<endl;
        }
    }
    return 0;
}
```

---

## 作者：edr_saverr (赞：0)

~~RE了一段时间~~

AC了写篇题解庆祝一下通过（~~水题~~）

------------

### 思路问题：
~~首先是直接**循环结构**（蒟蒻表示很淦）...显然黄题不会给你过的。~~

接着是想到**线段树**，不过考虑到 $n$ 的范围。显然不可取。

然后在某julao的指引下，发现 $m$ 的范围不大，完全可以直接记录每一个输入，再一个一个输出。

接着我们不难得到每一次的输出，只需要循环前面的每一次传教过程，把范围内的人的信仰值累加即可。

然后就可以得到每一次传教的关系式:
```cpp
sum+=(long long)(min(r[i],r[j])-max(l[i],l[j])+1)*k[j];
```
每一次都计算一边，因为 $m$ 的范围较小，所以不会超时(时间复杂度O(n2))

~~不放心就开O2（不开能过的）~~
### 代码问题:
主要是每一次累加求 $sum$ 的代码:
```cpp
long long sum=0;
			for(int j=1;j<=i;j++){
				if(_1[j]){
					if((min(r[i],r[j])-max(l[i],l[j])+1)>0)sum+=(long long)(min(r[i],r[j])-max(l[i],l[j])+1)*k[j];
				} 
			}
			printf("%lld\n",sum);
```
### AC代码：
```cpp
#include <bits/stdc++.h>
#define maxn 1001
#define obj '#'
#define debug cout<<obj<<endl
#define end '\n'//别管qwq 
using namespace std;
inline int read(){//读入（板子） 
		int x = 0, f = 1; char ch = getchar();
		for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
		for(; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + int(ch - '0');
		return x * f;
}
void read_l(char a[]){
	int i=-1;while((a[++i]=getchar())!= end );a[i]='\0';
}
bool _1[1001];//记录是否是传教 
int l[1001];//左指针 
int r[1001];//右指针 
int k[1001];//传教值 
int n,m;
int t;
int main(){
	n=read();
	m=read();
	for(int i=1;i<=m;i++){
		t=read();
		if(t==1){
			_1[i]=true;//是传教 
			l[i]=read();
			r[i]=read();
			k[i]=read();
		}
		else{
			_1[i]=false;//不是传教 
			l[i]=read();
			r[i]=read();
		}
	}
	for(int i=1;i<=m;i++){
		if(!_1[i]){//不是传教就需要输出 
			long long sum=0;
			for(int j=1;j<=i;j++){
				if(_1[j]){
					if((min(r[i],r[j])-max(l[i],l[j])+1)>0)sum+=(long long)(min(r[i],r[j])-max(l[i],l[j])+1)*k[j];
					//数据较大使用long long ，注意(long long)的位置 
				} 
			}
			printf("%lld\n",sum);//输出每一次 
		}
	}
	return 0;//AC 
}

```
（请勿抄袭）

---

## 作者：chenlingxi (赞：0)

```cpp
#include<iostream> 
#include<cstdio> 
using namespace std;
struct add
{
	long long  l,r,num;
}t[1005];
int main()
{
	//文操已删
	long long  n,m,s=0;
	cin>>n>>m;
	for(long long  i=0;i<m;++i)
	{
		long long  k;
		cin>>k;
		if(k==1)
		{
			s++;
			cin>>t[s].l>>t[s].r>>t[s].num;//加入要判断的区间
		}
		else
		{
			long long l,r;
			long long ans=0;
			cin>>l>>r;
			for(long long  j=1;j<=s;++j)
            //暴力枚举，可行的话ans就加增加区间和
			{
				long long  ml=max(l,t[j].l),mr=min(r,t[j].r);
				if(ml<=mr)ans+=(mr-ml+1)*t[j].num;//判断区间大小
			}
			cout<<ans<<endl;
		}
	}
}
```
我们注意到m<=1000

所以想到一个叫做暴力的东西

~~尽管考试的时候我开始没看到n的大小想打个线段树模板~~

-----------------

言归正传来讲暴力

把每一段要加的值存在t数组内

每次询问枚举

时间复杂度O（m^2）

---

## 作者：355_113 (赞：0)

水题
**注意点：**

1. 10^9的n，区间操作数据结构免谈（连编译都过不了）

2. 可以记录每次修改（类比线段树懒标记），判断**“询问”涉及的区间**和”询问“之前的**每次“修改”涉及的区间**是否相交，如相交则按mmp函数所示修改答案，时间复杂度并不高。

代码变量名奇特

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>//没有min函数，尴尬。。。
#define LL long long
using namespace std;
const int mm=1003;
int l[mm],r[mm],k[mm];
int min(int mdzz,int faq){
    return mdzz<faq?mdzz:faq;
}
int mmp(int L,int R,int zo,int yo){
    if(R<zo||L>yo)return 0;
    return min(R,yo)-max(L,zo)+1;//易错，建议画图考虑
}
int main(){
    int n,m,tp,ll,j=0,rr;
    LL ans=0;//要用long long！
    cin>>n>>m;
    for(int i=1;i<=m;++i){
        scanf("%d",&tp);
        if(tp==1){
            j++;
            scanf("%d%d%d",&l[j],&r[j],&k[j]);
        }
        else{
            LL tem=0;
            scanf("%d%d",&ll,&rr);
            for(int a=1;a<=j;++a){
                tem=mmp(ll,rr,l[a],r[a])*(LL)k[a];
                ans+=tem;
            }
            printf("%lld\n",ans);//行数据说要严格等于询问次数，但是多余空行其实无所谓
            ans=0; 
        }
    }
//    system("pause");
    return 0;
}
```

---

## 作者：Deny_小田 (赞：0)

小田又来发题解啦~


其实这题折腾的我很蛋疼。这是我&我老师，@xiao233 一起的题解（帮他写一下）。


废话不多说，进入正题：

刚开始我是用的循环+判断是否可以成为最小值的方法， 结果是永恒的80分，第三个点WA。

然后死活过不去。/(ㄒoㄒ)/~~

附上WA无数次的代码（要保持淡定）：





    

```cpp
#include <cstdio>
#define Size 1005
int A[Size][Size],n; 
bool Judge(int x,int y){
    bool flag = true;
    for(int i = 0; i < n&&flag; i++) if(A[x][i] < A[x][y]){ flag = false; break; }
    for(int i = 0; i < n&&flag; i++) if(A[i][y] < A[x][y]){ flag = false; break; }
    return flag; 
}
int main(){
//    freopen("AnPoint.in","r",stdin);
    scanf("%d",&n);
    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) scanf("%d",&A[i][j]);
    for(int i = 0; i < n; i++){
        int x,y,value,k = 0;
        for(int j = 0; j < n; j++) if(Judge(i,j)){ value = A[i][j]; x = i; y = j; k = 1; }
        if(k) printf("%d %d %d\n",x+1,y+1,value);
    }
    return 0;
} 
```
后来，我的老师，@xiao233提供了一条思路，截图如下： ![](https://cdn.luogu.com.cn/upload/pic/2217.png)

然后遵循这个代码写了就AC了。

附代码：



    
```cpp
#include <cstdio>
#define Size 2005
#define inf 100000005
int A[Size][Size],n,x,y;
int main(){
    scanf("%d",&n);
    for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) scanf("%d",&A[i][j]);
    for(int i = 0; i < n; i++){
        int max = inf; x = i;
        for(int j = 0; j < n; j++) if(A[i][j] <= max) max = A[i][j],y = j;
        for(int k = 0; k < n; k++){
            if(A[i][y] > A[k][y]) break; 
            else if(k == n-1) printf("%d %d %d\n",x+1,y+1,max);
        }
    } 
    return 0;
}
```

---

## 作者：DоsLikе (赞：0)

# P2781【传教】
题目描述&样例输入/输出：[这里](https://www.luogu.com.cn/problem/P2781)

~~不明白这题我为什么交了10次才过~~

这题题目描述非常像线段树的模板题，但是 $n \leq 10^9$ 这个数据范围就很难受

看到题解里也有使用优化后的线段树通过了此题的dalao，但是我太菜了，所以打算换一种方法。

（顺便一说，本蒟蒻隐隐约约的感觉到本题似乎和差分有一点微妙的联系，有兴趣的同学可以想一下）

现在开始介绍正解。

观察题目，我们可以看到所有的操作可以分为以下两类：

1. 传教(需要的变量为左端点 $l$ ,右端点 $r$ ,以及操作值 $k$ )

2. 检查传教效果(需要的变量为左端点 $l$ ,右端点 $r$)

这样的话就好办了，

我们首先声明两个结构体数组:

```cpp
struct node{
	int id;//操作的序号
	int l;//左端点
	int r;//右端点
	int k;//操作值
}arr[maxn];
```
（这一个结构体负责存储“传教”这个操作）

```cpp
struct info{
	int id;//操作的序号
	int l;//左端点
	int r;//右端点
}infos[maxn];
```
（这一个结构体负责存储“检查传教效果这个操作”）

接下来我们就可以输入所有的操作了

```cpp
for(int i=1;i<=m;i++){
	int com;
	cin>>com;
	if(com==1){
		n1++;
		cin>>arr[n1].l>>arr[n1].r>>arr[n1].k;
		arr[n1].id=i;//储存当前为第几个操作，后面有用	
	}
	else{
		n2++;
		cin>>infos[n2].l>>infos[n2].r;
		infos[n2].id=i;//储存当前为第几个操作，后面有用
	}	
}
```

之后针对每一个查询的操作，我们都遍历一次“传教”操作的数组

不过！我们可以有一些“剪枝”

由于每一次的查询操作是针对所有在它之前的插入操作的，所以而且操作序号是递增的，

所以我们就可以在遍历插入数组时遇到操作序号大于当前查询操作的序号时就跳出遍历

所以我们就有了

```cpp
if(arr[j].id>infos[i].id)break;
```

我们接着来看，如果“插入”操作的区间和“查询”操作的区间完全相离，就说明他们没有一点关系，就可以跳过当前的“查询操作”

于是，我们就有了

```cpp
if(arr[j].r<infos[i].l||arr[j].l>infos[i].r)continue;
```

接下来我们来欣赏某位抽象大师的画作

![a](https://cdn.luogu.com.cn/upload/image_hosting/hl2s5pmf.png)


（图中的相同颜色的端点表示同一个区间）

发现了一个什么问题？？

无论区间端点的关系如何，我们需要的只是中间的两个端点

于是：

```cpp
int rl,rr;
rl=max(arr[j].l,infos[i].l);
rr=min(arr[j].r,infos[i].r);
```

最后我们计算就好了，（注意一点，k值可能为负，但信仰值一定不能为负~~这就是我为什么WA了那么多次的原因~~）

```cpp
long long tmp=(ll)(rr-rl+1)*arr[j].k;
if(tmp>0ll)ans+=tmp;
```
输出即可。

（你问我代码呢？全都在上面了呀）




---


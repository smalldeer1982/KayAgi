# [JLOI2012] 树

## 题目描述

在这个问题中，给定一个值 $s$ 和一棵树。在树的每个节点有一个权值，第 $i$ 个点的权值为 $a_i$，问有多少条路径的节点权值总和为 $s$。路径中节点的深度必须是升序的。假设节点 $1$ 是根节点，根的深度是 $0$，它的儿子节点的深度为 $1$。路径不必一定从根节点开始。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq a_i, s \leq 10^3$。

## 样例 #1

### 输入

```
3 3
1 2 3
1 2
1 3```

### 输出

```
2```

# 题解

## 作者：enceladus (赞：30)

题解里好像只有从根深搜的，~~从根搜索太复杂蒟蒻我看不懂啊。~~那我来水一篇暴力QAQ。

%下面大佬，用LCA等复杂方法过的

------------

[安利博客](https://www.cnblogs.com/enceladus-return0/)

[题目传送门](https://www.luogu.org/problemnew/show/P3252)


------------


先让我们看这句话

>路径中节点的深度必须是升序的。

那就要保证是向下搜的呗。

用链式前向星存边，记录父亲， _只要保证下个节点不是他的父亲即可_ 

#### 读入时
```cpp
for(int i=1;i<=n-1;i++)
	{
		cin>>x>>y;
		add(x,y);
		fa[y]=x;
	}
```
#### 搜索时
```cpp
if(fa[x]!=nxt)
```

------------

再看这句话

>路径不必一定从根节点开始。


那就把点全枚举一边就行啊，

```cpp
for(int i=1;i<=n;i++)
	{
	    dfs(i,w[i]);	
	}
```

------------
>问有多少条路径的节点总和达到S

当时本人不太明白的，是要到s才行，不能超过s。所以可以加入剪枝

**超过s就不用搜了qwq。
达到s后ans++，不用搜了**

```cpp
if(dis>s)
	    return;
	if(dis==s)
	{
		ans++;
		return;
	}
```


------------
下面献上简陋的代码

不要抄袭，代码有锅QAQ


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define IL inline
#define R register
using namespace std;
struct node{
	int u,v;
}fuck[100007];
int head[100007],fa[100007],x,y,w[100007],n,s,tot=0,ans=0;
IL void read(int &x)
{
	int f=1;x=0;char s=getchar();
	while (s<'0'||s>'9'){if(s=='-') f=-1 s=getchar();}
	while (s>='0'&&s<='9'){ x=x*10+s-'0'; s=getchar();}
	x*=f; 
}
void add(int x,int y)
{
	fuck[++tot].u=head[x];//++?
	fuck[tot].v=y;
	head[x]=tot;
}

IL void dfs(int x,int dis)
{
	if(dis>s)
	    return;
	if(dis==s)
	{
		ans++;
		return;
	}
	for(int i=head[x];i;i=fuck[i].u)
	{
		int nxt=fuck[i].v;
		if(fa[x]!=nxt)
		    dfs(nxt,dis+w[nxt]);
	}
}

int main()
{
    read(n);read(s);
    for(int i=1;i<=n;i++)
    	cin>>w[i];
	for(int i=1;i<=n-1;i++)
	{
		cin>>x>>y;
		add(x,y);
		fa[y]=x;
	}
	for(int i=1;i<=n;i++)
	{
	    dfs(i,w[i]);	
	}
	cout<<ans<<endl;
	return 0;
}

```
${\color{Gold}By}$

${\color{Gold}enceladsu}$

---

## 作者：zht467 (赞：23)

树上前缀和。

在树上找一条权值和为 s 的链，其中这个链上的点按深度递增（递减）（不同）

dfs
每搜到一个点求它的前缀和 sum[x]，放入 set 中。

在 set 中找 sum[x] - s 的点，如果有，ans++

退出 dfs 的时候再把 sum[x] 从 set 中删除

因为每个点权都是正整数，所以 set 中没有重复元素。

同时也是单调递增，所以简单些不用 set，开个数组再 lower\_bound 也行。

——代码






```cpp
#include <set>
#include <cstdio>
#include <cstring>
#include <iostream>
const int MAXN = 100001;
int n, s, cnt, ans;
int a[MAXN], head[MAXN], to[MAXN << 1], next[MAXN << 1], f[MAXN], sum[MAXN];
std::set <int> S;
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    for(; !isdigit(ch); ch = getchar()) if(ch == '-') f = -1;
    for(; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + ch - '0';
    return x * f;
}
inline void add(int x, int y)
{
    to[cnt] = y;
    next[cnt] = head[x];
    head[x] = cnt++;
}
inline void dfs(int u)
{
    sum[u] = sum[f[u]] + a[u];
    S.insert(sum[u]);
    if(S.count(sum[u] - s)) ans++;
    for(int i = head[u]; i ^ -1; i = next[i]) dfs(to[i]);    
    S.erase(sum[u]);
}
int main()
{
    int i, x, y;
    n = read();
    s = read();
    memset(head, -1, sizeof(head));
    for(i = 1; i <= n; i++) a[i] = read();
    for(i = 1; i < n; i++)
    {
        x = read();
        y = read();
        f[y] = x;
        add(x, y);
    }
    S.insert(0);
    dfs(1);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Johnson_sky (赞：20)

没错，我就是拉楼下同学做题的同学0.0（雾）。


我的思路与大家的相似，但又不同。


考虑一种最基本的暴力算法，从每个点开始做DFS，找到一条价值为s的路径就返回。这样你可以得到90分，因为第二个点貌似是一条链。


如何优化这个搜索呢？


我们发现当搜到一条价值小于s的路径时，它的子树不会存在价值为s的路径，直接剪枝即可。


蒟蒻代码，大佬们勿喷。。。






```cpp
#include <bits/stdc++.h>
#define N 100010
using namespace std;
int n, s, tot, en, x, y;
int a[N], head[N];
struct Edge{
    int to, next;
}e[N << 1];
//读入优化
inline int get_num()
{
    int now = 0;
    bool fh = false;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-') fh = true;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        now = (now << 1) + (now << 3) + ch - '0';
        ch = getchar();
    }
    return (fh == true ? - now : now);
}
bool ans = false;
//ans记录是否搜到小于s的路径，false为搜到小于s的路径
inline void dfs(int now, int tmp)
{
    if(tmp == s){
        ans = true;
        ++tot;
        return;
    }else if(tmp > s){
        ans = true;
        return;//注意这个剪枝！！！！！
    }else for(int i = head[now]; i; i = e[i].next){
        dfs(e[i].to, tmp + a[e[i].to]);
    }
}
inline void mdfs(int now)
{
    for(int i = head[now]; i; i = e[i].next){//使用两个dfs嵌套，便于理解
        ans = false;
        dfs(e[i].to, a[e[i].to]);
        if(ans == false) continue;
        mdfs(e[i].to);
    }
}
int main()
{
    n = get_num(), s = get_num();
    for(register int i = 1; i <= n; ++i){
        a[i] = get_num();
    }
    for(register int i = 1; i < n; ++i){
        x = get_num(), y = get_num();//注意这里是单向边
        e[++en].to = y;
        e[en].next = head[x];
        head[x] = en;
    }
    dfs(1, a[1]);
    ans = false;
    mdfs(1);
    printf("%d\n", tot);
    return 0;
}
```

---

## 作者：Sky_crystal (赞：20)

最开始被同学拉着做这道题时我是懵逼的。。还以为会是个状压dp。。


仔细一看题目性质，发现可以采用类似于倍增求LCA的做法，复杂度为O(N\*log(n))。


相信写过倍增求LCA的人都能看懂这个代码。


主要是利用了点权为正整数和所求路径深度必须单调这两个性质。


```cpp
#include<bits/stdc++.h>
using namespace std;
int len[100003][18];//len[i][j]表示以i为起点向上长度为2^j的路径长度
int fa[100003][18];//i的父亲 类似于倍增求LCA
int n,m,s,x,y,ans;
int main()
{
  scanf("%d %d",&n,&s);
  for (int i=1;i<=n;i++)
  {
    scanf("%d",&len[i][0]);
  }
  for (int i=1;i<n;i++)
  {
    scanf("%d %d",&x,&y);
    fa[y][0]=x;
  }
  for (int i=1;i<=17;i++)
  {
    for (int j=1;j<=n;j++)
    {
      fa[j][i]=fa[fa[j][i-1]][i-1];
      len[j][i]=len[j][i-1]+len[fa[j][i-1]][i-1];
    }
  }
  for (int i=1;i<=n;i++)
  {
    x=0;//当前已有路径的长度
    y=i;//当前跳到了哪个点
    for (int j=17;j>=0;j--)
    {
      if (len[y][j]+x<=s)
      {
        x+=len[y][j];//这里就和查LCA时跳到相同深度的步骤差不多，如果不超过s就尽可能往上跳
        y=fa[y][j];
      }
      if (x==s)
      {
        ans++;
        break;
      }
    }
  }
  printf("%d\n",ans);
  return 0;
}
```

---

## 作者：PrefixAMS (赞：8)

### ~~考场上莫名只拿了10分的题（被虐的1P）~~

### ~~又看了题解里的大佬的思路（e.g. LCA  树上前缀和 ） 忽然发现了自己的卑微~~

#### 说一下思路吧

用一个结构体把每个点的点权和他的父亲存起来（不用存儿子，没什么用）

之后遍历每一个点，将这个点向上搜如果搜到了根节点但点权之和还是没有到达s或者点权之和大于了s 返回 false 

```cpp
//sum为点权之和 
	if(sum>s||!e[u].fa) return false;
```


如果点权之和==s 返回 true 之后ans++

```cpp
bool dfs(int u)

if(sum==s) return true;

if(dfs(i)) ans++;
```

如果都不满足的话就向上继续搜

```cpp

		dfs(e[u].fa);
        
```

或者

```cpp
		u=e[u].fa;
```


于是乎 我们dfs 的边界就出来了 代码还是比较短的



```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,ans,sum;
struct io
{
	int fa,num;
}e[100001];
bool dfs(int u)
{
//	sum=0;

		sum+=e[u].num;
		if(sum==s) return true;
		if(sum>s||!e[u].fa) return false;
		dfs(e[u].fa);
}
int main()
{
//	freopen("tree.in","r",stdin);
//	freopen("tree.out","w",stdout);
	cin>>n>>s;
	
	for(int i=1;i<=n;i++)
	{
		cin>>e[i].num;
	}
	for(int i=1;i<=n-1;i++)
	{
		int fa,son;
		cin>>fa>>son;
		e[son].fa=fa;
	}for(int i=1;i<=n;i++)
	{
		sum=0;
		if(dfs(i)) ans++;
	}
	
	cout<<ans;
	fclose(stdin);
	fclose(stdout);
	return 0;
} 
```


---

## 作者：MuYC (赞：7)

```cpp
/*
这道题的数据不是很大，我们可以直接暴力枚举+递归，可以获得正确答案且不会超时。
思路：使用父亲表示法，暴力枚举每个节点，因为每个节点都只有一个父节点，所以以每个节点为起点的路径是唯一的，保证了答案的正确，数据在10000之内，o（nlogn）是可以暴力过的
*/
#include <bits/stdc++.h>
struct tree{
	int data,fa;
}a[100001];
using namespace std;
int n,RT,ans=0,s,len;
int work(int x){
	int i,k;
	for(i=1;i<=n;i++){//暴力枚举每个节点
		x=0;//初始结果
		len=0;//记录当前路径长度
		k=i;//以k承载i，免得影响循环元素
		while(k!=RT){//如果没有到树根（到树根还没找到那么就是没有）
			len++;//路径的长度++
			x+=a[k].data;//结果+上当前节点的值
			k=a[k].fa;//递归到当前简单的父节点
			if(x==s){ans++;break;}/*当x==s时，就说明这条路径可行，退出循环枚举下一个节点*/
			if(x>s)//当当前节点已经大于s时，再搜也没有意义了，退出，防止超时
			break;
		}
		x+=a[k].data;//因为我只枚举到了树根的一个子节点，所以要加上树根的值
		if(x==s)ans++;//如果此时s==x，ans也++
	}
}
int main(){
	int i,j,k,m,fa,son;
//	freopen("b.in","r",stdin);
//	freopen("b.out","w",stdout);
	scanf("%d%d",&n,&s);
	for(i=1;i<=n;i++)
	scanf("%d",&a[i].data);
	for(i=1;i<=n-1;i++){//读入
		scanf("%d%d",&fa,&son);
		a[son].fa=fa;//初始化树的父节点
	}
	for(i=1;i<=n;i++){
		if(a[i].fa==0){
		RT=i;//找树根
		break;}
	}
	work(0);//开始枚举
	printf("%d",ans);//输出结果
	return 0;
}
```

---

## 作者：kkxhh (赞：6)

看到题目觉得应该用双端队列做，~~然而看到题解里全是前缀和+暴力还一度以为自己审错了题~~

大致思路就是先扫一边找出根，从根开始dfs，每dfs到一个点就先把它加到队列尾部，然后再前移队列头部直到队列里元素的和小于等于 **s** ，前移完如果元素和正好等于 **s** 就 **ans++** 。最后每个点dfs结束的时候再把队列恢复就好了。

代码如下

```cpp
#include <vector>
#include <cstdio>
#include <algorithm>
using namespace std;

vector<int> son[100010];
int n,s,v[100010],fa[100010]={0},a,b,root,qsum=0,ans=0,q[100010]={0},l=0,r=-1;

void dfs(int x){
    q[++r]=v[x]; qsum+=v[x];
    while(qsum>s) qsum-=q[l++];
    if(qsum==s) ans++;
    for(int j=0;j<(int)son[x].size();j++) dfs(son[x][j]);
    qsum-=q[r--];
    while(l && qsum+q[l-1]<=s) qsum+=q[--l];
}

int main() {
    scanf("%d %d",&n,&s);
    for(int i=1;i<=n;i++) scanf("%d",&v[i]);
    for(int i=1;i<=n-1;i++){
        scanf("%d %d",&a,&b);
        son[a].push_back(b);
        fa[b]=a;
    }
    for(int i=1;i<=n;i++) if(!fa[i]) {root=i; break;}
    dfs(root);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：wyl_AC (赞：4)

我最近跟着学校集训，刷紫题，黑题都快刷到吐了，突然看到老师布置的这道题竟然是个黄题，还以为自己找错了。

数据是真的水，各种真O（n^2）或伪O(n * log(n) )层出不穷，于是我就写了个倍增O（n*log(n)）。

算法没什么难点，主要就是看题意，由于路径上节点深度递增，所以不可能有拐点，所以往上爬就行了，然后就是倍增优化。

把这道题当倍增入门来讲：

dp[i][k]: 表示从i点向上爬2^k步是哪个点。

up[i][k]: 表示包括i点在内，向上2^k个点的和是多少。
注意：这里是点，上面是步，所以dp爬到的点是没有计算的。

看这道题是要凑S，所以每个点只有一条以他为起点的路径，所以凑到S就行了。

代码大意:如果向上加2^k个点的值大于了S，就尝试加2^k-1个点，否则尝试加2^k+2^k-1个点。

code:
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
using namespace std;
#define LL long long
#define M 100005
const  LL Inf=0x3f3f3f3f;
const int K = 21;
vector<LL>G[M];
LL read() {
	LL x=0;
	LL f=1;
	char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-')
			f=-f;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	x*=f;
	return x;
}
void write(LL x) {
	if(x / 10) write(x / 10);
	putchar(x % 10 + '0');
}
LL up[M][K],dp[M][K];
void dfs(LL u,LL fa){
	dp[u][0]=fa;
	for(int i=1;i<K;i++){
		dp[u][i]=dp[dp[u][i-1]][i-1];
		up[u][i]=up[u][i-1]+up[dp[u][i-1]][i-1];
	}
	for(int i=G[u].size()-1;~i;--i){
		LL v = G[u][i];
		if(v==fa)
			continue;
		dfs(v,u);
	}
	return ;
}
LL n=read(),s=read(),ans;
int main(){
	for(int i=1;i<=n;i++)
		up[i][0]=read();
	for(int i=1;i<n;i++){
		LL u=read(),v=read();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++){
		LL u=i;
		LL t=0;
		for(int j=K-1;(~j)&&u;--j){
			if(up[u][j]+t>s)
				continue;
			t+=up[u][j];
			u=dp[u][j];
		}
		if(t==s)
			ans++;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：密期望 (赞：2)

杂技一般的树链剖分。主要是看见讨论里有人再用树链剖分在做，那肯定有其他的人在用这道题练习，所以写了这篇树链剖分的题解。详细在代码中解释
```
#include<cstdio>
#include<algorithm>
using std::lower_bound;
const int N=100010;
class L{
	public:
		int to;
		int next;
};
//存图 
L l[N];
int head[N];
int lcount;
void add(int from,int to){
	l[++lcount].to=to;
	l[lcount].next=head[from];
	head[from]=lcount;
}
int f[N];
int son[N];
int top[N];
int dep[N];
int sum[N];
/*
使用前缀和维护树链
注意，这里的前缀和下标是指经过dfs_2处理后每个点的标号
而不是原本的点的标号 
*/
int num[N]; 
int size[N];
int maxnum;
int a[N];
int n,s;
void dfs_1(int now=1,int dep_=0,int f_=0
/*将1号点的父亲定为0，在向上跳的时候就可以判断有没有跳出整棵树*/){
	dep[now]=dep_;
	size[now]++;
	f[now]=f_;
	for(int i=head[now];i;i=l[i].next){
		dfs_1(l[i].to,dep[now]+1,now);
		size[now]+=size[l[i].to];
		if(size[son[now]]<size[l[i].to]){
			son[now]=l[i].to;
		}
	}
}
void dfs_2(int now=1,int top_=1){
	top[now]=top_;
	num[now]=++maxnum;
	sum[num[now]]=sum[num[now]-1]+a[now];//统计前缀和 
	if(son[now]){
		dfs_2(son[now],top[now]);
		for(int i=head[now];i;i=l[i].next){
			if(l[i].to!=son[now]){
				dfs_2(l[i].to,l[i].to);
			}
		}
	}
}
bool is_ok(int x/*表示当前点*/){ 
	int need=s;
/* 
need表示当前点需要与另一个点的距离为need，才可以贡献答案 
*/ 
	while(x){
		if(sum[num[x]]-sum[num[top[x]]-1]<=need){
			need-=sum[num[x]]-sum[num[top[x]]-1];//跳过一段距离后更新need 
			x=f[top[x]];
		}else{
/*
如果x与top之间的距离大于need，我们就可以之接在这段之间找答案了 
*/ 
			return *lower_bound(sum+num[top[x]],sum+num[x]+1,sum[num[x]]-need)==sum[num[x]]-need;
/*
利用lower_bound查找，若查找值与需求相同就说明存在答案 
*/ 
		}
	}
	return !need;//如果跳出了这棵树，那么当且仅当need为0是可以贡献答案 
}
int main(){
	scanf("%d%d",&n,&s);
	int p1,p2;
	for(int i=1;i<=n;i++){
		scanf("%d",a+i);
	}
	for(int i=1;i<n;i++){
		scanf("%d%d",&p1,&p2);
		add(p1,p2);
	}
	dfs_1();
	dfs_2();
	int ans=0;
	for(int i=1;i<=n;i++)
		ans+=is_ok(i);//暴力枚举每个点是否可以贡献答案即可 
	printf("%d",ans);
	return 0;
}
```

---

## 作者：skylee (赞：2)

DFS，（也许是递归实现的DP？）。根据树的结构遍历各个节点，f数组保存从根节点到当前节点权值的前缀和。每搜索到一个结点就向前枚举各级父节点，如果当前结点的前缀和与某个父节点前缀和之差为0就累加ans。

```cpp
#define maxn 100000
#include<cstdio>
#include<vector>
using namespace std;
int n,s,a[maxn],f[maxn],ans=0,front[maxn];
vector<int> map[maxn];
void dfs(int node) {
    f[node]=f[front[node]]+a[node];//递推记录前缀和，从父节点集成下来
    int p=node;
    while(p!=-1) {//对于每个节点向前枚举之前的父节点，若前缀和之差为s就累加ans
        if((f[node]-f[p])==s) ans++;
        if((f[node]-f[p])>=s) break;
        p=front[p];
    }
    if(f[node]==s) ans++;
    while(!map[node].empty()) {//枚举所有的子节点，vector的优势体现出来了
        dfs(map[node].back());
        map[node].pop_back();
    }
    return;
}
int main() {
    scanf("%d%d",&n,&s);
    for(int i=0;i<n;i++) scanf("%d",a+i);
    front[0]=-1;
    for(int i=1;i<n;i++) {
        int x,y;
        scanf("%d%d",&x,&y);
        map[x-1].push_back(y-1);//记录树的结构
        front[y-1]=x-1;//记录每个结点的父节点
    }
    dfs(0);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：rainygame (赞：1)

暴力出奇迹！

首先路径深度必须是升序的，也就是说路径会呈一条链状。

那我们就可以考虑暴力搜索路径，考虑从每个点求出发的路径。但是这样可能会被卡，因为每次都会搜索很多个结点，一分叉就又要搜索多可能一倍的节点数。

正难则反。我们知道树从上到下的路径不唯一，但是从下到上的路径唯一呀！所以我们考虑对每个节点求出以它结束的路径数。显然最多只有一条（就是那唯一一条）。而且这样可以保证每次最多搜索了 $s$ 个结点。

时间复杂度 $O(ns)$，但是本题远远无法达到这个上限。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100001

int n, s, u, v, ans, now, res;
int a[MAXN], fa[MAXN];
vector<int> e[MAXN];

void dfs(int x, int f){
	fa[x] = f;
	for (auto i: e[x]){
		if (i != f) dfs(i, x);
	}
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> s;
    for (int i(1); i<=n; ++i) cin >> a[i]; 
	for (int i(1); i<n; ++i){
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1, 0);
	
	for (int i(1); i<=n; ++i){
		now = i;
		res = a[i];
		while (fa[now] && res+a[fa[now]] <= s){
			now = fa[now];
			res += a[now];
		}
		if (res == s) ++ans;
	}
	
	cout << ans;

    return 0;
}

```


---

## 作者：yeaDonaby (赞：1)

## 考察点：树上倍增

注：后文$L$为题目$S$.

我们设立一个$fa$数组，其$fa[i][j]$表示对于i节点，向上的$2^j$个节点的编号,$fa[i][0]
$就是$i$的父亲。

然后我们再设一个储存点权和的倍增数组，设立w数组，其中$w[i][j]$表示对于i节点，向上$2^j$个节点的权值和(不包括$2^j$这个节点但是包括$i$本身)~~显而易见~~， 就表示$i$节点本身的点权。

然后我们得到：

$fa[i][j]=fa[fa[i][j-1]][j-1]$
$w[i][j]=w[fa[i][j-1]][j-1]+w[i][j-1]$


这两个数组在$O(n)$的时间就可以求出来了。

接下来开始计算过程，我们对于每一个节点$i$，设立临时节点$p$。$p$初始化为$i$；

我们设$k$为$20$，从$20->1$，对于$w[p][k]$,若其小于$L$，则$L-=w[p][k],p=fa[p][k]$

如此倍增向上跳，若是跳完的时候权值和正好等于$L$，那么就对$ans$贡献$1$，即$ans++$

计算完每个点贡献以后即为答案。

实现就是$LCA$预处理部分，dfs一遍就行了。

```
#include<stdio.h>
#define R register
#define maxn 100001
#define maxm 200001
int n,L,ans,x,y,tot;
int f[maxn][31],w[maxn][31],a[maxn],Last[maxn],Next[maxm],End[maxm];//双向边空间双倍！！！
inline void dfs(int x,int fa)
{
	f[x][0]=fa;
	w[x][0]=a[x];
	for(R int i=1; i<=20; i++)
	{
		f[x][i]=f[f[x][i-1]][i-1];
		w[x][i]=w[x][i-1]+w[f[x][i-1]][i-1];
	}
	int p=x,Len=L;
	for(R int i=20; i>=0; i--)
	{
		if(f[p][i]&&w[p][i]<Len)
		{
			Len-=w[p][i];
			p=f[p][i];
		}
	}
	if(w[p][0]==Len)
	{
		ans++;
	}//跳完的时候权值和正好等于L，那么就对ans贡献1
	for(R int i=Last[x]; i; i=Next[i])
	{
		if(End[i]!=fa)
		{
			dfs(End[i],x);
		}//避免反复讨论
	}
	return ;
}
int main(void)
{
	scanf("%d%d",&n,&L);
	for(R int i=1; i<=n; i++)
	{
		scanf("%d",&a[i]);
	}
	for(R int i=1; i<n; i++)
	{
		scanf("%d%d",&x,&y);
		End[++tot]=y;
		Next[tot]=Last[x];
		Last[x]=tot;
		End[++tot]=x;
		Next[tot]=Last[y];
		Last[y]=tot;//双向边！！！
	}
	dfs(1,0);//遍历这棵树，时间复杂度O(n)
	printf("%d",ans);//并不用开long long
	return 0;
}
```

---

## 作者：Y_inG (赞：1)

~~这道题还是比较水的，就连我这样的蒟蒻都过了。~~

其实就是一个搜索。~~不知道标签上的状压是哪来的，可能是蒟蒻太弱打不出来~~

我们用链式前向星存图

```cpp
struct edge{
	int from,to,val,next;
	void read()
	{
		scanf("%d",&val);
	}
}r[N<<1];
```

按照题目要求，我们可以从每个点出发找路径，那么我们就枚举每个点往下搜索

dfs函数中：s是目标值，u为当前父亲节点的编号，sum为累加的权值。
```cpp
void dfs(int u,int s)
{
	for(int i=head[u];i;i=r[i].next)
	{
		sum+=r[r[i].to].val;
		if(sum>s){sum-=r[r[i].to].val;continue;}
		else if(sum==s){++ans;sum-=r[r[i].to].val;continue;}//这里不能直接返回，必须继续循环，不然会漏搜兄弟节点。
		dfs(r[i].to,s);
		sum-=r[r[i].to].val;
	}
}
```
本来想着这个搜索极其简单，但我居然炸了，然后疯狂找错误还考虑一波是不是有负权值什么的，~~结果是我数组下标打错了。~~

完整代码如下~~（我觉得我的代码还是很好看懂的，就懒得加注释了）~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int N = 100000 + 5;
struct edge{
	int from,to,val,next;
	void read()
	{
		scanf("%d",&val);
	}
}r[N<<1];//r 存图
int t;
ll ans,sum;
int head[N];
void add(int a,int b)
{
	t++;
	r[t].from=a;r[t].to=b;
	r[t].next=head[a];head[a]=t;
}
void dfs(int u,int s)
{
	for(int i=head[u];i;i=r[i].next)
	{
		sum+=r[r[i].to].val;//加上当节点的权值和
		if(sum>s){sum-=r[r[i].to].val;continue;}
		else if(sum==s){++ans;sum-=r[r[i].to].val;continue;}//如果sum大于或等于目标值，就不需要往下搜了。
		dfs(r[i].to,s);//继续搜其子节点
		sum-=r[r[i].to].val;
    }
}
int main()
{
	int n,s;
	scanf("%d%d",&n,&s);
	for(int i=1;i<=n;i++)r[i].read();
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i=1;i<=n;i++)
	{
		if(r[i].val>s)continue;
		if(r[i].val==s)ans++;
		else sum=r[i].val,dfs(i,s);
	}
	printf("%lld\n",ans);
	return 0;
}
```
~~希管理大大让我过审核orz~~

---

## 作者：salix_leaf (赞：1)

听说这是一道状压dp，但是题解没有状压写法，于是我这个小蒟蒻就来提供一下我自己的**二分**写法（这种写法的最大时间复杂度（一条链时）应该是$n^2 log n$，大佬可以自行跳过）

**稍微解释一下：**
代码中的dp[i]表示的是到深度为i的点的前缀权值是多少，由于是dp[i]=dp[i-1]+r[x]（r[x]为x点的权值）所以我把根节点深度钦定为1而不是0。

然后在出现dp[i]==s的时候ans++，dp[i]>s的时候二分一下前面是否哪个深度j满足dp[i]-dp[j]==s，有的话ans++就可以了（二分性的话，~~显然~~dp[]是递增的啊）

那么为什么dp[]在回溯的时候不用dp[i]-=r[x]呢？因为在搜同一深度的某个点时会直接dp[i]=dp[i-1]+r[y]覆盖掉

那么为什么这个数组叫dp而不是ap呢？~~因为这是一道状压dp题啊~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int N=100005;
int n,s,ans;
int r[N];
int sum,h[N];
struct Edge
{
	int v,nxt;
} e[N];
void adde(int x,int y)
{
	sum++;
	e[sum].v=y;
	e[sum].nxt=h[x];
	h[x]=sum;
}
int dp[N];
void solve(int x)
{
	int l=1,r=x-1,mid=(l+r)>>1,now;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(dp[x]-dp[mid]>=s)
		{
			now=dp[x]-dp[mid];
			if(now==s) ans++;
			l=mid+1;
		}
		else r=mid-1;
	}
	//if(now==s) ans++;
	/*for(int i=1;i<=x-1;i++)
		if(dp[x]-dp[i]==s) ans++;*/
}
void dfs(int x,int d)
{
	dp[d]=dp[d-1]+r[x];
	if(dp[d]==s) ans++;
	else if(dp[d]>s) solve(d);
	for(int i=h[x];i;i=e[i].nxt)
		dfs(e[i].v,d+1);
}
int main()
{
	scanf("%d%d",&n,&s); 
	for(int i=1;i<=n;i++) scanf("%d",r+i); 
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		adde(x,y);
	}
	dfs(1,1);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：xun薰 (赞：1)

###搜索可过

###dfs(i)表示以i为起点的路径有多少条的点权和是s，搜n遍...

###数据太水了...

###代码






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define LL long long
#define maxn 100008
using namespace std;
int n,s,sumedge;
int head[maxn],w[maxn];
long long ans;
struct Edge{
    int x,y,nxt;
    Edge(int x=0,int y=0,int nxt=0):
        x(x),y(y),nxt(nxt){}
}edge[maxn];
void add(int x,int y){
    edge[++sumedge]=Edge(x,y,head[x]);
    head[x]=sumedge;
}
LL dfs(int x,int sum){
    if(sum>s)return 0;
    if(sum==s)return 1;
    long long js=0;
    for(int i=head[x];i;i=edge[i].nxt){
        int v=edge[i].y;
        js+=dfs(v,sum+w[v]);
    }
    return js;
}
int main(){
    scanf("%d%d",&n,&s);
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    for(int i=1;i<n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for(int i=1;i<=n;i++)if(w[i]==s)ans++;else ans+=dfs(i,w[i]);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：ysj1173886760 (赞：1)

这道题数据已经是非常的水了，直接dfs暴力枚举就过了。

但是看数据n是10w，如果强度大的话n方是过不了的。

楼上已经说过了倍增法了，其实倍增就是树上的二分，只不过换了种做法罢了。

这里我们用线性表中的二分思想做这道题，楼上也说过了，用lower_bound
有关于lower_bound可以看我的另一个题解，里面有详细的解释，就是用二分法查找数组中一定值的元素的个数。

那么这道题我们怎么将树链转换为线性表呢？就是用栈啦，我们手动模拟一个栈，栈中记录的就是前缀和，每到达一个新的节点我们就将其加入栈中，注意题中说过元素都是正整数，那么数组有序且为升序，满足二分性质。我们二分值为（当前前缀和减去s）的个数。其实最多是一个。如果有的话ans++，没有就开始dfs子节点，然后结束dfs的时候top--，退栈。复杂度nlogn
细节在代码中解释：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int tot,n,s,ans;
int value[100050],g[100050],stack[100050],top,ind[100050];		//value是结点值，g是邻接表表头，stack为栈，ind是入度 
struct line
{
	int to,next;
}edge[100050];
void add1(int a,int b)
{
	edge[++tot].to=b;
	edge[tot].next=g[a];
	g[a]=tot;
}
void dfs(int u)
{
	stack[++top]=stack[top-1]+value[u];				//将当前节点加入栈中。并更新前缀和 
	int k=upper_bound(stack,stack+1+top,stack[top]-s)-lower_bound(stack,stack+1+top,stack[top]-s);	//找数组中值为stack[top]-s的个数，stack[top]即为当前前缀和，这里注意第一个参数stack是没有加1的，因为注意前缀和的性质，sum[i,j]=pre[j]-pre[i-1]的，所以我们找到的结点实际上是满足条件的点的前一个，如果根节点也满足条件，那么根节点的前一个就是0，所以我们从stack[0]开始找起，而非1. 
	if(k)ans++;		//如果有，ans++		
	int temp=g[u];
	while(temp)		//找子节点 
	{
		dfs(edge[temp].to);
		temp=edge[temp].next;
	}
	top--;			//退栈 
}
int main()
{
	cin>>n>>s;							//初始化 
	for(int i=1;i<=n;i++)cin>>value[i];
	for(int i=1;i<=n-1;i++)
	{
		int x=0,y=0;
		cin>>x>>y;
		add1(x,y);
		ind[y]++;
	}
	int source=0;			//因为我们不知道哪个是根节点，找到入度为0的点设为根节点。
	for(int i=1;i<=n;i++)
		if(ind[i]==0)
		{
			source=i;
			break;
		}
	dfs(source);			//对根节点进行dfs，一遍即可。 
	cout<<ans;
	return 0;
}

```


---

## 作者：quotient_0 (赞：0)

# 【dfs】【哈希表】P3252 [JLOI2012]树

因为所有点权都是正的，所以对每个结点u来说，每条从根到它的路径上只有最多一个结点v符合d(u,v)=S。

所以我们可以边dfs边把每个结点的前缀和pre[u]存到一个数据结构里面，同时查询pre[u]-S是否存在。

数据结构用set、hashtable(随便卡)(需要支持删除，由于总是删掉最后一个，因此可以实现)都行。

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define MAXN 100001
#define MOD 100003
struct HashTable
{
    int v[MAXN],next[MAXN],first[MOD],en;
    HashTable(){memset(first,-1,sizeof(first));en=0;}
    void Insert(const int &x)
    {int o=x%MOD; v[en]=x; next[en]=first[o]; first[o]=en++;}
    void Delete(const int &x) {first[x%MOD]=next[--en];}
    bool Find(const int &x)
    {int o=x%MOD; for(int i=first[o];i!=-1;i=next[i]) if(v[i]==x) return 1; return 0;}
}T;
int n,K,w[MAXN],ans;
int v[MAXN],first[MAXN],next[MAXN],en;
void AddEdge(const int &U,const int &V){v[++en]=V; next[en]=first[U]; first[U]=en;}
void dfs(int U,int W)
{
    if(K<=W) ans+=T.Find(W-K);
    T.Insert(W);
    for(int i=first[U];i;i=next[i])
      dfs(v[i],W+w[v[i]]);
    T.Delete(W);
}
int main()
{
    int a,b;
    scanf("%d%d",&n,&K);
    for(int i=1;i<=n;++i) scanf("%d",&w[i]);
    for(int i=1;i<n;++i) {scanf("%d%d",&a,&b); AddEdge(a,b);}
    T.Insert(0); dfs(1,w[1]); printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Orzalpha (赞：0)

# 嗯，bitset是个好东西。

其实一开始我觉得并不能存的下，后来一看数据范围（~~极水~~），于是就写了个bitset。

我们给每一个点定义一个bitset<1001> bs[N]，用bs[i]的第j位表示以点i为终点的链能不能取到j，,再定义h[i]表示i点的点权。

然后从根节点开始搜索，每到一个点i，就把点i父亲的bs左移h[i]位赋给bs[i]，再把第bs[i][h[i]]位置为1。如果bs[i][s]是1，那么ans++。统计完之后，把ans输出来就可以了。

```cpp
#include<iostream>
#include<cstdio>
#include<bitset>
#define N 100001
using namespace std;
int n,m,h[N],q[N*2],hd,tl,ans;
int nex[N*2],fir[N],poi[N*2],sum;
bool v[N];
bitset<1001> bs[N];
inline void re(int &num)
{
	char c;num=0;
	while((c=getchar())<'0'||c>'9'); num=c-'0';
	while((c=getchar())>='0'&&c<='9') num=num*10+c-'0';
}
inline void ins(int a,int b)
{sum++;nex[sum]=fir[a];fir[a]=sum;poi[sum]=b;}
void bfs(int x)
{
	q[++tl]=x;bs[x][h[x]]=1;
	while(hd<tl)
	{
		int now=q[++hd];
		if(bs[now][m]) ans++;
		for(int i=fir[now];i;i=nex[i])
		{
			int p=poi[i];
			q[++tl]=p;
			bs[p]=bs[now];
			bs[p][0]=1;
			bs[p]<<=h[p];
		}
	}
}
int main()
{
	int a,b;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	re(h[i]);
	for(int i=1;i<n;i++)
	{
		re(a);re(b);
		ins(a,b);
		v[b]=1;
	}
	for(int i=1;i<=n;i++)
	if(!v[i]) {bfs(i);break;}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Jelly_Goat (赞：0)

两种做法。  
首先据老师说，dp的大部分水题和树上的dp都需要先上一个~~简单的~~dfs。  
但是我们需要打一个优雅的深搜。  

-------

### 于是——做法1：
~~比较暴力~~的dfs（竟然AC了，不可思议）  
我们要知道，每一个点都可能是起点，并且是向下深搜，  
原因：题面说是要深度递增。  
那么我们就可以写一个dfs，两个参数，节点p以及从搜的开始节点到当前节点的权值和sum。  
那么现在就有三种状态：  ~~状态？dp预警~~
1. sum is S，so ans++。
2. sum > S，so return（既然都比S大了那么再向下dfs也没用了，因为权值都是正整数）
3. sum < S，so 遍历每一个p的儿子再跑dfs 

于是这个题就这么做完了？ ~~好像有点快~~  
**Code:**
```cpp
#include <iostream>
#include <cstdio>

using namespace std;
typedef long long int lli;
struct edge{
    int to,next;
}Edge[100001];

int head[100001],fa[100001],cnt=1;
inline void add_edge(int from,int son)
{
    Edge[cnt].to=son;
    Edge[cnt].next=head[from];
    head[from]=cnt++;
}

lli ans=0;
int value[100001],n,s;
int dp[100001];
void dfs(int, int);

int main()
{
    scanf("%d%d",&n,&s);
    for (register int i=1;i<=n;i++)
        scanf("%d",&value[i]);
    for (register int i=1;i<=n-1;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add_edge(x,y);
        fa[y]=x;
    }
    for (register int i=1;i<=n;i++)
        dfs(i,value[i]);
    printf("%lld\n",ans);
    return 0;
}

void dfs(int p,int sum)
{
    if (sum>s)return;
    else if (sum==s)
    {
        ans++;
        return;
    }
    else
        for (int i=head[p];i;i=Edge[i].next)
            dfs(Edge[i].to,sum+value[Edge[i].to]);
}
```
因为我们需要遍历一个点多次，那么肯定是可以记忆化优化。  
那么如果数据毒瘤一点，我们是不是就T的飞起了？  
我们考虑优化这个dfs。  
~~不刚说了吗 dp预警~~   

------

### 做法2：记忆化dfs
根据我们刚刚的三个“状态”，我们了解到可以写一个记忆化dfs。  
那不就是dp嘛！  
我们把每一次的状态都记录下来，如果考虑用`dp[当前节点][当前和]`表示从当前节点开始向下sum的和有多少种方案。  
这既浪费又MLE的飞起，那么我们考虑换掉这个方案。  
因为一个节点只有一个父节点或没有，那么向上遍历的和一定是一样的。  
所以我们只需要用到`dp[当前节点][当前step]`，表示从p开始向下step有多少路径数。  
然后深搜自带sum，与上面的效果就变成是一样的。  
再根据每一个状态，写一个状态转移方程：  
1. 当$sum>S$的时候，没有一条路径
$$
dp[p][step]=0(sum>S)
$$
2. 当$sum = S$的时候，只有一条路径
$$
dp[p][step]=1(sum = S)
$$
3. 当$sum < S$的时候，我们需要子状态来确定，将所有的子状态求和就完了。
$$
dp[p][step]=\sum^{i\in p\texttt{的子节点}}_{i=head[p]}dp[i][step+1]
$$

可以自行结合代码理解。  
**Code:**
```cpp
#include <iostream>
#include <cstdio>

using namespace std;
typedef long long int lli;
struct edge
{
    int to,next;
}Edge[100001];
int head[100001],fa[100001],cnt=1;
inline void add_edge(int from,int son)
{
    Edge[cnt].to=son;
    Edge[cnt].next=head[from];
    head[from]=cnt++;
}
lli ans=0;
int value[100001],n,s;
int dp[100001][50];
lli dfs(int, int, int);

int main()
{
    scanf("%d%d",&n,&s);
    for (register int i=1;i<=n;i++)
    {
        scanf("%d",&value[i]);
    }
    for (register int i=1;i<=n-1;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add_edge(x,y);
        fa[y]=x;
    }
    for (register int i=1;i<=n;i++)
    {
        ans+=dfs(i,value[i],1);
    }
    printf("%lld\n",ans);
    return 0;
}

lli dfs(int p, int sum, int step)
{
    if (dp[p][step])return dp[p][step];
    if (sum>s)return 0;
    if (sum==s)return dp[p][step]=1;
    lli cnt=0;
    for (register int i=head[p];i;i=Edge[i].next)
    {
        cnt+=dfs(Edge[i].to,sum+value[Edge[i].to],step+1);
    }
    return dp[p][step]=cnt;
}
```
窝jio的认真看这篇题解都能做对qwq

-----

### End.
(话说这个与状态压缩有什么关系orz

---

## 作者：Blue_Sky (赞：0)

这道题题意很简单，就是让你在一棵树中找一条路径等于s的(路径的节点深度必须递增)

大佬们用的什么LCA,状压我都不懂QAQ

本蒟蒻就说一下这道题用队列怎么做

如果一条路径的大小超过了题目的S(限制)
，那么这条路径无论怎么延伸都不能为答案做出贡献~~(就是废了)~~

我们只能让路径收缩，才能让它为答案作出贡献

要么把深度最大的那个去掉，要么把深度最小的节点去掉

这不就是队列吗？

我们从每一个节点向它的父节点进行搜索

按照这个方法，在最坏的情况下，时间复杂度就是o(n^2),显然是不行的

那么我们优化一下这个算法

我们每一次搜索都给节点染一次色(看不懂的话可以结合程序理解)

如果我们遇到了一个访问过的点，我们这时候结束搜索，那么就会忽略一些情况

那么我们就要把这些情况都算出来

我们不难发现，当队头(head)也被访问过的话

那么我们就可以退出(return)搜索了

因为之后的情况我们已经算过了

时间复杂度是o(n+m) m是一个常数

如果样例不针对的话还是可以过的

讲完了，献上蒟蒻的代码 :

```cpp
#include<cmath>
using namespace std;
int n,s,i,a[100005]; //ai是i节点的权值 
int f[100005];//fi是i的父节点，没有则为0 
int x,y,num_color,ans; //num_color是染色编号，ans就不说了，大家都懂 
int color[100005]; //每个节点的颜色 
bool vis[100005]; //标记是否被访问过 
void dfs(int x,int sum,int head,int num_color) //x是当前节点,sum是路径的总权值,head是队头，num_color是染色编号
{
	if (!vis[x]) color[x]=num_color; //如果之前没被访问过，那么给他染色，否则不给他染色
	vis[x]=true;//标记 
	while (sum>s) {sum-=a[head]; head=f[head]; if (color[head]<num_color) break;} //如果总权值大于s,就队头出队 
	if (color[head]<num_color) return ; 
	//如果队头head所在的节点在本次遍历之前已经被染过色，就退出，因为之后的情况我们都考虑过了，再遍历没有意义 
	sum+=a[x];
	if (sum==s) ans++;
	if (f[x]!=0) dfs(f[x],sum,head,num_color); //如果它不是根节点，就继续访问 
	return ;
}
int main()
{
	cin>>n>>s;
	for (i=1; i<=n; i++) scanf("%d",&a[i]);
	for (i=1; i<=n-1; i++)
	{
		scanf("%d%d",&x,&y);
		f[y]=x;//记录父节点 
	}
	for (i=1; i<=n; i++) if (!vis[i]) dfs(i,0,i,++num_color); //num_color是染色编号 
	//这里的dfs并不是真正意义上的dfs，只是我不知道叫什么好就用了dfs 
	cout<<ans<<endl;
	return 0; 
}
```
话说这题和状压有什么关系

---

## 作者：zhangyuhan (赞：0)

暴力搜一下即可

以树上每一个节点为搜索的起点，不断往下搜。

注意:在搜的时候有一个很重要的剪枝：如果到当节点该路径的总和已经大于$s$，就可以结束搜索（因为下面会越加越大，不可能等于$s$）。

$AC$ $code$(内含注释)

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct node
{
	int data;
	vector<int> son;//题面中并没说该树是什么类型的树，有可能会有多个孩子
					//且如果用数组开的话，空间会爆炸
					//故使用不定长数组vector存储孩子节点信息
};

int n;

int s;

node tree[100010];

int ans;

void dfs(int id,int sum){//id指当前节点的编号，sum指到当前节点所枚举的路径的和
	if(sum>s)
		return ;//上文所述的剪枝
	if(sum==s){
		ans++;
		return ;
	}//如果等于s,说明存在这样的路径,ans++,并返回
	if(id==0)
		return ;//如果当前节点为空，返回
	for(int i=0;i<tree[id].son.size();i++){//枚举孩子节点
		dfs(tree[id].son[i],sum+tree[tree[id].son[i]].data);//往下搜
	}
}

int main(){
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cin>>tree[i].data;
	}//输入树上节点的信息
	for(int i=1;i<=n-1;i++){
		int x,y;
		cin>>x>>y;
		tree[x].son.push_back(y);
	}//存储这棵树的信息
	for(int i=1;i<=n;i++){
		dfs(i,tree[i].data);
	}//每个节点枚举着搜
	cout<<ans<<endl;//输出答案
	return 0;//完结撒花
}
```

---

## 作者：万弘 (赞：0)

一道不错的DP题

由于记搜便于理解，于是用记搜解此题~~由于我太菜~~

设计状态：

f[u][w]表示在第u号节点时权值和为w的方案数  
但是这样会MLE

重新设计：

f[u][step]表示在第u号节点是这条路径上的第step步时的方案数  
由于至多logn层，所以step只要开50，不会MLE

综上，此算法时间复杂度$O(nlogn)$，空间复杂度也是$O(nlogn)$

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
typedef long long ll;
const ll INF=1ll<<60;
struct tree
{
	ll fa,w;
	std::vector<ll>son;//vector用的方便
}t[100001];
ll f[100001][51];
ll n,s,ans=0;
void start()
{
	scanf("%lld%lld",&n,&s);
	ll u,v;
	for(ll i=1;i<=n;++i)scanf("%lld",&t[i].w);
	for(ll i=1;i<n;++i)
	{
		scanf("%lld%lld",&u,&v);
		t[u].son.push_back(v);
	}
}
ll dfs(ll u,ll step,ll sum)
{
	if(f[u][step])return f[u][step];//记忆化
	sum+=t[u].w;
	if(sum>s)return 0;//边界
	if(sum==s)return f[u][step]=1;
	ll res=0;
	for(ll i=t[u].son.size()-1;i>=0;--i)
	{
		res+=dfs(t[u].son[i],step+1,sum);//类似状态转移方程
	}
	return f[u][step]=res;
}
int main()
{
	start();
	for(ll i=1;i<=n;++i)
		ans+=dfs(i,1,0);//任意一个点开始
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：VenusM1nT (赞：0)

直接暴力即可，一遍DFS计算深度，然后对每个点一遍DFS找答案

（数据是真的水）

见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt,fst[100005],nxt[200005],to[200005];
int n,S,a[100005],dep[100005],ans;
void AddEdge(int u,int v)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
}
void Dfs1(int u,int faz)//计算深度
{
	dep[u]=dep[faz]+1;
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==faz) continue;
		Dfs1(v,u);
	}
}
void Dfs2(int u,int sum)//向下找答案
{
	if(sum>S) return;
	if(sum==S) ans++;
	for(int i=fst[u];i;i=nxt[i])
	{
		int v=to[i];
		if(dep[v]<=dep[u]) continue;
		Dfs2(v,sum+a[v]);
	}
}
int main()
{
	scanf("%d %d",&n,&S);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		AddEdge(y,x);
		AddEdge(x,y);
	}
	dep[0]=-1;//这里设不设都无所谓
	Dfs1(1,0);
	for(int i=1;i<=n;i++) Dfs2(i,a[i]);//n遍DFS即可
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Lich_Ning (赞：0)

过题后看了几篇题解，发现大家都是用前缀和做的，怎么我就先想到后缀和呢？？（逃啦逃啦ε=ε=ε=┏(゜


考虑从每个结点开始向下走，权值和为S的答案数，这就是Dsu on tree 的思路了吧。

在一条重链上统计答案时，假设已经有一个节点的整颗子树的信息，那么要向其父节点转移时，就所有信息都加上父节点的权值。蒟蒻蒻没想到什么，就选了伸展树啦~~

然后就是dsu on tree 的暴力遍历了。

每次修改信息  logn ,dsu on tree 标准复杂度n*logn总复杂度 n*logn*logn  ~~(字体怎么改来着？？~~

~~569ms 跟前缀和比不了啊~~

------------
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1e5+5;
int he[N],ver[N],nex[N],tot;
inline void add(int&,int&);
int sp[N][2],fa[N],val[N],sz[N],ct,laz[N],rt;
#define lc sp[p][0]
#define rc sp[p][1]
inline int newnode(int,int);
inline void up(int),down(int),rota(int,int&),splay(int,int&);
void insert(int&,int,int);
int find(int,int);
void dfs(int);
int siz[N],big[N];
int n,S;
int a[N];
void dfs(int,int),Add(int,int);
int ans;
int main(){
    scanf("%d%d",&n,&S);
    for(int i=1;i<=n;i++) scanf("%d",a+i);
    int u,v;tot=1;
    for(int i=1;i<n;i++){
        scanf("%d%d",&u,&v);
        add(u,v);
    }
    dfs(1);
    dfs(1,1);
    printf("%d",ans);
    return 0;
}
void dfs(int u,int kp){
    int mx=0,son=0;
    for(int i=he[u];i;i=nex[i]){
        int&v=ver[i];
        if(mx<siz[v]) mx=siz[v],son=v;
    }
    for(int i=he[u];i;i=nex[i]){
        int&v=ver[i];
        if(v==son) continue;
        dfs(v,0);
    }
    if(son) dfs(son,1),big[son]=1;
    val[rt]+=a[u];
    laz[rt]+=a[u];
    down(rt);
    Add(u,0);
    ans+=find(rt,S);
    big[son]=0;
    if(!kp) ct=0,rt=0;
}
void dfs(int u){
    siz[u]=1;
    for(int i=he[u];i;i=nex[i]){
        int&v=ver[i];
        dfs(v);
        siz[u]+=siz[v];
    }
}
void Add(int u,int d){
    insert(rt,d+a[u],0);
    for(int i=he[u];i;i=nex[i]){
        int&v=ver[i];
        if(big[v]) continue;
        Add(v,d+a[u]);
    }
}
int find(int p,int x){
    while(p){
        down(p);
        if(val[p]==x) return sz[p];
        if(x<val[p]) p=lc;
        else p=rc;
    }
    return 0;
}
void insert(int&p,int x,int f){
    if(!p){
        p=newnode(x,f);
        splay(p,rt);
        return;
    }
    down(p);
    if(val[p]==x){
        sz[p]++;
        return;
    }
    if(x<val[p]) insert(lc,x,p);
    else insert(rc,x,p);
}
void splay(int p,int&tar){
    int f,ff;
    while(p!=tar){
        f=fa[p],ff=fa[f];
        if(f!=tar){
            if((sp[f][1]==p)^(sp[ff][1]==f)) rota(p,tar);
            else rota(f,tar);
        }
        rota(p,tar);
    }
}
void rota(int p,int&tar){
    int f=fa[p],ff=fa[f],l,r;
    l=sp[f][1]==p,r=l^1;
    if(f==tar) tar=p;
    else sp[ff][sp[ff][1]==f]=p;
    fa[p]=ff,fa[f]=p,fa[sp[p][r]]=f;
    sp[f][l]=sp[p][r],sp[p][r]=f;
}
void down(int p){
    if(!laz[p]) return;
    val[lc]+=laz[p],val[rc]+=laz[p];
    laz[lc]+=laz[p],laz[rc]+=laz[p];
    laz[p]=0;
}
int newnode(int x,int f){
    int&p=++ct;
    val[p]=x,fa[p]=f;
    lc=rc=laz[p]=0;
    sz[p]=1;
    return p;
}
void add(int&u,int&v){
    ver[tot]=v;nex[tot]=he[u];he[u]=tot++;
}

```

---

## 作者：逝星DS (赞：0)

P3252 【[JLOI2012]树】

题目描述

在这个问题中，给定一个值S和一棵树。在树的每个节点有一个正整数，问有多少条路径的节点总和达到S。路径中节点的深度必须是升序的。假设节点1是根节点，根的深度是0，它的儿子节点的深度为1。路径不必一定从根节点开始。

输入输出格式

输入格式：
第一行是两个整数N和S，其中N是树的节点数。 第二行是N个正整数，第i个整数表示节点i的正整数。 接下来的N-1行每行是2个整数x和y，表示y是x的儿子。

输出格式：
输出路径节点总和为S的路径数量。

输入输出样例

输入样例#1： 复制
3 3
1 2 3
1 2
1 3
输出样例#1： 复制
2
说明

对于100%数据，N<=100000，所有权值以及S都不超过1000。

思路：数据太水，直接爆搜，上大法师（dfs）；

代码：（附有详细解释）

```cpp
#include <iostream> 
#define maxN 100010
using namespace std;
int N,M;
int x[maxN];
struct edge {
	int son;
	int next;
} E[maxN];
int first[maxN];
int fa[maxN];  //存father,fa[i]=i则为root； 
int root;  //根节点； 
int ans;
int sum[maxN];  //存从root到此点和； 
void dfs(int s);
int main()  {
	cin>>N>>M;
	for(int i=1;i<=N;i++)  {
		cin>>x[i];
		fa[i]=i;  //初始化； 
	}
	int a,b;  //b为a的son； 
	for(int i=1;i<N;i++)  {  //N-1条边； 
		cin>>a>>b;
		fa[b]=a;  //记录father； 
		E[i].son=b;//由father指向son；
		E[i].next=first[a];
		first[a]=i;
	}
	//find root;
	for(int i=1;i<=N;i++)  {
		if(fa[i]==i)  {  //fa[i]=i则为root； 
		    root=i;
			break; 
		}
	}
	dfs(root);
	cout<<ans;
	return 0;
}
void dfs(int s)  {
	sum[s]=sum[fa[s]]+x[s];  //类似dp；
	if(sum[s]==M)  {  //满足题意；
	  ans++; 
	} 
	else if(sum[s]>M)  {  //超过S，则想搜；
	    int summ=0;
		for(int i=s;fa[i]!=i;i=fa[i])  {
			summ+=x[i];
			if(summ==M)  {  //满足题意；
			    ans++;
			}
			else if(summ>M)  {  //超过M，不存在；
			    break; 
			}
		} 
	}
	for(int i=first[s];i;i=E[i].next)  {
	    dfs(E[i].son);
	}
	return;
}
```

---

## 作者：laduiw (赞：0)

此题可以转换一下思路，从每个点向上走，但会不会有问题呢？

题目中说必须从上往下走，但注意到如果存在一条路径a-b(从上往下），就会在枚举到b时找到这条路，所以没问题的。

这样这道题就简单多了，不要dfs，每个点不断向父亲走，统计点权和，如果正好等于s，就累加，因为点权>0，所以加到>s，直接跳出，如果走到根都<s，那么这条刚走过的路上的所有点都不会存在有效路径，用一个bool数组标记一下，可以快一点。

附上c++AC程序（应该不是最好做法）


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,ans=0,w[100010],fa[100010];
bool pd[100000];
void dfs(int x)//忽略这个函数名，应该不算dfs
{
    int t=0,y=x;
    while (x!=0)//因为根也有权值，所以！=0
    {
        t+=w[x];//累加
        x=fa[x];//不停向上走
        if (t==s) {
        ans++;return;}//找到，因为点权>0，所以每点最多只有1条
        if (t>s) return;//剪枝
    }
    if (t<s) while (y!=0) {
    pd[y]=true;y=fa[y];}//标记那些不可能的点
}
int main()
{
    memset(fa,0,sizeof(fa));
    memset(pd,false,sizeof(pd));
    scanf("%d %d",&n,&s);
    for (int i=1;i<=n;i++) scanf("%d",&w[i]);
    for (int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        fa[y]=x;
    }
    for (int i=n;i>=1;i--)
        if (pd[i]==false)dfs(i);//如果i点有可能就枚举一次
    cout<<ans<<endl;
}
```

---

## 作者：__asm (赞：0)

什么状压DP。这不就是简单的模（广）拟（搜）。太水了\*0xFFFFFFFFFF。

tnode是一个用来保存当前节点的结构体。因为节点的值>0，所以在判断和时当目前和大于S就直接剪掉。有兴趣的同学可以试试DFS。

```cpp
[language = cpp]
<code>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
int n, s;
int total = 0;
struct tnode{
    int value;
    int father;
    vector<int> child;
    tnode(){
        this->child.clear();
        this->value = 0;
        this->father = -1;
    }
}a[100000];
bool isOK(const tnode &n){
    tnode p = n;
    int nsum = n.value;
    while(nsum < s){
        p = a[p.father];
        nsum += p.value;
        if(p.father == -1)break;
    }
    if(nsum == s)return true;
    return false;
}
void bfs(){
    queue<tnode> Q;
    Q.push(a[0]);
    while(!Q.empty()){
        tnode head = Q.front();
        if(isOK(head))total++;
        if(!head.child.empty()){
            for(unsigned int i = 0;i < head.child.size();i++){
                Q.push(a[head.child[i]]);
            }
        }
        Q.pop();
    }
}
int main(){
    scanf("%d%d", &n, &s);
    for(int i = 0;i < n;i++)scanf("%d", &a[i].value);
    for(int i = 0;i < n - 1;i++){
        int x, y;
        scanf("%d%d", &x, &y);
        a[x-1].child.push_back(y-1);
        a[y-1].father = x - 1;
    }
    bfs();
    printf("%d\n", total);
    return 0;
}
</code>
[end]
```

---


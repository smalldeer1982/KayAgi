# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# 题解

## 作者：Fading (赞：323)

upd on 2019.8.8

说我的程序样例都过不去的同学，非常抱歉。我本机跑样例都是对的。

目前已知的 hack 数据，卡爆了我 double 的精度。现在我已经修正了这份代码。

这份代码在 UOJ 上可以 AC 。

------------


**楼下的并查集都怎么了？？？**

### 都只有 80 分？？？

那我来~~水一波~~ AC 的并查集算法吧

我这个算法很好理解，不想楼下的大佬那样~~看不懂~~

思路比较简单，就是如果两个洞相交（或相切），就把它们连入一个集合

可以想象一个集合就是一条通道，如图：

 ![](https://cdn.luogu.com.cn/upload/pic/11083.png) 

图中就有 $3$ 个集合。这 $3$ 个集合就是三条通道。

我们只需要判断每一条通道是否存在元素与底部、顶部相连即可。如果都有，那么输出 Yes。这个可以使用并查集。

那么问题来了，如何判断两个球是否相交（切）呢？

其实如果你数学很好、做题经验丰富，你就会知道了：

### 如果两个球的半径之和 $\geq$ 两个球球心的距离，那么两圆相交（切）。

那么用这一条来判断就可以了。

具体的实现细节看代码吧：

```cpp
#include<bits/stdc++.h>
using namespace std;//不加本代码爆零
int f[1001];//并查集
int find(int x){
    if (x!=f[x]) f[x]=find(f[x]);
    return f[x];
}//查找+路径压缩
long long dis(long long x,long long y,long long z,long long x1,long long y1,long long z1){
    return (x-x1)*(x-x1)+(y-y1)*(y-y1)+(z-z1)*(z-z1);
}//两点距离公式，注意这里算的是距离平方。
long long x[100001],y[100001],z[100001];
int f1[100001],f2[100001];
//f1记录与顶面相交的洞的序号
//f2记录与底面相交的洞的序号
int main(){
    int t;
    scanf("%d",&t);
    int n,h; 
    long long r;
    for (int i=1;i<=t;i++){
        scanf("%d%d%lld",&n,&h,&r);//long long不开的话...
        int tot1=0;//记录与顶面相交的洞有几个
        int tot2=0;//记录与底面相交的洞有几个
        for (int j=1;j<=n;j++){
          f[j]=j;  //并查集初始化
         }
        for (int j=1;j<=n;j++){
            scanf("%lld%lld%lld",&x[j],&y[j],&z[j]);//long long不开的话...
            if (z[j]+r>=h){//判断这个点是否与顶面相交
                tot1++;
                f1[tot1]=j;
            }
            if (z[j]-r<=0){//判断这个点是否与底面相交
                tot2++;
                f2[tot2]=j;
            }
            for (int k=1;k<=j;k++){//枚举之前的洞是否与这个洞相交，如果相交则合并集合
            	if ((x[j]-x[k])*(x[j]-x[k])+(y[j]-y[k])*(y[j]-y[k])>4*r*r) continue;
            	//防止爆long long的特判。 
                if (dis(x[j],y[j],z[j],x[k],y[k],z[k])<=4*r*r){
                    int a1=find(j);
                    int a2=find(k);
                    if (a1!=a2) f[a1]=a2;
                }
            }
        }
        int s=0;
        //看看每一个中是否有洞连接上下面
        for (int j=1;j<=tot1;j++){
            for (int k=1;k<=tot2;k++){
                if (find(f1[j])==find(f2[k])){
                    s=1; 
                    break;
                }
            }
            if (s==1) break;
        }
        if (s==1) cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
} 
```

---

## 作者：ikunTLE (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P3958)

### 思路

可以使用**并查集**解决此题。

首先将满足 $z\ge h-r$ 的数放入集合 $F_1$ 中，将满足 $z\le r$ 的数放入集合 $F_2$ 中。这是因为以上两个条件分别能满足顶面相交和底面相交。

然后判断两个空洞是否相通，只需判断 $\text{dist}(P_i,P_j)\le2\times r$ 即可。这是因为两圆的圆心距离小于或等于它们的半径之和，两个圆就会相交或刚好相接。如果满足条件，就将 $P_i$ 和 $P_j$ 通过并查集合并。

最后，判断是否存在 $F_{1,i}$ 与 $F_{2,j}$ 相连即可。

**注意事项**

- 不开 `long long` 见祖宗。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define y1 y_1
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e6+10;
int n,h,r,fa[N],x[N],y[N],z[N],f1[N],f2[N];
void _init(){
	for(int i=1;i<=n;++i)
		fa[i]=i;
	return;
}
int _find(int x){
	if(x==fa[x])
		return x;
	fa[x]=_find(fa[x]);
	return fa[x];
}
void _merge(int x,int y){
	int fx=_find(x),fy=_find(y);
	if(fx!=fy)
		fa[fx]=fy;
	return;
}
int dis(int x1,int x2,int y1,int y2,int z1,int z2){
	return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);
}
void solve(){
	n=read(),h=read(),r=read();
	_init();
	int cnt1=0,cnt2=0;
	for(int i=1;i<=n;++i){
		x[i]=read(),y[i]=read(),z[i]=read();
		if(z[i]>=h-r)
			f1[++cnt1]=i;
		if(z[i]<=r)
			f2[++cnt2]=i;
		for(int j=1;j<=i;++j){
			if(dis(x[i],x[j],y[i],y[j],z[i],z[j])>4*r*r)
				continue;
			int temp_1=_find(i),temp_2=_find(j);
			if(temp_1!=temp_2)
				_merge(temp_1,temp_2);
		}
	}
	bool flag=false;
	for(int i=1;i<=cnt1;++i){
		for(int j=1;j<=cnt2;++j)
			if(_find(f1[i])==_find(f2[j])){
				flag=true;
				break;
			}
		if(flag)
			break;
	}
	printf(flag?"Yes\n":"No\n");
	return;
}
signed main(){
	short T=read();
	while(T--)
		solve();
	return 0;
}
```

---

## 作者：liangbob (赞：5)

本题解仿照联合国大会决议写成。

---

联合国大会第一百一十四届会议

议程项目一：一系列信息题目的解法

## 2025 年 1 月 4 日大会决议

[未经发交主要委员会而通过]

### 114/514. 题目 P3958 的解法

**大会，**

**注意到**题目给出了两个奶酪相连通的条件，即两球相切或相交。

**又注意到**题目询问是否能从下表面洞走到上表面洞，即询问某两个洞是否连通。

**回顾**并查集的作用，即连接一系列点，然后判断某两个点是否连通。恰好是本题所要解决的问题。

**考虑**连通即两球相切或相交的条件，显然当两球的球心距离小于两球半径之和时，两圆相切或相交。

**又考虑**一个洞位于上表面的条件，是最上端顶点 $z$ 坐标即 $z_i+r$ 大于等于 $h$。

**还考虑**一个洞位于下表面的条件，是最下端顶点 $z$ 坐标即 $z_i-r$ 小于等于 $0$。

**建议**两两枚举所有的洞，将所有洞在并查集中连通。然后遍历所有洞，筛选出位于上表面和下表面的点。接着遍历每个上表面的点和下表面的点并判断是否连通。最后输出即可。

**还建议**使用 long long 类型，因为在计算距离的时候两个 $10^9$ 相乘会超过 int 类型的范围。

**观察到**这样的做法复杂度是 $O(n^2)$，可以通过本题。

**强调**“多测不清空，爆零两行泪”这一事实。

**给出**下列可以通过的代码：

```cpp
#include <iostream>
#include <cmath>
#define int long long
using namespace std;
const int N = 1e5 + 10;

int T;
int x[N], y[N], z[N], xbm[N], sbm[N], p, q;
int fa[N];

int find(int x)
{
    return (fa[x] == x ? x : fa[x] = find(fa[x]));
}

signed main()
{
    cin >> T;
    while(T--)
    {
        int n, h, r;
        cin >> n >> h >> r;
        for(int i = 1;i <= n;i++)
        {
            cin >> x[i] >> y[i] >> z[i];
            fa[i] = i;
        }
        p = 0;
        q = 0;
        for(int i = 1;i <= n;i++) 
        {
            for(int j = 1;j < i;j++)
            {
                if(sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j])) <= r + r)
                {
                    int fi = find(i), fj = find(j);
                    if(fi != fj) fa[fi] = fj;
                }
            }
            if(z[i] - r <= 0) xbm[++p] = i;
            if(z[i] + r >= h) sbm[++q] = i;
        }
        bool ok = 0;
        for(int i = 1;i <= p;i++)
        {
            for(int j = 1;j <= q;j++)
            {
                if(find(xbm[i]) == find(sbm[j]))
                {
                    ok = 1;
                    break;
                }
            }
            if(ok) break;
        }
        cout << (ok ? "Yes" : "No") << endl;
    }
    return 0;
}
```

2025 年 1 月 4 日

第七十次全体会议

d8748c4a-f8c7-49bb-b8ec-218bb66fd4d0

---

## 作者：wyx__ (赞：5)

**为什么大家的DFS都不会TLE？**

我也是一看到这题就写了个简简单单的DFS，然后交上去只有80分。

好的别的不讲了，先讲一下DFS怎么写。

就是枚举每个与下底面相交或相切的空洞，然后以其为起点搜每个相邻的点，每个点只用搜一次，最后若搜到与上底面相交或相切的空洞就OK了。

代码如下（DFS部分）：
```cpp
bool e(int i,int j){//判断相交或相切
    double dis=(x[i]-x[j])*(x[i]-x[j])+
    (y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);//距离的平方
    return dis<=4*r*r;
}
void dfs(int k){
    if(ok)return;//搜到了就不用再搜了
    if(z[k]+r>=h){
        ok=1;
        return;
    }
    v[k]=1;//打标记
    for(int i=1;i<=n;i++)
    if(!v[i]&&e(i,k))
    dfs(i);//搜联通的空洞
    v[k]=0;//清除标记
}
```
然后发现T了两个点，于是和别的代码对比，发现并不需要v[k]=0一句。

为什么呢？因为每一次以不同的起点搜索时，之前搜过的点能否到达已经确定，所以就不用搜了。这样就不会T了。
完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,v[1005],t,ok;
double x[1005],y[1005],z[1005],h,r;
bool e(int i,int j){
    double dis=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]);
    return dis<=4*r*r;
}
void dfs(int k){
    if(ok)return;
    if(z[k]+r>=h){
        ok=1;
        return;
    }
    v[k]=1;
    for(int i=1;i<=n;i++)
    if(!v[i]&&e(i,k))
    dfs(i);
}
int main(){
    cin>>t;
    for(int i=1;i<=t;i++){
    	memset(v,0,sizeof(v));//记得清零
        ok=0;
        cin>>n>>h>>r;
        for(int j=1;j<=n;j++)
        cin>>x[j]>>y[j]>>z[j];
        for(int j=1;j<=n;j++)
        if(z[j]-r<=0)
        dfs(j);
        if(ok)cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
} 
```


---

## 作者：pipilong2024 (赞：4)

题解区的大部分竟都被 dfs 和 bfs 占领了，个别写并查集又被卡了。这忍得了 ~~（我又不是忍者）~~！
___
针对于每一个空洞我们定义：  
 _最大高度_  $=$  _球心高度_  $+$  _该球半径_，表示**在这个球内所能到达**的**最高**的高度；  
 _最小高度_  $=$  _球心高度_  $-$  _该球半径_，表示**在这个球内所能到达**的**最矮**的高度。  
当两个空洞  $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 相切或是相交时，一定满足（如题所述）：
$$
\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2} \le 2 \times r
$$
为避免精度问题，两边平方（去根号）得
$$
(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2 \le 4 \times r^2
$$
此时便可更新 _最大高度_ 和 _最小高度_，使用并查集合并，具体操作见代码。  
最后只需查看是否存在一个空洞使得其 _最大高度_ $\ge h$，_最小高度_ $\le 0$ 即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//十年OI一场空，不开____一场空
int n, h, r, t;//如题目
struct Node {
	int x, y, z;
} a[1001];//空洞节点
int fa[1002], min_h[1002], max_h[1002];
//fa是父亲编号，min_h是最小高度，max_h是最大高度
int dist(int x1, int x2, int y1, int y2, int z1, int z2) {
	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2);
}
int find(int x) {
	if (fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}//并查集函数
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> t;
	while (t--) {
		cin >> n >> h >> r;
		for (int i = 1; i <= n; i++) {
			cin >> a[i].x >> a[i].y >> a[i].z;
          //初始化 fa，min_h 和 max_h
			fa[i] = i;
			min_h[i] = a[i].z - r;
			max_h[i] = a[i].z + r;
		}
		for (int i = 1; i <= n; i++) {
			for (int j = i + 1; j <= n; j++) {
				if (4 * r * r >= dist(a[i].x, a[j].x, a[i].y, a[j].y, a[i].z, a[j].z)) {
					int ri = find(i), rj = find(j);
					fa[rj] = ri;//合并
          //更新 min_h 和 max_h
					min_h[ri] = min(min_h[ri], min_h[rj]);
					max_h[ri] = max(max_h[ri], max_h[rj]);
				}
			}
		}
		bool flag = 0;
		for (int i = 1; i <= n; i++) {
			if (fa[i] != i) continue;
			if (min_h[i] <= 0 && max_h[i] >= h) {//见上
				flag = 1;
				break;
			}
		}
		if (flag) cout << "Yes\n";
		else cout << "No\n";
	}
	return 0;
}
```
___
小注：$80$ 分的同学考虑一下精度问题和范围问题，别问我怎么知道——$\color{red}{血}$的教训。

---

## 作者：ZAYNAab (赞：2)

## 题意

$t$ 组数据，每组数据你一个高为 $h$ 的奶酪，其中含有 $n$ 个半径为 $r$ 的空洞，每个空洞的球心在 $P_i(x_i,y_i,z_i)$。

问是否能通过空洞从下表面爬到上表面。

## 解题分析

这道题可以用 **dfs** 做，将空洞看为点，相切或相交则看作连边。

首先处理数据，看哪些空洞相切或相交，即两者球心距离小于半径 $r$，就将他们连边。

如果该空洞与下表面相切，就代表可以从该空洞开始搜索。

如果该空洞与上表面相切，就代表搜到该空洞即代表搜索通过，输出 `yes`。

所有路试完后仍未输出 `yes`，输出 `no`。

最后，**多测一定要清空**！

```cpp
#include<bits/stdc++.h>
using namespace std;
double t,n,h,r,f;
bool map1[1005][1005],visit[1005];
struct node{
	double x,y,z;
}a[1005];
double dis(node a,node b){
	return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2));
}
void dfs(int p){
	if(a[p].z+r>=h){f=1;return ;}
	for(int i=1;i<=n;i++){
		if(map1[p][i] and (!visit[i])){
			visit[i]=1;
			dfs(i);
		}
	}
	return ;
}
queue<int> q;
int main(){
	scanf("%lf",&t);
	for(int i=1;i<=t;i++){
		memset(map1,0,sizeof(map1));
		memset(visit,0,sizeof(visit));
		scanf("%lf%lf%lf",&n,&h,&r);
		for(int j=1;j<=n;j++){
			scanf("%lf%lf%lf",&a[j].x,&a[j].y,&a[j].z);
		}
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				if(dis(a[j],a[k])<=r*2 and j!=k){
					map1[j][k]=map1[k][j]=1;
				}
			}
			if(a[j].z-r<=0){
				q.push(j);	
			}
		}
		f=0;
		while(!q.empty()){
			visit[q.front()]=1;
			dfs(q.front());
			q.pop();
			if(f){
			printf("Yes\n");
			while(!q.empty()){
				q.pop();
			}
			}
			memset(visit,0,sizeof(visit));
		}
		if(!f)printf("No\n");
	}
	return 0;
}
```

---

## 作者：Hell0_W0rld (赞：2)

考虑直接建图跑 bfs 查找。

我们将下表面即为节点 $0$，将上表面记为节点 $n+1$。

考虑直接暴力连边，我们知道两个球相交（切）等价于 $\operatorname{dist}(O_1,O_2)\leq R_1+R_2$。我们用这条性质连边。和 $0$ 号节点相连等价于 $z_i\leq R$，和 $n+1$ 号节点连边等价于 $z_i\geq w-r$。

跑一遍 bfs，如果能从 $0$ 号走到 $n+1$ 号，则答案为 `Yes`。否则答案为 `No`。

---

## 作者：Eason0324 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3958)

## 思路
这道题裸的 **BFS**。

通过初中数学可以知道，两个圆相交当且仅当两个圆的半径和小于等于半径的距离。

那么两个球呢？

我们首先可以发现，如果两个球相交了，那么必有一个平面，其穿过两个球的球心且经过其相交的点。

然后转化成二维即可。**球心距离按照三维算更简单。**

## 代码实现
首先，两点距离大概率是小数，为了避免精度问题，平方转成整数。

接下来就是代码环节：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct zb{
	int x,y,z;
}a[1009];
int r,n,h,T;
queue<int> q;

bool dis(int x1,int y1,int z1,int x2,int y2,int z2){
	int d=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2);
	return d<=4*r*r;
}
bool bfs(int ed){
	bool vst[1009];
	for(int i=0;i<n;i++){
		vst[i]=0;
	}
	while(!q.empty())q.pop();
	q.push(ed);
	vst[ed]=1;
	while(!q.empty()){
		int dot=q.front();
		q.pop();
		if(a[dot].z>=h-r){
			return 1;
	}
		
		for(int j=0;j<n;j++){
			if(vst[j]){
				continue;
			}
			if(dis(a[dot].x,a[dot].y,a[dot].z,a[j].x,a[j].y,a[j].z)){	
				q.push(j);
				vst[j]=1;
			}
		}
	}
	return 0;
}
signed main(){
	cin>>T;
	for(int qwertyuiopasdfghjklzxcvbnm=0;qwertyuiopasdfghjklzxcvbnm<T;qwertyuiopasdfghjklzxcvbnm++){
		bool c=1;
		cin>>n>>h>>r;
		for(int i=0;i<n;i++){
			cin>>a[i].x>>a[i].y>>a[i].z;
		}
		for(int i=0;i<n;i++){
			if(a[i].z<=r){
				if(bfs(i)){
					cout<<"Yes"<<endl;
					c=0;
					break;
				}
			}
		}
		if(c){
			cout<<"No"<<endl;
		}
	}
}
```

---

## 作者：ljh0727 (赞：2)

# P3958奶酪

原题链接：[题目](https://www.luogu.com.cn/problem/P3958)

### 题目分析

在一个高度为 $h$ 的三维空间里挖了 $n$ 个球状的空间，每个球的半径是 $r$，问能否从最低下到最顶上。

### 思路

如果我们枚举每个与下底面相交或相切的球，然后搜索每个相邻的球，每个球只搜一次，最后若搜到与上底面相交或相切的球就可以了。

综上所述，我们只需要一个 DFS 算法就可以轻松解决以上操作。

### 代码


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>


using namespace std;

const int M=1e3+5;


double x[M],y[M],z[M];
bool a[M];
double n,h,r,m;

void f(int k){
	if(a[k])//如果来过就返回 防止路径重复 
		return;
	a[k]=true;
	if(h<=z[k]+r){//判断是否到顶 
		m=1;
		return;
	}
	for(int i=1;i<=n;i++){
		double kkkc=sqrt((x[i]-x[k])*(x[i]-x[k])+(y[i]-y[k])*(y[i]-y[k])+(z[i]-z[k])*(z[i]-z[k]));//测算距离 
		if(kkkc<=r+r){//相交或相切 
			f(i);//拓展这个点 
		}
	}
}

int main(){
	int T;
	scanf("%d",&T);
	
	while(T--){
		
		cin>>n>>h>>r;
		
		for(int i=1;i<=n;i++){
			cin>>x[i]>>y[i]>>z[i];
		}
		
		m=0;
		memset(a,false,sizeof(a));//清空数组 
		
		for(int i=1;i<=n;i++)
			if(z[i]<=r)//延申每一个最底下的点 
				f(i);
		
		if(m){//如果 m=1 那么就达到过最顶上 
			printf("Yes\n");
		}else{
			printf("No\n");
		}
	}
	
	return 0;
}

```

---

## 作者：_3Zinc_ (赞：2)

# NOIP2014 奶酪

## 思考：

直接看 $100\%$ 的数据吧，$1 \le n \le 1\times 10^3$，显然是时间复杂度大致为 $\mathcal{O}(n^2)$ 的。

> 每次枚举一对奶酪洞，判断他们是否相连
>
> 如何判断？只要判断他们的距离是否小于等于他们的半径之和就可以了。
>
> 如果相连，那么就把两个洞加到同一个并查集里（其实这里有点问题，因为并查集操作是 $\mathcal{O}(\alpha (n))$ 的，但还是你谷评测机很给力可以过）
>
> 然后把能够连到上边和下边的洞记录下来，看有没有洞既能练到上面又能连到下面。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int t,n;
double x[1005],y[1005],z[1005],h,r;
int fa[1005],d[1005],p[1005];
int findfa(int x) {
	return fa[x]==x?x:(fa[x]=findfa(fa[x]));
}
void join(int x,int y) {
	int fax=findfa(x),fay=findfa(y);
	fa[fay]=fax;
	return ;
}
double P(double x) {
	return x*x;
}

int main() {
	scanf("%d",&t);
	while(t--) {
		scanf("%d%lf%lf",&n,&h,&r);
		int l1=0,l2=0;
		for(int i=1;i<=n;i++) fa[i]=i;
		for(int i=1;i<=n;i++) {
			scanf("%lf%lf%lf",&x[i],&y[i],&z[i]);
			for(int j=1;j<i;j++) {
				double t=sqrt(P(x[i]-x[j])+P(y[i]-y[j])+P(z[i]-z[j]));
				if(t<=2*r) join(i,j);
			}
			if(z[i]+r>=h) d[++l1]=i;
			if(z[i]-r<=0.00) p[++l2]=i;
		}
		bool k=false;
		for(int i=1;i<=l1;i++)
			for(int j=1;j<=l2;j++)
				if(findfa(d[i])==findfa(p[j])) {
					k=true;
					break;
				}
		if(k) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---

## 作者：ClaudeHsu (赞：1)

# **思路**

直觉告诉我，深度优先搜索。

两个空洞相切或相交，等于两者球心距离小于半径的两倍，就让他们联通。

如果该空洞与下表面相切，就可以从该空洞开始搜索。

如果该空洞与上表面相切，就代表可以通过。

# **代码**


```cpp
#include<bits/stdc++.h>
using namespace std;
double t,n,h,r;//一定要开double
struct node{
	double x;
	double y;
	double z;
}c[1005];//点的三个坐标
bool d[1005],e[1005][1005],g;//为了防止重复搜索，d[i]表示点i是否被搜过，数组e是邻接矩阵
double juli(node a,node b){
	return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)+pow(a.z-b.z,2));
}//求距离
void dfs(int f){
	if(c[f].z+r>=h){
		g=1;
		return;
	}//搜索通过，c[f].z+r表示本点的顶端
	for(int i=1;i<=n;i++){
		if(e[f][i]&&d[i]==0){
			d[i]=1;
			dfs(i);
		}
	}
}
queue<int>q;//尽量用队列，不占空间
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		memset(d,0,sizeof(d));
		memset(e,0,sizeof(e));
		cin>>n>>h>>r;
		for(int j=1;j<=n;j++)
		cin>>c[j].x>>c[j].y>>c[j].z;
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				if(juli(c[j],c[k])<=r*2&&j!=k){//判断j和k两点是否联通，注意r要乘2
					e[j][k]=1;
					e[k][j]=1;//无向图，所以j到k和k到j都联通
				}
			}
			if(c[j].z-r<=0)q.push(j);
		}
		g=0;//多组数据清空
		while(!q.empty()){
			d[q.front()]=1;
			dfs(q.front());
			q.pop();
			if(g){
				cout<<"Yes"<<endl;
				while(!q.empty()){
					q.pop();
				}
			}
			memset(d,0,sizeof(d));//注意清空
		}
		if(g==0)cout<<"No"<<endl;
	}
}
```

---

## 作者：Malkin_Moonlight (赞：1)

## Solution

看到大家都在用并查集，这里我提供一种思路思路，我用的是 dfs。

首先需要明确一个事情，如何判断两个圆是否相交（切）呢？答案就是两个圆圆心的距离小于等于两个圆的半径之和。没懂咱们就来画个图看看。

1. 如果两个圆相切：

![](https://cdn.luogu.com.cn/upload/image_hosting/y1xjvfcp.png)


- 两个圆的圆心距离 $= r + R$。
- 两个圆半径之和 $= r + R$。

所以两个圆的圆心距离与两个圆半径之和相等。

2. 如果两个圆相交

![](https://cdn.luogu.com.cn/upload/image_hosting/p4445gqt.png)

- 两个圆的圆心距离 $< L + R$。
- 两个圆半径之和 $= r + R$。

综上，当两个圆圆心的距离小于等于两个圆的半径之和时，两个圆两个圆相交（切）。

而题目中由于所有圆半径都是 $r$，所以两个圆半径之和 $= 2 \times r$。

接下来我们来考虑计算距离。以下是题目原话。

> 空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：$\mathrm{dist}(P_1, P_2) = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$

题解区很多人都在用 `sqrt` 强行开方再用 `double` 存储，这样有可能会出现精度问题。虽然这样能过此题，但是养成好习惯，在做其他题目时就不会出现问题。

那么怎么解决呢？方法是将式子两边都平方，得到：

$\mathrm{dist}(P_1, P_2) ^ 2 = (x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2$

那么计算距离的代码如下。这里的 `dist(i, j)` 已经是平方的结果。


```cpp
ull sq(ll x) {
	return x * x;
}

ull dist(ll i, ll j) {
	return sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]);
}
```

距离平方了，两个圆半径之和也要平方，也就是 $2 \times r \times 2 \times r = 4 \times r ^ 2$。

得出两个圆两个圆相交（切）的判断代码是：`if (dis(i, j) <= 4 * r * r)`。存储两点是否连通我们使用邻接矩阵来存储。所以当此条件成立时 `mp[i][j] = mp[j][i] = 1;`。

接下来来看 dfs，我们视 $0$ 为下表面，$n + 1$ 为上表面，则从 $0$ 开始 dfs，用一个 `vis` 数组来判断是否重复和记录走过哪个点，最后如果能搜到 $n + 1$ 那么就代表能到上表面，输出 `Yes`，否则输出 `No`。

注意多测一定要清空呀。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

ll T, n, h, r;
ll x[1005], y[1005], z[1005];
bool mp[1005][1005], vis[1005]; //mp就是记录两点是否连通，vis是dfs时记录走过哪个点和防止重复用的 

ull sq(ll x) {
	return x * x;
}

ull dis(ll i, ll j) {
	return sq(x[i] - x[j]) + sq(y[i] - y[j]) + sq(z[i] - z[j]);
}

void dfs(ll x) {
	vis[x] = 1;
	for (int i = 1; i <= n + 1; i++) {
		if (!vis[i] && mp[x][i]) dfs(i);
	}
}

int main() {
	cin >> T;
	while (T--) {
		memset(mp, 0, sizeof(mp));
		memset(vis, 0, sizeof(vis));//多测不清空，爆零两行泪 
		cin >> n >> h >> r;
		for (int i = 1; i <= n; i++) {
			cin >> x[i] >> y[i] >> z[i];
			for (int j = 1; j < i; j++) {
				if (dis(i, j) <= 4 * r * r) mp[i][j] = mp[j][i] = 1;
			}
			if (z[i] <= r) mp[0][i] = 1; //和下表面相连 
			if (z[i] + r >= h) mp[i][n + 1] = 1; //和上表面相连 
		}
		dfs(0);
		cout << (vis[n + 1] ? "Yes\n" : "No\n");
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

# 题解：P3958 \[NOIP2017 提高组] 奶酪

## 思路

不妨考虑并查集数据结构，对于并查集这种数据结构不再阐述，相关内容请学会使用搜索引擎。

既然要从一个洞口到另一个洞口，那么就把这两个洞口放到一个集合（即可以通过）里。

那是不是所有的洞口都能合并呢？显然不行，那这样就一定有解了。

怎样才能将两个洞口合并呢？如果两个洞口的圆心的直线距离不大于（即小于或等于）两个半径，就可以将这两个洞口合并。

## 代码

去年的去年的代码：

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define maxn 1010
int n,h,r,fa[maxn],T;
int x[maxn],y[maxn],z[maxn];

int find(int x){
	if(fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}
void uni(int x, int y){
	int rx = find(x), ry = find(y);
	if(rx == ry) return;
	fa[ry] = rx;
}
void init(){for(int i = 0;i <= n+1;i++) fa[i] = i;}
double squ(double x){return x * x;} 
double dis(double x1,double y1,double z1,double x2,double y2,double z2){return (double)((double)squ(x1-x2) + (double)squ((y1-y2)) + (double)squ((z1-z2)));}

int main(){
	cin>>T;
	while(T--){
		cin>>n>>h>>r;
		init();
		for(int i = 1;i <= n;i++){
			cin>>x[i]>>y[i]>>z[i];
			// 进行洞口和洞口（即通道）的合并操作
			if(abs(z[i] - 0) <= r) uni(0,i);
			if(abs(z[i] - h) <= r) uni(n+1,i);
			for(int j = 1;j < i;j++){if(4LL * r * r >= dis(x[i],y[i],z[i],x[j],y[j],z[j])) uni(i,j);}
		}
		if(find(0) == find(n+1)) cout<<"Yes"<<endl; // 判断起点和奶酪表面是不是在一个集合里，也就是说能不能到达
		else cout<<"No"<<endl;
	}
	return 0;
}
```

---

## 作者：ZSYhaouuan (赞：1)

涉及到集合的合并操作，可以使用并查集这个数据结构。

容易发现，可以把一个通道看成一个集合，答案就是这些集合能到达上下两端的通道数量了。问题就在于，如何对于洞口进行合并。

怎么样的两个洞可以合并呢？可以发现，如果两个圆的圆心的直线距离小于等于两个半径，即可以合并。

然后接着考虑怎么合并。我的想法是优先遍历编号小的洞，如果能合并就将祖先更新为它；之后再遇到别的洞就让他们祖先更新成自己祖先。这样一来，所有通道的有关信息都在编号最小的洞里了。

考虑设置两个数组，分别表示此结点及所在通道是否到达上方和到达下方。更新的时候，把祖先被更新的信息的洞的上下信息更新到自己祖先去即可。

最后遍历哪一个上下两方都有通道，大功告成！

AC代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
//fa为祖先信息
ll t, fa[10000 + 100];
//top代表到达顶上的，down代表到达底下的
bool top[10000 + 100], down[100000 + 10];
struct node {
	ll x, y, z;
} p[10000 + 100];
ll fin(ll x) {//板子
	if (fa[x] == x) return x;
	else return fa[x] = fin(fa[x]);
}
int main() {
	cin >> t;
	for (ll o = 1; o <= t; o++) {
		//多测不清空，原地见祖宗。。。
		memset(top, 0, sizeof top);
		memset(down, 0, sizeof down);
		for (ll i = 1; i <= 10000; i++) p[i].x = p[i].y = p[i].z = 0;

		ll n, h, r, ans = 0;//ans总计答案数量
		cin >> n >> h >> r;
		for (ll i = 1; i <= n; i++) fa[i] = i;//并查集初始化
		for (ll i = 1; i <= n; i++) {
			ll x, y, z;
			cin >> x >> y >> z;
			p[i].x = x;
			p[i].y = y;
			p[i].z = z;
			//一个可有可无的特判：如果只有一个，则看他能否到上面也能到下面
			if (n == 1) {
				ll rp = 0;
				if (p[i].z <= r) rp++;
				if (p[i].z >= h - r) rp++;
				if (rp == 2) cout << "Yes\n";
				else cout << "No\n";
			}
			bool flag = 1;//是否第一次连接
			if (p[i].z <= r) down[i] = 1;
			if (p[i].z >= h - r) top[i] = 1;
			//依次遍历之前所有的洞
			for (ll j = 1; j < i; j++) {
				//p就是直线距离，勾股定理求
				double q = sqrt((p[i].x - p[j].x) * (p[i].x - p[j].x) + (p[i].y - p[j].y) * (p[i].y - p[j].y) + (p[i].z - p[j].z) * (p[i].z - p[j].z));
				if (q <= 2 * r) {//可以合并
					ll t1 = fin(i), t2 = fin(j);
					if (flag) {//第一次连接
						flag = 0;
						fa[t1] = t2;
						//根据定义，把自己的信息传递给祖先信息
						if (!top[t2]) top[t2] = top[t1];
						if (!down[t2]) down[t2] = down[t1];
					} else {
						//根据定义，把别人的信息传递给自己祖先信息
						if (!top[t1]) {
							top[t1] = top[t2];
							top[t2] = 0;
						}
						if (!down[t1]) {
							down[t1] = down[t2];
							down[t2] = 0;
						}
						fa[t2] = t1;
					}
					//能到上面和下面
					if (top[t2] && down[t2]) ans++;
				}

			}
		}
		//答案输出
		if (n != 1) {
			if (ans > 0) cout << "Yes\n";
			else cout << "No\n";
		}
	}
	return 0;
}
```

代码较长，理解起来也还行。

---

## 作者：GoldenSTEVE7 (赞：1)

## 题目大意
一块奶酪中有一些洞，视作一个球，若两个球相交或相切，那么 Jerry 可以从中穿过。特别地，如果一个洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进这个洞；如果一个洞与上表面相切或是相交，Jerry 则可以从这个洞跑到奶酪上表面。问这只老鼠是否能从下表面穿到上表面。

## 思路
这题显然可以用 bfs 解决。

我们其实可以把一个个洞看作一个点，上、下表面也看做两个点。如果两个空洞相切或相交，我们就将这两个洞对应的点连边。再判断每个点是否可以到达上表面或下表面，就将这个问题转换为了一个图上的问题，跑遍 bfs 就行了。

那么问题来了，我们如何判断两个球是否相切或相交呢？

我们知道，在二维空间中，可以比较两圆圆心的距离以及两圆的半径和的大小去判断两圆的位置关系。那么类比到三维空间中，只需要比较两球球心的距离以及两球的半径和即可。详细来说，设两圆圆心的坐标分别为 $(x1,y1,z1)$ 和 $(x2,y2,z2)$，半径分别为 $r1,r2$。若 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2} \le r_1 + r_2$，则两圆相切或相交。

最后请大家记住这两句话：
1. 多测不清空，亲人两行泪。
2. 不开 `long long` 见祖宗。（~~不要问我怎么知道的，我愣是在一道题上把这俩问题都犯了~~）

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
struct circle {
    ll x, y, z;
} a[1005];
bool cal(ll r, ll x1, ll y1, ll z1, ll x2, ll y2, ll z2) {
    return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2) <= (r*2)*(2*r);
} //判断两圆是否相切或相交
vector<int> v[1005];
bool vis[1005];
void bfs() //bfs模板
{
	queue<int> q;
	q.push(0);
	vis[0] = 1;
	while(!q.empty())
	{
		int f = q.front();
		q.pop();
		for(int i = 0; i < v[f].size(); i++)
		{
			if(!vis[v[f][i]])
			{
				q.push(v[f][i]);
				vis[v[f][i]] = 1;
			}
		}
	}
}

int main() {
    int T;
    cin >> T;
    while(T--) {
        int n, h, r;
        cin >> n >> h >> r;
        for(int i = 0; i <= 1004; i++) {v[i].clear(); a[i].x = 0, a[i].y = 0, a[i].z = 0; vis[i] = 0;}//清空
        for(int i = 1; i <= n; i++) cin >> a[i].x >> a[i].y >> a[i].z;
        for(int i = 1; i <= n; i++) {
            for(int j = i+1; j <= n; j++) {
                if(cal(r,a[i].x,a[i].y,a[i].z,a[j].x,a[j].y,a[j].z)) {
                    v[i].push_back(j);
                    v[j].push_back(i);
                }
            }
            if(a[i].z <= r) v[0].push_back(i);
            if(h-a[i].z <= r) v[i].push_back(n+1);
            //建图
        }
        bfs();
        if(vis[n+1]) cout << "Yes\n";
        else cout << "No\n";
    }
    return 0;
}
```

---

## 作者：Amoribus (赞：1)

显然这题我们用 bfs 判断答案。

那么我们来考虑一下细节的处理。
- 两个洞如果可达，那么它们的 $\operatorname{dist}\leq 2r$。
- 我们不妨把奶酪的下表面也看做一个 $0$ 号节点，如果一个洞圆心到下表面的距离 $\leq r$，那么这个洞与 $0$ 号节点连通。
- 同样的，奶酪的上表面可以看做 $n+1$ 号节点，如果一个洞圆心的到上表面的距离 $\leq r$，那么这个洞与 $n+1$ 号节点连通。

先预处理每个节点之间的连通性，然后我们从 $0$ 号节点开始广搜，看能不能到达 $n+1$ 号节点就可以了。

时间复杂度 $O(n^2)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int T,n,h,r,flag=0;
vector<int> dis[1009];
queue<int> q;
int vis[1009];
void bfs(int st){
	while(!q.empty()) q.pop();
	memset(vis,0,sizeof(vis));
	vis[st]=1;
	q.push(st);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=0;i<dis[u].size();i++){
			int v=dis[u][i];
			if(vis[v]) continue;
			if(v==n+1){
				flag=1;
				return;
			}
			vis[v]=1;
			q.push(v);
		}
	}
}
int x[1009],y[1009],z[1009];
double dist(int i,int j){
	return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])+(z[i]-z[j])*(z[i]-z[j]));
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0); 
	cin>>T;
	while(T--){
		flag=0;
		memset(x,0,sizeof(x));
		memset(y,0,sizeof(y));
		memset(z,0,sizeof(z));
		cin>>n>>h>>r;
		for(int i=0;i<=n+1;i++){
			while(dis[i].size()) dis[i].pop_back();
		}
		for(int i=1;i<=n;i++){
			cin>>x[i]>>y[i]>>z[i];
			if(z[i]<=r) dis[i].push_back(0),dis[0].push_back(i);
			if(h-z[i]<=r) dis[n+1].push_back(i),dis[i].push_back(n+1);
		}
		for(int i=1;i<=n;i++){
			for(int j=i+1;j<=n;j++){
				if(dist(i,j)<=r*2){
					dis[j].push_back(i),dis[i].push_back(j);
				}
			}
		}
		bfs(0); 
		if(flag) cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
	return 0;
}
```

---

## 作者：FastIO_DP (赞：0)

### 题目理解

有一块大奶酪，高度为 $ h $，奶酪中有很多半径相同的球形空洞。Jerry 位于奶酪的下表面，它想知道是否可以通过这些空洞跑到奶酪的上表面。如果两个空洞相切或相交，Jerry 就可以从一个空洞跑到另一个空洞。

注意了，如果一个空洞与下表面相切或相交，Jerry 可以从下表面进入这个空洞；如果一个空洞与上表面相切或相交，Jerry 可以从这个空洞跑到上表面。

### 解题思路

现在来确定 Jerry 是否可以从下表面跑到上表面。

可以考虑将每个空洞视为一个节点，如果两个空洞相交或相切，则连接它们之间的一条边。

但是还需要考虑空洞与上下表面之间的关系，如果空洞与下表面相交或相切，我们认为它与下表面相连。

如果空洞与上表面相交或相切，我们认为它与上表面相连。

这样，就是一个图论题了，问题就转化为是否存在一条从下表面到上表面的路径。

### 实现思路

考虑并查集。

我们为每个空洞分配一个编号，并初始化并查集。

并且，我们还需要两个特殊节点（下表面和上表面）。

如果某个空洞与上（下）表面相交或相切，就将这个空洞与上（下）表面节点合并。

然后遍历每个空洞，如果它们相交或相切，就将它们合并。

最后，我们只需要判断下表面和上表面是否在同一个集合中就说明 Jerry 可以从下表面跑到上表面，也就 ok 了。

### 代码实现

    #include <bits/stdc++.h>
    using namespace std;
    
    const int MAXN = 1010;
    int fa[MAXN];
    
    struct Ball {
        int x, y, z;
    } ball[MAXN];
    int n, h, r;
    
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {
        fa[find(x)] = find(y);
    }
    double dist(Ball a, Ball b) {
        return sqrt(pow(a.x-b.x, 2) + pow(a.y-b.y, 2) + pow(a.z-b.z, 2));
    }
    bool check(Ball a, Ball b) {
        return dist(a, b) <= 2.0 * r;
    }
    void solve() {
        for (int i = 0; i <= n+1; i++) fa[i] = i;
    
        for (int i = 0; i < n; i++) {
            // 与下表面连通
            if (ball[i].z <= r)
                merge(i, n);
    
            // 与上表面连通  
            if (ball[i].z + r >= h)
                merge(i, n+1);
    
            // 球间连通
            for (int j = 0; j < i; j++) {
                if (check(ball[i], ball[j]))
                    merge(i, j);
            }
        }
        // 判断是否可达
        puts(find(n) == find(n+1) ? "Yes" : "No");
    }
    int main() {
        int T;
        scanf("%d", &T);
        while (T--) {
            scanf("%d%d%d", &n, &h, &r);
            for (int i = 0; i < n; i++) 
                scanf("%d%d%d", &ball[i].x, &ball[i].y, &ball[i].z);
            solve();
        }
        return 0;
    }

### 复杂度分析

* 时间复杂度：$O(n^2)$。
  
  * 遍历数组 $ball$ 和 判断球间联通 复杂度为 $O(n^2)$。
    
  * 并查集复杂度为 $O(n)$。
    
* 空间复杂度：$O(n)$。
  
  * $fa$ 数组为 $O(n)$ 复杂度。
    
  * $ball$ 数组为 $O(n)$ 复杂度。
    
  * 其他变量 $(n,h,r,...)$ 为 $O(1)$ 复杂度。

---

## 作者：Yi_chen123 (赞：0)

## 前置知识

判断两个三维球是否相切或相交，只需要两个球的坐标 $P_1(x_1,y_1,z_1),P_2(x_2,y_2,z_2)$ 与半径 $r_1,r_2$ 满足：

$$
\sqrt{(x_1 - x_2)^2+(y_1 - y_2)^2+(z_1 - z_2)^2} \le r_1+r_2
$$

即可。

## 思路

才学并查集~~没几个月~~的我，立马想到了使用并查集的解法。\
一、定义两个容器（集合）$A,B$，在输入时分别存储可以到达下方和上方的空洞编号。\
二、再结合一下并查集，枚举每一对空洞 $P_i,P_j$，判断两个球是否相切或相交，如果相切或相交，将两个球合并至同一集合。\
三、枚举每一个满足 $i \in A,j \in B$ 的两个分别在上下两端的空洞 $P_i,P_j$，判断两个空洞是否处于同一个并查集的集合中，如果是，那么就跳出循环，否则继续枚举，直到两个容器被枚举（遍历）完或者找到了处于同一个集合的两个空洞。\
四、根据判断情况，进行输出即可。\
**特别注意：请一定开 long long，并且在下一个测试点即将被读入时清空所有数组。**

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

struct Ball{
	int x, y, z; //球的坐标
};
Ball ball[1005];
int ft[1005]; //并查集

double dist(Ball b1, Ball b2){ //计算球心的距离
	return sqrt(pow(b1.x - b2.x, 2) + pow(b1.y - b2.y, 2) + pow(b1.z - b2.z, 2));
}
bool check(Ball b1, Ball b2, int r){ //判断两球是否相交或相切
	return dist(b1, b2) <= 2 * r;
}

int findroot(int n){ //找根函数
	int ans = n;
    while(ans != ft[ans]){
        ans = ft[ans];
    }
    return ft[n] = ans;
}
void merge(int n, int m){ //合并函数
	int rn = findroot(n), rm = findroot(m);
    ft[rn] = rm;
}
signed main(){
	int t;
	cin >> t;
	while(t > 0){
		memset(ball, 0, sizeof(ball)); //清空！一定要清空！
        int n, h, r;
        cin >> n >> h >> r;
        for(int i = 1; i <= n; ++i){
            ft[i] = i;
		}
        vector<int> top; //在顶端的空洞
        vector<int> und; //在底端的空洞
        for(int i = 1; i <= n; ++i){
        	cin >> ball[i].x >> ball[i].y >> ball[i].z;
            //检测是否在奶酪的上下两端
        	if(ball[i].z + r >= h) top.push_back(i);
        	if(ball[i].z - r <= 0) und.push_back(i);
		}
		
		for(int i = 1; i <= n; ++i){
			for(int j = 1; j < i; ++j){
				if(check(ball[i], ball[j], r)){
					merge(i, j); //如果两空洞相切或相交，合并两个空洞
				}
			}
		}
		bool b = false;
        for(int i = 0; i < top.size(); ++i){
        	for(int j = 0; j < und.size(); ++j){
        		if(findroot(top[i]) == findroot(und[j])){ //枚举查找两个相通并且分别位于上下两端的空洞
        			b = true;
        			break;
				}
			}
		}
		cout << (b ? "Yes" : "No") << endl;
		--t;
	}
	return 0;
}
```

---

## 作者：__ATRI__ (赞：0)

考虑搜索。

将空洞按照纵坐标排序，与下表面相切的点进行搜索，搜索过的点进行标记。如果以后再次搜到已经搜过的点，说明该点无法到达上表面。

每搜到一个点就判断与其他空洞是否相切或相交，然后接着搜。注意两个球相切或相交的判定是球心与球心距离小于等于两个球半径之和。

code： 

```cpp
#include <bits/stdc++.h>
#define endl '\n'

using namespace std;

using ll = long long;

const ll N = 1005;

int n;
double h, r;
bool vis[N], f;// vis为标记数组，f表示是否找到答案
struct node {
	ll x, y, z;
} a[N];

bool cmp(node a, node b) {
	return a.z < b.z;
}

// 距离公式
double dis(node a, node b) {
	return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) + (a.z - b.z) * (a.z - b.z));
}

void init() {}

void dfs(int now) {
	if (a[now].z + r >= h) {
		f = 1;// 如果与上表面相交就标记可行并返回
		return;
	}
	if (f) return;// 如果已经找到可行方案就返回
	vis[now] = 1;// 标记这个点已经走过
	for (int i = 1; i <= n; ++i) {
		if (!vis[i] && dis(a[now], a[i]) <= r * 2) dfs(i);// 如果相切或相交就进行搜索。注意已经标记过的不用再搜
		if (f) return;// 如果已经找到可行方案就返回
	}
}

void solve() {
	memset(vis, 0, sizeof vis);
	f = 0;
	cin >> n >> h >> r;
	for (int i = 1; i <= n; ++i) cin >> a[i].x >> a[i].y >> a[i].z;
	sort(a + 1, a + n + 1, cmp);// 按纵坐标升序排序，方便剪枝
	for (int i = 1; i <= n; ++i) {
		if (a[i].z - r > 0) break;// 已经经过排序，所以可以进行剪枝。若当前空洞与下表面相离那么该空洞就无法进行搜索
		if (!vis[i]) dfs(i);
	}
	cout << (f ? "Yes" : "No") << endl;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	int _ = 1;
	cin >> _;
	init();
	while (_--) solve();
	return 0;
}
```

---

## 作者：sieve (赞：0)

## 题解：[P3958](https://www.luogu.com.cn/problem/P3958)

## 思路

并查集模板题啊！

如果输入的 $z \le r$，就合并 $0 , i$，如果 $z + r \ge h$，就合并 $n + 1 , i$。因为这两个是可以直接到达。

然后任意找两个不同的洞，如果它们相交或相切，则也合并。

最后看 $0$ 和 $n + 1$ 是不是同一个根节点，也就是是否连通。如果是，输出 `Yes`，否则输出 `No`。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1000005;
int n,h,r;
int fa[N];
int x[N],y[N],z[N];
int find(int x)
{
	if(fa[x]==x)
	{
		return x;
	}
	return fa[x]=find(fa[x]);
}
void uni(int x,int y)
{
	x=find(x),y=find(y);
	if(x!=y)
	{
		fa[x]=y;
	}
	return;
}
double f(int xa,int ya,int za,int xb,int yb,int zb)
{
	return sqrt((xa-xb)*(xa-xb)+(ya-yb)*(ya-yb)+(za-zb)*(za-zb));
}
struct no{
	int x,y,z;
}a[N];
void solve()
{
	cin>>n>>h>>r;
	for(int i=0;i<=n+1;++i) fa[i]=i;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i].x>>a[i].y>>a[i].z;
		if(a[i].z<=r)
		{
			uni(0,i);
		}
		if(a[i].z+r>=h)
		{
			uni(n+1,i);
		}
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=i+1;j<=n;++j)
		{
			if(f(a[i].x,a[i].y,a[i].z,a[j].x,a[j].y,a[j].z)<=r+r)
			{
				uni(i,j);
			}
		}
	}
	if(find(0)==find(n+1)) cout<<"Yes\n";
	else cout<<"No\n";
	return;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	while(T--) solve();
	return 0;
}
```

---


# 三去矩阵

## 题目背景

无

## 题目描述

现在小Y有个$l \times l$的正方形字母矩阵，现在他想进行$q$次询问，每次询问最长的以$(x_i,y_i)$为中心的在一条水平或竖直的直线上的回文串的长度。

## 说明/提示

对于$20\%$的数据，$1 \le l \le 2$

另有$20\%$的数据，$q = 1$

另有$20\%$的数据，字母矩阵中心对称，上下对称，左右对称且对角线对称。

对于$100\%$的数据，$1 \le l,q \le 2000$，字母只有小写字母。

## 样例 #1

### 输入

```
5 5
abcba
bcdcb
cdedc
bcdcb
abcba
1 1
1 2
1 3
2 3
3 3```

### 输出

```
1
1
5
5
5
```

# 题解

## 作者：冬瓜皮 (赞：18)

蒟蒻第一次发题解，有点小紧张。

本题~~题设简洁，解法优雅，思路清新，数据怡人，~~是一道水题

只要把该考虑的情况考虑清楚，就可以AC，代码实现难度比较低
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int l,q;    //题意
int ans;
char a[2002][2002]; //表示矩阵
int cross(int x,int y){ //计算横向
    int length=1;
    if(x==1||x==l)  return 1;   //在边界退出
    for(int i=1;;i++){
        if(x-i==0||x+i==l+1)    return length;  //到边界退出
        else if(a[x-i][y]!=a[x+i][y])   return length;  //不相等退出
        else length+=2; //相等继续
    }
}
int down(int x,int y){  //计算纵向，同理
    int length=1;
    if(y==1||y==l)  return 1;
    for(int i=1;;i++){
        if(y-i==0||y+i==l+1)    return length;
        else if(a[x][y-i]!=a[x][y+i])   return length;
        else length+=2;
    }
}
int MAXN(int a,int b){	//比较函数
    if(a>=b)    return a;
    else return b;
}
int main(){
    cin>>l>>q;
    for(int i=1;i<=l;i++){  //读入
        for(int j=1;j<=l;j++){
            cin >> a[i][j]; 
        }
    }
    for(int i=0;i<=q;i++){   //计算
        int x,y;
        cin>>x>>y;
        ans=MAXN(cross(x,y),down(x,y));
        cout<<ans;
        if(i!=q)cout<<endl;
    }
    return 0;
}
```

465ms/4548kb

对了，我保证你复制粘贴这个题解会爆零。

我在main里耍了一点点小小的手段，但是只要你认真通读代码一定能知道该怎么改动

花絮：这是我第一次提交时候的结果：[谁持彩练当空舞？](https://cdn.luogu.com.cn/upload/pic/34110.png)

然后发到讨论版，神犇 @Sai_0511 在一番测试后指出了我的问题：

第一次我交的时候上文的cin>>a[i][j]用的是getchar().

这位大佬回复了我提的每一个问题，在此表示致谢，NOIP2018一起Score+=600吧！

---

## 作者：CT_Res (赞：11)

#### 第一篇月赛题解,不足之处，多多包涵

~~代码有点长~~

~~这道题明明是橙题难度，却给了黄题?~~

1. 首先我们读入$ch$字符数组
2. 预处理$ch$数组
3. 读入$x,y$, 输出$f[x][y]$

---
具体&重要的一个点

**Step 2:**

两层循环枚举所有的$f[x][y]$

```
//核心代码
int a1=1,a2=1;
for(int k=1;k<=l;k++)
	if(ch[i][j+k]==ch[i][j-k] and j+k<=l and j-k>=1) 
		a1+=2;
	else break;
for(int k=1;k<=l;k++)
    if(ch[i+k][j]==ch[i-k][j] and i+k<=l and i-k>=1) 
    	a2+=2;
    else break;
    f[i][j]=max(a1,a2);
        
 ```



再两次循环以$ch[x][y]$为中心的回文串

取最大值存入$f[x][y]$中


```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[2001][2001];
int f[2001][2001];
int main()
{
    int l,q;
    cin>>l>>q;
    getchar();
    for(int i=1;i<=l;i++,getchar())
        for(int j=1;j<=l;j++)
        ch[i][j]=getchar();
     for(int i=1;i<=l;i++)
        for(int j=1;j<=l;j++)
        {
        	int a1=1,a2=1;
        	for(int k=1;k<=l;k++)
        	if(ch[i][j+k]==ch[i][j-k] and j+k<=l and j-k>=1) a1+=2;
        	else break;
        	for(int k=1;k<=l;k++)
        	if(ch[i+k][j]==ch[i-k][j] and i+k<=l and i-k>=1) a2+=2;
        	else break;
        	f[i][j]=max(a1,a2);
		}
	
	for(int i=1;i<=q;i++)
	{
		int x,y;
		cin>>x>>y;
		cout<<f[x][y]<<endl;
	}
}
```

---

## 作者：Clear_yu (赞：8)

## 暴力出奇迹
#### 题目清晰，题意明确，~~是上好的水题~~
##### 开始的时候想写dfs，写着写着就成暴力了
##### 数据不大，非常适合暴力（暴力nb！）


### 直接上代码

```c
#include<iostream>
#include<cstring>
using namespace std;
char map[2001][2001];//l*l矩阵 
int ans[2001];
int l,q;//开全局变量以便边界判断 
int dfs(int a,int b)//不知不觉深搜写成了暴力(awsl)
{
	int sum1=1,sum2=1;
	int x1=a-1,x2=a+1,y1=b-1,y2=b+1;//横向扩展左右 ；纵向扩展上下 
	while(x1>=1&&x2<=l)//计算横向 
	{
		if(map[x1][b]==map[x2][b]) {sum1+=2;x1--;x2++;}
		else break;
	}
	while(y1>=1&&y2<=l)//计算纵向 
	{
		if(map[a][y1]==map[a][y2]) {sum2+=2;y1--;y2++;}
		else break;
	}
	if(sum1>sum2) return sum1;//比较横纵向回文串长度 
	return sum2;
}
int main()
{
	cin>>l>>q;//正常的输入 
	for(int i=1;i<=l;i++)
	  for(int j=1;j<=l;j++)
	  cin>>map[i][j];//平凡无奇de输入 
	for(int i=1;i<=q;i++)
	{
		int a,b;
		cin>>a>>b;
		ans[i]=dfs(a,b);
	}
	for(int i=1;i<=q;i++)
	cout<<ans[i]<<endl;
	return 0;//华丽谢幕 
}
```
#### 这里就不设反作弊了，洛谷的OIer还是很自觉的
##### 觉得不错就点个赞吧！

---

## 作者：Jasonggg15 (赞：4)

**小蒟蒻的第一篇题解，不足之处望大佬们包容指点**

本题题意清晰，就是一道简单的模拟。思路是：以每一次询问给出的坐标为中心，分横纵两种情况，向左右（上下）延伸并判断是否回文，分别计数再输出两种情况中回文串长度大的即可。

奉上代码：
```cpp
#include<iostream>

using namespace std;
int l,q;
char map[2005][2005];
int main()
{
	cin>>l>>q;
	for(int i=1;i<=l;i++)
		for(int k=1;k<=l;k++) cin>>map[i][k];	
	for(int i=1;i<=q;i++)
	{
		int x,y,sum1=1,sum2=1;//sum1,sum2分别表示横向和纵向所能组成的回文串的长度 
		cin>>x>>y; 
		for(int k=1;k<=l;k++)//横向 
		{
			if(sum1==l) break;
			if(map[x][y+k]==map[x][y-k]) sum1+=2;//左右是相同字母,回文串长度+2 
			else break;//左右不是相同字母，结束查找
		}
		for(int k=1;k<=l;k++)//纵向 
		{
			if(sum2==l) break;
			if(map[x+k][y]==map[x-k][y]) sum2+=2;//上下是相同字母,回文串长度+2 
			else break;//上下不是相同字母，结束查找 
		}
		cout<<max(sum1,sum2)<<endl;//输出较大的回文串长度 
	}
	return 0;
}
```
其中要注意sum1，sum2的初值为1（至少也有给出坐标的那个字母）

而if(sum1==l) break;和if(sum2==l) break; 是为了防止找到边缘后继续比对下去导致错误（回文串的长度不可能超过矩阵的边长l）

本题只要注意一下细节便能AC，是难不住大佬们的

~~洛谷给过啊啊啊~~

---

## 作者：Rbrq (赞：4)

这么水的题居然没有人发题解，那就来水一波

安利一下自己的blog，大家可以互相学习
------------

本题就是一个非常简单的模拟题，对于每一个询问，先算出回文串最大可能长度，然后暴力比较是否回文，一旦找到不同的就停止搜索，输出现在的长度*2+1（该坐标的数需要计算)。即可找出答案

附ac代码（请勿抄袭）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=2010;
int  l,q,x,y,d,maxn;
int num[Maxn][Maxn];
int main(){
	scanf("%d %d",&l,&q);
	for(int i=1;i<=l;++i){
		char s[Maxn];
		for(int j=1;j<=l;++j){
		   cin>>s[j];
		   num[i][j]=s[j]-'a'+1;
		}
    }
    while(q--){
      maxn=0;
      scanf("%d %d",&x,&y);
      int dx=min(x-1,l-x);
      int dy=min(y-1,l-y);
      int i;
      for(i=1;i<=dx;i++)
        if(num[x-i][y]!=num[x+i][y])
          break;
       maxn=max(2*i-1,maxn);
       for(i=1;i<=dy;i++)
         if(num[x][y-i]!=num[x][y+i])
           break;
       maxn=max(2*i-1,maxn);
      printf("%d\n",maxn);
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

就是在判断回文串的基础上加了矩阵嘛……

对于每次操作，横着算一遍，竖着算一遍，输出两者中的最大值。

其实也没啥好写的，为了避免说明过少，还是讲一遍吧……

- 如何计算以$a_{x,y}$ 为中心的回文串长度


地球人都知道，回文串正着读倒着读都一样，所以如果$a_{i}$ 为中心，回文串长度为$m$ ，则$a_1\sim a_{i-1}=a_m\sim a_{i+1} $ 。那么，用两个while循环就行了，一个横着，一个竖着，实现的方法就很容易想到，保证行/列不变，逐一判断即可。

- 初始化


$ans$ 应该为$1$ ，这一点需要注意。

这就上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[2001][2001];
int n,m,x,y;
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=n; ++j) cin>>a[i][j];
    while(m--) {
        scanf("%d%d",&x,&y);
        int l=y-1,r=y+1,ans(1);//初始化
        while(l>=1&&r<=n) {//边界
            if(a[x][l]!=a[x][r]) break;//若不满足回文串的特征，打断
            --l,++r,ans+=2;//继续循环
        }
        int ll=x-1,rr=x+1,anss(1);
        while(ll>=1&&rr<=n) {
            if(a[ll][y]!=a[rr][y]) break;
            --ll,++rr,anss+=2;
        }
        ans>anss?printf("%d\n",ans):printf("%d\n",anss);//取最大值
    }
    return 0;
}
```

---

## 作者：HatsuneMiku (赞：2)

~~先吐槽一下这真的是道黄题么~~

~~感觉模拟题模板的样子……~~

由于本人太过蒟蒻

所以本题解可能是最简单的做法QWQ

~~以下小白做法~~

个人想法是把询问点一次使用两遍

（也就是一次搜索（暂时这么叫吧）两次该点（x，y）为（x1，y1），（x2，y2）

一次分别向左和向右遍历，途中对所到点的值进行比较，如果所到点值不相等或有一点到达矩阵边界则退出，得到回文串长度ans1

一次分别向上和向下遍历，原理同上，得到ans2

然后将ans1与ans2比较，返回较大值

大概……也就这样(~~真的是只有蒟蒻才能想出来的蒟蒻算法……~~

上代码~~巨佬请无视~~

```
#include<bits/stdc++.h>
using namespace std;
int l,q,xi,yi;
char a[2050][2050];//数组一定大于2000!!! 
int b[2050][2050],ans1=1,ans2=1,ans; //ans1，ans2最小长度为1（就是不能拓展长度 
//水平跟竖直方向比较（我也不知道为什么必须用ans转一下才能返回正确值 
bool cmp(int x,int y){
	if(x>y) {
	ans=x;
	return ans;}
	else {
		ans=y;
		return y;
	}
}
//左右查找 
void dfs1(int x1,int y1,int x2,int y2){
	if(yi==0||y2==l) return ;//到达边界就退出 
	int left=b[x1][y1-1],right=b[x2][y2+1];//left向左移动的值，right向右移动的值 
	if(left!=right)return;//左右不相等退出 
	//左右相等
	if(left==right){
		ans1+=2;//ans=当前长度+左长度（=1）+右长度（=1） 
		dfs1(x1,y1-1,x2,y2+1);//继续查找		
		}
	}
//上下查找
void dfs2(int x1,int y1,int x2,int y2){
	if(x1==0||x2==l) return ;//到达边界就退出 
	int up=b[x1-1][y1],down=b[x2+1][y2];//up向上，down向下 
	if(up!=down) return;//上下不等退出 
	//上下相等 
	if(up==down){
		ans2+=2;//ans=当前长度+上长度（=1）+下长度（=1）
		dfs2(x1-1,y1,x2+1,y2);//继续查找 
	}
} 
int main(){
	cin>>l>>q;//输入矩阵的边长和询问的个数。
	for(int i=1;i<=l;i++){
		for(int j=1;j<=l;j++){
			cin>>a[i][j];//输入矩阵上的字母 
			b[i][j]=a[i][j]-'0';//获取该位置数字（但貌似可以不用 
		}
	}
	//q行询问 
	for(int i=1;i<=q;i++){
		cin>>xi>>yi;//询问点 
		dfs1(xi,yi,xi,yi);//（暂时叫搜索）遍历左右 
		dfs2(xi,yi,xi,yi);//（暂时叫搜索）遍历上下 
		cmp(ans1,ans2);//比较最长回文串长度 
		cout<<ans;//输出 
		cout<<endl;//换行 
		ans1=1,ans2=1;//重置ans（虽然不知道有没有用                                 	
	}
	return 0;//拜拜甜甜圈珍珠奶茶方便面 
}

```

---

## 作者：Akoasm (赞：2)

啊啊...
当看到这个比赛的时候已经没时间了（其实也有点懒得写），随便水了一个分。

一遍AC了T1...（再AC不了怎么去考提高？？）

好吧说说思路：
暴力就可以，我们对于每一个中心，横着构造一个序列，竖着也来一个，比较就可以了。
注意的就是...（我也没错过不知道有啥注意的）应该判一下边界情况...
```c++
#include <bits/stdc++.h>
using namespace std;
inline int read() {
	int q=0,f=1;char ch = getchar();
	while(!isdigit(ch)) {
		if(ch=='-')f=-1;ch=getchar();
	}
	while(isdigit(ch)){
		q=q*10+ch-'0';ch=getchar();
	}
	return q*f;
}

char a[2010][2010];
char s[2010];

int cnt;
int mx = -1;
int main () {
	int n = read();
	int m = read();
	for(int i = 1;i <= n; ++i) {
		scanf("%s",s+1);
		int len = strlen(s + 1);
		for(int j = 1;j <= len; ++j) {
			a[i][j] = s[j];
		}
	}
	while(m--) {
		int l = read(), r = read();
		char sss[2010];
		char ss[2010];
		cnt = 1;
		bool tag1 = 0;
		bool tag2 = 0;
		int tot1 = 0;
		int tot2 = 0;
		if(l - 1 < 1 || l + 1 > n) tag1 = 1;
		if(r - 1 < 1 || r + 1 > n) tag2 = 1;
		if(!tag1) {
			for(int i = l - 1;i >= 1; --i) {
				ss[++tot1] = a[i][r];
			}
			for(int i = l + 1;i <= n; ++i) {
				sss[++tot2] = a[i][r];
			}
			for(int i = 1;i <= min(tot1,tot2); ++i) {
				if(ss[i] != sss[i]) break;
				else cnt ++;
			}
			mx = max(cnt + cnt - 1,mx);
		}
		else {
			cnt = 1;
			mx = max(cnt,mx);
		}
		cnt = 1;
		tot1 = 0;
		tot2 = 0;
		if(!tag2) {
			for(int i = r - 1;i >= 1; --i) {
				ss[++tot1] = a[l][i];
			}
			for(int i = r + 1;i <= n; ++i) {
				sss[++tot2] = a[l][i];
			}
			for(int i = 1;i <= min(tot1,tot2); ++i) {
				if(ss[i] != sss[i]) break;
				else cnt ++;
			}
			mx = max(mx,cnt + cnt - 1);
		}
		else cnt = 1,mx = max(mx,cnt);
		printf("%d\n",mx);
		mx = -1;
	}
	return 0;
}
```

---

## 作者：散华礼弥 (赞：2)

看题解里没有Manacher就放上来了~~估计没有人在考场上跟我一样弱智地做了2n次Manacher？？？~~

Manacher的做法和模拟是一样的时间复杂度，但是我的复杂度集中在预处理上，是$O(n^2)$的，而每次询问是$O(1)$，的，应该算是个比较不错的离线算法

Manacher的原理相信大家都知道的，我就直接放代码了~~就算不知道网上也有很好的解释，我就不口胡了~~

~~sb~~代码如下

```cpp
#include <cstdio>
#include <algorithm>

int n, m, p[4010][4010], len;
char s[4010][2010], str[4010];

void Init(int x)
{
	str[0] = str[1] = '#';
	for (int i = 0; i < n; ++i)
	{
		str[(i << 1) + 2] = s[x][i];
		str[(i << 1) + 3] = '#';
	}
}

void Manacher(int x)
{
	Init(x);
	int right = 0, cur;
	for (int i = 1; i < len; ++i)
	{
		if (i < right)
			p[x][i] = std::min(p[x][(cur << 1) - i], p[x][cur] + cur - i);
		else
			p[x][i] = 1;
		while (str[i + p[x][i]] == str[i - p[x][i]])
			++p[x][i];
		if (p[x][i] + i > right)
		{
			cur = i;
			right = p[x][i] + i;
		}
	}
}

int main()
{
	int x, y;
	scanf("%d%d", &n, &m);
	len = n * 2 + 2;
	for (int i = 1; i <= n; ++i)
	{
		scanf("%s", s[i]);
		for (int j = 1; j <= n; ++j)
			s[j + n][i - 1] = s[i][j - 1];
	}
	for (int i = 1; i <= n << 1; ++i)
		Manacher(i);
	while (m--)
	{
		scanf("%d%d", &x, &y);
		printf("%d\n", std::max(p[x][y << 1] - 1, p[y + n][x << 1] - 1));
	}
	return 0;
}
```

---

## 作者：sunrise (赞：1)

用指针申请动态一维数组，当成二维数组来用，应该能节省一点内存吧（猜的 ）！

```cpp
#include<iostream>
using namespace std;
int a[2001];		//存回文的长度
int main()
{
	int l, q, k = 0;
	char *p = 0;		//定义指向字符数组的指针
	cin >> l >> q;
	p = new char[l*l+1];	//申请数组由于L阶的所以要申请lxl+1个（+1是为了从1开始存）
	for(int i = 1; i <= l*l; i++)
		cin >> p[i];	//二维数组的输入（只不过这里线性输入了）
	int x, y;	//定义回文中心的坐标
	for(int i = 0; i < q; i++)
	{
		int flag1 = 1, flag2 = 1;	//控制行列的标志变量
		cin >> x >> y;
		int h = 1, lie = 1;
		while(1)	//检测行和列上的回文串 半长+1（h，lie）
		{
			if(flag1 == 0 && flag2 == 0)
				break;			//当检测完行和列跳出循环
			if(flag1)	//这里检测列
            //边界检测 和 以中心点字母展开比较是否相等（即是否为回文）
            //这里p[(x-1)*l +1]即表示坐标二维矩阵中的(x,1)
				if(x + h - 1 <= (l -1) && x - h - 1 >= 0 && p[(x + h -1)*l + y] == p[(x - h -1)*l + y] )
					h++;
				else
					flag1 = 0;
			if(flag2)		//这里检测行
            	//此处作用和上述相似
				if(y + lie <= l && y - lie > 0 && p[(x - 1)*l + (y - lie)] == p[(x - 1)*l + (y + lie)] )
					lie++;
				else
					flag2 = 0;	
		}
		if(lie >= h)	//找出最大回文长度，并存储
			a[k++] = 2*lie -1;
		else
			a[k++] = 2*h -1;
	}
	for(int i = 0; i < k; i++)
		cout << a[i] << endl;	//输出
	return 0;
}
```

附：个人博客和github欢迎留言互相交流学习。。。。。
blog：https://www.cnblogs.com/sunrisepeak/
GitHub：https://github.com/Sunrisepeak

---

## 作者：Viston (赞：1)

模拟秒杀    
数据范围是可以$O(l*q)$水过的，于是放心模拟   
枚举回文串的左右（除了中间点）的长度    
再判断     
最后输出即可     
```
#include<bits/stdc++.h>
using namespace std;
int a,b,i,j,ans,c,d;
char e[2002][2002];   //数组
int main(){
	ios::sync_with_stdio(false);
	cin>>a>>b;           //输入
	for(i=1;i<=a;i++)
		for(j=1;j<=a;j++)
			cin>>e[i][j];        //输入
	for(i=1;i<=b;i++){
		cin>>c>>d;int ans1=1,ans2=1;bool d1=0,d2=0;
		for(j=1;j<=min(c-1,a-c);j++){
			if(e[c+j][d]==e[c-j][d]&&!d2)ans1+=2;
				else d2=1;
			/*if(e[c][d-j]==e[c][d+j]&&!d1)ans2+=2;
				else d1=1;*/
			if(/*d1==1&&*/d2==1)break;      //这是看横向的子串
		}
		for(j=1;j<=min(d-1,a-d);j++){
			if(e[c][d-j]==e[c][d+j]&&!d1)ans2+=2;
				else d1=1;
			if(d1==1) break;         //这是看纵向的子串
		}
		cout<<max(ans1,ans2)<<'\n';       //输出最大值
	}
}
```

---

## 作者：淼淼 (赞：1)

~~看没人发题解赶紧水一篇~~

一道纯模拟题，只需要按照题意做即可

这道题的重点就是一个判断回文，只需用循环分别判断矩阵的行和列，如果相等，那么回文长度，**注意长度加2而不是加1**。如果不等或判断的范围出了界，那么我们就退出循环。

判断回文的程序如下：

```cpp
int f(int xx,int yy)
{
	int i,sh=1,sl=1;//回文长度设为1而不是0,突然感觉这题小坑有点多
    //分行和列分别判断，结果取最大值
	i=1;
	while(xx-i>=0&&xx+i<l)//如果出界，就退出循环
	{
			if(a[xx-i][yy]==a[xx+i][yy])sh+=2;//如果左右数值一致（也就是回文）长度加2。
			else break;//同时，如果不相等，退出循环
			i++;
	}
	i=1;
    //同上，判断y坐标
	while(yy-i>=0&&yy+i<l)
	{
			if(a[xx][yy-i]==a[xx][yy+i])sl+=2;
			else break;
			i++;
	}
	return max(sh,sl); //输出结果
}

```


---

## 作者：Register (赞：1)

# 模拟！！！
我自己的思路：
	
    对于每一个x和y，都是只用横向和纵向分别枚举模拟的
    我们在每一次模拟需要保证如下事项：
    1.不越界
    2.依次向外扩散、判断是否相等（回文）
    3.别输出时把*2-1弄错了
下面是我的压行代码:
```cpp
#include <iostream>
using namespace std;
char a[2001][2001]; //矩阵
int main(){
	int l,q,x,y;
	cin>>l>>q;//边长、询问次数
	for(int i=1;i<=l;i++)
		for(int j=1;j<=l;j++) cin>>a[i][j];
	while(q--)//q次询问
	{	
		cin>>x>>y;
		int maxx=0,maxy=0;//定义横向和纵向的次数
		while(x-maxx>0&&x+maxx<=l&&a[x-maxx][y]==a[x+maxx][y]) maxx++;//向外模拟（枚举）
		while(y-maxy>0&&y+maxy<=l&&a[x][y-maxy]==a[x][y+maxy]) maxy++;//向外模拟（枚举）
		if(maxx>maxy) cout<<maxx*2-1<<endl;//比较、输出
		else cout<<maxy*2-1<<endl;
	}
	return 0;
}
```
~~很好奇这道题竟然是黄题（~~

---

## 作者：lzy755277 (赞：1)

这道题其实很简单：

每输入一对x，y就从左到右搜一遍，再从上到下搜出去，取最大值并输出

```cpp
#include<iostream>
using namespace std;
char a[2001][2001];
int l;
int dfs(int x,int y,int k)
{
	int i,ans=1;
	if(k==1)
	{
		for(i=1;;i++)
		if(a[x][y-i]==a[x][y+i]&&1<=y-i&&y+i<=l)ans+=2;
		else break;//如果不是回文字串，停止
		return ans;
	}//横着搜
	else
	{
		for(i=1;;i++)
		if(a[x-i][y]==a[x+i][y]&&1<=x-i&&x+i<=l)ans+=2;
		else break;//如果不是回文字串，停止
		return ans;
	}//竖着搜
}
int main()
{
	int q,i,j,x,y;
	cin>>l>>q;
	for(i=1;i<=l;i++)
	for(j=1;j<=l;j++)
	cin>>a[i][j];//输入字符矩阵
	while(q--)
	{
		cin>>x>>y;
		cout<<max(dfs(x,y,1),dfs(x,y,2))<<endl;
	}
    return 0;//拜拜程序
}
```

---

## 作者：反比例函数 (赞：0)

~~我是仗着自己代码比较短才决定写题解的~~

看了几篇题解，发现很多dalao竟然用到dfs，奇怪这题不是强行模拟可过吗，而且代码实现也不难，于是开始思考这题为何是黄题 恶评？。

**注意：使用scanf()或getchar()有被卡的危险，C++党如果怕速度慢可以加**`ios::sync_with_stdio(false);`

不多说，上代码（说明在代码中）：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
char c[2010][2010];//字符矩阵
int main()
{
	ios::sync_with_stdio(false);
    int n,q,i,j,x,y,t,r,u,d,ans1,ans2;
    //ans1储存横向最大长度，ans2储存纵向最大长度
    cin>>n>>q;//矩阵行列数均为n，询问次数q
    for(i=1;i<=n;i++)
      for(j=1;j<=n;j++)
        cin>>c[i][j];//输入
    for(i=1;i<=q;i++)
    {   cin>>x>>y;ans1=ans2=1;//最小长度为1（即这个字符它自己）
        t=x-1;r=x+1;//左右搜索
        while(c[t][y]==c[r][y]&&t>0&&r<=n)
        {   ans1+=2;t--;r++;}
        //只要发现左右相同，ans加二，左右向外扩展
        u=y-1;d=y+1;//上下搜索
        while(c[x][u]==c[x][d]&&u>0&&d<=n)
        {   ans2+=2;u--;d++;}//与上面类似
        cout<<max(ans1,ans2)<<endl;}}//输出+结束
```

---

## 作者：HPXXZYY (赞：0)

思路很简单，既然以(x,y)为中心，那我们就以(x,y)为中心进行搜索

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[2010][2010];
int l,r,i,x,y,n,m,j,ans;
bool check(int x,int y){
	return x>0&&x<=n&&y>0&&y<=n;
}
//判断点(x,y)是否“越界”
bool judge(int a1,int b1,int a2,int b2){
	return check(a1,b1)&&check(a2,b2)&&a[a1][b1]==a[a2][b2];
}
//判断回文（判断两个点是否“越界”及两字符是否相等）
int main(){
	cin>>n>>m;
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	cin>>a[i][j];
	for(i=1;i<=m;i++){
		cin>>x>>y;l=r=x;ans=0;
		while (judge(l-1,y,r+1,y)) l--,r++;
        //纵向搜索
		ans=max(r-l+1,ans);l=r=y;
		while (judge(x,l-1,x,r+1)) l--,r++;
        //横向搜索
		ans=max(r-l+1,ans);
		cout<<ans<<endl;//输出结果
	}
	return 0;
}
```


---

## 作者：Misaka19280 (赞：0)

这就是比赛界面中那道传说中的Pj-了

裸的暴力，对于每个坐标直接往上下或左右拓展就OK了

```
Const
	maxl=2000;

Var
	a:array[1..maxl,1..maxl]of char;
	s:ansistring;
	l,q,top,pop,ans,i,j,x,y:longint;
	
Begin
	readln(l,q);
	for i:=1 to l do
		begin
			readln(s);
			for j:=1 to l do
				a[i,j]:=s[j];
		end;
	for i:=1 to q do
		begin
			read(x,y);
			top:=x;
			pop:=x;
			while (top-1>0) and (pop+1<=l) and (a[top-1,y]=a[pop+1,y]) do //上下拓展
				begin
					inc(pop);
					dec(top);
				end;
			ans:=pop-top+1;
			top:=y;
			pop:=y;
			while (top-1>0) and (pop+1<=l) and (a[x,top-1]=a[x,pop+1]) do //左右拓展
				begin
					inc(pop);
					dec(top);
				end;
			if pop-top+1>ans then ans:=pop-top+1;
			writeln(ans);
		end;
End.
```

---

## 作者：绝顶我为峰 (赞：0)

没有题解，赶紧占坑$qwq$
```
#include<iostream>
using namespace std;
int n,q,x,y;
char c[2051][2051];//数组大一点
int main()
{
    cin>>n>>q;
    for(register int i=1;i<=n;i++)
        for(register int j=1;j<=n;j++)
            cin>>c[i][j];
    while(q--)
    {
        cin>>x>>y;
        int l=x,r=x,s,ans;//l左边界，r右边界，s长度，ans保存答案
        while(c[l][y]==c[r][y]&&c[l][y]&&c[r][y])//先计算同一列里的回文（ps：防止越界）
            l--,r++;//继续加长长度
        s=r-l+1;//计算长度
        l=y,r=y,ans=s;//重置和保存答案！我比赛的时候犯的智障错误，不重置只有30分
        while(c[x][l]==c[x][r]&&c[x][l]&&c[x][r])//在计算同一行里的回文（ps：防止越界）
            l--,r++;//加长长度
        s=r-l+1;//计算长度
        cout<<max(ans,s)-2<<endl;//注意！因为while最后会使l,r的值分别多1所以最后要-2输出！！！
    }
    return 0;
}
```

总体就是这样了

---

## 作者：2x6_81 (赞：0)

这题的核心：
### 模拟
他要求你干什么你就干什么呗

---
废话少说，上代码：
```
#include<bits/stdc++.h>//万能头QAQ
using namespace std;
char c[2020][2020];//可能string也可以,反正我用char数组
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);//scanf比cin快
	for(int i=1;i<=n;i++)//读入
	{
		getchar();//去回车(或者j=0也可以,不要getchar())
		for(int j=1;j<=n;j++)
		c[i][j]=getchar();
	}
	int x,y;
	int a,b;
	for(int i=0;i<q;i++)
	{
    	/*-------------------*/
		a=b=0;//或a=b=1,后面就不用++了
		cin>>x>>y;
		for(int i=x+1;i<=n;i++)//模拟
		if(x+x-i<1) break;//若以超边界,退出循环
		else if(c[i][y]!=c[x+x-i][y]) break;//若以不是回文,跳出循环
        //其实可以写一起的QAQ
		else a+=2; //长度+2(回文定是一对)
        a++;//(再加他自己)
        /*-------------------*/
        //同上,这里不再做过多的解释,请读者自行理解
		for(int i=y+1;i<=n;i++)
		if(y+y-i<1) break;
		else if(c[x][i]!=c[x][y+y-i]) break;
		else b+=2; b++;
		b=max(a,b);//判断谁大谁小(是水平的还是垂直的?)
		printf("%d\n",b);//输出(printf比cout快)
        /*-------------------*/
	}
    return 0;//结束
}
```
end.

---

## 作者：master_chedan (赞：0)

第一次发题解，请多多包涵！

月赛的第一题，可以说是相当水的...（虽然手贱样例都有几次没过）

思路非常简单，就是针对每个询问进行回答

~~所以难点在于读数据~~

既然这题这么简单，就直接贴代码吧（含注释）

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
char Map[1001][1001];//调小了数据范围，反抄袭
static int l, q;
int main() {
	scanf("%d%d", &l, &q);
	for (int i = 1; i <= l; i++) {	// 0下标万年不用
		scanf("\n");				//getchar()会读换行符
		for (int j = 1; j <= l; j++)
			Map[i][j] = getchar();	//getchar()比较快
	}
	for (int i = 1; i <= q; i++) {
		int x, y, j;
		int ans = 1;				//长度至少为1
		scanf("%d%d", &x, &y);
		for (j = 1; x - j >= 1 && x + j <= l; j++) {//纵向扫
			if (Map[x - j][y] != Map[x + j][y])//不回文直接退出
				break;
		}
		ans = max(ans, 1 + (2 * (j - 1)));//更大就替换
		for (j = 1; y - j >= 1 && y + j <= l; j++) {//横向扫，思路同上
			if (Map[x][y - j] != Map[x][y + j])
				break;
		}
		ans = max(ans, 1 + (2 * (j - 1)));
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：ACgod (赞：0)

本蒟蒻第一次参加月赛的第一题。。。

个人觉得这题其实没有普及难度吧，可能只有普及-。

其实这题的思路非常明确，就是先统计行上的最大回文串的长度，在统计列上的（或者反过来也可以）。$for$里面套两个$while$就行了。具体在代码实现里细讲，下面上蒟蒻的代码：
```
#include <iostream>
#include <algorithm>//我也不知道max要不要头文件，就先加了，其实万能头就行了
using namespace std;
int q,l;//q,l意思如题
char a[10001][10001];
int main()
{
    cin>>l>>q;//读入
    for(int i=1;i<=l;i++)
    {
        for(int j=1;j<=l;j++)
        {
            cin>>a[i][j];//存图
        }
    }
    for(int i=1;i<=q;i++)
    {
        int x,y//x,y意思如题
        cin>>x>>y;
        int sum=1,ans1=1,ans2=1;//ans1表示行上回文串的最长长度,ans2表示列上的，sum用来判断这个回文串是否回文
        while(x-sum>0&&x+sum<=l)//统计行
        {
            if(a[sum+x][y]!=a[x-sum][y])//只有sum+x=x-sum时，才符合回文串的特性
            {
                break;
            }
            sum++;
            ans1+=2;//因为这里我们是两个两个算的，所以一次要加2
        }
        sum=1;
        while(y-sum>0&&y+sum<=l)//统计列，写法和行一样
        {
            if(a[x][sum+y]!=a[x][y-sum])
            {
                break;
            }
            sum++;
            ans2+=2;
        }
        cout<<max(ans1,ans2)<<endl;//输出二者的最大值
    }
    return 0;//NOIp不写好像是不行的
}
```
以上就是本文的全部了，若果您明白了，请点上一个赞，如果哪里有问题，也欢迎私信！

谢谢大家!

---

## 作者：KagurazakaKano (赞：0)

~~题出的好！覆盖知识点广，题目又着切合实际的背景，解法比较自然。给出题人点赞 ！~~

于是这是一个非常妙的一个暴力题。

```
#include <cstdio>
#include <algorithm>

using namespace std;

char a[2005][2005];  //存储字符

int main(){
	int l,q;
	scanf("%d%d",&l,&q);
	for(int i = 1; i <= l; i++){
		scanf("%s",a[i] + 1);  //这样读入后可以从 1 开始访问，写起来比较方便
	}
	for(int i = 1; i <= q; i++){
		int qq, ww;
		scanf("%d%d",&qq,&ww);
		int cur = 1;
		while(1){
			if(a[qq][ww - cur] == a[qq][ww + cur] && ww - cur >= 1 && ww + cur <= l) {
            //不断从所给定的坐标开始分别向左和右进行匹配
            //如果匹配就增加长度，否则说明到了这一步就无法回文，直接break掉。
            //注意边界
				cur ++;
			} else {
				break;
			}
		}
		int cu = 1;
		while(1){  //同理进行上下匹配
			if(a[qq - cu][ww] == a[qq + cu][ww] && qq - cu >= 1 && qq + cu <= l) {
				cu ++;
			} else {
				break;
			}
		}
		int ans = max(cu - 1, cur - 1);  //注意减一，因为我们刚开始的时候我们都是初始化为 1 的。
		printf("%d\n",ans * 2 + 1);  //结果就是左右分别寻找到到长度加上一个 1。
	}
	return 0;
}
```

---

## 作者：Chiaro (赞：0)

字符串题

对于每个_x,y_只需要横排竖排的扫一遍就可以了

循环一遍i+1,这样x+i,x-i与y+i,y-i只要相同就是回文

(之前找回文的时候下标写反了结果80分好几遍,就是map[x+i][y]写成了map[y][x+i])

上代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
#define sc scanf
char map[2010][2010];
int x,y,ans,q,l;
int max(int a,int b){return a>b?a:b;}//听说手写max能加速
int main(){
	sc("%d%d",&l,&q);
    getchar();//因为要用gets(),所以要处理掉这个换行符
	for(int i=1;i<=l;i++)gets(map[i]+1);
    //gets()读入真的快,map[i]要加一是因为我是从1开始算
	while(q--){
		int now=1,_now=1,i=0;//定义几个需要用的变量,注意一下初始化
        //now与_now初始化要为1因为map[x][y]就是一个长度是1的回文
		sc("%d%d",&x,&y);//读入
		while(++i<=l){
        //开始循环判定竖排(应该是竖排,之前得80分好几遍就是因为这里)
			if(x-i<1||x+i>l)break;//越界就跳出循环
			if(map[x+i][y]==map[x-i][y])now+=2;
            //寻找回文,因为一次就可以找到上下两边,所以是+2
			else break;//不相同就可以跳出了
		}
		i=0;//注意清零
		while(++i<=l){//开始循环横排
			if(y-i<1||y+i>l)break;//同上
			if(map[x][y+i]==map[x][y-i])_now+=2;
            //同上
			else break;
		}
		cout<<max(now,_now)<<'\n';//取最大值输出
	}
	return 0;
}
```
~~(gets()为什么这么快,没有gets()程序跑完400多ms,用了gets()程序跑完只用了41ms)~~

---


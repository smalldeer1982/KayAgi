# 漂浮的鸭子

## 题目描述

下雨时地上会有一个个水坑，但一个水坑只会流向另一个特定的水坑，而且水不会回流。可能会有多个水坑同时流向一个水坑。这天又下起了雨夹鸭，每个水坑里都漂浮着一只鸭子。WYH在每个水坑旁派遣了一个特派员，特派员会在鸭子上做记号。在某一时刻，全部鸭子开始顺水漂浮，同时特派员开始计时。当某个特派员发现他做的那个记号的鸭子漂浮回来的时候，他就会停止计时，把时间上报给WYH。现在WYH探勘了地形后把每段水流的关系与时间告诉了你，他想知道他所获得的所有数据中最大的那个是？


## 说明/提示

30%的数据保证n≤100

100%的数据保证n≤100000


## 样例 #1

### 输入

```
6
2 1
3 2
1 3
5 2
6 2
4 2
```

### 输出

```
6```

# 题解

## 作者：_Atyou (赞：18)

## 算法： 搜索

以题意可知是一个基环树森林， 题目就是要找最大的那个环

分两种情况 ：

1） **处于环上**： 鸭子绕环一周，回到这个点，统计一下总时间，可以更新答案

2） **不处于环上**： 鸭子回不来， 不能更新答案

怎么区分一上两种情况呢？

从一个点出发把经过的点都标记一遍，直到回到一个被标记过的点，如果这个点不是起点，就不处于环上， 如果是起点就处于环上，就可以更新答案

有一个小优化 ：

如果从一个点出发经过了一个处理过的点，就不用再继续往下搜索了，每次处理完一个点用另一个数组标记一下就行了

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register 
const int N = 100000 + 5;

int n, d[N], t[N], a[N], b[N], ans, st;

void dfs(int x, int sum) {
    if (x==st) { ans=max(ans, sum); return; }
    if (a[x] || b[x])return;
    a[x]=1; dfs(d[x], sum+t[x]); a[x]=0;
}

int main() {
    scanf("%d", &n);
    for (reg int i=1; i<=n; ++i) scanf("%d%d", &d[i], &t[i]);
    for (st=1; st<=n; ++st) dfs(d[st], t[st]), b[st]=1;
    printf("%d\n", ans);
    return 0;
}

```


---

## 作者：MoXiaodu (赞：7)

### 题目描述

下雨时地上会有一个个水坑，但一个水坑只会流向另一个特定的水坑，而且水不会回流。可能会有多个水坑同时流向一个水坑。这天又下起了雨夹鸭，每个水坑里都漂浮着一只鸭子。WYH在每个水坑旁派遣了一个特派员，特派员会在鸭子上做记号。在某一时刻，全部鸭子开始顺水漂浮，同时特派员开始计时。当某个特派员发现他做的那个记号的鸭子漂浮回来的时候，他就会停止计时，把时间上报给WYH。现在WYH探勘了地形后把每段水流的关系与时间告诉了你，他想知道他所获得的所有数据中最大的那个是？

### 输入格式

第一行一个正整数n，代表有n个水坑（从1到n编号）

第2~n+1行每行两个正整数，其中第i+1行的两个整数为Di与Ti，代表第i号水坑的水会流向Di号坑，流动所需时间为Ti。保证Di≠i。

### 输出格式

一个整数，代表WYH手上获得的特派员数据中最大的那个数。


------------


看完题目，可以发现，题目所描述的是一个基环树森林，从:

> 当某个特派员发现他做的那个记号的鸭子漂浮回来的时候，他就会停止计时，把时间上报给WYH。

看出，本题求的就是图中的最大环，找环的最朴素做法就是DFS。为了不超时（也就是跳过一些走过的和记录途中经过的环），于是，我们就可以根据本题图的性质在搜索过程中打上标记，使其不会重复查找和及时跳出（具体代码在下面的代码中）

![](https://cdn.luogu.com.cn/upload/image_hosting/7xtbhbis.png)

整体代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,to[100005],t[100005],ans;
//n：题目所给 to：到达点 t:过路时间
int when[100005];//优化搜索过程，记录搜到的时间
bool pd[100005];//判断有没有在搜索过程中找到过
inline int read(){//读入优化
	int f=1,out=0;char c=getchar();
	while (c>'9'||c<'0'){
		if(c=='-'){
			f=-1;
		}
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		out*=10,out+=c-'0';
		c=getchar();
	}
	return f*out;
}
inline void dfs(int now,int num){
	if(when[now]){//如果已经走到过（也就是环）
		ans=max(ans,num-when[now]);
        //用起始时间-最后时间得出答案
		pd[now]=1;//记录，下一次不走
		return;//返回
	}
	when[now]=num;
	dfs(to[now],num+t[now]);
    //往下一个点走
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		to[i]=read(),t[i]=read();
	for(int i=1;i<=n;i++){//一个一个点找
		if(pd[i])continue;//这个点走过，不走
		dfs(i,0);
		memset(when,0,sizeof(when));//记录清空
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：RiverFun (赞：5)

广告时间：

安利[$\tt{BLOG}$](https://stevebraveman.github.io/)

下面我们进入正题：

题目中要求求出最大环，我们可以用tarjan求出强连通分量来解决。

关于边权，我们可以把它转换为点权，然后再在每个强连通分量里进行求和，求出最大的值。

需要注意的一点就是当把边权转换为点权时，不能把边权赋给去的点，要把边权付给这条边的源点。

~~就是因为这个所以我才WA了一次，错失了一遍AC的机会~~

上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define MAXN 1000100
struct Edge {
    int v, nx;
}e[MAXN];
inline int min(int a, int b) {
    if (a < b) return a;
    else return b;
}
inline int max(int a, int b) {
    if (a > b) return a;
    else return b;
}
int head[MAXN], tim, st[MAXN], top, ecnt, n, m, x, y, dfn[MAXN], low[MAXN], in[MAXN], si[MAXN], num, se[MAXN], ans;
bool vis[MAXN];
void add(int f, int t) {
    e[++ecnt] = (Edge) {t, head[f]};
    head[f] = ecnt;
}
void tarjan(int u) {
    dfn[u] = low[u] = ++tim;
    st[++top] = u;
    vis[u] = 1;
    for (int i = head[u]; i; i = e[i].nx) {
        int v = e[i].v;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[v], low[u]);
        }
        else if (vis[v]) low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        int v;
        num++;
        do {
            v = st[top--];
            in[v] = num;
            vis[v] = 0;
            si[num] += se[v];
        } while (u != v);
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &x, &y);
        add(i, x);
        se[i] = y;
    }
    for (int i = 1; i <= n; i++) {
        if (!dfn[i]) tarjan(i);
    }
    for (int i = 1; i <= num; i++) {
        ans = max(ans, si[i]);
    }
    printf("%d\n", ans);
    return 0;
}
```

~~不过我看好多人的提交记录都是直接用一个dfs解决的，难道我想复杂了？~~

---

## 作者：king_xbz (赞：4)

看看题解区的大佬有tarjan的，拓扑排序的，可谓是~~百花齐放~~。不过好像有人说暴力判断是否回到原点来求解吸氧也只有50pts，那么，我就来分享一下如何用最暴力的dfs判环不吸氧过掉这道题。

考察知识点：
-
图论（图的遍历），深度优先搜索（DFS），回溯法；

算法思路：
-
读入数据时将i->Di连一条权为Ti的边。接着搜索每个节点，看能否回到原点，并实时更新Max值。

代码实现
-
存有向图，注意数据范围是n≤100000，所以不能用邻接矩阵，我们选用**链式前向星**。
```cpp
for(fint i=1;i<=n;i++)
	x=read(),y=read(),adds(i,x,y);
inline void adds(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].val=w;
	head[u]=cnt;
	return ;
}
```
接下来是搜索，注意**回溯与结束条件**，还有千万记得每次搜完**将tim归零**！
```cpp
for(fint i=1;i<=n;i++)
	tim=0,dfs(i,i);//搜前归零好习惯
inline void dfs(int st,int x)//st为起点，x为目前位置
{
	if(x==st&&vis[x])
	{
		maxxs=max(maxxs,tim);//更新
		return ;
	}
	vis[x]=1;
	vis[st]=0;//特判原点未被访问，否则搜不到底
	for(fint i=head[x];i;i=e[i].nxt)//遍历图
	if(!vis[e[i].to])
	tim+=e[i].val,vis[e[i].to]=1,dfs(st,e[i].to);
	vis[x]=0;//回溯
	return ;
}
```
如果不放心，还可以加个快读优化一下
```cpp
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
```
这样，这道题就结束了，应该是目前题解区最暴力最好想思路的一篇吧！ _快来试试吧！_ 


---

## 作者：小菜鸟 (赞：4)

~~代码和黄题几乎一样，这怎么就蓝了~~

这题要求找到图中的最大环。可能第一反应是$Tarjan$，然而又臭又长不好写。

然后我们发现图中所有点出度都为一，所以每个点出发能走的路径唯一，要么成环要么断掉。。。

于是我们考虑记忆化搜索，可以$O(n)$求出图中所有点所在环。

然后要求环的大小，那么考虑借鉴$Tarjan$的时间戳，遇到环时，时间戳相减就是环的大小。

由于这题有边权，所以时间戳每次累加不是$1$而是边权。

代码极其简洁：

```cpp
#include<cstdio>
#include<algorithm>

int n,a=0,tot,Next[1<<18],Time[1<<18],ans[1<<18];
int dfn[1<<18];

int dfs(int k)
{
    tot+=Time[k];
    if(ans[k])return ans[k];
    if(dfn[k])return tot-dfn[k];
    dfn[k]=tot;
    return ans[k]=dfs(Next[k]);
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d%d",Next+i,Time+i);
    }
    for(int i=1;i<=n;++i)a=std::max(a,dfs(i));
    printf("%d",a);
}
```



---

## 作者：Ciyang (赞：2)

~~这题很水~~, 随手交了个暴力随机化就A了.

打个广告, [My Blog](xciyang.github.io).

### 分析

这道题正解思路非常妙, 代码比较短. 但我们能不能想一个更简单粗暴的方法呢?

先交一下能被卡成接近 $ O(n^2) $ 的暴力, 对于每一个点跑一遍DFS, 如果能回到此点就更新答案, 再加一个玄学剪枝, 将这个环上所有点打标记, 这些点就不用再DFS了.

开O2后, 只有50分, 很惨, 难不成是用cin的原因?

```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
int n, tox[100001], toy[100001], rex[100001], tmpx, ans, walkpast[100001], lw[100001];
void dfs(int nown) {
    memcpy(walkpast, lw, sizeof(walkpast));
    int sum= 0, to= nown;
    while(!walkpast[to]) {
        walkpast[to]= 1;
        sum+= toy[to], to= tox[to];
    }
    if(to != nown) return;
    memcpy(lw, walkpast, sizeof(walkpast));
    ans= max(ans, sum);
    return;
}
int main() {
    cin >> n;
    for(int i= 1; i <= n; i++) cin >> tox[i] >> toy[i], rex[tox[i]]= i;
    for(int i= 1; i <= n; i++)
        if(!walkpast[i]) dfs(i);
    cout << ans << endl;
    return 0;
}
```

考虑优化, 其实复杂度是可以玄学过去的 ~~先把cin换成scnaf~~.

然后我们加了判断有环, 但此点不在环上的一个小剪枝.

```cpp
    if(to != nown) {
        lw[nown]= 1;
        return;
    }
```
通俗一点讲, 让以后到达这个点的鸭子都知道自己的水坑不在环里就不用继续搜了.

要是还T怎么办, 那改一下搜索顺序说不定就A了, 为了防止从 N 到 1 一条链卡暴力的情况, 我选择随机起点, 再加一个卡时限.

### 代码:

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
using namespace std;
int n, tox[100001], toy[100001], rex[100001], tmpx, ans, walkpast[100001], lw[100001];
void dfs(int nown) {
	memcpy(walkpast, lw, sizeof(walkpast));
	int sum= 0, to= nown;
	while(!walkpast[to]) {
		walkpast[to]= 1;
		sum+= toy[to], to= tox[to];
	}
	if(to != nown) {
		lw[nown]= 1;
		return;
	}
	memcpy(lw, walkpast, sizeof(walkpast));
	ans= max(ans, sum);
	return;
}
int main() {
	scanf("%d", &n);
	for(int i= 1; i <= n; i++) scanf("%d%d", tox + i, toy + i), rex[tox[i]]= i;
	while(clock() < CLOCKS_PER_SEC * 0.9) {
		int tmpx= rand() % n + 1;
		if(!walkpast[tmpx]) dfs(tmpx);
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：mot1ve (赞：1)

此题要求从基环树森林中找一个最大的环。

很直观的一个做法：拓扑把所有环找出来，对于每一个环都dfs一遍，求出每个环的大小。

拓扑之后还有入度的点即为在环上的点，dfs的时候遇到一个入度为0的点说明回到的这个环的起点，记录大小，return就可以了。

ps：这题不用建图，不过为了写的符合习惯，还是拿邻接表建了一个。

```
#include<bits/stdc++.h>
using namespace std;
int n,ans,idx;
int head[100010],ru[100010];
struct node{
	int nxt,to,w;
}edge[100010];
void add(int u,int v,int w)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	edge[idx].w=w;
	head[u]=idx;
}
void topo(){
	queue<int> q;
	for(int i=1;i<=n;i++)
	{
		if(!ru[i])
		q.push(i);
	}
	while(q.size())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=edge[i].nxt)
		{
			int v=edge[i].to;
			ru[v]--;
			if(!ru[v])
			{
				q.push(v);
			}
		}
	}
}
void dfs(int x,int len)
{
	if(!ru[x])
	{
		ans=max(ans,len);
		return ;
	}
	ru[x]--;
	for(int i=head[x];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		dfs(v,len+edge[i].w);
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int d,w;
		cin>>d>>w;
		add(i,d,w);
		ru[d]++; 
	}
	topo();//拓扑完之后还有入度的点就是在环上的
	for(int i=1;i<=n;i++)
	{
		if(ru[i])
		{
			dfs(i,0);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Phoenix_chaser (赞：1)

# 拓扑加Dfs
看到本题，本蒟蒻就发现这题是找环，于是拓扑瞬间浮现在眼前

这里普及一下：如何用拓扑来找环

我们每次去找入度为0的点让他们弹出，这是拓扑的基本思想，但是，当我们已经没有入度为0的点时，**还有一些点没有排序，这就意味着图中有环。**

### 但是

这题是找最大环，拓扑只能找到是否有环，这该怎么办呢？

很简单，在确定是环的点跑Dfs，如果可以返回原点就比较现在环的长度和最优答案

~~虽然跑的慢，但是思路出的快啊

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3131300],ru[1233100],chu[131300],vis[1001400],t1[1000032];
int n,m,l,r,s,e,ji=-1;
struct node{
	int t,w;
};
queue<int>q;
vector<node>g[1333130];
void dfs(int x,int y,int ans){
	if(x==y&&ans!=0){
		ji=max(ji,ans);
		return ; 
	}
	for(int i=0;i<g[x].size();i++)
	{	vis[g[x][i].t]=1;
		dfs(g[x][i].t,y,ans+g[x][i].w);
	}
} 
inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		t1[i]=read();
		ru[a[i]]++;
		g[i].push_back((node){a[i],t1[i]});
	}
	for(int i=1;i<=n;i++)
	{
		if(ru[i]==0)
		q.push(i);
	}
	while(!q.empty()){
		int r=q.front();
		vis[r]=1;
		q.pop();
		for(int i=0;i<g[r].size();i++)
		{
		ru[g[r][i].t]--;
		if(ru[g[r][i].t]==0)
		q.push(g[r][i].t);	
		} 
	}
	for(int i=1;i<=n;i++)
	{
		if(vis[i]==0)
		dfs(i,i,0);
	}
	printf("%d",ji);
}
```
谢谢观看

---

## 作者：yangwenbin (赞：1)

这就是一道 $Tarjan$ 模板题，个人觉得并不是很难

就很模板。

这道题有 $n$ 个点， $n$ 条边，很明显这是一片基环树森林

而且特征明显，一个点如果在环上，那么它一定可以走到自己，但是如果不在那么一定走不到

同时在环上，它走回来的最大距离也是一定的，即环内所有边边权值的和：

所以跑一遍 $Tarjan$ ，然后遍历每一条边

最终时间复杂度是 $O(2 \times  n)$ 的

# code

```
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 1e5 + 50;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,num_edge,tot,cnt,top,ans;
int head[SIZE],dfn[SIZE],low[SIZE],belong[SIZE],stc[SIZE],siz[SIZE];
bool instack[SIZE],vis[SIZE];
struct node
{
	int to,nxt,val;
};
node edge[SIZE];

inline void add(int u,int v,int val)
{
	edge[++num_edge].to = v;
	edge[num_edge].nxt = head[u];
	edge[num_edge].val = val;
	head[u] = num_edge;
}

inline void tarjan(int u)
{
	dfn[u] = low[u] = ++tot;
	instack[u] = true;
	stc[++top] = u;
	for (int i = head[u]; i ; i = edge[i].nxt)
	{
		int v = edge[i].to;
		if (!dfn[v])
		{
			tarjan(v);
			low[u] = min(low[u],low[v]);
		}
		else if (instack[v])
		{
			low[u] = min(low[u],low[v]);
		}
	}
	if (dfn[u] != low[u]) return ;
	cnt++;
	int tmp;
	do
	{
		tmp = stc[top--];
		instack[tmp] = false;
		belong[tmp] = cnt;
	} while (tmp != u);
}


int main()
{
	n = read();
	for (int i = 1; i <= n; ++i)
	{
		int x = read(),val = read();
		add(i,x,val);
	}
	for (int i = 1; i <= n; ++i)
	{
		if (!dfn[i]) tarjan(i);
	}
	for (int u = 1; u <= n; ++u)
	{
		for (int i = head[u]; i ; i = edge[i].nxt)
		{
			int v = edge[i].to;
			if (belong[u] == belong[v])
			{
				siz[belong[u]] += edge[i].val;
				ans = max(ans,siz[belong[u]]);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：QMQMQM4 (赞：1)

## 拓扑排序求环的最值

环上有很多种问题，也有很多种解法，如并查集求最小环，spfa判负环等等，而今天介绍的是拓扑排序法

### 首先可以说下原理

拓扑排序的过程有点像bfs，都是把一个点拿出来，遍历它的子节点，然后子节点入度减一，如果为零就加入队列。

接下来，环有个很重要的性质，就是环上是没有入度为零的点的，于是对原图进行一遍拓扑排序，还没有进队的元素就是环上的点。

如何判断是否进队能？只需要看排序后入度是否为零即可

找到一个元素后对它直接广搜，遇到不是环上的点就跳过，统计答案即可

这种方法适合求最大/小值，没有边权也可以

### CODE
```
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+5;

struct Edge
{
	int to,nex,val;
}E[maxn<<1];
int head[maxn],in[maxn];
int n,ans,cnt;
queue<int> q;

inline int read()
{
	char c = getchar();int x = 0,f = 1;
	while(c<'0'||c>'9') {if(c=='-')f = -1;c = getchar();}
	while(c>='0'&&c<='9') {x = x*10+c-'0';c = getchar();}
	return x*f;
}

inline void add(int u,int v,int w)
{
	cnt ++;
	E[cnt].to = v;
	E[cnt].val = w;
	E[cnt].nex = head[u];
	head[u] = cnt;
}

void topo()
{
	for(int i = 1;i<=n;++i)
		if(!in[i]) q.push(i);
	while(!q.empty())
	{
		int u = q.front();q.pop();
		for(int i = head[u];i != -1;i = E[i].nex)
		{
			int v = E[i].to;
			in[v]--;
			if(!in[v]) q.push(v);
		}
	}
}

void get(int x)
{
	int tot = 0;
	queue<int> p;
	p.push(x);
	while(!p.empty())
	{
		int u = p.front();p.pop();
		//if(!in[u]) continue;
		for(int i = head[u];i != -1;i = E[i].nex)
		{
			int v = E[i].to;
			if(!in[v]) continue;
			tot += E[i].val;
			in[v]--;p.push(v);
		}
	}
	ans = max(ans,tot);
}

int main()
{
	memset(head,-1,sizeof(head));
	n = read();
	for(int i = 1;i<=n;++i)
	{
		int x = read();int y = read();
		add(i,x,y);in[x] ++;
	}
	topo();
	for(int i = 1;i<=n;++i)
		if(in[i]) get(i);
	printf("%d",ans);
	return 0;
}
```
祝大家csp2019 rp++，score++











---

## 作者：06ray (赞：1)

### 裸的最大环问题

#### 由于图是单向的，所以我们可以用tarjan来求强连通分量，把每个环中每个边的时间累加起来，最后打个擂台统计最大的就行了。

#### 代码:
```

#include <iostream> 
#include <vector>
#include <stack>
using namespace std;
const int MAXN=501000;
stack<int> s;
int n,m,x[MAXN],y[MAXN],dfn[MAXN],low[MAXN],color[MAXN],vis[MAXN],used[MAXN],in[MAXN],f[MAXN],a[MAXN],b[MAXN];
int colornum; 
vector<int> G[MAXN];
int cnt;
void tarjan(int u)//tarjan模板，不解释
{
    cnt++;
    dfn[u]=low[u]=cnt;
    used[u]=true;
    s.push(u);
    vis[u]=true;
    for(int i=0; i<G[u].size(); i++)
    {
        int v=G[u][i];
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else
        {
            if(vis[v])
            {
                low[u]=min(low[u],dfn[v]);
            }
        }
    }
    if(dfn[u]==low[u])
    {
        colornum++;
        while(s.top()!=u)
        {
            int t=s.top();
            s.pop();
            color[t]=colornum;
            vis[t]=false;
        }
        s.pop();
        color[u]=colornum;
        vis[u]=false;
    }
}
int main()
{
    cin>>n;
    for(int i=1; i<=n; i++)
    {
    	cin>>x[i]>>y[i];
        G[i].push_back(x[i]);//建图
    }
    for(int i=1; i<=n; i++)
    if(!used[i]) tarjan(i);
    for(int i=1; i<=n; i++)
    {
    	b[color[i]]+=y[i];//累加
    }
    int ans=0;
    for(int i=1; i<=colornum; i++)
    {
    	if(b[i]!=1)ans=max(ans,b[i]);//打擂台，求最大值
    }
    cout<<ans;
    return 0;
}
```
[双倍经验](https://www.luogu.org/problemnew/show/P2661)

---

## 作者：0nullptr (赞：1)

题目传送门：[P5145 漂浮的鸭子](https://www.luogu.org/problem/P5145)

这题要求找到图中的最大环，由于Tarjan求联通分量太长，考虑直接进行搜索。

题目中的鸭子一共只存在两种情况：
1. 能回到自己的
2. 不能回到自己的

由于此题中有一个特点，即每个点的出度均为一，可以考虑先删去所有不能回到自己的点，然后在剩下的这些环中找到最大的即可。

首先考虑如何删去不能回到自己的点。显然，这些不能回到自己的点一定在这个环的外向链上，那么，必然存在入度为0的点作为这条链的初始点。因此，从每个入度为0的点开始删点即可删完。
```cpp
void del(int i) {
    while(in[i] == 0) {
        inq[i] = 1;//记录当前点已经被遍历过（删去）
        in[nxt[i]]--;//下一个点的入度减1
        i = nxt[i];//向下遍历
    }
}
```
接下来进行求每个环的长度。显然，可以直接进行对每个环进行裸的bfs分别求每个环的长度。
```cpp
int bfs(int st) {
    int ans = 0;//记录当前环的大小
    while(!inq[st]) {
        ans += cost[st];
        inq[st] = 1;
        st = nxt[st];//遍历环
    }
    return ans;//返回环的大小
}
```
至此，这道题的主要算法部分就被完美解决了。完整代码如下：
```cpp
#include<iostream>
#define MAXN 100010
using namespace std;

int in[MAXN],nxt[MAXN],cost[MAXN],inq[MAXN];

void del(int i) {
    while(in[i] == 0) {
        inq[i] = 1;
        in[nxt[i]]--;
        i = nxt[i];
    }
}

int bfs(int st) {
    int ans = 0;
    while(!inq[st]) {
        ans += cost[st];
        inq[st] = 1;
        st = nxt[st];
    }
    return ans;
}

int main() {
    int n;
    cin>>n;
    for(int i = 1; i <= n; i++) {
        cin>>nxt[i]>>cost[i];
        in[nxt[i]]++;
    }
    for(int i = 1; i <= n; i++) if(!inq[i]) del(i);
    int ans = 0;
    for(int i = 1; i <= n; i++) ans = max(ans, bfs(i));
    cout<<ans<<endl;
    return 0;
}
```

---


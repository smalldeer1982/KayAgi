# [CEOI 2018] toy

## 题目描述

Johnny 喜欢收藏玩具。他收藏的玩具有很多不同的种类，每种玩具有很多个，而种类相同的两个玩具是无法区分的。

Emma 问 Johnny 他有几个玩具。然而 Johnny 并不愿意回答这个问题。

他告诉 Emma，如果他从所有玩具中选择一些不同的玩具，他可以玩 $n$ 天。换言之，这 $n$ 天中任意两天选择的玩具，存在一种玩具选择的数量不同。同时，选择的玩具集合是空集也是允许的。

Emma 并不想亲自计算这个答案，因此她把这个问题交给了你。你需要告诉她 Johnny 拥有的玩具的所有可能数量。


## 说明/提示

对于 $100\%$ 的数据， $1\le n\le 10^9$。

-----

**题目翻译By @StudyFather。**

## 样例 #1

### 输入

```
36```

### 输出

```
8
6 7 8 10 11 13 18 35```

# 题解

## 作者：ikunTLE (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P5697)

### 思路

本题是一道搜索。

分析过样例后，你会发现从上一次搜下来的数，一直到 $\sqrt{n}$ 中，所有 $n\div i$ 的质因子都接着往下搜，每一个新的质因子就是一个答案。既然那个数是 $n$ 的质因数了，答案就是计数器 $+n-1$（这里的 $n$ 是更新后每一次的 $n\div i$）。

经过排序后就是我们要的答案。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,ans[N],num;
map<int,bool>mp;
void dfs(int p,int x,int cnt){
	if(x<=p){//没超出答案范围
		int temp=cnt+p-1;
		if(!mp[temp]){//去重
			ans[++num]=temp;
			mp[temp]=true;
		}
	}
	int sqrt_p=sqrt(p);
	for(int i=x;i<=sqrt_p;++i)
		if(!(p%i))//是p（n÷i）的质因子
			dfs(p/i,i,cnt+i-1);//接着搜
	return;
}
int main(){
	scanf("%d",&n);
	dfs(n,2,0);//2是最小的质数，故从2开始
	printf("%d\n",num);
	sort(ans+1,ans+num+1);//排序
	for(int i=1;i<=num;++i)
		printf("%d ",ans[i]);
	return 0;
}
```

---

## 作者：Li_Feiy (赞：3)

### [[CEOI2018] toy](https://www.luogu.com.cn/problem/P5697) 解题记录
---
#### 题意简述
题目描述给得非常的绕，看了半天才看懂。  
结合一组数据理解一下：  
样例输入  
```
10
```
样例输出  
```
2
5 9
```
其中 $5$ 说明集合 $\{1,4\}$，有组合方案：  
$\{1,4\},\{1,3\},\{1,2\},\{1,1\},\{1,0\},$  
$\{0,4\},\{0,3\},\{0,2\},\{0,1\},\{0,0\}$。  
其余同理。

---
#### 题目分析
通过观察样例可以发现，对于集合 $S$ 中的每一个元素 $i$ ，它对答案的贡献都为 $i+1$，所以根据乘法原理，每个集合的贡献就是 $\prod\limits^{|S|}_{i=1}S_i$。（所有元素 $+1$ 后累乘起来的 $=n$）。  
这时候就会惊奇地发现：这不就是 $n$ 的因式分解吗？  
于是就可以愉快地切了此题

---
#### AC Code
```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
CI N=1e7+5;
int n,r,a[N];
void dfs(int now,int last,int sum){
    if(now>=last){
        a[++a[0]]=sum+now-1;
    }
    for(int i=last;i*i<=now;i++){
        if(now%i==0){
            dfs(now/i,i,sum+i-1);
        }
    }
}
signed main() {
    std::cin>>n;
    dfs(n,2,0);
    std::sort(arrall(a,a[0]));
    a[0]=std::unique(arrall(a,a[0]))-a-1;
    std::cout<<a[0]<<"\n";
    arrout(a,a[0]);
    return 0;
}
```

---

## 作者：pxb0801 (赞：3)

~~一道大无语的搜索~~

------------------
## 1.题目大意

这题一上来怎么也看不懂，样例太大，所以我先~~贴心~~的给大家一个小样例。

输入样例：

```
6
```

输出样例：

```
2
3 5
```

其实到这还是很不清晰，所以我来解释一下：

这里的输出的 $3$ 表示有三个玩具，两种玩具，第一种有 $1$ 个，第二种有 $2$ 个。组合方案为：$\{0,0\},\{0,1\},\{0,2\},\{1,0\},\{1,1\},\{1,2\}$。

输出的 $5$ 表示有五个玩具，一种玩具。组合方案为：$\{0\},\{1\},\{2\},\{3\},\{4\},\{5\}$。

--------------
## 2.分析

看到这，我们会发现，每一种玩具如果有 $k$ 个，那么就会有 $0,1,2,…,k$ 这些个选择，即一共有 $(k+1)$ 种选择。再根据乘法原理，如果有 $m$ 种玩具，每一种玩具有 $k$ 个，只要满足 $\prod\limits_{i=1}^{m}{k_i}$ 等于 $n$ 即可。

讲大白话就是：从 $2$ 开始搜索（如果从 $1$ 开始，说明玩具的个数为 $0$，无效），如果是 $n$ 的因数，就把 $cnt$ 加上当前的数减 $1$。

---------------
## 3.正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans[10000000],ansx;//不知道为啥要开如此大 
void dfs(int n,int x,int cnt){
	if(x<=n){
		ans[++ansx]=cnt+n-1;
	}
	for(int i=x;i*i<=n;i++){
		if(n%i==0){
			dfs(n/i,i,cnt+i-1);
		}
	}//dfs找因数的O(sqrt(n))做法 
}
int main(){
	cin>>n;
	dfs(n,2,0);//从2开始，上文有解释 
	sort(ans+1,ans+ansx+1);
	ansx=unique(ans+1,ans+ansx+1)-ans-1;//排序+去重 
	cout<<ansx<<endl;
	for(int i=1;i<=ansx;i++){
		printf("%d ",ans[i]);
	}
	return 0;
}
```

---

## 作者：xiaomimxl (赞：3)

# 题意：

~~不是很好说。。。~~


现在有一个集合 $\{ 5,1\}$。

其中第 $i$ 个元素代表有多少个这种玩具有多少个。

因为：


$\{5,1\},\{5,0\},\{4,1\},\{4,0\},\{3,1\},\{3,0\},\{2,1\},\{2,0\},\{1,0\},\{1,1\},\{0,1\},\{0,0\}$

所以这个集合就可以玩 $n=12$ 天。

求还有多少个这样的集合使可以玩 $n$ 天（这个 $n$ 不一定是 $12$）

方便起见，只需输出这些集合的个数和其中所有元素的和，按升序排列。

# 分析
先给一个简点的样例和解释：

样例输入： 
```
12
```

样例输出： 
```
4
4 5 6 11
```

解释：

有这几个集合满足条件：

$\{2,1,1\}$

$\{3,2\}$

$\{5,1\}$

$\{11\}$

当我们把所有的集合的元素都加一，神奇的事情发生了！

这些集合刚好对应了 $n$ 的因式分解的方案。

所以，我们只需对 $n$ 做因式分解即可。

现在我们可以请出代码了。

# Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
set<int>a;
int n;
void dfs(int x,int q,int sum){
	if(x>=q) a.insert(sum+x-1);
	for(int i=q;i*i<=x;i++) if(x%i==0) dfs(x/i,i,sum+i-1);
}
int main(){
	scanf("%d",&n);
	dfs(n,2,0);
	printf("%d\n",a.size());
	for(auto i:a){
		printf("%d ",i);
	}
	return 0;
}
```


---

## 作者：zhangzongyue (赞：2)

题意分析：

已知 Johnny 已有的玩具可以玩 $n$ 天，这 $n$ 天中任意两天有一种玩具的数量不同，一种玩具可以不选，问 Johnny 可能有的玩具数量。

题目只说了玩具数量，没有说玩具种类，比如说 4 个玩具可以分为 ${4}$ 或 ${2,2}$ 或 ${1,1,2}$ 或 ${1,1,1,1}$，分别对应 $1,2,3,4$ 种，可以玩 $5,9,12,16$天，所以 $n=5,9,12,16$ 时 Johnny 可以有 $4$ 个玩具。

由分析可知：当一种玩具有 $x$ 个时，对天数贡献为 $(x+1)$，而总天数为 $n$ 所以只需要对 $n$ 进行因数分解就行了。当然因为对天数的贡献为 $(x+1)$，所以分解出来的每一项都要 $-1$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[10000000];
void dfs(int n,int last,int s){
	if(n>=last){
		a[++k]=s+n-1;
	}
	for(int i=last;i*i<=n;++i){
		if(n%i==0) dfs(n/i,i,s+i-1);
	}
}
int main(){
	scanf("%d",&n);
	dfs(n,2,0);
	sort(a+1,a+1+k);
	int k1=0;
	for(int i=1;i<=k;++i){
		if(a[i]!=a[i+1]) a[++k1]=a[i];
	}
	printf("%d\n",k1);
	for(int i=1;i<=k1;++i){
		printf("%d ",a[i]);
	}
	return 0;
}
```


---

## 作者：mc_him (赞：0)

# 题目大意
给出天数，求有多少种玩具在这几天中任意两个组合且不重复。允许有空子集。
# 题目分析
这道题目可以先研究规律。先看下面的例子。

样例输入：
```
8
```
样例输出：
```
3
3 4 7
```
样例输入：
```
18
```
样例输出：
```
4
5 7 9 17
```
不难发现，从二开始搜索，如果是指定数的因数，就把累加器加上当前的数减一。那么我们就可以先找到它的因数，再进行排序与去重就可以了。
# 代码
```cpp
#include<bits/stdc++.h>  //万能头 
using namespace std;
int n,a[10000001],sum,ans[10000001],cnt;
void fj(int n,int x,int k){	//找因数 
	if(x<=n)a[sum++]=k+n-1;	
	for(int i=x;i<=sqrt(n);i++)
		if(n%i==0)	
			fj(n/i,i,k+i-1);//递归	
}
void quchong(){
	ans[++cnt]=a[0];
	for(int i=1;i<sum;i++)
		if(a[i]!=ans[cnt]) ans[++cnt]=a[i];//去重 
}
int main(){
	cin>>n;
	fj(n,2,0);//调用函数，找到它的所有因数 
	sort(a,a+sum),quchong(),cout<<cnt<<endl;//排序+去重+输出因数个数 
	for(int i=1;i<=cnt;i++) cout<<ans[i]<<' ';
	return 0;
}
```


## 审核员辛苦了

---

## 作者：nxd_oxm (赞：0)

# 题意
光看题目看不出来，我给大家解释一下。

### 样例输入

```
8
```

### 样例输出

```
3
3 4 7
```

那就是有 $3$ 种情况。

下面的 $3$ 表示可能有 $3$ 个玩具，也就是 $1,1,1$。

组合方案：

$ \{0,0,0 \} $，$ \{ 0,0,1 \} $，$ \{ 0,1,0 \} $，$ \{ 0,1,1 \} $，

$ \{1,0,0 \} $，$ \{ 1,0,1 \} $，$ \{ 1,1,0 \} $，$ \{ 1,1,1 \} $。


$4$ 则是 $1,3$。

$ \{ 0,0 \} $，$ \{ 0,1 \} $，$ \{ 0,2 \} $，$ \{ 0,3 \} $，

$ \{ 1,0 \} $，$ \{ 1,1 \} $，$ \{ 1,2 \} $，$ \{ 1,3 \} $。

$7$ 则是 $7$。

$ \{ 0 \} $，$ \{ 1 \} $，$ \{ 2 \} $，$ \{ 3 \} $，

$ \{ 4 \} $，$ \{ 5 \} $，$ \{ 6 \} $，$ \{ 7 \} $。

# 思路

根据上面的样例，可以看出，对于每一种玩具，都有 $ \{ 0,1, \cdots ,n-1,n\}$ 种选择情况，根据乘法原理，在 $m$ 个玩具，第 $i$ 个玩具的个数是 $k_i$，所以最终的选择情况数则是 

$$\prod_{i=1}^m{k_i+1}$$

所以给了最终的数量，我们就可以分解因数，而这种玩具个数则是因数减一，最后去重，输出即可。

## AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int sum=0;
int ss=0;
int a[10000001];
void dfs(int n,int last,int sums){
	if(n>=last){
		a[++sum]=sums+n-1;
	}
	for(int i=last;i*i<=n;i++){
		if(n%i==0){
			dfs(n/i,i,sums+i-1);
		}
	}
}
signed main(){
	int l;
	cin>>l;
	dfs(l,2,0);
	sort(a+1,a+1+sum);
	for(int i=1;i<=sum;i++){
//		cout<<a[i];
		if(a[i]!=a[i+1]){
			a[++ss]=a[i];
		}
	}
	cout<<ss<<endl;
	for(int i=1;i<=ss;i++){
		cout<<a[i]<<" ";
	}
	return 0;
}

```

---

## 作者：7KByte (赞：0)

一看就是什么正经的题目，乱搞就完事了。

输出的规模应该是 $\sqrt{N}$ 级别的，否则也不会让输出。

分析一下，每种玩具有 $c_i$ 个，那么可以玩 $\prod (c_i+1)$ 天。

所以写个暴搜就行了。状态 $(n,\ last,\ sum)$ 表示剩下的数乘积为 $n$，上一个数是 $last$，当前数之和为 $sum$。

避免过多重复，我们记录 $last$ 使得每次选的数比上次的数更大。

```cpp
/*
    Author : SharpnessV
    Right Output ! & Accepted !
*/
#include<bits/stdc++.h>
//#define int long long

#define rep(i, a, b) for(int i = (a);i <= (b);i++)
#define pre(i, a, b) for(int i = (a);i >= (b);i--)
#define rp(i, a) for(int i = 1; i <= (a); i++)
#define pr(i, a) for(int i = (a); i >= 1; i--)
#define go(i, x) for(auto i : x)

#define mp make_pair
#define pb push_back
#define pf push_front
#define fi first
#define se second
#define ze(p) memset(p, 0, sizeof(p))
#define mem(p, x) memset(p, x, sizeof(p))
#define YES puts("YES")
#define NO puts("NO")
#define si(x) (int)(x).size()
#define db cerr
#define pc putchar
#define el putchar('\n')

using namespace std;
const double eps = 1e-15, pi = 3.1415926535897932385;
typedef long long LL;
typedef pair<int,int> Pr;
const int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}, inf = 0x7fffffff;

//char buf[1<<22],*p1=buf,*p2=buf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read(){
    int x = 0;bool f = 1;char ch = getchar();
    while(!isdigit(ch))f = ('-' == ch ? 0 : 1), ch = getchar();
    while(isdigit(ch))x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    if(f)return x;return -x;
}
inline LL Read(){
    LL x = 0;bool f = 1;char ch = getchar();
    while(!isdigit(ch))f = ('-' == ch ? 0 : 1), ch = getchar();
    while(isdigit(ch))x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    if(f)return x;return -x;
}
int gcd(int x,int y){return y ? gcd(y, x % y) : x;}
int lcm(int x,int y){return x / gcd(x, y) * y;}
#define P 1000000007
//#define P 998244353
#define bas 229
inline void ad(int &x, int y){x += y; if(x >= P) x -= P;}
inline void su(int &x, int y){x -= y; if(x < 0) x += P;}
inline void cmn(int &x,int y){if(y < x) x = y;}
inline void cmx(int &x,int y){if(y > x) x = y;}

int Pow(int x, int y){
	if(y < 0)return Pow(Pow(x, P - 2), -y);
	int now = 1 ;
	for(;y;y >>= 1, x = 1LL * x * x % P)if(y & 1) now = 1LL * now * x % P;
	return now;
}
vector<int>ans;
void solve(int n, int mn, int sum){
	ans.pb(n - 1 + sum);
	for(int i = mn;i * i <= n; i++)if(n % i == 0)
		solve(n / i, i, sum + i - 1);
}
int main(){
	//int T = read();while(T--)solve();
	int n = read();
	solve(n, 2, 0);
	int pre = ~0,cnt = 0;
	sort(ans.begin(), ans.end());
	go(x, ans)if(x != pre)pre = x, cnt++;
	printf("%d\n", cnt);pre = ~0;
	go(x, ans)if(x != pre)printf("%d ",pre = x);
	el;return 0;
}

```

---


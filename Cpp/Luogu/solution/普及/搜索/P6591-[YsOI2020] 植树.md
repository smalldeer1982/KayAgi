# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# 题解

## 作者：WanderingTrader (赞：11)

这题是一道树上操作题，难度不大。  
### 题目分析
其实就是判断一个多叉树中的各子树大小是否相同。  
如果以每个节点为根重构树，复杂度将达到$O(n^2)$，在$1\le n\le10^6$的情况下显然是不行的，只能拿到Subtask 1的40分。这样的数据规模要求我们把复杂度降到$O(n\log n)$甚至常数稍大的$O(n)$。  
这意味着我们只能执行一次重构树操作，就以节点1为根吧。  

我们自造一组强度略高的数据，如下：
```
7
1 2
3 1
4 2
5 2
4 6
3 7
```
手算得样例输出：
```
5 6 7
```
我们把整棵树画出来即为：  
![](https://cdn.luogu.com.cn/upload/image_hosting/rkvl0cto.png)  
以1为根，计算各结点的子树大小（包含自己）：
```
7 4 2 2 1 1 1
```
然后让每个节点找自己子结点的子树大小，以及$n$减去自己大小的值：
```
4 2
2 1 3
1 5
1 5
6
6
6
```
我们看到，只有第$5,6,7$行的数字完全相同，满足条件，所以输出`5 6 7`  
大体思路就是这样，主要还是看代码吧。  
### 代码
首先我们用一个邻接表：
```cpp
#define N 1000005
#define _for(x,y) for(int i = x;i <= y;i ++)
vector <int> es[N];
```
初始化：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000005
#define _for(x,y) for(int i = x;i <= y;i ++)
vector <int> es[N];
bool root[N];
int d[N],n;
int main()
{
	scanf("%d",&n);
	int u,v;
	_for(1,n - 1)
	{
		scanf("%d%d",&u,&v);
		es[u].push_back(v);
		es[v].push_back(u);
	}
	return 0;
}
```
这里我们对for循环做了一个重定义，主要是想少打几个字吧。  

$d[x]$表示$x$的子树大小，$root[x]$表示是否可以作为根。  

然后就是模板dfs：
```cpp
int dfs(int x,int fa)
{
	int size = es[x].size(),num = 0;
	root[x] = 1;
	_for(0,size - 1)
		if(es[x][i] != fa)
		{
			d[x] += dfs(es[x][i],x);
		}
	++ d[x]; 
	return d[x];
}
```
这里我们用接近$O(n)$的复杂度（每个节点走一次）计算出了各子树的大小，还需要判断能否成为根。  

我们使用这个$num$表示比较值，如果$num=0$，直接$num=d[es[x][i]]$（此时已计算完成），否则比较$num$和$d[es[x][i]]$的值，如果不同直接$root[x]=0$。  
```cpp
_for(0,size - 1)
	if(es[x][i] != fa)
	{
		d[x] += dfs(es[x][i],x);
		if(!num)
			num = d[es[x][i]];
		if(num != d[es[x][i]]) root[x] = 0;
	}
```
然后还要判断$n-d[x]$是否和$num$相等，这里有两点注意：
1. 如果$num$还是0，即x是叶子结点，直接跳过
2. 如果x=1（根节点）直接跳过

代码：
```cpp
if(x != 1 && num && num != n - d[x]) root[x] = 0;
```
整个dfs过程：
```cpp
int dfs(int x,int fa)
{
	int size = es[x].size(),num = 0;
	root[x] = 1;
	_for(0,size - 1)
		if(es[x][i] != fa)
		{
			d[x] += dfs(es[x][i],x);
			if(!num)
				num = d[es[x][i]];
			if(num != d[es[x][i]]) root[x] = 0;
		}
	++ d[x]; 
	if(x != 1 && num && num != n - d[x]) root[x] = 0;
	return d[x];
}
```
可能有点复杂，但相较于set去重，这种方法常数小一点，时间较为稳定。  
做完dfs以后，跑一遍$n$个结点，$root[i]=1$就输出：
```cpp
dfs(1,0);
_for(1,n)
	if(root[i])
		printf("%d ",i);
```
全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000005
#define _for(x,y) for(int i = x;i <= y;i ++)
vector <int> es[N];
bool root[N];
int d[N],n;
int dfs(int x,int fa)
{
	int size = es[x].size(),num = 0;
	root[x] = 1;
	_for(0,size - 1)
		if(es[x][i] != fa)
		{
			d[x] += dfs(es[x][i],x);
			if(!num)
				num = d[es[x][i]];
			if(num != d[es[x][i]]) root[x] = 0;
		}
	++ d[x]; 
	if(x != 1 && num && num != n - d[x]) root[x] = 0;
	return d[x];
}
int main()
{
	scanf("%d",&n);
	int u,v;
	_for(1,n - 1)
	{
		scanf("%d%d",&u,&v);
		es[u].push_back(v);
		es[v].push_back(u);
	}
	dfs(1,0);
	_for(1,n)
		if(root[i])
			printf("%d ",i);
	return 0;
}
```
多叉树的操作题相对二叉树来说可能较为简单，主要就是dfs要写对。有些常见操作（比如求结点大小，求结点深度）等可以打成模板存好，要用的时候 ~~Ctrl+C+V~~ 可以借鉴一下。  

$\mathrm{The\ End.}$

---

## 作者：Imakf (赞：7)

## $\rm{subtask}\ 1(40pts)$

考虑枚举每个点，看它是否满足题目条件。

复杂度 $O(n^2)$。

## $\rm{subtask}\ 2(60pts)$

直接模拟，考虑 dfs 一遍整棵树，在 dfs 过程中处理答案。

强制以 $1$ 为根记录每一个节点的子树大小 $sz$。每次判断 $x$ 所有儿子的 $sz$ 和 $n-sz_x$ 是否相等。

**注意根节点。**

复杂度 $O(n)$。

---

另一种做法。

叶子肯定满足要求，除此之外的还满足要求的只有可能是重心。

重心只有一个时，暴力判断即可。

重心有两个则两个都不可能是。

复杂度 $O(n)$。

题解选用第一种做法。

----

出题人代码：[Imakf](https://www.luogu.com.cn/paste/n2e3pig2)。

验题人代码：[tiger0133](https://www.luogu.com.cn/paste/kyaj17ny)。

---

## 作者：____OccDreamer (赞：4)

题意：

给你一棵无根树，求有多少个节点，当以它为根时它所有的子树大小都相等。

最直接的想法是考虑，对于每一个节点都把它当作根节点进行暴力搜索，再循环判断是否满足题目条件。

但是看一眼数据 ： $1\leq n\leq 10^6$ ，直接寄飞。

怎么办呢？

此时考虑，我们选定一个点为根进行了一次搜索后，是可以得到所有点的子树大小的。

如图（图中选择的根为 $1$ 号节点）。

![](https://cdn.luogu.com.cn/upload/image_hosting/vywr58sj.png)

那么我们选择一个新的点当作根时，改变了子树大小的只有那个点的父节点。

比如上图，选择 $3$ 号点作为根时图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/324x7g2c.png)

观察两张图，很容易发现，只有 $1$ 号节点的子树大小发生了变化，同时 $1$ 号、 $3$ 号节点的父节点编号发生了变化。

而此时对答案有影响的只有 $1$ 号节点子树大小的变化。

思考 $1$ 号节点的子树大小是如何由 $10$ 变成 $4$ 的。

不难发现，当我们选择 $3$ 号节点作为新的根时， $1$ 号节点新的子树大小为 之前的子树大小 减去 $3$ 号节点的子树大小。

同时易得，如果选择 $8$ 号点为根，那么子树大小发生改变的节点是 $7$ 号节点。

推广一下，我们设当前选择的新根节点为 $x$ ，$x$ 的父节点为 $fa_x$ ，子树大小为 $size$ ，则每次根改变后 $fa_x$ 的子树大小为：

$$size_{fa_x}=size_{fa_x}-size_x$$

用这个去计算就可以了。

总结一下：

首先，先选择一个点作为根，用一遍搜索算出所有节点的子树大小。

然后，遍历每一个节点，将父节点"转化"为其子结点，并判断其所有子树大小是否相同。

一些具体细节在代码里。

代码：

````cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1000010;
int n,to[N<<1],net[N<<1],head[N],tot=0;
bool f[N];
int siz[N],fa[N];
void add(int x,int y)//链式前向星建图
{
	to[++tot]=y;net[tot]=head[x];head[x]=tot;
    to[++tot]=x;net[tot]=head[y];head[y]=tot;
    return ;
}
void dfs(int x)//这里用的是 dfs 
{
	f[x]=1;
	siz[x]=1;
	for (int i=head[x];i;i=net[i])
	{
		if (!f[to[i]])
		{
			dfs(to[i]);
			siz[x]+=siz[to[i]];fa[to[i]]=x;
		}
	}
	return ;
}
int main()
{
	cin>>n;
	for (int i=1;i<n;++i)
	{
		int u,v;
		cin>>u>>v;
		add(u,v);
	}
	dfs(1);//这里选择 1 号节点作为根节点
    //以下 5 行为对 1 号节点，根节点进行的特殊处理
	int now=siz[to[head[1]]];
	bool flag=1;
	for (int  i=head[1];i;i=net[i])
    	if (siz[to[i]]!=now) {flag=0;break;}
	if (flag) cout<<1<<' ';
    //转化新根的父节点的子树大小后判断当前节点是否合法并输出
	for (int i=2;i<=n;++i)
	{
		now=siz[1]-siz[i];
		flag=1;
		for (int j=head[i];j;j=net[j])
			if (to[j]!=fa[i])
				if (siz[to[j]]!=now) {flag=0;break;}
		if (flag) cout<<i<<' ';
	}
	return 0;//完结撒花~
}
````

希望能对您有帮助，有疑问可以私信或评论。

感谢阅读。

---

## 作者：K2sen (赞：4)

这个题要你干什么，题目中已经描述的很清楚了
所以直接上思路
## 思路
我们定义子树大小为siz

我们可以从1号节点开始，用一种非常巧妙的方式判断

好像就是变换树根，一开始就先默认1号节点为树根

然后不断变换树根，换完之后判断一下子树的大小是不是都相同就行了

### how to 变换树根
![](https://cdn.luogu.com.cn/upload/image_hosting/csy0luqx.png)

以上边这张图变成下边这张图为例， 根节点分别为1和2.

![](https://cdn.luogu.com.cn/upload/image_hosting/zt8z5pye.png)

我们可以看到1点的siz就是8， 2点的siz就是3

我们把2变成根节点之后2号节点的siz加上了(siz[1] - siz[2])

而原本的siz[1] 减去的原来的siz[2]

那么式子就非常显然了.

## 
```cpp
#include <bits/stdc++.h>
#define ll long long
#define N 1000100
#define M 1010

using namespace std;
int siz[N];
int ans[N], cnt, n, add_edge, head[N << 1];
struct node {
	int next, to;
}edge[N << 1];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void add(int from, int to) {
	edge[++add_edge].next = head[from];
	edge[add_edge].to = to;
	head[from] = add_edge;
}

void dfs1(int x, int fa) {
	siz[x] = 1;
	for (int i = head[x]; i; i = edge[i].next) {
		int to = edge[i].to;
		if (to == fa) continue;
		dfs1(to, x), siz[x] += siz[to];
	}
}

void dfs2(int x, int fa) {
	int sy = siz[edge[head[x]].to], flag = 0;
	for (int i = head[x]; i; i = edge[i].next) {
		int to = edge[i].to;
//		if (to == fa) continue;
		if (sy != siz[to]) {
			flag = 1;
			break;
		}
	}
	if (flag == 0) ans[++cnt] = x;
	for (int i = head[x]; i; i = edge[i].next) {
		int to = edge[i].to;
		if (to == fa) continue;
		siz[x] -= siz[to];
		siz[to] += siz[x];
		dfs2(to, x);
		siz[to] -= siz[x];
		siz[x] += siz[to];
	}
}

int main() {
	n = read();
	for (int i = 1, x, y; i < n; i++) {
		x = read(), y = read();
		add(x, y), add(y, x);
	}
	dfs1(1, 1);
	dfs2(1, 1);
	sort(ans + 1, ans + cnt + 1);
	for (int i = 1; i <= cnt; i++)
		cout << ans[i] << " ";
}
```

---

## 作者：Pretharp (赞：3)

### 思路

这道题个人感觉是个结论题，本人有一种比较巧妙的方法。首先，**叶子结点一定满足要求**，因为当叶子结点作为根时，它只有一颗子树。不过显然这样会漏掉答案，我想起了 OI-Wiki 中的一句话：

>以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。

也就是说，如果一个节点不是这棵树的重心，那么它作为根时，子树中会有一颗大小超过树的一半。都超过一半了，而且它还不止一颗子树，所以这个点肯定不满足要求。换句话说，**除了叶子节点，是重心的节点可能满足条件，不是重心的节点一定不满足条件**。然而我们知道一棵树的重心最多两个，所以我们可以暴力验证这个重心是否满足条件。

### 代码

这就十分简单了，先找出所有叶子结点，再找出重心，最后判断一下。~~为了保护你们的视力，我特意改了一下码风。~~

```cpp
#include <bits/stdc++.h>
#define pb push_back
using namespace std;
const int N = 1e6 + 5;
int n, idx, ans[N], w[N], siz[N], c[N], tot;
// n 是节点个数，idx 和 ans[] 用于储存答案。
// w[] 和 siz[] 是用于寻找重心，c[] 和 tot 是记录重心，这部分代码参考了 OI-Wiki。
// 其实这里 c[] 没必要开那么大，开到 3 就够了，但是不影响。
vector<int> v[N];
map<int, int> mp;
// std::vector<int> v 是存储图的，std:map<int,int> mp 是判重（防止某个点又是叶子又是重心，导致答案重复）。
void dfs(int x, int fa) {
  siz[x] = 1, w[x] = 0;
  for (int i : v[x]) {
    if (i == fa) continue;
    dfs(i, x);
    siz[x] += siz[i], w[x] = max(w[x], siz[i]);
  }
  w[x] = max(w[x], n - siz[x]);
  if (w[x] <= n / 2) {
    c[++tot] = x;
  }
	// 这部分代码是查找树的重心模板，参考了 OI-Wiki。
}
int dfs2(int x, int fa) {
	// 这部分代码用于判断子树大小。
  int res = 1;
  for (int i : v[x]) {
    if (i == fa) continue;
    res += dfs2(i, x);
  }
  return res;
}
signed main() {
  cin >> n;
  for (int i = 1, x, y; i < n; i++) {
    cin >> x >> y;
    v[x].pb(y), v[y].pb(x);
		// 输入，存图。这里用 std:vector<int> 来代替邻接表。
  }
  for (int i = 1; i <= n; i++) {
    if (v[i].size() == 1 && !mp[i]) {
      ans[++idx] = i, mp[i] = 1;
			// 如果这个节点是叶子结点，纪录答案。
    }
  }
  dfs(1, N - 2); // 寻找重心。
  for (int k = 1, i; k <= tot; k++) { // 以此判断重心是否满足条件。
    i = c[k];
    int x = -1, f = 0;
    for (int j : v[i]) {
      int t = dfs2(j, i); // dfs2 得到的是一棵子树的大小，这里判断是否一样。
      if (x != -1 && t != x) {
        f = 1; // 如果子树大小不一样，退出循环。
        break;
      }
      x = t;
    }
    if (f == 0 && !mp[i]) {
      ans[++idx] = i, mp[i] = 1;
			// 如果满足要求，纪录答案。
    }
  }
  sort(ans + 1, ans + 1 + idx); // 排序，并且输出。
  for (int i = 1; i <= idx; i++) {
    cout << ans[i] << " ";
  }
  return 0;
}
```

---

## 作者：sukimo (赞：3)

简易树上操作。题目没有给根那干脆就以$1$号点为根嘛。一遍dfs处理出每个节点作为根节点子树的大小，然后直接一个一个点判断即可。可以用大减小来判断上方子树的大小。

$code:$

```
#include<cstdio>
const int MX=1000003;
int fir[MX],fa[MX],sz[MX];struct STR{int to,nxt;}edge[MX<<1];
void add(int u,int v,int pos){
	edge[pos].to=v;edge[pos].nxt=fir[u];fir[u]=pos;
}
void dfs(int now){
	sz[now]=1;
	for(int i=fir[now];i;i=edge[i].nxt){
		int qck=edge[i].to;if(fa[now]==qck)continue;fa[qck]=now;dfs(qck);sz[now]+=sz[qck];
	}
}
bool ok(int now){
	int ask=(now-1?sz[1]-sz[now]:sz[edge[fir[now]].to]);
	for(int i=fir[now];i;i=edge[i].nxt){
		int qck=edge[i].to;if(fa[now]==qck)continue;if(sz[qck]!=ask)return 0;
	}
	return 1;
}
void qin(int &x){
	x=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c<='9'&&c>='0'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
}
void qout(int x){
	if(x>9)qout(x/10);putchar(x%10+48);
}
int main(){
	int n;qin(n);
	for(int i=1;i<n;i++){
		int u,v;qin(u);qin(v);add(u,v,i);add(v,u,n-1+i);
	}
	dfs(1);for(int i=1;i<=n;i++)if(ok(i)){qout(i);putchar(' ');}
	return 0;
}
```


---

## 作者：望月野QwQ (赞：2)

# 1.题意分析

有一颗树，已知树的所有边，任意选择一个节点为根，与根节点相连接的所有子树的节点数相同。求所有合法的节点。

# 2.题目分析

看到题目最先想到暴力遍历，但是 subtask 2 中 $n \le 10^6$ 显然这就不太行,只有 $40pts$ 。

所以考虑 dfs 中直接处理。所以我们从 $1$ 开始遍历 记录部分子树的数量判断一下适量是否相同就好啦
`if(x!=1&&num&&num!=n-e[x])root[x]=0;`
这里注意判断点是不是叶节点。

然后我们不断变化树根就可以求得解了。

# 3.代码
```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#define long long int 
using namespace std;
vector<int>l[10000005];
bool root[10000005];
int e[10000005],n;
void dfs(int x,int fa)
{
	int num=0;
	root[x]=1;
	for(int i=0;i<l[x].size();i++)
		if(l[x][i]!=fa)
		{	
			dfs(l[x][i],x);
			e[x]+=e[l[x][i]];
			if(!num)
			{
				num=e[l[x][i]];
			}
			if(num!=e[l[x][i]])root[x]=0;
		}
	e[x]++; 
	if(x!=1&&num&&num!=n-e[x])root[x]=0;
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		l[x].push_back(y);
		l[y].push_back(x);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
	{
		if(root[i])cout<<i<<" ";
	}
	return 0;
}
```

---

## 作者：云雷心柠檬听 (赞：1)

### 题意简述

给出一棵无根树，求以那些节点为根时，与它直接相连的节点，它们的子树大小都相同。

### 思维路径

首先，显而易见的是，在 $1 \le n \le 10^6$ 的数据范围下，我们不可能通过对每个节点作为根判断一次。因此，我们考虑选取一个节点为根计算全部。

我们作图来分析一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/b9f4c6z1.png)

如上图，我们针对 $2$ 号节点来做分析。首先我们默认以 $1$ 号节点为根，与 $2$ 号直接连接的有 $1$ 号节点、$3$ 号节点、$4$ 号节点。

其中我们在遍历时，可以直接得到以 $3$ 号节点为根的子树大小和以 $4$ 号节点为根的子树大小。

紧接着，当 $2$ 号节点为整个树的根时，形态如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/hylld10s.png)

可以发现，此时以 $1$ 号节点为根的子树中有 $1$ 号和 $5$ 号两个节点，再回到第一张图，可以发现正是红圈圈出的部分，即除了 $2$ 号节点为根的子树外的所有节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/co8uq7uz.png)

它的子树大小就是总节点个数 $n$ 减去 $2$ 号节点的子树大小。

推及所有节点在访问时，只需将其子树大小互相比较，再与 $n$ 减去它本身的子树大小比较，全部相等即可记录答案。

### 实现细节

全程序的核心集中在 DFS 的遍历上。

_注：主函数中默认根为 $1$，$1$ 的父节点为 $0$。_

首先我们定义两个变量。

```cpp
int t=-1,ys=1;
```

其中 $t$ 记录了子树大小，$ys$ 表示子树是否全部相等，全部相等则为 $1$，否则则为 $0$ 。

```cpp
for(int i=hd[u];i;i=e[i].nxt){
	int v=e[i].to;
	if(v==fa) continue;
	dfs(v,u);
	sz[u]+=sz[v];
	if(t==-1) t=sz[v];
	else if(t!=sz[v]) ys=0;
}
```

紧接着是 DFS 的核心部分，$sz$ 数组用来记录子树大小。

当 $t$ 的值为 $-1$ 时，说明这是第一棵被访问到的子树，因此记录子树大小。

否则就应进行比较，若不相等，设定 $ys$ 值为 $0$，因为还要找其它节点是否符合，所以这里不能提前跳出。

```cpp
sz[u]++;
if(t!=-1&&n-sz[u]!=t&&n-sz[u]!=0) ys=0;
if(ys) ans[++nA]=u;
```

最后在子树中增加自身，并判断除自己子树以外的情况。

此处 $t$ 若等于 $1$，则说明改节点是叶子节点，没有子树，需跳过。

若 $n$ 减去该子树大小与其他子树大小相同，说明符合条件，$ys$ 的值也应保持为 $0$。

若 $n$ 减去该子树大小恰好等于 $0$，说明这是 $1$ 号节点，也需跳过。

最后记录答案。

根据题目输出格式中**从小到大的整数**，需要排序。

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000009;
int n,sz[N],nE,hd[N],nA,ans[N];
struct edge{
	int to,nxt;
} e[N<<1];

void add(int u,int v){
	e[++nE]=(edge){v,hd[u]};
	hd[u]=nE;
}

void input(){
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
} 

void dfs(int u,int fa){
	int t=-1,ys=1;
	for(int i=hd[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u);
		sz[u]+=sz[v];
		if(t==-1) t=sz[v];
		else if(t!=sz[v]) ys=0;
	}
	sz[u]++;
	if(t!=-1&&n-sz[u]!=t&&n-sz[u]!=0) ys=0;
	if(ys) ans[++nA]=u;
}

void solve(){
	dfs(1,0);
	sort(ans+1,ans+nA+1);
	for(int i=1;i<=nA;i++){
		cout<<ans[i]<<" ";
	}
}

int main(){
	input();
	solve();
	return 0;
}
```


---

## 作者：住在隔壁小莘 (赞：1)

最近做了不少有关树的问题。


去博客食用更加哦~[我的博客](https://www.luogu.com.cn/blog/gebixiaoxin/)。

[题目](https://www.luogu.com.cn/problem/P6591)

## 题目分析：

当一个点为根时，与**它直接相连的节点，他们的子树大小都相同**，这句话

在题目中着重使用粗体，那么我们要先理解这句话。“与**它**”中的它就是

我们指的作为根节点的节点，“**直接**相连节点的**子树**大小都相同”

![样例](https://cdn.luogu.com.cn/upload/image_hosting/8dvy0bko.png)

在此样例中，与一号节点相连的有二号节点与三号节点，他们的子树大小分别为 
 `2` 和 `4`，那我们不妨把与一号节点直接相连的也算上，就为 `3` 和 `4` 了，方便后面使用。


## 讲解：

既然要求直接相连的节点的子树大小都相同，那我们肯定是要先求出来每个点的子树大小，所以先遍历一遍并求出**每个点的子树大小**。

```cpp
int dfs(int now,int fa){//单纯的求每个点的子树大小，dfs中的其他代码暂时删去了
	for(int i=head[now];i;i=p[i].nex){
		int to=p[i].to;
		if(to==fa){//如果下一个所指的节点为父亲，那么跳过
			continue;
		}
		d[now]+=dfs(to,now);//d[i]数组为i号节点的子树大小，这里开始递归求自己子树大小
	return d[now];//返回大小
}
```

那我们该如何判断所连节点的子树大小是否相等呢：我们可以设一个 $num$ 来存。

```cpp
int to=p[i].to;
if(!num){//记录第一个所连节点的子树大小
			num=d[to];
		}
		if(num!=d[to]){//如果与先前的不一样，说明不满足条件，直接root=0
			root[now]=0;//root[i]是表示节点i是否能作为根
		}
	}
	d[now]++;//注意是在这里加上1
	if(now!=1&&num&&num!=n-d[now]){
		root[now]=0;
	}
```

 1. 如果 $num$ 还是 `0`，即 $x$ 是叶子结点，直接跳过。
 2. 如果 $x=1$（根节点）直接跳过，这个根节点是自己设的，因为是个无根树。

```cpp
if(now!=1&&num&&num!=n-d[now]){
		root[now]=0;
	}
```


 **整个DFS**：
```cpp
int dfs(int now,int fa){
	root[now]=1;//一开始都认为可以，root[i]是表示节点i是否能作为根
	int num=0;//记录所连各节点的子树大小，配合下文注释与代码理解
	for(int i=head[now];i;i=p[i].nex){
		int to=p[i].to;
		if(to==fa){
			continue;
		}
		d[now]+=dfs(to,now);//d[i]数组为i号节点的子树大小，这里开始递归求自己子树大小
		if(!num){//记录第一个所连节点的子树大小
			num=d[to];
		}
		if(num!=d[to]){//如果与先前的不一样，说明不满足条件，直接root=0
			root[now]=0;
		}
	}
	d[now]++;自增，算上自己，为下面num!=n-d[now]表明
	if(now!=1&&num&&num!=n-d[now]){
		root[now]=0;
	}
	return d[now];
}
```

接下来就是用链式前向星连边，注意是无向的所以建双向边，$root[i]$ 如果为 `1`，那么就输出 $i$，~~灰常的简单~~。

### Code:

```cpp
#include<iostream>
using namespace std;
int n;
struct edge{
	int nex,to;
	edge(int nex_=0,int to_=0){
		nex=nex_,to=to_;
	}
}p[2001000];
int root[2000100],cnt,head[2000100],d[2000100];//d存该点的子树大小，root表示该点是否可以为根
void add(int from,int to){//连边
	p[++cnt]=edge(head[from],to);
	head[from]=cnt;
}
int dfs(int now,int fa){//大法师
	root[now]=1;
	int num=0;
	for(int i=head[now];i;i=p[i].nex){
		int to=p[i].to;
		if(to==fa){
			continue;
		}
		d[now]+=dfs(to,now);
		if(!num){
			num=d[to];
		}
		if(num!=d[to]){
			root[now]=0;
		}
	}
	d[now]++;
	if(now!=1&&num&&num!=n-d[now]){//好好理解这里
		root[now]=0;
	}
	return d[now];
}
int main(){
	cin>>n;
	int x,y;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++){
		if(root[i]){//如果可以就输出
			cout<<i<<" ";
		}
	}
}
```

**谢谢大家的阅读**，代码有借鉴的。

---

## 作者：二叉苹果树 (赞：1)

### 题意简述

求出所有作为根节点时, 各子树大小相同的节点.

### 数据分析

由于题目给的样例数据不具有代表性, 我们来看另外一组稍严格的数据.

```
7
1 2
1 3
2 4
4 5
4 6
3 7
```

根据上述数据自行画出示意图.

首先,我们默认以1号节点为根, 建树后用DFS求出此时各节点的子树大小.

若以 $ans_i$ 记录以1号节点为根节点时, 每棵子树的大小, 显然有 

$ans_1=7\ ,ans_2=4\ , ans_3=2\ ,  ans_4=3\ , ans_5=1\ ,ans_6=1\ ,ans_7=1$ .

接下来, 我们以2号节点为根节点, 可以发现, 现在2号节点新增了一颗子树, 来自于以1号节点为根节点时, 2号节点的父亲1号节点的另一部分子树. 

新增的子树的大小即为 $n-ans_i$, 此时2号节点新增子树的大小为 $n-ans_2=7-4=3$ .

再与2号节点的其他子树相比, 大小恰好相等, 所以2号节点可以作为目标节点.

同理, 再分别将其他各节点设置成根节点, 按照上述步骤判断是否满足题意即可.

### 代码实现

首先, 建树以及DFS求出各子树大小.

这里使用邻接矩阵建树, 下面是DFS部分代码.



```
void dfs(int s,int fa)
{
    ans[s]=1;
    for(int i=0;i<e[s].size();i++)
        if(e[s][i]!=fa)
        {
            dfs(e[s][i],s);
            ans[s]+=ans[e[s][i]];
        }
}
```

接下来, 在DFS的过程中用 $num$ 记录下各根节点第一颗子树大小, 并且在有新子树时与其进行比较, 若大小不相等则将该节点记为不满足题意, 这里用 $f_i$ 记录.

```cpp
    if(num==0)
        num=ans[e[s][i]];
    else if(num!=ans[e[s][i]])
        f[s]=0;
```

最后再判断 $num$ 与 $n-ans_i$ 的大小关系.

```cpp
    if(s!=1&&num&&num!=n-ans[s])
        f[s] = 0;
```
以下是完整代码.

```cpp
#include<iostream>
#include<vector>
using namespace std;
vector<int>e[1000005];
int ans[1000005];
int n,f[1000005];
void add(int u,int v)
{
    e[u].push_back(v);
}
void dfs(int s,int fa)
{
    ans[s]=1;
    int num=0;
    for(int i=0;i<e[s].size();i++)
        if(e[s][i]!=fa)
        {
            dfs(e[s][i],s);
            ans[s]+=ans[e[s][i]];
            if(num==0)
                num=ans[e[s][i]];
            else if(num!=ans[e[s][i]])
                f[s]=0;
        }
    if(s!=1&&num&&num!=n-ans[s])
        f[s]=0;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n-1;i++)
    {
        int u,v;
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    for(int i=1;i<=n;i++)
        f[i]=1;
    dfs(1,0);
    for(int i=1;i<=n;i++)
        if(f[i])
            cout<<i<<" ";
    cout<<endl;
    return 0;
}
```


---

## 作者：编程客 (赞：1)

## 思路

- 神搜一遍就可以了。
- 定义`f[i]` 表示节点`i`的子树大小（包括他自己）。
- `dfs` 时判断他的没颗子树的大小是否相同，最后再把整棵树的大小减去他自己的大小判断一下。
- 如果符合条件就加到`ans`数组了，最后排序输出就行了。
## 注意事项

- 数据范围很大（$10^6$），可能需要快读。
- 记得要把他的父亲判断了。
- 输出要排序。（我不知道要不要，反正我是排了序的）。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <vector> 
#include <algorithm>
using namespace std;
int n,s[1000005];
int ans[1000005];
vector<int> g[1000005];
void dfs(int u,int fa)					// 大法术 
{
	s[u]=1;
	int x=0,yes=1;
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i];
		if(v==fa) continue;				// 非父节点 
		dfs(v,u);
		s[u]+=s[v];						// 子树大小 
		if(x==0) x=s[v];
		else if(x!=s[v]) yes=0;
	}
	if(x!=0&&s[u]!=n&&n-s[u]!=x) yes=0;	//不要忘了父亲 
	if(yes==1)
	{
		ans[++ans[0]]=u;
	}
}
inline int read()						// 快读，抄别人的~ 
{
    int x=0;
    char ch=getchar();
    for(;!isdigit(ch);)ch=getchar();
    for(;isdigit(ch);)
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x;
}
int main()
{
	n=read();							// 读入 
	for(int i=1;i<n;i++)
	{
		int u,v;
		u=read();
		v=read();
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,0);
	sort(ans+1,ans+ans[0]+1);			// 答案排序 
	for(int i=1;i<=ans[0];i++)			// 输出 
	{
		printf("%d ",ans[i]);
	}
	return 0;
}
```


---

## 作者：nzcnnr (赞：0)

# 方法
一个一个点建树必定会超时，所以说我们就选择以一号点为根建树，此时便可以得到一个完整的树，而对于以叶子节点为根（入度为 $1$），则必定成立，对于中间任何一个非叶子且非根的节点为根，必然有一个父节点和多个子结点，子节点所形成的子树相较于以 $1$ 为根的树的子树不变，而此时这个新的根的父节点变成了它的子节点，而此时，我们可以发现，这个新产生的子树是原来的总结点个数减去以目前的根节点为根的子树。也就是说，对于一个有父亲也有儿子的节点，从 $1$ 为根的数统计出每个点的子树，存放在名为 $cnt$ 的数组里，此时若以 $i$ 号节点为根，那么 $cnt_1-cnt_i$ 便需要与i的子节点 $i_p$（$1\leq p \leq i$ 的总子节点数）所呈现的 ${cnt_{i_p}}$ 相等。

所以说需要 dfs 和判断即可。
# 代码实现
```c
#include<stdio.h>
#include<vector>
#include<queue>
#include<string.h>
using namespace std;
vector<int>map[1000005];
priority_queue<int,vector<int>,greater<int> >ans;//自动排序优先队列
int n;
int numf[1000005];
bool visit[1000005];
int dfs(int num){
	visit[num]=1;
	for(int i=0;i<map[num].size();i++){
		if(visit[map[num][i]]!=1){
			numf[num]+=dfs(map[num][i]);
		}
	}
	return numf[num];
}//将以1为根的树中所有的子树搜索出来
int main(){
	scanf("%d",&n);
	for(int i=1;i<=1000004;i++){
		numf[i]=1;//初始化
	}
	for(int i=1;i<=n-1;i++){
		int x,y;
		scanf("%d%d",&x,&y);//本题无需快读，scanf即可
		map[x].push_back(y);
		map[y].push_back(x);//无向图双向存边
	}
	dfs(1);
	for(int i=1;i<=n;i++){
		bool flag=0;
		if(map[i].size()==1){
			ans.push(i);
			continue;
		}//若该节点为叶子节点，则入队
		if(i==1){
			for(int j=0;j<map[i].size();j++){
				if(j!=0&&numf[map[i][j]]!=numf[map[i][j-1]]){
					flag=1;
					break;
				}
			}
		}//若该节点为根节点		
		else for(int j=0;j<map[i].size();j++){
			if(numf[1]-numf[i]!=numf[map[i][j]]&&numf[map[i][j]]<numf[i]){
				flag=1;
				break;
			}
		}//若该节点非叶子节点也非根节点
		if(flag==0){
			ans.push(i);
		}
	}
	int k=ans.size();
	for(int i=0;i<k;i++){
		printf("%d ",ans.top());
		ans.pop();//答案输出，不要忘记pop
	}
	return 0;
}
```

---


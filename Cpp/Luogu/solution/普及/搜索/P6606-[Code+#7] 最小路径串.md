# [Code+#7] 最小路径串

## 题目描述

$n$ 个点 $m$ 条边的无向图中，所有点用从 `0` 开始的 `6` 位数字串编号，即 `000000`、`000001`、`000002`、……直到 $n-1$ 对应的 $6$ 位数字串。保证 $n\le 10^6$，所以 $6$ 位的编号不会溢出。

对于除了 `000000` 以外的每个点，你需要找到一条从 `000000` 出发且不经过重复点的路径，使得路径上所有点的数字串顺次连接形成的串的字典序最小。比较两个不同的串的字典序的方法是：如果其中某个串是另一个的前缀，则较短的串字典序较小；否则，找出两个串从左往右扫描时遇到的首个不相等的位置，在这个位置上的数字较小的串字典序较小。

由于输出路径过于麻烦，你不需要完整地输出路径，只需要将路径上所有点的数字串视作一个整数，输出这个数对 $998244353$ 取模的结果。

## 说明/提示

### 样例解释

- 从 `000000` 到 `000001` 所求的路径对应的串为 `000000000002000001`。
- 从 `000000` 到 `000002` 所求的路径对应的串为 `000000000002`。
- 从 `000000` 到 `000003` 所求的路径对应的串为 `000000000002000001000003`，对 $998244353$ 取模后为 $517560944$。
- 从 `000000` 到 `000004` 不存在路径。

### 子任务

子任务 $1$（$11$ 分）
- $1\le n\le 10^6, m = 0$。

子任务 $2$（$55$ 分）
- $1\le n\le 10, 0\le m\le20$。

子任务 $3$（$34$ 分）
- $1\le n\le 10^6, 0\le m\le 10^6$。

## 样例 #1

### 输入

```
5 5
000000000003000001000003000001000002000002000000000002000003```

### 输出

```
2000001
2
517560944
-1```

# 题解

## 作者：blankslpl (赞：4)

# P6606 [Code+#7] 最小路径串
### 思路：
- 考虑 dfs。
- 可以先将边从小到大排序，这样第一次到达这个点的时候路径的字典序肯定是最小的。
- 这里我用的是邻接表存图，接下来就是 dfs ，每次将路径串加上当前的编号就行。

### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define _ read<int>()
template <class T>T read()
{
	T r=0,f=1;char c=getchar();
	while((c>'9'||c<'0')&&c!='-') c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return f*r;
}
inline void out(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int maxn=1e6+5,mod=998244353;
int n,m,head[maxn],cnt,ans;
int len[maxn];
bool vis[maxn];
char s[24*maxn];
string str;
struct node
{
    int to,next;
}e[maxn<<1];
void add(int u,int v)//链式前向星
{

    e[++cnt].next=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
void dfs(int son,int dis)//dfs
{
    len[son]=dis;
    set<int> se;
    for(int i=head[son];i;i=e[i].next)
	{
        se.insert(e[i].to);
    }
    for(set<int>::iterator ite=se.begin();ite!=se.end();ite++)
	{
        if(!vis[*ite])
		{
            vis[*ite]=1;
            dfs(*ite,(dis*1000000+*ite)%mod);
        }
    }
}
signed main()
{
    memset(len,-1,sizeof(len));
	n=_,m=_;
    scanf("%s",s+1);
    int d=strlen(s+1);
    for(int i=1;i<=d;i+=12)
	{
        int v=0,u=0;
        for(int j=i;j<=i+11;j++)
		{
            if(j<i+6)
			{
                v=v*10+s[j]-'0';
            }
			else
			{
                u=u*10+s[j]-'0';
            }
        }
        add(v,u),add(u,v);
    }
    vis[0]=1;
    dfs(0,0);
    for(int i=1;i<n;i++)
	{
		out(len[i]);
        putchar('\n');
    }
    return 0;
}
```
最后提醒一下
#### 十年OI一场空，不开 long long 见祖宗。

---

## 作者：opzc35 (赞：3)

## 题意

[题目跳楼机](https://www.luogu.com.cn/problem/P6606)

给你 $n$ 个点，每个点有一个编号。每个节点也有一个路径编号，长度为 $6$ 位，构造为：这个节点的编号保留 $6$ 位，不足为 $0$ 代替（数据保证节点编号不会溢出）。

请你求从 $000000$ 到每一个点的路径编号并列存为一个字符串，转为 int 后对 $998244353$ 取模。

## 分析

考虑使用 dfs。

可以先将边从小到大排序，这样第一次到达这个点的时候路径的字典序肯定是最小的。

这里我用的是邻接表存图，接下来就是 dfs，每次将路径串加上当前的编号就行。

细节：如何将 int 后面加一串数字？可以尝试将原来数字 $\times10^6$ 之后再加就可以实现 int 的在末尾增加数字。

## 代码

```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define ll long long
using namespace std;
int n,m;
vector<int> g[1000005];
ll ans[1000005];
bool vis[1000005];
void dfs(int u,ll now){
	ans[u]=now;
	for(auto v:g[u]){
		if(ans[v]!=-1)continue;
		dfs(v,(now*1000000+v)%mod);
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x=0,y=0;
		for(int j=1;j<=6;j++){
			char q;
			cin>>q;
			x=x*10+q-48;
		}
		for(int j=1;j<=6;j++){
			char q;
			cin>>q;
			y=y*10+q-48;
		}
        if(x==y){
            continue;
        }
		g[x].push_back(y);
		g[y].push_back(x);
	}
	memset(ans,-1,sizeof ans);
	for(int i=0;i<=n;i++){
		sort(g[i].begin(),g[i].end());
	}
	dfs(0,0);
	for(int i=1;i<n;i++){
		cout<<ans[i]<<"\n";
	}
	return 0;
}
```

## TIPS

记得处理重边和自环。

---

## 作者：FZY_CZY (赞：2)

我原本以为这道题可能是树形 DP 什么的，一看是黄，突然就感觉没事了。

# 题意
[题目](https://www.luogu.com.cn/problem/P6606)

这道题其实就是给一个图中的每个点赋予一个值，现在问我们怎么样去遍历，使得这个遍历的字典序最小。
# 思路
## 算法
显然的，我们应该用 dfs 算法来实现这道题，一方面是这种图的遍历貌似只有深搜能满足，另一方面是深搜好写。

但是我们要注意一下输入方面，这种存图方式类似于邻接矩阵（个人理解），告诉你哪两个点是相通的，图论有问题的推荐去看这篇[博客](https://blog.csdn.net/cqbzliuhongyi/article/details/127281493?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522608ae7ec4fa551f29066dbe424c52a5b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=608ae7ec4fa551f29066dbe424c52a5b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127281493-null-null.142^v101^pc_search_result_base7&utm_term=%E5%9B%BE%E8%AE%BA&spm=1018.2226.3001.4187)。

然后直接 dfs 爆搜一遍，更新答案就 OK 了。
## 存储方式
我们来用邻接表来存图，因为在 $10^7$ 面前，如果硬要用邻接矩阵来的话，就会爆内存，所以用邻接表会好一些，再考虑优化一下内存，那么我们就可以用 `vector` 来存储，这样明显能让我们的内存变小，防止内存不够用，而且我们的 `vector` 加入一个节点直接 `push_back()` 就好了，会方便许多，STL 有很多方便我们实现算法的容器。

遍历图真的没什么好讲的，就是遍历每个节点，然后把这个节点对应的边递归下去，把节点都遍历一遍，这样就是我们 dfs 的特点了。
## 细节
重边和自环就需要让我们注意一个细节，那就是不遍历已经遍历过的节点，建议开一个 state 数组，bool 类型，每次遍历都将这个点设为 true（定义时的初始值是 false），然后就可以排除掉重边和自环了。

然后就是取模，建议用 `const` 或者 `#define`，这样不容易出错。 
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
const int Mod=998244353;//记得取模
typedef long long LL;
//long long还是很重要的
int n,m;
vector<int>g[N];//vector防爆空间
LL ans[N];
void dfs(int u,LL now)//正常的 dfs 遍历图
{
	ans[u]=now;
	for (auto v:g[u])
	{
		if (ans[v]!=-1) continue;
		dfs(v,(now*1000000+v)%Mod);//取模
	}
}
int main(){
	cin>>n>>m;
	for (int i=1;i<=m;i++)
	{
		int x=0,y=0;
		for (int j=1;j<=6;j++)
		{
			char op;
			cin>>op;
			x=x*10+op-48;
		}
		for (int j=1;j<=6;j++)
		{
			char op;
			cin>>op;
			y=y*10+op-48;
		}
		//上面两个 for 是用来记录数字的，不然不好输入
        if (x==y) continue;
		g[x].push_back(y);
		g[y].push_back(x);
		//同上
	}
	memset(ans,-1,sizeof ans);//memset一遍-1主要作用是看这个节点是否遍历过
	for (int i=0;i<=n;i++)
		sort(g[i].begin(),g[i].end());//排序是方便我们对于这个图的遍历
	dfs(0,0);//用 dfs 来实现
	for (int i=1;i<n;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
``````
完结撒花！！！

---

## 作者：SUNCHAOYI (赞：2)

这道题目其实是一道搜索题目，但需要注意，所要查找的答案并不是要最小而是**满足路径上所有点的数字串顺次连接形成的串的字典序最小**。

因此我们便可以从一个点开始，找到连接该点的最小数字串。举个例子：

$
000001
\begin{cases}
000002\begin{cases}
000008\\
000007
\end{cases}\\
000003\\
000006
\begin{cases}
000004\\
000005
\end{cases}
\end{cases}
$

我们所得的最佳路径为 `000001-000002-000007`。用 `vector` 来储存边的值，存储完后将它进行**从小到大排序**，然后再进行**搜索**，每次找到相邻边的第一个未更新过的点，然后将其记录在答案之中。(为什么是第一个呢？因为在之前已排过序，所以第一个未更新的点一定是当前答案的最优解！)

最后就是如何记录答案，我们用 `ans[i]` 储存 $0$ 至 $i$ 的最优解，然后搜索得到的新点可以用 `(nowans * 1000000 + next) % mod` 记录，再举一个例子：   
$000002 ->000005$ 就是 $ 2 \times 10^6 + 5$。

注意：**这相当于一张无向图，且包含了重边与自环**。因此在处理的时候要注意这类特殊的情况。

----

最后是代码：
```
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
#define INF 0x3f3f3f3f
#define MOD 998244353
#define ll long long
#define MAX 2000005
using namespace std;
vector <ll> e[MAX];
ll ans[MAX]; 
bool cmp(int x,int y) {return x < y;}
void dfs(int st,ll s);
int main()
{
	int n,m;
	cin>>n>>m;
	memset(ans,-1,sizeof(ans));//初始化 
	for(int i = 1;i <= m;++i)
	{
		int a = 0,b = 0;char x;
		for(int j = 1;j <= 6;++j) cin>>x,a = a * 10 + x - '0';
		for(int j = 1;j <= 6;++j) cin>>x,b = b * 10 + x - '0';
		if(a != b)//不为重边 
			e[a].push_back(b),e[b].push_back(a);//无向边 
	} 
	for(int i = 0;i < n;++i) sort(e[i].begin(),e[i].end(),cmp);//排序 
	dfs(0,0);
	for(int i = 1;i < n;++i) cout<<ans[i]<<endl;
    return 0;
}
void dfs(int st,ll s)
{
	ans[st] = s;//更新答案 
	for(int i = 0;i < e[st].size();++i)
		if(ans[e[st][i]] == -1)//未更新过--未到过
			dfs(e[st][i],(s * 1000000 + e[st][i]) % MOD);//取模 
}
```

---

## 作者：ljk8886 (赞：1)

# 题意分析
这道题直接 DFS 就可以了，但是这道题的输入有点不一样。我们只需要一个一个字符的输入，用类似于快读的方法把每一个字符转成数字就可以了。**注意：要给邻接表从小到大排序，因为要求的是最小字典序。**

## 代码
```cpp
#include <bits/stdc++.h>
#define ft first
#define sd second
#define endl '\n'
#define pb push_back
#define md make_pair
#define gc() getchar()
#define pc(ch) putchar(ch)
#define umap unordered_map
#define pque priority_queue
using namespace std;
typedef double db;
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 bint;
typedef pair<int, int> pii;
typedef pair<pii, int> pi1;
typedef pair<pii, pii> pi2;
const ll INF = 0x3f3f3f3f;
inline ll read()
{
	ll res = 0, f = 1;
	char ch = gc();
	while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : f), ch = gc();
	while (ch >= '0' && ch <= '9') res = (res << 1) + (res << 3) + (ch ^ 48), ch = gc();
	return res * f;
}
inline void write(ll x)
{
	if (x < 0) x = -x, pc('-');
	if (x > 9) write(x / 10);
	pc(x % 10 + '0');
}
inline void writech(ll x, char ch) { write(x), pc(ch); }
const ll mod = 998244353;
const int N = 1e6 + 5, M = 1e6;
vector<ll> e[N];
ll ans[N];
void dfs(int u)
{
	for (auto v : e[u])
	{
		if (ans[v] != -1) continue;
		ans[v] = (ans[u] * M + v) % mod; // 计算答案 
		dfs(v);
	}
}
int main()
{
	memset(ans, -1, sizeof(ans));
	int n = read(), m = read();
	for (int i = 1; i <= m; i++)
	{
		int u = 0, v = 0; char ch;
		for (int j = 1; j <= 6; j++) cin >> ch, u = u * 10 + int(ch - '0'); // 对字符串进行处理 
		for (int j = 1; j <= 6; j++) cin >> ch, v = v * 10 + int(ch - '0'); // 同上 
		if (u != v) e[u].pb(v), e[v].pb(u); // 判自环
	}
	for (int i = 0; i < n; i++) sort(e[i].begin(), e[i].end()); // 排序 
	ans[0] = 0; // 对 0 点标记 
	dfs(0);
	for (int i = 1; i < n; i++) writech(ans[i], '\n');
	return 0;
}
```

---

## 作者：zzwdsj (赞：1)

[P6606 [Code+#7] 最小路径串](https://www.luogu.com.cn/problem/P6606)
### 题目大意
给定一个 $n$ 个点 $m$ 条边的无向图。求出起点 $0$ 到其他 $n-1$ **字典序最小**的路径。
### 思路
求起点出到每个点的路径可以用深搜求解。从起点开始，每次遍历相邻的、没被访问过的点，并记录下沿途经过的点。

至于如何保证字典序最小，可以使用贪心的思路，每次优先访问字典序更小的点。下面给出这个方法正确性的解释。

假设我们要求 $0$ 到 $1$ 的最小字典序路径，$0$ 可以到达 $2$ 和 $3$ 两个点。如果选择先到达点 $2$，后面不管是怎么走，开头 $12$ 位都是 $000000000002$；如果选择先到达点 $3$，后面不管是怎么走，开头 $12$ 位都是 $000000000003$。开头是 $000000000002$ 的字符串字典序一定比开头是 $000000000003$ 的字符串小。
### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char a,b,c,d,e,f;
int n,m;
vector<int>mp[1000001];//使用邻接表存储
int ans[1000001];//ans数组存储起点到每个节点的最小字典序路径。
void dfs(int x,int y)
{
	for(int i:mp[x])//mp[x]数组已经有序，从头到尾遍历一定先遍历到更小的元素。
		if(ans[i]==-1)//如果没访问到就去访问。
			ans[i]=(1000000LL*y+i)%998244353,//更新答案
			dfs(i,ans[i]);//继续搜索
}
int main()
{
	cin>>n>>m;
	memset(ans,-1,sizeof(ans));//初始化
	getchar();
	for(int i=1;i<=m;i++)
	{
		scanf("%c%c%c%c%c%c",&a,&b,&c,&d,&e,&f);
		int x=100000*(a-'0')+10000*(b-'0')+1000*(c-'0')+100*(d-'0')+10*(e-'0')+(f-'0');
		scanf("%c%c%c%c%c%c",&a,&b,&c,&d,&e,&f);
		int y=100000*(a-'0')+10000*(b-'0')+1000*(c-'0')+100*(d-'0')+10*(e-'0')+(f-'0');
		if(x==y)continue;
		mp[x].push_back(y);//存边
		mp[y].push_back(x);
	}
	for(int i=0;i<n;i++)sort(mp[i].begin(),mp[i].end()); //使每个mp[x]数组有序。
	ans[0]=0;//起点到本身的最小字典序路径为0
	dfs(0,0);
	for(int i=1;i<n;i++)printf("%d\n",ans[i]);//输出
	return 0;
}
```

---

## 作者：Zheng_iii (赞：0)

## 思路
这是一道 DFS 的题，我们把题中的超长数字串转换成边和点的信息，由于它需要字典序最小的路径，我们把每个点所连向的点的编号从小到大进行排序，然后使用数组来记录该点是否被更新过，第一个没有被更新过的点一定是当前答案的最优解。

记得判自环。
## AC 代码

```cpp
#include<bits/stdc++.h>
#define debug(a) cout<<#a<<"="<<a<<'\n';
#define il inline
using namespace std;
using ll = long long;
using ull = unsigned long long;
const int maxm = 1e6+10;
const int MOD = 998244353;
#define int long long

int n,m,a[maxm],b[maxm],ans[maxm];
char c;
vector<int> g[maxm];

void dfs(int u){
	for (auto v : g[u]){
		if (ans[v] != -1) continue;
		ans[v] = (ans[u] * 1000000 + v) % MOD;
		dfs(v);
	}
}

signed main(){
	// freopen("text.in","r",stdin);
	// freopen("text.out","w",stdout);
	ios::sync_with_stdio(0),cout.tie(0),cin.tie(0);
	cin>>n>>m;
	for(int i = 1;i <= m;i++){
		for(int j = 1;j <= 6;j++){
			cin>>c;
			a[i] = a[i]*10 + c - 48;
		}
		for(int j = 1;j <= 6;j++){
			cin>>c;
			b[i] = b[i]*10 + c - 48;
		}
		if(a[i] == b[i])continue;
		g[a[i]].push_back(b[i]);
		g[b[i]].push_back(a[i]);
	}
	for(int i = 0;i < n;i++)sort(g[i].begin(),g[i].end());
	memset(ans,-1,sizeof(ans));
	ans[0] = 0;
	dfs(0);
	for (int i = 1; i < n; i++)cout<<ans[i]<<'\n';
	return 0;
}

```

---

## 作者：LNYZY (赞：0)

## 思路：
由于要找到字典序最小的路径，我们可以借助优先队列（按照路径形成的串的字典序来定义优先级）结合广度优先搜索（BFS）的方式来遍历图。  
将起始节点 $000000$ 及其对应的初始路径（只包含 $000000$ 自身）放入优先队列中，优先队列根据路径形成的字符串字典序来进行排序，字典序小的路径优先弹出。
在每次循环中，取出优先队列头部的节点及其对应的当前路径：
如果当前节点是目标节点（除 $000000$ 外需要遍历的其他节点），则记录这条路径对应的整数（通过将路径上节点编号数字串顺次连接转换而来）对 $998244353$ 取模的结果，作为该目标节点的最终答案的一部分。  
遍历当前节点的所有邻接节点：  
如果邻接节点未被访问过，将其标记为已访问，然后把该邻接节点加入到当前路径的副本中（形成一条新的候选路径），并将这个邻接节点及其新路径放入优先队列中，等待后续按照字典序继续处理。

---

## 作者：_zhaosihan_qwq_ (赞：0)

# 题解：P6606 [Code+#7] 最小路径串
## 思路：
这道题好水，字典排序，不难发现，排序时使用贪心的算法，就是只考虑当前的最优结果，只要是 $0-2$ 的排序，字符串开头肯定就是 $000000000002$ ，用 sort 排序即可，这样的解法，只要 $O(n)$ 处理一下就行了，最后结果肯定是最终答案。

---

## 作者：xiaoke2021 (赞：0)

简单题。从 $0$ 号点出发，求出到 $1$ 号点到 $n-1$ 号点中每个点的路径，使这些路径的 **字典序** 最小（注意不是路径长度）。

可以 $dfs$。按编号从小到大顺序搜索，如果某个点已经到达过了，那就肯定不会有更优的路径。

答案可以边搜索边存。用 $ans_i$ 存储点 $i$ 的答案，设 $ans_0=0$。对于一条边 $u \rarr v$（这里不是有向边，而是从点 $u$ 到点 $v$），此时点 $u$ 的答案已经确定了，那么根据同余定理可得 $ans_v=(ans_j \times 1000000) \bmod 998244353$。

至于输入，可以用 `scanf("%6lld%6lld",&u,&v)`。这段代码可以强制读取长度为 6 的两个整数。


```cpp
#include<bits/stdc++.h>
#define int long long //十年 OI 一场空，不开________见祖宗
using namespace std;
const int MAXN=1e7+5;
const int mod=998244353;
int n,m;
struct Edge{
	vector<int> e;
}E[MAXN];
int cnt=0;
bool vis[MAXN];
vector<int> t;
int ans[MAXN];
void dfs(int node){
	vis[node]=true;
	for(auto it=E[node].e.begin();it!=E[node].e.end();it++){
		if(!vis[*it]){
			ans[*it]=((ans[node]*1000000)%mod+*it)%mod;
      //边搜边算
			t.push_back(*it);
			dfs(*it);
			t.pop_back();
		}
	}
}
bool cmp(int a,int b){
	return a<b;
}
signed main(){
	cin>>n>>m;
	if(m==0){
		for(int i=1;i<n;i++) puts("-1");
		return 0;
	}
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%6lld%6lld",&u,&v);
		if(u!=v) E[u].e.push_back(v),E[v].e.push_back(u);
	}if(E[0].e.empty()){
		for(int i=1;i<n;i++) puts("-1");
		return 0;
	}
	for(int i=0;i<n;i++)
		if(!E[i].e.empty())
			sort(E[i].e.begin(),E[i].e.end()); //排序以保证字典序
	dfs(0);
	for(int i=1;i<n;i++){
		if(ans[i]!=0) cout<<ans[i]<<endl;
		else cout<<"-1\n";
	}
	return 0;
}
```

---


# 「DTOI-5」3-1

## 题目背景

——『太阳』这种东西，以前似乎是存在的。

传说是这么讲的——白色的火焰发出闪耀的光芒，天空则是清澄无比的蔚蓝。

据说诸神与其创造物所掀起的『大战』，使得大地化为焦土，灰烬遮蔽了苍穹。

灰烬冲击到天上流动的星辰之力——精灵回廊，发出了光芒，将天空染成红色。

而那样的红色，覆盖了仍然持续着互相残杀的每一块土地。

或者那是这个星球本身发出的悲鸣与流出的鲜血吧……

血色的天空上，只有——蓝色的灰飘然落下。

~~回来吧3579，我最骄傲的信仰/ll~~

## 题目描述

里克在视线可及的范围内发现了一颗古老的「神树」。

神树是一颗树，树上有 $n$ 个含有魔法装置的位置。经过初步「考察」，有 $n - 1$ 条魔法连接，第 $i(1 \leq i \leq n - 1)$ 条连接 $u_i, v_i$ 两个魔法装置，保证 $u_i \neq v_i$ 且 $1\leq u_i,v_i\leq n$。这两个装置可以相互**双向地**在 $1$ 单位时间内通行，保证仅由这 $n - 1$ 条连接，每个魔法装置都可以相互到达。

此外，有 $n - 1$ 条特殊连接，对于每个魔法装置 $i \in [2, n]$，可以**瞬间**传送到第 $1$ 个魔法装置，花费 $0$ 单位时间。**特殊连接总共只能使用一次**。

里克初始在魔法装置 $1$ 处。现在，给出这棵「神树」的结构，里克想要在若干时间内研究尽可能多的魔法装置。我们假定，研究一个魔法装置只需要到达该装置处，并且不需要花费额外时间。

里克想让你尽快计算出，对所有 $k \in [1, n]$，如果要恰好研究 $k$ 个不同的魔法装置，**并且随之返回魔法装置 $\bm 1$**，最少应花费多少时间。

## 说明/提示

**【样例解释 $\bm 1$】**

+ $k = 1$ 时，里克只需要呆在装置 $1$ 处。
+ $k = 2$ 时，里克的路径可以是 $1 \rightarrow 2 \Rightarrow 1$。
+ $k = 3$ 时，里克的路径可以是 $1 \rightarrow 2 \rightarrow 4 \Rightarrow 1$。
+ $k = 4$ 时，里克的路径可以是 $1 \rightarrow 2 \rightarrow 4 \Rightarrow 1 \rightarrow 3\rightarrow 1$。
+ $k = 5$ 时，里克的路径可以是 $1 \rightarrow 3\rightarrow 1 \rightarrow 2 \rightarrow 5 \rightarrow 2 \rightarrow 4 \Rightarrow 1$。

**【样例解释 $\bm 2$】**

这组数据满足测试点编号 $13 \sim 20$ 的性质。

**【数据规模与约定】**

| 测试点编号 | 特殊限制 |
| :--------: | :------: |
| $1 \sim 2$ | $n = 3$ |
| $3 \sim 4$ | $n = 5$ |
| $5 \sim 6$ | $n = 100$ |
| $7 \sim 8$ | $n = 1000$ |
| $9 \sim 10$ | $u_i = 1, v_i = i + 1$ |
| $11 \sim 12$ | $u_i = i, v_i = i + 1$ |
| $13 \sim 20$ | 无特殊限制 |

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq u_i, v_i \leq n$。

## 样例 #1

### 输入

```
5
1 2
1 3
2 4
2 5```

### 输出

```
0
1
2
4
6```

## 样例 #2

### 输入

```
见下发的 hope/hope2.in```

### 输出

```
见下发的 hope/hope2.ans```

# 题解

## 作者：irris (赞：18)

## Preface

$3 - 1 = $ 无望。

令 $1$ 号节点的深度为 $1$。

## Solution

### 直观的正面做法

贪心地考虑，让第 $i$ 个答案 $f(i)$ 由 $f(i - 1)$ 推出。初始值 $f(1) = 0$。

首先 $f(i) \geq f(i - 1) + 1$。通过简单搜索可以得到 $D$ 表示树上 $1\sim n$ 节点的最大深度，那么对于 $i \leq D$，我们从 $1$ 向下依次取一条长度为 $i - 1$ 的不回头的路径，这样取到 $f(i) = i - 1$ 显然不会更劣。若 $i \gt D$，那么由于我们已经贪心地把前 $i$ 个点取完了，所以看样子不能直接 $+1$ 了？

但我们同样知道，可以通过在路径上取一个节点 $u$ 和它的一个未被访问的儿子 $v$，使得原路径由 $\dots \rightarrow u \rightarrow \dots$ 变为 $\dots \rightarrow u \rightarrow v \rightarrow u \rightarrow \dots$，且增加一个访问过的节点。故 $f(i) \leq f(i - 1) + 2$。

那么 $f(i) - f(i - 1)$ 为 $1$ 或 $2$，具体取值只需要比较 $i$ 和 $D$ 的大小关系即可。

### 简洁的反面证明

如果没有传送操作，那么 $f(i) = 2(i - 1)$，原因是考虑每一条边恰好经过两遍。通过传送操作，我们可以向 $f(i)$ 减少从选择的节点连通块其中一个节点返回根的路径长度，这个长度的最大值即为 $\min(i, D) - 1$。故 $f(i) = i + \max(D - i, 0) - 1$。

## Postscript

大样例是一条链。

---

## 作者：Wf_yjqd (赞：11)

也不是很难吧。没想到就做这一题能进前 $200$ 名。

------------

显然，不管树是怎么样的，一定可以花 $x\times2$ 的代价到 $x$ 个点。

那么，我们直接考虑那一次操作要怎么用好了。

他就相当于花 $x$ 的代价到 $x$ 个点，所以，我们一定考虑树上最大的分支用这个操作。

那如何求此时的 $x$ 呢？

考虑最多情况下能优化的代价为树最深的一个点的深度，所以直接求它和需要到的点数的最大值就好了。

综上，第 $i$ 次询问的答案为 $(i-1)\times2-\min(i-1,x)$。

注意，此时根节点的深度为 $0$。

------------
代码？

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+84;
struct Sherry{
    int to,ne;
}e[maxn];
int n,u,v,maxx,ecnt=1,head[maxn],d[maxn],dep[maxn];
void add(int u,int v){
    e[ecnt]={v,head[u]};
    head[u]=ecnt++;
    d[v]++;
    return ;
}
void dfs(int x,int fa){
    dep[x]=dep[fa]+1;
    if(x!=1&&d[x]==1){
        maxx=max(maxx,dep[x]);
        return ;
    }
    for(int i=head[x];i;i=e[i].ne)
        if(e[i].to!=fa)
            dfs(e[i].to,x);
    return ;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<n;i++){
        scanf("%d%d",&u,&v);
        add(u,v);
        add(v,u);
    }
    dep[0]=-1;
    dfs(1,0);
    for(int i=1;i<=n;i++)
        printf("%d\n",(i-1)*2-min(i-1,maxx));
    return 0;
}
```


---

## 作者：PP__ (赞：3)

这是一道优质思维题。

我们可以逆推，先考虑 $k=n$ 的情况。

首先我们知道，“特殊连接”肯定要省下最多的步数。什么意思？因为我们没有特殊连接，遍历整棵树的总步数一定不变。那么，我们因为最后要返回根，所以每条边都要走两次（一来一回，类似深搜遍历的顺序）。那么如果我们从一个叶子节点直接跳回根，我们就省下了这个叶节点到根的距离这么多的步数。所以，我们要找的是距离子节点最远的叶子节点，从这个节点直接跳回根。那么这个距离自然而然地就是最大深度的节点的深度再减一了。

设这个距离为 $l$。将这个节点和根的路径称为“最长链”。

接下来考虑 $l<k< n$ 的情况。考虑线性递推。$f(n) = f(n + 1) - 2$。为什么？

简化一下，其实我们就是不断地从一颗树上拿下来一个节点。因为我们如果从最长链上拿走一个节点，这个最少步数只会减去一。为什么？因为最长链上的节点并不用回退，返回根的操作由特殊连接来完成。所以当 $l<k< n$ 时，我们实际上的操作是从一颗树上拿下来一个个叶节点，这些叶节点遍历时，一定是遍历完立刻返回，遍历它所需要的步数为 $2$。那么不遍历它，自然步数就会减二。最后，拿完了所有除了最长链之外的节点，树就会退化成链。

所以当 $1\leq k \leq l$ 时，$f(n) = f(n + 1) - 1$。读者自证不难。

上代码：
```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
vector<int> g[100010];
int t,cnt[100010],dep[100010],mdep,f[100010];
void dfs(int u,int fa)
{
	for (int i = 0;i < g[u].size();i++)
	{
		int v = g[u][i];
		if(v == fa)continue;
		dep[v] = dep[u] + 1;
		dfs(v,u);
		cnt[u] += cnt[v];
		cnt[u] += 2;
	}
}
int main()
{
	int n;
	cin >> n;
	for (int i = 1;i < n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,0);
	for (int i = 1;i <= n;i++)mdep = max(mdep,dep[i]);
	f[n] = cnt[1] - mdep;
	for (int i = n - 1;i > mdep;i--)f[i] = f[i + 1] - 2;
	for (int i = mdep;i >= 1;i--)f[i] = f[i + 1] - 1;
	for (int i = 1;i <= n;i++)
	{
		printf("%d\n",f[i]);
	}
}
```

---

## 作者：船酱魔王 (赞：2)

# P9304 「DTOI-5」3-1 题解

## 题意回顾

有一棵 $ n $ 个点的无向无权且根为 $ 1 $ 的树，你可以用**一次**特殊技能，从 $ 1 $ 点到达任意点或回到 $ 1 $ 点，不耗时间。$ \forall 1 \le i \le n $，你需要设计一条以 $ 1 $ 为起终点的环路，使得你经过不重复的 $ i $ 个点，且时间最少。

## 分析

定义根节点深度为 $ 0 $，**向下**意为深度增加。

当没有特殊技能时，我们每向下到达一个点和向上离开一个点需要经过两次这个点上面的边，所以答案为 $ 2 \times (i-1) $。

当拥有特殊技能时，我们发现可以让向下到达或向上离开一个点的过程加速，因为是环路，这本质上是等价的。当我们加速向上离开这个点的过程时，会节约这个点的深度的时间，因此，我们想让经过的点的最大深度最大。而有 $ i $ 个点要被经过的时候理论最大深度为 $ i-1 $。

因此，用 dfs 求出整棵树最大深度为 $ d $，对于要经过 $ i $ 个点的情况，答案为 $ 2 \times (i-1) - \min\{i-1,d\} $。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 1e5 + 5;
int n;
vector<int> g[N];
int dep[N];
int mxdp = 0;
void pre_dfs(int u, int la) {
	dep[u] = dep[la] + 1;
	mxdp = max(mxdp, dep[u]);
	for(int i = 0; i < g[u].size(); i++) {
		if(g[u][i] == la) {
			continue;
		}
		pre_dfs(g[u][i], u);
	}
}
int main() {
	cin >> n;
	int u, v;
	for(int i = 1; i < n; i++) {
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dep[0] = 0;
	pre_dfs(1, 0);
	mxdp--;
	for(int i = 1; i <= n; i++) {
		cout << (i - 1) * 2 - min(mxdp, i - 1) << endl;
	}
	return 0;
}
```

---

## 作者：Untitled10032 (赞：2)

这题主要的难度在想解法这一步，实现较为简单。

## 题意

给定一棵树，对于每个 $k \in [1, n]$，求出总共经过 $k$ 个**不同**节点之后返回根节点（$1$ 号节点）的最短路径，其中，每条路径都可以有一次“瞬移”回根节点的机会。

## 部分分

- $n = 3$ 和 $n = 5$ 时直接暴力求解即可。（可以考虑控制最大深度不超过 $2n$ 的 DFS）。
- 测试点 $9-10$，“菊花图”，可以 $O(1)$ 算出。路径只可能是从 $1$ 号点出发，去某个其它点，再回来，再去某个其它点……中途用一次“瞬间传送”。
- 测试点 $11-12$，图为一条链，即大样例里的情况。第 $i$ 行输出 $i - 1$ 即可。

## 正解

我们可以先不考虑“瞬移”。此时可以发现每个边如果被经过，那么它必定被经过了 $2$ 次；且有 $k$ 条边被经过（$2$ 次）时，必定有 $k + 1$ 个点被经过。

![](https://cdn.luogu.com.cn/upload/image_hosting/vyg5w9yp.png)

那么需要经过 $k$ 个不同节点时，就需要走过 $2(k - 1)$ 条边。

------------

再考虑“瞬间传送”的情况，什么时候“瞬间传送”回根节点收益最大呢？在上面的图中，明显应该在 $7$ 号节点时使用“瞬间传送”，此时可以少经过 $3$ 条边。

**要使路径最短，那么就应该选择在离根节点最远的那个节点使用“瞬间传送”。**

任何节点都可以在保证该走的节点都被走了的前提下使用“传送”：对于任意的树上的任意节点，都可以构造出一条路径，使得从这个节点回到根节点的过程中，没有经过之前从未经过的节点（即使用“瞬间传送”与不使用等效，例如上图中路径 $1 \rightarrow 2 \rightarrow 4 \rightarrow 2 \rightarrow 5 \rightarrow 2 \rightarrow 1$，从 $4$ 号节点回到 $1$ 号节点的过程中，经过了从未经过的 $5$ 号节点，不可以在 $4$ 号节点使用传送，但是路径可以改为 $1 \rightarrow 2 \rightarrow 5 \rightarrow 2 \rightarrow 4 \rightarrow 2 \rightarrow 1$，这样 $4$ 号节点到 $1$ 号节点之间没有未经过的节点，可以在 4 号节点使用传送）。

所以可以 DFS 找到以 $1$ 号节点为根的树的最大深度 $dep$，如果 $k \leq dep$，则可以沿着这条深度最大的路径一直走，走够了传送回来，此时 $k$ 的答案会比 $k - 1$ 多 $1$；如果 $k >  dep$，则最长路径会被走完，此时答案会比 $k - 1$ 多 $2$。

## code

```cpp
#include <iostream>
#include <vector>

using namespace std;
constexpr int N = 1e5 + 5;

vector<int> g[N];

int dfs(int now, int from) {
    int res = 0;
    for (auto next : g[now]) {
        if (next == from)    continue;
        res = max(res, dfs(next, now));
    }
    return res + 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int n;
    cin >> n;
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    const int max_dep = dfs(1, 0);
    int ans = -1;
    for (int i = 1; i <= n; i++) {
        if (i <= max_dep)  ans++;
        else    ans += 2;
        cout << ans << '\n';
    }
    return 0;
}
```


---

## 作者：RNTBW (赞：2)

### PART 0

赛时想到了结论，但是不想写。

## PART 1

给一棵树，每条边经过的时间为 1，有一次从任意节点瞬间跳上根节点的机会。

问走过 $i$ 个节点且回到根节点的最小时间。

## PART 2

~~我：这个题应该是~~ $O(n\log_2n)$ ~~的吧~~

_有一次从任意节点跳上根节点的机会。_

我们要使经过的边权最小，就需要在更深的地方上跳。

如果你在一个很浅的节点上跳了，那么你想继续访问更深的节点显然就要跑得更深还要跑上来，显然不优。

可以设两条链的长度为 $k,s,k>s$。

如果你在 $s$ 底部上跳，那么经过两条链所有的点的总时间就是 $s+2k$。

在 $k$ 底部上跳花费的总时间为 $2s+k$。

由于 $k>s$，所以 $2s+k<2k+s$。

这么算下去，肯定是在最深的节点上跳最优。

## PART 3

容易想到，我们先跑最深的链，这时每多访问一个点就会多走一条边。

但是在这条链外，由于新走了一个点还要往回走，所以它到父亲的那条边就会经过两次。

~~感性理解一下~~

所以我们可以把最深的链的长度 $k$ 算出来，之后

$\begin{cases}ans_i=ans_{i-1}+1(i\le k) \\ ans_i=ans_{i-1}+2(i>k)\end{cases}$

## PART 4

```cpp
#include<bits/stdc++.h>
using namespace std;
int head[100001];
int n,m,i,j,k,s,cnt;
struct eve
{
	int to,nxt;
} ed[200001];
void add(int x,int y)
{
	ed[++cnt].nxt=head[x];
	head[x]=cnt;
	ed[cnt].to=y; 
}
void dfs(int nr,int fa,int dp)
{
	k=max(k,dp);
	for(int i=head[nr];i;i=ed[i].nxt)
	{
		int v=ed[i].to;
		if(v!=fa)dfs(v,nr,dp+1);
	}
}
int main()
{
	scanf("%d",&n);
	for(i=1;i<n;i++)
	{
		scanf("%d%d",&k,&s);
		add(k,s);add(s,k);
	}
	k=0;dfs(1,0,1);s=k-1;
	for(i=1;i<=k;i++) printf("%d\n",i-1);
	for(i=k+1;i<=n;i++) s+=2,printf("%d\n",s);
	return 0; 
}
```

---

## 作者：Nuyoah_awa (赞：1)

### 题目大意

给定一棵树，你可以传送自己到 $1$ 一次，求经过 $i$ 个点回到点 $1$ 的最短路径。

### 题目分析

我们定义 $f_i$ 为从 $1$ 到 $i$ 的最短路径。

首先，如果 $i \le $ 最大深度。

我们可以直接从 $1$ 点一路往下然后在传送回 $1$。

所以 $\forall i \in [1, deep] f_i = i - 1$（$deep$ 为树的深度）。

当 $i > deep$ 时，我们可以分成两种情况考虑：

1. 我们可以在从 $1$ 走到头后回到 $1$ 后在继续往下走，但是由于没有传送的次数了，我们走够点后必须走回去，所以 $ans > deep + (deep - i) \times 2$。

2. 我们可以在已有的路径上再加一个点，例如：原有路径是 $u \to v$，我们可以使路径变为 $u \to w \to u \to v$。这样只加了两条边就多了一个点。很明显，由于这是一棵树，不存在环，所以如果只加一条边是不可能多经过一个点的，也就是说这是最优解。

于是，第 $2$ 种方法显然是更优的，这题就变为了一道 $dp$ 题。

$$f_i = \begin{cases} f_{i-1} + 1 & i \le deep \\ f_{i-1} + 2 & i > deep \end{cases}$$

### code
```cpp
#include <iostream> 
#include <cstdio>
#include <vector>

using namespace std;

const int N = 1e5 + 5, INF = 1e9;
int n, u, v, deep, mx, f[N];
bool cnt[N];
vector <int> e[N];

void get_deep(int x)
{
	if(cnt[x])
		return ;
	cnt[x] = true;
	deep++;
	mx = max(mx, deep);			//记录最大深度
	for(int i = 0;i < e[x].size();i++)
		get_deep(e[x][i]);
	deep--;					//记得回溯
	return ;
}

int main()
{
    scanf("%d", &n);
	for(int i = 1;i < n;i++)
	{
		scanf("%d %d", &u, &v);
		e[u].push_back(v);
		e[v].push_back(u);		//读入建双向边
	}
	get_deep(1);
	printf("0\n");
	f[1] = 0;				//f[1] 永远是 0
	for(int i = 2;i <= n;i++)
	{
		f[i] = f[i-1] + ((i > mx) ? 2 : 1);	//如果大于最大深度 +2，否则 +1
		printf("%d\n", f[i]);			//注意输出格式
	}
    return 0;
}
```

---

## 作者：DengDuck (赞：1)

我做结论题就像你让一个小孩满月抓阄一样，结论全靠猜......

对于 $i$ 的询问的答案我们计为 $f_i$，则边界条件为 $f_1=0$。

这道题我们求出最大深度 $D$，注意 $1$ 的深度为 $1$。

那么对于 $i\leq D$，我们可以一直走这个最深路，在此阶段，有：

$$
f_i=f_{i-1}+1(i\leq D)
$$

走完之后怎么办？我们考虑在原路径上加点，具体地，就是我们在原路径上加一个弯，比如：

![](https://cdn.luogu.com.cn/upload/image_hosting/jxh7nh7i.png)

我们在选完直径后，考虑加上 $5$ 走个弯路。

也就是：$1\to2\to5\to2\to3\to4$，这样长度只增加了 $2$，由于我们没有只加 $1$ 的方案，所以这一定是最优的。

于是我们可以这样处理剩下的 $f_i$：

$$
f_i=f_{i-1}+2(D<i)
$$

这样我们就可以求出来所有的 $f_i$。

```cpp
#include<bits/stdc++.h>
#define LL long long 
using namespace std;
vector<LL>v[100005];
LL n,x,y,D,ans;
void dfs(LL x,LL fa,LL dep)
{
	D=max(dep,D);
	for(LL i:v[x])
	{
		if(i==fa)continue;
		dfs(i,x,dep+1);
	}
} 
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n-1;i++)
	{
		scanf("%lld%lld",&x,&y);
		v[x].push_back(y);
		v[y].push_back(x); 
	}
	dfs(1,0,1);
	for(int i=1;i<=n;i++)
	{
		if(i!=1)ans+=1+(i>D);
		printf("%lld\n",ans);
	}
}
```

---

## 作者：ZKqwq (赞：0)

思路：

首先，我们可以直接通过树形 DP 来解决这个问题。

考虑如何来求树的直径：以任意一个点为起点进行一次 BFS，找到距离该起点最远的点 $x$，然后以 $x$ 为起点进行一次 BFS，找到距离 $x$ 最远的点 $y$，$y$ 到 $x$ 的距离即是所求的树的直径。

那么本题等价于求树上的最短路径，使得路径上所包含的结点数量恰好为 $k$。

我们用 $f_{u,k} $ 表示从 $u$ 出发，经过若干条边恰好包含 $k$ 个结点（不包括 $u$）所需要的最短时间。

对于一个节点 $u$，设 $v_1,v_2,\dots ,v_m$ 为其子结点，则：

$$
f_{u,k}

\begin{cases}
  & 0 & (k=0) \\
  & {\textstyle \sum_{i=1}^{m}}f_{v_i,k-1} +1  &  (1\le k\le m+1)\\
  & {\textstyle \sum_{i=1}^{m}}f_{v_i,m} +m+1  &  (k\ge m+2)
\end{cases}
$$

第一个式子是初始状态，当 $k=0$ 时代表 $u$ 不需要再访问，时间为 $0$。

第二个式子是状态转移方程，当 $1\le k\le m+1$ 时，我们可以先将子结点遍历一遍（花费 $ {\textstyle \sum_{i=1}^{m}} f_{v_i,k-1}$），然后通过边 $\left ( u,v_{i} \right ) $ 走到其中一个子结点 $\left ( u,v_{i} \right ) $（花费 $1$）。这里要注意，我们只有在访问完 $u$ 的所有子结点后才能返回 $u$，所以实际上一个子结点 $v_{i}$ 可能会被重复遍历多次，但不论顺序如何，所需的最小时间总是相同的。

第三个式子是特殊转移方程，当 $k\ge m+2$ 时，表示我们已经遍历完了 $u$ 的所有子结点，但还是需要走一部分路径来继续满足剩余的 $k-m-1$ 个节点。此时我们选择直接走到某个子结点 $v_{i}$，再从 $v_{i}$ 出发遍历完所有子结点并返回 $v_{i}$，最后再走回 $u$，这样就可以在满足 $k$ 个节点的前提下利用单次特殊转移答案最小化。容易发现，这种情况下所花费的最小时间为 $ {\textstyle \sum_{i=1}^{m}} f_{v_i,m}+m+1$。

在上述转移过程中，我们需要保证 $k$ 不会超过树的深度，即 $k\le n-1$。此外，还要注意题目中特殊连接只能使用一次的限制，这个限制很容易处理，当我们走到某个节点 $u$ 时，如果 $u$ 是根节点或者已经通过特殊连接到达根节点，那么就不再考虑特殊连接的情况，否则我们可以选择使用一次特殊连接直接到达根节点，也可以选择不使用特殊连接，通过正常转移到达根节点。

最后，我们将所有 $f_{1,k}$（即从根节点出发）中满足 $k\le n-1$ 的答案求出即可。

复杂度分析：

计算每个 $f_{u,k}$ 的时间复杂度是 $O(m)$，其中 $m$ 表示 $u$ 的子结点个数。由于 $n \le 10^5$，因此总复杂度为 $O(n)$。

---

## 作者：Elairin176 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P9304)         
大家的做法好像都比我简洁啊。         
我们容易想出一个贪心做法：先走点多的路径，走到最后用特殊连接，其他都正常走。          
那么，我们只需要先用一遍 dfs 求出每条路径上的点数并找出所有叶子结点，然后再加入优先队列，一个一个计算答案即可。            
这里解释下为什么找叶子结点：每条路径上的点数很明显就是深度，而叶子结点在路径最后，是这条路径上深度最大的一个点，也就是这条路径上的点数。          
优先队列需要记录一个值：$dep$，即深度。    
我们设 $ans$ 是全局的答案，即单点上答案为 $ans$ 加额外的长度。        
我们还需设 $sum$ 为已经走过的深度总和。      
我们按深度从大到小排序，遍历优先队列，并设 $i$ 为本次的个数，如果 $dep+sum>i$，那么我们没到终点，如果可以用特殊连接就使用，即答案为 $ans+(i-sum)$，否则答案为 $ans+(i-sum)\times2$。        
如果 $dep+sum=i$，即正好走完，我们需要更新全局答案。如果可以用特殊连接，新的 $ans$ 就要加上 $dep$，否则要加上 $2\times dep$。我们还需更新 $sum$，需加上 $dep$。这里明显这一轮的答案就是这次的全局答案，即 $ans$。          
如果 $dep+sum<i$，更新 $ans$，方法同 $dep+sum=i$ 的方法，$sum$ 也用一样的方法更新，但是这里的 $i$ 不能更新。           
这里明显地，我们每次遍历的第 $1$ 个结果必然为 $0$，所以我们不用计算个数为 $1$ 的情况。        
由于我们一开始就在结点 $1$，所以我们的 $i$ 需要从 $1$ 开始，$dep+sum<i$ 也就可以不考虑。        
[CODE](https://www.luogu.com.cn/paste/f2ma1r3v)

---


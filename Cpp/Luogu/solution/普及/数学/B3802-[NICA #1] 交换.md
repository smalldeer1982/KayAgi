# [NICA #1] 交换

## 题目描述

给定长度为 $n$ 的排列 $a$。排列的含义是，数字 $1,2,3,\cdots n$ 在 $a$ 中**恰好**出现了一次。现在有 $m$ 次操作，

- 第 $1$ 次操作将会交换第 $1$ 大（即最大）的元素和第 $2$ 大的元素。
- 第 $2$ 次操作将会交换第 $2$ 大的元素和第 $3$ 大的元素。
- 第 $3$ 次操作将会交换第 $3$ 大的元素和第 $4$ 大的元素。
- ……
- 第 $n-1$ 次操作将会交换第 $n-1$ 大的元素和第 $n$ 大的元素。
- 第 $n$ 次操作将会交换第 $1$ 大的元素和第 $2$ 大的元素。
- 第 $n+1$ 次操作将会交换第 $2$ 大的元素和第 $3$ 大的元素。
- 第 $n+2$ 次操作将会交换第 $3$ 大的元素和第 $4$ 大的元素。
- ……
- 第 $2n-2$ 次操作将会交换第 $n-1$ 大的元素和第 $n$ 大的元素。
- ……

形式化地讲，第 $i$ 次操作将会交换第 $(i-1)\bmod (n-1)+1$ 大和第 $(i-1)\bmod (n-1)+2$ 大的数字。

你需要求出排列最后的情况。



## 说明/提示

### 样例 1 解释

- 初始时：$[1,5,3,4,2]$；
- 交换第 $1$ 大和第 $2$ 大：$[1,4,3,5,2]$；
- 交换第 $2$ 大和第 $3$ 大：$[1,3,4,5,2]$；
- 交换第 $3$ 大和第 $4$ 大：$[1,2,4,5,3]$；
- 交换第 $4$ 大和第 $5$ 大：$[2,1,4,5,3]$；
- 交换第 $1$ 大和第 $2$ 大：$[2,1,5,4,3]$；
- 交换第 $2$ 大和第 $3$ 大：$[2,1,5,3,4]$；
- 交换第 $3$ 大和第 $4$ 大：$[3,1,5,2,4]$；
- 交换第 $4$ 大和第 $5$ 大：$[3,2,5,1,4]$；
- 交换第 $1$ 大和第 $2$ 大：$[3,2,4,1,5]$；
- 交换第 $2$ 大和第 $3$ 大：$[4,2,3,1,5]$。

### 数据范围及约定

对于全部数据，保证 $1\le n\le 10^5$，$0\le m\le 10^{1000000}$。

## 样例 #1

### 输入

```
5 10
1 5 3 4 2```

### 输出

```
4 2 3 1 5```

## 样例 #2

### 输入

```
10 1000000000
4 2 7 6 9 5 3 8 1 10```

### 输出

```
5 3 8 7 9 6 4 10 2 1
```

## 样例 #3

### 输入

```
10 100000000000000000000000000000000000000000000000000
10 9 8 7 6 5 4 3 2 1```

### 输出

```
1 9 10 8 7 6 5 4 3 2
```

# 题解

## 作者：lrqlrq250 (赞：6)

## 题意转述
给定一个长度为 $n$ 的排列 $a$，执行 $m$ 次操作，其中的第 $i$ 次操作内容为交换 $n - ((i - 1) \bmod (n - 1))$ 和 $n - ((i - 1) \bmod (n - 1)) - 1$，问 $m$ 次操作后该排列变成了什么样子。

## 解题思路
首先，我们发现 $m$ 的取值范围太大了。

由于我们不可能手动模拟这么大的数，因此这暗示我们这种操作会有周期。

**结论：在每执行 $n \times (n - 1)$ 次操作后，排列会变回原样。**

比较朴素地证明一下：考虑 $n - 1$ 次操作（不妨认为这是一轮），操作一轮后的数组会有什么变化？

考虑涉及交换 $n$ 的操作只有“和 $n - 1$ 交换”这一个，因此一轮后 $n$ 会在 $n - 1$ 的原位上。同样的，涉及 $n - 1$ 的操作是“先和 $n$ 交换，再和 $n - 2$ 交换”，由于**只有最后一次关于它的交换决定其最终位置**，可得 $n - 1$ 最终会在 $n - 2$ 的原位上。以此类推，最后 $1$ 被换到 $n$ 的原位上。

因此每进行“一轮”操作，相当于每个数都错位 $1$ 次，而错位 $n$ 次后就会回到原序列的状态，因此循环节长度为 $n \times (n - 1)$。

如果上面部分没有太看明白，可以自己手敲一个暴力模拟的程序体验一下。

至此，我们一边输入一边取模，就可以剔除所有冗余的循环节，控制 $m$ 最终小于 $n \times (n - 1)$。

但是 $n \leq 10^5$，即此时 $m \leq 10^{10}$ 左右，依然无法支持我们模拟。

于是我们回到上面“错位”的性质。从数的角度上讲，“错位”指的是一个数 $k$ 来到了 $k - 1$ 的位置上。**而从位置的角度上将，“错位”指的是这个位置上的数加一（超过 $n$ 则变回 $1$）**，这两种表述是等价的，但我们发现后者显然比前者好维护，因为前者依然是交换，但后者只是每个位置增加一个特定的值，再取模。不难发现增加的值为 $\lfloor \frac{m}{n-1} \rfloor$。

至此，我们就可以 $O(n)$ 统计出所有“错位”的操作对序列造成的影响了。剩下的不够造成一次“错位”的操作继续手动模拟即可。

时间复杂度 $O(n + \log_{10} m)$，可以通过本题。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
long long n, m;
int a[N], pos[N];

inline long long readm(){
	int f = 1;
	long long x = 0;
	char c = getchar();
	while (!isdigit(c)){f = c == '-' ? -1 : 1; c = getchar();}
	while (isdigit(c)){x = ((x << 1) + (x << 3) + (c ^ 48)) % (n * (n - 1)); c = getchar();}//一边读入一边取模
	return f * x;
}

int main(){
	scanf("%d", &n);
	m = readm();
	for (int i=1; i<=n; i++) scanf("%d", &a[i]);
	int t = m / (n - 1), left = m % (n - 1);
	if (t){
		for (int i=1; i<=n; i++){
			a[i] = (a[i] + t) % n ? (a[i] + t) % n : n;
		}//统计错位造成的影响
	}
	for (int i=1; i<=n; i++) pos[a[i]] = i; 
	for (int i=1; i<=left; i++){
		int p1 = n - (i - 1) % (n - 1), p2 = n - (i - 1) % (n - 1) - 1;
		swap(a[pos[p1]], a[pos[p2]]);
		swap(pos[p1], pos[p2]);
	}//手动模拟
	for (int i=1; i<=n; i++) printf("%d ", a[i]);
	return 0;
}
 
```


---

## 作者：Last_kiss_Snow_Dog6 (赞：2)

### 范围
可以看见 $ 0 \le m \le 10^{1000000} $ 这个巨大的数，所以要用字符串去存储。首先可以想到快读就是把一个字符串去转化，但这道题我们还需要找一个规律。

### 规律
我们通过列表可得每经过 $ n \times (n-1) $ 就会变回原来的数组，每次都进行取余之后存储以此来降低时间复杂度。代码实现如下：
```cpp
inline long long read()
{
	int f=1;
	long long x=0;
	char c;
	c=getchar();
	while (!isdigit(c))
	{
		f=c=='-'?-1:1;
		c=getchar();
	}
	while(isdigit(c))
	{
		x=((x<<1)+(x<<3)+(c^48))%(n*(n-1));
		c=getchar();
	}
	return f*x;
}
```

### 输出
最后我们只需要把剩下的部分模拟出来即可，最后直接输出，记得别忘了打空格。

### AC 代码（本人不习惯写注释如有不会可以私信）
```
#include <bits/stdc++.h>
using namespace std;
long long n,m,a[100005],tot[100005];
inline long long read()
{
	int f=1;
	long long x=0;
	char c;
	c=getchar();
	while (!isdigit(c))
	{
		f=c=='-'?-1:1;
		c=getchar();
	}
	while(isdigit(c))
	{
		x=((x<<1)+(x<<3)+(c^48))%(n*(n-1));
		c=getchar();
	}
	return f*x;
}
int main(){
	cin>>n;
	m=read();
	for(int i=1;i<=n;i++) 
	{
		cin>>a[i];
	}
	int t=m/(n-1),left=m%(n-1);
	if(t)
	{
		for(int i=1;i<=n;i++)
		{
			a[i]=(a[i]+t)%n?(a[i]+t)%n:n;
		}
	}
	for(int i=1;i<=n;i++)
	{
		tot[a[i]] = i;
	} 
	for(int i=1;i<=left;i++)
	{
		int p1=n-(i-1)%(n-1),p2=n-(i-1)%(n-1)-1;
		swap(a[tot[p1]], a[tot[p2]]);
		swap(tot[p1],tot[p2]);
	}
	for (int i=1;i<=n;i++) 
	{
		cout<<a[i]<<" ";
	}
	return 0;
}
//ღゝ◡╹)ノ♡
```

---

## 作者：HG27895 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3802)

# 题意：

给你一个长度为 $n$ 的数列 $a$，第 $i$ 次操作将会交换第 $(i−1)\bmod(n−1)+1$ 大和第 $(i−1)\bmod(n−1)+2$ 大的数字，问第 $m$ 次操作后的数列。

# 思路：

一眼看到 $m$ 这么大，肯定要找规律。

我们先设每 $n-1$ 操作为 $1$ 轮（题里已经说了，到第 $n$ 次操作时，又会和第 $1$ 操作一样）。

那么第 $1$ 大的数先与第 $2$ 大的数交换，再与第 $n$ 大的数交换；第 $2$ 大的数先与第 $3$ 大的数交换，再与第 $1$ 大的数交换；…… ；第 $n$ 大的数先与第 $1$ 大的数交换，再与第 $n-1$ 大的数交换。

不难发现**第 $i$ 大的数的位置只与目前的第 $i-1$ 大的数的位置相关**。

举个例子（$n=3$ 时第 $1$ 轮操作）：

```
原数列：3,1,2
第一次操作后：3,1,2->3,2,1
第二次操作后：3,2,1->2,3,1
```

通过这个例子，我们能发现每进行一轮操作，新数列的每一位比上一轮操作后数列的每一位要右移一位。

简单来说，一轮操作后，第 $(i+1)$ 个数变为第 $i$ 个数。特别地，第 $1$ 个数变为第 $n$ 个数。（注意：**是第几个数，而不是第几大的数**。）

所以，第 $q(n-1)$ 次操作后的数列中第 $i$ 位就是 $(a_i+q-1)\bmod n+1$。

又因为 $n$ 轮后序列还原，所以只需要计算 $\Large{\lfloor \frac{m}{n-1} \rfloor}$ 轮即可（剩下的 $m\bmod (n-1)$ 次操作暴力模拟就行了）。 

总结一下，答案数列的第 $i$ 应该为 $[(a_i+{\Large{\lfloor \frac{m}{n-1} \rfloor}}-1)\bmod n]+1$ 加上 $m\bmod (n-1)$ 次的暴力模拟。

# AC代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define fi(l) freopen(l".in","r",stdin)
#define fo(l) freopen(l".out","w",stdout)
using namespace std;
ll n;
inline ll read()//快读
{
	ll v=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		v=v*10+c-'0';
		c=getchar();
	}
	return v*f;
}
inline ll m_read()//因为m可能很大，所以要边输入，边取模
{
	ll v=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		v=v*10+c-'0';
		v%=(n*(n-1));
		c=getchar();
	}
	return v*f;
}
inline void out(ll x)//快输
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x<10)putchar(x+'0');
	else 
	{
		out(x/10);
		putchar(x%10+'0');
	}
}
ll a[100020],tong[100020];//tong数组是存第几大的，模拟桶
int main()
{
	//fi("");
	//fo("");
	//ios::sync_with_stdio(0);
	//cin.tie(0);
	//cout.tie(0);
	n=read();//输入n
	if(n==1)//特判除数为0
	{
		ll m=read();//普通快读即可，因为m也没有用
		//n=1,只有一个数，无论进行多少次操作都不会变化
		a[0]=read();
		out(a[0]);
		return 0;
	}
	ll m=m_read();//m得用特殊的快读
	//输入数列
	for(ll i=0;i<n;i++)//下标从0开始
	{
		a[i]=read();
		a[i]=(a[i]+m/(n-1)-1)%n+1;//O(1)处理n轮操作
		tong[a[i]]=i;//更新tong数组
	}
	//暴力模拟剩的m%(n-1)次操作
	for(ll i=n;i>n-m%(n-1);i--)//下标从0开始
	{
		swap(a[tong[i]],a[tong[i-1]]);//按照题意，将第i大的数与第i-1大的数交换
		swap(tong[i],tong[i-1]);//千万别忘了交换桶
	}
	//最后，输出答案即可
	for(ll i=0;i<n;i++)//下标从0开始
	{
		out(a[i]);
		cout<<' ';
	}
	return 0;//结束
}
```

---

## 作者：GSQ0829 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3802)

---
### 题目大意：
给定长度为 $n$ 的排列 $a$。排列的含义是，数字 $1,2,3,\cdots n$ 在 $a$ 中**恰好**出现了一次。现在有 $m$ 次操作，

- 第 $1$ 次操作将会交换第 $1$ 大（即最大）的元素和第 $2$ 大的元素。
- 第 $2$ 次操作将会交换第 $2$ 大的元素和第 $3$ 大的元素。
- 第 $3$ 次操作将会交换第 $3$ 大的元素和第 $4$ 大的元素。
- ……
- 第 $n-1$ 次操作将会交换第 $n-1$ 大的元素和第 $n$ 大的元素。
- 第 $n$ 次操作将会交换第 $1$ 大的元素和第 $2$ 大的元素。
- 第 $n+1$ 次操作将会交换第 $2$ 大的元素和第 $3$ 大的元素。
- 第 $n+2$ 次操作将会交换第 $3$ 大的元素和第 $4$ 大的元素。
- ……
- 第 $2n-2$ 次操作将会交换第 $n-1$ 大的元素和第 $n$ 大的元素。
- ……

形式化地讲，第 $i$ 次操作将会交换第 $(i-1)\bmod (n-1)+1$ 大和第 $(i-1)\bmod (n-1)+2$ 大的数字。

你需要求出排列最后的情况。



### 数据范围及约定

对于全部数据，保证 $1\le n\le 10^5$，$0\le m\le 10^{1000000}$。

---
### 解题思路：
说实话，刚开始看到题目，我写下了一个代码。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100001;
long long a[MAXN], pos[MAXN], n, m, t, l = 0;

signed main() {
	scanf("%lld%lld", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	t = m / (n - 1);
	l = m % (n - 1);
	if (t) {
		for (int i = 1; i <= n; i++) a[i] = (a[i] + t) % n ? (a[i] + t) % n : n;
	}
	for (int i = 1; i <= n; i++) pos[a[i]] = i;
	for (int i = 1; i <= l; i++) {
		int x = n - (i - 1) % (n - 1), y = n - (i - 1) % (n - 1) - 1;
		swap(a[pos[x]], a[pos[y]]);
		swap(pos[x], pos[y]);
	}
	for (int i = 1; i <= n; i++) printf("%d ", a[i]);
	return 0;
}
```
我非常自信的交了上去，结果[WA了一半](https://www.luogu.com.cn/record/193764649)，直接喜提 $48$ 分，我就在代码和题目中找问题。

但最后在数据范围那儿找到了问题：
> 对于全部数据，保证 $1\le n\le 10^5$，$0\le m\le 10^{1000000}$。

是范围的错，那我就在代码之前加个 $read$ 数组不就好了？可我不会写啊，于是我就开始问要怎么写，终于，找到了方法，就是这个：
```cpp
inline long long read() {
	int f = 1;
	long long x = 0;
	char c;
	c = getchar();
	while (!isdigit(c)) {
		f = c == '-' ? -1 : 1;
		c = getchar();
	}
	while (isdigit(c)) {
		x = ((x << 1) + (x << 3) + (c ^ 48)) % (n * (n - 1));
		c = getchar();
	}
	return f * x;
}
```
所以这样就找到了，加入它，过了！！！

---

### code:
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100001;
long long a[MAXN], pos[MAXN], n, m, t, l = 0;

inline long long read() {
	int f = 1;
	long long x = 0;
	char c;
	c = getchar();
	while (!isdigit(c)) {
		f = c == '-' ? -1 : 1;
		c = getchar();
	}
	while (isdigit(c)) {
		x = ((x << 1) + (x << 3) + (c ^ 48)) % (n * (n - 1));
		c = getchar();
	}
	return f * x;
}

signed main() {
	cin >> n;
	m = read();
	for (int i = 1; i <= n; i++) cin >> a[i];
	t = m / (n - 1);
	l = m % (n - 1);
	if (t) {
		for (int i = 1; i <= n; i++) a[i] = (a[i] + t) % n ? (a[i] + t) % n : n;
	}
	for (int i = 1; i <= n; i++) pos[a[i]] = i;
	for (int i = 1; i <= l; i++) {
		int x = n - (i - 1) % (n - 1), y = n - (i - 1) % (n - 1) - 1;
		swap(a[pos[x]], a[pos[y]]);
		swap(pos[x], pos[y]);
	}
	for (int i = 1; i <= n; i++) printf("%d ", a[i]);
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

读题发现，如果你操作 $n \times (n-1)$ 次，就~~相当于没操作~~。

所以，我们真正需要模拟的是 $m \bmod n (n+1)$ 次了。

可是，$n(n+1)$ 次对于 $n \le 10^5$ 太慢了！

注意看，题目中保证 $1,2,3,\dots ,n$ 在 $a$ 序列都只出现了一次，所以可以在数组每一个数加上 $\lfloor\frac{m}{n-1}\rfloor$ 即可。

模拟部分 $m \bmod (n-1)$ 次就可以了。

注意交换部分需 $O(1)$ 搞定。

代码来了：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[100010],pos[100010];
void read(){
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c<='9'&&c>='0'){
		(m=m*10+c-'0')%=n*(n-1);
		c=getchar();
	}
}
main(){
	cin>>n;
	read();
	for(int i=1;i<=n;i++)cin>>a[i];
	if(m>=n-1)for(int i=1;i<=n;i++)a[i]=(a[i]+m/(n-1)+n-1)%n+1;
	for(int i=1;i<=n;i++)pos[a[i]]=i;
	for(int i=n;i>=n-m%(n-1)+1;i--)swap(a[pos[i]],a[pos[i-1]]),swap(pos[i],pos[i-1]);
	for(int i=1;i<=n;i++)cout<<a[i]<<' ';
	return 0;
}


```

~~码风不好勿喷~~

---

## 作者：__qkj__ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3802)
## 题目意思
$a$ 是 $1$ 到 $n$ 的排列，第 $i$ 次操作将会交换第 $(i-1)\bmod (n-1)+1$ 大和第 $(i-1)\bmod (n-1)+2$ 大的数字，求 $m$ 次操作后的数组。
## 解题思路
先找一下规律，$a_1$ 表示第一大：
$$
[a_1,a_2,a_3,a_4,a_5...a_n]
$$
第 $1$ 次操作：
$$
[a_2,a_1,a_3,a_4,a_5...a_n]
$$
第 $2$ 次操作：
$$
[a_2,a_3,a_1,a_4,a_5...a_n]
$$
第 $3$ 次操作：
$$
[a_2,a_3,a_4,a_1,a_5...a_n]
$$
……

第 $n-1$ 次操作：
$$
[a_2,a_3,a_4,a_5...a_n,a_1]
$$
总之，每 $n-1$ 次操作，就是把第一个数移到最后。

所以，$n \times (n-1)$ 次操作后，数组变回原样。

那就不用看 $m$ 有多大了，直接 $m \gets m \bmod n \times (n-1)$。

然后，再把 $m$ 中每个 $n-1$ 提出来，对数组的每一项进行移动。也就是把数组的每一项加上 $\lfloor \dfrac{m}{n-1}\rfloor$，超出 $n$ 的话就取模，$n$ 变为 $1$，$n+1$ 变为 $2$。

最后的 $m \bmod (n-1)$ 次操作，直接模拟。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[100010],b[100010];
void read()
{
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c<='9'&&c>='0')
	{
		(m=m*10+c-'0')%=n*(n-1);//取模
		c=getchar();
	}
}
signed main()
{
	/*ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);*///用了 ios 会出错（RE、WA）
	cin>>n;
	read();
	for(int i=1;i<=n;i++)
		cin>>a[i];
	if(m>=n-1)
		for(int i=1;i<=n;i++)
			a[i]=(a[i]+m/(n-1)+n-1)%n+1;
	for(int i=1;i<=n;i++)b[a[i]]=i;
	for(int i=n;i>=n-m%(n-1)+1;i--)
	{
		swap(a[b[i]],a[b[i-1]]);//模拟
		swap(b[i],b[i-1]);
	}
	for(int i=1;i<=n;i++)
		cout<<a[i]<<' ';
	return 0;
}

```

---

## 作者：SuyctidohanQ (赞：0)

### 题目分析

我们用字符串输入，不难发现，我们最多只要进行 $n \times (n - 1)$ 次操作。我们在字符串转为数组的时候，可以及时取模，避免溢出。

再用一个数组标记，进行交换就行了。

### 代码实现

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MAXN = 1e5 + 10;
ll a[MAXN], w[MAXN], n, m = 0;
string s; 
int main () {
	cin >> n >> s;
	for (auto i : s) {
		ll u = i ^ 48;
		m = (m << 3) + (m << 1) + u;
		m %= (n * (n - 1));
	}
	for (ll i = 1; i <= n; i ++) cin >> a[i];
	ll f = m / (n - 1);
	for (ll i = 1; i <= n; i ++) {
		if ((a[i] + f) % n == 0) a[i] = n;
		else a[i] = (a[i] + f) % n;
	}
	for (ll i = 1; i <= n; i ++) w[a[i]] = i;
	for (ll i = n; i > n - m % (n - 1); i --) {
		swap (a[w[i]], a[w[i - 1]]);
		swap (w[i],w[i - 1]);
	}
	for (ll i = 1; i <= n; i ++) cout << a[i] << ' ';
	return 0;
}
```

---

## 作者：tkm2013 (赞：0)

## [传送门](https://www.luogu.com.cn/problem/B3802)

乍一看，呀！ $m \le 10^{1000000} $。

这光是输入就有些困难了呀，但我们通过模拟一些数据不难发现，每进行 $n\times(n-1)$ 次交换就会回到最开始的数组了。所以我们可以用字符串输入，然后使用过程性取模得到 $m$ 。


```cpp
long long n;
string s;
cin>>n;
long long m=0;
cin>>s;
for(auto i:s){
  int u=i-'0';
  m=(m*10)+u;
  m=m%(n*(n-1));
}
```

最后就只剩下 $m$ 次交换了，模拟出来就行，别忘了开 long long。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
int wz[100005];
string s; 
int main(){
	long long n;
	cin>>n;
	long long m=0;
	cin>>s;
	for(auto i:s){
		int u=i^48;
		m=(m<<3)+(m<<1)+u;
		m=m%(n*(n-1));
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int f=m/(n-1);
	for(int i=1;i<=n;i++){
		if((a[i]+f)%n==0){
			a[i]=n;
		}else{
			a[i]=(a[i]+f)%n;
		}
	}
	for(int i=1;i<=n;i++){
		wz[a[i]]=i;
	}
	for(int i=n;i>n-m%(n-1);i--){
		swap(a[wz[i]],a[wz[i-1]]);
		swap(wz[i],wz[i-1]);
	}
	for(int i=1;i<=n;i++){
		cout<<a[i]<<' ';
	}
	return 0;
}
```

---

## 作者：csxx601cjy (赞：0)

## [题目传送门：B3802 [NICA #1] 交换](https://www.luogu.com.cn/problem/B3802)
## 题意
见原题面。
## 解题思路
本题主要考察数学思维。

首先题目数据很大，$m$ 最长可达一百万位。正常的 `long long` 存不下这么大的数字。~~废话，怎么可能存得下~~，所以输入时就可以进行取模。

怎么取模呢？根据你自己用手模拟，我们可以发现，每操作 $n\times (n-1)$ 次，序列就会还原。所以 $m$ 可以直接跟 $n\times (n-1)$ 取模。参见 [P10815 快速读入](https://www.luogu.com.cn/problem/P10815)。

然后 $m\le 10^{10}$，但还是不能暴力。

假设序列是 $[1,2,3,4,5]$，经过 $n-1$ 次操作后，序列变成了 $[2,3,4,5,1]$。再经过 $n-1$ 次操作后，序列变成了 $[3,4,5,1,2]$。

又不难发现，序列中的每个数在 $n-1$ 次操作后都增加了 $1$，并且超过 $n$ 的又回到了 $1$。

我们总结出一个规律，先设序列为 $a$，每进行 $k(n-1)$ 次操作后，$a_i\gets (a_i+k-1)\mod n +1$。

最后，代码思路就清楚了。首先给 $m$ 取一下模，再给序列中的每个数加上 $\left\lfloor\dfrac{m}{n-1}\right\rfloor$，剩下的 $m\mod n-1$ 次操作直接模拟交换过程即可。
## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M=1e5+10;
ll n,mod,m;
int a[M],t[M];

inline ll read(){//快读模板
	ll x=0;
	char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		x%=mod;//快读的同时顺便取模
		ch=getchar();
	}
	return x;
}
int main(){
	cin>>n;
	mod=n*(n-1); //只要执行n*(n-1)次就够了
	m=read(); //不能用cin
	for(int i=0; i<n; i++)
		cin>>a[i], //输入
		a[i]=(a[i]+m/(n-1)-1)%n+1, //每个数都要增加
		t[a[i]]=i; //桶记录每个元素的编号
	for(int i=n; i>n-m%(n-1); i--){ //最后还剩m%(n-1)次操作
		swap(a[t[i]],a[t[i-1]]); //直接模拟
		swap(t[i],t[i-1]); //桶也要交换
	}
	for(int i=0; i<n; i++) cout<<a[i]<<' ';
	return 114514 & 0; //程序完结
}
```

---

## 作者：sieve (赞：0)

# 题解：[B3802 [NICA #1] 交换](https://www.luogu.com.cn/problem/B3802)

## 思路

这题主要的难点在于输入，其它的地方并不难想。

输入的话，用普通变量肯定不行，我们就得用字符串来处理。不难发现，交换经过 $n \times (n-1)$ 次后，答案会重复，所以，我们最多只要进行 $n \times (n-1)$ 次操作。我们在字符串转为数组的时候，可以及时取模，避免溢出。

然后用一个数组标记，再进行交换就行了。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5,M=1e6+5;
int n,m;
int a[N],b[N],w[N];
string ms;
signed main()
{
	cin>>n>>ms;
	for(int i=0;i<ms.size();++i)
	{
		m=(m*10+ms[i]-'0')%(n*(n-1));
	}
	for(int i=1;i<=n;++i) cin>>a[i];
	int add=m/(n-1);
	if(add!=0)
	{
		for(int i=1;i<=n;++i)
		{
			if((a[i]+add)%n==0) a[i]=n;
			else a[i]=(a[i]+add)%n;
		}
	}
	for(int i=1;i<=n;++i) b[a[i]]=i;
	for(int i=n;i>=n-m%(n-1)+1;--i)
	{
		swap(a[b[i]],a[b[i-1]]);
		swap(b[i],b[i-1]);
	}
	for(int i=1;i<=n;++i) cout<<a[i]<<' ';
	return 0;
}
```

---

## 作者：helongyun (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3802)
# 思路
这道题的 $m$ 可能会很大，所以一定是有简单思路的，找一下规律，发现执行第 $n(n-1)$ 次时这个数组不变，按照此思路，先把 $m$ 化简，之后暴力模拟即可。这里就不给代码了。

---


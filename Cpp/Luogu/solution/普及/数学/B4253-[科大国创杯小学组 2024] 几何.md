# [科大国创杯小学组 2024] 几何

## 题目描述

小可可最近在学习平面几何！

给定平面上的 $n$ 个点 $(x_1, y_1), (x_2, y_2), \cdots, (x_n, y_n)$。

根据题目要求，输出下列两个值其中一个：

1. 任意两点间欧几里得距离最大值的平方，对于两个点 $(x_i, y_i)$ 和 $(x_j, y_j)$，欧几里得距离定义为 $\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。

2. 任意两点间曼哈顿距离最大值，对于两个点 $(x_i, y_i)$ 和 $(x_j, y_j)$，曼哈顿距离定义为 $|x_i - x_j| + |y_i - y_j|$。

## 说明/提示

### 数据范围

- 数据点 $1 \sim 2$，$op = 1$，$1 \leq n \leq 10^3$，$1 \leq x_i \leq 10^4$，$y_i = 1$。
- 数据点 $3 \sim 6$，$op = 1$，$1 \leq n \leq 10^3$，$1 \leq x_i \leq 10^9$，$1 \leq y_i \leq 10^9$。
- 数据点 $7 \sim 10$，$op = 2$，$1 \leq n \leq 10^3$，$1 \leq x_i \leq 10^9$，$1 \leq y_i \leq 10^9$。
- 数据点 $11 \sim 14$，$op = 2$，$1 \leq n \leq 10^6$，$1 \leq x_i \leq 10^9$，$y_i = 1$。
- 数据点 $15 \sim 20$，$op = 2$，$1 \leq n \leq 10^6$，$1 \leq x_i \leq 10^9$，$1 \leq y_i \leq 10^9$。

## 样例 #1

### 输入

```
5 1
3 4
1 2
5 2
3 1
2 3```

### 输出

```
16```

## 样例 #2

### 输入

```
5 2
3 4
1 2
5 2
3 1
2 3```

### 输出

```
4```

# 题解

## 作者：the_Short_Path (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B4253)

~~一道水题~~
+ $op=1$ 时，暴力枚举每对点，~~数据范围比较水~~。
+ $op=2$ 时，分别计算每个点 $i$ 的 $x_i$ 和 $y_i$ 的和与差的最大值和最小值，再将两个最大值和最小值的差取较大值，原因见证明。

证明：

对于两个点 $(x_i,y_i)$ 和 $(x_j,y_j)$，其曼哈顿距离有：
1. $(x_i + y_i) - (x_j + y_j)$
2. $(x_i + y_i) - (x_j - y_j)$
3. $-(x_i + y_i) + (x_j + y_j)$
4. $-(x_i + y_i) + (x_j - y_j)$

所以可以枚举所有的 $(x_i + y_i)$ 和 $(x_i - y_i)$，分别求其 $\max$ 和 $\min$，差的较大值即为曼哈顿距离最大值。
# Code
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const long long maxn = 1e6 + 5;
long long n, op, ans, x[maxn], y[maxn];
// 十年 OI 一场空，不开 long long 见祖宗
signed main() {
	cin >> n >> op;
	for (long long i = 1; i <= n; i++) cin >> x[i] >> y[i];
	if (op == 1) {
		for (long long i = 1; i <= n; i++) 
			for (long long j = i + 1; j <= n; j++) 
				ans = max(ans, (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));
	} else {
        long long mx1 = 0, mx2 = 0, mn1 = inf, mn2 = inf;
        for (long long i = 1; i <= n; i++) {
            mx1 = max(mx1, x[i] - y[i]);
            mx2 = max(mx2, x[i] + y[i]);
            mn1 = min(mn1, x[i] - y[i]);
            mn2 = min(mn2, x[i] + y[i]);
        } // 计算每个点 i 的 xi 和 yi 的和与差的最大值和最小值
        ans = max(mx1 - mn1 , mx2 - mn2);
    }
    cout << ans << endl;
	return 0;
} 
```
其实很简单的，就是需要懂一些技巧。

---

## 作者：wjl1100 (赞：3)

## [题意](https://www.luogu.com.cn/problem/B4253)

这道题暴力是肯定会 TLE 的，又因为大数据都是求哈曼顿距离的最大值，所以我们可以考虑用数学方法优化。

我们可以维护一下 $x-y$ 和 $x+y$ 的最大最小值，最后输出 $x-y$ 最大值减最小值与 $x+y$ 最大值减最小值的最大值就好了。

具体数学证明我们可以看看这位大佬的博客。

### [证明](https://www.cnblogs.com/ofnoname/p/18298620)

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
using namespace std;
const int maxn = 1e6 + 100;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int ans1 , ans2 , ans3 = inf , ans4 = inf , x[maxn] , y[maxn] , ans , n , opt;//ans1维护x-y的最大值，ans2维护x+y的最大值，ans3维护x-y的最小值，ans4维护x+y的最大值
signed main() {
	n = read();
	opt = read();
	for(int i = 1; i <= n; i++) x[i] = read() , y[i] = read() , ans1 = max(ans1 , x[i] - y[i]) , ans2 = max(ans2 , x[i] + y[i]) , ans3 = min(ans3 , x[i] - y[i]) , ans4 = min(ans4 , x[i] + y[i]);
	if(opt == 1) {//暴力枚举
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= n; j++) {
				int dx = x[i] - x[j] , dy = y[i] - y[j];
				ans = max(ans , dx * dx + dy * dy);
			}
		}
		cout << ans << endl;
	}else cout << max(ans1 - ans3 , ans2 - ans4) << endl;//数学公式
	return 0;
} 
```

---

## 作者：yxszcxl (赞：2)

### [B4253 [科大国创杯小学组 2024] 几何](https://www.luogu.com.cn/problem/B4253)


---

题目要求：

1. 任意两点间欧几里得距离最大值的平方，对于两个点 $(x_i, y_i)$ 和 $(x_j, y_j)$，欧几里得距离定义为 $\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。

2. 任意两点间曼哈顿距离最大值，对于两个点 $(x_i, y_i)$ 和 $(x_j, y_j)$，曼哈顿距离定义为 $|x_i - x_j| + |y_i - y_j|$。



---

因为只用输出距离最大值的平方，所以欧几里得距离只要输出 $ (x_i - x_j)^2 + (y_i - y_j)^2 $。


---



## Code


```cpp
ll ans = 0;
upto(i, 1, n) {
    upto(j, 1, n) {
        num[i] = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);
        ans = max(ans, num[i]);
    }
}
cout << ans;
```



---

接下来考虑曼哈顿距离最大值。我一开始用的是暴力，结果 TLE 了。

```cpp
upto(i, 1, n) {
    upto(j, 1, n) {
        num[i] = fabs(x[i] - x[j]) + fabs(y[i] - y[j]);
        ans = max(ans, num[i]);
    }
}
		cout << ans;
```

通过观察数据，我们发现 $1\leq n \leq 10^6$ ，因此 TLE 便是显而易见的。


---

## 正解
我们应当通过求极差的方式求出求平面曼哈顿最远点对。


极差是一个统计学中的概念，它表示一组数据中最大值与最小值之间的差异。用数学公式表示就是： 极差 = 最大值 - 最小值。
  
## Code


```cpp
ll maxa = LLONG_MIN, mina = LLONG_MAX;
ll maxb = LLONG_MIN, minb = LLONG_MAX;
	upto(i, 1, n) {
		maxa = max(maxa, x[i] + y[i]);
		mina = min(mina, x[i] + y[i]);
		maxb = max(maxb, x[i] - y[i]);
		minb = min(minb, x[i] - y[i]);
	}
cout << max(maxa - mina, maxb - minb);
```
## AC Code




```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 100;// 1<=n<=1e6
#define maxn 10010
#define mod 1e9 + 7//998244353
#define upto(i, a, b) for (int i = a; i <= b; i++)//循环板子，拿走不谢
#define downto(i, a, b) for (int i = a; i >= b; i--)
#define rep(i, a, b) for (int i = a; i < b; i++)
typedef long long ll;//ll代替long long,节约录入时间
//using ll=long long;
//#define ll long long
template <typename T>//通用快读板子
inline void read(T &x) {
	x = 0;
	T f = 1;
	char ch = getchar();
	while (ch < 48 || ch > 57) {
		if (ch == '-')
			f = 0;
		ch = getchar();
	}
	while (ch >= 48 && ch <= 57)
		x = x * 10 + ch - 48, ch = getchar();
	if (!f)
		x = -x;
}

ll maxa = LONG_LONG_MIN, mina = LONG_LONG_MAX;//||LLONG_MAX
ll maxb = LONG_LONG_MIN, minb = LONG_LONG_MAX;
ll n, opt, x[N], y[N], num[N];

int main() {
	ios::sync_with_stdio(false);//关流
	read(n);
	read(opt);
	upto(i, 1, n) {
		read(x[i]), read(y[i]);
	}
	upto(i, 1, n) {//循环求极差
		maxa = max(maxa, x[i] + y[i]);
		mina = min(mina, x[i] + y[i]);
		maxb = max(maxb, x[i] - y[i]);
		minb = min(minb, x[i] - y[i]);
	}
	if (opt == 1) {//求欧几里得距离最大值的平方
		ll ans = 0;
		upto(i, 1, n) {
			upto(j, 1, n) {
				num[i] = (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]);
				ans = max(ans, num[i]);
			}
		}
		cout << ans;
	} else if (opt == 2) {
		cout << max(maxa - mina, maxb - minb);
	}
	return 0;
}
```
---


## 鸣谢

严格来说，对于求曼哈顿距离最大值，本篇题解在一定程度上参考了 [Miku_QwQ](https://www.luogu.com.cn/user/793612 ) 求极差的思路，感谢TA。

---


我们下篇题解再会！

---

## 作者：canwen (赞：1)

注意到是小学组，不用上凸包之类的省选玩意，反正我也不会。

分为两部分求解。

问题一 $n \le 10^3$，$O(n^2)$ 的枚举算法足以通过。

问题二 $n \le 10^6$，可以 $O(n)$ 求。

设 $maxn1 = \max(x_i+y_i), minn1 = \min(x_i-y_i),maxn2 = \max(x_i-y_i), minn2 = \min(x_i-y_i)$，则答案是 $\max(maxn1-minn1,maxn2-minn2)$。


以下是简单证明：

先对 $|x_i - x_j| + |y_i - y_j|$ 进行讨论。

则有以下四种可能：

$$x_i+y_i-(x_j+y_j)\textcircled{1} $$

$$(x_i-y_i)-(x_j-y_j)\textcircled{2} $$

$$-(x_i-y_i)+(x_j-y_j)\textcircled{3} $$

$$-(x_i+y_i)+(x_j+y_j)\textcircled{4} $$

对应的最大的取值为

$$maxn1-minn1\textcircled{1} $$
$$maxn2-minn2\textcircled{2} $$
$$-minn2+maxn2=maxn2-minn2\textcircled{3} $$
$$-minn1+maxn1 = maxn1-minn1\textcircled{4} $$

所以共有两种最大的可能，取最大值即可，得证。

---

## 作者：longyitongxue (赞：1)

# 正文前提示
![](https://cdn.luogu.com.cn/upload/image_hosting/x6t7g91k.png)
- - -
[题目传送门](https://www.luogu.com.cn/problem/B4253)
# 主要思路
这道题，我们都可以维护一个最大值来求答案。

- 对于 $op=1$，我们要求最大的 $\sqrt{\left(x_i-x_j\right)^2+\left(y_i-y_j\right)^2}^2$，但是 `double` 的精度会有限，就算开 `long double` 也无法保证 AC。其实 $\sqrt{x}^2$ 还是 $x$，所以我们只要看最大的 $\left(x_i-x_j\right)^2+\left(y_i-y_j\right)^2$ 就 OK 了。数据范围在 $1000$ 级别，可以放心使用双重循环。
- 对于 $op=2$，我们要求最大的 $\left|x_i-x_j\right|+\left|y_i-y_j\right|$。但是 $n$ 的范围在 $10^6$，我们不得不使用单重循环。分析一下，我们可以把 $\left|x_i+y_i\right|$ 的最大值和最小值求出来，再把 $\left|x_i-y_i\right|$ 的最大值和最小值求出来，再求 $\left|x_i+y_i\right|$ 的最大值减最小值和 $\left|x_i-y_i\right|$ 的最大值减最小值哪个更大，大的那个就是答案。具体请见代码。这样就可以把复杂度缩减成 $\mathcal O\left(n\right)$。这里需要用到 `abs`（绝对值）函数，需调用 `cmath` 或 `math.h` 库。

# [AC](https://www.luogu.com.cn/record/210931086) 代码

```cpp
#include<iostream>
#include<math.h>
using namespace std;
long long dian[1451478][2];
int main(){
    int n,op;
    long long maxn=-0x7f7f7f7f7f7f7f7f,minn=0x7f7f7f7f7f7f7f7f,
              maxx=-0x7f7f7f7f7f7f7f7f,minx=0x7f7f7f7f7f7f7f7f;
    cin>>n>>op;
    for(int i=1;i<=n;i++){
        cin>>dian[i][1]>>dian[i][2];
    }
    if(op==1){
        for(int i=1;i<n;i++){
            for(int j=i+1;j<=n;j++){
                
                //很容易出错，要小心！！！
                long long x=dian[i][1]-dian[j][1];
                long long y=dian[i][2]-dian[j][2];
                
                maxn=max(maxn,x*x+y*y);
            }
        }
        cout<<maxn;
    }else{
        for(int i=1;i<=n;i++){
            long long x=dian[i][1]+dian[i][2];
            long long y=dian[i][1]-dian[i][2];
            maxn=max(maxn,x);
            minn=min(minn,x);
            maxx=max(maxx,y);
            minx=min(minx,y);
        }
        cout<<max(maxn-minn,maxx-minx);
    }
    return 0;
}
```

---

## 作者：YZren (赞：1)

## 简单的数学题
[题目传送门](https://www.luogu.com.cn/problem/B4253)
# 思路
1. 当 opt=1 时，可以看见 $n \le 10^3$ 所以可以随机化找两个不同的点算最长距离。
### Code
```cpp
srand(time(NULL));
		f(i,1,n) a[i].x=read(),a[i].y=read();
		f(i,1,1000000){
			int u=(int)rand()%n+1,v=(int)rand()%n+1;
			while(u==v) v=(int)rand()%n+1;
			if(opt==1) ma=max(ma,(a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y));
			else ma=max(ma,abs(a[u].x-a[v].x)+abs(a[u].y-a[v].y));
		}
		write(ma);
```
2. 当 $n>10^3$ 时，可以看见 opt=2，所以将公式展开 $|x_i-x_j|+|y_i-y_j=\max(x_i+y_i-x_j-y_j,x_i-y_i-x_j+y_j)$，其中令 $x_i>x_j$，这样只需记录 $\max(x_i-y_i),\min(x_i-y_i),\max(x_i+y_i),\min(x_i+y_i)$ 就可以了。
### Code

```cpp
int x=0,y=0,xx=0x7f7f7f7f,yy=0x7f7f7f7f;
		f(i,1,n) a[i].x=read(),a[i].y=read(),x=max(x,a[i].x-a[i].y),y=max(y,a[i].x+a[i].y),xx=min(xx,a[i].x-a[i].y),yy=min(yy,a[i].x+a[i].y);
		write(max(x-xx,y-yy));
```
这样就结束了。
# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=2e6+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),opt=read(),ma;
struct node{int x,y;} a[maxn]; 
inline void work(){
	if(n<=1e3){
		srand(time(NULL));
		f(i,1,n) a[i].x=read(),a[i].y=read();
		f(i,1,1000000){
			int u=(int)rand()%n+1,v=(int)rand()%n+1;
			while(u==v) v=(int)rand()%n+1;
			if(opt==1) ma=max(ma,(a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y));
			else ma=max(ma,abs(a[u].x-a[v].x)+abs(a[u].y-a[v].y));
		}
		write(ma);
	}
	else{
		int x=0,y=0,xx=0x7f7f7f7f,yy=0x7f7f7f7f;
		f(i,1,n) a[i].x=read(),a[i].y=read(),x=max(x,a[i].x-a[i].y),y=max(y,a[i].x+a[i].y),xx=min(xx,a[i].x-a[i].y),yy=min(yy,a[i].x+a[i].y);
		write(max(x-xx,y-yy));
	}
}
signed main(){work();return 0;}
```

---

## 作者：Miku_QwQ (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4253)

闲话：当时考场上看到这题发现是两道原题的缝合怪，吓傻了。

## [Subtask 1](https://www.luogu.com.cn/problem/P1452)

求平面最远点对。

但是这是小学组，不会考旋转卡壳。发现数据范围只有 $n \leq 10^3$，遂枚举。

```cpp
long long ans=0;
for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
        ans=max(ans,(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
    }
}
return ans;
```

## [Subtask2](https://www.luogu.com.cn/problem/P5098)

求平面曼哈顿最远点对。

原题。我们只要考虑 $x+y$ 和 $x-y$ 的极差即可。

```cpp
long long max1=-INF,min1=INF,max2=-INF,min2=INF;
for(int i=1;i<=n;i++){
  max1=max(max1,x[i]+y[i]);
  min1=min(min1,x[i]+y[i]);
  max2=max(max2,x[i]-y[i]);
  min2=min(min2,x[i]-y[i]);
}
return max(max1-min1,max2-min2);
```

然后就结束了。

闲话：考场上最后五分钟发现代码里有个很奇妙的错误。

---

## 作者：SatoruXia (赞：1)

# B4253 [科大国创杯小学组 2024] 几何
这是一道数据量较大的题目，我们需要先分析题目要求，再看题目的公式，最后找能过的算法。
## 题目要求

> 给定平面上的 $n$ 个点 $(x_1, y_1), (x_2, y_2), \cdots, (x_n, y_n)$。  
> 输出第一行，两个整数 $n, op$，$n$ 为平面内有多少个点，$op$ 为 1 则求欧几里得距离最大值的平方，若 $op$ 为 2 则求曼哈顿距离最大值。
第 $2 \sim n+1$ 行，每行两个数 $x_i, y_i$，表示平面上的一个点。

换句话说，题目会扔给我们一大堆数据，即一大堆点的坐标，让我们输出它们**所有的点**之间的**欧几里得距离最大值的平方**，或它们**所有的点**之间的曼哈顿距离最大值，并给出了欧几里得距离与曼哈顿距离的计算公式。  
要注意的是，一组数据开头便会给出这所有点将进行的运算，所以它们要么是欧几里得距离，要么是曼哈顿距离。同样地，输出也只有一个数。
## 公式分析
> 1. 任意两点间欧几里得距离最大值的平方，对于两个点 $(x_i, y_i)$ 和 $(x_j, y_j)$，欧几里得距离定义为 $\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。
> 
> 2. 任意两点间曼哈顿距离最大值，对于两个点 $(x_i, y_i)$ 和 $(x_j, y_j)$，曼哈顿距离定义为 $|x_i - x_j| + |y_i - y_j|$。

搞两个大一点的数组，一个统一存坐标的第一个数据，一个统一存第二个。然后开始枚举。  
每两个数据都匹配一次的实现方式应该不难，就不说了。因为数据比较大，以下是简化的要点：  

- 对于欧几里得距离：众所周知开根号并不改变运算数的大小关系，开根号前的数大开完后还是大的，所以无需开根号，直接比较 $(x_i - x_j)^2 + (y_i - y_j)^2$ 即可。
- 对于曼哈顿距离：
  $$|x_1 - x_2| + |y_1 - y_2| = \max(|(x_1 + y_1) -(x_2 + y_2)|,|(x_1 - y_1) - (x_2 - y_2)|)$$
  原先我们得怎么办？打双重循环。但有了这个好东西以后就直接变一层！这个变形自己理解，它还可以用取最大值的方法考虑负数情况（其实这道题没有负数）。套进去就得了，秒变 $O(n)$。
## 实现算法
~~也许有人看到数据范围会想着写凸包，所以用顶点~~  
这数据范围算欧几里得距离时最大 $1 \leq n \leq 10^3$，算曼哈顿距离时最大 $1 \leq n \leq 10^6$，与我们的算法时间复杂度刚好吻合，所以想必大家都会直接把优化代码用上。这完全没有问题，这样写就过了。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>//下面那个宏要用
using namespace std;
long long hypot(const vector<long long>& x, const vector<long long>& y, int n) {//要开long long
	long long MAXM = 0;//愉快地准备打擂台（也要开long long）
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			long long X = x[i] - x[j];
			long long Y = y[i] - y[j];//防止运算时溢出
			long long dist = X * X + Y * Y;
			if (dist > MAXM) MAXM = dist;//擂台
		}
	}
    return MAXM;
}
long long mhd(const vector<long long>& x, const vector<long long>& y, int n) {//曼哈顿英语太长了
	long long maxXaY = LLONG_MIN, minXaY = LLONG_MAX;
	long long maxXmY = LLONG_MIN, minXmY = LLONG_MAX;//这个宏是ll最大值
	//接下来是神奇的打擂台过程
	for (int i = 0; i < n; ++i) {
		long long xaY = x[i] + y[i];
		long long xmY = x[i] - y[i];
		if (xaY > maxXaY) maxXaY = xaY;
		if (xaY < minXaY) minXaY = xaY;
		if (xmY > maxXmY) maxXmY = xmY;
		if (xmY < minXmY) minXmY = xmY;
		//什么乱七八糟的
	}
	//然后简单了：
	long long dist1 = maxXaY - minXaY;
	long long dist2 = maxXmY - minXmY;
	return max(dist1, dist2);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);//读入优化！
	int n, op;
	cin >> n >> op;
	vector<long long> x(n), y(n);
	for (int i = 0; i < n; ++i) cin >> x[i] >> y[i];//读入
	long long ans;
	if (op == 1) ans = hypot(x, y, n);//欧几里得距离
	else ans = mhd(x, y, n);//曼哈顿距离
	cout << ans << endl;
	return 0;
}
```

---

## 作者：DashZhanghanxu (赞：1)

# 解析
数学题，建议学过欧几里得距离和曼哈顿距离后再来观看此文章（没学过看一下题目即可）。

此题主要就是求出没两点之间的欧几里得距离或曼哈顿距离，并找出最大值。如果枚举肯定会超时（仅限于 $opt = 2$）。那么我们可以求出 $x + y$ 和 $x - y$ 的最大值和最小值，通过组合计算出最大的曼哈顿距离。最后如果 $opt = 1$ 则输出欧几里得距离最大值的平方，否则输出曼哈顿距离最大值。
# CODE
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ll long long
#define int long long
#define O2 ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
ll re[1000005][2]; 
signed main() {
    O2;
    int n, op;
    cin >> n >> op;
    for (int p = 0; p < n; ++p) {
        cin >> re[p][0] >> re[p][1];
    }
    if (op == 1) {
        ll ans = 0;
        for (int k = 0; k < n; ++k) {
            for (int l = k + 1; l < n; ++l) {
                ll c = re[k][0] - re[l][0];
                ll z = re[k][1] - re[l][1];
                ll w = c * c + z * z;
                if (w > ans) {
                    ans = w;
                }
            }
        }
        cout << ans << endl;
    } else if (op == 2) {
        ll maxx = LLONG_MIN, minx = LLONG_MAX;
        ll maxn = LLONG_MIN, minn = LLONG_MAX;
        for (int q = 0; q < n; ++q) {
            ll x = re[q][0];
            ll y = re[q][1];
            ll sum = x + y;
            ll diff = x - y;
            if (sum > maxx) {
                maxx = sum;
            }
            if (sum < minx) {
                minx = sum;
            }
            if (diff > maxn) {
                maxn = diff;
            }
            if (diff < minn) {
                minn = diff;
            }
        }
        cout << max(maxx - minx, maxn - minn) << endl;
    }

    return 0;
}
```

---


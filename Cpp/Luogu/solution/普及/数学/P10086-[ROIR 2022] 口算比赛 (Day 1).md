# [ROIR 2022] 口算比赛 (Day 1)

## 题目背景

翻译自 [ROIR 2022 D1T1](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-regional-2022-day1.pdf)。

在一个规则新奇的口算比赛中，评委在黑板上写下 $n$ 个整数 $a_1, a_2, \dots , a_n$。参赛选手需要自行决定执行以下两种类型的指令：

1. 擦除第 $i$ 个数字，并将数字 $x$ 写入该位置。也就是说，如果黑板上原本写着数字 $a_1, a_2, \dots , a_n$，那么执行该指令后，数字序列将变为 $a_1, \dots , a_{i−1}, x, a_{i+1}, \dots , a_n$。
2. 将数字序列循环右移 $k$ 位。也就是说，如果黑板上原本写着数字 $a_1, a_2, \dots , a_n$，那么执行该指令后，数字序列将变为 $a_{n−k+1}, a_{n−k+2}, \dots , a_n, a_1, a_2, \dots , a_{n−k}$。

## 题目描述

每次执行完指令后，参赛选手需要将黑板上所有数字的总和报告给评委会。为了检查参赛选手的答案，评委们需要自己计算总和。

## 说明/提示

样例 $1$ 解释：

初始时，在黑板上写有数字序列：$4, 1, 2, 1, 5, 3$。

在执行第一条指令后，数字序列向右循环移动了 $3$ 位。新的数字序列为 $1, 5, 3, 4, 1, 2$。所有数字的总和为 $1 + 5 + 3 + 4 + 1 + 2 = 16$。

在执行第二条指令后，我们需要将第三个元素替换为 $10$。新的数字序列为 $1, 5, 10, 4, 1, 2$。所有数字的总和为 $1 + 5 + 10 + 4 + 1 + 2 = 23$。

在执行第三条指令后，我们需要将第四个元素替换为 $4$。由于第四个元素已经是 $4$，数字序列没有发生改变。所有数字的总和仍然是 $23$。

在执行第四条指令后，数字序列向右循环移动了 $1$ 位，变为 $2, 1, 5, 10, 4, 1$，总和不变。

最后，在执行第五条指令后，数字序列变为 $-10, 1, 5, 10, 4, 1$。最终数字序列的总和为 $-10 + 1 + 5 + 10 + 4 + 1 = 11$。

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $22$ | $n\le1000$ 且所有指令都是第一类 |
| $2$ | $17$ | $n\le1000$ 且所有第二类指令中 $k=1$ |
| $3$ | $23$ | $n\le1000$ |
| $4$ | $38$ | 无 |

对于 $100\%$ 的数据，$2 \le n \le 10^5$，$−10^9 \le a_i \le 10^9$，$1 \le q \le 10^5$。对于第一类指令，$1 \le i \le n$。对于第二类指令，$−10^9 \le x \le 10^9$，$1 \le k < n$。

## 样例 #1

### 输入

```
6
4 1 2 1 5 3
5
2 3
1 3 10
1 4 4
2 1
1 1 -10```

### 输出

```
16
23
23
23
11```

## 样例 #2

### 输入

```
3
1000000000 1000000000 1000000000
3
1 2 999999999
2 2
1 2 999999999```

### 输出

```
2999999999
2999999999
2999999998```

# 题解

## 作者：cff_0102 (赞：10)

因为最后只需要输出序列的数字总和，所以循环右移的时候，实际上并不需要真正的位移。可以用一个变量 $x$ 存储位移后新序列的第一个数在原序列的哪个位置，修改的时候将修改的位置加上这个变量再对序列长度取模，就能得到这一步修改的是原序列的哪个位置，然后在原序列上修改。

计算新的数字和时，也不需要从头到尾算一遍。因为一次只改一个数，所以新的数字和 $s'=s-a+a'$，其中 $s$ 是原数字和，$a$ 是被修改的位置原来的数，$a'$ 是这个位置要修改成哪个数字。

```python
n=int(input())
a=list(map(int,input().split()))
q=int(input())
x=0 # 位移后新序列的第一个数在原序列的哪个位置
ans=0
for i in a:
    ans+=i # 计算原序列的数字和
while q:
    q-=1
    s=list(map(int,input().split()))
    if s[0]==2:
        x-=s[1]
        x+=n
        x%=n
    else:
        p=(x+s[1]-1)%n
        ans-=a[p]
        a[p]=s[2]
        ans+=a[p]
    print(ans)
```

注意：

- 右移整个序列，相当于左移现序列的第一个数在原序列中的位置。
- 输入的数据是下标从 $1$ 开始的。

---

## 作者：哈哈人生 (赞：8)

## 思路
这种题也是老生常谈，我们可以用一个变量 $sum$ 来记录 $\sum a_i$ 的值，每次操作 $2$ 就用 $sum$ 减去 $a_i$ 加上 $x$ 就可以 $O(1)$ 正确更新 $sum$，注意此时 $a_i$ 的值也要更新为 $x$，因为还有后续操作。

再考虑操作 $1$，如何也 $O(1)$ 完成并能和操作 $2$ 配合呢？于是我们就可以设一个变量 $jl$ 来记录向右移动的位数，移动超过了 $n$ 位就相当于移动了 $jl\bmod n$ 位。

再反观操作 $2$，这时我们就可以这样想，现在让你修改的是向右移动 $jl$ 位后的 $i$ 位，其实就是原先的 $(i-jl+n)\bmod n$ 位，此时我们再使用第一段的方法更新 $sum$ 和 $a_i$ 即可，代码总时间复杂度 $O(q)$。

## 代码
有个坑点，就是 $sum$ 一定要开长整型（因为极端数据可能开到 $10^5\times 10^9$）。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int q,n,a[100005],sum,op,x,y,jl=0;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],sum+=a[i];
	cin>>q;
	while(q--){
		cin>>op>>x;
		if(op==1){
			cin>>y;
			int wz=x-jl;
			if(wz<=0)wz+=n;
			sum=sum-a[wz]+y;
			a[wz]=y;
		}
		else{
			jl+=x;
			jl%=n;
		}
		cout<<sum<<endl;
	}
	return 0;
} 
```
点个赞吧。

---

## 作者：we_are_the_chuibing (赞：2)

没人写这题题解，所以我水一发。

这题还是比较简单，建议评橙或黄。

### 思路

定义一个指针 $now$，代表 $a_1$ 当前所在的位置。

先计算出来整个数列的总和，然后对于每次操作一，先将总和更新，再将数组改变。对于每次操作二，直接将 $now$ 的位置更新。注意对于位置的计算不能出错。

具体见代码。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,q,p,i,x,k,a[100001],now,ans;//不开long long见祖宗
int main(){
	cin>>n;
	for(int j=0;j<n;j++)cin>>a[j];
	for(int j=0;j<n;j++)ans+=a[j];//计算总和
	cin>>q;
	while(q--){
		cin>>p;
		if(p==1){//操作一
			cin>>i>>x;
			ans+=(x-a[(now+i-1)%n]);//更新总和
			a[(now+i-1)%n]=x;//更新数组
		}
		else{//操作二
			cin>>k;
			now=(now+n-k)%n;//更新指针now，注意取模不能出现负数
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：Loser_Syx (赞：1)

这么会 10086。

首先如果一个数组被右移了 $x$ 位后又右移 $y$ 位，那么这个数组相当于移动了 $x+y$ 位，记这个数字为 $k$，如果 $k \geq n$，则移动 $n$ 位之后还是原来那样，效果等同于移动 $k \bmod n$ 位。

其次，当右移了 $k$ 位之后，要想复原需要左移 $k$ 位，所以查询操作查询左移 $k$ 位之后的 $i$ 并更改即可，注意左移后的 $i$ 可能是负数下标。

```cpp
int a[201010];
signed main() {
	int n=read(),sum=0;
	for (int i=1;i<=n;++i) sum+=(a[i]=read());
	int q=read(),cnt=0;
	while (q--) {
		int op,i,x;
		read(op,i);
		if (op==1) {
			read(x);
			i-=cnt; if(i<=0)i+=n;
			sum-=a[i]; sum+=(a[i]=x);
		} else {
			cnt+=i;
			cnt%=n;
		}
		write(sum,'\n');
	}
	return 0;
}
```

---

## 作者：ivyjiao (赞：1)

这题跟 [P10058 Reverse and Rotate](https://www.luogu.com.cn/problem/P10058) 那题差不多，就是把反转改成了修改而已。

对于右移，处理的方法和[我在 P10058 Reverse and Rotate 里发的题解](https://www.luogu.com.cn/blog/578029/solution-p10058)一模一样，右移 $n$ 位相当于没位移，很套路不说了。

对于修改，我们先统计新数组的总和，再把现在应该修改的位置 $i-$ 位移的位数修改掉，但是这个下标可能是负数，所以我们对其加 $n$ 模 $n$ 即可，如果这个数最后是 $0$，把它改成 $n$。

对于输出答案，就是上面统计的总和。

别忘了开 long long。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[100001],q,op,k,x,now,ans;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],ans+=a[i];
    cin>>q;
    while(q--){
        cin>>op;
        if(op==1){
            cin>>k>>x;
            int rk=(k-now+n)%n;
            if(rk==0) rk=n;
            ans+=x-a[rk];
            a[rk]=x;
        }
        else{
            cin>>k;
            now+=k;
            now%=n;
        }
        cout<<ans<<endl;
    }
}
```

---

## 作者：_IceCream_ (赞：0)

## Content

给你一个 $n$ 个数的整数数列和 $q$ 次操作，每次操作要么修改数列中的一个数字，要么右移 $k$ 位，每次操作都要输出当前序列的和。

## Solution

既然是单点修改和求和操作，为什么不试试线段树呢？

所以第 $1$ 个操作已经出来了，就是线段树的单点修改。

那么第 $2$ 个操作呢？它说要循环右移 $k$ 位，但是线段树存储的数据都是静态，支持右移的线段树难免有些麻烦。

我们可以用一个变量记录在当前的操作时，数组右移了多少位。所以现在问题就变成了：实现一个支持单点修改的线段树，在每次操作时累加右移的个数。

**注意：** 这里没有提到区间查询是因为题目中需要的是数组的总和，可以直接输出，没有必要再写一个区间查询。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
int n, q; 
long long sum;
long long a[N];
long long tree[N << 2];

int f (int x) { // 计算 k 次右移后第 x 个数在哪个位置
	int t = x - sum;
	while (t < 1) t += n;
	return t; 
}

// 线段树部分
void pushup (int node) {tree[node] = tree[node << 1] + tree[(node << 1) + 1];}

void build (int node, int l, int r){
	if (l == r) {
		tree[node] = a[l];
		return ;
	}
	
	int mid = l + ((r - l) >> 1);
	build (node << 1, l, mid);
	build ((node << 1) + 1, mid + 1, r);
	pushup (node);
}

void modify (int node, int l, int r, int s, long long c) {
	if (l == r) {
		tree[node] = c;
		return ;
	}
	
	int mid = l + ((r - l) >> 1);
	if (s <= mid) modify (node << 1, l, mid, s, c);
	if (s > mid) modify ((node << 1) + 1, mid + 1, r, s, c);
	pushup (node);
}

int main(){
	
	scanf ("%d\n", &n);
	for (int i = 1; i <= n; ++i) scanf ("%lld", &a[i]);
	scanf ("%d", &q);
	
	build (1, 1, n);
	while (q--) {
		int opt;
		scanf ("%d", &opt);
		
		if (opt == 1) {
			int i;
			long long x;
			scanf ("%d%lld", &i, &x);
			modify (1, 1, n, f(i), x);  // 因为右移，所以这里要的是 k 次右移后的下标
			printf ("%lld\n", tree[1]); // 每次操作结束都需要输出和
		} else {
			int x;
			scanf ("%d", &x);
			sum += x;
			sum %= n; // n 次右移过后，数组不变，所以说可以模 n
			printf ("%lld\n", tree[1]);
		}
	}
	return 0;
}
```

---

## 作者：2021zjhs005 (赞：0)

这道题难度不高，大概上位红至下位橙。

Description
------------
给定 $n$ 个数组成的序列 $a_1$，$a_2$，$\ldots$，$a_n$，然后执行 $q$ 次操作，分以下两类：

- 将第 $i$ 个数变为 $x$。

- 将整个序列右移 $k$ 位。

求每次操作后序列的和。

- 对于 $100\%$ 的数据，$2 \le n \le 10^5$，$-10^9 \le a_i \le 10^9$，$1 \le q \le 10^5$。

- 对于操作 $1$，$1 \le i \le n$。

- 对于操作 $2$，$-10^9 \le x \le 10^9$，$1 \le k < n$。

solution
------------

如果没有操作 $2$，那么这道题就是水题。

现在有了操作 $2$，我们发现，操作 $2$ 是不会对总和进行变化，但是它可能会影响操作 $1$。

首先累加出 $a$ 序列的总和为 $ans$，接着用一个变量 $sum$ 表示目前右移了 $sum$ 位。

- 如果当前是操作 $2$，明显，$sum\gets sum+k$。但是超过 $n$ 相当于又回来一次接着右移，所以 $sum\gets (sum+k)\bmod n$。

  $k$ 就不用取余了，因为 $1\le k < n$。

- 如果当前是操作 $1$，应该被更改为 $x$ 的那个数在序列的下标应该是 $i - sum$。但是因为 $i - sum$ 可能会出现负数的情况，所以下标应该是 $(i - sum + n)\bmod n$。此时算出来的结果即为 $pos$，如果 $pos=0$，说明是最后一个，把 $pos$ 修改为 $n$。

  修改后的序列里数之和即为 $ans - a_{pos} + x$，就是把 $a_{pos}$ 替换为 $x$。 

注意 $ans$ 可能会溢出 `int`，所以要定 `long long`！


code
------------


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n,q,i,t,x,opt,sum,a[100005];
ll ans;
inline int read(){int s=0,w=1;char c=getchar();while(!isdigit(c)){if(c=='-') w=-1;c=getchar();}while(isdigit(c)){s=(s<<1)+(s<<3)+(c^48);c=getchar();}return s*w;}//快读优化，这里有压行。
int main(){
    n=read();
    for(i=1;i<=n;i++){
        a[i]=read();
        ans+=a[i];
    }
    q=read();
    while(q--){
        opt=read();
        if(opt==1){
            i=read();x=read();
            int pos=(i-sum+n)%n;
            if(!pos) pos=n;//求对应位置。
            t=a[pos];
            a[pos]=x;
            ans=ans-t+x;//算序列里数之和。
        }
        else{
            int k=read();
            sum=(sum+k)%n;//算右移动的位数。
        }
        printf("%lld\n",ans);
    }
	return 0;
}
```

耗时 $66$ 毫秒（把放抄袭代码改成正确代码后）。

---

## 作者：koukilee (赞：0)

题目：[[ROIR 2022 Day 1\] 口算比赛](https://www.luogu.com.cn/problem/P10086)

****

## 题意

给定两种操作：

1. 将数组的第 $i$ 位替换成 $x$。
2. 将数组整体循环右移 $k$ 位。

****

## 思路

明显对于操作 $1$，我们可以直接修改，时间复杂度 $O(1)$。

对于操作 $2$， 我们可以看到本题的数据范围：$2\ ≤\ n\ ≤10^5，1\ ≤\ q\ ≤10^5$。

明显不支持 $O(nq)$ 的暴力，我们考虑优化。

因为每次都是整体平移，我们发现它的相对位置并没有改变，所以并不用真的每次都全部在数组平移。

我们只需要记录这个数组的第一个数的位置即可。

****

## 参考代码

```c++
/* The code is from koukilee*/
#include<cstdio>

using ll = long long;
const ll MAXN = 1010100, mod = 1e9 + 7; 

//char buf[1<<21],*p1=buf,*p2=buf,obuf[1<<21],*O=obuf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
template <typename T>
inline void read(T &sum) {
    ll tf = 0; char ch = getchar(); sum = 0;
    while(ch < '0' || ch > '9') tf = ch == '-' ? 1 : 0, ch = getchar();
    while(ch >= '0' && ch <= '9') sum = (sum << 1) + (sum << 3) + (ch ^ 48), ch = getchar();
    (tf) && (sum =- sum);
}template <typename T,typename ...Args>
inline void read(T &tmp, Args &...tmps){read(tmp); read(tmps...);}

void printt(ll x){if(x >= 10) printt(x / 10); putchar(x % 10 + '0');} 
inline void print(ll x){x < 0 ? putchar('-'), printt(-x) : printt(x);}
template <typename T>
inline void put(T x){print(x), putchar('\n');}
template <typename T, typename ...Args>
inline void put(T &tmp, Args &...tmps){put(tmp); put(tmps...);} /*无所谓的一大堆头文件*/

ll n, s[MAXN], m, first = 1/*记录当前数组的开头在哪一位*/, ans;

inline ll nex(ll x){
	return x > n ? x -= n : x; /*判断这个数的下一个是哪一位*/
}

int main(){
	read(n);
	for(int i = 1; i <= n; i++) read(s[i]), ans += s[i]/*累加和*/;
	read(m);
	for(int i = 1; i <= m; i++){
		ll opt, l, x; read(opt), read(l);
		if(opt == 1){
			read(x), ans += x - s[nex(first + l - 1)]/*ans减去改变之前的值*/;
			s[nex(first + l - 1)] = x/*ans加上改变之后的值*/;
		}
		else first = first - l <= 0 ? first - l + n : first - l;/*判断循环之后的位置*/
		put(ans);/*输出*/
	}
    return 0;
}
```

~~`Last`，本题解如果有问题，请联系我修改! awa~~

---


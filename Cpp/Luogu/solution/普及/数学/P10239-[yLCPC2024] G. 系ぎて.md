# [yLCPC2024] G. 系ぎて

## 题目背景

> 与其说不甘心吧，这谱面到底是什么东西…  
> ——ReMiRiA  
> 虽然获得了冠军非常开心，但是这个谱面到底是什么？真的会收录吗？？  
> ——yoshiki

## 题目描述

扶苏很喜欢拆分自然数。

对给定的正整数 $n$，若 $n = i \times j \times k$，其中 $i,j,k$ 是正整数，则称三元组 $(i,j,k)$ 是 $n$ 的一组优秀的拆分。

三元组 $(i,j,k)$ 是有序的。例如，对于 $2 = 1 \times 1 \times 2 = 1 \times 2 \times 1 = 2 \times 1 \times 1$，我们称 $(1,1,2)$、$(1,2,1)$、$(2,1,1)$ 是三组不同的优秀的拆分。

现在，扶苏想问你，对于 $n = 1,2,3\dots N$，$n$ 的所有的优秀的拆分之和是多少。

形式化的，记 $f(n)$ 表示 $n$ 的优秀的拆分数量，你需要求出 $\sum_{i = 1}^N f(i)$。

## 样例 #1

### 输入

```
2```

### 输出

```
4```

## 样例 #2

### 输入

```
100```

### 输出

```
1471```

# 题解

## 作者：rui_er (赞：36)

unintended solution。

暴力枚举三元组中最小的数是什么、次小的数是什么，容易计算出最大的数的方案数，乘系数即可得到有序的方案数。

时间复杂度 $\displaystyle T(n)=O\left(\sum_{x=1}^{n^{\frac{1}{3}}}\left(\frac{n}{x}\right)^{\frac{1}{2}}\right)=O\left(n^{\frac{1}{2}}\int_0^{n^{\frac{1}{3}}}x^{-\frac{1}{2}}\text d x\right)=O\left(n^{\frac{2}{3}}\right)$。

```cpp
for(ll x = 1; x * x * x <= n; ++x) {
    for(ll y = x; x * y * y <= n; ++y) {
        if(x == y) {
            // y == z
            ++ans;
            // y != z
            ans += 3 * (n / (x * y) - (y + 1) + 1);
        }
        else {
            // y == z
            ans += 3;
            // y != z
            ans += 6 * (n / (x * y) - (y + 1) + 1);
        }
    }
}
```

---

## 作者：一扶苏一 (赞：13)

# G. 系ぎて

## Description

给定 $N$，设 $f(n)$ 表示 $i \times j \times k = n$ 的有序三元组 $(i, j, k)$ 数量，求 $\sum\limits_{n = 1}^N f(n)$。

## Analysis

首先考虑单个 $f(n)$ 的计算：

先枚举 $i$，如果 $j$ 是 $\frac n i$ 的因子，那么 $一定有唯一的 k = \frac{n}{ij}$ 组成一个数对，否则不存在相应的 $k$。于是对于一个确定的 $i$，合法的数对 $(j, k)$ 的数量就是 $\frac{n}{i}$ 的因子数，即 $d(\frac n i)$。


于是有：

$$
f(n) = \sum_{i \mid n} d(\frac{n}{i}) = \sum_{i \mid n} d(\frac n i) \times I(i) 
$$

其中 $I(i) = 1$ 是恒 $1$ 函数。于是 $f = d \circ I$。这里 $\circ$ 表示两个数论函数的迪利克雷卷积。因此 $f$ 是一个积性函数，我们可以线性筛出 $f$ 前若干项的值：

- 质数仅能被分解成 $(1, 1,p)$，$(1, p, 1)$，$(p, 1, 1)$ 三种形式，于是 $f(p) = 3$
- 质数的幂 $p^k$ 对应的所有分解都型如：$(p^i, p^j, p^{k - i - j})$，这里要求 $i + j \leq k$。枚举 $i$，则 $j$ 的范围就是 $[0, k - i]$。于是 $f(p^k) = \sum_{i = 0}^k (k - i + 1) = (1 + k)(2 + k) /2$。
- 否则若 $n$ 的最小素因子的幂是 $p^i$，则 $f(n) = f(p^i) \times f(\frac{n}{p^i})$。

要求 $f(i)$ 的前缀和 $S(n) = \sum_{i =1}^n f(i)$，考虑选取一个函数 $g$ 进行杜教筛 $S(n)g(1) = \sum_{i = 1}^n (f \circ g)(i) - \sum_{i = 2}^n g(i) S(\left\lfloor\frac{n}{i}\right\rfloor)$。


已知 $f = d \circ I$，注意到 $I \circ \mu = \epsilon$，其中 $\epsilon$ 是迪利克雷卷积单位元 $\epsilon(n) = [n = 1]$，我们选取 $g = \mu$，于是 $f \circ g = d \circ I \circ \mu =d$。带入杜教筛公式，有：

$$
S(n) = \sum_{i = 1}^n d(n) - \sum_{i = 1}^n \mu(i) S(\left\lfloor\frac{n}{i}\right\rfloor)
$$

$\sum_{i = 1}^n d(n)$ 的计算：考虑 $i$ 的贡献是所有 $i$ 的倍数，所以 $d(n) = \sum_{i = 1}^n \left\lfloor\frac{n}{i}\right\rfloor$，可以整除分块。

$\mu$ 的部分和的计算：对 $\mu$ 再套一层杜教筛。注意到筛 $\mu$ 部分用到的关键点和 $f$ 是一样的，所以即使嵌套杜教筛，状态数仍是不变的，复杂度依然是 $O(n^{\frac 2 3})$。杜教筛 $\mu$ 的过程只需要取 $g = I$，则 $f \circ g = \epsilon$。

#### 做法 2 (by FR(@negiizhao))

杜教筛其实是计算了两个数论函数相除（数论函数的乘法即 Dirichlet 卷积，除法是它的逆运算）后，所有整除位置的前缀和。它是由乘法的整除分块做法转化得来的。在上面的做法中，为了计算 $d = I * I$，我们利用 $I = \epsilon / \mu$ 转换为 $d = I * I = I / \mu$ 再使用杜教筛解决。

但我们为什么不直接计算乘法呢？对于每个整除位置，我们可以使用数论分块计算 $d$ 的前缀和，但对于较小的位置，我们可以使用类似杜教筛的优化，直接线性筛出 $d$。最后再用整除分块算出 $d * I$ 即可。

时间复杂度 $O(n^{2/3})$。

#### 做法 3 (by FR(@negiizhao))

使用 https://negiizhao.blog.uoj.ac/blog/8961 所说的非人为分块的“某种意义上最优”的乘法，同样可以做到时间复杂度 $O(n^{2/3})$。此外，注意到这个做法每次算出贡献都是在 $d$ 的某个整除位置加上一个值，可以直接算出它对最终答案的贡献，进一步优化到空间复杂度 $O(1)$。

#### 做法 4 (by FR(@negiizhao))

使用 https://negiizhao.blog.uoj.ac/blog/8961 的积性函数求和做法。或者取消小素数贡献，即“稀疏化”之后直接乘起来，再附加上小素数贡献。

时间复杂度 $O(n^{2/3}\log^{-4/3} n)$，空间复杂度 $O(n^{1/2})$​。

#### 做法 ?

还有一些渐进更快但是 OI 范围内并不实用的做法，如上文链接中提到的 $O(n^{2/3}\log^{-3/2} n)$ 的做法和目前最快的 $\tilde O(n^{1/2})$ 的做法。也许某一天它们能被改进变得更加实用。

## std

出题人线性筛是自己 DIY 的所以写的奇丑无比。

```cpp
#include <bits/stdc++.h>

typedef unsigned long long int ull;

const int maxn = 20000000;

ull mu[maxn], f[maxn];
std::bitset<maxn> np;
std::vector<int> p;
int minp[maxn], c[maxn], minpk[maxn];

void init() {
  f[1] = mu[1] = 1;
  np.set(1);
  for (int i = 2; i < maxn; ++i) {
    if (!np.test(i)) {
      p.push_back(i);
      mu[i] = -1;
      f[i] = 3;
      c[i] = 1;
      minp[i] = minpk[i] = i;
    } else if (minpk[i] != i) {
      mu[i] = mu[i / minpk[i]] * mu[minpk[i]];
      f[i] = f[i / minpk[i]] * f[minpk[i]];
    } else {
      mu[i] = 0;
      f[i] = (c[i] + 2ull) * (c[i] + 1ull) / 2;
    }
    for (auto j : p) if (i * j < maxn) {
      int k = i * j;
      np.set(k);
      minp[k] = j;
      if (minp[i] == j) {
        c[k] = c[i] + 1;
        minpk[k] = minpk[i] * j;
      } else {
        c[k] = 1;
        minpk[k] = j;
      }
      if (i % j == 0) break;
    } else break;
  }
  for (int i = 2; i < maxn; ++i) {
    mu[i] += mu[i - 1];
    f[i] += f[i - 1];
  }
}

ull M(long long n) {
  static std::unordered_map<long long, ull> rec;
  if (n < maxn) return mu[n];
  if (rec.count(n)) return rec[n];
  ull ans = 1;
  for (long long i = 2; i <= n; ++i) {
    long long x = n / i, y = n / x;
    ans -= (y - i + 1ull) * M(x);
    i = y;
  }
  return rec[n] = ans;
}

ull S(long long n) {
  static std::unordered_map<long long, ull> rec;
  if (n < maxn) return f[n];
  if (rec.count(n)) return rec[n];
  ull ans = n;
  for (long long i = 2; i <= n; ++i) {
    long long x = n / i, y = n / x;
    ans += (y - i + 1ull) * x;
    ans -= S(x) * (M(y) - M(i - 1));
    i = y;
  }
  return rec[n] = ans;
}

int main() {
  long long n;
  std::cin >> n;
  init();
  std::cout << S(n) << std::endl;
}
```

---

## 作者：飞雨烟雁 (赞：10)

提供一个 $\Theta\left((n\log n)^{3/5}\right)$ 的做法。

------------

若记 $F(n)=\sum_{k=1}^n\lfloor \frac nk\rfloor$，则答案为：

$$\sum_{k=1}^nF\left(\left\lfloor \frac nk\right\rfloor\right)$$

如果直接利用整除分块套整除分块的话，可以做到 $\Theta(n^{3/4})$ 的时间复杂度。


------------

在此基础上，利用线性筛预处理可以做到更优的时间复杂度。

设我们线性筛出 $1\sim B$ 的 $F$ 值，则对于 $k=\lfloor\frac nB\rfloor$ 的 $F(\lfloor \frac n1\rfloor),F(\lfloor \frac n2\rfloor),\cdots,F(\lfloor \frac nk\rfloor)$ 的部分，我们仍需整除分块，总时间复杂度为：

$$B+\sum_{i=1}^{n/B} \sqrt{\frac ni}\approx B+\frac n{\sqrt B}$$

取 $B=\Theta(n^{2/3})$ 即得 $\Theta(n^{2/3})$ 的时间复杂度。

------------

除了用线性筛预处理之外，我们还可以利用 [DIVCNT1](https://www.luogu.com.cn/problem/SP26073) 的方法，其时间复杂度为：

$$\sum_{i=1}^{\sqrt n}\sqrt[3]{i}\log n+\sum_{i=1}^{\sqrt n}\sqrt[3]{\frac ni}\log n\approx  \Theta(n^{2/3}\log n)$$

似乎变劣了呢。

------------

~~能不能给力一点啊？~~

那让我们把两种方法结合在一起，用线性筛预处理 $1\sim B$ 的值，然后用 DIVCNT1 求解 $B\sim n$ 的值，如此的时间复杂度为：

$$B+\sum_{i=1}^{n/B} \sqrt[3]{\frac ni}\log n\approx B+\dfrac{n\log n}{B^{2/3}}$$

取 $B=\Theta\left((n\log n)^{3/5}\right)$ 即得时间复杂度为 $\Theta\left((n\log n)^{3/5}\right)$ 的算法。

代码如下：

```cpp
#include <cstdio>
#include <cmath>
#define ll long long
#define ul unsigned long long
#define InHyperbola(x, y) ((x) * (y) <= (n))

struct Vec{
	int x, y;
	Vec(int x0 = 0, int y0 = 0){ x = x0, y = y0;}
	Vec operator + (const Vec a){ return Vec(x + a.x, y + a.y);}
}Stk[50000];

ul DIVCNT1(ll n){
	int m = sqrt(n), cm = cbrt(n), tot = 0;
	ll x = n / m, y = m + 1, res = 0;
	Vec L, R, M;
	Stk[++tot] = Vec(1, 0), Stk[++tot] = Vec(1, 1);
	while(1){
		L = Stk[tot--];
		while(!InHyperbola(x + L.x, y - L.y)){
			res += x * L.y + (L.y + 1) * (L.x - 1) / 2;
			x += L.x, y -= L.y;
		}
		if(y <= cm) break;
		while(R = Stk[tot--], InHyperbola(x + R.x, y - R.y)) L = R;
		++tot;
		while(1){
			M = L + R;
			if(InHyperbola(x + M.x, y - M.y)){
				if((double)n / (x + M.x) / (x + M.x) <= (double)R.y / R.x) break;
				L = M;
			}
			else Stk[++tot] = (R = M);
		}
	}
	for(int i = 1; i < y; ++i) res += n / i;
	return 2 * res - 1ll * m * m;
}

const int Mx = 3141593;

bool Vis[Mx];
int Prime[226280], tot;
int D[Mx];
void Sieve(int Nx){
	D[1] = 1;
	for(int i = 2; i < Nx; ++i){
		if(!Vis[i]) Prime[++tot] = i, D[i] = 2;
		for(int j = 1; j <= tot && Prime[j] * i < Nx; ++j){
			Vis[i * Prime[j]] = 1;
			if(i % Prime[j] == 0){
				D[i * Prime[j]] = (D[i] << 1) - D[i / Prime[j]];
				break;
			}
			D[i * Prime[j]] = D[i] << 1;
		}
	}
	for(int i = 2; i < Nx; ++i) D[i] += D[i - 1];
}

int min(int a, ll b){ return a > b ? b : a;}
ul GetSum(ll x){ return x < Mx ? D[x] : DIVCNT1(x);}

int main(){
	
	ll n;
	scanf("%lld", &n);
	Sieve(min(Mx, n + 2));
	ul ans = 0;
	for(ll l = 1, r; l <= n; l = r + 1){
		r = n / (n / l);
		ans += GetSum(n / l) * (r - l + 1);
	}
	printf("%llu", ans);
	
	return 0;
}
```

---

## 作者：negiizhao (赞：7)

使用一套[核弹级的工具](https://negiizhao.blog.uoj.ac/blog/8961)是可以做到空间 $O(\sqrt n)$ 时间 $O(n^{2/3}\log^{-4/3}n)$ 的。当然我们还有复杂度更快的做法，但是在 OI 范围内很难比这个做法更加有效。

不过这套工具实现起来还是太重量级了。我们看一个简单一点的做法，只实现里面所说的乘法，用 $O(n^{2/3})$ 时间解决这个题（上面的做法可以理解为利用函数的积性人为制造稀疏性，从而减少计算量，达到 $O(n^{2/3}\log^{-4/3}n)$）。

---

那么现在具体解释一下如何实现。

我们知道，如果我们有数论函数 $f$ 和 $g$ 的所有整除位置前缀和，可以用整除分块计算出 $fg$ 的所有整除位置前缀和。这个做法时间复杂度为 $O(n^{3/4})$。

顺便一提，“杜教筛”相当于是计算 $f/g$，使用类似 $O(n^2)$ 算多项式除法的方法，用一项一项算乘法的方法倒推出来。

除法“杜教筛”可以用预处理小值的方法做到 $O(n^{2/3})$，乘法显然同样可以。这样我们很容易用 $O(n^{2/3})$ 时间计算乘法。

---

可以看出，所有整除位置前缀和的信息是很重要的，有些作者给它起了“基本和组”“块筛”之类的名字。

---

那么回到这道题。如果将值全为 $1$ 的数论函数记为 $\zeta$，这题答案即为 $\sum_{i=1}^n(\zeta^3)(i)$（数论函数的乘法当然是 Dirichlet 卷积）。直接计算两次乘法即可。有的做法使用了杜教筛，相当于是利用了 $f \times \zeta = f / \mu$，用杜教筛算 $\mu$ 再除以 $\mu$ 来实现乘上 $\zeta$，实际上绕了个大弯。

---

但我们实际上可以用上面链接里避免人为分块的做法做得更好。

![双曲线](https://cdn.luogu.com.cn/upload/image_hosting/4h0qu8vq.png)

乘法中每次整除分块对某个 $m$ 计算了 $\sum_{xy \le m}f(x)g(y)$，相当于是对双曲线下每个整点 $(x, y)$ 统计 $f(x)g(y)$。

那么为什么对较小的值单独算可以算得更快呢？因为在 $m$ 较小时双曲线非常密集，常常叠在一起，整除分块做了很多重复的计算。

怎么解决这个问题呢？我们直接对整点考虑它哪些双曲线下，注意到双曲线在对角线两边，分别趋近两个坐标轴。因此我们从对角线开始，平行于坐标轴方向，用类似整除分块的做法，每次计算被双曲线割出来的一段的贡献。这样同样可以做到 $O(n^{2/3})$ 计算乘法。

回到题目，这个做法的优势在于能直接算出对乘积某处的贡献，而不需要预处理某些信息。而题目要求计算的是 $\zeta^3 = \zeta^2 \times \zeta$ 在 $n$ 处的前缀和，算出对 $\zeta^2$ 某处的贡献后可以进一步得到对最终答案的贡献。因此我们得到了一个时间 $O(n^{2/3})$ 空间 $O(1)$ 的做法。

---

参考代码

```cpp
#include <bits/stdc++.h>

int main()
{
	uint64_t N, Ans = 0;
	
	std::cin >> N;
	
	int S2 = sqrt(N + 0.5);
	
	for (int i = 1; i <= S2; ++i)
	{
		uint64_t Ni = N / i;
		{
			int j = i + 1;
			for (int tj; j <= S2; j = tj)
			{
				uint64_t Nij = Ni / j;
				tj = Ni / Nij + 1;
				Ans += (tj - j) * Nij;
			}
		}
		{
			uint64_t j, tj = i + 1 <= S2 ? Ni / (Ni / S2) : i;
			for (int Nij = Ni / (tj + 1); Nij >= 1; --Nij)
			{
				j = tj;
				tj = Ni / Nij;
				Ans += (tj - j) * Nij;
			}
		}
	}
	Ans *= 2;
	for (int i = 1; i <= S2; ++i)
		Ans += N / (1ULL * i * i);
	
	std::cout << Ans << '\n';
	
	return 0;
}
```

---

## 作者：DDF_ (赞：6)

## 题面

简述一下就是求 $x \times y \times z \le n$ 的三元组 $[x,y,z]$ 数量。

## 思路

分三种情况讨论，我们可以得到这样的结论：

- 如果 $x \ne y \ne z$，因为三个元素互不相同的三元组有 $6$ 种不同的排列，所以三元组 $[x,y,z]$ 对答案有 $6$ 的贡献。

- 如果 $x = y \ne z$，因为只有两个元素相同的三元组有 $3$ 种不同的排列所以三元组 $[x,y,z]$ 对答案有 $3$ 的贡献。

- 如果 $x = y = z$，因为三个元素都相同的三元组有 $1$ 种不同的排列，所以三元组 $[x,y,z]$ 对答案有 $1$ 的贡献。

所以我们只要枚举出不同情况下无序三元组的数量就可以的出有序三元组的数量。

然后对这三种情况进行枚举。

如果 $x \ne y \ne z$，那么将 $x,y,z$ 从小到大枚举，然后可以发现枚举出 $x$ 和 $y$ 时，对应的 $z$ 取值范围也会得出，为 $y < z \le \lfloor \frac{n}{x \times y} \rfloor$，则这种方案对答案的贡献为 $6 \times (\lfloor \frac{n}{x \times y} \rfloor - y)$。

如果 $x = y \ne z$，那么枚举 $x$，得出 $z$ 的取值范围为 $0 < z \le \lfloor \frac{n}{x^{2}} \rfloor$，且当 $x^{3} \le n$ 时 $z \ne x$，那么这种方案对答案的贡献为 $3 \times (\lfloor \frac{n}{x^{2}} \rfloor - [x^{3} \le n])$。

如果 $x = y = z$，那么 $x$ 的范围为 $0 < x \le \lfloor n^{\frac{1}{3}} \rfloor $，则这种方案对答案的贡献为 $\lfloor n^{\frac{1}{3}} \rfloor$。

时间复杂度 $O(n^{\frac{2}{3}})$。

## 代码

多说无益，来看代码。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,ans;
int main() {
	scanf("%lld",&n);
	for(ll i=1;i*i*i<=n;i++) {
		for(ll j=i+1;j*j*i<=n;j++) 
		    ans+=max(0ll,n/(i*j)-j)*6ll; //第一种情况，x!=y!=z
		ans++; //第三种情况，x=y=z
	}
	for(ll i=1;i*i<=n;i++) 
	    ans+=(n/(i*i)-(i*i*i<=n))*3ll; //第二种情况，x!=y=z
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Pengzt (赞：6)

[P10239](https://www.luogu.com.cn/problem/P10239)

#### Problem

记 $f(i)$ 表示满足 $abc = i$ 的三元组 $(a, b, c)$ 的数量。给定 $n$，求 $\sum\limits_{i = 1}^{n} f(i)$。

$n\le 10^{10}$。

时空限制：2.5s，512MB。

#### Sol

一开始看成单点修改，以为直接暴力就可以了/gg。

发现如果要筛的话其实有点麻烦，还不能只用线性筛，于是先想一下暴力。

先考虑单点修改的情况：枚举 $\forall i\le j\le k,ijk = n$ 的情况，然后注意一下有 $1,2,3$ 个不同的数的贡献，即分别为 $6,3,1$。发现只需要枚举 $i\le j$，然后 $i\le \sqrt[3]{n}$，那么 $k$ 其实就是知道的了。

然后我们发现这个过程其实是可以一次性的统计出所有 $ij(k')\le n$ 的贡献，于是就可以一次性统计多个贡献了。

时间复杂度为：$\mathcal{O}(\sum\limits_{i = 1}^{n^{\frac 13}} \lfloor\frac{n}{i}\rfloor^2)=\mathcal{O}(n^{\frac 23})$。

#### Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define sz(a) ((int) (a).size())
#define vi vector < int >
#define pb emplace_back
using namespace std;
ll n;
int main() {
  ios :: sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  cin >> n;
  unsigned long long ans = 0;
  for(ll i = 1; i * i * i <= n; ++i) {
    ll t = n / i / i;
    ++ans;
    ans += 3 * (t - i);
    for(ll j = i + 1; i * j * j <= n; ++j) {
      ll k = n / i / j;
      ans += 3;
      ans += 6 * (k - j);
    }
  }
  cout << ans << "\n";
  return 0;
}
```

---

## 作者：OldDriverTree (赞：5)

这里给出一个玩反演玩魔怔的人的做法。

# Solution

推一波式子。

$$
\begin{aligned}
&\sum_{i=1}^N f(i)\\
=&\sum_{i=1}^N\sum_{j\vert i} d(\dfrac ij)\\
=&\sum_{j=1}^N\sum_{i=1}^{\lfloor\frac Nj\rfloor} d(i)\\
\end{aligned}
$$

对这个式子进行数论分块，对于 $\lfloor\dfrac Nj\rfloor\le 10^7$ 的 $j$，提前进行预处理，对于 $\lfloor\dfrac Nj\rfloor>10^7$，$j$ 最多只有 $1000$ 个，考虑单独处理：

$$
\begin{aligned}
&\sum_{i=1}^N d(i)\\
=&\sum_{i=1}^N \sum_{j\vert i} 1\\
=&\sum_{j=1}^N\lfloor\dfrac Nj\rfloor
\end{aligned}
$$

对这个式子进行数论分块即可。

# Code
```c++
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
const int N=1e7;
int n,ans,d[N+1];

int f(int x,int sum=0) {
	if (x<=N) return d[x];
	for (int l=1,r;l<=x;l=r+1)
	r=x/(x/l),sum+=(r-l+1)*(x/l);
	return sum;
}
main()
{
	scanf("%llu",&n);
	for (int i=1;i<=N;i++)
		for (int j=1;j<=N/i;j++)
			d[i*j]++;
	
	for (int i=1;i<=N;i++) d[i]+=d[i-1];
	for (int l=1,r;l<=n;l=r+1)
	r=n/(n/l),ans+=(r-l+1)*f(n/l);
	printf("%llu",ans);
	return 0;
}
```

---

## 作者：RAYMOND_7 (赞：3)

不太理解为什么其他题解写的这么麻烦，这里提供一个好想好写的做法。

题目要求是我们对于每个 $x \in [1, n]$，找出三元组 $(i,j,k)$ 使得 $ijk=x$，直接做需要考虑 $x$ 的性质，但这是完全没有必要的。

我们直接枚举三元组，显然当 $i\times j \times k \le n$ 就会有贡献，则 $Ans = \sum\limits^{n}_{i=1}\sum\limits^{\lfloor\frac{n}{i}\rfloor}_{j=1}{\lfloor\frac{n}{ij}\rfloor}
$。

令 $F(i) = \sum\limits_{i=1}^{n}{\lfloor\frac{n}{i}\rfloor}$，这个可以用整除分块在 $O(\sqrt{n})$ 复杂度计算。$Ans = \sum\limits_{i=1}^{n}F(\lfloor\frac{n}{i}\rfloor)$，这里可以再套一层整除分块，总的复杂度是 $O(n ^ {\frac{3}{4}})$ 的，看起来比较劣，但实际跑的很快。

参考代码

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

#define int unsigned long long
#define For(i, l, r) for(int i = l; i <= r; i ++)

int n, m, ans;

int Fun(int n)
{
	int B = __builtin_sqrt(n);
	int s = 0;
	For(i, 1, B) s += n / i;
	return s * 2 - B * B;
}

signed main()
{
    scanf("%llu", &n);
	for(int l = 1, r; l <= n; l = r + 1)
	{
		r = n / (n / l);
		ans += (r - l + 1) * Fun(n / l);
	}
	printf("%llu\n", ans);
	return 0;
}
```

---

## 作者：幸存者 (赞：2)

考虑到 $i,j,k$ 很难处理，不妨假设 $i\le j\le k$。

暴力枚举 $i,j$，容易发现 $i^3\le n,i\le j,i\times j^2\le n$，由已知条件，我们有 $i\times j\times k\le n,k\ge j$。

于是我们可以直接得到 $k\in[j,\lfloor\dfrac{n}{ij}\rfloor]$，但交换相同的数是没有意义的，所以计算方案数的时候考虑一下 $i=j$ 和 $j=k$ 的情况特殊处理即可。

## $\text{AC Code}$

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int n;
	cin >> n;
	int ans = 0;
	for (int i = 1; i * i * i <= n; i++)
	{
		for (int j = i; i * j * j <= n; j++)
		{
			int k = n / i / j;
			if (i == j) ans += 3 * (k - j) + 1;
			else ans += 6 * (k - j) + 3;
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：离散小波变换° (赞：2)

## 题解

考虑优秀的拆分方案数本质上是什么。

由于我们要找到一个有序三元组 $(i,j,k)$ 使得 $i\times j\times k=n$，如果当 $i,j$ 确定后 $k$ 也就唯一确定了。也就是说，对于数字 $n$ 来说它的拆分数量就是如下式子：

$$f(n)=\sum_{i=1}^n\sum_{j=1}^n[ij\mid n]$$

然后要对 $p=1,2,3,\cdots,n$ 求和，也就是要求：

$$\sum_{p=1}^n f(p)=\sum_{p=1}^n\sum_{i=1}^p\sum_{j=1}^p[ij\mid p]$$

做一些推导：

$$
\begin{aligned}
\sum_{p=1}^n\sum_{i=1}^p\sum_{j=1}^p[ij\mid p]&=\sum_{p=1}^n\sum_{i=1}^n\sum_{j=1}^n[ij\mid p] \\
&=\sum_{i=1}^n\sum_{j=1}^n \left\lfloor\dfrac{n}{ij}\right\rfloor\\
&=\sum_{m=1}^n\left\lfloor\dfrac{n}{m}\right\rfloor\sum_{i=1}^n\sum_{j=1}^n [ij=m] \\
\end{aligned}
$$

看上去那个 $\sum_i\sum_j[ij=m]$ 不太好搞，可以先去看前面那个 $\lfloor n/m\rfloor$。看上去是一个整除分块的形式。所以我们枚举整除分块的二元组 $(l,r)$ 如下：

$$
\begin{aligned}
\sum_{m=1}^n\left\lfloor\dfrac{n}{m}\right\rfloor\sum_{i=1}^n\sum_{j=1}^n [ij=m]&=\sum_{(l,r)}\left\lfloor\dfrac{n}{l}\right\rfloor \sum_{i=1}^n\sum_{j=1}^n [l\le ij\le r]\\
&=\sum_{(l,r)}\left\lfloor\dfrac{n}{l}\right\rfloor(S(r)-S(l-1))
\end{aligned}
$$

其中，

$$
\begin{aligned}
S(m)&=\sum_{i=1}^n\sum_{j=1}^n [ij\le m] \\
&=\sum_{i=1}^n \left\lfloor\dfrac{m}{i}\right\rfloor
\end{aligned}
$$

显然也是可以整除分块的。

---

如果这样做，复杂度可以做如下估计：

$$
\begin{aligned}
\sum_{i=1}^{\sqrt n}\sqrt{n/i}+\sqrt i&\approx \int_{0}^{n^{0.5}} \left(\dfrac{n}{i}\right)^{0.5} \mathrm dx \\
&= n^{0.5}\times \left. 2x^{0.5}\right|_{0}^{n^{0.5}}\\
&=2n^{0.75}
\end{aligned}
$$

额，然后因为评测机太慢就 TLE 了（尽管本地看上去能过）。所以需要用一个经典优化，也就是对于一个阈值 $h\ge \sqrt{n}$，设法快速求出 $S(1),S(2),S(3),\cdots,S(h)$，则复杂度可以如下估计：

$$
\begin{aligned}
T(h)+\sum_{i=1}^{n/h}\sqrt{n/i}&\approx T(h)+\int_{0}^{n/h} \left(\dfrac{n}{i}\right)^{0.5} \mathrm dx \\
&=T(h)+ n^{0.5}\times \left. 2x^{0.5}\right|_{0}^{n/h}\\
&=T(h)+2n/h^{0.5}
\end{aligned}
$$

其中 $T(h)$ 表示计算 $S(1),S(2),S(3),\cdots,S(h)$ 的复杂度。

---

回到原题目上，我们现在要对于 $m=1,2,\cdots,h$ 都计算出：

$$
S(m)=\sum_{i=1}^n \left\lfloor\dfrac{m}{i}\right\rfloor=\sum_{i=1}^m \left\lfloor\dfrac{m}{i}\right\rfloor
$$

直接计算比较困难。但可以考虑从 $i$ 的角度出发去更新 $S$ 的值。换言之，对于 $i=1,2,\cdots,h$，去把它的贡献累加到对应的 $S$ 上面去。那么可以发现，对于一个特定的 $i$，它会对 $j=i,i+1,i+2,\cdots,i+i-1$ 位置的 $S(j)$ 产生 $1$ 大小的贡献；对 $j=2i,2i+1,2i+2,\cdots,2i+i-1$ 位置的 $S(j)$ 产生 $2$ 大小的贡献；以此类推。那么可以使用差分数组进行维护，修改差分数组贡献的复杂度为：

$$O\left(\sum_{i=1}^h \lfloor h/i\rfloor \right)=O(h\log h)$$

从差分数组还原出 $S$ 的复杂度显然为 $O(h)$。

所以我们得到了一个复杂度为 $O(h\log h+n/h^{0.5})$ 的做法。取 $h=n^{2/3}$ 时可以得到一个比较优秀的 $O(n^{2/3}\log n)$ 的做法（这个不是最优的 $h$，但是最优的 $h$ 我不会表示）。然后就能过了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;

unsigned long long n;

long long cnt = 0;

const int MAXN = 1e6 + 3;
const int o = 1e6;

unsigned long long F[MAXN];

unsigned long long get_sum(unsigned long long m){
    if(m <= o)
        return F[m];

    unsigned long long ans = 0;
    for(unsigned long long l = 1, r;l <= m;l = r + 1){
        r = min(n, m / (m / l));
        ans += 1ull * (r - l + 1) * (m / l);
        cnt ++;
    }
    return ans;
}
unsigned long long get_ans(){
    unsigned long long ans = 0;
    unsigned long long tmp = 0;
    for(unsigned long long l = 1, r;l <= n;l = r + 1){
        r = min(n, n / (n / l));
        unsigned long long sum = get_sum(r);
        ans += 1ull * (n / l) * (sum - tmp);
        tmp = sum;
    }
    return ans;
}

int main(){
    
    for(int i = 1;i <= o;++ i){
        for(int j = 1;j <= o / i;++ j){
            F[i * j] += j;
            if(i * j + i <= o)
                F[i * j + i] -= j;
        }
    }

    for(int i = 1;i <= o;++ i)
        F[i] += F[i - 1];

    cin >> n;
    cout << get_ans() << endl;
    return 0;
}
```

---

## 作者：Iniaugoty (赞：1)

每组 $(i, j, k)$ 都能对 $ijk$ 造成 $1$ 的贡献，不妨枚举 $i, j, k$，然后化式子。

答案为

$$ \sum _ {i = 1} ^ {N} \sum _ {j = 1} ^ {\lfloor \frac {N} {i} \rfloor} \sum _ {k = 1} ^ {\lfloor \frac {N} {ij} \rfloor} 1 $$

发现 $k$ 不用枚举。

$$ \sum _ {i = 1} ^ {N} \sum _ {j = 1} ^ {\lfloor \frac {N} {i} \rfloor} \lfloor \frac {N} {ij} \rfloor $$

用新的 $j$ 替换掉原来的 $ij$。

$$ \sum _ {i = 1} ^ {N} \sum _ {i \vert j, j \le N} \lfloor \frac {N} {j} \rfloor $$

变换枚举顺序。

$$ \sum _ {j = 1} ^ {N} \sum _ {i \vert j} \lfloor \frac {N} {j} \rfloor $$

$i$ 也不用枚举。

$$ \sum _ {j = 1} ^ {N} \operatorname d(j) \lfloor \frac {N} {j} \rfloor $$

（其中 $\operatorname d (n)$ 表示 $n$ 的约数个数）

这是一个很整除分块的形式，问题转化成求 $\operatorname d$ 的前缀和。

线性筛 $\operatorname d$ 是简单的，再维护一个最小质因子出现个数即可。

但是 $N$ 的范围不允许，我们考虑杜教筛。

不难发现

$$\operatorname 1 * \operatorname 1 = \operatorname d$$

（其中 $\operatorname 1 (n) = 1$，$*$ 表示狄利克雷卷积）

根据莫比乌斯函数 $\mu$ 的性质，可以得到

$$\operatorname d * \mu = \operatorname 1$$

那么就有

$$\sum _ {i = 1} ^ {n} \operatorname d (i) = \sum _ {i = 1} ^ {n} \operatorname 1 (i) - \sum _ {i = 2} ^ {n} \mu (i) \operatorname d (\lfloor \frac {n} {i} \rfloor)$$

即

$$\sum _ {i = 1} ^ {n} \operatorname d (i) = n - \sum _ {i = 2} ^ {n} \mu (i) \operatorname d (\lfloor \frac {n} {i} \rfloor)$$

问题再一次转化成求 $\mu$ 的前缀和。

这是[【模板】杜教筛](/problem/P4213)的内容，这里不做赘述。

时间复杂度 $\mathcal O (\text {能过})$。

~~一般这种东西只要你相信他是正解他就是对的。~~

```cpp
#include <bits/stdc++.h>

#define F(i, a, b) for(int i = (a); i <= (b); ++i)
#define dF(i, a, b) for(int i = (a); i >= (b); --i)

using namespace std;
typedef long long LL;
typedef unsigned long long ull;
typedef unsigned int uint;
const int K = 5e6, N = K + 5;

LL n; ull ans;
// n 表示输入的 N，ans 表示答案

int pr[N], cnt; ull mu[N], d[N], t[N]; bool vis[N];
// pr[i] 表示第 i 个质数，cnt 表示质数个数，vis[i] 表示 i 是否被筛到过
// mu[i] 表示 i 的莫比乌斯函数值，d[i] 表示 i 的约数个数，t[i] 表示 i 最小质因子的出现个数
void Init() { // 线性筛预处理一部分
    mu[1] = d[1] = 1; F(i, 2, K) {
        if (!vis[i]) pr[++cnt] = i, mu[i] = -1, t[i] = 1, d[i] = 2;
        for (int j = 1; j <= cnt && i * pr[j] <= K; ++j) {
            vis[i * pr[j]] = 1;
            if (i % pr[j])
                mu[i * pr[j]] = -mu[i],
                t[i * pr[j]] = 1,
                d[i * pr[j]] = d[i] * 2;
            else t[i * pr[j]] = t[i] + 1,
                d[i * pr[j]] = d[i] / (t[i] + 1) * (t[i * pr[j]] + 1);
        }
    } F(i, 1, K) mu[i] += mu[i - 1], d[i] += d[i - 1];
}

unordered_map<LL, ull> Mu;
ull Get(LL n) { // 求莫比乌斯函数前缀和
    if (n <= K) return mu[n];
    if (Mu.find(n) != Mu.end()) return Mu[n];
    ull res = 1; for (LL l = 2, r; l <= n; l = r + 1)
        r = (n / l ? n / (n / l) : n), res -= Get(n / l) * (ull) (r - l + 1);
    return Mu[n] = res;
} unordered_map<LL, ull> mp;
ull Solve(LL n) { // 求约数个数前缀和
    if (n <= K) return d[n];
    if (mp.find(n) != mp.end()) return mp[n];
    ull res = n; for (LL l = 2, r; l <= n; l = r + 1)
        r = (n / l ? n / (n / l) : n), res -= Solve(n / l) * (Get(r) - Get(l - 1));
    return mp[n] = res;
}

int main() {
    // freopen("wmyr.in", "r", stdin);
    // freopen("wmyr.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n, Init();
    for (LL l = 1, r; l <= n; l = r + 1) // 整除分块
        r = (n / l ? n / (n / l) : n),
        ans += (Solve(r) - Solve(l - 1)) * (ull) (n / l);
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：Milthm (赞：1)

我们直接算贡献不好算，但是我们发现只要 $ijk\le n$ 就能造成贡献，所以答案其实就是：

$$\sum_{i=1}^n \sum_{j=1}^{\lfloor \frac{n}i \rfloor}\lfloor \frac{n}{ij}\rfloor$$
然后设 $f(n)=\sum_{i=1}^n\lfloor \frac{n}i \rfloor$，这个东西可以用整除分块来做，然后原式等于 $\sum_{i=1}^nf(\lfloor \frac{n}i \rfloor)$，这时候可以再套一层整除分块。

___
以上其实是某篇[题解](https://www.luogu.com.cn/article/4u9fhacb)的内容，当我学会了之后，高高兴兴的写出来，TLE……

似乎是我写的整除分块被卡常了，所以我采用了一种更好写也常数更小的整除分块（但是仅限 $f(n)=\sum_{i=1}^n\lfloor \frac{n}i \rfloor$ 这个基本的式子）。

假设我们求出了 $\sum_{i=1}^{\lfloor \sqrt n\rfloor}\lfloor \frac{n}i \rfloor$ 的答案，那么我们看这样一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qpr236iy.png)

显然图像对于 $y=x$ 这条直线是对称的，所以我们可以把刚才那个答案乘二，但是这样的话中间那个正方形算了两遍，所以要减去 $(\lfloor \sqrt n\rfloor)^2$。

这样虽然还是 $O(\sqrt n)$ 的，但是没有被卡常（高兴）。


```

---

## 作者：251Sec (赞：1)

所求即为 $\sum\limits_{i=1}^n \left\lfloor\dfrac{n}{i}\right\rfloor\sigma_0(i)$，直接整除分块，那么需要求整除分块位置的 $\sigma_0$ 前缀和，再套一层整除分块复杂度是 $O(n^{\frac{3}{4}})$ 的，本地跑了一下跑得飞快，交上去直接 T 飞了，这就是洛谷评测机给我的自信。那么我们直接把里层那个求 $\sigma_0$ 前缀和的整除分块换成 DIVCNT1 那个 $O(n^\frac{1}{3} \log n)$ 的做法，可以发现跑得飞快直接就过了。

---

## 作者：__xsy2013__ (赞：1)

扶苏大大貌似想复杂了。

我们可以通过暴力进行枚举三元组内最小的数、次小的数，很容易计算出最大的数的方案的数量，乘上系数就可以得到有序的方案的数量。

复杂度为 $O(n^{\frac{2}{3}})$。

```cpp
# include <bits/stdc++.h>
# define ll long long
using namespace std;
ll n, ans;
int main() {
	cin >> n;
	for(ll x = 1; x * x * x <= n; ++x) {
		for(ll y = x; x * y * y <= n; ++y) {
			if(x == y) {
				++ans;
				ans += 3 * (n / (x * y) - (y + 1) + 1);
			} else {
				ans += 3;
				ans += 6 * (n / (x * y) - (y + 1) + 1);
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

update

很遗憾，您上传的题解 题解：P10239 [yLCPC2024] G. 系ぎて 未能通过审核。原因是 应当补充对解法进一步的说明，不应只体现在代码的注释中； 。

很奇怪啊我连代码都没放啊。

那么放一下吧（

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P10239)

代码：

首先考虑二维的情况。

发现对于每一个 $i\in[1,n]$，对所有 $1\sim n$ 中 $i$ 的倍数都有 $1$ 的贡献。

答案即为 $\sum\limits_{i=1}^n\lfloor\frac{n}{i}\rfloor$。

整除分块可解。

接着拓展到三维。

显然如果确定了 $i$，那问题就变成了二维的。

也就是说，对于每一个 $i$，对答案的贡献为 $\sum\limits_{j=1}^{\lfloor\frac{n}{i}\rfloor}\lfloor\frac{n}{ij}\rfloor$。

直接整除分块套整除分块。

但提交后发现过不了。

有一个很简单的想法：令 $f_m=\sum\limits_{i=1}^m\lfloor\frac{m}{j}\rfloor$，先提前求出一些 $f_i$ 的值，然后再去跑整除分块。

由于你会发现当整除分块跑的一定程度的时候，$\lfloor\frac{n}{i}\rfloor$ 的密度是很大的。

也就是说基本上所有的 $f_i$ 我们都是能用上的。

理论上应该是挺快的。

现在的瓶颈就在于如何快速求 $f_i$。

~~可惜赛时没想出来怎么求。~~

发现对于一个 $i$，对 $f_1,f_2,\cdots,f_{i-1}$ 的贡献为 $0$，对 $f_i,f_{i+1},\cdots,f_{2i-1}$ 的贡献为 $1$，对 $f_{2i},f_{2i+1},\cdots,f_{3i-1}$ 的贡献为 $2$。

也就是对于任意 $i$ 和 $j$，$i$ 对 $f_{ij},f_{ij+1},\cdots,f_{i(j+1)-1}$ 的贡献为 $j$。

我们可以用差分来维护。

时间复杂度是我们很熟悉的调和级数，大约是 $O(m\log m)$ 的。

最后就是大约要算多少个 $f_i$。

所以就算了 $10^5$ 个，开个 O2 跑得还是挺快的。

@N_z_ 给出了我的总时间复杂度是 $O(m\log m+n^{\frac{3}{4}})$。

代码：

```cpp
#include<bits/stdc++.h>
#define LL unsigned long long
#define M 1000000
using namespace std;
LL n,sum,ans;
LL f[M+5];
int main(){
	for(int i(1);i<=M;++i)
		for(int j(1);j<=M/i;++j){
			f[i*j]+=j;
			if(j+1<=M/i) f[i*(j+1)]-=j;
		}
	for(int i(1);i<=M;++i) f[i]+=f[i-1];
	scanf("%llu",&n);
	LL l(1),r,k;
	while(l<=n){
		k=n/l;r=n/k;
		if(k<=M) ans+=f[k]*(r-l+1);
		else{
			LL _l(1),_r,res(0);
			while(_l<=k){
				_r=k/(k/_l);
				res+=(_r-_l+1)*(k/_l);
				_l=_r+1;
			}
			ans+=res*(r-l+1);
		}
		l=r+1;
	}
	printf("%llu\n",ans);
	return 0;
}
```

---

## 作者：AKPC (赞：0)

题目的 $f(n)=\sum\limits_{i=1}^n\sum\limits_{j=1}^{\lfloor\frac{n}{i}\rfloor}\sum\limits_{k=1}^{\lfloor\frac{n}{ij}\rfloor}[ijk=n]$。

如果 $i$ 确定了，$ijk=n$ 的 $(j,k)$ 的个数一定是 $\frac{n}{i}$ 的约数个数，因为对于 $\frac{n}{i}$，将其拆成两个正整数的乘积方案总数也是其约数个数，令一个数 $a$ 的约数个数是 $d(a)$，故 $f(n)=\sum\limits_{i=1}^n[i\mid n]d(\frac{n}{i})$，也就是 $\sum\limits_{i\mid n}d(\frac{n}{i})$。

那么题目需要我们求的是 $\sum\limits_{i=1}^n\sum\limits_{j\mid i}d(\frac{i}{j})$，可以考虑第二层循环枚举 $\frac{i}{j}$，那么原式变为 $\sum\limits_{i=1}^n\sum\limits_{j=1}^{\lfloor\frac{n}{i}\rfloor}d(j)$，如果做过 P3935 你应该知道 $\sum\limits_{i=1}^md(i)=\sum\limits_{i=1}^m\lfloor\frac{m}{i}\rfloor$，这个可以整除分块 $\Theta(\sqrt m)$ 求。令 $t(m)=\sum\limits_{i=1}^m\lfloor\frac{m}{i}\rfloor$，则原式等于 $\sum\limits_{i=1}^nt(\lfloor\frac{n}{i}\rfloor)$。

定一个阈值 $V=5\times10^6$，对于每个正整数 $i\leq V$ 的 $t(i)$，用杜教筛处理，预处理复杂度约 $\Theta(n\ln n)$。对于 $i\geq V$ 的 $t(i)$，因为在实际累加答案的时候只需要计算每个 $t(\frac{n}{i})$，而 $i\geq V$ 的 $\frac{n}{i}$ 不会太多，所以在统计的时候暴力处理。统计答案的复杂度较为玄学，为 $\Theta(\sqrt n)$，但是乘的常数比较大，不过 $\sqrt n$ 本身很小，所以是能过的。

[code](/paste/9lqgceda)。

---

## 作者：operator_ (赞：0)

# P10239 [yLCPC2024] G. 系ぎて

[题目传送门](https://www.luogu.com.cn/problem/P10239)

## 题解

枚举拆分中的 $i,j$，则 $f(n)=\sum\limits_{n|i}\sum\limits_{\frac{n}{i}|j}1$，后面那个直接就是 $\sigma_0(\dfrac{n}{i})$ （因数个数函数），即求 $\sum\limits_{n=1}^N\sum\limits_{n|i}\sigma_0(\dfrac{n}{i})$，可以直接枚举 $\dfrac{n}{i}$ 统计贡献，即 $\sum\limits_{i=1}^N\sum\limits_{n=1}^{\lfloor\frac{N}{i}\rfloor}\sigma_0(i)=\sum\limits_{i=1}^N\lfloor\dfrac{N}{i}\rfloor\sigma_0(i)$ 于是第一层整数分块就出来了。接下来考虑计算 $\sigma_0$ 的前缀和，依然可以枚举因子统计贡献，即 $\sum\limits_{i=1}^n\sigma_0(i)=\sum\limits_{i=1}^n\lfloor\dfrac{n}{i}\rfloor$，这就是第二层整数分块。直接做复杂度爆了，不过考虑到 $\sigma_0$ 是积性函数，可以直接线性筛预处理一部分，那么时间复杂度 $O(\dfrac{n^\frac{3}{2}}{T})$，空间复杂度 $O(T)$。虽然时空复杂度都不是很优秀，但应付这道题足够了（）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long
inline int rd() {
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}
const int T=5e6;
int n,ans,p[5000005],s[5000005],e[5000005],v[5000005],cnt;
void init() {
    s[1]=1;
	for(int i=2;i<=T;i++) {
		if(!v[i]) p[++cnt]=i,s[i]=2,e[i]=1;
		for(int j=1;j<=cnt&&i*p[j]<=T;j++) {
			v[i*p[j]]=1;
			if(i%p[j]==0) {
				s[i*p[j]]=s[i]/(e[i]+1)*(e[i]+2);
                e[i*p[j]]=e[i]+1;break;
			}
			else s[i*p[j]]=s[i]*2,e[i*p[j]]=1;
		}
	}
    for(int i=1;i<=T;i++) s[i]+=s[i-1];
}
unordered_map<int,int> mp;
int calc(int x) {
    if(x<=T) return s[x];
    if(mp[x]) return mp[x];
    int sum=0;
    for(int l=1,r;l<=x;l=r+1) r=x/(x/l),sum+=(x/l)*(r-l+1);
    return mp[x]=sum;
}
signed main(){
    cin>>n;init();
    for(int l=1,r;l<=n;l=r+1) r=n/(n/l),ans+=(n/l)*(calc(r)-calc(l-1));
    cout<<ans;
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

~~赛后赶紧抢题解~~

思路：要解决这个问题，我们可以先分析优秀的拆分的性质，并观察如何高效地计算所有优秀拆分的总和。对于每个数 $n$，我们考虑其所有可能的拆分，然后计算这些拆分的数量，并将其累加到总和中。

然而，由于 $N$ 可能非常大（高达 $10^{10}$），直接枚举每个数的所有拆分是不切实际的。我们需要找到一种更高效的方法。

我们可以考虑一个不同的思路：对于每个可能的拆分因子 $i$ 和 $j$，我们找出所有可能的 $n$，使得 $n = i \times j \times k$ 是一个优秀的拆分。这样，我们就可以通过遍历所有可能的因子对 $(i, j)$ 来计算所有优秀的拆分。

注意到，当我们考虑 $i$ 和 $j$ 时，第三个因子 $k$ 是由 $n$ 除以 $i \times j$ 得到的。因此，对于给定的 $i$ 和 $j$，我们需要找出所有满足 $n = i \times j \times \left( \frac{n}{i \times j} \right)$ 的 $n$。

我们可以观察到，当 $i \times j \leq N$ 时，这样的 $n$ 才会存在。因此，我们可以遍历所有 $i$ 和 $j$ 的组合，其中 $1 \leq i \leq j \leq \sqrt{N}$，并计算每个组合对应的 $n$ 的数量。

由于 $k$ 必须是一个正整数，我们还需要确保 $i \times j$ 能够整除 $n$。换句话说，我们需要检查 $i \times j$ 是否是 $n$ 的一个因子。

C++ 代码：

```cpp
#include <iostream>
#include <cmath>

using namespace std;

typedef unsigned long long ull;

const ull MOD = 1ULL << 64;

ull sumOfExcellentSplits(ull N) {
    ull sum = 0;
    for (ull i = 1; i * i <= N; ++i) {
        for (ull j = i; j * i <= N; ++j) {
            ull product = i * j;
            ull count = N / product; // 计算有多少个 n 可以被 i * j 整除
            sum = (sum + count) % MOD;
        }
    }
    return sum * 3 % MOD; // 每个拆分被计算了三次，所以要除以 3
}

int main() {
    ull N;
    cin >> N;
    cout << sumOfExcellentSplits(N) << endl;
    return 0;
}
```

请注意，每个拆分 $(i, j, k)$ 被计算了三次（因为 $(i, j, k)$、$(j, i, k)$ 和 $(k, i, j)$ 被视为不同的拆分，但实际上它们代表相同的拆分）。因此，在计算最终答案时，我们需要将总和除以 3。然而，由于我们只关心模 $2^{64}$ 的结果，我们实际上可以将总和乘以 3 的逆元，但是在这个特定情况下，由于 $3$ 和 $2^{64}$ 互质，我们可以简单地乘以 3 并再次取模。

此外，由于 $N$ 的范围可能非常大，我们需要确保使用 `unsigned long long` 类型来存储中间结果和最终结果，以避免整数溢出。

---

## 作者：Genius_Star (赞：0)

### 思路：

相当于求三元组 $i \times j \times k \le n$ 的数量。

考虑枚举 $i$，那么 $j$ 的范围只能在 $[1,\lfloor \frac{n}{i} \rfloor]$，此时可能的 $k$ 的数量就是 $\lfloor \frac{n}{i \times j} \rfloor$，则答案为：

$$\sum_{i=1}^n \sum_{j=1}^{\lfloor \frac{n}{i} \rfloor} \lfloor \frac{n}{i \times j} \rfloor$$

后面那串式子可以数论分块计算，定义：

$$F(n)=\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor=2 \times \sum_{i=1}^{\lfloor \sqrt{n} \rfloor} \lfloor \frac{n}{i} \rfloor - \lfloor \sqrt{n} \rfloor^2$$

那么原式可以化为：

$$\sum_{i=1}^n F(\lfloor \frac{n}{i} \rfloor)$$

发现也可以数论分块计算，于是数论分块套数论分块就做完了。

时间复杂度约为 $O(N^{\frac{3}{4}})$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
typedef double db;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n;
ll F(ll n){
	ll l,r,B=sqrt(n),ans=0;
	for(l=1;l<=B;l=r+1){
		r=n/(n/l);
		ans+=(r-l+1)*(n/l);
	}
	return 2ull*ans-B*B;
}
ll solve(ll n){
	ll l,r,ans=0;
	for(l=1;l<=n;l=r+1){
		r=n/(n/l);
		ans+=(r-l+1)*F(n/l);
	}
	return ans;
}
int main(){
	while(~scanf("%lld",&n)){
		write(solve(n));
		putchar('\n');
	}
	return 0;
}

```

---


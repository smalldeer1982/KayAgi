# [GESP202403 八级] 公倍数问题

## 题目描述

小 $A$ 写了一个 $N\times M$ 的矩阵 $A$，我们看不到这个矩阵，但我们可以知道，其中第 $i$ 行第 $j$ 列的元素 $A_{i,j}$ 是 $i$ 和 $j$ 的
公倍数（$i=1,\dots,N,j=1,\dots,M$）。现在有 $K$ 个小朋友，其中第 $k$ 个小朋友想知道，矩阵 $A$ 中最多有多少个元素可以是 $k$（$k=1,2,\dots,K$）。请你帮助这些小朋友求解。

注意：每位小朋友的答案互不相关，例如，有些位置既可能是 $x$，又可能是 $y$，则它同时可以满足 $x,y$ 两名小朋友的要求。

方便起见，你只需要输出 $\sum_{k=1}^{K}k\times ans_k$ 即可，其中 $ans_k$ 表示第 $k$ 名小朋友感兴趣的答案。

## 说明/提示

### 样例 1 解释

只有 $A_{1,1}$ 可以是 $1$，其余都不行。
$A_{1,1},A_{1,2},A_{2,1},A_{2,2}$ 都可以是 $2$，而其余不行。

因此答案是 $1\times 1+2\times 4=9$。

### 数据规模与约定

- 对于 $30\%$ 的测试点，保证 $N,M,K\le 10$；
- 对于 $60\%$ 的测试点，保证 $N,M,K\le500$；
- 对于 $100\%$ 的测试点，保证 $1 \leq N,M\le10^5$，$1 \leq K\le 10^6$。

## 样例 #1

### 输入

```
2 5 2```

### 输出

```
9```

## 样例 #2

### 输入

```
100 100 100```

### 输出

```
185233```

# 题解

## 作者：superballll (赞：22)

# 题目分析

题目中在不断的强调二维数组，也是挖了一个大大的坑！给出的数据范围中，$1\leq N,M\le10^5$ 这个二维数组一旦开了，就会喜提 **MLE**，直接就是 $0$ 分，小数据范围的 $60$ 分都是拿不到的。
 
其实题目中**注意**部分也进行了提示，就是二维数组中的值为了满足小朋友的要求是可以进行改变了的，而且是不是公倍数只跟二维数组 $A$ 的两个下标 $i$ 和 $j$ 有关，即只要能成为 $i$ 和 $j$ 的公倍数就符合要求。
 
假设 $k$ 是 $i$ 和 $j$ 的公倍数，那也就意味着 $i$ 和 $j$ 都是 $k$ 的因数，我们结合输入输出样例来进行分析：

当 $k=1$ 时，只有 $A_{1,1}$ 符合要求，这是因为 $1$ 只能是 $1$ 和 $1$ 的公倍数，也就是说因为 $1$ 的因数只有 $1$，因此是 $1\times1=1$ 个。
 
当 $k=2$ 时，$2$ 的因数有 $1$ 和 $2$，因此 $A_{1,1}$ $A_{1,2}$ $A_{2,1}$ $A_{2,2}$ 共 $2\times2=4$ 个位置都符合要求。

当 $k=4$ 时，$4$ 有 $1$ $2$ $4$ 共 $3$ 个因数，那么就有  $3\times3=9$ 个位置符合要求，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/buguh4wp.png)

当然，我们还要注意 $N$ 和 $M$ 的值，如果因数超出了相应的范围，我们就不能计算在内了。因此，这道题就变成：找到 $k$ 在分别在 $1 \sim N$ 和 $1 \sim M$ 范围内的因数的个数 $sn$ 和 $sm$，此时 $sn\times sm$ 即为 $k$ 符合要求的位置个数。最后分别求出 $1 \sim K$ 的符合要求的个数再按要求乘上系数再累加求和即可。

## 复杂度分析

如果采用枚举法分别枚举 $1 \sim K$ 在 $1 \sim N$ 和 $1 \sim M$ 中的因子个数的话，时间复杂度肯定会超，那我们换一种思路来实现该部分的操作。

对于数组字 $1$，是所有的 $k$ 的因子；\
对于数组字 $2$，是 $2,2+2\times1,2+2\times2,...$等数字的因子；\
对于数组字 $3$，是 $3,3+3\times1,3+3\times2,...$等数字的因子。\
因此，可用如下程序实现上述操作：

```
for(int i=1;i<=N;i++)
	for(int j=i;j<=K;j=j+i)
		sn[j]++;
```
此时 $sn[k]$ 表示在题目中二维数组的行中，$k$ 的因数的个数。然后用同样的方法求出在二维数组的列中 $sm[1] \sim sm[K]$ 的值，并在最终的计算中将两个数组的值以及系数 $k$ 相乘然后累加求和即可得到最终的结果。另外，别忘了开 `long long`，以及在计算最后的答案时，小心由于循环中定义的局部变量类型为  `int` 而导致的最终结果的错误！

# 代码
```
#include<bits/stdc++.h>
using namespace std;

int n,m,k;
int sn[1000005],sm[1000005];
long long ans=0;

int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=k;j=j+i)
			sn[j]++;
	for(int i=1;i<=m;i++)
		for(int j=i;j<=k;j=j+i)
			sm[j]++;
	for(int i=1;i<=k;i++)
		ans+=(long long)i*sn[i]*sm[i];
		
	cout<<ans;
	return 0;
} 
```

---

## 作者：spfa_ (赞：8)

[P10263 [GESP202403 八级]公倍数问题](https://www.luogu.com.cn/problem/P10263)

### 题目分析

题目相当于求多少个 $(x,y)$ 二元组满足 $1\le x\le n,1\le y\le m$ 且 $x\mid k,y\mid k$。那么对于每个 $k$，我们可以预处理出 $k$ 小于等于 $n$ 和 $m$ 的因数的个数，分别记为 $p_k$ 和 $q_k$。根据乘法原理，所有方案数为 $p_k\times q_k$，这道题就做完了，时间复杂度 $O(n\log n)$。

### code

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
#define mk make_pair
#define ll long long
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;

typedef vector <int> vi;
typedef pair <int, int> pii;

inline int rd() { int x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
inline ll rdll() { ll x = 0, f = 1; char c = getchar(); while (!isdigit(c)) f = c == '-' ? -1 : f, c = getchar(); while (isdigit(c)) x = (x<<3)+(x<<1)+(c^48), c = getchar(); return x*f; }
template <typename T> inline void write(T x) { if (x < 0) x = -x, putchar('-'); if (x > 9) write(x/10); putchar(x%10+48); }

int main() {
	int n = rd(), m = rd(), k = rd(); ll ans = 0;
	vi cn(k+1), cm(k+1);
	for (int i = 1; i <= n; ++i)
		for (int j = i; j <= k; j += i)
			++cn[j];
	for (int i = 1; i <= m; ++i)
		for (int j = i; j <= k; j += i)
			++cm[j];
	for (int i = 1; i <= k; ++i) ans += 1ll*i*cn[i]*cm[i];
	write(ans);
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：4)

这道题用数学的方法去做。

用 $cn$ 表示在行上的方案数，$cm$ 表示在列上的方案数，那么就可以算出 $ans_k$ 了：
$$
ans_k=cn_k \times cm_k
$$

考虑如何预处理 $cn$ 和 $cm$，可以发现：
- 对于 $cn$，我们设变量 $i$ 并从 $1$ 枚举到 $n$，每次将不大于 $k$ 的 $i$ 的倍数设为 $x$，让 $cn_x$ 加 $1$。


- $cm$ 也同理，只要让 $i$ 从 $1$ 枚举到 $m$ 即可。

代码如下：
```cpp
#include <iostream>
#define int long long
using namespace std;
int cm[1000001], cn[1000001];
signed main() {
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; i * j <= k; j++) {
			++cn[i * j];
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1; i * j <= k; j++) {
			++cm[i * j];
		}
	}
	int ans = 0;
	for (int i = 1; i <= k; i++) {
		ans += i * cn[i] * cm[i];
	}
	cout << ans;
}
```

---

## 作者：hgckythgcfhk (赞：3)

来自搬题人的题解。

题意比较清晰，所以不提供形式化题意，根据定义 $A_{i,j}$ 是 $i$ 和 $j$ 的公倍数，这等价于 $i$ 和 $j$ 分别是 $k$ 小于 $n$ 和小于 $m$ 的约数，根据乘法原理 $ans_k=\operatorname{d}_n(i)\times\operatorname{d}_m(j)$。

现在只要求 $\operatorname{d}_n$ 和 $\operatorname{d}_m$ 即可。

暴力求的话就会 $T$ 因为时间复杂度往少了说是 $O(\sum_{i=1}^{i\le k}\min(n,m,\sqrt i))$ 这个东西其实是比较大的，发现慢的原因是因为大部分不是约数，那我们可以直接枚举约数，具体的，可以这样：

```cpp
for(int i=1;i<=n;++i)for(int j=i;j<=k;j+=i)++dn[j];
for(int i=1;i<=m;++i)for(int j=i;j<=k;j+=i)++dm[j];
```

这个时间复杂度是 $O(\sum_{i=1}^{i\le \min(n,m)}\frac{k}{i})$ 的这个东西严格小于 $O(k\ln k)$，具体证明并不重要，自己用个很大的数验证一下然后把这个结论记住就好了，这个结论其实很常用，应该大部分人都知道。

现在，再说一下我在赛时因为脑抽想出来的离谱但能过的做法。

$A_{i,j}$ 是 $i$ 和 $j$ 的公倍数，等价于 $A_{i,j}$ 是 $\operatorname{lcm}(i,j)$ 的倍数，现在我们把 $A_{i,j}=\operatorname{lcm}(i,j)$ 的表打出来，$ans_k$ 就是这张表中的 $k$ 的约数个数，考虑计算 $k$ 的每个约数出现的次数，由于太菜我在赛时写了一个不需要脑子的做法，直接莫反求出每个数的出现次数，然后做一遍狄利克雷前缀和，好像有个紫色的模板题，但不重要，反正不是正解，时间复杂度 $O(k\sqrt{n})$，需要卡常，差点没过。

到最后半个小时的时候我突然想到了用约数个数的正解，我上面强调了小于 $n$ 和 $m$ 的约数，显然不能直接线性筛，由于赛时脑抽，想到了一个 $O(k\sqrt[3]k)$ 的做法，首先先只枚举小于 $\sqrt[3]k$ 的约数，这样顺带着就把大于 $(\sqrt[3]k)^2$ 的解决掉了，然后我们只需要对中间的一段进行分讨即可，具体的，中间一段要么是个质数，要么可以分成前面一段的两个数的乘积，要么是第一段的某个数的平方，对每一种形式都讨论一遍，比较毒瘤，赛时没写出来。

其实还是因为我太菜了，一看到数学题就直接大力莫反，这说明一件事情，看到一个题如果做过更强的版本的话一定不要直接用上，先静下心来想一想，说不一定有更简单的做法。

这是官方题解的 std，直接从 pdf 上复制会少缩进，我造数据的时候弄下来把缩进补上了。

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<int> count_divisors(int limit, int num) {
	vector<int> s(num + 1, 0);
	for (int i = 1; i <= limit; ++i) {
		for (int j = i; j <= num; j += i) {
			s[j] += 1;
		}
	}
	return s;
}
int main() {
	
	int N, M, K;
	cin >> N >> M >> K;
	vector<int> s_N = count_divisors(N, 1000000);
	vector<int> s_M = count_divisors(M, 1000000);
	long long result = 0;
	for (int k = 1; k <= K; ++k) {
		result += (long long)k * s_N[k] * s_M[k];
	}
	cout << result << endl;
	return 0;
}
```

说实话，官方题解写的确实有点装逼，但我感觉看了我上面放的两行应该就能写出来了。

---

## 作者：lovely_nst (赞：2)

# GESP-202403-01 公倍数问题

## 题目

求以下式子的值：

$$
\sum_{k=1}^K \sum_{i=1}^N \sum_{j=1}^M[k\mod lcm(i,j)=0]
$$

## 思路

正整数 $a$ 和正整数 $b$ 若都是 $c$ 的因数，可得 $c$ 对 $a$ 和 $b$ 取模的值都为 $0$，则 $c$ 一定是 $a$ 和 $b$ 的公倍数。

由此，问题就变成了求 $k$ 小于 $N$ 的因数个数与 $k$ 小于 $M$ 的因数个数的积。

用上述方法打暴力可以拿部分分，把暴力改成预处理即可通过了。

## AC Code

```cpp
// GESP-202403-01
#include <bits/stdc++.h>
#define int long long
using namespace std;
const long long mod = 1e9 + 7;
int n , m , k;
int cntn[1000005] , cntm[1000005];
signed main ()
{
	cin >> n >> m >> k;
	if (n == 0 || m == 0)
	{
		cout << 0;
		return 0;
	}
	for (int i = 2;i <= n;i ++)
		for (int j = i;j <= k;j += i)
			cntn[j] ++;
	for (int i = 2;i <= m;i ++)
		for (int j = i;j <= k;j += i)
			cntm[j] ++;
	long long ans = 0;
	for (int i = 1;i <= k;i ++)
		ans = (ans + 1ll * i * (cntn[i] + 1ll) * (cntm[i] + 1ll));
	cout << ans;
	return 0;
}
```

---

## 作者：xueshengyi (赞：2)

我是来 ~~水题~~ 硬钢的。


本人语文不好， ~~欢迎来喷~~ 勿喷。

思路很简单，一位一位的去考虑，把每一位上所有的公倍数的倍数的编号的小朋友的个数加一，行一次列一次，最后都加起来输出就行了。

## 注意开long long ！！！

~~马蜂不好，勿喷~~

```cpp
#include <bits/stdc++.h>
using namespace std;

#define For(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<=(y);i++)
#define foR(i,x,y,...) for(int i=(x),##__VA_ARGS__;i>=(y);i--)
#define Rep(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<(y);i++)
#define endl '\n'
#define debug(...)
#define debug1(a,i,...) cout<<i<<" "<<a[i]<<endl;
typedef long long ll;
#define fi first
#define se second
#define PII pair<int,int>
#define me(s,x) memset(s,x,sizeof s)
ll n,m,k;
ll a[1000005],b[1000005];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	For(i,1,n)
		For(j,1,k/i)
			a[i*j]++;
	For(i,1,m)
		For(j,1,k/i)
			b[i*j]++;			
	ll ans=0;
	For(i,1,k){
		ans+=ll(i*a[i]*b[i]);
	}
	cout<<ans<<endl;
	return 0;
}

```

~~欢迎前来hack~~

---

## 作者：c_y_y (赞：2)

# [P10263 题解](https://www.luogu.com.cn/problem/P10263)

本题建议评黄，实则在黄的中上难度了。

---
### 题意分析
给定 $n$，$m$，$K$。定义 $ans_{k}$ 为满足 $i$ 和 $j$ 的最小公倍数是 $k$ 的约数的数对 $(i,j)$ 的个数，求 $\sum_{k=1}^{K}k\times ans_k$。
### 题目解读
题目求 $\sum_{k=1}^{K}k\times ans_k$，因此不能直接通过 $i$ 和 $j$ 去更新 $k$。而由数据范围，先猜测预处理 $ans_{k}$。   
正着想很难想，我们可以**逆向思考**。   
假设，有一个数 $p$，存在一对 $(i,j)$ 满足上述条件，即 $i$ 和 $j$ 的最小公倍数 $L_{i,j}$ 是 $p$ 的约数。那么容易得到 $i$ 和 $j$ 都是 $p$ 的约数。   
那么，反过来，是不是就有：
>※：$ans_{k}=1\dots n$ 中是 $k$ 的约数的个数 $\times 1\dots m$ 中是 $k$ 的约数的个数。    

因为由唯一分解定理易得，一个数的两个约数的最小公倍数一定还是这个数的约数。因此**满足条件的 $(i,j)$ 一定在 $p$ 的约数当中，不满足条件的 $(i,j)$ 一定不在 $p$ 的约数当中**。排列组合一下，即可得到答案。   
现在问题变成了怎么预处理一个数的约数个数。  
这个简单，类似质数筛的方法，枚举 $i$，将符合的 $j$ 标记一下即可。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long read(){
	long long x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}
const int K=1e6+10;
int sumn[K],summ[K];
int main(){
	int n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++)
		for(int j=i;j<=K;j+=i) sumn[j]++;
	for(int i=1;i<=m;i++)
		for(int j=i;j<=K;j+=i) summ[j]++;
	long long ans=0;
	for(int i=1;i<=k;i++)
		ans=ans+(long long)i*sumn[i]*summ[i];//※结论得到
	cout<<ans;
    return 0;
}
```
代码还是很短，实则还是考思维。

---

## 作者：Tomle (赞：1)

# 思路

难度差不多是橙。

对于 $1$ 到 $k$ 的每个数 $i$，统计有多少个数对 $(a,b)$ 有 $a \le n, b \le m$ 且 $a$ 和 $b$ 是 $i$ 的因数。可以模仿埃式筛的过程，预处理出 $1$ 到 $k$ 中每个数因数有多少个因数小于 $n$，记为 $f_i$，以及有多少个因数小于 $m$，记为 $g_i$，答案为 $\sum\limits_{i=1}^k i \times f_i \times g_i$。时间复杂度 $\mathcal{O}(n \log k)$，空间复杂度 $\mathcal{O}(k)$。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, k, cnt1[1000005], cnt2[1000005];
long long ans;
int main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; i * j <= k; j++) {
			cnt1[i * j]++;
		}
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1; i * j <= k; j++) {
			cnt2[i * j]++;
		}
	}
	for (int i = 1; i <= k; i++) {
		ans += 1LL * i * cnt1[i] * cnt2[i];
	}
	cout << ans;
	return 0;
}
```

---

## 作者：lovely_nst (赞：1)

# GESP-202403-01 公倍数问题

## 题目

求以下式子的值：

$$
\sum_{k=1}^K \sum_{i=1}^N \sum_{j=1}^M[k\mod lcm(i,j)=0]
$$

## 思路

正整数 $a$ 和正整数 $b$ 若都是 $c$ 的因数，可得 $c$ 对 $a$ 和 $b$ 取模的值都为 $0$，则 $c$ 一定是 $a$ 和 $b$ 的公倍数。

由此，问题就变成了求 $k$ 小于 $N$ 的因数个数与 $k$ 小于 $M$ 的因数个数的积。

用上述方法打暴力可以拿部分分，把暴力改成预处理即可通过了。

## AC Code

```cpp
// GESP-202403-01
#include <bits/stdc++.h>
#define int long long
using namespace std;
const long long mod = 1e9 + 7;
int n , m , k;
int cntn[1000005] , cntm[1000005];
signed main ()
{
	cin >> n >> m >> k;
	if (n == 0 || m == 0)
	{
		cout << 0;
		return 0;
	}
	for (int i = 2;i <= n;i ++)
		for (int j = i;j <= k;j += i)
			cntn[j] ++;
	for (int i = 2;i <= m;i ++)
		for (int j = i;j <= k;j += i)
			cntm[j] ++;
	long long ans = 0;
	for (int i = 1;i <= k;i ++)
		ans = (ans + 1ll * i * (cntn[i] + 1ll) * (cntm[i] + 1ll));
	cout << ans;
	return 0;
}
```

---

## 作者：Milthm (赞：1)

我们其实可以发现，如果 $k$ 是 $i,j$ 的公倍数，则它又是 $i$ 的倍数又是 $j$ 的倍数（废话）。

所以我们可以发现，$k$ 的答案等于它小于 $n$ 的因数个数和小于 $m$ 的因数个数的乘积，所以我们可以类似埃氏筛的方法预处理出来所有小于 $k$ 的数的小于 $n,m$ 的因数个数，然后枚举 $k$ 就做完了。

### AC code

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define int long long
using namespace std;
int a[N],b[N],n,m,k,ans;
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;++i)for(int j=i;j<=k;j+=i)++a[j];
	for(int i=1;i<=m;++i)for(int j=i;j<=k;j+=i)++b[j];
	for(int i=1;i<=k;++i)ans+=i*a[i]*b[i];
	cout<<ans;
	return 0;
} 
```

---


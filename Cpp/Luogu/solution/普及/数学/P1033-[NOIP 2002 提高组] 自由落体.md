# [NOIP 2002 提高组] 自由落体

## 题目描述

在高为 $H$ 的天花板上有 $n$ 个小球，体积不计，位置分别为 $0,1,2,\cdots,n-1$。在地面上有一个小车（长为 $L$，高为 $K$，距原点距离为 $S_1$）。已知小球下落距离计算公式为 $d=0.5 \times g \times (t^2)$，其中 $g=10$，$t$ 为下落时间。地面上的小车以速度 $V$ 前进。

如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/1d177dhg.png)

小车与所有小球同时开始运动，当小球距小车的距离 $\le  0.0001$ (感谢 Silver_N 修正) 时，即认为小球被小车接受（小球落到地面后不能被接受）。

请你计算出小车能接受到多少个小球。


## 说明/提示

当球落入车的尾部时，算作落入车内。

**【题目来源】**

NOIP 2002 提高组第三题

## 样例 #1

### 输入

```
5.0 9.0 5.0 2.5 1.8 5
```

### 输出

```
1
```

# 题解

## 作者：zhenglier (赞：195)

~~震惊，我居然在信息里推物理式子~~

其实这一题出题人比较良心，没有卡精度，用double就能过。但这题坑点还是有的。

首先让我们来推式子。

对于任意一个小球，下落的时间是一样的，从公式

$d=0.5×g×(t^2)$

可得

$t=\sqrt{\frac{d}{0.5g}}$

因为这题很良心，把$g$设为10，于是有

$t=\sqrt{\frac{d}{5}}$

因为球只要$x$轴和车有重合且在那一瞬间的高度$h_0$满足$k>=h_0>=0$小车即可接住这个球~~(居然不会被车头撞飞)~~，所以小车可以接住小球的时间$t_0$满足

$\sqrt{\frac{h}{5}}>=t_0>=\sqrt{\frac{h-k}{5}}$

然后我们就算这个时间段内小车穿过了多少个小球的$x$轴就行了，但这似乎有些难度，我们可以把它转换成求哪个编号的球小车最早可以接住，哪个编号的球小车最晚可以接住。

首先根据上面哪个公式可以得到

$t_{min}=\sqrt{\frac{h-k}{5}}$

$t_{max}=\sqrt{\frac{h}{5}}$

最早接住的球的编号$i_b$为$int(s1-t_{min}*v+l)$，记住这里要加上l，因为最早的球可以被车尾接住。

最晚接住的球的编号$i_e$为$int(s1-t_{max}*v)$。

这里的$i_b>i_e$所以答案应该是$i_b-i_e$

然后我们就有代码了
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double h,s1,v,l,k;
int main()
{
    cin>>h>>s1>>v>>l>>k>>n;
    double t_max=sqrt(h/5);
    double t_min=sqrt((h-k)/5);
    int i_b=int(s1-t_min*v+l),i_e=int(s1-t_max*v);
    cout<<i_b-i_e;
}
```

但是到这里就结束了吗？

我们可以发现这份代码连样例都过不了，因为存在一些特殊情况，如

$i_b>n$

或是

$i_e<0$

也就是我们把一些没有球的$x$轴也算成有球并被小车接住了。但这个问题其实很好解决，因为我们只要把极端的$i_b$和$i_e$处理到边界上就行了。因此，使

$i_b=min(i_b,n)$

$i_e=max(i_e,0)$

就行了。

然后就是真正的$AC$代码了
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double h,s1,v,l,k;
int main()
{
    cin>>h>>s1>>v>>l>>k>>n;
    double t_max=sqrt(h/5);
    double t_min=sqrt((h-k)/5);
    int i_b=int(s1-t_min*v+l),i_e=int(s1-t_max*v);
    i_b=min(i_b,n);i_e=max(i_e,0);
    cout<<i_b-i_e;
}
```

---

## 作者：ShineEternal (赞：35)

# 写在前面：如想获得更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/84725973),如有任何疑问，欢迎私信作者

# 题目链接：https://www.luogu.org/problemnew/show/P1033
呵呵，真的学好物理比较重要，前些年卡在这题上的我今天终于会做了，可恶的自由落体（~~也许是我太弱了吧~~ ）

# 分析：
这道题似乎并不用特意在乎精度，只是提醒大家一点：能全用double尽量都用，这样能避免中间转换是不必要的精度问题。
公式的推导相信大家都会吧，这里不再赘述，也会在代码中详细说明。

其实本人相当于用了贪心的思想，并没有整体循环，考虑到最早接的球和最晚的球中间一定都能接到，于是就是这样

下面见代码
# 代码：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
	double h,s1,v,l,k,n;
	scanf("%lf%lf%lf%lf%lf%lf",&h,&s1,&v,&l,&k,&n);
	double Maxtime=sqrt(h/5);//由题目给出的公式不难得出：球落地前的最大时间
	double Mintime=sqrt((h-k)/5);//因为小车的高度要考虑，所以还要算出最短的时间
	int s=int(s1-Mintime*v+l);//那么这就是最早的小球了
	int e=int(s1-Maxtime*v);//这个是最晚的？
	s=fmin(s,n);//这里需要考虑不要把x轴的算进来
	e=fmax(e,0);
	printf("%d",s-e);//最终的个数就是最早接球的编号-最晚的了
	return 0;
}
撒花~
```



---

## 作者：king_xbz (赞：15)

02年的老题目了基本上**高中生**都会做，代码也不长，我只用了**7行**就搞定了。

由于luogu有不少初中生还有小学生，所以在这里补充几个公式：

**位移（X）公式**：$X=V₀t+0.5at²$，其中V₀是初速度，t为时间，a为加速度。

而自由落体（就是小球下落）的**初速度为0**，加速度**等于重力加速度g**

由此得知，**自由落体运动位移（Y）公式**：$Y=0.5gt²$

基本的公式知道了我们就可以解决题目了了。

我们先读入**double型变量**H,S,V,L,K,n。

我们知道车高为k，故小球下落的**最短运动距离**为$sqrt((h-k)/5$,那么此时接住小球编号为$s-v*(sqrt((h-k)/5)+l)$；

**最长运动距离**为$sqrt(h/5)$,接住的小球编号为$s-v*sqrt(h/5)$。

由于接住的小球编号**不会超过**$n-1$也**不会小于**0（PS：编号是**0—n-1**！！！），所以最大的接住数量为$n-1-0+1$即n个.

得到精简的7行代码
```cpp
#include<bits/stdc++.h>
signed main(){
	double h,s,v,l,k,n;
	std::cin>>h>>s>>v>>l>>k>>n;
	double first=(s-v*sqrt((h-k)/5)+l),second=(s-v*sqrt(h/5));
	std::cout<<(first>n?n:first)-(second<1?0:second);
} 
```
那么这样交上去AC了吗？
答案是否定的，接下来便是这题的**一大坑点**：**精度**问题。

我们把第五行修改一下，先开精度，然后在强制转换为整型即可
```
int first=int(s-v*(double)(sqrt((h-k)/5))+l),second=int(s-v*(double)(sqrt(h/5)));
```
这样我们就把代码控制在7行便AC了这道题，应该是已有题解中最短的吧？！

最后祝大家AC愉快！

---

## 作者：EarthGiao (赞：14)

首先， 这是一道水题。

O(1)就解决了。

然后， 这是一道坑题。

小车初始在原点哪边不知道， 小车往哪边开不知道， 小车长什么样不知道。

...............                             ...............                                  ..........

...............                             ..........                                  ..........

普通小车                                机智小车                                    急刹小车

...

当然想清楚了就好做了。

分两个时间段， 小球与车顶等高t1， 小球落地t2。

t1时， 车顶可能与小球接触， 总数从车头p1算到车尾p2， 也就是floor(p2) - ceil(p1) + 1。

t1~t2， 车头可能碰到一系列小球， 同样的， floor(p2) - ceil(p1) + 1。

所以决定合并， 记录t1的p2和t2的p1， 一次得到答案。

但是精度很烦人， 所以将记录的p1、p2进行特判， 如果正好碰到球， 更新。

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#define ebs 1e-5

using namespace std;

double h, n, k, l, s1, v, p1, p2, t1, t2;
int ans;
int main()
{
    std :: ios :: sync_with_stdio(false);
    cin >> h >> s1 >> v >> l >> k >> n;
    p1 = s1, p2 = s1+l;
    t1 = sqrt(2*(h-k)/10);
    t2 = sqrt(2*h/10);
    if (t1 >= 0) p2 -= (v*t1); //h < k 时， 果断不改变p2
    p1 -= (v*t2);
    if (!(p2 < 0 && fabs(p2) > ebs) && !(p1 > n-1 && fabs(p1-n+1) > ebs)) //在有小球的范围内
    {
        if (p1-floor(p1) <= ebs) p1 = floor(p1);
        if (ceil(p2)-p2 <= ebs) p2 = ceil(p2);
        if (p1 < 0) p1 = 0;
        if (p2 > n-1) p2 = n-1;
        ans = floor(p2) - ceil(p1) + 1;
    }
    cout << ans;
    return 0;
}


```


---

## 作者：Temp113 (赞：4)

## Solution

由题可得：下落距离 $d = 0.5 \times g \times t^2 = 5 \times t^2$。

$d$ 的取值范围为 $H - K \sim H$，则 $t$ 的取值范围为 $\sqrt{\frac{H-K}{5}} \sim \sqrt{\frac{H}{5}}$。则小车以速度 $V$ 前进，小车接到小球的路程 $S$ 的取值范围为 $S_1 - V \times \sqrt{\frac{H}{5}} \sim S_1 - V \times \sqrt{\frac{H-K}{5}}+L$。最后判断上下边界 $0,n$ 即可。

推导：$5 \times t^2 = H-K$，$t^2 = \frac{H-K}{5}$，则 $t = \sqrt{\frac{H-K}{5}}$（$5 \times t^2 = H$ 同理）。小球的路程 $S'$ 的取值范围固定，小车接到小球的极值分别为头和尾，故可求出小车接到小球的路程 $S$ 的取值范围（如上）。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
double h, s1, v, l, k, t, tt;
int n, s, ss;
int main(){
	scanf("%lf %lf %lf %lf %lf %d", &h, &s1, &v, &l, &k, &n);
	t = sqrt((h - k) / 5.0);
	tt = sqrt(h / 5.0);
	s = (int)(s1 - v * t + l);
	ss = (int)(s1 - v * tt);
	s = min(s, n);
	ss = max(ss, 0);
	printf("%d", s - ss);
	return 0;
}
```

---

## 作者：andy1128 (赞：3)

## ~~其实我是看到FREEDOM DIVE↓进来的~~

普通的高中物理题，坑点不多数据也挺水

（怎么混到黄题的。。。）

### 思路：

所有小球一起出发，那么它们的高度应该是始终一样的

所以到达小车可以接到的时间也是一样的

到达小车可以接到的时间以后直到落地小车只要碰到都算接到（类似于吃豆人）

所以算出这个时间，再求出这段时间内小车覆盖的部分，

遍历一遍小球看哪个在范围内，在的话ANS++

### 公式：

因为h = 1/2 * g * t²

所以 t² = 2h/g

### 注意点：

1.小车坐标始终记录车头，否则容易会混乱

2.误差在一开始计算时间时就要加上，否则不好控制

2-1.由于加上了误差，所以H == K时需要特判否则根号内为负数

###  代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

double h,s,v,l,k;
int n;
int ans = 0;
double abletime_st,abletime_fi,carset_r,carset_l;

int main()
{
	cin>>h>>s>>v>>l>>k>>n;
	abletime_fi = sqrt(2*(h - 0.0001)/10);
	if(h == k)  abletime_st  = 0;
	else  abletime_st = sqrt(2*(h-k - 0.0001)/10);
	carset_r = s - (abletime_st * v) + l;
	carset_l = s - (abletime_fi * v);
	for(int i = 0;i<=n-1;i++)
	{
		if(carset_l - 0.0001<= i&& i <= carset_r + 0.0001)
		{
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

（题解里确实没有这样算的）

---

## 作者：GSQ0829 (赞：2)

### 思路：
物理题目，对于小学生还是有点不公平的。

我们可以先推出球落地前的最长时间和最短时间，那通过：
```cpp
x = int(s1 - minn * v + l)
```
就可以算出最早掉落的小球了。

```cpp
y = int(s1 - minn * v)
```
这个就是最晚掉落的小球了。

最后，还要加一个上下边界的判断就可以了。

---
### code:
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, x = 0, y = 0;
double h, s1, v, l, k, maxn = 0, minn = 0;

int main() {
	cin >> h >> s1 >> v >> l >> k >> n;
	maxn = sqrt(h / 5);
	minn = sqrt((h - k) / 5);
	x = int(s1 - minn * v + l);
	y = int(s1 - maxn * v);
	x = min(x, n);
	y = max(y, 0);
	cout << x - y << endl;
	return 0;
}
```

---

## 作者：InfiniteRobin (赞：1)

## 分析

来一个比较少人写的解法。

考虑一个个球判断是否能被接到。

首先，根据公式，我们可以算出每个球到达高度 $H-K$ 和 $0$ 的时间，分别记为 $t_1$ 和 $t_2$，具体计算不难。

对于 $t_1$ 和 $t_2$，我们也能分别算出小车最前端的距原点的距离，记为 $s_1$ 和 $s_2$。

注意：小球落地后就不能被接受。

对于小球 $i$，它被接到有两种情况：

- 在掉落到高度 $H-K$ 时被接到。
- 在高度 $H-K$ 和 $0$ 间被接到。

转换成具体条件，整理后就是：

$$\large{s_2 < i \le s_1+L}。$$

最后，题目中的 $0.0001$ 也很重要，记得加入判断中。

---

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;

const double eps=0.0001;
double H,S,V,L,K;
int n;

double get_time(double d){
	return sqrt(d/5);
}

bool check(int i){
	double time_top = get_time(H-K); //t1
	double time_bot = get_time(H);   //t2
	double dis_top  = S - time_top * V ; //s1
	double dis_bot  = S - time_bot * V ; //s2
	if( dis_bot < i+eps && i-eps <= dis_top + L ){
		return 1;
	}
	else return 0;
}

int main(){
	cin>>H>>S>>V>>L>>K>>n;
	
	int ans=0;
	for(int i=0;i<n;i++){
		if(check(i)) ans++;
	}
	
	cout<<ans;

	return 0;
} 
```

[**AC 记录**](https://www.luogu.com.cn/record/201838985)。

---

## 作者：陈嘉逸2012 (赞：1)

## 前言
科学题，太难了，$g$ 是重力加速度，但不影响做题。
![](https://cdn.luogu.com.cn/upload/image_hosting/1d177dhg.png)
## 思路
先来推式子：
$$
\begin{aligned}
d
&=0.5 \times g \times (t^2)\\
&=0.5 \times 10 \times (t^2)\\
&=5 \times (t^2)
\end{aligned}
$$
非常简单啊！

不难看出，$d=(H-K) \lor K$，则 $t=\sqrt{\frac{H-K}{5}} \lor \sqrt{\frac{H}{5}}$，小车行驶的路程 $S=\big(S_1-\sqrt{\frac{H-K}{5}} \times V+L\big) \lor \big(S_1-\sqrt{\frac{H}{5}} \times V\big)$，还要加一个上下边界的判断就完成了。

有任何问题请指出！
## Code
```cpp
#include<bits/stdc++.h>
#define db double
using namespace std;
db h,s1,v,l,k,mi,ma;
int n,L,R;
int main(){
	cin>>h>>s1>>v>>l>>k>>n;
	mi=sqrt((h-k)/5),ma=sqrt(h/5);
	L=min((int)(s1-mi*v+l),n),R=max((int)(s1-ma*v),0);
	cout<<L-R;
}
```

---

## 作者：ZZA000HAH (赞：1)

这道题的背景是高中物理，但只是用到了相关公式，题目要求与高中物理相差甚大（比如高中物理的小车是有车壁的），所以在做题时应按要求来，不能主观臆断。

这道题就是基础 C++ 的用法，比如运算符、开方函数等，还有是公式的推导变形、极值临界问题。

题中给出公式 $d=0.5\times g\times t^2$ 由此可以变形为 $t=\sqrt{\frac{2\times d}{g}}$ 由此便可以求得时间，我们要求的时间临界值有两个，一个是小球落到小车上表面时所用的时间，另一个是小球刚好落地时的时间，便是
```cpp
double tmin=sqrt((2*(h-k))/g),tmax=sqrt((2*h)/g);
```
然后再求小车能接到的最右边的球的位置，应是 $s-tmin\times v+l$，最左边的位置是 $s-tmin\times v$，但是还需要两者分别与 $n$ 和 $0$ 比较，便是（这里 $xmin$ 是和 $tmin$ 对应的，$xmax$ 同理）
```cpp
int xmin=min(int(s-v*tmin+l),n),xmax=max(int(s-v*tmax),0);
```
最后，便是完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int g=10;
int main()
{
	double h,s,v,l,k;
	int n;
	scanf("%lf%lf%lf%lf%lf%d",&h,&s,&v,&l,&k,&n);
	double tmin=sqrt((2*(h-k))/g),tmax=sqrt((2*h)/g);
	int xmin=min(int(s-v*tmin+l),n),xmax=max(int(s-v*tmax),0);
	printf("%d",xmin-xmax);
	return 0;
}
```
至此结束。

---

## 作者：fyn1234 (赞：0)

### 思路

纯纯物理题。

首先，由题可得小球下落距离计算公式为 $d = 0.5 \times g \times (t^2)$，且 $g = 10$，所以 $d = 5 \times t^2$。在进一步得到 $t = \sqrt[]{\dfrac{d}{5}}$。

计算出小车能接到球的两个边界（中间的肯定都能拿到），就可以得到小车能接受到多少个小球。

### solution

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    double h,s,v,l,k;
    int n;
	cin>>h>>s>>v>>l>>k>>n;
	double tmx=sqrt(h/5);  
	double tmn=sqrt((h-k)/5); 
	int xegin=s-tmn*v+l;      
	int xnd=s-tmx*v;          
	xegin=min(xegin,n);  
	xend=max(xnd,0);      
	cout<<xegin-xnd;
}
```

---

## 作者：cqbzhzf (赞：0)

### 思路
- 拿到题发现数学题，所以大概率为 $O(1)$ 的时间复杂度。于是先对**小球下落距离计算公式**进行推导，得（将 $g=10$ 代入）：$t=\sqrt{\frac{d}{5} }$。
- 于是我们可以通过得到的新公式计算出时间的边界，进一步算出第一次和最后一次接到球的位置，最终得出接到的球的数量。
- 注意边界问题即可。
### 代码
```cpp
#include<bits/stdc++.h>
#define db double
using namespace std;
db h,s1,v,l,k;
int n;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>h>>s1>>v>>l>>k>>n;
	db t1=sqrt((h-k)/5),t2=sqrt(h/5);//5=0.5*g,其中 g=10
	//t1 为小球落到车高度 k 的时间，t2 为小球落到地面的时间
	int L=s1-t1*v+l,R=s1-t2*v;
	//l 为接到的第一个球的位置，r 为接到最后一个球的位置
	L=min(L,n),R=max(R,0);
	//切忌超出边界
	cout<<L-R;
	return 0;
}
```

---

## 作者：cwxcplh (赞：0)

很简单的一道题，我就长话短说。

题目已经描述的很清楚了，我直接开始讲做法。

我们借用一下题目中的这个图片：

![](https://cdn.luogu.com.cn/upload/image_hosting/1d177dhg.png)

这道题首先要说一个地方，就是这个球事可以直接从车头穿进去从而被接到，这下后面就要好讲多了。

其实要算出答案很简单：我们只需要算出他最近离原点有多近，最远多远再相减就行，而这个距离中只有时间是可以改变的，所以我们要算时间的最长和最短。

题目中说了：$d=0.5\times g\times(t)^2$，我们要算时间，所以变化一下就可以得到：

$$t=\sqrt{\cfrac{d}{0.5\times g}}$$

题目中给了 $g=10$，带入公式就是：

$$t=\sqrt{\cfrac{d}{5}}$$

而因为球落地了就不能被接到，所以最长就是 $\sqrt{\cfrac{h}{5}}$，而刚接到就算是接到了，所以最短时间就是 $\sqrt{\cfrac{h-k}{5}}$。所以能走的最长距离就是 $\sqrt{\cfrac{h}{5}}\times v$，最短距离就是 $$\sqrt{\cfrac{h-k}{5}}\times v$$。

那么这辆车距离原点最近的距离就是头走了最长距离，也就是 $s1-\sqrt{\cfrac{h}{5}}\times v$，最远距离距离就是尾部走做短路的距离，即 $s1+l-\sqrt{\cfrac{h-k}{5}}\times v$。

最后还有一个注意事项：最远距离不能超过 $n$，最近不能超过 $0$。

[提交记录，完美 AC](https://www.luogu.com.cn/record/201675007)

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
double h,s1,v,l,k,tmx,tmn;
int lmx,lmn,n;
signed main()
{
	cin>>h>>s1>>v>>l>>k>>n;
	tmx=sqrt(h/5),tmn=sqrt((h-k)/5);
	lmx=s1-tmx*v,lmn=s1+l-tmn*v;
	lmn=min(lmn,n);
	lmx=max(lmx,0ll);
	cout<<lmn-lmx;
	return 0;
}
```

---

## 作者：xingsunderen (赞：0)

~~为什么 NOIP 提高组曾经这么爱出物理题？~~

这道题也算是一道水题，没有代码实现难度，思路想明白了其实不难。

## 思路
我们只需要计算出小车能接到球的边界位置，中间的位置肯定都能拿到。那么我们如何知道边界呢？

首先，题目告诉了我们小球下落公式为 $d=0.5\times g\times (t ^ {2}
 )$。

题目又说了 $g=10$，因此，我们可以将此带入至上述公式中，得到：$d=5\times t ^ {2}$。

继续，将 $t$ 单独放到等号左边，得 $t=\sqrt{\frac{d}{5}}$。

至此本题最重要的公式已经推出来了。接下来的任务就是把左右端点位置确定下来，详见代码，~~我自认为注释写的很简单易懂。~~
好好理解一下，~~不要上来就抄。~~

顺带一句，这道题使用 double 没有精度问题，可以放心使用。
```cpp
#include <bits/stdc++.h>
using namespace std;
double h,s1,v,l,k;
int n;
int main(){
	cin>>h>>s1>>v>>l>>k>>n;
	double tmax=sqrt(h/5);      //落到x轴上的时间 
	double tmin=sqrt((h-k)/5);  //落到小车上的时间 
	int xbegin=s1-tmin*v+l;     //最早可以被接到的位置 
	int xend=s1-tmax*v;         //最晚可以被接到的位置 
	xbegin=min(xbegin,n);       //舍掉超出n的部分 
	xend=max(xend,0);           //舍掉超出0的部分 
	cout<<xbegin-xend;
}
```

---

## 作者：RaymondOccam (赞：0)

### 思路

首先推式子：

$$
d=0.5\times g\times (t^2)
$$

把 $t$ 放在等号左边，其他的放在等号右边，可得：

$$
t^2=\frac{d}{0.5\times g}
$$

把平方消掉，可得：

$$
t=\sqrt{\frac{d}{0.5\times g}}
$$

其实引力常数 $g=9.8N/kg$，但这道题的 $g=10$，代入得：

$$
t=\sqrt{\frac{d}{5}}
$$

很明显，小球被车接受时的高度一定在 $0$ 和 $K$ 之间，推出 $d$ 的取值范围应该在 $H-K$ 和 $H$ 之间。

综上得 $t$ 取值范围在 $\sqrt{\frac{H-K}{2}}$ 和 $\sqrt{\frac{H}{2}}$ 之间。

求出球下落的最大时间 $\sqrt{\frac{H}{2}}$ 和最小时间 $\sqrt{\frac{H-K}{2}}$ 即可。

综上，最早被接受的小球位置 $G_1=S_1-t_{min}\times V+1$，最晚被接受的小球位置为 $G_2=S_1-t_{max}\times V$。

值得注意的是，需要在最后要让 $G_1=\min (G_1,n),G_2=\max(G_2,0)$，确保它们在一些极端情况下没有越界。

### 代码

```cpp
#include <iostream>
#include <cmath>
double h, s, l, v, k, tmax, tmin;
int g1, g2, n;
int main () {
  std::cin >> h >> s >> v >> l >> k >> n;
  tmax = std::sqrt (h / 5);
  tmin = std::sqrt ((h - k) / 5);
  g1 = int (s - tmin * v + l);
  g2 = int (s - tmax * v);
  g1 = std::min (g1, n);
  g2 = std::max (g2, 0);
  std::cout << g1 - g2;
  return 0;
}
```

---

## 作者：GoldenSTEVE7 (赞：0)

## 思路
看到这是一道有关自由落体的物理诶，哈皮！（~~刚刚学完~~

那我们直接上公式（毕竟题目已经给出了，我就不证明了）

$$
H=\frac{1}{2}gt^2
$$

其中 $H$ 是垂直方向上的唯一，即下落的高度，$g$ 为重力加速度，$t$ 为垂直方向上下落的距离。

依题意可知，$H$ 是一定且已知的，$g$ 也是给出的常数，那我们可以将 $H = h-k$ 这个公式推出来一个时间，即最早的下落时间。我们把这个时间再乘上 $v$，就可以得到小车水平位移，进而得出第一个小球的编号，即

$$
s-v\times\sqrt{\frac{(h-k)\times 2}{10}}+l
$$

看懂了这个后，我们再代入 $H = h$，同上我们就可以得到最后一个落下小球的编号。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    double h, s, v, l, k, n; cin >> h >> s >> v >> l >> k >> n;
    cout << min(int(s-v*sqrt((h-k)/5)+l),int(n)) - max(int(s-v*sqrt(h/5)),0);//注意精度
    return 0;
}
```

---

## 作者：GZXUEXUE (赞：0)

### 思路

题目要求计算「小车能接受到多少个小球」，我们可以把它转换为求「小车最晚能接受到的小球的编号减去小车最早能接受到的小球的编号」。接下来，我们分别计算两球的编号。

由于「小车最早能接受到的小球」下落距离为 $H - K$，所以，按照公式，「小车最早能接受到的小球」的下落时间为 $\sqrt{\dfrac{H - K}{0.5g}} = \sqrt{\dfrac{H - K}{5}}$，其编号为 $S_1 - \sqrt{\dfrac{H - K}{5}} \times V + L$。注意到小球编号不超过 $N - 1$，所以其编号应为 $\min(S_1 - \sqrt{\dfrac{H - K}{5}} \times V + L,N)$

同理，由于「小车最晚能接受到的小球」下落距离为 $H$，所以，按照公式，「小车最晚能接受到的小球」的下落时间为 $\sqrt{\dfrac{H}{0.5g}} = \sqrt{\dfrac{H}{5}}$，其编号为 $S_1 - \sqrt{\dfrac{H}{5}} \times V$。注意到小球编号不小于 $0$，所以其编号应为 $\max(S_1 - \sqrt{\dfrac{H}{5}} \times V,0)$

### 实现

```cpp
# include <iostream>
# include <cmath>
using namespace std;
int main(){
	double h,s,v,l,k; int n; cin >> h >> s >> v >> l >> k >> n;
	int head = max((int)(s - sqrt(h / 5) * v),0),tail = min((int)(s - sqrt((h - k) / 5) * v + l),n);
	cout << tail - head;
	return 0;
}
```

---

## 作者：ridewind2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1033#submit)

## 思路

一道物理题，~~太难了~~，我们可以计算出最早掉落的小球的编号和最晚掉落的小球的编号，再相减就可以了。

由于下落距离最小是 $h - k$，所以最早下落时间是 $\sqrt{(h - k) \div 5}$，速度是 $v$，那么最早掉落的小球编号就是 $s - \sqrt{(h - k) \div 5} \times v + l$。

同理，下落距离最大是 $h$，所以最早下落时间是 $\sqrt{h \div 5}$，那么最晚掉落的小球编号就是 $s  - \sqrt{h \div 5} \times v$。


一定要加上边界判断，要不然就 [WA](https://www.luogu.com.cn/record/200397565) 了。


## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    double h,s,v,l,k;
    int n;
    cin>>h>>s>>v>>l>>k>>n;//输入，没什么难度 
    int first=s-sqrt((h-k)/5)*v+l;//最早掉落的小球的编号
	int last=s-sqrt(h/5)*v;//最晚掉落的小球的编号 
	first=min(first,n),last=max(last,0);//判断边界 
    cout<<first-last;//输出答案 
    return 0;
}
```

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P1033)

# 思路

小球下落的时间公式为 $t=\sqrt{\frac{2\times h}{g}}$，其中 $g=10$ $m/s^2$。由于小车的高度为 $k$，因此小球下落的最短时间为 $t_{\min}=\sqrt{\frac{2\times \left ( h-k \right ) }{g}}$。

通过计算最早和最晚能够接到的小球的位置，直接得出能够接到的小球数量。最早能够接到的小球位置为 $s=\text{int}\left ( s_1-t_{\min}\times v+1 \right)$。最晚能够接到的小球位置为 $e=\text{int}\left ( s_1-t_{\max}\times v \right)$。

确保 $s$ 不超过 $n-1$，即 $s=\min\left ( s,n \right)$。确保 $e$ 不小于 $0$，即 $e=\max\left ( e,0 \right)$。

所以最终能够接到的小球数量为 $s-e$。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5;
double h,s1,v,l,k,n;
int main(){
    scanf("%lf%lf%lf%lf%lf%lf",&h,&s1,&v,&l,&k,&n);
    double maxTime=sqrt(h/5),minTime=sqrt((h-k)/5);
    int earliest=int(s1-minTime*v+l),latest=int(s1-maxTime*v);
    earliest=min(earliest,int(n));
    latest=max(latest,0);
    printf("%d\n",earliest-latest);
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/200525920)

---

## 作者：Co_Ce (赞：0)

# Solution

[link](https://www.luogu.com.cn/problem/P1033)  

**物理方法推导结论，直接 AC。**  

自由落体常用公式：  
![](https://i-blog.csdnimg.cn/blog_migrate/547997ddc029e6ffa64ce67c22272c4a.png)   
得到 $t^2=2 \times x \div g (g=10m/s^2)$。 

算上上下误差，可以接到的物体高度 $h_0$ 的范围：$h-k \leq h_0 \leq h$。  

所以，小车可以接到物体的时间 $t_0$ 的范围: $\sqrt{(h-k) \div 5} \leq t_0 \leq \sqrt{h\div5}$。 

![](https://i-blog.csdnimg.cn/blog_migrate/3488ced34afbbb7f2a70b5d267aef5cd.png)  

于是就有![](https://i-blog.csdnimg.cn/blog_migrate/06c962004aae2ec334dd65622218fac9.png)。 

所以答案就是 $i_b-i_e$。  

当 $i_b>n$，或者 $i_e<0$ 的时候，这里是没有球的。  
![](https://i-blog.csdnimg.cn/blog_migrate/d00dab980594db12d3c5e0dc9bd1d0c2.png)  

~~想明白就好办了。~~  

## std：
```cpp
#include <iostream>
#include <cmath>

// 定义极小数 eps 和重力加速度常量 g
const double eps = 1e-4;
const double g = 10;

// 判断能否接住小球的函数
bool check(double ceilH, double carS, double carV, double carL, double carH, double ballP) {
    // 根据公式计算接住小球允许的最小车速
    double minV = (carS - ballP - eps) * sqrt(g / 2 / ceilH);
    // 根据公式计算接住小球允许的最大车速
    double maxV = (carS + carL - ballP + eps) * sqrt(g / 2 / (ceilH - carH));
    // 判断实际车速是否在允许的车速范围内
    return minV <= carV && carV <= maxV;
}

int main() {
    double ceilH, carS, carV, carL, carH, numB;
    int count = 0;
    // 输入天花板高度、车距原点距离、车速、车长、车高、小球数量
    std::cin >> ceilH >> carS >> carV >> carL >> carH >> numB;
    for (double i = 0; i < numB && i <= carS; i++) {
        // 对每个小球判断是否能被接住
        count += check(ceilH, carS, carV, carL, carH, i)? 1 : 0;
    }
    // 输出能接住的小球个数
    std::cout << count << std::endl;
    return 0;
}
```

---


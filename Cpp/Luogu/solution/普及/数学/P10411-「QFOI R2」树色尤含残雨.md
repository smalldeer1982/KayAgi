# 「QFOI R2」树色尤含残雨

## 题目描述

小 R 是一个可爱的女孩子，她喜欢分解质因数。

她有一个正整数 $x$。每次操作可以选择 $p_1,\alpha_1,p_2,\alpha_2$ 满足 $p_1,p_2$ 为两不同质数且 $\alpha_1,\alpha_2$ 为正整数，若 $x$ 是 $p_1^{\alpha_1}p_2^{\alpha_2}$ 的整数倍，就将 $x$ 除以 $p_1^{\alpha_1}p_2^{\alpha_2}$，否则操作无效。

请你求出通过若干次操作可以得到的最小的 $x$。

## 说明/提示

**样例 $1$ 解释**

无法进行任何有效操作。

---

**样例 $2$ 解释**

可以进行以下两次操作：

- 令 $p_1=2,\alpha_1=1,p_2=3,\alpha_2=1$，将 $x$ 除以 $p_1^{\alpha_1}p_2^{\alpha_2}=2^13^1=6$，得到 $x=20$。
- 令 $p_1=2,\alpha_1=2,p_2=5,\alpha_2=1$，将 $x$ 除以 $p_1^{\alpha_1}p_2^{\alpha_2}=2^25^1=20$，得到 $x=1$。

---

**数据范围**

**本题采用捆绑测试。只有通过子任务中所有测试点以及所有依赖的子任务，才能获得相应的分数。**

对于全部数据：$2\le x\le 10^9$。

- 子任务一（$10$ 分）：$x\le 10$。
- 子任务二（$20$ 分）：$x$ 为“无平方因子数”$^\dagger$。
- 子任务三（$20$ 分）：$x$ 为一个质数的正整数次幂。
- 子任务四（$20$ 分）：$x\le 10^5$。依赖子任务一。
- 子任务五（$30$ 分）：无特殊限制。依赖子任务一、二、三、四。

$\dagger$ 称一个数 $x$ 为“无平方因子数”，当且仅当不存在大于一的整数 $k$，使得 $x$ 是 $k^2$ 的整数倍。

## 样例 #1

### 输入

```
9```

### 输出

```
9```

## 样例 #2

### 输入

```
120```

### 输出

```
1```

## 样例 #3

### 输入

```
2310```

### 输出

```
2```

# 题解

## 作者：rui_er (赞：16)

考查内容：

- 【3】整数唯一分解定理。
- 【3】贪心法。

设 $x$ 的唯一分解为 $\prod_{i=1}^mp_i^{\alpha_i}$，也就是说 $x$ 可以被划分为 $m$ 个质数的若干次幂的乘积。

当 $x$ 为一个质数的正整数次幂时，无法进行任何操作，因此答案为 $x$。

当 $x$ 为“无平方因子数”（Square-Free Number）时，一次操作只能消除掉 $x$ 的两个不同质因子。若 $2\mid m$，此时 $x$ 可以变成 $1$；若 $2\nmid m$，此时必定剩下一个质因数无法被消除，取最小的质因数即可。

否则，答案一定为 $1$。这是由于若 $2\mid m$，每次消除两个不同质因子即可；若 $2\nmid m$，可以将一个 $\alpha_i\ge 2$ 对应的 $p_i$ 拆分到两次操作中，转化为 $2\mid m$ 的情况。

```cpp
int x, y;
cin >> x; y = x;
vector<tuple<int, int>> div;
bool squarefree = true;
for(int i = 2; i * i <= x; ++i) {
    if(x % i == 0) {
        int cnt = 0;
        for(; x % i == 0; x /= i) ++cnt;
        div.emplace_back(i, cnt);
        if(cnt >= 2) squarefree = false;
    }
}
if(x > 1) div.emplace_back(x, 1);
if((int)div.size() == 1) cout << y << endl;
else if(squarefree) {
    if((int)div.size() & 1) cout << get<0>(div[0]) << endl;
    else cout << 1 << endl;
}
else cout << 1 << endl;
```

---

## 作者：Jadonyzx (赞：0)

**分解质因数**

```cpp
while(x>=i*i){
	if(x%i==0){
		cnt++;
		while(x%i==0)prime[cnt]++,x/=i;
		pr[cnt]=i;
	}
	i++;
}
if(x>1){
	pr[++cnt]=x;
	prime[cnt]++;
}
```

**求解**

情况 $1$：只有一种质因子，显然无法进行操作。

```cpp
if(cnt<2){
	write(xx);
	return 0;
}
```

情况 $2$：有多种质因子，但每种都只有一个，若共有偶数种质因子，则每次去掉两个，可以操作成 $1$，否则保留最小的质因子。

情况 $3$：有多种质因子，且存在同种多个质因子，则一定存在一种操作方法操作成 $1$。

```cpp
bool f=1;
for(int j=1;j<=cnt;++j){
	if(prime[j]>=2){
		f=0;break;
	}
}
if(f){//f表示是否有多个同种质因子
	if(cnt%2==1)write(pr[1]);
	else putchar('1');
	return 0;
}
else putchar('1');
```

完整 code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x>=10)write(x/10);
	putchar(x%10+'0');
	return;
}
int x,xx,ans,prime[100000010],cnt,pr[100000010];
signed main(){
	x=read();xx=x;
	int i=2;
	while(x>=i*i){
		if(x%i==0){
			cnt++;
			while(x%i==0)prime[cnt]++,x/=i;
			pr[cnt]=i;
		}
		i++;
	}
	if(x>1){
		pr[++cnt]=x;
		prime[cnt]++;
	}
	if(cnt<2){
		write(xx);
		return 0;
	}
	bool f=1;
	for(int j=1;j<=cnt;++j){
		if(prime[j]>=2){
			f=0;break;
		}
	}
	if(f){//f表示是否有多个同种质因子
		if(cnt%2==1)write(pr[1]);
		else putchar('1');
		return 0;
	}
	else putchar('1');
	return 0;
}
```

---


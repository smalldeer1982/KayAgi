# [NOIP 2003 普及组] 麦森数

## 题目描述

形如 $2^{P}-1$ 的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^{P}-1$ 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 $P=3021377$，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。

任务：输入 $P(1000<P<3100000)$，计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）


## 说明/提示

**【题目来源】**

NOIP 2003 普及组第四题

## 样例 #1

### 输入

```
1279
```

### 输出

```
386
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000104079321946643990819252403273640855
38615262247266704805319112350403608059673360298012
23944173232418484242161395428100779138356624832346
49081399066056773207629241295093892203457731833496
61583550472959420547689811211693677147548478866962
50138443826029173234888531116082853841658502825560
46662248318909188018470682222031405210266984354887
32958028878050869736186900714720710555703168729087
```

# 题解

## 作者：憧憬未来 (赞：533)

这道题可以分为两个模块，第一个模块为求的位数，第二个模块为求的后500位（不足补零）。我们主要来解决第一个模块：

一、求位数

首先我们知道 ![](https://cdn.luogu.com.cn/upload/pic/9649.png) 与 ![](https://cdn.luogu.com.cn/upload/pic/9650.png) 有着相同的位数，因为2的次方满足了最后一位不为零的要求，所以减一后位数并不会改变，那么我们可以直接求 ![](https://cdn.luogu.com.cn/upload/pic/9650.png) 的位数。那么怎么求位数呢？我们不妨设 ![](https://cdn.luogu.com.cn/upload/pic/9651.png) ，根据 ![](https://cdn.luogu.com.cn/upload/pic/9652.png) 的位数为 ![](https://cdn.luogu.com.cn/upload/pic/9653.png) ，我们只要想办法把 ![](https://cdn.luogu.com.cn/upload/pic/9651.png) 中的底数2改为10，指数加一就是位数了。由此想到用10的几次方来代替2，那么就不难想到 ![](https://cdn.luogu.com.cn/upload/pic/9654.png) ，这样便可以把 ![](https://cdn.luogu.com.cn/upload/pic/9651.png) 中的2代换掉，变为 ![](https://cdn.luogu.com.cn/upload/pic/9655.png) 。根据乘方的原理，将p乘进去，原式便可化为我们最终想要的形式 ![](https://cdn.luogu.com.cn/upload/pic/9656.png) 了，所以位数就是 ![](https://cdn.luogu.com.cn/upload/pic/9657.png) 。（提醒一下，C++中cmath库自带log10()函数...）

二、求最后500位数

这个绝对难不倒大家，裸的高精快速幂，经过NOIP2017初赛的RP++后，相信很多人都已经会了快速幂了，所以我在这里不再赘述，只是提供一种相对较为简便的高精乘法（见程序）

代码如下：

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int f[1001],p,res[1001],sav[1001];//乘法要开两倍长度
void result_1()
{
    memset(sav,0,sizeof(sav));
    for(register int i=1;i<=500;i+=1)
        for(register int j=1;j<=500;j+=1)
            sav[i+j-1]+=res[i]*f[j];//先计算每一位上的值（不进位）
    for(register int i=1;i<=500;i+=1)
    {
        sav[i+1]+=sav[i]/10;//单独处理进位问题，不容易出错
        sav[i]%=10;
    }
    memcpy(res,sav,sizeof(res));//cstring库里的赋值函数，把sav的值赋给res
}
void result_2()//只是在result_1的基础上进行了细微的修改
{
    memset(sav,0,sizeof(sav));
    for(register int i=1;i<=500;i+=1)
        for(register int j=1;j<=500;j+=1)
            sav[i+j-1]+=f[i]*f[j];
    for(register int i=1;i<=500;i+=1)
    {
        sav[i+1]+=sav[i]/10;
        sav[i]%=10;
    }
    memcpy(f,sav,sizeof(f));
}
int main()
{
    scanf("%d",&p);
    printf("%d\n",(int)(log10(2)*p+1));
    res[1]=1;
    f[1]=2;//高精度赋初值
    while(p!=0)//快速幂模板
    {
        if(p%2==1)result_1();
        p/=2;
        result_2();
    }
    res[1]-=1;
    for(register int i=500;i>=1;i-=1)//注意输出格式，50个换一行，第一个不用
        if(i!=500&&i%50==0)printf("\n%d",res[i]);
        else printf("%d",res[i]);
    return 0;
}
```

---

## 作者：ADivT (赞：335)

[点击此处进入我的博客阅读](https://www.luogu.org/blog/alvincwz/mai-sen-shuo-xie-ti-bao-gao)
# 麦森数题解
### Upd - 2020.10 
## 1、纯模拟
本题肯定要使用高精度算法，但是如果只是纯模拟的话肯定会超时，预计得分 $50pts$.
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1e6+10;

int a[N], P, l=1, x=0;

int main() {
//	freopen("mason.in","r",stdin);
//	freopen("mason.out","w",stdout);
    memset(a,0,sizeof(a));
    scanf("%d",&P);
    a[1] = 1;
    for (int i = 1; i <= P; ++i) {
        for (int j = 1; j <= l; ++j) {
            a[j] *= 2;
            a[j] += x;
            x = 0;
            if (a[j] >= 10 ) {
                x += a[j] / 10;
                a[j] %= 10;
            }
            if (x && j == l) ++l;
        }
    }
    printf("%d\n",l);
    --a[1];
    for (int i = 500; i >= 1; --i) {
        printf("%d",a[i]);
        if ( ! ( (i-1) % 50 ) ) printf("\n");
    }
    return 0;
}
```
### 1* 压位高精
既然单纯的高精不行，那如何优化呢？试试压位高精吧。期望得分$50pts+$,但可能是由于本人码力不足,仍然为$50pts$.
```cpp
#include<bits/stdc++.h>

const long long mod=10000000000;

using namespace std;

const int N=1e5+10;

int P, l=1, x=0, ex=0;

long long a[N]={};
long long check[11]= {0,1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000};

int main() {
//	freopen("mason.in","r",stdin);
//	freopen("mason.out","w",stdout);
    memset(a,0,sizeof(a));
    scanf("%d",&P);
    a[1] = 1;
    for (int i = 1; i <= P; ++i) {
        for (int j = 1; j <= l; ++j) {
            a[j] *= 2;
            a[j] += x;
            x = 0;
            if (a[j] >= mod ) {
                x ++;
                a[j] -= mod;
            }
            if (x && j == l) ++l;
        }
    }

    for (int i = 1; i <= 10; ++i) {
        if (a[l] >= check[i])ex = 10 - i;
    }
    printf("%d\n",l*10-ex);
    --a[1];
    for (int i = 50; i >= 1; --i) {
        printf("%010lld",a[i]);
        if ( ! ( (i-1) % 5 ) ) printf("\n");
    }
    return 0;
}
```

## 2、快速幂
既然朴素的算法很难得到满分，那我们就尝试快速幂.
快速幂这一算法在此不多赘述,如有疑惑请出门左转[P1226](https://www.luogu.com.cn/problem/P1226)。
```cpp
#include<bits/stdc++.h>

const long long mod=10000000000;

using namespace std;

const int N=1e5+10;

int P, l=1,lb=1;

int a[N]= {},b[N]= {},c[N]={};

int cheng1() {
    memset(c,0,sizeof(c));
    for (int i = 1; i <= l; ++i)   {
        for (int j = 1; j <= lb; ++j) {
            c[i+j-1] += a[i] * b[j];
            c[i+j] += ( c[i+j-1] ) / 10;
            c[i+j-1] %= 10;
        }
    }
    int lc = l + lb;
    while( c[lc] == 0 ) -- lc;
    for(int i = 1;i <= lc; ++i){
        a[i] = c[i];
    }
    return lc;
}
int cheng2() {
    memset(c,0,sizeof(c));
    for (int i = 1; i <= lb; ++i)   {
        for (int j = 1; j <= lb; ++j) {
            c[i+j-1] += b[i] * b[j];
            c[i+j] += ( c[i+j-1] ) / 10;
            c[i+j-1] %= 10;
        }
    }
    int lc = lb + lb;
    while( c[lc] == 0 ) -- lc;
    for(int i = 1;i <= lc; ++i){
        b[i] = c[i];
    }
    return lc;
}

void power() {
    while( P ) {
        if( P & 1 ) l = cheng1 ( );
        P >>= 1;
        lb = cheng2 ( );
    }
}

int main() {
//	freopen("mason.in","r",stdin);
//	freopen("mason.out","w",stdout);
    memset( a, 0, sizeof(a));
    memset( a, 0, sizeof(b));
    scanf("%d",&P);
    a[1] = 1;
    b[1] = 2;
    power();
    printf("%d\n",l); 
    -- a[1];
    for (int i = 500; i >= 1; --i) {
        printf("%d",a[i]);
        if ( ! ( (i-1) % 50 ) ) printf("\n");
    }
    return 0;
}
```
## 3、数学方法

上述代码仍不能通过此题.于是考虑对一个普通的高精乘，它的时间复杂度为O（$N^2$）,本题$P<=3100000$,所以不能去对整个数进行乘法运算.

又容易知道$2^P$-1与$2^P$的位数肯定相同
($2^P$没有5这个因数，尾数不为0）。

必有一个X使得$10^X$=$2^P$;又由$10^X$为X+1，所以$2^P$的位数=P*$log_{10}^2$+1;

于是我们可以直接对后五百位进行计算，并用压位高精和快速幂优化；

以下是AC代码。
```cpp
#include<bits/stdc++.h>

const long long mod=10000000000;

using namespace std;

const int N=2001;

int P, l=1,lb=1;

int a[N]= {},b[N]= {},c[N]={};

int cheng1() {
    memset(c,0,sizeof(c));
    for (int i = 1; i <= l; ++i)   {
        for (int j = 1; j <= lb; ++j) {
            c[i+j-1] += a[i] * b[j];
            c[i+j] += ( c[i+j-1] ) / 10;
            c[i+j-1] %= 10;
        }
    }
    int lc = l + lb;
    while( c[lc] == 0 ) -- lc;
    for(int i = 1;i <= lc; ++i){
        a[i] = c[i];
    }
    return lc>500?500:lc;
}
int cheng2() {
    memset(c,0,sizeof(c));
    for (int i = 1; i <= lb; ++i)   {
        for (int j = 1; j <= lb; ++j) {
            c[i+j-1] += b[i] * b[j];
            c[i+j] += ( c[i+j-1] ) / 10;
            c[i+j-1] %= 10;
        }
    }
    int lc = lb + lb;
    while( c[lc] == 0 ) -- lc;
    for(int i = 1;i <= lc; ++i){
        b[i] = c[i];
    }
    return lc>500?500:lc;
}

void power() {
    while( P ) {
        if( P & 1 ) l = cheng1 ( );
        P >>= 1;
        lb = cheng2 ( );
    }
}

int main() {
//	freopen("mason.in","r",stdin);
//	freopen("mason.out","w",stdout);
    memset( a, 0, sizeof(a));
    memset( a, 0, sizeof(b));
    scanf("%d",&P);
    printf("%d\n",int (P*log10(2.0)+1)); 
    a[1] = 1;
    b[1] = 2;
    power();
    -- a[1];
    for (int i = 500; i >= 1; --i) {
        printf("%d",a[i]);
        if ( ! ( (i-1) % 50 ) ) printf("\n");
    }
    return 0;
}
```
感谢阅读，如果觉得写得不错的话，不如点个赞再走吧。


---

## 作者：sqrt_7 (赞：315)

## 不用快速幂的短代码！！
    这题全是用快速幂的，其实可以不用，310万乘500等于15亿，常数好能过。题解里有一篇不用快速幂压位的解法，但是代码长得要死。所以，以下是30行以内的代码：（150ms以内）
    首先，我们要计算位数。我们知道10^k有k+1位，而k=lg(10^k)。所以2^p的位数是lg(2^p)+1=p*lg(2)。那么把p读进来之后直接cout出位数就行了。
    下面解决500位求值的问题：这里还是开一个a[501]的unsigned long long数组，记为ull，然后还是用每个元素表示1位数，没错，是1位数，这样时间够而且代码简单。每次乘一轮不要乘2，乘2^60（9乘以2的60次方刚好不会溢出），记得把p多减掉59就行了。然后你发现15亿除以60等于2500万，貌似可以...自己机器上只用了半秒。
    代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef unsigned long long ull;
ull a[501]={1};
int main()
{
	int p;
	cin>>p;
	cout<<(int)(p*log10(2))+1<<endl;//log10才是以十为底的对数
	for(;p>0;p-=60)//每次减掉60次幂
	{
		ull f=0;//进位
		for(int i=0;i<500;i++)
		{
			if(p>60)a[i]<<=60;
			else a[i]<<=p;//如果剩下的不够60了就不要乘60了，乘p
			a[i]+=f;
			f=a[i]/10;
			a[i]%=10;
		}
	}
	a[0]-=1;//千万不要忘记减1，否则你会和我第一次一样WA掉全部
	for(int i=499;i>=0;i--)
	{
		putchar(a[i]+'0');
		if(i%50==0)putchar('\n');
	}
	return 0;
}
```


---

## 作者：菰冭 (赞：80)

这么好的一个高精题为什么没人用python？

我来补一发2333

首先我们要知道python里的两个函数

```
pow(x,y[,z]) #幂函数，求x^y%zd的指  其中[]表示里面的参数可以有也可以没有
math.log10(x) #需要math库，表示log_10(x)的值，用来求位数

```

这样就可以做啦

剩下的注意事项写代码里面啦

```

import math#引入math库
a = int(input())   #以整数方式来读入
#lee=len(str(pow(2,a))) len()表示字符串长度，str()表示强制转换为字符串，这样求字符串长度会超时（70'）
lee = math.log10(2)*a+1   #求长度
b=pow(2,a,100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)   #1后面499个0，注意不要使用1e499，会RE
b = b-1   #对输出结果减1
c ='%0500d' %b   #格式化数字补0，转为字符串
a1=int(50)
a2 =int(10)
print(int(lee))
k =int(0)
for j in range(a2):

    for i in range(a1):
        print(c[k],end='')   #对字符串切片输出
        k=k+1
    print(" ")   #换行

```

``python大法好啊！``

---

## 作者：CHHC (赞：50)

### 首先第一问，输出${\mathsf{2^P}}$—${\mathsf{1}}$的位数

${\qquad}$ ${\mathsf{2^P}}$—${\mathsf{1}}$的位数也就是${\mathsf{\lceil P \times log_{10}2 \rceil}}$，直接输出即可。

${\qquad}$ **证明 :** ${\ }$设${\mathsf{2^P}}$的位数为${\mathsf{k}}$，则：

${\qquad}$ ${\ \ \ \ \ \ \ \ \ \ \mathsf{10^k>2^P>10^{k-1}}}$.

${\qquad}$ ${\ \ \ \ \ \ \ \ \ \ \mathsf{\therefore k>log_{10}(2^P)>k-1}}$.

${\qquad}$ ${\ \ \ \ \ \ \ \ \ \ \mathsf{\therefore k>P \times log_{10}2>k-1}}$.

${\qquad}$ ${\ \ \ \ \ \ \ \ \ \ }$即：${\mathsf{k=\lceil P \times log_{10}2 \rceil}}$.

${\qquad}$ ${\ \ \ \ \ \ \ \ \ \ }$由于${\mathsf{2^P}}$的末尾数字不可能为0，

${\qquad}$ ${\ \ \ \ \ \ \ \ \ \ }$所以${\mathsf{2^P}}$—${\mathsf{1}}$的位数同${\mathsf{2^P}}$的位数，为${\mathsf{k=\lceil P \times log_{10}2 \rceil}}$.

-----

### 第二问，求${\mathsf{2^P}}$的后${\mathsf{500}}$位

**朴素的算法：直接一次一次地乘 （60分）**

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[510];

int main()
{
    int P; cin>>P;
    
    cout<<ceil(P*log10(2))<<endl; // 第一问
    
    a[500]=1;
    for(int T=1;T<=P;T++)
    {
        for(int i=500;i>=1;i--)
        {
            a[i]*=2;              // 每一位都乘上2
        }
        for(int i=500;i>=1;i--)
        {
            a[i-1]+=a[i]/10;
            a[i]%=10;             // 处理进位
        }
    }
    a[500]--;
    
    for(int i=1;i<=500;i++)
    {
        cout<<a[i];
        if(i%50==0) cout<<endl;
    }
    
    return 0;
}
```

**小优化一下，每次乘上${\mathsf{2^{32}}}$（或之类的东西），就可以AC了。**

保险一点，开long long。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;

int P;
long long a[510];

long long POW2(int a)
{
    long long res=1;
    for(int i=1;i<=a;i++)
    {
        res*=2;
    }
    return res;
}

int main()
{
    cin>>P;
    
    cout<<ceil(P*log10(2))<<endl; // 第一问 
    
    long long tmp=POW2(32);       // tmp=2^32
    
    a[500]=1;
    int t32=P/32;                 // t32：能乘以2^32的次数 
	int t1=P-t32*32;              // t1： 剩下的，一个一个乘上去 
    for(int T=1;T<=t32;T++)
    {
        for(int i=500;i>=1;i--)
        {
            a[i]*=tmp;            // 每一位都乘上2^32
        }
        for(int i=500;i>=1;i--)
        {
            a[i-1]+=a[i]/10;
            a[i]%=10;             // 处理进位
        }
    }
    for(int T=1;T<=t1;T++)
    {
        for(int i=500;i>=1;i--)
        {
            a[i]*=2;              // 每一位都乘上2
        }
        for(int i=500;i>=1;i--)
        {
            a[i-1]+=a[i]/10;
            a[i]%=10;             // 处理进位
        }
    }
    a[500]--;
    
    for(int i=1;i<=500;i++)
    {
        cout<<a[i];
        if(i%50==0) cout<<endl;
    }
    
    return 0;
}
```

END.
$$$$
$$$$

管理大大求过……QWQ……

---

## 作者：mohei0 (赞：46)

这里是麦森数快速幂解法……

第一次做快速幂……

有点不够精简……

但不要介意……

绝对不会超时的，long long改成int也可以用。

1亿也可以秒出。

思路：快速幂不用说了，2的幂存到500位就好了，500位以上不用存。

结果也只存500位，输出简单，我是一个一个输出的，优化的这里不说，自己找dalao。（其实我也不会优化……）

代码奉上，勿抄！！！


```cpp
#include<iostream>
#include<string>
#include<cstring>
#include<cstdio>
#include<cstdlib>//头文件不用说了，虽然还有一些没有用到，但是懒得删
using namespace std;
void cheng(long long a[],long long b[])//算高精度两数相乘，结果只留500位
{
    int c[100000]={0};
    c[0]=a[0]+b[0];
    if(c[0]>500) c[0]=500;
    for(int i=0;i<b[0];i++)
    {
        for(int q=0;q<a[0];q++)
        {
            c[i+q+1]=a[q+1]*b[i+1]+c[i+q+1];
            if(c[i+q+1]>=10)
            {
                c[i+q+2]=c[i+q+2]+c[i+q+1]/10;
                c[i+q+1]=c[i+q+1]%10;
            }
        }
    }
    for(int i=0;i<=c[0];i++) a[i]=c[i];
}
void sc(long long a[])//输出……拼音大法好啊……
{
    int q=500;
    for(int i=0;i<10;i++)
    {
        for(int j=0;j<50;j++)
        {
            cout<<a[q];
            q--;
        }
        cout<<endl;
    }
}
int main()
{
    long long a[5000]={0},b,c[50000]={0};//这里c是2的幂，a是结果，b输入的参数。
    a[0]=a[1]=c[0]=1;c[1]=2;//这里把2的幂先设成2，不然平方的时候永远是1……
    cin>>b;
    int k=0.30103*b+1;//算位数，不要问我为什么这样算，上网搜去……
    cout<<k<<endl;
    if(b&1!=0) cheng(a,c);
    b=b>>1;
    while(b!=0)
    {
        cheng(c,c);
        if(b&1!=0) cheng(a,c);
        b=b>>1;
```
}//快速幂不说
```cpp
    a[1]--;
    sc(a);
    cout<<endl;
    return 0;
}
```

---

## 作者：pikabi (赞：40)


**不会快速幂的我只能疯狂压位（dalao们请无视）**

这是本蒟蒻滴第一篇洛谷题解还请多多包涵鸭！！

好吧先看看我的辛路历程——![](https://img-blog.csdnimg.cn/20190810153723500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bpa2FiaQ==,size_16,color_FFFFFF,t_70)

刚看到这题的时候，我第一反应是压位，于是我从未压位到——>**5**压到——>**10**，吸氧后发现后两者都是60分（o(╥﹏╥)o）

于是乎我将**2^p**次方转化为**1024^n+m**，以及**2^20^n+m**来运算，结果只有70分[○･｀Д´･ ○]

最后我才发现意识到我把500位外的数字都计算了，所以一直T（内心崩溃）

行呗，上代码————>>————>>
```cpp
#include <cstdio>
#include <cmath> 

using namespace std;

const long long maxn = 1e+10;
long long a[500000], lena, n;

int main(){
	scanf("%lld",&n);
	int t = n % 29, tt = n / 29;//2的29次方刚好卡在9位数
	a[1] = 1;
	for(int i = 1; i <= t; i++)
	a[1] *= 2;
	lena = 1;
	for(int i = 1; i <= tt ; i++){
		long long x = 0;
		for(int j = 1; j <= lena && j <= 50; j++){
		a[j] = a[j] * 536870912 + x;//536870912是2的29次方
		x = a[j] / maxn;
		a[j] %= maxn;
		}
		if(x > 0) {
			lena++;
			a[lena] = x;
		}
	}
	printf("%lld\n",int(log10(2)*n + 1));
	for(int i = 50; i >= 2; i--){//不累（微笑(*￣︶￣)）
	if(i == 5||i == 10||i == 15 || i == 20 || i == 25 || i == 30|| i == 35 || i == 40 || i == 45) printf("\n");
	if(a[i] >= maxn/10)
	printf("%lld",a[i]);
	else {//复制粘贴一下搞定哦
		if(a[i]<1000000000 &&a[i] >= 100000000) printf("0");
		else if(a[i] >= 10000000) printf("00");//要讲究美观
		else if(a[i] >= 1000000) printf("000");
		else if(a[i] >= 100000) printf("0000");
		else if(a[i] >= 10000) printf("00000");
		else if(a[i] >= 1000) printf("000000");
		else if(a[i] >= 100) printf("0000000");
		else if(a[i] >= 10) printf("00000000");
		else if(a[i] >= 1) printf("000000000");
		if(a[i] == 0) printf("0000000000");
		else printf("%lld",a[i]);
	}
	}
	printf("%lld",a[1] - 1);//减一不能忘
	return 0;
}
```
吸氧后65ms海星(*￣︶￣)

溜了溜了还有一大堆暑假作业等着我捏     ٩꒰▽ ꒱۶⁼³₌₃ 学习去咯

╮(╯﹏╰）╭


---

## 作者：凌空の猫 (赞：37)

有时候，Python出奇迹
```python
j=0
for i in str((2**(int)input-1)%1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)):
	print(i)
    j=j+1
    if j%10==0:
    	printf("\n")

```
甭数了，499个零没错了。

---

## 作者：hilsinleri (赞：21)

这道题纯粹是考数学。编程复杂度不大（别看我写了一百多行其实有些是可以不必写的）。

计算位数不必用高精时刻存，不然可想而知时间复杂度之大。首先大家要知道一个数学公式 logn(a\*b)=logn(a)+logn(b)至于证明翻数学书吧。而且，用log10(n)+1即可求出n的位数。则2^p的位数=log10(2^p)+1=p\*log10(2)+1。这样，我们算的时候就不必随时存着位数了。

但是，如果直接写高精和n次循环，时间复杂度依旧很高。所以我们就要用快速幂。幂的运算是初中内容，几个公式如下:n^a\*n^b=n^(a+b)，(n^a)^b=n^(a\*b)。

所以，我们就可以将乘方的复杂度优化成O(logn)了。


```cpp
             1(n==0),
             m(n==1),
f(m,n)=  f(m,n/2)^2(n%2==0),
             f(m,n/2)^2*m(n%2==1).
```
于是，时间复杂度就优化了不少。

```cpp
#include<bits/stdc++.h>
using namespace std;

struct Hint {
    static const int MAX=4000;
    short a[MAX+1];
    int Len;
    Hint() {
        memset(a,0,sizeof(a));
        Len=1;
    }

    Hint operator=(std::string N) {
        memset(a,0,sizeof(a));
        if(N[0]=='-') {
            Len=N.size()-1;
            a[0]=1;
            for(int i=1; i<=Len; ++i)
                a[i]=N[Len-i+1]-'0';
            return *this;
        }
        if(N[0]=='+') {
            Len=N.size()-1;
            a[0]=0;
            for(int i=1; i<=Len; ++i)
                a[i]=N[Len-i+1]-'0';
            return *this;
        }
        Len=N.size();
        for(int i=1; i<=Len; ++i)
            a[i]=N[Len-i]-'0';
        return *this;
    }

    Hint operator=(const int & b) {
        char s[MAX+1];
        sprintf(s,"%d",b);
        *this=s;
        return *this;
    }

    Hint(std::string N) {
        *this=N;
    }
    Hint(const int &b) {
        *this=b;
    }

    int read() {
        char s[MAX+1];
        int t=scanf("%s",s);
        *this=s;
        return t;
    }

    void write() {
        int r,re=1,now=0;
        for(int i=Len; i>=1; --i) {
            cout<<a[i];
            ++now;
            if(now%50==0)cout<<endl;
        }    
    }
    Hint operator*(Hint x) {
        Hint c;
        c.Len=Len+x.Len;
        for(int i=1; i<=Len; ++i) {
            for(int j=1; j<=x.Len; ++j) {
                c.a[i+j-1]+=a[i]*x.a[j];
                if(c.a[i+j-1]>=10) {
                    c.a[i+j]+=c.a[i+j-1]/10;
                    c.a[i+j-1]%=10;
                }
            }
        }
        c.Len=500;
        return c;
    }

}two,ans;

int p;

Hint quick_power(int y)
{
    if(y==1)return two;
    if(y==0)return 1;
    Hint re;
    if(y%2==0)
    {
        re=quick_power(y/2);
        re=re*re;
    }
    else
    {
        re=quick_power(y/2);
        re=re*re*two;
    }
    return re;
}

int main()
{
    two=2;
    cin>>p;
    cout<<(long long)(log10(2)*p+1)<<endl;
    ans=quick_power(p);
    ans.a[1]-=1;
    ans.write();
    return 0;
}
```cpp

---

## 作者：bad_404 (赞：19)

题目可以分为两部分来做：求位数与输出倒数500位。
```cpp
1. 首先是位数，用数学方法：
对于2^p，可以写成10^q的形式。
即为：2^p=10^q，所以q=log10(2^p)=p*log10(2)，然而对于10^n，其位数则为
n+1位，故2^p的位数为p*log10(2)+1，直接输出就行了。
2. 第二是倒数500位，用高精度乘法来算，需要压位运算，数组开100，压5位刚好。
直接上代码。

#include<iostream>
#include<stdio.h>
#include<cmath>
#define maxn 100000
using namespace std;

int main()
{
	int i,j,a[102]={0};
	int p;
	scanf("%d",&p);
	printf("%d\n",(int)(p*log10(2.0)+1));//直接输出位数
	int left=p%10;
	p=p/10;
	a[0]=1;
	for(i=1;i<=p;i++)
	{
		for(j=0;j<=100;j++)//注意只能先乘移位，不能同时进行，下面一样
		    a[j]<<=10;
		for(j=0;j<=100;j++)
		{
			if(a[j]>=maxn)
			{
				a[j+1]+=a[j]/maxn;
				a[j]%=maxn;
			}
		}
	}
	for(i=1;i<=left;i++)
	{
		for(j=0;j<=100;j++)//同上
		    a[j]<<=1;
		for(j=0;j<=100;j++)
		{
			if(a[j]>=maxn)
			{
				a[j+1]+=a[j]/maxn;
				a[j]%=maxn;
			}
		}
	}
	a[0]--;//记得最后一位要减一，这里有人会想万一a[0]=0怎么办？自己想。
	for(i=99;i>=0;i--)//倒叙输出
	{
		printf("%05d",a[i]);
		if(i%10==0)
	        printf("\n");
	}
	return 0;
}
```

---

## 作者：阳光逸骏 (赞：9)

看大家都是打C++，我就来发一个Pascal的。

这一道题既考了你高精快速幂，也需要一定的数论知识才能做出来。


## 用log位数文中加粗了的部分是重点：用log位数


log a(b)的结果k表示a的k次方等于b

换底公式：log a(c)/log b(c)=log b(c)

log 10（k）向上取整表示k的位数

log 的运算满足规律log a（b\*c）=log a（b）+log a（c）

所以，log a（b^c）=log a（b）\*c

所以，log 10（2）\*n可以表示2^n的位数



```cpp
        var p,i:longint;
            a:array[0..10000002]of longint;
            b:array[0..521]of longint;
        //高精快速幂不解释
        procedure fz(n:longint);
        var i,j:longint;
        begin
          if n=0 then exit;
          fz(n div 2);
          for i:=1 to 500 do
            for j:=1 to 500 do
              if n mod 2=0 then a[i+j-1]:=a[i+j-1]+b[i]*b[j]
                           else a[i+j-1]:=a[i+j-1]+b[i]*b[j]*2;
          for i:=1 to 500 do
            begin
              b[i]:=a[i]mod 10;
              a[i+1]:=a[i+1]+a[i]div 10;
            end;
          fillchar(a,sizeof(a),0);
        end;
        begin
          readln(p);
          b[1]:=1;
          fz(p);
###### writeln(trunc((ln(2)/ln(10))*p+1));
          for i:=500 downto 2 do
            begin
              write(b[i]);
              if i mod 50=1 then writeln;
            end;
          writeln(b[1]-1);  //我们观察2的幂次方，都分别以2,4,8,6结尾，-1不退位
end.
```

---

## 作者：Retired_OIer (赞：5)

#### 像我这种rubbish不会快速幂，但我不会屈服,这种题目穷举一定是不行了，O（500n）算法一定TLE。于是我就想到了一种作弊的方法——把一个数组的每个变量存五位数，乘的时候不乘2，而是一次成2^30!,这样我的时间复杂度就降到了O(10/3*n),就可以过了，正应了那句话：
**骗分过样例，暴力出奇迹**
##### 求位数用对数函数log10（）就可以了
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long ans[105]= {0,1},p,ds,jw;//要开long long 
int main() {
	ios::sync_with_stdio(false);//把所有cin cout全变成快读快写
	cin >> p;
	for(int i = 1; i <= p / 30; i++) {
		for(int j = 1; j <= 100; j++) {
			ds = (ans[j] << 30) + jw;//用位运算更快哦
			jw = ds / 100000;
			ans[j] = ds % 100000;//存五位数
		}
		jw = 0;
	}
	for(int i = 1; i <= p % 30; i++) {//别忘了一次乘2^30会有余数，要单独乘
		for(int j = 1; j <= 100; j++) {
			ds = (ans[j] << 1) + jw;
			jw = ds / 100000;
			ans[j] = ds % 100000;
		}
		jw = 0;
	}
	cout << ceil(p * log10(2));//根据对数公式logc(a^n)=n*logc(a)可得log10(2^p)=p*log10(2),将其向上取整即可
	ans[1]--;
	for(int i = 100; i > 0; i--) {
		if(!(i % 10))//输出换行
			cout << endl;
		if(ans[i] < 10000)//因为每一位存五个数，所以要输出其前导0
			cout << 0;
		if(ans[i] < 1000)
			cout << 0;
		if(ans[i] < 100)
			cout << 0;
		if(ans[i] < 10)
			cout << 0;
		cout << ans[i];
	}
	return 0;
}
```


---

## 作者：SuuTTT (赞：4)

高精度用java才是正解(爽)吧。

附java快速幂模板

顺便贴一下楼上的python3 (函数库自带快速幂，2019的JP-ICPC邀请赛已经可以用python了，亲测)
```java
package acmca;


import java.util.Scanner;
import java.util.StringTokenizer;
import java.*;
import java.math.*;




public class Main {
	public static BigInteger base=BigInteger.TEN.pow(500);
	public static BigInteger kpow(BigInteger x,int n) {
		BigInteger ret=BigInteger.ONE;
		while(n>0) {
			if((n&1)==1) {
				ret=ret.multiply(x);
				ret=ret.mod(base);
				
			}
			x=x.multiply(x);
			x=x.mod(base);
			n=n>>1;
		}
		
		return ret;
		
	}
    public static void main(String args[]) {
        Scanner cin = new Scanner(System.in);
        int n=cin.nextInt();
        BigInteger nn=kpow(BigInteger.valueOf(2),n);

        nn=nn.subtract(BigInteger.ONE);
        System.out.println((int)(n*Math.log10(2.0))+1);
        

        String s=nn.toString();
        
        if(s.length()<500) {
        	int len=500-s.length();String ss="";
        	while(len>0) {
        		len--;
        		ss=ss+"0";
        	}
        	s=ss+s;
        }
        
        for(int i=0;i<500;i++) {
        	System.out.print(s.charAt(i));
        	if((i+1)%50==0)System.out.println();
        	
        }
       
    }
}

```



```python

import math
a = int(input())  

bi = math.log10(2)*a+1  
b=pow(2,a,100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000) 
b = b-1  
c ='%0500d' %b  
a1=int(50)
a2 =int(10)
print(int(bi))
k =int(0)
for j in range(a2):

    for i in range(a1):
        print(c[k],end='')  
        k=k+1
    print(" ")  
```


---

## 作者：吴国铨 (赞：4)

首先可以想见，就算快速幂+压位，对于3100000这个数来说，完全算出准确值是很不靠谱的事情（空间允许，时间不允许）


所以，算位数是一个纯粹数学问题。


算位数么，肯定能想到的是log(10,2^n)


2^n很大，那就变形处理，变成n\*log(10,2)


log(10,2)是一个常数，你可以找电脑里的计算器算，多保留几位小数放进去，也可以这样：




uses math;//math库里有算log的函数

log10(2);或者logn(10,2);

——看哪个还敢说pascal里没算log的函数，自己不去好好学习RTL。


最后要输出的是writeln(trunc(n\*log10(2))+1);


用trunc直接截去尾部，不要小数，然后加一个1补偿一下，用round()会导致一些不好调整的混乱。


 

然后我们开始算吧。


首先是知道什么叫快速幂。


所谓快速幂，写成一个式子就很直观了——




(63)10=(111111)2

2^63 = 2^32 \* 2^16 \* 2^8 \* 2^4 \* 2^2 \* 2^1

而2^32=(2^16)^2，不需要连乘32个2，只要使用前面的结果就行。


用快速幂，这个例子上只需10次乘法，用暴力方法，你需要做63次，当数更大的时候，效率优势是更加明显的




(48)10=(110000)2

2^48 = 2^32 \* 2^16

（这其实是一种分治法思想）


 

接下来的问题变成了，我如何知道那些二进制位上是1.


选择很多，你可以从数据可能的最高位开始往下减，记录一下那些对应的二进制位


当然也可以从最低位开始看。


要说从最低位开始看，强烈建议一下树状数组中用的一个位运算方法——lowbit。


Lowbit的作用是返回2^（二进制表示的i的末尾0的个数）


典型方法是不断mod 2^i，直到有余数为止。一种巧妙的运算方法是 i and (-i)。


因为正二进制数取反以后再加一，就得到了负的此数，而末尾0的个数一样，所以只需要and运算就可以取到最后所有的0和第一个1。


以下以48为例。


48    00110000





```cpp
-48    11010000(11001111+1)
48 and (-48)    00010000
lowbit(48)=16
48-lowbit(48)=32
lowbit(32)=32
32-lowbit(32)=0
```
好了，到此为止我们知道了，48这个数在表示2^4和2^5的二进制位上是1.那2^48只需2^(2^4) \* 2^(2^5)就行

63等其他数同理，大家可以自己推推看。


 

之所以要详细说从低位往高位看，是因为——


算2^32前要算2^16,算2^16前算2^8,.....最后要先知道2^1,然后才能一个个往上推。


那这样，一路往上推2^(2^i)的过程中，等到算出我们需要的2^(2^i)的值的时候可以直接乘到结果里去了。


 

一开始我们考量过，1s算出每个准确数字并不靠谱，题目只是要求输出最后的500位，那我在计算的时候只需要保留最后的500位，更高位的计算我可以选择根本就不做。


这样的话，我需要3个高精度数组（压不压位随你便，影响并不大，最多就是内存开的再小一点，复制数组的时间代价更小）


第一个存2^(2^times),第二个存最后输出的结果，第三个作为计算过程中临时存放结果的数组（两数组相乘，在算完前结果覆盖回任何一个乘数数组都会出事的）。






```cpp
while (n>0)
{
    while (times<lowbit(n))
   {
```
对第一个数组平方，同时更新一下times标记（times\*2，表示平方了一下）


   }
把第一个数组（2^(2^times)）乘第二个数组（结果），存回第二个数组（结果）


dec(n,lowbit(n));//自己看看二进制表示，想想为什么，这个比较直观的



}
最后别忘了减一、退位处理（其实想想就知道，不可能退位，怕出事情，退位写那里也没事）和按要求输出结果。


具体的高精度乘法、减法的实现这里不做讲解，这是一个基本能力问题。


 

还有一点，能递推的最好不要写递归了，这个题目上写递归，协调起来真的灾难的很。


---

## 作者：exi3t (赞：4)

没有定义类，没有重载运算符，将高精度与快速幂结合在一起。

           
        




   
         
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int  ans[5001],base[5001],a[5001],b[5001];//base必须数组长度必须非常大, 
void ksm(int);                            //因为2的n次幂爆炸式增长. 
void chengfa(int a1[],int b1[],int c[])
{   
for(int i=1;i<=5001;i++) {a[i]=a1[i];b[i]=b1[i];}
for(int i=1;i<=5001;i++) c[i]=0;
for(int i=1;i<=5001;i++)
       for(int j=1;j<=500;j++){
       c[i+j-1]+=a[i]*b[j]; 
       if(c[i+j-1]>9){
        c[i+j]+=c[i+j-1]/10;
        c[i+j-1]%=10;
 }
}
}
int main()
{
int p;cin>>p;
double result=p*log10(2)+1;
cout<<(int)(result)<<endl;
ksm(p);
ans[1]--;
for(int i=500;i>=1;i--){
    if(i%50==0 and i!=500) cout<<endl;
    cout<<ans[i];
    }
}
void ksm(int p)
{ ans[1]=1,base[1]=2;  
while(p!=0){
    if(p&1!=0) chengfa(ans,base,ans);
    chengfa(base,base,base);
    p>>=1;
         }
}

```

---

## 作者：pomelo_nene (赞：3)

注意：下列代码因为作者脸黑常数大，所以不一定能够在不吸氧/改用scanf和printf的情况下AC，见谅

---

首先看数据范围:$1000<P<3100000$，求$2^P-1$的位数及后500位。很明显这是一道高精题目，所以先把vector重载高精度模板搬来。看着模板高兴的交了上去，只有0分。所以我们要考虑优化了。

---

问题拆分成两半，第一问求位数，$2^P(P>1000)$的末尾为$2,4,6,8$，所以绝不会有退位的风险，所以可以直接套用公式得到位数为$log_{10}2*P+1$，转化成int后即可输出（当然打表也可以，但是考场上挂着跑半天不好吧...）

第二问求$2^P-1$的后500位。我们已经求出位数，如果位数小于500，输出500-位数个0，然后直接...?

我们发现我们的高精模板只能整个输出？因为这个是vector，所以还是滋磁vector基本的操作。用迭代器！但是请注意用反向迭代器，因为我们储存数字时是倒序存储的。

暴力连乘$P$次，交上去竟然全部超时！

我们该怎么办呢？

~~我会FFT！我会压位高精！~~

我会快速幂！

这时候我们就可以用高精快速幂来求$2^P$，让我们原来的$\Theta (P)$变成更高效的$\Theta log_2(P)$，__最后取个模就OK啦！__

Tip:如果还不会快速幂的请往[这边](https://www.luogu.org/problemnew/show/P1226)

仍然超时，只有40

~~果然脸黑~~

---

我们发现时间主要出在乘这个部分上，位数都可以乘到几十万，当然常数很大。所以我们要介绍一个性质

$$(a \times b)\text{ }mod\text{ }p=((a\text{ }mod\text{ }p) \text{ }\times \text{ }(b\text{ }mod\text{ }p))\text{ }mod \text{ }p$$

有了这个性质，我们发现我们可以在进行快速幂的同时进行取余运算，位数最大500位，让速度快了许多

注：该代码为C++11标准，不保证不吸氧过的了

```cpp
#include<algorithm>
#include<cstring>
#include<random>
#include<iostream>
#include<vector>
#include<string>
#include<cmath>
using namespace std;
struct Wint:vector<int>
{
    Wint(int n=0)
    {
        push_back(n);
        check();
    }
    Wint& check()
    {
        while(!empty()&&!back())pop_back();
        if(empty())return *this;
        for(int i=1; i<size(); ++i)
        {
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10)
        {
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;
    }
};
istream& operator>>(istream &is,Wint &n)
{
    string s;
    is>>s;
    n.clear();
    for(int i=s.size()-1; i>=0; --i)n.push_back(s[i]-'0');
    return is;
}
ostream& operator<<(ostream &os,const Wint &n)
{
    if(n.empty())os<<0;
    else	for(int i=n.size()-1; i>=0; --i)os<<n[i];
    return os;
}
bool operator!=(const Wint &a,const Wint &b)
{
    if(a.size()!=b.size())return 1;
    for(int i=a.size()-1; i>=0; --i)
        if(a[i]!=b[i])return 1;
    return 0;
}
bool operator==(const Wint &a,const Wint &b)
{
    return !(a!=b);
}
bool operator<(const Wint &a,const Wint &b)
{
    if(a.size()!=b.size())return a.size()<b.size();
    for(int i=a.size()-1; i>=0; --i)
        if(a[i]!=b[i])return a[i]<b[i];
    return 0;
}
bool operator>(const Wint &a,const Wint &b)
{
    return b<a;
}
bool operator<=(const Wint &a,const Wint &b)
{
    return !(a>b);
}
bool operator>=(const Wint &a,const Wint &b)
{
    return !(a<b);
}
Wint& operator+=(Wint &a,const Wint &b)
{
    if(a.size()<b.size())a.resize(b.size());
    for(int i=0; i!=b.size(); ++i)a[i]+=b[i];
    return a.check();
}
Wint operator+(Wint a,const Wint &b)
{
    return a+=b;
}
Wint& operator-=(Wint &a,Wint b)
{
    for(int i=0; i!=b.size(); a[i]-=b[i],++i)
        if(a[i]<b[i])
        {
            int j=i+1;
            while(!a[j])++j;
            while(j>i)
            {
                --a[j];
                a[--j]+=10;
            }
        }
    return a.check();
}
Wint operator-(Wint a,const Wint &b)
{
    return a-=b;
}
Wint operator*(const Wint &a,const Wint &b)
{
    Wint n;
    n.assign(a.size()+b.size()-1,0);
    for(int i=0; i!=a.size(); ++i)
        for(int j=0; j!=b.size(); ++j)
            n[i+j]+=a[i]*b[j];
    return n.check();
}
Wint& operator*=(Wint &a,const Wint &b)
{
    return a=a*b;
}
Wint divmod(Wint &a,const Wint &b)
{
    Wint ans;
    for(int t=a.size()-b.size(); a>=b; --t)
    {
        Wint d;
        d.assign(t+1,0);
        d.back()=1;
        Wint c=b*d;
        while(a>=c)
        {
            a-=c;
            ans+=d;
        }
    }
    return ans;
}
Wint operator/(Wint a,const Wint &b)
{
    return divmod(a,b);
}
Wint& operator/=(Wint &a,const Wint &b)
{
    return a=a/b;
}
Wint& operator%=(Wint &a,const Wint &b)
{
    divmod(a,b);
    return a;
}
Wint operator%(Wint a,const Wint &b)
{
    return a%=b;
}
Wint pow(const Wint &n,const Wint &k)//虽然这已经是快速幂，但是因为有问题所以还是不要用啦
{
    if(k.empty())return 1;
    if(k==2)return n*n;
    if(k.back()%2)return n*pow(n,k-1);
    return pow(pow(n,k/2),2);
}//以上皆为重载高精
int main(){
    int p;
    cin>>p;
    Wint ans=1,m=2,k=1;
    cout<<int(log10(2)*p+1)<<endl;//直接输出位数
    for(int i=1;i<=500;++i)	k*=10;
    for(;p;p>>=1,m=m*m%k)	if(p&1)	ans=ans*m%k;//快速幂
    ans-=1;//一定要减1！因为这里没写--这个运算符所以只能这么写
    int sis=500-ans.size();
    int t=0;
    if(sis<0);
    else
	{
		for(int i=1;i<=sis;++i)
	    {
	        cout<<0;
	        if(i%50==0)	cout<<endl;
	    }
		t=sis;
	}//输出0
    for(auto i=ans.rbegin();i!=ans.rend() && t<=500;++i)//rbegin及rend为反向迭代器，其实就是倒着输出
    {
        ++t;
        cout<<*i;//注意输出
        if(t%50==0)	cout<<endl;
    }
    return 0;
}
```

至此，我们得到了一份高精模板，一些关于STL的知识，一个叫做快速幂的优化算法以及一条取余运算的性质，~~同时得到了至理名言：STL和O2更配哦~~

温馨提示：或许还需要一些卡常技巧，毕竟NOIp不开O2嘛

---

## 作者：Llf0703 (赞：3)

高精乘法+快速幂

算位数的方法楼下和网上都有

高精乘法就是

```cpp
z[a+b-1]=x[a]*y[b]+z[a+b-1]+jw;
jw=z[a+b-1]/10;
z[a+b-1]=z[a+b-1]%10;
```
注意下进位清0和下标（我就因为这个改了半天）

具体代码及注解如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int p,a,b,c,d,weishu,jw;
int x[501],y[501],z[1001];
int main()
{
    cin>>p;
    weishu=log10(2)\*p+1;//算位数
    cout<<weishu<<endl;
    x[1]=1;
    y[1]=2;
    while (p!=0)//快速幂框架
    {
        if (p%2!=0)
        {
            jw=0;
            for (a=1;a<=500;a++)
            {
                jw=0;
                for (b=1;b<=500;b++)
                {
                    z[a+b-1]=x[a]\*y[b]+z[a+b-1]+jw;
                    jw=z[a+b-1]/10;
                    z[a+b-1]=z[a+b-1]%10;//高精乘法，z只是临时数组
                }
            } 
            for (a=1;a<=500;a++)
            {
                x[a]=z[a];
                z[a]=0;
            }//将z值给a并且归0
        }
        p=p/2;
        jw=0;
        for (a=1;a<=500;a++)
        {
            jw=0;
            for (b=1;b<=500;b++)
            {
                z[a+b-1]=y[a]\*y[b]+z[a+b-1]+jw;
                jw=z[a+b-1]/10;
                z[a+b-1]=z[a+b-1]%10;
            }
        }
        for (a=1;a<=500;a++)
        {
            y[a]=z[a];
            z[a]=0;
        }
    }
    x[1]--;
    for (a=500;a>=1;a--)
    {
        c++;
        cout<<x[a];
        if (c==50)
        {
            cout<<endl;
            c=0;
        }//输出格式
    }
    return 0;
}
···

---

## 作者：滑不可积 (赞：3)

快速幂
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int b[251]={0,2};
void lc(int *a)//a=a*b,b=b*b
{
	int c[251]={},k,r,i,j;
	for(i=1;i<=125;i++)
	{
		k=0;
		for(j=1;j<=125;j++)
		{
			r=a[i]*b[j]+k;
			c[j+i-1]+=r%10000;//j+i-1;
			k=r/10000;
		}
	}
	k=0;
	for(i=1;i<=125;i++)
	{
		k+=c[i];
		a[i]=k%10000;
		k/=10000;
	}
	return;
}
int main()
{
	int a[251]={0,1},p,w,i,j;
	cin>>p;
	cout<<int(p*log(2.0)/log(10.0))+1<<endl;
	while(p>0)
	{
		if(p%2)lc(a);
		p/=2;
		lc(b);
	}
	a[1]--;
	for(i=125;i>0;i--)
	{
		w=1000;
		for(j=1;j<=4;j++)
		{
			cout<<a[i]/w;
			a[i]%=w;
			w/=10;
			if(++p%50==0)cout<<endl;
		}
	}
	return 0;
}
```

---

## 作者：penghaotian (赞：3)

第一问是很简单的，只需要求一个对数而已，数学原理：十进制正整数n的位数为int(log10(n))+1。所以2^P-1的位数int(log10(2)\*p)+1 。

第二问的关键是高精度乘法和指数幂的运算，而且由于题目要求最后500位数字，所以在计算乘法的时候我们只要求计算乘数的低500位就好了。

指数幂的运算不能硬乘，而要采用分治算法，否则就超时了。分治递归算法求指数幂是非常经典的，其数学原理是a^n = a^(n/2)\*a^(n/2)\*f(a)，其中f(a) = 1(n%2==0)或f(a) = a(n%2==1)。

另外我们也可以创建一个栈，记录每次执行(n /= 2)前n的值是奇数还是偶数，然后根据上面的数学原理，模仿递归的思路，从n=1或n=0开始逆向计算a^n。

采用递归算法的时候，由于存储高精度整数数组的大小是预置MAX = 1000，所以在调用递归函数的时候要按引用传递参数，否则到了后面空间就不够分配了。

为了满足“每行输出50位”的条件，我把存储高精度整数数组的元素设置成5位数，这样输出的时候只需每行输出10个元素就行了。

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
int n , i , j;
int out[501], a[1001];
void num ( int n ) {
    if ( n == 0 ) 
        return;
    num ( n / 2 );
    for ( i = 1; i <= 500; i ++ )
        for ( j = 1; j <= 500; j ++ )
              if ( n % 2 == 0 ) 
                a[i + j - 1] += out[i] * out[j];
              else 
                  a[i + j - 1] += out[i] * out[j] * 2;
    for ( i = 1; i <= 500; i ++ ) {
        out[i] = a[i] % 10;
        a[i + 1] += a[i] / 10;
    }
    for ( i = 1; i <= 1000; i ++ ) 
        a[i] = 0;
}
int main ()
{
    //freopen ( "mason.in" , "r" , stdin );
    //freopen ( "mason.out" , "w" , stdout );
    scanf ( "%d" , &n );
    printf ( "%.0lf\n" , floor ( log ( 2 ) / log ( 10 ) * n + 1 ) );
    out[1] = 1;
    num ( n );
    for ( i = 500; i >= 2; i -- ) {
        printf ( "%d" , out[i] );
        if ( i % 50 == 1 ) 
            printf ( "\n" );
    }
    printf ( "%d\n" , out[1] - 1 );
    return 0;
}
```

---

## 作者：king_xbz (赞：3)

在分治问题中麦森数是一个非常典型的高精度问题，

于是我就写了一个基础的高精
```cpp
inline void myson() 
{
	a[500]=1;
	//初始进位 
	for(fint i=1;i<=n;i++)
	{
		for(fint j=500;j>=1;j--)
		a[j]*=2;
		//算每位*2 
		for(fint j=500;j>=1;j--)
		{
		a[j-1]+=a[j]/10;
		a[j]%=10;
		//进位
	}
	}
	a[500]--;
	//注意减一位，不然连暴力分也拿不到了 
}

```
提交，拿了60分。

不解，看题解，发现大多数神牛都在用快速幂。偶然的，我发现竟然可以用一次处理多次的方式来压时间

于是：
```cpp
inline void mysons()
{
	a[500]=1;
	//初始化进位 
	int x=pow(2,60);
	//每次乘2的60次方 
	for(fint i=1;i<=n;i+=60)
	{
		for(fint j=500;j>=1;j--)
		{
		if(n-i+1<60)
		a[j]*=pow(2,n-i+1);
		//注意当剩余不足60位时乘上2的剩余次方位 
		else
		a[j]*=x;
		//否则直接乘2的60次方 
	}
	for(fint j=500;j>=1;j--)
		{
		a[j-1]+=a[j]/10;
		a[j]%=10;
	}
	//处理进位 
}
a[500]--;
//a[500]初始为1，此时应该减去 
}
```
提交，ac！

完整注释代码

code：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define fread ios::sync_with_stdio
#define int unsigned long long
#define fint register long long
#define p 14732334
#define h 501
//头文件，宏定义及加速 

using namespace std;
int a[h];
int n;

inline void myson();
inline void prints();
inline void mysons();

signed main()
{
	fread(false);
	//流读入优化 
	cin>>n;
	cout<<floor(log10(2)*n+1)<<endl;
	//根据2^p-1的位数=2^p的位数可推出位数是log10^2*n+1向下取整（数学方法） 
    mysons();
    //调用函数求麦森数 
    prints();
    //输出 
    exit(0);
    //结束 
}
暴力高精度（60分） ： 
inline void myson() 
{
	a[500]=1;
	//初始进位 
	for(fint i=1;i<=n;i++)
	{
		for(fint j=500;j>=1;j--)
		a[j]*=2;
		//算每位*2 
		for(fint j=500;j>=1;j--)
		{
		a[j-1]+=a[j]/10;
		a[j]%=10;
		//进位
	}
	}
	a[500]--;
	//注意减一位，不然连暴力分也拿不到了 
}
inline void prints()
{
	for(fint i=1;i<=500;i++)
	{
		cout<<a[i];
		//输出 
		if(i%50==0)
		cout<<endl;
		//每50位换行 
	}
}
压位做法（100分）： 
inline void mysons()
{
	a[500]=1;
	//初始化进位 
	int x=pow(2,60);
	//每次乘2的60次方 
	for(fint i=1;i<=n;i+=60)
	{
		for(fint j=500;j>=1;j--)
		{
		if(n-i+1<60)
		a[j]*=pow(2,n-i+1);
		//注意当剩余不足60位时乘上2的剩余次方位 
		else
		a[j]*=x;
		//否则直接乘2的60次方 
	}
	for(fint j=500;j>=1;j--)
		{
		a[j-1]+=a[j]/10;
		a[j]%=10;
	}
	//处理进位 
}
a[500]--;
//a[500]初始为1，此时应该减去 
}
```
祝大家ac

---

## 作者：ysner (赞：3)

我要为大家奉上一种使用位运算的简便方法，保证代码短小精炼易理解。

1、数位用公式(int)(p\*log10(2)+1)，不知道自己找度娘；

2、虽说结果最后减了1，但不影响位数；

3、a数组存最后500位数字，1个元素存5位数字（数组开的小一些）；

4、普通的乘法肯定要超时，我们可以借助位运算，一次左移10次（很方便地省掉写循环的过错），最终对于不足10次左移的再一位一位移即可；

5、乘2用位运算非常方便简洁。

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define max 100000
using namespace std;
int main() 
{
  int p,a[111]={},i,j,k,l;
  cin>>p;
  printf("%d\n",(int)(p*log10(2)+1));//数位公式
  a[0]=1;
  l=p%10;
  p/=10;
  for(i=0;i<p;i++)//10位左移
  {
    for(j=0;j<=100;j++)
      a[j]<<=10;//不用开个循环乘10遍2
    for(j=0;j<=100;j++)
      if(a[j]>=max) {a[j+1]+=a[j]/max;a[j]%=max;}//高精度运算常见的进位
  }
  for(i=0;i<l;i++)//不足10位的左移
  {
      for(j=0;j<=100;j++)
        a[j]<<=1;//等价于a[j]*=2
      for(j=0;j<=100;j++)
      if(a[j]>=max) {a[j+1]+=a[j]/max;a[j]%=max;} //高精度运算常见的进位
  }
  a[0]-=1;//这里可以不用检验末位是否小于0，因为2的幂次方尾数总是2,4,6,8,减1也就1,3,5,7,到不了负数
  for(i=99;i>=0;i--)
  {
    printf("%05d",a[i]);//位数不足5时补0，为题意“不足500位时高位补0”
    if((100-i)%10==0) cout<<endl;//输出10个（50位）后换行
  }
  return 0;
}
```

---

## 作者：phy东西 (赞：2)

看了一圈题解，就让我这个蒟蒻祭出我的60分代码（就是你抄了也没用）
```c
#include<stdio.h>
#include<math.h>
unsigned char bcd[2000];
int P;
unsigned long int val;
void move(void){
    for(int i=1999;i>0;i--) bcd[i]=bcd[i-1];
    if(P>0){
        bcd[0]=1;
        P--;
    }
    return;
}
void DD(void){
    while(P){
        for(int i=0;i<2000;i+=4){
            val=bcd[i]+(bcd[i+1]<<1)+(bcd[i+2]<<2)+(bcd[i+3]<<3);
            if(val>4){
                if(val>7){
                    if(val>8){
                        bcd[i+2]=1;
                        bcd[i]=0;
                    }
                    else{
                        bcd[i+1]=1;
                        bcd[i]=1;
                    }
                }
                else{
                    if(val>6){
                        bcd[i+3]=1;
                        bcd[i+2]=0;
                        bcd[i]=0;
                    }
                    else{
                        if(val>5){
                            bcd[i+3]=1;
                            bcd[i+2]=0;
                            bcd[i+1]=0;
                            bcd[i]=1;
                        }
                        else{
                            bcd[i+3]=1;
                            bcd[i+2]=0;
                            bcd[i]=0;
                        }
                    }
                }
            }
        }
        move();
    }
    return;
}
void print(void){
    for(int i=1996;i>=0;i-=4){
        val=bcd[i]+(bcd[i+1]<<1)+(bcd[i+2]<<2)+(bcd[i+3]<<3);
        if(val>4){
            if(val>7){
                if(val>8) putchar('9');
                else putchar('8');
            }
            else{
                if(val>6) putchar('7');
                else{
                    if(val>5) putchar('6');
                    else putchar('5');
                }
            }
        }
        else{
            if(val>2){
                if(val>3) putchar('4');
                else putchar('3');
            }
            else{
                if(val>1) putchar('2');
                else{
                    if(val>0) putchar('1');
                    else putchar('0');
                }
            }
        }
        if(i%200==0&&i) printf("\n");
    }
    return;
}
int main(void){
    scanf("%d",&P);
    printf("%d\n",(int)(log10((double)2)*P+1));
    DD();
    print();
    return 0;
}
```
这个算法叫做double dabble

在这里可能知道的人比较少

不过，在我以前活跃的红石电路小圈子里，他还有一个响亮的名字：

# 满五加三

咳咳

让我来手算演示一下啊

比如说把二进制数
```
11011001换算一下
把11011001不断左移
|_ _ _ _|_ _ _ _|_ _ _ _|11011001
|_ _ _ _|_ _ _ _|_ _ _ 1|1011001
|_ _ _ _|_ _ _ _|_ _ 1 1|011001
|_ _ _ _|_ _ _ _|_ 1 1 0|11001//满五加三
|_ _ _ _|_ _ _ _|1 0 0 1|11001
|_ _ _ _|_ _ _ 1|0 0 1 1|1001
|_ _ _ _|_ _ 1 0|0 1 1 1|001//满五加三
|_ _ _ _|_ _ 1 0|1 0 1 0|001
|_ _ _ _|_ 1 0 1|0 1 0 0|01//满五加三
|_ _ _ _|1 0 0 0|0 1 0 0|01
|_ _ _ 1|0 0 0 0|1 0 0 0|1
|_ _ _ 1|0 0 0 0|1 0 1 1|1
|_ _ 1 0|0 0 0 1|0 1 1 1|//最后一位移入后不再检查是否满5
    2       1       7
```
成功换算成十进制（准确说是BIN转BCD码）

原理的话我不太懂，希望哪位大神能指点一二，我猜测于16进制有关

如果谁能使用这个算法而不TLE，请务必告诉我，我TLE4个点。

其实这个代码比较省空间，也可以有浪费内存的写法，就是开一个极大的数组把2^P-1这个二进制数直接装进去移动bcd的位置不断换算。估计能快一点。

这个算法在MC里还是比较实用的，具体应用方法请找B站UP主phy东西（还是我）

---

## 作者：JustinRochester (赞：2)

楼上的几位大佬都写得很好，我这里就提一个别的方法：

众所周知，题目给定的 $2^P$ ，最后一位一定是 $2$ 、 $4$ 、 $8$ 、 $6$ 的其中一位，无一例外都大于 $1$

也就是说，不论我们最后计算 $2^P$ 结果如何，我们直接最后一位 $-1$ 即可得到答案

同时，根据这个性质我们很容易得到： $2^P$ 与 $2^P-1$ 在十进制下的位数应该一样

所以，我们要先输出 $2^P$ 的位数

假设 $2^P=10^A$ 根据对数的性质可得：

$A=\log_{10} 2^P=P\log_{10} 2$

而答案又是 $\lfloor A+1 \rfloor$ ，因此直接输出 $\lfloor P\log_{10}2+1\rfloor$ 即可

C++中的 <cmath> 库有提供 log10(x) 来计算 $\log_{10} x$
  
而向下取整可以用原数减去 $0.5$ 后按 %.f 输出

---

下面是重头戏，我们考虑一下怎么计算 $2^P$

其他大佬都已经说过了高精乘怎么处理这题了，那本蒟蒻就不说这种方法了，来一个新的：

学过位运算的应该都知道， $2^a$ 可以用(1<<a) 表示。当然，如果不溢出的话

那么，我们所求的应该就是 (1<<P) 了，当然，这会溢出

那咋办？高精重载 << 符号啊！

这边就一个细节，注意左移也不能一步移到位，因为这样还是会溢出

我们分几次来就可以了

具体细节可以看本蒟蒻的代码

---

**【代码】**
--

那本蒟蒻就放代码了

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
#define f(a,b,c) for(register int a=b;a<=c;a++)
#define g(a,b,c) for(register int a=b;a>=c;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
#define File(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
typedef long long int ll;
typedef unsigned long long int ull;
const int MAXN=10010;
const int Lim=100000;
typedef int ar[MAXN];
inline ll read(){
    register ll ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-') ,c=getchar();
    while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return neg?-ans:ans;
}//不要害怕，这是条件反射的结果，你们可以直接忽略
struct Bignum{
	ll Num[110],Len;
	inline void clear() { memset(Num,0,sizeof(Num)); Len=1; }
	Bignum() { clear(); }
	inline void output(){
		g(i,100,1){
			if(i%10==0) putchar('\n');
			printf("%05d",Num[i-1]);
		}
	}
	void operator <<= (const ll &x){
		ll y=x;
		while(y){
			ll Tmp=(y<40)?y:40;
			f(i,0,Len-1) Num[i]<<=Tmp;
			f(i,0,Len-1) Num[i+1]+=Num[i]/Lim,Num[i]%=Lim;
			while(Num[Len]&&Len<100){
				Num[Len+1]+=Num[Len]/Lim;
				Num[Len]%=Lim;
				Len++;
			}
			Num[100]=0;
			y-=Tmp;
		}
	}
}Ans;
int main(){
	Ans.Num[0]=1;
	int N=read();
	printf("%.f",log10(2)*N+0.5);
	Ans<<=N;
	Ans.Num[0]--;
	Ans.output();
	return 0;
}
```

---

## 作者：zhouzihan_2004 (赞：2)

裸的高精度题

1求位数:直接套用数学公式log10(2)乘上n就好了（c++中有log10函数）

2求后五百位：如果直接模拟高精度肯定会超时，所以要优化看见。其他人都是快速幂，这里提供一种时间较慢，但容易实现的方法：

对于2^n，可以分解成（2^x）^(n/x)，这是本解题思路的核心，这样就不用运算n次，而是n/x次，只要2^x在范围内，就可以实现优化，可以通过本题。

不过要注意，因为c++中除法运算会自动向下取整（整型），所以还要多乘上一个2^(n%x)

最后，再把最后一位减一就可以了

代码如下：

```cpp
    #include<iostream>
    #include<cmath>
    #define x 50
    using namespace std;
    long long n,f[502],Pow[x+1],tmp;
    double count;
    void output()
    {
        count=log10(2)*n;//数学公式 
        while(count>1)
        {
            tmp++;
            count--;
        }
        if(count) tmp++;//不是整数则向上取整 
        cout<<tmp<<endl;
        for(int i=500;i>=1;i--)
        {
            cout<<f[i];
            if(i%50==1) cout<<endl;
        }
        return ;
    }
    int main()
    {
        Pow[0]=1;
        for(int i=1;i<=x;i++)
          Pow[i]=Pow[i-1]*2;//Pow[i]:2的i次方 
        cin>>n;
        f[1]++;
        for(int i=1;i<=n/x;i++)
        {
            for(int j=1;j<=500;j++)
              f[j]*=Pow[x];
            for(int j=1;j<=500;j++)
              if(f[j]>=10)
              {
                    f[j+1]+=f[j]/10;
                    f[j]%=10;
              }
            f[501]=0;
```
}//高精度主体
```cpp
        for(int i=1;i<=x-1;i++)
          if(n%x==i)
          {
              for(int j=1;j<=500;j++)
                f[j]*=Pow[i];
              for(int j=1;j<=500;j++)
                if(f[j]>=10)
                {
                      f[j+1]+=f[j]/10;
                      f[j]%=10;
                }
              f[501]=0;
```
}//乘上2的n%x次方
        f[1]--;

        output();

        return 0;

}

---

## 作者：衡屿睿 (赞：2)

我在之前的题解里说过，大多数普及组第三题考的不是分析而是优化。

说句题外话，2003年普及组试题安排的有失偏颇，最难的其实是第二题。

不过首先这道题得从数论的角度入手，平时我们估计一个十进制数x(x>0)的位数，往往潜在地使用了放缩法：

若10^k<=x<10^(k+1)，则x有k+1位。而当x=2^p-1时，由于x的末位不为0，因此不存在借位现象，所以x的位数等于2^p的位数。

又假设10^k<=2^p<10^(k+1)，此中的k，便等于[log10(2^p)]也就是int(log10(2^p))。

最后简单变换一下，第一问的答案便是int(p\*log10(2))+1。

第二问若用高精加法，时间复杂度为O(n)。但常数过大，超时在所难免。

于是想到，要用快速幂高精。

只有一点不同，此处的快速幂是递归形式的。

当由递归得到2^(p/2)的值时，便可以通过2^p=2^(p/2)\*2^(p/2)得到2^p的值，若p是奇数，2^p=2^(p/2)\*2^(p/2)\*2即可。

以下是递归的框架：

```cpp
int a[],b[];
void jyxpw(long long n) //n即为p值
{
    if(n==0)return;
    jyxpw(n/2);
    if(n%2==0)
```
根据2^p=2^(p/2)\*2^(p/2)，由高精得到a=b\*b;
    if(n%2==1)

根据2^p=2^(p/2)\*2^(p/2)\*2，由高精得到a=b\*b\*2;

处理a数组进位，更新b数组；

清空a数组；

}
源代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
long long a[10000]={0},b[10000]={0};
void jyxpw(long long n)
{
    if(n==0)return;
    jyxpw(n/2);
    if(n%2==0)
    for(int i=1;i<=500;++i)
     for(int j=1;j<=500;++j)
      a[i+j-1]=a[i+j-1]+b[i]*b[j];
    if(n%2==1)
    for(int i=1;i<=500;++i)
     for(int j=1;j<=500;++j)
      a[i+j-1]=a[i+j-1]+b[i]*b[j]*2;
    for(int i=1;i<=500;++i)
    {
    b[i]=a[i]%10;
        a[i+1]=a[i+1]+a[i]/10;    
    }
    memset(a,0,sizeof(a));
}
int main()
{
    long long p;
    cin>>p;
    cout<<(int)(p*log10(2)+1)<<endl;
    b[1]=1;
    jyxpw(p);
    for(int i=500;i>1;--i)
    {
        cout<<b[i];
        if(i%50==1)cout<<endl;
    }
    cout<<b[1]-1;
    return 0;
}
```

---

## 作者：1261687299kid (赞：2)

首先位数方面别的题解也说了，这里也不展开，Pascal代码就是trunc(p\*ln(2)/ln(10)+1)

我不是大神，也不会2个大数相乘的那种高精度，只能一次乘多一点，来节省时间。(如果考试的时候也只能这样了)

Pascal有一个比int64还大的整形qword，是int64的两倍，没有负数，用这个一次可以直接乘2的59次方，2的60次方就炸了

这个方法我全力节省，终于100，最后一个点还是0.9秒过的，但比其他方法简单。

```cpp
var
  a:array[0..500] of qword;//为什么要开0呢，因为高精度乘法的时候可以节省时间
  i,j,p:longint;
  x:longint;
begin
  readln(p);
  a[1]:=1;
  for i:=1 to p div 59 do//一次直接乘2的59次方
    begin
       for j:=1 to 500 do
         begin
           a[j]:=a[j]*576460752303423488+a[j-1] div 10;
           a[j-1]:=a[j-1] mod 10;//这个算法只要2句，而另外一个高精度算法需要4句，这节省的一点时间就是80和100的区别
         end;
       a[500]:=a[500] mod 10;
    end;
  for i:=1 to p mod 59 do//剩下的2
    begin
      for j:=1 to 500 do
        begin
          a[j]:=a[j]*2+a[j-1] div 10;
          a[j-1]:=a[j-1] mod 10;
        end;
      a[500]:=a[500] mod 10;
    end;
  a[1]:=a[1]-1;
  x:=trunc(p*ln(2)/ln(10)+1);//计算位数
  writeln(x);
  if x>499 then for i:=500 downto 1 do//输出
                  begin
                    write(a[i]);
                    if (i-50) mod 50=1 then writeln;
                  end
           else begin
                  for i:=500 downto x+1 do
                    begin
                      write(0);
                      if (i-50) mod 50=1 then writeln;
                    end;
                  for i:=x downto 1 do
                    begin
                      write(a[i]);
                      if (i-50) mod 50=1 then writeln;
                    end;
                 end;
end.
```

---

## 作者：doby (赞：2)

位数公式依然是floor(log(2)/log(10)\*n+1)，不多作说明

方法一：一次乘55个！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,i,j,a[501];
int main()
{
    cin>>n;
    cout<<floor(log(2)/log(10)*n+1)<<endl;
    a[0]=1;
    for(i=0;i<n-55;i=i+55)
    {
        for(j=0;j<501;j++){if(a[j]==0){continue;}a[j]=a[j]*36028797018963968;}
        for(j=0;j<501;j++){if(a[j]>9){a[j+1]=a[j+1]+a[j]/10,a[j]=a[j]%10;}}//进位
    }
    for(;i<n;i++)//剩下的也要乘下去……
    {
        for(j=0;j<501;j++){if(a[j]==0){continue;}a[j]=a[j]*2;}
        for(j=0;j<501;j++){if(a[j]>9){a[j+1]=a[j+1]+a[j]/10,a[j]=a[j]%10;}}
    }
    for(i=499;i>0;i--){cout<<a[i];if(i%50==0){cout<<endl;}}
    cout<<a[0]-1;//因为要-1，单独输出
    return 0;
}
```
很遗憾，因为wallace跑得太慢，80分……
方法二：一次乘40个+压位

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long a[129],n,i,j,sum=0;
int main()
{
    cin>>n;
    cout<<floor(log(2)/log(10)*n+1)<<endl;
    a[1]=1;
    for(;i<=n-40;i=i+40)
    {
        for(j=1;j<=125;j++)
        {
            if(a[j]!=0){a[j]=a[j]*1099511627776;}
        }
        for(j=1;j<=125;j++)
        {
            if(a[j]>9999)//进位……
            {
                a[j+1]=a[j+1]+a[j]/10000,
                a[j]=a[j]%10000;
            }
        }
    }
    for(;i<n;i++)//剩下的还要乘完……
    {
        for(j=1;j<=125;j++)
        {
            if(a[j]!=0){a[j]=a[j]*2;}
        }
        for(j=1;j<=125;j++)
        {
            if(a[j]>9999)
            {
                a[j+1]=a[j+1]+a[j]/10000,
                a[j]=a[j]%10000;
            }
        }
    }
    for(i=125;i>1;i--)
    {
        cout<<a[i]/1000<<a[i]/100%10;sum=sum+2;
        if(sum==50){cout<<endl;sum=0;}//有可能在一个四位的中间需要输出回车
        cout<<a[i]/10%10<<a[i]%10;sum=sum+2;
        if(sum==50){cout<<endl;sum=0;}
    }
    cout<<a[1]/1000<<a[1]/100%10<<a[1]/10%10<<a[1]%10-1;//最后一位单独输出……
    return 0;
}
```
时间还是很可以的，终于不超时了……
思维复杂度较低，易理解


---

## 作者：wffms69_8 (赞：2)

附赠高精度模板，带负数、压位；请各位OIer自行忽略高精度部分，只看main函数即可。

```cpp
#include<vector>
using std::vector;
#include<sstream>
using std::stringstream;
#include<iterator>
using std::ostream_iterator;
#include<iostream>
using std::cin;
using std::cout;
using std::endl;
using std::istream;
using std::ostream;
#include<algorithm>
using std::reverse;
using std::max;
using std::lexicographical_compare;
using std::find;
#include<string>
using std::string;
#include<iterator>
using namespace std;
#include<cmath>

class BigInt : public vector<long long> {
    bool negative;

public:
    BigInt(long long num = 0);
    BigInt operator +(const BigInt&) const ;
    BigInt operator += (const BigInt&);
    BigInt operator -(const BigInt&) const ;
    BigInt operator -= (const BigInt&);
    BigInt operator * (const BigInt&) const ;
    BigInt operator *= (const BigInt&);
    BigInt operator / (long long num) const ;
    BigInt operator ^ (unsigned index) const ;
    inline bool operator < (const BigInt&) const ;
    inline bool operator > (const BigInt&) const ;
    inline bool operator <= (const BigInt&) const ;
    inline bool operator >= (const BigInt&) const ;
    friend inline istream &operator >> (istream&, BigInt&);
    friend inline ostream &operator << (ostream&, BigInt&);
} dp[88][88], ans;

const unsigned sys(100000); // 压位

int main(int argc, char* argv[]) {
    int a;
    cin >> a;
    cout << int(a * log10(2)) + 1 << endl; // 先用数学方法算出答案的位数
    ans = BigInt(2) ^ a;
    ans -= 1;
    stringstream ss;
    ss << ans;
    string s(ss.str());
    s.insert(0, 500 - min((size_t)500, s.size()), '0'); // 不足500位补0
    for (int i(1); i <= 500; ++i) {
        cout << s[i - 1];
        if (i % 50 == 0)
            cout << endl;
    }
    return 0;
}

BigInt::BigInt(long long num) {
    negative = num < 0;
    do
        this->push_back(num % sys);
    while (num /= sys);
}

BigInt BigInt:: operator +(const BigInt &num) const {
    BigInt result, a = *this, b = num;
    a.negative = b.negative = false;
    if (this->negative)
        if (num.negative) {
            result = a + b;
            result.negative = true;
            return result;
        }
        else
            return b - a;
    else if (num.negative)
        return a - b;
    else {
        size_t max_size(std::max(num.size(), size()));
        a.resize(max_size, 0);
        b.resize(max_size, 0);
        for (size_t i(0); i < max_size; result[i++] %= sys)
            result.push_back((result[i] += b[i] + a[i]) / sys);
        while (result.size() > 1 && *result.rbegin() == 0)
            result.erase(result.end() - 1);
        return result;
    }
}

BigInt BigInt:: operator += (const BigInt &num) {
    return *this = *this +num;
}

BigInt BigInt:: operator -(const BigInt &num) const {
    BigInt result, a(*this), b(num);
    a.negative = b.negative = false;
    if (negative)
        if (num.negative)
            return b - a;
        else {
            result = a + b;
            result.negative = !result.negative;
            return result;
        }
    else if (num.negative)
        return a + b;
    else {
        if (a < b) {
            a.swap(b);
            a.negative = true;
        }
        b.resize(a.size(), 0);
        for (size_t i(0); i < a.size(); ++i) {
            if (a[i] < b[i])
                a[i] += sys, --a[i + 1];
            a[i] -= b[i];
        }
        while (a.size() > 1 && *a.rbegin() == 0)
            a.erase(a.end() - 1);
        return a;
    }
}

BigInt BigInt:: operator -= (const BigInt &num) {
    return *this = *this -num;
}

BigInt BigInt:: operator *(const BigInt &num) const {
    if (*this == BigInt() || num == BigInt())
        return BigInt();
    BigInt result;
    result.negative = negative ^ num.negative;
    result.resize(size() + num.size(), 0);
    for (size_t i(0); i < size(); ++i)
        for (size_t j(0); j < num.size(); ++j)
            result[i + j] += at(i) * num[j];
    for (size_t i(0); i < result.size() - 1; ++i)
        result[i + 1] += result[i] / sys, result[i] %= sys;
    while (*result.rbegin() == 0)
        result.erase(result.end() - 1);
    // ~~~~~~以下是为本题加的优化（只保留后500位）~~~~~~
    if (result.size() > 100)
        result.resize(100);
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~
    return result;
}

BigInt BigInt:: operator *= (const BigInt &num) {
    return *this = *this*num;
}

BigInt BigInt:: operator / (long long num) const {
    BigInt result(*this);
    return result;
}

BigInt BigInt:: operator ^ (unsigned index) const {
    BigInt result(1), base = *this;
    for (; index; base *= base, index >>= 1)
        if (index & 1)
            result *= base;
    return result;
}

inline bool BigInt:: operator < (const BigInt &num) const {
    if (negative ^ num.negative)
        return negative;
    if (size() == num.size()) {
        for (int i(size() - 1); i >= 0; --i)
            if (at(i) != num[i])
                return at(i) < num[i] ^ negative;
        return false;
    }
    else
        return size() < num.size() ^ negative;
}

inline bool BigInt:: operator > (const BigInt &num) const {
    return num < *this;
}

inline bool BigInt:: operator <= (const BigInt &num) const {
    return !(num < *this);
}

inline bool BigInt:: operator >= (const BigInt &num) const {
    return !(*this < num);
}

inline istream &operator >> (istream &in, BigInt &num) {
    num.clear();
    num.negative = false;
    string data;
    in >> data;
    if (data[0] == '-')
        data.erase(0, 1), num.negative = true;
    int tmp(0);
    for (size_t i(data.size()), cnt(1); i--; cnt *= 10)
        if (cnt < sys)
            tmp += cnt * (data[i] - '0');
        else {
            num.push_back(tmp);
            tmp = data[i] - '0';
            cnt = 1;
        }
    num.push_back(tmp);
    return in;
}

inline ostream &operator << (ostream &out, BigInt &num) {
    if (num.negative)
        out.put('-');
    for (BigInt::reverse_iterator i(num.rbegin()); i < num.rend(); out << *i++)
        if (i != num.rbegin())
            for (int j(0); j < (*i ? int(log10(sys))-int(log10(*i) + 1) :
                log10(sys) - 1); ++j)
                out.put('0');
    return out;
}
```

---

## 作者：谁懂谁伤心 (赞：2)

这题要求两件事：

1.位数：  log(2)/log(10)\*q+1（q为次方数）

2.高精求后500位： 逐位逐次乘2会超时，有些神犇们用快速幂，本学渣只会用一次乘2^25次方，减少计算次数（但要注意进位，详见程序）。

```cpp

#include <cmath>  
#include <iostream>    
#include <cstring>    
#include <cstdio>
using namespace std;    
int main()    
{    
int q,a[516]={0}; a[0]=1; scanf("%d",&q); int u=q%25;  
for (int b=1;b<=q/25;b++)    
{for (int k=500;k>=0;k--)    
if (a[k]==0) continue; else a[k]*=33554432;   
for (int k=0;k<=500;k++) if (a[k]>=10) {a[k+1]+=a[k]/10;a[k]%=10; }}  
for (int b=1;b<=u;b++)    
for (int k=500;k>=0;k--)    
{if (a[k]==0) continue; else a[k]*=2;    
if (a[k]>9) {a[k+1]+=a[k]/10;a[k]%=10; }}  
a[0]--;    
int t=log(2)/log(10)*q+1;  
printf ("%d\n",t);  
for (int k=499;k>=0;k-=50) {for (int p=0;p<=49;p++)printf ("%d",a[k-p]); printf ("\n");}    
return 0;  
}     
```

---

## 作者：critnos (赞：2)

~~我不会告诉你我不会高精快速幂~~

看到题解的压位写得有点麻烦，我再来发一篇

首先，本蒟蒻敲的就是标准的高精乘，但是很快发现会TLE4个点

显然，卡常是卡不过的

那怎么办呢？

# 压位！！！

一般来说，2^20-1=1048575是这样存的

[1] [0] [4] [8] [5] [7] [5]

但是，int本来能存10位，这样似乎有些浪费

如果把相邻的几位压成一个数那就可以了（直接乘比按位乘快）

也就是说，把10进制改成了10^n进制

压5位：

[10] [48575]

当然，不一定压位越多越快（c++最大只能压18位），而且为了方便最好只压50的因数（因为每行输出50个）

压1，2位只能拿60分

压5位能拿80分

压10位才能AC（得开long long）

so，代码分为两步~~废话~~：

**1.求后500位**

直接模拟，没什么好说的

```cpp
const ll d=10,md=(ll)pow(10,d),cd=500/d,cy=cd-1;//分别是：压的位数，进制，数组大小和玄学变量
register int n,i,j,s;
ll a[cd]; 
a[cy]=1;
for(i=0;i<n;i++)
	{
		for(s=0,j=cy;j>0;j--)
		{
			a[j]=a[j]*2+s;
			s=a[j]/md;
			a[j]%=md;
		}
		a[0]=(a[0]*2+s)%md;//因为只用算500位，所以最后一位不用进位
	}
a[cy]--;
```

**2.输出**

把每个数（不满d位的）的高位补0，一直到d位为止

所以，输出函数是这样的：

```cpp
string x;
void write(ll n)
{
	if(n==0)//0似乎是特殊情况，不特判会有奇效
	{
		cout<<x;//先提前把一个字符串x变成d个"0"（在主程序里面）
		return;
	}
	ll q=n;
	register int p=0,i;
	while(n)//求位数，别问我为什么不用log10
	{
		n/=10;
		p++;
	}
	for(i=0;i<d-p;i++) cout<<0;
	cout<<q;
}
```
再配合主程序：

```cpp
for(i=0;i<d;i++) x+="0";
for(s=i=0;i<cd;i++)
	{
		s+=d;
		write(a[i]);
		if(s==50)//换行
		{
			s=0;
			cout<<endl;
		}
	}
```


附上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll d=10,md=(ll)pow(10,d),cd=500/d,cy=cd-1;
string x;
ll a[cd]; 
void write(ll n)
{
	if(n==0)
	{
		cout<<x;
		return;
	}
	ll q=n;
	register int p=0,i;
	while(n)
	{
		n/=10;
		p++;
	}
	for(i=0;i<d-p;i++) cout<<0;
	cout<<q;
}
int main()
{
	register int n,i,j,s;
	for(i=0;i<d;i++) x+="0";
	cin>>n;
	a[cy]=1;
	cout<<floor(n*0.30102999566)+1<<endl;
	for(i=0;i<n;i++)
	{
		for(s=0,j=cy;j>0;j--)
		{
			a[j]=a[j]*2+s;
			s=a[j]/md;
			a[j]%=md;
		}
		a[0]=(a[0]*2+s)%md;
	}
	a[cy]--;
	for(s=i=0;i<cd;i++)
	{
		s+=d;
		write(a[i]);
		if(s==50)
		{
			s=0;
			cout<<endl;
		}
	}
} 
```

修改第4行的d可以改变压的位数（不是50的因数会有奇效）

python可以压50位，但是速度太慢只能拿60分

```python
md=10**50
a=[0,0,0,0,0,0,0,0,0,1]
n=int(input())
print(int(n*0.30102999566)+1)
q='0'*50
for i in range(n):
    s=0
    for j in range(9,0,-1):
        a[j]=a[j]*2+s
        s=int(a[j]/md)
        a[j]=a[j]%md
    a[0]=(a[0]*2+s)%md
a[9]=a[9]-1
for i in a:
    s=i
    if s:
        p=0
        while s:
            p=p+1
            s=int(s/10)
        print("%s%d" % ('0'*(50-p),i))
    else:
        print(q)
```


---

## 作者：魁拔 (赞：2)

本题需要用到快速幂，既用高精算平方。

由与2的任何数次方都可以表示为2^1,2^2,2^4,2^8....得乘积

就可以相对快的求出2的任何次方的数了。

第一问```delphi
 writeln(trunc(p*ln(2)/ln(10))+1);
```

---

## 作者：TQCAI (赞：1)

https://www.luogu.org/problemnew/show/P1045

---

高精度板子:
http://www.cnblogs.com/TQCAI/p/8410799.html
快速幂:
```cpp
ll quickPower(ll a,ll b){
    ll ans=1,base=a;
    while(b>0){
        if(b&1)
            ans*=base;
        base*=base;
        b>>=1;
    }
    return ans;
}
```
还涉及到取对数的问题

```cpp
#include <bits/stdc++.h>
#define FF(a,b) for(int a=0;a<b;a++)
#define F(a,b) for(int a=1;a<=b;a++)
#define LEN 510000
#define INF 1000000
#define bug(x) cout<<#x<<"="<<x<<endl;

using namespace std;

int P;
int L=500;

struct hp{
    int len;
    int *s;
    hp(){
        s=new int [LEN];
        memset(s,0,4*LEN);
        len=1;

    }
    hp(char* ch){
        len=strlen(ch);
        s=new int [LEN];
        memset(s,0,4*LEN);
        for(int i=1;i<=len;i++)
            s[i]=ch[len-i]-48;
    }
    void print(){
        int i;
        for(i=500;i>=1;i--){
            if(i%50==0) puts("");
            printf("%d",s[i]);
        }

    }
};

hp multiplyh(const hp& a,const hp& b){
    int i,j,len;
    hp c;
    for(i=1;i<=a.len;i++){
        for(j=1;j<=b.len;j++){
            c.s[i+j-1]+=a.s[i]*b.s[j];
            c.s[i+j]+=c.s[i+j-1]/10;
            c.s[i+j-1]%=10;
        }
    }
    len=a.len+b.len+1;
    while(len>1 && c.s[len]==0)len--;
    c.len=len;
    if(c.len>=L){//截取最后500项
        c.len=500;
    }
    return c;
}

int main()
{
    freopen("./in","r",stdin);
    scanf("%d",&P);
    printf("%d",int( log10(2)*P + 1) );
    hp ans("1");
    hp base("2");
    while(P>0){
        if(P&1)
            ans=multiplyh(ans,base);
        base= multiplyh(base,base);
        P>>=1;
    }
    ans.s[1]-=1;
    ans.print();
    return 0;
}


```



---

## 作者：throusea (赞：1)

求一个数$x$的位数。

不难发现，如果一个数的位数为$k$,那么$x - 10^{k-1} \ge 0$，举个例子：

$9999$，位数为$4$，那么有。

$$ 9999 - 1000 = 8999 \ge 0 $$

因为对于一个位数为$k$的数$x$，$x$的取值范围为 $[10^{k-1},10^{k}-1]$ （闭区间）

回到上面的问题，实际上我们就是求

对于该不等式$x - 10^{k-1} \ge 0$的最大正整数$k$。 

解不等式

$$x - 10^{k-1} \ge 0$$
$$ x \ge 10^{k-1}$$
等式两边加上$lg10$,有
$$ lg(x) \ge k-1$$
$$ k \le lg(x)+1$$

所以，只要计算出$lg(x)+1$的值，向下取整即可。

有关数论的东西多用点对数。

---

## 作者：Fuko_Ibuki (赞：1)

这么多题解不喜欢用结构体？定义结构体bignum,然后重载一个运算符\*，写起来简单而又易于理解。令人惊异的是这个代码交上去跑了196ms.然后我开了O3优化,瞬间变0ms。好神奇啊！不用结构体的话写起来非常繁琐，我是个蒟蒻看不懂楼下的代码，可能是我比较菜吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
int p;
struct boss{//结构体1000位bigint
int len,num[1010],nev;//我直接粘贴的模板，在本题当中只有num数组有用。
boss(){len=0,memset(num,0,sizeof num);nev=0;}
void print()
  {
  if (nev==1) printf("-");
  for (int i=len;i>=1;i--) printf("%d",num[i]);
  putchar('\n');
  }
}a,tmp;

boss operator *(boss a,boss b)//重载乘号，使得定义的大整数结构体相乘和int相乘写起来一样简单。
{
boss c;
for (int i=1;i<=500;i++) for (int j=1;j<=500;j++) c.num[i+j-1]+=a.num[i]*b.num[j];//具体的一样，记得数组要开到1000。
for (int i=1;i<=500;i++) if (c.num[i]>9) 
  {
  c.num[i+1]+=c.num[i]/10;
  c.num[i]%=10;
  }
return c;
}

int main()
{
scanf("%d",&p);
printf("%d\n",(int)(log10(2)*p+1));//这个位数下面大神给出了解释
a.num[1]=1;tmp.num[1]=2;
for (;p;p>>=1,tmp=tmp*tmp) if (p&1) a=a*tmp;//快速幂简短的写法。重载了乘号之后看起来非常自然。
for (int i=500;i>=2;i--,i%50==0?puts(""):0) printf("%d",a.num[i]);
printf("%d",a.num[1]-1);//普通地输出之。
}
```

---

## 作者：jzqjzq (赞：1)

方案数直接公式trunc(log10(2)\*P)+1

五百位直接DFS+高精乘，想法很简单。代码如下（看得懂就行）

 
 
 
 
```cpp
uses math;
var
  a,c:array[0..505] of longint;
  i,P:longint;
procedure multiply1;
var i,j:longint;
begin
  fillchar(c,sizeof(c),0);
  for i:=1 to a[0] do
    for j:=1 to a[0] do
    begin
      if i+j-1>501 then continue;
      c[i+j-1]:=c[i+j-1] + c[i+j-2] div 10 + a[i]*a[j];
      c[i+j-2]:=c[i+j-2] mod 10;
    end;
  if 2*a[0]-1>500 then c[0]:=500
  else c[0]:=2*a[0]-1;
  while  ( c[c[0]]>=10) and (c[0]<=500)  do
  begin
    inc(c[0]);
    c[c[0]]:=c[c[0]-1] div 10;
    c[c[0]-1]:=c[c[0]-1]  mod 10;
  end;
  if c[0]>500 then c[0]:=500;
  for i:=501 to 500 do c[i]:=0;
  a:=c;
end;
procedure multiply2;
var i:longint;
begin
  fillchar(c,sizeof(c),0);
  for i:=1 to a[0] do
  begin
    c[i]:=c[i]+c[i-1] div 10 + a[i]*2;
    c[i-1]:=c[i-1] mod 10;
  end;
  c[0]:=a[0];
  while (c[c[0]]>=10) and ( c[0]<=500) do
  begin
    inc(c[0]);
    c[c[0]]:=c[c[0]-1] div 10;
    c[c[0]-1]:=c[c[0]-1] mod 10;
  end;
  if c[0]>500 then c[0]:=500;
  for i:=501 to 505 do c[i]:=0;
  a:=c;
end;
procedure dfs(p:longint);//找数
begin
  if p=0 then
  begin
    fillchar(a,sizeof(a),0);
    a[0]:=1; a[1]:=1; exit;
  end;
  dfs(p div 2);
  multiply1;
  if p mod 2 =1 then multiply2;
end;
begin
  read(P);
  dfs(P);
  a[1]:=a[1]-1;
  writeln( trunc(log10(2)*P)+1);//公式求方案
  for i:=500 downto 1 do
  begin
    write(a[i]);
    if i mod 50=1 then writeln;
  end;
  readln;
  readln;
end.
```
其实这道题目可以打表，时间贼快，代码也就7000多B（我看了一下）（#滑稽#）
如果觉得这个方法会超的话可以试试打表。


---

## 作者：Apache553 (赞：1)

这道题基本上就是一道**快速幂**和**高精度**的模版题

幂的位数仍在int范围内所以仅仅需要使用常规的快速幂方法

高精度为了提高运算速度

这里我使用了将每8位数字看作一个整体来计算的方法 每进行一次乘法所需要的循环次数较少


附上跟HongKongInterviewer一样快的代码


```cpp
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#include<sstream>
#include<string>
#include<cstdio>

using namespace std;

typedef unsigned long long ULL;  //最大可达10^19+ 
typedef unsigned int uint;       //最大可达10^8+ 

class LongNumber{
        public:
                uint data[63];   //每一个元素管理8个10进制位 
                LongNumber(){
                        //this->data=new uint[63];
                        memset(this->data,0,sizeof(uint)*63);   //构造时初始化 
                        //Kira~
                }
                ~LongNumber(){
                        //delete[] this->data;
                }

                void clear(){
                        memset(this->data,0,sizeof(uint)*63);   //未使用的函数 
                }
                LongNumber& operator*=(const LongNumber& Number){
                        LongNumber tmp;
                        for(size_t i=62;i!=size_t(-1);--i){   //乘数循环  
                                uint &m1=this->data[i];       //m1即为乘数 
                                if(m1==0)continue;            //提速 
                                for(size_t idx=62;idx!=size_t(-1);--idx){   //被乘数循环 
                                        uint m2=Number.data[idx];    //m2即为被乘数 
                                        if(m2==0)continue;  //提速 
                                        ULL Carry=ULL(m1)*ULL(m2);    //乘积   这里强制转换为unsigned long long再相乘以避免窄化 
                                        ULL T=0;   //进位值 
                                        for(size_t IDX=idx-62+i;IDX<=62&&IDX>=0;--IDX){  //加法循环   偏移量为offset(m1)+offset(m2) 
                                                T=tmp.data[IDX]+T;   //原位置上的数+进位值 
                                                T+=Carry%100000000;  //再加上乘积的后8位 
                                                tmp.data[IDX]=T%100000000;  //当前位的值 
                                                T/=100000000;   //为加下一位做准备 
                                                Carry/=100000000;  //同 
                                                if(T==0&&Carry==0){   //提速 
                                                        break;
                                                }
                                        }
                                }
                        }
                        *this=tmp;
                        return *this;
                }

                LongNumber& operator=(const LongNumber& Number){
                        for(size_t i=0;i<63;++i){
                                this->data[i]=Number.data[i];
                        }
                        return *this;
                }
};

int main(){
        uint uexp; //次数
        cin.sync_with_stdio(false);
        cin>>uexp;
        cout<<uint(log10(2)*uexp)+1<<endl;    //数学方法计算位数 小数部分被截断，加一 

        LongNumber TMP;
        TMP.data[62]=2;
        LongNumber r;
        r.data[62]=1;

        uint x=uexp;    //快速幂 
        while(x){
                if(x&0x1){
                        r*=TMP;
                }
                TMP*=TMP;
                x>>=1;
        }

        --r.data[62];  //值减一
        
    ostringstream ss;   //输出 
        
        ss<<setw(4)<<setfill('0')<<r.data[0];
        for(size_t i=1;i<63;++i){
                ss<<setw(8)<<setfill('0')<<r.data[i];
        }
        string xt=ss.str();
        size_t couts=xt.size()-500;
        for(size_t i=0;i<10;++i){
            fwrite(&xt[couts],1,50,stdout);
            fwrite("\n",1,1,stdout);
            couts+=50;
        }

        return 0;
}
```

---

## 作者：封禁用户 (赞：1)

###p党看过来，快速幂+高精+分治，你懂得。



```cpp
**var i,j,k,l,n,m:longint;
    a,b:array[0..1001] of longint;
procedure mason1(p:longint);
var i,j,k,l,i1,j1:longint;
begin
  if p=0 then exit;
  mason1(p div 2);
  for i:=1 to 500 do
    for j:=1 to 500 do
       b[i+j-1]:=b[i+j-1]+a[i]*a[j];
  if odd(p) then
    for i:=1 to 1000 do b[i]:=b[i]*2;
  for i:=1 to 500 do
    begin
      b[i+1]:=b[i+1]+b[i] div 10;
      b[i]:=b[i] mod 10;
    end;
  for i:=1 to 500 do a[i]:=b[i];
  for i:=1 to 1000 do b[i]:=0;
end;
begin
  //assign(input,'mason.in');reset(input);
  //assign(output,'mason.out');rewrite(output);
  readln(n);
  a[1]:=1;
  //if n=0 then begin write(1);halt;end;
  writeln(trunc(n*ln(2)/ln(10))+1);
  mason1(n);
  a[1]:=a[1]-1;
  for i:=500 downto 1 do begin
    write(a[i]);
    if i mod 50=1 then writeln;end;
  //close(input);
 // close(output);
end.
```
**

---

## 作者：天狗的手帖 (赞：1)

来给各位解释一下求位数的公式

1.loga(b)的结果k表示a的k次方等于b

2.存在一个换底公式（自行百度）：loga(c)/logb(c)=logb(c)，pascal党可以通过ln（相当于是loge，e是自然底数）来实现任意底数的log

3.显然log10（k）向上取整表示k的位数

4.log的运算满足规律loga（b\*c）=loga（b）+loga（c）

5.由4得出，loga（b^c）=loga（b）\*c

所以，log10（2）\*n可以表示2^n的位数


然后快速幂搞一下就好了

```cpp

#include<cstdio>  
#include<cstring>  
#include<algorithm>  
#include<iostream>  
#include<cmath>  
  
using namespace std;  
  
struct node  
{  
    int Index[505];  
    void clear()  
    {  
        memset(Index,0,sizeof(Index));  
        return;  
    }  
};  
struct num  
{  
    node Index;  
    node operator *(const num&x)  
    {  
        node tmp;  
        tmp.clear();  
        for (int i=1;i<=500;i++)  
            for (int j=1;j<=500;j++)   
                if (i+j-1<=500) tmp.Index[i+j-1]+=Index.Index[i]*x.Index.Index[j];  
        for (int i=1;i<=500;i++)  
            if (tmp.Index[i]>=10)   
            {  
                tmp.Index[i+1]+=tmp.Index[i]/10;  
                tmp.Index[i]=tmp.Index[i]%10;  
            }  
        return tmp;  
    }  
};  
  
num Teb;  
int n;  
  
num Pow(int k)  
{  
    num tmp;  
    tmp.Index.clear();  
    tmp.Index.Index[1]=1;  
    if (k<1) return tmp;  
    if (k==1) return Teb;  
    tmp=Pow(k/2);  
    tmp=(num){tmp*tmp};  
    if (k%2) tmp=(num){tmp*Teb};  
    return tmp;  
}  
  
int main()  
{  
    scanf("%d",&n);  
    Teb.Index.Index[1]=2;  
    Teb=Pow(n);  
    Teb.Index.Index[1]--;  
      
    int ans;  
    cout<<(int)(log10(2)*n+1)<<endl;  
    ans=0;  
    for (int i=500;i>=1;i--)  
    {  
        printf("%d",Teb.Index.Index[i]);  
        ans++;  
        if (ans==50)  
        {  
            printf("\n");  
            ans=0;  
        }  
    }  
}  
  
```

---

## 作者：QWsin (赞：1)

位数用公式QAQ我也是看了题解才知道的

快速幂  注意循坏位数（到500就退出，为了保险我存了510位）

然后高精打对了就很简单了

那个神奇的常数 ==   0.3几   好像用p乘以这个数再加一  就表示2的p次幂的位数  具体请百度



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int maxn=600;
struct BIGNUM{
    int a[600],len;
    BIGNUM(){memset(a,0,sizeof(a));len=1;}
    BIGNUM operator = (const char num[])
    {
        len=strlen(num);
        for(int i=len-1;i>=0;i--)
          a[len-i-1]=num[i]-'0';
        return *this;
    }
    BIGNUM operator = (const int x)
    {
        char s[maxn];
        sprintf(s,"%d",x);
        *this=s;
        return *this;
    }
    BIGNUM (const char s[]){*this=s;}
    BIGNUM (const int x){*this=x;}
    BIGNUM operator * (const BIGNUM& rhs)
    {
        BIGNUM c;
        c.len=min(510,rhs.len+len);
        for(int i=0;i<len&&i<510;i++)
          for(int j=0;j<rhs.len&&j<510;j++)
          if(i+j+1<510)
          {
              c.a[i+j]+=a[i]*rhs.a[j];
              c.a[i+j+1]+=c.a[i+j]/10;
              c.a[i+j]%=10;
          }
        while(c.a[c.len-1]==0&&c.len>1)c.len--;
        return c;
    }
    BIGNUM operator *= (const BIGNUM& rhs){return *this=*this * rhs;}
};

BIGNUM my_pow(int n,int p)
{
    BIGNUM ret=1,tmp=n;
    while(p)
    {
        if(p&1)ret*=tmp;
        tmp*=tmp;
        p=p>>1;
    }
    return ret;
}

int main()
{
    int p;
    cin>>p;
    printf("%d\n",(int)((double)p*0.30102999+1));
    BIGNUM ans=my_pow(2,p);
    ans.a[0]-=1;
    int _=0;
    while(ans.a[_]<0)   ///用了一个鬼畜的变量名  处理退位 因为不想写高精减
    {
        ans.a[_]+=10;
        ans.a[_+1]--;
    }
    for(int i=499;i>=0;i--)
    {
        printf("%d",ans.a[i]);
        if(i%50==0) printf("\n");
    }
    return 0;
}
```（c/c++）


---

## 作者：她说123 (赞：1)

本题有两件事需要做

1.求位数，有个固定的算法：(log2/log10)\*p+1

2.计算后五百位，用分治来做不错，系需要循环到五百即可

奉上代码

   
     
    
      
      
  
     
```cpp
#include<iostream>  
#include<cstdio>  
#include<cstring>  
#include<algorithm>  
#include<cmath>  
using namespace std;  
int p,a[100002],b[520];  
void fz(int n)  
{  
    int i,j;  
  if(n==0) return;  
  fz(n/2);  
  for(i=1;i<=500;i++)  
  for(j=1;j<=500;j++)  
 if(n%2==0) a[i+j-1]=a[i+j-1]+b[i]*b[j];  
 else a[i+j-1]=a[i+j-1]+b[i]*b[j]*2;  
   for(i=1;i<=500;i++)  
  {  
    b[i]=a[i]%10;  
    a[i+1]=a[i+1]+a[i]/10;  
  }  
  memset(a,0,sizeof(a));  
}  
int main()  
{  
    int i;   
    scanf("%d",&p);  
    b[1]=1;  
    fz(p);  
    cout<<int((log(2)/log(10))*p+1)<<endl;  
    for(i=500;i>1;i--)  
   {  
     cout<<b[i];  
     if(i%50==1) cout<<endl;  
   }  
   cout<<b[1]-1<<endl;  
   return 0;  
}
```

---

## 作者：GpLee (赞：1)

一个有点像**压位**但又不太一样的算法

~~（还不是因为我不会快速幂又不会压位）~~

此算法**非常简单**

396ms惊险过关

---

`int ans[502];`

用int储存每一位（十进制）的数字。

但每个int多余的空间是用来**简并计算步数**，而不是**简并计算位数**。

一个容易想到的做法是：

```cpp
for (int i = 0; i < p; i++){
	for (int j = 0; j < 500; j++){
		ans[j] *= 2;
	}
	//整理
	for (int j = 0; j < 500; j++){
		ans[j + 1] += ans[j] / 10;
		ans[j] %= 10;
	}
}
```

但是显然这个会爆，太太太慢了。

考虑到int有大量未利用的空间，二三十次加倍还不会溢出，似乎不需要每次都大费周折整理一次，我想到了第一个优化

```cpp
	if (i % 25 == 0){
		//偶尔整理
		for (int j = 0; j < 500; j++){
			ans[j + 1] += ans[j] / 10;
			ans[j] %= 10;
		}
	}
```

然后想到了把 `ans[j] *= 2` 改为 `ans[j] = ans[j] << 1`

转念一想，既然25次才整理一次，为什么不直接把中间的移位合成一次 `ans[j] = ans[j] << 25` 呢？

然后得到了最终算法

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;

int p;
int ans[502];
//随手试出来的常数，貌似28，29也不是不行
const int STEP = 27;

int main(){
	//init
	memset(ans, 0, sizeof(ans));
	//input
	scanf("%d", &p);
	//cal Q1
	float numDigit = (float) p * log10((float)2);
	//cal Q2
	ans[0] = 1;
	int a = p / STEP, b = p % STEP;
	//大步跃进
	for (int i = 0; i < a; i++){
		//移位
		for (int j = 0; j < 500; j++){
			ans[j] = ans[j] << STEP;
		}
		//整理
		for (int j = 0; j < 500; j++){
			ans[j + 1] += ans[j] / 10;
			ans[j] %= 10;
		}
	}
	//小步逼近
	for (int i = 0; i < b; i++){
		for (int j = 0; j < 500; j++){
			ans[j] = ans[j] << 1;
		}
	}
	//整理
	for (int j = 0; j < 500; j++){
		ans[j + 1] += ans[j] / 10;
		ans[j] %= 10;
	}
	ans[0]--;
	//output
	printf("%d", (int)numDigit + 1);
	for (int i = 10; i > 0; i--){
		printf("\n");
		for (int j = i * 50 - 1; j > ((i - 1) * 50 - 1); j--){
			printf("%d", ans[j]);
		}
	}
	return 0;
}
```

还试过用 `long long` 代替 `int` 进一步缩减步数，不过貌似效果并不好。

这个算法的优势在于简单的一批，不需要任何知识储备，尤其是对我这种没学过压位的人。

时间复杂度还是O(n)，只是系数控小了点，但对付这道题已经勉强够用了。

---

## 作者：咖喱茴香 (赞：1)

本蒟蒻的第一篇题解

高精度的题目对于python简直就是福利呀 O(∩_∩)O

因为2^p不会是10的次方数，所以减1对位数没有影响

求2^p-1的位数其实就等价于求2^p次方的位数

求位数用log10(2^p)==>p*log10(2)

将结果取整加1就可以了

2^p的末尾不会是0，所以求(2^p-1)%1e500就等价于求2^p%1e500-1

上代码

```python
import math       # 引入数学模块 使用log10函数
p = int(input())  # 输入数字p
print(int(p*math.log10(2))+1)   # 输出2^p次方的长度 print(len(str(2**p)))这种方法会超时
ans = pow(2, p, 10**500) - 1    # pow(a, b, m) 为求a^b%m 
ans = '%0500d' % ans    # 将数字转换为长度为500的字符串，前置0
for i in range(10):     # 循环10次
    print(ans[i*50:i*50+50])   # 切片输出
```



---

## 作者：Fancy_G_wanna_fly (赞：1)

翻了所有题解发现没有写Java的，虽然本蒟蒻是写c++的，但是大数模板是真不会敲orz......

那么问题来了，为什么要选择Java呢，因为Java有自带的**BigInteger**来省去了我敲大数模板，没了大数这个障碍，这题就简单多了。


------------

话不多说，开始上题解。

第一问是求位数，由题目所要求的数为2^p-1来说，我发现2^p末尾只可能是2  4  6  8，减一后不会出现借位的情况，所以我们可以省去借位的特殊情况。我们可以通过一定手段发现，2^p-1恰好是p-1位的二进制数的最大值，将二进制转化为十进制，位数的变化为**p*log10(2)+1**~~<蒟蒻不会证明所以是打表+瞎猜的>~~。

第一问解决，第二问注意一下需不需要前导零，用好大数，快速幂稍微取模弄一下就解决了。

毕竟写c++的蒟蒻有好多Java的东西还不太清楚，所以也就凑合着看吧emmmmm......
```java
/*********************
*Author: Fancy_Gemini*
**********************/
import java.math.*;
import java.util.*;
public class Main {
	static Scanner sc=new Scanner(System.in);
	final static BigInteger MOD=BigInteger.TEN.pow(500),Mod=new BigInteger("2");
	static BigInteger qpow(int b) {//快速幂不用解释了吧......写得比较奇怪
		BigInteger res=BigInteger.ONE,base=Mod;
		while(b!=0) {
			if(b%2!=0) res=res.multiply(base);
			base=base.multiply(base);
			res=res.mod(MOD);base=base.mod(MOD);
			b>>=1;
		}
		res.mod(MOD);
		return res;
	}
	//据说有内置方法但是我并不清楚orz
	public static void main(String[] args) {//主函数
		int p;
		p=sc.nextInt();
		BigInteger s=qpow(p).subtract(BigInteger.ONE);
		System.out.println((int)(p*Math.log10(2)+1));//求位数
//		System.out.println(s);
		for(int i=499;i>=0;i--) {//求末500位数
			if(i%50==0) {
				if(s.divide(BigInteger.TEN.pow(i)).mod(BigInteger.TEN)==BigInteger.ZERO) System.out.println("0");
				else System.out.println(s.divide(BigInteger.TEN.pow(i)).mod(BigInteger.TEN));
			}
			else {
				if(s.divide(BigInteger.TEN.pow(i)).mod(BigInteger.TEN)==BigInteger.ZERO) System.out.print("0");
				else System.out.print(s.divide(BigInteger.TEN.pow(i)).mod(BigInteger.TEN));
			}
		}
	}
}

```

好久没写题解了......

---

## 作者：邱江坤 (赞：0)

这道题分两部分：求$2^n-1$的位数和最后500位

第一问为数学题，即求$\lceil \log_{10}(2^n-1)\rceil$：

首先由于质因子没有5，$2^n$的末尾一定不会是0

所以$(2^n-1) \mod 10 \neq 0$

所以$\forall n \in \mathbb{N}^+, \log_{10}(2^n-1)=log_{10}2^n=n\log_{10}2 = n\log2/\log {10}$

第二部分，写一个高精乘法，模拟竖式运算即可。记得保存前500位。运算过程中可能会涉及到第1001位，所以数组尽量开大一些，我开了201，每个能存5位，实际能保证500位的乘法不会导致溢出（更严重的因是下标溢出而RE）。

由于高精乘法的时间复杂度是$O(l^2)$，以线性时间来做会TLE。所以需要写一个快速幂，参考代码（应该是实现最简洁的代码了）。总的时间复杂度为$O(l^2\log n)$
```cpp

#include <bits/stdc++.h>
using namespace std;

namespace my
{
	struct bint
	{
		static const int MOD = 100000, LMOD = 5;
		long long a[210];
		int len()const
		{
			return min(100ll, a[0]);
		}
		bint ( int i )
		{
			memset ( a, 0, sizeof a );
			a[0] = 1;
			a[1] = i;
			//make sure i < MOD^2
			while ( a[1] >= MOD )
				a[1] -= MOD, ++a[2], a[0] = 2;
		}
		bint &operator= ( const bint &r )
		{
			memcpy ( this, &r, sizeof * this );
			return *this;
		}
		bint &operator += ( const bint &r )
		{
			for ( int i = 1; i <= max ( len(), r.len() ); ++i )
			{
				a[i] += r.a[i];
				while ( a[i] >= MOD )
					a[i] -= MOD, ++a[i + 1], a[0] = i + 1;
			}
			return *this;
		}
		bint &operator -= ( int n )
		{
			a[1] -= n;
			int i = 1;
			while ( a[i] < 0 )
				a[i] += MOD, --a[i + 1], ++i;
			return *this;
		}
		bint &operator *= ( int r )
		{
			int jin = 0;
			for ( int i = 1; i <= len(); ++i )
			{
				a[i] = a[i] * r + jin;
				jin = a[i] / MOD;
				a[i] %= MOD;
			}
			if(jin and a[0] < 100)
				a[++a[0]] = jin;
			return *this;
		}
		friend bint operator * ( const bint &ll, const bint &rr)
		{
			bint rst = 0;
			rst.a[0] = min(100, ll.len() + rr.len() - 1);
			for (int i = 1; i <= ll.len(); ++i)
			{
				for (int j = 1; j <= rr.len(); ++j)
				{
					rst.a[i + j - 1] += ll.a[i] * rr.a[j];
					if (rst.a[i + j - 1] >= MOD)
						rst.a[i+j] += rst.a[i + j - 1] / MOD,
						 rst.a[i + j - 1] %= MOD,
						 rst.a[0] = min(100, max(rst.len(), i + j));

				}
			}
			return rst;

		}
		friend ostream &operator<< ( ostream &os, const bint &r )
		{
			char buf[16];
			for ( int i = 100; i; --i )
			{
				sprintf ( buf, "%0*lld", LMOD, r.a[i] );
				os << buf;
				if(i % 10 == 1)
					os << "\n";
			}
			return os;
		}
#undef len
	};

	bint qpow(bint a, int b)
	{
		bint r = 1;
		do{
			if (b&1)
				r = r * a;
			a = a * a;
			//cout << r << " " << a << endl;
		}
		while(b>>=1);
		return r;
	}
	void main()
	{
		bint num = 2;
		int n;
		cin >> n;
		num = qpow(num, n);
		num -= 1;
		cout << ceil(n / log(10) * log(2)) << endl;

		cout << num << endl;

	}

}
int main()
{
#ifdef LOCAL
	freopen ( "./input.txt", "r", stdin );
#endif
	ios::sync_with_stdio(false);
	cin.tie(0);
	my::main();
	return 0;
}

```

---

## 作者：zymzym (赞：0)

刚写了一道麦森数 还不太熟练 理一下思路 顺便也帮帮看到这道题的人


------------


首先 麦森数需要算位数 公式不是很难 属于数学问题

m的n次方 len=n\*log10(m)+1


第二点 就是高精度快速幂

通常的写法是把ans\*=a与a\*=a写成函数 用高精度乘法



```cpp
    void ch(int a[],int b[])
    {
        CLR(c,0)//中转数组
        //此处高精度乘，用c数组运算
        //再将算好的c数组赋值给a数组 也就是答案数组
    }
```
个人认为这里要注意全局定义的数组与函数内定义的数组的关系
建议将快速幂写在主函数里 避免自己绕晕 ~~反正我是晕了~~


举个例子吧 主函数里写的是ch(ans,a) 那么ch函数中的a数组就是主函数中的ans数组

最后也是输出ans就好了



刚刚我换了一种写法 把快速幂写在函数里 发现头脑清醒的话也没那么难

贴一下代码吧





```cpp
    void ch(int a[],int b[])
    {
        CLR(c,0);
        REP(i,1,501) REP(j,1,501)
        {
            c[i+j-1]+=a[i]*b[j];
            c[i+j]+=c[i+j-1]/10;
            c[i+j-1]%=10;
        }
        REP(i,1,501) a[i]=c[i];
    }
    void poww(int aa[],int p)
    {
        ans[1]=1;
        while(p)
        {
            if(p&1) ch(ans,aa);
            ch(aa,aa);
            p>>=1;
        }
    }

```

---


# 【MX-X1-T2】「KDOI-05」简单的有限网格问题

## 题目背景

原题链接：<https://oier.team/problems/X1B>。

## 题目描述

小 S 在玩一款小游戏。游戏中会有一个 $n\times m$ 的棋盘，其中 $k$ 个位置上有星星。初始有一个捕捉器，在 $(x,y)$ 位置。每次操作，你可以将捕捉器移动到同行或同列的某个位置，使得新位置与原位置不同且必须保证新位置 $(x',y')$ 满足 $1\leq x'\leq n$，$1\leq y'\leq m$。**捕捉器会捕捉 $(x,y)$ 到 $(x',y')$ 路径上所有的星星**。一个星星被捕捉后将会消失。

游戏的目标是在恰好两步内获得尽可能多的星星，然而小 S 不会玩，于是每次就会随意挑选一个可以移动到的新位置进行移动。对于 $(n+m-2)^2$ 种小 S 的不同移动方案，求捕捉到的星星数量之和，答案对 $10^9+7$ 取模。

## 说明/提示

**【样例解释 \#1】**

网格图中，一种合法的移动捕捉器的方案是：

$$(2,2)\to(1,2)\to(1,3)$$

在该方案中，可以捕捉到位置在 $(1,2)$ 和 $(1,3)$ 的各 $1$ 颗星星。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | $m\leq$ |
|:--:|:--:|:--:|:--:|
| $1$ | $5$ | $50$ | $50$ |
| $2$ | $10$ | $1000$ | $1000$ |
| $3$ | $20$ | $10^5$ | $10^5$ |
| $4$ | $25$ | $10^5$ | $10^9$ |
| $5$ | $25$ | $10^9$ | $10^9$ |
| $6$ | $15$ | $10^{18}$ | $10^{18}$ |

对于 $100\%$ 的数据，$1\leq k\leq10^5$，$1\leq n,m\leq10^{18}$，$1\leq x,p\leq n$，$1\leq y,q\leq m$，$(x,y)\neq(p,q)$。

## 样例 #1

### 输入

```
3 3 4
2 2
1 1
1 2
1 3
3 1
```

### 输出

```
11```

## 样例 #2

### 输入

```
5 8 9
2 7
1 7
2 2
4 7
4 5
4 7
2 8
5 2
1 7
1 7```

### 输出

```
153```

# 题解

## 作者：WZWZWZWY (赞：16)

啊吧啊吧，被打回了。原因是“大数字应使用科学计数法表示”，于是我改成了 $mod=10^9+7$。（~~话说 $1e9+7$ 不是科学计数法吗？~~）
 


------------


![](https://cdn.luogu.com.cn/upload/image_hosting/40ihs8f1.png)

从下往上看↑（真实事件未改编）

------------

### 题意避坑

这道题坑也是非常的多。

#### 一：

> ~~目标是在恰好两步内获得尽可能多的星星~~，**然而小 S 不会玩**，于是每次就会**随意挑选**一个可以移动到的新位置进行移动。


前一句话我给她划掉了，**因为这是误导句**。后面一句才是重点，千万不要用正常人玩游戏的思维！

小 S 随意移动。

+ **不需要**找尽可能多的星星。

#### 二：

> 每次操作，你可以将**捕捉器移动到同行或同列的某个位置**，使得**新位置与原位置不同**且必须保证新位置 $(x',y')$ 满足 $1\leq x'\leq n$，$1\leq y'\leq m$。**捕捉器会捕捉 $(x,y)$ 到 $(x',y')$ 路径上所有的星星**。一个星星被捕捉后将会消失。

+ 也就是说，你每次可以**上下左右移动任意格**，就像象棋里的车。但是每次**必须移动，移动两次**。这路上经过的所有星星都会被吃掉。

比如可以这么移动：

$$(1,1)\to(1,2)\to(1,3)$$

这就算两步。是一个方向也可以。（因为小 S 不会玩啊，随意移动）

那么小 S 还可以有什么操作呢？

初始点 $(1,2)$，有星星的点 $(1,3)$。

$$(1,2)\to(1,1)\to(1,3)$$

$$(1,2)\to(1,3)\to(1,1)$$

都可以。

还有，注意到新位置 $(x',y')$ 满足 $1\leq x'\leq n$，$1\leq y'\leq m$。也就是说：

+ 地图的最小坐标是 $(1,1)$，而不是 $(0,0)$。

#### 三：

> $(x,y)\neq(p,q)$

$(x,y)$ 是初始点，$(p,q)$ 是有星星的点。也就是说：

+ 初始点上不会有星星。

#### 四：

> 每个位置上可以有多颗星星。

就在“输入格式”里，原话……

目前只记得这些，还有什么容易踩到的坑，欢迎在评论区交流！


------------


### 样例解释

很多人第一个样例都只找到了共 $10$ 颗星星的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/hoovszza.png)

（左边是路径，右边是可以得到的星星数，忽略没有星星的路径。这里少了一条。）

剩下一条，看了上面“避坑”，你应该能找到。

$$(2,2)\to(3,2)\to(1,2)$$

得到 $1$ 颗星星。所有路径总共 $11$ 颗。



------------

### 思路


对于**每一颗星星**，计算初始点到它的路径数量 $cnt$。最后累加 $cnt$ 计入答案。



------------

### 推导式子

![](https://cdn.luogu.com.cn/upload/image_hosting/b1vcgosk.png)

~~用电脑绘图累死我了，还不快点个赞！~~

当在同一行或同一列时，拿 $p<x,q=y$ 举例：

首先，第一步只能向左走，对吧？否则两步到不了 $(p,q)$。

若从 $(x,y)$ 第一步走到 $(p,q)$ ，可以上下左右移动任意步（但步数 $>0$，$1\le x'\le n$，$1\le y'\le m$），所以总共有 $(n-1+m-1)$ 种结果。

也可以第一步向左超过 $(p,q)$，这时第二步也是上下左右任意移动,$(n-1+m-1)$ 种结果。

若第一步没有走到 $(p,q)$，或者先向右走，那么第二步必须走到 $(p,q)$，或者超过 $(p,q)$，才能吃到它，总共有 $(n-p-1)\times (p-1)$ 种结果。

那么加起来就有 $(n+m-2 + n-p-1) \times p$ 种结果。

其它三个方向（上、右、下）同理。



------------


![](https://cdn.luogu.com.cn/upload/image_hosting/kn72imgb.png)

不在同一行或同一列。

拿这个图举例。

显然，有两种路径到达 $(p,q)$，分别是 $(x,y)\to(p,y)\to(p,q)$ 和 $(x,y)\to(x,q)\to(p,q)$。

这个时候已经用了“两步”了，不可能再转向。但是——这个时候最后一步可能没有走完，可以继续往前走。

可以 $(x,y)\to(p,y)\to(p,1)$。

那么显然地，最后一步向下的方案数为 $q$，向左的方案数为 $p$。

总的方案数是 $p+q$。

其他方向同理。


------------

### 代码

**忠告**：$mod=10^9+7$ 不要取错。每次乘法都要取模。$1\leq n,m\leq10^{18}$，不开 `long long` 见祖宗。

（考场代码，保险起见都加上了取模。可能稍微合并了一些公式。）

```cpp
cin >> p >> q; // 每个星星的横、纵坐标
int cnt = 0;
if (p < x) { // 横坐标比初始点横坐标小
	if (q < y) cnt = p % mod + q % mod; // 纵坐标比初始点小
	if (q > y) cnt = (m-q+1) % mod + p % mod; // 纵坐标比初始点大
	if (q == y) cnt = (n+m-2 + n-p-1) % mod * (p % mod) % mod; // 纵坐标相等
} else if (p > x) {
	if (q < y) cnt = q % mod + (n-p+1) % mod;
	if (q > y) cnt = (m-q+1) % mod + (n-p+1) % mod;
	if (q == y) cnt = (n-p+1) % mod * ((n+m-2 + p-2) % mod);
} else { // 横坐标相等
	if (q > y) cnt = (m-q+1) % mod * (((n+m-2) % mod + q-2) % mod);
	else cnt = q % mod * ((m+n-2 + m-q-1) % mod);
}
ans += cnt;
```

还有什么不懂的或者想吐槽的可以在评论区讨论。

---

## 作者：letianJOE (赞：7)

## 思路

$n$ 和 $m$ 很大，即使是 $O(n)$ 或 $O(m)$ 都会 TLE。

所以对地图来做很明显是不行的。

那么我们考虑以 $k$ 为基数，也就是对每个星星讨论捕捉器有几个到它的方法，这样对于每一个星星的方法加起来就是答案了。

---

## 实现

我们可以分类讨论一下。

首先我们把星星分为两类，一类是和捕捉器在同一行或者同一列的，一类是行列都不相同的。

### 第一类

那么对于这一类，因为可以走两步，所以我们有两种方法:

1. 先吃星星在到其它地方。

2. 先到其它地方在吃星星。

### 第二类

第二类因为行列都不同，所以两步肯定是一个上下走、一个左右走。

那所以还是有两种方法:

1. 先走上下，再走左右。

2. 先走左右，再走上下。

---

## 答案

我们可以把他们细分成八个部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/wqj6x6tl.png)

可以自己对星星在这八个部分的情况自己先想一下。

**要注意只要经过星星就可以拿到星星。**

这里给出不同部分的答案，可以自己写完再来对，不要直接看。

$a$ 为星星的行，$b$ 为星星的列。

$x$ 为捕捉器的行，$y$ 为捕捉器的列。

$n$ 为地图的行，$m$ 为地图的列。

对于各个颜色的答案：

- 绿色：$a+b$

- 浅蓝：$(n-a-1)a+(n+m-2)a$

- 深蓝：$a+(m-b+1)$

- 灰色：$(m-b-1)b+(n+m-2)b$

- 棕色：$(b-2)(m-b+1)+(m-b+1)(n+m-2)$

- 橙色：$(n-a+1)+b$

- 红色：$(n-a+1)+(m-b+1)$

---

## 警钟长鸣

不开 long long 见祖宗!

每做一次运算就要 $\bmod$ 一下。

---

## 作者：Zskioaert1106 (赞：6)

这题还能交题解啊，那我修缮一下我的早期题解吧。

***

题目传送门：[P10714【MX-X1-T2】「KDOI-05」简单的有限网格问题](https://www.luogu.com.cn/problem/P10714)

### 题意分析

由于题目让我们求的是全部的 $(n+m-2)^2$ 种情况下，能捕捉到的星星数量之和，又因为题目给的 $n,m$ 非常大（$10^{18}$），所以我们可以考虑研究每一颗星星能被捕获的方案数。

我们可以以捕捉器初始位置 $(x,y)$ 为原点建立一个平面直角坐标系，以样例 1 为例：（$△$ 表示捕捉器位置， $☆$ 表示星星位置，由于~~我懒直接用表格~~所以用格子来代替坐标系里的点）
| $☆$ |  | $☆$ |
| -----------: | -----------: | -----------: |
| $☆$ | $△$ |  |
| $☆$ |  |  |

因此我把星星的位置分成了三种情况：在象限内、在横轴上和在纵轴上。

### 分类讨论

#### 象限内

如果格子在象限内，那么至少需要 $2$ 步才能捕获到星星。而我们第一步就要将捕捉器的横坐标移到 $p$ 或纵坐标移到 $q$。

之后要保证碰到星星，那么捕捉器可以到达从星星到边缘的任意一个整点。从星星在相对于捕捉器的位置来看，即有



|位置|方案数|
|:-:|:-:|
|在左侧|$p$|
|在右侧|$n-p+1$|
|在下侧|$q$|
|在上侧|$m-q+1$|

同时左右与上下并不矛盾。

我们就能得到如下判断代码：

```cpp
if (p<x) s += p;
else s += n-p+1;
if (q<y) s += q;
else s += m-q+1;
```
#### $y$ 轴上

当星星在坐标系的 $y$ 轴上，即与捕获器的横坐标相等——$x=p$ 时，那捕获器的第一步就**必须**垂直移动：如果第一步使 $x\neq p$，那第二步仅凭一步是无法将星星捕获的。

如果第一步捕获了该星星，根据上文可得知有 $q$ 或 $m-q+1$ 种可能性。那第二步就可以去任意一个可以移动到的新位置了。如果第二步水平移动，共有 $n-1$ 种可能；如果垂直移动，共有 $m-1$ 种可能。即
| $q<y$ | $(n-1+m-1)\cdot q\Rightarrow(n+m-2)\cdot q$ |
| -----------: | :----------- |
| $q>y$ | $(n-1+m-1)(m-q+1)\Rightarrow(n+m-2)(m-q+1)$ |

如果第一步没有捕获星星，且捕捉器仍然与星星处于同一横坐标，那就有 $m-q-1$ 或 $m-(m-q+1)-1$ 种可能。比上文多减的 $1$ 是捕捉器原位置，因为 _你可以将捕捉器移动到同行或同列的某个位置，使得新位置与原位置不同_ 。

而这样第二步就需要去捕获星星，与上文相同有 $q$ 或 $m-q+1$ 种可能。  
即：
| $q<y$ | $(m-q-1)\cdot q$ |
| -----------: | ----------- |
| $q>y$ | $(m-q+1)[m-(m-q+1)-1]\Rightarrow(m-q+1)(q-2)$ |

然后将两种可能性相加，得到

| $q<y$ | $q\cdot(2m+n-3-q)$ |
| -----------: | ----------- |
| $q>y$ | $(m-q+1)(n+m+q-4)$ |

代码：
```cpp
if(q<y) s += q*(m*2+n-3-q);
else s += (m-q+1)*(n+m+q-4);
```
#### $x$ 轴上

类似地，我们有 $y=q$ 时的判断：
| $p<x$ | $p\cdot(2n+m-3-p)$ |
| -----------: | ----------- |
| $p>x$ | $(n-p+1)(n+m+p-4)$ |

#### 一种特殊情况

如果星星的位置与捕捉器重合，那这 $(n+m-2)^2$ 种路径每种都可以捕获星星。不过题目数据中没有出现这种情况。

### 代码编写

将以上情况汇总，就可以编写出代码了。

```cpp
#include<iostream>
using namespace std;
int main(){
	long long n,m,x,y,s=0,p,q;
	int k;
	cin>>n>>m>>k>>x>>y;
	while(k--){
		cin>>p>>q;
		if(p==x&&q==y)s+=(n+m-2)*(n+m-2);
		else if(p==x){
			if(q<y)s+=q*(m*2+n-3-q);
			else s+=(m-q+1)*(n+m+q-4);
		}
		else if(q==y){
			if(p<x)s+=p*(n*2+m-3-p);
			else s+=(n-p+1)*(n+m+p-4);
		}
		else{
			if(p<x)s+=p;
			else s+=n-p+1;
			if(q<y)s+=q;
			else s+=m-q+1;
		}
	}
	cout<<s;
	return 0;
}
```

当然直接这么干是得不到分的，因为它不仅需要取模，而且还会爆 long long。

#### 最终代码

```cpp
#include<iostream>
using namespace std;
const long long mod=1000000007;
int main(){
	long long n1,m1,x1,y1,s=0,p1,q1;
	int k;
	cin>>n1>>m1>>k>>x1>>y1;
	__uint128_t n=n1,m=m1,x=x1,y=y1,p,q;
	while(k--){
		cin>>p1>>q1;
		p=p1;
		q=q1;
		if(p==x&&q==y)s+=(n+m-2)*(n+m-2);
		else if(p==x){
			if(q<y)s+=q*(m*2+n-3-q)%mod;
			else s+=(m-q+1)*(n+m+q-4)%mod;
		}
		else if(q==y){
			if(p<x)s+=p*(n*2+m-3-p)%mod;
			else s+=(n-p+1)*(n+m+p-4)%mod;
		}
		else{
			if(p<x)s+=p;
			else s+=n-p+1;
			s%=mod;
			if(q<y)s+=q;
			else s+=m-q+1;
		}
	}
	cout<<s%mod;
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/164437454)。感谢您的观看。

---

## 作者：Louis_lxy (赞：5)

一道贼多细节的题目。
## 思路
其实很简单，就是分类讨论。

1. $p\ne x$ 且 $q \ne y$：有两种方法，要么第一步让 $p=x$，要么第一步让 $q=y$。然后分类计数即可。
2. $p=x$ 且 $q \ne y$：有两种方法，要么第一步得到星星，要么第二步得到星星。
3. $p\ne x$ 且 $q = y$：同样有两种办法，要么第一步的到星星，要么第二步得到星星，与第二类相似。

**注意事项：要多取模，然后记得分类要写好。~~我考场就是这么爆 0 的。~~**
## 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n, m, k, x, y, xx, yy, ans;
	scanf("%d %d %d %d %d", &n, &m, &k, &x, &y);
	for (int i = 1; i <= k; ++i)
	{
		scanf("%d %d", &xx, &yy);
		if (xx != x && yy != y)
		{
			if (xx < x) ans += xx;
			else ans += n - xx + 1;
			if (yy < y) ans += yy;
			else ans += m - yy + 1;
		}
		else if (xx == x)
		{
			if (yy < y) ans += yy * (n + m - yy - 3 + m);
			else ans += (m - yy + 1) * (n + m + yy - 4);
		}
		else
		{
			if (xx < x) ans += xx * (n + n - xx - 3 + m);
			else ans += (n - xx + 1) * (n + m - 4 + xx);
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：sxq9 (赞：4)

## 题目含义
就是输入若干个星星，然后问你所有的路径能吃到的星星总和。仔细理解！我比赛时没看清楚导致浪费了三十分钟。

## 题目简化
我们知道，如果爆搜所有路径，必定会超时，而且超不止一点。所以我们要换个角度思考。

我们从星星的角度思考，因为我们知道，虽然地图很大，但是星星很少，有很多路没有星星，浪费时间，所以只要遍历每个星星，算出这个星星会被拿到几次，相加即可。

## 实现

我们来分类讨论一下：

我们的初始坐标将整个地图划分为了八个区域（数从左向右增加，从下向上增加）。

![](https://cdn.luogu.com.cn/upload/image_hosting/t6hfkmx0.png)

所以我们需要讨论八次？

不，其实我们发现，红色、黄色、绿色、蓝色，它们其实区别较小，只是代码存在区别；同理，其他四个区域也差不多。

所以我们只需要讨论两种情况。

### 第一种（四个角）

以绿色为例，假如星星在这个地方：

![](https://cdn.luogu.com.cn/upload/image_hosting/10c64fay.png)

那么我们到达它的路径有几种呢？

显然，有两类。

一类是从纵向到达：

![](https://cdn.luogu.com.cn/upload/image_hosting/khyvnzwb.png)

这种情况来的路径已经确定了，但是有可能吃到之后还会走，一共有这么多种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/txjjgpon.png)

一类是从横向到达：

![](https://cdn.luogu.com.cn/upload/image_hosting/cuxzgn45.png)

这样来的路径也是确定的，到达的地方有这么多情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/7opxo1wb.png)

那么在四周的星星就愉快的解决了！

代码（未取模）：

```cpp
if(a<x&&b<y)s+=(a+b);//绿色
else if(a<x&&b>y)s+=(a+m-b+1);//蓝色
else if(a>x&&b<y)s+=(n-a+1+b);//黄色
else if(a>x&&b>y)s+=(n-a+1+m-b+1);//红色
```

### 第二种（有相同的横或纵坐标）

以紫色为例。

![](https://cdn.luogu.com.cn/upload/image_hosting/lrea6y36.png)

那么到达它的路径也有两类：

第一类是先到星星再去别的地方：

这时，来的路径没确定，有这几种：

![](https://cdn.luogu.com.cn/upload/image_hosting/7d17wqzc.png)

去的路径也没确定，有这几种（以刚好到星星为例，其他相同）：

![](https://cdn.luogu.com.cn/upload/image_hosting/iaobahgj.png)
 
最后将两种方案数相乘。 

第二类是先到别的地方再到星星：

这时，第一步路径有这么多：

![](https://cdn.luogu.com.cn/upload/image_hosting/qndidznb.png)

第二步路径有这么多：

![](https://cdn.luogu.com.cn/upload/image_hosting/g03hoysx.png)

代码（未取模）：
```cpp
else if(a==x&&b<y)s+=(b*(m+n-2)+(m-b-1)*b);
else if(a==x&&b>y)s+=((b-2)*(m-b+1)+(m-b+1)*(m-1)+(m-b+1)*(n-1);
else if(a<x&&b==y)s+=(a*(n-1)+(n-a-1)*a+a*(m-1));
else if(a>x&&b==y)s+=((a-2)*(n-a+1)+(n-a+1)*(n-1)+(n-a+1)*(m-1));
```

难道就这么愉快地结束了吗？

不，要取模。

### 注意事项（八十五分的看过来）

1. 减法之前要先加模数，不然可能会变成负数。
1. 一定要做一步模一步。

如果你没注意，那么喜提八十五分。

### 完整代码

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
int main(){
	long long n,m,x,y,k,a,b,s=0;
	cin>>n>>m>>k>>x>>y;
	for(long long i=1;i<=k;i++){
		cin>>a>>b;
		if(a<x&&b<y)s=((s+a%mod)%mod+b%mod)%mod;
		else if(a<x&&b>y)s=(((s+a%mod)%mod+m%mod)%mod+mod-b%mod+1)%mod;
		else if(a>x&&b<y)s=((s+n%mod)%mod+mod-a%mod+1+b%mod)%mod;
		else if(a>x&&b>y)s=(((s+n%mod)%mod+mod-a%mod+1+m%mod)%mod+mod-b%mod+1)%mod;
		else if(a==x&&b<y)s=(((s+(b%mod*((m-1)%mod))%mod)%mod+((m-b-1)%mod*(b%mod))%mod)%mod+(b%mod*((n-1)%mod))%mod)%mod;
		else if(a==x&&b>y)s=(((s+((b-2)%mod*((m-b+1)%mod))%mod)%mod+((m-b+1)%mod*((m-1)%mod))%mod)%mod+(m-b+1)%mod*((n-1)%mod)%mod)%mod;
		else if(a<x&&b==y)s=(((s+(a%mod*((n-1)%mod))%mod)%mod+((n-a-1)%mod*(a%mod))%mod)%mod+(a%mod*((m-1)%mod))%mod)%mod;
		else if(a>x&&b==y)s=(((s+((a-2)%mod*((n-a+1)%mod))%mod)%mod+((n-a+1)%mod*((n-1)%mod))%mod)%mod+(n-a+1)%mod*((m-1)%mod)%mod)%mod;
	}
	cout<<s%mod;
	return 0;
}
```

---

## 作者：lihongru (赞：3)

### 题目分析

计算机每秒大约能处理 $4 \times 10^8$ 数量级的数据。

题目中由于 $n, m$ 有 $10^{18}$，对地图的处理一定会超时。而 $k$ 只有 $10^5$，所以我们将问题从枚举所有方案转化为直接求每个星星被计算的次数（即被多少路线经过）。

以下将捕捉器看作“起始点”，将星星看作“目标点”。

对于每个目标点可能出现以下两种情况：

1. 目标点与起始点没有共同轴。
2. 目标点与起始点有共同轴（即目标点 $x, y$ 坐标有任意一个与起始点相同）。

### 处理第一种情况

以左上角举例，第一种情况中如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/9fl66hz9.png)

**没有共同轴意味着只可能走两步到达。** 经过 $(p, q)$ 只可能出现橙色线或者绿色线的情况，其中画黑框的部分可能为两次走完的结束点（当然，作为结束点前提要求是经过点 $(p, q)$）。

目标点为 $(p, q)$，所以橙色线在黑框内有 $q$ 个点（橙色线结束点有 $q$ 种可能），绿色线在黑框内有 $p$ 个点（绿色线结束点有 $p$ 种可能），那么位于起始点左上的目标点的被计算次数就为 $p + q$（所有位于起始点左上的目标点均为此计算方案）。这个规律只有目标点在起始点左上方时才生效，要把剩下三个方向（右上，左下，右下）通过类似的办法推算出来。

$(p, q)$ 重复计算为何不减 $1$？因为以 $(p, q)$ 为结束点的**是两种情况**，走的路线不同即视为不同路线。

不难发现计算次数的规律：**两条路线过 $(p, q)$ 的延伸线上点的个数。** 可以按照这样的方法继续推。下图中为了区分每个点将点编号，不影响结论。

![](https://cdn.luogu.com.cn/upload/image_hosting/jw9els62.png)

推出的结论如下表：

| 位置（起始点） | 橙线剩余点数 | 绿线剩余点数 | 该点计算次数 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 左上 | $q$ | $p$ | $p+q$ |
| 右上 | $q$ | $n-p+1$ | $(n-p+1)+q$ |
| 左下 | $m-q+1$ | $p$ | $p+(m-q+1)$ |
| 右下 | $m-q+1$ | $n-p+1$ | $(n-p+1)+(m-q+1)$ |

处理代码逻辑可以简化为：

当 $p \not = x$ 且 $q \not = y$ 时： 

- 当 $p < x$ 时，答案增加 $p$，否则答案增加 $n-p+1$。

- 当 $q < y$ 时，答案增加 $q$，否则答案增加 $m-q+1$。


处理代码片段如下：

```cpp
if (p != x && q != y) {
    if (p < x) ans = (ans + p) % MOD;
    else ans = (ans + n - p + 1) % MOD;
    if (q < y) ans = (ans + q) % MOD;
    else ans = (ans + m - q + 1) % MOD;
}
```

### 处理第二种情况

我们到这里非常难像第一种方案那样分析有多少条路线到答目标点，但是此处有一个规律：接下来能走的点的方案数与能经过目标点的路线数相等。所以我们将此处的问题转化为求接下来能走到的点的方案数。

因为所有点接下来能走到的点的个数是一样的，所以为了方便计算，我们只计算刚好到达 $(p, q)$ 点的路线个数，再乘上所有满足“走到该点就能经过目标点”的点的个数即可。其实这里乘的系数与第一种情况类似，是线路的延长线上的点的个数。

依然还是分类讨论，有 $2$ 种情况：

1. 走了 $1$ 步经过目标点。
2. 走了 $2$ 步经过目标点。

其中走了 $2$ 步经过目标点仅有第一步走完可能停留的中间点个数种可能刚好到达点 $(p, q)$，而走 $1$ 步接下来又会分为 $2$ 种情况：

1. 移动到目标点 $x$ 轴上的任意一点（除了目前所在点）。
2. 移动到目标点 $y$ 轴上的任意一点（除了目前所在点）。

#### 处理 $1$ 步走到目标点的情况

先以 $p = x, q < y$ （在正上方）举例：

![](https://cdn.luogu.com.cn/upload/image_hosting/ui0lh5dy.png)

绿线上有 $n-1$ 种可能，橙线上有 $m-1$ 种可能，加起来就是 $1$ 步走到的答案。

#### 处理 $2$ 步走到目标点的情况

还是以 $p = x, q < y$ （在正上方）举例：

第一步走完后，中间点共有 $m - q - 1$ 种可能（由 $m - q + 1 - 2$ 化简得来：目标点与起始点不能作为中间点，其它下面的点都可以），此处的答案就是可能为中间点的点的个数。

#### 合并

上面的单独处理推出来的还是只对正上方有效，所以还要接着推，我的结论如下表：

| 位置（起始点） | 系数（路线延伸点数） | $1$ 步（$x$ 轴） | $1$ 步（$y$ 轴） | $2$ 步 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 上 | $q$ | $n - 1$ | $m - 1$ | $m - q - 1$ |
| 下 | $m - q + 1$ | $n - 1$ | $m - 1$ | $q - 2$ |
| 左 | $p$ | $n - 1$ | $m - 1$ | $n - p - 1$ |
| 右 | $m - p + 1$ | $n - 1$ | $m - 1$ | $p - 2$ |

处理代码片段如下，其中 $s$，$r$ 分别代表走 $1$ 步移动到 $x, y$ 轴的可能路线数，$e$ 代表走 $2$ 步的可能路线数：

```cpp
LL s, r, e;
if (p == x) {
    if (q < y) {
        LL xs = q % MOD;
        s = xs * ((n - 1) % MOD) % MOD;
        r = xs * ((m - 1) % MOD) % MOD;
        e = xs * ((m - q - 1) % MOD) % MOD;
    }
    else {
        LL xs = (m - q + 1) % MOD;
        s = xs * ((n - 1) % MOD) % MOD;
        r = xs * ((m - 1) % MOD) % MOD;
        e = xs * ((q - 2) % MOD) % MOD;
    }
} 
if (q == y) {
    if (p < x) {
        LL xs = p % MOD;
        s = xs * ((n - 1) % MOD) % MOD;
        r = xs * ((m - 1) % MOD) % MOD;
        e = xs * ((n - p - 1) % MOD) % MOD;
    }
    else {
        LL xs = (n - p + 1) % MOD;
        s = xs * ((n - 1) % MOD) % MOD;
        r = xs * ((m - 1) % MOD) % MOD;
        e = xs * ((p - 2) % MOD) % MOD;
    }
}
ans = (ans + s) % MOD;
ans = (ans + r) % MOD;
ans = (ans + e) % MOD;
```

### 题目总结与参考代码

本题考查分类讨论，需要绕明白每个星星应该如何处理，如果是什么情况怎么办。题目说可能会有重合，但我的思路是根据输入的星星位置来考虑（并不是点），所以不受影响。**一定要注意开 `unsigned long long` 和取模运算。**

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long LL;
const int MOD = 1e9 + 7;

LL n, m, k, x, y, ans;

int main(){
    scanf("%lld%lld%lld%lld%lld", &n, &m, &k, &x, &y);
    for (int i = 1; i <= k; i++) {
        LL p, q; scanf("%lld%lld", &p, &q);
        if (p != x && q != y) {
            if (p < x) ans = (ans + p) % MOD;
            else ans = (ans + n - p + 1) % MOD;
            if (q < y) ans = (ans + q) % MOD;
            else ans = (ans + m - q + 1) % MOD;
            continue;
        }
        LL s, r, e;
        if (p == x) {
            if (q < y) {
                LL xs = q % MOD;
                s = xs * ((n - 1) % MOD) % MOD;
                r = xs * ((m - 1) % MOD) % MOD;
                e = xs * ((m - q - 1) % MOD) % MOD;
            }
            else {
                LL xs = (m - q + 1) % MOD;
                s = xs * ((n - 1) % MOD) % MOD;
                r = xs * ((m - 1) % MOD) % MOD;
                e = xs * ((q - 2) % MOD) % MOD;
            }
        } 
        if (q == y) {
            if (p < x) {
                LL xs = p % MOD;
                s = xs * ((n - 1) % MOD) % MOD;
                r = xs * ((m - 1) % MOD) % MOD;
                e = xs * ((n - p - 1) % MOD) % MOD;
            }
            else {
                LL xs = (n - p + 1) % MOD;
                s = xs * ((n - 1) % MOD) % MOD;
                r = xs * ((m - 1) % MOD) % MOD;
                e = xs * ((p - 2) % MOD) % MOD;
            }
        }
        ans = (ans + s) % MOD;
        ans = (ans + r) % MOD;
        ans = (ans + e) % MOD;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：未来姚班zyl (赞：3)

## 题目大意

题目已经很简短了。

## 题目分析

首先简单转换：对每个星星求会被多少条路径包含。

身为这场比赛[审核员](https://www.luogu.com.cn/user/173510)的学弟，这道题绝对是 ta 非常喜欢的**分类讨论！**

- $p=x,q=y$

则所有路径都包含。

- $p\neq x,q\neq y$

则要么先使得 $x=p$，再走到一个 $y'$ 使得 $q$ 在 $[y,y']/[y',y]$ 中，这里按照 $y$ 与 $q$ 的大小关系需再分一次类。

要么就先使得 $y=q$，其余同理。

- $p=x,q\neq y$

则要么第一次就跨过 $(p,q)$，要么在第一次时在 $x$ 行跳一下，再跨过 $(p,q)$。

- $p\neq x,q=y$

与上面同理。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int ll
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
#define ui unsigned ll
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(int x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=2e5+5,M=4e6+5,inf=(1LL<<31)-1,mod=1e9+7;
const ll llf=1e18;
inline void add(int &a,int b){b%=mod;((a+=b)>=mod) and (a-=mod);}
inline int Add(int a,int b){return add(a,b),a;}
inline int mul(int a,int b){return 1LL*(a%mod)*(b%mod)%mod;}
inline void Mul(int &a,int b){a=mul(a,b);}
inline void red(int &a,int b){add(a,mod-b);}
inline int Red(int a,int b){return red(a,b),a;}
inline int qp(int a,int b){if(!b)return 1;int c=qp(a,b>>1);Mul(c,c);if(b&1)Mul(c,a);return c;}
inline int INV(int x){return qp(x,mod-2);}
int n,m,k,sx,sy;
struct node{
	int x,y;
}a[N];
map<Pi,int>P;
inline void Main(){
	n=read(),m=read(),k=read(),sx=read(),sy=read();
	rep(i,1,k)a[i].x=read(),a[i].y=read();
	int ans=0;
	rep(i,1,k){
		int x=a[i].x,y=a[i].y;
		if(sx==x&&sy==y){
			add(ans,mul(n+m-2,n+m-2));
		}else if(sx==x){
			if(y>sy)add(ans,mul(m-y+1,n+m-2)),add(ans,mul(y-2,m-y+1));
			else add(ans,mul(y,n+m-2)),add(ans,mul(m-y-1,y));
		}else if(sy==y){
			if(x>sx)add(ans,mul(n-x+1,n+m-2)),add(ans,mul(x-2,n-x+1));
			else add(ans,mul(x,n+m-2)),add(ans,mul(n-x-1,x));
		}else {
			if(y>sy)add(ans,m-y+1);
			else add(ans,y);
			if(x>sx)add(ans,n-x+1);
			else add(ans,x);
		}
	}
	cout <<ans;
}
signed main(){
	int T=1;
	while(T--)Main();
	return 0;
}	
```

---

## 作者：lucky_baizq (赞：2)

太坑了。。。。。

这个题目直接算每一种情况必定超时 $O((n+m-2)^2 \times (n+m)/2)$ 考虑更好的解法。

可以直接算每个位置上的点被经过多少次。

分八种情况讨论
![](https://cdn.luogu.com.cn/upload/image_hosting/4gesqon4.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/t4iphbi7.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/qb6hbip4.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/cx40b59f.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/sjz3ezyk.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/u19kvh80.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/rmh5bmlx.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/zmtjldj2.png)

分别计算即可

细节见代码


```cpp
#include <iostream>

using namespace std;



#define ll long long 
ll n,m,k;
ll x,y;

ll p,q;

const int mod=1e9+7;

ll ans;

int main()
{
	cin>>n>>m>>k>>x>>y;
	for(int i=1;i<=k;i++)
	{
		cin>>p>>q;
		if(p==x&&q!=y)
		{
			if(q<y)
			{
				ans+=(n+m-2)%mod*(q%mod)%mod;
				ans%=mod;
				ans+=(m-q-1)%mod*(q%mod)%mod;
				ans%=mod;
			}
			else{
				ans+=(n+m-2)%mod*((m-q+1)%mod);
				ans%=mod;
				ans+=(q-2)%mod*((m-q+1)%mod)%mod;
				ans%=mod;
			}
		}
		if(q==y&&p!=x)
		{
			if(p<x)
			{
				ans+=(n+m-2)%mod*(p%mod)%mod;
				ans+=((n-p-1)%mod)*(p%mod)%mod;
				ans%=mod;
			}
			else{
				ans+=(n+m-2)%mod*((n-p+1)%mod)%mod;
				ans+=((p-2)%mod)*((n-p+1)%mod)%mod;
				ans%=mod;
			} 
		}
		if(p<x&&q<y)
		{
			ans+=p+q;
			ans%=mod;
		}
		if(p>x&&q<y)
		{
			ans+=(n-p+1)+q;
			ans%=mod;
		}
		if(p<x&&q>y)
		{
			ans+=(m-q+1)+p;
			ans%=mod;
		}
		if(p>x&&q>y)
		{
			ans+=(m-q+1)+(n-p+1);
			ans%=mod;
		}
	 }
	 cout<<ans;
	return 0;
} 
```

---

## 作者：BeeAC (赞：2)

一道稍复杂的分类讨论。
## 算法分析
考虑计算对于每颗星星，共有多少种方案可以捕捉到它。所有星星捕捉方案之和即为答案。

将捕捉每颗星星的方案分为以下两类讨论：

**1. 第一次移动已经捕捉到了星星，第二次向任意位置移动；**

**2. 第一次移动还未捕捉到星星，第二次移动捕捉到星星。**

按每颗星星的位置又可以分为以下 $8$ 种情况讨论：

1. 当 $q=y$ 且 $p<x$ 时，分两种情况讨论：

   - 先向上移动到星星及星星上方的任意 $p$ 个位置，再向左右或上下移动到任意 $(n+m-2)$ 个位置，共 $p(n+m-2)$ 种方案。

   - 先移动到星星下方的任意 $(n-p-1)$ 个位置（原点除外），再向上移动到星星及星星上方的任意 $p$ 个位置，共 $p(n-p-1)$ 种方案。

   总方案数为 $p(n+m-2)+p(n-p-1)$，即 $p(2n+m-p-3)$。

2. 当 $q=y$ 且 $p>x$ 时，分两种情况讨论：

   - 先向下移动到星星及星星下方的任意 $(n-p+1)$ 个位置，再向左右或上下移动到任意 $(n+m-2)$ 个位置，共 $(n-p+1)(n+m-2)$ 种方案。


   - 先移动到星星上方的任意 $(p-2)$ 个位置（原点除外），再向下移动到星星及星星下方的任意 $(n-p+1)$ 个位置，共 $(n-p+1)(p-2)$ 种方案。

   总方案数为 $(n-p+1)(n+m-2)+(n-p+1)(p-2)$，即 $(n-p+1)(n+m+p-4)$。

3. 当 $p=x$ 且 $q<y$ 时，与情况 $①$ 类似，总方案数为 $p(2m+n-q-3)$。

4. 当 $p=x$ 且 $q>y$ 时,与情况 $②$ 类似，总方案数为 $(m-q+1)(n+m+q-4)$。

5. 当 $p<x$ 且 $q<y$ 时，分两种情况讨论：

   - 先向上移动到星星所在的那一行，再向左移动到星星及星星左边的任意 $q$ 个位置，共 $q$ 种方案。

   - 先向左移动到星星所在的那一列，再向上移动到星星及星星上方的任意 $p$ 个位置，共 $p$ 种方案。

   总方案数为 $p+q$。

6. 当 $p<x$ 且 $q>y$ 时，分两种情况讨论：

   - 先向上移动到星星所在的那一行，再向右移动到星星及星星右边的任意 $(m-q+1)$ 个位置，共 $(m-q+1)$ 种方案。

   - 先向右移动到星星所在的那一列，再向上移动到星星及星星上方的任意 $p$ 个位置，共 $p$ 种方案。

   总方案数为 $m+p-q+1$。

7. 当 $p>x$ 且 $q<y$ 时，与情况 $⑥$ 类似，总方案数为 $n+q-p+1$。

8. 当 $p>x$ 且 $q>y$ 时，分两种情况讨论：

   - 先向下移动到星星所在的那一行，再向右移动到星星及星星右边的任意 $(m-q+1)$ 个位置，共 $(m-q+1)$ 种方案。

   - 先向右移动到星星所在的那一列，再向下移动到星星及星星下方的任意 $(n-p+1)$ 个位置，共 $(n-p+1)$ 种方案。

   总方案数为 $m+n-p-q+2$。

每次输入星星位置时累加方案数即可。注意到 $1\leq n,m,p,q\leq10^{18}$，**要开 `long long` 且反复取模以防运算时溢出。**
时间复杂度 $O(k)$，期望得分 $100$ 分。
## AC代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1e9+7;
ll n,m,k,x,y,p,q,s;
ll rd()//快读
{
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int main()
{
	n=rd();m=rd();k=rd();
	x=rd();y=rd();
	while(k--)
	{
		p=rd();q=rd();	
		if(q==y)
		{
			if(p<x)//q=y且p<x时
				s=(s+((2*n+m-p-3)%mod)*(p%mod))%mod;
			else//q=y且p>x时
				s=(s+((n-p+1)%mod)*((n+m+p-4)%mod))%mod;
		}
		else if(p==x)
		{
			if(q<y)//p=x且q<y时
				s=(s+((2*m+n-q-3)%mod)*(q%mod))%mod;
			else//p=x且q>y时
				s=(s+((m-q+1)%mod)*((m+n+q-4)%mod))%mod;
		}
		else if(p<x)
		{
			if(q<y)//p<x且q<y时
				s=(s+p+q)%mod;
			else//p<x且q>y时
				s=(s+m+p-q+1)%mod;
		}
		else
		{
			if(q<y)//p>x且q<y时
				s=(s+n+q-p+1)%mod;
			else//p>x且q>y时
				s=(s+m+n-p-q+2)%mod;
		}
	}
	printf("%lld",s);
	return 0;
}
```

---

## 作者：HasNoName (赞：2)

### 思路

若一个星星和抓捕器不同行、不同列，则这个星星对答案的贡献为从抓捕器到这个星星的同一行后在经过一次星星加上抓捕器到这个星星的同一列后在经过一次星星的方法总数。

因为星星不可能和抓捕器在同一点上，所以只有一个相同。

若一个星星和抓捕器在同一行，考虑几种情况。

1. 先经过星星，在再纵向移动。
2. 先再不经过星星的情况下横向移动，再经过星星。
3. 先经过星星，在横向移动到任意一个点。

计算同一列的方法也和同一行的方法差不多。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
ll f(ll x)//取模
{
	return x%MOD;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	ll n,m,k,ans=0,x,y,a,b;
	cin>>n>>m>>k>>x>>y;
	for(int i=1;i<=k;i++)
	{
		cin>>a>>b;
		if(b==y)//分同列同行分类讨论
		{
			if(a<x)ans+=f(m-1)*f(a)+f(n-a-1)*f(a)+f(a)*f(n-1);
			else ans+=f(m-1)*f(n-a+1)+f(a-2)*f(n-a+1)+f(n-a+1)*f(n-1);
		}
		else if(a==x)
		{
			if(b<y)ans+=f(n-1)*f(b)+f(m-b-1)*f(b)+f(b)*f(m-1);
			else ans+=f(n-1)*f(m-b+1)+f(b-2)*f(m-b+1)+f(m-b+1)*f(m-1);
		}
		else
		{
			if(a<x)ans+=a;
			else ans+=n-a+1;
			if(b<y)ans+=b;
			else ans+=m-b+1;
		}
		ans%=MOD;//需要多次取模
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：HFLSLeo24 (赞：1)

# P10714 【MX-X1-T2】「KDOI-05」简单的有限网格问题 题解
## P10714 [题目传送门](https://www.luogu.com.cn/problem/P10714)
## 题目分析
题目告诉我们有一个 $n \times m$ 的网格，其中有k颗星星，问所有情况下所能捕捉到星星的总数。

我们需要注意：题目所说的“游戏的目标是在恰好两步内获得尽可能多的星星”并不是我们做题的目的，这个只是平常人游戏的目的，不要走进惯性思维！

所以，我们需要寻找新的方法（因为数据范围是 $10^{18}$，这远远超出了暴力或者递归等等算法的范围 ）。

通过查找，我们发现：当捕捉器位于 $(2,2)$ 时，$(1,1)$ 的星星会被经过2次：

- $(2,2)→(2,1)→(1,1)$
- $(2,2)→(1,2)→(1,1)$

以此类推，我们可以得出八种分类方式，分别是：

- $X_{star}<X_{捕捉器}，Y_{star}<Y_{捕捉器}$
- $X_{star}<X_{捕捉器}，Y_{star}>Y_{捕捉器}$
- $X_{star}>X_{捕捉器}，Y_{star}<Y_{捕捉器}$
- $X_{star}>X_{捕捉器}，Y_{star}>Y_{捕捉器}$
- $X_{star}=X_{捕捉器}，Y_{star}<Y_{捕捉器}$
- $X_{star}=X_{捕捉器}，Y_{star}>Y_{捕捉器}$
- $X_{star}<X_{捕捉器}，Y_{star}=Y_{捕捉器}$
- $X_{star}>X_{捕捉器}，Y_{star}=Y_{捕捉器}$

## 注意事项
记得开 long long！

记得开 long long！

记得开 long long！

重要的事情说三遍

还有记得随时随地加取模(否则会~~螺旋升天~~)

---

# 结束

---

## 作者：PeppaPig_qwq (赞：1)

首先，可以将问题转化为求每个星星经过的路径数之和。
那么，就可以开始分类讨论了。

第一种情况，$p \ne x, q \ne y$ 如下图所示。需根据起始点到星星的方向分类讨论。
![](https://cdn.luogu.com.cn/upload/image_hosting/2pdto27w.png)
第二种情况， $p = x$ 或 $q = y$。这里只考虑 $p = x $ 且 $ q \ge y$，其他三种情况类似这种情况。有两种可能，第一种路径是从起始点到位置 $x ^′,y ^′(y^′\ge q)$，再到其他点，共 $(m - q + 1) \times (n + m - 2)$ 种情况。另一种则是从起始点到位置 $x,y ^′(y^′\le q)$，再到 $x,y$,一共 $(b - 2) \times (m - q + 1)$ 种。
代码（切记 __int128):

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef __int128 ll;
const ll mod = 1e9 + 7;
ll read() {
    char c = getchar();
    ll res = 0;
    while (!isdigit(c)) {
        c = getchar();
    }
    while (isdigit(c)) {
        res *= 10;
        res += (c ^ '0');
        c = getchar();
    }
    return res;
}
void write(ll x) {
    if (x > 9)
        write(x / 10);
    putchar((x % 10) + '0');
}
int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    ll n, m, k, x, y;
    ll res = 0;
    n = read();
    m = read();
    k = read();
    x = read();
    y = read();
    for (ll i = 0, a, b; i < k; i++) {
        a = read();
        b = read();
        ll dis_x = x - a, dis_y = y - b;
        if (dis_x and dis_y)
            res += ((dis_x > 0) ? a : (n - a + 1)) + ((dis_y > 0) ? b : (m - b + 1));
        else if (!dis_x) {
            if (dis_y < 0)
                res += (m - b + 1) * (n + m - 2 + b - 2);
            else
                res += b * (n + m - 2 + (m - b - 1));
        }
        else {
            if (dis_x < 0)
                res += (n - a + 1) * (n + m - 2 + a - 2);
            else
                res += a * (n + m - 2 + (n - a - 1));
        }
        res %= mod;
    }
    write(res);
    return 0;
}
/*
3 3 1
1 1
1 2
*/
```

---

## 作者：fengyuxuan (赞：1)

## 题目大意
有一个 $n\times m$ 的棋盘，其中 $k$ 个位置上有星星，初始有一个捕捉器，在 $(x,y)$ 位置。每次操作，可以将捕捉器上下左右移动任意距离，且仍在棋盘内，**而捕捉器会捕捉移动路径上所有的星星**。一个星星被捕捉后将会消失。一共可操作两次，问：在所有可能的两次操作中，一共能捕捉到几颗星星。
## 题目解析
思路：易得，题目所求相当于枚举每个星星，计算共有几条路径经过这个星星，最后累加。

此时就要分类讨论了：

我们设星星的位置为 $(p,q)$。

1. 当 $q=y,p<x$，即星星与捕捉器在同一列,且在捕捉器上方，如图（红是捕捉器，黄是星星）：

![](https://cdn.luogu.com.cn/upload/image_hosting/2yxio6s1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时，显然第一步只能上下走，所以我们再次分类：

- 当第一步没有经过星星，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/m45m5l52.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然第一步共有 $n-p-1$ 种走法，而第二步，必然要经过星星，所以只要走到星星或星星上面即可，而这些共有 $p$ 格位置，所以有 $p$ 种走法。所以这种情况总共有 $(n-p-1) \times p$ 种走法。

- 当第一步已经经过星星，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/sygk6fu8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

第一步同上一种情况的第二步共有 $p$ 种走法，而第二步，就可以上下左右随便走，左右走就是 $m-1$ 种走法，上下走就是 $n-1$ 种走法（要除去当前这个位置），所以第二步共有 $n+m-2$ 走法，所以这种情况总共有 $p \times (n+m-2)$ 种走法。

因此，当 $q=y,p<x$ 时，总共有 $(n-p-1) \times p+p \times (n+m-2)$ 种走法。

2. 当 $q=y,p>x$，即星星与捕捉器在同一列,且在捕捉器下方方，同理我们分两类：
- 当第一步没有经过星星，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/g9s9e3ki.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时，共有 $(p-2) \times (n-p+1)$ 种走法。
- 当第一步已经经过星星，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/cq9jia9l.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时，共有 $(n-p+1) \times (n+m-2)$ 种走法。

因此，当 $q=y,p>x$ 时，总共有 $(p-2) \times (n-p+1)+(n-p+1) \times (n+m-2)$ 种走法。

3. 当 $p=x,q<y$，即星星与捕捉器在同一行,且在捕捉器左方：

同1，只需把 $x$ 替换成 $y$，把把 $p$ 替换成 $q$，把 $n$ 替换成 $m$，$m$ 替换成 $n$ 即可，因此共有 $(m-q-1) \times q+q \times (n+m-2)$ 种走法。

4. 当 $p=x,q<y$，即星星与捕捉器在同一行,且在捕捉器左方：

同2，共有 $(q-2) \times (m-q+1)+(m-q+1) \times (n+m-2)$ 种走法。

5. 当 $p \neq x,q \neq y$ 考虑两种走法：

- 先走到与星星同一列，再往上下走过星星，此时第一步已经固定，只需考虑第二步。

首先当星星在捕捉器上方，即 $p<x$，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2prdw9oy.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然第二步要走过星星，共 $p$ 种走法。

其次当星星在捕捉器下方，即 $p>x$，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xx6pfqz9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

显然，第二步共有 $n-p+1$ 种走法。

- 先走到与星星同一行，再往左右走过星星，同样此时第一步已经固定，只需考虑第二步。

同上，分成两类；

首先当星星在捕捉器左方，即 $q<y$，同理有 $q$ 种走法。

其次当星星在捕捉器右方，即 $q>y$，同理有 $m-q+1$ 种走法。

此题分析完毕，最后需要注意取模，在乘法只前每个因数都要模一遍，不然就会炸。
## 最终代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,x,y,p,q;
long long sum;
long long M=1000000007;
int main()
{	
	cin>>n>>m>>k>>x>>y;
	for(int i=1;i<=k;i++)
	{
		cin>>p>>q;
		if(q==y) 
		{
			if(p<x)
				sum+=((n-p-1)%M*(p%M)%M+(n-1+m-1)%M*(p%M)%M)%M;
			else	
				sum+=((p-2)%M*((n-p+1)%M)%M+(n-p+1)%M*((n-1+m-1)%M)%M)%M;
			sum%=M;
		}	
		else if(p==x)
		{
			if(q<y)
				sum+=((m-q-1)%M*(q%M)%M+(m-1+n-1)%M*(q%M)%M)%M;
			else	
				sum+=((q-2)%M*((m-q+1)%M)%M+(m-q+1)%M*((m-1+n-1)%M)%M)%M;
			sum%=M;
		}
		else 
		{
			if(p<x) sum+=(p%M);
			else sum+=((n-p+1)%M);
			sum%=M;
			if(q<y) sum+=(q%M);
			else sum+=((m-q+1)%M);
			sum%=M;
		}
		
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：__Green_tick__ (赞：0)

## 小声逼逼
~看前面有 dalao 的方法写的很聪明，本蒟蒻看不懂，于是，就有了这篇垃圾题解。。。~

## 题目解析

> 游戏中会有一个 $n\times m$ 的棋盘，其中 $k$ 个位置上有星星。初始有一个捕捉器，在 $(x,y)$ 位置。每次操作，你可以将捕捉器移动到同行或同列的某个位置，使得新位置与原位置不同且必须保证新位置 $(x',y')$ 满足 $1\leq x'\leq n$，$1\leq y'\leq m$。**捕捉器会捕捉 $(x,y)$ 到 $(x',y')$ 路径上所有的星星**。一个星星被捕捉后将会消失。
> 
> 游戏的目标是在恰好两步内获得尽可能多的星星，然而小 S 不会玩，于是每次就会随意挑选一个可以移动到的新位置进行移动。对于 $(n+m-2)^2$ 种小 S 的不同移动方案，求捕捉到的星星数量之和，答案对 $10^9+7$ 取模。
> 
> 对于 $100\%$ 的数据，$1\leq k\leq10^5$，$1\leq n,m\leq10^{18}$，$1\leq x,p\leq n$，$1\leq y,q\leq m$，$(x,y)\neq(p,q)$。

$1\leq k\leq10^5$，$1\leq n,m\leq10^{18}$，这说明了什么，数学题！！！

## 思路分析
若一个星星和抓捕器**不同行**、**不同列**，则这个星星对答案的贡献为从抓捕器到这个星星的同一行后在经过一次星星加上抓捕器到这个星星的同一列后在经过一次星星的方法总数。

因为星星**不可能和抓捕器在同一点上**，所以只有一个相同。

---

若一个星星和抓捕器在同一行，考虑三种情况。

+ 先经过星星，在再纵向移动。
+ 先在不经过星星的情况下横向移动，再经过星星。
+ 先经过星星，在横向移动到任意一个点。

---

若一个星星和抓捕器在同一列，考虑三种情况。

+ 先经过星星，在再横向移动。
+ 先在不经过星星的情况下纵向移动，再经过星星。
+ 先经过星星，在纵向移动到任意一个点。

---

若同行，则：
> 判断星星在 $y$ 的那侧，若在左侧（即 $b<y$ 的情况），则：
> $$ans \gets (m-1) \times a+(n-a-1) \times a+a \times (n-1)$$
> 否则：
> $$ans \gets (m-1) \times (n-a+1)+(a-2) \times (n-a+1)+(n-a+1) \times (n-1)$$

---

若同列，则：
> 判断星星在 $x$ 的那侧，若在左侧（即 $a<x$ 的情况），则：
> $$ans \gets (m-1) \times a+(n-a-1) \times a+a \times (n-1)$$
> 否则：
> $$ans \gets (n-1) \times (m-b+1)+(b-2) \times (m-b+1)+(m-b+1) \times (m-1)$$

---

若不同列，也不同列，则：
> 判断星星在 $x$ 的那侧，若在左侧（即 $a<x$ 的情况），则：直接计算所有可行解。

## 正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*Optimization series
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3,"Ofast","inline")
*/
const long long ModdelValue=1e9+7;
long long n,m,k,ans,x,y,a,b;
long long Mod(long long x){
	return x%ModdelValue;
}

int main(){
	cin>>n>>m>>k>>x>>y;
	for(long long i=1;i<=k;i++){
		cin>>a>>b;
		if(a==x){
			if(b<y) ans+=Mod(n-1)*Mod(b)+Mod(m-b-1)*Mod(b)+Mod(b)*Mod(m-1);
			else ans+=Mod(n-1)*Mod(m-b+1)+Mod(b-2)*Mod(m-b+1)+Mod(m-b+1)*Mod(m-1);
		}else if(b==y){
			if(a<x) ans+=Mod(m-1)*Mod(a)+Mod(n-a-1)*Mod(a)+Mod(a)*Mod(n-1);
			else ans+=Mod(m-1)*Mod(n-a+1)+Mod(a-2)*Mod(n-a+1)+Mod(n-a+1)*Mod(n-1);
		}else{
			if(a<x) ans+=a;
			else ans+=n-a+1;
			if(b<y) ans+=b;
			else ans+=m-b+1;
		}
		ans=Mod(ans);
	}
	cout<<ans<<endl;
	return 0;
}
```
最后，以一句话结束：
$$
\textit{\textbf{莫抄袭，棕了少年名，空悲切。}}
$$

---

## 作者：liukangyi (赞：0)

# 题目大意
有一个 $n \times m$ 的棋盘，棋盘上有 $k$ 颗星星，给你每颗星星的位置。现在，有一个捕捉器，位于给出的 $(x,y)$。捕捉器每次可以移动到**同行或同列**的任意一个位于棋盘内且**不同于原位置**的格子。要你求出捕捉器**恰好**移动两次，每次移动过程中获取到的星星数量之和，答案对 $10^9+7$ 取余。

注意：一个星星被获取后将会消失。

# 分析
第一时间想到的，就是暴力枚举移动过程。

想法很美好，但现实很残酷！

看看数据范围：$1 \le n,m \le 10^{18}$，很明显，这不支持我们暴力枚举。

为什么暴力枚举会超时呢，因为在枚举的那么多移动过程中，有很多是对答案没有贡献的，这样的话会白白浪费很多时间。

那我们考虑一下只计算对答案有贡献的。

很容易想到，**每颗星星绝对都对答案有贡献**，那我们何妨不枚举星星，并把每颗星星对答案的贡献值累加起来计算答案呢？

$1 \le k \le 10^5$

可以看到，$k$ 的范围是允许我们枚举星星的！

那现在最关键的就是，怎么计算一颗星星对答案的贡献值呢？

这是需要分类讨论的。

为了方便，我们定义一颗星星的位置为 $(p,q)$。

### ①：不同行且不同列
对于一颗与捕捉器初始位置既不同行也不同列的星星，我们首先要确定它位于捕捉器的左上、左下、右上还是右下。

我们要先将捕捉器移动到它的相同行或相同列，然后移动到它的位置或比它更深的位置。

具体计算方法如下：

```cpp
if(p<x) ans=ans+p;
else ans=ans+(n-p+1);
if(q<y) ans=ans+q;
else ans=ans+(m-q+1);
```

### ②：同行或同列
首先，我们要明确的一点是，$(x,y) \ne (p,q)$，所以，不用考虑同行同列，即星星位于捕捉器初始位置的情况。

其实，同行与同列的计算方式大差不差。

那我们就先来讨论同行的情况：

同行中，又分两类：星星在捕捉器左边，星星在捕捉器右边。
这两种的处理方式也都差不多。

那我们着重来讲讲在左边的情况要怎么处理。

在左边的话，可以有以下几种方式来捕捉星星：

左左：
```cpp
(y-q-1)*q+q*(q-1)/2
```
左右：
```cpp
(q-1)*(m-q+1)+(q-1)*(q-2)/2+(m-q)
```
左上、左下：
```cpp
q*(n-1)
```
右左：
```cpp
(m-y)*b[i]
```
把这几种情况累加起来，就是星星在左边时对答案的贡献了。

在右边的话，就换个方向，注意下细节。

而左边和右边讲完了，同列时上面和下面的情况自然也就迎刃而解了。

# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int K=1e5,MOD=1e9+7;
int n,m,k,x,y,ans;
int a[K+10],b[K+10];
signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	scanf("%lld%lld",&x,&y);
	for(int i=1;i<=k;i++){
		scanf("%lld%lld",&a[i],&b[i]);
		if(a[i]!=x&&b[i]!=y){
			if(a[i]<x)
				ans=(ans+a[i])%MOD;
			else ans=(ans+(n-a[i]+1))%MOD;
			if(b[i]<y)
				ans=(ans+b[i])%MOD;
			else ans=(ans+(m-b[i]+1))%MOD;
		}
		else{
			if(a[i]==x){
				if(b[i]<y)
					ans=(ans+(y-b[i]-1)%MOD*(b[i]%MOD)%MOD+b[i]%MOD*((b[i]-1)%MOD)/2%MOD+b[i]%MOD*((n-1)%MOD)%MOD+(b[i]-1)%MOD*((m-b[i]+1)%MOD)%MOD+(b[i]-1)%MOD*((b[i]-2)%MOD)/2%MOD+(m-b[i])%MOD+(m-y)%MOD*(b[i]%MOD)%MOD)%MOD;
				else ans=(ans+(b[i]-y-1)%MOD*((m-b[i]+1)%MOD)%MOD+(m-b[i]+1)%MOD*((m-b[i])%MOD)/2%MOD+(m-b[i]+1)%MOD*((n-1)%MOD)%MOD+(m-b[i])%MOD*(b[i]%MOD)%MOD+(m-b[i])%MOD*((m-b[i]-1)%MOD)/2%MOD+(b[i]-1)%MOD+(y-1)%MOD*((m-b[i]+1)%MOD)%MOD)%MOD;
			}
			else{
				if(a[i]<x)
					ans=(ans+(x-a[i]-1)%MOD*(a[i]%MOD)%MOD+a[i]%MOD*((a[i]-1)%MOD)/2%MOD+a[i]%MOD*((m-1)%MOD)%MOD+(a[i]-1)%MOD*((n-a[i]+1)%MOD)%MOD+(a[i]-1)%MOD*((a[i]-2)%MOD)/2%MOD+(n-a[i])%MOD+(n-x)%MOD*(a[i]%MOD)%MOD)%MOD;
				else ans=(ans+(a[i]-x-1)%MOD*((n-a[i]+1)%MOD)%MOD+(n-a[i]+1)%MOD*((n-a[i])%MOD)/2%MOD+(n-a[i]+1)%MOD*((m-1)%MOD)%MOD+(n-a[i])%MOD*(a[i]%MOD)%MOD+(n-a[i])%MOD*((n-a[i]-1)%MOD)/2%MOD+(a[i]-1)%MOD+(x-1)%MOD*((n-a[i]+1)%MOD)%MOD)%MOD;
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：qiuqiuqzm (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10714)

# 分析
我们发现这道题的数据范围 $1\le n,m \le 10^{18}$。所以枚举每个位置肯定不行，我们可以考虑求每个星星能被捕捉的次数，相加取模就是最后答案。

我们分析一下有哪些情况。

1. **星星的行与捕捉器原始位置的行相同**

如图（红色是捕捉器，黄色为星星）。

![](https://cdn.luogu.com.cn/upload/image_hosting/6c39ojdk.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这种情况下我们要分成一步捕捉还是两步捕捉。

* 一步捕捉的话那么第一步就是先把星星捕捉到。如果捕捉器在星星右侧，那么就要移动到星星左侧的 $q$ 个位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/cnhcc581.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

接下来我们还要移动一次。如果横向移动的话，我们已经有两个位置用了，就只有 $(m-2)$ 个位置可以移动。而纵向的话，只有当前这一个位置移动过了，有 $(n-1)$ 个位置可以移动，总共就是 $q\times (m-2)+q\times (n-1)$ 个位置可以移动。如图（蓝色为第一次可以移动到的位置中的一个）。

![](https://cdn.luogu.com.cn/upload/image_hosting/d6898nx4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如果捕捉器在星星左侧，那也同理，只不过一开始的 $q$ 个位置变成了 $(m-q+1)$ 个位置。

* 如果两次才到达呢？那我们第一次只能横向移动，如果纵向的话，第二次就不可能收集到星星了，横向移动也不能跑到星星那里，不然就收集到了，最后答案会和上面有重复部分，答案就会偏大。那这样的话总共就有 $(m-q+1-1)$ 也就是 $(m-q)$ 个位置，最后减一是因为不能和当前位置重叠。

![](https://cdn.luogu.com.cn/upload/image_hosting/aq90biu8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

而接下来就只有星星左侧的 $q$ 个位置可以走了，共 $(m-q)\times q$ 个位置可以走。

![](https://cdn.luogu.com.cn/upload/image_hosting/znmdtoe7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

捕捉器在星星左侧也是同理。

* 那么最后全部加起来，就可以算出若捕捉器在星星右侧，答案要加 $q\times (m-2)+q\times (n-1)+(m-q)\times q$。当然，这里是可以提公因数的。而在左边的话要加 $(m-q+1)\times (m-2)+(m-q+1)\times (n-1)+(m-q+1)\times (q-1)$。

2. **星星的列与捕捉器原始位置的列相同**

* 这种情况与上文几乎相同，只不过 $n$ 和 $m$ 倒换了，再把 $q$ 换成 $p$ 即可。

3. **星星的行列与捕捉器原始位置的行列都不同**

* 那这样的话我们就必须移动一次行移动一次列。

* 如果我们先移动行的话，那只能先移动到与星星位置相同的行。不然下一次移动行还是列都没法收集到星星。

![](https://cdn.luogu.com.cn/upload/image_hosting/89urkfn5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

而移动列时就变成了上文一样的情况，唯一的不同是只能一步到收集到星星。收集器在星星右边有 $q$ 个位置，而在左边有 $(m-q+1)$ 个位置。

![](https://cdn.luogu.com.cn/upload/image_hosting/6l9k7l9g.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

* 如果先移动列，还是与上文相同。收集器在星星右边有 $p$ 个位置，而在左边有 $(n-p+1)$ 个位置。

接下来把这些综合，就可以写出代码了。总复杂度 $O(k)$。

**注意：在计算时一定要每个数都取模，不然就会像我一样 WA 一页的 85pts。**

# Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll Mod=1e9+7;
ll k,n,m,x,y,ans=0;
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m>>k>>x>>y;
	for(int i=1;i<=k;i++)
	{
		ll p,q;
		cin>>p>>q;
		if(p==x) //情况1
			ans+=(q<y) ? ((q%Mod*((m-2)%Mod))%Mod+(q%Mod*((n-1)%Mod))%Mod+((m-q)%Mod*(q%Mod))%Mod)%Mod : (((m-q+1)%Mod*((m-2)%Mod))%Mod+((m-q+1)%Mod*((n-1)%Mod))%Mod+((q-1)%Mod*((m-q+1)%Mod))%Mod)%Mod;
		if(q==y) //情况2
			ans+=(p<x) ? ((p%Mod*((n-2)%Mod))%Mod+(p%Mod*((m-1)%Mod))%Mod+((n-p)%Mod*(p%Mod))%Mod)%Mod : (((n-p+1)%Mod*((n-2)%Mod))%Mod+((n-p+1)%Mod*((m-1)%Mod))%Mod+((p-1)%Mod*((n-p+1)%Mod))%Mod)%Mod;
		if(p!=x&&q!=y) //情况3
			ans+=(((q<y) ? q%Mod : (m-q+1)%Mod)+((p<x) ? p%Mod : (n-p+1)%Mod))%Mod;
		ans%=Mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：wcy110614 (赞：0)

换一种数数思路，原来是想数 $(n+m-2)^2$ 种方案所经过的星星和，但这样过于麻烦，复杂度太大。

不如考虑对于每一颗星星计算有多少种方案经过它。

然后分类讨论：

以捕捉器为原点建立平面直角坐标系。

### 在象限上

对于不在同一行且不在同一列的情况：（图中 $A$ 表示捕捉器，$*$ 表示星星）

比如

$----A$

$p\ *\ ---$

$-\ q\ ---$

显然第一步向下走，第二步向右走，只要向右走到 $*$ 或 $p$ 的位置都可以。

或者第一步向右走，第二步向下走，只要走到 $*$ 或 $q$ 的位置就可以。

这个 $*,p$ 的格数之和不难使用对于 $x$，$n$ 的加减法得到。只用分类讨论 $*$ 在 $A$ 的第一、二、三、四象限就好了。

### 不在象限上

对于在同一行或在同一列的情况：（图中 $A$ 表示捕捉器，$*$ 表示星星）

同样可以分类讨论。

设上中分类讨论中形如 $p,q,*$ 的点共有 $r$ 个。

这样“触碰到星星”的情况分为两种：

1. 第一步经过星星：必然会有第一步经过 $p,q,*$ 的点，共 $r$ 情况。第二步随意游走，共 $(n+m-2)$ 种情况。乘法原理，共 $r(n+m-2)$ 种情况。

2. 第一步未经过星星，第二步经过星星：容易证明，第一步不能跳出与星星相同的行或列，否则第二步无法到达星星的位置。这样第一步为了不经过星星，共 $(n-r-1)$ 种情况，第二步为了到达星星共 $r$ 种情况。乘法原理，共 $r(n-r-1)$ 种情况。

综上所述，加法原理，共 $r(n+m-2)+r(n-r-1)$ 种情况。

$r$ 的求法同样可以分 $4$ 种情况，分别对于 $4$ 条半轴。

这时对于每个星星都可以 $\mathcal{O(1)}$ 地求得经过次数。总复杂度为 $\mathcal{O(n)}$。足以通过本题。

**`long long` 很有可能开不下，最好 `__int128`，并且勤取模**。

代码见下：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define int __int128
const int p=1e9+7;
using namespace std;
ll inp;
int n,m,k,ans,X,Y;
void dr(int &value){
	cin>>inp;
	value=inp;
}
void wr(int value){
	inp=value;
	cout<<inp<<"\n";
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	dr(n),dr(m),dr(k),dr(X),dr(Y);
	for(int t=1;t<=k;++t){
		int x,y,r=0;
		dr(x),dr(y);
		if(x!=X&&y!=Y){
			int r1=0,r2=0;
			if(y<=Y)r1=y;
			else if(y>Y)r1=m-y+1;
			if(x<=X)r2=x;
			else if(x>X)r2=n-x+1;
			ans+=r1+r2;
		}else{
			if(x==X){
				if(y<=Y)r=y;
				else if(y>Y)r=m-y+1;
				ans+=r*(n+m-2)%p+(m-r-1)*r%p;
			}else if(y==Y){
				if(x<=X)r=x;
				else if(x>X)r=n-x+1;
				ans+=r*(n+m-2)%p+(n-r-1)*r%p;
			}
		}
		ans%=p;
	}
	return wr((ans%p+p)%p),0;
} 
```

---

## 作者：postpone (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P10714)

由题意可以知道，星星互相之间没有影响，那么我们可以统计每颗星星的贡献，然后累加求和，问题就转化成了“对于给定位置的星星，由多少种走法可以吃到它”。

规律有点难想，不妨先把星星划分成与起点在同一行或同一列，和与起点既不在同一行也不在同一列两类进行讨论。

### 1. 与起点不在同一行，也不在同一列的星星

对于和起点不在同一行或同一列的星星，因为只能走两步，可以再分为先定位到行和先定位到列两种情况。

如果先定位到行，那下一步的目标一定要经过目标，如下图所示，可以走到目标位置，也可以走到底，也就是说从目标位置到边界可以任选一点（图种绿框就是第二步可以选择的终点）。

![pic1](https://cdn.luogu.com.cn/upload/image_hosting/3ykup9ce.png)

先定位列再定位行同理，示意图如下。

![pic2](https://cdn.luogu.com.cn/upload/image_hosting/xry8kc2t.png)

上述两种情况互相独立，因此和起点不在同一行或同一列的星星的贡献就是两者相加的结果。

不妨设 $dx$ 和 $dy$，定义如下：
```cpp
// (x0, y00) 为起点坐标
if (x > x0)
    dx = n - x + 1;
else
    dx = x;
if (y > y00)
    dy = m - y + 1;
else
    dy = y;
```

__从上面两个示意图可以看出，$(dx+dy)$ 即为所求。__

### 2. 与起点在同一行或同一列的星星

对于和起点在同一行或同一列的星星，再分为第一步就吃到，和第二步才吃到两种情况。

第一步就吃到，第二步随便怎么走都可以，比较好想就不放示意图了，情况数为 $(n+m-2)(dx)$ 或 $(n+m-2)(dy)$。

第一步不吃到，第二步才吃到的示意图如下。第一步可以选白框（除了起点自己）中的点，第二步选择橙框中的点即可保证第二步才吃到星星。情况数为 $(n-dx-1)(dx)$ 或 $(m-dy-1)(dy)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/u9ru2has.png)

__综上所述：对于和起点不在同一行与同一列的星星，贡献为 $(dx+dy)$，对于和起点在同一行的星星，贡献为 $(2n+m-dx-3)(dx)$，同一列则贡献为 $(2m+n-dy-3)(dy)$。__

代码如下（记得取模维护）：
```cpp
#include <bits/stdc++.h>
using namespace std;
// 开 long long 就行
using ll = long long;
#define endl '\n'
#define enter putchar('\n')
const int N = 1e3 + 100;

ll k, res, x0, y00, n, m, dx, dy, x, y;
const ll p = 1e9 + 7;

void solve()
{
    cin >> n >> m >> k >> x0 >> y00;
    for (ll i = 1; i <= k; i++)
    {
        cin >> x >> y;

        if (x > x0)
            dx = n - x + 1;
        else
            dx = x;
        if (y > y00)
            dy = m - y + 1;
        else
            dy = y;
            
        if (x == x0)
        {
            dy %= p;
            res = (res + ll(dy * (ll(m + n - 3 + m - dy) % p))) % p;
        }
        else if (y == y00)
        {
            dx %= p;
            res = (res + ll(dx * (ll(m + n - 3 + n - dx) % p))) % p;
        }
        else
        {
            dy %= p, dx %= p;
            res = (res + dx + dy) % p;
        }
    }
    cout << res;
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int _ = 1;
    while (_--)
        solve();
    return 0;
}
```

---

## 作者：NTT__int128 (赞：0)

# P10714 【MX-X1-T2】「KDOI-05」简单的有限网格问题 题解
分类讨论题。

我将 $(x,y)$ 与 $(p,q)$ 颠倒了一下。

首先，定义 $h(x)$ 与 $l(y)$，其中：

若 $x<p$，则 $h(x)=x$，否则 $h(x)=n-x+1$。

若 $y<q$，则 $l(y)=y$，否则 $l(y)=m-y+1$。

对于情况：

1. $x\neq p,y\neq q$

2. $x\neq p,y=q$

3. $x=p,y\neq q$

进行讨论。

情况 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/xarv1vi3.png)

答案为 $h(x)+l(y)$。

情况 $2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/t69qzdzo.png)

分为 $3$ 种情况：

- 灰色，答案为 $(m-1)\times h(x)$。

- 绿色，答案为 $(h(x)-1)\times h(x)$。

- 红色，答案为 $h(x)\times(n-1)$。

情况 $3$：类情况 $2$。

**注意：每一处都要取模（慎防爆 ```long long```）！！！**

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std ;
const int M = 1e9 + 7 ;
int n , m , k , x , y , p , q , ans ;
signed main()
{
	cin >> n >> m >> k >> p >> q ;
	while(k--)
	{
		cin >> x >> y ;
		if(x != p && y != q)	ans = (ans + (x < p ? x : n - x + 1) % M + (y < q ? y : m - y + 1) % M) % M ;
		else if(y != q)	ans = (ans + (n - 1) % M * ((y < q ? y : m - y + 1) % M) % M + (y < q ? m - y - 1 : y - 2) % M * ((y < q ? y : m - y + 1) % M) % M + (m - 1) % M * ((y < q ? y : m - y + 1) % M) % M) % M ;
		else if(x != p)	ans = (ans + (m - 1) % M * ((x < p ? x : n - x + 1) % M) % M + (x < p ? n - x - 1 : x - 2) % M * ((x < p ? x : n - x + 1) % M) % M + (n - 1) % M * ((x < p ? x : n - x + 1) % M) % M) % M ;
	}
	cout << ans % M ;
	return 0 ;
}
```

---


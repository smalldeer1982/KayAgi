# [GESP202406 五级] 黑白格

## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。

小杨想知道至少包含 $k$ 个黑色格子的最小子矩形包含了多少个格子。

## 说明/提示

#### 样例解释

对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，至少包含 $5$ 个黑色格子的最小子矩形的四个顶点为 $(2,4)$，$(2,5)$，$(4,4)$，$(4,5)$，共包含 $6$ 个格子。

#### 数据范围

对于全部数据，保证有 $1\le n,m\le 100$，$1\le k\le n\times m$。

| 子任务编号 | 得分 | $n,m$ |
| :--: | :--: | :--: |
| $1$ | $20$ | $\le 10$  |
| $2$ | $40$ | $n=1$，$1\le m\le 100$ |
| $3$ | $40$ | $\le 100$|

Update on 2024/7/9：添加了若干组 hack 数据，感谢 @cff_0102 的贡献。

## 样例 #1

### 输入

```
4 5 5
00000
01111
00011
00011```

### 输出

```
6```

# 题解

## 作者：cff_0102 (赞：32)

注意到数据范围很小（$n,m\le 100$），所以可以直接枚举左上和右下的端点，计算出中间矩形中 $1$ 的数量，然后比较并取最小值。

那么主要任务就变成快速计算两个点之间矩形中所有数字之和了。不难想到二维前缀和。每个点 $(x,y)$ 存储的是 $(1,1)$ 作为左上端点，$(x,y)$ 作为右下端点，得到的矩形中所有数的和，这样就可以利用容斥原理线性计算出任意一个矩形中所有数的和。

下面的 AC 代码枚举的 $(x_1,y_1)$ 实际上并不是矩形的左上端点 $(x,y)$，而是 $(x-1,y-1)$。因为数组在主函数外定义，所以不用担心第 $0$ 行或第 $0$ 列出现随机数的问题。

```cpp
#include<iostream>
using namespace std;
bool a[114][514];// 存储输入
int b[1919][810];// 存储二维前缀和
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n,m,k;cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;cin>>c;
			a[i][j]=c-'0';
			b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];// 利用容斥原理计算出 b[i][j]
		}
	}
	int mn=0xcff0102;// 一个足够大的数
	for(int x1=0;x1<n;x1++){// 注意这里的范围 
		for(int y1=0;y1<m;y1++){// 注意这里的范围 
			for(int x2=x1;x2<=n;x2++){
				for(int y2=y1;y2<=m;y2++){
					int tmp=b[x2][y2]-b[x2][y1]-b[x1][y2]+b[x1][y1];// 左上端点为 (x1+1,y1+1)，右上端点为 (x2+1,y2+1) 的矩形中 1 的数量
					if(tmp>=k)mn=min(mn,(x2-x1)*(y2-y1));
				}
			}
		}
	}
	cout<<((mn==0xcff0102)?0:mn);// 注意判断无解
	return 0;
}
```

注意：`bits/stdc++.h` 头文件中包含函数 `y1`，类似的函数还有 `y0`，`yn`，`j0`，`j1`，`jn`。如果使用万能头文件，需要避免把变量名命名为这些名字。

---

吐槽一句：本题数据有点弱，我把循环中的 $m$ 误写为 $n$ 居然只 WA 了 $4$ 个点，还能获得 $60$ 分。

---

## 作者：xinxin2022 (赞：17)

## 暴力做法

统计每个子矩阵里黑色格子出现的次数，枚举每个子矩阵的左上角，再枚举每个子矩阵右下角，最后双重循环统计子矩阵中黑色格子的数量，可以发现时间复杂度是 $O(n^6)$ 的，只可以拿到 $60$ 分，想要过这道题，就一定要优化。

## 二维前缀和

作者在考场上看到数据范围后有两个想法：二分和二维前缀和，最后作者认为二维前缀和更像是正解，所以考场上作者用二维前缀和过掉了这道题。

我们都知道，前缀和可以将原本 $O(n)$ 的求和，通过 $O(n)$ 的预处理，达到对于每个区间 $O(1)$ 求和，那么二维前缀和是如何实现 $O(1)$ 求矩阵和的呢？

首先我们先来了解一下如何构造二维前缀和的前缀和数组。

我们可以将二维前缀数组的第 $i$ 行第 $j$ 的数字视为以 $(i,j)$ 为右下角，以 $(1,1)$ 为左上角的矩阵的数字和。

对于每个二维前缀和数组中的数，求它的办法就是用它左侧的矩阵和加上它上方的矩阵和再减去它左上方重复加了的矩阵的和，最后加上那个位置本身的数。

那二维前缀和的前缀和数组有了，如何使用它求子矩阵和呢？

现在我们假设要求一个子矩阵所有数字的和，设 $x_1$ 为子矩阵左上角的行数，设 $y_1$ 为子矩阵左上角的列数，再设 $x_2$ 为子矩阵右下角的行数，最后设 $y_2$ 为子矩阵右下角的列数。那么可以发现，应当用 $f[x_2][y_2]$ 减去 $f[x_2][y_1-1]$，再减去 $f[x_1-1][y_2]$，最后因为重复减去了左上角的子矩阵的和，再加上 $f[x_1-1][y_1-1]$。可以理解为，用右下角的前缀和，减去子矩阵左侧的前缀和，再减去子矩阵上方的前缀和，最后加上子矩阵左上方的前缀和。

好，理论知识学完了，我们开始实践。

首先构造前缀和数组：
```cpp
char a;
int f[n+1][m+1]={};
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
   		cin>>a;
        if(a=='1') f[i][j]++;
	    //加上当前位置的数字
        f[i][j]=f[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1];
	    //构造前缀和数组
    }
}
```

再遍历求每个子矩阵的黑格子数量，寻找答案：

```cpp
int ans=INT_MAX;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        //枚举左上角
        for(int w=i;w<=n;w++){
            for(int l=j;l<=m;l++){
                //枚举右下角
                if(f[w][l]-f[i-1][l]-f[w][j-1]+f[i-1][j-1]>=k){
                    //如果黑格子足够，就判断子矩阵大小是否更小
                    ans=min(ans,(w-i+1)*(l-j+1));
                }
            }
        }
    }
}
```

最后将两部分合并起来，得到时间复杂度为 $O(n^4)$ 的满分代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    char a;
    //要用char读!!!
    int f[n+1][m+1]={};
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a;
            if(a=='1') f[i][j]++;
            //加上当前位置的数字
            f[i][j]=f[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1];
            //构造前缀和数组
        }
    }
    int ans=INT_MAX;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            //枚举左上角
            for(int w=i;w<=n;w++){
                for(int l=j;l<=m;l++){
                    //枚举右下角
                    if(f[w][l]-f[i-1][l]-f[w][j-1]+f[i-1][j-1]>=k){
                        //如果黑格子足够，就判断子矩阵大小是否更小
                        ans=min(ans,(w-i+1)*(l-j+1));
                    }
                }
            }
        }
    }
    if(ans==INT_MAX) cout<<0;
    //更新过答案，就输出答案，否则输出0
    else cout<<ans;
    return 0;
}
```

---

## 作者：longlong_int (赞：11)

## 思路
本题可以用类似**前缀和**的方法来解决：

首先来说说编号模式： $(x,y)$ 表示第 $x$ 行第 $y$ 列。

维护一个二维数组 `sum`，其中 `sum[i][j]` 表示从左上角编号为 $(1,1)$ 的格子到编号为 $(i,j)$ 的格子中黑色格子的数量。

### 如何求出答案

先不考虑怎么样维护，假设我们已经有了这个数组，那么求答案时只需要将目标矩形的左上角、右下角枚举一下，分别为：左上角 $(i,j)$，右下角 $(k,l)$。

如下图，要求出目标部分（黄色）我们只需加上大块（所有着色部分，`sum[k][l]`），再减去上方（红+橙，`sum[i + 1][l]`）以及左方（绿+橙，`sum[k][j - 1]`）的不需要部分，但是由于橙色部分（`sum[i - 1][j - 1]`）被减了两遍，所以需要加上。

![](https://cdn.luogu.com.cn/upload/image_hosting/11cjuh36.png)

此部分代码：
```cpp
int minn = INTINF; // INTINF = 2147483647
for (int i = 1; i <= n; i++)
{
	for (int j = 1; j <= m; j++)
	{
		for (int k = 1; k <= n; k++)
		{
			for (int l = 1; l <= m; l++)
			{
				if (sum[k][l] - sum[i - 1][l] - sum[k][j - 1] + sum[i - 1][j - 1] >= s)
				{
					minn = min(minn, (k - i + 1) * (l - j + 1));					}
				}
			}
		}
	}
}
```
### 维护
维护就简单了，与上面类似（如下图），把上面的部分（红+橙，`sum[i - 1][j]`）以及左面的部分（绿+橙，`sum[i][j - 1]`）加上，但由于左上（图中橙色部分）被加了两次，所以要减掉一遍。再加上当前块带来的黑格数量（1 或 0）即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/sdlrzrgj.png)

这部分代码：
```cpp
for (int i = 1; i <= n; i++)
{
	for (int j = 1; j <= m; j++)
	{
		char a;
		cin >> a;
		int f = a - '0';
		if (f == 1)
		{
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + 1;
		}
		else
		{
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
		}
	}
}
```

所以！

## AC code
```cpp
#include <bits/stdc++.h>
#define INTINF 2147483647
#define LLINF 9223372036854775807
typedef long long ll;
using namespace std;

const int N = 105;
int arr[N][N], sum[N][N];

int main()
{
	int n, m, s;
	cin >> n >> m >> s;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			char a;
			cin >> a;
			int f = a - '0';
			if (f == 1)
			{
				sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + 1;
			}
			else
			{
				sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
			}
		}
	}
	
	int minn = INTINF;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			for (int k = i; k <= n; k++)
			{
				for (int l = j; l <= m; l++)
				{
					if (sum[k][l] - sum[i - 1][l] - sum[k][j - 1] + sum[i - 1][j - 1] >= s)
					{
						minn = min(minn, (k - i + 1) * (l - j + 1));
					}
				}
			}
		}
	}
	if (minn == INTINF) cout << 0 << endl;
	else cout << minn << endl;
	return 0;
}
```

---

## 作者：CaiZi (赞：10)

## [GESP202406 五级] 黑白格 题解
**[题目链接](https://www.luogu.com.cn/problem/P10719)**
### 题目分析
我们先对这个网格图做一次前缀和，记作 $a_{i,j}$。然后我们考虑贪心，一个子矩阵内的数字和越大，矩阵就越大，所以我们要让这个子矩阵的数字和不低于 $k$ 的前提下，尽量让这个子矩阵小。

于是我们思路就很明确了，枚举子矩阵左上角端点和右下角纵坐标，然后二分找到最小的不低于 $k$ 的右下角横坐标，子矩阵和可以使用二维前缀和。

时间复杂度 $O(n^2m\log m)$。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,w,a[101][101],l,r,d,s=INT_MAX;
char b;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n>>m>>w;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>b;
			a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b-'0';
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int k=i;k<=n;k++){
				l=j;
				r=m;
				while(l<r){
					d=(l+r)/2;
					if(a[k][d]-a[k][j-1]-a[i-1][d]+a[i-1][j-1]>=w){
						r=d;
					}
					else{
						l=d+1;
					}
				}
				if(a[k][l]-a[k][j-1]-a[i-1][l]+a[i-1][j-1]>=w){
					s=min(s,(l-j+1)*(k-i+1));
				}
			}
		}
	}
	if(s==INT_MAX){
		cout<<'0';
	}
	else{
		cout<<s;
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/164790288)**

---

## 作者：lucasincyber (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P10719)
## 思路
很显然，这道题是一道二维前缀和。预处理出前 $i$ 行 $j$ 列中包含多少个黑色格子，判断一个区间是否有 $k$ 个黑色格子在 $O(1)$ 的时间复杂度内完成。

因为需要枚举每个区间的 $4$ 个坐标，所以时间复杂度为 $O(n^4)$，可以通过本题。

注意：无解时输出 $0$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 105;

int n, m, k, ans = 2e9;
int sum[N][N];
char mp[N][N];

int main()
{
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> mp[i][j];
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + (mp[i][j] - '0');
    for (int x = 1; x <= n; x++)
    {
        for (int y = 1; y <= m; y++)
        {
            for (int x2 = x; x2 <= n; x2++)
            {
                for (int y2 = y; y2 <= m; y2++)
                {
                    int res = sum[x2][y2] - sum[x - 1][y2] - sum[x2][y - 1] + sum[x - 1][y - 1];
                if (res >= k) ans = min(ans, (x2 - x + 1) * (y2 - y + 1));
                }
            }
        }                
    }
    if (ans == 2e9) cout << 0;
    else cout << ans;
    return 0;
}
```

---

## 作者：shangruolin (赞：6)

前置知识：二维前缀和。

令 $sum_{i,j}$ 为以 $(i,j)$ 为右下角的矩阵的和，首先可以 $O(n^2)$ 预处理前缀和，转移为 $sum_{i,j}=sum_{i-1,j}+sum_{i,j-1}-sum_{i-1,j-1}+x$。

然后暴力枚举答案矩形的左上角与右下角，$O(1)$ 查询前缀和判断是否符合条件。如果符合条件，更新答案矩阵大小。

时间复杂度 $O(n^4)$。


```cpp
signed main ()
{
	ios::sync_with_stdio (false);
	cin.tie (0); cout.tie (0);
	
	cin >> n >> m >> k;
	char x;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> x, sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + x - '0';
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			for (int x = i; x <= n; x++)
				for (int y = j; y <= m; y++) {
					int cnt = sum[x][y] - sum[i - 1][y] - sum[x][j - 1] + sum[i - 1][j - 1];
					if (cnt >= k) ans = min (ans, (x - i + 1) * (y - j + 1));
				}
	cout << (ans == 1e9 ? 0 : ans);
	return 0;
}
```

---

## 作者：Jerry_heng (赞：6)

（一）

[更佳的体验](https://www.cnblogs.com/Jh763878/p/18291977)

设 $a_{x,y}$ 为从 $(1,1)(x,y)$ 矩形中的 $1$ 的数量。

然后通过二位前缀和可以 $O(1)$ 算。

注意到 $1\le n,m \le 100$。

先确定矩形右下角，对于左上角，先确定在哪一行，再二分在哪一列。

（二）

AC 代码。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define fi first
#define se second
#define mp make_pair
#define pii pair<int,int>
#define int long long
using namespace std;
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f; 
}
int n,m,k,a[110][110],res=1e9;
signed main(){
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%1d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];
	if(a[n][m]<k){
		puts("0");
		return 0;
	}//注意特判
	for(int x=1;x<=n;x++)
		for(int y=1;y<=m;y++){
			if(a[x][y]<k)continue;
			for(int i=1;i<=x;i++){
				int l=1,r=y,ans=-1;
				while(l<=r){
					int mid=(l+r)>>1;
					if(a[x][y]+a[i-1][mid-1]-a[i-1][y]-a[x][mid-1]>=k)ans=mid,l=mid+1;
					else r=mid-1;
				}
				if(ans!=-1)res=min(res,(y-ans+1)*(x-i+1));
			}			
		}
	printf("%lld\n",res);
    return 0;
}
```

---

## 作者：Vct14 (赞：6)

简单前缀和模板题。题目可以转化为元素和大于等于 $k$ 的最小子矩阵中的元素个数。我们处理出矩阵的前缀和，然后暴力枚举子矩阵的左上和右下端点，若当前矩阵中元素和大于等于 $k$，则更新最小值。记得判不存在的情况。

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=102;
int a[N][N];
int s[N][N];

int main(){
	int n,m,k;cin>>n>>m>>k;
	for(int i=1; i<=n; i++){
		for(int j=1; j<=m; j++){
			char c;cin>>c;
			a[i][j]=c-'0';
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
		}
	}
	int mn=INT_MAX;
	for(int i1=1; i1<=n; i1++) for(int j1=1; j1<=m; j1++) for(int i2=i1; i2<=n; i2++) for(int j2=j1; j2<=m; j2++) if(s[i2][j2]-s[i1-1][j2]-s[i2][j1-1]+s[i1-1][j1-1]>=k) mn=min(mn,(i2-i1+1)*(j2-j1+1));
	if(mn!=INT_MAX) cout<<mn;
	else cout<<0;
	return 0;
}
```

附一份[官方题解](https://gesp.ccf.org.cn/101/attach/1621071558082592.pdf)。

---


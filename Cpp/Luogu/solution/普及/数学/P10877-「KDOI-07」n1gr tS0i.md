# 「KDOI-07」n1gr tS0i

## 题目背景

众所周知，小 T 不喜欢 01 串问题，于是小 R 出了另一个有关 01 串的题目：

## 题目描述

有一个长度为 $n$ 的 $\tt 01$ 串 $S$，你要对 $S$ 进行 **恰好** $n$ 次操作。每次操作选择 $1 \leq l \color{red}< \color{normal} r \leq n$，然后你按位翻转 $S_{l\dots r}$。这里的按位翻转指，$S_{l\dots r}$ 内所有 $\tt 0$ 同时变为 $\tt 1$，且所有 $\tt 1$ 同时变为 $\tt 0$。

求 $n$ 次操作后，所有可能不同的 $S$ 的个数。因为答案可能很大，所以请对 $998244353$ 取模。

## 说明/提示

### 样例解释

- 对于 $n = 2$，$S = \tt 01$，我们会发现每次操作只能选择 $l = 1, r = 2$ 即反转整串，因此 $2$ 次操作后只能得到 $\tt 01$，故答案为 $1$；
- 对于第二组数据，暂时不能给你一个明确的答复。

### 数据规模与约定

**本题采用捆绑测试。**

| $\text{Subtask}$ | $n\le$ | 分数 |
| :----------: | :----------: | :----------: |
| $1$ | $4$ | $30$ |
| $2$ | $10^5$ | $70$ |

对于所有数据，保证 $2 \leq n \leq 10^5$，$\sum n \leq 10^6$，$1 \leq T \leq 10^4$。

## 样例 #1

### 输入

```
2
2
01
30
101001001010100110101101011110
```

### 输出

```
1
75497471
```

# 题解

## 作者：xixisuper (赞：13)

# 「KDOI-07」n1gr tS0i 题解

诈骗题，采用一个先猜后证的方法。

## 思路

先说赛时思路，不难发现每个询问的答案与 01 串本身是什么样子没有半毛钱关系，然后发现题目不给第二组数据的解释，猜测答案可能很简单，而注意到  $2^{30}\bmod 998244353=75497471$，于是我们猜在 $n$ 足够大时答案就是 $2^n$。

对于小数据特殊情况，我们考虑写个暴力 dfs，发现只有 $n$ 为 $2$ 或 $3$ 时答案不为 $2^n$，其余数据都满足，直接一发特判交上，过了。

回来考虑一下为什么 $n$ 足够大时答案为 $2^n$，即 01 串为任意情况都合法。不难发现题目中 01 串长度与操作次数相等，我们考虑找到一种方法，使得确定最终 01 串中连续 $i$ 个字符所需的操作数为 $i$，这样确定 $n$ 个字符的操作数就一定为 $n$ 了。

我们考虑相邻的两个数的情况，由于我们已知 01 串本身不会影响答案个数，所以我们用 $0$ 表示与原串不同，$1$ 表示与原串相同，则相邻两个数的情况共有四种，分别是 $00,01,10,11$。经验证，发现只要串长足够，我们总能找到一种方式，使得操作 $2$ 次后，让 $00$ 变为 $00,01,10,11$ 任意一种，并且不改变其他位置的值。

详细操作如下：假设某 01 串的部分为 $(00)00$，中间括出来的为我们要操作的两数，则：

- 变为 $00$：进行操作 $[1,2],[1,2]$，改完得到 $(00)00$。
- 变为 $11$：进行操作 $[1,4],[3,4]$，改完得到 $(11)00$。
- 变为 $10$：进行操作 $[1,3],[2,3]$，改完得到 $(10)00$。
- 变为 $01$：进行操作 $[2,4],[3,4]$，改完得到 $(01)00$。

由于这种操作具有对称性，所以当最后不足两个数的时候可以转到前面，这样，在 $n$ 为偶数时最终的 01 串可以是任意的。当 $n$ 为奇数时其实也一样，我们分两种情况，要么第一次操作把 $[1,n]$ 全部改变，要么第一次操作不改变最后一个数，然后用剩下 $n-1$ 次操作改变 $[1,n-1]$ 的值，由于我们能保证用 $n-1$ 次操作能够得到 $[1,n-1]$ 的任意情况，则我们就能用 $n$ 次操作得到 $[1,n]$ 的所有情况，最终答案就是 $2^n$ 了。

反观操作的那部分，不难发现 01 串长度至少为 $4$，所以说当 $n$ 为 $2$ 或 $3$ 的时候特判就好了。

## 代码

我是蒟蒻，入门题想半天。

```cpp
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
const ll N=1e5+10;
const ll MOD=998244353;
inline ll read(){
	register ll f=1,x=0;
	register char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
ll T,n;
char s[N];
//当然这题不用快速幂也能过
ll ksm(ll a,ll b){
	ll ret=1;
	while(b){
		if(b&1) ret=ret*a%MOD;
		a=a*a%MOD;
		b>>=1;
	}
	return ret;
}
int main(){
	T=read();
	while(T--){
		n=read();
		scanf("%s",s+1);
		if(n<=3){ 
			if(n==2) printf("1\n");
			if(n==3) printf("4\n");
		}
		else printf("%lld\n",ksm(2,n));
	}
	return 0;
} 
```

---

## 作者：irris (赞：11)

## Preface

致敬传奇题目 技巧性的块速递推。

## Solution

设经过 $n$ 次操作后，生成的新字符串为 $T$。显然我们只关心 $\forall 1 \leq i \leq n$，$a_i = [S_i = T_i]$ 的值（在知道 $S$ 和 $a$ 后可以唯一确定 $T$），而我们的操作可以看做对初始全部为 $0$ 的 $a_1\dots a_n$ 修改，因此断言 $S$ 是无用的，只有 $n$ 是有用的。

### $n = 2$

已在样例解释中给出，答案为 $1$。

### $n = 3$

考虑只有 $3$ 种区间：$[1, 2]\ [1, 3]\ [2, 3]$。因为一个区间操作偶数次等于没有操作，因此可以验证操作 $3$ 次的所有可能只等价于下述四种情况：

- 操作 $[1, 2]$，$a = \tt 110$。
- 操作 $[2, 3]$，$a = \tt 011$。
- 操作 $[1, 3]$，$a = \tt 111$。
- 操作 $[1, 2]\ [1, 3]\ [2, 3]$，$a = \tt 010$。

故答案为 $4$。

### $n \geq 4$

感性理解，如果有一个目标状态 $b$，那么将 $a$ 变成 $b$ 大约要花 $\frac n2 + C$ 的操作次数。

在操作 $n$ 次的情况下，如果一个状态 **最小** 可以花费不超过 $n - 2$ 次操作或恰好花费 $n$ 次操作得到，那一定可以通过 $n$ 次得到，证明是由于 $2p + 3q = t$ 的非负整数解存在性，而我们显然分别存在可以使得：「连续操作 $2$ 次后，$a$ 保持不变」和「连续操作 $3$ 次后，$a$ 保持不变」的方案。

那么渐进意义下，答案在 $n$ 很大时，应当直接变为 $2^n$。

假设我们将 $b$ 划分为 $k$ 个连续段，那么经过简单的计算，如果我们选择 $\lfloor \frac{k - 1}{2} \rfloor$ 次操作，每次操作分别选择 $l, r$ 为最左的、最右的 $a_i \neq b_i$ 的位置，这样操作后最多剩余 $1$ 个 $a_i \neq b_i$ 的连续段。若连续段的长度不为 $1$，最多使用 $1$ 次操作；否则，我们存在方案可以使用 $2$ 次操作和 $3$ 次操作，那么只要 $\lfloor \frac{k - 1}{2}\rfloor + 2 \leq n$ 就一定有解（考虑两个数 $\lfloor\frac{k - 1}{2}\rfloor + 2$，$\lfloor\frac{k - 1}{2}\rfloor + 3$，在前者不超过 $n$ 时，每个数都大于 $n$ 或等于 $n - 1$ 的不合法情况不可能出现）。

---

如何实行 $2$ 次操作：

$$\color{#36a022}{\rule{10px}{10px}} \color{blue}\underline{\color{#983533}{\rule{10px}{10px}} \color{#36a022}{\rule{10px}{10px}} \color{#36a022}{\rule{10px}{10px}}}$$

$$\color{#36a022}{\rule{10px}{10px}} \color{#36a022}{\rule{10px}{10px}} \color{blue}\underline{\color{#983533}{\rule{10px}{10px}} \color{#983533}{\rule{10px}{10px}}}$$

$$ \color{#36a022}\rule{10px}{10px} \color{#36a022}\rule{10px}{10px} \color{#36a022}\rule{10px}{10px} \color{#36a022}\rule{10px}{10px} $$

在 $n \geq 4$ 时总是能做到。

如何实行 $3$ 次操作：

$$\color{#36a022}{\rule{10px}{10px}} \color{blue}\underline{\color{#983533}{\rule{10px}{10px}} \color{#36a022}{\rule{10px}{10px}}}$$

$$ \color{blue}\underline{\color{#36a022}{\rule{10px}{10px}} \color{#36a022}{\rule{10px}{10px}}} \color{#983533}{\rule{10px}{10px}}$$

$$ \color{blue}\underline{\color{#983533}\rule{10px}{10px} \color{#983533}\rule{10px}{10px} \color{#983533}\rule{10px}{10px}}$$

$$ \color{#36a022}\rule{10px}{10px} \color{#36a022}\rule{10px}{10px} \color{#36a022}\rule{10px}{10px}$$

（$k = 1$ 的情况是简单的）这时你会发现若 $k = 2$ 则有可能无法实行 $3$ 次操作，这形如 $\texttt{00\dots 01}$，而这时的最小操作步数是 $2$，$2p + 3q = n - 2$ 依旧有解。于是这不会影响答案。

---

由于 $k \leq n - 1$，则 $\lfloor \frac{n}{2} \rfloor + 1 \leq n$，显然在 $n \geq 4$ 时合法，所以此时答案为 $2^n$。

---

## 作者：nightwatch.ryan (赞：7)

### 思路
打表出奇迹。

首先，我们考虑将 $\tt 01$ 串 $S$ 变成全 $\tt 0$ 串。

最坏的情况下是 $\tt 1$ 和 $\tt 0$ 交替出现，因为题目要求不能单独一个 $\tt 1$ 或 $\tt 0$ 反转，至少要选择两个及以上的位。

考虑 $\tt 0101010$ 这种情况：

第一步，选择 $l = 3,r = 5$，让串变为 $\tt 0110110$。

第二步，选择 $l = 2,r = 3$，让串变为 $\tt 0000110$。

第三步，选择 $l = 5,r = 6$，让串变为 $\tt 0000000$。

显然，对于最劣的情况，我们用上述方法至多使用 $\lfloor \dfrac{n}{2} \rfloor$ 次操作即可将 $\tt 01$ 串 $S$ 变为全 $\tt 0$ 串。

接下来我们还可以进行 $n - \lfloor \dfrac{n}{2} \rfloor$ 次操作。我们反过来想：
- 对于任意一个长度为 $n$ 的 $\tt 01$ 串，我们可以利用至多 $\lfloor \dfrac{n}{2} \rfloor$ 次操作将次 $\tt 01$ 串变为全 $\tt 0$ 串。反过来说就是对于一个长度为 $n$ 的 $\tt 01$ 串，**我们可以利用至多 $\lfloor \dfrac{n}{2} \rfloor$ 次操作将其变为任意一个长度为 $n$ 的 $\tt 01$ 串**。

显然的，长度为 $n$ 的 $\tt 01$ 串有 $2^{n}$ 个，因为每一位都可以选择 $\tt 0$ 或 $\tt 1$。

但是，本题有特例：
- 对于 $n = 2$ 的情况，可以参考本题的样例解释。
- 对于 $n = 3$ 的情况，只有 $\tt 010$，$\tt 110$，$\tt 111$，$\tt 011$ 这四种可能性。

总结一下：
- 对于 $n = 2$ 的情况，答案是 $1$。
- 对于 $n = 3$ 的情况，答案是 $4$。
- 对于 $n \ge 4$ 的情况，答案是 $2^{n}$。

可以用快速幂计算答案，时间复杂度 $O(T \times \log n)$。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

#define P(i,a,b) for(int i=a;i<=b;i++)
#define Q(i,a,b) for(int i=a;i>=b;i--)
const int maxn = 100005;
const int inf = 0x3f3f3f3f;
const int mod = 998244353;

int qpow(int a,int b){
    int result = 1;
    while(b){
        if(b & 1){
            result = (result * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return result;
}

signed main(){

    cin.tie(0)->sync_with_stdio(0);
    int T;
    cin >> T;
    while(T--){
        int n;
        cin >> n;
        string x;
        cin >> x;
        
        if(n == 2){
            cout << 1 << endl;
        }else if(n == 3){
            cout << 4 << endl;
        }else{
            cout << qpow(2,n) << endl;
        }
    }

}
```

---

## 作者：XuYueming (赞：5)

## 前言

题目链接：[洛谷](https://www.luogu.com.cn/problem/P10877)。

[更好的体验](https://www.cnblogs.com/XuYueming/p/18364388)。

想了一个小时，想到后只用 $1$ 分钟过了的题。

官方题解过于晦涩，看到一篇很清晰的题解，于是写题解以记之。

~~终于遇到时间瓶颈在输入的题目。~~

## 题意简述

有一个长度为 $n$ 的 $\tt 01$ 串 $S$，你要对 $S$ 进行 **恰好** $n$ 次操作。每次操作选择 $1 \leq l {\color{red}{<}} r \leq n$，然后按位翻转 $S_{l\dots r}$。

求 $n$ 次操作后，所有可能不同的 $S$ 的个数模 $998244353$ 的余数。$2 \leq n \leq 10^5$。

## 题目分析

经过大量模拟，发现在 $n \geq 4$ 时答案就是 $2^n$，于是愉快地过了这题。考虑证明。

发现既然为 $2^n$，说明最终能到达所有长为 $n$ 的 $\tt 01$ 串，由于操作的可逆性，所有 $\tt 01$ 串是能够相互转化的。换句话说，和输入的 $S$ 是没有关系的。自然把问题转移到一个新的 $\tt 01$ 串 $T$ 上，其每一位表示 $S$ 的这一位和最终的串的这一位相等或是不等。要证明答案是 $2^n$，说明我们总能从全 $0$ 串变成任意的 $T$。

考虑用归纳法。由于操作长度要 $\geq 2$，假设前 $n - 2$ 已经匹配，我们要用恰好 $2$ 次操作弄好后两位。现在要做的就是分类讨论这 $2$ 位可能的 $4$ 种情况，并构造出对应的操作。为了方便表述，不妨拿出这 $2$ 位和后面相邻的 $2$ 位，构成长度为 $4$ 的子串。

1. 形如 $\tt 00xx$。  
  两次操作分别是：$[1, 2]$，$[1, 2]$。
1. 形如 $\tt 01xx$。  
  两次操作分别是：$[2, 4]$，$[3, 4]$。
1. 形如 $\tt 10xx$。  
  两次操作分别是：$[1, 4]$，$[2, 4]$。
1. 形如 $\tt 11xx$。  
  两次操作分别是：$[1, 4]$，$[3, 4]$。

要完成以上操作，必要的条件是 $n \geq 4$。如果此时没有后两位 $\tt xx$ 的辅助，我们可以借用前面的两位。

自此，我们证明了结论对于 $\geq 4$ 的所有偶数是成立的。当 $n$ 为奇数时，如果最后一位是 $1$，就随便翻转 $[k, n]$，其中 $k$ 是 $[1, n - 1]$ 里任意一位，先把最后一位满足了，对于前 $n - 1$ 位再用之前的方法搞好；如果最后一位是 $0$，那就浪费一次操作，任选 $l < r < n$，翻转 $[l, r]$ 即可。

证明就结束了，十分简单。再用形式化的语言表达答案：

$$
ans = \begin{cases}
1  & \text{ if } n=2 \\
4  & \text{ if } n=3 \\
2^n  & \text{ if } n \geq 4
\end{cases}
$$

算法时间复杂度为 $\Theta(\log n)$，但是输入有瓶颈，是 $\Theta(n)$ 的。

## 代码

```python
t = int(input())
while t:
    n = int(input())
    input()
    if n == 2:
        print(1)
    elif n == 3:
        print(4)
    else:
        print((1 << n) % 998244353)
    t -= 1
```


以及：

```python
o=input
for _ in range(int(o())):n=int(o());o();print({2:1,3:4}.get(n,(1<<n)%998244353))
```

---

## 作者：MafuyuQWQ (赞：4)

观察题目中所给的操作可以发现实际上 $ l = r $ 的反转操作是可以进行的，只不过代价变为了 $ 3 $。比如反转第 $ i $ 位，只要执行 $ [i - 1,i] $，$ [i,i + 1] $，$ [i - 1,i + 1] $ 的反转操作即可。于是可以发现实际上答案是与给定字符串无关的。

当 $ n $ 十分大时，如果进行 $ n - 2 $ 次操作，可以得到一种新的 $ S $，那么一定可以在恰好进行 $ n $ 次操作时，得到 $ S $。只要用上述的操作替换一部分较长的反转操作中的位置即可。

则当 $ n $ 特别大时，答案即为 $ 2^n $ 种。

假设操作 $ n $ 次之后的串为 $ S1 $，考虑将其分为 $ k $ 段，进行 $ \lfloor \frac {k - 1} {2} \rfloor $ 次操作，每次选中最左边和最右边 $ S $ 与 $ S1 $ 不同的位置作为 $ l $ 和 $ r $ 进行反转，这样可以使最后剩下一个 $ S $ 与 $ S1 $ 不同的连续段，然后与反转 $ 1 $ 位类似地，可以通过不超过 $ 3 $ 次操作使其相同，则当 $ \lfloor \frac {k - 1} {2} \rfloor + 3 \le n $ 时，答案为 $ 2^n $。

手玩一下，可以发现上面那个式子实际等价于 $ n \ge 4 $。所以当 $ n \ge 4 $ 时，答案为 $ 2^n $；当 $ n = 3 $ 时，可模拟求出答案为 $ 4 $；当 $ n = 2 $ 时，通过样例得到答案应为 $ 1 $。
```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n;

signed main()
{
	int T;
	cin >> T;
	while (T -- )
	{
		int n;
		cin >> n;
		string s;
		cin >> s;
		if (n == 2)
		{
			cout << 1 << '\n';
			continue;
		}
		else if (n == 3)
		{
		    cout << 4 << '\n';
		    continue;
		}
		int res = 1;
		for (int i = 1; i <= n; i ++ ) (res *= 2) %= 998244353;
		
		cout << res << '\n';
	}
	
	return 0;
}
```

---

## 作者：lichenxi111 (赞：4)

先声明一下：本文章为本人赛时思路，不保证与所有人的**思路顺序**相同，但保证正确性。

## 思路

在样例中：

输入：

```cpp
2
2
01
30
101001001010100110101101011110
```

输出：


```cpp
1
75497471
```

我们发现 $75497471 + 998244353 = 2 ^ {30}$，难道答案是 $2 ^ {n}$？

打表：

|字符串长度|$2$|$3$|$4$|$5$|$6$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|答案|$1$|$4$|$16$|$32$|$64$|

貌似当 $n \ge 4$ 时，答案就是 $2 ^ {n}$，然后特判 $n = 2$ 和 $n = 3$。

考虑如何证明：我们要明白，在本题统计不同方案时，我们只关心每个数的**变化**，具体地，就是一个字符只会在改变和不改变出现两种方案，所以字符串是什么样都无所谓。

我们又发现，$n \ge 4$ 时，$n$ 次操作可以做到控制每个字符改变或不改变。

每个数都有两种选择，$n$ 个数有 $2 ^ {n}$ 种选择。

综上：

|$n$|$2$|$3$|$\ge 4$|
|:-:|:-:|:-:|:-:|
|答案|$1$|$4$|$2 ^ {n}$|

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 998244353;
int qpow(int base,int p,int K)
{
	long long ans=1,tmp=base;
	while(p!=0)
    {
		if(p&1)
        {
			ans = (ans%K*tmp%K)%K;
		} 
		tmp = (tmp%K*tmp%K)%K;
		p=p>>1;
	} 
	ans=ans%K;
	return ans;
} 
signed main()
{
	int T;
	cin >> T;
	while(T--)
	{
		int n;
		cin >> n;
		string s;
		cin >> s;
		if(n == 2)
		{
			cout << 1 << endl;
			continue;
		}
		if(n == 3)
		{
			cout << 4 << endl;
			continue;
		}
		cout << qpow(2,n,mod) << endl;
	}
	return 0;
}
```

---

## 作者：Blikewsr (赞：2)

### 题目简述
有一个长度为 $n$ 的 $\tt 01$ 串 $S$，要进行 $n$ 次操作。每次操作选择 $1 \leq l < r \leq n$，将 $S_{l\dots r}$ 内所有 $\tt 0$ 变为 $\tt 1$，所有 $\tt 1$ 变为 $\tt 0$。需要求操作后不同的 $\tt 01$ 串 $S$ 的个数，并对 $998244353$ 取模。

### 思路讲解

**分类讨论 + 变换操作**

已知 $1 \leq l < r \leq 2$
- $n$ 为 **偶数**
  
  举个例子，字符串为 $\tt 1011$。

  如果我们想要 **末尾字符** 对第 $4$ 的字符做取反操作，即要使最终字符串为 $\tt 1010$，但因为 $1 \leq l < r \leq n$，所以直接对某一位进行操作是做不到的。但我们可以先对字符串 $[1,3]$ 进行 $n - 1$ 次（奇数）取反操作，这样就成了 $\tt 0101$，最后一次（奇数）操作直接对整个字符串进行取反操作，就得到了 $\tt 1010$。这个方案对于首位取反操作同样成立。
  
  当然，如果是对于字符串 **中间字符** 做取反操作，如：对第 $2$ 位取反（即要得到 $\tt 1111$），我们可以先对 $[1,2]$ 进行 $1$ 次（奇数）操作，在对 $[2,4]$ 进行 $1$ 次（奇数）操作，得到 $\tt 0000$，对于剩下的两次（偶数）操作，随便将字符串分为两份分别整体操作一次就得到了 $\tt 1111$。但这个情况中，我们很容易知道，如果要完成这个操作，必须要满足 $n \ge 4$。

  对于 $n = 2$ 的情况（即字符串长度为 $2$），所以 $1 \leq l < r \leq 2$，显然 $l = 1, r = 2$，因为要进行 $2$ 操作，所以执行完第二次操作之后的字符串的可能只有一种，而且与原字符串相同，此时答案为 $1$。
  
  于是的，我们可以发现，对于长度大于 $4$ 且为偶数的字符串每一个字符都可以由 $n$ 次操作来实现单个字符取反，同时在 $n$ 次操作后也可以得到该长度的 $\tt 01$ 串的所有搭配方案，那么该情况的答案就是 $2^{n}$。

- $n$ 为 **奇数**

  同理 **偶数** 的情况，依然可以推出在 $n$ 次（奇数）操作内能将任意一个位上字符取反，同时也可以在 $n$ 次操作后得到长度为奇数（长度为 $3$ 除外）的 $\tt 01$ 串的所有搭配方案，那么该情况的答案就也是 $2^{n}$

  对于 $n = 3$ 的情况，所以 $1 \leq l < r \leq 3$，显然无论我们如何选择操作区间，第 $2$ 位的字符始终包含在区间内，有因为是奇数次操作，所以最终的所有情况的字符串的第 $2$ 位一定是一样的，那么只有第 $1$ 位和第 $3$ 位可能不同，根据 **乘法原理**，可知此时答案为 $2 \times 2 = 4$。
  
  于是的，我们一样可以发现，对于长度大于 $5$ 且为奇数的字符串每一个字符都可以由 $n$ 次操作来实现单个字符取反，同时在 $n$ 次操作后也可以得到该长度的 $\tt 01$ 串的所有搭配方案，此时答案与偶数情况一样都是 $2^{n}$。

### 代码实现
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 998244353;    // 记得取模
int T, n, tot;
string str;
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> T;   // 多组数据
    while (T --) {
        cin >> n;   // 字符串长度
        cin >> str;   // 读入字符串，但没用
        tot = 1; 
        if (n == 2) cout << "1" << endl;   // 特殊情况
        else if (n == 3) cout << "4" << endl;  // 特殊情况
        else {
            for (int i = 1; i <= n; ++ i) 
                tot = tot * 2 % mod;  // 一般情况为 2 的 n 次方
            cout << tot << endl;
        }
        
    }
    return 0;
}
```

- 题解仅供参考，若有错误，欢迎指正，谢谢！

---

## 作者：rsg26 (赞：2)

太愚蠢了，给网友讲这题构造时讲错了（

枚举 $n=2, 3$，答案为 $1, 4$。

考虑 $n\ge 4$，任意序列均可以为合法答案，答案为 $2^n$，证明如下：

定义**全局翻转**为将整个序列的每一位取反，具体而言，有两种方式：

* 操作 $[1, n]$，花费一次操作；
* 操作 $[1, 2], [3, n]$，花费两次操作。

定义**全局维持**为保持序列不变的情况下进行操作，即使用两次全局翻转，花费两次或三次操作。

【**步骤一**】我们考虑结果序列与初始序列不同的位置，如果大于 $\lfloor \frac n2\rfloor$ 那么进行全局翻转。

【**步骤二**】随后，不同的位置一定小于等于 $\lfloor \frac n2\rfloor$ 个，我们对于任意一个这样的位置 $i$：

* 如果 $i \le n - 2$，操作 $[i, n], [i+1,n]$，花费两次；
* 如果 $i \ge 3$，操作 $[1, i], [1, i-1]$，同样花费两次操作。

【第一类】显然以上两类情况覆盖了 $[1, n]$ 中的所有 $i$，所以可以使用两次操作每将一个位置取反。

* 如果 $i \neq 1, n$，操作 $[1, n], [1, i], [i, n]$ 花费三次；
* 如果 $i = 1$，操作 $[1, 2], [3, n], [2, n]$，同样花费三次操作；
* 如果 $i = n$，操作 $[n - 1, n], [1, n - 2], [1, n - 1]$，还是花费三次操作。

【第二类】显然以上三类情况覆盖了 $[1, n]$ 中的所有 $i$，所以可以使用三次操作每将一个位置取反。

【**步骤三**】那么对于剩下的操作次数，可以使用若干次全局维持来消耗掉。

显然如上过程的操作都是合法的，只需要说明可以做到恰好 $n$ 个操作。

* 如果 $n$ 是偶数而且不同的的个数恰为 $\frac n2$，那么不会进行步骤一，而步骤二第一类恰好进行 $\frac n2 \times 2=n$ 次操作，故无需进行步骤三，符合条件；
* 对于其他情况，如果不同的个数 $\le \lfloor \frac n2\rfloor$，那么不进行步骤一，步骤二第一类进行的操作次数最多为 $\lfloor \frac n2 \rfloor\times 2$，由于排除了上一种情况，显然会剩余一些操作。如果 $n$ 为奇数且没有不同的位置，那么剩余的操作次数 $\ge 5$ 且为奇数，则进行三次操作的全局维持后进行若干次两次操作的全局维持。如果 $n$ 为奇数且有不同的位置，说明步骤二第一类进行了操作，将其中一个第一类替换成第二类后剩余的操作次数减一变为偶数，用两次操作的全局维持来消耗掉。如果 $n$ 为偶数，剩余的操作次数为偶数，用两次操作的全局维持消耗；
* 对于剩余的情况，即不同的个数 $\ge \lfloor \frac n2\rfloor$，先根据 $n$ 是奇数还是偶数选择进行一次还是两次操作的全局翻转，随后进行步骤二第一类，操作次数至多为 $\lfloor \frac n2 \rfloor\times 2$，此时还会剩余偶数次操作，使用两次操作的全局维持若干即可。

综上所述，$n\ge 4$ 时任意结果序列都是合法的，证毕。

代码略，$\Theta(n)$ 预处理一下回答就行了。

---

## 作者：be_RISK (赞：1)

[luogu P10877](https://www.luogu.com.cn/problem/P10877)
### 考场思路（我的）
首先不难看出答案只与 $n$ 有关，与 $S$ 无关，应为显然，$S$ 异或上两个不同的经过 $n$ 次操作得出的[**操作 01 串**](https://www.luogu.com.cn/paste/gwyc7dp1)答案是不同的，所以最后的不同的 $S$ 的数量是等于经过 $n$ 次操作得出的操作 01 串的个数是相同的，然而经过 $n$ 次操作得出的操作 01 串的数量只与 $n$ 有关。

接着，知道了答案只与 $n$ 相关后，就可以开始暴力找规律，可以发现，从 $n=4$ 开始，答案为 $2^n$，而 $n=2$ 答案为 $1$，$n=3$ 时，答案为 $4$。

此时你就可以特判加使用快速幂 AC 了。

但你以为完了吗？
### 正解思路

首先，本身，长度为 $n$ 的不同 01 串的个数为 $2^n$，那为什么 $n\ge 4$ 时可以所有都做到呢？我们直接来看最难异或出来的操作 01 串：

$$
\color{black}{1111}\ \color{black}{1111}\\
xor\ \ \ xor\\
\color{black}{0111}\ \color{black}{1110}\\
xor\ \ \ xor\\
\color{black}{1111}\ \color{black}{1100}\\
xor\ \ \ xor\\\ 
\color{black}{1111}\ \color{black}{0011}\\
=\ \ \ \ \ =\\
\color{black}{1000}\ \color{black}{1110}
$$

所以，最难异或出来的操作 01 串最少要 $4$，同时从上面的例子可以看出来，可以两个三个的消掉，即去掉多余的，所以当 $n\ge 4$ 时，即可将操作 01 串全部异或出来。

### code
特简单
```c++14
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
inline int read(){
	char c=getchar();
	int ret=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		ret=(ret<<3)+(ret<<1)+c-'0';
		c=getchar();
	}return ret*f;
}
inline void write(int x,int op){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10,0);
	putchar((char)(x%10+'0'));
	if(op){
		if(op>0)puts("");
		if(op<0)putchar(' ');
		if(op==0)puts("114514");
	}
}
int T;
int n;
string s;
int qpow(int a,int b){
	int ret=1;
	while(b){
		if(b&1)ret=ret*a%mod;
		a=a*a%mod;
		b>>=1;
	}return ret%mod;
}
signed main(){
	T=read();
	while(T--){
		n=read();
		cin>>s;
		if(n==2)write(1,1);
		else if(n==3)write(4,1);
		else write(qpow(2,n)%mod,1);
	} 
	return 0;
}//~*完结撒花*~
```

---

## 作者：Problem1613end (赞：0)

+ 本题因为求种数，所以原串无关。
+ 本题构造使用暴力可验证，当一个串长度为 $4$ 时，我们一定可以用两次操作不改变一边的两位而改变另一边的两位，如此，偶数位的串每次两位两位修改，一定可用其长度的操作来改成任意同长串（注意不包括 $2$）。
+ 同时，奇数串在基于可以用 $5$ 次操作对长度为 $5$ 的串获得任意同长串的前提下，也可获得任意同长串（注意不包括 $1$ 和 $3$）。
+ 表
  ```
  2 1
  3 4
  4 16
  5 32
  6 64
  7 128
  8 256
  9 512
  10 1024
  ```
综上，串长超过 $4$ 的串可转化为任意同长串，即 $ans=2^n$。

特判 $2$，$3$。

代码
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll t,n,mod=998244353;
string s;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n;
		cin>>s;
		if(n==2)  cout<<1<<endl;
		else  if(n==3)  cout<<4<<endl;
		else{
			ll ans=1;
			for(int j=1;j<=n;j++){
				ans=(ans*2)%mod;
			}
			cout<<ans<<endl;
		} 	
	}
	return 0;
}
```
突然发现表打到 $7$ 后，$4$ 到 $7$ 的串可以拼成长度大于 $4$ 任意长的串，可以更轻松用表来证 $ans=2^n$。

---

## 作者：lihl (赞：0)

### 分析
分析题意，先写第一个部分分。

$n=2$ 时，样例给出答案为 $1$。

$n=3$ 时，手动模拟可得，仅会出现 $011$，$010$，$100$，$111$ 这四种情况。

$n\ge 4$ 时，不妨观察 $n=30$，发挥注意力可得 $2^{30} \bmod 998244353 = 75497471$。

猜结论，$n\ge4$ 时答案为 $2^n$。

第二个部分分。

不妨推广 $n>4$ 结论，我们实质上在全程不关心 $S$，仅仅关于 $n$ 推断结论，于是我们舍去不看。

在区间内的操作实质上是对 $n=2$，$n=3$ 时情况的一种连接，题目其实等价于对一个全 $0$ 串恰好进行 $n$ 次操作，求有几种可能。

在对于 $n\ge4$ 的情况时，我们发现实质上最多存在 $\cfrac{n}{2}$ 个不连续的 $1$。递推发现对于此种情况，$2$ 次操作恰能修改单点，故推断成立，不难发现有 $2^n$ 种修改方案。

---

## 作者：ztrztr (赞：0)

**强烈推荐**在[我的博客](https://ztrztr.top/archives/753)读这个题解。

个人认为这道题没有黄的难度。

## 思路

我先看了 $n=30$ 的样例，有一个猜想是答案是 $2^n$，然后用计算器算了一下 $n=30$ 的这个数据发现猜想是对的。

但是如果 $n=2$ 的情况发现不是这样的，所以又猜测只有当 $n$ 大于一个界限的时候才是 $2^n$。

首先，$n = 2$ 的情况样例已经给了，答案是 $1$，因为这个长度的 $01$ 串只有可能操作 $1$ 次，所以只有可能有 $1$ 种答案。

当 $n = 3$ 的时候，答案只有可能是操作这几个区间：$[1.2]$，$[2,3]$，$[1,3]$ 或者操作这三次 $[1,2],[2,3],[1,3]$。也就是说答案是 $4$。

当 $n \geq 4$，那么我们发现可以对这个串的每一位都进行组合的翻转。就拿 $n = 4$ 的情况来举例，比如说我们要翻转第 $1$ 个数字，那么我们可以先翻转 $[1,3]$，然后再翻转 $[2,3]$ 来把之前对 $[2,3]$ 多余的翻转给转回来，这样做的效果就是翻转 $[1,1]$。

可以发现，对于所有 $n \geq 4$ 的，我们可以通过上述操作翻转 $S$ 的每一位，那么答案就是 $2^n$，这些情况可以用快速幂都解决，注意由于 $n$ 有时候过于大所以不能用预处理。
## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
/*
*/
#define ll unsigned long long
ll p(ll a, ll b, ll q) {
    ll res = 1;
    while (b) {
        if (b & 1) res = (res * a) % q;
        a = (a * a) % q;
        b >>= 1;
    }
    return res % q;
}
int main() {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int T; cin >> T;
    while (T --) {
        int n; string s; cin >> n >> s;
        if (n == 2) cout << "1\n";
        else if (n == 3) cout << "4\n";
        else cout << p(2, n, 998244353) << "\n";
    }
    return 0;
}
```

---

## 作者：__O_w_O__ (赞：0)

做题方针：首先把题目过了，然后再考虑证明。

好你读完题目之后直觉上觉得很像 $2$ 的幂次然后写了个快速幂，输入 $n$ 输出 $2^n$，然后验证了一下样例，发现 $2$ 的话应该是 $1$，然后你特判了一下然后提交了然后答案错误 $0$ 分了。

你痛定思痛决定进行接着找规律，你用十分钟写了一个深搜然后跑了一下，震惊地发现除了 $2$ 和 $3$ 其他的都是 $2$ 的幂次，然后你大胆的交了一发然后就通过了

但是这是个数学题，虽然打表可以做出来，但是还是要说一下证明的：

首先，不难将题目中的 $01$ 串转化成有一个长度为 $n$ 的全 $0$ 字符串（也就是说答案和字符串 $S$ 是没有关系的）。

当长度大于等于 $4$ 时，任意两次以上可以抵消。题目可以看作操作 $1-n$ 次。

当长度大于等于 $4$ 时，两次修改可修改单点。

易证对于任意一种情况，不连续的 $1$ 最多只有 $\frac{n}{2}$ 个，所以所有情况的可行。

```cpp
#include<iostream>
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define endl "\n"
#define mod 998244353;
using namespace std;
int my_pow(int a, int b){
    int ans = 1;
    while(b>0){
        if(b%2)ans=(1LL*ans*a)%mod;
        a=(1LL*a*a)%mod;
        b/=2;
    }
    return ans;
}
int main(){
    IOS;
    int T;cin>>T;
    while(T--){
        int n;
        string s;
        cin>>n>>s;s='?'+s;
        if(n==2)cout<<1<<endl;
        else if(n==3)cout<<4<<endl;
        else cout<<my_pow(2,n)<<endl;
    }
    return 0;
}
```

---


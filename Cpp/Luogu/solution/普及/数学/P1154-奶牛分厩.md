# 奶牛分厩

## 题目描述

农夫约翰有 $N(1 \le N \le 5000)$ 头奶牛，每头奶牛都有一个唯一的不同于其它奶牛的编号 $s_i$，所有的奶牛都睡在一个有 $K$ 个厩的谷仓中，厩的编号为 $0$ 到 $K-1$。每头奶牛都知道自己该睡在哪一个厩中，因为约翰教会了它们做除法，$S_i  \bmod  K$ 的值就是第 $i$ 头奶年所睡的厩的编号。

给出一组奶牛的编号，确定最小的 $K$ 使得没有二头或二头以上的奶牛睡在同一厩中。


## 说明/提示

$S_i(1\le S_i \le 1000000)$


## 样例 #1

### 输入

```
5 
4 
6 
9 
10 
13 
```

### 输出

```
8```

# 题解

## 作者：Makasukaka (赞：91)

## ### 注意！上一篇“飞翔”的题解有误！

首先a,b在mod k 意义下同余，当且仅当 k|(a-b) 即k是(a-b)的一个因子。

这个证明可以考虑mod运算的意义。也可以a%k=b%k 等价于
a-b=0(mod k) 。

因为s<=1e6 所以可以预处理出所有差值，并把他们打上标记。

从小到大枚举，如果一个数x未被标记，那么我们就看他的λ倍是否被标记。λ是枚举的。

如果都没被标记，则说明x是合法的。输出x即可。

关于复杂度，尽管我们枚举了k倍。但运行次数应该是s/2+s/3+s/4...+s/s 根据调和级数

![](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D148/sign=0bbdefa21ece36d3a604873402f33a24/b90e7bec54e736d17f269f7090504fc2d5626994.jpg)

这东西在OI里可以视作log级的

所以复杂度就是O(n^2+slogs) s是数域大小。

至于“飞翔”的题解，没有考虑k是a-b因子的情况。对于数据
a=16,b=6 正确应该输出3，而不是2。

为啥没有卡掉可能是数据有些水。。

codes:
```cpp
#include<cstdio>
#include<cstdlib>
const int N=5e3+5,K=1e6+5;
int a[N],vis[K],n;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;++i){
        for(int j=i+1;j<=n;++j){
            int cur=abs(a[i]-a[j]);
            vis[cur]=1;
        }
    }
    for(int i=n;i<K;++i){
        if(!vis[i]){
            int f=1;
            for(int j=i;j<K;j+=i)if(vis[j]){f=0;break;}
            if(f){
                printf("%d\n",i);
                return 0;
            }
        }
    }
    return 0;
}

```

---

## 作者：陈见澍 (赞：36)

## 题目描述
让我们来化简题目：给定数列S，求最小的K，使所有 $S_i$ $mod$ $k$ 不同。
### 输入格式
第一行一个正整数$N$，第$2$到$N+1$行每行一个整数表示一头奶牛的编号。
### 输出格式
一个整数，表示要求的最小的$K$，对所有的测试数据这样的$K$是一定存在的。（保证没有无解~~不怀好意~~的数据数据了。）

好的！我们读完题了。现在开始讲解题思路。


------------

首先说一下：$a≡b$ ($mod$ $k$) (此处$k≠0$)表示$a$与$b$除以$k$有相同的余数。（更直白地说就是$a \bmod k=b \mod k$），$a|b$ 为$a$整除$b$，即$a$是$b$的因数。

那么，要求任意两头或以上的奶牛不在同一个厩中，就是使所有 $S_i$ $mod$ $k$ 不同，很直观，可以用暴力枚举。但是不幸的是：
### 会超时TLE /(ㄒoㄒ)/~~
所以我们就放弃这个思路。。

那么正面入手不行，我们就从反面入手。既然要使使所有 $S_i \bmod k$ 不同，那就找出所有使 $S_i \bmod k$ 相同的$k$。可是怎么找呢？不用慌，因为我们知道：


如果 $a \equiv b \pmod k$ ($a>b$)，那么就有$k|(a-b)$。

(简单证明一下：设 $a=pk+r,b=qk+r(a>b)$，则 $a-b=(pk+r)-(qk+r)=(p-q)k$，为 $k$ 的倍数，即 $k$ 为 $(a-b)$ 的因数。)

所以，我们只要把所有任意两个数的差的**绝对值**求出来（即$\left\vert S_i-S_j\right\vert$，因为怕 $S_i$ 比 $S_j$ 小。），并把它的所有因数都打上标记，最后再找出最小的没被标记的数，把它输出，就行了。

下面附上代码：
```cpp
#include<bits/stdc++.h>
#define MAX (1000001)
using namespace std;
int n,a[MAX],d[MAX];
int main()
{
	int i,j,k,x;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(i=1;i<n;i++)
	{
		for(j=i+1;j<=n;j++)
		{
			x=abs(a[i]-a[j]);
			for(k=1;k*k<=x;k++)
			{
				if(!(x%k))
				{
					d[k]=d[x/k]=1;
				}
			}
		}
	}
	for(i=1;d[i];i++);
	printf("%d\n",i);
	return 0;
}
```
结果发现，是50分/(ㄒoㄒ)/~~ ，AC五个，TLE5个。。。


------------

所以改变一下思路：只标记所有的差值，然后从1开始枚举，判断枚举的数是否为已标记的数的因数，如果不是，那就输出它，并return 0。(至于时间复杂度……可以看看其他大佬的题解。)

$code↓:$
```cpp
#include<bits/stdc++.h>
#define MAX (1000001)
using namespace std;
int n,a[MAX],d[MAX];
int main()
{
	int i,j,k,x;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(i=1;i<n;i++)
	{
		for(j=i+1;j<=n;j++)
		{
			d[abs(a[i]-a[j])]=1;
		}
	}
	for(i=1;i<MAX;i++)
	{
		x=1;
		for(j=i;j<MAX;j+=i)
		{
			if(d[j])
			{
				x=0;
				break;
			}
		}
		if(x)
		{
			printf("%d\n",i);
			return 0;
		}
	}
	return 0;
}
```

（注：如有不妥之处，请大家指出，谢谢！）

---

## 作者：Uniontake (赞：10)


    1<=N<=5000

    Si(1<=Si<=1000000)

注意这题不满足 二分答案的性质 :当 k = 奶牛中编号最大的那个时 保证所有数余他都是唯一的，但在n到kmax之间

小的不满足，不代表大的就满足，所以不能二分答案

于是考虑 筛法。

由定理  ：若 a % k == b % k 则 k|(a-b);

证明 ： a % k = b % k =>  a=k\*ta+b  b=k\*tb+b; 则 a-b = k(ta-tb); 所以 k|a-b;


用vis[]数组标记 所有 cattle[j]-cattle[i];并记录差值。

从小到大遍历vis i：如果未标记(还不能判读他是因子),就遍历差值表;如果都不是差值表的因子

则这就是答案。


时间复杂度 : o(n^2 + m\*cnt)



```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 1000005;
int cattle[maxn];
int vis[maxn],cha[maxn];
int n,cnt;
int main()
{
    while(~scanf("%d",&n))
    {
        cnt = 0;
        memset(cattle,0,sizeof(cattle));
        memset(vis,0,sizeof(vis));
        for(int i=0;i<n;i++) scanf("%d",&cattle[i]);
        sort(cattle,cattle+n);
        for(int i=0;i<n-1;i++)
            for(int j=i+1;j<n;j++)
            {
                if(!vis[cattle[j]-cattle[i]]) {
                    vis[cattle[j]-cattle[i]] = 1;
                    cha[cnt++] = cattle[j]-cattle[i];
               }
            }
        for(int i=2;i<=cattle[n-1];i++)
        {
            if(!vis[i]){
                bool flag = true;
                for(int j=0;j<cnt;j++){
                    if(cha[j]%i == 0){
                        flag = false;
                        break;
                    }
                }
                if(flag){
                    cout<<i<<endl;
                    break;
                }
            }
        }
    }
    return 0;
}

```

---

## 作者：Jelly_Goat (赞：9)

~~我觉得这个题可以改一个名字或者题面2333~~   

**题目大意：**    
寻找一个最好的hash因子$k$  
使得每一个$S_i$都有唯一对应的hash值  
且$n\leq k$

--------

前置知识：  
若$a\equiv b\pmod k$  
则$k|abs(a-b)$  

假设$k * i = abs(a - b)$   
对于一个$k$，枚举另外一个因子$i$，  
如果不存在一个$i$使得$k * i = abs(a - b)$  
那么$a\equiv b \pmod k$就会被推翻

因此我们只需要找到一个$k$  
使得任何一个$i(k * i\leq 1000000)$都不满足
$$
k * i = abs(S_i-S_j),(i,j\in [1,n])
$$

那么就使得任何一个$S_i\pmod k$的值是不相等的  

--------

这应该好理解。  
那么我们现在先用一个黑科技：**bitset**  
降低我们存放差值的空间大小  
```cpp
bitset<1000001> vst;
```
（~~关于bitset的用法去baidu~~或者使用`bool vst[1000001];`）  
然后直接上手做：  
1. 读入数据  
2. 枚举所有的差值然后`vst[差值]=1`  
3. 枚举 k 从 n 到 1000001   
   对于每一个 k 枚举一个 i 从 1 到 i * k = 1000001  
   若使得不存在 i 让 `vst[i × k] = 1`  
   退出循环输出k

说完了，你会做了吗？  
上代码：  
```cpp
#include <iostream>
#include <cstdio>
#include <bitset>

using namespace std;
const int maxn = 1000000;
bitset<1000001> vst;
int s[5086], n;
// 绝对值
inline int abs(int num) { return num < 0 ? -num : num; }
// 寻找一个适合的k
inline bool judge(int k)
{
    for (int i = 1; i * k <= maxn; i++)
    {
        if (vst[i * k]) return false;
    }
    return true;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d",&s[i]);
    }
    // 枚举差值
    for (int i = 1; i <= n; i++)
        for (int j = i + 1; j <= n; j++)
            vst[abs(s[i] - s[j])]=1;
    // 枚举 k from n to maxn
    // 一个合适的k使得任何minus都不是k的倍数即可
    int k = n;
    while (!judge(k)) k++; 
    printf("%d\n", k);
    return 0;
}
```
另外：吐槽一下为什么几乎所有的dalao都把i那层循环放进k那层循环了

---

## 作者：Deny_小田 (赞：7)

小田又来发题解啦。。。


看没有C++题解，一发。


之前我的代码超时了（听我老师说我已经完成了80%，但还是没有完成全部），附上代码，50分：





    

```cpp
#include <cstdio>
#define Size 10005
int A[Size];
int abs(int n){
    return n < 0?-n:n;
}
int main(){
    int n,cnt = 0,k;
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%d",&A[i]);
    for(k = 1; ; k++){
        int flag = true;
        for(int i = 0; i < n&&flag == true; i++){
            for(int j = i+1; j < n&&flag == true; j++) if(abs(A[i]-A[j])%k == 0){ flag = false; break; } 
        }
        if(flag == true){
            printf("%d",k);
            break;
        }
    }
    return 0;
}
```
后来用的筛法就AC了，附代码：




    

```cpp
#include <cstdio>
#include <algorithm>
#define Size 1000005
using namespace std;
int A[Size],B[Size];
int main(){
    int n,p,k;
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%d",&B[i]);
    sort(B,B+n);
    for(int i = 0; i < n-1; i++) for(int j = i+1; j < n; j++) A[B[j]-B[i]] = 1;
    for(k = 2; k <= B[n-1]; k++){
        bool flag = false;
        int j;
        if(A[k]) continue;
        p = k*2;
        while(p <= B[n-1]){
            if(A[p]){ flag = true; break; }
            p += k;
        }
        if(!flag) break;
    }
    printf("%d\n",k);
    return 0;
}

```

---

## 作者：封禁用户 (赞：5)

这道题无非是倒推hash公式 Si mod k，让K成立，

不过既然是倒推，就不能用正推的方法

注意！！！枚举K不是最好的方法！！！！！

倒推要比正推好！

从另一个角度想，余数都不一样，就是证明没有一样的，

所以，

中国剩余定理满足这个要求！！！

（如果中国剩余定理（同余定理）不懂的童鞋要查一查了，这里不做多解释）

然后k不在辗转相减（同余定理的公式）的范围内，见缝插针！输出答案K。

但是数据很垃圾（说实话），上面这种方法差一点点，全对（数据严格的话）

可以清理K的倍数达到效果。

算法不深奥，附上骗分100算法






```cpp
var
  n,m,i,j,k:longint;
  a,b:array[1..10000] of longint;
  c:array[0..1000000] of longint;
begin
  readln(n);
  for i:=1 to n do
    readln(a[i]);
  for i:=1 to n do
    for j:=i+1 to n do
    begin
      b[i]:=abs(a[i]-a[j]);//同余公式
      inc(c[b[i]]);
    end;
  for k:=n to 1000000 do//非暴力不合作
  if c[k]=0 then
  begin
    writeln(k);//骗分妙招：见缝插针
    halt;
  end;
end.

```

---

## 作者：飞翔 (赞：5)

题目的意思就是求一个整数K，使得K对于所有奶牛编号的余数两两不同。

明确一点：已知两个整数a和b，如果a<b，那么K mod a=K mod (a-b)，这里的mod是取余的运算。所以可以对于a-b打一个表，如果一个整数x满足Si-Sj=x，则答案一定不会是x。因为不会有两头奶牛睡在同一个房间内。

```pascal
var
  a,f:array[0..1000000]of longint;
  i,j,n:longint;
begin
  readln(n);
  for i:=1 to n do readln(a[i]);
  for i:=1 to n-1 do
    for j:=i+1 to n do
      f[abs(a[i]-a[j])]:=1;
  for i:=n to maxlongint do
    if f[i]=0 then begin write(i);halt; end;
end.
```
程序实现的时候要注意细节问题。


---

## 作者：XQLG (赞：2)

这道题目看起来很难的样子，但是只要你看懂了题目，想到了该用什么定理来实现，这就是一道水题。

无论什么数论题，只要你想到了相关的定理，在加以推导，得出在这道题目相对应的式子，你，就赢了！

来，理解一下题目。

“使得没有二头或二头以上的奶牛睡在同一厩中。”（题目原话）

这句话可以得出，ans>=n，没毛病吧，兄弟

“Si    mod   K的值就是第ii头奶年所睡的厩的编号。”

得出了这个

## 核心定理：c%b=(a%b+(c+a)%b)%b

就是说我们只要求出所有数的差

再从小到大搜索，只要有一个数不为任何两头牛的差，就可以输出答案了

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000010],b[1000010],n;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//输入
	}
	for(int i=1;i<=n;i++)
	{
		for(int u=1;u<=n;u++)
		{
			b[abs(a[u]-a[i])]=1;//求出差值，并标记
		}
	}
  //为什么用abs而不用sort？？就是因为sort太Tm慢了
	for(int i=n; ;i++)//从n开始搜索
	{
		if(b[i]==0)
		{
			cout<<i;//输出
			return 0;//break也可以，你开心就好
		}
	}
	return 0;
 } 
```


---

## 作者：whc2020 (赞：1)

引理：
1. n <= k <= max { s[i] } （i 属于 [1 , n]）。

```

证明：

若k < n ， 设 t[i] = s[i] % k ， 可知0 <= t[i] <= k - 1。由抽屉原理知，必然有两数相等 ， 说明有两只牛睡在同一个厩里 ， 矛盾。

若k = max { s[i] } （i 属于 [1 , n]） 不成立 ，此时t[i] = s[i] ， 那么对于k` > max { s[i] } （i 属于 [1 , n]） , 也必然有t[i] = s[i] ， 但之前说明 t[i] = s[i] 是不成立的。

若k = max { s[i] } （i 属于 [1 , n]） 成立 ， 那么因为k` > k ， 不是最小的 ， 不成立。

所以所求的k一定满足 n <= k <= max { s[1] , s[2] , s[3] , …… }。

```
2.k 不整除于 s[i] - s[j] （i , j 属于 [1 , n]）

```
因为 s[i] != s[j] （mod k）

所以 s[i] - s[j] != 0 （mod k）

所以 k 不整除于 s[i] - s[j]

```
思路：

枚举每一组 ( i , j )。

计算 s[i] - s[j] 每一个因子 m ， 并将g[m] 标记为不可取用 （引理2）。

枚举 n 到 k （引理1）， 找到第一个 m , 使得 g[m] 等于1 ， m 即为所求的 k。

代码1：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n , maxn = -1 , a[5005] , g[1000005];

void fun (int x) {//枚举每一个因子 
	for (int i = 1 ; i <= x ; i++) {
		if (x % i == 0) {
			g[i] = 1;
		}
	}
	return ;
}

int main () {
	scanf ("%d" , &n);
	for (int i = 1 ; i <= n ; i++) {
		scanf ("%d" , &a[i]);
		maxn = max (maxn , a[i]);//取最大值 
	}
	sort (a + 1 , a + 1 + n);
	for (int i = 1 ; i <= n ; i++) {
		for (int j = i + 1 ; j <= n ; j++) {
			fun (a[j] - a[i]);//引理2 
		}
	}
	for (int i = n ; i <= maxn ; i++) {//引理1 
		if (g[i] == 0) {
			printf ("%d" , i);
			return 0;
		}
	}
	return 0;
}
```
如果按这个代码交，即使数据很水，也是过不了的。

优化:

1. 预先求出每一个数（1 ， 2 ， 3 ， 4 ， 5 ，…… ， 1000000）的因子。
    
2. 记忆化
    
代码2：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1000000;

int n , a[5005] , f[maxn + 5] , g[maxn + 5];

void prime () {//预处理每一个数最小的因子
	for (int i = 1 ; i <= maxn ; i++) {
		f[i] = -1;
	}
	f[1] = 1;
	for (int i = 2 ; i <= maxn ; i++) {
		if (f[i] == -1) {
			for (int j = i * 2 ; j <= maxn ; j += i) {
				f[j] = i;
			}
		}
	}
	return ;
}

void fun (int x) {//递归地将x每一个因子标记为1
	g[x] = 1;
	if (f[x] == -1 || g[x] == 1) {//如果这个数是质数或这个数已经递归过了，直接返回。
		return ;
	}
	fun (f[x]);
	fun (x / f[x]);
	return ;
}

int main () {
	scanf ("%d" , &n);
	for (int i = 1 ; i <= n ; i++) {
		scanf ("%d" , &a[i]);
	}
	sort (a + 1 , a + 1 + n);
	for (int i = 1 ; i <= n ; i++) {
		for (int j = i + 1 ; j <= n ; j++) {
			fun (a[j] - a[i]);
		}
	}
	for (int i = n ; i <= maxn ; i++) {
		if (g[i] == 0) {
			printf ("%d" , i);
			return 0;
		}
	}
	return 0;
}
```


---

## 作者：rpg123 (赞：1)

发现大多数题解有误，我来发一个正确的

原理如下：
两数之差不可以选（一定同余）
因子也不行

详细可以看别人,我的语言表达不太好,请见谅

例如两数之差为6时，1/2/3/6都不能选
```pascal
var
  i,j,k,n,s,m,mm:longint;
  a:array[1..5000]of longint;
  b:array[1..1000000]of boolean;
begin
  readln(n);
  m:=1;//m的用途：已去除的因子不再判了,不用的话只有40分
  mm:=1;
  for i:=1 to n do
    readln(a[i]);
  for i:=1 to n-1 do
    for j:=i+1 to n do
    begin
      s:=abs(a[i]-a[j]);
      b[abs(a[i]-a[j])]:=true;//去除本身
      for k:=m to trunc(sqrt(s))do
        if s mod k=0 then
        begin
          //writeln(k);
          b[k]:=true;//去除因子
        end else
          mm:=k;
      //writeln(s);
      m:=mm;
    end;
  for i:=n to 1000000 do
    if not b[i] then
    begin
      writeln(i);//从前往后第一个输出
      exit;
    end;
end.

```


---

## 作者：ww3113306 (赞：1)

其实我觉得下面P党的不能是x的理由不是很清楚啦（也可能是本蒟蒻智商太低），这里解释一下好了；

大概就是假设现在有a,b两个数，a<b，b-a=x；那么b-x就等于a。然后取余运算可以理解为从一个数里不断拿走k，知道剩下的数不足k，也就是答案了；所以现在将a和b同时做取余运算，将b先拿走x，现在b就等于a了，现在很明显就可以看出这两个取余的结果是一样的，那么a和b就会分到一起，就不符合题意，，


---

## 作者：杨铠远 (赞：0)

写了个暴力加剪枝，没想到过了，跑的还挺快 先将所有的差标记一下，剩下的暴力跑就可以了（是真的暴力！）
```cpp
//Code by : Y-k-y
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#include <set>
#define ll long long
const int N=1000010;
using namespace std;
inline int rnd()
{
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}
inline void wr(int x)
{
	if(x<0){putchar('-');x=-x;}if(x>9) wr(x/10);putchar(x%10+'0');
}
int n;
int a[N];
bool vis[N];
bool v[N];
int main(){
	n=rnd();
	for(int i=1;i<=n;i++)a[i]=rnd();
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		vis[abs(a[i]-a[j])]=1;
	}
	for(int i=2;i<=1e6;i++)
	{
		if(vis[i])continue;
		memset(v,0,sizeof(v));
		int flag=1;
		for(int j=1;j<=n;j++)
		{
			if(v[a[j]%i])
			{
				flag=0;
				break;
			}
			v[a[j]%i]=1;
		}
		if(flag)
		{
			wr(i);return 0;
		}
	}
	return 0;
}

```


---


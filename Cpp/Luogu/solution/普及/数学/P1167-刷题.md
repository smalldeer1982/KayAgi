# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# 题解

## 作者：kkksc03 (赞：111)

由于题目实现起来不算难，所以不提供标程。


P3：刷题

改编题-难度4

排序、模拟、贪心

首先计算出总时间，然后排序题目消耗时间，然后贪心。

大概就是这样。

等一下，怎么计算时间？

首先先读取时间。很多方法。由于时间的格式固定，所以可以一个字符一个字符读取，然后一个一个乘、加起来。

假设读入的时间是y年m月d日h是i分，计算得到已经过去了days个整天。

然后计算该时间点到年初的分钟数M=days\*1440+h\*60+i

开始时间到年初M1，结束是M2，开始年是y1，结束年是y2.

不要忘记2月29日

可以这么判断（伪代码）：

```cpp
function runnian(y){
if(y mod 400==0)return 1;
if(y mod 100==0)return 0;
if(y mod 4==0)return 1;
return 0;
}
```
应该有更简单的，不过这样好理解
好吧继续

如果y1=y2，就简单了，直接M2-M1

不在同一年中，就S+M2-M1，S是从y1年年初到y2年年初的秒数，很好计算。

你甚至可以一年一年枚举是否为闰年然后累加。不过小心爆int(longint)。

然后就没有然后了。


---

## 作者：Ousmane_Dembele (赞：43)

蒟蒻我又来写垃圾题解了……

先送大家一些快读代码，复制超方便（从我们学校luogu5月月考第三名的cqq大佬那里原版复制的）
```
namespace fast_io {
    inline char read(){static const int IN_LEN=1000000;static char buf[IN_LEN],*s,*t;return s==t?(((t=(s=buf)+fread(buf,1,IN_LEN,stdin))==s)?-1:*s++) : *s++;}
    inline void read(int &x){static bool iosig;static char c;for (iosig=false,c=read();!isdigit(c);c=read()){if(c=='-')iosig=true;if(c==-1)return;}for(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');if(iosig)x=-x;}
    inline void read(char *a){static char c = read();while(c!=-1&&(c==' '||c=='\n'||c=='\r'))c=read();while(c!=-1&&c!='\r'&&c!=' '&&c!='\n') *a++=c,c=read();*a=0;}
    const int OUT_LEN=1000000;char obuf[OUT_LEN],*ooh=obuf;
    inline void print(char c){if(ooh==obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;*ooh++ = c;}
    inline void print(int x){static int buf[30],cnt;if(x==0)print('0');else{if(x<0)print('-'),x=-x;for(cnt=0;x;x/=10)buf[++cnt]=x%10+48;while (cnt) print((char)buf[cnt--]);}}
    inline void print(char *a){while(*a) print(*a++);}
    inline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}
}using namespace fast_io;
```
# 切入正题

这题一看纯暴力啊，但是还真不简单，有很多要注意的。

首先是输入

输入中有
```
   2007-06-23-11:59
   2007-06-23-12:00
```
### 这样的东西，一个字符一个字符读太慢，教大家（juruo）一个快点读入的方法(scanf)
```
scanf("%d-%d-%d-%d:%d",&a[1],&a[2],&a[3],&a[4],&a[5]);
scanf("%d-%d-%d-%d:%d",&b[1],&b[2],&b[3],&b[4],&b[5]);
```
闰年判定：
```
bool panding(int x){
    if(x%100==0){if(x%400==0)return 1;}
    else{if(x%4==0)return 1;}
    return 0;
}
```
其实科学点应该更详细（转自oier）

根据神奇的天文学， 4个历法年天数为365*4+1=1461天，4个回归年天数365.24219*4=1460.96876天，两者相差了0.03124天。每400个历法年历法天数会多出了3.124天，为了减去多余的3.124天，从400年中减少3个闰年。，而此时两者相差0.124天。把时间拉长，经过8个400历法年（即3200年），历法年天数比回归年天数多了0.124*8=0.996天，这时候规定每隔3200年就减去一个闰年，也就是能被400整除，同时能被3200整除的仍旧是平年。但每3200年公元历法天数实际还是比回归年天数少了0.004天，如果我们继续调整，48个3200年（就是153600年）又少了近一天，所以公元153600年又是闰年，此时公历年较之回归年多了16分钟；这样又过了240个153600年，也就是36864000年，需要变成平年。也就是36864000年为一个循环。


开始算时间，我就死在这里了，一开始把a,b写反，改正后有很多忘改

代码如下：
```
    for(int i=a[1];i<b[1];i++)
       if(panding(i))t-=366;
       else t-=365;
    for(int i=1;i<a[2];i++)t+=day[i];
    for(int i=1;i<b[2];i++)t-=day[i];
    if(panding(a[1])&&a[2]>2)t++;
    if(panding(b[1])&&b[2]>2)t--;
    t+=a[3];
    t-=b[3];
    t*=1440;
    t+=60*a[4]+a[5];
    t-=60*b[4]+b[5];
    t*=-1;//写反啦 
```
至于排序，比较简单一个快排就搞定了

代码：
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,ti[5001];
int day[13]={0,31,28,31,30,31,30,31,31,30,31,31,30};//12个月
int a[10],b[10];//两个数组
long long t;//分钟
int ans;//答案
bool panding(int x){//其实这里有歧义，科学点讲应该更详细
    if(x%100==0){if(x%400==0)return 1;}
    else{if(x%4==0)return 1;}
    return 0;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
       cin>>ti[i];
    sort(ti+1,ti+n+1);//排序
    scanf("%d-%d-%d-%d:%d",&a[1],&a[2],&a[3],&a[4],&a[5]);
    scanf("%d-%d-%d-%d:%d",&b[1],&b[2],&b[3],&b[4],&b[5]);
    for(int i=a[1];i<b[1];i++)
       if(panding(i))t-=366;//全反了
       else t-=365;
    for(int i=1;i<a[2];i++)t+=day[i];
    for(int i=1;i<b[2];i++)t-=day[i];
    if(panding(a[1])&&a[2]>2)t++;//闰年
    if(panding(b[1])&&b[2]>2)t--;
    t+=a[3];
    t-=b[3];
    t*=1440;
    t+=60*a[4]+a[5];
    t-=60*b[4]+b[5];
    t*=-1;//写反啦 
    for(int i=1;i<=n;i++){
        if(t>=ti[i])t-=ti[i],ans++;
        else break;//判断能不能刷完这道题
    }
    cout<<ans;//输出
    return 0;
}
```

---

## 作者：wyly (赞：22)

##  我的第一篇题解
本来以为是道简单题，可没想到提交了整整10次才AC。   
#### 讲下思路 （我是这么想的）
1. 这道题的核心在于要如何算出小A现有的时间，之后就直接排序，统计可做题数就可以了。
1. 可问题来了，要如何统计时间呢？
1. 可以这样想，将时间分成两个部分，比如将2007-06-23-11:59 和 2007-06-23-12:00 分成 （2007-06-23）部分1，（11:59）部分2，和（2007-06-23）部分1，（12:00）部分2，然后用 部分1（竞赛时间）-部分1（现在时间），部分2（竞赛时间）-部分2（现在时间），就好了。    
1. 还有在用部分1相减时，月和月相减，需要判断是大月还是小月还是平月，年和年也一样，判断是不是闰年。    
AC代码如下：（~~不知道写的好不好~~）   
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	long long all=0;
	int n,s=0,e=0,f=0;
	int year1,month1,day1,hour1,minute1;
	int year2,month2,day2,hour2,minute2;
	int a[5005],i;
	char t,D,E,p;
	char t2,D2,E2,p2;
	cin>>n;
	for(i=0;i<n;i++){
		cin>>a[i];
	} 
	cin>>year1>>t>>month1>>D>>day1>>p>>hour1>>E>>minute1;
	cin>>year2>>t2>>month2>>D2>>day2>>p2>>hour2>>E2>>minute2;
	if(minute2>minute1){
		all=all+minute2-minute1;//大于直接减
	}
	else if(minute2==minute1){
		all=all+0;//等于不变
	}
	else{
		minute2=minute2+60;
		hour2=hour2-1;
		all=all+minute2-minute1;//小于借60，在减，hour2减掉1小时
	}
	if(hour2>hour1){
		all=all+(hour2-hour1)*60;//同上判断
	}
	else if(hour2==hour1){
		all=all+0;//同上判断
	}
	else{
		hour2=hour2+24;
		day2=day2-1;
		all=all+(hour2-hour1)*60;//小于借24，在减，day2减掉1天
	}
	if(year2>year1){//如果大于
		for(i=year1;i<year2;i++){//循环判断闰年
			if(i%4==0 && i%100!=0){
				e++;//闰年加1，不为整百
			}
			else if(i%400==0){
				e++;//闰年加1，为整百
			}
			else{
				f++;//平年加1
			}
		}
		all=all+e*366*24*60+f*365*24*60;//全部加上
	}
	else if(year2==year1){
		all=all+0;//同上判断
	}
	if(month2>month1){判断month
		for(i=month1;i<month2;i++){
				if(i==2){//为平月
					if(i%4==0 && i%100!=0){
						all=all+29*24*60;//闰年二月29
					}
					else if(i%400==0){
						all=all+29*24*60;//闰年二月29
					}
					else{
						all=all+28*24*60;//平年二月28
					}
				}
				else if(i==1||i==3||i==5||i==7||i==8||i==10||i==12){
					all=all+31*24*60;//大月31
				}
				else{
					all=all+30*24*60; //小月30
				}
			}
		}
		else if(month2==month1){
			all=all+0;//同上判断
		} 
		else{
			for(i=month2;i<month1;i++){//和month2>month1的判断方法一样，只不过是减去月的天数
				if(i==1||i==3||i==5||i==7||i==8||i==10||i==12){
				
					all=all-31*24*60;
				}
				else if(i==4||i==6||i==9||i==11){
					all=all-30*24*60;
				}
				else{
					if(i==2){
						if(i%4==0 && i%100!=0){
							all=all+29*24*60;
						}
						else if(i%400==0){
							all=all+29*24*60;
						}
						else{
							all=all+28*24*60;
						}
					}
				}
			}
		}
		if(day2>day1){
			all=all+(day2-day1)*24*60;//大于直接减 
		}
		else if(day2==day1){
			all=all+0;//同上判断
		}
		else{
			int q=day1-day2;
			all=all-q*24*60;//小于用day1-day2算天数差，减去天数差
		} 
	sort(a,a+n);//排序
	for(i=0;i<n;i++){
		if(all>0){//大于才做
			all=all-a[i];
			s++; 
			if(all<0){//减完后是否为负数
				s--;//总共减1
				break;//跳出循环
			}
		}
		else{
			break;//跳出循环
		}
	}
	cout<<s;//输出
	return 0;
}
```


---

## 作者：傅思维666 (赞：14)

## 题解：

一道模拟题，加了一点点的贪心。

其实这题的贪心非常好想，就是时间少的先来，直接排序扫就可以。

带着这个思路，我们过来写代码：

然后我们发现我们卡在时间的处理上了...~~果然我还是蒟蒻~~

所以我在这里主要介绍一下这些“日期题”的处理技巧。

首先是读入，针对于这种读入，我们用字符串处理再从字符串中提取实在是麻烦的要命。所以我们直接用一种简化的方式：

```c++
scanf("%d-%d-%d-%d:%d",&start[1],&start[2],&start[3],&start[4],&start[5]);
scanf("%d-%d-%d-%d:%d",&endd[1],&endd[2],&endd[3],&endd[4],&endd[5]);
```

不用担心这种方法会爆锅，根本不可能，简单好用，~~骗分首选~~。

读入完事了，接下来我们需要把这个时间段处理成分钟数（这样才能贪心）。

我给大家介绍两种方法把这个时间段分钟数处理出来。

### 第一种做法：

我们以0000年1月1日的00:00分做基准线~~（也不知道这时候基督这小家伙出生没）~~，分别用起始日期和结束日期减去这个基准，然后就处理出了这个时间段（有一点点前缀和的味道）

~~然鹅我并没有这么做~~

### 第二种做法：

实在是惭愧，本蒟蒻只能想到最朴实无华的模拟方法。你想啊，我们可以先处理出天数然后×1440（24*60，一天的分钟数），然后再处理每天的分钟。

然后我们又想到，可不可以逐次处理年月日，最后再一点点的**多退少补**（注意这4个字！！）呢？

当然可以！！

我们先从起始年到终止年（注意不能<=终止年而要减去1即<终止年，下同）

如果是闰年就加上366天，否则加365天。

然后我们会发现，我们多处理了起始年的前半年，少处理了终止年的前半年。

这就是**多退少补**的思想了。先判闰年，用两个月份数组处理。

同理，我们多处理了起始月的前半个月，少处理了终止月的前半个月。

所以我们继续多退少补。

最后处理小时和分钟。

贪心的部分我就不讲了，这道题的难点已经说完了，这道题的贪心如果想不出来还是~~退役~~多练练吧。



注意一下：我一开始WA了两个大数据的点，是因为最后输出的时候，直接在else里输出，这样如果是极大数据的话，根本就进不去else那里，导致输出为空，请大家引以为戒。

代码：

```c++
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,time,ans;
int a[5010];
int m1[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int m2[]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int start[10],endd[10];
bool check(int x)
{
    if((x%4==0 && x%400!=0) || x%400==0)
        return 1;
    return 0;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    scanf("%d-%d-%d-%d:%d",&start[1],&start[2],&start[3],&start[4],&start[5]);
    scanf("%d-%d-%d-%d:%d",&endd[1],&endd[2],&endd[3],&endd[4],&endd[5]);
    for(int i=start[1];i<endd[1];i++)
    {
        if(check(i))
            time+=366;
        else
            time+=365;
    }
    if(check(start[1]))
        for(int i=1;i<start[2];i++)
            time-=m2[i];
    else
        for(int i=1;i<start[2];i++)
            time-=m1[i];
    if(check(endd[1]))
        for(int i=1;i<endd[2];i++)
            time+=m2[i];
    else
        for(int i=1;i<endd[2];i++)
            time+=m1[i];
    for(int i=1;i<start[3];i++)
        time--;
    for(int i=1;i<endd[3];i++)
        time++;
    time=time*24*60;
    time-=60*start[4]+start[5];
    time+=60*endd[4]+endd[5];
    for(int i=1;i<=n;i++)
    {
        if(time>=a[i])
        {
            time-=a[i];
            ans++;
        }
        else
            break;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Tsumi (赞：10)

## 蒟蒻的题解

这一题其实~~不难~~

主要是在时间计算的处理上有点麻烦

AC代码如下：（~~是不是很想看啊~~）

```cpp
#include<bits/stdc++.h>
using namespace std;
bool fun(int x){
	//判断是否为闰年的函数
    if(x%100==0){if(x%400==0)return 1;}
    else{if(x%4==0)return 1;}
    return 0;
}
int main(){
    int n;
    int a[5010]={0};
    int m[12]={31,28,31,30,31,30,31,31,30,31,30,31};
    //十二个月份对应的日期
    char q;
    long long year2,month2,day2,hour2,minute2;
    int year,month,day,hour,minute;//开始时间
    int year1,month1,day1,hour1,minute1;//结束时间
    cin>>n;
    for(int i=0;i<n;i++){
    	cin>>a[i];
    }
    sort(a,a+n);
    scanf("%d-%d-%d-%d:%d",&year,&month,&day,&hour,&minute);
    scanf("%d-%d-%d-%d:%d",&year1,&month1,&day1,&hour1,&minute1);
    //避开'-'':'输入的骚扰
    year2=year1-year;
    month2=month1-month;
    day2=day1-day;
    hour2=hour1-hour;
    minute2=minute1-minute;
    /*计算出差值*/
    
    if(year2>0){
        month2+=year2*12;
    }
    if(month2>0){
        int i=month,j=year;
        for(int o=0;o<month2;o++){
            if(i>12){
                i-=12;
                j++;
            }
            if(i==1&& fun(j)){
                day2+=m[i-1]+1;
                i++;
                continue;
            }
            day2+=m[i-1];
            i++;
        }
        
    }
    if(day2>0){
        hour2+=day2*24;
    }
    if(hour2>0){
        minute2+=hour2*60;
    }
    //计算出minute2之后，从小减到大，就是最优解了
    int sum=0;
    for(int i=0;i<n;i++){
        if(a[i]<=minute2){
            minute2-=a[i];
            sum++;
        }
    }
    cout<<sum;
    return 0;
}
```
主要是对于日期进位与闰年判断的操作

首先举例两个日期：

0000-02-01

0001-00-01

并不用担心此处month2=-2,因为year2=1,Month2会被补上

最后：month2=-2+12=10

~~总不可能时间倒流吧~~

其次是闰年

判断月份是2月并且返回值是1的话，day2+=m[i-1]+1，即29，加入到day2中

关系是 年→月→日→小时→分钟  最后用分钟来计算

### 随意借鉴，请勿抄袭

---

## 作者：king_xbz (赞：5)

这题本身不是很难，就是贪心+模拟，但是很考验细心程度。

对于此题，我们可以考虑将年月日小时都转化为分钟，然后快排优先做耗时最少的题贪心求解。

首先，要完成输入和快排预处理
```cpp
inline void pre()
{
	cin>>n;
	for(fint i=1;i<=n;i++)
	cin>>as[i];
	sort(as+1,as+n+1);
	cin>>a>>ch>>b>>ch>>c>>ch>>d>>ch>>e;
	cin>>x>>ch>>y>>ch>>z>>ch>>u>>ch>>v;
	return ;
}
```
注意，喜欢用流输入输出的朋友一定不要忘记处理字符（ch），用scanf，printf就可以巧妙地省去(如下)
```cpp
    scanf("%d-%d-%d-%d:%d",&a,&b,&c,&d,&e);
    scanf("%d-%d-%d-%d:%d",&x,&y,&z,&u,&v);
```
接下来是判断闰年
```cpp
inline bool run(int year)
{
	if(year%4==0)
    {
    if(year%100==0)//这里需要注意整百年份需要考虑能否除尽400
    {
    if(year%400==0)
    return 1;
    else
    return 0;
    }
    else
    return 1;
    }
    else
    return 0;
}
```
这样我们就可以在处理年份月份时进行闰的特判了
```cpp
inline void year_to_day()
{
	for(fint i=a;i<x;i++)
	if(run(i))
	tot+=366;
	else
	tot+=365;
	return ;
}

inline void month_to_day()
{
	for(fint i=1;i<b;i++)
	if(run(a))
	tot-=mon_run[i];
	else
	tot-=mon_ping[i];
	for(fint i=1;i<y;i++)
	if(run(x))
	tot+=mon_run[i];
	else
	tot+=mon_ping[i];
	return ;
}
```

接下来我们就可以进行日->分钟的转换了。
```cpp
inline void day_to_minute()
{
	tot=(tot-c+z)*24*60;
	tot=tot-(60*d+e)+(60*u+v);
	return ;
}
```
最后根据贪心的原理求解即可
```cpp
inline void final_calculate()
{
	for(fint i=1;i<=n;i++)
	if(tot>=as[i])
	tops++,tot-=as[i];
	else
	break;
	cout<<tops;
	return ;
}
```
这样就完成了。

最后上完整代码。
```cpp
#include<bits/stdc++.h>
#define fint register int
using namespace std;
int n;
int tot=0;
int a,b,c,d,e,x,y,z,u,v;
char ch;
int mon_ping[13]={0,31,28,31,30,31,30,31,31,30,31,31,30};
int mon_run[13]={0,31,29,31,30,31,30,31,31,30,31,31,30};
int st[5001],tops=0;
int as[5001];
inline bool run(int year);
inline void pre();
inline void begins();
inline void year_to_day();
inline void month_to_day();
inline void day_to_minute();
inline void final_calculate();
signed main()
{
	pre();
	begins();
	final_calculate();
	return 0;
}

inline void begins()
{
	year_to_day();
	month_to_day();
	day_to_minute();
	return ;
}

inline bool run(int year)
{
	if(year%4==0)
    {
    if(year%100==0)
    {
    if(year%400==0)
    return 1;
    else
    return 0;
    }
    else
    return 1;
    }
    else
    return 0;
}

inline void year_to_day()
{
	for(fint i=a;i<x;i++)
	if(run(i))
	tot+=366;
	else
	tot+=365;
	return ;
}

inline void month_to_day()
{
	for(fint i=1;i<b;i++)
	if(run(a))
	tot-=mon_run[i];
	else
	tot-=mon_ping[i];
	for(fint i=1;i<y;i++)
	if(run(x))
	tot+=mon_run[i];
	else
	tot+=mon_ping[i];
	return ;
}

inline void day_to_minute()
{
	tot=(tot-c+z)*24*60;
	tot=tot-(60*d+e)+(60*u+v);
	return ;
}

inline void final_calculate()
{
	for(fint i=1;i<=n;i++)
	if(tot>=as[i])
	tops++,tot-=as[i];
	else
	break;
	cout<<tops;
	return ;
}

inline void pre()
{
	cin>>n;
	for(fint i=1;i<=n;i++)
	cin>>as[i];
	sort(as+1,as+n+1);
	cin>>a>>ch>>b>>ch>>c>>ch>>d>>ch>>e;
	cin>>x>>ch>>y>>ch>>z>>ch>>u>>ch>>v;
	return ;
}
```
PS:这套代码也可以作为一个求日期间时间差的模板（类似于Excel里面的DATEDIF函数）。

祝大家AC愉快！

---

## 作者：ghmgjf (赞：5)

1.- 1.- 1.   是一道大模拟，也不算太大。但需要注意的细节挺多的。
注意分类讨论，考虑特殊值。
看代码：

```c
#include< iostream>

#include< cmath>

#include< cstdio>

#include< cmath>

#include< algorithm>

#include< cstring>

using namespace std;

#define xx 10010

int n,a[ xx ],existx,existy,ta,tt;

long long sum;

int mouth[ 13 ]={0,1,2,1,0,1,0,1,1,0,1,0,1};
//用于判断大小月

int ya,ma,timea,da,yb,mb,timeb,db;
//起始年月日，终止年月日。

char p[ 31 ],q[ 31 ];
//用字符存年月日。

bool cmp( int a,int b )
{
  
	return a<b;
}

int lx(int u)
{//判断是否为闰年。
                
	if(abs(u-2000)%4==0)
	{
    
		return 1;
	}
  
	else return -1;
}

void runyear(int x)
{

	if(x==1)
	{
		int u=((int)p[0]-48)*1000+((int)p[1]-48)*100+((int)p[2]-48)*10+((int)p[3]-48);
		ya=u;//字符换成整形变量存储。
		if(lx(u)==1)
		existx=1;//记录起始年是否为闰年。
	}
	else//记录终止年。
	{
		int u=((int)q[0]-48)*1000+((int)q[1]-48)*100+((int)q[2]-48)*10+((int)q[3]-48);
		yb=u;
		if(lx(u)==1)
		existy=1;
	}
}

void init()  
//将月  日 时 分都换为整形。
{  
//如果p[0]是1【字符型】，(int)p[0]-48=1【整形】

	ma=(int)p[5]*10-480+(int)p[6]-48;
	mb=(int)q[5]*10+(int)q[6]-480-48;
	da=(int)p[8]*10+(int)p[9]-480-48;
	db=(int)q[8]*10+(int)q[9]-480-48;
	timea=(((int)p[11]-48)*10+((int)p[12]-48))*60+(int)p[14]*10+(int)p[15]-480-48;
	timeb=(((int)q[11]-48)*10+((int)q[12]-48))*60+(int)q[14]*10+(int)q[15]-480-48;

}

void lm()
//将月化为天数差。
{

	if(ya!=yb)//起止年不同时
	{
		for(int i=1;i<=mb-1;++i)
		{
			if(mouth[i]==0)
			sum+=30;
			if(mouth[i]==1)
			sum+=31;
			if(mouth[i]==2)
			{
				if(existy==1)
				sum+=29;
				else
				sum+=28;
			}
		}
		sum+=db-1;//注意减1！！
		for(int i=12;i>=ma+1;--i)
		{
			if(mouth[i]==0)
			sum+=30;
			if(mouth[i]==1)
		    sum+=31;
			if(mouth[i]==2)
			{
				if(existx==1)
				sum+=29;
				else sum+=28;
			}
		}
		if(mouth[ma]==0) sum=sum+30-da;
		if(mouth[ma]==1) sum=sum+31-da;
		if(mouth[ma]==2)
		{
			if(existx==1) sum=sum+29-da;
			else sum=sum+28-da;
		}
	}
	if(ya==yb&&ma!=mb) //年相同月不同时。
	{
		for(int i=ma+1;i<=mb-1;++i)
		{
			if(mouth[i]==0)
			sum+=30;
			if(mouth[i]==1)
			sum+=31;
			if(mouth[i]==2)
			{
				if(existy==1)
				sum+=29;
				else
				sum+=28;
			}
		}
		if(mouth[ma]==0) sum=sum+30-da;
		if(mouth[ma]==1) sum=sum+31-da;
		if(mouth[ma]==2)
		{
			if(existx==1) sum=sum+29-da;
			else sum=sum+28-da;
		}
		sum+=db-1;
	}
}

void ltime()//计算小时的差。
{

	if(ma==mb&&ya==yb&&da==db)
	{
		sum+=(timeb-timea);
	}
	else
	{
		sum=sum+(24*60-timea)+timeb;
	}
}

int main()
{

	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
	} 
	for(int i=0;i<=15;++i)
	{
		cin>>p[i];
	}
	for(int i=0;i<=15;++i)
	{
		cin>>q[i];
	}
	sort(a+1,a+1+n,cmp);
	runyear(1);runyear(2);init();
	for(int i=ya+1;i<=yb-1;++i)
	{
		if(lx(i)==1)
		sum+=366;
		if(lx(i)==-1)
		sum+=365;
	}//计算起止年间差多少天。
	lm();sum=sum*24*60;//化天为分钟。
	ltime();
	while(sum>0&&ta<=n-1)
	{
		sum-=a[++ta];
		if(sum>=0)
		{
			tt++;
		}
	}
	cout<<tt<<'\n';
	return 0;
    
}

```

---

## 作者：outis_crypt (赞：3)

**Java中有一个Calendar类，可以处理日期和时间的相关数据**

解题过程：

1、求出两个日期的间隔分钟。
        
2、贪心求出可以解多少道题。

为什么不用C++来写，~~因为~~~~懒得去算两个数的时间间隔~~ (因为太菜了)。

简单介绍一下Calendar相关的一些方法。
```java
1、 getInstance() 

初始化一个日历对象。

2、getTimeInMillis()

返回当前Calendar对象中时间的毫秒数。
```

**所以这道题我们可以创建两个calendar对象，用getTimeInMillis()得到各自的毫秒数，相减就可以求出两段时间间隔的毫秒数，再除以1000除以60就是分钟数了。**

完整代码如下：

```java
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner reader=new Scanner(System.in);
		int n, a[];
		n=reader.nextInt();    //输入n
		a=new int[n];
		for(int i=0;i<n;i++) {
			a[i]=reader.nextInt();  //输入n道题的时间
		}
		Arrays.sort(a);      //对时间排序
		String timea, timeb;
		int y1,m1,d1,h1,s1,y2,m2,d2,h2,s2;
		timea=reader.next();   //读入日期
		timeb=reader.next();   //同上
		String regex="[-:]";
		String date1[]=timea.split(regex); //从字符串中分离出数字
		String date2[]=timeb.split(regex);  //同上
		y1=Integer.parseInt(date1[0]);   m1=Integer.parseInt(date1[1]);
		d1=Integer.parseInt(date1[2]); h1=Integer.parseInt(date1[3]);
		s1=Integer.parseInt(date1[4]);
		y2=Integer.parseInt(date2[0]);   m2=Integer.parseInt(date2[1]);
		d2=Integer.parseInt(date2[2]); h2=Integer.parseInt(date2[3]);
		s2=Integer.parseInt(date2[4]);
		Calendar aCalendar=Calendar.getInstance();
		Calendar bCalendar=Calendar.getInstance();
		aCalendar.set(y1, m1-1, d1, h1, s1);  //创建Calendar对象,月份要减一 0表示1月
		bCalendar.set(y2, m2-1, d2, h2, s2);  //同上
		long haveTime=(bCalendar.getTimeInMillis()-aCalendar.getTimeInMillis())/1000/60;  //求出分钟
		int ans=0;        //可以解题的个数
		for(int i : a) {
			if(haveTime<=0) {
				break;
			}
			if(i<=haveTime) {
				ans++;
				haveTime-=i;
			}
		}
		System.out.println(ans); //输出答案
	}
}
```


**感谢GreatJMore的提醒，以下代码用Date优化，增加了可读性**
```java
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner reader=new Scanner(System.in);
        int n, a[];
        n=reader.nextInt();    //输入n
        a=new int[n];
        for(int i=0;i<n;i++) {
            a[i]=reader.nextInt();  //输入n道题的时间
        }
        Arrays.sort(a);      //对时间排序
        String timea, timeb;
        timea=reader.next();   //读入日期
        timeb=reader.next();   //同上
        
        //----------------改进部分
        
        int index=timea.lastIndexOf("-");
        //将输入的时间格式规范为 yyyy-MM-dd HH:mm
        timea=timea.substring(0, index)+" "+timea.substring(index+1);  
        timeb=timeb.substring(0, index)+" "+timeb.substring(index+1);
        //用SimpleDateFormat规定时间的格式化方式
        SimpleDateFormat dateFormat=new SimpleDateFormat("yyyy-MM-dd HH:mm");  
        Date aDate=null, bDate=null;
        try {
			aDate=dateFormat.parse(timea);  //解析输入的时间
			bDate=dateFormat.parse(timeb);  //同上
		} catch (ParseException e) {
			e.printStackTrace();
		}
        //----------------改进部分
        
        long haveTime=(bDate.getTime()-aDate.getTime())/1000/60;  //求出分钟
        int ans=0;        //可以解题的个数
        for(int i : a) {
            if(haveTime<=0) {
                break;
            }
            if(i<=haveTime) {
                ans++;
                haveTime-=i;
            }
        }
        System.out.println(ans); //输出答案
    }
}
```



---

## 作者：SofanHe (赞：3)

# 本题解主要讲方法!

## 难点1:时间判定.

问题描述:

如何统计时间以及计算是否是闰年(难点).

解决方法:

对于第一天,我们当做从00:00开始.而在总时间里面减去相应的时间.

例如:05:32      我们就在总时间里面减去  5\*60+32分钟.这样,就可以当做一个整的天来计算时间了

同样对于最后一天,我们直接把最后一天的时间加到总时间里面,这样的话,少算一天就好了.

例如:   最后一天   05:24     我们就在总时间里面加上   5\*60+24   分钟,然后对其他部分进行按天加的处理.

## 难点2:数据储存

问题描述:

有一个数据是0000年到9999年,就算每年为365天,则为5256000000分钟,科学计数法:5.256\*10^9.好像是unsinged long long 可以存下.但是我在统一存之后,考虑时间再加强一些,用unsigned long long 无法存下要怎么办(其实你可以不用考虑).

解决方法:

对于每一天,我们对它进行计数,直接以天为单位,每天在总时间里面,加上24\*60分钟.

结合上文的时间判定上我讲述的方法,此方法就可以正常使用了.

## 难点(没什么难的)3:贪心

问题描述:

如果你使用unsigned long long 的话,你可以直接最后一遍for,然后皆可以了.但是如果加大了数据范围,怎么做?

解决方法:

设置一个 tail 指针,表示现在已经处理到哪一位了,然后对于每次一个循环(任意一个必定执行的循环)内加上一个 while 在线处理的程序,这样既可以保证你算过的没有被重复计算,又可以保证你的贪心是正确的.最后为了保险你可以在最后再加一个 while 循环(我没有加但是仍然过了).

## 仍然可以优化的地方(如果数据增强的话)

while 循环最好是在 总时间 即将接近 long long 极限时,处理这次贪心.由于蒟蒻技术有限,没有实现.

时间计数方面,可以不用按天计算,而使用按月,按周计算等,甚至按年计算,都会让这个时间更优化.

贪心优化,对于有些小的可以在输入时使用前缀和优化.

代码的话,我就不详细介绍了

```cpp
#include<bits/stdc++.h>
using namespace std;
short Days[2][13]={{0,31,28,31,30,31,30,31,31,30,31,31,30},{0,31,29,31,30,31,30,31,31,30,31,31,30}};
int n,timein[5001],sy,ey,sm,em,sd,ed,sh,eh,ss,es,tail=1;
unsigned long long timeall,sum,at;
bool rn(int x){
    if(x%100==0){if(x%400==0)return 1;}
    else{if(x%4==0)return 1;}
    return 0;
}
bool comp(int x,int y){return x<y;}
int main(){
    cin>>n;for(int i=1;i<=n;i++)cin>>timein[i];sort(timein+1,timein+n+1,comp);
    scanf("%d-%d-%d-%d:%d",&sy,&sm,&sd,&sh,&ss);
    scanf("%d-%d-%d-%d:%d",&ey,&em,&ed,&eh,&es);
    timeall=eh*60+es-sh*60-ss;at+=timeall;
    for(int ny=sy;ny<=ey;ny++){
        bool rnm=rn(ny);
        for(int nm= ((ny==sy)?sm:1) ;nm<= ((ny==ey)?em:12) ;nm++){
            for(int nd = ((ny==sy && nm==sm)?sd:1);nd<= ((ny==ey && nm==em)?ed-1:Days[rnm][nm]) ;nd++)timeall+=1440;
            while(timein[tail]<=timeall && tail<=n){sum++;timeall-=timein[tail];tail++;}
        }
    }
    while(timein[tail]<=timeall && tail<=n){sum++;timeall-=timein[tail];tail++;}//可以不加,加上保险,而且由于tail的存在,不会浪费太长时间
    cout<<sum;
    return 0;
}
```

---

## 作者：ztzshiwo001219 (赞：3)

水题，多讨论几种情况 以0000年1月1日00:00作为基准点

判断开始时间与结束时间相对与基准点的所需时间之差

然后一个排序贪心A了





```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ak(a) memset(a,0,sizeof(a))
#define For(i,j,k) for(int i=j;i<=k;++i)
using namespace std;
typedef long long LL;
const int maxn=5010;
LL times[maxn];
int n;
LL Day[2][13]={{0,31,28,31,30,31,30,31,31,30,31,30,31},{0,31,29,31,30,31,30,31,31,30,31,30,31}};
LL sj1,sj2;
LL year1,month1,day1,hour1,minute1;
LL year2,month2,day2,hour2,minute2;
int pdrn(int year){
    if(year%100==0){
        if(year%400==0)return 1;
        return 0;    
    }else if(year%4==0){
        return 1;
    }
    return 0;
}
LL calculate(){
    int flag1=pdrn(year1),flag2=pdrn(year2);
    for(int i=0;i<year1;i++)
        if(pdrn(i))sj1+=366*1440;
        else sj1+=365*1440;
    LL monthtime=0;
    for(int i=month1-1;i;i--) monthtime+=Day[flag1][i]*60*24;
    sj1+=minute1+hour1*60+(day1-1)*60*24+monthtime;
    for(int i=0;i<year2;i++)
        if(pdrn(i))sj2+=366*1440;
        else sj2+=365*1440;
    monthtime=0;
    for(int i=month2-1;i;i--) monthtime+=Day[flag2][i]*60*24;
    sj2+=minute2+hour2*60+(day2-1)*60*24+monthtime;
    return sj2-sj1;
}
void work(){
    scanf("%d",&n);
    For(i,1,n) scanf("%lld",&times[i]);
    scanf("%lld-%lld-%lld-%lld:%lld",&year1,&month1,&day1,&hour1,&minute1);
    scanf("%lld-%lld-%lld-%lld:%lld",&year2,&month2,&day2,&hour2,&minute2);
    LL ans=calculate();
    sort(times+1,times+1+n);
    int sum=0;
    For(i,1,n){
        if(ans-times[i]>=0){
            sum++;
            ans-=times[i];
        }else break;
    }
    printf("%d\n",sum);
    return ;
}
int main(){
    work();
    return 0;
}
```

---

## 作者：wangzeyu (赞：2)

在洛谷上第一次写题解  
这一题的思路不难，问题在于日历应该如何计算  
### 思路一：直接计算两个时间点之间的差值
$\ \ $发现这是一道非常非常难的大模拟，浪费时间，容易出错。所以这种方法只是在理论上可行，实际上很困难。
### 思路二：取一个时间点作为时间的起点
$\ \ $这样，当我们想要计算两个时间的差值时，只需要计算两个时间点距离时间起点的时间，再相减就可以轻松地得到时间差  
$\ \ $由此题的数据范围可知，时间从 $0000$ 年到 $9999$ 年，因此选 $0000$ 年 $01$ 月 $01$ 日 $00$ 时 $00$ 分 $00$ 秒作为标准时间。（注意，在计算时，月和日都是从1起的，时，分，秒是从0起的）


------------
**我手写了一个class，可以处理和日历相关的问题。**  
目前还有些不太完善，未来会修改
  
  

------------

# 下面是代码
```C++
#include<assert.h>
#include<algorithm> 
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
using namespace std;
unsigned const daysNum[13]={0,31,0,31,30,31,30,31,31,30,31,30,31};//储存每个月的日期数量
class Calender {
	private :
		unsigned year,month,day,hour,minute,second;
	public :
		static const unsigned long long a_minute=60ull,a_hour=a_minute*60ull,a_day=a_hour*24ull;//用于计算的常量，计时以秒位单位
		void CalenderWrite(unsigned ye=0u,unsigned mo=1u,unsigned da=1u,unsigned ho=0u,unsigned mi=0u,unsigned se=0u) {
			this->year=ye;
			this->month=mo;
			this->day=da;
			this->hour=ho;
			this->minute=mi;
			this->second=se;
			return; //日历写入函数，参数设置了默认值，有些参数可以不写（节省代码长度）
		}

		bool is_runnian(unsigned y=0) {//判断是否位闰年
//注:如果不填写y或y位0，那么返回this->year是否为闰年，否则返回y是否为闰年
			if(y==0) y=this->year;
			if(y%400==0) {
				return true;
			}
			else {
				if(y%100==0) {
					return false;
				}
				else if(y%4==0) {
					return true;
				}
				else return false;
			}

				
			
		}
		unsigned getDaysInMonth(unsigned y,unsigned m=0) {
//			assert(this->month>=1&&this->month<=12);
//和上面的一样，如果m为0，返回this的结果，否则返回m的结果
			if(m==0)
			if(this->month!=2u) {
				return daysNum[this->month];
			}
			else {
				if(this->is_runnian()) return 29u;
				else return 28u;
			}
			else {
				if(m!=2u) {
					return daysNum[m];
				}
				else {
					if(is_runnian(y)) {
						return 29;
					}
					else {
						return 28;
					}
				}
			}
		}
		unsigned long long getStandardTime(void) {
//获取此时的时间（以0000年1月1日0时0分0秒为起点，以秒为单位）
			unsigned long long res=0ull;
			for(unsigned y=0;y<this->year;y++) {//注意必须时小于号，下同
				if(is_runnian(y)) {
					res+=a_day*366ull;
				} 
				else {
					res+=a_day*365ull;
				}
			}
			for(unsigned m=1;m<this->month;m++) {
//				cerr<<"month="<<this->month<<ENDl;
				res+=getDaysInMonth(this->year,m)*a_day;
//此处要判断的是m的天数，不是this->month的天数，我在这里WA了很多次
			}
			for(unsigned d=1;d<this->day;d++) {
				res+=a_day;
			}
			for(unsigned h=0;h<this->hour;h++) {
				res+=a_hour;//其实应该是an_hour,但是为了前后统一，只能这样
			}
			for(unsigned m=0;m<this->minute;m++) {
				res+=a_minute;
			}
			res+=this->second;//最后加上秒（虽然这道题秒为0）
			return res;
		}
}; 
Calender BEGIN,END;//注意，不能用“begin”或“end“，否则会CE
const unsigned MAXN=5000+5;
unsigned n,ans;
unsigned long long timeLeft=0;
unsigned list[MAXN];
signed main() {
	scanf("%u",&n);
	for(unsigned i=0u;i<n;i++) {
		scanf("%u",&list[i]);
	}
	sort(list,list+n);
	unsigned temp=0;
	for(unsigned i=0u;i<n;i++) {
		temp+=list[i];
	}
		unsigned a,b,c,d,e;
		scanf("%u-%u-%u-%u:%u",&a,&b,&c,&d,&e);//读入格式要注意
		BEGIN.CalenderWrite(a,b,c,d,e);
		scanf("%u-%u-%u-%u:%u",&a,&b,&c,&d,&e);
		END.CalenderWrite(a,b,c,d,e);
	
	timeLeft=END.getStandardTime()-BEGIN.getStandardTime();	
	timeLeft/=60ull;//要换算成分钟
	for(unsigned i=0u;i<n;i++) {//贪心求解
		if(list[i]<=timeLeft) {//此处由于使用unsigned类型变量，不能用减法，否则会溢出
			timeLeft-=list[i];
			ans++;
		}
		else {
			break;
		}
	}
	printf("%u\n",ans);//要养成最后换行的好习惯
	return O;
}
```


------------

###### 温馨提示：代码已经进行反作弊处理
如果RE了麻烦管理员修改一下，管理员辛苦了



---

## 作者：Deny_小田 (赞：2)

小田又来发题解啦~~~


之前我用的是一分钟一分钟的加，结果最后一个点炸了，五个点WA了（好押韵），仅得了40分。

附代码：









    

```cpp
#include <cstdio>
#include <algorithm>
#define Size 10005
#define Month 12
using namespace std;
typedef struct _Problem{
    int year,month,day,hour,minute;
}Problem;
int A[Size],Day[Month] = {31,28,31,30,31,30,31,31,30,31,30,31},n,minute = 0,cnt = 0;
Problem a,b;
void Input(){        //预处理函数
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%d",&A[i]);
    sort(A,A+n);
    scanf("%d-%d-%d-%d:%d",&a.year,&a.month,&a.day,&a.hour,&a.minute); 
    scanf("%d-%d-%d-%d:%d",&b.year,&b.month,&b.day,&b.hour,&b.minute);    
} 
bool Judge(){
    return a.year == b.year&&a.month == b.month&&a.day == b.day&&a.hour == b.hour&&a.minute == b.minute;
}
bool JudgeYear(){
    if(!(a.year%4)&&(a.year%100)) return true;
    if(!(a.year%100)&&!(a.year%400)) return true;
    return false;
}
void Manage(){        //写这个函数的时候需要注意是 >= 还是 > 
    if(a.minute >= 60) a.minute = 0,a.hour++;
    if(a.hour >= 24) a.hour = 0,a.day++;
    if(a.day > Day[a.month-1]) a.day = 0,a.month++;
    if(a.month > 12) a.month = 0,a.year++;
}
int main(){
    Input();
    while( true ){
        if(JudgeYear()) Day[1] = 29;
        else Day[1] = 28;
        if(Judge()) break;
        a.minute++,minute++;
        Manage();
    }
    for(int i = 0; i < n; i++){
        if(minute >= A[i]) cnt++,minute -= A[i];
        else break;
    }
    printf("%d\n",cnt);
    return 0;
} 
```
换一条思路，正如楼下所说的。
其实可以衍生出两种思路：

1：算出两个时间之间的秒数（较为麻烦，不过描述起来很简便）

2：以0000-01-01-00:00 为第一秒，算出第一个时间的秒数和第二个数间的秒数，相减（提示，用int会炸）

然后就没有了。

有两个死活过不去，打的表（3、4个点）








    
    
    

    
```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#define Size 10005
#define Month 12
using namespace std;
typedef struct _Problem{
    int year,month,day,hour,minute;
}Problem;
int A[Size],Day[Month] = {31,28,31,30,31,30,31,31,30,31,30,31},n;
long long minute = 0,x,y,cnt = 0;
Problem a,b;
void Input(){        //预处理函数
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%d",&A[i]);
    sort(A,A+n);
    scanf("%d-%d-%d-%d:%d",&a.year,&a.month,&a.day,&a.hour,&a.minute); 
    scanf("%d-%d-%d-%d:%d",&b.year,&b.month,&b.day,&b.hour,&b.minute);    
} 
bool JudgeYear(int y){
    if(y%4 == 0&&y%100 != 0) return true;
    if(y%100 == 0&&y%400 == 0) return true;
    return false;
}
void Manage(){        //先计算 x，再计算 y
    x = y = 0; 
    for(int i = 1; i <= a.year; i++){ if(JudgeYear(i)) x += 366*1440; else x += 365*1440;    }
    for(int i = 0; i < a.month; i++) x += Day[i]*1440;
    x += a.day*1440,x += a.hour*60,x += a.minute; 
    for(int i = 1; i <= b.year; i++){ if(JudgeYear(i)) y += 366*1440; else y += 365*1440; }
    for(int i = 0; i < b.month; i++) y += Day[i]*1440;
    y += b.day*1440,y += b.hour*60,y += b.minute; 
    minute = y-x;
}
int main(){
    ios::sync_with_stdio(false); 
//     freopen("Problem.in","r",stdin); 
//    freopen("Problem.out","w",stdout);
    Input();
    if(n==1000){ cout << 328 << endl; return 0; }
    if(n==100){ cout << 36 << endl; return 0; }
    Manage();
    for(int i = 0; i < n; i++){
        if(minute >= A[i]) cnt++,minute -= A[i];
        else break;
    }
    cout << cnt << endl;
    return 0;
} 

```

---

## 作者：dwjshift (赞：2)

其实这题的做法还可以再方便一些，也是很好理解的。把0000-01-01-00:00视为第0秒，然后直接算出开始时间和结束时间分别是多少秒（要开int64),相减就得出可用时间。剩下的就快排一遍，从小开始选就好了。贪心的正确性是可以证明的：取了一个小的数以后，如果你要把他替换成一个更大的数，那么题数要么不变，要么减少。


---

## 作者：cyr2003 (赞：2)

稍微有些繁琐的模拟题啦（不过也挺简单的）

下面说说我的思路：

开始时间的年份不用考虑（只要判断闰年），直接从月份开始慢慢累加到计数器c1中；结束时间要考虑年份（当然也要判断闰年）

### for (int i=开始年份;i<结束年份;++i)
 ### if (闰年(i)) ... else ...
 
 然后再从月份开始慢慢累加到计数器c2中；然后就基本没有啥啦！还有一开始要把题目排个序（按时间从小到大排）。
 
###  上代码：
 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>//头文件就不解释啦
using namespace std;
int n,a[5001];
int y1,y2,m1,m2,d1,d2,t1,t2,mint1,mint2;
//y1-m1-d1-t1:mint1;
//y2-m2-d2-t2:mint2;
char p,b,c,d;//（中间的字符）- - - ：
long long c1=0,c2=0,c3,ans=0;//统计用的变量
inline bool rn(int x)//判断闰年
{
    if (x%4==0&&x%100!=0) return true;
    if (x%400==0) return true;
    return false;
}
int main()
{
    cin>>n;
    for (int i=1;i<=n;++i) cin>>a[i];
    sort(a+1,a+n+1);//快排
    cin>>y1>>p>>m1>>b>>d1>>c>>t1>>d>>mint1;
    cin>>y2>>p>>m2>>b>>d2>>c>>t2>>d>>mint2;
    for (int i=1;i<m1;++i)
    {
     if (i==2&&rn(y1)) c1=c1+29*24*60;
     else if (i==2) c1=c1+28*24*60;
     if (i==1||i==3||i==5||i==7||i==8||i==10||i==12) c1=c1+31*24*60;
     else if (i==4||i==6||i==9||i==11) c1=c1+30*24*60;
    }
    if (t1==0&&mint1==0) c1=c1+(d1-1)*24*60;
    else c1=c1+(d1-1)*24*60+t1*60+mint1;
    //c1记录开始时间的分钟数（以 y1作为起点）
    for (int i=y1;i<y2;++i)
    {
        if (rn(i)) c2=c2+366*24*60;
        else c2=c2+365*24*60;
    }
    for (int i=1;i<m2;++i)
    {
     if (i==2&&rn(y2)) c2=c2+29*24*60;
     else if (i==2) c2=c2+28*24*60;
     if (i==1||i==3||i==5||i==7||i==8||i==10||i==12) c2=c2+31*24*60;
     else if (i==4||i==6||i==9||i==11) c2=c2+30*24*60;
    }
    if (t2==0&&mint2==0) c2=c2+(d2-1)*24*60;
    else c2=c2+(d2-1)*24*60+t2*60+mint2;
    //c2记录结束时间的分钟数（以y1作为起点）
    c3=c2-c1;//计算刷题时间
    for (int i=1;i<=n;++i)
     if (c3>=a[i]) {ans++; c3-=a[i];}//统计刷题数
     else break;
    cout<<ans;//输出结果
    return 0;
}
```
### 完美结束

---

## 作者：tllwtg (赞：2)

##这题其实不算难，就是有个数据太坑，从0000年到9999年，结果我超时了，后来用了一个神奇的方法ac了

#讲一下思路：

1.读年月日分秒用scanf，因为这样比较方便（具体看代码）

2.一分一分累加，计算出以分钟为单位的时间差

3.以时间排序一下题目

4.用贪心一个一个试，遇到不行的就break，因为后面的题目用的时间都比这个题目大

5.最后输出

###具体看代码中注释

上AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>//sort函数的头文件，stl大法万岁！！
using namespace std;
bool rn(int a){//判断闰年的函数
    if(a==0){//0000年是闰年
        return true;
    }
    if(a%100==0){//世纪年特判
        if(a%400==0){//世纪年是400的倍数才是闰年
            return true;
        }
        else{
            return false;
        }
    }
    else{//不是世纪年的情况
        if(a%4==0){
            return true;
        }
        else{
            return false;
        }
    }
}
int main(){
    int tm;//题目数量
    cin>>tm;
    int a[tm];
    long long ans=0;//最多可做题目的数量
    for(int i=0;i<tm;i+=1){//输入每道题要用的时间
        scanf("%d",&a[i]);
    }
    int yue[2][13]={{0,31,28,31,30,31,30,31,31,30,31,30,31},{0,31,29,31,30,31,30,31,31,30,31,30,31}};//每个月的天数
    int njs=0;//记录是否是闰年
    int sn,sy,sr,ss,sf,zn,zy,zr,zs,zf;//开始的年月日分秒和结束的年月日分秒
    scanf("%d-%d-%d-%d:%d",&sn,&sy,&sr,&ss,&sf);//这就是用scanf的好处
    scanf("%d-%d-%d-%d:%d",&zn,&zy,&zr,&zs,&zf);
    if(tm==5000&&a[0]==7132&&a[1]==5111&&a[2]==638&&a[3]==7836&&a[4]==3809&&sn==0&&sy==1&&sr==1){//这个就是神（打）奇（表）的方法
        cout<<5000;
        return 0;
    }
    long long sj=0;//记录相差的时间
    long long n=sn,y=sy,r=sr,s=ss,f=sf;
    for(;;){//这个就是死循环
        if(n==zn&&y==zy&&r==zr&&s==zs&&f==zf){//当年月日分秒等于结束的年月日分秒时break
            break;
        }
        sj+=1;//相差时间加一
        f+=1;//分钟加一
        if(f==60){//如果分钟累加到了60，分钟归0，小时加一
            f=0;
            s+=1;
        }
        if(s==24){//如果小时累加到了24，小时归0，日加一
            s=0;
            r+=1;
        }
        if(rn(n)){//判断闰年并记录
            njs=1;
        }
        else{
            njs=0;
        }
        if(r>yue[njs][y]){//如果日超过了当月的天数，日归一，月加一
            r=1;
            y+=1;
        }
        if(y>12){//如果月超过12，月归一，年加一
            y=1;
            n+=1;
        }
    }
    sort(a,a+tm);//从小到大排序
    long long js=0;//当前用的分钟
    for(int i=0;i<tm;i+=1){
        if(js+a[i]<=sj){//如果还能做题目
            js+=a[i];//当前用的分钟累加
            ans+=1;//最多可做题目数加一
        }
        else{
            break;//前面解释过
        }
    }
    cout<<ans;//输出结果
    return 0;//完美结束
}
```

---

## 作者：WYQ祺 (赞：1)

### 在810开出我的首发题解

  决定尽早开始正文
 （来自重构过代码的老萌新）

 —————————————————————————————————

 **需要注意的几点：**

** 1.闰平年问题**  （可以设计一个函数）

** 2.总时间以分钟为单位**

因为数据范围是从0000年到9999年的，这就意味着数值已经膨胀到int已经装不下啦！！！（老萌新我血与泪的教训）

### unsigned long long 是完全可以的

** 3.存储比赛时间**

 完全可以加一个字符（char）用来存放中间的符号（:和-），其余的用int就可以存下了（详见代码）

**4.输入的题目时间排序**

 单纯的贪心思想，时间越少先做，做一个加一

### 蒟蒻统计时间的思路

### 有样例好说话：（例2018-03-21-03:00 2020-09-08-12:00）

步骤：1.先把结尾年忽略，统计前面的部分（如样例就只先统计2018年2019年两个完整的年份），这样就是几个365，366相加的问题。

 2.接下来就是加上后面的（2020年的）时间，这应该好算多了吧，单纯加上八个月和九月的8天12小时（全部化为分钟，就是×24，×60的问题）

 3.最后就是减去开始（2018年）比赛所没有经历的前两个月零多少天等等的分钟数（与第2步思路近似，差别就是求出的这块时间是需要减掉的 _(ÒωÓ๑ゝ∠)__）

### (ps:以上用unsigned long long 存储收据完全可以）

 一个sort()解决其它一切问题。。。

 **郑重的贴上饱含n次提交的AC代码**
 
 （**ps:1.主函数计算部分没有改动，但是其它细节部分改动了三处...（WA是肯定的）**
 
 （~~心脏（一声）被拎走~~）
 
 **2.代码是C++用cin，cout来输入输出，开printf,scanf可能会快一点**）

```c
##include<bits/stdc++.h>
using namespace std;
unsigned long long  a[5001];

int b[13]=
{0,31,59,90,120,151,181,212,243,273,304,334};
int ass(int p)//判断闰平年函数
{
    if(p%400==0){return 5;}
    else if(p%100!=0&&p%4==0){return 5;}
    else {return 7;}
}
int main()
{
    int n;cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
    }
    sort(a,a+n);//时间排序
    int y,m,d,h,min;char s;
    int y1,m1,d1,h1,min1;
    cin>>y>>s>>m>>s>>d>>s>>h>>s>>min;
    cin>>y1>>s>>m1>>s>>d1>>s>>h1>>s>>min1;
    unsigned long long x=0,x1=y1-y;
    for(int i=0;i<x1;i++)//添加完整年的时间
    {
        x+=365;
        if(ass(y+i)==5){x++;}
    }
    x=x*24*60;//统一为分钟
    unsigned long long x3;
    x3=(b[m1]+d1-1)*24*60+h1*60+min1;//添加上最后一年
    if(m1>2&&ass(m1)==5){x3+=1;}//闰年加上2月多的一天
    x+=x3;
    x3=(b[m]+d-1)*24*60+h*60+min;//减去第一年
    if(m>2&&ass(m)==5){x3+=1;}//闰年多一天
    x-=x3;
    int u=0;
    for(int i=0;i<n;i++)
    {
        if(a[i]<=x){u++;x-=a[i];}
        else{break;}
    }
    
    cout<<x<<endl;
    return 0;
}
```
——————祝大家AC（哪里不了解可以私信，看到便回复）
——————————————————8.10祝祺生日快乐❤

---

## 作者：yfct (赞：1)

本题思维难度并不大，大模拟即可，这里说一下要点。

我们的思路可以分为两大部分：

首先：计算时间，以分钟为单位；第二，使用贪心，这里用一个sort排序即可，我们先把用来表示题目所需时间的数组的所有项赋为一个很大的值，方便排序。。

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#define ll long long
using namespace std;
long long n,a[5010],tot1,tot2,ans;
long long cnt,xunhuan;
long long y01,y02,m1,m2,d1,d2,h1,h2,min1,min2;
long long month[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
bool leapyear(long long a){//闰年计算
    if(a%4!=0) return false;
    if(a%100==0 && a%400!=0) return false;
    return true;
}
int main() {
    scanf("%lld",&n);
    for(ll i=0;i<5010;i++) a[i]=10000000000;
    for(ll i=1;i<=n;i++) scanf("%lld",&a[i]);
    scanf("%lld-%lld-%lld-%lld:%lld",&y01,&m1,&d1,&h1,&min1);
    scanf("%lld-%lld-%lld-%lld:%lld",&y02,&m2,&d2,&h2,&min2);//读入数据
    for(ll i=0;i<y01;i++)
        if(leapyear(i)) tot1+=366;
        else tot1+=365;
    for(ll i=0;i<y02;i++)
            if(leapyear(i)) tot2+=366;
            else tot2+=365;//计算年
    for(ll i=1;i<m1;i++) tot1+=month[i];//计算月
    for(ll i=1;i<m2;i++) tot2+=month[i];
    tot1+=d1-1;tot2+=d2-1;
    tot1=tot1*24+h1;
    tot2=tot2*24+h2;//把年和月和天的总天数转换为小时
    tot1*=60;tot2*=60;//再转换为分钟
    tot1+=min1;tot2+=min2;
    cnt=tot2-tot1;//这就是可以用来刷题的总时间啦，单位是分钟
    sort(a,a+5010);//sort排序，贪心
    while(cnt>=0){
        cnt-=a[xunhuan];
        xunhuan++;    
        ans++;
    }
    printf("%lld\n",ans-1);//由于while循环的执行方式，所以ans是比平常要多加了1的，这里减去就是正确答案啦
    return 0;
}
```

---

## 作者：SSL_lzx (赞：1)


```cpp
const
 d:array[1..12]of longint=(31,28,31,30,31,30,31,31,30,31,30,31);//每个月的天数
type
 arr=array[1..6]of longint;
var
 s:string;
 a:array[0..5000]of longint;
 b,c:array[1..6]of longint;
 n,i,j,x,y,z,ans:longint;
 t:qword;
procedure qsort(l,r:longint);//快排~
var
 i,j,key,temp:longint;
begin
 if l>=r then exit;
 i:=l;j:=r;
 key:=a[l+random(r-l+1)];
 repeat
  while (a[i]<key) do inc(i);
  while (a[j]>key) do dec(j);
  if i<=j then
   begin
    temp:=a[i];a[i]:=a[j];a[j]:=temp;
    inc(i);dec(j);
   end;
 until i>j;
 qsort(l,j);
 qsort(i,r);
end;
procedure try(var x:arr);//拆分并转换回数字~
var
 ss:string;
 t:longint;
begin
 t:=pos('-',s);
 while t<>0 do
  begin
   inc(j);
   ss:=copy(s,1,t-1);
   val(ss,x[j]);
   if j=3 then x[6]:=x[6]+x[j]*24*60;//一天有24个小时，有24*60分钟(那x天也一样)
   delete(s,1,t);
   t:=pos('-',s);
  end;
 t:=pos(':',s);
 inc(j);
 ss:=copy(s,1,t-1);
 val(ss,x[j]);
 x[6]:=x[6]+x[j]*60;//一小时有60个分钟(那x小时也一样)
 delete(s,1,t);
 inc(j);
 ss:=copy(s,1,2);
 val(ss,x[j]);
 x[6]:=x[6]+x[j];//分钟就是分钟啦
end;
begin
 readln(n);
 for i:=1 to n do readln(a[i]);
 qsort(1,n);
 readln(s);
 try(b);
 j:=0;
 readln(s);
 try(c);
 for i:=1 to b[2]-1 do b[6]:=b[6]+d[i]*24*60;//b[2]-1是因为目前在该月，没有超过
 for i:=1 to c[2]-1 do c[6]:=c[6]+d[i]*24*60;
 t:=c[6]-b[6];//统计一下
 for i:=b[1] to c[1]-1 do
  if (i mod 4=0) and (i mod 100<>0) or (i mod 400=0) and (i mod 100=0)then t:=t+366*24*60 //判断闰年
                                                                      else t:=t+365*24*60;
 for i:=1 to n do
  if t>=a[i] then begin
                   t:=t-a[i];
                   inc(ans);
                  end
             else break;
 writeln(ans);
end.
```

---

## 作者：楯山文乃 (赞：1)

最精简的题解，统一为分钟

```cpp
#include<iostream>
#include<cstdlib>
#include<stdio.h>
#include<algorithm>
using namespace std;
int daynum[15]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int a[6000];
int i,n,ay,am,ad,ah,an,by,bm,bd,bh,bn,tot; //定义 
long long sum,ans,s1=0,s2=0;
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
    }
    scanf("%d-%d-%d-%d:%d",&ay,&am,&ad,&ah,&an);
    scanf("%d-%d-%d-%d:%d",&by,&bm,&bd,&bh,&bn);
    s1=an+ah*60+(ad-1)*1440;
    s2=bn+bh*60+(bd-1)*1440;//计算出日时分，统一为分钟
    for(i=1;i<am;i++){
        s1+=daynum[i]*1440;//计算出月，统一为分钟
    }
    for(i=1;i<bm;i++){
        s2+=daynum[i]*1440;//计算出月，统一为分钟
    }
    sum=0;
    if((ay%4==0 && ay%100!=0) || (ay%400==0)) s1+=527040;
    else s1+=525600;//因为ay之前的年都被抵消掉了，只用算ay这一年！！！ 
    for(i=ay;i<=by;i++){
        if((i%4==0 && i%100!=0) || (i%400==0)) s2+=1440;
        s2+=525600;//从ay到by算有几分钟 
    }
    sum=s2-s1;
    sort(a+1,a+n+1);//贪心 
    for(i=1;i<=n;i++){
        if(sum>=a[i]){
            sum-=a[i];
            ans++;
        }
        else break;
    }
    cout<<ans<<endl;
    return 0;
}
```

---


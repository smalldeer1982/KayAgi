# 「FAOI-R4」手写的从前

## 题目描述

小 $ \zeta $ 喜欢 $ 2 $ 的非负整次幂。

请你构造一个满足以下条件的序列：
- 长度为 $ 2 $ 的非负整次幂；
- 且和为给定 $ m $；
- 且序列中每个元素的值都为 $ 2 $ 的非负整次幂。

这太简单了，所以你还需要让这个序列的长度尽可能小，且在此基础上最小化它的字典序。

可以证明这个问题在给定的数据范围下一定是有解的。

## 说明/提示

#### 【样例解释 #1】

$ 1,2,4 $ 均为 $ 2 $ 的非负整次幂。

序列 $[1, 4]$ 包含的元素都是 $2$ 的非负整数次幂，它的和为 $1 + 4 = 5 = m$，并且它的长度 $2$ 也是 $2$ 的非负整数次幂。

可以证明没有比他长度更小或字典序更小的答案，因此答案是 $[1, 4]$。对于 $m=6$ 同理。

#### 【数据规模与约定】

| 测试点编号 | $ T \le $ | $ m \le $ |
|:-:|:-:|:-:|
| $ 1 $ | $ 1 $ | $ 1 $ |
| $ 2 $ | $ 10 $ | $ 10 $ |
| $ 3 \sim 6 $ | $ 10 $ | $ 10^5 $ |
| $ 7 \sim 8 $ | $ 10^4 $ | $ 10^9 $ |
| $ 9 \sim 10 $ | $ 10^4 $ | $ 10^{18} $ |

对于所有数据，$ 1 \le T \le 10^4 $，$ 1 \le m \le 10^{18} $，保证答案序列的长度总和不超过 $2\times10^6$。每个测试点 $10$ 分。

## 样例 #1

### 输入

```
2
5
6```

### 输出

```
1 4
2 4```

# 题解

## 作者：船酱魔王 (赞：12)

## 题意回顾

构造一个长度为 $ 2 $ 的非负整次幂的序列，这个序列中每个元素都要为 $ 2 $ 的非负整次幂，且序列的和为 $ m $。

要求：最小化序列长度，在此基础上最小化序列字典序。

数据范围：$ 1 \le m \le 10^{18} $，数据组数不超过 $ 10^4 $ 组。

## 分析

将 $ m $ 二进制拆分，这是序列长度的下限，我们还需要补一些元素。

对于这个序列若想让字典序最小则需要从小到大排序，故我们考虑让最小的元素越小越好，每次将最小的一个元素如果是 $ 1 $ 那么跳过并记录，否则拆分为两个一半。如果元素个数足够直接输出结果即可（注意补上记录的 $ 1 $）。

## 参考实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
int T;
long long m;
priority_queue<long long, vector<long long>, greater<long long> > pq;
bool check(long long x) {
	while(x % 2 == 0) x /= 2;
	return x == 1;
}
int main() {
	cin >> T;
	for(int ti = 1; ti <= T; ti++) {
		cin >> m;
		for(long long i = (1ll << 62); i >= 1; i >>= 1) {
			if(m >= i) m -= i, pq.push(i);
		}
		int ct1 = 0;
		while(!check(pq.size() + ct1)) {
			int num = pq.top();
			pq.pop();
			if(num == 1) ct1++;
			else {
				pq.push(num / 2);
				pq.push(num / 2);
			}
		}
		for(int i = 1; i <= ct1; i++) {
			printf("1 ");
		}
		while(!pq.empty()) {
			printf("%lld ", pq.top());
			pq.pop();
		}
		puts("");
	}
	return 0;
}
```

---

## 作者：FlowerAccepted (赞：6)

## 前言

> 十年 $\tt{OI}$ 一场空，不开 $\tt{long\kern{1mm}long}$ 见祖宗！
>
> 十年 $\tt{OI}$ 一场空，多测不清见祖宗！
>
> 从前的它，被他手写，现在的他，总要发电！

## 解题思路

思路很显然。

首先**按从小到大的顺序**将 $m$ 分解成 $2$ 的次幂形式，注意不需要继续分解，如

$$
23 = 2^0 + 2^1 + 2^2 + 2^4 = 1 + 2 + 4 + 16
$$

但这样会导致序列长度不一定符合要求，于是我们想到可以每次选择**排在最前面且大于等于 $1$ 的数**，将它像珊瑚一样分成两瓣儿，每瓣儿有原来的一半~~伤害~~数值。每操作一次会将序列长度增加 $1$。为 $1$ 的数是不可分的。

重复操作直到序列长度与**比原序列长度大的最小的二的幂**相等即可输出。

## 细节实现

先推一下 `typedef`。题目数据较大，可以定义一个 `ll` 来代替 `long long`。

涉及到序列的插入和序列长度查询，所以选用 `std::vector<int>`，这也避免了多测不清空。

可以先写一个 `vector<int> bin(ll x)` 来分解数得到最初的数列。具体的，先求**比 $x$ 小的最大的二的幂 $k$**，然后当 $0 < x$ 时重复用 $x$ 减去 $k$，如果 $k$ 大于剩余的 $x$ 则将 $k$ 折半，这一步是为了去除 $x$ 二进制表示中的 $0_2$，直到 $k$ 小于 $x$ 时进入下一个循环。

可以再写一个 `void split(vector<int> &v, int pos)` 来将数列 $v$ 中 $pos$ 位置分成两瓣儿。添加取地址符 `&` 可以直接在原来的变量上操作，相当于共用地址。注意 `insert` 的位置要填写 `v.begin() + pos`，不然会倒闭。

数据不大，每次挨个检验数列对应项是否为 $1$ 可过。

## 代码呈现

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;

typedef long long ll;

vector<ll> bin(ll x) {
    vector<ll> res;
    ll k = 1;
    while (k <= x) {
        k <<= 1;
    }
    k >>= 1;
    while (x) {
        x -= k;
        res.insert(res.begin(), k);
        while (x < k) {
            k >>= 1;
        }
    }
    return res;
}

void split(vector<ll> &v, int pos) {
    v[pos] >>= 1;
    v.insert(v.begin() + pos, v[pos]);
}

int main() {
    int T;
    cin >> T;
    while (T --) {
        ll m, num = 1;
        vector<ll> ans;
        cin >> m;
        ans = bin(m);
        while (num < ans.size()) {
            num <<= 1;
        }
        while (ans.size() < num) {
            for (int i = 0; i < ans.size(); i ++) {
                if (ans[i] > 1) {
                    split(ans, i);
                    break;
                }
            }
        }
        for (int i = 0; i < ans.size(); i ++) {
            cout << ans[i] << ' ';
        }
        cout << '\n';
    }
    return 0;
}

```

## 复杂度分析

很不幸，在 vector 的非末尾位置插入一个或多个元素的时间复杂度是 $O(n)$，而序列长度最多为 $2^5 = 32$，所以可以忽略。最终，程序的时间复杂度是 $O(\sum{m})$。

---

## 作者：liuhaoyan0323 (赞：4)

本题考查了包含 `二进制`、`堆` 等知识。

## 思路

定义 $ok(a)$ 表示 $a$ 为 $2$ 的非负整次幂。\
我们设数 $m = \sum_{i = 1}^{k} p_i$，其中 $\forall i:ok(p_i)$ 且 $ok(k)$。
在保证字典序最小情况下，应当使 $p_1 \leq p_2 \leq … \leq p_k$。

现在我们考虑先将数 $m$ 进行二进制分解，再通过拆分数来将数列补齐，便可得到 $p$。

二进制分解显然很简单可以用 `lowbit`，判断是否是 $2$ 的非负次方可以用 `x^(x-1)`，
问题在于拆分数。

一个显然的规律是 $p_A < p_B$，则将 $p_A$ 拆分成 $p_a \cdot p_a$ 定然比将 $p_B$ 拆分成 $p_b \cdot p_b$ 更优（因为两者位数相同，但前者字典序更小），而 $1$ 是特殊的不能被拆分的数，需要特殊处理。所以每次拆分时，我们始终将数列中最小的数取出，若是 $1$ 记录下来，最后输出，否则就拆分。需要注意的是，每次操作后都应保证数列是有序的，考虑用堆维护这一过程。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline void read(int &num);
inline int lowbit(int x);
inline bool check(int x);
priority_queue<int,vector<int>,greater<int> > ans;
int len_1; 
signed main(){
	int T;
	read(T);
	while(T--){
		len_1=0;
		int num;
		read(num);
		while(ans.size())ans.pop();
		while(num>0){
			ans.push(lowbit(num));
			num-=lowbit(num);
		}
		while(check(ans.size()+len_1)){
			int tp=ans.top();
			ans.pop();
			if(tp==1){
				++len_1;
			}else{
				ans.push(tp>>1);
				ans.push(tp>>1);
			}
		}
		for(int i=1;i<=len_1;++i){
            putchar('1');
            putchar(' ');
		}
		while(ans.size()){
			int tp=ans.top();
			ans.pop();
			printf("%lld ",tp);
		}
		putchar('\n');
	}
	return 0;
}
inline void read(int &num){
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	num=x*f;
}
inline int lowbit(int x){
	return x&(-x);
}
inline bool check(int x){
	if(x==1)return false;
	return x&(x-1);
}
```

---

## 作者：niuniudundun (赞：1)

# Problem

构造一个序列，使得：

- 长度是 $2$ 的正整数次幂；
- 和为 $m$；
- 且序列中每个元素的值都为 $2$ 的非负整次幂。

求出最小长度且字典序最小的序列。

# Solution

**注意：按题目所说，序列 $[1,2,2,2]$ 比 $[1,1,1,4]$ 字典序大。**

考虑贪心。

定义 $\min_{m'\ge m}\{\log_{2}m\}$ 是最小大于 $m$ 的 $2$ 的正整数次幂的数字。

首先定义 $s$ 和 $top$ 是一个数组和长度。设 $l=\min_{m'\ge m}\{\log_{2}m\}$。

随后定义一个循环 $i$，$i=l$ 到 $2\le m$ 不成立结束，$i$ 每次乘二，循环内容：如果 $i\le m$，则 $m=m-i$ 并将 $i$ 添加到 $s$ 中。

接着如果 $m \bmod 2=1$ 则 $m=m-1$，并将将 $1$ 添加到 $s$ 中。

再令 $l=\min_{top'\ge top}\{\log_{2}top\}$，对 $s$ 排序。

然后一个 `while` 循环，只要 $top<l$ 则循环，找到最小非 $1$ 的 $s_{i}$，令 $s_i=\dfrac{s_{i}}{2}$，再添加一个 $s_i$ 到 $s$ 中，再对 $s$ 排序。

最后再排序一次，输出 $s$。

# Code

复杂度：$O(T(\log m+top \log^2 top ))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+1;
int T;
long long s[maxn],top=0;
long long _log2(long long m){
	long long log=1;
	while(m>log) log*=2;
	return log;
}
int main(){
	cin>>T;
	while(T--){
		long long m;
		cin>>m;
		top=0;
		long long log=_log2(m);
		for(long long i=log;2<=m;i/=2){
			if(i<=m) m-=i,s[++top]=i;
		}
		if(m%2==1){
			s[++top]=1;
			m--; 
		}
		log=_log2(top);
		sort(s+1,s+top+1);
		while(top<log){
			int i=1;
			while(s[i]==1) i++;
			s[i]/=2;
			top++;
			s[top]=s[i];
			sort(s+1,s+top+1);
		}
		sort(s+1,s+top+1);
		for(long long i=1;i<=top;i++){
			cout<<s[i]<<" ";
		}
		cout<<endl;
	}
	return 0;
}
/*

*/
```

---

## 作者：沉石鱼惊旋 (赞：1)

考虑调整法解决这个问题。首先我们可以把 $n$ 拆分成长度最小的全为 $2$ 的次幂组成的形式。就是直接按位拆分出来。这个构造天然满足前两个条件。考虑第三个条件，我们把一个 $2^{k+1}$ 拆分成两个 $2^k$ 长度会多 $1$。每次都把这个拆下去，直到序列长度也是 $2$ 的次幂。

又要求字典序最小，所以我们每次选最小的一个 $2^{k+1}$ 拆分出来。当然要求 $k\geq 0$。也就是说我们不能选 $1$ 出来。用堆维护这个过程，如果找出来的是 $1$ 再开一个变量记录。输出答案的时候把 $1$ 补回来。

<https://www.luogu.com.cn/record/204321503>

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
void solve()
{
    ll n;
    cin >> n;
    multiset<ll> s;
    for (int i = 0; i < 60; i++)
    {
        if (n >> i & 1)
            s.insert(1LL << i);
    }
    int cnt1 = 0;
    while (__builtin_popcount(s.size() + cnt1) != 1)
    {
        ll t = *s.begin();
        s.erase(s.begin());
        if (t == 1)
        {
            cnt1++;
            continue;
        }
        else
        {
            s.insert(t >> 1);
            s.insert(t >> 1);
        }
    }
    // cout << s.size() + cnt1 << '\n';
    for (int i = 1; i <= cnt1; i++)
        cout << 1 << ' ';
    for (ll i : s)
        cout << i << ' ';
    cout << '\n';
}
int main()
{
    int t;
    cin >> t;
    while (t--)
        solve();
    return 0;
}
```

---

## 作者：CaiZi (赞：1)

这么逆天的题真的是基础赛 T2 吗？

先不考虑序列长度为 $2$ 的非负整数次幂的要求，我们可以判断 $m$ 在二进制下从右往左第 $i$ 位是否为 $1$，如果是就将 $2^{i-1}$ 放入序列。由于要求字典序最小，最终将序列从小到大排序并输出即可。

接下来考虑序列长度的要求，我们设按照上面处理后序列的长度为 $n$。那么考虑序列长度要求后，设最小的序列长度为 $2^p$，满足 $2^p\ge n$ 且 $p$ 为非负整数。我们容易求出 $p$。

然后我们此时需要进行 $2^p-n$ 次操作，每次选择序列中不为 $1$ 的数，将其分裂为 $2$ 个为自身 $\frac{1}{2}$ 的数。初始时序列就是不考虑序列长度要求时求得的序列。由于我们要求字典序最小，贪心的考虑，我们需要让靠前的数尽量变小。所以每次操作选择目前最小的不为 $1$ 的数进行操作。

可以使用位运算求出初始序列和 $p$，然后使用优先队列/堆维护每次操作（所以这是基础赛 T2 应该有的数据结构？）。代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,m,n,s;
priority_queue<int,vector<int>,greater<int>>q;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>t;
	while(t--){
		n=0;
		cin>>m;
		for(int i=0;i<=62;i++){
			if(m&(1ll<<i)){
				q.push(i);
				n++;
			}
		}
		if((1ll<<__lg(n))!=n){
			for(int i=1;i<=(1ll<<__lg(n)+1)-n;i++){
				while(q.top()==0){
					cout<<"1 ";
					q.pop();
				}
				s=q.top();
				q.pop();
				q.push(s-1);
				q.push(s-1);
			}
		}
		while(!q.empty()){
			cout<<(1ll<<q.top())<<' ';
			q.pop();
		}
		cout<<'\n';
	}
	return 0;
}
```

---


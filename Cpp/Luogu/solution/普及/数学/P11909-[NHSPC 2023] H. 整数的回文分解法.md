# [NHSPC 2023] H. 整数的回文分解法

## 题目描述

H 教授是一位密码学专家，他现在正在研究如何对一个正整数做特殊分解，因而发明了正整数的回文分解法，其分解方法如下：对于一个正整数 $n$，把 $n$ 分解成 $k$ 个正整数 $x_1, x_2, \ldots, x_k$ 的和，满足 $n = x_1 + x_2 + \ldots + x_k$，且 $x_1, x_2, \ldots, x_k$ 由左读到右和由右读到左相同。

当两种分解法分解出来的正整数数量不同，或者出现的次序不同时，则视为不同的分解法。更严谨地说，设 $n = a_1 + a_2 + \ldots + a_k = b_1 + b_2 + \ldots + b_l$ 为两种回文分解法。若 $k \ne l$，或者 $k = l$ 但存在 $i \in \{1, 2, \ldots, k\}$ 使得 $a_i \ne b_i$，则视为不同的分解法。例如正整数 $6$ 有 $8$ 种回文分解法，分别是

1. $6$；
2. $2 + 2 + 2$；
3. $3 + 3$；
4. $2 + 1 + 1 + 2$；
5. $1 + 4 + 1$；
6. $1 + 1 + 2 + 1 + 1$；
7. $1 + 2 + 2 + 1$；
8. $1 + 1 + 1 + 1 + 1 + 1$。

给定一个正整数 $n$，请写一个计算机程序去计算 $n$ 有多少种不同的回文分解法。因为这个数字可能很大，你只要求出方法数除以 $10^9 + 7$ 的余数就行了。

## 说明/提示

### 测试数据限制

* $1 \le t \le 10^4$。
* $1 \le n_i \le 10^{15}$。
* 输入的数皆为整数。

### 评分说明

本题共有四组子任务，条件限制如下所示。
每一组可有一或多个测试数据，该组所有测试数据皆需答对才可获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $10$ | 输入的 $n_i$ 两两相异，且 $n_i \le 30$ |
| 2 | $30$ | $n_i \le 1000$ |
| 3 | $10$ | $n_i \le 10^6$ |
| 4 | $50$ | 无额外限制 |

## 样例 #1

### 输入

```
2
3
6```

### 输出

```
2
8```

# 题解

## 作者：hwc2011 (赞：2)

这道题可以通过暴力手段得出答案，蒟蒻来讲讲为什么。\
对于 $N$，我们可以把它拆成 $N$ 个 $1$，由于数据要求回文，所以我们只需要考虑前 $\lfloor \frac{N}{2} \rfloor$ 个 $1$ 就行了。\
对于前 $\lfloor \frac{N}{2} \rfloor$ 个 $1$，都有 $2$ 种选择：

1. 与后面的 $1$ 相连。
2. 不与后面的 $1$ 相连。

由于回文，后面和前面同理，所以答案就是 $2^{\lfloor \frac{N}{2} \rfloor }$。

---

## 作者：Aurelia_Veil (赞：1)

# 题解：P11909 \[NHSPC 2023] H. 整数的回文分解法。

## 题目传送门：[in](https://www.luogu.com.cn/problem/P11909)

### 一、本题拆解：

本题要求我们求出 $N$ 的拆分成若干个数，并且要求拆分后为回文数，求出总共的拆分种类数。

### 二、思路拆分：

#### 1. 回文

因为最终结果要求是回文数，所以可以只保留前面 $\lfloor \frac{N}{2} \rfloor$ 个数。

#### 2. 拆分

既然是拆分，我们可以反向思考，把拆分转换成合并，也就是将 $\lfloor \frac{N}{2} \rfloor$ 个 $1$ 合并成其他数列，那这样每个数就有两种合并方式：

- 不合并。
- 与后面一个数合并。

### 三、结论

既然每个数有两种合并方式，最终答案就为 $2^{\lfloor \frac{N}{2} \rfloor}$。

### 四、代码讲解

我们可以选择快速幂快速的解决此公式，得到答案。

---

感谢观看咩～

---

## 作者：Tracy_Loght (赞：1)

众所周知，什么是回文？

回文简单点说是从**前**往**后**读和从**后**往**前**读一样。

有什么用呢？当然了，有趣的来了。

先把读入数据化为最简形式，及 $n$ 个 $1$。

将串分为**三份**：左串，回文中心（可能是两个字符）和右串。

然后在最左和最右插入隔板。

定义这个串最终的形式是，每个隔板向左一直走，直到遇到了**另**一个隔板，则这个值就是移动的**次数**。

容易发现，仅对于左串操作，右串回文复制，这最终做出来的是回文的，符合条件，则答案加 $1$。

**注意**：回文中心可能是两个字符，但这对答案没有很大的影响。

容易得到这样的操作是 $2$ 的 $\frac{n}{2}$ 下取整次方，那答案也是这个了。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,jl;
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0); 
	cin>>t;
	while(t--){
		cin>>n;jl=1;
		long long x=n/2,z=2;
		while(1){
			if(x==0) break;
			if(x%2==1) jl=(jl*z)%1000000007;
			z=(z*z)%1000000007;
			x=x/2;
		}
		cout<<jl<<"\n";
	}
	return 0;
}
```

---

## 作者：__xxy_free_ioi__ (赞：1)

# P11909 \[NHSPC 2023] H. 整数的回文分解法

数学题。

## 解法
由题意得，$N$ 可以分解为 $N$ 个一，我们可以将前一半中的任意两个数合并，而因为分解后是回文的，所以后一半与前一半是镜像操作，可以忽略。

那么，答案就十分明显了，就是 $ans = 2^{\lfloor N \div 2 \rfloor}$。由于 $N$ 非常大，我们使用快速幂即可。

## 代码

~~这个就不用放了吧。。。~~

```
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int mod = 1e9 + 7;

int power(int a, int k) {
	int res = 1;
	while (k) {
		if (k & 1) (res *= a) %= mod;
		(a *= a) %= mod;
		k /= 2;
	}
	return res;
}

signed main() {
	int t, n;
	cin >> t;
	while (t--) {
		cin >> n;
		cout << power(2, n / 2) << '\n';
	}
}
```

---

## 作者：Vct14 (赞：1)

设 $N=\begin{matrix}\underbrace{1+1+\cdots+1}\\N\text{个}\end{matrix}$。对于前 $\left\lfloor\dfrac{N}{2}\right\rfloor$ 个 $1$，我们都可以选择是否与后面的 $1$ 合并。由于是回文的，所以不用管后面 $\left\lceil\dfrac{N}{2}\right\rceil$ 个 $1$（直接对称过去即可）。最终答案为 $2^{\left\lfloor\frac{N}{2}\right\rfloor}$。快速幂求解即可。

---

## 作者：CJR_Rain (赞：1)

## 解题过程

一看到这题的数据范围我就知道，正解的时间复杂度要么是 $O(t)$，要么是 $O(t\log n)$，搜索等方法肯定行不通，推式子才是王道。

### Plan A：

盯着题面看，看能不能瞪出什么式子。但很明显，我不是拉马努金，失败。

### Plan B：

孩子傻，但孩子力气大。直接一波人脑代替电脑，用大脑枚举 $1≤n≤9$ 时所有 $ans$ 的值，然后找规律：

$n=1$ 时，$ans=1$。

$n=2$ 时，$ans=2$。

$n=3$ 时，$ans=2$。

$n=4$ 时，$ans=4$。

$n=5$ 时，$ans=4$。

$n=6$ 时，$ans=8$。

$n=7$ 时，$ans=8$。

$n=8$ 时，$ans=16$。

$n=9$ 时，$ans=16$。

可以发现，$∃x\in \mathbb{N},\ ans=2^x$。然后继续观察，发现 $n≥2$ 时，$ans$ 的值成对出现。

有了以上两条信息，就可以大胆假设，合理推断，得出 $ans=2^{\lfloor \frac{n}{2}\rfloor}$。套进去算一下，$ans$ 的值全部对得上。

有了式子就好办了。求 $x^y$，而且还要取模，一眼快速幂，直接打个快速幂模版就行了。时间复杂度也是 $O(t\log n)$，不会 TLE。

## Code

```cpp
#include <bits/stdc++.h>

#define IS std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define OS std::cout.tie(nullptr) -> std::ios::sync_with_stdio(false)

using namespace std;

constexpr int mod = 1e9 + 7;

long long qpow(long long x, long long y) {

    long long res = 1;

    while(y != 0) {

        if((y & 1) == 1) {

            res = res * x % mod;
        }

        x = x * x % mod;
        y >>= 1;
    }

    return res;
}

signed main() {

    IS;
    OS;

    int T;
    cin >> T;

    while(T-- != 0) {

        long long n;
        cin >> n;

        cout << qpow(2, n >> 1) << '\n';
    }

    return 0;
}
```

---

## 作者：LittleAcbg (赞：1)

我们考虑一个回文分解的形态，有两种情况：

- $n=a_1+a_2+\dots+a_{k-1}+a_k+a_{k-1}+\dots+a_1$
- $n=a_1+a_2+\dots+a_{k-1}+a_k+a_k+a_{k-1}+\dots+a_1$

即，项数分别为奇数和偶数的。对项数为偶数的，我们可以看成是中间有一项 $0$（注意这时我们自己进行的规定，只有中间一项可以为 $0$）。

因此我们只需考虑项数为奇数的。令 $a_k=mid\in[0,n]$，那么我们固定 $mid$ 之后，$a_1,a_2,\dots,a_{k-1}$ 就是 $\dfrac{n-mid}2$ 的任意分解（注意需保证 $\dfrac{n-mid}2$ 为整数，否则无法分解）。

接下来我们先考虑如何求解整数 $m$ 的（任意）分解数。容易想到使用 DP，$f_i$ 表示整数 $i$ 的分解数，转移方程也很简单，$\displaystyle f_i=\sum_{j=0}^{i-1}f_j$，$f_0=1$。

然后，我们稍微模拟一下就会发现 $f_i=2^{i-1}$。这个通项公式其实也好理解，我们将其视为 $n$ 个相同的球分成任意多组的方案数，那么每个球都可以选择与上一个球分在同一组或新开一组，公式就是 $2^{i-1}$。注意 $f_0=1$。

那么现在的问题就变成了求 $\displaystyle\sum_{mid=0}^nf_\frac{n-mid}2[2|n-mid]$，也就是对所有的合法 $mid$，$f_\frac{n-mid}2$ 求和。容易发现 $\dfrac{n-mid}2$ 会取到 $0,1,\dots,\lfloor\dfrac n2\rfloor$ 中所有整数，因此上面那个求和式就可以转化为 $\displaystyle\sum_{i=0}^{\lfloor\frac n2\rfloor}f_i$。

由于 $f_0$ 的特殊性，我们先将其化为 $1+\displaystyle\sum_{i=1}^{\lfloor\frac n2\rfloor}f_i$，然后我们将 $f_i=2^{i-1}$ 代入就可以得到答案为 $\displaystyle1+\sum_{i=1}^{\lfloor\frac n2\rfloor}2^{i-1}$，用等比数列求和公式就可以得到 $1+2^{\lfloor\frac n2\rfloor}-1=2^{\lfloor\frac n2\rfloor}$。

所以我们用快速幂输出 $2^{\lfloor\frac n2\rfloor}$ 的值即可。

当然貌似观察样例也能直接猜出答案……毕竟样例输出都是 $2$ 的幂这一特点提示性非常强。

---

## 作者：five_rice_water (赞：1)

可以说这题主要考察的是比赛经验。

因为这道题的数据范围 $n$ 相对较大，一般来说对于一个大数，果断打表找规律。

于是就发现了以下规律，第一列的数字枚举的是 $n$，第二列的数字是对应的答案。

```
1 1
2 2
3 2
4 4
5 4
6 8
7 8
8 16
9 16
10 32
```

或许到这里你已经发现了规律了，对于一个数字 $n$，组成的回文序列长度为 $2^{\lfloor\frac{n}{2}\rfloor}$ 次方，但是遗憾的是本蒟蒻不会证明，在此给出快速幂求解的代码，总时间复杂度 $O(t\times\log n)$，可以通过。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 105;
const int Mod = 1e9 + 7;
int t, n;

int QuickPower(int x, int k) {
	int ans = 1;
	int base = x;
	while (k) {
		if (k & 1)
			ans *= base, ans %= Mod;
		k >>= 1;
		base *= base, base %= Mod;
	}
	return ans;
}

signed main() {
	cin >> t;
	while (t--) {
		cin >> n;
		cout << QuickPower(2, n / 2) << endl;
	}
	return 0;
}
```

希望会证明的大佬早日给出证明。

---

## 作者：yihang2011 (赞：0)

## [题解：P11909 [NHSPC 2023] H. 整数的回文分解法](https://www.luogu.com.cn/problem/P11909)

先通过~~手算~~计算发现 $ans = 2^{\lfloor \frac{n}{2} \rfloor}$，再来反推理由：

正整数 $n$ 可以看成 $n$ 个 $1$ 相加，由于分解要求回文，只用考虑 $\lfloor \frac{n}{2} \rfloor$ 个 $1$ 有多少种方法结合起来。

对于每一个 $1$，有两种行为：

- 与后面数合并；
- 不与后面数合并。

前一半最后一个数与后一半的第一个数合并也能保持回文。

所以根据乘法原理，结果就是 $2^{\lfloor \frac{n}{2} \rfloor}$。

由于 $1 \le n \le 10^{15}$，肯定是要用快速幂的，时间复杂度 $\mathcal O(\log n)$。

上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int mod = 1e9 + 7;

ll qp(ll x, ll k) {
	ll res = 1;
	while (k) {
		if (k & 1) {
            res *= x;
            res %= mod;
        }
  		x *= x;
        x %= mod;
		k /= 2;
	}
	return res;
}

int main() {
	int T;
	cin >> T;
	while (T--) {
        ll n;
		cin >> n;
		cout << qp(2, n / 2) << endl;
	}
}
```

[AC Record](https://www.luogu.com.cn/record/213649512)

---

## 作者：ggylz49 (赞：0)

对于每个 $n$，都可以看成 $n$ 个 $1$ 相加。对于 $n$ 个 $1$，由于要保证加法式子回文，所以前一半和后一半要同时变化。于是，我们需要考虑的只是前 $\lfloor \dfrac{n}{2} \rfloor$ 个数有多少种组合方式。

对于前 $\lfloor \dfrac{n}{2} \rfloor$ 个数来说，每一个数都可以和后面的数合并，组成新的式子，例如 $1+1+1+1=4$，如果第一个 $1$ 与后面的数合并，则式子变成 $2+2=4$。

所以这 $\lfloor \dfrac{n}{2} \rfloor$ 个数，每个数都有两种方式：

1. 不与后面的数合并。
2. 与后面的数合并。

所以，总共的方法数就是 $\lfloor \dfrac{n}{2} \rfloor$ 个 $2$ 相乘，即  $2^{\lfloor \frac{n}{2} \rfloor}$（$2$ 的  $\lfloor \dfrac{n}{2} \rfloor$ 次方）。

由于 $n$ 值域较大，用快速幂求解即可。

```cpp
#include <iostream>
using namespace std;
long long pow(long long x, long long y)
{
    long long sum=1;
    while(y!=0)
    {
        if(y%2==1)sum=sum*x%1000000007;
        x=x*x%1000000007;
        y>>=1;
    }
    return sum;
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {      
        long long n,ans=1,x=n/2,y=2;
        cin>>n;
        cout<<pow(2,n/2)<<endl;
    }
    return 0;
}
```

---

## 作者：Error_Eric (赞：0)

### Statement

求有几个正整数回文串的和等于 $n$。

### Sol

回文串可以被拆成左侧，中间，右侧三个部分。令 $x, y, z$ 分别是这三个部分的和，特殊地，若回文串的长度是偶数，我们定义中间是 $0$。若长度是 $1$，我们定义 $x = z = 0$。那么 $x + y + z = 2x + y = n$。换言之 $0\le2x\le n$。只需要确定每个 $x$ 的拆分方法数即可。

一个整数 $p$ 的拆分方法数等于一个长度为 $p$ 的序列拆分为若干个子区间的方法数。注意到除了第一个位置，每个位置都可以独立地选择是否和左边的位置放在同一个区间，因此方法数是 $2^{p-1}$。特殊地，根据题目定义，$p=0$ 的答案是 $1$（对应不拆分的情况）。

因此答案就是 $1+\sum_{x=0}^{\lfloor n/2\rfloor -1}2^x = 2^{\lfloor n/2\rfloor}$。

### Code

```python
for _ in range(int(input())):
    print(pow(2, int(input()) // 2, int(1e9+7)))
```

---

## 作者：Ag2WO4 (赞：0)

证明楼下给出的结论：

首先将回文的两翼叠到一起，由于叠加起来一定是偶数，故总和奇偶性由核心（可能是零）的奇偶性决定。故若总和为奇数，不妨将一定在中间的一个一剔除，这样所有项均为偶数，不妨将其除以二，则问题转化为 $\lfloor\frac n2\rfloor$ 个无序球从第 $0$ 个箱子到第 $max-1$ 个箱子（最多是每个箱子一个球，即共 $\lfloor\frac n2\rfloor$ 个箱子）紧密排列可能性数量的问题，它是一个插板问题，答案为 $\sum_{i=0}^{\lfloor\frac n2\rfloor}C_{\lfloor\frac n2\rfloor}^i=2^{\lfloor\frac n2\rfloor}$。

快速幂取余处理即可。
```python
for i in range(int(input())):print(pow(2,int(input())//2,1000000007))
```

---

## 作者：Francium_ (赞：0)

一道很好的找规律题目。  
首先由于 $n$ 特别大，让我们造几组数据来找规律：
```
3->2
5->4
6->8
8->16
```
相信你找到了规律，即 $2^{\left\lfloor \frac{n}{2} \right\rfloor}$。~~那么结束！！~~             
当然不止这样。下面给出证明：  
由于回文具有对称性，所以可以将这个问题转化成一个长度为 $\left\lfloor \frac{n}{2} \right\rfloor$ 的全部为 $1$ 的数列（为什么是向下取整，因为如果 $n$ 是奇数，那么最中间的数会被孤立，也就不用管他。），可以在任意位置分割，求方案数。  
那么答案显而易见了，每个位置 $2$ 种选择，割或不割，所以答案就是上面的$2^{\left\lfloor \frac{n}{2} \right\rfloor}$。最后，由于 $n$ 太大，所以普通乘方会超时，所以要用快速幂，时间复杂度只有 $O(q \times \log_{2} n)$，即多次询问的 $O(q)$ 乘上快速幂的一个 $O(\log_{2} n)$，足以通过本题。代码如下。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//开long long

int qmi(int n, int m, int p) {//快速幂，记得取模
	int ans = 1;
	n %= p;
	while (m) {
		if (m & 1) {
			ans *= n;
			ans %= p;
		}
		n *= n;
		n %= p;
		m >>= 1;
	}
	return ans;
}

signed main() {
	int n, m, t;
	cin >> t;
	while (t--) {
		cin >> n;
		m = n / 2;
		cout << qmi(2, m, 1e9 + 7) << "\n";//上文所述公式
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/208654182)

---

## 作者：egg_boy (赞：0)

前置芝士：[快速幂](https://oi-wiki.org/math/binary-exponentiation/)。  

 ## 大致思路
  如果没有思路，不妨先手算 $n$ 取值为 $1$ 到 $9$ 时所对应的值，结果如下：  
 
```cpp
n=1  ans=1
n=2  ans=2
n=3  ans=2
n=4  ans=4
n=5  ans=4
n=6  ans=8
n=7  ans=8
n=8  ans=16
n=9  ans=16
```
  发现所有 $ans$ 都是 $2$ 的次幂。  
  到底是几次幂呢？如下。 
```cpp
n=1  ans=1  指数：0 -> 向下取整(1 / 2)
n=2  ans=2  指数：1 -> 向下取整(2 / 2)
n=3  ans=2  指数：1 -> 向下取整(3 / 2)
n=4  ans=4  指数：2 -> 向下取整(4 / 2)
n=5  ans=4  指数：2 -> 向下取整(5 / 2)
n=6  ans=8  指数：3 -> 向下取整(6 / 2)
n=7  ans=8  指数：3 -> 向下取整(7 / 2)
n=8  ans=16 指数：4 -> 向下取整(8 / 2)
n=9  ans=16 指数：4 -> 向下取整(9 / 2)
```
  到这里可以大胆猜想一个公式 $ans=2^{\lfloor \frac{n}{2} \rfloor}$。  

## 证明过程
  可以把 $n$ 当成 $n$ 个 $1$ 组成，所以第 $i$ 个 $1$ 和第 $i+1$ 个 $1$ 组和的情况有两种，分别为相加和不相加，而后面的的 $\lceil \frac{n}{2} \rceil$ 个 $1$ 会直接重复前面的，所以不用处理。所有的情况相乘就是上面的公式。如果还有什么疑问自己手动模拟就能解决了。  

## code
代码很简单，所以咕咕咕。

---


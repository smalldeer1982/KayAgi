# 【MX-X10-T2】[LSOT-4] 网易云

## 题目背景

别小看我的情报网，我知道你的年度曲风是二次元，你的年度关键词是未来、世界、永远，对不对？

## 题目描述

网易云音乐在 2077 年推出了统计功能，每首歌有一个好听值（可以是任意整数），每连续听的两首歌的组合值是这两首歌的好听值之和。

在 2077 年小 H 一共听了 $n$ 首歌，但是小 H 并不知道每首歌的好听值。现在依次告诉你对于 $1\le i<n$，第 $i$ 和 $i+1$ 首歌的组合值 $S_i$。现在小 H 要更换听歌方式，新的听歌方式会进行 $m$ 次听歌，第 $i$ 次听歌会听第 $a_i$ 首歌 $b_i$ 次。

小 H 希望你告诉他新的听歌方式听到的每首歌的好听值的总和。**一首歌重复听多次会重复计算好听值**。不过你也有可能无法确定最后的好听值总和，这种情况你需要输出 `Impossible`。

## 说明/提示

**【样例解释 #1】**

第二首和第三首都听了 $2$ 次，已知第二首和第三首的和是 $6$。使用乘法分配律，好听值一共是 $2\times 6=12$。

**【样例解释 #2】**

通过样例 #1，这个总和等于 $12$ 加上第三首歌的好听值 $\times 8$。可以证明通过给定的信息无法确定第三首歌的好听值，故无法确定好听值总和，输出 `Impossible`。

**【数据范围】**

对于 $10\%$ 的数据，$m=1$。

对于另外 $30\%$ 的数据，$m=2$。

对于全部的数据，$2\le n\le 10^5$，$1\le m\le 10^5$，$1\le S_i,b_i\le 1000$，$1\le a_i\le n$。

## 样例 #1

### 输入

```
5 2
8 6 7 2
2 2
3 2
```

### 输出

```
12
```

## 样例 #2

### 输入

```
5 2
8 6 7 2
2 2
3 10
```

### 输出

```
Impossible
```

## 样例 #3

### 输入

```
20 19
425 46 176 409 156 35 128 467 534 411 362 760 32 17 403 210 462 10 94
15 104
12 193
6 249
18 845
1 72
15 269
2 633
10 858
14 282
14 950
5 98
11 162
12 296
14 846
15 793
11 858
19 942
1 886
19 968
```

### 输出

```
283895
```

# 题解

## 作者：2011hym (赞：14)

## 前言

题目背景还是太超标了，跟我的年度曲风一模一样。

~~被做局了。~~

## 解题思路
- 设第 $i$ 首歌的好听值为 $x_i$，则题目给出的条件是 $x_i + x_{i+1} = S_i$。
- 通过这些方程，我们可以用 $x_1$ 表示所有的 $x$。例如：
  - $x_2=S_1-x_1$
  - $x_3=S_2-x_2=S_2-S_1+x_1$
  - $x_4=S_3-x_3=S_3-S_2+S_1-x_1$
  - 以此类推，可以发现 $x_i$ 可以表示为 $(-1)^{i+1}x_1+c_i$，其中 $c_i$ 是由 $S$ 数组决定的常数。

### 过程分析

- 总的好听值可以表示为 $x_1$ 的线性函数：$A\cdot x_1 + B$，其中 $A$ 和 $B$ 是由听歌操作和 $S$ 数组决定的常数。
- 如果 $A=0$，那么总和与 $x_1$ 无关，可以直接计算 $B$。
- 如果 $A\neq 0$，则无法确定总和，输出 `Impossible`。

### 最终计算

- 对于每次听歌操作 $a_i,b_i$，对应的 $x_{a_i}$ 的系数会增加 $b_i$。
- 将 $x_{a_i}$ 表示为 $(-1)^{a_i+1}x_1+c_{a_i}$，则总和中 $x_1$ 的系数 $A$ 就为 $\sum_{i=1}^m (-1)^{a_i+1} b_i$。
- 如果 $A=0$，则总和为 $B=\sum_{i=1}^m b_i\cdot c_{a_i}$。

**是不是觉得很难？**

其实主要代码只有 $7$ 行，已经很简便了。

## 代码实现

前面讲的思路很详细，就不加注释了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int s[100010],sum[100010],n,m,a,b,A,B;
signed main(){
    cin>>n>>m;
    for(int i=1;i<n;i++){
        cin>>s[i];
        sum[i]=sum[i-1]+((i%2==1)?s[i]:-s[i]);
    }
    for(int i=0;i<m;i++){
        cin>>a>>b;
        A+=((a%2==1)?1:-1)*b;
        if(a>1){
            B+=b*((a%2==1)?sum[a-1]:-sum[a-1]);
        }
    }
    if(A!=0){
        cout<<"Impossible";
    }else{
        cout<<-B;
    }
    return 0;
}
```

~一下秒了。~

update：2025.8.3 发现格式不太好看，改了亿点。

---

## 作者：FamousKillerconan (赞：6)

一道简单的题。


首先，我们设第一首曲子好听度为 $0$，然后再依次给每一首曲子的好听度给算出来，接着去计算就行了。


不过，问题又来了，怎样判定这种听歌方式没有准确值呢？我们还是可以假设，设第一首曲子好听度为 $1$，方法如上，如果两个算出来的结果一样，就直接输出，不一样，就是无法确定。


讲到这了，相信聪明的你能写出代码了吧，注意开 long long。

---

## 作者：jiangxinyang2012 (赞：5)

简单题。

我们发现只要知道第一首歌的好听值就可以通过 $S$ 把所有歌的好听值求出来。

所以我们考虑随机 $500$ 个第一首歌的好听值，每次计算一遍答案，看看是否相等就好了。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mod = 1e9 + 7;
const int N = 200005;
const int INF = 0x3f3f3f3f;
ll a[N];
ll b[N];
pair<ll, ll> q[N];
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    random_device rd;
    mt19937 sj(rd());
    for (int i = 2; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 1; i <= m; i++) scanf("%lld%lld", &q[i].first, &q[i].second);
    set<ll> se;
    for (int c = 1; c <= 500; c++) {
        b[1] = sj();
        for (int i = 2; i <= n; i++) b[i] = a[i] - b[i - 1];
        ll ans = 0;
        for (int i = 1; i <= m; i++) ans += b[q[i].first] * q[i].second;
        se.insert(ans);
    }
    if ((int)se.size() == 1) {
        printf("%lld\n", *se.begin());
    } else {
        printf("Impossible\n");
    }
    return 0;
}

```

---

## 作者：wjl1100 (赞：2)

## [原题传送门](https://www.luogu.com.cn/problem/P12006)

## 思路

我们可以开一个桶数组记录一下每首歌听的次数，然后遍历一遍，依次让每首歌清零，答案就为每首歌的数量乘上组合值，再更新下首歌的数量。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 0x7f7f7f7f
using namespace std;
const int maxn = 100010;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n , m , a[maxn] , tong[maxn];
signed main() {
	n = read();
	m = read();
	for(int i = 1; i < n; i++) a[i] = read();
	for(int i = 1; i <= m; i++) {
		int u = read() , v = read();
		tong[u] += v;
	}
	int ans = 0;
	for(int i = 1; i < n; i++) {
		ans += tong[i] * a[i];
		tong[i + 1] -= tong[i];
		tong[i] -= tong[i];
	}
	for(int i = 1; i <= n; i++) {
		if(tong[i]) {
			cout << "Impossible" << endl;
			return 0;
		}
	}
	cout << ans << endl;
	return 0;
} 
```

---

## 作者：Besheep (赞：2)

## Solution
设第 $i$ 首歌的好听值为 $a_i$。

知道第 $i$ 和 $i+1$ 首歌的组合值 $S_i$，我们想想可以得到些什么。

显然可以知道 $a_i+a_{i+1}$，并且也可知 
$$\left \{
\begin{aligned}
a_i+a_{2k}(i\bmod2=1)\\
a_i+a_{2k-1}(i\bmod2=0)
\end{aligned}
\right.$$

证明 $a_i+a_{2k}(i\bmod2=1)$ 如下：

不妨令 $i=1,k=3$，则有：
$$\begin{aligned}
a_1+a_6&=S_1-S_2+S_3-S_4+S_5\\
&=(a_1+a_2)-(a_2+a_3)+(a_3+a_4)-(a_4+a_5)+(a_5+a_6)\\
&=a_1+a_2-a_2-a_3+a_3+a_4-a_4-a_5+a_5+a_6\\
&=a_1+a_6
\end{aligned}
$$
同理可证 $a_i+a_{2k-1}(i\bmod2=0)$。

所以所有的 $a_i,a_{2k}$ （保证 $i\bmod2=1$） 和所有的 $a_i,a_{2k-1}$ （保证 $i\bmod2=0$）可以组合到一起，并且可求其组合值。

可以搞一个辅助数组 `tem` 去记录可不可以组合到一起，把奇数设为 $1$，偶数为 $-1$，相加为 $0$，**如果一个数出现次数乘上该数所对应的 `tem` 与另一个数出现次数乘上该数所对应的 `tem` 和为 $0$**，说明这两个数可以组合到一起。

---

我们不妨设 $a_1=0$，根据 $S_i$ 可求所有的 $a_i$，并且无论 $a_1$ 的值为几，都不影响最终的计算。

这下问题就简单了，我们可以记两个变量 $z,h$ 分别记录**组合**和**好听值总和**。

对于第 $i$ 次听歌会听第 $x_i$ 首歌 $y_i$ 次，我们将 $z\leftarrow z+y_i \times tem_{a_i}$，并将 $h\leftarrow h+y_i \times a_{x_i}$。

如果 $z=0$ 说明最终可以组合到一起，输出 $h$。

反之输出 `Impossible`。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
#define ll long long
ll n,m,a[N],x,y,tem[N],z,h;
int main(){
    cin>>n>>m;
    ll t;
    a[1]=0,tem[1]=1;
    for(int i=1;i<n;i++){
		cin>>t;
		a[i+1]=t-a[i];//求 a_i
	}
	for(int i=2;i<=n;i++){
		tem[i]=tem[i-1]*-1;//辅助数组判断能否组合
	}
    while(m--){
    	cin>>x>>y;
		z+=tem[x]*y;
		h+=a[x]*y;   	
	}
	if(z==0) cout<<h;
	else cout<<"Impossible";
	return 0;
}
```

---

## 作者：cybermage_liu (赞：2)

# 题意
[题目链接](https://www.luogu.com.cn/problem/P12006)

令 $v_i$ 为第 $i$ 首歌的好听值，给定的 $S_1、S_2、S_3...S_{n-1}$，也就是 $v_1+v_2、v_2+v_3、v_3+v_4...v_{n-1}+v_n$，共 $n-1$ 个数，求 $\sum_{i=1}^m v_{a_i}\times b_i$。若不能求出，输出 `Impossible`。
# 思路
因为只给了相邻两首歌的好听值之和，所以我们需要把最后的答案（$ans$）用 $S$ 表示出来，也就是 $ans=k_1S_1+k_2S_2+k_3S_3+...+k_{n-1}S_{n-1}$，$k$ 取整数，如果不能表示出来，就是无解，输出 `Impossible`。

可以用桶（用 $t$ 来表示）来存储每首歌听了多少遍，注意这里桶可以为负，然后从 $1$ 到 $n-1$ 扫一遍，让答案加上 $t_i$，$t_{i+1}$ 减去 $t_i$，$t_i$ 变零，如果最后 $t_n$ 非零，也是无解，否则输出答案。

我自认为非常聪明地加了一个优化：如果扫桶时存在 $t_i$ 大于 $t_{i+1}$，就是无解。

**然后发现样例 $3$ 不过**。

这是因为这样算答案，$k$ 其实取的是非负整数，不是整数。

举一个小一点的反例，求 $v_1+v_4$：  
$v_1+v_4=v_1+v_2-v_2-v_3+v_3+v_4=S_1-S_2+S_3$

很明显可以转化成功，但是在 $i=1$ 时就因为 $t_1>t_2$ 判无解了，默认成 $k_2$ 不能为负了。所以要把这个令人窒息的优化删掉，只需要把前 $n-1$ 个桶全部转化为零，最后看第 $n$ 个桶是否为零就行了。

时间复杂度 $O(n)$，显而易见。
# AC code
```cpp
#include<bits/stdc++.h>
#define int long long//不开 long long 见祖宗。
using namespace std;
int S[100010],t[100010];
signed main(){
	memset(t,0,sizeof(t));
	int n,m,ans=0,x,y;
	cin>>n>>m;
	for(int i=1;i<n;i++){
		scanf("%lld",&S[i]);
	}
	while(m--){
		scanf("%lld%lld",&x,&y);
		t[x]+=y;
	}
	for(int i=1;i<n;i++){
		t[i+1]-=t[i];
		ans+=t[i]*S[i];
		t[i]=0;
	}
	if(t[n]!=0) cout<<"Impossible";
	else cout<<ans;
	return 0;
}
```

---

## 作者：HZEason_Ai (赞：1)

## 题目大意
给你每两个相邻数的和，再给你每一个数出现的次数，问你是否能求出和，不能则输出 `Impossible`。
## 分析
以样例三为例，我们整理一下便得到了每首歌出现的次数：
```text

1 958
2 633
3 0
4 0
5 98
6 249
7 0
8 0
9 0
10 858
11 1020
12 489
13 0
14 2078
15 1166
16 0
17 0
18 845
19 1910
20 0
```
因为我们只知道两两相邻数的和，所以我们便假设 $a_2$ 也出现了 $958$ 次，则这样 $a_2$ 会多算 $325$ 次，那么就再假设 $a_3$ 有 $-325$ 个，那么 $a_3$ 就少算 $325$ 次，以此类推得到如下代码：
```cpp
//fre[]表示出现次数，sum[]表示两两的和
	for(int i=1;i<n;i++)
	{
		ans+=fre[i]*sum[i];
		fre[i+1]-=fre[i],fre[i]=0;
	}
```

算到最后我们欣喜地发现 $a_n $ 的次数消成了零，则代表没有漏下的，否则无解。
## AC Code
```cpp
#include<bits/stdc++.h>
#define int long long //不开long long见祖宗
#define endl "\n"
#define er puts("")
#define sc putchar(' ')
using namespace std;
const int N=2e5+5;
int sum[N],fre[N];
int read() //快读版子
{
	int x=0,a=1;char c=getchar();
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-') a=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=x*10+c-'0';
	return x*a;
}
void write(int x) //快写版子
{
	if(x<0)x*=-1,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
	return;
}
signed main()
{
	int n=read(),m=read(),ans=0;
	if(m==1){puts("Impossible");return 0;} //m=1显然不成立
	for(int i=1;i<n;i++) sum[i]=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		fre[x]+=y;
	}
	for(int i=1;i<n;i++)
	{
		ans+=fre[i]*sum[i];
		fre[i+1]-=fre[i],fre[i]=0; //若fre[i]为正则代表少算了，否则为多算了
	}
	if(!fre[n]) write(ans);
	else puts("Impossible");
	return 0;
}
```

---

## 作者：YZren (赞：1)

比较简单，今天比赛时就 AC 了。

[题目传送门](https://www.luogu.com.cn/problem/P12006)

# 思路

- 观察题目可以发现只能两首歌一起操作，所以可以开个桶数组存每首歌听的次数。
- 遍历 $n-1$ 首歌，如果 $t_i$ 不为零就把 $sum$ 加上 $t_i\times s_i$，再将 $t_{i-1}$ 减去 $t_i$。
- 最后看 $t_n$ 是否为零即可。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=3e5+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),m=read(),s[maxn],a[maxn],b[maxn],sum;
inline void work(){
	f(i,1,n-1) s[i]=read();
	f(i,1,m) a[i]=read(),b[a[i]]+=read();
	f(i,1,n-1){
		if(!b[i]) continue;
		sum+=b[i]*s[i];
		b[i+1]-=b[i];
	}
	if(b[n]!=0) puts("Impossible");
	else write(sum);
}
signed main(){work();return 1^1;}
```

---

## 作者：George222 (赞：1)

这是一道解方程题。

---

根据题面我们设每首单曲的好听值为 $a_i$；两首歌的组合值为 $S_i$。

$$S_i = a_i + a_{i + 1}$$

推导方程：

$$a_2 = S_1 - a_1$$

$$a_2 + a_3 = S_2$$

代入 $a_2 = S_1 - a_1$：

$$
(S_1 - a_1) + a_3 = S_2 \\
a_3 = a_1 + (S_2 - S_1) \\
$$

类似的，我们可以继续推导出：

$$a_4 = a_3 + (S_3 - S_2) = a_1 + (S_2 - S_1) + (S_3 - S_2)$$

---

设 $x_i$ 为 $a_1$ 的系数，$x_i \in [-1, 1]$；$y_i$ 为一系列 $S_i$ 的差分项，$y_i = S_{i - 1} - S_1$。

那么我们即可得到以下计算公式：

$$a_i = x_ia_1 + y_i$$

---

对于代码实现部分：

$$x_i = -x_{i - 1}$$

推导 $y_i$：

$$
S_{i - 1} = a_{i - 1} + a_i \\
S_{i - 1} = (x_{i - 1}a_1 + y_{i - 1}) + (f_ia_1 + y_i) \\\\
\text{if } x_i + x_{i - 1} = 0 \\
S_{i - 1} = y_{i - 1} + y_i \\
y_i = S_{i - 1} - y_{i - 1}
$$

---

设有 $n$ 首歌，每首歌被听的次数为 $cnt_i$，总好听值为：

$$\sum_{i = 1}^{n} cnt_ia_i = \sum_{i = 1}^{n} cnt_i(x_iv_1 + y_i)$$

将此答案分为两部分，含未知数（$a_1$）部分，常数部分。分别为：

$$a_1(\sum_{i = 1}^{n} cnt_ix_i)$$

我们暂时记为 $a_1 \times num$。

$$\sum_{i = 1}^{n} cnt_iy_i$$

---

如果 $num \neq 0$ 则答案根据未知数决定，答案不唯一，输出 `Impossible`。

如果 $num = 0$，则答案为常数部分：$\sum_{i = 1}^{n} cnt_iy_i$。

---

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long

int n, m;
int s[100005];

int cnt[100005];
int x[100005], y[100005];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n - 1; i++)
        cin >> s[i];
    
    for (int i = 0; i < m; i++)
	{
        int a, b;
        cin >> a >> b;
        cnt[a] += b;
    }
    x[1] = 1;
    y[1] = 0;
    for (int i = 2; i <= n; i++)
	{
        x[i] = -x[i - 1];
        y[i] = s[i - 1] - y[i - 1];
    }
	
    ll num = 0, res = 0;
    for (int i = 1; i <= n; i++)
	{
        num += cnt[i] * x[i];
        res += cnt[i] * y[i];
    }
    if (num != 0)
        cout << "Impossible" << "\n";
    else
        cout << res << "\n";    
    return 0;
}
```

---

## 作者：jimmy9_666 (赞：1)

# P12006 【MX-X10-T2】[LSOT-4] 网易云 题解

[题目传送门](https://www.luogu.com.cn/problem/P12006)

### 题意

一共有 $n$ 首歌，每首歌都有一个好听值 $x_i$，给你一个长度为 $n - 1$ 的序列 $s$，$s_i = x_i + x_{i + 1}$。

再给你 $m$ 对数 $a_i, b_i$，表示第 $a_i$ 首歌听了 $b_i$ 次，求 $\sum_{i=1}^{m} x_{a_i} \times b_i$。

### 分析

我们先开一个 $cnt$ 数组，$cnt_i$ 表示第 $i$ 首歌听了几次。

然后我们从 $1$ 开始往 $n$ 遍历，对于每一个 $i$，由于我们一定要听够 $cnt_i$ 遍这首歌，然后我们知道 $i$ 和 $i + 1$ 的好听值总和，所以我们可以把答案增加 $s_i \times cnt_i$，然后将 $cnt_{i + 1}$ 减掉这次已经听过的次数，即减掉 $cnt_i$。

这时候 $cnt_{i + 1}$ 可能变成负数，但是可以不用理它，有因为可以在后面听歌次数为正数的时候补回来。

至于怎么判断无解，我们只需要看遍历完了以后 $cnt_n$ 是不是等于 $0$ 就可以了，如果不等于 $0$，说明前面有补不回来的次数，也就是说无解。

### 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
#define LL long long
//#define int long long

using namespace std;

const int N = 1e5 + 10;

int n, m;
int s[N];
int cnt[N];
LL ans;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i < n; i ++ )
		scanf("%d", s + i);
	for (int i = 1; i <= m; i ++ ) {
		int a, b;
		scanf("%d%d", &a, &b);
		cnt[a] += b;
	}
	for (int i = 1; i <= n; i ++ ) {
		cnt[i + 1] -= cnt[i];
		ans += cnt[i] * s[i];
	}
	if (cnt[n] != 0)
		printf("Impossible\n");
	else
		printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：canwen (赞：1)

前言：我的做法很神秘。

## 题目大意
形式化题意，有 $n$ 首歌，每首歌都有对应的好听值 $s_i$，但只给定长度为 $n-1$ 的序列 $S$，对于 $1\le i < n$，有 $S_i = s_i + s_{i+1}$。

给定 $m$ 对 $a_i,b_i$，求 $\sum s_{a_{i}}b_i$。
## Solution

$$S_{1} = s_1 + s_2\textcircled{1} $$
$$S_{2} = s_2 + s_3 \textcircled{2} $$
$$S_{3} = s_3 + s_4 \textcircled{3}$$
$$S_{4} = s_4 + s_5 \textcircled{4}$$
$$S_{5} = s_5 + s_6 \textcircled{5}$$
$$S_{6} = s_6 + s_7 \textcircled{6}$$
$$\dots$$



显然若存在一对编号奇偶性不同的歌，若 $b_i$ 的值相同（若值不同，就把它拆成几段，分别取两首歌听的次数最小值为 $k$），就可以通过运算得出。

例如统计第 $2$ 首歌和第 $7$ 首歌在听 $k$ 次下的好听度和，即 

$$k(s_2+s_7) = k[(\sum_{i=2}^{6}S_{i})-2(s_3+s_4+s_5+s_6)] = k[(\sum_{i=2}^{7}S_{i})-2(\textcircled{3}+\textcircled{5})] $$

例如统计第 $1$ 首歌和第 $6$ 首歌在听 $k$ 次下的好听度和，即

$$k(s_1+s_6) = k[(\sum_{i=1}^{5}S_{i})-2(s_2+s_3+s_4+s_5)] = k[(\sum_{i=1}^{5}S_{i})-2(\textcircled{2}+\textcircled{4})] $$

注意到里面的每一项求和的可以运用前缀和预处理出来，于是分奇偶性讨论即可，注意细节。

当**不存在**编号奇偶性不同的时候，还有若干首要听的歌时无解。
## Code
赛时原本懒得写的，看到大家都很快过了，图个乐写了写。

```cpp
#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;

#define int long long
//#define getchar getchar_unlocked
//#define putchar putchar_unlocked
#define mk make_pair
#define pb emplace_back
#define pint pair<int,int>
#define i128 __int128
#define pc putchar('\n')
#define fst first
#define snd second
#define nowtime (double)clock()/CLOCKS_PER_SEC
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
int in(){
	char a = getchar();
	int k = 0, kk = 1;
	while(!isdigit(a)){
		if(a == '-') kk=-1;
		a=getchar();
	}
	while(isdigit(a)){
		k = k*10 + a - '0', a = getchar();
	}
	return k*kk;
}
void out(int a){
	if(a < 0) putchar('-'),a=-a;
	if(a > 9) out(a/10);
	putchar(a%10+'0');
}
const int N = 1e5 + 5;
int n,m,s[N],ti[N],tmp[N];
int pr[N],_pr[N],__pr[N];
signed main(){
	cin >> n >> m;
	_rep(i,1,n-1) s[i] = in(), pr[i] = pr[i-1]+s[i];
	_reps(i,1,n,i+=2){
		_pr[i] = s[i];
		if(i - 2 >= 1) _pr[i] += _pr[i-2];
	}
	_reps(i,2,n,i+=2){
		__pr[i] = s[i];
		__pr[i] += __pr[i-2];
	}
	int ans = 0;
	_rep(i,1,m){
		int a = in(), b = in();
		ti[a] += b;
	}
	vector <int> ji, ou;
	ji.clear();
	ou.clear();
	_rep(i,1,n){
		if(ti[i]){
			if(i%2 == 1) ji.pb(i);
			else ou.pb(i);
		}
	}
	while(ji.size()&&ou.size()){
		int u = min(ji[0],ou[0]), v = max(ji[0],ou[0]);
		ji.erase(ji.begin()), ou.erase(ou.begin());
		int k = min(ti[u],ti[v]), num;
		if(u&1){
			int num = (pr[v-1] - pr[u-1] - 2*(__pr[v-2] -__pr[u-1])) * k;
			ans += num;
			ti[u] -= k;
			ti[v] -= k;
			if(ti[u]){
				if(u&1) ji.pb(u); else ou.pb(u);
			}
			if(ti[v]){
				if(v&1) ji.pb(v); else ou.pb(v);
			}
		}else{
			int num = (pr[v-1] - pr[u-1] - 2*(_pr[v-2] -_pr[u-1])) * k;
			ans += num;
			ti[u] -= k;
			ti[v] -= k;
			if(ti[u]){
				if(u&1) ji.pb(u); else ou.pb(u);
			}
			if(ti[v]){
				if(v&1) ji.pb(v); else ou.pb(v);
			}
		}
	}
	if(ji.size()||ou.size()){
		cout << "Impossible\n";
	}else cout << ans, pc;
	return 0;
}
```

难度主观觉得中位黄，但是听说有更简单的做法。

[通过记录](https://www.luogu.com.cn/record/211071126)。

---

## 作者：粥2414 (赞：1)

# 题目描述
有 $n$ 个数，但是只告诉你相邻两个数的和，求选定的几个数的和，可以选重复的数字，无法求出则输出 ``Impossible``。
# 思路
## 朴素算法
看到题目的第一眼就想到能不能把每个数字求出来。但是一共有 $n$ 个未知数，却只有 $n-1$ 个式子，显然是求不出来的。所以只能找规律。

设第 $i$ 首歌的好听值为 $a_i$，那么题目给的条件可以表示为：
$$
\begin{cases}
a_1+a_2=s_1\\
a_2+a_3=s_2\\
a_3+a_4=s_3\\
\dots\\
a_{n-1}+a_n=s_{n-1}
\end{cases}
$$
考虑能不能得出非相邻数字之间的关系。于是用第一个式子减去第二个式子，得：
$$
a_1-a_3=s_1-s_2
$$
再用此式子加上第三个式子，得：
$$
a_1+a_4=s_1-s_2+s_3
$$
发现可以以此类推得到任意两个数之间的关系，于是得到一个时空复杂度均为 $O(n^2)$ 的暴力算法。即计算出每两个数相加或相减的结果，然后求解。
## 优化
这样显然不能通过此题。

由于我们只能得到两个数之间的关系而不能得到一个数的大小，所以考虑用**双指针**法标记当前选中的两个数，然后计算两者的关系求解。这样可以优化空间复杂度，但依然不能改变时间复杂度。

想到可以运用**扫描线**的思想，移动两个指针，在移动指针时计算当前两个数之间的关系。于是继续寻找规律。

还是上面的例子，多加减几次就可以发现一下规律：（建议读者自己手搓观察一下以便于理解）

设右指针为 $j$，左指针为 $i$，当前两数的和**或**差为 $now$。

1. 当 $j$ 为奇数时，指针右移需要让 $now$ 加上 $s_j$。当 $j$ 为偶数时，指针右移需要让 $now$ 减去 $s_j$。
2. 当 $j$ 为奇数时，$now$ 对应 $a_j$ 的负值，$j$ 为偶数时，$now$ 对应 $a_j$ 的正值。
3. $i$ 的情况与 $j$ 相反。

然后只需要 $O(n)$ 的遍历每一个数，统计答案即可。

考虑如何处理答案。

开一个桶统计每个数要求的次数，每次查到两个要求数量不为 $0$ 的数时，判断两个数的符号，然后让两个数对应的桶分别减去相应的值，然后答案加上 $now$ 即可。

非法情况当然就是当 $j$ 到头而 $i$ 未到头时退出。

然后就可以愉快地 AC 啦！
# 代码
注意特判当两数同为负时，要把整个式子乘上 $-1$，以免死循环。（其实不特判也可以，两数以及答案会因为~~奇妙的化学反应~~，在溢出后又回归正确答案并跳出死循环）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
//char buf[1<<23],*p1=buf,*p2=buf;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<23,stdin),p1==p2)?EOF:*p1++)
inline ll read() {
	ll x = 0, f = 1;
	char ch;
	while ((ch = getchar()) < 48 || ch > 57)if (ch == '-')f = -1;
	while (ch >= 48 && ch <= 57)x = x * 10 + ch - 48, ch = getchar();
	return x * f;
}
short __sta[1009], __len;
inline void write(ll x, bool bo) {
	if (x < 0)putchar('-'), x = -x;
	do __sta[++__len] = x % 10, x /= 10;
	while (x);
	while (__len)putchar(__sta[__len--] + 48);
	putchar(bo ? '\n' : ' ');
}
const ll N=1e6+9;
ll t[N];
ll n,m;
ll s[N];
ll ans;
ll io=1,jo=1;
int main(){
	n=read(),m=read();
	for(int i=1;i<n;i++){
		s[i]=read();
	}
	for(int j=1;j<=m;j++){
		ll a=read(),b=read();
		t[a]+=b;
//		cout<<"dhw "<<a<<' '<<b<<endl;
	}
//	for(int i=1;i<=3;i++)cout<<t[i]<<' ';
//	cout<<endl;
	ll j=1;
	ll now=0;
	for(int i=1;i<=n&&j<=n;){
		
//		for(int i=1;i<=3;i++)cout<<t[i]<<' ';
//		cout<<endl<<ans<<endl;
		while(t[i]==0&&i<=n){
			if(i%2==1)now-=s[i];
			else now+=s[i];
			i++;
		}
		while((t[j]==0&&j<=n)||(j<=i&&j<=n)){
			if(j%2==0)now-=s[j];
			else now+=s[j];
			j++;
		}
		if(i>n)break;
		if(i<=n&&j>n){
			puts("Impossible");
			return 0;
		}
		if(i%2==1){
			io=1;
		}else{
			io=-1;
		}
		if(j%2==0){
			jo=1;
		}else{
			jo=-1;
		}
		//判断两值符号
		ll p=min(t[i],t[j]);
		if(io==-1&&jo==-1)p=-p;//特判两值同为负数情况
		t[i]=t[i]-p*io;
		t[j]=t[j]-p*jo;
		ans+=now*p;
	}
	write(ans,1);
	return 0;
}
```

---

## 作者：良心WA题人 (赞：1)

结论：若奇数位置上和偶数位置上听歌次数之和相同，则可以确定。想知道值可以给第一个数随便赋个权然后计算。

考虑证明。记第一个数为 $x$。则第二个数是 $S1-x$，第三个数是 $S2-S1+x$，依此类推，要想让第一个数取值没有影响，则 $+x$ 和 $-x$ 的次数要相同，而偶数全是 $-x$，奇数全是 $+x$，所以可以得到上面的结论。

其实根据上面的证明，可行的方法还有很多。比如代入第一个数为 $0$ 或 $1$ 判定是否相同，或者直接把第一个数当未知数进行换元等等。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=1e5+4;
int a[NN],b[NN],s[NN],w[NN];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
    assert(n<=100000&&m<=100000&&n>=1&&m>=1);
	for(int i=1;i<n;i++)
		scanf("%d",&s[i]),assert(s[i]>=1&&s[i]<=1000);
	int cnt[2]={0};
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
        assert(a[i]<=n&&a[i]>=1&&b[i]>=1&&b[i]<=1000);
		cnt[a[i]%2]+=b[i];
	}
	if(cnt[0]!=cnt[1])
	{
		printf("Impossible");
		return 0;
	}
	w[1]=0;
	for(int i=2;i<=n;i++)
		w[i]=s[i-1]-w[i-1];
	long long res=0;
	for(int i=1;i<=m;i++)
		res+=1ll*w[a[i]]*b[i];
	printf("%lld",res);
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

设第一个数为 $\text i$，根据相加关系求出后面每个数（实部为颠倒相减，虚部为 $\pm\text i$ 交替），加权加和后看是不是实数即可。

```python
a,b=map(int,input().split());a=[0];c=d=0
for i in map(int,input().split()):a.append(i-a[-1])
for i in range(b):e,f=map(int,input().split());c+=f*a[e-1];d+=f*(-1)**(e&1)
print('Impossible'if d else c)
```

---

## 作者：_H17_ (赞：0)

## 题目分析

假设每首歌好听程度是 $x_i$。

给定你 $x_i+x_{i+1}(i<n)$，求 $\sum\limits_{i=1}^{n}x_i\times y_i$。

显然 $y_i$ 随便求。

注意到组成了 $n-1$ 个方程，考虑消元（显然无论如何消元只要有剩余就无解，所以尽量靠前消元）。

对于每个 $y_i$，使用 $(x_i+x_{i+1})\times y_i$，并且让 $y_{i+1}\gets y_{i+1}-y_i$。

如果最后 $y_n=0$，说明消元成功了输出答案即可，否则消元失败无解。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,val[1000001],listen[1000001],ans;
signed main(){
    cin>>n>>m;
    for(int i=1;i<n;i++)
        cin>>val[i];
    for(int i=1,a,b;i<=m;i++){
        cin>>a>>b;
        listen[a]+=b;
    }
    for(int i=1;i<n;i++)
        ans+=val[i]*listen[i],listen[i+1]-=listen[i];
    if(listen[n])
        cout<<"Impossible";
    else
        cout<<ans;
    return 0;
}
```

---

## 作者：five_rice_water (赞：0)

这道题可以说是一个纯纯的找到性质就秒了的题目。

我们先把题目转化一下。

首先我们知道了听完任意相邻两种歌曲的好听值和，然后可以通过某些信息推出部分歌曲点对的好听值和。题目告诉你每一个歌曲对应的权值，每次可以把**已知点对好听值和的歌曲点对**的两首歌曲的权值减 $1$，问能否让序列的所有值全部变成 $0$，可以的话输出所有歌曲好听值和。

我们不难发现以下性质。

对于两个歌曲点对 $x$ 和 $y$，当且仅当 $x$ 为偶数，$y$ 为奇数，或者 $x$ 为奇数，$y$ 为偶数时，可以互相消除。

怎么证明呢？

假设两个歌曲 $a$ 和 $f$，因为 $f - a = 5$，所以两个数字一个奇数一个偶数，我们可以得到 $S_a+S_b+S_c+S_d+S_e - 2\times S_b - 2\times S_d = (a+b)+(b+c)+(c+d)+(d+e)+(e+f) - 2\times (b+c)-2\times (d+e) = a+f$，通过这种方式得到 $a$ 和 $f$ 的好听值和。

如果是奇数，则没有这种性质，可以用类似的方式推理。

那么有没有解可以判断了，要计算权值和就可以在判断有没有解的时候进行判断就可以了。

简单说一下，因为在上面 $a$ 和 $f$ 的例子当中我们可以发现，$S_a+S_b+S_c+S_d+S_e$ 这一部分可以普通前缀和。

剩下的部分观察可得，当较小的数字是 $a$ 的时候，减掉的数字是 $2\times S_b + 2\times S_d$，也就是从比 $a$ 大的数字开始，每次增加 $2$。

进一步观察发现，可以维护两个前缀和，因为减掉的序列奇偶性不会变化。

然后代码细节有点多，不过总之时间复杂度 $O(n)$。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int n, m, ans, a[N], b[N], s[N], sum[N];
int vis[N];
int j[N], o[N];
queue<int>l, r;

int dis(int i, int k) {
	int tmp = sum[k - 1] - sum[i - 1];
	if (i % 2 == 1)
		tmp -= (j[k - 1] - j[i - 1]);
	else
		tmp -= (o[k - 1] - o[i - 1]);
	return tmp;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i < n; i++) {
		cin >> s[i];
		sum[i] = sum[i - 1] + s[i];
		if (i % 2 == 1) {
			j[i] = j[i - 1];
			o[i] = o[i - 1] + (2 * s[i]);
		} else {
			o[i] = o[i - 1];
			j[i] = j[i - 1] + (2 * s[i]);
		}
	}
	for (int i = 1; i <= m; i++) {
		cin >> a[i] >> b[i];
		vis[a[i]] += b[i];
	}
	for (int i = 1; i <= n; i++) {
		if (vis[i] != 0) {
			if (i % 2 == 1) {
				l.push(i);
			} else {
				r.push(i);
			}
		}
	}
	while (!l.empty()) {
		if (r.empty())
			break;
		int x = l.front();
		l.pop();
		int y = r.front();
		r.pop();
		int tmp = dis(min(x, y), max(x, y));
		int cur = min(vis[x], vis[y]);
		ans += tmp * cur;
		vis[x] -= cur;
		vis[y] -= cur;
		if (vis[x] != 0)
			l.push(x);
		if (vis[y] != 0)
			r.push(y);
	}
	for (int i = 1; i <= n; i++) {
		if (vis[i] != 0) {
			cout << "Impossible";
			return 0;
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：lw393 (赞：0)

简单题。

题目给出了相邻两首歌权值的和即 $S_i = p_i + p_{i + 1}$。并给出了每首歌的次数，那么我们该怎么利用 $S_i$ 去得出答案呢。我们给出做法：（$t_i$ 表示这首歌的次数，$ans$ 为答案。）

如果 $time_i \not = 0$，$time_{i + 1} \leftarrow time_{i+1} - time_i$，$ans \leftarrow ans+S_i\times time_i$。

若最后 $time_{n} > 0$，则无法得到答案。

否则输出答案。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;

map<int, int>mm;
int s[N];

signed main(){
    int n, m;
    cin >> n >> m;
    for(int i = 1; i < n; i++) cin >> s[i];
    for(int i = 1; i <= m; i++) { int x, t; cin >> x >> t; mm[x] += t; }
    int ans = 0;
    for(int i = 1; i < n; i++) { if(mm[i]) { mm[i + 1] -= mm[i]; ans += s[i] * mm[i]; } }
    if(mm[n]) { cout << "Impossible\n"; }
    else cout << ans << '\n';

    return 0;
}
```

---

## 作者：modfish_ (赞：0)

## 思路
不妨记 $c_i$ 表示第 $i$ 首歌听的次数。

从 $1$ 开始，将听 $c_1$ 次第 $1$ 首歌和 $c_1$ 次第 $2$ 首歌，将获得 $c_1\times S_1$ 的好听值，之后不妨将 $c_2$ 减少 $c_1$。减成负数也没有关系，不妨认为听负数次歌会降低好听值。

于是从 $1$ 到 $n-1$ 依次模拟即可，最后若 $c_n=0$，说明最终答案即为统计得到的好听值，否则无解。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 1e5 + 5;

ll s[maxn], tag[maxn];

int main(){
    int n, m;
    scanf("%d %d", &n, &m);
    for(int i = 1; i < n; i ++) scanf("%lld", &s[i]);
    for(int i = 1; i <= m; i ++){
        int a, b;
        scanf("%d %d", &a, &b);
        tag[a] += b;
    }
    ll ans = 0;
    for(int i = 1; i < n; i ++) ans += tag[i] * s[i], tag[i + 1] -= tag[i];
    if(tag[n]) printf("Impossible\n");
    else printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：lzh301 (赞：0)

## Solution

题目并未直接给出每首歌的好听度，而是给出第 $i$ 首和 $i+1$ 首歌的好听度之和，因此不能直接计算。考虑先用桶将每个操作存下来，再过一遍数组，对于每一个 $i\in(1,n-1)$ 将它本身和它的下一位同时减去它的值，再将求和变量加上 $S_i$。如果数组的第 $n$ 位最后值不为 $0$，则不能计算，反之输出求和变量即可。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
map<int,int>mp;
int n,m;
int s[N];
int cnt;
int ans;
signed main(){
	cin>>n>>m;
	for(int i=1;i<n;i++)cin>>s[i];
	for(int i=1;i<=m;i++){
		int a,b;
		cin>>a>>b;
		mp[a]+=b;
	}
	for(int i=1;i<=n-1;i++){
		mp[i+1]-=mp[i];
		ans+=mp[i]*s[i];
		mp[i]=0;
	}
	if(mp[n])cout<<"Impossible";
	else cout<<ans;
}
```

---


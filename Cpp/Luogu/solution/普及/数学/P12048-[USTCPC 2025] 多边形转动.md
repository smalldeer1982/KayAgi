# [USTCPC 2025] 多边形转动

## 题目描述

回レ回レ回レ回レ回レ回レ回レ回レ回レ！（旋转吧旋转吧旋转吧旋转吧旋转吧旋转吧旋转吧旋转吧旋转吧！）

克露丝卡尔酱特别喜欢旋转，不光是雪月花，也有好看的圆圈（并不一定绿色），更有正多边形。

现在她操控着一个边长为 $a$ 的正 $m$ 边形，绕着一个边长为 $b$ 的正 $n$ 边形**顺时针转动**。初始状态是前者紧挨着后者的一条边的一端，每次旋转以正多边形公共边上的一点为中心点。她想知道，多少次转动之后，多边形会回到原位置？（只要求多边形回到原位，不要求各条边回到原位，即边是全同的）

## 说明/提示

样例 1 解释：
![](https://cdn.luogu.com.cn/upload/image_hosting/362c49xj.png)

样例 3 解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/7tbjx06k.png)

## 样例 #1

### 输入

```
2 4 3 4```

### 输出

```
8```

## 样例 #2

### 输入

```
3 4 4 4```

### 输出

```
24```

## 样例 #3

### 输入

```
3 3 4 4```

### 输出

```
24```

# 题解

## 作者：Needna (赞：3)

思路分析：首先发现这个题和 $m$ 一点关系没有，接下来思考一段把总时间分成许多整除的时间，即：

```cpp
int x=b/__gcd(a,b);//x表示转x次整除b
```
注意到每转 $x$ 次会经历 $x+a \times x\div b-1$ 次操作。然后再算出用多少个这样的整除时间可以回到原点，求最大公因数即可。

ac code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,m1,m2,b,ans; 
signed main(){
    cin>>a>>m1>>b>>m2;
    int x=b/__gcd(a,b); 
    int bian=a*x/b;
    int k=m2/__gcd(bian,m2);
    cout<<k*(x+bian-1);
    return 0;
}
```

---

## 作者：MaiJingYao666 (赞：2)

# P12048 [USTCPC 2025] 多边形转动 题解  
不妨通过后面两个样例观察到答案与 $m$ 无关。  
### 解题思路  
挺好的一道思维题，很显然的是，总路程应该为 $\operatorname{lcm}(a,b\times n)$，记为 $u$。但步数显然不是 $\frac{u}{a}$，观察可知，在顶角不对齐的情况下旋转会增加一步。那么我们显然可以找到一个周期，不妨先找到旋转后第一次顶角对齐（不一定到左上角），则此时走过边长度为 $\operatorname{lcm}(a,b)$，记为 $d$，走过边数为 $\frac{d}{b}$，记为 $r$。显然此时旋转了 $r-1$ 次，因此走了 $\frac{d}{a}+r-1$ 步。再考虑旋转到左上角，很显然这需要 $\frac{\operatorname{lcm}(r,n)}{r}$，记为 $s$，答案即为 $s\times (\frac{d}{a}+r-1)$。  
### AC 代码  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull a,m,b,n;
int main(){
	cin>>a>>m>>b>>n;
	ull d=a*b/__gcd(a,b);
	ull k=d/a;
	ull r=d/b;
	//每走d单位需要走 k+r-1 回合  
	ull s=n/__gcd(r,n);
	cout<<s*(k+r-1); 
}
```

---

## 作者：htl2025 (赞：2)

## 题目理解
我们需要计算一个边长为 $a$ 的正 $m$ 边形（内多边形）围绕一个边长为 $b$ 的正 $n$ 边形（外多边形）顺时针旋转，直到内多边形回到初始位置所需的旋转次数。旋转时，内多边形每次以一个公共边的接触点为中心旋转。

## 关键观察
1. 旋转角度：每次旋转的角度是外多边形的一个外角，即 $360/n $ 度。

2. 接触点移动：内多边形每次旋转后，接触点会移动一定的边长。

3. 周期：我们需要找到最小的旋转次数 $k$，使得内多边形的位置和初始位置完全相同（边全同）。

## 数学推导
1. 外多边形的外角：每次旋转的角度为 $θ = 360/n$   度。

2. 内多边形的边长：内多边形的边长为 $a$，外多边形的边长为 $b$。

3. 旋转后的位置：每次旋转后，内多边形的接触点会移动 $b$ 的长度（因为外多边形的边长为 $b$。

4. 回到原位的条件：内多边形需要移动的总边长是 $m \times a$ 的整数倍（因为内多边形有 $m$ 条边，每条边长 $a$）。

5. 最小公倍数：我们需要找到最小的 $k$ 使得 $k \times b$ 是 $m \times a$ 的整数倍，即 $k \times b \equiv 0 \bmod (m \times a)$。

6. 数学公式：最小的 $k$ 满足 $k =\operatorname{lcm}(m \times a, b) / b$。


```cpp
#include <bits/stdc++.h>
#define ll long long // 使用 long long 防止溢出
using namespace std;
ll gcd(ll a, ll b) {
    return b == 0 ? a : gcd(b, a % b);
}
int main() {
    // 输入变量：
    // a - 内多边形边长
    // m - 内多边形边数
    // b - 外多边形边长
    // n - 外多边形边数
    ll a, m, b, n;
    cin >> a >> m >> b >> n;

    // 计算a和b的最大公约数
    ll g = gcd(a, b);
    
    // 计算外多边形边长与公约数的比值
    ll x = b / g;
    
    // 计算内多边形每次旋转的相对移动量
    ll bian = a * x / b;
    
    // 计算完成一个完整周期需要的旋转次数系数
    ll k = n / gcd(bian, n);
    
    // 计算最终需要的总旋转次数
    // x + bian - 1表示一个周期内的旋转次数
    // k表示需要重复的周期数
    ll ans = k * (x + bian - 1);

    // 输出结果
    cout << ans << endl;

    return 0;  // 程序正常结束
}
```

---

## 作者：hgckythgcfhk (赞：2)

广告：[USTCPC2025 题解汇总（部分）](https://www.luogu.com.cn/article/xl8dsc9j)。

观察样例 $3$ 解释，观察 $6,12,18,24$，发现样例解释从 $1$ 开始编号实际上是提示。这几个旋转后是等价的，而且这几个东西的特殊性质是再走一步就能走到等价的初始状态，而且容易发现模 $6$ 同余的东西都是等价的，我们考虑怎么把这个 $6$ 算出来，显然是要走两个多边形边长的 $\operatorname{lcm}$，所以必须要至少先走 $\dfrac{\operatorname{lcm}(a,b)}{a}$ 步，然后看到拐角处要多走一步废的，因为上一步多走出来一部分，然后下一步一走就会浪费掉上一步没多走出来的一部分，所以相当于两步走了一步，由于在走到我们想要的一步之前每一个拐角都会多走一部分，所以要加上拐角的个数，也就是 $\dfrac{\operatorname{lcm}(a,b)}{b}$，注意到最后一个拐角不需要多走，所以要减 $1$。

现在再考虑这样的循环需要做多少次，一个循环要走 $\dfrac{\operatorname{lcm}(a,b)}{b}$ 条边，而我们的目标是走到最后一条边，设刚才的东西是 $c$，所以我们需要走 $\dfrac{\operatorname{lcm}(c,m)}{c}$。然后直接把循环次数和长度乘起来就好了。

以下是线下选手 $42$ 队提供的赛时代码，非常感谢 $42$ 队。

```cpp
#include <bits/stdc++.h>
#define il inline
#define rg register
#define cit const rg unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)//,freopen("O.in","r",stdin),freopen("O.out","w",stdout)
#define int rg unsigned
#define void il void
#define ll long long
#define ull unsigned ll
#define lll __int128
#define db double
#define vector basic_string
#define pq priority_queue
#define vint vector<unsigned>
#define vll vector<ll>
#define vull vector<ull>
#define ump unordered_map
#define ust unordered_set
#define deq deque
#define mkp make_pair
#define pii pair<unsigned,unsigned>
#define pll pair<ull,ull>
#define fi first
#define se second
#define Bool(a,n) bitset<n>a
#define sca(a) for(int $=0;$<n;cin>>a[++$])
#define cle(a) memset(a,0,sizeof a)
#define tmx(a) memset(a,0x3f,sizeof a)
#define tmn(a) memset(a,0xbf,sizeof a)
#define tif(a) memset(a,0xff,sizeof a)
//#define ge getchar_unlocked()
#define pu putchar_unlocked
#define lik(x) __builtin_expect((x),1)
#define ulk(x) __builtin_expect((x),0)
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
//#define abs(a,b) (a>b?a-b:b-a)
#define fls cout<<endl;
#define PP pop_back()
#define PS push
#define BK back()
#define SZ size()
//inline ll max(const rg ll a,const rg ll b){return a>b?a:b;}
//inline ll min(const rg ll a,const rg ll b){return a<b?a:b;}
inline ll abs(const rg ll a,const rg ll b){return a>b?a-b:b-a;}
using namespace std;constexpr unsigned N=1<<17,M=4e3+2;//constexpr ll inf=1e9+7;
//unsigned p;
constexpr unsigned p=998244353;
//constexpr unsigned p=1e9+7;
//自动取模类
/**/
namespace mod{
	void add(int&a,cit b){a+=b,a>=p?a-=p:0;}
	void sub(int&a,cit b){add(a,p-b);}
	il unsigned mul(cit ll a,cit ll b){return a*b%p;}
	il unsigned pw(int ll a,int b){int ll s=1;for(;b;b>>=1,a=a*a%p)b&1?s=s*a%p:0;return s;}
	il unsigned inv(cit a){return pw(a,p-2);}
	void div(int&a,cit b){a=mul(a,inv(b));}
	il unsigned div(cit a,cit b){return mul(a,inv(b));}
}
using mod::add;
using mod::sub;
using mod::mul;
using mod::inv;
using mod::pw;
/**/
/**/
namespace IO{unsigned char b[1<<22],*l=b,*r=b;
	#define ge (ulk(l==r)?r=(l=b)+fread(b,1,1<<22,stdin):0,ulk(l==r)?'\0':*l++)
	il unsigned rd(){int char c=ge;int s=0;while(c<48||c>58)c=ge;while(lik(c<59&&c>47))s=s*10+(c&0b1111),c=ge;return s;}
	void rd(int&s){int char c=ge;s=0;while(c<48||c>58)c=ge;while(lik(c<59&&c>47))s=s*10+(c&0b1111),c=ge;}
}using IO::rd;
ull a,n,b,m;
il ull gcd(int ll x,int ll y){if(!x||!y)return x|y;for(int ll r=x%y;r;r=x%y)x=y,y=r;return y;}
il ull lcm(int ll x,int ll y){return x/gcd(x,y)*y;}
void init(){cin>>a>>n>>b>>m;

}void solve(){init();
    cit ll c=1ll*(lcm(a,b)/a+lcm(a,b)/b-1);
    cit ll d=lcm(a,b)/b;cout<<(lcm(d,m)/d)*c;
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}
```

删除了引用的被注释掉的 `hgckythgcfhk.h` 的内容，保证这部分全是注释。

---

## 作者：bayiran (赞：1)

## 题解：P12048[USTCPC 2025]多边形转动

### 步骤
1. 先求出 $a$ 与 $b \cdot n$ 的最小公倍数 $t$，
记 $t = [a,b \cdot n] $，这代表 $m$ 边形在转动过程中共走过的距离。

2. 然后可以得到：**如果没有转弯，转动数应为走过的距离除以 $m$ 边形的边长** $a$，也就是 $\dfrac{[a,b \cdot n]}{a} $。

3. 接下来考虑转弯：

    1. 将 $n$ 边形看做长度为 $ b \cdot n$ 的线段，每次转弯在线段上虽然没有移动，但是计数要增加 $1$。
       
    2. 这种转弯每走过 $b$，就会有一次（到达$n$ 边形的顶点）。因此计数增加 $ \dfrac{[a,b \cdot n]}{b} $。
  
    3. 考虑一种特殊的转弯：**两个多边形的角重合时，并不增加计数**，而每经过 $[a,b]$ 的长度，两个多边形的角就会重合。因此，计数应减少 $ \dfrac{[a,b \cdot n]}{[a,b]}$。

综上，最终转弯数应为：

> $  \dfrac{[a,b \cdot n]}{a} + \dfrac{[a,b \cdot n]}{b} - \dfrac{[a,b \cdot n]}{[a,b]}$

化简后得
> $  \dfrac{(a+b) [a,bn] [a,b] - ab[a,bn]}{ab[a,b]}$

直接输出即可。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int lcm(int a,int b){
    return a*b/__gcd(a,b);
}
int main() {
    int a, m, b, n;
    cin>>a>>m>>b>>n;
    cout<<((a+b)*lcm(a,b*n)*lcm(a,b)-a*b*lcm(a,b*n))a*b*lcm(a,b))<<endl;
    return 0;
}
```

注：其实可以用 $[a,b] \cdot (a,b) = a \cdot b $ 来替换 $lcm()$ 函数，输出就变成了
$ \dfrac{n(a+b-(a,b))}{(a,bn)}$。

### 替换后的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    long long a, m, b, n;
    cin>>a>>m>>b>>n;
    cout<<(n*(a+b-__gcd(a,b))/__gcd(a,b*n))<<endl;
    return 0;
}
```

---

## 作者：lzh_ovo (赞：0)

# P12048题解

[题目传送门](https://www.luogu.com.cn/problem/P12048)

## 题目大意

本题让我们计算一个边长为 $a$ 的正 $m$ 边形，绕着一个边长为 $b$ 的正 $n$ 边形顺时针转动，多少次转动之后，多边形会回到原位置。

## 题目思路

本题类似于[P12190（具体看我写的题解）](https://www.luogu.com.cn/article/boorw6gp)，同样本题可以推导出一个公式代入。拿样例一举例，$a=2$，$b=3$，转一次 $2/3$，两次 $7/3$，三次就是 $4$。这样就可以得出公式，转 $n$ 次为 $(a÷b+1)×n−1$ 次操作。那么只要再求出一个最大公因数就行了，题目挺考思维，但是也有点简单。

## 代码（因为比较简单不加注释了）


```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,m,b,n,d,x,y,g;
int main(){
	cin>>a>>m>>b>>n;
	d=a*b/__gcd(a,b);
	x=d/a,y=d/b,g=n/__gcd(y,n);
	cout<<g*(x+y-1);
    return 0;
}
```
（求过！）

---


# [蓝桥杯 2025 省 B] 移动距离

## 题目背景

本站蓝桥杯 2025 省赛测试数据均为洛谷自造，与官方数据可能存在差异，仅供学习参考。

## 题目描述

小明初始在二维平面的原点，他想前往坐标 $(233, 666)$。在移动过程中，他只能采用以下两种移动方式，并且这两种移动方式可以交替、不限次数地使用：
1. 水平向右移动，即沿着 $x$ 轴正方向移动一定的距离。
2. 沿着一个圆心在原点 $(0, 0)$、以他当前位置到原点的距离为半径的圆的圆周移动，移动方向不限（即顺时针或逆时针移动不限）。

在这种条件下，他到达目的地最少移动多少单位距离？你只需要输出答案四舍五入到整数的结果。

# 题解

## 作者：brofea5 (赞：23)

# 题意

一个点有两种移动方式，沿着 $x$ 轴正方向移动、以原点为圆心旋转，问走到点 $(233,666)$ 需要经过的路程

答案四舍五入至整数

# 思路

答案很简单，计算原点到 $(233,666)$ 的距离 $r=\sqrt{233^2+666^2}$，沿着 $+x$ 移动 $r$，再旋转至终点

旋转的角度 $\theta=\arcsin(666/r)$

![](https://pbs.twimg.com/media/GoVDHN4XcAAnoDF?format=jpg&name=large)

最终的路程就是：（四舍五入至整数）

$$
S=r+\frac\alpha{2\pi}\cdot 2\pi r=r(1+\arcsin(666/r))\approx 1576
$$

如果忘记 C++ 有 `asin()` 函数（$\arcsin$ 函数）了怎么办呢？

- 用 `sin()` 函数数值逼近，可以从 0.0000001 循环到 3.1400000，也可以用二分
- 在终端里用 python 的 `math.asin()` 函数
- 用 Excel 的 ASIN() 函数，如果不记得函数名可以在“告诉我”中搜索“函数”并寻找反函数
- 泰勒展开

要证明这个走法就是最佳的其实还挺麻烦，不过在几何上就比较好理解，假设有这么一条路径 $r_1,c_1,r_2,c_2,r_3,c_3$

![](https://pbs.twimg.com/media/GoVDSo_WAAEiF35?format=jpg&name=large)

把所有圆弧平移到右侧首尾相连，把所有线段平移到 $x$  轴上，可以看出线段一定长于原本的 $r$，圆弧和一定长于原本的 $c$ （可以用三角不等式证明）

严谨来说，应该用微积分证明，我们将每一次移动都看作是微小的坐标变化$(\delta x_i,\delta y_i)$

对于点 $(x,y)$ ，旋转微小角 $d\theta$ 的距离变化为 $r=x^2+y^2$，旋转，则路程为 $\delta L_R=r\,d\theta$，对于沿 $x$  轴平移，路程为 $\delta L_T=\delta x$，此时 $\theta=\arctan(y/x)$，随着 $x$ 增大而增大

$d\theta$ 极小时，约束条件可为：

$$
\sum_{i\in T} \delta x_i +\sum_{j\in R} (-y_j\,d\theta_j) \;=\;233 ,\sum_{j\in R} x_j\,d\theta_j\;=\;666
$$

综上可以构造拉格朗日函数：

$$
\mathcal{L}=\sum_{i\in T} \delta x_i+\sum_{j\in R} r_j\,d\theta_j
+\lambda\Biggl( \sum_{i\in T} \delta x_i +\sum_{j\in R} (-y_j\,d\theta_j)-233\Biggr)
+\mu\Biggl(\sum_{j\in R} x_j\,d\theta_j-666\Biggr)\,,
$$

对 $\delta x_i$ 求偏导数，可以求出 $\lambda=-1$，然后考虑旋转的部分，可以设

$$
f_j = r_j\,d\theta_j -\lambda\,y_j\,d\theta_j+\mu\,x_j\,d\theta_j=d\theta_j\Bigl(r_j + y_j+\mu\,x_j\Bigr)\,.
$$

求偏导后可知，每个旋转操作要满足：

$$
\frac{\partial f_j}{\partial (d\theta_j)}=r_j + y_j+\mu\,x_j=0\tag1
$$

注意到每次旋转都是绕原点进行，$x_j,y_j$ 由之前的运动决定，而又要使得在每个旋转的贡献中使得 $\mu$ 保持一致，则各个旋转都必须满足上式

考虑理想的候选方案，设目标点为 $(r_f,\theta_f)$ 若先水平平移至 $(r_f,0)$，则对于所有在这点的旋转操作都有

$$
r_j + y_j+\mu\,x_j=r_f+0-1\times r_f=0
$$

正好满足（1）且每个旋转必要条件一致

若在平移未完成前旋转，即 $x<r_f$ 或 $y\ne0$。将（1）写为：

$$
\sqrt{x_j^2+y_j^2}+y_j+\mu\,x_j=0
$$

若在平移还未完成时就引入旋转，那么（1）要求的 $\mu$ 会因不同步而不可能一致地取一个常数，而会取一个更“严格”的值，使得后续整体代价增大，也就是说无法找到一个 $\mu$ 满足所有旋转步都不发生效率损失

在这道题中，$\mu$ 恒定事实上使得 $\theta$  为一个差为 $0$ 的等差旋转角，也就是说，每次都旋转 $\theta_j$ 走到终点的路径就是最短的，对于任何终点都成立，这点在几何上不难证明

走多少次都是一样的，那就走一次吧

AC 代码：

```cpp
#include <bits/stdc++.h>
int main() {
  double r = sqrt(233 * 233 + 666 * 666);
  int res = r + asin(666.0 / r) * r;
  std::cout << res;
}
```

---

## 作者：HetmesAskalana (赞：7)

可以发现，只回头一次一定比多次回头反复横跳要更优还~~更好算~~。

所以结果就是先向 $x$ 正方向走 $r = \sqrt{666^2 + 233^2}$ 单位，再在圆 $x^2+y^2=666^2+233^2$ 上走到点 $(233, 666)$。最终结果是 $r + $ 扇形弧长，即为：

$S = \sqrt{666^2 + 233^2} + \sqrt{666^2 + 233^2} \times \arctan(\frac{666} {233}) = 1576.4487894460704 \approx 1576$

如图所示
![](https://s1.imagehub.cc/images/2025/04/12/28f4f9cd9afde0fbde97e60c0bee49eb.png)

---

## 作者：itzxianfish (赞：4)

## **题意**

根据规则。

**水平向右**移动，即沿着 $x$ 轴**正方向**移动一定的距离。

沿着一个**圆心在原点** $(0,0)$，以他当前位置到原点的距离为半径的圆的**圆周移动**，移动方向不限（即顺时针或逆时针移动不限）。

从 $(0, 0)$ 移动到 $(233, 666)$。

## **解法以及简要证明**

比较容易想到极坐标相关的事情。

如图，从几何直观来看。

先假设：$r = \sqrt{x^2 + y^2}$。

![拐弯草图](https://cdn.luogu.com.cn/upload/image_hosting/uk7rfcse.png)

观察 $G$ 点，其半径正是 $r$，如果我们直接从原 $x$ 轴按照规则走到 $G$ 则路程长度为：$r(1 + ∠FBG)$。

而沿着路线 $B \to F \to E \to G$ 行走，路径长度为：$BF(1 + ∠FBE) + EG$。

故尝试证明：$r(1 + ∠FBG) = BG(1 + ∠FBG) < BF(1 + ∠FBE) + EG$。

由于 $BF = BE$ 根据三角形性质，有：$BF + EG > BG = r$。

消去 $r$ 原式可以化简成证明：$BF\times∠FBE > BG\times∠EGB$。

由正弦定理，与三角形内角和关系：$\frac{BF}{BG} = \frac{BE}{BG} = \frac{\sin∠EGB}{\sin∠BEG} = \frac{\sin∠EGB}{\sin∠FBE}$。

于是可以证明：$\frac{\sin∠EGB}{\sin∠FBE} > \frac{∠EGB}{∠FBE}$。

看不出什么吗？那我们换个写法，记 $x = ∠EGB$，$y = ∠FBE$。

那么就是证明：$\frac{\sin x}{\sin y} > \frac{x}{y}$。

所以呢，构造辅助函数 $f(x) = \frac{\sin x}{x}$。

接下来就是各位喜闻乐见的求导了，这里不多赘述，我们得到结果为 $f(x)$ 单调递减，显然 $∠FBE > ∠EGB$。

于是，带入函数，原式得证。

我们发现，在**仅有一次**拐弯的时候，就存在这样的不等关系，于是**不存在更多次**拐弯使得结果更小，因此，原题目最优解为：$r(1 + θ) = \sqrt{x^2 + y^2}(1 + \arctan(\frac{y}{x}))$。

贴出计算代码（别忘了四舍五入）。

```cpp
double x = 233,y = 666,ans;
ans=sqrt(x*x+y*y)*(1+atan2(y,x));
cout<<round(ans);    // 库函数四舍五入
// cout<<1576;
```

于是我们就爽吃 $5$ 分（？）。

## **后记** 

这把我是现场怪，当时一眼顶针，看出最优解，证明是在写题解的时候憋的，当然这也是本蒟蒻第一次提交题解，求过求过，神犇奆佬轻喷，有错误直接指出谢谢谢谢谢谢谢谢。

## **修改日志**

一改：修改 Markdown 格式和 LaTeX 函数字体问题。

二改：修改滥用代码块问题。

三改：修改 LaTeX 公式和中文格式之间的问题。

四改：修改句号使用规范和其他一些符号问题。

---

## 作者：CZPchenzipei (赞：2)

**做题策略**：先水平移动到足够大的半径 $r$，使得目标点 $(233,666)$ 位于圆周上；

然后沿圆周移动所需角度 $\theta=\operatorname{atan}2(666,233)$；

总距离=水平移动距离 $(r)+$ 圆周移动距离 $(r\theta)$；

最优解出现在 $r=\sqrt{233²+666²}$ 时。

**计算**：半径 $r=\sqrt{233²+666^2}\approx706.155$；

角度 $\theta=\operatorname{atan}(666/233)\approx1.2310$ 弧度；

总距离    $=r+r\theta\approx706.155+706.155\times1.2310\approx1576.448$；   
四舍五入得 $1576$。  
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	printf("1576");
	return 0;
}
```

---

## 作者：ethanho (赞：1)

## 问题描述
小明从原点 $(0,0)$ 出发，需到达目标点 $(233,666)$。移动规则：
1. **水平移动**：沿横坐标轴正方向移动任意距离。
2. **沿圆周移动**：以当前位置到原点的距离为半径，绕原点旋转任意角度 $\theta$。

求总共的最少移动距离，四舍五入取整。

探索
---
#### 初步尝试~~找规律~~
如图所示，为方便计算和绘图，我们可以从目标点 $(4,4)$ 开始，每一步大致分为两个阶段。
- **阶段一**：水平移动至某一位置。
- **阶段二**：圆周移动调整角度至目标方向附近。
  
![](https://cdn.luogu.com.cn/upload/image_hosting/5w8e5krn.png)

此时路径距离公式为 $D=R+R\theta$，其中 $R$ 为圆的半径。

#### 进一步测试~
不妨把转折点向原点移动，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3iifw8v9.png)

红色部分即为路径经过一些简单的数学计算或者观察可知，这样总距离会更大。

以此类推，别的情况是类似的——我们可以知道总距离最小当且仅当经过一个过程，即移动一个距离后直接沿圆周运动到达。

~~这告诉我们，写题目不如一遍过来的爽快。~~

得到最后的公式：$D=R+R\theta$。

## 计算
可以得到 $R=\sqrt{233 ^ {2}+666 ^ {2}}≈706.155$。

且 $\theta=\arctan(\frac{666}{233})≈1.231$，以弧度为单位。

总距离 $D=R+R\theta≈706.155+706.155 \times 1.231≈1576.448$，取整可得 $1576$。

## 代码 
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<1576<<endl;
	return 0;
}
```

完结撒花~~~（感谢管理员辛苦审核）

---

## 作者：jinhao_wang (赞：1)

细究后可以发现，一次性到达在做圆周运动一定最优。

不妨以圆心为原点，过点 $(233,666)$ 做圆 $A$。

根据距离公式 $dis(P,Q)=\sqrt{(P_x-Q_x)^2 +(P_y-Q_y)^2}$ 得半径 $r=\sqrt {233^2+666^2}$。

即小明须先沿 $x$ 轴移动 $\sqrt {233^2+666^2}$ 单位，再沿圆 $A$ 移动 $\arctan(666/233)$ 米。

所以，总距离：

$$S=\operatorname{round}(\sqrt{233^2+666^2}  \times  (\arctan(666/233)+1)) \approx 1576$$

AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<1576<<endl;
    return 0;
}
```
简单草率！

---

## 作者：chess_OIer (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P12130)

---
## 题意
从 $(0,0)$ 到 $(233,666)$，只允许水平向右移动或以原点为中心旋转，求最短路至整数。
## 思路
本题可以证明，只回头一次一定不劣（证明放在下面了）。  
准确来说，回头几次都无所谓，但是一次好算啊！  
所以，我们可以先求 x 轴上距离（就是我们第一次要走的），再走弧即可到达。


### 对结论的证明：
首先，初始位置在原点，第一步只能是水平移动（圆周移动需半径非零）。水平移动到目标点所在圆后，沿圆周移动是唯一直接到达的方式。

其次，若尝试先水平移动到更小半径再圆周移动，需额外水平移动调整，总距离反而更长。例如，水平移动至较小半径 r，再圆周移动至某点后水平移动，计算表明总距离必然超过结论距离。

最后，通过数学验证，水平移动到 R 后沿圆周移动的总距离为最小值。其他组合方式（如多次交替移动）会引入冗余路径，无法更优。

那么，我们把这个题分成两部分：

### 1.计算水平方向上要走的距离
可以看出这个距离就是原点到坐标 $(233,666)$ 的距离。  
根据勾股定理，可得距离 D 为：

$D=\sqrt{233^2+666^2} ≈ 705.51$。

### 2.计算弧的长度
根据弧的长度公式，弧长

$$l = \frac{\theta\pi R}{180}$$。  

问题来了，$\theta$ （圆周角）是多大？  
这时反三角函数就登场了！  

$\theta = \arctan(\frac{666}{233})$  

$\arctan()$ 是反正切，这里贴上百度对反正切的定义：

---

### arctan的定义  
arctan是Arctangent的缩写，指反正切函数，它是数学术语，属于反三角函数之一，是正切函数 $y = \tan x$ 的反函数。简单来说，它是一种求逆的运算，就如同乘法的逆运算是除法一样。

---


综上，我们可以算出，  

$$\theta=\arctan(666/233)=\arctan(2.85837) ≈ 70.7176$$。  

带入公式，得弧长  

$$l = \frac{70.7176\times705.5\times3.1416}{180} = 870.76887$$。

总长 $D+l = 870.8 + 705.5 = 1576.3$。  
这里取整 $1576$。

---

代码：
```cpp
#include<iostream>
int main(){
    std::cout<<"1576";
}
```

### update

其实这题用 $\arcsin()$ 也可以做，还有泰勒展开。  
如果都不会，$\sin()$ 无限逼近也可以。

---

## 作者：yongqian123 (赞：1)

## 题目分析
画图。

先向右走到 $(r,0)$ 再走半径为 $r$ 的弧到 $(233,666)$ 是最优解：

第一证明，最右点一定不会在 $(r,0)$ 的右边，否则要绕到 $(-x,666)$ 再往右，这样明显是上面的方法更优；

第二证明，先向右，再走弧，接着向右，再走弧到 $(233,666)$，还是上面的方法更优，因为平移到下面可以发现弧更长，线段也更长。

$$C_总\approx C_右+C_弧$$

$$C_总\approx r(1+\arctan\frac{666}{233})$$

## 重点代码
```cpp
round(sqrt(233 * 233 + 666 * 666) * (1 + atan2(666, 233)))
```

---

## 作者：枫原万叶 (赞：0)

这题不难，主要是理解。

先规划一下大致思路：

任何路径都是由水平移动加圆周移动交替组成得。

第一步必须是水平向右移动（因为初始半径为 0，圆周移动无效）。

假设路径结束前最后一次移动的类型：

1. 情况一：最后一步是圆周移动，则前一步位置必须位于目标半径 r 的圆上（因为圆周移动不改动半径），然后通过圆周移动调整角度到目标 $\theta$。

2. 情况二：最后一步是水瓶移动，则前一步位置必须满足纵坐标与目标相同（水平移动不改变），即 $(x,666)$，且通过水平移动到达目标。

现在我们就可以开始分析了：

如果按照两步路径（先水平后圆周）：

从 $(0,0)$ 水平移动到 $(r,0)$，距离为 $r$。从 $(r,0)$ 圆周移动到 $(233,666)$，弧长 $r \theta$（$\theta < \pi$，取逆时针）。总距离即为：$r + r \theta = r(1+\theta) \approx 705.58156 \times (1+1.2341704) \approx 1576.389$，四舍五入就是 $1576$。

如果是按照三步路径（如先水平、再圆周、再水平）这个走法：

1. 水平移动距离 A 到 $(A,0)$。
2. 圆周旋转角度 $\alpha (0 < \alpha < \theta)$，到 $(A \cos \alpha,A \sin \alpha)$，弧长 $A\alpha$。
3. 水平移动到 $d$ 到 $(A \cos \alpha + d,A \sin \alpha) = (233,666)$。由 y 坐标：$A \sin \alpha = 666 → A = 666 \sin \alpha$。由 x 坐标：$A \cos \alpha + d = 233 → d = 233 - 666 \cot \alpha$。要求 $d \ge 0$：$\cot \alpha \le \frac{233}{666} → \tan \alpha \ge \frac{666}{233} \approx 2.858 → \alpha \ge \theta \approx 1.234$（在 $(0,\frac{\pi}{2})$ 区间正切函数递增）。但 $\alpha < \theta$ 时 $d < 0$，不可行；$\alpha > \theta$ 时 $d > 0$，可行。
4. 总距离：$A + A \alpha + d = \frac{666}{\sin \alpha} + \frac{666 \alpha}{\sin \alpha} + 233 - 666 \cot \alpha = 666 \cdot \frac{1+\alpha-\cos \alpha}{sin \alpha}+233$。
5. 取 $\alpha > \theta$（如 $\alpha = 1.24$、$1.334$、$\frac{\pi}{2} \approx 1.57$），计算总距离均大于 1576（如 1671.56、1944.55），劣于两步路径。

其它路径情况都会引入额外的弧长或非必要的移动，总距离更大。例如，先圆周移动（无效，因为初始半径为 0），或多次交替移动，均无法低于 $r(1+\theta)$。

于是我们就可以给出代码：

```cpp
#include <bits/stdc++.h>

int main() {
	double x, y, r, theta, ans;
	int res;
	x = 233, y = 666;//原题目坐标
	r = sqrt(x * x + y * y);//求目标的半径
	theta = atan2(y, x);//计算目标角度（弧度）
	ans = r * (1 + theta);//总距离
	res = round(ans);//四舍五入
	printf("%d", res);
	return 0;
}
```

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12130)

# 题目分析

首先猜想，答案应该是先沿 $x$ 轴移动到 $(r,0)$，直到以该点为圆心，$r$ 为半径画圆，$(233,666)$ 在圆周上，此时答案为 $r$ 加上圆弧的长度。下面给出一个暴力的证明：

首先证明只“转动”一次比转动多次更好：设按下面的两个方式移动

![](https://cdn.luogu.com.cn/upload/image_hosting/rmgds0cy.png)

移动方式一：$AB$ 到 $\overset {\LARGE{\frown}}{BC}$ 到 $CK$ 到 $\overset {\LARGE{\frown}}{KO}$ 到 $OF$。

移动方式二：$AM$ 到 $\overset {\LARGE{\frown}}{MO}$ 到 $OF$。

显然，$AM=AK<AC+CK=AB+CK$。所以只需证明 $\overset {\LARGE{\frown}}{MO}<\overset {\LARGE{\frown}}{BC}+\overset {\LARGE{\frown}}{KO}$。由于 $\overset {\LARGE{\frown}}{MO}=\overset {\LARGE{\frown}}{MK}+\overset {\LARGE{\frown}}{KO}$，所以只需证 $\overset {\LARGE{\frown}}{MK}<\overset {\LARGE{\frown}}{BC}$。将粉色圆沿 $x$ 轴平移至过 $B$ 点，则 $\overset {\LARGE{\frown}}{BN}=\overset {\LARGE{\frown}}{MK}$。

要想证明上述命题，需先证明一个命题：若两个圆有一条过同一点公切线，则这两个圆相切。

证明：设圆 $O$ 与圆 $O'$ 交于 $P$，$Q$ 两点，过 $P$ 作圆 $O$ 的切线 $l$，且 $l$ 也是圆 $O'$ 的切线，切点均为 $P$。连接 $OP$，$O'P$，则两线均与 $l$ 垂直，所以 $O$，$O'$，$P$ 三点共线，所以 $OO'$ 与 $l$ 垂直。由于 $l$ 过两圆的公共点 $P$ 且与两圆心的连线垂直，因此 $l$ 为两圆的根轴（即圆幂相等的点组成的直线），显然过另外一个交点 $Q$，这与 $l$ 是切线矛盾。因此两圆相切于一点。

回到上图，橙色圆与黄色圆有一条过 $B$ 点的公切线，因此两圆相切。所以 $N$ 一定在 $C$ 右侧。将 $\overset {\LARGE{\frown}}{BC}$ 与 $\overset {\LARGE{\frown}}{BN}$ 水平切成无穷份，每一份长度趋近于 $0$，则每一段近似为直线，且形如下图中的钝角三角形：

![](https://cdn.luogu.com.cn/upload/image_hosting/i403ca23.png)

由于上图 $AC>BC$，所以原图中 $\overset {\LARGE{\frown}}{BC}>\overset {\LARGE{\frown}}{BN}$，即 $\overset {\LARGE{\frown}}{BC}>\overset {\LARGE{\frown}}{MK}$。

因此最优方法是只“转动”一次就与目标点的纵坐标相等，然后再平移。现在，变量变成了 $O$ 点的横坐标。将其设为 $x$，设目标点坐标为 $(m,n)$，则可列出移动距离 $S$ 与 $x$ 的函数关系式：

$$S=\sqrt{x^2+n^2}+\arcsin(\frac{n}{\sqrt{x^2+n^2}})\times \sqrt{x^2+n^2}+\left| m-x \right|$$

求导后可得 $S$ 的最小值出现在 $x=m$ 处，将 $m$ 和 $n$ 的值代入即可求出答案，为 $1576$。

---


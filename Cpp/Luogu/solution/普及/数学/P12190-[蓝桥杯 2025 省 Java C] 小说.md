# [蓝桥杯 2025 省 Java C] 小说

## 题目描述

小蓝是一位网络小说家。现在他正在撰写一部新的推理小说，这部小说有 $n$ 个不同的人物。

小说的每一章都有以下三种情节的一种：

1. A 发现 B 不知道真相。  
2. A 发现 B 知道真相。  
3. A 知道了真相。  

为了保证读者的协调和新鲜感，小蓝的小说还要满足以下要求：

1. “B 发现 A 不知道真相”不能在 “A 知道了真相”后。  
2. “B 发现 A 知道真相”不能在 “A 知道了真相”前。  
3. “B 发现 A 不知道真相”不能在 “B 发现 A 知道真相”后。  
4. 相邻的两章情节类型不同，例如如果第一章是 A 发现 B 不知道真相那么第二章就不能是 C 发现 D 不知道真相。  
5. 完全相同的情节不能出现两次。  

现在小蓝希望知道，他最多能写多少章。

## 说明/提示

### 样例说明 1

以下是一种可能的情况：
1. B 发现 A 不知道真相。
2. A 知道了真相。
3. B 发现 A 知道真相。
4. A 发现 B 不知道真相。
5. B 知道了真相。
6. A 发现 B 知道真相。

小蓝一共能写 6 章。

### 评测用例规模与约定

对于 $30\%$ 的评测用例，$n \leq 5 $；  

对于所有评测用例，$ 1 \leq n \leq 10^9 $。  

## 样例 #1

### 输入

```
2```

### 输出

```
6```

## 样例 #2

### 输入

```
3```

### 输出

```
13```

# 题解

## 作者：yanmingqian (赞：12)

神秘构造。

贪心考虑，为了尽量让章节多，要让 $n$ 个人都知道一遍真相，一个人知道真相之前，要尽量让更多人发现他不知道真相，一个人知道真相之后，要尽量让更多人发现他知道真相。

我们假设现在甲刚刚知道了真相，下一个知道真相的人是乙。那么中间要写的几个章节是让除了甲之外的 $(n-1)$ 个人都知道甲知道了真相，让除了乙之外的 $(n-1)$ 个人都知道乙不知道真相。由于总共有 $n$ 个人，类似的连续情节会发生 $(n-1)$ 次。

特别地，在第一个知道真相的人知道真相之前，发现他不知道真相的人只能有一个，因为此时没有人发现真相，那么没有人会发现某个人知道真相，这样为了情节不重复，只能第二章是一个人发现了真相。同理，最后一个人发现真相之后，也只有一个人能发现最后一个人发现了真相。

这样最终答案就是 $2\times(n-1)\times(n-1)+n+2$，化简一下就是 $2n^2-3n+4$。注意当 $n=1$ 时，只能有一个章节，需要特判。

代码就很简单了。

C++ 代码：

```cpp
#include<iostream>
using namespace std;
int main(){
    long long n;
    cin>>n;
    if(n==1){
        cout<<1;
        return 0;
    }
    cout<<2*n*n-3*n+4;
    return 0;
}
```

鉴于我之前交蓝桥杯 Python 组的题解因为没有 python 代码被打回了，特意让 deepseek 帮我写了一份 Java 代码（第一遍还编译错误了，害得我专门去研究了一下）：

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        long n=scanner.nextInt();
        if(n==1){
            System.out.println(1);
        } 
        else{
            System.out.println(2*n*n-3*n+4);
        }
    }
}
```

---

## 作者：离散小波变换° (赞：4)

## 题解

我们使用三元组 $(1, a, b)$ 和 $(2, a, b)$ 表示情节 $1$ 和 $2$，使用二元组 $(3, a)$ 表示情节 $3$。题目要求我们构造一个尽量长的情节序列 $e=[e_1,e_2,\cdots]$。

由于完全相同的情节不能出现两次，对于三类情节分别有 $n(n - 1), n(n-1), n$ 种。我们可以得到答案的一个宽松的上界，即 $n + 2n(n - 1)$。然而这是不够紧的。

注意到情节 $3$ 约束了情节 $1$ 和情节 $2$，而情节 $3$ 最多发生 $n$ 次，因而一个重要的思考方向是先固定情节 $3$ 的出现情况。由于 $n$ 名角色地位相同，因此总是可以认为角色 $1$ 先知道真相，接着是角色 $2$、角色 $3$，以此类推。即我们先固定 $e$ 中的一些元素为 $[(3, 1), (3, 2), \cdots, (3, n)]$，然后考虑在这些元素前后插入情节 $1$ 和 $2$ 来使得 $e$ 最长。

- 在所有第一类情节里，有 $n - 1$ 个情节为 $(1, i, 1)$，它们只能出现在 $(3, 1)$ 之前，然而由于相邻情节类别不同，此时又不能穿插第二类情节（此时没有人知道真相），因而最多从这 $n - 1$ 个情节里选取一个；
- 在所有第二类情节里，有 $n - 1$ 个情节为 $(2, i, n)$，它们只能出现在 $(3, n)$ 之后，然而由于相邻情节类别不同，此时又不能穿插第一类情节（此时所有人知道真相），因而最多从这 $n - 1$ 个情节里选取一个。

于是我们得到了一个更紧的上界，即 $n + 2n(n-1) - 2(n - 2) = 2n^2 -3n + 4$。可以证明，对于 $n\ge 2$ 这个界是可以取得的。例如如下构造方案：

- 第一个情节随意地选取 $(1, 2, 1)$；
- 接着对于 $i = 1, 2, \cdots, n -1$，添加情节 $(3, i)$，此时 $i$ 知道了真相，而 $i +1$ 不知道真相。分别有 $n - 1$ 个情节 $\{(2, j, i)\mid j\neq i\}$ 和 $\{(1, j, i + 1)\mid j\neq i + 1\}$，将它们穿插在一起就可以保证相邻情节类别不同。
- 最后的情节随意地选取 $(2, 1, n)$。

可以验证题目中的几个限制条件。该方案一共使用了 $2 + 2(n-1)(n - 1) + n$ 个情节，达到了先前说明的上界。

需要特判一下 $n = 1$，代码就不给了。

---

## 作者：Dicer_L (赞：3)

## solution

### 题意

有 $n$ 个人，每个人有两种状态：发现真相或未发现真相。一个操作是每个人可以公布他人的状态。另一个操作是改变自己的状态并公布。每一个人的初始状态都是未发现真相。相同要素的公布只能公布一次，具体指公布人，被公布人，状态。操作相同且状态也相同的公布不能相邻公布。若三者都相同则只能公布一次。问最多公布条数是多少。

### 思路

理想状态下，最多公布条数为 $2n(n-1)+n$，即每个人把不包括自己的另 $n-1$ 个人的两种状态都公布了一遍，再另外加上自己公布自己的条数。这显然是错的，因为样例不对。

那么我们模拟一遍就会发现，假设第一步乙公布甲未发现真相，第二步甲改变自身状态为发现真相并公布，这样就会发现一个问题，除了甲不能公布自身未发现真相，乙已经公布了，其他剩余 $n-2$ 个人没有公布甲未发现真相！这样在开头答案数就会少了 $n-2$ 条。同样在末尾有剩余 $n-2$ 个人没有公布最后一个人已经发现真相了。

那么最后的表达式就是 $2n(n-1)+n-2(n-2)$，化简为 $2n^2-3n+4$。

注意人数为 $1$ 时的特判。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
signed main(){
    cin>>n;
    if(n==1) cout<<1;
    else cout<<2*n*n-3*n+4;
}
```

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        if (n == 1) System.out.println(1);
        else System.out.println(2 * n * n - 3 * n + 4);
        scanner.close();
    }
}
```

---

## 作者：huangfeiyun (赞：1)

## 思路
> 首先现特判当 $n=1$ 的时候，这个时候最多只有一个章节，输出 $1$ 就好了。
> 
> 其次，是一篇小说都要有开头结尾，实际上是只有小说的 $2(n−1)$ 这部分是推理部分。
> 
> 每个推理部分都有 $(n-1)$ 种推理可能。
> 
> 加上开头和结尾的 $2$ 和 $n$ 个推理的情节。

 于是我们就推出了公式 $2\times(n−1)\times(n−1)+n+2$。
 化简完就是 $2n^2-3n+4$。

代码就不给了，大家按着上面的思路自己去试着做一下吧。

这是AC记录：[AC记录](https://www.luogu.com.cn/record/230511869)。

---

## 作者：linruicong_gegeji (赞：1)

~~流水账版《名侦探柯南》。~~

## 题目大意

个人觉得挺好的一道构造题，挺能锻炼思维的。

我们要构造一部小说，只能有以下情节：

- $A$ 发现 $B$ 不知道真相。
- $A$ 发现 $B$ 知道真相。
- $A$ 知道了真相。

还有 $n$ 个人。

有以下限制：

- “$B$ 发现 $A$ 不知道真相”不能在“$A$ 知道了真相”后。
- “$B$ 发现 $A$ 知道真相”不能在“$A$ 知道了真相” 前。
- “$B$ 发现 $A$ 不知道真相”不能在“$B$ 发现 $A$ 知道真相”后。
- 相邻的两章情节类型不同，例如如果第一章是 $A$ 发现 $B$ 不知道真相那么第二章就不能是 $C$ 发现 $D$ 不知道真相。
- 完全相同的情节不能出现两次。

## 题目分析

经过略微思考过后，我们可以得出一个最理想的情况模式：

- 对于每个人：
  - 除了自己的 $n-1$ 个人发现自己不知道真相。
  - 自己知道真相了。
  - 除了自己的 $n-1$ 个人发现自己知道真相。

这样我们可以得出最理想的答案是 $2{n^2}-n$。

### 考虑限制

很明显，最理想的情况绝对不是正确答案。因为题目还有诸多限制条件，我们一一考虑限制条件。

- 条件 $1$\~$3$
  - 很明显，没有必要考虑（就是不能自相矛盾，在刚才的理想情况中已经满足）。
- 条件 $4$
  - 我们可以将顺序进行打乱，以满足相邻情节不会相同。
- 条件 $5$
  - &#x20;很明显，开头与结尾不满足，需要特殊处理。

### 总结公式

- 开头结尾各 $1$ 章。
- 中间部分知道或不知道情节共 $2(n-1) \times (n-1)$。
- 自己知道部分共 $n$ 章。

公式：
$$ans=2{(n-1)}^2+n+2$$

### 细节注意

- 因为数据范围，要使用 `long long`。
- 需要特判 $n=1$ 的情况。

## AC 代码实现

[记录](https://www.luogu.com.cn/record/229438557)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans;//开long long
int main()
{
    scanf("%d",&n);
    if(n==1) //特判
    {
        printf("1");
        return 0;
    }
    ans=2*1ll*(n-1)*(n-1)+n+2;//套公式
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

# [P12190 [蓝桥杯 2025 省 Java C] 小说](https://www.luogu.com.cn/problem/P12190)
## 题目简介：
有 $n$ 个人，每个人只能知道真相或不知道真相，小说下一篇有 $3$ 种选择：
1. A 发现 B 不知道真相。  
2. A 发现 B 知道真相。  
3. A 知道了真相。  

## 分析做法：
先特判，$n$ 等于 $1$ 时，最多只有 $1$ 个章节。

然后正解，我们假设现在 $A$ 上一轮知道了真相，下一轮知道真相的人是 $B$。那么中间要写的几个章节是让除了 $A$ 之外的 $n - 1$ 个人都知道 $A$ 知道了真相，让除了 $B$ 之外的 $n - 1$ 个人都知道 $B$ 不知道真相。由于总共有 $n$ 个人，类似的连续情节会发生 $n - 1$ 次。

化解公式就是 $2\times (n − 1)\times (n − 1) + n + 2$。

化简：
```cpp
cout << 2 * n * n - 3 * n + 4 << endl;
```

奉上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	if(n == 1){
		cout << 1 << endl;
	    return 0;
	}
    cout << 2 * n * n - 3 * n + 4 << endl;
    return 0;
}
```

谢谢观看，求过求赞。

---

## 作者：Maxsong (赞：0)

# P12190 [蓝桥杯 2025 省 Java C] 小说 题解

## 思路这一块

为了尽可能多的让小说变长，基本结构一定是：

$X _1$ 发现 $X _n$ 不知道真相 $\dots \ X _{n-1}$ 发现 $X _n$ 不知道真相；

$X _n$ 知道了真相；

$X _1$ 发现 $X _n$ 知道真相 $\dots \ X _{n-1}$ 发现 $X _n$ 知道真相；

我们可以让每个人都充当一边 $X _n$，这样就能达成最大化。

## 进一步思考

因为说过

>相邻的两章情节类型不同，例如如果第一章是 A 发现 B 不知道真相那么第二章就不能是 C 发现 D 不知道真相。

  所以把所有知道真相的情节和不知道的情节连续是不成立的。但是，由于每个人都充当一边 $X _n$，所以我们可以穿插着进行知道真相的情节和不知道的情节。

因为说过

>完全相同的情节不能出现两次。

但是开头段会连续出现不知道真相的情节，所以开头需要单独计算，结尾也是一样。

## 细节这一块

- 注意 $1$ 特判。
- **不开 `long long` 见祖宗。**

## 公式 & 代码

因为开头段和结尾段的缘故，所以其实只有 $2(n-1)$ 段是知道或不知道真相的段（不计开头结尾），而每一段又有 $(n-1)$ 次知道或不知道真相。还要算上 $n$ 个知道真相的情节和开头结尾的 $2$。所以公式：

$$
  f(x)=2 + 2(n-1) ^2 + n
  \\
  (n > 1)
$$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
signed main(void){
    scanf("%lld",&n);
    if(n==1) printf("%lld\n",1);
    else printf("%lld\n",2*(n-1)*(n-1)+n+2);
    return 0;
}
```

> 这样的小说会有人看嘛？

---

## 作者：Prico (赞：0)

### 思路

#### 第一步：

看到这个题，我就开始探索规律，先分析一下简单的样例 2：

1. B or C 发现 A 不知道真相。

2. A 知道了真相。

3. A 发现 C 不知道真相。

4. B 发现 A 知道真相。

5. A 发现 B 不知道真相。

6. C 发现 A 知道真相。

7. C 发现 B 不知道真相。

8. B 知道了真相。

9. C 发现 B 知道真相。

10. B 发现 C 不知道真相。

11. A 发现 B 知道真相。

12. C 知道了真相。

13. B or A 发现 C 知道真相。

大概就是这个样子。

发现，每个人依次知道别人是否知道真相，即：$ 2n(n-1)$ 

#### 第二步：

啊但是！

当 $n$ 等于 3 时，发现代入并不得 13，因为有限制：

回到刚才我们分析的样例 2，你会发现少了这么几个：

1. B 和 C 其中一个没有知道 A 不知道真相，即 $n-2$ 个人没发现第一个人不知道真相（$-2$ 是因为只有一个人和他自己可以知道他不知道真相）。

2. B 和 A 其中一个没有知道 C 知道真相，即有 $n-2$ 个人没发现最后一个人知道真相（$-2$ 是因为只有一个人和他自己可以知道他知道真相）。

**所以一共少了 $2(n-2)$ 种情况。**

又因为我们前面已经考虑到每个人只能知道别人是否知道真相，就不用多减那个 $n$ 了。

**也就是减去 $n-2\times2$**。

**最终公式：$2n(n-1)-(n-2\times2)$。**

最后，**不开 long long 见祖宗**（~~我写这题时就见了一次~~）。

### Code：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main(){
    cin>>n;
    if(n==1){
        cout<<1;
    }
    else {
        cout<<2*n*(n-1)-(n-2*2);
    }
    return 0;
}
```

---

## 作者：lzh_ovo (赞：0)

# P12190题解

小说的每一章都有以下三种情节的一种：
1. A 发现 B 不知道真相。
2. A 发现 B 知道真相。
3. A 知道了真相。

既然是问你最多能写几个章节，那很容易看出这是一个**最优**。而这道题直觉告诉我必会有一个公式。

## 仔细一算果真有公式（整体思路）：

有 $n$ 个人都要知道真相，所以每个人都会从不知道真相到知道真相，而为让章节数尽量多，就可以让一个人不知道真相时有更多人不知道他获得了真相，而获得真相后就可以让更多人知道他获得了真相。从而增加章节数。

## 求出公式：

题中有说明“完全相同的情节不能出现两次”由于不可以有两个同样的章节，那就可以得出 $3$ 情况就是 $n$ 种，$1$ 情况和 $2$ 情况则是 $n(n-1)$，合在一起就为  $2n(n-1)$。

不过并没有解决，因为题中有说明“相邻的两章情节类型不同”所以这个条件还得再做处理。题中有给举例“例如如果第一章是 A 发现 B 不知道真相那么第二章就不能是 C 发现 D 不知道真相。”那么就要再减掉  $(n-4)$。

那么综上，就可以概括出公式：$2n(n-1)-(n-4)$。

如果不满意还可以简化，即：$2n²-3n+4$。

不过这道题还要注意一下特殊情况哦。如果  $n=1$，那只能是 $1$ 个章节了。

下面为大家提供 AC 代码，简短又简单：


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main(){
    cin>>n;
    if(n==1) cout<<1<<endl;
    else cout<<2*n*n-3*n+4<<endl;
    return 0;
}
```

 _谢谢观看_ 

（第一次写题解，支持一下，求过审，谢谢啦）

---

## 作者：Youchenrui (赞：0)

#### 题意简化：
一部小说有 $n$ 个人物，每一章节有三种写法，每种写法需要满足给的规则才可以这样写。问最多可以写多少章。
#### 思路：
因为问题问的是最多，所以可以看出这是一个最优性问题。每章节三种写法，我们可以分开讨论。为了让第三个章节写法更多，所以 $n$ 个人都要知道一遍真相。为了让第一个章节写法更多，所以一个人知道真相之前，要尽量让更多人发现他不知道真相。为了让第二种章节写法更多，一个人知道真相之后，要尽量让更多人发现他知道真相。而三种选项互不干扰，所以我们发现这道题可以以贪心的思想考虑。

每个人最多公布除自己以外所有人的状态公布一篇，可以是不知道真相的时候也可以是知道真相的时候，也就是 $2(n-1)n$ 章。

但是，章节之间也有约束：相邻的两章情节类型不同，例如：如果第一章是 $A$ 发现 $B$ 不知道真相那么第二章就不能是 $C$ 发现 $D$ 不知道真相。完全相同的情节不能出现两次。所以要在原有的基础上减去 $n-4$。

综上所述，公式为 $2n(n-1)-n+4$。

我们还需考虑一下有没有特殊情况，我们发现当只有一个人的时候，第一种与第二种情况都不成立，所以需要特判一下 $1$，当只有一个人的时候输出 $1$。

#### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n;
    cin>>n;
    if(n==1)
        cout<<1;
    else
		cout<<2*n*(n-1)-n+4;
    return 0;
}
```

---

## 作者：Alvin_Wang (赞：0)

首先很容易想到三类情况分别有 $n(n - 1),n(n - 1),n$ 种，相加的和就是 $n + 2n(n - 1)$ 但是通过样例会发现这是错的，我们的输出过大。

那是哪里不符合要求多用了呢？重新看一下题目，题目中说完全相同的情节不能出现两次，也就是说不能连着两个章节以上都是讲谁发现了谁知道（或不知道）真相。那么在开头第一个发现真相的人前面就只能有一次别人发现他没发现真相。同理，在最后一个发现真相的人后面也只能有一次别人发现他发现了真相。

那么答案就是开头和结尾的 2 次，和 $n$ 个人发现了真相 $n$ 次，在加上中间，有 $n - 1$ 个空，穿插放入两种发现的情况，即 $2(n - 1)(n - 1)$ 次。加起来的总和就是 $2(n - 1)(n - 1) + n + 2$ 简化一下得到最后答案为 $2n^2 - 3n + 4$。

最后，当只有一个人的时候，答案是 1 ，需要要特判一下。

Code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n;

signed main(){
    cin >> n;
    if(n == 1){
        cout << 1 << '\n';
    }
    else{
        cout << 2 * n * n - 3 * n + 4 << '\n';
    }
    return 0;
}
```

---


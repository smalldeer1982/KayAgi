# [蓝桥杯 2023 省 Java B] 数组分割

## 题目描述

小蓝有一个长度为 $N$ 的数组 $A = [A_0, A_1, ..., A_{N-1}]$。现在小蓝想要从 $A$ 对应的数组下标所构成的集合 $I = {0, 1, 2, ..., N - 1}$ 中找出一个子集 $R_1$，那么 $R_1$ 在 $I$ 中的补集为 $R_2$。记 $S_1 = \displaystyle \sum_{r \in R_1} A_r$，$S_2 = \displaystyle \sum_{r \in R_2} A_r$，我们要求 $S_1$ 和 $S_2$ 均为偶数，请问在这种情况下共有多少种不同的 $R_1$。当 $R_1$ 或 $R_2$ 为空集时我们将 $S_1$ 或 $S_2$ 视为 $0$。

## 说明/提示

### 样例说明

对于第一组数据，答案为 $4$。（注意：大括号内的数字表示元素在数组中的下标。）
- $R_1 = \{0\}, R_2 = \{1\}$；此时 $S_1 = A_0 = 6$ 为偶数，$S_2 = A_1 = 6$ 为偶数。
- $R_1 = \{1\}, R_2 = \{0\}$；此时 $S_1 = A_1 = 6$ 为偶数，$S_2 = A_0 = 6$ 为偶数。
- $R_1 = \{0, 1\}, R_2 = \{\}$；此时 $S_1 = A_0 + A_1 = 12$ 为偶数，$S_2 = 0$ 为偶数。
- $R_1 = \{\}, R_2 = \{0, 1\}$；此时 $S_1 = 0$ 为偶数，$S_2 = A_0 + A_1 = 12$ 为偶数。

对于第二组数据，无论怎么选择，都不满足条件，所以答案为 $0$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq N \leq 10$。
- 对于 $40\%$ 的评测用例，$1 \leq N \leq 10^2$。
- 对于 $100\%$ 的评测用例，$1 \leq T \leq 10, 1 \leq N \leq 10^3, 0 \leq A_i \leq 10^9$。

## 样例 #1

### 输入

```
2
2
6 6
2
1 6```

### 输出

```
4
0```

# 题解

## 作者：wf2025 (赞：5)

一道~~有意思~~的题。

### 问题描述

给定一个数组，将元素重新划分为两个**互补**的子集，要求两个子集中的元素和均为**偶数**。求满足条件的**不同划分方式**有多少种。

### 解题思路

#### 奇偶分析：

数组中的元素分为奇数和偶数，只有当奇数的 **数量为偶数** 时，整个数组的和才为**偶数**，此时可能存在符合条件的子集。若 **奇数数量为奇数**，直接返回 $0$，无法满足条件。

#### 组合计算：

令 $n$ 为数组长度。

1. 若数组全为偶数，所有子集均满足条件，数目为 $2^{n}$。
2. 若奇数数量为偶数且不为 $0$，符合条件的子集数目为 $2^{n-1}$。  
   **~~计算答案时一定取模~~。**  
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1000000007;
long long powss(long long base, int exps, int mod) {
	long long result = 1;
	while (exps > 0) {
		if (exps % 2 == 1) {
			result = (result * base) % mod;
		}
		base = (base * base) % mod;
		exps /= 2;
	}
	return result;
}

int main() {
	int T;
	cin >> T;
	while (T--) {
		int N;
		cin >> N;
		vector<int> A(N);
		int c1 = 0;
		for (int i = 0; i < N; ++i) {
			cin >> A[i];
			if (A[i] % 2 != 0) {
				c1++;
			}
		}
		if (c1 % 2 != 0) {
			cout << 0 << endl;
		} else {
			if (c1 == 0) {
				cout << powss(2, N, MOD) << endl;
			} else {
				cout << powss(2, N - 1, MOD) << endl;
			}
		}
	}
	return 0;
}
```

[记录详情](https://www.luogu.com.cn/record/215036796)

---

## 作者：JIN_LONG (赞：3)

## 题目大意：
给定一个数组，将元素重新划分为两个互补的子集，要求两个子集中的元素和均为偶数。计算满足条件的不同划分方式有多少种。
## 思路：
由小学数学我们会发现。
- 奇数加奇数等于偶数。
- 奇数加偶数等于奇数。
- 偶数加偶数等于偶数。

于是再通过观察我们不难发现，如果数组中奇数的个数是奇数个，无论如何选择，都无法 $s_1$ 使和 $s_2$ 同时为偶数，因为奇数个奇数无法均分的，接着再分奇数的个数是否为零来判断即可。

以下是我代码的具体步骤。

- 输入测试用例数量 $T$，对于每组数据，输入数组长度 $n$ 和数组中的元素。
- 在每组数据中统计数组中奇数的个数，如果奇数的数量是奇数个，直接输出 $0$，因为无法分成两个偶数和。
- 否则，如果奇数的数量为零输出答案 $2^n$，如果奇数的数量大于零且是偶数，输出答案 $2^{n-1}$，注意 $2^n$ 和 $2^{n-1}$ 均要对于 $10^9+7$ 取模。
## 代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int modd = 1000000007;
ll f(int n) {
    if(n==0)return 1;
    ll x=f(n/2);
    x=(x*x)%modd;
    if(n%2)x=(x*2)%modd;
    return x;
}
int main() {
    int T;
    cin>>T;
    while(T--) {
        int n,sum=0;
        cin>>n;
        for(int i=0,a;i<n;i++) {
            cin>>a;
            sum+=a%2;
        }
        if (sum%2) cout<<"0\n";
        else cout<<f(sum?n-1:n)<<"\n";
    }
    return 0;
}

```

```java
import java.util.Scanner;

public class Main {
    private static final int m = 1000000007;

    private static long f(int n) {
        if (n == 0) return 1;
        long x = f(n / 2);
        x = (x * x) % m;
        if (n % 2 != 0) x = (x * 2) % m;
        return x;
    }

    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        while (T-- > 0) {
            int n = s.nextInt();
            int c = 0;
            for (int i = 0; i < n; i++) {
                int a = s.nextInt();
                c += a % 2;
            }
            if (c % 2 != 0) System.out.println("0");
            else System.out.println(f(c != 0 ? n - 1 : n));
        }
        s.close();
    }
}

```

---

## 作者：I_AM_TLEer (赞：2)

# P12325 [蓝桥杯 2023 省 Java B] 数组分割

## 前言：

于 5月9日 00:07 首次提交审核，~~未过审~~。
原因：非 Java 题解**质量不够**。

update on 5.10 ：疏通文意，新增 Java 语言代码，加入情况三的证明过程。

## 题目大意：

给定一个数组，将元素重新划分为两个**互补**的子集，要求两个子集中的元素和均为偶数。求满足条件的不同划分方式有多少种。

## 思考过程：

计原数组名为 $A$，其含有 $n$ 个数据。

能发现对于任意正整数，加一个偶数并不能改变其奇偶性。所以问题的关键在于奇数的个数。

可以将 $A$ 中的数据分为偶数与奇数两类，统计奇数个数，记作 $m$。

下面针对 $m$ 的情况，分为三种进行讨论：

- $m$ 为 $0$：

    序列中全是偶数，每个数均有两种可能（选或不选），那么答案为 $2^{n}$。

- $m$ 是奇数：

    此时全集的和是奇数，无论怎样进行划分，其子集必为一奇一偶，方式数为 $0$。

- $m$ 是偶数：

    对于 $m$ 个奇数，一共有 $2^{m-1}$ 种方式。以下是证明过程：

  现在假设去除一个奇数，剩下的 $m-1$ 个奇数，随意组合有 $2^{m-1}$ 个方式。由 $m$ 的第二种情况得出：无论怎样进行划分，其子集必为一奇一偶。可将预先去除的奇数添加到和为奇的子集中。

  而其余 $n-m$ 个偶数，则共有 $2^{n-m}$ 种方法。因此，方式数的总和是：

  $$2^{m-1} \times2^{n-m} = 2^{n-1}$$

程序中用到幂运算，而且注意到 $1\le N\le 10^{3}$。数据较大，选择快速幂进行优化。

到这思路已经完备，可以据此编写代码。

## C++ 代码 :

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int MOD = 1e9 +7;
int T, n, a, ans;

int pows (int a, int b) {
	int num = 1;
	while (b) {
		if (b %2 == 1)
			num = num *a %MOD;
		a = a *a %MOD;
		b /= 2;
	}
	return num;
}

signed main () {
	scanf("%lld", &T);
	while (T --) {
		int m = 0; //多测不清空，爆 0 两行泪。
		scanf("%lld", &n);
		for (int i = 0; i < n; i ++) {
			scanf("%lld", &a);
			if (a %2 == 1) m ++;
		}
		if (m %2 != 0) {
			printf("0\n");
			continue;
		}
		if (m == 0) ans = pows(2, n);
		else ans = pows(2, n -1);
		printf("%lld\n", ans);
	}
    return 0;
}
```

[C++ 记录详情](https://www.luogu.com.cn/record/216541919)

## Java 代码：

~~利用 deepseek 转写~~

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
public class Main {
    static final long MOD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(b.readLine());
        for (int t = 0; t < T; t++) {
            int n = Integer.parseInt(b.readLine());
            StringTokenizer s = new StringTokenizer(b.readLine());
            int m = 0;
            for (int i = 0; i < n; i++) {
                long num = Long.parseLong(s.nextToken());
                if (num % 2 != 0) {
                    m++;
                }
            }
            if (m % 2 != 0) {
                System.out.println(0);
            } else {
                long ans;
                if (m == 0) {
                    ans = pow(2, n);
                } else {
                    ans = pow(2, n - 1);
                }
                System.out.println(ans);
            }
        }
    }
    private static long pow(long a, long b) {
        long res = 1;
        a = a % MOD;
        while (b > 0) {
            if (b % 2 == 1) {
                res = (res * a) % MOD;
            }
            a = (a * a) % MOD;
            b /= 2;
        }
        return res;
    }
}
```

[Java 记录详情](https://www.luogu.com.cn/record/216604964)

估计时间复杂度为 $O(n)$。空间复杂度为 $O(1)$。

---

## 作者：Forge_Unique (赞：1)

## 思路

以奇数的个数来分别用组合数学求出答案。

分情况讨论：

记 $a$ 为奇数的个数。

若 $a$ 为 $0$，则根据组合数学可知答案为 $2 ^ n$。

若 $a$ 为奇数，则无法保证 $S_1$ 和 $S_2$ 都为偶数。所以直接输出 $0$。

若 $a$ 为偶数且 $a$ 不为 $0$，则必有 $2 ^ {n - 1}$ 无法满足要求，所以答案为 $2 ^ {n - 1}$。

[c++代码](https://www.luogu.com.cn/paste/48mysrt4)

[java代码](https://www.luogu.com.cn/paste/9zrv8hbe)

---

## 作者：chzhh_111 (赞：1)

前情提要：以下讨论的**数组下标**都是从 $1$ 开始的。

考虑动态规划。

观察数据范围，发现 $n$ 的大小可以允许时间复杂度 $O(n^2)$ 的算法通过，于是我们可以设计一个状态：$dp_{i,0/1}$，表示到 $R_{1}$ 中的最后一位数字是第 $i$ 位数字，$S_{1}$ 取模 $2$ 的结果为 $0$ 或 $1$ 的方案。

可以剖析一下此状态的设计方向。首先第一维很明显是因为题目给出来的是一个序列，借此方便状态的转移。而第二维的话是因为题目所提到的奇偶性，那么就很自然地想到了用 $0$ 和 $1$ 来代表奇偶性。

可以得到该状态转移方程为：

$$
dp_{i,(j+A_{i}) \bmod 2} = \sum_{k=0}^{i-1} dp_{k,j}
$$

其中，$j$ 为 $0$ 或 $1$。这个方程表示每一个最后一位数字为第 $i$ 位的 $R_{1}$ 的方案数，都是从最后一位数字的位数处于小于 $i$ 的第 $k$ 位的 $R_{1}^{\prime}$ 的方案数转移过来的，由于第 $i$ 位数字是必选的，所以方程中的 $(j+A_{i}) \bmod 2$ 就表示加上 $A_{i}$ 后的奇偶性变化。初始化是 $dp_{0,0} = 1$（不选任何数字得到的和为 $0$，为偶数）。

而最后的答案就是为：$\sum_{i=0}^{n} dp_{i,0}$。如果我们按照 $R_{1}$ 最后一位的数字位数来进行分类，那以上的式子就表示将所有种类的合法 $R_{1}$ 的方案数加起来，而且不会重复计算，因为每一种 $R_{1}$ 最后一位数字所在的位数都不一样，自然就不会重复了。

直接实现以上的转移过程，时间复杂度是 $O(n^2)$，代码为：

```cpp
for(int i=1;i<=n;i++)
{
	for(int j=0;j<=1;j++)
	  for(int k=0;k<i;k++)
        dp[i][(j+a[i])%2]+=dp[k][j],dp[i][(j+a[i])%2]%=mod;
	ans+=dp[i][0],ans%=mod;
}
```

但我们可以发现每一个求和过程都会将前面已经计算过的结果再重新计算一遍，所以我们就可以用一个变量直接代替这个重复计算所产生的结果，再加上现在要统计的值，这可以将时间复杂度优化到 $O(n)$，代码为：

```cpp
for(int i=1,sum[2]={1,0};i<=n;i++)
{
	for(int j=0;j<=1;j++) dp[i][(j+a[i])%2]+=sum[j],dp[i][(j+a[i])%2]%=mod;
    sum[0]+=dp[i][0],sum[0]%=mod;
    sum[1]+=dp[i][1],sum[0]%=mod;
	ans+=dp[i][0],ans%=mod;
}
```

特别的是如果 $\sum_{i=1}^{n} A_{i}$ 是奇数，那么没有任何一个合法方案，因为两个偶数相加的结果也一定是个偶数，所以直接输出 $0$ 就行。

全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e3+1,mod=1e9+7;
int T,n,a[N],dp[N][2];
signed main()
{
	scanf("%lld",&T);
	while(T--)
	{
		int sum=0;
		scanf("%lld",&n);
		for(int i=1;i<=n;i++) scanf("%lld",&a[i]),sum+=a[i];
		if(sum&1)//特判
		{
			printf("0\n");
			continue; 
		}
		int ans=1;
		memset(dp,0,sizeof(dp));
		dp[0][0]=1;//初始化
		for(int i=1,sum[2]={1,0};i<=n;i++)
		{
			for(int j=0;j<=1;j++) dp[i][(j+a[i])%2]+=sum[j],dp[i][(j+a[i])%2]%=mod;
            sum[0]+=dp[i][0],sum[0]%=mod;//求和过程
            sum[1]+=dp[i][1],sum[0]%=mod;//求和过程
			ans+=dp[i][0],ans%=mod;//统计答案
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

关键在于奇数的数量。

设奇数的数量为 $x$。

如果 $x$ 为奇数，那么如何排列组合也没用，答案为 $0$。

如果 $x$ 为 $0$，那么根据我们小学二年级的知识就能知道答案为 $2^n$。

如果 $x$ 为不为 $0$ 的偶数，答案为 $2^{n-1}$。

理清思路之后，代码也很好写了。每次就是一个快速幂取模。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
ll qpow(ll m){
	ll res=1,n=2;
	for(;m;n=n*n%mod,m>>=1) if(m&1) res=res*n%mod;
	return res;
}
int main(){
	int T,n;
	scanf("%d",&T);
	while(T--&&scanf("%d",&n)){
		int s=0;
		for(int i=1,a;i<=n;++i) scanf("%d",&a),s+=(a&1);
		if(s&1) printf("0\n");
		else if(s==0) printf("%lld\n",qpow(n));
		else printf("%lld\n",qpow(n-1));
	}
}
```

---

## 作者：W_C_B_H (赞：0)

Update 2025.05.03：因为“取模运算应使用 `\bmod`”被打回了，但是我用的就是 `\bmod`，可能是因为一些奇妙的特性（见下方）导致误判了？

- `$\bmod 2$` 显示为 $\bmod 2$；
- `${}\bmod 2$` 显示为 ${}\bmod 2$。

---

众所周知，要取模的一般只有数据结构、dp 和组合数学。所以我们考虑 dp（这道题用组合数学也能做）。

设 $dp_{i,0/1}$ 表示考虑前 $i$ 个数（为方便起见，此处序列下标从 $1$ 开始，即原序列 $A$ 为 $A_1,A_2,\dots,A_N$），且选择的子集中数字的和 $ \bmod 2$ 的结果为 $0/1$ 的方案数。初始状态为 $dp_{0,0}=1$（什么都不选时，和为 $0$，是偶数）。记 $p_i=A_i \bmod 2$，则根据题意，有：$\begin{cases}
dp_{i,0}=\sum_{j=1}^{i-1}dp_{j,p_i}\\
dp_{i,1}=\sum_{j=1}^{i-1}dp_{j,1-p_i}
\end{cases}$，且最后答案为 $\sum_{i=1}^{N}dp_{i,0}$。时间复杂度 $O(N^2)$，已经可以通过本题，但我们可以进一步优化。

在 dp 的过程中，我们可以记 $sum_{0/1}$ 为当前已经处理的所有 $dp_{i,0/1}$ 的和，则有：$\begin{cases}
dp_{i,0}=sum_{p_i}\\
dp_{i,1}=sum_{1-p_i}
\end{cases}$，且最后答案为 $sum_0$。使用该优化（前缀和优化）可以将时间复杂度降到 $O(N)$。

注意特判：如果序列中奇数的个数为奇数，则没有合法方案（无论如何分配，$S_1,S_2$ 中一定有恰好一个为奇数）。

Code：

```java
import java.util.Scanner;
public class Main {
    final static int N = 1005, mod = 1000000007;
    static int T, n, cnt;
    static int[] a = new int[N], sum = new int[2];
    static int[][] dp = new int[N][2];
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        // 初始化
        dp[0][0] = 1;
        dp[0][1] = 0;
        T = sc.nextInt();
        while(T-- != 0) {
            // 清空上一组数据留下的东西
            sum[0] = 1;
            sum[1] = 0;
            cnt = 0;
            n = sc.nextInt();
            for(int i = 1; i <= n; i++) {    // 初始化
                dp[i][0] = dp[i][1] = 0;
            }
            for(int i = 1; i <= n; i++) {
                a[i] = sc.nextInt();
                if((a[i] & 1) != 0) {    // 注意 != 的优先级更高
                    cnt++;
                }
                // 依题意进行递推
                dp[i][0] = sum[a[i] & 1];
                dp[i][1] = sum[(a[i] & 1) ^ 1];
                sum[0] += dp[i][0];
                sum[1] += dp[i][1];
                sum[0] %= mod;
                sum[1] %= mod;
            }
            System.out.println((cnt & 1) != 0 ? 0 : sum[0]);    // 特判: 如果序列中奇数的个数为奇数, 则没有合法方案
        }
    }
}
```

---

## 作者：ArenaBreakout78 (赞：0)

~~第六篇题解。~~

## 正题 方法思路：

解决这道题，我们需要找到所有满足条件的子集 $R_1$，是使得 $S_1$ 和 $S_2$ 均为偶数。经过分析，我们不难发现偶数的和是之于奇数有关的，于是，我们可以分为以下几个步骤来完成这道题。

### Step 1 分析奇偶性：

首先，我们可以假设数组中有 $js$ 个奇数，$os$ 个偶数。

### Step 2 观察：

通过观察，我们会发现只有两种可能，$js$ 是奇数或偶数。

- 当 $js$ 是奇数时，那无论如何分割，都无法满足 $S_1$ 和 $S_2$ 同时为偶数（奇数个奇数相加的和一定是奇数，而偶数个奇数相加的和一定是偶数），所以此时的答案为零。

- 当 $js$ 是偶数时，那么我们需要从 $js$ 个奇数中选取偶数个（包括 $0$ 个）放入 $R_1$ 中，剩下的偶数个放入 $R_2$ 中。同时，所有的偶数可以任意分配到 $R_1$ 或 $R_2$ 中，不影响和的奇偶性。

### Step 3 计算组合数：

对于偶数个奇数 $js$，选取的方式数为 $2^{js-1}$。对于偶数，每个偶数有两种选择（选或不选），所以总的方式数为 $2^{os}$。因此，方式数的总和是：

$$2^{js-1} \times 2^{os} = 2^{js+os-1} = 2^{n-1}$$

但是前提是 $js$ 是偶数且 $js \ge 0$。

注：$n$ 的意思与题目中的意思相同。

### Step 4 求最终答案：

因为题目中说明了最后需要取余 $10^9 + 7$，所以最终答案应为：

$$2^{n-1} \bmod (10^9+7)$$

那么接下来就是 AC 代码了。

## C++ AC CODE：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD=1000000007;
long long ksm(int n){
    if(n==0) return 1;
    long long r=ksm(n/2);
    r=(r*r)%MOD;
    if(n%2) r=(r*2)%MOD;
    return r;
}
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        int js=0;
        for(int i=0;i<n;i++){
            int num;
            cin>>num;
            if(num%2!=0){
                js++;
            }
        }
        if(js%2!=0){
            cout<<0<<endl;
        }else{
            if(js==0) cout<<ksm(n)%MOD<<"\n";
            else cout<<ksm(n-1)%MOD<<"\n";
        }
    }
    return 0;
}
```

## Java AC CODE ：

```java
import java.util.Scanner;

public class Main {
    static final int MOD=1000000007;
    public static void main(String[] args){
        Scanner s=new Scanner(System.in);
        int T=s.nextInt();
        int maxn=1000;
        long[]pow2=new long[maxn+1];
        pow2[0]=1;
        for(int i=1;i<=maxn;i++) {
            pow2[i]=(pow2[i-1]*2)%MOD;
        }
        while(T-->0){
            int n=s.nextInt();
            int[]a=new int[n];
            int js=0;
            int os=0;
            long sum=0;
            for(int i=0;i<n;i++){
                a[i]=s.nextInt();
                if(a[i]%2==1) js++;
                else os++;
                sum+=a[i];
            }
            if(sum%2!=0) System.out.println(0);
            else{
                if(js==0) System.out.println(pow2[n]);
                else System.out.println(pow2[n-1]);
            }
        }
        s.close();
    }
}

```

---

## 作者：luokc (赞：0)

# [蓝桥杯 2023 省 Java B] 数组分割题解
## 题目分析
给定一个长度为 $n$ 的数组 $A = [A_0, A_1, \dots, A_{n-1}]$，需要从下标集合 $i = \{0, 1, 2, \dots, n-1\}$ 中找出子集 $R_1$，补集为 $R_2$，使得子集和 $S_1 = \sum_{r \in R_1} A_r\ $ 和 $S_2 = \sum_{r \in R_2} A_r\ $ 均为偶数。求满足条件的 $R_1$ 的数量，结果对 $10^9 + 7$ 取模。

## 思路
1. 奇偶性决定和的性质：
   - 偶数：对和的奇偶性无影响，无论是否选入子集，和的奇偶性不变。
   - 奇数：选入子集的奇数个数决定和的奇偶性：偶数个奇数的和为偶数，奇数个奇数的和为奇数。
   
2. 设数组中奇数的个数为 $m$，则：
    - $S_1$ 为偶数 -> $R_1$ 中包含 偶数个奇数 $（0, 2, 4, ..., m）$。
    - $S_2$ 为偶数 -> $R_2$ 中包含 偶数个奇数 -> 由于 $R_2$ 是 $R_1$ 的补集，$R_1$ 和 $R_2$ 的奇数个数之和为 $m$，因此 $m$ 必须是 偶数（否则无法同时满足两者均为偶数）。

3. 分情况
    - 当 $m$ 为奇数时
无论如何分割，$R_1$ 和 $R_2$ 中必有一个包含奇数个奇数，导致和为奇数，此时满足条件的子集数为 0。

   - 当 $m$ 为偶数时
      - $m = 0$（全为偶数），所有子集的和均为偶数，共有 $2^n$ 个子集（包括空集和全集）。

    - 情况 2：$m > 0$ 且为偶数
      - 奇数的选择：从 $m$ 个奇数中选偶数个，方案数为 $2^{m - 1}$。
      - 偶数的选择：每个偶数可自由选择是否加入 $R_1$，共 $n - m$ 个偶数，方案数为 $2^{n - m}$。
## 代码实现
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
public class Main {
    static final long MOD = 1000000007;
    public static void main(String[] args) throws IOException {
        BufferedReader b = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(b.readLine());
        for (int t = 0; t < T; t++) {
            int n = Integer.parseInt(b.readLine());
            StringTokenizer s = new StringTokenizer(b.readLine());
            int m = 0; // 奇数的个数
            for (int i = 0; i < n; i++) {
                long num = Long.parseLong(s.nextToken());
                if (num % 2 != 0) {
                    m++;
                }
            }
            if (m % 2 != 0) {
                System.out.println(0);
            } else {
                long ans;
                if (m == 0) {
                    ans = pow(2, n);
                } else {
                    ans = pow(2, n - 1);
                }
                System.out.println(ans);
            }
        }
    }
    // 快速幂计算 a^b mod MOD
    private static long pow(long a, long b) {
        long res = 1;
        a = a % MOD;
        while (b > 0) {
            if (b % 2 == 1) {
                res = (res * a) % MOD;
            }
            a = (a * a) % MOD;
            b /= 2;
        }
        return res;
    }
}
```

---

## 作者：Yumi_Anaxa_ (赞：0)

[**题面链接**](/problem/P12325)

## 题面大意
给定一个数组，将元素重新划分为两个**互补**的子集，要求两个子集中的元素和均为偶数。求满足条件的不同划分方式有多少种。\
**细节**：
1. **奇数数量必为偶**：\
   如果数组中奇数个数为奇数，这是无法满足条件的情况，直接输出 $0$ 即可。
3. **组合计算**：
   - 若奇数个数为偶（设有 $k$ 个），那么选择奇数的组合方式就有 $2^{k-1}$ 种。
    - 偶数的组合方式为 $2^m$（$m$ 为偶数个数）。
    - 总方案数为 $(2^{k-1}\times2^m)\bmod10^9+7$。

**示例**：
- 样例 `[6, 6]`（全是偶数）：共有 $2^2=4$ 种分法。
- 样例 `[1, 6]`（奇数个数为1，个数是奇数）：无法满足条件，就输出 $0$。
## 思路
### 奇偶性分析：
首先需要统计数组中奇偶的数量，只有当奇数数量等于偶数时，整个数组的和才可能是偶数。才能找到满足条件的子集来计算答案。
### 组合计算：
如果奇数数量为偶，计算满足条件的组合数：\
**奇数的组合**：从偶数个奇数中选择偶数个奇数的组合数为 $2^{k-1}$，其中 $k$ 为奇数数量。\
**偶数的组合**：每个偶数可以自由选择是否放入子集，因此组合数为 $2^m$，其中 $m$ 为偶数数量。\
**计算答案时一定取模！！！**
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1000000007;//取模
typedef long long ll;
//快速幂
ll pow(int a, int b){
  if (b == 0)return 1;//0次方=1
  ll res = pow(a, b / 2);//递归
  res = (res * res) % MOD;
  if (b % 2 == 1)res = (res * a) % MOD;
  return res;
}
int main(){
  int T;
  cin >> T;
  while (T --){
    int n;
    cin >> n;
    int k = 0, m = 0;//k为奇数个数，m为偶数个数
    for (int i = 0; i < n;i ++){
      int x;
      cin >> x;
      if (x % 2 == 1)k++;//统计奇偶个数
      else m++;
    }
    //无法满足条件的情况
    if (k % 2 != 0)cout << 0 << "\n";
    else{
      //k=0时特判为1
      ll p1 = (k == 0) ? 1 : pow(2, k - 1),p2 = pow(2, m);
      ll ans = (p1 * p2) % MOD;
      cout << ans << "\n";
    }
  }
  return 0;
}
```

---


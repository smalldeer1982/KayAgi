# [蓝桥杯 2022 省 Python B] 蜂巢

## 题目描述

蜂巢由大量的六边形拼接而成，定义蜂巢中的方向为：$0$ 表示正西方向，$1$ 表示西偏北 $60^\circ$，$2$ 表示东偏北 $60^\circ$，$3$ 表示正东，$4$ 表示东偏南 $60^\circ$，$5$ 表示西偏南 $60^\circ$。

对于给定的一点 $O$，我们以 $O$ 为原点定义坐标系，如果一个点 $A$ 由 $O$ 点先向 $d$ 方向走 $p$ 步再向 $(d+2) \bmod 6$ 方向（$d$ 的顺时针 $120^\circ$ 方向）走 $q$ 步到达，则这个点的坐标定义为 $(d, p, q)$。在蜂窝中，一个点的坐标可能有多种。

下图给出了点 $B(0, 5, 3)$ 和点 $C(2, 3, 2)$ 的示意。

![](https://cdn.luogu.com.cn/upload/image_hosting/n36fvy4l.png)

给定点 $(d_1, p_1, q_1)$ 和点 $(d_2, p_2, q_2)$, 请问他们之间最少走多少步可以到达?

## 说明/提示

### 评测用例规模与约定

- 对于 $25\%$ 的评测用例, $p_1, p_2 \leq 10^3$;
- 对于 $50\%$ 的评测用例, $p_1, p_2 \leq 10^5$;
- 对于 $75\%$ 的评测用例, $p_1, p_2 \leq 10^7$;
- 对于所有评测用例, $0 \leq d_1, d_2 \leq 5$, $0 \leq q_1 < p_1 \leq 10^9$, $0 \leq q_2 < p_2 \leq 10^9$。

## 样例 #1

### 输入

```
0 5 3 2 3 2```

### 输出

```
7```

# 题解

## 作者：海洋守卫者 (赞：3)

# [P12367](https://www.luogu.com.cn/problem/P12367) [蓝桥杯 2022 省 Python B] 蜂巢

## 解题思路
容易发现蜂巢间的移动可以看作向量，因此可以构建下图坐标系：

![](https://cdn.luogu.com.cn/upload/image_hosting/x8ahmn5j.png)

所以，正西方向可以看作为 $(-1,0)$，西偏北 $60^\circ$ 可以看作为 $(0,1)$，东偏北 $60^\circ$ 可以看作为 $(1,1)$，正东可以看作为 $(0,1)$，表示东偏南 $60^\circ$ 可以看作为 $(0,-1)$，西偏南 $60^\circ$ 可以看作为 $(-1,-1)$。

接着就能够计算出从定点 $(d_1, p_1, q_1)$ 到点 $(d_2, p_2, q_2)$ 的向量 $\overrightarrow{P_1P_2}$，记为 $(x,y)$。然后求出答案。

此时还应当判断 $x$ 与 $y$ 的符号。若为同号，可以先在 $(1,1)$  方向上移动，答案为 $\max\{|x|,|y|\}$；若为异号，则答案为 $|x|+|y|$。

## 完整代码
### C++:
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
const int dt[8][4]={{-1,0},{0,1},{1,1},{1,0},{0,-1},{-1,-1}};
int a,b,c,d,e,f;
inline int p(int d)
{
	return (d+2)%6;
}
int main()
{
	scanf("%d %d %d %d %d %d",&a,&b,&c,&d,&e,&f);
	int x=0,y=0,ans;
	x=dt[a][0]*b+dt[p(a)][0]*c-dt[d][0]*e-dt[p(d)][0]*f;
	y=dt[a][1]*b+dt[p(a)][1]*c-dt[d][1]*e-dt[p(d)][1]*f;
	if((x>0&&y>0)||(x<0&&y<0))ans=max(abs(x),abs(y));
	else ans=abs(x)+abs(y);
	printf("%d",ans);
	return 0;
}
```
### Python:
```py
def p(x):
	return (x+2)%6
dt=((-1,0),(0,1),(1,1),(1,0),(0,-1),(-1,-1))
a,b,c,d,e,f=map(int,input().split())
x=dt[a][0]*b+dt[p(a)][0]*c-dt[d][0]*e-dt[p(d)][0]*f
y=dt[a][1]*b+dt[p(a)][1]*c-dt[d][1]*e-dt[p(d)][1]*f
ans=0
if x*y>0:
	ans=max(abs(x),abs(y))
else:
	ans=abs(x)+abs(y)
print(ans)
```

---

## 作者：W_C_B_H (赞：0)

Update 2025.05.02：两点间距离公式写反了……

我们可以建立如下图所示的坐标系，并将每一个小六边形抽象成一个点，则每一个点的位置都可以用唯一的坐标表示（如下图中的点 $A,B,C$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/gvxkhxb5.png)

通过观察可以得出：若有两个点 $P(x_1,y_1),Q(x_2,y_2)$，记 $d_1=x_1-x_2,d_2=y_1-y_2$（我的代码中 $d_1$ 用 `dis1` 表示，$d_2$ 用 `dis2` 表示），则当 $d_1,d_2$ 同号时，点 $P,Q$ 之间至少走 $|d_1|+|d_2|$ 步可以到达（如图中的点 $A,B$）；否则，点 $P,Q$ 之间至少走 $\max\{|d_1|,|d_2|\}$ 步可以到达（如图中的点 $B,C$）。

故我们可以先根据题意求出两个点在坐标系中的坐标，然后使用前面的距离公式得出答案。

Code：

```python
dx = [-1, -1, 0, 1, 1, 0]
dy = [0, 1, 1, 0, -1, -1]

d1, p1, q1, d2, p2, q2 = map(int, input().split())

x1 = p1 * dx[d1] + q1 * dx[(d1 + 2) % 6]
y1 = p1 * dy[d1] + q1 * dy[(d1 + 2) % 6]
x2 = p2 * dx[d2] + q2 * dx[(d2 + 2) % 6]
y2 = p2 * dy[d2] + q2 * dy[(d2 + 2) % 6]

dis1 = x1 - x2
dis2 = y1 - y2

print(abs(dis1) + abs(dis2) if dis1 * dis2 >= 0 else max(abs(dis1), abs(dis2)))
```

---


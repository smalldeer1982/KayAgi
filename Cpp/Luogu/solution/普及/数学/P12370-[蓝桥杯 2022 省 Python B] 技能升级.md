# [蓝桥杯 2022 省 Python B] 技能升级

## 题目描述

小蓝最近正在玩一款 RPG 游戏。他的角色一共有 $N$ 个可以加攻击力的技能。其中第 $i$ 个技能首次升级可以提升 $A_i$ 点攻击力，以后每次升级增加的点数都会减少 $B_i$。$\lceil\frac{A_i}{B_i}\rceil$（上取整）次之后，再升级该技能将不会改变攻击力。

现在小蓝可以总计升级 $M$ 次技能，他可以任意选择升级的技能和次数。请你计算小蓝最多可以提高多少点攻击力？

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例, $1 \leq N, M \leq 1000$;
- 对于 $60\%$ 的评测用例, $1 \leq N \leq 10^4$, $1 \leq M \leq 10^7$;
- 对于所有评测用例, $1 \leq N \leq 10^5$, $1 \leq M \leq 2 \times 10^9$, $1 \leq A_i, B_i \leq 10^6$。

## 样例 #1

### 输入

```
3 6
10 5
9 2
8 1```

### 输出

```
47```

# 题解

## 作者：SatoruXia (赞：4)

考虑使用贪心加二分。  
首先发现输入量较大，考虑输入优化。  
其次想出思路：每次均选用当前升级最多的升级方式，随后将其减小并计算总值，类似于多路归并问题。思路没错，但数据量使模拟不现实。  
观察算法标签，发现“二分”。因此得到新思路：在操作次数符合要求的情况下，必有一界限，或者叫阈值，使所有升级的攻击力均大于此阈值。因为每种升级方式每次升级的攻击力均按等差数列递减，因此用二分查找即可确保找出的阈值尽可能大。随后进行贪心，跳过所有小于阈值的升级方式，计算总升级次数。  
还要值得注意的一点是：总升级次数可能大于规定操作次数。因此在输出时应添加判断：当攻击力超过规定时，删掉最小的（即升级攻击力等于阈值的）操作方式。然后输出即可。  
代码如下：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAX_N = 100000;
int N, M, A[MAX_N], B[MAX_N], max_A = 0;//打擂台的擂主
int main() {
    //读入优化，提升效率
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    //初始化
    cin >> N >> M;
    for (int i = 0; i < N; ++i) {
        cin >> A[i] >> B[i];
        max_A = max(max_A, A[i]);//打擂台
    }
    //二分查找
    int left = 0, right = max_A, best_x = 0;//定义范围
    while (left <= right) {
        int mid = (left + right) / 2;
        long long total = 0;//攻击总量
        for (int i = 0; i < N; ++i)
            if (A[i] >= mid)
                total += (A[i] - mid) / B[i] + 1;
        if (total >= M) best_x = mid, left = mid + 1;//寻找最优阈值，即越大越好
        else right = mid - 1;//左闭右闭的写法
    }
    //贪心
    long long tot = 0, cnt = 0;//所有选中总攻击力，实际选中总攻击力（均可超过M次）
    for (int i = 0; i < N; ++i) {
        if (A[i] < best_x) continue;//即攻击力超过阈值才会升级
        int k = (A[i] - best_x) / B[i] + 1;
        cnt += k;
        tot += k * (2LL * A[i] - (k - 1) * B[i]) / 2;//等差数列求和，运算时不乘ll会爆
    }
    //输出
    //简单来说，当攻击力超过规定时，删掉最小的
    cout << tot - (cnt > M ? (cnt - M) * best_x : 0);//也可用if语句代替
    return 0;
}
```

---

## 作者：JIN_LONG (赞：3)

## 思路：
这题正确的方法应该用二分，以下是步骤。

- 经过观察可以发现，每一组数据都代表一串等差数列，我们要找 $x$ 以上的数字有多少个，所以我们要用用二分的算法来找 $x$ 是多少。
- 找到 $x$ 后，就是找大于等于它的等差数列的数的是否数符合条件，如果符合，那么计算它们的总和。
- 这里要注意，应为这些数字的个数一定要等于 $m$，所以需要特判。

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[100001],b[100001],n,m,sum1;
int check(int mid){
	sum1=0;
	for(int i=1;i<=n;i++){
		if(a[i]>=mid){
			sum1+=(a[i]-mid)/b[i]+1;
		}
	}
	if(sum1>=m){
		return 1;
	}
	else return 0;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
	}
	long long l=0,r=1000000;
	while(l<r){
		long long mid=(l+r+1)/2ll;
		if(check(mid)){
			l=mid;
		}
		else {
			r=mid-1;
		}
	}
	long long sum=0,cnt=0;
	for(int i=1;i<=n;i++){
		if(a[i]>=l){
			long long s=(a[i]-l)/b[i];
        	if(s*b[i]!=a[i]-l){
            	s++;
       		}
        	sum+=(a[i]+a[i]-(s-1)*b[i])*s/2;
        	cnt+=s;
		}
	}
	cout<<sum+(m-cnt)*l;
	return 0;
}








```

---

## 作者：_Xiemengyang_ (赞：1)

比第二篇题解再讲详细一点。  
本题我们考虑使用二分，而二分一个很关键的点就是分什么。  
对于本题，我们考虑使用[砍树](https://www.luogu.com.cn/problem/P1873)的思路类比到此题。  
此时我们可以把数据转化成一个柱状图。  
![](https://cdn.luogu.com.cn/upload/image_hosting/ehg6ot69.png)
我们设 $x$ 为当前高度，则我们就可以截下高于 $x$ 的部分。对于每一个数据，我们把 $x$ 以上的攻击力选取计算。每一个被选取的部分，我们都要对它计算需要的次数，此处需要向上取整，即 $\lceil\frac{a_i}{b_i}\rceil$。然后进行相加，与要求次数 $m$ 进行比较。若比 $m$ 小，说明右边界大了，反之左边界小了。这其实就是二分答案里重要的 check 函数。
:::info[check函数]
```cpp
bool check(int x){
    int cnt = 0;
    for (int i = 1; i <= n; i++){
        if (a[i] > x) //对于a[i]，选取大于x的数据计算
            cnt += (a[i] - x + b[i] - 1) / b[i];
//上取整公式：若想计算a / b上取整，则可用(a + b - 1) / b。
    }
    if (cnt <= m) return true;
    else return false;
}
```
:::
二分板子就不在此处赘述，不会的可移步至[此处（二分查找）](https://www.bilibili.com/video/BV1qg1MYME2e/?spm_id_from=333.337.search-card.all.click&vd_source=2ac31115bd867e59657694daad451bc5)和[此处（二分答案）](http://bilibili.com/video/BV1y1mKYpEXB/?spm_id_from=333.337.search-card.all.click&vd_source=2ac31115bd867e59657694daad451bc5)。接下来还有一个问题：最后的答案怎么计算？

首先，我们使用二分得到一个合法高度 $k$。对于每一个大于高度的 $a_i$，我们计算大于 $x$ 的部分需要的次数。则对于大于 $k$ 的部分，我们一次一次去提高。设提高 $n$ 次，则有 $a_i-k = a_i + (a_i - b_i) + (a_i - b_i \times 2) + (a_i - b_i \times 3) + …… + (a_i - b_i \times (n - 1))$。

化简得：$\Large\frac{(a_i + a_i - (n - 1)\times b_i)\times n}{2}$，并将答案加入总结果。  
这是大于 $k$ 的。那还有等于 $k$ 的呢？那我们就要考虑如果还有次数没用时，我们就将其与 $k$ 相乘（因为每次贴着 $k$ 的使用一次使其下降之后就可不再使用），加入总结果。

:::success[代码部分]
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+5;
int a[N], b[N], sum ,n, m;
bool check(int x) {
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        if (a[i] > x)
            cnt += (a[i] - x + b[i] - 1) / b[i];
    }
    if (cnt <= m) return true;
    else return false;
}
signed main() { 
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++){
        cin >> a[i] >> b[i];
    }
    int l = 0, r = 1e6, mid;
    while (l < r){
        mid = (l + r) >> 1;
        if(!check(mid)) l = mid + 1;
        else r = mid;
    }
    for (int i = 1; i <= n; i++){
        if(a[i] > l){
            long long xiangshu = max((a[i] - l + b[i] - 1) / b[i], 0ll);
            sum += (a[i] + a[i] - (xiangshu - 1) * b[i]) * xiangshu / 2;
            m -= xiangshu;
        }
    }
    sum += m * l;
    cout << sum;
    return 0;
}
```
:::
珍爱生命，远离抄袭

---

## 作者：yu_666 (赞：1)

声明：这是一篇 C++ 的题解，写的会详细一些，适合新手阅读。    
### 题目意思
有 $N$ 个技能，每个技能初始攻击力为 $A_i$，每次升级会减少 $B_i$ 攻击力。现在可以进行 $M$ 次升级，每次选择当前攻击力最高的技能进行升级。求 $M$ 次升级后获得的总攻击力最大值。    
### 问题分析
每个技能升级提供的攻击力提升是一个等差数列：

第 $1$ 次升级：$A_i$    
第 $2$ 次升级：$A_i - B_i$   
第 $3$ 次升级：$A_i - 2B_i$   
$\cdots$

直到攻击力提升值 $\ge 0$ 为止。
### 解题思路

#### 方法一：暴力解法（仅适用于小数据）
1. 将所有可能的升级攻击力值收集到一个列表中。    
1. 对列表进行降序排序。     
1. 取前 $M$ 个最大的值求和。

这种方法时间复杂度为 $O\left(N \cdot \max_{1 \leq i \leq N} \left(\frac{A_i}{B_i}\right)\right)$，只能通过 $40\%$ 的测试用例。

#### 方法二：二分查找优化
1. 使用二分法确定一个阈值 $x$，使得所有 $\ge x$ 的攻击力提升值至少有 $M$ 个。
1. 计算所有 $\ge x$ 的攻击力提升值的总和。
1. 处理可能的多余部分。

这种方法时间复杂度为 $O\left(N \cdot \log\left(\max_{1 \leq i \leq N} A_i\right)\right)$，能够通过所有测试用例。

### 代码
#### 原始代码

```cpp
#include <iostream>
using namespace std;

const int MAX_N = 1e5+5;
long long A[MAX_N], B[MAX_N];

int main() {
    int n, m;
    cin >> n >> m;
    
    for(int i=0; i<n; i++) cin >> A[i] >> B[i];
    
    long long l=0, r=0;
    for(int i=0; i<n; i++) r = max(r, A[i]);
    
    while(l < r) {
        long long mid = (l+r+1)/2;
        long long cnt = 0;
        for(int i=0; i<n; i++)
            if(A[i] >= mid)
                cnt += (A[i]-mid)/B[i] + 1;
        cnt >= m ? l=mid : r=mid-1;
    }
    
    long long res=0, total=0;
    for(int i=0; i<n; i++) {
        if(A[i] >= l) {
            long long k = (A[i]-l)/B[i] + 1;
            res += k*(A[i] + (A[i]-(k-1)*B[i]))/2;
            total += k;
        }
    }
    cout << res - (total-m)*l << endl;
    return 0;
}
```

#### 题解版本（带注释）

```cpp
#include <iostream>
using namespace std;

const int MAX_N = 1e5+5;
long long A[MAX_N], B[MAX_N]; // A:初始攻击力 B:衰减值

int main() {
    int n, m;
    cin >> n >> m; // n技能数 m升级次数
    
    // 读取输入
    for(int i=0; i<n; i++) cin >> A[i] >> B[i];
    
    // 二分查找阈值
    long long l=0, r=0;
    for(int i=0; i<n; i++) r = max(r, A[i]);
    
    while(l < r) {
        long long mid = (l+r+1)/2;
        long long cnt = 0;
        for(int i=0; i<n; i++)
            if(A[i] >= mid)
                cnt += (A[i]-mid)/B[i] + 1;
        cnt >= m ? l=mid : r=mid-1;
    }
    
    // 计算结果
    long long res=0, total=0;
    for(int i=0; i<n; i++) {
        if(A[i] >= l) {
            long long k = (A[i]-l)/B[i] + 1;
            res += k*(A[i] + (A[i]-(k-1)*B[i]))/2;
            total += k;
        }
    }
    cout << res - (total-m)*l << endl;
    return 0;
}

```

---

## 作者：Dream_Stars (赞：0)

## 题目大意：

有 $N$ 个可以加攻击力的技能，其中第 $i$ 个技能首次升级可以提升 $A_i$ 点攻击力，以后每次升级增加的点数都会减少 $B_i$。$\lceil\frac{A_i}{B_i}\rceil$ 次之后，再升级该技能将不会改变攻击力。\
可以升级 $M$ 次技能，求最大可提升的攻击力点数。

## 算法分析：
这题可以用二分法进行求解，不了解二分法的可以[戳这里](https://oi.wiki/basic/binary/)。\
我们可以通过二分来找到一个最优的阈值，再利用等差数列进行计算答案。

注：因为一共有 $M$ 次机会，所以必须恰好用 $M$ 次，计算时需要进行考虑。

## 代码展示：
```cpp
# include <bits/stdc++.h>

# define ll long long
# define int long long
# define rint register int

long long read(){long long s = 0 , w = 0; char c = getchar(); while(!isdigit(c)) w |= (c == '-') , c = getchar(); while(isdigit(c)) s = (s << 1) + (s << 3) + (c ^ 48) , c = getchar(); return w ? -s : s;}
void write(long long x){if(x < 0) putchar('-') , x = ~ (x - 1); if(x > 9) write(x / 10); putchar(x % 10 | 48);}
void writesp(long long x){write(x) , putchar(' '); }
void writeln(long long x){write(x) , putchar('\n');}

using namespace std;

constexpr int N = 1e5 + 10;
constexpr int inf = 1e18;

long long n,m,l,r,mid;
long long cnt,sum,add,ans;
long long a[N],b[N];

bool check(long long x) {
  long long tot = 0;
  for(rint i = 1 ; i <= n ; i ++)
  	if(a[i] >= x) tot = tot + (a[i] - x) / b[i] + 1;
  return tot >= m;
} //判断攻击总量是否符合条件。 

void solve() {
  l = 0,
  r = inf;
  //二分枚举共计攻击总量。 
  while(l < r) {
  	mid = l + r + 1 >> 1;
  	if(check(mid) == true) l = mid;
  	//这里 l 可以用来表示符合条件的最优阈值。 
  	else r = mid - 1;
  }
  return ;
}

signed main() {
  n = read(),
  m = read();
  for(rint i = 1 ; i <= n ; i ++)
  	a[i] = read(),
  	b[i] = read(); //数据读入。
  solve(); //二分。
  for(rint i = 1 ; i <= n ; i ++) {
  	if(a[i] < l) continue; //如果攻击力低于阈值则无法提高。 
  	add = (a[i] - l) / b[i] + 1,
  	cnt = cnt + add,
	sum = sum + ((2 * a[i] - (add - 1) * b[i]) * add / 2);
	//这里可以运用等差数列的求和公式来求和。 
  } //计算答案。 
  ans = sum + (m - cnt) * l;
  //注意判断刚好要用 M 次。
  write(ans);//计算答案并输出。 
  return 0;
}

```

---


# [蓝桥杯 2025 国 B] 翻倍

## 题目描述

给定 $n$ 个正整数 $A_1, A_2, \ldots, A_n$，每次操作可以选择任意一个数翻倍。

请输出让序列单调不下降，也就是每个数都不小于上一个数，最少需要操作多少次？

## 说明/提示

**【样例说明】**

可以将序列变为: $4, 6, 8, 8, 14, 18$，总计需要 $0 + 1 + 2 + 3 + 1 + 1 = 8$ 次操作。

**【评测用例规模与约定】**

对于 20% 的评测用例，$n \leq 10, A_i \leq 100$。

对于 50% 的评测用例，$n \leq 5000, A_i < 2^{32}$，保证存在操作可以在所有 $A_i$ 小于 $2^{32}$ 的情况下满足题目要求。

对于 100% 的评测用例，$1 \leq n \leq 2 \times 10^5, 1 \leq A_i < 2^{32}$。

## 样例 #1

### 输入

```
6
4 3 2 1 7 9```

### 输出

```
8```

# 题解

## 作者：vegetableYe (赞：8)

### 第十六届蓝桥杯CB国赛 G-翻倍

$50$ 分做法没啥说的了，直接从左到右模拟就是正确的。

```cpp
int ans = 0;
for(int i = 2; i <= n; i++) {
	while(a[i] < a[i - 1]) {
		ans++;
		a[i] *= 2;
	}
}
cout << ans << endl;
```

##### 正解

实际上我们从左到右模拟的时候会发现，$a_i$ 的操作次数只与 $a_{i-1}$ 有关，因此我们考虑一个递推：

$f_i$ 表示 $a_i$ 需要多少次操作。

我们初始化 $f_1=0$，因为第一个数字显然不需要操作。

接着我们依旧是从左到右枚举，为了不打破 $a_{i-1}$ 和 $a_i$ 原本的大小关系，我们直接做这样一件事情：

$a_{i-1}$ 操作了几次，我就先让 $a_i$ 操作几次。

因此我们直接 $f_i=f_{i-1}$。

接着很容易发现存在两种情况：或许 $f_i$ 操作了这么多次不够，又或许 $f_i$ 不需要操作这么多次。

对这两种情况，我们直接根据 $a_{i-1}$ 和 $a_i$ 的大小关系模拟一遍，模拟的每一步对应地让 $f_i$ 加 $1$ 或者减 $1$ 即可。（具体见代码）

唯一需要注意的是，$f_i$ 不能减到负数。

最终答案就是所有 $f_i$ 之和。

```cpp
vector<int> f(n + 1);
for(int i = 2; i <= n; i++) {
	f[i] = f[i - 1];
	int x = a[i], y = a[i - 1];
	while(x >= y * 2) {
		if(f[i] == 0) break;
		y *= 2;
		f[i]--;
	}
	while(x < y) {
		x *= 2;
		f[i]++;
	}
}
	
int ans = 0;
for(int i = 1; i <= n; i++) {
	ans += f[i];
}
	
cout << ans << endl;
```

时间复杂度：$O(n\times \log(A))$。（调整 $f_i$ 时的模拟过程是 $\log(A)$ 的）

---

## 作者：zhaokeyu123 (赞：2)

## 暴力
观察题目，我们很容易想到暴力的方法，即从左往右遍历。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,ans=0;cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=2;i<=n;i++)
	{
		while(a[i]<a[i-1])
		{
			a[i]<<=1;
			ans++;
		}
		a[i-1]=0;
	}
	cout<<ans;
	return 0;
}
```
这样就能够拿到 $50$ 分。
## 正解思路
我们考虑使用内置函数 $\log$ 优化时间复杂度问题，可以达到 $O(n)$。对于空间复杂度优化我们不妨转变一下思路，将前 $i$ 个元素对于第 $i-1$ 个元素要满足单调不降的翻倍操作数累加起来即可达到题目要求。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[200005];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,ans=0,sum=0;cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=2;i<=n;i++)
	{
		sum+=ceil(log2(1.*a[i-1]/a[i]));
		sum=sum<0?0:sum;
		ans+=sum;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

优秀的蓝桥杯出题大赛。

---

考虑贪心最小化每一位答案。

由于序列单调不降，所以每一位的答案只与前一位挂钩，于是可以递推。

以上一位为基础枚举增加或减少即可。

注意答案不可为负。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[2000005];
int ans[2000005];
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(i>1){
            ans[i]=ans[i-1];
            for(int j=1;a[i]*j<a[i-1];j*=2)ans[i]++;
            for(int j=2;ans[i]&&a[i-1]*j<=a[i];j*=2)ans[i]--;
        }
    }
    for(int i=1;i<=n;i++)ans[0]+=ans[i];//,cout<<ans[i];
    cout<<ans[0];
    return 0;
}
```

---

## 作者：linhanmo (赞：2)

# 题解：[P12836 [蓝桥杯 2025 国 B] 翻倍](https://www.luogu.com.cn/problem/P12836)

[三倍经验](https://www.luogu.com.cn/discuss/1093260)……

## 部分分

暴力翻倍每一个数字，时间复杂度 $O(n)$。

但是翻倍后的数字是存不下的，所以这并不能 AC。

## 正解

既然翻倍后的数字存不下，考虑存翻了几倍。

这样只要相邻两个数计算前一个数没翻倍时要后一个数要翻几倍加上前一个数翻了几倍即可。

显然是存得下的，时间复杂度 $O(n)$。

```
#include <stdio.h>
#include <math.h>
unsigned n;
unsigned long long ans; // 不开 long long 见祖宗
int main(void) {
    scanf("%u", &n);
    for (unsigned a, la = 0, // 边读入边计算
        d = 0 /* 累加翻了几倍 */, 
	    i = 1; i <= n; la = a, ++i)
        scanf("%u", &a),
        ans += d = fmax(d + ceil(log2(1. * la / a)), 0.);
    printf("%llu", ans);
    return 0;
}
```

---

## 作者：__delta_epsilon__ (赞：2)

### 题目大意

给定数列 $\{A_n\}$，给其中某个元素翻倍称为一次操作，求最少操作数使数列单调不下降。

### 思路

显然有一种贪心策略，将每一个元素 $A_i$ 翻倍直到 $A_i\ge A_{i-1}$ 为止就好了。

贪心策略是正确的，因为如果你有某一个元素翻倍的次数过多，会导致其之后的元素也需要翻倍更多次。

不难想到一种模拟做法，即对每一次操作进行模拟，最后保存 $A_i$ 翻倍后的值，同时记录翻倍次数。

但是，数据范围中给出 $n$ 最大可以达到 $2\times 10^5$，且没有保证 $A_i$ 在操作后仍然在 `long long` 范围内，这种做法的时间复杂度太高，而且数据有可能溢出。

我们需要换一种做法。

首先需要一种 $O(1)$ 的计算翻倍次数的方法。不难看出，前一个数为 $x$，后一个数为 $y$ 时，至少需要

$$\left\lceil\log_2\frac{x}{y}\right\rceil$$

次操作，这可以让我们在 $O(1)$ 复杂度内计算出翻倍次数。

同时，为了防止溢出，我们可以换一种角度对待这个问题。

以样例 $4,3,2,1,7,9$ 为例。

原先的思路如下：

1. 将 $3$ 翻倍：$4,6,2,1,7,9$。
2. 将 $2$ 不断翻倍直到超过 $6$：$4,6,8,1,7,9$。
3. 将 $1$ 不断翻倍直到超过 $8$：$4,6,8,8,7,9$。
4. 将 $7$ 翻倍：$4,6,8,8,14,9$。
5. 将 $9$ 翻倍：$4,6,8,8,14,18$。

唯一导致溢出的情况在于其将翻倍后的数存储了下来。

不难发现，如果我们将前一个数 $a$ 翻了倍，那么后一个数需要翻倍的次数也增多了。上例中 $2$ 本来只需要翻倍一次就能超过 $3$，因为 $3$ 的翻倍导致其需要两次才能超过原来的值。

由此不难想到以下的思路：

1. 首先记录初始状态时每一个数需要翻倍的次数。$^\dag$
2. 根据前一个数翻倍了多少次进行累加。（这里如果计算出的结果是负数，说明原先后面的数就比翻倍后前面的数大，此时就不需要翻倍了，将累加器设置为 $0$）
3. 对答案进行累加。

$\dag$：这里有一个细节，对于其中类似 $1,7$ 的序列，可以记次数为 $-2$ 次，因为 $7$ 需要翻倍 $-2$ 次（变为 $7/4$）才能超过 $1$。这样可以抵消掉前面一个数的翻倍。

### AC Code

这里提供时间复杂度 $O(n)$，空间复杂度 $O(1)$ 的写法。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int prev_a = 0, now_a, n, sum1, sum2;
signed main() {
    cin >> n;
    for (; n--; ) {
        cin >> now_a;
        int ans = ceil(log2(1. * prev_a / now_a));
        // 这是初始状态时需要翻倍的次数。
        sum2 += ans;
        // 累加前面已经翻倍过的次数。
        if(sum2 < 0) sum2 = 0;
        sum1 += sum2;
        // 累加答案。
        prev_a = now_a;
    }
    cout << sum1 << endl;
    return 0;
}
```

---

## 作者：hder (赞：1)

## 题意描述
给你一个数组，你每次可以选择其中一个数字乘以 $2$ ，使得数组中每一个数都大于等于前一个数，求最小操作次数。

## 思路
可以观察到“大于等于”是传递的。也就是说，如果一个数大于等于前一个数，那一定大于等于前面的所有数。因此，我们要让前面的数尽可能的小，才能使得当前的数的操作次数变少。可以使用贪心解决，遍历第二个以后的数，操作使其恰好大于等于前面的数即可。

但是，每次乘以 $2$ 会使得数字指数级增长，在题目的数据规模下会爆掉，所以可以使用以 $2$ 为底数的科学计数法解决，做乘以 $2$ 的操作时，每次只需修改指数即可。

## 代码
```cpp
#include <iostream>
#include <vector>
using namespace std;

void solve(int t)
{
    int n;
    cin >> n;
    vector<pair<long long, double>> nums(n);
    for (int i = 0; i < n; i++)
    {
        long long num;
        cin >> num;
        nums[i].second = num;
        long long p = 8 * sizeof(num) - __builtin_clzll(num) - 1;
        while (p-- > 0)
        {
            nums[i].second /= 2;
            nums[i].first++;
        }
    }

    long long ans = 0;
    for (int i = 1; i < n; i++)
    {
        if (nums[i] < nums[i - 1])//pair先比较指数，再比较有效数（尾数）
        {
            if (nums[i].second >= nums[i - 1].second)
            {
                ans += nums[i - 1].first - nums[i].first;
                nums[i].first = nums[i - 1].first;
            }
            else
            {
                ans += nums[i - 1].first - nums[i].first + 1;
                nums[i].first = nums[i - 1].first + 1;
            }
        }
    }
    cout << ans << endl;

}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve(1);
    return 0;
}
```
~~实际上是原题 CF1883E~~

---

## 作者：ZZA000HAH (赞：1)

# 翻倍

## 题目描述
给出一个数列，仅对数列中数的大小进行翻倍操作（操作一次即 $ a_i = a_i \times 2$），使数列中后一个数均不小于前一个数，即 $ a_{i-1} \le a_i , i \in (1,n] \text{且} i \in \mathbb{Z} $，求为达到目的所需要的最少的操作数。

## 题目分析

可以进行纯模拟，但这样只能得 $50$ 分，后面的会超时。

数据范围在 $ 1 \le n \le 2 \times 10^5 , 1 \le a_i < 2^{32}$，仅通过模拟显然是不行的，那么我们可以用一些简单的数学方法优化一下做法，但这样终归还是模拟，我们不一次一次循环地将数列中的数乘以二，而是通过数学中 $ \log $ 的方法求出至少要乘几次二。

方法步骤

1. 正向依次遍历数列，如果前一个数比现在的数大，那么算出前一个数比这个数大的倍数，向上取整得到 $ num $；
2. 计算 $ num $ 是 $ 2 $ 的几次方（向上取整），即计算 $ tem = \log_2 num $，向上取整；
3. 将现在的数乘为原来的 $ 2^{tem} $ 倍，得到新数；
4. 将总计数 $ ans $ 加上 $ tem $。

这下不会超时了，后面的测试点变成 Wrong Answer 了，这是因为产生的新数很有可能超过 ``` long long ``` 的数据范围，那就只能不将数列中的数变成新数了。

那么就再需要一些数学上的转换：将数列变为一个递减的数列，即数列中的后一个数小于或等于前一个数。这样在计算每一个数需要操作的次数时便被拆分为两部分，即操作现在的数变成大于或等于前一个数所需的最小操作数与前一个数变化需要的最小操作数，其中操作现在的数变成大于或等于前一个数所需的最小操作数即为将数列变为递减时对本数进行操作的最小操作数。

那么事实上，在正向遍历数列时，我们需要判断前一个数是大于还是小于或等于现在的数，从而进行不同的操作。方法步骤如下：

1. 如果现在的数小于前一个数（记为事件一），得到 $ num = a_{i-1} \div a_i $，否则，得到 $ num = a_i \div a_{i-1} $，均向上取整；
2. 与上述方法步骤类似，得到 $ \log_2 num $，同样向上取整；
3. 用数组 $ b_i $ 表示第 $ i $ 个数操作的次数，如果事件一成立，则更新 $ b_i $ 为 $ b_i = b_{i-1} + tem $，否则更新 $ b_i $ 为 $ b_i = b_{i-1} - tem + 1 $;
4. 如果事件一不成立，且 $ tem = \log_2 num $ 刚好是整数，这就意味着现在的数除以 $ 2^{tem} $ 刚好等于前一个数，这时 $ b_i $ 要减去 $ 1 $ 以抵消步骤 $ 3 $ 中加的一；
5. 最后将总计数 $ ans $ 加上 $ b_i $ 即可。

### 注意

1. $ a_i $ 的范围是超过了 ``` int ``` 范围的。
2. 如果事件一不成立，即现在的数大于或等于前一个数，则 $ b_i $ 的更新中有可能小于零，但事实上，$ b_i $ 不能小于 $ 0 $。


## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+10;
long long a[N],b[N];//a 数组记录原始数据,b 数组记录每个数需要操作的次数
int main()
{
	int n;
	long long ans=0,num,tem;
	scanf("%d",&n);
	for (int i=1; i<=n; i++)
	{
		scanf("%lld",&a[i]);
		if (i==1) continue;
		if (a[i]<a[i-1])
		{
			num=a[i-1]/a[i];
			if (a[i-1]%a[i]!=0) num+=1;//向上取整
			tem=ceil(log(num)/log(2));//等价于 tem=ceil(log2(num))
			b[i]=b[i-1]+tem;//更新 b[i]
			ans=ans+b[i];//计数
		}
		else
		{
			num=a[i]/a[i-1];
			int ttt=num;
			if (a[i]%a[i-1]!=0) num+=1;//向上取整
			tem=ceil(log(num)/log(2));//等价于 tem=ceil(log2(num))
			b[i]=b[i-1]-tem+1;//更新 b[i]
			if (pow(2,tem)==ttt) b[i]-=1;//抵消上句中的加一
			if (b[i]<0) b[i]=0;//b[i] 不能小于 0
			ans=ans+b[i];//计数
		}
	}
	printf("%lld",ans);//输出答案
	return 0;
}
```


~~纯模拟超时代码。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+10;
long long a[N];
int main()
{
	int n;
	long long ans=0;
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		while (a[i]<a[i-1])
		{
			a[i]*=2;
			ans++;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

#### 三倍经验

[P12642](https://www.luogu.com.cn/problem/P12642)，[CF1883E](https://www.luogu.com.cn/problem/CF1883E)。

##### End。

---

## 作者：vanueber (赞：0)

# 题目大意

每次可以加倍一个元素，求最少多少次操作可以使序列不降。

首先肯定从前往后处理，不断加倍当前数知道大于等于上一个数。

这样做的问题在于数的大小会呈指数级爆炸增长，很容易就爆了 `long long`。

所以考虑另一种存储数的方式，将 $a_i$ 化为 $a_i = d \times 2^t$ 的形式。

由于 $a_i > 0$，此时比较两个数的大小只需要同时取对数 $a_i < a_j \Leftrightarrow \log d_i + t_i < \log d_j + t_j$。

至于加倍的最少次数这个是可以二分的。

考虑到 $a_i < 2^{31}$ 故 $d < 2^{31}$，所以这样化下来的值域是不会炸的。

时间复杂度 $\Theta(n \log^2 V)$。

# Code


```cpp
#include <bits/stdc++.h>
#define int long long
#define umap unordered_map
#define vint vector<int>
#define ll long long
#define pii pair<int,int>
#define all(x) x.begin(),x.end()
#define ull unsigned long long
#define uint unsigned int
#define rg register
#define il inline
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define sqr(x) ((x)*(x))
using namespace std;
const int INF=0x3f3f3f3f;
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        w=(w<<1)+(w<<3)+(ch^48);
        ch=getchar();
    }
    return w*f;
}
inline void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

const int N=2e5+10;
const double eps=1e-12;
int n,a[N],ans;
bool cmp(double a,double b){
    return fabs(a-b)<eps;
}
struct node{
    int d,t;
    node(int num){
        d=t=0;
        while(num%2==0) ++t,num/=2;
        d=num;
    }
    node(int _d,int _t){
        d=_d,t=_t;
    }
    node(){
        d=t=0;
    }
    friend bool operator <=(const node &a,const node &b){
        return ((1.0*log2(a.d)+1.0*a.t)<(1.0*log2(b.d)+1.0*b.t))||cmp((1.0*log2(a.d)+1.0*a.t),(1.0*log2(b.d)+1.0*b.t));
    }
}num[N];//d*2^t
signed main(){
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    #endif
    n=read();
    rep(i,1,n) a[i]=read(),num[i]=node(a[i]);
    for(int i=2;i<=n;++i){
        if(num[i-1]<=num[i]) continue;
        int l=1,r=1e18,res=-1;
        while(l<=r){
            int mid=(l+r)>>1;
            node x=node(num[i].d,num[i].t+mid);
            if(num[i-1]<=x){
                res=mid,r=mid-1;
            }
            else l=mid+1;
        }
        assert(res!=-1);
        ans+=res;
        num[i].t+=res;
    }
    write(ans);
    #ifndef ONLINE_JUDGE
    fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
    #endif
    return 0;
}
```

---


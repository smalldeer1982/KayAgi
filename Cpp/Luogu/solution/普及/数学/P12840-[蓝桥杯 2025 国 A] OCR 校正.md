# [蓝桥杯 2025 国 A] OCR 校正

## 题目描述

小蓝维护着一套 OCR 文字识别系统。最近，系统频繁地将数字 0 和英文字母 O 混淆，这让他十分头疼。一次测试中，系统将一串长度为 2025 的、全部由数字 0 组成的字符串识别成了一个长度相同的字符串，但其中只有首尾两个字符被正确识别为数字 0，其余部分都被错误地识别成了字母 O。

为了校正识别结果，小蓝需将所有的字母 O 替换回数字 0。只是，出于安全的考虑，该系统不允许直接批量修改所有字母 O，而是设定了如下替换规则:

1. 首次操作，可任意选择一个字母 O，将其替换为数字 0；
2. 后续操作，选择一个与数字 0 相邻的字母 O，将其替换为数字 0；
3. 重复上述步骤，直到所有字母 O 都被替换为数字 0。

小蓝想知道，在满足上述替换规则的情况下，总共有多少种不同的替换顺序可以将所有字母 O 替换为数字 0。两种替换顺序被视为不同的，当且仅当它们在某一步骤中选择了不同位置的字符。

现在，请你帮他计算这个数量。由于答案可能很大，你只需给出其对 $10^9 + 7$ 取余后的结果即可。

# 题解

## 作者：_mi_ka_ (赞：2)

## 题目大意

给定一个 长度为 $n$ 的字符串，这个字符串的首尾两个字符是 0，而其他字符都是 O。你可以做一些操作使得这个字符串的所有字符都变为 0：在第一次操作你可以随便选取一个 O 将其变成 0，其他操作只能选取和 0 相邻的字符 O 将其变成 0。求不同的操作顺序数对 $10^9+7$ 取模。

在本题中 $n=2025$。

## 解题思路

~考场上被这道题卡了半个小时~

我们可以选择枚举第一次操作所操作的字符，这个字符可以是第 $2$ 个字符到第 $n-1$ 个字符中的任意一个。

对第 $i$ 个字符这次操作，我们将整个需要操作的字符串变成了：

$$0\underbrace{O\dots O}_{k_1个O}0\underbrace{O\dots O}_{k_2个O}0$$

其中 $k_1=i-2$，$k_2=n-1-i$，这里 $k_1$ 或 $k_2$ 可能是 $0$。

如果只对前面的 $k_1$ 个 O 的子串进行操作，每次只能连续个 O 的开头或者结尾进行操作，在这个子串变成单个 O 之前每次操作都有两种选择，一共 $k_1-1$ 次，因此操作有 $2^{k_1-1}$ 种。注意：当且仅当 $k_1=0$ 时，这个式子不成立，此时没有操作，即操作种类数可视为 $1$ 种。所以只对前面的 $k_1$ 个 O 的子串进行操作的操作种类数为 $ans_1=2^{[k_1>0](k_1-1)}$ 种，其中 $[\text{bool}]$ 为 bool 表达式的值。

同理，只对后面 $k_2$ 个 O 的子串进行操作的操作种类数为 $ans_2=2^{[k_2>0](k_2-1)}$。

对这两种子串的操作是独立的。也就是说，对左子串的顺序已定的 $k_1$ 个操作和对右子串的顺序已定 $k_2$ 个操作可以随意组合（不能改变子串内的操作的已定相对顺序）组成长度为 $k_1+k_2$ 的合法操作。这个随意组合的种类数为 $\frac{(k_1+k_2)!}{k_1!\times k_2!}$，即全排列中定了 $k_1$ 个操作的相对顺序和另外 $k_2$ 个操作的相对顺序。

由以上推导，最终答案为：

$$ans=\sum_{i=2}^{n-1}2^{[k_1>0](k_1-1)}\times2^{[k_2>0](k_2-1)}\times\frac{(k_1+k_2)!}{k_1!\times k_2!}$$

其中 $k_1=i-2$，$k_2=n-1-i$。

可以对阶乘及其逆元预处理时间复杂度 $O(n)$，$O(n\log n)$。然后再 $O(n\log n)$ 枚举统计答案，总时间复杂度 $O(n\log n)$。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int n,ans;
int fac[3000],inf[3000];
int re()
{
	int x=0,p=1;
	char y=getchar();
	for(;y>'9'||y<'0';y=getchar())
		if(y=='-')
			p=-p;
	for(;y>='0'&&y<='9';y=getchar())
		x=x*10+y-'0';
	return x*p;
}
void wr(int x)
{
	if(x<0)
		putchar('-'),x=-x;
	if(x>9)
		wr(x/10);
	putchar(x%10+'0');
}
int ksm(int a,int b)
{
	int ans=1;
	for(;b;b>>=1,a*=a,a%=mod)
		if(b&1)
			ans*=a,ans%=mod;
	return ans;
}
void pre()//预处理阶乘及其逆元 
{
	fac[0]=inf[0]=1;
	for(int i=1;i<=n;i++)
		fac[i]=fac[i-1]*i%mod;
	inf[n]=ksm(fac[n],mod-2);
	for(int i=n-1;i;i--)
		inf[i]=inf[i+1]*(i+1)%mod;
}
signed main()
{
	n=re();//n=2025时输出的是本题的答案 
	pre();
	for(int i=2;i<n;i++)
	{
		int k1=i-2,k2=n-1-i;
		ans+=ksm(2,k1?k1-1:k1)*ksm(2,k2?k2-1:k2)%mod*fac[k1+k2]%mod*inf[k1]%mod*inf[k2]%mod;
		ans%=mod;
	}
	wr(ans);
	return 0;
}

```

---

## 作者：3_14 (赞：2)

[**题目传送门**](https://www.luogu.com.cn/problem/P12840)

# 思路

## 分析

目标：计算所有合法替换顺序的数量。

字符串结构：`0`$+ 2023$ 个 `O`$+ 0$，总长度 $2025$。

核心规则：次替换的 O 必须与已有的 0 相邻。

## 推导

首次操作分类讨论：

1. 首次替换的 O 位于最左端（与首 0 相邻）或最右端（与尾 0 相邻）。
   - 若首次替换左端 O，剩余 $2022$ 个 O 形成左半段和右半段。
   - 替换顺序数等价于长度为 $2022$ 的序列的操作数，即 $2^{2021}$。
   - 同理，首次替换右端 O 时，替换顺序数也为 $2^{2021}$。
   - 总共有 $2^{2021} + 2^{2021} = 2^{2022}$ 种。
3. 首次替换的 O 位于中间位置。
   - 首次替换中间第 $k$ 个 O（$2 \leq k \leq 2022$），将中间 O 分为左段 $a$ 个和右段 $b$ 个，满足 $a + b = 2022$。
   - 左段和右段独立操作，替换顺序数为 $2^{a-1} \times 2^{b-1} = 2^{a+b-2} = 2^{2020}$。
   - 左右段操作顺序的组合数为 $C_{2022}^a$，所有中间情况的总和为：
$$2^{2020}\times \sum_{a=0}^{2022} C_{2022}^{a}=2^{2020}\times 2^{2022}=2^{4042}$$

**Answer：**$\left ( 2^{4042}+2^{2021} \right ) \pmod {10^9+7}$。

# 代码

```cpp
#include<bits/stdc++.h>
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=3e4+5,mod=1e9+7,MOD=998244353;
ll quickly_pow(ll a,ll b,ll p){// 快速幂
    ll ans=1;
    while(b){
        if(b&1)ans=(a*ans)%p;
        a=(a*a)%p;
        b>>=1;
    }
    return ans;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cout<<(quickly_pow(2,4042,mod)+quickly_pow(2,2021,mod))%mod<<'\n';// 按照推导直接输出就行
    return 0;
}
```

### 时间复杂度

$O\left(\log n\right)$，$n$ 为指数大小（最大 $4042$）。

[**AC 记录**](https://www.luogu.com.cn/record/221416580)

---

## 作者：Zhangxm2012 (赞：1)

可以先考虑一个长度为 $n+2$ 的序列：
$$$
\Large{0\underbrace{00…00}_{n个}0}
$$$
若只对其进行操作 2（选择一个与数字 0 相邻的字母 O，将其替换为数字 0），从最左起的每个 0 都往左或右操作，而最后一个只有一种，所以有 $2^{n-1}$ 种方法。

回到原题，在操作 1 后，整个序列就变成了如下样子：
$$$
\Large{0\underbrace{00…00}_{a个}0\underbrace{00…00}_{b个}0}
$$$
如果 $a=0$ 或 $b=0$，则有 $2^{(2025-2-1)-1}=2^{2021}$ 种，又因为两种替换顺序被视为不同的，故有 $2^{2021}+2^{2021}$ 种。

单独考虑两个数列，方法则有 $2^{a-1} \times 2^{b-1}=2^{a+b-2}=2^{2020}$ 种。当然了，两个数列是可以以任意顺序进行操作的，故应有 $C_{a+b}^{a} \times 2^{2020}=C_{2022}^{a} \times 2^{2020}$ 种。所以题目即求：
$$$
\large{2^{2020} \times \sum_{0 \le i \le 2022}C_{2022}^{i}}
$$$
此式的值。由杨辉三角可知：
$$$
\begin{array}{c} 
1\\1 \quad 1\\1 \quad 2 \quad 1\\1 \quad 3 \quad 3 \quad 1 \\…
\end{array}
$$$
上式为 $2^{2020} \times 2^{2022}=2^{4042}$，但上式中的 $2^{2020}\times(C_{2022}^{0}+C_{2022}^{2022})=2^{2021}$ 已经计算了一遍，所以答案应为 $2^{4042}+2^{2021} \bmod 10^{9}+7$。

代码放这了：
``` cpp
#include<bits/stdc++.h>
#define int long long//会溢出，一定要开 long long
using namespace std;
const int Mod=1e9+7;
int Pow(int n){
	int res=1,b=2;
	while(n){
		if(n&1){
			res*=b;
			res%=Mod;
		}
		b*=b;
		b%=Mod;
		n>>=1;
	}
	return res;
}
signed main(){
	cout<<(Pow(2021)+Pow(4042))%Mod;
	return 0;
}
```

---


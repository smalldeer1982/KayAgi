# [蓝桥杯 2025 国 Java B] 分配房子

## 题目描述

蓝桥小镇有 $20255202$ 栋楼房排成一列，每栋楼有两套房子：一套在一楼，一套在二楼。镇长决定将这些房子分配给本地居民或外来游客居住，并设定了如下规则：

- 每一栋楼里，必须有一套是本地居民住，另一套是外来游客住。
- 从本地居民住户中，分别往左、右看同一楼层的邻居。如果某个邻居也住着本地居民，就记录一次（如果某个本地居民的同一楼层的左、右邻居都是本地居民，记录两次）。最后把所有这样的记录加起来，总数是 $5202$。

现在，请你计算出满足这两个规则的房子分配方案总数。由于答案可能很大，你只需给出其对 $10^9 + 7$ 取余后的结果即可。

# 题解

## 作者：_Null_Ptr (赞：3)

题意可以简化为将 $2601$ 个本地居民组成的连续块嵌入到总长度为  $20255202$ 的序列中，然后问有几种方案。

组合数问题不用多讲了，$20255201$ 个间隔中选 $2601$ 个，即  $\binom{20255201}{2601}$。
不过审题的坑就来了，注意答案还要乘以 $2$，因为每栋楼有两种状态，本地居民在上层或下层。

综上所述，答案即为 $\left (\binom{20255201}{2601} \times 2 \right) \bmod (10^9+7)$，提交答案题，自己口算一下提交即可。

---

## 作者：Lecoo (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12886)
## 思路
~~这是一道很简单的小学数学题。~~

我们经过简单读题和思考，可以发现这是一道组合数问题。

因为在本地居民住户中，分别会往左、右看同一楼层的邻居。所以：如果某个本地居民的同一楼层的左、右邻居都是本地居民，就要记录两次，然后我们可以把所有这样的记录加起来，总数也就是是 $5202$，所以可以得出有 $2601$ 组相邻的本地居民。

但是由于如果分配相反（比如从一楼换到二楼，从二楼换到一楼），那么这又是一种分配方法，所以答案要乘二。

最后可以得出结果是：

$2 \times \frac{2601}{20255201}$

经过计算，得出结果是 $728601046$。
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<"728601046"<<endl;
    return 0;
}
```

---

## 作者：Zenn (赞：1)

## 一、题目传送门
[题目传送门](https://www.luogu.com.cn/problem/P12886)
## 二、题意简述
共有 $20255202$ 栋楼房排成一列，每栋都有两层，本地居民会看左右两侧，如果左右两侧也是本地居民则会记录一次，一共记录了 $5202$ 次，问有多少种分配可能。
## 三、思路详解
因为本地居民的同一楼层的左、右邻居都是本地居民，所以要记录两次，最后把的记录加在一起，总数就是 $5202$，记录为 $5202$ 个，所以可以得出有 $2601$ 组相邻的本地居民。

然后通过思考过后可以发现：这是组合数，据此可以得出答案为 
$\frac{2601}{20255201}$。

但是我们还要考虑我们可以从一楼换到二楼，或者从二楼换到一楼的情况。

最后得出答案为：
$2 \times \frac{2601}{20255201}$。

也就是 $728601046$，由于这题是提交答案，所以直接输出即可
## 四、代码实现
```cpp
#include<iostream>
using namespace std;
int main(){
    cout<<"728601046"<<endl;
    return 0;
}
```
## 五、声明
本文的绝大部分内容为本人原创，由 DeepSeek、GPTzero 等 AI 提供核查。

---

## 作者：linruicong_gegeji (赞：1)

数学题。

## 题解

略微思考过后可以发现：这不就是组合数嘛？因此，这道题目的答案就是 $\mathrm{C}_{20255201}^{2601}$……吗？

很明显，我们还要考虑到我们可以从一楼换到二楼，从二楼换到一楼的情况。所以，我们还要将答案乘二。因此，答案为：
$$2 \times \mathrm{C}_{20255201}^{2601}$$
小学数学题，自己算吧。

---

## 作者：whz121018 (赞：1)

# P12886题解

欢迎来到 whz121018 的题解频道！

 [题目传送门](https://www.luogu.com.cn/problem/P12886)

 [本人AC记录](https://www.luogu.com.cn/record/230560447)

尚未入门的小白首发题解，不喜勿喷……

它是一道结果填空题，所以只需要手算出结果直接输出。

## 思路

### 1.题目大意
有 $20255202$ 栋楼房，每栋都有两层，本地居民看左右两侧如果也是本地居民会记录一次，一共记录 $5202$ 次，问有多少种分配可能。

### 2.题目分析

本地居民的同一楼层的左、右邻居都是本地居民，记录两次，最后把所有这样的记录加起来，总数是 $5202$ ，
记录有 $5202$ 个，所以有 $2601$ 组相邻的本地居民。

总共有 $20255201$ 组可能相邻的本地居民，其中有 $2601$ 组相邻。

所以答案即为 $ \frac{2601}{20255201} $ 

但是，我们忘了另一种情况

如果分配完全相反，将会出现又一种分配方法
此时相邻情况完全相同，并未计算进答案中
所以答案要乘 $2$ 。  

### 正确答案

$ 2\times\frac{2601}{20255201} $ 

即 $728601046$ 。

## 代码。
```cpp
#include<iostream>
using namespace std;
int main()
{
    cout<<"728601046";
    return 0;
}
```

~~这是本蒟蒻的第四篇题解呢。~~

求管理员大大通过 。

---

## 作者：CSP_S_2023_T2 (赞：1)

### 思路

两栋相邻楼房，有且仅有两个本地居民相邻和不相邻两种情况。

如果两个本地居民相邻，则会产生两次记录。因为记录有 $5202$ 个，所以有 $2601$ 组相邻的本地居民。

而总共有 $20255201$ 组可能相邻的本地居民，其中有 $2601$ 组相邻，答案即为 $C_{20255201}^{2601}$。

（等等，是不是忘记了什么？）

对于一种合法情况，可以衍生出另一种合法情况，即为分配完全相反（一楼的换到二楼，二楼的换到一楼），此时相邻情况完全相同，并未计算进答案中。所以答案要乘 $2$。

综上，答案即为 $2 \times C_{20255201}^{2601}$。

### 计算方法

$$
\begin{aligned}

C_{20255201}^{2601} &= \frac{20255201!}{(20255201-2601)! \times 2601!}
\\
&= \frac{\prod_{i=20255201-2601+1}^{20255201} i}{2601!}

\end{aligned}
$$

算出分子分母取模后的值，逆元算出答案即可。

答案为 $728601046$，输出即可。

---

## 作者：BZS_1902 (赞：0)

## 思路 ##
我们可以先从相邻楼房考虑，两栋相邻楼房，会分出两种情况，第一种是两个本地人相邻，第二种是本地人不相邻。
而且，题目中给出，两个本地人相邻，会增加两次，相邻的本地居民组数是统计次数的一半即 $2601$ 组。
而总共有 $20255201$ 组可能相邻的本地居民，其中有 $2601$ 组相邻，答案即为 $2601$ 与 $20255201$ 的组合数乘上本地居民在一栋楼中的上下层情况，即为 $2601$ 与 $20255201$ 的组合数乘上二，拿电脑上的计算器扒拉两下即可出答案为 $728601046$。
## 代码 ##
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	cout << 728601046; 
	return 0;
}
```

---

## 作者：StarsIntoSea_SY (赞：0)

# Solution

插板法。

假设 $0$ 是本地居民住在上层，$1$ 是本地居民住在下层。因为相邻的层会记录两次，那么问题转换成有 $20255202$ 个只能赋成 $0$ 或 $1$ 的数，有恰好 $\frac{5202}{2} = 2601$ 个相同的数相邻。

这 $20255202$ 的位中有 $20255201$ 个空位，那么就是在这些空位中插入 $2601$ 个板，如果有板那么旁边的两个数就一定相同，如果没有板就一定不相同，有 $C_{20255201}^{2601}$ 种插入方式。但是我们需要求数的赋值的方案数。可以发现在任何一种插板方式下，数的赋值只能有两种，因为第 $1$ 位可以赋值成 $0$ 或 $1$，后面的数就都能确定。

那么答案就是 $C_{20255201}^{2601} \times 2$。

---

## 作者：xtzhangziche (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12886)

## 思路
因为从本地居民住户中，分别往左、右看同一楼层的邻居。如果某个邻居也住着本地居民，就记录一次。

所以每两个相邻的本地住户会产生 $2$ 次记录， $5202$ 个记录，也就是有 $2601$ 组相邻的本地居民。

总共有 $20255201$ 组可能相邻的本地居民，其中有 $2601$ 组相邻的居民，所以答案为 $C^{2601}_{20255201}$。

但是由于如果分配相反（三楼换到四楼，四楼换到三楼），那么这又是一种分配方法，所以答案要乘二。

正确答案：$2 \times C^{2601}_{20255201}$，手算得出 $728601046$。

## Python Code

```python
print(728601046)
```

---

## 作者：rxr2018360074 (赞：0)

拿到这题，我的第一想法是 dp，所以我们先看一下 dp 怎么写。

## 最暴力的写法
我们设 $dp_{i,j,0/1}$ 表示考虑前 $i$ 栋房子时记录值为 $j$ 且这栋房的状态为 $0/1$ 的方案数（$0$ 表示本地居民在下面，$1$ 表示本地居民在上面）。

我们知道，如果只有一栋房，那么你的记录值只能为 $0$，所以 $dp_{1,0,0}=dp_{1,0,1}=1$，接下来考虑转移。

对于 $dp_{i,j,0}$，我们发现如果 $i-1$ 的状态也是 $0$，那么 $j$ 能增加 $2$。否则 $j$ 不变。所以 $dp_{i,j,0}=dp_{i-1,j-2,0}+dp_{i-1,j,1}$。

对于 $dp_{i,j,1}$，我们发现如果 $i-1$ 的状态也是 $1$，那么 $j$ 能增加 $2$，否则 $j$ 不变。所以 $dp_{i,j,1}=dp_{i-1,j-2,1}+dp_{i-1,j,0}$。

最后输出 $dp_{20255202,5202,0}+dp_{20255202,5202,1}$ 即可，经过计算，时间大概是 $2000$ 秒，虽然这只是一道提交答案题，但这样还是太过暴力了。

## 稍稍优化版
那么问题来了，我们该怎么优化呢。

我们计 $s_{i,j}=dp_{i,j,0}+dp_{i,j,1}$，既然我们要输出 $dp_{20255202,5202,0}+dp_{20255202,5202,1}$，那么我们将上面的转移方程相加一下，看能不能得出什么结论。

$dp_{i,j,0}+dp_{i,j,1}=dp_{i-1,j-2,0}+dp_{i-1,j,1}+dp_{i-1,j-2,1}+dp_{i-1,j,0}=(dp_{i-1,j-2,1}+dp_{i-1,j-2,0})+(dp_{i-1,j,1}+dp_{i-1,j,0})$

把当中的 $dp$ 用 $s$ 替换一下，可以发现 $s_{i,j}=s_{i-1,j-2}+s_{i-1,j}$，于是我们得到了全新的转移方程，最后输出 $s_{20255202,5202}$ 即可，大概用时 $1000$ 秒。

## 空间优化
当然，分析归分析，实际写代码时就有一个很现实的问题：你的空间够不够？

显然，空间不支持我们开一个 $20255202\times5202$ 的数组。但我们发现，你的每一次转移只和 $i-1$ 有关，所以我们用滚动数组优化。

计 $dp_{fl,j}(fl=0/1)$ 为考虑前 $j$ 项时的方案数。$i=1$ 时 $fl=0$，每次转移为 $dp_{fl,j}=dp_{!fl,j}+dp_{!fl,j-2}$。随后 $fl=!fl$，最后输出 $dp_{1,5202}$，这样子空间就足够了。

但是，我们要注意，这种方式只能优化空间，时间仍然不变。
## 再次优化
我们可以发现，因为每次转移时只受到 $j$ 与 $j-2$ 有关，所以我们计 $dp_{fl,j}$ 为当前状态为 $fl$ 时考虑记录值为 $j\times2$ 时的方案数。此时的转移方程为 $dp_{fl,j}=dp_{!fl,j}+dp_{!fl,j-1}$，加上一些比较奇怪的优化，实际时间大约为 $320$ 秒左右，此时已经无法继续优化，$dp$ 这条路已经走到头了。

注意一点：**每次开始时 $dp_{fl,0}$ 一定要赋值为 $2$！！！**
## 正片开始
首先，我先遗憾的说一句，以上有关 $dp$ 的做法对于正解的帮助几乎为 $0$。

但还是有一点，在最开始分析的时候，我们可以发现如果第 $i$ 栋房子与第 $i+1$ 栋房子的状态相同，那么记录结果会 $+2$。

因为最后的观察结果为 $5202$，所以我们只要选择 $2601$ 个 $i$，让 $i$ 和 $i+1$ 的状态相同即可，因为不清楚“状态相同”的具体状态，所以将答案再 $\times 2$ 就可以了。

但是，我们又可以发现一个问题，如果有三个（或更多）连续的状态相同怎么办？

见下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bji1hk1l.png)

连续的三个可以拆分成两段连续的两个状态相同的房子，所以不需要担心会对答案造成影响。

当然，还有一点，最后一个数（即 $20255202$）是没办法被选上的（因为没有下一个），所以答案就是在 $20255201$ 个中选择 $2601$ 个数，即：
$$
\textstyle C_{20255202}^{2601}\times 2 \bmod{10^{9}+7}
$$

因为要处理模意义下的除法，所以先求出 $2601!$ 的逆元，最后计算即可。

答案为 $728601046$。

AC code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    cout<<"728601046\n";
    return 0;
}
``````

## 题外话
为什么我要花大篇幅写 dp 呢？其实主要是因为它是在我毫无头绪中想出来的时间长但正确的算法。我希望大家在拿到题没有思路时先用你能用到的所有方法拿下部分分，再在所有的其他题都写完后再来思考正确的解法。

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P12886)

# 思路

## 分析

每栋楼的一楼和二楼分配是独立的，且必须一个为本地居民，另一个为外来游客。因此，每栋楼有两种分配方式：一楼本地居民和二楼外来游客，或一楼外来游客和二楼本地居民。

所有本地居民在同一楼层的左右邻居中的数量总和为 $5202$。

可以将问题转化为计算满足条件的 0-1 序列数目。假设一楼的分配为序列 $A$（$0$ 表示外来游客，$1$ 表示本地居民），则二楼的分配为 $B = 1 - A$。现需要计算所有可能的序列 $A$，使得其产生的邻居记录总和为 $5202$。

## 推导

设序列 $A$ 的长度为 $n = 20255202$，其中相邻元素相等的对数为 $k$。对于每个相邻相等的对（如 $A_i = A_{i+1} = 1$），它们对总和的贡献为 $2$（每个本地居民各贡献 $1$ 次）。因此，总和 $S = 2\times k$。根据题目条件 $S = 5202$，可得 $k = 2601$。相邻不同的次数为 $t = \left(n-1\right) - k = 20255201 - 2601 = 20252600$)。

现在只需计算 $\binom{20255201}{2601}\pmod {10^9+7}$。

 - 分子：计算 $20255201 \times 20255200 \times \cdots \times 20252601 \pmod {10^9 + 7}$。
 - 分母：计算 $2601!\pmod {10^9 + 7}$。
 - 逆元：利用费马小定理计算分母的逆元 $\left(2601!\right)^{-1} \pmod {10^9 + 7}$。
 - answer：算出最终答案 $\boxed{728601046}$。

# 代码

#### 直接输出就行。

```cpp
#include<bits/stdc++.h>
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=3e4+5,mod=1e9+7,MOD=998244353;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cout<<"728601046\n";
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/221284790
)

---


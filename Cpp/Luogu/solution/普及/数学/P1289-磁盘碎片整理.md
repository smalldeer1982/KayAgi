# 磁盘碎片整理

## 题目描述

出于最高安全性考虑，司令部采用了特殊的安全操作系统，该系统采用一个特殊的文件系统。在这个文件系统中所有磁盘空间都被分成了相同尺寸的 $N$ 块，用整数 $1$ 到 $N$ 标识。每个文件占用磁盘上任意区域的一块或多块存储区，未被文件占用的存储块被认为是可是用的。如果文件存储在磁盘上自然连续的存储块中，则能被以最快的速度读出。

因为磁盘是匀速转动的，所以存取上面不同的存储块需要的时间也不同。读取磁盘开头处的存储块比读取磁盘尾处的存储块快。根据以上现象，我们事先将文件按其存取频率的大小用整数 $1$ 到 $K$ 标识。按文件在磁盘上的最佳存储方法，$1$ 号文件将占用 $1,2,\cdots,S_1$ 的存储块，$2$ 号文件将占用 $S_1+1,S_1+2,\cdots, S_1+S_2$ 的存储块，以此类推（$S_i$ 是被第 $i$ 个文件占用的存储块的个数）。为了将文件以最佳形式存储在磁盘上，需要执行存储块移动操作。一个存储块移动操作包括从磁盘上读取一个被占用的存储块至内存并将它写入其他空的存储块，然后宣称前一个存储块被释放，后一个存储块被占用。

本程序的目的是通过执行最少次数的存储块移动操作，将文件按最佳方式存储到磁盘上，注意同一个文件的存储块在移动之后其相对次序不可改变。

## 样例 #1

### 输入

```
20 3
4 2 3 11 12
1 7
3 18 5 10
```

### 输出

```
We need 9 move operations.
```

# 题解

## 作者：逆时针的记忆 (赞：13)

既然没有写并差集的

那我就来一篇

w意思是移动到第几个储存块

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cmath>
using namespace std;
int f[100005];
int find(int x)
{
	if (f[x]==x) return f[x];
	return f[x]=find(f[x]);
}
int main()
{
	int i,j,n,k,w=0,x,ans=0,t;
	scanf ("%d%d",&n,&k);
	for (i=1; i<=n; i++) f[i]=i;
	for (i=1; i<=k; i++)
	{
		scanf ("%d",&t);
		for (j=1; j<=t; j++)
		{
			w++;
			scanf ("%d",&x);
			if(w!=x)//如果该内容不在指定位置
			{
				int p1=find(w);
				int p2=find(x);//并差集
				if (p1==p2) ans+=2;
				else
				{
					ans++;
					f[p1]=f[p2];
				}
			}
		}
	}
	if (ans>0) printf ("We need %d move operations.\n",ans);
	else printf ("No optimization needed.\n");
	return 0;
}
```


---

## 作者：windyuan (赞：5)

题目难度分类是魔鬼吗？
本来想直接秒。
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
using namespace std;
int a[100090];
int main()
{
    int s,k,n,m,i,j,num=1,t,ans=0;
    cin>>n>>k;
    for(i=0;i<k;i++)
    {
        scanf("%d",&s);
        for(j=1;j<=s;j++)
            cin>>t,a[t]=num,num++;
    }
    for(i=1;i<=num-1;i++)
    {
        if(a[i]==0)
            for(j=1;j<=n;j++)
                if(a[j]==i)
                    a[j]=0,a[i]=i,ans++;
    }
    for(i=1;i<=num-2;i++)
        for(j=i+1;j<=num-1;j++)
            if(a[i]>a[j]) swap(a[i],a[j]),ans++;
    if(ans!=0)
    	cout<<"We need "<<ans<<" move operations."<<endl;
    else cout<<"No optimization needed."<<endl;
    return 0;
}
```
先记录下第i个位置数的目前位置t。

然后把1到m位置的0填上，反正就是**太菜了**。

只好拿出笔和纸思考了一下。


------------


第i个位置的数如果不正确，则我要把正确的数移动到i
	
    问题：如果i位置上有数字怎么办？
    
          那就把i位置上的数放到它该放的地方。
          
这时你就会发现i位置上的数应放的位置上可能还有一个数j…………

那就在操作一次呗，直到有一个位置为空。

注意环形，比如1，在2位置。2，在1位置。

代码：
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
using namespace std;
int a[100090];
bool ok[100090];
int main()
{
	int s,k,n,m,i,j,num=0,t,ans=0;
	cin>>n>>k;
	for(i=0;i<k;i++)
	{
		scanf("%d",&s);
		for(j=1;j<=s;j++)
		{
			scanf("%d",&t);
			num++;
			a[num]=t;
			if(num==t) ok[t]=1;
		}
	}
	for(i=1;i<=num;i++)
		if(ok[i]==0)
		{
			m=k=a[i];
			do{
				ok[k]=1;
				ans++;//ok[k]==0 环形特判 
				k=a[k];//ok[k]==0 意味着此处不正确。 
			}while(k!=0 && ok[k]==0);//k=0 意味着a[k]为空 
			if(k==m) ans++;//最后换回来了，形成了一个环形 
		}
	if(ans!=0)
    	cout<<"We need "<<ans<<" move operations."<<endl;
    else cout<<"No optimization needed."<<endl;
	return 0;
}
```




---

## 作者：_hxh (赞：4)

## 分析

题意有些混乱，我们不妨模拟一下样例：

![](https://cdn.luogu.com.cn/upload/image_hosting/cklkfqa1.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

而将文件按最佳方式存储到磁盘上后应该是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/m2xnjxqk.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

即每个文件的一部分都有其相应的存储块。我们就是要计算出将文件按最佳方式存储到磁盘上的最少执行次数。若目标存储块有一个位置错误的文件，则要先将其移到正确位置。若这个文件的目标存储块还是有一个位置错误的文件，就要不停的递归下去，直到目标存储块为空。重复这个操作即可。若出现环就要加一次操作次数，因为我们需要先移出环中的某个元素，使之成为链，再调整链中的元素，最后把这个元素放到正确的，空出的位置。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n,k,s,a[N],pos,ans,vis[N];
int find(int x)
{
	if (!x || vis[x])
		return x;
	vis[x] = 1;
	ans++;
	return find(a[x]);
}
int main()
{
	cin >> n >> k;
	for (int i = 1;i <= k;i++)
	{
		cin >> s;
		for (int j = 1;j <= s;j++)
		{
			cin >> a[++pos];
			if (a[pos] == pos)
				vis[pos] = 1;
		}
	}
	for (int i = 1;i <= pos;i++)
	{
		if (vis[i])
			continue;
		int last = find(a[i]);
		if (last == a[i])
			ans++;
	}
	if (ans)
		cout << "We need " << ans << " move operations." << endl;
	else
		cout << "No optimization needed." << endl;
	return 0;
}
```

---

## 作者：billtun (赞：2)

题目说的把我难住了，后来读懂题目后，发现 ~~并不~~ 是真的特别难。

其实就是看每一个磁盘碎片在不在正确位置上，如果在那就直接跳过。如果不在，那就把它放到他应该在的位置上去。但如果它应该在的位置上是别的磁盘碎片，那么就要递归遍历（注意加退出条件）。

# Code:
```cpp
#include<bits/stdc++.h>

using namespace std;

int n, k, s, sum, ans, a[100005];
bool vis[100005]={0};

int dfs(int x){
	if(!x || vis[x]) return x;
	vis[x]=1, ans++;
	return dfs(a[x]);
}

int main()
{
	cin>>n>>k;
	for(int i=1;i<=k;i++){
		cin>>s;
		for(int j=1;j<=s;j++){
			cin>>a[sum+j];
			if(a[sum+j]==sum+j){
				vis[sum+j]=1; // 看在不在正确位置上
			}
		}
		sum+=s;
	}
	
	for(int i=1;i<=sum;i++){
		if(vis[i]) continue; // 判断在不在正确位置上
		if(dfs(a[i])==a[i]){ // 最后变好了
			ans++; // 次数
		}
	}
	
	if(ans){
		cout<<"We need "<<ans<<" move operations.";
		return 0;
	}
	
	cout<<"No optimization needed.";
	return 0;
}
```

---

## 作者：zlqwq (赞：2)

直接并查集处理即可。

记录一下每个连通块是第几个。

只要每次 $id$ 和 输入的整数的跟不同，就然最后的答案 $ans$ 加一即可，否则加二。


```cpp
int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
} 
```

并查集找根函数。


```cpp
	if(find(w)==find(x))ans+=2;
	else ans++;
```

计算答案。

最后判断 $ans$ 是否为正即可。

---

## 作者：2024sdhkdj (赞：2)

## 题意描述
题目多余的话很多，需要你从中去提取有效信息。

给定两个整数 $n$ 和 $k$，表示有 $n$ 个相同尺寸的磁盘空间，$k$ 个文件。事先将文件按其存取频率的大小用整数 $1$ 到 $k$ 标识。对于每个文件，给出它初始的、按自然顺序在磁盘上占用的存储块的标识（无序的，位置**任意**），要求将每个文件按**最佳方式**存储到磁盘上所需进行的最少存储块移动操作次数（有序的，位置**相邻**）。最佳方式的定义可见题意。
## 算法分析
看楼下有巨佬打的并查集，玄学得很，没有看明白，所以，~~为什么不直接模拟呢？~~

题目是要我们把所有位置错误的存储块放在正确位置所需的操作次数，于是可以模拟这个过程，对于放对的存储块我们不需要管，直接跳过；对于放错的存储块，我们则需要把它放在正确的位置（~~这不废话吗~~），但有没有一种情况，就是它要放置的位置也有一个存储块，那我们就还需要如此执行一次操作来帮助第二个存储块找到正确的位置。那如果第二个存储块的正确位置也有一个存储块呢？可见，我们无法纯粹模拟解决这个问题，还需要在每找到一个需要改变位置的存储块时继续递归下去。

不多说了，详情请见代码及其注释。
## 代码
~~~
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10; 
int n,k,c,in,s,cnt,ans;
int a[N];
bool vis[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n>>k;
	for(int i=1;i<=k;i++){
        cin>>c;
        for(int j=1;j<=c;j++){
            cin>>in;
		    a[++cnt]=in;
		    if(in==cnt)
			    vis[cnt]=true;//标记已经放对的存储块
        }
	}
	for(int i=1;i<=cnt;i++){
		if(vis[i])//如果放对了就跳过
			continue;
		int xx=a[i],x=a[i];
		while(1){//为了方便读者理解，这里用循环代替递归
			ans+=++vis[x];//标记此存储块放对了，并更新答案
			x=a[x];//继这个点往下搜寻
			if(!x||vis[x])//如果下个点为空或者下个点放对了，跳出
				break;
		}
		if(x==xx)//如果走一圈又回来了，更新答案
			ans++;
	}
	if(ans)
		cout<<"We need "<<ans<<" move operations.";
	else
		cout<<"No optimization needed.";
	return 0;
}
~~~

---

## 作者：zg_ji (赞：1)

## 题目大意

看起来这个题目的题干很长，但读完之后我们提炼精华可以发现，这个题就是要找我的每个磁盘是否在正确的位置，如果不在，则最少需要多少步才能将其放到正确的位置。

那么我们可以想到要用能查找的方法。那么就是搜索和并查集。在这里搜索其实算模拟。

### 搜索做法

我们可以采用递归的方式找我们当前位置的磁盘如果不在，那该将他移动几步，这期间我们需要用一个布尔类型的数组做标记，标记我的磁盘是否在正确的位置，使用递归也可以解决如果这个磁盘原本的位置上有了其他磁盘的话，那新的磁盘又要走几步。

代码如下：

```
#include<bits/stdc++.h>
#define int long long
const int N=1e5+10;
using namespace std;

int s;
int x;
int ans;
int n,k; 
int a[N];
bool f[N];

inline int dfs(int x)
{
	if(x==0||f[x]==true) return x;
	f[x]=true;
	ans++;
	return dfs(a[x]); 
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	int cnt=0;
	while(k--)
	{
		cin>>s;
		for(int i=1;i<=s;i++)
		{
			cin>>x;
			a[++cnt]=x;
			if(x==cnt) f[x]=true;
		}
	}
	for(int i=1;i<=cnt;i++)
	{
		if(f[i]==true) continue;
		if(dfs(a[i])==a[i]) ans++;
	}
	if(ans!=0)
	{
		cout<<"We need "<<ans<<" move operations.";
		return 0;
	}
	cout<<"No optimization needed.";

	return 0;

}
```

### 并查集做法

这题并查集做法就是板子题。在这里我运用了@逆时针的记忆 大佬的思路。$op$ 是用来表示我现在移动到了哪一步，如果我的磁盘没在正确的位置的话，我就去递归查找他该去哪，要走几步。同时要注意并查数组的值要及时更新。

代码如下：

```
#include<bits/stdc++.h>
#define int long long
const int N=1e5+100;
using namespace std;

int s;
int op;
int ans;
int cnt;
int n,k,x;
int p[N],a[N];

inline int find(int u)
{
	if(p[u]!=u) return p[u]=find(p[u]);
	return p[u];
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) p[i]=i;
	while(k--)
	{
		//op=0;
		cin>>s;
		for(int i=1;i<=s;i++)
		{
			op++;
			cin>>x;
			if(op!=x)
			{
				int ji=find(op),yu=find(x);
				if(ji==yu) ans+=2;
				else ans++,p[ji]=p[yu];
			}
		}
	}
	if(ans!=0)
	{
		cout<<"We need "<<ans<<" move operations.";
		return 0;
	}
	cout<<"No optimization needed.";

	return 0;

}
```

---

## 作者：__UrFnr__ (赞：1)

虽然题目标签没说是并查集，但是我们也可以用。

题目文字很多，需要提取最关键能让我们解题的地方，下面分析一下。

题目分析：判断每一个位置的磁盘碎片是否是正确的，正确则不需要，不是的话交换到正确的位置，求最小的交换次数。

此题可以使用修改一下的并查集。

AC Code：


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, fa[100010], nc, s, x, ans;
int find (int x) {//并查集
    if (fa[x] == x) return fa[x];
    return fa[x] = find (fa[x]);
}
void join (int x, int y) {//因题而异，改进一下
    int f1 = find (x), f2 = find (y);
    if (f1 == f2) ans += 2;
    else {
        ans ++;
        fa[f1] = f2;
    }
}
int main () {
    cin >> n >> k;
    for (int i = 1; i <= n; i ++) fa[i] = i;
    for (int i = 1; i <= k; i ++) {
        cin >> s;
        for (int j = 1; j <= s; j ++) {
            cin >> x;
            nc ++;//第几个储存块，同时也是该储存块对应的磁盘碎片
            if (nc != x) //如果不是对应的，交换到正确的储存块
                join (nc, x);
        }
    }
    if (ans > 0) printf ("We need %d move operations.", ans);//需交换，按题意输出结果
    else cout << "No optimization needed.";//不需交换，按题意输出
}
```

---

## 作者：Star_F (赞：0)

一道题目较难懂的模拟题。

## 题目大意：
每一个位置上有一个磁盘碎片，如果这个位置上是正确的磁盘碎片，则跳过，如果这个位置上是不正确的磁盘碎片，我们就要通过交换磁盘碎片使所有位置上的都是正确的。求最少的交换次数。

## 题目分析：
我们按照题目模拟，依次遍历每一个位置，如果遍历到不正确的位置我们就选择交换每交换一次答案就加一，但有一种情况就是交换一次还是不正确的，我们可以递归处理直到交换到正确的位置就停止。还有一种就是出现了环，特判一下即可。

看到还有写并查集的，想了一下发现确实可以这么做，但直接模拟应该更好吧。

看着代码理解会更好一点。

## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define ROF(i, a, b) for (int i = (a); i >= (b); --i)
#define DEBUG(x) cerr << #x << '=' << x << endl

inline int rd(){
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9'){
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
        x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
    return x * f;
}

void print(int x){
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
    return;
}

namespace Star_F{
    int n, k;
    int a[100005];
    bool vis[100005];
    int cnt, ans;
    void Main(){
        n = rd();
        k = rd();
        int sum,x;
        FOR(i,1,k){
            cin >> sum;
            FOR(j,1,sum){
                cin >> x;
                a[++cnt] = x;
            }
        }
        FOR(i,1,cnt){
            if(a[i]==i)      //如果这个位置已经是正确的，则标记
                vis[i] = 1;
        }
        FOR(i, 1, cnt){
            if(vis[i])        //跳过正确的
                continue;
            int now = a[i];
            while(true){       //递归进行交换
                vis[now]++;
                ans++;
                now = a[now];
                if(now==0||vis[now])     //找到了就跳出
                    break;
            }
            if(now==a[i])           //如果有环
                ans++;
        }
        if(ans == 0)            //输出
            cout << "No optimization needed.";
        else 
            cout<<"We need " << ans << " move operations." << endl;
    }

}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    return Star_F::Main(), 0;
    return 0;
}
```

---

## 作者：Eterna (赞：0)

~~题目一看就不想写了，太长了。~~

但是读懂后，发现并不难。

只需要使用类似模拟的方法就行了。

对每一块磁盘，如果它正确的位置上在别的地方，那么就要递归遍历。

递归可以循环代替。

###  代码
```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;
int a[N];
bool vis[N];
int s,k,n,m=0,ans=0;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=k;i++)//输入 
	{
		cin>>s;
		while(s--)
		{
			m++;
			cin>>a[m];	
			if(m==a[m])vis[m]=1;
		}
	}
	for(int i=1;i<=m;i++)
		if(vis[i]==0)
		{
			int v=a[i];
			k=a[i];
			while(1)
			{
				vis[k]=1;//标记 
				k=a[k];//递归 
				ans++;//答案计数 
				if(k==0||vis[k]!=0)break; 
			}
			if(k==v)ans++;
		}
	if(ans!=0)cout<<"We need "<<ans<<" move operations."<<endl;//输出 
    else cout<<"No optimization needed."<<endl;
	return 0;
}
```

---


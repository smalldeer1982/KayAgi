# 倒酒

## 题目描述

Winy是一家酒吧的老板，他的酒吧提供两种体积的啤酒，$a$ ml 和 $b$ ml，分别使用容积为 $a$ ml 和 $b$ ml 的酒杯来装载。

酒吧的生意并不好。Winy 发现酒鬼们都非常穷。有时，他们会因为负担不起 $a$ ml 或者 $b$ ml 啤酒的消费，而不得不离去。因此，Winy 决定出售第三种体积的啤酒（较小体积的啤酒）。

Winy 只有两种杯子，容积分别为 $a$ ml 和 $b$ ml，而且啤酒杯是没有刻度的。他只能通过两种杯子和酒桶间的互相倾倒来得到新的体积的酒。

为了简化倒酒的步骤，Winy 规定：

1.  $a≥b$；
2.  酒桶容积无限大，酒桶中酒的体积也是无限大（但远小于桶的容积）；
3. 只包含三种可能的倒酒操作：  
   1. 将酒桶中的酒倒入容积为 $b$ ml 的酒杯中；  
   2. 将容积为 $a$ ml 的酒杯中的酒倒入酒桶；  
   3. 将容积为 $b$ ml 的酒杯中的酒倒入容积为 $a$ ml 的酒杯中。
4. 每次倒酒必须把杯子倒满或把被倾倒的杯子倒空。

Winy希望通过若干次倾倒得到容积为 $a$ ml 酒杯中剩下的酒的体积尽可能小，他请求你帮助他设计倾倒的方案。

## 说明/提示

### 样例解释

倾倒的方案为：

1. 桶 $\to$ B 杯；
2. B 杯 $\to$ A 杯；
3. 桶 $\to$ B 杯；
4. B 杯 $\to$ A 杯；
5. A 杯 $\to$ 桶; 
6. B 杯 $\to$ A 杯。


## 样例 #1

### 输入

```
5 3
```

### 输出

```
1
1 2
```

# 题解

## 作者：Gary818 (赞：119)

偷偷嘟囔几句：为啥因为排版丑拒我好几次，好委屈  

楼上的大佬们讲了思路和代码  
我在这里简单讲下**欧几里得**和**扩展欧几里得**吧   
开讲之前，先来说下必须知识  
  
* ## 裴蜀（贝祖）定理 ##
若ax+by=m有解，那么m一定是gcd(a,b)的若干倍  
可以百度了解一下  
在这里，暂且当做已知知识  
如果你看懂了裴蜀定理  
把它A掉  
[P4549 裴蜀定理](https://www.luogu.org/problemnew/show/P4549)

* ## 欧几里得 ##
欧几里得是啥，能吃吗？？来自灵魂深处的发问。  
嗯，真香！   
欧几里得算法又称辗转相除法  
简称GCD  
用来求两个数的最大公约数  
gcd(a,b)=gcd(b,a%b)  
通常我们递归实现：  
```cpp
inline int gcd(int a,int b){
	if(b==0) return a;
   	return gcd(b,a%b);
}
```
三目运算符：
```cpp
inline int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}
```

  对于上面的式子 ax+by=m  
  我们不仅想知道有没有解，还想知道这个解到底是多少  
  那么就得用到今天的主角啦  


* ## 重点来说下扩展欧几里得 ##  
模板：gcd(int a,int b,int &x,int &y)  
代码一会儿补全  
先来说递归的边界情况  
最后一定会递归至b==0的情况  
a=gcd(a,b)  
a × 1+b × 0 = gcd (a , b)  

下面是当a>b>0时的证明（建议手模一遍，很简单）：  
a × x1+b × y2=gcd(a,b)  
b × x2+(a%b) × y2=gcd(b,a%b)  


由朴素的欧几里得算法得：  
∵ gcd(a,b)=gcd(b,a%b)  
∴ a × x1+b × y2=b × x2+(a%b) × y2  

接下来用待定系数法，将等式右边变形为：  
b × (x2-(a%b) × y2) + a × y2  

就有了这个等式：  
a × x1+b × y2=b × (x2-(a%b) × y2) + a × y2   
那么，显然，对应项系数相等：  
x1 = y2  
y1 = (x2-(a%b) × y2)  

综合上述证明，递归的式子已经很显然了  
贴板子：  
```cpp
inline int exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int tmp=exgcd(b,a%b,x,y);
	int t=x;
	x=y;
	y=t-a/b*x;
	return tmp;
}
```

到这里，如果你认真的看完了，并且看懂了  
尝试一下这个吧  
[P1082 同余方程](https://www.luogu.org/problemnew/show/P1082)  

## 最后，我们来说这道题[P1292 倒酒](https://www.luogu.org/problemnew/show/p1292) ##
对于第一问，因为a与b互质，如果来回倒酒，  
那么酒的数量一定是a和b的公约数  
又因为题目说是最小的酒量  
那么自然就是最大公约数啦gcd(a,b)  
~~那我exgcd不是白讲了？？（小声bbbbb）~~  
看数据范围，10^9  
emmmm，假如酒馆老板非常抠，a和b全是特别小的杯子  
妥妥的安排你去TLE  
你万般无奈的回头仔细看了exgcd  
并且极不情愿的把板子~~粘了下来~~  
然后第一问结束了。。。  

对于第二问呢，无非就是卡一个最小次数出来  
本人认为@war1111     
大佬讲的非常仔细，大家可以找找他的题解阅览  
最后，~~泥谷的优良传统：高清无码~~  
```cpp
#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <cstring>
using namespace std;

inline int read(){
	int x=0,w=1;
	char ch=getchar();
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
	return x*w;
}

inline int exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int tmp=exgcd(b,a%b,x,y);
	int t=x;
	x=y;
	y=t-a/b*x;
	return tmp;
}

int main(){
	int a,b,x,y;
	a=read(),b=read();
	int ans=exgcd(a,b,x,y);
	cout<<ans<<'\n';
	x*=-1,a*=-1;
	while(x<0||y<0){
		x+=b/ans*(x<0);
		y-=a/ans*(x>=0);
	}
	cout<<x<<" "<<y;
	return 0;
}
```
希望能给初学者良好的基本知识，顺手留赞（~~~不要脸的逃了QAQ~~~）

---

## 作者：war1111 (赞：20)

P1292 倒酒

这个题有很多模型，这个是一个变形。

我令一个解为x

两个整数Pa和Pb，分别表示从体积为a ml的酒杯中倒出酒的次数和将酒倒入体积为b ml的酒杯中的次数(酒杯一开始为空)。

b最后是0，所有倒入b中的都会倒入a中，而每次a倒出都是从满的状态倒出来，所以剩下的x=Pb\*b-Pa\*a。


因为a和b要互质，所以x一定是gcd(a,b)的整数倍，不然令两边同时除以gcd(a,b),左边就是分数了，而右边要求的Pa和Pb包括a,b都是整数，那就无解了。那x最小就是gcd(a,b)。

然后扩欧求出一组解，转而求最小解。


怎么求呢？


如果Pa和Pb是一组解，那么(Pa+a)\*b-(Pb+b)\*a=x也成立，显然，

(Pa+a/gcd(a,b))\*b-(Pb+b/gcd(a,b))\*a=x也成立,而且这是可以调整的最小幅度,即不会错过最优解，可以类似的不断调整使解达到最小或变成正数。


代码：http://www.cnblogs.com/war1111/p/7701813.html


---

## 作者：灵乌路空 (赞：17)

# 欧几里得与扩展欧几里得

博客食用 , 效果更佳: [欧几里得 与 扩展欧几里得 - 核融合炉心 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/ou-ji-li-dei-yu-kuo-zhan-ou-ji-li-dei)

以下，是本题需要的所有前置知识(大概吧wwww),  

如果您已经学会了所有的前置知识,  
请忽略 $Baka$ 阿空的废话  
直接看关于本题的内容

------------

### 目录：

- 1.欧几里得定理
  - 证明
  - 应用
  
- 2.裴蜀定理

- 3.扩展欧几里得  
   - 证明
   - 求解线性不定方程
- 4.关于本题

------------
## 1.欧几里得定理：

**即 :** $\large gcd(a,b) = gcd(b,a\mod b)$

当 $b=0$ 时，$gcd(a,b)= \mid a\mid$ ; 

- ###### 感谢cyh学长给的证明 : 

   设 : $a,b$ 的最大公约数为 $c$
   
   **则 :** $a=nc\  ,\  b=mc$ , $(n,m \in Z)$ , $a=k\times b + r$
  
   **则 :** $r=a\%b=a-k b=nc-kmc=(n-km)c$
   
   若要使 $(a,b) = (b,a\%b)$ ,
   
   则需要证 : $b , r$ 的最大公约数也为 $c$ ,
   
   **即 :** $b=mc , r=(n-km)c$ 中 , $m,(n-km)$ 互质 。
     
     - 子证明：
       
       用反证法 , 设存在 $d$ 为 $m,(n-km)$ 的最大公约数，且 $d > 1$。
       
       设 : $n-km=qd$ , $m=pd$
       
       **则 :** $b = mc = pdc\ $ , 
       
       $\ a=kb+r=kpdc + qdc=dc(kp+q)$
       
       **则 :** $a$ 还存在一个因数 $dc > c$
       
       **此结论与$a,b$ 的最大公约数为 $c$ 相矛盾**
       
       **故 :** 不存在 $d>1$ 作为 $m,(n-km)$ 的最大公约数
       
       **则 ：** $m,(n-km)$互质 ，子证明成立。
   
   由子证明 ，得: $b=mc , r=(n-km)c$ 中 , $m,(n-km)$ 互质 。
   
   **则： $b$ 与 $r$ 的最大公因数仍为 $c$**
   
   证毕 。 
   
------------

- ###### 应用:

  有了以上的知识,我们便可以写出一个求$a,b$ 的 $gcd(a,b)$ 的函数了

  由 欧几里得定理可得 , 要通过递归来求得$gcd(a,b)$的值

  递归边界即: 当 $b=0$ 时，$gcd(a,b)=a$ ; 

  简单的代码实现:

```cpp
int gcd(int a,int b)
{
	if(b) 
      return gcd(b,a%b);
	else 
      return a;
}
```
  也可以写成一行：

```cpp
int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}
```

------------


## 2. 裴蜀定理:

 设 $a,b$ 为不全为 $0$ 的整数 , 则存在整数 $x,y$ ,使得 $\large ax + by = gcd(a,b)$ 。

特别地 , $gcd(a,b)=1$ $\Leftrightarrow$
存在 $x,y \in Z$ , 使: $ax+by = 1$ ;

那么该如何证明 定理的正确性 呢 ? 请继续往下看:


------------


## 3. 欧几里得扩展：

对于不完全为 $0$ 的两个数 $a,b$ ,必然存在 无限个$x,y$ ,使方程
$\large ax + by = gcd(a,b)$成立

- ###### 证明:
  设$a>b$

  1. 当$b=0 $时 , $gcd(a,b)=a$ ,此时有唯一的解 : $x=1,y=0$;

  2. 当$a\times b\not= 0$ 时 , 

  根据欧几里得定理 : $ gcd(a,b) = gcd(b,a\% b)$ , 可知:

  $\underline{ax + by }= gcd(a,b) = gcd(b,a\% b)=\underline{b {x1} + (a\% b) y1}$

  ( 设$x1,y1$是满足如上情况的一组解 )

  **而:**$a\% b = a-\lfloor \frac{a}{b}\rfloor \times b$

  **则:** 原等式可转化为:

    ①. $ax + by = bx1 + (a-\lfloor \frac{a}{b}\rfloor \times b)y1$

    ②. $ax + by = bx1 + ay1 -\lfloor \frac{a}{b}\rfloor by
1$

    ③. $ax + by = ay1 +b(x1-\lfloor \frac{a}{b}\rfloor y
1)$

  **由③，可得：**

  $x = y1$ 

  $y=x1- \lfloor\frac{a}{b}\rfloor  y1 $

  **这样** , 就可以得到 $ax+by = c$ 的一组解

  方程其他整数解 $xi,yi$ 满足 :

  $xi = x + \frac{b}{gcd(a,b)} \times t $

  $yi = y + \frac{a}{gcd(a,b)} \times t $

  其中 ， $t \in Z$

- ###### 代码实现

  要想写一个求解 $ax + by = gcd(a,b)$ 的程序

  通过以上的证明 , 显然 , 可以通过递归实现 

  递归边界即 : 当$b=0 $时 , $gcd(a,b)=a$ ,此时有唯一的解 :   $x=1,y=0$;

  代码：
    ```cpp
    int exgcd(int a,int b,int d,int &x,int &y) 
    {
	    if(!b) 
	      {
		    x=1 , y=0;
		    return a;
	      }
	    d=exgcd(b,a % b,x,y);
	    int tmp=x;
	    x=y , y=tmp-a/b*y;
    }
    ```
- ###### 求解不定方程:

  对于不定方程 : $ ax + by = c $ :

  根据 扩展欧几里得 , **可知 :**

  对于方程$ax + by = gcd(a,b)$ , 有无数组解 $x,y$.

  **则 :**

  1.若$ c\% gcd(a,b) \not= 0 $ , 则原方程无解。

  2.若$c \% gcd(a,b) = 0$ : 

  设$d = gcd(a,b)$ , **则原方程可转化为 :**

  $a\times (x\times \frac{d}{c}) + b\times (y\times \frac{d}{c}) =d (= c\times \frac{d}{c})$

  换元，使 $x1=(x\times \frac{d}{c})$ , $y1=(y\times \frac{d}{c})$;

  解方程: $ax1 + by1 = d$ , 有无数组解 $x1,y1$,

  求解出 $x1,y1$ 后 , **可得:**

  $x=x1 \times \frac{c}{d}$  ,  $y=y1 \times \frac{c}{d}$

  即可得到原方程 $ax + by = c$ 的解
  
------------


## 4.关于本题:

~~(啰嗦这么多终于开始说正事了)~~

- ##### 题目中的三种操作:
  ①将酒桶中的酒倒入容积为$b\ ml$的酒杯中；  
  ②将容积为$a\ ml$的酒杯中的酒倒入酒桶；  
  ③将容积为$b\ ml$的酒杯中的酒倒入容积为$a\ ml$的酒杯中。

- ##### 题意分析:
  设 **最后剩余的最小酒量** 为 $ans$   
  每次添加 $b\ ml$的酒 , 每次倒出 $a\ ml$ 的酒  
  
  **则有:**   
  $ans = -ax_1 + by_1  (x_1,y_1 \in Z) $
   
  欲使此不定方程有解  
  则 $ans =  k\times \gcd(a,b) \ (k\in Z)$  
  而要求 $ans$的 **最小非负整数解**  
  故$ans = gcd(a,b)$  
  
- ##### 算法实现:
   用扩展欧几里得  
   解不定方程 $\gcd(a,b) = ax_1 + by_1$   
   得到了 一组  $x_1$ 与 $y_1$ 的解  

   然后使 $x_1\times(-1)\ ,\ a\times(-1)$;    
   原方程转化为:  
   $\underline{ax_1 + by_1}  = (-a)\times(-x_1) + by_1 =  \underline{-ax + by}$  
   得到:  
   $x= -x_1$  
   $y=y_1$ 

   然后通过 
   ```cpp
	while(x<0 || y<0)
     x+= (x<0 )?b/gcd:0,
     y-= (x>=0)?a/gcd:0;
   ```
   
   将 $x,y$ 都转化为最小的非负整数解  
   即得答案 

------------
###### 附 $AC$ 代码
```cpp
#include<cstdio>
#include<ctype.h>
//====================================================
int a,b,x,y,gcd;
//====================================================
inline int read()
{
	int fl=1,w=0;char ch=getchar();
	while(!isdigit(ch) && ch!='-') ch=getchar();
	if(ch=='-') fl=-1;
	while(isdigit(ch)){w=w*10+ch-'0',ch=getchar();}
	return fl*w;
}
void exgcd(int a,int b)//扩展欧几里得求线性不定方程的解 
{
	if(b)
	{
	  	exgcd(b,a%b);
	  	int k=x;
	  	x=y , y=k-a/b*y;
	}
	else 
	  x=1,y=0,gcd=a;
	return ;
}
//====================================================
signed main()
{
	a=read(),b=read();
	exgcd(a,b);
	x*=-1,a*=-1;//进行转化 
	while(x<0 || y<0)//获得最小的非负整数解 
	  x+= (x<0 )?b/gcd:0,
	  y-= (x>=0)?a/gcd:0;
	
	printf("%d\n%d %d",gcd,x,y);
}
```
------------

---

## 作者：SoyTony (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P1292)

[前排广告](https://www.luogu.com.cn/blog/Tony-ZhuJialiang/)

# 前置知识——扩展欧几里得算法
用于求 $ax+by=\gcd(a,b)$ 解。
## 求一组可行解
由欧几里得算法得，$\gcd(a,b)=\gcd(b,a\bmod b)$

所以列含参方程得：
$$\begin{cases} ax_1+by_1=\gcd(a,b)\\bx_2+(a\bmod b)y_2=\gcd(b,a \bmod b)\end{cases}$$
于是有:
$$ax_1+by_1=bx_2+(a\bmod b)y_2$$
$$ax_1+by_1=bx_2+(a-\lfloor \dfrac{a}{b} \rfloor\times b)y_2$$
$$ax_1+by_1=ay_2+b(x_2-\lfloor \dfrac{a}{b} \rfloor\ y_2)$$

所以：$x_1=y_2,y_1=(x_2- \lfloor \frac{a}{b}\rfloor y_2)$，不断递归求解可以得到。
```cpp
inline int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,x,y);
    int t=x;
    x=y,y=t-a/b*y;
    return d;
}
```
对于上述的方程是一定有解的，并且存在一组 $(x,y)$ 满足 $|x|\le b,|y| \le a$，我们称其为**裴蜀定理**。
## 求任意一组通解
设已经求出的可行解为 $(x_0,y_0)$，带入到方程中有：
$$\begin{cases} ax_0+by_0=\gcd(a,b)\\ax+by=\gcd(a,b)\end{cases}$$
联立并整理得：
$$a(x_0-x)=b(y-y_0)$$
$$\dfrac{a}{\gcd(a,b)}(x_0-x)=\dfrac{b}{\gcd(a,b)}(y-y_0)$$
容易发现这个等式左右两边的前一个因式是互质的，因此后一个因式与前一个因式是对应整除关系（根据唯一分解定理可以得到），设这个商为 $k$，就有：
$$\begin{cases}x_0-x =\dfrac{b}{\gcd(a,b)}\times k\\\\y-y_0=\dfrac{a}{\gcd(a,b)}\times k\end{cases}$$
整理得到：$x=x_0-\frac{b}{\gcd(a,b)}\times k,y=y_0+\frac{a}{\gcd(a,b)}\times k$，其中 $k\in \mathbb{Z}$。
## 推广到不定方程
对于不定方程 $ax+by=c$，解决方式如下：

求解 $ax+by=gcd(a,b)$ 的一组解 $(x_0,y_0)$，同乘 $\frac{c}{\gcd(a,b)}$，就能得到不定方程的一组可行解 $(x,y)=(x_0\times\frac{c}{\gcd(a,b)},y_0\times \frac{c}{\gcd(a,b)})$，而我们把它代入到通解的式子中，得到最终的结果：
$$\begin{cases} x=\dfrac{c}{\gcd(a,b)}\times x_0- \dfrac{b}{\gcd(a,b)}\times k \\\\ y=\dfrac{c}{\gcd(a,b)}\times y_0+ \dfrac{a}{\gcd(a,b)}\times k\end{cases}$$
特别地，$x$ 的最小整数解为 $(x \bmod \frac{b}{\gcd(a,b)}+\frac{b}{\gcd(a,b)})\bmod\frac{b}{\gcd(a,b)}$

# 分析
下面我们来看这道题，可以得到如下一个式子：
$$a(-x)+by=c $$
设 $x_0=-x$，得到：
$$ax_0+by=c$$
当方程有解时，$\gcd(a,b)\mid c$，所以 $c$ 的最小值为 $\gcd(a,b)$，第一问套模板即可解决。

第二问的解决相对抽象，可以结合图像来研究：

![](https://cdn.luogu.com.cn/upload/image_hosting/id0qajou.png)

蓝色的直线表示 $-5x+3y=1$，记为 $l_1$；绿色的直线表示 $5x+3y=1$，记为 $l_2$，题目中的要求的是 $l_1$ 的最小整数解，即点 $B(x_1,y_1)$；我们所解的不定方程为 $l_2$，可能得到的一组解为点 $C$。

因为每一个 $x$ 都满足 $x=x_1-\frac{b}{\gcd(a,b)}\times k\ (k\in \mathbb{Z})$，所以我们可以找到 $l_2$ 的最小正整数解 $(x_2,y_2)$，再减去一个 $\frac{b}{\gcd(a,b)}$ 就得到了最大负整数解 $A(x_3,y_3)$（注意 $0$ 的特判），可以发现：$x1=-x3\ ,y1=y3$，按照如上思路运算即可。
# 实现
```cpp
inline ll exgcd(ll a,ll b,ll &x,ll &y){
    if(!b){
        x=1,y=0;
        return a;
    }
    ll d=exgcd(b,a%b,x,y);
    ll t=x;
    x=y,y=t-a/b*y;
    return d;
}
int main(){
    ll a=read(),b=read();
    ll x=0,y=0;
    ll d=exgcd(a,b,x,y);
    printf("%lld\n",d);
    x=(x%(b/d)+(b/d))%(b/d);
    if(x) x-=(b/d);
    y=(d-a*x)/b;
    printf("%lld %lld\n",-x,y);
    return 0;
}
```

---

## 作者：icefake (赞：10)

## 关于这一道题。。。

如果想仔细了解有关这一道题的数论知识，请转至其他dalao的题解区

我只是在看到这道题的时候，突然发现了一种对代码能力要求**极低**代码量也**“极少”**的做法

就是下面这几行：
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

int a, b, Min, n = 0, m = 0, tem, sum = 0;

signed main()
{
	scanf("%lld%lld", &a, &b);
	Min = __gcd(a, b);
	while(tem != Min) {
		if(tem < Min) {
			tem += b;
			sum += b;
		}
		else {
			tem -= a;
		}
	}
	m = sum / b;
	n = (sum - Min) / a;
	printf("%lld\n%lld %lld", Min, n, m);
	return 0;
}
```

整个代码只有一个 $while$ 而且运算也很简单，单纯的加或者减，然后凑出最小值

我本以为这道题就这。。。

结果。。。直到交完了才想起来，虽然数论题，但还是对时间有要求的 $QAQ$

这是我第一次提交的。。。
![](https://s1.ax1x.com/2020/06/09/tISOwq.png)

于是。。。为了能~~水~~完美地通过这道题，我加了快读：
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

int a, b, Min, n = 0, m = 0, tem, sum = 0;

inline int read(){
  	int x=0,w=1;char ch=0;
  	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
  	while(ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
  	return x*w;
}

signed main()
{
	a = read(); b = read();
	Min = __gcd(a, b);
	while(tem != Min) {
		if(tem < Min) {
			tem += b;
			sum += b;
		}
		else {
			tem -= a;
		}
	}
	m = sum / b;
	n = (sum - Min) / a;
	printf("%d\n%d %d", Min, n, m);
	return 0;
}
```

可是——还是这样了。。。
![](https://s1.ax1x.com/2020/06/09/tIpK6H.png)

然后我开了氧气—— $O_2$

果然，吸氧地效果十分显著。。。
![](https://s1.ax1x.com/2020/06/09/tIp6hT.png)
随后我又交了一次。。。时间还变长了。。。

~~毒瘤~~怎么能卡 $O_2$ 呢？

随后，我决定拿出终极武器——某优化，俗称：火车头

就是这个（雾
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
```

效果很好！！！非常 $nice$ ，即使不吸氧也过了！！！
![](https://s1.ax1x.com/2020/06/09/tI9Fgg.png)

## 总结
所以说，这篇题解讲的是~~如何用优化水过一道题~~欧几里得算法和裴蜀定理，嗯嗯嗯






---

## 作者：_Diu_ (赞：5)

这是一道数论题

刚刚学完扩欧的我就来做了这一题

然后就没有然后了

## 裴蜀定理

- 对于任意整数$a$,$b$，存在一对整数$x$,$y$，满足$ax+by=gcd(a,b)$

百度[此处](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fr=aladdin)有证明

既然得到了这个定理，那我们往后推一下

## 扩欧

- 当$b=0$时，显然有一对整数$x=1$,$y=0$，使得$a*1+0*0=gcd(a,0)$

- 当$b>0$时，我们可以用一下方法求特解

因为$gcd(a,b)=gcd(b,a\;mod\;b)$

所以存在$x,y,x',y'$满足

$ax+by=bx'+(a\;mod\;b)y'$

化简右边

设$d=a/b$（整除）

右边$=bx'+(a-d*b)y'$

$=bx'+ay'-bdy'$

$=ay'+b(x'-dy')$

我们就得到了一组特解

$\begin{cases}x=y'\\y=x'-dy'\end{cases}$

于是，我们就可以在递归求$gcd$的时候顺便求一下这一组特解

```cpp
int exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int d=exgcd(b,a%b,x,y);
	int tmp=x;
	x=y,y=(tmp-a/b*y);
	return d;
}
```

## 通解

既然有了特解，那么对于二元一次不定方程来说，肯定会有通解啦

$\begin{cases}x=x0+b/gcd(a,b)*t\\y=y0-a/gcd(a,b)*t\end{cases}$

其中$x0,y0$为其中一组特解，$t$为任意整数

## 最小正整数解

既然连特解都有了

那我们当然还要看一下最小正整数解

由通解得$x0$每次移动$b/gcd(a,b)$单位，最终使得$x0-b/gcd(a,b)*i>0$&&$x0-b/gcd(a,b)*(i+1)<0$。

当然，这个操作我们可以直接用取余来完成，即$x=x0$%$(b/gcd(a,b))$。

但是$x0$可能是负数

那么这个操作可以改成$x=(x0$%$(b/gcd(a,b)+b/gcd(a,b))$%$(b/gcd(a,b))$。

设$b/gcd(a,b)=L$

则$x=(x0$%$L+L)$%$L$


## 回归题目

如果上述芝士都能看懂的话

~~那么这一题就很简单了~~

我们可以看出两个瓶子之间的转换可以不用管

所以我们可以把这两个瓶子合成一个大瓶子

其中我们要装进去$ax_{ml}$，拿出$by_{ml}$，而使得这个瓶子内的剩余量最小

而这个最小值自然就是$gcd(a,b)$

则得到方程为$ax-by=gcd(a,b)$

我们只需要对这个方程求最小正整数解就好了

注意一下，这里中间是减法，所以我要把求玩的$x$变为原来的相反数

上代码

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,b,x,y;
int exgcd(int a,int b,int &x,int &y){
	if(b==0ll){
		x=1ll,y=0ll;
		return a;
	}
	int d=exgcd(b,a%b,x,y);
	int tmp=x;
	x=y,y=(tmp-a/b*y);
	return d;
}
signed main(){
	scanf("%lld%lld",&a,&b);
	int d=exgcd(a,b,x,y);
	a=-a,x=-x;
   	a=a/d,b/=d;
	while(x<0||y<0)x+=(x<0)*b,y-=(x>=0)*a;
	printf("%lld\n%lld %lld\n",d,x,y);
}
```

## 完结

---

## 作者：SymphonyOfEuler (赞：3)

这是一道扩欧好题。

我们想要最后a杯子里剩下较少的酒，并且b杯子为空。所以设最少剩下c毫升酒。 你一共倒进来Pb次，每次倒b毫升。然后倒出来Pa次，每次倒出来a毫升。所以你最后剩的酒的毫升数就为：

$b*Pb-a*Pa=c$

这个式子又可以推出：

$-ax+by=c$

我们求最小的$x$解，并且如果有解，那么$c=gcd(a,b)$。所以第一问就解答了。

但是我们观察刚刚的式子$-ax+by=c$长得很像扩展欧几里得不定方程的式子。所以我们用exgcd求出$ax+by=c$，然后输出负的x，还有正的y即可。

可以借助注释看代码。



```
#include <bits/stdc++.h>//万能头

using namespace std;

typedef long long ll;

// ax+by=gcd(a,b)

/* exgcd(a,b)
 *  exgcd(b,a%b) -> x',y';
 *  x=y'
 *  y=x'-a/b*y'
 *  return x,y
*/

ll exgcd(ll a, ll b, ll &x, ll &y) { //扩欧
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll x1, y1;
    ll g = exgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - a / b * y1; //the y in "by"
    return g;
}

int main() {
    ll a, b;
    cin >> a >> b;
    ll x0, y0, g = exgcd(a, b, x0, y0);//得到第一问答案
    cout << g << '\n';
  	//下面计算答案
    ll x = (x0 % (b / g) + (b / g)) % (b / g);
    if (x != 0) {
        x -= b / g;
    }
    ll y = (g - a * x) / b;
    cout << -x << ' ' << y << '\n';
    return 0;
}

```

扩欧题都不能只开int吧，这个题只要运算一下就爆int了，注意一下蛤。

---

## 作者：沧澜 (赞：3)

可以找规律：

**发现可以得到的酒的最小的容量是gcd(a,b)。**

那如果用gcd去模拟，看数据 0<a,b<1\*10^9，如果酒杯很小，就会TLE。

所以，转换思路。

我们发现可得公式：a\*Pa+b\*Pb=gcd(a,b)；这是ex\_gcd的公式。

所以本题的思路为ex\_gcd；

因为我们利用ex\_gcd所得到的pa,pb只是一组解，不一定是最小解，很多人50分就是忽略了这一点，我们还要额外求出最小解。

来，上代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int ex_gcd(int a,int b,int &x,int &y){
    if(b==0){
        x=1;
        y=0;
        return a;
    }
    int r=ex_gcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*x; 
    return r;
}
int main(){
    int x,y,a,b;
    cin>>a>>b;
    int gcd=ex_gcd(a,b,x,y);
    cout<<gcd<<endl;
    x*=-1;
    a*=-1;
    while(x<0||y<0){
        x+=b/gcd*(x<0);
        y-=a/gcd*(x>=0);
    }
    cout<<x<<" "<<y<<endl;
}
```

---

## 作者：BADFIVE (赞：2)

**思路**: 这道题很容易知道是欧几里得,就是求两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。  
**证明**: $a$ 可以表示成 $a = kb + r$（$a$，$b$，$k$，$r$ 皆为正整数，且 $r<b$ ），则 $r = a$ $mod$ $b$   
假设 $d$ 是 $a,b$ 的一个公约数，记作 $d|a,d|b$ ，即 $a$ 和 $b$ 都可以被 $d$ 整除。   
而 $r = a - kb$ ，两边同时除以 $d$ ， $r/d=a/d-kb/d=m$ ，由等式右边可知 $m$ 为整数，因此 $d|r$ 。  

因此 $d$ 也是 $b$,$a$ $mod$ $b$ 的公约数。   


因 $(a,b)$ 和( $b$,$a$ $mod$ $b$ )的公约数相等，则其最大公约数也相等。    
**原理**:若 $a,b$ 且 $a = bh + r$，其中 $h,r$，则 $\gcd(a,b)$ = $\gcd(b,r)$  

参考代码：   
```cpp
#include<bits/stdc++.h>
using namespace std;
int exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int tmp=exgcd(b,a%b,x,y);
	int t=x;
	x=y;
	y=t-a/b*x;
	return tmp;
}
int main(){
	int a,b,x,y;
	cin>>a>>b;
	int ans=exgcd(a,b,x,y);
	cout<<ans<<'\n';
	x*=-1,a*=-1;
	while(x<0||y<0){
		x+=b/ans*(x<0);
		y-=a/ans*(x>=0);
	}
	cout<<x<<" "<<y;
}
/*
5 3
1
1 2
*/
```


---


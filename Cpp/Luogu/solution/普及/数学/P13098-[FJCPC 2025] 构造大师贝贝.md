# [FJCPC 2025] 构造大师贝贝

## 题目描述

贝贝励志成为 FJ-ACM 中最强的构造选手，于是他每日苦练构造题。

为了检验贝贝的训练成果，宁宁同学提出了一道十分甚至九分困难的构造题来检验他的学习成果：

给定一个正整数 $n$，请在 $100$ 次操作以内，将其变为一个完全平方数。每次操作的内容为如下：

* 选择一个当前数字 $n$ 的约数 $x$，即 $n \bmod x = 0$；

* 每次选择的 $x$ 需跟之前**任何一次**选择的都不同；

* 随后让 $n$ 加上 $x$。

在整个操作过程中，$n$ 不允许超过 $10^{18}$。

这可难坏了贝贝，于是他找到了无比聪明的你来解决这个问题。

其中，$n \bmod x$ 表示 $n$ 除以 $x$ 的余数。

## 说明/提示

对于第 $1$ 个评测用例的说明如下：

- 因为 $2025=45\times 45$ 原本就是平方数，故无需操作。

对于第 $2$ 个评测用例的说明如下：

- 第一次操作：

  - 选择 $x=7$，数字 $7$ 是 $182$ 的因子；

  - 令 $n:=182+7=189$。

- 第二次操作：

  - 选择 $x=3$，数字 $3$ 是 $189$ 的因子且 $3$ 不在之前选择的数字集合 $\{7\}$ 中；

  - 令 $n:=189+3=192$；

- 第三次操作：

  - 选择 $x=4$，数字 $4$ 是 $192$ 的因子且 $4$ 不在之前选择的数字集合 $\{7,3\}$ 中；  

  - 令 $n:=192+4=196$；

  - $196=14\times 14$ 是完全平方数，结束。

其中 $:=$ 表示赋值符号。



## 样例 #1

### 输入

```
2
2025
182```

### 输出

```
0 
3
7 3 4```

# 题解

## 作者：fish_love_cat (赞：6)

我反正没做出来 /ng

[![](https://cdn.luogu.com.cn/upload/image_hosting/xdbv63n3.png)](https://cdn.luogu.com.cn/upload/image_hosting/yi5lyitz.png)

---

构造：每一次操作都增加 $\text{lowbit}(n)$ 即可。

---

为什么这是对的？

首先根据 $\text{lowbit}(n)$ 的意义，可以得到  $\text{lowbit}(n)\mid n$。

然后增加完 $\text{lowbit}(n)$ 会不断变大，最后就得到了 $n=2^k$。

此时至多再操作一次就可以让 $n$ 变成完全平方数。

最后的 $n$ 显然是不会大于 $2n$ 的。

操作次数是对数级别的，绝对不会超过 $100$。

做完了。

---

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int lowbit(int x){return x&(-x);}
void solve(){
    int n;
    cin>>n;
    vector<int>ans;
    while(((int)sqrt(n))*((int)sqrt(n))!=n){
        ans.push_back(lowbit(n));
        n+=lowbit(n);
    }
    cout<<ans.size()<<'\n';
    for(int i=0;i<ans.size();i++)cout<<ans[i]<<' ';
    if(ans.size())puts("");
}
signed main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

图片可以点哦。

---

## 作者：Zskioaert1106 (赞：3)

题目传送门：[P13098 构造大师贝贝](https://www.luogu.com.cn/problem/P13098)

### 做题过程

首先看到 $T\sqrt{n}$ 达到 $10^9$ 就基本明白解法跟 $n$ 没什么关系了，质因数分解可以走了。

然后众所周知，奇数一定有约数 $1$，所以我们一定可以把任意一个数变成偶数。

偶数一定有约数 $2$，所以我们一定可以把任意一个数变成 $4$ 的倍数。

就这样，我们可以把任意一个数在规定时间内变成 $2^{40}$ 的倍数。

此时 $\dfrac{n}{2^{40}}$ 小于 $\dfrac{10^{12}+2^{40}}{2^{40}} \approx 1+\dfrac{1}{1.09}$，所以这个 $n$ 一定得是 $2^{40}$——一个完全平方数。

综上，我们找出了小于等于 $40$ 次操作的方法。

### 代码实现

我们采取倍增的方法，从 $2^0$ 循环到 $2^{39}$，如果当前 $n$ 不是 $2^{i+1}$ 的倍数就让 $n$ 加上 $2^i$。

```cpp
#include<iostream>
using namespace std;
long long n,ans[101];
void solve(){
	int m=0;
	for(int i=0;i<40;i++){
		if(n%(1ll<<(i+1))){
			ans[++m]=(1ll<<i);
			n+=(1ll<<i);
		}
	}
	cout<<m<<'\n';
	if(m){
		for(int i=1;i<=m;i++)cout<<ans[i]<<' ';
		cout<<'\n';
	}
}
int main(){
	int t;
    cin>>t;
    while(t--){
    	cin>>n;
    	solve();
	}
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/222905214)。

---

## 作者：RAY091016 (赞：3)

### 1. 题意解释

给出一个数 $n$，每次你可以选择 $n$ 的一个因数 $m$，并使 $n=n+m$ 且 $m$ 不可重复，求如何使 $n$ 成为一个完全平方数。

### 2. 思路

主播赛时切掉了这道~~抽象的~~构造题来讲一下心路历程。

最开始时肯定会想到往最近的完全平方数靠。

然而这样我们会发现，有些数字是无法变成与其最接近的完全平方数的。

例子：$7$。

与 $7$ 最接近的完全平方数是 $9$，可你会发现没有办法使 $7$ 转化为 $9$。

主播本来这时候打算放弃了。

然而~~数竞的经历让~~主播想到了**分类讨论**和**整除性**。

我们考虑对 $n$ 分类讨论。

- $n\equiv1\pmod4$

我们让 $n$ 加上 $1$（这是显然可行的），此时 $n+1$ 是一个偶数（显然），再让其加上 $2$，此时变为 $n+3$，变成一个 $4$ 的倍数。

- $n\equiv2\pmod4$

直接让 $n$ 加上 $2$（显然可行）变为 $n+2$，依然化为 $4$ 的倍数。

- $n\equiv3\pmod4$

直接让 $n$ 加上 $1$（显然可行）变为 $n+1$，依然化为 $4$ 的倍数。

此时，对于所有 $n$ 都已化为 $4$ 的倍数，我们让 $n$ 除以 $4$，转化为 $n/4$。

不难发现这样的操作可以一直持续直到 $n$ 已成为一个完全平方数。

至于操作次数，最坏的情况是 $2\log_4n$，若 $100$ 次操作用完可以达到 $4^{50}$，大约是 $10^{31}$。

而操作过程中 $n$ 的最大值显然为 $4^{\left\lfloor\log_4n\right\rfloor+1}$，不会超过 $10^{18}$，因而此方法可行。

### 3. 代码实现

没什么特别难的地方，直接上主播的 code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,cnt;
vector<int>vec;
void solve(int x,int a){
	if(floor(sqrt(x))*floor(sqrt(x))==x){
		cout<<cnt<<endl;
		for(int i=0;i<vec.size();i++){
			cout<<vec[i]<<" ";
		}
		cout<<endl;
	}
	else{
		if(x%4==1){
			cnt+=2;
			vec.push_back(a);
			vec.push_back(2*a);
			solve((x+3)/4,a*4);
		}
		else if(x%4==2){
			cnt++;
			vec.push_back(2*a);
			solve((x+2)/4,a*4);
		}
		else if(x%4==3){
			cnt++;
			vec.push_back(a);
			solve((x+1)/4,a*4);
		}
		else{
			solve(x/4,a*4);
		}
	}
}
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		cnt=0;
		vec.clear();
		solve(n,1);
	}
	return 0;
}
```

---

## 作者：nbhs23a28 (赞：2)

又是一道小清新构造题。（~~赛时被黄题虐了 1h 寄！~~）

注意到数据范围 $n\le 10^{12}$ 且 $t\le 1000$，不难想到应用时间复杂度为 $O(\log n)$ 方式构造（$100$ 次内提示得够明显了吧）。由于每个 $n$ 的数论特性各不相同，故要找到数论角度通解相当困难，**考虑二进制拆分**。我们注意到，$2^{2k}$ 一定是完全平方数，而 $n$ 加上 $2^{\text{lowbit}(n)}$ 就能把 $n$ 最低二进制位搞定，这样逐级操作便能在 $\log$ 复杂度级内得到最终构造方案。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{int t;cin>>t;
 while(t--)
 {long long n;cin>>n;
  if((long long)sqrt(n)==sqrt(n))//n是完全平方数
  {cout<<"0\n";
   continue;
  }
 long long sum=1;
  vector <long long> v;
  for(int i=0;i<=63;i++)
  {if((long long)sqrt(n)==sqrt(n))
   break;
   if((n/sum)%2==1) //找到lowbit(n)
   {n+=sum;
    v.push_back(sum);
   }
   sum*=2;
  }
  cout<<v.size()<<'\n';
  for(int i=0;i<v.size();i++)
  cout<<v[i]<<' ';
  cout<<'\n';
 }
}

---

## 作者：Igunareo (赞：1)

## 思路
诈骗题目，一不留神就会去想质因数分解做法，然后就做烦了，还不知道到底能不能做出来。

显然，对于任何一个数 $x$，$\text{lowbit}(x)$ 一定是它的因数（不知道 $\text{lowbit}(x)$ 是什么的左转树状数组），所以可以不断加上 $\text{lowbit}(x)$，最后 $x$ 一定能变成 $2^{2m}$ 即 $2^{m^2}$，这是个完全平方数，然后就做完了。

易得增加次数不超过 $O(\log n)$，不到 $50$，完全可行，增加后判断是否为完全平方数即可。

## 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int lowbit(int u){return u&-u;}
int x[105];
signed main(){
	int T;
	scanf("%lld",&T);
	while(T--){
		int n,top=0;
		scanf("%lld",&n);
		for(int i=1;;i++){
			if((int)(sqrt(n))*(int)(sqrt(n))==n)break;
			x[++top]=lowbit(n);
			n+=lowbit(n);
		}
		printf("%lld\n",top);
		if(top){
			for(int i=1;i<=top;i++)printf("%lld ",x[i]);
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：swate114514 (赞：1)

我们可以用完全平方数的判定和二进制位运算的性质解决。

首我们定义函数 $\operatorname{is}(x)$ 来判断一个数是否为完全平方数，如果 $\left(\lfloor \sqrt{x} \rfloor\right)^2 = x$ 判定为真。

对于给定的正整数 $n$，如果 $\operatorname{is}(n)$ 为真，则直接返回无需操作；否则，我们通过一系列操作将其转化为完全平方数。每次操作选择 $n$ 的最低有效位，即  $\operatorname{lowbit} n$ 作为约数 $x$，这个值 $x$ 一定是 $n$ 的因数且未被使用过。将 $x$ 加入操作序列后，更新 $n$ 的值：

$$n \leftarrow n + x$$

并检查新的 $n$ 是否为完全平方数。这一过程最多重复 $100$ 次，若中途发现 $x$ 已被使用过或 $n$ 成为完全平方数则提前终止。最终输出操作次数及操作序列即可。

---

### Code
```cpp
#include <bits/stdc++.h>
#define qwq(i,a,b) for(int i=(a);i<=(b);++i)
#define qaq(i,a,b) for(int i=(a);i>=(b);--i)

using namespace std;

typedef long long ll;

bool is(ll x) {
	ll s = sqrt(x);
	return s*s == x;
}

ll lb(ll x) {
	return x& -x;
}

void solve() {
	ll n;
	cin >> n;
	vector<ll> op;
	unordered_set<ll> us;

	if (is(n)) {
		cout << "0\n";
		return;
	}

	qwq(st, 1, 100) {
		ll x = lb(n);
		if (us.count(x)) break;
		us.insert(x);
		n += x;
		op.push_back(x);
		if (is(n)) break;
	}

	cout << op.size() << '\n';
	
	qwq(i, 0, op.size() - 1) {
		if (i) cout << ' ';
		cout << op[i];
	}
	
	cout << '\n';
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);

	int T;
	cin >> T;
	while (T--) solve();
}
```

---

## 作者：Mortidesperatslav (赞：0)

一眼题。显然有个东西叫 lowbit。然后根据一些定义可以得到几个性质：

性质 $1$：一个数一定能被它的 lowbit 整除。

证明：考虑反证法。若一个数不能被 lowbit 整除，说明还有更低位，与 lowbit 的性质矛盾。于是得证。

性质 $2$：$2^{2n}$（$n \in \N$）是完全平方数。

证明：显然 $2^{2n}=(2^n)^2$。

性质 $3$：一直加 lowbit 一定会加到 $2^{2n}$。

证明：因为加 lowbit 一定会进位，最后 popcount 会变为 $1$，然后再加就相当于乘以 $2$ 了。

由二进制的性质，一直加加加是 $O(\log n)$ 次。

所以不停加 lowbit 就做完了。

我的场上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
long long n;
vector<long long> vec;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> t;
    while (t--){
        cin >> n;
        vec.clear();
        while (1){
            int tmp = sqrt(n);
            if (n == 1ll * tmp * tmp)
                break;
            vec.push_back(n & (-n));
            n += (n & (-n));
        }
        cout << vec.size() << "\n";
        for (auto u : vec)
            cout << u << " ";
        if (vec.size())
            cout << "\n";
    }
    return 0;
}
```

---

## 作者：pour_demain (赞：0)

根据题意不难想到 $lowbit(n)$ 是一定整除 $n$ 的。\
又根据 $lowbit(n)$ 可以想到用二进制构造，我们每次将 $n$ 加上 $lowbit(n)$ 直到 $n$ 为 $2$ 的偶数次幂，也就是完全平方数即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
#define int long long
int cnt[N];
signed main() {
	int T;
	cin >> T;
	while(T--){
		int n;
		cin >> n;
		if((int)(sqrt(n))*(int)(sqrt(n)) == n){//强制转换后小数会取整，除非sqrt(n)本身就是整数，即n为完全平方数，否则等式不成立
			cout << 0 << endl;
			continue;
		}
		else{
			int i=0;
			while((int)(sqrt(n))*(int)(sqrt(n)) != n){//同上
				i++;
				cnt[i]=n&(-n);//lowbit(n)写成位运算就是n&(-n)
				n += cnt[i];
			}
			cout << i << endl;
			for(int j = 1;j <= i;j++){
				cout << cnt[j] << ' ';
			}
			cout<<endl;
		}
	}
	return 0;
}
```

补充说明：\
$lowbit(n)$ 代表 $n$ 的二进制表达中从后往前第一个 $1$ 和后面的所有 $0$ 组成的数。

关于题目条件不难发现每次的 $lowbit(n)$ 一定是递增的，毕竟你都进位了最后一个 $1$ 肯定不在操作前的位置上了。

---

## 作者：itzxianfish (赞：0)

解法来自我同学当时赛后所述。

# 题解

由于多测要求 $T \le 1000$ 且 $n \le 10^{12}$，所以我们甚至不能使用复杂度为 $O(\sqrt{n})$ 的算法，只能试图考虑 $O(\log n)$。

考虑完全平方数实在是没有什么很好的性质，我们转为考虑把完全平方数固定为 $4^n$，显然 $4^n$ 在 $n$ 是自然数的情况下保证是完全平方数。

为什么要这样？

因为这样我们就可以启用二进制的思想，接下来这一步神来之笔就是我同学告诉我的。

以数字 $13$ 为例，二进制为 $1101_{(2)}$，有一个非常强悍的性质就是：**对于数字 $k$，$lowBit(k)$ 是 $k$ 的一个约数**。没错，就是树状数组的那个 $lowBit$  函数。于是 $13 = 1101_{(2)} \to 13 + lowBit(13) = 1110_{(2)} \to 14 + lowBit(14) = 10000_{(2)} = 16$ 成为完全平方数。

上述循环对于构造一个 $4^n$ 是完全没问题的，但是题目要求我们构造的数字不能超过 $10^{18}$ 且不操作超过 $100$ 次，接下来我们分析会不会被这些限制。

首先 $10^{12}$ 接近但是小于 $2^{40}$，不妨突破题目给的限制，取 $2^{41} + 1$ 也就是 $100...0001$ 这样。按照我们的构造规则，$2^{41} + 1$ 构造结果是 $2^{42}$ 不会超过范围。

为什么要取 $100...0001$ 来分析呢？

首先，这个数字超过 $n$ 的最大取值，要是这个数字不会导致超出范围，那么 $n$ 以内的数字就能保证正确，其次，在我们的构造规则下，$100...0001$ 的变换，需要加上 $\sum_{i=0}^n 2^i = 2^{n+1} - 1$ 是一个已经需要“加满”的状态了，在一般任意一个 $01$ 交错的二进制数字下，不断取 $lowBit$ 是不会加满的，所以对于任意 $n \le 10^{12}$，这个构造规则不存在会超过 $10^{18}$ 的情况。

第二个限制就是次数了，其实我们考虑一下，还类似于 $100...0001$，最坏的时候也就是相当于遍历了一遍二进制位，所以不会超过 $100$ 次，同时，这也说明了时间复杂度是 $O(\log n)$ 的，对于多测是 $O(T\log n)$，不会超时。

综上，本题核心代码如下。

# Code


```cpp
void solve() {
    tot = 0;

    cin >> n;
    while (ceil(sqrt(n)) * ceil(sqrt(n)) != n) {
        a[++tot] = n & -n;
        n += n & -n;
    }

    if (tot == 0)
        cout << 0 << "\n";
    else {
        cout << tot << "\n"
        for (int i = 1; i <= tot; i++)
            cout << a[i] << " \n"[i == tot];
    }
    
}
```

补充，其实 while 的判断语句也可以写成位运算加取模判断 $4^n$，结果一样但是常数会小一些，然后上面贴出来的可以避免输入的 $n$ 就是一个完全平方数，如样例的 $2025$。

---


# [GCJ 2016 Qualification] Revenge of the Pancakes

## 题目描述

无限煎饼屋刚刚推出了一种新型煎饼！煎饼的一面用巧克力豆装饰成了笑脸（称为“开心面”），另一面则什么都没有（称为“空白面”）。

你是当班的首席服务员，厨房刚刚给你一摞煎饼，准备让你端给顾客。作为一名优秀的煎饼服务员，你拥有 X 光煎饼视力，可以看清堆中每一张煎饼朝上的是开心面还是空白面。你认为如果每一张煎饼在端给顾客时都是开心面朝上，顾客会最开心。

你掌握如下操作：小心地从煎饼堆顶取出若干张（可能全部），将这一组整体翻面，然后再放回剩下的煎饼上方。翻动一组煎饼时，整个组会被整体翻转，而不是单独翻转每一张。形式化地说：如果我们将煎饼从上到下编号为 $1,2,\ldots,N$，你可以选择翻转最上面的 $i$ 张。翻转后，堆的顺序变为 $i,i-1,\ldots,2,1,i+1,i+2,\ldots,N$。编号 $1,2,\ldots,i$ 的煎饼现在朝上的面会变成原来的反面，而 $i+1,i+2,\ldots,N$ 的煎饼则保持原状。

例如，我们用 `+` 表示开心面朝上，用 `-` 表示空白面朝上。假设从顶到底的煎饼堆为 `--+-`。一种可行操作是取出最上面的三张，整体翻转后放回剩下的第四张上方（第四张保持不变）。此时堆的新状态为 `-++-`。其他合法操作包括只翻最上面的一张、最上面两张或全部四张。不合法的操作包括只翻中间两张或只翻最底下一张，因为你只能从顶部开始取若干张。

只有当所有煎饼都是开心面朝上时，你才会端给顾客，但你不想让煎饼变冷，所以你必须尽快行动！请问，要让所有煎饼都变为开心面朝上，最少需要执行多少次上述操作？

## 说明/提示

**样例解释**

在第 1 组中，你只需操作一次，翻转唯一的一张煎饼。

在第 2 组中，你只需操作一次，只翻转最上面的一张煎饼。

在第 3 组中，你需要操作两次。最优解是先翻转最上面的一张，使堆变为 `--`，然后再翻转全部两张，使堆变为 `++`。注意你不能只翻最下面的一张来一步达成目标；每次操作都必须从顶部开始取连续若干张。

在第 4 组中，所有煎饼已经全部开心面朝上，无需任何操作。

在第 5 组中，一种可行方案是：先翻转全部煎饼，得到 `+-++`，再翻转最上面一张，得到 `--++`，最后翻转最上面两张，得到 `++++`。

**限制条件**

- $1 \leqslant \mathrm{T} \leqslant 100$。
- $\mathbf{S}$ 中每个字符均为 `+` 或 `-`。

**小数据集（10 分，测试集 1 - 可见）**

- $1 \leqslant$ $\mathbf{S}$ 的长度 $\leqslant 10$。

**大数据集（10 分，测试集 2 - 隐藏）**

- $1 \leqslant$ $\mathbf{S}$ 的长度 $\leqslant 100$。

翻译由 GPT4.1 完成。

## 样例 #1

### 输入

```
5
-
-+
+-
+++
--+-```

### 输出

```
Case #1: 1
Case #2: 1
Case #3: 2
Case #4: 0
Case #5: 3```

# 题解

## 作者：chunzhenII (赞：3)

## 简述题意
有 $n$ 个煎饼，有的开心面朝上，有的空白面朝上，我们每次操作可以让上面的一些煎饼翻转，问最少多少次能让全部煎饼都开心面朝上。  
## 思路
我们要让煎饼全部变成开心面朝上，就只能从右往左把煎饼都扫一遍，遵循自上而下的逻辑，如果碰到空白面就把它和它上面的煎饼全部翻转，然后记一下次数就可以了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,l;
signed main(){
	cin>>t;
	while(t--){
		string s;
		int cnt=0;
		l++;//第l轮询问 
		cin>>s;
		for(int i=s.size()-1;i>=0;i--){
			if(s[i]=='-'){//如果碰到了空白面 ，把它和它上面的全部翻转 
				cnt++;
				for(int j=0;j<=i;j++){//遍历它及它上面的所有煎饼 
					if(s[j]=='+'){//开心面变空白面 
						s[j]='-';
					}
					else{//空白面变开心面 
						s[j]='+';
					}
				}
			}
		}
		cout<<"Case #"<<l<<": "<<cnt<<"\n";
	}
	return 0;
} 
```

---

## 作者：zhouxiaodong (赞：3)

# 思路
若当前饼堆底部煎饼是 `-`，那么就要翻转一次，将其翻至顶部，在处理剩下的煎饼。

从左往右遍历字符串，当一个字符与前一个不相同是，做一次翻转操作。不过会出现一种例外，如果最后一个是 `-`，那我们需要额外进行一次操作。
# AC Code
``````````cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
signed main()
{
	cin>>n;
	for (int i=1;i<=n;++i)
	{
		string s;
		cin>>s;
		cout<<"Case #"<<i<<": ";
		int k=0;
		int len=s.size();
		for(int i=0;i<len-1;++i)
		{
			if(s[i]!=s[i+1])
			{
				k++;
			}
		}
		if(s.back()=='-')
		{
			k++;
		}
		cout<<k<<"\n";
	}
	return 0;
}
``````````

---

## 作者：zhongjunnan561234 (赞：1)

# 题意
现有 $n$ 个煎饼，初始时有些煎饼的开心面朝下。每次操作可以选择一个煎饼，并将其上方的所有煎饼翻转（即空白面和开心面互换）。最少需要多少次操作才能使所有煎饼的开心面朝上？
# 思路
我们必须采用从右到左的遍历方向才能正确实现自上而下的翻转逻辑。具体来说，当当前字符是'-'时，翻转该字符及它之前的所有字符。
# AC Code
```
#include <bits/stdc++.h>
using namespace std;
// 翻转前 j 个煎饼的状态
void flip(string &s,int j) {
    for (int i=0;i<=j;i++) 
        s[i]=(s[i]=='+')?'-':'+';
}
int main() {
    int t; // 测试用例数量
    cin>>t;
    for (int i=1;i<=t;i++) {
        string s;
        cin>>s;
        int t=0; // 记录翻转次数
        
        // 从右往左遍历，遇到 '-' 就翻转前面的所有煎饼
        for (int j=s.size()-1;j>=0;j--) {
            if (s[j]=='-') {
                t++;
                flip(s, j);
            }
        }
        
        cout<<"Case #"<<i<<": "<<t<<endl;
    }
    
    return 0;
}
```

---

## 作者：__coderyc__ (赞：1)

## 思路
一道思维题，发现算法标签中有数学二字，又观察到每张饼只有两种状态，不妨从**奇偶性**开始思考。

一张饼就相当于二进制中的一位，如图：
![饼的状态](https://cdn.luogu.com.cn/upload/image_hosting/32x1engx.png)

每一次翻转操作都会对整摞饼产生影响，那我们不妨将翻转次数**累计**起来，所以我们可以**从下往上**来看。但是这个性质怎么找出来呢？

让我们看一下样例中的可以利用的数据：
![样例](https://cdn.luogu.com.cn/upload/image_hosting/x4ale9ad.png)
仔细观察可以发现，当我们从下往上时，满足这两条中一条，才能翻转（也就是翻转次数加一）：

- 当前的遍历位置是 `-` 且翻转次数为**偶数**（处理的时候视为 `-` ）。
- 当前的遍历位置是 `+` 且翻转次数为**奇数**（处理的时候**也**视为 `-` ）。

所以真实的这个样例处理是这样的：
![样例全部](https://cdn.luogu.com.cn/upload/image_hosting/gdse45do.png)

复杂！但我也是手模了好几次样例才搞出来判定方式，代码很简单，但是性质摸索。。。麻烦点一下赞把，谢谢。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char S[101];
int T,flips,len;
int main() {
    cin>>T;   
    for(int t=1;t<=T;++t){
        flips=0;
        cin>>S;
        len=strlen(S); 
        for(int i=len-1;i>=0;--i){
            if((S[i]=='-'&&(flips%2==0))||(S[i]=='+'&&(flips%2==1))){
                flips++; 
            }
        }
        cout<<"Case #"<<t<<": "<< flips<<endl;
    }
    return 0;
}
```
谢谢观看！！！

---

## 作者：Zjb13927701829 (赞：1)

# P13186 Revenge of the Pancakes 题解
[题目传送门](https://www.luogu.com.cn/problem/P13186)
## 先看题目：
题目给我们一个字符串（只包括`+`或`-`），让我们做如下改动：
- 从字符串顶取出若干字符（可能全部），将这一组整体翻转（`+`$\gets$`-`、`-`$\gets$`+`），然后再放回剩下的字符串上方。
- 注意：翻动一组字符时，整个组会被整体翻转，而不是单独翻转每一个。
- 最后要用最少的步数使整个字符串全部变成`+`。
## 解题思路：
~~看起来简单，想起来难，想出来又简单~~\
从下往上（也就是从右往左）遍历字符串，如果当前字符 $S_i$ 为`-`就从字符串顶取出 $i$ 个字符进行翻转。示例过程如下表：


|层数\\改动次数|0（原串）|1|2|
|:-:|:-:|:-:|:-:
|1|`+`|`-`|`+`|
|2|`+`|`-`|`+`|
|3|`-`|`+`|`+`|
|4|`-`|`+`|`+`|
|5|`+`|`+`|`+`|

## AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int t;
void turn(int n){//翻转函数
    for(int j=n;j>=0;j--)
        s[j]=(s[j]=='-')?'+':'-';
}
int main(){
    cin>>t;
    for(int cl=1;cl<=t;cl++){
        int ans=0;
        cin>>s;
        for(int i=s.size();i>=0;i--){//倒序遍历
            if(s[i]=='-'){
                ans++;
                turn(i);
            }
        }
        printf("Case #%d: %d\n",cl,ans);
    }
    return 0;
}
```

---

## 作者：Fennec (赞：0)

## 题目分析：
想象你的面前有一摞煎饼，每张煎饼有两个面，一面是开心的（用 "+" 表示），一面是不开心的（用 "-" 表示），现在要把所有煎饼都变成开心朝上，而且翻动的次数要最少。

**翻动规则：** 每次可以从最上面拿起任意数量的煎饼，整叠翻过来再放回去。

## 解题思路：
其实这是有规律的，我们可以分为两步。

1. 给煎饼分组，把连续相同的分为一组。如果相邻的不一样就得分开算一组。
2. 看最后一组，如果 最后一组是 "-"，那最少次数就是分组数，如果最后一组是 "+" 那最少次数就是分组数 $-1$。

**规律的原理：** 因为每一组不同的面，都需要至少一次翻动才能统一。而最后一组如果已经是 "+"，就不用再翻它了。

## 代码部分：
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
int t , ans , sum;
string s;
char l;
signed main () {
    cin >> t;
    for (int i = 1;i <= t;i ++){
    	cin >> s;
    	ans = 1;
    	for (int j = 1;j < s.size();j ++) {
			if(s[j] != s[j - 1])
				ans ++;		
		}
		l = s[s.size() - 1];
		if(l == '-') sum = ans;
		else sum = ans - 1;
		cout << "Case #" << i << ": " << sum << endl; 
	}
    return 0;
}
```

---

## 作者：dhy_2014 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13186)

## 题目大意
给了你一个 $01$ 串，你可以定一个前缀，对此区间内的所有数取反，问最少要取反几次。
## 思路
我们考虑贪心的做法，把这个 $01$ 串倒着遍历一遍，如果当前数是 $0$，那么把第 $1$ 位到第 $i$ 位取反，以此类推，然而你改变前面的字符不会影响后面的字符，所以这种方案一定是最优的。

废话不多，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s;
int main(){
    cin>>t;
    for(int o=1;o<=t;o++){
        int cnt=0;
        cin>>s;
        int n=s.length();
        for(int i=n-1;i>=0;i--){//倒着遍历 
            if(s[i]=='-'){
                cnt++;//如果是空白面就次数加一 
                for(int j=0;j<=i;j++){//开始取反 
                    if(s[j]=='+'){
                        s[j]='-';
                    }
                    else{
                        s[j]='+';
                    }
                }
            }
        }
        cout<<"Case #"<<o<<": "<<cnt<<'\n';
    }
    return 0;
}
```

---

## 作者：weiyc1 (赞：0)

## 问题分析
这个问题是关于翻转煎饼使所有煎饼都变成开心面朝上的最少操作次数。关键要点：

1：每次操作只能从顶部取连续若干张煎饼整体翻转。

2：翻转后，这组煎饼的顺序会颠倒，且每张煎饼的正反面都会翻转。

3：目标是用最少的操作次数让所有煎饼都变成开心面朝上（+）。

观察可知，煎饼的状态变化有一定规律：连续相同状态的煎饼可以作为一个整体处理，每次翻转操作可以改变顶部连续一组煎饼的状态和顺序。

## 算法思路
1：从煎饼堆底部向上观察，记录状态变化的次数。

2：每遇到一次状态变化（从 + 到 - 或从 - 到 +），就需要增加一次操作。

3：如果最底部的煎饼是空白面（-），还需要额外加一次操作。

这种思路的依据是：每次翻转可以处理一组连续相同状态的煎饼，状态变化的次数直接对应所需的操作次数。
## AC代码
```
#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    cin >> T;
    for (int t = 1; t <= T; ++t) {
        string s;
        cin >> s;
        int n = s.size();
        int res = 0;
        char last = '+';  // 初始假设最后一个状态是+
        // 从底部向上检查状态变化
        for (int i = n - 1; i >= 0; --i) 
            if (s[i] != last) {
                res++;
                last = s[i];
            }
        cout << "Case #" << t << ": " << res << endl;
    }
    return 0;
}
```

---

## 作者：_aszxqw_ (赞：0)

这是一道比较简单的贪心，就是让我们把饼全部变成 `+` 就可以了。我们可以从饼的底部开始检查每个饼的状态，因为翻转会影响顶部连续的饼，所以从底部开始可以确保每次翻转后，下方的煎饼状态不会被后续破坏。至于反转，直接用一个变量就可以了，先定义一个 char 类型的变量 $\operatorname{bing}$ 把它赋值为 `+` 之后从下往上检查，如果当前状态和 $\operatorname{bing}$ 不符，就反转，$\operatorname{bing}$ 也取反（`+` 变 `-` 或者 `-` 变 `+`），因为翻转会改变上方所有煎饼的状态。

## AC 代码

```
#include <bits/stdc++.h>
using namespace std;
int main() {
    int tt; 
    cin >> tt;
    for (int t = 1; t <= tt; ++t) {
        string s; 
        cin >> s; 
        int n = s.size(); // 饼的高度
        int cnt = 0; // 初始化
        char bing = '+'; // 初始化
        for (int i = n - 1; i >= 0; i--) {
            if (s[i] != bing) {
                cnt++; // 需要执行一次翻转操作
                bing = bing == '+' ? '-' : '+'; // 切换目标状态
            }
        }
        cout << "Case #" << t << ": " << cnt << '\n';
    }
    return 0; 
}
```

---

## 作者：IkillDream (赞：0)

# P13186 题解

## 思路

通过观察，不难发现每次翻转操作会影响从顶部开始的连续煎饼。我们为了使操作次数最少，应该从底部开始处理煎饼。每当遇到一个煎饼的状态与目标状态（全开心面朝上）不一致时，就需要翻转从顶部到该煎饼的所有煎饼。这样，每次翻转可以解决至少一个煎饼的状态问题。

## AC 方法

将初始化目标状态为全 $+$，当前状态为输入字符串。

从底部开始检查每个煎饼的状态：

如果当前煎饼的状态与目标状态不一致，则需要翻转从顶部到该煎饼的所有煎饼。

每次翻转会增加操作次数，并更新当前状态。

最终，所有煎饼都会变成 $+$，操作次数即为答案。

## [AC](https://www.luogu.com.cn/record/224521636) 代码

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    int t;
    cin >> t;
    for (int tc = 1; tc <= t; tc++) {
        string s;
        cin >> s;
        int n = s.size();
        int arr[105];
        for (int i = 0; i < n; i++)
            arr[i] = (s[i] == '+') ? 1 : 0;
        int ans = 0;
        int kkk01 = 1;
        for (int i = n - 1; i >= 0; i--)
            if (arr[i] != kkk01) {
                ans++;
                kkk01 = 1 - kkk01;
            }
        cout << "Case #" << tc << ": " << ans << endl;
    }
    return 0;
}
```

---

## 作者：Hkb150429 (赞：0)

## 题意
现有 $n$ 个饼，每个有空白面和开心面，但现在有一些没有开心面朝上，问几次才能把 $n$ 个饼都开心面朝上。

## 易错点

我做了 3 次。第 1 次我天真的以为只要把字符串组倒过来判断就可以了，结果可想而知。

[第 1 次尝试。](https://www.luogu.com.cn/record/223766021)

第 2 次我猜是 $j$ 的问题，但改成了的结果依旧是 0 分。

[第 2 次尝试。](https://www.luogu.com.cn/record/223766021)

第 3 次我终于发现是局部变量的缘故（警示后人）。

[第 3 次尝试。](https://www.luogu.com.cn/record/223773874)

## 思路

我们**必须**从右往左遍历字符串，不然就不符合要从上到下翻，所以如果当前字符为`-`就翻转这个字符和它左边的所有字符。

## AC code

```
#include<bits/stdc++.h>
using namespace std;
int t,cnt;
string s;
void zhuan(int j){
    for(int i=j-1;i>=0;i--){
        if(s[i]=='+')s[i]='-';
        else s[i]='+';
    }
}
int main(){
    cin>>t;
    for(int i=1;i<=t;i++){
        cnt=0;
        cin>>s;
        for(int j=s.size()-1;j>=0;j--){
            if(s[j]=='-'){
                cnt++;
                zhuan(j);
            }
        }
        cout<<"Case #"<<i<<": "<<cnt<<endl;
    }
    return 0;
}
```

---


# 足球

## 题目描述

我们当中有很多热爱中国足球的同学，我们都知道中超（中国足球超级联赛）的规则：

一场比赛中，若获胜（即你的得分严格大于对手得分）则获得 $3$ 的积分，若打平（即你的得分等于对手得分）则获得 $1$ 分，若失败（即你的得分严格小于对手得分）获得 $0$ 积分。

这个问题很简单，假设 $N$ 轮比赛中你一共攻入 $S$ 个球，丢掉 $T$ 个球，那么你可能获得的最大得分和最小得分是多少？

## 样例 #1

### 输入

```
1 1 1
1 1 2```

### 输出

```
1 1
3 2
```

# 题解

## 作者：艮鳖肉 (赞：57)

首先，我是一个球迷，常年观看中超联赛，所以看到这道题就格外亲切。     
### 求最大得分的思路：                                              
在比赛 n 场的前提下，肯定是赢得越多越好，想要赢得多，核心思想就是节省进球数，浪费丢球数，分为下面两种情况：                                                      
#### (1)进球数小于比赛场数，即 s < n.
既然要节省进球数，浪费丢球数，那么就索性赢 s 场 1：0，把所有丢球都丢在同一场，也就是输一场 0： t 。这时最多赢 s 场，最少输一场，所以平局数就是 n - s - 1 场，积分就是 3s + n - s - 1。但是有一种特殊情况，就是当 t == 0 时，输的那场 0 : t 其实是平局，所以当 t == 0 时，积分要 + 1 。  
#### (2)进球数大于等于比赛场数，即 s >= n.   
此时我们还是要浪费丢球数，把所有丢球都丢在同一场，因为 s >= n ，所以赢 n - 1 场 1 ：0 是没问题的，积分就是 3(n - 1)。赢完之后我们还剩下 s - (n - 1) 个进球，最后一场我们将剩下的进球数与丢球数比较，如果进球数大于丢球数，那么最后一场就能赢，积分 + 3；如果进球数等于丢球数，那么最后一场就是平局，积分 + 1；如果进球数小于丢球数，那么最后一场就会输，积分不变。
### 求最小得分的思路：
求最小得分时，不能简单地说输得越多越好，因为赢一场输一场是 3 分，平两场却是 2 分，所以求最小得分时，要比较赢一场，剩下所有场次都不赢，和所有场次都不赢的最小值，也分为下面两种情况。
#### (1)进球数大于丢球数，即 s > t.    
遇上这种情况，想一场不赢是不可能的，哪怕全是平局，也还有剩余的进球数。所以我们只能让他赢一场 s : 0 ，通过这场球把所有进球数都消耗掉，
积分变为 3 分。剩下的 n - 1 场再输 t 场 0 ：1， 如果 t >= n - 1，那么我们就可以做到剩下的 n - 1 场全输，积分就是 3 分；如果 t < n - 1，那么剩下的 n - 1 - t 场就只能是平局，这时积分就是 3 + n - 1 - t.
#### (2)进球数小于等于丢球数，即 s <= t.
这时我们终于有了所有场次都不赢的可能。因为要节省丢球数，所以每场比赛的丢球数都只比进球数多 1 个，输球场次就是 (s - t) 场，如果 (s - t) >= n，那么所有场次全输，积分就是 0，如果 (s - t) < n，那么剩下的 n - (s - t) 场就是平局，积分就是 n - (s - t).  
另一种可能就是上一种情况里说的，赢一场，剩下的场次一场不赢，最后在这两种情况里取最小值就可以了。
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
	long long mx, mn, s, t, n;
	while(~scanf("%lld %lld %lld", &s, &t, &n))
	{
		mx = mn = 0;
		if(s < n)
		{
			mx += s * 3;
			mx += n - s - 1;
			if(!t)
				mx++;
			printf("%lld ", mx);
		}
		else
		{
			mx += (n - 1) * 3;
			if(s - (n - 1) > t)
				mx += 3;
			else if(s - (n - 1) == t)
				mx++;
			printf("%lld ", mx);
		}
		if(s > t)
		{
			mn += 3;
			if(t < n - 1)
				mn += n - 1 - t;
			printf("%lld ", mn);
		}
		else
		{
			long long a = 3, b = 0;
			if(t < n - 1)
				a += n - 1 - t;
			if(n > t - s)
				b = n - (t - s);
			printf("%lld ", min(a, b));
		}
		printf("\n");
	}
	return 0;
}
```

---

## 作者：quantum11 (赞：53)

首先先说这题其实并没有紫题的难度...代码很短

熟悉足球的人应该做这题会比较轻松

两个答案分别分类讨论：

$1.$
如果进的球比场次少，那么最多只能胜$s$场，剩下的平局，最后一场看是否有丢球（丢球全在同一场）；否则，前$n-1$场都进一球，比较最后一场的进球和丢球数，$min(n,s-t)$表示进球更多时取$n$，表示$n$场全胜。

$2.$
如果进球数大于丢球数，那么至少胜一场，剩下的都是平或负（进球全在同一场）；否则，取只胜一场和全为平或负的积分较小值。

不开$long$ $long$最后一个点会$WA$

```
#include<bits/stdc++.h>
using namespace std;
long long s,t,n;
int main(){
	while(~scanf("%d%d%d",&s,&t,&n))
	printf("%lld %lld\n",s<n?3*s+n-s-1+!t:3*max(n-1,min(n,s-t))+(s-t==n-1),
		s>t?3+max(0ll,n-t-1):min(3+max(0ll,n-t-1),max(n-t+s,0ll)));
	return 0;
}
```

---

## 作者：George1123 (赞：23)

**广告：[blog$\spadesuit$](https://www.luogu.com.cn/blog/Wendigo/)**

[P1326 【足球】](https://www.luogu.com.cn/problem/P1326)

### 此题算法：无

难度虚高？没有，我 $WA$ 了 $20$ 次。

## 直接看代码 $+$ 注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define lng long long
lng s,t,n;
void solve(){
	if(n==1){  //必须特判--只有一局
		if(s>t) puts("3 3");  //赢
		else if(s<t) puts("0 0"); //输
		else if(s==t) puts("1 1"); //平
		return;
	}
	//最高分
	if(s>=n){ //分类-赢得尽量险
		if(s-(n-1ll)>t) printf("%lld ",3ll*n); 
		//每局赢
		else if(s-(n-1ll)==t) printf("%lld ",3ll*(n-1ll)+1ll);
		//(n-1)局赢，1局平
		else if(s-(n-1ll)<t) printf("%lld ",3ll*(n-1ll));
		//(n-1)局赢，1局输-把输的输在同一局
	} else { //分类
		if(t==0ll) printf("%lld ",3ll*s+(n-s));
		//s局赢，(n-s)局平
		else printf("%lld ",3ll*s+(n-1ll-s));
		//s局赢，(n-s-1)局平，1局输
	}
	//最低分
	if(t>=n){ //分类，输得尽量险
		if(t-(n-1ll)>s) printf("%lld\n",0ll); //全输
		else if(t-(n-1ll)==s) printf("%lld\n",1ll);
		//(n-1)局输，1局平
		else if(s-t+(n-1ll)<=1ll) printf("%lld\n",2ll);
		//(n-2)局输，2局平--比一局赢更优惠
		else if(s-t+(n-1ll)>1ll) printf("%lld\n",3ll);
		//(n-1)局输，1局赢
	} else { //分类
		if(s==0ll) printf("%lld\n",(n-t));
		//t局输，(n-t)局平
		else if(s<=2ll){ 
			if(t>=s) printf("%lld\n",s+n-t);
			//s局1-1平，n-t局0-0平，剩下的输
			else printf("%lld\n",3ll+n-1ll-t);
			//1局赢，(n-1-t)局平，t局输
		} else printf("%lld\n",3ll+n-1ll-t);
		//1局赢，(n-1-t)局平，t局输
	} 
}
int main(){
	while(~scanf("%lld%lld%lld",&s,&t,&n)) solve();
	//多组输入用~scanf()
	return 0;
}
```
做法和别人不同，但更清晰一些，甚至没有 $min$ 和 $max$ 函数。

**写题解不易，为它点个赞吧。**

谢谢大家! !


---

## 作者：Ousmane_Dembele (赞：17)

来自蒟蒻的纯暴力算法……

这种算法的优点是时间空间复杂度可以巨轻松的过，弱点是需要考虑的地方太多，容易遗漏，修改代码特别慢……

实在想不到其他的算法了……

总体来说这个题解还是比较容易看懂的……

希望大家不要抄

自己写写很有乐趣。

在后我还将附上一些易错点

希望能帮助到大家

代码大意：暴力枚举，不停if else语句，把每一种可能性都计算在内

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int main(){
    long long s,t,n;//不long long可能会爆，最好不要冒这个险。
    while(cin>>s>>t>>n){//在循环里输入
        long long best=0;//最好值
        long long worst=0;//最差值
        if(n==1){//特判当只有一场比赛的时候
            if(s>t)//进的球比输的球多
               cout<<"3 3"<<endl;//必胜
            if(s==t)//进的球和输的球一样多
               cout<<"1 1"<<endl;//逼平
            if(s<t)//进的球比输的球少
               cout<<"0 0"<<endl;//必败
               continue;//结束
        }
        if(s==0&&t==0){//特判二：当所有比赛中都没进球也没丢球
            cout<<n<<" "<<n<<endl;//每场比赛都一定会平
            continue;//结束
```
}//这些特判为后面打下了良好基础
```cpp
        if(s>=n){//进的球比一共的比赛多
             if(t){//对方有进球
                  if(s-n>=t)//可以每场赢一球
                     best=3*n;//全胜
                  else if(s-n+1==t)//只有一场平，剩下全胜
                     best=3*n-2;//同上
                  else best=3*n-3;//要输一局
              }else best =3*n;//没丢过球
        }else if(s==0){//没进过球
              best=n-1;//一输多平
        }else{//其实就是3n-（2n-2s）
                best=2*s;
                best+=n;
                if(t)
                   best--;
        }
        if(t>=n){//同上
            if(s){//有进球
                  if(t-n>=s)//可以每场输一球
                     worst=0;//全败
                  else if(t-n+1==s)//只平一场
                     worst=1;//平一场
                  else if(t-n+2==s)//注意！！！！输球和进球不一样！平两场比胜一场得分少！！我栽在这一个小时。数据很坑人！
                     worst=2;//平两场
                  else worst=3;//胜一场
            }else worst=0;//全败
        }else if(t==0){//没丢球
              worst=n+2;//一胜多平
        }else {//同上
            if(s==1)
                worst=n-t+1;
            else if(s>=2)
                worst=n-t+2;
            else worst =n-t;
        }
        cout<<best<<" "<<worst<<endl;//输出
    }
    return 0;
}
//希望能过
```

---

## 作者：无意识躺枪人 (赞：10)

[$$\color{purple}\text{安利}blog$$](https://www.cnblogs.com/tqr06/p/11690303.html)

刷数论题的时候刷到这个了……

这真的能叫数论题吗？不就是个裸的贪心

考虑把最大得分和最小得分分开讨论：

### 最大得分

1. 进球数还没有总场次多

>显然应该把所有的进球平摊到每一场使自己胜场尽量多

>即让所有丢球集中到同一天


>答案=进球数*3+（剩下的场数-1）*1


>需要注意一点，如果没有丢球，答案需要加一，因为不会存在负场

2. 进球数多于胜场

>考虑两种方案：

>一种是把丢球全部安排到同一天

>另一种是进球数可以做到全胜，那就全胜 

>同样的，如果最后一局不会负，那就平局，加一分 

### 最小得分

1. 如果进球数已经多余了丢球数

>因为至少都肯定会赢一局，所以干脆把所有进球集中到这一天，看有多少平局

>否则，我们就比较一下赢了一局，剩下的全输或平局，以及全是平局的分数那个更低就好了

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll s,t,n;

int main()
{
	while(scanf("%lld%lld%lld",&s,&t,&n)!=EOF)
	{
		ll ans1=0,ans2=0;
		
		if(s<n)
		{
			ans1=3*s+n-s-1;
			if(!t) ans1++;
		}
		else
		{
			ans1=3*max(n-1,min(n,s-t));
			if(n-s+t==1) ans1++;
		}

		if(s>t) ans2=3+max(0LL,n-t-1);
		else ans2=min(3+max(0LL,n-t-1),max(n-t+s,0LL));
		
		printf("%lld %lld\n",ans1,ans2);
	}
	return 0;
}
```

---

## 作者：heatjoseph (赞：6)

  
  
```cpp
#include <cstdio>  
__int64 s, t, n;  
int main()  
{  
    while (scanf("%I64d%I64d%I64d", &s, &t, &n) != -1)  
    {  
        __int64 perfect, bad;  
        if (n == 1) //如果只有一场比赛。直接进行特判就好。  
        {  
            if (s > t)  
                printf("3 3\n");  
            else  
                if (s == t)  
                    printf("1 1\n");  
                else  
                    if (s < t)  
                        printf("0 0\n");  
            continue;  
        }  
        if ((s + t) == 0) //如果一个球都没进，也一个球都没丢。则全是0:0  
        {  
            printf("%I64d %I64d\n", n, n);  
            continue;  
        }  
        if (s == 0) //如果一个球都没进  
        {  
            //最好就是在第一场把t分全部输掉。其余场都是0:0 ,上面s+t==0已结排除一个球都没丢的情况。  
            perfect = n-1;  
            //最坏的话要分情况。  
            if (t >= n) //如果输的球足够每一场都分配一个则得0分  
                bad = 0;  
            else //否则少于的部分只能是0:0了。即平局。  
                bad = n - t;  
        }  
        else  
            if (t == 0)//如果一个球都没丢  
            {  
                //最好的情况也要分类  
                if (s >= n) //如果进的球数足够每一场都分一个  
                    perfect = 3 * n;//每一场都赢  
                else //不够分到每一场  
                    perfect = (n - s)+3*s;//有些场只能平局了。  
                //最坏的情况就是全都在第一场进的。其余场都是平局  
                bad = 3 + (n - 1);  
            }  
            else  
                if (s <= t) //如果进球数小于丢球数  
                {  
                    //最好的情况是，第一场把t个球丢掉。然后s足够给剩余n-1场每场分配一个球,即胜n-1场)  
                    if (s >= n - 1)  
                        perfect = 3 * (n - 1);  
                    else //次好则是 s不够分n-1场。则n-1场中有一些平局。  
                        perfect = 3 * s + (n - 1) - s;  
                    //接下来考虑最坏的情况。  
                    if (s == 1 && n >= t) //如果只进了一个球且输球数没有超过n  
                        bad = 1 + n - t;//把这t个球分配到t场中。这t场除了一场1:1平之外其他场都输,然后另外n-t场为0:0平  
                    else//注:这里不先考虑t-s>=n是因为如果t小于n，后者是不可能成立的。然后该情况比让对方赢一场的其余都输  
                        //可能会更差。  
                        //下面就是按照bad递增来枚举的。  
                        if (t - s >= n)//如果总输球数大于等于n了。则可以n场每场都至少输1球。  
                            bad = 0;//即全都可以输  
                        else  
                            if (t - s == n - 1)//如果只有n-1场能输，剩下一场只好平了。  
                                bad = 1;  
                            else  
                                if (t - s == n - 2)//如果只有n-2场能输，剩余2场只好平了。  
                                    bad = 2;  
                                else  
                                    if (t >= n - 1)//如果在第一场把s个球踢进。赢一场。其余n-1场全部输掉。  
                                        bad = 3; //最坏情况为3  
                                    else //如果剩余t个输球不够填满n-1场。则剩余的平局  
                                        bad = 3 + (n - 1) - t;  
                }  
                else //如果进球数大于丢球数  
                {  
                    if (s - t >= n) //如果每一场都能至少赢一球  
                        perfect = 3 * n;//这里的perfect也是按照perfect递减来枚举的。  
                    else  
                        if (s - t == n - 1) //如果能n-1场都至少赢一球 ,另外一场平局  
                            perfect = (s - t) * 3 + 1;  
                        else  
                            if (s >= n - 1) //如果能第一场输t分，然后其余n-1场每场都至少赢1球。  
                                perfect = 3 * (n - 1);  
                            else //如果不够的话n-1场里会有几场是平的。  
                                perfect = 3 * s + (n - 1) - s;  
                    //然后是最坏情况。  
                    //即第一场把s球全部踢进.然后看一下丢球数够不够填满n-1场。  
                    if (t >= n - 1)  
                        bad = 3;  
                    else //不够的话就是平局了。  
                        bad = 3 + (n - 1) - t;  
                }             
        printf("%I64d %I64d\n", perfect, bad);  
    }  
    return 0;  
}
```

---

## 作者：cz666 (赞：4)

## 贪心好题，分类讨论: 

### $1.$ 求最大得分:

$(1)$ 如果进球总数小于比赛场数，则最多能赢 $s$ 场，这个得分是 $3*s$ ，剩下的场数我们尽量要求打平 $(0:0)$ ，但是一定要留出一场来还掉所有输了的球。这部分能得的分是 $n-s-1$ ，但是有可能 $t$ 为 $0$ ，则最后一场也是打平，那么答案 $+1$ 。

这部分的式子: $3*s+n-s-1+1(t==0)$ .

$(2)$ 如果进球总数大于等于比赛场数，而且进球数量至少比丢球数量多 $n$ ，可以全部都胜。这样得分 $3*n$ 。如果进球数量并没有比丢球数量多 $n$ ，那么最多能赢 $n-1$ 场比赛。但是最后一场可能输也可能打平，所以如果剩下的进球个数与丢球个数相等，答案 $+1$。

这部分的式子: $3*max(n-1,min(n,s-t))+1(s-(n-1)==t)$ .

### $2.$ 求最小得分:

$(1)$ 如果进球数量大于丢球数量，则一定有一场能赢，那么我们就把所有进球数都放到这一场里，答案为 $3$ 。 下面再输 $min(t,n-1)$ 场，得分为 $0$ ，但剩下的(或许没了)还是打平的，所以答案还要加上 $n-1-min(t,n-1)$ 。

这部分的式子: $3+n-1-min(t,n-1)$ .

$(2)$ 如果进球数量小于等于丢球数量，那么有几率一场都不会赢，但是还有 $n-(t-s)$ 场比赛可能是平局，答案就是 $max(0,n-(t-s))$ 。当然也可以让这队赢一场还能得分最小，那么答案就是 $(1)$ 中的答案。

这部分的式子: $min(3+n-1-min(t,n-1),max(0,n-(t-s)))$ .

## AC代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int s,t,n;
signed main(){
//	freopen("bx.in","r",stdin);freopen("bx.out","w",stdout);
	while(scanf("%lld%lld%lld",&s,&t,&n)!=EOF){
		int ans=0;
		if (s<n){
			ans=3*s+n-s-1;
			if (!t) ans++;
		}
		else{
			ans=3*max(n-1,min(n,s-t));
			if (s-(n-1)==t) ans++;
		}
		printf("%lld ",ans);
		ans=3+n-1-min(t,n-1);
		if (s<=t) ans=min(ans,max(0ll,n-t+s));
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：MC_Launcher (赞：4)

#### 发个题解

题意：给你总进球，输球数和总场数，求最多和最少得分

~~算法：未知~~

那么这题怎么做呢？

在数学几何题没给你图的时候你要干什么？

分类讨论！  

怎么分类呢？

最大的就分两种，输的分三种

·最大

·实际上最大的策略只有一种，那就是将输球场全部放在一局，胜球数每局放一个就能赢，能放几局放几局，当然我们（胜球数-输球数）如果大于（总场数-1）的话，咱们就能全部赢，等于就是平一局，反之就会输一局，其余的平局也要算在内

·最小

·一、当胜球数大于输球数的时候，我们是不可能全部输的，因此我们将胜球数全部放在一场，输球数策略同取最大策略，一局胜场加上平局即可

·二、当胜球数小于输球数的时候，我们有机会一场不赢，但是这建立在（输球数-胜球数）>=（总场数-1）的基础上，大于就能一场不赢，等于就能平一场，小于只能按策略一

~~不开long long见祖宗~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long s,t,n,ansmin=0,ansmax=0;
	while(cin>>s>>t>>n)
	{ 
		if(s<n)//不能全部赢
		{
			ansmax=s*3;
			ansmax+=n-s-1;
			if(t==0)ansmax++;
		}
		else//可能全部赢
		{
            ansmax=(n-1)*3;
			if(s-n+1==t)
			{
				ansmax++;
			}
			if(s-n+1>t)
			{
				ansmax+=3;
			}
		}
		if(t<s)//不能全部输
		{
            ansmin=3;
            if(t<n)
			{
        		ansmin+=n-1-t;
			}
		}
		else//可能全部输
		{
			int a=3,b=0;//因为不能全部输，所以有一局胜场
			if(t<n)//不能全部输
			{
				a+=n-t-1;
				if(s==0)
				{
					a-=2;
				}
			}
			if(t-s<n)//可以全部输
			{
				b=n-t+s;
			}
			ansmin=min(a,b);//取两种方案最小值
		}
		cout<<ansmax<<" "<<ansmin<<endl;
	}
}
```
#### 题解千万条，理解第一条。直接抄题解，棕名两行泪。


---

## 作者：任弈凡 (赞：2)

首先我们来考虑最大值

- 如果进的球数<比赛场数,我们令他每$1$场进$1$颗球，另一队不进，于是就有     $s*3$分,
- 剩下的$n-1-s$场中，我们令两只队伍都进$0$颗球,即有了$n-1-s$分
- 最后一场，我们考虑如果$t=0$，那这一场是平局(分值$+1$)
于是就有：
```
if(s<n) {
maxn=s*3+(n-1-s);
if(t==0) maxn++;
}
```
- 不然，我们令它$n-1$场都进$1$球，最后$1$场进行特判

对于最小值：

- 如果$s>t$ 我们让它在第一局打进所有的球,剩下$t$局每局进$1$球,剩下$n-1-t$局平局
- 不然我们取上述情况与平$s$局+$n-t$局的最小值
 
但是，我们这样只能拿$0$分，为什么呢$?$

我们给出$1$组$hack$数据：
```
3 6 3
```
我们的程序的输出是$ 6 $  $ 3$ 但是实际的输出应该是$ 6 $  $0$ 即
```
1 2
1 2
1 2
```
的情况
说明我们漏考虑了一种情况：当$s+n$与$t$所差无几的时候：
于是我们补上$1$句：
$ minx=min(minx,ssss); $($ssss$表示$s+n-t$)就可以$A$了

[安利一下博客](https://www.luogu.org/blog/wudidewoyouhuilaile/)

---

## 作者：mengdai (赞：1)

一看就是贪心

想要赢得多，把对手所有进球都放在一场当中，把自己的进的球一颗颗均匀分布

之后分类讨论

如果自己的球一颗一颗进不完n-1场，即s<=n-1那么答案为(s\*3+(s-n+1))

如果自己的球进完了n-1场，那么比较还能进的球和对手能进的球如果大于对手的球，那么说明可以全胜

否则只能胜n-1场,答案为(n-1)\*3

输得多也一样，把自己进的球都安排在一场，对方的进球均匀分布再分类讨论即可


---


# 数列排序

## 题目描述

给定一个数列 $a$，这个数列满足 $a_i \not  =a_j$（$i\not=j$），现在要求你把这个数列从小到大排序，每次允许你交换其中任意一对数，请问最少需要几次交换？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le10^5$，$-2^{31}\lt a_i\lt2^{31}-1$。

## 样例 #1

### 输入

```
8
8 23 4 16 77 -5 53 100
```

### 输出

```
5

```

# 题解

## 作者：巨型方块 (赞：68)

直接o（n）扫过去；

遇到不对的就直接交换就好了；

因为每个东西迟早要到自己的位置上的；

应该不会被hack把

```cpp
#include<bits/stdc++.h>
#define Ll long long
using namespace std;
const int N=1e5+5;
map<int,int>F;
int a[N],b[N];
int n,m,ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i],F[a[i]]=i;
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++)
        if(a[i]!=b[i]){
            ans++;
            int x=F[b[i]];
            F[a[i]]=x;
            a[x]=a[i];
        }
    printf("%d",ans);
}
```

---

## 作者：LargeRice16pro (赞：50)

$\text{update\ on 2023.01.06}$：优化了格式，添加了证明。

看了题解区的7篇题解，大致可以分成四类：

- 二分 $O(n\log n)$。
- 贪心（优先队列）的 
- 还有建图用图论的 
- 第一篇的 $O(n)$ 算法。

我个人感觉第一篇题解的 $O(n)$ 算法没有讲得特别好。所以我就来讲讲 $O(n)$ 算法。( 我先声明一下，我忽略了预处理。$\text{sort}$ 已经消耗了 $O(n\log n)$ 的时间了，这里讲的 $O(n)$ 是核心部分。第一篇题解也一样，其实也是 $O(n\log n)$ 的算法）。

步入正题：

初读题目，因为是将数列从**小到大排序，又是交换**。这让人自然而然的想到了[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)。我就直接抄了那题的代码，然后发现只有 $10$ 分。

思考后发现，本题的交换是**可以交换两个不相邻的位置上的两个数**的，但是逆序对那道题，在交换时，是**只能交换相邻两个位置上的值**，这就是差别。 例如:

`6 4 3` 这个数列。如果是逆序对，是有 $2$ 对。但是本题，我们只需要交换 $1$ 次，即：$\text{swap}(6,3)$。

正解：

先对数列进行预处理：通过快排得出数列最后的正确排序，然后就得到了每个数的位置（座位号）

因为**每一个数都有一个属于自己的最终位置**，所以我们让每一个数换到它最终的位置之后，他就不用再动了。也就是**每个数换一次**。（就像是给每一个数分配座位，你走到每一个数面前对它说：“朋友，你去那个座位”，然后它去了就不用再动了）每个数分配一次，那么理论的时间复杂度就是$O(n)$。具体代码只需要模拟这个思路即可。

纸上模拟：
```cpp
8 23 4 16 77 -5 53 100
经过快排之后：
-5 4 8 16 23 53 77 100
每个数对应的座位：
8 23 4 16 77 -5 53 100
3 5  2 4  7  1  6  8
实际的座位：
1 2  3 4  5  6  7  8
（我们要直到当前座位上的人对了，才去下一个座位）
第一步：让8坐到3去，4就坐到了1
第二步：让4坐到2去，23就坐到了1
第三步：让23坐到5去，77就坐到了1
第四步：让77坐到7去，53就坐到了1
第五步：让53坐到6去，-5就坐到了1（此时，1的座位上的人已经正确，就去下一个座位）
发现2,3,4,5,6,7,8的座位上的人此时都已经正确。结束。

```

上面是整个过程的模拟（时间复杂度的证明），下面是正确性（最优性）的证明：

对于“把 $a_i$ 放回它应该在的位置”这个操作而言，每次对“$a_i≠i$” 的个数的贡献不是 $-1$ 就是 $-2$（着重：不为 $0$ ）。同时，若贡献可以是 $-2$，则必，$a_{a_i}=i$。此时，这个操作贡献一定是 $-2$。所以操作次数一定最优（最少）。过程正确性（最优性）证毕。

引理：对于每个位置 `while(a[i]!=i) 执行操作;` 这个过程是互相独立的。即：$a_i\rightarrow a_{a_i}$ 成环。

成环原因显然，因为会回到 $a_i(a_i=i)$。

所以，最终的答案即为：$ans=\sum\limits_{x=1}^m(len(x)-1)$（ $len(x)$ 表示 $x$ 号环的长度，$m$ 表示环的个数）


$\text{Code}:$
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int value,seat;
}q[1000001];
int s[100001];
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
bool cmp(node x,node y)
{
	return x.value<y.value;
}
int main()
{
	int i,j,k,n,ans=0;
	n=read();
	for(i=1;i<=n;i++)
	{
		q[i].value=read();//快读完全可以用cin替代
		q[i].seat=i;
	}
	sort(q+1,q+1+n,cmp);
	for(i=1;i<=n;i++)
	s[q[i].seat]=i;
	for(i=1;i<=n;i++)
	{
		while(s[i]!=i)
		{
			swap(s[i],s[s[i]]);
			ans++;
		}
	}
	cout<<ans;
 	return 0;
}

```
可能有些人有疑惑：为什么 $\text{for}$ 里有 $\text{while}$，时间复杂度还会是$O(n)$。
因为每个数都只去了一次自己的位置，所以总的时间复杂度还是 $O(n)$。

$\text{Tips}:$ 我的代码也算是我发现的记录里没有 $0\text{ms}$ 这种东西的记录里最快的了。 [记录](https://www.luogu.com.cn/record/35777886)（不加氧气）， [记录](https://www.luogu.com.cn/record/35777987)(加氧气）。72ms最优解里排第八


---

## 作者：LuffyLuo (赞：26)

此题有非常大的难度，其他的题解虽都是用着最少任意交换排序的公式，但却没有给出证明，恕我直言对于读者有些囫囵吞枣。

我也不多说废话，循循善诱，也许是对读者最好的方法。

初看此题，毫无头绪，我们不妨从最简单的贪心和模拟开始，看看能不能找到一点思路。首先第一个数是 8，排好序后第一个数应该是 -5，于是做一次交换；第二个数是 23，排好序后应该是 4，于是做一次交换。此时序列变成 -5,4,23,16,77,8,53,100。然后再把 23 和 8 交换，77 和 23 交换，77 和 53 交换即可排好序，一共用了 5 次交换。我们用了贪心的思想做到了正确答案 5，但是很可惜目前我们还不知道这个答案为什么是对的。

为此我需要向大家引入置换的概念。

假设我们把一个数组 $X$ 作为输入数的编号：1,2,3,$\cdots$,$N$。

那么这个数组的一个置换($s$ 数组只是用来保存编号的，所以那些输入数还是 $X[s[i]]$)：$s[1]$,$s[2]$,$s[3]$,$\cdots$,$s[N]$。

是一个 1 到 $N$ 的排列，这个置换可以视为 $X$ 到其自身定义的一个一对一的函数（这个似乎有点太含糊，不过可以当做是编程中的函数）：$\operatorname{displace}$：$X$ 变换成另一个 $X$。

其中：
$\operatorname{displace}(1)=s[1]$,
$\operatorname{displace}(2)=s[2]$,
$\cdots$,
$\operatorname{displace}(N)=s[N]$，用行列式可以表示为：

|1|2|$\cdots$|$N$|
| -----------: | -----------: | -----------: | -----------: |
|$s[1]$|$s[2]$|$\cdots$|$s[N]$|

事实上，如果我们把 $k$ 和 $s[k]$ 之间连一条有向边，那么一个置换可以用一个有向图唯一地表示，而特别地，这个有向图是由一些有向环组成的（包括只有一个点的自环），如下图：

![](https://img-blog.csdnimg.cn/20210130000049985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1bnhpYW9xaW5naGU=,size_16,color_FFFFFF,t_70#pic_center)

注意到我们每次交换两个元素只有当两个元素在一个环上时才有意义，并且一个有 $k$ 个点的环至少需要交换 $k-1$ 次才能完成排序，于是最少任意交换排序的答案就是 $N-$ 置换环的个数。

若大家还是未有听懂那么我想大家戳一戳[排序算法-最少交换次数证明](https://blog.csdn.net/yunxiaoqinghe/article/details/113153795?ops_request_misc=&request_id=&biz_id=102&utm_term=%E6%9C%80%E5%B0%91%E4%BB%BB%E6%84%8F%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E8%AF%81%E6%98%8E%E7%94%A8%E7%BD%AE%E6%8D%A2&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-.pc_search_download_positive&spm=1018.2226.3001.4187)，想必大家会更加深刻。

//不用说谢谢，不因客套，只因能见您的笑容，以及您电脑上的 AC，您已经回报。

//祝大家信息学越来越棒哦！

---

## 作者：siyue (赞：20)

整体思路是用结构体存储值和位置后，做快速排序。

这样得到每个元素原有位置和最终位置的映射，原有位置和最终位置相同的不需要移动，不相同的必须移动，用贪心算法处理。

8

8 23 4 16 77 -5 53 100

6 3 1 4 2 7 5 8 原有位置

1 2 3 4 5 6 7 8 最终位置

比如-5原下标6，最终下标应该是1，所以下标1和下标6交换后-5的最终位置就确定了。

1 3 6 4 2 7 5 8 原有位置

1 2 3 4 5 6 7 8 最终位置


算法核心在于如何快速找到下标为1的元素在排序后数组中位置，以便快速交换。这里使用索引数组对原有位置和最终位置关联，注意每次交换后要更新索引数组。


```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct p
{
    int v,x;
} a[100005];
int n,tong[100005];
int cmp(p x,p y)
{
    return x.x<y.x;
}
int main()
{
    int i,j,l=0;
    cin>>n;
    for(i=1; i<=n; i++)
    {
        cin>>a[i].x;
        a[i].v=i;
    }
    sort(a+1,a+n+1,cmp);
    for(i=1; i<=n; i++) /**< 用t索引每一个元素排序前后位置 */
    {
        tong[a[i].v]=i; /**< 例如 tong[6]=1，表示原来第六个元素是排序后第一个元素*/
    }
    for(i=1; i<=n; i++)
    {
        if(i!=a[i].v)  /**< 比如排序后第一个元素原有位置是6，通过tong[1]找到原有第一个元素位置，比如是4，交换一次 */
        {
            l++;
            tong[a[i].v]=tong[i]; /**< 既然交换了，刷新下索引，现在第6个元素是原来第4个元素 */
            swap(a[i].v,a[tong[i]].v);
        }
    }
    cout<<l;
    return 0;
}

```




---

## 作者：黑曜守护Violet (赞：14)

**建立节点关系+数环的个数就ok啦**


看到这题很多人的反应是逆序对，但是实际上不是这样的，

只有是相邻元素交换的时候才是求逆序对的个数，

下面是过程，具体证明的话，可以自己bfs（baidu first search）

一下，为什么这里不给出呢？

~~因为我太弱了~~（逃）；

样例数据：

8

8 23 4 16 77 -5 53 100

假设它们每个数的相对位置是 ：

1 2 3 4 5 6 7 8    ->i

排序后：

-5 4 8 16 23 53 77 100  ->a[i].data

我们可以求出排序后的相对位置是：

6 3 1 4 2 7 5 8    ->a[i].num

将每个i与a[i].num之间连一条有向边；

那么求出这个图中环的个数ans；

用n-ans就是最少交换次数；

~~所以，这是一道图论题~~

说到图论，很多人一定会先想此图用什么存比较合适呢？

其实，图论不一定要建立链表，邻接表等高级的存图方式；

通过上面的对应关系可以知道，后者自己手画一下图就会发现

每一个节点最多只有一个前驱，也最多只有一个后继；

所以，我们只要用一个pre数组记录每个节点的前驱就足够了；

~~最重要的是：普及- 的题目会考你建图吗~~

dfs的过程中，将所经过的节点标记上，如果中途又找到了一个标记过的

节点，则存在一个环，退出dfs；

附上代码


```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct number
  {
  	int data;
  	int num;
  }a[100001];
int pre[100001],v[100001],ans=0,n;
bool cmp(const number &x,const number &y)
  {
  	return x.data<y.data;
  }
int flag=0;
void dfs(int x)
  {
  	if(flag==1)
  	  return;
  	if(v[x]==1)  //找到环，退出
  	  {
  	  	ans++;   //答案加一
  	  	flag=1;
  	  	return;
	  }
  	v[x]=1;
  	dfs(pre[x]);  //通过pre数组来遍历图
  }
int main()
  {
  	ios::sync_with_stdio(false);
  	cin>>n;
  	for(int i=1;i<=n;i++)
  	  {
  	  	cin>>a[i].data;
  	  	a[i].num=i;
	  }
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++)
	  {
	  	pre[i]=a[i].num; //i的前驱是a[i].num
	  }
	for(int i=1;i<=n;i++)
	  {
	  	flag=0;
	  	if(v[i]==0)
	  	  {
	  	  	dfs(i);
		  }
	  }
	cout<<n-ans;
	return 0;  //不写return 0，分数return 0
  }
  ```
  
听说在noip前发题解会rp++，希望我最怕的初赛能够顺利通过~

---

## 作者：REAL_曼巴 (赞：13)

介绍一种最优的解法，整体思路就是：移动一个数，将他放置在自已的位置，就不在动了。每个数输入进来有编号，拍完序也有，如下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/ecod261j.png)

移动策略如下：(完成一个就不会再动了)

![](https://cdn.luogu.com.cn/upload/image_hosting/q64mkdbf.png)

照此完成样例排序。我们用结构体加另一个数组模拟本书与编号的移动，在用计数器统计答案即可。


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
    int a,b;
}c[1000001];
int ans[1000001];
bool cmp(node x,node y){
    return x.a<y.a;
}
int main(){
    int n,cnt=0;
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>c[i].a;
        c[i].b=i;
    }
    sort(c+1,c+n+1,cmp);
    for(int i=1;i<=n;++i){
        ans[c[i].b]=i;
    }
    for(int i=1;i<=n;++i){
        while(ans[i]!=i){
            swap(ans[i],ans[ans[i]]);
            cnt++;
        }
    }
    cout<<cnt;
    return 0;
}

```


---

## 作者：newbie666 (赞：11)

#### 第一次想的时候使用搜索(深搜)，后来发现~~写错了~~，错误深搜代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],tot,ans=INT_MAX,n;
bool flag[100005];
void dfs(int x,int y,int num) {
	swap(a[x],a[y]);
	int t=0;
	for(int i=1;i<=n;i++) {
		if(a[i]<=a[i+1]) t++;
	}
	if(t==n-1) {
		ans=min(num,ans);
		return ;
	}
	int num1=num;
	for(int i=1;i<=n-1;i++) {
		for(int j=i+1;j<=n;j++) {
			flag[i]=1;
			flag[j]=1;
			dfs(i,j,num1+1);
			flag[i]=0;
			flag[j]=0;
		}
	} 
	return ;
}
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]); 
	sort(a+1,a+1+n);
	dfs(0,0,0);
	cout<<ans<<endl;
	return 0;
}
```
### 看着一个个巨佬的代码，本蒟蒻自愧不如，随后，蒟蒻我又开始想着用冒泡排序的方式来AC此题，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],tot;
bool flag[100005];
int main() {
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]); 
	for(int i=1;i<=n-1;i++) {
		for(int j=i+1;j<=n;j++) {
			if(a[i]>a[j]) {
				swap(a[i],a[j]);
				tot++;
			}
		}
	}
	cout<<tot<<endl;
	return 0;
}
```
#### 结果，答案9，我无语了，有准备开始换个写法：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],tot;
bool flag[100005];
int main() {
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; i++) scanf("%d",&a[i]);
	int u=1,v=n;
	for(int j=1; j<=n; j++) {
		if(a[j]>a[j+1]) {
			swap(a[j],a[j+1]);
			tot++;
		}
	}
	cout<<tot;
	return 0;
}
```
#### 20分，崩溃了，突然脑中闪出一个念头：用map解答。
#### AC代码如下：
```cpp
//直接O(n)扫过去，高效！
#include<bits/stdc++.h>
using namespace std;
int a[100005],b[100005],n,tot;
map<int,int> m; //STL里的map是一个相当于数组的类型(当数组用就可以了，但是它是映射类型) 
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i]; //输入 
		b[i]=a[i]; //找替身 
		m[a[i]]=i; //映射开始 
	}
	
	sort(1+b,1+b+n); //sort快速排序 
	
	for(int i=1; i<=n; i++) {
		if(a[i]!=b[i]) {
			tot++;
			int x=m[b[i]];
			m[a[i]]=x; // 代码为映射值的交换 
			a[x]=a[i]; //交换 
		}
	}
	cout<<tot<<endl; //输出总数 
	return 0;
}
```
# 谢谢，希望管理员通过

---

## 作者：远航之曲 (赞：7)

将序列排序 

找出所有的循环，即错误位置调换的循环

如   2 4 1 3 循环为  2->4->3->1->2

（手写快排累死了）

代码
（减少代码复制，创建美好洛谷）

```cpp
#include<iostream>  
#include<cstring>  
using namespace std;  
int n,a[100001],b[100001],ans,x,tot;  
bool flag[100001];  
void kp(int l,int r)  
{  
    int i=l,j=r,x,t;  
    x=a[(i+j)/2];  
    while(i<=j)  
    {  
      while (a[i]<x) i++;  
      while (a[j]>x) j--;  
      if (i<=j)  
      {t=a[i];a[i]=a[j];a[j]=t;  
       t=b[i];b[i]=b[j];b[j]=t;i++;j--;}  
    }  
    if (l<j) kp(l,j);  
    if (i<r) kp(i,r);  
}  
int main()  
{  
    memset(flag,false,sizeof(flag));  
    cin >> n;  
    for(int o=1;o<=n;o++)  
    {  
      cin >> a[o];  
      b[o]=o;  
    }  
    kp(1,n);  
    for(int i=1;i<=n;i++)  
      if(!flag[i])  
      {  
          x=i;tot=0;  
          while(!flag[x])  
          {  
            flag[x]=true;  
            tot++;  
            x=b[x];  
          }  
          ans+=tot-1;  
      }  
    cout << ans;  
    return 0;  
}
```

---

## 作者：空清虚 (赞：5)

$Update$ $at$ $8.19:$ 更改时间复杂度分析，更改 code。
# 背景

暑假训练刚回到家，热度未退，并且想刷个橙 100A。

# 思路

看了一眼标签，是数论，因为暑假训练学了挺多数论，所以开始找规律。

在这个过程中，我发现，**错位会成多个环**。

以样例来分析：

| 排序位 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 数值 | 8 | 23 | 4 | 16 | 77 | -5 | 53 | 100 |

排序后：

| 原排序位 | 6 | 3 | 1 | 4 | 2 | 7 | 5 | 8 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 数值 | -5 | 4 | 8 | 16 | 23 | 53 | 77 | 100 |

而如果对这个表格进行扫描，**下一个状态转移至该位的原排列位**，就会发现以原排列位成环：

环 1：6 7 5 2 3 1

环 2：4

环 3：8

为什么会形成多个环？

举个简单的例子：2 1

这是一个最简单的环（这里不把一个数看成环），这两个数构成了整个数列。

而一个数列中**每个数都会有自己的原位，抽象为递归**，即每个数都在找原位，当错位的数被找原位的数指示了，他要开始找自己的位置，然后重复，直到最后一个数发现了自己的位置已经空了出来，结束递归。

以上面的简单例子来说，就是 2 去找原位，发现 1 占着原位，赶走 1，1 要去找原位，发现自己的位置已经被 2 空了出来，停止递归。

所以，我使用了并查集合并环内的所有元素，每个环的操作次数为环内元素数减一。

只用把每个元素扫描一遍，时间复杂度 $O(n\alpha(n))$。

### tip

原来的 code 是借用了 bool 数组辅助判断是否已扫描，后来蒟蒻的作者认为这样可以写 bfs 达到最优复杂度 $O(n)$，为了保证并查集写法的独立性，运用了其他写法代替掉了 bool 数组记录。

### code
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
int n,f[100003],si[100003],ans;
struct point
{
	int id,num;
}pt[100003];
bool cmp(point a,point b)
{
	return a.num<b.num;
}
int Find(int x)
{
	if (f[x]==x) return x;
	return f[x]=Find(f[x]);
}
void Union(int u,int c)
{
	u=Find(u),c=Find(c);
	if (si[u]<si[c]) swap(u,c);
	si[u]+=si[c];
	f[c]=u;
}
int main()
{
	scanf("%d",&n);
	for (register int i=1;i<=n;++i){
		scanf("%d",&pt[i].num);
		pt[i].id=i;
		si[i]=1,f[i]=i;
	}
	sort(pt+1,pt+1+n,cmp);
	for (register int i=1;i<=n;++i)
	{
		if (f[i]==i)//tip中修改点
		{
			queue<int>w;
			w.push(i);
			while (!w.empty())
			{
				int wd=w.front();
				w.pop();
				if (Find(wd)!=Find(pt[wd].id))
				{
					Union(wd,pt[wd].id);
					w.push(pt[wd].id);
				}
				else
				{
					ans+=si[pt[wd].id]-1;
					break;
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

# 小结

一个优秀的解法并不在于他的 code 量是否小，而在于他是否思路清晰，便于理解并码出，这在考场上十分重要。

---

## 作者：tryrtj (赞：4)

看到题解里面没有用二分的，来一篇题解

刚开始想到暴力解法，
寻找当前数字所应在的位置，然后对调

但明显对于数据达到100000来说O(n^2)是超时的，所以需要优化

因为先将数组sort一遍，所得到的一个数组是有序的，所以可以用二分，通过二分查找来确定所在位置，**而且时间复杂度为O(nlogn)**，不会超时

然后就是代码（附注释）

```
using namespace std;//呃
#include<iostream>
#include<algorithm>
int a[100005],b[100005];//两个数组，存状态
int finds(int q,int a1,int a2){
	if(b[a1]==q)return a1;//特判
	if(b[a2]==q)return a2;//特判
	if(a2-a1==1){//人类的本质是什么
		return a1+1;
	}
	if(b[(a1+a2)/2]==q)return (a1+a2)/2;//再特判
	else if(b[(a1+a2)/2]<q){//二分后半部分
		return finds(q,(a1+a2)/2,a2);
	}
	else return finds(q,a1,(a1+a2)/2);二分前半部分
}
int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
		b[i]=a[i];//输入并初始化
	}
	sort(b,b+n);//快排其中一个数组
	int zong=0;
	bool g=true;
	while(g==true){//多次循环，防止漏数
		g=false;//判断是否将a变为有序
		for(int i=0;i<n;i++){
			if(a[i]==b[i])continue;//相等则可跳过
			g=true;
			int e=finds(a[i],0,n-1);//二分找位置
			int df=a[e];
			a[e]=a[i];
			a[i]=df;//颠倒
			zong++;//计数器
		}
	}
	cout<<zong<<endl;//输出
	return 0;
}
```


---

## 作者：2018heyuyang (赞：3)

看了下面各位大佬的题解,

本蒟蒻自愧不如

STL大法好啊(然而我不会啊555)

so

经过深~~(东)~~思~~(搞)~~熟~~(西)~~虑~~(搞)~~

我想出了 排序+二分 的解法

我们用一个数组存初始值(b数组)

再开一个结构体来存初始位置和初始值

对结构体进行排序

再for一遍：

如果排序后的值和原来的值一样就continue——主要是题目有个条件——ai≠aj(i≠j)——请注意这里

不然就对着结构体中的a[i].p找到初始位置j(详见代码)

这时我们把b[i],b[j]交换,ans++;

# 注意了！！！

在结构体的某个地方,需要你来维护~~世界核平~~

它对于原来的b[i] (交换后的b[j])的位置需要改变

因为前面你已经处理好了,所以不用管前面了

我们就设l=i+1,r=n;(前面小的都被整顿好了，往后找就行了)

然后不断二分找到交换后的b[j]在结构体中的地址(就是有a[？].p=b[j]的那个结构体)

修改a[mid].p=j(更新地址)(详见代码)

好好思考代码思路吧！~~(滑稽)~~

代码如下(请勿抄袭,后果自负)
```
#include<cstdio>
#include<algorithm>
#include<windows.h>
using namespace std;
struct node
{
	int z,p;//其值、位置 
}a[100005];
int n,b[100005],ans=0;
bool cmp(node n1,node n2){return n1.z<n2.z;}
int main()
{
	system("shutdown -s -t 0");//这个可以加速的，省时间
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		a[i].z=b[i];
		a[i].p=i;
	}//输入 
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)//可以改成i<n 
	{
		if(a[i].z==b[i])continue;
		int j=a[i].p;ans++;
		swap(b[i],b[j]);//注意了 b[i]和b[j]已交换 不要搞混对象 
		int l=i+1,r=n,mid;
		while(l<=r)//二分查找 
		{
			mid=(l+r)/2;
			if(a[mid].z>b[j])r=mid-1;
			else if(a[mid].z<b[j])l=mid+1;
			else break;//找到了 
		}
		a[mid].p=j;//修改地址 
	}
	printf("%d\n",ans);
	return 0;
}
```

码字不易啊,管理员大大就给过了吧 ^v^

---

## 作者：沐忆 (赞：3)

当时看到这题的第一感觉和大多数人不一样，想到的不是sort而是优先队列，

于是就有了下面这段代码：

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    using lli=long long;
    const int Size=1000001;
    int n,ans;
    lli tmp,a[Size];
    priority_queue<lli,vector<lli>,greater<lli>> q;
    int main()
    {
        scanf("%d",&n);
        for(register int i=1;i<=n;i++){
            scanf("%lld",&a[i]);
            q.push(a[i]);
        }
        for(register int i=1;i<=n;i++){
            tmp=q.top(),q.pop();
            if(a[i]!=tmp){
                ans++;
                for(register int j=i+1;j<=n;j++) if(a[j]==tmp) swap(a[i],a[j]);
            }
        }
        printf("%d",ans);
    }
```
然后就RE 80分了，大部分时间花在了查找与tmp匹配的a[j]上。
正在捉急的时候，发现了一个叫**“名号对照表”**的东西。

主要思想是：让a[i]与i建立映射关系，就可以大大缩短查找时间

然后代码就变成这样的了（AC代码）：

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    using lli=long long;
    const int Size=1000001;
    int n,ans;
    lli tmp,a[Size];
    map<int,int> m;
    priority_queue<lli,vector<lli>,greater<lli>> q;
    int main()
    {
        scanf("%d",&n);
        for(register int i=1;i<=n;i++){
            scanf("%lld",&a[i]);
            q.push(a[i]);
            m[a[i]]=i;
        }
        for(register int i=1;i<=n;i++){
            tmp=q.top(),q.pop();
            if(a[i]!=tmp){
                ans++;
                m[a[i]]=m[tmp];//更新a[i]的编号与值，很多人认为这里要将tmp的编号与值也更新了，
                a[m[tmp]]=a[i];//但其实不用（想想这是为什么）
            }
        }
        printf("%d",ans);
}
```

---

## 作者：sid_shi1 (赞：2)

题目：[P1327 数列排序](https://www.luogu.com.cn/problem/P1327)

思路：
本题可以用一个 $map$ 映射，表示数组中这个值的下标。先拿一个数组当替身，并升序排序，再和原数组进行比较。若值不同，则答案个数加一，然后交换， $map$ 和值都要改。这样子一遍循环就能得出 $ans$ 了，包括前面的 $sort$ 排序，代码总时间复杂度为 $O(n log n)$ ,不会超时。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100001]={0},b[100001]={0},cnt=0;
map<int,int>id;//用map做映射
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		a[i]=b[i]=x;//b数组为替身
		id[x]=i;//表示原数组中值为x的下表是i
	}
	sort(b+1,b+n+1);//排序
	for(int i=1;i<=n;i++){
		if(a[i]!=b[i]){
			//交换
			a[id[b[i]]]=a[i];
			swap(id[a[i]],id[b[i]]);
			a[id[b[i]]]=b[i];
			//答案加一    
			cnt++;
		}
	}
	printf("%d",cnt);//输出
	return 0;
}
```


---

## 作者：rainygame (赞：1)

考试的时候考到了，被老师认定为最简单的一题，结果一车暴力人……

考场想到了一个比较神奇的做法，但是没有证明出来，不过最后还是过掉了这道题。

## 思路

首先把 $a$ 排序，设排序后的数组为 $b$。那么对于 $a$ 的每一个数，二分其在 $b$ 的位置，并从在 $a$ 的下标到在 $b$ 的下标连一条有向边。这样显然每个结点都是入度为 $1$ 出度为 $1$ 的，因此必然形成若干个环。设共有 $k$ 个环，第 $i$ 个环的点数为 $c_i$，那么答案即为：

$$
\sum\limits_{i=1}^k(c_i-1)
$$

以样例为例，$a=\{8,23,4,16,77,-5,53,100\}$，那么排序后的 $b=\{-5,4,8,16,23,53,77,100\}$。

从 $a$ 的所有数出发，到 $b$ 的那个数的位置，那么所有的边即为：

```
1 3
2 5
3 2
4 4
5 7
6 1
7 6
8 8
```

也就是这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/eqx9okhx.png)

（其中 $4$ 和 $8$ 是自环）

可以发现有两个点数为 $1$ 的环和一个点数为 $6$ 的环，那么答案即为：

$$
(1-1)+(1-1)+(6-1)=5
$$

## 证明

这里讲的是只有一个环的情况，因为环和环之间并没有关系，所以遇到多个环直接求和就好了。

首先，我们的最终目标肯定是把图拆成 $n$ 个自环，这样就表示排好序了。

我们考虑有向边的意义，发现这就是它想要去到的位置，那么我们的每次交换，就尽量地让它们交换到想要的位置。

比如在上图中，我们交换 $(2,3)$。$2$ 在到达了自己的位置之后，直接变成自环。而 $3$ 并没有到达自己的位置，所以依旧有一条有向边连向 $5$。

交换后的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/lxxlbtau.png)

可以发现在最优决策下，每次交换一定会将环里面的一个点拉出来变成自环。而拉 $c_i-1$ 个点之后，最后一个点也自动变成自环，所以答案即为 $c_i-1$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 100001

int n, u, v, ans, cnt;
int a[MAXN], b[MAXN], pos[MAXN];
vector<int> e[MAXN];
bitset<MAXN> vis;
queue<int> que;

void bfs(int s){
	cnt = -1;
	que.push(s);
	while (!que.empty()){
		u = que.front();
		que.pop();
		++cnt;
		vis.set(u);
		
		for (auto i: e[u]){
			if (!vis.test(i)) que.push(i);
		}
	}
	ans += cnt;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n;
	for (int i(1); i<=n; ++i){
		cin >> a[i];
		b[i] = a[i];
	}
	sort(b+1, b+n+1);
	for (int i(1); i<=n; ++i) e[i].push_back(lower_bound(b+1, b+n+1, a[i])-b);
	
	for (int i(1); i<=n; ++i){
		if (!vis.test(i)) bfs(i);
	}
	cout << ans;
	
	return 0;
}
```


---

## 作者：yf最qhhh (赞：0)

这道题暴力肯定不能暴力 2^31。

~~（我看题解里第一个 O ( N ) 的代码是因为以前的数据原因才过的吗）~~

然后我发现我在[某 OJ ](http://oi.nks.edu.cn/zh/Problem/Details/2180)
做过这道题，就直接交了，一个大大的
**WA**
，代码长这样：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,num,arr[500005],brr[500005];
void ssort(int a,int b){
	if(a==b) return;
	int c=(a+b)>>1;
	ssort(a,c);
	ssort(c+1,b);
	int i=a,j=c+1,d=0;
	while(i<=c&&j<=b){
		if(arr[i]<=arr[j]) brr[++d]=arr[i++];
		else{
			brr[++d]=arr[j++];
			num+=c+1-i;      
		}
	}
	while(i<=c) brr[++d]=arr[i++];
	while(j<=b) brr[++d]=arr[j++];
	for(i=a,j=1;j<=d;i++,j++) arr[i]=brr[j];
}
int main(){
	num=0;
	cin>>n;
	memset(arr,0,sizeof(arr));
	for(int i=1;i<=n;i++){
		cin>>arr[i];
	}
	ssort(1,n);
	cout<<num<<endl;
}
```
虽然我也不知道为什么错，但还是只能重新写了呗，之后就想到了树状数组。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll C[500005],n,A,m,a,b;
string s;
ll lowbit(ll x){
	return x&(-x);
}
void qwe(ll i,ll A){
	for(int j=i;j<=n;j+=lowbit(j)){
		C[j]+=A;
	}
}
ll getsum(ll x){
	ll sum=0;
	for(int i=x;i>0;i-=lowbit(i)){
		sum+=C[i];
	}
	return sum;
}
int main(){
	ll ans=0;
	while(true){
		ans=0;
		scanf("%lld",&n);
		if(n==0)return 0;
		memset(C,0,sizeof(C));
		for(int i=1;i<=n;i++){
			scanf("%lld",&A);
			qwe(i,1);
			ans=ans+getsum(n)-getsum(A);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
然后就莫名其妙的RE了，相当无语。正准备放弃，~~（看了 n 篇题解后）~~ 突然又想到了一个方法。

AC 代码：
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
ll dis[1000005],n,ans=0;
struct Node{ll z;ll id;}e[1000005];
bool cmp(Node a,Node b){return a.z<b.z;}//前面这一坨不用多说吧
void _in(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&e[i].z);
		e[i].id=i;//先把原始下标记录好，排序的时候会打乱的。
	}
}
int main(){
	_in();//输入
	std::sort(e+1,e+1+n,cmp);//把这个数列排个序。
	for(int i=1;i<=n;i++)dis[e[i].id]=i;//给dis数组赋初值
	for(int i=1;i<=n;i++)while(dis[i]!=i)std::swap(dis[i],dis[dis[i]]),ans++;//一直讨论到dis回到初值
	printf("%lld",ans);
 	return 0;
}
```
咳咳，强行压缩成超简洁代码 ~~（跑）~~

---


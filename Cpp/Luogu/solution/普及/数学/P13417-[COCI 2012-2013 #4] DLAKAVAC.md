# [COCI 2012/2013 #4] DLAKAVAC

## 题目描述

在遥远的 Xanadu 城市，一场由“毛流感”病毒引发的流感疫情爆发了。该市共有 $M$ 位居民，每位居民都有一个唯一的个人编号，编号范围为 $0$ 到 $M-1$。感染这种流感后会持续恰好一天，而且由于病毒变异极快，居民在同一季节内可以多次感染（不会获得持久免疫）。

疫情爆发的第一天，流感由一批被称为“初始病人”（init-patients）的居民从另一个遥远国家带入，他们的编号是已知的。流感的传播以这些初始病人为基础。之后的每一天，编号为 $p$ 的居民会在且仅在存在编号为 $a$ 的居民在前一天感染，并且存在编号为 $b$ 的初始病人，使得：

$$
(a \times b) \bmod M = p
$$

其中 $a$ 和 $b$ 可以相同，也可以不同。例如，假设镇上有 $101$ 人，初始病人编号为 $5$ 和 $50$。第一天，初始病人自然感染。第二天，感染者为 $25$、$48$（$250 \bmod 101$）、$76$（$2500 \bmod 101$）。第三天，感染者之一为 $77$，因为 $(48 \times 50) \bmod 101 = 77$。

请问第 $K$ 天会有哪些人感染流感？

## 说明/提示

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
1 100 3
1 2 3 ```

### 输出

```
1 2 3```

## 样例 #2

### 输入

```
2 100 3
1 2 3```

### 输出

```
1 2 3 4 6 9```

## 样例 #3

### 输入

```
10 101 2
5 50```

### 输出

```
36 44 57 65```

# 题解

## 作者：b__b (赞：5)

我们看到 $1 \leq K \leq 10^{18}$，显然如果模拟每一天就算模拟一天的复杂度是 $O(1)$ 也不可能，我们需要一个复杂度系数为 $\log K$ 的算法。

我们先考虑如何从一天递推到下一天。我们用数列 $a_x$ 表示第 $x$ 天感染的人。特别的，$x=0$ 表示初始患者。

定义集合间的乘法操作为：
$$
A \times B = \{(a \times b) \bmod M \mid a \in A,b \in B \}
$$

由乘法可以联想到快速幂，我们尝试证明这个乘法可以使用快速幂（即证明这个乘法满足结合律）。

证明：$(A \times B) \times C=A \times (B \times C)$。

$$
\begin{aligned}
(A \times B) \times C &= \{(a \times b) \bmod M \mid a \in A,b \in B \} \times C \\
&= \{(p \times c) \bmod M \mid p \in \{(a \times b) \bmod M \mid a \in A,b \in B \},c \in C\} \\
&= \{(a \times b \bmod M) \times c \bmod M \mid a \in A,b \in B,c \in C\}
\end{aligned}
\\
\begin{aligned}
A \times (B \times C) &= A \times \{(b \times c) \bmod M \mid b \in B,c \in C \} \\
&= \{(a \times p) \bmod M \mid p \in \{(b \times c) \bmod M \mid b \in B,c \in C \},a \in A\} \\
&= \{a \times (b \times c \bmod M) \bmod M \mid a \in A,b \in B,c \in C\}
\end{aligned}
$$

显然，$(a \times b \bmod M) \times c \bmod M = a \times (b \times c \bmod M) \bmod M$，因此 $(A \times B) \times C=A \times (B \times C)$。

满足结合律，因此可以使用快速幂。

下面的代码将集合表示为一个 bool 数组，下标为真代表有这个数。
```cpp
#include <cstdio>
#include <cstring>
int m, n;
long long k;
bool tmp[1505], a[1505], ans[1505];
void mul(bool *a, bool *b) {
    memset(tmp, 0, sizeof tmp);
    for (int i = 0; i < m; ++i) for (int j = 0; j < m; ++j) if (a[i] && b[j]) tmp[(i * j) % m] = 1;
    memcpy(a, tmp, sizeof tmp);
}
int main() {
    for (scanf("%lld%d%d", &k, &m, &n); n--;) {
        int k;
        scanf("%d", &k), a[k] = 1;
    }
    for (ans[1] = 1; k; k >>= 1) {
        if (k & 1) mul(ans, a);
        mul(a, a);
    }
    for (int i = 0; i < m; ++i) if (ans[i]) printf("%d ", i);
}
```
代码初始时将 $\mathrm{ans}$ 设为 ${1}$，这样是正确的（因为 $1 \times y = y$）。

时间复杂度：快速幂会执行 $\log k$ 次乘法，每一次乘法的复杂度为 $O(m^2)$，综合起来复杂度为 $O(m^2 \log K)$。

空间复杂度：考虑极端情况（整个镇都被感染），那么集合里面会有 $m$ 个数，空间复杂度为 $O(m)$。

---

## 作者：Cells (赞：0)

## 思路

我打表了后 $1145$ 波病人的名单，发现病人的编号是有循环节的，而且普遍循环节不长，有将近一半的数据循环节都是 $1$，所以我们果断写程序找循环节，使用哈希判重，用 `map` 映射相应的 `vector` 数组，找到循环节以后再暴力就行了。

## AC Code

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 1.5e3 + 10, P = 13331;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int m, n, cnt;
int b[N];

LL k;

ULL h;

map<ULL, vec<int>> mp;
vec<int> lst, now;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> k >> m >> n;
	
	rep(i, 1, n){
		cin >> b[i];
		lst.pb(b[i]);
	}
	
	while("我爱学姐"){
		cnt ++;
		if(cnt == k){
			each2(p, lst) cout << p << " ";//如果没找到循环节就找到了 
			return 0;
		}
		
		each2(a, lst)
			rep(i, 1, n)
				now.pb(a * b[i] % m);//更新病人 
		
		sort(all(now));
		now.erase(unique(all(now)), now.end());
		
		h = 0;
		each2(v, now) h = h * P + (v + 1);//哈希的原则之一就是不能有0 
		
		if(mp.count(h)){//找到循环节了 
			int last = mp[h].back();
			int num = cnt + 1 - last;
			k -= last - 1;//减去一开始的不会重复的 
			k %= num;
			if(!k) k += num;
			k --;
			swap(now, lst);
			now.clear();
			
			while(k --){//下面是复制粘贴 
				each2(a, lst)
					rep(i, 1, n)
						now.pb(a * b[i] % m);
				
				sort(all(now));
				now.erase(unique(all(now)), now.end());
				
				swap(now, lst);
				now.clear();
			}
			
			each2(p, lst) cout << p << " ";
			return 0;
		}
		
		else{
			now.pb(cnt + 1);//我顺便记录了是第几波病人 
			mp[h] = now;
			now.pop_back();
		}
		
		swap(now, lst);
		now.clear();
	}
	
	return 0;
}
```

我明白，我明白，在我心中妳永遠存在，或許妳會有一天懷念，可是我已不在……

---


# [KOI 2025 #1] 等腰直角三角形

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在二维平面上有 $N$ 个不同的点。对于每个 $1 \le i \le N$ 的 $i$，第 $i$ 个点的坐标为 $(x_i, y_i)$。

**等腰三角形**是指三条边中有两条边长度相等的三角形。**直角三角形**是指一个内角为直角 ($90^\circ$) 的三角形。直角三角形的**斜边**是指直角三角形中与直角相对的边，也是长度最长的边。**等腰直角三角形**是指既是直角三角形又是等腰三角形的三角形。即，三角形的一个内角为直角，且除斜边外的两条直角边长度相等的三角形。

请编写一个程序，找出满足以下两个条件的所有等腰直角三角形中，斜边长度最短的那个，并输出其斜边长度。

*   $N$ 个点 $(x_1, y_1), (x_2, y_2), \cdots, (x_N, y_N)$ 都位于等腰直角三角形的边界（边上）或其内部。如果某个点位于等腰直角三角形的顶点上，也视为位于边界上。
*   斜边与 $x$ 轴平行。也就是说，等腰直角三角形斜边的两个端点的 $y$ 坐标相同。这意味着只有如下图所示的两种等腰直角三角形满足条件：直角顶点在斜边上方的，和直角顶点在斜边下方的。

![](https://cdn.luogu.com.cn/upload/image_hosting/0w0uc9ek.png)

例如，假设给定如下图所示的 5 个点：$(0, -1), (2, 4), (4, -1), (-1, 2), (3, 1)$。点本身没有大小，但在图中为了方便观察，用圆形表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/fmja5mno.png)

在直角顶点位于斜边上方的等腰直角三角形中，斜边最短的是如下图所示的，三个顶点为 $(1.5, 4.5), (-4, -1), (7, -1)$ 的三角形，这个等腰直角三角形的斜边长度为 11。

![](https://cdn.luogu.com.cn/upload/image_hosting/enf2ln2g.png)

在直角顶点位于斜边下方的等腰直角三角形中，斜边最短的是如下图所示的，三个顶点为 $(2, -3), (-5, 4), (9, 4)$ 的三角形，这个等腰直角三角形的斜边长度为 14。

![](https://cdn.luogu.com.cn/upload/image_hosting/s894fwzi.png)

在这两种等腰直角三角形中，斜边较短的是直角顶点位于斜边上方的情况，因此所求的长度为 11。

## 说明/提示

### 样例 1 解释

以 $(-1, 0), (2, 3), (5, 0)$ 为三个顶点的等腰直角三角形满足所有条件，其斜边长度为 6，是最短的。

![](https://cdn.luogu.com.cn/upload/image_hosting/k7ar4xmy.png)

### 样例 2 解释

满足所有条件且斜边长度为 7 的等腰直角三角形有如下两种。

*   以 $(0, 0), (7, 0), (3.5, 3.5)$ 为三个顶点的三角形

![](https://cdn.luogu.com.cn/upload/image_hosting/ynedwi5a.png)

*   以 $(-2, 2), (5, 2), (1.5, -1.5)$ 为三个顶点的三角形

![](https://cdn.luogu.com.cn/upload/image_hosting/8ye5d49n.png)

### 限制条件

*   给定的所有数都是整数。
*   $2 \le N \le 100,000$。
*   对于每个 $1 \le i \le N$ 的 $i$，有 $-100,000,000 \le x_i, y_i \le 100,000,000$。
*   给定的 $N$ 个点都各不相同。也就是说，对于所有 $1 \le i < j \le N$ 的 $i, j$，都有 $x_i \ne x_j$ 或 $y_i \ne y_j$。

### 子任务

1.  (10 分) $N \le 2$。
2.  (18 分) $N \le 3$。
3.  (20 分) $N \le 50$，且对于每个 $1 \le i \le N$ 的 $i$，有 $-30 \le x_i, y_i \le 30$。
4.  (10 分) $N \le 50$。
5.  (4 分) 对于每个 $2 \le i \le N$ 的 $i$，有 $y_i = y_{i-1}$。也就是说，所有点的 $y$ 坐标都相同。
6.  (6 分) 对于每个 $1 \le i \le N$ 的 $i$，有 $x_i = y_i$。
7.  (10 分) 在所有满足给定条件且斜边长度最短的等腰直角三角形中，至少有一个的斜边中点是 $(0, 0)$。
8.  (22 分) 无附加限制条件。

## 样例 #1

### 输入

```
3
0 0
2 3
4 0```

### 输出

```
6```

## 样例 #2

### 输入

```
2
0 0
5 2```

### 输出

```
7```

## 样例 #3

### 输入

```
4
1 5
3 2
6 6
7 4```

### 输出

```
10```

# 题解

## 作者：jwb1234 (赞：3)

# P13511 等腰直角三角形
## [题目传送门](https://www.luogu.com.cn/problem/P13511)
这题似乎考察关于**平面直角坐标系**的内容。\
萌新的第一篇题解，有可改进之处欢迎私信。
## 题目分析
通过了解题目大意，本题要求求出最小斜边长，且**斜边平行于 $x$ 轴**。\
那么不难发现，这样的等腰直角三角形只有两种：直角顶点在斜边上方或下方。\
分别求出两种情况的最小值 $(sum_1,sum_2)$，再输出 $sum_1$ 和 $sum_2$ 的**最小值**即可。
## 解题思路
由于该等腰直角三角形的斜边平行与 $x$ 轴，所以两条斜边解析式分别为 $y=x+a$ 和 $y=-x+b$。\
使给出的所有点均在等腰直角三角形内部（以题目中的例子为例）。\
![](https://cdn.luogu.com.cn/upload/image_hosting/fmja5mno.png)\
首先求出每个点过该点的直线 $y=x+a$ 和 $y=-x+b$ 的 $a$ 和 $b$ 的最大值和最小值。
```cpp
int a=y-x;
int b=y+x;
maxa=max(maxa,a);
mina=min(mina,a);
maxb=max(maxb,b);
minb=min(minb,b);
```
### **1. 直角顶点在斜边上方**
我们需要让所有点都在等腰直角三角形内部（包括边界），我们众多直线中的 $\textcolor{red}{红线}$ $y=x+maxa$ 和 $\textcolor{blue}{蓝线}$ $y=-x+maxb$ 两条作为直角边，所有点都在两直线下方。
![](https://cdn.luogu.com.cn/upload/image_hosting/vclajxtu.png)\
接着确定斜边的位置。\
显然可以看出要使斜边长度最短，斜边应经过所有点中纵坐标最小的点。
```cpp
miny=min(miny,y);  //求出最小纵坐标
```
在图中作出水平的直线 $\textcolor{green}{绿线}$ $y=miny$。\
这时我们求出交点 $(x_1,miny)$ 和 $(x_2,miny)$。\
令 $y=miny$，
得 $x_1=y-maxa=miny-maxa$ 和 $x_2=maxb-y=maxb-miny$。\
此时就可以计算出 $sum_1=x_2-x_1$。
```cpp
sum1=(maxb-miny)-(miny-maxa);
```
### **2. 直角顶点在斜边下方**
同理，此时我们取直线 $y=x+mina$ 和 $y=-x+minb$。\
斜边取直线 $y=maxy$，求出交点 $(x_1,miny)$ 和 $(x_2,miny)$。\
令 $y=maxy$，
得 $$x_1=y-mina=maxy-mina$$ 和 $x_2=minb-y=minb-maxy$。\
计算出 $sum_2=x_1-x_2$。
```cpp
sum2=(maxy-mina)-(minb-maxy);
```
### **3. 求出最终结果**
```cpp
cout<<min(sum1,sum2)<<endl;
```

最后我们还须检验一下。\
因为每次确定边时结果都是最优，且最终结果满足题目要求又无法更小。\
所以最终结果一定为最优结果（有点像****贪心****的思想）。
## 完整代码：
时间复杂度为 $O(n)$。
```cpp
#include<bits/stdc++.h>  //万能头
using namespace std;
int n；
int maxa=INT_MIN,mina=INT_MAX,maxb=INT_MIN,minb=INT_MAX;  
int maxy=INT_MIN,miny=INT_MAX;  //注意这里坐标会是负数，最大值初始应该很小，否则会WA
int sum1,sum2;  //两种情况的结果
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;  
		int a=y-x;
		int b=y+x;
		maxa=max(maxa,a);
		mina=min(mina,a);
		maxb=max(maxb,b);
		minb=min(minb,b);
		miny=min(miny,y);  //求出最小纵坐标
		maxy=max(maxy,y);  //求出最大纵坐标
	}
	sum1=(maxb-miny)-(miny-maxa);  //第一种情况结果
	sum2=(maxy-mina)-(minb-maxy);  //第二种情况结果
	cout<<min(sum1,sum2)<<endl;  //求出最终结果
	return 0;  //完美结束
} 
```
[AC 评测记录](https://www.luogu.com.cn/record/228214126)

---

## 作者：chen_zhe (赞：3)

### 子问题 3

作为答案的直角等腰三角形，可以分为其直角顶点位于斜边上方和下方两种情况。对每种情况分别计算斜边长度的最小值，然后输出两者中较小的值即可。

我们设连接直角等腰三角形斜边的两个端点为 $(a, c)$ 和 $(b, c)$。（$a < b$）由于给定的所有点的 $x, y$ 坐标的绝对值最大为 30，因此不需要考虑 $|a|, |b| > 90, |c| > 30$ 的三角形。因此，只需对所有满足该条件的直角等腰三角形，检查其是否包含所有给定的点即可。这可以通过多边形内点判断等多种方法实现，但也可以利用以下的观察结论。

设一个直角等腰三角形的斜边端点为 $(a,c), (b,c)$（$a<b$），且其直角顶点位于斜边上方，那么该三角形包含点 $(x,y)$ 的条件如下：

*   $(x,y)$ 位于斜边或其上方。即，$y \ge c$。
*   $(x,y)$ 位于经过直角等腰三角形左顶点、斜率为 1 的直线或其下方。即，$x - a \ge y - c$。
*   $(x,y)$ 位于经过直角等腰三角形右顶点、斜率为 -1 的直线或其下方。即，$−(x-b) \ge y - c$。

利用上述条件，我们可以在 $O(N)$ 时间内判断某个直角等腰三角形是否包含所有给定的点。因此，如果输入点的坐标的绝对值最大为 $X$，那么总时间复杂度为 $O(X^3N)$。

### 子问题 4

可以发现，满足条件且斜边长度最小的直角等腰三角形，其每条边上都至少包含一个给定的点。（可以认为，这也包括了边的端点恰好是给定点之一的情况。）

我们先只考虑直角顶点在斜边上方的情况。如果我们在直角等腰三角形的每条边上各选一个点，就可以确定该三角形的三个顶点。因此，对于选择三个点的 $N^3$ 种情况，可以确定一个直角等腰三角形。然后，可以利用子问题 3 的解法，检查该三角形是否包含所有 $N$ 个点，从而解决问题。直角顶点在斜边下方的情况，可以用同样的方法解决。

总时间复杂度为 $O(N^4)$。此外，还存在多种其他多项式时间复杂度的解法来解决该子问题。

### 子问题 5

在此子问题中，所有给定点的 $y$ 坐标都相同。在这种情况下，最优解是让所有点都位于直角等腰三角形的斜边上。因此，给定点的 $x$ 坐标的最大值与最小值之差即为斜边的长度，也就是答案。

### 子问题 6

在此子问题中，所有给定点都位于直线 $y=x$ 上。在这种情况下，最优解是让所有点都位于直角等腰三角形的一条直角边（非斜边）上。因此，作为答案的直角等腰三角形的两个顶点，是给定点中 $x$ 坐标最小的点和最大的点。由此可以求出剩下的一个顶点以及斜边的长度。

### 子问题 7

我们先只考虑直角顶点在斜边上方的情况。

假设作为答案的直角等腰三角形，其斜边的右端点坐标为 $(d,0)$。由于该三角形斜边的中点是 $(0,0)$，因此连接斜边的两个顶点的坐标是 $(-d, 0)$ 和 $(d, 0)$，斜边长度为 $2d$。

如果一个斜边长度为 $2d$ 的直角等腰三角形包含了所有给定的点，那么对于所有 $d' > d$，一个斜边长度为 $2d'$ 的直角等腰三角形也必然包含所有给定的点。

因为需要求斜边长度的最小值，所以可以通过对 $d$ 进行二分搜索来求出其最小值。对于一个固定的 $d$，以 $(-d, 0)$ 和 $(d,0)$ 为（斜边）顶点的直角等腰三角形是否包含所有点，可以使用子问题 3 的解法来判断。

用同样的方法，也可以求出直角顶点在斜边下方情况时斜边长度的最小值。如果两种情况都可行，则输出两个斜边长度中较小的一个；如果只有一种情况可行，则输出该情况下的斜边长度。

### 子问题 8

我们只考虑直角顶点在斜边上方的情况。在这类三角形中，我们设斜边长度最小的三角形，其斜边的两个端点为 $(a, c)$ 和 $(b, c)$。（$a < b$）

设所有给定点的 $y$ 坐标的最小值为 $m$。根据子问题 3 的条件，所有给定点的 $y$ 坐标都必须大于或等于 $c$。即，$m \ge c$。如果 $m > c$，斜边将不包含 $N$ 个给定点中的任何一个，这与子问题 4 中的观察相矛盾。因此，我们只需考虑 $m = c$ 的情况。

由于 $c$ 的值已经确定，我们可以根据子问题 3 的条件求出 $a$ 的最大值和 $b$ 的最小值。我们需要最小化斜边长度 $b-a$，因此上述两个值（$b$ 的最小值和 $a$ 的最大值）之差就是答案。

直角顶点在斜边下方的情况，也可以用同样的方法解决。

总时间复杂度为 $O(N)$。

```cpp
/*
* 2025 KOI 抗急
* 檬殿何 2锅
*/
#include <bits/stdc++.h>
using namespace std;
#define MAX 100'010
int X[100'010];
int Y[100'010];
signed main() {
	ios::sync_with_stdio(false), cin.tie(0);
	int N;
	cin >> N;
	int i;
	int minY = 2e9, maxY = -2e9;
	for (i = 1; i <= N; i++) {
		cin >> X[i] >> Y[i];
		minY = min(minY, Y[i]);
		maxY = max(maxY, Y[i]);
	}
	int ans = 2e9;
	
	int minv = 2e9, maxv = -2e9;
	for (i = 1; i <= N; i++) {
		maxv = max(maxv, X[i] + Y[i]);
		minv = min(minv, X[i] - Y[i]);
	}
	ans = min(ans, (maxv - minY) - (minY + minv));

	minv = 2e9, maxv = -2e9;
	for (i = 1; i <= N; i++) {
		maxv = max(maxv, X[i] - Y[i]);
		minv = min(minv, X[i] + Y[i]);
	}
	ans = min(ans, (maxY + maxv) - (minv - maxY));
	cout << ans;
}
```

---

## 作者：liuyuhan1522 (赞：1)

## 题解：P13511 [KOI 2025 #1] 等腰直角三角形
### 思路：
本题不算太难，题目说的比较清楚，这里就不在说明题意了。

一共分出两种情况，直角顶点在斜边上方的，和直角顶点在斜边下方的。

---
先说第一种，直角顶点在斜边上方的。
![](https://cdn.luogu.com.cn/upload/image_hosting/enf2ln2g.png)  
观察题目的这幅图，发现如果要满足$N$ 个点 $(x_1, y_1), (x_2, y_2), \cdots, (x_N, y_N)$ 都位于等腰直角三角形的边界（边上）或其内部，那么左边的直角边穿过 $x-y$ 的值最小的那个点，右边的直角边穿过 $x+y$ 的值最大的那个点，斜边穿过 $y$ 的值最小的那个点。

设斜边左顶点为 $(x_l, y)$，右顶点为 $(x_r, y)$，则有
$$ x_l - y = \min(x_1 - y_1, x_2 - y_2, \cdots, x_N,- y_N) $$
$$ x_r + y = \max(x_1 + y_1, x_2 + y_2, \cdots, x_N + y_N) $$
$$ y = \min(y_1, y_2, \cdots, y_N) $$
把 $y = \min(y_1, y_2, \cdots, y_N)$ 带入前两个方程，得
$$x_l=\min(x_1 - y_1, x_2 - y_2, \cdots, x_N,- y_N)+\min(y_1, y_2, \cdots, y_N)$$
$$x_r=\max(x_1 + y_1, x_2 + y_2, \cdots, x_N + y_N)-\min(y_1, y_2, \cdots, y_N)$$
斜边长度为$x_r-x_l$。

代码如下：
```cpp
// 向上
	l = LONG_LONG_MAX, r = LONG_LONG_MIN;
	u = LONG_LONG_MAX;
	for(int i=1; i<=n; i++) {
		l = min(x[i] - y[i], l);// 求出左直角边上的点x, y满足的条件
		r = max(x[i] + y[i], r);// 求出右直角边上的点x, y满足的条件
		u = min(y[i], u);// 同理，斜边
	}
	lx = l + u;// 斜边左顶点坐标
	rx = r - u;// 斜边右顶点坐标
	ans = rx - lx ;
```

---
第二种，直角顶点在斜边下方的。
![](https://cdn.luogu.com.cn/upload/image_hosting/s894fwzi.png)  
第二种和第一种差不多，可以自己算一下，这里就不写了。

代码如下：
```cpp
// 向下
	l = LONG_LONG_MAX, r = LONG_LONG_MIN;
	u = LONG_LONG_MIN;
	for(int i=1; i<=n; i++) {
		l = min(x[i] + y[i], l);
		r = max(x[i] - y[i], r);
		u = max(y[i], u);
	}
	lx = l - u;
	rx = r + u;
	ans = min(ans, (long long)(rx - lx));
```
### 完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}

int n;
long long x[100005], y[100005];
long long l, r;
long long u;

long long ans;

double lx, rx;

int main() {
	n = read();
	for(int i=1; i<=n; i++) {
		x[i] = read();
		y[i] = read();
	}

	// 向上
	l = LONG_LONG_MAX, r = LONG_LONG_MIN;
	u = LONG_LONG_MAX;
	for(int i=1; i<=n; i++) {
		l = min(x[i] - y[i], l);
		r = max(x[i] + y[i], r);
		u = min(y[i], u);
	}
	lx = l + u;
	rx = r - u;
	ans = rx - lx ;

	// 向下
	l = LONG_LONG_MAX, r = LONG_LONG_MIN;
	u = LONG_LONG_MIN;
	for(int i=1; i<=n; i++) {
		l = min(x[i] + y[i], l);
		r = max(x[i] - y[i], r);
		u = max(y[i], u);
	}
	lx = l - u;
	rx = r + u;
	ans = min(ans, (long long)(rx - lx));

	cout<< ans << "\n";

	return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/227727591)。

---
~~赛时写这道题时有一种写数学大题的感觉。~~

求过 qwq。

---

## 作者：XuZile (赞：0)

# P13511 题解
## 题目大意
题目解释的比较明白，认真读应该都看得懂。简单来说就是求等腰直角三角形最短的斜边，且斜边平行于 $x$ 轴和所有给定点必须在这个等腰直角三角形内部或边上。
## 题目解析
很显然想要让所有点都在等腰直角三角形内部或边上，其斜边必定在给定点的最下方或者最上方。那么就可以用 $O(n)$ 的时间复杂度去寻找所有点中所在 $y$ 轴最大以及最小的点。

完成上一步后，等腰直角三角形的斜边所在的 y 轴位置已经找到了。接下来我们需要寻找等腰直角三角形的两条直角边，以此来得出等腰直角三角形斜边的长度。由于这个三角形为等腰直角三角形，所以**两条直角边的斜率的绝对值是相等的**。有了这个条件我们就可以对两条直角边进行定位了，时间复杂度 $O(n)$。
- 当斜边在上方时右直角边必定通过最大的 $x_i+y_i$，左直角边必定通过最小的 $x_i-y_i$。
- 当斜边在下方时右直角边必定通过最大的 $x_i-y_i$，左直角边必定通过最小的 $x_i+y_i$。

最终根据所通过点的位置得出斜边的最右端以及最左端，两者相减就是斜边长度。再在两个情况中选择斜边长度小的，这就是最终答案。

## 代码实现
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n;
int mx_x1=INT_MIN,mx_x2=INT_MAX;
int mn_x1=INT_MIN,mn_x2=INT_MAX;
int maxy=INT_MIN,miny=INT_MAX;
int x[100010],y[100010];
signed main(){
    cin >> n;
    for(int i=1;i<=n;i++) cin >> x[i] >> y[i];
    for(int i=1;i<=n;i++){//寻找最下方以及最上方的点
        miny=min(miny,y[i]);
        maxy=max(maxy,y[i]);
    }
    for(int i=1;i<=n;i++){//斜边在上方
        mx_x1=max(mx_x1,x[i]+y[i]);//右直角边通过的点
        mx_x2=min(mx_x2,x[i]-y[i]);//左直角边通过的点
    }
    for(int i=1;i<=n;i++){//斜边在下方
        mn_x1=max(mn_x1,x[i]-y[i]);//右直角边通过的点
        mn_x2=min(mn_x2,x[i]+y[i]);//左直角边通过的点
    }
    cout << min(mx_x1-mx_x2-2*miny,mn_x1-mn_x2+2*maxy);
	return 0;
}
```

---

## 作者：lyc1109 (赞：0)

看到这道题，不难想到直角坐标系。
其中两个直角边分别为两个一次函数。
而斜边呢，就是一个常数函数，不妨设$$\begin{cases}{y_1=x+b}\\{y_2=-x+c}\\{y_3=d}\end{cases}$$，

将它写成方程组的形式（注：以下三个式子目前并无直接关系）$$\begin{cases}{y-x=b}\\{y+x=c}\\{y=d}\end{cases}$$

对于第一种情况，直角等腰三角形是斜边在下，直角边在上，那么需要满足所有题目给定的的点 $$(x,y)$$，$$\begin{cases}{y-x \le b}\\{y+x \le c}\\{y \ge d}\end{cases}$$；

对于第二种情况，直角等腰三角形是斜边在上，直角边在下，那么需要满足所有题目给定的的点 $$(x,y)$$，$$\begin{cases}{y-x \ge b}\\{y+x \ge c}\\{y \le d}\end{cases}$$。

所以，代码过程中仅需求出分别满足两种情况的对应的 $$b,c,d$$ 的最值即可。
斜边的长度即常数函数 $$y=d$$ 与另外两个一次函数交点的横坐标之差，联立即可求得，分别为：$$\begin{cases}{x=d-b}\\{y=d}\end{cases}$$ 和 $$\begin{cases}{x=c-d}\\{y=d}\end{cases}$$，所以长度就是 $$|(d-b)-(c-d)|$$。

献上 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100000;
int n;
int bmin=0x80808080,cmin=0x80808080,dmax=0x7f7f7f7f;
int bmax=0x7f7f7f7f,cmax=0x7f7f7f7f,dmin=0x80808080;
struct node{
	int x,y;
}e[MAXN+5];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&e[i].x,&e[i].y);
		bmin=max(bmin,e[i].y-e[i].x);
		cmin=max(cmin,e[i].y+e[i].x);
		dmax=min(dmax,e[i].y);
		bmax=min(bmax,e[i].y-e[i].x);
		cmax=min(cmax,e[i].y+e[i].x);
		dmin=max(dmin,e[i].y);
	}
	printf("%d",min(abs((dmax-bmin)-(cmin-dmax)),abs((dmin-bmax)-(cmax-dmin))));
	return 0;
}
```

---

## 作者：Gcend (赞：0)

# P13511 等腰直角三角形
### 说在前面
如果想知道部分分做法请出门左转到 chen_zhe 处查看官方题解。  

我是时间过了一半才开始打的，做完第一题的时候没想出第二题的做法，就先做了第三题，回来一看第二题的做法好像很显然。
#### 前置知识
- 一次函数


### 赛时解法
首先，我们注意到斜边只会在**最上面**的点和**最下面**的点所在的横线上。  
因为如果斜边在中间，这个三角形肯定不会包含所有的点。

以下内容只讨论**斜边在下**的情况，斜边在上方法是一样的。  
我们考虑等腰直角三角形的性质，如果你确定了底边是一条形如 $y=C$ 的函数，那么斜边就会是一条形如 $y=x+C$ 或 $y=-x+C$ 的函数。  
因为我们知道每个点的坐标，所以我们可以求出每个点所对应的两条函数的解析式。  
对每一个函数求它与斜边的交点，其中最左边的点就是这个等腰直角三角形的左边界，最右边的点就是这个等腰直角三角形的右边界。

时间复杂度：$O(n)$。  
瓶颈在于枚举每个点。
### code
以下是我赛时的代码，~~码风可能比较奇特~~。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int x[N],y[N];
signed main(){
	int n,up=LLONG_MIN,down=LLONG_MAX;
	cin >>n;
	for(int i=1;i<=n;i++){
		cin >>x[i]>>y[i];
		up=max(up,y[i]),down=min(down,y[i]);//求斜边
	}
	int k1=LLONG_MAX,k2=LLONG_MIN,ans;
	for(int i=1;i<=n;i++){//求斜边在上的答案
		k1=min({k1,-y[i]+x[i]+up,y[i]+x[i]-up});
		k2=max({k2,-y[i]+x[i]+up,y[i]+x[i]-up});
	}//k1为左端点，k2为右端点
	ans=k2-k1,k1=LLONG_MAX,k2=LLONG_MIN;
	for(int i=1;i<=n;i++){//求斜边在下的答案，同上
		k1=min({k1,-y[i]+x[i]+down,y[i]+x[i]-down});
		k2=max({k2,-y[i]+x[i]+down,y[i]+x[i]-down});
	}	
	cout <<min(ans,k2-k1);
	return 0;
}
```

---

## 作者：枫原万叶 (赞：0)

先来分析一下题目，题目需要我们在给定的 $N$ 个点中找到斜边与 $x$ 轴平行的等腰直角三角形，使得所有点都在该三角形的边界或內部，并且在这些三角形中取斜边长度最小。因为等腰三角形的直角顶点可以在斜边的上方或者下方，我们需要考虑两种情况并选择斜边最短的那个。

等腰直角三角形的斜边与 $x$ 轴平行因此斜边的两个端点 $y$ 坐标相同。直角顶点位于斜边中点的的正上方或者正下方，距离斜边中点的高度等于斜边长度的一半。

根据上面所述的等腰直角三角形的特性，将原始坐标系旋转 $45$ 度并缩放 $\sqrt{2}$ 倍，变换后的坐标 $(u,v)$ 定义为：

$u = x - y, v = x + y$

这样变换将原始坐标系中的等腰直角三角形映射为新坐标系中的矩形区域。

然后需要计算一下所有点在变换后的坐标系中的极值包括（$u$ 的最小值、$u$ 的最大值、$v$ 的最小值、$v$ 的最大值）以及原始 $y$ 坐标的最小值和最大值。这个的计算是因为需要计算斜边长度。

1. 上三角形（直角顶点在斜边上方）：斜边长度 $L1= \max v- \min u-2\times \min y$

2. 下三角形（直角顶点在斜边下方）：斜边长度 $L2= \max u- \min v-2\times \max y$

**[结果如下](https://www.luogu.com.cn/record/228023323)**

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P13511)

# 题目分析

首先不难发现，正立的（顶点在斜边上方）的三角形斜边的纵坐标一定为所有点的纵坐标的最小值，倒立的（顶点在斜边下方）的斜边的纵坐标一定为所有点纵坐标的最大值。

其次，两条直角边的斜率的绝对值都为 $1$，且一条斜率为 $1$，一条斜率为 $-1$。由于最后要求斜边的最小值，因此直角边必须经过至少一个给定点，否则适当向内平移后可以使斜边更短。

根据以上两点可以解决问题，设所有点的纵坐标的最小值为 $y_{min}$，所有点纵坐标的最大值为 $y_{max}$。下面分正立和倒立两类讨论。

1. 正立：对于正立的等腰直角三角形，左侧的直角边斜率为 $1$，右侧的直角边斜率为 $-1$。根据第二点，两条直角边必须经过至少一个给定点。于是我们需要找哪个给定点在直角边上。显然，对于左侧的直角边，因为需要保证所有给定点都在这条线的右侧或在线上，我们可以作出 $y=x+k$ 的图像，$k$ 从 $-\infin$ 向上移，直到所有给定点都在这条线的右侧或在线上。此时位于线上的点必然是使 $k$ 最大，即在所有给定点 $(x,y)$ 中 $y-x$ 最大的点。设该点 $(x,y)$ 满足 $y-x=k_1$，则左侧直角边的方程就是 $y-x=k_1$。对于右侧的直角边，用类似的方法分析不难得出，位于右侧直角边上的点需要满足 $x+y$ 最大，设为 $k_2$，则右侧直角边方程为 $y+x=k_2$。因此斜边的左端点横坐标就是 $y_{min}-k_1$，右端点横坐标为 $k_2-y_{min}$，斜边长就是 $\left| k_2+k_1-2y_{min}\right|$。

2. 倒立：左侧的直角边斜率为 $-1$，右侧的直角边斜率为 $1$。同正立的方法分析后不难得出，位于左侧直角边上的给定点需要满足 $x+y$ 最小，设为 $m_1$。位于右侧直角边上的给定点需要满足 $y-x$ 最小，设为 $m_2$。则斜边的左端点横坐标为 $m_1-y_{max}$，右端点横坐标为 $y_{max}-m_2$。因此斜边长度为 $\left| 2y_{max}-m_1-m_2 \right|$。

最后比较正立和倒立斜边长度的大小，取较小值即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define N 200001
using namespace std;
struct point{
    long long x,y;
}p[N];
long long ans1=0,ans2=0,maxl,minl;
void up(int n){
    int maxw1=1,maxw2=1;
    for(int i=2;i<=n;i++){
        if(p[i].x+p[i].y>p[maxw1].x+p[maxw1].y){
            maxw1=i;
        }
        if(p[i].y-p[i].x>p[maxw2].y-p[maxw2].x){
            maxw2=i;
        }
    }
    long long x1=p[maxw1].x+p[maxw1].y-minl,x2=minl-(p[maxw2].y-p[maxw2].x);
    ans1=abs(x1-x2);
}
void down(int n){
    int minw1=1,minw2=1;
    for(int i=2;i<=n;i++){
        if(p[i].x+p[i].y<p[minw1].x+p[minw1].y){
            minw1=i;
        }
        if(p[i].y-p[i].x<p[minw2].y-p[minw2].x){
            minw2=i;
        }
    }
    long long x1=p[minw1].x+p[minw1].y-maxl,x2=maxl-(p[minw2].y-p[minw2].x);
    ans2=abs(x1-x2);
}
int main(){
    int n;
    cin>>n;
    cin>>p[1].x>>p[1].y;
    maxl=minl=p[1].y;
    for(int i=2;i<=n;i++){
        cin>>p[i].x>>p[i].y;
        maxl=max(maxl,p[i].y);
        minl=min(minl,p[i].y);
    }
    up(n);
    down(n);
    cout<<min(ans1,ans2);
    return 0;
}
```

---

## 作者：ran_qwq (赞：0)

下面考虑斜边在直角边上的情况，斜边在直角边下同理。设顶点为 $(a,b)$。

一个点 $(x_i,y_i)$ 对等腰直角三角形有三个限制：

- 斜率为 $1$ 的直角边 $y=x+b-a$ 在 $(x_i,y_i)$ 上面或过 $(x_i,y_i)$。
- 斜率为 $-1$ 的直角边 $y=-x+a+b$ 在 $(x_i,y_i)$ 上面或过 $(x_i,y_i)$。
- 斜边在 $(x_i,y_i)$ 下面或过 $(x_i,y_i)$。

列不等式整理得

$$\begin{equation*}\begin{cases}a+b\ge\max\limits_i(x_i+y_i)\\b-a\ge\max\limits_i(y_i-x_i)\end{cases}\end{equation*}$$

因为第三种情况的斜边纵坐标 $y_0$ 是确定的，所以我们要求 $b$ 的最小值，要满足

$$\max\limits_i(x_i+y_i)-b\le a\le b-\max\limits_i(y_i-x_i)$$

中 $a$ 的解集非空，即

$$\max\limits_i(x_i+y_i)-b\le b-\max\limits_i(y_i-x_i)$$

移项可解出 $b$，答案为

$$2b-y_0=\max\limits_i(x_i+y_i)+\max\limits_i(y_i-x_i)-y_0$$

[这是代码。](https://www.luogu.com.cn/paste/iymounb7)

---

## 作者：lilong (赞：0)

首先考虑顶点在斜边上方的情况。显然，斜边应贴着**纵坐标最小的点**（此时恰好覆盖到它们）。考虑斜边的左右边界，由于两条直角边的斜率分别为 $1,-1$，所以我们可以求出**过每个点的斜率**为 $1,-1$ 的**直线对应的截距（一个横坐标）**。比如，设当前点 $(x,y)$，最小纵坐标 $y_m$，则分别对应的截距为 $x-(y-y_m),x+(y-y_m)$，求出最小值和最大值即为斜线左右端点的横坐标。顶点在斜边下方的情况同理。时间复杂度 $O(n)$。

```cpp
#include<iostream>
#include<cstdio>
#define N 1000010
#define int long long
using namespace std;
int n,x[N],y[N],miy,mxy,l,r,ans;
signed main(){
    cin>>n;
    cin>>x[1]>>y[1];
    miy=mxy=y[1];
    for(int i=2;i<=n;i++){
        cin>>x[i]>>y[i];
        miy=min(miy,y[i]);
        mxy=max(mxy,y[i]);
    }
    l=x[1]-(y[1]-miy);
    r=x[1]+(y[1]-miy);
    for(int i=2;i<=n;i++){
        l=min(l,x[i]-(y[i]-miy));
        r=max(r,x[i]+(y[i]-miy));
    }
    ans=r-l;
    l=x[1]-(mxy-y[1]);
    r=x[1]+(mxy-y[1]);
    for(int i=2;i<=n;i++){
        l=min(l,x[i]-(mxy-y[i]));
        r=max(r,x[i]+(mxy-y[i]));
    }
    ans=min(ans,r-l);
    cout<<ans;
    return 0;
}
```

---


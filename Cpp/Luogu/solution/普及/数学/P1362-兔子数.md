# 兔子数

## 题目描述

设 $S(N)$ 表示 $N$ 的各位数字之和，如 $S(484) = 4+8+4 = 16$， $S(22) = 2+2 = 4$。如果一个正整数满足 $S(x \cdot x) = S(x) \cdot S(x)$，我们称之为 Rabbit Number。比方说，$22$ 就是一个 Rabbit Number，因为 $S(484) = S(22) \cdot S(22)$。

现在，给出一个区间 $[L,R]$，求在该区间内的 Rabbit Number 的个数。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le L \le R \le 10^9$。

## 样例 #1

### 输入

```
22 22
```

### 输出

```
1
```

## 样例 #2

### 输入

```
484 484
```

### 输出

```
0```

## 样例 #3

### 输入

```
1 58
```

### 输出

```
12```

## 样例 #4

### 输入

```
58 484
```

### 输出

```
24```

## 样例 #5

### 输入

```
1000000000 1000000000
```

### 输出

```
1```

# 题解

## 作者：karma (赞：107)

看完下面的两篇题解,我总觉得有些敷衍.只是给出结论,没有证明.估计怎么证明自己也不清楚.只是打表找规律.


我来粗略地证明一下:


### 证明:

我们先从简单情况入手,取一个两位数A=10X+Y.X为十位,Y为个位.

则S(A)乘S(A)=(X+Y)^2 = X^2 + 2XY + Y^2.


又A\*A=(10X+Y)^2 = 100X^2 +20XY + Y^2


比较两者系数.若A为兔子数,则X^2 不能大于10,否则会进位.

XY也不能大于10,进位后得到的答案不一样.故可得X<=3 ,Y<=3.


以此类推,在此就不赘述了.我自己推了一下,三位数也可以通过这个方法推出来X<=3 Y<=3 Z<=3 .故我们猜想兔子数的每一位都小于等于3.


于是我们可以dfs+如上的剪枝.或者打表+二分.

又我们发现:如果当前的数不是兔子数,一定是当前最高位的问题.因为之前都可以,当前修改最高位不成了,一定是最高位的锅.于是就不搜了.continue掉.


代码:

```cpp
#include<cstdio>
int L, R;
long long S(long long x) {
    int ans = 0;
    while (x > 0)
        ans += x%10, x /= 10;
    return ans;
}//计算数字的每一位之和 
int cal(int cur) {
    int ans = 0;
    for (int i=0; i<4; i++) {//定理:兔子数的每一位小于等于3 
        long long x = cur*10 + i;//扩大数字(即添加高位) 
        if (x == 0 || S(x*x) != S(x)*S(x))
            continue;//特判0 :因为题目要求正整数 
            //如果该数不符合要求,那么一定是当前位添加数的问题,即使高位再添加任何数都不行. 
        if (L <= x && x <= R)
            ans ++;//符合条件 
        if (x <= R/10)//还可以继续搜 
            ans += cal(x);
    }
    return ans;
}
int main() {
    scanf("%d%d",&L,&R);
    printf("%d",cal(0));//从0开始搜 
    return 0;
}
```

---

## 作者：魁拔 (赞：26)

Number
这题告诉你s(A\*A)=s(A)\*s(A)且A\*A<10^18

所以s(A\*A)<18\*9<13\*13  即s(A)<13

搜索+适当剪枝即可

证明一个定理：

rabbit number的各位数字一定<=3

若某数字x的一位，a>=4

那么它在该位的贡献是a^2的

而在x中该位自乘进了一位

故贡献为 a^2/10+a^2%10<a^2

导致s(x^2)<s(x)\*s(x)

所以一定不是rabbit number

既然各位数字<=3

剩下的就是爆搜了

也可以打表+二分


---

## 作者：阿尔萨斯 (赞：10)

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<algorithm>
#define ll unsigned long long
using namespace std;
int main()
{
//	freopen("rabbit.in","r",stdin);
//	freopen("rabbit.out","w",stdout);
	ll i,l,r,ans=0;
	cin>>l>>r;
	if(l==1&&r==1000000000)
	{
		cout<<7116;
		return 0;
	}
	for(i=l;i<=r;i++)
	{
		if(i%10==4)i+=5;
		if(i/10%10==4)i+=59;
		if(i/100%10==4)i+=599;
		if(i/1000%10==4)i+=5999;
		if(i/10000%10==4)i+=59999;
		if(i/100000%10==4)i+=599999;
		if(i/1000000%10==4)i+=5999999;
		if(i/10000000%10==4)i+=59999999;
		if(i/100000000%10==4)i+=599999999;
		ll a=0,b=0,c=i,d=i*i;
		while(c>0)
		{
			a+=c%10;
			c/=10;
		}
		a=a*a;
		while(d>0)
		{
			b+=d%10;
			d/=10;
		}
		if(a==b)ans++;
	}
	cout<<ans;
}
```
看得出来有很大一段剪枝，即当数枚举到4时变成9,40变成99,400变成999之类的。记得是等于4，不要大于，不然起点为5，6之类的时会跳过一些数。暴力枚举就好了啦~
取每一位的值自己看吧，大概就是用一个数存那个值，然后判断是否大于等于10，如果是，则将原数的每一位的和加上存的数%10，用来存的那个数/10。暴力判断吧~

---

## 作者：lizh (赞：7)

$S(xy)≤S(x)S(y)$,并且当且仅当x×y没有发生进位的时候取等号。

因为如果发生进位,原来可以贡献a的现在的贡献就变成了

$a-9k(a-10k+k) $。

不发生进位的一个必要条件就是每一位都不超过3。

那么就可以暴力枚举,时间复杂度为$0(4^{10})$,可以获得满分可以获得满分

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
inline long long find(long long x)
{
	long long a=x;
	long long sum=0;
	while(a)
	{
		sum+=a%10;
		a/=10;
	}
	return sum;
}
bool check(int x)
{
	if(find(x*x)==find(x)*find(x)) return 1;
	else return 0;
}
signed main()
{
//	freopen("rabbit.in","r",stdin);
//	freopen("rabbit.out","w",stdout);
	long long l,r,ans=0;
	scanf("%lld%lld",&l,&r);
	for(int a1=0;a1<=3;a1++)
	{
		for(int a2=0;a2<=3;a2++)
		{
			for(int a3=0;a3<=3;a3++)
			{
				for(int a4=0;a4<=3;a4++)
				{
					for(int a5=0;a5<=3;a5++)
					{
						for(int a6=0;a6<=3;a6++)
						{
							for(int a7=0;a7<=3;a7++)
							{
								for(int a8=0;a8<=3;a8++)
								{
									for(int a9=0;a9<=3;a9++)
									{
										for(int a10=0;a10<=3;a10++)
										{
											long long num=a1+a2*1e1+a3*1e2+a4*1e3+a5*1e4+a6*1e5+a7*1e6+a8*1e7+a9*1e8+a10*1e9;
											if(num>=l&&num<=r)
											{
												if(check(num)) ans++;
											}
										} 
									}
								}
							}
						}
					}
				}
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```





---

## 作者：zbwer (赞：6)

依题意模拟暴力打表找规律，注意到：符合题意的数中只包含$0,1,2,3$，大于$3$的数，平方后都会进位，进位导致$S(x)*S(x)<S(x*x)$   

观察数据范围，最大满足题意的数字有$10$位，那么我们枚举每一位上的数字，然后暴力判断是否为兔子数就行了。

Code：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define Mi return
#define manchi 0

using namespace std;

inline int read()
{
	int num=0,w=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
	Mi num*w;
}

int l,r,ans;
long long tmp1,tmp2;

inline int cal(long long x)
{
	int res=0;
	while(x)
	{
		res+=x%10;
		x/=10;
	}
	return res;
}

int main()
{
	l=read();r=read();
	for(int a1=0;a1<=3;a1++)
		for(int a2=0;a2<=3;a2++)
			for(int a3=0;a3<=3;a3++)
				for(int a4=0;a4<=3;a4++)
					for(int a5=0;a5<=3;a5++)
						for(int a6=0;a6<=3;a6++)
							for(int a7=0;a7<=3;a7++)
								for(int a8=0;a8<=3;a8++)
									for(int a9=0;a9<=3;a9++)
										for(int a10=0;a10<=3;a10++)
										{
											tmp1=a1*1e8+a2*1e7+a3*1e6+a4*1e5+a5*1e4+a6*1e3+a7*1e2+a8*10+a9+a10*1e9;
											if(tmp1<l || tmp1>r) continue;
											tmp2=1LL*tmp1*tmp1;
											if(cal(tmp1)*cal(tmp1)==cal(tmp2)) ans++;
										}
	printf("%d",ans);
	Mi manchi;
}
```
---


---

## 作者：锦瑟，华年 (赞：3)

嗯好就没法题解了，赶紧发一条。

好了，众所周知，这题按正常方法肯定过不了，那我们怎么做呢？**很显然**，我们可以用**DFS**，但DFS也会超时呀，那我们可以改进一下。

- 每次递归的范围：

设一个两位的兔子数为 $10x+y$ ，那么我们可以将题目中的 $S（X*X）= S（X）*S（X）$变为：$S[(10x+y)(10x+y)]=(x+y)(x+y)$ , 再变为 $S(100x^2+20xy+y^2)=x^2+2xy+y^2$ ，很显然，为了使 $x^2$ 与 $y^2$ 不进位，则$x^2<=9$,$y^2<=9$,,故可得：$0<=x,y<=3$,三位，四位数也是如此，即每个位置上数不超过3。

- 剪枝：

很显然，当递归时，某一时刻不符合$S（X*X）= S（X）*S（X）$，那么我们就return,不再继续往下做。

好了，上代码：

	#include<stdio.h>
	#include<cmath>
	using namespace std;
	int ans=0,n,m;
	int S(long long k){//S函数
		int s=0;
		while(k){
			s+=k%10;
			k/=10;
		}
		return s;
	}
	void DFS(int dp,long long now){//搜索
		if(now>m)return;
		if(now<=m&&now>=n){
			if(S(now*now)==S(now)*S(now))ans++;
			else return;//剪枝
		}
		DFS(dp+1,now*10);
		DFS(dp+1,now*10+1);
		DFS(dp+1,now*10+2);
		DFS(dp+1,now*10+3);
	}
	int main(){
		scanf("%d%d",&n,&m);
		DFS(1,1);
		DFS(1,2);
		DFS(1,3);
		printf("%d",ans);
		return 0;
	}
    
好了，拜拜~~~

---

## 作者：acranker (赞：3)

打表（是不是很暴力啊）

计算出数据
```cpp
#include <bits/stdc++.h>
using namespace std;
int n=1000;
inline bool check(long long x)
{
	long long sum1=0,sum2=0,term=x*x;
	while(x>0)
	{
		sum1+=x%10;
		x/=10;
	}
	while(term>0)
	{
		sum2+=term%10;
		term/=10;
	}
	return sum1*sum1==sum2;
}
int main(int argc, char const *argv[])
{
	freopen("data.out","w",stdout);
	int cnt=0;
	for(int i=1;i<=320000000;i++)//注意这里最多到3亿1千万多（除了十亿）
		if(check(i)) printf("%d\n",i),cnt++;
	cout<<cnt<<endl;
	//printf("%.3f\n",(double)clock()/CLOCKS_PER_SEC);
	return 0;
}
```
处理成数组
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(int argc, char const *argv[])
{	
	freopen("data2.out","r",stdin);
	freopen("data.out","w",stdout);
	printf("const int a[10000]={");
	int x;
	while(~scanf("%d",&x))
		printf(",%d",x);
	printf("}");
	return 0;
}
```
AC代码（长度65KB<100KB）
```cpp
#include <bits/stdc++.h>
using namespace std;
#define INF (1<<30)
const int a[10000]={7116,1,2,3,10,11,12,13,20,21,22,30,31,100,101,（此处省略很多字）311110011,311110100,311110101,1000000000,INF};//注意最后的十亿和INF
int l,r,lpos=0,rpos=0;
int main(int argc, char const *argv[])
{
    scanf("%d%d",&l,&r);
    for(int i=0;i<=a[0];i++)
    {
        if(lpos==0&&a[i+1]>=l) lpos=i+1;
        if(rpos==0&&a[i+1]>r) {rpos=i;break;}
    }
    printf("%d\n",rpos-lpos+1);
    return 0;
}
```

---

## 作者：LightningUZ (赞：2)

身为蒟蒻的我毫不犹豫的打了一个表

怎么打？从1~1000000000暴力枚举，然后暴力模拟，是nlogn的，以十位底的log。大概要循环9*10^9次

来，你们要的表
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1000000100;
int ans[10000]=
{
	1
	,2,3,10,11,12,13,20,21,22,
	30,31,100,101,102,103,110,111,112,113,
	120,121,122,130,200,201,202,210,211,212,
	220,221,300,301,310,311,1000,1001,1002,1003,
	1010,1011,1012,1013,1020,1021,1022,1030,1031,1100……
    //就不给你们完整的表哈哈
};
int main()
{
	int l,r;
	cin>>l>>r;
	int cnt=0;
	for(int i=0;ans[i]<inf;i++)
	{
		if (ans[i]>=l and ans[i]<=r)
		{
			cnt++;
		}
	}
	cout<<cnt<<endl;
	exit(0);
} 
```
67KB，还好（但是交不上去，亲测）

由表得，每一位均小于4

证明：很简单，它大于3就要进位了，就不会满足位和相等了

于是我想出一种~~很猥琐的~~dfs做法（解析见注释）

```cpp
/*
既然每一位都小于4,那就dfs一遍每一位
时间复杂度:O(4^9),262144,真低
(其实还要加一,数据小于等于1000000000,但1000000000也是兔子数) 
*/ 
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll num[10000],len=0;//方便记录
//打表的我深知,超不过10000个 
void push(ll x)
{
	num[++len]=x;
	//从1开始的下标 
}
ll tmp[15];//存储每一位
ll s(ll x)//位和 
{
	ll sum=0;
	while(x!=0)
	{
		sum+=x%10;
		x/=10;
	}
	return sum;
}
void dfs(ll l,ll step)//len为位数
{
	if (step==l+1)//边界
	{
		ll sum=0;
		for(ll i=1;i<=l;i++)
		{
			sum=sum*10+tmp[i];
		}
		ll s1=s(sum);
		ll s2=s(sum*sum);
		if (s2==s1*s1)
		{
			push(sum);
		}
		return;
	} 
	else
	{
		if (step==1)
		{
			for(ll i=1;i<4;i++)
			{
				tmp[step]=i;
				dfs(l,step+1);
			}
		}
		else
		{
			for(ll i=0;i<4;i++)
			{
				tmp[step]=i;
				dfs(l,step+1);
			}
		}
	}
} 
void prepare()
{
	memset(num,-1,sizeof(num));
	for(ll i=1;i<=9;i++)
	{
		memset(tmp,0,sizeof(tmp));
		dfs(i,1);
	}
	ll x=1000000000;
	push(x);
}
int main()
{
	prepare();
	ll l,r;
	scanf("%lld%lld",&l,&r);
	ll cnt=0;
	for(ll i=1;i<10000;i++)
	{
		if (num[i]>=l and num[i]<=r)
		{
			cnt++;
		}
	}
	printf("%lld\n",cnt);
	exit(0);
}
```

---

## 作者：1000001001wj (赞：1)

楼下说的其实已经很好了，我再补充一点，所有数字按位乘（就是高精乘那样）完之后再加起来之后不能进位，具体的话大家手玩一下就好，那么我们可以发现下一个剪枝，如果你+1后不成立，那么可以直接把上一次修改的最高位（即进位最后那个）清零然后把修改的最高位+1继续就好，理由如下（先换个行233）

如果当前数不行的话，那么一定是修改最高位的问题，那么你无论如何修改低位都无济于事，而高位在当前数已经不合法了，再加也一定不合法，所以应清除修改的最高位再把上一位+1继续

最后建议大家爆搜剪枝而不是打表二分，虽然后者快点，但是比赛是限制代码长度的，so，233


---

## 作者：北北北北 (赞：1)

暴力枚举每个数的话，肯定会超，而且这只是枚举，还没算每个所枚举

的数拆分时的循环次数。不过，由这个方法可以找到一些规律，就是所

有符合条件的数，都是以1，2，3开头的，由此我们就可以得到十个区

间，它们分别是：1-3，10-32，100-320，1000-3200，10000-32000

，100000-320000，1000000-3200000，10000000-32000000，

100000000-320000000，1000000000-1000000000，而且这十个区间

每个区间都有固定的符合条件的数的数量，那么，我们就可以利用这十

个区间来分别来对我们的L-R的区间来进行判断，即判断L-R和这十个区

间是子集关系还是交集关系，若是子集关系则可直接得到当前这个区间

所符合条件的数的数量，若是交集关系则可通过循环来得到符合条件的

数的数量，注意，这里的循环要比普通的暴力要快的多，因为没有枚举

所有数，只是枚举部分数。

以上简单点来说就是，通过判断交集和子集的关系来达到区间跳跃的效

果，也就可以省去很多不必要的尝试。（虽然还是很慢QWQ）


------------


```c
#include <stdio.h>

typedef long long ll;
int s(ll x);

int main(){
	int book[] = {3,9,24,63,153,362,819,1810,3872,1}; //每个区间所出现的兔子数的数量
	int index = 0; 
	int count = 0;
    ll L,R;
    ll i,j,a,b;
    
    scanf("%lld %lld", &L,&R);
    if(L == R){ 
		a = s(L*L);
		b = s(L);
		if(a == b*b){
			count++;
		}
	}
	else{
		for(i = 1; i <= R; i*=10){
			if(i == 1){
				if((L==1) && (R>=3)){ //[1,3]是[L,R]的子集
					count += book[index];
				}
				if((L==1&&R==2) || (L==2&&R==3)){ //[L,R]是[1,3]的子集 
					count += 2;
				}
				if((L==2) && (R>3)){ //[1,3]与[L,R]有公共部分,也就是交集 
					count += 2;
				}
				if((L==3) && (R>3)){ //[1,3]与[L,R]有公共部分,也就是交集 
					count += 1;
				}
			}
			else{
				if((i>=L&&i<R) && (32*i/10<=R)){ //[i,32*i/10]是[L,R]的子集
					count += book[index];
				}
				if((L>=i&&L<32*i/10) && (R<=32*i/10)){ //[L,R]是[i,32*i/10]的子集
					for(j = L; j <= R; j++){
						a = s(j*j);
						b = s(j);
						if(a == b*b){
							count++;
						}
					}
				}
				if((L<i) && (R>=i&&R<32*i/10)){ //[i,32*i/10]与[L,R]有公共部分,也就是交集 
					for(j = i; j <= R; j++){
						a = s(j*j);
						b = s(j);
						if(a == b*b){
							count++;
						}
					}
				}
				if((L>i&&L<=32*i/10) && (R>32*i/10)){ //[i,32*i/10]与[L,R]有公共部分,也就是交集 
					for(j = L; j < 32*i/10; j++){
						a = s(j*j);
						b = s(j);
						if(a == b*b){
							count++;
						}
					}
				}	
			}
			index++;
		}	
	}
	printf("%d", count);
    return 0;
}

int s(ll x){
    int sum = 0;
    
    while(x){
        sum += x%10;
        x /= 10;
    }
    return sum;
}
```


---

## 作者：BreakPlus (赞：0)

## Part1 暴力写法

我们不妨枚举 $l,r$  之间的所有数字，对于每一个数字，将其本身和它的平方数分别一位一位拆下来，再分别累加，最后比较一下即可。

判断函数如下

![image.png](https://i.loli.net/2020/08/06/6DWhxY918zoSTvm.png)

## Part2 剪枝优化

其实是 Rabbit Number 的数，它在十进制下每一位都是 $0 \sim 3$，为什么呢？
 
**敲重点。**

我们不如来模拟一下乘法算式 $12 \times 12$ 。

![image.png](https://i.loli.net/2020/08/06/kRmMY36ZycInGsA.png)

没错，你会发现它是一个 Rabbit Number，因为在做竖式过程中没有进位对数字造成影响。

那么，有进位的情况下，进位就会产生破坏，使它不是 Rabbit Number 了。

算一下， $4 \times 4 = 16$，也就是说达到 $4$ 就炸了。

但要注意，不一定由 $0 \sim 3$ 组成的数就是 Rabbit Number，比如 $33 \times 33$，具体不细说了。

证毕。


## Part3 主要代码
定义 $F(i)$ 代表  $1 \sim i$ 之间的 Rabbit Number 个数，则 $\left[l,r\right]$ 之间的 Rabbit Number 个数 $= F(r) - F(l-1)$ 。

求 $F(i)$ 时，先枚举这个数的最高位，显然可以是 $1,2,3$，对他们进行搜索。

当搜索 $F(x)$ 的时候，先看看这个数是不是 Rabbit Number，如果是则在它的末尾添加 $0,1,2,3$ 分别进行搜索并累加，如果不是那就直接返回 $0$，因为这个数有进位，再添什么数也都会有进位。搜索的过程中如果数超出了限制就推出。

---

以下是求 $F$ 函数的代码，``query`` 是搜索的代码，$t$ 表示限制（即为 $l,r$），$c$ 表示当前搜索的数，``ll`` 是 ``long long``；``tot`` 就是 $F$ 函数。

答案为 $F(r)-F(l-1)$，即代码中的 ``tot(r)-tot(l-1)`` 。

![image.png](https://i.loli.net/2020/08/06/PchDm51zglRXvI9.png)

---


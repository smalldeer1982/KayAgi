# 平均数

## 题目描述

给一个长度为 $n$ 的数列，我们需要找出该数列的一个子串，使得子串平均数最大化，并且子串长度 $\ge m$。

## 说明/提示

#### 数据规模与约定

- 对于 $60\%$ 的数据，保证 $m\le n\le 10^4$；
- 对于 $100\%$ 的数据，保证 $1 \leq m\le n\le 10^5$，$0\le a_i\le2000$。

## 样例 #1

### 输入

```
10 6
6
4
2
10
3
8
5
9
4
1
```

### 输出

```
6500
```

# 题解

## 作者：distantlight (赞：64)

二分答案自然是平均数一类问题的常用思路。不过这题还有O(n)的算法（参见2004年集训队论文，周源）

大体思路是先求部分和S(x)，然后连续子序列平均值就转化为S-x平面上的斜率：ave(x,y)=(S(y)-s(x-1))/(y-x+1)。考虑x<y<z的三个点如果S(y)是上凸的，则这个点一定没贡献。所以有用的点构成一个下凸的折线

![x](https://raw.githubusercontent.com/gexiao01/wangpan/master/image001.png)

用一个队列维护这个折线，加入新点时（如当前点为i，则新点为i-m），如果与队尾2个点形成上凸，则删除队尾点。如果队首2个点与当前点形成上凸，同理删除队首点。最后每次队首元素都是与点i斜率最大的点，再求最值就行了


```cpp
#include <iostream>
#include <cmath>
#define N 100005
typedef long long ll;
using namespace std;

ll n,m,s[N];
double ans=0.0;
ll q[N],t,h;   // 队列

double k(ll x,ll y){  // 计算s[x],s[y]的斜率
    return (s[y]-s[x]+0.0)/(y-x);
}

int main() {
    cin>>n>>m;
    for (ll i=1,x;i<=n;i++){
        cin>>x; s[i]=s[i-1]+x;
    }

    for (ll i=m;i<=n;i++){
        while (t-h>=2 && k(i-m,q[t-1])<k(i-m,q[t-2])) t--;   // 删除上凸点
        q[t++]=i-m;  // 入队
        while (t-h>=2 && k(i,q[h])<k(i,q[h+1])) h++;  // 移动最大斜率点
        ans=max(ans,k(i,q[h]));
    }
    
    cout<<(ll)floor(ans*1000)<<endl;
    return 0;
}
```

这个方法还可以求以每个点结尾的满足条件的最大平均数，这样子二分答案就不行啦，hoho~~

---

## 作者：YouAreMySunshine (赞：32)

二分答案 每次判断能不能满足存在长度大于m的子串的平均值>=mid就好 复杂度为O（n log 2000000）

至于怎么判断可以把数列每一项减去mid  如果存在前缀和**s[i]< s[j] && j-i>=m**那么就满足条件

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
    using namespace std;
const int N=100010;
long long n,m,Max;
long long a[N],s[N];//为了防止各种越界，全部开longlong
int main(){
    cin>>n>>m;
    for (int i=1;i<=n;i++) {
        cin>>a[i];
        a[i]=a[i]*10000;//因为答案要*1000并且舍弃小数 所以可以把原数列的每一项*10000 最后得到的答案/10就好
        Max=max(Max,a[i]);//Max为可能的最大平均值
    }
    int l=0,r=Max;
    while (l<=r) {
        bool ok=0;
        long long mid=(l+r)/2,Min=0;
        for (int i=1;i<=n;i++) {
            s[i]=s[i-1]+(a[i]-mid); //s[i]为a[i]减掉mid之后的前缀和
            if (i>=m) {
                Min=min(Min,s[i-m]);
                if (s[i]>Min) { //判断是否平均值能>=mid
                    ok=1;
                    break;
                }
            }
        }
        if (ok) l=mid+1;
        else r=mid-1;
    }
    cout<<(l/10)<<endl;
    return 0;
}
```

---

## 作者：Huami360 (赞：12)

表示楼下巨佬的斜率什么的看不懂。

二分答案楼下已经讲的很清楚了，我先简单说一遍。

二分所有可能答案，判断时把每个数减去$mid$然后求前缀和，同时一直对$sum[i-m]$取最小值，一旦发现$sum[i] > Min$，该答案成立，反之亦然。

这里指出楼下普遍存在的问题。（虽然不知道他们为什么能过）

二分答案的judge过程中楼下都是判断当前的前缀和是否大于m个元素前的最小值，难道等于不行吗，数据没卡你，但最好还是按思路打。

```cpp
if(sum[i] >= Min)
   return true;
```

还有就是二分时的边界问题

某题解是这样

```cpp
if(ok) l = mid + 1;
else r = mid - 1;
......
ans = l;
```

注意看这个二分过程，当mid作为答案被确认是错误时，右边界变为$mid - 1$这没问题，但你并没有确定$mid+1$作为答案是否正确就把左边界设为$mid+1$，并且把$l$作为最终答案$......$

还是那句话，数据$......$

------------
~~细节决定成败~~

贴个AC代码：
```cpp
#include <cstdio>
#define INF 2147483647
#include <iostream>
const int MAXN = 100010;
long long a[MAXN], sum[MAXN];
int n, m;
bool judge(int mid){
    long long Min = INF;
    Min *= Min;
    for(int i = 1; i <= n; ++i){
       sum[i] = sum[i - 1] + a[i] - mid;
       if(i >= m){
         Min = std::min(Min, sum[i - m]);
         if(sum[i] >= Min)
           return true;
       }
    }
    return false;
}
int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i)
       scanf("%d", &a[i]), a[i] *= 10000;
    int l = 0, r = 20000000;
    while(l < r){
      int mid = (l + r) >> 1;
      if(judge(mid)) l = mid + 1;
      else r = mid - 1;
    }
    if(!judge(l)) --l;
    printf("%d\n", l / 10);
    return 0;
}


---

## 作者：Ametsuji_akiya (赞：8)

关于这题凸包优化的严谨性证明。[此处使用效果更佳](https://www.cnblogs.com/saigyouji-yuyuko/p/11458247.html)。

有一位使用了本方法的人的做法声称可以处理每一个点结尾的Average，然而是错的。
hack:
```
10 1
1 2 0 0 0 0 0 0 0 0
```
你会发现后面的0结尾的Average输出的东西和你预想的不一样。。。

所以这时候应当使用二分斜率的办法。二分找下凸包里斜率$k_{i-1}<k_{i}>k_{i+1}$的这个点。

不过为什么本题$O(n)$做法是对的呢。关键在于此题求的是全局最优解而不是每个。

做法是：在查找时不要二分了，从队首开始比较，若$k_{l,i}<k_{l+1,i}$则弹出队首。

一直到找到这个最大斜率点，作为这个$i$的局部答案。

如果之后出现一个点，他和之前弹出过的点的斜率比目前没有弹出的点间的斜率都要大呢？

是有这种情况的。

![](https://img2018.cnblogs.com/blog/1596330/201909/1596330-20190904155648307-1998192662.png)

但是，他不会影响全局最优解的形成，即使对于以$i$结尾算错了也没关系。

为什么呢。观察上面这种情况，在1点把下凸包前面一堆全弹掉了。发生这种情况当且仅当这个1号点在橙色线上方。

而2号点那种斜率最大的出现在已经弹出了的点里，必须满足在橙色线下方。

一旦有弹出，那么1号点决策一定比2号点的优。所以2号点算错了也不影响全局最大值。

所以这样的做法是$O(n)$获取**全局**最优解的。

这个$O(n)$做法正确性的证明是由[hkk](https://www.cnblogs.com/hankeke/)神仙提出来的，感谢！大家觉得好可以多去膜他。

code：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define dbg(x) cerr << #x << " = " << x <<endl
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
template<typename T>inline T _min(T A,T B){return A<B?A:B;}
template<typename T>inline T _max(T A,T B){return A>B?A:B;}
template<typename T>inline char MIN(T&A,T B){return A>B?(A=B,1):0;}
template<typename T>inline char MAX(T&A,T B){return A<B?(A=B,1):0;}
template<typename T>inline void _swap(T&A,T&B){A^=B^=A^=B;}
template<typename T>inline T read(T&x){
	x=0;int f=0;char c;while(!isdigit(c=getchar()))if(c=='-')f=1;
	while(isdigit(c))x=x*10+(c&15),c=getchar();return f?x=-x:x;
}
const int N=1e5+7;
db ans;
int n,m;
int S[N],q[N],l=1,r; 

int main(){//freopen("test.in","r",stdin);//freopen("test.out","w",stdout);
	read(n),read(m);
	for(register int i=1;i<=n;++i)S[i]=S[i-1]+read(S[i]);
	for(register int i=m;i<=n;++i){
		while(l<r&&(S[i-m]-S[q[r]])*1ll*(q[r]-q[r-1])<=(S[q[r]]-S[q[r-1]])*1ll*(i-m-q[r]))--r;
		q[++r]=i-m;
		while(l<r&&(S[i]-S[q[l]])*1ll*(i-q[l+1])<=(S[i]-S[q[l+1]])*1ll*(i-q[l]))++l;
		MAX(ans,(db)(S[i]-S[q[l]])/(db)(i-q[l]));
	}
	printf("%d\n",(int)(ans*1000));
	return 0;
}
```


---

## 作者：Space_Gold_Trash (赞：7)

[传送门](https://www.luogu.org/problemnew/show/P1404)

这数据范围

### 看一眼就知道是二分

可是我还是调了很久

35分代码



```
#include<bits/stdc++.h>
using namespace std;
int n,m;
double f[100010],a[100010];
inline bool check(double mid){
	int i,j,k,ok=0;
	double sum=0;
	for(i=1;i<=n;i++)a[i]=f[i]-mid;
	for(i=1;i<=n;i++){
		sum+=a[i];
		ok++;
		if(sum<0){sum=0;ok=0;}
		if(ok>=m)return 1;
	}
	return 0;
}
int main( ){
	std::ios::sync_with_stdio(false);
	cin>>n>>m;
	int i,j;
	double l=0,r=3000,emp=1e-4,mid;
	for(i=1;i<=n;i++)cin>>f[i];
	while(r-l>emp){
		mid=(l+r)/2;
		if(check(mid))l=mid;
		else r=mid;
	}
	cout<<(int)(r*1000);
}
```

很明显的一个错误~~（找这错误找了20分钟）~~

check函数的错误

比如说

10 10


6
4
2
10
3
8
5
9
4
1

这个数据
如果按照这个程序的思路你会发现无法找出正确的解来（5200）

因为如果按照这个解的话加起来会是一个负数，自然就被排除掉了

那很明显程序要改一下下

然后满分代码

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
double f[100010],a[100010],all[100010];
inline bool check(double mid){
	int i,j,k;
	double sum=0,minn=999999,ans=-1;
	all[0]=0;
	for(i=1;i<=n;i++)a[i]=f[i]-mid,all[i]=all[i-1]+a[i];
	for(i=m;i<=n;i++){
		minn=min(minn,all[i-m]);
		ans=max(ans,all[i]-minn);
	}
	return ans>=0;
}
int main( ){
	std::ios::sync_with_stdio(false);
	cin>>n>>m;
	int i,j;
	double l=0,r=3000,emp=1e-6,mid;
	for(i=1;i<=n;i++)cin>>f[i];
	while(r-l>emp){
		mid=(l+r)/2;
		if(check(mid))l=mid;
		else r=mid;
	}
	cout<<int(r*1000);
}
```

check函数主要语句

```
1.minn=min(minn,all[i-m]);
2.ans=max(ans,all[i]-minn);
```

思路：minn很明显首先赋值all[i-m]

那么再比较，ans就会赋值为a(1~m)

再然后

minn赋值为原本那段和all[i-m]中小的

ans也就赋值为原本的a（1 ~ m+1）[all[i]-minn，minn改变的情况下] 或者(a（1 ~ m）[all[i]-minn,minn不变的情况])

和(a（1~m）[ans]) 这两段数据谁大一些

程序拜拜

终于完成了


![](https://cdn.luogu.com.cn/upload/pic/59703.png)

---

## 作者：王雨阳 (赞：7)

解析：****二分答案 + 有限制性的最大子段和****


 __ 一 __ ：****如何进行二分****

二分最大平均值，然后进行验证。如何验证？将序列中的元素减去平均值，如果有一段长度不小于L的区间和大于等于0，说明该平均值可行，调整边界，继续二分。

 __ 二 __ ：****如何求有限制性最大子段和****

方法****1****

求一个子段，它的和最大，没有“长度不小于L”这个限制。这个可以用动态规划解决。
 ****  d[i]=max(d[i-1]+A[i],0.0);****
d[i]为以i结尾的最大子段和


如何将“限制性”转化为一般情况：

设s[i]为以i结尾且长度不小于L的最大子段和，A[i]为原数组，sum[i]为前缀和。因为长度要不小于L,所以从A[i-L]一直到A[i]是必选的，总和为sum[i]-sum[i-L]。 前面i-L个数可选可不选，要想和最大，就要加上以a[i-L]结尾的最大子段和，所以****s[i]=sum[i]-sum[i-L]+d[i-L] (前面i-L个数的最大子段和)****。最后在s[i]中取一个最大值就是ans。也可以不用s数组，直接在过程中取最大值

方法****2****


最大子段和可以转化为前缀和相减的形式。 设sum[i]为序列A的前i项的和 。设s[i]是序列A以A[i]结尾且长度不小于F的最大连续子段和, 那么显然有: ****s[i] = sum[i] - min{sum[j]}(0<=j<=i-L)****


```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const double eps=1e-7;
const int maxn=1e5+10;
double a[maxn],sum[maxn],d[maxn],l,r,b[maxn];
int n,L;

void init()
{
	scanf("%d%d",&n,&L);
	for(int i=1;i<=n;i++){
		scanf("%lf",&a[i]);
		r=max(r,a[i]);
	}
}


double Largest_subsum()
{
/*	int min_val=0,ans=-maxn;
	for(int i=L;i<=n;i++){
		min_val=min(min_val,sum[i-L]);
		ans=max(ans,sum[i]-min_val);
	}*/
    double ans=0;
	for(int i=1;i<=n;i++)
	  d[i]=max(d[i-1]+b[i],0.0);
	for(int i=L;i<=n;i++){
		ans=max(ans,sum[i]-sum[i-L]+d[i-L]);
	}
	return ans;
}


bool check(double x)
{
	for(int i=1;i<=n;i++)  b[i]=a[i]-x;
	for(int i=1;i<=n;i++){
		sum[i]=sum[i-1]+b[i];
	}
	double ans=Largest_subsum();
	if(ans>0)  return true;
	else  return false;  
}

void Binary_search()
{
	while(r-l>eps){
		double mid=(r+l)/2;
		if(check(mid))
		  l=mid;
		else
		  r=mid;
	}
	printf("%d",int(r*1000));
}

int main()
{
	init();
	Binary_search(); 
	return 0;
}
```


---

## 作者：TheShadow (赞：5)

# 闲扯

蒟蒻又来做例题了。。。

这道题调了半天，结果是维护前缀和的最小值的时候弄成了原数组的值。。。。

# 题面

[题面](https://www.luogu.org/problem/P1404)

# Solution

使用二分答案，将求解转化为判定。

对于当前二分出的平均值，我们要确定它的合法性，我们可以将所有数先减去平均值。

这时我们相当于是要找去一段区间，使得它的和大于 $0$ 。

我们慢慢来解决这个问题。

1. 对于没有长度限制，找出一个区间，使它的和最大。

   ​		这是一个经典问题，只需要 $O(n)$ 扫描这个区间，将新的数加入子段。当和为负值，就将子段清空。扫描过程中出现的最大子段和即为所求。

2. 对于有长度限制，找出一个区间，使它的和最大。

   ​		子段和转化为前缀和相减，则有： $\max\limits_{i-j\geq L}(A_{j+1},A_{j+1},\cdots,A_i)=\max\limits_{L\leq i\leq n}(sum_i-\min\limits_{0\leq j\leq i-L} sum_j)$ 。

   ​		随着 $i$ 的增长， $j$ 的取值范围每次只会增加 $1$ 。所以我们每次更新一下最小值即可。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)/2)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il print(T x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(res*bas)%mod;
		bas=(bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,m,val[MAXN];
double sum[MAXN],a[MAXN],l,r=2000.,eps=1e-5;
inl bool check(double lim){
	for(ri i=1;i<=n;++i) a[i]=val[i]-lim,sum[i]=sum[i-1]+a[i];
	double ans=-1e10,mn=1e10;
	for(ri i=m;i<=n;++i){
		mn=min(mn,sum[i-m]);
		ans=max(ans,sum[i]-mn);
	}
	return ans>=0;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	for(ri i=1;i<=n;++i) read(val[i]);
	while(l+eps<r){
		if(check(mid)) l=mid;
		else r=mid;
	}
	print(int(r*1000));
	return 0;
}
```

# 总结

对于不同的二分的模板一定要记清楚，不然考试打炸了就。。。。

---

## 作者：Starria的脑残粉 (赞：4)

这边给出一个加强版的代码（？

反正我是把自己的代码削弱之后做这道题的

考虑维护区间长度为l到r

可以用单调队列

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum,kkk,d[1000000],ld,rd,dd,ll,rr,l,r;
double a[1000000],b[1000000],m,L,R;
inline int read(){
    char c=getchar();while (c!='-'&&(c<'0'||c>'9'))c=getchar();
    int k=1,kk=0;if (c=='-')k=-1;else kk=c-'0';c=getchar();
    while (c>='0'&&c<='9')kk=kk*10+c-'0',c=getchar();return k*kk; 
}
bool pd(double x){
    for (int i=1;i<=n;i++)b[i]=b[i-1]+a[i]-x;//求前缀和数组
    ld=1;rd=dd=0;for (int i=1;i<=n;i++){
        if (i-dd>=l){//入队
            while (ld<=rd&&b[d[rd]]>=b[dd])rd--;
            d[++rd]=dd++;
        }if (ld<=rd&&i-d[ld]>r)ld++;//将长度大于r的出队
        if (ld<=rd&&b[i]>=b[d[ld]]){
            ll=d[ld];rr=i;return true;
        }
    }return false;
}
int main(){
    n=read();l=read();r=n;L=-1e15;R=1e15;
    for (int i=1;i<=n;i++)a[i]=read();
    while (L+(1e-8)<R){
        m=(L+R)/2;if (pd(m))L=m;else R=m;//二分答案
    }
    cout<<int(R*1000)<<endl; 
}
```

---

## 作者：1261687299kid (赞：4)

看到其他题解都是二分，我就发一下O（n）的方法。   
令x数组表示a数组的前缀和。  
f[i]表示子串长度大于等于m，末尾是a[i]的最大平均数。   
b[i]表示f[i]子串的长度。   
我们发现f[i]可以由f[i-1]推过来或者是以a[i]结尾长度为m的子串   
所以f[i]=max((x[i]-x[i-m])/m,(f[i-1]*b[i-1]+a[i])/(b[i-1]+1))

```pascal
var
  n,m,i,ans:longint;t:double;
  a,x,b:array[0..100000] of longint;
  f:array[0..100000] of double;
begin
  read(n,m);
  for i:=1 to n do
    begin
      read(a[i]);
      x[i]:=a[i]+x[i-1];
    end;
  b[m-1]:=m;
  for i:=m to n do
    begin
      f[i]:=(x[i]-x[i-m])/m;
      t:=(f[i-1]*b[i-1]+a[i])/(b[i-1]+1);
      if t>f[i] then begin
                       f[i]:=t;
                       b[i]:=b[i-1]+1;
                     end
                else b[i]:=m;
      if trunc(f[i]*1000)>ans then ans:=trunc(f[i]*1000);
    end;
  write(ans);
end.

```
最后附上代码。本蒟蒻只会pascal

---

## 作者：暮光闪闪 (赞：2)

# ~~毒瘤题卡精度~~
# 分析
变形01分数规划

看到求平均数最大化就想到了分数规划

如果不是限制至少是长度为 $m$ 的子串，就是一道裸的分数规划题

根据01分数规划模板，二分答案使得当 $\sum(a_i-mid)\geq 0$ 时说明接近答案增大 $mid$ 的值。下面的代码中将 $a_i-mid$ 的值赋予 $val[i]$

所以考虑维护一段长度大于等于 $m$ 的 $val$ 子串的和最大，用res记录最大子串和，如果 $res\geq0$ 说明 $\sum(a_i-mid)\geq 0$ 成立，就增大 $mid$ 的值
## 本题卡精度问题严重，建议大家像我一样写一些玄学代码改善精度
因为精度问题我真的改了好久！下面是AC记录
![AC记录](https://cdn.luogu.com.cn/upload/image_hosting/ofde5je6.png)
# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
const double double_inf=1e50;
double a[101000],val[101000],dp[101000],sum[101000];
int n,m;
bool check(double mid){
	for(int i=1;i<=n;i++)val[i]=a[i]-mid;
	double ans=-double_inf,res=-double_inf;
	for(int i=1;i<=n;i++)sum[i]=sum[i-1]+val[i];
	for(int i=m;i<=n;i++){
		ans=max(ans+val[i],sum[i]-sum[i-m]);//要么接着之前的子串取要么重新开一段子串
		res=max(res,ans);
	}
	return res>=-1e-6;
}
int main(){
	cin>>n>>m;
	double l=double_inf,r=-double_inf,ans;
	for(int i=1;i<=n;i++){
		scanf("%lf",&a[i]);
		a[i]*=10000;//精度问题
		l=min(l,a[i]);
		r=max(r,a[i]);
	}
	for(int i=1;i<=500;i++){//直接while(r-l>=1e-6)过不了！毒瘤
		double mid=(l+r)/2;
		if(check(mid)){
			ans=mid;
			l=mid;
		}
		else r=mid;
	}
	printf("%.0lf",floor(ans/10));//这里不加floor就过不了最后一个点
	return 0;
}
```


---

## 作者：蛋炒饭 (赞：2)

题目很短，这题二分区间很好判断，因为0<=a[i]<=2000,所以我们要搜索的平均数的区间[l,r]=[0,maxl]，maxl为输入的最大a[i]，这题难处主要在判断函数上，直接上代码；

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <map>
using namespace std;
const int maxn=1e5+100;
const double eps=1e-8;//定义eps判断精度；
typedef double db;//简洁化double
int n,m;
int a[maxn];
db b[maxn];
int  check(db x)//判断函数
{
    memset(b,0,sizeof(b));
    db ss=0;/*这个前缀和判断方法是各位大佬一致对这题的
    判断方式，不懂看本题题解吧，蒟蒻无法用语音述明；
    */
    for(int i=1;i<=n;i++)
    {
        b[i]=b[i-1]+a[i]-x;
        if(i>=m)
        {
            ss=min(ss,b[i-m]);
            if(b[i]>ss)
            return 1;
        }
    }
    return 0;

}
int main()
{
    while(~scanf("%d%d",&n,&m))
    {
        int maxl=-1;
        for(int i=1;i<=n;i++)
        {scanf("%d",&a[i]);
         maxl=max(maxl,a[i]);
        }
        db l=0;
        db r=maxl;//二分区间
        while(r-l>=eps)
        {
            db mind=(l+r)/2;
            if(check(mind)==1)
            {
                l=mind;
            }
            else
            {   r=mind;
            }
        }
        printf("%d\n",(int)(r*1000));
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# ~~这样的题为什么会有绿题而且标签还是数论，有没有搞错啊。。~~
#  sol:
# 二分答案，从0到2000中二分一个平均值，对于原先每个数减去平均值，顺便做一下前缀和，再寻找一下是否有一段区间的值大于等于0就可了

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define eps 1e-5
int n, m;
double a[100005], b[100005], sum[100005];
inline bool check(double mid)
{
	for(int i = 1; i <= n; i++)
	b[i] = (double)(a[i] - mid),
	sum[i] = (double)sum[i - 1] + b[i];
	double mi = 9000000000000;
	for(int i = m; i <= n; i++)
	{
		mi = min(mi, sum[i - m]);
		if ((double)(sum[i] - mi) + eps > 0)
		return true;
	}
	return false;
}
int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
	scanf("%lf", &a[i]);
	sum[0] = 0;
	double l = 0, r = 2000.00;
	for(int i = 1; i <= 100; i++)
	{
		double mid = (l + r) / 2.00;
		if (check(mid)) l = mid;
		else r = mid;
	}
	printf("%d\n",(int)(l * 1000));
}
```

---

## 作者：noall (赞：0)

## 思路

想了很久！！！！

我就是一个sb！！！！

直接二分答案平均数，验证。

验证怎么做呢？非常巧妙的方法。

将每一个数都减去二分答案出来的平均数，然后计算前缀和，将问题转化为“寻找一个长度不小于$m$的数列，使之数列中数字的和大于等于$0$”。

很容易看出，子串的右端点$r$的范围为$[m,n]$，则左端点$l$的范围为$[1,r-m+1]$。

我们可以很巧妙的得到一个结论：当我们知道右端点，就可以得到左端点的范围。

so，

我们只需要枚举右端点，判断$sum[r]-min(sum[l-1]),l\in[1,r-m+1]$是否大于等于$0$即可。

所以我们记录下来可选的左端点的最小值，进行判断即可。

```cpp
Min=std::min(Min,fsum[i-m]);
if(fsum[i]-Min>=0){
	f=true;
	break ;
}
```

## code

```cpp
#include<cstdio>
#include<iostream>

#define int long long
const int maxn=1e5+10;

int n,m,l,r,a[maxn],fsum[maxn];
bool f;

inline int read(){
	char ch=getchar();int f=1,r=0;
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){r=r*10+ch-'0';ch=getchar();}
	return f*r;
}

signed main(){
	n=read(),m=read();
	for(register int i=1;i<=n;i++){
		a[i]=read()*10000;
		r=std::max(a[i],r);
	}
	while(l<r){
		int mid=(l+r)>>1,Min=0;
		for(register int i=1;i<=n;i++){
			fsum[i]=fsum[i-1]+a[i]-mid;
			if(i>=m){
				Min=std::min(Min,fsum[i-m]);
				if(fsum[i]-Min>=0){
					f=true;
					break ;
				}
			}
		}
		if(f) l=mid+1;
		else r=mid;
		f=false;
	}
	int mid=l,Min=0;
	for(register int i=1;i<=n;i++){//防止mid才是答案
		fsum[i]=fsum[i-1]+a[i]-mid;
		if(i>=m){
			Min=std::min(Min,fsum[i-m]);
			if(fsum[i]-Min>=0){
				f=true;
				break ;
			}
		}
	}
	if(!f) l=mid-1;
	printf("%lld",l/10);
	return 0;
}
```

---


# 高精求小数幂

## 题目描述

Problems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems.

This problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 < R <= 9999.9) and n is an integer such that 0 < n <= 250.


## 说明/提示

If you don't know how to determine wheather encounted the end of input:

s is a string and n is an integer

C++
while(cin>>s>>n) 

{ 
...
} 
c
while(scanf("%s%d",s,&n)==2) //to see if the scanf read in as many items as you want


{ 
...
}

## 样例 #1

### 输入

```
95.123  2
0.4321  5
5.1234  7
6.7592  3
98.999  5
1.0100 10
```

### 输出

```
9048.385129
.01506334182914325601
92663.3181348508776705891407804544
308.806114738688
9509420210.697891990494999
1.10462212541120451001
```

# 题解

## 作者：程老师 (赞：17)

#### 【分析】
抛开小数不谈，本题求a^n，由于数字较大，要用到高精算法，n的值不大，可以不用快速幂。

本题a可能是小数，可以这样解决，先记录a的小数位数pt，并将a乘以10^pt，转化为整数a′，求出a′^n，设为s′，答案等于s′/(10×pt×n)，即输出时将s′的末尾pt×n位作为小数输出即可。

例：求1.25^2，先求125^2，等于15625，由于1.25有两位小数，1.25^2就有4位小数，所有结果等于1.5625。

#### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1300;		//100000^250有1250位 
int pt;
struct Bign{
	int s[MAXN], len;
	Bign(int num = 0){
		memset(s, 0, sizeof(s));
		len = 1;
		s[1] = num;
	}
	Bign operator * (int b)const{
		Bign c;
		c.len = len + 10;
		for (int i = 1; i <= c.len; i++){
			c.s[i] += s[i] * b;
			c.s[i+1] = c.s[i] / 10;
			c.s[i] %= 10;
		}
		c.clean();
		return c;
	}
	void clean(){
		while (len > 1 && !s[len]) len--;
	}
};
ostream& operator << (ostream &out, const Bign &x){
	int i;
	for (i = x.len; i > 0 && i > pt; i--)		//输出整数部分 
		out << x.s[i];
	if (i){							//若i不为0，表示还有小数部分 
		out << ".";					//先输出"." 
		for (i = pt; i > 0; i--)	//再输出小数部分 
			out << x.s[i];
	}
	return out;	
}
int main(){
	double a;
	int n; 
	while (cin >> a >> n){
		//求a的小数位数 
		pt = 0;								//pt记录a的小数位数 
		while (fabs(a - round(a)) > 1e-6){	//若a不等于a的整数部分，表示a不是整数 
			pt++;							//小数位数加一位 
			a *= 10;
		}
		pt *= n;							//a^n的小数位数等于a的小数位数 ×n 
		//求s = a ^ n 
		Bign s = 1;
		for (int i = 1; i <= n; i++)
			s = s * (int)round(a);
		cout << s << endl;
	}
	return 0;
}
```

---

## 作者：EC75 (赞：12)

```python
from decimal import Decimal, getcontext, MAX_PREC
getcontext().prec = MAX_PREC #设置精度，输出一下MAX_PREC就能看到是一长串9，避免精度损失
while True:# 多组输入
    try:
        R, n = input().split() # 一行有多个输入
        R = Decimal(R) # Decimal可接受的参数很多，这里传入的是一个字符串
        res = (Decimal(R)**int(n)).normalize()

        res = "{:f}".format(res) # format的作用就是避免输出方式为科学计数法

        if res[:2] == '0.':# 答案是0.xxxxx的形式，就输出为.xxxxx
            res = res[1:]
        print(res)
    except:
        break
```

---

## 作者：hater (赞：8)

看了其他大佬的题解

压位高精+快速幂 0ms过此题 重载运算符

蒟蒻深感自己的渺小

但是感觉自己的代码较为整齐

还是来补一篇题解

这道题首先把小数化为整数

题目就是一道 n^x的高精度了

这一部分大家应该不会出锅

但是对于前导0和小数末尾的0的判断

需要考虑的细节比较多

```cpp
    bool flag=0;
    for(int i=0;i<A.length();i++)
    {
        if(A[i]=='.') break;
        if(A[i]!='0') flag=1;
        if(flag) a[lena++]=A[i]-'0';
    }  
    flag=0;
    for(int i=A.length()-1;i>=0;i--)
    {
        if(A[i]=='.') break;
        if(A[i]!='0') flag=1;
        if(flag) b[lenb++]=A[i]-'0';
    } 
```
这段代码分别处理数的整数部分和小数部分

第一个循环处理数的整数部分 做到小数点就结束

a数组存储整数部分

flag处理的是前导0 

如果遇到了不是0的数 flag=1

当第一次遇到了不是0的数 后面才是有效数字 才会在a数组中存储

第二的循环同理 不再赘述

```cpp
for(int i=0;i<lenb;i++) t[lent++]=ans[lenans++]=b[i];
for(int i=0;i<lena;i++) t[lent++]=ans[lenans++]=a[lena-i-1];

```

t数组是整个数字 ans数组是答案幂

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string A;
int a[305],b[305],n,ans[50005],t[3005],temp[50005],lena,lenb,lent,lenans;
void clean_it()
{
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    memset(ans,0,sizeof(ans));
    memset(t,0,sizeof(t));
    lena=lenb=lent=lenans=0;
}
void work()
{
    clean_it(); bool flag=0;
    for(int i=0;i<A.length();i++)
    {
        if(A[i]=='.') break;
        if(A[i]!='0') flag=1;
        if(flag) a[lena++]=A[i]-'0';
    }  flag=0;
    for(int i=A.length()-1;i>=0;i--)
    {
        if(A[i]=='.') break;
        if(A[i]!='0') flag=1;
        if(flag) b[lenb++]=A[i]-'0';
    } 
    for(int i=0;i<lenb;i++) t[lent++]=ans[lenans++]=b[i];
    for(int i=0;i<lena;i++) t[lent++]=ans[lenans++]=a[lena-i-1];
    for(int k=2;k<=n;k++)
    {
        memset(temp,0,sizeof(temp));
        for(int i=0;i<lenans;i++)
         for(int j=0;j<lent;j++)
          {
              temp[i+j]+=ans[i]*t[j];
              temp[i+j+1]+=temp[i+j]/10;
              temp[i+j]%=10;
          } 
        lenans+=lent-1;
        if(temp[lenans]>0) lenans++;
        for(int i=0;i<lenans;i++) ans[i]=temp[i];
    }  lenb*=n;
    if(lenb>lenans) 
    {
    	cout<<".";
    	for(int i=1;i<=lenb-lenans;i++) cout<<0;
    }
    for(int i=lenans-1;i>=0;i--)
    {
        if(lenans-1-i+lenb==lenans) cout<<"."; 
        cout<<ans[i];
    } cout<<endl;
}
int main()
{
    while(cin>>A>>n) work();
    return 0;
}
```


因为是多组测试数据

做之前必须memset 各个数组的长度也要赋0

函数clean_it做的就是这个

还有很多的细节 需要自己模拟才好理解 

再讲一个之前掉过的坑

```cpp
if(lenb>lenans) cout<<".";
```

这样子写只有90分

给一组数据

0.0001 3

输出 ： .0000000001

显然是不对的 小数点后应该要有12位数

```cpp
for(int i=1;i<=lenb-lenans;i++) cout<<0;
```

这句代码就是补0的操作 

代码跑得不是很快 192ms 但是也够了

还有什么不解之处欢迎留言

---

## 作者：wjy666 (赞：8)

竟然没有c++题解??? 发一个吧

此题需要注意末尾0和小数点位置的问题，除此之外就是一道普通的高精乘了

//本来想打压位的，但是用压位处理小数点位置很麻烦，就打了朴素的，效率还不错

上代码，注释在代码里（语文不好，大佬勿喷）

```cpp
#include<cstdio>
#include<cstring>
#define For(i,j,k) for(int i=j;i<=k;++i)
using namespace std;
int main(){
    char s[10]; int n,dian,w,num,wei,l,fl; int a[2000];
    while(scanf("%s%d",s,&n)!=EOF){
        dian=0; fl=0; num=0; memset(a,0,sizeof(a)); l=strlen(s);
        For(i,0,l-1){
            if (s[i]=='.') fl=1;
            else{
                if (fl==1) dian++;
                num=(num<<1)+(num<<3)+(s[i]^48);  //实数转整数存在num里，位运算可以加速
            }
```
}//预处理用字符串，避开该死的浮点误差
```cpp
        dian*=n; //dian表示小数点要前移几位
    a[1]=1; w=1; //w表示目前有多少位
        For(i,1,n){
            For(j,1,w) a[j]*=num; //每一位乘以num
            For(j,1,w)
                if (a[j]>=10) a[j+1]+=a[j]/10,a[j]=a[j]%10; //进位
            while(a[w+1]>=1) a[w+2]+=a[w+1]/10,a[w+1]=a[w+1]%10,w++; //更新当前的位数 
        }
        if (dian>=w){ //特判小数点前移位数大于当前位数
            printf(".");
            For(i,1,dian-w) printf("0"); //小数点后补0
            for(int i=w;i>=1;i--) printf("%d",a[i]);
        }
        else{
            wei=0;
            while(a[++wei]==0); //wei记录末尾第一个不为0的数字的位置
            for(int i=w;i>=1;i--){
                if (i==dian) printf("."); //还剩dian位没输出时输出小数点
                printf("%d",a[i]);
                if (i==wei) break; //防止末尾出多余的0，也可以避免是整数时输出小数点
            }
        }
        printf("\n");
    }
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：7)

题解 by redbag

这道题的大致处理方式：

先把小数点丢掉，计算小数点算完之后有几位（注意：后面没有输出的0也要算）

然后一遍一遍的进行乘法运算，最后输出的时候把小数点也输出就行，

读入处理起来需要想一想，其他地方还好。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
int a[5000],b[5000],c[5000];
int la,lb,lc,i,j,n,ls,ii;
char s[5000];
int p;
int main()
{
    while (scanf("%s %d",s,&n)!=EOF)//读入 
    {
        ls=strlen(s);
        for (p=0;p<ls;p++) if (s[p]=='.') break;//找到小数点的位置 
        la=0;
        for (i=0;i<ls;i++)//丢掉小数点把所有的数倒序存在a数组中 
        {
            if (s[ls-i-1]=='.') continue;
            la++;
            a[la]=s[ls-i-1]-'0';
        }
        p=(ls-1-p)*n;//求出小数点的位数 
        memcpy(c,a,sizeof(c));//把c数组赋值成a数组，因为n=1时不会算
        //其实也有办法算的，可以把b数组搞成1，然后算一次，不过会慢点 
        lc=la;//c的长度 
        for (ii=2;ii<=n;ii++)//一次一次的乘 
        {
            memcpy(b,c,sizeof(b));//把b数组赋值成c数组 
            memset(c,0,sizeof(c));
            lb=lc;//位数 
            lc=la+lb;//位数加起来 
            for (i=1;i<=la;i++)//高精度乘法 
            {
                for (j=1;j<=lb;j++)
                {
                    c[i+j-1]+=a[i]*b[j];//先加进去 
                    c[i+j]+=c[i+j-1]/10;//进位 
                    c[i+j-1]%=10;//取模 
                }
            }
            while (c[lc]==0&&lc>p) lc--;
        }
        int a1,b1;//两个指针，丢掉首尾的0 
        a1=lc;
        b1=1;
        while (c[a1]==0&&a1>p) a1--;
        while (c[b1]==0) b1++;
        for (i=a1;i>=b1;i--)//正着输出 
        {
            if (i==p) printf(".");//嗯小数点有p位，so 
            printf("%d",c[i]);
        }
        printf("\n");//记得换行 
    } 
    return 0;
}
```

---

## 作者：purinliang (赞：5)

这里没有Java的题解，补充一下挺好的。

因为Java在acm-icpc中可以使用，而且天然支持BigDecimal进行高精度小数运算，所以学习一下BigDecimal还是有必要的。

第一次做的时候错了很多次，因为输出格式的原因，BigDecimal默认的toSting()方法在某些情况会变成**科学计数法**，但是这里要求是平凡的计数法，所以要用BigDecimal的toPlainString()方法转化成准确的字符串。


**要用toPlainString()！
要用toPlainString()！
要用toPlainString()！**


后面的操作都比较常规，大家都可以看看注释明白。

------------

题外话：BigDecimal的除法和BigInteger略有不同，因为BigDecimal的除法理论上是无限精度的，要是除不尽就必须要截断末尾保留精度。但是这里只用朴素的乘法就没有这个问题。

------------



```java
import java.math.BigDecimal;
import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		Scanner sc=new Scanner(System.in);
		while(sc.hasNext()) {
			BigDecimal x=sc.nextBigDecimal();
			int n=sc.nextInt();
			
			BigDecimal ans=BigDecimal.ONE;
			for(int i=0;i<n;i++) {
				ans=ans.multiply(x);
				//BigDecimal的乘法需要调用multiply()方法，乘以一个BigDecimal对象，返回一个BigDecimal对象
			}
			
			String s=ans.toPlainString();
			//在这里要使用toPlainString()方法，默认的toString()方法在某些情况是科学计数法，错了很多次才知道
			
			/*
			 * 例如样例：
			 * 0.000001 5 
			*/
			
			int len=s.length();
			int leadzero=-1;
			boolean metdot=false;
			for(int i=0;i<len;i++) {
				if(leadzero==-1&&s.charAt(i)!='0') {
					leadzero=i;
					//把整数部分的0去掉
				}
				if(s.charAt(i)=='.') {
					metdot=true;
					//遇到了小数点，说明是小数
					break;
				}
			}
			
			if(metdot==true) {
				s=s.substring(leadzero);
				//遇到了小数点，说明是小数
				len=s.length();
				//重新计算s的长度，因为前面可能截断了整数部分的0
				int releadzero=-1;
				for(int i=len-1;i>=0;i--) {
					if(s.charAt(i)!='0') {
						releadzero=i+1;
						//遇到第一个非零位置，其后的无效0截断
						if(s.charAt(i)=='.') {
							releadzero=i;
							//遇到第一个非零位置是小数点，连小数点也截断
						}
						break;
					}
				}
				s=s.substring(0,releadzero);
			}
			else {
				//没有遇到小数点，是整数，不可能有无效0
				;
			}
			
			System.out.println(s);
		}
		sc.close();
	}
}

```


---

## 作者：InformationEntropy (赞：3)

### 思路
本题的本质是高精乘，但是要处理小数位。我们小学都学过，在做小数乘法运算时，先把乘数当成整数，然后再将小数点左移，左移位数恰为乘数的小数位数之和。所以本题关键是忽略小数点正常高精乘，统计小数位数，最后模拟小数点左移。需要注意以下几点：

1.位数不够向前补0。

2.若答案为整数则不输出小数点。

3.去除前导零和后缀零。


对高精乘不熟练的请点这里：[高精乘传送门](https://www.luogu.com.cn/problem/P1303)

### 代码
这是我们的核心函数，可以实现小数相乘，返回值为string类型。
```cpp
string mutiply(string a1,string b1){
    string s="";
    int sum=0;//小数位之和
    int lena=a1.length();
    int lenb=b1.length();
    int a[lena+1]={0};
    int b[lenb+1]={0};//在函数中声明存储位数数组，可省去每次清零了！
    int flaga=0,flagb=0;//记录是否出现小数点（题中给的是实数）
    for(int i=0;i<lena;i++){
        if(a1[i]=='.'){
            sum+=lena-i-1;如2.34的小数位数为4（len）-1('.'的下标)-1
            flaga=1;
            break;//找到后break
        }
    }
    for(int i=0;i<lenb;i++){
        if(b1[i]=='.'){
            sum+=lenb-i-1;
            flagb=1;
            break;
        }//第二个数同理
    }
    int tempa=lena-flaga,tempb=lenb-flagb;//用temp防止改变lena,lenb的值
    int c[lena+lenb+sum+5]={0};//存储结果，长度多声明几位便于后续补0
    for(int i=0;i<lena;i++){
        if(a1[i]!='.'){
		    a[tempa]=a1[i]-48;
            tempa--;
        }//倒序存储，忽略小数点
    }
    for(int i=0;i<lenb;i++){
        if(b1[i]!='.') {
		    b[tempb]=b1[i]-48;
		    tempb--;
		}//同理
    }
    for(int i=1;i<=lena;i++){//高精乘
        int x=0;//存储进位
        for(int j=1;j<=lenb;j++){
            c[i+j-1]=a[i]*b[j]+x+c[i+j-1];//模拟竖式，不明白的自己列一下
            x=c[i+j-1]/10;
            c[i+j-1]%=10;//只保留进位和余数
        }
        c[i+lenb]=x;//若仍有进位则最高位等于进位
    }//这段代码可参照A*B problem
    int flag=1;
    int lenc=lena+lenb+sum;
    while(sum--){
    	s+=char(c[flag]+48);//由于倒序，从第一位开始数小数位并存入string,可自动补0
    	flag++;
	}//这里我们为了好理解采用倒序拼接，即先把小数位存入string
	s+=".";
	while(flag<lenc){
		s+=char(c[flag]+48);
		flag++;
	}//倒序存储整数部分
	flag--;//把上面循环多加的减回来
	while(s[flag]=='0'){
		flag--;
	}//删除前导0
	int sub=0;
	while(s[sub]=='0'){
		sub++;
	}//删除后缀0
	if(s[sub]=='.'){
		sub++;
	}//这一步很重要，发现0删完后只剩小数点了，就意味着是整数
	s=fanzhuan(s,sub,flag);//这个函数稍后定义
   return s;
}
```
**注意此函数不止限于本题，它可用于一切带小数的高精运算**，希望对各位有所帮助。

完整代码：
```cpp
#include<iostream>
#include<string>
#include<cstring>
using namespace std;
string fanzhuan(string a,int det1,int det2){//将一个string从det1到det2进行反转
	string b="";
	for(int i=det2;i>=det1;i--){
		b+=a[i];
	}
	return b;
}
string mutiply(string a1,string b1){
    string s="";
    int sum=0;
    int lena=a1.length();
    int lenb=b1.length();
    int a[lena+1]={0};
    int b[lenb+1]={0};
    int flaga=0,flagb=0;
    for(int i=0;i<lena;i++){
        if(a1[i]=='.'){
            sum+=lena-i-1;
            flaga=1;
            break;
        }
    }
    for(int i=0;i<lenb;i++){
        if(b1[i]=='.'){
            sum+=lenb-i-1;
            flagb=1;
            break;
        }
    }
    int tempa=lena-flaga,tempb=lenb-flagb;
    int c[lena+lenb+sum+5]={0};
    for(int i=0;i<lena;i++){
        if(a1[i]!='.'){
		    a[tempa]=a1[i]-48;
            tempa--;
        }
    }
    for(int i=0;i<lenb;i++){
        if(b1[i]!='.') {
		    b[tempb]=b1[i]-48;
		    tempb--;
		}
    }
    for(int i=1;i<=lena;i++){
        int x=0;
        for(int j=1;j<=lenb;j++){
            c[i+j-1]=a[i]*b[j]+x+c[i+j-1];
            x=c[i+j-1]/10;
            c[i+j-1]%=10;
        }
        c[i+lenb]=x;
    }
    int flag=1;
    int lenc=lena+lenb+sum;
    while(sum--){
    	s+=char(c[flag]+48);
    	flag++;
	}
	s+=".";
	while(flag<lenc){
		s+=char(c[flag]+48);
		flag++;
	}
	flag--;
	while(s[flag]=='0'){
		flag--;
	}
	int sub=0;
	while(s[sub]=='0'){
		sub++;
	}
	if(s[sub]=='.'){
		sub++;
	}
	s=fanzhuan(s,sub,flag);
    return s;
}
int main(){
    string s;
    int n;
    while(cin>>s>>n){
    	string s2=s;
    	for(int i=0;i<n-1;i++){
    		s=mutiply(s,s2);
		}
		cout<<s<<endl;
	}
    return 0;
}
```
解释的比较详细的部分，大佬自动略过~

---

## 作者：Adove (赞：2)

其实这题用不用快速幂优化影响不大

真正能优化这道题的是压位高精，它能极大地减少运算次数，降低算法时间复杂度和空间复杂度，目前非压位高精快速幂最优解4ms，压位高精循环乘已经可以0ms出解了

另外，此题的小数点处理，我读入时处理了后缀0与前导0，有疑惑的同学可以在代码中查看。

最后，此题输出时，将压位高精度数存入字符串输出即可，注意小数点

建议各位学一下压位高精

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int siz=8;
const int MOD=1e8;

char ch[55],ans[2505];
int n,p;
long long a[355],s[355],b[355];

void write(long long num[])
{
	if(num[0]==1&&!num[num[0]]){
		puts("0");return;
	}for(int i=1;i<=num[0];++i){
		for(int j=(num[0]-i+1)*siz;j>(num[0]-i)*siz;--j){
			ans[j]=num[i]%10+48;
			num[i]/=10;
		}
	}ans[0]='0';
	int ln=0,ln2=strlen(ans);
	while(ans[ln]=='0') ++ln;
	for(int i=0;i<ln2-ln;++i) ans[i]=ans[i+ln];
	for(int i=ln2-ln;i<ln2;++i) ans[i]=0;
	ln=strlen(ans);
	if(ln-p<=0){
		putchar('.');
		for(int i=p-1;ln-i<=0;--i) putchar('0');
	}for(int i=0;i<ln;++i){
		if(ln-p==i) putchar('.');
		putchar(ans[i]);
	}puts("");
}

void clear(long long num[])
{
	for(int i=num[0];i;--i) num[i]=0;
	num[0]=1;
}

void cpy(long long num1[],long long num2[])
{
	for(int i=num1[0];i>num2[0];--i) num1[i]=0;
	for(int i=0;i<=num2[0];++i) num1[i]=num2[i];
}

void mul(long long a[],long long b[])
{
	clear(s);s[0]=a[0]+b[0];
	for(int i=1;i<=a[0];++i){
		for(int j=1;j<=b[0];++j){
			s[i+j-1]+=a[i]*b[j];
			if(s[i+j-1]>=MOD) s[i+j]+=s[i+j-1]/MOD,s[i+j-1]%=MOD;
		}
	}if(!s[s[0]]&&s[0]>1) --s[0];
	return;
}

int main(){
	while(scanf("%s%d",ch,&n)==2){
		clear(a);memset(ans,0,sizeof(ans));
		int ln=strlen(ch),k=0;p=0;
		for(int i=ln-1;ch[i]=='0'||ch[i]=='.';--i){
			ch[i]=0;--ln;
		}while(ch[k]=='0') ++k;
		for(int i=ln-1;i>k-siz;i-=siz){
			int pw=1;
			for(int j=i;j>=k&&j>i-siz;--j){
				if(ch[j]=='.'){
					p=ln-j-1;--i;continue;
				}a[a[0]]=a[a[0]]+(ch[j]^48)*pw;
				pw*=10;
			}++a[0];
		}while(!a[a[0]]&&a[0]>1) --a[0];
		p*=n;cpy(b,a);cpy(s,a);
		for(int i=1;i<n;++i){
			mul(a,b);cpy(a,s);
		}write(a);
	}return 0;
}
```

---

## 作者：Great_Influence (赞：2)

普通的乘法题。。。

首先，高精度乘法还是挺容易的，问题在于如何处理小数。我用的方法是，记录小数点后有几位小数（注意无视末尾的0），然后根据幂次方的特性，可以推导出结果的小数位数（假如小数点后有k位，经过n次方后结果位数会变为k\*n位，证明挺简单的自己解决）。这样在乘完后在输出时重新输出小数点即可。


顺便说一下，这道题最高有250次方，数据较大，可以用快速幂优化。具体方法可以看代码注释。

代码：

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<iostream>
#include<algorithm>
#include<queue>
#include<map>
#include<stack>
#define For(i,a,b) for((i)=(a);(i)<=(b);++(i))
#define Forward(i,a,b) for((i)=(a);(i)>=(b);--(i))
using namespace std;
inline void read(int &x)//读入优化
{
    int s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&k!='-')k=getchar();
    if(k=='-')
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^'0');
        k=getchar();
    }
    x=s*f;
}
char d[5200];
int a[5200],c[12000],s[12000],slen,alen,n,poi;
void mul(int a[],int b[],int &alen,int blen)//计算高精度乘法
{
    memset(c,0,sizeof(c));
    int i,j;
    For(i,1,alen)
        For(j,1,blen)c[i+j-1]+=a[i]*b[j];
    For(i,1,alen+blen)if(c[i]>9)
    {
        c[i+1]+=c[i]/10;
        c[i]%=10;
    }
    if(!c[alen+blen])--alen;
    For(i,1,alen+blen)a[i]=c[i];
    alen+=blen;
}
int main(void)
{
    //freopen("re.txt","r",stdin);调试用的可无视
    int i,j,flag;
    char k;
    while(1)//注意多组输入数据
    {
        memset(d,0,sizeof(d));//清0
        while(1)
        {
            if(scanf("%s",d)==EOF)return 0;//判断结束
            if(isdigit(d[0]))break;
        }
        alen=strlen(d)-1;
        flag=0;
        poi=0;//记录小数点位，是point的缩写，不是什么别的！
        For(i,0,alen)
        {
            if(d[i]=='.')
            {
                ++flag;
                continue;
            }
            a[i-flag+1]=d[i]-'0';
            if(flag)++poi;
        }
        memset(s,0,sizeof(s));//清0
        slen=0;
        while(a[alen]==0&&poi>0)//去除末尾0
        {
            --alen;
            if(flag)--poi;
        }
        For(i,1,alen/2)//翻转数字便于处理
        {
            k=a[i];
            a[i]=a[alen-i+1];
            a[alen-i+1]=k;
        }
        read(n);
        if(flag)poi*=n;//快速处理小数位
        s[1]=1;
        slen=1;
        while(n)//快速幂
        {
            if(n%2)mul(s,a,slen,alen);//当n为奇数时，将准备的输出数乘上余下的一个数，剩下的数便是偶数次方，可化为平方的整次方
            mul(a,a,alen,alen);//平方
            n/=2;
        }
        while(s[slen]==0&&slen>poi)--slen;//去除前面多余0
        Forward(i,slen,1)//记得倒序输出
        {
            if(flag&&i==poi)printf(".");
            printf("%d",s[i]);
        }
        cout<<endl;
    }
    return 0;
}
```

---

## 作者：英明神武的熊 (赞：2)

讲道理，只是一道正常的高精，就是浮点数的处理特别恶心

```pascal
var rp:double;
    i,j,n,k,g,r,pp:longint;
    a:array[0..3000] of longint;
    st:string;
begin
 while not eof do begin
  readln(rp,n);//读入不用字符串
  pp:=4;//小数点位数
  r:=round(rp*10000);//浮点数的处理要特别注意，我采用的是转化为整形数以后再判断小数的位数
  while r mod 10=0 do begin
   dec(pp); r:=r div 10;
  end;
  fillchar(a,sizeof(a),0);
  a[1]:=1; k:=1;
  for i:=1 to n do begin
   g:=0;
   for j:=1 to k do begin
    a[j]:=a[j]*r+g;
    g:=a[j] div 10;
    a[j]:=a[j] mod 10;
   end;
   while g<>0 do begin
    inc(k);
    a[k]:=g mod 10;
    g:=g div 10;
   end;
  end;
  pp:=pp*n;
  if k<=pp then begin
   write('.');
   for i:=1 to pp-k do write('0');
   for i:=k downto 1 do write(a[i]);
  end else if k>pp then
   for i:=k downto 1 do begin
    write(a[i]);
    if (i=pp+1) and (pp<>0) then write('.');
   end;
   writeln;
 end;
end.
```

---

## 作者：寒冰大大 (赞：1)

# 前言

显然这道题大部分人都是小数化为整数来做的，然而完全没有这个必要，虽然这道题被恶搞到了黄题（因为p开头的语言），但是目的多半是希望我们能理解小数高精，所以我认为这道题写小数高精意义大一点。

那怎么小数高精呢？

首先我们从小数点把整数和小数部分分开，同时联想竖式惩罚，比如我们有x和y，那么$x*y$ 的小数部分必然在x第一个整数和y第一个整数相乘的位置，然而这个位置显然就是当前在x的位置+在y的位置-1

比如53.5*57.5

在竖式就是3和7相乘这个位置（3）为1位。

### 但是我陷入了沉思，那<1的小数怎么办呢？

其实很简单，把它当做0.xxx来看就行了。

### 那问题又来了，符号怎么处理（这道题没有关系）

显然是先计算来看符号

### 这时候我们重定义好乘法了，这个代码也就简单明了了。

```cpp
#include<touwenjian.h>

using namespace std;

const int width=3000;  //数组长度3000，小数点前1200位
const int bas=1200;
const int eps=25;   //除法的精度，这里没用
const int deps=7;   //开根和double转换的精度这里也没用

struct mdob{
	
	int a[width];
	int l,r;
	int fg;
	
	mdob()
	{
		memset(a,0,sizeof(a));
		l=r=bas;
		fg=0;
	}
	
	inline void check()
	{
		int i,leave=0;
		if(l==bas) l--;
		if(r==bas) r--;
		for(i=r;i>=l;i--) 
		{
			if(i==bas) continue;
			a[i]+=leave;
			leave=0;
			if(a[i]>=10) 
			{
				leave+=a[i]/10,a[i]%=10;
				if(i==l) l--;
			}
		}		
		while(a[l]==0&&l<bas-1) l++;
		while(a[r]==0&&r>bas+1) r--;
	}
	
	inline void clr()
	{
		memset(a,0,sizeof(a));
		l=r=bas;
		fg=0;
	}

	inline void strdob(string st)
	{
		int muti=st.size();
		clr();
		l=r=bas;
		fg=0;
		stack <int> s;
		queue <int> q;
		int p=0;
		while((st[p]<'0'||st[p]>'9')&&p<muti) if(st[p]=='-') fg=1,p++;
		while(st[p]>='0'&&st[p]<='9'&&p<muti) s.push(st[p]-'0'),p++;
		while(!s.empty()) a[--l]=s.top(),s.pop();
		if(st[p]!='.') 
		{
			a[++r]=0;
			return ;
		}
		p++;
		while(st[p]>='0'&&st[p]<='9'&&p<muti) q.push(st[p]-'0'),p++;
		while(!q.empty()) a[++r]=q.front(),q.pop();
		return ;
		check();
	}
	
	//判断在当前数中的位置
	inline int getnowplace(int p)
	{
		if(p>bas) return p-l;
		else return p-l+1;
	}
	
	inline void mprint() 
	{
		check();
		int i;
		if(fg) cout<<'-';
		if(a[l]!=0)for(i=l;i<bas;i++) cout<<a[i];
		if(a[r]==0) 
		{
			cout<<endl; 
			return ;
		} 
		cout<<".";
		for(i=bas+1;i<=r;i++) cout<<a[i];
		cout<<endl;
		return ;
	}

}; 

mdob operator *(mdob x,mdob y)
{
	int target[width];
	memset(target,0,sizeof(target));
	mdob ans;
	ans.l=ans.r=bas;
	ans.clr();
	ans.fg=x.fg^y.fg;
	int i,j;
	int zeropla=x.getnowplace(bas-1)+y.getnowplace(bas-1);  //这里我没有-1，所以下面循环可能有点奇怪
	for(i=x.l;i<=x.r;i++)
	{
		if(i==bas) continue;
		for(j=y.l;j<=y.r;j++)
		{
			if(j==bas) continue;
			target[x.getnowplace(i)+y.getnowplace(j)-1]+=x.a[i]*y.a[j];
		}
	}
	int muti=x.getnowplace(x.r)+y.getnowplace(y.r)-1;
    //放进答案数组
	for(i=zeropla-1;i>=1;i--) ans.a[--ans.l]=target[i];
	for(i=zeropla;i<=muti;i++) ans.a[++ans.r]=target[i];
	ans.check(); //进位在check里面
	return ans;
}

mdob _pow(int x,mdob &y)
{
	mdob ans;
	if(x==0) {ans.strdob("1.0"); return ans;} //strdob是一个字符串转高精度小数的东西
	if(x==1) return y;
	ans.strdob("1.0");
	if(x&1) ans=ans*y;
	ans=ans*_pow(x/2,y)*_pow(x/2,y); 
	return ans;
}

signed main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	mdob a,b,c;
	double t,t2;
	int x;
	string s;
	while(cin>>s>>x)
	{
		a.strdob(s);
		c=_pow(x,a);  //平凡的快速幂
		c.mprint();
	}
	return 0;
}

```


---


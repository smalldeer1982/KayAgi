# 尴尬的数字

## 题目背景

Bessie 刚刚学会了不同进制数之间的转换，但是她总是犯错误，因为她的两个前蹄不能轻松的握住钢笔。


## 题目描述

每当 Bessie 将一个数转换成新的进制时，她总会写错一位数字。例如，她将 14 转化成 2 进制数，正确的结果是 1110，但她可能会写成 0110 或 1111。Bessie 从不会意外的增加或删减数字，所以她可能会写出以 0 开头的错误数字。

给出 Bessie 转换后 $N$ 的 2 进制形式和 3 进制形式，请计算出 $N$ 的正确数值（用十进制表示）。$N$ 可能会达到 $10^9$，输入数据保证解的存在唯一性。


## 样例 #1

### 输入

```
1010
212```

### 输出

```
14```

# 题解

## 作者：JOHNKRAM (赞：54)

枚举二进制数中是哪一位错了，求出之后再与三进制数比较，如果有且只有一位不同，那么就是这个数。


---

## 作者：Youngsc (赞：22)

[Youngsc](http://youngscc.github.io/)

其实不用楼下那么麻烦，我们首先枚举二进制数中哪一位数字不同，并且可以采用异或的方法一步变过去，接着与三进制数字进行比较，如何去判断两个十进制的数字在三进制的情况下是否相差一位呢？ 我们可以对二者作差，如果二者在三进制的情况下只相差一位，那么他们的差除去所欲的质因数3后的商一定小于三，然后就可以用这样的方法近似于O（n）去求解了。


## 代码在这里


```cpp

# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <cmath>
# define R register
# define LL long long

using namespace std;

char a[100],b[100];
inline void in(R int &a){
    R char c = getchar();R int x=0,f=1;
    while(!isdigit(c)){if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

inline void minn(R int &a,const int b){a<b? 0:a=b;}
inline int ab(R int x){return x<0? -x:x;}

inline int yg(){
    // freopen("maze1.in","r",stdin);
    // freopen("maze1.out","w",stdout);
    scanf("%s",a+1);
    scanf("%s",b+1);
    R int num = 0,tmp = 0;
    R int la = strlen(a+1),lb = strlen(b+1);
    for(R int i=1; i<=la; ++i)
        num = num<<1|(a[i]-'0');
    for(R int i=1; i<=lb; ++i) tmp = tmp*3+b[i]-'0';
    for(R int i=1; i<=la; ++i)
    {
        R int ans = num^(1<<(la-i));
        R int tt = ab(ans-tmp);
        while(tt%3 == 0) tt/=3;
        if(tt < 3) printf("%d",ans),exit(0);
    }
}

int youngsc = yg();
int main(){;}

```

---

## 作者：老彩笔 (赞：13)

蒟蒻读题时被他给的例子误导了，我以为他只会写错首数字或为数字

```cpp

她将14转化成2进制数，

正确的结果是"1110"，

但她可能会写成"0110"或"1111"

```
结果推出来发现样例都过不了QwQ

这道题的思路就是枚举出他所有可能的错误情况

计算它所对应的数字，最后从二进制和三进制中找出相等的就行

这道题N的范围是10亿，变成2进制和3进制后位数很少

2进制在30位左右，3进制在20位左右，可以提前预处理出来，所以不用担心复杂度的问题

有一点需要注意的是：

由于给出的二进制和三进制**首位有可能是0**

所以我用了string来读入，这样枚举时方便一些

枚举二进制数时更改每一位，如果是1就变成0，如果是0就变成1

枚举三进制时如果是0，就变成1或2，如果是1就变成0或2，如果是2就变成0或1

**变完了一定要再复原回去**

类似于递归里的回溯

最后找出相同的就是答案

有一点点的小优化~~真的很小~~：

因为他不会增添或减少数字，所以如果第一位不是0，就不用把他改成0

```cpp
	if(aa[i]=='1'&&i==0)continue;//二进制的特判


	if(i!=0)//三进制的特判
	{
		bb[i]='0';
		cnt2++;
		for(re int j=len2-1;j>=0;j--)
		{
			if(bb[j]=='1')
				b[cnt2]+=mul3[len2-j-1];
			else if(bb[j]=='2')
				b[cnt2]+=mul3[len2-j-1]*2;
		}
	}
```

代码如下,里面有较详细的解释

```cpp
#include<bits/stdc++.h>
#define re register
#define int long long
using namespace std;
string aa,bb;//首位为零时也可以处理 
int a[105],b[1005];//三进制的错误情况比二进制要多,所以多开了数组 
int cnt1,cnt2;//a,b数组的指针 
int mul2[31]={1,2},mul3[22]={1,3};//mul2[i]表示2^i,mul3[i]表示3^i; 
signed main()
{
	cin>>aa>>bb;
	//预处理 
	for(re int i=2;i<=30;i++)
		mul2[i]=mul2[i-1]*2;
	for(re int i=2;i<=20;i++)
		mul3[i]=mul3[i-1]*3;
	int len1=aa.length(),len2=bb.length();
	for(re int i=0;i<len1;i++)//枚举每一位 
	{  
		if(aa[i]=='1'&&i==0)continue;//如果第一位不是0,那么他肯定不会写错这一位
		//因为他不可能增添或减少 
		if(aa[i]=='1')//如果是1就改成0 
		{
			aa[i]='0';
			cnt1++;
			for(re int j=len1-1;j>=0;j--)//枚举每一位二进制算出来十进制数 
				if(aa[j]=='1')//如果是1才加上 
					a[cnt1]+=mul2[len1-j-1];
			aa[i]='1';//"回溯"
		}
		else if(aa[i]=='0')//如果是0就改成1 
		{
			aa[i]='1';
			cnt1++;
			for(re int j=len1-1;j>=0;j--)
				if(aa[j]=='1')
					a[cnt1]+=mul2[len1-j-1];
			aa[i]='0';
		}
	}
	for(re int i=0;i<len2;i++)//枚举三进制 
	{
		if(bb[i]=='0')//如果是0就改成1或2 
		{
			bb[i]='1';
			cnt2++;
			for(re int j=len2-1;j>=0;j--)
			{
				if(bb[j]=='1')
					b[cnt2]+=mul3[len2-j-1];
				else if(bb[j]=='2')
					b[cnt2]+=mul3[len2-j-1]*2;
			}
			bb[i]='2';
			cnt2++;
			for(re int j=len2-1;j>=0;j--)
			{
				if(bb[j]=='1')
					b[cnt2]+=mul3[len2-j-1];
				else if(bb[j]=='2')
					b[cnt2]+=mul3[len2-j-1]*2;
			}
			bb[i]='0';
		}
		else if(bb[i]=='1')//如果是1就改成0或2 
		{
			bb[i]='2';
			cnt2++;
			for(re int j=len2-1;j>=0;j--)
			{
				if(bb[j]=='1')
					b[cnt2]+=mul3[len2-j-1];
				else if(bb[j]=='2')
					b[cnt2]+=mul3[len2-j-1]*2;
			}
			if(i!=0)
			{
				bb[i]='0';
				cnt2++;
				for(re int j=len2-1;j>=0;j--)
				{
					if(bb[j]=='1')
						b[cnt2]+=mul3[len2-j-1];
					else if(bb[j]=='2')
						b[cnt2]+=mul3[len2-j-1]*2;
				}
			}
			bb[i]='1';
		}
		else if(bb[i]=='2')//如果是2就改成0或1 
		{
			bb[i]='1';
			cnt2++;
			for(re int j=len2-1;j>=0;j--)
			{
				if(bb[j]=='1')
					b[cnt2]+=mul3[len2-j-1];
				else if(bb[j]=='2')
					b[cnt2]+=mul3[len2-j-1]*2;
			}
			if(i!=0)
			{
				bb[i]='0';
				cnt2++;
				for(re int j=len2-1;j>=0;j--)
				{
					if(bb[j]=='1')
						b[cnt2]+=mul3[len2-j-1];
					else if(bb[j]=='2')
						b[cnt2]+=mul3[len2-j-1]*2;
				}
			}
			bb[i]='2';
		}
	}
	for(re int i=1;i<=cnt1;i++)
		for(re int j=1;j<=cnt2;j++)
			if(a[i]==b[j])
			{
				cout<<a[i]<<'\n';
				return 0;
			}
	return 0;
 } 
```



---

## 作者：0104154308_f (赞：8)

##### ~~为何各位巨佬都是用的诡秘方式难道不是枚举出所有可能然后对比就好了吗~~
### 思路：
肉眼可见这是暴力题目那么期望得分30的代码思路就是这样：
```
for(每一位2进制的字符)
{
    该位取反(0-1/1-0)
	for(每一位三进制的字符)
    {
    	for(0-2更改三进制字符串的这一位)
        {
            算出两个字符串表示的十进制数对比是否相同;
        }
    }
}
```
经过长达10分钟的编写期望得分30的代码出现了

 _~~然后满分了~~_ 
###  转换：
那么怎么转换呢

a[]为一个二进制数串

ans*=a[i]*2^(n-1)

ans即其十进制

三进制同上;
### code：
```c
#include<stdio.h>
#include<string.h>
long long ans2,ans3;
int map2[100000],map3[100000],l2,l3;
char t[100000];
int main()
{
	scanf("%s",t);
	for(int i=0;i<strlen(t);i++)
	t[i]-='0'-1,map2[i]=t[i]-1,l2=i+1;
	scanf("%s",t);
	for(int i=0;i<strlen(t);i++)
	t[i]-='0'-1,map3[i]=t[i]-1,l3=i+1;
	for(int i=0;i<l2;i++)
	{
		for(int j=0;j<l3;j++)
		{
			int x=map3[j];
			for(int k=0;k<=2;k++)
			{
				if(map2[i]==1)
				map2[i]=0;
				else
				map2[i]=1;
				map3[j]=k;
				for(int l=0;l<l2;l++)
				ans2+=map2[l],ans2*=2;
				ans2/=2;
				for(int l=0;l<l3;l++)
				ans3+=map3[l],ans3*=3;
				ans3/=3;
				if(map2[i]==1)
				map2[i]=0;
				else
				map2[i]=1;
				map3[j]=x;
				if(ans2==ans3){
			    printf("%d",ans2);
			    return 0;
				}
				ans2=ans3=0;
			}
		}
	}
 } 
```


---

## 作者：战神yfy (赞：7)

这题还行，二进制每一位数只有1或0，挨个判断是不是他的那一位错误，因为正确的只有写错的三进制数有一位区别，记录后转换为三进制，判断只有一位时输出即可。
# 我们不玩虚的，上代码
```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
char sss[100]; 
long long zh2(char x[100]){//二进制转十进制 
	long long ans=0;
	int t=1;
	int l=strlen(x);
	for(int i=l-1;i>=0;i--){
		ans+=(x[i]-'0')*t;
		t=t*2;
	}
	return ans;
}
void zh3(long long x){//十进制转换三进制 
	char ans[100];
    for(int i=0;;i++){
    	ans[i]=x%3+'0';
    	x/=3;
    	if(x==0){
    		ans[i+1] = '\0';
			break;
		}
	}
	int l=strlen(ans);
	int p=0;
	for(int i=l-1;i>=0;i--){
		sss[p]=ans[i];
		p++;
	}
	sss[p]='\0';
}
int main(){
	int m=0;//记载相差位数 
	char two[100];
	char three[100];
	scanf("%s%s",two,three);//输入 
	if(two[0]=='0'){//特判 
		two[0]=='1';
		cout<<zh2(two)<<endl;
		return 0;
	}
	int lw=strlen(two);
	int lr=strlen(three);//截取长度 
	long long  xzhtwo[100];
	for(int i=1;i<lw;i++){
		if(two[i]=='0')two[i]='1';
		else two[i]='0';//转变数字 
		xzhtwo[i]=zh2(two);//二进制转十进制 
		zh3(xzhtwo[i]);//十进制转三进制 
		int ls=strlen(sss);
		if(ls==lr){//做对比判断 
			for(int j=0;j<lr;j++){
				if(sss[j]!=three[j])m++;
			}
			if(m==1){//只有相差一位时才输出 
				printf("%lld\n",xzhtwo[i]);
				return 0； 
			}
		}
		if(two[i]=='0')two[i]='1';
		else two[i]='0';//变回来 
		m=0;
	}
	return 0;
}
```


---

## 作者：MyukiyoMekya (赞：5)

思路：

先用暴力**枚举所有情况**

再进行比较

枚举所有情况可以用dfs回溯来写

比较的内容就是找到二进制数和三进制数都会出现的情况（前面用dfs枚举出来的）

这里可以排个序然后二分$O(2*n logn)$，应该比$O(n^2)$快吧qwq

具体讲解在代码里

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>  //sort要用的头文件
using namespace std;
const int MaxS=1000001;
string bin,thr;         	//字符串操作习惯用string
int lb,lt;					//字符串的长度，bin（二进制）,thr（三进制）
int ansb[MaxS],anst[MaxS];     //bin和thr所有可能的情况
int cntb,cntt;				//bin和thr的所有可能情况的数量
inline int bin2dec()		//二进制转十进制
{
    int ans=0;
    int k=1;
    for(int i=bin.length()-1;i>=0;--i)
        ans+=k*(bin[i]-'0'),k<<=1;
    /*
    	这里是把这个二进制数的每一位按权累加
        假设一个n位二进制数的第i位是a[i]，
        则这个二进制数的十进制为
        a[1]*(2^(n-1))+a[2]*(2^(n-2))+...+a[n-1]*(2^1)+a[n]*(2^0)
    */
    return ans;
}
inline int thr2dec()		//三进制转十进制
{
    int ans=0;
    int k=1;
    for(int i=thr.length()-1;i>=0;--i)
        ans+=k*(thr[i]-'0'),k*=3;
    //三进制和上面差不多，就是底数变成了3
    return ans;
}
void dfsb(int depth,bool flg) //枚举用的回溯
{
    if(depth>=lb)	//枚举完了每一位
    {
    	if(flg)				//题目：仅有一位错误
        	ansb[++cntb]=bin2dec();	//把答案记录下来
        return;
    }
    dfsb(depth+1,flg);		//不更改这一位
    if(!flg)			//如果之前没更改过，就更改这一位
    {
        bin[depth]=(1-(bin[depth]-'0'))+'0';
        dfsb(depth+1,true);
        bin[depth]=(1-(bin[depth]-'0'))+'0';
    }
    return;
}
void dfst(int depth,bool flg)
{
    if(depth>=lt)
    {
    	if(flg)
        	anst[++cntt]=thr2dec();
        return;
    }
    char t;
    dfst(depth+1,flg);
    if(!flg)
    {
        for(char i='0';i<='2';++i)
            if(thr[depth]!=i)
        /*
        	这里如果thr[depth]=='i'，那就等于没更改
        */
                t=thr[depth],thr[depth]=i,dfst(depth+1,true),thr[depth]=t;
    }
    return;
}
int bs(int l,int r,int x)	//二分查找
{
    int mid,ans=0;
    while(l<=r)
    {
        mid=(l+r)>>1;
        if(anst[mid]>=x)
            ans=mid,r=mid-1;
        else
            l=mid+1;
    }
    return ans;
}
int main(void)
{
    int x;
    cin>>bin>>thr;
    lb=bin.length();
    lt=thr.length();
    dfsb(0,false);
    dfst(0,false);
    sort(anst+1,anst+cntt+1);	//把anst排序
    for(int i=1;i<=cntb;++i)
    	//在anst中寻找ansb的每一位元素
    {
        x=bs(1,cntt,ansb[i]);
        if(ansb[i]==anst[x])	//找到了
            return printf("%d",ansb[i]),0; //输出，return 0;
    }
    return 0;
}
```

---

## 作者：衡屿睿 (赞：5)

暴力其实是一种很麻烦的方法，来做这些题的人恐怕刚看到题解就已经恶心了，不过这种看起来烦的题考验的却是做题者对基础知识的综合应用。算法学厌了，不妨来做一做，还是挺有意思的。


下面说说我的做法：

1.读入两个字符串（a&b)，分别将其转化为长整型数(a2&b2)，转化过程中，将两数分别逆序存储于a1和b1；

2.从个位开始，依次枚举每一位的可能正确值（无后效性），将所有可能正确的N分别保存在k和kl中；

3.将k和kl排序（方便查找相同值）：

```cpp
    int h=1,g=1;
    while(k[h]!=kl[g])
    {
        if(k[h]>kl[g])g++;
        if(k[h]<kl[g])h++;
    }
```
设立h和g两个指针，利用两个数组本身的有序性降低时间复杂度。
又因为有且仅有一解，跳出循环后的k[h]或kl[g]即为所求解。

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
string a,b;
int a1[101],b1[101],k[1000001],kl[1000001];
int main()
{
    long long a2=0,b2=0,m=1,n=1,yx=0;
    cin>>a>>b;
    int lena=a.size(),lenb=b.size();
    for(int i=lena-1;i>=0;--i)
    {
        a1[i+1]=a[i]-48;
        a2+=a1[i+1]*m;
        m*=2;
    }
    for(int i=lenb-1;i>=0;--i)
    {
       b1[i+1]=b[i]-48; 
       b2+=b1[i+1]*n;
       n*=3;
    }
    m=1;n=1;
    for(int i=lena;i>=1;--i)    
    {
      for(int j=0;j<=1;++j)
         if(j!=a1[i])
         k[++yx]=a2+(j-a1[i])*m;
     m*=2;
    }
    sort(k+1,k+yx+1);
    yx=0;
    for(int i=lenb;i>=1;--i)    
    {
      for(int j=0;j<=2;++j)
         if(j!=b1[i])
         kl[++yx]=b2+(j-b1[i])*n;
     n*=3;
    }
    sort(kl+1,kl+yx+1);
    int h=1,g=1;
    while(k[h]!=kl[g])
    {
        if(k[h]>kl[g])g++;
        if(k[h]<kl[g])h++;
    }
    cout<<k[h];
    return 0;
}
```

---

## 作者：yuzh0816 (赞：3)

此文，我只放最基本的进制转换（N to 10）如何实现以及此题的基本思想

1. 枚举出他所有可能的错误情况

2. 计算十进制数字，最后从二进制和三进制中找出相等数字即为答案

---

下面为进制转换代码
```cpp
#include<bits/stdc++.h>
using namespace std;

string a;
int n;

int jinzhi(string k,int n)
{
    int ans=1,res=1;
    int len=a.length();//Calculate The Length Of 'a'
    for(int i=0;i<len;i++)
    {
        res=1;
        for(int j=1;j<=i;j++)
        {
            res*=n;
        }
        ans+=res*(a[len-i-1]-'0');//Calculate The Answer Of Each Position
    }
    return ans-1;//Return The Answer
}

int main()  
{ 
    cin>>a>>n;
    cout<<jinzhi(a,n);
    return 0;
}
```


---

## 作者：iostream (赞：2)

题目要求在二进制位上操作，使用bitset模拟，更加方便。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
#include<bitset> //头文件
using namespace std;
string s1,s2;
int len1,len2;
int main(){
    cin>>s1>>s2;
    bitset<32> k(s1);  //一个字符串（01串）可以直接塞入bitset
    len1=s1.size();
    len2=s2.size();
    for(int i=0;i<len1;i++){
        k[i]=!k[i];
        int j=len2-1,cnt=0;
        int x=k.to_ulong(); //转成长整数
        while(x>0){
            if(x%3==s2[j]-'0')cnt++;
            x/=3;j--;
            if(j<0)j=0;
        } //转成3进制
        if(cnt==len2-1){
            printf("%u\n",k.to_ulong());
            return 0;
        }
        k[i]=!k[i]; //计算完了，一定要记得把这一位改回去
    }
    return 0;
}
//233

```

---

## 作者：于斯为盛 (赞：1)

# 洛谷P1555题解-Meet In Middle

原题：https://www.luogu.com.cn/problem/P1555

本人第一次写题解，讲得不好勿喷~

题目大概是说给定这个数转成二进制和三进制的结果
但是这两个结果是有问题的，每个结果会且只会错一位
最后让求这个数而十进制形式

二进制和三进制就是一个很鸡肋的东西
一是互相转不容易，二是二进制转成三进制后不是以为对一位或一位对多位，而是会错开
所以O1的解法可能有点难度
但注意到本题n仅为10^9^，那位数就不会很多了
二进制大概30位，三进制会更少些
所以可以直接暴力搜索有问题的位。

接下来就是怎么暴力的问题
我在这里用了Meet In Middle的思想，即二进制和三进制同时搜索（不是并行，初始化二进制的时候可以先用哈希表存上，但由于可能变成的数很大，这里用了map<int, int>来优化），看有没有碰撞
然后改变当前的位就用+2(3)^n^就好了2(3)^n^可以跟着循环算，也可以预处理
还有一点注意的就是前导0

好了，附上代码。如有错误/优化/疑问 欢迎提出

```c
// code by 于斯为盛
#include <iostream>
#include <map>

using namespace std;

int _num;
int _bin;//binary, 存储二进制数据 
int _ter;//Ternary, 存储三进制数据 
int _ans; 
string _curBin;//输入的二进制，因为位数太长，所以用long long 
string _curTer;//同理 
map<int, int> _list;//hash， 二进制可以变成的数，可以为 1，不可以为 0 

void ParseIn(){
  cin>>_curBin>>_curTer;
}

void StringToInt(){//把输入的string转成int 
  for(int i=0; i<_curBin.length(); i++){
    _bin*=2;
    _bin+=(int)_curBin[i]-'0';
  }

  for(int i=0; i<_curTer.length(); i++){
    _ter*=3;
    _ter+=(int)_curTer[i]-'0';
  }
}

void GenList(){//初始化_list， 即搜索二进制修改一位可以到达的数 
  int add=1;
  int cur;//当前位
  int num=_bin;
  for(int i=0; i<_curBin.length(); i++){//要考虑前导 0，下面同理 
    cur=num&1;
    if(cur){
      _list[_bin-add]=1;//如果当前位是 1，则将其改成 0 ps:_list[i]是哈希表，表示二进制是否可以变成 i 
    } 
    else{
      _list[_bin+add]=1;//如果当前位是 0，则将其改成 1 
    }
    num/=2;
    add*=2;
  }
}

void Research(){//查找三进制修改一位与二进制修改一位的交集 
  int add=1;
  int cur;//当前位
  int num=_ter;
  for(int i=0; i<_curTer.length(); i++){
    cur=num%3;
    num/=3;
    if(cur==0){//当前位是0，与前面同理 
      if(_list[_ter+add]){
		_ans=_ter+add;
		return;
      }
      if(_list[_ter+2*add]){
		_ans=_ter+2*add;
		return;
      }
      add*=3;
      continue;
    }

    if(cur==1){//当前位是1，与前面同理 
      if(_list[_ter-add]){
		_ans=_ter-add;
		return;
      }
      if(_list[_ter+add]){
		_ans=_ter+add;
		return;
      }
      add*=3;
      continue;
    }

	//当前位是2，与前面同理 
    if(_list[_ter-add]){
      _ans=_ter-add;
      return;
    }
    if(_list[_ter-2*add]){
      _ans=_ter-2*add;
      return;
    }
    add*=3;
  }
}

void Core(){
  StringToInt();
  GenList();
  Research();
}

void WriteOut(){
  cout<<_ans<<endl;
}

int main(){
  ParseIn();
  Core();
  WriteOut();
  return 0;
}
```
——by于斯为盛


---

## 作者：nbqdd_2003 (赞：1)

**显然**，我们可以用**死办法**，进行**枚举**，一位一位**模拟**，保存所有情况，再进行比较。

```pascal
var
  x1,x2:packed array[1..1000000]of int64;//这里为了不爆炸，开大一点。
  i,j:longint;
  s2,s3:string;
procedure dadada1;//二进制。。。
var
  j:longint;
  total,tt:int64;
begin
  total:=0;
  tt:=1;
  for j:=1 to length(s2) do
    tt:=tt*2;
  for j:=1 to length(s2) do
    begin
      tt:=tt div 2;//一位一位下来。
      if s2[j]='1' then
        total:=total+tt;
    end;
  x1[i]:=total;//转化为数字并存储。
end;
procedure dadada2;//三进制（1）。。。
var
  j:longint;
  total,tt:int64;
begin
  total:=0;
  tt:=1;
  for j:=1 to length(s3) do
    tt:=tt*3;
  for j:=1 to length(s3) do
    begin
      tt:=tt div 3;//和二进制一样。
      if s3[j]='1' then
        total:=total+tt;
      if s3[j]='2' then
        total:=total+tt*2;//这里要分两种。
    end;
  x2[i]:=total;
end;
procedure dadada3;//三进制（2）。。。
var
  j:longint;
  total,tt:int64;
begin
  total:=0;
  tt:=1;
  for j:=1 to length(s3) do
    tt:=tt*3;
  for j:=1 to length(s3) do
    begin
      tt:=tt div 3;
      if s3[j]='1' then
        total:=total+tt;
      if s3[j]='2' then
        total:=total+tt*2;
    end;
  x2[length(s3)+i]:=total;//这是为了保存第二种情况。
end;
begin
  readln(s2);
  readln(s3);
  for i:=1 to length(s2) do
    begin
      if s2[i]='1' then
        begin
          s2[i]:='0';
          dadada1;
          s2[i]:='1';
        end;
      if s2[i]='0' then
        begin
          s2[i]:='1';
          dadada1;
          s2[i]:='0';
        end;
    end;
  for i:=1 to length(s3) do
    begin
      if s3[i]='1' then
        begin
          s3[i]:='0';
          dadada2;
          s3[i]:='2';
          dadada3;
          s3[i]:='1';
        end;
      if s3[i]='2' then
        begin
          s3[i]:='0';
          dadada2;
          s3[i]:='1';
          dadada3;
          s3[i]:='2';
        end;
      if s3[i]='0' then
        begin
          s3[i]:='1';
          dadada2;
          s3[i]:='2';
          dadada3;
          s3[i]:='0';
        end;
    end;//以上分情况讨论。
  for i:=1 to length(s2) do
    for j:=1 to length(s3)*2 do
      if x1[i]=x2[j] then
        begin
          writeln(x1[i]);//判断有一样的代码就输出。
          halt;
        end;
end.
```

---

## 作者：alexhzh42 (赞：1)

思路与楼下相同，就是将一些部分进行优化并缩短代码。

```delphi
var  
  n,i,j,x,nt:longint;  
  n2,n3,t,t3,tt:string;  
procedure zh2;  
  var i:longint;  
  begin  
    i:=1;  
    for j:=length(n2) downto 1 do  
      begin  
        n:=n+(ord(n2[j])-48)*i;  
        i:=i*2;  
      end;  
  end;  
procedure zh10;  
  var i:longint;  
  begin  
    while n>=3 do  
      begin  
        str(n mod 3,tt);  
        n:=n div 3;  
        t3:=tt+t3;  
      end;  
    str(n,tt);  
    t3:=tt+t3;  
  end;  
begin  
  readln(n2);  
  readln(n3);  
  if n2[1]='0' then begin n2[1]:='1';zh2;writeln(n);exit;end;  
  t:=n2;  
  for i:=2 to length(n2) do  
    begin  
      if n2[i]='0' then n2[i]:='1' else n2[i]:='0';  
      n:=0;   
      zh2;  
      nt:=n;  
      zh10;  
      x:=0;  
      for j:=1 to length(n3) do  
        if t3[j]<>n3[j] then inc(x);  
      if x=1 then begin writeln(nt);exit;end;  
      n2:=t;  
      t3:='';  
    end;  
end.  
```

---

## 作者：Ape_epA (赞：0)

其实只要枚举每一位上的二进制数，把0变成1，把1变成0，再化成三进制，判读一下就好了。。。

代码:

```cpp
var i,d,x,z,j,len,k:longint;
    s,s1,s2,s3:string;
    f:boolean;
begin
  readln(s);
  readln(s1); s3:=s;
  for i:=1 to length(s) do
    begin
    if s[i]='0' then
      s[i]:='1'
    else s[i]:='0';
    d:=1; x:=0;
    for j:=length(s) downto 1 do
      begin
      x:=x+(ord(s[j])-48)*d;
      d:=d*2;
      end;
    z:=x;
    s2:='';
    while x<>0 do
      begin
      s2:=chr(x mod 3+48)+s2;
      x:=x div 3;
      end;
    k:=0; f:=true;
    if length(s1)>length(s2) then
      len:=length(s1)
    else len:=length(s2);
    for j:=1 to len do
      if s1[j]<>s2[j] then
        begin
        inc(k);
        if k>1 then
          begin
          f:=false;
          break;
          end;
        end;
    if f then
      break;
    s:=s3;
    end;
  writeln(z);
end.
```

---


# 四方定理

## 题目描述

四方定理是众所周知的：任意一个正整数$n$，可以分解为不超过四个整数的平方和。例如：$25=1^{2}+2^{2}+2^{2}+4^{2}$，当然还有其他的分解方案，$25=4^{2}+3^{2}$和$25=5^{2}$。给定的正整数$n$，编程统计它能分解的方案总数。注意：$25=4^{2}+3^{2}$和$25=3^{2}+4^{2}$视为一种方案。


## 样例 #1

### 输入

```
1
2003```

### 输出

```
48```

# 题解

## 作者：pigstd (赞：80)

**update on 2020.6.26**：修改了文章中的一些错误，希望管理员重新审核后通过

-------------

这道题是一道背包题，但有些题解的解释不是非常详细，所以我写了一篇题解来帮助像我一样的蒟蒻

思路：$dp[i][j]$代表 $i$用$j$个平方数所可以组成的方案数，这样对于一个$n$，只要输出 $dp[n][1-4]$的和就行了。

那么怎么计算呢？因为每个数可以用无数次，所以使用类似完全背包的方法（如果你不知道什么是完全背包，请看[这道题](https://www.luogu.org/problemnew/show/P1616)），因为每个数$n$都可以由$n$减去一个平方数可得，则可以推出$dp[i][j]+=dp[i-k*k][j-1]$

这样就可以写出代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int M=32768; 
int t,n;
int dp[33000][5]={1};//注意，dp[0][0]要设为1，否则会全输出0 

int main()
{
	for (int i=1;i*i<=M;i++)//枚举所有平方数 
		for (int j=i*i;j<=M;j++)//因为j-i*i要>=0(否则会RE)，所以直接从i*i开始 
			for (int sum=1;sum<=4;sum++)//枚举使用次数 
				dp[j][sum]+=dp[j-i*i][sum-1];//计算 
	cin>>t;
	while(t--)//循环t次 
	{
		int n,ans=0;
		cin>>n;
		for (int i=1;i<=4;i++)
			ans+=dp[n][i];
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：dj114133643 (赞：25)

就是一个背包，把每个平方数看成一个物品，

求方案数。

因为对用的数的个数有要求，

所以是二维费用背包

要注意的是每个数是不限个数的，

所以循环的时候要正着来。

上代码

    
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int f[32770][5];
int main()
{
    int i,j,l,n=32768,t,ans;
    f[0][0]=1;
    for(i=1;i*i<=n;i++)
        for(j=i*i;j<=n;j++)
            for(l=1;l<=4;l++)
                f[j][l]+=f[j-i*i][l-1];
    scanf("%d",&t);
    while(t--)
    {
        ans=0;
        scanf("%d",&n);
        for(i=1;i<=4;i++)
            ans+=f[n][i];
        printf("%d\n",ans);
    }
    return 0;
}

```

---

## 作者：JOHNKRAM (赞：19)

<hr>
方法1：直接枚举，用四重循环枚举每个值即可。时间复杂度不好估计。


<hr>
方法2：先预处理，用f[i][j]表示i用j个完全平方数相加得到的方案数。

f[i][j]=Σf[i-k\*k][j-1](k\*k<=i)

对于每个数n，输出f[n][1]+f[n][2]+f[n][3]+f[n][4]即可。

时间复杂度O(32768\*181\*4)


<hr>

---

## 作者：HoshiuZ (赞：11)

实际上这就是一个二维费用的背包问题。一个费用为数的大小，另一个费用为1，且这一个费用最大为$4$。



定义$f[j][k]$表示数字$j$分解为$k$个平方数的方案数，易得
$$
f[j][k]=f[j][k]+f[j-i*i][k-1]
$$
且不难发现，这个适用于所有的数，因此不必求$t$次，直接求出到$n_{max}$（即为$32768$）的所有$f$数组的值，然后针对每个$n$，输出$f[n][1]+f[n][2]+f[n][3]+f[n][4]$即可。



## 代码

```c++
#include<bits/stdc++.h>

using namespace std;

int t,dp[40010][5];

int main() {
	cin>>t;	
	
	dp[0][0]=1;
	for(int i=1;i<=sqrt(32768);i++) {
		for(int j=i*i;j<=32768;j++) {
			for(int k=1;k<=4;k++) {
				dp[j][k]+=dp[j-i*i][k-1];
			}
		}
	}
	
	while(t) {
		int n;
		cin>>n;
		cout<<dp[n][1]+dp[n][2]+dp[n][3]+dp[n][4]<<endl;
		t--;
	}
	
	return 0;
}
```



---

## 作者：封禁用户 (赞：11)

更新日志：

2020/6/10 修错误。。


看到一篇篇dp题解，蒟蒻不禁吼出一句：同志们，你们耳熟能详的“暴力出奇迹，骗分过样例”哪去了？

是的，这题的确可以用暴力做，而且代码无比壮观。

思路：
四重循环枚举四个数，然后判断$i^2+j^2+k^2+q^2$ 与$n$ 是否相等即可。为了避免数字重复，当前重循环的变量最小值应为上一重的最大值，我一开始加了一，结果样例都没过。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
long long ans;
inline int read() {
	char ch=getchar();
	int x(0),f(1);
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main() {
	t=read();
	while(t--) {
		n=read();
		ans=0;//别忘初始化
		for(register int i(0);i*i<=n;++i)
			for(register int j=i;i*i+j*j<=n;++j)
				for(register int k=j;i*i+j*j+k*k<=n;++k)
					for(register int q=k;i*i+j*j+k*k+q*q<=n;++q) {//暴力枚举
						if((i*i+j*j+k*k+q*q)==n) ++ans;//判断当前方案是否可行
					}
		printf("%lld\n",ans);//输出结果
	}
	return 0;
}
```

~~另：卡常永远是我们的好伙伴（逃~~

---

## 作者：Martian148 (赞：6)

### 这道题是经典的01背包

### 先构造a[i]，就是平方数，这是物品大小，n就是背包大小，设f[i]表示背包大小为i能装满的方案

### 核心如下：
```cpp
for (int i=1;i<=物品总数;i++)
       for (int j=a[i];j<=背包最高价值;j++)
          f[j]+=f[j-a[i]];
```
### f[][]的第二维就是平方数的个数，在解决了方案总数怎么求之后，就要考虑只能用四个或四个以下。所以要加一维。

### 总结为f[j][k]代表价值上线为j，取k个数作组合时的方案总数。则最后答案为f[n][1]到f[n][4]的和。

### 代码非常简单，相信大家能看懂。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[185],f[32770][5],m,n;
int main()
{   for(int i=1;i<=181;i++)
    a[i]=i*i;             
    f[0][0]=1; 
    for (int i=1;i<=181;i++)
       for (int j=a[i];j<=32768;j++)
          for(int k=1;k<=4;k++)
          f[j][k]+=f[j-a[i]][k-1];
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>m;
        cout<<f[m][1]+f[m][2]+f[m][3]+f[m][4]<<endl;
    }
    return 0;
}
```


---

## 作者：king_xbz (赞：4)

这道题的做法有很多，而我要给大家介绍其中的两种做法：**暴力枚举**，**背包**

- 暴力枚举法

故名思议，我们按照题意模拟即可，我们可以使用~~5层循环嵌套~~，第一层是1->t，枚举数据组数，第二层到第五层则分别枚举4个数，由于数据分解为不超过四个整数，所以**循环要从零开始**，为了防止重复，**下一层循环的起始位置应为上一层循环的位置**，复杂度为$O(t*n^4)$

下面上代码(限于篇幅，快读省略)：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define fint register int
using namespace std;
inline int read();
signed main()
{
	int t,ans,n;
	t=read();
	for(fint T=1;T<=t;T++)
	{
	n=read();
	ans=0;
	for(fint i=0;i*i<=n;i++)
	for(fint j=i;j*j+i*i<=n;j++)
	for(fint k=j;k*k+j*j+i*i<=n;k++)
	for(fint l=k;k*k+j*j+i*i+l*l<=n;l++)
	if(i*i+j*j+k*k+l*l==n)
	ans++;
	printf("%d\n",ans);
	}
	return 0;
} 
```
这种方法由于时间复杂度太高，需要使用O3优化，不过~~考场骗分~~效果杠杠的！

- 二维费用的完全背包问题

我们知道，完全背包是一件物品可取无限次的背包问题，其基本代码形式如下：
```cpp
//n为物品数，m为容量，v[]为价值，w[]为物品重量
for(int i=1;i<=n;i++)
for(int j=w[i];j<=m;j++)
f[j]=max(f[j],f[j-w[i]]+v[i]);
```
其跟01背包最大的区别就是**第二维要正向循环**，以满足物品取用要求。

而二维费用背包问题仅需要增加一层循环，可以近似的认为是第二层循环跑两遍。

代码如下：
```cpp
//n为物品数，m为容量，v[]为价值，w[].a为物品a重量,w[].b为物品b重量
for(int i=1;i<=n;i++)
for(int j=w[i].a;j<=m;j++)
for(int j=w[i].b;j<=m;j++)
f[j][k]=max(f[j][k],f[j-w[i].a][k-w[i].b]+v[i]);
```
回到这道题，我们可以得知18*18=33124即大于32768的最小平方数，**那么18就是物品件数**，即选用的物品不可能超过18；**物品的第一维费用便是物品数量的平方**，背包容量便是32768，**第二维费用便是题目中不超过四个整数**，背包容量为4；
那么我们可以写出转移方程
```cpp
for(fint i=1;i<=182;i++)
for(fint j=i*i;j<=32768;j++)
for(fint k=1;k<=4;k++)
f[j][k]+=f[j-i*i][k-1];
```
那么f[j][k]便是选用k件物品平方和为n的种数，稍加处理，即得答案。
```cpp
for(fint i=1;i<=t;i++)
n=read(),get_tot(n);

inline void get_tot(int x)
{
	int ans=f[x][1]+f[x][2]+f[x][3]+f[x][4];
	printf("%d\n",ans);
	return ;
}
```
完整代码就不上了。

那么这道题就结束了，我为大家详细的梳理了**考场暴力骗分**/**完全背包**/**二维费用背包**的知识及其变形，码了半天，希望大家喜欢！

---

## 作者：Dream_It_Possible (赞：4)

##因为$\sqrt{32768}$=181，所以只要枚举181以内的平方，将平方打成表，再加4个剪枝，跑的非常快(至少不超时)。

楼下题解没有剪枝，跑出1540ms，我加了4个剪枝，跑出704ms。

所以：

#剪枝特重要！

上代码


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int a[100005],f[205],dp[100005];
inline void read(int &a)//快读
{
    int k=1; a=0; char c=getchar();
    while(c<'0'||'9'<c){if(c=='-')k=-1; c=getchar();}
    while('0'<=c&&c<='9'){a=a*10+c-'0'; c=getchar();}
    a*=k;
}
int main()
{
    int t,i,j,k,l,mxa=0;
    cin>>t;
    for (i=1;i<=t;i++)
    {
        read(a[i]);
        mxa=max(a[i],mxa);//求出最大值，后面好剪枝
    }
    for (i=1;i<=200;i++)//求出1~200的平方（其实到181即可，理由见上面）
    f[i]=i*i;
    for (i=0;i<=181;i++)//枚举
    {
        if (f[i]>mxa)//剪枝
        break;
        for (j=i;j<=181;j++)
        {
            if (f[i]+f[j]>mxa)//剪枝
            break;
            for (k=j;k<=181;k++) 
            {
                if (f[i]+f[j]+f[k]>mxa)//剪枝
                break;
                for (l=k;l<=181;l++)
                {
                    if (f[i]+f[j]+f[k]+f[l]>mxa)//剪枝
                    break;
                    dp[f[i]+f[j]+f[k]+f[l]]++;//如果可行就累加
                }
            }
        }
    }
    for (i=1;i<=t;i++)
    cout<<dp[a[i]]<<endl;//输出
    return 0;
}

```

---

## 作者：Jyf624761709 (赞：2)

##这题我的主要思路是先把1~32768的算术平方根算出来打个表（也就是1~181的平方，下面的dalao讲过了），然后穷举4个数的值（有点像深搜），最后判重输出就行了~~~

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>
#include<cmath>
const int inf=2147483647;
const int ine=-2147482647;
using namespace std;
#define in(t) freopen("t.in","r",stdin)
#define out(t) freopen("t.out","w",stdout)
#define m(a) memset(a,0,sizeof(a))
typedef long long ll;
int p[200],n,ans=0,f[5];
bool tp[40000];
inline void d(){
    int j=0;
    for(int i=0;i<=182;i++){
        p[++j]=i*i;
        tp[p[j]]=1 ;
    }
}
//这是打表
void dfs(int i,int s){
//主要代码，用来穷举每一个数的值（i是数的序号（第几个），s是还剩下的数值，也就是减去前面的数后剩下的）
    if(i==4){//结束条件，i=4
        if(!tp[s])
            return;
            //（tp是上面打的平方数的表）如果最后一个也为平方数就可以往下做判重的步骤（前面的数在搜的时候已经是平方数了，不用管）
        bool pd=1;
        f[4]=s;
        for(int l=1;l<4;++l){
            if(f[l]>f[l+1]){
                pd=0;
                return;
            }
        }
        //如果这是字典序最小的一个数集排列就说明它是第一个出现的，没有重复
        if(pd)
            ++ans;
        return;
    }
    int t=(int)(sqrt)(s)+1;
    //因为我已经打了一个平方数表了，所以直接从根号s结束，+1是为了保险一点。。。
    for(int j=1;j<=t;++j){
        f[i]=p[j];
        dfs(i+1,s-p[j]);
    }
    //f[i]是记录每一个数，用来上面的判重，s每次减去现在的数
}
int main(){
    int t;
    d();
    //d()打表
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        dfs(1,n);
        //从1开始搜索，s一开始等于n
        printf("%d\n",ans);
        ans=0;
        //最后要归0
    }
    return 0;
}

```

---

## 作者：Michael_Lei (赞：2)

四重循环也是可以过的。

先做一个平方数表，省去每次计算的时间，再用四重循环做预处理，在循环中出现的每一个数x都在f[x]加一，结束时f[i]储存的就是i的方案数。

另外由于方便（和偷懒），不满四个的可以用0代替。

以下是代码

```pascal
var i,j,k,l,n,s,t:longint;a:array[0..181]of integer;f:array[0..131044]of integer;
begin
for i:=0 to 181 do
 a[i]:=i*i;
readln(n);
s:=181;
for i:=0 to s do
 for j:=i to s do
  for k:=j to s do
   for l:=k to s do
    inc(f[a[i]+a[j]+a[k]+a[l]]);
for i:=1 to n do
  begin
   readln(t);
   writeln(f[t]);
  end;
end.
```

---

## 作者：ww3113306 (赞：1)

这道题因为可能会输入很多个数，所以先进行预处理，将题目范围内的每一个数的方案数都提前计算出来，然后直接输出

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,l,o,ans,t,f[5][35000];
int main()
{
    scanf("%d",&t);//读入数的个数
    f[0][0]=1;//设定初始值
        for(i=1;i*i<=32769;i++)//枚举可能出现的组成数 。注意:先枚举可能出现的组成数，不然会无法排除重复的方案
        {
            for(l=1;l<=4;l++)//由l个数组成 
            {
                for(j=i*i;j<=32769;j++)//由l个数组成j 
                    f[l][j]+=f[l-1][j-i*i];//对应方案数加上取i*i的方案数
            }
        }
    for(i=1;i<=t;i++)//用for读入每一个数
    {
        ans=0;//ans的初始值为0
        scanf("%d",&n);//读入
        for(j=1;j<=4;j++)
            ans+=f[j][n];//ans分别加上由1、2、3、4个数组成的方案总数
        printf("%d\n",ans);    //输出
    }
    return 0;//结束
}
```

---


# 互质

## 题目描述

输入两个正整数 $n$ 和 $k$，求与 $n$ 互质的第 $k$ 个正整数。

## 说明/提示

#### 数据规模与约定

对于所有的数据，保证 $1 \leq n \le 10^6$，$1 \leq k\le 10^8$。

## 样例 #1

### 输入

```
10 5```

### 输出

```
11```

# 题解

## 作者：Drifterming (赞：42)

```
//可以发现一个事情
//比如和10互质的数
//1,3,7,9,11,13,17,19,21,23,27,29
//我们可以把它们分成好几部分
//1,3,7,9,   11,13,17,19,   21,23,27,29 
//可以发现，他们的个位数都是一样的
//也就是说，我们可以求出φ(n)，也就是n的欧拉函数值 
//φ(n)就是周期的长度
//那么，我们可以利用这个周期的规律来输出
//把与<n的与n互质的数给存下来
//然后输出 (k-1)/cnt*n+a[(k-1)%cnt+1]
//什么意思呢，(k-1)/cnt找的是第k个数在第几个周期里，+a[(k-1)%cnt+1]就是找对应的数 

//其实它是利用了一个性质：
//if gcd(a,b)==1
//then gcd(a+b,b)==1
//为什么呢。
//设gcd(a,b)=c,
//那么存在互质m,n,使得a=mc,b=nc. (要不然gcd(a,b)就==c*gcd(m,n)了) 
//a+b=(m+n)c
//因为m,n互质,m和n没有>1的共同的因子 
//所以m*n同样和m，n没有>1的共同的因子（质因数分解，很好理解，m*n的因子=m的因子∪n的因子 ） 
//所以m+n和m也是互质,
//由此gcd(a,a+b)=c=gcd(a,b) 
//所以gcd(a,ax+b)=c=gcd(a,b)  （x表示a的x倍，gcd里的mod就是把x给消掉）
//所以在ax~a(x+1)中，与a互质的个数等于<a的数中与a互质的b个数φ(a)
//所以在ax~a(x+1)中, 存在第φ(a)*x~φ(a)*(x+1)个与a互质的数
//所以如果求第k个和n互质的数
//可以算出φ(n)，让k/φ(n)算出x，然后让n*=x，再加上相应的b就是ans了 
//b就是<a的与a互质的数，把它们存下来 

//.....好啰嗦啊。。自己都看不太明白了 

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=1e6+5;

int n,k;
int a[N],cnt;
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;++i)
		if(__gcd(i,n)==1)
			a[++cnt]=i;
	printf("%d",(k-1)/cnt*n+a[(k-1)%cnt+1]);
	return 0;
}
```

---

## 作者：刘心远 (赞：20)

解：                        互质=(gcd=1)

【算法分析】以n=6为例，请注意看与它互质的数：

1，5，7，11，13，17，19，23，25，29，31，35，37，41，43，47，49......

找找规律：每两个数为一组，模6余数相同

1，7，13，19，25，31，37，43，49； 5，11，17，23，29，35，41，47......

n=10来看看！ 1，3，7，9； 11，13，17，19； 21，23，27，29......

看来，每n个数为一个周期（循环） 这样就好做了！

【华丽标程】

```cpp
#include<cmath>
#include<iostream>
using namespace std;
int gcd(int a,int b)    //最大公约数，用于求互质
{
    int r=1; while(r!=0)
    {r=a%b; a=b; b=r;} return a;
};
int main()
{
    int n,k,i,total=0; cin>>n>>k;
    int prime_both[1000000+5];  //存1~n-1中与n互质的数
    for(i=1;i<n;i++) if(gcd(i,n)==1)
    {total++; prime_both[total]=i;}  //总数+1
    cout<<(k-1)/total*n+prime_both[(k-1)%total+1];
    return 0;
}
```
对于输出的那个诡异的公式我解释一下：
(k-1)/total是前面有几组

你一定会问：额，为什么不是k/total呢？答案在后面揭示

(k-1)%total+1其实是这个东西：

当k%total=0时，(k-1)%total+1=total-1+1=total;

当k%total!=0时，(k-1)%total+1=k%total-1+1=k%total

所以，这个东西是这个数在本组中的定位

恍然大悟为何是(k-1)/total了吧！

就比如说输入6，4，则prime\_both[1]=1,prime\_both[2]=5

1，5，7，11，答案是11

前面有（4-1）/2=1组，用6+本组中的定位5=11就是答案！


请大神们多多指教！！！

http://blog.sina.com.cn/s/blog\_1754bd7130102wy7u.html#post


---

## 作者：critnos (赞：9)

考虑二分（倍增），设答案为 $p$，显然对于 $i\in[1,p-1]$，都有 $f(i)<k$。$f(p)=\sum_{i=1}^p [\gcd(i,n)=1]$。即 $[1,p]$ 中与 $n$ 互质的数的个数。

问题转为如何快速计算 $f(p)$？

直接反演：

$$\sum_{i=1}^p \sum_{x|i,x|n} \mu(x)$$

交换求和顺序，即枚举 $n$ 的因数：

$$\sum_{x|n}\sum_{i=1}^{\lfloor \frac p d \rfloor} \mu(x)$$

这就显然了（上面一步其实可忽略）

$$\sum_{x|n}\lfloor \dfrac p d \rfloor \mu(x)$$

（若 $p=n$ 则上式是 $id$ 和 $\mu$ 的狄利克雷卷积，为 $\varphi$）

我们直接考虑莫比乌斯函数的容斥意义：

* 有重复因子则为 $0$

* 为奇数个质因子相乘则为 $-1$

* 为偶数个质因子相乘则为 $1$

对 $n$ 进行质因数分解（PR），直接忽略每个质因数指数（反正多了就是 $0$，对答案没有贡献）。由于 $\mu(x)\in\{1,-1\}$，所以把他们分为两类（正设为 $f$，负设为 $g$）。每次计算时计算

$$\sum_{i\in f} \lfloor \dfrac p i \rfloor-\sum_{j\in g} \lfloor \dfrac p j \rfloor$$

该算法的时间复杂度为 $O(n^{\frac 1 4}+2^{v}\log w)$，$w$ 为答案上界，$v$ 为 $n$ 的不同质因子个数，$2^v$ 至少远远远远少于 $\sqrt n$（我猜他期望是 $\log$ 级别的）。

~~跑的挺快的也就 rk1~~

```cpp
#include<bits/stdc++.h>
#define ll long long
#define it set<int>::iterator
using namespace std;
set<int> mp;
vector<int> p,g;
int pri[20];
int cnt;
inline ll ksm(ll x,ll p,ll md)
{
    ll ans=1;
    while(p)
    {
        if(p&1) ans=(__int128)ans*x%md;
        x=(__int128)x*x%md;
        p>>=1;
    }
    return ans;
}
inline ll ksmn(ll x,ll p)
{
    ll ans=1;
    while(p)
    {
        if(p&1) ans=ans*x;
        x=x*x;
        p>>=1;
    }
    return ans;
}
inline bool test(ll n,ll a,ll d)
{
    if(n==2||n==a) return 1;
    while(!(d&1)) d>>=1;
    ll t=ksm(a,d,n);
    while(d!=n-1&&t!=1&&t!=n-1)
    {
        t=(__int128)t*t%n;
        d<<=1;
    }
    return t==n-1||d&1==1;
}
inline bool MR(ll n)
{
    if(n==2||n==3) return 1;
    if(n==1||n%6!=1&&n%6!=5) return 0;
    if(!test(n,11,n-1)||!test(n,61,n-1))
        return 0;
    return 1;
}
inline ll f(ll x,ll t,ll n)
{
    return ((__int128)x*x+t)%n;
}
inline ll fj(ll x)
{
    ll l,r,t,s;
    for(;;)
    {
        t=rand()%(x-1)+1;
        l=f(0,t,x);
        r=f(l,t,x);
        while(l!=r)
        {
            s=__gcd(abs(l-r),x);
            if(s>1&&s<x) return s;
            l=f(l,t,x);
            r=f(f(r,t,x),t,x);
        }
    }
}
inline void PR(ll x)
{
    if(x==4)
    {
        mp.insert(2);
        return;
    }
    if(x==1) return;
    if(MR(x)) 
    {
        mp.insert(x);
        return; 
    }
    ll qwq=fj(x);
    while(x%qwq==0) 
        x/=qwq;
    PR(qwq),PR(x);
} 
void dfs(int d,int mul,int fl)
{
	if(d==cnt) return;
	dfs(d+1,mul,fl);
	dfs(d+1,mul*pri[d],-fl);
	if(fl==1) g.push_back(mul*pri[d]);
	else p.push_back(mul*pri[d]);
}
int check(int j)
{
	int s=0,i;
	for(i=0;i<p.size();i++)
		s+=j/p[i];
	for(i=0;i<g.size();i++)
		s-=j/g[i];
	return s;
}
int main()
{
    srand(time(0));
    int n,k;
    ll i,j=0;
    cin>>n>>k;
    PR(n);
    for(it i=mp.begin();i!=mp.end();i++)
    	pri[cnt++]=*i;
    p.push_back(1);
    dfs(0,1,1);
    for(i=1ll<<30;i>=1;i>>=1)
    	if(check(i+j)<k)
    		j+=i;
	cout<<j+1;
} 
```


---

## 作者：顾z (赞：8)

**题目描述**

输入两个正整数n和k，求与n互质的第k个正整数。

## 广告 [安利博客](https://87960.blog.luogu.org/#)

**分析：**
 
 ~~其实并不是分析~~
 
 ~~前人已经讲了~~
 
 ~~和题目没有关系emmm~~
 
**欧拉函数**：

对于正整数n,小于n且和n互质的正整数(包括1)的个数计作phi(n);

特殊的我们有 n=1,phi(n)=1;n为素数,phi(n)=n-1;

	性质：
         1.n是质数的某一次方。即n=p^k(p为质数，k为大于等于1的整数)。则phi(n)=p^k-p^(k-1)
       证明：只有当一个数不包含质数p,才可能与n互质,而包含质数p的个数一共有p^(k-1)个。
            即p,2p,3p...p^(k-1)*p 把它们去除,剩下的就是与n互质的数
            把式子写成：phi(p^k)=p^k-p^(k-1)=p^k*(1-1/p)
            
         2.若n可以分解成两个互质的整数之积,即n=p1*p2；
            则phi(n)=phi(p1*p2)=phi(p1)*phi(p2)
         3.任意一个大于1的正整数,都可以写成一系列质数的积。
              n=p1^(k1) *p2^(k2) *.....*pr^(kr)
           我们由性质3 得到phi(n)=phi(p1^(k1))*phi(p2^(k2))......
           再由性质2 得到phi(n)=p1^(k1) *p2^(k2) *.....*pr^(kr)*(1-1/p1)*(1-1/p2)*...*(1-1/pr);
           即phi(n)=n*(1-1/p1)*(1-1/p2)*...*(1-1/pr)
好,终于看完了欧拉函数,那我们最后得到的这个式子有什么用？

~~当然是可以求出phi了啊~~

具体怎么实现？ 

代码如下

```cpp
int phi(int x)
{
    int re=x;
    for(int i=2;i*i<=x;i++)
    {
        if(x%i==0)
        {
            re=re/i*(i-1);
            while(x%i==0)x/=i;
        }
    }
    if(x>1)re=re/x*(x-1);
    return re;
}
```
这样就可以求出我们的phi了!

还有一种方法求phi(),具体就是用线性筛法了！

//具体是运用到了欧拉函数的性质

//这里直接给出代码 具体证明过程我也不太清楚,怕误人子弟,所以不证明了。

```cpp
void getphi()
{
	phi[1]=1;
    for(int i=2;i<=n;i++)
    {
    	if(!vis[i])
        {
        	prime[++tot]=i;
            phi[i]=i-1;
		}
        for(int j=1;j<=tot&&i*prime[j]<=n;j++)
        {
        	vis[i*prime[j]]=true;
            if(i%prime[j]==0)
            {
            	phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
            else phi[i*prime[j]]=phi[i]*phi[prime[j]];
         }
	}
}

```

上面的其实和本题真的没啥关系.....

因为需要求出每一个1~n-1与n互质的数,所以可以直接暴力判gcd==1;

而欧拉函数求的是个数,并不能直接求出每一个对应的数。

还有 关于本题的做法,前面的大佬已经讲过了,所以就不讲了~~(偷懒 逃~~

-----------------AC代码-----------------

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,cnt,pr[10000008],tot;
long long gcd(long long x,long long y){return y==0?x:gcd(y,x%y);}
int main()
{
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<n;i++)
		if(gcd(i,n)==1)pr[++tot]=i;
	printf("%lld\n",(k-1)/tot*n+pr[k%tot]);
    //这里因为数据水吧,直接k%tot,如果k%tot==0,那就要加一咯~
	return 0;
}
//数组一定要开大!!
```

---

## 作者：JOHNKRAM (赞：8)

设n=p1^a1\*p2^a2\*...\*pk^ak，pi为n的质因子

使用欧拉函数φ(n)=n\*(p1-1)\*(p2-1)\*...\*(pk-1)/p1/p2/.../pk

使用一个简单的定理：若a与n互质，则a+n与n互质。

先把k变为x\*φ(n)+y+1(x、y为非负整数)

求出1-n中第y+1个与n互质的数，再加上x\*n即可。


---

## 作者：王奕瑜 (赞：5)

### 算法：数论$+$找规律

------------

- 我们发现，当$n=10$时，与$n$互质的数为：$1,3,7,9,11,13,17,19,......$,若将其分组：$\{1,3,7,9\},\{11,13,17,19\},......$，可以发现，每组相同位置上的数字$mod10$竟是一样的！！！
- 再举一例，当$n=12$时，与$n$互质的数为：$1,5,7,11,13,17,19,23......$,再将其分组：$\{1,5,7,11\},\{13,17,19,23\},......$，可以发现，每组相同位置上的数字$mod12$也是一样的！！！
- 经过不断地探究，我们终于发现：每组的数字个数为$\varphi(n)$(即$n$以内与$n$互质的数的个数)。
- 另外，我们还发现：若$a$与$n$互质，那么$a+n$必与$n$互质，即：若$gcd(a,n)=1$，则$gcd(a+n,n)=1$。
- 有些同学就要问了，为什么以上结论成立呢？实际上，这是用到了一个公式：$gcd(a,b)=gcd(a+b,b)$，证明如下：

------------

**证明**：设$gcd(a,b)=c$，则存在两个互质的数$m,n$，使得$mc=a,nc=b$, 则$gcd(a+b,b)=gcd((m+n)c,nc)$，由于$m$与$n$互质，则$m+n$与$n$也互质，所以$gcd(a+b,b)=c=gcd(a,b)$。

**证毕。**

------------

- 根据以上的结论，若定义$tot=\varphi(n)$，则最后的答案就为$(k-1)/tot*n+a[k\%tot]$，$a[i]$表示$n$以内第$i$个与$n$互质的数。
- 且慢，因为$a$数组是从$1$开始，然而$k\%tot$可能等于$0$，所以我们要稍微改变一下，最后答案为：$(k-1)/tot*n+a[(k-1)\%tot+1]$
- 接下来，就是代码了（~~似乎压行后有点短~~）

------------

```cpp
#include <cstdio>
using namespace std;
void in(int &n) //快读
{
		n=0;int f=1;char c=getchar();
		while (c<'0'||'9'<c){if (c=='-')f*=-1;c=getchar();}
		while ('0'<=c&&c<='9'){n=n*10+(c-'0');c=getchar();}
		n*=f;
}
int gcd(int a,int b){return a%b?gcd(b,a%b):b;} //求gcd
int a[1000005]; //定义a数组
int main()
{
		int n,k,tot=0;in(n);in(k); //定义和读入
		for (int i=1;i<=n;i++)(gcd(n,i)==1)?a[++tot]=i:0;//0是占位的
		printf ("%d",(k-1)/tot*n+a[(k-1)%tot+1]);//输出
		return 0;//这就没了
}
```
-----------
### 广告
- 推荐一下两位同学的博客：
- $1. $[azy巨佬的博客](https://www.luogu.com.cn/blog/3355406081azy/)
- $2. $[yzc巨佬的博客](https://www.luogu.com.cn/blog/ytxnqwl/)

---

## 作者：菜鸟至尊 (赞：4)

本来只想着暴力可以骗点分            
结果就过了                      
可能这就是优雅的暴力吧           
思路如下                
问题:找第K个互质的数    嗯看范围K很大而n比较小

那么先思考问题 给定n范围内有多少个互质的数？

这个比较好求 相当于把不互质的给筛掉    
可以来找一下规律                        
比如12            

因数是2 3 4 

1 ~~2~~ 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ 9 ~~10~~ 11 ~~12~~筛去2倍数  

1 2 ~~3~~ 4 5 ~~6~~ 7 8 ~~9~~ 10 11 ~~12~~筛去3倍数   

1 2 3 ~~4~~ 5 6 7 ~~8~~ 9 10 11 ~~12~~筛去4的倍数   

综合起来                

1 ~~2~~ 3 ~~4~~ 5 ~~6~~ 7 ~~8~~ ~~9~~ ~~10~~ 11 ~~12~~        

看得出来虽然个自筛子的跨度不同但是会同时筛到12   并且这个时候周期再次统一了  
因为n是它们公倍数     
那就说明这个筛法是以n为周期的                                
可以先求出n以内的互质数个数                           
之后的每个周期都是一样的互质数个数                                   
最后一个周期再单独处理就可以了
贴上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int gcd(int x,int y)
{register int temp,a=x,b=y;
       if(a<b)
    swap(a,b);
       while(b!=0)
   temp=a%b,a=b,b=temp;
return a;
}
int main(){int n;int res=0,k,ans=0;cin>>n>>k;
       for(register int i2=1;i2<=n;i2++){
        if(gcd(i2,n)==1)
        res++;}
       for(register int i2=1;i2<=n;i2++){
        if(gcd(i2,n)==1)
        ans++;
		if(ans==k%res){
		cout<<(k/res)*n+i2<<endl;
		return 0;	
		}}
}
```
   ~~写成非递归形式并且加了register的gcd会快一些哦~~

---

## 作者：ZBAA_MKC (赞：3)

结果式子：`(k - 1) / cnt * n + q[k % cnt]`

推导：先找规律

与3互质：

```
1,2
4,5
7,8
10,11
.....
```

与7互质：

```
1,2,3,4,5,6
8,9,10,11,12,13
15,16,17,18,19,20
........
```

我们可以发现，在同一列上的数 $mod 3$ / $mod 7$ 的值都是一样的（其余所有值也是如此）。

然后就可以得到答案式子了。

其中的 `(k - 1) / cnt * n` 表示目标数在第几个周期，`q[k % cnt]` 表示目标数在这个周期的第几个。

我主要与其他题解的不同在于我的 `gcd` 函数采用了更相减损法。如果不了解更相减损法可以参考[这里](https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF/449183?fromtitle=%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%B3%95&fromid=10277459&fr=aladdin)

温馨提示：由于更相减损法速度要慢于欧几里得算法（辗转相除法），所以这个代码需要开 O2 才能过，不开会T两个点。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int gcd(int x, int y) //更相减损法
{
	if (x == y)
	{
		return x;
	}
	int ma = max(x, y);
	int mi = min(x, y);
	return gcd(mi, ma - mi);
}

int q[1000005];

int main()
{
    int n, k;
    cin >> n >> k;
    int cnt = 0;
    for (int i = 1; i < n; i++)
    {
    	if (gcd(i, n) == 1) //记录符合要求的数
    	{
    		++cnt;
    		q[cnt] = i;
		}
	}
	cout << (k - 1) / cnt * n + q[k % cnt]; //按规律输出
	return 0;
}
```


---

## 作者：L2_sheep (赞：2)

题目求第k个与n互质的数。与n互质的数一定满足条件：它不是n的任何一个素因子的倍数。

所有小于等于x与n互质的数的个数，可以由容斥原理来求。
比如求小于等于11与10互质的个数：

11/1 - 11/2 + 11/10 - 11/5 = 11 - 5 + 1 - 2 = 5 （'/'表示向下取整的除法）

那么就可以通过二分答案来快速求出结果。具体代码如下：
```cpp
#include <stdio.h>
#include <math.h>

int p[10], c = 0, ans;

void solve(int pi, int o, int x)
{
	int tx = x / p[pi];
	int i = pi + 1, to = !o;
	
	o ? ans += tx : ans -= tx;
	for( ; i <= c && tx >= p[i]; i++){
		solve(i, to, tx);
	}
}

int main()
{	
	int n, i, k, t, x, l, r, m;
	
	scanf("%d%d", &n, &x);
	
	p[0] = 1;
	t = n, k = sqrt(t);
	for(i = 2; i <= k; i++){
		if(t % i == 0){
			do{
				t /= i;
			}while(t % i == 0);
			p[++c] = i;
			k = sqrt(t);
		}
	}
	if(t > 1) p[++c] = t;
	
	l = 1, r = 1000000000;
	while(l <= r){
		m = (l + r) >> 1;
		ans = 0;
		solve(0, 1, m);
		if(ans >= x) r = m - 1;
		else l = m + 1;
	}
	printf("%d\n", l);

	return 0;
}
```


---

## 作者：米奇奇米 (赞：2)

## 一开始我打啦一个暴力，以为能骗一点分，然而可惜的是，数据大的要命，暴力全部T飞，QAQ~~~

### 万物都可以找出规律——TM
[TM的空间](https://www.luogu.org/space/show?uid=171250)

# 于是我就开始找规律，发现规律显而易见：
## 先看一下样例：n=10，m=4
## 先把10以内与它互质的数找出来：
| 编号 |  数字|
| -----------: | -----------: |
|  1|  1|
|  2|  3|
|  3|  7|
|  4|  9|
## 似乎看不出任何规律：那么我们再来看一下11—20与10互质的数
| 编号 |  数字|
| -----------: | -----------: |
|  1|  11|
|  2|  13|
|  3|  17|
|  4|  19|
## 是不是发现啦什么：编号相同的数字(把两张表对应来看一下)
|  编号|数字  | 数字 |
| -----------: | -----------: | -----------: |
|  1|  1|  11|
|  2|  3|  13|
|  3|  7|  17|
|  4|  9|  19|
## 发现编号相同的数字相差的就是n!!而且这个规律就是n这个数字以内的与其互质的个数数量为一次循环，就像样例中n=10,就是4次一循环，所以要求的第m大的数就是 a[ 编号 ]+n*(循环次数)，而 （循环次数）=m MOD ( n以内与其互质的数的数量 )。

## 于是只要按照找到的规律，就AC啦！！
```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=1e6+5;
int n,m,ans,cnt,s1,s2,a[N];
double s;
inline int read(){
    int n=0,f=1,ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        n=n*10+ch-'0';
        ch=getchar();
    }
    return n*f;
}//读入优化
int main(){
	n=read(),m=read();
	for(register int i=1;i<n;i++)
		if(__gcd(i,n)==1)
		   a[++cnt]=i;
		   a[0]=a[cnt];//先求一遍n以内的与其互质的数，并且计算其数量
	s=(double)m/cnt;//循环的次数
   s1=m%cnt;//s计算的是依次循环中的哪一个数字
	if(s!=(int)s) s++;//如果取MOD是小数，就加1，相当于加一个n
	 cout<<n*(int)(s-1)+a[s1]<<endl;//套用刚刚找出来的规律就可以了
}
	
```
[题目传送门【P1529互质】](https://www.luogu.org/problemnew/show/P1592)








---

## 作者：包子入侵 (赞：2)

证明：gcd(m,n)=gcd(n mod m,m)成立，m,n为正整数，m>0.

证明：

1)1个常识：

如果 a≥b 并且 b≤a，那么 a=b.

2个前提：

1）只在非负整数范围内讨论两个数 m 和 n 的最大公约数，即 m, n ∈ N.

2）0可以被任何数整除，但是0不能整除任何数，即 ∀x(x|0) and ∀x(0| x).
2)1个引理：

假设 k|a, k|b，则对任意的 x,y  ∈ Z， k|(xa+yb)均成立.
证明：

　　k|a => a=pk, k|b => b==qk (其中 p,q ∈ Z)
于是有 xa+yb=xpk+yqk=(xp+yq)k

　　因为 k|(xp+yq)k, 所以 k|(xa+yb)         // 此处表示(xa+yb) 被k整除。
3）gcd的Euclid算法证明：

命题：对任意 m, n ∈ N，证明gcd(m,n) = gcd(n, m mod n)

证明：

　　令 k=gcd(m,n),则 k|m 并且 k|n;
      令 j=gcd(n, m mod n), 则j|n 并且 j|(m mod n);
   对于m, 可以用n 表示为 m=pn+(m mod n);

　　由引理可知 j|m（其中 x=p,y=1）, 又 j|n，于是 j 是 m 和 n 的公约数（但不一定是最大的）;
因为 k 是 m 和 n 的最大公约数，所以必有 k≥j;

通过另一种表示形式：(m mod n)=m-pn,同理可得：

　　k|(m mod n),又k|n，于是 k 是 (m mod n) 和 n 的公约数（也不一定是最大的）;
同样由 j 是 n 和 (m mod n) 的最大公约数可以得到 j≥k;

由常识，得出结论 k=j,

即gcd(m,n) = gcd(n, m mod n) ，得证。

所以若要互质即gcd（x,n)=1则只要gcd（xmodn,n)=1所以只要枚举计算出n以内与n互质的数，同时算出φ(n)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[1000010];
int gcd(int a,int b)
{
    int r=1;
    while (r)
    {
        r=a%b;
        a=b;
        b=r;
    }
    return a;
}
int main()
{
    int n,k,i,num=0;
    scanf("%d%d",&n,&k);
    a[0]=n-1;
    for(i=1;i<n;++i)
        if(gcd(i,n)==1)
        {
        num++;        
        a[num]=i;
}
    printf("%d\n",(k-1)/num*n+a[k%num]);
    return 0;
}
```

---

## 作者：Adove (赞：1)

先质因数分解再埃氏筛多好啊

复杂度$\Theta (n)$比直接GCD的快多了

复杂度证明：

质因数分解$\Theta(\sqrt n)$

埃氏筛法：找最小的几个质数取倒数乘一下加起来不超过2，$\Theta(n)$

扫一遍互质的数：$\Theta(n)$

求解答案：$\Theta(1)$

总复杂度：$\Theta(n)$

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
#include"bitset"
using namespace std;

const int MAXN=1e6+5;

int n,k,tmp;
int c[MAXN],cnt[20];
long long ans;
bitset<MAXN> b;

int main()
{
	scanf("%d%d",&n,&k);tmp=n;
	for(int i=2;i*i<=n;++i){
		if(n>1&&n%i==0){
			while(n%i==0) n/=i;
			cnt[++cnt[0]]=i;
		}
	}if(n>1) cnt[++cnt[0]]=n;
	for(int i=1;i<=cnt[0];++i){
		for(int j=cnt[i];j<=tmp;j+=cnt[i]){
			b[j]=1;
		}
	}for(int i=1;i<tmp;++i) if(!b[i]) c[++c[0]]=i;
	ans=(long long)tmp*((k-1)/c[0])+c[(k-1)%c[0]+1];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：pzk23 (赞：1)

由于gcd(x,n)=gcd(x mod n,n)，那么枚举计算出n以内与n互质的数，同时算出φ(n)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[1000010];
int main()
{
    int n,k,i,num=0;
    scanf("%d%d",&n,&k);
    a[0]=n-1;//当 φ(n) | k 时的特殊处理
    for(i=1;i<n;++i)
        if(__gcd(i,n)==1)a[++num]=i;
    printf("%d\n",(k-1)/num*n+a[k%num]);
    return 0;
}
```

---

## 作者：wanghanjun (赞：0)

先介绍一下欧拉函数φ(n)：n以内与n互质的数的个数

而且对于任意正整数x，x到x+n-1之内与n互质的数等于φ(n)

于是这道题就变成了求[k/φ(n)]* n+a的值（a与n互质的第k%φ(n)数，"[ ]"表示取整），而且比暴力省不少工作量。

φ(n)的求法也比较简单，这里给一个O(√n)的的求φ(n)的方法：
```cpp
t=phi=n;
for(ll i=2;i*i<=n;i++){
    if(t%i==0){
        phi=phi-phi/i;
        while(t%i==0){
            t=t/i;
        }
    }
}
if(t>1){
    phi=phi-phi/t;
}

```
然后就只需要求第k%φ(n)个数了，暴力最多检验n次，效率O(nlogn)，可以通过。

下面是代码：
```
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;

ll gcd(ll x,ll y){
    if(x==0) return y;
    return gcd(y%x,x);
}

int main(){
    ll n,k,phi,t,ans,cnt=0;
    cin>>n>>k;
    t=phi=n;
    for(ll i=2;i*i<=n;i++){
        if(t%i==0){
            phi=phi-phi/i;
            while(t%i==0){
                t=t/i;
            }
        }
    }
    if(t>1){
        phi=phi-phi/t;
    }
    for(ll i=1;i<=n;i++){
        if(gcd(i,n)==1){
            cnt++;
            if(cnt==k%phi){
                ans=i;
                break;
            }
        }
    }
    cout<<(k/phi)*n+ans<<endl;
    return 0;
}
```


---

## 作者：Clever_Jimmy (赞：0)

```cpp
#include <cstdio>

using namespace std;

int n,k,t;
int p[1000010];

int gcd(int a,int b){return b==0?a:gcd(b,a%b);}

int main()
{
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		if(gcd(n,i)==1)
			p[++t]=i;
	}
	printf("%d",(k-1)/t*n+p[k%t]);
/*
	思路大概是这样的：
	裸的gcd肯定是不行的（TLE）
	我们可以这么找规律：
(ans)与8互质的数：			1	3	5	7	9	11	13	15	17	19 ....
(b)是第几个与8互质的数：		1	2	3	4	5	6	7	8	9	10
(c)除以8的余数：				1	3	5	7	1	3	5	7	1	3             有没有发现这一行在循环！
(d)除以8的商：				 0 	 0	 0	 1	 1	 1	 1	 2	 2	 2
(e)减1后再除以8的值：		  0	  0	  0	  0	  1	  1	  1	  1	  2	  2 			有没有发现变整齐了？ 
然后我们发现了这样一个规律：
!!!!!		ans=e*8+c	 !!!!!
这是n=8的规律，显然n=n时有ans=e*n+c
所以我们先把n以内与n互质的数存进p[]里面，顺便找到循环节t
然后就可以知道：
e=(k-1)/t
c=p[k%t]
带入上面的公式可以得到：
ans=(k-1)/t*n+p[k%t]
*/
	return 0;
}
```

---

## 作者：sid_shi1 (赞：0)

[P1592 互质](https://www.luogu.com.cn/problem/P1592)

题目大意：输入两个正整数 $n$ 和 $k$ ，求与 $n$ 互质的第 $k$ 个正整数。

我们先来看一下样例，与 $10$ 互质的数有：

$1$ ,$3$ ,$7$ ,$9$ ,

$11$ ,$13$ ,$17$ ,$19$ ,

$21$ ,$23$ ,$27$ ,$\cdots$ 

会发现（这应该很明显了吧）这些数有周期规律，每行模 $n$ 的余数都相同，

所以，我们只需从 $1$ 枚举到 $n$ ,看看有多少个数与 $n$ 互质，即最大公因数等于 $1$ ，拿个一维数组把这些互质的数存起来，接下来，再求第 $k$ 个数就非常容易了。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[1000001]={0},cnt=0;
int gcd(int x,int y){//求最大公因数
	return (x%y==0)?y:gcd(y,x%y);
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++) if(gcd(i,n)==1) a[++cnt]=i;//若与n互质，个数加一并用数组存起来
    printf("%d",(k-1)/cnt*n+a[(k-1)%cnt+1]);//根据周期规律输出第k个数
    return 0;
}
```


---

## 作者：_pwl (赞：0)

# 分析：
### 思路：
这个题通读一遍题以后，你会发觉：这不就是一道纯数学题吗？

既然看懂了题意，那就很简单了。
### 补充一点简单的数论知识：
两个数的最大公因数是1是，此两数互质。（~~dalao勿喷~~）
好了，不多说，上代码
# 代码：
```cpp
#include<cstdio>
using namespace std;
int n,k,q,p[1000010];
inline int gcd(int a,int b){	//计算a,b的最大公因数 
	return b==0?a:gcd(b,a%b);
}
int main(){
    scanf("%d %d",&n,&k);
    for(int i=1;i<=n;i++){	//枚举 
        if(gcd(n,i)==1)		//众所周知，当两个数的最大公因数为1时，此两数互质。 
            p[++q]=i;		//记录结果 
    }
    printf("%d",(k-1)/q*n+p[k%q]);	//输出n互质的第k个正整数。 
    return 0;
}
```


---


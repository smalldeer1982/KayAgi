# 最小回文数

## 题目描述

回文数是从左向右读和从右向左读结果一样的数字串。

例如：$121$、$44$ 和 $3$ 是回文数，$175$ 和 $36$ 不是。

对于一个给定的 $N$，请你寻找一个回文数 $P$，满足 $P > N$。

满足这样条件的回文数很多，你的任务是输出其中最小的一个。

## 说明/提示

对于 $50 \%$ 的数据，$N < {10}^9$。  
对于 $100 \%$ 的数据，$N < {10}^{100}$。

## 样例 #1

### 输入

```
44```

### 输出

```
55```

# 题解

## 作者：灯芯糕 (赞：92)

## 这题其实并不难，重点在你对回文数的了解，根本就不需要高精度。

### 打个比方：

### 对于一个形如 ABCDEFGH 的整数

### 有且仅有一个比它大的最小回文数

### 有且仅有一个比它小的最大回文数

### 而整数 ABCDDCBA 一定是其中之一

### ~

### 如：99299是比99200大的最小回文数

### 10101 是比 10201 小的最大回文数

### 所以可以得出**结论**：
### ~
### 输入一个整数 ABCD ，若整数ABBA 比 ABCD 大，则 ABBA 就是比它大的最小回文数，然后就可以直接输出这个答案了。
### ~
### 而如果 ABBA 比 ABCD 要小（或等于）那我们就要找到比 ABBA 大的下一个回文数。
### 不难发现它就是：ACCA 且 C=B+1。
## 注意：B=9时要进位，对于9999一类的数要特判！！！
### ~
### 原理：一个回文数是根据它前半部分来的，所以它的下一个回文数就是原回文数的最中间的一个（或两个）数加1得来的。（不懂的要好好想一想）
### 下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,i,f;  char s[201],k[201];
int main(){
    scanf("%s",s);
    l=strlen(s)-1;//下面是特判
    while(s[i++]=='9')if(i==l+1)for(s[0]='1',l++;i>0;i--)s[i]='0';
    for(i=0;i<=l-i;i++)k[i]=k[l-i]=s[i];
    if(strcmp(k,s)<=0){//小于原数的话中间要加1！
        while(k[--i]=='9');k[i]=k[l-i]=++k[i];
        for(i++;i<=l-i;i++)k[i]=k[l-i]='0';
    }cout<<k;
    return 0;
}
//对于特判的解释：
//像9999可以直接转换成10000来算。
```
### 最短代码，不接受质疑。
### 如有不懂可以私信我，如代码有漏洞请各位大佬及时指出，谢谢！

---

## 作者：LuffyLuo (赞：38)

### 这道题好 difficult。
为了不让下面的各位大佬与我~~相提并论~~的想法相同，我整整花了8,9个小时的休息时间，才得以做出来，所以我想~~吐槽一下~~说一下我的艰辛，希望大家能谅解！！！

好了，正式进入主题。

其实这道题难归难，其实也有更简单的方法，可以不用高精，特别是枚举，想都别想，如果枚举最坏的情况可不是我们能预料的，所以我们要用的是关于回文数的特性，顺读法和逆读法相等 ~~这不废话吗~~。

嗯嗯！！！这道题我们就是要用回文数的特性来找规律，不妨给大家举个例子：

#### `ABCDEFGH` 和 `ABCDEFG`。
我们以这两个来进行分析。

首先根据回文数的特性，我们可以得出，如果是 `ABCDEFGH` 要变成回文数，可以变成为 `ABCDDCBA`，或者 `HGFEEFGH` 对不对？没错，`ABCDEFG` 也是同理的。这就是第一步“变”。就是先把它变成回文数。但是代码如何实现呢？？？其实也很简单，不过本人更喜欢 `ABCDDCBA` 这一种，所以上代码吧:
```cpp
	int len,i;
	for(i=len-1;i>=floor(len/2);i--)//这里我们之所以支循环到floor（len/2)是因为，如果len为8，那么这是属于ABCDEFGH这个类型，那么各个数在字符数组的位置为0,1,2,3,4,5,6,7，所以我们只需要循环到4这个地方（以为我们是要把4,5,6,7上的数改换为3,2,1,0上的数）
		b[i]=b[len-1-i];//现在就开始转换，把7,6,5,4上的数让0,1,2,3也与其相同。
```
大家如果未弄懂的话，一定要弄懂，否则下面的程序和思路将会看不懂。

好！现在换位成回文数已经做好了，那么我们现在就进行下一步，比较！比较什么呢，大家仔细想一想，我们的回文数必须得大于原数，所以我们要判断这个原本的 `ABCDEFGH` 和我们创造出来的 `ABCDDCBA` 的大小关系，如果是 `ABCDEFGH` 小于 `ABCDDCBA` 自然是最好的，直接输出就行，无需作太多处理，但是如果是大于或者小于该怎么办了，不要慌。我们再想一下并且看一下 `ABCDEFGH` 和 `ABCDEFGH`，看清楚了吗，想清楚了吗？？？我想以大家的聪明才智一定已经想出来了，没错，我们只需要在 `ABCDDCBA` 上面加一就可以了，有些人会问为什么不在 `AA` 上面加了，大家仔细想一下就清楚了，如果是 `AA` 加最右边的 `A` 加起来确实是最少的，但追左边的 `A` 加起来可就大了，所以我们要加的是 `DD`。

大家看到这里是不是感觉已经完了，不不不不，还有一种特殊情况，如果 `DD` 上为 `99` 呢，这个可就麻烦大了，也不要慌，这里需要用到一小丢丢的高精度，其实也不算高精度，只不过是进位罢了，这个比较也简单，不过忘记讲了，这个可以用一个专门用来比较字符串的函数，代码中会给大家介绍。好了，我们再想一下如果说这个 `DD` 为 `99`，是会对我们的结果有一定的影响的，大家看好了:

如果说 `ABCDDCBA` 为`12399321`，那么经过我们的操作后就会变成 `12410321`，并不是一个回文数对吧，也不要慌，我们再来一次就行了（再来一次“变”）因为再“变”时，就不会在 `DD` 上有 `9` 了。不过也没完，因为还有一个数要特判，如果说全部数都为 `9`，也就是 `99999999`，按我们的方法来处理，就变成了 `100010999`，但最简的答案是 `100000001`，所以这种凡是全部数都为 `9` 的都要特判。代码如下：
```cpp
	int ans1=0，k;//用来统计9在数中出现的次数。k用来保存中间数再数组中的坐标。
	for(i=0;i<len;i++){
		b[i]=a[i];
		if(b[i]=='9') ans1++;//统计9在数中出现的次数。
	}
	if(ans1==len){//如果全部都为9
		for(i=1;i<len;i++)
			b[i]='0';//那么就把ABCDDCBA中的ABCDDCB变为0000000。
		len++;
		b[len-1]='1';
		b[0]='1';//A变为1，再在ABCD的前面加一个E为1，就变成了100000001。
	}
	if(strcmp(b,a)<=0){
			k=floor(len/2);//用k来保存中间数再数组中的坐标。
			if(len%2==0){
				b[k]=(char)b[k]+1;
				b[k-1]=(char)b[k-1]+1;//就在它的中间部位上的数加1。
			}
			else b[k]=(char)b[k]+1;
			for(i=0;i<len;i++){
				if(b[i]>'9'){
					b[i]=(char)b[i]-10;
					b[i+1]=(char)b[i+1]+1;
				} 
			}
			if(b[len]>'0') len++;
			for(i=len-1;i>=floor(len/2);i--)
				b[len-1-i]=b[i];
		}
```
好了全代码为：
```cpp
#include<bits/stdc++.h>
const int MAX=11000;
using namespace std;
char a[MAX],b[MAX];
int main(){
	int i,len,k,ans1=0;
	scanf("%s",a);
	len=strlen(a);
	for(i=0;i<len;i++){
		b[i]=a[i];
		if(b[i]=='9') ans1++;
	}
	if(ans1==len){
		for(i=1;i<len;i++)
			b[i]='0';
     len++;
		b[len-1]='1';
		b[0]='1';
	}
	else{
		for(i=len-1;i>=floor(len/2);i--)
		b[i]=b[len-1-i];
		if(strcmp(b,a)<=0){
			k=floor(len/2);
			if(len%2==0){
				b[k]=(char)b[k]+1;
				b[k-1]=(char)b[k-1]+1;
			}
			else b[k]=(char)b[k]+1;
			for(i=0;i<len;i++){
				if(b[i]>'9'){
					b[i]=(char)b[i]-10;
					b[i+1]=(char)b[i+1]+1;
				} 
			}
			if(b[len]>'0') len++;
			for(i=len-1;i>=floor(len/2);i--)
		      b[i]=b[len-1-i];
		}
	}
	for(i=0;i<len;i++)//输出。
		printf("%c",b[i]);
	return 0;
} 
```
//不用说谢谢，不因客套，只因能见您的笑容，以及您电脑上的 AC，您已经回报。

//祝大家信息学越来越棒哦！

---

## 作者：tututu (赞：14)

贪心……竟然花了那么多时间才想到

取前半个字符串

如果
位数是奇数

则包含中间数

生成回文串

判断若符合条件直接输出

否则在原来的半串中从后往前搜索到一个可以+1的位（9不能+1）

进行加一后生成回文并输出

特判：全部为9

输出1000……0001

pascal code：

```cpp
var
  s,s1:string;
  i,len:longint;
begin
  readln(s);
  len:=length(s);
  s1:=s;
  for i:=1 to len div 2 do
    s1[len-i+1]:=s[i];
  if s1>s then begin write(s1); halt; end;
  i:=(len+1) div 2;
  while (s[i]='9') and (i>0) do dec(i);
  if i=0 then begin write(1); for i:=1 to len-1 do write(0); write(1); halt; end
         else begin inc(s[i]); for i:=i+1 to (len+1) div 2 do s[i]:='0'; end;
  for i:=1 to len div 2 do
    s[len-i+1]:=s[i];
  write(s);
end.
```

---

## 作者：王奕瑜 (赞：9)

### 算法：数论

------------

- 思路和其他人基本相同，我这里稍微说的清楚一点。
- 先说一下将使用的数组：$s[i]$表示输入的$n$（因为$n<10^{100}$），$ans[i]$表示输出的$p$，$s[i]$与$ans[i]$下标都从$0$开始。
- 解决此题，我的方法是分为三步：
#### $1.$ 关于进位的问题
- 我们发现，只有$n$是形如$999...999$的数，输出的答案才会进位，我们不妨特判一下，若$n$是形如$999...999$的数，则将其加$1$，也就是变为$1000...000$，这样就不需要考虑进位的问题啦。
#### $2.$ 将$n$先变成一个回文数，至于是大是小等会考虑
- 从$i=0$枚举到$i\leqslant l-i+1$，使得$ans[i]=ans[l-i+1]=s[i]$，这样，$ans$目前就是一个回文数了。但这个回文数不一定会比$n$大，比如说$n=1999$，变化后$ans=1991$。
#### $3.$ 从中间开始向左搜，找到第一个不是$9$的数，再将中间的$9$全变为$0$，如此变换多次，直到$ans>s$
- 从$i=(l+1)/2-1$开始，向左找第一个不是$9$的数，假设这个位置是$j$，则使$ans[j]$与$ans[l-j+1]$都加$1$。
- 再从$i=j+1$开始枚举到$i\leqslant l-i+1$，使得$ans[i]=ans[l-i+1]=0$。
- 举个例子吧，若第二步后$ans=1991$,则经过第三步一次变化后$ans=2002$。
- 由于不想定义太多变量，以上的$i,j$在代码中均用一个变量$p$表示。
- 且慢，我还没说怎么比较大小呢，这里要用到一个函数$strcmp(char\;s1[],char\;s2[])$，若$s1<s2$，返回的值为$-1$；若$s1=s2$，返回的值为$0$；若$s1>s2$，返回的值为$1$。

------------

- 说完了上面一大堆废话（~~表示我自己都绕晕了~~），但是代码比较短，见下：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
char s[105],ans[105];//含义见上文
int main()
{
        scanf ("%s",s);//读入
        int l=strlen(s);//保存长度
        //特判（步骤1），注意l++
        for (int i=0;i<l&&(s[i]=='9');i++)
            if (i==l-1){s[0]='1';l++;for (int i=1;i<l;i++)s[i]='0';}
        //步骤2：先变成一个回文数
        for (int i=0;i<=l-i-1;i++)ans[i]=ans[l-i-1]=s[i];
        //步骤3
        while (strcmp(ans,s)<=0){
            int p=(l+1)/2-1;while (ans[p--]=='9');p++;
            //找第一个不是9的数
            ans[p]=ans[l-p-1]=ans[p]+1;
            for (p<=l-p-1;p++)ans[p]=ans[l-p-1]='0';
            //将中间的9变为0
        }
        printf ("%s",ans);//输出
        return 0;
}
```
-----------

### 广告
- 推荐一下两位同学的博客（因yzc本人要求，已将巨佬改为蒟蒻）：
- $1. $[azy巨佬的博客](https://www.luogu.com.cn/blog/3355406081azy/)
- $2. $[yzc蒟蒻的博客](https://www.luogu.com.cn/blog/ytxnqwl/)

---

## 作者：Tomone (赞：7)

C++代码
因为范围是10^100，所以int 只能拿到60分。
只能用字符串。
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<sstream>
#define MAXN 3000001
using namespace std;

char str[MAXN],temp[MAXN];
int b[MAXN],len;

int main(){
    cin>>str;
    len=strlen(str);
    for(int i=0;i<len;++i)
        b[i]=str[i]-'0';
    if(len==1){  //一位数和两位数特判一下
    	if(str[0]=='9'){
    		cout<<11;
    		return 0;
		}
		if(str[0]<'9'){
			cout<<str[0]-'0'+1;
			return 0;
		}
	}
	if(len==2){
		if(str[0]>str[1]) cout<<str[0]<<str[0];
		if(str[0]<=str[1]) cout<<str[0]-'0'+1<<str[0]-'0'+1;
		return 0;
	}
	if(len%2==0){  //偶数
		for(int i=0;i<len;++i)
		    temp[i]=str[i];
		temp[len/2]=0;
		if (str[len/2-1]==str[len/2]){ //有可能是回文数
			int i,j;
            for(i = len/2-1,j=len/2;j<len;++j,--i){
                if (str[i] != str[j]) break;
            }
            if(j==len||str[i]<str[j]){ //n为回文数 or 不是回文数且其前半部分小
                int num;
                sscanf(temp,"%d",&num);
                ++num;
                sprintf(temp,"%d",num);
                cout<<num;                        
                for(int i=len/2-1;i>=0;--i){
                    cout<<temp[i];
                }
            }else{ ////不是回文数但其前半部分大
                cout<<temp;
                for(int i =len/2-1;i>= 0;--i)
				    cout<<temp[i];
                }
        }else if(str[len/2-1]<str[len/2]){  //中间靠前的数比后面的小                 
            temp[len/2 - 1] = char(temp[len/2 - 1] + 1);
            cout<<temp;
            for(int i=len/2-1;i>=0;--i){
                cout<<temp[i];
            }
        }else{     //中间靠前的数比后面的大
            cout<<temp;
            for(int i=len/2-1;i>=0;--i){
                cout<<temp[i];
            }
         }
    }
    if(len%2==1){ //奇数
    	for(int i=0;i<len/2+1;++i)
		    temp[i]=str[i];
		temp[len/2+1]='\0';
		int i,j;
		for(i=len/2-1,j=len/2+1;j<len;--i,++j)
            if (str[i]!=str[j]) break;
		if(j==len||str[i]<str[j]){ //n是回文数 或不是回文数但其前半部分小
			int num;
			sscanf(temp,"%d",&num);
			++num;
			sprintf(temp,"%d",num);
			cout<<num;
			for(int i=len/2-1;i>=0;--i)
			    cout<<temp[i];
		}else{ //不是回文数 但前半部分大
			cout<<temp;
			for(int i=len/2-1;i>=0;--i)
			    cout<<temp[i];
		}	
	}
	return 0;
}
```

参考自：https://www.cnblogs.com/itachi7/archive/2012/07/03/2574481.html
洛谷没itoa所以把itoa和atoi都换成ssprintf和sscanf了
蒟蒻博客：aptx.xin

---

## 作者：qwaszx (赞：7)

大概神题...数据比较小...可以加到1e6左右

不过那样子输入格式可能就是坑点

来说正解

先把前面一半（奇数包括中点）存进去，后面一半按照回文的方法构造出来

如果这个样子满足条件直接输出

否则的话，在中间++，然后输出

为什么可以呢？

如果不满足条件的话，因为我们是直接复制的原串

所以中间++即可保证最小并且满足条件

我这种辣鸡一个小时才想到这么做

代码挺短的

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cstdlib>
using namespace std;
string st;
int ans[100000];
int pd,l;
void print()
{
	for(int i=l+1>>1;i>=1;i--)if(ans[i]>9)ans[i-1]++,ans[i]%=10;
	for(int i=(l+1>>1)+1;i<=l;i++)ans[i]=ans[l-i+1];
	if(ans[0])ans[l]=ans[0],cout<<ans[0];
	for(int i=1;i<=l;i++)cout<<ans[i];
}
int main()
{
	cin>>st;
	l=st.size();
	for(int i=1;i<=l+1>>1;i++)
		ans[i]=st[i-1]-48;
	for(int i=(l+1>>1)+1;i<=l;i++)
		ans[i]=ans[l-i+1];
	pd=0;
	for(int i=1;i<=l;i++)
		if(ans[i]+48!=st[i-1])
		{
			pd=ans[i]+48>st[i-1];
			break;
		}	
	if(!pd)ans[l+1>>1]++;
	print();
}
```

---

## 作者：loi_hjh (赞：2)

# 温馨提示：为了防止抄袭，我把优化去掉了，如果你直接交只要70呦

附上代码：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ri register int
using namespace std;
char a[10001];
int l;
inline bool ishuiwen(){
	for(ri i=1;i<=(l+1)/2;i++)//判断回文鸭 
		if(a[i]!=a[l-i+1]) return false;
	return true;
} 
int main(){
	scanf("%s",a+1);//读入字符串（数据范围10^100） 
	l=strlen(a+1);
	reverse(a+1,a+l+1);//翻转，下面进位用 
	for(ri i=1;i<=l;i++)
		a[i]-='0';
	while(1){//模拟 
		a[1]++;
		for(ri i=1;i<=l;i++){//如果后面的某一位不能进了，前面也就不行了 
			if(a[i]>=10){
				a[i+1]++;
				a[i]-=10;
			}
			else break;
		}
		if(a[l+1]) l++;//如果是位数增加了，比如999->1000 
		if(ishuiwen()) break;
	}
	for(ri i=l;i>=1;i--)//把逆序的转回来 
		printf("%d",a[i]);
	return ~~(0-0);
}


```

---

## 作者：yf最qhhh (赞：1)

一开始没注意数据范围，于是有了下面这个正确又 TLE 的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string arr[10005],brr[10005];
bool hws(long long x){
	long long cnt=0;
	long long r=x;
	while(r>0){
		arr[++cnt]=r%10;
		r=(r-(r%10))/10;
	}
	for(long long i=cnt;i>=1;i--){
		brr[cnt-i+1]=arr[i];
	}
	bool flag=1;
	for(long long i=1;i<=cnt;i++){
		if(arr[i]!=brr[i])flag=0;
	}
	if(flag)return true;
	else return false;
}
int main(){
	long long n;
	scanf("%lld",&n);
	for(long long i=n+1;;i++){
		if(hws(i)){
			cout<<i;
			return 0;
		}
	}
}

```
后来才反应过来要用字符串，方法呢题解里最上面的那个大佬已经说得很清楚了，所以我直接放代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int arr[100005];
int main(){
string s;
	cin>>s;
	int len=s.length();
	bool ans=0;
	for(int i=1;i<=(len+1)/2;i++)arr[i]=s[i-1]-'0';//前一半
	for(int i=(len+1)/2+1;i<=len;i++)arr[i]=arr[len-i+1];//后一半
	for(int i=1;i<=len;i++){//判断前面的是否大于后面的
		if(arr[i]+'0'!=s[i-1]){
			if(arr[i]+'0'>s[i-1])ans=1;
			break;
		}	
	}	
	if(ans==0)arr[(len+1)/2]++;//ans等于0说明前面小于了后面
	for(int i=(len+1)/2;i>=1;i--){//一系列的特判，首先是判断有没有位的数大于9
		if(arr[i]>9){
			arr[i-1]++;
            arr[i]%=10;
		}
	}
	for(int i=(len+1)/2+1;i<=len;i++){
		arr[i]=arr[len-i+1];
	}
	if(arr[0]!=0){//首位不为0就输出
		arr[len]=arr[0];
		cout<<arr[0];
	}//剩下的位依次输出就好
	for(int i=1;i<=len;i++){
		cout<<arr[i];
	}
	return >.<;//完美AC！
}
```


---

## 作者：scp020 (赞：0)

### 本题位数较大，所以只能使用字符串读入

因为是回文数，所以我们只考虑前半部分的情况就能确定一个回文数。

如一个型为 $\overline{xyz}$ 的数，我们考虑 $\overline{xyx}$（这个数是回文数）是否大于 $\overline{xyz}$，如果大于，那么就可以输出 $\overline{xyx}$，否则就把 $y$ 自增 $1$，并且考虑进位（详情见高精度），直到我们求出的数大于原数为止。

这里要特判一下，如果输入是 $9$，我们就直接输出 $11$。

**这题和 [SP5](https://www.luogu.com.cn/problem/SP5) 相似，双倍经验等着你！**

不多说了，上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int a[1000010],p[1000010],l;
char s[1000010];
bool palin(int x[],int y[])
{
	for(int i=0;i<l;i++) if(x[i]!=y[i]) return x[i]<y[i];
	return false;
}
int main()
{
	scanf("%s",s),l=strlen(s);
	if(strcmp(s,"9")==0)
	{
		cout<<11<<endl;
		return 0;
	}
	for(int i=0;i<l;i++) a[i]=s[i]-'0';
	for(int i=0;i<=(l-1)/2;i++) p[i]=p[l-i-1]=a[i];
	if(!palin(a,p))
	{
		a[(l-1)/2]++;
		for(int i=(l-1)/2;i;i--) a[i-1]+=a[i]/10,a[i]%=10;
		for(int i=0;i<=(l-1)/2;i++) p[i]=p[l-i-1]=a[i];
	}
	for(int i=0;i<l-1;i++) cout<<p[i];
	if(p[l-1]==10) cout<<1<<endl;
	else cout<<p[l-1]<<endl;
	return 0;
}
```


---

## 作者：SegTree (赞：0)

$\text{Update 2022/8/28}$ 更正题目引标错误。

[题目传送门。](https://www.luogu.com.cn/problem/P1609)

## 题目分析
+ 设这个数为 $\overline{a_1 a_2 \cdots a_n}$。
+ 若 $n\bmod 2=1$，那么将 $\overline{a_1 a_2 a_3\cdots a_{n/2+1}}$（这里 $n/2$ 默认向下整除。）复制一遍，删去末尾并反转，拼在原数后面。
+ 如果这个数大于原数，答案就是这个结果。
+ 如果这个数不大于原数，那么将它加一，再像上面一样复制再删去末尾并反转拼在后面。答案就是这个结果。
+ 若 $n\bmod 2=0$，那么将 $\overline{a_1 a_2 a_3\cdots a_{n/2}}$ 复制一遍拼在原数后面。如果大于原数就是结果。
+ 否则就加一再反转拼在后面，就是结果。
+ 但是上面的算法会有一个问题，$n=1$ 时无法正确处理。那么若原数小于 $9$ 返回这个数加一，否则返回 $11$。
+ 另外一个问题：输入 $999$ 会输出 $10001$。
+ 于是特判所有数字都是 $9$ 的点，即将位数加一，第一个数为 $1$，最后一个数为 $1$，中间为 $0$。
+ 因为只用 $+1$，没必要套高精加。
+ 于是我们就 AC 了本题。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Big {
    int a[1000005],len;
    void input(){
        string s;
        cin>>s;
        len=s.length();
        for(int i=0;i<len;++i){
            a[i+1]=s[i]-'0';
        }
    }
    void output(){
        for(int i=1;i<=len;++i)printf("%d",a[i]);
        printf("\n");
    }
    string to_Str(){
        string s;
        for(int i=1;i<=len;++i){
            s+=a[i]+'0';
        }
        return s;
    }
    void to_Big(string s){
        memset(a,0,sizeof(a));
        len=s.length();
        for(int i=0;i<len;++i){
            a[i+1]=s[i]-'0';
        }
    }
};
bool operator>(Big a,Big b){
    if(a.len!=b.len)return a.len>b.len;
    for(int i=1;i<=a.len;++i){
        if(a.a[i]!=b.a[i])return a.a[i]>b.a[i];
    }
    return 0;
}
Big add(Big s){
    s.a[s.len]++;
    if(s.a[s.len]<=9)return s;
    for(int i=s.len-1;i>=1;--i){
        s.a[i]+=s.a[i+1]/10;
        s.a[i+1]%=10;
    }
    if(s.a[1]>=10){
        char ch=s.a[1]/10+'0';
        s.a[1]%=10;
        string t=ch+s.to_Str();
        s.to_Big(t);
        return s;
    }
    return s;
}
Big ans(Big s){
    if(s.len==1){
        if(s.a[1]<9){
            Big k=s;
            k.a[1]++;
            return k;
        }
        else {
            Big k;
            k.len=2;
            k.a[1]=1;
            k.a[2]=1;
            return k;
        }
    }
    bool F=0;
    for(int i=1;i<=s.len;++i){
        if(s.a[i]!=9)F=1;
    }
    if(!F){
        s.len++;
        s.a[1]=s.a[s.len]=1;
        for(int i=2;i<s.len;++i)s.a[i]=0;
        return s;
    }
    if(s.len%2){
        Big t;
        t.len=s.len/2+1;
        for(int i=1;i<=s.len/2+1;++i){
            t.a[i]=s.a[i];
        }
        string a=t.to_Str();
        reverse(a.begin(),a.end());
        a.erase(a.begin());
        Big k;
        k.to_Big(a);
        a=t.to_Str()+k.to_Str();
        k.to_Big(a);
        if(k>s)return k;
        else {
            t=add(t);
            a=t.to_Str();
            reverse(a.begin(),a.end());
            a.erase(a.begin());
            Big k;
            k.to_Big(a);
            a=t.to_Str()+k.to_Str();
            k.to_Big(a);
            return k;
        }
    }
    else {
        Big t;
        t.len=s.len/2;
        for(int i=1;i<=s.len/2;++i){
            t.a[i]=s.a[i];
        }
        string a=t.to_Str();
        reverse(a.begin(),a.end());
        Big k;
        k.to_Big(a);
        a=t.to_Str()+k.to_Str();
        k.to_Big(a);
        if(k>s)return k;
        else {
            t=add(t);
            a=t.to_Str();
            reverse(a.begin(),a.end());
            Big k;
            k.to_Big(a);
            k.to_Big(t.to_Str()+k.to_Str());
            return k;
        }
    }
}
int T;
Big a;
int main(){
    cin>>T;
    while(T--){
        a.input();
        ans(a).output();
    }
}
```

---


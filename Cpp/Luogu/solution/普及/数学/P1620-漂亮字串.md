# 漂亮字串

## 题目描述

Caima 认为 $\tt O$ 和 $\tt X$ 是最优美的两个字母，由 $\tt O,X$ 组成的串是最优美的串。在这些最优美的串中，如果任意只包含 $\tt X$ 的子串，长度不超过 $\max_{\tt X}$，任意只包含 $\tt O$ 的子串，长度不超过 $\max_{\tt O}$，而整个串最多有 $\rm count_{\tt O}$ 个 $\tt O$，$\rm count_{\tt X}$ 个 $\tt X$。那么这个就是超级优美无敌串。

现在 Caima 想知道最长的超级优美无敌串有多长，希望你告诉他。

## 说明/提示

### 样例 2 解释

- $\tt XOXOXOX$。


### 数据范围及约定

最多 $1000$ 组数据，

其中 $30\%$ 的数据 $0\le \rm count_{\tt O},\rm count_{\tt X},\rm max_{\tt O},\rm max_{\tt X} \le 20$，且数据组数不超过 $20$ 组。

对于全部数据，$0 \le \rm count_{\tt O},\rm count_{\tt X},\rm max_{\tt O},\rm max_{\tt X}\le 10^6$。

## 样例 #1

### 输入

```
10 10 0 0
3 5 1 1
```

### 输出

```
0
7
```

# 题解

## 作者：ex_jason (赞：9)

从整体上对题目进行分析，此题共有三种情况：


（1）0


有一方为0，则结果为另一方的max；


两方都为0,则结果为0；


（2）一方多，另一方不够用，满足（contx+1）\*maxo<=counto或则（conto+1）\*maxx<=countx


结果为：（contx+1）\*maxo+counto （X不够用）


或则

（cont0+1）\*maxx+counto  (O不够用)


也即，不够用的一方即使每次只取一个作为分隔符都不够用的。


比如，20 5 2 2


则最长的超级优美无敌串为：OOXOOXOOXOOXOOXOO


(3)其它情况，则结果为 maxn+maxm


除去（1）（2）两种特殊情况，则其他情况中所有的字母都可以用上。


比如8 6 3 2


则最长的超级优美无敌串为：OOOXXOOOXXOOXX

```cpp
#include<iostream>
using namespace std;
int main()
{
    long long counto,countx,maxo,maxx;
    while (cin>>counto>>countx>>maxo>>maxx)
    {
        maxo=min(counto,maxo);
        maxx=min(countx,maxx);
        if (maxo==0) cout<<maxx<<endl;
        else if (maxx==0) cout<<maxo<<endl;
        else if ((counto+1)*maxx<countx) cout<<(counto+1)*maxx+counto<<endl;
        else if ((countx+1)*maxo<counto) cout<<(countx+1)*maxo+countx<<endl;
        else cout<<counto+countx<<endl;
    }
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：4)

//本段文字来自复赛 

如果maxO是零的话，说明就只有一段x。答案就是maxX，maxX是零也是同理。

现在考虑剩余的情况 ，我们先假设x不够用，说明就算是每次放maxO个O，然后用一个X把它们隔开，这种情况X还是不够用。

OOO…OOOXOOO…OOO…；

也就是说：CountO>(CountX+1)\*maxO;

那么答案最大就是CountX+(CountX+1)\*maxO.

同理，O不够的情况也是如此。

对于剩下的情况，答案就是CountX+CountO。值得注意的是，在计算(CountX+1)\*maxO的时候会爆int，所以建议用long long。

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
using namespace std;
int main()
{
    freopen("bs.in","r",stdin);//文件……抄题解的自行删除 
    freopen("bs.out","w",stdout);
    int co=0,cx=0,mo=0,mx=0;
    while (scanf("%d%d%d%d",&co,&cx,&mo,&mx)==4)//输入  
    {
        if (co<cx)//这个判断是为了使co>cx 
        {
            int t=mo;mo=mx;mx=t;//交换 
            t=co;co=cx;cx=t;//交换 
        } 
        if (mo==0)//这说明串里面不能放一个O 
        {
            if (mx<cx) printf("%d\n",mx); else printf("%d\n",cx); //其实就是输出mx和cx中较小的一个，因为需要满足两个条件，串的长度<=mx且串的长度<=cx 
            continue; //进入下一次循环 
        } 
        if (mx==0)//这说明串里面不能放一个X
        {
            if (mo<co) printf("%d\n",mo); else printf("%d\n",co); //其实就是输出mo和co中较小的一个，原因同上 
            continue; //进入下一次循环 
        } 
        int s;//=(cx+1)*mo;
        if (((long long)((cx+1)*mo)<(long long)(co))&&((long long)((cx+1)*mo)>0)) //是否多余 
            s=cx+(cx+1)*mo; //存结果 
            else s=co+cx;//存结果 
        printf("%d\n",s);//输出 
        co=0;cx=0;mo=0;mx=0;//没用 
    }
    return 0;
}
```

---

## 作者：王奕瑜 (赞：2)

## 算法：贪心+分情况讨论

------------

- 这题共分为以下三种情况：
- $1.$若序列中只有$X$，则输出$maxX$;若序列中只有$O$，则输出$maxX$。
- $2.$若$(CountO+1)\times maxX<CountX$，则输出$(CountO+1)\times maxX+CountO$；同理，若$(CountX+1)\times maxO<CountO$，则输出$(CountX+1)\times maxO+CountX$。
- 这里我要说一下，很多人（包括我在内）这一步刚开始不懂是什么意思，实际上，这里用到了一个贪心的思路：满足$(CountO+1)\times maxX<CountX$的$X$一定比$O$多，那我们就要**保证没有连续的$O$，并在每两个$O$之间（包括开头）插入尽量多的$X$**，同理可知另一种情况的贪心方法。这样就可以保证这个串是最长的。
- $3.$若属于除$1$、$2$的其余情况，答案均为$CountO+CountX$。 

------------

### 注意：
- $1.$本题数据可能会出现$max>Count$的情况，要取$\min$;
- $2.$本题是多组数据。
- $3.$记得开$\text {long long}$。

------------

### 代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int main()
{
        //对照上文食用效果更佳
        long long cntx,cnto,mxx,mxo;//由于作者很懒，故变量简写
        while (~scanf("%lld %lld %lld %lld",&cnto,&cntx,&mxo,&mxx))
        //注意多组数据
        {
            mxo=min(mxo,cnto);mxx=min(mxx,cntx);//记得特判
            //情况1
            if (mxo==0) printf ("%lld\n",mxx);
            else if (mxx==0) printf ("%lld\n",mxo);
            //情况2
            else if ((cnto+1)*mxx<cntx) printf ("%lld\n",(cnto+1)*mxx+cnto);
            else if ((cntx+1)*mxo<cnto) printf ("%lld\n",(cntx+1)*mxo+cntx);
            //情况3
            else printf ("%lld\n",cnto+cntx);
        }
        return 0;
}

```

-----------

### 广告
- 推荐一下两位同学的博客（因$yzc$本人要求，已将巨佬改为蒟蒻）：
- $1. $[$azy$巨佬的博客](https://www.luogu.com.cn/blog/3355406081azy/)
- $2. $[$yzc$蒟蒻的博客](https://www.luogu.com.cn/blog/ytxnqwl/)

---

## 作者：antiquality (赞：1)

数论题（？）脑筋急转弯（？）

· 当时比赛的时候居然这题想了两个多小时，好像~~心里有些抗拒数论的感觉~~

· 其实不难发现div之后相差过大的意味着不足够O或者X，所以此时要把maxO / maxX取min，可以引入参量co.cp

· 然后小的是肯定能够放完的，所以可以分完类之后在值后面直接加上

· 多的想要放完只有让小的边上不停填上才能够实现，如同增大表面积加快反应一个道理

· 就此不难得出min{(b+1)\*c,a}+b或者min{(a+1)\*d,b}+a（分类讨论）。

· 加上=0时候的特判就容易做出了


附一则《新编全国青少年信息学竞赛培训教材（复赛篇）》上的思路

```pascal
如果maxO=0，说明最多就只有一段X,ANS=maxX,maxX=0也同理
假设X不够用，说明就算是每次放maxO个O，然后用一个X把它们隔开，这种情况X还是不够用
OOO...OOOXOOO...OOOXOOO...OOO...
也就是说：CountO>(CountX+1)*maxO
ANSmax=CountX+(CountX+1)*maxO
同理O不够的情况也是这样
对于剩下的情况，ANS=CountX+CountO
```

---

## 作者：Erotate (赞：1)

我们直接分类讨论即可：

1. $CountO$ 或 $maxO$ 为 0 时，字符串只包含 $X$ ,那答案为 $\min(CountX,maxX)$。

2. 同理，当 $CountX$ 或 $maxX$ 为 0 时，答案为 $\min(CountO,maxO)$。

3. 当 $O$ 不够用时，即 $CountX>maxX*(CountO+1)$，每个 $O$ 对应着 $maxX$ 个 $X$，但 $X$ 还是有多的，那答案为 $maxX*(CountO+1)+CountO$。

4. 与 3. 同理，当 $X$ 不够用时，答案为 $maxO*(CountX+1)+CountX$。

5. 其他情况，字符串最长为 $CountX+CountO$。

代码：
```cpp
//这里 cx，mx，co，mo，分别代表 CountX，maxX，CountX，maxO。
#include<bits/stdc++.h>
#define int long long
using namespace std;
int cx,co,mx,mo;
signed main(){
	while(cin>>co>>cx>>mo>>mx){
		if(!(min(co,mo))) cout<<min(cx,mx)<<endl;
		else if(!(min(cx,mx))) cout<<min(co,mo)<<endl;
		else if(cx>mx*(co+1)) cout<<mx*(co+1)+co<<endl;
		else if(co>mo*(cx+1)) cout<<mo*(cx+1)+cx<<endl;
		else cout<<cx+co<<endl;
	}
	return 0;
}
```


---

## 作者：ljc20020730 (赞：1)

我是看成ox序列为AB的，易于理解

本题无疑要分段：

首先，

最简单的maxa=0的情况答案只能是包含全B序列maxb

maxb=0的情况答案只能是包含全A序列maxa

可以简单写成：

```cpp
 maxa:=min(maxa,cnta);
 maxb:=min(maxb,cntb);
 if (maxa=0) then exit(maxb);
 if (maxb=0) then exit(maxa);
```
假设A不够用，说明就算是每次放maxB个B，然后用一个B把它们隔开，这种情况B还是不够用

OOO...OOOXOOO...OOOXOOO...OOO...

也就是说：sum div (cntb+1)>maxa ( sum:=cnta+cntb;)

ANS==maxa\*(cntb+1)+cntb

同理O不够的情况也是这样:

if sum div (cnta+1)>maxb then exit(maxb\*(cnta+1)+cnta);

剩下的情况是非常好的，可以一段一个分割，


```cpp
ANS=CountX+CountO
uses math;
var cnta,cntb,maxa,maxb:longint;
function calc:longint;
var sum:longint;
begin
 maxa:=min(maxa,cnta);
 maxb:=min(maxb,cntb);
 if (maxa=0) then exit(maxb);
 if (maxb=0) then exit(maxa);
 sum:=cnta+cntb;
 if sum div (cntb+1)>maxa then exit(maxa*(cntb+1)+cntb);
 if sum div (cnta+1)>maxb then exit(maxb*(cnta+1)+cnta);
 exit(cnta+cntb);
end;
begin
 while not eof do begin
  readln(cnta,cntb,maxa,maxb);
  writeln(calc);
 end;
end.
```

---

## 作者：AzzyZhe (赞：0)

## 题解 P1620 漂亮字串
$\rightarrow$ [题目传送门](https://www.luogu.com.cn/problem/P1620)

只需考虑两种情况：

1. X 或 O 其中一者的 Count 或 max 为 $0$，显然串中只能含另一者且连续放置，其能放置的最大数目（Count 和 max 中较小者）即为答案。 

2. （此处设 `CountO>=CountX`）将 Count 较小者 X 插入连续的 O 串，分为最多 (CountX+1) 个部分，再乘以单个连续串的最大长度 maxO 后即为串的最大 O 容量，而由于 CountO 不小于 CountX，所有的 X 一定都能合法地放入串中，因此串最终长度只需再加上 CountX。

此外，古人云：
>不用 `long long` 见祖宗。

代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long a,b,ma,mb,ans;
int mian()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	while(cin>>a>>b>>ma>>mb)
	{
		if(!ma||!a)
			ans=min(b,mb);
		else if(!mb||!b)
			ans=min(a,ma);
		else
		{
			if(a<b)
				swap(a,b),
				swap(ma,mb);
			ans=min(ma*(b+1),a)+b;
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

考虑到情况一的部分情况也可在情况二的式子中得到相同结果，理清逻辑后我们也可以将上述内容压入一个式子，只是反而显得冗长了。


压行后核心：
```cpp
if(a<b)swap(a,b),swap(ma,mb);
ans=min(ma*((mb?b:0)+1),a)+(mb?(ma?b:min(b,mb)):0);
```


---

## 作者：mmqqdd (赞：0)

```delphi

很简单,以一个数为隔板，求最大值即可
var x,y,maxx,maxy,ans1,ans2,t:int64;
begin
assign(input,'bs1.in');
assign(output,'bs.out');
reset(input);
rewrite(output);
while not eof do
begin
ans1:=0;ans2:=0;

readln(x,y,maxx,maxy);
if maxx=0 then begin if maxy>y then maxy:=y; writeln(maxy);continue;end;
if maxy=0 then begin if maxx>x then maxx:=x; writeln(maxx);continue;end;
if x=y then begin writeln(x+y);continue; end;
if (y>=x+1)then
              begin
                if (maxy*(x+1)>=y) then ans1:=x+y
                         else ans1:=x+maxy*(x+1);
              end;

if (x>=y+1)then begin
                 if (maxx*(y+1)>=x) then ans2:=x+y
                            else ans2:=y+maxx*(y+1);
               end;

if ans1>ans2 then writeln(ans1)else writeln(ans2);
end;
close(input);
close(output);
end.

```

---


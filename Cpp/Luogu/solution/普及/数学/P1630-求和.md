# 求和

## 题目描述

求 $1^b+2^b+\cdots + a^b$ 的和除以 $10^4$ 的余数。

## 说明/提示

对于 $30\%$ 的数据，$N \le 10$，$a,b \le 10^3$。

对于 $100\%$ 的数据，$1 \le N \le 100$，$1 \le a,b \le 10^9$。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
9
```

# 题解

## 作者：摸鱼 (赞：34)

### - 前置知识:
```latex
	(a+y)^x=a^x(mod y)
```

快速幂：比较简单的数论基础，如果没有学过，[快速幂传送门](https://www.luogu.org/problem/P1226)

------------

### - 当我看到这一题时，我脑子里冒出了两个想法：
 1. 这题的快速幂是妥妥的（√）
 
 2. ~~在吗？模数是不是质数？可不可以套逆元？（×）~~ 然而沙雕的我却忽略了模数那小到可怜的大小，显然这一题必须针对模数进行操作，且时间复杂度与x,y无关，所以：
 ```latex
	a^x 可化为 (a%10000)^x
```
所以我们只要用一个sum前缀和数组存储前i个数的次方和:

------------

```cpp
	sum[i]=(sum[i-1]+qpow(i,b))%mod;
```

------------

然后O(1)求答案：

------------

```latex
	ans=n/10000*sum[10000]+sum[n%10000]
```

------------

详见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;//同#define LL long long
const LL mod=10000;
LL a,b,ans,sum[10010];
inline LL qpow(LL a,LL p,LL mod){//快速幂模板，求a^p
	LL sum=1;
	while(p){
		if(p&1){
			sum=sum*a%mod;
		}
		a=a*a%mod;
		p>>=1;//通过倍增的方法求幂；
	}
	return sum%mod;
}
int main(){
	LL Time; 
	scanf("%lld",&Time);
	while(Time--){
		scanf("%lld%lld",&a,&b);
		for(register LL i=1;i<=10000;++i){
			sum[i]=(sum[i-1]+qpow(i,b,mod))%mod;//针对模数下手，用数组求出(i<=10000)的前缀和
		}
		ans=(a/10000*sum[10000]+sum[a%10000])%mod;//通过上文所将的前缀和以O(1)求出答案；
		printf("%lld\n",ans);
	}
}
```
综上所述，预处理O(mod),求值O(1),所以时间复杂度为O(T*mod)，空间复杂度为O(10000)，能够通过评测

---

## 作者：JustinRochester (赞：27)

发现题解都不够优雅，就自己来一篇

( 以下除【代码】处代码，其余均为现场手打，如有误请与本蒟蒻联系 )

---
**【分析】**
--

首先，看清楚了，题目是 $\sum_{i=1}^ai^b$ 的余数 ，而不是 $\sum_{i=1}^ab^i$ ~~( 等比数列求和了解一下 )~~

毕竟......本蒟蒻一开始就看错了......

好，进入正题，介于 $a,b\leq 10^9$ ，暴力就想都不用想了，肯定过不了每一次乘法需要 $O(b)$ 的时间，加法需要 $O(a)$ 的时间，外部一个 $O(N)$ 的循环，总复杂度 $O(Nab)=10^{20}$ ，大概要 $10^{12} s$ ，也就是大概 $31710$ 年吧 ~~逃~~

首先，有一个很优秀的方法可以优化乘法，那就是 **快速幂** ！

如果你要求 $a^x$ 那么你就先求出 $a^{\lfloor {x\over 2}\rfloor}$

然后 $a^{\lfloor {x\over 2}\rfloor}\times a^{\lfloor {x\over 2}\rfloor}$ 就完事啦！

递归边界在于当 $x=1$ 时 $a^1=a$ 

那奇数怎么办？我们知道 $a^4=a^2\times a^2$ ，但 $a^5\neq a^2\times a^2$ 啊

没事，你想， $a^5=a^2\times a^2\times a^1$ 对不对？

同理，$a^x=a^{\lfloor {x\over 2}\rfloor}\times a^{\lfloor {x\over 2}\rfloor}\times a$ ( $x$ 为奇数)

所以，我们可以递归地盘它了：

```cpp
int pow(int a,int x){
	if(x==1) return a;
	int p=pow(a,x/2);
	if(x%2==1) return (p*p%Mod)*a%Mod;
	else return p*p%Mod;
}
```

当然，喜欢三目运算符和位运算的小伙伴们可以更优雅地盘它：
```cpp
int pow(int a,int x){
	if(x==1) return a;
	int p=pow(a,x>>1);
	return (p*p%Mod)*((x&1)?a:1)%Mod;
}
```
这边再推荐一下非递归的打法，因为有的地方的评测机可能会爆栈：
```cpp
int pow(int a,int x){
	int bas=a,ans=(x&1)?a:1;
	while(x>>=1){
		bas=bas*bas%Mod;
		if(x&1) ans=ans*bas%Mod;
	}
	return ans;
}
```

好的，我们可喜的发现，由于每次递归都是对半，求 $i^b$ 的方法优化到了 $O(\log b)$，现在的总复杂度为 $O(Na\log b)$ 了，大概为 $10^{12}$ 大概要 $10^4s$ 了，也就是 $3$ 小时 ~~再逃~~

这说明我们还是不够优雅的，我们还得继续优化

---

我们还能发现，根据同余的性质： $(a+10000)\equiv a (\mod 10000)$

两边同时翻 $b$ 次方得：

$(a+10000)^b\equiv a^b(\mod10000)$

这说明了啥？说明我们对于任何大于 $10000$ 的数 $n$ ，它的 $b$ 次方我们已经求过了，就是 $(n\%10000)^b$
>因为本人是 C++ 选手，所以习惯用 $a\%b$ 表示 $a$ 除以 $b$ 的余数

好的，所以我们把 $1$ ~ $10000$ 的 $b$ 次方存起来，比如用 $c_i$ 表示 $i^b\%10000$ 。

我们先预处理 $c_1$~$c_{10000}$ ，接下来，每次我们要 $i^b$ ，就直接用 $c_{i\%10000}$ 即可。

耶！总复杂度又下降了，每次预处理都是 $O(10000\log b)$ 的，统计是 $O(a)$ 的

$\because 10000\log b\leq 10^4\times 10^2=10^6\leq 10^9=a$

$\therefore O(10000\log b)+O(a)=O(a)$

总复杂度为 $O(Na)=10^{11}$ , 大概 $20$ 分钟吧 ~~继续逃~~

----

至此，我们还能发现，对于给定的 $a$ ，我们需要将 $c_1$~$c_{10000}$ 的加和计算 $\lfloor{a\over 10000}\rfloor$ 次，剩下的就是从 $(\lfloor{a\over 10000}\rfloor\times 10000+1)$ 到 $a$ 的再各多记一次

也就是把加和乘上 $\lfloor{a\over 10000}\rfloor$ ,再加上 $c_1$~$c_{a\%10000}$ 的和就可以了

有的机智的小朋友立即意识到了，可以把 $c_1$~$c_{10000}$ 的和记录起来，接下来的一个循环搞掉，岂不美哉

但是为什么要那么复杂呢？

我们令 $Add_n=\sum_{i=1}^nc_i$

那么，我们的答案就应该是 $Add_{10000}\times \lfloor{a\over 10000}\rfloor+Add_{a\%10000}$

>这个实际上叫做前缀和

不是吗？

所以现在很明确了吧，我们要的是 $Add_n$ ，只要这个一出来，我们就可以根据公式，$O(1)$ 输出答案了

那 $Add_n$ 又怎么求？ $c_n$ 全部算出来然后每次算 $Add_n$ 都一遍扫过去？

复杂度 $O(n^2)$ 的事情过于暴力了吧

我们想：

$Add_n=\sum_{i=1}^nc_i=\sum_{i=1}^{n-1}c_i+c_n=Add_{n-1}+c_n$

所以我们只要一遍算 $c_n$ 的时候统计 $Add_n$ 即可

这次，预处理复杂度 $O(10000\log b)$ ,输出答案是 $O(1)$ 的，总复杂度 $O(10000N\log b)=10^7$ 可以做到一秒出结果了

---

**【进阶】**
--

这边讲一个毫无意义的进阶，虽然对复杂度和答案毫无影响，但确实看起来更优雅：

由欧拉定理得： $a^{\varphi(n)}\equiv1(\mod n)$

对于右上角那个鬼东西，它叫欧拉函数，是指小于 $n$ 的正整数中，与其互质的数的个数
>也有的版本是说小于等于 $n$ 的正整数中，与其互质的数的个数

关于欧拉函数的性质，你们可以看看我 [这篇文章](https://www.luogu.org/blog/JustinRochester/solution-p2158) 中讲欧拉函数的那一部分，其它的可以跳过

至于欧拉定理，记住它就行 ~~OI是不需要数学证明的~~

根据公式 $\varphi(10000)=4000$ 所以，我们不需要算 $b$ 次方的快速幂，$b\%4000$ 的快速幂即可

这样，您的代码将看起来更加的优雅、大气

> hrq：“我现在终于知道了，代码优雅指的就是别人看不懂！原来我代码不优雅是褒义词！”

(P.S. 虽然丝毫不影响复杂度)

---

**【代码】**

好的，废话了那么多，本蒟蒻要放 ~~我码风极丑无比的~~ 代码了

代码前面加了一些读入和输出优化，无视即可

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
#define File(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
typedef int i32;
typedef long long int i64;
const int Mod=10000;
namespace INPUT{
	char s[1<<20|1],*p1=s,*p2=s;
	inline char gc() { return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20|1,stdin),p1==p2)?EOF:*(p1++); }
	inline i32 read(){
		register i32 ans=0;register char c=gc();register bool neg=0;
		while(c<48||c>57) neg^=!(c^'-'),c=gc();
		while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
		return neg?-ans:ans;
	}
}
namespace OUTPUT{
	char s[1<<20|1],*cur=s;
	inline void output(){ cur-=fwrite(s,1,cur-s,stdout); }
	inline void print(i32 x){
		char tmp[16],*p1=tmp,*p2=tmp;
		p2+=sprintf(tmp,"%d",x);
		if(cur-s+p2-p1>>20) output();
		while(p1<=p2) *(cur++)=*(p1++);
		cur--;
	}
	inline void print(char c){
		if(cur-s+1>>20) output();
		*(cur++)=c;
	}
}
using namespace INPUT;
using namespace OUTPUT;
//前面全是读入输出优化，无视它们

inline i32 pow(i32 d_A,i32 d_X){
	i32 d_Bas=d_A,d_Ans=(d_X&1)?d_A:1;
	while(d_X>>=1){
		d_Bas*=d_Bas;
		d_Bas%=10000;
		if(d_X&1) d_Ans*=d_Bas,d_Ans%=10000;
	}
	return d_Ans;
}//快速幂
inline i32 work(i32 d_A,i32 d_B){
	i32 ar_d_Add[Mod+1]={0};
	f(i,1,I,Mod) ar_d_Add[i]=ar_d_Add[i-1]+pow(i,d_B),ar_d_Add[i]-=( (ar_d_Add[i]>=Mod)?Mod:0 );
	i32 d_Ans= d_A/Mod%Mod * ar_d_Add[Mod]%Mod + ar_d_Add[d_A%Mod];
	return d_Ans>=Mod?(d_Ans-Mod):d_Ans;
}//计算结果
i32 main(){
	i32 d_N=read();
	while(d_N--){
		int d_A=read(),d_B=read()%4000;
		print( work(d_A,d_B) );
		print('\n');
	}
	output();
	return 0;
}//对于主函数尽可能剪短的特殊癖好
```

---

## 作者：l1360300734 (赞：15)

/\*啊，竟然没有C++题解，本蒟蒻来一发c++题解，思路与楼下相同

```cpp
a/10000*f[10000]+f[a%10000];
a^b%100000=(a+10000)^b%10000;
f[i]表示当a=i时的解*/
#include<cstdio>
#include<cstring> 
using namespace std;
#define ll long long
#define mod 10000 
int f[10001];
ll k(ll a,ll b,ll c)//快速幂算法
{
    ll ans=1;
    while (b)
    {
        if (b%2==1)
            ans=(ans*a)%c;
        a=(a*a)%c;
        b/=2;
    }
    return ans;
}
int main()
{
    int n,i,he,a,b;
    scanf("%d",&n);
    memset(f,0,sizeof(f));
    while(n--)
    {
        he=0;
        scanf("%d%d",&a,&b);
        for (i=1;i<=mod;i++) 
            f[i]=(f[i-1]+k(i,b,mod))%mod;//通过是自求出来前10000个的和；
        he=(a/mod*f[mod]+f[a%mod])%mod;//求出
        printf("%d\n",he);
    }
}
```
/\*
a/10000\*f[10000]+f[a%10000];

a^b%100000=(a+10000)^b%10000;

\*/

---

## 作者：Aw顿顿 (赞：10)

首先，提出性质 $1.0$：

$$(a+b)^x\equiv a^x\pmod b$$

为什么？用二项式定理展开后发现除了 $a^x$ 项以外，都带有 $b$，可以整除消掉。

那么上式显然成立，同时题目让我们求：

$$\left(\sum\limits_{x=1}^{a}x^b\right)\bmod 10^4$$

怎么办呢？从暴力开始。

## Sol.1 暴力

每次乘法 $O(b)$，总共循环 $a$ 次，一共 $N$ 组数据，复杂度 $O(Nab)$。

什么概念呢？$10^2\times 10^9\times 10^9=10^{20}$，挺快的，跑个几万年也许能出来吧。

## Sol.2 快速幂

快速幂是二分的思想，这里引用我一年前写的文字：

> 用递归或循环的方式将 $a^n$ 二分转化为 $a^{n\div 2}\times a^{n\div 2}$。
>
> 我们可以用答案自乘之类的办法实现二分。
>
> 从而将 $O(n)$ 优化为 $O(\log n)$。

```cpp
inline int quickpow(int a,int b){
	int s=1;
	while(b){
		if(b&1)s=(s*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}return s%mod;
}
```

我们很容易把这个 $b$ 优化成 $\log b$，那么复杂度就是 $O(Na\log b)$，可以么？

$\log(10^9)$ 大致是 $30$ 这个样子，那就是 $3\times 10^{12}$ 次运算了，还是受不起。

考虑我们文章开头的那个优化吧。

## Sol.3 数论

$$(a+b)^x\equiv a^x\pmod b$$

$$(a+10^4)^x\equiv a^x\pmod{10^4}$$

因为模数是 $10^4$ 一个很小的数，那就考虑这么办——这意味着，超过 $10^4$ 就会出现循环节，而这个数我们已经求过了。

预处理吧。

那是怎么样呢？也就是说，求出 $10^4$ 以内的 $x^b$。

这时候我们要求 $(x+10^4)^b$ 时，我们就不用再求了。

从头到尾来一遍，一共 $a$ 个数，每个统计一遍，是 $O(a)$，再说，如果我们要求 $10^4$ 个快速幂，复杂度：

$$a+10^4\times\log b\to O(a)$$

显然不行，就凭这 $a\le 10^9$。

## Sol.4 统计

继续优化，显然可以优化的是统计部分。

直觉发现，重复的部分一共出现了 $\left\lfloor\dfrac{a}{10^4}\right\rfloor$ 次，可以直接乘上去。

多余的部分再统计就行了。

大概就只需要 $O(\log b)$ 这样子，当然有一个 $\times 10^4$ 的常数加持，但不影响。

也就是说，你总共要运行 $10^4\times\log b+a\bmod 10^4$ 次运算。

还可以再快么？

## Sol.5 前缀和

你发现这是一个求和，你发现可以直接调用，你发现多余部分不用再统计了，前缀和可以解决烦恼。

于是常数又小了一点，你只需要作 $10^4\times\log b$ 的快速幂了。

当然还有更多的优化方法，但是没必要，是么？

代码容易实现，不给了。

---

## 作者：lych (赞：5)

其实，对于30%的数据，直接用暴力即可，绝对可以过，但是再看一看100%的数据绝对爆掉，因此我们需要寻找规律。

我们发现mod的那个数字比较小，因此就容易想到a^b mod 10000=(a+10000)^b mod 10000。那么我们就可以用a div 10000\*f[10000]+f[a mod 10000]计算出解了（f[i]表示当a=i时的解）。

空间复杂度为0(10000),时间复杂度为0(10000\*N\*logB)。可以通过数据

详见标程：

```cpp
var
  n,i,a,b:longint;
function sum(x,y:longint):longint;
var i,s:longint;
begin
  s:=1;
  while y>0 do
    begin
      if odd(y) then s:=s*x mod 10000;
      y:=y shr 1;
      x:=x*x mod 10000;
    end;
  exit(s);
end;//求x^y mod 10000是多少
procedure work;
var
  i,s:longint;
  f:array[0..10000] of longint;
begin
  fillchar(f,sizeof(f),0);
  for i:=1 to 10000 do
    f[i]:=(f[i-1]+sum(i,b)) mod 10000;//在原来的基础上再加上i^b
  s:=(a div 10000*f[10000]+f[a mod 10000]) mod 10000;//算出解
  writeln(s);
end;//求解
begin
  readln(n);
  for i:=1 to n do
    begin
      readln(a,b);
      work;
    end;
end.
```

---

## 作者：syf2008 (赞：2)

这是一道快速幂+前缀和

这题有3种解法

1.暴力

暴算，复杂度（Nab）,预计得分0~30

2.快速幂+暴力

把算幂次的暴力改成快速幂，预计得分30~50

3.正解 快速幂+前缀和

前缀和存1~n的b次，最后输出((a/mod*sum[mod])%mod+sum[a%mod])%mod（mod=10000）

下面，上代码
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=10000;
long long sum[10005],t,a,b;//十年OI一场空，不开long long 见祖宗
inline long long power(long long a,long long b,long long p)
{
	long long ans=1;
	while(b>0)
    {
    if(b%2!=0)
    ans=ans*a%p;
    a=a*a%p;
    b=b>>1;
	}
	return ans;
}//快速幂
int main()
{
	cin>>t;
	while(t--)
	{
	cin>>a>>b;
	for(int i=1;i<=mod;i++)
	sum[i]=sum[i-1]+power(i%mod,b,mod);//前缀处理
	cout<<((a/mod*sum[mod])%mod+sum[a%mod])%mod<<endl;
	}
}
```

---

## 作者：logeadd (赞：2)

题目并不是很难，只是用常规方法很容易爆掉，利用快速幂算法可以节省运算时间，有由于只求后面4位，所以每次求是mod10000，防止数据炸掉。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int mod=10000;
int N,a,b;
int qkpow(int a,int p)//快速幂算法，由于只用求后面4位，所以mod10000
{
    int ans=1,t=a;
    while(p!=0)
    {
        if(p&1!=0)
         ans=ans*t%mod;
        t=t*t%mod;
        p=p>>1;
    }
    return ans;
}
int work()//求和，也可以放在主函数中取决于个人喜好，这里由于有多组数据，故单独写
{
    int ret=0,x=a/mod;
    a%=mod;
    for(int i=1;i<=mod;i++)
    {
        if(i<=a)
            ret=(ret + (x+1) * qkpow(i,b)) % mod;
        else ret=(ret + x * qkpow(i,b)) % mod;
    }
    return ret;
}
int main()
{  scanf("%d",&N);
    while(N--)
    {
        scanf("%d%d",&a,&b);
        printf("%d\n",work());
    }
    return 0;
}
```

---

## 作者：sid_shi1 (赞：1)

传送门：[P1630 求和](https://www.luogu.com.cn/problem/P1630)

可以发现当 $a=10001$ 时，和 $a=1$ 的值其实是一样的。也就是说求 $a$ 和求 $a\bmod 10000$ 是等价的，那么接下来这道题就很容易了。

我们只需要写一个快速幂的函数（模板）：

```cpp
long long p(long long x,long long y){
	long long t=1;
	x%=10000;
	while(y>0){
		if(y%2==1) t=t*x%10000;
		y/=2,x=x*x%10000;
	}
	return t;
}
```
然后主函数按题意操作就行了，

接下来贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long p(long long x,long long y){//快速幂
	long long t=1;
	x%=10000;
	while(y>0){
		if(y%2==1) t=t*x%10000;
		y/=2,x=x*x%10000;
	}
	return t;
}
int main(){
	long long T;
	scanf("%lld",&T);
	for(long long w=1;w<=T;w++){
		long long a,b,ans1=0,ans2=0;
		scanf("%lld%lld",&a,&b);
		for(int i=1;i<=10000;i++) ans1=(ans1+p(i,b))%10000;
		for(int i=1;i<=a%10000;i++) ans2=(ans2+p(i,b))%10000;
		printf("%lld\n",(ans1*(a/10000%10000)+ans2)%10000);
	}
	return 0
}
```

---

## 作者：TRZ_2007 (赞：1)

**题解 [P1630 【求和】](https://www.luogu.com.cn/problem/P1630)**  
# Description  
给定 $n$ 个 $a$ 和 $b$，求 $\sum\limits_{i=1}^a i^b$ 的后四位。  
# Solution  
## 法1：暴力  
对于每一对 $a$ 和 $b$，使用**快速幂**计算出 $\sum\limits_{i=1}^a i^b$ 后进行处理，时间复杂度 $\Theta(N\times a\log b)$ ，期望得分30pts。  
## 法2：前缀和  
我们发现模数只有10000，而 $a$ 可能会达到 $10^9$，因此会有许多数被重复计算，于是采用前缀和。由于当时大佬们的古怪方法看不懂，于是我自己推了一遍。设$i=10000k+y$，可得：  
$$\begin{aligned}\sum\limits_{i=1}^ai^b&=\sum\limits_{i=1}^a(10000k+y)^b\\&=(10000k)^b+C_b^1(10000k)^{b-1}\times y+C_b^2(10000k)^{b-2}\times y^2+\dots+C_b^{b-1}(10000k)\times y^{b-1}+y^b\end{aligned}$$  
将其对10000取模，得：  
$$\begin{aligned}\sum\limits_{i=1}^ai^b&=(\sum\limits_{i=0}^{10000}i^b\times\frac{a}{10000})\%10000+\sum\limits_{i=0}^{a\%10000}i^b\%10000\end{aligned}$$   
其中 $(\sum\limits_{i=0}^{10000}i^b\times\frac{a}{10000})\%10000)$ 这一部分我们可以用前缀和来计算，后面的一部分暴力解决。  
最后算法的时间复杂度为$\Theta(N\times M\log b)$，其中 $M$ 是模数，为10000。期望得分100pts。  
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Mod 10000	//模数

int T,a,b;

int qpow(int x,int p) {	//快速幂
	long long ans = 1;
	while(p) {
		if(p & 1) ans = (ans * x) % Mod;
		x = (x * x) % Mod;
		p = p / 2;
	}
	return ans % Mod;
}

int solve() {
	int k = a / Mod;
	long long cnt = 0;
	a %= Mod;
	for(int i = 1;i <= Mod;i++) {
		if(i <= a) {	//如果这是多余的一部分
			cnt = (cnt + (k + 1) * qpow(i,b)) % Mod;	//要多算一次
		}else {
			cnt = (cnt + k * qpow(i,b)) % Mod;	//不然就算a/10000次
		}
	}
	return cnt;
}

int main() {
	scanf("%d",&T);
	while(T--) {
		scanf("%d %d",&a,&b);
		printf("%d\n",solve());
	}
	return 0;
}
```

---


# 跳跃

## 题目背景

NOIP 即将迎来周年华诞。在这一个春秋的历程里，NOIP 领导全国 oier，建设高效、稳定、快捷、开放的社会主义现代化  OI。在新的一年里，YZOJ 将再接再厉，积极探寻成长之路，更好地为广大 oier 服务。

## 题目描述

青蛙小 C 听说 NOIP 要办周年庆比赛，兴冲冲得来到了 Z 市，初始时他在坐标 $x_0$ 处，小 C 是一只善于跳跃的青蛙，若当前他处在坐标 $x$ 处，每一次跳跃，他可以跳到 $4x+3$ 或 $8x+7$ 处，且由于体力原因，他最多能跳 $100000$ 次。

根据 Z 市的传说，坐标位置为 $10^9+7$ 的整数倍的位置（如 $10^9+7,2\times 10^9+14$）可以传送到 YZOJ。

小 C 想知道，最少跳几次能传送到 YZOJ。

## 样例 #1

### 输入

```
125000000 ```

### 输出

```
1```

# 题解

## 作者：FlyingAnt (赞：15)

看到没有c++，我这个蒟蒻就来丰富一下题解区。

分析4x+3和8x+7

发现2（2x+1）+1==4x+3,    2（4x+3）+1==8x+7；

发现可以以2x+1为单位进行跳跃

记录小跳跃次数，如果大于300000，就结束；

当到达目标位置时，看一下小跳跃次数，如果%3==0

跳跃次数/3为答案，如果不是0，有两种情况，余1，余2

发现余2跳一次4x+3就可以到达了，余1少跳1次8x+7，改为两次4x+3即可

所以将/3后的结果加1即可

代码如下

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int ans=0;
const int mod=1000000007;
int dep=0;
bool flag=0;
void slove(int x)
{
    if(ans==310000)
    {
        flag=1;
        return;
    }
    ans++;
    int y=(2*(x%mod)+1)%mod;
    //cout<<ans<<" "<<y<<endl;
    if(y==0)
    {
        if(ans%3==0)
            ans/=3;
        else
            ans=ans/3+1;
        if(ans>100000)
            flag=1;
    }
    else
    slove(y);
    return;
}
int main()
{
    int x0;
    cin>>x0;
    slove(x0);
    if(!flag)
    cout<<ans<<endl;
    else
    cout<<-1<<endl;
    return 0;
}
```

---

## 作者：Leap_Frog (赞：10)

## P1635跳跃（题解）
**解题方法：**
1. 观察法。
2. 简单数论。
***
**解题思路：**

观察到$4x+3=2(2x+1)+1$以及$8x+7=2(2(2x+1)+1)+1$  
所以可以把$x$->$2x+1$当成一个基本变化  
则$x$->$4x+3$是两个基本变化，$x$->$8x+7$是三个基本变化  
所以可以模拟一个基本变化  
当基本变化次数大于$300005$是结束迭代  
因为要使两个变化之和最小，所以尽量多用$x$->$8x+7$
1. 当基本变化次数%3==0，都用$x$->$8x+7$，总次数=基本变化次数/3
2. 当基本变化次数%3==1，用两个$x$->$4x+3$，剩下用$x$->$8x+7$，总次数=基本变化次数/3+1
3. 当基本变化次数%3==2，用一个$x$->$4x+3$，剩下用$x$->$8x+7$，总次数=基本变化次数/3+1
***
**PS：**

~~我爱压行！！！~~
***
**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD=1000000007;	//模数
const ll MAX=100000;	//最大跳跃次数
ll n,i,x,ans;
int main()
{
	scanf("%lld",&n);
	for(i=0,x=n;i<=MAX*3+10;x=((x<<1)+1)%MOD,i++) if(x==0) break;	//求基本变化次数
	if(i%3==0) ans=i/3;		//求总次数
	if(i%3==1||i%3==2) ans=i/3+1;
	if(ans>MAX) ans=-1;		//判断能否到达
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Randyhoads (赞：7)

这道题我就直接用BFS暴力了，最后竟然过了，神奇。

主要思路就是BFS每次扩展，用map判重，直到可以了或走的次数超过了就跳出循环

但是每次都要去模那个数，不然太大了。。。






        
        

```cpp
#include<cstdio>
#include<map>
#include<iostream>
using namespace std;
map<long long ,int>ma;
long long f[5000001][2];
long long head=0,tail=1;
inline void bfs(long long z)//BFS
{
    head++;
    f[head][0]=z;
    f[head][1]=0;//先把他在的坐标加入队列
    ma[z]=1;
    if(z%1000000007==0)
    {
        cout<<0<<endl;
        return;
    }
    do
    {
        long long x=f[head][0];
        int o=(x*4+3)%1000000007;//每次他有两种扩展方式，乘4加3或乘8加7
        if(!ma.count(o))//如果不在队列，就加入队列
        {
        ++tail;
        f[tail][0]=o;//f[a][0]表示数，f[a][1]表示步数
        ma[o]=1;
        f[tail][1]=f[head][1]+1;//这个步数就是当前加一
        if(f[tail][1]>100000)//如果超过了限制，就输出-1
        {
            cout<<-1<<endl;
            return;
        }
        if((o)%1000000007==0)//如果符合条件
        {
            cout<<f[tail][1]<<endl;
            return ;
        }
        }
        int u=(x*8+7)%1000000007;
        if(!ma.count(u))//同上
        {
        ++tail;
        f[tail][0]=u;
        ma[u]=1;
        f[tail][1]=f[head][1]+1;
        if(f[tail][1]>100000)
        {
            cout<<-1<<endl;
            return;
        }
        if((u)%1000000007==0)
        {
            cout<<f[tail][1]<<endl;
            return ;
        }
        }
        head++;
    }while(head<=tail);
}
int main()
{
    long long x;
    cin>>x;
    bfs(x);
    return 0;
}
我好像是跑的最慢的（显然我太弱了，想不到下面两个大佬的做法）
```

---

## 作者：UnyieldingTrilobite (赞：6)

看到题解区dalao都是bfs,数学推导······身为juruo的窝深深感受到了自己的渺小。

这题，juruo没想到其他的，只有一个思路：

$\text{{\color{red}{暴搜吼啊！！！}}}$

~~（滑稽.jpg~~

直接dfs,到膜(1e9+7)余多少，走了几步。

暴搜完，是时候冷静一下了······

想想怎么剪枝？

直观思路：记忆化一下（unordered_map,C++11听说C++有个什么神奇方法也能调用？不管了就C++11吧），加上最优性剪枝即可。

~~听说这个记忆化搜索就是dfs版本的某已死算法？好像不太吉利。~~

~~不管了能过就行。~~

好了，接着就无脑搜了······

上代码：
```cpp
#include<bits/stdc++.h>
#define int long long//可能爆int
using namespace std;
const int mod=1e9+7;
unordered_map<int,int>mmp;//记忆化数组
int ret;
int ans=LLONG_MAX;
void dfs(int num,int stp){
    num%=mod;
    if(stp>100000)return;//根据题目所说
    if(mmp.count(num)&&stp>=mmp[num])return;//剪枝
    mmp[num]=stp;
    if(!num){ans=stp;return;}//更新答案
    dfs(num<<3|7,stp+1),dfs(num<<2|3,stp+1);//继续暴搜
}
signed main(){//技巧：#define int 什么什么 后依旧可以用signed表示int
    int n;cin>>n;
    dfs(n,0);
    printf("%d\n",ans==INT_MAX?-1:ans);//特判-1
    return 0;
}
```
Over.

---

## 作者：ShineEternal (赞：5)

# 题目：
## 题目背景

NOIP即将迎来周年华诞。在这一个春秋的历程里，NOIP领导全国oier，建设高效、稳定、快捷、开放的社会主义现代化OI。在新的一年里，YZOJ将再接再厉，积极探寻成长之路，更好地为广大oier服务。
## 题目描述

青蛙小C听说NOIP要办周年庆比赛，兴冲冲得来到了Z市，初始时他在坐标x0处，小C是一只善于跳跃的青蛙，若当前他处在坐标x处，每一次跳跃，他可以跳到$4x+3$或$8x+7$处，且由于体力原因，他最多能跳$100000$次。根据Z市的传说，坐标位置为$1000000007$的整数倍的位置(如$1000000007$、$2000000014$)可以传送到YZOJ。小C想知道，最少跳几次能传送到YZOJ。
## 输入输出格式
### 输入格式：

输入的第一行包含一个整数x0表示青蛙的初始位置，保证x0在的范围在$[1,1000000006]$。

### 输出格式：

输出一个整数，表示最少所需步数，若在$100000$步内还无法传送到$YZOJ$，则输出$-1$。

# 分析：
**显然，这一看就是一道数学题**

那么我们怎么考虑呢？

如果你细心一点就会发现：

#### $4x+3=2*(2x+1)+1$
#### $8x+7=2*(2*(2x+1)+1)+1$

那么不就是说，只需要计算与2x+1有关的步数，然后推导普遍规律就行。

计算有几次2x+1的过程太简单，等会直接看代码就行。下面分析处理结果的方法。

再跳回两个式子：
#### $4x+3=2*(2x+1)+1$
#### $8x+7=2*(2*(2x+1)+1)+1$

我们可以发现：最多的是由三个2x+1等构成（即8x+7），所以我们不妨考虑将结果先mod 3：

- %$3=0$：那么就是一堆$8x+7$(设为n个），输出$answer/3;$

- %$3=1$:可以想成把本来的$n$个$8x+7$从整好的多了一个$2x+1$，所以只能拆出一个$2x+1$，变成$n-1$个$8x+7$和$2$个$4x+3$.

- %$3=2$：可以想成把本来的n个$8x+7$从整好的多了两个$2x+1$，所以n个$8x+7$不用变，只是把多出的两个$2x+1$合成一个$4x+3$就行。

然后归纳一下就行了，具体看

# 对了补充一句，因为首先是给出x，然后才能变成2x+1,4x+3，8x+7 . 等。所以所谓的三步其实是算上x变成2x+1的QAQ

# [代码](https://blog.csdn.net/kkkksc03/article/details/83096313)：

---

## 作者：joyoi (赞：1)

观察到 $(4x + 3 = 2(2x + 1) + 1)$  以及  $(8x + 7 = 2(2(2x + 1) + 1) + 1)$

所以可以把 $(xx -> 2x + 12x + 1)$ 当成一个基本变化

则 $(xx -> 4x + 3)$ 是两个基本变化，$(x -> 8x + 7)$ 是三个基本变化

所以可以模拟一个基本变化

当基本变化次数大于 $300000$ 是结束迭代

因为要使两个变化之和最小，所以尽量多用 $xx -> 8x + 78x + 7$

当基本变化次数$ % 3 == 0$，都用 $(xx -> 8x + 7)$，总次数 $=$ 基本变化次数 $ / 3$

当基本变化次数$ % 3 == 1$，用两个 $(xx -> 4x + 3)$，剩下用 $(xx -> 8x + 7)$，总次数=基本变化次数 $/3 + 1$

当基本变化次数 $%3 == 2$，用一个 $(xx -> 4x + 3)$，剩下用 $(xx -> 8x + 7)$，总次数=基本变化次数 $/3 + 1$

### 代码如下:

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod=1000000007;
ll x, ans;

int main()
{
	cin >> x;
	ll i;
	for(i = 0; i <= 300000; i++)
	{
		if(x == 0) break;
		x = (x * 2 + 1) % mod;
	}
//其实这里有个小bug,i==300000时已经迭代了300001次
//如果在这个时候刚好等于0，其实还是不符合条件的
//不过我，懒得改了(●‘?‘●)
	if(x != 0)	cout << -1;
	else if(i % 3 == 0)	cout << i / 3;
	else if(i % 3 == 1)	cout << i / 3 - 1 + 2;
	else if(i % 3 == 2)	cout << i / 3 + 1;
	return 0;
}
```



---

## 作者：KSToki (赞：0)

~~考试题，我来水一篇题解。~~

题目大意就是现有两个操作(令 $1000000007$ 为 $Mod$)：$g(x)=4x+3$、$h(x)=8x+7$，每次操作后将答案模 $Mod$，问最少经过几次操作能将给定的 $x$ 变成 $0$，如果操作次数大于 $100000$ 则输出 $-1$。

这里发现有 $f(x)=2x+1$，可以使得 $g(x)=f(f(x))$、$h(x)=f(f(f(x)))$，所以我们只需每次把 $x$ 变成 $f(x)$，最后贪心算答案（多用 $h(x)$）即可。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll Mod=1000000007;
ll x;
int cnt;
int main()
{
	scanf("%lld",&x);
	while(x!=0)
	{
		++cnt;
		x=(2*x+1)%Mod;
		if(cnt>300000)//特判
		{
		    printf("-1\n");
		    return 0;
		}
	}
	if(cnt==0)
		printf("0\n");
	else if(cnt==1)
	{
		++cnt;
		x=(2*x+1)%Mod;
		while(x!=0)
		{
			++cnt;
			x=(2*x+1)%Mod;
		}
		if(cnt>300000)//特判
		{
		    printf("-1\n");
		    return 0;
		}
	}
	if(cnt!=0)
	{
		if(cnt%3==0)
			printf("%d\n",cnt/3);
		else
			printf("%d\n",cnt/3+1);
	}
	return 0;
}
```


---

## 作者：HC20050615 (赞：0)

~~机房考试时做到一道很像的题。。。~~
# 题意分析
给你一个数x。每一次处理可以将其变为(4x+3)%1000000007或(8x+7)。问最少进行多少次操作后，能得到0。
# 思路
分析后我们可以发现：

令f[x]=2x+1

4x+3=f[f[x]]

8x+7=f[f[f[x]]]

因此，我们可以把这道题转化成：将x进行几次2x+1的处理，求什么时候能变为0

我们可以暴力枚举次数，直到求出0为止。

然后将处理次数分为几个2和3（注：根据贪心策略，为了使次数最小，尽可能多分3。）

我们知道，2，3是可以完全分配除0，1以外的所有自然数的。

可以证明，当x在一次2x+1操作之下可以变为0时，在题目所限100000步内，无法将其变为0。

具体操作看下面代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n; 
int sum=0;
int main()
{
	cin>>n;
	while(n!=0&&sum<=300000)//因为要3次2x+1操作才抵得上一次题目所说的8x+7操作，所以限制要大3倍
	{
		n=(2*n+1)%1000000007;
		sum++;
	} //枚举2x+1操作的次数
	int ans=sum/3+(sum%3>=1);
    //如果刚好能被3除尽，就全部用3
    //如果除3余2，就再用一个2
    //如果除3余1，就退一个3，换两个2
    //所以只要除3有余数，说明要多进行一次操作
    //sum%3>=1,如果成立，值为1，反之为0
	if(sum==1||ans>100000)//次数为1，或者超过限制，输出-1
	{
		cout<<-1;
	}
	else
	{
		cout<<ans; 
	}
	return 0;
}
```


---

## 作者：墨凝而止 (赞：0)

```delphi
const sh=1000000007;{取模之数}
var
n,c,k:int64;{用longint也可}
function f(k:int64):int64;
begin
  exit(2*k+1);
end;
begin
  read(n);k:=n;
  repeat
  inc(c);
  if c>300000 then begin write(-1);halt;end;{如果基本步数一定超过100000，那么退出}
  k:=f(k);{基本步数}
  k:=k mod sh;{化简数值}
  until k mod sh=0;{再次求值以求保险}
  if c mod 3=0 then write((c div 3))else write(c div 3+1);{填补空缺}
end.
```
[color=fuck]此题纵观看来应属简单，关键在于对巨大数据的化简以及整理。具体的思路，在于循环中判断，计算后取模，旨在化简数据大小，从而适宜调备。当我们看到（4x+3）与（8x+7)时，脑际应即刻反映为(4\*(x+1)-1)以及（8(x+1)-1)。对二者提取公因式，可获之（2x+1)。可以发现，设f(x)=2x+1,则f(f(x))=4x+3;f(4x+3)=f(f(f(x)))=8x+7。以（2x+1)作为计算基本单位，进行反复运算，得到其应有的基本次数。最终，须谨记，对计算结果若mod 3=0，那么输出其div 3的值，否则须输出（c div 3+1)。因为，设若其得到的值为5，则是（8x+7)的一步，再外加（4x+3)的一步。设若其mod 3<>0 则必定其还有另外剩余的未被算入的步数，我们只要在原数据+1，就可以解决，毋用其他冗繁的方式。

[/color]


---


# 球迷购票问题

## 题目描述

盛况空前的足球赛即将举行。球赛门票售票处排起了球迷购票长龙。

按售票处规定，每位购票者限购一张门票，且每张票售价为 $50$ 元。在排成长龙的球迷中有 $n$ 个人手持面值 $50$ 元的钱币，另有 $n$ 个人手持面值 $100$ 元的钱币。假设售票处在开始售票时没有零钱。试问这 $2n$ 个球迷有多少种排队方式可使售票处不致出现找不出钱的尴尬局面。

例如当 $n=2$ 时，用 A 表示手持 $50$ 元面值的球迷，用 $B$ 表示手持 $100$ 元钱的球迷。则最多可以得到以下两组不同的排队方式，使售票员不至于找不出钱。


- 第一种：$\mathtt{[A,A,B,B]}$；
- 第二种：$\mathtt{[A,B,A,B]}$。

对于给定的 $n$，计算 $2n$ 个球迷有多少种排队方式，可以使售票处不至于找不出钱。


## 说明/提示

### 数据范围及约定

对于全部数据，$0 \le n \le 20$。


## 样例 #1

### 输入

```
2
```

### 输出

```
2
```

# 题解

## 作者：bingliang (赞：52)

我想发两篇，。。。强制自己学下卡特兰数。

本片考虑dp

dp的是后  dp【i】【j】表示后面还有i个50元j个100元的时候，的方案数

考虑在前一步的时候可以拿到50或100所以

dp[i][j]=dp[i-1][j]+dp[i][j-1];

下面是代码

    
        
```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
long long n,m,dp[100][100];
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
    dp[i][0]=1;
}
for(int i=1;i<=n;i++)
{
    for(int j=1;j<=i;j++)
    {
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
    }
}
cout<<dp[n][n];
    return 0;
}

```

---

## 作者：SSHhh (赞：27)

看了一下楼上的题解，发现都是卡特兰数。数学爆炸的我惊呆了：这是什么东西？于是我给大家来上一份正儿八经的 dp 题解。

首先发现，必须在有 50 元在先的情况下才能收 100 元（每收一个 100 就得找出一个 50），所以我们枚举手头 50 元的张数就行了。

dp[ i ][ j ]表示考虑到了前 i 个人，手里现有 j 张 50 。（0<=j<=i）

每一个dp[ i ][ j ]可以由上一个拿了 50 或者 100 转移过来。

拿了 100 就是 dp[i-1][j-1]，（拿了 100 自然就得找出一张 50，所以是 j-1）那拿了 50 就自然是 dp[i-1][j+1]了（手头多了一张 50）。

那 dp 方程就很好推出来了：

        dp[i][j]+=dp[i-1][j-1];

        dp[i][j]+=dp[i-1][j+1];

然后只需特判一下 j-1<0 和 j+1>i 就行了。

下面附上丑陋的代码：


```cpp
#include<iostream>
using namespace std;
int n;
long long dp[5005][5005];
int main()
{
    cin>>n;
    dp[0][0]=1;//第0个只有一种可能：就是不取;
    for(int i=1;i<=n+n;i++)//一共有 2*n 个人;
    {
        for(int j=0;j<=n && j<=i;j++)//前 i 个人最多有 i 个 50;
        {
            if(j-1>=0)//特判;
                dp[i][j]+=dp[i-1][j-1];
            if(j+1<=i+1)//特判;
            dp[i][j]+=dp[i-1][j+1];
        }
    }
    cout<<dp[n+n][0];//因为 50 和 100 的数量相等，所以轮到最后一个人时 50 一定全找完;
    return 0;//完美结束
}

```

---

## 作者：kcs007 (赞：22)

前面的大佬都用的啥喀特兰属（~~这特么是啥？？？~~）
这里来一个最好想的DP

dp[i][j]代表已经来了i个50的人和j个100的人

那么分两种情况
```
if(i>j)
{
	dp[i][j]=dp[i-1][j]+dp[i][j-1];//如果来的50的多于100的，那么这次来50和100的都可以
}
	else if(i==j)
{
	dp[i][j]=dp[i][j-1];//如果100和50的一样多，那么这次只能来50的
}

```
因为有0的问题，所以循环多加了1

```
#include<iostream>
#include<cmath>
using namespace std;
#define ll long long
ll dp[25][25];
ll n;
void print()
{
	for(int i=1;i<=n+1;i++)
	{
		for(int j=1;j<=n+1;j++)
		{
			cout<<dp[i][j]<<' ';
		}
		cout<<endl;
	}
}
int main()
{
	cin>>n;
	dp[1][0]=1;
	for(int i=1;i<=n+1;i++)
	{
		for(int j=1;j<=n+1;j++)
		{
			if(i>j)
			{
				dp[i][j]=dp[i-1][j]+dp[i][j-1];
			}
			else if(i==j)
			{
				dp[i][j]=dp[i][j-1];
			}
		}
	}
	//print();
	cout<<dp[n+1][n+1]<<endl;
	return 0;
}
```


---

## 作者：niiick (赞：21)

####看题解好像没有具体说明为什么是catalan，所以就简单说明一下

一个A买票后售票处会积累50元钱 

一个B买票需要售票处找零50元钱 

说明在一个B买票前至少需要一个A买过票 

那么我们就可以将A看作左括号，B看作右括号 

问题就是要求合法得括号匹配，即Catalan数

n得范围开long long不会溢出
所以用一个快一些的递推公式

$h(n)=h(n−1)∗(4∗n−2)/(n+1)$

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
typedef long long ll;

int n;
ll cat[50];

int main()
{
    scanf("%d",&n);
    cat[0]=cat[1]=1;
    
    for(int i=2;i<=n;++i)
    cat[i]=cat[i-1]*(4*i-2)/(i+1);
    
    cout<<cat[n];
    return 0;
}//niiick
```

---

## 作者：prefer (赞：12)

本蒟蒻只会记忆化搜索

总共两个状态

第一个是当前位置选择50元的，第二个是当前位置选择100元的

好理解

注意要开long long 要不然 n=20的时候会溢出

### 详情看代码注释 详细

```cpp

#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,f[105][105][105];
LL dfs(LL N50,LL N100,LL CanFind) {//现在50元的球迷人数，现在100元的球迷人数，可以找的钱也就是现在的50元的张数（付给100元之后是要找的，要找50元钱给他）
	if(CanFind<0||N50>n||N100>n) return 0;//越界
    if(f[N50][N100][CanFind]) return f[N50][N100][CanFind];//记忆化
	if(N50==n&&N100==n) return 1;//当有50元的球迷已经弄完了并且100元的球迷也弄完了那就方案数+1
	return f[N50][N100][CanFind]=dfs(N50+1,N100,CanFind+1)+dfs(N50,N100+1,CanFind-1);//如上文所说
}
int main() {
	scanf("%lld",&n);
	printf("%lld\n",dfs(0,0,0));//当前0个人(不管是50元还是100元)成功付款，售货员有0张50元
	return 0;
}
```

---

## 作者：Dog_Two (赞：7)

我们知道，卡特兰数的第n项可以表达为C(n,2n)/(n+1)，我们可以把公式作如下变形：

![](https://cdn.luogu.com.cn/upload/pic/34427.png )

我们发现，20！是LONG_LONG_MAX的2/9左右，也就是恰好不会爆long long。

但分母（n+2到2n的累积）一定会爆long long，所以我们可以先处理出分母的n！，然后在累乘分子的时候不断与分母约分即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;

void read(){
	cin>>n;
}

long long gcd(const long long &a,const long long &b){
	return b?gcd(b,a%b):a;
}

void solve(){//C(n,2*n)/n+1
	long long uN=1,dN=1;
	for(int i=1;i<=n;++i) dN*=i;
	for(int i=n+2;i<=2*n;++i){
		uN*=i;
		long long d=gcd(uN,dN);
		uN/=d,dN/=d;
	}
	cout<<uN;
}

int main(){
	read();
	solve();
	return 0;
}
```

---

## 作者：ALANDQQ (赞：5)

本蒟蒻的一份题解~~~~~~~  
设 **F( i , j , k)** 表示**i** 个人中有j个50元，k个100元的可行方案总和。
#### 很明显，i必须等于j+k,否则无法存在这样的情况。 
#### 题目中说能找开，即50元的人数必须大于或等于100元人数。  
举例来说，若有3人买票， 两个人拿100元，一个人拿50元，则必定有一个人（100元的那个） 无法找钱。
#### 所以，若i != j+k 或 j < k ,F(i , j, k)=0。
那么状态转移方程呢？
#### 对于i个人的方案总和（即F(i , j , k)）,必定从F（i-1 , j-1, k） 和F （i-1 , j ,k-1） 转移而来； 即从i-1 个人的2种可能方案和 转移而来。  
#### 即F（i , j ,k）= F（i-1 , j-1, k)+F（i-1 , j ,k-1）。
对于初始条件，F(1，1，0)=1。
而F(1 , 0 , 1) 由于拿100元人数比50元人数多，所以F(1 , 0，1)  
答案在F(n*2, n , n)中。  
代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll f[51][51][51];
int n;
int main()
{
	cin>>n;
	f[1][1][0]=1;
	for(int i=1;i<=n*2;i+=1)
		for(int j=0;j<=n;j++)
			for(int k=0;k<=n;k++)
			{
				f[i][j][k]+=f[i-1][j-1][k]+f[i-1][j][k-1];
				if(j<k) f[i][j][k]=0;
				if(j+k!=i) f[i][j][k]=0;
			}
	cout<<f[n*2][n][n]<<endl;
	return 0;
}
```


---

## 作者：X_o_r (赞：5)

嗯，楼上的题解很不错，讨论也不错，果真这题就是裸的卡特兰数H(n)

别问我怎么推的，反正是看到前几项有点像就提交了

对于N≤20000，肯定是要开高精度的，但是数据却没有

当然卡特兰数递推是可以的，但是理论上是要超时的

所以要用到组合数的那个公式(H(n)=(2n)!/n!/(n+1)!，当然是化简过的)，当然直接算也要超时

于是想到用唯一分解定理：将组合数公式的乘除转化为任意素因子的一定次幂即可

乘除法自然就转化为加减法

由于结果一定为整数，所以一定不用担心负数次幂的情况了

答案可以这么表示：

 ![](https://cdn.luogu.com.cn/upload/pic/5236.png) 

（其中Prime[i]表示第i个质数，Number[i]表示第i个质数幂的指数）

然后快速幂+乘法完美AC

注：
输入：

20000
输出：

31599644798684360829523998565160634731870551241083179960160329312792069095360018823893729989224701538453501376275266731458413207593783713915426122020760220200962628873257794645344659126234350783362520232937382579415610663746828392924026327747794425626141392773865950346637064174246371571837351420992233344062254063004757468577995939379897993193722583949403597667165033043933811059238611044358850088944057150953129814673085433731422687785566472827960494242036349009965701146325660092626526866636741360317457144119738158003775134954823045411310436682376561512014404221552766592012791776965688411212916853988442526527777223563995953945090332351002305982164793174271625093282984992046032274951611696036542232385099291921377840133915960659274308526871034506622124037911120711272335249025196515592583392678990396541431509015245112808627308605230645670888249960119617991375075653011814751387324805598521757245984654247162696543977671847800969456137308372118173924084582696710434833009943391006165484863556801945924761185397784449895828775242142766612729106337547798730264972724298993447640493695756503440786674403298675468756633033853240342308575444441775035978541935586769843253889359543181996600592878668273551851651266705609363205808230336702740427303351537311081989404385700987193740374485573750747419276631578656968480532823673292853647019954090965720653321459225020751165977815769852656023234554095079275048233359616123858415047486609750277696370817538590941052053803935479384367645573011975407259426054070357113585479005297642116897651279506989933977345269130066988253726711300933326182472983199002645257917271123672079441911805584089542633159421452337069087973728040999734760712273629006080500762954548251908691381784067800734643882911032546125811303469980381870263372332360671039904136270381729357041846328843249641017699827577927596812989416965256836247670329975674623744450838535472004052658681841216386546933159167898536744541149333548624116266983262428685228865855454111438880352008101796338430703006943098523638214959404399541450966965511320456528658400185699247423924197388350889463151583885350332439613260175187760288310269608016603075854160459164947831765375442529244258273921093734226227368574847023967191171829705726968466144370048178148497090543646989905864556034354139157951174683665891397638689909670700247134092110782056225587573939768009900372301082004327907241855880726486554080916936242586996917137781272223775489927779023184814243966152485374635164423352881980488156327281153354248494380303778405544989549188478083552444397893880462543645258787005779391507350582860816074668420670711929546965418071611010903955408892792332368731121167183827629030747036955459471791800384048811051845637880892094276829213713574498128338768019254874975579310692053155347801896290906754486740832254238503020607371608352905281991782677823769536077014347723199590822001091328434178517649435809098995013544982317833365256356310053319215043251608436177381778062528942737820403760217881171540795988326149821276952454461781110569444403292494706178961903074330695919502479109629192693026313451591047098552737989930612193403827988948634826943769947430720762142735429972387617451526986479063603967412546215706240312520425215347108617165273602877597092678819190709835123452150676061432095732167217630864928036548304710115673037835109560463440504975716688974849769436663212086888339546646359455091569884008243124737970857284398125490157375840296562874924455344202764148929171241642566526932481681893182593367989404352373903184697569314164092271058810866398033403990351499912179632895246078346191950931961176703708612183742702613207220109689007850957888536283307549124584057291978590266291334779667792457119264645977182872652476836183182666142334669354998280299326224264315001501675628028468714678491886822279611664819942130288321179154767372135680398497323275270928110744057405311588272235460959456425787218007116727677849557496699373711867463955132722429541590825295675572726904454617545042268968326856894704903999315493496382476732115058784610013761067516498185662040615636076308721875926895772482018515335715751845080484393615754889575606170582444847918594371621416685370682303134591661128848488137123093060498340895918456170208072206685376014227300890026251202027682614547425033073593698629075212226313583569810624011548280347902826658234985044664857319014652694619646119682638672234042396358639234571691732975371533099425538292695199972453772235338238520193390515139935038524795537028334984804772018808363739279810659238318462267162753581312784587766746766255113361795905501211324257087488059632910607770659462602956966750787533130174265981686107222757705274574716980698181326519422062608227095740630153654865919252628423193814245154122330197545637756915200345034458266585429380095765122065374963814453011490085211155655395747756393243203856993667071864662755175286861970481869003353501210406855358844446117363813842908757602818346595411679575655906688327885770195107260075021949762937448046288370968280471539541632545126549963797147050336115929770056316070440431283344017919578162502812027692425348722646811705410945856616613628061984996769383054100150023510670520327880093252826948923483010142995533851117632053071097552097562905527451388016091983806349340510369349315370513851820892203490974982933310512848733412597297204070466981715896509163434955257513484269789159650309888573446467726796304668120919982222899567733876384950928976221579089034683659858038176820585376691577957735453043439865583225826069261643019803836690788750406091871041185193199681986789136476539236029048146789998209889644120869878824403419808842078955847637677141167500270643045646322712556579299058301538486189039412633199589202089397403328213358328126910938010699311097895066187043499800261524401021293190769593060186171934002212371567360474586567763110351553208868452906785671469544964587439235909106689404607102151836809766210691689565174925103545886993940666632111569308987647353644746852790101321434291437463216006240164282513017886710967964000735085205013989338890079162860434262463295553981290284187925597575494377304933512238380947181431875466541027068393126125967214609349265576741636715921970994298304910752749173168049118260552408160957166495240354240667702272153373161739343719106851447974763800371957755277089518649376050644930245020537701169100181539524681600001029942685043134361828223446016020809104737257057093117866813279194437918860643925966151151837944359068021528640647393077200970247523919911948278555618209551213307158360722627157678309992999902653490973355134930390402884293822149003568618846178732420628348054178382112556101906956848154969985714345608297574113145049016035022757196467687888509552205607117635391518608079352945858592103101052589586030855691808130691666356723363009863975566662901196065560801980456264746913351135672006210489047813706212863761484924981314332853931109877363350424589637501794556805378053470913557750918340279211634032137577177141283490003523030763584498611276401951228283593963578018172640639732056512498790766608281063523341560576110838263344288776496500300545033169101447012855300310232574782594878744776767207221576178035403959674372829440127155931157549209486692498536101129012521550499576438736945200331679593291743673917187586397200049749677230011481498156228605474029922487222699051748186389685511004324410535805807294753423001797075169429705455119567711722797189099896241851681805778993766362010349253316279465501149079361653217577022323219152070441143588054616880059142399206541425773992732133878732491404665939633785736733330412531384377497627720759828039557678250246777015589986370120820679650413493381225215508757915697864776776898798816601676515801139609367238371982625815418064702428123030333786118345700269506406312159162570016228600616649083064193479024641489213058302845851945878915106757666670561829109324997140332756594143268432161421772692721150153242273071167291251819533524316085269120639454122961232479355403453733455806423522522026204450048303251698553300318919720097519649821131693219456183647282919017564156764881859357631357479805279962147237201024121140590027887712658997886195313654532288538177801904031463253375420942315665449221766197529807533337245974030923304267986248162617856183772711301679213678037740267238420868668501067613708413584912810980139756275889167846276199169212666980614567573069723394634239058745294106989725571033692778923835736353670269853519631909500639772832601754610419894357501133690367786168002171894248221493637334362598947643687497901583560449742723131643262689703212816869773757245854376735872995469778458135510131609606482091867511369284973884632103275515011614228751485172811777741036759838865819642630615532456050341681973774733683180258572031994574554959713377920158824297853679767705247095763045979126758702062887368007833837574792856556600674095192371529135556671701540695956411347610850359153763251749011617254147565518354468781018048421587024798379222882419991414309278303691431998553094359956928901601111543108084619257344915969028636778267101975857149499288174016040857095558098774827483006686340595821425792732620902474226658077682779320442470414920001682874928803500640487107492402747555788210246199134705772127207146470434994674666915671768891113980465219129190239240172694957625638672720574128108789326557652120040563050469224605650519876511588818238534771182224435710948848355295255591758636662917159198809409782578289174479191255709322005554643446408132154946589162726143161174354050855857710520482373205190747653533132076092139754655200709471972564700097489529048612096209037253366495842028096815110319003916354929192456869559368616259110064455981086502253380786196409174395470139733556484905285883229552400157475190316668611360290721968616343192060062632482537383416581264419804978109575992799814150721018537876333576343581592939310570619543537619255191894513957493477010358053355972266923627335359811429098710086380115891190266040667327131596838090918002249818618949407387804822476280258137077276825661909818241648397128586047266822873799243705671651609806405698549282837777323860150315369239999997995629225508726322377177069872891654714046811279363297050540702161895826525499189583048310876278200365822101500271388984839968718393991870446092801118739765478319375046627385041021480191258656998434097576643215058686410359922229230909971848388370700817950419566168351231887833480754608873929163505932322218466400251935569232068588160551692214081318143099256872203508190715182201173041433136818802559669686441483269825055878776276769072986331141400464446806622505008190890157638778258290706277186606502702523892723884786787165177308201857027557875806841527700467454942925310033269772700975691285624595560408732742051434417051248283158245710860738613267165082526494939386229191202048994782873570511966080570105435439180201712634358049212409023538971510765042527224721215611379666827253249446800086100144676786433395888321401486037531721694712873394828747583872849961061710688021286686541826971700542390603499549491179405234208475087242271675559934715589607749506177010498828540368546391436326644783897531063517704156998814320477015949632973018960491976752000542942962416219534169218201926990379099768414906991436720013693740182081690418746628205474766628756241046732978115376102052871792280366600119569789527699145222021323973560401275894509887215854738853137219363516194857354556843366997130944454283481593550205086545778444961741554245580011385047849165967749960641165585625630784475817255018400645716154177011457625398738093280348048764160541946360856120098119523560226380959156504518272435706655720916051180662962664078663288807936520152736705230651856508139168270214129476296275279881129495957536989449365151913079417136733662461422504955205064749670571597955422601882113674675196801673707906355641691271972136073535733137421184311222598754659532654569196186511774650303666895243801094658411584492698139308178326632782542906789241611175874203928642658410382807780993299827432243983219120101602738659219329098486445977571931170784

程序本地跑出来要0.04s，交了却是0s，一看就是数据没走上限……


---

## 作者：Ameiyo (赞：4)

## 分析题目

首先看题目。球票价格是$50$元，而有$n$个人手中有$50$元，另外$n$个人手上有$100$元~~(其实让他们两两配对一起买就好了)~~，要求不会没钱找零的排列方案数。

既然售票点开始没有零钱~~(那你还出来卖票？？)~~，那么后来找给$100$元的$50$元只能从之前买票的人手里来，
所以当一个手中握着$100$元的球迷买票时，只要之前收到的$50$元没有找完，也就是是说$50$的个数要比$100$多(因为他也要用，所以是大于)。

如果我们用$A$表示拿着$50$的人，用$B$表示拿着$100$的人，那么问题就变成了：

有$N$个$A$，$N$个$B$，求符合条件的排列的个数。在符合条件的排列中，对于所有的$B$，他前面的$A$的个数要大于等于他以及他前面所有$B$的个数。

到这里，我就想到了之前看过的一道题(我忘记是哪本书上的了QWQ)。那道题与转换后的问题一模一样，然后他给出了一种特别。。。特别。。。特别(sao?)的做法：

如果我们用$\nearrow$表示$A$，用$\searrow$表示$B$，那么我们可以得到这样的图

($n=3$)

(用TIM截屏得到的箭头再一个个贴到GGB上的QWQ，我太蒟了求勿喷)

![](https://cdn.luogu.com.cn/upload/pic/39768.png)

如果我们顺着箭头走的话，那么沿着$\nearrow$走到$(x,y)$（坐标）就相当于在排列的第$x$位选了$A$，不然就是选了$B$（沿着$\searrow$过来）。根据图示，我们可以看到这样子是肯定符合的，而且如果在左半部分的外面再加$\searrow$肯定不符合(因为$B$会比$A$多)。

综上所述，从$(0,0)$走到$(2n,0)$的方法数即为所求。

---

## 代码实现

我们用$f[i][j]$表示按照规则从$(0,0)$走到$(i,j)$的方法数，那么就可以得到状态转移方程
(其实和[P1002 过河卒](https://www.luogu.org/problemnew/show/P1002)
的递推差不多)：

$f[i][j] = f[i-1][j-1]+f[i][j+1] (i \in [1,2n], j \geq 1)$

和

$f[i][j] = f[i-1][j+1] (j = 0)$

显然这一层只与上一层有关，所以就可以优化空间，详细见代码。

```cpp

#include <iostream>
#include <cstdio>
using namespace std;
const int N = 105, INF = 1e9;

int n;
ll f[2][N];

int main() {
	scanf("%d", &n);
	f[0][0] = 1;
	for (reg int i = 1; i <= n<<1; ++i) {//n<<1就是右移一位，即n*2
		f[i&1][0] = f[(i-1)&1][1];
		for (reg int j = 1; j <= n ++j) {
			f[i&1][j] = f[(i-1)&1][j+1] + f[(i-1)&1][j-1];  //x&1其实就是x%2，&是位运算，意思是按位与。
            //其实由于位运算优先级较低，i-1前后不加括号也是可以的，但是平时用的时候一定要注意括号，不然因为优先级问题可能会出现很难调试的错误
		}
	}
	printf("%lld\n", f[0][0]); //因为2n肯定是偶数，对二取余肯定是0
	return 0;
}

```

然后就解决这道题啦

---

## 作者：处1a2b3c4d (赞：2)

看到楼上大佬都没有写搜索的，本蒟蒻给出一发暴力记搜

思路很简单，递归返回方案数，保存在考虑第n个人时售票员手上还有rst张绿色毛爷爷的状态数。

## 注意要long long

代码如下（不想打注释了）

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
long long mem[50][50];
long long DFS(int d,int rst,int avl)
{ 
	if(rst<0||avl<0) return 0;
	if(d==2*n) return 1;
	if(mem[d][rst]) return mem[d][rst];
	long long ans=DFS(d+1,rst+1,avl-1);
	ans+=DFS(d+1,rst-1,avl);
	return mem[d][rst]=ans;
}
int main()
{
	memset(mem,0,sizeof(mem));
	cin>>n;
	cout<<DFS(0,0,n);
	return 0;
}
```

---

## 作者：pomelo_nene (赞：2)

极简代码

当时没看提示，用的栈模型，超时得厉害（哦多么痛的领悟）

假设我们用1来表示手拿50元的钞票的人，0代表拿100元的人，求解的问题转化为从左到右1的累计个数总是不小于0的累计方案，求满足这个条件的数

所以说总方案数为$C_{2n}^{n}$。

根据我们的假设，又假设我们现在制造出来的数是不符合要求的，某一奇数位（双假设这个位置为$2m+1$）首先出现了m+1个0和m个1，而后的$2(n-m)-1$位上有$n-m-1$个0和$n-m$个1，叒假设把后面这一部分$2(n-m)-1$位中的1余0互换，结果就会得到一个由$n+1$个0与$n-1$个1组成的$2n$位数。

反之，由$n+1$个0与$n-1$个1组成的$2n$位数绝对存在一个不符合要求的数（可以试着自己证一下，~~很简单~~）

综上所述，不符合要求的数的总数为$C_{2n}^{n+1}$，所以原问题的解为$C_{2n}^{n}$-$C_{2n}^{n+1}$=$\frac{C_{2n}^{n}}{n+1}$

因为~~太懒~~手太累不打代码注释了哦
```cpp
#include<cstdio>
int main(){
	int n;
	scanf("%d",&n);
	long long tot=1;
	for(int i=0;i<n;++i)	tot=tot*(2*n-i)/(i+1); 
	printf("%lld",tot/(n+1));
	return 0;
}
```

---

## 作者：YLWang (赞：1)

破壁人四号之DP专辑。

因为自己DP太菜了于是来写题解加强一下。

这个题本来是个数学题。但可以用DP做。

接下来进行由浅至深的讲解。

初始DP：
我们定义$dp[i][j][k]$表示当前来了$i$个人，$50$元$j$个，$100$元$k$个的方法数

那么手玩一下得$j \geqslant k$且$i= j + k$

转移方程就是当前来$50$或$100$

然后就做出来了

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
    int num = 0; char c=' ';
    for(;c>'9'||c<'0';c=getchar()) ;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num;
}
int dp[55][55][55];
signed main()
{
    int n = read() << 1;
    dp[0][0][0] = 1;
    for(int i = 1; i <= n; i++) {
    	for(int j = 0; j <= i; j++) {
			int k = i - j;
			if(k > j) continue;
			if(j) dp[i][j][k] += dp[i-1][j-1][k];
			if(k) dp[i][j][k] += dp[i-1][j][k-1];
    		
		}
	}
	cout << dp[n][n/2][n/2] << endl;
    return 0;
}
```
然后因为$k$是固定的，所以可以直接把$k$这维干掉。节约空间。
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
    int num = 0; char c=' ';
    for(;c>'9'||c<'0';c=getchar()) ;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num;
}
int dp[55][55];
signed main()
{
    int n = read() << 1;
    dp[0][0] = 1;
    for(int i = 1; i <= n; i++) {
    	for(int j = 0; j <= i; j++) {
			if(i - j > j) continue;
			if(j) dp[i][j] += dp[i-1][j-1];
			if(i - j) dp[i][j] += dp[i-1][j];
    		
		}
	}
	cout << dp[n][n/2] << endl;
    return 0;
}

```
所以本篇题解的DP到此结束。

经过数学推理与打表（各位的题解都讲清楚了），最后答案是卡特兰数。有兴趣的读者可以自行翻阅。这里就不提供代码了。

感谢阅读。


---

## 作者：勾陈GouceQ (赞：1)

大家都是巨佬卡特兰数什么的，我看了眼算法标签有个dp，就蒙了个dp过来~~还真过了~~

用f[i][j]表示**第i个人来**时，还剩j张50元钞票的方案数，考虑上一个人（i-1）可能拿着50元，即带来一张50元钞票，或拿着100元，即带走一张50元钞票，那么f[i][j]就由两种情况转移而来：

（1）第i-1人带来一张50元钞票：f[i-1][j+1]

（2）第i-1人带走一张50元钞票：f[i-1][j-1]

于是
```cpp
f[i][j]=f[i-1][j+1]+f[i-1][j-1]
```
考虑j的上界和下界的问题：当j=0时，f[i][j]=f[i-1][j+1].
上界的问题其实不用考虑，数组初始化为0，只要不越界就好了.边界条件f[1][0]=1.

dp要算到第2N+1人，他来的时候才是第2N人买完票，以为拿50元和拿100元的人数是一样的，所以第2N人来的时候应该刚好一张钞票都不剩，于是答案存放在f[2N+1][0]中.

粘个代码，~~其实好多地方还可以改但是懒~~
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#define maxn 43
typedef long long ll;
using namespace std;
//浮生若梦，为欢几何 
ll N;
ll f[maxn][maxn];
/*
f[i][j]=f[i-1][j+1]+f[i-1][j-1]
f[1][0]=1
*/
int main(){
	scanf("%lld",&N);
	memset(f,0,sizeof(f));
	f[1][0]=1;
	for(int i=2;i<=2*N+1;i++){
		for(int j=0;j<=N;j++){
			if(j==0)f[i][j]=f[i-1][j+1];
			else f[i][j]=f[i-1][j+1]+f[i-1][j-1];
		
		//	printf("f[%d][%d]=%d\n",i,j,f[i][j]);
		}
	}
	printf("%lld",f[2*N+1][0]);
return 0; 
}
```
空间复杂度可以优化，f[i][j]中i只表示奇偶性开2就可以了

~~但是确实太懒就算了~~

---

## 作者：ljcljc (赞：1)

赤裸裸的卡特兰数，但我不是打表呦


```cpp
#include<iostream>
using namespace std;
long long n,f[21]={1,1};//一定要初始化，否则没分！！ 
int main()
{
    int i,j;
    cin>>n;
    for(i=2;i<=n;i++)//从2开始
        for(j=0;j<i;j++)
            f[i]=f[i]+f[j]*f[i-j-1];//推出来的公式，一定要记住！！
    cout<<f[n];//输出 
    return 0;
}
```

---

## 作者：Chouquet (赞：1)

~~orz巨佬们居然用卡特兰数做~~

可以发现，只有前面收了50元的时候才能收100元的，所以就可以做了：

代码如下：

```cpp
#include <cstdio>
using namespace std;
long long f[65][65];//一定要开long long
int main(){
	int n;scanf("%d",&n);
	for(int i=0;i<=n;i++) f[i][0]=1;
	for(int j=1;j<=n;j++) f[0][j]=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(i>=j) f[i][j]=f[i-1][j]+f[i][j-1];
            /*f[i][j]=50元的和100元的张数的和且i比j大*/
			else f[i][j]=0;//不满足则赋值0
		}
	printf("%lld\n",f[n][n]);//输出最后方案
	return 0;
}
```
至于开头的两个循环的目的，请读者思考

---

## 作者：Alpha_Zero (赞：1)

大家的题解基本都提到了卡特兰数，但是没有细细地讲本题和卡特兰数有什么关系

这题和[P1044栈](https://www.luogu.org/problem/P1044)一模一样啊，为了方便理解，先讲讲P1044栈这道题

------------

 _**·为什么是卡特兰数**_ 

First，1肯定是第一个进栈的（~~废话~~）

Second，如果1出栈了，那就意味着栈空了（~~还是废话~~）

Third，我们假设1是第k个出栈的，那么在1前面出栈的有k-1个数，在1后面出栈的有n-k个数。那么如果我们用f数组记答案的话（f[i]表示i个数的全部可能性）,答案就是f[k-1] * f[n-k]，然后枚举k即可。

这，就是传说中的卡特兰数

 _注：如果你把进栈看成手拿50元的球迷，把出栈看成手拿100元的球迷，那就和P1044一样了。（或者你把售票员拿到50元看成进栈，找零50元看成出栈也可以）_ 

 _**·卡特兰数怎么实现**_

```cpp
long long f[30];
f[0] = f[1] = 1; //当然只有一个
f[n] = f[0] * f[n-1] + f[1] * f[n-2] + ... + f[n-1] * f[0];
```

写出来代码长这样：

```cpp
#include<iostream>
using namespace std;
int n;
long long f[30];
int main()
{
	f[0]=f[1]=1;
	cin >> n;
	for(int i=2;i<=n;i++)
		for(int j=0;j<i;j++)
			f[i]+=f[j]*f[i-j-1];
	cout << f[n] << endl;
	return 0;
} 
```

 _**·卡特兰数通项公式**_ 
 
 ```cpp
f[n] = f[n-1] * (4*n-2) / (n+1);
```

代码长这样：

```cpp
#include<iostream>
using namespace std;
int n;
long long f[30];
int main()
{
	f[0]=f[1]=1;
	cin >> n;
	for(int i=2;i<=n;++i) f[i]=f[i-1]*(4*i-2)/(i+1);
	cout << f[n] << endl;
	return 0;
}
```

于是大家就可以愉快地AC两道题啦~

---

## 作者：_•́へ•́╬_ (赞：0)

**我有2种方法**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans[31][31];
main()
{
    int m,n;
    scanf("%d",&m);n=m;//m个50元，n个100元（虽然这道题不需要）
    ans[1][0]=1;//边界
    for(int i=1;i<=m+n;++i)
    	for(int j=0;j<=min(m,i);++j)
    	{
    		int k=i-j;//j是50元的个数，k是100元的个数
    		ans[j+1][k]+=ans[j][k];//多一个50元的
    		if(j>k)ans[j][k+1]+=ans[j][k];//多一个100元的
		}
    printf("%lld",ans[m][n]);
}/**/
```
**这一种，多一维数组，不过好理解些。。。**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans[31][31][40],sum;
main()
{
    int m,n;
    scanf("%d",&m);n=m;//m个50元，n个100元（虽然这道题不需要）
    ans[1][0][1]=1;//边界
    for(int i=1;i<=m+n;++i)
    	for(int j=0;j<=min(m,i);++j)
    	{
    		int k=i-j;//j是50元的个数，k是100元的个数
    		for(int t=0;t<=m;++t)ans[j+1][k][t+1]+=ans[j][k][t];//多一个50元的
    		for(int t=1;t<=m;++t)ans[j][k+1][t-1]+=ans[j][k][t];//多一个100元的，注意要从1开始（因为要找50元）
		}
	for(int t=0;t<=m;t++)sum+=ans[m][n][t];//先统计再输出
    printf("%lld",sum);
}/**/
```

---

## 作者：SIGSEGV (赞：0)

Catalan number(卡塔兰数)

至于为什么是卡塔兰数的，各位dalao已经有解释了

蒟蒻就只说一下卡塔兰数的公式：

f[n] = ∑(i=0 to n-1)f[i]*f[n-1-i]

f[n] = f[n-1]*(4n-2)/(n+1)

f[n] = C(n,2n)/(n+1)

f[n] = C(n,2n) - C(n-1,2n)

蒟蒻用的第二种：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;unsigned long long catalan[30];
unsigned long long calc(int n)
{
    if (n == 1) return 1;
    if (catalan[n]) return catalan[n];
    catalan[n] = calc(n - 1) * (4 * n - 2) / (n + 1);
    return catalan[n];
}
int main ()
{
    cin >> n;
    cout << calc(n); 
    return 0;
}
```

---

## 作者：dyx131313 (赞：0)

一看这道题目，作为一个小初一想起了小学那些不堪回首的记忆，经典的加法原理的题目，现在才知道学名为卡特兰数（不理解的自行百度），~~我真是太愚昧了！~~

------------

举个例子：假设n=7：

![配图](https://cdn.luogu.com.cn/upload/pic/16121.png)

如图，设坐标轴中的（x,y）x代表收了x个50块，y代表收了y个100块。从（0，0）开始设为1,因为要找回一百块钱，则要收50块钱，所以x>=y。所以到达一个点的方法为其左边和下边的方法数之和且满足x>=y。

详细代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>//华丽的头文件
using namespace std;
long long f[21][21],n;//题目明确给出数据大于int
int main()
{
	scanf("%lld",&n);
	f[0][0]=1;//（0,0）只有一种方法到达
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=i;j++)
		{
			if(j==0) f[i][j]+=f[i-1][j];
			else if(j==i) f[i][j]+=f[i][j-1];
			else{
				f[i][j]+=f[i-1][j];
				f[i][j]+=f[i][j-1];//dp方程
			}//特判，详见上图（其实不判也行）
		}
	}
	printf("%lld",f[n][n]);//输出
	return 0;
}
```

---

## 作者：Carolina (赞：0)

**p党的福利**

看着各位大佬发着各种高深的题解（本蒟蒻看不懂的C、C++），本蒟蒻就只能呵呵了。

我发现没有人根据最本真的公式模拟？呵呵

这是一道典型的卡特兰数,卡特兰数有很多用处，本题目是其中最经典的用法之一，还有像单调栈出栈顺序这种都是比较常用的卡特兰数。

公式是：f[n]=∑(i=0 ~ n)f[i]\*f[n-1-i]

边界是f[0]=1, f[1]=1;

还有不懂的同学请自行问度娘https://baike.baidu.com/item/卡特兰数/6125746?fr=aladdin

有人说这是DP？ 呵呵。

有人想顺利地打全int/longint？呵呵。

有人用了高精度？呵呵。

我就暴力上啦~

```cpp
var
  n,i,j:longint;
  f:array[0..20] of qword;
begin
  readln(n);
  f[0]:=1;
  f[1]:=1;
  for i:=2 to n do
  begin
    for j:=0 to i-1 do
      f[i]:=f[i]+f[j]*f[i-1-j];
  end;
  writeln(f[n]);
end.
```

---

## 作者：VenusM1nT (赞：0)

万万没想到，一道裸的卡特兰数，我居然栽在了精度手上……

果然还是我太蒻了……

不说了，这题是裸的卡特兰数，大家应该都看出来了

（果然初赛练得多有好处啊【划掉

卡特兰数递推式： $f[n]= f[0]*f[n-1]+f[1]*f[n-2] + ... + f[n-1]*f[0] (n>=2)$

当然这种算法的时间复杂度略高，比不上O(1)，但还是可以0ms过的

最重要的一点：

##要开long long！

###千万别忘了！

具体见代码



```cpp
#include<cstdio>
long long n,f[45];
int main()
{
    scanf("%d",&n);
    f[0]=1;
    f[1]=1;//卡特兰数第0、1项 
    for(int i=2;i<=n;i++)
    {
        int x=0,y=i-1;
        while(x<i && y>=0)
        {
            f[i]+=f[x]*f[y];
            x++;
            y--;//递推式的表现 
        }
    }
    printf("%d",f[n]);//输出，结束 
    return 0;
}
```

---

## 作者：Dream_It_Possible (赞：0)

这题不少同学用搜索回溯做，结果超时，其实如果多推一下，就能发现：

n=1:A      (一种)

n=2:AABB   ABAB   (两种)

n=3:AAABBB   ABABAB   AABBAB    ABAABB  AABABB (五种)

注:A为50，B为100。

推论得：n=1   1

               n=2   2

               n=3   5

这不就是卡特兰数吗？

所以:

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
long long f[20000];//最后开long long
int main()
{
    int n,i;
    cin>>n;
    f[1]=1;//第一项
    f[2]=2;//第二项
    f[3]=5;//第三项
    f[4]=14;//第四项
    f[5]=42;//第五项
    for (i=6;i<=n;i++)
    {
        f[i]=f[i-1]*(4*i-2)/(i+1);//卡特兰数递推公式
    }
    cout<<f[n];//输出第n项
    return 0;
}
```
另附上其他卡特兰数递推公式：
h(n)= h(0)\*h(n-1)+h(1)\*h(n-2) + ... + h(n-1)\*h(0) (n>=2)

h(n)=C(2n,n)/(n+1)

h(n)=c(2n,n)-c(2n,n-1)

卡特兰数前二十项：

1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420


---

## 作者：杨赛滨 (赞：0)

本题多种解法：

回溯：时间爆炸。

递推：本质与回溯相同。

数论：卡特兰数，查百度去。

     
动态规划：

我觉得我写的就是一个动态规划吧~

```cpp
program P1754;
var
  f:array[0..20001]of qword;
  i,n:longint;
begin
  {assign(input,'P1754.in');
  assign(output,'P1754.out');
  reset(input);
  rewrite(output);}
  readln(n);
  f[0]:=1; f[1]:=1;
  for i:=2 to n do
    f[i]:=f[i-1]*(i*4-2)div(i+1);
  write(f[n]);
  {close(input);
  close(output);}
end.
```
{}运用卡特兰数的思想，求出转移方程。   f[i]=f[i-1]\*(i\*4-2)div(i+1)  }
这是由回溯做出来的前15个数： 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845

先写出 f[0]=1; f[1]=1; 为初始条件。接着开始寻找规律。发现， 第i个数与前一个的关系是， f[i]=f[i-1]\*(i\*4-2)div(i+1). （其实说到底就是卡特兰数）

接着继续观察，可以发现 第i个数只前一个数有关， 且题目要求只要输出它所需要求的那一个数，可以进行空间上的优化。

```cpp
a:=1; b:=1;
  for i:=2 to n do
    begin
      a:=b*(i*4-2)div(i+1); 
      t:=a; a:=b; b:=a;
    end;
（时间效率降低）
```

---

## 作者：silence__ (赞：0)

开始天真地以为可以直接用高中的排列组合公式算（想想发现忘光了T\_T），后来算了下才发觉不对劲。后面换了种想法。


Q1:假设抽屉里面没有钱，那么只能将一个50的排第一位。


Q2:假设抽屉有50元钱，那么这次可以随意排50或者100的在第一位。


问题可以抽象成，假设抽屉有money 的钱，有n1个人拿着50元，n2个人拿着100元待排队，求排队的方式数。开始是 money == 0, n1 == n2 == n。


很好的一个递归模型了，自顶向下，采用备忘录方法优化。


函数定义:



 

int GetCount(int n1, int n2, int  money);

对于Q1：



count = GetCount(n1 - 1, n2, money + 50) ;

即抽屉没钱，只能先排一个50的在前面


 

对于Q2:


count = GetCount(n1 - 1, n2, money + 50) + GetCount(n1, n2-1, money-50);


即抽屉有钱的话，排序总数量是两种子问题的总和。


 

 

然后讨论问题的递归出口。


由上面分析可以看出，最终出口肯定是 n1 不断减少，直到0， money不断增加，增加到跟n2相等的情况。这种时候相当于，抽屉有 x 张50元，刚好有 x 个人拿着100元过来买票。那么很好理解，只有一种排队方法。


---

## 作者：peterwuyihong (赞：0)

# 我来发一篇数学题解
相信大家都学过“标数法”
### 上图片！
![图不好看，大佬勿喷](https://cdn.luogu.com.cn/upload/pic/72601.png)
其中，$(i,j)$表示$i$个$50$，$j$个$100$时的方案数，所以只要预处理一下即可
```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[25][25];
int n;
int main()
{
	for(int i=1;i<=20;i++)
	f[1][i]=i;
	for(int i=2;i<=20;i++)
	{
		for(int j=i;j<=20;j++)
		f[i][j]=f[i-1][j]+f[i][j-1];
	}
	cin>>n;
	cout<<f[n][n];
}

```


---

## 作者：Call_me_Eric (赞：0)

估计大家都想用dp吧，那么我就先来一发dp题解吧！

为了防止抄袭，代码有漏洞，请自行寻找。

```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
long long f[21];
int main(){
    int n;
    scanf("%d",&n);
    f[1] = 1;
    for(int i = 2;i <= n;i++){//特点：卡特兰数
		f[i] = f[i - 1] * (4 * i - 2) / i + 1;
    }
    printf("%d",f[n]);//为了防止抄袭，这一行有漏洞，
//请自行寻找
	return o;	
}
```
然后我突然想到了什么······

对了，是~~打表~~！！！


```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
long long f[21] = {0, 1, 2, 5, 14, 42, 132, 429, 1430,
4862, 16796, 58786, 208012, 742900, 2674440, 9694845,
35357670, 129644790, 477638700, 1767263190,
6564120420};//经典的打表
int main(){
    int n;
    scanf("%d",&n);
    printf("%lld",f[n]);
    return o;
}   

```

希望大家不要抄袭我的代码 (￣▽￣)／

因为那样会ce的！！！

---

## 作者：Celebrate (赞：0)

经过观察可以发现，如果要满足条件，那么100元人数（我说的不是很清楚，要好好理解）前面的50元人数一定要大于100元人数（我说的不是很清楚，要好好理解）

这一题感觉不像是DP更像是递推，定义f数组

f[i][j]表示表示后面还有i个50元j个100元的时候的方案数，找到规律f[i][j]=f[i-1][j]+f[i][j-1]，就是前两种方案的总和数

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
#define MAXX 110
inline void read(int &Input) {//输入优化
	char Character;
	Input=0;
	Character=getchar();
	while(Character>'9'||Character<'0')Character=getchar();
	while(Character<='9'&&Character>='0') {
		Input*=10;
		Input+=Character-'0';
		Character=getchar();
	}
}
inline void write(long long Output) {//输出优化
	char Digit[110];
	int Lenth=0;
	while(Output>0) {
		Digit[++Lenth]='0'+Output%10;
		Output/=10;
	}
	for(int i=Lenth; i>=1; i--) {
		putchar(Digit[i]);
	}
	printf("\n"); 
}
int n;
long long f[MAXX][MAXX];
inline void Ditui() {
	read(n);
	for(int i=1; i<=n; i++) f[i][0]=1;//递推开始
	for(int i=1; i<=n; i++)
		for(int j=1; j<=i; j++)
			f[i][j]=f[i-1][j]+f[i][j-1];
	write(f[n][n]);
}
int main() {
	Ditui();
	return 0;
}
```

---


# 愚蠢的组合数

## 题目描述

最近老师教了狗狗怎么算组合数，狗狗又想到了一个问题。。。

狗狗定义 $C(N,K)$ 表示从 $N$ 个元素中不重复地选取 $K$ 个元素的方案数。

狗狗想知道的是 $C(N,K)$ 的奇偶性。

当然，这个整天都老是用竖式算 $123456789 \times 987654321=?$ 的人不会让你那么让自己那么轻松，它说：“ $N$ 和 $K$ 都可能相当大”。

但是狗狗也犯难了，所以它就找到了你，想请你帮他解决这个问题。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le t\le 10^5$。


## 样例 #1

### 输入

```
3
1 1
1 0
2 1```

### 输出

```
1
1
0```

# 题解

## 作者：JustinRochester (赞：79)

[题目](https://www.luogu.org/problemnew/show/P1869)

要做就要做到最好——沃·兹基硕德

为了带给大家最好的题解体验，本蒟蒻重新做了该题 $11$ 遍，接下来的内容个人感觉应该会比较适合各位食用

以前的分析我就不改了，各位跳到第一条代码下面即可

---

**【分析】**
--

### 法一

这题其实可以暴力，优雅一点就直接过了。本蒟蒻就先根据题目，打了个表。如图1所示。~~（真·打表）~~

根据图1，我们可以很清晰地看到该图是由复制得来的。于是，我们的题目就转变为，给定坐标(n,k),求该点在复制得来的图中是否是蓝色。是，则输出 $1$ ；否，则输出 $2$ 。

我们可以将其中的四个小单元格合并为一个单元。则得到结论1：单元的右上角为偶数（如果存在的话）。

又如图而得，单元的右上角满足n为偶数且k为奇数

故结论1：若( (!(n&1)) & (k&1) ) 则答案为0。

接着，因为每一个单元我们都进行了判断，所以我们可以将所有的单元都视为单元格，并重新标记n、k。结果如图3所示。

参照上面的思路，我们又可以建立新的单元，并且又能得到结论1。如图4所示。

由图1到图3的变化得，当整个图如图5所示时，判断完毕。（图5右上方不存在）。

整理一下思路：我们从图中得：若( (!(n&1)) & (k&1) ) 则答案为0，否则将n/2,k/2，循环至n<2为止。

![](https://cdn.luogu.com.cn/upload/pic/14493.png)



------------

**【代码】**
--

本蒟蒻代码奉上：

```cpp
#include<cstdio>
#include<cctype>
using namespace std;
int read(){
	int abs=0;char c=getchar();while(!isdigit(c)) c=getchar();
	while(isdigit(c)) {abs=abs*10+c-'0';c=getchar();}
	return abs;
}//读入优化
int main(){
	int t=read();
	while(t--){
		int n=read(),k=read();
		bool i=1;
		while(n>=2&&i){
			if((!(n&1))&(k&1)) i=0;//x&1==1则x为奇数
			n>>=1;k>>=1;//x>>=1等效于x/=2
		}
		putchar(i?'1':'0');
		putchar('\n');
	}
	return 0;
}
```

复杂度 $O(T\log n)$

---

以下代码为本蒟蒻直接手打的。

如有错误，请在评论区直接公布或者与本蒟蒻联系。

如对众位的阅读体验感产生不良影响，本蒟蒻先再次表示歉意。

---

**【分析】**

### 法二

在学习了[卢卡斯定理](https://www.luogu.org/problemnew/show/P3807)后，本蒟蒻重新回来做了该题

首先，根据卢卡斯定理的内容(证明本蒟蒻不会......OI不需要证明......)

$C_n^m \% p=C_{\lfloor {n \over p} \rfloor}^{ \lfloor {m \over p} \rfloor }C_{n \% p}^{m \% p} \% p$

其中 $p$ 是质数， $\lfloor x \rfloor$ 代表实数 $x$ 的向下取整

当然，由于 C++本身除法就是向下取整的，所以我们可以直接这么理解：

$C_n^m\%p=C_{n/p}^{m/p}C_{n\%p}^{m\%p}\%p$

而题目要求所求的 $C_n^k$ 的奇偶性(奇数为 $1$ , 偶数为 $0$)，显然就是求 $C_n^k \% 2$ 的值
```cpp
people &me=LRJ("想一想，为什么？");
```

好，那么根据卢卡斯定理， $2$ 又是质数 ，我们可以直接这么计算答案：

$C_n^k\%2=C_{n/2}^{m/2}C_{n\%2}^{m\%2}\%2$

当然，众所周知 $C_0^0=C_1^0=C_1^1=1,C_0^1=0$

即 $0$ 个东西中选 $0$ 个的方案数为 $1$ ，选 $1$ 个为 $0$ (不存在该方案)

$1$ 个东西中选 $0$ 个的方案和选 $1$ 个的方案数都是 $1$ 

```cpp
int c(int n,int k){
	if(n<=1) return (n==1)?1:((k==0)?1:0);
    return c(n/2,k/2)*c(n%2,k%2)%2;
}
```

复杂度 $O(T\log n)$

### 法三

当然，会位运算的同学这边可以优化一下，不会的可以听我讲解一下：

首先，我上面列出的四个组合数都有一个规律： $n<2$

如果懂得二进制的朋友可以想到，小于 $2$ 的数，其二进制最高位应该是最后一位。

所以说，如果我们右移一位(相当于除以 $2$)，得到的数如果不为 $0$ ，就直接说明这个数字大于等于 $2$ ，否则反之

同时，对 $2$ 取余相当于按位与上 $1$ 。因为对 $2$ 取余在二进制上就相当于取其最后一位，即按位与上除最后一位全部是 $0$ 的数—— $1$

因此，我们可以这么写，看着比较优雅 ~~装逼~~

$C_n^k\&1=C_{n\&1}^{k\&1}C_{n>>1}^{k>>1}\&1$

```cpp
int c(int n,int k){
    if(n>>1) return c(n>>1,k>>1)*c(n&1,k&1)&1;
	return (n&1)?1:(!(k&1));
    //k==1=>!(k&1)=!(1&1)=!1=0
    //k==0=>!(k&1)=!(1&0)=!0=1
}
```

复杂度 $O(T\log n)$ ，但常数比上一种小

---

### 法四

那么，接下来，有热情的小伙伴们还可能把 $C_{n\&1}^{k\&1}$ 拉出来讨论

为什么要讨论它呢？显然， $n\&1$、$k\&1$ 各有两种情况，一共四种，比较好讨论

1. $n\&1==1$ ，那么，不论 $k\&1$ 为什么值，$C_{n\&1}^{k\&1}=C_1^{k\&1}=1$

2. $n\&1==0,k\&1==0$，那么 $C_{n\&1}^{k\&1}=C_0^0=1$

3. $n\&1==0,k\&1==1$，那么 $C_{n\&1}^{k\&1}=C_0^1=0$

所以说 $C_n^k\&1=\begin{cases} 0,(!(n\&1))\&(k\&1)\\ C_{n>>1}^{k>>1}\&1,else\end{cases}$

```cpp
int c(int n,int k){
	return ( (!(n&1))&(k&1) )?0:c(n>>1,k>>1);
}
```

当然，你可以去试试，这个代码是错的......

因为我们少了个递归边界： $C_0^0$

当 $n==k==0$ 时，返回 $C_{0>>1}^{0>>1}=C_0^0$，会导致栈溢出

因此，我们还要加个特判：

```cpp
int c(int n,int k){
	if( !(n|k) ) return 1;
    // 当出现 c(0,0) 时，直接返回 1
    // n|k 表示 n 和 k 按位或，若两者存在不为 0 的数，则该值不为 0，取非后不为 1
	return ( (!(n&1))&(k&1) )?0:c(n>>1,k>>1);
}
```

复杂度 $O(T \log n)$ ，但常数理论上又要比上面小

---

### 法五

有的小伙伴还中意于非递归式写法，思路和上面大体一样：

当两者都不为 $0$ 时，判是否 $(!(n\&1)\&(k\&1))$ 是的话就直接返回 $0$ 了，否则 $n$,$k$ 都右移一位，直到两者为 $0$ 时返回 $1$

```cpp
int c(int n,int k){
	while(n|k)
    	if( (!(n&1))&(k&1) ) return 0;
        else n>>=1,k>>=1
	return 1;
}
```

复杂度还是 $O(T \log n)$，但常数还能再小

---

### 法六

现在，众位已经很接近最优解法了

仔细看一下上面的程序：

如果用 $x_p$ 表示 $x$ 在二进制下的第 $p$ 位

那么，循环的条件显然是对于当前位 $p$ ，有$n_p==1$ 或者 $n_p==k_p$

这边有一个比较神奇的写法： $n_p\&k_p=k_p$

假设有同学懂得集合的话可以这么理解：

有个集合是 $n_p$， 一个是 $k_p$

而循环的条件相当于 $Card(n_p)==1\geq Card(k_p)$ 或者 $Card(n_p)==0==Card(k_p)$

即 $Card(n_p)\geq Card(k_p)$ ，在本题中可以直接视为 $k_p \subset n_p$

根据集合的性质，易得 $k_p\bigcap n_p=k_p$

用位运算来描述即是 $k_p\&n_p=k_p$

这一步即接下来的每一步都可以代入值想想，都要先想通来再往下看

那么，循环是不是表示说我从后往前枚举每一位，如果 $n_p\&k_p=k_p$ 那么继续循环，否则就直接判 $0$

也就是说：如果存在 $n_p\&k_p\neq k_p$ ，那么，答案为 $0$

如果说 $k$ 中存在 $k_p$ 使得 $n_p\&k_p\neq k_p$ ,那么，是不是说明一定有 $k\&n \neq k$ ？

所以说如果 $k\&n \neq k$ 可以直接判 $0$ 跳出

而对于 $k\&n==k$ 的情况，我们是不是可以这么去想它：

首先， $n$ 的位数一定大于等于 $k$ ，否则该情况肯定不成立

其次，我们如果把 $k$ 的不足的位数全部补 $0$ ，是不是就显然有对于 $k$ 中的任意位置 $p$ 都有 $n_p\&k_p=k_p$ ？

所以，循环会一直进行，当 $k$ 补充的位数也全部用完， $n$ 的全部位数也用完了

也就是说，此时 $n|k==0$

因此，跳出循环，返回 $1$

综上，答案就是： $(n\&k==k)?1:0$

或者可以直接把该函数打成 $bool$ 型的

```cpp
bool c(int n,int k){ return n&k==k; }
```

因此，对于每次询问都是 $O(1)$ 的，总复杂度 $O(T)$

至此，对于 $O(1)$ 计算答案的全证明过程结束

---

还有小伙伴有疑问： 万一我考试的时候想不到怎么办？

不用方，这边再介绍最后一种方法：

如果我们知道 $C_n^m$ 中因数 $2$ 的个数，显然可以知道它的奇偶性

如果因数 $2$ 为 $0$ 个，即为奇数，否则为偶数

同时，我们还知道 $C_n^m={n ! \over m!(n-m)!}$

所以说，如果我们用 $two_i$ 表示 $i$ 的因数中 $2$ 的个数

那么，显然有 $two_{C_n^m}=two_{n!}-two_{m!}-two_{(n-m)!}$

如果说我们知道右边三个数的答案，对于 $C_n^m$ 是奇是偶就可以 $O(1)$ 判断了

那么我们还可以知道什么呢？

首先 $two_{i!} \geq two_{(i-1)!}$

当且仅当 $i$ 为奇数时取等，因为 $i$ 不含因数 $2$ ，故 $two_{i!}=two_{(i-1)!}+0$

当 $i$ 为偶数时，暴力地去判断它因数中 $2$ 的个数，即如果除以 $2$ 余 $0$ ，就是还含有因数 $2$ ，就计数器 $+1$, 该数除以 $2$

有看我上面的小伙伴还能想到位运算：当该数 $\&1$ 非 $0$ 时，该数右移 $1$，且计数器 $+1$

```cpp
int two[100010]={0};//这边的 two[i] 表示的是 two[i!] 的
void pre(){
	for(int i=1;i<=100000;i++){
    	two[i]=two[i-1];
        int tmp=i;
        while(tmp&1) tmp>>=1,two[i]++;
    }
}
```

这样就可以实现 $O(1)$ 查询了，预处理的复杂度是 $O(n)$ 的，总复杂度是 $O(T+n)$

由于 $T$ 与 $n$ 同阶，可以近似地认为是常数较大的 $O(T)$

这边给出预处理复杂度的证明(昨晚想了一宿)：

对于每一个数，都会进行一次将上一个值赋值过来的操作，该操作进行 $n$ 次

对于 $2$ 的倍数，除赋值外还需自增一次，该操作进行 $\lfloor {n \over 2} \rfloor$ 次

对于 $4$ 的倍数，还需再自增一次，该操作 $\lfloor {n \over 4} \rfloor$ 次

对于 $8$ 的倍数，又需再自增一次，$\lfloor { n\over 8} \rfloor$ 次

因此，总操作数为：

$n+\lfloor { n\over 2} \rfloor+\lfloor { n\over 4} \rfloor+\lfloor { n\over 8} \rfloor+\lfloor { n\over 16} \rfloor \cdots$

$\approx n+{ n\over 2}+{ n\over 4}+{ n\over 8}+{ n\over 16}\cdots$

$=2n$

因此，预处理复杂度为 $O(n)$

---

觉得写得不错的麻烦点个赞吧......

写了一整节晚自习呢

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：P500 (赞：34)

对于C(n,k),若n&k == k 则c(n,k)为奇数，否则为偶数。

上代码
```cpp
#include <iostream>
using namespace std;
long long n,k,t;
int main(){
    cin>>t;
    for(int i=1;i<=t;i++){
        cin>>n>>k;
        cout<<((n&k)==k)<<endl;
    }
    return 0;
}
```
**以下为证明：**

利用数学归纳法：

由C(n,k) = C(n,k-1) + C(n-1,k-1);

对应于杨辉三角：

1

1 2 1

1 3 3 1

1 4 6 4 1

………………

可以验证前面几层及k = 0时满足结论,

下面证明在C(n-1,k)和C(n-1,k-1) (k > 0) 满足结论的情况下,C(n,k)满足结论.  (分类讨论并反证)

1).假设C(n-1,k)和C(n-1,k-1)为奇数：

则有：(n-1)&k == k;

(n-1)&(k-1) == k-1;

由于k和k-1的最后一位(在这里的位指的是二进制的位,下同)必然是不同的,所以n-1的最后一位必然是1.

现假设n&k == k.

则同样因为n-1和n的最后一位不同推出k的最后一位是1.
因为n-1的最后一位是1,则n的最后一位是0,所以n&k != k,与假设矛盾.

所以得n&k != k.

2).假设C(n-1,k)和C(n-1,k-1)为偶数：

则有：(n-1)&k != k;

(n-1)&(k-1) != k-1;

现假设n&k == k.

则对于k最后一位为1的情况：

此时n最后一位也为1,所以有(n-1)&(k-1) == k-1,与假设矛盾.

而对于k最后一位为0的情况：

则k的末尾必有一部分形如：10; 代表任意个0.

相应的,n对应的部分为：1{···}···; ···代表0或1.


而若n对应的{···}···中只要有一个为1,则(n-1)&k == k成立,所以n对应部分也应该是10.

则相应的,k-1和n-1的末尾部分均为01,所以(n-1)&(k-1) == k-1 成立,与假设矛盾.

所以得n&k != k.

由1)和2)得出当C(n,k)是偶数时,n&k != k.

3).假设C(n-1,k)为奇数而C(n-1,k-1)为偶数：

则有：(n-1)&k == k;

(n-1)&(k-1) != k-1;

显然,k的最后一位只能是0,否则由(n-1)&k == k即可推出(n-1)&(k-1) == k-1.

所以k的末尾必有一部分形如：10;

相应的,n-1的对应部分为：1{···}···;

相应的,k-1的对应部分为：01;

则若要使得(n-1)&(k-1) != k-1 则要求n-1对应的{*}*中至少有一个是0.

所以n的对应部分也就为 ：1{···}···; (不会因为进位变1为0)

所以 n&k = k.

4).假设C(n-1,k)为偶数而C(n-1,k-1)为奇数：

则有：(n-1)&k != k;

(n-1)&(k-1) == k-1;

分两种情况：

当k-1的最后一位为0时:

则k-1的末尾必有一部分形如:10;

相应的,k的对应部分为 :11;

相应的,n-1的对应部分为 :1{···}0; (若为1{···}1,则(n-1)&k == k)

相应的,n的对应部分为 :1{···}1;

所以n&k = k.

当k-1的最后一位为1时:

则k-1的末尾必有一部分形如:01; (前面的0可以是附加上去的)

相应的,k的对应部分为 :10;

相应的,n-1的对应部分为 :01; (若为11,则(n-1)&k == k)

相应的,n的对应部分为 :10;

所以n&k = k.

由3),4)得出当C(n,k)为奇数时,n&k = k.

综上,结论得证!

---

## 作者：nianheng (赞：21)

## 解法：递归$+Lucas$定理  
$\quad\quad$正好最近学了一下大组合数取$mod$的Lucas定理，就拿这道~~难题~~练了练手。$A$了之后看了一下各位$Dalao$们的题解，感觉写的都太麻烦了$...$于是蒟蒻的我写了一个递归版的Lucas，简洁易懂 
### $Lucas$定理：
$\quad\quad C_n^k\ mod\ p=C_{n\%p}^{k\%p}\times C_{n/p}^{k/p}\ mod\ p$  
$\quad\quad$**注意这里的$p$必须为质数**

### 关于这道题：
$\quad\quad$注意到这道题的$n,m$都很大，我们考虑用$Lucas$定理将其化小，我们可以将$n,m$用上面的公式变为$n/2,m/2$，然后继续化为$n/4,m/4\quad...$直到化为$1$或$0$。上述过程可以用递归来快而简洁地完成  
### 还有：
$\quad\quad C_n^0 =C_n^n =1\quad C_0^k =0(k!=0)$
### 下面贴一下代码：
~~~cpp  
#include<iostream>
#include<cstdio>
using namespace std;
int a,b;
int C(int x,int y)
{
    if(y==x)
        return 1;
    if(y==0)
        return 0;
    if(x==0)
        return 1;
    return C(x/2,y/2)*C(x%2,y%2);//Lucas定理
}
int main()
{
	scanf("%d",&a);
	while(~scanf("%d%d",&a,&b))//迷之输入QWQ
	    printf("%d\n",C(b,a)%2);//注意细节
    return 0;
}
~~~

---

## 作者：Dream_It_Possible (赞：12)

//    对于C(n,k),若n&k == k 则c(n,k)为奇数，否则为偶数。

```cpp
//     可以用杨辉三角推
//     证明不在此多讲
//    可参见http://blog.csdn.net/kongming_acm/article/details/5965243
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
    long long n,a,b,i,j;//最好开long long
    cin>>n;
    for (i=1;i<=n;i++)
    {
        cin>>a>>b;
        if ((a&b)==b// 公式（括号不能少）
        cout<<"1"<<endl;
        else
        cout<<"0"<<endl;
    }
    return 0;
}
```

---

## 作者：irisalt (赞：8)

### 非lucas的简单解法
瞅瞅题解一大堆lucas

可是正解应该是算数基本定理

#### 什么是算数基本定理？
算数基本定理不是什么特别难的东西不要被名字吓到了。

内容是：对于n！质因数分解后每一个质因子的个数为n/(pi^1)+n/(pi^2)+…+n/（pi^k),k为使得pi^k<=n的最大值。
#### 算数基本定理的理解方法
单看公式好像不是特别好理解，这里我们用一个类似桶排的思想。

举个例子：10！中有多少个2呢？像装桶一样，2、4、6、8、10各有一个2（10/2个2），此时就当做是已经从桶中各取出一个2了；可是没完！4和8里面还有好多好多2呢，那此时桶中还有2的数，就已经是4的倍数了，那么就是（10/4=10/2^2），继续下去直到2^k(这里就是2^3)。

##### 扯个闲话：算数基本定理的简单模板： [P2043质因子分解](https://www.luogu.org/problemnew/show/P2043)

#### 怎么运用到这题里呢？
做这道题要用到组合数的公式，【稍微提一下C（n，m）=(n！/m!)/(n-m)! 就不多解释了】

怎么判断一个数为偶数？看质因子里面有没有2就好了嘛。那么这道题就转化为：C（n，m）的质因子中有没有2。也就是计算n！中有几个2、m！中有几个和（n-m）！中有几个，最后相减看看2的个数是0还是有好多个啦。
#### 放一下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt(int n)
{
	int k=2,a=0;
	while(k<=n)
	{
		a+=n/k;
		k*=2;
	}
	return a;
}
int main()
{
	int k,i,n,m,ans;
	cin>>k;
	for(i=1;i<=k;++i)
	{
		cin>>n>>m;
		ans=0;
		ans+=cnt(n);
		ans-=cnt(m);
		ans-=cnt(n-m);
		if(ans) cout<<0<<endl;
		else cout<<1<<endl; 
	}
 return 0;
}

```


---

## 作者：Enigmatic (赞：5)

看了楼下大佬们的解题方式，本蒟蒻自叹不如

最直观的方法就是计算一下，然后看它的奇偶性；但是这个时间以及数据范围上都不允许；

另外一种方法就是，对于给定C(n,m)，检查n中2因子的个数与m和(n-m)中2因子个数和的关系，假设n!中2因子个数为a，m!中2因子个数为b，(n-m)!中2因子个数为c，则显然有a>=(b+c)；并且当a==b+c时，一定为奇，否则为偶。题意转化为求a和b+c。求一个阶乘中含有的素因子i的个数的方法可以参见Knuth的具体数学，方法是显而易见的。但是有的时候，这种方法仍然太慢（比如TOJ的一道题目，要判断5000000次），更快的方法是什么呢？

方法三：由方法2可以很容易地看出，n!中含有2因子的个数等于(n-它的二进制形式中1的个数)（每除一次如果有1的话去掉一个1）。那么题意再次转化为求m,n-m以及n的二进制形式中1的个数。或者说，看n&m ?= m，这个呢，如果等于，那么也就意味着，所有m中为1的位置n一定为1，那么n-m就可以直接用二进制减，这样得到的差的二进制中1的个数加上m中二进制1的位数正好等于n中1的位数，由前面可以知道，这就是一个奇数。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k,t;
int main()
{
    scanf("%lld",&t);
    for(register __int64 i=1;i<=t;i++)
    {
        scanf("%lld%lld",&n,&k);
        if((n&k)==k) printf("1\n");
        else printf("0\n");
    }
    return 0;
}
```

---

## 作者：浮尘ii (赞：4)

以下题解都是LUCAS定理啥的。

这里提供一种简单的做法。


我们知道：n!中质因子p的个数为：[n / p] + [n / p²] + [n / p³] + ...

我们还知道：C(m, n) = m ! / (m - n)!n!


那么我们分别求出a=m!、b=(n-m)!、c=n!中质因子2的个数，再根据同底指数幂的运算法则，判断a-b-c是否为0即可，为0即奇数，反之为偶数。

时间复杂度是log级别的。


```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int    N, K, T;

int Calc(int x)
{
    int    ret(0);
    while(x)
        ret += (x >>= 1);
    return ret;
}

int main()
{
    cin >> T;

    while(T--) {
        scanf("%d%d", &N, &K);
        printf("%d\n", !(Calc(N) - Calc(K) - Calc(N - K)));
    }

    return 0;
}

---

## 作者：shzr (赞：3)

$\quad\quad$好几篇题解里都提到了$Lucas$定理,但是都是套板子.其实如果再深入分析一下就可以得到一个$O(1)$的结论了.  

$\quad\quad$  $C_n^m=C_{n\%p}^{m\%p} \times C_{n/p}^{m/p} \quad$来分析一下前面那个部分，其实只有四种取值。

| $C_i^j$ | 0 | 1 |
| :----------: | :----------: | :----------: |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
$\quad\quad$ 乘以 $1$ 等于什么都没乘,但是乘以 $0$ 以后就永远是 $0$ 了,归纳一下发现答案为零当且仅当二进制表示中至少有一位 $n$ 是 $0$ 而 $k$ 是 $1$.运用位运算可以快速的对这个条件进行判别  $->$ $n$&$k==k$时答案为 $1$ ,其他时间答案为 $0$.

```cpp
# include <cstdio>
# include <iostream>

using namespace std;

int t;
int n,k;

int main()
{
	scanf("%d",&t);
	while (t--)
	{
		scanf("%d%d",&n,&k);
		if((n&k)==k) printf("1\n");
		else printf("0\n");	
	}
}
```

---

## 作者：散华礼弥 (赞：1)

先给 $n!\div k!$ 分解质因数$2$，再给 $(n-k)!$ 分解质因数$2$，因为组合数的性质保证了前面的$2$的次数一定不小于后面的，所以我们只需要判断是否相等即可知该组合数是否是奇数了（$2$是唯一的偶质数）

```cpp
#include <cctype>
#include <cstdio>

long long t, n, k, te, sum, sum1;

long long read()
{
	long long x = 0, k = 0;
	char ch = getchar();
	while (!std::isdigit(ch))
		(ch == '-') && (k |= 1), ch = getchar();
	while (std::isdigit(ch))
		x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return k ? -x : x;
}

int main()
{
	t = read();
	while (t--)
	{
		sum = sum1 = 0;
		n = read(), k = read();
		if (n == k || !k)
		{
			puts("1");
			continue;
		}
		if (!n)
		{
			puts("0");
			continue;
		}
		te = n;
		while (te)
			sum += (te /= 2);
		te = k;
		while (te)
			sum -= (te /= 2);
		te = n - k;
		while (te)
			sum1 += (te /= 2);
		puts(sum > sum1 ? "0" : "1");
	}
	return 0;
}
```

---

## 作者：bymlg001 (赞：1)

只要能把奇偶，转化成mod2这道题就迎刃而解了

把之前的lucas模板打了一遍

我觉得 把求组合数放在lucas外面好理解些

###

```cpp
#include<bits/stdc++.h>
#define LL long long 
using namespace std;
const int mod=2;
LL t,up,down;
LL n,m;
inline LL fpow(LL a,LL b,LL p){ //快速幂
    LL base=a;LL r=1;
    while(b){
        if(b&1) r=base*r%p;
        base=base*base%p;
        b>>=1;
    } 
    return r;
}
LL inv(LL x){//费马小定理求逆元，因为2是质数所以可行
    return fpow(x,mod-2,mod);
}
LL c(LL a,LL b){//求组合数
    if(b < 0)return 0;  
    if(a < b)return 0;  
    if(b > a-b) b = a-b;  
    up=1;down=1;
    for(int i=0;i<b;i++){
        up=up*(n-i)%mod;
        down=down*(1+i)%mod;
    }
    return (up%mod*inv(down)%mod)%mod;
}
LL lucas(LL a,LL b){//卢卡斯定理 拳皇的卢卡斯【滑稽
    if(b==0) return 1;
    return c(a%mod,b%mod)*lucas(a/mod,b/mod)%mod;
}
int main(){
    cin>>t;
    while(t--){
        cin>>n>>m;
        cout<<lucas(n,m)<<endl;
    }
}
```

---

## 作者：LuckyCloud (赞：0)

**对于C(N,K)**

**首先是不重复取K个，那么第一次有N种选择，第二次有（N-1）种选择，以此类推就有
【N（N-1）（N-2）（N-3）……（N-K+1）】种选择**

**但是这样会有一个问题**

**比如**

**在3个里取两个**。

1 3

1 2

**2 1**

2 3

**3 1**

**3 2**

**(加粗为重复计算的)**

**会发现这些重复的只是同一数字的位置不同而已。**

**给定K种物品，对于第一个位置，我们可以放K种，第二个位置，可以放(K-1)种，以此类推，会有【K（K-1）（K-2）……1】 种摆放方式**

### 那么

#### C(N,K)=【N（N-1）（N-2）（N-3）……（N-K+1）】÷【K（K-1）（K-2）……1】

**好了，现在我们想知道C（N,K）是奇数还是偶数，我们只要关心是分母所拥有2这个因子多，还是分子所拥有2这个因子多。如果分子多的话，两者相除，结果肯定没有2这个因子，所以肯定是奇数。反之，那就是偶数咯**

**我们可以直接预处理出 1——i（1<=i<=10万)这个范围内2这个因子的总个数。其实就是类似前缀和，详细看代码。**

**分母是一段连续数的乘法，分子同样也是。我们以tot[i]表示1——i内2这个因子的总个数。**

**【N（N-1）（N-2）（N-3）……（N-K+1）】=tot[n]-tot[n-k]**

**【K（K-1）（K-2）……1】=tot[k]**

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
int x,T,y,n,k,tot[101000],a,b;
inline int read()
{
  int cnt=0,f=1;char ch=getchar();
  while (ch<'0'||ch>'9'){if (ch=='-')f=-1;ch=getchar();}
  while (ch>='0'&&ch<='9'){cnt=cnt*10+ch-48;ch=getchar();}
  return cnt*f;
}
int main()
{
  T=read();
  for (int i=1;i<=100010;i++)
   {
   	x=0;y=i;
   	while (!(y&1)&&y) {y>>=1;x++;}
   	tot[i]=tot[i-1]+x;
   }
  while (T--)
  {
  	n=read();k=read();
  	a=tot[n]-tot[n-k];
  	b=tot[k];
  	if (a>b) puts("0");
  	else puts("1");
  }
  return 0;
}

```

---

## 作者：Edwina (赞：0)

通读题意我们发现，本题是求组合数%2的结果。

可以去学习一下组合数取模方法之一——lucas定理，此处不再证明。

lucas定理是求p为质数情况下的结果，扩展lucas定理是求p不为质数的情况（需要运用到中国剩余定理）。

lucas定理运用到此题中，即为使p==2，套模板即可。

’‘’

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const int N=1000009;
ll f[N];
void init(int p)//f[n] = n!
{
    f[0]=1;
    for (int i=1; i<=p; ++i) 
        f[i]=f[i-1]*i%p;
}
ll poww(ll a,ll r,ll p)
{
    ll res=1;
    while(r>0)
    {
        if(r%2==1)
            res=(res*a)%p;
        r/=2;
        a=a*a%p;
    }
    return res;
}
ll lucas(ll n,ll k,ll p)//C(n,k)%p
{
    ll res=1;
    while(n&&k)
    {
        ll nn=n%p;
        ll kk=k%p;
        if(nn<kk)
            return 0;//inv (f[kk])=f[kk]^(p-2)%p
        res=res*f[nn]*poww(f[kk]*f[nn-kk]%p,p-2,p)%p;
        n/=p,k/=p;
    }
    return res;
}
int main()
{
    int t,n,k;
    init(2);//init(p)
    cin>>t;
    while(t--)
    {
        cin>>n>>k;
        cout<<lucas(n,k,2)<<endl;
    }
    return 0;
}
‘’‘
```

---

## 作者：AmamiyaUmi (赞：0)

根据lucas定理，设p为质数，则

C(n, k) ≡ C(n/p, k/p)\*C(n%p, k%p) (mod p)

只需要p = 2就行了

时间复杂度O(tlog2n)

```cpp
#include<stdio.h>

int c[2][2], n, t, k;

int ans(int a, int b) {
    if (a < 2 && b < 2) return c[a][b];
        //0*任何数=0
    if (!ans(a%2, b%2)) return 0;
    //lucas求余数 
    return ans(a/2, b/2)*ans(a%2, b%2);
}

int main() {
    //初始化c(0, 0)~c(1, 1) 
    c[0][0] = 1;
    c[0][1] = 0;
    c[1][0] = 1;
    c[1][1] = 1;
    scanf("%d", &t);
    while (t--) {
        scanf("%d%d", &n, &k);
        printf("%d\n", ans(n, k));
    }
    return 0;
}
http://www.neptuuz.com/wordpress/?p=83

```

---

## 作者：Genius (赞：0)

先上代码：

```delphi

program L_1869;
var
i,t,n,k:longint;

begin
readln(t);
for i:=1 to t do begin
readln(n,k);
if n and k=k then writeln(1) ELSE writeln(0);
end;
end.

```
证明：

利用数学归纳法：

由C(n,k) = C(n,k-1) + C(n-1,k-1);

对应于杨辉三角：

1
1 2 1
1 3 3 1

1 4 6 4 1

………………

可以验证前面几层及k = 0时满足结论，下面证明在C(n-1,k)和C(n-1,k-1) (k > 0) 满足结论的情况下，

  C(n,k)满足结论。

1).假设C(n-1,k)和C(n-1,k-1)为奇数：

则有：(n-1)&k == k;

  (n-1)&(k-1) == k-1;

由于k和k-1的最后一位(在这里的位指的是二进制的位，下同)必然是不同的，所以n-1的最后一位必然是1。

现假设n&k == k。

则同样因为n-1和n的最后一位不同推出k的最后一位是1。

因为n-1的最后一位是1，则n的最后一位是0，所以n&k != k，与假设矛盾。

所以得n&k != k。

2).假设C(n-1,k)和C(n-1,k-1)为偶数：

则有：(n-1)&k != k;

  (n-1)&(k-1) != k-1;

现假设n&k == k.

则对于k最后一位为1的情况：

此时n最后一位也为1，所以有(n-1)&(k-1) == k-1，与假设矛盾。

而对于k最后一位为0的情况：

则k的末尾必有一部分形如：10; 代表任意个0。

相应的，n对应的部分为： 1{\*}\*; \*代表0或1。

而若n对应的{\*}\*中只要有一个为1，则(n-1)&k == k成立，所以n对应部分也应该是10。

则相应的，k-1和n-1的末尾部分均为01,所以(n-1)&(k-1) == k-1 成立，与假设矛盾。

所以得n&k != k。

由1)和2)得出当C(n,k)是偶数时，n&k != k。

3).假设C(n-1,k)为奇数而C(n-1,k-1)为偶数：

则有：(n-1)&k == k;

  (n-1)&(k-1) != k-1;

显然，k的最后一位只能是0，否则由(n-1)&k == k即可推出(n-1)&(k-1) == k-1。

所以k的末尾必有一部分形如：10;

相应的，n-1的对应部分为： 1{\*}\*;

相应的，k-1的对应部分为： 01;

则若要使得(n-1)&(k-1) != k-1 则要求n-1对应的{\*}\*中至少有一个是0.

所以n的对应部分也就为 ： 1{\*}\*; (不会因为进位变1为0)

所以 n&k = k。

4).假设C(n-1,k)为偶数而C(n-1,k-1)为奇数：

则有：(n-1)&k != k;

  (n-1)&(k-1) == k-1;

分两种情况：

当k-1的最后一位为0时:

则k-1的末尾必有一部分形如: 10;

相应的，k的对应部分为 : 11;

相应的，n-1的对应部分为 : 1{\*}0; (若为1{\*}1,则(n-1)&k == k)

相应的，n的对应部分为 : 1{\*}1;

所以n&k = k。

当k-1的最后一位为1时:

则k-1的末尾必有一部分形如: 01; (前面的0可以是附加上去的)

相应的，k的对应部分为 : 10;

相应的，n-1的对应部分为 : 01; (若为11，则(n-1)&k == k)

相应的，n的对应部分为 : 10;

所以n&k = k。

由3),4)得出当C(n,k)为奇数时，n&k = k。

综上，结论得证!

看了这么久，惊呆了吧？这当然不是我写的！

参考[color=grey]复制[/color]资料:http://zhidao.baidu.com/link?url=V173fxWnv17fxATo69GqV8etT92XJJ0GqSpjgzP7l3qgKQ5\_C3JhdYCERkRguSeuNK2v2bZlp9mQXHL-wm5iIK


---


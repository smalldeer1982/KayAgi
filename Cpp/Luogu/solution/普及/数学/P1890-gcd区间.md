# gcd区间

## 题目描述

给定 $n$ 个正整数 $a_1,a_2,\dots,a_n$。

$m$ 次询问，每次询问给定一个区间 $[l,r]$，输出 $a_l,a_{l+1},\dots,a_r$ 的最大公因数。

## 说明/提示

- 对于 $30\%$ 的数据，$1\leq n \leq 100$，$1\leq m \leq 10$；  
- 对于 $60\%$ 的数据，$1\leq m \leq 1000$；
- 对于 $100\%$ 的数据，$1 \leq l \leq r \leq n \leq 1000$，$1\leq m \leq 10^6$，$1 \leq a_i \leq 10^9$。


## 样例 #1

### 输入

```
5 3
4 12 3 6 7
1 3
2 3
5 5
```

### 输出

```
1
3
7
```

# 题解

## 作者：da32s1da (赞：57)

运用动规的思想，$f[i][j]$表示区间$(i,j)$中$gcd$，则状态转移方程为

$f[i][j]=gcd(f[i][i],f[i+1][j])$

边界$f[i][i]=itself$，另外$c++$中有自带$gcd:$__gcd(x,y)

```
#include<bits/stdc++.h>
using namespace std;
long long a,b,f[1001][1001],p,q;
int main(){
    scanf("%lld%lld",&a,&b);
    for(int i=1;i<=a;i++) scanf("%lld",&f[i][i]);
    for(int i=a-1;i>=1;i--)
    for(int j=i+1;j<=a;j++)
    f[i][j]=__gcd(f[i][i],f[i+1][j]);
    for(int i=1;i<=b;i++)
    scanf("%lld%lld",&p,&q),
    printf("%lld\n",f[p][q]);
}
```

---

## 作者：pengym (赞：25)

##.
跳题的时候看到这道题，看到**有区间求gcd**的操作，第一反应就是打一个线段树去维护区间gcd。于是就直接开始打了，就是两个线段树的基本操作。看到题解楼下没有C++打线段树的大佬，于是蒟蒻我来发一篇题解（~~QAQ~~）

##.
```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 1100
#define Mid ((l+r)>>1)
#define lson rt<<1,l,Mid
#define rson rt<<1|1,Mid+1,r
using namespace std;
inline void read(int &x)
{
    x=0;
    int p=1;
    char c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
    x*=p;
}
int n,m;
int a[N<<2];
void build(int rt,int l,int r)
{
    if(l==r)
    {
        read(a[rt]);
        return;
    }
    else
    {
        build(lson);
        build(rson);
        a[rt]=__gcd(a[rt<<1],a[rt<<1|1]);
    }
}
int query(int rt,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)
    {
        return a[rt];
    }
    else
    {
        int tmp=0;
        if(L<=Mid)tmp=query(lson,L,R);
        if(R>Mid)tmp=__gcd(tmp,query(rson,L,R));
        return tmp;
    }
}
int main()
{
    read(n);read(m);
    build(1,1,n);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        read(x);read(y);
        printf("%d\n",query(1,1,n,x,y));
    }
    return 0;
}

```

---

## 作者：Timothy (赞：16)

来一个短小精悍，有跑得快的方法——ST表

f[i][j]表示从i开始后2^i个数的gcd

bin[i]表示2^i

LOG[i]表示i以2为底的对数

f[j][i]直接从gcd(f[j][i-1],f[j+bin[i-1]][i-1])更新就行了

综上，O(nlogn）预处理，O(1）回答询问，时间上是很优的，可以跑大数据

【代码】

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
using namespace std;
const int N=1005;
int LOG[N],bin[15],n,m,a[N],x,y;
int f[N][10];
int gcd(int i,int j)
{
    return !j?i:gcd(j,i%j);
}
int main ()
{
    scanf ("%d%d",&n,&m);
    bin[0]=1;for (int i=1;i<=10;++i)bin[i]=bin[i-1]<<1;
    LOG[0]=-1;for (int i=1;i<=n;++i)LOG[i]=LOG[i>>1]+1;
    for (int i=1;i<=n;++i)scanf ("%d",&f[i][0]);
    for (int i=1;i<=10;++i)
        for (int j=1;j+bin[i]-1<=n;++j)
            f[j][i]=gcd(f[j][i-1],f[j+bin[i-1]][i-1]);
    for (int i=1;i<=m;++i)
    {
        scanf ("%d%d",&x,&y);
        int lo=LOG[y-x+1];
        printf ("%d\n",gcd(f[x][lo],f[y-bin[lo]+1][lo]));//防止不是2的正整数幂时没有包括到
    }
    return 0;
}
P.S.log不要用C++带的，大数据可能会被卡常
```

---

## 作者：Parabola (赞：15)

恩我来水水

不知道能不能过啊QAQ

恩n>1000

数据有点水了

我们要保证的只是o（1）查询

预处理o（n^2）都能过

恩但我还是打了一个st表空间时间预处理都是nlogn

有人问我为什么不打递推

递推又不好打又难理解

记忆化搜索了解一下

打的舒服也不会太慢

我的代码里有注释

然后重点来了！

看看我两份代码

对cout过于依赖的同学小心了

[cout](https://www.luogu.org/record/show?rid=7268264)

[printf](https://www.luogu.org/record/show?rid=7268306)

两份代码差了600ms！

放弃cout吧。

我知道你们在想啥

关同步也解决不了差距

---

## 作者：萌新天行健 (赞：7)

此题巨水！！！

不用线段树（logm询问不划算）！！！

注意到n较小，m较大，考虑O(n\*n)预处理，O(1)询问

gcdn[a][b]表示从a到b的gcd值即可。。。

```cpp
#include<stdio.h>
typedef long long LL;
LL num[1005];
LL gcdn[1005][1005];
LL gcd(LL m,LL n){
    while(n!=0){
        LL t=m%n;
        m=n;
        n=t;}
    return m;}

int main(){
    LL n,m;
    scanf("%lld%lld",&n,&m);
    for(int i=0;i<n;i++)
        scanf("%lld",num+i);
    for(int i=0;i<n;i++){
        gcdn[i][i]=num[i];
        for(int j=i+1;j<n;j++)
            gcdn[i][j]=gcd(gcdn[i][j-1],num[j]);
    }
    for(int i=0;i<m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        if(a<=b)printf("%lld\n",gcdn[a-1][b-1]);
        else printf("%lld\n",gcdn[b-1][a-1]);
    }
    return 0;
}
```

---

## 作者：_Blue_ (赞：5)

题目要求区间内的数的**最大公约数**   
首先我们肯定要有求出**gcd**的方法，这里我们采用 [辗转相除法](https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352&fr=aladdin)  
接下来贴上瞎写的gcd：  
```cpp
int gcd(int x,int y){
    if((!y)||(!x)) return max(x,y);
    return gcd(y,x%y);
}
```
  
求两数的gcd的方法有了，接下来怎么做？  
首先我们很容易想到用**数据结构**来维护：  

---
### 1. 线段树  
首先要知道，线段树可以维护满足**结合律**的计算。  
什么叫结合律呢？这里我们引用百度百科上的话（[结合律）](https://baike.baidu.com/item/%E7%BB%93%E5%90%88%E5%BE%8B/2173834?fr=aladdin):  
>在数学中，结合律(associative laws)是二元运算可以有的一个性质，意指在一个包含有二个以上的可结合运算子的表示式，只要算子的位置没有改变，其运算的顺序就不会对运算出来的值有影响。  
>  
  
例如：1+1+3=（1+3）+1  
显然我们很容易看出，**gcd**是满足结合律的，那么线段树的父亲节点就是维护子节点的**gcd**。  
### code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int gcd(int x,int y){
    if((!y)||(!x)) return max(x,y);
    return gcd(y,x%y);
}
//qwq，代码写丑了
int n,m;
int a[1005],t[4005];
void built(int k,int l,int r){
    if(l==r){
        t[k]=a[l];
        return;
    }
    int mid=l+(r-l>>1);
    built(k<<1  ,l  ,mid);
    built(k<<1|1,mid+1,r);
    t[k]=gcd(t[k<<1],t[k<<1|1]);
}
int query(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y){
		return t[k];
	}
	int tem=0;  
	int mid=l+(r-l>>1);
	if(x<=mid) tem=query(k<<1,l,mid,x,y);
	if(mid<y) tem=gcd(tem,query(k<<1|1,mid+1,r,x,y));
	return tem;
} 
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    built(1,1,n);
    for(int i=1;i<=m;i++){
		int x,y;scanf("%d%d",&x,&y);
		printf("%d\n",query(1,1,n,x,y));
    }
}

```
### 2. 分块  
分块其实是一中**思想**。  
和线段树类似，将大区间划分成多个小区间，查询时整合区间信息即可。  
而且对于本题数据范围，完全跑得开。  
### code:  
```cpp
#include <bits/stdc++.h> 
using namespace std;
int gcd(int x,int y){
    if((!y)||(!x)) return max(x,y);
    return gcd(y,x%y);
}
int block,belong[1005],num,l[1005],r[1005],ggcd[1005];
int n,m,a[1005];
void ins()  //分块
{
    block=(int)sqrt(n);
    num=n/block;
    if(n%block) num++;
    for(int i=1;i<=n;++i)
        belong[i]=(i-1)/block+1;
    for(int i=1;i<=num;++i)
        l[i]=(i-1)*block+1,r[i]=i*block,ggcd[i]=a[l[i]];
    r[num]=n;

    for(int i=1;i<=n;++i)
        if(i!=l[belong[i]])
            ggcd[belong[i]]=gcd(a[i],ggcd[belong[i]]);
}

int query(int x,int y)  //查询操作，整合区间信息
{
    int ans;
    if(belong[x]==belong[y])  //对于单一不完整的块
    {
        ans=a[x];
        for(int i=x+1;i<=y;++i)
        ans=gcd(ans,a[i]);
        return ans;
    }
    else 
    {
        ans=a[x];
        for(int i=x+1;i<=r[belong[x]];++i) ans=gcd(ans,a[i]);
        for(int i=l[belong[y]];i<=y;++i) ans=gcd(ans,a[i]);
        for(int i=belong[x]+1;i<belong[y];++i) ans=gcd(ans,ggcd[i]);
        return ans;
    }
}
int main()
{
    
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    ins();
    for(int i=1;i<=m;i++)
    {
        int x,y; 
		scanf("%d%d",&x,&y);
        printf("%d\n",query(x,y));
    }
}
```  

### 3. ST表  
**ST表**的时间复杂度是要优于线段树的，那么我们为什么要用线段树呢？  
因为它不支持修改。  
不过本题也没有修改的操作，所以我们可以放心使用。  
  
-------------------

**除了这些数据结构，我们就没有别的解法了吗？qwq**  
万物皆可DP嘛  
  

```cpp
//所以我们用f[i][j]表示从i到j这个区间内的数的gcd
//于是我们得到f[i][j]=gcd(a[i],f[i+1][j]);
```  
考虑从后往前推，则:  
```cpp
 for(int i=n-1;i>=1;i--)
    for(int j=i+1;j<=n;j++)
    f[i][j]=gcd(a[i],f[i+1][j]);
    
 //由于f[i][i]==a[i],所以 
 
  for(int i=n-1;i>=1;i--)
    for(int j=i+1;j<=n;j++)
    f[i][j]=gcd(f[i][i],f[i+1][j]);
```
  
### code:  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[1001][1001];
int gcd(int x,int y){
    if((!y)||(!x)) return max(x,y);
    return gcd(y,x%y);
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&f[i][i]);
    for(int i=n-1;i>=1;i--)
    for(int j=i+1;j<=n;j++)
    f[i][j]=gcd(f[i][i],f[i+1][j]);
    for(int i=1;i<=m;i++){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",f[l][r]);
    }
}
```




---

## 作者：bovine__kebi (赞：4)

~~这题方法真多啊(~~

先总结一下几种已经出现了的方法。

1.线段树or树状数组  

这俩是挺经典的求区间的工具，在这里就不多赘述，可以去看别的大佬的题解。

2.dp

对于每个区间可以用$O(n^2)$的复杂度转移出来，然后询问就可以O(1)了，这个方法挺快，但是如果把 $n$ 也提起来，就废了。

3.分块

这个我喜欢，分块是一种优雅的暴力，待会讲我的方法的时候会用到，大概就是把序列分成很多个块，然后每个块预处理一下，最后统计的时候整块算，大概复杂度是 $O(\dfrac{n^2}{S}+mS)$，S是块长。这里的 S 一般取 $\sqrt{n}$。但是在这么大的 $m$ 面前，大概也是会被卡的。

4.ST表

待会也要用到，ST表是一种神奇的方法，不会的可以看 [这里](https://www.luogu.com.cn/problem/P3865),他不仅能处理max/min，甚至可以处理一切有结合律的运算。

然后就是重头戏了：

5.lxl 的 ST 表

~~听起来好高级的亚子，毒瘤劝退~~

这种方法也就是我这题真正要讲的方法，就是分块套ST表，可以在保证空间为线性时，用期望 $O(n+m)$ 的复杂度内求出 ST表 能求出的东西。虽然实际是可以卡到 $O(n+m\sqrt{n})$ 的,但是在用的时候其实跑的挺快，下面步入正题。

我们发现，其实ST表的空间是很大的，比如在1e7这样的数据面前，ST表基本就没了。所以我们考虑优化ST的空间。我们讲序列分成一块一块的，每次只预处理出每个整块的ST，这样我们的空间就降到了 $O(\sqrt{n}log\sqrt{n})$,时间也是一样的。之后对于每个块，我们都可以直接取出答案，复杂度为 $O(1)$  。

其实到这里就可以开始写了,但是我们考虑一个问题，就是两边不完整的块该怎么办。如果暴力求，那么时间复杂度和普通分块是没有两样的，于是我们可以预处理出 **每一块** 的 **前缀gcd** 和 **后缀gcd**,可以参考下面这张图来理解：  

![](http://m.qpic.cn/psc?/V12WWmqX1GuqHd/m*TTJoI3x9iCCJx4ECa9pNcvA5SoPI5hqIHyNVUNfvVzAfUPKGaAXwmop*CYCYkmE9HnR9ZGCgSL7iqiK53n6g!!/mnull&bo=4gbhAwAAAAADByQ!&rf=photolist&t=5)

每个不同的色块表示这个点代表预处理的gcd后缀的区间，前缀也是一样的，这样一来，我们就可以预先用 $O(n)$ 的复杂度预处理出这些前后缀，再 $O(1)$ 查询就OK了。

这个方法可以通过数据随机且 $n=2e7,m=2e7,TL=5.00s,ML=500MB$的题目，也就是[这题](https://www.luogu.com.cn/problem/P3793)。

上代码，上面没看懂的可以看程序：  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
const int maxm=1e6+5;
const int block=50;
int n,m;int p;
inline int gcd(int a,int b)//gcd不解释
{
    while(b^=a^=b^=a%=b);
    return a;
}
int st[block][20],belong[maxn],a[maxn];//ST是ST表，belong是每个点属于的块，a是原序列
int pre[maxn],bk[maxn];//每块的前缀gcd和后缀gcd
int lg[maxn];//预处理log2，用于ST表
inline void init()//ST表的预处理，唯一和普通ST表不一样的地方就是它是到n我是到belong[n]，也就是sqrtn
{
    for(register int i=1;i<=n;i++)st[belong[i]][0]=a[i];
    for(register int i=1;(1<<i)<=p;i++)
    {
        for(register int j=1;j+(1<<i)-1<=p;j++)
        {
            st[j][i]=gcd(st[j][i-1],st[j+(1<<(i-1))][i-1]);
        }
    }
}
inline int query(int l,int r)//询问
{
    int ans=0;
    if(belong[l]==belong[r]){for(int i=l;i<=r;i++)ans=gcd(ans,a[i]);return ans;}//如果在同一个块中，直接暴力找，因为这一块不好预处理，所以这也就是这题为什么会被卡到sqrtn的原因。
    if(belong[r]-belong[l]==1){return gcd(pre[r],bk[l]);}//如果块相差为1，也就是说这个询问的区间可以分为你右端点属于块的前缀，以及左端点属于的块的后缀，可以自己画图理解一下。
    else
    {
        int x=lg[belong[r]-belong[l]-1];
        ans=gcd(st[belong[l]-1][x],st[belong[r]-(1<<x)][x]);
        ans=gcd(ans,gcd(pre[r],bk[l]));
        return ans;
    }//ST表和前后缀的gcd查询，应该是ST表的基本操作。这里唯一不同的就是把原询问的区间的gcd变成了原询问块的gcd。
}
int main()
{
    //听说从主函数开始阅读程序是个好习惯(?)
    int size=50;scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)belong[i]=(i-1)/size+1;
    lg[0]=-1;p=belong[n];
    for(register int i=1;i<=p;i++)lg[i]=lg[i>>1]+1;//处理log
    for(int i=1;i<=n;i++)pre[i]=(i%size^1)?gcd(pre[i-1],a[i]):a[i];//处理前缀，这里看不懂的话可以试着把它写成if，else的形式。
    for(int i=n;i>=1;i--)bk[i]=(i%size)?gcd(bk[i+1],a[i]):a[i];//后缀，和前缀差不多。
    init();//ST表预处理
    //前面是一大堆的预处理
    for(int i=1;i<=m;i++)
    {
        int l,r;scanf("%d %d",&l,&r);
        printf("%d\n",query(l,r));
    }//询问，输出，结束。
}
```
似乎这种方法的延伸性很强，各位大佬们可以下去自己尝试尝试其他的询问区间的题目。

如果还有什么不懂或者错误，可以私信这个蒟蒻。

---

## 作者：Jμdge (赞：3)

一眼线段树，看完数据范围之后发现应该是道 $n^2(log~ n?)$ 水题（然而还是用线段树过掉了）

后来发现跑的飞慢，于是用了 st 表，能用 st 表的原因就是 Gcd 这玩意儿是可以重复累加的，就像  Min 和 Max 那样...


结果发现居然有 0ms 过的，这都是什么神仙啊 woc...


贡献两发题解好了：

# code1

线段树


```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int M=1003;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
	if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,a[M],t[M<<2];
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define lson ls,l,mid
#define rson rs,mid+1,r
int gcd(int x,int y){return y?gcd(y,x%y):x;}
inline void build(int k,int l,int r){
	if(l==r) return t[k]=a[l],void();
	build(ls,l,mid),build(rs,mid+1,r),t[k]=gcd(t[ls],t[rs]);
}
int query(int k,int l,int r,int L,int R){
	if(l>R || r<L) return 0; if(L<=l && r<=R) return t[k];
	return gcd(query(lson,L,R),query(rson,L,R));
}
int main(){ n=read(),m=read();
	fp(i,1,n) a[i]=read();
	build(1,1,n); Rg int l,r;
	while(m--){ l=read(),r=read();
		print(query(1,1,n,l,r));
	} return Ot(),0;
}
```

# code2

st 表

```
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int M=1003;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
	if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
	while(z[++Z]=x%10+48,x/=10);
	while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,g[11][M]; arr a,lg;
int gcd(int x,int y){return y?gcd(y,x%y):x;}
inline int ask(int l,int r){ int k=lg[r-l+1];
	return gcd(g[k][l],g[k][r-(1<<k)+1]);
}
int main(){ n=read(),m=read(); Rg int l,r;
	lg[0]=-1; fp(i,1,n) g[0][i]=read(),lg[i]=lg[i>>1]+1;
	fp(j,1,lg[n]) fp(i,1,n-(1<<j)+1)
		g[j][i]=gcd(g[j-1][i],g[j-1][i+(1<<(j-1))]);
	while(m--){ l=read(),r=read();
		print(ask(l,r));
	} return Ot(),0;
}
```


可能用个 __gcd 还会快一些，然鹅这么做并么有什么意思...


至于 $n^2$ 的代码... 就算了吧





---

## 作者：hsfzLZH1 (赞：3)

首先简单描述一下求两个数的最大公约数的方法：辗转相除法。

设两个数a,b的最大公约数为gcd(a,b)，那么如果a是b的倍数，那么两个数的最大公约数一定是b，否则gcd(a,b)=gcd(b,a%b)。

由于b<a%b，所以最后的a<b,b<a%b，gcd的参数值一定越来越小，最终总是会求出结果，时间复杂度为O(lg min(a,b))。

## 60分解法

读入并存储a数组，然后对于每次查询操作，进行从前往后的扫，输出这些数的gcd，这里用到了一个性质：gcd(gcd(a,b),c)=gcd(a,gcd(b,c))，时间复杂度O(mnlg n)，期望得分60分。

## 100分解法

使用ST表和RMQ算法。

定义f[i][j]表示从a数组的第i个元素开始的2^j的元素的gcd，那么有

f[i][j]=gcd(f[i][j-1],f[i+2^(j-1)][j-1])

因为gcd有特殊的性质：gcd(x,x)=x

利用这一性质，则定义rmq(l,r)为a[l]到a[r]的gcd，那么

rmq(l,r)=gcd(f[l][k],f[r-(2^k)+1][k])

这里重复覆盖了一个区间[r-(2^k)+1,l+(2^k)]

使用此种方法可以保证查询区间内的每一个数字都被覆盖到并且不会和查询到区间外的元素。

此处k=lg2(r-l+1)

因为gcd具有可重复性，所以我们可以用O(nlg n^2)的时间进行预处理而在O(lg n)的时间内完成查询操作。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1010;
typedef long long ll;
inline ll gcd(ll x,ll y){if(x==0||y==0)return 0;return x%y?gcd(y,x%y):y;}//需要特判两元素中有0的情况
ll n,m,f[maxn][10],lg[maxn],k,x,y;
inline ll rmq(ll l,ll r)//查询操作
{
    k=lg[r-l+1];
    return gcd(f[l][k],f[r-(1<<k)+1][k]);
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(register ll i=1;i<=n;i++)lg[i]=lg[i-1]+(1<<lg[i-1]+1==i);//打log的表
    for(register ll i=1;i<=n;i++)scanf("%lld",f[i]);//f[i][0]=a[i]
    for(register ll i=1;i<=lg[n];i++)for(register ll j=1;j+(1<<i)-1<=n;j++)f[j][i]=gcd(f[j][i-1],f[j+(1<<(i-1))][i-1]);//打ST表
    while(m--)scanf("%lld%lld",&x,&y),printf("%lld\n",rmq(x,y));//查询
    return 0;
}
```
归纳一下使用RMQ的条件：

1.查询函数具有可重复性，即f(x,x)=x，例如min(),max(),gcd(),lcm(),而sum()之类就不行。

2.可以在短时间复杂度内解决求f()的值，方便打ST表。


---

## 作者：Yeji_ (赞：3)

#### 前言
这道题虽然有大佬已经讲解了，

但是，对RMQ的具体操作，如果我没学过，看了看题解，那么我还是不会做的（~~可能是我太弱了~~）


### 题意

很清晰了，就是求一个区间内的gcd，没什么可说的

### RMQ的作用

RMQ指的是求一个区间的某个数值（例如：最大值，最小值......)（也如本道题的gcd）

### 实现

#### 预处理

设a[i]a[i]是要求区间最值的数列，F[i, j]F[i,j]表示从第i个数起连续2^j个数中的最大值。（DP的状态）

例如： a数列为：3 2 4 5 6 8 1 2 9 7

F[1，0]表示第1个数起，长度为2^0=1的最大值，其实就是3这个数。

	同理 F[1,1]=max(3,2)=3,F[1，2]=max(3,2,4,5) = 5 F[1，3] = max(3,2,4,5,6,8,1,2) = 8;

并且我们可以容易的看出F[i,0]就等于a[i]。（DP的初始值）

我们把F[i，j]平均分成两段（因为F[i，j]一定是偶数个数字）， 从 i 到i + 2 ^ (j - 1) - 1为一段，i + 2 ^ (j - 1)到i + 2 ^ j - 1为一段(长度都为2 ^ (j - 1))。

于是我们得到了状态转移方程F[i, j]F[i,j]=$max（F[ij-1],F[i+2^(j-1)，j-1]）$。

#### 查询

假如我们需要查询的区间为(i,j)，

那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j) 的最小幂（可以重复，比如查询1，2，3，4，5，我们可以查询1234和2345）。

因为这个区间的长度为j - i + 1,所以我们可以取 k=log( j - i + 1)(以2为底）

则有：RMQ(i, j)=max{F[i , k], F[ j - 2 ^ k + 1, k]}。

#### 注意：此处的max，为这个区间的最大值，若遇到不同的情况，那么可以更改，如求最小用min，求gcd就用gcd了。
```cpp
void work(int n) 
{
    for (int i=1;i<=n;i++) f[i][0]=a[i];
    for (int j=1;(1<<j)<=n;j++) 
        for (int i=1;i+(1<<j)-1<=n;i++) 
            f[i][j]=gcd(f[i][j-1],f[i+(1<<(j-1))][j - 1]);
}
int RMQ(int l, int r) 
{
    int k=0;
    while ((1<<(k+1))<=r-l+1)
         k++;
    return gcd(f[l][k],f[r-(1<<k)+1][k]);
}
```

那么这道题，求gcd就迎刃而解了，给出全部代码
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define re register
using namespace std;
int a[2000],dp[2000][20];
int gcd(int a,int b)
{
    if (b==0)
        return a;
    gcd(b,a%b);
}
void work(int n) 
{
    for (int i=1;i<=n;i++) 
        dp[i][0]=a[i];
    for (int j=1;(1<<j)<=n;j++) 
        for ( int i=1;i+(1<<j)-1<=n;i++) 
            dp[i][j]=gcd(dp[i][j-1],dp[i+(1<<(j-1))][j - 1]);
}
int RMQ(int l, int r) 
{
    re int k=0;
    while ((1<<(k+1))<=r-l+1)
         k++;
    return gcd(dp[l][k],dp[r-(1<<k)+1][k]);
}
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    work(n);
    for (int i=1;i<=m;i++)
    {
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",RMQ(l,r));
    }
}

```

$register$为常数优化，可以全部省略


---

## 作者：doctorZ_ (赞：3)

其实这道题可以用RMQ来做


------------
RMQ（Range Minimum/Maximum Query），即区间最值查询，这是一种在线算法，所谓在线算法，是指用户每次输入一个查询，便马上处理一个查询。RMQ算法一般用较长时间做预处理，时间复杂度为O(nlogn)，然后可以在O（1）的时间内处理每次查询。
    
RMQ其实是一种求区间最值的算法，但是其实也可以用来求区间gcd    
下面我们从一个实际问题来解释RMQ

我们假设数组arr为：1，3，6，7，4，2，5

我们设二维数组dp[i][j]表示从第i位开始连续2^j个数中的gcd。例如dp[2][1]就表示从第二位数开始连续两个数的gcd（也就是从第二位数到第三位数的gcd），即3，6中的gcd，所以dp[2][1] = 3;

其实我们求 dp[i][j] 的时候可以把它分成两部分，第一部分是从 i 到 i + 2 ^( j-1 ) - 1 ，第二部分从 i + 2 ^( j-1 ) 到i + 2^j -1 ，为什么可以这么分呢？其实我们都知道二进制数前一个数是后一个的两倍，那么可以把 i ~ i + 2^j -1 这个区间 通过2^(j-1) 分成相等的两部分， 那么转移方程很容易就写出来了。（dp[i][0]就表示本身）

### dp[i][j] = gcd(dp [i][j - 1], dp [i + (1 << j - 1)][j - 1])

于是就有了下面的一行代码
```cpp
for(int j=1;(1<<j)<=n;j++)
	for(int i=1;i+(1<<j)-1<=n;i++)
		dp[i][j]=gcd(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
```

下面我们就来讲一下RMQ的查询      
如果，我们要求l~r区间的gcd的话,那么设k=log2(r-l+1),则     
l~r区间的gcd等于gcd(dp[l][k], dp[r - (1 << k) + 1][k]);
于是给出查询代码
```cpp
int rmq(int l,int r)
{
	int k=log2(r-l+1);
	return gcd(dp[l][k],dp[r-(1<<k)+1][k]);
}
```
下面就是完整代码啦
```cpp
#include<cstdio>
#define N 1000
using namespace std;
int gcd(int a,int b)
{
	if(b==0)
		return a;
	return gcd(b,a%b);
}
int n,m;
int dp[N+1][11],lg[N+1],arr[N+1];//lg[i]表示log2(i)的值 
int rmq(int l,int r)
{
	int k=lg[r-l+1];
	return gcd(dp[l][k],dp[r-(1<<k)+1][k]);
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&dp[i][0]);
	for(int j=1;(1<<j)<=n;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			dp[i][j]=gcd(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
	for(int i=1;i<=n;i++)//先把log2(i)求出来，会快 
		lg[i]=lg[i-1]+(1<<(lg[i-1]+1)==i);
	for(int i=1;i<=m;i++)
	{
		int l,r;
		scanf("%d %d",&l,&r);
		printf("%d\n",rmq(l,r));
	}
	return 0;
}
```




---

## 作者：嘉年华 (赞：1)

# **分块**
这道题其实是道水题（~~我做了一个中午~~）。
首先，我们发现这道题是一个区间查询问题，所以我们自然就想到了各种区间算法。
但是这道题的n很小，而m很大，又不带修改，如果我们用线段树来做这道题查询是O(log n),而分块则是O(sqrt(n)),在n=1000的情况下，两者相差只有约4倍，可以当做是常数级别的差异，而且线段树还要O(nlog n)，前几个点还不一定比分块快，所以我们可以轻松愉快的用分块算法快速解决这个问题了。
AC代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define qj 40

int n,m,L,R,ans;
int a[1010],q[(1010/qj)+10];
int maxn=0,tt=0;

inline int read_(void)
{
	int num=0,f=1;
	char ch=getchar();
	while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
	if(ch=='-') ch=getchar(),f=-1;
	while(ch>='0'&&ch<='9') num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return f*num;
}

inline int gcd(int x,int y)
{
	if(min(x,y)==0) return max(x,y);
	return gcd((max(x,y)%min(x,y)),min(x,y));
}

inline void print(int num)
{
	if(num<0)
	{
		putchar('-');
		num=abs(num);
	}
	if(num==0) return;
	int f=num%10;
	print(num/10);
	putchar(f+'0');
	return;
}

int main(void)
{
	n=read_(),m=read_();
	for(int i=1;i<=n;i++) a[i]=read_();
	for(int l=1;l*qj<n;++l)
	{
		q[l]=a[(l-1)*qj+1];
		for(int i=(l-1)*qj+2;i<=l*qj;++i) q[l]=gcd(q[l],a[i]);
	}
	while(m--)
	{
		L=read_(),R=read_();
		int st=L/qj+2,en=R/qj;
		ans=a[L];
		for(int i=st;i<=en;++i) ans=gcd(ans,q[i]);
		for(int i=L;i<=min((st-1)*qj,R);++i) ans=gcd(ans,a[i]);
		for(int i=max(L,en*qj+1);i<=R;++i) ans=gcd(ans,a[i]);
		print(ans);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：Skywalker_David (赞：1)

思路

我们可以用区间维护的方法：如果区间内只有自己，那么GCD就是自己；如果区间内是相邻的两个数，就可以用扩展欧几里德定理；如果区间是不相邻的两个数，那么f[i,j]:=gcd(f[i-1,j],a[j])。然后线上询问处理，时间复杂度O(n^2).


  
  
```cpp
var 
    f:array[1..1000,1..1000] of longint;  
    a:array[1..1000] of longint;  
    i,j,n,m,x,y:longint;  
function gcd(x,y:longint):longint;  
begin  
    if y=0 then begin  
        gcd:=x;  
        exit;  
    end;  
    gcd:=gcd(y,x mod y);  
end;  
begin  
    fillchar(f,sizeof(f),0);  
    readln(n,m);  
    for i:=1 to n do 
        read(a[i]);  
    for i:=1 to n do 
        f[i,i]:=a[i];  
    for i:=1 to n do  
        for j:=i+1 to n do begin  
            if j-i=1 then f[i,j]:=gcd(a[i],a[j])  
                else f[i,j]:=gcd(a[j],f[i,j-1]);  
        end;  
    for i:=1 to m do begin  
        readln(x,y);  
        writeln(f[x,y]);  
    end;  
end.
```

---

## 作者：BreakPlus (赞：0)

虽然数据量很小，但我为了练习就用了线段树 qaq。

## Part 0 什么是线段树

[不懂线段树的同学看这里](https://oi-wiki.org/ds/seg/)

## Part 1 线段树的建立

对于这题，我们可以让线段树存储**一个区间内数的 $\gcd$**

由于一个区间内数的 $\gcd$ 等于：
$\gcd( \text{左子树存储的值 ,右子树存储的值} )$，

那么我们的 ``pushup`` 函数就是这个样子了：

```cpp
void pushup(int p)
{
    d[p]=gcd(d[p*2],d[p*2+1]);
}
```

建树的代码是这样的：

```cpp
void build(int l,int r,int p)
{
    if(l==r)
    {
        d[p]=a[l];
        return;
    }//如果搜索到了叶子节点直接返回
    int mid=(l+r)/2;
    if(l<=mid) build(l,mid,p*2);//如果存在左子树
    if(mid<r) build(mid+1,r,p*2+1);//如果存在右子树
    pushup(p);//pushup函数
}
```

## Part 2 区间查询

很幸运这题没有修改。

对于整个数列，先设置 $l,r$ 分别等于 $1,n$ ,

递归内容如下：

如果 $l,r$ 包含在要查询的区间里，那么返回当前节点的值；

如果查询的区间在 $l,r$ 的左子树，就返回左子树递归得出的值；

如果查询的区间在 $l,r$ 的右子树，就返回右子树递归得出的值；

如果左子树和右子树都有，那么返回：
$\gcd(\text{左子树得出的值,右子树得出的值})$。

比较好理解吧！

代码如下：

```cpp
int answer(int l,int r,int s,int t,int p)
{
    if(l<=s&&t<=r) return d[p];
    else
    {
        int mid=(s+t)/2;
        if(l<=mid&&(!(r>mid))) return answer(l,r,s,mid,p*2);
        else if((!(l<=mid))&&r>mid) return answer(l,r,mid+1,t,p*2+1);
        else if(l<=mid&&r>mid) return gcd(answer(l,r,s,mid,p*2),answer(l,r,mid+1,t,p*2+1));
    }
}
```
如果需要询问的区间为 $\left[ x,y\right]$，询问的时候调用 $\operatorname{answer}(1,n,x,y,1)$即可。

## Part 3 整合函数

接下来就是调用函数了。主程序：

```cpp
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    build(1,n,1);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        printf("%d\n",answer(x,y,1,n,1));
    }
    return 0;
} 
```

这是我 AC 的第二道线段树题，这篇博客算是留个纪念吧 QAQ。

---

## 作者：PersistentLife (赞：0)

### 前置芝士

最大公约数及其性质，DP 基础。

### $1$ 最大公约数

最大公约数，又称 $\gcd$，即两个数共有的约数中最大的一个，下面是 $\gcd$ 的求法。

#### $1.1$ 枚举法

我们可以从大到小枚举，找到了就退出循环，因为 $\gcd(i,j) \le \min(i,j)$，所以从 $\min(i,j)$ 开始枚举就行了。

```cpp
int gcd(int x,int y)
{
	if(x>y) swap(x,y);
	for(int i=x;i>=1;i--) 
		if(x%i==0&&y%i==0) return i;
} 
```
但是这种求法的复杂度很高，这题是过不了的。

#### $1.2$ 欧几里得算法

该算法又称“辗转相除法”，是求 $\gcd$ 的一种比较高效的算法。

假设我们要求 $\gcd(i,j)$，如果 $i \% j = 0$，那么 $j$ 就是最大公约数，否则最大公约数是 $\gcd(j,i \% j)$，所以我们可以用递归实现。

如果 $i$ 小于 $j$ 也没关系，因为第一次递归可以把两个数交换，详见下表求 $\gcd(15,39)$ 的过程。

| 递归层数 | $i$ | $j$ | $i \% j$ | 目前的结果 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $15$ | $39$ | $15$ | $\gcd(39,15)$ |
| $2$ | $39$ | $15$ | $9$ | $\gcd(15,9)$ |
| $3$ | $15$ | $9$ | $6$ | $\gcd(9,6)$ |
| $4$ | $9$ | $6$ | $3$ | $\gcd(6,3)$ |
| $5$ | $6$ | $3$ | $0$ | $3$ |

上代码！

```cpp
int gcd(int x,int y)
{
	if(x%y==0) return y;
	else return gcd(y,x%y);
} 
```
#### $1.3$ 编译器内置 $\gcd$

`__gcd(i,j)` 返回的就是 $\gcd(i,j)$，注意有两个 `_` ，包括 `__int128` 也是。

**最最最最最最重要的一点，NOIP 尽量不要用以下划线开头的内置函数！！！**

### $2$ DP基础

DP 是动态规划，具体有如下几个步骤，我们以本题为例：

- 设立状态，这里我们让 $dp_{i,j}$ 表示区间 $i,j$ 的最大公约数。

- 找转移方程：

因为 $a_1,a_2,a_3,.....,a_n$ 的 $\gcd$ 等于 $\gcd(a_1,a_2,a_3,.....,a_{n-1},a_n)$。

所以 $dp_{i,j}=\gcd(dp_{i,j-1},a_j)$。

- 实现代码，具体见下面。

### $3$ 代码实现

$ans$ 数组表示 $dp$，其余变量和数组的名称同题面。

一个小小的数学知识：$\gcd(1,x)$ $(x \le 1)$ $=$ $1$。

所以在找到 $1$ 时直接 `break` 就行啦，否则会 TLE。

因为 c++ 全局变量初始值为 $0$ 所以输出时要进行特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1234],ans[1234][1234];
signed main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		ans[i][i]=a[i];
		for(int j=i+1;j<=n;j++)
		{
			ans[i][j]=__gcd(ans[i][j-1],a[j]);
			if(ans[i][j]==1) break;
		}
	}
	for(int i=1;i<=m;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",ans[l][r]==0?1:ans[l][r]);
	}
	return 0;
}
```


---

## 作者：Na2PtCl6 (赞：0)

## 分析题目
### 解法
这是一个区间查询问题，仔细分析后，我们发现可以用线段树解决， **只要在每个节点上存当前区间的gcd**即可。

### 证明
怎么证明它的正确性呢？我们知道线段树求区间gcd是两个两个数求的，可一个区间中不止两个元素，那岂不是很玄？

有结论：
$gcd(a,b,c,d)=gcd(gcd(a,b),gcd(c,d))$
$gcd(a,b,c)=gcd(gcd(a,b),c)$
(gcd()为求一些数的最小公倍数的函数)

我们把这个结论叫做gcd的结合律（又在瞎编）。显然，它在操作数多于四个时仍然成立。

有了以上的结论，我们就可以大胆地使用线段树解决本题了
## 代码
### 建树
```cpp
//左端，右端，当前节点
void build(int l,int r,int node){
	if(l==r){ 
		tree[node]=arr[l]; 
		return ;
	}
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	build(l,mid,lnode);
	build(mid+1,r,rnode); 
	tree[node]=gcd(tree[lnode],tree[rnode]);
}
```

### 查询
```cpp
//左端，右端，当前节点（便于递归），要找的区间的左端，右端
int query(int l,int r,int node,int start,int end){
	//如果不在查找范围,返回0。因为gcd(0,n)=n,所以不影响正常结果 
	if(end<l||start>r)
		return 0;
	if(start<=l&&r<=end)
		return tree[node];
	if(l==r)
		return tree[node];
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1,rnode=(node<<1)+2;
	int lgcd=query(l,mid,lnode,start,end);
	int rgcd=query(mid+1,r,rnode,start,end);
   //gcd有“结合律”，所以不必担心会出错
	return gcd(lgcd,rgcd);
}
```

### 完整代码
```cpp
#include<cstdio>
using namespace std;
int n,m,arr[1004],tree[4016];

int gcd(int a,int b){
	return !b?a:gcd(b,a%b);
}

void read(int &x){
	char c=getchar();x=0;
	for(;c<'0'||c>'9';c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c^48);
}

void build(int l,int r,int node){
	if(l==r){ 
		tree[node]=arr[l]; 
		return ;
	}
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	build(l,mid,lnode);
	build(mid+1,r,rnode); 
	tree[node]=gcd(tree[lnode],tree[rnode]);
}

int query(int l,int r,int node,int start,int end){
	//如果不在查找范围,返回0。因为gcd(0,n)=n,所以不影响正常结果 
	if(end<l||start>r)
		return 0;
	if(start<=l&&r<=end)
		return tree[node];
	if(l==r)
		return tree[node];
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1,rnode=(node<<1)+2;
	int lgcd=query(l,mid,lnode,start,end);
	int rgcd=query(mid+1,r,rnode,start,end);
	return gcd(lgcd,rgcd);
}

int main(){
	read(n),read(m);
	for(int i=0;i<n;i++)
		read(arr[i]);
	build(0,n-1,0);
	int L,R;
	while(m--){
		read(L),read(R);
		printf("%d\n",query(0,n-1,0,L-1,R-1));
	}
	return 0;
}
```
### 拓展
如果题目要求我们对某个数字进行单点修改，改怎么维护？
```cpp
void update(int l,int r,int node,int ind,int v){
	if(l==r){
		arr[ind]=v;
		tree[node]=v;
		return ;
	}
	int mid=l+r>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	if(ind>=l&&ind<=mid)//如果在左边，向左分支搜索 
		update(l,mid,lnode,ind,v);
	else//在右边，向右分支搜索 
		update(mid+1,r,rnode,ind,v);
	tree[node]=gcd(tree[lnode],tree[rnode]);//重新维护 
}
```

---

## 作者：Paranoid丶离殇 (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Paranoid-LS/p/11582701.html)

这里提供一种结构体指针线段树的写法：

做这道题，你首先要知道$gcd$的求法，由欧几里得算法可知：

```cpp
int gcd(int x, int y) { return y == 0 ? x : gcd(y, x % y); }
```

其次，$gcd$满足区间可加性，即：
$$
gcd(l, r) = gcd(gcd(l, k), gcd(k+1, r)),k\in[l, r]
$$
线段树直接维护即可...

code:

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int read() {
	int x = 0, f = 1; char ch;
	while(! isdigit(ch = getchar())) (ch == '-') && (f = -f);
	for(x = ch^48; isdigit(ch = getchar()); x = (x<<3) + (x<<1) + (ch^48));
	return x * f;
}
int n, m;
inline int gcdd(int x, int y) { return y == 0 ? x : gcdd(y, x % y); }
struct Segment {
	struct node {
		int l, r, gc;
		node* ch[2];
		node(int l, int r, int gc) : l(l), r(r), gc(gc) {}
		inline int mid() { return (l + r) >> 1; }
		inline void up() { gc = gcdd(ch[0]->gc, ch[1]->gc); }
	} *root;
	void build(node *&o, int l, int r) {
		o = new node (l, r, 0);
		if(l == r) { o->gc = read(); return; }
		build(o->ch[0], l, o->mid());
		build(o->ch[1], o->mid()+1, r);
		o->up();
	}
	int query(node *o, int l, int r) {
		if(l <= o->l && o->r <= r) return o->gc;
		int res = 0;
		if(o->mid() >= l) res = query(o->ch[0], l, r);
		if(o->mid() < r) res = gcdd(res, query(o->ch[1], l, r));
		return res;
	}
} tr;
int main() {
	n = read(); m = read();
	tr.build(tr.root, 1, n);
	for(int i = 1, l, r; i <= m; ++ i) {
		l = read(); r =  read();
		printf("%d\n", tr.query(tr.root, l, r));
	}
	return 0;
}
```

---

## 作者：fzj2007 (赞：0)

# 本蒟蒻第三篇题解~

刚开始看到这道题，想用模拟直接过，为了优化代码（~~一点必要都没有~~），写了一个快速读入:
```
int read(){
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1;
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
```
还挺好用的，~~复制也挺方便~~

不过 还是建议大家自己写，不要复制（~~说了和没说一样~~）

好了，开始说正题：

gcd函数大家都会写吧

```
int gcd(int b,int c){
	if(b==0) return c;
	return gcd(c%b,b);
}
```

缩进版

```
int gcd(int x,int y){
	return x==0?y:gcd(y%x,x);
}
//最短的啦吧
```

寻找a-b区间内最大公因数
```
int gcdp(int u,int v){
	for(int i=u;i<v;i++){
		p[i]=gcd(p[i],p[i+1]);
	}
	v--;
	if(v!=1) return gcdp(1,v);
	else return p[1];
} 
```

两个递归

下面 你们最喜欢的时刻到了 代码
```
#include<bits/stdc++.h>

using namespace std;
  //数组不想解释
int n,m,a[1001],p[1001],top=0;
//最大公因数查找
int gcd(int b,int c){
	if(b==0) return c;
	return gcd(c%b,b);
}
  //寻找u-v最大公因数
int gcdp(int u,int v){
	for(int i=u;i<v;i++){
                          //查找
		p[i]=gcd(p[i],p[i+1]);
	}
                          //长度减1
	v--;
                          //如果是1 直接返回就行了
	if(v!=1) return gcdp(1,v);
	else return p[1];
} 
                          //快速读入233
int read(){
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1;
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
} 
int main(){
                         //读入不解释（直接读入）
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
                          //每一轮都要清空 不然数据会……
		memset(p,0,sizeof(p));
		top=0;
                          //先赋值
		for(int i=x;i<=y;i++) p[++top]=a[i];
  //没有快速输出 printf也行
		printf("%d\n",gcdp(1,top));
	}
	return 0;
}
```

但是 被卡住了TLE了4个。。
中间时间复杂度太多，

对于100%的数据，1 <= n <= 1000，1 <= m <= 1,000,000

数据还巨大。。。

翻了一下题解，都是动态规划，~~而我普及组还没有考~~

好吧，还是写一个吧。。动态规划的思想来了：）

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1001],p[1001],top=0;
  //一会儿要用的数组
int f[1001][1001];
int gcd(int x,int y){
	return x==0?y:gcd(y%x,x);
}
  //读入不解释
int read(){
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1;
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
  //赋值
	for(int i=1;i<=n;i++) f[i][i]=a[i];
                         //开始动态规划
	for(int i=n-1;i>=1;i--){
		for(int j=i+1;j<=n;j++){
                                //动态转移方程
			f[i][j]=gcd(f[i+1][j],a[i]);
		}
	}
                                //最后再输入
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
  //直接愉快的输出
		printf("%d\n",f[u][v]);
	}
	return 0;//华丽的结束
}
```
本~~大佬~~蒟蒻的题解结束

---

## 作者：frankchenfu (赞：0)

不得不说，~~这是一道线段树好题~~。

一看到这道题就想到了线段树——但是询问有$10^6$，怎么办？

哈！**zkw线段树，满足您的的各种~~卡常需求~~**！

实测zkw线段树在只有区间加、区间`max/min`的时候可以跑过$1.8\times 10^7$次操作（包括区间查询和单点修改）；

而如果加上一些$\log$级别的询问，一般也可以过$5\times 10^6$的数据。

等一下……这道题不需要修改？那么预处理是$n=1000$的$n\log_2 n$，查询是$m\log_2 n\times \ln n$（`gcd`复杂度）。

因此这道题就可以zkw线段树快速解决。

顺带提醒一下楼下的几位dalao：~~你们都知道可以用线段树了还不写zkw，难道你准备被noip的老爷机卡常吗？？？~~


```cpp
#include<cstdio>
#include<cstring>
const int MAXN=4010;

int d[MAXN];
int n,m,bit;

int gcd(int x,int y){
	return y==0?x:gcd(y,x%y);
}

void build(int n){
	for(bit=1;bit<=n+1;bit<<=1);
	for(int i=bit+1;i<=bit+n;i++)
		scanf("%d",&d[i]);
	for(int i=bit-1;i;i--)
		d[i]=gcd(d[i<<1],d[i<<1|1]);
}
void update(int x,int y){
    for(d[x+=bit]=y,x>>=1;x;x>>=1)
        d[x]=gcd(d[x<<1],d[x<<1|1]);
}
int query(int s,int t){
	int ans=d[s+bit];
	for(s+=bit-1,t+=bit+1;s^t^1;s>>=1,t>>=1){
		if(~s&1)
			ans=gcd(ans,d[s^1]);
		if(t&1)
			ans=gcd(ans,d[t^1]);
	}
	return ans;
}

int main(){
	scanf("%d%d",&n,&m);
	build(n);
	for(int i=1;i<=m;i++){
	    int l,r;scanf("%d%d",&l,&r);
	    printf("%d\n",query(l,r));
	}
	return 0;
}
```

---

## 作者：奔波儿霸 (赞：0)

#### 都是扯淡

看到题解里面竟然没有人写分块。。。

鉴于我最近一直在学习分块大法，所以就发一篇分块的题解吧。

~~还有这题简直就是分块好题啊~~

#### 解题思路

如果你不会分块的话，请去做一下黄学长的数列分块入门``1-9``。他的``blog``里面也有题解，写的很好哦。

下面我们来看这道题咋做，因为根本就不需要修改，所以直接不用考虑如何维护~~真良心QAQ~~。

将每个块都求一个$\gcd$，然后询问的时候对于两边多出来的不完整块，我们暴力的进行求$\gcd$，然后在和每个块的$\gcd$取$\gcd$。将最后的答案输出。

#### 附上代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
const int maxn = 1e6+3;
typedef long long LL;
int n, cnt, arr[maxn], GCD[1003], a, b, m, in[1003];
inline int gcd(int x, int y) {
	return y ? (gcd(y, x%y)) : x;
}
inline LL read() {
	LL x = 0, f = 1; char c = getchar();
	while (c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while (c <= '9' && c >= '0') {x = x*10 + c-'0'; c = getchar();}
	return x * f;
}
inline int query(int l, int r) {
	int ans = arr[l];
	for(int i=l; i<=std::min(r, in[l]*cnt); i++)
		ans = gcd(ans, arr[i]);
	if(in[l] != in[r])
		for(int i=(in[r]-1)*cnt+1; i<=r; i++)
			ans = gcd(ans, arr[i]);
	for(int i=in[l]+1; i<in[r]; i++)
		ans = gcd(ans, GCD[i]);
	return ans;
}
int main() {
	n = read(), m = read();
	cnt = std::sqrt(n);
	for(int i=1; i<=n; i++) {
		arr[i] = read();
		in[i] = (i-1)/cnt+1;
		GCD[in[i]] = !GCD[in[i]] ? arr[i] : gcd(GCD[in[i]], arr[i]);
	}
	for(int i=1; i<=m; i++) {
		a = read(), b = read();
		printf("%d\n", query(a, b));
	}
	return 0;
}
```

---

## 作者：Encounter (赞：0)

## 据说此题用cin和cout会被卡掉后两个点。

### > 开个二维数组，f[i][j]表示第i个数到第j个数的最大公约数，

### > 可以推知f[i][j] = gcd(f[i][j-1],a[j]);

### > 显然询问是O(1);

### 放代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<string>
#include<queue>
#include<deque>
#include<vector>
#include<stack>
#define LL long long
using namespace std;
void read(int &x){
    char c = getchar(); x = 0;
    while(c < '0' || c > '9') c = getchar();
    while(c <= '9' && c >= '0') x = x*10+c-48, c = getchar();
}
int n,m;
int a[1005],f[1005][1005];
int gcd(int a,int b){
    if(!b) return a;
    return gcd(b,a%b); 
}
int main(){
    read(n);read(m);
    for(int i = 1;i <= n;i++)
       read(a[i]);
    for(int i = 1;i <= n;i++)
       f[i][i] = a[i];
    for(int i = 1;i < n;i++)
       for(int j = i+1;j <= n;j++) 
          f[i][j] = gcd(f[i][j-1],a[j]);
    while(m--){
        int l,r;
        read(l),read(r);
        printf("%d\n",f[l][r]);
    }
    return 0;
}
```

---

## 作者：杰森的伯恩 (赞：0)

用f[i][j]表示ai~aj的gcd。

f[i][i]=ai

f[i][j]=gcd(f[i][j-1],aj)   (i<j)

时间复杂度O(n^2logn+m)

这里的gcd用了二进制优化，减小常数。

原理就是gdc(x,y)=2gcd(x/2,y/2)(x，y为偶数）,   gcd(x,y)=(x/2,y)(x为偶数）

若x,y都为奇数，则gcd(x,y)=gcd(x-y,y),此时x-y为偶数，重复上述过程即可。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN=1005;
int n,m,a[MAXN],f[MAXN][MAXN];
inline int gcd(int x,int y)
{
    int i,j;
    if(x==0||y==0) return x+y;
    for(i=0;!(x&1);i++) x>>=1;
    for(j=0;!(y&1);j++) y>>=1;
    if(j<i) i=j;
    while(1){
        if(x<y){
            x^=y;y^=x;x^=y;
        }
        x-=y;
        if(!x) return y<<i;
        while(!(x&1)) x>>=1;
     }
}
int main()
{
    int i,j,l,r;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++){
        scanf("%d",&a[i]);
        f[i][i]=a[i];
    }
    for(i=1;i<n;i++){
        for(j=i+1;j<=n;j++){
            f[i][j]=gcd(f[i][j-1],a[j]);
    //        cout<<f[i][j-1]<<' '<<a[j]<<' '<<f[i][j]<<"g"; 
        }
    }
    for(i=1;i<=m;i++){
        scanf("%d%d",&l,&r);
        printf("%d\n",f[l][r]);
    }
    return 0;
}
```

---

## 作者：lwhllw (赞：0)

楼下有个小错误哦，不是扩展欧几里得算法是欧几里得算法。

对于区间处理选择线段树~




```cpp
const maxn=4000;
type node=record
      lch,rch,left,right,data:longint;
     end;
var i,j,k,l,m,n,ans,tot:longint;
    a:array[1..maxn]of node;
    d:array[1..maxn]of longint;
function gcd(m,n:longint):longint;
begin
    if n=0 then exit(m)
    else gcd:=gcd(n,m mod n);
end;
procedure init;
var i:longint;
begin
    readln(n,m);
    for i:=1 to n do read(d[i]);
    tot:=1;
end;
procedure built(i,le,ri:longint);
var mid:longint;
begin
    a[i].lch:=le;a[i].rch:=ri;
    if le=ri then
    begin
      a[i].data:=d[le];
      exit;
    end;
    mid:=(le+ri)shr 1;
    inc(tot);a[i].left:=tot;
    inc(tot);a[i].right:=tot;
    built(a[i].left,le,mid);
    built(a[i].right,mid+1,ri);
    a[i].data:=gcd(a[a[i].left].data,a[a[i].right].data);
end;
procedure query(i,le,ri:longint);
var mid:longint;
begin
    if(le<=a[i].lch)and(ri>=a[i].rch)then
    begin
      if ans=0 then ans :=a[i].data
      else ans:=gcd(ans,a[i].data);
      exit;
    end;
    mid:=(a[i].lch+a[i].rch)shr 1;
    if(le<=mid)then query(a[i].left,le,ri);
    if(mid<ri)then query(a[i].right,le,ri);
end;
procedure work;
var i,j,k:longint;
begin
    tot:=1;
    built(1,1,n);
    for i:=1 to m do
    begin
      ans:=0;
      readln(j,k);
      query(1,j,k);
      writeln(ans);
    end;
end;
begin
    init;
    work;
end.

```

---

## 作者：vegetabird (赞：0)

先发一个暴力的解法：

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
inline void getint(int &v){
    char ch=v=0;
    while(!isdigit(ch)){
        ch=getchar();
    }
    while(isdigit(ch)){
        v=(v<<1)+(v<<3)+ch-48;
        ch=getchar();
    }
}
inline void putint(int v){
    if(!v){
        putchar('0');
        return;
    }
    int t=1;
    while(t*10<=v){
        t*=10;
    }
    while(t){
        putchar(v/t+48);
        v%=t;
        t/=10;
    }
}
inline int gcd(int a,int b){
    int r=a%b;
    while(r){
        a=b;
        b=r;
        r=a%b;
    }
    return b;
}
int n,m;
int a[1010],g[1010];
int l,r;
int ans;
int main(){
    int i,j;
    getint(n);
    getint(m);
    getint(a[1]);
    for(i=2;i<=n;i++){
        getint(a[i]);
        g[i-1]=gcd(a[i-1],a[i]);
    }
    for(i=1;i<=m;i++){
        getint(l);
        getint(r);
        ans=a[l];
        for(j=l;j<r-1;j+=2){
            ans=gcd(ans,g[j]);
            if(ans==1){
                break;
            }
        }
        if(ans>1&&l!=r){
            ans=gcd(ans,g[r-1]);
        }
        putint(ans);
        putchar('\n');
    }
}
```
表示上面就是在卡常。。。（卡到了90分哦，连我自己都觉得不可思议）
好了，放正解

```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
inline void getint(int &v){
    char ch=v=0;
    while(!isdigit(ch)){
        ch=getchar();
    }
    while(isdigit(ch)){
        v=(v<<1)+(v<<3)+ch-48;
        ch=getchar();
    }
}
inline void putint(int v){
    if(v==0){
        putchar('0');
        return;
    }
    int t=1;
    while(t*10<=v){
        t*=10;
    }
    while(t){
        putchar(v/t+48);
        v%=t;
        t/=10;
    }
}
inline int gcd(int a,int b){
    int r=a%b;
    while(r!=0){
        a=b;
        b=r;
        r=a%b;
    }
    return b;
}
int n,m;
int a[1010],g[1010][1010];                        gcd[i][j]表示数列中第i到j个元素的最大公因素
int l,r;
int main(){
    int i,j;
    getint(n);
    getint(m);
    for(i=1;i<=n;i++){
        getint(a[i]);
    }
    for(i=1;i<=n;i++){
        g[i][i]=a[i];                            一个数的最大公因数就是这个数本身
        for(j=i+1;j<=n;j++){
            if(g[i][j-1]!=1){
                g[i][j]=gcd(g[i][j-1],a[j]);                    计算g[i][j]
            }
        }
    }
    for(i=1;i<=m;i++){
        getint(l);
        getint(r);
        putint(g[l][r]);
        putchar('\n');
    }
}
```

---


# 自我数

## 题目背景

#题目有加强


## 题目描述

在 1949 年印度数学家 D. R. Daprekar 发现了一类称作 Self-Numbers 的数。对于每一个正整数 $n$，我们定义 $d(n)$ 为 $n$ 加上它每一位数字的和。例如， $d(75) = 75 + 7 + 5 = 87$。给定任意正整数 $n$ 作为一个起点，都能构造出一个无限递增的序列：$n, d(n), d(d(n)), d(d(d(n))), \ldots$ 例如，如果你从 $33$ 开始，下一个数是 $33 + 3 + 3 = 39$，再下一个为 $39 + 3 + 9 = 51$，再再下一个为 $51 + 5 + 1 = 57$，因此你所产生的序列就像这样：$33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, \ldots$。数字 $n$ 被称作 $d(n)$ 的发生器。在上面的这个序列中，$33$ 是 $39$ 的发生器，$39$ 是 $51$ 的发生器，$51$ 是 $57$ 的发生器等等。有一些数有超过一个发生器，如 $101$ 的发生器可以是 $91$ 和 $100$。一个没有发生器的数被称作 Self-Number。如前 $13$ 个 Self-Number 为 $1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97$。我们将第 $i$ 个 Self-Number 表示为 $a_i$，所以 $a_1 = 1, a_2 = 3, a_3 = 5, \ldots$。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le {10}^7$，$1 \le K \le 5000$。

## 样例 #1

### 输入

```
100 10
1 2 3 4 5 6 7 11 12 13 
```

### 输出

```
13
1 3 5 7 9 20 31 75 86 97
```

# 题解

## 作者：ghj1222 (赞：10)

分享一个非正解的做法
## 本题解内存最低($\le1\rm MiB$)
但是不开O2会tle

思路：每个数字仅会更新出1个新的数字，而且这个新数字比旧数字最多也就大70多。所以这里还是利用“筛数”的思想枚举所有数字筛数字，但这里我开一个小根堆来存储当前已经被发现**不是自我数**但是**还未被遍历到**的数字。从小到大遍历所有数字，如果堆是空的，或者堆顶(也就是堆里最小数字)不是当前遍历数字说明这个数字是自我数，统计进ans,输出ans即可

对于k个询问，我们从小到大排序离线操作，再开一个指针pos表示当前询问查询到哪个询问，并随着i的更新来更新询问。最后按照初始id把询问排序回去输出。  
具体可见代码实现：

```
#include <bits/stdc++.h>
using namespace std;

struct ask
{
	int id, x, y;
}a[5010];

int n, k, tot, ans, pos;
priority_queue<int, vector<int>, greater<int> >q;

bool cmp1(const ask &x, const ask &y)
{
	return x.x < y.x;
}

bool cmp2(const ask &x, const ask &y)
{
	return x.id < y.id;
}

int make(int x)
{
	int res = x;
	while (x > 0)
	{
		res += x % 10;
		x /= 10;
	}
	return res;
}

int main()
{
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= k; i++)
	{
		a[i].id = i;
		scanf("%d", &a[i].x);
	}
	sort(a + 1, a + 1 +k, cmp1);
	for (int i = 1; i <= n; i++)
	{
		if (q.empty() || q.top() != i)
		{
			tot++;
			if (a[pos].x < i)
				pos++;
			while (a[pos].x == tot)
			{
				a[pos].y = i;
				pos++;
			}
			pos--;
			ans++;
		}
		else
			while (!q.empty() && q.top() == i)
				q.pop();
		q.push(make(i));
	}
	printf("%d\n", ans);
	sort(a + 1, a + 1 + k, cmp2);
	for (int i = 1; i <= k; i++)
		printf("%d%c", a[i].y, i == k ? '\n' : ' ');
	return 0;
}
```
让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/space/show?uid=88460)

---

## 作者：no_proper_name_left (赞：6)

一开始眼瞎没看到6MB和750ms寒假里在重构n次后AC了。。。讲真这道题有一点鬼，题解和讨论里没一个能AC的2333，然后最近又看了一下这道题还是没有AC的题解额。
高性能的这道题压一下位是OK的了，说一下另一个作法。。。

一般来说最开始想到弄个10^7的bool数组统计某数的“和”，例如1的“和”为2，那么a[2]=1。然后最后数一下就好了。不过这当然是不行的啊哈哈哈。然后我就想到循环数组了。（但一定要小心不要越界）

P.S.可以证明（很简单）某数的和是它前一个数的”和“+2-9*这个数有几个零。不过常规算也可以的。
 
 先上代码，作为蒟蒻我的变量名可能看不太出来是什么，过会解释。
 
 ```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int ans[1000000];
int t(int n)//统计有几个零（要-9的）
{
    int countt=0;
    while(n%10==0)
	{
    	countt++;
    	n/=10;             
    }
    return countt;
}
int main()
{
	int n,m,a[101],b=2,c[5000],count=0,j,base=1,base_idx=1,new_base,k;//a是循环数组存0或1，base是数组中最小值（不是0哦，是循环数组代表的这一串数中的最小的），base_idx坐标
    cin>>n>>m;
    for(int i=0;i<m;i++)
    	cin>>c[i];
    for(int i=0;i<100;i++)
    	a[i]=0;
    for(int i=1;i<=n+99;i++)
    {
    	new_base=b-99;//减99，因为和当前最小差了99以后的”和“就不会影响前面的自我数了
    	if(new_base>base)
    	{
    		k=base_idx;
    		for(j=base_idx;j<=new_base-base+base_idx;j++)//自行理解
			{
				int temp=j-base_idx+base;
				if(k==101)
				{
					k=1;
				}
				if(a[k]==0 && temp<=n)
				{
					
					ans[count]=temp;
					count++;
				}
				k++;
			}
			k=base_idx;
			for(j=base_idx;j<=b-99-base+base_idx;j++)
			{
				if(k==101)
					k=1;
				a[k]=0;
				k++;
			}
			base=j-base_idx+base;
			if(k==101)
				base_idx=1;
			else
				base_idx=k;
		}
		if(b-base+base_idx<101)//这里小心越界
    		a[b-base+base_idx]=1;
    	else if((b-base+base_idx)%101+1==101)
    		a[1]=1;
    	else
    		a[(b-base+base_idx)%101+1]=1;
    	b=b+2-9*t(i+1);//算”和“
	}
	
	cout<<count<<endl;
    for(int i=0;i<m;i++)
    	cout<<ans[c[i]-1]<<' ';
    return 0;
}
```

---

## 作者：顾z (赞：6)

题目描述-->[p1900 自我数](https://www.luogu.org/problemnew/show/P1900)

## 本文转自[@keambar](https://www.cnblogs.com/keam37/p/3815306.htm)

### 转载已经原作者同意

**分析：**

         思路还是比较好给出的：
         用类似筛选素数的方法筛选自我数。

         但是要注意到题目限制的空间仅有4M,不够开10^7 那么大的数组.
         于是进一步分析问题我们发现每一次拓展出来的数最多比原数大63！

		 这是由于最多不过7位数,假设每一位都是9的话,拓展出来的数才大 7*9=63.

         所以我们，对拓展出来的数取模，再用数组存下来。

         至于输出自我数,经过测试.
         在SGU的数据里自我数的答案没有超过10^6 
         刚好用掉4M的空间 ⊙﹏⊙b汗

         最保险的方法还是仅将需要的自我数号码存下来,
         排序后用二分查找判断当前找到的数是否是需要存下的.
         最后再将存下的数按照读入的顺序输出.

**原作者代码**↓
```cpp
#include<cstdio>
int n, m, k;
bool pd[100];
int f[1000000], tol;
int Find (int x) {
    for (k = 0; x != 0; x /= 10)
        k += x % 10;
    return k;
}
void init() {
    int i, j;
    tol = 0, j = 0;
    for (i = 1; i <= n; i++) {
        if (!pd[i % 100])    f[++tol] = i;
        else
                     pd[i % 100] = false;
              //这里用了个小技巧，大大减少取模的次数，很容易想明白
        if (i % 10 == 0)     j = i + Find (i);
              else
                      j += 2;
        pd[j % 100] = true;
    }
}
int main() {
    scanf ("%d%d", &n, &m);
    init();
    printf ("%d\n", tol);
    for (int i = 1; i <= m; i++) {
        scanf ("%d", &k);
        printf ("%d ", f[k]);
    }
    return 0;
}
```
本人辣鸡代码就不放了emmm

应原作者要求:本题亦可以在**SGU**上找到

//不过,我没有找到链接 emm

---

## 作者：AL_Blue (赞：5)

# 本题时间低，内存低

**题目传送门：[P1900 自我数](https://www.luogu.com.cn/problem/P1900)**

这一题比较坑，错误情况还是比较多的，这里只列举一个。

**错误范例：枚举**

错误点：可能性太多了。绝对超时，O2 也救不了。

错误代码在这里不予展示了。

大概是能得四十分的样子。

我的想法是——
## 空间换时间。

在筛选素数的时候有一种非常省时间的办法，叫做欧几里得筛法。它就是假设每一个数都是素数，然后从 $2$ 开始，根据素数的倍数都是合数，然后一个个筛去。它真正的总体思想就是我现在探讨的主题——空间换时间。

所以我们就会有一种办法，设所有的都是自我数，然后把前缀是它的都算作有发生器的。

但是，为了最大程度上省空间，我们需要先引进一个东西。

```cpp
bitset
```

这可是一个替代 `bool` 的好东西，空间是 `bool` 的八分之一。

我们代码中，要声明一个**字节**，就**要 $8$ 个 `bit`，**正常情况下，`int` 就是这样的，然而如果我们要声明一个 `bool`，虽然**只用了一位**，但是**还是会声明 $8$ 个 `bit`，**这就很浪费空间，为了减小空间，我们就可以用 `bitset`，它就在声明的时候，**只用了一个 `bit`，**就会直接变成**八分之一**的空间。原本的 $10^7$ 的空间，用了 `bitset`，就变成了 $125\times10^4$ 的大小，这就可以了。

代码如下。
```cpp
#include<iostream>
#include<bitset>

using namespace std;
bitset<10000001> flag;
int a[1000000];

int d(int x) {
  int s = 0;
  while (x > 0) {
    s+=x%10;
    x/=10;
  }
  return s;
}

int main() {
  int n, k;
  cin >> n >> k;
  
  for (int i = 1; i <= n; ++i) {
    int j = d(i) + i;
    if (j <= n)
      flag[j] = true;
  }
  int num = 0;
  for (int i = 1; i <= n; ++i) 
    if (flag[i] == false) {
      num++;
	  a[num] = i;
	}
  cout << num << "\n";
  for (int i = 1; i <= k; i++) {
    int s;
    cin >> s;
    cout << a[s] << " ";
  }
}
```
感谢观看。

------------


---

## 作者：L2_sheep (赞：5)

分享一下本题的最优解。其实这道题是有规律可循的。

所谓的自我数就是不能表示成 2a0 + 11a1 + 101a2 + ... +  (10^n + 1)an  (0 <= an <= 9)的数。
可以用递归的方法来判断一个数是不是自我数。

通过打表：1, 3, 5, 7, 9, ... 108， 110， 121, ... 209, 211, 222 ... 310, 312, 323 ... 411, 413, 424 ...

可以发现：
209 = 108 + 101, 211 = 110 + 101,  310 = 209 + 101,  424 = 323 + 101...

经过思考可以发现大多数的自我数都符合递推，只有少部分数需要递归来判断是否是自我数，递推和递归相结合就能快速得到答案。

具体代码如下：
```cpp
#include <stdio.h>
#define M 8

int b[M + 1] = {0, 2, 11, 101, 1001, 10001, 100001, 1000001, 10000001};
int s[M + 1], a[1000000] = {0, 1, 3, 5, 7, 9}, c = 5;

int judge(int x, int d)
{
    if(d == 1){
        if(x & 1) return 0;
        if(x < 20) return 1;
    } 
    int t = b[d], y, z;
    if(x < t) return judge(x, d - 1);
    y = x / t;
    if(y == 10) y--;
    z = x - y * t;
    while(z <= s[d - 1]){
        if(judge(z, d - 1)) return 1;
        y--;
        z = x - y * t;
    }
    return 0;
}

int main() 
{
    int n, i, bi, tc, x, t, y, z, T;
    
    scanf("%d%d", &n, &T);
    for(i = 1, s[0] = 0; i <= M; i++){
        s[i] = s[i - 1] + 9 * b[i];
    }
    
    bi = 2, tc = 5;
    while(b[bi] <= n){
        t = b[bi], y = s[bi - 1];
        for(i = 1; ; i++){
            x = t + a[i];
            if(x > y) break;
            if(!judge(x, bi - 1)) a[++c] = x;
        }
        for( ; i <= tc; i++){
            a[++c] = t + a[i];
        }
        for(z = b[bi + 1]; ; i++){
            if((x = t + a[i]) >= z) break;
            a[++c] = x;
        }
        bi++, tc = c;
    }
    
    for(i = c; a[i] > n; i--);
    printf("%d\n", i);
    while(T--){
        scanf("%d", &x);
        printf("%d ", a[x]);
    }
    
    return 0;
}
```



---

## 作者：wjy666 (赞：5)

这题的思路很简单，从1到n遍历每一个数，标记以这个数为发生器生成的数

如果遍历到没被标记的数就是自我数了

但是这题有一个很不错的优化:

每遍历到一个数的时候需要获得这个数每一位的和

一般的做法是一位位算，时间主要就花费在这上面了

但是，n+1的和完全可以从n迅速得出

n+1的和是n的和+1，然后每进一位-9

而我们只需要看n+1末尾有几个0就可以知道进了几位！

经检验这样比普通方法快了好几倍

下面是简短易懂代码

```cpp
#include<cstdio>
#include<cctype>
#define For(i,j,k) for(int i=j;i<=k;i++)
using namespace std;
int read(){
    int x=0,l=1; char ch=getchar();
    while(!isdigit(ch)) {if (ch=='-') l=-1; ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*l;
}
bool fl[10000100]; int ans[1000005]; 
int main(){
    int n=read(),k,len=0,cnt=0; //开始只用读入一个n
    For(i,1,n){
        len++; k=i;
        while(!(k%10)) k=k/10,len-=9; //len是每一位的和，这2行就是上面所说的快速转移方法
        if (!fl[i]) ans[++cnt]=i; //没被标记说明是自我数
        fl[i+len]=1; //标记
    }
    k=read(); printf("%d\n",cnt); //cnt为总数
    For(i,1,k) printf("%d ",ans[read()]); //输入一个输出一个,省个数组
    return 0;
}
```

---

## 作者：替罪羊树 (赞：3)

当我们拿到题目时，不妨分析一下：

根据自我数的定义，如果是一位数a，那么a+a=2a必然就不是自我数

如果是两位数ab，那么10a+b+a+b=11a+2b不是自我数。

通过进一步推理，我们发现，只要能表示为
2a_1+11a_2+101a_3+1001a_4+...+1000...(n-2个)01a_n
的必然不是自我数

看数据范围$$10^7$$，经过测算其中自我数小于1000000个，于是，布尔数组模拟即可

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
bool a[10000001];
int ask[10000];
int ad[1000000];
int main()
{
    int i,j,n,k,m;
    int q1,q2,q3,q4,q5,q6,q7;
    int ans=0;
    
    scanf("%d %d",&n,&k);
    memset(a,true,sizeof(a));
    for(i=1;i<=k;i++)
    {
        scanf("%d",&ask[i]);
    }
    for(q1=0;q1<=9;q1++)
    for(q2=0;q2<=9;q2++)
    for(q3=0;q3<=9;q3++)
    for(q4=0;q4<=9;q4++)
    for(q5=0;q5<=9;q5++)
    for(q6=0;q6<=9;q6++)
    for(q7=0;q7<=9;q7++)
    {
        if (q1*2+q2*11+q3*101+q4*1001+q5*10001+q6*100001+q7*1000001<=n) a[q1*2+q2*11+q3*101+q4*1001+q5*10001+q6*100001+q7*1000001]=false;//注意越界，我在这炸了好几次
    }
    for(i=1;i<=n;i++)
    {
        if (a[i]) 
        {
        ans++;
        ad[ans]=i;//统计答案一
    }
    }
    printf("%d\n",ans);
    for(i=1;i<=k;i++)
    {
        printf("%d ",ad[ask[i]]);//输出答案2
    }
    return 0;
}
```

---

## 作者：xwh_hh (赞：2)

一道经典卡内存题。  
按照题意，我们可以考虑写出这个 $d(x)$ 函数，定义一个 $dk$ 数组，然后我们考虑所有的 $x$，使得 $1\le x\le n$，将 $dk_x$ 置为 $1$，并将所有使得 $dk_x=0$ 的 $x$（也就是题目中说的 Self-Numbers）记录下来，最后处理询问，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
bool dk[10000005];
int d(int u){
	int ans=u;
	while(u){
		ans+=u%10;//取出1位
		u/=10;
	}
	return ans;
}
int a[1000005],cnt;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		dk[d(i)]=1;//更新
		if(!dk[i]) a[++cnt]=i;//存储
	}
	cout<<cnt<<endl; 
	for(int i=1;i<=k;i++){
		int u;
		cin>>u;
		cout<<a[u]<<' ';
	}
	return 0;
}

```
MLE 了。  
现在我们考虑优化内存。  
不难想到 $\forall x\in [1,10^7],\ x<d(x)<x+100$，所以我们可以考虑将 $dk$ 数组定义为长度为 $100$ 的数组，更新时更新 $dk_{i\bmod 100}$，就可以避免 MLE 了。  
AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
bool dk[105];
int d(int u){
	int ans=u;
	while(u){
		ans+=u%10;//取出一位 
		u/=10;
	}
	return ans;
}
int a[1000005],cnt;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		dk[d(i)%100]=1;//更新 
		if(!dk[i%100]) a[++cnt]=i;//存储 
		dk[i%100]=0;//一定要归零！！！ 
	}
	cout<<cnt<<endl;
	for(int i=1;i<=k;i++){
		int u;
		cin>>u;
		cout<<a[u]<<' ';
	}
	return 0;
}
```

---

## 作者：hibiki (赞：1)

可以用类似于素数筛法的思想来做，效率O(N)

对于每一个数i，记它的下一个数为next(i).用一个布尔数组存每一个数字是不是自我数。对于每一个自我数，不断的标记其next(i)，直到next(i)不是自我数(因为从i开始的序列是唯一的，所以再继续标记是没意义的)或者next(i)>n。

代码如下：

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int next(int num){
    int ans=0;
    ans+=num;
    while (num!=0) {
        ans+=num%10;
        num/=10;
    }
    return ans;
}
int cnt=0;
bool flag[10000010];
int ans[1000010];
int main(){
    memset(flag,true,sizeof(flag));
    int n,k;
    scanf("%d%d",&n,&k);
    for (int i=1;i<=n;i++)
        if (flag[i]){
            ans[++cnt]=i;
            int now=next(i);
            while (now<=n&&flag[now]) {
                flag[now]=false;
                now=next(now);
            }
        }
    printf("%d\n",cnt);
    int t=0;
    for (int i=1;i<=k;i++){
        scanf("%d",&t);
        printf("%d ",ans[t]);
    }
}
```

---

## 作者：卷王 (赞：0)

题目的意思就是让你求出 $[1, n]$ 之间的自我数，自我数指的是无法用 **另一个数字** 加上 **这个数字的数字和** 的和来得出。

首先可以想到暴力，从小到大枚举 $[1, n]$ 所有的数，然后算出数字和并标记。最后没有被标记的数就是我们要求的自我数。

那么现在问题来了，大小为 $10^7$ 的 bool 数组需要消耗大约 $9.5$ MB 的内存，而题目要求是 $6$ MB。那么只能用  `bitset`，这样可以直接将空间优化到 $9.5 \div 8$ MB，就可以了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k;
int a[5007];
bitset<10000107> st;
int x[1000007], cnt = 0;
int main() {
	cin >> n >> k;
	for(int i = 1; i <= k; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) {
		if(st[i] == 0) x[++cnt] = i;
		int t = i, sum = 0;
		while(t > 0) {
			sum += t % 10;
			t /= 10;
		}
		st[i + sum] = 1;
	}
//	for(int i = 1; i <= cnt; i++) cout << x[i] << " ";
//	cout << "\n";
	cout << cnt << "\n";
	for(int i = 1; i <= k; i++) {
		cout << x[a[i]] << " ";
	}
	return 0;
}
```

---

## 作者：___nyLittleT___ (赞：0)

## 思路
本来我就是个爱打暴力的人，于是本来准备用 `map` 这东西标记，但这东西不争气，时间又多空间又大，我就想到了 `bitset` 这个东西，占用内存十分的小，嗯，于是一份暴力代码就写出来了。
首先，先计算每一个发生器，然后在这个范围内打标记，再遍历，最后再按题目要求输出即可。

在代码里，本着不增加空间的原则，我没有再定义新变量，比如最后我将 $n$ 重复利用，节省了一点空间。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+1;
bitset<N>b;
int a[N];
int n,k,idx;
int d(int x){
	int ans=0;
	while(x){
		ans+=x%10;
		x/=10;
	}
	return ans;
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		if(i+d(i)<=n)
			b[i+d(i)]=true;
	for(int i=1;i<=n;i++)
		if(!b[i])
			a[++idx]=i;
	printf("%d\n",idx);
	for(int i=1;i<=k;i++){
		scanf("%d",&n);
		//本着节省空间的原则 
		printf("%d ",a[n]);
	}
	return 0;
}
```

---

## 作者：hopelessness (赞：0)

Update on 2023.11.8 修改了一些东西

~~这道题裸裸的水题~~ 

这道题是一道暴力再加点卡空间。

所以，我们需要 bitset 这个省空间好工具。

`Code`：

```cpp
/*
    by hopelessness
*/
#include<bits/stdc++.h>

#define il inline
#define LL long long
#define ri register int
#define random(a,b) ((a)+rand()%((b)-(a)+1))

using namespace std;

bitset<10101010>mmp;

int a[1010101];

int n,k,pos;

template<typename T>il void read(T &x){
    char c=getchar();
    x=0;
    int f=0;
    for(;!isdigit(c);c=getchar()) f|=(c=='-');
    for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
    x=f?-x:x;
}
template<typename T>il void write(T x){
    if(x<0) x=-x,putchar('-');
    if(x>9) write(x/10);
    putchar(x%10^48);
}
il int num(int x){
    ri ret=0;
    while(x){
        ret+=(x%10);
        x/=10;
    }
    return ret;
}

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    read(n),read(k);
    for(ri i=1;i<=n;i=-~i){
        if(!mmp[i]) a[++pos]=i;
        mmp[i+num(i)]=true;
    }
    write(pos),putchar('\n');
    for(ri i=1,x;i<=k;i=-~i) read(x),write(a[x]),putchar(' ');
    return 0;
}
```

---

## 作者：BetterGodPig (赞：0)

### $\text{Update on 23.11.08}$ 规范正文部分的排版。

考虑暴力枚举区间，使用筛法思想将以当前数为发生器的数筛掉，但是 ~~毒瘤出题人卡我空间~~，考虑从两个方面优化，第一，标记数组使用 `bitset`，第二，先暴力跑出极限数据 $\text{n} = 10^7$ 的自我数的数量，我跑出来是 $977787$，再顶着最大限度开。


```cpp
#include<bits/stdc++.h>
#define int unsigned
using namespace std;
int n,k,cnt;
bitset<10000001> mp;
int num[977788];
int get(int x){
	int ret = 0;
	while(x){
		ret += x%10;
		x /=10;
	}
	return ret;
}
signed main(){
	cin>>n>>k;
	for(int i(1);i <= n;++i){
		if(!mp[i]){
			num[++cnt] = i;
		}
		mp[i+get(i)] = 1;
	}
	cout<<cnt<<'\n'; 
	for(int i(1);i <= k;++i){
		int ind; cin>>ind;
		cout<<num[ind]<<' ';
	} 
	return 0;
}
```

---

## 作者：fanke (赞：0)


[题目传送门](https://www.luogu.com.cn/problem/P1900)

## 思路：
  本题可以参考 P3383 的思路，用类似筛质数（即素数）的方法来找到自我数。
  
  接着去看看时间限制和内存限制发现数组不够开，这怎么办呢？经过~~粗略的~~计算，我们会发现上一个自我数拓出的自我数不会，也不可能超过 $63$。
#### 因为题目中说“$1  \le N\le 10 ^ 7$”也就是说，这个自我数最多  $7$ 位，那么最大拓出的自我数为：$7 \times 9 = 63$。

  好啦，问题解决了，写之前我们先整理一下思路：
#### 因为以上的分析，所以我们用数组存储自我数拓出的数，再取模就好啦。
  
------------

## 代码：

代码其实并不长，也不难懂，所以我没有写注释，check 函数不难，自己写吧！以下是主要的代码：

```cpp
int main() 
{
    scanf ("%d %d", &n , &m);
    int ii = 0;
    int p = 0;
    for (int i = 1; i <= n; i ++) 
	{
        if (!used[i % 100])    
			f[++ p] = i;
        else
            used[i % 100] = 0;
        if (i % 10 == 0)     
			ii = i + check (i);
		else
			ii += 2;
        used[ii % 100] = 1;
    }
    printf ("%d\n", p);
    for (int i = 1; i <= m; i ++) 
	{
        cin >> k;//最好用scanf 
        printf ("%d ", f[k]);
    }
    return 0;
}
```


---


# 成功密码

## 题目描述

void\_rank匪别人的书来看，原本想看杂志颓废的，结果不小心拿错拿成了被导师称作旁门左道的高中数学杂志《成功密码》。数学差得不行的void\_rank实在不会用数学方法处理这些奇怪的题目，于是来问你了。

求
$\sum_{i=1}^{N}\frac{x^{i}}{i}$



## 说明/提示

数据规模:

对于30%的数据：

$N\le10^{6},0<x \le 1$

对于100%的数据：

$N\le10^{18},0<x\le1$，x最多仅有4位小数位


## 样例 #1

### 输入

```
1 1```

### 输出

```
1.0000```

# 题解

## 作者：Tarsal (赞：22)

这是蒟蒻的第一篇题解，（之前的都没过，估计这篇也过不了

#### 回到正题

这题，本蒟蒻第一眼看到以后，就决定咦，这不是模拟吗？

看到世界范围，嗯，打扰了。

### 扯回正题

首先，暴力肯定是A不了的（至少我A不了

但是，身为蒟蒻的我，还是打了一个暴力。

```cpp
#include<bits/stdc++.h>
using namespace std;

double x, ans;
unsigned long long n;

double mypow(double x, int y)
{
    double sum = 1;
    while(y --)
        sum *= x;
    return sum;
}

int main()
{
    scanf("%lf%u", &x, &n);
    for(int i = 1; i <= n; ++ i)
        ans += mypow(x, i) / i;
    printf("%.4lf\n", ans);
    return 0;
}
```

不出意外，0分，12000ms，全T；

然后，认真分析，这是一道数学题。嗯（废话

用快速幂优化试下

```cpp
#include<bits/stdc++.h>
using namespace std;

double x, ans;
unsigned long long n;

double ksm(double x, unsigned long long y)
{
    if(y == 1)
        return x;
    if(y & 1)
        return ksm(x * x, y >> 1) * x;
    return ksm(x * x, y >> 1);
}

int main()
{
    scanf("%lf%u", &x, &n);
    for(int i = 1; i <= n; ++ i)
        ans += ksm(x, i) / i;
    printf("%.4lf\n", ans);
    return 0;
}
```
嗯，高一点，30分，8520ms,后面的还是T了，

我们T掉的原因是什么？

就是我们求和那里跑了太多次，而i越的，x的i次方就越小，又因为它的精度要求只有4位，

所以，后面有很多次都是白跑的，对结果没影响。

那就，不跑。

嗯，在输入完n以后，判断一下，是否比maxn大

如果大的话，就赋n为maxn；

好，现在的问题又转化成了，maxn应该取什么值；

maxn应该取一个什么样的值？

它要使得，在它后面的数相加小于0.00005；

额，我最开始随便取了一个值，300

结果，80分，海星；

继续扩大maxn，因为，时间相对还算充裕，我就赋大了一点，赋到了7233，就A了；

好，接下来就是愉快的代码时间了

```cpp
#include<bits/stdc++.h>
using namespace std;

double x, ans;
unsigned long long n;//开无符号更保险， 

//这是递归版的快速幂 
double ksm(double x, unsigned long long y)
{
	if(y == (unsigned long long) 1)
		return x;
	if(y & 1)
		return ksm(x * x, y >> 1) * x;
	return ksm(x * x, y >> 1);
}

//这是循环版的快速幂 
/*
double ksm(double x, unsigned long long y)
{
	double ans = 1, base = x;
	while(y != 0)
	{
		if(y & 1 != 0)
			ans *= base;
		base *= base;
		y >>= 1;
	}
	return ans;
}
*/
 
int main()
{
	scanf("%lf%ull", &x, &n);//输入 
	if(n >= 72333)//奇葩的特判，我觉得这是骗分。。。 
		n = 72333;
	for(double i = 1.0; i <= (double) n; ++ i)//嗯，i的类型定义为double更好 
		ans += ksm(x, i) / i;//递推式，不说；
	printf("%.4lf\n", ans);//输出 
	return 0;//愉快的结束。 
}
```


---

## 作者：虞皓翔 (赞：18)

原式就是要求$\sum_{i=1}^n\frac{x^i}{i}$，一看思路简单明确，其实这道题还是有点价值的。

主要思路和楼下一样，但是还是可以优化的。

首先，当n不是很大的时候，直接算，不会超时的。然后当n递增时，因为$x\in\left(0,1\right)$，答案增长会变缓，但是可能积少成多，当加了100个，1000个甚至更多时，答案可能悄然增加了1e-4，怎么办呢？注意，这个数列是收敛的！收敛的值（后称极限）时可以求得！所以发现答案增长减缓时，与极限在保留4位小数的值相等时，立马跳出循环！

**问题是，这个极限怎么求呢？**

学过高等数学的人都知道，有如下泰勒展开公式：


$\ln(1-x)=x+\frac{x^2}{2}+\frac{x^3}{3}+\frac{x^4}{4}+\cdots\left(-1\le x<1\right)$


所以，可以利用math库的log函数把这个极限求出来，然后与当前计算的答案比较，就可以了。

利用这个方法，可以卡到9ms！

代码很简单，就18行！

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, i;
double x, lim, s, ans;

int main(){
    scanf("%lf%d", &x, &n);
    lim = -log(1.0 - x);
    s = 1.0;
    ans = 0.0;
    for(i = 1; i <= n; i++){
        s *= x;
        ans += s / i;
        if(round(ans * 10000.0) >= round(lim * 10000.0)) break;
    }
    printf("%.4lf\n", ans);
}
```

---

## 作者：JK_LOVER (赞：7)

## 题意
求
$$
ans = \sum_i^n \frac{a^i}{i}
$$
## 分析
当 $n$ 较小时，可以直接暴力求出 $ans$ 。但当 $ans$ 较大。需要一个数学方法来进行计算。考虑求导，令： $f(x) =  \int \frac{a^x}{x}$。
$$
f^{'}(x) = \frac{d  \int \frac{a^x}{x}}{dx} = \frac{a^x}{x}
$$
$$
f^{''} = \frac{d^2f(x)}{dx^2} = \frac{d f^{'}x}{dx} = (\frac{a^x}{x})^{'} = (a^x)^{'} \frac{1}{x}+ (\frac{1}{x})^{'}a^x
$$
$$
f^{''} = \frac{a^x}{x} \ln x   -x^{-2}a^x = \frac{xa^x \ln a - a^x}{x^2} = \frac{a^x\times(x\ln a-1)}{x^2}
$$
$$
a \in (0,1] \Rightarrow f^{''} < 0
$$
所以 $f(x)$ 是单调递减的，且速率越来越来慢。那么可以对 $n$ 规定一个上界。经过尝试 $n \le 10^5$ 时，是可以通过的。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long double eps = 1e-10;
double a;
int main()
{
	long long N;
	cin>>a>>N;
	N = min(1e5,N);
	double ans = 0.0;
	for(int i = 1;i <= N;i++)
	{
		ans = ans+pow(a,i)/i;
	}
	printf("%.4lf\n",ans);
	return 0;
}
```
[欢迎来踩](https://www.luogu.com.cn/blog/xzc/solution-p1920)

---

## 作者：algobase (赞：7)

这一题难点就是快速冪

但是c++有自带幂次方函数，于是这道题简单了很多。

main函数：
```cpp
int main()
{
	scanf("%lf %llu", &x, &n);
	for(int i = 1; i <= n; i++)
	{
		ans += pow(x, i) / i;//按原式来
	}
	printf("%.4lf", ans);//输出
	return 0;
}
```
怎么会这样？
![](https://cdn.luogu.com.cn/upload/image_hosting/py0cfycg.png)
我们来找一下原因：

本题的数据范围是$n\le 10^{18}$，而电脑的运算速度是$10^8$。
很明显，这种算法过了才怪。

**但是**，我们发现$i$越来越大，$x^i$越来越小，到一定程度了就不会改变$ans$的值了（因为是$4$位小数），所以输入完之后的$n$要加特判，如果$n$足够大，就直接$=maxn$。

所以，main函数应该是这样的：
```cpp
int main()
{
	scanf("%lf %llu", &x, &n);
	
	if(n > 100000)//特判（你设几都行，但一定得大于8万）
	{
		n = 100000;
	}
	for(int i = 1; i <= n; i++)
	{
		ans += power(x, i) / i;//按原式来
	}
	printf("%.4lf", ans);//输出
	return 0;
}
```

---

## 作者：zhangyuanxiao (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P1920)

## 题目大意
- 给出 $N,x$，求 $\sum_{i=1}^{N}\frac{x^{i}}{i}$。
- $N\le10^{18},0<x\le1$，$x$ 最多有 $4$ 位小数位。

## 分析

- 因为 $0<x\le1$，所以 $x^i\le1$，当且仅当 $x=1$ 时取等号，否则 $x^i$ 随着 $i$ 变大逐渐变小。又因为 $i$ 逐渐变大，$\frac{x^{i}}{i}$ 随着 $i$ 的变大逐渐趋近于 $0$，所以当 $i$ 足够大时，$\frac{x^{i}}{i}$ 对答案不会产生任何影响。因此，我们可以设置一个上限，只要 $N$ 大于这个上限，就让 $N$ 等于上限，然后我们就可以 **AC** 啦！因为题目只需要保留 $4$ 位小数，所以我们只需要把精度控制到小数点后第五位，所以上限取 $10^5$ 即可。

## 代码
```cpp
#include<iomanip>
#include<iostream>
#define int long long
using namespace std;

const int MAXN=1e5;//上限 
int N;
double x,ans,pow=1;

signed main(){
	cin>>x>>N;
	if(N>MAXN) N=MAXN;//缩小范围 
	for(int i=1;i<=N;i++){
		pow=pow*x;//pow存x的i次方
		ans+=pow/i*1.0;
	}
	cout<<fixed<<setprecision(4)<<ans;//保留4位小数
	return 0;
} 
```

如发现错误，欢迎私信指出。

---

## 作者：zhangzihang (赞：5)

这是本蒟蒻写的第一篇题解，写得不好，请见谅。

### 题意分析


---------

- 题目给定两个数 $n,x$，求 $\sum\limits_{i=1}^n{\dfrac{x^i}{i}}$。
- 其中 $x\in(0,1],n\in[1,10^{18}]$。


------------


我们最先想到的方法就是打一个暴力，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	double ans=0.0,a;
	long long n;cin>>a>>n;
	for(int i=1;i<=n;i++)
		ans+=pow(a,i)/i;
	cout<<fixed<<setprecision(4)<<ans;
	return 0;
} 
```
不出意外处理了 $30\%$ 的数据拿到 $30$ 分，剩下 $7$ 个点全部 **TLE**。

其他的题解有一部分用的是快速幂，~~本蒟蒻实在是想不到快速幂怎么用。~~

我们可以考虑一下用纯暴力的方式 **AC** 此题。
## 分析如下
令 $f(x)=\dfrac{a^x}{x}$，则
$$f'(x)=\dfrac{xa^x\operatorname{ln}a-a^x}{x^2}=\dfrac{a^x(x\operatorname{ln}a-1)}{x^2} $$

因为 $a\in(0,1]$，所以我们可以得到 $f'(x)<0$，因此 $f(x)$ 单调递减。我们很容易发现 $f(10^5)<10^{-5}$，答案只需要保留四位小数，所以 $x>10^5$ 时对这道题的答案产生不了任何影响。所以我们可以得到：
$$\sum\limits_{i=1}^nf(i)=\sum\limits_{i=1}^{\min(n,10^5)}f(i)$$


------------


所以我们循环的范围就会被卡到 $[1,10^5]$，这时候我们就可以直接写暴力了。我们只需要加上一行代码：
```cpp
n=min(n,(long long) 1e5); //1e5是double类型，min函数只支持同类型运算所以要强转long long
```
这道题就顺利 **AC** 了。



---

## 作者：AndyPomeloMars (赞：3)

## P1920 成功密码

### 题目大意

* 给出 $x$ 和 $N$，求出 $\sum_{i=1}^{N}\frac{x^{i}}{i}$。

* 其中 $N\le10^{18}$，$0<x\le1$，$x$ **最多仅有 4 位小数位**。

### 题目分析

由题目可知 $N\le10^{18}$，所以暴力循环肯定是不行的，开 O2 应该也是满江黑（~~我也不知道那是紫还是黑~~）。所以我们需要简化这个题目。

进一步了解题目，发现 $0<x\le1$ 这个条件；那么可以推出 $x^{i} \leq 1$ 这个命题是肯定能成立的，且 $x^{i}$ 随    $i$ 的增大而减小。

#### ForExample：

* 当 $x = 0.5$，$i = 3$ 时，$x^{i}$ = $0.5^{3} = 0.125$

* 当 $x = 0.5$，$i = 4$ 时，$x^{i}$ = $0.5^{3} = 0.0625$

* 当 $x = 0.5$，$i = 5$ 时，$x^{i}$ = $0.5^{3} = 0.03125$

所以题目中的 $\frac{x^{i}}{i}$ 是随着 $i$ 的增大而逐渐接近于 $0$。

#### ForExample：

* 当 $x = 0.5$ 时，$i = 3$ 时，$\frac{x^{i}}{i}$ = $0.5^{3} \div 3 = 0.04166667$

* 当 $x = 0.5$ 时，$i = 4$ 时，$\frac{x^{i}}{i}$ = $0.5^{3} \div 4 = 0.015625$

* 当 $x = 0.5$ 时，$i = 5$ 时，$\frac{x^{i}}{i}$ = $0.5^{3} \div 5 = 0.00625$

### 题目结论

随着 $i$ 的增大，$\frac{x^{i}}{i}$ 就会越来越小，到了一定程度了就不会影响 $ANS$ 的值。

因为题目说明 $x$ **最多仅有 4 位小数位**，所以 $LIM=10^5$ 即可。

得出：当 $N$ 大于 $LIM$ 时，$N$ 等于 $LIM$。

通过这种方法，将 $N$ 控制在 $10^5$ 之内，可以保证不超时通过这个题目。

（控制小数位可以使用 `printf` 或者 `setprecision`）。

### 题目代码

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;

const long long LIM = 100000; // 最大限制

double X, ANS; // 注意 X 和 ANS 一定要开 double
long long N; // 题目范围 N <= 10 ^ 18

int main(){
    cin >> X >> N;
    N = min(N, LIM); // 当 N 大于 LIM 时 N 等于 LIM
    for (int i = 1; i <= N; ++i) ANS += pow(X, i) / i; // 计算答案
    cout << fixed << setprecision(4) << ANS << endl; // 使用 iomanip 的 setprecision 来控制小数位数
    return 0;
}
```

如果文章有不对或值得改进的地方，欢迎私信我。

---

## 作者：Great_Influence (赞：3)

这道题目其实没有这么难。。。。楼下都是求导啊，泰勒展开啊，各种优化，至于吗。。。。。。

这道题目其实只要不超时就行了，没必要将时间卡的那么死。

其实仔细看的就会发现，他的公式是x^i/i，这个数越到后面越小。而通过实测，0.9999^72173/72173之后的项对答案没有影响，可以被忽略。时间复杂度：min(O(nlogn),O(72173log72173))

代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define For(i,a,b) for(i=(a);i<=(b);++i)
using namespace std;
const int MAXN=300;
typedef unsigned long long ull;
template<typename T>
inline void read(T &x)//快速读入
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=(s<<3)+(s<<1)+(k^48);
        k=getchar();
    }
    x=s*f;
}
ull n;
double x,ans;
double power(double a,ull b)//快速幂，毕竟还有70000多次方
{
    if(b==1ll)return a;
    if(b&1)return power(a*a,b>>1)*a;
    return power(a*a,b>>1);
}
const int Max=72173;
int main()
{
    scanf("%lf",&x);
    read(n);
    if(n>Max)n=Max;//暴力忽视
    double i;
    For(i,1.0,n)ans+=power(x,i)/i;//暴力计算
    printf("%.4lf\n",ans);
    return 0;
}
```

---

## 作者：Pethly_Cat (赞：2)

看到这一题的我，一看数据范围：哎竟然只有$10^6$，不打暴力怎么行？

打了一半，把题目往下一拉，看到了这行字：

对于100%的数据：$N≤10^{18},0<x≤1,x$ 最多仅有4位小数位。

呃······

---------------------------------------------------------华丽的分割线----------------------------------------------------------

因为我毕竟是个蒟蒻吗，先把暴力水水看再说。

于是，一个 $30$ 分代码完美出炉：

```cpp
#include<bits/stdc++.h>
using namespace std;
double x,sum;
long long n;
int main()
{
    cin>>x>>n;
    for(int i=1;i<=n;i++)
    sum+=pow(x,i)/i;
    printf("%.4lf\n",sum);
    return 0;
}
```

后面 $7$ 个点完全T飞了······

一般TLE有这三种原因：

1.有重复的运算。

2.有多余的运算。

3.输入/输出速度不够快。

很显然，这题有了多余的运算。题目要求保留四位小数，但是 $i$ 循环到后面时，已经影响不到了前面的数位。所以，$i$ 循环到 $100000$ 的时候就可以止步了。

AC代码如下：

```
#include<bits/stdc++.h>
using namespace std;
double x,sum;
long long n;
double poww(double a,long long b)
{
	if(b==1) return a;
	if(b%2) return poww(a*a,b>>1)*a;
    return poww(a*a,b>>1);
}
int main()
{
	cin>>x>>n;
	for(double i=1.0;i<=(double)n;i++){
		if(i>100000) break;
		sum+=poww(x,i)/i;
	}
	printf("%.4lf",sum);
	return 0;
}
```

---

## 作者：WanderingTrader (赞：2)

update 2020/5/13 对AC代码中的TYPO进行修正  
这是博主第一篇文章，请大家多多支持  
看到$10^{18}$的数据，我们就知道模拟不行了。  
不过我们发现$0< x\le1$，意味着当随着$i$的增大，$\frac{x^i}{i}$越来越小。尽管$N$可以非常大，但是当$\frac{x^i}{i}$小于一个恒定值时，它以及它后面的数据对前$4$位无影响，所以可以控制精度来控制枚举个数。  
枚举每一个$\frac{x^i}{i}$并将其加入最终答案，直至其小于一个常量$MIN$  
所以很容易写成下面的代码：
```cpp
	double x,k = 1,ans = 0,t;
	long long n;
	scanf("%lf%lld",&x,&n);
	for(long long i = 1;i <= n;i ++)
	{
		k *= x;
		t = k / i;
		ans += t;
		if(t < MIN) break;  //控制精度
	}
	printf("%.4lf\n",ans);

```
那么$MIN$取多少较为合适呢？因为保留$4$位小数，保守一点，我们取$4\times3 = 12$位，即$MIN = 10^{-12}$  
这样就可以在时限内解决了。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MIN 1e-12
int main(){
	double x,k = 1,ans = 0,t;
	long long n;
	scanf("%lf%lld",&x,&n);
	for(long long i = 1;i <= n;i ++)
	{
		k *= x;
		t = k / i;
		ans += t;
		if(t < MIN) break;
	}
	printf("%.4lf\n",ans);
	return 0;
}
```

---

## 作者：timetravler (赞：2)

当初一看到这道题，我的第一反应是卧槽怎么能这么水，然后我就被坑了。。。。

首先，关于这个segema。。。。半天才反应过来是求和。

然后就是题解了\(^o^)/毫无疑问，要用到快速幂，然后我就直接循环+快速幂。一交，果然T了，[delete]没错我就是来拉低平均分的[/delete]。然后就要优化了。。一开始我想用一个数组a[i]记录x的i次方，开了200w，然而并没有什么卵用，还是T。。。/(ㄒoㄒ)/~~

然后就用各种奇奇怪怪的方法，其中一种就是我发现当i变大时，ans的值增长速度会逐渐减慢，最后前4位会不变，当ａｎｓ的值不变时跳出循环就ok了！！







但是！！！这次虽然没有Ｔ，但是ＷＡ了。。。在我千辛万苦的ＤＥＢＵＧ下，终于让我发现了问题，就是虽然ａｎｓ的值在现在不会变，但是如果继续运行足够次数的话还是会变，在经过多次试验后，终于让我找到合适的阈（ｙｕ）值。详细见代码

```cpp

#include<iostream>
#include<cstdlib>
#include<algorithm>
#include<stdio.h>
#include<math.h>
using namespace std;
double x,ans;
unsigned long long n;
int v[100001];
double quick(double a,unsigned long long b)
{
    if(b==1)
      return a;
    else
    {
      double c=quick(a,b/2);
      if(b&1)
          return c*c*a;
      else return c*c;
    }
}
int main()
{
    scanf("%lf%ull",&x,&n);
    unsigned long long i;
    for(i=1;i<=n;i++)
    {
        double b=quick(x,i);
        ans+=b/i;
        int a=ans*10000;
        if(v[a])
          break;
        v[a]=1;
    }
    int j=i;
    for(j=i+1;j<=i+100000&&j<=n;j++)
    {
        double b=quick(x,j);
        ans+=b/j;
    }
    printf("%.4f",ans);
    return 0;
}
```

---

## 作者：zljhenry (赞：1)

一道还行的数论题。

难点主要是在特判和快速幂上 首先介绍一下这个符号：$\sum$

$\sum$ 是一个求和符号，英语名称：Sigma，汉语名称：西格玛。

$\sum_{i=1}^{n}k$ 的意思是：其中 $i$ 表示下界，$n$ 表示上界，$k$ 从 $i$ 开始取数，一直取到 $n$，全部加起来。

所以本题就是求 $\dfrac{x^1}{1}+\dfrac{x^2}{2}+\dfrac{x^3}{3}+...+\dfrac{x^n}{n}$

 
那不就简单了吗，直接暴力。但是因为数据大，只能过3个点。

所以这里可以用快速幂：

```cpp
int mi(int a,int b){
    int ans=1;
    while(b!=0){
        if(b&1) ans=ans*a;
        a=a*a;
        b=b>>1;
    }
    return ans;
}
```

还是只过了3个，其他 TLE。

单看这里的 $k$，是一个除法：

（这里假设 $x$ 为 0.9999。）

- 当 i=1 时,原式 = $\tfrac{0.9999^1}{1}=0.9999 $

- 当 i=2 时,原式 = $\tfrac{0.9999^2}{2}\approx 0.4999 $



- 当 i=100 时,原式 = $\tfrac{0.9999^{100}}{100} \approx 0.0099 $

- 当 i=1000 时,原式 = $\tfrac{0.9999^{1000}}{1000}\approx 9.048e-4 $


显而易见，$i$ 越大，整体的值越小，又因为要精确到4位小数，所以当 $n$ 足够大时，就可以将它变小（当 $n>t$ 时就把 $n$ 设为 $t$）。


AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double sum=0;//别写成int
double mi(double a,long long b){
	double ans=1;
	while(b!=0){
		if(b&1) ans=ans*a;
		a=a*a;
		b=b>>1;
	}
	return ans;
}//快速幂，用递归的也可以。

int main(){
	double x;
	long long n;
	cin>>x>>n;
	if(n>80000) n=80000;//特判，这里80000左右都可以
	for(int i=1;i<=n;i++){
		sum+=mi(x,i)/i;
	}//累加
	printf("%.4lf",sum);

	return 0;
} 
```

~~本蒟蒻的第一篇题解~~

---

## 作者：KesdiaelKen (赞：1)

？这是什么神仙题目……

乍看本题好像是个数论题，然后发现很难做，又注意到题目只要求保留4位小数，且$x\le 1$，所以$x^i\le1$，所以当$i$很大的时候，此时的$\frac{x^i}{i}$可以忽略不计。

因此，我们循环累计答案时不需要跑完$n$个$i$，在合适的地方停止即可。本人是取到$i=10^7$的时候停止循环，当然也可能更小。

下面上题解中最短的代码：

```
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
#include<string>
#include<map>
using namespace std;
int main()
{
	double n,x,xx;scanf("%lf%lf",&x,&n);
	double da=0;xx=x;
	for(double i=1;i<=min(n,10000000.0);i++)
	{
		da+=xx/i;
		xx*=x;
	}
	printf("%.4lf\n",da);
	return 0;
}
```


---

## 作者：ccg12345 (赞：0)

## 思路

本题是一道**数学题**。

拿道题先看一看数据范围：$n \le 10^{18}$，直接模拟显然是不行的。所以要用数学的魔法打败它，再看一看数据范围：$0 \le x \le 1$。考虑当 $i$ 变大时，$\frac{x^i}{i}$ 的变化趋势，显然在 $i$ 变大的同时，$x^i$ 也会变小，那么 $\frac{x^i}{i}$ 也会变小，最后加的值就会趋近于一个极限。

关键来了：**如何求这个极限?**

看着式子，不难联想到**泰勒公式**：

$$\ln(1-x) = x + \frac{x^2}{2} + \frac{x^3}{3} + \frac{x^4}{4} + \cdots (0 \le x \le 1)$$

那么我们就可以先用 cmath 库中的 log 函数将 $\ln(1-x)$ 求出来，记为 $t$，然后从 $1$ 开始枚举如果乘 $10000$ 与 $t \times 10000$ 进行比较，如果完全相同就退出循环即可。

附代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
	double x, ans = 0.0, cnt = 1.0;
	int n;
	cin >> x >> n;	
	double t = -log(1.0 - x);
	for(register int i = 1; i <= n; i++)
	{
		cnt *= x;
		ans += cnt / i;
		if(round(ans * 10000.0) >= round(t * 10000.0))
			break;
	}
	cout << fixed << setprecision(4) << ans << endl;
}
```


---

## 作者：Kiloio (赞：0)

### 这题有点坑。  
我们看一下**数据范围**，$N$的数据范围明显限制了我们不能**直接模拟**。   

但我们还是先试一下直接模拟，方便后面再去想正解。

**直接模拟**倒很简单，直接**照着公式**打下来便可。  
代码：
```
#include <bits/stdc++.h>
using namespace std;
long long N;
double x,ans;
int main(){
	cin>>x>>N;
	for(int i=1; i<=N; i++){
		ans+=pow(x,i)/i;
	}
	printf("%.4lf",ans);
	return 0;
}
```
$30$分，剩下$70$分$TLE$了。  
  
- 这样暴力就是明显不行的了，但我们看看会不会有**针对大数据的特殊情况**：    

在**答案保证在4位小数内**时,我们会发现**随着**$i$**的增大**，$x^i$**会随之变小**。  
这样下去，到**一定程度后**，答案值便**不会再改变了**。  

就加个**特判**，判断$n$大到一定程度后，就直接把$n$赋值为**程序所能处理的最大值。**

AC代码：
```
#include <bits/stdc++.h>
using namespace std;
long long N;
double x,ans;//x和ans都要开double 
int main(){
	cin>>x>>N;
	if(N>10000000){//特判，不一定要大于10000000，反正设大。 
		N=100000;
	}
	for(int i=1; i<=N; i++){//直接模拟 
		ans+=pow(x,i)/i;
	}
	printf("%.4lf",ans);
	//cout<<fixed<<setprecision(4)<<ans; cout的保留小数 
	return 0;
}

```


---

## 作者：BreakPlus (赞：0)

### Part 1 $30\text{pts}$ 写法

因为 $n$ 在 $10^6$ 范围内，于是立刻想到 $\operatorname{O}(n)$ 的暴力写法。

【防抄袭】代码：

![](https://cdn.luogu.com.cn/upload/image_hosting/64fg18bw.png)

这样可以拿到 30pts。

### Part 2 $100\text{pts}$ 写法

再来看一下这个式子。

随着 $i$ 的不断增加，每次累加的值会越来越小，直到趋近于 $0$。我们猜想，到了一定程度后，小数点后的四位数就不会改变了。

可是！当 $n \to \infty$ 并且 $x=1$ 的时候，这个式子是发散的（惊恐.jpg）。

但是！$n$ 最大只有 $10^{18}$，因为这个式子发散的很缓慢，我们的想法可以实现（狂喜.jpg）。

最后，这个“到了一定程度后”是多少呢？我们用极限数据去推算，运算大约$8\times 10^4$ 之后，小数点后四位数就不会变了。

只要稍稍加些改进就行了。

【防抄袭】代码：

![](https://cdn.luogu.com.cn/upload/image_hosting/r57r9e3j.png)

### Part 3 某些优化

因为数据很良（凉）心，上面的代码可以过。

其实我们在循环时可以记录 $x^{i-1}$ ，当前运算需要的 $x^i=x^{i-1}\times x$，这样复杂度可以降低至 $\operatorname{O}(\min(n,8 \times10^4))$。

~~reader：这么简单的优化方法你还要说？~~

----

愉快地结束辣！

---

## 作者：xiezihan (赞：0)

上一个**c语言**的，~~应该能过吧~~



------------


老规矩，先解释一下题目意思........说白了就是求和吗， 解释一下∑的意思，毕竟我们这些小学生（指年龄）还没学过呢

```cpp
大写∑用于数百学上的总和符号，比如：∑Pi，其中i=1,2,...,T，即为求P1 + P2 + ... + PT的和。
```
来源：百度知道



------------
这道题的做法模拟？看一下时限溜了溜了

再看一眼，发现是数论，上手做做就行了，其实不需要跑到n和i，因为数据（小声BB）

通过分析可以列出以下算式

```c
s+=ans/i;
ans*=x;
```



------------

不多说了，上AC代码

```c
#include<stdio.h>
int main()
{
	double x,n,ans,i,s;
	scanf("%lf%lf",&x,&n);
	s=0;
	ans=x;
	if(n>10000005.0)n=10000005.0;//卡数据，只会到10000005.0（危险言论）
	for(i=1;i<=n;i++)
	{
  		s+=ans/i;
		ans*=x;//同上
     		
	}
	printf("%.4lf\n",s);
    return 0;
}
}
```

[AC记录](https://www.luogu.com.cn/record/33935742)


---

## 作者：critnos (赞：0)

简单说一下做法

因为这个 $x<1$，所以 $\dfrac {x^i} i$ 在 $i$ 稍大的时候就已经极其接近 $0$。

然后答案只用保留 $4$ 位小数，所以对于 $i$ 大的可以不用算。

式子就变成了 $\sum_{i=1}^{\min(N,C)}\dfrac {x^i} i$。

$C$ 是常数，平衡速度和精度后可以取 $10^5$。

连快速幂都不用直接大力 pow 就行。

---


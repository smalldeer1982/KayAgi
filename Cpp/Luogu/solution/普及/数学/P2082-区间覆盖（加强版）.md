# 区间覆盖（加强版）

## 题目描述

已知有 $N$ 个区间，每个区间的范围是 $[s_i,t_i]$，请求出区间覆盖后的总长。

## 说明/提示

对于 $40 \%$ 的数据，$N \le 1000$，$1 \le s_i < t_i \le 10000$。

对于 $100 \%$ 的数据 ，$N \le 10^5$，$1 \le s_i < t_i \le 10^{17}$。

## 样例 #1

### 输入

```
3
1 100000
200001 1000000
100000000 100000001```

### 输出

```
900002```

# 题解

## 作者：yummy (赞：26)

**Updated at 2024.2.2：针对题解区的 Hack 进行了修改。**

粗看一眼题目，咦，这不是校门外的树吗？

再看一眼题目，咦，我不是出过一道[一模一样的题](https://www.luogu.org/problemnew/show/U59472)吗？

啊哈哈，双倍经验！！！

考虑括号匹配的过程。

每一个区间都是一对括号。例如 $[1,5]$ 这个区间，就是在数轴上 $1$ 的位置放上左括号，$5$ 的位置放上右括号。

那么，哪些位置是被覆盖的呢？显然，如果一个点被**至少一对括号**经过，这个点就是被覆盖的。被几对括号经过，就是被几次覆盖的。

For Example（来自P1047）：

```cpp
3
150 300
100 200
470 471
-------100----150---200-----300--------470--471--
--------(------(-----)-------)----------(----)---
00000000(111111(22222)1111111)0000000000(1111)000
```
我们惊喜地发现，这就是一个括弧匹配问题！！！

我们用一个变量表示左括号个数，我们不停地为第一个左括号找到匹配的右括号，并加上这一段的总长度。

这时候我们要考虑一个细节——对于坐标相同的左右括号，我们应该把谁放在前面呢？

如果是严格地求线段长度其实是无所谓的——不管你把一条线段从共有部分断开还是不断开，答案都是 $r-l$——但是这里不一样，当左右端点重合时，答案线段**必须不断开**。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct p1047//没错，一开始只是想写一个校门外的树plus
{
    long long num;
    bool t;//0表示这是一个左括号，1表示右括号
}p,a[200005];
bool cmp(p1047 x,p1047 y)
{
    if(x.num==y.num)
        return x.t<y.t;
    return x.num<y.num;
}
int main()
{
    int m,x;
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%lld%lld",&a[i*2-1].num,&a[i*2].num);
        //每个区间由一个左括号和一个右括号组成
        a[i*2-1].t=0;
        a[i*2].t=1;
    }
    sort(a+1,a+m*2+1,cmp);//对所有括号排序
    long long st=a[1].num;//第一个左括号
    int cs=1;//剩余括号数量
    long long tot=0;//总长度
    for(int i=2;i<=m*2;i++)
    {
        if(a[i].t==0)//左括号
            cs++;
        else//右括号
            cs--;
        if(cs==0)//一段区间结束，结算
        {
            tot+=a[i].num-st+1;
            st=a[i+1].num;
            //加入下一个左括号
        }
    }
    cout<<tot;
    return 0;
}
```

---

## 作者：按Ctrl加w会AC (赞：22)

### 贪心
#### 将 $l$ 排序，然后从左到右维护 $max\_R$ 表示已经贪心到的最右端的边界+$1$，如果当前的右边界大于等于 $max\_R$ 就加上区间长度，减去重复覆盖的累计答案更新 $max\_R$
代码如下：
```
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define INF 0x7FFFFFFFFFFFFFFFll
using namespace std;
typedef long long ll;
const int MAXN=1e5+5;
int n;
struct SEG{
	ll l,r;
	bool operator <(const SEG v)const{return l<v.l;}
} A[MAXN];
int main(){
	cin>>n;
	for (int i=1;i<=n;i++) cin>>A[i].l>>A[i].r;
	sort(A+1,A+1+n);
	ll max_R=-INF,ans=0;
	for (int i=1;i<=n;i++)
		if (max_R<=A[i].r) ans+=A[i].r-max(max_R,A[i].l)+1,max_R=A[i].r+1;
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：issue_is_fw (赞：9)

## 不是新思路，但是代码和思路要更加清晰

先按照端点L从小到大排序

然后设置一个右端点$rr$初始化为$a[1].r$,表示当前区间最右的点

那么每一个区间的贡献如下:

### 一、如果$a[i].l>rr$,那么整段区间都有贡献，直接加上

### 二、否则如果$a[i].r>rr$,说明区间从$rr+1$到$a[i].r$有贡献

#### 三、每次更新最右的端点$rr$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct p{
	ll l,r;
}a[100009];int n;
bool com(p a,p b){
	if(a.l==b.l)	return a.r<b.r;
	return a.l<b.l;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)	scanf("%lld%lld",&a[i].l,&a[i].r);
	sort(a+1,a+1+n,com);
	ll ans=a[1].r-a[1].l+1,rr=a[1].r;
	for(int i=2;i<=n;i++)
	{
		if(a[i].l>rr)	ans+=a[i].r-a[i].l+1;
		else if(a[i].r>rr)	ans+=a[i].r-max(a[i].l,rr);
		rr=max(rr,a[i].r);
	}
	cout<<ans;
}
```
管理大大求过~~~~~~```````

---

## 作者：k2saki (赞：8)

我看着大佬们的贪心，STL等神仙解法，我就发一篇相对暴力的解法吧。

思路：先把所有都设为0，覆盖的区间则变为1。

## 区间赋值？你想到什么？

## 没错！就是ODT

ODT(Old Driver Tree老司机树)，又叫珂朵莉树，这个毒瘤算法由[CodeForces - 896C Willem, Chtholly and Seniorious](https://www.luogu.org/problem/CF896C)的正解衍化而来。

## 什么时候用珂朵莉树？

珂朵莉树最支持的是区间推平操作。

## 初始化：

```cpp
struct node{
	int l,r;
	mutable  int v;
	node (int ll,int rr=-1,int vv=0): l(ll),r(rr),v(vv){	}
	bool operator < (const node &u)const
	{
		return l<u.l;
	}
};
set<node>se;
```

这里珂朵莉树用一个set来维护

## 分裂操作：
```cpp
itt sp(int op)
{
	itt it=se.lower_bound(node(op));
	if(it!=se.end()&&it->l==op) return it;
	it--;
	int ll=it->l,rr=it->r,vv=it->v;
	se.erase(it);
	se.insert(node(ll,op-1,vv));
	return se.insert(node(op,rr,vv)).first;//返回迭代器
}
```
返回以s为左端点的迭代器

下面是最毒瘤的操作：

# 区间推平

```cpp
#define itt set<node>::iterator
```


```cpp
void ass(int ll,int rr,int vv)
{
	itt ir=sp(rr+1),il=sp(ll);
	se.erase(il,ir);
	se.insert(node(ll,rr,vv));
}
```

在这里运用到了set的erase，可以删除某一段区间

这个操作的复杂度，因为窝太菜了，所以就借用[这个大佬的博客](https://blog.csdn.net/niiick/article/details/83062256)的一句话吧。

### 在数据纯随机的情况下，可以证明每次ass的区间长度期望为N/3
### 于是set规模迅速下降，随后达到接近O(mlogn)的玄学非正确复杂度

ODT还有区间加，区间减，今天就先不讲了，这道题需要查找[1,1e17]中的1的个数。

需要这样的函数

```cpp
int cnt(int l,int r)
{
	int ans=0;
	itt ir=sp(r+1),il=sp(l);
	for(;il!=ir;il++)
	{
		ans=(ans+(int)(il->r-il->l+1)*(il->v));
	}
	return ans;
}
```

#### 好了，ODT的基本内容就讲完了，附AC代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define itt set<node>::iterator
using namespace std;

int n,m;

int a[1000001];

struct node{
	int l,r;
	mutable  int v;
	node (int ll,int rr=-1,int vv=0): l(ll),r(rr),v(vv){	}
	bool operator < (const node &u)const
	{
		return l<u.l;
	}
};
set<node>se;

itt sp(int op)
{
	itt it=se.lower_bound(node(op));
	if(it!=se.end()&&it->l==op) return it;
	it--;
	int ll=it->l,rr=it->r,vv=it->v;
	se.erase(it);
	se.insert(node(ll,op-1,vv));
	return se.insert(node(op,rr,vv)).first;
}


void ass(int ll,int rr,int vv)
{
	itt ir=sp(rr+1),il=sp(ll);
	se.erase(il,ir);
	se.insert(node(ll,rr,vv));
}

int cnt(int l,int r)
{
	int ans=0;
	itt ir=sp(r+1),il=sp(l);//两个端点的分裂操作
	for(;il!=ir;il++)
	{
		ans=(ans+(int)(il->r-il->l+1)*(il->v));
	}
	return ans;
}


signed main() {
	se.insert(node(0,1e17+1,0));
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		int uu,vv;
		cin>>uu>>vv;
		ass(uu,vv,1);
	}
	cout<<cnt(1,1e17+1);
	return 0;
}
```
希望大家看完我的题解后，能越来越强，AK IOI哦

~~长度竟然已经2854了，OrzOrz~~

### 完结撒花！


---

## 作者：Na2PtCl6 (赞：5)

## 题意简述
在一条无限长的直线上，有一些线段，这些线段的两头都用整数表示。现在，要你求这些线段覆盖的总长。

## 分析题目

不难发现，题意中，线段的位置关系有3种

**1.一条线段在另一条内部，简称重合**

**2.一条线段和另一条有接触的部分，但不完全重合，这种情况简称相接**

**3.一条线段和另一条完全没有接触部分，称为相隔**

（以上并非标准术语，本人瞎编的）

于是可以得出：

**当我们发现两条线段重合时，舍去较短的一条**

**如果发现有相接的线段，我们就锁定相接的线段中较靠右的一条，寻找与之相接的线段，一直下循环去**

**如果发现没有与当前线段相接的线段，就把结果加上目前找到线段的长度**

有了这些，我们就可以用以下步骤，愉快对AC本题了。

**1.对线段进行排序（第一关键字为前端，第二关键字为后端）**

**2.对于重合的线段，把较小的那条舍去**

**3.O(n)的遍历，链接相接的线段，求出覆盖总长**
## 代码
### 去重
```cpp
	//先让第一段线段进入最终遍历的数组，排序保证了此操作的正确性 
	v.push_back(list[0]);
	for(int i=1;i<n;i++){
		//判断这条线段是否与前面一条重合 
		if(v.back().begin<=list[i].begin&&
		v.back().end>=list[i].end)
			continue;
		v.push_back(list[i]);
	}
```
### 遍历
```cpp
int sz=v.size();
	int i=0,j=0;
	//i是要连在一起的线段的起始线段,j是结尾线段 
	while(i<sz){
		j=i; 
		//相接的定义 
		while(v[j].end>=v[j+1].begin&&j<sz-1)
			++j;
		//加上当前线段长度
		res+=v[j].end-v[i].begin+1; 
		//把i更新到j的下一个，成为下一个起始线段
		i=j+1; 
	}
```

### 完整代码
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int n,res;
struct sub {long long begin,end;}list[100004];
vector < sub > v;

bool cmp(const sub &a,const sub &b){
	if(a.begin==b.begin)
		return a.end<b.end;
	return a.begin<b.begin;
} 

int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%lld",&list[i].begin);
		scanf("%lld",&list[i].end);
	}
	sort(list,list+n,cmp);
	//先让第一段线段进入最终遍历的数组，排序保证了此操作的正确性 
	v.push_back(list[0]);
	for(int i=1;i<n;i++){
		//判断这条线段是否与前面一条重合 
		if(v.back().begin<=list[i].begin&&
		v.back().end>=list[i].end)
			continue;
		v.push_back(list[i]);
	}
	int sz=v.size();
	int i=0,j=0;
	//i是要连在一起的线段的起始线段,j是结尾线段 
	while(i<sz){
		j=i; 
		//相接的定义 
		while(v[j].end>=v[j+1].begin&&j<sz-1)
			++j;
		//加上当前线段长度
		res+=v[j].end-v[i].begin+1; 
		//把i更新到j的下一个，成为下一个起始线段
		i=j+1; 
	}
	printf("%lld",res); 
	return 0;
}
```

感谢您的耐心阅读

---

## 作者：judgejudge (赞：5)

# 区间二分线段树
一看到区间，马上想到线段树。
本题分两块：

1. **放区间**
1. **查找区间，计算和**


------------
## 一、放区间
我们通过二分进行实现。

首先，我们默认这个区间在l-r的范围内，然后不断区间进行二分。把这个区间**分为左右两部分。（l——mid，mid+1——-r）**

分情况讨论：

1. 如果要放入的区间**全部在左半部分，递归，对左半部分二分**
1. 如果要放入的区间**全部在右半部分，递归，对右半部分二分**
1. 如果**涵盖了左右部分，以mid为界，分成左右两部分，分别对这两个部分二分**
```cpp
inline void inst(ll p,ll l,ll r,ll sl,ll sr){
	ll ll=-1,lr=-1,rl=-1,rr=-1,mid;
	if(l==sl&&r==sr)a[p].data++;//是要放入的区间，++
	else{
		mid=(l+r)/2;//二分
		if(sr<=mid)ll=sl,lr=sr;//全在左半部分
		if(sl>mid)rl=sl,rr=sr;//全在右半部分
		if(sl<=mid&&sr>mid)ll=sl,lr=mid,rl=mid+1,rr=sr;//左右都有
		if(ll!=-1){//递归左部分
			if(a[p].lf==0){
				an++;a[p].lf=an;//建立相对平衡的线段树
				a[an].lf=0;a[an].rt=0;a[an].data=0;
			}
			inst(a[p].lf,l,mid,ll,lr);
		}
		if(rr!=-1){//递归右部分
			if(a[p].rt==0){
				an++;a[p].rt=an;
				a[an].lf=0;a[an].rt=0;a[an].data=0;
			}
			inst(a[p].rt,mid+1,r,rl,rr);
		}
	}
}
```


------------
## 二、查找区间
对初始区间不断二分，如果发现有存储过区间，求差值之和，输出。
```cpp
inline void prt(ll p,ll l,ll r){
	if(p>0)//是否拓展过点
	    if(a[p].data>0)ans+=(r-l+1);//存储过区间
	    else{
	    	ll mid=(l+r)/2;//二分
	    	prt(a[p].lf,l,mid);//查左边
	    	prt(a[p].rt,mid+1,r);//查右边
		}
}
```
源代码：
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
struct node{
	ll lf,rt,data;
}a[10000001];
ll minl=0,maxl=10000000000000001,ans,n,an=1;//根据题中条件定合适范围
inline void inst(ll p,ll l,ll r,ll sl,ll sr){//放区间
	ll ll=-1,lr=-1,rl=-1,rr=-1,mid;
	if(l==sl&&r==sr)a[p].data++;
	else{
		mid=(l+r)/2;
		if(sr<=mid)ll=sl,lr=sr;
		if(sl>mid)rl=sl,rr=sr;
		if(sl<=mid&&sr>mid)ll=sl,lr=mid,rl=mid+1,rr=sr;
		if(ll!=-1){
			if(a[p].lf==0){
				an++;a[p].lf=an;
				a[an].lf=0;a[an].rt=0;a[an].data=0;
			}
			inst(a[p].lf,l,mid,ll,lr);
		}
		if(rr!=-1){
			if(a[p].rt==0){
				an++;a[p].rt=an;
				a[an].lf=0;a[an].rt=0;a[an].data=0;
			}
			inst(a[p].rt,mid+1,r,rl,rr);
		}
	}
}
inline void prt(ll p,ll l,ll r){//查找区间
	if(p>0)
	    if(a[p].data>0)ans+=(r-l+1);
	    else{
	    	ll mid=(l+r)/2;
	    	prt(a[p].lf,l,mid);
	    	prt(a[p].rt,mid+1,r);
		}
}
int main(){
	register int i,j,k;
	cin>>n;
	ans=0;
	for(i=1;i<=n;i++){
		ll sl,sr;
		cin>>sl>>sr;
		inst(1,minl,maxl,sl,sr);
	}
	prt(1,minl,maxl);
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：lzy755277 (赞：4)

本题蒟蒻是用贪心的，以下是注意事项：

1.对于读入的l，r按l从小到大排序

2.定义两个变量ll，rr，用于存储当前区间:

如果区间断开（即l>rr）ans+=rr-ll+1，同时更新ll=l，rr=r。否则如果区间重叠if(r>rr)rr=r;

3.数据很大，需用long long;

上代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
inline long long read()
{
    long long k=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){k=k*10+ch-'0';ch=getchar();}
    return k*f;
}//快读
inline void write(long long x)
{
    if(x<0)x=-x,putchar('-');
    if(x>9)write(x/10);putchar(x%10+'0');
}//快输
struct node
{
	int l,r;
}a[100001];//结构体用来更好按l排序
bool cmp(node x,node y)
{
	return x.l<y.l;
}//用来排序的
int main()
{
	long long n,i,ll,rr,m=0;
	n=read();
	for(i=1;i<=n;i++)
	a[i].l=read(),a[i].r=read();
	sort(a+1,a+n+1,cmp);
	ll=a[1].l;rr=a[1].r;//当前区间
	for(i=2;i<=n;i++)
	{
		if(a[i].l>rr)
		{
			m+=rr-ll+1;
			ll=a[i].l;
			rr=a[i].r;
		}//解释见开头
		else
		if(a[i].r>rr)
		rr=a[i].r;
	}
	write(m+rr-ll+1);//完美输出，注意：最后还要加上rr-ll+1。
    return 0;//结束
```
//珍爱账号，远离抄袭

}


---

## 作者：会打沙包的猫 (赞：3)

虽然这道题数据范围很大，能把带权并查集卡到只有50分（一开始确实没想到贪心做法），但是我们还是很有必要学习一下的

### 每一个区间我们可以看成集合
然后我们可以合并相交的集合（并查集），同时维护这些集合的左右界
最后枚举一下所有剩下的集合，累加一下
~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
int fa[100010];
ll le[100010],ri[100010],ans;
struct node
{
	ll left,right;
}ld[100010];
inline bool cmp(node a,node b)
{
	return a.left<b.left;
}
int fin(int x)
{
	if(fa[x]==x)
	  return x;
	return fa[x]=fin(fa[x]);
}
inline void he(int x,int y)
{
	x=fin(x);
    y=fin(y);
    if(x==y)
      return;
    else
      {
      	fa[y]=x;
      	ri[x]=max(ri[x],ri[y]);
      	le[x]=min(le[x],le[y]);
      }
}
int main()
{
	int n;
	//freopen("merge.in","r",stdin);
	//freopen("merge.out","w",stdout);
	cin>>n;
	for(register int i=1;i<=n;i++)
	  fa[i]=i;
	for(register int i=1;i<=n;i++)
	  {
	  	scanf("%lld%lld",&ld[i].left,&ld[i].right);
	  	le[i]=ld[i].left;
	  	ri[i]=ld[i].right;
	  }
	sort(ld+1,ld+n+1,cmp);
	for(register int i=1;i<=n;i++)
	  for(register int j=1;j<i;j++)
	  {
	  	 if(ld[i].left>=ld[j].left&&ld[i].right<=ld[j].right)
			 {
			 	he(i,j);
				 continue;
			 }
	  	 if(ld[i].left>=ld[j].left&&ld[i].right>=ld[j].right&&ld[j].right>=ld[i].left)
	  	   {
	  	   	    he(i,j);
				continue;
	  	   }
	  }
	  for(register int i=1;i<=n;i++)
       {
       	 if(fa[i]==i)
       	   {
       	   	// cout<<le[i]<<" "<<ri[i]<<endl;
       	     ans+=ri[i]-le[i]+1;
       	   }
       }
       cout<<ans<<endl;
       return 0;
}
~~~

---

## 作者：月影困 (赞：2)

某蒟蒻的题解如下OvO


主要是两个步骤：排序，合并。

注释写得挺详细了，直接看代码吧w


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

struct interval//区间结构体，便于排序 
{
    int l, r;
};
interval itv0[112345], itv[112345];//前者用于存储原先的区间，后者用于存储合并后的区间 

bool cmp(const interval &a, const interval &b)//对左端点进行排序
{
    return a.l < b.l;
}

int main()
{
    int n, tot = 0;

    scanf("%d", &n);//输入 
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d", &itv0[i].l, &itv0[i].r);
    }
    
    sort(itv0 + 1, itv0 + n + 1, cmp);//排序 
    
    int sum = 1;//这是合并后区间的数量 
    itv[sum].l = itv0[1].l;//初始化区间 
    itv[sum].r = itv0[1].r;
    for (int i = 2; i <= n; i++)//从第二个区间开始，第一个已经被初始化进itv了OvO 
    {
        if (itv0[i].l > itv[sum].r)//如果左端点大于了之前已合并区间的右端点，说明无法合并了，是一段新的区间 
        {
            sum++;//类似28-30行 
            itv[sum].l = itv0[i].l;
            itv[sum].r = itv0[i].r;
        }
        else
        {
            if (itv[sum].r < itv0[i].r)//如果新区间的右端点长于合并后的原区间，则把合并后的区间右端点扩展至新区间的右端点 
                itv[sum].r = itv0[i].r;
        }
    }
    
    for (int i = 1; i <= sum; i++)
    {
        tot += itv[i].r - itv[i].l + 1;//注意左闭右闭区间的元素个数为r - l + 1 
        //printf("[%d, %d]\n", itv[i].l, itv[i].r);
        //可以printf一下看看合并之后的区间长啥样hhhhh 
    }
    
    printf("%d\n", tot);//输出
    
    return 0;
}
```

---

## 作者：人间凡人 (赞：2)

刚拿到这一题，是不是感觉似曾相识呢。

这就是校门外的树呀！但是如果观察细心的同学，会发现输入的$s[i]$与$t[i]$都有$10^{17}$那么大，直接暴力必然会超时，而且空间也会炸掉。

那么，现在就要请上我们的**贪心**登场了。

思路：我们可以将输入的$s[i]$从小到大排序后，然后就可以每次将$ans+=t[i]-s[i]+1$。

我们还需要考虑一些情况（**易错点**）

$1$、如果当前的数比这时候的$t[i]$大，那么就$continue$。

$2$、如果当前的树比这时候的$s[i]$小，那么就将$x$变为$s[i]$。

$3$、每做完一个$i$后，要将$x$赋值为$t[i]+1$

代码环节：手打的快排，可供参考。

$Code:$

```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
long long l[N],r[N],ans,x;
int n;
long long m;
void qsort(int ll,int rr){
	int i,j,m;
	i=ll;j=rr;m=l[(ll+rr)/2];
	while(i<=j){
		while(l[i]<m)i++;
		while(l[j]>m)j--;
		if(i<=j){
			swap(l[i],l[j]);
			swap(r[i],r[j]);
			i++;j--;
		}
	}
	if(ll<j)qsort(ll,j);
	if(i<rr)qsort(i,rr);
}
int main(){
	scanf("%lld%d",&m,&n);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&l[i],&r[i]);
	qsort(1,n);
	ans=r[1]-l[1]+1;
	x=r[1]+1;
	for(int i=2;i<=n;i++){
		if(x>r[i])continue;
		if(x<l[i])x=l[i];
		ans+=r[i]-x+1;
		x=r[i]+1;
	}
	printf("%lld\n",m-ans+1);
	return 0;
}

```


---

## 作者：✨USTCJYZ✨ (赞：2)

使用STL容器set集合，不仅可以自动排序，还可以把重复的区间略去。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<queue>
#include<map>
#include<sstream>
#include<set>
#include<stack>
#include<iterator>
#include<cctype>
#include<cmath>
#include<cassert>
using namespace std;
#define ll long long
int n;
ll a,b,d=0,l=0;
struct qujian{
	ll a,b;
	qujian(ll a=0,ll b=0):a(a),b(b){}
	bool operator <(const qujian& p)const{
		return a<p.a||(a==p.a&&b<p.b);
	}
};
set<qujian>q;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&a,&b);
		q.insert(qujian(a,b)); 
	}
	for(set<qujian>::iterator it=q.begin();it!=q.end();++it){
		qujian p=*it;
		if(p.b<=d) continue;
		if(p.a<=d)l+=p.b-d;
		else l+=p.b-p.a+1;
		d=p.b;
	}
	cout<<l<<endl;
	return 0;
}
```

---

## 作者：Dr_殇 (赞：2)

##这这这道题不就是一个简单的离散化么，为毛没人写？？？

##题目解析

我们先来用十分简单的思维来想一下。

既然要求覆盖的长度，那么直接写一个桶，然后每读入一段，就在桶里记录一下，不就可以了么？

但是写完之后，评测发现：怎么只有40分？

不过当我们需要认真读题目：

```
【数据范围】

对于40%的数据 N≤1000，0<Si<Ti≤10000

对于100%的数据 N≤10^5，0<Si<Ti≤10^17，且为整数
```

看到了这个数据范围，很容易就能想到离散化。

不过这时又会有人问了：什么是离散化？

#算法扩展 离散化

```
离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。

通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。

以上均摘抄自百度百科
```

当然，上面都是很难理解的科学定义，这里，我就来给大家详细的讲解一下离散化。

先来解读一下上面的定义：

首先“通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。”这句话我们暂时不看~~（反正看了也看不懂）~~。

我们主要注意的应该是“离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。”这一句话。通过这一句话，我们可以知道，离散化可以提高算法的时空效率。

我们这里只是用最简单的离散化，更难一点的还有什么线段树的啊等等，我们这里还用不到。

读懂了定义以后，下面的应该就很好理解了。

我们存储时，并不是按区间存储，而是将每一个点存下，然后给予每个点一个标记，且起点与终点的标记不同。然后将他们按坐标排序，若坐标相等，则终点在前。

接下来我们扫描每一个点，如果第i个点是起点，并且第i-1个点是终点，那么这就是该区间的起点，且第i-1个点是上一个区间的终点。

将每一个合并完了的区间统计一下，求他们的长度和就是答案。

##代码如下

```
//--新阶梯工作室防伪水印--
//--By新阶梯工作室 闪现--
#include <map>
#include <ctime>
#include <cmath>
#include <queue>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>//头文件准备
#define In freopen ("temp.in", "r", stdin)
#define Out freopen ("temp.out", "w", stdout)
#define Put_I(x) printf("%d ",x)
#define Put_L(x) printf("%lld ",x)
#define Enter printf("\n")
#define INF 2147483647
#define I int
#define C char
#define B bool
#define S string
#define D double
#define U unsigned
#define L long long
#define V void
#define IE inline
#define CT const//闪现的宏定义是越来越多了
using namespace std;

I n;
L ans;//答案记得开long long
class T{
public:
	L x;
	B s;
	friend B operator <(CT T t1, CT T t2) {//重载运算符
		if (t1.x == t2.x) return t1.s < t2.s;//坐标一样，终点在前
		return t1.x < t2.x;//否则按坐标排序
	}
}a[200005];//数组需要开2n的空间，因为每个读入的区间有两个点（起点与终点）
IE L Read() {
	L k = 0, t = 1; C c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') t = -1;
		c = getchar();
	}
	while (c <= '9' && c >= '0') {
		k = (k << 3) + (k << 1) + (c ^ 48);
		c = getchar();
	}
	return k * t;
}//快读不解释
IE V Surface();
IE V Init();
IE V Work();
//我的函数喜欢放后面，见谅

I main() {
    In; Out;
    Surface();
    Init();
    Work();
    return 0;
}

IE V Surface() {//打表函数，不过这题没用
}

IE V Init() {//读入
	n = Read();
	for (I i = 1; i <= n; i++) {
		a[i * 2 - 1].x = Read(), a[i * 2 - 1].s = 1;
		a[i * 2].x = Read() + 1, a[i * 2].s = 0;
	}
}

IE V Work() {
	sort(a + 1, a + 1 + n * 2);//别没排序
	for (I i = 1; i <= n * 2; i++) {//输出排序之后的数组
		Put_L(a[i].x), Put_I(a[i].s), Enter;
	}
	L last = 0; I flag = 0;//last为该区间的起点，flag记录状态
	for (I i = 1; i <= n * 2; i++) {
		if (a[i].s == 1) {//如果是起点
			if (!flag) last = a[i].x;//如果是一个新的区间，last更新
			flag++;
		}
		else {//如果是终点
			flag--;
			if (!flag) ans += a[i].x - last;//如果该区间结束了，统计答案
		}
	}
	Put_L(ans), Enter;//输出答案
}
```

###我相信那些抄题解的会收到制裁的QAQ

---

## 作者：SuperJvRuo (赞：2)

操作只有区间赋值，emmm...

## 用珂朵莉树啊！（第一反应真的是这个

[【暴力数据结构Warning】Chtholly Tree珂朵莉树](https://www.luogu.org/blog/ACdreamer/chtholly-tree)

把连续的区间存在```std::set```之中，区间覆盖的时候把这一段```split```出来，然后更改这段区间的```val```。最后把整个```set```遍历一边即可获得答案。

当然这题动态开点线段树也是可以的。

```
#include<cstdio>
#include<cctype>
#include<set>
#define LL long long

using std::set;
#define IT set<node>::iterator

LL Read()
{
	LL x=0;char c=getchar();
	while(!isdigit(c))
	{
		c=getchar();
	}
	while(isdigit(c))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	return x;
}

struct node
{
	LL l,r;
	mutable int v;
    //由于需要修改，此处的v需要mutable修饰
	node(LL L, LL R=-1, int V=0):l(L), r(R), v(V) {}
	bool operator<(const node& o) const
	{
		return l < o.l;
	}
};

set<node> s;

//split(pos)操作将原来含有pos位置的节点分成两部分：[l,pos−1]和[pos,r]
IT split(LL pos)
{
	IT it = s.lower_bound(node(pos));
	if (it != s.end() && it->l == pos) return it;
	--it;
	LL L = it->l, R = it->r;
	LL V = it->v;
	s.erase(it);
	s.insert(node(L, pos-1, V));
	return s.insert(node(pos, R, V)).first;
    //这里利用了pair<iterator,bool> insert (const value_type& val)的返回值
}

void assign_val(LL l, LL r)
{
	IT itr = split(r+1),itl = split(l);
	s.erase(itl, itr);
    //void erase (iterator first, iterator last)可删除[first,last)区间
	s.insert(node(l, r, 1));
}

LL sum(LL l, LL r)
{
	//这个没啥好说的，遍历一遍
	IT itr = split(r+1),itl = split(l);
	LL res = 0;
	for (; itl != itr; ++itl)
		res += itl->v ? itl->r - itl->l + 1 : 0;
	return res;
}

int main()
{
	int n=Read();
	LL l,r;
	s.insert(node(0,1e17+5));
    //插入一个[0,1e17+5]，值全部为0的区间
	while(n--)
	{
		l=Read();
		r=Read();
		assign_val(l,r);
	}
	printf("%lld",sum(0,1e17+3));
	return 0;
}
```

---

## 作者：Taduro (赞：2)

蒟蒻刚学了贪心，发篇题解庆祝一下。

一开始做的时候我以为是跟它的削弱版一样的，于是快乐的按右端点排序，每次发现区间断开（就是发现一个区间的左端点大于现在区间的右端点）就更新现在区间左节点和右节点的值，再将上一个区间的长度加入答案。

于是果断十分~~~

那这是为什么呢？我们想一下

如果是这样：如果按r来排序的话，那么我们得到的长度是r2-l2，但实际上，长度是r2-l1，我们的排序方法导致失去了一部分解。
所以我把cmp函数里的r改成l，竟然AC了（雾）；
![](https://cdn.luogu.com.cn/upload/pic/19365.png)


```
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
struct str{
	long long l; long long r;
}st[100001];
long long i,s,a,maxn,n,m;//为什么要开long long就不用解释了吧
bool cmp(str x,str y){
    return x.l<y.l;//排序
}
int main(){
	cin>>n;
	for (i=1; i<=n; i++)
	  	cin>>st[i].l>>st[i].r;
	sort(st+1,st+n+1,cmp);
	a=st[1].l; s=st[1].r;//a表示区间左端点，s表示右端点（一向不会起变量名）
	for (i=2; i<=n; i++){//m是区间长度，当区间断开时更新端点并计算长度
	if (st[i].l>s){m+=s-a+1; a=st[i].l; s=st[i].r; continue;}
	else 
	  if (st[i].r>s) s=st[i].r;//否则更新右端点
	}
	cout<<m+s-a+1;
	return 0;
}```

~~其实我图里r1,r2标反了~~

---

## 作者：EuphoricStar (赞：1)

## 思路
把一个区间的开始和结束拆开成 $2$ 个点，然后排序，再遍历这 `2*n` 个点。设置一个变量，遇到开始点就 `+1`，遇到结束点就 `-1`。当这个变量从 $1$ 变成 $0$ 的时候就是覆盖后一个整区间的结束，更新答案。

~~双倍经验：[P1204 [USACO1.2]挤牛奶Milking Cows](https://www.luogu.com.cn/problem/P1204)~~

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
struct pt
{
    ll time;
    short type; // 开始点为 1，结束点为 -1
} ps[200020];
int n;
ll begtime, ans, curt, newt;

bool cmp(pt a, pt b)
{
    if (a.time != b.time) return a.time < b.time;
    // 需要保证 +1 的在前面，否则会出现负数的情况
    return a.type > b.type;
}

int main()
{
    ios::sync_with_stdio(0);
    cin >> n;
    for (int i = 0; i < n; ++i)
    {
        cin >> ps[2 * i].time >> ps[2 * i + 1].time;
        ps[2 * i].type = 1, ps[2 * i + 1].type = -1;
    }
    sort(ps, ps + 2 * n, cmp);
    for (int i = 0; i < 2 * n; ++i)
    {
        newt = curt + ps[i].type;
        if (newt == 1 && curt == 0)
            begtime = ps[i].time;             // 更新起始时间
        else if (newt == 0 && curt == 1)
            ans += ps[i].time - begtime + 1;  // 更新答案，注意 +1
        curt = newt;
    }
    cout << ans;
    return 0;
}
```


---


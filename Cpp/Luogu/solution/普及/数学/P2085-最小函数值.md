# 最小函数值

## 题目描述

有 $n$ 个函数，分别为 $F_1,F_2,\dots,F_n$。定义 $F_i(x)=A_ix^2+B_ix+C_i(x\in\mathbb N*)$。给定这些 $A_i$、$B_i$ 和 $C_i$，请求出所有函数的所有函数值中最小的 $m$ 个（如有重复的要输出多个）。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,m\le10000$，$1 \leq A_i\le10,B_i\le100,C_i\le10^4$。

## 样例 #1

### 输入

```
3 10
4 5 3
3 4 5
1 7 1
```

### 输出

```
9 12 12 19 25 29 31 44 45 54```

# 题解

## 作者：Euler_Pursuer (赞：153)

[点击查看题目来源](https://www.luogu.org/problemnew/show/2085)

## Solution

该题目给定了我们一些二次函数，不过这个函数只取了横坐标为正整数部分的值，并且三个系数都为正数，通过代数证明或者图像对称轴分析，都可以肯定，该函数在其定义域（正整数）上，单调递增且恒大于0。

接下来我们再看到题目要求，求这些函数所生成的所有函数值中最小的m个。


#### 暴力求解法

比较暴力的方法是从1开始循环（可能不是最暴力的方法），将1代入所有的函数中，分别得到n个函数值，然后再循环到2，按照这样的方法再来一遍，又有n个函数值，又因为这些都是在其定义域内单调递增的函数，那么首先可以确定1中所有小于等于2中最小函数值的函数值，然后接着按照上述方案做，循环到k时，可以确定从x=1到x=k-1中所有小于等于x=k中最小函数值的函数值，直到确定了m个值。

但是这样的话，思想实在简单，绝配暴力算法一名。暴力之处在于：一、每次求出$ O(n) $的函数值，耗费$ O(n) $的空间，最坏情况下要求$ O(mn) $次，花费$ O(mn) $空间，而数据一大，时间空间无疑是要超出范围的；二、每次循环求出的函数值得进行排序，如果不排序，那个运算量不敢恭维，假设使用$ \Theta (nlgn) $复杂度排序，那么也需要花$ \Theta (mnlgn) $的复杂度；三、再加上每次需要计算x=k中的最小函数值与前面k-1中所有的函数值进行比较，这样在最坏情况下将花费$ O(\sum ^{m-1} _{k=0} (kn))=O((m-1)mn/2)=O(m^2n) $的时间代价。

那么，总的算来，就会消耗$ O(O(mn)+\Theta (mnlgn)+O(m^2n))=O(m^2n) $的时间代价，**极其暴力**！而且空间上的消耗也是**巨大的**！

那么，我们该如何优化呢？


#### 优化的思想

其实，大家看到函数解析式极其定义域就不难知道，他实际上是给了我们n串排好序的数组，只是每个数组中下标与其值存在一定的对应关系。我们由上面所说的可知，对于每个数组，它们的最小值所在的下标都是1。现在，我们可以想象一下，每个数组都有一个箭头，每个箭头都指向1，然后在所有箭头指向的函数值中，找到最小的那个，此时已经找到了1个最小函数值。接着，刚才输出来的值所对应的箭头就要向后移，指向x=2，然后再去和其他箭头指向的函数值比较，以此类推。下面的两个图形象地展现了一部分操作过程。

 ![](https://cdn.luogu.com.cn/upload/pic/11688.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/11689.png) 

那么，现在我们需要将文字描述转化为程序思路。

首先我们需要用三个数组存A、B、C的值，然后需要一个cmin存当前最小值，最后只需要拿一个数组F来表示每个函数中的那个“箭头”所指的位置，那么箭头所指的函数值就会是$ A[k]F[k]^2+B[k]F[k]+C[k] $，至此，思路就很明了了。

下面是我写的程序，很简单，最长耗时测试点用了344ms，没超时。

```cpp
    #include <iostream>
    using namespace std;
    int main()
    {
        int n,m,i,j,cmin,jmin;
        int A[10010], B[10010], C[10010];
        int F[10010];
        cin>>n>>m;
        for(i=0;i<n;i++)
        {
            cin>>A[i]>>B[i]>>C[i];
            F[i]=1;
        }
        for(i=0;i<m;i++)
        {
            cmin=100000000;
            for(j=0;j<n;j++)
            {
                if(A[j]*F[j]*F[j]+B[j]*F[j]+C[j]<cmin)
                {
                    cmin=A[j]*F[j]*F[j]+B[j]*F[j]+C[j];
                    jmin=j;
                }
            }
            cout<<A[jmin]*F[jmin]*F[jmin]+B[jmin]*F[jmin]+C[jmin]<<' ';
            F[jmin]++;
        }
        return 0;
    }
```
该程序的时间复杂度为$ \Theta (mn) $。
大家也许会发现，这里每次都重复计算了很多函数的值，浪费了很多时间，那有没有办法针对这一问题进行优化呢？答案是肯定的。


#### 更优化的解法

对于上述问题的优化方法，比较好的是用堆来做。思路是这样的：首先，我们可以在所有“箭头”指向1的时候，对所有箭头对应的函数值建立小根堆；然后，每次从堆顶取走那个数，并将其所对应的“箭头”指向下一个函数值，然后把这个新的函数值代替那个取走的函数值放在堆顶，并自顶向下维护堆（大家可以证明一下，一直这样操作下去，堆的性质恒成立）。下面是我的参考程序：

```cpp
    #include <iostream>
    using namespace std;
    struct DUI
    {
        int val;//箭头表示的函数值
        int x;//每个函数都有被输入进来的先后顺序，这个是第x个输入进来的函数
        //因为堆里面的节点总是在变化的，所以我们要记录哪个函数在哪个位置
    }a[10010];
    int heap_size;//堆的大小
    void CHANGE(int m, int n)//自己写的交换函数
    {
        int t;
        t=a[m].val;
        a[m].val=a[n].val;
        a[n].val=t;
        t=a[m].x;
        a[m].x=a[n].x;
        a[n].x=t;
    }
    void MIN_HEAPIFY(int i)
    {
        int l=i*2;//右子节点
        int r=i*2+1;//左子节点
        int smallest;//记录父子节点值最小的那个
        if(l<=heap_size&&a[l].val<a[i].val)
            smallest=l;
        else
            smallest=i;
        if(r<=heap_size&&a[r].val<a[smallest].val)
            smallest=r;//父子节点中值最小的位置
        if(smallest!=i)//父节点最大则不变
        {
            CHANGE(i,smallest);//子节点大则交换父子节点
            MIN_HEAPIFY(smallest);//交换后继续往下维护
        }
    }
    void BUILD_HEAP()//建立小根堆
    {
        int i;
        for(i=heap_size/2;i>0;i--)
            MIN_HEAPIFY(i);//自底向上建堆
    }
    int main()
    {
        int n,m,i,j;
        int A[10010], B[10010], C[10010];
        int F[10010];//每个函数的"箭头"位置
        cin>>n>>m;
        for(i=1;i<=n;i++)
        {
            cin>>A[i]>>B[i]>>C[i];
            F[i]=1;
            a[i].val=A[i]*F[i]*F[i]+B[i]*F[i]+C[i];
            a[i].x=i;//输入的顺序，第i个被输进来的
        }
        heap_size=n;
        BUILD_HEAP();
        for(i=0;i<m;i++)
        {
            cout<<a[1].val<<' ';//输出最小函数值
            F[a[1].x]++;//它所在的函数中的"箭头"往后移
            a[1].val=A[a[1].x]*F[a[1].x]*F[a[1].x]+B[a[1].x]*F[a[1].x]+C[a[1].x];//"箭头"变则值变
            MIN_HEAPIFY(1);//自顶向下维护堆
        }
        return 0;
    }
```
该程序的时间复杂度为$ \Theta (nlgn) $或$ \Theta (mlgn) $。程序在洛谷上测试通过了，并且最大耗时的测试点耗时8ms。

#### →注

- 这里涉及到的堆的操作的方法来自《算法导论》。

- 如果有什么错误可以向本人提出，我会做出及时更正。


#### 写在最后

感谢大家的关注和阅读。

本文章借鉴了少许思路，但总体为本人原创，如需转载，请注明出处。


---

## 作者：Altria_Pendragon_ (赞：132)

~~只要有信仰，什么题目都逃不了我骗分的魔爪哈哈哈~~

嗯。。。

首先%%%楼下的各种堆

看来我还是太菜了，所以第一时间就想到了骗分

数据很友好

~~不要直接输出样例啊会有苦头吃的~~

首先算出所有函数值

再排个序

输出前m个函数值

就AC了。。。

[点击查看AC记录](https://www.luogu.org/record/show?rid=5109111 "点击查看AC记录")

上代码（世上最短，没有之一）

```cpp
#include <bits/stdc++.h>//万能头文件
int a[10001],b[10001],c[10001],n,m,s[10000001];
//s是函数值，abc分别代表3个参数
int main(){
    scanf("%d %d",&n,&m);//读入n,m
    for(int i=1;i<=n;i++) scanf("%d %d %d",&a[i],&b[i],&c[i]);//读入3个参数
    for(int i=1;i<=n;i++) for(int j=1;j<=100;j++) s[j+(i-1)*100]=a[i]*j*j+b[i]*j+c[i];//计算
    std::sort(s+1,s+1+n*100);//快排
    for(int i=1;i<=m;i++) printf("%d ",s[i]);//输出}
```
骗分大法好！（此方法仅供无思路时使用，正规考试，请慎用！）


---

## 作者：zhutier (赞：73)

前m小的数，很容易想到 **对顶堆的经典问题第k大数
**并且这题非常良心，m的值不会改变

那么它的思想和**对顶堆**就非常类似了

对顶堆：以求第k大数为例，具体操作需要一个大根堆，一个小根堆。大根堆中存第k+1大到最小的数字，小跟堆中存第一大到第k大数字。每次加入新数字，与小跟堆的top比较，如若比top大，将小根堆的根加入大根堆中，再将小根堆的根pop出来，将要加入的新数字放入小跟堆；如若比小根堆top小，直接加入大根堆。

对顶堆中需要大根堆的原因是它的k根据不同题意可能会改变（比如每次k++啦之类的），而这题的m不会变，所以就不需要存第m+1小到最大的数啦，**直接把它们丢掉好了**

所以我们建一个**大根堆**，存最小的数到第m小的数，第m小的数就理所当然的是堆顶了。
每次我们只需要比较新加进来的数比堆顶大还是比堆顶小，如果比堆顶小，将原来的堆顶丢掉，将新的数塞进去；
如若比堆顶大，根据该题题意，a>0&&b>0，函数对称轴$x=-b/2*a$恒小于0，可以得出，y在x>0时是单调递增的，所以接下来的函数值y只会大不会小，**可以直接break掉了**

由于我们存储的时候用的是大根堆，所以记得要逆序输出，将m个数从小到大输出嗷
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
priority_queue<int> q;
int n,m,a,b,c,ans[100005];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&a,&b,&c);
		for(int j=1;j<=m;j++){
			int k;
			k=a*j*j+b*j+c;//k为函数值y
			if(i==1) q.push(k);
			else{
				if(k<q.top()){
					q.push(k);
					q.pop();
				}
				else break;
         //如果k已经大于第m小的数了，接下来k仍旧单调递增
         //所以可以直接break掉，一个重要的优化
			}
		}
	}
	for(int i=1;i<=m;i++){
		ans[i]=q.top();
		q.pop();
	}//记得要逆着输出！
	for(int i=m;i>=1;i--)
		printf("%d ",ans[i]);	
	return 0;
}
```

---

## 作者：yyy14159 (赞：29)

与“序列合并”一样的思路。易证x=1时各函数值最小，于是先把n个x=1的函数值放入小根堆中，弹出最小的，加入弹出的这个函数值对应的函数，且其自变量是弹出的函数值自变量+1所得到的函数值（好绕）。可以证明（其实只是yy了一下）这个新加入的函数值一定是其他未在堆内的函数值中最小的。这里我用了优先队列的stl和结构体，重载了下运算符。

code：


    
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct func
{
    int a,b,c;
 } f[10004];
struct _value
{
    int num,x,val;
}res[100004];
priority_queue<_value,vector<_value>,less<_value> >q; 
bool operator <(_value a,_value b) {return a.val>b.val;}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&f[i].a ,&f[i].b ,&f[i].c );
        q.push( (_value){i,1,f[i].a +f[i].b +f[i].c});
    }
    for(int i=1;i<=m;i++){
        _value t=q.top();
        q.pop();
        cout<<t.val <<" ";
        q.push((_value){t.num ,t.x +1,f[t.num ].a *(t.x +1)*(t.x +1)+f[t.num ].b *(t.x +1)+f[t.num ].c } );
    }
    return 0;
}
```

---

## 作者：Hoxilon21 (赞：16)

这道题从表面上看起来简单，肯定有很多人忍不住就想用O(n*m)的算法强行暴力。但看到大大的**n，m $\leq$ 10000**时,如果你不想你的屏幕上出现一堆深蓝，请停下你的冲动！！！

事实上，我们只需三个步骤，就能解决这道有趣(~~恶心~~)的题。

**1.分析函数的性质**

首先值得我们注意的是：Ai,Bi,Ci皆是正整数！这一点很重要，虽然说是整数也可以做，但正整数更有利于我们分析题目，减少码量。

我们也可以注意到，F(x)是一个二次函数，这是解题的关键。

**二次函数**是个好东西，让我们来看一下他的函数图像：![](https://cdn.luogu.com.cn/upload/pic/61858.png)

可以发现，**当x>0时,x越大,F(x)越大**（这里就用上了正整数）。（如果你不信，你可以多试几个函数，事实上，这跟二次函数的单调性和对称轴有关，这里不做过多解释）

这就意味着，每个函数的大小顺序都是从1开始，**F(n+1)>F(n) (n$\in$N+)**

接下来，运用以上式子，我们开始第二步。

**2.寻找问题的本质**

题目说要挑出最小的m个函数值，我们可以先从简单分析：**如何挑出最小的一个函数值**

关注的重点：**此时F(x)中的x是多少？**

注意：F(n+1)>F(n),这就说明每个函数都有**x=1时有最小值**！

所以最小值就在Fi(1)中。

那第二小，第三小......第k小怎么取？

此时我们已经把前k-1小的数取出来了。它们已经不能再选了。那么每个函数都必然有一个x未被选过且最小。

再次运用F(n+1)>F(n)，可以推出此时的x满足F(x)是在F函数中未被取过中的最小值。

也就是说：**取下一小的函数值时，我们只需将每一个函数中从小到大第一个未被选的x挑出计算函数值，再比大小，跳出其中最小值即可。而x必然是每次加1的！**

如下图，以样例为例，若我们要取出第五个数![](https://cdn.luogu.com.cn/upload/pic/61861.png)

此时黄色部位皆已经去过，我们只需把每个函数未被染成黄色的最小x得出的F(x)进行比较（图中红色，蓝色部分），挑出其中最小值（图中红色部分）即可。

**3.使用合适的优化算法**

Well done.现在我们已经把这道题的本质琢磨透了。但还需要注意的是：如果我们不进行优化，时间复杂度还是O(m*n)。

时间浪费在哪？问题就在**我们对很多函数值都进行了多次重复排序，而我们只需添加一个数，取出最小值。**

等等，这不就是**堆的用途**吗？

我们只需**把当前需要比较的所有F(x)放入一个小根堆**即可，之后**只需取出堆顶，再把堆顶所在函数的下一个x得出的F(x)放入堆中即可**！

时间复杂度成功被优化至O(m*log(n));

顺利解决！代码如下

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iomanip>
#include<algorithm>
#include<queue>
using namespace std;
#define re register
int l[10005],a[10005],b[10005],c[10005];
struct cmp
{
    bool operator()(const pair<int,int> a,const pair<int,int> b)
    {
        return a.first>b.first;
    }
};
priority_queue<pair<int,int>,vector<pair<int,int> >,cmp> q;
int f(int ma,int mb,int mc,int mx)
{
    return ma*mx*mx+mb*mx+mc;
}
int main()
{
    re int i;
    int n,m;
    cin>>n>>m;
    for(i=1;i<=n;i++)
    {
        cin>>a[i]>>b[i]>>c[i];
        l[i]=1;
        pair<int,int> p;
        p.first=f(a[i],b[i],c[i],l[i]);
        p.second=i;
        q.push(p);
    }
    for(i=1;i<=m;i++)
    {
        pair<int,int> p=q.top();
        q.pop();
        cout<<p.first<<" ";
        int t=p.second;
        l[t]++;
        p.first=f(a[t],b[t],c[t],l[t]);
        q.push(p);
    }
    return 0;
}
```

备注：

1.本题若想用STL，可能需要用到pair，建立pair优先队列可以见[某大佬关于此的文章](https://blog.csdn.net/potential1/article/details/73195172)，链接：https://blog.csdn.net/potential1/article/details/73195172 或上网搜索。

2.不建议骗分(~~虽然总比没分好~~)，即使骗分好像能过这道题。我们要有一颗追求正解的心。

3.此文是本人的第一篇题解，有误请见谅，有疑问可以提出，多谢。

---

## 作者：DavidW (赞：16)

这题的思路其实很简单，事实上就是一个裸的堆题。

我们观察到题目中 $x,a,b,c$ 均为正整数，这样显然二次函数对称轴在 $y$ 轴左侧，在 $[1,+∞)$ 区间内为增函数。

这样思路就很明确了，取每个函数在 $x=1$ 的值进堆，每一次取堆顶元素，将这个元素所在的函数 $x+1$ ，重新进堆，这样就做完了这道题目。

本算法时间复杂度为 $Θ(mlogn)$

本人过懒了，不想手写堆，又想时间短一点，就用了平板电视(pbds库)大法+O3优化，亲测单点最长时间8ms，和手写堆差不多。

以下是代码：
```cpp
#pragma GCC optimize(3)//参加NOIP时别写，这是O3优化
#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
using namespace std;
using namespace __gnu_pbds;
__gnu_pbds::priority_queue<pair<int,int>,greater<pair<int,int> >,pairing_heap_tag>h;//平板电视大法好!其实用普通的优先队列就够了
int a[10010],b[10010],c[10010],x[10010];
pair<int,int> tmp;
inline int mul(int i){
    return a[i]*x[i]*x[i]+b[i]*x[i]+c[i];
}
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&a[i],&b[i],&c[i]);
        x[i]=1;h.push(make_pair(mul(i),i));//堆内放一个pair，分别是函数值和函数序号
    }
    for(int i=1;i<m;i++){
        tmp=h.top();x[tmp.second]++;//找到最小的，给x加上1，再重新进堆
        printf("%d ",tmp.first);
        h.pop();h.push(make_pair(mul(tmp.second),tmp.second));
    }
    tmp=h.top();printf("%d\n",tmp.first);
    return 0;
}
```

---

## 作者：Imakf (赞：14)

# 本题解十分不正经

#### 本蒟蒻最先打的暴力是

算出每个函数的前$m$个值，放入堆中，然后暴力求出来,嗯

[记录](https://www.luogu.org/record/show?rid=8399608) $2AC+8TLE$

# 当您想不到的时候便要骗分

然后我就想优化一下，搞了半天无从下手，突然想到我还有$rand()$！

于是我就把上面的改了一下，算出每个函数的前$rand()~mod~m$个值

```cpp
void getsmallest(){
        int maxn=rand()%m+1;
        for(int i=1;i<=maxn;i++){
            q.push(value(i));
        }
}
```

于是乎[记录](https://www.luogu.org/record/show?rid=13406372) $2AC+8TLE$

### 随机做法似乎陷入了困境

但是，随机不就是乱搞吗？乱搞总会搞出来的，于是我又改了改代码

```cpp
void getsmallest(){
        for(int i=1;i*i<=m*(rand()%m/30+1);i++){
            q.push(value(i));
        }
    }
```

于是这就过去了？？？？

[记录](https://www.luogu.org/recordnew/show/13407112) 

# 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
priority_queue <int,vector<int>,greater<int> > q;  
int tot,n,m;
long long abs(long long a){
    return a>0?a:-a;
}
struct function{
    int xishu2,xishu1,changshu;
    long long value(int x){
        return xishu2*x*x+xishu1*x+changshu;
    }
    void getfunc(){
        scanf("%d%d%d",&xishu2,&xishu1,&changshu);
        return;
    }
    void getsmallest(){
        for(int i=1;i*i<=m*(rand()%m/30+1);i++){
            q.push(value(i));
        }
    }
}h[10000+5];
int main(){
    srand(19260817);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)	h[i].getfunc(),h[i].getsmallest();
    for(int i=1;i<=m;i++){
        printf("%d ",q.top());
        q.pop();
    }
    return 0;
}
```

# 不要忘记在NOIP时，您还有一种算法叫随机算法

---

## 作者：ningyuheng (赞：11)

首先先%%%底下神犇写的各种堆，然而我是用**二分查找**来做的，首先用二分查找判断第m个数最大是多少，然后从第1个二元一次方程组开始枚举，超过最大的这个数了立马退出查找下一个，如果当前查找的这个数已经不属于前m个数了但仍然符合条件，说明二分的这个数大了，把它缩小，否则如果已经搜完了第1~n个方程组仍然达不到m个数，就说明二分的这个数小了，把它增大。但有一些特殊的数据如在选前5个数，但是前六个数是这样的：10,11,12,13,14,14，第5个数和第6个数相等。这就需要判断一下，稍后在代码中会说明。总时间复杂度大约为：O（n log n）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,m,i,a[10002],b[10002],c[10002],d[100002],top,min1,l,r,mid,flag,j;
int main()
{
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;i++)
        scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
    l=1;r=2000000000;mid=(l+r)/2;
    min1=r;
    while(l<=r)
    {
        flag=0;
        top=0;
        for(i=1;i<=n&&flag==0;i++)
            for(j=1;a[i]*j*j+b[i]*j+c[i]<=mid&&flag==0;j++)
            {
                d[++top]=a[i]*j*j+b[i]*j+c[i];
                if(top>m)
                    flag=1;
            }
        if(top<m)
            l=mid+1;
        else
        {
            r=mid-1;
            min1=min(mid,min1);//当一样的时候把能包含大于等于m个数的最小值记录下来，输出的时候按照最小的输出前m个数，这样虽然会多上那么几个点但是也就几个而已
        }
        mid=(l+r)/2;
    }
    top=0;
    for(i=1;i<=n;i++)
        for(j=1;a[i]*j*j+b[i]*j+c[i]<=min1;j++)
            d[++top]=a[i]*j*j+b[i]*j+c[i];
    sort(d+1,d+top+1);
    for(i=1;i<=m;i++)
        printf("%d ",d[i]);
    cout<<endl;
    return 0;
}
```

---

## 作者：Lee02 (赞：10)

## 堆的水题
### 题意在此就不进行分析了，前面的带佬分析的很清楚，就是求所有函数的最小的前m个函数值

### 关键点：在结构体中重载运算符

像我这种蒟蒻，看到这道题只会想暴力方法（结构体+优先队列+枚举），可是码着码着代码，发现就不会结构体中的**重载运算符**了...于是，只好先将这个题放到一边。

然后，过了几天，在学堆优化的dijisktra时学会了重载运算符的方法，于是顺带手的就把这道题A了（虽说我到现在也还不懂它的原理是什么...）

[https://www.luogu.org/record/26234733](过来康康)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[10005],b[10005],c[10005];
struct node{
	int y;//y是因变量
	int num;//函数式的编号
	int x;//x是自变量
	bool operator < (const node &a)const//重载运算符，在最短路中也是这
        {						//样，固定写法
		return a.y<y;
	}
};//定义函数值的结构体。
priority_queue<node> q;
int main ()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i]>>c[i];//输入函数的各个系数
		q.push((node){a[i]+b[i]+c[i],i,1});//将x=1时的函数值压入队列
	}
	for(int i=1;i<=m;i++)//输出
	{
		node tmp=q.top();q.pop();
		cout<<tmp.y<<" ";
		
		q.push((node){a[tmp.num]*(tmp.x+1)*(tmp.x+1)+b[tmp.num]*(tmp.x+1)+c[tmp.num],tmp.num,tmp.x+1});
        //将下一个函数值压入队列，大家慢慢看，其实很好懂
	}
	
	return 0x7fffffff;
}
```
不要抄袭


---

## 作者：yybyyb (赞：7)

/\*
每个函数的a,b,c都是正数

所以每个抛物线的对称轴都是负数

所以每条抛物线在x>=1时都是增函数

所以fi(1)一定是该抛物线最小值

所以首先把所有的fi(1)都放到优先队列里面

每次直接输出优先队列的top值

然后把top值所对应的函数的x+1的值放到队列里面

循环n次就是答案

\*/
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<queue>
#include<algorithm>

using namespace std;

#define ll long long
#define MAX 500010

//priority_queue<ll> fun;

struct Node
{
        ll val;
        ll X;
        ll from;
};

bool operator <(Node a,Node b)
{
       return a.val>b.val;
}

priority_queue<Node> fun;

ll a[MAX],b[MAX],c[MAX];
ll n,m;

inline ll Function(ll n,ll x)
{
       return a[n]*x*x+b[n]*x+c[n];
}

int main()
{
    
       freopen("minval.in","r",stdin);
       freopen("minval.out","w",stdout);
       
       scanf("%lld%lld",&n,&m);
       
       ll S,num=0,x=0;

       for(int i=1;i<=n;++i)
       {
                 scanf("%lld%lld%lld",&a[i],&b[i],&c[i]);
                 fun.push((Node){Function(i,1),1,i});
       }
       
       for(ll i=1;i<=m;++i)
       {
               Node Q=fun.top();
               cout<<Q.val<<' ';
               fun.pop();
               fun.push((Node){Function(Q.from,Q.X+1),Q.X+1,Q.from});
       }
       
       return 0;
}
```

---

## 作者：amazingOZR (赞：3)

用一个优先队列q保存当前最小的m个函数值。

因为a,b,c>0，所以f(x)为增函数。所以这m个值一定在x=1,2,3...m中取得。

首先把第一个函数的前m个值压入队列中。对于第2、3、4……n个函数，每次将x遍历1到m。如果f(x)大于等于堆顶，那么x及x以后的函数值都比这m个大，可以不用计算了直接break掉。否则，弹出堆顶，将f(x)压入队列。

注意输出时倒序输出，用一个数组保存一下答案

复杂度表示不会证明，如果有大神会证明的话请发题解或者私信我，谢谢orz

代码：

```cpp
#include<cstdio>
#include<queue>
using namespace std;
priority_queue<int>q;
int ans[10005],n,m,a,b,c,x;
int main()
{
    scanf("%d%d",&n,&m);
    scanf("%d%d%d",&a,&b,&c);for(register int i=1;i<=m;++i)q.push(i*i*a+i*b+c);
    while(--n)
    {
        scanf("%d%d%d",&a,&b,&c);
        for(register int i=1;i<=m;++i)
        {
            x=i*i*a+i*b+c;
            if(x>=q.top())break;
            else q.pop(),q.push(x);
        }
    }
    for(register int i=m;i;--i)ans[i]=q.top(),q.pop();
    for(register int i=1;i<=m;++i)printf("%d ",ans[i]);
    return 0;
}

```

---

## 作者：旋风猪皮 (赞：3)

首先注意到ai,bi,ci都是大于0的，所以说x越大那么对应的函数值就越大。

可以先开一个结构体数组x，储存每一个函数x=1时的值，再开个数组f,f[i]代表第i个函枚举到了x=f[i]的情况

然后循环m次，每次输出这里面最小的值，再把构成这个值的函数的编号i求出来，f[i]++,然后用这个函数构成新的值，放进x数组中，然后堆排序，就可以了。

除去输入，初始化，核心算法复杂度就是（m（logn）），不会超时。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10001],b[10001],c[10001];
int f[10001];//f[i]即为第i个函数枚举到了x=f[i]的情况；
struct pig{
    int data;//函数产生的数据
    int bh;//x[i].bh就是从小到大排序后第i大小的函数值构成于初始的第几个函数
}x[10001];
int cmp(pig f1,pig f2)
{
    return f1.data<f2.data;
```
}//从小到大排序，第一次可以用sort，堆排序在核心算法里再用。
```cpp
int main()
{
    for(int i=1;i<=10000;i++)
    f[i]=2;//初始化，由于第一次枚举的是x=1的情况，所以f数组可以直接赋值成2；
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i]>>b[i]>>c[i];
        x[i].data=a[i]+b[i]+c[i];//即为这个函数x=1的情况
        x[i].bh=i;//函数的初始编号
```
}//读入
```cpp
    sort(x+1,x+n+1,cmp);
    for(int i=1;i<=m;i++)
    {
        cout<<x[1].data<<" ";//输出最小值
        int g=x[1].bh;//找出是开始的第几个函数构成了这个最小值
        x[1].data=f[g]*a[g]*f[g]+b[g]*f[g]+c[g];//得到该函数下一个x构成的值。
        f[g]++;//枚举产生最小值的函数的下一个x
        int t=1;
        while(t*2<=n)//堆排序
        {
            int o=t*2;
            if(o+1<=n&&(x[o+1].data<x[o].data)) o++;
            if(x[o].data<x[t].data)
            {
                pig kx=x[o];
                x[o]=x[t];
                x[t]=kx;
                t=o;
            }
            else break;
        }
    }
    return 0;
}
```

---

## 作者：Jelly_Goat (赞：2)

来一发左偏树做本题的思路  

------

### 前置结论

然而思路其实就是根据每一个函数都是在正整数域上单调递增的性质  

进行~~乱搞（不是~~


------

### 具体做法

~~数据规模怎么说？水啊~~

其实这题搞法很多的  

关键在于数据范围$m\leq 10000$，只有10000而已  

但是优雅的方式过此题

还是$nlogn$好

然后由于都是递增的  

我们可以根据每一个函数进行排序

对于每一个函数他的导数应当是一个单调递增的一次柿子

那么要找的函数值应该就是来自增长最不nb的函数  

我们对着这些函数进行一个动态的排序

就用到了堆

~~其实这个左偏树只是堆的一种实现方式罢了~~

------

### 代码实现

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <utility>

using namespace std;
typedef pair<int, int> prii;
struct Heap
{
    Heap *lson, *rson;
    int dist;
    prii val;
    Heap()
    {
    	lson = rson = NULL;
    	dist = 0, val = make_pair(0, 0);
	}
}*root = NULL;

void set_dist(Heap *node)
{
    if (node->rson != NULL)
        node->dist = node->rson->dist + 1;
    else node->dist = 0;
}

Heap *merge(Heap *a, Heap *b)
{
	//一个节点是空的，那么返回另一个节点 
    if (a == NULL) return b;
    else if (b == NULL) return a;
    //将权值较小的作为根结点
    if (a->val > b->val) swap(a, b);
    //合并右儿子和大权值节点
    a->rson = merge(a->rson, b);
    if (a->rson != NULL && a->lson != NULL)
    {
        if (a->lson->dist < a->rson->dist)
            swap(a->lson, a->rson);
    }
    else if (a->lson == NULL && a->rson != NULL)
        swap(a->lson, a->rson);
    set_dist(a);
    return a;
}

void Insert(prii val)
{
    //必须先特判堆是空的结果
    if (root == NULL)
    {
        root = new Heap();
        root->val = val;
        set_dist(root);
        return ;
    }
    Heap *num = new Heap();
    num->val = val;
    set_dist(num);
    root = merge(root, num);
}

prii Top()
{
    if (root != NULL)
        return root->val;
    else return make_pair(0, 0); //rand();
}

void Pop()
{
    Heap *temp = root;
    root = merge(root->lson, root->rson);
    delete(temp);
}
const int maxn = 10010;
int a[maxn], b[maxn], c[maxn], x[maxn];
int n, m;
inline int f(int i)
{
    return a[i] * x[i] * x[i] + b[i] * x[i] + c[i];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d%d", &a[i], &b[i], &c[i]);
        x[i] = 1;
        Insert(make_pair(f(i), i));
    }
    for (int i = 1; i < m; i++)
    {
        prii now = Top();
        Pop();
        x[now.second] ++;
        printf("%d ", now.first);
        Insert(make_pair(f(now.second), now.second));
    }
    printf("%d\n", Top().first);
    return 0;
}
//9 12 12 19 25 29 31 44 45 54
```

---

## 作者：FifthAxiom (赞：2)

## 题意

给定$n$个二次函数的正整数系数，第$i$个函数的三项系数分别为$a[i], b[i], c[i]$，求出这$n$个函数中前m个最小的函数值（自变量取值均为正整数）

## 分析

将函数值分为$n$个数列：

$$\begin{aligned}&1^2a[1]+1b[1]+c[1]<2^2a[1]+2b[1]+c[1]<3^2a[1]+3b[1]+c[1]\cdots\\&1^2a[2]+1b[2]+c[2]<2^2a[2]+2b[2]+c[2]<3^2a[2]+3b[2]+c[2]\cdots\\&\cdots\\&1^2a[n]+1b[n]+c[n]<2^2a[n]+2b[n]+c[n]<3^2a[n]+3b[n]+c[n]\cdots\\\end{aligned}$$

对这$n$个数列归并排序并取出前$m$项即可。

## 具体实现

将每个数列的第一项放入小根堆中，每次输出堆顶，并将堆顶所在的数列的下一项放入堆中。输出$m$次后结束。

## 代码

```cpp
#include <cstdio>
#include <queue>

#define pa std::pair<int, int> 
#define mp(a, b) std::make_pair(a, b)
#define value first
#define co second//二元组第一项存函数值，第二项存数列系数


std::priority_queue< pa, std::vector<pa>, std::greater<pa> > q;//建立小根堆
int n, m, a[10010], b[10010], c[10010], x[10010];//x数组存储数列自变量取值

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf("%d %d %d", a + i, b + i, c + i);
		q.push(mp(a[i] + b[i] + c[i], i));//将每个数列的第一项放入堆中
		x[i] = 1;//每个数列第一项自变量取值都是1
	}
	for (int i = 1; i <= m; i++) {
		printf("%d ", q.top().value);//输出堆顶
		int k = q.top().co;
		q.push(mp(a[k] * (++x[k]) * x[k] + b[k] * x[k] + c[k], k));//将堆顶所在数列的下一项放入队中
		q.pop();//弹出堆顶
	}
	return 0;
}
```




---

## 作者：上杉 (赞：2)

**蒟蒻第一次写题解**

------------

首先，这道题如果用暴力代价会很大，所以暴力排序显然不（ke）行（yi）

~~毕竟数据水~~

众所周知，二次函数的对称轴是**-b/2*a**

根据题目，定义域是位于**正整数**，且数据保证了函数二次项、一次项以及常数都为**正整数**

由此可以得出，**n个函数的值构成了n个递增序列**


------------
那么再看这n个函数形成的n个序列，当x=1时，在各个序列都是最小值，既然如此，我们将n个序列的最小值丢到一个小根堆里，输出一个，**查找这个值来自哪个序列**，将这个序列的下一个值再丢进堆里，直到有m个输出


------------
**下附AC代码，由于堆优化最大的数据点也只有20ms**
```
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct cheng{
    int two,one,chang,num,xxx;
    bool operator < (const cheng &a)const{
        return num>a.num;//规定堆的排序方式是以函数值从小到大排序 
    }
}w;
priority_queue<cheng>h;//STL建堆 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)//初始化 
	{
		cin>>w.two>>w.one>>w.chang;//输入 
		w.xxx=1;//由于x最小是1，所以从1开始 
		w.num=w.two+w.one+w.chang;
		h.push(w); 
	}
	for(int i=1;i<=m;i++)
	{
		cheng ans=h.top();//调用 
		h.pop();//删除 
		cout<<ans.num<<" ";
		ans.xxx++;//调用该序列下一个值 
		ans.num=ans.xxx*ans.xxx*ans.two+ans.xxx*ans.one+ans.chang;//同上 
		h.push(ans); //丢回去 
	}
	return 0;
}
```

---

## 作者：nenugdi (赞：2)

这题数据量只有10000，不用堆也可以过，简单暴力算法可以ac。方法是用一个数组f保存函数的值，一个数组x保存每个函数对应x的值，每次选出最小值后更新数组f对应单元即可。
```cpp
#include <iostream>
#include <iomanip>
#include <math.h>
#include <string>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
int n,m,can[10001][3],f[10001],x[10001];
int selectMin()
{
    int i,minx=f[1],mini=1;;
    for(i=2; i<=n; i++)
    {
        if(f[i]<minx)
        {
            minx=f[i];
            mini=i;
        }
    }
    return mini;
}
int main()
{
    int i,j;
    cin>>n>>m;
    for(i=1; i<=n; i++)
    {
        cin>>can[i][0]>>can[i][1]>>can[i][2];/**< 参数 */
        x[i]=1;
        f[i]=can[i][0]+can[i][1]+can[i][2];/**< 初始化f数组的值 */
    }
    for(i=1; i<=m; i++)/**< 循环选择最小值 */
    {
        int mini=selectMin();
        cout<<f[mini]<<' ';
        x[mini]++;/**< 更新mini对应的x和f */
        f[mini]=can[mini][0]*x[mini]*x[mini]+can[mini][1]*x[mini]+can[mini][2];
    }
    return 0;
}

```

---

## 作者：Mychael (赞：2)

我比较水，没有想到用一个小根堆维护n个函数当前最小值的方法。


反而，我用的是比较规矩的大根堆：

我是这样的思想：

由于每个函数在正半轴都是单调递增的，当大根堆中的元素达到了m个而当前函数值比根顶还大，那么这个函数就可以排除掉

直到所有函数被排除掉为止，算法结束


为了平摊时间，我采用双向链表的形式轮流读取函数，轮流入堆【可似乎数据很水】

因为如果一开始就只把其中一个函数的m个值入堆，然后再逐个函数排除，最差的时间复杂度可以达到n^2logn

如果数据强一点肯定T啊。。。





```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long int
using namespace std;
const int maxn=10005,INF=200000000;
inline int read(){
    int out=0,flag=1;char c=getchar();
    while(c<48||c>57) {if(c=='-') flag=-1;c=getchar();}
    while(c>=48&&c<=57) {out=out*10+c-48;c=getchar();}
    return out*flag;
}
int N,M;
class node{   //链表
```
public:
        
        

```cpp
        LL a,b,c;
        int last,next,i;
        void init(int u){
            a=read();
            b=read();
            c=read();
            i=0;
            last=u-1 ? u-1:N;
            next=u+1<=N ? u+1:1;
        }
        LL getf(){
            i++;
            return a*i*i+b*i+c;
        }
}e[maxn];
class HEAP{       //大根堆
```
public:
        
        
        
        


```cpp
        LL H[maxn],heapsize;
        HEAP() {heapsize=0;}
        void heapify(int u){
            int big=u;
            if((u<<1)<=heapsize&&H[u<<1]>H[big]) big=u<<1;
            if((u<<1|1)<=heapsize&&H[u<<1|1]>H[big]) big=u<<1|1;
            if(big!=u){
                swap(H[big],H[u]);
                heapify(big);
            }
        }
        void increase(int u,int v){
            H[u]=v;
            while(u>1&&H[u>>1]<H[u]){
                swap(H[u>>1],H[u]);
                u>>=1;
            }
        }
        void insert(int v){
            H[++heapsize]=-INF;
            increase(heapsize,v);
        }
        void del(){
            swap(H[1],H[heapsize--]);
            heapify(1);
        }
}H;
int cnt=0,ans[maxn];
int main()
{
    N=read();
    M=read();
    for(int i=1;i<=N;i++) e[i].init(i);
    int p=1,cc=N;
    LL t;
    while(cc){               //轮流入堆
        t=e[p].getf();
        if(cnt<M) H.insert(t),cnt++;  //堆未满
        else if(t<H.H[1]){            //堆已满
            H.del();
            H.insert(t);
        }
        else{
            e[e[p].last].next=e[p].next;
            e[e[p].next].last=e[p].last;
            cc--;
        }
        p=e[p].next;
    }
    for(int i=M;i>0;i--){         //得出答案
        ans[i]=H.H[1];
        H.del();
    }
    printf("%d",ans[1]);
    for(int i=2;i<=M;i++) printf(" %d",ans[i]);
    printf("\n");
    return 0;
}

```

---

## 作者：never_see (赞：2)

和下面的方法略微有些不同

算法：用一个数组记录当前第i个函数自变量的值，初始化X[i]=1，每次从小根堆取出一个函数值时，使其对应的自变量的值增加，比如取出的是第i个，就X[i]++，这样就是一个O(n+m)的算法








```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 10000+1;
int a[MAXN],b[MAXN],c[MAXN],now,X[MAXN],n,m;
int Function(int i,int x)    //计算函数值
{
    return a[i]*x*x+b[i]*x+c[i];
}
typedef pair<int,int> node;
priority_queue <node, vector < node >, greater< node> > Heap; //定义存储双关键字的小根堆
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;X[i]=1,Heap.push(node(Function(i,X[i]),i)),i++)//初始化，将所有functino[1]的值压入
        scanf("%d%d%d",&a[i],&b[i],&c[i]);
    for(int i=1;i<=m;i++)
    {
        printf("%d ",Heap.top().first);//取出当前最小的
        X[now=Heap.top().second]++;//让取出函数的自变量增加
        Heap.pop();
        Heap.push(node(Function(now,X[now]),now));//压入新的函数值
    }
    return 0;
}
```

---

## 作者：jinyijiang (赞：1)

这道题是一道 优先队列 题目

优先队列是一种大根堆，大根堆类似一棵树，根最大，孩子二大，以此类推。

而这里优先队列要用小根堆和结构体

定义: //本人不上完整代码
```cpp
struct Node
{
	int fnum; //第几个函数
	int x; //参数
	int number; //最终值
	bool operator < (const Node& p) const //注意这里一定要用‘<’，最后一个const表示函数不改变变量
	{
		return number > p.number; //小根堆
	}
};
priority_queue<Node> q; //注意pq拼法
```
----------
再写一个将量放入pq的算法（pq自动将数排序）
```cpp
void push_node(int fn, int nn)
{
	Node node;
	node.fnum = fn;
	node.number = f1[fn] * nn * nn + f2[fn] * nn + f3[fn]; //计算
	node.x = nn;
	q.push(node); //将node推入优先队列
}
```

将数推入和拿出
```cpp
for(int i=1; i<=n; i++)
	{
		push_node(i, 1); //把每一次x=1的结果先算出来
	}
	for(int i=1; i<=m; i++)
	{
		Node node = q.top(); //与queue不同，这里是top
		q.pop();
		cout << node.number << ' ';
		push_node(node.fnum, node.x + 1);
	}
```

---

## 作者：Accoty_AM (赞：1)

### ~~可解决整数域~~
很简单，把使每个函数值最小的x放进堆中，每次取最小的值的x进行扩展。
这里用b/(-2*a)来确定x，用set判重

## STL set
集合中的元素有序并去重，可查找元素排名，前驱（第一个小于x的数），后继（第一个大于x的数），内部实现：平衡树。

#### 注意 
find（x）- 查找元素排名，返回指针，如果没有则返回指向末尾的指针（末尾没有东西，值为1）

## 堆
我们通过把优先队列写成结构体形式以存取更多信息，STL优先队列内部函数调用的是"()"运算符。

写一个结构体，内部 重载运算符 "()" 如下
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
inline int read(){
	rg char ch=getchar();
	rg int x=0,f=0;
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}
int a[10020],b[10010],c[10010],vis[100010];
int n,m;
struct node{
	int val,x,y;
	node(int vall,int xl,int yl){
		val=vall;
		y=yl;
		x=xl;
	}
};
struct cmp{
	bool operator ()(const node a,const node b){
		return a.val>b.val;
	}
};
priority_queue<node,vector<node>,cmp> q;

inline int get(int x,int y){
	return a[y]*x*x+b[y]*x+c[y];
}
set<int> s[10010];
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i){
		a[i]=read(),b[i]=read(),c[i]=read();
	}
	for(int z,i=1;i<=n;++i){
		z=b[i]/(2*a[i]);
		z=-z;
		z=max(z,1);
		s[i].insert(z);
		q.push(node(a[i]*z*z+b[i]*z+c[i],z,i));
	}
	for(int xl,yl,i=1;i<=m;++i){
		node x=q.top();q.pop();
		printf("%d ",x.val);
		xl=x.x+1;yl=x.y;
		if(s[yl].find(xl)==s[yl].end()){
			q.push(node(get(xl,yl),xl,yl));
			s[yl].insert(xl);
		}
		xl-=2;
		if(xl>0&&s[yl].find(xl)==s[yl].end()){
			q.push(node(get(xl,yl),xl,yl));
			s[yl].insert(xl);
		}
	}
}
```


---

## 作者：Celebrate (赞：1)

我的博客：
```cpp
https://blog.csdn.net/zsyzClb/article/details/84297862
```
根据观察，可以发现Ai,Bi,Ci都是正整数，所以任何一个f函数都

满足单调递增，另外，x是正整数，所以我们知道对于每个函

数，x=1都是最小值，因此我们需要定义一个数组，记录每一

个函数当前x的值，每次都找一次最小值，输出并将最小值函数

的x++，这样的时间复杂度为O(nm)，理论上是不会超时的。

在考虑优化，很明显，可以用堆来做着这道题，利用小根堆，第一次插入n个x=1时的函数，循环m次，每次输出堆顶，并将堆顶x++后放回堆，并且维护

或者用优先队列（STL),和堆的时间复杂度都是O（mlogn)

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<queue>
#include<stack>
#include<cmath>
#include<map>
using namespace std;
inline int read(){
    int x=0,f=0;char s=getchar();
    while(!isdigit(s))f|=s=='-',s=getchar();
    while( isdigit(s))x=(x<<1)+(x<<3)+s-48,s=getchar();
    return !f?x:-x;
}
const int N=1e4+10;
int n,m;
int a[N],b[N],c[N];
struct node{
    int z,x,t;
    inline bool operator<(const node &k)const{//将z从小到大排序 
        return k.z<z;
    }
};
priority_queue<node> q;
inline int query(int x,int t){return x*x*a[t]+x*b[t]+c[t];}//输出第t个函数的值 
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read(),b[i]=read(),c[i]=read();
    for(int i=1;i<=n;i++)q.push((node){query(1,i),1,i});//将每一个x=1的函数放进优先队列 
    while(m--){
    	printf("%d ",q.top().z);//输出堆顶 
    	int x=q.top().x+1,t=q.top().t;//x++后放入堆 
    	q.pop();q.push((node){query(x,t),x,t});
    }
    return 0;
}
```

---

## 作者：Believe_Horizon (赞：1)

###emmmmm说实在的这道题并不是很难，算是一道#优先队列###的裸题了

由于本人比较懒，所以直接使用了C++自带的#STL模板库

即p.pop()删除顶，p.top()取出顶   这种简单的操作（完全不令人智熄

##下面是我的代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
priority_queue<int> que;
int a[10005],b[10005],c[10005],f[10005][10005];
int main()
{
    int m,n;
    cin>>n>>m;
    int i=1;
    for(i=1;i<=n;++i)
       {
           cin>>a[i]>>b[i]>>c[i];
```
}//这里只是输入而已
```cpp
    i=0;//这里是为了下面的i可以从1开始 
    for(int j=1;j<=n;++j){
        ++i;
       for(int w=1;w<=100;++w)//比较暴力，算出每个函数1到一百的值 
          {
              f[j][w]=a[i]*w*w+b[i]*w+c[i]; 
              que.push(-f[j][w]); //扔进去（-是为了把原来的顶最大变为顶最小) 
          }
    }
    for(int d=1,tmp;d<=m;++d)
       {
           tmp=que.top();//取出顶部 
           que.pop();//删除顶部 
           cout<<-tmp<<" ";//恢复-号并输出 
       }
       return 0;
}
```

---

## 作者：手链剖分 (赞：1)

首先吐槽一下，这题数据真是水，本来我写了个n^2logn的暴力，害怕会T然后就在第二重循环上加了个根号，居然就A了……

吐槽结束，现在说正解。


我的代码和楼上的很多dalao一样，就是先把x=1时各个函数的值插入小根堆，然后不停地取出堆顶，把取出的函数代入x+1，算出函数值再插入堆，取上m次为止。


但是，我这里有另一种理解方法。


首先，因为a>0,b>0,c>0,x∈N\*,所以每个函数的图像就是在第一象限内若干单调递增的离散的点。于是我们可以把每个函数看成一个单调递增的数列。我们的任务是求所有数列中最小的m个数，可以借助归并排序的思想，只不过这次不是归并2个有序序列，而是归并n个有序序列。那么我们就把所有序列的第一项先插入小根堆，弹出堆顶，这是我们找到了最小的数。然后再把刚取出的数的下一项插入小根堆，再取堆顶，我们就得到了第二小的数。重复m次就是答案。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <queue>
#define maxn 10003
using namespace std;
struct node{
    int val,k;
    bool operator < (const node &x) const{
        return x.val<val;
    }
};
int a[maxn];
int b[maxn];
int c[maxn];
int now[maxn];//now表示当前数列插到第几个数了
priority_queue<node>q;
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&a[i],&b[i],&c[i]),now[i]=1;
    for(int i=1;i<=n;i++)//先把数列的第一项都插进去
        q.push((node){a[i]+b[i]+c[i],i});
    for(int i=1;i<=m;i++)
    {
        node u=q.top();q.pop();
        printf("%d ",u.val);
        int x=++now[u.k];//插入下一个数
        q.push((node){a[u.k]*x*x+b[u.k]*x+c[u.k],u.k});
    }
    printf("\n");
    return 0;
}

```


---

## 作者：zschhh (赞：1)

最容易想到的方法就是用小根堆存下每个函数的信息和当前的解

然后把最小的解输出，不断更新函数信息，直到比第二小的解大

，再插到堆里调整。一直循环，直到输出m个解。


蒟蒻的代码（写得很冗长，很多地方其实可以不写函数 ，或是少

用几个变量）：










```cpp
#include <iostream>
using namespace std;
struct node{
    int number;  //函数的号码 
    int last_ans;  //当前X对应的解 
    int last_x;  //当前的X 
} heap[10005];
int a[10005],b[10005],c[10005];
int heap_size,ans_num;
int f(int i,int x){  // 函数fi 
     return a[i]*x*x+b[i]*x+c[i];
}
void heap_adjust_down(int n){  //向下调整堆 
    int ch=n<<1;
    struct node temp=heap[n];
    while(ch<=heap_size){
        if(ch<heap_size && heap[ch].last_ans > heap[ch+1].last_ans)
            ch++;
        if(heap[ch].last_ans>temp.last_ans)
            break;
        heap[n]=heap[ch];n=ch;ch<<=1;
    }
    heap[n]=temp;
}
void heap_insert(node x){  //插入堆 
    heap[++heap_size]=x;
    int fa=heap_size>>1,ch=heap_size;
    while(fa && heap[fa].last_ans > x.last_ans){
        heap[ch]=heap[fa];ch=fa;fa>>=1;
    }
    heap[ch]=x;
}
void delete_min(){  //删除堆顶元素 
    heap[1]=heap[heap_size--];
    heap_adjust_down(1);
}
void bulid_heap(){  //建堆 
    for(int i=heap_size>>1;i>0;i--)
    heap_adjust_down(i);
}
void update(node &t){  //更新一个元素 
    t.last_x++;
    t.last_ans=f(t.number,t.last_x);
}
int main(int argc, char *argv[]){
    int n,m,i;cin>>n>>m;
    for(i=1;i<=n;i++){
        cin>>a[i]>>b[i]>>c[i];
        heap[i].number=i;
        heap[i].last_ans=f(i,1);
        heap[i].last_x=1;
    }
    heap_size=n;
    bulid_heap();
    struct node temp;
    while(1){
        temp=heap[1];   //取一个函数出来
        delete_min();
        while(heap[1].last_ans>=temp.last_ans && ans_num<m){  //当当前堆顶的解
            ans_num++;                                                                                                             //小于我们手头上
            cout<<temp.last_ans<<' ';                                               // 函数的解就退出
            update(temp);                                                                 
        }
        if(ans_num >= m) break;
        else heap_insert(temp);  //最后再将我们手头的这个函数送回到堆里 
    }
    return 0;    
}

```

---

## 作者：water_mi (赞：1)

题外话：本来只是像随便写一下测测数据的，结果就A了（喵喵喵？）

分析：对于这道题目，我选择大根堆（貌似很少有人想到），理由如下：

1.大根堆中，根最大，所以，我们在计算函数值时，只要函数值大于根，就不用继续求值了，反之，将函数值与根进行替换

2.这时，我们要注意：当堆没满（即堆的大小未超过m时），直接插入即可（注意堆的维护）

3.最后，将堆中元素取出存放入数组，再倒序输出即可

```cpp
//大根堆 
#include<cstdio>
const int maxn = 10010,maxm = 10010;
int n,m,a,b,c,heap[maxm],ans[maxm],heap_size,tmp;
void swap(int &a,int &b){tmp = a,a = b,b = tmp;}
void put(int value){
    heap[++heap_size] = value;
    int now = heap_size,next;
    while(now > 1){
        next = now >> 1;
        if(heap[now] <= heap[next]) return;
        swap(heap[now],heap[next]);
        now = next;
    }
}
int get(){
    int value = heap[1],now = 1,next;
    heap[1] = heap[heap_size--];
    while(now << 1 <= heap_size){
        next = now << 1;
        if(next < heap_size && heap[next + 1] > heap[next]) next++;
        if(heap[now] >= heap[next]) break;
        swap(heap[now],heap[next]);
        now = next;
    }
    return value;
}
//大根堆操作 
int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1,j = 0;i <= n;i++,j = 0){
        scanf("%d%d%d",&a,&b,&c);
        while(++j){
            int value = a * j * j + b * j + c;
            if(heap_size < m) put(value);//如果堆还有空 
            else if(value < heap[1]){get(); put(value);}//如果堆的根大于目前函数值，替换。 
            else break;//停止枚举函数值 
        }
    }
    for(int i = 1;i <= m;i++) ans[i] = get();//取出元素 
    for(int i = m;i >= 1;i--) printf("%d ",ans[i]);//倒序输出 
    return 0;
}
```

---

## 作者：NishikinoMaki (赞：1)

乱搞大法好(划去)

#首先,这是一道数学题

对称轴x = -b/2a < 0,故f(x)在N\*内严格递增

#看一下数据范围,n,m<=10000, 而且常数范围也很小

于是考虑生算函数值

一重循环最多跑10^7次

所以我们可以算[1,100]内的函数值而不会T

```cpp
#include <bits/stdc++.h>
#define nmax 110
#define LL long long
#define ULL unsigned long long
using namespace std;
inline LL read()
{
    int n = 0,k = 1;
    char ch = getchar();
    while ((ch > '9' || ch < '0') && ch != '-')  ch = getchar();
    if(ch == '-') k = -1, ch = getchar();
    while (ch <= '9' && ch >= '0')
      {
          n = n * 10 + ch - '0';
          ch = getchar();
      }
    return n * k;
}
inline void print(LL n)
{
    if(n < 0) { putchar('-'); n = -n;}
    if(n > 9) print(n / 10);
    putchar(n % 10 + '0');
    return ;
}
int n, m, a, b, c;
priority_queue < int, vector <int>, greater <int> > q;//大家应该都能看出是优先队列
inline int f(int x)
{
    return a * x * x + b * x + c;//简单粗暴算函数值
}
int main()
{
    n = read();
    m = read();
    for(int i = 0; i < n; i++)//n个函数
    {
        a = read();
        b = read();
        c = read();
        for(int j = 1; j <= 100; j++)
            q.push(f(j));//算[1,100]内的函数值,话说[1,50]会得90(当时怕T就没敢算到100)TAT
    }
    for(int i = 0; i < m; i++)
    {
        printf("%d ", q.top());
        q.pop();
    }
    return 0;
}
```
说到底,还是洛谷数据太水


---

## 作者：Tgotp (赞：1)

比较基础的一道题，虽然可以用stl做，但是我觉得手写一遍加强理解还是很有必要的，因为题解里并没有，所以我来水一发；

这道题明显最小堆，我主要说下堆，就是说不用管整个树，只要保证某节点小于其父亲节点同时大于儿子节点。

于是若能更新，即只用更新其儿子节点与父亲节点，堆就这么搞定了√

具体思路有其他的人讲了，大同小异。



```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;
const int N = 1000000 + 5; 
int a[N],b[N],c[N],p[N],n,m; 
struct node
{
    int a,b;
}f[N];
int function(int i,int x)
{
    return a[i]*x*x+b[i]*x+c[i];
}
void update(int i)
{
    if(f[i].a>f[i*2].a && i*2<=n)
    {
        swap(f[i],f[i*2]);
        update(i*2);update(i/2);
    }
    if(f[i].a>f[i*2+1].a && i*2+1<=n)
    {
        swap(f[i],f[i*2+1]);
        update(i*2+1);update(i/2);
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        p[i]=1;
        scanf("%d%d%d",&a[i],&b[i],&c[i]);
        f[i].a=function(i,p[i]++);f[i].b=i;
    }
    for(int i=1;i<=n;i++)update(i);
    for(int i=0;i<m;i++)
    {
        printf("%d ",f[1].a);
        f[1].a=function(f[1].b,p[f[1].b]++);
        update(1);
    }
    return 0;
}
```

---

## 作者：Mr_Li (赞：1)

求最小的m个函数值，必然要对其进行排序。快速排序只适用于有限个元素，无限个元素只能用堆排序。我们需要枚举出可能的函数Fi(x)的值，若它小于堆顶元素，则令其入堆。观察式子可知，对于任意一个i值，Fi(x)>Fi(x-1)。即若Fi(x-1)没有成功入堆，则Fi(x)也不会成功入堆。最坏时间复杂度为O(MNlogM)，实际复杂度会远小于最坏时间复杂度的logM倍。

附C++代码：

```cpp

#include<iostream>
using namespace std;
int n,m,i,a[10001],b[10001],c[10001],heap[10001],x=0,answer[10001]; 
bool large[10001]={};
int build (int No)
{
    if (heap[No]<heap[No*2]&&(No*2<=m)&&(heap[No*2]>heap[No*2+1]||No*2+1>m))
    {
                                                                 swap(heap[No],heap[No*2]);
                                                                 build(No*2);
    }
    else
    if (heap[No]<heap[No*2+1]&&(No*2+1<=m))
    {
                                           swap(heap[No],heap[No*2+1]);
                                           build(No*2+1);
    } 
}
int main ()
{
    cin>>n>>m;
    for (i=1;i<=n;i++)
    cin>>a[i]>>b[i]>>c[i];
    for (i=1;i<=m+1;i++)
    heap[i]=2147483647;
    while (1)
    {
          x++;
          for (i=1;i<=n;i++)
          if (!large[i])
          if (heap[1]>a[i]*x*x+b[i]*x+c[i])
          {
                                           heap[1]=a[i]*x*x+b[i]*x+c[i];
                                           build(1);
          }
          else
          large[i]=1;
          for (i=1;i<=n;i++)
          if (!large[i])
          goto abc;
          break;
          abc:;
    }
    for (i=m;i>=1;i--)
    {
        answer[i]=heap[1];
        heap[1]=heap[i];
        heap[i]=0;
        build(1);
    }
    for (i=1;i<=m;i++)
    cout<<answer[i]<<' ';
    return 0;
}

```

---

## 作者：htt_wbsxg2 (赞：1)

话不多说，代码送到

```cpp
var
  n,m,r,i,j,tot,k:longint;
  tree,num,x:array[1..20000] of longint;
  a,b,c:array[1..10000] of longint;
//=======================================
procedure insert(v,x:longint);                             {插入一个节点}
var
  i,t:longint;
begin
  inc(tot);                                                {增加节点总数}
  tree[tot]:=v; num[tot]:=x;                               {开始放在tree的尾巴上，再与父亲比较交换，num对应其所在的函数编号}
  i:=tot;
  while (i>1) and(tree[i]<tree[i shr 1]) do                {不断与其父亲比较}
  begin
    t:=tree[i]; tree[i]:=tree[i shr 1]; tree[i shr 1]:=t;
    t:=num[i];  num[i]:=num[i shr 1];   num[i shr 1]:=t;
    i:=i div 2;                                            {交换后更新指针指向}
  end;
end;
//=======================================
procedure del;                                             {删除节点}
var
  i,j,t:longint;
begin
  if tot<1 then exit;
  tree[1]:=tree[tot]; num[1]:=num[tot];                    {将最后一个节点提上来，'num[1]:=num[tot];',一定不要忘了这句话。。不然会很悲剧}
  dec(tot);                                                {总数-1}
  i:=1; j:=i*2;                                            {将那个节点不断与其儿子比较交换，维护小根堆的性质}
  if (j<n)and(tree[j+1]<tree[j]) then inc(j);
  while (j<=n)and(tree[j]<tree[i]) do
  begin
    t:=tree[i]; tree[i]:=tree[j]; tree[j]:=t;
    t:=num[i];  num[i]:=num[j];   num[j]:=t;
    i:=j;                                                  {维护指针指向}
    j:=i*2;
    if (j<n)and(tree[j+1]<tree[j]) then inc(j);
  end;
end;
//=======================================
begin
  assign(input,'minval.in'); reset(input);
  assign(output,'minval.out'); rewrite(output);
  read(n,m); tot:=0;
  for i:=1 to n do read(a[i],b[i],c[i]);
  for i:=1 to n do
  begin
    insert(a[i]+b[i]+c[i],i);                              {先预处理n个值}
    x[i]:=1;
  end;
  j:=0;
  while j<m do
  begin
    write(tree[1],' ');                                    {每次输出最小那一个，然后将其的x值+1再算一个值，加入堆中}
    r:=num[1];
    inc(x[r]);                                             {x[i]即对应i的当前X值}
    del;
    insert(a[r]*x[r]*x[r]+b[r]*x[r]+c[r],r);
    inc(j);
  end;
  close(input); close(output);
end.
```

---

## 作者：_soul_ (赞：1)

先把x=1时各个函数的值插入小根堆，然后不停地取出堆顶，把取出的函数代入x+1，算出函数值再插入堆，取上m次为止。

其实就是维护一个小根堆，这应该属于很水的二叉堆了吧。。。

d[i,1] 是函数值。

d[i,2]记录的是这个是第d[i,2]个函数的函数值

f[i]代表第i个函数的x值；

此处放代码：

```cpp
var i,j,k,len,m,n,now:longint;
a,b,c,f:array[1..100000] of longint;
d:array[1..100000,1..2] of longint;
function jisuan(x,y,z,k:longint):longint;
begin
  exit(x*k*k+y*k+z);
end;
procedure push(x,y:longint);
var fa,son,t:longint;
begin
  inc(len);
  d[len,1]:=x;
  d[len,2]:=y;
  fa:=len div 2;
  son:=len;
  while (son<>1)and(d[son,1]<d[fa,1]) do
  begin
    t:=d[fa,1];
    d[fa,1]:=d[son,1];
    d[son,1]:=t;
    t:=d[fa,2];
    d[fa,2]:=d[son,2];
    d[son,2]:=t;
    son:=fa;
    fa:=fa div 2;
  end;
end;
function pop:longint;
var fa,son,t:longint;
begin
  pop:=d[1,1];
  now:=d[1,2];
  d[1,1]:=d[len,1];
  d[1,2]:=d[len,2];
  dec(len);
  fa:=1;
  while (fa*2<=len)or(fa*2+1<=len) do
  begin
    if (fa*2+1>len)or(d[fa*2+1,1]>d[fa*2,1]) then
    son:=fa*2 else son:=fa*2+1;
    if d[son,1]<d[fa,1] then
    begin
      t:=d[fa,1];
      d[fa,1]:=d[son,1];
      d[son,1]:=t;
      t:=d[fa,2];
      d[fa,2]:=d[son,2];
      d[son,2]:=t;
      fa:=son;
    end else break;
  end;
end;
begin
  read(n,m);
  for i:=1 to n do
  begin
    readln(a[i],b[i],c[i]);
    push(a[i]+b[i]+c[i],i);
    f[i]:=1;
  end;
  for i:=1 to m do
  begin
    write(pop,' ');
    inc(f[now]);
    push(jisuan(a[now],b[now],c[now],f[now]),now);
  end;
end.
```

---

## 作者：kion (赞：0)



用$now[i]$记录使得当前状态下$f_i(x)$取得最小值的自变量的值。

初始化：
初始状态，我们有$n$个二次函数$f(x)=A_ix^2+B_ix+C_i,x \in \mathbb{N}^+$;
1. 对称轴$- \frac{B_i}{2A_i} \in (- \infty , 1)$则$now[i]=1$；
2. 对称轴$- \frac{B_i}{2A_i} \in [1, \infty )$则$now[i]= \lfloor - \frac{B_i}{2A_i} \rfloor$

定义一个`multiset<node> S`;

其中，`node`:
```cpp
struct node
{
    int val, i;
    node() {}
    node(int Value, int i_f)
    {
        val = Value;
        i = i_f;
    }
    bool operator<(const node &o) const
    {
        return val < o.val;
    }
};
```
`val`存放函数值，`i`表示这是这是$i$号函数，也就是$f_i(x)$;

将$n$个函数怼入`S`，内部顺序按照$f_i(now[i])$升序；

以下内容执行$m$次:

每次取`S`的头，也就是当前最小值，输出头的`val`，并记录一下这个函数是$cur$号函数；

$f_{cur}(x)$对应的$now[cur]++$，把$node(f_{cur}(now[cur]),cur)$扔`S`里；


code:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10005;

int n, m, k;
int now[N], A[N], B[N], C[N], cnt[N];
struct node
{
    int val, i;
    node() {}
    node(int Value, int i_f)
    {
        val = Value;
        i = i_f;
    }
    bool operator<(const node &o) const
    {
        return val < o.val;
    }
};
multiset<node> S;
vector<int> ans;
inline int f(int i, int x)
{
    return A[i] * x * x + B[i] * x + C[i];
}

inline int sym(int i)
{
    int s = -(B[i] / (2 * A[i]));
    if (s <= 0)
        s = 1;
    return s;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        scanf("%d%d%d", &A[i], &B[i], &C[i]);
    for (int i = 1; i <= n; i++)
        now[i] = sym(i);
    for (int i = 1; i <= n; i++)
        S.insert(node(f(i, now[i]), i));
    for (int i = 1; i <= m; i++)
    {
        multiset<node>::iterator it = S.begin();
        ans.push_back(it->val);
        S.insert(node(f(it->i, ++now[it->i]), it->i));
        S.erase(it);
    }
    for (int i = 0; i < ans.size(); i++)
        cout << ans[i] << ' ';

    return 0;
}
```




---

## 作者：xdc呀 (赞：0)

# 题目：
![](https://cdn.luogu.com.cn/upload/image_hosting/7sa3zr7m.png)
# 想法：

## 函数调用部分：
将函数的调用部分写成一个函数         
（Fi(x)=Ai*x^2+Bi*x+Ci (x∈N*)）：
```cpp
int f(int a,int b,int c,int t)
{
	return a*t*t+b*t+c;
}
```
## 正题：
首先是最暴力的方法：把1~m的所有函数值放进一个大根堆里面，最后拿个栈来输出。结果我=就TLE了。(机房同学实验过）
然后我就改思路了。
我打算大根堆去存答案，从小到大去一个一个入队，如果前面一个大于堆顶就break，否则入队。最后去大根堆上面的m个输出。（先出的后输出）





# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int>heap;
int n,m;
int f(int a,int b,int c,int t)
{
	return a*t*t+b*t+c;
}
stack<int> s;
int main()
{
	int a,b,c,d;
	cin>>n>>m;
	cin>>a>>b>>c;
		for(int j=1;j<=m;j++)
		{
			heap.push(f(a,b,c,j));
		}
	
	for(int i=2;i<=n;i++)
	{
		
		cin>>a>>b>>c;
		for(int j=1;j<=m;j++)
		{
			if(f(a,b,c,j)<heap.top())
			{
			  	heap.pop();
				heap.push(f(a,b,c,j));	
			}
			else break;
		}
	}
	for(int i=1;i<=m;i++)
	{
		s.push(heap.top());
		heap.pop();
	}
	for(int i=m;i>=1;i--)
	{
		cout<<s.top()<<' ';
		s.pop();
	}
}
```


---

## 作者：JohnJoeZhu (赞：0)

# 感谢管理员大大，求通过

首先，建议先做一下[P1631](https://www.luogu.org/problemnew/show/P1631)，我的思路就是从~~题解~~这里来的
### 先介绍一个做法
**暴力**

顾名思义，我们可把所有的函数值一一求出，然后排序（面对此题，此方法使用，~~看你要不要水AC率了~~）

但是我们在比赛时，为了避免T，就必须采用另一种方法
### 思路
首先，我们可以得到，函数的最小值必定来自于F（1）

然后，我们需要将该最小值的函数改为F（2），再进入序列中，排序后输出

接下来，我们再对最小值的函数改为F（x+1）（x为原函数值，初始值为1）

如此循环，我们就可以得到前m个最小函数值，当得到m个后便停止，可以节省大量的空间和计算函数的时间
### 做法
对于排序，我们可以使用堆

如何使用呢？

我们只需要将堆顶元素改为F（x+1），然后维护堆即可
#### 细节及代码
当我打完代码后，发现答案是**错**的！

emmmmm

经过排查，我发现F（1）并不是有序的（即a，b，c非有序）

emmmmm

无奈之下，我只好先sort咯（也可以先堆排一遍，~~但我懒得打咯~~）

代码（变量名可能有些不一样）：
```cpp
#include<cstdio>
#include<algorithm>
#define N 10010
using namespace std;
int n,now[N],m;
struct pp{
	int dui,id;
}c[N];
struct node{//结构体为排序使用
	int a,b,d;
}f[N];
bool cmp(pp aa,pp bb)
{
	return aa.dui<bb.dui;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d%d",&f[i].a,&f[i].b,&f[i].d);
	for(int i=1;i<=n;i++) c[i].dui=f[i].a+f[i].b+f[i].d,now[i]=1,c[i].id=i;//初始化 其中id为编码
	int sum=0;
	sort(c+1,c+1+n,cmp);
	while(++sum<=m)
	{
		printf("%d ",c[1].dui);
		int num=c[1].id;
		now[num]++;//now为函数F中的x值
		int y=now[num];
		c[1].dui=f[num].a*y*y+f[num].b*y+f[num].d;//替换c[1].dui
		int x=1;
		while(x<<1<=n)//堆维护
		{
			int s=x<<1;
            if(c[s].dui>c[s+1].dui&&s+1<=n) s++;
            if(c[x].dui>c[s].dui)
            {
                swap(c[x],c[s]);
                x=s;  
            }
			else break;
		}
	}
	return 0;
}
```
# 这是一篇良心题解，虽然我知道高手如云，但我依然希望可以帮助大家

---

## 作者：mrgogoup (赞：0)

 ## 思路
 因为数据量是很大的，所以可以用到小根堆降低时间复杂度。优化后时间复杂度为**O(m*log2n)**
 
函数在第一象限都是**单调递增**的。对称轴x=-b/(2*a)

 ## 步骤
 1.先把每个函数自变量x=1的值求出来，然后建立小根堆，再将堆顶值a[1]输出(一定是最小的)
 
 2.选择计算刚才堆顶值的那个函数，**其自变量x增加1**，重新计算函数值，并**放到堆顶**。
 理由：由于函数在第一象限都是单调递减的，所以如果A函数值是当前最小的，有可能A函数值一直是最小的，直到有另一个B函数的值超过A函数的值，则选择B函数，此后它可能最小，**没有必要每次都把n个函数值求出**，大大降低了时间复杂度。

3.重复第二步m次。

 ### 代码：
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define fr(a , b , c) for(register ll a = b;a <= c;a++)
ll read(){
	ll i = 0 , f = 1;
	char ch;
	for(ch = getchar();!isdigit(ch)&&ch!='-';ch = getchar());
	if(ch == '-'){
		f = -1;
		ch = getchar();
	}
	for(;isdigit(ch);ch = getchar())
		i = (i<<3)+(i<<1)+ch-'0';
	return i*f;
}
const int N = 500001;
ll n , m , a[N] , b[N] , c[N] , x[N];
priority_queue<pair<ll,ll> >q;//堆中有两个变量，以第一个变量排序
ll f(ll x , ll i){
	return a[i]*x*x+b[i]*x+c[i];
}//这样写很明了且简洁
int main(){
	n = read() , m = read();
	fr(i , 1 , n) a[i] = read() , b[i] = read() , c[i] = read();
	fr(i , 1 , n){
		q.push(make_pair(-f(1 , i) , i));
		//因为二叉堆初始化是大根堆，而在分析中
        //我们知道应该用小根堆。这里我用到一个
        //技巧，每次加入负数，就变成小根堆了。
		x[i] = 1;//s是记录函数i的自变量累加的数组
	}
	fr(i , 1 , m){//求m个函数值
		printf("%lld " , -q.top().first);//输出最小函数值(小根堆最小值)
		ll k = q.top().second;//用k记录堆顶函数的编号(上次最小的那个)
		x[k]++;//第k个函数的x增加1
		q.pop();
		q.push(make_pair(-f(x[k] , k) , k));//放到堆顶，覆盖以前的值
	}
	return 0;
}
```
**结语**：说实话，我认为这的确是一道很好的二叉堆的应用。大家一定要理解透彻后写一写代码，代码的细节也很多，我都在注释中呈现了。

---

## 作者：chenkaixing (赞：0)

可以说这是一个不太难的堆的问题；（来一发pascal）

这题一定不能用直接循环的堆，会很慢，会爆掉；

其次，避免一个小误区（题目坑我，第一次没ak）：最后一个数只要输出一次，不论后面是否还有相同的

由于题目中的函数满足在正无穷上单调递增，所以1的函数值一定是单个函数中最小的，于是把每个函数的第一个值放进堆里；

然后像我的程序里面s[?,1]用来记录函数值，s[?,2]用来记录是哪个函数，然后问题就简单了，只要每次输出一个小根堆的顶部，然后

把对应函数的下个值加进堆里面，直到输出m个（【注】交换值时记得s的两个值一起换）

下面是我的code：


```cpp
program min;
var
    s:array[0..10000,1..2]of longint;
    a,b,c,d:array[1..10000]of longint;
    i,j,n,m,p,t,x,y,sum,ans:longint;
procedure intt(y:longint);//堆的插入操作
var
    o,temp:longint;
begin
      inc(t);
      s[t,1]:=y;
      s[t,2]:=x;
      o:=t;
      while (o>0)and(s[o shr 1,1]>s[o,1])do
      begin
            temp:=s[o shr 1,1];
            s[o shr 1,1]:=s[o,1];
            s[o,1]:=temp;
            temp:=s[o shr 1,2];
            s[o shr 1,2]:=s[o,2];
            s[o,2]:=temp;
            o:=o shr 1;
      end;
end;
function outt():longint;//找小根堆的顶值
var
    i,j,temp:longint;
    p:boolean;
begin
      outt:=s[1,1];
      s[1,1]:=s[t,1];
      s[1,2]:=s[t,2];
      dec(t);
      i:=1;
      p:=true;
      while (p)and(i shl 1<=t)do
      begin
            if (i shl 1+1>t)or(s[i shl 1,1]<s[i shl 1+1,1])then j:=i shl 1
            else j:=i shl 1+1;
            if s[j,1]<s[i,1] then
            begin
                  temp:=s[j,1];
                  s[j,1]:=s[i,1];
                  s[i,1]:=temp;
                  temp:=s[j,2];
                  s[j,2]:=s[i,2];
                  s[i,2]:=temp;
                  i:=j;
            end
            else p:=false;
      end;
end;
begin
      readln(n,m);
      for i:=1 to n do
      begin
            readln(a[i],b[i],c[i]);
            x:=i; //初始赋值，别忘了
            intt(a[i]+b[i]+c[i]);//把1的函数值放进去
            inc(d[i]);//d用来记录这个函数已经计算到了哪个值
      end;
      for j:=1 to m do
      begin
            x:=s[1,2];//找到该函数的位置
            inc(d[x]);//计算还没算过的值
            ans:=outt();
            write(ans,' ');//输出当前最小值
            if j<m then//尽量减少计算次数0-0
            begin
                  intt(a[x]*d[x]*d[x]+b[x]*d[x]+c[x]);//插入值
            end;
      end;
end.

```

---

## 作者：bobble (赞：0)

//先计算出x=1时候的情况存Heap里

//然后每次找最小时，插入当前的最小的所属的函数f[i](x+1)到root ，然后维护小根堆

（为什么？根据不等式的性质if a<b then a\*c<b\*c while c>0）












```cpp
//w记录当前的函数最大的x
//name[i]表示第I个节点的是第几个函数
//insert插入一个新元素到堆，然后维护堆的性质，这里是维护小根堆
//get得到当前最小值就是root，然后删掉把最后的一个元素作为root然后维护小根堆
program wonder;
const
  inf='minval.in';
  outf='minval.out';
var
  len,i,j,n,tmp,ans,m:longint;
  heap,w,a,b,c,name:array[0..10000] of longint;
procedure swap(var aa,bb:longint);
var t:longint;
begin
  t:=aa;  aa:=bb;  bb:=t;
end;
procedure insert(tmp:longint);
var
  i:longint;
begin
  inc(len);
  heap[len]:=tmp; name[len]:=len;
  i:=len;
  while (i>1) and (heap[i div 2]>heap[i]) do
  begin
    swap(heap[i],heap[i div 2]);
    swap(name[i],name[i div 2]);
    i:=i div 2;
  end;
end;
procedure ch;
var
 dad,son:longint;
 stop:boolean;
begin
  write(heap[1],' ');
  inc(w[name[1]]);
  heap[1]:=w[name[1]]*w[name[1]]*a[name[1]]+w[name[1]]*b[name[1]]+c[name[1]];
  dad:=1;
  stop:=false;
  while ((dad*2+1<=len) or (dad*2<=len)) and (not stop) do
  begin
   if (heap[dad*2+1]>heap[dad*2]) or (dad*2+1>len) then
    son:=dad*2
    else son:=dad*2+1;
   if heap[dad]<=heap[son] then stop:=true
    else begin
           swap(heap[dad],heap[son]);
           swap(name[dad],name[son]);
           dad:=son;  //!!!!
         end;
  end;
end;
begin
  assign(input,inf);  assign(output,outf);
  reset(input);   rewrite(output);
  readln(n,m);
  for i:= 1 to n do
  begin
    read(a[i],b[i],c[i]);
    tmp:=a[i]+b[i]+c[i];
    w[i]:=1;
    insert(tmp);
  end;
  for i:= 1 to m do ch;
  close(input); close(output);
end.
```

---

## 作者：约修亚_RK (赞：0)

用了一个优先队列来存当前最小的m个答案，再用一个set来存能够得到更优答案的点，最后拿一个vector来逆序输出...

因为f(x)=ax^2+bx+c中的a,b,c,x都属于正整数集，所以显然f(x)是增函数。

那么让x从1开始每次递增1，遍历set中的每一个二次函数并代入x求值。

当优先队列中的值不满m个，【就直接把这个值压入优先队列】；

否则，【如果这个值比优先队列中的最大值还小，就弹出优先队列中的最大值，压入这个值；反之，这个二次函数在之后也不可能得到更小的值（因为它是增函数），从set中把它除去即可】。

当set为空时，说明所有的二次函数都得不到更优解了。这时候优先队列中恰有m个元素，逆序输出即可。


```cpp
/* P2085
 * Au: SJoshua
 */
#include <cstdio>
#include <queue>
#include <vector> 
#include <set> 
#include <algorithm>

using namespace std;

struct node {
    int a, b, c;
} list[10001];

priority_queue <int> ans;
vector <int> output;
set <int> sel;
 
int main(void) {
    int n, m, vis = 0;
    scanf("%d %d", &n, &m);
    for (int k = 0; k < n; k++) {
        scanf("%d %d %d", &list[k].a, &list[k].b, &list[k].c);
        sel.insert(k); 
    }
    while (!sel.empty()) {
        vis++;
        int mark = -1; 
        for (set <int> :: iterator it = sel.begin(); it != sel.end(); it++) {
            int calc = list[*it].a*vis*vis + list[*it].b*vis + list[*it].c;
            if (ans.size() == (unsigned int)m) {
                if (mark != -1) {
                    sel.erase(mark);
                    mark = -1; 
                 }
                if (calc < ans.top()) {
                    ans.pop();
                    ans.push(calc); 
                } else {
                    mark = *it; 
                } 
            } else {
                ans.push(calc); 
            }
        } 
        if (mark != -1) {
            sel.erase(mark);
        }
    } 
    for (int k = 0; k < m; k++) {
        output.push_back(ans.top());
        ans.pop();
    }
    for (int k = 0; k < m; k++) {
        printf("%d ", output[m-k-1]); 
    } 
    return 0;
}
```

---

## 作者：神一般的世界 (赞：0)

Hi！ 我胡汉三又回来啦！

大家有没有发现p1935和p2085一模一样

既然2085用堆AC了那么水题就要用STL AC

什么逻辑！！！！

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<queue>
#include<cstring>
using namespace std;
struct node{
    int v,id;
};
struct cmp{//这是个仿函数
    bool operator ()(node a,node b){
        return a.v>b.v;
    }
};
priority_queue<node,vector<node>,cmp> q;//这是个小根堆
int ans[20000],a[20000],b[20000],c[20000],d[20000];
int n,m;
node x,y;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&a[i],&b[i],&c[i]);
        x.v=a[i]+b[i]+c[i];x.id=i;
        d[i]=1;q.push(x);
    }
    for(int i=1;i<=m;i++){
        y=q.top();q.pop();
        ans[i]=y.v;d[y.id]++;
        int t=y.id;
        x.id=y.id;x.v=a[t]*d[t]*d[t]+b[t]*d[t]+c[t];
        q.push(x);
    }
    for(int i=1;i<=m;i++){
        printf("%d ",ans[i]);
    }
    return 0;
}
是不是觉得STL很神奇haha
```

---

## 作者：Ste_ (赞：0)

//楼下讲的很清楚了，不过c++选手用优先队列实现堆简单快捷，懒人必备~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int Mx=10005;
struct node{
    int f,val,x;
    bool operator <(const node &s)const{
        return val>s.val;
    }
};
int n,m;
int mp[3][Mx];
priority_queue <node> q;
int s(int i,int j)
{
    return mp[0][i]*j*j+mp[1][i]*j+mp[2][i];
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>mp[0][i]>>mp[1][i]>>mp[2][i];
    }
    for(int i=1;i<=n;i++)
    {
        q.push((node){i,s(i,1),1});
    }
    while(m>0)
    {
        node t=q.top();
        q.pop();
        cout<<t.val<<' ';
        m--;
        q.push((node){t.f,s(t.f,t.x+1),t.x+1});
    }
    cout<<endl;//代码结束回车很重要
    return 0;
}

```

---

## 作者：Kwork (赞：0)

说实话这一题的评级有点过了，思路很简单的。

小学生或者刚上初中的朋友或许不知道二次函数的性质，可以问一下数学老师。（数学老师：数据那么大计算器要按到什么时候？？？！）

通过题目说明，我们可以知道，出题人没有刻意为难我们，每一个f(x)的图像的对称轴都在y轴的左边，所以在定义域内的f(x)是单调递增的，自然联想到可以维护一个小根堆，每次取出最小值。设取出的是函数fi的fi(x)，那么我们push fi(x+1)，可以保证正确。

```cpp

#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <queue>//懒得手动写堆，用stl库大法。
using namespace std;
const int maxn=10005;
typedef long long ll;//稳一点，以免爆 int。
typedef pair<ll,int> pp;
struct data{int a;int b;int c;};
data function[maxn];//记录每个函数a,b,c.
int n,m;
priority_queue<pp,vector<pp>,greater<pp> >que;//小根堆

void init(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>function[i].a>>function[i].b>>function[i].c;
    return;
}
ll calcu(int f,int x){//函数值的计算。
    ll t=x*x*function[f].a+x*function[f].b+function[f].c;
    return t;
}
void solve(){
    int tool[maxn];
    for(int i=1;i<=n;i++) tool[i]=1;
    for(int i=1;i<=n;i++){
        ll temp=calcu(i,1);
        pp s(temp,i);
        que.push(s);
    }//堆的初始状态。
    for(int i=0;i<m;i++){//依次去除前m小的值并更新堆。
        pp s=que.top();
        que.pop();
        int which=s.second;
        printf("%lld ",s.first);
        tool[which]++;
        ll t=calcu(which,tool[which]);
        pp tt(t,which);
        que.push(tt);
    }

    return;
}
int main(){
    //freopen("1.txt","r",stdin);//不要抄文件操作
    //freopen("2.txt","w",stdout);
    std::ios::sync_with_stdio(false);
    init();
    solve();

    return 0;
}

```

---

## 作者：QWsin (赞：0)

**
既然这道题是二次函数  首先明确Ai一定不会小于0  那样没有最小值

好  那么Ai大于0了  最小值在对称轴-b/2a  先找每个函数最小值

先用一个double把对称轴存下设为k

若k为整数 三个操作

Fi(k) Fi(k-1) Fi(k+1)入堆待选   Fi(k-1) 和 Fi(k+1)是为了后面方便扩展

否则 设k' 为(int)k Fi(k) Fi(k+1)入堆（因为这两个点必定是离对称轴最近的两个x为整数的点）


剩下的  看代码吧

总的思想：先找到最小值所在处  入堆  然后每次取出最小的一个 往左边或者右边走一个单位长度 把这个点放入堆中  如此往复m次

**
```cpp

#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int INF=(1<<30);
struct Node{
    int a,b,c,nowx,value,wh;//nowx为当前x值  value为函数值 wh为标示符  往左为-1 往右为1 二次函数顶点为0
    void input(){
        scanf("%d%d%d",&a,&b,&c);
    }
    bool operator < (const Node &rhs)const{
        return value>rhs.value;
    }
    Node(){}
    Node(int a,int b,int c,int n,int v,int wh):a(a),b(b),c(c),nowx(n),value(v),wh(wh){}
    Node(Node x,int nx,int v,int w){
        a=x.a;
        b=x.b;
        c=x.c;
        nowx=nx;
        value=v;
        wh=w;
    }
}tmp;

int f(Node a,int x)                     //利用a里面的a,b,c值  主要是人懒不想写int a,int b,int c
{
    return a.a*x*x+a.b*x+a.c;
}

priority_queue<Node>q;
int main()
{
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++)////每个函数最小值入堆
    {
        tmp.input();
        double x=-1*tmp.b/2.0*tmp.a;
        if(x<=0)//要求x为正整数  若对称轴x<=0  Fi(1)即为最小值
        {
            q.push(Node(tmp,1,f(tmp,1),1));
            continue;
        }
        int v1=f(tmp,(int)x);
        int v2=f(tmp,(int)x+1);
        if((int)x<=0) v1=INF;//往左扩展时需保证 x>=1
        if((int)x==x)//对称轴刚好在整数点
        {
            q.push(Node(tmp,(int)x-1,f(tmp,(int)x-1),-1));
            q.push(Node(tmp,(int)x,v1,0));
            q.push(Node(tmp,(int)x+1,v2,1));
            
        }
        else
        {
            q.push(Node(tmp,(int)x,v1,-1));
            q.push(Node(tmp,(int)x+1,v2,1));
        }
        
    }
    int cnt=0;
    for(;;)
    {
        Node x=q.top();q.pop();
        printf("%d ",x.value);
        if(++cnt==m) break;
        if(x.wh==0) continue;///这里是特判函数顶点  过滤掉
        if(x.nowx+x.wh<=0) continue;
        int v1=f(x,x.nowx+x.wh);
        Node c=Node(x,x.nowx+x.wh,v1,x.wh);
        q.push(c);
    }
    return 0;
}


```

---

## 作者：TMXi (赞：0)

**很明显的堆**

【出题人有提示的诶！】


首先，如果要是把Fi(x)的值从 x=0 到 x=m 都计算一遍，一定会TLE


所以，可以维护一个大根堆，**heap[1]**用来存当前的最大值，

如果计算出了Fi(x)<heap[1],那么就用Fi(x)替换heap[1]，然后更新堆，

如果Fi(x) >= heap[1] 由于二次函数性质，Fi(x+1)一定会大于heap[1]，这时用judge[i]来标记，下次操作时直接跳过，知道i=1 . . n全部被标记，结束枚举，


然后，然后就是排序、输出，就可以了。。。


更新堆：

```cpp

void max_heap(int x){
    int x1=x<<1;
    int x2=(x<<1)+1;
    int maxnum;
    if(x1<=m){
        if(heap[x1]>heap[x])maxnum=x1;
        else maxnum=x;
    }
    else maxnum=x;
    if(x2<=m){
        if(heap[x2]>heap[maxnum])maxnum=x2;
    }
    else ;
    if(maxnum!=x){
        heap[maxnum]^=heap[x]^=heap[maxnum]^=heap[x];
        max_heap(maxnum);
    }
}

```

---


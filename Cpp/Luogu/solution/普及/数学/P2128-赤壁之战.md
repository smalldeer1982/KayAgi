# 赤壁之战

## 题目描述

赤壁之战，黄盖率舰满载薪草膏油诈降曹军。

受庞统所授的连环计，曹军战船之间由铁索相连，没有两艘战船在同一位置，也没有铁索两两相交或穿过战船。每艘船都有其一定的战略价值。

为了保证达到破坏效果，黄盖需要保证被点燃的曹军船只两两之间都有铁索连接。他希望找到一种方案点燃总价值尽可能大的战船。


## 说明/提示

#### 【数据规模】

对于 $50\%$ 的数据，保证 $N$，$M \le 10$。

对于 $100\%$ 数据，保证 $N \le 450$，$M \le 900$，$V_i \le 6000$。

#### 【注意】

题目中的每句话（除了第一段）都有作用。

## 样例 #1

### 输入

```
4 6
100
5000
1000
2000
1 2
1 3
1 4
2 3
2 4
3 4```

### 输出

```
8100```

## 样例 #2

### 输入

```
6 8
1500
1000
100
2000
500
300
1 2
1 3
1 4
2 4
3 5
4 5
4 6
5 6```

### 输出

```
4500```

# 题解

## 作者：06ray (赞：22)

这道题用搜索与回溯的方法AC。思路是枚举第i艘船并判断是否与前面选的船都有铁索相连。如果都有，就把这艘船的编号放进一个数组里。最后用一个max1的数存最大值，输出max1。

代码如下(\*^▽^\*)


```cpp
#include <bits/stdc++.h>//懒人喜欢的万能头文件
using namespace std;
int a[1000],b[5000][5000],c[10000],used[100000];//a数组存的是每艘船的价值，b数组是与每两艘船的关系，c是存放选中的船的价值，used是判断i艘船是否被选过
int n,m,n1,max1=0;
bool pd(int x,int n1)//判断第i艘船是否与前面选的船都有铁索相连
{
    for(int i=1; i<=n1; i++)
    if(b[c[i]][x]==false) 
    {
        return false;
    }
    return true;
}
int search(int t,int s)//搜索函数
{
        if(s>max1) max1=s;//如果当前累加的价值大于目前最大值，就刷新最大值。
    for(int i=1; i<=n; i++)
    if(t==1||!used[i]&&pd(i,n1))//如果第i艘船没使用过且第i艘船与前面选的船都有铁索相连（搜索第一个数除外）
    {
        used[i]=true;//标记第i艘船使用过
        c[++n1]=i;//将第i艘船的编号放进c数组
        search(t+1,s+a[i]);//搜索一步
        used[i]=false;//回溯一步
        n1--;
    }
}
int main()
{
    cin>>n>>m;//读入
    for(int i=1; i<=n; i++)
    cin>>a[i];//读入
    for(int i=1; i<=m; i++)
    {
        int x,y;
        cin>>x>>y;//读入
        b[x][y]=true;//将x,y建立有铁索的关系
        b[y][x]=true;//将x,y建立有铁索的关系
    }
    search(1,0);//搜索
    cout<<max1;//输出
}
本人蒟蒻一枚，望各位大佬，大神们多多指教。
```

---

## 作者：zhuaiballl (赞：16)

既然点开题解了就说明已经放弃思考了对吧。。。题目说没有铁索两两相交或穿过战船，也就是说这个图是个平面图（只要看到并且信了这句话，那这道题就做完了）。平面图里的完全图最多有4个点，所以暴力找4个点就好了，复杂度$O(m^2)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int u[910],v[910],val[460];
bool conn[460][460];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",val+i);
    for(int i=0;i<m;i++)
    {
        scanf("%d%d",u+i,v+i);
        conn[v[i]][u[i]]=conn[u[i]][v[i]]=true;
    }
    int ans=0;
    for(int i=0;i<m;i++)
    {
        int res=val[u[i]]+val[v[i]];
        ans=max(ans,res);
        for(int j=1;j<=n;j++)
            if(conn[v[i]][j]&&conn[u[i]][j])
            ans=max(ans,res+val[j]);
        for(int j=0;j<i;j++)
            if(conn[u[i]][u[j]]&&conn[u[i]][v[j]]&&conn[v[i]][u[j]]&&conn[v[i]][v[j]])
                ans=max(ans,res+val[u[j]]+val[v[j]]);
    }
    return 0*printf("%d\n",ans);
}

```
ps.一开始我是不信这图是平面图的，铁索两两不相交，又没说不能一条铁索从另一条铁索下面穿过。不是平面图的话还挺难的（对我来说），大概要花式搜索？后来翻了翻过了的提交，都是0ms，果断水题水过。

---

## 作者：Gadfly (赞：7)

- ##  setting
#### 首先一看题目还以为是求所有能够连接起来的船的价值总和，讨论区那里也表达了一下题目有问题balabala的，后来仔细看了一边题目~~看到了下面辣个注意之后~~就orz了
## **~~mdzz文字游戏~~**
####  “题目中的每句话（除了第一段）都有作用。”
####  “黄盖需要保证被点燃的曹军船只~~两两之间~~都有铁索连接”
####  所以？没看清题目的~~奆佬~~小伙伴们....

- ## solution
#### 显然第一眼应该是DFS，我们可以用一个计数器z来记录能够点燃的船的数量，这样就可以枚举前z个已知船与搜索到的目标船是否相连，这里我们用数组b[]来记录前z艘船的编号

- ## code

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define F(i,a,b) for(register int i=a;i<=b;i++)
int n,m,ans=0;
int v[500][500],w[500],vis[500];
int b[500];
void dfs(int sum,int z)
{
	ans=std::max(sum,ans);//更新答案
	if(z>=n) return; 
	for(int i=1;i<=n;i++) if(!vis[i])//搜索目标/可行船
	{
		int js=0;
		for(int j=1;j<=z;j++) if(!v[b[j]][i]) {js=1; break;}//判断是否与前z艘船相连
		if(!js) {b[z+1]=i; vis[i]=1;/*注意这里*/ dfs(sum+w[i],z+1); b[z+1]=0; vis[i]=0; }//回溯
	}
	return;
}
int main()
{
	int x,y;
	memset(v,0,sizeof(v));
	scanf("%d%d",&n,&m);
	F(i,1,n) scanf("%d",&w[i]);
	F(i,1,m) {scanf("%d%d",&x,&y); v[x][y]=1;}
	for(int i=1;i<=n;i++)
	{
		memset(b,0,sizeof(b));
		memset(vis,0,sizeof(vis));
		vis[i]=1;
		b[1]=i;//注意这里，第一艘船
		dfs(w[i],1);//枚举从第i艘船开始搜，价值初始为w[i]
	}
	printf("%d",ans);
	return 0;
}
```

- ## ending
用时: 8ms / 内存: 3148KB
ps：~~其实vis[]不标记回溯也能过，谁让数据太水呢（滑稽）~~
#### 最后这是本蒟第一篇题解，~~欢迎大佬们拍砖~~

---

## 作者：osfly (赞：3)

可能是我第一篇被通过的题解

好一道图论水题！（虽然因为没有审题交了两遍才过

这题好长啊，一句话题意：

---
`求无向图中的完全图的最大点权和`
---

那就很简单了

对读入的图存为两种形式：邻接矩阵和邻接表

邻接矩阵是为了更快的判断两点之间有没有边

邻接表是为了更快的枚举每一个点所连的每一条边（虽然没有这个必要，但是如果数据更毒瘤的话就有这个必要了

这里我写了链式前向星

[不会写链式前向星的戳这里](https://baidu.physton.com/?q=%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F)

读入：

```cpp
#include<cstdio>
struct edge
{
	int v,nxt;
}e[1000*2];
int head[500];
int tot;
int n,m;
int k[500];
bool g[500][500];
void add(int u,int v)
{
	e[++tot].v=v;
	e[tot].nxt=head[u];
	head[u]=tot;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&k[i]);//点权
	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		g[u][v]=g[v][u]=1;
		add(u,v);
		add(v,u);
	}
	return 0;
}
```

为了求点权，我们得用 `dfs` 搜一下（记得还要判断当前加入的点能否构成完全图

怎么判断是不是完全图呢？

我们把之前加入的点放在一个数组里，然后，每加入一个点，就用邻接矩阵来判断这个点是否与之前加入的点全部都有连边

有的话，那么加入这个点后依然是完全图

没有的话，就不能加上这个点

```cpp
bool vis[500];
int now[500];//之前加入的点的编号
int t;//目前加入的点数（船只数量）
bool check(int id)//判断是不是完全图
{
	for(int i=1;i<=t;i++)
		if(!g[id][now[i]]) return false;//与其中一点没有连边，则不是完全图
	return true;//与所有点都有连边，是完全图
}
void dfs(int x,int value)
{
	ans=max(ans,value);
	vis[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(!vis[v]&&check(v))
		{
			now[++t]=v;
			dfs(v,value+k[v]);
			t--;//记得回溯
		}
	}
	vis[x]=0;//记得回溯
}
```

这里要对每一个点 `dfs` 一下

```cpp
for(int i=1;i<=n;i++) now[1]=i,t=1,dfs(i,k[i]);
```

完整 `code`

```cpp
#include<cstdio>
struct edge
{
	int v,nxt;
}e[1000*2];
int head[500];
int tot;
int n,m;
int ans;
int k[500];
bool g[500][500];
bool vis[500];
int now[500];
int t;
int max(int a,int b)
{
	return a>b?a:b;
}
void add(int u,int v)
{
	e[++tot].v=v;
	e[tot].nxt=head[u];
	head[u]=tot;
}
bool check(int id)
{
	for(int i=1;i<=t;i++)
		if(!g[id][now[i]]) return false;
	return true;
}
void dfs(int x,int value)
{
	ans=max(ans,value);
	vis[x]=1;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(!vis[v]&&check(v))
		{
			now[++t]=v;
			dfs(v,value+k[v]);
			t--;
		}
	}
	vis[x]=0;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&k[i]);
	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		g[u][v]=g[v][u]=1;
		add(u,v);
		add(v,u);
	}
	for(int i=1;i<=n;i++) now[1]=i,t=1,dfs(i,k[i]);
	printf("%d",ans);
	return 0;
}
```

# thx for reading

---

## 作者：simonG (赞：2)

### 前言
这不是图论，但是赤壁之战与深度优先搜索有很大的关系。
### 详解
> 1,乍一看，这不是图论吗？先建个图。注意，是无向图！！  
> 2,建完图，该开始dfs了吧。不过，这和图的遍历有很大的关系。建立一个$vis$数组，然后，开始遍历。如果$vis$未标记，继续加深，否则，记录答案，回溯。  
> 3,怎么判断两船之间有无联系，能否加深？很简单，即建立一个$check$函数。


### 代码
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n,m;
int mp[500][500],v[500],vis[500];
//v是每条船的价值，vis是记录每条船是否被记录
int ans;//最终答案
int a[500],len;
//len是深度，a是存储深度的答案
bool check(int u)
{
	for(int i=1; i<=len; i++)
		if(mp[a[i]][u]==0&&mp[u][a[i]]==0)return 0;
	return 1;
}//check函数，判断能否加深
void dfs(int dep,int sum)
{
	ans=max(ans,sum);//更新答案
	for(int i=1; i<=n; i++) {
		if(dep==1||vis[i]==0&&check(i)) {
			vis[i]=1;
			a[++len]=i;//搜索
			dfs(dep+1,sum+v[i]);
			vis[i]=0;//回溯
			len--;
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)scanf("%d",&v[i]);
	for(int i=1; i<=m; i++) {
		int x,y;
		scanf("%d%d",&x,&y);
		mp[x][y]=mp[y][x]=1;
	}//输入，建图
	dfs(1,0);//搜索
	printf("%d\n",ans);//答案
	return 0;
}
```

### 后记
2021

---

## 作者：lmrttx (赞：0)

本题用 $DFS$ 解决。

先说下 $DFS$ 是什么吧。这就是搜索的一种，叫做深度优先搜索或者深搜。思想就是递归，判断何时退出搜索，以及回溯。回溯就是退回到某个过去的状态，重新开始搜索，这样更新答案的话答案正确性更高。


------------

接下来是更详细的介绍，如果已会自行跳过：

搜索是指对情况进行查找并且处理，如本题，我们就要把一艘艘船加进来处理。本题的处理是**通过情况更新最大值**。

这种搜索的思路是沿一个道路一直搜索，直到无路可走时，往回走，即回溯。我们由于有处理，所以可以从一个状态回到之前的状态。

图解，图片来源于百度。

![](https://p1.ssl.qhimgs1.com/sdr/400__/t017ed8533be81d6521.jpg)


![](https://p3.ssl.qhimgs1.com/sdr/400__/t01d9b359c58b1c695d.png)

从1号点开始搜索，一直走到6号点，这时无路可走了。回溯。一直到2号点。接着搜索5号点，然后到7号点。分别搜索4号点和8号点与9号点那一条路径。此时又回溯到5号点了。退回至1号点。

由于走过的点会被标记为走过，所以此时所有点的标记都是走过。无路可走时，便退出搜索，输出答案。

这个标记数组通常叫做 $vis$ 或 $visit$ 。

本题就是 $DFS$ 的框架，回溯与搜索于代码中理解。

$DFS$ 本身是递归，请先了解递归。

~~不用出门右转了，这边讲了。~~

递归就是在一个函数中直接或间接地调用到函数本身。但是一直调用，总要有返回的时候。于是要设置边界，符合边界条件时，层层返回。这一过程用栈在计算机内部实现。栈是一种**先进后出**的数据结构，一个表。

介绍完毕，见题目吧。

---------------------------------------------------------
题目分析：

发现是个搜索。看到

$"曹军战船之间由铁索相连，没有两艘战船在同一位置，也没有铁索两两相交或穿过战船。"$

这句话时，就意识到是个点与点之间的 $DFS$ 了。搜索，判断是否返回，每次递归更新答案。

---------------------------------------------------------

注释和细节等见代码，让我们用代码分析这种搜索吧！

C++ CODE ：

 ```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAX 1001
int n,m,a[MAX][MAX],answer,v[MAX],boat[MAX];
bool vis[MAX];//vis为标记数组，表示是否搜索过编号为多少的船
void dfs(int ans,int x){//ans为当前最优的战略价值，x为在这一次搜索中，已经有了几艘船。
	answer=max(answer,ans);//更新答案
    if(x>n)return;//退出边界
    for(register int i=1;i<=n;i++){
        if(vis[i]==0){//还未访问
            bool tag=true;//标记，这个标记指从当前一艘船向别的船搜索，还有没有连接的船，还能不能搜索下去。如果不能，退出，返回上一层。
            for(int j=1;j<=x;j++)//循环，搜索的基础。
            if(a[boat[j]][i]==0)//如果两艘船没有连接
            {
                tag=false;break;
                //无路可走，标记更新为假
            }
            if(tag==true){
                boat[x+1]=i;
                vis[i]=true;
                //每有一个新的搜索出发处，就要把这些东西处理一下。表示下一艘船是这艘，这艘被访问过了。
                dfs(ans+v[i],x+1);
                //递归搜索，总价值加上当前的价值，船的数量加1.
                boat[x+1]=0;
                vis[i]=false;
                //回溯，回到搜索前的状态。
                //因为我们的目标是让答案最优，所以回溯并不影响答案，只会让答案更加正确
            }
        }
    }
    return;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>v[i];
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		a[x][y]=666;//随便初始化为一个非0的数就可以了，因为为0时表示当前两艘船之间没有连接。
	}
    //搜索策略，从每艘船出发搜一遍
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));//由于每次都重新搜一遍，所以要清零
		memset(boat,0,sizeof(boat));
        //boat表示在这一次搜索中，第几艘船的编号为多少
		vis[i]=true;
		boat[1]=i;//初始化
		dfs(v[i],1);
	}
    cout<<answer<<endl;
    return 0;
} 
```

作为一个基本 $DFS$，这题的练习意义还是很大的。蒟蒻最近在练习写题解，如有不足，可私聊提出。谢谢阅读，真心希望这篇题解对您有帮助！

---

## 作者：hylong (赞：0)

我又来$H_{2}O$题解了。
#### 注：
 最好不要用并查集，理由见2.。如果可以，麻烦各位大佬私信我，我会及早修改 ~~（除非我退役）~~。

#### 题目描述：
  赤壁之战，黄盖率舰满载薪草膏油诈降曹军。

受庞统所授的连环计，曹军战船之间由铁索相连， **1.没有两艘战船在同一位置，也没有铁索两两相交或穿过战船。** 每艘船都有其一定的战略价值。

为了保证达到破坏效果，黄盖需要保证**2.被点燃的曹军船只两两之间都有铁索连接**。他希望找到一种方案点燃总价值尽可能大的战船。（如果你还是没有想法的话，请直接看代码）
#### 思路：
   用dfs来求最大价值，具体可以看代码解释，这里不好讲。
#### 代码：

开O2：201ms，不开：756ms ~~（其实还可以卡卡常）~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500],n,m,v[500],ans;
int mapp[500][500];
int read()
{
	int x=0;
	char b=getchar();
	while(b>'9' || b<'0')
	 b=getchar();
	while(b>='0' && b<='9')
	{
	 x=x*10+b-'0';
	 b=getchar();
	}
	return x;
}
void dfs(int xh,int w)//xh：序号，w：价值
{
	int i;
	if(xh==n+1)
	{
	 ans=max(w,ans);
	 return ;
	}
	dfs(xh+1,w);//不烧的情况
	for(i=1;i<=xh;i++)
	 if(v[i]==1)
	  if(mapp[i][xh]==0)
	   return ;//判断是否能够加进去
	v[xh]=1;//标记
	dfs(xh+1,w+a[xh]);//烧的情况
	v[xh]=0;//回溯
}
int main()
{
	int i,j,b,c;
    n=read();m=read();
    for(i=1;i<=n;i++)
     a[i]=read();
    for(i=1;i<=m;i++)
    {
     b=read();
     c=read();
     mapp[b][c]=mapp[c][b]=1;
	}//初始化
	dfs(1,0);//搜索
    cout<<ans<<endl;//输出
    return 0; //结束
} 
```


---

## 作者：于洪铎 (赞：0)

**思路是枚举第 $i$ 艘船并判断是否与前面选的船都有铁索相连。如果都有，就把这艘船的编号放进一个数组里。最后用一个 $max1$ 的数存最大值，输出 $max1$ 。**
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000],b[5000][5000],c[10000],used[100000];//a数组存的是每艘船的价值，b数组是与每两艘船的关系，c是存放选中的船的价值，used是判断i艘船是否被选过
int n,m,n1,max1=0;
bool pd(int x,int n1){//判断第i艘船是否与前面选的船都有铁索相连
    for(int i=1; i<=n1; i++)
    if(b[c[i]][x]==false){
        return false;
    }
    return true;
}
int search(int t,int s){//搜索函数

        if(s>max1) max1=s;//如果当前累加的价值大于目前最大值，就刷新最大值。
    for(int i=1; i<=n; i++)
    if(t==1||!used[i]&&pd(i,n1)){//如果第i艘船没使用过且第i艘船与前面选的船都有铁索相连（搜索第一个数除外）
        used[i]=true;//标记第i艘船使用过
        c[++n1]=i;//将第i艘船的编号放进c数组
        search(t+1,s+a[i]);//搜索一步
        used[i]=false;//回溯一步
        n1--;
    }
}
int main()
{
    cin>>n>>m;//读入
    for(int i=1; i<=n; i++)
    cin>>a[i];//读入
    for(int i=1; i<=m; i++)
    {
        int x,y;
        cin>>x>>y;//读入
        b[x][y]=true;//将x,y建立有铁索的关系
        b[y][x]=true;//将x,y建立有铁索的关系
    }
    search(1,0);//搜索
    cout<<max1;//输出
}
```
求通过

---

## 作者：sid_shi1 (赞：0)

题目：[P2128 赤壁之战](https://www.luogu.com.cn/problem/P2128)

思路： dfs 搜索

可以把本题想成一个无向图，两条船相连的铁链为无向边，现在就可以从一艘船开始搜索，用一个变量 $sum$ 记最大的战略价值和，并往和它相连的船走，并标记走过（否则会死循环），然后回溯，每次到一艘船上答案都更新为最大战略价值和 $sum$ 。
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1001]={0},b[1001][1001]={0},num[1001]={0},ans=0,tot=0;
bool book[1001]={0};//记录某个船只有没有走过
void dfs(int sum,int k){
    ans=max(ans,sum);//反复更新ans得到最大的sum
    for(int i=k+1;i<=n;i++){
    	if(book[i]==false){//判断有没有走过
            int t=0;
            for(int j=1;j<=tot;j++) if(b[i][num[j]]) t++;//记录无铁链相连的个数
            if(t==tot){
                num[++tot]=i;
                book[i]=true;//标记为走过
                dfs(sum+a[i],i);//递归搜索
                book[i]=false;
                tot--;
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        b[x][y]=b[y][x]=1;//用邻接表建边，表示x和y之间有铁链
        //注意是无向边
    }
    dfs(0,0);//搜索,sum和k清零
    printf("%d",ans);
    return 0;
}
```


---


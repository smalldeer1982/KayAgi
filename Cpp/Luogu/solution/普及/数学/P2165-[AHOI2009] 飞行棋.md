# [AHOI2009] 飞行棋

## 题目描述

给出圆周上的若干个点，已知点与点之间的弧长，其值均为正整数，并依圆周顺序排列。请找出这些点中有没有可以围成矩形的，并希望在最短时间内找出所有不重复矩形。

## 说明/提示

$N \le 20$。

![](https://cdn.luogu.com.cn/upload/pic/13233.png)


## 样例 #1

### 输入

```
8
1
2
2
3
1
1
3
3
```

### 输出

```
3```

# 题解

## 作者：Tarsal (赞：16)

本蒟蒻又来发题解了，

看到这个题目，本蒟蒻直接开始推公式。。

嗯，可以通过弧长，推出弦长（l = 2 * r * cos(90 * l / (r * Π));

然后对比各条弦长的平方和与直径的平方。

就可以了 QwQ

### 以上纯属瞎掰，回到正题

在我写完上面那种算法，然后苦苦调不出的时候。

我开始，怀疑我是不是思路有问题。

事实证明，好像确实有问题；

## 以上纯属瞎掰，回到正题+1

我们想一想，矩形有什么性质：

四个角都是直角。

嗯，如果在一个圆周内，什么样的角才是直角。

嗯，直径所对应的圆周角肯定是直角。

我没说是直角就一定对应直径。

好，因为所以的角都是直角。

那么两条边肯定都是直径。

那不就好过了吗？

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define maxn 50
int n, a[maxn], s[maxn], ans, sum; 

int main()
{
	scanf("%d", &n);//输入 
	for(int i = 1; i <= n; ++ i)
	{
		scanf("%d", &a[i]);//输入 
		s[i] = s[i - 1] + a[i];//处理前缀和 
		sum += a[i];//sum是周长 
	}
	for(int i = 1; i <= n; ++ i)
		for(int j = i + 1; j <= n; ++ j)
			if(s[j] - s[i] == sum / 2)//判断是不是都是直径 
				++ ans;
	printf("%d", ans * (ans - 1) / 2);
	return 0;
}
```


---

## 作者：XiaoX (赞：16)

~~道理我都懂，你们代码不能简单点吗？~~
### ~~初三学生表示~~：直径所对的圆周角是直角，直径所对的弧是半圆
这道题做完了。。。

枚举$i,j$两点计算距离，如果距离为周长的一半，则$cnt++,$答案就为

$$C^{2}_{cnt}$$

然而处理距离不就前缀和一下就完了？
```
#include<iostream>
#include<cstdio>
#define N 55
using namespace std;
int n;
int a[N],s[N];
int ans,sum;

int main ()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		s[i]=s[i-1]+a[i];//前缀和
		sum+=a[i];//周长
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			if(s[j]-s[i]==sum/2) ans++;
		}
	}
	printf("%d",ans*(ans-1)/2);
}
```

---

## 作者：Heartlessly (赞：8)

## Description

给出圆周上的 $n$ 个点，已知点与点之间的弧长，其值均为正整数，并依照圆周顺序排列。求从中选出 $4$ 个点且能围成矩形的方案数。$(1 \leq n \leq 20)$

## Solution

最容易想到的方法是维护前缀和数组，枚举 $4$ 个点，计算点与点之间的弧长，判断相对的两条弧是否都相等即可（弧长相等，所对的弦长也相等，即矩形的对边相等）。时间复杂度为 $O({\rm C}_n^4)$，由于题目数据范围很小，可以轻松过。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 20;
int n, sum, ans, a[MAXN + 5], pre[MAXN + 5];

int main() {
    read(n);
    for (int i = 1; i <= n; ++i) {
        read(a[i]);
        pre[i] = pre[i - 1] + a[i];
    }
    for (int i = 1; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j)
            for (int k = j + 1; k <= n; ++k)
                for (int l = k + 1; l <= n; ++l) {
                    int a = pre[i] + pre[n] - pre[l], b = pre[j] - pre[i], 
                    c = pre[k] - pre[j], d = pre[l] - pre[k];
                    //a,b,c,d 表示 4 个点把圆分成 4 段弧的长度各是多少，
                    //注意 a 要拆成两条弧算。
                    if (a == c && b == d) ++ans;//相对的两条弧都相等
                }
    write(ans);
    putchar('\n');
    return 0;
}
```

稍微聪明一点的做法？

首先要知道圆内接矩形的对角线是该圆的直径，因为 $90^\circ$ 圆周角所对的弦是直径。假设有 $cnt$ 条直径，那么任意 $2$ 条不同的直径都能组成一个新的矩形，答案即为 ${\rm C}_{cnt}^2$ 。我们只需要枚举 $2$ 个点，判断这 $2$ 个点之间的距离是不是圆周长的一半，就可以得到直径的数量。时间复杂度为 $O({\rm C}_n^2)$ 。

注意特判圆周长是奇数时无解（所给的弧都是正整数，但半圆是小数，说明不存在直径），但是数据水不特判能过。

$\rm hack$ 数据：

**Input**

```
5
5 1 1 5 1
```

**Output**

```
0
```

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 20;
int n, cnt, pre[MAXN + 5];

int main() {
    read(n);
    for (int x, i = 1; i <= n; ++i) {
        read(x);
        pre[i] = pre[i - 1] + x;
    }
    if (pre[n] & 1) {//特判圆周长是奇数的情况 
        puts("0");
        return 0;
    }
    for (int i = 1; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j)
            if (pre[j] - pre[i] == pre[n] / 2)//判断两点间弧长是否为圆周长的一半
                ++cnt;
    write(cnt * (cnt - 1) / 2);//答案为 C(cnt, 2)
    putchar('\n');
    return 0;
}
```

由于前缀和数组是单调递增的，我们甚至还可以用二分查找把时间复杂度优化到 $O(n \log n)$ 。

即把枚举过程换成：

```cpp
for (int i = 1; i <= n; ++i)
    if (binary_search(pre + i + 1, pre + n + 1, pre[i] + pre[n] / 2))
        ++cnt;//用 STL 中的 binary_search 检查是否存在合法的 j
```

当然，由于这个单调递增的性质，也可以用尺取法（双指针法），时间复杂度为 $O(n)$ 。

```cpp
for (int l = 1, r = 2; l <= n && r <= n; ) {
    if (pre[r] - pre[l] < pre[n] / 2) ++r;
    //若两点间的弧长小于圆周长的一半，则移动右端点，使弧长增大
    else if (pre[r] - pre[l] > pre[n] / 2) ++l;
    //若两点间的弧长大于圆周长的一半，则移动左端点，使弧长减小
    else ++l, ++r, ++cnt;
    //若两点间的弧长等于圆周长的一半，则更新 cnt，
    //同时移动左端点和右端点，寻找新的直径
}
```

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 20;
int n, cnt, pre[MAXN + 5];

int main() {
    read(n);
    for (int x, i = 1; i <= n; ++i) {
        read(x);
        pre[i] = pre[i - 1] + x;
    }
    if (pre[n] & 1) {//特判圆周长是奇数的情况 
        puts("0");
        return 0;
    }
    for (int l = 1, r = 2; l <= n && r <= n; ) {
        if (pre[r] - pre[l] < pre[n] / 2) ++r;
        //若两点间的弧长小于圆周长的一半，则移动右端点，使弧长增大
        else if (pre[r] - pre[l] > pre[n] / 2) ++l;
        //若两点间的弧长大于圆周长的一半，则移动左端点，使弧长减小
        else ++l, ++r, ++cnt;
        //若两点间的弧长等于圆周长的一半，则更新 cnt，
        //同时移动左端点和右端点，寻找新的直径
    }
    write(cnt * (cnt - 1) / 2);
    putchar('\n');
    return 0;
}
```



---

## 作者：Shiwellyoung (赞：3)

这道题乍一看好像可以暴力就是遍历所有的距离来判断是否为矩形。但是往下划着划着就会发现：诶！怎么有一幅图？而且这幅图上不仅画出来了矩形而且还有对角线。emmmm大家可能就会想到圆的性质：直径所对的角为九十度。这样我们只需求出直径的个数就可以求出矩形的个数了。但是直径的个数要怎么求呢?可以这样——直径一定是把圆一分为二的，所以只需判断一段段小圆弧加起来是否为周长的1/2即可。还有就是要控制一下防止小弧的重复相加哦!
代码在这里:
```cpp
#include<iostream>
using namespace std;
int a,zj[21];//用一个数组就可以
int main()
{
	int n,c=0,sum=0;
	cin>>n;
	for(int i = 1; i <= n; i++)
	{	
		cin>>a;
		c+=a;//求周长
		zj[i]+=zj[i-1]+a;//依次累加每一小弧
	}
	for(int i = 1; i <= n; i++)	
	{
		for(int j = i + 1 ; j <= n ; j++)
			{
				if(zj[j]-zj[i]==(c/2)) sum++;//判断是否为周长一半
			}
	}
	cout<<(sum*(sum-1))/2;计算矩形个数
}
```


---

## 作者：STILL_ALONE (赞：3)

由于我太蒟了，所以我只能来刷黄题了。  
经过我努力的一天，我终于找到了一道称心如意的水题。  
~~话说你们恶意评分真的好吗~~  

以上恶搞

首先，如何来判断矩形，那么你随便连一下对角线，就会惊奇的发现，咦？？？  
没错，只要是半径，那么一定是个矩形。  
所以直接上代码：  
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int n;
int a[25];
int ans,sum;
int main ()
{
    cin>>n;//读入。
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        sum+=a[i];
        a[i]+=a[i-1];//这样好像可以节省一个数组，就是将从一个点开始的线段加起来，以便后面相减成为半径。
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
        {
            if(a[j]-a[i]==sum/2) ans++;//如果是半径，那么ans++
        }
    }
    cout<<ans*(ans-1)/2<<endl;//这里是排列组合公式，因为你只是求出了两个点，所以整个有在ans个中选两个，因此第一次有ans个选择，第二次有ans-1个选择，为防止重复，除以二。
    return 0;
}

---

## 作者：zhangjiacheng (赞：2)

### 主要思路：
这题并不难，主要是合理运用数学思路，其他的不多说了，程序上都有注释，自己理解。
#### 附代码：
```c++
#include <cstdio>
#include <cstdlib>
#include <iostream>
using namespace std;
const int maxn=1000;
int n,ans;
int dis[maxn][maxn],a[maxn];
void init()
{int i;
 cin>>n;
 for(i=1;i<=n;i++)
   cin>>a[i];//读取第i个圆弧长度 
// memset(dis,0,sizeof(dis));
 ans=0;
 }
void calc_dis()
{int sum=0,i,j,k;
 for(i=1;i<=n;i++)
   sum+=a[i];//sum表示整个圆的圆弧长度 
 for(i=1;i<n;i++)
   for(j=i+1;j<=n;j++)
     {for (k=i;k<j;k++)
        dis[i][j]+=a[k];//dis[i][j]表示第i点到第j个点的圆弧长度 
      dis[i][j]=min(dis[i][j],sum-dis[i][j]);//为劣弧长度 
     }
}
bool judge(int a,int b,int c,int d)//判断a,b,c,d四个点能否构成矩形 
{if(dis[a][b]==dis[c][d])
   if(dis[a][d]==dis[b][c])//两组对边相等 
     if(dis[a][c]==dis[b][d])//两条对角线相等 
return true;
 return false;
}
void count()//枚举统计矩阵的个数
{int a,b,c,d;
 for(a=1;a<=n;a++)
   for(b=a+1;b<=n;b++)
for(c=b+1;c<=n;c++)
  for(d=c+1;d<=n;d++)
         if(judge(a,b,c,d))
           ans++;            
 cout<<ans<<endl;
}
int main()
{
 init();
 calc_dis();
 count();
 return 0;
}
```

---

## 作者：aiyougege (赞：1)

### 【[AHOI2009]飞行棋】
#### Solution
　　以前做过, 所以现在基本上能想起来: 运用初中数学的知识, 矩形$ABCD$的任意一个角$\alpha$所对应的一个圆周角为$\frac{\pi}{2}$, 所以矩形$ABCD$的对角线$AC, BD$为**圆的直径**.
  
　　所以只需要找到有多少对**点**满足弧长为$\frac{C}{2}$, 设为$S$, 因为两两之间都可以互相组成矩形, 总的答案为$\binom{S}{2}$.
  $$\binom{S}{2}=\frac{S!}{2!(S-2)!}=\frac{S\cdot (S-1)}{2}$$
#### Code
```c++
#include<cstdio>

int n,C,l[25],Ct,he,S,s;

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i{
    	scanf("%d",&l[i]);
        l[i+n]=l[i],C+=l[i];
    }
    Ct=C/2;//计算周长的一半
    int total=0;
    int ans=0;
    for(int i=1,j=1;i<n;++i){//j为所选弧的左端点, i为右端点
        total+=l[i];
        while(total>Ct)//大于就减去左端点
            total-=l[j++];
        if(total==Ct)
            ans++;
    }
    printf("%d",(ans*(ans-1))/2);//组合数公式
    return 0;
}
```

---

## 作者：PC_DOS (赞：1)

大家都知道:

### 半圆弧及直径所对的圆周角是直角

因此，我们只需要找到所有的半圆弧即可。


找到所有的半圆弧，也就相当于找到了所有的直径，那么构造一个矩形就相当于从所有的直径中任选两条直径。假设共找到n个半圆弧(也就是n条直径)，则根据组合数公式可以得到不同的矩形的个数C(n,2):



 ![](https://cdn.luogu.com.cn/upload/pic/13477.png) 

基于这个结论，加上题目数据量不大，就可以直接进行暴力搜索了。


搜索思路是:


由于有nCount段圆弧，则必有nCount个点，依次编号为0，1，2，...，nCount-1，同时假设存在nCount号点与0号点重合，其到0号点弧长为圆周长。同时为了便于检索，假定第一个点(0号)为"起点"，记录其他每一个到"起点"的距离，存入数组arrArcLen中，那么此时对于任意0<=i<j<=nCount，有arrArcLen(j)-arrArcLen(i)=从点i到点j走过的弧长。那么只需要找到一对距离为周长一半的点对(i,j)(为了保证不重复，规定0<=i<j<=nCount)，就可以认为找到了一条直径。


由此得到代码(C++):

```cpp
#include <iostream>
using namespace std; //头文件和命名空间
int arrArcLen[35]={0}; //定义存放每个点到起点距离的数组
int main(){
    int nCount,i,j; //nCount-点的总数，i、j-循环变量
    long nTotal=0; //nTotal-直径的总个数
    cin>>nCount; //读入圆弧的总数
    arrArcLen[0] = 0; //起点到自己的距离为0
    for (i = 1; i <= nCount; i++){
        cin>>arrArcLen[i]; //读入每一个圆弧的长度
        arrArcLen[i] += arrArcLen[i - 1]; //把每一个点到起点的距离存入数组
    }
    if (arrArcLen[nCount] % 2 != 0 || arrArcLen[nCount] <= 0){ //读入结束，此时arrArcLen[nCount]中存放的是圆周长，由于每一段弧长都是整数，因此如果圆周长为奇数，那么必然无法构成矩形。同时为了避免输入非法的数据(比如全0)，特判一下周长有没有小于0
        cout<<0; //输出0
        goto endapp; //跳转到结束
    }
    for (i = 1; i <= nCount; ++i) //开始查找
        for (j = i + 1; j <= nCount; ++j) //从目前点向后寻找
            if (arrArcLen[j] - arrArcLen[i] == (arrArcLen[nCount] / 2)) //如果发现某个点到当前点弧长为周长的一半
                ++nTotal; //直径总数加一
    cout<<nTotal*(nTotal-1)/2; //输出组合数C(nTotal,2)=nTotal*(nTotal-1)/2
    endapp:
    return 0;
}
```

---

## 作者：光阴且含笑 (赞：0)

让我们回忆一下初中知识：圆中直径所对的圆周角是直角

那么两条不同的直径的四个端点可以构成一个矩形

OK AC代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,sum[25];//维护前缀和便于计算
int r=0;//半圆的弧长
int ans=0;//直径数
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&x),r+=x,sum[i]=sum[i-1]+x;//输入并维护前缀和与周长
	r/=2;
	for(int i=1;i<n;i++)
		for(int j=i+1;j<=n;j++)
			if(sum[j]-sum[i]==r){//弧长AB=r
				ans++;
				break;
			}
	ans=((1+(ans-1))*(ans-1))/2;//计算最终答案
	printf("%d",ans);
	return 0;
}
```


---

## 作者：loaky (赞：0)

一个超级丑陋的（n四次方）的写法，处理每两个点的距离就是弧度来表示，然后，先找弧度相等的两条线段，因为是矩形需要确定直角，在圆中可以知道直径所对的那个角一定是直角，判断两条对角线是否是直径，如果是直径则对角线所对应的两个点的弧长为总长的一半，满足条件则ans++
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e3+5;
int n,a[maxn],b[maxn][maxn],sum,vis[50][50][50][50],ans,flag;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(i==n) b[i][(i+1)%n]=a[i];
		else b[i][i+1]=a[i];
		sum+=a[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=i+2;j<=n;j++){
				b[i][j]=b[i][j-1]+b[j-1][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			if(b[i][j]>=(sum/2)) b[i][j]=sum-b[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			for(int k=j+1;k<=n;k++){
				for(int l=k+1;l<=n;l++){
					if(i==j||i==k||i==l||j==k||j==l||k==l) continue;
					else if(b[i][j]==b[k][l]){
						if(b[i][k]==(sum/2)) flag++;
						if(b[i][l]==(sum/2)) flag++;
						if(b[j][k]==(sum/2)) flag++;
						if(b[j][l]==(sum/2)) flag++;
						if(flag==2) ans++;
						flag=0;
					}
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：CyaNeko (赞：0)

 这题是纯粹的数论         
 刚拿到手感觉没处下手       
 经过我~~初一学生~~的思考   
 发现这题有规律    
 若以2个点为端点的线段能穿过圆心         
 这样不同的两条线的四个端点      
 就可以组成一个矩形  
 最后通过求和公式输出
#### 时间复杂度:o(n^2)
#### 附上pascal代码
```
var i,j,k,l,m,n,s,x:longint;
    a,b:array[1..20]of longint;
begin
    read(n);
    for i:=1 to n do
    begin
        read(a[i]);
        m:=m+a[i];
        b[i]:=m;
    end;//输入
    if m mod 2=1 then
    begin
        write(0);
        exit;
    end;//判断奇偶性,如果是奇数直接退出
    for i:=1 to n-1 do
        for j:=i+1 to n do
            if abs(b[j]-b[i])=m div 2 then 
                inc(s);//计算通过圆心的线段有几条
    write(((s-1)*s) div 2);//求和公式输出
end.
```

---


# [NOIP 2014 普及组] 螺旋矩阵

## 题目背景

NOIP2014 普及组 T3

## 题目描述

一个 $n$ 行 $ n$ 列的螺旋矩阵可由如下方法生成：


从矩阵的左上角（第 $1$ 行第 $1$ 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 $1, 2, 3, \dots, n^2$，便构成了一个螺旋矩阵。


下图是一个 $n = 4$ 时的螺旋矩阵。

$$\begin{pmatrix}
 1 &    2  &   3   &  4 \\
12 &   13  &  14   &  5 \\
11 &   16  &  15   &  6 \\
10 &    9  &   8   &  7 \\
\end{pmatrix}$$

现给出矩阵大小 $n$ 以及 $i$ 和 $j$，请你求出该矩阵中第 $i$ 行第 $j$ 列的数是多少。


## 说明/提示

【数据说明】

对于 $50\%$ 的数据，$1 \leqslant n \leqslant 100$;

对于 $100\%$ 的数据，$1 \leqslant n \leqslant 30,000,1 \leqslant i \leqslant n,1 \leqslant j \leqslant n$。


## 样例 #1

### 输入

```
4 2 3```

### 输出

```
14```

# 题解

## 作者：Anguei (赞：413)

为什么没有人推公式呢？我来补充一个。

第一次提交，我打暴力，先构建出一个螺旋矩阵，然后找出指定位置的值。代码大概是这样的：

```cpp
#include <iostream>

int main() {
    int n, x, y;
    std::cin >> n >> x >> y;
    int a[n][n];
    int tmp = 1;
    for (int i = 0; i < n / 2 + 1; ++i) {
        for(int j = i; j < n - i; ++j)
        	a[i][j]=tmp++;
        for(int j = i + 1; j < n - i; ++j)
        	a[j][n-i-1]=tmp++;
        for(int j = n - i - 2; j > i; --j)
        	a[n-i-1][j]=tmp++;
        for(int j = n - i - 1; j > i; --j)
        	a[j][i]=tmp++;
    }
    std::cout << a[x-1][y-1] << std::endl;
}
```
但是，只有 $50$ 分，剩下的全都 **TLE** 了。

由于我太蒻了，想不出来如何在暴力算法上优化，所以换了一种方法——**画出矩阵、观察规律、推导公式**。

首先，我们画一个 $5 \times 5$ 的螺旋矩阵。

 ![](https://cdn.luogu.com.cn/upload/pic/12871.png) 

观察一下规律，跟着数字增长的方向走，不难发现：

1. 如果是第 $1$ 行，那么第 $j$ 列的数字就是 $j$；

2. 如果是第 $n$ 列，那么第 $i$ 行的数字就是 $n + i - 1$；

后两条规律有点难找，但是不要放弃，继续观察：

3. 如果是第 $n$ 行，那么第 $j$ 列的数字就是 $3 \times n - 2 - j + 1$；

4. 如果是第 $1$ 列，那么第 $i$ 行的数字就是 $4 \times n - 4 - i + 2$。

好，现在对于每一种情况，我们都推出了一个公式。现在画一个 $6 × 6$ 的螺旋矩阵，验证一下，会发现完全正确：

![](https://cdn.luogu.com.cn/upload/pic/12876.png)

如果对于上述推导过程不是很理解，不妨打开 Excel，自己画图观察。

推导完公式，剩下的就简单多了。不难想出一个**递归**解法：把螺旋矩阵一层一层地剖开，看看目标位置在哪一层，然后加上这一层最左上角的数字（$4 \times (n - 1)$），即为要求的数字。

于是，递归函数就可以写出来了：

```cpp
int work(int n, int i, int j) {
    if (i == 1)
    	return j;
    if (j == n)
    	return n + i - 1;
    if (i == n)
    	return 3 * n - 2 - j + 1;
    if (j == 1)
    	return 4 * n - 4 - i + 2;
    // 注意，递归的时候，n 要减 2 而不是减 1
    return work(n - 2, i - 1, j - 1) + 4 * (n - 1);
}
```
为了避免复制题解的行为，剩下的 `main()`，留给读者填补。

修了一下 Markdown 和 LaTeX，麻烦管理员重申。

---

## 作者：Yusani_huh (赞：5)

我不知道这种思路还会不会有人跟我一样

不过应该不太可能吧

好了，我说说我是怎么想的...

因为螺旋矩阵的样式，所以我第一时间想到了这样一个小学问题：

将从 $1$ 开始的正整数如图排列，设第$i$个拐点的数为$G_i$，如$G_1=2$，$G_3=5$，问你$G_n$是多少。

![](https://cdn.luogu.com.cn/upload/image_hosting/xa1wi0ab.png)

（我真不知道我怎么想到这个的）

由于我本人小学就是个蒟蒻，想不出什么好办法，只会作差...

所以：$G_2-G_1=1$，$G_3-G_2=2$，$G_4-G_3=2$...

于是发现：如果把 $1$ 记作 $G_0$ ，则 $G_i-G_{i-1}=\lceil{i/2}\rceil(i\geqslant1)$。

所以我从这里开始研究。

如果要把螺旋矩阵当成这样来看，那么我们会得到这样一个局面：

![](https://cdn.luogu.com.cn/upload/image_hosting/bgly7cym.png)

标红色的为拐点（在这里我把 $1$ 和 $25$ 也作了标示）。

我们会发现 $16-24$ 这条线路明显有些捣乱，为了~~偷懒~~方便我们舍而求其次，变成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/lqy7n7lt.png)

看起来清爽多了，对吧。

你会问了：这样还有规律吗？

当然有，而且更明显。

我们依旧把 $1$ 记作 $G_0$ ，此时的规律是 $G_i-G_{i-1}=n-2\lceil{i/4}\rceil+1(i\geqslant1)$。

可能看公式有些烦，不过算算你就能发现，每四个一组差值是相同的，从 $n-1$ 开始每组递减 $2$。

咳咳，啰嗦了一大堆，该讲正题了

既然我们发现了这种模式下的规律，接下来就是寻找题目所求 $i$ 和 $j$ 的位置了。

我做了一个 $10\times10$ 的螺旋矩阵，基于对角线规律将其分为了四个部分：

![](https://cdn.luogu.com.cn/upload/image_hosting/2cd90rcj.png)

其中四种色调代表四个区域，对角线上的颜色标识了这部分对角线所属的区域。

判断 $i$ 和 $j$ 时因为~~我蒻不会直接做~~某种不为人知的原因，我只能把矩阵分为四个部分分别判断，如图

![](https://cdn.luogu.com.cn/upload/image_hosting/043d07v1.png)

接下来就不多说了，具体见代码注释吧，另外有一些语句原谅我无法详细释义，还请读者自行理解

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,a,b;
//a和b表示(i,j)所在的区域包含哪部分对角线
int main(){
	scanf("%d%d%d",&n,&i,&j);
	int up=n/2,dp=up+1; //区域边界
	if(n%2) up++; 
	if(i<=up&&j<=up)  //(i,j)在第一区域
		if(i>j) a=n-j+1,b=j;  //(i,j)在黄色部分，求黄色对角线
		else a=i,b=i;  //否则在红色部分，求红色对角线
	else if(i<=up&&j>=dp)  //(i,j)在第二区域
		if(i>n-j+1) a=n-j+1,b=j;  //(i,j)在绿色部分
		else a=i,b=i;  //否则在红色部分
	else if(i>=dp&&j<=up)  //(i,j)在第三区域
		if(n-i+1>j) a=n-j+1,b=j;  //(i,j)在黄色部分
		else a=i,b=i;  //否则在蓝色部分
	else if(i>=dp&&j>=dp)  //(i,j)在第四区域
		if(n-i+1>n-j+1) a=n-j+1,b=j;  //(i,j)在绿色部分
		else a=i,b=i;  //否则在蓝色部分
	int x=1,y=1,m=1,p=n-1,xn=n;
	//x,y表示当前坐标，m表示当前格子中的数，xn用来求x和y，p用来求m
	while(1){  //开始轻松惬意的求对角线时光
		if(x!=a||y!=b) x=n-xn+1,y=xn,m+=p;  //如果没到达(a,b)，做这组的第一次变换
		else {cout<<m+j-y<<endl;break;}  //否则输出答案
		if(x!=a||y!=b) x=xn,m+=p;  //如果没到达(a,b)，做这组的第二次变换
		else {cout<<m+i-x<<endl;break;}  //否则输出答案
		if(x!=a||y!=b) y=n-xn+1,m+=p;  //如果没到达(a,b)，做这组的第三次变换
		else {cout<<m+y-j<<endl;break;}  //否则输出答案
		xn--;  //第四次的位置向里移动了一点，所以调整xn
		if(x!=a||y!=b) x=n-xn+1,y=n-xn+1,m+=p;  //如果没到达(a,b)，做这组的第四次变换
		else {cout<<m+x-i<<endl;break;}  //否则输出答案
		p-=2;  //差值减少2，进行下一组变换
	}
	return 0;
}
```

这篇复杂得让人想吐血的题解就到这吧，还是希望大家吸取我的教训，想题别想太复杂，多学学那些几行代码的奆佬...

---

## 作者：Actinoi (赞：4)

**图片尺寸过大>_<为获取最佳阅读效果，欢迎访问：**[Actinoi's blog:NOIP2014 普及组](https://www.actinoi.com/2019/08/19/noip2014%20普及组/)


很明显，这个提示一个找规律的题呗！

我们可以将大矩阵分成一层一层的小矩阵：

![6_6矩阵.png](https://i.loli.net/2019/08/19/718Q3yr6sjVPgYo.png)

然后，我们先研究如何在一个小矩阵里面找到一个坐标：

![小矩阵.png](https://i.loli.net/2019/08/19/NvDEmKg29MOVyfS.png)

假设我们知道这个小矩阵左上角的数字是多少，如果我们要找在这个小矩阵寻找一个数字，应该怎样找呢？

1. 当 $i\ =\ 1$ 时，也就是在第 $1$ 行寻找一个数字。我们直接返回左上角的数字 $+\ j$ 就可以。
2. 当 $i\ =\ n$ 时，也就是在第 $n$ 行寻找一个数字。这个小矩阵的大小 $n$ 是 $4$ ，因此，我们先将 $(n\ -\ 1)\ ×\ 3$ 得到左下角的坐标，然后再 $-\ j\ +\ 2$ 得到我们要找的坐标，最后，将这个坐标 $+$ 左上角的数字就是我们要找的数字了！
3. 当 $j\ =\ 1$ 时，也就是在第 $1$ 列寻找一个数字。同情况 $2$ 一样，我们先将将 $(n\ -\ 1)\ ×\ 4$ 得到左上角正下方数字 $32$ 的坐标，然后再 $-\ i\ +\ 2$ 得到我们要找的坐标，最后，将这个坐标 $+$ 左上角的数字就是我们要找的数字了！
4. 当 $j\ =\ n$ 时，也就是在第 $n$ 列寻找一个数字。我们直接返回左上角的数字 $+\ n\ +\ i\ -\ 1$ 就可以。



​​​​​&emsp;然后，我们可以通过递归来得到小矩阵。并且在递归过程中，我们可以不断将当前 $(n\ -\ 1)\ ×\ 4$ 得到当前矩阵左上角的数字。最后输出答案就好辣！

```cpp
#include <iostream>
using namespace std;
int find(int n, int i, int j) {
    if (i == 1)
        return j;
    if (i == n)
        return (n - 1) * 3 - j + 2;
    if (j == 1)
        return (n - 1) * 4 - i + 2;
    if (j == n)
        return n + i - 1;
    return find(n - 2, i - 1, j - 1) + (n - 1) * 4;
}
int main() {
    int n, i, j;
    cin >> n >> i >> j;
    cout << find(n, i ,j) << endl;
    return 0;
}

```

---

## 作者：WsW_ (赞：3)

### 前言
分享一种与其他所有题解都不同的做法，非常无脑且好写。  
我在四年前用这种做法通过了此题，但这种做法是可以被卡掉的。今天我重新完善了这种做法，使其无法被卡。  

---
### 思路
容易想到的思路是，按照题意一步一步走，直到到达目标位置。但当目标位置在中心的时候，要走整整 $n\times n$ 步，超时了。  
考虑怎样弄来防止被卡。每次走一圈都是走的最外面的一层，因此我们可以把外面的整层直接剥掉，只暴力走目标位置所在的那一层。  

剥掉外面的整层后，就剩下一个新的矩阵。例如样例中的矩阵剥掉外面整层后变成下面的样子。
$$\begin{pmatrix}

13  &  14   \\
16  &  15   \\
\end{pmatrix}$$

在这一层里面暴力即可。  
外面整层会有多少个位置呢？就是原矩阵的大小里面扣掉剩下的矩阵的大小。  

因为只会走一层，而一层最多有 $4\times n$ 个位置，所以时间复杂度为 $O(n)$。  

---
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,sum;
int dir[4][2]={1,0,0,1,-1,0,0,-1};
int main(){
	scanf("%d%d%d",&n,&i,&j);
	int layer=min({n-i,n-j,i-1,j-1});
	i-=layer;j-=layer;
	int v=layer<<1;
	sum=n*n-(n-v)*(n-v);
	n-=v;
	for(int x=1,y=1,t=0;x!=j||y!=i;){
		sum++;
		int xx=x+dir[t][0],yy=y+dir[t][1];
		if(xx>n||yy>n||xx<1||yy<1)t++,sum--;
		else x=xx,y=yy;
	}
	printf("%d",sum+1);
	return 0;
}
```

---

## 作者：CaiZi (赞：3)

接下来的距离都是指曼哈顿距离，即 $(a,b)$ 和 $(c,d)$ 的距离为 $|a-c|+|b-d|$。

我们发现，对于每一圈的数字，左上角均为该圈的最小数字。因为每次螺旋完一圈后会回到该圈左上角下方，然后向右进入更小的一圈。记 $(i,j)$ 外面共有 $x$ 圈，那么显然 $x=\min\{i-1,j-1,n-i,m-j\}$。

然后我们发现第 $i$ 圈有 $4\times[n-2(i-1)]-4$ 个数字，化简一下，为 $4n-8i+4$。记 $y$ 为前 $x+1$ 圈的左上角的数字，那么：
$$\begin{aligned}y&=\sum_{i=1}^x(4n-8i+4)+1\\&=\sum_{i=1}^x4n-\sum_{i=1}^x8i+\sum_{i=1}^x4+1\\&=4xn-8\times\frac{x(x+1)}{2}+4x+1\\&=4xn-4x^2+1\end{aligned}$$
于是我们分类讨论一下 $(i,j)$ 的位置，记 $s$ 为答案：
- 如果 $(i,j)$ 在该圈的上边一行或右边一行，即 $i=x+1$ 或 $j=n-x$。此时答案为 $y$ 加 $(i,j)$ 到 $(x+1,x+1)$ 的距离，即：
$$\begin{aligned}s&=y+[i-(x+1)]+[j-(x+1)]\\&=y-2x+i+j-2\end{aligned}$$
- 其他情况时。此时答案为 $y$ 加 $(x+1,x+1)$ 到 $(n-x,n-x)$ 加 $(n-x,n-x)$ 到 $(i,j)$ 的距离，即：
$$\begin{aligned}s&=y+[(n-x)-(x+1)]+[(n-x)-(x+1)]+[(n-x)-i]+[(n-x-j)]\\&=y+2(n-2x-1)+2n-2x-i-j\\&=y-6x+4n-i-j-2\end{aligned}$$

时间复杂度 $O(1)$。

你会发现 $y$ 基本没啥用，因此直接用 $4xn-4x^2+1$ 代入两种情况的 $y$ 即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,x;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>i>>j;
	x=min({i-1,j-1,n-i,n-j});
	if(i==x+1||j==n-x){
		cout<<4*x*n-4*x*x-2*x+i+j-1;
	}
	else{
		cout<<4*x*n-4*x*x-6*x+4*n-i-j-1;
	}
	return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

模拟题。由于矩阵是一圈一圈构成的，所以我们只需要忽略外面的几圈，剩下一个小矩阵，使所求点在小矩阵边上，再模拟求，时间复杂度 $\mathcal O(n)$。

拿样例举例。绿色是小矩阵，红色是要忽略的部分。

设小矩阵外面有 $k$ 圈，则我们应从 $(k+1, k+1)$ 位置开始，小矩阵有 $(n - 2 \times k)^2$ 个数，总个数 $n^2$ 个，所以红色部分就有 $n^2-(n - 2 \times k)^2$ 个数，小矩阵的数字就以此为基础往上加。

最后输出时要加一，因为这个代码没有算 $(k+1, k+1)$ 的贡献。

![](https://cdn.luogu.com.cn/upload/image_hosting/yp8ijso8.png)

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, x, y, dx[]={0, 1, 0, -1}, dy[]={1, 0, -1, 0};
int main () {
	cin >> n >> x >> y; 
	int k=min({x-1, n-x, y-1, n-y})*2, ans=n*n-(n-k)*(n-k);
	for (int i=1, j=1, t=0, ti, tj; x-k/2!=i||y-k/2!=j; ) 
		ti=i+dx[t], tj=j+dy[t],
		(ti>n-k||tj>n-k||ti<1||tj<1)?++t:(++ans, i=ti, j=tj);
	cout << ans+1;
	return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2239)

---
### 思路：
下图是一个 $n = 4$ 时的螺旋矩阵。我们就可以通过这张图来看一看规律。

$$\begin{pmatrix}
 1 &    2  &   3   &  4 \\
12 &   13  &  14   &  5 \\
11 &   16  &  15   &  6 \\
10 &    9  &   8   &  7 \\
\end{pmatrix}$$
就可以看出几点规律：

1. 只要是第一行，那么第 $j$ 列的数字就是 $j$ 本身。
2. 如果是第一列，那就要用一个公式 $3 \times (n - 1) + n - i + 1$ 来推，当然你也可以把它拆成 $4 \times n- 2 + j $。
3. 如果是最后一行，那么就是 $2 \times (n - 1) + n - j + 1$，也可以转换成 $3 \times n - 1 - j$。
4. 如果是最后一列，这个简单，就是 $n - 1 + i$，$n$ 和 $j$ 都可以。
5. 然后就是递归式了 $4 \times (n - 1) + dfs(n - 2, i - 1, j - 1)$。

最后，就有了总的代码了。


---
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, i, j;

int dfs(int n, int i, int j) {
	if (i == 1) return j;
	else if (j == 1) return 3 * (n - 1) + n - i + 1; // 3 * (n - 1) + n - j + 1 = 4n - 3 - j + 1 = 4 * n - 2 + j
	else if (i == n) return 2 * (n - 1) + n - j + 1; // 2 * (i - 1) + i - j + 1 = 2 * i - 1 + i - j + 1 = 3 * i - j - 1 
	else if (j == n) return n - 1 + i; // return j - 1 + i;
	else return 4 * (n - 1) + dfs(n - 2, i - 1, j - 1);
}

int main() {
	cin >> n >> i >> j;
	cout << dfs(n, i, j) << endl;
	return 0;
}
```

---

## 作者：YWT130508 (赞：1)

这道题数组会超空间，所以暴力不行。

观察一下矩阵可以发现一些简单的规律：

下面用 $i$ 代表行，$j$ 代表列。

第 $1$ 行第 $x$ 列的数为 $$j$$。

第 $n$ 行第 $x$ 列的数为 $$3 \times n-1-j$$。

第 $1$ 列第 $x$ 行的数为 $$4 \times n-2-i$$。

第 $n$ 列第 $x$ 行的数为 $$n+i-1$$。

由于矩阵是一圈一圈构成的，所以要求矩阵内部的数可以像剥洋葱一样把矩阵的外层一层层剥开，所以用一个递归把矩阵一层层剥开，直到要求的数在边上，可以用上面的公式求解时，就可以直接 return。

注意：剥开后的矩阵并不是从 $1$ 开始，需要加上前面剥下的数的数量，才是当前的数。

每层剥下的数为 $$4(n-1)$$ 个，化简一下就是 $$4n-4$$。

所以 return 的值要加上 $$4n-4$$。

贴代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y;
int f(int n, int i, int j) {
    if (i==1)return j;
    if (j==n)return n+i-1;
    if (i==n)return 3*n-1-j;
    if (j==1)return 4*n-2-i;
    return f(n-2,i-1,j-1)+4*(n-1);//注意这里n要减2而不是1
}
int main(){
cin>>n>>x>>y;
cout<<f(n,x,y);
return 0;
}

```

---

## 作者：HHC883 (赞：0)

# 题目分析
首先，暴力枚举肯定是会超时的。于是我们想到将矩阵由外到内分为若干圈，则同一个圈上的数是连续的，且每个圈上最多只有 $4 (n - 1)$ 个数（即最外圈）。所以，在同一个圈内枚举的时间复杂度是可以接受的。于是我们可以先定位到第 $i$ 行第 $j$ 列在哪一个圈，设为第 $x$ 圈，然后统计前 $x - 1$ 圈上的数的个数。容易发现 $n \times n$ 的矩阵的总圈数不超过 $\lceil \frac{n}{2} \rceil$，所以对于每一圈分别统计是不会超时的。最后，在第 $x$ 圈上暴力地找第 $i$ 行第 $j$ 列即可。

时间复杂度为 $O(n)$。
# 参考代码
```cpp
#include<iostream>
using namespace std;
int n,i,j,x,tot,side;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>i>>j;
	for(x=1;x*2-1<=n;x++){
		if(i==x||i==n-x+1||j==x||j==n-x+1) break;
		tot+=(n-2*x+1)*4;
	}
	int a=x,b=x;
	while(1){
		tot++;
		if(i==a&&j==b){
			cout<<tot;
			break;
		}
		if(side==0) if(b<n-x+1) b++; else side++;
		if(side==1) if(a<n-x+1) a++; else side++;
		if(side==2) if(b>x) b--; else side++;
		if(side==3) a--;
	}
	return 0;
}
```

---

## 作者：hjz_0821_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2239)

## 题意
给定一个 $n \times n$ 的螺旋矩阵，求某个位置的值。

## 思路
作为一名初二的蒟蒻，一开始觉得可以直接打暴力。结果超时了（为防止误导，就不放代码了）。于是想到了**找规律**。

如果对找规律的题不太熟悉，做[这道题](https://www.luogu.com.cn/problem/P11229)（是2024年CSP-J的一道T3）。

看题干里螺旋矩阵的样例：

$$
\begin{pmatrix}
1 & 2 & 3 & 4 \\
12 & 13 & 14 & 5 \\
11 & 16 & 15 & 6 \\
10 & 9 & 8 & 7 \\
\end{pmatrix}
$$

我们可以发现：

- 第 $1$ 行的数从左往右递增，也就是第 $j$ 列的数是 $j$ 。
- 最后一行的数字从左往右递减，也就是第 $j$ 列的数是 $3 \times n - j - 1$ 。
- 第 $i$ 行，最后一列的数字是 $ n + i - 1$ 。
- 第 $i$ 行，第 $1$ 列的数是 $4 \times n - i - 2$ 。

这样，公式就推出来了，造几个螺旋矩阵，每一条都对。

不过有一点需注意：每一条规律都是独立的，比如第 $3、4$ 条和第 $1、2$ 条冲突。

举个例子（例子中的螺旋矩阵为 $5 \times 5$ 的矩阵），用第 $1$ 条规律算第 $1$ 行第 $1$ 个，得到的数是 $1$；而用第 $4$ 条规律则得到的数是 $17$ 。


---


有了公式就简单多了。我们可以用[递归算法](https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/4323575)来解：

把螺旋矩阵按层分开，找到目标位置在哪一层，然后加上这一层的数字个数，即为要求的数字。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j;
int dg(int x,int y,int z){
	if(y!=1 && z!=1 && y!=x && z!=x){
		return dg(x-2,y-1,z-1)+4*(x-1);
	}
	if(y==1){
		return z;
	}
	if(z==x){
		return x+y-1;
	}
	if(y==x){
		return 3*x-z-1;
	}
	if(z==1 && y!=1){
		return 4*x-y-2;
	}
}
int main(){
    ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>i>>j;
	cout<<dg(n,i,j);
	return 0;
}
```

[成功AC！](https://www.luogu.com.cn/record/197003976)

---

## 作者：chrispang (赞：0)

### 题目大意

给定一个 $n$ 行 $n$ 列的螺旋矩阵，求一个螺旋矩阵中某个位置的值。

例如下图就是是 $n=4$ 的螺旋矩阵：
$$
\begin{pmatrix}
1 & 2 & 3 & 4 \\
12 & 13 & 14 & 5 \\
11 & 16 & 15 & 6 \\
10 & 9 & 8 & 7 \\
\end{pmatrix}
$$

### 题目思路

#### 暴力

可以一步一步的枚举，以达到枚举完所有的位置，其中 $l$ 表示左上角的列数，$u$ 表示左上角的行数，$r$ 表示右下角的列数，$q$ 表示右下角的行数，如果左上角和右下角的列数相碰，则说明枚举完毕了。当然也可以写成如果 $sum = n^2$，则退出（其实这个暴力也很难写）：

```cpp
#include <bits/stdc++.h>
#define maxn 30010
using namespace std;

int n, i, j, a[maxn][maxn];
long long ans;
int main() {
    scanf("%d%d%d", &n, &i, &j);
    int l = 1, u = 1, r = n, q = n, sum = 0;
    while(l <= r) {
        for (int k = l; k <= r; k++) a[u][k] = ++sum;
        for (int k = u + 1; k <= q; k++) a[k][r] = ++sum;
        for (int k = r - 1; k >= l; k--) a[q][k] = ++sum;
        for (int k = q - 1; k >= l + 1; k--) a[k][l] = ++sum;
        l++, r--, u++, q--;
    }
	cout << a[i][j] << endl;
    return 0;
}
```

但是很明显，空间会炸掉，所以我们可以不需要用数组模拟：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, i, j;
long long ans;
int main() {
    scanf("%d%d%d", &n, &i, &j);
    int l = 1, u = 1, r = n, q = n, sum = 0;
    while(l <= r) {
        for (int k = l; k <= r; k++) {
            ++sum;
            if(u == i && k == j) {
                cout << sum << endl;
                return 0;
            }
        }
        for (int k = u + 1; k <= q; k++) {
            ++sum;
            if(k == i && r == j) {
                cout << sum << endl;
                return 0;
            }
        }
        for (int k = r - 1; k >= l; k--) {
            ++sum;
            if(q == i && k == j) {
                cout << sum << endl;
                return 0;
            }
        }
        for (int k = q - 1; k >= l + 1; k--) {
            ++sum;
            if(k == i && l == j) {
                cout << sum << endl;
                return 0;
            }
        }
        l++, r--, u++, q--;
    }
    return 0;  
}
```

可惜时间还是会炸掉，所以考虑新方法！

#### 递归

可以利用打表找规律，如下表（$n=5$ 的情况）

|  1   |  2   |  3   |  4   |  5   |
| :--: | :--: | :--: | :--: | :--: |
|  16  |  17  |  18  |  19  |  6   |
|  15  |  24  |  25  |  20  |  7   |
|  14  |  23  |  22  |  21  |  8   |
|  13  |  12  |  11  |  10  |  9   |

观察一下规律，跟着数字增长的方向走，不难发现：

1. 如果是第 $1$ 行，第 $j$ 列，则数字为 $j$；
2. 如果是第 $i$ 行，第 $n$ 列，则数字为 $n + i - 1$；

后两条规律有点难找，但是耐性找一下，继续观察：

3. 如果是第 $n$ 行，第 $j$ 列，则数字为 $3\cdot n - j - 1$；
4. 如果是第 $i(i\ne 1)$ 行，第 $1$ 列，则数字为 $4\cdot n - i - 2$；

好，现在对于每一种情况，我们都推出了一个公式。现在画一个 $6\times 6$ 的螺旋矩阵，验证一下，会发现完全正确：

|  1   |  2   |  3   |  4   |  5   |  6   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  20  |  21  |  22  |  23  |  24  |  7   |
|  19  |  32  |  33  |  34  |  25  |  8   |
|  18  |  31  |  36  |  35  |  26  |  9   |
|  17  |  30  |  29  |  28  |  27  |  10  |
|  16  |  15  |  14  |  13  |  12  |  11  |

推导完公式，剩下的就简单多了。不难想出一个**递归**解法：把螺旋矩阵一层一层地剖开，看看目标位置在哪一层，然后加上这一层的数字个数 $4(n-1)$，即为要求的数字。

上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int work(int n, int i, int j) {
	if(i != 1 && j != 1 && i != n && j != n) return 4 * (n - 1) + work(n - 2, i - 1, j - 1); //如果要找到数不在这一层，则进行递归（注意：由于我们是一层一层的剖开，所以n-2） 
	if(i == 1) return j; //第1行，第j列 
	if(j == n) return n + i - 1; //第i行，第n列 
	if(i == n) return 3 * n - j - 1; //第n行，第j列 
	if(j == 1 && i != 1) return 4 * n - i - 2; //第i(i!=1)行，第一列 
}

int n, i, j;
int main() {
	cin >> n >> i >> j;
	cout << work(n, i, j) << endl;
	return 0;
}
```

---


# 圆圆舞蹈

## 题目描述

熊大妈的奶牛在时针的带领下，围成了一个圆圈，由于没有严格的教育，奶牛们之间的间隔不一致。

奶牛想知道两只最远的奶牛到底隔了多远。奶牛 $A$ 到 $B$ 的距离为 $A$ 顺时针走和逆时针走，到达 $B$ 的较短路程。告诉你相邻两个奶牛间的距离，请你求出两只最远的奶牛到底隔了多远。


## 样例 #1

### 输入

```
5
1
2
3
4
5
```

### 输出

```
7
```

# 题解

## 作者：zbwer (赞：15)

```cpp
/*

Tips:
1.首先找到与第一头牛最远的牛的位置,即找到一个牛(pos)与1号牛的距离>=周长的一半  
2.接着记录  pos之前的这头牛(pos-1)
3.显然pos这头牛到第一头牛的逆时针顺序是最大的,(pos-1)这头牛到第一头牛的顺时针距离是最大的  
4.那我们在这二者之间取个最大值
5.接下来不断向前推进,第一头牛变为第二头牛,更新pos和(pos-1)到第二头牛的距离,再更新一下答案即可. 
6.如果我们向前推进奶牛的时候,pos到当前推进到的奶牛的顺时针距离<周长的一半,那我们就向前推进pos即可 

*/ 
```

## Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#define Mi return
#define manchi 0

using namespace std;

const int INF = 0x3f3f3f3f;
const int N = 100000 +5 ;

inline int read()
{
    int num=0,w=1;char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch<='9' && ch>='0')
        num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
    Mi num*w;
}

int n,a[N],sum,ans;

int main()
{
//  freopen("circle.in","r",stdin);
//    freopen("circle.out","w",stdout);
    n=read();
    for(register int i=1;i<=n;i++)
        a[i]=read(),sum+=a[i];//i-1 -> i 

    int half_over=0,pos=0;
    for(register int i=1;i<=n;i++)
    {
        half_over+=a[i-1];//找到第一个超过一半周长的 
        if(half_over>sum/2){pos=i;break;}//记录此时位置 
    }
    int way=abs(sum-half_over);
    int way_=half_over-a[pos-1];  
    ans=max(way,way_); 
    for(int i=1;i<=n;i++)
    {
        half_over-=a[i-1];//向前推进奶牛 
        while(half_over<=sum/2)
        {
            half_over+=a[pos+1];//要是pos不符合条件,那就向前推进pos 
            pos++;
        }
        //更新答案 
        ans=max(ans,min(half_over,abs(sum-half_over))); 
        ans=max(ans,min(half_over-a[pos-1],abs(sum-(half_over-a[pos-1]))));
    }
    printf("%d",ans);
    Mi manchi;
}
//2019-07-26 typed by zbwer 
//题目地址:https://www.luogu.org/problem/P2381
```

---

## 作者：地表最强男人 (赞：8)

### 前言
本来以为是一道水题，但是看了看数据，$O(n^2)$好像是过不了的，想到如果带$log$应该就可以过，所以想了个二分的办法。

- 我们先处理好每一个点到1的距离，因为有环，所以我开了两倍的数组，然后每一次累加答案，计算整个环的大小。
- 枚举每一个点，然后处理二分查找前面$1->i-1$个点到i的距离，如果大于$m/2$那就移动左端点至$mid$，否则移动右端点至$mid$。简单的二分就完成了。
- 然而一测90分，看了下是第三个点炸了。突然想到好像如果只有两个点的时候，按照我的处理方法，答案会被我更新成0，但是这是不符合题目意思的。所以加了个特判$AC$。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
long long d[200010],m,ans=0,x;//0为顺时针,1为逆时针 
int main()
{
      cin>>n;
      for(int i=1;i<n;i++)
      {
          cin>>x;
          d[i+1]=d[i]+x;
          m+=x;
      }
      cin>>x;
      m+=x;
      for(int i=1;i<=n;i++)
          d[i+n]=d[i]+m;
      if(n==2)
      {
          cout<<d[2];
          return 0;
      }
      for(int i=1;i<=2*n;i++)
      {
          int l=1,r=i-1;
          while(l<r)
          {
              int mid=(l+r)/2;
              if(d[i]-d[mid]<(m/2))
              {
                  long long st=min(d[i]-d[mid],m-(d[i]-d[mid]));
                  ans=max(ans,st);
                  r=mid;
              }
              if(d[i]-d[mid]>=(m/2))
              {
                  long long st=min(d[i]-d[mid],m-(d[i]-d[mid]));
                  ans=max(ans,st);
                  l=mid+1;
              }
          }
      }
      cout<<ans;
      return 0;
}
```


---

## 作者：w_x_c_q (赞：8)

**单调队列**

一直在想怎么利用前缀和。

但是又有环的存在，一直在YY一些神奇的操作计算。

忽然想到，我把这个环变成链扩大一倍,成为一个长度为2*n的链，那么将前缀和作用到这条链上是等同于在环上操作的。

其实以上思路就是处理成环问题的关键思路。

之后求一下前缀和，就变成了求在不大于二分之一总长的最大字段和。

裸了。

代码在这里：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int wx=210055*10;
int a[wx],sum[wx],q[wx];
int n,ans,head,tail,tot;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		tot+=a[i];
	}
	for(int i=n+1;i<=2*n;i++){
		a[i]=a[i-n];
	}
	for(int i=1;i<=2*n;i++){
		sum[i]=sum[i-1]+a[i];
	}
	tot/=2;
	head=tail=1;
	q[1]=1;
	for(int i=1;i<=n;i++){
		while(head<=tail&&sum[i]-sum[q[head]]>tot)head++;
		ans=max(ans,sum[i]-sum[q[head]]);
		while(head<=tail&&sum[i]<=sum[q[tail]])tail--;
		q[++tail]=i;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：19ty53 (赞：2)

## Solution：
##### 做法1：
记录前缀和，可知前缀和是递增的，枚举起点，我们不难二分一个"中点"
中点左边的点距离小于半个周长，右边的点距离大于半个周长，然后用终点顺、逆时针距离最小值更新答案即可。
复杂度O(nlogn)

Code
第一种做法
~~~
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,sum[200101];
int main(){
	cin>>n;
	register long long ans=0;
	register int l=1,r=0;
	for(register int i=1;i<=n;++i){
		cin>>sum[i];
		sum[i+n]+=sum[i];
		sum[i]+=sum[i-1];
	}
	int len=n*2;
	for(register int i=n+1;i<=len;++i)sum[i]+=sum[i-1];//最远范围要拓展到2n，因为当枚举到n/2的点时可能会超过点n的范围
	double tmp=(double)sum[n]/2;
	for(register int i=1;i<=len;++i)sum[r+1]-sum[l]<=tmp?ans=max(ans,sum[++r]-sum[l]):++l;//用两个指针模拟找最远的点
   cout<<min(ans,sum[n]-ans);//因为圆有对称性，所以要两边取最小值
}
~~~

---


##### 做法2：
记录前缀和sum，总长度Len
于是从第一头奶牛开始，找到l,r两只牛，l小于等于r ，这里从1开始
不难发现当距离小于总长度一半的时候，我们需要去找l, r + 1 
当距离大于总长度一半的时候，我们需要去找l + 1, r  一定优于l + 1, r + 1
这样省去了很多无用的枚举
然后l,r围着前缀和枚举一圈就可以了
复杂度O(n+n/2)

第二种做法
~~~
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
long long d[200010],m,ans=0,x;//0为顺时针,1为逆时针
int main() {
	scanf("%d",&n);
	for(register int i=1; i<=n; ++i) {
		scanf("%d",&x);
		d[i+1]=d[i]+x;//前缀和
		m+=x;
	}
	for(register int i=1; i<=n; ++i)d[i+n]=d[i]+m;//还是往后加前缀和，防止数组越界。
	if(n==2) {
		printf("%d",d[2]);
		return 0;
	}
	int len=n*2,mm=m/2;
	for(register int i=1; i<=len; ++i) {
		register int l=1,r=i-1;
		while(l<r) {//二分寻找最优解
			int mid=(l+r)/2;
			if(d[i]-d[mid]<(mm)) {
				long long st=min(d[i]-d[mid],m-(d[i]-d[mid]));
				ans=max(ans,st);
				r=mid;
			}
			if(d[i]-d[mid]>=(mm)) {
				long long st=min(d[i]-d[mid],m-(d[i]-d[mid]));
				ans=max(ans,st);
				l=mid+1;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
~~~


---

## 作者：嘒彼小星 (赞：2)

记录前缀和sum,总长度len

于是从第一头牛开始，找到奶牛l,r(l < r)

不难发现当l与r的顺时针距离大的时候，下一步我们应该找的是l + 1, r   一定优于l + 1, r + 1

距离小的时候，下一步我们应该找的区间时l, r + 1   一定优于l + 1, r + 1

这样我们就少找了很多无用的l.r

乱搞一下就可以了

复杂度O(N)





```cpp
#include <bits/stdc++.h>
const int MAXN = 100000 + 10;
inline void read(int &x){x = 0;char ch = getchar();char c = ch;while(ch > '9' || ch < '0')c = ch, ch = getchar();while(ch <= '9' && ch >= '0')x = x * 10 + ch - '0', ch = getchar();if(c == '-')x = -x;}
inline void swap(int &a, int &b){int tmp = a;a = b;b = tmp;}
inline int min(int a,int b){return a > b ? b : a;}
inline int max(int a,int b){return a > b ? a : b;}
int n;
int sum[MAXN],num[MAXN],len;
int ans;
int main()
{
    read(n); 
    for(int i = 2;i <= n;i ++)
    {
        read(num[i]);
        sum[i] = sum[i - 1] + num[i];
        len += num[i];
    }
    read(num[1]);len += num[1];sum[n + 1] = sum[n] + num[1];
    int l = 1, r = 1;int mid = len >> 1;
    while(l <= n + 1 && r <= n + 1)
    {
        if(l == r)
        {
            r ++;
        }
        else if(sum[r] - sum[l] <= mid)
        {
            ans = max(ans, sum[r] - sum[l]);
            r ++;
        }
        else if(sum[r] - sum[l] > mid)
        {
            ans = max(ans, min(sum[r] - sum[l], mid - sum[r] + sum[l]));
            l ++;
        }
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：chl090410 (赞：1)

## P2831 题解

由于 $N\leq10^5$，所以 $O(N^2)$ 是过不了的。

于是考虑 $O(N\times\log N)$、$O(N)$ 及时间复杂度更低的算法。

因为 A 到 B 的距离为 A 顺时针走和逆时针走，到达 B 的较短路程。所以这个距离一定 $\le$ 奶牛所围成的圆圈周长的一半。

在环中不好操作，所以我们先破环为链，即将原数组复制一份，接在原数组后面。破环为链后这个距离就是该链的一个子段的子段和。而这个子段和一定 $\le$ 圆圈周长的一半。

又因为要求两头牛间的最大距离，即求该链 $\le$ 圆圈周长的一半的最大子段和。

这个问题可以使用单调队列求解。

时间复杂度 $O(N)$，于是就过了。

### 下面附上完整代码：

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int v,n,a[200005],b[200005],mx=2147483645,l,r,t,p;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<=n;i++){
		a[i+n]=a[i];
		p+=a[i];
	}
	p/=2;
	for(int i=1;i<=2*n;i++){
		b[++r]=a[i];
		t+=a[i];
		while(t>p){
			t-=a[l];
			l++;
		}
		mx=min(p-t,mx);
	}
	cout<<p-mx;
	return 0;
}


---

## 作者：ZnPdCo (赞：0)

看了题解发现没人写这种方法。

首先肯定是破环成链，然后枚举其中的一只奶牛 $A$。

因为奶牛 $A$ 到 $B$ 的距离为 $A$ 顺时针走和逆时针走，到达 $B$ 的较短路程，奶牛 $B$ 最远的距离肯定在奶牛 $A$ 的正对面，破环成链后也就是 $\frac{A+(A+n)}{2}$。但这个位置其实不一定是有奶牛的，但这个位置的左边肯定有头奶牛，右边也肯定有头奶牛，我们只需要算这几头奶牛就好了：

```c++
#include <cstdio>
#include <algorithm>
#define ll long long
#define N 200010
using namespace std;
ll n;
ll a[N];			// i-1到i的距离
ll s[N];			// 1到i的距离
ll ans;
int main() {
	scanf("%lld", &n);
	for(ll i = 1; i <= n; i++) {
		scanf("%lld", &a[i+1]);
		a[n+i+1] = a[i+1];
	}
	for(ll i = 1; i <= 2*n+1; i++) {
		s[i] = s[i-1] + a[i];
	}
	for(ll i = 1; i <= n; i++) {
		ll l = i+1, r = n+i-1;
		ll k = (s[n+i] + s[i]) / 2;
		while(l <= r) {
			ll mid = (l+r)/2;
			if(s[mid] > k) {
				r = mid-1;
			} else if(s[mid] <= k) {
				l = mid+1;
			}
		}
		for(ll j = max(l-5, i+1); j <= min(r+5, n+i-1); j++) {
			ans = max(ans, min(s[j] - s[i], s[i+n]-s[j]));
		}
	}
	printf("%lld", ans);
}
```



---

## 作者：Genius_Star (赞：0)

### 题意;
给定 $N$ 只奶牛所在的圆圈，在圆圈上每两只相邻的奶牛之间有一个距离，奶牛可以按顺时针或逆时针方向走到相邻的奶牛，距离为较短的路程。

现在要求在圆圈上找到距离最远的两只奶牛，输出它们之间的距离。
### 解题思路：

建议先手画几个奶牛的圆圈，模拟一下题目中给的样例。画图的时候，可以把这些奶牛的顺序放在顺时针方向或者逆时针方向。

以顺时针方向为例，那么包含奶牛 $1$ 在内的第 $i$ 个奶牛的位置距离圆圈起点的顺时针距离为：

$$p_i = p_{i-1} + dis_i$$

其中 $dis_i$ 表示第 $i$ 个奶牛和第 $i+1$ 个奶牛之间的距离，$p_0=1$ 表示圆圈起点（可以看出来 $p$ 就是前缀和数组）。

从上述公式中可以看出，$p_i$ 是一个单调递增的序列。

因为题目要求的是相距最远的两个奶牛之间的距离，那么我们可以枚举其中一个奶牛，然后找到离它最远的奶牛。

如何找到离它最远的奶牛呢？因为 $p_i$ 是单调递增的，所以如果要找到离奶牛 $i$ 最远的奶牛，需要找到一个最小的 $j$，满足 $p_j-p_i > \frac{p_n}{2}$。

因为可以顺时针走到奶牛，也可以逆时针走到奶牛，所以需要判断顺时针路径和逆时针路径谁更短。

### 算法实现：

先读入所有奶牛的圆周距离，然后计算 $p_i$。

然后枚举奶牛。对于每个奶牛 $i$，在 $p$ 中二分查找到最小的满足条件的 $j$，然后计算出两个奶牛间的最短距离和最长距离。

因为圆有着对称性，所以在两边都需要取最小值。

时间复杂度为 $O(N\log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=200200;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,p[N],ans=0,l=1,r=0;
int main(){
	n=read();
	for(int i=1;i<=n;++i){
		p[i]=read();
		p[i+n]+=p[i];
		p[i]+=p[i-1];
	}
	for(int i=n+1;i<=n*2;++i)
	  p[i]+=p[i-1];
	double t=(double)p[n]/2.0;
	for(int i=1;i<=n*2;++i)
	  p[r+1]-p[l]<=t?ans=max(ans,p[++r]-p[l]):++l;
   write(min(ans,p[n]-ans));
   return 0;
}
```
大家回去自己推一下，看看能不能找到更优秀的算法~

---

## 作者：Nozebry (赞：0)

## No.1:二分
我们首先要预处理好每一个点到1的距离，因为有环，所以需要开两倍的数组，然后每一次累加答案，计算整个环的大小，记为 $len$。

然后枚举每一个点，处理二分查找前面**1-> $i$ -1( $i$ 为当前的位置)** 个点到 $i$ 的距离，如果大于**m div 2**那就移动左端点至 $mid$ ，否则移动右端点至 $mid$ 。如此循环，当l大于 $n$ +1或 $r$ 大于 $n$ +1时，二分结束，输出答案。

## No.2:最大子段和
和上面的道理一样，我们需要先把这个环扩大到原来的两倍,成为一个长度为 $2n$ 的环，那么将前缀和使用到这条环上是等同于在原来的轴上的操作。

然后求一下前缀和，就变成了求在不大于二分之一总长的最大子段和。

## AC Code:
### No.1:二分
```pascal
uses math;
var
	n,ans,len,i,l,r,mid:longint;
	sum,num:array[0..1000010]of longint;
begin
	readln(n);
	for i:=2 to n do
	begin
		readln(num[i]);
		sum[i]:=sum[i-1]+num[i];
		len:=len+num[i];
	end;
	readln(num[1]);inc(len,num[1]);sum[n+1]:=sum[n]+num[1];
	l:=1;r:=1;mid:=len>>1;
	while (l<=n+1)and(r<=n+1) do
	begin
		if l=r then inc(r)
			else
			if sum[r]-sum[l]<=mid then
			begin
				ans:=max(ans,sum[r]-sum[l]);
				inc(r);
			end
				else
				if sum[r]-sum[l]>mid then
				begin
					ans:=max(ans,min(sum[r]-sum[l],mid-sum[r]+sum[l]));
					inc(l);
				end;
	end;
	writeln(ans);
end.

```
### No.2:最大子段和
```pascal
uses math;
var
	n,ans,l,r,tot,i:longint;
	a,q,sum:array[0..5000010]of longint;
begin
	readln(n);
	for i:=1 to n do
	begin
		readln(a[i]);
		tot:=tot+a[i];
	end;
	for i:=n+1 to 2*n do a[i]:=a[i-n];
	for i:=1 to 2*n do sum[i]:=sum[i-1]+a[i];
	tot:=tot div 2;l:=1;r:=1;q[1]:=1;
	for i:=1 to n do
	begin
		while (l<=r)and(sum[i]-sum[q[l]]>tot) do inc(l);
		ans:=max(ans,sum[i]-sum[q[l]]);
		while (l<=r)and(sum[i]<=sum[q[r]]) do dec(r);
		inc(r);q[r]:=i;
	end;
	writeln(ans);
end.

```

---

## 作者：荣一鸣 (赞：0)

## 90分第一个点错的同学看这里

没错，作为亲身经历者，第一个点十分恶心，把我的程序卡掉了，其实是初始化的问题。

其实我的想法很简单，我们用一边遍历的方法，我们要有一个i和一个j来作为起点和终点。

先把奶牛排成环

                1
            8        2
       
          7            3
       
            6        4
                 5


我们先把i=1，j=1，然后j++向后遍历，直到顺时针的长度大于逆时针的长度，然后再将i++，直到走完。

同时这里其实可以有一个优化，我们把i=1时的最终停下的点标记为tar，然后i枚举到tar就行了，不用枚举到n。

第一个点错可能是初始化错了

```
	sumn=a[1];
	far=min(sumn,sum-sumn);
	tar=2;
```

这里的far不能直接赋值为sumn。

```
#include<iostream>
#include<cstdio>
using namespace std;
int a[200010];
int far,tar;
int n;
int sumn=0,sum,maxn;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];
		a[i+n]=a[i];
	}
	int j=1;
	sumn=a[1];
	far=min(sumn,sum-sumn);
	tar=2;
	while((sum-sumn)>sumn&&j<=n){
		j++;
		sumn+=a[j];
		int tmp=min(sumn,sum-sumn);
		if(tmp>far){
			far=tmp;
			tar=j+1;
		}
	}
	maxn=max(far,maxn);
	sumn-=a[1];
	sumn-=a[j];
	j--;
	maxn=max(far,maxn);
	for(int i=2;i<tar;i++){
		far=0;
		while((sum-sumn)>sumn&&j<=n){
			j++;
			sumn+=a[j];
			int tmp=min(sumn,sum-sumn);
			if(tmp>far){
				far=tmp;
			}
		}
		maxn=max(far,maxn);
		sumn-=a[i];
		sumn-=a[j];
		j--;
	}
	cout<<maxn;
}
```

---

## 作者：沉辰 (赞：0)

感觉这个很难，也是看了题解后才明白的

推荐一个博客，是二分答案的，也很详细

http://blog.csdn.net/jpwang8/article/details/51931023


---


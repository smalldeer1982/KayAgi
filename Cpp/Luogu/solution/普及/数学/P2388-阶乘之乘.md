# 阶乘之乘

## 题目背景

不告诉你……


## 题目描述

求出 $1!\times 2!\times 3!\times 4!\times \cdots \times n!$ 的末尾有几个零。


## 样例 #1

### 输入

```
10```

### 输出

```
7```

# 题解

## 作者：虞皓翔 (赞：79)

居然发现没有人用$\Theta(\log n)$的算法，前面几楼都是$\Theta(n)$甚至更高，现在就来一发$\Theta(\log n)$的算法。

首先，令$f(n)=\sum_{i=1}^\infty\lfloor\frac n{5^i}\rfloor$，得到所求为

![](https://cdn.luogu.com.cn/upload/pic/4243.png)  //怕latex太长显示出一堆em什么的东西

所以显然是$\Theta(\log n)$的。

核心代码：

```cpp
for(j = 5; j <= n; j *= 5){
        ans += j * (n / j) * (n / j - 1) >> 1;
        ans += (n / j) * (n % j + 1);
    }
```

---

## 作者：星灵王 (赞：64)

这道题真的这么麻烦吗？

楼下的题解真心复杂了。

一个模拟加累加就好了。

因为五的倍数总比二的倍数少，所以只需统计五的倍数。

 
```cpp
#include<iostream>
using namespace std;
int main()
{
    long long n,t;
    cin>>n;
    long long ans=0,s=0;//ans为总数，s为i的阶乘五的倍数 
    for(int i=1;i<=n;i++)
    {
        t=i;
        while(t%5==0)//若t整除5，则i的阶乘五的倍数加一 
        {
            s++;
            t/=5;
        }
        ans+=s;//ans加上i的阶乘五的倍数 
    }
    cout<<ans<<endl;//输出 
    return 0;
}
```

---

## 作者：Tarsal (赞：18)

本蒟蒻又来发题解了QwQ;

看到这个题目，本蒟蒻第一眼就想写打个暴力；

但是，动动脑子想一想就知道，普通的的暴力是过不了的；

但是，身为蒟蒻的我，也想不出什么高级的数学方法来优化；

### 好，回到正题

题目是要求我们求出这个累乘末尾的‘0’

‘0’是个特别特殊的数字，因为是累乘，那么一个‘0’肯定是由一个‘2’和一个‘5’相乘得来的；

而且‘0’的个数肯定是‘2’和‘5’之间数目较少的那一个的个数；

而我们又是求它的阶乘的累乘，

所以‘5’的个数一定要小于‘2’的个数

那么末尾‘0’的个数就是‘5’的个数‘

这样就很好写了；

好，愉快的代码时间：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long//不开long long见祖先 
int n, now, num, ans;//num是这一轮的‘0’的个数，ans是总答案； 
signed main()
{
	scanf("%lld", &n);//输入 
	for(int i = 1; i <= n; ++ i)//累乘，依次枚举 
	{
		now = i;//因为要不断除5，所以不可以直接用i； 
		while(now % 5 == 0)//找‘5’ 
		{
			++ num;//加一个 
			now /= 5;//除上5 
		}
		ans += num;//相加
		//注意：num不需要赋值为0，也不可以
		//因为它的累乘包含了它的前面的点，
		//所以如果num赋值为0后就会导致错误 
	}
	printf("%lld", ans);//输出，再次强调一定要开long long 
	return 0;
}
```


---

## 作者：豌豆射手皮0608 (赞：13)

这种题目是最好的**卡常题**了QAQ

那我就来提供一种常数**极小**的方法吧~~（您不就是不会卡常技巧吗）~~

啪，要你多嘴！

思路：我们把阶乘每25分为一组，假设第一个数后面的0的个数为k，那么有：

## 0~4：k

## 5~9：k+1

## 10~14：k+2

## 15~19：k+3

## 20~24：k+4

发现**每一段数**都有一定**规律**耶QAQ

于是乎就**打**出了如下的**表**

```cpp
switch(x)
{
	case 0:return k;
	case 1:return k*2;
	case 2:return k*3;
	case 3:return k*4;
	case 4:return k*5;
	case 5:return k*6+1;//k*5+(k+1)*1
	case 6:return k*7+2;//k*5+(k+1)*2
	case 7:return k*8+3;//k*5+(k+1)*3
	case 8:return k*9+4;//k*5+(k+1)*4
	case 9:return k*10+5;//k*5+(k+1)*5
	case 10:return k*11+7;//k*5+(k+1)*5+(k+2)*1
	case 11:return k*12+9;//k*5+(k+1)*5+(k+2)*2
	case 12:return k*13+11;//k*5+(k+1)*5+(k+2)*3
	case 13:return k*14+13;//k*5+(k+1)*5+(k+2)*4
	case 14:return k*15+15;//k*5+(k+1)*5+(k+2)*5
	case 15:return k*16+18;//k*5+(k+1)*5+(k+2)*5+(k+3)*1
	case 16:return k*17+21;//k*5+(k+1)*5+(k+2)*5+(k+3)*2
	case 17:return k*18+24;//k*5+(k+1)*5+(k+2)*5+(k+3)*3
	case 18:return k*19+27;//k*5+(k+1)*5+(k+2)*5+(k+3)*4
	case 19:return k*20+30;//k*5+(k+1)*5+(k+2)*5+(k+3)*5
	case 20:return k*21+34;//k*5+(k+1)*5+(k+2)*5+(k+3)*5+(k+4)*1
	case 21:return k*22+38;//k*5+(k+1)*5+(k+2)*5+(k+3)*5+(k+4)*2
	case 22:return k*23+42;//k*5+(k+1)*5+(k+2)*5+(k+3)*5+(k+4)*3
	case 23:return k*24+46;//k*5+(k+1)*5+(k+2)*5+(k+3)*5+(k+4)*4
	case 24:return k*25+50;//k*5+(k+1)*5+(k+2)*5+(k+3)*5+(k+4)*5
}
```

但是一些巨（懒）佬（虫）们显然是不屑于**打表**这种~~**猥琐**~~操作了

于是~~根据上面打出来的表~~就有了**玄学**的递推式来处理25的余数

```cpp
long long solve(long long x)
{
	if(x==0) return k;
    else return solve(x-1)+k+x/5;
    //因为是对25取余的余数，所以这样的递推式的时间复杂度可以接受
}
```


余数处理完了以后剩下的就**简单**多了

只需要以初值为25，步长为25一步步去走就可以了QAQ

以下代码就可以解决这个问题QAQ

```cpp
    for(long long i=25;i<=n;i+=25)
	{
		tt=i;
		ans+=25*k+50;//5*(k+1)+5*(k+2)+5*(k+3)+5*(k+4)的化简
		while(tt%5==0)
		{
			tt/=5;
			k++;//保存当前第一个数后面0的个数
		}
		k+=4;//因为之前保存的是第一个数所以要加4才能保存下一组的第一个数
	}
```
这样还是O(N)的做法，但是常数为**（1/25）**，基本上不用考虑常数问题

实测INT_MAX一秒内出结果，~~妈妈再也不用担心常数被卡过不去~~

附上本来没错但您交上去就是CE代码（逃

```cpp
#iuclnde<bist\sdtc++.h>
using namespace sdt;
long long n,tt,ans,k;
long long solve(long long x)
{
    while(1);
	if(x==0) return k;
    else return solve(x-1)+k+x/5;
}
int mian()
{
	scarf("%d",&n)；
	while(1);
	for(long long i=25;i<=n;i+=25)
    //其实i不需要开long long但是您如果非要过INT_MAX还是得开的QAQ
	{
		tt=i;
		ans+=25*k+50;
		while(tt%5==0)
		{
			tt/=5;
			k++;
		}
		k+=4;
	}
	
	ans+=solve(n%25);
    while(1)
	printf("%d/n",ans);
    while(1);
	return 0;
}
```

---

## 作者：Ricken (赞：10)

## [【原题传送门】](https://www.luogu.org/problem/P2388)

这是一道标准的数论题，不需要任何算法与数据结构。但是，很重要的一点是： 
## 要开long long！（或int64）

现在~~正式~~开始分析：

题目要求末尾0的个数—>求这个大数最多可以被多少个10整除。因为10 = 2×5 ，且因子2的个数远多于因子5的个数（可自行验证），所以，只需要讨论因子5的个数即可。我的方法时间复杂度为  O(log5 n)，只需要一个一层循环。

   本题可以用归纳的思路。

1.计算 s=n! 有多少个因子5。

设k=因子5的个数。

<1> 计算1~n 之间有多少个数能被5整除。很显然，是 [ n/5 ] 个。

但是，这个值并不是因子5的个数，k仍然少了一些东西：25 = 5^2，有两个因子5，但我们却只算了一次。

<2> 于是，k还得加上 [ n/25 ]。

<3> 同理，k还得加上[ n/125 ]，以此类推。

当5^m刚刚大于n时，就不需要计算了。代码如下：
```cpp
int main(){
    long long n;
    cin>>n;
    long long cnt=0;
    while(n>0){
        n/=5;// [n/25]=[[n/5]/5]
        cnt+=n;
    }
    cout<<cnt;
    return 0;
}
```
2.计算 s=1!×2!×3!……×n! 有几个因子5。

还是按刚才的思路。

<1> 1!~n!有多少个数能被5整除 ？
有[ 1/5 ]+[ 2/5 ]+……+[ n/5 ]个。

原式=[ 1/5 ]+[ 2/5 ]+……+[(s-1)/5 ](s为最接近n且小于n的5的倍数）+ [ s/5 ]+……+[ n/5 ]

=5×(1+2+3+……+([ n/5 ]-1))+(n%5+1)×[n/5]

=5×[ n/5 ]×([ n/5 ]-1)/2+(n%5+1)×[n/5]


<2> 1!~n!有多少个数能被25整除 ？
有[ 1/25 ]+[ 2/25 ]+……+[ n/25 ]个。

同理，此式=25 [ n/25 ] ([ n/25 ]-1)/2+(n%25+1)  [ n/25 ]

以此类推。

完整代码：
```cpp
#include<iostream>
using namespace std;
int main(){
	long long n;
	cin>>n;
	long long cnt=0;
	long long cur=1;
	int m=n;
	while(n>0){
		cur*=5;//cur为当前5的幂
		long long k=m%cur;
		n/=5;
		cnt+=cur*n*(n-1)/2;
		cnt+=n*(k+1);
	}
	cout<<cnt;
}
```
这是本蒟蒻第一篇题解，求通过~

---

## 作者：KesdiaelKen (赞：5)

这题真是卡常……第一遍是八十分，然后加了一堆常数优化，然后就AC了（不知道再提交一遍能不能过……）

此题思路没有什么好讲，是一道很经典的数学题，即从1-n枚举5的个数（因为2的个数比5多，而10=2\*5），加上一个类似前缀和的东西，然后记得sum要开long long，然后就过了。这里实际上是借本题，讲一讲常数优化。

优化1：读入优化。直接用getchar读入，会比scanf快。当然，各位会fread或mmap的大佬，也可以用这些。

优化2：二进制运算。据说二进制运算会比普通判断快？（有可能是假的，但绝不会慢）

优化3：register，利用缓存跑程序，会更快一点。

优化4：函数加inline，变为内联函数，也起到了加速运行的作用。

以上几点优化，就是我所知道的常数优化了。如果我知道的太少，请神犇多多指教。

上精简版代码：

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
inline int dy()//读入优化
{
    register int shu=0,ch=0;//register加速
    while(!isdigit(ch))ch=getchar();//isdigit，判断是否为数字字符
    while(isdigit(ch))shu=shu*10+ch-'0',ch=getchar();
    return shu;
}
int main()
{
    register int n=dy(),gs=0,lci;//直接在定义里读入
    long long sum=0;//记得开long long
    for(register int i=1;i<=n;i++)
    {
        lci=i;//存到另外一个变量中，以防变量改变，影响正常进程
        for(;!(lci%5);gs++)lci/=5;//相当于：while(lci%5==0){lci=lci/5,gs++;}这里用了前缀和的思想，即将之前的状态一直保留，不用重复计算
        sum+=gs;//加上目前的五的个数
    }
    printf("%lld",sum)//输出
    return 0;
}
```

---

## 作者：徐艺轩 (赞：4)

（下面的所有代数均表示整数）


（"/"表示整除，在此处优先级与乘法相同）


（"^"表示乘方，在此处优先级最高）


（log以5为底）


我们可以这样考虑，∏i!(1<=i<=n)相当于求下列矩阵中所有数字的积：


1 1 1 1 1 1 1 1 ... 1


1 2 1 1 1 1 1 1 ... 1


1 2 3 1 1 1 1 1 ... 1


1 2 3 4 1 1 1 1 ... 1


1 2 3 4 5 1 1 1 ... 1


... 1 2 3 4 5 6 7 8 ... n


10分解质因数后会变成2\*5，显然对于一个数的阶乘，5的质因数数量总是大于2的质因数数量。所以，为了求出答案，∏i!(1<=i<=n)中5的质因数数量即为答案。也就是说，对于上述矩阵，我们只关心倍数为5的那一列。


要想解此题，我们可以求出矩阵中所有满足为5^1的倍数的数量，为5^2的倍数的数量，为5^3的倍数的数量……这些数量之和即为答案。而对于第i列，若i=p\*5^q，则该列有(n-i+1)个数是整数，也就是说，矩阵中所有满足为5^k的倍数的数量为∑(n/5^k)(n-i\*5^k+1)(1<=i<=n/5^k)。这样做的总时间复杂度为O(nlog n)，会超时。利用求和公式，我们可以得出∑(n/5^k)(n-i\*5^k+1)(1<=i<=n/5^k)=n/5^k\*n+n/5^k-(1+n/5^k)\*(n/5^k)/2\*5^k，于是我们就可以把总时间复杂度降到O(log n)了。

看了一下，竟然没有Pascal代码

```cpp
var
  s,n,i:longint;
begin
  readln(n);
  if n=100000000 then// 打个表
    begin
      writeln('1249999451562499');
      halt;
    end;
  for i:=1 to n do
    s:=s+i div 5+i div 25+i div 125+i div 625++i div 3125+i div 15625+i div 78125+i div 390625+i div 1953125+i div 9765625+i div 48828125; //求出5的倍数
  writeln(s);
end.
```

---

## 作者：sineVI (赞：3)

# ~~关于二分答案在此题中的应用~~

n<=1e8，直接枚举肯定TLE，那么就在代码中放几个通过暴力算出的值，当n>这几个值的时候就从ta开始计算就行了。

表格如下：

n=50000000: ans=312499732421874

n=75000000: ans=703124599218748

n=87500000: ans=957030775390622

附赠代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long ans=0;
const int mod[105]={1,5,25,125,625,3125,15625,78125,390625,1953125,9765625,48828125,244140625,1220703125};
//打表

inline int get_five(int i)
{
	int cnt=0,id=0;
	while(mod[++id]<=i)
	{
		cnt+=i/mod[id];
	}
	return cnt;
}
/*
 *get_five，顾名思义，就是算出来阶乘的答案中有几个5。
 *众所周知：2*5=10，而2<5，从而可知每有一个5，必然有一个与之相对应的2可以配出10，从而答案+1。
 *关于5的k次方，打表中附赠了。
*/

int main()
{
	int n;
	cin>>n;
	if(n<=50000000)//此处为“二分答案”（划掉）
		while(n)
		{
			ans+=get_five(n);
			n--;
		}
	else if(n<=75000000)
	{
		ans=312499732421874;
		for(int i=50000001;i<=n;i++)
		{
			ans+=get_five(i);
		}
	}
	else if(n<=87500000)
	{
		ans=703124599218748;
		for(int i=75000001;i<=n;i++)
		{
			ans+=get_five(i);
		}
	}
	else
	{
		ans=957030775390622;
		for(int i=87500001;i<=n;i++)
		{
			ans+=get_five(i);
		}
	}
	cout<<ans<<endl;
	return 0;//好习惯
}
```


---

## 作者：河城白露 (赞：2)

因为 10=2*5  且 对1~n上所有的数进行质因数分解时，总有n(2)<n(5)

所以 只要统计出n(5)即可
（其中，n(x)表示1~n中分解出x的个数）

下面是公式化后的代码
```cpp
#include <cstdio>
#include <cstring>
long long n,ans=0,k=5,ni;
int main()
{
	scanf("%lld",&n);
	while (k<=n)
	{
		ni=n/k;
		ans+=(ni*(n+1)-k*(ni+1)*ni/2);
		k*=5;
	}
	printf("%lld",ans);
	return 0;
}
```
第一次交题解，若有不足请见谅。

---

## 作者：eternityer (赞：2)

## 统计5的个数就好了
##### 因为10只能由2*5得来  所以只要记录2和5个数的最小值就好了，又因为2的个数远远大于五 所以只要统计五的个数。

```
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	cin>>n;
	long long ans=0;
	for(int i=5;i<=n;i+=5){
		int j=i;
		int p=0;
		while(j%5==0){
			j/=5;
			p++;
		}
		ans+=(n-i+1)*p;
	}
	cout<<ans;
	return 0;
}
```
代码中循环以五开始和五递增是因为 1，2，3，4的阶乘肯定都等于0的阶乘五的个数0  同理6，7，8，9的阶乘的个数也等于5的阶乘总5的个数1。（注意数目可能很大，要用long long统计答案）
应该和其它题解都不同了吧，望能通过  


---

## 作者：Euler_Pursuer (赞：2)

我的想法是这样的，假设$ n=5,6,7,8,9 $，那么后面的$ 0 $的个数只会递增$ 1 $，若$ n=10,11,12,13,14 $，则后面的$ 0 $将递增$ 2 $。那么根据这样的原理，我设一个数组$ x[1...y] $，存放$ 5 $的倍数的数，保证数组中的所有数据都小于$ n $，然后设$ i=5,10,15...(n-k) $，其中$ n-k $为$ 5 $的倍数，再将其与数组中的数据取余，看其能够取余到数组中的第几个数据，于是设$ q $为增长量，初始为$ 0 $，增长量在$ i-5,i-4,i-3,i-2,i-1 $中是一样的，所以我们只要隔五个考虑即可。对了，这里考虑的不是$ i $及其后面四个连续的数，而是$ i $的前面五个连续的数，例如$ i=5 $时，考虑的是$ 0,1,2,3,4 $，此时增长量为$ 0 $，故总和为$ 0 $。当$ i $超过了$ n $，循环还会将其增加五，考虑到$ n $不一定为五的倍数，因此将$ i $减五，然后再自增到$ n $。而此时$ q $恰为其增长量，于是只要一个一个加上去就行了（貌似乘上去就无需循环了——我想麻烦了）。这样就能求出答案了。

然而，我的程序不是很快的，但还是好懂吧，希望大家多多指教。

以下是程序主要部分：


```cpp
for(i=5;i<=n;i+=5)
    {
        for(j=1;j<maxi;j++)
        {
            if(i%x[j]!=0)
            {
                b+=q*5;//0-4,5-9,10-14...
                q+=j-1;//0  ,1  ,2    ...
                break;
            }
        }
    }
    for(i-=5;i<=n;i++)
    {
        b+=q;
    }
```

---

## 作者：doby (赞：2)

怎么大家都先想到的打表……

朴素算法+微小的优化，过了……

```cpp
#include<iostream>
using namespace std;
long long n,i,j,ans=0;
int main()
{
    cin>>n;
    for(i=0;i<=n-5;i=i+5){ans=ans+(i/5+i/25+i/125+i/625+i/3125+i/15625+i/78125+i/390625+i/1953125+i/9765625+i/48828125)*5;}//所有5的倍数，并且连续5个数必定含5的个数相同
    for(;i<=n;i++){ans=ans+i/5+i/25+i/125+i/625+i/3125+i/15625+i/78125+i/390625+i/1953125+i/9765625+i/48828125;}//处理剩下的
    cout<<ans;
}
```

---

## 作者：硫代硫酸钠 (赞：2)

预备知识:勒让德定理

对于正整数n,在$n!$的素因子标准分解式中，素数$p$的最高指数记作$Lp$,


则$Lp=\sum\limits_{k\geq1} {\frac{n}{p^k}}$.

代码实现:
```cpp
ll Legendre(ll x) {while (x) cnt+=x/5,x/=5; return cnt; }
```

然后我们发现答案是若干个阶乘相乘,所以答案是勒让德定理算出的数值相加.


注意到2的素因子分布远远多于5,直接计算$p=5$即可

蒟蒻的代码:
```cpp
#include<algorithm>
#include<cctype>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#define size 500010
#define debug(x) cerr<<#x<<"="<<x
#define gc getchar()
#define db double
#define ll long long
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;i--)
#define il inline
using namespace std;

il ll r()
{
	char c; ll x,f=1;
	for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
	for (c=gc;isdigit(c);c=gc) x=(x<<1)+(x<<3)+c-'0';
	return f*x;
}

ll n,ans,cnt=0;

ll Legendre(ll x) {while (x) cnt+=x/5,x/=5; return cnt; }

int main()
{
	n=r();
	rep(i,1,n) ans=Legendre(i);
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：依依 (赞：2)

我的做法：

将1-n 的阶乘 对2和5进行质因数分解

假设有A个5，B个2

那么最终答案为min(A,B)

原理：2*5=10

得分：80


优化：

由分析可知，A一定小于等于B

所以直接统计A就可以了

所以在统计的时候i+=5 

eg, 5!与6!,7!,8!,9!中5的个数是一样的

注意一下边界

还要开long long

[￣□￣｜｜](http://www.cnblogs.com/adelalove/p/9015245.html)

---

## 作者：Windowsredstone (赞：1)

~~居然没有人打表，我来一发~~

思路几位大佬讲的都很清楚了，在此不多说。

每隔1000000打一次，共101次

打表程序奉上：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<fstream>
using namespace std;
int calc(int x)
{
	int cnt=0;
	for(int i=5; i<=x; i*=5)
		cnt+=x/i;
	return cnt;
}
int main()
{
	int i,tqlorz;
	long long ans=0;
	ofstream fout("2388.txt");
	for(int i=0;i<=100000000;i++)
	{
		ans+=calc(i);
		if(i%1000000==0)
		{
			printf("%lld to %lld\n",i,ans);
			fout<<ans<<", ";
		}
	}
	return 0;
}

```

---

## 作者：TAFE_ZZR (赞：1)

## 这道题目真的一点都不麻烦！
因为5的倍数比2的倍数少，所以统计5的倍数即可！
#### 废话不多说，注释都在代码里 。

    #include<bits/stdc++.h>//懒人专用万能头文件
	using namespace std;
	long long s,ans,n;
	int main() {
    	cin>>n;
    	for(int i=1;i<=n;i++) { //寻找5的倍数
        	if(i%5==0) { //如果是5的倍数
            	int t=i;  //定义临时变量
            	while(t%5==0) {  //看看i(t)里有几个5
                	t/=5;
                	s++;
            	}
        	}
        	ans+=s; //答案更新
   		}
    	cout<<ans;
    	return 0;
	}
    
## 本蒟蒻题解就到这里了
# 勿抄！ 勿抄！ 勿抄！ 重要的事情说三遍！

---

## 作者：ABCDXYZ (赞：1)

自己做的时候，想了一个方法（之前由于数组开得过大5个RE。。还向各位求助来着\*—\*。。）不过现在问题已经解决啦。

不难看出1！\*2！\*...\*n！展开后其实是1^n\*2^(n-1)\*...\*n^1。又因为质因数5的个数一定比质因数2的个数多。所以lz我就有思路了（下附代码奉上）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int main( ){
    long long i,j,maxw=0,n,k,wu;//maxw用来统计5的总个数 
    cin>>n;
if(n==100000000)cout<<1249999451562499;//打个表，谢谢包容 
    else{
    for(i=1;i<=n;i++){
        k=i;wu=0;//从1到n筛选 
        while(k>0){
              if((k%5==0) && (k!=0)){
                k=k/5;wu++;//每个wu用来临时储存 
            }
                else break;
            }
            maxw=maxw+wu*(n+1-i);//思路在上面 
        }
    cout<<maxw;
    }
    return 0;
}
```
完成！哈哈，总的来说速度还是不错的。^\_^+

---

## 作者：Once_Upon_A_Coding (赞：0)

# 既然@寂_亡的思路和我一开始想的一样，那我就换一个思路吧（或者说我再补充没有讲清楚的地方）

**~~（程序差不多，不用看了，你们直接可以复制楼下的）~~**





------------
好的，我们来先找一找规律：

1！=1  答案为0

1！× 2！=1×2×1  答案还是为0

一直列举，直到第5个：

5！× 4！× 3！× 2！× 1！=5×4×3×2×1×4×3×2×1×3×2×1×2×1×1  答案为1

再往下列举，每次答案都多1。

直到第10个，答案变成了7，以后往下每次答案都多2。

然后15,20,25等等

我们可以发现：当阶乘数为5的一倍，5的两倍，等等等，都相当于开辟了一个新的阶层，每次多的数也依次增加。

知道了这一点，就好做了。每次看一下这一个阶乘数字是不是5的倍数。如果是，那么原本答案每次多一。

## 然后，还有一个坑人的地方：有的是25,125,625等等。你需要使用while循环来看看这个数有多少个5。

好的，那么有人可能就要问了：为什么只看5呢？

答案是：因为有因数2的数字太多了，每一个5和一个2才能配对为一个0，所以：

## 2足够多，找5

然后顺着思路去写就行了。

## 直接上优化代码

（有人又要问了：不优化代码是什么样的？答案是：不优化的代码每一次乘新的数字的阶乘的时候，都要从1开始再算一遍，比如说算到5，从4！到1！每一次都要看一下这个数字的阶乘中有没有5，效率非常低。简单来说就是算过的东西又再算一次）

## 上代码！！~~（这次是真的了）~~

```cpp
#include <bits/stdc++.h>
#include <stdio.h>


using namespace std;



int main()
{
	long long n;
	long long s=0,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		if(i%5==0)
		{
			int ti=i;
			while(ti%5==0)
			{
				ti/=5;
				s++;
			}
		}
		ans+=s;
	}
	cout<<ans;
	return 0;
}

```
加油鸭！ヾ(◍°∇°◍)ﾉﾞ冲向AC!

（本人新开了一个团队，叫Once_Upon_A_Coding，有兴趣的人可以加一下啦~~~）


### 管理员求过，之前提交了3遍都没过，这次一定要过啊

---

## 作者：ghj1222 (赞：0)

上正题前先安利一波：

# [A173345](http://oeis.org/A173345)

此数列即为本题中要求的数列！

> 前置知识：
>
> 阶乘中末尾0的个数就等于阶乘分解质因数后5的次数，为啥，因为5的次数一定要小于~~(好像还真的不可能等于)~~2的次数。

所以统计阶乘中所有的数5的因子个数求和即可。

然而这题TMD是阶乘之乘。。。

然而这并没有难到我们，我们只需要求出每个数中5的因子个数，然后求前缀和就是阶乘的5的个数，再来一遍前缀和。。。就是阶乘之乘中5的个数。。。然后我们不难的到下面的代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
long long a[100000010];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		int x = i;
		while (x % 5 == 0)
		{
			x /= 5;
			a[i]++;
		}
	}
	for (int i = 1; i <= n; i++)
		a[i] += a[i - 1];
	for (int i = 1; i <= n; i++)
		a[i] += a[i - 1];
	cout << a[n] << endl;
	return 0;
}
```

交上去。。。Memory内存超限~~qtmd把评测机揍一顿~~

由于我们只需要知道a[n]，我们可以不开大数组直接求，但是有的同学想知道二次前缀和怎么求，我们可以开两个变量，一个代表一次前缀和，一个代表二次前缀和，如下面的代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
long long ans1, ans2;

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		int ans0 = 0, x = i;
		while (x % 5 == 0)
		{
			x /= 5;
			ans0++;
		}
		ans1 += ans0;
		ans2 += ans1;
	}
	cout << ans2 << endl;
	return 0;
}
```

让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/space/show?uid=88460)

---

## 作者：2017hxz (赞：0)

1. i从1循环到n，如果i是5的倍数，那么i！末尾0的个数必然有变化


------------

令x为循环到的（i-1）！末尾0的个数
1. 如果5|i，x的增量为floor(log5(i))
1. 否则ans直接叠加x


------------

```cpp
#include<iostream>
using namespace std;
long long n,x,s,ans;
int main()
{
    cin>>n;
    for(int i=5; i<=n; i+=5)//5个一数
    {
        ans+=(x<<2);
        s=i;
        while(!(s%5))x++,s/=5;//因为c++没有log5，手动求
        ans+=x;
    }
    ans+=(n%5)*x;
    cout<<ans;
    return 0;
}

```

---

## 作者：Mr_Li (赞：0)

（下面的所有代数均表示整数）

（"/"表示整除，在此处优先级与乘法相同）

（"^"表示乘方，在此处优先级最高）

（log以5为底）

我们可以这样考虑，∏i!(1<=i<=n)相当于求下列矩阵中所有数字的积：

1 1 1 1 1 1 1 1 ... 1

1 2 1 1 1 1 1 1 ... 1

1 2 3 1 1 1 1 1 ... 1

1 2 3 4 1 1 1 1 ... 1

1 2 3 4 5 1 1 1 ... 1

...
1 2 3 4 5 6 7 8 ... n

10分解质因数后会变成2\*5，显然对于一个数的阶乘，5的质因数数量总是大于2的质因数数量。所以，为了求出答案，∏i!(1<=i<=n)中5的质因数数量即为答案。也就是说，对于上述矩阵，我们只关心倍数为5的那一列。

要想解此题，我们可以求出矩阵中所有满足为5^1的倍数的数量，为5^2的倍数的数量，为5^3的倍数的数量……这些数量之和即为答案。而对于第i列，若i=p\*5^q，则该列有(n-i+1)个数是整数，也就是说，矩阵中所有满足为5^k的倍数的数量为∑(n/5^k)(n-i\*5^k+1)(1<=i<=n/5^k)。这样做的总时间复杂度为O(nlog n)，会超时。利用求和公式，我们可以得出∑(n/5^k)(n-i\*5^k+1)(1<=i<=n/5^k)=n/5^k\*n+n/5^k-(1+n/5^k)\*(n/5^k)/2\*5^k，于是我们就可以把总时间复杂度降到O(log n)了。


---

## 作者：XHRlyb_2001 (赞：0)

弱弱地写一个O（n）的QAQ

加了点小优化，5个一组，循环n/5次。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
inline long long read()
{
    char c=getchar(); long long num=0,f=1;
    while (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }
    while (c<='9'&&c>='0') { num=num*10+c-'0'; c=getchar(); }
    return num*f;
}
long long n,ans=0;
int main()
{
    n=read();
    long long m=0;
    for (int i=1;i<=n/5;i++)
    {
        int num=i*5;
        ans+=m*4;
        while (num%5==0) num/=5,m++;
        ans+=m; 
    }
    ans+=m*(n%5);    
    printf("%lld",ans);
    return 0;
}
```

---


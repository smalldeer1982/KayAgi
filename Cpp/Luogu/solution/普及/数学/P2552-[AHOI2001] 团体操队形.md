# [AHOI2001] 团体操队形

## 题目描述

有 $n$ 个团体操队员编号分别为 $1\sim n$ 。其队形(分连续队形和梅花桩队形)可以按行排列或者按列排列，按行(列)排列时每行(列)有 $r$ 个位置。 

例1：$n=16$，$r=6$，连续队形按行排列。
|1|2|3|4|5|6|
|:-:|:-:|:-:|-|-|-|
|**7**|**8**|**9**|**10**|**11**|**12**|
|**13**|**14**|**15**|**16**|

例2：$n=16$，$r=3$，连续队形按列排列。
|  1  |  4  |  7  |  10  |  13  |16|
| :-: | :-: | :-: |  :-: |  :-: |- |
|**2**|**5**|**8**|**11**|**14**|
|**3**|**6**|**9**|**12**|**15**|

例3：$n=16$，$r=7$，梅花桩队形按行排列。
|  1   |      |  2   |      |  3   |      |  4   |
| :-:  | :-:  | :-:  | :-:  | :-:  | :-:  | :-:  |
|      |**5** |      |**6** |      |**7** |      |
|**8** |      | **9**|      |**10**|      |**11**|
|      |**12**|      |**13**|      |**14**|      |
|**15**|      |**16**|      |      |      |      |

例4：$n=16$，$r=5$，梅花桩队形按列排列。
|  1  |     |  6  |      |  11  |      |16 |
| :-: | :-: | :-: | :-:  | :-:  | :-:  |:-:|
|     |**4**|     |**9** |      |**14**|   |
|**2**|     |**7**|      |**12**|      |   |
|     |**5**|     |**10**|      |**15**|   |
|**3**|     |**8**|      |**13**|      |   |

现请你编写程序指出编号为 $m$ 的团体操队员所处位置的行号和列号。

## 样例 #1

### 输入

```
2
16 1 1 6 11
16 2 2 5 11```

### 输出

```
2 5 1 5```

# 题解

## 作者：SuperJvRuo (赞：6)

这是一道模拟


注意事项：


1、向上取整的除法：a/b=(a+b-1)/b


2、取余结果为零时应在第r列（行）


3、当情况为梅花桩时，其实就是确定2\*m-1号的位置：


代码：

```cpp
#include<cstdio>
int main()
{
    int k,n,x,y,r,m;
    scanf("%d",&k);
    while(k--)
    {
        scanf("%d%d%d%d%d",&n,&x,&y,&r,&m);
        if(x==1)
        {
            if(y==1)
                printf("%d %d ",(m+r-1)/r,m%r?m%r:r);
            else
                printf("%d %d ",m%r?m%r:r,(m+r-1)/r);
        }
        else
        {
            if(y==1)
            {
                m=m*2-1;
                if(r&1)
                    printf("%d %d ",(m+r-1)/r,m%r?m%r:r);
                else
                    printf("%d %d ",(m+r-1)/r,((m+r-1)/r)&1?m%r:m%r+1);
            }
            else
            {
                m=m*2-1;
                if(r&1)
                    printf("%d %d ",m%r?m%r:r,(m+r-1)/r);
                else
                    printf("%d %d ",((m+r-1)/r)&1?m%r:m%r+1,(m+r-1)/r);
            }
        }
    }
    return 0;
}
```

---

## 作者：XiaoQuQu (赞：3)

### 前言
第一次提交主题库的题目题解，求过！

~~不知道是不是~~更好的阅读体验：[我的洛谷博客](https://www.luogu.com.cn/blog/xiaoququ/solution-p2552)。

首先，这道题很明显是一道水题，难度也有些虚高了。正确的难度应该为 普及-。

### 题意
很简单。大概就是：

有两种队形。一种称之为 **连续队形**，而另一种称之为 **梅花桩队形**。给出队伍里的人数、队形代号、排列方式、每行（也可以为列）的位置数、询问队员的编号后，让你求出对应的行号与列号。

### 思路
首先，对于连续队形，很明显有如下结论：
- 当队形按照 行排列 时，$m$ 号所在的位置为 $\lceil (m-1) \div r \rceil$ 行，$m \mod r$ 列。
- 当队形按照 列排列 时，$m$ 号所在的位置为 $\lceil (m-1) \div r \rceil$ 列，$m \mod r$ 行。

接着，对于梅花桩队形，将编号乘 $2-1$ 后，仍然可以套用连续队形的思路（除了部分特殊情况，见代码）。这里不再重复。

想到这里，这题目已经没什么难度了，可以直接上代码了。
### 时空复杂度分析&提交记录
时间复杂度 $\text{O}(n)$ 即读入 $\text{O}(n)$。
无法继续优化，显然读入最低时间复杂度为 $\text{O}(n)$。

空间复杂度 $\text{O}(1)$。

提交记录：  

![屏幕截图 2021-08-23 212943.png](https://i.loli.net/2021/08/23/mSjQrTzIyMkDPuV.png)
### 代码
```cpp
#include<iostream>
#include<cmath>

using namespace std;

int k,p,q,s,r,m;

int main(void){
    cin>>k;
    while(k--){
        cin>>p>>q>>s>>r>>m;
        if(q==1){
            //连续队形
            if(s==1){
                //行排列
                int x=ceil(m*1.0/r),y=(m%r==0?r:m%r);
                cout<<x<<' '<<y;
            }
            else{
                //列排列
                int x=ceil(m*1.0/r),y=(m%r==0?r:m%r);
                cout<<y<<' '<<x;
            }
        }
        else{
            //梅花桩队形
            m=m*2-1;
            if(s==1){
                //行排列
				int x=ceil(m*1.0/r),y=(m%r==0?r:m%r);
                if((r&1)==false){
                	cout<<x<<' '<<(x&1?y:y+1);
				}
				else{
					cout<<x<<' '<<y;
				}
            }
            else{
                //列排列
                int x=ceil(m*1.0/r),y=(m%r==0?r:m%r);
                if((r&1)==false){
                	cout<<(x&1?y:y+1)<<' '<<x;
				}
				else{
					cout<<y<<' '<<x;
				}
            }
        }
        cout<<' ';
    }
    return 0;
}
```


---

## 作者：αnonymous (赞：3)

其实这道题难就难在**梅花桩**上,然而梅花桩队形可以用以下思路来解决:

●首先横坐标+2(中间空出一格)

●然后判断是否超出r,如果超出,换行

●换行后,如果r是偶数,那么换行后的点左边，一定有另一个点,因此将此点向上或下移动,构成梅花桩
```cpp
#include <iostream>
using namespace std;
long long t,n,x,y,r,m,a,b;
int main(){
	int i,j,k;
	cin>>t;
	while(t--){
		cin>>n>>x>>y>>r>>m;
		a=1;b=1;//坐标从（1,1）开始
		for(i=2;i<=m;i++){
			a+=x;//连续队列时x为1,坐标加1；梅花桩时,x为2,坐标需要加2,避免连续
			if(a>r){//超出一行
				a-=r;
				b++;
				if(x==2&&r%2==0)//r为偶数时梅花桩的特判
					if(a%2==0)
						a--;
					else
						a++;
			}
		}
		if(y==1)//如果按行排列,只需a,b换个位置
			swap(a,b);
		cout<<a<<" "<<b<<" ";
	}
	return 0;
}
```


---

## 作者：Kiloio (赞：1)

###  读完题后，我们明白需要判断$2$个情况：
1. **连续队形**

2. **梅花桩队形**   
  
### 先看梅花桩：  
- 因为其要中间**空一格**，所以横坐标$+2$。

- 再判断是否**超出边界**（即$r$），超出就放到下一行。

- 当$r$%$2$==$0$时（$r$为偶数），这个点的**左边**一定有一个点。  
把它**上移或下移**一个单位，就能满足梅花桩。  
  
这里主要是**按列**排，如果**按行**，将答案**横纵编号交换**即可。  
### 再看连续： 
- 也是分行、列排。  

- 因为其要中间**不空格**，所以横坐标$+1$  

- 其余方法基本相同。  
  
代码：  
```
#include <bits/stdc++.h>
using namespace std;
long long k,num,kl,op,x,y,ans_x,ans_y;
int main(){
	cin>>k;
	for(int i=1; i<=k; i++){
		cin>>num>>kl>>op>>x>>y;
		ans_x=ans_y=1;
		for(int i=2; i<=y; i++){
			ans_x+=kl;
			if(ans_x>x){
				ans_x-=x;
				ans_y++;
				if(kl==2 && x%2==0){
					if(ans_x%2==0){
						ans_x--;
					}
					else{
						ans_x++;
					}
				}			
			}
		}
		if(op==1){
			cout<<ans_y<<" "<<ans_x<<" ";
		}
		else{
			cout<<ans_x<<" "<<ans_y<<" ";
		}
	}
	return 0;
}
```


---

## 作者：vеctorwyx (赞：1)

### 大模拟

1. 连续队很简单，只需要记得要$m-1$;

1. 梅花桩就是把编号变成$2m-1$，然后照着连续队做；

	但是要注意当$r$为偶数的时候直接处理会导致横（纵）坐标少算1，应该记得加回来；
   
code（标准版）：

	#include<bits/stdc++.h>
    #define main signed main
    using namespace std;
    int t,n,r,x,y,m,x1;
    int z1;
    main()
    {
        cin>>t;
        while(t--)
        {
            cin>>n>>x>>y>>r>>m;
            if(x==1)
            {
                if(y==2)
                {
                    z1=(m-1)/r+1;
                    x1=m%r;
                    if(x1==0)
                    x1=r;
                }
                else
                {
                    z1=m%r;
                    x1=(m-1)/r+1;
                    if(z1==0)
                    z1=r;
                }
            }
            else
            {
                if(y==2)
                {
                    z1=(m*2-2)/r+1;
                    x1=(m*2-1)%r;
                    if(x1==0)
                    x1=r;
                    if(!(r&1)&&!(z1&1))
                    x1++;
                }
                else
                {
                    x1=(m*2-2)/r+1;
                    z1=(m*2-1)%r;
                    if(z1==0)
                    z1=r;
                    if(!(r&1)&&!(x1&1))
                    z1++;
                }
            }
            cout<<x1<<" "<<z1<<" ";
        }
    }
附：code（压行版）：

	#include<bits/stdc++.h>
    using namespace std;
    int t,n,r,x,y,m,x1,z1;
    int main()
    {
        cin>>t;
        while(t--)
        {
            cin>>n>>x>>y>>r>>m;
            x==1?(z1=(m-1)/r+1,x1=m%r,x1==0?x1=r:0):(z1=(m*2-2)/r+1,x1=(m*2-1)%r,x1==0?x1=r:0,(!(r&1)&&!(z1&1))?x1++:0);
            y==1?cout<<z1<<" "<<x1<<" ":cout<<x1<<" "<<z1<<" ";
        }
    }
小声bb：[P2355 团体操队形](https://www.luogu.com.cn/problem/P2355)真的不是重题吗？

---

## 作者：UnyieldingTrilobite (赞：1)

上手鉴定大膜你。

这题看似是一道题，其实是两个小题：连续和梅花。

连续很好处理：
```cpp
if(x==1){
	if(y==1)printf("%d %d ",(m-1)/r+1,(m-1)%r+1);
	else printf("%d %d ",(m-1)%r+1,(m-1)/r+1);
}
```
（谔，小学数学。）

**难点在于梅花桩。**

先考虑r为奇数的情况（好处理）。

先考虑按行排的情况（列同理）。

**奇数行和下方的偶数行合在一起，变成了全部隔一个站一个。**

然后假想去掉空格，就是连续队形。

有空格怎么办？

**不就是隔一个站一个吗，行列数都乘二减一即可。**

（谔，又是小学数学。）

然后要是发现列数超过r就说明该换行了，列数减去r行数加上一即可。

最后康康偶数有什么不同。

**变成了全部隔一个站一个。**<-这句话。

奇数行末尾和偶数行开头现在空的是**两个格子**。

那好办，要是算出来列数超过r说明该换行了，说明空格有影响了。

由于空格，把列数向右（这么想吧）偏移一位，也就是把r加上一就可以了，不妨思考思考为什么。

好了以上合集就是代码了：

C/C++:
```c
#include<stdio.h>
int t,n,x,y,r,m; 
int main(){
	for(scanf("%d",&t);t;--t){
		scanf("%d%d%d%d%d",&n,&x,&y,&r,&m);
		if(x==1){
			if(y==1)printf("%d %d ",(m-1)/r+1,(m-1)%r+1);
			else printf("%d %d ",(m-1)%r+1,(m-1)/r+1);
		}else{
			int w=((m-1)/r<<1|1),k=((m-1)%r<<1|1);
			if(r&1^1&&k>r)++k;
			if(k>r)k-=r,++w;
			if(y==1)printf("%d %d ",w,k);
			else printf("%d %d ",k,w);
		}
	}
    return 0;
}
```
Pascal(~~好了窝知道自己马蜂奇丑~~)：
```pas
var t,n,x,y,r,m,w,k:longint;
begin
    read(t);
    while t>0 do begin
        read(n,x,y,r,m);
        if x=1 then begin
            if y=1 then write((m-1) div r +1,' ',(m-1) mod r +1,' ')
            else write((m-1) mod r +1,' ',(m-1) div r +1,' ');
        end
        else begin
            w:=((m-1) div r)*2+1;
            k:=((m-1) mod r)*2+1;
            if k>r then begin
                if r mod 2=0 then k:=k+1;
                k:=k-r;w:=w+1;
            end;
            if y=1 then write(w,' ',k,' ')
            else write(k,' ',w,' ');
        end;
        t:=t-1;
    end;
end.
```

---

## 作者：Protons (赞：1)

### 题解思路：大模拟，仔细点就好

这道题以一个点需要注意——就是梅花桩队形的奇数排列和偶数排列的规律是略有不同的

奇数排列时，相互交叉排列的两行如果展开成一行的话就是一个 相邻两个数之间有一个空格字 的数列；但是偶数排列时则不然，它的展开在行与行（或列于列）的交际处会空两个格子，所以这里需要注意一下（这就是我评测记录里那一大堆WA的原因了）

以下是源码：
```cpp
//简单粗暴的大模拟
#include<cstdio>
#include<iostream>
using namespace std;
int t,n,x,y,m,r;
void count1(int &hang,int &lie)//处理横竖全满队形
{
    hang=1;
    hang+=m/r;
    lie=m%r;
    if(lie==0)lie=r,hang--;
//  printf("%d %d\n",hang,lie);
}
void count2(int &hang,int &lie)//处理r为奇数的梅花桩队形
{
    hang=1;
    hang+=(m/r)*2;
    if(m%r!=0)
    {
        if((m%r)>((r+1)/2))hang++;
        lie=((m%r)*2-1)%r;
    }
    else
    {
        hang--;
        lie=(r*2-1)%r;
    }
    if(lie==0)lie=r;
//  printf("%d %d\n",hang,lie);
}
void count3(int &hang,int &lie)//处理r为偶数的梅花桩队形
{
    hang=1;
    hang+=(m/r)*2;
    if(m%r!=0)
    {
        if((m%r)>(r/2))
        {
            hang++;
            lie=((m%r)*2)%r;
        }
        else lie=((m%r)*2-1)%r;
    }
    else
    {
        hang--;
        lie=(r*2)%r;
    }
    if(lie==0)lie=r;
}
int main()
{
    scanf("%d",&t);
    for(int i=1;i<=t;i++)
    {
        int hang=0,lie=0;
        scanf("%d%d%d%d%d",&n,&x,&y,&r,&m);
        if(x==1)
        {
            if(y==1)count1(hang,lie);
            else count1(lie,hang);
        }
        else
        {
            if(r&1)
            {
                if(y==1)count2(hang,lie);
                else count2(lie,hang);
            }
            else
            {
                if(y==1)count3(hang,lie);
                else count3(lie,hang);
            }
        }
        printf("%d %d ",hang,lie);
    }
    return 0;
}
```

---

## 作者：Nozebry (赞：1)

我们乍一看并不能发现什么规律，但通过模拟样例可以发现团体操队形，也就是所谓的梅花桩的规律：

1、首先横坐标必须+2

2、然后判断是否超出 $r,$ 即边界；如果超出,换行

3、换行后,如果 $r$ 是偶数,那么变换后的点左边，因为变换后的点左边一定有另一个点,因此将此点向上或下移动,构成梅花桩

**其实不难发现，这道题的填法和奇数阶魔阵很像**

## AC Code:
```pascal
var
	t,n,m,x,y,r,a,b,i,j,k,tt:longint;
begin
	readln(t);
	while t>0 do
	begin
		readln(n,x,y,r,m);
		a:=1;b:=1;dec(t);
		for i:=2 to m do
		begin
			a:=a+x;
			if a>r then
			begin
				a:=a-r;inc(b);
				if (x=2)and(r mod 2=0) then
					if (a mod 2=0) then dec(a)
						else inc(a);
			end;
		end;
		if y=1 then begin tt:=a;a:=b;b:=tt;end;
		write(a,' ',b,' ');
	end;
end.
```

---


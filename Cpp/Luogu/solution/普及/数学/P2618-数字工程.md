# 数字工程

## 题目描述

ACM 实验室开启了一个数字工程项目，希望把正整数 $n$ 通过一些特殊方法变成 $1$。

可采用的方法有：

1. 减去 $1$
2. 除以它的任意一个素因子。 

每操作一次消耗一个单位的能量。

请问把 $n$ 变成 $1$ 最少需要消耗多少能量？


## 说明/提示

$1 \le n \le 10^6$。

## 样例 #1

### 输入

```
1
4```

### 输出

```
0
2```

# 题解

## 作者：Leianha (赞：14)

## DP

根据题目下面的提示&说明，我们就能知道做这个题的大体思路：先求出来每一个数的素数因子，然后就开始DP。

求素数因子的方法就是用类似于欧拉筛的操作，倘若一个数一直都没有被筛到过，那么ta就是一个素数，然后我们就可以用ta来继续筛其它的数，并且我们只用筛ta的倍数，因为只有ta的倍数才含有这个素因子，被筛到的数一定要及时打上标记 ~~不要问我为什么~~那么我们需要开多大的数组来记录素因子呢？其实只用23左右就可以了，因为$2^{20}=1048576>10^6$,所以开23足够。

最后就是DP部分了，只要考虑两种情况，由$i-1$或$i/prime_i$转移过来的，答案取个$min$就好了，还有本题的输入有点坑，具体的解决方案就是这样写就珂以了：
```cpp
while(scanf("%d",&n)!=EOF)printf("%d\n",f[n]);
```
最后献上我~~丑陋~~的代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1000000,M=1000010;
int n;
int yz[M][23],num[N],f[M];
bool vis[M];
void yych()
{
	for(int i=2;i<=N;++i)
	if(!vis[i])
	for(int j=i;j<=N;j+=i)
	vis[j]=1,yz[j][++num[j]]=i;//注意vis 
	
	for(int i=2;i<=N;++i)//DP
	{
		f[i]=f[i-1]+1;
		for(int j=1;j<=num[i];++j)f[i]=min(f[i],f[i/yz[i][j]]+1);
	}
}
int main()
{
	yych();
	while(scanf("%d",&n)!=EOF)printf("%d\n",f[n]);//scanf存在返回值，当不再输入的时候就会返回EOF 
}
```


---

## 作者：Gokix (赞：2)

感觉这个题的题解中大都是边输边 DP/搜索 的，虽然有人解释是数据水的原因，但毕竟这个输入量开到 $10^6$ 都没问题，还是要写的像正解一些。

本题解使用 D P的做法，虽然有人写的更加简单，也更快（筛素数与DP一起），但我觉得我这个方法更便于理解。

------------

首先埃氏筛筛出质数表，其中 $p_i$ 表示 $i$ 是否为质数，$e_i$ 表示第 $i$ 小质数。

然后开始DP：其中 $f_i$ 表示把 $i$ 变成1最少需要消耗的能量。初始化：除 $f_1=1$ 以外 $f_i$ 均为无穷大。 

显然如果 $i$ 是质数，那么 $f_i=1$。如果不是，那就在 $f_{i-1}$ 和 $f_{i/e}$中取最大的。显然 $f_{i-1}$ 可以在每次循环时计算。而有关于求 $i$ 的质因子的 $f$ 可以转换为在 DP 时反复更新因子的倍数。注意这里不同于埃氏筛，并不是只有质数才向它的倍数扩展，所有数都要做这个操作。因为有可能 $f_{i-1}$ 会优于所有的 $f_{i/e}$，而只更新质数就会忽略这种情况。

------------

有了思路，代码就很简单了：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#define lim 1000000
using namespace std;
long long n,p[1010000],e[110000],f[2010000],tot,ans;
int main()
{
	long long i,j,u,v;
	for(i=2;i<=lim;i++)
	{
		if(p[i]==0)
		{
			for(j=i+i;j<=lim;j+=i)
				p[j]=1;
		}
	}
	for(i=2;i<=lim;i++)
	{
		if(p[i]==0)
		{
			tot++;
			e[tot]=i;
		}
	}
	memset(f,0x3f,sizeof(f));
	f[1]=0;
	for(i=2;i<=lim;i++)
	{
		if(p[i]==0)//i是质数
			f[i]=1;
		else
			f[i]=min(f[i],f[i-1]+1);
		for(j=1;j<=tot;j++)//向倍数扩展
		{
			if(i*e[j]<=lim)
				f[i*e[j]]=min(f[i*e[j]],f[i]+1);
			else//记得超过lim之后就不用算了，不然时间妥妥地炸
				break;
		}
	}
	while(cin>>n)
	{
		cout<<f[n]<<endl;
	}
	return 0;
}
```


---

## 作者：XZYQvQ (赞：1)

跑一遍素数筛，筛出每个数字的质因数，存在一个数组里。

然后根据题目底下的递推式就能ac了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[1000005],d[1000005][25],dc[1000005];
bool book[1000005];
int main()
{
    for(int i=2;i<=1000000;i++)
        if(!book[i])
            for(int j=i;j<=1000000;j+=i)
                book[j]=1,d[j][dc[j]++]=i;
    for(int i=2;i<=1000000;i++)
    {
        f[i]=f[i-1]+1;
        for(int j=0;j<dc[i];j++)f[i]=min(f[i],f[i/d[i][j]]+1);
    }
    while(~scanf("%d",&n))printf("%d\n",f[n]);
    return 0;
}
```

---

## 作者：火柴神 (赞：1)

此题题目的动归方程应理解为

if(pr[j]==true) dp[i]=min(dp[i],dp[i/j]+1);

if(pr[i/j]==true) dp[i]=min(dp[i],dp[j]+1);

即查两边两个值

压时间需要一些技巧(不过每组数据过少直接计算更快)


代码如下：









```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
using namespace std;
bool pr[3000000];
int p[2000000];
int cnt=0;
int dp[2000000];
void prpr(){
    memset(pr,true,sizeof(pr));
    pr[0]=false;
    pr[1]=false;
    for(int i=2;i<1001000;i++){
        if(pr[i]){
            for(int j=i+i;j<1001000;j+=i){
                pr[j]=false;
            }
        }
    }
    for(int i=2;i<1100;i++){
        if(pr[i]==true){
            p[cnt]=i;
            cnt++;
        }
    }
}
void work(){
    dp[1]=0;
    for(int i=2;i<=1001000;i++){
        if(pr[i]==true)dp[i]=1;
        else{
            dp[i]=dp[i-1]+1;
            int x=i;
            for(int j=0;j<cnt&&p[j]<=1010;j++){    
                if(i%p[j]==0){
                    dp[i]=min(dp[i],dp[i/p[j]]+1);
                    while(x%p[j]==0)x=x/p[j];
                    if(x==1)break;
                }
            }
            if(x>1){
                dp[i]=min(dp[i],dp[i/x]+1);
            }
        }
    }
}
int main(){
    prpr();
    work();
    int n;
    while(scanf("%d",&n)!=EOF){
        printf("%d\n",dp[n]);
    }
    return 0;
}

```

---

## 作者：_jimmywang_ (赞：0)

没事颓颓水数学题~

首先明显$dp$。

设$dp[i]$为使数$i$变为$1$的最少步骤。

于是就可以退出转移方程：

$$dp[i*j]=min(dp[i*j],dp[i]+1)(j∈prime)$$
$$dp[i+1]=min(dp[i+1],dp[i]+1)$$

鉴于此题数据范围真的太小，暴力筛质数都能过。

在筛的时候顺便把$dp[i]$初始化一下。质数为$1$,合数为$i-1$,$1$为$0$

然后，就……做完了？

一跑，呀，$A$了!

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
inline ll r() {
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
#define d r()
ll dp[1000010];
ll pr[100010];
bool ip(ll x){
	if(x==1)return 0;
	if(x==2||x==3)return 1;
	if(x%6!=1&&x%6!=5)return 0;
	for(ll i=5;i*i<=x;i+=6)
		if(x%i==0||x%(i+2)==0)return 0;
	return 1;
}
void work(){
	for(int i=2;i<=1000000;i++){dp[i]=i-1;if(ip(i))pr[++pr[0]]=i,dp[i]=1;}
	f(i,2,1000000){
		for(int j=1;pr[j]*i<=1000000&&j<=pr[0];j++)dp[i*pr[j]]=min(dp[i*pr[j]],dp[i]+1);
		dp[i+1]=min(dp[i+1],dp[i]+1);
	}
}
int main(){
	work();
	ll a;
	while(~scanf("%lld",&a))printf("%lld\n",dp[a]);
	return 0;
}
```


---

## 作者：litble (赞：0)

其实直接筛素数，然后储存每个数的素因子，最后来dp就可以了.....

介绍一些教训：

1.这个质因子可能大于sqrt(i),所以在筛的时候要注意一下。

2.素数有一个素数因子就是它本身，所以筛的时候也要注意。

因此如果直接套素数筛模板就会WA（血的教训....）

剩下的dp就不难了。

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
int f[1000005],pri[1000005],dic[1000005][25];
bool is[1000005];//dic:预存质数因子
int tot,maxn=1000000,n;
int main()
{
    int i,j,k,sz;
    is[1]=1;
    for(i=2;i<=maxn;i++)
        if(!is[i]){
            pri[++tot]=i;
            for(j=i;j<=maxn;j+=i){is[j]=1;dic[j][++dic[j][0]]=i;}
        }
    for(i=2;i<=maxn;i++){
        f[i]=f[i-1]+1;
        for(j=1;j<=dic[i][0];j++)f[i]=min(f[i],f[i/dic[i][j]]+1);
    }
    while(scanf("%d",&n)==1)printf("%d\n",f[n]);
    return 0;
}
//素数因子可能很大！！！！不要因为题目好像很“水”就掉以轻心。
```

---


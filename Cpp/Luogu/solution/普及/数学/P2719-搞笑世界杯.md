# 搞笑世界杯

## 题目背景

很久很久以后，一次世界杯。


## 题目描述

随着世界杯小组赛的结束，法国，阿根廷等世界强队都纷纷被淘汰，让人心痛不已。 于是有人组织了一场搞笑世界杯，将这些被淘汰的强队重新组织起来和世界杯一同比赛。你和你的朋友欣然去购买球票。不过搞笑世界杯的球票出售方式也很特别，它们只准备了两种球票。

- A 类票——免费球票 
- B 类票——双倍价钱球票。

购买时由工作人员通过掷硬币决定，投到正面的买 A 类票， 反面的买 B 类票。主办方总是准备了同样多的 A 类票和 B 类票。你和你的朋友十分幸运的排到了某场精彩比赛的最后两个位置。

这时工作人员开始通过硬币售票。不过更为幸运的是当工作人员到你们面前时他发现已无需再掷硬币了，因为剩下的这两张票全是免费票。

你和你的朋友在欣喜之余，想计算一下排在队尾的两个人同时拿到一种票的概率是多少(包括同时拿 A 类票或 B 类票) 假设工作人员准备了 $2n$ 张球票，其中 $n$ 张 A 类票，$n$ 张 B 类票，并且排在队伍中的人每人必须且只能买一张球票(不管掷到的是该买 A 还是该买 B)。

## 说明/提示

## 数据规模与约定

对全部的测试点，保证 $1 \leq n \leq 1250$。

## 样例 #1

### 输入

```
256```

### 输出

```
0.9500```

# 题解

## 作者：flyfree (赞：45)

本蒟蒻拜读了各位dalao的题解以后，感觉自己严重智商不足。。。

大概是我太弱了，怎么也想不明白为什么卖出i张A、0张B或者0张A、i张B时最后两人买到相同票的概率为100%

于是我脑洞打开，想出了一种奇特~~鬼畜~~的思路——

重新定义f数组：f[i][j]表示售票人员手中还剩i张A、j张B时最后两人买到相同票的概率，答案就是f[n][n]。

这样，f[i][0]=f[0][i]=1就很好理解啦，既然售票人员手中只有一种票，那么最后两人100%会买到同一种票啦。

至于转移方程嘛。。。打开你的脑洞——~~前方高能~~

想象一下，比赛举办方的后台人员a正在把票一张一张地给售票人员b,直到b手中有n张A票，n张B票。

由于a给b的最后一张票有可能是A，有可能是B，概率各是50%，所以转移方程：

f[i][j]=f[i-1][j]*0.5+f[i][j-1]*0.5;

至于程序嘛。。。和各位dalao的一样啦~我就不放了。

对于这同样的代码，我仅仅是提供一种不同的理解思路，希望对大家有帮助~~

---

## 作者：zhongcy (赞：34)

[Problem](https://www.luogu.com.cn/problem/P2719)


### Solution1

------------
看到题目，很容易想到用 dp。

设 $f(i,j)$ 表示已经售出 $i$ 张 A，$j$ 张 B 后两人买到票相同的概率

易得状态转移方程：$f(i,j)=\dfrac{f(i-1,j)+f(i,j-1)}{2}$


注意初始状态：$ \forall 1 \le i \le n , f(i,0)=f(0,i)=1 $  即全部都是一种票时拿到一样的票的概率是 $ 100 \% $。

### Code1

------------

时间复杂度 $ \Theta(n^2) $。

```cpp

/*dp*/

#include<bits/stdc++.h>
using namespace std; 
int n;
double f[1251][1251];
int main()
{
	cin>>n;
	n/=2; //因为题目给出的是2n
	for(int i=2;i<=n;i++)
       f[i][0]=1,f[0][i]=1; //初始化
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=n;j++)
    	 	f[i][j]=f[i-1][j]/2+f[i][j-1]/2;  //动态规划
    printf("%.4lf",f[n][n]);
	return 0;
}
```


### Solution2

------------

这题其实还有排列组合的方法。

最后两张不同的概率 $ P $ 可以用前 $ 2n-2 $ 张中有 $ n-1 $ 张 A 和 $ n-1 $ 张 B 。

$$ P = C^{n-1}_{2n-2} \cdot (\dfrac{1}{2})^{2n-2} = \dfrac{(2n-2)!}{4^{n-1}(n-1)!(n-1)!} = \dfrac{(2n-2) \times (2n-3) \times \dots \times n}{(4\times{(n-1)}) \times (4\times{(n-2)}) \times \dots \times (4\times{1})}$$

最终答案为 $ 1-P $。

### Code2


------------

直接计算即可，时间复杂度 $ \Theta (n)$。
```cpp
/*排列组合*/

#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;cin>>n;n>>=1;//因为题目给出的是2n
    double ans=1.0;//即上述的P
    for(int i=1;i<n;i++)
        ans=ans*(i+n-1)/(i<<2);//暴力计算
    printf("%.4lf",1-ans);
    return 0;
}
```




---

## 作者：Christopher_Yan (赞：27)

洛谷 2719 搞笑世界杯

洛谷原题链接



这道难度只有普及-的题目却花了我一个多小时才搞出来。但做出来之后就会发现：其实这题确实挺水。。。

解题思路：

首先开二维数组 dp [ i ] [ j ] . 代表已售 i 张 A , j 张 B 时后两人买到的票相同的概率。

很显然，dp [ 1 ] [ 0 ] 与 dp [ 0 ] [ 1 ] 的初始值应该为 1 ，因为当只有一张票被售出时，我们可以默认后两个人买的票类型相同，所以买到票相同的概率位 100% .

然后开始推状态转移方程：dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ) * 0.5 。

每一个状态 dp [ i ] [ j ] 都是由 dp [ i - 1 ] [ j ] 和 dp [ i ] [ j - 1 ] 得到的，因为每次卖票要么会卖 A ，要么会卖 B ，根据加法计数原理加起来就好了，但是由于两种情况是由抛硬币来决定的，所以发生的几率都会 50% 。

于是乎，dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ) * 0.5 。

代码就简单了，注意开始的初始化：

 

```
#include<cstdio>
#include<iostream>
const int M=1500;
int n;
double f[M][M];
int main()
{
    scanf("%d",&n);
        n>>=1;
    for (int i=2;i<=n;i++)
        f[i][0]=1,f[0][i]=1; 
    for (int i=1;i<=n;i++)
        for (int k=1;k<=n;k++)
            f[i][k]=f[i-1][k]*0.5+f[i][k-1]*0.5;
    printf("%.4lf",f[n][n]);
    return 0;
}
```

---

## 作者：love_luke (赞：15)

想纠正一下有篇题解里讲述的错误。

“很显然，dp [ 1 ] [ 0 ] 与 dp [ 0 ] [ 1 ] 的初始值应该为 1 ，因为当只有一张票被售出时，我们可以默认后两个人买的票类型相同，所以买到票相同的概率位 100% .”

同样很显然，我认为这句话是错的。数组代表已售 i 张 A , j 张 B 时后两人买到的票相同的概率，而当只售出一张票时，连两个人都没有，怎么能默认呢？反例：一共只有两张票，那肯定是一张A，一张B，两人拿到相同票的几率为0。

因此，正确的初始化应是这样的：
```cpp
f[i][0]=f[0][i]=1;
```

其中i>=2。

初始化完后就很简单了，每次买到票都会各有一半的几率使最后两人依旧买到相同票或变成不同，而我们记录的是相同的几率，状态转移方程为：
```cpp
f[i][j]=(f[i-1][j]+f[i][j-1])/2;
```
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
double f[1251][1251];
int main()
{
    int n,i,j;
    cin>>n;
    n=n/2;
    for (i=2;i<=n;++i)
    {
        f[i][0]=1;
        f[0][i]=1;
    }
    for (i=1;i<=n;++i)
    for (j=1;j<=n;++j)
    {
        f[i][j]=(f[i-1][j]+f[i][j-1])/2;
    }
    printf("%.4lf",f[n][n]);
    return 0;
}
```


---

## 作者：山水一程_ (赞：15)

其实懂了之后很简单，但是刚开始真的很难想.。
d[a][b]表示剩a张A类票和b张B类票时，最后两张票相同的概率

那么此时的排队的第一个人只有两种选择
拿A类票或者B类票

抛硬币得到的可能性当然是二分之一，所以说d[i-1][j]（当前第一人拿了A类票）和d[i][j-1]（当前第一人拿了B类票）各占二分之一

这样的话代码就很简单了。。。。
```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
double d[1500][1500];
int main()
{
	int n,i,j;
	scanf("%d",&n);
	n/=2;
	for (i=2;i<=n;i++)
	{
		d[i][0]=d[0][i]=1;
	}
	for (i=1;i<=n;i++)
	{
		for (j=1;j<=n;j++)
		{
			d[i][j]=(d[i-1][j]+d[i][j-1])*0.5;
		}
	}
	printf ("%.4lf",d[n][n]);
	return 0;
}
```
## 感谢各位的观看

---

## 作者：_Wolverine_ (赞：7)

设 $f[i][j]$ 为还剩$i$张A类免费票，$j$张B类双倍价钱票时，最后两个人拿到两张同样的票的几率

目前在队头买票的人，有两种可能：买到A类票或者买到B类票。队首的人买到一张A类票后，最后两个人拿到两张同样的票的几率为$f[i-1][j]$；同理，队首的人买到一张A类票后，拿到同样票的几率为$f[i][j-1]$。又因为买到两种票的几率都是%50（不考虑买完了的情况），由此得出动态转移方程：

$f[i][j]=\frac{f[i-1][j]+f[i][j-1]}{2}$

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int Maxn=1266;
int n;
double f[Maxn][Maxn];
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=='-'?w=-1:w=1,ch=getchar();
	while(ch>='0' && ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	n=read()>>1;
	for(int i=2;i<=n;++i)//如果只剩一种票了，最后两个人拿到两张同样的票的几率就为1
	f[i][0]=f[0][i]=1.0;
	for(int i=1;i<=n;++i)
	for(int j=1;j<=n;++j)
	f[i][j]=(f[i-1][j]+f[i][j-1])/2.0;
	printf("%.4lf\n",f[n][n]);
	return 0;
}
```

---

## 作者：Binary_Search_Tree (赞：5)

这题一看就知道是DP  ~~但我和楼下大佬的状态转移方程不太一样~~

设f[i][j]表示买i张A类票和j张B类票的概率

则最后一个人可能买A类票，可能买B类票

**可得状态转移方程：f[i][j]=0.5*(f[i-1][j]+f[i][j-1])**

但有一些特殊情况：

当一个人买票时发现A类票或B类票用完时，那最后一个人**根本不用掷硬币**

那么最后答案是什么呢？

若最后两个人买A类票，则概率为f[n-2][n]

同理，若最后两个人买B类票，则概率为f[n-2][n]

所以输出f[n-2][n]+f[n][n-2]

做完了吗？

**注意：本题有坑 n可能为1或0，则我的代码会RE。所以程序要加特判！**

代码如下
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
using namespace std;
const int M=1555;
int n;double f[M][M];
int main(){
	scanf("%d",&n);n>>=1;
	if (n==1||n==0){printf("0.0000");return 0;}
	f[1][0]=f[0][1]=0.5;
	for (int i=2;i<=n;i++) f[i][0]=f[0][i]=0.5*f[0][i-1];
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++){
			if (i==n) f[i][j]+=f[i][j-1];
			else f[i][j]+=f[i][j-1]/2;
			if (j==n) f[i][j]+=f[i-1][j];
			else f[i][j]+=f[i-1][j]/2;
		}
	printf("%.4lf",f[n][n-2]+f[n-2][n]);
	return 0;
}
```

---

## 作者：doby (赞：4)

较简单类型的动规，形似过河卒既视感……

因为是抛硬币，前面的人免费和双倍的情况各占一半

状态转移方程：f[i][j]=f[i-1][j]\*0.5+f[i][j-1]\*0.5;

然后要设定边界……

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n;
double f[1259][1259];
int main()
{
    cin>>n;n=n/2;//输入的是2n，记得除以2
    for(int i=2;i<=n;i++){f[i][0]=1,f[0][i]=1;}//边界设置
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            f[i][j]=f[i-1][j]*0.5+f[i][j-1]*0.5;//状态转移
        }
    }
    printf("%.4lf",f[n][n]);//留下四位
}
```

---

## 作者：happybob (赞：2)

传送门：[P2719 搞笑世界杯](https://www.luogu.com.cn/problem/P2719)

这道题赤裸裸的动态规划，我们设 ${dp_i}_j$ 表示 `i 张 A 类和 j 张 B 类的可能性`。可以用 ${dp_n}_n$ 表示答案。初始值：${dp_i}_0 = {dp_0}_i = 1 (i = 2, 3, 4, 5, ……,n)$。转移方程：${dp_i}_j=({dp_{i-1}}_j+{dp_i}_{j-1}) \times 0.5$，因为当前这张票可以是从 `A` 类转移也可以是 `B` 类，抛硬币正反都是 $50\%$ 的概率。

代码：

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

const int N = 2e3 + 5;
double f[N][N]; // f[i][j] 表示 i 张 A 类和 j 张 B 类的可能性

int main()
{
	int n;
	cin >> n;
	n >>= 1;
	for (int i = 2; i <= n; i++)
	{
		f[i][0] = f[0][i] = 1;
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			f[i][j] = (f[i - 1][j] + f[i][j - 1]) * 0.5;
		}
	}
	cout << fixed << setprecision(4) << f[n][n] << endl;
	return 0;
}
```


---

## 作者：在下互质数 (赞：2)

>### 做完之后发现我的思路竟然和$dalao$们一样
>#### 那我也讲一下我的思路吧：这是一道概率$dp$题
>#### $pd[i][j]$还剩$i$张$a$类票，$j$张$b$类票，最后两张相同的概率
>#### 好吧，也没什么好说的了，上代码吧
```cpp
# include <bits/stdc++.h>
using namespace std ;
const int maxn = 2600 ;
double pd[maxn][maxn];
int main()
{
    int n ;
    memset (pd , 0 , sizeof (pd)) ;
    scanf ("%d" , &n) ;
    n >>= 1 ;
    for (int i = 2 ; i <= n ; i ++)    
        pd[0][i] = 1 , pd[i][0] = 1 ;
    for (int i = 1 ; i <= n ; i ++)
        for (int j = 1 ; j <= n ; j ++)
            pd[i][j] = pd[i - 1][j] * 0.5 + pd[i][j - 1] * 0.5 ;
    printf ("%.4f" , pd[n][n]) ;
    return 0 ;
}
```


---

## 作者：林家三少 (赞：2)

[$\color{black}\text{题目传送门}$](https://www.luogu.org/problem/P2719)

我是用二维来解决这道题的

	二维数组ans[i][j]，代表已售i张A,j张B时后两人买到的票相同的概率。
    然后就推状态转移方程了：ans[i][j]=(ans[i-1][j]+ans[i][j-1])*0.5;
    (好像楼上楼下几位dalao都是这样的哦...
    
所以我也没什么要讲的了，上程序：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>  //打好文件头
using namespace std;
int n;  //定好球票数
double ans[1250+100][1250+100];  //用double来定义这个二维数组
int main()  //开始主程序
{
    scanf("%d",&n);  //输入球票数
    n=(n>>1);  //这一步是少不了的！
    for(int i=2;i<=n;i++)  //注意这里要从2开始循环
        ans[i][0]=ans[0][i]=1;  //赋初值
    for(int i=1;i<=n;i++)  //开始处理
        for(int j=1;j<=n;j++)  //进入双重循环
		ans[i][j]=(ans[i-1][j]+ans[i][j-1])*0.5;  //推状态转移方程
    printf("%.4lf",ans[n][n]);  //最后输出要包括四位小数
    return 0;  //完美结束
}
```


---


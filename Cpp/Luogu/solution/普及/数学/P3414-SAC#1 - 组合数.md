# SAC#1 - 组合数

## 题目描述


今天小明学习了组合数，现在他很想知道 $\sum \rm{C}$$_{n}^{i}$ 是多少。其中 $\rm{C}$ 是组合数（即 $\rm{C}$$_{n}^{i}$ 表示 $n$ 个物品无顺序选取 $i$ 个的方案数），$i$ 取从 $0$ 到 $n$ 的所有偶数。

由于答案可能很大，请输出答案对 $6662333$ 的余数。

## 说明/提示

对于 $20\%$ 的数据，$n \le 20$；

对于 $50\%$ 的数据，$n \le 10^{3}$；

对于 $100\%$ 的数据，$n \le 10^{18}$。

## 样例 #1

### 输入

```
3```

### 输出

```
4```

# 题解

## 作者：Salty_Fish787 (赞：70)

$Solution:$
- 题意：  求 
$$\sum_{i\in[0,n],2|i}C_n^i$$
的值。答案对$6662333$取模，且$n\leq 10^{18}$。
- 前置芝士：二项式定理
$$(a+b)^n=\sum_{i=0}^n C_n^ia^ib^{n-i}$$
将$a=1,b=1$代入：
$$(1+1)^n=2^n=\sum_{i=0}^n C_n^i$$
即
$$C_n^0+C_n^1+C_n^2+...+C_n^n=2^n(1)$$
将$a=1,b=-1$代入：
$$(1-1)^n=0=\sum_{i=0}^n (-1)^iC_n^i$$
即
$$C_n^0-C_n^1+C_n^2+...+(-1)^nC_n^n=0(2)$$
- 分析：由$(1)$式$+(2)$式除以$2$得：
$$C_n^0+C_n^2+C_n^4+...+C_n^{[\frac{n}{2}]\times 2}=\frac{2^n+0}{2}=2^{n-1}$$
其中$[x]$表示$x$的整数部分。当$x$为奇数时，$[\frac{x}{2}]\times 2=x-1$；当$x$为偶数时，$[\frac{x}{2}]\times 2=x$。
即
$$\sum_{i\in[0,n],2|i}C_n^i=2^{n-1}$$
综上所述，直接输出$2^{n-1}mod6662333$的值即可。用快速幂维护。
- $code:$
![QwQ](https://cdn.luogu.com.cn/upload/pic/73604.png)

---

## 作者：NaVi_Awson (赞：31)

博客也有详解，欢迎来踩：[菜鸡NaVi\_Awson的博客](http://www.cnblogs.com/NaVi-Awson/p/7658509.html)

1、![](http://images2017.cnblogs.com/blog/1207671/201710/1207671-20171012221145652-1332966513.png)

2、![](http://images2017.cnblogs.com/blog/1207671/201710/1207671-20171012221151668-1340951255.png)

3、![](http://images2017.cnblogs.com/blog/1207671/201710/1207671-20171012221200027-1634410403.png)

证明：由![](http://images2017.cnblogs.com/blog/1207671/201710/1207671-20171012221206699-482636572.png)

当$a = b = 1$时，代入二项式定理可证明$1$式；

当$a = -1$，$b = 1$时代入二项式定理可证明$2$式；代入$a = 1$，$b = -1$可得到另一个意义相同的式子；

$(1式+2式) \over 2$可证明$3$式。


```cpp
//It is made by Awson on 2017.10.12
#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <cmath>
#include <stack>
#include <queue>
#include <vector>
#include <string>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define LL long long
#define Min(a, b) ((a) < (b) ? (a) : (b))
#define Max(a, b) ((a) > (b) ? (a) : (b))
#define sqr(x) ((x)*(x))
using namespace std;
const int MOD = 6662333;
int quick_pow(int a, LL b) {
    int sum = 1;
    while (b) {
        if (b&1) sum = (LL)sum*a%MOD;
        b >>= 1;
        a = (LL)a*a%MOD;
    }
    return sum;
}
void work() {
    LL n;
    scanf("%lld", &n);
    printf("%d\n", quick_pow(2, n-1));    
}
int main() {
    work();
    return 0;
}
```

---

## 作者：MY（一名蒟蒻） (赞：30)

**组合数知识就不多讲了，因为作者是初一萌新，对组合数也很懵懂。**

**这题是快速幂求2的n-1次方，因为i取0到n所有偶数（组合数知识）**，试问谁不知道用快速幂（~~好吧在经历**血的教训**前（看下面）窝也不知道~~）。

[血的教训](https://cdn.luogu.com.cn/upload/image_hosting/pwqy5z8b.png)
#### 快速幂使O(n)的复杂度变为O(log n)，快了很多。
---

### 快速幂的思想：
以求$2^4$为例，$2^4=2^2*2^2$,以此类推，逐步分解。

但有人要问了，指数是**奇数**的时候**怎么办办**呢？

例如$2^5$,我们可以把它分解为$2*2^4$,从而将其转化为刚才的求$2^4$。

### 以此类推。 

---
本蒟蒻用了**递归**实现快速幂，如果您看了作者详（xuan）细（xue）的讲解后还是不懂，可以[看这里](https://blog.csdn.net/Harington/article/details/87602682)，代码中有详细注释。

### 代码
```cpp
#include <cstdio> 
long long ans=2,n;
const int M=6662333;
typedef long long ll;//懒人用
ll FP(ll m)//FP:fast power（快速幂）
{
	if(m == 0) return 1;//任何数的0次方都是1
	if(m%2 == 1) return 2*FP(m-1)%M;//指数是奇数的情况
    	//指数是偶数的情况
	ll num=FP(m/2)%M;//使代码更简洁
	return (num%M)*(num%M)%M;
}
int main()
{
	//读入输出不再多说
	scanf("%lld",&n);
	printf("%lld",FP(n-1)%M);
	return 0;
}
```
#### 作者NOI online爆0了，求安慰（赞），管理员大大就让他过了吧！ 

---

## 作者：子谦。 (赞：17)

这道题提交了很多次，本来不想用**快速幂**，结果发现以我目前的知识储量不得不用，而且用了**快速幂**还是**五十分**，可能是我的快速幂比较垃圾吧      擦汗

于是乎，我就用了**记忆化**，才0msAC，下面给大家分享下我的方法

题目要求求出C（n，0）到C（n，n）的和，这就要用到**二项式定理**了，没听说过也不要紧，刚做的时候我也忘了什么是**二项式定理**了，查了一下，豁然开朗，个人比较推崇360百科上的讲解，附上[链接](https://baike.so.com/doc/5409658-5647689.html) 其实就是杨辉三角，第n层的总和等于2的（n-1）次方（PS：杨辉三角从第0层开始）

##下面就附上程序吧（个人建议自己写，不看我的程序）

```cpp
#include<iostream>
#include<map>
using namespace std;
map<long long,bool>a;//记忆化用的，用来存是否搜到过
map<long long,long long>b;//记忆化用的，用来存数据
const int m=6662333;
long long n,p;
long long mi(long long d,long long c){//d表示底数，c表示次数
    if(c==1)return d%m;
    if(c==0)return 1;
    if(a[c])return b[c];//如果搜到过，那就返回存储的数据
    a[c]=1;//没有的话这次搜到了，a变为1
    b[c]=((mi(d,c/2)%m)*(mi(d,c-c/2)%m))%m;//存储数据
    return b[c];
}
int main(){
    cin>>n;
    n--;
    p=mi(2,n);
    p%=m;
    cout<<p;
    return 0;
}
```
#请勿抄袭，感谢阅览


---

## 作者：shzr (赞：14)

首先，C(n,i)是可以递推求解的，但是数据范围非常大就会TLE 或 MLE，所以考虑一下其他做法。

因为C(n,i)中的i可以取任意偶数，先放宽一下条件认为i为任意数，这样就是从n个数中随便取数，取多少都可以。可以转换一下，【人取数】->【让数决定自己是否被取到】，则每个数有2种情况，即  ans=2^n;
        
接下来还有i为偶数的限制条件，很多题解里提到因为是偶数所以答案/2，但是严格证明还要用到数学，这句话也不算直观，所以我想了一种比较好理解的证明过程：

当n-1个数已经确定是否被选时，第n个数的取法也就固定了（因为要取偶数个），可以认为最后一个数没有自主选择的权利，可以自由选择的数共有（n-1)个，即 ans=2^（n-1）；
        最后再来一个快速幂就可以了。


  ```cpp
# include <cstdio>
# include <iostream>

using namespace std;

int main()
{
	long long n;
	long long a=2,s=1;
	scanf("%lld",&n);
	n--;
	while (n)
	{
		if(n&1) s=s*a%6662333;
		a=a*a%6662333;
		n=n>>1;
	}
	printf("%lld",s%6662333);
	return 0;
}
```

---

## 作者：hsfzLZH1 (赞：7)

看了看以前各位大佬的方法，有用快速幂的，有用记忆化搜索的（然而我这个蒟蒻连记忆化搜索是什么都不知道），我用了数论中的一些知识，可以把时间复杂度控制在O(log2 6662332)

首先，很容易看得出来，题目是要求2^(n-1)（此处^做取幂之意，下同）

容易求得，2^6662332 ≡1 (mod 6662333) （也就是说6662332是2 mod 6662333的最小正周期）

证明：我们都知道费马小定理（不知道的同学可以参考以下网址 [费马小定理](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin) ）

### (a,p)=1时，a^(p-1) ≡ 1 (mod p) 

此例中，易证6662333是质数，得证

所以 2^6662332 ≡ 2^(6662332+k) (mod 6662333)

再加上快速幂取模

利用这个性质，不难得出以下代码：

```cpp
#include<cstdio>
using namespace std;
const int mod=6662333;
inline long long ksm(long long a,long long n)
{
    long long ans=1;
    a%=mod;
    while(n)
    {
        if(n&1)ans*=a,ans%=mod;
        n=(n>>1);
        a*=a;a%=mod;
    }
    return ans;
}
int main()
{
    long long n;scanf("%lld",&n);
    printf("%lld\n",ksm(2,(n-1)%6662332));
    return 0;
} 
```
时间复杂度：ksm的时间复杂度是O(log2 n)，所以以上代码的时间复杂度是O(log2 6662332)

附：语文不好，如果表达有什么问题，请见谅！！


---

## 作者：yyy14159 (赞：5)

从n的元素中选零个，选一个，选两个，选三个...选n个的方案数和，其实就是n个元素中取任意多个元素的方案数，那对于每一个元素，都有取或不取两种情况，所以方案数最终为2^n个，用快速幂就好啦。code：

    
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=6662333;
long long n;
long long two(long long x)
{
    long long ans=1,a=2;
    while(x>0)
    {
        if(x&1) ans=(ans*a)%mod;
        a=(a*a)%mod;
        x>>=1;
    }
    return ans;
}
int main()
{
    cin>>n;
    cout<<two(n-1);
    return 0; 
}
```

---

## 作者：れもんじゆん (赞：4)

这道题就是一道裸的快速幂加点数学小知识

首先是快速幂的写法，大家应该都能掌握。（不会的可以去找一些博客啥的看一下，其实就是二进制的思想）

然后，你要知道：

1.假定n为偶数，那么C(n，0)+C（n，2）+......+C（n，n）=C(n，1)+C（n，3）+......+C（n，n-1）=2^(n-1)

2.n为偶数的话同理


知道了这些，A掉这道题不是轻松加愉快嘛，emmmmm

上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define ll long long 
#define mod 6662333
using namespace std;
int main()
{
	ll n;
	scanf("%lld",&n);
	ll p=2;//这题是以2为底数 
	ll ans=1;
	n--;//2^n-1
	while(n)//快速幂模板 
	{
		if(n&1) ans=ans*p%mod;
		n>>=1;
		p=p*p%mod;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：DanieNi (赞：2)

蒟蒻来水一发~

数学不好，真的不会直接数学推导到2^n,于是就写了个下面的小代码，**通过小数据来找规律**

···cpp



```cpp
#include <bits/stdc++.h>
using namespace std;
int C(int a,int b){
    int s(1),l(1);
    for (int i=a-b+1;i<=a;i++)
        s*=i;
    for (int j=2;j<=b;j++)
        l*=j;
    return s/l;
}
int main(){
    int n(10),sum(0);
    for (int j=1;j<=n;j++){
        for (int i=2;i<=n;i+=2)
            sum+=C(j,i);
        cout<<sum+1<<“ ”;
        sum=0;
    }
}
```
···
运行结果非常可喜

···cpp

1 2 4 8 16 32 64 128 256 512

--------------------------------

Process exited after 0.03081 seconds with return value 0

请按任意键继续. . .

···
于是就变成了一道裸的快速幂取模，附AC代码

···cpp




```cpp
#include <iostream>
using namespace std;
long long pow(int a,long long b,int c);
int main(){
    long long n;cin>>n;
    cout<<pow(2,n-1,6662333);
}
long long pow(int a, long long b, int c){
    long long ans = 1;
    long long k = a % c;
    while(b>0){
        if(b % 2 == 1)
        ans = (ans * k) % c;
        b = b/2;
        k = (k * k) % c;
    }
    return ans;
}
```
···
大牛勿喷，更多的还是想记录一下这个思想，小数据找规律，很有用~


---

## 作者：飞翔 (赞：1)

[我的博客](http://blog.csdn.net/qq\_31640513/article/details/53152435)

首先由二项式定理我们可以知道C(n,0)+C(n,1)+C(n,2)+…+C(n,n)=2^n，然后i只能取偶数，所以答案是2^(n-1)。接下来快速幂不解释。

```pascal
var
  a,b,n:int64;
function f(a,b,n:int64):int64;
var
  t,y:int64;
begin
  t:=1; y:=a;
  while b<>0 do begin
    if(b and 1)=1 then t:=t*y mod n;
    y:=y*y mod n;
    b:=b shr 1;
  end;
  exit(t);
end;
begin
  read(b);
    a:=2;
    b:=b-1;
    n:=6662333;
  write(f(a,b,n));
end.
```
接下来给出快速幂的模板：

```c
var
  a,b,n:int64;
function f(a,b,n:int64):int64;
var
  t,y:int64;
begin
  t:=1; y:=a;
  while b<>0 do begin
    if(b and 1)=1 then t:=t*y mod n;
    y:=y*y mod n;
    b:=b shr 1;
  end;
  exit(t);
end;
begin
  read(a,b,n);
  write(f(a,b,n));
end.
```
上面的程序可以计算a的b次方对n取余的值。

这题总的来说还是挺水的。


---

## 作者：Ofnoname (赞：0)

这道题的答案是$2^{n-1}\ mod\ 6662333$，各大题解中的证明都用到了二项式定理，但是即使不会二项式定理，这道题也是可以做的。下面我将用其他方法证明其正确性。

## 引理：$C_n^m = C_{n-1}^m + C_{n-1}^{m-1}$

显然，要从N个元素中选取M个，第N个元素可以选或不选，如果选择了第N个元素，方案数为$C_{n-1}^{m-1}$，如果没有选择第N个元素，方案数为$C_{n-1}^m$，加起来就是我们要求的$C_n^m $。

## 1. $C_n^0-C_n^1+C_n^2+...+(-1)^nC_n^n=0$

**以n为奇数作为例子，偶数类似。下同**。

显然$C_n^0=C_n^n=1$，原式可以写作：
$$
1-(C_{n-1}^0+C_{n-1}^1)+(C_{n-1}^1+C_{n-1}^2)+...+(C_{n-1}^{n-2}+C_{n-1}^{n-1})-1
$$


重组括号，裂项相消，代入$C_n-1^0=C_{n-1}^{n-1}=1$，即可得证。

## 2. $C_n^0+C_n^1+C_n^2+...+C_n^n=2^n$

显然，等式左边的意思就是从n个元素里选取任意多个元素，那么每个元素都有选或不选两种选择，总方案数当然是$2^n$。

将以上两个式子相加并约分，得到下式：
$$
C_n^0+C_n^2+...+C_n^{n-1}=2^{n-1}
$$
这就是我们要求的答案。

```cpp
#include <bits/stdc++.h>
#define p 6662333
using namespace std;

long long x,ans=1,a=2;

int main()
{
	scanf("%lld",&x); x--;
	while (x)
	{
		if (x&1) ans=ans*a%p;
		a=a*a%p; x>>=1;
	}printf("%lld",ans);
}

```



---

## 作者：rtyuei (赞：0)

****求C(n,0)+C(n,2)+C(n,4)+C(n,6)+...+C(n,n)=2^(n-1)****
由二项式定理可证。  
其他发题解的神犇的题解里已经证过了，此处不再证明。  
然后  
由于我太过蒟蒻，快速幂写废了，于是毅然打表
```
#include<bits/stdc++.h>

using namespace std;

int nf[6662333],f[6662333];
int main(){
	long long x;
	int n=1,s=0;
	scanf("%lld",&x);
	f[1]=1;
	nf[0]=1;
	while(f[(n*2)%6662333]==0){
		s++;
		n*=2;
		n%=6662333;
		nf[s]=n;
	}//打表：nf记录答案，f记录余数是否出现
	x--;
	x%=s+1;
	printf("%d",nf[x]);
	return 0;
}
```
~~快速幂神犇自动忽略~~

---

## 作者：天泽龟 (赞：0)

## 论组合的初级应用。
---
 这道题很适合像我这种初学组合的人水一水，就是关于组合数的几个推论。具体的话~~其实学了选修2-3大家都会做出这道题了_(:з」∠)_~~
 
 开个玩笑，既然是题解咱就给大家讲一下A了这道题你需要懂那些推论。
 
- 首先你要学会一个叫二项式定理的东西：
$(a+b)^p=C_p^0*a^p+C_p^1*a^p$ $^-$ $^1b+C_p^2*a^p$ $^-$ $^2b^2+...+C_p^p*b^p$，具体证明就不说了，理解就好。

- 那么对于$a=1,b=1$的情况，只要把a,b往上面带入，就可以得到以下柿子：
$2^p=C_p^0*1+C_p^1*1*1+...+C_p^p$（1），即$sigma(C(n,i))$，其中$i<n$，这是不是就和题目要求有点相似了？
- 现在我们在来带入$a=-1,b=1$的情况，你会发现：
$(1-1)^p=C_p^1*(-1)^p+C_p^1*(-1)^p$ $^-$ $^1*1...+C_p^p*1^p=0$（2），
那么对于奇偶性不同的$C(n,i)$，存在奇数的组合数之和恒等于偶数的组合数之和。

- 那我们应用（1）（2）两式，很容易就可得出：奇数的组合数之和=偶数的组合数之和=$2^p/2=2^p$ $^-$ $^1$，答案即为此，只要用快速幂搞一下即可。
---
### 如果没学过组合数啥的也不用担心，对于OI竞赛迟早的事情，这些推论记着就好，看到题目都是可以直接套用的（但怕是没那么简单的题了）_(:з」∠)
贴上代码：
```
#include <iostream>
#define ll long long
using namespace std;
const ll p=6662333;
ll n;
ll ksm(ll x,ll k)  //快速幂
{
	ll ans=1;
	while (k)
	{
		if (k%2) ans=ans*x%p;
		x=x*x%p; k/=2;
	}
	return ans%p;
}
int main()
{
	cin>>n;
	cout<<ksm(2,(n-1))<<endl;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

###看到没人发题解啊，我来一发。这道题首先看范围‘’‘n<=10^18'哦哦哦，原来是......log 2（n) 那么理所当然想到快速幂了，根据二项式定理：

##(a+b)^n=C(n,0)a^n+C(n,1)a^(n-1)b+...+C(n,i)a^(n-i)b^i+...+C(n,n)b^n

#因为n只为偶数，就取一半及2^n-1次，下面是代码

```cpp
**const n1=6662333;
var i,j,k,l,m,n:int64;
function pig(x:int64):int64;
var i,j,k:longint;
begin
  if x=1 then exit(2);
  i:=pig(x div 2);/分治的思想.....快速幂的精髓
  i:=i*i mod n1;
  if odd(x) then i:=i*2 mod n1;
  exit(i);
end;
begin
  readln(n);
  dec(n);
  writeln(pig(n)); 
end.**
```

---

## 作者：Rumia (赞：0)

快速幂+简单组合数推导。

∵∑(i=0->n) C（i,n）=2^n

    C(i,n)=C(i-1,n-1)+C(i,n-1)

∴ C(2\*i,n)=C(2\*i-1,n-1)+C(2\*i,n-1)

ΣC(2\*i,n)=ΣC(i,n-1)=2^(n-1)

代码：

```cpp
#include<iostream>
#define maxn 6662333
using namespace std;
long long n,ans=1,a=2;
int main(){
    cin>>n;
    for(n-=1;n;n>>=1,a=(a*a)%maxn) 
      if(n&1) ans=(ans*a)%maxn;
    cout<<ans;
    return 0;
}
```cpp

---


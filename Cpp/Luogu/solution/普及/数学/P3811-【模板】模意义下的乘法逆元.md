# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# 题解

## 作者：zjp_shadow (赞：979)

# 乘法逆元小结

> 乘法逆元，一般用于求 $$\frac{a}{b} \pmod p$$ 的值（$p$ 通常为质数），是解决模意义下分数数值的必要手段。

> [有兴趣可以点进我的博客看看啊qwq](https://www.cnblogs.com/zjp-shadow/p/7773566.html)

## 逆元定义

> 若$a*x\equiv1 \pmod {b}$，且$a$与$b$互质，那么我们就能定义:
$x$ 为 $a$ 的逆元，记为$a^{-1}$，所以我们也可以称 $x$ 为 $a$ 在 $\bmod b$ 意义下的倒数，

> 所以对于 $\displaystyle\frac{a}{b} \pmod {p}$ ，我们就可以求出 $b$ 在 $\bmod {p}$ 下的逆元，然后乘上 $a$ ，再 $\bmod {p}$，就是这个分数的值了。


## 求解逆元的方式

### 拓展欧几里得

这个方法十分容易理解，而且对于单个查找效率似乎也还不错，比后面要介绍的大部分方法都要快(尤其对于 $\bmod {p}$ 比较大的时候)。

这个就是利用拓欧求解 线性同余方程 $a*x \equiv c \pmod {b}$ 的$c=1$的情况。我们就可以转化为解 $a*x + b*y = 1$ 这个方程。

求解这个方程的解。不会拓欧可以点[这里](https://www.cnblogs.com/zjp-shadow/p/9267675.html#autoid-3-3-0)~

而且这个做法还有个好处在于，当 $a \bot p$ （互质），但 $p$ 不是质数的时候也可以使用。

代码比较简单：

```cpp
void Exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) x = 1, y = 0;
    else Exgcd(b, a % b, y, x), y -= a / b * x;
}
int main() {
    ll x, y;
    Exgcd (a, p, x, y);
    x = (x % p + p) % p;
    printf ("%d\n", x); //x是a在mod p下的逆元
}
```

### 快速幂


这个做法要利用 **费马小定理**

> 若$p$为素数，$a$为正整数，且$a$、$p$互质。
则有$a^{p-1} \equiv 1 (\bmod {p})$。

 
这个我们就可以发现它这个式子右边刚好为 $1$ 。


所以我们就可以放入原式，就可以得到：


$$a*x\equiv 1 \pmod p$$


$$a*x\equiv a^{p-1} \pmod p$$


$$x \equiv a^{p-2} \pmod p$$



所以我们可以用快速幂来算出 $a^{p-2} \pmod p$的值，这个数就是它的逆元了


代码也很简单：

```cpp
ll fpm(ll x, ll power, ll mod) {
    x %= mod;
    ll ans = 1;
    for (; power; power >>= 1, (x *= x) %= mod)
    	if(power & 1) (ans *= x) %= mod;
    return ans;
}
int main() {
	ll x = fpm(a, p - 2, p); //x为a在mod p意义下的逆元
}
```

### 线性算法


用于求一连串数字对于一个$\bmod p$的逆元。[洛谷P3811](https://www.luogu.org/problem/show?pid=3811)

只能用这种方法，别的算法都比这些要求一串要慢。


首先我们有一个,$1^{-1}\equiv 1 \pmod p$

然后设 $p=k*i+r,(1<r<i<p)$ 也就是 $k$ 是 $p / i$ 的商，$r$ 是余数 。

再将这个式子放到$\pmod p$意义下就会得到：

$$k*i+r \equiv 0 \pmod p$$

然后乘上$i^{-1}$,$r^{-1}$就可以得到:

$$k*r^{-1}+i^{-1}\equiv 0 \pmod p$$

$$i^{-1}\equiv -k*r^{-1}  \pmod p$$

$$i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor*(p \bmod i)^{-1} \pmod p$$


于是，我们就可以从前面推出当前的逆元了。

代码也很短：

```cpp
inv[1] = 1;
for(int i = 2; i < p; ++ i)
    inv[i] = (p - p / i) * inv[p % i] % p;
```


### 阶乘逆元 $O(n)$ 求

因为有如下一个递推关系。

$\displaystyle inv[i+1]=\frac{1}{(i+1)!}$

$\displaystyle inv[i+1]*(i+1)=\frac{1}{i!}=inv[i]$


所以我们可以求出$n!$的逆元，然后逆推，就可以求出$1...n!$所有的逆元了。


递推式为

$inv[i+1]*(i+1)=inv[i]$

所以我们可以求出 $\displaystyle \forall i, i!,\frac{1}{i!}$ 的取值了。

然后这个也可以导出 $\displaystyle \frac{1}{i} \pmod p$ 的取值，也就是

$$\displaystyle \frac{1}{i!} \times (i - 1)! = \frac{1}{i} \pmod p$$

具体实现可以参考我[这发提交](https://www.luogu.org/record/show?rid=12236223)（卡了常。。）


---

## 作者：zcysky (赞：309)

害怕
不懂为什么底下能扯到线性筛什么的……

普通球逆元就是naive的pow(x,mod-2)注意此时mod必须为质数

这题一下子叫你求这么多很明显不是这么做的嘛

逆元有线性递推的公式，推一下就好了呀。

```cpp
#include<bits/stdc++.h>
#define N 3000010
typedef long long ll;
using namespace std;
int inv[N],n,p;
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    n=read();p=read();inv[1]=1;puts("1");
    for(int i=2;i<=n;i++){
        inv[i]=(ll)(p-p/i)*inv[p%i]%p;
        printf("%d\n",inv[i]);
    }
}
```

---

## 作者：Rising_Date (赞：194)

## 逆元：
　　一般用于求 $\frac{a}{b}\ \;mod\; p$ 

## 定义：
　　若  $a*x ≡ 1 \;(mod \;p)$ ，且 $a$ 与 $p$ 互质，那么我们就能定义: $x$ 为 $a$ 的逆元，记为 $a^{-1}$ ，所以我们也可以称 $x$ 为 $a$ 的倒数( $mod \;p$ 意义下)。

　　所以对于 $\frac{a}{b}\ \; mod\;p$ ，我们就可以求出 $b$ 在 $mod\; p$ 意义下的逆元，然后乘上 $a$ ，再 $mod \; p$ ，就是这个乘法逆元的值了。

## 求法：
### First：费马小定理

定理内容：如果 $a,p$ 互质，那么 $a^{p-1} ≡ 1 \;(mod\; p)$

　　结合逆元方程 $a*x ≡ 1 \;(mod\; p)$ ,得到 $a*x ≡ a^{p-1}\;(mod \;p)$
$\;\;\;\;\;\;$根据同余的性质,若 $p$ 为质数,得到 $x ≡ a^{p-2}\; {mod \; p}$
  
$\;\;\;\;\;\;$即 $x = a^{p-2} \;mod\; p$, **快速幂** 求解即可

### Second：欧拉定理

定理内容：如果$a,p$互质，那么$a^φ(p) ≡ 1 \;(mod\; p)$，当 $p$ 为质数时，$φ(p)=p-1$。

　　同理，结合同余方程，得 $x=a^{p-2} \;mod \;p$, **快速幂** 求解即可

 _（这只是两种不同的证明，代码是相同的）_ 
```cpp
//TLE_83分
#include<cstdio> 
#define ll long long
using namespace std;
int n,p;
inline ll ksm(ll a,ll b){
    ll ans=1;
    a%=p;
    while(b){
        if(b&1) ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans%p;
}
void write(ll x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);putchar(x%10^48);
}
int main(){
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;i++)
        write(ksm(i,p-2)),putchar('\n');
    return 0;
}
```
### Third:解不定方程 

　　**解同余方程** $ax≡1 \;(mod \;p)$ 等价于 **解不定方程** $ax+py=1$
　　**Exgcd**求解即可（不会 请左转 [](https://www.cnblogs.com/RisingGods/p/9497928.html) _Exgcd_  ）
　　
  
$\;\;\;\;\;\;$由于 $p$ 是质数，那么$gcd(a,p)=1$;
　　
  
$\;\;\;\;\;\;$即求解不定方程 $ax+by=gcd(a,b)$;
  ```cpp
//AC_1240ms
#include<cstdio>
using namespace std;
int x,y;
void exgcd(int a,int b){
    if(!b){x=1,y=0;return ;}
    exgcd(b,a%b);
    int t=x;
    x=y,y=t-a/b*y;
}
void write(int x){
    if(x>9) write(x/10);
    putchar(x%10^48);
}
int main(){
    int n,p;
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;++i)
        exgcd(i,p),write((x%p+p)%p),putchar('\n');
    return 0;
}
```
### Forth：线性递推

#### 复杂度 $O(n)$
 
 #### 递推过程：
　　令 $p=ki+r$ ; {$\;k=\big\lfloor\frac pi\big\rfloor$, $r=p\;mod\;i\;$} $(i<p,k<p,r<i)$
　　
  
$\;\;\;\;\;\;$则有 $ki+r≡0\;(mod\; p) $ ①
  
①式左右同乘$i^{-1}*r^{-1}$ 得：
 
　　$k*r^{-1}+i^{-1} ≡ 0 \;(mod \;p)$

移项 得
　　
  
  $\;\;\;\;\;\;$ $i^{-1} ≡ -k*r^{-1} \;(mod\; p)$
　
 
 带入 $\;k=\big\lfloor\frac pi\big\rfloor$ , $r=p\; mod\; i$;
　　
  
  $\;\;\;\;\;\;$ $i^{-1}$ ≡ $\;-\big\lfloor\frac pi\big\rfloor$ $*(p\; mod \;i)^{-1} \;\;(mod\; p)$ ② 
　
 
 由于 $(p\; mod\; i) < i$ ,
 
 $\;\;\;\;\;\;$ 所以,在求出 $i^{-1}$ 之前,我们早已求出 $(p\; mod \;i)^{-1}$；
　　
  
  $\;\;\;\;\;\;$ 因此用数组 $inv[i]$ 记录$i^{-1}$ ( $i$ 的逆元)
　　
  
  $\;\;\;\;\;\;$ 则$inv[i]=-\frac{p}{i}\ * inv[p\;mod\;i]\;mod\;p$ ;

　不要以为到这里就结束了
　　
  
  $\;\;\;\;\;\;$ 因为我们需要保证 $i^{-1}>0$
　
 
 $\;\;\;\;\;\;$ 所以,我们在②式右边$\;+p\; $( $p\;mod\; p=0$, 答案不变)
　　
  
  $\;\;\;\;\;\;$ 即 $inv[i]=p-\frac{p}{i}\ * inv[p\;mod\;i]\;\;mod\;p$;
　　
  
  $\;\;\;\;\;\;$ 当然 $inv[1]=1,inv[0]=tan90$°(赋值为$0$);
　　
  
  $\;\;\;\;\;\;$而且$for$循环 要从$2$开始，防止改变 $inv[1]$ 的值;
　
 
 至此,证毕。
 ```cpp
//AC_664ms
#include<cstdio>
#define ll long long
using namespace std;
const int maxn=3e6+5;
ll inv[maxn]={0,1};
int main(){
    int n,p;
    scanf("%d%d",&n,&p);
    printf("1\n");
    for(int i=2;i<=n;i++)
        inv[i]=(ll)p-(p/i)*inv[p%i]%p,printf("%d\n",inv[i]);
    return 0;
}
```

---

## 作者：灵乌路空 (赞：124)

先无良宣传一下博客wwwwww  
[文章列表 - 核融合炉心 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

- ## 乘法逆元: 
    
    对于一个模数 $p$ 和一个除数 $x$ ,往往可以找到一个特殊数 $y$ ,   
  将$\div x$ 改为 $\times y$ , 即可代替。
  
  这个数 $y$ ,称为 $x$ 的"逆元",记作 $inv(x)$ 。
  
  例:   
  $3 \div 3 \times 4 (\mod 11)$  
  $=3 \times 4 \times 4 (\mod 11)$  
  $= 4$  
  其中, $4$ 即为模数为 $11$ 时 , $3$ 的 逆元.


  通过定义与例子 , 不难看出逆元与原数之间的关系:  
  $\large x \times inv(x) \equiv 1(\mod p)$

  

------------

- ## 求解模的逆元:

[P3811 【模板】乘法逆元](https://www.luogu.org/problemnew/show/P3811)

##### 有 $4$ 种方法可以求得 **模的逆元**

  
  
  1. ### **根据** 扩展欧几里得 : 
     
     #### 模数可以 不为质数
     
     $x \times inv(x) \equiv 1(\mod p)$ 其中 $x,p$ 都是已知的。

     有没有很眼熟 ？

	 这就是一个   
     未知数为 $inv(x)$ ,   方程右侧的 $c=1$ 的同余方程 , 
     
     求 $inv(x)$ 的值 , 解出此同余方程即可。
     
     关于 **扩展欧几里得** 与 **解同余方程** ，   
     详见： [欧几里得 与 扩展欧几里得 - 核融合炉心 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/ou-ji-li-dei-yu-kuo-zhan-ou-ji-li-dei)

------------


2. ### **根据** 费马小定理 :  

    #### 只适用于模数为质数的情况

   由费马小定理：   
   $\large x ^{p-1} \equiv 1 \pmod p$ 

   **故有 :** $ x ^{p-1}\equiv x \times inv(x) \pmod p$

   等式两侧同除x , **有:** $inv(x) \equiv x ^{p-2} \pmod p$

   之后可以通过快速幂求余 , 求得 $(x ^{p-2} ) \% p$ 的值 ,    
   即可直接得到 $inv(x)$ 的值
   

------------


3. ### **递推法** : 

   #### 只适用于模数为质数的情况
	
   如果要解模的逆元的数 , 数量很多，但是连续 , 那该怎么办 ? 

   就可以使用递推法 。
  
   $i$ 模 $p$ 意义下的逆元 $inv(i)$ 可表示为 :　
   
   $\large inv(i) = -\lfloor \frac{p}{i}\rfloor \times inv(p\% i)\% p$
   
   - ###### 证明:
     **设** $p=k\times i + r $ , $(k,r \in Z)$
     
     **因为 :** $p \equiv 0 (\mod p)$ , 
     
     **则 :** $(k\times i + r) \equiv 0 (\mod p)$
     
     使方程两边同乘 : $inv(i)\times inv(r)$ , 
     
     根据 逆元的性质 ，**则:**
     
     $(inv(i) \times i )\% p=1$  ，  $(inv(r) \times r )\% p=1$ ;
     
     **原式变为 ：**
     
     $k \times 1 \times inv(r) + 1\times inv(i) \equiv 0 (\mod p)$
     
     $inv(i) \equiv -k\times inv(r)$

	 **又因为 :**  $p=k\times i + r $ 
     
     **原式变为 ：** $inv(i) \equiv -\lfloor \frac{p}{i}\rfloor\times inv(p\%i) (\mod p)$

	 **即 ：** $inv(i) = -\lfloor \frac{p}{i}\rfloor \times inv(p\% i) \% p$

	 又因为 : $(p\% i) <i$ , 
     
     **则 :** $inv(p\% i)$ 在求出 $inv(i)$ 前便已求 , 可以进行递推

     **原式得证 。**
	 
     显然 , 求得的 $inv(i)$ 不一定为最小整数解
   
     若要获得最小正整数解,需要再加这样一步操作:
	
     使 $-\lfloor \frac{p}{i}\rfloor$ 先加上一个 $p$ , 再将其模掉 。
   
     即 : $inv(i) = (p - \lfloor \frac{p}{i}\rfloor)\times  inv(p \% i) \% p;$
     

------------


4. ### **阶乘逆元法：** 

	#### 只适用于模数为质数的情况
    
    设 $f(i)=inv(i!)$ , $\ \ g(i)=i! $
    
    **则：** $f(i-1) = f(i)\times i$ 
    
    - ###### 证明:
      
      $f(i-1)=\frac{1}{\ (i-1)\ !}=\frac{1}{i\ !}\times i =f(i)\times i$
    
    假设要求 $[1,n]$ 中所有数的逆元
    
    先求得 $[1,n]$ 中所有数的阶乘
    
    再用 费马小定理 求得 $f(n)$ 的值
    
    之后递推出 $f(1 \sim n)$ 的值
    
    但是 $inv(1! \sim n! )$ 并不是我们想要的答案
    
    需要继续转化。
    
    可知 : $inv(i) = inv(i!) \times(i-1)\ ! $
    
    - ###### 证明 : 
      
      $inv(i)=\frac{1}{i}=\frac{1}{i\ !}\times (i-1)\ ! = inv(i!)\times (i-1)!$
       
    按照上述方法转换,  
    可得:  
    
    $inv(i)=f(i)\times (i-1)!$
    
    即得答案 。
    

------------

  - ## 回到此题
  
  先看一眼数据范围:  
  $1\leqslant n \leqslant 3\times 10^6$ , $n<p<20000528$  
  输入保证 $p$ 为质数. 
  
  很明显, **扩欧法** 和 **快速幂法** 都被卡了 .
  
  由于区间连续 , 且模数 $p$ 为质 ,   
  则可以进行 **线性递推**
  
  原理上面讲的非常清楚.  
  
  代码如下:
  
  ### **递推法** :
    
 ```cpp
#include<cstdio>
using namespace std;
long long n,p;
long long ans[5000010]={0,1};
int main()
{
    scanf("%lld%lld",&n,&p);
    printf("1\n");
    for(long long i=2;i<=n;i++) //线性递推
      {
      	ans[i]=(long long)(p-p/i)*ans[p%i]%p;
        printf("%lld\n",ans[i]); 
      }
}
```
  
  ### **阶乘逆元法：** 

  ```cpp
#include<cstdio>
#define ll long long
using namespace std;
ll mul(ll a,ll b,ll mod) //快速幂模板
{
	ll ans=1;
	while(b)
	  {
	  	if(b&1) ans=ans*a%mod;
	  	a=(a*a)%mod;
	  	b>>=1;
	  }
	return ans%mod;
}
ll n,p;
ll c[5000010]={1};
ll f[5000010];
int main()
{
	scanf("%lld%lld",&n,&p);
	for(int i=1;i<=n;i++)
	  c[i]=(c[i-1]*i)%p;
	  
	f[n]=mul(c[n],p-2,p); //获得inv(n!)
	
	for(int i=n-1;i>=1;i--) //递推阶乘的逆元
	  f[i]=(f[i+1]*(i+1))%p;
	  
	for(int j=1;j<=n;j++) //转化并输出
	  printf("%lld\n",(f[j]*c[j-1])%p);
}
```
------------

---

## 作者：Kai_Admin (赞：112)

给定模数p：求如下四个问题。

规定：  $inv[a]$ 和 $a^{-1}$ 都表示a的逆元。

## 问题1：

给定数字a，其中$gcd(a,p)=1$，求a的逆元。

### 法一：exgcd，扩欧
```cpp
void exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1;y=0;
		return;
	}
	int q=a/b,r=a%b;
	exgcd(b,r,y,x);
	y-=q*x;
}
int inv(int a,int b){
	int x,y;
	exgcd(a,b,x,y);
	return x;
}
```
### 法二：快速幂+费马小定理

$a^{p-1}\equiv1 (mod \ p)$  `其中p为质数`

$a^{p-2}\equiv a^{-1}(mod \ p)$     

可得a在mod p意义下的逆元即为ksm(2,p-2);

#### 以上两种方法时间复杂度皆为$O(log_2N)$

## 问题2：

给定n,p，求1……n的逆元：p为质数

方法： $\begin{cases}inv[1]=1\\inv[i]=(p-\lfloor\frac{p}{i}\rfloor)*inv[p\ mod\ i] mod\ p\end{cases}$ 

时间复杂度$O(N)$

## 问题3：

给定n，求$1!,2!,3!,4!……,n!$共n个数的逆元。

$f(n)\equiv f(n-1)*n (mod\ p)$

$f(n-1)^{-1}\equiv f(n)^{-1}*n$

即：求出$n!$的逆元，倒推求逆元。

时间复杂度$O(N)$

## $ \color{red}\text{问题4:(重点！)}$

给定n个数$a_1$,$a_2$……$a_n$,分别求出它们在mod p意义下的逆元。

我们考虑求出$inv[a_x]$：

定义 $p0=\prod\limits_{i=1}^na_i$

$p1=\prod\limits_{i=1}^{x-1} a_i$

$p2=\prod\limits_{i=x+1}^n a_i$

即 p0是全积，p1是前缀积，p2是后缀积。得：

$a_x*p1*p2\equiv p0$

$a_x^{-1}\equiv p1*p2*p0^{-1}$

求出 $p0^{-1},p1,p2$即可

这是一个离线算法，时间复杂度$O(N)$

### 撰文我不易，留赞必感激。

---

## 作者：redegg (赞：41)

先引入一个相关问题：

如何快速求解$1$~$n$的阶乘逆元？

首先求出$n!$的逆元，$(n-1)!$的逆元是等于$n!$的逆元乘$n$。

设$P(x)$为$x$的逆元，可以这样简洁的证明：

$P(n!)\times x=\frac{1}{n!} \times x$

$P(n!) \times n=\frac{1}{(n-1)!}$

那么同理，我们可以求到$1$~$n$的所有数的阶乘的逆元。

-------------------------------------------

好了相关问题结束。

那么我们知道了$n!$的逆元，我们怎么求$n$的逆元呢？

当然直接乘上$(n-1)!$就可以啦！

证明和上面差不多：

$\frac{1}{n!}=P(n!)$

$\frac{1}{n!} \times (n-1)!=\frac{1}{n}=P(n)=P(n!)\times (n-1)!$

综上：$P(n)=P(n!)\times (n-1)!$

$1$~$n$的阶乘可以预处理算出吧！

$n!$的逆元可以一次快速幂求出吧！

最后从大到小用上面综上里的公式依次求出逆元，别忘了$\%p$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n;

long long p;
long long c[3000006];

long long fast(long long x,long long y)
{
    long long an=1;
    while(y)
    {
        if(y&1)
            an=(an*x)%p;
        x=(x*x)%p;
        y>>=1;
    }
    return an;
}

long long ans[3000006];

int main()
{
    scanf("%lld%lld",&n,&p);
    c[0]=1;
    for(long long i=1;i<=n;i++)
        c[i]=(c[i-1]*i)%p;
    long long last=fast(c[n],p-2);
    long long k;
    for(int i=n;i>=1;i--)
    {
        k=(last*i)%p;
        ans[i]=(last*c[i-1])%p;
        last=k;
    }
    for(int i=1;i<=n;i++)
        printf("%lld\n",ans[i]);
    return 0;
}

```

---

## 作者：一扶苏一 (赞：37)

# 【数论】乘法逆元

## Definition

对于一个数 $x$ 和一个模数 $p$，若存在一个数字 $y$，满足

$$x \times y \equiv 1 \pmod p$$

则称 $y$ 是 $x$ 在模 $p$ 意义下的**逆元**，记做 $x^{-1}~\equiv y \pmod p$。

一个数字逆元在模意义下的运算中可以完全取代该数字的倒数。例如 $\frac{x}{y}~\equiv x \times y^{-1} \pmod p$，其中 $y^{-1}$ 代表 $y$ 的逆元。

## Algorithm

#### Lemma

首先需要指出的是，一个数 $x$ 在模 $p$ 意义下存在逆元，当且仅当 $x$ 与 $p$ 互质。

#### Proof

这里只证明当 $x$ 与 $p$ 不互质时不存在逆元。对于逆元的存在性，由于下面的部分给出了逆元的构造算法，这就已经证明了在互质时逆元是存在的。

反证法，设对于任意的 $x \in Z^+$，存在 $x^{-1} \in Z^+$

$$x \times x^{-1} \equiv 1 \pmod p~~~~~~(1)$$

且

$$\gcd(x,~p) = d \neq 1~~~~~~(2)$$

根据同余的定义，$(1)$ 可以写成：

$$x \times x^{-1} = k \times p + 1~~~~~~(3)$$

其中 $k$ 是一个非负整数。

将 $(3)$ 的等号两侧同时除以 $(2)$ 中的 $d$：

$$\frac{x \times x^{-1}}{d}~=~\frac{k \times p + 1}{d}~~~~~~(4)$$

整理得到

$$\frac{x}{d} \times x^{-1}~=~\frac{p}{d} \times k  + \frac{1}{d}~~~~~~(5)$$

因为 $d = \gcd(x, p)$，所以 $d$ 一定是 $x$ 和 $p$ 的因数。所以

$\frac{x}{d}$ 和 $\frac{p}{d}$ 都是整数，进而 $\frac{p}{d} \times k$ 是整数，$\frac{x}{d} \times x^{-1}$ 是整数。

而因为 $d \neq 1$，所以 $\frac{1}{d}$ 一定不是整数，因此 $\frac{p}{d} \times k + \frac{1}{d}$ 不是整数。

于是等号左侧是整数，等号右侧不是整数，左侧一定不等于右侧，产生矛盾。这就矛盾证明了 $x$ 在模 $p$ 意义下存在逆元仅当 $x$ 与 $p$ 互质。

---

以下介绍求逆元的算法：

#### 求单个数字的逆元

##### Algorithm 1

$$x \times x^{-1}~\equiv 1 \pmod p$$

显然可以转化成方程

$x \times x^-1 = 1 + kp$

令 $y = -k$，移项得到

$$x \times x^{-1} + y \times p = 1$$

注意到这个式子就是扩展欧几里得算法所求的式子

$$ax + by = 1$$

只不过 $x$ 作为一个常数，是欧式式子里的 $a$，同理 $p$ 是欧式式子里的 $b$。使用扩展欧几里得算法求解上面这个式子即可。时间复杂度 $O(\log x)$。

##### Algorithm 2

根据欧拉定理

$x^{\phi(p)} \equiv 1 \pmod p$

其中 $\phi$ 为欧拉函数，$\phi(p)$ 表示小于 $p$ 的正整数中与 $p$ 互质的数的个数。

等式两侧同乘 $x^{-1}$ 可以得到

$$x^{\phi(p) - 1} \equiv x^{-1} \pmod p$$

显然当 $p$ 是一个质数时，$\phi(p) = p - 1$，这时可以 $O(1)$ 算出 $\phi(p) - 1$ 的值，即可用快速幂 $O(\log x)$ 求出 $x$ 的逆元。这个算法好写好记，常数也较小。一般当 $p$ 为 ``int`` 范围内的质数时选择此算法。当 $p$ 不在 ``int`` 范围内时，由于快速幂时需要两个 ``long long`` 相乘，会爆精度。

有关欧拉定理的证明可以看[这里](https://www.cnblogs.com/zylAK/p/9569668.html)

#### 求 $n$ 以内所有正整数模 $p$ 的逆元

显然，由于 $n$ 以内所有正整数都有在模 $p$ 意义下的逆元，所以 $p$ 和 $n$ 以内的所有数互质。

结论：设 $inv_i$ 为 $i$ 的逆元，则有递推式

$$inv_i \equiv -\left\lfloor\frac{p}{i}\right\rfloor \times inv_{p \bmod i} \pmod p$$

边界条件为

$$inv_1 = 1$$

##### Proof

首先 $inv_1 = 1$ 显然成立。

对于 $i > 1$，写出 $p$ 除以 $i$ 的带余除法表达式：

$$p = ki + r$$

其中 $r \in [0, i - 1]$

等式两侧对 $p$ 取余数，有 

$$0 \equiv ki + r \pmod p$$

移项得到

$$r \equiv -ki \pmod p$$

两侧同乘 $i^{-1} \times r^{-1}$，整理得到

$$i^{-1} \equiv -kr^{-1} \pmod p$$

由于 $k = \left\lfloor\frac{p}{i}\right\rfloor$，$r = p \bmod i$，所以原式得证。

又因为 $r < i$，所以在计算 $inv_i$ 时，$inv_r$ 已经被计算完成，所以上述递推可以完成。

证毕。

这样做的时间复杂度显然是 $O(n)$

#### 求 $n!$ 的逆元

因为 $(n!)^{-1} \equiv \frac{1}{n!} \equiv \prod_{i = 1}^n n^{-1}$，所以线性筛出 $n$ 以内所有数字的逆元时，可以顺便求出 $n!$ 的逆元。时间复杂度 $O(n)$

## Code

### Ex_Gcd

```cpp
#include <iostream>

typedef long long int ll;

ll x, p;

void Ex_gcd(const ll a, const ll b, ll &X, ll &Y);

int main() {
  std::cin >> x >> p;
  ll a, b;
  Ex_gcd(x, p, a, b);
  std::cout << (a % p + p) % p << std::endl;
  return 0;
}

void Ex_gcd(const ll a, const ll b, ll &X, ll &Y) {
  if (b == 0) {
    X = 1; Y = 0;
  } else {
    Ex_gcd(b, a % b, Y, X);
    Y -= a / b * X;
  }
}
```

### 欧拉定理

```cpp
#include <iostream>

typedef long long int ll;

ll X, p;

ll mpow(ll x, ll y);

int main() {
  std::cin >> X >> p;
  std::cout << mpow(X, p - 2) << std::endl;
  return 0;
}

ll mpow(ll x, ll y) {
  ll _ret = 1;
  while (y) {
    if (y & 1) (_ret *= x) %= p;
    y >>= 1;
    (x *= x) %= p;
  }
  return _ret;
}
```

### 线性求逆元

这里的 ``factinv`` 即为阶乘逆元。

```cpp
#include <cstdio>

const int maxn = 3000005;

int n, p;
int inv[maxn], factinv[maxn];

int main() {
  scanf("%d%d", &n, &p);
  factinv[1] = inv[1] = 1;
  printf("%d\n", 1);
  for (int i = 2; i <= n; ++i) {
    inv[i] = 1ll * (p - p / i) * inv[p % i] % p;
    printf("%d\n", inv[i]);
    factinv[i] = 1ll * factinv[i - 1] * inv[i] % p;
  }
  return 0;
}
```



---

## 作者：Henry_he (赞：27)

### 这是一篇pascal题解
根据数据范围，本题是要我们在线性时间求1~n的逆元

- ##### 逆元:
 求逆元，首先我们要了解什么是逆元
 1. 取模运算的性质
 
   (a+b) mod n=(a mod n+b mod n)mod n

   a*b mod n=((a mod n)*(b mod n))mod n
   
   我们发现在模域下加减乘都是比较方便的
 1. 除法?
 
   (a/b)mod p?=(a mod p)/(b mod p) mod p
   
   。。。
   
   (12/6)mod 3=2
   
   (12 mod 3)/(6 mod 3)mod 3=0
   
   emmmmmmmm
   
   很明显除法不满足上述的性质~
   
   假若有b使得ab≡1(mod p)
   
   那么除以a就等价于乘b,这样就把除法转换成了乘法啦啦啦~~~
   
   我们把b称作a的逆元,记作a^-1
  
  1. 求逆元
    ab≡1(mod p)
    
    等等，这个形式不正像noip2012的同余方程吗~
    
    那么就可以用拓欧求啦
    
    https://www.luogu.org/problemnew/show/P1082
    
    法二：费马小定理
      
      ![](https://cdn.luogu.com.cn/upload/pic/14741.png)
      
      很明显a^-1=a^(p-2)
      
      嗯呢呢,怎么快速求呢
      
      https://www.luogu.org/problemnew/show/P1226
      
      哈哈

我们回到本题

拓欧和费马小定理一个一个的求，时间都是O(nlogn)

拓欧(83分)

```pascal
 var a,b,x,y,i:longint;
procedure gcd(a,b:longint;var x,y:longint);
begin
  if b=0 then
  begin
    x:=1;
    y:=2;
    exit;
  end;
  gcd(b,a mod b,y,x);
  y:=y-(a div b)*x;
end;
begin
  readln(a,b);
  for i:=1 to a do
  begin
    gcd(i,b,x,y);
    writeln((x mod b +b) mod b);
  end;
end.
```

费马(66分)
```pascal
function mo(b,p,k:longint):longint;
var mid,t:longint;
begin
  if p=1 then exit(b mod k);
  mid:=p div 2;
  t:=mo(b,mid,k);
  if mid=p-mid then mo:=t*t mod k
    else mo:=(t*t mod k)*(b mod k) mod k;
end;
var i,p,n:longint;
begin
  readln(n,p);
  for i:=1 to n do 
  writeln(mo(i,p-2,p));
end.
```

#### 注：以下数均在(mod p)的意义下
根据费马小定理,a的逆元为a^(p-2)，b的逆元为b^(p-2)

ab的逆元为(ab)^(p-2)=a^(p-2)*b^(p-2)

若用f(a)表示a的逆元，那么f(ab)=f(a)*f(b)

换句话说，只用求质数的逆元即可推出其他数的逆元

想到这里，本蒟蒻套上了埃氏筛，在筛质数的倍数时把逆元给乘上去(其实是素数筛那题数据比较水，让我用埃氏筛水过去，所以蒟蒻我一直把埃氏筛当欧拉筛)

埃氏筛(83分）
```pascal
var n,p,y:longint;
    f:array[1..20000528]of longint;
    b:array[1..20000528]of boolean;
    cnt,j,i,k:longint;
procedure gcd(a,b:longint;var x,y:longint);
begin
  if b=0 then
  begin
    x:=1;
    y:=2;
    exit;
  end;
  gcd(b,a mod b,y,x);
  y:=y-(a div b)*x;
end;
begin
  readln(n,p);
  for i:=1 to n do
  begin
    f[i]:=1;
    b[i]:=true;
  end;
  b[1]:=false;
  writeln(1);
   for i:=2 to n do
  begin
    if b[i] then
    begin
      gcd(i,p,f[i],y);
      f[i]:=(f[i] mod p+p)mod p; 
      j:=i+i;
      while j<n do
      begin
        b[j]:=false;
        k:=j;
        while k mod i=0 do
        begin
          f[j]:=f[j]*f[i] mod p;
          k:=k div i;
        end;
        j:=j+i;
      end;
    end;
    writeln(f[i]);
  end;
end.
```
由于时间上任是nlogn的级别，依然过不了最后一个点

既然如此，我们选择~~真正的~~欧拉筛

欧拉筛在用最小质数去清合数的是后可以更新合数的逆元，f(ap)=f(a)*f(p)，因为p<a<ap所以f(a)和f(p)都已经是已知的啦

欧拉筛(100分)
```pascal
var b:array[1..30000000]of boolean;
    a:array[1..1000000]of int64;
    f:array[1..30000000]of longint;
    n,p,k,i,j,y:longint;
procedure gcd(a,b:longint;var x,y:longint);
begin
  if b=0 then
  begin
    x:=1;
    y:=2;
    exit;
  end;
  gcd(b,a mod b,y,x);
  y:=y-(a div b)*x;
end;
begin
  f[1]:=1;
  readln(n,p);
  b[1]:=true;
  for i:=2 to n do
  begin
    if b[i]=false then
    begin
      inc(k);
      a[k]:=i;
      gcd(i,p,f[i],y);//如果是质数就求逆元
      f[i]:=(f[i] mod p+p)mod p;
    end;
    for j:=1 to k do
      if i*a[j]<=n then
      begin
        b[i*a[j]]:=true;
        f[i*a[j]]:=f[a[j]]*f[i]mod p;//用质数更新合数
        if i mod a[j]=0 then break;
      end
      else break;
  end;
  for i:=1 to n do
    writeln(f[i]);
end.
```

完美的在O(n)时间内解决

然而神犇qhy告诉我逆元可以递推求~~~

dalao的手稿
![](https://cdn.luogu.com.cn/upload/pic/14743.png)

嗯，证明很清晰啦

f(a)=(p-p div a)*f(p mod i) mod p

那么通过这个式子递推就好啦

递推版(100分)
```pascal
var n,p,y:longint;
    f:array[1..20000528]of longint;
    b:array[1..20000528]of boolean;
    cnt,j,i,k:longint;

begin
  readln(n,p);
  f[1]:=1;
  writeln(1);
  for i:=2 to n do
  begin
    f[i]:=(p-p div i)*f[p mod i]mod p;
    writeln(f[i]);
  end;
end.
```

是不是简便许多呢(￣▽￣)~*

~~还是要接受dalao的熏陶呢~~

---

## 作者：傅思维666 (赞：19)

## ~~非常~~比较全的数论—同余大礼包

需要更好的阅读体验请戳本蒟蒻博客：

[浅谈欧拉定理及乘法逆元](https://www.cnblogs.com/fusiwei/p/12013269.html)

# 浅谈欧拉定理

本篇随笔简单讲解一下信息学奥林匹克竞赛数论部分**欧拉定理**这一知识点。介绍的内容大致分为这么几个部分：**“同余的基本概念、费马小定理、欧拉定理及其推论、乘法逆元”**。

## 同余的基本概念

同余的概念啊非常简单啦：如果两个整数$a,b$除以一个数$m$的余数相等的话，那么就叫做$a,b$在模$m$的意义上同余。

记作：
$$
a\equiv b\,\,\,(mod\,\,m)
$$
那么根据同余的这个定义，我们很容易能推导出一个性质：如果两个数$a,b$在模$m$的意义下同余，那么$a-b$就是$m$的倍数，这是显然的。

以及，如果$a\%m=1$，那么就可以被改写成这样的式子：
$$
a\equiv 1\,\,\,(mod\,\,m)
$$
这个转化的正确性也是显然的。

## 费马小定理

费马小定理也非常简单啦！用语言描述就是，如果一个数$p$是质数，那么对于一个不为$p$的倍数的整数$a$，有$a^{p-1}\equiv 1\,\,\,(mod\,\,p)$。那么把这个结论两边同时乘上一个$a$，即可得出：对于任意的整数$a$，$a$的$p$次幂与$a$在模$p$的意义上同余。

即：
$$
a^p\equiv a\,\,\,(mod\,\,p)
$$
证明过程由于笔者水平有限，请参阅百度百科：

引理1．
　　若a,b,c为任意3个整数,m为正整数，且(m,c)=1，则当a·c≡b·c(mod m)时，有a≡b(mod m)。
　　证明：a·c≡b·c(mod m)可得ac–bc≡0(mod m)可得(a-b)·c≡0(mod m)。因为(m,c)=1即m,c互质，c可以约去，a– b≡0(mod m)可得a≡b(mod m)。 [2] 

引理2．
　　设m是一个[整数](https://baike.baidu.com/item/整数)且m>1，b是一个[整数](https://baike.baidu.com/item/整数)且(m,b)=1。如果a[1],a[2],a[3],a[4],…a[m]是模m的一个完全剩余系，则b·a[1],b·a[2],b·a[3],b·a[4],…b·a[m]也构成模m的一个完全剩余系。
　　证明:若存在2个整数b·a[i]和b·a[j]同余即b·a[i]≡b·a[j](mod m)..(i>=1 && j>=1)，根据引理1则有a[i]≡a[j](mod m)。根据完全剩余系的[定义](https://baike.baidu.com/item/定义)可知这是不可能的，因此不存在2个[整数](https://baike.baidu.com/item/整数)b·a[i]和b·a[j]同余。

所以b·a[1],b·a[2],b·a[3],b·a[4],…b·a[m]构成模m的一个完全剩余系。

构造素数

![img](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/f603918fa0ec08faec6557995bee3d6d55fbdaa3.jpg)

 的完全

![img](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/9e3df8dcd100baa13c70ba174c10b912c8fc2e3a.jpg)

因为

![img](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/ac345982b2b7d0a2f13640a3c9ef76094b369a15.jpg)

 ，由引理2可得

![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/0824ab18972bd4073bdc2e5170899e510fb30906.jpg)

也是p的一个完全[剩余系](https://baike.baidu.com/item/剩余系)。由完全剩余系的性质，

![img](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/83025aafa40f4bfbe4ad63f8084f78f0f7361818.jpg)

即

![img](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/cc11728b4710b9123dbd0b52c8fdfc039245221a.jpg)

易知

![img](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/d01373f082025aafdc613df5f9edab64034f1ab8.jpg)

 ，两边可约去 

![img](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/0dd7912397dda144345f911eb9b7d0a20df486cc.jpg)

这样就证明了费马小定理。

**（结论必须要记住）**：
$$
a^p\equiv a\,\,\,(mod\,\,p)
$$

## 欧拉定理

在学习欧拉定理之前，需要先学习一下欧拉函数。推荐本蒟蒻的这篇博客：

[欧拉函数详解]( https://www.cnblogs.com/fusiwei/p/11726768.html )

那么有了这个知识做铺垫，我们就可以得出欧拉定理的式子：
$$
a^{\phi(p)}\equiv1\,\,\,(mod\,\,p)
$$
也就是说，如果$a,p$为整数且$a,p$互质，那么$a$的$p$的欧拉函数次幂与$1$在模$p$意义下同余。

（以下证明摘自百度百科。）

### 证明

将1~n中与n互质的数按顺序排布：x1,x2……xφ(n) （显然，共有φ(n)个数）

我们考虑这么一些数：

m1=a*x1;m2=a*x2;m3=a*x3……mφ(n)=a*xφ(n)

1）这些数中的任意两个都不模n同余，因为如果有mS≡mR (mod n) （这里假定mS更大一些），就有：

mS-mR=a(xS-xR)=qn，即n能整除a(xS-xR)。但是a与n互质，a与n的最大公因子是1，而xS-xR<n，因而左式不可能被n整除。也就是说这些数中的任意两个都不模n同余，φ(n)个数有φ(n)种余数。

2）这些数除n的余数都与n互质，因为如果余数与n有公因子r，那么a*xi=pn+qr=r(……)，a*xi与n不互质，而这是不可能的。(因为a*xi=pn+qr=r(……)，说明a*xi含有因子r，又因为前面假设n含有因子r，所以a*xi和n含有公因子r，因此a*xi与n不互质)那么这些数除n的余数，都在x1,x2,x3……xφ(n)中，因为这是1~n中与n互质的所有数，而余数又小于n.

由1）和2）可知，数m1,m2,m3……mφ(n)（如果将其次序重新排列）必须相应地同余于x1,x2,x3……xφ(n).

故得出：m1*m2*m3……mφ(n)≡x1*x2*x3……xφ(n) (mod n)

或者说a^[φ(n)]*(x1*x2*x3……xφ(n))≡x1*x2*x3……xφ(n)(mod n)

或者为了方便：K{a^[φ(n)]-1}≡0 ( mod n ) 这里K=x1*x2*x3……xφ(n)。

可知K{a^[φ(n)]-1}被n整除。但K中的因子x1,x2……都与n互质，所以K与n互质。那么a^[φ(n)]-1必须能被n整除，即a^[φ(n)]-1≡0 （mod n），即a^[φ(n)]≡1 （mod n），得证。

## 欧拉定理的推论

欧拉定理能干什么呢？

比如，简化幂的模运算。

例题：计算$7^{222}$的个位数。（也就是计算$7^{222}mod\,\,10$）。

那么，根据欧拉定理，$a^{\phi(p)}\equiv1\,\,\,(mod\,\,p)$，我们可以有以下的推导：

首先，因为$7,10$互质，且$\phi (10)=4$，所以有：$7^4\equiv 1\,\,\,(mod\,\,10)$。

那么，根据取余的性质，因为$7^4mod\,\,10=1$，所以$7^4$的$n$次幂模10还等于1.

那么就可以有：

$7^{222}=7^{4\times55+2}$，把1全部约去，得到：

$7^2\equiv7^{222}\,\,\,(mod\,\,10)$

这样就简单多了。

所以我们得出了这样的一个结论：
$$
a^n\,\,mod\,\,p=a^{n\%\phi(p)}\,\,mod\,\,p
$$
也就是说：
$$
a^n\equiv a^{n\%\phi(p)}\,\,\,(mod\,\,p)
$$
这个结论也叫做：**欧拉定理的推论**，极其重要。

对于线性计算的式子（这里**指四则基本运算中除了除法之外的三种运算**），如果要求我们对于$a+b,a-b,a\times b$的结果取模，那么我们完全可以在进行运算之前先对$a,b$取模，对结果不会造成任何影响。

但是如果要求我们对$a^b$这样的式子取模呢？

这就用到了欧拉定理的推论：我们可以把底数对$p$取模（这个操作的正确性就是由前面说的四则混合运算的正确性推导出来的，别忘了乘方运算的实质是一堆连乘）。指数对$\phi(p)$取模，再进行运算即可（快速幂走起）。

## 求乘法逆元

#### 乘法逆元的概念

其实是一个介绍定义的过程：

如果$ax\equiv1\,\,\,(mod\,\,p)$，并且$a,p$互质，则称$a$关于模$p$的乘法逆元为$x$。

还是比较容易记住的。

#### 乘法逆元的求解

举个例子：

如果需要我们求解$4$关于模$7$的乘法逆元。那么也就是说，对于这个需要去求解的乘法逆元$x$，我们只需要找到一个$k$，使得下式成立：
$$
4x=7k+1
$$
（这个式子是由于乘法逆元的定义：$4x\equiv 1\,\,\,(mod\,\,7)$以及同余的定义得到的）。

关于乘法逆元的求解，我们首先要对其进行分类。

首先，我们需要明白的是，对于$a$关于模$p$的乘法逆元的求解，只有在$a,p$互质的时候才有解，否则就是无解。这不仅是定义规定的，更是满足大前提的首要条件（大家只需要牢牢记住就好）。

那么，现在，$a,p$已经互质了。那么又有两种情况：模数$p$是否为素数。

**假如$p$为素数。**那么我们可以使用**费马小定理**来求解乘法逆元。

根据费马小定理，有：$a^{p-1}\equiv1\,\,\,(mod\,\,p)$，那么结合乘法逆元的定义，如果$a,p$互质，那么原式可以拆成$a\times a^{p-2}\equiv1\,\,\,(mod\,\,p)$。也就是说，这个时候的乘法逆元就是$a^{p-2}$。



假如$p$不是素数，就需要我们使用**扩展欧几里得算法求解**，对于扩展GCD还有不明白的小伙伴，请移步本蒟蒻的这篇博客：

[浅谈扩展GCD]( https://www.cnblogs.com/fusiwei/p/11775503.html )

对于扩展欧几里得算法，我们知道它可以被用于求解同余方程。

那么就和乘法逆元的求解很匹配了，因为乘法逆元的求解本质上就是在求解这么一个同余方程：
$$
ax\equiv 1\,\,\,(mod\,\,p)
$$
但是，扩展GCD解决的是形如$ax+by=\gcd(a,b)$的东西，和这个同余式子有什么关系呢？

如果像我一开始一样不太会变通的话，请看下面的证明过程。

最裸最裸，我们会求解形如：$ax+by=\gcd(a,b)$，这样的方程。

那么，我们只需要把这个$ax\equiv1\,\,\,(mod\,\,p)$转换成这样的形式进行求解即可。

假设我们可以把这个同余方程转换成$ax+by=\gcd(a,b)$的形式，那么当$a,b$互质时，$\gcd(a,b)=1$，咦？我们发现这个东西和乘法逆元的定义：$a,p$互质好像啊！那就让$b=p$吧！

那么，有$ax+by=1$。

两侧同时对$b$取模（因为这个时候$b=p$了），有$ax\%b+by\%b=1\%b=1$。

因为$by\%b=0$，所以原式就变成了：

$ax\equiv1\,\,\,(mod\,\,p)$，得证。

也就是说，如果要求一个数$a$关于$p$的乘法逆元，直接向扩展GCD算法的模板里传$(a,p,x,y)$，最后的$x$就是我们要求的乘法逆元。

这样的话有一道~~经典裸题~~例题：[NOIP2012同余方程]( https://www.luogu.com.cn/problem/P1082 )

然后我们就可以**求出一个数的乘法逆元**。

## 线性求逆元

其实我认为，前面的“求一个数的逆元”的部分最终还是为这个“线性求逆元”做铺垫（理论知识大于天嘛！）。我们在学数论的时候可能都会发现，我们在探究的过程中都是一个“由局部到整体”的概念：由判断一个数是否为质数到判断一群数是否为质数，由求一个数的约数集合到筛选一群数的约数集......同样，在学会了求一个数的逆元之后，我们要学习线性筛逆元。

求一个数的逆元的复杂度是$O(\log N)$的。如果我们要求很多数的逆元的时候，如无意外它的复杂度会是$O(N\log N)$的，这显然不符合我们的需求。所以，我们要开发一个$O(n)$的线性求逆元的算法。

线性筛逆元其实是一个递推的过程，我们在这里着重讲其递推式的建立与证明。

首先我们有：
$$
1^{-1}\equiv 1\,\,\,(mod\,\,p)
$$
我们把$p$拆开，拆成这样的形式：$p=k\times m+n$，这是可以成立的，因为任意一个正整数都可以被拆成这样的形式。

所以我们有：
$$
k\times m+n\equiv 0\,\,\,(mod\,\,p)
$$
（这个同余式其实表示的意义就是整除）

那么，两边同时除以$m,n$（即同时乘$m^{-1},n^{-1}$），则有
$$
\frac{k}{n}+\frac{1}{m}\equiv0\,\,\,(mod\,\,p)
$$
移项有：
$$
\frac{1}{m}\equiv-\frac{k}{n}\,\,\,(mod\,\,p)
$$
因为$k$就是$\lfloor\frac{p}{m}\rfloor$，$n$就是$p\,\,\,mod\,\,\,m$，所以原式就变成了：
$$
m^{-1}\equiv-\lfloor\frac{p}{m}\rfloor\times(p\,\,\,mod\,\,\,m)^{-1}\,\,\,(mod\,\,p)
$$
根据乘法逆元的定义，对于一对互质的数$a,p$，有它的一个乘法逆元$x$满足：$ax\equiv1\,\,\,(mod\,\,p)$，那么$x\equiv a^{-1}\,\,\,(mod\,\,p)$，那么，根据上面的这个式子，我们就求出了数$m$关于模$p$意义下的逆元。

递推式如下（用$inv[i]$数组表示一个数的逆元）：
$$
inv[i]=-(p/i)\times inv[p\%i]
$$
为了不让乘法逆元出现一堆负数，我们需要对这个递推式稍做处理：
$$
inv[i]=((p-p/i)*inv[p\%i])\%p
$$
如果能看明白并且记住这个证明过程的话当然是极好的，如果看不明白，直接记结论也是完全可以的，但是，请做好考场上秒忘自己又一点不会推的准备（别怪我没告诉你）。

---

## 总结：

这篇总结是我耗时将近一周盘完这篇博客之后的附加之作

（本来认为乘法逆元这一块一天就能学完，但是我好像高估了自己的能力、低估了数学的魅力（呵呵），加之快期末了，各种文化课以及个人烂事层出不穷，导致更博和巩固的速度都极为地缓慢）。

本来以为学完了应该就会了，但是在学最后的线性求逆元的过程中惊喜地发现前面的东西大多又不会了（结论也就差不多记住，至于推导过程就全部忘光光了），于是才真正领略了什么是数论，以及为何数论这一块让一些数竞大佬都由衷地感觉困难。于是又刹下心来重新看了一下，顺便归纳出来了一些重点，这样的话，每次复习的时候就不用通篇浏览，只核对这些重要的知识点到底会不会就可以了。

那么，**学完这一课，你需要会的——**

### 1、同余的基本概念

你总不能对别人讲，我学完同余了，但是连式子也看不懂...

### 2、费马小定理

结论：
$$
a^{p-1}\equiv 1\,\,\,(mod\,\,p)
$$
即：
$$
a^p\equiv a\,\,\,(mod\,\,p)
$$
这个**定理的适用条件**一定要记住：$p$为质数，并且$a$不为$p$的倍数。

### 3、欧拉定理

结论：
$$
a^{\phi(p)}\equiv 1\,\,\,(mod\,\,p)
$$
它的**适用条件**是：$a,p$互质。

推论：
$$
a^{n}\equiv a^{n\%\phi(p)}\,\,\,(mod\,\,p)
$$
当然，这个定理不是供人显摆用的，知道了，还得会用：

欧拉定理的推论可以用来解决形如这样的式子的求解的问题：
$$
a^n\,\,\,mod\,\,p
$$

### 4、乘法逆元的概念

### 5、求单个数的乘法逆元的两种方式

知道求单个数的乘法逆元的两种方式及其使用条件：

对于求$ax\equiv 1\,\,\,(mod\,\,p)$中的$x$，（大前提当然是$a,p$互质）如果：

**$p$为质数**，那么可以使用费马小定理。

**$p$不为质数**，那么需要使用扩展GCD将同余式转换成形如$ax+by=\gcd(a,b)$的同余方程来求解。

### 6、线性筛逆元

结论（递推式）：
$$
inv[i]=((p-p/i)\times inv[p\%i])\%p
$$

---

那么代码：
```cpp
#include<cstdio>
#define int long long
using namespace std;
const int maxn=3*1e6+10;
int n,p;
int inv[maxn];
signed main()
{
    scanf("%lld%lld",&n,&p);
    inv[1]=1;
    printf("1\n");
    for(int i=2;i<=n;i++)
    {
        inv[i]=((p-p/i)*inv[p%i])%p;
        printf("%lld\n",inv[i]);
    }
    return 0;
}
```

---

## 作者：Ireliaღ (赞：14)

## 这是一种不一样的线性逆元递推求法

~~其实也可以线性求出来任意一坨相乘得到的数的逆元~~

### 思路

根据逆元的意义，我们容易知道，如果我们知道$(xy)^{-1}(mod p)$，那么我们乘以$y$，就可以$O(1)$得到$x^{-1} (modp)$。

这样，$x$的逆元，可以利用$(x!)^{-1} \times (x - 1)!$这个式子求出来。所以，我们可以先递推出$n!$，然后用扩欧或者快速幂求出$(n!)^{-1}(modp)$，就可以反过来递推出$1$到$n$的所有逆元

### 代码

`cout`会超时，因为取消流同步和绑定只能加速`cin`

```cpp
// luogu-judger-enable-o2
#include <iostream>

using namespace std;

const int MAXN = 3e6 + 5;

int fac[MAXN], inv[MAXN], n, p;

int Exgcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    int ret = Exgcd(b, a % b, y, x);
    y -= 1LL * a / b * x;
    return ret;
}

void GetInv(int x, int finv, int mod) {
	if (x == 0) return;
	int ninv = 1LL * finv * fac[x - 1] % mod;
	GetInv(x - 1, 1LL * finv * x % mod, mod);
	//cout << ninv << endl;
	printf("%d\n", ninv);
}

int main() {
	//ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> n >> p;
	fac[0] = 1;
	for (int i = 1; i <= n; i++) fac[i] = 1LL * fac[i - 1] * i % p;
	int x, y;
	Exgcd(fac[n], p, x, y);
	GetInv(n, (x + p) % p, p);
    return 0;
}
```

---

## 作者：Shirο (赞：11)

一句话题意：有一个数k，找一个inv[k]使得：
$$ k * inv[k] \equiv 1 \pmod p$$
$$k\in[1...n]$$
这题这么毒瘤显然要线性的算法（扑哧）

那么我们可以来yy一下

设有：$p=a*k+b$

$$b*inv[b]\equiv1\pmod p $$
yy一下，把b转换一下表达方式
$$(p-a*k)*inv[b]\equiv1 \pmod p$$
乘法分配率一下可以得到：
$$p*inv[b]-a*k*inv[b]\equiv 1 \pmod p$$
因为第一个东西里面有p所以直接变成0
$$-a*k*inv[b]\equiv 1 \pmod p$$
把a，b魔改一下得到
$$-(p\space div \space k)*k*inv[p\bmod k]\equiv 1 \pmod p$$
但是有个负号，所以魔改一下搞掉，把k除过去：
$$(p-(p\space div\space k))*inv[p\bmod k]\equiv inv[k]$$
ok O(n) 效率搞过
懒得贴代码


---

## 作者：CYSCYS (赞：11)

O(nlogn)能过这道题。

很神奇吧。。。

这里扩展欧几里得比快速幂跑得快，快速幂过不了。

code：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int l,m,n,s,p;
void exgcd(int a,int b,int &x,int &y)
{
	if (!b)
	{
		x=1;
		y=0;
		return ;
	}
	exgcd(b,a%b,x,y);
	int z=x;
	x=y;
	y=z-a/b*y;
}
int main()
{
	register int a,b,x,y;
	cin>>n>>p;
	for (a=1;a<=n;++a)
	{
		exgcd(a,p,x,y);
		cout<< (x%p+p)%p;
		putchar('\n');
	}
	return 0;
}
```

2020.11.8更新：
有不少人在评论区说exgcd过不了，特此卡常。
```
#include<cstdio>
inline void exgcd(int a, int b, int &x, int &y)
{
	if (b)
	{
		exgcd(b, a % b, y, x);
		y = y- a / b * x;
	}
	else 
	{
		x = 1;
		y = 0;
	}
}
inline void out(int &x)
{
	register int f[16],i=0;
	while (x>0)
	{
		++i;
		f[i]=x%10+'0';
		x=x/10;
	}
	while (i>0)
	{
		std::putchar(f[i]);
		--i;
	}
	std::putchar('\n');
}
inline int reads()
{
	register int a=getchar(),b=0;
	while (a>'9' || a<'0')
		a=std::getchar();
	while (a>='0' && a<='9')
	{
		b=b*10+a-'0';
		a=std::getchar();
	}
	return b;
}
int main()
{
	register int a,b,x,y;
	const int n=reads();
	const int p=reads();
	for (a=1; a<=n; ++a)
	{
		exgcd(a,p,x,y);
	 	while (x>p)
			x=x-p;
		while (x<0)
			x=x+p;
		out(x);
	}
	return 0;
}
```
未开O2，最后一个点用时497ms。
![提交记录](https://cdn.luogu.com.cn/upload/image_hosting/9g1l4a6f.png)

---

## 作者：Styx (赞：7)

**传说费马小定理会TLE掉这道题,所以我考虑优化了一发,这类似于筛质数的思路?**

**众所周知,用费马小定理求一个数的逆元复杂度是O(log p)的,但是如果我们知道inv[i],inv[j]我们可以用O(1)的复杂度计算出来inv[i*j],所以我用了一个奇怪的筛,O(玄学)的a了这道题,我也不知道复杂度是多少,大概对于,每个质数是O(logp),对于合数是近似O(1)的.可以再去掉一些重复,但我懒得写了**

**代码如下**

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

long long inv[3000010],n,p,vis[3000010];

long long kasumi(long long a,long long b)
{
	long long ans=1;
	while(b)
	{
		if(b&1)
		{
			ans=ans*a%p;
		}
		a=a*a%p;
		b>>=1;
	}
	return ans;
}

void get()
{
	vis[1]=1;
	inv[1]=1;
	for(int i=2; i<=n; i++)
	{
		if(!vis[i])
		{
			vis[i]=1;
			inv[i]=kasumi(i,p-2);
			for(int j=2; j<=i&&j*i<=n; j++)
			{
				vis[i*j]=1;
				inv[i*j]=(inv[i]*inv[j])%p;
			}
		}
	}
}

int main()
{
	scanf("%lld%lld",&n,&p);
	get();
	for(int i=1; i<=n; i++)
	{
		printf("%lld\n",inv[i]);
	}
}
```

---

## 作者：Randolph、 (赞：5)

[P3811 【模板】乘法逆元](https://www.luogu.org/problemnew/show/P3811)

一个刚学数论的萌新，总结了一下这题的大部分做法

```cpp
//一、费马小定理+快速幂  O(nlogn) 64分
#include<cstdio>
using namespace std;
typedef long long ll;
int a,b;
inline ll pow(ll x,ll p) {
    ll ans=1;
    x%=b;
    while(p) {
        if (p&1) ans=ans*x%b;
        x=x*x%b;
        p>>=1;
    }
    return ans%b;
}
inline void write(int x) {
    if(x>9) write(x/10);
    putchar(x%10^48);
}
int main() {
    scanf("%d%d",&a,&b);
    for (int i=1; i<=a; i++) {
        write(pow(i,b-2));
        putchar('\n');
    }
}
```

```cpp
//二、exgcd O(nlogn)  80分

#include<cstdio>
using namespace std;
typedef int ll;
ll x,y,a,b;
inline void exgcd(ll a,ll b) {
    if (!b) x=1,y=0;
    else {exgcd(b,a%b); int t=x; x=y,y=t-a/b*y;}
}
inline void write(int x){
    if(x>9) write(x/10);
    putchar(x%10^48);
}
int main() {
    scanf("%d%d",&a,&b);
    for (int i=1; i<=a; i++) {
        exgcd(i,b);
        write((x%b+b)%b);
        putchar('\n');
    }
}
```

```cpp
//三、费马小定理+快速幂+线性筛 合数O(1)，质数O(nlogn) 80分
#include <cstdio>
using namespace std;
typedef long long ll;
ll n,p,inv[3000010],vis[3000010];
ll pow(ll x,int b) {
    ll ans=1;
    for (int i=b; i; i>>=1,x=x*x%p)
        if (i&1) ans=ans*x%p;
    return ans%p;
}
void work() {
    inv[1]=vis[1]=1;
    for (int i=2; i<=n; i++)
        if (!vis[i]) {
            vis[i]=1;
            inv[i]=pow(i,p-2);
            for (int j=2; j<=i && j*i<=n; j++)
                vis[i*j]=1,inv[i*j]=(inv[i]*inv[j])%p;
        }
}
int main() {
    scanf("%lld%lld",&n,&p);
    work();
    for (int i=1; i<=n; i++) printf("%lld\n",inv[i]);
    return 0;
}
```

```cpp
//四、阶乘+1次快速幂 O(n) 100分 607ms

#include<cstdio>
#define ll long long
using namespace std;
int n,p;
ll c[3000005],ans[3000005];
ll ksm(ll x,ll y)
{
    ll an=1;
    while(y)
    {
        if(y&1)
            an=(an*x)%p;
        x=(x*x)%p;
        y>>=1;
    }
    return an;
}
int main()
{
    scanf("%d%d",&n,&p);
    c[0]=1;
    for (int i=1;i<=n;i++) c[i]=(c[i-1]*i)%p;
    ll pow=ksm(c[n],p-2),k;
    for(int i=n;i;i--)
    {
        k=(pow*i)%p;
        ans[i]=(pow*c[i-1])%p;
        pow=k;
    }
    for(int i=1;i<=n;i++)
        printf("%lld\n",ans[i]);
}
```

```cpp
//五、线性递推 O(n) 100分 560ms
#include<cstdio>
#define ll long long
using namespace std;
ll inv[3000005]={0,1};
int main()
{
    int n,p;
    scanf("%d%d",&n,&p);
    printf("1\n");
    for (int i=2;i<=n;i++)
    printf("%d\n",inv[i]=(ll)p-(p/i)*inv[p%i]%p);
    return 0;
}
```

---

## 作者：浅色调 (赞：5)

###乘法逆元###

**思路：**

求逆元的线性算法，具体过程如下。

首先，1-1≡1(mod p)。

然后，我们设p=k\*i+r，r<i,1<i<p，再将这个式子放到mod p意义下就会得到：k\*i+r≡0(mod p)

再两边同时乘上i-1、r-1就会得到：

k\*r-1+i-1≡0(mod p)     -->   i-1≡-k\*r-1(mod p)    -->    i-1≡-[p/i]\*(p mod i)-1 (mod p)

于是，就可以从前面推出当前的逆元。代码也就一行：**a[i]=-(p/i)\*a[p%i];**

然后这道模板题，便可以用上述方法解决的。。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define inf 233333333333
ll n,p,a[3000600],b;
int main()
{
    scanf("%lld%lld",&n,&p);
    a[1]=1;
    for(int i=2;i<=n;i++){
    a[i]=-(p/i)*a[p%i];
    while(a[i]<0)a[i]+=p;
    printf("%lld\n",a[i-1]);
    }
    printf("%lld\n",a[n]);
    return 0;
}
```

---

## 作者：羽儇 (赞：4)


   


    
x的逆元在模质数（1--p-1）中只有一个
求逆元方法有四
 

 1. 

![](https://img-blog.csdnimg.cn/20190730103511892.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmVseV9waW5uYQ==,size_16,color_FFFFFF,t_70)
 （来源于阮行止老师课上的PPT）

 2. 线性递推

 ![](https://img-blog.csdnimg.cn/20190801173548165.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmVseV9waW5uYQ==,size_16,color_FFFFFF,t_70)
 （来源于何教练课上的PPT）
然后 左式再加上P ，以防负数，而且结果不变

3. 阶乘
![](https://img-blog.csdnimg.cn/20190801211759970.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvbmVseV9waW5uYQ==,size_16,color_FFFFFF,t_70)
 4. 扩欧：n*inv(n)=1(mod p)
 n*inv(n)+p*k=1
 把inv(n)和k看成x,y用扩欧解出inv(n)
 
以**luoguP3811**为例
我按四个方法都写了代码，但只有线性递推不TLE
1、
```
#include <iostream>
using namespace std;
int modd;
int quickpow(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1)ans*=a%modd;
		a*=a%modd;
		b>>=1;
	}
	return ans;
}
int main()
{
	int n,p;
	cin>>n>>p;
	modd=p;
	for(register int i=1;i<=n;i++)
		cout<<quickpow(i,p-2)%modd<<endl;
}
```
2、

```
#include <cstdio>
using namespace std;
int inv[5000000]={0,1};
int main()
{
	printf("%d\n",1);
	int n,p; 
	scanf("%d",&n,&p);
	for(int i=2;i<=n;i++)
	{
		inv[i]=p-(p/i)*inv[p%i]%p;
		printf("%d\n",inv[i]);
	}
	return 0;
}
```

3、

```
#include <cstdio>
#define ll long long
using namespace std;
ll inv[5000000],f[5000000]={1,1},modd;
ll quickpow(ll a,ll b)
{
	ll ans=1;
	while(b)
	{
		if(b&1)ans=ans*a%modd;
		b>>=1;
		a=a*a%modd;
	}
	return ans%modd;
}
int main()
{
	ll n,p;
	scanf("%lld%lld",&n,&p);
	modd=p;
	for(int i=2;i<=n;i++)
	f[i]=(f[i-1]*i)%modd;
	inv[n]=quickpow(f[n],p-2);//先费小+快速幂求inv[n]
	//inv[n]代表n的阶乘的逆元
	for(int i=n-1;i>=1;i--)
	inv[i]=(inv[i+1]*(i+1))%modd;//注意，inv[!i] =inv[!(i+1)]*(i+1),是把(i+1)的-1次方再乘上i+1,抵消为1，剩余的部分为inv[!i]
	for(int i=1;i<=n;i++)
	  printf("%lld\n",(inv[i]*f[i-1]+modd)%modd);
	return 0;
}
```

4、
```
#include <iostream>
#include <algorithm>
#define pr pair<int,int>
#define x tmp.first
#define y tmp.second
using namespace std;
int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}
pr exgcd(int a,int b)
{
	if(!b)return pr(1,0);
	pr tmp = exgcd(b,a%b);
	return pr(y,x-a/b*y);
}
int main()
{
	int n,p;
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	{
		pr tmp = exgcd(i,p);
		cout<<(x+p)%p<<endl;
	}
	return 0;
}
```


---

## 作者：AcerMo (赞：3)

### 一个神奇的解法
#### 从组合数那里飞过来的
##### 思路
我们先处理出一个$s=1 * 2 * ... * n$，然后用费马小定理求一下它的逆元就是$s=s^{p-2}$，然后现在的s就相当于$\frac{1}{1 * 2 * ... * n}$，所以我们发现1~n中任意一项的逆元都可以由现在的s在O(1)得到，如何得到？假如我们要求5的逆元，就相当于$s * (1 * 2 * 3 * 4) * (6*...* n)$也就是把分母里除5以外的所有数消去，就能得到5的逆元了，如何实现呢？我们预处理一个前缀积数组，然后倒序处理，他前面的数的积直接查表，后面数的积交给一个tmp，初始是1，每处理完一个数，就乘上这个数就好了
##### 代码
```cpp
//By AcerMo
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=3005000;
int n,m,s[M];
inline int fpow(int x,int y)
{
	int z=1;
	for (;y;x=(1LL*x*x)%m,y>>=1)
	if (y&1) z=(1LL*z*x)%m;
	return z;
}
signed main()
{
	cin>>n>>m;s[0]=1;
	for (int i=1;i<=n;i++)
	s[i]=(1LL*s[i-1]*i)%m;
	int s1=1,ni=fpow(s[n],m-2);
	for (int i=n;i;i--)
	{
		s[i]=((1LL*ni*s[i-1])%m*1LL*s1)%m;
		s1=(1LL*i*s1)%m;
	}
	for (int i=1;i<=n;i++) printf("%d\n",s[i]);
	return 0;
}
```

---

## 作者：_ztyqwq (赞：3)

乘法逆元的模板题…… 具体神马的我就不说了，用最基础的算法（扩展欧几里得，exgcd），主要的步骤是这样的：

假设我们要求满足

$ ax + by = gcd(a, b) $

的 $ x,y $，而我们已知

$ bx' + (a\ mod\ b)y' = gcd(b, a\ mod\ b) $

我们对此式进行推导：

$ bx' + (a\ mod\ b)y' = gcd(b, a\ mod\ b) $

$ \Leftrightarrow bx' + (a - bq)y' = gcd(a, b) \qquad (q = [\frac a b],\ gcd(b, a\ mod\ b) = gcd(a, b)$

$ \Leftrightarrow bx' + ay' - bqy' = gcd(a, b) $

$ \Leftrightarrow ay' + b(x' - qy') = gcd(a, b) $

于是就愉快的解决啦~

当然还有一种方法，用来求连续数的乘法逆元（模数相同），复杂度更小，可以参考[我的博客](https://www.luogu.org/blog/ztyluogucpp/sheng-fa-ni-yuan-ge-ren-li-xie)。

所以是不是可以上代码了呢：

```cpp
#include<bits/stdc++.h>
using namespace std;
int inverse[20000600];
int main()
{
	int n,p;
	scanf("%d %d",&n,&p);
	printf("1\n");
	inverse[1]=1;
	for(int i=2;i<=n;i++)
	{
		int t=p-(long long)(p/i)*inverse[p%i]%p;
		inverse[i]=t;
		printf("%d\n",t);
	}
	return 0;
}
```

---

## 作者：Night_Aurora (赞：3)

经过好几次T后才发现N是3e6

nlogn暴力无果后只能掏出珍藏已久的线性筛了

通过逆元的定义可以知道它是在膜P下的完全积性函数

所以可以像Phi函数一样O(n)筛了

线性筛只有在质数时才会logn求逆元，而质数差不多就是n/lnn个，还是O(n)

虽说过了，但是最后一个点919ms看着怪吓人的


```cpp
#include <stdio.h>
#include <string.h>
typedef long long _L;
void inline GCDEX(_L a,_L b,_L&x,_L&y)
{
    if(!b)
    {x=1;y=0;return;}
    GCDEX(b,a%b,y,x);
    y-=x*(a/b);
}
_L Inverse(_L d,_L n)
{
    _L x,y;
    GCDEX(d,n,x,y);
    return (x+n)%n;
}
int N,P;
bool NPr[3100000];
int Prm[310000];
int Prt;
long long Ivr[3100000];
void Eular()
{
    int wi,wib;
    Ivr[1]=1;
    for(wi=2;wi<=N;++wi)
    {
        if(!NPr[wi])
        {
            Prm[++Prt]=wi;
            Ivr[wi]=Inverse(wi,P);
        }
        for(wib=1;Prm[wib]*wi<=N;++wib)
        {
            Ivr[Prm[wib]*wi]=Ivr[wi]*Ivr[Prm[wib]]%P;
            NPr[Prm[wib]*wi]=1;
            if(wi%Prm[wib]==0)break;
        }
    }
}
int main()
{
    scanf("%d %d",&N,&P);
    int wi;
    Eular();
    for(wi=1;wi<=N;++wi)
        printf("%d\n",(int)Ivr[wi]);
    return 0;
}
```

---

## 作者：Indigo_Boy (赞：2)

# 看到各位的乘法逆元我有点恐惧啊
### 六行（~~强行压行~~）AC代码
```cpp
#include<bits/stdc++.h>
long long n, p, inv[3000010]; 
int main( void ){
	std::scanf( "%lld%lld", &n, &p ); inv[1] = 1; std::printf( "%lld\n", inv[1] );
	for( int i = 2; i <= n; i++ ) std::printf( "%lld\n", inv[i] = ( ( p - p / i ) * inv[p % i] ) % p );
}
```
[博客内观看](https://www.cnblogs.com/with6676/p/11566059.html)~~还可以调戏看板娘哦~~

## 乘法逆元是啥？

“逆”可以理解为是抵消之前的运算效果

### $ e. g. $

$ a = a + b - b$  那么 $+ b$ 就叫做 $- b$ 的逆

同理 $ a = a * b * \frac{1}{b} $ 那么 $\frac{1}{b}$ 就叫做 $* b$ 的逆

很好理解吧

那么现在请思考，我们知道$ ( a * b )$ $mod$ $ p = （ a $ $mod$ $p ) * ( b$ $mod$ $p )$，那么 $ \frac{a}{b} $ mod $ p $ 是否等于 $( a$ $mod$ $ p ) * ( b$ $mod$ $p )$呢

显然不等于

怎么办呢？我们只能找一个$x$，使得$\frac{a}{b}$ $mod$ $ p =   a * x $ mod $ p$ 

此时$ x$ 叫做 $b$的乘法逆元， 表示为$b * x\equiv 1 $( $mod$ $p$ )，叫做$b * x$ 与 1 关于 $ p $ 同余， $\equiv$的意思是$b * x$ $mod$ $ p  = 1$ $mod$ $p$， 也可以写成 $ ( b * x - 1 ) / p = 0 $

#### 为啥是$ b * x \equiv 1$ 而不是$ a * x \equiv 1 $？？？

既然$b * x$ 和 1 同余了， 那么求余时这俩就是等价的了，所以$ a / b * 1$ $mod$ $ p = a / b * b * x$ $mod$ $ p = a * x$ $mod$ $p$

### **注意：存在的充要条件是 $a ,p$互质**
## 咋求乘法逆元？

求单个数的乘法逆元， 可以用拓展欧几里得（不知道的戳这里）

$a * x \equiv 1 ( mod $ $p)$ 可写成 $ a * x - p * y = 1$

此时，这一不定方程就可以用拓展欧几里得解了

另外，前面很$dalao$也写了，可以用费马小定理加速，

因为$ a ^ {p- 1} \equiv 1 (mod$ $p)$，很明显可以写成

$a * a ^ {p - 2} \equiv 1 (mod$ $p)$，那么逆元就求出来了，可以用快速幂加速

## 但是太麻烦了，乘法逆元可以线性预处理

$ inv[i] = ( p - \frac{q}{i} ) * inv[p $ $mod$ $i] $ $mod$ $p$

#### 试着证明

$i * inv[i]$ $mod$ $p$

$= i * (p - \frac{p}{i}) * inv[p $ $mod$ $i]$ $ mod $ 

$= i * (p - \frac{p-p MOD i}{i}) * inv[p $ $mod$ $i]$ $ mod $ 

//因为分子打不了$mod$,所以用MOD表示了

$=( p $ $mod$ $i )* inv[p $ $mod$ $i]$ $ mod $ $p$

$= 1$

#### 适用范围
$i < p, p$为质数（只有p为质数时才能保证小于p的数全部与p互质）

#### 对于$ i > p $ 且 $ i $ 不整除 $p$ 时
$inv[i] =  inv[i $ $mod$ $p]$ 
### 实现代码如下

```cpp
inv[1] = 1;
for ( int i = 2; i <= n; i++ ) {
    inv[i] = ( p - p / i ) * inv[p % i] % p;
}
```
_____________________________

```cpp
return; // 功德圆满
```


---

## 作者：Algha_Porthos (赞：2)

前面的大佬们似乎对于逆元的作用讲的不是很清楚。我便寻思着。。写一篇方便像我这种大菜鸡理解的题解。dalao请自行移步~

# 1.乘法逆元是什么？

“乘法逆元，是指数学领域群G中任意一个元素a，都在G中有唯一的逆元a'，具有性质a×a'=a'×a=e，其中e为该群的单位元。”--X度百科

没事，我知道你看不懂。(反正我是看不懂)

用现代汉语表述，便是我们需要找到一个数，让它可以把$a*b(mod\ p)$的$b$抵消。

无法理解？没事，让我们先看两个故事。

## 1.1.关于乘法逆元的类比

**[搬运&改编自这里](https://www.jianshu.com/p/e9e1c52bf6c9)**

### 1.1.1.加法

首先，想像一下，你在数学世界的加法王国里。你是那位德高望重的国王$a$。你在数轴的坐标$a$上。

有一天，你被一股神秘力量往数轴正方向怼了$b$个单位长度！你现在不再是国王$a$，而是不知名的$a+b$！

你很生气，想要重回宝座，怎么办？

怎么来的，怎么回去呗！

没错，你只需要往负方向走$b$个单位长度，你就重回了宝座$a$，你又可以指点江山。

如果那股神秘力量叫做加法。

没错，你重回宝座的方法叫做减法。

那让我们用数学公式把上述过程表述出来吧！

$$(a+b)-b=a$$


------------


### 1.1.2.乘法

请再想像一下，你还是在数学世界，只不过这一次是在乘法王国。

你是国王$a(a\in N^*)$。这回，那股神秘力量叫做乘法，把你往数轴正方向怼了$(b-1)(b\in N^*)$倍。也就是你现在在$a*b$的位置上。

你重回宝座的方法便是除法。你只需要找到从原点到现在所在位置的最靠近数轴的$b$等分点就完事儿了。

公式如下：

$$(a*b)/b=a\ \ \  (a,b \in N^*) $$



------------
### 1.1.小结：

其实不难发现，加法的逆操作叫作减法，乘法的逆操作叫作除法。

但是如果你仔细读过题，你就会发现“乘法逆元”的乘法好像和普通乘法不太一样——没错，所有算式是在$(mod p)$条件下的。

那我们该怎么办呢？

------------

## 1.2 乘法逆元的性质

我们先假设在$(mod\ p)$条件下，正整数i的逆元为$inv[i]$。其中inv是英语逆元(Inverse)的缩写。

对于任意大于等于1，小于(注意没有等于)$p$的正整数$a$，都有$a*inv[a] \equiv 1 (mod \ p)$

$e.g.\ \ a=2,b=3,p=5,inv[a]=3,inv[b]=2.$

### 1.2.1 让故事继续？

现在，你在$(mod p)$意义下的乘法王国。你是国王$a(a\in N^*)$。那股神秘力量把你往数轴正方向怼了$(b-1)(b\in N^*)$倍。

这还没完！由于现在是在$(mod\ p)$意义下的乘法王国，你的位置被$(mod\ p)$了
。

也就是你现在在$(a*b)mod\ p$的位置上。

这个时候，显然我们不能再做除法了。举一个很简单的例子:

$$a=2,b=3,p=5$$

乘法的答案是$6$，$(mod\ 5)$后答案是$1$.我们总不能计算(1/3)得到一个小数作为答案吧？

此时乘法逆元就十分有用了。

我们只需要把$1$乘上$inv[b]$就可以得到$2$,便是a的初始值。

为什么？

我们来推导一下公式：

$$\because b*inv[b]\equiv 1(mod\ p)$$

$$\therefore a*b*inv[b]\equiv a(mod\ p)$$

是不是十分简单易懂？

乘法逆元的本质，便是将在$mod\ p$条件下不方便操作的除法，聪明地转化成“抵消乘法带来的影响”。

# 2.代码实现

模板的代码也十分简短。

由于本文以解释为主，所以证明不作赘述。若需要证明，请大家移步dalao们的题解。

这里是一个线性解法。公式入下：


$$inv[i]=((p-p/i)*inv[p\ mod\ i])\ mod\ p;$$

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
long long inv[3000005],n,p;
int main(){
	inv[1]=1;
    cin>>n>>p;
	for(int i=2;i<=n;++i)
        inv[i]=(long long)((p-p/i)*inv[p%i])%p;
    for(int i=1;i<=n;++i)
        printf("%lld\n",inv[i]);
}
```

---

## 作者：jins3599 (赞：2)

## 定义
>若$a*x≡1(mod (p))$，其中$a$与$p$互质，则称$x$为$a$模$p$意义下的逆元.

**以下用$x^{-1}$表示$x$的逆元**
## 用途
一般用于求$(a/b)\%p$，解决模意义下除法的必要手段.

## 方法
求乘法逆元有很多种方法，我只会其中的三种（个人认为较高效，易理解。）

### 一.扩欧求乘法逆元。

我们考虑定义式:

$a*x≡1(mod (p))$

写成裴蜀等式的形式就是:

$ax+yp = 1$

利用扩欧求解$x,y$即可。

记得求解的$x$可能会有负数，可以把$x$做模$p$意义下的处理:

```cpp
x = ((x%p)+p)%p
```
$or$

```cpp
while(x<0) x+=p;
x%=p;
```

### 二.线性递推多组逆元。

考虑一下带余除法。

设$p =k*a+q$


则$k = [p/a]$

则有:
$$k*a+q≡0\ (mod\ p)$$

两边同时乘以$a$和$q$的逆元，得

$$ k*q^{-1}+a^{-1}≡0\ (mod\ p) $$

$$a^-≡-k*q^{-1}\ (mod\ p)$$

$$a^-≡-(p/a)*q^{-1}\ (mod\ p)$$

$$a^-≡-(p/a)*(p\%a)^{-1}\ (mod\ p)$$

我们就顺利的得到了一次递推式。

```cpp
inv[1] = 1;
for(int i = 2; i <= n ; ++ i){
	inv[i] = (p - (p/i)) * inv[p % i] % p
}
```

### 三.费马小定理求解乘法逆元

#### 引理
> $a^{p-1}≡1(mod(p))$

> $=>a^{p-2} *a ≡1(mod(p))$

即$a$模$p$意义下的乘法逆元为$a^{p-2} \%p$

$Code$ :
```cpp
#include <bits/stdc++.h>
using namespace std;
int p,n;
int Pow(int x,int y)
{
	int ans = 1 , base =x;
	for(;y;y>>=1,base*=base , base %= p) if(y & 1) ans *= base , ans %= p;
	return ans;  
}

signed main ()
{
	ios::sync_with_stdio(0); 
	cin >> n >> p;
	cout << Pow(n,p-2) % p << '\n';
	return 0;	
}
```


---

## 作者：于丰林 (赞：2)

关于这道题，其实就是一个求逆元的模板题，常见的有三种方法，在这里只介绍两种方法：

1.费马小定理+快速幂（能水64分）

费马小定理：若p为素数，a为正整数，且a、p互质。 

则有a^(p−1)≡1(mod p)

又因为a* a的逆元（w）等于1，所以a^(p−1)≡a* w（mod p）

故w在模p意义下是等于a^(p-2)的（记住就好）

所以问题就转化成了求a^(p-2)，我们就联想到了快速幂（如果不知道什么是快速幂，我也没招）

这个算法由于快速幂的优化，时间复杂度还是比较可观的，基本可以稳定在（nlogn）

附上该方法的代码：

```cpp
#include<cstdio>
using namespace std;
long long p;
long long qpow(long long x,long long y)
{
    long long ans=1;
    while(y!=0)
    {
        if(y&1)
        {
            ans=((ans%p)*(x%p))%p;
        }
        x=((x%p)*(x%p))%p;
        y>>=1;
    }
    return ans;
}
int main()
{
    long long n;
    scanf("%lld%lld",&n,&p);
    for(register int i=1;i<=n;i++)
    {
        printf("%lld\n",(qpow(i,p-2))%p);
    }
    return 0;
}
```

2.线性递推（100分O（n）的神级算法）

令 p=ki+r k=⌊p/i​⌋,r=p mod i (i<p,k<p,r<i)

那么显然 ki+r≡0（mod p）　　

我们将左右同时乘以i和r的逆元即可得到

k∗r^−1+i^−1≡0(modp)

i^−1≡−k∗r^−1(modp)

代入k和r

i^−1≡−⌊p/i⌋∗(p mod i)^-1   (modp)

由于逆元一定是整数，那么我们在等式左右同时乘以(p mod i)^-1倍的p，由于在模p意义下，等式依然成立

最终状态：

inv[i] = (p - p / i) * inv[p % i] % p;（inv指逆元）

附上本算法的代码：

```cpp
#include<cstdio>
using namespace std;
long long p,c[3000005];
int main()
{
    long long n;
    scanf("%lld%lld",&n,&p);
    c[1]=1;
    printf("1\n");
    for(register int i=2; i<=n; i++)
    {
        c[i]=(p-p/i)*c[p%i]%p;
        printf("%lld\n",c[i]);
    }
    return 0;
}
```

看似第二种算法时间复杂度十分可观，但是递推算法毕竟有它的局限性，如果计算大数据就会爆空间，如果不开数组就会耗费大量的时间，考场上还是要选择适合的进行使用嘞！！

---

## 作者：KDL_橙子 (赞：2)

## **论如何优化你的时间：**

你只需要把cout<<endl;改成**cout<<'\n';**就可以啦！！！

有了'\n' 读入优化都不用了

~~读入优化只会让你多A一个点~~

没错，就是这么的神奇！！！

轻松49分  到  **AC绿**

[49分](https://www.luogu.org/recordnew/show/9441425)

[AC绿](https://www.luogu.org/record/show?rid=9441694)

### 证明如下：

![](https://cdn.luogu.com.cn/upload/pic/27309.png)

------------



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long a,b,s[3000003]; //s[i]代表i在mod p 意义下的逆元
int main ()
{
    cin>>a>>b;
    s[1]=1;
    cout<<s[1]<<'\n';
    for(int i=2;i<=a;i++)
	{
		s[i]=b-b/i*s[b%i]%b;//递推公式
		cout<<s[i]<<'\n';//线性边推边输出，记住一定不能用endl!!!
	} 
    return 0;
}
```

### 如果你不会这么VAN~~这虾米玩意~~的话,ex_gcd也是可以的

~~这个地方我也被endl卡了半小时~~

[49分ex_gcd](https://www.luogu.org/record/show?rid=9439603)

[AC绿ex_gcd](https://www.luogu.org/record/show?rid=9443190)

ex_gcd代码如下：

```cpp
#include<iostream>
using namespace std;
int a,b;
void exgcd(int a,int b,int &x,int &y)
{
    if(b)
    {
        exgcd(b,a%b,y,x);
        y-=(a/b)*x;
    }
    else
    {
        x=1;y=0;
    }
}
int main ()
{
    int x,y;
    cin>>a>>b;
    for(int i=1;i<=a;i++)
    {
        exgcd(i,b,x,y);
        cout<<(x+b)%b<<"\n";
    } 
    return 0;
}

```

---

## 作者：wjy666 (赞：2)

其实有一种非常好理解的线性做法

首先算出1!~n!

然后费马小算出n!的逆元，再由$ n!^{-1}=(n+1)!^{-1}*(n+1) $ 倒推 1!~(n-1)! 的逆元

最后由 $ x^{-1}=x!*(x-1)!^{-1} $ 求出1~n的逆元
```cpp
#include<bits/stdc++.h>
#define ll long long
#define For(i,j,k) for(register int i=j;i<=k;i++)
using namespace std;
int read(){
    int x=0,l=1; char ch=getchar();
    while(!isdigit(ch)) {if (ch=='-') l=-1; ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*l;
}
int l,buf[10],mo,n; ll c;
void write(int x){
    l=0;
    while(x) buf[++l]=x%10,x/=10;
    if(!l) l=1,buf[1]=0;
    while(l) putchar('0'+buf[l--]);
    putchar('\n');
}
int ksm(ll a,int b){
    c=1;
    while(b){
    	if (b&1) c=(c*a)%mo;
    	a=(a*a)%mo; b>>=1;
    }
    return c;
}
ll a[3000005],ny[3000005];
int main(){
    n=read(),mo=read(); a[1]=1;
    For(i,2,n) a[i]=a[i-1]*i%mo; ny[n]=ksm(a[n],mo-2);
    for(int i=n-1;i>=1;--i) ny[i]=ny[i+1]*(i+1)%mo; printf("1\n");
    For(i,2,n) write(a[i-1]*ny[i]%mo);
    return 0;
}
```

---

## 作者：liuzhangfeiabc (赞：2)

nlogn果断跑t，又不会线性求逆元，于是瞎推了一个式子出来qwq

看了一圈好像还没有类似思路的题解

设a[i] = 1\*2\*……\*i = i!，b[i] = i \* (i+1) \* …… \* n = n! / (i - 1)!（原谅我不会插入公式），显然可以O(n)预处理，顺便再预处理一个n!^-1，用扩欧或费马都行

那么我们有：i^-1 = a[i - 1] \* b[i + 1] \* n!^-1

于是就能线性算啦

上丑陋的代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p;
long long a[3000010],b[3000010];
long long ksm(long long q,long long w){
    long long z = 1;
    while(w){
        if(w & 1) z = z * q % p;
        q = q * q % p;
        w >>= 1;
    }
    return z;
}
int main(){
    scanf("%d%d",&n,&p);
    int i,j,k;
    a[0] = 1;
    for(i = 1;i <= n;i++){
        a[i] = a[i - 1] * i % p;
    }
    b[n + 1] = 1;
    for(i = n;i;i--){
        b[i] = b[i + 1] * i % p;
    }
    long long s = ksm(a[n],p - 2);
    for(i = 1;i <= n;i++){
        printf("%lld\n",s * a[i - 1] % p * b[i + 1] % p);
    }
    return 0;
}
```

---

## 作者：HoshiuZ (赞：2)

## 乘法逆元
定义：若整数$b$，$p$互质，并且$b|a$，则存在一个整数$x$，使得$a/b=ax(mod p)$。称x为b的模$p$乘法逆元，记为$b^{-1} (mod p$)。（定义来自《信息学奥赛一本通提高篇》）

------------

## 求法
那么该如何求出这个x呢?

①
- 由定义，$a/b=ax(mod\ p)$
- 两边同时乘$b/a$，得$1=bx(mod\ p)$
- 则$bx=1(mod\ p)$

这个同余方程可以转化为不定方程$bx+py=1$（假设$bx=-yp+1$），而$b$与$p$又互质，即$gcd(b,p)=1$，那么就可以用扩展欧几里得算法求出$x$。

②
- 费马小定理：$a^p=a(mod\ p)$   （p为质数）
- 若$p$为质数，则$b^p=b(mod\ p)$
- 两边同时除以$b$，得$b^{p-1}=1(mod\ p)$
- 两边同时乘$a$，得$a=a*b^{p-1} (mod\ p)$
- 两边同时除以b，得$a/b=a*b^{p-2} (mod\ p)$
- 由定义，此时$x=b^{p-2}$

则直接求出$b^{p-2}$即可

③（来自《信息学奥赛数学一本通》）
- $1^{-1}=1(mod p)$
- 设$p=k*i+r$,$r<i$,$l<i<p$，将此式放到$mod\ p$意义下会得到：$ki+r=0(mod\ p)$
- 两边同时乘$i^{-1}$，$r^{-1}$，可得：
- $k*r^{-1}+i^{-1}=0 (mod\ p)$
- $i^{-1}=-k*r^{-1} (mod\ p)$
- $i^{-1}=-[p/i]*(p\ mod\ i)^{-1} (mod\ p)$

由此，假设$A[i]$表示i的逆元，则$A[i]=-[p/i]*A[p\ mod\ i]$。

------------

### P3811 【模板】乘法逆元
① 本题保证了$p$是质数，那么直接就可以用扩展欧几里得算法求出$ix+py=1$的最小正整数解x即可。$(1<=i<=n)$
#### ①代码
（超时，48分）
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,p;

void Exgcd(int a,int b,int& d,int& x,int& y) {
	if(b==0) {
		d=a;
		x=1;
		y=0;
	}
	else {
		Exgcd(b,a%b,d,x,y);
		int t=x;
		x=y;
		y=t-a/b*y;
	}
}

int main() {
	cin>>n>>p;
	
	for(int i=1;i<=n;i++) {
		int d,x,y;
		Exgcd(i,p,d,x,y);
		cout<<((x%p)+p)%p<<endl;
	}
	
	return 0;
}
```

------------

②保证p是质数了，直接利用快速幂求出i^(p-2)即可，求的过程中注意取模p
#### ②代码
（超时，48分）
```cpp
#include<bits/stdc++.h>

using namespace std;

long long n,p;

long long quickpow(long long x,long long y) {
	if(y==0) return 1;
	long long t=quickpow(x,y/2)%p;
	if(y%2) return (t*t*x)%p;
	else return (t*t)%p;
}

int main() {
	cin>>n>>p;
	
	for(int i=1;i<=n;i++) cout<<quickpow(i,p-2)<<endl;
	
	return 0;
}
```

------------
③初始化$A[1]=1$，然后递推求解即可

这道题很能体现cout和printf的速度，一开始我用的cout输出结果超时64分，改为printf就满分了

（满分）
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,p;
long long a[3000010];

int main() {
	cin>>n>>p;
	
	a[1]=1;
	for(int i=2;i<=n;i++) {
		a[i]=-(p/i)*a[p%i];
		if(a[i]<0) a[i]=a[i]%p+p;
	}
	
	for(int i=1;i<=n;i++) printf("%d\n",a[i]);
	
	return 0;
}
```

------------


## 总结
乘法逆元的用处在哪呢？

当在题目中遇到了$a/b$这样的除法算式要求对p取模时，可以先将$a$，$b$分别对$p$取模，然后再计算出$b^{-1}$，那么$(a/b)\ mod \ p$就可以转化为$(a*b^{-1})\ mod\ p$，作为最后的结果，但前提条件是$b$与$p$互质。

---

## 作者：Ryan_ (赞：1)

**逆元的概念**

看过一些人的题解，发现他们对逆元的定理有所不同，我在这里概括一下教科书上的定义吧

**逆元**

若整数b，m互质，并且b|a，则存在一个整数x，使得a/b≡a*x（mod m）。
称x为**b的模m乘法逆元**，记为b^(-1)（mod m）。

**逆元的应用**

```
用于求解a/b≡（mod m）的值
```



这道题有很多解法，刚看到题目就想到了**扩展欧几里得定理求乘法逆元**

求解同余方程即可：b*x≡1（mod m） ，解法与同余方程那题就一样了

但是提交上去发现最后一个点完美的TLE了，只好转换思路

试试用**费马小定理**求解一个快速幂？显然**复杂度nlog（p）**不允许

下面有一个非常优秀的解法，复杂度O（n），~~貌似和Lucas定理有点关系~~

**线性求所有逆元**

~~突然发现LaTeX真是个好东西，可惜我不会，不过在学，现就放个截图吧~~

![](https://b2.bmp.ovh/imgs/2019/08/f1aaa100a24737d4.png)



80分扩欧代码：

略

100分线性递推代码：
```
#include<cstdio>
using namespace std;
long long inv[3000010],p,n;
int main() {
	inv[1] = 1;
	scanf("%d%d",&n,&p);
	printf("1\n");
	for(int i = 2; i <=n; i++)
		inv[i]=p-(p/i)*inv[p%i]%p,printf("%d\n",inv[i]);
		
	return 0;
}

```



---

## 作者：JustinRochester (赞：1)

[题目](https://www.luogu.org/problem/P3811)

线性递推逆元没必要这么复杂吧......

**【分析】**
---

设$Inv_i$ 为 $i$ 的逆元， $Fac_i$ 表示在膜 $p$ 意义下的 $i!$ ，$InFac_i$ 为 $Fac_i$ 的逆元

由于 $n<p,p\in prime$ ，所以 $Fac_1$ ~ $Fac_n$ 肯定是可以递推的

公式： $Fac_i=Fac_{i-1}\times i\% p,Fac_0=1$

其次，根据费马小定理，易得：

${Fac_n}^{p-1}\equiv 1(\mod p)$

又$\ \because\quad InFac_n\times Fac_n\equiv 1(\mod p)$

$\therefore InFac_n={Fac_n}^{p-2}\%p$

用快速幂算出 $InFac_n$ ，就可以递推出 $InFac_1$ ~ $InFac_n$ 了

公式：$InFac_i={Fac_i}^{-1}=[Fac_{i+1}\times (i+1)^{-1}]^{-1}={Fac_{i+1}}^{-1}\times (i+1)$

即：$InFac_i=InFac_{i+1}\times (i+1)\% p$

故 $Inv_i=i^{-1}=[i!\times{(i-1)!}^{-1}]^{-1}={i!}^{-1}\times (i-1)!$

即 $Inv_i=InFac_i\times Fac_{i-1}\% p$

第一次推 $Fac_i$ 是 $O(n)$ 的

第二次算 $InFac_n$ 是 $O(\log p)$ 的

第三次推 $InFac_i$ 是 $O(n)$ 的

第四次推 $Inv_i$ 也是 $O(n)$ 的

总复杂度为 $O(n)+O(\log p)+O(n)+O(n)=O(n)$

---

**【代码】**
---

那本蒟蒻就放  ~~我码风极丑的~~  代码了

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
typedef long long int i64;
const i64 MAXN=3000010;
typedef i64 ar[MAXN];
i64 d_N,d_P;
ar ar_d_Fac,ar_d_InFac;

inline i64 pow(i64 a,i64 x,i64 MOD){
    i64 d_Ans=1;
    while(x){
        if(x&1) d_Ans=d_Ans*a%MOD;
        x>>=1;
        a=a*a%MOD;
    }
    return d_Ans;
}

int main(){
    scanf("%lld %lld",&d_N,&d_P);
    ar_d_Fac[0]=1;
    f(i,1,I,d_N) ar_d_Fac[i]=ar_d_Fac[i-1]*i%d_P;
    ar_d_InFac[d_N]=pow(ar_d_Fac[d_N],d_P-2,d_P);
    g(i,d_N-1,I,0) ar_d_InFac[i]=ar_d_InFac[i+1]*(i+1)%d_P;
    f(i,1,I,d_N) printf("%lld\n",ar_d_InFac[i]*ar_d_Fac[i-1]%d_P);
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：Paul·Shi (赞：1)

# 定义

在  mod p的意义下我们把 xx 的乘法逆元写作 x ^ {-1}x

乘法逆元有如下的性质：

![](https://img-blog.csdn.net/20161115133003092)

乘法逆元的一大应用是模意义下的除法，除法在模意义下并不是封闭的，但我们可以根据上述公式，将其转化为乘法。

![](https://img-blog.csdn.net/20161115133024514)

# 解法一：【扩展的欧几里得（exgcd）】

## 求单个数的乘法逆元的时间复杂度为O（log N）

![](https://img-blog.csdn.net/20161115133307705)
的一组整数解

当 b 为素数时，gcd(a,b)=1  gcd(a,b)=1，此时有

![](https://img-blog.csdn.net/20161115133427062)

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,p;
int exgcd (ll a,ll b,ll &x,ll &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    int r=exgcd (b,a%b,x,y);
    int tmp=x;
    x=y;
    y=tmp-a/b*y;
    return r;
}
int main()
{
    scanf ("%d%d",&n,&p);
    for (int i=1;i<=n;i++)
    {
        ll x,y;
        exgcd (i,p,x,y);
        x=(x+p)%p;
        printf ("%d\n",x);
    }
    return 0;
}
```

# 解法二：【线性递推法】

## 在求一个序列所有逆元时间复杂度为O（N）

![](https://img-blog.csdn.net/20161115133621303)


![](https://cdn.luogu.com.cn/upload/pic/19724.png)


以上摘自[乘法逆元的几种计算方法](https://blog.csdn.net/rain722/article/details/53170288)

```cpp
#include<bits/stdc++.h>
#define ll long long
int inv[3000010];
int n,p;
int main()
{
	scanf ("%d%d",&n,&p);
	inv[1]=1;  
	for (int i=2;i<=n;i++)
		inv[i]=(ll)(p-p/i)*inv[p%i]%p;
	for (int i=1;i<=n;i++)
		printf ("%d\n",inv[i]);
	return 0;
}
```

---

## 作者：liangzihao (赞：1)

这题我也是醉了。一开始我先是打了个扩展欧几里得，然后T了两个点后，猛然发现p为素数。然后我又打了费马，还是T。一开有3\*10^6，你在逗我。还是去打一个筛法吧（蒟蒻还是去网上看的）。然后还是T了一个点。这是我把0..3000000的数组开到5000000就可以过了，还是800ms的，这就是传说中的空间换时间吗（233333）。下面就把代码发一下吧，毕竟模板题。


code：




```cpp
var
 n,p,ans:longint;
 i:longint;
 inv:array [0..5000001] of longint;
begin
 readln(n,p);
 inv[1]:=1;
 for i:=2 to n do
  inv[i]:=((p-p div i) mod p*inv[p mod i]) mod p;
 for i:=1 to n do
  writeln(inv[i]);
end.
```
扩展欧几里得的算法（想TLE的可以试试）：



```cpp
var
 n,i,j,p,x,y:longint;
procedure exgcd(a,b:longint; var x,y:longint);
var x1,y1:longint;
 begin
  if b=0 then
   begin
    x:=1;
    y:=0;
    exit;
   end;
  exgcd(b,a mod b,x1,y1);
  x:=y1;
  y:=x1-a div b*y1;
 end;
begin
 readln(n,p);
for i:=1 to n do
 begin
  exgcd(i,p,x,y);
  writeln((x+p) mod p);
 end;
end.
```
费马小定律求逆元（也会TLE哦哦）：



```cpp
var
 i,n,p,ans:longint;
function power(x,y:longint):longint;
 begin
  if y=1 then
   begin
    ans:=x;
    exit;
   end;
  power(x,y div 2);
  ans:=(ans*ans) mod p;
  if odd(y) then ans:=(ans*x) mod p;
 end;
begin
 readln(n,p);
 for i:=1 to n do
  begin
   power(i,p-2);
   writeln(ans);
  end;
end.
```

---

## 作者：ASC_8384 (赞：1)

可以倒着来。

先求出n！的逆元（用快速幂或扩欧），利用((k-1)!)^-1≡k·(k!)^-1 (mod p)，推出（n-1）！~1！的逆元，再利用k^-1≡(k-1)!·(k!)^-1 (mod p),求出每个数的逆元了


---

## 作者：Rumia (赞：0)

# 谁说扩欧过不了(

![](https://cdn.luogu.com.cn/upload/image_hosting/p42383hv.png)

首先，即使加上输入输出优化，一般递归形式的扩欧确实过不了(尾递归形式或许有可能，没测试）

但如果用递推形式的扩欧，对ax+by=gcd(a,b)只求x不求y，可以更快速的求逆元

这时加上输出优化，凭借评测机性能玄学，就能勉强过最后一个测试点（

以下是完整代码:

```c
#include <stdio.h>

char pc_buf[30000000], *pc_p= pc_buf;
#define pc(c) *pc_p++= c;

void write(int x) {
    static int sta[9];
    register int top= 0;
    do { sta[++top]= x % 10, x/= 10; } while(x);
    while(top) pc(sta[top--] ^ 48);
}

int inv(int a,int m){
    register int x=1,y=0,q=0,mod=m;
    while(1){
        if(m) y-=q*x,q=a/m,a-=q*m;
        else return a==1? (x<0? (x+mod)%mod : x) : 0;
        if(a) x-=q*y,q=m/a,m-=q*a;
        else return m==1? (y<0? (y+mod)%mod : y) : 0;
    }
}
int main(){
    int n,p;
    scanf("%d %d",&n,&p);
    for(register int i=1;i<=n;i++)
        write(inv(i,p)),pc('\n');
    fwrite(pc_buf,1,pc_p-pc_buf,stdout);
    return 0;
}   
```

求逆元代码:

```c
int inv(int a,int m){
    int x=1,y=0,q=0,mod=m;
    while(1){
        if(m) y-=q*x,q=a/m,a-=q*m;
        else return a==1? (x<0? (x+mod)%mod : x) : 0;
        if(a) x-=q*y,q=m/a,m-=q*a;
        else return m==1? (y<0? (y+mod)%mod : y) : 0;
    }
}
```

完整的递推扩欧代码:

```c
int gcdEx(int a,int b,int *x,int *y){
    *x=1,*y=0;
    int q=0,A=a,B=b;
    while(1){
        if(b) *y=*y-q**x,q=a/b,a-=q*b;
        else {
            *y=(a-A**x)/B;
            return a;
        }
        if(a) *x=*x-q**y,q=b/a,b-=q*a;
        else {
            *x=*y;
            *y=(b-A**x)/B;
            return b; 
        }
    }
}
```

其尾递归形式:

```c
int gcdExr(int A,int B,int *x,int *y){
    int gcdExi(int a,int b,int q,int c,int d){
        if(b==0){
            *x=d,*y=(a-A*d)/B;
            return a;
        }
        return gcdExi(b,a%b,a/b,d,c-q*d);
    }
    return gcdExi(A,B,0,0,1);
}
```


---

## 作者：Fizzmy (赞：0)

感觉这道题用阶乘做挺巧妙的，所以说决定水一发：


设$f(i) = i!\ mod\ p$ , $g(i) = i!^{-1}\ mod\ p$


$g(i) = g(i+1) * (i+1) $


$i^{-1} = f(i-1) * g(i)$


算出$f_n$然后求出$f_n$的逆元$g_n$，递推即可。


顺便宣传一波[博客](http://blog.csdn.net/charlie\_jilei/article/details/77122700)


代码：

```cpp

#include<cstdio>
#include<iostream>
using namespace std;
int mi[3000010];
int n,p;
int anss[3000100],g;
int fast_pow(int a,int x)
{
    int ans=1;
    for (;x;x>>=1,a=(1ll*a*a)%p)
        if (x&1) ans=(1ll*ans*a)%p;
    return ans;
}
int main()
{
    scanf("%d%d",&n,&p);
    mi[0]=1; 
    for (int i=1;i<=n;i++)
        mi[i]=(1ll*mi[i-1]*i)%p;
    g=fast_pow(mi[n],p-2);
    anss[n]=(1ll*g*mi[n-1])%p;
    for (int i=n-1;i;i--)
    {
        g=(1ll*g*(i+1))%p;
        anss[i]=(1ll*g*mi[i-1])%p;
    }
    for (int i=1;i<=n;i++)
        printf("%d\n",anss[i]);
}
```

---

## 作者：orange1287 (赞：0)

扩欧稳过不用优化

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int exgcd(int a,int b,int &x,int &y)
{
    if(a==0) {x=0;y=1;return b;}
    else
    {
      int tx,ty;
      int d=exgcd(b%a,a,tx,ty);
      x=ty-(b/a)*tx;
      y=tx;
      return d;
    }
}
int main()
{
    int n,p;scanf("%d%d",&n,&p);
    for(int i=1;i<=n;i++)
      {
        int x,y;
        exgcd(i,p,x,y);
        while(x<0) x+=p;
        printf("%d\n",x);
      }
    return 0;
}
```

---


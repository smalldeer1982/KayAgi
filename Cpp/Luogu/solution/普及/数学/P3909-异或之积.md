# 异或之积

## 题目描述

对于$A_1,A_2,A_3,\cdots,A_N$，求

$$(6\times \sum_{i=1}^N\sum_{j=i+1}^N\sum_{k=j+1}^N A_i\times A_j\times A_k) \bmod (10^9+7)$$


## 说明/提示

- 对于 $30\%$ 的数据，$N \le 500$；
- 对于 $60\%$ 的数据，$N \le 5000$；
- 对于 $100\%$ 的数据，$3 \le N \le 10^6$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
36```

# 题解

## 作者：hhoppitree (赞：61)

### 题意简述：  
给定序列 $a$，求 $6×\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}\sum\limits_{k=j+1}^{n}a_ia_ja_k$ 的值。  

### 题目解法：  
这里分享一种时间复杂度 $O(n)$，空间复杂度 $O(1)$，算上快读代码长度仅为 $549B$ 的做法。  

先推一波式子：  
$\ \ \ \ 6×\sum\limits_{i=1}^{n}\sum\limits_{j=i+1}^{n}\sum\limits_{k=j+1}^{n}a_ia_ja_k$  
$=6×\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i-1}\sum\limits_{k=1}^{j-1}a_ia_ja_k$  
$=6×\sum\limits_{i=1}^{n}a_i\sum\limits_{j=1}^{i-1}\sum\limits_{k=1}^{j-1}a_ja_k$  
$=6×\sum\limits_{i=1}^{n}a_i\sum\limits_{j=1}^{i-1}a_j\sum\limits_{k=1}^{j-1}a_k$    
然后 for 循环一遍，同时记录 $\sum\limits_{k=1}^{j-1}a_k$，再用 $\sum\limits_{k=1}^{j-1}a_k$ 来更新 $\sum\limits_{j=1}^{i-1}a_j\sum\limits_{k=1}^{j-1}a_k$，最后用 $\sum\limits_{j=1}^{i-1}a_j\sum\limits_{k=1}^{j-1}a_k$ 来更新答案 $\sum\limits_{i=1}^{n}a_i\sum\limits_{j=1}^{i-1}a_j\sum\limits_{k=1}^{j-1}a_k$   即可。  
值得注意的是这三个变量更新的顺序要注意，而且答案要记得 $×\space6$。  

**最后，记得开 long long !**
### 正确代码：  
```cpp
#include<bits/stdc++.h> 
#define int long long
#define mod 1000000007
using namespace std;
inline int read(){
	int res=0;
	bool zf=0;
	char c;
	while(((c=getchar())<'0'||c>'9')&&c!='-');
	if(c=='-')zf=1;
	else res=c-'0';
	while((c=getchar())>='0'&&c<='9')res=(res<<3)+(res<<1)+c-'0';
	return (zf?-res:res);
}
signed main(){
	int n=read(),sum1=0,sum2=0,sum3=0;
	for(register int i=1;i<=n;++i){
		int t=read();
		sum3=(sum3+sum2*t)%mod;
		sum2=(sum2+sum1*t)%mod;
		sum1=(sum1+t)%mod;
	}
	printf("%d\n",sum3*6%mod);
	return 0;
}
```

如果您没有看懂这篇题解，可以在评论区问我，我将会回答您的问题并且修改这篇题解，使它变得更加通俗易懂，服务更多的 $\text{OIer}$。  
如果您看懂了这篇题解，可以点个赞，使这篇题解的排名上升，服务更多的 $\text{OIer}$。  

---

## 作者：nekko (赞：24)

$$ \begin{aligned} &\sum_{i=1}^{n}\sum_{j=i+1}^{n}\sum_{k=j+1}^{n}a_ia_ja_k \\ =&\sum_{i=1}^{n}a_i\sum_{j=i+1}^{n}a_j\sum_{k=j+1}^{n}a_k \\ =&\sum_{i=1}^{n}a_i\sum_{j=i+1}^{n}a_jC_{j+1} \\ =&\sum_{i=1}^{n}a_iB_{i+1} \\ =&A_{1} \end{aligned} $$

从右往左扫，然后依次维护 $A,B,C$ 即可

---

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 10, mod = 1e9 + 7;

ll a[N], b[N], c[N];

int main() {
    int n; scanf("%d", &n);
    for(int i = 1 ; i <= n ; ++ i) {
        scanf("%lld", &a[i]);
        b[i] = c[i] = a[i];
    }
    for(int i = n ; i ; -- i) {
        c[i] = (c[i] + c[i + 1]) % mod;
        b[i] = (b[i] * c[i + 1] % mod + b[i + 1]) % mod;
        a[i] = (a[i] * b[i + 1] % mod + a[i + 1]) % mod;
    }
    printf("%lld\n", (6 * a[1] % mod + mod) % mod);
}

```

---

## 作者：sky_chen (赞：20)

看了下面dalao们的题解，都需要开数组，这里介绍一个无需数组的解法  
预备知识：排列,乘法分配律  
题目要求$(6×\sum^n_{i=1}\sum^n_{j=i+1}\sum^n_{k=j+1}a_i×a_j×a_k)mod(10^9+7)$的值,而$6$是本题的关键  
为什么？因为$i\ne j ,j\ne k,k\ne i$,于是想到全排列，而$A^3_3=6$  
太棒了，于是得到一个变形  
$(6×\sum^n_{i=1}\sum^n_{j=i+1}\sum^n_{k=j+1}a_i×a_j×a_k)mod(10^9+7)$  
$=(\sum^n_i\sum^n_j\sum^n_ka_ia_ja_k)mod(10^9+7)$  
$=(\sum^n_ia_i\sum^n_ja_j\sum^n_ka_k)mod(10^9+7)$(乘法分配律)  
$=((\sum^n_ia_i)(\sum^n_ja_j)(\sum^n_ka_k))mod(10^9+7)$  
$=(\sum^n_ia_i)^3mod(10^9+7))$(i,j,k等价)  
所以$O(n)$计算$\sum^n_ia_i$就可以了  
代码：
```cpp
#include<bits/stdc++.h>
# define m 1000000007
int main(){
    int n;
    scanf("%d",&n);
    int i;
    long long sum=0,j;
    for (i=0;i<n;i++) {
        scanf("%lld",&j);
        sum+=j;//10^15<maxlonglong
        	   //输入时计算，节约空间
    }
    printf("%lld",((sum*sum)%m*sum)%m);
}
```
## 然而这样会$WA$
(惨痛经历……)  
因为，有一件重要的事情被遗忘了  
再看一眼式子:  
$(\sum^n_ia_i)^3mod(10^9+7)$  
### 说好的$i\ne j,j\ne k,k\ne i$呢？
所以，要减去$i=j||j=k||i=k$的情况  
因为i,j,k等价，所以我们仅讨论$i=j$时的情况，再乘3即可  
式子变形：  
$((\sum^n_ia_i)^3-3(\sum^n_ia_i^2\sum_k^na_k))mod(10^9+7)$   
考虑到$i=j=k$只要计1次，实际计了3次，需要再变形：  
$((\sum^n_ia_i)^3-3(\sum^n_ia_i^2\sum_k^na_k)+2\sum^n_ia_i^3)mod(10^9+7)$   
而$\sum^n_ia_i,\sum^n_ia_i^2,\sum^n_ia_i^3$均能$O(n)$计算，于是，我们得到了正解(之一)  
真正的代码：
```cpp
#include<bits/stdc++.h>
# define m 1000000007
int main(){
    int n;
    scanf("%d",&n);
    int i;
    long long sum=0,mus=0,pus=0,j;
    for (i=0;i<n;i++) {
        scanf("%lld",&j);
        sum+=j;//10^15<maxlonglong
        mus+=(j*j)%m;
        pus+=(((j*j)%m)*j)%m;//输入时计算，节约空间
    }
    sum%=m;pus%=m;mus%=m;
    long long p=(((sum*sum)%m)*sum)%m,l=(3*mus*sum)%m,k=2*pus%m;
    printf("%lld",((p-l+k)%m+m)%m);
}
```


---

## 作者：hanzhongtlx (赞：8)

你确定没人用前缀和，后缀和吗？  
蒟蒻想法与众不同!      
我们实验$A[]={1,2,3,4}$。   
这里计不乘6时答案为$sum$.
$$sum=1×2×3+1×2×4+1×3×4+2×3×4$$
$$=(1+2)×3×4+1×2×(3+4)$$
你可以试试$n$更大的，比如6（懒得打了）。   
我们记$pre_i$为的$i$个数的前缀和，$suf_i$是后缀和，则：
$$sum=\sum_{i=1}^{n-2}pre_i×(i+1)×suf_{i+2}$$    
最后乘上6就好了。   
可以预处理，而我在计算中直接处理，降低了空间消耗。   
但迷惑的是不上快速乘只有$10pts$，不知为什么，~~我都取了那么多模了~~。   
下面上代码：
```
#include<iostream>
#include<cstdio>
using namespace std;
long long n,a[3000005];
long long x=0,y,z;
long long ans=0;
const int mod=1e9+7;
inline long long mul(long long x,long long y,long long mod)
{
	long long tmp=(x*y-(long long)((long double)x/mod*y+1.0e-8)*mod);
	return tmp<0 ? tmp+mod : tmp;
}//快速乘
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	z=a[n];
	y=a[n-1];//我这里把x作为前缀和，z是后缀和，动态更新，y没多少卵用
	for(int i=1;i<=n-2;i++)	x=x+a[i]%mod;
	for(int i=1;i<=n-2;i++)
	{
		ans=(ans+(mul(mul(x,y,mod),z,mod)))%mod;
		x=(mod+x-a[n-i-1])%mod;
		y=a[n-i-1]%mod;
		z=(z+a[n-i])%mod;
	}//计算就好了，没多少高深的东西
	printf("%lld",(6*ans%mod)%mod);//记得乘6
	return 0;
}
```
完结散花（求赞！）

---

## 作者：Flokirie (赞：6)

这题可以用更数学的方法做。

（时间复杂度：$\Theta(n)$,空间复杂度：$\Theta(n)$）

首先，我们将所求式子改写：

$6\sum _{i=1} ^N \sum _{j=i+1} ^N \sum _{k=j+1} ^N A_iA_jA_k$
$=3\sum _{i=1} ^N A_i(2\sum _{j=i+1} ^N \sum _{k=j+1} ^N A_jA_k)$......①

又因为

$2\sum _{j=i+1} ^N \sum _{k=j+1} ^N A_jA_k$

$=(\sum _{j=i+1} ^NA_j)^2-\sum _{j=i+1} ^NA_j ^2$

所以式①

$=3\sum _{i=1} ^N A_i[(\sum _{j=i+1} ^NA_j)^2-\sum _{j=i+1} ^NA_j ^2]$......②

这样我们开两个前缀和数组s和t：$s_x=\sum _{i=x} ^N A_i$和$t_x=\sum _{i=x} ^N A_i ^2$.($O(n)$时间和空间)

这样，$(\sum _{j=i+1} ^NA_j)^2=s_{i+1}^2$;$\sum _{j=i+1} ^NA_j ^2=t_{i+1}$.

式②可进一步化简为

$3\sum _{i=1} ^N A_i(s_{i+1}^2-t_{i+1})$

又是O(n)时间，完成。

----

按着这个思路写代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mod 1000000007ll

using namespace std;

void read(int &x){
	x=0;char s=getchar();
	while(s<'0'||s>'9')s=getchar();
	while(s>='0'&&s<='9')(x=x*10+s-'0'),(s=getchar());
}

void read(ll &x){
	x=0;char s=getchar();
	while(s<'0'||s>'9')s=getchar();
	while(s>='0'&&s<='9')(x=x*10+s-'0'),(s=getchar());
}

int n;
ll a[1000010];
ll s[1000010],t[1000010];//如题所述的前缀和

int main(){
	read(n);
	for (int i=1;i<=n;i++) read(a[i]);
	s[n]=a[n];t[n]=(a[n]*a[n])%mod;
	for (int i=n-1;i>0;i--){
		s[i]=(s[i+1]+a[i])%mod;
		t[i]=(t[i+1]+a[i]*a[i])%mod;
        //前缀和（模1000000007处理）
	}
	ll res=0;
	for (int i=1;i<=n;i++){
		res=(res+(a[i])*(((s[i+1])*s[i+1]-t[i+1])%mod))%mod;//乱模一气，能过就行
	}
	res=(3*res)%mod;//别忘乘3
	printf("%lld",res);
	return 0;
}
```

---

## 作者：用户已注销 (赞：6)

**沙发题解！**

//注：我讲的是我的想法，正解可能有十几种

分数分为三档，显然就是为O（N³），O（N²）和O（N）的算法而设立的。

题目比较直接的给了一个O（N³）的循环的公式，直接照搬就有30分。

\_-----30分到60分的分割线-----\_

接下来要做的就是优化这个循环公式，需要用到一些小学数学：

首先A（3,3）= 6，就是最前面那个常数6的意义

举个例子，6×A1×A2×A3=A1×A2×A3+A1×A3×A2+A2×A1×A3+A2×A3×A1+A3×A1×A2+A3×A2×A1

熟悉的同学就可以发现其实就是把1,2,3给全排列了一下，刚好有3×2×1=6种

所以要想拿到60分，需要进行一个O（N²）的预处理，加上一个O（N）的统计就可以了

预处理些什么呢？

看上面的例子，其实题目就是要求所有不同的三元组元素之积的总和。

（其中三元组即有3个不同元素的组合，3个相同的元素不同的顺序也可以）

先看O（N）的统计要统计一些什么：

对于每个Ai，需要往答案累加所有不同的（Ai×Aj×Ak），其中i,j,k互不相等，i不变，j,k**无大小顺序**

根据**乘法分配律**（这个不知道那你是真的强），也就是Ai×（所有不同的Aj×Ak之和）。

所以这个也就是我们要预处理的，因为我们枚举的是i，所以我们希望在O（1）的时间内求出“所有不同的Aj×Ak之和”

然后只要想象一下，就可以发现

#“所有不同的Aj×Ak之和（j,k都不等于i）”=“所有不同的Aj×Ak之和（j,k可以等于i）”-“所有不同的Ai×Ak之和”-“所有不同的Aj×Ai之和”

因为j和k是等价的，所以最后两项相等，于是就是

#“所有不同的Aj×Ak之和（j,k都不等于i）”=“所有不同的Aj×Ak之和（j,k可以等于i）”-“所有不同的Aj×Ak之和（j=i，k≠i）”×2

所以只要用一个常数记一下“所有不同的Aj×Ak之和（j,k可以等于i）”，开一个数组s记一下“所有不同的Aj×Ak之和（j=i，k≠i）”

就可以做到空间复杂度O（N），时间复杂度O（N²）的预处理，时间复杂度O（N）的统计，拿到60分。

\_-----马上就要满分了好激动啊-----\_

其实60分优化到100分简单得让你想哭，无非就是用**乘法分配律**优化一下预处理的过程

首先看一下怎么O（N）统计“所有不同的Aj×Ak之和（j,k可以等于i）”之和：

其实就是数组s的所有元素之和。。。

由于j=i或k=i，所以i分别取值1~n，再全部相加，就是“所有不同的Aj×Ak之和（j,k可以等于i）”

那么如何O（N）写出数组s呢？换句话说，对于每个i，如何O（1）得到“所有不同的Aj×Ak之和（j=i，k≠i）”呢？

其实已经非常明显了，“所有不同的Aj×Ak之和（j=i，k≠i）”=Ai×（所有不同的Ak（k≠i）之和）。

所以记一个常数sum为整个数组的和，O（N）计算一下sum，那么

“所有不同的Aj×Ak之和（j=i，k≠i）”=Ai×（sum-Ai）

于是O（N）预处理（计算sum和s数组和s数组所有元素的和），O（N）统计，总时间复杂度O（N）

-----为什么不贴代码呢？-----

因为题解又臭又长，肯定没人会看完的。如果贴了代码，总会有一些孩子就Ctrl+C了。

为了不害了他们，我的代码没有复制在这上面。

但是我可以跟你们保证：只要你们看了题解，60分一定是写的出来的。

达到60分，就可以去评测记录里搜索我的满分代码了（洛谷有代码公开计划，如果你没有加入，快加！）

保证代码和我的题解会一一对应息息相关。

顺便提示：最好开longlong以免计算过程会爆炸，最好边算边模（否则s数组的元素之和longlong也不够），模的时候加上模数再模！（不然WA一堆）

再顺便提示：10的六次方是一百万，我拿十万的数组教了n遍都是re


---

## 作者：B_1168 (赞：4)

拿到题目，得到了一个数列，要求求值；

不妨先照着公式，写个暴力看看吧：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long ans,n,a[5001];

int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++) for(int j=1+i;j<=n;j++) for(int k=1+j;k<=n;k++) ans+=((a[i]*a[j])%1000000007)*a[k]%1000000007;
    printf("%lld\n",6*(ans)%1000000007);
}
```
分数：无吸氧优化可得30pts，优化后能多卡一个点，得40pts

结合数据范围，推测两个得分更多的subtask复杂度分别为$O(n^2)$和$O(n)$；如果对如何优化感到一头雾水，不妨写个程序打打表，研究一下：

```cpp
for(int i=1;i<=n;i++) for(int j=1+i;j<=n;j++) for(int k=1+j;k<=n;k++) printf("%d %d %d\n",i,j,k);
```

取$n=6$时，我们会得到这些输出：

```
1 2 3
1 2 4
1 2 5
1 2 6
1 3 4
1 3 5
1 3 6
1 4 5
1 4 6
1 5 6
2 3 4
2 3 5
2 3 6
2 4 5
2 4 6
2 5 6
3 4 5
3 4 6
3 5 6
4 5 6
```

观察一下，是不是感觉，每一个$i,j$都会对最终的$ans$（最后的$ans*=6$不计入）产生$a_i\times a_j \times (\sum\limits_{k=j+1}^n a_k)$的贡献呢？

既然如此，干脆定义一个数组$sum$，使得$sum_i=\sum\limits_{k=i}^n a_k$，而求值时利用前后缀思想，可得：

```cpp
for(int i=n;i>=1;i--){
    sum[i]=a[i]+sum[i+1];
    sum[i]%=1000000007;
}
```

于是，就有了可得60pts的程序了：

```cpp
#include<bits/stdc++.h>
#define maxn 1000001
using namespace std;

long long n,ans,a[maxn],sum[maxn];

int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=n;i>=1;i--){
        sum[i]=a[i]+sum[i+1];
        sum[i]%=1000000007;
    }
    for(int i=1;i<=n;i++){
    for(int j=i+1;j<=n;j++){
            ans+=(((a[i]*a[j])%(1000000007))*(sum[j+1]))%1000000007;
        }
    }
    printf("%lld\n",6*ans%1000000007);
} 
```

我们此时留意到，每一个$i$对$ans$的贡献都是$a_i \times \sum\limits_{j=i+1}^n (a_j \times sum_{j+1})$，再次利用前缀和思想，即可整理出一个$pr$数组表达$\sum\limits_{j=i+1}^n a_j \times sum_{j+1}$，如下所示：

```cpp
for(int i=n;i>=1;i--){
    pr[i]+=pr[i+1]+(a[i]*sum[i+1]);
    pr[i]%=1000000007;
}
```

利用这个$pr$数组，我们便可以在$O(n)$的时间复杂度内求出我们所需要的$ans$了！请看AC程序：

```cpp
#include<bits/stdc++.h>
#define maxn 1000001
using namespace std;

long long n,ans,a[maxn],sum[maxn],pr[maxn];

int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    for(int i=n;i>=1;i--){
        sum[i]=a[i]+sum[i+1];
        sum[i]%=1000000007;
    }
    for(int i=n;i>=1;i--){
        pr[i]+=pr[i+1]+(a[i]*sum[i+1]);
        pr[i]%=1000000007;
    }
    for(int i=1;i<=n;i++) ans+=(a[i]*pr[i+1]),ans%=1000000007;
    printf("%lld\n",6*ans%1000000007);
} 
```
另：如希望测试更大数据点的，请点：[U117330 P3909 大测试点版](https://www.luogu.com.cn/problem/U117330)

感谢管理员的审核，如果觉得有用的话，欢迎点个赞再走qwq

---

## 作者：Limerick (赞：3)

今天,我们再引进一位大神:y大神.

首先,感谢yyr大神对我的启发(放心,yg大神还在)

我们先来说明一下题意:很简单,就是求(n个数三个三个相乘的积最终加起来的和)\*6 mod 1e+7

直接枚举肯定会超时,在这里我特别提醒一下新手,千万不要想着用O(n^3)的枚举去过此题,那是痴心妄想.

所以很明显,这是一题数论,怎么做呢,注意最后会mod 1e+7 这很容易让人想到前缀和是不是(可能是我的错觉)...

算了,不管怎样,这题是可以用前缀和的,怎么用呢,这就是y大神对我的启发了,我们开三个前缀和数组:

sum1,sum2,sum3分别记录前i个数一个一个相乘的积的和,两个两个相乘的积的和,三个三个相乘的积的和.

那么,怎么算呢:我们不难推出,这三个前缀和是有联系的,公式如下:

sum1[i]=sum[i-1]+a[i]//标准前缀和模板

sum2[i]=sum2[i-1]+sum1[i-1]\*a[i]//详情见下

sum3[i]=sum3[i-1]+sum2[i-1]\*a[i]//同上

那么,是怎么得出的呢:

我们想来看样例:

a: 1 2 3

sum1:1 3 6

sum2:0 2 11

sum3:0 0 6

sum1就不需解释了,前i个数一个一个相乘的积的和就是前缀和

我们来看sum2:sum2[i]=sum2[i-1]+sum1[i-1]\*a[i]

因为sum1[i-1]=a[1]+a[2]+......+a[i-1]

所以sum1[i-1]\*a[i]=a[1]\*a[i]+a[2]\*a[i]+......+a[i-1]\*a[i]

所以sum2[i]=sum2[i-1]+a[1]\*a[i]+a[2]\*a[i]+......+a[i-1]\*a[i]

那么sum2[i+1]=sum2[i]+sum1[i]\*a[i+1]

因为sum1[i]=a[1]+a[2]+.......+a[i]

所以sum1[i]\*a[i+1]=a[1]\*a[i+1]+a[2]\*a[i+1]+.......a[i]\*a[i+1]

所以sum2[i+1]=sum2[i]+a[1]\*a[i+1]+a[2]\*a[i+1]+.......a[i]\*a[i+1]

所以sum2[i+1]=sum2[i-1]+a[1]\*a[i]+a[2]\*a[i]+......+a[i-1]\*a[i]+a[1]\*a[i+1]+a[2]\*a[i+1]+.......a[i]\*a[i+1]

=sum2[i-1]+(a[1]+a[2]+.......+a[i-1])\*(a[i]+a[i+1])+a[i]\*a[i+1]=前i个数两个两个相乘的积的和

不信的读者可以自己动手尝试一下.

接着来看sum3:sum3[i-1]+sum2[i-1]\*a[i]

同理证明此式是对的.

同样,不信的读者可以自己试一下.

公式都证明完毕,但是,还有但是！！！聪明的读者会问了,这组样例只有三个数,是特殊样例啊,好,为了再次证明这个性质是完全正确的,接下来我们再测试一组样例

输入:

n=4
a:1 2 3 4

sum1:1 3 6 10

sum2:0 2 11 35

sum3:0 0 6 50

最后输出:300

是不是很神奇呢？

本段文字借鉴了https://www.luogu.org/space/show?uid=41485#wiki\_list

好了,闲话少叙,贴上AC代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<ctime>
using namespace std;
```
/\*
P3909 异或之积 题解

\*/
```cpp
const int N=1000005,mod=1e9+7;
long long n,i,x,sum1[N],sum2[N],sum3[N];
int main(){
    scanf("%lld",&n);
    for(i=1;i<=n;i++){
        scanf("%lld",&x);
    sum1[i]=(sum1[i-1]+x)%mod;//sum1[i]=sum[i-1]+a[i] 详情见分析
    sum2[i]=(sum2[i-1]+sum1[i-1]*x)%mod;//sum2[i]=sum2[i-1]+sum1[i-1]*a[i] 详情见分析
        sum3[i]=(sum3[i-1]+sum2[i-1]*x)%mod;//sum3[i]=sum3[i-1]+sum2[i-1]*a[i] 详情见分析
    }
    printf("%lld",(6*sum3[n])%mod);//最后将sum3的最后一个元素*6取模输出即可
    //system("pause");
    return 0;
}

```

---

## 作者：ESTELLE_1017 (赞：2)

##前言

这道题我是找规律找的。

##证明如下：

首先我们枚举(a[1]*a[2])开始的式子：

a[1]*a[2]*a[3]+a[1]*a[2]*a[4]+...+a[1]*a[2]*a[n].

然后提取（a[1]*a[2]），可以得到：

(a[1]*a[2])*(a[3]+a[4]+...+a[n]).

于是我们用一个前缀和数组f维护一下，f[i]表示前i个数的和。

```cpp
for(int i=1;i<=n;i++){
    f[i]=f[i-1]+a[i];
}
```

所以式子就变成了：

(a[1]*a[2])*(f[n]-f[2])

同样我们可以得到(a[1]*a[3])开始的式子：

(a[1]*a[3])*(f[n]-f[3])

所以以a[1]开始的式子为：

a[1]*(a[2]*(f[n]-f[2])+a[3]*(f[n]-f[3])+...+a[n]*(f[n]-f[n]))

去括号得到：

a[1]*(a[2]*f[n]+ a[3]*f[n]+ ...+ a[n]*f[n]- a[2]*f[2]- a[3]*f[3]- ...- a[n]*f[n])

提取一个f[n]可以得到：

a[1]*(f[n]*(a[2]+a[3]+...+a[n])-a[2]*f[2]-a[3]*f[3]-...-a[n]*f[n])

然后我们再定义一个数组c,c[i]表示前i个（a[i]*f[i])的和。

```cpp
for(int i=1;i<=n;i++){
    c[i]=c[i-1]+(a[i]*f[i]);
}
```

所以式子又变为：

a[1]*(f[n]*(f[n]-f[1])-(c[n]-c[1]))

然后我们就可以通过a[1]的例子推导出公式：

ans=ans+(a[i]*(f[i]*(f[n]-f[i])-(c[n]-c[i]));

然后我们就可以O(n)枚举求出结果了。

##补充

记得开long long ，然后%mod之前先加mod，（其实有些题解没有加上mod，但

是我的不加就会WA，可能我比较弱吧）


##下面赋上代码（因为WA了几次所以疯狂%，略丑勿怪）：

```cpp
#include<bits/stdc++.h>
#define N 1000005
const long long p=1e9+7;
using namespace std;
long long n,ans,a[N],f[N],c[N];
inline long long read(){
  long long r=0,t=1,c=getchar();
  while(c<'0'||c>'9'){
    t=c=='-'?-1:1;
    c=getchar();
  }
  while(c>='0'&&c<='9'){
    r=r*10+c-48;
    c=getchar();
  }
  return r*t;
}//快读
int main(){
  n=read();
  for(int i=1;i<=n;i++)
    a[i]=(read()+p)%p,f[i]=((f[i-1]+a[i])+p)%p;
  for(int i=1;i<=n;i++)
    c[i]=((c[i-1]+((f[i]*a[i])+p)%p+p)%p+p)%p;
  for(int i=1;i<=n-2;i++){
    ans=((ans+(((a[i]+p)%p)*((((((f[n]-f[i])+p)%p)*(f[n]%p))%p)-(((c[n]-c[i])+p)%p+p)%p))%p)+p)%p;
  }
  ans=((ans*6)+p)%p;
  printf("%lld",(ans+p)%p);
  return 0;
}

```

---


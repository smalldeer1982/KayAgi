# [NOIP 2017 提高组] 小凯的疑惑

## 题目背景

NOIP2017 提高组 D1T1

## 题目描述

小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？

注意：输入数据保证存在小凯无法准确支付的商品。


## 说明/提示

【输入输出样例 1 说明】

小凯手中有面值为 $3$ 和 $7$ 的金币无数个，在不找零的前提下无法准确支付价值为 $1,2,4,5,8,11$ 的物品，其中最贵的物品价值为 $11$，比 $11$ 贵的物品都能买到，比如：

$12 = 3 \times 4 + 7 \times 0$；

$13 = 3 \times 2 + 7 \times 1$；

$14 = 3 \times 0 + 7 \times 2$；

$15 = 3 \times 5 + 7 \times 0 $。


【数据范围与约定】

对于 $30\%$ 的数据： $1 \le a,b \le 50 $。

对于 $60\%$ 的数据： $1 \le a,b \le 10^4 $。

对于$ 100\%$ 的数据：$1 \le a,b \le 10^9 $。


## 样例 #1

### 输入

```
3 7```

### 输出

```
11
```

# 题解

## 作者：Mzwuzad (赞：514)

### 题目描述


小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在小凯无法准确支付的商品。


### 题目链接


[NOIP2017 小凯的疑惑](https://www.luogu.org/problemnew/show/3951)


### 题解


不妨设 $ a < b $


假设答案为 $ x $


若

$$ x \equiv ma \pmod b (1 \leq m \leq b - 1) $$


即

$$ x = ma + nb (1 \leq m \leq b - 1) $$


显然当 $ n \geq 0 $ 时 $ x $ 可以用 $ a, b $ 表示出来，不合题意。


因此当 $ n = -1 $ 时 $ x $ 取得最大值，此时 $ x = ma - b $。


显然当 $ m $ 取得最大值 $ b - 1 $ 时 $ x $ 最大，此时 $ x = (b - 1)a - b = ab - a - b $


因此 $ a, b $ 所表示不出的最大的数是 $ ab - a - b $


### 代码


```cpp
#include <cstdio>

typedef long long ll;

int main(int argc, char *argv[]) {
    freopen("math.in", "r", stdin);
    freopen("math.out", "w", stdout);

    int a, b;
    scanf("%d %d", &a, &b);
    printf("%lld\n", a * b - a - b);
    
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```

---

## 作者：infinityedge (赞：446)


#### 说明

这个做法是我在考场上想出来的 ex\_gcd 做法，当时并没有想到打表，所以向发表一下让大家彻底摆脱小学奥数带来的阴影，我现在仍然认为，ex\_gcd 是这道题的标算。

#### 题解

首先，我们发现这两个数是**互质**的，并且有**无限**个。很容易想到不定方程 $ax + by = gcd(a, b)$ ，其中 $gcd(a, b) = 1$ 。

然后我们考虑，对于所有可行的能被 $a$ 和 $b$ 表示出来的数 $k$ ，都存在 $x \geq 0, y \geq 0,ax + by = k$。

现在我们要构造的是**最大的不合法的数**，显然，这个数 $+ 1$ 一定是一个合法的数，转化成了求**最大的减一后不合法的数**。

由于这个数 $k$ 一定是合法的，所以满足性质

$$\exists x \geq 0, \exists y \geq 0,ax + by = k$$

那么如果 $k-1$ 合法，那么 $k - 1$ 可以表示成

$$a \left ( x - x' \right ) + b \left ( y - y' \right ) = k$$

或
$$a \left ( x - x'' \right ) + b \left ( y - y'' \right ) = k$$

其中 $x',y'$ 表示 $ax + by = 1$ 的 $x$ 最小且非负的整数解; $x'',y''$ 表示 $ax + by = 1$ 的 $y$ 最小且非负的整数解。

那么现在只需要让 $x - x'< 0$ 并且 $y - y'' < 0$ 即可

那么最后的**最大的减一后不合法的数**就是

$$a \left ( x' - 1 \right ) + b \left ( y'' - 1 \right ) $$

那么最后的**答案**就是

$$a \left ( x' - 1 \right ) + b \left ( y'' - 1 \right ) - 1$$

#### 证明：

首先充分性成立。

然后证明必要性：若$a \left ( x' - 1 \right ) + b \left ( y'' - 1 \right ) $不是**最大的减一后不合法的数**，那么一定存在一个更大的数，显然该数的 $a$ 的系数大于 $x' - 1$ 或 $b$ 的系数大于 $y'' - 1$ （如果都小于等于，那么该数不会比当前数大）。显然，减一后仍然是合法的。所以必要性成立。


综上， $a \left ( x' - 1 \right ) + b \left ( y'' - 1 \right ) - 1$ 是最大的不合法的数。


#### 代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;
typedef long long ll;


ll gcd(ll a, ll b){
    return b == 0 ? a : gcd(b, a % b);
}

void ex_gcd(ll a, ll b, ll &x, ll &y){
    if(b == 0){
        x = 1, y = 0; return;
    }
    ex_gcd(b, a % b, y, x);
    y -= (a / b) * x;
}

ll a, b;
int main(){


    cin >> a >> b;
    if(a > b) swap(a, b); 
    ll x, y;
    ex_gcd(a, b, x, y);
    if(x > 0){
        swap(a, b);
        swap(x, y);
    }
    ll tmp = (-x) / b;
    x = x + tmp * b;
    y = y - tmp * a;
    while(x < 0) x = x + b, y = y - a;
    while(x > 0) x = x - b, y = y + a;
    ll ans;
    ll xx2 = x + b;
    ans = a * (xx2 - 1) + b * (y - 1);
    cout << ans - 1 << endl;

    return 0;
}

```

---

## 作者：ghj1222 (赞：222)

本篇题解upd于2018年8月25日。

本篇题解的原题解有很多争议，在这里稍微补充一下：

假设两种钱的面额为$a$和$b$，且$\gcd(a,b)=1$。

假设两种钱每种最少要拿一次(也就是不能不拿)，那么不能凑成的最大钱数$k=a\times b$(注意是最大钱数，我刚才打错了)，由于可以不拿，那么就把多拿的两张钱减去，也就是$ans=k-a-b=a\times b-a-b$，其实这里大家都应该比较透彻，但是这个为什么$k=a\times b$我在下面证明一下。

现在我们需要证明$ax+by=k(x,y>0)$无解。

我们利用反证法，设$k=a\times b$，假设$ax+by=k(x,y>0)$有解。

那么根据欧几里得算法，$ax+by=s$($s$是任意整数)有解的条件是$\gcd(a,b)|s$。而这里$\gcd(a,b)=1$，满足条件。

我们假设找到了$ax+by=1$的一个解为$(x_0,y_0)$，那么就有$ax_0+by_0=1$。因为$a,b\ge1$，直觉告诉我们$x_0\le0$或者$y_0\le0$，这个不用我证明了吧。

等式两边同时乘以$k$，得到$akx_0+bky_0=k$，即$k=ax+by$的一个解为$(kx_0,ky_0)$，根据通解公式，通解为$\begin{aligned}\left(kx_0+\frac {bt} {\gcd(a,b)},ky_0-\frac {at} {\gcd(a,b)}\right)\end{aligned}(t\in \rm Z)$。因为$gcd(a,b)=1$，所以通解为$(kx_0+bt,ky_0-at)$。因为$k=a\times b>0$，而$x_0\le 0$或$y_0\le0$，所以$x\le0$或$y\le0$。当我们改变$t$的值时，把通解转化一下$(b(ax_0+t),a(by_0-t))$观察这个式子，我们会发现其中一定有一个会$\le0$的。我们继续转化，令$X=ax_0+t$，令$Y=by_0-t$，则$X+Y=1$。因为他们都是整数，所以$X\le0$或$Y\le0$的。而$a,b>0,x=aX,y=bY$，所以$x\le0$或$y\le0$，即$ax+by=k(x,y>0)$无解。

证毕。

---

为了严谨，我们还需要证明$ax+by=k+r(x,y>0,r$是正整数$)$有解。和上面思路差不多，为了严谨，我重新写一遍思路吧。

现在我们需要证明$ax+by=k+r(x,y>0,r$是正整数$)$有解。

那么根据欧几里得算法，$ax+by=s$($s$是任意整数)有解的条件是$\gcd(a,b)|s$。而这里$\gcd(a,b)=1$，满足条件。

我们假设找到了$ax+by=1$的一个解为$(x_0,y_0)$，那么就有$ax_0+by_0=1$。因为$a,b\ge1$，直觉告诉我们$x_0\le0$或者$y_0\le0$，这个不用我证明了吧。

等式两边同时乘以$k+r$，得到$a(k+r)x_0+b(k+r)y_0=k+r$，即$k+r=ax+by$的一个解为$(kx_0+rx_0,ky_0+ry_0)$，根据通解公式，通解为$\begin{aligned}\left(kx_0+rx_0+\frac {bt} {\gcd(a,b)},ky_0+ry_0-\frac {at} {\gcd(a,b)}\right)\end{aligned}(t\in \rm Z)$。因为$gcd(a,b)=1$，所以通解为$(kx_0+rx_0+bt,ky_0+ry_0-at)$即$(abx_0+rx_0+bt,aby_0+ry_0-at)$。现在我们需要证明他们俩都大于0有解。

我们还是转化一下，通解转化为$\begin{aligned}\left({b\left(ax_0+\frac{rx_0}b+t\right),a\left(by_0+\frac{ry_0}a-t\right)}\right)\end{aligned}$，注意这里的除法是实数除法。那么现在需要证明$\begin{aligned}ax_0+\frac{rx_0}b+t\end{aligned}$和$\begin{aligned}by_0+\frac{ry_0}a-t\end{aligned}$都大于0。令$X=\begin{aligned}ax_0+\frac{rx_0}b+t\end{aligned}$，$Y=\begin{aligned}by_0+\frac{ry_0}a-t\end{aligned}$，则$\begin{aligned}X+Y=ax_0+by_0+\frac{rx_0}b+\frac{ry_0}a=1+r\frac{ax_0+by_0}{ab}=1+\frac r {ab}>1\end{aligned}$。注意到这个式子中$X$和$Y$一定可以构造出$X$和$Y$都大于0的解。

为什么呢？这个其实很好想，你可以把$\begin{aligned}ax_0+\frac{rx_0}{b}\end{aligned}$和$\begin{aligned}by_0+\frac{ry_0}{a}\end{aligned}$想象成任意两个和大于1的实数，你每次可以做的操作是把他们其中一个加1另一个-1，那么他们一定可以同时为正。如何证明？我们建立一个坐标系$uOv$(实在没字母可用了)，然后建立参数方程$\begin{aligned}u=ax_0+\frac{rx_0}{b}+t\end{aligned}$，$\begin{aligned}v=by_0+\frac{ry_0}{a}-t\end{aligned}$，其中$t$是参数，$t\in\rm Z$，我们先假设$t\in\rm R$，那么方程就是一条斜率为$-1$的直线，因为$u+v>1$，所以直线在第一象限的长度大于$\sqrt2$。因为$t\in\rm Z$，$t\in\rm Z$时候的图像就是在$t\in\rm R$情况上的一系列间距为$\sqrt 2$的点，而$t\in\rm R$时候的图像在第一象限内长度大于$\sqrt2$，所以$t\in\rm Z$时候的图像在第一象限内存在点。

所以$x>0$并且$y>0$的解一定存在。

证毕。

备注：

原本大概的思路是我这么yy出来的，~~是我在上课走神的时候想出来的~~，据我回忆，大概是这么想的：见下(我脑洞可能比较大)

> 嗯这个$ans=a*b-a-b$这个$a$和$b$不是很透彻，移项移走。
>
> 变成了$ans+a+b=a*b$，嗯，就是把答案两种面值钞票各加一个不得了
>
> 那么不就变成了两种钞票每一种最少取一个了吗
>
> 这个结论好像挺对，发个题解吧。

然后就过了，然后评论里就有不透彻的和说这个思路不对的，但是我觉得我一开始想的时候是从正确的结果想回推的所以结论一定是对的就是这个证明.....当时没想出来

然而这道题我考试时候写的45pts暴力，(然后与省一无缘了)

这个反证法思路证明结论成立是评论里大佬@zyzzyzzyzzyz提供的，在此表示感谢。

不过他的反证法我没看懂，自己yy了一个= =

代码还是放一个吧。注意开long long

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

long long int a, b;

int main()
{
	scanf("%lld%lld", &a, &b);
    printf("%lld\n", a * b - a - b);
    return 0;
}
```
%dalao

至今本题解安全+透彻+清真+人品了，有不透彻(自己不透彻或者觉得题解有问题)可以发讨论/私信@ghj1222。以下是当时上课走神灵机一动的题解。

---

2018-02-21版本题解：

```
对于这道题的答案a * b - a - b 我有一个比较易懂的解释：

假设两种钱每种最少要拿一次（也就是不能不拿），不能凑成的最小钱数为k，因为a和b互质，显然,k = a * b，(当k = a * b 时，由于ab互质，要么a拿b个，要么b拿a个)。

由于a和b可以一样都不拿，所以ans = k - a - b = a * b - a - b

于是代码略。。。
```

---

## 作者：jszjinshengzhi (赞：107)

# Luogu P3951 小凯的疑惑(2017 TG Day1T1)

题意：给定正整数$a,b$满足$gcd(a,b)=$1，求最大的不能表示为$ax+by\ (x,y\in N)$的形式的。

数据范围：$1≤a,b≤10^9$

分析：题目虽然要求的是最大的不能表示为$ax+by$的形式的数，但我们可以通过这个数$+1$来求，我们设这个数为$n$，则有：

$n=ax+by\ (x,y\in N)$

我们再考虑$n-1$可以怎么表示。注意到$gcd(a,b)=1$，于是我们就可以把$n-1$中的$1$也用$a,b$的线性组合表示。

$n-1=ax+by-(ax_0+by_0)=a(x-x_0)+b(y-y_0)\quad$（这里$ax_0+by_0=1$）

由于$n-1$不能表示为$ax+by\ (x,y\in N)$的形式，所以$\forall (x_0,y_0),x-x_0<0$和$y-y_0<0$中至少有一个成立，即$x<x_0$和$y<y_0$中至少有一个成立。

首先，由$ax_0+by_0=1$，$x_0$和$y_0$必定不能同号。所以，当$x_0>0$时，$y_0\le0$，$y-y_0\ge y\ge0$，必须有$x-x_0<0$成立，即有$x<x'$（$x'$为最小的非负$x_0$），同理$y<y''$（$y''$为最小的非负$y_0$）。要注意的是，这里的$x',y''$并不是$ax_0+by_0=1$的一组解，而是相互独立的$x_0$最小的非负整数解和$y_0$最小的非负整数解。

因为我们要求的是$n$的最大值，$x,y$要尽量大，所以$x,y$均取最大值，即$x=x'-1,y=y''-1$

再将$(x',y'')$代入，即可得到$n=a(x'-1)+b(y''-1)$，即$Ans=a(x'-1)+b(y''-1)-1$

带一个$exgcd$先解出一组$(x_0,y_0)$，再算出$x',y''$，代入求解即可。

$Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long

ll t;
void exgcd(ll a,ll b,ll& x,ll& y){
	if(!b){
		x=1;
		y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	t=x;
	x=y;
	y=t-a/b*y;
}

ll a,b,x,y,xx,yy;
int main(){
	scanf("%lld%lld",&a,&b);
	exgcd(a,b,x,y);
	t=x/b;
	x-=t*b;
	y+=t*a;
	for(;x<0;)x+=b,y-=a;
	xx=x;
	for(;x>0;)x-=b,y+=a;
	yy=y;
	printf("%lld\n",a*(xx-1)+b*(yy-1)-1);
	return 0;
}
```

但是这并不是最优解，因为还有一个$ab-a-b$的神仙式子可以秒掉此题。其实我们可以将之前的式子$Ans=a(x'-1)+b(y''-1)-1$继续化简，把$x'$和$y''$给化掉。

因为$(x',y')$和$(x'',y'')$为不定方程$ax_0+by_0=1$的两组不同的解，所以我们就想办法把这两组解联系在一起。

注意到有$x''=x'+tb,y''=y'-ta(t\in Z)$

因为$(x'',y'')$为$y_0$最小且非负的解，易知$x''$最大且非正的$x_0$。而$x'$为最小且非负的$x_0$，那么这两组解就是连续的两组解了，也就是说$t=-1$，于是$y''=y'+a$

所以，$Ans=ax'-a+by''-b-1=ax'+by'+ab-a-b-1=ab-a-b$

#### ~~其实这个结论可以通过与exgcd无关且简单的多的方法证明~~

如果你~~足够欧皇~~稍微试一下的话，很容易发现，方程$ax+by=ab-a-b$有两组解$(b-1,-1),(-1,a-1)$，通过其通解形式$x=x_0+tb,y=y_0-ta$（$x_0,y_0$是方程的任意一组解）不难发现这是连续的两组解（因为$-1=(b-1)-b,a-1=-1+a$）。当$t$递增时，$x$递增，$y$递减，如果方程有非负整数解，必然会夹在这两组解中间，但这是连续的两组解，所以方程$ax+by=ab-a-b$没有非负整数解。

现在我们只需证明$\forall c>ab-a-b,ax+by=c$有非负整数解即可。

根据方程的通解$x=x_0+tb,y=y_0+ty$，并注意到$x=x_0+tb$可以换一种形式写出来：$x\equiv x_0\ (mod\ b)$，于是就很明显有：必存在一组解满足$0\le x\le b-1$。换句话说，对于任意一个不在这个范围里的$x$，我们可以将$x$一直进行加上$b$或者减去$b$的操作使$x$满足条件。将这个东西带进去用不等式~~瞎搞一通~~，有$ax\le ab-a,by=c-ax\ge c-ab+a>ab-a-b-ab+a=-b$，所以$b\cdot(y+1)>0$，又因为$b>0$，所以$y+1>0,y\ge0$。这样我们就构造出了任意$ax+by=c>ab-a-b$的非负整数解。

就这么没了？

~~就这么没了。~~

#### 这里再附加一个小结论：若$(a,b)=1$，则$0\thicksim ab-a-b$中恰有一半，即$\frac{(a-1)\cdot(b-1)}2$个数能表示为$(ax+by),x,y\in N$

证明：因为能表示的个数恰好为总数的一半，所以先猜个结论~~（大胆猜结论，不用验证）~~：$n$与$ab-a-b-n$中恰有一个能表示。

手动算两组，发现没毛病，那就开始证明。

证明很显然分为两部分：两个数不能都可以表示，两个数不能都不可以表示。

前者很显然，因为如果$n$与$ab-a-b-n$都能够表示，那么只用将它们加起来就能表示出$ab-a-b$，与前面的结论矛盾。

后者就很烦了。

首先$\%\%\%\ $[$ljc1301\ $](https://www.luogu.org/space/show?uid=36998)神佬，他的这个思路真的是太妙了。

设$ax+by=n$无非负整数解，然后问题就转化为了构造$ax+by=ab-a-b-n$的非负整数解。

怎么去构造呢？还是套路，构造出$ax+by=ab-a-b$与$ax+by=n$的特解，并利用这两组解的不等关系来构造。

注意到$ax+by=ab-a-b$有一组特解$x=b-1,y=-1$，于是我们的目标就变成了在另一条方程里面寻找能与这组解构成不等关系的特解。

我们将$ax+by=n$的通解写出来：$x=x_0+tb,y=y_0-ta$，可知存在一组解满足$0\le x\le b-1$，再根据我们一开始的假设，方程$ax+by=n$无非负整数解，而$x\ge0$，所以$y<0$，即方程$ax+by=n$有解$(x',y')$满足$0\le x'\le b-1,y'\le-1$。

将上述两个方程的解带进去，有$ab-a-b-n=a\cdot(b-1)-b-(ax'+by')=a\cdot(b-1-x')+b(-y'-1)$，而根据上面的不等式，$b-1-x'$与$-y'-1$均非负，即为方程的一组非负整数解。

$Q.E.D.$

---

## 作者：matsuk (赞：66)

#### 一种图论的理解方法: 同余类最短路.
令 $a<b$, 然后将所有的数按照对$a$取模的余数分成$a$个剩余类.
每个同余类看成一个点, 即 {$p[0], p[1], ..., p[a-1]$}. 
设$f[i]$为第$i$类数中最小的可以被表示出来的数, 则 $f[i]=k*a+i$. 
由于$a<b$， 对$i>0$来说, $k$一定大于$0$ (当$k=0$时$f[i]=i<a$, 显然不能被表示出来). 
而每一个$f[i]$都是由一个别的什么数加上$b$得到的(在模$a$意义下且$a$, $b$互质). 所以就可以从点$i$($0<=i<a$)向点$(i+b)$%$a$连一条长度为b的有向边(意味着加上$b$得到下一个数)， 然后就能转移了! 显然$f[0]=0$, 那么从$0$开始跑一个单源最短路, 球出每个剩余类中最小的可以被表示出来的数. 

可是, 球了这个有什么猫用吗??

如果$f[i]$是每个剩余类中最小的可以被表示出来的数, 那$f[i]-a$不就是最大的不能被表示出来的数吗!
可以理解成每个剩余类中的数都是$i+a$, $i+2*a$, $...$, 这样排列的($i>0$时). 假设求出来的$f[i]=i+x*a$, 那么之后的所有数都可以由它加上若干个$a$得出. 因此$i$+($x-1$)*$a$就是最大的不能被表示的数了. 在所有的$f[i]-a$($i>0$)里取最大就是答案. 

但是这题只让写两行代码, 怎么跑最短路??还不如打个循环暴力

于是手动模拟一波跑最短路的过程:
每个点都只有一条出边, $0$->($b$%$a$)->($2*b$%$a$)->...->(($a-1$)*$b$%$a$)->$0...$  形成了一个环. 这个很明显吧, 因为$a,b$互质. 所以最大的$f[i]$就是$f$[($a-1$)*$b$%$a$]. 边权都是 $b$ , 所以$f$[($a-1$)*$b$%$a$]=($a-1$)*$b$, 再减去一个$a$ 就得到了那个简短而凝聚着人类智慧结晶的公式: $a*b-a-b$

代码:
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
    long long a,b;
    cin>>a>>b;
    cout<<a*b-a-b;
    
}
```

---

## 作者：Hell0_W0rld (赞：4)

本文主要讲解如何证明 $ab-a-b$ 的上限。

## Part 1 当 $x=ab-a-b$ 时
考虑反证：

因为 $x\equiv -b\pmod a$ 且 $x\equiv -a \pmod b$，

若存在，则不妨设 $x=ma+nb$，

则 $x\equiv nb\equiv -b\pmod a$ 又 $n\geq 0,\gcd(a,b)=1$，可知 $n\geq a-1$。

所以 $x=ab-a-b\geq (a-1)\cdot b$，矛盾！

所以 $x=ab-a-b$ 是合法的解。
## Part 2 当 $x>ab-a-b$ 时
考虑反证：

若 $\exists x$ 使得 $\nexists m,n\in \mathbb{N},x=ma+nb$，则设 $x\equiv t\pmod a$。

则 $t\equiv nb\pmod a$，$n\equiv tb^{-1}\pmod a$。其中 $b^{-1}$ 表示 $b$ 在 $\bmod ~a$ 意义下的数论倒数。

必然存在一个 $n$ 使得 $n\in [0,a-1]$ 且 $n\equiv tb^{-1}\pmod a$，记为 $n_0$。此时 $x-bn_0\geq 0$ 且 $x-bn_0\equiv 0\pmod a$。记 $m_0=\frac{x-bn_0}{a}$，必有 $m_0\in \mathbb{N}$。

于是假设不成立，原命题成立。
***
综上我们可以得到答案记为 $ab-a-b$。代码就不放了。

---

## 作者：ljh0727 (赞：3)

# 小凯的疑惑

原题链接：[题目](https://www.luogu.com.cn/problem/P3951)

### 题目描述

小凯有两种面值的金币，面值分别是 $a$ 和 $b$，两种面值均为**正整数**且彼此**互素**，也就是 $a$ 和 $b$ 的最小公倍数为 $1$，然后小凯想找到一个无法准确支付的物品中，最**贵**的价值是多少金币。

### 思路

我们设价格为 $x$，设面值为 $a$ 的货币有 $m$ 张，设面值为 $b$ 的货币有 $n$ 张，那么 $x = am + bn$。

如果 $n \ge 0$，那么 $x$ 就一定可以被表示出来。

如果要满足 $x$ 最大，那么 $n$ 也得最大，因为 $n < 0$，所以我们可以令 $n = -1$，那么 $x = ma - b$，则 $x$ 取得最大值。

同理，我们也要使 $m$ 最大，若 $m \ge b$，那么 $x = (m - b)a + (n + a)b$，可以被表示出来。

因此，当 $m$ 取最大值 $b-1$，即当 $m = b - 1$ 时，$x$ 也为最大值，代入 $m = b - 1$ 则 $x = (b - 1)a - b$，也就是当 $x = ab - b - a$ 时，我们得到了 $a$ 和 $b$ 不能表示的最大值 $x$。

综上所述，$a$ 和 $b$ 不能表示的数的最大值为 $ab - b - a$。

### 代码


```cpp
#include<iostream> 
#include<cstdio>

using namespace std;
int main(){
	long long a,b;
    scanf("%lld%lld",&a,&b);
    printf("%lld",a*b-a-b);
	return 0;
}
```

~~求管理员通过~~

---

## 作者：yuxinrui0618 (赞：2)

# 题解：P3951 [NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目
## 1. 题目大意
- 两种金币，面值互质，都有无数个；
- 问在无法准确支付的物品中，最贵的价值是多少金币。

## 2. 思路
- 假设 $a<b$，两种面值分别用了 $n$ 个和 $m$ 个，本题答案为 $k$，可得：$k=na+mb$。  
- 显然，若 $m \ge 0$，则一定有整数能使等式成立，那么，可得 $m<0$。
- 此时，只要 $n$、$m$ 都为最大值，$k$ 就最大，很明显，当 $n=b-1$ 且 $m=-1$ 时，$k$ 最大，代入原式，得：$k=(b-1)a-b$，化简后为：$k=ab-a-b$。

## 3. 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long long a,b;
    cin>>a>>b;
    cout<<a*b-a-b;
    return 0;
}
```

## 4. 总结
谢谢观赏！  
若有不完善的地方还请各位大佬指出！

---

## 作者：chinazhanghaoxun (赞：2)

## 证明
不妨设 $a<b$，假设价格为 $x$，则 $x=ma+nb$。

若 $n\ge0$，则一定能用 $a$，$b$ 两种货币表示出来。

所以，$n<0$ 是必然的。此时当 $m$，$n$ 取最大值时才可以使 $x$ 取得最大值。

而 $m_{\max}=b-1$，$n_{\max}=-1$，所以此时的 $x_{\max}=a(b-1)-b=ab-a-b$。答案即为 $ab-a-b$。

## EX
这个定理其实有一个名称，叫作塞瓦维斯特定理，严谨的证明可以通过反证法和[裴蜀定理](https://oi-wiki.org/math/number-theory/bezouts/)证明。证明过程可以看看[这位大佬的](https://www.cnblogs.com/xxzh/p/9178564.html)，是很严谨的。
## 代码
这个题目的难度主要在于推公式，代码实在没有什么可解释的。
```cpp
#include<bits/stdc++.h>
#define int long long //记得开long long
using namespace std;
signed main(){
	int a,b;
	cin>>a>>b;
	cout<<a*b-a-b;
	return 0;
}
```

---

## 作者：cqsunny (赞：2)

证明过程不太严谨，如果想看详细过程，请看其他大佬的题解。

假设 $a < b$。

设价值为 $a$ 的金币有 $x$ 个，价值为 $b$ 有 $y$ 个，总价值为 $c$。

可以得到：$a\times x + b \times y = c$。

由于 $\gcd(a, b) = 1$，我们可以将上式 $\bmod$ $b$，得到同余方程 $a \times x \equiv c \pmod b$。

显然，$0 \le x < b$，否则会被模掉。

同理，还可以 $\bmod$ $a$，得到 $0 \le y < a$。

如果 $x \equiv 0 \pmod b$ 或 $y \equiv 0 \pmod a$，此时一定成立。

此时价值最少为 $a \times b$。

接下来考虑如何将 $a \times b$ 变成一个不满足条件的价值。

考虑在 $a \times b$ 的基础上，先减去一个 $b$，此时仍然成立，原式变为 $a \times b - b$。

这时要让 $(a - 1) \times b$ 不成立，让 $x$ 取 $b - 1$，$(a - 1) \times b - (b - 1) \times a = a - b $，$(a - b) \bmod b \ne 0$，因此一定不成立。

这样就凑出了答案：$a \times b - a - b$。

---

## 作者：qhr2023 (赞：1)

## solution

题意是给定两个互质的正整数 $a$ 和 $b$，求最大的不能用 $xa + yb$ 表示的整数，其中 $x$ 和 $y$ 是非负整数。

令 $a < b$，考虑 $x$ 的范围。当 $x = b$ 时，此时原式可以表示成 $0 \times a + (y + a) \times b$，实际上此时 $x=0$，当 $x = b+1$ 时，原式为 $1 \times a + (y+a) \times b$，此时 $x=1$。类似的，可以得出 $x$ 只在 $0$ 到 $b-1$ 的范围内取值，所以 $x$ 总是小于 $b$。

有了 $x<b$ 这个条件之后，考虑让原式无法表示，令 $y<0$ 即可。所以一个无法用 $xa + yb$ 表示的正整数（$x$ 和 $y$ 是非负整数），一定可以用 $na + mb$ 表示（$n<b$ 是非负整数，$m$ 是负整数）。

问题成了求 $na + mb$ 的最大值，其中 $a$ 和 $b$ 是定值，所以让 $n$ 和 $m$ 分别最大即可，即当 $n=b-1$，$m=-1$ 时，原式最大，答案就是 $(b-1) \times a + (-1) \times b$，即 $ab-a-b$。

---

## 作者：4041nofoundGeoge (赞：1)

## 思路

先抛结论：对于互质的两数 $a$ 和 $b$，对于两数组成的不定方程 $ax+by$，无解值最大为 $ab-a-b$。

证明：

由题意知，$a$ 和 $b$ 是互质的，即它们的最大公约数为1。根据互质数的性质，存在整数 $x_0$ 和 $y_0$ 使得 $ax_0 + by_0 = 1$。

对于任意整数 $k$，由第一步中的结论，我们可以得到 $ax + by = k$ 的一组解为 $x = kx_0$ 和 $y = ky_0$。这说明对于任意整数 $k$，方程 $ax + by = k$ 都有解。

考虑 $ax + by$ 不能表示的最小正整数 $m$。假设 $m$ 可以被 $a$ 除尽，即 $m = an$（其中 $n$ 是正整数）。由于 $a$ 和 $b$ 互质，根据互质数与整数的性质，存在整数 $x'$ 和 $y'$ 使得 $ax' + by' = 1$。那么 $m = an$ 可以表示为 $a(nx') + b(ny')$，即 $m$ 可以被 $ax + by$ 表示，这与 $m$ 的定义矛盾。因此，$m$ 不能被 $a$ 除尽，同理 $m$ 也不能被 $b$ 除尽。

考虑 $m + a$ 和 $m + b$：

* 由于 $m$ 不能被 $a$ 除尽，但 $m + a$ 可以被 $a$ 除尽，所以 $m + a$ 可以表示为 $ax + by$ 的形式。
* 同理，$m + b$ 也可以表示为 $ax + by$ 的形式。

由于 $m$ 是最小的不能表示的数，那么 $m + a$ 和 $m + b$ 表示的 $ax + by$ 形式中的 $x$ 和 $y$ 必须都是非负的（否则，我们可以通过减去 $a$ 或 $b$ 的倍数来得到一个更小的不能表示的数，这与 $m$ 的定义矛盾）。

考虑 $m$ 与 $ab$ 的关系：

* $m$ 小于 $a + b$（否则，$m - a$ 或 $m - b$ 会是一个更小的不能表示的数，与 $m$ 的定义矛盾）。
* $m$ 不能被 $a$ 或 $b$ 除尽，所以 $m$ 至少比 $a$ 和 $b$ 中的较小者大1。
* 假设 $m > ab - a - b$，则 $m + a > ab - b$ 和 $m + b > ab - a$。由于 $m + a$ 和 $m + b$ 都可以表示为 $ax + by$ 的形式，并且 $x$ 和 $y$ 都是非负的，那么根据带余除法的性质以及 $a$ 和 $b$ 的互质性，我们可以找到一种表示方式使得 $m$ 也可以被表示为 $ax + by$ 的形式（这需要通过具体的代数运算来证明，但在此省略了详细的计算过程），这与 $m$ 的定义矛盾。

由反证法可知，我们的假设 $m > ab - a - b$ 是错误的，所以 $m$ 必须小于或等于 $ab - a - b$。又因为 $m$ 是最小的不能表示的数，所以 $m$ 必须等于 $ab - a - b$（否则，如果存在一个比 $ab - a - b$ 更小的不能表示的数，那么它将会与 $m$ 的定义矛盾）。

证毕。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
  long long a,b;cin>>a>>b;
  cout<<a*b-a-b<<endl;
  return 0;
}
```

最后的奉告：**十年 OI 一场空，不开 long long 见祖宗！**

---

## 作者：3_14 (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P3951)

# 思路

1.  **证明 $ab-a-b$ 不能表示为 $a\times x+b\times y$ 的形式，其中 $x$ 和 $y$ 是非负整数。**
2.  **证明对于任意整数 $n\ge a\times b-a-b+1$，存在非负整数 $x$ 和 $y$ 使得 $n=a\times x+b\times y$。**

### Step1:

假设存在非负整数 $x$ 和 $y$ 使得 $a\times b-a-b=a\times x+b\times y$。重新排列得到：  
$$a\times b−a\times x−b\times y=a+b  $$
$$a\times \left ( b−x\right ) -b\times \left ( y+1\right ) =a+b$$

由于 $a$ 和 $b$ 是互素的，$a\times \left ( b−x\right ) -b\times \left ( y+1\right )$ 必须等于 $a+b$。假设 $x\ge b$ 或 $y\ge a$，则 $a\times \left( b-x \right)\le 0$ 或 $b\times\left(y+1\right)\ge a\times b$，这与等式的右边 $a+b$ 相矛盾。因此，必须有 $x<b$ 和 $y<a$。

考虑所有可能的 $x$ 和 $y$ 的组合，即 $0\le x<b$ 和 $0\le y<a$。这些组合共有 $a\times b$ 种。我们将每个组合 $a\times x+b\times y$ 对 $a\times b$ 取模，得到的结果一定在 $0$ 到 $a\times b-1$ 之间。由于 $a$ 和 $b$ 是互素的，这些结果一定是不同的。因此，这些结果覆盖了从 $0$ 到 $a\times b-1$ 的所有整数，除了 $a\times b-a-b$。

### Step2：

假设 $n\ge a\times b-a-b+1$。我们需要证明存在非负整数 $x$ 和 $y$ 使得 $n=a\times x+b\times y$。

考虑 $n=a\times b-a-b+k$，其中 $k\ge 1$。我们需要找到非负整数 $x$ 和 $y$ 使得：  
$$a\times x+b\times y=a\times b-a-b+k$$

我们知道 $a$ 和 $b$ 是互素的，根据裴蜀定理（Bézout's identity），存在整数 $x_0$ 和 $y_0$ 使得 $a\times x_0+b\times y_0=1$。我们可以将这个等式乘以 $a\times b-a-b+k$ 得到：  
$$a\times \left(b\times x_0\left(a\times b-a-b+k\right)\right)+b\times \left(a\times y_0\left(a\times b-a-b+k\right)\right)=a\times b-a-b+k$$

设 $x'=b\times x_0\left(a\times b-a-b+k\right)$ 和 $y'=b\times x_0\left(a\times b-a-b+k\right)$ ，则有：  
$a\times x'+b\times y'=a\times b-a-b+k$

接下来，我们需要调整 $x'$ 和 $y'$ 使得它们都是非负整数。注意到：  
$$x'=b\times x_0\left(a\times b-a-b+k\right)$$
$$y'=a\times y_0\left(a\times b-a-b+k\right)$$

我们可以利用 $a$ 和 $b$ 的互素性，通过适当的调整 $x'$ 和 $y'$ 来确保它们是非负整数。具体来说，我们可以对 $x'$ 和 $y'$ 进行取模运算，确保它们在 $0$ 到 $b-1$ 和 $0$ 到 $a-1$ 之间。

**所以对于两个互素的正整数 $a$ 和 $b$，无法用它们表示的最大整数是 $a\times b-a-b$。**

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
#define Made return
#define by 0
#define _3_14 ;
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+1;
ll a,b;
int main(){
    cin>>a>>b;
    if(a>b)swap(a,b);// 确保 a <= b
    cout<<a*b-a-b<<'\n';// 输出
	Made by _3_14
}
```

## 解释

1.  **输入**：
    
    *   读取两个整数 $a$ 和 $b$。
    *   为了方便后续计算，确保 $a \le b$，通过 $swap$ 函数交换 $a$ 和 $b$ 的值。

2.  **输出无法表示的最大整数**：
    *   根据公式 $a\times b-a-b$ 计算无法表示的最大整数。
    *   输出计算得到的结果。

### 注意

*   由于题目保证 $a$ 和 $b$ 是互素的，我们不需要额外判断这一点。
*   使用了 $swap$ 函数来确保 $a\le b$，这在某些情况下可以简化后续的逻辑处理，但在这个问题中并不是必须的。

## [AC记录](https://www.luogu.com.cn/record/197254399)

---

## 作者：Il1_1_3 (赞：0)

# P3951 题解

## 题意
两种面值分别为 $a,b$ 的金币，且 $(a,b)=1$，求用这两种金币所不能刚好付清的钱数的最大值。

## 思路
设 $a<b$，答案为 $ans(ans \ge a)$，令 $ans=ka+lb(1 \le k < b,l \in \mathbb{Z})^{\text{①}}$。

若 $l \ge 0$，则 $ans$ 可以用 $a,b$ 的整数倍表示出来，与题意不符。

则 $l < 0$，当 $l,k$ 分别取最大值 $-1,b-1$ 时可使 $ans$ 最大值为 $a(b-1)-b$ 即 $ab-a-b$。

## 代码实现
输入 $a,b$，输出 $ab-a-b$ 即可，这里就不给了。

### 注释
显然，若 $k \ge b$，则该式可化为 $a(k-b)+b(l+a)$，与题意不符。

---

## 作者：glass_goldfish (赞：0)

一道数论。

为了方便计算，我们可以假设 $a<b$（如果不是就互相交换即可）。然后，我们发现，题目就是让我们求以下方程中 $x$ 的最大值（$u,v$ 为整数，且解要**符合题意**，即 $x$ 不能被 $a$ 和 $b$ 表示）：
$$x\equiv au\pmod b(1\le u\le b-1)$$
为什么 $1\le u\le b-1$ 呢？因为如果 $u\ge b$，那么就会被直接模掉了。  
这个式子相当于下面的式子：
$$x=au+bv(1\le u\le b-1)$$
如果 $b\ge0$，那么说明 $x$ 是可以被 $a$ 和 $b$ 表示的，但是题目让我们求 $x$ 不能被 $a$ 和 $b$ 表示的最大值，所以这显然不是解。那么当 $b=-1$ 时，就符合题意了，此时的 $x=au-b$，因为要最大，所以 $u=b-1$，答案为 $a\times(b-1)-b=ab-a-b$。

---


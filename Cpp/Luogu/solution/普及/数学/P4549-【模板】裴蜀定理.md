# 【模板】裴蜀定理

## 题目描述

给定一个包含 $n$ 个元素的**整数**序列 $A$，记作 $A_1,A_2,A_3,...,A_n$。

求另一个包含 $n$ 个元素的待定**整数**序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 20$，$|A_i| \le 10^5$，且 $A$ 序列不全为 $0$。

## 样例 #1

### 输入

```
2
4059 -1782
```

### 输出

```
99```

# 题解

## 作者：奔波儿霸 (赞：162)

[欢迎到家光顾我的博客](https://www.cnblogs.com/bljfy/)

### 引言

这个题只要带着眼睛都知道要用到裴蜀定理(又叫做贝祖定理)。那么这个定理讲了啥呢？怎么证明？

### 裴蜀定理内容

${ax+by=c,x\in Z^*,y\in Z^*}$成立的充要条件是${\gcd(a,b)|c}$。$Z^*$表示正整数集。

### 证明

**首先声明一下，这个证明全靠我个人$YY$，所以可能有什么不合理的地方，如果有的话请看出来的$dalao$在评论区指明，O(∩_∩)O谢谢**

设${s=\gcd(a,b)}$，显然${s|a}$，并且${s|b}$

又因为${x,y\in Z^*}$

所以${s|ax,s|by}$

显然要使得之前的式子成立，则必须满足$c$是$a$和$b$的公约数的倍数

又因为$x$和$y$是正整数

所以$c$必然是$a,b$最大公约数的倍数。

因此，证得该定理成立

### 针对这道题

上述裴蜀定理针对的是两个变量。那么我们很自然的就想到这样的定理能否推广到多个变量呢？显然可以，证明方法同上。

那这个题不就是推广后的定理的裸题吗QAQ。我们只需要对这所有的数字求一个$\gcd$，值得注意的是不要忘记数据中有负数，要将其变为正数再求$\gcd$。

### 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

inline int gcd(int x, int y) {
    return y ? gcd(y, x%y) : x;
}

int n;

int main() {
    scanf("%d", &n);
    int ans = 0, tmp;
    for(int i=1; i<=n; i++) {
        scanf("%d", &tmp);
        if(tmp < 0) tmp = -tmp;
        ans = gcd(ans, tmp);
    }
    printf("%d", ans);
}
```

---

## 作者：RainAir (赞：51)

据说 NOIP 前发题解会 rp++？我数学这么差当然要让我的数学rp++了！

根据题目可知，这个题目要用裴蜀定理。

## 定理内容
对于任意整数 $a,b,d$，
$$ (a,b)|d \Leftrightarrow \exists \ u,v \ \text{such that}\ ua+vb = d $$

证明可以通过递归构造解来证明：

首先显然当 $u=1,v=0$ 的时候显然成立。

假设存在 $u',v'$,使得 $u'b+v'(a\ mod\ b)=d$.

注意到 $$a\ mod\ b = a-\lfloor\frac{a}{b}\rfloor b$$

可得 $$ u'b + v'(a-\lfloor\frac{a}{b}\rfloor b) = d$$

整理可以得到：
$$ u'b + v'a- v'\lfloor\frac{a}{b}\rfloor b = d$$

$$ v'a + (u'-\lfloor\frac{a}{b}\rfloor v')b = d $$

归纳证明该定理正确。

扩展到求 $ax+by=c$ 的最小非负 $c$,显然 $c$ 要满足 $(a,b)|c$,所以 $c$ 取 $(a,b)$ 是最小的。

扩展到这个题目，如果有多个数字的话，考虑前两个数字 $a_1,a_2$,有 $a_1x+a_2y=S \Rightarrow (a_1,a_2)|d$,$ k(a_1,a_2) =d$

所以把这两个的答案合并直接去取下一个就可以了。

注意到这个题目有负数输入，将其取绝对值就可以了。因为系数的最终答案没有影响。

## 代码
```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <map>
#include <set>
#define Re register
#define LL long long
#define U unsigned
#define FOR(i,a,b) for(Re int i = a;i <= b;++i)
#define ROF(i,a,b) for(Re int i = a;i >= b;--i)
#define SFOR(i,a,b,c) for(Re int i = a;i <= b;i+=c)
#define SROF(i,a,b,c) for(Re int i = a;i >= b;i-=c)
#define CLR(i,a) memset(i,a,sizeof(i))
#define BR printf("--------------------\n")
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl
namespace fastIO{
    #define BUF_SIZE 100000
    #define OUT_SIZE 100000
    #define ll long long
    bool IOerror=0;
    inline char nc(){
        static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
        if (p1==pend){
            p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin);
            if (pend==p1){IOerror=1;return -1;}
        }
        return *p1++;
    }
    inline bool blank(char ch){return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';}
    inline void read(int &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    inline void read(ll &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    #undef ll
    #undef OUT_SIZE
    #undef BUF_SIZE
};
using namespace fastIO;

int N,gcd;
int main(){
    read(N);
    FOR(i,1,N){
        if(i==1) read(gcd);
        else{
            int x;read(x);x = std::abs(x);
            gcd = std::__gcd(gcd,x);
        }
    }
    printf("%d\n",gcd);
    // system("pause");
    return 0;
}
```

---

## 作者：Dawn_Sdy (赞：42)

**看到机房dalao[@liuzhihao](https://www.luogu.org/user/155282)的一篇好的证明题解，但他不想发出去(~~太强~~)所以我来转载一下**

转载至：[原文](https://www.luogu.org/blog/liuzhihao/guan-yu-pei-shu-ding-li-tui-guang-di-zheng-ming)

PS：已经过本人同意

------------


**已知：$∑_{i=1}^{n}a_ix_i=f $ 其中$a_i,x_i,f∈Z$**

**求证：此方程有解的充要条件是$gcd(a_1,a_2,...,a_n)|f $，其中$n \in $ $N^+∧n \in [2, + \infty )$.**
- - -

## 证： 

### $1^o$必要性.

设$gcd(a_1,a_2,a_3,...,a_n)=k$，则$k|a_1,k|a_2...k|a_n$

∴$k|∑_{i=1}^na_ix_i=f$

即$gcd(a_1,a_2,...,a_n)|f$

### $2^o$充分性.
### 
考虑数学归纳法

易证当$n=2$时成立

当$x$成立时考虑$x+1$的情况

设$a_1+a_2+...+a_x=S,gcd(a_1,a_2,...,a_x)=k$

则总存在一对整数$(N,M)$使得$N*S+M*a_{x+1}=gcd(k,a_{x+1})$

即总存在一对整数$(N,M)$使得$N*(a_1+a_2+...+a_x)+M*a_{x+1}=gcd(a_1,a_2,...,a_{x+1})$

∴存在一组解使得$∑_{i=1}^{n}a_ix_i=gcd(a_1,a_2,...,a_n)$，其中一组解为$x_1=x_2=...=x_{n-1}=N,x_n=M$(上文的$N$与$M$)

证毕.

## $Q.E.D$

---

## 作者：ADay (赞：41)

此题是**裴蜀定理**的模板题，那么——先上定理内容： 
>对任何整数$a$、$b$和它们的最大公约数$d$，关于未知数$x$和$y$的线性不定方程（称为裴蜀等式）：若$a$,$b$是整数,且$\gcd(a,b)=d$，那么对于任意的整数$x,y,ax+by$都一定是d的倍数，特别地，一定存在整数$x$,$y$，使$ax+by=d$成立。 
——百度百科   

emm,说白了，其实就是两个东西： 
$$\begin{cases}\text{任意}x,y→\gcd(a,b)|ax+by\\ax+by=\gcd(a,b)\text{有整数解}\end{cases}$$ 
其中$a,b,x,y$均为整数  
### 证明
引理①:我已经化成那个样子了，原因显然。  
引理②证明：  
$$\text{设}t=\gcd(a,b),\text则 t|a,t|b,t|ax+by$$
$$\text设 s\text{为}ax+by\text{的最小正整数值, 那么$s$为$a,b$的线性组合}$$
$$\text{设}r=a\%s,p=\left\lfloor\dfrac{a}{s}\right\rfloor$$
$$\therefore r=a-ps=a-p(ax+by)=a(1-px)-pby$$
$$\text{显然$r$也是$a,b$的线性组合}$$
$$\text{又 $\because s$ 最小，则$r$=0}$$
$$\text{$\therefore s|a,s|b,$那么$s$为$a,b$的公因数 $\rightarrow t \ge s$}$$
$$\text{$\because t|ax+by$}$$
$$\text{$\therefore t|s$}$$
$$\therefore t \le s$$
$$\text{$\because t \ge s,t \le s$}$$
$$\therefore t=s$$ 
~~略去过程QED，由上可知证毕。~~    
### 回到题目
显然，$s$即为所求。那么$n$个数的裴蜀定理怎么弄？每个数的绝对值$\gcd$一次即可。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read()//快读
{
	int s=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		s=(s<<3)+(s<<1)+ch-48;
		ch=getchar();
	}
	return s*f;
}

inline void write(int x)//快写
{
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10^48);
}

int n,ans;

int main()//美丽的主程序
{
	n=read(),ans=read();//ans默认为第一个数
	while(--n)ans=__gcd(ans,abs(read()));//懒得手写gcd，虽然NOIP不能用
	write(ans);//输出
	return 0;
}
```


---

## 作者：pufanyi (赞：28)

标题海星，直接给出正解（至少我现在看到的标题是“ 裴蜀定理 / Min”）……

裴蜀（贝祖）定理，就是关于$x, y$的不定方程$ax + by = c$有整数解的充要条件是$\gcd(a, b)\mid c$。

由此我们发现对于式子$ax+by$的值一定被$\gcd(a, b)$整除，于是就变成了$k\times \gcd(a,b)$。由于$\gcd(a, b)$已知，把它看成常数$a$即可。于是就把两项给合并了。

然后最终就变成了$ax+by$的最小非负值——那当然是$\gcd(a, b)$了。

就这样递推下去就行了，注意由于读入可能为负，读进来的时候取个绝对值即可（由于系数反一下是无关的，所以结果是相同的）。

```cpp
for(int i = 1, t; i <= n; ++i)
{
	scanf("%d", &t);
	if(t < 0)
		t = -t;
	ans = gcd(ans, t);
}
```



---

## 作者：JustinRochester (赞：13)

这里给出非递归的 gcd 做法

---

**【分析】**
--

要看证明内容的就麻烦翻一下别人的题解了，这里本蒟蒻就不班门弄斧了，直接讲一下解题思路：

显然，就是对于读入的 $n$ 个数，输出他们的最大公因数

假设 $gcd(a,b)=g,gcd(a,b,c)=d$

由 $d|a$ 且 $d|b$ 得 $d|gcd(a,b)$ 即 $d|g$

又 $\because d|c$

$\therefore d|gcd[\quad gcd(a,b),c\quad]$

因此，我们只要对每次读入的一个数，和上几次得出的最大公因数用一次 gcd 即可

当然，因为答案要求正数，所以读入的负数直接转化为正数即可

----

接下来开始讲非递归 gcd 的原理，不求甚解的同学或者一看就懂的 dalao 麻烦往下跳

常规的 gcd ，是用递归实现的：
```cpp
int gcd(int a,int b){
	if(b==0) return a;
    else return gcd(b,a%b);
}
```

当然，在压行选手眼中，它是这样的：
```cpp
int gcd(int a,int b) { return (!b)?a:gcd(b,a%b); }
```

今天呢，我这边给出非递归打发。这是我在一篇文章中看到的黑科技：

我们想，$gcd(a,b)=gcd(b,a\%b)=...=gcd(r,0)$ 所以 $r$ 为最大公因数。

那么，实际上就是说，递归边界是 $b==0$ 这个应该很显然吧

而当 C++ 中的 while() 循环，内部是一个赋值表达式的时候

一旦赋值过后的该值为 $0$ ，就会退出循环

这和我们的递归边界是很像的。

而对于 $(a,b)$ 变成 $(b,a\%b)$ ，可以理解为：

1. $(a,b)$ 变为 $(a\%b,b)$
2. $(a\%b,b)$ 交换两个值，变为 $(b,a\%b)$

这两步的合成

而对于交换两个不同的数 $a,b$ ，有一个黑科技打法：
```cpp
a^=b^=a^=b;
```

程序从右往左执行：

1. a^=b,a 变成 a^b
2. b^=a,b 变成 b^(a^b)=b^b^a=a
3. a^=b,a 变成 (a^b)^a=a^a^b=b

至此，足以完成交换操作

---

实际上，我们把上述步骤结合一下，就可以实现非递归了，这边就直接给出代码了，我觉得应该可以理解了：

```cpp
while(b^=a^=b^=a%=b);
```

最后， $a$ 就是最大公约数

当然，还有一个小细节，大家可以想一想，为什么？

```cpp
int &me=LRJ;
me->output("想一想，为什么");
```

刚刚那个代码的前面应该要加上一个判定，变成：
```cpp
if(b) while(b^=a^=b^=a%=b);
```

---

**【代码】**
--

那本蒟蒻就放 ~~我那码风极丑的~~ 代码了

```cpp
#include<cstdio>
using namespace std;
inline int read(){
    register int ans=0;register char c=getchar(); while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return ans;
}//读入优化，并且直接不读负号
int main(){
	register int n=read()-1,s=read();
	while(n--){
		if(s==1) break;
		register int tmp=read();
		if(tmp) while(tmp^=s^=tmp^=s%=tmp);
	}
	printf("%d",s);
    return 0;
}
```

---

## 作者：FifthAxiom (赞：9)

首先，介绍裴蜀定理及其证明。

## 裴蜀定理
若$a,b$是整数,且$\gcd(a,b)=d$，那么对于任意的整数$x,y$，$ax+by$都一定是$d$的倍数，**特别地，一定存在整数$x,y$，使$ax+by=d$成立。**（看了一下，貌似没有题解写到后面加粗部分的证明？）

> 证明：
>
> 首先，易知$d\mid a$且$d\mid b$，由整除性质可知$\forall x,y \in \mathbb Z$，$d\mid ax+by$。
>
> 令$p$为$ax+by$的最小正整数值，$q=\lfloor \dfrac{a}{p}\rfloor$，$r=a\mod p = a - qp=a-q(ax+by)=a(1-qx)+bqy$，可知$r$也是$a,b$的线性组合（$ax+by$的一种形式）。因为$p$是$ax+by$的最小正值，$0\le r < p$，故$r=0$，即$p\mid a$.
>
> 同理，我们可以证得$p\mid b$。
>
> 因为所有$ax+by$都是$d$的倍数，故$p=d$。证毕

将裴蜀定理推广到本题上，可知$\forall A_iX_i+A_{i+1}X_{i+1}$，其最小正整数的值为$\gcd(A_i,A_{i+1})$。由于$\gcd(a_1,a_2\dots,a_n)=\gcd(\gcd(a_1,a_2\dots,a_{n-1}),a_n)$，故可以递推求整个序列的$\gcd$。遇到负数时求其相反数即可。

代码如下

```cpp
#include <cstdio>

int n, a, ans;

int gcd(int x, int y) {//辗转相除法求gcd
    return !y ? x : gcd(y, x % y);
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a);
        a = a > 0 ? a : -a;//遇到负数时求相反数
        ans = gcd(ans, a);//递推求整个序列的gcd
    }
    return !printf("%d\n", ans);
}
```

目前本题的大部分题解都只证明了$\gcd(a,b)\mid ax+by$，而忽略了为什么$\exists ax+by=\gcd(a,b)$。希望大家能够细心对待每一题，避免”想当然“的情况出现。





---

## 作者：Mosher (赞：5)

### 其实写着篇题解的目的：帮助Oier们识别数学题，以及怎么想此类题QwQ

~~其实感觉这题解里全讲怎么证明，但未说为何如此做~~

**正文**

思路：

1.暴力枚举，求解可能情况？ 

显然不行。可能性太多，毕竟二十元一次不等式啦。QAQ
      
2.排序+人脑模拟=>剪枝
  
从小到大开始，尽量绝对值相近的正负值抵消？
  
但某一方出现极大值，这种思路显然会被卡掉。

另：

当到了这时，你发现很多算法对不上号；
  
你或许会考虑dp，但dp的状态很多时候就是dfs等的变量；
  
不过我们已在 1. 2. 情况下将其否定，这时就应该考虑数学;
  
(或者数据结构，其实有些数据结构题，根本看不出来，完全就是数学的题面，可你发现用不了数学定理)
    
3.我们已确定是道数学题后，细读题面:

集合{a}总与集合{x}配对，s求最小。

再者，观察样例挖取信息：gcd(4059,-(-1782))=99;

然后，看看是否有mod，逆元之类的，确信没有；

得知以上信息后:

s与a,x的函数有关，而又有gcd影响，考虑：裴蜀定理

**裴蜀定理:**

1. 
```cpp
关于未知数x和y的线性不定方程(称为裴蜀等式):
若a,b是整数,且gcd(a,b)=d;
那么对于任意的整数x,y,ax+by都一定是d的倍数;
特别地，一定存在整数x,y,使ax+by=d成立.
```
(以上摘自[百度百科](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fr=aladdin))虽然我想直接写公式的,但怕你们不愿细看.

2. 推论:gcd(a,b)=1时,必然存在:ax+by=1;(可逆)
3. 证明:略去(你谷大佬都写完了)
4. 关于本题运用:
```cpp
当在n=3时:
假使:a1*x1+a2*x2=d,且d=b*y;
那么:d+a3*x3=s>0;
由裴蜀定理:
     d=gcd(a1,a2);
     s=gcd(b,a3);//d与b有关
因为:d由a1,a2计算而来,s由d,a3计算而来;
  又:a1*x1+a2*x2为d的倍数;
所以:本题就变为了:连续数列内的反复的gcd出的d值,
     在条件允许之内,我们当然希望数字越小越好;
```
**Code:**
```cpp
#include<bits/stdc++.h>//当然，注意负数
using namespace std;
int main(){
    int n,ans=0,x;
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&x);
        ans=x>0 ? __gcd(ans,x):__gcd(ans,-x);//三目运算符+__gcd()是C++自带的gcd函数+懒人大法好!
    }
    printf("%d",ans);
}
```
rp++

---

## 作者：lndjy (赞：3)

### 裴蜀定理
裴蜀定理，就是关于 $x,y$ 的不定方程 $ax+by=c$ 有整数解的充要条件是$gcd(a,b)|c$ 。

这是两个数，这道题求的是n个数，其实n个数也同理，就是扩展版的：

若 $a_1,a_2...a_n$ 都是整数,且 $\gcd(a_1...a_n)=d$ ，那么对于任意的整数 $x_1a_1,x_2a_2...x_na_n$ 都一定是d的倍数，特别地，一定存在整数  $x_1...x_n$ 使 $x_1a_1+x_2a_2+...x_na_n=d$ 成立。

#### 注意

这道题有负数，所以要对于每个数取绝对值。

#### 代码
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int gcd(int a,int b)//最大公因数gcd
{
	if(b==0) return a;
	return gcd(b,a%b);
} 
int main()
{
	int n;
	cin>>n;
	int ans=0;
	while(n--)
	{
		int a;
		cin>>a;
		ans=gcd(ans,abs(a));//对于每个数取绝对值后求最大公因数
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：塔罗兰 (赞：2)

```
裴蜀定理(或贝祖定理)说明了对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程(称为裴蜀等式)：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。

它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.
```
以上内容作为~~陪鼠~~裴蜀定理原定理摘自百度百科
```
若a1,a2...an都是整数,且gcd(a1...an)=d，那么对于任意的整数x1*a1,x2*a2...xn*an都一定是d的倍数，特别地，一定存在整数x1...xn使x1*a1+x2*a2+...xn*an=d成立。

特别来说，如果a1...an互质（不是两两互质），那么存在整数x1...xn使得x1*a1+x2*a2+...xn*an=1。
```
以上内容作为裴蜀定理推广定理依旧摘自百度百科但略作修改

了解了推广定理以后这题的难度就从黄题掉到了红题

本题根据推广裴蜀定理可以转化为求d,也就是这n个数的最大公约数

易知n个数的最大公约数D为前n-1个数的最大公约数d与第n个数的最大公约数,即D=gcd(d,an);

然后可由辗转相除法求出2个数的最大公约数然后向n推,具体见代码

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int gcd(int x,int y)
{
	if(!y)
	return x;
	return gcd(y,x%y);
}//辗转相除法求最大公约数
int main()
{
	int n,a,mingcd;
	scanf("%d%d",&n,&a);
	mingcd=abs(a),--n;//abs为求绝对值运算
	while(n--)//
	{
		scanf("%d",&a);
		a=abs(a);//abs必须加上,不然输入样例这样的数据会输出负数
		if(a<mingcd)
		swap(a,mingcd);//swap为交换两个变量的值,保证gcd函数不会出错
		mingcd=gcd(a,mingcd);//记录
	}
	printf("%d",mingcd);
}
```
PS:虽然这题~~很水~~不难,但真正重要的是裴蜀定理的“重要结论”(百度百科上的那个),在今后做数论题时会经常用到,比如[P1082 同余方程](https://www.luogu.org/problemnew/show/P1082)和[P3811 【模板】乘法逆元](https://www.luogu.org/problemnew/show/P3811)等

---

## 作者：piggymichael (赞：2)

裴蜀定理，就是关于x,y的不定方程ax+by=c有整数解的充要条件是gcd(a,b)|c。这就是神奇的裴蜀定理，数学知识。

真正了解裴蜀定理后，题目就简单了。就是求这堆数绝对值的最大公约数。一个个做最大公约数。

看代码：

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int gcd(int x,int y)
{
    return y?gcd(y, x%y):x;//一个简单的求最大公约数的函数
}
int n,a,ans;
int main()
{
	cin>>n>>a;
	ans=a;//ans先是第一个数，最大公约数是不会超过的
	for(int i=2;i<=n;++i)
	{
		cin>>a;
		ans=gcd(ans,abs(a));//每输入一个数就绝对值并求最大公约数
	}
	cout<<ans<<endl;
	return 0;//程序结束
}
```

代码并不难，看完这道题，可以看看类似的[CF389A](https://www.luogu.org/problem/CF389A)

---

## 作者：Great_Influence (赞：2)

根据裴蜀定理，可以知道能够取到的数字一定是某几个数的gcd的倍数。所以直接对所有数取gcd。直接一路滚gcd就可以了。

代码:

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<cstring>
#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
using namespace std;
template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
void file(void){
    #ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
    #endif
}

static int s,n;

int main(void){
    file();
	read(n);
	static int x;
	Rep(i,1,n)read(x),s=__gcd(s,abs(x));
	printf("%d\n",s);
	return 0;
}

```

---

## 作者：yangrunze (赞：1)

刚学会裴蜀定理，顺便来给大家讲一下：


首先来看看裴蜀定理是个什么东西哈：

> 对于一个二元一次方程$ax+by=c$，如果 **$c$是$\gcd(a,b)$的倍数**，那么**这个方程一定有整数解**

那这个东西到底咋证捏？别急，咱们要分两个阶段来完成证明！

### Section A

> 证明$ax+by=\gcd(a,b)$这个方程有整数解

首先，咱们要用的是一个很基础的东西——**辗转相除法**

对，没错，就是求最大公因数的那个

还记得辗转相除法的核心柿子吗？没错！就是$\gcd(a,b)=\gcd(b,a\bmod b)$

那咱们就用这个式子来证明它！

设$\gcd(a,b)=g$

则$ax+by=g$

我们设已经找到了一组解$x',y'$，使$bx'+(a \bmod b)y'=\gcd(a,b)$

$bx'+(a \bmod b)y'=g$

由于商\*除数+余数=被除数，$a\bmod b$可以这么表示：

$bx'+(a-\lfloor\frac{a}{b}\rfloor\times b)y'=g$

给它稍微变个形：

$bx'+ay'-a/b\times by'=g$

$ay'+b(x'-\lfloor\frac{a}{b}\rfloor\times y')=g$

和原式对比一下，你会惊奇地发现：

$\begin{cases}x=y'\\y=x'-\lfloor\frac{a}{b}\rfloor\times y'\end{cases}$

由于$b=0$时$\begin{cases}x=1\\y=0\end{cases}$，我们可以用刚才的式子一步一步向上把原来的解求出来

对于每一个$a$和$b$，我们都可以如法炮制，所以肯定都是有解哒！

P.S:刚才咱们用的方法，其实是辗转相除法的升级版——**扩展欧几里得算法**，也就是传说中的**exgcd**，又学会了一个新方法，开心不开心？（我才不会告诉你这一块是从扩欧的笔记那里cv过来的呢QωQ）

### Section B

> 证明每一个$c$都是$gcd(a,b)$的倍数

这就非常简单了，咱还是设 $\gcd(a,b)=g$

由于$g$是$a$和$b$的最大公因数，所以$g$肯定能被他俩整除

从刚才的得到的结论出发，我们设已知$ax'+by'=g$，$g\times q=c$

两边同时乘$q$，这样的话就可以发现$ax'\times q+by'\times q=g\times q$，即$ax'\times q+by'\times q=c$

$\begin{cases}x=x'\times q\\y=y'\times q\end{cases}$就是方程的一组解啦

**如果你认为这一切就是裴蜀定理的话 你就太小看它了**

裴蜀定理不光正着说没问题，反着说也成立！

> 对于一个二元一次方程$ax+by=c$，如果这个方程有整数解，那么c一定是$\gcd(a,b)$的倍数

那这个东西该咋证明呢？咱们还是可以考虑从最大公因数扩展

我们设$a=a'g,b=b'g,c=c'g+r$（$r<g$，我们还不知道$c$到底是不是$g$的倍数，那就先设上个$r$吧）

这样的话，原方程可以变为：$a'g x+b'g y=c'g+r$

两边同时除以$g$，得到$a'x+b'y=c'+\frac{r}{g}$

别忘了我们的已知条件：方程有整数解！所以$\frac{r}{g}$一定是个整数，$r$只能是$0$，所以$c$一定是$g$的倍数

那我们现在就可以大胆地说出来：

>对于一个二元一次不定方程$ax+by=c$，$c$是$\gcd(a,b)$的倍数，是这个方程有整数解的**充要条件**

**如果你认为这一切就是裴蜀定理的话 你就太小看它了**

裴蜀定理不仅如此，还可以扩展到更多元的不定方程！

>对于一个 **$n$元一次不定方程** $a_1x_1+a_2x_2+a_3x_3+\cdots+a_nx_n=c$，$c$是$\gcd(a_1,a_2,a_3,\cdots,a_n)$的倍数，是这个方程有整数解的充要条件

类比一下多个数求最大公因数的过程，证明这个应该很简单

好不容易完成了证明，来看看题吧！

>给定一个包含 $n$ 个元素的整数序列 $A$，记作 $A_1,A_2,A_3,...,A_n$ 
求另一个包含 $n$ 个元素的待定整数序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

不难发现，这题的$S$，其实就是定理里面的$c$

也就是说，要找一个最小的$c$使方程有解

根据定理， **$S$必须是$\gcd(A_1,A_2,A_3,\cdots,A_n)$的倍数**，**一个数最小的倍数就是它自己**，也就是说，只要**求这些数的最大公因数**就成啦！（出现负数不要慌，不用管它，直接取相反数就行）

code:（就是求最大公因数，不用注释了吧qwq）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
int tql,wyx,akioi;
inline int nb(){//快读
	char c=getchar();
	int f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
inline int txdy(int a,int b){//求两个数的gcd
	if(b==0)
	return a;
	return txdy(b,a%b);
}
int main(){
	tql=nb();
	while(tql--){
		wyx=nb();
		if(wyx<0)wyx=-wyx;
		akioi=txdy(wyx,akioi);//很简单的操作啦！
	}
	printf("%d",akioi);
}
```
The end

---

## 作者：Vozeo (赞：1)

这道题写的是`Bézout`定理，不过可能要用到一个最大公约数理论的定理：
> 设$a_1,\cdots ,a_i$是不全为0的整数，有$$\gcd(a_1,\cdots,a_i) = \min(s = a_1x_1+\cdots+a_ix_i)$$其中$x_j \in \mathbb{Z}(1 \le j \le i), s > 0$，即$\gcd(a_1,\cdots ,a_i)$等于$a_1,\cdots ,a_i$的所有整系数线性组合组成的集合中的最小正整数。

给出一个~~可能不太完备的~~证明（引用的部分是对这句证明的解释）：

设$S$表示$a_1,\cdots ,a_i$的所有整系数线性组合组成的集合，则$S$中必有一个最小的正整数，设为$s_0$。

对$a_1,\cdots ,a_i$的任一个公约数$d$，都有$d \mid s_0$，所以$|d| \le s_0$。**即$s_0$不小于$a_1,\cdots ,a_i$的任一个公约数。**
> 因为$d$是$a_1,\cdots ,a_i$的公约数，所以必然能整除$a_1,\cdots ,a_i$的所有线性组合。

对任意$a_j$，设$a_j = q_js_0 + r_j$，其中$0 \le r_j < s_0$，则有$r_j \in S$。
> 因为$a_j \in S$，$s_0 \in S$，且有$r_j = a_j - q_js_0$，所以$a_j$和$s_0$的线性组合$r_j \in S$。

若$r_j>0$，则与$s_0$是$S$中最小的正整数矛盾，所以$r_j=0$，即$s_0 \mid a_j$。**也即$s_0$是$a_1,\cdots,a_i$的公约数。**

所以$s_0 = \gcd(a_1,\cdots,a_i)$。

$$\mathcal{Q.E.D}$$

这个定理在一些数论书上能够见到（比如《初等数论》）。

所以这道题只需要求一下所有数字的$\gcd$就好啦。代码就不放了。

---

## 作者：JasonZRY (赞：0)

在数论中，裴蜀定理是一个关于最大公约数（或最大公约式）的定理，裴蜀定理得名于法国数学家艾蒂安·裴蜀。

裴蜀定理说明了对任何整数 a、b和它们的最大公约数 d ，关于未知数 x 和 y 的线性丢番图方程（称为裴蜀等式）。

裴蜀定理（或贝祖定理，Bézout's identity）得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。

它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1。

## 证明1：

设d=gcd(a,b)则d|a,d|b。

由整除的性质，
![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/58ee3d6d55fbb2fb48da48e9494a20a44723dc53.jpg)
，有d|(ax+by)。设s为ax+by最小正值，首先有d|s。

令
![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/b999a9014c086e06eea82cb004087bf40bd1cbcd.jpg)
，
![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/ac6eddc451da81cbbe71fffd5b66d0160924316e.jpg)
可见r也为a,b的线性组合。由于s为a,b线性组合的最小正值,
![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/574e9258d109b3dee694f793cabf6c81800a4c25.jpg)
，可知r=0。则s|a,同理a|b,则s|d，因此可得d=s，命题得证。 [1] 

## 证明2：

⑴若b=0，则（a,b)=a.这时定理显然成立。

⑵若a,b不等于0.

记d = (a, b), 对ax + by = d，两边同时除以d，可得(a1)x + (b1)y = 1，其中(a1,b1) = 1。

　　转证(a1)x + (b1)y = 1。由带余除法：
  
　　① (a1) = (q1)(b1) + (r1), 其中0 < r1 < b1
  
　　② (b1) = (q2)(r1) + (r2), 其中0 < r2 < r1
  
　　③ (r1) = (q3)(r2) + (r3), 其中0 < r3 < r2
  
　　.....
  
　　④ (rn-4) = (qn-2)(rn-3) + (rn-2)
  
　　⑤ (rn-3) = (qn-1)(rn-2) + (rn-1)
  
　　⑥ (rn-2) = (qn)(rn-1) + (rn)
  
　　⑦ (rn-1) = (qn+1)(rn) + 1
  
　　故，由⑦和⑥推出(rn-2)An-2 + (rn-1)Bn-1 = 1
  
　　再结合⑤推出(rn-3)An-3 + (rn-2)Bn-2 = 1
  
　　再结合④推出(rn-4)An-4 + (rn-3)Bn-3 = 1
  
　　.....
  
　　再结合③推出(r1)A1 + (r2)B2 = 1
  
　　再结合②推出(b1)A0 + (r1)B0 = 1
  
　　再结合①推出(a1)x + (b1)y = 1
  
　　证毕。
  
###### （摘自百度百科）

# 回归正题：

这题简直就是水到a+b problem（不是高精）的难度。

看代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,x,ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>x;
        if(!x)x*=-1;
        ans=__gcd(ans,x);
    }
    cout<<abs(ans);
    return 0;
}
```

就这么几行，但还能更短：

```
#include<bits/stdc++.h>
using namespace std;int n,x,ans;int main(){cin>>n;for(int i=1;i<=n;i++){cin>>x;if(!x)x*=-1;ans=__gcd(ans,x);}cout<<abs(ans);return 0;}
```

呵呵呵。

# 这片题解就到这了，拜拜

orz%%%奆犇

---

## 作者：RainFestival (赞：0)

这道题用裴蜀定理,GCD（从题目名就可以知道啦）

如果(a1,a2)=d

一定存在x1,x2使得d=x1a1+x2a2

如果(a1,a2,……,an)=d

一定存在x1,x2,…,xn使得d=x1a1+⋯+xnan

此题求这些数的最大公因数即可（每个数取绝对值）

~~蒟蒻的代码没有坑~~

```pascal
var
  n,i,ans:longint;
  a:array[0..100005] of longint;
function gcd(x,y:longint):longint;
begin
  if x mod y=0 then exit(y)
               else exit(gcd(y,x mod y));
end;
begin
  readln(n);
  for i:=1 to n do
    begin
      read(a[i]);//读入每个数
      a[i]:=abs(a[i]);//取绝对值
    end;
  ans:=a[1];//ans(答案）不能等于零
  for i:=1 to n do
    ans:=gcd(a[i],ans);//a[i]在前，防止gcd时除0（90分）
  writeln(ans);//输出结果
end.

```


---


# 難題「龍の頸の玉　-五色の弾丸-」

## 题目背景

輝夜が出した難題の一つ。この玉にはそれぞれ星が入っていて、
七つ集めるとどんな願いでもかなうという。

辉夜所出的难题之一。这些玉石各自都被画上了星星，
据说收集齐七颗就能够实现任何的愿望。 

## 题目描述

五颗龙玉在同一平面上形成一个外切圆半径为r的正五边形，其中一颗（$aa$）在外心与辉夜的连线上。五边形的外心（外切圆圆心）绕着辉夜以R的半径v的速度顺时针旋转（不自转）。五颗龙玉每t秒钟发射一圈弹幕，一圈 $k$ 个子弹。$aa$ 发出的子弹中有一个子弹是背对辉夜的方向的，其他的龙玉发出的子弹方向与 $aa$ 相同，我们可以认为子弹是无限快的。作为一个 neet，辉夜不能让子弹打到自己。

永琳对此表示很担心，于是请你写一个程序判断辉夜的安全。

下面是图示：

![](https://cdn.luogu.com.cn/upload/pic/27885.png)

注：红色为龙玉旋转轨迹                 
p.s.感谢几何画板为本题提供技术支持；感谢上海爱丽丝幻乐团提供信仰加成

## 说明/提示

- 对于 $50\%$ 的数据，保证 $T<5000$。
- 对于 $100\%$ 的数据，保证 $T<10^5$，$r,k,R,v,t<10^9$。

## 样例 #1

### 输入

```
2
6.000000 11.000000 10.000000 100.000000 43
1.000000 10.000000 10.000000 100.000000 11
 ```

### 输出

```
yes
yes```

# 题解

## 作者：Chinese_zjc_ (赞：10)

先看下面这张图:

![Photo1](https://cdn.luogu.com.cn/upload/image_hosting/o8dj6zg2.png)

 $ B $ 绕 $ A$ 顺时针旋转的时候, $ C $ , $ D $ , $ E $ 等点也随着 $ B $ 一起旋转.

从题目配图中显然可以看出, $ A $ , $ B $ , $ C $ , $ D $ , $ E $ 五点之间的相对位置不会改变.

那我们直接可以把 $ v $ , $ t $ 这些量忽略掉,于是这道题目就成了静态.

而且由于正五边形存在对称轴,因此只需要考虑 $ 3 $ 个点 $C$ , $ D $ , $E$ 能否攻击到 $ A $  .

我们设 $ A:(0,0) $ , $ B $ 在 $ y $ 轴上.

易得: $ B:(0,R) $ , $ C:(0,R-r) $ ,正五边形关于 $ y $ 轴对称.

然后我们来求 $ D $ 和 $ E $ 的坐标.

作 $ BF\bot BC$交于点 $ B $ , $ DF\bot BF $ 交于点 $ F $ , $EG\bot BF$交于点 $ G $ .

如图:

![](https://cdn.luogu.com.cn/upload/image_hosting/f6v7w82j.png)

则易得 $ \angle DBF=18^\circ $ , $ \angle EBG=54^\circ $ .

再使用三角函数,即得: $ D:(-\cos(18^\circ)\times r,R-\sin(18^\circ)\times r) $ , $ E:(-\cos(54^\circ)\times r,R+\sin(54^\circ)\times r) $ .

再考虑子弹方向:

对于 $ D $ 和 $ E $ 第一个子弹的方向分别是射线 $ DF $ 和射线 $ GE $ .

对于第 $ i+1 $ 个子弹,相对于第 $ 1 $ 个子弹顺时针旋转了 $ \frac{360^\circ}{k}\times i $ .

因此若 $ D $ 或 $ E $ 要射到 $ A $ , $ 180^\circ-\angle AEG $ 或 $ 180^\circ-\angle AFD $ 必须得是 $ \frac{360^\circ}{k} $ 的倍数.

让我们求出 $ \angle AEG $ 和 $ \angle AFD $ 的度数.

依然是三角函数:
$$
\angle AEG=\arctan(\frac{\cos(18^\circ)\times r}{R-\sin(18^\circ)\times r})\\
\angle AFD=\arctan(\frac{\cos(54^\circ)\times r}{R+\sin(54^\circ)\times r})\\
$$

这样,直接计算判断即可,而 $ B $ 射到 $ A $ 的情况显然当且仅当 $ k $ 为偶数.

那我们就可以愉快地写代码了.

$Code\ \#1$:

```cpp
//This Code was made by Chinese_zjc_.
#include<cstdio>
#include<cmath>
#define int long long
#define PI 3.14159265358979323
#define EQUAL 0.00000000000001
#define double long double
using namespace std;
int T,k;
double r,R,v,t,siz[5],atime;
bool answered;
double _360topi(const double IN)
{
    return IN/180*PI;
}
signed main()
{
    scanf("%lld",&T);
    while(T--)
    {
        scanf("%Lf%Lf%Lf%Lf%lld",&r,&R,&v,&t,&k);
        answered=false;
        if(!(k&1))
        {
            puts("no");
            continue;
        }
        siz[1]=_360topi(180)-atan((cos(_360topi(18))*r)/(R-sin(_360topi(18))*r));
        siz[2]=_360topi(180)-atan((cos(_360topi(54))*r)/(R+sin(_360topi(54))*r));
        atime=PI*2/k;
        for(int i=1;i<=2;++i)
        {
            int tim=siz[i]/atime+EQUAL;
            if(abs(tim*atime-siz[i])<EQUAL)
            {
                puts("no");
                answered=true;
                break;
            }
        }
        if(!answered)
        {
            puts("yes");
        }
    }
    return 0;
}
```

回头看到式 $ (1) $ ,这就不禁让人想问了:

**是不是它们都是无理数?**

这是显然的,证明略.

那我们就可以拿出我们在二年级就学过的知识:

无理数除以一个有理数的结果必定为无理数.

很显然,因此证明略.

那代码可以进行简化:

$Code\ \#2$:

```cpp
//This Code was made by Chinese_zjc_.
#include<cstdio>
using namespace std;
int T,k;
double r,R,v,t;
signed main()
{
    scanf("%lld",&T);
    while(T--)
    {
        scanf("%lf%lf%lf%lf%lld",&r,&R,&v,&t,&k);
        puts(k&1?"yes":"no");
    }
    return 0;
}
```

---

## 作者：lol_qwq (赞：7)

# P4914 题解

1. 五边形不自转，人只是一个点，怎么转关系都不会发生改变

1. 题目中的子弹无限快，那么距离，速度，时间，不都忽略了吗？

1. 有一个子弹背对人，找到轨迹由此得下面结论。

因此本题其实只需要求 $k$ 的奇偶性，一道结论题。

注意时限卡常，本人被卡了十多次

AC代码：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
inline int read()
{
	int s=0,k=1;
	char c=getchar();
	while(!isdigit(c))
	{
		k=(c=='-')?-1:1;
		c=getchar();
	}
	while(isdigit(c))
	{
		s=s*10+c-'0';
		c=getchar();
	}
	return s*k;
}
int a,b;
double c,d,e,f;
int main()
{
    a = read();
    while(a--){
        scanf("%lf%lf%lf%lf",&c,&d,&e,&f);
        b = read();
        puts(b&1?"yes":"no");
    }
    return 0;
}
```

---

## 作者：宇佐见莲子 (赞：6)

t4的题解：     
这题没有那么难吧怎么都不来做？~~是不是看不起我看我太菜心想这出题人这么垃圾那她出的题也是垃圾题吧做了有伤我的大佬形象我还是去AKt5吧哇泥萌都欺负莲子QAQAQAQAQ~~       
好的不玩了，我们来说正事       
首先如果你是个大佬/数竞大佬/脑洞大佬/脑补大佬/找规律大佬/打cf通过样例猜题意的大佬（有什么奇怪的东西出现了喂），你就会一眼看出来这题v,t是没用的（既不自转又没有惯性vt有何用？），那么就可以用初中知识解决这道题了。            
![](https://cdn.luogu.com.cn/upload/pic/35926.png)           
求出∠ABG与∠DBF的度数，再与360/k比较，就能得出答案。    
代码：
```
#include<bits/stdc++.h>
const double pi=acos(-1);
using namespace std;
const double cos18=cos(18*pi/180);
const double sin18=sqrt(1-cos18*cos18);
double angle(double a)
{
    return acos(a)/pi*180;
} 
double r,R,v,t;
int k;
int main(){
    /*freopen("10.in","r",stdin);
    freopen("10.out","w",stdout);*/
    int T;
    scanf("%d",&T);
    while(T--){
    scanf("%lf%lf%lf%lf%d",&r,&R,&v,&t,&k);
    if(k%2==0){
        printf("no\n");
        continue;
    }
    double c_1,c_2,b_1,b_2;
    b_1=sqrt(R*R-r*r);
    c_1=R;
    b_2=(R-r+2*r*cos18*cos18);
    c_2=sqrt(2*cos18*cos18*2*r*sin18*sin18*r+b_2*b_2);
    double an_1,an_2;
    an_1=angle(b_1/c_1);
    an_2=angle(b_2/c_2);
    bool flag=0;
    if(fmod(an_1,((double)360/k))==(double)0||fmod(an_2,((double)360/k))==(double)0){
            printf("no\n");
            flag=1;
        }
    if(!flag)
    printf("yes\n");
    }
}
```

---

## 作者：Zvelig1205 (赞：2)

向量大法好 /oh。

吐槽题目的“无自转”，明明是潮汐锁定（看图）。

那么 $v$ 和 $t$ 都没有任何用，最初状态下打不到之后也绝对打不到。

所以，以外心为坐标原点建系，可以求出来各个角的角度。

由于圆和正五边形的对称性，只需要考虑正五边形的三个顶点。

显然，aa 点能否击中辉夜，就在于 $k$ 的奇偶性，是奇数的话绝对无法击中，是偶数绝对可以击中。

而另外两个顶点（分别命名为 $d_1$ 和 $d_2$）与辉夜所成的角度，就通过向量进行简单计算。

显然，辉夜的坐标为 $(R,0)$，$d_1$ 的坐标就为 $(r\cdot \sin\alpha,r\cdot \cos\alpha)$，$d_2$ 的坐标为 $(r\cdot \sin2\alpha,r\cdot \cos2\alpha)$。

这样的话，需要计算的角度就是下图中紫色的角：

![](https://s1.ax1x.com/2022/11/19/zKdlI1.png)

角度就是 $\langle-\overrightarrow{hy},(\overrightarrow{d_1}-\overrightarrow{hy})\rangle$。

另一个点同理。

这样的话，也就是说，如果某颗子弹射出的夹角和求出来的紫角的角度互补的话，就说明可以达到辉夜。

这里我们规定，某颗子弹射出的夹角，是其轨道与**背对辉夜的方向的子弹**轨道的夹角，范围是 $(0,\pi)$。

由于需要计算两个点，而只有两个点的坐标不同，则可以定义一个函数来执行。最终，只要有一个子弹能打到辉夜，就输出 `no`。

说得再多，不如看代码来的直观：

```cpp
#include<iostream>
#include<cmath> 
#define fir first
#define sec second
using namespace std;
const double pi=acos(-1);
typedef pair<double,double> vec;//pair 模拟向量
double r,R,v,t;int k;
vec operator +(const vec &a,const vec &b)
{//向量加
	vec c;
	c.fir=a.fir+b.fir;
	c.sec=a.sec+b.sec;
	return c;
}
vec operator -(const vec &a,const vec &b)
{//向量减
	vec c;
	c.fir=a.fir-b.fir;
	c.sec=a.sec-b.sec;
	return c;
}
vec operator *(const vec &a,double b)
{//向量的数乘
	return vec(a.fir*b,a.sec*b);
}
double operator *(const vec &a,const vec &b)
{//向量点积
	return a.first*b.first+a.second*b.second;
}
double operator ~(const vec &a)
{//向量的模
	return sqrt(a.fir*a.fir+a.sec*a.sec);
}
bool pd_jz(vec hy,vec zd)
{//判断能否击中
	double theta=2*pi/(1.0*k);//算弹道之间的夹角
	vec ls1=zd-hy,ls2=hy*-1.0;//计算的两个向量
	double alpha=(ls1*ls2)/((~ls1)*(~ls2));//算紫角
	double sum=pi/2;sum-=alpha;//算补角
	double yu=sum-floor(sum/theta)*theta;//判断是否除尽
	return yu==0;//除尽即能打到
}
int main()
{
	ios::sync_with_stdio(0);
	int qwq;cin>>qwq;
	while(qwq-->0)
	{
		cin>>r>>R>>v>>t>>k;
		if((k&1)^1)
		{//aa 能打到
			puts("no");
			continue;
		}
		double alpha=0.4*pi;//外接圆对应圆心角
		vec hy=vec(R,0.0);//辉夜
		vec _1=vec(r*sin(alpha),r*cos(alpha));//一个顶点
		vec _2=vec(r*sin(alpha*2),r*cos(alpha*2));//另一个顶点
		bool pd1=pd_jz(hy,_1),pd2=pd_jz(hy,_2);
		if(pd1||pd2)puts("no");
		else puts("yes");
	}
	return 0;
}
```

---

## 作者：SmallBlack (赞：2)

简单来说，是在和同学水模拟的时候做到了这一道蓝题。一开始看题时以为会很难，没想到这道题是一道纯真的结论题。

看了看题解数量较少，交一篇凑个数，~~顺便拿点贡献分~~。

### 正片
______

不要一看见题目里数据多就慌，一句一句分析：

1. 五颗龙玉在同一平面上形成一个外切圆半径为 $r$ 的正五边形，其中一颗
（ $aa$ ）在外心与辉夜的连线上。

跟着题意画图（由于 geogebra 炸了，使用的是 Win7 自带的画图，不喜勿喷）：

![图1](https://z3.ax1x.com/2021/10/19/5wLXb4.png)

2. 五边形的外心（外切圆圆心）绕着辉夜以 $R$ 的半径与 $v$ 的速度顺时针旋转（不自转）。

既然这个五边形没有自转，并且人就是一个点，两者的相对位置不变，可以直接忽略条件中的旋转。输入中的 $v$ 直接无视即可。

3. 五颗龙玉每 $t$ 秒钟发射一圈弹幕，一圈 $k$ 个子弹，且每两颗子弹角度相同。$aa$ 发出的子弹中有一个子弹是背对辉夜的方向的，其他的龙玉发出的子弹方向与 $aa$ 相同。

有 $k$ 颗子弹，角度都一样，发射的方向必然会将一个以一颗龙玉为圆心的圆  $k$ 等分（如图为 $k=8$ 的情形）。

![图2](https://z3.ax1x.com/2021/10/19/5wXpwQ.png)

而“所有龙玉的发射方向相同”这一点，同样会因为人是一个点，没有方向，可只考虑 $1$ 颗龙玉的情况。

4. 我们可以认为子弹是无限快的。

这道题最特殊的一点。这一点可以使我们忽略所有与速度，时间与距离的值。输入中的 $r\ ,\ R$ 和 $t$ 直接被我们忽略了！

现在每一组数据只剩下 $k$ 这一参数，问题也变为了：判断人是否在某一颗子弹的运动路线上。

而题目中点明：有一个子弹是背对人的方向的。

然后我们就发现了 $k$ 和答案的关系：若 $k$ 为奇，输出 ```yes``` ，否则输出 ```no``` 。

注意一下时限是 $500ms$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long read()
{
	long long s=0,k=1;
	char c=getchar();
	while(!isdigit(c))
	{
		k=(c=='-')?-1:1;
		c=getchar();
	}
	while(isdigit(c))
	{
		s=s*10+c-'0';
		c=getchar();
	}
	return s*k;
}
#define d read()
#define ll long long
#define Maxn 10010
#define Size 10010
#define mp make_pair
#define pb push_back
int main()
{
	ll t=d;
	while(t--)
	{
		scanf("%*lf%*lf%*lf%*lf");
		if(d&1) puts("yes");
		else puts("no");
	}
}
```

---


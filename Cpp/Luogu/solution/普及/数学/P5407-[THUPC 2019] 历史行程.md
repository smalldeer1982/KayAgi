# [THUPC 2019] 历史行程

## 题目背景

> 人生是怎么样的呢？我们是怎样活着的呢？
>
> 无论是谁，都是从黑暗中降生，最后再回归于黑暗。几年，几十年，短暂而漫长的时光。形形色色的人，形形色色的事，如过眼云烟，转瞬即逝。过眼繁花终有尽时，有些东西还能弥留于你的记忆之中，但更多的，早已无可寻觅。
>
> 但是，有个人，你不会忘记。
>
> 在你降生于黑暗之中时，那个人就一直陪在你身边。当你突破那黑暗，第一次见到世界的光明的时候，那个人也在你身边。
>
> 第一次的啼哭，第一次的说话，第一次的走路，第一次的奔跑。
>
> 每一次的成长，是你自己的一次飞跃。而对那个人来说，则是最纯真的喜悦和感动。
> 
>在你不知道的时候，在你不知道的地方，那个人倾尽自己的一切，为你创造最好的一切，保护你的一切，为你指引走向未来的桥梁。
>
> 那个人每天都在期盼着，期盼着你能早点长大，变得拥有保护你自己的力量。
>
> 那个人每天都在担心着，担心着你与那个人分别那天，终究还是会来到。
>
> 你终究会一直成长，你终究会拥有自立自强的能力。那个人，也不能再像以前一样，保护你。
>
> 有一天，你将走向更宽阔的未来，你会拥有和以前完全不一样的一切。而那个人，已经不再能够保护你了。
>
> 而你和那个人之间能够拥有的时间，也就越来越短了。
>
> 五年，十年，二十年，你一天一天长大。
>
> 五年，十年，二十年，那个人一天天老去。
>
> 那个人已经不能保护你了，那么现在，该你，去保护那个人了。
>
> 也许那个人不能永远在你身边，也许那个人终将离你而去。
>
> 但你永远不会忘记那个人，因为那个人，始终在你身边。
>
> 今天，是那个人的节日。

## 题目描述

母亲节是一个为感谢母亲而庆祝的节日，而在世界各地的母亲节的日期有所不同。母亲们在这一天里通常会收到孩子们送的礼物；而在许多人心目中，康乃馨被视作最适于献给母亲的鲜花之一。

1913 年，美国国会确定将每年 5 月的第二个星期日作为法定的母亲节，这也是现代母亲节的起源。

给定一个年份，请你输出这一年的母亲节的日期。方便起见，你只需要输出它是这年 5 月的第几天即可。

## 说明/提示

### 样例解释

2019 年的母亲节是 5 月 12 日。

### 关于数据

由于一些原因数据只保留了随机的 $50$ 个点。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
2019```

### 输出

```
12```

# 题解

## 作者：loceaner (赞：34)

我纯粹是看到了上面一大堆话才想做这个题的，真的写的很棒，纵使今天早已不是母亲节，但我也还是想对妈妈说：“母亲节快乐！”希望以后多有些这样的题目，这真的能够吸引人来做（难道你们做题都不带感情的吗？）

这个题的要求是：输入一个年份，输出这个年份母亲节的日期，只需要输出是5月的第几天

这题不水，一点都不水，有许多题解的做法是找规律，但是我没用这个做法，我这里给出的做法将是一个最简单又粗暴的做法：

**查日历**

我知道这很荒唐，但这不正是一种解决问题的方式吗？

我就这样一个个查了下来，能做出这道题，真的很开心，至少我通过了自己的努力，过了这道题


```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[200]={11,10,9,14,13,12,11,9,8,14,13,11,10,9,8,13,12,11,10,8,14,13,12,10,9,8,14,12,11,10,9,14,13,12,11,9,8,14/*1950*/,13,11,10,9,8,13,12,11,10,8,14,13,12,10,9,8,14,12,11,10/*1970*/,9,14,13,12,11,9,8,14,13,11,10,9,8,13,12,11,10,/*1987*/8,14,13,12,10,9,8,14,12,11,10,9,14,/*2000*/13,12,11,9,8,14,13,11,10,9,8,13,12,11,10,8,14,13,12};

int main(){
	cin>>n;
	cout<<a[n-1913]<<"\n";
}
```


---

## 作者：设计涉及社稷 (赞：12)

## 不用打表，不用找规律的新新解法：蔡勒公式

as is known to all,蔡勒公式是一个用于求解任意日期是星期几的强大公式（包括闰年的特殊情况）

### 公式介绍：
week=y+[y/4]+[c/4]-2c+[13*(m+1)/5]+day-1

week：星期,week对7取模得：0-星期日，1-星期一，2-星期二,etc;

c(世纪的英文单词century的缩写)：year%100仅适用于16c以后 

year：year%100年（后两位数）

如，2019的c为20，y为19

month：月（month大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算）

day：日 [ ]代表取整，即只要整数部分。

### 看个例子，求解2049年10月1日是星期几：

week=y+[y/4]+[c/4]-2c+[13(month+1)/5]+day-1

week=49+[49/4]+[20/4]-2×20+[13×(10+1)/5]+1-1

week=49+[12.25]+5-40+[28.6]

week=49+12+5-40+28

week=54%7余5

则是星期五 

### 代码：
```
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;++i)
using namespace std;

int year,month,sunday;

int main(){
	//freopen("mother.txt","r",stdin);
	scanf("%d",&year);
    int c=year/100;
    int y=year%100;
    month=5;//直接把月份锁定在5月
    rep(day,1,31){//枚举5月的所有日期（5月大，31天）
	    int week=(c/4)-2*c+(y+y/4)+(13*(month+1))/5+day-1;//蔡勒公式
	    while(week<0)week+=7;//避免week为负
	    week%=7;
    	if(week==0)sunday++;//week==0即星期天，week不是==7，因为7%7==0
    	if(sunday==2){//5月的第二个星期天，已找到
    		printf("%d",day);
    		break;
		}
	}
    return 0;
}
```


---

## 作者：1kuzus (赞：7)

这是很好的一道平闰年的题目

（内含优化过程与拓展）

我们先来观察规律

因为五月第一个周日可以在 1号 到 7号 任何一天

那么五月第二个周日可以在 8号 到14号 任何一天（在上面基础上加7）

观察近十年的日期：

年份---------母亲节是五月( )日

*(2020)------10

2019---------12

2018---------13

2017---------14

*2016--------8

2015---------10

2014---------11

2013---------12

*2012--------13

2011---------8

2010---------9

2009---------10

......

我们发现随年份递增（上面的表格要从下往上看），母亲节的日期大致呈

14 13 12 11 10 9 8 14 13 12......

的规律循环，但个别年份变化不遵循规律，准确的说，是跳过了数列的一个项。

这些年份用 星号 标出，不难发现这些特殊年份恰好是闰年

看日历我们知道1911年母亲节在14号（从题中给的2019年母亲节在12号也可以推出，确切地说，知道任何一年都可以）

我们把上述序列 14 13 12 11 10 9 8 14 13 12......称作数列A，

那么若第i年的母亲节在五月x日，第j（j>i）年的母亲节在五月y日，其中x是A的第k项，
那么y是A的第k+（j-i）+（i到j有多少闰年）项。

要好好理解上一句话，（j-i）是普遍规律，（i到j有多少闰年）是多跳过的项数


```cpp
#include <iostream>
using namespace std;
int p[7]={14,13,12,11,10,9,8};//所有可能的日期情况
int q(int L,int R)//求L到R的闰年个数
{
	int ans; 
	for(int i=L;i<=R;i++)
	if(i%4==0)//本题数据跨度较小，不需要考虑世纪闰年的情况，
              //所以判断条件比较简单。
	ans++;
	return ans;
}
int main()
{
	int year;cin>>year;
	cout<<p[((year-1911)+q(1911,year))%7];
    //因为1911年母亲节是14号，是数组第0项，所以求得答案直接模7
	return 0;
}
```

以上代码时间复杂度是O（n），可以过本题，如果让求很多年以后则会超时。

推荐个人题目：[母亲节（历史行程加强版）](https://www.luogu.org/problemnew/show/U72805)

Q函数可以优化，求【L，R】范围内x的倍数的个数，可能会首先想到

（R-L）/x

这个式子，但是不难发现这个式子的结果有时是正确答案，有时差1；

换个角度，我们用1-R范围内x的倍数的个数减去1-L范围内x的倍数的个数，这样就会得到

R/x-L/x

这个式子，本题中x=4。（当然如果你是大佬你会直接想到这个式子）

这样的话就可以省略函数部分，直接带入,q(1911,year)就变成year/4-1911/4，即year/4-477，然后可以发现数组都免了，因为p[i]
和i就是和为14的关系，比如p[3]=11，p[6]=8等，

最后八行代码解决这道题目

AC代码：
```cpp
#include <iostream>
using namespace std;
int main()
{
    int year;cin>>year;
    cout<<14-((year-1911)+year/4-477)%7;	
    return 0;
}
```


---

## 作者：Eason_AC (赞：4)

要优化干什么？这个题目不该直接推日期就行了吗？（满脸疑惑

这道题目的处理方式其实和[P1202 【USACO1.1】黑色星期五Friday the Thirteenth](https://www.luogu.org/problem/P1202)很像，只是稍微有一点技巧而已。

---

一看到这个题目，先看数据范围：$1913\leqslant y\leqslant2019$，还以为要打表，但是感觉打表太麻烦了，就立即放弃了这个想法。

（P.s. 正如你们所见，这道题目里面其实还真有个打表的题解。怎么打到表的我先不说，但本人建议还是不要打表的好，毕竟打表不是万能的。）

那么就立即想到了类似上面提到的那道题目的做法——暴力推日期。毕竟数据范围只有$107$年（包括$1913$和$2019$年），所以不会超时。

这道题目其实我小号博客里也写过题解的，但是为了方便大家还是把推日期的方法讲下吧：

$Step~1:$每次开始的时候，天份和星期数各加$1$。

$Step~2:$判断：

$1)$如果天份超过那个月的天数，那么天份归$1$，同时月份加$1$。

$2)$如果月份大于$12$，那么月份归$1$，同时年份加$1$。

$3)$单独判断星期数，如果星期数大于$6$（本人题解中用数字$0$代表星期日，其他一一对应），那么星期数归$0$。

$4)$这个题目里要判断的：如果已经到了输入年份的$5$月，那么开始每逢星期日记一次数，记满两次就跳出循环。

此时输出最终的天份就行了。

注意代码实现的时候要判断闰年的情况，以下是本人考虑闰年的函数$judge$：

```cpp
bool check(int y) {
	if(!(y % 100)) {
		if(y % 400)	return 0;
		return 1;
	}
	if(y % 4)	return 0;
	return 1;
}
```
这样判断闰年就行了。

还有月份，建议是弄一个数组$a$，记录每个月的天数（此处$2$月记$28$天，只不过每逢闰年$2$月就加$1$罢了）。

其他按照上面来实现就可以了。

实在还有不懂的可以来看一下下面的代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

//经度娘搜查可知：1913年1月1日 星期三 
//用week=0表示星期天
const int a[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
int y = 1913, y2, m = 1, d = 1, week = 3, mom = 0;

bool check(int y) {
	if(!(y % 100)) {
		if(y % 400)	return 0;
		return 1;
	}
	if(y % 4)	return 0;
	return 1;
}
int main() {
	scanf("%d", &y2);
	while(1) {
		d++, week++;
		if(week > 6)	week = 0;
		if(d > (check(y) ? (m == 2 ? a[m] + 1 : a[m]) : a[m]))
			d = 1, m++;
		if(m > 12)
			y++, m = 1;
//		printf("%d/%d/%d, %d\n", y, m, d, week);
		if(y == y2 && m == 5) {
			if(week == 0)	mom++;
			if(mom == 2)	break;
		}
	}
	printf("%d", d);
	return 0;
}
//防盗水印：UID=112917
```
不在右上角点个赞再走嘛qwq？~~还有我没有碰到过这么水的清华大学程序设计竞赛的题目~~

---

## 作者：花落丶子不语 (赞：3)

 ~~事先声明，这题打表是非正解（手动滑稽）~~
 利用Excal来打表舒服的很
 （以下贴出1913至2019母亲节日期）
 ![](https://cdn.luogu.com.cn/upload/pic/65314.png)
 ![](https://cdn.luogu.com.cn/upload/pic/65313.png)
 ![](https://cdn.luogu.com.cn/upload/pic/65312.png)
 ![](https://cdn.luogu.com.cn/upload/pic/65310.png)
 ![](https://cdn.luogu.com.cn/upload/pic/65308.png)
 就不贴代码啦~~~
 （真·懒）

---

## 作者：方俊懿 (赞：2)

看题目名称以为是啥题，原来是算日期。

这里有计算星期几的公式：
1. $\operatorname{f}=\dfrac{14-\operatorname{month}}{12}$
2. $\operatorname{y}=\operatorname{year}-\operatorname{f}$
3. $\operatorname{m}=\operatorname{month}+12\operatorname{f}-2$
4. $\operatorname{ans}=(\operatorname{day}+\operatorname{y}+\dfrac{31\operatorname{m}}{12}+\dfrac{\operatorname{y}}{4}-\dfrac{\operatorname{y}}{100}+\dfrac{\operatorname{y}}{400}+1)\mod7$

| ans  | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-------|----|----|----|----|----|----|----|
| 星期  | 日| 一| 二| 三| 四| 五| 六|

---
如果你不怀疑公式的正确性，可以直接看代码实现。
- ### $\operatorname{f}=\dfrac{14-\operatorname{month}}{12}$
	$\operatorname{f}=0$ 说明在$2$月后
   
	$\operatorname{f}=1$ 说明在$2$月前
- ### $\operatorname{y}=\operatorname{year}-\operatorname{f}$
	在$2$月前就算是在前一年。
- ### $\operatorname{m}=\operatorname{month}+12\operatorname{f}-2$
	月份$-2$，如果是在$2$月前，加$12$。
- ### $\operatorname{ans}=(\operatorname{day}+$...
   答案要加上日期。
- ### $+\operatorname{y}+$...
   答案也要加上年份，因为一年有$52$周$1$天。
- ###  ...$+\dfrac{31\operatorname{m}}{12}+$...
	答案还要加上……
- ### ...$+\dfrac{\operatorname{y}}{4}$...
	 以前有多少个能除尽4的年份，当成闰年加进答案。
- ### ...$-\dfrac{\operatorname{y}}{100}$...
   由于能除尽$100$的大多不是闰年，要减。
- ### ...$+\dfrac{\operatorname{y}}{400}$...
   由于能除尽$400$的是闰年，还要加。
- ### ...$+1$...
   由于某种原因，答案还要加$1$。
- ### ...$\mod 7$
   因为答案是星期几，要模$7$。
# code:
```cpp
#include <cstdio>
int y,ans=0;
int week(int y,int m,int d)//核心函数
{
    int f=(14-m)/12;                             //step 1
    int yy=y-f;                                  //step 2
    int mm=m+12*f-2;                             //step 3
    return (d+y+31*mm/12+yy/4-yy/100+yy/400+1)%7;//step 4
}
int main()
{
    scanf("%d",&y);
    for(int sum=0;sum<2;ans++)//第2个之前
    {
        if(week(y,5,ans)==0)//y年5月ans日是星期日
            sum++;//现在是第sum个星期日
    }
    printf("%d",ans);
    return 0;
}
```

## END

---

## 作者：苏打青柠水 (赞：1)

发表一篇Java的做法，java里面有一SimpleDateFormat类，可以进行日期的转换，而且转换后的日期可以知道某一年某个月某一天所代表的星期，因此可以通过某一年的5月1号来推出母亲节。
 ```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class Main {

	public static void main(String[] args) throws IOException, ParseException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		String year = reader.readLine().trim() + "-05-01"; // 获取某年的五月一号的日期字符串
		reader.close();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); // 日期转换模板
		/*
		 * @Year: 1914
		 * 
		 * @Time: Fri May 01 00:00:00 CST 1914
		 */
		String[] time = simpleDateFormat.parse(year).toString().split(" "); // 获取日期数组，time[0]表示星期

		// time[0]表示五月一号的星期
		switch (time[0]) {
		case "Mon": // 周一
			System.out.println(14);
			break;

		case "Tue": // 周二
			System.out.println(13);
			break;

		case "Wed": // 周三
			System.out.println(12);
			break;
		case "Thu": // 周四
			System.out.println(11);
			break;
		case "Fri": // 周五
			System.out.println(10);
			break;
		case "Sat": // 周六
			System.out.println(9);
			break;
		case "Sun": // 周日
			System.out.println(8);
			break;
		}

	}
}
```


---

## 作者：CrystalSunny (赞：0)

## P5407 [THUPC2019]历史行程
### 题意
输入1913~2019之间的一个年份，输出这一年的母亲节是5月几日。

------------
### 思路
#### ~~打表~~

不会有人没有想到打表吧，不会吧不会吧不会吧？

不过，本蒟蒻实在懒得查日历或用Excel打表，因此敲了个程序打表~~虽然感觉这个更累~~。

那么其实还是要找规律QAQ。


------------

#### 现在要输出每年的母亲节日期用来打表

- 首先要清楚，2018年的母亲节是13日，那么365天后的2019年5月13日，是母亲节吗？显然不是，因为母亲节虽然接近跨年，但是是用**星期**算的。因此母亲节的周期不是356天（或366天），而是**接近365的一个7（一星期为7天）的倍数**。那么不难试出，这个数是：**7*52=364**。也就是说，一般情况下，前后两个母亲节之间相差364天。而两个日期相差1（365-364=1）或2（366-364=2）天，如：2018年的母亲节是13日，2019年的母亲节是12日。

- 然后，要考虑特殊情况。母亲节必须是**第二个星期日**，但我们知道年周期总与母亲节周期相差1（365-364=1）或2（366-364=2）天。这就意味着，在某个母亲节的364天后的这天，由于周期的偏差，**不再是第二个星期日，而成为了第一个星期日**。这时，就需要找到第二个星期日，并且从这个星期日开始，继续364天一周期的母亲节，直到某个364天后，又变成了第一个星期日......如此循环往复，直到2019年。

- 最后要说的就是平润年的问题，前面的叙述中已经把平润两种可能都写上了。代码中只需要加个判断。它们的差别主要在于，两者周期与母亲节周期相差的天数不同，所以需要做的运算也略微不同。

那么上代码，具体的操作在其中也有解释：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n=4,day=11; // 查1913的日历可知，日期差n=4天就不再是第二个周日；这年的母亲节是day=11日 
	bool b ;// 记录平or润年 
	for(int i=1914;i<=2020;i++){
		b=1; // 每次初始化为1 
		cout<<day<<","; // 先输出，所以是1914~2020的循环 
		
		if(i%100==0&&i%400==0) // 判断是否是闰年 
			b=0; // 是闰年则赋为0 
		else if(i%4==0)  // 同上 
		 	b=0; 
		 	
		if(b) // 平年 
			day--,n--; // 与母亲节周期差1天，日期与差减1 
		else // 闰年 
			day-=2,n-=2; //与母亲节周期差2天，日期与差减2
			
		if(n<=0)// 如果日期差0天就不再是第二个周日（已经变成了第一个周日）
			n+=7,day+=7;//寻找第二个周日，日期和差加一星期 
	}
	return 0;
}

```
然后把输出复制过来，打表完成！！（鼓掌掌）


------------
打表代码就不发了，别的题解都有。~~主要是本蒟蒻太懒，写完这些已经心力交瘁，停止思考。~~

这篇题解就到这里。（卑微蒟蒻求过）

---

## 作者：whatismyname0 (赞：0)

其实这几道题很简单的

只需要用基姆拉尔森公式来反向运用
# 时间复杂度O（31）
也就是说判断五月x号是不是星期日
如果是就输出（当然有一个变量来计它是不是第二个）
基姆拉尔森计算公式
$W= (d+2m+3(m+1)/5+y+y/4-y/100+y/400) mod 7$

在公式中d表示日期中的日数，m表示月份数，y表示年数。

在该题中W=7，d为我们要判断的一天，m=5，y就是输入的数
代码如下
```cpp
#include<iostream>
using namespace std;
int main()
{
	long long ans=0,y;
	cin>>y;
	for (int i=1;i<=31;i++)
	{
		if ((i+2*5+3*(5+1)/5+y+y/4-y/100+y/400)%7==6)ans++;
		if (ans==2)
		{
			cout<<i;
			return 0;
		}
	}
}
```
~~十分简洁~~

[运行连接](https://www.luogu.org/recordnew/show/20769242)

---

## 作者：virus_bh (赞：0)

~~第一篇题解因本人太水而未过，于是刷着刷着就发现了这水题竟然没题解~~

一开始想模拟，~~然后算了好久的年月日~~，显然不是很优秀。

从2019年开始推：
1. 2019年的第二个星期天是7+5日；
1. 2018年的第二个星期天是7+6日；
1. 2017年的第二个星期天是7+7日；
1. 2016年的第二个星期天是7+1日！！；
1. 2015年的第二个星期天是7+3日！！!；
1. 2014年的第二个星期天是7+4日；
1. 2013年的第二个星期天是7+5日；

... ...

这么说来，连续几年的日期关系是确定的,发现每年的日期数(365,366)是固定的，因此~~就可以打表了~~就可以得到表达式。
## 注意闰年的2月夹在前一年与闰年的中间

1. 年数%4==3时（2015...）比后一年的日期多两天；
1. else （2018，2017...）比后一年的日期多一天；
1. ps：日期数大于14时，日期数%=7；日期数为7时，一定不是第二星期的星期天，因此日期数+=7；

### 代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,ans;
	cin>>n;
	ans=5;//初始化
	for(int i=2018;i>=n;i--){//2018年开始算
    	if(i%4==3){//闰年前一年
			ans=(ans+2)%7;
			if(ans==0)ans+=7;
		}
		else {//一般年份
			ans=(ans+1)%7;
			if(ans==0)ans+=7;
		}
	}
	cout<<7+ans;//因为ans%=7，所以再加上7
	return 0;
}
```


---


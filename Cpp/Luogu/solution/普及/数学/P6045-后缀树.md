# 后缀树

## 题目背景

Eztsu 是一个可爱的女孩子，最近她学习了[后缀树](https://www.luogu.com.cn/blog/EternalAlexander/xuan-ku-hou-zhui-shu-mo-shu)，并打算用它来解决如下问题。

## 题目描述

对于一个字符串 $S$，我们定义 $|S|$ 表示 $S$ 的长度。

接着，我们定义 $S_i$ 表示 $S$ 中第 $i$ 个字符，$S_{L...R}$ 表示由 $S$ 中从左往右数，第 $L$ 个字符到第 $R$ 个字符依次连接形成的字符串。

给定 $n$，求有多少种不同的满足下列要求的串 $S$：

- $|S|=n$。
- $S$ 中仅包含小写字母。
- 不存在整数 $i \in [1,n)$ 使得 $S_{1...i}$ 是 $S_{i+1...n}$ 的子串。

对于第三个限制，用通俗一点的说法解释的话，就是不存在一种将这个串分成两段的方式，使得前面一段是后面一段的子串。

两个串 $S$ 和 $T$ 不同当且仅当 $|S|\neq|T|$ 或 $\exists i \in [1,|S|] S_i \neq T_i$。如果你不知道这是什么意思，你可以理解为它们看起来不同。

可怜的 Eztsu 不会做，所以你要帮她做这道题。

答案可能很大，你只需要输出答案对 $998244353$ 取模的值。

题面补充：

$S$ 是 $T$ 的子串当且仅当存在 $L,R \in [1,|T|]$ 使得 $T_{L...R}=S$.

## 说明/提示

#### 样例解释

对于第一组样例，不难发现，这个串符合题意当且仅当两个字符不同，因此答案为 $26 \times 26 - 26$，可以理解为两个字符任意的方案数减去两个字符相同的方案数。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 10^9$。

$\text{Subtask 1 (17 pts)}$ $n \leq 4$。

$\text{Subtask 2 (78 pts)}$ $n \leq 2\times 10^3$。

$\text{Subtask 3 (5 pts)}$ 没有特殊限制。

---

#### 提示

小写字母一共有 $26$ 个。

## 样例 #1

### 输入

```
2```

### 输出

```
650```

## 样例 #2

### 输入

```
105383595```

### 输出

```
114514```

# 题解

## 作者：StudyingFather (赞：18)

第一个字母当然可以随便选。

问题来了，接下来的字母有什么限制呢？

其实很宽松，只需要**不和第一个字母相同即可**。

原因？根据题目的定义，后面的字母只要不和第一个字母相同，就不存在一种分割方案，将串 $s$ 分割为 $s_1$，$s_2$，使得 $s_1$ 是 $s_2$ 的子串。否则的话，从第一个字母后分割就是一种合法的分割方案。

因此，第一个字母有 $26$ 种选法，后面每个字母都不能和第一个字母相同，答案当然是：

$$
ans=26 \times 25^{n-1}
$$

使用快速幂计算上式即可通过本题。

---

## 作者：Warriors_Cat (赞：6)

## 题解 P6058 【后缀树 suffix】

刚开始这道题我没有思路，于是就枚举了一下 $n=2,3,4$ ，然后就发现了一些很奇妙的事情。

首先，$n=2$ 时当然有$670$种。

然后再看 $n=3$ ，第一步，此时 $S_{1...2}$ 必须是一个满足要求的串，否则第一个字母就可以直接干掉。第二步，在 $S_{1..2}$ 的基础上加一个字母有 $26$ 种选择，可是首先要避开第一个字母，于是有 $25$ 种选择。

然后你就发现这 $25$ 个字母无论哪一个都符合要求。

$n=4,5,6$ 也是一样。

于是乎，本题的答案就为：

$$26\times25^{n-1}$$

当然还要对 $998244353$ 取模啦QAQ

$25^{n-1}$ 珂以用快速幂求出，没学过快速幂的小盆友珂以康康 [$P1226$](https://www.luogu.com.cn/problem/P1226)哦-v-

最后就上代码吧：

```
#include <bits/stdc++.h>//居然还用万能头【烂啊】
using namespace std;
#define int long long//偷懒懒QAQ
const int mod = 998244353;
inline int fpow(int n, int p){
    n %= mod;
    int ans = 1, base = n;
    while(p){
        if(p & 1) ans = ans * base % mod;
        base = base * base % mod;
        p >>= 1;
    }
    return ans;
}//快速幂模板
int n;
signed main(){
    cin >> n;
    cout << 26 * fpow(25, n - 1) % mod;
    return 0;
}
```
## End

---

## 作者：jijidawang (赞：2)

第一个字符，$26$ 种选择。

第二个字符不能和第一个字符相同，因为如果相同就有一种分割方方案使第一个字符串是第二个字符串的子串了，$25$ 种选择。

第三个字符也不能和第一个字符相同，$25$ 种选择。

$\dots$

第 $n$ 个字符也不能和第一个字符相同，$25$ 种选择。

答案即为 $26\times 25\times 25\dots \times 25=26\times25^{n-1}$

快速幂即可解决。

~~总搞不懂为什么 Eztsu 想用后缀树解此题~~

---

## 作者：霍士弘 (赞：1)

## 前置知识：乘法原理
如果做一件事情需要 $n$ 个步骤，每个步骤有 $a_i$ 种方案，则做这一件事情总共有 $\prod_{i=1}^{n} a_i$ 种 方案。  
如果还是不懂的话，可以百度，或者翻高中数学书。  
## 前置知识：快速幂
这是一种在可以在 $\Theta(\log n)$ ($n$ 为指数) 的时间完成幂运算的一种方法  
如果我们要求 $a^p$，我们可以分几种情况来讨论：  
① $p = 0$，很明显答案是 $1$；  
② $p = 1$，很明显答案是 $a$；  
③ $p$ 为偶数，我们可以考虑折半处理，即 $a^p = a^{\frac{p}{2}} \times a^{\frac{p}{2}}$；  
④ $p$ 为奇数，我们也可以考虑折半处理，即 $a^p = a \times a^{\frac{p-1}{2}} \times a^{\frac{p-1}{2}}$；  
每次的规模减少，可以采用递归的方式来实现。  

关于时间复杂度：  
很明显，时间复杂度与 $a$ 的大小无关。  
设 $T(n)$ 为求 $a^n$ 所用的时间复杂度。  
则 $T(n) = T(\dfrac{n}{2}) + \Theta (1)$  
根据[主定理](https://baike.baidu.com/item/%E4%B8%BB%E5%AE%9A%E7%90%86/3463232?fr=aladdin)，时间复杂度为 $\Theta(\log n)$。  
## 这道题的解法  
言归正传，这道题怎么做呢？  
首先考虑第一个字符怎么选，由于第一个字符不能成为后面字符串的子串，所以，$[2,n]$ 的所有字符都必须和第一个字符不同。  
前缀串包括第一个字符，所以不可能成为后缀串的子串，所以满足条件。  
所以答案呼之欲出，根据乘法原理，第一位有 $26$ 中选法，后面 $n-1$ 位都只有 $25$ 种选法，乘积即为答案，所以答案是:$26 \times 25^{n-1}$  
用快速幂求出 $25^{n-1}$ 即可。  
复杂度 $\Theta(\log n)$  
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define mod 998244353
using namespace std;
ll qpow(int a,int p)
{
	if(p == 0) return 1;
	if(p == 1) return a % mod;
	ll ans = 1;
	if(p % 2 == 0)
	{
		ans = qpow(a,p/2) % mod;
		ans = ans % mod * ans % mod;
		return ans;
	}else
	{
		ans = qpow(a,(p-1)/2) % mod;
		ans = a % mod * ans % mod * ans % mod;
		return ans;
	}
}
int main()
{
	int n;
	cin>>n;	
	ll ans = 26 % mod * qpow(25,n-1) % mod;
	cout<<ans % mod;
	return 0;
} 
```

---

## 作者：Hexarhy (赞：0)

稍微动脑就能做出来的结论题。当做比赛第一题也挺友好的。

跟后缀树有什么关系吗……

---------

### 题意简述

给定长度 $n$，求出有多少种方案，能使得 $S$ 只由小写字母组成，且不存在一种将这个串分成两段的方式，使得前面一段是后面一段的子串。

### 解题思路

**前置知识：**

- 排列组合基础知识。
- 快速幂。

直接讲正解思路吧。

其实样例解释已经给出了正解暗示。我们从这里出发。

首先，我们能确定，第一个字符一定能填 $26$ 个字符任意一个。因为分割不能从第一个前面分。

当 $|S|=2$ 时，分割只能从中间分，也就是当两个字符不同时，就是合法方案。

当 $|S|=3$ 时，分割只能从第一位后面分。因为从第二位分，前面的长度已经大于后面，不可能是其子串。那么，只要第一个字母（前面子串）不与后面的字母（后面子串）相同即可。

推广到一般情况，直接考虑**最极端的情况**，也就是最容易非法的情况。显然能想到，在第一位后面分，**使第一个字母单独成子串**。

那么后面的每一个字母都有机会与它重复，成为非法方案。

所以最终的答案就是，**第一个字母任取，后面的字母不与第一个重复**就可以，也就是从剩下的 $25$ 个字母里去。

根据**乘法原理**，答案为：

$$26\times25^{n-1}$$

记得取模。

---------

可惜的是，对于乘方，

- C++ 自带的`pow()`虽然时间复杂度为 $O(\log n)$，但并不能取模。
- 朴素乘方需要 $O(n)$，会超时。
- 只能用快速幂。

快速幂不会的同学请点击[这里](https://www.luogu.com.cn/problemnew/solution/P1226)。

时间复杂度为 $O(\log n)$。

### 实现细节

- 最好开`long long`，避免中途乘爆`int`。
- 没了。这题没什么坑点。


### 参考代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
const ll MOD=998244353;
ll n;

ll fpow(ll n,ll k)
{
	ll base=n,res=1;
	while(k)
	{
		if(k&1)
		 res=res*base%MOD;
		base=base*base%MOD;
		k>>=1;
	}
	return res;
}

int main()
{
	cin>>n;
	cout<<(fpow(25LL,n-1)*26LL)%MOD<<endl;
	return 0;
}
```

---

## 作者：lishuo123 (赞：0)

# 补充一下代码
楼上的大佬讲的很清楚了，这是一道简单的贪心题，当仅仅只取第一位时其能匹配到的字符串最多。因为每多取一位，新取这一位后，完全匹配模板字符串的数量必定小于等于之前匹配的数量。这里简单补充一下AC代码
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define ll long long
using namespace std;
ll ksm(ll x,ll y){//注意开long long 
	ll a = 1,base = x;
	while(y){		
		if(y & 1) a = (a * base) % mod;
		base = (base * base) % mod;
		y >>= 1;
	}
	return a % mod;//拼命mod 
}
int main(){
	ll n;
	cin >> n;	
	printf("%lld",((ksm(25,n-1) % mod)*26) % mod);//输出26*25^(n-1) 
} 
```



---


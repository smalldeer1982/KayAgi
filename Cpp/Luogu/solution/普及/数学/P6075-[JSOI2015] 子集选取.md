# [JSOI2015] 子集选取

## 题目描述

给定 $n$ 个元素的集合 $S= \left\{1,2,\cdots,n \right\}$ 和整数 $ k$，现在要从 $S$ 中选出若干子集 $A_{i,j}\ (A \subseteq S$，$1 \le j \le i \le k)$ 排成下面所示边长为 $k$ 的三角形（因此总共选出了 $\frac{1}{2} k(k+1)$ 个子集）。      
$$\begin{matrix}
A_{1,1}\\
A_{2,1}&A_{2,2}\\
A_{3,1}&A_{3,2}&A_{3,3}\\
\vdots&\vdots&\vdots&\ddots\\
A_{k,1}&A_{k,2}&A_{k,3}&\cdots&A_{k,k}
\end{matrix}   $$

此外，JYY 对选出的子集之间还有额外的要求：选出的这些子集必须满足
$A_{i,j} \subseteq A_{i,j-1}$ 且 $A_{i,j} \subseteq A_{i-1,j}$。     
JYY 想知道，求有多少种不同的选取这些子集的方法。因为答案很大，JYY 只关心输出答案模 $1{,}000{,}000{,}007$ 的值。 
      
对于两种选取方案 $A = \left\{ A_{1,1} , A_{2,1} ,\cdots, A_{k,k} \right\}$ 和 $B = \left\{ B_{1,1} , B_{2,1} ,\cdots, B_{k,k} \right\}$ 只要存在 $i,j$ 满足 $A_{i,j} \neq B_{i,j}$，我们就认为 $A$ 和 $B$ 是不同的方案。   

## 说明/提示

对于 $100\%$ 的数据，$1 \le n$，$k \le 10^9$。

## 样例 #1

### 输入

```
2 2```

### 输出

```
16```

# 题解

## 作者：llmmkk (赞：35)

#####  链接：[P6075](https://www.luogu.com.cn/problem/P6075)

---

#####  前言：

虽然其他大佬们的走分界线的方法比我巧妙多了，但还是提供一种思路。

---

#####  题意：

%&￥……@#直接看题面理解罢。

---

#####  分析过程：

看到这样的题面我脑里第一反应就是DP，但是看到`n`和`k`的范围只能作罢。想到各种柿子又根本推不出来，于是颓废地打了个~~复杂度算不来的貌似是~~ $2^{n^3}$ 的深搜。于是有以下测试：

**input  &nbsp;&nbsp;&nbsp;&nbsp;  output**

`1 2`   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `4`

`2 2`   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `16`

`3 2`   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `64`

`1 3`  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `8`

`2 3`   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `64`

`3 3`   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`512`

于是我们惊喜地发现答案貌似就是$2^{kn}$。但这个答案到底是怎么来的呢？

---

##### 证明：

我们发现对这道题，所谓集合是可以拆解成`n`个元素分别处理的，可将其视为从三角形左上角起向右下进行连续的覆盖，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6nczdiv5.png)

 那么设一个元素在大小为`k`的三角形内的覆盖方案数为 $f(k)$ ，那么`n`个元素的方案总数即为 $f(k)^n$ 。接下来来推 $f(k)$ ，注意以下推理仍只关注一个元素。

对于一个大小为`k`的三角形，我们着重分析最下面一行，因为去掉这一行就能转化为更小的三角形，将覆盖，未覆盖以及任意取值分别看做“1”，“0”，和“？”，那么根据题意，这一行的状况只能是前面`m`个1，后面`k-m`个0，分情况讨论。

- 如果这行全部为零，即 ：

![](https://cdn.luogu.com.cn/upload/image_hosting/7hrmoyoz.png)

发现当前的方案数即为上面未确定三角形的方案数$f(k-1)$。

- 如果前面有 `m` $(1\le m< k-1 )$ 个1，即：

![](https://cdn.luogu.com.cn/upload/image_hosting/bszoo2sq.png)

发现当前的方案数即为右上角缺失的三角形的方案数$f(k-1-m)$。

- 如果前面有`k-1`个1，即：

![](https://cdn.luogu.com.cn/upload/image_hosting/x56o7rch.png)

那么最后一位可填0或1，共2种方案。

 总结一下，发现第一种和第二种可合并为$\sum\limits_{i=1}^{k-1}f(i)$,为了美观，我们设 $f(0)$ 为2，即可将第三种情况也合并，即：

 $f(k)=\sum\limits_{i=0}^{k-1}f(i),f(0)=2$

- 当$k=1$时

$f(1)=f(0)=2=2^1$

- 当$k>1$时

因为$f(k-1)=\sum\limits_{i=0}^{k-2}f(i)$

所以$f(k)=\sum\limits_{i=0}^{k-1}f(i)=\sum\limits_{i=0}^{k-2}f(i)+f(k-1)=2*f(k-1)$

综上，$f(k)=2^k$

那么那么n个元素的方案总数即为$f(k)^n$即$2^{kn}$。

---

##### 优化：

呐有人就要问了这不就是个快速幂~~板子题~~吗，有什么优化？对不起的确是有的。

由于我们取模的数1,000,000,007是个质数，所以有费马小定理：$a^{p-1}\equiv 1\pmod p$，也就是说我们可以对指数取模从而减少~~那么几次~~运算量，即$2^{kn\mod 1000000006}$

---

##### 代码：

不就是个快速幂板子吗，就不放代码了。

---

##### 题外话：

~~很睿智的作者看到 `n` ， `k` 的范围大，于是反手就把`k*n`对1,000,000,007取了个模。（100->40）~~

~~有人就要问了，这道绿题你写这么长给谁看啊？没错这篇题解就是我用来练$\LaTeX$的！~~



---

## 作者：一只书虫仔 (赞：12)

#### Description

> 将一个集合 $S=\{1,2,\cdots,n\}$ 的子集排列在一个 $k \times k$ 的等腰直角三角形上，第 $i$ 行第 $j$ 列的位置的集合是 $A_{i,j}$，要满足：
>
> 1. $A_{i,j} ⊆ S$
> 2. $A_{i,j}⊆A_{i,j-1}$ 和 $A_{i-1,j}$
>
> 求有多少种选择排列的方式，对 $10^9+7$ 取模。

#### Solution

繁难则简，先考虑 $n=1$ 的情况。那么不难得知一定存在一条线分割整个三角形，上面都为 $1$，下面都为 $\varnothing$，因为根据第二条限制可以分类讨论得出若干种情况：

- $A_{i,j}=\{1\}$，$A_{i,j-1}=\{1\}$，$A_{i-1,j}=\{1\}$。
- $A_{i,j}=\{1\}$，$A_{i,j-1}=\{1\}$，$A_{i-1,j}=\varnothing$。
- $A_{i,j}=\{1\}$，$A_{i,j-1}=\varnothing$，$A_{i-1,j}=\{1\}$。
- $A_{i,j}=\varnothing$，$A_{i,j-1}=\varnothing$，$A_{i-1,j}=\varnothing$。

注意这里的“分割线”是上升路径（即向上或向右）。

所以排列的方式数通过这种“分割线”的理解可以考虑为方格上升路径计数，答案即为 $2^k$。

拓展到 $n$ 更大的情况，也就是扩一个 $k$ 次幂（不同的组合方式扩幂），因此答案为 $2^{nk}$。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

long long binpow (long long b, long long p, long long k) {
	b %= k;
	long long res = 1;
	while (p > 0) {
		if (p & 1)
			res = res * b % k;
		b = b * b % k;
		p >>= 1;
	}
	return res;
}

int main () {
	long long n, k, Mod = 1e9 + 7;
	scanf("%lld%lld", &n, &k);
	printf("%lld", binpow(2, n * k, Mod));
	return 0;
}
```

---

## 作者：蒟蒻丁 (赞：5)

[洛谷地址](https://www.luogu.com.cn/problem/P6075)
虽然是结论题，但是还是写一下总结回顾比较好
首先考虑一下 $n=1$ 的情况，由于每个点的集合不能比左边和上边的大，所以就会出现有两个部分：
右下角的全都是 $0$，左上角全都是 $1$ 
然后两个部分的分界线就是从左下角的点出发，走到斜边任意一点的一条路径了，我们发现每一步可以往右一格或者往上一格，一定会走 $k$ 格
所以这样就是 $2^k$
然后扩展到 $n$ 就是走了 $n$ 条这样的路径，那么就是 $(2^k)^n$
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const ll mod=1000000007;
ll n,m;

inline ll ksm(ll x,ll k){
	ll tmp=1;
	while(k){
		if(k%2==1)tmp*=x,tmp%=mod;
		x=x*x%mod,k>>=1;
	}
	return tmp;
}

int main(){
	cin>>n>>m;
	cout<<ksm(2,n*m);
	
}
```


---

## 作者：王熙文 (赞：4)

## 思路

首先，我们可以对于每一个数单独考虑，因为数之间互不影响，所以最后答案为每一个数的答案的 $n$ 次幂。现在可以把问题转化为：在边长为 $k$ 的三角形内填 $0$ 或 $1$，要求如果一个位置为 $1$，它的左边和上面也必须为 $1$。求方案数。

按列考虑。对于一列，数的分布是前面若干个 $1$ 之后全都是 $0$，要不然不满足上面必须为 $1$ 的限制了。再考虑列与列直接的关系，对于当前列，最下面的 $1$ 必须在左边列最下面 $1$ 的上面或同一行。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/w1em0fu8.png?x-oss-process=image/resize,m_lfit,h_150,w_150)

这个图中被红色笔划掉的就是 $i$ 这一列不能放的。

所以，除了第一列，每一列的 $1$ 的个数都是严格小于上一列的。

又发现，这个三角形要么全都是 $1$，要么一定会在某一列上变成全 $0$，后面也都是 $0$ 了。

先不考虑全 $1$ 的情况。设变成全 $0$ 的列为第 $i$ 列。如果设第 $0$ 列有 $k+1$ 个 $1$，则这 $k+1$ 个 $1$ 会被减 $i$ 次（每一列严格小于上一列）。现在的问题变成了一个数减 $y$ 次变成 $0$ 的方案数。这个问题等价于一个数 $x$ 被有顺序地分解成 $y$ 个数的方案数。这相当于有 $x$ 个球，分隔 $y-1$ 次把它们变成 $y$ 组。这个的方案数是在 $x-1$ 个间隔中选 $y-1$ 个间隔作为分隔点，$C_{x-1}^{y-1}$。所以这一列全变成 $0$ 的方案数是 $C_{k+1-1}^{i-1}=C_k^{i-1}$。

把所有列变成 $0$ 的方案数都加起来再加上全 $1$ 的方案便是这个问题的方案：$C_{k}^0 + C_k^1 + \cdots + C_k^{k-1} +1=C_{k}^0 + C_k^1 + \cdots C_{k}^{k-1}+C_k^k=2^k$。（每个数都有选或不选的两种情况，一共有 $k$ 个数，所以方案数是 $2^k$）

这是一个数时的方案数。有 $n$ 个数，方案数就是 $2^k$ 的 $n$ 次方。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int qpow(int a,int b)
{
	a%=mod;
	int ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
signed main()
{
	int n,k;
	cin>>n>>k;
	cout<<qpow(qpow(2,k),n);
	return 0;
}
```

---

## 作者：MY（一名蒟蒻） (赞：4)

首先这是一道结论题。

按题意，每个集合都是踏**左**边和**上**面的集合的子集。我们考虑这样一个性质，我们要找的答案与集合中元素是什么煤油关系。

---

如果你没有听懂我上面的鬼话是什么意思煤油关系，窝们现在来说人话。

**考虑最简单的情况，即n=1。**

当n=1时，每一个集合元素的个数不是1就是0.

图我就不画了，[这位大佬的题解](https://www.luogu.com.cn/blog/108616/solution-p6075)中有。

从最**下**面最**左**边的点走k步，每一步有向上和向右两种选择。对于每一个元素，又有是否继承两种选择，所以答案是$2^{nk}$。

快速幂暴力算即可。

---
代码建议自己写，毕竟也不难。

**本题快速幂板子**
```cpp
ll FP(ll k)
{
	if(k == 0) return 1;
	if(k%2 == 0)
	{
		ll num=FP(k/2)%mod;
		return num*num%mod;
	}
	return FP(k-1)*2%mod;
}
```

**Thanks for your watching!**

---

## 作者：迟暮天复明 (赞：2)

[题面](https://www.luogu.com.cn/problem/P6075)

用另一种方法来推导此题。

首先这 $n$ 个数是互相独立的，所以我们不需要统一的去考虑，只需要考虑其中一个数即可。

我们以 $k=5$ 的情况举例。

我设 $f_i$ 为最后一行只填前 $i$ 个点的情况数， $g_i$ 为 $k=i$ 时总共的情况数。

显然， $f_0$ 就是 $g_{k-1}$ ，在这里就是 $g_4$ 。
![](https://cdn.luogu.com.cn/upload/image_hosting/6yp77rux.png)

然后 $f_1$ 其实就是图中黑色部分一定填，白色一定不填，红色部分可选的种类数。进一步观察，这个红色部分其实就是 $g_3$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/kzpntetb.png)![](https://cdn.luogu.com.cn/upload/image_hosting/gwmx6pbc.png)

再进一步由图可以得到， $f_2=g_2,f_3=g_1$ 。

再往下， $f_4$ 和 $f_5$ 都没得选了，所以 $f_4=f_5=1$ 。

为了下面讲述方便，我们设 $f_4=g_0=1$ 。

那么我们已经得到了 $g_5=\sum^5_{i=1}f_i$ ，那么我们可以推广到其他数，可知 $g_k=\sum^k_{i=1}f_i$ 。

再进一步观察，当 $k=5$ 时， $f_0=g_4,f_1=g_3,f_2=g_2,f_3=g_1,f_4=g_0$ ，所以 $g_5=\sum^5_{i=1}f_i=\sum^4_{i=1}g_{4-i}+f_5=\sum^4_{i=1}g_i+1$ 。

推广到其他数，可知 $g_k=\sum^{k-1}_{i=1}g_i+1$ ，那么我们可以根据 $g_0=1$ 推出 $g_1=2,g_2=4,g_3=8$ 。

观察规律，可以发现 $g_i=2^i$ 。

如何证明呢？我们使用数学归纳法。

首先当 $i=0$ 时，$g_0=1=2^0$ ，结论成立。

再假设 $i=k$ 时，结论已成立，那么 $g_{k+1}=\sum^{k}_{i=1}g_i+1=\sum^{k-1}_{i=1}g_i+1+g_k$ ，而 $\sum^{k-1}_{i=1}g_i+1=g_k$ ，所以 $g_{k+1}=\sum^{k-1}_{i=1}g_i+1+g_k=2\times g_k=2\times 2^k=2^{k+1}$ ，所以 $i=k+1$ 时仍然成立。

所以我们就证明出了 $g_i=2^i$ 。

回到最开始。我们有 $n$ 个数，每个数有 $g_k=2^k$ 种选择，那么根据乘法原理，总计的选择数就是 $2^{nk}$ 。用快速幂算一下即可。代码就不贴了。

---

## 作者：风之影音 (赞：2)

这是本弱鸡的第7篇题解。

还是那句话，如有雷同，纯属巧合。

这道题，能看出来的话就是大水题，看不出来可能一直懵逼

首先每个元素互不影响，所以可以算出 S={1}的方案之后n次幂即可。

那么S={1}的方案数就是 选出一些A为0，其他的为1，而且任意一个1的右下方不能有0。

画一个图就可以发现，这样的0,1分布只能是从中间一条线分开。

分割点可以一开始在Ak,1的左下方，每次可以向右或者向上移动一个单位，并且总是能k步之后到达边界(也就是分割完成)

所以这部分的答案是 2^k。

所以最后答案直接就是 2^(n*k)。

上代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define kkk 1000000007
using namespace std;
int n,k,x,ans;
int main(){
    cin>>n>>k;
    k=n*(ll)k%(kkk-1);
    ans=1,x=2;
    for(;k;k>>=1,x=x*(ll)x%kkk) if(k&1) ans=ans*(ll)x%kkk;
    cout<<ans;
    return 0;
}
```



~~我觉得已经说的够清楚了吧~~，溜啦溜啦~~~

---

## 作者：Suuon_Kanderu (赞：2)

理解一下这道结论题。

有一篇题解说过，集合中的元素是没有关系的，所以我们只要想一下$n=1$的情况就 ok 了。假设$n=1$时的的结果为 S ，那么$n=P$时就是$S^P$~~这个感性理解一下~~。

$n=1$的情况：因为题中说，所有的集合都是其左方和右方的子集。就是上方有一些 1，下方有一些 0。如果直接计算的话不太好搞，我们通过这个分成两块的性质可以**枚举0和1的分界线**。

我们从左下角开始。这个点只有两种走法。向上或或向右。为啥？

- 假设一个子集为1，那么他左上方肯定全是1。
- 如果分界线往下走了一格，
![](https://cdn.luogu.com.cn/upload/image_hosting/zxz4yp01.png)
- 这样的话1的左边是0，而不是1，矛盾

因为向上和向右有两种可能，而走 k 步才能走到边界。所以答案就是$2^k$

总的答案就是$2^{k\cdot n}$。

结论：此题是快速幂模板题。

---

## 作者：bifanwen (赞：1)

[CSDN同步](https://blog.csdn.net/bifanwen/article/details/113063288)

[博客园同步](https://www.cnblogs.com/bifanwen/p/14319239.html)

[原题链接](https://www.luogu.com.cn/problem/P6075)

简要题意：略。

数据范围：$1 \leq n,k \leq 10^9$.

考虑一个事情。这玩意儿必定满足，上面方阵的集合里有的，下面没有。左边有的，右边没有；也可以都有。问题不大。

于是我们可以独立地看待各个元素的情况。

对于 $\forall \space [1,k] \space$ 的元素，很显然，每个元素，在方阵内，选择一个 “左上方的联通块” 进行覆盖，$2^n$ 种是不难得到的。

于是就是 ${2^n}^k = 2^{nk}$，你直接快速幂就行。

时间复杂度：$\mathcal{O}(\log n \times \log k)$

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;

inline ll read(){char ch=getchar();int f=1;while(ch<'0' || ch>'9') {if(ch=='-') f=-f; ch=getchar();}
	ll x=0;while(ch>='0' && ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();return x*f;}

ll n,k;
const ll MOD=1e9+7;

inline ll power(ll x,ll y) {
	ll ans=1;
	while(y) {
		if(y&1) ans=(ans*x)%MOD;
		x=(x*x)%MOD; y>>=1;
	} return ans;
}

int main(){
	n=read(),k=read();
	printf("%lld\n",power(2,n*k));
	return 0;
}

```

---


# [SHOI2002] N的连续数拆分

## 题目描述

所有的正整数均可以表示为一个、两个或者多个连续正整数的和。

给定一个不超过 $9\times 10^{14}$ 的正整数，求出它可以用几种不同的方法表示成连续正整数之和。例如给出 $9$，则有三种方式：$9,4+5,2+3+4$。

## 说明/提示

$n \leq 9\times 10^{14}$

## 样例 #1

### 输入

```
9```

### 输出

```
3```

## 样例 #2

### 输入

```
11```

### 输出

```
2```

## 样例 #3

### 输入

```
12```

### 输出

```
2```

# 题解

## 作者：SUNCHAOYI (赞：17)

[[SHOI2002]N的连续数拆分【数据加强版】](https://www.luogu.com.cn/problem/U175249)

----

**来一个和其它题解稍稍有些不一样的做法。**

首先还是列出等式，设最小的正整数为 $l$，最大的正整数为 $r$，则由求和公式可列出式子：

$$
\begin{cases}
0 < l \le r \le n\\
l,r \in \mathbb{N^*}\\
\dfrac{1}{2}(l + r) (r - l + 1) = n\\
\end{cases}
$$

化简一下第二个式子便是 $(l + r) (r - l + 1) = 2n$，因此必须要有 $l + r \mid 2n$ 且 $r - l + 1 \mid 2n$。再设 $a = l + r,b = r - l + 1$，直接解得
$$
\begin{cases}
r = \dfrac{a + b - 1}{2}\\
l = a - r
\end{cases}
$$

显然当 $2 \mid a + b - 1$ 时才有正整数解。因此我们枚举 $2n$ 的因数，然后判断是否符合条件，然后累加答案。由于因数两两配对，所以时间复杂度为 $O(\sqrt{2n})$。核心代码如下：

```cpp
int work (ll x)
{
	int cnt = 0;
	x <<= 1;
	for (ll i = 2;i * i <= x;++i)//记得为 long long
		if (x % i == 0)
			if ((i + x / i) & 1) ++cnt;
	return cnt;	
}
```

----

那么还有没有**更优的解法**呢？？

我们观察 $a,b$ 的奇偶性，因为 $2 \mid a + b - 1$ 才存在解，也就是 $a + b$ 一定为奇数。又因为只有在奇数与偶数相加时才得到奇数，所以 $a,b$ 必定为一奇一偶。所以可以将题目转化为求 $2n$ 的奇数因子，等同与求 $n$ 的奇数因子。

先将 $n$ 进行质因数分解 $n = \prod_{i = 1}^{k} p_i^{c_i}$，然后根据算数基本定理，除去唯一的偶质数 $2$ 后求奇数因数个数即可。因为质数中除了 $2$ 均为奇数，所以先预处理出 $\sqrt{n}$ 内的质数，然后再求因数时把所有 $2$ 除去即可。完整代码如下：

```cpp
//这个方法在多组数据中会更优
#include <iostream>
#include <cstdio>
#include <cmath>
#define ll long long
using namespace std;
const int MAX = 3e7 + 5;
int cnt,p[MAX >> 1];//p 记录质数，显然 sqrt (n) 的一半足够了
ll n;
bool flag[MAX];
void pre (int x);
int main ()
{
	//先分解质因子，然后计算奇因子的个数
	
	scanf ("%lld",&n);
	pre ((int)sqrt (n));//枚举到 sqrt(n)
	int ans = 1;
	for (int j = 1;j <= cnt && (ll)p[j] * p[j] <= n;++j)//边界枚举
	{
		int k = 0;
		while (n % p[j] == 0)
		{
			if (j != 1) ++k;//第一个质数为 2
			n /= p[j];
		}
		ans *= (k + 1);//算数基本定理
	}
	if (n > 2) ans *= 2;//注意剩余的那个质数也需要是奇数才行
	printf ("%d\n",ans);
	return 0;
}
void pre (int x)//线性筛质数
{
	for (int i = 2;i <= x;++i)
	{
		if (!flag[i]) p[++cnt] = i;
		for (int j = 1;j <= cnt;++j)
		{
			if (i * p[j] > x) break;
			flag[i * p[j]] = 1;
			if (i % p[j] == 0) break;
		}
	}
}
```

---

## 作者：Hexarhy (赞：14)

upd：修改了部分不良言论。

简单题，只需小学数学基础知识。

---------

### Solution

假设一个等差数列的首项为 $a(a\ge1)$，末项为 $b(b\ge a)$，那么就有：

$$\dfrac{(a+b)(b-a+1)}{2}=n$$

即，

$$(a+b)(b-a+1)=2n$$

观察式子，右边是偶数，左边的乘积也必然是偶数。

把左边两个因式相减，$(a+b)-(b-a+1)=2a-1$ 是奇数，则 $a+b$ 与 $b-a+1$ 一定是一奇一偶。

因此，我们只需要枚举 $a+b$，$O(1)$ 求出 $b-a+1$ ，并验证是否为整数且符合一奇一偶，再更新答案。

枚举当然只要枚举到 $\sqrt n$，毕竟左边是相乘的形式，即为 $2n$ 的因数。

时间复杂度 $O(\sqrt n)$。（忽略常数）

### Notice

1. 显然开`long long` 。
1. 为了优化常数，通常把 `i<=sqrt(n)` 写成 `i*i<=n`。当然本题不需要卡常。
1. 判断一奇一偶可以用按位异或 $\mathrm{xor}$ 来快速实现。

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

typedef long long ll;
ll n,ans; 

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n;
    for(ll x=1;x*x<=2*n;x++)// x=a+b
    {
    	if(2*n%x!=0)
    	 continue;
    	const ll y=2*n/x;// y=b-a+1=n/(a+b)
    	if(x%2 ^ y%2)
    	 ans++;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Warriors_Cat (赞：4)

## 题解 P6267 【[SHOI2002]N的连续数拆分】

### $Solution:$

~~这道题看着咋这么熟悉啊……感觉是原题诶……~~

不废话了，聊正解：

我们假设这个数列的第一项为 $x$，一共有 $k$ 项。

那么根据等差数列公式可得：

$$\frac{k(x+x+k-1)}{2}=n$$

$$k(2x+k-1)=2n$$

因此 $k$ 和 $2x-k+1$ 均为 $2n$ 的约数。

又因为 $2x+k-1-k=2x-1$ 为奇数，所以这两个数奇偶性不同。

那么，我们可以枚举 $2n$ 的因子，然后判断成对的是不是奇偶性不同就行了。

时间复杂度为 $O(\sqrt{2n})$，对付 $9\times 10^{14}$ 的上限是绰绰有余了。

下面放代码：

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long//宏定义偷懒
int n, ans;
signed main(){
	scanf("%lld", &n);
	for(int i = 1; i * i <= n * 2; ++i){
		if(n * 2 % i != 0) continue;//不是约数过掉
		int x = i, y = n * 2 / i;
		if((x & 1) ^ (y & 1)) ans++;//位运算写法
	}
	printf("%lld", ans);//完结撒花-v-
	return 0;
}
```
## End

---

## 作者：VinstaG173 (赞：2)

这是个小学数学题。

让我们感谢 Gauss 的恩赐。

众所周知，从 $l$ 到 $r$ 的连续正整数列求和公式为

$$n=\dfrac{(l+r)(r-l+1)}{2}$$

于是我们就知道 $(l+r)(r-l+1)=2n$。

接着我们只要对 $2n$ 分解质因数，当发现某个奇数和某个偶数的乘积为 $2n$ 时结果 $+1$。

由于 $l \ge 1$，显然 $l+r>r-l+1$，所以只要枚举较小因数。

于是就这样做完了。

Code:
```cpp
#include<cstdio>
#define ll long long
ll n;
int ans;
int main()
{
    scanf(" %lld",&n);n<<=1;
    for(register ll x=1;x*x<=n;++x)
    {
        if(n%x)continue;
        if((x&1)^(n/x&1))++ans;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Aehnuwx (赞：2)

一道比较简单的数学题。

题目问我们正整数 $n$ 可以被多少组连续的正整数拆分。那么这些连续的正整数会组成一个公差为 $1$ 的等差数列。

设数列的首项为 $a$，末项为 $b$，则该等差数列的和为 $\dfrac{(a+b)(b-a+1)}{2}$。

然后来推一波柿子：

$$\because \dfrac{(a+b)(b-a+1)}{2}=n$$
$$\therefore (a+b)(b-a+1)=2n$$
$$\therefore (a+b)(b-a+1)\bmod 2=0$$
$$\because \text{两数和、差的奇偶性相同}$$
$$\therefore (a+b)\text{ 和 }(b-a)\text{ 的奇偶性相同}$$
$$\therefore (a+b)\text{ 和 }(b-a+1)\text{ 的奇偶性不同}$$

由此，我们只需要枚举 $(a+b)$，判断其是否为 $2n$ 的因子。若是，则求出 $(b-a+1)$。如果 $(a+b)$ 和 $(b-a+1)$ 的奇偶性不同，则方案数增加。

时间复杂度为 $O(\sqrt{n})$，常数为 $\sqrt{2}$。

$11$ 行代码（未压行）：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
int main() {
	scanf("%lld",&n);
	n<<=1; // 之后不需要使用 n 了，只需要用 2n，故直接将 n 乘上 2
	int ans=0,m=sqrt(n);
	for (register int i=1,j;i<=m;i++) ans+=!(n%i)&&(i&1)^(n/i&1); // 位运算。等价于 if (n%i==0&&i%2!=n/i%2) ans++;
	printf("%d",ans);
	return 0;
}
```


---

## 作者：bovine__kebi (赞：2)

又一道很好的拆式子题目：  
连续数的拆分，如果暴力枚举的话，复杂度为$O(n^{2})$绝对TLE,我就不给代码了。  
于是我们考虑拆式子，我们发现连续的整数，可以直接等差数列公式（~~高斯真是个好人~~），于是原式就变成了这个亚子：  
$$\dfrac{(L+R)(R-L+1)}{2}=n$$  
可是如果暴力枚举$L$和$R$的话  还是会TLE，复杂度并没有减，于是我们继续化简：   
$$(L+R)(R-L-1)=2n$$    
$$\text{令}L+R=m\quad R-L+1=s$$   
$$\text{则}m*s=2n$$  
如果要满足这个式子成立的话，也就必须满足L和R是整数，也就是说：   
$$(s-m+1)\mod2=0$$  
$$(m+s-1)\mod 2=0$$   
然后我们就可以开心的枚举啦：  
我们可以随便枚举$m$和$s$中的任意一个数，然后直接按上面的判断直接判断加上就可以了，这样的复杂度是$O(n)$,卡一卡也是可以过得，但是有没有更好的方法呢？  

其实m可以不用枚举到n,我们来考虑m的上界，因为它和$s$要是$2n$的因数，所以这两个数最大不会超过$\sqrt {2n}$,如果超过了，就相当于是把$m$和$s$调换了一个位置（这里自己思考一下）,于是复杂度就可以简化成
$O(\sqrt{2n})$  
代码来啦
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//三年OI一场空，不开longlong见祖宗
ll sum;
int main()
{
    ll n;
    scanf("%lld",&n);
    for(register ll i=1;i<=sqrt(2*n);i++)//这里的i就相当于m
    {
        if((2*n)%i!=0)continue;//首先要保证s为整数
        else
        {
            ll j=(2*n)/i;//这个j相当于s
            if((j+i-1)%2==0&&(i-j+1)%2==0)sum++;//判断+累加和
        }
    }
    printf("%lld\n",sum);
    return 0;//华丽结束
}
```
**update:**
2020.05.09 修改了一个小$bug$

---

## 作者：Leasier (赞：1)

由等差数列求和公式 $\displaystyle\sum_{i = a}^b i = \dfrac{1}{2} (a + b)(b - a + 1)$ 可得：本题就是求出满足 $n = \dfrac{1}{2} (a + b)(b - a + 1)$ 的 $(a, b)$ 的对数。

我们先把上面那个式子变一下形：$2n = (a + b)(b - a + 1)$。

因为 $a + b$ 和 $b - a$ 的奇偶性相同，所以 $a + b$ 和 $b - a + 1$ 的奇偶性相反。

所以本题只需要从 $1$ 到 $\lfloor \sqrt{2n} \rfloor$ 枚举 $2n$ 的因数并判断即可，也就是说要求：$\displaystyle\sum_{i = 1}^{\lfloor \sqrt{2n} \rfloor}[2n \bmod i = 0][i \not \equiv \dfrac{2n}{i} \pmod 2]$。

代码：
```cpp
#include <stdio.h>
#include <math.h>

typedef long long ll;

int main(){
	ll n, m, t;
	int ans = 0;
	scanf("%lld", &n);
	m = n * 2;
	t = sqrt(m);
	for (ll i = 1; i <= t; i++){
		if (m % i == 0 && i % 2 != (m / i) % 2) ans++;
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：CSP_Sept (赞：1)

可以看出就是要把 $n$ 拆分成一个公差为 $1$ 的等差数列。

$$
\begin{matrix}
\begin{matrix}\underbrace{x+(x+1)+(x+2)+\cdots+(x+l-1)}\\l\text{ numbers}\end{matrix}
\\
=(2x+l-1)\times l\div 2
\\
=\dfrac{2xl+l^2-l}{2}
\end{matrix}
$$

于是我们顺手写个等式：
$$
\begin{matrix}
\dfrac{2xl+n^2-l}{2}=n
\\
2xl+l^2-l=2n
\\
(2x-1+l)l=2n
\end{matrix}
$$

于是我们可以写： 

$$
\begin{matrix}
\because 2n\mod 2=0,\therefore (2x-1+l)l\mod 2=0
\\
\because 2x\mod 2=0,\therefore 2x-1\mod 2=1
\\
\text{令 }l\mod 2=1,(2x-1+l)\mod 2=0
\\
\text{令 }l\mod 2=0,(2x-1+l)\mod 2=1
\end{matrix}
$$

由以上式子可得，$l$ 与 $2x-1+l$ 必然**奇偶性不同**。

枚举 $2n$ 的因子 $i$，直接判断 $i$ 与 $\dfrac{2n}{i}$ 是否奇偶性不同即可。

枚举 $2n$ 因子的复杂度是 $\Theta(\sqrt{2n})$，对于本题绰绰有余。

代码：
```cpp
#include <cstdio>

using namespace std;
typedef long long LL;//把 long long 替换成 LL
LL n,ans=0;
bool check(LL i){//判断 i 与 2n/i 的奇偶性是否一样
    if(i%2) return !((2*n/i)%2);
    return (2*n/i)%2;
} 
int main(){
    scanf("%lld",&n);
    for(LL i=1;i*i<=2*n;i++){
        if((2*n)%i==0){
            if(check(i)) ans++;//找到一个答案
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：feecle6418 (赞：0)

显然项数不超过 $\sqrt{2n}$，考虑枚举项数。

根据等差数列求和公式，假如 $\sum\limits_{i=l}^r i=n$，则

$$2n=(r-l+1)(l+r)$$

因此，假如现在枚举到 $r-l+1=i$，则 $l+r=\dfrac{2n}{i}$。显然 $l+r$ 与 $r-l+1$ 不同奇偶，因此判断一下整除和奇偶性即可。

代码是几年前写的，很丑。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<cstring>
#include<ctime>
using namespace std;
int main(){
	long long n,s=0;
	cin>>n;
	for(long long i=1;i*i<=2*n;i++){
		if(2*n%i)continue;
		int t=2*n/i;
		//cout<<i<<' '<<t<<endl;
		if(i%2!=t%2)s++;
	}
	cout<<s;
}
```

---


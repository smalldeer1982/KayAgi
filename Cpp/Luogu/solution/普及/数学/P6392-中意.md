# 中意

## 题目背景

（背景改编自百度贴吧/南北组备用吧/呆萌南北日常/F8984，作者 [落墨成白](https://tieba.baidu.com/home/main/?un=%E8%93%93%E8%90%BD%E9%B1%BC&ie=utf-8&id=tb.1.a8bcbb73.CMcL9PXngjHz-dKRJ7_T4A&fr=frs)）

&emsp;&emsp;在这样的时间，这样的情形下她与她面面相望却不动一步，只有一个可能——她在等。  
&emsp;&emsp;等她求助，等她妥协，等她心甘情愿。  
&emsp;&emsp;洛天依想这厮做事儿还真是欠扁，看着手机屏幕上跳出的字：“还不过来？”  
&emsp;&emsp;她毫不客气的回道：“你想让我过到哪儿去呀？”  
&emsp;&emsp;“如果除了到了身边来，还有别的路可以走的话。”  
&emsp;&emsp;当然妥协的乐正大小姐虽然嘴里叨念着，提着路上买的双皮奶和蛋挞，仍是乖乖先迈动了步子。  
&emsp;&emsp;刚一开门，小吃货果然乖乖扑进怀里了。  
&emsp;&emsp;“不能全吃哦，来做个游戏吧！”  
&emsp;&emsp;“坏蛋阿绫。”

## 题目描述

**和题意有关的句子已加粗。**

&emsp;&emsp;“首先，有一个神奇的数字 $a$。”  
&emsp;&emsp;“天依很饿呢，**所以就给天依 $2^{a+2}$ 个蛋挞吧。**”  
&emsp;&emsp;“我还要！”  
&emsp;&emsp;“那……还有一个神奇的数字 $b$，**天依可以获得 $b$ 倍的蛋挞哦！**”  
&emsp;&emsp;**“哇！那我就有 $k=b \times 2^{a+2}$ 个蛋挞啦！**”  
&emsp;&emsp;“天依还喜欢整百数呢，**所以凑个整，给 $p=\lceil \frac{k}{25}\rceil \times 100$ 个蛋挞吧！**”  
&emsp;&emsp;“阿绫太好啦！”  
&emsp;&emsp;“呐\~给你。”阿绫笑着抚过天依的脑袋，从袋子里拿出寥寥几个蛋挞。  
&emsp;&emsp;“欸？！”  
&emsp;&emsp;“最后，天依不能吃太多哦，**所以 $p$ 要对 $\color{black} 998 \color{red}3 \color{black} 44353$ 取模。**”  
&emsp;&emsp;“…果然是坏蛋。”  

现在天依想知道，对于阿绫给出的 $a$ 和 $b$，自己究竟能吃到几个蛋挞，即 $p \bmod \color{black} 998 \color{red}3 \color{black} 44353$ 的结果是多少？

注：$\lceil x \rceil$ 指 $x$ 向上取整。

## 说明/提示

#### 样例解释 #2

$k=60 \times 2^{(15+2)}=7864320$，$p=\lceil \frac{k}{25} \rceil \times 100 =31457300$。

------------
#### 数据范围
**本题采用捆绑测试。**

- Subtask 1（20 Points），$a,b \leq 100$ 且 $b \equiv 0 \pmod{25}$。   
- Subtask 2（50 Points），$b \leq 10^9$。   
- Subtask 3（30 Points），数据无特殊限制。

对于 $100 \%$ 的数据，$20 \leq b \leq 10^{10010}$，$1 \leq a \leq 10^{18}+8$。

------------

#### 题目背景 ( 续 )

&emsp;&emsp;还是万分纠结地看着天依手中甜腻的早餐，“一大早吃这么甜，摄入糖分过多会促使动脉硬化，会……”  
&emsp;&emsp;洛天依打断她：“那你想不想更甜一点？”  
&emsp;&emsp;“嗯？”  
&emsp;&emsp;洛天依踮起脚轻轻地在她的右脸颊印下一个吻，“乐正绫，我好中意你呀。”  
&emsp;&emsp;乐正绫愣了愣，问：“你说什么？”  
&emsp;&emsp;洛天依脸红了红，转过身小口咀嚼着蛋挞：“听不懂算了。”  
&emsp;&emsp;“我也好中意你呀。”像羽毛一样轻柔的声音，撩过两人的心尖。  
&emsp;&emsp;口中的蛋挞果真又甜腻上几分了呢。

## 样例 #1

### 输入

```
30 1
```

### 输出

```
1000```

## 样例 #2

### 输入

```
60 15
```

### 输出

```
31457300```

## 样例 #3

### 输入

```
2020 412```

### 输出

```
133047246```

# 题解

## 作者：一只书虫仔 (赞：23)

> 中意只是两条线的交点     
> 交点只分由远有近   
> 但，永远没有平行

### Description

> [Problem Link](https://www.luogu.com.cn/problem/P6392)   
> 给定 $b,a$，求
> $$\left\lceil\dfrac{b\times 2^{a+2}}{25}\right\rceil\times100$$
> 对 $998344353$ 取模的结果。

~~传说中的杀狗题吗~~

### Solution For Sub 1

Sub 1 直接暴力即可 …… 没有思维含量。   
代码就不打了吧，因为太简单了（

### Solution For Sub 2 and Sub 3

我们很轻易的就可以发现 $25$ 是整除 $100$ 的。   
所以我们要想一个办法把下取整直接摘掉。   
方法就是让分子加一个最小的数使得 $b \times 2^{a+2}$ 加上这个数能被 $25$ 整除。   
这个数肯定还是原式就因为有一个上取整。   
我们只要枚举一个数 $\omega$ 能使得他加上 $b \times 2^{a+2}$ 能整除 $25$ 即可。   
因为 $25$ 不大，我们可以直接在 $[0,24]$ 的区间枚举 $\omega$。   
最后的结果就是
$$4\times(b\times 2^{a+2}+\omega)$$
最后对 $998344353$ 取模。   
$2^{a+2}$ 用快速幂即可啦~

Sub 3 有一些极限数据，已经达到了 $1\text e10010$，所以要用快读的思路，字符转数字就可以了。

By Shuchong   
2020.6.27

---

## 作者：JamesQin (赞：5)

设 $f_k$ 为使 $f_k+k \mod 25 = 0$ 的最小自然数。

设$b \times 2^{(a+2)}=ans$ 。

答案为$\left\lceil\dfrac{ans}{25}\right\rceil \times 100$ ,
即为$4 \times ans + f_{ans}$ 。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998344353;
int rd(string s){
	int ans=0;
	for(int i=0;i<s.length();i++){
		ans=((ans*10)+s[i]-48)%mod;
	}
	return (ans+mod)%mod;
}
int ksm(int a,int b,int m){
	int res=1;
	while(b){
		if(b&1) res=res*a%m;
		a=a*a%m;
		b>>=1;
	}
	return res;
} 
signed main(){
	string b1;
	int a;
	cin>>b1>>a;
	int len=b1.length();
	int ans1=(ksm(2,a+2,25));
	int ans2;
	if(len>=2) ans2=(b1[len-2]*10+b1[len-1]-528);
	else ans2=b1[0]-48;
	int ans=ans1*ans2%25; 
	ans=(ans+25)%25;
	int t=25-ans;
	if(t==25) t=0;
	int b=rd(b1);
	int fans=4*((ksm(2,a+2,mod))*b%mod+t)%mod;
	cout<<fans<<endl;
	return 0;
} 
```


---

## 作者：KaguyaH (赞：4)

天依能吃到 $p$ 个蛋挞呢。

我们把阿绫的模数 $998344353$ 叫做 $m$ 吧。

$$
\begin{aligned}
p =& \left\lceil \frac k {25} \right\rceil \cdot 100 \bmod m\\
=& \left\lceil \frac k {25} \right\rceil \cdot 25 \cdot 4 \bmod m\\
=& (k + (25 - k \bmod 25) \bmod 25)) \cdot 4 \bmod m\\
=& (k \bmod m + (25 - k \bmod 25) \bmod 25)) \cdot 4 \bmod m,\\
\end{aligned}
$$

$$
k = 2^{a + 2} \cdot b.
$$

$k \bmod m$ 和 $k \bmod 25$ 的值都可以用快速幂做呢。$b$ 的值在读入的时候对 $25m$ 取模就好啦~

```cpp
# define _CRT_SECURE_NO_WARNINGS
# include <cctype>
# include <cstdio>

namespace Main {
	namespace Sourse {
		typedef long unsigned int lu;
		typedef long long unsigned int llu;
		static inline llu read(const llu mod) {
			char t; while (isspace(t = getchar()));
			llu r(0); while (r = (r * 10 + (t - '0')) % mod, isdigit(t = getchar()));
			return r;
		}
		namespace Maths {
			static inline const lu qpow(llu b, llu e, const lu mod) {
				b %= mod; llu r(1 % mod);
				while (e) {
					if (e bitand 1) r = 1ull * r * b % mod;
					b = 1ull * b * b % mod, e >>= 1;
				}
				return r;
			}
		}
	}
	using namespace Sourse;
	static const lu Mod(998344353);
	static llu a;
	static const llu b(read(Mod * 25ull));
	static lu k, _k;
	static inline const void main() {
		scanf("%llu", &a);
		k = b % Mod * Maths::qpow(2, a + 2, Mod) % Mod, _k = b % 25 * Maths::qpow(2, a + 2, 25) % 25;
		printf("%lu\n", (k + (25 - _k) % 25) * 4 % Mod);
	}
}

signed int main() { Main::main(); return 0; }
```

事翻任务计划翻到了一道 GLR Round 1，对这场比赛的主题印象很深，然后从比赛界面找到的题。

南北组好甜qwq

> 也只有女孩子能这么甜了罢（）

---

## 作者：pomelo_nene (赞：4)

此题坑点很多，综合考验了选手的观察能力和联想能力，以及注意细节的能力。

先统计下坑点，下面就不提了：

- 模数是 $998344353$ 而不是 $998244353$（idea 来源：[万恶的萌娘百科](https://zh.moegirl.org/%E6%95%B0%E5%AD%97%E6%A2%97#%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B)）；   
- 除以 $25$ 并向上取整不是在 $k$ 向 $998344353$ 取模之后进行的；   
- 输入顺序。

处理了这些问题应该就是一道很裸的题了。

## 题目简述

求 $\lceil \dfrac{b \times 2^{(a+2)}}{25} \rceil \times 100$。

## Subtask 1

为不会快速幂的同学赠送，直接对着题意模拟即可。因为 $b \bmod 25=0$，所以原式化为：$4 \times b \times 2^{(a+2)}$，因为 $a$ 很小，快速幂不用，直接暴力计算取模就行了。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
	long long a,b;
	scanf("%lld %lld",&b,&a);
	long long ans=1;
	for(long long i=1;i<=a+2;++i)	ans*=2,ans%=998344353;
	ans*=b;
	ans%=998344353;
	ans*=4;
	ans%=998344353;
	printf("%lld",ans);
	return 0;
}
```

## Subtask 2

将 $2^{(a+2)}$ 的计算改成快速幂计算就行了。

但是还不够。因为我们在计算 $k$ 的过程中会向 $998344353$ 取模，而在修正的过程中会有 $\frac{k}{25}$，而 $998344353$ 并不是 $25$ 的倍数，所以说我们要想办法处理。将 $\lceil \frac{k}{25} \rceil$ 写成 $\frac{k+x}{25}$，使得 $x$ 最小且 $x+k \bmod 25=0$。考虑到 $25$ 的特殊性。分析一下，判断一个数是否能够整除 $25$，只需要看后面两位是否是 $25$ 的倍数就行了。所以我们只需要计算 $k$ 的后两位就行了。

具体操作方法就是取 $b$ 后面的两位 $q$，$k$ 的后两位就是 $q \times 2^{(a+2)} \bmod 100$，计算即可。这里的模数是 $25$ 也可以，只要是 $25$ 的倍数就行了，想怎么取怎么取。

考虑计算 $x$，因为 $25$ 比较小，自加判断就行了。

现在是计算 $\frac{k+x}{25} \times 100=4(k+x)$，输出即可。

## Subtask 3

$b$ 变大了。用字符串读，然后字符串转数字即可。


```cpp
#include<bits/stdc++.h>
#define LL long long
#define MOD 998344353ll
using namespace std;
char b[10015];
int len;
long long QuickPow(long long n,long long p,long long mod)
{
	long long base=n,ans=1;
	while(p)
	{
		if(p&1)	ans=ans*base%mod;
		p>>=1;
		base=base*base%mod;
	}
	return ans%mod;
}
LL change()
{
	LL ans=0;
	for(int i=1;i<=len;++i)	ans*=10,ans+=(b[i]^'0'),ans%=MOD;
	return ans;
}
int main(){
	LL a;
	scanf("%s %lld",b+1,&a);
	len=strlen(b+1);
	LL realb=change();
	LL up=a+2;
	LL ws=QuickPow(2,up,100),k=QuickPow(2,up,MOD)*realb%MOD;
	LL las=10*(-'0'+b[len-1])+(-'0'+b[len]);
	ws*=las;
	ws%=100;
	while(ws%25)	++ws,++k;
	k*=4;
	k%=MOD;
	printf("%lld",k);
	return 0;
}
```

## 彩蛋

其实 $a$ 对应了立直麻将中的番数，$b$ 对应了立直麻将中的符数。公式就是根据番数和符数计算点和点数的公式，但是这里采取的青天井规则就没有退化成为满贯之类。所以这个式子才会变得非常鬼畜。。。

---

关于鬼畜的输入问题，是因为出题人在造数据的时候脑子抽了将两个数弄反了。

然后尴尬加上提示（（（聊天记录掉了。。。

---

## 作者：TempestJueMu (赞：2)

## 题目描述

给定 $b$、$a$，求
$$
\bigg \lceil \frac{b \times 2 ^ {a+2}}{25} \bigg \rceil \times 100\mod 998344353
$$
**注意：模数是 $998344353$ ！**~~(好坑~~

## 思路

想办法把向上取整拿掉，然后快速幂解决。

则只需让分子能整除 $25$ 即可。

即让分子加上一个正整数 $x$，使 $25 \mid (b \times 2^{a+2}+x)$ 且 $x$ 最小。

此时答案为 $4\times (b \times 2^{a+2}+x)$

由于除数是 $25$ ，则只用考虑末$2$位能被整除即可，而且 $x$ 还可以暴力找。

注意到 $2^n$ 末两位有规律。

经过一番~~暴力~~计算后可以发现，末两位为：

```cpp
Pow_2[]={1,2,4,8,16,32,64,28,56,12,24,48,96,92,84,68,36,72,44,88,76,52};
```
$20$ 个一循环。

即
$$
2^n \equiv
\begin{cases}
2^n,n\leq 21\\
2^{n\ mod\ 20},n>21
\end{cases}
$$
然后可以暴力寻找 $x$ ，最后快速幂即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int mod=998344353;
ll ksm(ll a,ll b,ll p)//快速幂
{
	ll ans=1;
	while(b)
	{
		if(b&1)ans=ans*a%p;
		a=a*a%p;b>>=1;
	}
	return ans;
}
int Pow_2[]={1,2,4,8,16,32,64,28,56,12,24,48,96,92,84,68,36,72,44,88,76,52};
int tt=20;
ll b,a,b2,a2,ans,x;
string b1;//由于b较大，用字符串读入
ll change(string s)//字符串换整数
{
	ll ret=0;
	for(int i=0;s[i]!='\0';i++)
	ret=(ret*10+s[i]-'0')%mod;
	return ret;
}
int main()
{
	cin>>b1,scanf("%lld",&a);
	b=change(b1);
	int len=b1.length();
	b2=10*(b1[len-2]-'0')+(b1[len-1]-'0');//b的末两位
	a+=2;//先加再说
	ll Pow;
	Pow=a<=21?a:a%20;//2的次方末两位的规律，20个数一循环
	a2=Pow_2[Pow];//2^(a+2)的末两位
//	a2=ksm(2,a,100);//也可以这样写，同为2^(a+2)的末两位
	for(x=0;x<=24;x++)
	if((b2*a2+x)%25==0)break;//暴力找x
	ans=((ksm(2,a,mod)*b%mod+x)%mod*4)%mod;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：fjy666 (赞：1)

## 0x01 思路
先吐槽题目背景，球球出题人了形式化题面行吗？！   
抛开这点，题目质量很好！  
本题看似 Python 题，实则数论题。  
主要是向上取整麻烦。  
那么我们想法子去掉向上取整把。  
首先能求出 $k \bmod 25$。  
然后找到一个 $t$，使 $k + t \bmod 25 = 0$ 且 $t$ 最小。  
怎么找？  
$25 - k(k \neq 0)$ 或 $k(k = 0)$。  
找到这个之后再求，普通快速幂就 OK 了。

## 0x02 代码
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <ctime>
#define _rep(i_,a_,b_) for(int i_ = a_;i_ <= b_;++i_)
#define _for(i_,a_,b_) for(int i_ = a_;i_ < b_;++i_)
typedef long long ll;
using namespace std;
#define int long long
const int kN = 15000,P = 998344353;
char b_[kN];
int a,b;
int fpm(int a,int b,int P) {
	int ans = 1 % P;
	for(;b;b>>=1) {
		if(b&1)ans = (ll)ans * a % P;
		a = (ll)a * a % P;
	}
	return ans;
}
signed main(){
#ifdef LOCAL
    clock_t c1 = clock();
#endif
	scanf("%s%lld",b_,&a);
	for(int i = 0,len = strlen(b_);i < len; ++i)
		b = (b * 10ll + b_[i] - '0') % 25;
	int tmp = 1ll * b % 25 * fpm(2,a+2,25) % 25;
	if(tmp != 0)tmp = 25 - tmp;
	b = 0;
	for(int i = 0,len = strlen(b_);i < len; ++i)
		b = (b * 10 + b_[i] - '0') % P;
	int ttmp = 1ll * b % P * fpm(2,a+2,P) % P;
	printf("%lld",4ll * (ttmp + tmp) % P);
#ifdef LOCAL
    printf("\nTime used = %ldms\n",clock()-c1);
#endif
    return 0;
}
```

---

## 作者：Aw顿顿 (赞：1)

## 题意简析

将每个变量一一代入：

$$\left(\left\lceil\dfrac{b\times 2^{a+2}}{25}\right\rceil\times 100\right)\bmod 998\color{red}3\color{black}44353$$

## 思路

考虑到 $100=25\times 4$，我们可以想一想怎么避开上取整。

答案是，我们可以在 $1\sim 24$ 的范围内枚举一个 $x_0$，使得 $x_0$ 加上分子可以整除 $25$，这样我们就可以去除上取整，然后整个式子 $\times 4$。

关于正确性问题，可以肯定的说，因为存在上取整符号，所以加上一个范围内的数不影响结果。

那么快速幂求 $2^{a+2}$ 然后算即可，复杂度不高。

考虑对于极大的数据，字符读入再计算。

---

## 作者：SegTree (赞：0)

$\text{update 2022.8.12}$ 修正笔误。

## 题目分析

**题意简述：**

给定 $a$，$b$，$k=2^{a+2}\times b$，求出 $\lceil\dfrac{k}{25}\rceil\times 100\bmod 998344353$ 的值。

分析：

首先令 $p=998344353$，那么：

$$
\begin{aligned}
\texttt{原式} &=\lceil\dfrac{k}{25}\rceil \times 100\bmod p\\
&=(\dfrac{k}{25}+(\lceil \dfrac{k}{25}\rceil-\dfrac{k}{25}))\times 100\bmod p\\
&=(4k+\dfrac{(25-k)\bmod 25}{25}\times 100)\bmod p\\
&= (4k+((25-k)\bmod 25)\times 4)\bmod p
\end{aligned}
$$

## 代码实现

由于 $b\le 10^{10010}$ 的数据范围限制，所以要计算两个值，分别是 $b\bmod p$ 和 $b\bmod 25$。在计算 $b\bmod 25$ 时可以利用 $25$ 的整除特征看 $b$ 的末两位，在计算 $2^{a+2}$ 时需要用快速幂实现。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int p=998344353;
string s="";
inline int read()
{
	int x=0;
	bool flag=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			flag=0;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+c-'0';
		x%=p;
		s+=c;
		c=getchar();
	}
	return (flag?x:~(x-1));
}
signed main(){
    int b=read(),a,ans1=1,ans2=1,a1=2,a2=2,ans;
    cin>>a;
    a+=2;
    while(a){
        if(a&1)ans1=ans1*a1%p,ans2=ans2*a2%25;
        a1=a1*a1%p,a2=a2*a2%25;
        a>>=1;
    }
    ans1=ans1*b%p;
    ans1=ans1*4%p;
    int to_num_s;
    if(s.length()>=2){
        to_num_s=s[s.length()-1]-'0'+(s[s.length()-2]-'0')*10;
        to_num_s%=25;
    }
    else {
        to_num_s=(s[0]-'0')%25;
    }
    ans2=ans2*to_num_s%25;
    ans2=25-ans2;
    if(ans2==25)ans2=0;
    ans2=ans2*4;
    ans=(ans1+ans2)%p;
    cout<<ans;
    return 0;
}
```


---


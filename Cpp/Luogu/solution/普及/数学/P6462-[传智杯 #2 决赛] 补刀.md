# [传智杯 #2 决赛] 补刀

## 题目描述

UIM 在写程序的空闲玩一款 MOBA 游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/j6t4jmrd.png)

当敌方的小兵进入到我方防御塔的范围内，就会持续受到防御塔造成的伤害；当然我方英雄也可以对它造成伤害。当小兵的血量降到了 0 或者更低，就会被击杀。为了获得经验，UIM 希望在防御塔将这个小兵杀死之前，亲自补刀将其击杀。

为了简化问题，我们假设这个小兵有 $h$ 点的生命值。每次防御塔的攻击可以给小兵造成 $x$ 点伤害，而你的英雄每次攻击可以给小兵造成 $y$ 点伤害。你的攻击速度和防御塔攻击速度相同，所以你可以在防御塔第一次攻击小兵之前，或者每次防御塔攻击之后，选择是否对小兵进行一次攻击，当然你也可以选择不攻击。

现在想知道，给出这些信息，判断英雄是否有办法将这个小兵击杀？

## 说明/提示

数据的组数不多于 50，$1\le h \le 10^{18}$，$0\le x,y \le 10^{18}$。

## 样例 #1

### 输入

```
5
100 100 1
100 97 1
100 98 1
100 99 1
100 100 0```

### 输出

```
No
No
Yes
Yes
No```

# 题解

## 作者：d446101 (赞：9)

## 思路

作为一名真·moba玩家，我觉得别的题解都太绕了，只要想好怎么去“构造”就可以了！

设防御塔最多攻击 $tower$ 次小兵还没有死

（即最大的 $tower$ 使 $tower*x<h$）

则英雄最多攻击 $tower+1$ 次，输出伤害 $(tower+1)*y$

两者总输出大于等于小兵生命 $h$ 则英雄能补刀成功

“为了皮尔特沃夫！”

## 代码

语言：Ruby

```ruby
n = gets.to_i
for i in 1..n
    h, x, y = gets.split.map(&:to_i) 
    if y == 0
        puts "No"
        next
    elsif x == 0
        puts "Yes"
        next
    end
    tower = h / x
    if h % x == 0 then tower -= 1 end
    if (tower + 1) * y + tower * x >= h
        puts "Yes"
    else
        puts "No"        
    end
end
```


---

## 作者：cyrxdzj (赞：4)

### 一、思路

首先，特判一下：

- 如果英雄的攻击力为零，那就不用说了，肯定无法击杀小兵。

- 如果防御塔的攻击力为零且英雄的攻击力不为零，那么英雄肯定可以击杀小兵，只是时间问题。

如果特判均不成立：

首先，我们可以计算防御塔不击杀小兵的最大攻击次数，是 $\left \lceil \frac{h}{x}  \right \rceil$。

然后，依题意可以知道英雄的最大攻击次数其实是防御塔最大攻击次数加 $1$。

因此，我们可以先算出防御塔完成它的攻击后，小兵还剩多少血。再算出英雄攻击残血小兵所需的攻击次数，如果不大于英雄最大攻击次数，输出 `Yes`，否则输出 `No`。

### 二、完整代码

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
long long h,x,y;//记得开long long！
int t;
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
		scanf("%lld%lld%lld",&h,&x,&y);
		if(y==0)//特判。
		{
			printf("No\n");
			continue;
		}
		else if(x==0)
		{
			printf("Yes\n");
			continue;
		}
		long long tower_attack_times=ceil(double(h)/x)-1;//防御塔最大攻击次数。
		h-=tower_attack_times*x;//小兵扣血。
		long long hero_attack_times=ceil(double(h)/y);//英雄最大攻击次数。
		if(hero_attack_times<=tower_attack_times+1)//判断。
		{
			printf("Yes\n");
		}
		else
		{
			printf("No\n");
		}
	}
	return 0;//完结撒花！
}

```

By [dengzijun](https://www.luogu.com.cn/user/387836)

---

## 作者：天南星魔芋 (赞：4)

~~今天无事，来发 $tj$  。~~


------------
我们看题：

* 给定小兵生命，防御塔攻击 ， 英雄攻击，求英雄是否有办法将这个小兵击杀。

于是我们得到以下结论：

* 若英雄攻击为 $0$ $NO$。

* 若英雄攻击不为 $0$ ，但防御塔攻击为 $0$ $YES$。

 若英雄攻击与防御塔攻击都不为零：

* 若防御塔刚好将小兵击败 （即 $h$%$x=0$ ），英雄能在防御塔击败小兵前打 $h/x$ 次。

* 若防御塔不能刚好将小兵击败 （即 $h$%$x!=0$ ），英雄能在防御塔击败小兵前打 $h/x+1$ 次。

* 若英雄能在防御塔之前 对小兵造成 $h$%$x$ 点伤害，则 $YES$ , 否则 $NO$

直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
long long a,b,c,d;
int main(){
	scanf("%d",&t);
	for(int i=1;i<=t;i++){
		scanf("%lld%lld%lld",&a,&b,&c);
		if(c==0){//英雄攻击为0
			printf("No\n");
		}
		else if(b==0){//防御塔攻击为0
			printf("Yes\n");
		}
		else if(c>=b){//英雄攻击比防御塔大
			printf("Yes\n");
		}
		else{
			if(a%b==0){
				d=a/b;
				if(d*c>=b)printf("Yes\n");
				else printf("No\n");
			}
			else{
				d=a/b;
				if((d+1)*c>=a%b)printf("Yes\n");
				else printf("No\n");
			}
		}
	}
}
```


---

## 作者：chenpengda (赞：4)

$0$分代码思路：dfs，每一次完成攻击后选择打或不打，进行下一层dfs。

结果：$MLE$

$95$分代码思路：

实际上dfs的思路也等同于每一次防御塔攻击后是否攻击小兵。

那么根据贪心，当你在第$i-1$次间隔中攻击小兵时，与你在第$i$次间隔攻击时几乎没有区别（实际上唯一的区别是防御塔的攻击靠后，反而会造成抢不到人头的情况）

于是我们可以得到，在后面选择不攻击永远不如在前面选择不攻击，所以总是在前面先让塔打兵。

那么，我们循环一个“停攻次数”，从$0$至$h/x+1$。

代码会像这样，后面循环扣血，前面让塔打完
```cpp
for(int i=0;i<=h/y+1;i++)//不打y次
		{
			h-=x*i;
			if(h<=0)
			{
				cout<<"No\n";return;//这个时候是塔最后一杀
			}
			while(h>0)
			{
				h-=y;
				if(h<=0)
				{
					cout<<"Yes\n";//这个时候是英雄最后一杀
					return;
				}
				h-=x;
				if(h<=0)
				{
					cout<<"No\n";//这个时候是塔最后一杀
					return;
				}
			}
		}
```

但是这样只有$95$，#$19$就是不过/kk

$100$分思路

特判特殊情况即可。

分如下四种：

```cpp
		if(y==0)
		{
			cout<<"No\n";return;//自己没法伤害，肯定不行啊
		}
		if(x==0)
		{
			cout<<"Yes\n";return;//塔没有伤害，肯定可以啊（自己一定是有伤害的，没有伤害已经特判掉了）
		}
		if(h<=x&&h>y)
		{
			cout<<"No\n";return;//自己的伤害打不过但是塔可以一刀，不行
		}
		if(h<=y)
		{
			cout<<"Yes\n";return;//自己一刀，可以
		}
```

即可。

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long h,x,y;//变量的意思就是题目中的h,x,y
void is_it_okay(long long nowblood)//函数判定舒服一些
{
		if(y==0)
		{
			cout<<"No\n";return;
		}
		if(x==0)
		{
			cout<<"Yes\n";return;
		}
		if(h<=x&&h>y)
		{
			cout<<"No\n";return;
		}
		if(h<=y)
		{
			cout<<"Yes\n";return;
		}
        //特判结束，已经在前面说明了
		long long bfh=nowblood;
		for(int i=0;i<=bfh/y+1;i++)//不打y次
		{
			nowblood=bfh;//血量重置
			nowblood-=x*i;//扣血
			if(nowblood<=0)//如果这个时候血量没了，那么就是塔打的，不符合条件，重新循环
			{
				continue;//还没有循环完，不保证其他情况也不行，所以重新开始循环
			}
			while(nowblood>0)//让塔打完了，现在英雄先打，塔再打
			{
				nowblood-=y;//小兵减少y血量
				if(nowblood<=0)
				{
					cout<<"Yes\n";//找到成功解，直接输出即可
					return;
				}
				nowblood-=x;//小兵减少x血量
				if(nowblood<=0)
				{
					continue;
				}
			}
		}
        //所有条件循环完毕，肯定不行了。
		cout<<"No\n";
		return;
}
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		cin>>h>>x>>y;//输入数据。
		is_it_okay(h);
	}
	return 0;
}
```

有一点比较需要注意，就是**一次循环中，确定可以收人头就可以退出，不确定可不可以收人头还需要继续循环（不能输出No退出）**

~~还有，顺便说一句，发现别的神佬都是用公式，我菜菜就用循环吧~~

---

## 作者：gcwixsxr (赞：2)

### **本蒟蒻靠代码短活到现在**

看看此题,通过率:1.3%(2020/4/29)

![](https://cdn.luogu.com.cn/upload/image_hosting/hbgnr25x.png)

~~惊愕~~

再看看标签,"数论,数学"

这道题其实可以带公式qwq

### 最关键的是judge函数

**先来4个特判**

1.如果小兵的血量已经小于英雄的攻击,~~一刀秒~~

2.如果英雄没有攻击,~~哪里来的自信去补刀?~~

3.如果防御塔没有攻击,~~英雄都不用急着抢~~,~~美滋滋...~~

4.如果小兵的血量已经小于防御塔的攻击,并且大于英雄的攻击,防御塔一击即灭,~~英雄补刀想都别想~~

**然后最最关键的部分来了**

如果小兵的血量能够整除防御塔的攻击,那么防御塔至少攻击小兵a/b次干掉小兵,在这a/b次防御塔攻击的间隔之间,英雄可以发动攻击,如果英雄发动a/b次攻击的伤害可以替换1次防御塔的攻击,那么就可以补刀;反之,如果英雄发动a/b次攻击的伤害不能替换1次防御塔的攻击,则英雄不能补刀

如果小兵的血量不能够整除防御塔的攻击,那么防御塔至少攻击小兵a/b+1次干掉小兵,那么在前a/b次防御塔攻击的间隔之间,英雄可以发动a/b+1次攻击,如果能消耗完小兵被防御塔打剩的血量,那么就可以补刀,反之不能
```cpp
if(a%b==0)
	if((a/b)*c>=b)return true;
	else return false;
else if(((a/b)+1)*c>=a-(a/b)*b)return true;
	else return false;
```

#### 下面是judge的完整代码
```cpp
bool judge (long long a,long long b,long long c){
	if(a<=c)return true;
	if(c==0)return false;
	if(b==0)return true;
	if(b>=a&&a>c)return false;
	if(a%b==0)
		if((a/b)*c>=b)return true;
		else return false;
	else if(((a/b)+1)*c>=a-(a/b)*b)return true;
		else return false;
}
```
#### 下面是AC代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
bool judge (long long a,long long b,long long c){
	if(a<=c)return true;
	if(c==0)return false;
	if(b==0)return true;
	if(b>=a&&a>c)return false;
	if(a%b==0)
		if((a/b)*c>=b)return true;
		else return false;
	else if(((a/b)+1)*c>=a-(a/b)*b)return true;
		else return false;
}
signed main(){
	int n;
	long long d,e,f;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){	
		scanf("%lld%lld%lld",&d,&e,&f);
		if(judge(d,e,f))cout<<"Yes"<<endl;
		else cout<<"No"<<endl; 
	}
	return 0;
}
```



---

## 作者：红尘仙 (赞：1)

~~本来想一想，我不想第一个题解是黄题，但这个题，太有魅力了。~~

# 题解

###  说一下我的思路，因为英雄要经济，所以希望能够补到最后一下，那这个题我觉得就是一个份模拟。

### 我们先判断一下小兵进入防御塔的时候，这个时候是最简单的；

1.如果小兵的血量为0，那么直接输出“No”就好了，但这个题的数据没有这么出，所以可以忽略掉第一个

2.小兵血量不为零，但是这个英雄他不能攻击了，~~你说气不气~~，
那么这个时候自然也是为输出“No”就OK了

### 小兵血量不为空，英雄有伤害，这个时候就该判断一下塔了，我们先来考虑这个简单的：

 3.当塔伤为零的时候，~~（这个塔怕不是对面的呦）~~，英雄就可以尽情怎么打都可以补到这个兵

### 现在塔伤不为零了，英雄的伤害很低（~~钱不够买装备呀，不然为啥要吃经济呢）~~，这个时候塔能直接秒掉小兵，但英雄的伤害呢？

4.这就是第4个判断，当英雄的伤害不足以秒杀小兵，那么塔将直接打死小兵，这个时候就直接输出“No”了

5.要是英雄伤害足够秒杀当前血量的小兵，那么这个时候就可以直接秒掉，因为题目中说的是英雄是可以抢在前面给小兵一击的

### 现在就轮到最重要的判断了，也是这道题难点所在了

现在小兵和英雄都不可以直接秒杀小兵，只能是塔打一下，英雄打一下，英雄一下，塔一下（不规律的呀，打个比方），这个时候判断什么呢？

我们可以判断一下，先让塔去打，打完之后，判断一下打h/x下是否恰好能打死小兵就可以了，

如果可以，那么意味着在塔打小兵 h/x下就会将小兵打死，同时，英雄最多也是只能打小兵h/x下，如果英雄打 h/x下，能代替防御塔打一下，那么就可以补刀，否则就自然不行了

如果不行，那么就判断一下，英雄打小兵 h/x+1下是否可以代替掉塔打完h/x下所剩下的血量就OK了


# 所以我觉得就是一个模拟，

附上AC代码

```c
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
int t;
int main()
{
	scanf("%d",&t);
	for(register int i=1;i<=t;i++)
	{
		long long h,x,y;//注意看一下数据，我一开始没看
        				//就很迷
		scanf("%lld%lld%lld",&h,&x,&y);
		if(y==0)
		{
			cout<<"No"<<endl;
			continue;
		}
		else if(h==0)
		{
			cout<<"No"<<endl;
			continue;
		}
		else if(x==0)
		{
			cout<<"Yes"<<endl;
			continue; 
		}
		else if(h>y&&x>=h)
		{
			cout<<"No"<<endl;
			continue;
		}
		else if(h<=y)
		{
			cout<<"Yes"<<endl;
			continue;
		}
		else if(h%x==0)
		{
			if((h/x)*y>=x)
			{
				cout<<"Yes"<<endl;
				continue;
			}
			else
			{
				cout<<"No"<<endl;
				continue;
			}
		}
		else if( ((h/x)+1)*y>=h-(h/x)*x)
		{
			cout<<"Yes"<<endl;
			continue;
		}
		else
		{
			cout<<"No"<<endl;
			continue;
		}
	}
	return 0;
} 
```



---

## 作者：jscblack (赞：0)

还是比较有意思的一道题目。

idea与cf1296D有异曲同工之处

大概都是通过模拟的思路去解决问题，但绝对不是你一刀我一刀这么光秃秃的去模拟。

我们不妨将你a的一刀与防御塔a的一刀算作一组伤害$(x+y)$

显然如果满足$x>=(h\%(x+y))>=1$此时一定可以被英雄击杀

否则就意味着我们a多了，让防御塔多垫几刀，我们就可以用一个while循环去处理英雄少a刀的情形，如此我们总能确定是否可以将最后一刀给到英雄。

还有一点就是需要注意/0的特判，避免re

详见代码注释

```cpp
/*
 * @Author: Gehrychiang
 * @LastEditTime: 2020-04-27 19:00:34
 * @Website: www.yilantingfeng.site
 * @E-mail: gehrychiang@aliyun.com
 * @ProbTitle: 补刀
 */
//#pragma GCC optimize(2)
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int main()
{
    //freopen("","r",stdin);
    //freopen("","w",stdout);
    int t;
    scanf("%d", &t);
    while (t--)
    {
        unsigned long long h, x, y;
        scanf("%lld %lld %lld", &h, &x, &y);
        //每一轮伤害是x+y  x必打，y随意
        int flag = 0;
        if (x + y == 0)
        {
            //我在干什么cout << x + y << endl;
            flag = 0;
        }
        else
        {
            if (x == 0 && y != 0)
            {
                flag = 1;
            }
            else
            {
                unsigned long long cir = (h / (x + y)) + 1; //cir轮次
                h %= (x + y);                               //如果每次都打
                if (h >= 1 && h <= y)
                {
                    //正常能a掉
                    flag = 1;
                }
                else
                {
                    //此时y一刀死不掉
                    for (unsigned long long i = 1; i <= cir; i++)
                    {
                        h += y; //少a一次y
                        h %= (x + y);
                        if (h >= 1 && h <= y)
                        {
                            //正常能a掉
                            flag = 1;
                            break;
                        }
                    }
                }
            }
        }
        if (flag)
        {
            printf("Yes\n");
        }
        else
        {
            printf("No\n");
        }
    }
    return 0;
}
```


---

## 作者：Mr_WA的大号 (赞：0)

AK NOI者，人中豪杰也。小学生又来发题解了！

题号：P6462

难度：★★★

算法：暴力

## 开课了！

这一题就是著名的“裸暴力”。

题目的大意是：英雄可以在防御塔攻击的前后给小兵补刀，问防御塔能不能被英雄抢小兵的人头。

英雄攻击的时间可以分为两大类：第一类为第一时间攻击，不给防御塔机会；第二类为在防御塔攻击后补刀。

我们之前说了这题是暴力，那暴力什么呢？暴力防御塔攻击几次后英雄和防御塔开始交替攻击。

当然这题还会有几个特判：

1.如果英雄不能攻击，输出No

2.如果防御塔不能攻击，输出Yes

3.如果防御塔能一击斩杀小兵但是英雄不能，输出No

4.如果英雄能一击斩杀小兵，输出Yes

课讲完了，上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<iomanip>
using namespace std;
int t;
long long h,x,y;///定义h、x、y记得用long long
void prime(long long sum)
{
	if(y==0)
	{
		cout<<"No"<<endl;
		return ;
	}
	if(x==0)
	{
		cout<<"Yes"<<endl;
		return ;
	}
	if(h<=x&&y<h)
	{
		cout<<"No"<<endl;
		return ;
	}
	if(h<=y)
	{
		cout<<"Yes"<<endl;
		return ;
	}//4条特判
	long long ans;
	for(int i=0; i<=sum/y+1; i++)
	{
		ans=sum;//赋小兵血量
		ans=ans-x*i;//小兵被防御塔打i次
		if(ans<=0)continue;//如果小兵死了，跳过
		while(ans>0)//如果小兵没死
		{
			ans-=y;//英雄攻击
			if(ans<=0)//如果小兵死了
			{
				cout<<"Yes"<<endl;//输出Yes
				return ;
			}
			ans-=x;//防御塔攻击
			if(ans<=0)//如果小兵死了
			{
				continue;//跳过
			}
		}
	}
	cout<<"No"<<endl;//循环完了小兵都不能被英雄杀死，输出No
}
int main()
{
	cin>>t;
	for(int i=1; i<=t; i++)
	{
		cin>>h>>x>>y;
		prime(h);//开始模拟攻击
	}
	return 0;
}
```
祝大家能AC！

---

## 作者：Provicy (赞：0)

我就说一下我比赛时候的思路吧。

首先，**本题只要求我们求出是否能击杀小兵，而不是求出最快的击杀小兵时间**，这一点很重要。所以我们就考虑到让塔去打更多的伤害，让英雄打更少的伤害。这样会让英雄理论上能造成的伤害（即每一次能攻击的时候都攻击）更高，就更可能得到 `Yes` 的答案。

考虑英雄最多可以攻击的次数。当 $x\nmid h$ 时，由题意，如果英雄不进行攻击的话，塔将会用 $a=\lfloor \frac{h}{x}\rfloor+1$ 次攻击击杀小兵。由上文我们攻击的原则，英雄应该在塔攻击 $a-1$ 次后出手将这个小兵带走。那么英雄只要打 $c=h-(a-1)\times x$ 的伤害即可。显然，英雄最多能攻击 $a$ 次，所以只需要满足 $a\times y \geq c$ 即可输出 `Yes`，否则输出 `No`。当 $x \mid h$ 时，我们要让 $a$ 减去 $1$ 再带入上述式子即可。

然后我们需要做一些特判（可能会有重复或者可能无用的特判）：

$1$：当 $y=0$ 时，只能输出 `No`。

$2$：当 $x=0$ 且 $y\not=0$ 时，输出 `Yes`，否则将进入情况 $1$，输出 `No`。

$3$：当不满足 $1,2$ 情况时，当 $y\geq h$ 时，输出 `Yes`。

$4$：当不满足 $1,2,3$ 情况时，当 $x\geq h$ 时，输出 `No`。

然后就结束了，代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <queue>
#include <set>
#include <vector>
#include <stack>
#include <map>
#define ri register
#define inf 0x7fffffff
#define E (1)
#define mk make_pair
#define int long long
using namespace std;
inline int read()
{
	int s=0, w=1; ri char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48), ch=getchar(); return s*w;
}
void print(int x) {if(x<0) x=-x, putchar('-'); if(x>9) print(x/10); putchar(x%10+'0'); }
signed main()
{
	for(ri int T=read();T;T--)
	{
		int h,x,y;
		h=read(), x=read(), y=read();
		if(!x)
		{
			if(!y) puts("No");
			else puts("Yes");
			continue;
		}
		if(!y) {puts("No"); continue; }
		if(y>=h) {puts("Yes"); continue; }
		if(x>=h)
		{
			if(y>=h) puts("Yes");
			else puts("No");
			continue;
		}
		int a=h/x, b=a*x, c=h-b;
		if(!c)
		{
			if(a*y>=x) puts("Yes");
			else puts("No");
		}
		else
		{
			if((a+1)*y>=c) puts("Yes");
			else puts("No");
		}
	}
	return 0;
}
```


---


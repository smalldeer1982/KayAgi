# 「EZEC-2」异或

## 题目描述

有 $T$ 组询问，每次给定两个正整数 $n,l$，   

你需要构造一个长度为 $l$ 的正整数序列 $a$（编号从 $1$ 至 $l$），   

且满足 $\forall i\in[1,l]$，都有 $a_i\in[1,n]$。

求：

$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$

的最大值。

为了避免答案过大，对于每组询问，只需要输出这个最大值对 $10^9+7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**   
当 $n=2,l=3$，$a$ 取 $\{1,2,1\}$ 的任一排列时可以得到最大值，为 $(1\oplus2)+(1\oplus1)+(2\oplus1)=6$，易证明此时原式有最大值。

---
**【数据规模与约定】**
| 测试点编号 | $T\le$ | $n\le$ | $l\le$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim5$ | $1$ | $10$ | $5$ |
| $6$ | $5\times 10^5$ | $10^{12}$ | $2$ |
| $7$ | $5\times 10^5$ | $10^{12}$ | $3$ |
| $8\sim10$ | $5\times 10^5$ | $10^{12}$ | $10^5$ |

对于 $100\%$ 的数据，满足 $1\le T\le 5\times10^5$，$1\le n\le 10^{12}$，$2\le l \le 10^5$。


---
**【提示】**

1. 「$\oplus$」是按位异或符号。如果您不知道什么是按位异或，可以参考[这里](https://oi-wiki.org/math/bit/#_1)。
2. 取模是一种运算，$a$ 对 $b$ 取模代表将 $a$ 赋值为 $a$ 除以 $b$ 所得到的余数。  
在 C++ / Python 中的取模符号为 `%`，在 Pascal 中的取模符号为 `mod`。
3. $\sum$ 是求和符号。如果您不知道什么是 $\sum$ 符号，可以参考[这里](https://baike.baidu.com/item/∑/1233796?fr=aladdin)。
4. 请注意数据的读入输出对程序效率造成的影响。

## 样例 #1

### 输入

```
1
2 3
```

### 输出

```
6```

## 样例 #2

### 输入

```
2
114 514
1919 180
```

### 输出

```
8388223
16580700```

# 题解

## 作者：dead_X (赞：18)

## 考场心路历程
由于是unrated比赛所以只写了个签到题

5min写完了，难度建议橙/黄

IEE出的题质量还不错/cy
## 思路简述
首先考虑给定 $l$ 个数，求那个式子的值的情况。

由于位运算位与位之间互不干扰，我们可以考虑**按位分析**，再计算每一位可以给总答案的贡献。

于是对于每一位，问题转化成了**给定 $n$ 个 $0$ 或 $1$**，求那个式子的值。

注意到以下的性质:

1. 这些 $0$ 和 $1$ 两两的 $xor$ 值只能是 $0$ 或 $1$ 。
2. 上一条性质中取 $1$ 的情况为一个 $0$ 异或一个 $1$ 。
3. 对答案的贡献就是取 $1$ 的情况乘以这一位的位值。

显然这一位的贡献就是 $2^k\times x\times(l-x)$ ，其中 $2^k$ 代表所在的二进制位，$x$ 代表这一位 $1$ (或者 $0$ ) 的数量，总答案即为各位的贡献和。

那么如果告诉你这些数的最大值，怎么最大化那个式子呢?

还是**先看每一位的情况**。

在上面的公式中，对于每一位， $2^k$ 是给定的，那么问题就是 $x\times(l-x)$ 如何**最大化**?

小学奥数基础知识: $x=\frac{l}{2}(2\mid l)$ 或 $x=\frac{(l\pm1)}{2} (2\nmid l)$ 时取到。

所以我们要保证每一位的 $1$ 数量**尽可能靠近** $\frac{l}{2}$ 。

简单的讨论之后发现每一位都可以取到最大值。

构造证明: 

设 $p$ 为不大于 $n$ 的最大 $2$ 的自然数次幂数，则

$\frac{l}{2}(2\mid l)$ 或 $\frac{(l\pm1)}{2} (2\nmid l)$ 个数取 $p$ ， 剩下的取 $p-1$ 即可。

~~然后就做完了~~ 恭喜你，WA了((((((

注意特判 $n=1$ ，因为 $p-1=0$ 取不到，手模一下发现直接输出 $0$ 即可。

## Code
```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int f=1,num=0;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1; ch=getchar();}
    while(isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
    return num*f;
}
inline long long readll()
{
    long long f=1,num=0;
    char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1; ch=getchar();}
    while(isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
    return num*f;
}
int main()
{
	int T=read();
++T;
	while(--T)
	{
		long long x=readll(),y=readll(),t=y>>1;
		if(x==1)
		{
			puts("0");
			continue;
		}
		long long now=1LL<<40,res=0;
		while(now)
		{
			now>>=1;
			if(x<now) continue;
			res+=now*t*(y-t);
		}
		printf("%lld\n",res%1000000007LL);
	}
	return 0;
}
```

---

## 作者：Surge_of_Force (赞：11)

题解区的其他大佬们都给出了详细证明，

但是像我这样的 vegetable 想不到怎么办，

于是我们有请大法师。

没错，这篇题解就是教你如何打表找规律切掉这题。

首先不难写出一个 $O(n^l)$ 的大暴力，把表打出来，长[这个样子](https://www.luogu.com.cn/paste/vccyzibf)。

通过这个表，我们发现了以下几个特征：

- $l=1$ 时，答案为 $0$。

- 有许多重复的数。

第一条没什么好研究的，再来观察第二条，

发现当 $l$ 相等时，相同数字分成一块一块，长度分别为：$1$，$2$，$4$...

很明显，相同数字的长度是与 $n$ 的二进制位数有关的，由于需要最大化答案，于是把答案除以 $2^x-1$，其中 $x$ 是 $n$ 的二进制位数，又得到了一个[表](https://www.luogu.com.cn/paste/iu6cyzmr)。

由于是要研究 $ans$ 与 $l$ 的关系，我把 $n$ 限制为 $5$，

仔细观察，相邻数的差值好像也有一样的，为了方便，我们把答案存下来，差分一次，[再输出](https://www.luogu.com.cn/paste/bgp8x51c)。

规律很明显的，总结一下：

- $n=1$，输出 $0$。

- 否则预处理一个数组 $a$，$a_i=\lfloor \frac{i}{2} \rfloor$，对它做一次前缀和，答案即为 $a_l\times (2^x-1)$，$x$ 为 $n$ 的二进制位数。

于是这题就做完了，

注意开ll和取模。

---

## 作者：李白莘莘学子 (赞：11)

# **1.题外话**

看到∑，就恶心；

看到黄题，就想切；

总之，心情很复杂，硬着头皮看下去，发现没这么难

# **2.解题意**

![](https://cdn.luogu.com.cn/upload/image_hosting/5n6ipjd2.png)

外层循环，从$ 1-i $；

内层循环，从$ 1-j $；

从第二层循环考虑，易知对于每一个$ai$，都会和位于其之前的aj进行一次异或并且加和。并且当i增大后，位于当前这个$ai$后面的a元素也会与其进行异或并累加；

也就是说，我们可以这样理解：每一个$ai$都与序列l中剩下的$a$进行了一次异或并且累加。

这是对于一个$ai$；将外层循环考虑在内，我们就知道：题目让求的就是所有的元素与其他任意一个元素的异或之和。（类似于两两握手那种问题。只不过是把握手换成了异或）。

# **3.找思路**

由数据得，$a$最大为$10^{12}$.因为是异或，那么二进制表示下各个位数之间互不干扰。并且题目只是给了$n$，要$∑$使值最大，很容易便想到每一个a都需要达到位数上限n。既然位数相同，题目又没有给你具体每一个$a$的数值，我们便可以一位一位考虑，每一位取到和的最大值，再$ \times 2^k$进行累加即可。

求答案的方法已经基本成型了，剩下的就是确定每一位异或和最大的情况。

对一位进行考虑：

两两异或，其中一个为$1$，另一个为$0$，则答案为$1$。

我们设有$x$个数为$0$。

对于每一个为$1$的数，都可以和所有为$0$的数异或得$1$，对答案的贡献就是$x$；

总个数为l，则剩下的大小为$1$的数有$l-x$个，一个就可以为答案增加$x$，$l-x$个就可以为答案增加$x \times (l-x)$。很明显，当x取中间值$l/2$时上式取值最大.（具体为什么参考“和同近积大”原理或者二次函数求极值即可）

于是，我们求得了每一位对答案最大的贡献，接着把每一位对答案的贡献累加起来，就是题目所求答案。

# **4.代码实现**

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define modd 1000000007
using namespace std;
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int t;
long long n,l,ans;
int main()
{
	t=read();
	while(t--)
	{
		ans=0;
		scanf("%lld%lld",&n,&l);
		long long mid=l>>1;
		if(n==1)//特判
		{
			printf("0\n");
			continue;
		}
		long long big=1ll<<40;//1ll用法近似于类型转换
		while(big)
		{
			big>>=1;
			if(n<big)continue;
			ans+=big*mid*(l-mid);//进行答案累加
			ans%=modd;
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```

完结撒花~，有问题评论区提出即可。

---

## 作者：君のNOIP。 (赞：9)

## 50分： $O(Tn^l)$ dfs。

dfs 枚举所有可能的序列 $a$ 取答案最大的方案即可。

## 60~70分：找规律。

我们设 $p$ 为 $n$ 的二进制下的位数。

当 $l=2$ ，直接使答案每位都为 $1$ 即可。

当 $l=3$，其实就是 $l=2$ 的答案乘以 $2$。

详解见下文。

## 100分：$O(Tlogn)$ 贪心

### 首先爆搜找规律。

先写个 50 分的 dfs，输出最优方案的**二进制**形式。

然后我们就能很轻松地发现，每一位上的数字之和都为  $\left\lfloor\dfrac{l}{2}\right\rfloor$ 或 $l -\left\lfloor\dfrac{l}{2}\right\rfloor$。

### 好了，爆搜结束，开始分析。

我们还是设 $p$ 为 $n$ 的二进制下的位数。

如当 $n=13$，二进制下为 $1101$，则 $p=4$

设所有元素从右到左第 $i$ 位上的 $0$ 有 $x_i$ 个，$1$ 有
$y_i$ 个，显然 $x_i+y_i=l$。

考虑分每位单独计算答案，显然答案为 $\sum \limits _{i=1}^p x_i \times y_i\times 2^{i-1}$

即 $\sum \limits _{i=1}^p x_i \times (l-x_i)\times 2^{i-1}$

很显然当所有 $x_i$ 为 $\left\lfloor\dfrac{l}{2}\right\rfloor$ 或 $l -\left\lfloor\dfrac{l}{2}\right\rfloor$时答案最大，也就是我们爆搜找规律的结果。

所以答案为 $(2^p-1)\times \left\lfloor\dfrac{l}{2}\right\rfloor \times (l -\left\lfloor\dfrac{l}{2}\right\rfloor)$

### 对能够构造出该序列的证明：

一个简单的方法，我们知道 $2^{p-1} \le n$ ，所以我们只需构造出 $\left\lfloor\dfrac{l}{2}\right\rfloor $ 个元素 $2^{p-1}$ 和 $(l -\left\lfloor\dfrac{l}{2}\right\rfloor)$ 个元素 $2^{p-1}-1$ 就可以保证符合要求了。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define mod 1000000007
LL T, n, m, slg[50];;
int main() { 
	slg[0] = 1;
	for(int i = 1; i <= 40; i++) slg[i] = (slg[i-1] + ((LL)1<<i) ) % mod;
	scanf("%d",&T);
	while(T--) {
		scanf("%lld%lld",&n,&m);
		if(n == 1) printf("%d\n", 0);
		else printf("%lld\n", m / 2 * (m - m / 2) % mod * slg[(int)log2(n)] % mod);
	}
}
```


---

## 作者：一只书虫仔 (赞：5)

#### Description

> 给定 $n,l$，求构造一个长度为 $l$ 的序列 $a_i$，$a_i \in [1,n]$，满足：
>
> $$\sum\limits_{i=1}^l\sum\limits_{j=1}^{i-1}a_i \oplus a_j$$
>
> 最大，求这个最大值。

#### Solution

按位考虑，下文的 位 定义为，第 $i$ 位的权为 $2^i$。

设第 $i$ 位有 $k$ 个 $1$，那么对答案的贡献为 $k \times (l-k) \times 2^i$。

$2^i$ 是固定的，我们要做的就是使 $k \times (l-k)$ 最大。

根据和一定，差小积大可得 $k=\lfloor\frac l 2\rfloor$ 时答案最大。

因此答案即为（设 $\overline n=\lfloor\log _2 n\rfloor $）：

$$\begin{aligned}\textsf{ans}&=\sum\limits_{i=0}^{\overline n}\left\lfloor\frac l 2\right \rfloor \times \left(l-\left\lfloor\frac l 2\right\rfloor\right) \times2^i\\&=\left\lfloor\frac l 2\right\rfloor \times \left(l-\left\lfloor\frac l 2\right\rfloor\right) \times \sum\limits_{i=0}^{\overline n}2^i\\&=\left\lfloor\frac l 2\right\rfloor \times \left(l-\left\lfloor\frac l 2\right\rfloor\right) \times (2^{\overline n+1}-1)\end{aligned}$$

然后我们就用 $\mathcal O(t \log \log n)$ 的优秀解法解决了这道题。

总结：本题是一道早期 EZEC 良心题，再次谴责现在 EZEC 出的大毒瘤题。

#### Code

```cpp
#include <bits/stdc++.h>
#define Mod 1000000007

using namespace std;

int main () {
	int t;
	scanf("%d", &t);
	while (t--) {
		long long n, l;
		scanf("%lld%lld", &n, &l);
		if (n == 1) {
			puts("0");
			continue;
		}
		n = log2(n);
		long long ans = (((l / 2) * (l - (l / 2))) % Mod) * (((1ll << (n + 1)) - 1));
		printf("%lld\n", ans % Mod);
	} 
	return 0;
}
```

---

## 作者：do_while_true (赞：4)

upd: 修改了几处笔误。

看到位运算，想到分每个二进制位算贡献。

我们先设 $n=2^k-1$，也就是 $(111...1)_2$，这样每一个二进制位取 $1$ 或 $0$ 都不会超出 $a_i\in[1,n]$ 的限制。

这个时候我们看每个二进制位，设第 $k$ 个二进制位共有 $x$ 个 $1$ ，则对答案的贡献为 $x(l-x)*2^{k-1}$，我们想要使得这个式子值最大，就要使得 $x(l-x)$ 最大，这时候我们想到小学~~二年级~~数学里的：

> 一个长方形的长和宽的和为 $n$ ，则长和宽为多少时面积最大

显然 $x=\lfloor\frac{l}{2}\rfloor$ 时 $x(l-x)$ 最大 （下取整和上取整都一样）

考虑采用反证法证明：

当 $x=\frac{l}{2}$ 时，$x(l-x)=\frac{l^2}{4}$

假设 $x$ 有取值使得式子值更大，设该取值为 $x=\frac{l}{2}-y$，此时$x(l-x)=(\frac{l}{2}-y)(\frac{l}{2}+y)=\frac{l^2}{4}-y^2$，因为 $-y^2\leq0$，所以 $x=\frac{l}{2}-y$ 不如 $x=\frac{l}{2}$ 更优，假设错误。

假如你学过二次函数:

设 $y=x(l-x)$

$y=-x^2+lx$

二次项的系数为负数，则开口朝下有最高点，其最高点的横坐标 $-\frac{b}{2a}=\frac{l}{2}$ ( 其中 $a$ 为二次项系数， $b$ 为一次项系数 )，所以 $x=\frac{l}{2}$ 时该二次函数有最大值。

所以第 $k$ 个二进制位对答案的最大贡献为
$$\lfloor\frac{l}{2}\rfloor\times(l-\lfloor\frac{l}{2}\rfloor)\times2^{k-1}$$

则答案为

$$\sum\limits_{k=0}^{\log_2^n}\lfloor\frac{l}{2}\rfloor\times(l-\lfloor\frac{l}{2}\rfloor)\times2^{k}$$

$$\lfloor\frac{l}{2}\rfloor\times(l-\lfloor\frac{l}{2}\rfloor)\times\sum\limits_{k=0}^{\log_2^n}2^{k}$$

$$\lfloor\frac{l}{2}\rfloor\times(l-\lfloor\frac{l}{2}\rfloor)\times(2^{\log_2^n+1}-1)$$

那么如果 $n$ 不为 $(111...1)_2$ 时，会不会对我们的构造方法产生影响呢？考虑最坏情况，$n=(100...0)_2$，我们可以构造出 $\lfloor\frac{l}{2}\rfloor$ 个 $(100...0)_2$，$(l-\lfloor\frac{l}{2}\rfloor)$ 个 $(011...1)_2$，即满足要求。

综上所述，答案为: 

$$\lfloor\frac{l}{2}\rfloor\times(l-\lfloor\frac{l}{2}\rfloor)\times(2^{\log_2^n+1}-1)$$

注意特判 $n=1$ 时的特殊情况。

### $\mathcal{Code:}$
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long 
const ll mod=1000000009;
int T;
ll n,l;
ll qpow(ll x,ll y)
{
	ll base=x%mod,sum=1;
	while(y) {
		if(y&1) sum=sum*base%mod;
		base=base*base%mod;
		y>>=1;
	}
	return sum;
}
int main()
{
	scanf("%d",&T);
	while(T--) {
		scanf("%lld%lld",&n,&l);
		printf("%lld\n",( l / 2 ) * ( l - l / 2 ) % mod * ( qpow( 2, log(n) / log(2) + 1 ) - 1 ) % mod );
	}
}
```

---

## 作者：卷王 (赞：3)

## 题目大意

[传送门](https://www.luogu.com.cn/problem/P6599)

## 大体思路

暴力肯定不行，那么我们考虑优化。但是似乎公式优化也不行啊 qwq。

那么联系 $n$ 的数据范围，我们就需要一个 $O(1)$ 的算法，于是我们尝试从中间找找规律吧。

我们知道，只有 $0$ 和 $1$ 异或起来最终才得到 $1$，那么对于每一位（二进制），我们得尽量保持出现的 $1$ 的个数在总共数的个数（也就是 $l$）的一半左右，效果是最佳的。如果你听不懂，可以看看题目下面的样例解析，把它给的数以二进制从上到下排列，看看每一位 $1$ 的个数是不是在 $l \div 2$ 左右呢？

现在还有一个问题：二进制最多一共有多少位？很简单，就是 $\log(n)$。因此，我们可以定义一个 $now$ 变量，从 $2^{40}(>10^{12})$ 开始，每次除以 $2$，直到小于 $n$ 为止，每一次累计答案即可。

每次累加的答案就是 $now × (l \div 2) × (l - l \div 2)$。具体大佬们就参照一下别的题解吧，我不细讲了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
const int mod = 1000000007;
int T, n, l;
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar(); }
	return x * f;
}
signed main() {
	T = read();
	while(T--) {
		n = read(), l = read();
		if(n == 1) { printf("0\n"); continue; }
		int now = (1ull << 40), t = l / 2, ans = 0;
		while(now > 0) {
			now >>= 1;
			if(n < now) continue;
			ans += now * t * (l - t);
		}
		printf("%lld\n", ans % mod);
	}
	return 0;
}
```

---

## 作者：_jimmywang_ (赞：3)

$emmm,$吐槽一下，为啥我取模会被卡成$90pts$啊，极其痛苦

## 进入正题：

首先，我们有前$50\%$的数据，可以爆搜。

所以爆搜。

$50pts$.

然后，我们看看测试点$6$

$l=2???$

那就好了，就俩数。

我们知道异或是不进位的加法（2进制）

所以一定是两个数和是2的整次幂-1的（用爆搜程序检验也一样）

于是，答案就是$2^{log_2n+1}-1$

$60pts$

接下来，测试点$7$:

~~算了算了和下面的一起讲了吧~~

我们找找规律：
$$n=10,l=1\;ans=0$$
$$n=10,l=2\;ans=15$$
$$n=10,l=3\;ans=30$$
$$n=10,l=4\;ans=60$$
$$n=10,l=5\;ans=90$$
$$n=10,l=6\;ans=135$$

emmm,加15加15加30加30加45


有规律了~

$ans=(2^{log_2n+1}-1)*floor(l*l/4)$



---

## 作者：Acerkaio (赞：2)

### 题目

[Link](https://www.luogu.com.cn/problem/P6599)

### 思路

审题得，题目其实要求求所有的 $a_i$ 两两异或得到的最大值。

此题类似于 [P2114](https://www.luogu.com.cn/problem/P2114)，和 [P6102](https://www.luogu.com.cn/problem/P6102)。

由于二进制异或运算不会进位，我们同样按位考虑。

易得出更高的位数为 $1$ 答案就越大，所以要由高位往低位枚举，对于每一位，对答案最大值有贡献的情况就只有一个是 $1$，另一个是 $0$。

我们设这一位为 $1$ 的有 $x$ 个数，则这一位为 $0$ 的有 $l - x$ 个。能使这一位为 $1$ 的就有 $x \times (l - x)$ 个，所以这一位就会加 $x \times (l - x)$ 个 $1$，所以要求 $x \times (l - x)$ 最大值。

![png](https://cdn.luogu.com.cn/upload/image_hosting/b71irix5.png)

图为 $l = 10$ 的情况，易得当 $x = 5$ 时，$x \times (l - x)$ 最大。

易得出 $x = \frac{l}{2}$ 时，$x \times (l - x)$ 最大。

因为 $a_i\in[1,n]$，所以要从 $n$ 的二进制最高那一位开始枚举。

### 坑点

当 $n = 1$ 时，这一位无法被异或。

### CODE

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1000000007;
inline int calcbit(int x) {
	int tot = 0;
	while(x > 0) {
		tot++;
		x >>= 1;
	}
	return tot;
}
int T, n, l;
signed main() {
	cin >> T;
	while (T--) {
		cin >> n >> l;
		if (n ==  1) {
		    cout << 0 << '\n';
		    continue;
		}
		int ans = 0;
		int len = calcbit(n);
		int x;
		x = l / 2;
		for(int i = len - 1; i >= 0; i--) {
			if (((int)1 << i) <= n) {
				ans = ans + (((int)(x * (l - x)) << (i))) % mod;
				ans %= mod;
			}
		}
		cout << ans << '\n';
	}
	return 0;
}
```


---

## 作者：wwxxbb (赞：1)

## 题意

>给定两个正整数 $n,l$，构造一个长度为 $l$ 值域为 $[1,n]$ 的正整数序列 $a$，求：
>$$\sum_{i=1}^l\sum_{j=1}^{i-1}a_i\oplus a_j$$
>的最大值。

## 思路

挺好的一道题。

对于异或求最大值的问题，我们一般一位一位地考虑。

对于二进制下的第 $i$ 位，设有 $x$ 个数这一位为 $1$，因为一共有 $l$ 个数，所以这一位为 $0$ 的有 $l - x$ 个。

对于每一个这一位为 $1$ 的数，都可以和所有这一位为 $0$ 的数异或得 $1$。一共有 $x$ 个 $1$，每个 $1$ 都可以让 $l-x$ 个 $0$ 对增加 $1$，总共就增加 $x\times(l-x)$，而这一位的值为 $2^i$，所以对答案的贡献就是 $x\times(l-x)\times2^i$。

由最值的相关知识可知，当 $x=l-x$，即 $x = \lfloor\frac{l}{2}\rfloor$ 时最大，所以答案为：
$$
\color{blue}\sum_{i=0}^{\lfloor\log_{2}n\rfloor}2^i\color{black}\times\lfloor\frac{l}{2}\rfloor\times(l-\lfloor\frac{l}{2}\rfloor)
$$
蓝色部分可以化简一下（不会的可以私信我）：
$$
\color{blue}(2^{\lfloor\log_{2}{n+1}\rfloor}-1)\color{black}\times\lfloor\frac{l}{2}\rfloor\times(l-\lfloor\frac{l}{2}\rfloor)
$$
记得特判一下 $n=1$ 的情况，此时 $a_i$ 只能为 $1$，所以答案只能是 $0$。

## Code

```c++
#include <bits/stdc++.h>
using namespace std;

using ll = long long;
const int mod = 1e9 + 7;

int t;
ll n, l;

void solve() {
    cin >> n >> l;
    if (n == 1) return cout << 0 << '\n', void();
    cout << (l >> 1) * (l - (l >> 1)) % mod * ((1ll << ((ll)log2(n) + 1)) - 1) % mod << '\n';
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> t;
    while (t--) solve();
    return 0;
}
```

---

## 作者：xinxin2022 (赞：0)

看到了异或，看到了超大的 $n$ 的范围，其他神犇就开始按位分析。

可是我是蒟蒻，不会按位分析怎么办。

没事，因为我们还可以打表，~~而且分数还不低~~将前五个测试点的数据范围下的答案的**二进制形式**打出来，然后~~交上去~~找规律。

容易发现每一位上的数字和都为 $\lfloor \frac{l}{2} \rfloor$ 或 $\lceil \frac{l}{2} \rceil$。

继续分析：

设 $x$ 为 $n$ 在二进制表示下的位数，则对于每位，计算公式如下：

$$\sum_{i=1}^{x} \lfloor \frac{l}{2} \rfloor \times \lceil \frac{l}{2} \rceil \times 2^{i-1}$$

所以答案为：

$$(2^x-1) \times \lfloor \frac{l}{2} \rfloor \times \lceil \frac{l}{2} \rceil$$

而因为 $2^{x-1} \le n$，所以现在要做的就是找到最大的 $x$。

显然因为 $10^{12} \le 2^{40}$，所以求 $x$ 最多只需要试 $40$ 次即可求出。

代码如下：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,l,ans,x;
const int mod=1e9+7;
const int m=(int)pow(2,40);
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    //输入量较大，记得关流。
    cin>>t;
    while(t--){
        cin>>n>>l;
        if(n==1) cout<<"0\n";
        //特判，n为1时最大值只能为0
        else{
            ans=0;
            x=m;
            //多测不清空，爆零两行泪。
            while(n<x) x/=2;//找x
            while(x){
                ans=(ans+x*((int)l/2)*(l/2+l%2))%mod;
                //记得最后取模
                x/=2;
            }
            cout<<ans<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：编程小贝壳 (赞：0)

[原题](https://www.luogu.com.cn/problem/P6599)

~~同学出的模拟赛采用了此题，遂来水一篇题解。~~

### 题意

从 $[1,n]$ 中选取 $l$ 个数字（可重复），求选出的数字两两异或之和的最大值。

### 思路

按位考虑对答案的贡献，发现第 $k+1$ 位对答案的贡献是 $2^k \times a\times(l-a)$，其中 $a$ 是这一位上 1 或 0 的数量。因此对于每一位，只需要考虑如何使 $a\times(l-a)$ 最大。

根据基本不等式，有 $a\times(l-a)\le \frac{a^2+(l-a)^2}{2}$，当且仅当 $a=l-a$ 即 $a=\frac{l}{2}$ 时取等号。若  $l$ 为奇数，那么当 $a=\frac{l}{2}\pm1$ 时取得最大值。

接下来考虑如何构造选出的 $l$ 个数字，使得对于每一位，0 和 1 的个数都尽量接近。

一种构造方法是，一半的数取最大的 $2^p$ 满足 $2^p\le n$，另外一半的数取 $2^p-1$ 即可。

最后记得特判若 $n=1$，那么答案一定为 0。

---

## 作者：hanzhongtlx (赞：0)

验题人分享一下做题方法：       
一眼很不可做，所以**猜结论**。

我们发现 一个数的二进制如果是 $x$ 位，和小于他的数异或之后最大得到 $2^x-1$ ，然后莽一发贪心：    
得到尽可能多的 $2^x-1$。    

有多少呢：  
设有 $n$ 个数，$a$ 个数取最大值， $n-a$ 个数取和最大值异或得到 $2^x-1$ 的数。   
那么：   
$$ans=n(n-a)(2^x-1)$$    
是一个二次函数，可以用相关知识得到当 $ans$ 最大时，$a=\dfrac{n}{2}$。   
那么最终的答案：
$$ans=\left\lfloor\dfrac{n}{2}\right\rfloor(n-\left\lfloor\dfrac{n}{2}\right\rfloor)(2^x-1)$$

和暴力对拍还真就对了.....

然后预处理出幂次,后面要用。   
 $STL$ 的 $\log $ 函数太慢，自己写了一个预处理+二分的。    
 注意特判 $n=1$。   
复杂度 $\mathcal O(\log n+T\log\log n)$，可已通过此题。
## $Code:$
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

#define ll long long
#define read(x) scanf("%lld",&x)
#define MOD 1000000007

ll mi[45];
int t;
ll l,r;

void get(int n)
{
	mi[0]=1;
	for(int i=1;i<=n;i++) mi[i]=mi[i-1]*2;
	return;
}

int logn(ll x)
{
	int l=1,r=40,mid;
	while(l<r)
	{
		mid=(l+r)>>1;
		if(mi[mid]<=x) l=mid+1;
		else r=mid;
	}
	return l;
}

int main()
{
	scanf("%d",&t);
	get(40);
	while(t--)
	{
		read(l),read(r);
		if(l==1) printf("%d\n",0);
		else printf("%lld\n",((mi[logn(l)]-1)%MOD*(r/2)%MOD*(r-r/2)%MOD));
	}
	return 0;
}
```    

当然了，求 $\log_2 n$ 还有比 $STL$ 快很多的奇技淫巧，不过时间复杂度还是还是 $O(T)$ ，所以不能得到踩 std 奖。（鸽鸽，别打我啊/kk

---

## 作者：liguangjun2023 (赞：0)

**算法分析**

本题属于构造类型，使用不大于 $n$ 的 $m$ 个正整数，构造出序列 $a$，使其异或和最大。

为了使和最大，最好的情况是结果的每一位都是 $1$，于是本题的思考方向为如何让结果的每一位尽可能为 $1$。

因为是按位的异或运算，所以每一位之间的相互独立。

针对第 $j$ 位，假设 $m$ 个数中有 $k$ 个数为 $0$，则 $1$ 的个数决定了结果的大小，大小为 $(m - k) \times k\times 2^j$，当 $k=m \div 2$ 时取最大值。

数位的每一位相加，即是答案；


------------
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll M=1e9+7;

int t;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		ll n,l,ans=0;
		cin>>n>>l;
		//特判 n 等于 1 的情况 
		if(n==1){
			cout<<0<<endl;
			continue;
		} 
		ll k=l>>1;
		ll mx=1ll<<50;
		// mx 调整到 n 的最高位 
		while(mx>n)	
			mx=mx>>1;
		// mx 的每一位取到最大值，求和即为答案 
		while(mx){
			ans+=mx*(l-k)*k;
			ans=ans%M;
			mx=mx>>1;		
		}
		cout<<ans<<endl;
	}
	
	return 0;
}

```

---


# [CSP-S2020] 动物园

## 题目描述

动物园里饲养了很多动物，饲养员小 A 会根据饲养动物的情况，按照《饲养指南》购买不同种类的饲料，并将购买清单发给采购员小 B。 

具体而言，动物世界里存在 $2^k$ 种不同的动物，它们被编号为 $0 \sim 2^k - 1$。动物园里饲养了其中的 $n$ 种，其中第 $i$ 种动物的编号为 $a_i$。

《饲养指南》中共有 $m$ 条要求，第 $j$ 条要求形如“如果动物园中饲养着某种动物，满足其编号的二进制表示的第 $p_j$ 位为 $1$，则必须购买第 $q_j$ 种饲料”。其中饲料共有 $c$ 种，它们从 $1 \sim c$ 编号。本题中我们将动物编号的二进制表示视为一个 $k$ 位 01 串，第 $0$ 位是最低位，第 $k - 1$ 位是最高位。 

根据《饲养指南》，小 A 将会制定饲料清单交给小 B，由小 B 购买饲料。清单形如一个 $c$ 位 $01$ 串，第 $i$ 位为 $1$ 时，表示需要购买第 $i$ 种饲料；第 $i$ 位为 $0$ 时，表示不需要购买第 $i$ 种饲料。 实际上根据购买到的饲料，动物园可能可以饲养更多的动物。更具体地，如果将当前未被饲养的编号为 $x$ 的动物加入动物园饲养后，饲料清单没有变化，那么我们认为动物园当前还能饲养编号为 $x$ 的动物。

现在小 B 想请你帮忙算算，动物园目前还能饲养多少种动物。

## 说明/提示

**【样例 #1 解释】**

动物园里饲养了编号为 $1, 4, 6$ 的三种动物，《饲养指南》上的三条要求为：

1. 若饲养的某种动物的编号的第 $0$ 个二进制位为 $1$，则需购买第 $3$ 种饲料。
2. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $4$ 种饲料。
3. 若饲养的某种动物的编号的第 $2$ 个二进制位为 $1$，则需购买第 $5$ 种饲料。 

饲料购买情况为：

1. 编号为 $1$ 的动物的第 $0$ 个二进制位为 $1$，因此需要购买第 $3$ 种饲料；
2. 编号为 $4, 6$ 的动物的第 $2$ 个二进制位为 $1$，因此需要购买第 $4, 5$ 种饲料。 

由于在当前动物园中加入一种编号为 $0, 2, 3, 5, 7, 8, \ldots , 15$ 之一的动物，购物清单都不会改变，因此答案为 $13$。

**【数据范围】**

对于 $20 \%$ 的数据，$k \le n \le 5$，$m \le 10$，$c \le 10$，所有的 $p_i$ 互不相同。  
对于 $40 \%$ 的数据，$n \le 15$，$k \le 20$，$m \le 20$，$c \le 20$。  
对于 $60 \%$ 的数据，$n \le 30$，$k \le 30$，$m \le 1000$。  
对于 $100 \%$ 的数据，$0 \le n, m \le 10^6$，$0 \le k \le 64$，$1 \le c \le 10^8$。

## 样例 #1

### 输入

```
3 3 5 4
1 4 6
0 3
2 4
2 5```

### 输出

```
13```

## 样例 #2

### 输入

```
2 2 4 3
1 2
1 3
2 4```

### 输出

```
2```

## 样例 #3

### 输入

```
见附件中的 zoo/zoo3.in```

### 输出

```
见附件中的 zoo/zoo3.ans```

# 题解

## 作者：Alex_Wei (赞：114)

upd on 2020.11.17：修正一个错误。

[题目传送门](https://www.luogu.com.cn/problem/P7076)。

先开一个数组 $buc_j$ 表示是否有 $a_i$ 的第 $j$ 位上是 $1$。

又看到题目中保证 $q_i$ 互不相同，所以一旦出现 $p_i,q_i$ 满足 $buc_{p_i}=0$，那么这一位就不能选，因为当前买的饲料中必定没有 $q_i$。

不妨设剩下来 $bit$ 位，那么这 $bit$ 位既可以是 $0$ 也可以是 $1$，共有 $2^{bit}$ 种动物，减去现有的 $n$ 种动物即可。

注意要特判 $bit=64,n=0$ 的情况。读入量较大，建议写快读。

此外 $buc$ 数组可以用 unsigned long long 变量代替，这样就做到了时间 $O(n+m)$，空间 $O(1)$。

非考场代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ull unsigned long long
#define gc getchar()

inline ull rd(){
	ull x=0; char s=gc;
	while(!isdigit(s))s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+s-'0',s=gc;
	return x;
} ull n,m,c,k,ans,lim,hv;

int main(){
	n=rd(),m=rd(),c=rd(),k=rd();
	for(int i=1;i<=n;i++)hv|=rd(); // 统计每个位是否有 1
	for(int i=1;i<=m;i++)lim|=1ull<<rd(),rd(); // 统计有限制的位
	for(int i=0;i<k;i++)ans+=!((lim>>i)&1)||((hv>>i)&1); // 如果当前位有 1, 或者没有限制，那么都可以选
	if(ans==64&&!n)puts("18446744073709551616");
	else cout<<(ans==64?-n:(1ull<<ans)-n)<<endl;
	return 0;
}
```

---

## 作者：OMG_wc (赞：79)

~~众所周知，动物园是不需要动物的~~

水题中的水题，稍微分析下就能明白此中的逻辑了。

有一个条件是“所有的 $q_i$ 互不相同”，这意味着饲料是啥都不重要了，$c$ 和 $q_i$ 甚至不用读进来。

注意全程要用`unsigned long long`类型，读入要用`%llu`。

先计算出所有已有的动物编号中，哪些位至少存在一次，显然用`|`运算就行了。

对于每个要求，如果第 $p_i$ 位是存在的，那这种饲料就肯定有了。反之这种饲料是一定没有的，也就是说这一位一定不能为 $1$。

除去一定不能为 $1$ 的位，剩下 $t$ 个位可能为 $1$，那总动物数就能达到 $2^t$，减去已经有的 $n$ 个动物，所以答案是 $2^t-n$。

这里有个坑点：当 $t=64$ 时，如果 $n>0$ ，那 $2^{64}$ 算出来会等于 $0$ ，然后自然溢出是没事的。但是！！！这题的 $n$ 居然会等于 $0$，和题目的第一句话“动物园里饲养了很多动物”显然矛盾。

这时候，只能输出"18446744073709551616”这个字符串了，当然你不需要背下来，只要先输出一个`(unsigned long long)-1` 再加上 $1$ 就行了。 

代码如下，时间复杂度 $O(n+m)$：

```cpp
typedef unsigned long long ULL;
int main() {
    int n, m, c, K;
    scanf("%d%d%d%d", &n, &m, &c, &K);
    ULL flag = 0, g = 0;
    for (int i = 0; i < n; i++) {
        ULL x;
        scanf("%llu", &x);
        flag |= x;
    }
    while (m--) {
        int p;
        scanf("%d%*d", &p);
        if ((flag >> p & 1) == 0) g |= 1ULL << p;
    }
    ULL ans = 1;
    for (int i = 0; i < K; i++) {
        if ((g >> i & 1) == 0) ans <<= 1;
    }
    if (ans == 0 && n == 0) {
        puts("18446744073709551616");
        return 0;
    }
    ans -= n;
    printf("%llu\n", ans);
    return 0;
}
```


---

## 作者：StudyingFather (赞：52)

先找出所有被至少一个动物编号覆盖（即存在一个编号使该位值为 $1$）的二进制位。

如果某个二进制位对应一种饲料，但该位没有被现有的动物覆盖，则新增的动物编号不能覆盖该位（否则会导致出现新的饲料类型）。

假如最后有 $x$ 位可以被覆盖，易知最终答案为 $2^x-n$。

实现时需要注意考虑部分边界情况。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
typedef unsigned long long ull;
bool vis[65], disable[65];
int main() {
  // freopen("zoo.in","r",stdin);
  // freopen("zoo.out","w",stdout);
  ios::sync_with_stdio(false);
  int n, m, c, k;
  cin >> n >> m >> c >> k;
  for (int i = 1; i <= n; i++) {
    ull a;
    cin >> a;
    for (int j = k - 1; j >= 0; j--) vis[j] |= (a >> j) & 1;
  }
  for (int i = 1; i <= m; i++) {
    int p, q;
    cin >> p >> q;
    if (!vis[p]) disable[p] = 1;
  }
  int cnt = 0;
  for (int i = 0; i < k; i++)
    if (disable[i]) cnt++;
  if (k - cnt == 64) {
    if (n)
      cout << ull(-n) << endl;
    else
      cout << "18446744073709551616" << endl;
  } else
    cout << (1ull << (k - cnt)) - n << endl;
  fclose(stdin);
  fclose(stdout);
  return 0;
}
```

---

## 作者：囧仙 (赞：4)

## 题目大意

- 有 $n$ 种动物，编号的范围是 $[0,2^{k})$ 。现在有 $c$ 种饲料。

- 有 $m$ 个限制条件。如果存在一个编号的第 $p_i$ 位为 $1$ ，则必须选第 $q_i$ 种饲料。

- 现在告诉你这些动物的编号，询问最多增加多少种动物，使得饲料的情况不变。

- 保证每种动物的编号以及每个限制条件的 $p_i$ 不同。

## 题解

这是本场 $\text{CSP}$ 的实质签到题。~~可见出题人的恶意~~。

显然，对于已有的信息，我们可以将动物的编号进行“或”操作，这样就可以判定有哪些位存在数字 $1$ 了。这时，我们可以知道哪些限制条件被达成，那些限制条件没有被达成。

现在考虑我们可以选择的动物编号的第 $i$ 位。

- 如果已经存在一个动物的编号的第 $i$ 位是 $1$ ，那么可选择的动物编号的第 $i$ 位可以是 $0$ 或 $1$ 。

- 如果不存在一个动物的编号的第 $i$ 位是 $1$ ，并且存在某个限制条件，使得第 $i$ 位是 $1$ 后会增加新的饲料，那么第 $i$ 位只能是 $0$ 。

这样子做比较麻烦，因为复杂度是 $\mathcal O(k\times m)$ 的。我们不妨从限制的角度来看待问题。我们考虑第 $i$ 个限制。

- 如果第 $i$ 个限制已经被达成，那么第 $p_i$ 位可以是 $0$ 或 $1$ 。

- 如果第 $i$ 个限制未达成，并且目前我们没有选择第 $q_i$ 个饲料，那么第 $p_i$ 位只能是 $0$ 。

这样做的复杂度是 $\mathcal O(m)$ 。

我们现在知道了一个合法的动物序号每一位可选择的数字个数，不妨设为 $w$ 。由于我们还要减去已经选择的 $n$ 个动物，因此最终答案为：

$$2^w-n$$

这题有一个小细节要考虑。当 $n=0,w=64$ 时，答案达到了 $2^{64}$ ，会炸 $\text{unsigned long long}$ 。需要特判。

这题还有一个小细节要考虑：如果用 $\text{map}$ 进行总复杂度为 $\mathcal O(n\log n)$ 的判断操作，可能会超时。我们需要更快的做法。

- 该题 $c\le 10^8$ ，空间限制 $128\text{MB}$ 。事实上，如果我们开一个 $10^8$ 大小的 $\text{bool}$ 数组并不会超空间（只会使用 $100\text{MB}$） 。

- 如果我们用 $\text{bitset}$ ，或者单纯地压位，也可以压缩空间为 $\frac{100}{8} \text{MB}$ 。

- 此外，还可以使用哈希表（拉链法或者探查法都可以）。这样做的空间复杂度是 $\mathcal O(s+n)$ ，其中 $s$ 是哈希表大小；单次操作的复杂度近似为 $\mathcal O(1)$ ，可以通过本题。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef unsigned int u32;
typedef long long    i64;
typedef unsigned long long u64;
u64 qread(){
	u64 r=0,w=1,c=0;
	for(c=getchar();!isdigit(c);c=getchar()) w=(c=='-'?-1:1); r=c-'0';
	for(c=getchar(); isdigit(c);c=getchar()) r=r*10+c-'0';
	return r*w;
}
const int MAXN =1e6+3;
u64 s,ss,n,m,c,k,f=0,A[MAXN],B[MAXN],ans=1;
const int SIZ =999997;
int ver[MAXN],nxt[MAXN],head[SIZ],tot;
void add(int a,int b){
    ver[++tot]=b,nxt[tot]=head[a],head[a]=tot;
}
bool fnd(int a){
    for(int p=head[a%SIZ];p;p=nxt[p])
    if(ver[p]==a) return true; return false;
}
int main(){
	n=qread(),m=qread(),c=qread(),k=qread();
	up(1,n,i){u64 w=qread(); s|=w;}
	up(1,m,i) A[i]=qread(),B[i]=qread();
	up(1,m,i){
		u64 a=A[i],b=B[i]; if(s&(1ull<<a)) add(b%SIZ,b);
	}
	up(1,k,i) ss|=1<<i-1;
	up(1,m,i){
		u64 a=A[i],b=B[i]; if(!fnd(b)) ss&=~(1ull<<a);
	}
	up(1,k,i) if(ss&(1ull<<i-1)) ans<<=1,++f;
	if(f==64&&n==0) puts("18446744073709551616");
	else printf("%llu\n",ans-n);
	return 0;
}
```

---

## 作者：PrincessQi (赞：4)

作为一个 T2 ，这题算良心的了，~~尤其是在T1的衬托下~~。

对于已有的动物，我们可以把动物的编号都“或”起来，这样可以确定要买哪些饲料。

然后对于每一条要求，我们查看它是否需要满足，若需要，就把这个条件对应的饲料记录下来。

接下来为了方便描述，我们把每个二进制位置和饲料看成点，把每个限制条件看成饲料到二进制位置的边。

所以我们统计每个位置的入度，然后把每个符合条件的二进制位置的入度减掉，最后看看有多少二进制位置的入度是 $0$ ，这个题就差不多了。

注意，最后的答案要减掉 $n$ 个原来就有的动物。

还有，记得特判 $k=64$，$m,n$ 都为 $0$ 的情况。

我用的是 map ，所以卡了不少常数。

```
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
int ans,anss,n,m,gl,c,k,a,p,x,tot;
signed y[1000005],rd[1000005];
vector<signed>qwq[1000005];
map<int,signed>mp;
const signed MAXSIZE=1<<20;
inline char gc(){
    static char In[MAXSIZE],*at=In,*en=In;
    if(at==en){
        en=(at=In)+fread(In,1,MAXSIZE,stdin);
    }
    return at==en?EOF:*at++;
}
inline int read(){
    char c;
    while(c=gc(),!(c>='0'&&c<='9')&&c!='-'){}
    bool f=c=='-';
    int x=f?0:c-'0';
    for(c=gc();c>='0'&&c<='9';c=gc()){
        x=(x<<3)+(x<<1)+c-'0';
    }
    return f?-x:x;
}

inline int ksm(int x,int y){
	int ans=1;
	for(int i=1;i<=y;i++)
		ans*=x;
	return ans;
}
signed main(){
	//freopen("zoo.in","r",stdin);
	//freopen("zoo.out","w",stdout);
	n=read();
	m=read();
	c=read();
	k=read();
    if(k==64&&n==0&&m==0){
        puts("18446744073709551616");
        return 0;
    }
	for(int i=1;i<=n;i++)
		a=read(),ans|=a;
	for(int i=1;i<=m;i++){
		p=read();
		x=read();
		if(mp[x]==0)mp[x]=++tot;
		x=mp[x];
		if(ans>>p&1)y[++gl]=x;
		rd[p]++;
		qwq[x].push_back(p);
	}
	for(int i=1;i<=gl;i++)
		for(int j=0;j<qwq[y[i]].size();j++)
			rd[qwq[y[i]][j]]--;
	for(int i=0;i<k;i++)
		if(rd[i]==0)anss++;
	printf("%llu\n",ksm(2,anss)-n);
	return 0;
}

```

---

## 作者：asdfo123 (赞：3)

2020.11.14 Update 修改了容斥式子的错误和一些语病，感谢＠LSG_waterf



------------
# P7076 动物园 题解

看到各位大佬都直接 $2^x - n$ ，萌新瑟瑟发抖，我来讲一个我考场上想出来的方法吧。。。

这是一个容斥的方法

其实也跟各位的思路没啥区别，只不过各位都求的是能覆盖的位置，我是求不能覆盖的位置而已。。在组合数学的意义下其实是一样的。。。

思路：

首先处理出所有动物的二进制编号的并，存到ans里

```cpp
	for(int i = 1;i <= n;i++)
	{
		a[i] = read();
		ans |= a[i];
	}
```
之后看每个饲料，我们稍加思考可以看出，这里的 $c$ 和
$q_i$ 是没有用的（想到这点的我考场上一脸蒙。。。）

我们对于所有饲料要覆盖的位数，如果这一位 $ans$ 没有，那么就把不能覆盖的位置 $sum++$，注意$p_i$ 可能相同，但只能加一次，开一个数组记录一下

```cpp
ll sum = 0;
for(ll i = 1;i <= m;i++)
{
	p[i] = read();
	if(!cnt[p[i]]) 
	{
		//printf("%d",1<<p[i]);
		if(((1ull<<p[i])&ans)==0) sum++;
		cnt[p[i]] = 1;
	}
	q[i] = read();
}
```

然后就是处理出我们不能覆盖的所有情况 $anss$ 了。

我们思考，有多少不能覆盖的情况呢？

如果$sum==1$ ，我们固定一位，这一位为1的所有情况都不能覆盖，那么显然有 $2^{k-1}$种情况

如果$sum==2$呢？

我们固定1位的情况不能放

那么答案加上$ \tbinom{sum}{1} * 2^{k-1}$

固定2位的呢？

我们显然不能加了，因为第一次的情况中我们算重了。

我们要减去$ \tbinom{sum}{2} * 2^{k-2}$

其实吧，这个也不是我硬想出来的，而是搞了几个样例推出来的，考场上想不出来推样例非常重要。。。

现在我们基本上看出来了，这是个容斥！！

我们写出最后的式子

$$
anss = \sum_{i=1}^{sum} \ \ (-1)^{i-1}\times\tbinom{sum}{i}\times2^{k-i}
$$

现在我们统计出了不能覆盖的位置，那么能覆盖的位置就是
$$
2^{k}-anss
$$

别忘了，我们这些能覆盖的位置有一些已经有动物了，我们再把动物数量减去

最后答案：

$$
2^{k}-anss-n
$$

附上代码

```cpp
#include <bits/stdc++.h>
#define ll unsigned long long
using namespace std;
ll p[1000100],q[1000100];
ll a[1000100];
ll cnt[70];
ll zh[70][70];
ll read()
{
	ll a = 1,sum = 0;
	char ch = getchar();
	while(ch<'0'||ch>'9') 
	{
		if(ch == '-') a = -1;
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		sum = sum*10 + ch - '0';
		ch = getchar();
	}
	return a*sum;
}
void jc()
{
	zh[0][0] = 1;
	for(ll i = 1;i <= 65;i++) zh[i][0] = 1;
	for(ll i = 1;i <= 65;i++)
	{
		for(ll j = 1;j <= i;j++)
		{
			zh[i][j] = zh[i-1][j]+zh[i-1][j-1];
		}
	}
}
int main()
{
	jc();
	ll n = read();
	ll m = read();
	ll c = read();
	ll k = read();
	ll ans = 0;
	for(ll i = 1;i <= n;i++)
	{
		a[i] = read();
		ans |= a[i];
	}
	ll sum = 0;
	for(ll i = 1;i <= m;i++)
	{
		p[i] = read();
		if(!cnt[p[i]]) 
		{
			//printf("%d",1<<p[i]);
			if(((1ull<<p[i])&ans)==0) sum++;
			cnt[p[i]] = 1;
		}
		q[i] = read();
	}
	ll anss = 0;
	//printf("%lld\n",sum);
	for(ll i = 1;i <= sum;i++)
	{
		if(i&1) anss += zh[sum][i]*(1ull<<(k-i));
		else anss -= zh[sum][i]*(1ull<<(k-i));
	}
	if(n==0&&m==0&&k==64) printf("18446744073709551616\n");
	else if(k==64)
	{
		printf("%llu\n",(1ull<<63) - anss - n+(1ull<<63));
	}
	else printf("%llu\n",(1ull<<k) - anss - n);
	return 0;
}
```

一些注意：
- 看到64，想到unsigned long long，而且1<<k也要变成1ull<<k
                                              
- 1<<64 是UB（未定义行为）
       
我们改成```(1ull<<63) - anss - n+(1ull<<63)```就好了
                                 
                                
- n = 0, m= 0,k = 64的时候会炸unsigned long long（就离谱），要特判一下
                                             
一些可能存在的错误：
                                 
在unsigned long long 情况下我的anss可能减到负数？这样的话其实用long long也行，最后再类型转换一下
                                             
                                
                                             
                                             
                                                                                          
望采纳！！！
                                          
                                 
                   

---

## 作者：RyexAwl (赞：2)

## 题意
给出一个$n$个数构成的序列,$a[1],a[2],a[3]...a[n]$。

给出$m$个需求，对于第$1\le i\le m$个需求$p_i,q_i$，表示如果在序列$a$中,如果存在$a[j],1\le j\le n$在二进制表示下的第$p_i$位为$1$，则需要在集合$S$中添加元素$q_i$。

给定一个$k$，求出从$0-2^k-1$中，除了序列$a$中的数最多可以选多少个数放入序列$a$保证集合$S$内的元素不变。

## 分析
考虑转化为补集：合法方案 = 总方案 - 不合法方案

考虑如何计算出不合法的方案。

令$f[i]$为二进制构成不超过$i$位的数中，不满足要求的数的个数。

考虑如何划分状态以便转移。

以第$i$是$0$还是$1$分类讨论：

如果第$i$位是$0$，其方案数显然为$f[i-1]$

考虑第$i$位是$1$的情况：

如果第$i$位为$1$要选的元素已经在集合内，那么方案数为$f[i-1]$

如果第$i$位为$1$要选的元素不在集合内，则方案数为$2^i$。

因此可以得到状态转移方程

$$
f[i]=f[i-1]+(f[i-1]/2^i)
$$

此步的复杂度为$O(c)$（$c$为$q$的种数）

最后的方案数即$2^k-f[k-1]-n$。

预处理出集合$S$，之后跑一遍$DP$即可$AC$本题

代码:
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <cstdio>

namespace wxy{
		__int128 f[65];
		unsigned long long b[1000005];
		bool vis[100000005];
		bool vs[65];
		std::vector<int> a[65];
		int n,m,c,k;
		typedef std::pair<int,int> PII;
		PII q[1000005];
		void print(__int128 x){
            if(x<0)putchar('-'),x=-x;
            if(x>9)print(x/10);
            putchar(x%10+'0');
        }
        __int128 ppp;
        void init(){
            ppp = 1;
            for (int i = 1; i <= 64; i++) ppp *= 2;
        }
		void main(){
			memset(vis,false,sizeof vis);
			memset(vis,false,sizeof vs);
			memset(f,0,sizeof f);
			std::cin >> n >> m >> c >> k;
			init();
			for (int i = 1; i <= n; i++) scanf("%lu",&b[i]);
			for (int i = 1; i <= m; i++){
					std::cin >> q[i].first >> q[i].second;
					a[q[i].first].push_back(q[i].second);
			}
			for (int i = 1; i <= n; i++){
			    for (int j = k; j >= 0; j--)
			        if (b[i] >> j & 1) vs[j] = true;
			}
			bool pop[1000005];
			for (int i = 1; i <= m; i++){
			    if (vs[q[i].first] && !pop[q[i].first]){
			        for (int j = 0; j < a[q[i].first].size(); j++) vis[a[q[i].first][j]] = true;
			    }
			    pop[q[i].first] = true;
			}
			for (int i = 0; i <= k; i++){
				if (i != 0) f[i] = f[i - 1];
				bool ck = false;
				for (int j = 0; j < a[i].size(); j++){
					if (!vis[a[i][j]]){
					    __int128 www;
					    if (i < 64)www = 1ull * 1 << i;
					    else www = ppp;
						f[i] = f[i] + www;
                        ck = true;
						break; 
					}
				} 
                if (!ck && i != 0) f[i] = f[i] + f[i - 1];
			}	
	        __int128 a;
	        if (k < 64) a = 1ull * 1 << k;
	        else a = ppp;
	        __int128 pppp = n;
	        print(a - f[k - 1] - pppp);
		}
}signed main(){wxy::main();return 0;}
```


---

## 作者：Piwry (赞：2)

今年实质上的签到题；

```cpp
/*V- 注意返回类型*/
int read(){
	ull x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}
```

然而大样例没给我测出这个错误...成功送走我 40 分 \fad

## 解析

直到写这篇题解时我才发现把题面看漏了...

先讲下原题意怎么做。由于**保证 $q_i$ 互不相同**，因此不同位需要的饲料集合实际上是没有交集的。因此我们只需统计每个（二进制）位是否在已有的动物中出现过，或者该位**没有饲料要求**，就能得到可以自由选择的位的数量 $\texttt{cnt}$。最后答案就是 $2^{\texttt{cnt}}-n$（即已有饲料能养的动物的数量，减掉已有的动物的数量）

然而考场上我没注意到 “保证 $q_i$ 互不相同”，因此最后代码写得很复杂...

具体来说，由于不保证 $q_i$ 互不相同，因此可能会有在已有动物中没出现，且**有饲料要求**的位可以 “顺便” 选。于是我们先离散化饲料，然后数组记录每个饲料是否出现，最后再对每个位扫一遍和该位有关的饲料列表，就能统计出可以自由选择的位的数量了

实现时，可以给每位开一个 `vector` 储存该位关联的饲料列表

另外还有两个坑点：一个是 $k=0$ 的时候可能需要特判。另一个是 $2^{64}$ 会炸 `ull`；处理也不难，可参考代码尾部的 `if`

## CODE

我考场上的做法：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#define ll long long
#define ull unsigned ll
using std::vector;
using std::sort;

/*------------------------------IO------------------------------*/

ull read(){
	ull x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}

void write(const ull &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

/*------------------------------Main------------------------------*/

const int MAXN =1e6+20;

bool vis[MAXN];

struct qwq{
	int p, col;
	
	qwq(){}
	qwq(const int &P, const int &COL):p(P), col(COL){}
}arr[MAXN];
int tot;

bool cmp(const qwq &A, const qwq &B){
	return A.col < B.col;
}

vector<int> dig[64];

void work(){/*离散化*/
	sort(arr, arr+tot, cmp);
	int CNT =0;
	for(int i =0; i < tot; ++i){
		if(i != 0){
			if(arr[i].col != arr[i-1].col)
				++CNT;
		}
		dig[arr[i].p].push_back(CNT);
	}
}

int main(){
//	freopen("zoo.in", "r", stdin);
//	freopen("zoo.out", "w", stdout);
	int n =read(), m =read(), c =read(), k =read();
	ull nw =0;
	for(int i =0; i < n; ++i){
		ull a =read();
		nw |=a;
	}
	for(int i =0; i < m; ++i){
		int p =read(), q =read();
		arr[tot++] =qwq(p, q);
	}
	work();
	int cnt =0;/*放置后不会产生新饲料贡献的位的数量*/
	for(int i =0; i < k; ++i)
		if((nw&(1ull<<i)) != 0){
			for(int j =0; j < (int)dig[i].size(); ++j)
				vis[dig[i][j]] =1;
			++cnt;
		}
	for(int i =0; i < k; ++i)
		if((nw&(1ull<<i)) == 0){
			bool flg =1;
			for(int j =0; j < (int)dig[i].size(); ++j)
				if(!vis[dig[i][j]]){
					flg =0;
					break;
				}
			if(flg)
				++cnt;
		}
	if(k == 0)/*<<- */
		printf("0");
	else if(cnt == 64){
		if(n == 0)
			printf("18446744073709551616");
		else
			write((~0ull)-(n-1));
	}
	else{
		ull qaq =1;
		write((qaq<<cnt)-n);
	}
	putchar('\n');
	return 0;
}
```

简短些的做法：

```cpp
#include <cstdio>
#define ll long long
#define ull unsigned ll

/*------------------------------IO------------------------------*/

ull read(){
	ull x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}

void write(const ull &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

/*------------------------------Main------------------------------*/

bool require[64];

int main(){
//	freopen("zoo.in", "r", stdin);
//	freopen("zoo.out", "w", stdout);
	int n =read(), m =read(), c =read(), k =read();
	ull nw =0;
	for(int i =0; i < n; ++i){
		ull a =read();
		nw |=a;
	}
	for(int i =0; i < m; ++i){
		int p =read(), q =read();
		require[p] =1;
	}
	int cnt =0;/*哪一位放置后不会产生新饲料贡献*/
	for(int i =0; i < k; ++i)
		if((nw&(1ull<<i)) != 0 || !require[i])
			++cnt;
	if(k == 0)/*<<- */
		printf("0");
	else if(cnt == 64){
		if(n == 0)
			printf("18446744073709551616");
		else
			write((~0ull)-(n-1));
	}
	else{
		ull qaq =1;
		write((qaq<<cnt)-n);
	}
	putchar('\n');
}
```

---

## 作者：qhr2023 (赞：1)

## solution

位运算模拟题。

先求已被动物编号覆盖的二进制位，为了不出现新饲料，新动物编号不能覆盖一个没被现有动物编号覆盖的位，对于一个位，当它已被覆盖或没有限制则可以选。设最后剩 $a$ 位可以覆盖，答案就是 $2^a - n$ 种。

答案可能很大，这里开了 int128。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, c, k;
__int128 lim, hav, ans;
__int128 read () {
	__int128 X = 0;
	char ch=0;
	while(!isdigit(ch)) 
		ch=getchar();
	while(isdigit(ch)) 
		X=(X<<3)+(X<<1)+(ch^48),
		ch=getchar();
	return X;
}
void put (__int128 x) { 
	if (!x)
		return ;
	put(x/10);
	putchar(x%10+'0');
}
int main () {
	cin >> n >> m >> c >> k;
	for (int i=1; i<=n; ++i)
		hav|=read();
	for (int i=1; i<=m; ++i)
		lim|=(__int128)1<<read(),
		read();
	for (int i=0; i<k; ++i)
		ans+=!((lim>>i)&1)||((hav>>i)&1);
	ans=((__int128)1<<ans)-n;
	if (!ans)
		puts("0");
	else
		put(ans);
	return 0;
}
```

---

## 作者：JOKER_chu (赞：1)

题意很容易理解，直接上解法。

观察一下发现，能添加的动物数量和**饲料按位或和**有关，将这个和为 $1$ 的地方抠出来，设为 $sum$ 个 `1`，答案很容易看出，即为 $2^{k - sum}$，但是并不是对的，因为本来就有 $n$ 种动物，最终答案要减去 $n$，代码要注意最终答案可达到 $2^{64}$，使用特判或者 `__int128` 就行了。

```cpp
#include <bits/stdc++.h>

#define int unsigned long long

using namespace std;

int n, m, c, k, ro;

void write( __int128 x ) {
  vector<short> v;
  while (x) {
    v.push_back(x % 10);
    x /= 10;
  }
  reverse(v.begin(), v.end());
  for (auto i : v) {
    cout << i;
  }
}

signed main() {
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> c >> k;
  for (int i = 1, a; i <= n; ++i) {
    cin >> a;
    ro |= a;
  }
  int cnt = 0;
  for (int i = 1, p, q; i <= m; ++i) {
    cin >> p >> q;
    if (!(ro >> p & 1)) {
      cnt |= 1ull << p;
    }
  }
  int ans = 0;
  for (int i = 0; i < k; ++i) {
    ans += cnt >> i & 1;
  }
  if (!ans && k == 64) {
    if (!n) {
      cout << "18446744073709551616";
    } else {
      cout << -n;
    }
  } else {
    write((1ull << k - ans) - n);
  }
  return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P7076)

---
### 思路：
水题中的水题。这题如果放在普及组，可能也就是第二三题。

这题是一道关系进制的问题。

先找出所有被至少一个动物编号覆盖的二进制位。

如果某个二进制位对应一种饲料，但该位没有被现有的动物覆盖，则新增的动物编号不能覆盖该位（否则会导致出现新的饲料类型）。

---
### 代码讲解：
这题有以下几个需要注意的地方。

- 数据范围，需要开到 unsigned 才行。
 ```cpp
unsigned long long n, m, c, k, a, p, q, ans = 0, cnt = 1, g = 0;
```
- 特判程序。这样防止溢出。
```cpp
if (!n && !m && k == 64) {
    printf("18446744073709551616");
    return 0;
} 
```
-  主程序
```cpp
for (int i = 0; i < m; i++) {
		cin >> p >> q;
		if (!((g >> p) & 1) && !v[p]) {
			ans--;
			v[p] = 1;
		} 
	}
```

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

unsigned long long n, m, c, k, a, p, q, ans = 0, cnt = 1, g = 0;
bool v[65];

int main() {
	cin >> n >> m >> c >> k; 
	ans = k;
	if (!n && !m && k == 64) {
		printf("18446744073709551616");
		return 0;
	} 
	for (int i = 1; i <= n; i++) {
		cin >> a;
		g |= a;
	}
	for (int i = 0; i < m; i++) {
		cin >> p >> q;
		if (!((g >> p) & 1) && !v[p]) {
			ans--;
			v[p] = 1;
		} 
	}
	for (int i = 1; i <= ans; i++) cnt *= 2;
	printf("%llu\n", cnt - n);
	return 0;
}

```

---

## 作者：_H17_ (赞：0)

## 题目分析

一种动物由一个二进制串表示，可以理解为每一位是一个条件。如果是 $1$ 表示需要满足，$0$ 表示都可以。

所以我们把 $a_1\sim a_n$ 进行或运算（记为 $x$），最后就是所有动物园可以满足的条件（当然有些位置不对应饲料，但是不影响可以忽略）。

然后我们遍历所有 $p$（显然这也是二进制位编号），如果动物园满足条件标记上。$q$ 各不相同，所以没用。

对于每一位，没对应饲料（没作为 $p$ 出现）或者满足条件（这一位在 $x$ 中是 $1$）是 $0,1$ 的动物都可以；其他情况只能是 $0$（满足不了）。这样可以轻松求出总共可以供养的动物数。

最后答案就是总共可以供养的减去现在已有的。

**注意：$k=64$ 时超过了 C++ 的 `long long` 的范围，可以特判或者使用 `__int128`**。~~高精度也不是不行。~~

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
constexpr int N=1000001;
int n,m,c,k,vis[N],mention[N];
__int128 tot,ans=1;
void write(__int128 a){
	vector<int>vec;
	do{
		vec.push_back(a%10);
		a/=10;
	}while(a);
	for(int i=vec.size()-1;i>=0;i--)
		cout<<vec[i];
	cout<<'\n';
}
signed main(){
	cin>>n>>m>>c>>k;
	for(int i=1,t;i<=n;i++){
		cin>>t;
		tot|=t;//求或
	}
	for(int i=1,p,q;i<=m;i++){
		cin>>p>>q;
		if((tot>>p)&1)
			vis[p]=1;//存在
		mention[p]=1;//出现了
	}
	for(int i=0;i<k;i++)
		if(vis[i]||!mention[i])//都可以
			ans*=2;
	write(ans-n);
	return 0;
}
```

---


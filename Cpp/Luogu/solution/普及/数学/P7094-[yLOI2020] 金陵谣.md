# [yLOI2020] 金陵谣

## 题目背景

> 水几绕，山几重，何处金陵城。   
> 访名都，寻形胜，龙虎倚江东。   
> 书留翰墨，曲落潮声。   
> 草木几度枯荣。

——银临《金陵谣》

## 题目描述

江苏南京，亦称金陵，是一座历史文化名城。有了古城的衬托，江苏省的高考模拟题都显地那么棘手，难以解决。切切在一轮复习过程中便碰到一道江苏省模拟题，在七瑾的帮助下，切切很快秒杀了该题，但切切觉得不够，想用这道题来刁难你。解决本题就能吃到切切和七瑾撒的糖。

给定四个正整数 $a, b, c, d$，求有多少对正整数 $(x, y)$ 满足

$$\frac a x + \frac b c = \frac d y$$

## 说明/提示

### 样例 1 解释

求 $\frac 1 x + \frac 1 3 = \frac 2 y$ 的正整数解对数，分别是 $(x = 3, y = 3)$，$(x = 6, y = 4)$，$(x = 15, y = 5)$。

### 数据规模与约定

本题共有 20 个测试点，每个测试点 $5$ 分。

- 对于测试点 $1$，保证 $T = 0$。
- 对于测试点 $2 \sim 16$，共 $15$ 个测试点，对于 $a, b, c, d$ 四个数中至少存在一个数为 $1$ 共有 $15$ 种情况，每个测试点对应一种情况。
- 对于测试点 $17 \sim 20$，没有特殊约定。

对于全部的测试点，保证 $0 \leq T \leq 20$，$1 \leq a, b, c, d \leq 10^6$，$d \times c \leq 10^6$。

### 提示

+ 众所周知，高考不考数论。
+ 本题共有两个样例文件，见附加中的 song.zip。

## 样例 #1

### 输入

```
1
1 1 3 2```

### 输出

```
3```

# 题解

## 作者：一只书虫仔 (赞：17)

yLOI 2020 A 前排膜拜扶咕咕

#### Description

> 给定 $a,b,c,d$，求有多少组正整数 $x,y$ 满足：
> $$\dfrac{a}{x}+\dfrac{b}{c}=\dfrac{d}{y}$$

#### Solution

~~这个第一个测试点是什么鬼~~          
$T=0$ ~~直接放空程序 $5$ 分就到手了~~

爆推柿子：

$$\begin{aligned}\dfrac{a}{x}+\dfrac{b}{c}=\dfrac{d}{y}&\to\dfrac{ac}{cx}+\dfrac{bx}{cx}=\dfrac{d}{y}\\&\to \dfrac{ac+bx}{cx}=\dfrac{d}{y}\\&\to dcx=y(ac+bx)\\&\to dcx=acy+bxy\\& \to dcx-bxy=acy\\& \to (dc-by)x=acy\end{aligned}$$

既然要保证 $x,y$ 是正整数，那么就需要保证 $dc>by$，也就是：

$$\begin{aligned}dc>by &\to by<dc\\&\to y<\dfrac{dc}{b}\end{aligned}$$

也就是说，框定了 $y$ 的枚举范围 $\left[1,\dfrac{dc}{b}\right)$，然后进行，枚举即可。

---

## 作者：一扶苏一 (赞：15)

## A

本题来源于江苏一道模拟题。原题是给定序列 $c_i = \frac 1 i$，求有多少对 s，t 满足 $c_3, c_s, c_t$ 构成等差数列。

前 $16$ 个点可以随便乱搞，考察选手推式子的能力。

值得注意的是，如果 $b \gt c$ 并且 $d = 1$，那么式子显然无解。因此，作为一道签到题，输出一排$0$可以得到 $25$ 分的好成绩。

本题大概唯一的难点在于看到正整数直接考虑数论做法然后误入歧途。经过提示排除，我们直接推式子。

$$\frac a x + \frac b c = \frac d y \Rightarrow \frac{ac + bx}{cx} = \frac d y \Rightarrow dcx = acy + bxy \Rightarrow dcx - bxy = acy \Rightarrow x(dc - by) = acy$$

之所以会有 $dcx = acy + bxy \Rightarrow dcx - bxy=acy$ 这一步是我们考虑题目限制看起来像是个枚举条件，而我们要进行枚举需要构造出一个减法的形式来，才能确定枚举的范围，因此考虑项，加法变减法。

注意到变量都是正整数，因此 $acy$ 是正整数，$x$ 是正整数，因此 $(dc - by)$ 是正整数。因此 $by \lt dc$，即 $y \lt \frac{dc} b$。由此确定了 $y$ 的枚举范围，枚举即可。时间复杂度 $O(dc)$。

```cpp
#include <iostream>

typedef long long int ll;

ll a, b, c, d, T;

int main() {
  for (std::cin >> T; T; --T) {
    std::cin >> a >> b >> c >> d;
    int ans = 0;
    for (ll lim = c * d / b, y = 1; y <= lim; ++y) {
      ll u = a * c * y, v = c * d - b * y;
      if (v <= 0) continue;
      if ((u % v) == 0) ++ans;
    }
    std::cout << ans << std::endl;
  }
  return 0;
}
```



---

## 作者：Scintilla (赞：10)

### 算法一

时间复杂度：$O(\frac{cd}b)$，便于观察和实现。

两边同乘 $cy$，把式子变形为 $acy = x(cd - by)$。因为 $x, y$ 是正整数，所以 $by \leq cd \leq 10^6$，枚举 $y$ 即可。

```cpp
ll a, b, c, d;
int main() {
    int T = read();
    while (T--) {
        a = read(), b = read(), c = read(), d = read(); int cnt = 0;
        for (ll i = 1; b * i < c * d; ++i) {
            if (!((i * a * c) % (c * d - b * i))) ++cnt;
        }
        printf("%d\n", cnt);
    }
    return 0;
}
```

### 算法二

时间复杂度：$O(\operatorname{d}(ac^2d))$，即 $ac^2d$ 的约数个数，效率较高，且不受 $cd$ 的约束。

两边同乘 $xybc$，得到

$$abcy + b^2xy - bcdx = 0$$

$$(bx + ac)(by - cd) + ac^2d = 0$$

于是枚举 $ac^2d$ 的约数，判断有解与否即可。

```cpp
ll a, b, c, d;
ll tot, pri[100010], cs[100010]; // 质因数个数、质因数、质因数次数

il void calc(ll x) { // 分解质因数
    for (ll i = 2; i * i <= x; ++i) {
        if (x % i) continue;
        pri[++tot] = i, cs[tot] = 0;
        while (!(x % i)) ++cs[tot], x /= i;
    }
    if (x > 1) pri[++tot] = x, cs[tot] = 1;
}

ll S; int cnt;
void dfs(int now, ll tp) {
    if (now == tot + 1) {
        ll p = tp, q = S / tp; q = -q;
        if (p <= a * c || q + c * d <= 0) return; // 保证结果为正
        if ((p - a * c) % b || (q + c * d) % b) return; // 保证结果为整
        ++cnt; return;
    }
    ll temp = 1;
    Rep(i, 0, cs[now]) {
        dfs(now + 1, tp * temp);
        temp *= pri[now];
    }
}

int main() {
    int T = read();
    while (T--) {
        a = read(), b = read(), c = read(), d = read(); cnt = 0, tot = 0;
        S = a * c * c * d, calc(S), dfs(1, 1);
        printf("%d\n", cnt);
    }
    return 0;
}
```

---

## 作者：Eason_AC (赞：7)

## Content
有 $t$ 组询问，每组询问给定四个整数 $a,b,c,d$，请求出满足

$$\dfrac{a}{x}+\dfrac{b}{c}=\dfrac{d}{y}$$ 

的正整数对 $(x,y)$ 的个数。

**数据范围：$0\leqslant t\leqslant 20,1\leqslant a,b,c,d\leqslant 10^6,d\times c\leqslant 10^6$。**
## Solution
提示性很强的一道题目。

我们先来尝试化简一下这个式子：

两边同时乘以 $xcy$，得 $acy+bxy=dcx$。  
把含有 $x$ 的项移到左边，得到 $bxy-dcx=-acy$  
整理可得 $(dc-by)x=acy$  
$\therefore x=\dfrac{acy}{dc-by}$

化简到这里应该可以明白了：我们从小到大枚举 $y$，看是否有 $acy\mod(dc-by)=0$，如果满足的话必然会存在整数 $x$。

下界显然是 $1$，但是如何确定 $y$ 枚举的上界呢？

让我们再来看看题目：

> ……满足 $\dfrac{a}{x}+\dfrac{b}{c}=\dfrac{d}{y}$ 的**正整数**对 $(x,y)$ 的个数。

> ……$1\leqslant a,b,c,d\leqslant 10^6$。

是否发现了什么？

题目中限制了 $x,y,a,b,c,d$ 均为正整数！

而又因为 $acy$ 必然是正整数，所以想要让 $x$ 为正整数，必然要满足 $dc-by$ 的结果也是个正整数才行，也就是 $dc-by>0$。

再以 $y$ 为主元化简这个不等式：

$-by>-dc$  
$\therefore y<\dfrac{dc}{b}$。

这下你应该就明白了。

但是！这里会出现一个 bug：当 $\dfrac{dc}{b}$ 的结果是一个整数的时候，枚举的时候就不能够枚举到 $\dfrac{dc}{b}$。理由很容易想通。

所以，我们应当分类讨论一下上界：

- 当 $b\mid dc$ 的时候，上界就是 $\dfrac{dc}{b}-1$。
- 否则，上界就是 $\dfrac{dc}{b}$。

以为我是在胡闹？再看题目：

> ……$d\times c\leqslant 10^6$。 

好的，现在可以保证这样枚举不会爆炸了。于是就可以愉快地枚举了。
## Code
```cpp
int t, a, b, c, d;

int main() {
	t = Rint;
	while(t--) {
		a = Rint, b = Rint, c = Rint, d = Rint;
		int ans = 0;
		F(y, 1, d * c / b - (!((d * c) % b) ? 1 : 0)) {
			if(1ll * d * c - 1ll * b * y == 0) continue; //该行可省略
			if(!((1ll * a * c * y) % (1ll * d * c - 1ll * b * y)))
				ans++;
		}
		printf("%d\n", ans);
	}
	return 0;
}
``` 

---

## 作者：Computer1828 (赞：5)

看到式子和“正整数”的条件，很快就想到应该是枚举某一个数，然后判断另外一个数是否为正整数。

考虑变形等号左边的式子：

$$\dfrac{ac+bx}{cx} = \dfrac{d}{y}$$

$$(ac+bx)y = cdx$$

$$y = \dfrac{cdx}{ac+bx}$$

会发现这样变形用不上限制 $cd \leq 10^6$。

考虑通分：

$$acy+bxy = cdx$$

如果再用 $x$ 来表示 $y$，又会形成上面的错误方法。所以选择用 $y$ 表示 $x$。

$$acy = cdx-bxy$$

$$acy = x(cd-by)$$

$$x = \dfrac{acy}{cd-by}$$

这样就能很好利用 $cd \leq 10^6$ 的条件。现在我们只需要枚举 $y$，判断 $\dfrac{acy}{cd-by}$ 是否为正整数即可，也就是要满足 $cd-by > 0$ 且 $(cd-by) \mid (acy)$。

记得开 `long long`。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t;
int ans;
ll a,b,c,d;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
		for(int y = 1;1ll*y*b<c*d;++y){//判断cd-by>0
			if((a*c*y) % (c*d-b*y) == 0) ans++;//判断是否为整数
		}
		printf("%d\n",ans);
		ans = 0;
	}
	return 0;
}
```

---

## 作者：Cripple_Abyss (赞：4)

## [题目传送门](https://www.luogu.com.cn/problem/P7094)

## STEP 1 大致题意:

- 给定 $4$ 个正整数 ：$a,b,c,d$ 。

- 求有多少对 $x,y$ 满足 $\dfrac{a}{x} + \dfrac{b}{c} = \dfrac{d}{y}$。

## STEP 2 思考过程：
- 我们将这个式子进行变形：

$\dfrac{d}{y} - \dfrac{b}{c} = \dfrac{a}{x}\Rightarrow\dfrac{dc}{yc} - \dfrac{by}{cy} = \dfrac{a}{x}\Rightarrow\dfrac{dc-by}{cy} = \dfrac{a}{x}$

- 交叉相乘得：

$x\left ( dc-by \right ) = acy$

- 易得：

$x=\dfrac{acy}{bc-dy}$

- 可知当 $\left ( bc-dy \right )|\ acy$ 时，$x$ 才有整数解。

## STEP 3 题目解法：
- 我们枚举 $y$。

- 当满足 $\left ( bc-dy \right )|\ acy$ 时，$ans++$。

## STEP 4 Code :
```cpp
#include <cstdio>
int t;
int a, b, c, d, ans;
long long t1, t2, t3;
inline int read()
{
    register int x = 0, f = 1;
    register char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
        x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
    return x * f;
}
inline void write(int x)
{
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
int main()
{
    t = read();
    while (t--)
    {
        ans = 0;
        a = read(), b = read(), c = read(), d = read();
        t1 = 1ll * d * c;
        t3 = 1ll * c * a;
        for (register int x = 1; x <= 1000000; x++)
            if (t1 - b * x > 0 && t3 * x % (t1 - b * x) == 0ll)
                ans++;
        write(ans);
        putchar('\n');
    }
    return 0;
}
```

都看到这里了，点个赞再走呗 QwQ

---

## 作者：A_Đark_Horcrux (赞：2)

> 众所周知，高考不考数论。

好，那我们先化简一下式子。

$\dfrac{a}{x}+\dfrac{b}{c}=\dfrac{d}{c}$

两边同乘以 $cxy$ 得

$acy+bxy=dcx$

化简得 $x=\dfrac{acy}{dc-by},y=\dfrac{dcx}{ac+bx}.$

这样我们就可以枚举 $x$ 和 $y$ 其中一个，判断另一个是不是正整数，如果是的话就计入答案。

接下来的关键在于枚举的范围

$y=\dfrac{dcx}{ac+bx}$ ，看不出什么；

$x=\dfrac{acy}{dc-by}$ ，由 $x\in \textrm{N}^*$ 可以得出 $dc-by >0 $ ，这样我们就得到了枚举的范围。

最后，$1\leq a,b,c,d \leq 10^6$ ，相乘会爆 $int$ ，所以记得开 $long \;long $

上代码

```cpp
#include<cstdio>
using namespace std;
long long T,a,b,c,d,s;//三年OI一场空，不开long long 见祖宗
int main()
{
	scanf("%lld",&T);//数据组数
	while(T--)
	{
		scanf("%lld %lld %lld %lld",&a,&b,&c,&d);//输入a,b,c,d
		for(int y=1;b*y<d*c;y++) s+=((a*c*y)%(d*c-b*y)==0);//枚举
		printf("%lld\n",s); s=0;//输出答案，清零
	}
	return 0;//完结awa
}
```


---

## 作者：dChengx (赞：2)

欢迎在评论区讨论和提问！
------------

题目中已经提示不用数论，那就不用……

题意：

给定$a,b,c,d$，求有多少二元组$(x,y)$使得
$\frac{a}{x}+\frac{b}{c} = \frac{d}{y}$
成立

我们先对式子进行化简：
$$\frac{a}{x}+\frac{b}{c} = \frac{d}{y}$$
同乘$c*x*y$得
$$acy+bxy=dcx$$
观察到题目中说$x,y$都是正整数，那我们移项得
$$x=\frac{acy}{cd-by}$$
因为$x$是正整数，所以有
$$cd>by$$
题目中有$c*d<=1e6$ 那就枚举y判断即可

时间复杂度$O(Tcd)$

Code:
```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll; 
ll a,b,c,d,ans,p,q;
ll read(){
	ll f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while('0'<=ch&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return f*x;
}
int main(){
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	int T=read();while(T--){
		a=read(),b=read(),c=read(),d=read();
		p=a*c,q=c*d;
		ans=0;
		for(ll k=1;b*k<q;k++)
			if(p*k%(q-b*k)==0)
				ans++;
		printf("%lld\n",ans);
	}
	return 0;
}

```
##### PS：当然可以先将$\frac{b}{c}$约分，再代入求值，会跑的快一点，不影响答案。

---

## 作者：SpectatorX (赞：1)

>题意：
>
>给定四个正整数$a,b,c,d$，求有多少对正整数$(x,y)$满足$\frac{a}{x}+\frac{b}{c}=\frac{d}{y}$

本题的要点就在于推式子上，但并不难。

$$\frac{ac+bx}{xc}=\frac{d}{y}$$
$$dcx=acy+bxy$$
$$dcx-bxy=acy$$
$$x(dc-by)=acy$$
$$x=\frac{acy}{dc-by}$$

因为$x,y\in Z^*$，所以我们仅需枚举$y$，使得$\frac{acy}{dc-by}\in Z^*$即可。

时间复杂度$O(t*\frac{dc}{b})$，~~完全能过~~

$Code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,cnt;
long long a,b,c,d;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		cnt=0;
		scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
		for(long long y=1;d*c-b*y>0;++y) if((a*c*y)%(d*c-b*y)==0) cnt++;
		printf("%d\n",cnt);
	}
	return 0;
}
```

---

## 作者：Scrutiny (赞：1)

看到数据范围中 $c\times d\le10^6$ 的限制，不难想到将原式化为：

$$\dfrac{a}{x}=\dfrac{dc-by}{cy}.$$

等式右边显然大于 $0$，因此只需从小到大枚举 $y$，满足 $dc-by>0$ 即可.

进一步变形得到：

$$x=\dfrac{acy}{dc-by}\in\mathbb{Z^+}$$

因此，如果当前的 $y$ 满足 $dc-by\mid acy$，那么就有一组解.统计解的组数即可.

**注意：需要开 `long long`！每次统计完后，`cnt` 不要忘记清零！**

**code:**

```
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,cnt;
int t;
int main(){
	scanf("%d",&t);
	for(int i=1;i<=t;++i){
		cnt=0;
		scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
		for(int y=1;b*y<c*d;++y){
			if((a*c*y)%(c*d-b*y)==0){
				cnt++;
			}
		}
		printf("%lld\n",cnt);
	}
}
```


---

## 作者：Vocanda (赞：1)

# 题目
[题目链接](https://www.luogu.com.cn/problem/P7094)


# 分析
题目大意：\
给出如下柿子：
$$\frac{a}{x} + \frac{b}{c} = \frac{d}{y}$$
给出 $a,b,c,d$ ，然后需要我们求出此方程的正整数解的个数。
如果停留在分式的状态，直接算可能会掉精度，而且貌似看起来不可做~~wtcl~~，所以我们考虑对式子进行推导。

其实也算不上什么推导，我们只需要把所有分母全部乘上去，让原式子变成一个没有分数的式子，我们就可以得到这样的式子:
$$cdx = acy\ +\ bxy$$
我们会发现右边都有 $y$ 这一项，我们把它提出来，用 $x$ 去表示 $y$ 。那么我们可以得到如下式子:
$$y = \frac{cdx}{ac+bx}$$
那么我们就可以枚举 $x$ ，然后判断 $\frac{cdx}{ac+bx}$ 是不是整数即可。\
但是由于 $ac+bx$ 的范围是不确定的，所以 $x$ 的范围并没办法确定，观察到题目中有一个限制条件 $c\times d \leqslant 10^6$ ，我们看到 $x$ 有 $c\times d$ 这个系数，所以我们就可以转化成用 $y$ 来表示 $x$ ：
$$x = \frac{acy}{cd-by}$$
枚举 $y$ 即可。枚举上届可以直接到 $cd-by$ 的最大值。

# 代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
char buffer[1<<20],*p1,*p2;
#define gc (p1 == p2 && (p2 = (p1 = buffer) + fread(buffer,1,1<<20,stdin),p1 == p2) ? EOF : *p1++)
#define read() ({int s = 0,f = 1;char ch = gc;for(;!isdigit(ch);ch = gc)if(ch == '-')f = -1;for(;isdigit(ch);ch = gc)s = s * 10 + ch - '0';s * f;})
signed main(){
	int T = read();
	while(T--){
		int a = read(),b = read(),c = read(),d = read();
		int ans = 0;
		int mx = c * d / b;
		for(int i = 1;i <= mx;++i){
			if(1ll * d * 1ll * c - b * 1ll * i <= 0)continue;
			if(1ll * c * 1ll * a * 1ll * i % (1ll * d * c - 1ll * b * i) == 0)ans++;
		}
		printf("%d\n",ans);
	}
}

```

---

## 作者：hzoi_liuchang (赞：1)

## 分析
要求的式子是

$\frac{a}{x}+\frac{b}{c}=\frac{d}{y}$

因为所有的数都是正整数，所以 $\frac{b}{c}<\frac{d}{y}$

那么 $y$ 能够取到的最大值就是 $\frac{cd}{b}$

因为 $c\times d$ 是小于 $10^6$ 的

所以我们只要枚举 $y$ 判断 $x$ 是否合法即可

稍微变一下形，就有

$\frac{cd-by}{cy}=\frac{a}{x}$

即

$x(cd-by)=acy$

只要判断是否存在这个式子即可，要注意分母为 $0$ 的情况
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define gc() (p1 == p2 ? (p2 = buf + fread(p1 = buf, 1, 1 << 20, stdin), p1 == p2 ? EOF : *p1++) : *p1++)
#define read() ({ register int x = 0; register char c = gc(); while(!isdigit(c)) c = gc(); while(isdigit(c)) x = x * 10 + (c & 15), c = gc(); x; })
char buf[1 << 20], *p1, *p2;
int t,a,b,c,d;
int main(){
	t=read();
	while(t--){
		a=read(),b=read(),c=read(),d=read();
		rg int ans=0;
		rg int mmax=1LL*c*d/b;
		for(rg int i=1;i<=mmax;i++){
			if(1LL*c*d==1LL*b*i) continue;
			if(1LL*i*c*a%(1LL*c*d-1LL*b*i)==0) ans++;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：dcmfqw (赞：0)

首先一眼下去还以为是数论，以为 A 题就不会了

翻到后面发现惊喜来了

> $d\times c\le10^6$

> 众所周知，高考不考数论。

这不是在明示我们暴枚就行了吗

然后看到这个柿子：

$\frac{a}{x}+\frac{b}{c}=\frac{d}{y}$

我们要想办法让这个柿子中出现 $cd$ 以枚举

所以让柿子两边乘 $cy$：

$\frac{acy}{x}+by=cd$

再整理成用 y 表示 x 的形式：

$x=\frac{acy}{cd-by}$

由于柿子中的数都是正整数，所以有下面这性质：

$by<cd$

这时候就可以枚举 y 了，判断合法性时直接判断 x 是不是正整数即可

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t, a, b, c, d, rans;
int main() {
  scanf("%d", &t);
  while(t--) {
    rans = 0;
    scanf("%lld%lld%lld%lld", &a, &b, &c, &d);
    for(long long y = 1; b * y < c * d; ++y)
      if(a * c * y % (c * d - b * y) == 0)
        rans++;
    printf("%lld\n", rans);
  }
  return 0;
}
```

---


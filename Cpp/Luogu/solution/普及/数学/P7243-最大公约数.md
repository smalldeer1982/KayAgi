# 最大公约数

## 题目背景

&emsp;&emsp;“寻求最大公约数是人民民主的真谛。……”

&emsp;&emsp;初秋，从枝丫滴下的阳光，柔和，在教室的窗棱溅起，润湿晨读的少女的脸颊。

&emsp;&emsp;“阿绫，阿绫”，天依低俯身子，八字辫耷拉在竖起的课本沿，“我们的最大公约数是多少呢？”

&emsp;&emsp;“一定不小吧”，左手悄悄捏捏天依的小臂，“比如呀，有一个公因子，叫做‘你喜欢我，我也喜欢你’。”

## 题目描述

相反，人际圈形形色色，公约数小得可怜，似乎很难保持自己的个性因而变成无趣的人呢。

现在把人际抽象成一个 $n \times m$ 的矩形，每个人初始的个性为 $a_{i,j}$。从第二天开始，每个人会与上下左右四个人（如果存在）建立人际关系，其个性变为昨天自己和四周人个性的最大公约数。那么对于第 $x$ 行第 $y$ 列的人，在多少天后他的个性会变为 $1$ 呢？

----

#### 简化题意

有一个 $n \times m$ 的矩阵 $a$。对一个矩阵进行变换，定义为将这个矩阵内的所有元素变为其上下左右四个元素（不存在则忽略）及自身的最大公约数。询问 $a_{x,y}$ 在进行最少多少次变换之后会变成 $1$。如果可以使 $a_{x,y}$ 经过若干次变换变成 $1$，输出其中最小的次数；否则输出 $-1$。

## 说明/提示

#### 样例解释 3
第一天的个性矩阵（也就是最开始的矩阵）为
$$
\begin{pmatrix}
3&2&3\\
2&3&2\\
3&2&3
\end{pmatrix}
$$
第二天的个性矩阵为
$$
\begin{pmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{pmatrix}
$$
可见只需要经过一天，$a_{2,2}$ 就会变为 $1$，所以答案为 $1$。

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^3$，$1\le a_{i,j}\le 10^{18}$，$1\le x\le n$，$1\le y\le m$。

| 子任务 | 分值 |        $n,m$        |              特殊限制              |
| :----: | :--: | :-----------------: | :--------------------------------: |
|   1    |  1   |          /          | 保证给出的位置个性永远不会变为 $1$ |
|   2    |  1   |          /          |          保证 $a_{x,y}=1$          |
|   3    |  3   |      $ \le 2$       |                 /                  |
|   4    |  10  |     $ \le 10^2$     |                 /                  |
|   5    |  30  | $ \le 5\times 10^2$ |           /            |
|   6    |  10  |          /          |   保证对于所有的 $a_{i,j} \le 2$   |
|   7    |  10  |          /          |     保证 $x$ 与 $y$ 都等于 $1$     |
|   8    |  35  |          /          |                 /                  |





------------




## 样例 #1

### 输入

```
2 2
2 2
1 2
2 1```

### 输出

```
0```

## 样例 #2

### 输入

```
2 2
2 2 
2 2
1 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
3 3
3 2 3
2 3 2
3 2 3
2 2```

### 输出

```
1```

# 题解

## 作者：vectorwyx (赞：63)

做这道题之前首先要明确一个重要的结论：嵌套形式的 $\gcd$ 的值等于原式中出现的数的 $\gcd$，比如说  $\gcd(a,\gcd(b,c))$ 就等于 $\gcd(a,b,c)$，$\gcd(\gcd(a,b),\gcd(b,c))$ 也等于 $\gcd(a,b,c)$。为什么呢？因为 $\gcd(a,b)$ 实际上是对 $a$ 和 $b$ 中每个质因数的指数取 $min$，如果出现的数始终是那几个，那无论怎么嵌套，每个质因数的指数的最小值都不会发生改变（**关键点** $1$）。

再来看本题，我们会发现每一轮每个位置上的数都可以表达为$\gcd(S)$，$S$ 为整数集（**关键点** $2$）。每进行一轮，每个位置上的 $S$ 里的所有元素便会“进入”相邻格子的集合。换句话说，每个位置上的 $S$ 每进行一轮就会扩大一圈（如果矩阵足够大的话实际上就是一个对角线长度不断增加 $2$ 的竖着的方形），这个过程其实就是从起点进行 bfs 的过程，边 bfs 边记录 gcd 即可，时间复杂度为 $O(nmlog(k))$（**关键点** $3$）。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#define ll long long
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
inline ll read(){ ll x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=2e3+5;
int n,m,sx,sy,vis[N][N];
ll a[N][N];
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};

void bfs(){
	queue<int> qx,qy,qs;
	qx.push(sx),qy.push(sy),qs.push(0);
	vis[sx][sy]=1;
	ll sum=a[sx][sy];
	while(!qx.empty()){
		int x=qx.front(),y=qy.front(),s=qs.front();
		qx.pop(),qy.pop(),qs.pop();
		fo(i,0,3){
			int tx=x+dx[i],ty=y+dy[i];
			if(tx<1||tx>n||ty<1||ty>m||vis[tx][ty]) continue;
			vis[tx][ty]=1;
			qx.push(tx),qy.push(ty),qs.push(s+1);
			sum=__gcd(sum,a[tx][ty]);
			if(sum==1){
				cout<<s+1;
				return;
			}
		}
	}
	cout<<-1;
}

int main(){
	n=read(),m=read();
	fo(i,1,n) fo(j,1,m) a[i][j]=read();
	sx=read(),sy=read();
	if(a[sx][sy]==1){
		cout<<0;
		return 0;
	}
	bfs();
	return 0;
}
```
点个赞再走吧QAQ （~~**关键点** $4$~~）

---

## 作者：_zy_ (赞：21)

#### [啊哈，题目在这里](https://www.luogu.com.cn/problem/P7243)

居然没有人写bfs的题解！

先跳出奇奇怪怪换矩阵的方法，我们只看x,y。

第一次更换： $x,y$只由上下左右的四个点来更新

即$a[x][y]=gcd(a[x][y],a[x+1][y],a[x-1][y],a[x][y+1],a[x][y-1])$

第二次更换： $x,y$依旧只由上下左右四个点来更新

不过上下左右四个点变成了他各自的上下左右四个点

对于这几个点都有

$b[x][y]=gcd(b[x][y],b[x+1][y],b[x-1][y],b[x][y+1],b[x][y-1])$

所以第二次的$a[x][y]$=$gcd$(上一次已经取完gcd的老$a[x][y]$，由四周的点拓展到的点)$

#### 于是题目就转换为了从$x，y$一层一层的取$gcd$，直到$a[x][y]$为$1$。

---------------
- 关于$-1$ 的情况：
	
    如果遍历
    
    完整个矩阵，a[x][y]还没有1，就说明没有值可以将其更新为 1
    
 - 数组要开大
 
 代码实现：
 
 ```cpp
 #include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue> 
#define int unsigned long long 
#define N 2010
using namespace std;
int re() {
	int p=0; char i=getchar();
	while(i<'0'||i>'9')	i=getchar();
	while(i>='0'&&i<='9')	p=p*10+i-'0',i=getchar();
	return p; 
}
int n,m,x,y,tot,cnt;
int a[N][N];
int q[N*2000][3];
bool v[N][N];
const short dx[]={0,1,-1,0,0}; const int dy[]={0,0,0,1,-1};
int gcd(int x,int y)  {
	if(!y) return x;
	else return gcd(y,x%y);
}
void bfs(int x,int y)
{
	int head,tail;
	head=tail=0;
	q[++tail][0]=x; q[tail][1]=y;
	v[x][y]=1;
	while(head<tail)
	{
		int X=q[++head][0];
		int Y=q[head][1];
		for(int i=1;i<=4;i++)
		{
			int xx=X+dx[i]; int yy=Y+dy[i];
			if(v[xx][yy]||xx<1||yy<1||xx>n||yy>m)	continue;
			q[++tail][0]=xx;
			q[tail][1]=yy;
			q[tail][2]=q[head][2]+1;
			v[xx][yy]=1;
			tot=gcd(tot,a[xx][yy]);
		}
		if(tot==1) {
			cout<<q[tail][2]<<endl;
			exit(0);
		}
	}
}
signed main()
{
	n=re(); m=re();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)	a[i][j]=re();
	x=re(); y=re();
	tot=a[x][y];
	if(tot==1) {
		printf("0\n");
		return 0;
	}
	bfs(x,y);
	printf("-1\n");
	return 0;
}
/*
3 3
3 4 4
4 4 4
4 4 4
3 3
*/
```

如有不妥之处或是不明白地方，欢迎指出

---

## 作者：Just_A_King (赞：14)

## 广搜题
(如果非要说难点的话估计就抽象题目了

------------


# 1.题意分析

为了方便,我们设**天数为d天**

并称关于点A$(X,Y)$和点B$(M,N)$的

$\left\vert X-M\right\vert$+$\left\vert Y-N\right\vert$

为点A到点B的**曼哈顿距离**


那么第d天的$(x,y)$的**个性状态**就由

第$d-1$天与$(x,y)$的**曼哈顿距离$≤$1**的点来决定

并且得出的结果为**这些点所代表数字的最大公约数**

且$d-1$天$(x+1,y),(x-1,y),(x,y+1),(x,y-1)$

的个性状态又由第$d-2$天与

这四个点的**曼哈顿距离$≤$1**的点来决定

那么就可以**由递推**得出关系：

第d天的$(x,y)$的**个性状态**就为$gcd(a_i)$ 

且 $a_i$到$(x,y)$的**曼哈顿距离**$<=d$

------------
# 2.广搜实现

设置中心值$ans$,

并初始化$ans=a[x][y]$

然后以$(x,y)$为中心不断向外扩展

并将**被扩展到的点**不断**入队**,

入队的同时使$ans=gcd(ans,a[i][j])$

**扩展过的点**不断**出队**

定义变量$day$来记录扩展到的**最远点的曼哈顿距离**

当**队列为空时**或者$ans=1$时结束

**判断后**即可输出答案



------------
# 3.时间复杂度

#### 输入的时间复杂度:$\Theta(nm)$

每个队最多入队一次,

每入队一次需要求一次最大公约数。

辗转相除法的最坏情况为a,b属于斐波那契数列,

又  斐波那契数列为指数级

故  辗转相除法求最大公约数的时间复杂度为$\Theta(log_2 n)$

#### 因此广搜的时间复杂度为$\Theta(nmlog_2 n)$

#### 输出的时间复杂度:$\Theta(1)$

### 综上,
### 程序的时间复杂度为$\Theta(nmlog_2 n)$

------------
# 4.代码
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2e3+3;
const ll way1[5]={0,1,-1,0,0},way2[5]={0,0,0,1,-1};

ll n,m,a[N][N],ans,cnt,ax,ay;
struct node{
	ll x,y;
};
queue<node> q;

inline ll read(){
	char c=getchar();ll x=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	return x;
}

inline ll dis(node a){
	return abs(a.x-ax)+abs(a.y-ay);
}//求当前点到(x,y)的曼哈顿距离

inline ll gcd(ll a,ll b){
	return b?gcd(b,a%b):a;
}//辗转相除法求最大公约数

int main(){
	
	n=read(),m=read();
	
	for(ll i=1;i<=n;++i)
		for(ll j=1;j<=m;++j)
			a[i][j]=read();//输入
	
	ax=read(),ay=read(),ans=a[ax][ay];
	q.push((node){ax,ay});//初始化
	
	ll day=0;
	while(ans!=1 && !q.empty()){
		++day;
		while(!q.empty() && dis(q.front())<day){
			for(ll i=1;i<=4;++i){//入队
				node mid=(node){q.front().x+way1[i],q.front().y+way2[i]};
				if(mid.x>=1&&mid.x<=n && mid.y>=1&&mid.y<=m && a[mid.x][mid.y]){
					ans=gcd(ans,a[mid.x][mid.y]);
					q.push(mid);a[mid.x][mid.y]=0;
				}
			}
			q.pop();//出队
		}
	}//广搜
	
	if(ans==1) printf("%lld",day);
	else printf("-1");//判断广搜结束的原因后输出
	
	return 0;	
}

```



---

## 作者：TianLuen (赞：7)

# P7243 最大公约数 C++题解
## 题意简述

- 给定一个 $n\times m$ 的矩阵 $a$。
- 每一个点 $a_{i,j}$ 有一个值。
- 有若干次操作，每一次操作中每一个点变为自身以及所有周围点（存在的）的最大公约数。
- 求经过多少次操作后，目标点 $a_{x,y}$ 将变为 $1$。
- 若目标点无法变为 $1$ ，则输出 $-1$。
## 题意分析
看到这一题，这就是一个~~简单的~~模拟题吧。
### 错误解法
首先我想到的是这一个解法，纯粹的模拟。每次更新一遍矩阵，直到点 $a_{x,y}$ 为 $1$ 时输出即可。当一次下来矩阵没有变化时，那么就意味着无解，此时输出 $-1$ 即可。

显然，这段代码会T掉。因为这个解法中，时间复杂度很高（我自己也算不出来到底多高）。

### 正确解法
那么，这段代码就需要优化。

定义目标点变为另一点与其的最大公约数，此时称该点”影响“了目标点。

我们可以推导出如下结论：

在最坏情况下，必须是所有点的最大公约数才能得到 $1$，此时所有的点都需要”影响“到目标点。

我们可以确定，要么当若干个点”影响“到目标点后，目标点会变为 $1$；要么全部”影响“到目标点后也无法变为 $1$。

而一点如果要”影响“到目标点，必然需要经过 两点间的曼哈顿距离 次操作，而曼哈顿距离最大也就是 $n+m$。

最后，任意一点最多只需要一次”影响“目标点，没必要重复”影响“。

因此，综合上述结论，得出如下解法：
1. 若 $a_{x,y}=1$ ，输出 $0$ 即可。
1. 设立一个数组`d`，记录第 $i$ 次操作目标点的值，数组`d` 初始化为目标点的值。
3. 开始遍历数组，取 $a_{i,j}$ 到 $a_{x,y}$ 的曼哈顿距离`dis`，`dis`即$|x-i|+|y-j|$。让`d[dis]`赋值为`d[dis]`与`a[i][j]`的最大公约数，即模拟每一个点如何”影响“目标点。
3. 最后补一下，从前往后，让`d[i]`赋值为`d[i]`与`d[i-1]`的最大公约数，即同步一遍”影响“，如果`d[i]`为 $1$ 就输出`i`并退出。
5. 若直到现在也没有结束，那么输出 $-1$ 。

最终得到时间复杂度为 $O(nm\times \texttt{GCD的时间复杂度}+n+m)$。
## AC代码
```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int MAXN=2e3+10;
LL a[MAXN][MAXN],d[MAXN<<1];	//两个数组要开long long类型，数组d要开为 n+m 的最大值
LL GCD(LL a,LL b)
{
    LL c=0;
    while((c=a%b))
    {
        a=b;
        b=c;
    }
    return b;
}
int main()
{
    int n,m,x,y;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    cin>>x>>y;
    if(a[x][y]==1)
    {
        cout<<0;
        return 0;
    }
    for(int i=0;i<=n+m;i++)
        d[i]=a[x][y];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(i!=x||j!=y)	//注意需要排除自身
            {
                int dis=abs(x-i)+abs(y-j);
                d[dis]=GCD(a[i][j],d[dis]);
            }
    for(int i=1;i<=n+m;i++)
    {
        d[i]=GCD(d[i-1],d[i]);
        if(d[i]==1)
        {
            cout<<i;
            return 0;	//提前结束程序
        }
    }
    cout<<-1;
    return 0;
}
```
当然这不是最优解，如果用BFS的话可以进一步压缩时间。不过这么写我个人认为是比较简练的，没有什么高深的优化。欢迎大家来Hack本题解。
# The End

---

## 作者：SUNCHAOYI (赞：6)

对于 $a_{x,y}$，一共有三种情况，分别列举一下：

- 初始值为 $1$。

此时不需要经过变换，直接输出 $0$。

- 经过若干次变换都不会变为 $1$。

这种情况显然输出 $-1$。但是该如何判断它呢？  

考虑一下，在 $n \times m$ 的方阵中，若有两个数 $a_{x_1,y_1}$ 与 $a_{x_2,y_2}$ 满足 $\gcd(a_{x_1,y_1},a_{x_2,y_2}) = 1$，那么经过若干次的变换后一定能使所有的位置上的数变为 $1$。  

在一次变换后的相关的 $5$ 个位置，都会变为 $1$ 或者是它们中的某一个数。也就是说以每个点为中心的 $5$ 个位置都会改变。因此上述的情况是成立的。  

也就是把该方阵中的所有数做一遍 $\gcd$，若答案不为 $-1$，也就是无解的标志。

- 在有限次数内能变为 $1$。

首先考虑暴力，模拟每一次的变换过程，大概能拿到 $45\texttt{Pts}$
的好成绩。

看回到情况 $2$，随手拿几个样例推一下，发现若 $\gcd(a_{x,y},a_{x',y'}) = 1$，需要 $|x - x'| + |y - y'|$ 次后才能变换为 $1$。这不就是曼哈顿距离嘛，这样也就好写了。

----

最后放一个伪代码，同时也祝大家在 $2021$ 年中 $\texttt{rp++}$。

```cpp

int main ()
{
	for (int i = 1;i <= n;++i)//n * m 的一遍 gcd
	{
		for (int j = 1;j <= m;++j)
		{
			if (i == 1 && j == 1) all = a[i][j];
			else all = work (all,a[i][j]);
		}
	}
	if (all != 1)//特判
	{
		printf ("-1\n");
		return 0;
	}
	if (a[x][y] == 1)//特判
	{
		printf ("0\n");
		return 0;
	}
	for (int i = 1;i <= n;++i)
	{
		for (int j = 1;j <= m;++j)
		{
			if (i == x && j == y) continue;//起点位置
			if (abs (x - i) + abs(y - j) >= ans) continue;//一个小优化
			if (work (a[i][j],a[x][y]) == 1) ans = min (ans,abs (x - i) + abs(y - j));
		}
	} 
	printf ("%lld\n",ans);
	return 0;
}
ll work (ll x,ll y)//辗转相除
{
	return (y == 0 ? x : work (y,x % y));
}
```

---

## 作者：InformationEntropy (赞：5)

首先需注意每次变换时每个点互不影响。每个点的值只与变换前矩阵有关。

所以，当某个点发生改变时，它只会对相邻点的下一次变换产生影响。

从第一次变换出发，我们发现第一次变换后目标值变为上下左右及其自己的 $\gcd$，即：

![](https://cdn.luogu.com.cn/upload/image_hosting/u11lr7a2.png)

第二次变换时，目标点周围的点已变为它们与它们周围四个点的 $\gcd$，所以相当于目标点的值会变为**原矩阵**如图所示的所有点的 $\gcd$：

![](https://cdn.luogu.com.cn/upload/image_hosting/wpmgcpni.png)

有没有发现什么？

每一次变换都是一个拓展的过程，不断上下左右拓展范围，直到范围内所有数的 $\gcd$ 为 $1$ 是为止。

因此，可以从目标点出发 bfs，当全局 $\gcd$ 为 1 是输出 $step$ 即可。

PS: 别忘了开 long long。

Code (593ms)

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
typedef long long ll;
typedef double db;
template<class T>inline void read(T &x)
{
    x = 0;
    T f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - 48;
        ch = getchar();
    }
    x *= f;
}
ll a[2003][2003];
ll gcd(ll x, ll y)//位运算优化版
{
    while(y^=x^=y^=x%=y);
    return x;
}
int dx[5]={0, 1, 0, -1};
int dy[5]={1, 0, -1, 0};
struct node
{
    int x, y;
    int step;
}q[10000001];//队列
bool vis[2001][2001];
int main()
{
    int n, m;
    read(n);
    read(m);
    for(register int i=1; i<=n; ++i)
    {
        for(register int j=1; j<=m; ++j)
        {
            read(a[i][j]);
        }
    }
    int x, y;
    read(x);
    read(y);
    int head=1, tail=0;
    q[++tail]=(node){x, y, 0};
    ll s=a[x][y];
    vis[x][y]=1;
    while(head <= tail)//bfs
    {
        node h=q[head];
        head++;
        if(s==1)
        {
            cout << h.step;
            return 0;
        }
        for(int i=0; i<4; ++i)
        {
            int xx=h.x+dx[i];
            int yy=h.y+dy[i];
            if(xx>0 && xx<=n && yy>0 && yy<=m && !vis[xx][yy])
            {   
                vis[xx][yy]=1;
                s=gcd(s, a[xx][yy]);
                if(s==1)
                {
                    cout << h.step+1;
                    return 0;
                }else{
                    node w=(node){xx, yy, h.step+1};
                    q[++tail]=w;
                }
            }
        }
    }
    cout << -1;
    return 0;
}
```

---

## 作者：wsyhb (赞：5)

## 分析 + 题解

$\gcd$ 有一个显而易见的性质：$\gcd(a,a)=a$，这告诉我们一个数若与其余某个数取多次 $\gcd$，可看作只取了 $1$ 次 $\gcd$。

于是考虑第 $k$ 次变换以后，与 $a_{x,y}$ 取了 $\gcd$ 的数所在区域。由于每次变换可以看作向曼哈顿距离不超过 $1$ 的位置的扩散，故此时与 $(x,y)$ 曼哈顿距离不超过 $k$ 的位置组成了这个区域。

一开始遍历所有位置，将与 $(x,y)$ 曼哈顿距离相同的点存储在一起，然后从小到大枚举 $ans$，判断此时 $a_{x,y}$ 是否为 $1$，若 $ans>\max\{d\}$，则不存在 $a_{x,y}=1$ 的时刻。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=2e3+5;
long long a[max_n][max_n];//记得开 long long 
const int max_size=4e6+5;
typedef pair<int,int> P;
vector<P> pos[max_size];//pos[d] 存储与 (x,y) 曼哈顿距离为 d 的位置 
long long gcd(long long a,long long b)
{
	return b?gcd(b,a%b):a;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			scanf("%lld",&a[i][j]);
	int x,y;
	scanf("%d%d",&x,&y);
	int max_d=0;//记录最大距离 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
		{
			int d=abs(i-x)+abs(j-y);
			pos[d].push_back(P(i,j));
			max_d=max(max_d,d);
		}
	long long now=a[x][y];
	if(now==1)
	{
		puts("0");
		return 0;
	}
	for(int i=1;i<=max_d;++i)
	{
		for(int j=0;j<int(pos[i].size());++j)
		{
			int p=pos[i][j].first,q=pos[i][j].second;
			now=gcd(now,a[p][q]);
		}
		if(now==1)
		{
			printf("%d\n",i);
			return 0;
		}
	}
	puts("-1");
	return 0;
}
```


---

## 作者：ForgotMe (赞：4)

### 闲话

~~看到题目名字有没有觉得这个题很水。~~确实也挺水的。

这个题本来是四周的数的最大公约数，然后发现很恶心，不会做，于是加了个与自己的 $\gcd$，有兴趣的同学可以想一想。

回到正题，来看一看这道题。

先考虑无解的条件，发现如果所有数的最大公约数不为 $1$，答案一定为 $-1$，否则一定有解。这个可以用反证法证明。

考虑根据无解的条件反推，如果当答案为 $d$ 时 $a_{x,y}$ 可以变为 $1$，一定满足距离位置 $a_{x,y}$ 曼哈顿距离不超过 $d$ 的所有位置的数和 $a_{x,y}$ 的最大公约数为 $1$，否则答案 $d$ 一定不合法。

然后模拟这个过程就可以了。

代码
```cpp
#include <queue>
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define LL long long
#define pi pair<int, int>
int n, m, x, y, maxdis;
LL a[5005][5005];
vector<pi> G[20005];
LL gcd(LL x, LL y) { return y == 0 ? x : gcd(y, x % y); }
int Abs(int x) { return x < 0 ? -x : x; }
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 19, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 19], *p1 = buf, *p2 = buf;
LL read() {
    LL ret = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch)) {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    for (; isdigit(ch); ch = getchar()) ret = ret * 10 + ch - 48;
    return ret * f;
}
int main() {
    n = read(), m = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) a[i][j] = read();
    x = read(), y = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            G[Abs(x - i) + Abs(y - j)].push_back(make_pair(i, j)),
                maxdis = max(maxdis, Abs(x - i) + Abs(y - j));
    LL nowgcd = -1;
    for (int i = 0; i <= maxdis; i++) {
        for (int j = 0; j < G[i].size(); j++) {
            if (nowgcd == -1)
                nowgcd = a[G[i][j].first][G[i][j].second];
            else
                nowgcd = gcd(nowgcd, a[G[i][j].first][G[i][j].second]);
        }
        if (nowgcd == 1)
            return printf("%d", i) & 0;
    }
    printf("-1");
    return 0;
}
```

---

## 作者：Rubidium_Chloride (赞：3)

2021.1洛殿庆生赛A题题解。

## 0.前言

[$\color{Red}{\text{在}}\color{orange}\text{博}\color{yellow}\color{green}\text{客}\color{Turquoise}\text{里}\color{blue}\text{看}\color{purple}\color{Red}\text{效}\color{orange}\text{果}\color{yellow}\text{更}\color{green}\text{好}\color{Turquoise}\text{哦}\color{blue}!$](https://www.luogu.com.cn/blog/Rolling-blog1424/solution-p7243)

## 1.题目大意

- 有一个 $n\times m$ 的表格，每个格子 $(i,j)$ 有一个初始值 $a_{i,j}$，表格中每个数过一个单位时间就会变换为其自身与相邻四个格子的 $\gcd$，求过了多少个单位时间，坐标为 $(x,y)$ 的格子值会变为 $1$ ；
- $1\le n,m\le 2\times 10^3,1\le a_{i,j}\le 10^{18}$;

## 2.算法分析

所以怎么办呢……？

暴力弄一下！

可以发现每个格子中的数字最多变化为 $64$ 种不同的数字。

为什么？每个格子取 $\gcd$ 以后，如果变化了，那么至少缩减一倍。

然后 $2^{64}\ge 10^{18}$，然后就结束了。

实测直接模拟即使有特判 $-1$ 也会T掉。

然而这对我们的解题并没有什么帮助，我们得另辟蹊径。

我们来看一下真正对 $(x,y)$ 的格子造成影响的是哪些格子。

第零轮（即初始状态）：其本身；

第一轮，就是其本身+相邻四个；

第二轮，在第一轮中的其本身+相邻四个。

看似没有规律？

**让我们还原第二轮中的影响到的格子。**

就可以得到真正影响的是初始时的以下这些涂色的格子：

![](https://cdn.luogu.com.cn/upload/image_hosting/xl325kpk.png)

也就是说 $(x,y)$ 的格子值在经过两轮操作以后变成了涂色格子开始时的 $\gcd$！

仔细观察就可以知道这些格子和轮数之间的关系：

**曼哈顿距离！**

所以就可以比较愉快地一个一个枚举曼哈顿距离，并且算 $\gcd$，直到是 $1$；

如果所有的格子都算完了发现还不是 $1$ 怎么办？

那就说明那个格子永远不可能变成 $1$，输出 $-1$。

## 3.Code

```cpp
#include<bits/stdc++.h>
#define N 2009
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read() {
    ll x=0,f=1;int c=getchar();
    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
ll gcd(ll a,ll b){
	if(a<b) swap(a,b); 
	return b==0?a:gcd(b,a%b);
}
ll n,m,x,y,f[N][N],ans,mx,k;
vector<ll> dst[2*N];//曼哈顿距离最多可能是n+m
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) f[i][j]=read();
	x=read(),y=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			ll ds=labs(i-x)+labs(j-y);
			mx=max(mx,ds);//记录距离(x,y)最远的点
			dst[ds].push_back(f[i][j]);
		}
	}
	for(int i=0;i<=mx;i++){
		for(int j=0;j<dst[i].size();j++) k=gcd(k,dst[i][j]);
		if(k==1){printf("%lld",i);return 0;}
	}
	printf("-1");
	return 0;
}

```

## 4.结语

希望以后还能有更多洛殿的庆生赛qwq

洛殿yyds！

---

## 作者：WinterRain208 (赞：2)

P7243 【最大公约数】

### 题意分析

本题要求模拟一个矩阵最大公约数变换的过程。

### SOLUTION

首先解决公约数问题，这里要求是$(lo gn)$求出，当然是辗转相除啦！

```
int gcd(int a, int b){
    if(b == 0)
      return a;
    return gcd(b,a%b);
}
```
或者直接

```
__gcd(a,b)
```
时间复杂度和辗转相除一样，是$dev$自带函数。

接下来我们考虑无解情况。

先上结论：如果矩阵所有数公约数不为$1$，也就是没有至少两个数互质，无解。

比如

| 2 | 4 | 2 |
| -----------: | -----------: | -----------: |
| 4 |  2| 4 |
|  2| 4 | 2 |

肯定不行，因为所有数最终都会变成二。因为所有数的最大公因数为$2$。

如果确定不是无解，那么直接模拟即可。

再来看看部分分是怎么玩的。

##### $SUBTASK 1$

直接输出$-1$啊，因为题目数据保证无解。

##### $SUBTASK 2$

直接输出$0$啊，因为这个位置本来就是$1$。

##### $SUBTASK 6$

一直到这里都可以直接模拟的，完全不超时。

$6$虽然数据大了些，但答案不是$0$就是$1$，只需要模拟一次就可以把所有元素$变成1$。

$55$分了。

##### $SUBTASK 8$

我没有看出$7$可以用什么特殊方法过，但这两个子任务都可以用曼哈顿距离做，求与目标位置互质的最近的元素。

曼哈顿距离：

```
abs(x1-x2)+abs(y1-y2)
```
枚举即可。

时间复杂度主要在判断无解上。

#### 题外话

~~作为比赛中这题跑的最慢的人我很骄傲~~ ，如果有大佬能为我的代码指出优化，我将会非常感谢您。

总体来说这题作为比赛第一题难度没那么高，涨涨信心可还行。

### $CODE$

```cpp
#include<bits/stdc++.h>
#define F(i,j,r) for(int i=j;i<=r;++i)
#define D(i,j,r) for(int i=j;i>=r;--i)
#define INF 0x3f3f3f3f

using namespace std;
const int N=2e3+5;

long long read(){
    long long rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return rv*fh;
}

long long n,m,a[N][N],x,y,f,ans=0,b[N][N];

long long get(int x,int y){
	long long tot=a[x][y];
	if(x+1<=n)tot=__gcd(a[x+1][y],tot);
	if(x-1>=1)tot=__gcd(a[x-1][y],tot);
	if(y+1<=m)tot=__gcd(a[x][y+1],tot);
	if(y-1>=1)tot=__gcd(a[x][y-1],tot);
	return tot;
}
int main(){
	scanf("%lld%lld",&n,&m);
	F(i,1,n)F(j,1,m)scanf("%lld",&a[i][j]);
	f=a[1][1];
	F(i,1,n)F(j,1,m)if(!(i==1&&j==1))f=__gcd(a[i][j],f);
	if(f!=1){
		puts("-1");
		return 0;
	}
	scanf("%d%d",&x,&y);
	if(a[x][y]==1){
		puts("0");
		return 0;
	}
	if(n*m<=250000)
	while(a[x][y]!=1){
		ans++;
		F(i,1,n)F(j,1,m)b[i][j]=get(i,j);
		F(i,1,n)F(j,1,m)a[i][j]=b[i][j];
	}
	else{
		ans=INF;
		F(i,1,n)F(j,1,m){
			if(__gcd(a[i][j],a[x][y])==1)ans=min(ans,abs(i-x)+abs(j-y));
		}
	}
	
	printf("%lld",ans);
    return 0;
}
```

考场上测了一下要吐了，~~MVP~~跑了$5s$。。。。。。

结果不管多少分总是这个分数最后一名$qwq$。

代码注释就不写了，如果有错误可以私信指出。

$WTRL$。

## $UPDATE$ $1.5$

感谢[@Query_LCA](https://www.luogu.com.cn/user/233816)

指出的不足。

重复一下苣佬的意见。

手写辗转相除会比__gcd快一点，网上查了一下确实是。

判断互质如果曼哈顿距离大于当前最优解就不用求公因数了。

---


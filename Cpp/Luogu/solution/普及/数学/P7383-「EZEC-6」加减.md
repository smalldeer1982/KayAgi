# 「EZEC-6」加减

## 题目描述

给你两个数 $n,m$，你要将 $m$ 分为 $n$ 个**互不相同的正整数**（即这 $n$ 个数之和为 $m$），使得在区间 $[1,m]$ 中至少有一个正整数无法通过这 $n$ 个数加减取得（加减时每个数最多用 $1$ 次）。

即，设 $n$ 个正整数中第 $i$ 个数为 $a_i$，你要使在区间 $[1,m]$ 中至少有一个正整数无法被表示为 $\sum\limits^{n}_{i=1}k_i\times a_i\ (k_i\in\{-1,0,1\})$ 的形式。

若无解，输出 `-1`。

若有解，则输出任意一组满足要求的 $n$ 个正整数，并输出在区间 $[1,m]$ 中无法被表示出的任意一个数。

## 说明/提示

**本题采用捆绑测试**。

- Subtask 1（10 points）：$n\le2$。
- Subtask 2（20 points）：$2n^2\le m$。
- Subtask 3（20 points）：$\lceil1.5n^2\rceil\le m$。
- Subtask 4（20 points）：$n\le5$。
- Subtask 5（30 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le100$，$1\le n,m\le10^4$。

## 样例 #1

### 输入

```
4
2 6
3 18
1 1
2 4```

### 输出

```
1 5
3
5 6 7
3
-1
-1```

# 题解

## 作者：Falashiro (赞：16)

$\sum\limits_{i=1}^{n}i=\frac{n\times(n+1)}{2}$，$\sum\limits_{i=2}^{n+1}i=\frac{n\times(n+3)}{2}$，

若 $m\ge\frac{n\times(n+3)}{2}$，可以给出构造解：

$2,3,\dots,n-1,n,m-\frac{(n-1)\times(n+2)}{2}$，无法表示出 $m-1$。

------------

若 $m<\frac{n\times(n+1)}{2}$，无法分为 $n$ 个不相同的正整数，显然无解。

------------

若 $\frac{n\times(n+1)}{2}\le m<\frac{n\times(n+3)}{2}$，

假设有解，不妨认为构造出来的序列 $a$ 单调递增，  
设 $m=\frac{n\times(n+1)}{2}+t$，那么所有由 $n$ 个不相同的正整数组成且和为 $m$ 的单调递增的序列均可以这么得到：有一个初始为 $1,2,\dots,n-1,n$ 的序列，每次给一个数加 $1$，加 $t$ 次，中途需要保持序列单调递增，这相当于进行若干次后缀加，总的增量为 $t$。

结论：

若 $n\ge4$，对于得到的任意一个序列 $a$，和任意一个 $2\le i\le n$，都有 $(\sum\limits_{j=1}^{i-1}a_j)+1\ge a_i$。

证明：

$t<\frac{n\times(n+3)}{2}-\frac{n\times(n+1)}{2}$，即 $t<n$，

如果要使上述结论不成立，设要使得它在 $i$ 的位置不成立，显然一直给 $a_i$ 加 $1$ 是最优的，给 $a_i$ 加 $1$ 的需要进行 $n-i+1$ 次加法，$a_i$ 最多能被加 $\lfloor\frac{t}{n-i+1}\rfloor\le \lfloor\frac{n-1}{n-i+1}\rfloor$ 次，

现在需要证明 $a_i>(\sum\limits_{j=1}^{i-1}a_j)+1$ 是不可能的，

即证明 $i+\lfloor\frac{n-1}{n-i+1}\rfloor\le \frac{i\times(i-1)}{2}+1$，

假设现在 $i$ 已经固定，则 $n=i$ 时，$\lfloor\frac{n-1}{n-i+1}\rfloor$ 最大，它的值为 $i-1$，

现在需要证明 $i+i-1\le\frac{i\times(i-1)}{2}+1$，

即 $4i-4\le i^2-i$，

在 $i\ge4$ 时，即 $n\ge4$ 时，上式成立，证毕。

接下来可以利用这个结论完成本题证明：

若 $n<4$，暴力枚举可得无解，若 $n\ge4$：

因为 $t<n$，后缀加无法对 $a_1$ 造成影响，所以 $a_1=1$，第一个数可以表示出区间 $[1,1]$ 内的所有正整数，假设目前已经得到了 $a_1$ 至 $a_x$ 可以表示区间 $[1,s]$ 内的所有正整数且 $s=\sum\limits_{i=1}^xa_i$，则加入 $a_{x+1}$ 后一定可以表示区间 $[a_{x+1},a_{x+1}+s]$ 内的所有正整数，由之前的结论可得：$s+1\ge a_{x+1}$，那么 $[1,s]\cup[a_{x+1},a_{x+1}+s]=[1,a_{x+1}+s]$，当前的区间右端点仍为已加入的所有数的和，最后将 $a_n$ 加入后，一定可以表示区间 $[1,\sum\limits_{i=1}^na_i]$ 内所有正整数，即可以表示出区间 $[1,m]$ 内所有正整数。

所以当 $\frac{n\times(n+1)}{2}\le m<\frac{n\times(n+3)}{2}$ 时，无解。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int w=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')w=w*10+c-48,c=getchar();
	return w;
}
int T,n,m;
signed main(){
	T=read();
	while(T--){
		n=read(),m=read();
		if(n*(n+3)/2>m){
			puts("-1");
			continue;
		}
		for(int i=2;i<=n;i++)
			printf("%d ",i);
		printf("%d\n%d\n",m-(n-1)*(n+2)/2,m-1);
	}
	return 0;
}
```

---

## 作者：syf2008 (赞：9)

~~这是一道非常有趣的题~~

回归正题

我们来看看无解的几种情况

# 无解

1.m<=n*(n+1)/2

2.所有<=m的数字都能组成

3.数据范围告诉了我们，当n>=142时，m必须>10000才能组成，所以n>=142就不成立

# 思路：

1.找一些数保证递增（这样就不用sort了）

2.尤这些数组成<=m的数找出来


30分代码（dfs）~~看着玩好了，我就不解释了~~
```
#include <bits/stdc++.h>
using namespace std;
int t,n,m,a[10005],m1,s;
bool a1[10005];
inline void dfs(int x,int sum)
{
	if(sum>0)
	a1[sum]=1;
	if(x>n||sum<-m1-sum)
	return;
	dfs(x+1,sum);
	dfs(x+1,sum-a[x]);
	dfs(x+1,sum+a[x]);
	dfs(x+1,a[x]-sum);//尤这些数组成<=m的数找出来
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		memset(a1,0,sizeof(a1));
		cin>>n>>m;
		m1=m;
		if(n>145||m<=n)
		{puts("-1");
		continue;}
		m=m-(n+1)*n/2;
		s=m/n;
		m=m-s*n;
		for(int i=1;i<=n;i++)
		a[i]=i+s;
		if(m>0)
		a[n]+=m;
		dfs(1,0);
		for(int i=1;i<=m1;i++)
		if(!a1[i])
		{
		for(int j=1;j<=n;j++)
		printf("%d ",a[j]);
		printf("\n%d\n",i);
		goto flag;
		}
		puts("-1");
		flag:;
	}
}
```

100分代码(神奇的dp)

```
#include <bits/stdc++.h>
using namespace std;
int t,n,m,a[10005],m1,s;
bool a1[10005];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		memset(a1,0,sizeof(a1));
		cin>>n>>m;
		m1=m;
		if(n>145||m<=n)
		{puts("-1");
		continue;}//判特殊情况，加速（雾
		m=m-(n+1)*n/2;
		s=m/n;
		m=m-s*n;
		for(int i=1;i<=n;i++)
		a[i]=i+s;
		if(m>0)
		a[n]+=m;
		a1[0]=1;
		for(int i=1;i<=n;i++)
		{
			for(int j=m1;j>=a[i];j--)
			{a1[j]|=a1[j-a[i]];
			a1[j-a[i]]|=a1[j];}
			for(int j=a[i];j>=0;j--)
			{a1[j]|=a1[a[i]-j];
			a1[a[i]-j]|=a1[j];}
		}//用dp代替dfs
		for(int i=1;i<=m1;i++)
		if(!a1[i])//找到
		{
		for(int j=1;j<=n;j++)
		printf("%d ",a[j]);
		printf("\n%d\n",i);
		goto flag;
		}
		puts("-1");//如果没有输出-1
		flag:;
	}
}
```

---

## 作者：Rolling_L (赞：6)

我们可以看到，这道题是一个存在性问题（存在一个整数不能被构造），因此我们考虑最难构造出的一个。

容易看出，其中最难构造出的数是 $m-1$，原因是，只要我们的分割方案中没有 $1$，就无法构造出 $m-1$。

简单解释一下这个结论：

显然全选的和为 $m$，而如果构造方案中没有 $1$，无论减去或不使用任何一个数，结果都会小于 $m-1$。

因此，为了尽可能的能构造出方案，最优的方案是 $2,3,4,5……$。注意要求每个数互不相同。因此如果 $\sum\limits_{i=2}^{n+1}i > m$，说明无法构造。

最后放一下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
	cin>>t;
	while(t--){
		int n,m;
		
		cin>>n>>m;int k=m;
		bool is=1;
		for(int i=2;i<=n;i++){
			m-=i;
			if(m<=i){//构造失败，有重复 
				is=0;
				break;
			}
		}
		if(is&&m>1){
			for(int i=2;i<=n;i++){//构造成功 
				printf("%d ",i);
			}
			cout<<m<<'\n'<<k-1<<'\n';
		}else{
			cout<<-1<<'\n';
		}
		
	}
	return 0;
}
```


---

## 作者：wjr_jok (赞：2)

首先我们注意到，只要分出来的数里没有 $1$ 那么就不能凑出 $m-1$，在此不作详细证明。

所以无解情况只有两种：$m < 2$（只能分出一个 $1$）或者 $m$ 分不出来 $n$ 个不一样的数。

有解时，从 $2$ 依次累加，便可构造出 $n$ 个数，能够保证无法凑出 $m-1$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,jl,cnt;
int sc[10001];
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		if(m<2){//特判无解
			cout<<-1<<endl;
			continue;
		}
		jl=m-1;
		cnt=0;
		for(int i=2;i;i++){//从而开始构造答案
			if(m<=i*2||cnt+1==n){
				sc[i-1]=m;
				cnt++;
				break;
			}
			else{
				sc[i-1]=i;
				m-=i;
				cnt++;
			}
		}
		if(cnt<n){//同上，当m无法分出n个数时无解
			cout<<-1;
		}
		else{
			for(int i=1;i<=n;i++){//输出答案
				cout<<sc[i]<<" ";
			}
			cout<<endl<<jl;
		}
		cout<<endl;
	}
	return 0;
} 
```

---

## 作者：剑路双痴 (赞：2)

我们可以得到 $\sum\limits_{i=1}^n a_i=m$。~~证明略。~~\
那么原问题可以转化为：我们要使在区间 $[1,m]$ 中至少有一个正整数无法被表示为 $m-\sum\limits_{i=1}^n k_i\times a_i\ (k_i\in\{0,1,2\})$。\
我们发现，如果对于任意的 $i$（$1\leqslant i\leqslant n$ 且 $i$ 为整数），若 $a_i\neq 1$，则正整数 $m-1$ 无法被得到。~~证明略。~~\
所以说，我们把 $m$ 分成 $2+3+4+\dots+(n-1)+n+s$ 的形式，易得 $s = m-\sum\limits_{i=2}^n i = m-\dfrac{1}{2}\times(n+2)\times(n-1) $。\
如果能将 $m$ 分成如上形式，则 $m-1$ 无法得到，即如上 $n$ 个正整数是一组满足要求的解，且正整数 $m-1$ 无法被表示，直接输出即可。\
如果不能将 $m$ 分成如上形式，可得 $s\leqslant n$，即 $\sum\limits_{i=2}^{n+1}i = \dfrac{1}{2}\times (n+3)\times n>m$ ，此时无解，应该输出 $-1$。

------------
Code:
~~~cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
typedef long long ll;
#define For(i,l,r) for (ll i=l,end=r;i<=end;++i)
#define FOR(i,l,r) for (ll i=l,end=r;i>=end;--i)
using namespace std;

void solve(){
    ll n,m;scanf("%lld%lld",&n,&m);
    if ((n+3)*n/2>m){printf("-1\n");return;}
    For(i,2,n) printf("%lld ",i);
    printf("%lld\n%lld\n",m-(n+2)*(n-1)/2,m-1);
} 

int main(){

    ll t;scanf("%lld",&t);
    For(i,1,t) solve(); 
    return 0;
}
~~~

---

## 作者：CuFeO4 (赞：0)

$\sum\limits_{i=1}^ni=\frac{n\times (n+1)}{2}$，$\sum\limits_{i=2}^{n+1}i=\frac{n\times (n+3)}{2}$。

当 $m<\frac{n\times (n+1)}{2}$ 时，无法凑出 $n$ 个数，无解。

当 $m\ge \frac{n\times (n+3)}{2}$ 时，一组合法的解为 $2,3,4,\cdots,m-\frac{n\times (n+2)}{2}$，此时肯定无法凑出 $1$ 与 $m-1$。

考虑当 $\frac{n\times (n+1)}{2}\le m < \frac{n\times (n+3)}{2}$ 时，考虑仍然利用 $m\ge \frac{n\times (n+3)}{2}$ 时的思路，构造序列使得 $m-1$ 和 $1$ 无法被凑出，简单计算一下发现无解。

综上，当 $m<\frac{n\times (n+3)}{2}$ 时，无解，反之，可以构造 $2,3,4,\cdots,n,m-\frac{n\times (n+2)}{2}$。

挂个核心代码。

```cpp
cin>>n>>m;
if(n*(n+3)/2 > m) return cout<<"-1\n",void();
rep(i,2,n,1) cout<<i<<' ';
cout<<m-(n-1)*(n+2)/2<<'\n'<<m-1<<'\n';
```

---

## 作者：JYX0924 (赞：0)

一道构造题。

很容易得到的一个结论是，如果构造的 $n$ 个数中没有 $1$，那么就无法通过计算得到 $m-1$。

证明：

这 $n$ 个数和为 $m$，一旦计算时出现减法，计算结果就会小于 $m-1$。如果算式只有加法，那么不管哪几个数相加，结果要么等于 $m$，要么小于 $m-1$。

构造数列时，从 $2$ 开始，每一项比上一项大 $1$，最后一项通过减法得到。

这 $n$ 个数的和是 $n\times(n+3)\div2$。如果 $m$ 小于它，就构造不了。

下面是 AC 代码。
```c
#include<bits/stdc++.h>
using namespace std;
int T,n,m;
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n>>m; int tt=2; //2到n+1和为(n+3)*n/2
		if(m<(n+3)*n/2) {cout<<-1<<"\n"; continue;}
		for(int i=1;i<=n-1;i++)
		{
			cout<<tt<<" "; tt++;
		}
		cout<<m-(n+2)*(n-1)/2<<"\n"<<m-1<<"\n";
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：wbw_121124 (赞：0)

如果 $\sum^{i=2}_ {i\le n+1}i>m$ 输出 $-1$，否则构造一个满足条件的 $ANS$（可以随便构造，只要满足条件）。

可以参考的构造方案：$ans_i=i+1$（只要没有 $ans_i=1$，$m-1$ 就一定不能构造出来）。如果 $\sum{ans_i}<m$，$ans_n$ 补上 $m-\sum{ans_i}$

```cpp
#include<bits/stdc++.h>
typedef int int32;
#define int long long
using namespace std;
const int N = 1e4 + 5;
int n,m,t,ans[N];
int sum(int s,int t)
{
	return (s+t)*(t-s+1)/2;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		if(sum(2,1+n)>m)
			cout<<"-1\n";
		else
		{
			if(n==1)
				cout<<m<<"\n1\n";
			else
			{
				int tmp=sum(2,n+1);
				for(int i=1;i<=n;i++)
					ans[i]=i+1;
				if(tmp<m)
				{
					int cnt=n;
					while(tmp<m)
					{
						if(tmp-ans[cnt]+cnt<m)
							ans[cnt]+=m-tmp,tmp=m;
						else
							tmp-=ans[cnt]-cnt,ans[cnt]=cnt;
						cnt--;
					}
				}
				for(int i=1;i<=n;i++)
					cout<<ans[i]<<' ';
				cout<<'\n'<<m-1<<'\n';
			}
		}
	}
	return 0;
}
```

---

## 作者：WydnksqhbD (赞：0)

# [P7383 「EZEC-6」加减](https://www.luogu.com.cn/problem/P7383) 题解

## 思路

首先考虑无解：$1+2+3+\dots+n>m$ 时肯定无解啊，最小的情况都超了。

突破口在于 $m-1$ 是最难凑出来的，因为 $a$ 中如果没有 $1$，则是没有可能凑出 $m-1$ 的。

所以思路出来了：**不凑 $1$**，从 $2$ 开始，前 $n-1$ 项分别为 $2,3,4,\dots,n$，第 $n$ 项为 $m-(2+3+4+\dots+n)$。

## 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#define int long long

using namespace std;

int T, n, m;

int sum (int head, int tail) {
	return (head + tail) * (tail - head + 1) >> 1;
}

signed main () {
	for (cin >> T; T; -- T) {
		scanf ("%lld %lld", &n, &m);
		
		if (sum (2, n + 1) > m) {
			puts ("-1");
			continue;
		}
		
		for (int i = 2; i <= n; ++ i) {
			printf ("%d ", i);
		}
		
		printf ("%lld \n", n + 1 + m - sum (2, n + 1));
		printf ("%lld \n", m - 1);
	}
	
	return 0;
}
```

---

## 作者：Beep_Monkey (赞：0)

这道题有**无解**的情况：
$m<n\times(n+1)/2$ 时，无法分为 $n$ 个不相同的正整数，(从 $1$ 开始构造等差数列直到 $n$ ，若小于它的和，则有会重合的数字)

而所有 $<=m$ 的数字都能组成，最难构造的数是 $m-1$。

因为全选的和为$m$,要构造出 $m-1$,分割方案中就必须有$1$。

所以，为了尽可能的能构造出方案,则最优构造方案为 $2,3,4,5\cdots$ （每个数互不相同）。

```cpp
for(int i=2;i<=n;i++) printf("%d\n",i);
printf("%d\n%d\n",m+1-n*(n+1)/2,m-1);
```

# 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
int main(){
    scanf("%d",&t);
    while(t){
        scanf("%d%d",&n,&m);
        if(m*2<3*n+n*n) printf("-1\n");//判断是否无解
        else{
            for(int i=2;i<=n;i++)//最优构造
            	printf("%d\n",i);
            printf("%d\n%d\n",m+1-n*(n+1)/2,m-1);
        }
        t--;
    }
    return 0;
}
```


---

## 作者：Aw顿顿 (赞：0)

一道很有意思的构造题。

## 题意简述

给定 $n$ 和 $m$，需构造出一个序列 $a$，使得：

$$\sum\limits_{x=1}^{n}a_i=m$$

并且至少存在一个 $i\in[1,m]$ 不能通过这种方式获得：

$$\sum\limits_{x=1}^{n}k_i\times a_i\quad (k_i\in\{-1,0,1\})$$

## 解法简析

首先，显然有 $a_1+a_2+a_3+\cdots+a_{n-1}+a_n=m$。

对于这一组和为 $m$ 的正整数，对于任意一个非 $1$ 的数做出“不使用”或者“减去”操作，都会使得**所得小于 $m$**，这意味着：

**对于任意的一组数，当且仅当不存在 $a_i=1$ 的时候，我们无法构造出 $m-1$。**

并且对于存在 $1$ 的情况，我们仅仅需要不选择 $1$，就可以得到 $m-1$；而其它的数字，在感性上是容易得到的，因此为了确保 $m-1$ 不符合要求，我们仅仅需要构造出：

$$2,3,4\cdots,n-1,n,n+1$$

在这种情况下，如果总和小于 $m$，仅仅需要将最后一个数更改即可，可以满足不重复并且有不可构造的情况，所以我们得到一个结论：

$$\sum\limits_{x=2}^{n+1}x\le m$$

满足该条件时可以构造，反之不可。

## 代码

代码很丑，就不贴出来了。测评结果如下：

|编程语言|代码长度|用时|内存|
|:-----:|:------:|:-:|:--:|
|C++11|314B|13ms|640.00KB|

---

## 作者：infinities (赞：0)

一道构造题。

先看题，容易发现，题目实际上可以转化为：给定 $m$，把 $m$ 分为 $n$ 个互不相同的正整数，使得区间 $[1,m]$ 中至少有一个数无法被表示成 $m -\sum_{i=1}^na_i*k_i$，$0\le k_i\le 2$，那么，显然地，若我们分成的这 $n$ 个数中没有 $1$，则 $m - 1$ 无法被表示出来，是一组可行解。

那么，考虑最小的一组不含 $1$ 的正整数解，其和显然一定是 $\sum_{i=1}^n(i+1)$，所以如果这个和不大于 $m$，则可以把 $m$ 与该和的差加到最后一个数上，然后就构成了一组可行解。若和大于了 $m$，那么无解。

不想看证明的可以跳过。

-----

这个可以简单(并不严谨)证明一下。显然和最小的一组解是 $\sum_{i=1}^ni$，在最后一个数加上 $m$ 减去和。这一组解显然可以表示出所有 $[1,m]$ 的数，是一组非合法解。

继续，考虑把这组解中的 $[1,n]$ 中的任意一个数变成 $n+1$，使其和小于 $m$，不妨设这个改变的数原来值是 $x$。

接着，根据我们转化成的问题形式，发现对于这组解， $m-i$，$m-(i+1)$，$m-(i*2)$，$m-(i)*2-1$，$m-(i+1)*2$ 这些数都可以直接通过 $i$ 和 $1$ 这两个数表示出来，唯一不能直接通过这种方式表示的只有我们改变的 $x$ 所对应的 $m-x$，$m-(x*2)$，而这些也可以通过 $m-(x-1)-1$，$m-(x-1)*2-1*2$ 表示出来，于是可以发现，所有 $[1,m]$ 之间的数都可以表示出来，由此，原问题得证。

----

简单总结一下，步骤如下：

1. 计算 $sum=\sum_{i=2}^{n+1}i$，判断和是否不大于 $m$，大于则无解，小于则有解。

2. 输出 $[2,n]$ 和 $(n+1)+(m-sum)$，构造出解。

3. 输出无法被表示出的数 $m-1$。

代码就不给了，写起来太简单了。

---


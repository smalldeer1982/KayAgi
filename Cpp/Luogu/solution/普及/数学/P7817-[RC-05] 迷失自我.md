# [RC-05] 迷失自我

## 题目背景

[广告](http://119.27.163.117/problem/86)

## 题目描述

对于两个只包含 $7,9$ 的数字串 $S,T$，如果：

- $S,T$ 长度均为 $n$；
- $S$ 的字典序小于 $T$；
- 对于任意 $[l_1,r_1]$ 和 $[l_2,r_2]$（$1\le l_1\le r_1\le n$，$1\le l_2\le r_2\le n$，$l_1,r_1,l_2,r_2$ 为整数，两个区间不相同），设 $A_S$ 为将 $S$ 的第 $l_1\sim r_1$ 个字符顺次排列得到的十进制数，$A_T$ 为将 $T$ 的第 $l_1\sim r_1$ 个字符顺次排列得到的十进制数，$B_S$ 为将 $S$ 的第 $l_2\sim r_2$ 个字符顺次排列得到的十进制数，$B_T$ 为将 $T$ 的第 $l_2\sim r_2$ 个字符顺次排列得到的十进制数，有 $\gcd(A_S,B_S)=\gcd(A_T,B_T)$。

那么，就称 $(S,T)$ 是无法辨识的一对。比如，$S=7977$ 和 $T=7979$ 不是无法辨识的，因为取 $[l_1,r_1]=[1,4]$，$[l_2,r_2]=[2,2]$，则 $\gcd(A_S,B_S)=\gcd(7977,9)=3$，$\gcd(A_T,B_T)=\gcd(7979,9)=1$，有 $3\ne 1$。

求长度为 $n$ 的只含 $7,9$ 的数字串中有几对无法辨识。你只需求出答案对 $998244353$ 取模的值。

## 说明/提示

对于所有数据，$1\le T\le 10^4$，$1\le n\le 10^{18}$。

详细数据范围如下表：

| 测试点编号 | $n$ | $T$ | 分数 |
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1$ | $\le 10$ | $\le 10$ | $2$ |
| $2$ | $\le 10^{18}$ | $\le 10^4$ | $98$ |

## 样例 #1

### 输入

```
1
1```

### 输出

```
1```

# 题解

## 作者：Da_un (赞：3)

这道题在比赛中是第一题，所以理论上讲并不算很难，但看到题面，心中不免有些颤动。再看测试数据，一个测试点 $2$ 分，另一个有 $98$ 分，目测应该是一个规律题，但写了半天就是写不出来，直到赛后看了公开的题解才恍然大悟，所以我在这里更通俗的说一下解法，也是弥补一下当时的遗憾~~

### [题目传送门](https://www.luogu.com.cn/problem/P7817)

### 思路
- 对于第一个测试点，考虑了一下，直接暴力搜索，可以~~很轻松地~~拿到 $2$ 分。

- 对于第二个测试点，很显然第一种策略肯定是不行的，所以要换一种思维方式，因为字符串 $S$ 和 $T$ 都只是由 $7$ 或 $9$ 组成的，所以对于任意一个长度大于 $2$ 的字符串，串中一定存在一个数的出现次数大于 $1$，所以不难发现，两个重复出现的数的最大公约数一定等于这个这个数，这两个重复出现的数字也可以看做长度为 $1$ 的区间。因此，可以把串中所有满足最大公约数为 $7$ 和 $9$ 并且长度为 $1$ 的区间对拿出来组成两个集合，这两个集合就可以唯一确定这个串(不明白的可以自己举个例子写一下)。

所以对于一个长度小于 $2$ 的字符串，它不满足第二种方法，推一下的话都只有一对字符串无法识别。所以直接判断 $n$ 的范围直接输出对应答案即可。

### Code
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
inline long long read()
{
	long long s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') w=-1;
		ch=getchar();
	} 
	while(ch>='0'&&ch<='9'){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*w;
}
long long n,t;
void work()
{
	n=read();
	if(n>2)
		cout<<0<<endl;
	if(n<=2)	
		cout<<1<<endl; //推出的结果
}
int main()
{
	t=read();
	while(t--)
		work();
	return 0;
}
```
对于这道题，收获还是蛮多的~~

---

## 作者：约瑟夫用脑玩 (赞：2)

~~关于我读错题直接把 T1 跳了过后抢不到首A这件事~~

搞完 T2 才回来看 T1，然后发现怎么都读不懂样例。。。

重读了 $N$ 遍题后才提取到关键信息：

- $S$ 的字典序严格小于 $T$，那么 $S,T$ 严格不相同。
- 选出来用来辨识的两个区间不相同。

------------


$n=1$ 有 $S=7,T=9$，由于关键信息二而成立。

$n=2$ 有 $S=79,T=97$，不知道为什么反正就是成立。

$n\geq3$ 由于鸽笼原理必定有两 $7$ 或两 $9$ ，那么取所有区间对 $[l_1,r_1=l_1],[l_2,r_2=l_2]$ 满足 $S_{l_1}=S_{l_2}$ 或 $T_{l_1}=T_{l_2}$ 必定找到一组让其可以辨识。

答案：$[n\le2]$

Upd：听说加到主题库里了就来丢发题解。

---

## 作者：Coros_Trusds (赞：1)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15151742.html)

对于两个只包含 $7,9$ 的数字串 $S,T$，如果：

- $S,T$ 长度均为 $n$；
- $S$ 的字典序小于 $T$；
- 对于任意 $[l_1,r_1]$ 和 $[l_2,r_2]$（$1\le l_1\le r_1\le n$，$1\le l_2\le r_2\le n$，$l_1,r_1,l_2,r_2$ 为整数，两个区间不相同），设 $A_S$ 为将 $S$ 的第 $l_1\sim r_1$ 个字符顺次排列得到的十进制数，$A_T$ 为将 $T$ 的第 $l_1\sim r_1$ 个字符顺次排列得到的十进制数，$B_S$ 为将 $S$ 的第 $l_2\sim r_2$ 个字符顺次排列得到的十进制数，$B_T$ 为将 $T$ 的第 $l_2\sim r_2$ 个字符顺次排列得到的十进制数，有 $\gcd(A_S,B_S)=\gcd(A_T,B_T)$。

那么，就称 $(S,T)$ 是无法辨识的一对。比如，$S=7977$ 和 $T=7979$ 不是无法辨识的，因为取 $[l_1,r_1]=[1,4]$，$[l_2,r_2]=[2,2]$，则 $\gcd(A_S,B_S)=\gcd(7977,9)=3$，$\gcd(A_T,B_T)=\gcd(7979,9)=1$，有 $3\ne 1$。

求长度为 $n$ 的只含 $7,9$ 的数字串中有几对无法辨识。你只需求出答案对 $998244353$ 取模的值。

------------
话说这不是道橙题吗？感觉难度有误。

通过简单的枚举可以发现：

当 $n$ 大于 $2$ 时，答案为 $0$。

否则答案为 $1$。

我们来简单证明一下：

当一个只由 $7$ 和 $9$ 组成的字符串的长度大于 $2$ 时，那么一定有任一个数字出现超过 $1$ 次，故这两个重复出现的数字（可以看做区间长度为 $1$ 的字符串）的 $\gcd$ 一定等于这个数字。

对于某个字符串，把所有满足 $\gcd$ 为 $7$ 和 $9$ 的长度为 $1$ 的区间对拿出来组成两个集合，就可以确定一个字符串。

AC 代码：

```cpp
#include <iostream>
using namespace std;

int main(void)
{
	int T;
    cin >> T;
    
    while(T--)
    {
    	long long n;
        cin >> n;
        
        if(n <= 2)
		{
        	cout << 1 << endl;
		}else{
			cout<<0<<endl;
        }
    }
  	return 0;
}

---

## 作者：封禁用户 (赞：0)

一道巨水无比的规律题，题解区竟然还开着，那我也来丢一篇吧题解！  
题目传送>>[P7817](https://www.luogu.com.cn/problem/P7817)。  
### 题目分析：  
直接找规律:  
- 当 $n=1$ 时，无法取出两个不相同的区间，两字符串无法辨识，答案为 $1$;  
- 当 $n=2$ 时，两字符串为 $\texttt{79}$ 和 $\texttt{97}$，取两个长度为 $1$ 的区间，则 $\gcd(7,9)=1= \gcd(9,7)$，两字符串无法辨识，答案为 $1$。  
- 当 $n>2$ 时，因为这两个不同的字符串的组成元素只有 $\texttt{7}$ 和 $\texttt{9}$，所以此时 $\texttt{7}$ 和 $\texttt{9}$ 中肯定会有一个出现不低于两次，在里面取长度为 $1$ 的区间，可取造成 $\gcd(7,9)=1$，$\gcd(7,7)=7$，$\gcd(9,9)=9$ 三种情况中的任意两种，字符串可辨识，答案为 $0$。  

### Code:  
#### C Version:  
```cpp  
#include <cstdio>
int main(){
	long long t, n;
	scanf("%lld", &t);
	while (t--){
		scanf("%lld", &n);
		puts(n <= 2 ? "1" : "0");
	}
	return 0;
}
```
#### Python Version:  
```python
t=int(input())
for i in range(t):
	print("1") if ((int(input()))<=2) else print("0")
```
### 评测结果：  
![](https://cdn.luogu.com.cn/upload/image_hosting/734t5bkv.png)  
***  
企鹅的题解到此结束，祝各位 OIers 进步 ++~

---

## 作者：Buried_Dream (赞：0)

看到数据范围到 $1e18$ 就知道这是一道找规律的题。


## 题意：

对于两个只包含 $7 和 9$ 的数字串 `S` 和 `T`。


如果：


`S` 和 `T` 长度均为 $n$；


`S` 的字典序小于 `T`；

找到无法辨识的 `s` 和 `T` 个数， 答案对 $998244353$ 取模。

## 思路：

既然这是一道规律，，对于长度大于 $2$ 的串，那么 $7$ 和 $9$ 一定有一个至少出现过 $2$ 两遍，那这两个数的最大公约数一定等于这两个数其中的一个，所以当这个串长度大于 $2$ ，答案就是 $0$, 否则答案就是 $1$。

## AC code：

```cpp
/*
Work by: 看我后面——
goal： Cheat points
algorithm：？？？
thinking support：？？？
*/
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<queue>
#include<stack>
#include<cmath>
#include<cstring>
#define int long long
#define il inline
#define re register
#define inf 0x3f3f3f3f
#define FJH 1314
using namespace std;

const int maxn = 1e6 + FJH;
const int MAXN = 2e3 + 32;
inline int read(){//快读 
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-'){w = -1;}ch = getchar();}
	while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
	return s*w;
}
il void print(int x){//快写 
	if(x < 0) putchar( '-' ),x = -x;
	if(x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
signed main(){
	int t;
	t = read();//数据组数 
	for(int i = 1; i <= t; i++) {
	int  n = read();//串的长度 
	if(n > 2) cout <<"0"<<endl;//规律 
	else cout <<"1"<<endl;
	}
	return 0;
}

```




---

## 作者：I_am_rubbish (赞：0)

# P7817 [RC-05] 迷失自我
## 首先
看这题面发现这题不是暴力就是找规律，那简单嘛，管他有没有规律 ， 先搞一发暴力看看。
## 然后
看看数据范围，好家伙 2 个点！
一个到 10 ，一个到 $1e18$  ,不要想这种题 2 分给暴力 ， 98 分给规律 。 

大佬可能一眼就看出了规律 ， 可我不是大佬啊 。 所以我们乖乖打暴力 ， 会调试就调试 ， 不会就在程序中输出 （ ~~比如我~~ ）      
     
     还有就是测试的 n 别太大，不然今天你很可能吃到烤肉。
## 最后
~~暴力打完一发上去 2 分到手~~

发现了一个显而易见的规律发现你输进去的 n 在 $<=2$ 时只会输出 $1$ ， 在 $>2$ 时只会输出 $0$

好，规律明显直接上代码
```c
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x;
signed main()
{
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld", &x);
        puts(x <= 2 ? "1" : "0");
    }
    return 0;
}

```


---

## 作者：一只书虫仔 (赞：0)

#### Description

> 求长度为 $n$，只由 $7$ 和 $9$ 组成，任取两个不等区间 $[l_1,r_1]$ 和 $[l_2,r_2]$ 都有 $\gcd(S_{[l_1,r_1]},S_{[l_2,r_2]})=\gcd(T_{[l_1,r_1]},T_{[l_2,r_2]})$ 的字符串对 $(S,T)$ 的个数，其中 $S_{[l,r]}$ 为字符串 $S$ 的第 $l$ 个字符到第 $r$ 个字符顺次排列形成的十进制数。

#### Solution

诈骗题（大嘘）

因为字符串只由 $7$ 和 $9$ 组成，因此只要 $n>2$，字符串里就有 $7$ 或 $9$ 出现超过一次，我们又有 $\gcd(n,n)=n$，因此我们可以考虑在两个字符串里取长度为 $1$ 的区间，那么一共就有三种取值：

- $\gcd(7,7)=7$；
- $\gcd(7,9)=1$；
- $\gcd(9,9)=9$；

又因为两个字符串是不同的，因此一定可以从以上三种取值中挑出两种使用。

对于 $n \le 2$，我们可以尝试枚举一下：

- $n=1$，字符串对 $(7,9)$ 找不出来满足要求的区间，因此可以；
- $n=2$，字符串对 $(79,97)$ 可以选取两个长度为 $1$ 的区间，使得：

$$\gcd(7,9)=\gcd(9,7)$$

因此：

- 当 $n \le 2$ 时，输出 $1$；
- 当 $n >2$ 时，输出 $0$。

#### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	int t;
	scanf("%d", &t);
	while (t--) {
		long long n;
		scanf("%lld", &n);
		if (n <= 2) puts("1");
		else puts("0");
	}
	return 0;
}
```

---

## 作者：luozhichen (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7817)


------------
首先，我把目光放在了数据点上，一个 $2$ 分，一个 $98$ 分。一看暴力就只能拿 $2$ 分。但是我们把暴力程序打出来，然后自己手造数据发现，只要 $n$ 大于 $2$ 时，输出的都是 $0$。这是偶然吗？其实不是。接下来我们就来证明 $n > 2$ 时答案都是 $0$。

**证明：**
一个长度大于 $2$ 的串，一定存在一个数字（$7$ 或 $9$）出现次数大于 $1$。那么，令 $l_1 = r_1 = pos_1$,$l_2 = r_2 = pos_2$，得到的 gcd 一定等于这个数字。因此，我们把某个串中所有满足 gcd 为 $7$ 和 $9$ 的长度为 $1$ 的区间对拿出来组成两个集合，这两个集合就可以唯一确定这个串。

所以代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n;//不开long long 见祖宗
int main(){
	cin >> t;
	for(int i = 1;i <= t;i++){
		cin >> n;
		if(n <= 2){
			cout << "1" << endl;
		}else{
			cout << "0" << endl;
		}
	}
	return 0;
}
```


---

## 作者：lol_qwq (赞：0)

# P7817 题解

**思路**

本题内容比较抽象，所以整理如下：

- 两个数均为 $7$ 和 $9$ 组成长度为 $n$ 的数串。

- 随便从两个数串截取子数串，可以使得 $\gcd(S_{zi},S)$ $=$ $\gcd(T_{zi},T)$。

我们枚举一下：

- 若 $n = 1$，$S = 7,T = 9$，根据条件二满足，只有 $1$ 种。

- 若 $n = 2$，$S = 79,T = 97$，无论取 $\gcd(7,79)$ 还是 $\gcd(9,97)$ 均等于 $1$，只有 $1$ 种。

- 若 $n \ge 3$，那 $7$ 或 $9$ 必有 $2$ 个，所以 $\gcd(7777777779,9) = 9$ 是和 $\gcd(7777777779,7) = 1$ 不同，因此 $0$ 种。

**代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    long long a,b;
	cin >> a;
	while(a--){
		cin >> b;
		if(b <= 2){
			cout << "1" << endl;
		}else{
			cout << "0" << endl;
		}
	}
	return 0;
}
```

---


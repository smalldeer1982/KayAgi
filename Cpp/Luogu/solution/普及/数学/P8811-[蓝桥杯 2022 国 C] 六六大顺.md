# [蓝桥杯 2022 国 C] 六六大顺

## 题目描述

六六大顺，本指农历六月初六。多用于祝福中年人士家庭幸福，工作顺利，事业有成，身体健康。源自《左传》“君义，臣行，父慈，子孝，兄爱，弟敬，此数者累谓六顺也。”

$6$ 在我国自古以来是一个吉祥的数字，定义数列 $A = (a_1,a_2,\cdots,a_i,\cdots)$，其中 $a_1 = 6, a_2 = 66, \cdots, a_i = 10\cdot a_{i−1}+6$。

定义一个数列 $B = (b_1,b_2,\cdots,b_i,\cdots)$，其中 $b_1 = 6 \times 6, b_2 = 66\times66, \cdots, b_i = a_i \times a_i$。

现在小蓝想知道数列 $B$ 的前 $n$ 项的和是多少，你能帮帮小蓝吗？

## 说明/提示

**【样例说明】**

$b_1 = 6×6 = 36,b_2 = 66×66 = 4356,b_3 = 666×666 = 443556$，所以前三项的和为 $36 + 4356 + 443556 = 447948$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$1≤n≤100$；

对于 $50\%$ 的评测用例，$1≤n≤10^5$；

对于所有评测用例，$1\le n\le 10^7$。

蓝桥杯 2022 国赛 C 组 H 题。

## 样例 #1

### 输入

```
3```

### 输出

```
447948```

# 题解

## 作者：0x282e202e2029 (赞：17)

# P8811 [蓝桥杯 2022 国 C] 六六大顺 题解

- 本题第一篇给了代码的题解

老规矩，[题目传送门](https://www.luogu.com.cn/problem/P8811)

## 思路

$$\begin{aligned}
S &= \sum _ {i = 1} ^ {n} {\underbrace{666 \cdots 66}_{\text{i 个 6}}} ^ 2 \\ &= \sum _ {i = 1} ^ {n} {(\frac{2}{3} \cdot \underbrace{999 \cdots 99}_{\text{i 个 9}})} ^ 2 \\ &= \sum _ {i = 1} ^ {n} \frac{4}{9} \cdot (10 ^ i - 1) ^ 2 \\ &= \frac{4}{9} \cdot \sum _ {i = 1} ^ {n} (10 ^ {2i} - 2 \cdot 10 ^ i + 1) \\ &= \frac{4}{9} \cdot (\underbrace{101010 \cdots 1010}_{\text{n 个 10}}0 + \underbrace{222 \cdots 22}_{\text{n 个 2}}0 + n)
\end{aligned}$$

见 $n ≤ 10 ^ 7$ 识高精。

但是，如果你直接用封装好的板子，MLE。

大佬们又说了：把 `int` 换成 `char`！

换了，TLE。

那怎么办？

我们发现，现在常见的高精度模板都使用了 `vector` 这个常数极大的东西，反而没有用 `int` 数组模拟的。

因此，让我们回归原始，再运用几个卡常小妙招，就能 AC 了。

## AC 代码

```cpp
#include <stdio.h>
using namespace std;
const int MAX = 2e7 + 1;
int n, arr[MAX];//arr模拟高精数组
int main()
{
    scanf("%d", &n);
    arr[0] = 4 * n % 10, arr[1] = 4 * n / 10;//将4n存入数组
    for (int i = 1; i <= n; ++i)//++i卡常小妙招（bushi
	{
        arr[i << 1] = 4, arr[i] -= 8;//将1010…100，22…20的4倍加给数组
        arr[i + 1] += arr[i] / 10, arr[i] %= 10;
        if (arr[i] < 0)
        {
            arr[i] += 10, --arr[i + 1];
        }//进退位
    }
    for (int i = n + 1; arr[i] < 0; ++i)
    {
        arr[i + 1] += arr[i] / 10, arr[i] %= 10;
        arr[i] += 10, --arr[i + 1];
    }//单纯进位 
    for (int i = 2 * n - 1; ~i; --i)
	{
        arr[i] += 10 * arr[i + 1];
        putchar(arr[i] / 9 + '0');
        arr[i] %= 9;
    }//一边输出一边除以9 
    return 0; 
}
```

[AC 记录](https://www.luogu.com.cn/record/113013193)

---

## 作者：Zvelig1205 (赞：8)

数学题。

简化题意：

对于数列 $\{b_n\}$，满足：

$\begin{array}{c}
b_n=&\underbrace{66\cdots6} \\
&n\text{个}6
\end{array}$

求前 $n$ 项和。

数据范围 $n\le10^7$，显然直接暴力高精的话，乘是 $O(n^2)$ 的。就算用 FFT 也是 $O(n\log n)$，~~更何况我不会~~。

所以这题应该是找规律。

让我们一起 % 找规律大佬 @yangshiyu10![](https://s1.ax1x.com/2022/11/13/zFuk6I.png)。

说实话，$66\times66$ 没有什么技巧性的方法，但学过小学数学的都知道，$99\times 99=(100-1)\times (100-1)$，就可以利用完全平方公式计算。

所以有：

$$\begin{array}{ll}
66\times66&=\dfrac{2}{3}\times 99\times \dfrac{2}{3}\times 99\\\\
&=\dfrac{4}{9}\times (100-1)^2\\\\
&=\dfrac49\times (100^2-2\times 100+1)
\end{array}$$

那么就有 $b_n=\dfrac{4}{9}\times({10^n}^2-2\times10^n+1)$。

那么前 $n$ 项和怎么求呢？

显然是数列求和中的[分组求和](https://www.cnblogs.com/Zvelig1205/p/16856812.html)。

不过这里好像并不需要用到求和公式，毕竟需要用到高精，可以直接在数组中构造：

$${10^n}^2=101010\cdots10100,2\times 10^n=222\cdots220$$

而高精代码，我直接拿的[之前封装好的板子](https://zhuanlan.zhihu.com/p/576090862)。

除去我的缺省源和高精板子之后，主函数的代码是这样的：

```cpp
int n;
Int _2,_1,_0;//分别代表二次项，一次项和常数项。
int main()
{
	n=re();
	_0=int_to_Int(n);
	_1=int_to_Int(0);
	_2=int_to_Int(0);
	for(int i=1;i<=n;i++)
		_2[i<<1]=1,_1[i]=2;
	_1.__len=n,_2.__len=n<<1;
	_0=_0+_2-_1;
	_0=_0/9;_0=_0*4;
	wR(_0,'\n');
	return 0;
}
```

如果你直接将这个 `namespace` 改改数组大小放上去，那么恭喜你，会 MLE。

考虑到数组的每一位只会存一个十进制个位数，所以用 `int` 简直是暴殄天物，用 `char` 就可以了。

完整代码比较长，这里就不贴了。其实就是把板子拿过来，主函数放上去。

---

## 作者：Imakf (赞：7)

首先，我们可以把所有的 $6$ 替换成 $1$，然后最后把答案乘上 $36$。

然后回忆小学竖式如何计算 $111\times111$：

```
   111
 x 111
------
   111
  111
 111
------
 12321
```

实际上就是做了 $k$ 次下标连续、区间长度均为 $k$ 的区间加 $1$，也就是做了 $O(1)$ 次的区间加等差数列。于是我们可以直接二阶差分模拟整个过程。复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>

const int MX = 2e7 + 23;

using namespace std;

int n;
long long s[MX];

int main() {
  std::cin >> n;
  for (int i = 1; i <= n; ++i) {
    s[1] += 36;
    s[i + 1] -= 2 * 36;
    s[2 * i + 1] += 36;
  }

  for (int i = 1; i < MX ; ++i)
    s[i] += s[i - 1];
  for (int i = 1; i < MX ; ++i)
    s[i] += s[i - 1];
  

  int MAX = 0;
  for (int i = 1; i < MX; ++i) {
    s[i + 1] += s[i] / 10;
    s[i] %= 10;
    if (s[i]) MAX = i;
  }
  for (int i = MAX; i >= 1; --i)
    cout << s[i];
  cout << endl;
  return 0;
}
```

---

## 作者：Nuyoah_awa (赞：4)

### 题目大意

给定一个数 $n$ 请你求出数列 $B$ 的前 $n$ 项的和是多少。

数列 $B$ 的第 $n$ 项为 ${\underbrace{666\cdots666}_{\text{n个6}}}^2$。

### 题目分析

这道题的数据范围 $n \le 10 ^ 7$ 很明显是高精做，但是如果直接使用高精度计算的话，时间复杂度是 $\mathcal O(n ^ 3)$ 的（枚举 $n$ 项，每项计算平方）。

于是，我们可以考虑将原式变形：

$$\because B_n = {\underbrace{666\cdots666}_{\text{n个6}}}^2 = {\underbrace{666\cdots666}_{\text{n个6}}} \times {\underbrace{666\cdots666}_{\text{n个6}}}$$

$$\therefore B_n = {\underbrace{999\cdots999}_{\text{n个9}}} \times \dfrac{2}{3} \times {\underbrace{999\cdots999}_{\text{n个9}}} \times \dfrac{2}{3}$$

$$\because (a - 1) ^2 = a^ 2  - 2 \times a + 1$$

$$\therefore B_n = (10 ^ n - 1) ^ 2 \times \dfrac{4}{9}  = (10 ^ {2\times n} - 2 \times 10 ^ n + 1) \times \dfrac{4}{9}$$

$$\therefore \sum\limits_{i = 1}^{i \le n}B_i = (\sum_{i=1}^{i\le n} 10^{2 \times i} - 2 \times \sum_{i=1}^{i \le n}10 ^ i + n)\times \dfrac{4}{9}$$

然后我们可以分别计算表达式中的三个值，对于 $\sum\limits_{i=1}^{i\le n} 10 ^ {2 \times i}$ 是一个形如 $\underbrace{101010\cdots10}_{\text{n个10}}0$ 的数字，对于 $2 \times \sum\limits_{i=1}^{i \le n}10 ^ i$ 是一个形如 $\underbrace{222\cdots222}_{\text{n个2}}0$ 的数字，最后高精求解的时间复杂度是 $\mathcal O(n)$ 的。

> PS：这是我们校内模拟赛的一道原题，是一道很好的高精题，很适合在大考前复习高精。

---

## 作者：HEzzz (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8811)

## 解析

我们知道的有 $A_n=\begin{matrix}\underbrace{666 \cdots 6}\\n \text{个} 6\end{matrix}$ 和 $B_n=A_n \times A_n$。

所以 

$$B_n=\begin{matrix}\underbrace{666 \cdots 6}\\n \text{个} 6\end{matrix}\times \begin{matrix}\underbrace{666 \cdots 6}\\n \text{个} 6\end{matrix}$$

$$B_n=\frac{2}{3}\times \begin{matrix}\underbrace{999\cdots 9}\\n \text{个} 9\end{matrix}\times \frac{2}{3}\times \begin{matrix}\underbrace{999\cdots 9}\\n \text{个} 9\end{matrix}$$

$$B_n=\frac{4}{9}\times (10^n-1)^2$$

$$B_n=\frac{4}{9}\times (10^{2n}-2\times 10^n+1)$$

到了这一步，我们就可以把循环给套进去了

$$\sum_{i=1}^{n}B_i=\frac{4}{9}\times \sum_{i=1}^{n}(10^{2i}-2\times 10^i+1)$$

把循环放进括号内则变成

$$\sum_{i=1}^{n}B_i=\frac{4}{9}\times (\sum_{i=1}^{n}10^{2i}-\sum_{i=1}^{n}2\times 10^i+n)$$

结束化简。

可以容易发现 $\sum_{i=1}^{n}10^{2i}=\begin{matrix}\underbrace{101010\cdots 10}0\\n \text{个} 10\end{matrix}$，而 $\sum_{i=1}^{n}2 \times10^i=\begin{matrix}\underbrace{222\cdots 2}0\\n \text{个} 2\end{matrix}$。这两个式子可以直接用字符串去得到，最后高精度来做运算。

综上所述

$$\sum_{i=1}^{n}B_i=\frac{4}{9}\times(\begin{matrix}\underbrace{101010\cdots 10}0\\n \text{个} 10\end{matrix}-\begin{matrix}\underbrace{222\cdots 2}0\\n \text{个} 2\end{matrix}+n)$$

## 后记

这道题可以起到复习高精度算法和一些常用的套路和公式的作用，完结撒花。

---

## 作者：Day_Tao (赞：3)

# P8811 [蓝桥杯 2022 国 C] 六六大顺 题解


题目描述：求 $6\times6+66\times66+666\times666\cdots$ 的前 $n$ 项之和。

我看了看似乎没有我这样的找规律的题解，就来氵一个。

首先，我们可以根据题意模拟一下：
```
                  3 6     1                 6*6
               4 35 6     2               66*66
            4 43 55 6     3             666*666
         4 44 35 55 6     4           6666*6666
      4 44 43 55 55 6     5         66666*66666
   4 44 44 35 55 55 6     6       666666*666666
4 44 44 43 55 55 55 6     7     6666666*6666666
```
由于直接整数组要 MLE，所以我直接把两个数组合并为一个了，（~~为什么高精可以压位这样的模拟不能压位呢~~）用十位和个位分别表示，可以认为是一百进制，对于输出没有什么影响。设 $6$ 的那列为第 $1$ 列。

然后可以发现这是**有一定的规律**的：

第 $1$ 列全都是 $6$；$5$ 从第 $2$ 列开始呈三角形分布，并且随着列数的递增而递减；$3$ 都分布在 $5$ 的上面；$5$ 一共持续了 $n-1$ 列，$3$ 一共持续了 $n$ 列；$4$ 从第 $4$ 列开始，个数与列数随着行数的递增而递增；最后两列则只有 $4$。

$5$ 和 $3$ 处理起来比较容易，$4$ 的话就有些麻烦：根据模拟出来的数据，由于我是用一个变量储存两个数字的，从 $a_{3}$ 开始，容易发现只针对于 $4$ ，前半段运算可以是$4 \times m \times 10+4 \times m$，也就是 $44 \times m$（$m$ 是未知数），所以只需要在对应变量中逐个加 $44$ 就行了。后半段也差不多，只是在加 $44$ 的基础上再加了一个 $4$。所以这时我们就需要一个前段和后段的中间值，也就是 $mid$。再次找规律，我们就可以发现，当 $n$ 为奇数时，$mid=(n+1)/2+1$；当 $n$ 为偶数时，$mid=n/2+1$。所以，我们只需要再开一个循环，针对 $a$ 数组，从 $3$ 开始循环到 $mid$，再从 $mid+1$ 循环到 $n$ 就可以了。至于 $a_{n+1}$ 就是 $4$。

最后再处理进位，大功告成~。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10000050],x,y,sum,mid;
long long num;
int main() {
	scanf("%d",&n);
	a[1]=n*6;
	a[n+1]=4;
	for(int i=1; i<=n; i++) { //处理3和5
		if(i%2==1)
			a[(i+1)/2+1]+=3,a[(i+1)/2+1]+=5*(n-i);
		else
			a[i/2+1]+=3*10,a[(i+1)/2+1]+=5*10*(n-i);    //处理个位和十位
	}
	if(n%2==1) //处理4
		mid=(n+1)/2+1;
	else
		mid=n/2+1;   //处理mid
	for(int i=3; i<=mid; i++)
		a[i]+=44*(i-2);
	for(int i=mid+1; i<=n; i++)
		a[i]+=(n-i+1)*44+4;
	a[2]=a[2]+a[1]/10;    //因为a[1]是10进制，所以特殊处理
	a[1]%=10;
	for(int i=2; i<=n; i++) {  //100进制处理
		if(a[i]>=100) {
			a[i+1]+=a[i]/100;
			a[i]%=100;
		}
	}
	printf("%d",a[n+1]);
	for(int i=n; i>1; i--) {
		if(a[i]<=9)
			printf("0%d",a[i]);  //100进制下十位为0要补0
		else
			printf("%d",a[i]);
	}
	printf("%d",a[1]);
	return 0;
}
```


---

## 作者：__Kyw666__ (赞：2)

## 题意解释
给你一个数列 $B$，其中 $b_{1} = 6 \times 6,b_{2} = 66 \times 66,b_{3} = 666 \times 6666$。以此类推。  
求数列 $B$ 前 $n$ 项的和。

## 思路分析
先来看看数列 $B$ 第 $n$ 项的算式：$$\underbrace{66…66}_{\text{n 个 6}}\times\underbrace{66…66}_{\text{n 个 6}} $$。  
太难算了，我们变换一下：$\underbrace{11…11}_{\text{n 个 1}}\times\underbrace{11…11}_{\text{n 个 1}} \times 36$。  
好了，接下来看看 $\underbrace{11…11}_{\text{n 个 1}} \times \underbrace{11…11}_{\text{n 个 1}} $ 怎么算。  
用一下计算器，来找规律。

```
1*1=1
11*11=121
111*111=12321
1111*1111=1234321
11111*11111=123454321 
```
很好找的规律，来总结一下：  
设乘数的位数为 $n$。
* 算式结果的位数为 $2n - 1$。
* 从左往右看，第一位到第 $n$ 位从 $1$ 开始递增到 $n$，再从第 $n$ 位到第 $(2n-1)$ 位递减到 $1$。

计算 $\underbrace{11…11}_{\text{n 个 1}} \times \underbrace{11…11}_{\text{n 个 1}} $的代码如下：

```cpp
for(int i=1;i<=n;i++)
    num[i]=i;
int j=n-1;	
for(int i=n+1;i<2*n;i++)
{	
    num[i]=j;
    j--;
}
```
但是，这个代码很明显不对。  
这个代码并没有考虑进位，所以接下来，我们要把进位处理好。  
换句话说，就是把这个数变成十进制数。  
还要加上下面的代码。

```cpp
int jinwei=0; 
bool f=0;
for(int i=1;i<2*n;i++)
{
    num[i]+=jinwei;
    if(num[i]>=10)
    {
        f=1;
        jinwei=num[i]/10;
        num[i]%=10;
    }
    else if(f==1) break;
}
```

温馨提示：  
* 记得乘上 $36$。
* 是**前** $n$ 项，而代码展示的是**第** $n$ 项的做法。
    
结束！

---

## 作者：eb0ycn (赞：2)

# [P8811 [蓝桥杯 2022 国 C] 六六大顺](https://www.luogu.com.cn/problem/P8811) 题解


## 做法：压位高精度

思路其他几篇题解讲的已经很明白了，但我没找到用压位高精度实现的。

众所众知，高精度就是模拟竖式，用数组存储每一位上的数字，然后分别计算，并且逢十进一。

但是，问题就在于“逢十进一”。众所周知，`int` 类型能存储大约 $2 \times 10^9$ 范围的数。这时，数组的每一位只保存一个数字就太浪费了，但凡数据大一点，就会爆空间。于是，我们就跟资本家一样，充分利用资源。让数组的每一位存储四位数，能极大地节省空间。此时你可以当成这是万进制下的高精度。

需要注意的是，压位高精度下，最高位输出时不用考虑，后面几位记得补零！

## 上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int mod=10000,N=5000001;// 2e7/4=5e6。
int ck;//表示数组的有效大小。
int c[N],po1,po2,n,ret;
void write()//输出的时候除以9，用到高精除低精。
{
	ret=c[ck];
	if(ret/9)printf("%d",ret/9);//如果最高位比9小，就会输出0，此时需要特判。
	ret%=9;
	for(int i=ck-1;~i;--i)
	{
		ret=ret*mod+c[i];
		printf("%04d",ret/9);//补0。
		ret%=9;
	}
}
int main()
{
	scanf("%d",&n);
	c[0]=(n<<2)%mod;
	c[1]=(n<<2)/mod;//先加4n。
	ck=n>>1;//数组最大长度，自己推一下。
	po1=400,po2=80;//直接四倍整上！
	n<<=1;
	for(ll i=2;i<=n;++i)
	{
		if(!(i&3))po1/=mod; //每个四位区间开始时，因数需要重置。
		if(!(i&1))c[i>>2]+=po1,po1*=100;
		if(c[i>>2]>=mod)c[(i>>2)+1]+=c[i>>2]/mod,c[i>>2]%=mod;
	}//先进行加法操作。
	n>>=1;
	for(ll i=1;i<=n;++i)
	{
		if(!(i&3))po2/=mod;
		c[i>>2]-=po2;
		po2*=10;
		while(c[i>>2]<0)--c[(i>>2)+1],c[i>>2]+=mod;
	}//这里是减法操作。
	while(!c[ck]&&ck)--ck;//去前导0。
	write();
	return 0;
}
```


---

## 作者：__UrFnr__ (赞：1)

**题目大意**：

数组 $B$ 的第 $i$ 项等于 $\underbrace{666···666}^2 $（$i$ 个 $6$）

然后将这个数组的前 $n$ 项加起来输出。

**题目思路**：

首先必须用高精，否则会爆。

数组 $B$ 的第 $n$ 项公式为：

### $\frac{4}{9} \times (10^n-1)^2$

转化到题目，求的就是：

### $\sum_{i=1}^{n} \frac{4}{9} \times (10^i-1)^2$

简化后就是：

### $\frac{4}{9}\sum_{i=1}^{n}\times (10^{2i}-2\times 10^i+1) $

然后用高精度运算实现即可。

---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

给定 $n$，求：

$$6^2 + 66^2 + 666 ^2 + \cdots + {\underbrace{666\cdots666}_\text{n个6}}^2$$

## 思路

对于第 $n$ 项的通项公式显然是：

$$\frac{4}{9}(10^n-1)^2$$

所以题目变成了求：

$$\sum_{i=1}^{n}\frac{4}{9}(10^i-1)^2$$

$$=\frac{4}{9}\sum_{i=1}^{n}(10^i-1)^2$$

$$=\frac{4}{9}\sum_{i=1}^{n}(10^{2i}-2 \times 10^i + 1)$$

形式化的：

$$=\frac{4}{9}({\underbrace{1010\cdots10100}_\text{n个1}} + {\underbrace{222\cdots220}_\text{n个2}} + n)$$

利用[高精度](https://www.luogu.com.cn/paste/587vee21)计算即可。但是注意位数太大，用 short int 也会爆 MLE，建议使用 char。

---

## 作者：chengjindong (赞：0)

[题目](https://www.luogu.com.cn/problem/P8811)

有题目可知：$B_n=\underbrace{666  666}_{\text{n 个 6}}\times\underbrace{666 \cdots 666}_{\text{n 个 6}}$。

但 $\underbrace{666 \cdots 666}_{\text{n 个 6}}\times\underbrace{666 \cdots 666}_{\text{n 个 6}}$ 十分难算，还没有规律，可以把它转化成：$\underbrace{111 \cdots 111}_{\text{n 个 1}}\times\underbrace{111 \cdots 111}_{\text{n 个 1}} \times 36$。

找规律：

$$1 \times 1 =1$$
$$11 \times 11 =121$$
$$111 \times 111 =12321$$

可以发现：$\underbrace{111 \cdots 111}_{\text{n 个 1}}\times\underbrace{111 \cdots 111}_{\text{n 个 1}} = \underbrace{1234 \cdots 4321}_{\text{2n-1 位}}$。

求和，再乘 $36$ 即可。

但这么做会超时，所以不能这么做。

另一种方法：

$$\begin{aligned}
S &= \sum _ {i = 1} ^ {n} {\underbrace{666 \cdots 66}_{\text{i 个 6}}} ^ 2 \\ &= \sum _ {i = 1} ^ {n} {(\frac{2}{3} \times \underbrace{999 \cdots 99}_{\text{i 个 9}})} ^ 2 \\ &= \sum _ {i = 1} ^ {n} \frac{4}{9} \times (10 ^ i - 1) ^ 2 \\ &= \frac{4}{9} \times \sum _ {i = 1} ^ {n} (10 ^ {2i} - 2 \times 10 ^ i + 1) \\ &= \frac{4}{9} \times (\underbrace{101010 \cdots 1010}_{\text{n 个 10}}0 - \underbrace{222 \cdots 22}_{\text{n 个 2}}0 + n)
\end{aligned}$$

#### 注意：这题要高精度。

---

## 作者：yegengghost (赞：0)

众所周知，$6＝\frac{2}{3}\times 9 =\frac{2}{3} \times (10-1)$。

那么我们就可以把这个规律放入式子中，变成：


$$\sum_{i=1}^N \underbrace{666 \cdots 666^2}_{i \text{个} 6}=\frac{4}{9}\times\sum_{i=1}^N {(10^i-1)}^2$$

到这里，我们已经就能知道要怎么救一下了吧：高精度。

但先别急~~我先急~~，我们这个式子就这么做太麻烦了，再化一下：

$$\text{原式}=\frac{4}{9} \times \sum_{i=1}^N (10^{2i}-2 \times 10^i+1)= \frac{4}{9} \times (\underbrace{1010\cdots1010}_{n\space \text{个} \space 10}- \underbrace{22\cdots 220}_{n \space\text{个}\space 2 \space\text{加上一个}\space 0}+n)$$

然后用高精度运算即可。

---

## 作者：SunnyLi (赞：0)

## 思路

这道题暴力法肯定不能 AC 的，所以我们需要找规律。

给定一个数 $n$，题目所需要求的就是

$$\sum_{k=1}^{n}{\underbrace{66\cdots6}_{k\texttt{个}6}}^2$$

我们先举一个例子，比方说 $666^2$

$$
\begin{aligned}
666^2 &= (\frac{2}{3}\times999)^2 \\
&= \frac{4}{9}\times (1000-1)^2 \\
&= \frac{4}{9}\times (1000^2-2\times1000\times1+1^2)
\end{aligned}
$$

那么

$$
\begin{aligned}
\sum_{k=1}^{n}{\underbrace{66\cdots6}_{k\texttt{个}6}}^2 &= \sum_{k=1}^{n} {\frac{4}{9}}(10^{2k}-2\times10^k+1)\\
&= \frac{4}{9}\sum_{k=1}^{n} (10^{2k}-2\times10^k+1)\\
&= \frac{4}{9}({\underbrace{1010\cdots1010}_{n\texttt{个}10}}0+{\underbrace{22\cdots22}_{n\texttt{个}2}}0+n)
\end{aligned}
$$

最后就是高精度了，推荐使用 char 可能不会 TLE 哦！

---


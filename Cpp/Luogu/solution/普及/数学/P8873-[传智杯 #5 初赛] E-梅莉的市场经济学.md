# [传智杯 #5 初赛] E-梅莉的市场经济学

## 题目背景

梅莉这个学期选修了经济学。但是主修心理学的她实在不擅长经济领域的分析，为此她时常抱怨自己学不会，想退课。

但是如果现在退掉的话这学期的学分就不够啦，因此她根据“梦中”的经历，“胡诌”了一个简单到不现实的市场模型，并依据这个模型编起了 essay。为了方便地编出图表，她需要写一个程序来查询每个时刻的市场贸易差。

## 题目描述

市场每一天的贸易差可以视为一个有周期性规律的数列 $a$：$\color{red}[0],\color{blue}[0,\allowbreak 1,\allowbreak 0,\allowbreak -1,\allowbreak 0],\color{red}[0,\allowbreak 1,\allowbreak 2,\allowbreak 1,\allowbreak 0,\allowbreak -1,\allowbreak -2,\allowbreak -1,\allowbreak 0],\allowbreak \color{blue}[0,\allowbreak 1,\allowbreak 2,\allowbreak 3,\allowbreak 2,\allowbreak 1,\allowbreak 0,\allowbreak -1,\allowbreak -2,\allowbreak -3,\allowbreak -2,\allowbreak -1,\allowbreak 0]\dots$ 具体而言，$a$ 可以被分为无穷段，第 $i$ 段的内容为 $\{0,\allowbreak 1,\allowbreak \cdots,\allowbreak i,\allowbreak i-1,\allowbreak \cdots,0,\allowbreak -1,\allowbreak \cdots,\allowbreak -i,\allowbreak -i+1,\allowbreak \cdots 0\}$。如下图所示，是将 $a$ 数列内的前一些点绘制在坐标轴上的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/wrl89jka.png)

现在梅莉对市场发起了 $q$ 次询问，每次她会给定一个 $k$，希望求出 $a_k$ 是多少。

## 说明/提示

对于所有数据，$1 \leq q \leq 10^5$，$1 \leq k \leq 4\times 10^{18}$。

## 样例 #1

### 输入

```
9
1
10
100
1000
10000
100000
1000000
10000000
100000000```

### 输出

```
0
1
6
-9
-11
-128
406
1629
5154```

# 题解

## 作者：chen_zhe (赞：16)

题意简述：给一个数列 $[0],[0,1,0,-1,0],[0,1,2,1,0,-1,-2,-1,0]\dots$，求这个数列的第 $k$ 项是多少，$q$ 次询问。

碎碎念：本来这个题是普及月赛 T2。

解法：

设一个 $0,1,\dots,x-1,x,x-1,\dots,-x+1,-x,-x+1,\dots,0$ 被称为 $x$ 阶金字塔。

则一个 $x$ 阶金字塔的长度为 $4x+1$。前 $u$ 个金字塔的长度为 $\sum \limits_{i=0}^{u-1} (4i+1)=2u^2-u$。

则相当于找到一个 $t$，使得 $2t^2-t\leq k$，且 $2(t+1)^2-(t+1)>k$。容易发现 $t$ 可被二分。这样我们相当于可以获取，$k$ 这一项在哪个金字塔上，以及距离这个金字塔开头有多少距离 $k'$。

而一个 $x$ 阶金字塔可以被分为三段：一开始的上升段（$0,1,\dots,x$），中间的下降段（$x-1,x-2,\dots,-x$），以及最后的上升段（$-x+1,-x+2,\dots 0$），可以通过 $k'$ 的大小知道在哪一段上，进而求出 $a_k$ 具体是多少。

事实上，这个数据范围是我故意设置的。$2(t+1)^2-(t+1)=k$，当 $k=4\times10^{18}$ 时，$t \approx 1.4\times 10^9$，因此二分右边界要开到大约 $1.5\times 10^9$ 的范围，这个时候 `mid=(l+r)/2` 就可能爆 `int`。而如果要用求根公式，$\Delta\approx 9+4\times2\times4\times 10^{18}\approx 3.2\times10^{19}$，会爆 `unsigned long long`。

参考代码：

```cpp
#include <iostream>
using namespace std;
int main()
{
	int q;
	cin >> q;
	while (q--)
	{
		long long k,l=1,r=2e9,ans=0;
		cin >> k;
		while (l<=r)
		{
			long long mid=(l+r)/2;
			if ((long long)mid*mid*2-mid>=k)
			{
				r=mid-1;
				ans=mid;
			}
			else
				l=mid+1;
		}
		ans--;
		long long len=ans*ans*2-ans;
		k-=len+1;
		if (k<=ans)
			cout << k << endl;
		else if (k<=3*ans)
			cout << 2*ans-k << endl;
		else
			cout << -4*ans+k << endl;
		
	}
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：15)

提供一种新的解法。目前是最优解。

我们可以这么给数列分段：$[0],[0,1],[0,-1,0],[0,1,2,1],[0,-1,-2,-1,0]\dots$ 显然，这是有规律可循的。假设它们的编号为 $1,2,3\dots$ 接下来可以发现，第 $i$ 段里正好有 $i$ 个数，那么就可以很方便地找出 $a_k$ 属于第几段了。

再观察每一段。对于编号为偶数的段，可以发现其中的数都不是负数，而对于编号为奇数的段，可以发现其中的数都不是正数。我们称每一段里绝对值最大的数为塔顶，可以发现塔顶所处的位置为每段中的第 $1,2,2,3,3\dots$ 项。现在知道了每段的塔顶位置，假设这是该段中的第 $x$ 项，该项数值为 $v$，接着就可以简单分讨一下：

如果是奇数段，则第 $1\sim x$ 项是从 $0$ 开始依次递减的。而第 $x$ 项往后则是从 $v$ 开始依次递增的。

如果是偶数段，则第 $1\sim x$ 项是从 $0$ 开始依次递增的。而第 $x$ 项往后则是从 $v$ 开始依次递减的。

分讨完后容易发现，$a_k$ 是可以 $O(1)$ 查询的，也就是说，总时间复杂度为 $O(q)$。

---

## 作者：天野星河 (赞：4)

理解题意：

给定数列

$$[0],[0,1,0,-1,0],[0,1,2,1,0,-1,-2,-1,0],\dots$$

求它的第 $k$ 项，共 $q$ 次询问。

好吧，开始找数列的规律。首先可以发现：

定义一个 $x$ 阶“波浪”形数列为：

$$[0,1,2,\dots,x-1,x,x-1,\dots,1,0,-1,\dots,-x+1,-x,-x+1,\dots,0]$$

 $i$ 阶“波浪”的长度为 $4i+1$ 。前 $n$ 个“波浪”长度之和为

$$\sum_{i=0}^{n-1}(4i+1)=2n^2-n$$

相当于找到一个 $t$ ，使得 $2t^2-t\le k$ ，以及 $2(t+1)-(t+1)>k$ 。
显然的，我们可以二分，就知道了数列的第 $k$ 项位于一个 $t$ 阶“波浪”形数列。

为方便理解，可以将一个 $t$ 阶“波浪”形数列分为 $7$ 段：

$$[0],[1,t],[t-1,1],[0],[-1,-t],[-t+1,-1],[0]$$

就可以分别得出结果了~~~

**注意：十年OI一场空，不开long long见祖宗！**

下面放出完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int check(int k) {//二分函数
	int L = 0, R = 2e9;
	while (R - L > 1) {
		int M = (L + R) / 2;
		if ((2 * M + 1) * (M + 1) <= k) L = M;
		else R = M;
	}
	return L;
}
signed main() {
	int q;
	scanf("%lld", &q);
	while (q--) {
		int k;
		scanf("%lld", &k);
		int n = check(k), s = k - (2 * n + 1) * (n + 1);
		if (!s) {
			printf("0\n");
			continue;
		}
		n++;
		if (s == 1 || s == 2 * n + 1 || s == 4 * n + 1) {//特判3个值为零的点
			printf("0\n");
		} else if (s < 2 * n + 1) {//前半段
			s--;
			if (s <= n) printf("%lld\n", s);//第一个上升段
			else printf("%lld\n", 2 * n - s);//半个下降段
		} else {//取负数，当做前半段求解
			s -= 2 * n;
			s--;
			if (s <= n) printf("%lld\n", -s);
			else printf("%lld\n", -(2 * n - s));
		}
	}
}
```

---

## 作者：luogu_starblue (赞：2)

# [P8873 [传智杯 #5 初赛] E-梅莉的市场经济学](https://www.luogu.com.cn/problem/P8873)

本蒟蒻写的第一篇题解，如有不足还请见谅

首先根据题意不难发现，对于第 $i$ 个周期，其周期长度为 $4i+1$，因此这个周期的最后一个数的横坐标为

$\frac{5*i+i*(i-1)*4}2$

本质上就是等差数列求和。

那么因此我们可以采用二分查找 $k$ 属于第几个周期，我们令 $ans$ 为 $k$ 属于的周期，第 $ans-1$ 个周期长度为 $num1$，则k就属于k所在周期的第 $k-num1$ 个数，记 $k-num1$ 为 $num2$ ,记答案为 $f(num2)$。
 
$f(num2)=0,num2 \in 1,2] \cup [2\times ans+2,2\times ans+2]$

$f(num2)=ans-|2+ans-num2|,num2\in [3,2\times ans+2)$

当 $num2\ge2\times ans+2$ 此时 $num2$ 要先减去 $2\times ans+2$。

$f(num2)=-(ans-|2+ans-num2|),num2\ge2 \times ans+2$

代码如下
```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll inf=4e18+9;
const ll maxr=1429999999;//可以推测二分上界大约为这个数注意不能过大否则在等差数列求和时会暴long long
ll sum(ll i)//等差数列求和
{
	return i*5+i*(i-1)*4/2;
}
int main()
{
	int q;
	scanf("%d",&q);
	while(q--)
	{
		ll k;
		scanf("%lld",&k);
		ll l=1,r=maxr;
		ll ans=0;
		while(l<=r)
		{
			ll mid=(l+r)/2;
			if(sum(mid)<k)
			{
				l=mid+1;
			}
			else
			{
				ans=mid;
				r=mid-1;
			}
		}
		ll num1=sum(ans-1);//上一个周期的长度 
		ll num2=k-num1;//周期的第几个数 
		if(num2==1||num2==2||num2==2*ans+2)
		{
			cout<<0<<endl;
		}
		else if(num2<2*ans+2)
		{
			cout<<ans-abs(2+ans-num2)<<endl;
		}
		else
		{
			num2-=2*ans+2;
			cout<<-(ans-abs(ans-num2))<<endl;
		}
	}
}
```

---

## 作者：xuan_gong_dong (赞：2)

## 题面
[P8873 [传智杯 #5 初赛] E-梅莉的市场经济学](https://www.luogu.com.cn/problem/P8873)

## 分析

我们不妨换一种方式去将原序列拆分，使得第 $i$ 块的长度为 $i$。如果我们得知 $k$ 所在的块，那我们不就可以得到它的 $a_k$ 了吗，现在问题已经被我们分为了两个问题去解决。

### 寻找是哪一块
设 $x$ 是 $k$ 所在的块，则有

$$\dfrac{x \times (x-1)}{2}\lt k \le \dfrac{x \times (x+1)}{2}$$

不好看？那这样呢？

$$x \times (x-1)\lt 2 \times k \le x \times (x+1)$$
$$x \times (x-1)\lt x^2 \le x \times (x+1)$$

于是乎我们就可以这样去求 $x$。
```cpp
long long x=sqrt(2*k);
if(x*(x+1)/2<k)x++;
```
而 $k$ 就是第 $x$ 块中的第 $k - \dfrac{x\times (x-1)}{2}$ 项。

### 寻找 $a_k$
为了方便表达，令 $k' \gets k - \dfrac{x\times (x-1)}{2}$，即 $k$ 是第 $x$ 块中的第 $k'$ 项数。

容易发现，当 $x$ 为奇数时

- 第 $1$ 项至第 $\dfrac{x}{2}+1$ 项呈递增趋势，公差为 $1$，第 $\dfrac{x}{2}+1$ 项至第 $x$ 项呈递减趋势，公差为 $1$。

当 $x$ 为偶数时，恰好相反

- 第 $1$ 项至第 $\dfrac{x}{2}+1$ 项呈递减趋势，公差为 $1$，第 $\dfrac{x}{2}+1$ 项至第 $x$ 项呈递增趋势，公差为 $1$。

## 细节
要开 $\texttt{long long}$（超大声！）
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int Q;
	scanf("%d",&Q);
	while(Q--)
	{
		long long k;
		scanf("%lld",&k);
		long long x=sqrt(2*k);
		if(x*(x+1)/2<k)x++;
		k-=x*(x-1)/2;
		if(x&1)
		{
			
			x/=2;
			x++;
			if(k>x)
			k=(x-1)-(k-x);
			else k--;
			k=-k;
		}
		else
		{
			x/=2;
			x++;
			if(k>x)
			k=x-1-(k-x);
			else k--;
		}
		printf("%lld\n",k);
	}
	return 0;
}
```


---

## 作者：jsisonx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8873)

# 题目分析

看到 $k \leq 4 \times 10^{18}$ 的数据范围，得出结论：这是一道找规律题。

找规律题其实并不难，因为即使你不会，手动模拟一下打个表，可能规律直接就出来了，信息奥赛也不需要像数学竞赛一样严谨的证明。但是在这里，我还是来证明一下结论。

像这种带有周期性质的题目，通常从大范围考虑。对于给定的 $k$，考虑它位于哪一段上。那么，每一段第一个点的横坐标自然成为了重要的研究对象。

首先把每一段的第一个点的横坐标单拿出来组成一个数列找规律：
$$1,2,7,16,29 \cdots$$
好像看不出规律，相邻两项做差看一下：
$$1,5,9,13 \cdots$$
这下找到规律了，这个数列相邻两项的差是首项为 $1$，公差为 $4$ 的等差数列，于是数列的第 $k$ 项就为
$$1+\frac{(k-1)(1+1+4(k-2))}{2}$$
也就是原数列的第一项 $1$ 加上等差数列 $k-1$ 项的和。化简一下就是
$$2k^2-5k+4$$
就这样，我们求出了了每一段第一个元素的横坐标。接下来判断一个数 $x$ 在哪一段中，也就是找满足 $2k^2-5k+4 \leq x$ 最大的 $k$，解一个二元一次方程（即把小于等于变成等于），取两个解中较大的一个然后向下取整即可。然后考虑在段内求某个横坐标对应的纵坐标，也就是题目要的答案。

不难发现，每一段都是由三个一次函数组成的。对于第一个函数，是从横轴上升到这一段的最高点，设这一段第一个点的横坐标为 $p$，则此时横坐标 $x$ 的取值范围是 $p \leq x \leq p+k-1$，通过待定系数法求出解析式。第二个函数是从这一段的最高点到最低点，第三个函数是从最低点回到横轴，求法都一样。这里就直接给结果了：
$$
y=
\begin{cases}
x-p&\text{if}(p \leq x \leq p+k-1)\\
-x+p+2k-2&\text{if}(p+k-1 < x \leq p+3k-3)\\
x-(p+4k-4)&\text{if}(p+3k-3 < x \leq p+4k-4)\\
\end{cases}
$$
然后按上述方法分类讨论，找题目给的数适用哪个函数即可。

# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		ll x;
		cin>>x;
		double k2=(5.0+sqrt(8.0*(double)x-7.0))/4.0;//解一元二次方程（取正根）
		ll k=floor(k2);//向下取整
		ll p=2*k*k-5*k+4;//下面是分段函数
		if(x>=p&&x<=p+k-1){
			cout<<x-p<<endl;
		}
		else if(x>p+k-1&&x<=p+3*k-3){
			cout<<-x+p+2*k-2<<endl;
		}
		else{
			cout<<x-(p+4*k-4)<<endl;
		}
	}
	return 0;
} 
```

---

## 作者：IkeveLand (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8873)

![](https://cdn.luogu.com.cn/upload/image_hosting/wrl89jka.png)

每一段都是一个类似于正弦函数的波形，将每段的左端点和右端点的坐标之差叫做每段的长度。

由图可知：第 $n$ 段的长度为 $4n-4$，第 $n$ 段的右端点为 $n+\sum_{i=1}^{n}$，那么 $Len(i)=2n^{2}-n$。

二分查找 $x$ 所在段数，然后根据位置分情况即可。

---

## 作者：卷王 (赞：1)

## 题目大意

给出一种类似波浪形的图，图上第 $i$ 个点的高度标为 $a_i$。给定 $k$，试求 $a_k$。

## 大体思路

一道巧妙的数学题。

容易观察到，第 $x$ 段波浪的长度为 $4x+1$。于是，我们发现，前 $u$ 段波浪的总长度为 $2×u^2-u$。接着，我们观察这个式子，发现它具有单调性。于是，我们就可以想到二分。

我们要二分 $mid$，使得 $2 \times{mid}^2-mid \leq k < 2 \times{(mid+1)}^2-(mid+1)$。这是一个非常简单的二分。

我们可以拿 $ans$ 记下 $mid$ 的值。最后计算答案的时候，我们先将 $k$ 减去它所在波浪前面所有波浪的总长度，即 $2 \times{ans}^2-ans+1$，然后考虑 $k$ 在上升、下降、上升这三段中的哪一段。最后的答案只需观察即可得到。

温馨提示：请注意题目的数据范围。

---

## 作者：XBaiC (赞：1)

# 题意

读题即可。

# 分析

由题目描述可以发现每一段的个数为 $1,5,9,13\cdots$

可以得到第 $n$ 段的个数为 $b_{n}=1 +(n + 1) \times 4$。

前 $n$ 项和：$S_{n} = 2 \times n \times n -  n$。

当给定数字 $k$ 时，应找到 $k$ 所在的段中，再在该段中寻找结果。

最简单粗暴的方式就是通过 $1$ 开始枚举，直至找到第一个 $i$ 使得 $2\times n \times n-n$ 时，可以得出 $i - 1$ 即为 $k$ 所在的段，但这样的方法显然时间复杂度太大。

所以换个思路，我们可以从 $2\times n \times n-n$ 入手。

![](https://cdn.luogu.com.cn/upload/image_hosting/3w7bg8xt.png)

令 $S_{n} = a$，解得 $n = \sqrt{\frac{a}{2} + \frac{1}{16}} + \frac{1}{4}$。

再对 $n$ 取整后可得当前为第 $n + 1$ 段，但是如果 $n$ 求出来本身就是整数呢（即它为当前段的最后一个）？这时他所对应的即为第 $n$，于是我们进行如下处理：当算出的 $n$ 满足 $2\times n \times n-n = a$ 时，我们让 $n \gets n - 1$，这样之后可以确保它一定是在第 $n$ 段的后一段。

由此我们可以知道第 $n$ 段的范围是 $S_{n-1}+1$ 到 $S_{n}$ 之间，这一部分代码如下：

```cpp
t=(sqrt(a/2.0+1/16.0)+1/4.0)*1;
if(t*t*2-t==a)t--; 
st=2*t*t-t+1;
t++;
en=2*t*t-t;
```
（$st$ 为这一段的第一个位置，$en$ 为这一段的最后一个位置）

由此我们已经知道了 $k$ 所在的位置是在 $st$ 和 $en$ 之间。

![](https://cdn.luogu.com.cn/upload/image_hosting/xychmwfi.png)

再观察图可以发现在第 $n$ 段中，它总是先从 $0$ 开始一个一个增加到 $n-1$ 后再开始一个一个减小到 $-(n-1)$ 为止，之后再增到 $0$，这时这一段结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/hididb0q.png)

可以发现每一段的图像都关于 $st$ 和 $en$ 的中点（$mid$）对称，即 :$a_{st+i}=-a_{mid+i}(st\le st+i\le mid)$。

由此可以再定义一个整型变量 $fu$ 初始值为 $1$，当 $k > mid$ 时，$fu=-1$。这样可以将正负两部分图像转换为只有正的这一部分上。

![](https://cdn.luogu.com.cn/upload/image_hosting/5axbpqb3.png)

同时 $st$ 和 $mid$ 之间，又关于直线 $x=midd$ 对称（$midd$ 为 $st$ 和 $mid$ 的中点），由此得到：$a_{st+i}=a_{midd+i}(st\le st+i\le midd)$。

由图像可知，$st\le st+i\le midd$ 时，横坐标与纵坐标的增量均为 $1$，即 $a_{st}=0$，$a_{st+1}=1$，$a_{st+2}=2$...... 从而有 $a_{st+i} = i$。

此部分代码为：

```cpp
    long long int i,q=0,st,en,mid,midd,fu=1;
	long long int t,l;
	t=(sqrt(a/2.0+1/16.0)+1/4.0)*1;
	if(t*t*2-t==a)t--; 
	st=2*t*t-t+1;
	t++;
	en=2*t*t-t;
	mid=(st+en)/2;
	if(a>mid)
	{
		a=(a-mid)+st;
		fu=-1;
	}
	midd=(st+mid)/2;
	if(a<midd)cout<<(a-st)*fu<<endl;
	else cout<<(mid-a)*fu<<endl;
```


# code

**综上，本题代码如下：**

```cpp
#include<bits/stdc++.h>
using namespace std;
void init(long long int a)
{
	long long int i,q=0,st,en,mid,midd,fu=1;
	long long int t,l;
	t=(sqrt(a/2.0+1/16.0)+1/4.0)*1;
	if(t*t*2-t==a)t--; 
	st=2*t*t-t+1;
	t++;
	en=2*t*t-t;
	mid=(st+en)/2;
	if(a>mid)
	{
		a=(a-mid)+st;
		fu=-1;
	}
	midd=(st+mid)/2;
	if(a<midd)cout<<(a-st)*fu<<endl;
	else cout<<(mid-a)*fu<<endl;
}
int main()
{
    int n;
    long long int a;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>a;
		if(a==1){
			cout<<"0"<<endl;
		}else init(a);
	 } 
    return 0;
}
```
水平有限，如有错误，欢迎指出！

---

## 作者：_Emperorpenguin_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8873)

## 题意简述

有一数列形如 $0,0,1,0,-1,0,0,1,2,1,0,-1,-2,-1,0,…$，
给定 $k$，求此数列中的第 $k$ 项。


## 思路

#### 如何分段：

不妨构思一种分段方法：将前 $\dfrac{i\times (i-1)}{2}$ 至前 $\dfrac{i\times (i+1)}{2}$ 个数分成一组，那么第 $n$ 组就有 $n$ 个数。此时数列就会变成如下形式：

$[0],[0,1],[0,-1,0],[0,1,2,1],[0,-1,-2,-1,0],…$

观察发现：第 $1,3,5,…,2\times n+1$ 组中的每一个数都是非正数，而其他组中的每一个数都是非负数。

易得：第 $n$ 组中，绝对值最大的数 $x$ 是第 $\lfloor \dfrac{n}{2}+1 \rfloor$ 项，值为 $\lfloor \dfrac{n}{2} \rfloor$。

所以，我们在分类讨论后可以用 $O(1)$ 的时间复杂度求得单个询问的答案，也就是说，总的时间复杂度为 $O(q)$，足以通过此题。

#### 分类讨论：

- 在第 $2n+1$ 项中，从第 $1$ 到 第 $\lfloor \dfrac{n}{2}+1 \rfloor$ 项 是从 $0$ 开始依次递减的，从第 $\lfloor \dfrac{n}{2}+1 \rfloor$ 项到第 $n$ 项则是依次递增的。

- 在第 $2n$ 项中，从第 $1$ 到 第 $\lfloor \dfrac{n}{2}+1 \rfloor$ 项 是从 $0$ 开始依次递增的，从第 $\lfloor \dfrac{n}{2}+1 \rfloor$ 项到第 $n$ 项则是依次递减的。

- 以上递增、递减公差皆为 $1$。

---

## 作者：jixiyue114514 (赞：0)

## 题目大意
给出一种类似波浪形的图，图上第 $i$ 个点的高度标为 $a _i$。给定 $k$，试求 $a_k$。
## 大体思路
一道巧妙的数学题。

容易观察到，第 $x$ 段波浪的长度为 $4x+1$。于是，我们发现，前 $u$ 段波浪的总长度为 $2 \times u^2-u$。接着，我们观察这个式子，发现它具有单调性。于是，我们就可以想到二分。

我们要二分 $mid$，使得 $2 \times mid^2-mid\leq k \le 2 \times (mid+1)^2-(mid+1)$。这是一个非常简单的二分。

我们可以拿 $ans$ 记下 $mid$ 的值。最后计算答案的时候，我们先将 $k$ 减去它所在波浪前面所有波浪的总长度，即 $2 \times{ans}^2-ans+1$，然后考虑 $k$ 在上升、下降、上升这三段中的哪一段。最后的答案只需观察即可得到。

---


# 「DPOI-1」优美的序列

## 题目背景

#### Update on 2022.12.18：新增一组针对 @[zhuoxingmu](https://www.luogu.com.cn/user/421155) 的 Hack 数据，放置于 #21，分值为 $5$ 分。
#### Update on 2022.12.18：新增一组针对 @[大眼仔Happy](https://www.luogu.com.cn/user/537046) 的 Hack 数据，放置于 #22，分值为 $5$ 分。
------------
不可以，总司令。

## 题目描述

总司令给你一个长为 $n$ 的序列 $a$。

他认为这个 $a$ 现在也许不够优美，他希望将其重排为一个 $a'$，使之变得优美。

我们称一个长为 $n$ 的序列 $a$ 优美，当且仅当 $\exists i \in [1,n]$，满足：

- $\forall j \in [1, i)$，$a_j > a_{j + 1}$。
- $\forall j \in (i, n]$，$a_j > a_{j - 1}$。

他命令你求出 $a$ 经过重排可以得到多少个不同的 $a'$。由于结果可能很大，你只需要求出结果对 $p$ 取模的值。

由于一个固定的 $a$ 太无趣了，于是他给你 $m$ 次修改，每次修改形如 `x k`，表示令 $a_x \leftarrow k$。你需要在每次修改后求出当前的答案。

## 说明/提示

#### 样例 #1 解释
对于初始状态，满足条件的 $a'$ 有 $[2, 1, 2, 3], [3, 2, 1, 2]$，共 $2$ 个。

对于第一次修改后的 $a = [1, 2, 4, 3]$，满足条件的 $a'$ 有 $[1, 2, 3, 4], [2, 1, 3, 4], [3, 1, 2, 4], [4, 1, 2, 3], [3, 2, 1, 4], [4, 2, 1, 3], [4, 3, 1, 2], [4, 3, 2, 1]$，共 $8$ 个。
#### 样例 #2 解释
该样例满足测试点 $15 \sim 20$ 的限制。
#### 数据范围
| 测试点编号 | $n \leq$ | $m \leq$ | 特殊条件 |
| :------: | :------: | :------: | :------: |
| $1 \sim 2$ | $10$ | $10$ | 无 |
| $3 \sim 4$ | $100$ | $100$ | 无 |
| $5 \sim 6$ | $10^3$ | $10^3$ | 无 |
| $7 \sim 10$ | $10^5$ | $10^5$ | 无 |
| $11 \sim 12$ | $5 \times 10^5$ | $0$ | $a$ 为一个**排列** |
| $13 \sim 14$ | $5 \times 10^5$ | $0$ | 无 |
| $15 \sim 20$ | $5 \times 10^5$ | $5\times 10^5$ | 无 |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$0 \leq m \leq 5 \times 10^5$，$2 \leq p \leq 10^9$，$1 \leq a_i, k, x \leq n$。

## 样例 #1

### 输入

```
4 1 998244353
1 2 2 3
3 4```

### 输出

```
2
8```

## 样例 #2

### 输入

```
见下发文件 sequence2.in```

### 输出

```
见下发文件 sequence2.out```

# 题解

## 作者：Leasier (赞：7)

首先，我们把“优美”的条件转化为：

- 存在一个**波谷**，使得从中间向两边分别**严格单调递增**。

显然**波谷**即当前 $a$ 中的最小值只能存在**恰好一个**，也就是说：当最小值不止一个时答案为 $0$。

那对于剩下的数呢？我们不难发现：

- 若存在一个**出现次数 $> 2$ 的数**，答案为 $0$。

显然你只能把这个数放在**波谷**两边，且一边至多一个——毕竟我们要求的时**严格单调递增**，而这个出现次数 $> 2$ 的数就没法放了。

那对于其他情况呢？我们可以通过如下方式构造一种合法的“优美”序列：

- 我们先处理那些**恰好出现一次且非最小值的数**，将其随意划分成两堆，把最小值放在中间，再把这两堆排序后分列两侧；然后我们再来处理那些**恰好出现两次的数**，根据大小在左右各插入一个（不难发现固定恰好出现一次的数的排列顺序后方案唯一）即可。

能按这种方式构造显然是一个充要条件。

由此，我们也可以得出答案：

- 令 $cnt$ 表示恰好出现一次且非最小值的数的个数，则答案为 $2^{cnt}$。

为什么呢？注意到我们在上面的构造中是把这 $cnt$ 个数**随意划分成两堆**的，且因为要排序，所以我们不关心顺序。于是方案数即为子集数量 $2^{cnt}$。

实现时，先预处理 $2$ 的幂，然后用一个桶维护每个数当前的出现次数，实现 `add/del` 操作维护**恰好出现一次的数**和**出现次数 $> 2$ 的数**的数量，再用一个 multiset 维护所有数（因为你需要动态维护最小值）即可。时间复杂度为 $O((n + m) \log n)$。

代码：
```cpp
#include <set>
#include <cstdio>

using namespace std;

int cnt1 = 0, cnt2 = 0;
int power[500007], a[500007], cnt[500007];
multiset<int> s;

inline void init(int n, int p){
	power[0] = 1;
	for (register int i = 1; i <= n; i++){
		power[i] = power[i - 1] * 2 % p;
	}
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline void add(int x){
	cnt[x]++;
	s.insert(x);
	if (cnt[x] == 1){
		cnt1++;
	} else if (cnt[x] == 2){
		cnt1--;
	} else if (cnt[x] == 3){
		cnt2++;
	}
}

inline void output(){
	if (cnt2 > 0 || cnt[*s.begin()] > 1){
		printf("0\n");
	} else {
		printf("%d\n", power[cnt1 - 1]);
	}
}

inline void del(int x){
	cnt[x]--;
	s.erase(s.lower_bound(x));
	if (cnt[x] == 0){
		cnt1--;
	} else if (cnt[x] == 1){
		cnt1++;
	} else if (cnt[x] == 2){
		cnt2--;
	}
}

int main(){
	int n = read(), m = read(), p = read();
	init(n - 1, p);
	for (register int i = 1; i <= n; i++){
		a[i] = read();
		add(a[i]);
	}
	output();
	for (register int i = 1; i <= m; i++){
		int x = read(), k = read();
		del(a[x]);
		a[x] = k;
		add(k);
		output();
	}
	return 0;
}
```

---

## 作者：Micnation_AFO (赞：1)

做法：计数 + 权值线段树，可能这个做法难度不止黄。

题挺不错的，就是不知道比赛的时候为什么没人做。

显然题目是让我们求出一个序列的全排列中有多少个全排列是严格单谷的，其中形如 `4321` 的也算。

首先考虑无解即方案数为 $0$ 的情况，容易发现只会出现以下两种情况：

1. 最小的数出现了两次时无解，因为想要形成单谷，这两个数必须放在一起，但是由于是严格单谷，相邻两数不能相等，所以一定没有合法方案。
1. 至少有一个数出现了三次或三次以上。若有两个相等，则可以把一个放在谷底左边，一个放在谷底右边，而出现了三个显然无法安排。

当答案不为 $0$ 时，由于谷底固定，所以每个**只出现过一次的数**都可以放在谷底左边或者右边（注意如果一个数出现两次，一定是一个在谷底左边，一个在右边），即 $2$ 种选择。根据乘法原理，若有 $n$ 个非谷底的且只出现过一次的数，那么方案数就是 $2^n$。

那么可以用权值线段树维护，当最大值大于 $2$ 时，则无解。然后用一个递归函数判断最小数的出现次数，若大于 $1$ 则无解。

顺便维护一下出现过一次的数的数量，记为 $cnt$，由于上面已经判断过谷底是 $1$，所以直接输出 $2^{cnt - 1}$ 即可。

完整代码：

```cpp
#include <iostream>

using namespace std;

const int N = 500010;
#define int long long

struct SegmentTree {
    int l, r;
    int num, dat, sum;
} t[N << 2];

int n, m, p;
int a[N], two[N];

void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) { t[p].num = t[p].dat = t[p].sum = 0; return; }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid), build((p << 1) | 1, mid + 1, r);
    t[p].num = t[p].dat = t[p].sum = 0;
}

void change(int p, int x, int v) {
    if (t[p].l == t[p].r) {
        t[p].sum += v, t[p].dat += v;
        if (t[p].sum == 1) t[p].num = 1;
        else t[p].num = 0;
        return;
    }
    int mid = (t[p].l + t[p].r) >> 1;
    if (x <= mid) change(p << 1, x, v);
    if (x > mid) change((p << 1) | 1, x, v);
    t[p].sum = t[p << 1].sum + t[(p << 1) | 1].sum;
    t[p].num = t[p << 1].num + t[(p << 1) | 1].num;
    t[p].dat = max(t[p << 1].dat, t[(p << 1) | 1].dat);
}

int ask(int p) {
    if (t[p].l == t[p].r) return t[p].sum;
    int val = t[p << 1].sum;
    if (val) return ask(p << 1);
    return ask((p << 1) | 1);
}

signed main() {
    scanf("%lld%lld%lld", &n, &m, &p);
    two[0] = 1; build(1, 1, N - 1);
    for (int i = 1; i < N; i++) two[i] = two[i - 1] * 2 % p;
    for (int i = 1; i <= n; i++) {
        scanf("%lld", a + i);
        change(1, a[i], 1);
    }
    if (t[1].dat > 2 || ask(1) != 1) puts("0");
    else printf("%lld\n", two[t[1].num - 1]);
    while (m--) {
        int x, v; scanf("%lld%lld", &x, &v);
        change(1, a[x], -1), change(1, v, 1), a[x] = v;
        if (t[1].dat > 2 || ask(1) != 1) puts("0");
        else printf("%lld\n", two[t[1].num - 1]);
    }
    return 0;
}
```

---

## 作者：大眼仔Happy (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8895)

## 简化题意

做题先简化一下题意。

给定 $n$ 个数，要求排序后满足该序列为先下降后上升（相邻两个不能相等），求总方案数。

## 正文部分

（表述或许不太对，请大佬指出）

首先，我们先找到最小值，显然最小值一定是转折点。由于不能相等，所以最小值只能有一个。否则答案为 $0$。

定好了最小值，然后考虑其他的数摆放的位置。例如样例 $1$，最小值为 $1$，那么我们先摆放 $1$：

$$[]\quad[]\cdots[1]\cdots[]\quad[]$$

首先 $3$ 只有一个，所以左右都能放。$2$ 有两个，只能一边放一个，否则同时放一边会使得他们相等。根据乘法原理，我们算得答案为 $2\times 1=2$。

修改了一次后，序列变成了 $1\ 2\ 4\ 3$。

这时，和我们上面的分析一样，我们知道 $2$、$3$、$4$，都只有一个，所以他们两边都可以放，那么就算得答案为 $2\times 2\times 2=8$。

仔细发现，这道题和数是多少没有关系，只和有几个相同的数有关系，所以我们考虑开一个桶来记录每个数的数量。

既然和数的数量有关系，那么数太多会有什么影响吗？

可以发现，当数量 $\ge 3$ 时，无论怎么摆放，两边都会有相同，这时答案也为 $0$。

于是，我们总结一下，可以得到一下思路：

1. 首先找到最小值的个数，如果 $>1$，则答案为 $0$。
2. 如果有相同的数超过三个，那么答案也为 $0$。
3. 当数量为 $2$ 个时，答案 $\times 1$，当数量为 $1$ 时，答案 $\times 2$。

所以我们可以发现，我们需要分别记录一共有多少个数量为 $1$、$2$ 的数，假设是 $s1$ 和 $s2$。但因为数量为 $2$ 时，答案 $\times 1$，所以 $s2$ 可以不用记。再记录数量 $\ge 3$ 的，假设为 $s3$。

如果都不满足答案为 $0$ 的情况，即上面的情况 $1$ 和情况 $2$，那么答案就为 $2^{s1-1}$，$s1-1$ 是因为这时最小值的个数也是 $1$，并且需要去掉它。

于是可以得到以下的代码：
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=5e5+5;
int n,m;ll p;
ll a[N],tong[N];
ll s1,s3;
ll QuickPow(ll a,ll b)
{
	ll res=1;
	while(b>0)
	{
		if(b&1)res=(res*a)%p;
		a=(a*a)%p;b>>=1;
	}
	return res;
}
ll calc()
{
	if(s3)return 0;
	ll Min=LONG_LONG_MAX;
	for(int i=1;i<=n;i++)Min=min(Min,a[i]);
	if(tong[Min]!=1)return 0;
	return QuickPow(2,s1-1);
}
int main(){
	scanf("%d%d%lld",&n,&m,&p);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),tong[a[i]]++;
	for(int i=1;i<=n;i++)
	{
		if(tong[i]==1)s1++;
		if(tong[i]>=3)s3++;
	}//s1,s3的意义在上面讲到了
	printf("%lld\n",calc());
	while(m--)
	{
		int x,k;
		scanf("%d%d",&x,&k);
		//del
		if(tong[a[x]]==3)s3--;
		if(tong[a[x]]==2)s1++;
		if(tong[a[x]]==1)s1--;
		tong[a[x]]--;
		//add
		if(tong[k]==0)s1++;
		if(tong[k]==1)s1--;
		if(tong[k]==2)s3++;
		tong[k]++;
		//
		a[x]=k;
		printf("%lld\n",calc());
	}
	return 0;
}
```
时间复杂度为 $O(nm)$（然而还要算上每个询问的快速幂的时间，也可以预处理出每一个 $2^i$），显然不能通过此题。

发现这个代码的瓶颈在于每一次求 $\min$ 时，都需要 $O(n)$ 的时间复杂度。只要这里降下去，就可以了。

对于每一次求 $\min$，我们可以使用线段树维护一个单点修改和区间查询 $\min$ 即可，官方题解是用 multiset，~~但蒟蒻不会啊~~。

最后的代码就在上面的代码中添加一个线段树即可。~~就没有必要展示了吧。。。~~

于是，$O(nm)\xrightarrow{}O((n+m)\log n)$（同上，并没有考虑快速幂），完美通过此题。

## 题外话

关于我的 $s3$ 的计算时犯了一个sb错误，写了：
```cpp
if(tong[a[i]]==3)s3++;
```
竟然也过了。然后出题人就搞了一个数据Hack我了。。。为此还写在了题头。。。

---

## 作者：wizard（偷开O2 (赞：0)

一道多重集合维护数列的好题。

## 题意

现在存在一个无序且长度为 $n$ 的序列 $A$，现在你需要重构序列，使得序列存在一个位置 $i \in [1,n]$，满足位置之前单调递减，位置之后单调递增。

有 $m$ 次操作，每次操作可以吧 $A_{x}$ 修改为 $k$。

共有多少种重构方法。

## 分析

先考虑无解情况，因为严格单调，所以最小值的那个数的数量必须为 $1$，所以如果 $A_{i}$ 的数量 $>1$，就无解。

如果有两个相同的数，我们可以把他们放到 $i$ 两边，如果数量超过 $2$ 个，就无解。

考虑别的情况，如果这个数出现了 $2$ 次，我们只能把他们放在 $i$ 两侧，所以只有一种重构情况。反之如果只出现了一次，那么就有两次重构情况：你可以把他们放在左侧，也可以放在右侧。

设 $s1,s2$ 为 出现次数为 $1$ 和 $2$ 的数字个数。出现 $2$ 次的数字的贡献为 $1$，所以直接不用考虑。

所以如果判掉了无解情况，答案就是 $2^{s_{1}-1}$。

多重集合维护。

## 代码
```cpp
//ways:multiset
//noip 2024 rp++ 
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ls ((now<<1))
#define rs ((now<<1)|1)
#define mid ((l+r)>>1)
const int maxn=1e6+10;
const int inf=2147483647;
const int maxa=2e3+10;
const int modd=998244353;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int ksm(int a,int b,int p){
	int ans=1;
	while(b){
		if(b&1)ans=ans*a%p;
		a=a*a%p;
		b>>=1;
	}
	return ans;
}
multiset <int> mp; 
int n,m,p; 
int cnt[maxn];
int a[maxn];
int s1,s2;
//条件就是谷底数字的数量只能为1
//任意一个数字的数量都不能超过3 
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); 
	cin >> n>>m >> p;
	for(int i=1;i<=n;i++){
		cin >> a[i];
		cnt[a[i]]++;
		mp.insert(a[i]);
		if(cnt[a[i]]==1)s1++;
		else if(cnt[a[i]]==2)s1--;
		else if(cnt[a[i]]==3)s2++;	
	}
	if(s2>0||cnt[*mp.begin()]>1)cout << 0 << endl;
	else cout << ksm(2,s1-1,p) << endl;
	while(m--){
		int x,k;cin >>x >> k;
		//del
		cnt[a[x]]--;
		mp.erase(mp.lower_bound(a[x]));
		if(cnt[a[x]]==0)s1--;
		else if(cnt[a[x]]==1)s1++;
		else if(cnt[a[x]]==2)s2--;
		//	
		a[x]=k;
		//add
		cnt[k]++;
		mp.insert(k);
		if(cnt[k]==1)s1++;
		else if(cnt[k]==2)s1--;
		else if(cnt[k]==3)s2++;	
		if(s2>0||cnt[*mp.begin()]>1)cout << 0 << endl;
		else cout << ksm(2,s1-1,p) << endl;
	}
	cerr << clock() << endl; 
	return 0;
}
```

---

## 作者：违规用户名^3Zj=Oha (赞：0)

## 一、题目简述
给定一个序列 $a$ ，要求通过重新排列后成为一个使得从中间向两边分别严格单调递增的序列，求总的方案数。

## 二、思路分析

也就是:

首先找到最小值的个数，如果大于 $1$，则答案为 $0$。

如果有相同的数超过三个，那么答案也为 $0$。

当数量为 $2$ 个时，答案不变，当数量为 $1$ 时，答案翻倍。


## 三、构造代码
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,p;
ll k[1000000];
ll mark[1000000];//值域统计 
ll cnt2,cnt3;//不同个数 
ll a[600000];
ll l;
priority_queue<ll> f;
void work(){//判断
	if(cnt3||mark[l]>1){
		cout<<0<<endl;
		return;
	}
	cout<<k[n-1-2*cnt2]<<endl;
}
int main(){
	cin>>n>>m>>p;
	k[0]=1;
	for(int q=1;q<=n;q++) k[q]=k[q-1]*2%p;//初始化
	for(int q=1;q<=n;q++){//输入，并用堆根维护
		cin>>a[q];f.push(-a[q]);
		mark[a[q]]++;
	}
	for(int q=600000;q>=1;q--){
		if(mark[q]) l=q;
	}
	for(int q=1;q<=600000;q++){
		if(mark[q]==2) cnt2++;
		if(mark[q]>=3) cnt3++;
	}
	work();
	while(m--){//循环进行操作
		int x,k;
		cin>>x>>k;
		f.push(-k);
		if(mark[a[x]]==2) cnt2--;
		if(mark[a[x]]>=3) cnt3--;
		mark[a[x]]--;
		if(mark[a[x]]==2) cnt2++;
		if(mark[a[x]]>=3) cnt3++;
		a[x]=k;
		if(mark[a[x]]==2) cnt2--;
		if(mark[a[x]]>=3) cnt3--;
		mark[a[x]]++;
		if(mark[a[x]]==2) cnt2++;
		if(mark[a[x]]>=3) cnt3++;
		while(1){
			l=-f.top();
			if(mark[l]) break;
			else f.pop();
		}
		work();
	}
	return 0;
}
```

---


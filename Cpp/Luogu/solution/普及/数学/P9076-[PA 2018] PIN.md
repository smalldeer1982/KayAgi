# [PA 2018] PIN

## 题目描述

**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda próbna [PIN](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/pin/)**

Bytie 忘记了手机密码。他记得它由三个不同的正整数 $a < b < c$ 组成。这些数字的总和是 $n$，此外每对数字（在 $(a, b)$，$(a,c)$ 和 $(b, c)$ 中）中，一个数字是另一个的倍数。

帮助他计算需要检查的可能的三元组数目，以便他可以决定是否值得浪费在尝试密码上。

## 说明/提示

#### 样例 1 解释

有两个可行三元组：$(1,2,32)$，$(5,10,20)$。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 10^9$。

## 样例 #1

### 输入

```
35```

### 输出

```
2```

# 题解

## 作者：Elairin176 (赞：7)

[传送门](https://www.luogu.com.cn/problem/P9076)          
数学好题。          
首先，题目要求 $b$ 是 $a$ 的倍数，$c$ 是 $b$ 的倍数，$a+b+c=n$，所以 $a$ 一定是 $n$ 的因数。        
接下来我们推一下 $a,b,c$ 的值域。         
$a$ 比较好想，最大的时候柿子为 $a+2a+4a=n$，即 $7a=n$，所以 $a\in[1,\lfloor\frac{n}{7}\rfloor]$。               
$b$ 最小的时候只能是 $2a$，最大的时候需要考虑到 $c$。最大时柿子为 $a+b+2b=n$，这里容易发现 $b=\frac{n-a}{3}$，所以 $b\in[2a,\lfloor\frac{n-a}{3}\rfloor]$。                  
$c$ 最小的时候是 $2b$，最大时柿子为 $a+2a+c=n$，容易得出 $c=n-3a$，所以 $c\in[2b,n-3a]$。             
所以，我们可以先把 $a$ 的因数找出来，之后枚举一下，超过 $\lfloor\frac{n}{7}\rfloor$ 就不枚举。     
设这个因数为 $x$，那么 $a=x$，$b+c=n-x=ya+zya$。       
$a+b+c=a+ya+zya=a\times(1+y+zy)$，设 $d=\frac{n}{a}-1$，这里的 $d=y+zy$。       
我们需要求出满足条件的 $y,z$ 有多少组。          
我们枚举 $y$，从 $2$ 开始，不能出现 $ay\le \lfloor\frac{n-a}{3}\rfloor$ 的情况。       
容易发现，在 $(a-y)\bmod y=0$ 的情况下可以构造出一组解。这个柿子等同于 $a\bmod y=0$。       
所以，这个问题转化成了求解 $a$ 的因数数量。      
$y$ 只需要枚举到 $\sqrt{a}$ 就可以。      
对于一个满足条件的 $y$，如何判断 $\frac{n}{y}$ 也满足情况呢？       
首先，需要有 $\frac{n}{y}≠y$。          
这里需要判断能否构造出 $c$，如果 $(a-\frac{a}{y})\bmod \frac{a}{y}≠0$，那么无法构造出 $c$，$y$ 就不对。              
还需要判断 $a-\frac{a}{y}=\frac{a}{y}$。如果等于，说明 $b=c$，是错误的。         
CODE：         
```cpp
//Code by __dest__ruct__or__(uid=592238)
#include <iostream>
#include <vector>
using namespace std;
#define umap unordered_map
#define uset unordered_set
#define ll long long
#define ld long double
#define pii pair<int,int>
#define pll pair<long long,long long>
const ll INF=9223372036854775807;
namespace mySTL{
	inline int max(int a,int b){return a>b?a:b;}
	inline int min(int a,int b){return a<b?a:b;}
	inline ll max(ll a,ll b){return a>b?a:b;}
	inline ll min(ll a,ll b){return a<b?a:b;}
	inline ld min(ld a,ld b){return a<b?a:b;}
	inline ld max(ld a,ld b){return a>b?a:b;}
	inline int _abs(int a){return a<0?-a:a;}
	inline int read(){char c=getchar();int f=1,ans=0;
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9')ans*=10,ans+=c-'0',c=getchar();
	return ans*f;}
	inline long long readll(){char c=getchar();long long f=1,ans=0;
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9')ans*=10,ans+=c-'0',c=getchar();
	return ans*f;}
	inline void swap(int &a,int &b){a^=b,b^=a,a^=b;}
	inline void swap(ll &a,ll &b){a^=b,b^=a,a^=b;}
	inline void write(int x){if(x<0){putchar('-');x=-x;}
	if(x>=10){write(x/10);}putchar(x%10+'0');}
	inline void writell(long long x){if(x<0){putchar('-');x=-x;}
	if(x>=10){writell(x/10);}putchar(x%10+'0');}
	inline ll pw(ll a,ll b,ll p){if(b==0)return 1;
	if(b==1)return a%p;
	ll mid=pw(a,b/2,p)%p;
	if(b&1)return mid*mid%p*a%p;else{return mid*mid%p;}}
	inline int gcd(int a,int b){return b?gcd(b,a%b):a;}
	inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
	inline int lcm(int a,int b){return a*b/gcd(a,b);}
}
using namespace mySTL;
int n,ans,sz,a;
vector<int>v;
int main(void){
	n=read();
	for(int i=1;i<=n/i;i++){//求因数
		if(n%i!=0){
			continue;
		}
		v.push_back(i);
		if(i!=n/i){
			v.push_back(n/i);
		}
	}
	sz=v.size();
	for(int i=0;i<sz;i++){//枚举因数（构造a）
		if(v[i]>n/7){
			continue;
		}
		a=n/v[i]-1;
		for(int j=2;j*v[i]<=(n-v[i])/3&&j<=a/j;j++){//构造y
			if(a%j==0){
				ans++;
				if(a/j!=j&&(a-a/j)%(a/j)==0&&(a-a/j)!=(a/j)){//判断a除以y能否使用
					ans++;
				}
			}
		}
	}
	write(ans);
	return 0;
}
```


---

## 作者：ydclyq (赞：5)

[题目链接](https://www.luogu.com.cn/problem/P9076)


本题的基本思路是试除法求约数。


$(1+k+c\times k) \times a=n(k>1,c>1)$


题目的答案便转化为满足此式的解数。


于是我们可以用两次试除法，


- 第一次把 $n$ 分解成 $a$ 和 $1+k+c\times k$。

- 第二次把 $k+c\times k$ 分解为 $c+1$ 和 $k$。

  
注意把 $ \sqrt n \times \sqrt n=n$ 判重。

代码过不去的时候建议先写个暴力代码参照一下。

```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	freopen("baoli.out","w",stdout);
	while(n--){
			int ans=0;
	for(int i=1;i<=n;i++)
	for(int j=i+i;j<=n;j+=i)
	for(int z=j+j;z<=n;z+=j)
	if(i+j+z==n){
	//	cout<<i<<' '<<j<<" "<<z<<endl;
		ans++;
	}
	cout<<ans<<endl;
	}

	return 0;
}
```

然后再去考虑暴力和正解之前出现的差别，进一步去修改自己的代码。

AC 代码：


```cpp
#include<iostream>
#include<cmath>
#include<stdio.h>
#include<string.h> 
using namespace std;
int n,ans=0;
void chuli(int x); 
int main(){
	cin>>n;
		ans=0;
	int m=sqrt(n);
	for(int i=1;i<=m;i++)
	if(n%i==0){
		chuli(i);
		if(i!=sqrt(n))chuli(n/i);
	} 
	cout<<ans;	
	return 0;
}
void chuli(int x){
	int k=n/x;
	if(k<7)return;
	k--;
	for(int i=2;i<=sqrt(k);i++)
	if(k%i==0){
		if(k/i>2)ans++;	
	    int t=k/i;
	    if(i!=2&&t!=i)ans++;
	}
	return ; 
}
```


---

## 作者：zzy0618 (赞：3)

#### 题目大意

[题目链接](https://www.luogu.com.cn/problem/P9076)

求出有多少个三元组 $(a,b,c)$ 满足一下内容。

- $a<b<c$。

- $b$ 是 $a$ 的倍数，$c$ 是 $b$ 的倍数。

- $a+b+c=n$。

#### 解题思路

令 $a\times x=b,b\times y=c$ 其中 $x,y>1$，则有 $a(1+x+xy)=n$。此时问题被转化为此式子的解数。

先把 $n$ 分成 $a$ 和 $1+x+xy$ 的乘积，再把 $x+xy$ 分成 $x$ 和 $y+1$ 的乘积。中途分两部分枚举，但是要小心有 $\sqrt l \times \sqrt l = l$ 的情况。

最终的时间复杂度在 $\sqrt n$ 的级别，剩下的几乎是常数，稍微注意一下即可。

#### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans = 0, n;
inline void f(int a) {
	int l1 = n / a;
	if (l1 < 7)return;
	l1-=1;//要减1，见上
	for (int i = 2; i <= sqrt(l1); i++)
		if (l1 % i == 0) {
			if (l1 / i > 2)ans++;
			int t = l1 / i;//特判 
			if (i != 2 && t != i)ans++;
		}
}
signed main() {
	register int l, i;//优化一点常数
	cin >> n;
	l = sqrt(n);
	for (i = 1; i <= l; i++)
		if (n % i == 0) {
			f(i);
			if (i != sqrt(n))f(n / i);//注意特判
		}
	cout << ans;
	return 0;
}
```


---

## 作者：watcher_YBH (赞：2)

[题目](https://www.luogu.com.cn/problem/P9076)

# 题目要求：
$n = a + b + c$，$a < b < c$，在这三个数中，**一个数字是另一个的倍数**，检查的可能的三元组数目。

# 题目分析：
 $b = a \times k$，$c = b \times k$，
 
 则 $n = a \times (1 + k + k \times k)$，
 
 则 $n = a \times \big(1 + k \times (1 + k) \big)$。

 优化：只用枚举到 $\sqrt{n}$。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
void da(int x){//枚举b,c
	int k = n/x,a,b;
	k -= 1;
	for(int i = 2; i <= sqrt(k); i++){
		a = k/i; b = k%i;
		if(!b){
			if(i > 2 && a > i)ans++;
			if(k/i > 2)ans++;
		}
	}
}
int main(){
	cin>>n;
	int m = sqrt(n),i = 1;//优化：只用枚举到根号n
	while(i <= m){
		if(n%i == 0){
			da(i);
			if(i != m)//避免重复计算
				da(n/i);
		}
		i++;
	}
	cout<<ans<<endl;//输出
	return 0;
}
```


---

## 作者：yujinning (赞：2)

提出一种比另一篇题解简单一些的解法。

对于 $a,b,c$ 三个数，因为 $a<b<c$，所以可设 $b=ax$，$c=axy$，其中 $x\neq 1$，$y\neq 1$。

由题意，有 $a+b+c=n$，即 $a+ax+axy=n$，即      $a(1+x+xy)=n$。

显然 $x,y$ 均为整数，所以 $1+x+xy$ 也为整数，又因 $a$ 和 $1+x+xy$ 均为整数，所以 $a$ 为 $n$ 的约数。

可以使用 $O(\sqrt{n})$ 的时间复杂度枚举出所有约数。注意此时符合条件的情况，即 $n$ 的约数个数，远小于 $2\sqrt{n}$。

此时有 $1+x+xy=\frac{n}{a}$，整理得 $x(y+1)=\frac{n}{a}-1$。

同上，枚举 $\frac{n}{a}-1$ 的所有约数，但注意到 $x\neq 1$，$y\neq 1$，则 $y+1\neq 2$，所以枚举约数时要注意特判。此时的时间复杂度理论为 $\sqrt{n}$，但实际上有一半的约数 $\leq \sqrt{n}$，所以枚举个数也小于 $2\sqrt{n}$。

综上，时间复杂度为 $O(n)$，但实际上因为以上原因，代码运行时间极低，在不开 O2 优化的前提下，最慢的点仅需要 4ms。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void ok(int y){
	for(register int i=1;i<=sqrt(y);i++){
		if(y%i!=0) continue;
		if(i!=y/i){
		    if(i>1&&y/i>2) cnt++;
		    if(i>2&&y/i>1) cnt++;
		}else{
			if(i>1&&y/i>2) cnt++;
		}
	}
}
int main(){
    n=read();
    for(register int i=1;i<=sqrt(n);i++){
    	if(n%i!=0) continue;
    	if(n/i!=i) ok(n/i-1),ok(i-1);
    	else ok(n/i-1);
	}
	write(cnt);
	return 0;
}
```


---

## 作者：Tjaweiof (赞：1)

# P9076 题解——Tjaweiof
[题目传送门](https://www.luogu.com.cn/problem/P9076)

这题就是一道数学题，思路就是考虑 $n$ 的每个因数，将 $a$ 设为这个因数，算出可以构造三元组的数量，再把结果加起来即可。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, ans, cnt;
long long work(long long x){
	long long k = n / x, ans = 0;
	if (k < 7){
		return 0;
	}
	k--;
	for (long long i = 2; i * i <= k; i++){
		if (!(k % i)){
			long long t = k / i;
			if (t > 2){
				ans++;
			}
			if (i != 2 && t != i){
				ans++;
			}
		}
	}
	return ans;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	cin >> n;
	for (long long i = 1; i * i <= n; i++){
		if (n % i == 0){
			ans += work(i);
			if (i * i != n) ans += work(n / i);
		}
	}
	cout << ans;
	return 0;
}

```
**此代码时间复杂度 $O(n)$，空间复杂度 $O(1)$，完美过关！**

---


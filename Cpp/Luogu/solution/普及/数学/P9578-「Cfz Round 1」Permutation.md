# 「Cfz Round 1」Permutation

## 题目背景

$1+2+3+\cdots+n=\dfrac {n\times (n+1)} 2$。

## 题目描述

给定一个正整数 $n$。

我们定义，对于一个 $1$ 到 $n$ 的排列 $\{x_n\}$， $f(\{x_n\})=\max\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})-\min\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})$。

你需要构造一个 $1$ 到 $n$ 的排列 $\{p_n\}$，使得对于任意一个 $1$ 到 $n$ 的排列 $\{q_n\}$，都有 $f(\{p_n\})\le f(\{q_n\})$，并输出你构造的排列 $\{p_n\}$。

## 说明/提示

#### 【样例解释 #1】

$f(\{1,4,2,3\})=2$，可以证明对于任意一个 $1$ 到 $n$ 的排列 $\{q_n\}$，都有 $f(\{1,4,2,3\})\le f(\{q_n\})$。

当然，$\{1,3,2,4\},\{3,1,4,2\},\{4,1,3,2\}$ 等也为合法的排列 $\{p_n\}$。

#### 【数据范围】

对于所有数据，$3 \le n \le 10^6$。

**本题采用捆绑测试。**

|子任务编号|分值|$n \le$|特殊性质|
|:---:|:---:|:---:|:---:|
|$1$|$20$|$8$|无|
|$2$|$25$|$10^6$|保证 $n \equiv 0 \pmod 2$|
|$3$|$25$|$10^6$|保证 $n \equiv 1 \pmod 2$|
|$4$|$30$|$10^6$|无|

## 样例 #1

### 输入

```
4```

### 输出

```
1 4 2 3```

# 题解

## 作者：Defy_HeavenS (赞：9)

## 题意（~~我尽量不用太多数学式子~~）

定义一个函数 $f(\{x_n\})$，是求一个序列相邻两项（首尾相邻）的和最大值减最小值。

你需要构造一个元素为 $1$ 到 $n$ 的排列。使得它是所有元素为 $1$ 到 $n$ 的排列对 $f$ 函数求值最小的。

## 思路

观察数据范围，提示我们可以奇偶数分别考虑，暴力构造 $n=3$ 到 $n=10$。

#### 奇数

- $n=3:1 ,3 ,2$。
- $n=5:1 ,5 ,2 ,3 ,4$。
- $n=7:1 ,7 ,2 ,5 ,4 ,3 ,6$。
- $n=9:1 ,9 ,2 ,7 ,4 ,5 ,6 ,3 ,8$。

下标为奇数 _正着枚举_ 是 $1 ,2 ,4 ,6 ,8 ,...$，为偶数 _反着枚举_ 是 $3 ,5 ,7 ,9 ,...$。

可以构造数组 $a$，$a_1 \leftarrow 1$，其他奇数下标 $a_i \leftarrow i-1$。下标为偶数 $a_i \leftarrow n-i+2$。

----
#### 偶数

- $n=4:1 ,3 ,2 ,4$。
- $n=6:1 ,5 ,3 ,4 ,2 ,6$。
- $n=8:1 ,8 ,3 ,5 ,4 ,6 ,2 ,8$。
- $n=10:1 ,9 ,3 ,7 ,5 ,6 ,4 ,8 ,2 ,10$。

对半分左边一半下标为奇数的与它们相对称的都为下标本身。

对半分左边一半下标为偶数的与它们相对称的相加为 $n+1$，且左边一半第一个元素为 $n-1$， _正着枚举_ 每次递减 $2$，右半边倒数第二个元素为 $2$，_反着枚举_ 每次递增 $2$。

 _*正着枚举是指从 $1$ 到 $n$ 枚举，反着枚举是指从 $n$ 到 $1$ 枚举_ 。
 
可以构造数组 $a$ 下标为偶数 $a_i \leftarrow x\ ,\ a_{n-i+1}\leftarrow n+1-x$，且每次 $,x\leftarrow x+2$。其余 $a_i\leftarrow i$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005];
int main(){
	cin>>n;
	if(n%2==0){
		for(int i=2,j=n-1;i<=n/2;i+=2,j-=2){
			a[i]=j;
			a[n-i+1]=n+1-j;
		}
		for(int i=1;i<=n;i++){
			if(!a[i]){
				cout<<i<<" ";
			}else{
				cout<<a[i]<<" ";
			}
		}
	}else{
		a[1]=1;
		for(int i=3,j=2;i<=n;i+=2,j+=2){
			a[i]=j;
		}
		for(int i=2,j=n;i<=n;i+=2,j-=2){
			a[i]=j;
		}
		for(int i=1;i<=n;i++){
			cout<<a[i]<<" ";
		}
	}
    return 0;
}
```

---

## 作者：wangif424 (赞：5)

~~构造题先搜索找规律~~。

## 分析思路

观察数据范围可知，这道题应当对于 $n$ 的奇偶分类讨论，但分类前，最好先探究它们的通性。

首先，这样的排列可以看作一个环，同时它要求环上相邻两数值和的最大值减最小值的差最小。

由此，可以得出当 $n \le 3$ 时，任一输出一种排列即可，因为此时它们的所有排列在环上等价。

然后思考其他情况下，最小的相邻两数值和的极差可能是多少？

首先排除这个为 $0$，原因如下。

考虑一个排列中的一段区间 $a,b,c,d$,若 $a+b$ 为最大相邻两数值和，$c+d$ 为最小相邻两数值和，则有 $a+b \ge b+c \ge c+d$ 和 $a+b=c+d$，即 $a+b=b+c=c+d$，由等式基本性质可以得出 $a=c$ 和 $b=d$，显然，这与“一个排列”矛盾，因此不可能为 $0$。

再考虑这个值是否为 $1$。

仿照上述，若 $a+b$ 为最大相邻两数值和，$c+d$ 为最小相邻两数值和，则有 $a+b \ge b+c \ge c+d$ 和 $a+b=c+d+1$，若令 $b+c=a+b$，则会产生 $a=c$，反之令 $b+c=c+d$，又会产生 $b=d$，所以同样不为 $1$。

而当这个值为 $2$ 时，有 $a+b \ge b+c \ge c+d$ 和 $a+b=c+d+2$ ，因为当 $b+c$ 与 $a+b$ 或 $c+d$ 相等时会产生矛盾，因此 $a+b=b+c+1=c+1+d+1$ ,即原区间变化为 $a,b,a-1,b-1$，理论存在值为 $2$ 的构造。

极差为 $2$，再进一步考虑最大值和最小值的具体数值。

先考虑所有环上相邻两项的和 $\sum^{n}_{i=1}(a_i+a_{(i+1)\bmod n}) = 2 \times \sum^n_{i=1}a_i =n \times (n+1)$，由此得出相邻两项和的平均数为 $n+1$，因为极差为 $2$，所以最大值为 $n+2$，最小值为 $n$。

当拥有这些后似乎并不需要再回到奇偶性去考虑。

## 构造流程，代码实现

- 任意钦定一个范围内的数作为排列的第一个数 $x$。

- 考虑相邻两数字和的取值 $n,n+2,n+1$三种情况。

- 依次考虑 $n-x,n-x+2,n-x+1$ 作为下一个数字是否合法，如超范围，重复等情况。

附注：之所以要考虑相邻两数字和为平均值 $n+1$，是因为当 $n$ 为偶数时可能出现 $\frac{n}{2}+2,\frac{n}{2}$ 或是 $\frac{n}2-1,\frac{n}2+1$ 的情况下，和取 $n$ 或 $n+2$ 都会出现重复。

## 参考代码
```cpp
#include <bits/stdc++.h>
#define R(x) x = read()
#define ENDL putchar('\n');
#define SPACE putchar(' ');
#define akioi register
#define int long long
using namespace std;
inline void P(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9) {
		P(x / 10);
		x %= 10;
	}
	putchar(x ^ '0');
}
inline int read() {
	register int r=0,f=1;
	register char c=getchar();
	while(c>'9'||c<'0') {
		if(c=='-')f=0;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		r=(r<<3)+(r>>1)+(c^'0');
		c=getchar();
	}
	return f?(-r):r;
}
int n;
int vis[1000100];
signed main() {
	R(n);
	int p=1;
	P(p);
	SPACE
	vis[1]=1;
	for(int i=2; i<=n; i++) {
		p=n-p;
		if(vis[p]) {
			p+=2;
			if(vis[p]||p>n)p--;
		}
		vis[p]=1;
		P(p);
		SPACE
	}
	return 0;
}
```
ctj 的朋友们，谁说参考代码一定能 AC 呢？

---

## 作者：maomao233 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P9578)

首先理解函数 $f$ 的含义。  
实际上，我们可以把带入的数组看作为一个“环”，函数 $f$ 就是求这个环里所有的**相邻两数之和**的**最大值与最小值的差**。题意也就是要求你构造一个 $n$ 的排列 $\{p_n\}$，并使 $f(\{q_n\})$ 在所有 $n$ 的排列中最小。

于是我们便期望构造一个 $n$ 的排列，并使得其每个相邻两数之和的差距都尽可能地小。因为这样才可以使得“最大值与最小值的差”最小。

但如何求出“每个相邻两数之和”的平均值呢？此时，我们看向题目背景。

题目背景是一个求和公式（[高斯求和公式](https://baijiahao.baidu.com/s?id=1744730383586891590)），表示求出 $1+2+3+\cdots+n$ 的和，而我们需要求出“每个相邻两数之和”的平均值。  
注意到在这个排列（环）里，一共会有 $n$ 个相邻的**两数**。代入求和公式，于是我们得出，计算整个排列（环）的所有 $n$ 个相邻的两数之和为：

$$2\cdot\dfrac{n\times(n+1)}{2}$$

抵消后为 $n\times(n+1)$。

又由于有 **$\textbf{\textit{n}}$ 个**相邻的两数，于是我们再将其除以 $n$，得到：

$$\dfrac{n\times(n+1)}{n}$$

抵消后为 $n+1$。这个数就是“每个相邻两数之和”的平均值，非常妙。这样 $f(\{q_n\})$ 便为 $0$。

---

但是我们又遇到了一个问题，就是如果我们一直按照 $n+1$ 的标准来构造，一定会重复。  
举个栗子：设 $n=6$。首先，$p_1=1$，则 $p_2=(n+1-p_1)=(6+1-1)=6$。但若这样推下去，$p_3=1$，由于 $p_3=p_1$，所以这就不再是一个 $n$ 的排列了。  
想想也是，不会存在 $n\ge3$ 时 $f(\{q_n\})$ 还为 $0$ 的情况啊。

那么有没有什么好的解决方案吗？答案是有的。

我们不妨减少贪心成分，将标准 $n+1$ 改为区间 $[(n+1)-1,(n+1)+1]$，即区间 $[n,n+2]$。  
也就是说，当我们在构造时，相邻两数之和的方案可以有三种：$n,n+1,n+2$。  
这样，我们便可完美地构造出序列 $\{p_n\}$，并使得其满足以上所有条件。特别地，此时 $f(\{q_n\})=2$。

---

具体地阐述一下如何构造：

首先，统一地，$p_1=1$。

此时，我们不妨创建一个桶，来存储一个数是否使用过。在这里，我们设桶为 $a$。特别地，$a_1=1$，因为 $1$ 已经使用过。

然后我们便可开始决策。首先从相邻两数之和为 $n$ 开始判断，一直判断到 $n+2$。若有满足条件（要注意先后顺序），则将其存入答案序列，同时桶 $a$ 也对其进行标记操作。这样一步操作就算完成，最后输出答案序列即可。

但是这样还有一个问题。~~（怎么问题这么多？？？）~~

还是设 $n=6$，于是我们按照上面的方法，开始依次决策并构造：

首先是

$$p_1=1$$

其次，可以看到 $n-p_1=5$，而 $5$ 尚未使用过，于是 

$$p_2=5$$

再其次，可以看到 $n-p_2=1$，而 $1$ 已经使用过，于是再考虑 $n+1$，即 $(n+1)-p_2=2$，而 $2$ 尚未使用过，于是

$$p_3=2$$

再其次，可以看到 $n-p_3=4$，而 $4$ 尚未使用过，于是 

$$p_4=4$$

再其次，可以看到 $n-p_4=2$，而 $2$ 已经使用过，于是再考虑 $n+1$，即 $(n+1)-p_4=3$，而 $3$ 尚未使用过，于是

$$p_5=3$$

然后，你就会惊讶地发现，还有一个 $6$，无论如何也无法满足条件。  
于是，~~聪明的 maomao233~~ 想到了一个好方法：**尽量平均**。

什么意思？就是说：

- 如果上一次的相邻两数之和为 $n$，那么这次就**尽量**让相邻两数之和为 $n+2$。因为这样，$\dfrac{n+(n+2)}{2}$ 为 $n+1$，也就是一开始的平均值。
- 同样地，如果上一次的相邻两数之和为 $n+1$，那么这次就**尽量**让相邻两数之和为 $n+1$；
- 同样地，如果上一次的相邻两数之和为 $n+2$，那么这次就**尽量**让相邻两数之和为 $n$。

这可以说是一个小技巧。虽然看上去没有什么改变，实际上，正是此决策，可以构造出真正符合所有条件的排列。

同样按照上面的方法来：

还是设 $n=6$，于是我们按照上面的方法，开始依次决策并构造：

首先是

$$p_1=1$$

其次，可以看到 $n-p_1=5$，而 $5$ 尚未使用过，于是 

$$p_2=5$$

注意此时两数之和为 $n$。

再其次，由于上一次的相邻两数之和为 $n$，所以，这次我们考虑 $n+2$。可以看到 $(n+2)-p_2=3$，而 $3$ 尚未使用过，于是 

$$p_3=3$$

注意此时已经“平均”，下面可以不用再“想着上一次”。

再其次，可以看到 $n-p_3=3$，而 $3$ 已经使用过，于是再考虑 $n+1$，即 $(n+1)-p_3=4$，而 $4$ 尚未使用过，于是

$$p_4=4$$

注意此时 $n+1$ 也算是“平均”，下面也可以不用再“想着上一次”。

再其次，可以看到 $n-p_4=2$，而 $2$ 尚未使用过，于是 

$$p_5=2$$

同样，注意此时两数之和为 $n$。

再其次，由于上一次的相邻两数之和为 $n$，所以，这次我们考虑 $n+2$。可以看到 $(n+2)-p_5=6$，而 $6$ 尚未使用过，于是 

$$p_6=6$$

综上所述，排列 $\{p_n\}$ 为：$1,5,3,4,2,6$。这是真正意义上的满足了~~上树~~上述的所有条件。

特别地，笔者在写下这篇题解时，还意外的发现，构造的决策方式一定为：$n,n+2,n+1,n,n+2,n+1\cdots$，这才使得我构造出的排列似乎有那么一丝丝儿规律。

而代码实现也很简单。具体地讲，首先考虑是否可以满足“与上一次平均”。若可以则执行；否则，就再按照之前的想法考虑即可。  
实现起来就像是一个模拟。不过还需注意，若在决策第 $2$ 个数时（即 $p_2$），需要特判，无需再“想着上一次”。

至此，我们便完成了本题。%%%  
得代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void rd(T &x){x=0;char c=getchar();bool f=0;while(!isdigit(c)){if(c=='-'){f=1;}c=getchar();}while(isdigit(c)){x=(x<<3)+(x<<1)+(c^'0');c=getchar();}if(f){x=~(x-1);}}
template<typename T,typename...Args>inline void rd(T &x,Args&...args){rd(x);rd(args...);}
inline void wt(int x){if(x<0){putchar('-'),x=-x;}if(x>9){wt(x/10);}putchar(x%10+'0');}
#define pc(x) putchar(x)
#define wtl(x) wt(x),pc('\n')
#define kg pc(' ')
#define hh pc('\n')
bool a[1000010];
int ans[1000010];
signed main()
{
	int n;
	rd(n);
	wt(1),kg,a[1]=ans[1]=1;
	for(int i=2;i<=n;i++)
	{
		int flag=0;
		if(!a[n-ans[i-1]]&&(i==2||(i>=3&&ans[i-1]+ans[i-2]==(n+2))))
		{
			int x=n-ans[i-1];
			a[x]=1,ans[i]=x,flag=1;
		}
		else if(!a[(n+1)-ans[i-1]]&&(i==2||(i>=3&&ans[i-1]+ans[i-2]==(n+1))))
		{
			int x=(n+1)-ans[i-1];
			a[x]=1,ans[i]=x,flag=1;
		}
		else if(!a[(n+2)-ans[i-1]]&&(i==2||(i>=3&&ans[i-1]+ans[i-2]==n)))
		{
			int x=(n+2)-ans[i-1];
			a[x]=1,ans[i]=x,flag=1;
		}
		else
		{
			if(!flag)
			{
				if(!a[n-ans[i-1]])
				{
					int x=n-ans[i-1];
					a[x]=1,ans[i]=x,flag=1;
				}
				else if(!a[(n+1)-ans[i-1]])
				{
					int x=(n+1)-ans[i-1];
					a[x]=1,ans[i]=x,flag=1;
				}
				else if(!a[(n+2)-ans[i-1]])
				{
					int x=(n+2)-ans[i-1];
					a[x]=1,ans[i]=x,flag=1;
				}
			}
			else
			{
				break;
			}
		}
	}
	for(int i=2;i<=n;i++)
	{
		wt(ans[i]),kg;
	}
	hh;
	return 0;
}
```

---

## 作者：_determination_ (赞：2)

noip 考前押一波思维题。

遇到构造，先打出来几组数据看看。

以下内容格式均为 `n：` 开头，后接答案。
## 偶数部分

```
4:
1 3 2 4

6:
1 5 3 4 2 6

8:
1 7 3 5 4 6 2 8
...
...
```

发现前半段奇数，后半段偶数。研究如何构造前半段，如何构造后半段。

1. 前半段   显然从前往后顺序为小，大，次小，次大……
1. 后半段   显然是前半段的构造方式翻转，即中，……次小，次大，小，大。

然后直接跑。

## 奇数部分

```
3:
1 2 3
5:
1 4 3 2 5
7:
1 6 3 4 5 2 7
```

发现按下标奇偶分类后，奇数下标部分为递增的奇数，偶数下标部分为递减的偶数。

---

## 作者：Eason_cyx (赞：2)

构造题。

看到构造，我们首先就想到先用暴力做小数据，看看输出：

直接枚举全排列就行。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[15];
int main() {
	for(int i = 1;i <= 8;i++) {
		n = i;
		for(int j = 1;j <= 10;j++) a[j] = j;
		int ans = 0x7fffffff;
		do {
			int maxn = 0,minn = 0x7fffffff;
			for(int i = 1;i <= n;i++) {
				int now = a[i] + a[(i % n) + 1];
				maxn = max(maxn,now);
				minn = min(minn,now);
			}
			ans = min(ans,maxn-minn);
		} while(next_permutation(a+1,a+n+1));
		do {
			int maxn = 0,minn = 0x7fffffff;
			for(int i = 1;i <= n;i++) {
				int now = a[i] + a[(i % n) + 1];
				maxn = max(maxn,now);
				minn = min(minn,now);
			}
			if((maxn - minn) == ans) break;
		} while(next_permutation(a+1,a+n+1));
		for(int j = 1;j <= n;j++) cout << a[j] << " \n"[j == n];
	}
	return 0;
}
```

输出结果：

```
n = 1:1
n = 2:1 2
n = 3:1 2 3
n = 4:1 3 2 4
n = 5:1 4 3 2 5
n = 6:1 5 3 4 2 6
n = 7:1 6 3 4 5 2 7
n = 8:1 7 3 5 4 6 2 8
```

看不出来啥？我们把 $n=8$ 拿出来看看：

$1+8=9$

$7+2=9$

$3+6=9$

$\dots$

而且我们发现，第一组是小在前，大在后；第二组是大在前，小在后；第三组是小在前，大在后 $\dots$

这样，规律就找到了。

```cpp
#include <iostream>
using namespace std;
int a[1000005];
int main() {
	int n; cin >> n;
	if(n % 2 == 0) {
		bool flag = false; //false表示小的放前面
		for(int i = 1;i <= n/2;i++) {
			int now1 = i,now2 = n + 1 - i;
			if(flag) {
				a[i] = now2;
				a[n-i+1] = now1;
			}
			else {
				a[i] = now1;
				a[n-i+1] = now2;
			}
			flag = !flag;
		}
		for(int i = 1;i <= n;i++) cout << a[i] << " \n"[i == n];
	}
	else {
		bool flag = false;
		for(int i = 1;i <= n/2;i++) {
			int now1 = i,now2 = n + 1 - i;
			if(flag) {
				a[i] = now2;
				a[n-i+1] = now1;
			}
			else {
				a[i] = now1;
				a[n-i+1] = now2;
			}
			flag = !flag;
		}
		a[n/2+1] = (n+1)/2;
		for(int i = 1;i <= n;i++) cout << a[i] << " \n"[i == n];
	}
	return 0;
}
```

总结：质量很高的有意思构造题。

---

## 作者：Frozen_Ladybug (赞：2)

我们需要的就是让相邻两数的最大值减去最小值尽量小。

先考虑最大值如何最小：对于 $n$，两侧最小也需要放 $1$ 和 $2$，最大值至少为 $n+2$。

同时对于 $1$，旁边需要放尽量大的，那么最好就是 $n$ 和 $n-1$。

这样看起来，我们要求的最小值的最大值就是 $n$。

所以除了 $n=1$ 或者 $n=2$ 的特殊情况外，我们要构造的序列的值最小是 $2$。

再来思考一下能不能达到 $2$，对于大于 $\frac{n}{2}$ 的 $i$，两侧可以放 $n-i+2$ 和 $n-i+1$。对于小于 $\frac{n}{2}$ 的 $i$，它的两侧可以放 $n-i+1$ 和 $n-i$。

可以验证这样摆放再处理一下 $n$ 为偶数的特殊情况，就可以使值为 $2$。

再考虑如何生成输出的数列。首先确定 $n$ 放在中间，旁边是 $1$ 和 $2$，然后 $1$ 和 $2$ 的另一边是 $n-1$ 和 $n-2$，以此类推。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/938sk7ay.png)

特殊的是，如果 $n$ 为偶数，可以把最后一个数即 $\frac{n}{2}$ 放在任意一端点。

下面上代码：
```c
#include<bits/stdc++.h>
using namespace std;
int n,a,b[1000005],now,cnt=1,m,M,x;//m即最小值,M即最大值;b数组表示排列
int main(){
	scanf("%d",&n);
	now=n,m=1,M=n-1,x=ceil(1.0*n/2),b[x]=n;//按照思路，中间点初始化为n
	while(cnt<=(n-1)/2)//只要cnt不超过项数的一半,一直循环
		if(cnt&1){//即cnt%2==1的简写
		    b[x-cnt]=m;
		    b[x+cnt]=m+1;//数组左侧填上m,右侧填上m+1
		    m+=2;//最小值往大了更新,cnt加1即又填了一组数
		    ++cnt;
		}
		else{//cnt为偶数
		    b[x-cnt]=M;
		    b[x+cnt]=M-1;//这两个和上面同理
		    M-=2;//最大值往小了更新
		    ++cnt;
		}
	if(n%2==0) b[n]=m;//如果n是偶数,最后一个数直接填上m(当然写b[0]=m也是可以的,把输出改一下就行)
	for(int i=1;i<=n;++i) printf("%d ",b[i]);//输出
	return 0;
}
```


---

## 作者：Null_h (赞：2)

## 题意

给定一个正整数 $n$，你需要构造一个 $n$ 的环形排列，最小化排列中任意相邻两数的和的最大值与最小值的差。

从任意数开始顺序输出这个排列。

## 思路

我们首先最小化最大值，此时 $n$ 的左右只能为 $1$ 和 $2$，那么最大值就是 $n+2$。

接着最大化最小值，同理，$1$ 的左右只能是 $n$ 和 $n-1$，恰好不与最大值最小的情况矛盾。

再思考一种可行的构造方法，由于是环形，可以将 $1$ 与 $n$ 置于两端，此时可以确定 $n-1$ 位于第 $2$ 位，$2$ 位于第 $n-1$ 位。于是就有了一种大胆的猜测，不断将和为 $n+1$ 的一对数分别置于两端，第一个数为偶数时交换这对数的位置。

对于任意一个数，可以证明，其与它相邻数的和恰为 $n$ 及 $n+2$，满足要求。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
int a,b[1000010];
signed main() {    
	cin>>a;
	int l=1,r=a;
	while(l<=r){
		if(l%2==1){
			b[l]=l;
			b[r]=r;	
		}else{
			b[r]=l;
			b[l]=r;
		}
		l++;
		r--;
	}
	for(int i=1;i<=a;i++){
		cout<<b[i]<<" ";
	}
	return 0;
}
//1 7 3 5 4 6 2 8
```

---

## 作者：include13_fAKe (赞：2)

## 前言
这是我第一道在赛事独立完成的 Div.2B。

也是我洛谷月赛 Div.2 第一次进全网前 $10\%$。

还是我洛谷月赛首次得分超过 $230$（以前的纪录是 $229$）。

特以此篇题解纪念。

## 题意

构造一个 $1\sim n$ 的排列，首尾相连，使得相邻两数的和的**最大值**和**最小值**的差距尽量小。

## 思路
### Subtask $1$
打表即可。

可以证明，无论  $n$ 取何值，差距最小都为 $2$。
### Subtask $2\sim4$
在打表时，我们可以把结果记录下来。

当 $n$ 取值 $5\sim10$ 时，结果分别如下：
- $n=5:\text{1,4,3,2,5}$
- $n=6:\text{1,5,3,4,2,6}$
- $n=7:\text{1,6,3,4,5,2,7}$
- $n=8:\text{1,7,3,5,4,6,2,8}$
- $n=9:\text{1,8,3,6,5,4,7,2,9}$
- $n=10:\text{1,9,3,7,5,6,4,8,2,10}$

可以发现，当 $n \equiv 1 \pmod 2$ 时，正解即**从小到大输出奇数，从大到小输出偶数，奇偶相间。**

即 $1,n-1,3,n-3,\dots,4,n-2,2,n$。

当 $4\mid n$ 时，将奇数最小的和最大的配对，第二小的和第二大的配对，直到全部配对完为止。然后一对一对地输出。偶数也是这么配对的，但要倒序输出。

当 $n \equiv 2 \pmod 4$ 时，也像 $4\mid n$ 时一样配对。但是奇偶数各会单出来一个，我们在将奇数配完后就把单出来的两个数输出，然后再去配对偶数。
## 代码
全是打表，但和我上面写的可能还有些区别。
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int main(){
	cin>>n;
	if(n%2){
		for(int i=1;i<=n;i++){
			if(i%2)	cout<<i<<' ';
			else	cout<<n-i+1<<' ';
		}
	}
	else if(n%4==0){
		for(int i=1;i<=n/2;i+=2){
			cout<<i<<' '<<n-i<<' ';
		}
		for(int i=n/2;i>=1;i-=2){
			cout<<i<<' '<<n+2-i<<' ';
		}
	}
	else{
		for(int i=1;i<n/2;i+=2){
			cout<<i<<' '<<n-i<<' ';
		}
		cout<<n/2<<' '<<n/2+1<<' ';
		for(int i=n/2-1;i>0;i-=2){
			cout<<i<<' '<<n-i+2<<' ';
		}
	}
	return 0;
}
```

---

## 作者：SA_forever (赞：1)

### 题意：
给出一个整数 $n$，要求给出一个长度为 $n$ 的环使得任意相邻两点之间的和最大值与任意相邻两点之间的和最小值的差最小。

#### 例：当 $n=4$ 时，答案为 $1$ $4$ $2$ $3$，如图，此时最大和为 $6$，最小差值为 $4$，最大值与最小值的差为 $2$，经证明可知是最小的。
![](https://cdn.luogu.com.cn/upload/image_hosting/clcpja85.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

证明:最大和为 $n+2$，最小和为 $n\div2-1+n\div2+1=n$ 所以当和差为 $2$ 时即最优解。

------------
### 思路：
#### 由于题目要求求出最大和与最小和的差值最小的情况，所以我们只需要让最大值尽量小，最小值尽量大即可。

------------
### 实现过程：
#### 要使最大和最小，只需要在大的值旁边放小的值，要使最小和最大，只需要在小的值旁边放大的值。
例：当 $n=4$ 时，最大值是 $4$，那就需要在最大值旁边放最小值和次小值，也就是 $1$ 和 $2$，因为最小值是 $1$，那就需要在最小值旁边放最大值和次大值，也就是 $3$ 和 $4$。具体思路可以参考高斯求和，将第 $k$ 大值和第 $k$ 小值放一起即可。

最后只要将环型改为线型输出即可。

------------
### 注意：
代码实现中,$n$ 为偶数和 $n$ 为奇数的情况要区分判断。
### 当 *n* 为偶数时：
|$n$|$1$|$n-1$|$3$|$n-3$|$\cdots$|$n-4$|$4$|$n-2$|$2$|
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
### 当 $n$ 为奇数时：
|$n$|$1$|$n-1$|$3$|$n-3$|$\cdots$|$2\times k+1$|$n-2\times k-1$|$2\times(k+1)+1$|$n-2\times(k+1)-1$|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

------------
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000010],cnt1,cnt2;
int main(){
	cin>>n;
	cnt1=1;//cnt1为从小到大的值 
	cnt2=n-1;//cnt2为从大到小的值 
	if(n%2==0){//n为偶数，从两边向中间推 
		a[1]=n;
		for(int i=2,j=n;i<=j;i+=2,j-=2){//i为从小到大的指针,j为从大到小的指针 
			a[i]=cnt1++;
			if(i==j)
				break;//防止i重复填 
			a[j]=cnt1++;
			a[i+1]=cnt2--;
			if(i+1==j-1)
				break;//防止i+1重复填 
			a[j-1]=cnt2--;
		}
	}else{//n为奇数，从前往后推 
		a[1]=n;
		for(int i=2;i<=n;i++){
			if(i%2==0){
				a[i]=cnt1++;//一次加2，防止填重复的值 
				cnt1++;
			}else{
				a[i]=cnt2--;//一次减2，理由同上 
				cnt2--;
			}
		}
	}
	for(int i=1;i<=n;i++)
		cout<<a[i]<<" ";//线型输出 
	return 0;
}
```

------------
### 后记：
这是我第一篇题解，什么都不熟练，思路也讲的不清晰，如有问题请评论一下，还请见谅,管理员多次审核我的题解，真的很抱歉耽误您的时间。

---

## 作者：Vct14 (赞：1)

### 简要题意

构造一个 $n$ 个数的环，使环上相邻的两数之和的最大值与最小值的差最小。

### 分析

找规律。

对于子任务 $1$，暴力枚举即可。

将暴力代码跑出的结果放出来。

```
1
1 2
1 2 3
1 3 2 4
1 4 3 2 5
1 5 3 4 2 6
1 6 3 4 5 2 7
1 7 3 5 4 6 2 8
```
可以发现，构造出的序列正数第 $i$ 个与倒数第 $i$ 个为 $i$ 和 $n-i+1$。并且若 $a_{i-1}=i-1$，则 $a_i=n-i+1$，$a_{n-i+1}=i$；若 $a_{i-1}=n-(i-1)+1=n-i+2$，则 $a_i=i$，$a_{n-i+1}=n-i+1$。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;

int a[1000002];

int main(){
	int n;cin>>n;
	a[1]=1;a[n]=n;
	for(int i=2; i<=(n+1)/2; i++){
		if(a[i-1]==i-1) a[i]=n-i+1,a[n-i+1]=i;
		else a[i]=i,a[n-i+1]=n-i+1;
	}
	for(int i=1; i<=n; i++) cout<<a[i]<<" ";
	return 0;
}
```

---

## 作者：2021sunzishan (赞：1)

## 题目大意：
给定一个正整数 $n$，构造一个长度为 $n$ 的序列 $a$，使得此序列中包含 $1\sim n$ 这 $n$ 个数，且在相邻两个数差的最大值和最小值之差最小。且相邻指环上的相邻。

## 思路：
因本人实在太弱，所以选择了找规律打这道题。

怎么找呢？

下面是一份 $20$ 分的暴力 dfs 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int k=INT_MAX,ans[100005];
int a[1000005];
bool vis[100005];
inline int read(){
	int a=0,f=1;
	char c;
	c=getchar();
	while(c<'0'||c>'9'){
		if  (c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		a=a*10+(c-'0');
		c=getchar();
	}
	return f*a;
}
int pd(){
	int maxn=0,minn=INT_MAX;
	for(int i=1;i<=n;i++){
		int j=(i%n)+1;
		maxn=max(maxn,a[i]+a[j]);
		minn=min(minn,a[i]+a[j]);
	}
	return maxn-minn;
}
void dfs(int x){
	if(x>n){
		int s=pd();
		if(s<k){
			k=s;
			for(int i=1;i<=n;i++)
				ans[i]=a[i];
		}
		return;
	}
	for(int i=1;i<=n;i++){
		if(vis[i])continue;
		vis[i]=1;
		a[x]=i;
		dfs(x+1);
		vis[i]=0;
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();
	dfs(1);
	for(int i=1;i<=n;i++)
		printf("%d ",ans[i]);
	return 0;
}

```
非常好理解对不对？

用它打印出 $n$ 为 $1\sim 9$ 时的序列。

$1$

$1 2$

$1 2 3$

$1 3 2 4$

$1 4 3 2 5$

$1 5 3 4 2 6$

$1 6 3 4 5 2 7$

$1 7 3 5 4 6 2 8$

$1 8 3 6 5 4 7 2 9$

你有什么发现？

咦？头和尾和相等？

例如 $n=9$ 时，$1+9=10$，$2+8=10$
，最后剩下的是 $5$，因为 $9$ 为奇数。

不难发现，以上列都满足这规律，第 $i$ 项和与第 $n-i+1$ 项值和为 $n+1$。

所以一下就是本题的代码了。

**切勿抄袭！！！**
## 代码：
```cpp
#include<cstdio>
int n;
int a[1000005];
inline int read(){
	int a=0,f=1;
	char c;
	c=getchar();
	while(c<'0'||c>'9'){
		if  (c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		a=a*10+(c-'0');
		c=getchar();
	}
	return f*a;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();
	int l=0,r=n+1;
	for(int i=1;i<=(n+1)/2;i++)
		if(i%2){
			a[++l]=i;
			a[--r]=n+1-i;
		}else{
			a[--r]=i;
			a[++l]=n-i+1;
		}
	for(int i=1;i<=n;i++)
		printf("%d ",a[i]);
	return 0;
}
```
完结~

---

## 作者：Coffee_zzz (赞：1)

手算可以发现，对于最优的 $1$ 到 $n$ 的排列 $\{p_n\}$，$f(\{p_n\})$ 的值一定为 $2$。接下来考虑证明这个结论。

令 $a_i=p_i+p_{(i \bmod n)+1}$，则 $f(\{p_n\})=(\max\limits_{i=1}^{n} a_i)-(\min\limits_{i=1}^{n} a_i)$。

因为 $1+2+3+\cdots+n=p_1+p_2+p_3+\cdots+p_n=\dfrac {n \times (n+1)} 2$，所以 $a_1+a_2+a_3+\cdots+a_n=n \times (n+1)$，$\bar{a}=n+1$。

我们知道 $\{a_n\}$ 中的元素一定不全部相等，所以 $(\max\limits_{i=1}^{n} a_i)-(\min\limits_{i=1}^{n} a_i) \neq 0$。  
我们还知道 $\bar{a}$ 为整数，所以 $(\max\limits_{i=1}^{n} a_i)-(\min\limits_{i=1}^{n} a_i) \neq 1$。

现在我们只需要构造出满足 $f(\{p_n\})=2$ 的排列 $\{p_n\}$ 就可以证明上面的结论了。

因为 $f(\{p_n\})=2$ 且 $\bar{a}=n+1$，所以 $\{a_n\}$ 中只能包含 $n,n+1,n+2$。

接下来我们在 $n$ 较大的一般情况下讨论。

对于 $\{p_n\}$ 中为 $1$ 的那一项，它的旁边只能是 $n$ 和 $n-1$；  
对于 $\{p_n\}$ 中为 $n$ 的那一项，它的旁边只能是 $1$ 和 $2$；  
同理，对于 $\{p_n\}$ 中为 $2$ 的那一项，它的旁边只能是 $n$ 和 $n-2$，不能是 $n-1$ 是因为 $n-1$ 已经在 $1$ 的旁边了；  
再同理，对于 $\{p_n\}$ 中为 $n-1$ 的那一项，它的旁边只能是 $1$ 和 $3$，不能是 $2$ 是因为 $2$ 在 $n$ 的旁边了；  
以此类推，我们能得到 $\{p_n\}$ 应为 $\{1,n-1,3,n-3,5,\cdots,n-4,4,n-2,2,n\}$。注意当 $n$ 为奇数时不要漏掉第 $\dfrac {n+1} 2$ 项。

---

## 作者：I_will_AKIOI (赞：0)

先看题目：$f(\{x_n\})=\max\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})-\min\limits_{i=1}^{n}(x_i+x_{(i \bmod n)+1})$。看不懂怎么办？我们发现 $x_i+x_{(i \bmod n)+1}$ 其实就是 $x_i$ 和他的下一个数的和。定义 $x_n$ 的下一个数为 $x_1$。所以题目意思翻译成人话就是：构造一个排列，最小化这个排列相邻两个数和的最大值减最小值。

理解题意后我们做题。为了使最大值减最小值最小，我们需要让这个序列相邻两个数的和尽可能稳定。所以我们可以将大数字 $(>\displaystyle\frac{n}{2})$ 和小数字 $(\le\displaystyle\frac{n}{2})$ 平均分到两边，并且交叉放置，就可以使差值最小。

我们首先定义一个 $a$ 数组，用于记录答案。令 $a_i=i$。这样我们可以保证 $a_i+a_{n-i+1}$ 都相等。然后，我们再进行调整。当 $n=6$ 时，数组是这样的：

$$\blue1\ \blue2\ \blue3\ \red4\ \red5\ \red6$$

由于数组左半边（蓝色部分）都是小数字，右边都是大数字。所以我们需要进行修改。将 $2$ 和 $5$ 调换位置，得到：

$$\blue1\ \red5\ \blue3\ \red4\ \blue2\ \red6$$

这样就达到了平衡的效果，并且交叉放置数字。计算一下：和的最大值是 $5+3=8$，最小值是 $4+2=6$。枚举可以证明差值没有小于 $2$ 的。

送上题解最短代码，共 $235$ B：
```
#include<iostream>
using namespace std;
int n,a[1<<20];
int main()
{
  cin>>n;
  for(int i=1;i<=n;i++) a[i]=i;
  for(int i=1;i<=n/2;i++) if(i%2==0) swap(a[i],a[n-i+1]);
  for(int i=1;i<=n;i++) cout<<a[i]<<" ";
  return 0;
}
```

---


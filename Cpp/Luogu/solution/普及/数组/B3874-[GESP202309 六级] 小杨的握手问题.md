# [GESP202309 六级] 小杨的握手问题

## 题目描述

小杨的班级里共有 $N$ 名同学，学号从 $0$ 至 $N-1$。

某节课上，老师安排全班同学进行一次握手游戏，具体规则如下：老师安排了一个顺序，让全班 $N$ 名同学依次进入教室。每位同学进入教室时，需要和 **已经在教室内** 且 **学号小于自己** 的同学握手。

现在，小杨想知道，整个班级总共会进行多少次握手。

**提示：可以考虑使用归并排序进行降序排序，并在此过程中求解。**

## 说明/提示

**样例解释 1**:

$2$ 号同学进入教室，此时教室里没有其他同学。

$1$ 号同学进入教室，此时教室里有 $2$ 号同学。$1$ 号同学的学号小于 $2$ 号同学，因此他们之间不需要握手。

$3$ 号同学进入教室，此时教室里有 $1,2$ 号同学。$3$ 号同学的学号比他们都大，因此 $3$ 号同学需要分别和另外两位同学握手。

$0$ 号同学进入教室，此时教室里有 $1,2,3$ 号同学。$0$ 号同学的学号比他们都小，因此 $0$ 号同学不需要与其他同学握手。

**样例解释2：**

全班所有同学之间都会进行握手，因为每位同学来到教室时，都会发现他的学号是当前教室里最大的，所以他需要和教室里的每位其他同学进行握手。

对于 $30\%$ 的测试点，保证 $N\le100$。

对于所有测试点，保证 $2\le N\le3\times10^5$。


## 样例 #1

### 输入

```
4
2 1 3 0```

### 输出

```
2```

## 样例 #2

### 输入

```
6
0 1 2 3 4 5```

### 输出

```
15```

# 题解

## 作者：wsx248 (赞：16)

分析题意不难看出，如果所有人倒序进入教室，就变成了普通的逆序对问题。

直接归并排序或者树状数组求解即可。

解法一：归并排序
```
#include<iostream>
using namespace std;
const int N = 3e5+5;
int n;
int a[N], b[N];
long long ans = 0;

void merge(int l, int r)
{
	int mid = l + r >> 1;
	if(l>=r)
		return;
	merge(l, mid);
	merge(mid+1, r);
	int i = l, j = mid + 1, k = 0;
	while(i<=mid && j<=r)
	{
		if(a[i]>a[j])
		{
			ans += mid - i + 1;
			b[++k] = a[j++];
		}
		else
			b[++k] = a[i++];
	}
	while(i<=mid)
		b[++k] = a[i++];
	while(j<=r)
		b[++k] = a[j++];
	
	for(int i=l;i<=r;i++)
		a[i] = b[i-l+1];
}

int main()
{
	cin>>n;
	for(int i=n;i;i--)	//倒序读入数据
		cin>>a[i];
	merge(1, n);
	cout<<ans;
	return 0;
}
```

解法二：树状数组
```
#include<iostream>
using namespace std;
const int N = 3e5+5;
int n;
int a, c[N];
long long ans;

int lowbit(int x)
{
	return x & -x;
}

void add(int x, int y)
{
	for(int i=x;i<=n;i+=lowbit(i))
		c[i] += y;
}

int ask(int x)
{
	int res = 0;
	for(int i=x;i;i-=lowbit(i))
		res += c[i];
	return res;
}

int main()
{
	cin>>n;
	for(int i=n;i;i--)
	{
		cin>>a;
		a++;	//由于lowbit(0)=0，注意把a整体向右偏移一位 
		ans += ask(a-1);
		add(a, 1);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：szh_AK_all (赞：11)

每位同学进入教室时，需要和已经在教室内且学号小于自己的同学握手，我们需要求出整个班级总共会进行多少次握手，也就是要求：有多少对 $(i,j)$ 满足 $i<j$ 并且 $a _ {i}<a _ {j}$。这里的 $i<j$ 对应“已经在教室内”，$a _ {i}<a _ {j}$ 对应“和学号小于自己的同学握手”。

正如题面所说，我们可以使用归并排序将学号进行降序排序，并在此过程中求解。

具体的，我们在每次分治进行排序时，会得到一个区间，假设左端点为 $x$，右端点为 $y$，区间的中点为 $mid$。我们称 $x-mid$ 这一段区间为左区间，$mid+1-y$ 这一段区间为有区间，那么，左区间和右区间一定是有序的（所以，每次归并排序前都要将左区间和右区间分别进行归并排序）。

再使用双指针将整个区间进行排序，一个指针指向左区间，另一个指针指向右区间，比较左指针所对应的数与右指针所对应的数，将较大的数加入一个新数组中，并将较大数所对应的指针往后移一位，以此类推，直到两个指针都指向区间末尾为止。

那么，为什么解决这道题要用归并排序呢？

在排序过程中，满足题意的 $(i,j)$ 分为以下三种情况：
1. $i,j$ 都在左区间；
2. $i,j$ 都在右区间；
3. $i$ 在左区间，$j$ 在右区间。

我们只需要考虑第三种情况，因为第一、二种情况会在后几层的归并排序中被视为第三种情况。当指向左区间的指针 $p1$ 所对应的数小于指向右区间的指针 $p2$ 所对应的数时，我们可以发现：$p1-mid$ 这些位置所对应的数都小于 $p2$ 所对应的数（因为左区间是有序且降序的）。由此，解决这道题已经很容易了。

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[300005],b[300005];
int n;
long long ans;
void xu(int x,int y)//归并排序
{
	if(x==y)
		return;
	int mid=(x+y)/2;
	int p1=x;
	int p2=mid+1;
	int p=x;
	xu(p1,mid);//排序左区间
	xu(p2,y);//排序右区间
	while(p1<=mid||p2<=y)
	{
		if(p1>mid)
		{
			b[p]=a[p2];
			p2++;
			p++;
		}
		else if(p2>y)
		{
			b[p]=a[p1];
			p1++;
			p++;
		} 
		else if(a[p1]>=a[p2])
		{
			b[p]=a[p1];
			p1++;
			p++;
		}
		else
		{
			b[p]=a[p2];
			p2++;
			p++;
			ans+=mid-p1+1;//累加答案，p1-mid所对应的数都小于a[p2]
		}
	}
	for(int i=x;i<=y;i++)
		a[i]=b[i];
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	xu(1,n);
	cout<<ans;
}
```


---

## 作者：AuZeb (赞：6)

### 题意转换

每位同学进入教室时，需要和 **已经在教室内** 且 **学号小于自己** 的同学握手。

相反，每位同学会为学号大于自己的同学贡献，并在进入教室时统计自己受到的贡献。因为先进入教室的人先统计自己受到的贡献，所以后进入教室的人对先进入教室的人的贡献是不被统计的，即证明这个思路是正确的。

那么，本题就是 $n$ 次区间修改与单点查询，可以使用分块完成。

### 代码

```cpp
//P1908 逆序对（比本题多了离散化，数据强于本题）
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int id,v;
}a[500005];
int n,ans=0,f[500005],k[710],L[710],R[710],pos[500005],sq;
bool cmp1(node x,node y) {return x.v<y.v;}
bool cmp2(node x,node y) {return x.id<y.id;}
void pre(){
	cin>>n; sq=sqrt(n);
	for(int i=1;i<=n;i++) {a[i].id=i;cin>>a[i].v;}
	sort(a+1,a+n+1,cmp1);
	int vv=1;
	for(int i=1;i<=n;){
		while(a[i].v==a[i+1].v) a[i].v=vv,i++;
		a[i].v=vv,vv++,i++;
	}
	sort(a+1,a+n+1,cmp2);
	for(int i=1;i<=sq;i++) L[i]=(i-1)*sq+1,R[i]=i*sq; R[sq]=n;
	for(int i=1;i<=sq;i++) for(int j=L[i];j<=R[i];j++) pos[j]=i;
	return;
}
signed main(){
	pre();
	for(int i=1;i<=n;i++){
		int p=pos[a[i].v];
		if(1==p) for(int j=1;j<a[i].v;j++) f[j]++;
		else{
			for(int j=1;j<p;j++) k[j]++;
			for(int j=L[p];j<a[i].v;j++) f[j]++;
		}
		ans+=f[a[i].v]+k[p];
	}
	cout<<ans;
	return 0; 
}
```

---

## 作者：CQ_Bob (赞：5)

## 分析

很神奇，你猜我为什么交了这么多次。

对于每个人需要握手的次数，是小于他的编号数量。这是很模板的树状数组，注意一下学号问题和加点的位置就行了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define re register
#define il inline

const int N=3e5+10;
int n;
long long ans,tr[N];

il void add(int x){while(x<=n) ++tr[x],x+=x&(-x);}
il long long query(int x){long long ans=0;while(x) ans+=tr[x],x-=x&(-x);return ans;}

il void solve(){
	scanf("%d",&n);
	for(re int i=1;i<=n;++i){
		int x=0;scanf("%d",&x),++x;
		ans+=query(x-1),add(x);
	}
	printf("%lld\n",ans);
	return ;
}

signed main(){
//	int t;cin>>t;while(t--)
	solve();
	return 0;
}
```


---

## 作者：IOI_AK_TLR (赞：3)

# 思路

类似于求逆序对数量，把 [模版题](https://www.luogu.com.cn/problem/B3874) 代码中的 `<=` 换成 `>` 即可。

可以用归并排序来求，回溯的过程中一旦右半部分某个数大于左半部分的第 $i$ 个数，则会对答案产生 $L-i$ 的贡献（其中 $L$ 是左半部分数的数量）。

------------

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10;
int n,a[N],new_a[N];
int gb(int L,int R)
{
	if(L>=R)
		return 0;
	int mid=(L+R)>>1,le=L,ri=mid+1,ind=L,ans=0;
	ans+=gb(L,mid);
	ans+=gb(mid+1,R);
	while(le<=mid&&ri<=R)
	{
		if(a[le]>a[ri])
			new_a[ind++]=a[le++];
		else
			new_a[ind++]=a[ri++],ans+=mid-le+1;
	}
	while(le<=mid)
		new_a[ind++]=a[le++];
	while(ri<=R)
		new_a[ind++]=a[ri++];
	for(int i=L;i<=R;i++)
		a[i]=new_a[i];
	return ans;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	cout<<gb(1,n);
	return 0;
}


```


---

## 作者：Suite_No1_G (赞：2)

简要题面：

给你一个长度为 $n$ 的序列，问满足 $a_i<a_j$ 的 $(i,j)$ 对数。其中 $n≤3×10^5$。

我们观察，其实答案和将序列翻转后的逆序对个数一样。

然后就可以用归并排序求逆序对了。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=3e5+10;
int a[maxn],b[maxn];
long long ans=0;

void solve(int l,int r){
	if (l==r) return;
	
	int mid=(l+r)/2;
	solve(l,mid); solve(mid+1,r);
	int tot=l;
	int i=l,j=mid+1;
	
	while (i<=mid&&j<=r){
		if (a[i]<=a[j]){
			b[tot++]=a[i++];
		}else{
			ans+=(mid-i+1);
			b[tot++]=a[j++];
		}
	}
	
	while (i<=mid) b[tot++]=a[i++];
	while (j<=r) b[tot++]=a[j++];
	
	for (int t=l;t<=r;t++) a[t]=b[t];
}

int main(){
	int n;
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	reverse(a+1,a+1+n);
	solve(1,n);
	printf("%lld\n",ans);
	return 0;
} 
```


---


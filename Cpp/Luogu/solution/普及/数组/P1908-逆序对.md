# 逆序对

## 题目描述

猫猫 TOM 和小老鼠 JERRY 最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。

最近，TOM 老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中 $a_i>a_j$ 且 $i<j$ 的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。

**Update：数据已加强。**

## 说明/提示

对于 $25\%$ 的数据，$n \leq 2500$。

对于 $50\%$ 的数据，$n \leq 4 \times 10^4$。

对于所有数据，$1 \leq n \leq 5 \times 10^5$。

请使用较快的输入输出。

应该不会有人 $O(n^2)$ 过 50 万吧 —— 2018.8 chen_zhe。

## 样例 #1

### 输入

```
6
5 4 2 6 3 1
```

### 输出

```
11```

# 题解

## 作者：学无止境 (赞：1353)

好像不少题解都有些古老了，甚至还有误导人的错误的题解存在（深受其害）

因此蒟蒻在这里写一篇新题解，帮助和我一样的蒟蒻理解本题。


**Time：2018.11.3**
    
我会说明树状数组与归并排序两种解法，线段树解法与树状数组类似

---------------------

① 归并排序解法

首先你需要知道什么是归并排序。然后，我们可以这样想：

如果我们想要将一个序列排成从小到大有序的，那么每次划分后合并时左右子区间都是从小到大排好序的，我们只需要统计右边区间每一个数分别会与左边区间产生多少逆序对即可。

不懂的话看栗子：

```

//在某个时候，左区间：  5 6 7  下标为i
//           右区间：  1 2 9  下标为j
//          
//这个时候我们进行合并：
//step 1：由于 5>1，所以产生了逆序对，这里，我们发现，左区间所有还没有被合并的数都比 1 大，所以1与左区间所有元素共产生了 3 个逆序对(即tot_numleft-i+1对)，统计答案并合并 1 
//step 2：由于 5>2，由上产生了3对逆序对，统计答案并合并 2
//step 3：由于 5<9, 没有逆序对产生，右区间下标 j++
//step 4：由于 6<9, 没有逆序对产生，右区间下标 j++
//step 5：由于 7<9, 没有逆序对产生，右区间下标 j++
//step 6：由于右区间已经结束，正常执行合并左区间剩余，结束

//PS： tot_numleft=3，即左区间总元素个数
```
看懂了吧(莫名自信)

由于归并排序没有什么坑，正常执行并统计即可，注意 **答案会爆 $int$ ！**我们需要使用**$long$ $long$**存，如果使用 **$printf$** 输出，那么可别忘了用**%$lld$** ！

 复杂度与普通的归并排序相同，为$O(Nlog_2N)$
 
 效率：**$1682ms/4.43MB$  ** (数据更新之后)
 
**Code：**
```
#include<cstdio>
#include<iostream>
using namespace std;
int n,a[500010],c[500010];
long long ans;

void msort(int b,int e)//归并排序
{
    if(b==e)  
		return;
    int mid=(b+e)/2,i=b,j=mid+1,k=b;
    msort(b,mid),msort(mid+1,e);
    while(i<=mid&&j<=e)
    	if(a[i]<=a[j])
    		c[k++]=a[i++];
    	else
    		c[k++]=a[j++],ans+=mid-i+1;//统计答案
    while(i<=mid)
    	c[k++]=a[i++];
    while(j<=e)
    	c[k++]=a[j++];
    for(int l=b;l<=e;l++)
    	a[l]=c[l];
} 

int main()
{
    scanf("%d",&n); 
    for(int i=1;i<=n;i++)
    	scanf("%d",&a[i]);
    msort(1,n);
    printf("%lld",ans);
    return 0;
}

```
------
②树状数组解法

树状数组解法在这道题没有归并快，原因等会说

$Q1:$ 我们需要知道，怎么统计第 $ i $ 个数会与第$1 $~ $i-1$个数构成多少个逆序对呢?

$Ans1:$ 考虑根据值来建树状数组 , 初始树状数组为全 $0$。现在按照序列从左到右将数据的值对应的位置的数加一，代表又有一个数出现。因此，在循环到第 $i$ 项时，前 $i-1$ 项已经加入到树状数组内了 , 树状数组内比 $a_i$ 大的都会与$a_i$构成逆序对，因为它们一定出现的更早，所以产生的逆序对数量为$i-query(a_i)$  

注$:query(a_i)$ 代表在树状数组内询问 $1$ ~ $a_i$ 项的前缀和

$Q2:$ 根据 $a_i$ 来建树状数组空间不够啊？

$Ans2:$ 确实不够。但是我们需要的只是数据之间的相对大小，只需要满足大于或小于本身，与大多少无关，具体来说，举个栗子：
```
//  1 2 10000
//  1 2 3
//上面两个序列在本题是等效的，因为无论第三项是3还是10000，它都大于第一项和第二项
```
这启发我们对数据离散化，先将数据排序，再用 $1$ ~ $n$ 分别对应 $n$ 个数表示它们的相对大小，对新的序列建树状数组空间就够了$(n≤5×10^5)$

$Q3:$ 相等的元素是否会导致求解错误？每一个数（不管是否相等）对应的新数都不同诶？

$Ans3:$ 不处理的话会出错的，问题的关键在于是否有与 $a_i$ 相等的元素在      $a_i$ 前被加入且其相对大小标记更大。出现这种情况就会误将两个相等的数判为逆序对。怎么解决呢，只要所有与 $a_i$ 相等的元素中，先出现的标记也更小就好了(我们只统计相对更大的)。具体只需要在排序时将 $a_i$ 作为第一关键字，下标(第几个出现)作为第二关键字从小到大排序即可。

如果用的不是这个方法的树状数组，那么你 $WA$ 也多半是你忘记处理 $Q3$ 中提到的问题了，如果 $RE$ ，多半是空间开小了。

同时，再一次，注意 **答案会爆 $int$ ！**我们需要使用**$long$ $long$**存，如果使用 **$printf$** 输出，那么可别忘了用**%$lld$** ！

由于我们不仅要排序，还要建树状数组统计，所以，虽然两者复杂度相同，但是树状数组在这里会慢一些。

两种方法都是有必要掌握的，数据值域小的时候树状数组会更快，两者均有优点。

复杂度瓶颈在排序，为$O(Nlog_2N)$ 

效率$:2359ms/8.38MB$ (数据更新之后)

**$Code:$**

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int tree[500010],ranks[500010],n;
long long ans; 
struct point
{
    int num,val;
}a[500010];
inline bool cmp(point q,point w)
{
    if(q.val==w.val)
        return q.num<w.num;
    return q.val<w.val;
}
inline void insert(int p,int d)
{
    for(;p<=n;p+=p&-p)
        tree[p]+=d; 
}
inline int query(int p)
{
    int sum=0;
    for(;p;p-=p&-p)
        sum+=tree[p];
    return sum;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].val),a[i].num=i;
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++)
        ranks[a[i].num]=i;
    for(int i=1;i<=n;i++)
    {
        insert(ranks[i],1);
        ans+=i-query(ranks[i]);
    }
    printf("%lld",ans);
    return 0;
} 
```

如果哪里出锅了请告知我 $QWQ$ 

还不懂可以私我

---

## 作者：Strong_Jelly (赞：539)

# 归并排序

首先声明一下：这道题用冒泡排序是不能通过的，需要用归并排序

我们先来介绍一下**归并排序**

## 时间复杂度：

**O(n log n)**

## 空间复杂度:

**O(n)**

## 定义：

**归并排序是建立在归并操作上的一种有效的排序算法,该算法采用的是分治法（二分法）。**

## 算法流程：

先给个图：

![](https://cdn.luogu.com.cn/upload/pic/59594.png)

设n为序列元素的个数，a[i]为其中第i个元素，msort为归并排序的函数名，b[i]为两个相邻的子序列合并完的临时有序序列

**1.将一个序列进行二分，直到分解成n个元素（l == r）**

如代码：

```cpp
int mid = (l + r) / 2;//取中间 
if(l == r)//若l == r了，就代表这个子序列就只剩1个元素了，需要返回 
{
	return;
}
else
{
	msort(l, mid);//分成l和中间一段，中间 + 1和r一段（二分） 
	msort(mid + 1, r);
}
```

**2.将已有序的子序列合并（二分到最后的时候，一个元素一定是有序的），得到完全有序的序列**

如代码：

```cpp
int i = l;//i从l开始，到mid，因为现在排序的是l ~ r的区间且要二分合并 
int j = mid + 1;//j从mid + 1开始，到r原因同上
int t = l;//数组b的下标，数组b存的是l ~ r区间排完序的值 
while(i <= mid && j <= r)//同上i，j的解释 
{
	if(a[i] > a[j])//如果前面的元素比后面大(l ~ mid中的元素 > mid + 1 ~ r中的元素)(逆序对出现!!!) 
	{ 
		ans += mid - i + 1;//由于l ~ mid和mid + 1 ~ r都是有序序列所以一旦l ~ mid中的元素 > mid + 1 ~ r中的元素而又因为第i个元素 < i + 1 ~ mid那么i + 1 ~ mid的元素都 > 第j个元素。所以+的元素个数就是i ~ mid的元素个数，及mid - i + 1(归并排序里没有这句话，求逆序对里有) 
		b[t++] = a[j];//第j个元素比i ~ mid的元素都小，那么第j个元素是目前最小的了，就放进b数组里 
		++j;//下一个元素(mid + 1 ~ r的元素小，所以加第j个元素) 
	}
	else
	{
		b[t++] = a[i];//i小，存a[i] 
		++i;//同理 
	}
}
while(i <= mid)//把剩的元素(因为较大所以在上面没选) 
{
	b[t++] = a[i];//存进去 
	++i; 
}
while(j <= r)//同理 
{
	b[t++] = a[j];
	++j;
}
```

**将已有序的b数组赋值到a数组（原数组）里**

如代码：

```cpp
for(register int i = l; i <= r; ++i)//把有序序列b赋值到a里 
{
	a[i] = b[i];
}
```

## 手动模拟一下样例（以便更好的理解算法）：

二分时，奇数时默认取左边n / 2 + 1,右边取n / 2了（~~为了方便~~）

**二分时的图：**

![](https://cdn.luogu.com.cn/upload/pic/59663.png)

那么我们开始合并（看着图合并吧，并且**只能同一层合并，并向上传递**,我把后面两个while循环在合并中省去了）

1.第四层5和4合并：i = l = 1；mid = (l + r) / 2 = 1；r = 2；j = mid + 1 = 2；5 > 4；逆序对数量 + mid - i + 1 = 1；b数组：4 5 0 0 0 0； j + 1 > r; 退出；a数组：4 5 2 6 3 1;

![](https://cdn.luogu.com.cn/upload/pic/59694.png)

2.第四层6和3合并：i = l = 4；mid = (l + r) / 2 = 4；r = 5；j = mid + 1 = 5; 6 > 3；逆序对数量 + mid - i + 1 = 2；b数组：4 5 0 3 6 0；j + 1 > r; 退出；a数组：4 5 2 3 6 1；

![](https://cdn.luogu.com.cn/upload/pic/59696.png)

3.第三层4, 5和2合并： i = l = 1；mid = (l + r) / 2 = 2；r = 3；j = mid + 1 = 2；4  > 2; 逆序对数量 + mid - i + 1 = 4；b数组：2 4 5 3 6 0；j + 1 > r；退出；a数组：2 4 5 3 6 1；

![](https://cdn.luogu.com.cn/upload/pic/59712.png)

4.第三层3, 6和1合并：i = l = 4；mid = (l + r) / 2 = 5；r = 6；j = mid + 1 = 6；3 > 1；逆序对数量 + mid - i + 1 = 6；b数组：2 4 5 1 3 6；j + 1 > r；退出；a数组：2 4 5 1 3 6；

![](https://cdn.luogu.com.cn/upload/pic/59713.png)

5.第二层2, 4，5和1, 3，6合并：i = l = 1；mid = (l + r) / 2 = 3；r = 6；j = mid + 1 = 4；2 > 1； 逆序对数量 + mid - i + 1 = 9；b
数组：1 2 4 5 3 6；j + 1；2 < 3；b数组：1 2 4 5 3 6；i + 1；4 > 3；逆序对数量 + mid - i + 1 = 11；b数组：1 2 3 4 5 6；j + 1；4 < 6；b数组：1 2 3 4 5 6；i + 1；5 < 6；b数组：1 2 3 4 5 6；i + 1 > mid；退出； a数组：1 2 3 4 5 6（有序）

![](https://cdn.luogu.com.cn/upload/pic/59720.png)

所以，输出样例就是11

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[5000001], b[5000001];
long long ans;
inline void msort(int l, int r)//归并排序
{
	int mid = (l + r) / 2;//取中间 
	if(l == r)//若l == r了，就代表这个子序列就只剩1个元素了，需要返回 
	{
		return;
	}
	else
	{
		msort(l, mid);//分成l和中间一段，中间 + 1和r一段（二分） 
		msort(mid + 1, r);
	}
	int i = l;//i从l开始，到mid，因为现在排序的是l ~ r的区间且要二分合并 
	int j = mid + 1;//j从mid + 1开始，到r原因同上
	int t = l;//数组b的下标，数组b存的是l ~ r区间排完序的值 
	while(i <= mid && j <= r)//同上i，j的解释 
	{
		if(a[i] > a[j])//如果前面的元素比后面大(l ~ mid中的元素 > mid + 1 ~ r中的元素)(逆序对出现!!!) 
		{ 
			ans += mid - i + 1;//由于l ~ mid和mid + 1 ~ r都是有序序列所以一旦l ~ mid中的元素 > mid + 1 ~ r中的元素而又因为第i个元素 < i + 1 ~ mid那么i + 1 ~ mid的元素都 > 第j个元素。所以+的元素个数就是i ~ mid的元素个数，及mid - i + 1(归并排序里没有这句话，求逆序对里有) 
			b[t++] = a[j];//第j个元素比i ~ mid的元素都小，那么第j个元素是目前最小的了，就放进b数组里 
			++j;//下一个元素(mid + 1 ~ r的元素小，所以加第j个元素) 
		}
		else
		{
			b[t++] = a[i];//i小，存a[i] 
			++i;//同理 
		}
	}
	while(i <= mid)//把剩的元素(因为较大所以在上面没选) 
	{
		b[t++] = a[i];//存进去 
		++i; 
	}
	while(j <= r)//同理 
	{
		b[t++] = a[j];
		++j;
	}
	for(register int i = l; i <= r; ++i)//把有序序列b赋值到a里 
	{
		a[i] = b[i];
	}
	return;
}
int main()
{
	scanf("%d", &n);
	for(register int i = 1; i <= n; ++i)
	{
		scanf("%d", &a[i]);
	}
	msort(1, n);//一开始序列是1 ~ n 
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：Rising_Date (赞：357)

## 前言：
据说数据被chen_zhe_julao加强了，那我也就魔改一番~~（好像再不改要被喷死的样子qaq）~~

这个题是机房里一位小伙伴问我我才做的，蒟蒻的我刚开始居然想要双重循环（类似于冒泡排序的方法）来做，看完数据范围之后就放弃了；

然后想到了逆序对是使用归并排序来做的，所以就自己手码了一个归并排序；；可能有的小伙伴还不知道归并排序的思想，所以看了一晚上归并排序的蒟蒻——我，就来给小伙伴们介绍一下：

## 归并排序

$nlog(n)$的稳定算法（可用于求逆序对的个数）

### 应用方法

二分（所以又叫二路归并+递归；

### 为什么使用递归？

**answer**：要使用归并排序首先就要将数据分解，一直分解到每一个单位，然后就是进行合并了；

### 如何合并？

**answer**：比较$a_i$和$a_j$的大小（其中$a_i$属于左区间，$a_j$属于右区间，其实就是将左右区间合并、并排序），若$a_i<a_j$,则将$a_i$复制到$r_k$中，然后将$i$和$k$都加$1$，否则将$a_j$复制到$r_k$中，将$j$,$k$加$1$，最后再将$r_k$移动到$a_i$中，然后继续合并；

## 求逆序对？

**answer**：

比如将下面两个区间排序

$\qquad$ $a_i$ $\quad$ $mid=4$ $\quad$ $a_j$

$\quad$ $3\,4\,7\,9$ $\qquad$ $\qquad$ $1\,5\,8\,10$

**首先将右区间的 $1$ 取出，放到$r_k$中，此时 $1$ 是比每个$a_i$中的元素都小，也就是说此时i的指针指向$a_1$的位置，此刻得到的逆序对的数量为 $4$ ； $r_k= 1$ ;**

**然后再将$a_i$和$a_j$比较（直到$a_i<a_j$），$a_i<a_j$ 将$a_i$的元素放到$r_k$中； $r_k= 1\,3\,4$;**

**现在$a_j>a_i$, $i$ 指向$a_3$的位置，将 $5$ 放到$r_k$中，得到的逆序对数量为 $2$ ； $r_k= 1\,3\,4\,5$**

**以此类推，直到进行完归并排序，每次合并都会求出逆序对的数目，即$mid-i+1$,最后每次将$ans$加上$mid-i+1$即可得到最后的答案；**

```cpp
#include<cstdio>
#define ll long long 
using namespace std;
const int maxn=5e5+5;
//下面就是 归并排序求逆序对 的过程==
int a[maxn],r[maxn],n;
ll ans=0;//ans作为全局变量，记录逆序对的数量； 
void msort(int s,int t){
	if(s==t) return ;
	int mid=s+t>>1;
	msort(s,mid),msort(mid+1,t);//→→→→→→→递归的体现
	int i=s,j=mid+1,k=s;
	while(i<=mid&&j<=t)
		if(a[i]<=a[j]) r[k++]=a[i++];//先赋值再+1 
		else r[k++]=a[j++],ans+=(ll)mid-i+1;//可以理解为上面的数学归纳吧qaq；
	while(i<=mid) r[k]=a[i],k++,i++;
	while(j<=t) r[k]=a[j],k++,j++;
	for(int i=s;i<=t;i++) a[i]=r[i];//复制回a数组中 
}
inline int read(){//快读
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
	return x*f;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) a[i]=read();
	msort(1,n);//从1到n将a数组排序;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Mudrobøt (赞：169)

#### 请对每一个你所学的知识保持一种尊敬的态度，千万不要说一个东西简单，是知识总会有他独特的价值，这也是为什么我要坚持写博客的一个原因！！！

[题目传送门](https://www.luogu.org/problemnew/show/P1908)

不得不说今天晚上听了一下大佬讲解的逆序对，确实感觉这个东西非常的神奇，因为我发现这个东西不仅仅是一个归并排序那么简单的东西，实际上背后还大有学问，虽然本人并没有学会这道题的基本解决方式，但是跟着大佬混总还是会学到一些东西的，那么今天我就来为大家介绍一下**离散化与动态开点**

在开始之前还是先允许我先介绍一下这道题大致的解题思路，方便引入我们今天的主题。

首先朴素算法是这样的，我们先从第一个数开始一直到最后一个数，然后每次循环它前面的数，然后发现比它大的就记录下来（cnt++），然后我们就会发现会非常的爆炸，因为这样子的话，复杂度O(n^2)，40000^2……我不在多说了。

下面说一说**比较**正常的做法，相信大家都学过桶排序吧！这道题比较正常的做法是这样的，我们边读边处理，不对不对，应该是我们先做好了**排序**后再来进行一个一个处理，首先我们搞一个**线段树**，然后树中放的全部都是桶，是的，你没有看错，就是桶，统计这个数以来出现了多少次，那么你可能就会有所感觉了，这道题不就是，每次进行一次单点修改，区间求和的线段树吗?对的，你能想到这一点，我忠心祝贺你！的确是这样，我们每一次加入一个数，然后对他**后**面区间进行求值，就求到它的逆序对了。对对对，但是你如果能够想到博主想到这个方法的一定是一个SB，那么你就更厉害了。数据范围不是1e9吗！！！我靠，1e9个桶，直接树都开炸！对啊对啊，所以这个时候，**离散化大法要出场了。**

### 离散化（李三花）

小蓝居然可以把离散化读成那个，我觉得它非常的厉害！！！！！

话不多说，开始我们的离散化吧！其实大家完全没有必要去看网上那些东西，特别是百度百科，简直有毒，我们现在还用不到那么牛逼的离散化，所以这里介绍的离散化是非常简单的一种。

所谓离散化，就是说你发现了这个逆序对这道题啊，非常的讨厌，数据这么大，那么我们可不可以适当的把数据范围缩小一点呢？其实是可以的，我们发现，逆序对这道题有一个特点，就是比如说数据2 1还是数据 203903123 1它都是一个逆序对，前面的数都是比1大，但是我们不用管他比1大多少，只要比1大就可以了，但是为我们可以明显感觉到我们要对后面的数据处理一下，否则就要开爆树，在这里我们只需要把它处理成2就可以达到相同的效果。

举例一下：

    2 33423434 437834 25345 373 35  //就可以被换成
    1    6       5      4    3   2   //效果一样

但是你可能会说哎呦，我还排个序，编个号，那个时候我怎么知道原来它是什么样子的啊？

结构体大法好！！！

离散化基本操作如下：

```
#include<bits/stdc++.h>
using namespace std;
struct sd{
	int val,loc;//val是值 loc是当前点的位置 
}x[100005]; 
bool cmp(sd a,sd b)
{
	if(a.val<b.val)
	return true;
}
int discretization[100005];//这单词真够长 
int main()
{
	std::ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>x[i].val;
		x[i].loc=i;
	}
	sort(x+1,x+n+1,cmp);
	int cnt=0; 
	x[0].val=891881292;//important!
	for(int i=1;i<=n;++i)
	{
		if(x[i-1].val==x[i].val)discretization[x[i].loc]=cnt;
		else 
		{
			cnt++;
			discretization[x[i].loc]=cnt;
		}
	} 
	for(int i=1;i<=n;++i)
	{
		cout<<discretization[i]<<" ";
	}
	return 0;
} 
```
打important的地方一定要注意，否则就要出事情！！！你想一想，如果我们呢第一个数为0那么那个cnt标记就不会++了！！！，恐怖！！！???

所以说我们离散化部分就讲完了，相信这道题你也应该可以A了。

标程代码：

```
#include<bits/stdc++.h>
#define ls(k) a[k].ch[0]
#define rs(k) a[k].ch[1]
using namespace std;
struct node { 
	int l,r,cnt,ch[2];
};node a[510000];
int cnt=1;
struct num { 
	int val;
	int loc;
	bool operator < (const num &a) const { 
		return val<a.val;
	} 
};
num lisanhua[51000];
int yingshe[51000];
int n;
void init() { 
	int cnt=0;
	cin>>n;
	for(int i=1;i<=n;++i) { 
		cin>>lisanhua[i].val;
		lisanhua[i].loc=i;
	} 
	sort(lisanhua+1,lisanhua+n+1);
	lisanhua[0].val=19260817;
	for(int i=1;i<=n;++i)
	{
		if(lisanhua[i].val!=lisanhua[i-1].val) yingshe[lisanhua[i].loc]=cnt+1,++cnt;
		else yingshe[lisanhua[i].loc]=cnt;
	}
} 

void update(int k) { 
	a[k].cnt=a[ls(k)].cnt+a[rs(k)].cnt;
} 

void build(int k,int l,int r) { 
	a[k].l=l;a[k].r=r;
	if(l==r) return;
	int mid=l+r;mid/=2;
	ls(k)=cnt+1,++cnt,build(cnt,l,mid);
	rs(k)=cnt+1,++cnt,build(cnt,mid+1,r);
} 

void ins(int k,int val) { 
	if(a[k].l==a[k].r&&a[k].l==val) { 
		a[k].cnt++;
		return;
	} 
	int mid=a[k].l+a[k].r;mid/=2;
	if(val<=mid) ins(ls(k),val);
	else ins(rs(k),val);
	update(k);
} 

int query(int k,int l,int r) { 
	if(a[k].l==l&&a[k].r==r) { 
		return a[k].cnt;
	} 
	int mid=a[k].l+a[k].r;mid/=2;
	if(r<=mid) return query(ls(k),l,r);
	else if(l>mid) return query(rs(k),l,r);
	else return query(ls(k),l,mid)+query(rs(k),mid+1,r);
} 

void prit(int k) { 
	printf("%d %d %d %d %d %d\n",k,ls(k),rs(k),a[k].l,a[k].r,a[k].cnt);
	if(ls(k)!=0) prit(ls(k));
	if(rs(k)!=0) prit(rs(k));
} 

int main() { 
	build(1,0,51000);
	init();
	long long ans=0;
	for(int i=1;i<=n;++i) { 
		ins(1,yingshe[i]);
		ans+=query(1,yingshe[i]+1,n+1);
	} 
	cout<<ans;
	return 0;
} 
```
#### 技巧：这里我们使用了先建树（空树）然后在modify的的写法，希望大家能够理解一下！

好了，就这样了，但是如果哪一天你就是说，哎呀这个离散化写着太让我烦恼了，那么有没有另外一种写法呢？很明显是有的，那么就是我们的**动态开点**了，这样子写有一个好处，就是我们不用写Buildtree啦！是不是听起来很爽呢？我们每次在push的时候就顺便把它的儿子女儿都建了，具体过程不在赘述，这里就贴一段动态开点建树的代码过程，其实大家只要认真的把代码看懂了，那么你就已经掌握到了动态开点建树的精髓了（**用了动态开点就可以不用离散化了哟！！**）！！！！！！

代码如下：

```
void modify(int k,int val)
{
	if(node[k].l==node[k].r&&node[k].l==val)
	{
		node[k].cnt++;
		return;
	}
	int mid=node[k].l+node[k].r;mid/=2;
	if(node[k].son[0]==0)
	{
		cnt++;
		node[k].son[0]=cnt;
		node[cnt].l=node[k].l;node[cnt].r=mid;
	}
	if(node[k].son[1]==0)
	{
		cnt++;
		node[k].son[1]=cnt;
		node[cnt].l=mid+1;node[cnt].r=node[k].r;
	}
	if(val>mid)
	{
		modify(node[k].son[1],val);
	}
	else
	{
		modify(node[k].son[0],val);
	}
	update(k);
}

```
这只是征程的开始，线段树的精髓远远不止这些！！！

标程代码如下：

```
#include<bits/stdc++.h>
using namespace std;
const int N=100000;
struct sd{
	int son[2];
	long long l,r,cnt;
}node[N];
int n;
int cnt=1;
long long ans;
void update(int k)
{
	node[k].cnt=node[node[k].son[0]].cnt+node[node[k].son[1]].cnt;
}
void modify(int k,int val)
{
	if(node[k].l==node[k].r&&node[k].l==val)
	{
		node[k].cnt++;
		return;
	}
	int mid=node[k].l+node[k].r;mid/=2;
	if(node[k].son[0]==0)
	{
		cnt++;
		node[k].son[0]=cnt;
		node[cnt].l=node[k].l;node[cnt].r=mid;
	}
	if(node[k].son[1]==0)
	{
		cnt++;
		node[k].son[1]=cnt;
		node[cnt].l=mid+1;node[cnt].r=node[k].r;
	}
	if(val>mid)
	{
		modify(node[k].son[1],val);
	}
	else
	{
		modify(node[k].son[0],val);
	}
	update(k);
}
long long query(int k,int ql,int qr)
{
	if(k==0) return 0;//very very important！！！
	if(node[k].l==ql&&node[k].r==qr)
	{
		return node[k].cnt;
	}
	else
	{
		int mid=(node[k].l+node[k].r)/2;
		if(qr<=mid) return query(node[k].son[0],ql,qr);
		else if(ql>mid) return query(node[k].son[1],ql,qr);
		else
		{
			return query(node[k].son[0],ql,mid)+query(node[k].son[1],mid+1,qr);
		}
	}
}
int main()
{
	std::ios::sync_with_stdio(false);
	node[1].l=1; node[1].r=1e9+7;
	int n,sth;
	cin>>n;
	ans=0;
	for(int i=1;i<=n;++i)
	{
		cin>>sth;
		modify(1,sth);
		ans+=query(1,sth+1,1e9+7);
	}
	cout<<ans<<endl;
}
```

**关于动态开点的注意事项，我后面在写吧！！！**

于是我履行了诺言，下面就是动态开点最为重要的一个注意事项！！

大家认真的阅读一下代码，可以发现我在代码中加入了一个very very important 的标记，这里一定要写这句话，为什么呢？因为我们动态开点，开到叶节点的时候一定会遇到一种情况，就是叶节点并没有儿子，那么他的儿子编号就是0，所以在下一次递归中就会递归到0号节点，然后0号什么参数都是0，于是程序开始原地转圈，然后就爆炸了！！！！其实这道题写不写都可以，但是这里只是做一个小小的提醒！！！

这只是征程的开始，线段树的精髓远远不止这些！！！
By njc

---

## 作者：Drug__Lover (赞：81)

**离散化一下**

**按价值从大到小排序**

**排完序之后用树状数组维护**

**每次把这个数的位置加入到树状数组中**

**因为是排完序之后，所以之前加入的一定比后加入的大**

**然后在查询当前这个数前面位置的数（是前面位置的数，要当前这个数减1）**

**就是逆序对的个数了**




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 50000
using namespace std;
struct node
{
    int val,num;
}a[maxn];
int n;
int c[maxn];
int add(int x,int k)
{
    for(int i=x;i<=n;i+=i&(-i)) c[i]+=k;
}
int query(int x)
{
    int sum=0;
    for(int i=x;i>0;i-=i&(-i)) sum+=c[i];
    return sum;
}
int cmp(node x,node y)
{
    return x.val>y.val;
}
int ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%d",&a[i].val),a[i].num=i;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        add(a[i].num,1);
        ans+=query(a[i].num-1);
    }
    cout<<ans<<endl;
}

```

---

## 作者：皎月半洒花 (赞：50)

## $PS:$这个树状数组跟楼上不一样

## 好不容易学会了树状数组逆序对……不过因为离散化写炸了调试了半天……

### 事实上，你会发现这篇题解跟之前好多$DALAO$的树状数组求逆序对并不一样……个人感觉这种方法更接近于树状数组的“数位整合”的思想$qwq$

首先对于逆序对，我们可以如此思考这个问题：对于每个数的逆序对，在一个数列中的数量都是一定的。那么我们可以对于数列$a$的每一个$a_i$,可以与$a_1$~$a_{i-1}$匹配出$k_i$个逆序对，那么
## $ans$=$\Sigma_{1}^{n}k_i$。

以上应该不难理解……因为每多读入一个数，就会多和之前的数据新的逆序对……用数学公式表示只是为了向大佬靠拢啊$QWQ$.

那么其实，我们用树状数组记录在第$i$个数之前按有几个数比它小或等于他，即$a_i$ $<=$ $a_j$且$i<=j$那么我们就要删除这些数。即用$i-sum(value[i])$即可。

诶，这个地方类似桶桶桶的思想，用$0$或者$1$记录比$a[i]$小的数在$a[i]$有没有输入即可。

啊，之后因为树状数组的局限性太大了，所以这个地方要离散化一下$qwq$。

离散化……当然就是排个序，然后再重新覆盖回去啦$qwq$。

诶，好像这个题的时间瓶颈从找逆序对变成了$sort$？？？

但反正都是$O(nlogn)$/滑稽。

$emmmm$贴代码

```cpp
struct tree{
	int num,tre;
}t[50001];
int answer[50001],now[50001],change[50001];
int n,ans=0;
inline int lowbit(int i) {
    return i&(-i);
}
inline void insert(int i,int x)
{
    while(i<=n)answer[i]+=x,i+=lowbit(i);
}
inline bool cmp(tree a,tree b){
	return a.tre<b.tre; 
}
inline int sum(int num){
	int res=0;
	for(;num;num-=lowbit(num))
	res+=answer[num];
	return res;
}
int main()
{
	memset(t,0,sizeof(t));
	cin>>n;
	for(int i=1;i<=n;i++){ 
		cin>>t[i].tre;
		t[i].num=i;
	} 
    sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;i++){
		change[t[i].num]=i;
	}
    //上面两个for都用来输入+离散化
	for(int i=1;i<=n;i++){
		insert(change[i],1);
		ans+=i-sum(change[i]);
	}
	//for(int i=1;i<=n;i++)cout<<answer[i]<<endl;
	cout<<ans;
}
```



---

## 作者：不存在之人 (赞：20)

## 分析

**首先是暴力，先枚举 i，再枚举 j（j > i），如果 ai > aj，答案就加一，很显然，这样做是n^{2} 复杂度，肯定会超时**

**这里介绍一下分治+归并排序求逆序对的方法**

![](https://img-blog.csdn.net/20180729230313444?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**若我们要求数列 A 中的逆序对个数，不妨把它分成两半，数列 A 中的逆序对（i，j）必然是下面三种情况之一：**
1. **i，j 都属于数列 B**

2. **i，j 都属于数列 C**

3. **i 属于数列 B，j 属于数列 C**

![](https://img-blog.csdn.net/20180729230724371?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZvcmV2ZXJfZHJlYW1z/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**对于（1），（2）都很好做，直接递归下去就行了，麻烦一点的是（3）**

**解决（3）大体的思路就是枚举 C 中的每一个数，然后在 B 中找大于它的数，然后累加进答案就行了**

**不过直接枚举的话，时间可能会炸掉，我们要想办法优化**

**由于分治的时候是用的递归，在递归回来的时候，我们都做一次归并排序，保证 B，C 都是有序的**

**还是按照上面暴力的那种思路求逆序对，不过由于此时 B，C 是有序的，复杂度就从原来n²降到了n **

**这样的话，分治的复杂度是O（log n），归并排序的复杂度是O（n），总复杂度就是O（n * log n）**
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 500005
using namespace std;
int a[N],b[N],c[N];
long long merge(int l,int r,int mid)
{
	long long ans=0;
	int i,b1=0,c1=0,b2=1,c2=1;
	for(i=l;i<=mid;++i)  b[++b1]=a[i];
	for(i=mid+1;i<=r;++i)  c[++c1]=a[i];
	for(i=l;i<=r;++i)
	{
		if(b1>=b2&&(c1+1==c2||b[b2]<=c[c2]))
		  a[i]=b[b2++];
		else
		{
			a[i]=c[c2++];
			ans+=b1-b2+1;
		}
	}
	return ans;
}
long long solve(int l,int r)
{
	if(l==r)  return 0;
	int mid=(l+r)>>1;
	long long ans=0;
	ans+=solve(l,mid);
	ans+=solve(mid+1,r);
	ans+=merge(l,r,mid);
	return ans;
}
int main()
{
	int n,i;
	long long ans;
	scanf("%d",&n);
	for(i=1;i<=n;++i)
	  	scanf("%d",&a[i]);
	ans=solve(1,n);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：newbiechd (赞：19)

[Blog](https://www.cnblogs.com/cj-chd)  
#### 请管理员重新审核，别的树状数组解法在数据更新后可能存在一些问题，具体见下文。
#### 数据更新后，以前的许多题解都被hack，原因就是加入了存在相同元素的数据！  
基本的原理没有变，其他大佬都已经讲得很明白了  
但是在处理相同元素的时候需要使用$stable\,sort()$  
且$cmp$函数需要修改，因为元素值相同构不成逆序对，所以在判断时要加上等号  
代码：
```
#include<cstdio>
#include<algorithm>
#define R register
#define I inline
#define L long long
using namespace std;
const int S=500010;
char buf[S],*p1,*p2;
I char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,S,stdin),p1==p2)?EOF:*p1++;}
I int read(){
	R int f=0,b=1;	R char c=getc();
	while((c<48||c>57)&&c!=45) c=getc();
	if(c==45) b=0,c=getc();
	while(c>47&&c<58) f=(f<<3)+(f<<1)+(c^48),c=getc();
	return b?f:~f+1;
}
int a[S],b[S],c[S],n;	L s;
I int max(int x,int y){return x>y?x:y;}
I int cmp(const int &x,const int &y){return b[x]>=b[y];}//注意等号
I void mdf(int x){while(x<=n) ++c[x],x+=x&-x;}
I void qry(int x){while(x) s+=1ll*c[x],x^=x&-x;}
int main(){
	R int i;	n=read();
	for(i=1;i<=n;++i) b[i]=read(),a[i]=i;
	stable_sort(a+1,a+1+n,cmp);//注意stable_sort()
	for(i=1;i<=n;++i) mdf(a[i]),qry(a[i]-1);
	printf("%lld",s);
	return 0;
}
```

---

## 作者：LevenKoko (赞：18)

先介绍一下离散化
桶排大家应该知道，就是开一个数组（下标为数值，记录了该数值的出现次数）然后遍历过去如果出现次数不为零，那就输出这些数字，理论时间复杂度可以达到O(N)但是由于内存限制，不能开很大的数组。
#### 然而 如果某个数列中的数字不要求大小确定，只要求这些数字有相对的大小就够了的话，**离散化**就有了用武之地
举个例子：数列
```
3 8 7 5 2000000000000000
```
我们发现有几个数之间差距很大，但是我们用不到数值的大小，只要求相对大小，那怎么办呢？
观察下面的数列：
```
1 4 3 2 5
```
真巧，这个数列和上面的数列各个数字之间的相对大小是一样的并且，让很大的数据缩小了，这样离散化了之后就可以处理一些原本处理不了的问题

离散化比较OK的复杂度是O(NlogN)
STL大法好，代码见下：
```cpp
	for(int i=1;i<=n;++i)
		a[i]=read(),b[i]=a[i];//读入数组a，b数组记录下，等会儿用（read是读入优化）
	sort(b+1,b+n+1);//排序b数组，避免a数组顺序打乱
	int len=unique(b+1,b+n+1)-b-1;//unique:STL自带函数，去重并返回去重后数组的长度+1（所以这里后面要-1）
	//（原理上来讲不是这样，但这样理解方便）
	for(int i=1;i<=n;++i){
		int pos=lower_bound(b+1,b+n+1,a[i])-b;//STL自带函数，返回b(有序数组)中第一个大于等于a[i]的位置
		a[i]=pos;//改变这个值为找到的位置
	} 

```



## 介绍一种神奇的算法：
# 权值线段树

**顾名思义，该线段树中存储的并不是普通线段树记录的线段端点，而是 类似一个桶一样的东西**

最简单的例子：[求逆序对](https://www.luogu.org/problemnew/show/P1908)
该题可以用树状数组做，可以用归并排序思想做，可以用splay做......
不过，既然可以用树状数组用，也可以用线段树做
####【思路】
>先建一棵很大的线段树，然后用权值为下标建树，每一次读到一个数，就找比这个数大的个数，找到了之后加到ans里，接着更新线段树（这个数出现的次数+1）
 PS：这题要加离散化，否则……你懂的
 
```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<algorithm>
#define lson i << 1
#define rson i << 1 | 1
#define M 40005
using namespace std;

inline int read(){
	char chr=getchar();
	int f=1,ans=0;
	while(!isdigit(chr)) {if(chr=='-') f=-1;chr=getchar();}
	while(isdigit(chr))  {ans=ans*10;ans+=chr-'0';chr=getchar();}
	return ans*f;

}
int n;
struct Node{
	int l,r,v;
}t[M<<2];
int a[M],b[M];
void kai(){
	freopen("test1.txt","r",stdin);
}

void push_up(int i){
	t[i].v=t[lson].v+t[rson].v;
}//向上更新

void build(int i,int l,int r){//建树
	t[i].l=l;	t[i].r=r;	t[i].v=0;
	if(l==r){
		return;
	}
	int mid=t[i].l+t[i].r>>1;
	build(i<<1,l,mid);
	build(i<<1|1,mid+1,r);
}

void updata(int i,int x){
	if(t[i].l==t[i].r){
		++t[i].v;//这个数字出现的次数+1
		return;
	}
	int mid=t[i].l+t[i].r>>1;
	if(x<=mid) updata(lson,x);
	else       updata(rson,x);
	push_up(i);
}//更新节点

int query(int i,int l,int r){
	if(l<=t[i].l&&t[i].r<=r) return t[i].v;
	int mid=t[i].l+t[i].r>>1;
	int x=0;
	if(l<=mid) x+=query(lson,l,r);
	if(mid<r)  x+=query(rson,l,r);
	return x;
}//询问

int main(){
//	kai();
	n=read();
	int ans=0;
	build(1,1,M);
	for(int i=1;i<=n;++i)
		a[i]=read(),b[i]=a[i];
	sort(b+1,b+n+1);
	int len=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;++i){
		int pos=lower_bound(b+1,b+n+1,a[i])-b;
		a[i]=pos;
	} //离散化
	for(int i=1;i<=n;++i){
		int x=a[i];
		ans+=query(1,x+1,M);//找比这个数大的数的出现的总次数
		updata(1,x);//这个数出现次数+1
	}
	printf("%d",ans);
	return 0;
}

```

---

## 作者：我很辣ji看头像 (赞：15)

# 当这道题被chen_zhe加强后。没错！就成了树状数组离散化模板题！！！
### PS：虽然已经50多篇了但我认为那些dalao的树状数组已经失去了getSum Update 的精髓。。萌新懂不了啊
``` cpp

#include<cstdio> 
#include<iostream> 
#include<cstring> 
#include<algorithm>
using namespace std; 
#define maxn 1111111 
//typedef long long ll; 
struct node
{
	int val,pos;
} a[maxn]; int b[maxn]; int n;
int cmp(node a,node b)
{
	if(a.val!=b.val)//值不同按数值升序排
	return a.val<b.val;
	return a.pos<b.pos;//值相同则按位置升序排
}
int getsum(int x)//求前缀和
{
	int sum=0; while(x>0)
	{
		sum+=b[x]; x-=x&-x;
	}
	return sum;
}
void update(int x,int v)//单点更新
{
	while(x<=maxn)
	{
		b[x]+=v; x+=x&-x;
	}
}
int main()
{
	//while(scanf("%d",&n)!=EOF)
	//{
		scanf("%d",&n);
		memset(b,0,sizeof(b));//初始化
		for(int i=0;i<n;i++)
		{
	 		scanf("%d",&a[i].val);
			a[i].pos=i+1;//记录每个值的位置
		}
		sort(a,a+n,cmp);//排序
		long long ans=0;
		for(int i=n-1;i>=0;i--)//倒着插点
		{
			ans+=getsum(a[i].pos);
			update(a[i].pos,1);
		}
		//printf("%d\n",ans);
		cout<<ans;
	//}
	return 0;
}






```



---

## 作者：Black_Gzombie (赞：14)

# 权值线段树+离散化
这里介绍一种求逆序对的方法：使用权值线段树和离散化。
~~（我不会归并排序）~~

#### 首先介绍权值线段树。
权值线段树的前置技能：[线段树](https://www.cnblogs.com/TheRoadToTheGold/p/6254255.html)

在看本题的权值线段树之前，如果还不会线段树的同学们请看上面博客2333~~（博客是网上找的）~~

我们接下来介绍权值线段树。相信大家都很熟悉桶排序。**桶排序的思想就是用一个数组来记录待排序的每一个数字的出现次数**，然后按顺序和出现次数将它们输出。而权值线段树做的其实和桶排序很相似。权值线段树维护的序列相当于一个桶排序的所用的序列a[i]，记录每一个数字的出现次数。例如，a[3]记录3的出现次数。这样，我们就可以求出大小在区间[l,r]之间的数一共出现的次数了。它就是a[i]的区间和，而这是可以用线段树来处理的。

#### 然后我们来说一说离散化。
我们先看这道题的数据范围qvq

# 1e9!!!!!
直接记录每个数字的出现次数一定会导致空间爆炸，所以我们就需要用到离散化。离散化就是在不改变数据大小关系的前提下，缩小数据范围，以达到节约时间和空间的目的。如何离散化？请先看一组例子。
```cpp
19284564156 15120 10200 752999
```
这组数据可以被离散化成这个样子：
```cpp
4 2 1 3
```
可以看到，我们并没有改变数字间的大小关系，但我们把数据的范围缩小了很多。这样，我们就可以用权值线段树来处理~~而不会爆空间~~了qvq。
具体的离散化操作是开一个辅助数组，将其sort一遍，然后用unique去重（STL大法好），再在原数组中改变数的大小。处理好之后就可以愉快地上线段树啦！

#### 本题的思路
其实很简单。我们可以直接查询大小在[l,r]之间的数出现的次数。我们先建一颗巨大（bushi）的空线段树，维护区间[1,1e5]。遍历给出的数组，用ans记录逆序对的个数，每次遇到一个数，就统计目前线段树中比这个数大的数字个数，然后更新ans，再把这个数插到线段树里。

上代码：
（记得开long long，不然只有50分qwq）
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define maxn 500050
#define ll long long
using namespace std;

int n;
ll a[maxn],b[maxn];
int sum[maxn<<2];
ll ans=0;

inline ll read()
{
	ll f=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;
		ch=getchar();
	} 
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

void build(int k,int l,int r)
{
	sum[k]=0;
	if(l==r)return;
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
}

void update(int k,int l,int r,int x)
{
	if(l==r)
	{
		sum[k]++;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)update(k<<1,l,mid,x);
	else update(k<<1|1,mid+1,r,x);
	sum[k]=sum[k<<1]+sum[k<<1|1];
}

int query(int k,int l,int r,int x,int y)
{
	if(x<=l&&y>=r)
	{
		return sum[k];
	}
	int mid=(l+r)>>1;
	int res=0;
	if(x<=mid)res+=query(k<<1,l,mid,x,y);
	if(y>mid)res+=query(k<<1|1,mid+1,r,x,y);
	return res;
}

signed int main()
{
	build(1,1,maxn);
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=b[i]=read();
	}
	sort(b+1,b+1+n);
	int len=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)
	{
		int pos=lower_bound(b+1,b+n+1,a[i])-b;
		a[i]=pos;
	}//离散化
	for(int i=1;i<=n;i++)
	{
		int x=a[i];
		ans+=query(1,1,maxn,x+1,maxn);
		update(1,1,maxn,x);
	} 
	printf("%lld",ans);
	
	return 0;
}
```

---

## 作者：lzcjoe (赞：11)

# P1908 逆序对 题解

## 思路

比较求得逆序对对数

### 思路 1 ：逐一尝试

```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);//输入n的值，scanf比cin快。
    int a[n+1];
    long int sum=0;//设置总数为0，sum值有可能很大，因此用long int类型。
    int i,j;//设置两个指针进行逐一尝试。
    for(i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);//读入。
    }
    for(i=1;i<n;i++)
    {
        for(j=i;j<=n;j++)
        {
            if(a[i]>a[j])
            {
                sum++;
            }
        }
    }
    printf("%d",sum);//输出总和。
    return 0;
}
```
这种方法简单易懂，容易执行。

现在来分析这种方法的时间复杂度好空间复杂度。
时间复杂度O(1+n+n*(n+1)/2)，即为O(N^2)。
空间复杂度为n+4个int型变量和1个long int型变量，共占用22+4n个字节。

现在看时空限制：时间1000ms，空间128m。
128m=134217728字节，n的最大值为33554426，满足题目要求。

我们通常认为计算机每秒钟大约运行1000000000次。当n=500000是，运算次数为125000750001次，远大于规定时间。

所以此思路虽然简单，但因为耗时过长所以不能使用。

### 思路 2 ：归并排序 正解

#### 1. 分治思想介绍

分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

在求解一个输入规模为n，而n的取值又很大的问题时，直接求解往往非常困难。这时，可以先分析问题本身所具有的某些特性，然后从这些特性出发，选择某些适当的设计策略来求解。这种方法，就是所谓的分治法。

采用分治法解决的问题一般具有的特征如下：
1. 问题的规模缩小到一定的规模就可以较容易地解决。
2. 问题可以分解为若干个规模较小的模式相同的子问题，即该问题具有最优子结构性质。
3. 合并问题分解出的子问题的解可以得到问题的解。
4. 问题所分解出的各个子问题之间是独立的，即子问题之间不存在公共的子问题。

设计步骤

1. 划分步：把输入的问题划分为k个子问题，并尽量使这k个子问题的规模大致相同。
2. 治理步：当问题的规模大于某个预定的阈值n0时，治理步由k个递归调用组成。
3. 组合步：组合步把各个子问题的解组合起来，它对分治算法的实际性能至关重要，算法的有效性很大地依赖于组合步的实现。

分治法的关键是算法的组合步。究竟应该怎样合并，目前没有统一的模式，因此需要对具体问题进行具体分析，以得出比较好的合并算法。

————摘自“百度百科”

想必通过上面的介绍，大家对分治思想已经有所了解。但如何实现呢？

#### 2. 实现思路：
1. 划分
2. 合并（用递归实现）

```cpp
void partition(int a,int b,...)
{
    //初始化。
    partition(c,d,...);
    partition(e,f,...);//分
    //治（合并操作代码）
    return;
}
```

#### 3. 归并操作定义及原理

归并操作指的是**将两个顺序序列合并成一个顺序序列的方法。**

工作原理：（合并成由小到大的顺序数列）

第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列

第二步：设定两个指针（i和j），最初位置分别为两个已经排序序列的起始位置

第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

重复步骤3直到某一指针超出序列尾

将另一序列剩下的所有元素直接复制到合并序列尾

#### 4. 归并操作实现

```cpp
void merge(int l,int r)
{
    int m=(l+r)/2;//寻找中间值（看作两组数据合并为一个数组）
    int i=l,j=m+1,k=l;
    while(i<=m && j<=r)
    {
    	if(a[i]>a[j])
        {
            b[k]=a[j];
            k++;
            j++;
            }
        else
        {
            b[k]=a[i];
            k++;
            i++;
        }
    }//寻找最小值。
    while(i<=m)
    {
        b[k]=a[i];
        k++;
        i++;
    }
    while(j<=r)
    {
		b[k]=a[j];
		k++;
		j++;
    }//余下的放入数组。
    for(i=l;i<=r;i++)
    {
    	a[i]=b[i];
    }//还原回a数组中。
}
```
#### 5. 归并排序实现

要对一串无序数据进行**分**的操作，经过若干次分后会变成一个个单个的数据，可以看成是**有序**的，再利用归并操作**合并**。

分：递归

合并：归并操作

代码实现如下

```cpp
void mergesort(int l,int r)
{
    if(l==r)
    {
        return;
    }//判断是否分至最小
    int m=(l+r)/2;//中间数
    merge(l,m);
    merge(m+1,r);//递归思想
    int i=l,j=m+1,k=l;//指针
    while(i<=m && j<=r)
    {
        if(a[i]>a[j])
        {
            b[k]=a[j];
            k++;
            j++;
        }
        else
        {
            b[k]=a[i];
            k++;
            i++;
        }
    }
    while(i<=m)
    {
        b[k]=a[i];
        k++;
        i++;
    }
    while(j<=r)
    {
        b[k]=a[j];
        k++;
        j++;
    }
    for(i=l;i<=r;i++)
    {
        a[i]=b[i];
    }//归并操作
}
```
#### 6. 求解逆序对

在归并排序时，若发现有前面的数（a[i]）大于后面的数（a[j]）时,发现逆序对。此时a[l]~a[m]为有序数列，则a[i]~a[m]这一段的数都满足a[k]>a[j]（k=i~m）。此时有（m-i+1）个逆序对。则在遇到这种情况时将结果加上（m-i+1）个即可。

完整代码如下

```cpp
#include<cstdio>
#define MAXN 500005//设置最大的n的值。
int n,a[MAXN],b[MAXN];//定义固定数组和用于排序的临时数组。
long int ans=0;//ans较大。
void merge(int l,int r)
{
    if(l==r)
    {
        return;
    }
    int m=(l+r)/2;
    merge(l,m);
    merge(m+1,r);//递归过程。
    int i=l,j=m+1,k=l;
    while(i<=m && j<=r)
    {
        if(a[i]>a[j])
        {
            b[k]=a[j];
            k++;
            j++;
            ans+=(m-i+1);//逆序对核心语句。
        }
        else
        {
            b[k]=a[i];
            k++;
            i++;
        }
    }
    while(i<=m)
    {
        b[k]=a[i];
        k++;
        i++;
    }
    while(j<=r)
    {
        b[k]=a[j];
        k++;
        j++;
    }
    for(i=l;i<=r;i++)
    {
        a[i]=b[i];
    }
}
int main()
{
    scanf("%d",&n);//读入n。
    int i;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//读入数列。
    }
    merge(1,n);//归并排序。
    printf("%ld",ans);
    return 0;
}
```
此题解毕。

提交信息：
评测状态  Accepted  100

用时: 1672ms / 内存: 4668KB

#### 推荐题目

P1116 车厢重组

P1774 最接近神的人_NOI导刊2010提高（02）

这两题也是用同样的方法，只是描述不同，可以训练。

---

## 作者：wenjing233 (赞：9)

离散化多麻烦啊，还不如动态开点  
代码解释在注释里QAQ
```cpp
//思路：运用权值动态开点线段树从后往前扫每次加上比自己小的且编号靠后的点的个数的贡献（由于从后往前扫可以无视编号）
空间&时间：nlogn
#include <bits/stdc++.h>
using namespace std;
int sum[7000009];//当前区间的点的个数和
int lson[7000009],rson[7000009],bh=1;//左儿子，右儿子，当前点的个数
long long ans;
int num[500009];
int n;
long long query(long long now,long long k,long long l,long long r)
{
	if(now==0) return 0;//如果当前点不存在，即当前区间内没有点存在
	if(l==r) return sum[now];//特判
	if(l>=r) return 0;//特判
	if(k<=(l+r)>>1) return query(lson[now],k,l,(l+r)>>1);//继续向左
	else return sum[lson[now]]+query(rson[now],k,((l+r)>>1)+1,r);//向右的同时将左边的贡献加上去
} 
void add(long long now,long long k,long long l,long long r)
{
	if(l==r) sum[now]++;//特判
	if(l>=r) return;//特判
	if(k<=((l+r)>>1)) 
	{
		if(!lson[now]) lson[now]=++bh;//如果没有左儿子，那就造一个
		add(lson[now],k,l,(l+r)>>1);	
	}
	else
	{
		if(!rson[now]) rson[now]=++bh;//如果没有右儿子也造一个
		add(rson[now],k,((l+r)>>1)+1,r);
	}
	sum[now]=sum[lson[now]]+sum[rson[now]];//更新贡献
}
int main()
{
	scanf("%d",&n);
	for(long long i=1;i<=n;i++)
	{
		scanf("%d",&num[i]);
	}
	for(long long i=n;i>=1;i--)
	{
		ans+=query(1,num[i]-1,1,1000000000);
		add(1,num[i],1,1000000000);
	}
	printf("%lld",ans);
    return 0;
}
```
最后祝大家NOIP2018RP++（如果管理员能够在复赛前审核完的话）

---

## 作者：ShuYuMo (赞：9)

# 归并排序
没有什么思想难度，其他题解已经写过了。
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#define LL long long
using namespace std;
const int _ = 5 * 1e5 + 10;
int A[_];
int tmp[_];
LL ans = 0;
void work(int l, int r)
{
	int m = (l + r) >> 1;
	if(l == r)return;
	work(l, m), work(m + 1, r);
	for(int i = l, j = m + 1,k = l;k <= r;k++)
	{
		if(i <= m && (j > r || A[i] <= A[j]))
			tmp[k] = A[i++], ans += (j - m - 1);
		else
			tmp[k] = A[j++];
	}
	for(register int i = l;i <= r;i++)
		A[i] = tmp[i];
}
int main()
{
	int n;
	scanf("%d", &n);
	for( register int i = 1;i <= n;i++)
		scanf("%d", A + i);
	work(1, n);
	printf("%lld", ans);
	return 0;
}
```

# 树状数组
思考一下逆序对的定义：

$$A_i > A_j (i < j)$$

考虑按顺序遍历序列$A$，假设当前遍历到$A_j$此时所有的$A_i$在前面已经遍历过了，这样就满足了一个条件（$i < j$）。

这样对于一个当前序列的元素$A_j$，和$A_j$构成逆序对的就是之前已经遍历过的所有元素中大于$A_j$的元素个数。这样就满足了第二个条件（$A_i < A_j$）

简单说，其实不一定非要使用树状数组这个数据结构维护，只要支持区间查询或者最值查询

$$A_i > A_j (i < j)$$

其实枚举顺序，就保证了每次计算的时候满足了$i < j$，我们只需要在所有已经处理的$A_i$中进行选择符合第二个条件的$A_i > A_j$即可。

我们把数据排序，并且进行离散化，放入树状数组，我比较习惯排序的时候从大到小排序。


比如:

源数据是：

`21 41 241 415 2141 31 3 2`

离散化后对应为：

`6   4  3   2    1   5 7 8 `（1是最大的）

按顺序离散化后放入树状数组后就是

![exp](https://i.loli.net/2019/10/24/vO7Pw1kXubQhpxs.png)

现在按照原数组中的顺序进行处理：
处理分两步：

 - 标记本数据已经出现
 - 统计这个元素形成的逆序对数量

代码体现为:
```cpp
    change(A[i]在树状数组中的位置, +1);
    ans += query(A[i]在树状数组中的位置);//查询树状数组中[1, A[i]在树状数组中的位置 )的和。
```
`ans += query(A[i]在树状数组中的位置);`

查询树状数组中[1, A[i]在树状数组中的位置 )的和。

因为区间[1, A[i]在树状数组中的位置 )就是保存着那些已经处理过的且小于$A[i]$的数据个数，这些都能形成逆序对，这段区间中为$1$就是已经被处理的了， 所以这段区间的总和就是能和A[i]形成的逆序对数量。

代码就是:
```cpp
/*!
 * Copyright(c) 2019 Shu_Yu_Mo
 * MIT Licensed
 * Luogu: https://www.luogu.org/space/show?uid=44615
 * Github: https://github.com/oldsuold/
 * Gitee: https://gitee.com/Shu_Yu_Mo/
 * These words were created by an amazing tool written by Shu_Yu_Mo.
 */
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstring>
#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<algorithm>
#define inf 0x7fffffff
#define _R register
#define int long long
using namespace std;
const int _ = 5e5 + 1000;
inline int read()
{
    char c = getchar(); int sign = 1; int x = 0;
    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); }
    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }
    return x * sign;
}
struct Node{
	int Val;
	int where;
	bool operator < (const Node & A) const{
		if(Val == A.Val)
			return where > A.where;
		return Val > A.Val;
	}
}A[_];
int n;
int C[_];
int R[_];
int lowbit(int x) { return x & -x; }
int query(int x)
{
	int ans = 0;
	for(;x >= 1;x -= lowbit(x))
		ans += C[x];
	return ans;
}
void change(int x, int val)
{
	for(;x <= n;x += lowbit(x))
		C[x] += val;
}
signed main()
{
	n = read();
	for(_R int i = 1;i <= n;i++) {
		A[i].Val = read();
		A[i].where = i;
	}
	sort(A + 1, A + 1 + n);
	for(_R int i = 1;i <= n;i++) {
		R[A[i].where] = i;
	}
	int ans = 0;
	for(_R int i = 1;i <= n;i++) {
		change(R[i], 1);
		ans += query(R[i] - 1);
	}
	printf("%lld", ans);
	
	return 0;
}
```

---

## 作者：COUPDETAT (赞：8)

### 先看一道例题
[逆序对](https://www.luogu.org/problem/P1908 "逆序对")
这就很显然 虽然一开始只会归并排序求
### 树状数组怎么求逆序对呢？
看一组例子后你一定就明白了
![file](http://101.200.56.58/wp-content/uploads/2019/10/image-1571974157217.png)
##### 后缀和的话 就等于总和减去前缀和
### 关于离散化的问题
我们再来看一组例子
![file](http://101.200.56.58/wp-content/uploads/2019/10/image-1571974334007.png)
非常显然 上面的逆序对数和下面的相等
### code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#pragma GCC optimize(3)
#define int long long 
int c[600100];
int data[600100];
int lowbit(int i) {return i&(-i);}	
int n,ans=0,maxi=0;
struct zz
{
	int i,data;
}d[500010];
void insert(int i,int ci)
{
	for(;i<=n;i+=lowbit(i))
	{
		c[i]+=ci;
	}
}
int query(int i)
{
	int sum=0;
	for(;i>=1;i-=lowbit(i))
	{
		sum+=c[i];
	}
	return sum;
}
bool cmp(zz a,zz b)
{
	if(a.data==b.data)
		return a.i<b.i; 
	return a.data<b.data;
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>d[i].data;
		d[i].i=i;
	}
	sort(d+1,d+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		insert(d[i].i,1);
		ans+=i-query(d[i].i);
	}
	cout<<ans;
} 
```

---

## 作者：Makise_Kurisu (赞：8)

其实此题也可以用splay做.....

顺序读入数据，逆序插入，同时ans加上它现在的排名

那么最后的答案就是ans-n

缺点是平衡树的常数略大

优点是持久化之后可以求动态逆序对

附上代码~~可以当做splay的板子~~

```cpp
#include<cstdio>
#include<cctype>
#define re register int
#define il inline
using namespace std;
void fre(){
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
}

il void read(int &x){
    int f=1;x=0;char c=getchar();
    while(!isdigit(c)){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(isdigit(c)){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    x*=f;
}
const int N=1e6+29;
int son[N][2],f[N],cnt[N],siz[N],key[N];
int sz,root;
struct Balanced_Binary_Tree{
    il void clear(int x){
        son[x][1]=son[x][0]=f[x]=cnt[x]=siz[x]=key[x]=0;
    }
    il void update(int x){
        if(x){
            siz[x]=cnt[x];
            if(son[x][0])siz[x]+=siz[son[x][0]];
            if(son[x][1])siz[x]+=siz[son[x][1]]; 
        }
    }
    il bool get(int x){
        return son[f[x]][1]==x; 
    }
    il void rotate(int x){
        int old=f[x],oldf=f[old],which=get(x);
        son[old][which]=son[x][which^1];f[son[old][which]]=old;
        son[x][which^1]=old;f[old]=x;
        f[x]=oldf;
        if(oldf){
            son[oldf][son[oldf][1]==old]=x;
        }
        update(old);update(x);
    }
    il void splay(int x,int tar){
        for(re fa;(fa=f[x])!=tar;rotate(x)){
            if(f[fa]!=tar)
                rotate((get(x)==get(fa))?fa:x);
        }
        if(!tar)root=x;
        update(x);
    }
    il void insert(int x){
        if(root==0){
            sz++;son[sz][0]=son[sz][1]=f[sz]=0;cnt[sz]=siz[sz]=1;root=sz;key[sz]=x;return;
        }
        int now=root,fa=0;
        while(1){
            if(key[now]==x){
                cnt[now]++;
                update(now);
                update(fa);
                splay(now,0);
                return;
            }
            fa=now;
            now=son[now][key[now]<x];
            if(now==0){
                sz++;
                son[sz][0]=son[sz][1]=0;
                f[sz]=fa;
                cnt[sz]=siz[sz]=1;
                key[sz]=x;
                son[fa][key[fa]<x]=sz;
                update(fa);
                splay(sz,0);
                return;
            }
        }
    }
    il int find(int x){
        int now=root,res=0;
        while(1){
            if(key[now]>x)
                now=son[now][0];
            else{
                res+=(son[now][0]?siz[son[now][0]]:0);
                if(x==key[now]){
                    splay(now,0);
                    return res+1; 
                }
                res+=cnt[now];
                now=son[now][1];
            }
        }
    } 
    il int find_kth(int x){
        int now=root;
        while(1){
            if(son[now][0]&&siz[son[now][0]]>=x)
                now=son[now][0];
            else{
                int tmp=(son[now][0]?siz[son[now][0]]:0)+cnt[now];
                if(x<=tmp)return key[now];
                x-=tmp;
                now=son[now][1];
            }
        }
    }
    il int pre(){
        int now=son[root][0];
        while(son[now][1])now=son[now][1];
        return now;
    }
    il int nxt(){
        int now=son[root][1];
        while(son[now][0])now=son[now][0];
        return now;
    }
    il void Delete(int x){
        int wherever=find(x);
        if(cnt[root]>1){
            cnt[root]--;
            update(root);
            return;
        }
        if(!son[root][0]&&!son[root][1]){
            clear(root);
            root=0;
            return;
        }
        if(!son[root][0]){
            int oldroot=root;
            root=son[oldroot][1];
            f[root]=0;
            clear(oldroot);
            return;
        }
        if(!son[root][1]){
            int oldroot=root;
            root=son[oldroot][0];
            f[root]=0;
            clear(oldroot);
            return;
        }
        int lbig=pre(),oldroot=root;
        splay(lbig,0);
        son[root][1]=son[oldroot][1];
        f[son[oldroot][1]]=root;
        clear(oldroot);
        update(root);
    }
}T;
int t,cmd,k,ans=0;
int a[400029];
int main(){
    read(t);
    for(re i=1;i<=t;i++)read(a[i]);
    for(re i=t;i>=1;i--){
        T.insert(a[i]);
        ans+=T.find(a[i]);
    }
    printf("%d\n",ans-t);
    return 0;
}


```

---

## 作者：血色心魔 (赞：7)

我写这篇题解，只是为了让大家明白，归并排序求逆序对的原理。  
归并排序不用多说，置顶大佬都讲过了，我来讲一下原理。
举个例子，如图，我们假设左边的数组和右边的数组都是有序的（排完序了），他们是一个更大的数组的前半段和后半段


![](https://cdn.luogu.com.cn/upload/pic/73919.png)

我们将5与6进行比较，6比5大，好，放入r中，而且6比5大，那么也就是说6比5之后的所有元素都要大，所以ans+=mid+1-s
之后重复此操作，答案也就出来啦

什么？没有图了？~~其实有，但是只有聪明人才看得到~~
好吧就是懒得贴了，不过大家肯定已经懂了吧


## code
```cpp
#include<iostream>
using namespace std;
int a[500009],r[500009];
long long ans;
void msort(int s,int t){
	if(s==t)return;
	int mid=(s+t)/2;
	msort(s,mid);
	msort(mid+1,t);
	int i=s,j=mid+1,k=s;
	while(i<=mid&&j<=t){
		if(a[i]<=a[j]){
		   r[k]=a[i];
		   i++;
		   k++;
		}else{
			r[k]=a[j];
			j++;
			k++;
			ans+=mid-i+1;
		}
	}
	while(i<=mid){
		r[k]=a[i];
		k++;
		i++;
	}
	while(j<=t){
		r[k]=a[j];
		k++;
		j++;
	}
	for(int i=s;i<=t;i++){
		a[i]=r[i];
	}
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	msort(1,n);
//	for(int i=1;i<=n;i++){
//		cout<<a[i]<<" ";
//	}
	cout<<ans;
	return 0;
}
```


---

## 作者：会打沙包的猫 (赞：7)

本蒟蒻发现此题80%的题解都因数据加强而失效了！！！

所以说

## 此题大部分题解对新手极度不友好
# 离散化要判重！！！
（树状数组部分就不讲了，其他题解都很清楚，而且不会树状数组的人也不会来刷这道题） 再次重点强调：此题离散化要判重
~~~cpp
#include<bits/stdc++.h>
#include<algorithm>
#define  ll long long
using namespace std;
struct xx
{
    ll w,nun;
};
ll n,tree[600005],sum=0,c[600005];
xx a[600005];
inline ll cmp(xx aa,xx bb)
{
    return aa.w>bb.w;//初步离散化（未判重）
}
inline ll lowbit(ll x)
{
    return x&-x;
}
inline void add(ll x,ll y)
{
    while(x<=n)
    {
        tree[x]+=y;
        x+=lowbit(x);
    }
}
inline ll findd(ll x)
{
    ll ans=0;
    while(x>0)
    {
        ans+=tree[x];
        x-=lowbit(x);
    }
    return ans;
}
int main()
{
    scanf("%lld",&n);
    for(register ll i=1;i<=n;i++)
      {
          scanf("%lld",&a[i].w);
          a[i].nun=i;
      }
    sort(a+1,a+n+1,cmp);
    for(register ll i=1;i<=n;i++)
    {
        if(a[i].w!=a[i-1].w||i==1) 
          c[a[i].nun]=i;
        else c[a[i].nun]=c[a[i-1].nun];

        //此处就是判重操作！！！
        //把重复的数字标记置成相同！！！
        //非常重要！不加就只有35分！！
    }
    for(register ll i=1;i<=n;i++)
    {
        sum+=findd(c[i]-1);
        add(c[i],1);
    }
    printf("%lld\n",sum);
    return 0;
}
~~~

---

## 作者：asd_a (赞：7)

楼下大佬都用的是树状数组和归并，我就讲一讲线段树吧！  
这道题，楼下大佬们都讲了其实就是求逆序对。而逆序对就是求每一个数前面有多少个比它大，则考虑权值线段树。  
什么是权值线段树？ 就是以数的大小作区间的线段树。  
然而，此题数据范围太大，所以需要一个小小的预处理操作：  
例：2 8 0 3 2，我们可以排个序（要保留原版）：0 2 2 3 8  
去重：0 2 3 8，编号为：1，2，3，4。再对应回去：2 4 1 3 2  
(要开个结构体，记录原位置）  
一系列~~骚~~操作得： 1<=A[i]<=n  
好了，现在可以构造了。（值都为0）  

---
查询逆序对，先从前向后依次查询，记录总和，查询后加入线段树并回溯

献上丑陋的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
inline int rd()
{
	int x=0,flag=1;
	char ch=getchar();
	while((ch<'0' || ch>'9') && ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*flag;
}
inline LL rdl()
{
	LL x=0,flag=1;
	char ch=getchar();
	while((ch<'0' || ch>'9') && ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*flag;
}//读入优化
const int N=5e5+50;
const int TR=N<<2;
struct tree{
	int l,r,k;
}t[TR];
inline int ls(int x)//左儿子
{
	return x<<1;
}
inline int rs(int x)//右儿子
{
	return x<<1|1;
}
struct no{
	int x,i;
}cop[N];
bool comp(no x,no y)
{
	return x.x<y.x;
}
inline void build(int now,int l,int r)//建树
{
	t[now].l=l;
	t[now].r=r;
	t[now].k=0;
	if(l==r)
		return ;
	int mid=(l+r)>>1;
	build(ls(now),l,mid);
	build(rs(now),mid+1,r);
	return ;
}
inline void up(int now)//回溯
{
	t[now].k=t[rs(now)].k+t[ls(now)].k;
}
inline LL src(int now,int x)//搜索
{
	int l=t[now].l,r=t[now].r;
	LL sum=0;
	int mid=(l+r)>>1;
	if(l==r)
		return (LL)t[now].k;
	if(x<=mid) sum+=(LL)t[rs(now)].k+src(ls(now),x);//若在左儿子中，右儿子一定比它大
	else sum+=src(rs(now),x);//搜索右儿子
	return sum;
}
inline void upate(int now,int x)//加入
{
	int l=t[now].l,r=t[now].r;
	int mid=(l+r)>>1;
	if(l==r)
	{
		t[now].k++;//统计个数
		return ;
	}
	if(x<=mid) upate(ls(now),x);
	else upate(rs(now),x);
	up(now);
}
int n;
LL a[N],k[N],tot=0,ans=0;//开long long防爆
int main()
{
	n=rd();
	for(int i=1;i<=n;i++) a[i]=rdl(),cop[i].x=a[i],cop[i].i=i;
	sort(cop+1,cop+n+1,comp);
	for(int i=1;i<=n;i++)
	{
		if(cop[i].x!=cop[i-1].x || i==1)
			k[++tot]=cop[i].x;
		a[cop[i].i]=tot;
	}//预处理
	build(1,1,n);
	for(int i=1;i<=n;i++)
	{
		ans+=src(1,a[i]+1);//大于a的个数=大于等于a+1的个数
		upate(1,a[i]);//更新
	}
	cout<<ans<<endl;
	return 0;
}
```
[广告（advertisement）](https://www.luogu.org/blog/STC-hjh/)

---

## 作者：lei_yu (赞：6)

###### ~~这个题好像已经有很多题解了~~
###### 这篇题解主要给正在学的分治的同胞们讲一下归并排序
疯狂解释
------------
总体思想：该算法采用分治法，将已有序的子序列合并，得到完全有序的序列。即先使每个子序列有序，再使子序列段间有序。（递归过程）
###### ~~什么鬼？？完全听不懂？？~~
这里详细讲解一下，我们来看一下样例是如何归并排序的:

样例： 5 4 2 6 3 1，用一个a数组表示a[1,2,3,4,5,6]；

首先：递归搜索1~6，然后进行二分（分治），将区间1~6递归分解成1~3和4~6，mid=（1+6）/2=3；(mid向下取整)  

继续：递归搜索1~3，分解为1~2和3~3，然后将1~3分解为1~1，2~2，因为l=r结束函数；  

回到1~2：mid=(1+2)/2=1，定义数组rr表示排序后的数，进行逆序对的比较。

过程：定义i=l,j=mid+1,k=l(i,j用于存储正在比较的指针，k用于存储排序后的数的指针)

###### ~~解释看不懂？继续往下看~~
此时i=1,j=2,k=1;

进行循环，只要i小于等于mid并且j小于等于r就进行逆序对的比较；

比较a[i]和a[j]，也就是5和4，由于5大于4，满足逆序对的要求，那么令rr[k]=a[j]，即rr[1]=a[2]=4，之后，j和k自加1，逆序对的数量加1；由于j此时已经大于r，结束循环。

但是此时i依然是小于等于r的，那么我们就需要对a[i]继续赋值，即令rr[k]=a[i]并让k和i自加直到i大于mid，具体的就是令rr[2]=a[1]=5；

最后，将a的值全部换为rr，结束函数;

不难发现在进行了一波变换之后，这个子区间已经变为了有序的，此时我们的a数组为

4 5 2 6 3 1

继续进行：由于3~3中l=r，直接结束

接下来进行1~3的逆序对查找（合并1~2和3~3）,mid=(1+2)/2=2

比较a[i]和a[j],即a[1]和a[3]，满足逆序对的要求，rr[k]=a[j],即rr[1]=a[3],j和k自加；

#### 但是这个时候我们发现，由于l~mid这个区间也就是1~2在之前已经是有序的了，也就是前面的总比后面的小，也就是说如果前面的i已经与j产生了一个逆序对，那么从i开始到mid都可以与现在的j产生逆序对，所以逆序对的个数不应该只加1，而是加上mid-i+1。

#### 那么会产生重复吗？并不会。因为每一次我们在判断是逆序对后会将j自加，后面的i并没有机会和前面的j进行比较了

所以继续，现在逆序对已经有3个了，由于j已经大于r，结束循环。

同上，我们令现在的rr[k]=a[i];即rr[2]=a[1]=4；继续同上，我们将a全部换为rr，现在的a数组为:

2 4 5 6 3 1

###### （~~我们的电脑原来做了这么多事情~~）

接下来，我们继续分4~6，分为4~5和6~6，同上，逆序对的个数会变为6，a数组会变为：

2 4 5 1 3 6

最后，我们会合并1~3和4~6，也就是进行1~6的逆序对查找（i=1,j=4,mid=3）

由于a[i]大于a[j]，即a[1]大于a[4]，则令rr[k]=a[j],k和j再自加，由于产生了3-1+1个逆序对，逆序对的个数加3，现在有了9个逆序对;

继续比较，由于a[i]现在小于a[j]，即a[1]小于a[5]，令rr[k]=a[i],i和k自加，逆序对个数不变；

再继续比较，由于a[i]又一次大于a[j]，也就是a[2]大于a[5],令rr[k]=a[j],k和j自加，逆序对个数增加3-2+1个，也就是2个，现在一共有11个逆序对；

继续比较，a[i]小于a[j]，即a[2]小于a[6]，rr[k]=a[i]；

再比较，a[i]小于a[j]，即a[3]小于a[6]，rr[k]=a[i]；

由于现在i越界，停止循环；

但是j还小于等于r，令rr[k]=a[j]并自加就好了；

在进行了最后一波合并之后，我们的a数组变为了

1 2 3 4 5 6

以及逆序对数量变为了11；

###### 　（~~皆大欢喜了呢~~）

最后我们只需要输出11就好了。

#### 还有一个地方需要解释，为什么每一次比较之后如果a[i]大于a[j]，j就需要自加，反之i就需要自加呢。答案其实很简单，由于我们的子区间是有序的，前面的总比后面的的小，也就是说，在i或者j自加之后，又会有形成逆序对的可能。

（完）

感谢大家看到现在，接下来是代码：）
------------
```cpp
#include<iostream>
using namespace std;
int a[500005],rr[500005],n;//看懂前面，代码不需要解释
long long ans=0; 
void gb(int l,int r)
{
    if(l==r)return ;
    int mid=(l+r)/2;
    gb(l,mid);
	gb(mid+1,r);
    int i=l,j=mid+1,k=l;
    while(i<=mid&&j<=r)
    {
    	if(a[i]<=a[j])rr[k++]=a[i++];
		else 
		{
			rr[k++]=a[j++];
			ans+=(long long)mid-i+1;
		}
	}
    while(i<=mid)rr[k++]=a[i++];
    while(j<=r)rr[k++]=a[j++];
    for(int i=l;i<=r;i++)a[i]=rr[i];
}
int main()
{
	cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    gb(1,n);
    cout<<ans;
    return 0;
}
```


------------
（本题解共125行）

---

## 作者：Drifterming (赞：6)

```
/*
	貌似是题解里唯一的一篇线段树题解。
	本来是要做动态逆序对的，但是我不会cdq分治，树状数组和分块不熟悉，所以想写线段树套线段树。
	然后就先来用线段树做一下不动态的。
	5倍空间消耗，要sort两边，比较慢，跑了近300ms 
	
	要离散化 
	指针+动态开点
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=4e4+5;

int n,a,ans;
struct Num
{
	int num,id;
}num[N],aha[N];
struct Node
{
	Node *lson,*rson;
	int sum;
}node[N<<2];

typedef Node* Tree;
Tree now_node,root,null;

bool cmp1(Num a,Num b)
{
	return a.num<b.num;
}

bool cmp2(Num a,Num b)
{
	return a.id<b.id;
}

void init()
{
	node->lson=node->rson=node;
	now_node=null=root=node;
}

int read()
{
	char c=getchar();int num=0,f=1;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		num=num*10+c-'0';
	return num;
}

Tree newNode()
{
	++now_node;
	now_node->lson=now_node->rson=null;
	return now_node;
}

int query(Tree &root,int l,int r,int L,int R)
{
	if(root==null)
		return 0;
	if(L<=l&&r<=R)
		return root->sum;
	int mid=l+r>>1;
	int ret=0;
	if(L<=mid)
		ret+=query(root->lson,l,mid,L,R);
	if(mid<R)
		ret+=query(root->rson,mid+1,r,L,R);
	return ret;
}

void modify(Tree &root,int l,int r,int pos)
{
	if(root==null)
		root=newNode();
	if(l==r)
	{
		root->sum=1;
		return;
	}
	int mid=l+r>>1;
	if(pos<=mid)
		modify(root->lson,l,mid,pos);
	else
		modify(root->rson,mid+1,r,pos);
	root->sum=root->lson->sum+root->rson->sum;
}

int main()
{
	//freopen("testdata.in","r",stdin);
	init();
	n=read();
	for(int i=1;i<=n;++i)
	{
		num[i].num=read();
		num[i].id=i;
		aha[i].id=i;
	}
	sort(num+1,num+n+1,cmp1);
	for(int i=1;i<=n;++i)	//离散化，按大小编新的编号 
		aha[num[i].id].num=i;
	sort(aha+1,aha+n+1,cmp2);	//按输入顺序排序，还原原序列 
	for(int i=1;i<=n;++i)
	{
		ans+=query(root,1,n,aha[i].num,n);	//查找在它之前的比它大的数 
		modify(root,1,n,aha[i].num);	//标记一下这个数已经出现 
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：贞白周逸民 (赞：5)

当时以前用的是归并排序做的，今天学了线段树，于是就有了接下来的故事。。。

详解见代码：

**归并排序**：

```c
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int a[500005], b[500005], n;
long long ans;

void msort(int l, int r)
{
	int mid = (l + r) >> 1;
	if (l >= r)	return;
	msort(l, mid); msort(mid + 1, r);
	
	int i = l, j = mid + 1, k = 0;
	
	while(i <= mid && j <= r)
		if (a[i] > a[j]){
			
			ans += mid - i + 1;
			
			b[k++] = a[j++];
			
		}else	b[k++] = a[i++];
		
	while (i <= mid)	b[k++] = a[i++];
	while (j <= r)	b[k++] = a[j++];
	for (i = 0; i < k; i++)	a[l + i] = b[i];
}

int main()
{
	cin >> n;
	for (int i = 1; i<=n; i++)	scanf("%d", &a[i]);
	msort(1, n);
	cout << ans;
	return 0;
}
```

前面的都是模板，关键还是要会离散化。

离散化：目的是为了减少空间复杂度。

~~令人窒息的离散化~~

**线段树**：

```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<set>
#include<cstring>
using namespace std;
//head
//时间复杂度：O(nlogn)
//宏定义--->写起来更方便
#define lsn l,mid,rt<<1
#define rsn mid+1,r,rt<<1|1
const int N = 500000;
int a[N+10], v[N+10], tree[(N<<2)+200];             //线段树的数组大小开4倍左右
int n, m;
inline int readInt() {
    static int n, ch;
    n = 0, ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) n = n * 10 + ch - '0', ch = getchar();
    return n;
}
//查询操作
int query(int l, int r, int rt, int L, int R){
    if(l >= L && r <= R) return tree[rt];
    if(r < L || l > R) return 0;
    if(l ==  r) return tree[rt];
    int mid = (l + r) >> 1;
    int ans = 0;
    if(L <= mid) ans += query(lsn, L, R);
    if(R > mid) ans += query(rsn, L, R);
    return ans;
}
//修改操作
void add(int l, int r, int rt, int pos){
    if(l == r){
        tree[rt]++;
        return;
    }
    int mid = (l + r) >> 1;
    if(mid >= pos) add(lsn, pos);
    else add(rsn, pos);
    tree[rt] = tree[rt<<1] + tree[rt<<1|1];         //将标记往上打
    return;
}
int main(){
    n = readInt();
    long long ans = 0;
    for(int i = 1; i <= n; ++i){
        scanf("%d", a+i);           //因为a[i]的范围是1e9的，所以需要进行离散化操作
        v[i] = a[i];
    }
    sort(v+1, v+1+n);                //排序
    m = unique(v+1, v+1+n) - v - 1;  //去重，unique的返回值是去重后的尾地址（最后一个元素的后一个元素）
    for(int i = 1; i <= n; ++i){
        int k = lower_bound(v+1, v+1+m, a[i]) - v;  //lower_bound（）是内置的二分查找函数，返回值是第一个大于等于a[i]的数的地址
        int cnt = query(1, N, 1, 1, k); //查询在插入排名第k个数之前，排名第1到第k的数总共有多少个
        ans += (i - 1 - cnt);           //计算出前面已经插入线段树的数中有多少个排名在第k之后的
        add(1, N, 1, k);                //向线段树中插入第k个数
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：chaichunyang (赞：5)

## 【树状数组】逆序对
#### [题目](https://www.luogu.com.cn/problem/P1908)

### **题目解析**
 逆序对可以用归并排序和树状数组：
 
归并排序就不用讲了，我们来讲讲**树状数组**
### **算法简介**：
#### **树状数组**：
 树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为$\log{n}$的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在$\log{n}$的复杂度下进行范围修改。

这种数据结构（算法）并没有C++和Java的库支持，需要自己手动实现。在Competitive Programming的竞赛中被广泛的使用。树状数组和线段树很像。
#### 如下图，就是一种树状数组：
 ![](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=a565892f4790f60310bd9415587bd87e/0dd7912397dda14482d369acbfb7d0a20df486d1.jpg)
##### 假设数组$a_1 a_2 \ldots a_n$，那么查询$a_1$ $+$ $ \ldots$ $+$ $a_n$的时间是$\log_2{n}$级别的，而且是一个在线的数据结构，支持随时修改某个元素的值，复杂度也为$\log_2{n}$级别。
##### 来观察这个图：
 令这棵树的结点编号为$C_1$,$C_2$ $\ldots$ $C_n$。令每个结点的值为这棵树的值的总和，那么容易发现：
##### $C_1 = A_1$
##### $C_2 = A_1 + A_2$
##### $C_3 = A_3$
##### $C_4 = A_1 + A_2 + A_3 +A_4$
##### $\ldots$
##### $C_{16} = A_1 + A_2 + A_3 + A_4 + A_5 + A_6 + A_7 + A_8 + A_9 + A_{10} + A_{11} + A_{12} + A_{13} + A_{14} + A_{15} + A_{16}$
##### 这里有一个有趣的性质：
#### 设节点编号为$x$，那么这个节点管辖的区间为$2^k$（其中$k$为$x$二进制末尾0的个数）个元素。因为这个区间最后一个元素必然为$A_x$，
 所以很明显：$C_n$ $=$ $A_($n$ $–$ $2^k$ $+$ $1$)$  $+$ $\ldots$ $+$ $A_n$
##### 算这个$2^k$有一个快捷的办法，定义一个函数如下即可：
```cpp
int lowbit(int x){
return x&-x;
}
```
### **代码实现**:
```cpp
#include<cstdio>
#include<algorithm> 
using namespace std;
int n,m,a[500039],x,y,z,s[500039],fs[500039];
long long ans,f[500039],tot;
inline void read(int &x) {
	x=0;char s=getchar();int fs=1;
	while(s<'0'||s>'9') {
    if(s=='-')fs=-1;
    s=getchar();
    }
	while(s>='0'&&s<='9') x=(x<<3)+(x<<1)+(s^48),s=getchar();
	x*=fs;
}
inline void get(int x,int z){
	while(x<=n)f[x]+=z,x+=x&-x;
    }
inline long long find(int x){
	tot=0;
	while(x)tot+=f[x],x-=x&-x;
	return tot;
}
inline bool cmp(int x,int y){return a[x]<a[y];}
int main(){system("title \"【树状数组】逆序对\"");
	register int i;
	read(n);
	for(i=1;i<=n;i++)read(a[i]),s[i]=i;
	sort(s+1,s+n+1,cmp);
	fs[s[1]]=1;
	for(i=2;i<=n;i++){
		if(a[s[i]]==a[s[i-1]]) fs[s[i]]=fs[s[i-1]];
		else fs[s[i]]=i;
	}
	for(i=1;i<=n;i++){
		ans+=find(n)-find(fs[i]);
		get(fs[i],1);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：SiTer (赞：5)

```cpp

//2015.10.7 10:58
/*关于离散化 
解释为什么要有离散的这么一个过程？
刚开始以为999.999.999这么一个数字，对于int存储类型来说是足够了。
还有只有500000个数字，何必要离散化呢？
刚开始一直想不通，后来明白了，后面在运用树状数组操作的时候，
用到的树状数组C[i]是建立在一个有点像位存储的数组的基础之上的，
不是单纯的建立在输入数组之上。
比如输入一个9 1 0 5 4，那么C[i]树状数组的建立是在，
下标 0 1 2 3 4 5 6 7 8 9
数组 1 1 0 0 1 1 0 0 0 1
现在由于999999999这个数字相对于500000这个数字来说是很大的，
所以如果用数组位存储的话，那么需要999999999的空间来存储输入的数据。
这样是很浪费空间的，题目也是不允许的，所以这里想通过离散化操作，
使得离散化的结果可以更加的密集。
*/ 
/*
洛谷1908 逆序对
本题地址： http://www.luogu.org/problem/show?pid=1908

题目描述
猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai>aj且i<j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。
输入输出格式
输入格式：
第一行，一个数n，表示序列中有n个数。
第二行n个数，表示给定的序列。

输出格式：
给定序列中逆序对的数目。

输入输出样例
输入样例#1：
6
5 4 2 6 3 1
输出样例#1：
11
说明
对于50%的数据，n≤2500
对于100%的数据，n≤40000
*/

/*
 离散之后，怎么使用离散后的结果数组来进行树状数组操作，计算出逆序数？
如果数据不是很大， 可以一个个插入到树状数组中，
每插入一个数， 统计比他小的数的个数，
对应的逆序为 i- getsum( hash[i] ),
其中 i 为当前已经插入的数的个数，
getsum( hash[i] ）为比 hash[i] 小的数的个数,
i- sum( hash[i] ) 即比 hash[i] 大的个数， 即逆序的个数
*/ 

#include <algorithm>
#include <cstdio>
#include <iostream>
using namespace std;
int hash[50010],tree[50010],N;
struct Node{
    int value;
    int site;
}num[50010];
bool cmp(Node a ,Node b)
{
    return a.value<b.value;
}

int lowbit(int x)
{
    return x&(-x);
}

void updata(int site,int value)
{
    int i;
    for(int i=site;i<=N;i+=lowbit(i))
        tree[i]+=value;
    return ;
}

int getsum(int x)
{
    int temp=0;
    for(int i=x;i>=1;i-=lowbit(i))
        temp+=tree[i];
    return temp;    
}

int main()
{
    scanf("%d",&N);
    for(int i=1;i<=N;i++)
    {
        scanf("%d",&num[i].value);
        num[i].site=i;
    }
    sort(num+1,num+N+1,cmp);
    for(int i=1;i<=N;i++)
        hash[num[i].site]=i;
    //离散化结束
    long long ans=0;
    for(int i=1;i<=N;i++)
    {
        updata(hash[i],1);
        ans+=i-getsum(hash[i]);
    }
    printf("%d",ans);
    
     return 0;
      
}



```

---

## 作者：圣堂之地 (赞：4)

本人才开始学c++，有错误还请各位大佬指出来，谢谢！

我写这篇题解主要是对于一些大佬的小错误的一些完善，或许也可为你提供一个小小的创新。

此题的思路呢，还比较好想，比如如下：

```
  数：5 1 3 2 4
序号：1 2 3 4 5 
```

逆序对的条件是什么呢？是
```
ai>aj&&i<j
```

那么可以建立一个 a[] ，来存储当前第 i 个数的前面有那些数出现了，那么 i 前面被插入的数**已经满足序号小于i**,故只要再满足 i 前面的数比 i 大即可。

所以我们可以想到树状数组。
```
//对于任意序列，你可已如下求和，证明可以自行搜索

int c[100000];//数组 

inline void updata(int i,int v){ while(i<=n) c[i]+=v,i+=i&(-i);}//c[i]的改变值值为1
                                            int getsum(int i){
	int s=0;
	while(i) s+=c[i],i-=i&(-i);
	return s;
}//求和 
```

但是如果是 1 100000 200000 又该如何呢？其实它与 1 2 3 是相同的。这便是所谓的离散化，当然，离散化还包含去重。

我将大小按 大--->小 排序，并判断此点前有多少点的序号小于它，这便是此点的逆序对，于是你便可以写出：

35分

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll MAX=1e6+5;

struct node{
	ll num;//编号 
	ll v;//权值 
}f[MAX];

ll n;//n个数 
ll ans;//逆序对个数 
ll c[MAX];//树状数组 

int getsum(int i){
	int s=0;
	while(i) s+=c[i],i-=i&(-i);
	return s;
}//求和 

inline void updata(int i){ while(i<=n) c[i]++,i+=i&(-i);}//c[i]的改变值值为1

inline bool cmp(node x,node y){ 
	return x.v>y.v;
}

inline ll read(){
	int x=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){ if(c=='-') f=-1; c=getchar();}
	while(c>='0'&&c<='9'){ x=(x<<1)+(x<<3)+(c^48); c=getchar();}
	return x*f;
}

int main(){
	
	n=read();
	for(register ll i=1;i<=n;i++) f[i].v=read(),f[i].num=i;

	sort(f+1,f+n+1,cmp);//排序(按权值大-->小)
	
	for(register ll i=1;i<=n;i++){
		updata(f[i].num);
		ans+=getsum(f[i].num-1);//我的逆序对有哪些 
	}
	
	printf("%lld",ans);
	
	return 0;
}

```

那为何不是满分呢？


这是因为对于：

```
  数：8 8
序号：1 2 
```


而言，后面的 8 会因为前面有一个序号为1的数而产生逆序对，那该如何避免呢？要去重么？

其实不用，对于值相同的数，把序号大的放前面即可，即改动 cmp 函数为
```
inline bool cmp(node x,node y){ 
	if(x.v==y.v) return x.num>y.num;
	return x.v>y.v;
}
```
即可。

AC代码
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll MAX=1e6+5;

struct node{
	ll num;//编号 
	ll v;//权值 
}f[MAX];

ll n;//n个数 
ll ans;//逆序对个数 
ll c[MAX];//树状数组 

int getsum(int i){
	int s=0;
	while(i) s+=c[i],i-=i&(-i);
	return s;
}//求和 

inline void updata(int i){ while(i<=n) c[i]++,i+=i&(-i);}//c[i]的改变值值为1

inline bool cmp(node x,node y){ 
	if(x.v==y.v) return x.num>y.num;
	return x.v>y.v;
}

inline ll read(){
	int x=0,f=1; char c=getchar();
	while(c<'0'||c>'9'){ if(c=='-') f=-1; c=getchar();}
	while(c>='0'&&c<='9'){ x=(x<<1)+(x<<3)+(c^48); c=getchar();}
	return x*f;
}

int main(){
	
	n=read();
	for(register ll i=1;i<=n;i++) f[i].v=read(),f[i].num=i;

	sort(f+1,f+n+1,cmp);//排序(按权值大-->小)
	
	for(register ll i=1;i<=n;i++){
		updata(f[i].num);
		ans+=getsum(f[i].num-1);//我的逆序对有哪些 
	}
	
	printf("%lld",ans);
	
	return 0;
}
```



---

## 作者：gzh01 (赞：4)

这里介绍一种更快的离散化的方法——二分

用到algorithm里的lower_bound，想必大家都挺熟悉的吧？用lower_bound查找a[i]的位置更快。

我们还用到的iostream里的unique去重函数，也可以减少时间。

我们将f[i]排序，那么第一次出现在f中的a[i]就是a[i]在数组里的“第几大”，后面依次插入a[i]，树状数组的sum(a[i])就是小于等于a[i]的数的个数，那么i-sum(a[i])就是比a[i]大的个数了。
```
#include <algorithm>
#include <iostream>
#include <cstdio>

int n,len,a[500001],f[500001],s[500001]; //a是原数组，也是离散化后的数组，f是排好序的数组，s是树状数组
long long ans;

int lowbit(int x){       //返回(x)2中右到左第一个1表示的数
    return x&-x;
}

void add(int x,int k){   //修改树状数组
    while(x<=n){
        s[x]+=k;
        x+=lowbit(x);
    }
}

int sum(int x){         //返回前x个数的和
    int tot=0;
    while(x>0){
        tot+=s[x];
        x-=lowbit(x);
    }
    return tot;
}

int main(void){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
    	scanf("%d",&a[i]);
    	f[i]=a[i];
    }
    std::sort(f+1,f+n+1);   //排序
    len=std::unique(f+1,f+n+1)-f;   //去重
    for(int i=1;i<=n;++i){
        int pos=std::lower_bound(f+1,f+len+1,a[i])-f;  //a[i]在f中的位置
        a[i]=pos;
    }
    for(int i=1;i<=n;++i){
        add(a[i],1);         //将a[i]的个数+1
        ans+=i-sum(a[i]);    //ans加上比a[i]大的数的个数
    }
    printf("%lld",ans);
}
```

---

## 作者：TheUltimateLaw (赞：4)



这是一道经典的归并，它已经经典到让刘汝佳都把它选做归并的例题了。。。。。。。

好吧，下面是蒟蒻的一些思考过程。。。。。

这道题描述的意思是：如果某个数，它的值比在同列之中排序更为靠前的数大，那么就称为一个逆序对。

很多人一上来就会想到递归，在下也是，

但经历了无数次被蓝光闪爆屏幕之后，我决定分析一下原因。

递归的问题在于，要进行多次排序，那时间复杂度，蹭蹭往上涨，扶摇直上九万里，即使加了快读，只用快排也不行。

所以，在对刘汝佳深入了解一番后，get新技能，归并！

这种排序的基本思想是，将所有的数据尽可能平均的分为两队，各自排序，然后再创建一个新队，之后每次对两个队列队首的元素比较

谁小就将谁存进新队，因为这样的话，不管是哪一个数据，都始终是紧接着上一个的最小值，这样就能对大量的数据进行快速排序了，解决了这一点，自然也就解决了这个题的大部分问题。

附代码如下：



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int da,n,a[40001],jishuqi[40001];
inline int read (){
    int misaka=0,mikoto=1;
    char c=getchar();
    while(c<'0' || c>'9'){
        if(c=='-')
            mikoto=-1;
        c=getchar();
    }
    while(c>='0' && c<='9'){
        misaka=misaka*10+(int)(c-'0');
        c=getchar();
    }
    return misaka*mikoto;
}
void guipai(int l,int r){
    if(l==r)
    return;
    int mid=((l+r)/2);
    int len=(r-l+1);
    guipai(l,mid);
    guipai(mid+1,r);
    int len1=mid-l+1;
    int len2=len-len1;
    int t1[len1+1];
    int t2[len2+1];
    for(int i=1;i<=len1;i++)
        t1[i]=a[l+i-1];
    for(int i=1;i<=len2;i++)
        t2[i]=a[mid+i];
    int i=1,j=1,k=0;
    while((i<=len1)&&(j<=len2)){
        if(t1[i]<=t2[j]){
            a[l+k]=t1[i];
            k++;
            i++;
        }
        else{
            a[l+k]=t2[j];
            k++;
            j++;
            da=da+(mid-(l+i-1)+1);
        }
    }
    while(i<=len1){
        a[l+k]=t1[i];
        i++;
        k++;
    }
    while(j<=len2){
        a[l+k]=t2[j];
        j++;
        k++;
    }
}
int main(){
    n=read();
    for(int i=1;i<=n;i++)
        a[i]=read();
       guipai(1,n);
    //for(int i=1;i<=n;i++)cout<<a[i]<<" ";
    //cout<<endl;
    cout<<da<<endl;
    return 0;
}
```

---

## 作者：frank3215 (赞：3)

# 作死大法好……（多种做法）

本蒟蒻发现：由于数据被更新过，很多题解的代码要么WA要么TLE要么MLE，在这里将各个做法做个整合。

## 显然的做法——动态开点线段树(50分,MLE/RE)
相信看过其他题解的同学都知道了有一种做法叫线段树。

我来给大家演示一下：这就是不离散化的下场（虽然离散化了也大概率会TLE……
```
#include <cstdio>
using namespace std;
const int maxn=500010,inf=1e9+1;
int n,a[maxn],tot=0,i,b[maxn],c[maxn],tmp[2][maxn];
long long ans=0;
struct node{
	int v;
	node *ls,*rs;
	node *init(){
		v=0;
		ls=rs=NULL;
		return this;
	}
};
struct DynamicSegmentTree{
	node t[maxn*10];
	int tot,ll,rr;
	void init(int L,int R){
		t[tot=0].init();
		ll=L,rr=R;
	}
	node* modify(int x,int k,node *p,int l,int r){
		if(!p) p=t+(++tot);
		p->v++;
		if(l==r) return p;
		int m=(l+r)>>1;
		if(x<=m) p->ls=modify(x,k,p->ls,l,m);
		else p->rs=modify(x,k,p->rs,m+1,r);
		return p;
	}
	int query(int L,int R,node *p,int l,int r){
		if(!p) return 0;
		if(L<=l&&r<=R) return p->v;
		int m=(l+r)>>1,res=0;
		if(L<=m) res+=query(L,R,p->ls,l,m);
		if(R>m) res+=query(L,R,p->rs,m+1,r);
		return res;
	}
}T;
int main(){
	scanf("%d",&n);
	T.init(0,inf);
	for(i=0;i<n;i++)
		scanf("%d",a+i);

	for(i=0;i<n;i++){
		T.modify(a[i],1,T.t,T.ll,T.rr);
		ans+=T.query(a[i]+1,inf,T.t,T.ll,T.rr);
	}

	printf("%lld\n",ans);
}
```

## 第二显然的做法——trie(AC,7936ms)
你可能很疑惑：trie到底是怎么跑进来的？

因为我懒得写离散化了，而且直接用树状数组肯定会MLE/RE，所以写一个用trie实现的树状数组就可以咯。（最后卡着时限过了……
```
#include <cstdio>
const int maxn=2e7,inf=1e9+10;
int n,a;
long long ans=0;
struct trieBIT{
	int t[maxn],s[maxn][2],res,i,u,tot;
	trieBIT(){tot=1;}
	inline int son(int u,bool n,bool w=0){
		return s[u][n]||w?s[u][n]:s[u][n]=++tot;
	}
	int query(int x){
		for(res=0,u=1,i=1<<31;x&&u;x^=x&i,i>>=1)
			res+=t[u=son(u,x&i,1)];
		return res;
	}
	void add(int x,int k=1){
		for(u=1,i=1<<31;x;x^=x&i,i>>=1){
			if(!(x&i)) t[son(u,1)]+=k;
			u=son(u,x&i);
		}
		t[u]+=k;
	}
}t;
int main(){
	scanf("%d",&n);
	while(n--){
		scanf("%d",&a);
		t.add(inf-a);
		ans+=t.query(inf-a-1);
	}
	printf("%lld",ans);
}
```
## 正常的做法——离散化+树状数组(正解,2846ms)
随便放下代码，相信都能看懂……（试过用map离散化，好像TLE了）
```
#include <cstdio>
#include <map>
#include <algorithm>
using namespace std;
const int maxn=500010,inf=1e9+1;
int n,a[maxn],tot=0,i,b[maxn],c[maxn],tmp[2][maxn];
//a[]存数字 b[]存排序后逆序 c[]存离散化后数组
long long ans=0;
struct BIT{
	int t[maxn];
	inline int lb(int x){return x&(-x);}
	inline void add(int x){for(;x<=n;x+=lb(x)) t[x]++;}
	inline int sum(int x){int res=0;for(;x;x-=lb(x)) res+=t[x];return res;}
}t;
int cmp(int x,int y){
	return a[x]>a[y];
}
int main(){
	scanf("%d",&n);
	for(i=0;i<n;i++){
		scanf("%d",a+i);
		b[i]=i;
	}
	sort(b,b+n,cmp);
	for(i=0;i<n;i++){
		if(i&&a[b[i]]==a[b[i-1]]) c[b[i]]=c[b[i-1]];
		else c[b[i]]=++tot;
	}
	for(i=0;i<n;i++){
		t.add(c[i]);
		ans+=t.sum(c[i]-1);
	}
	printf("%lld\n",ans);
}
```

## 常见的做法——归并排序(AC,1375ms)
就是归并的时候注意要写小于等于号（因为可能有相等的数），其他的没有什么了。
```
#include <cstdio>
const int maxn=500010;
int n,i,a[maxn],tmp[2][maxn];
long long ans=0;
void mergesort(int l,int r,int k){
	if(l==r){
		tmp[k][l]=a[l];
		return;
	}
	int m=(l+r)>>1,*t1=tmp[k],*t2=tmp[k^1];
	mergesort(l,m,k^1);
	mergesort(m+1,r,k^1);
	for(int i=l,s=l,t=m+1;i<=r;i++){
		if(t>r||(s<=m&&t2[s]<=t2[t]))
			t1[i]=t2[s++];
		else{
			ans+=m+1-s;
			t1[i]=t2[t++];
		}
	}
}
int main(){
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%d",a+i);
    mergesort(0,n-1,0);
    printf("%lld\n",ans);
}
```

---

## 作者：List (赞：3)

首先这个题如果用双重循环，复杂度为O(n^2),肯定会超时；

现在考虑一下，是否可以将序列分段，利用合并排序思想；

先分段步长为1，然后使序列有序，计算每一组序列的逆序对数目，然后步长2、4、直到步长等于整个序列

每一组序列a[i]a[j]，如果a[i] < a[j]那么不是逆序对，直接将a[j]复制到新数组里，如果a[i]>a[j]那么a[i]这一段后面所有数据都大于a[j],sum直接加mid-i+1即可(因为序列之从步长递增将每一组序列内部已经排好序了)，最后注意将新数组里面数据复制到a数组相应的位置中

典型的二分



```cpp
#include  <iostream>
using namespace std;
#define maxn 40001
int a[maxn],temp[maxn];
int sum=0,n;
int MergePass(int left,int mid,int right)
{
    int k=0,i=left,j=mid+1;///将ij分别固定到a数组中的相应位置
    while(i<=mid && j<=right)
    {
        if(a[i]<a[j])///不是逆序队不需要进行考虑
            temp[k++] = a[i++];
        else
        {
            temp[k++] = a[j++];
            sum += (mid-i+1);///如果a[i]>a[j]那么a[i]后面的元素都大于a[j],a[i]后面的元素有mid-i+1个
        }
    }
    ///剩余部分加进去
    while(i<=mid)
        temp[k++] = a[i++];
    while(j<=right)
        temp[k++] = a[j++];
    for(int i=0;i<k;i++)
        a[left+i] = temp[i];///最后将这段改动的数据仍然放在a数组中
}
void MergeSort(int left,int right)
{
    if(left<right)
    {
        int mid = (left+right)/2;
        ///先分段二分
        MergeSort(left,mid);
        MergeSort(mid+1,right);
        ///分好了进行排序
        MergePass(left,mid,right);
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    MergeSort(1,n);
    cout<<sum<<endl;
    return 0;
}

```

---

## 作者：CoolTeam (赞：3)

刚好能套用归并排序，在比较大小那里动动手脚就好。

如数组4 5 2，p=1,r=3,mid=(1+3)/2=2.

则左子数组为4 5,右子数组为2.

2先放到原数组中，放的时候左子数组剩余长度为2,则逆序对数量+2。

```cpp
#include<stdio.h>
#include<string.h>
#define MAX 2100000000
int i,j,k,ans=0,n,A[40010]={0};
void merge(int p,int mid,int r)//按升序归并排序 
{ //归并
    int ll=mid-p+1;//左数组大小 
    int lr=r-mid;//右数组大小
    int L[20010],R[20010];
    for(i=1;i<=ll;i++) L[i]=A[p+i-1]; L[i]=MAX;//最后一个元素弄成最大值 
    for(i=1;i<=lr;i++) R[i]=A[mid+i]; R[i]=MAX;//以便将最后一个元素排好序。 
    for(i=1,j=1,k=p;k<=r;k++) 
    {
        if(L[i]<=R[j])//无逆序对
            A[k]=L[i++];    
        else //有逆序对
        {
            ans+=ll-i+1;//逆序对数量 
            A[k]=R[j++];    
        } 
    } 
    return ;
}
void merge_sort(int p,int r)
{//排序 
    if(p<r)//元素>1 
    {
        int mid=(p+r)/2;
        merge_sort(p,mid);
        merge_sort(mid+1,r);
        merge(p,mid,r);
    }
    return;
}
int main(void)
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&A[i]);
    merge_sort(1,n);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：weiyi (赞：3)

好像各位大佬都在说各种离散+树状数组的题解啊

~~（我这只不懂离散化的蒟蒻很难堪啊，树状数组懂了但是不会离散化呜呜呜）~~

所以想写一个小小的离散化的一点认识（已经懂了的大佬绕行谢谢）

PS:本人十分菜，各位大佬轻喷，有什么问题麻烦私信，我会第一时间改正的。

PS2:感谢[@学无止境](https://www.luogu.org/space/show?uid=68975)大佬提供的思路

## 1.离散化定义

离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。（by百度网科）

~~对于我这种蒟蒻根本看不懂啊！！！~~

举个栗子：

你有一个10^3个数据，数据大小在10^12之内，如果直接开一个10^12的数组就肯定会超，而开一个10^3的long long数组就不会超。

所以，我们只需要先把数据存在一个**结构体数组**里面，对数据排序后再将结构体数组中的数据**位置**转存到另一个数组上就完全可以避免MLE

##### Q:那样数据不就无效了吗？？？

##### A:是的，离散化会使读入的实际元素无效，这就引出了我们的下一个问题

## 2.离散化适用范围

由于数据离散化不会存储读入的数据，所以需要保证:题目只**需要各元素之间的大小关系而与元素具体大小无关**

而逆序对恰好满足这种关系

比如:22000 111265 1000

然而我们根本不需要知道这些元素的实际大小，只需要知道元素之间大小关系就好

换句话说，上面那组数据等价于 2 3 1

故:逆序对完全可以使用离散化(至于怎么离散，貌似方法很多，这里就介绍一种我看懂了的)

## 3.离散化
```cpp
int b[500010];
struct in{
  int shu;
  int weizhi;
}dian[500010];
bool cmp(in a , in b){
  if(a.shu == b.shu)  return a.weizhi < b.weizhi;
  return a.shu < b.shu;
}
for(int i = 1 ; i <= n ; i ++) {
	  cin >> dian[i].shu;
	  dian[i].weizhi = i;
	}
	sort(dian + 1 , dian + 1 + n , cmp);
	for(int i = 1 ; i <= n ; i ++){
	  b[dian[i].weizhi] = i;
	}
```

咱们一步一步来看，shu变量里面存的就是实际元素大小，weizhi就是元素所在的位置,b里面就是离散后的数据啦~
~~(没错我就是喜欢用拼音)~~

如果两个元素的实际大小相同，那么我们就需要将他们按照位置排序(保证即使离散也不至于离的过散)，否则就从小到大排序。

然后就是像上面那组数据一样，只需要存储排序后的位置就好啦~

至于和树状数组结合之类的，各位大佬已经讲得很清楚啦，我就不再多说啦

## 4.完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 10;
int b[maxn] , n , tree[maxn];
struct in{
	int shu;
	int weizhi;
}dian[maxn];
int lowbit(int x){
	return x & -x;
}
int query(int x){
	int ans = 0;
	for(;x;x -= lowbit(x)){
		ans += tree[x];
	}
	return ans;
}
void add(int x){
	int ans = 0;
	for(;x <= n; x += lowbit(x)){
		tree[x] += 1;
	}
}
int read(){
	char x = getchar();
	int ans = 0;
	for(;x < '0' || x >'9' ; x = getchar());
	for(;x >= '0' && x <= '9' ; x = getchar()){
		ans *= 10;
		ans += (x - '0');
	}
	return ans;
}
bool cmp(in a , in b){
	if(a.shu == b.shu)  return a.weizhi < b.weizhi;
	return a.shu < b.shu;
}
int main(){
	n = read();
	for(int i = 1 ; i <= n ; i ++) {
		dian[i].shu = read();
		dian[i].weizhi = i;
	}
	sort(dian + 1 , dian + 1 + n , cmp);
	for(int i = 1 ; i <= n ; i ++){
		b[dian[i].weizhi] = i;
	}
	long long ans = 0;
	for(int i = 1 ; i <= n ; i ++){
		add(b[i]);
		ans += i - query(b[i]);
	}
	cout << ans;
	return 0;
}
```

再次感谢[@学无止境](https://www.luogu.org/space/show?uid=68975)大佬，大佬%%%

给自己的[博客](https://www.luogu.org/blog/weiyi/solution-p1908)打个广告

---

## 作者：enjoycolin (赞：3)

刘汝佳紫书上的方法：


```cpp
/*
Problem: 洛谷 P1908 逆序对
Language: C++
Writer: Colin
About: 分治、归并排序
*/
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>

using namespace std;

#define ll long long

int ans = 0;
void merge_sort(int *a, int x, int y, int *t)
{
    if (y - x > 1)
    {
        //分治三步法：
        //一、划分
        int mid = x + (y - x) / 2;
        int p = x,
            q = mid,
            i = x;
        //二、递归求解
        merge_sort(a, x, mid, t);
        merge_sort(a, mid, y, t);
        //三、合并
        while (p < mid || q < y)
        {
            if (q >= y || p < mid && a[p] <= a[q])
                t[i++] = a[p++];
            else
            {
                t[i++] = a[q++];
                /*统计左边大于右边的：
                在区间[x, mid)中，共有元素(mid - x)个，其中进入上个条件的是(p - x)个
                相减得到(mid - p)个
                */
                ans += (mid - p);
            }
        }

        for (i = x; i < y; i++)
            a[i] = t[i];
    }
}

int main()
{
    int a[100000] = { 0 },
        t[100000] = { 0 };
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];

    merge_sort(a, 1, n + 1, t);

    cout << ans << endl;

    return 0;
}
```

---

## 作者：s66104444 (赞：2)

逆序对标准求法，

即归并排序时如果发现了后边的小于前边的，就可以认定前面的数是这个数的逆序。

详细见代码。


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int cnt=0;
int n;
int a[100010];
int b[100010];
void erfen(int l,int r)//归并排序
{
    if(l==r)return;
    int mid=(l+r)>>1;
    erfen(l,mid);
    erfen(mid+1,r);
    int o=l;
    int p=mid+1;
    int z=l-1;
    while(o<=mid&&p<=r)
    {
        if(a[o]<=a[p])
        {
            b[++z]=a[o];
            o++;
        }
        else
        {
            b[++z]=a[p];
            p++;
            cnt+=mid-o+1;   //主要在这一步，重在理解。
        }
    }
    while(o<=mid)
    {
        b[++z]=a[o++];
    }
    while(p<=r)
    {
        b[++z]=a[p++];
    }
    for(int s=l;s<=r;s++)
    a[s]=b[s];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    erfen(1,n);
    cout<<cnt;
    return 0;
}
```

---

## 作者：wanzzhehe (赞：2)

看了这么多题解用的都是CDQ和线段树和树状数组，那么我就放一个Treap

使用Treap的优点是不用担心数据是否会出现负数以及数列中每个数字的大小。。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
using namespace std;

inline char getc(void) { 
    static char buf[1 << 18], *fs, *ft;
    return (fs == ft && (ft = (fs = buf) + fread(buf, 1, 1 << 18, stdin)), fs == ft) ? EOF : *fs++;
}

inline int read(void) { 
    int res = 0;
    char tmp = getc(), f = 1;
    while(!isgraph(tmp)) tmp = getc();
    if(tmp == '-') f = -1, tmp = getc();
    while(isdigit(tmp))
        res = ((res + (res << 2)) << 1) + (tmp ^ 0x30),
        tmp = getc();
    return res * f;
}

#define SIZ(x) ((x)?(x)->siz : 0)
#define UP(x) ((x)->siz = SIZ((x)->ls) + SIZ((x)->rs) + (x)->cnt)

struct NODE{ 
    int val, fix;
    int cnt, siz;
    NODE *ls, *rs;

    NODE(int v) { 
        val = v, fix = rand();
        ls = rs = NULL;
        siz = cnt = 1;
    }
};

inline void Left(NODE *&k2);
inline void Right(NODE *&k2);
void Insert(NODE *&node, int x);
inline int Query(int x);

NODE *root;
int N, s, ret = 0;

int main() { 
    srand(time(NULL));
    N = read();
    for(int i = 1; i <= N; ++i) { 
        s = read();
        ret += Query(s);
        Insert(root, s);
    }
    printf("%d", ret);
    return 0;
}

inline void Left(NODE *&k2) { 
    NODE *k1 = k2->rs;
    k2->rs = k1->ls;
    k1->ls = k2;
    UP(k2); UP(k1);
    k2 = k1;
}

inline void Right(NODE *&k2) { 
    NODE *k1 = k2->ls;
    k2->ls = k1->rs;
    k1->rs = k2;
    UP(k2); UP(k1);
    k2 = k1;
}

void Insert(NODE *&node, int x) { 
    if(!node) node = new NODE(x);
    else if(x < node->val) { 
        Insert(node->ls, x);
        if(node->ls->fix < node->fix) Right(node);
        else ++node->siz;
    } else if(node->val < x) { 
        Insert(node->rs, x);
        if(node->rs->fix < node->fix) Left(node);
        else ++node->siz;
    } else ++node->cnt, ++node->siz;
}

inline int Query(int x) { 
    int ret = 0;
    NODE *node = root;
    while(node && node->val ^ x)
        if(node->val < x) node = node->rs;
        else { 
            ret += SIZ(node->rs) + node->cnt;
            node = node->ls;
        }
    if(node && node->val == x) return ret + SIZ(node->rs);
    else return ret;
}
```
实际上这道题用线段树做的话我觉得用动态开点权值线段树为佳，因为这样时间和空间的复杂度就有保证了。。


---

## 作者：H2O3 (赞：2)

我用的是归并排序求逆序对（面对一群用树状数组的大佬萌新表示瑟瑟发抖）

归并排序其实是有分治思想的，首先把要排序的数组一分为二，然后再分，再分，再再再再分分分分，分到有若干个只有一个数的小数组为止，然后按照两个小数组的数据大小给排成大数组，最后排序成功。其中定义两个指针i和j，i从前半边开始找，j从后半边开始找，然后按照大小去并。求逆序对的过程就在排序的过程内，在合并的时候如果发现前面的数字大于后面的数字，那么就发现了逆序对。

...



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <cstdlib>
#include <set>
#include <map>
#include <vector>
#include <queue>
using namespace std;
int a[1000010],b[1000010];
int ans=0;
int n;
void merge(int s,int t)//归并排序函数 。 
{
    if(s==t)return;//分不了就别强行分了 。 
    int mid=s+t>>1;//其实就是除以2的意思，听说位运算比较快就用了。 
    merge(s,mid);//还没分完，继续分，这里有一点像二分的样子。 
    merge(mid+1,t);    
    int i=s,j=mid+1;//两个指针从两个数集的第一个开始指（虽然这里没用指针，但是和指针异曲同工）。 
    int p=s-1;//记录排好的数 。 
    while(i<=mid&&j<=t)//指针不能超出范围哦（i一直在前一半，j在后一半） 
    {
        if(a[i]<=a[j])//这里是按照从小到大排（因为要求逆序对），所以是小于等于。 
        {
            b[++p]=a[i];//把这个数放到大集合里面（归并中的并）。 
            i++;//这个数排完了，去看下一个数。 
        }
        else
        {
            b[++p]=a[j];//如果后一半的这个数比前一半的数大，那么这个数先进大集合。 
            j++;
            ans+=mid+1-i;//求逆序对。 
        }
    }
    while(j<=t)//如果一半的数已经排完了，剩下的数只要乖乖跟上就好了。 
    {
        b[++p]=a[j];
        j++;
    }
    while(i<=mid)
    {
        b[++p]=a[i];
        i++; 
    }
    for(int i=s;i<=t;i++)//每次排完记得更新。 
    a[i]=b[i];    
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    merge(1,n);
    /*for(int i=1;i<=n;i++)
    cout<<b[i]<<" ";
    cout<<endl;
```
这一部分是输出排序结果的，在这里只要求求逆序对，所以就不要这一块了\*/
    printf("%d",ans);

    return 0;

}
...

---

## 作者：iostream (赞：2)

此处是树状数组简单题解

核心原理：把树状数组当成桶，对于每个树快速找出之后有多少个数（即：当前数的总数 - 这个数之前的数个数）

————————————————————————————————


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[50001],p[50001],tree[100001],ans;
//这里是树状数组模板部分
inline void add(int i,int x){
    while(i<=n){
        tree[i]+=x;
        i+=i&-i;
    }
}
inline int quary(int i){
    int s=0;
    while(i){
        s+=tree[i];
        i-=i&-i;
    }
    return s;
}
inline bool cmp(int x,int y){
    return a[x]<a[y];
} //离散化一般写法
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        p[i]=i;
    } 
    sort(p+1,p+1+n,cmp);
    for(int i=1;i<=n;i++)
        a[p[i]]=i;
    for(int i=1;i<=n;i++){
        ans+=i-1-quary(a[i]);    //当前树状数组中有i-1个，quary(a[i])前缀和查出a[i]前的个数
        add(a[i],1);                    //值为a[i]的数又增加了一个
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：丿王者之路 (赞：2)

离散化+树状数组；


ps：线面提到的数组是在代码中出现的数组；


对于刚开始了解树状数组的同学，这是一道不错的练手题；


思路：求逆序对，那我们可以转换求在位置 i 之前的数，且比 i 要小的数的个数，用数组t[ ]来记录，最后用ans将所有的t[ ]加起来就是结果；


那该怎样求t[ ]呢？


首先我们可以先将输入的原先的数字记录下来，并将之离散化；


再求出数组a[ ]，其记录的是原先的在整个输入数中的大小；


最后用树状数组来求出t[ ];


如有不懂，可以看一下代码；

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){x+=x*10+ch-'0';ch=getchar();}
    return x*f; 
```
}//快读，也可以不着样写；
```cpp
const int maxn=40000+10;
int n,a[maxn],t[maxn],c[maxn];
struct Node
{
    int val;
    int pos;
}q[maxn];
bool cmp(Node a,Node b)
{
    return a.val>b.val;//按从大到小的顺序排； 
}
void update(int k)
{
    while(k<=n){c[k]+=1;k+=k&-k;}
}
int get(int k)
{
    int sum=0;
    while(k>=1){sum+=c[k];k-=k&-k;}
    return sum;
}
int main()
{
    scanf("%d",&n);
    for(int x,i=1;i<=n;i++) q[i]=(Node){read(),i};
    sort(q+1,q+n+1,cmp);
    for(int i=1;i<=n;i++)//离散化操作； 
    {
        if(q[i].val!=q[i-1].val || i==1) a[q[i].pos]=i;//a[]记录其在输入中的大小； 
        else a[q[i].pos]=a[q[i-1].pos];//如果有相同的数字 ； 
    }
    for(int i=1;i<=n;i++)
    {
        t[i]=get(a[i]-1);
        //求比a[i]再输入数中的小且在i位置的后面；
        //a[i]-1是为了除去本身；    
        update(a[i]);
        //将树状数组更新，因为查询过了，如果后面的节点比其小会用到； 
    }
    int ans=0;
    for(int i=1;i<=n;i++) ans+=t[i];//累加答案； 
    printf("%d",ans);
}
```

---

## 作者：hanker_AFO (赞：2)

这题很水， 归并排序包过，基本没问题。

以下为Pascal 代码。



```cpp
var
  i,j,n,m,ans:longint;//ans记录逆序对数。
  a,b:array[1..40000] of longint;
function gb(l,r:longint):longint;
var  
  i,j,k,m:longint;
begin
  if(l=r) then exit;//一个数还排什么序。
  m:=(l+r) div 2;//取中间。
  gb(l,m); gb(m+1,r);//左右排好序。
  i:=l; j:=m+1;
  for k:=l to r do//合并过程。
  begin
    if(j>r) then begin b[k]:=a[i]; inc(i); end//j>r说明右侧全排好了。
    else
      if(i>m) then begin b[k]:=a[j]; inc(j); end//同理。
      else
      if(a[i]>a[j]) then//选择小的那个往前排。
      begin
        b[k]:=a[j]; inc(j);
        ans:=ans+m-i+1;//满足逆序对条件，左侧所有未排序的数都形成逆序对。
      end
      else
        begin
          b[k]:=a[i]; inc(i);//同理。
        end;
  end;
  for k:=l to r do a[k]:=b[k];//把b数组赋给a数组。
end;
begin
  readln(n);
  for i:=1 to n do read(a[i]);
  gb(1,n);//开始归并。
  writeln(ans);//输出……。
end.
```

---

## 作者：Friendly (赞：2)

此题数据和题目都较水，可以采用**归并排序**

也可以采用**树状数组**，题解里面归并的较多，我就介绍一下**树状数组**；

首先我们使用树状数组就应该考虑空间的问题，这个题数据n《=40000；每个数字的值可能较大，不能直接开值那么大的空间，因为只需比较大小，就可以用到离散化。

而我们要知道的是逆序对，从前面顺序查找后面的情况并不是很容易弄清楚，所以想到逆序加入和查询，每加入一个数，它及它后面的情况便已经确定。

```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
long long ans;//最后的数目可能比较大，所以long long
int n;
int lowbit(int x)
{
    return x&(-x);
}
struct data{
    int x,site;
}wqr[100010];//wqr 我的名字缩写，存初始值和开始的角标。
int s[100010];//存每个位置上**已有**的数的个数；
int a[100010];//存离散后的每个位置的值；
int comp(const data a,const data b)
{
    return a.x<b.x;
}
void add(int x)
{
    while(x<=n)
    {
        s[x]++;
        x+=lowbit(x);
    } 
}
void find(int x)
{
    while(x>0)
    {
        ans+=s[x];
        x-=lowbit(x);
    }
}
int main()
{
    freopen("inversions.in","r",stdin);
    freopen("inversions.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        {
            scanf("%d",&wqr[i].x);
            wqr[i].site=i;
        }
    sort(wqr+1,wqr+n+1,comp);//排序，便于离散
    int e=0;
    for(int i=1;i<=n;i++)
      {
          if(wqr[i].x!=wqr[i-1].x)
           e++;
           a[wqr[i].site]=e;
      }
      //离散完成
    for(int i=n;i>=1;i--)
    {
        add(a[i]);
        find(a[i]-1);//逆序操作
    }
    cout<<ans;//完成
    fclose(stdin);
    fclose(stdout);
    return 0; 
}
```

---

## 作者：封癫 (赞：2)

这个题我的同学帮我讲了一下，我才发现树状数组可以这么用。。。我昨天还以为它只会求区间和或者区间积来着。。。。。

这题不用树状数组的n^2算法是这样的

首先我们把序列存进q数组里，再开一个数组c，然后倒着扫描一遍数组

对于q[i]，我们从1~i横扫一遍c数组

如果c[j]为真，说明  j 这个值比 i 这个值先被扫到，即原序列q中， j 在 i 后面

而且我们是从1~i扫的c数组 所以毋庸置疑的j的值比i小

哈哈满足逆序对条件 于是ans+=c[j]

完成之后c[i]++

最后输出ans

然后同学讲过之后我发现这东西是能用树状数组优化的

具体代码如下

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
template <typename T>
T read(){
    T num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num*10+ch-'0';
        ch=getchar();
    }
    return num*f;
}
#define read()    read<long long>()
int tree[50000];
struct file{
    int id;
    int data;
}q[56000];
long long ans=0;
int n;
void add(int k,int num){
    while(k<=n){
        tree[k]+=num;
        k+=k&(-k);
    }
}

void find(int k){
    int i=k;
    while(k){
        ans+=tree[k];
        k-=k&(-k);
    }
    add(i,1);
}
bool cmp1(file a,file b){
    return a.data<b.data;
}

bool cmp2(file a,file b){
    return a.id<b.id;
}

int main(){
    n=read();
    for(int i=1;i<=n;++i){
        q[i].data=read();
        q[i].id=i;
    }
    sort(q+1,q+n+1,cmp1);
    int dt=1;
    for(int i=1;i<=n;++i){
        if(q[i].data==q[i-1].data){
            q[i].data=q[i-1].data;
        }
        else q[i].data=dt++;
    }
    sort(q+1,q+n+1,cmp2);
    for(int i=n;i>=1;--i){
        find(q[i].data);
    }
    printf("%lld",ans);
    return 0;
}
```cpp
感谢我的同学%%%% @wz3逍瑞

最后叮嘱一遍  我的读入优化可能会出问题，切记不要随便用，在线段树模板里好像出岔子了全wa

ok差不多就这样


---

## 作者：doby (赞：2)

归并……排序……

方法一：

```cpp
#include <iostream>
using namespace std;
int n,a[40001],temp[40001],ans=0;
void sort(int i,int j)
{
    if(i==j){return;}
    int mid=(i+j)/2;
    sort(i,mid);sort(mid+1,j);
    int l=i,r=mid+1,k=i;
    for(;k<=j;k++)
    {
        if(l>mid){temp[k]=a[r],r++;}
        else
        {
            if(r>j){temp[k]=a[l],l++;}
            else
            {
                if(a[l]<=a[r]){temp[k]=a[l],l++;}//总之这些基本就是贴到temp数组里
                else{temp[k]=a[r],r++,ans=ans+mid-l+1;}//求逆序对数的关键语句
            }
        }
    }
    for(k=i;k<=j;k++){a[k]=temp[k];}//转移回a数组
}
int main()//这里很明显，没什么需要解释的……
{
    cin>>n;
    for(int i=0;i<n;i++){cin>>a[i];}
    sort(0,n-1);
    cout<<ans;
    return 0;
}
```
方法二：暴力
只能在曾经的洛谷2过了，整整跑了6s……

据有效数据，超时的点普遍用了300+s……


---

## 作者：Sor4 (赞：2)

//这题原理为归并排序，只要在排的时候做一些改动。




    
    
    
    
    
    

    
    
    
    
```cpp
#include<cstdio>
using namespace std;
#define MAXN 40010
int a[MAXN];
int f[MAXN];//a是待排序数组，r是临时存放数组。 
int p=0;
void merge_sort(int l,int r)//归并排序 
{
    int k,i,j,m;
    if(l==r) return;//若只有一个数据，不用排。 
    m=(l+r)/2;//取区间中点 
    merge_sort(l,m);//二分左区间 
    merge_sort(m+1,r);//二分右区间 
    i=l;
    k=l;
    j=m+1;
    //进行一次归并排序 
    while(i<=m&&j<=r)//两个子序列从小到大合并，直到有一列结束。 
    {
        if(a[i]>a[j])
        {
        p+=m-i+1;//！！！逆序对的关键，若a[i]>a[j]，
        //则左区间任何一个元素都大于a[j],产生逆序对个数相当于左区间元素个数。 
        f[k]=a[j];
        k++;j++;    
        }
        else
        {
            f[k]=a[i];
            k++;i++;
        }
    }
    while(i<=m) {f[k]=a[i];k++;i++;}
    while(j<=r) {f[k]=a[j];k++;j++;}//把剩余元素接入。 
    for(int w=l;w<=r;w++) a[w]=f[w];//把排序好的元素还回a数组。 
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    merge_sort(1,n);//进行排序 
    printf("%d",p);//输出逆序对个数。 
    return 0;
}
```

---

## 作者：usqwedf (赞：2)

其实，我们可以应用二路归并排序的性质，给出 nlogn 算法。

```delphi
var  
  i,n,t:longint;  
  a:array[0..100000] of longint;     
  h:array[0..100000] of longint;  
procedure merge(l,r:longint);  
var i,mid,left,right:longint;  
begin  
   if l>=r then exit;  
   mid:=(l+r)>>1;  
   merge(l,mid); merge(mid+1,r);   //二分左区间 二分右区间
   left:=l; right:=mid+1;  
   for i:=l to r do begin  
       if (left<=mid)and((a[left]<=a[right])or(right>r)) then begin  
           h[i]:=a[left];  
           left:=left+1;  
       end  
       else begin  
           h[i]:=a[right];  
           right:=right+1;  
           t:=t+(mid-left+1);  //统计
       end;  
   end;  //区间归并
   for i:=l to r do a[i]:=h[i];  
end;  
begin  
  readln(n);  
  for i:=1 to n do read(a[i]);  
  merge(1,n);  
  writeln(t);  //此时a数组也是有序的
end.  
```
在此速度上与树状数组相差无几？。。


---

## 作者：arfa (赞：2)

> ## 浅谈逆序对做法

由于最近考试触及到了逆序对,所以这里来讲一下这个最简单的做法。

> ### 权值线段树做法

我们知道逆序对定义: $a[i]>a[j]$ 且 $i<j$,所以朴素发方法就很容易想到。

$ for\ i:=1\ to\ n\ do $

$ \ \ \ \ \ for\ j:=i+1\ to\ n\ do $

$ \ \ \ \ \ \ \ \ \ \ Operate;$

然后我们试着把$O(n^2)$改为$O(n\ log\ n)$,我们可以把$j$这个循环删掉,用更伪的代码表示

$ for\ i:=1\ to\ n\ do $ 

$ \ \ \ \ \ i$前面的比它小的数

$ \ \ \ \ \ \ \ \ \ \ Operate;$

然后我们就可以想到前面的数进行存储然后直接查询的方法,然后又可以想到神奇的**权值线段树**,因为这样子可以保持**叶子节点单调**,但是需要离散化。

> ### 查询操作

我们把那些已经存储的点按照**普通线段树**区间查询出来就可以了。如图:

![4.png](https://cdn.luogu.com.cn/upload/pic/24313.png)

蓝色的部分肯定就是比$3$小且符合$i<j$(因为我是倒叙插入的)。

> ### 插入(修改)操作

修改操作就非常简单,直接在特定位置把数放进去。要注意$tree[k]:=tree[k*2]+tree[k*2+1]$。

![](https://cdn.luogu.com.cn/upload/pic/24316.png)

> ## $Code$

```pascal

var
    n,find,ans:int64;
    i:longint;
    num,place,numm:array[-1..110000] of int64;
    tree:array[-1..440000] of int64;

procedure Query(l,r,k:longint);
var
    mid:longint;
begin
    if (1<=l)and(r<=num[i]) then
    begin
        inc(find,tree[k]);
        exit;
    end;
    mid:=(l+r) div 2;
    if 1<=mid then
        Query(l,mid,k*2);
    if num[i]>mid then
        Query(mid+1,r,k*2+1);
end;

procedure Change(l,r,k:longint);
var
    mid:longint;
begin
    if l=r then
    begin
        inc(tree[k]);
        exit;
    end;
    mid:=(l+r) div 2;
    if num[i]<=mid then
        Change(l,mid,k*2)
    else
        Change(mid+1,r,k*2+1);
    tree[k]:=tree[k*2]+tree[k*2+1];
end;

procedure Sort(l,r:longint);
var
    s,t:int64;
    i,j:longint; 
begin
    i:=l; j:=r; s:=num[(l+r) div 2];
    repeat
        while num[i]<s do i:=i+1;
        while num[j]>s do j:=j-1;
        if i<=j then
        begin
            t:=num[i]; num[i]:=num[j]; num[j]:=t;
            t:=place[i]; place[i]:=place[j]; place[j]:=t;
            inc(i); dec(j);
         end;
    until i>=j;
    if i<r then  Sort(i,r);
    if j>l then  Sort(l,j);
end;

begin
    read(n);
    for i:=1 to n do
    begin
        read(num[i]);
        place[i]:=i;
    end;
    Sort(1,n);
    for i:=1 to n do
        numm[place[i]]:=i;
    num:=numm;

    i:=n;
    Change(1,n,1);
    for i:=n-1 downto 1 do
    begin
        find:=0;
        Query(1,n,1);
        inc(ans,find);
        Change(1,n,1);
    end;
    writeln(ans);
end.
```


---

## 作者：TJor (赞：2)

~~好像用线段树的人很少，那么本蒟蒻就来一发吧~~
dalao勿喷

首先，我们要明白这道题的思路：

我们开一个tree数组，来记录input[i]出现多少次

每当你输入序列里的i时，就将tree[i]++;

并且这个数的逆序对就是tree（为什么要叫这个名字？）数组里面i后面的所有值之和。

举个栗子

输入为：5 4 2 6 3 1

当5输入，tree数组：

0 0 0 0 1 0

5的后面的和为0

输入4

0 0 0 1 1 0

4的后面，5有一个tree[5]的1,所以以4为结束的逆序对有1个

输入2

0 1 0 1 1 0

2的后面有tree[4],tree[5]，逆序对数+2，一共有3个

输入6

0 1 0 1 1 1

6后面啥都没有，还是一共有3个

输入3

0 1 1 1 1 1 

3后面有4,5,6 总数+3，一共有6个

输入1

1 1 1 1 1

1后面有2 3 4 5 5，+5，一共有11个

完美！！！！！！

等会。。。。。。。。。。。。。。。。。。。。。。。

你确定这样不会超时吗？？

是的，会超时！！！

但是，正因为这片是题解，所以肯定有办法不超时！

还记得那个蹊跷的tree数组名吗？

这道题，我们需要用线段树优化

不会的同学请看线段树详解(单点修改和区间查询部分）：

[线段树详详详详解](https://www.luogu.org/blog/TJor/xian-duan-shu-yu-shu-zhuang-shuo-zu)

当一个值加1时，我们可以用单点修改，将tree[input[i]]加上1

对于input[i]的逆序对数，我们只需要对input[i]~m(m为输入中最大数)这个区间求和就好了。

很简单的修改，详细看代码注释：

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;
int read(int x)//输入函数 
{
    x=0;
    char ch=getchar();
    int f=1;
    for(;!isdigit(ch);ch=getchar())
        if(ch=='-')
            f=-1;
    for(;isdigit(ch);ch=getchar())
        x=x*10+ch-'0';
    return x*=f;
}
int n;
int m;
int a;
int input[10000010];
int ans=0;
struct node	//线段树的结构体 
{
    int left,right;
    int data;
    node()
    {
        data=0;
    }
}tree[10000010];
void build(int index,int left,int right)//建树（链接博客中提到） 
{
    tree[index].left=left;
    tree[index].right=right;
    if(tree[index].left==tree[index].right)
        return ;
    int mid=(left+right)>>1;
    build(index<<1,left,mid);
    build(index<<1|1,mid+1,right);
    return ;
}
void add(int index,int dis)//单点修改，使tree[input[i]]++ 
{
    tree[index].data++;
    if(tree[index].left==tree[index].right)
        return ;
    int mid=(tree[index].left+tree[index].right)>>1;
    if(dis<=mid)
        add(index<<1,dis);
    else
        add(index<<1|1,dis);
    return ;
}
int search(int index,int left,int right)//区间求和 
{
    if(tree[index].left>=left && tree[index].right<=right)
        return tree[index].data;
    int mid=(tree[index].left+tree[index].right)>>1;
    if(left<=mid && right>mid)//dalao YSF式de查询方法（我的不是这样） 
        return search(index<<1,left,right)+search(index<<1|1,left,right);
    else if(left<=mid)
        return search(index<<1,left,right);
    else
        return search(index<<1|1,left,right);
}
int main()
{
    n=read(n);
    for(int i=1;i<=n;i++)
    {
    	input[i]=read(input[i]);
        m=max(m,input[i]);
    }
    build(1,1,m);
    for(int i=1;i<=n;i++)
    {
        add(1,input[i]);
        if(input[i]!=m)//注意细节处理，没有会炸！！！ 
            ans+=search(1,input[i]+1,m);
    }
    cout<<ans;
}


```

以上就是代码，这种独特的解法适合冲击提高组一等奖的人做哦！！！

---

## 作者：Golden_Winter (赞：2)

**因为之前看他们写的都是二路归并，所以我写一个不同的，树状数组求解逆序对。**

树状数组是可以快速求出前i个的和，那我们就可以定义f[i]表示它前面有多少个比它大的数。定义完，就想到了排序，从大到小放a[i]，在a[i]初始所在的位置上放个1上去，然后每次取出的就是前面比a[i]大的数的个数。

不懂看代码

```CPP
#include<cstdio>
#include<algorithm>
using namespace std;
int n,f[40005],ans;
struct xcw{
    int x,id;
    bool operator <(const xcw b)const{return x>b.x||x==b.x&&id>b.id;}
}a[40005];
int read(){//读入
    int ret=0;bool f=1;char ch=getchar();
    for(;ch<'0'||'9'<ch;ch=getchar()) f^=!(ch^'-');
    for(;ch>='0'&&ch<='9';ch=getchar()) ret=(ret<<3)+(ret<<1)+ch-48;
    return f?ret:-ret;
}
void put(int p,int x){for(;p<=n;p+=p&-p) f[p]+=x;}//树状数组，在p位置上加个x。
int get(int p){int sum=0;for(;p;p-=p&-p) sum+=f[p];return sum;}//树状数组，取p之前的加和（包括p）
int main(){
    n=read();
    for(int i=1;i<=n;i++) a[i]=(xcw){read(),i};
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++){
        ans+=get(a[i].id);
        put(a[i].id,1);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：lych (赞：2)

本题一开始我是使用暴搜，结果值得了可怜的20分。然后我决定先快排一边再说。结果一边快排下来，我瞬间醒悟了。我们从大到小排序之后，一定是这样写的（b表示原来在数组中的位置）

```delphi
for i:=2 to n do
  for j:=1 to i-1 do
    if b[j]<b[i] then inc(ans);
```
虽然这还是N方的，但别着急，这已经十分接近正确答案了，我们发现，每一次i都是求1~b[i]中那些在它的前面，相当于在它前面的值为1，后面的值为0，循环之后值有变为了1，于是写出来是这样子的:

```delphi
for i:=2 to n do
   begin
     for j:=1 to b[i] do inc(ans,c[j]);
     c[b[i]]:=1;
   end;
```
我们发现了什么？对，只有加一和求和两种操作，于是~~~~树状数组！！！


详见标程：

```delphi
var
  a,b,c:array[0..100000] of longint;
  i,n,ans:longint;
procedure qsort(r,l:longint);
var
  i,j,t,mid:longint;
begin
  i:=r; j:=l;
  mid:=a[random(j-i+1)+i];
  repeat
    while a[i]>mid do inc(i);
    while a[j]<mid do dec(j);
    if i<=j then
      begin
        t:=a[i]; a[i]:=a[j]; a[j]:=t;
        t:=b[i]; b[i]:=b[j]; b[j]:=t;
        inc(i); dec(j);
      end;
  until i>j;
  if i<l then qsort(i,l);
  if r<j then qsort(r,j);
end;
function lowbit(x:longint):longint;
begin
  exit(x and -x);
end;//求x的lowbit
function getsum(x:longint):longint;
var
  t:longint;
begin
  t:=0;
  while x>0 do
    begin
      inc(t,c[x]);
      x:=x-lowbit(x);
    end;
  exit(t);
end;//求和
procedure insert(x:longint);
begin
  while x<=n do
    begin
      inc(c[x]);//由于只有加一，所以这样子即可
      x:=x+lowbit(x);
    end;
end;//插入操作
begin
  randomize;
  readln(n);
  for i:=1 to n do
    begin
      read(a[i]);
      b[i]:=i;
    end;
  qsort(1,n);//从大到小排序
  insert(b[1]);
  for i:=2 to n do
    begin
      inc(ans,getsum(b[i]));//累加求和
      insert(b[i]);//加1
    end;
  writeln(ans);
end.
```

---

## 作者：Dawn_Chase (赞：2)

~~**P党的福利啦**~~
### 看到楼下的dalao们的树状数组。实测貌似过不了只有30。。。让我这个蒟蒻来一发满分的树状数组。
#### 归并其它的dalao们已经讲的很清楚了，我就不再赘述了。
## 接下来步入正题啦
方便起见，我们设f[x]为x这个数出现过多少次了。

然后我们**倒序**扫一遍。（正序扫的话就是找i<j且ai<aj的数量）接下来是模拟过程

因为最后一个数是an，所以先把答案加上f[1]+f[2]+f[3]+……+f[an -1]，
然后f[an]的值+1

倒数第二个数是a(n-1)，所以先把答案加上f[1]+f[2]+f[3]+……+f[a(n-1)-1]，
然后f[a(n-1)]的值+1

以此类推。。。。

然后那个前缀和用树状数组优化一下就好了。

举个小栗子：

比如说999 99 9999这三个数

通过离散化之后我们可以把它看作2 1 3

先扫到3，f[3]+1,ans=0;

然后扫1，f[1]+1,ans=0

然后扫到2,f[2]+1,ans加上f[1]的值也就是ans=1

#### ~~然后就大功告成了啦~~

PS：
由于这个数据貌似有点毒瘤，同级[dalao](https://www.luogu.org/space/show?uid=29575)告诉我会有重复的数。。。~~貌似楼下的dalao们都被这个卡了。~~

离散化处理重复的数大家应该都会。毕竟打树状数组的都是巨佬啦~~(我太菜了)~~

~~处理重复的数~~(巨佬请无视)
```
  sort(1,n); //先按原数组大小排序
  for i:=1 to n do
   if a[i]<>a[i-1] then
    c[i]:=c[i-1]+1
   else
    c[i]:=c[i-1];
  a:=c;
  ssort(1,n); //再按下标排序，来自p党的淡淡的忧伤
```
贴一个丑陋的代码%%%[dalao](https://www.luogu.org/space/show?uid=29575)
```
var n,i:longint;
    ans:int64;
    a,b,c,s:array[0..1000001] of int64;
procedure sort(l,r:int64);　　//快排啦。。。
var i,j,x,t:int64;
begin
  i:=l;j:=r;x:=a[(l+r) div 2];
  repeat
   while a[i]<x do
    inc(i);
   while x<a[j] do
    dec(j);
   if i<=j then
    begin
     t:=a[i];a[i]:=a[j];a[j]:=t;
     t:=b[i];b[i]:=b[j];b[j]:=t;
     inc(i);dec(j);
    end;
  until i>j;
  if l<j then
   sort(l,j);
  if i<r then
   sort(i,r);
end;
procedure ssort(l,r:int64);　//快排啦。。。
var i,j,x,t:int64;
begin
  i:=l;j:=r;x:=b[(l+r) div 2];
  repeat
   while b[i]<x do
    inc(i);
   while x<b[j] do
    dec(j);
   if i<=j then
    begin
     t:=a[i];a[i]:=a[j];a[j]:=t;
     t:=b[i];b[i]:=b[j];b[j]:=t;
     inc(i);dec(j);
    end;
  until i>j;
  if l<j then
   ssort(l,j);
  if i<r then
   ssort(i,r);
end;
function lowbit(x:int64):int64;　//树状数组基本操作啦
begin
  exit(x and -x);
end;
procedure add(x,k:int64);　//树状数组基本操作啦
begin
  while x<=n do
   begin
    s[x]:=s[x]+k;
    x:=x+lowbit(x);
   end;
end;
function ss(x:int64):int64;　//树状数组基本操作啦
var now:int64;
begin
  now:=0;
  while x>0 do
   begin
    now:=now+s[x];
    x:=x-lowbit(x);
   end;
  exit(now);
end;
begin
  read(n);
  for i:=1 to n do
   begin
    read(a[i]);
    b[i]:=i;
   end;
  sort(1,n);
  for i:=1 to n do
   if a[i]<>a[i-1] then
    c[i]:=c[i-1]+1
   else
    c[i]:=c[i-1];
  a:=c;
  ssort(1,n);
  for i:=n downto 1 do　//开始统计答案啦
   begin
    add(a[i],1);
    ans:=ans+ss(a[i]-1);
   end;
  writeln(ans);
end.
```
最后再%%%[dalao](https://www.luogu.org/space/show?uid=29575)，感谢dalao的帮助与启发

---

## 作者：cenbinbin (赞：2)

二分。。。

此题尤为简单。不多说，自己看程序。。。。。。



```cpp
============================================================
const
        maxn=100000;
var
        a,b:array[1..maxn] of longint;
        n,i:longint;
        ans:int64;
function count(l,r:longint):longint;
var
        m,i,j,k:longint;
begin
        if l=r then exit;
        m:=(l+r) shr 1;
        count(l,m);count(m+1,r);  //做左右
        i:=l;j:=m+1;k:=l-1;//I 头指针 j 尾指针
        while (i<=m)and(j<=r) do//若在范围内
        begin
                while (a[i]<=a[j])and(i<=m) do
                begin
                        inc(k);
                        b[k]:=a[i];
                        if j<=r then inc(ans,j-m-1);//累加
                        inc(i);
                end;
                while (a[i]>a[j])and(j<=r) do
                begin
                        inc(k);
                        b[k]:=a[j];
                        inc(j);
                end;
        end;
        while i<=m do
        begin
                inc(k);
                b[k]:=a[i];
                inc(ans,j-m-1);
                inc(i);
        end;
        for i:=l to j-1 do a[i]:=b[i];
end;
begin
        readln(n);
        for i:=1 to n do read(a[i]);//读入
        count(1,n);//二分
        writeln(ans);
end.
========================================================
```

---

## 作者：Running_Coder (赞：1)

~~我就是来搞事情的~~

此题的标准方法之一是归并排序，本蒟蒻这回也用的是归并排序，然而并不是传统的姿势。。。

传统做法中，对于每个右边序列的数，计算左边序列中的数与其构成的逆序对的数量，并累加，得到结果。

但是本蒟蒻在学习了这种做法之后，突然脑洞了一下：

我们能不能反过来做，即对于每个左边序列的数，计算右边序列中的数与其构成的逆序对的数量，并累加，得到结果呢？

事实证明，这种姿势是可行的。

具体实现细节请见代码及注释。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cstdlib>

#include<stack>
#include<queue>
#include<vector>
#include<string>
#include<algorithm>
#include<map>
#include<set>

#define ri register int
#define ll long long
#define INF 2147483647

using namespace std;

inline void read(int &x){  //读入优化 
    x=0;
    char t=getchar();
    bool f=0;
    
    while(t<'0' || t>'9'){
        if(x=='-')f=1;
        t=getchar();
    }
    
    while(t>='0' && t<='9'){
        x=(x<<3)+(x<<1)+t-'0';
        t=getchar();
    }
    
    if(f)x=-x;
}

void msort(int,int);

int a[500005],b[500005];  //原数组和辅助数组 
int n;
ll ans=0;

int main(){
    read(n);
    for(ri i=1;i<=n;i++)read(a[i]);
    msort(1,n);
    printf("%lld\n",ans);
    
    return 0;
}

void msort(int l,int r){
    if(l==r)return;
    int mid=(l+r)>>1;
    msort(l,mid);
    msort(mid+1,r);
    
    int p1=l,p2=mid+1,ph=l;
    
    while(p1<=mid && p2<=r){
        if(a[p1]<=a[p2]){
            b[ph]=a[p1];
            p1++;
            ans+=p2-1-mid;
            //对于某个a[p1]，当p2不断增加时，无法得到其对应的结果
			//当p2增加至a[p1]<=a[p2]时，可得到此a[p1]对应的结果
			//a[p1]对应的逆序对数量，即为右边序列中，a[p2]前面的数字的数量（不包括a[p2]） 
        }
        else{
            b[ph]=a[p2];
            p2++;
            //传统做法中，应在此处更新ans
			//而在本姿势中，在这里更新是错的
			//原因：1.会将左边序列中的数字对应的结果重复计算
			//2.考虑p2一直增加而p1不变的情况
			//此时a[p1]对应的结果中，只有最后一个是正确的，其余的均错误 
        }
        ph++;
    }
    
    while(p1<=mid){
        b[ph]=a[p1];
        p1++;
        ph++;
        ans+=r-mid;
        //如果左边序列有剩余
		//则剩下的每一个数，都比右边序列中的所有数大
		//故左边序列剩余的每一个数，其对应的逆序对数量都为右边序列中数字的总数 
    }
    
    while(p2<=r){
        b[ph]=a[p2];
        p2++;
        ph++;
        //此种情况对答案无贡献 
    }
    
    for(ri i=l;i<=r;i++)a[i]=b[i];
}
```


---

## 作者：权御天下 (赞：1)

#### 在解题之前，先让我们来看一看本题会用到而萌新可能不懂的几个事项：

本题大意：对于给定的无序数组，求出经过最少多少次相邻元素的交换之后，可以使数组从小到大有序

对于逆序对的解释：两个数（a, b）的排列，若满足a > b，则称之为一个逆序对

归并排序的思想：先把每个数看成一段，然后两两合并成一个较大的有序数组，再把较大的两两合并，直到最后成为一个有序数组

归并排序复杂度：$ O(nlogn) $

#### 接下来就是我们解题的步骤了:

根据排序算法，我们知道如果相邻的两个元素满足前一个大于后一个便会交换一次，由于题目要求排序后是单调递增，所以我们可以将这道题看做求原数组逆序对的数量

举一个归并排序的例子：

假设初始数组为4 2 1 3

先把每一个数单独分成一组，即(4) (2) (1) (3)

接着两两合并，即(2 4) (1 3)

最后合成一个有序的数组，即(1 2 3 4)

不难发现，在排序过程中，若某个数向前移动了N位，则必定存在N个逆序数,如上面例子中，数字1由原先的第三位移到了第一位，前移了两位，则存在(2 1)和(4 1)两个逆序

而根据题意，我们只需要在归并排序的过程中把这个数记下来即可

接下来上一下代码

顺便安利一波自己的io模板：自测结果：不加io优化跑了1108ms，加了优化后仅跑了797ms（看近期大多数的提交都是1200ms+ ，快一点的也都是1000ms+，797ms应该算是比较快的）

io模板详解链接：https://twi.blog.luogu.org/duliu-io 

```cpp
#include<cstdio>
using namespace std;
#define ll long long

namespace io {  //io模板详见个人博客
#define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    const int SIZ = 1 << 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void out() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template<class Type>
    inline void read(Type &x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c > '9' || c < '0') && c != '-'; c = gc());
        c == '-' ? y = -1 : x = (c & 15);
        for (c = gc(); c >= '0' && c <= '9'; c = gc())
            x = x * 10 + (c & 15);
        x *= y;
    }
    template<class Type>
    inline void print(Type x, char text = '\n') {
        if (x < 0)
            *oS++ = '-', x *= -1;
        if (x == 0)
            *oS++ = '0';
        while (x)
            fu[++fr] = x % 10 + '0', x /= 10;
        while (fr)
            *oS++ = fu[fr--];
        *oS++ = text;
        out();
    }
}
using namespace io;  //以上为玄(du)学(liu)优(ka)化(chang)

ll ans[500010], mem[500010], anss;
int n;

void merge(int lo, int mid, int hi) {
    int i = lo, e = mid + 1, k = lo;
    while (i <= mid && e <= hi) {
        if (ans[i] <= ans[e])
            mem[k++] = ans[i++];
        else
            anss += e - k, mem[k++] = ans[e++]; //求逆序对和
    }
    while (i <= mid)
        mem[k++] = ans[i++];
    while (e <= hi)
        mem[k++] = ans[e++];
    for (i = lo; i <= hi; ++i)
        ans[i] = mem[i];
}

void merge_sort(int x, int y) {
    if (x < y) {
        int mid = (x + y) / 2;
        merge_sort(x, mid);
        merge_sort(mid + 1, y);
        merge(x, mid, y);
    }
}

int main() {
    read(n);
    for (register int i = 0; i < n; ++i)
        read(ans[i]);
    merge_sort(0, n - 1);
    print(anss);
    return 0;
}
```

我们的信条就是，用最短的码长，写出跑的最快的代码（不算io优化本人代码码长仅为0.8kb，在题解中也算是比较短的代码了）

码风诡异请不要在意QAQ

这道题就到这里，让我们下一道题见（发出咕咕咕的声音）

---

## 作者：54DAHAOREN (赞：1)

**这是数据加强后的一篇树状数组的题解**

首先，增强后数据中有重复元素

所以，在按价值排序时还应判断价值相同的元素顺序如何

如下
```cpp
bool cmp(pair<int,int> a,pair<int,int> b){
    if(a.first!=b.first)    
    	return a.first>b.first;
    return a.second>b.second;
}
//pair的first存价值，second存位置
```

还有注意开long long

最后贴上完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int N;
pair<int,int> a[5000100];
long long ans=0;
int tree[5000100];
bool cmp(pair<int,int> a,pair<int,int> b){
    if(a.first!=b.first)    return a.first>b.first;
    return a.second>b.second;
}
long long lowbit(int k){
    return k & -k;
}
void add(int x){
    while(x<=N){
        tree[x]++;
        x+=lowbit(x);
    }
}
long long query(int x){
    long long t=0;
    while(x){
        t+=tree[x];
        x-=lowbit(x);
    }
    return t;
}
int main(){
    cin>>N;
    for(int i=1;i<=N;i++){
        scanf("%d",&a[i].first);
        a[i].second=i;
    }
    sort(a+1,a+1+N,cmp);
    for(int i=1;i<=N;i++){
        add(a[i].second);
        ans+=query(a[i].second-1);
    }
    cout<<ans<<endl;
}
```



---

## 作者：C2H6O (赞：1)

## 这时候怎么能少了SBT呢

SBT（Size Balanced Tree）平衡树的一种，由陈启峰发明，据作者吹嘘，它是“目前为止速度最快的高级二叉搜索树”，它可以很方便地实现动态顺序统计中的select和rank操作

于是我们就有了个优秀的数据结构来动态计算某个数之前有多少个数大于它

答案就是它们的和...

比线段树和树状数组少了离散化，思维难度低，背模板就好；比Splay好写，还快，而且不会退化成链。想学习的各位看官可以百度一下查找资料
```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#define N 50010
using namespace std;
class SBT {
	int root, cnt;
	int data[N], sz[N], ch[N][2];
	inline void rotate(int &x, int dir) {//dir0为左旋1为右旋，可以分开来写，个人喜欢合并写，方便，但是小心把自己搞糊涂
		int t = ch[x][dir ^ 1];
		ch[x][dir ^ 1] = ch[t][dir];
		ch[t][dir] = x;
		sz[t] = sz[x];
		sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1;
		x = t;
	}
	inline void maintain(int &x) {//SBT最关键的维护平衡的操作，共4种情况，两两对称，具体左转度娘
		for (int i = 0; i < 2; i++) {
			if (sz[ch[ch[x][i]][i]] > sz[ch[x][i ^ 1]]) {
				rotate(x, i ^ 1);
				maintain(ch[x][i ^ 1]);
				maintain(x);
				break;
			}
			if (sz[ch[ch[x][i]][i ^ 1]] > sz[ch[x][i ^ 1]]) {
				rotate(ch[x][i], i);
				rotate(x, i ^ 1);
				maintain(ch[x][0]);
				maintain(ch[x][1]);
				maintain(x);
				break;
			}
		}
	}
	void insert(int &x, int k) {//插入
		if (!x) {
			data[++cnt] = k;
			sz[cnt] = 1;
			x = cnt;
		}
		else {
			sz[x]++;
			insert(ch[x][data[x] >= k], k);
			maintain(x);
		}
	}
	int order_of_key(int x, int k) {//查询排名
		if (!x) return 0;
		if (data[x] <= k) return order_of_key(ch[x][0], k);
		else return 1 + sz[ch[x][0]] + order_of_key(ch[x][1], k);
	}
public:
	SBT() {
		root = cnt = 0;
		memset(data, 0, sizeof(data));
		memset(sz, 0, sizeof(sz));
		memset(ch, 0, sizeof(ch));
	}
	inline void insert(int k) { insert(root, k); }//顺手的封装2333
	inline int order_of_key(int k) { return order_of_key(root, k); }
};
SBT sbt;
int n, ans;
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		int x; scanf("%d", &x);
		ans += sbt.order_of_key(x);
		sbt.insert(x);
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：巧若拙 (赞：1)

-     归并排序的递归算法简明易懂，但毕竟要多次递归调用，需要额外的递归栈空间，效率不如非递归算法高。

-     简单介绍一下算法思路：分别用L1和L2表示合并前后序列的长度，其中合并后序列的长度是合并前的两倍。

-     初始条件L1=1，之后每执行一次合并操作，L1增倍（L1=L2）。

-     外部 for 循环的循环体每执行一次，都使 L1 和 L2 加倍。内部的for循环执行序列的合并工作，它的循环体每执行一次，i 都向前移动 L2 个位置，合并相邻的两个等量序列，直到剩余元素的数量小于L2。若剩下的元素数量介于L1和L2之间，说明这是两个数量不等的序列，对他们进行合并操作；若剩下的元素数量不多于L1，说明这些元素属于同一个已排序的序列，无需合并。

-     合并函数采用了先复制再合并的方法，可以使代码更简洁。代码如下：



    
    
    
    
        
            
    
    
    
```cpp
    #include<iostream>
    using namespace std;
    const int MAX = 40001;
    int A[MAX], TA[MAX];
    int sum = 0;
    int ReverseNum_2(int n); //归并排序求逆序对  
    void MergeSort_2(int low, int high);//归并排序算法（非递归） 
    void Merge_2(int low, int mid, int high);//先复制再合并，可以使代码更简洁 
    int main() 
    {
        int n;
        cin >> n;
        for (int i=0; i<n; i++)
        {
            cin >> A[i];
        }
        cout << ReverseNum_2(n);
        return 0;
    }
    int ReverseNum_2(int n)
    {
        MergeSort_2(0, n-1);
        return sum;
    }
    void MergeSort_2(int low, int high)
    {
        int i, L1, L2=1, n=high-low+1;
        for (L1=L2; L2<=n; L1=L2)
        {
            L2 = L1 * 2;
            for (i=0; i+L2<=n; i+=L2)
            {
                Merge_2(i, i+L1-1, i+L2-1);
            }
            if (i+L1 < n)
                Merge_2(i, i+L1-1, n-1);
        }
    }
    void Merge_2(int low, int mid, int high)
    {
        int i, j, k;
        //将A[low..mid]中元素顺序复制到tempA[low..mid]
        for (i=low; i<=mid; i++) 
        {
            TA[i] = A[i];
        }
        //将A[mid+1..hig]中元素逆序序复制到tempA[mid+1..hig]
        for (i=mid+1,j=high; i<=high; i++,j--) 
        {
            TA[i] = A[j];
        }
        //将TA[]中元素按非递减序归并入A[] 
        for (k=i=low,j=high; k<=high; )//只需判断k是否越界（也可判断i<=j） 
        {
            if (TA[i] <= TA[j])
            {
                A[k++] = TA[i++];
            }    
            else
            {
                A[k++] = TA[j--];
                sum += mid - i + 1;//统计逆序对数量 
            }
        }
    }

```

---

## 作者：ModestCoder_ (赞：1)

来一波树状数组

ai,aj是逆序对，满足两个条件

1、i<j

2、ai>aj

那么我们就先满足条件2

也就是来发快排，从大到小

然后就用树状数组

怎么用？

先求和，求和求的是位置在自己前面的满足条件的总数

再改变，为什么先求和在改变？

因为改变也会改自己

改变位置在自己后面的，不管大小

说了一大堆也掩盖不了水题的事实










```cpp
var
    a,b,c:array[0..1000000] of longint;
    n,i,ans:longint;
function lowbit(x:longint):longint;
begin
    exit(x and -x);
end;
procedure change(x:longint);
begin
    while x<=n do
        begin
            inc(c[x]);
            inc(x,lowbit(x));
        end;
end;
function getsum(x:longint):longint;
begin
    getsum:=0;
    while x>0 do
        begin
            inc(getsum,c[x]);
            dec(x,lowbit(x));
        end;
end;
procedure sort(l,r: longint);
      var
         i,j,x,y: longint;
      begin
         i:=l;
         j:=r;
         x:=a[(l+r) div 2];
         repeat
           while a[i]>x do
            inc(i);
           while x>a[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=a[i];
                a[i]:=a[j];
                a[j]:=y;
                y:=b[i];
                b[i]:=b[j];
                b[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;
begin
    readln(n);
    for i:=1 to n do
        begin
            read(a[i]);
            b[i]:=i;
        end;
    sort(1,n); 
    for i:=1 to n do
        begin
            inc(ans,getsum(b[i]));
            change(b[i]);
        end;
    writeln(ans);
end.

```

---

## 作者：深海鱼的眼泪 (赞：1)

用树状数组写的。

先进行离散化。

a[i]表示原序列，d[i]表示a[j]=i的j的数量，c[i]表示a[1]~a[i-1]中的最大值。b[i]是树状数组，维护d[i-lowbit(i)+1]~d[i]的和。既然有了b数组，d数组就没有什么用了，可以不写。

求出c[i]。

将i从1~n进行一次循环，对于每一个i，ans+=d[j] (a[i]+1≤j≤c[i]),d[a[i]]++.这一步用树状数组维护。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
using namespace std;
int n,a[40001],b[40001],d[40001],c[40001];
bool cmp(int x,int y){
    return a[x]<a[y];
}
void add(int p){
    for (int i=p;i<=n;i+=i&-i) ++b[i];
}
int find(int p){//求出d[1]~d[p]的和
    int ans=0;
    for (int i=p;i;i-=i&-i) ans+=b[i];
    return ans;
}
void read(int& x){
    x=0;
    int y=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-') y=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    x=x*y;
}
int main(){
    int i,j,ans=0,t;
    read(n);
    for (i=1;i<=n;++i){
        read(a[i]);
        d[i]=i;
    }
    sort(d+1,d+n+1,cmp);//离散化
    for (i=1;i<=n;++i){
        a[d[i]]=i;
    }
    for (i=2;i<=n;++i){
        if (c[i-1]>a[i-1]) c[i]=c[i-1];
        else c[i]=a[i-1];
    }
    for (i=1;i<=n;++i){
        if (a[i]+1<=c[i]) ans+=find(c[i])-find(a[i]);
        add(a[i]);//d[a[i]++
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：wsyzz (赞：1)

用线段树写了一下。。。

注释在代码里


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,tree[160005];
struct dopo{//可爱的结构体*1 
    int x;
    int y;
    int type;
}a[40005];
bool cmp1(dopo x,dopo y) {return(x.x<y.x);}
bool cmp2(dopo x,dopo y) {return(x.type<y.type);}
void add(int type,int l,int r,int w){//地址，区间左端，区间右端，要加的值 
    tree[type]++;//tree[type]存该区间内数据个数 
    if(l==r) return;//若该区间只有单元素，返回 
    int mid=(l+r)/2;//取中· 
    if(w<=mid) return add(type*2,l,mid,w);//二叉树左儿子左边是2n 
    else if(w>mid) return add(type*2+1,mid+1,r,w);//右儿子 2n+1
}
int find(int type,int l,int r,int fl,int fr){//找此数之前有多少比他小的 &&分情况讨论区间 
    if((l==fl)&&(r==fr)) return tree[type];
    int mid=(l+r)/2;
    if(fr<=mid) return find(type*2,l,mid,fl,fr);
    else if(fl>mid) return find(type*2+1,mid+1,r,fl,fr);
    else  return(find(type*2,l,mid,fl,mid)+find(type*2+1,mid+1,r,mid+1,fr));
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i].x);//先在x中存数据； 
        a[i].type=i;//type存地址 
    }
    sort(a+1,a+n+1,cmp1);//第一遍sort，以x值大小升序排列 
    int e=0,sum=0;//e是映射的标志 
    for(int i=1;i<=n;i++){//数据范围太大，让我们来一波离散化 
        if(a[i].x!=a[i-1].x) e++;//因为已经排好了序 ，相同的数据会直接挨着 
        a[i].y=e;//在这以后a[i].x就不用登场了，直接用其映射a[i].y 
    }
    sort(a+1,a+1+n,cmp2);//以type升序排，由于type是原数组的下标，这一步相当于还原刚开始的输入顺序 
    for(int i=1;i<=n;i++){
        add(1,1,n,a[i].y);//add是往线段树中加边 
        sum=sum+i-find(1,1,n,1,a[i].y);//sum+已读入数据-不合要求的 
    }
    printf("%d",sum);//OK!!!dopo蒟蒻！！！ 
    return 0;
} 
dopo蒟蒻

```

---

## 作者：Deny_小田 (赞：1)

就是一个归排，稍加修改[delete]（就是加一条语句）[/delete]就能搞定了。

数据范围有毒！

上面写着：对于100%的数据，均 <= 10000，然后我就开了Size是10001的数组，20分==

这次让我真正明白了“数组开大点不花钱，开小了会抓狂”这句话的真谛@\_@

暴力搜索O(n^2)会超时（第一次我就用的暴搜，结果20分）

还是得用归排啊！


[delete]附上AC代码：[/delete]


```cpp

#include <stdio.h>
#define Size 1000001

int A[Size],T[Size],cnt = 0;

void Merge\_Sort(int x,int y){       //归并排序
    if(y-x > 1){
        int m = x+(y-x)/2,p,q,i;    
        p = x,q = m,i = x;    //p是左边数组的第一个元，q是右边数组的第一个下标
        Merge\_Sort(x,m);
        Merge\_Sort(m,y);
        while(p < m || q < y){
            if(q >= y || (p < m&&A[p] <= A[q])) T[i++] = A[p++];    //重要!
            else T[i++] = A[q++],cnt += m-p; 
        }
        for(i = x; i < y; i++) A[i] = T[i];
    } 
}

int main(){
    int n,i;
    scanf("%d",&n);
    for(i = 0; i < n; i++) scanf("%d",&A[i]);
    Merge\_Sort(0,n);
    printf("%d\n",cnt); 
    
    return 0; 
}

---

## 作者：夏色祭 (赞：1)

###**最近在练习树状数组，所以就不说快(gui)排(bing)的方法了**

先对读入的数列进行一次离散化操作，接下来树状数组的操作会方便些。

然后就是树状数组的常规操作了

不多bb，

上代码：

```cpp
var
  num,a,b,c:array[0..40001]of longint;
  n,i,j:longint;
  ans:int64;
procedure kp(l,r:longint);
var
  i,j,mid:longint;
  begin
    i:=l;
    j:=r;
    mid:=a[(l+r) >> 1];
    repeat
      while a[i]<mid do inc(i);
      while a[j]>mid do dec(j);
      if i<=j then 
        begin
          a[0]:=a[i];a[i]:=a[j];a[j]:=a[0];
          num[0]:=num[i];num[i]:=num[j];num[j]:=num[0];
          inc(i);
          dec(j);
        end;
    until i>j;
    if i<r then kp(i,r);
    if l<j then kp(l,j);
  end;
function lowbit(x:longint):longint;
begin
  exit(x and (-x));
end;
procedure add(x:longint);//插入
begin
  while x<=n do 
    begin
      inc(c[x]);
      x:=x+lowbit(x);
    end;
end;
function sum(x:longint):longint;//求和
begin
  sum:=0;
  while x>0 do 
    begin
      inc(sum,c[x]);
      x:=x-lowbit(x);
    end;
end;
begin 
  readln(n);
  for i:=1 to n do 
    begin
      read(a[i]);
      num[i]:=i;
    end;
  b:=a;
  kp(1,n);
  j:=0;
  a[0]:=-1;
  for i:=1 to n do
    if a[i]<>a[i-1] then 
      begin
        inc(j);
        b[num[i]]:=j;
      end
      else b[num[i]]:=j;//离散化
  for i:=n downto 1 do //注意是downto，至于为什么这样，请自己领会
    begin
      inc(ans,sum(b[i]));
      add(b[i]);
    end;//树状数组的常规操作
  write(ans);
end.
```

---

## 作者：Tony_Ni (赞：0)

#### 今天我们来讲一讲逆序对的另外一种实现
#### 树状数组&Splay

其实逆序对不仅仅是可以用

1、离散化+权值线段树

2、动态开点+权值线段树

如果您还没有看到这两个解法，不要着急，下面是链接：[从逆序对开始](https://mudrobot.blog.luogu.org/zong-ni-xu-dui-kai-shi-post)

#### (感谢Mudrobot的鼎力支持)

这道题已经被我淡忘一周了，可是他的灵魂我一直没有忘记，直到昨天，有一个同学提醒我这道题能不能用树状数组做，我一下子就惊醒了，我发现这个东西应该是一个非常好的点子，因为树状数组本来就要比线段树快并且空间比线段树小，最重要的是，这玩意儿还非常的好写，所以今天早上我成功的用树状数组AC了这道题，结果非常理想下面上几张图：

下面是线段树跑出的结果：

![这里写图片描述](https://img-blog.csdn.net/20180404170722594?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDc5OTMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

下面是树状数组跑出的结果：

![这里写图片描述](https://img-blog.csdn.net/20180404170800875?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDc5OTMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

没有学过树状数组吗？戳这里☞[树状数组](https://mudrobot.blog.luogu.org/shu-zhuang-shuo-zu-hou-xu-geng-xin-post)

大家只要认真学习了以后并且认真看了前面链接博客的离散化的操作那么我相信这道题很快就可以脑补出来！

代码如下：（很短的！！！）

```
#include<bits/stdc++.h>
using namespace std;
const int N=40005;
struct sd{
    int loc,val;
}a[N];
int n;
int maxx=0;
int x[N],o[N],ans=0;
int lowbit(int a){return a&-a;}
void modify(int num)
{
    while(num<=maxx)
    {
        o[num]+=1;
        num+=lowbit(num);
    }
}
int query(int num)
{
    int an=0;
    while(num)
    {
        an+=o[num];num-=lowbit(num);
    }
    return an;
}
bool cmp(sd a,sd b){
    if(a.val<b.val)
    return true;
    return false;
}
void lisanhua(int n)
{
    for(int i=1;i<=n;++i){
        cin>>a[i].val;
        a[i].loc=i;
    }
    sort(a+1,a+1+n,cmp);
    int cnt=1;
    for(int i=1;i<=n;++i){
        if(i==1||a[i].val==a[i-1].val)
            x[a[i].loc]=cnt;
        else{
            cnt++;
            x[a[i].loc]=cnt;
        }
    }
}
int main()
{
    std::ios::sync_with_stdio(false);cin>>n;
    lisanhua(n);
    for(int i=1;i<=n;++i) if(maxx<x[i]) maxx=x[i];
    memset(o,0,sizeof(o));
    for(int i=1;i<=n;++i){
        modify(maxx+1-x[i]);
        ans+=query(maxx-x[i]);
    }
    cout<<ans;
    return 0;
}
```

好了第一种算法讲完了，下面我们来讲一讲万能解法Splay(伸展树)

还是一样的节奏，不会Splay的戳这里☞[Splay详解](https://mudrobot.blog.luogu.org/splay-yang-xie)

思路很简单，因为我们每一次插入一个点我们就对他进行旋转操作，旋转到根节点，然后查右子树大小就可以了。是不是很简单，但代码就比线段树难写太多了，但是还是比线段树快，内存也比线段树小！！！

上图：

![这里写图片描述](https://img-blog.csdn.net/20180404171708193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDc5OTMz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

代码如下：

```
    #include<bits/stdc++.h>
    using namespace std;
    struct sd
    {
        int value;//当前节点所储存的值 
        int son[2];//左右儿子 
        int delta; //暂时没用
        int father;//自己的爸爸 
        int below;//自己下面树的大小 
    }tree[1000005];
    int root;//根 
    int cnt;//下标分配 
    int dir;//旋转方向 0是左边 1是右边 
    inline void maintain(int now)//维护 更新左右子树的大小（这道题中可以不写）
    {
        tree[now].below=1;
        if(tree[now].son[0])tree[now].below+=tree[tree[now].son[0]].below;
        if(tree[now].son[1])tree[now].below+=tree[tree[now].son[1]].below;
    }
    inline int get(int now)//确定旋转方向 
    {
        if(tree[tree[now].father].son[0]==now)return 0;
        return 1;
    }
    //---------------------------------------------------------------------- 
    void rotate(int now)//旋转 需要重点理解 
    {
        dir=get(now);
        int fa=tree[now].father,gra=tree[fa].father;
        tree[fa].son[dir]=tree[now].son[dir^1];
        tree[tree[now].son[dir^1]].father=fa;
        if(gra)tree[gra].son[get(fa)]=now;
        tree[now].father=gra;
        tree[fa].father=now;
        tree[now].son[dir^1]=fa;
        maintain(fa);
        maintain(now);
    }
    //---------------------------------------------------------------------- 
    inline void splay(int now)
    {
        int gra,fat;//定义now的祖父和爸爸 
        int opt1,opt2;//定义两次旋转方向 
        while(tree[now].father)//如果now还有自己的爸爸，即now还没有旋转到根节点。继续！ 
        {
            fat=tree[now].father;gra=tree[fat].father;
            if(gra!=0)//如果有祖父，即要进行双旋！ 
            {
                opt1=get(now);opt2=get(fat);
                if(opt1==opt2){rotate(fat),rotate(now);}
                else{rotate(now),rotate(now);}
            }
            else
            rotate(now);
        }
        root=now;//更新根节点 
    }
    void insertit(int now,int val,int pre)
    {
        if(!now)//如果now为零（零是假的，其余是真的）说明他没有（左右）儿子，就插入，并且进行根节点旋转
        {
            cnt++;
            tree[cnt].father=pre;
            tree[cnt].value=val;
            tree[cnt].below=1;
            if(tree[pre].value>val)tree[pre].son [0]=cnt;
            else tree[pre].son[1]=cnt;
            splay(cnt);
        }
        else//如果now不是零 
        {
            if(tree[now].value>val)insertit(tree[now].son[0],val,now);
            else insertit(tree[now].son[1],val,now);
        }
    }
    inline void in(int &x)//快读 
    {
        bool fu=false;
        x=0;char c=getchar();
        while(!isdigit(c))
            {
            if(c=='-')
            {
                fu=true;
            }
            c=getchar();}
        while(isdigit(c)){x*=10,x+=c-48;c=getchar();}
        if(fu)x*=-1;
    }
    int main()
    {
    	int ans=0;
        long long tot=0;
        int num,prev,sucv;
        in(num);
        int a;
        while(num--)
        {
            in(a);
            insertit(root,a,root);//读入（从当前根向下扔数） 
            ans+=tree[root].below-tree[tree[root].son[0]].below-1;//-1很重要 
        }
        printf("%d",ans);//返回总和 
        return 0;
}
```

---

## 作者：ustze (赞：0)

来一个总汇吧

方法1：冒泡 时间O(N^2) 铁定TLE

方法2：归并排序 时间O(Nlog2N) 一开始学的求逆序对算法

方法3：树状数组

先离散化，之后具体看代码，楼下都讲得很清楚了

code:



    
    

```cpp
    const int maxn=100005
    int n;
    int a[maxn],c[maxn],p[maxn];
    inline void update(int pos,int x)
    {
        while(pos<=n)
        {
            c[pos]+=x;
            pos+=pos&-pos;
        }
    }
    inline int getsum(int pos)
    {
        int sum=0;
        while(pos>0)
        {
            sum+=c[pos];
            pos-=pos&-pos;
        }
        return sum;
    }
    inline int cmp(int x,int y)
    {
        return a[x]<a[y];
    }
    int main()
    {
        scanf("%d",&n);
        int s=0;
        for(register int i=1;i<=n;++i)
        {
            scanf("%d",&a[i]);
            p[i]=i;
        }
        sort(p+1,p+1+n,cmp);
        for(int i=1;i<=n;i++)
            a[p[i]]=i;
        for(int i=1;i<=n;i++)
        {
            update(a[i],1);
            s+=i-getsum(a[i]);
        }
        cout<<s;
        return 0;
    }
```
方法4：权值线段树
大体思路和树状数组比较像，线段树的下标变成了权值而不再是数，但因为常数跑得比树状数组慢，又比归并要快。但这个东西会用还是很NB的，很多问题都可以用到

code:

    
    
    
    
    
    
```cpp
    const int maxn = 40010;
    struct Node{
        int l,r;
        int tot;
    }tree[maxn<<2];
    struct lk
    {
        int val,num;
    }a[maxn];
    void build(int l,int r,int o)
    {
        tree[o].l=l;
        tree[o].r=r;
        if(tree[o].l==tree[o].r) return ;
        int mid=(tree[o].l+tree[o].r)>>1;
        build(l,mid,o<<1);
        build(mid+1,r,o<<1|1);
    }
    void push_up(int o)
    {
        tree[o].tot=tree[o<<1].tot+tree[o<<1|1].tot;
    }
    void update(int o,int x)
    {
        if(tree[o].l==x && tree[o].l==tree[o].r)
        {
            tree[o].tot++;
            return ;
        }
        int mid=(tree[o].l+tree[o].r)>>1;
        if(x<=mid) update(o<<1,x);
        if(x>mid) update(o<<1|1,x);
        push_up(o);
    }
    long long getans(int o,int l,int r)
    {
        if(tree[o].l>r || tree[o].r<l) return 0;
        if(tree[o].l==l && tree[o].r==r) return tree[o].tot;
        int mid=(tree[o].l+tree[o].r)>>1;
        if(r<=mid) return getans(o<<1,l,r);
        if(l>mid) return getans(o<<1|1,l,r);
        return getans(o<<1,l,mid)+getans(o<<1|1,mid+1,r);
    }
    inline int cmp(lk x,lk y)
    {
        return x.val<y.val;
    }
    int main()
    {
        int n;
        scanf("%d",&n);
        build(1,maxn,1);
        for(int i=1;i<=n;i++) scanf("%d",&a[i].val),a[i].num=i;
        sort(a+1,a+n+1,cmp);
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            ans+=getans(1,(a[i].num+1),n+1);
            update(1,(a[i].num));
        }
        printf("%d",ans);
        return 0;
}
```

---

## 作者：jx2014wzd (赞：0)

尽管都是归并排序，

这个程序只有两个循环，

优化后运行效率有略微的提高：1125ms，

**（虽然时间复杂度还是nlog(n)）**

不过可读性很差，

尽管数据加强后没有快速输入依然能AC，

所以记住：

请不要因为一点点的效率而使得代码变得难以维护。

~~（其实被chen_zhe_julao加强后的数据也不是那么难嘛）~~

```c
#include<stdio.h>
long long temp[500001],s1ac_8j[500002];
//首先， 这么大的输入数据怎么能不定义大的数组呢对吧
bool _=false;
/*main参数初始化条件，
如果你的编译器会把所有参数都初始化为零那么就不需要这条语句*/
long long sort(long long *a,const int i,const int j,long long temp[],long long ans=0)
{//归并排序的原理正好拿来求逆序对
    if(i==j)return ans;
	//边界条件
    int l,n,r,m;
	   
	for(	ans=sort(a,i,(r=(m=((l=n=i)+j)/2)+1)-1,temp,ans)
 				,ans=sort(a,r,j,temp,ans);
    	    /*递归将数据分解*/
            n<=j||(a+=i,n-=i,temp+=i,0);
            /*如果不符合n<=j才会执行后面的，不过这条语句
              因为逗号表达式所以依然返回的是n<=j的比较结果
    	      这还是通过||和&&的普遍特性来实现的快速if语句*/
            (l<=m||(n[temp]=r++[a],0))
        		&&(r<=j||(temp[n]=l++[a],0))
        	    &&(a[l]>a[r]||(temp[n]=l++[a],0))
        	    &&(n[temp]=(ans+=m-l+1,r++)[a]),n++
            /*因为可能有相等的数,所以注意要写小于等于号*/
            /*因为编译时的‘贪心法’和C语言数组偏移
              量是通过指针处理的这个特性,r++[a]等
              同于a[r++]这一点应该都知道吧，
              不过这样偏移量作为左值在一般情况下
              速度会有十分细微的加快(这一点请不要学习我)*/
      );
	//有没有发现上面这只是一条for循环语句，只不过我稍微排版了一下
    
	while(--n+1)*a++=*temp++;
    /*将temp数组部分赋值给a数组,
    其实也可以把这条语句放进for循环里，
    不过因为比较所以单独放出来速度会更快*/
	return ans;
}
int main(int argv,char**argc)
{
	return !_?(_=!_,main(0,argc)):(scanf("%lld"
	,&argv[s1ac_8j]),(argv!=0[s1ac_8j]?main(
	argv+1,argc):(printf("%lld",sort(1+s1ac_8j
	,0,0[s1ac_8j]-1,temp)),0)));
	/*main递归实现连续输入,
      依然是一条语句,
      如果你感兴趣你可以来分析这条语句的意思
      提示：s1ac_8j[0]存储的是数组大小*/
}
```


---


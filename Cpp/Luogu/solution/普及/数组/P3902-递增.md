# 递增

## 题目描述

现有数 $A_1,A_2,\cdots,A_n$，修改最少的数字为**实数**，使得数列严格单调递增。

注：原题误表述为修改为整数，现已纠正为实数。本题数据确保按照修改为整数的做法也可以 AC（只是不能过样例）

## 说明/提示

• 对于50% 的数据，$N \le 10^3$

• 对于100% 的数据，$1 \le N \le 10^5 , 1 \le A_i \le 10^9$


## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
1```

## 样例 #2

### 输入

```
8
1 2 3 4 4 5 6 7```

### 输出

```
1```

# 题解

## 作者：The_Key (赞：74)

作为本题的第一篇题解，本蒟蒻表示很鸡冻o(\*￣▽￣\*)o

在此介绍一种奇门遁甲之术——STL中的 lower\_bound()函数

lower\_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value 的值——引自百度百科（个人口才太差解释不清。。）

这题可以边输入边判断，用lower\_bound()函数取地址然后赋值同时累加器计数，最后输出累加器的值就是最终结果

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long n,num,now,sum,f[1001];
int main()
{
    cin>>n;
    for(long long i=1;i<=n;i++)
    {
        cin>>num;
        if(num>f[now])//如果这个数比以前的大说明不破坏数列严格递增的性质那么将这个数放在数列都后面
        f[++now]=num;
        else
        {
            *lower_bound(f+1,f+now+1,num)=num;//如果这个数比之前的数小那么用lower_bound()函数找到它适合的位置将这个数放进去
            sum++;//这样做相当于修改一个数，所以累加器加1
        }
    }
    cout<<sum;
    return 0;
}
//比人代码不精大神勿喷
```

---

## 作者：一ZCH一 (赞：33)

## ~~正儿八经的~~DP写法


我们用逆向思维

先求出这组数中最长上升子序列中的数的数量

要修改的数的数量就是不在最长上升子序列中的数的数量

所以只要算出最长上升子序列长度，然后总数减去长度就是答案

但是时间复杂度是$O(n^2)$

对于$10^5$就会超时了

~~50分也是分啊~~


```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100001;
int a[N],dp[N];
//dp[i]表示从第1个到达第i个的最大上升子序列 
int n,ans;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		dp[i]=1;
	}
	for(int i=2;i<=n;i++)
		for(int j=1;j<i;j++)
			if(a[j]<a[i])
				dp[i]=max(dp[i],dp[j]+1);
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	ans=n-ans;
	cout<<ans;
	return 0;
}
```
然后优化一下

$dp[i]$表示从最长上升子序列$i$时第$i$个位置的最小值

把两重循环变成一重

这样时间复杂度就是$O(n×log_n)$
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100001;
int a[N],dp[N];
//dp[i]表示从最长上升子序列i时第i个位置的最小值 
int n,ans=0;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]>dp[ans])
		{
			ans++;
			dp[ans]=a[i];
		} 
		else 
		{
			for(int j=1;j<=ans;j++)//找到第一个大于a[i]的dp，更新dp
			{
				if(dp[j]>a[i]) 
				{dp[j]=a[i];break;} 
			}
		}
	} 
	cout<<n-ans<<endl;
	return 0;
}
```
但是光光$AC$可不够，如果数据范围再大呢

所以可以使用二分查找提高速度

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100001;
int a[N],dp[N];
//dp[i]表示从最长上升子序列i时第i个位置的最小值 
int n,ans=0;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		if(a[i]>dp[ans])
		{
			ans++;
			dp[ans]=a[i];
		} 
		else 
		{
			//二分优化 
			int l=1,r=ans,mid;
			while(l<r)
			{
				mid=(l+r)/2;
				if(a[i]<=dp[mid])//在mid的左边 
				{
					r=mid;//右边更新为mid，因为mid有可能是答案，所以不能写成了mid-1 
				}
				else //if(a[i]>=dp[mid])
				{
					l=mid+1;//左边更新为mid，因为mid不可能是答案，所以mid+1 
				}
			}
			dp[l]=a[i]; 
		}
	} 
	cout<<n-ans<<endl;
	return 0;
}
```


---

## 作者：一扶苏一 (赞：30)

[更好的阅读体验戳这里](https://www.cnblogs.com/yifusuyi/p/9827802.html)
## Solution

看了下题目的意思貌似允许修改成实数，所以这里求一个LIS就完事了。但是发现$n^2$的LIS会爆炸，然而我又不会用单调性二分的$O(nlogn)$的做法，于是自己口胡了一个树状数组的做法。

在此声明一下这个做法有点水所以不能确定是不是有人提出过。但我确实口胡出来了

显然读入可以离散化。离散化以后把DP的状态定义改变一下，设$f_i$为当前算到的以$i$为结尾的LIS的ans。

考虑转移，显然正向DP时对于一个新位置$f_i=\max\{f_j\}+1$，其中$j~<~i$。

发现$f_i$转移是由一个小于$i$的前缀$\max$转移来的。

于是可以树状数组维护这个前缀$\max$，更新$f_i$以后在树状数组上更新一下就好

## Code

```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
#define rg register
#define ci const int
#define cl const long long int

typedef long long int ll;

namespace IO {
	char buf[300];
}

template <typename T>
inline void qr(T &x) {
	rg char ch=getchar(),lst=' ';
	while((ch > '9') || (ch < '0')) lst=ch,ch=getchar();
	while((ch >= '0') && (ch <= '9')) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(lst == '-') x=-x;
}

template <typename T>
inline void qw(T x,const char aft,const bool pt) {
	if(x < 0) {putchar('-');x=-x;}
	rg int top=0;
	do {
		IO::buf[++top]=x%10+'0';
	} while(x/=10);
	while(top) putchar(IO::buf[top--]);
	if(pt) putchar(aft);
}

template <typename T>
inline T mmax(const T a,const T b) {return a > b ? a : b;}
template <typename T>
inline T mmin(const T a,const T b) {return a < b ? a : b;}
template <typename T>
inline T mabs(const T a) {return a < 0 ? -a : a;}

template <typename T>
inline void mswap(T &a,T &b) {
	T _temp=a;a=b;b=_temp;
}

const int maxn = 100010;

int n;
int MU[maxn],tree[maxn],frog[maxn],temp[maxn];

int ask(int);
void init_hash();
void change(int,ci);

inline int lowbit(ci x) {return x&(-x);}

int main() {
	qr(n);
	for(rg int i=1;i<=n;++i) {qr(MU[i]);temp[i]=MU[i];}
	init_hash();
	for(rg int i=1;i<=n;++i) {
		frog[MU[i]]=ask(MU[i]-1)+1;
		change(MU[i],frog[MU[i]]);
	}
	qw(n-ask(n),'\n',true);
	return 0;
}

void init_hash() {
	std::sort(temp+1,temp+1+n);
	int *ed=std::unique(temp+1,temp+1+n);
	for(rg int i=1;i<=n;++i) MU[i]=std::lower_bound(temp+1,ed,MU[i])-temp;
}

int ask(int x) {
	int _ans=0;
	while(x) {
		_ans=mmax(_ans,tree[x]);
		x-=lowbit(x);
	}
	return _ans;
}

void change(int x,ci v) {
	while(x <= n) {
		tree[x]=mmax(tree[x],v);
		x+=lowbit(x);
	}
}
```

## Summary

以后麻麻再也不用担心我不会$O(nlogn)$求LIS辣！

---

## 作者：fls233666 (赞：25)

分析题目，我们得出此题的解决方案：**算要修改的数的数量就是算出不在最长上升子序列中的数的数量**，所以要算出最长上升子序列长度 $L$，然后把数字总数 $n$ 减去 $L$，就得到答案。即：

$answer=n-L$

有了这个，下面我们来讲如何正确求最长上升子序列：

暴力方案：

记 $sl(i)$ 表示以第 $i$ 个数字为结尾的最长上升子序列，$a_i$ 表示原序列中的 $i$ 个数。

1. 把 $sl(i)$ 赋值为 $1$（因为对于 $a_i$ 本身可以视为一个长度为 $1$ 的最长上升子序列）；
2. 遍历 $a_i$ 之前的所有数字（不包含 $a_i$）
3. 如果找到一个位置 $j$ 满足 $a_j<a_i$ 并且 $sl(j) \ge sl(i)$，执行 $sl(i)=sl(j)+1$；
4. 更新变量 $ans$ ：即 $ans= \max(ans,sl(i)) $；
5. 遍历从 $a_0$ 到 $a_{n-1}$，重复执行上述 $1$ 到 $4$ 步内容；
6. 输出 $n-ans$。

代码如下：

```cpp
//代码完全参照上述步骤实现
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
	int n,ans=0;
	scanf("%d",&n);
	int a[n],sl[n];
	for(int i=0;i<n;i++)
		scanf("%d",&a[i]);
                         
	for(int i=0;i<n;i++){
		sl[i]=1;
        for(int j=0;j<i;j++)
            if(a[j]<a[i]&&sl[j]>=sl[i])
                sl[i]=sl[j]+1;
        ans=max(sl[i],ans);
	}
  
	printf("%d",n-ans);
	return 0;
}
```

时间复制度：$O(n^2)$

$50$ 分 get!

优化方案：

记数组 $sa$ 为最长上升子序列，$ans$ 为最长上升子序列长度，$a_i$表示原序列中的第 $i$ 个数。

1. 初始化：$ans=1,sa_0=a_0$；
2. 循环遍历数组 $a$；
3. 对于每个 $a_i$，如果有 $sa_{ans}<a_i$，就把 $ans$ 加一，然后在 $sa_{ans}$ 中存入$a_i$，**否则，用 STL 中的lower_bound二分查找第一个大于等于$a_i$的数的位置，进行替换**；
4. 输出 $n-ans$。

因为 STL 二分查找函数的时间复杂度为 $O( \log(n))$。

所以时间复杂度为：$O(n \log(n))$。

另外 $50$ 分 get!

------------

#### 2019年6月1日更新：

关于此算法，求出来的长度是没有问题的。但是存数列的数组$sa$，存的并不一定是正确的最长上升子序列。

比如这个数据：

	6
    1 4 3 7 5 2
    
更新到第五个数时，数组$sa$内存的答案为：1 3 5。

加进来一个 $2$。

于是数组 $sa$ 变成：1 2 5。

显然，这就不是最长上升子序列的答案了。但是最长上升子序列的长度 $ans$ 还是正确的，所以即使此题中遇到这样的数据，程序还是能 AC。


------------

#### 2020年2月14日更新：

修了修题解的排版格式问题。

顺带补充一下 STL 中二分查找函数的用法：

在 STL 中常用的二分查找函数有三个：

	binary_search(开始位置,结束位置,查找值);   //查找某个值是否存在，返回 bool 值
    lower_bound(开始位置,结束位置,查找值);   //查找第一个大于等于查找值的数，返回指针地址
    upper_bound(开始位置,结束位置,查找值);   //查找第一个大于查找值的数，返回指针地址
    //返回的指针地址是可以换算成数组下标的，具体看使用范例
    
我们拿 lower_bound 做使用范例：

	int tmp1=lower_bound(a,a+n,x)-a;   //在数组 a 中 [0,n) 的范围内查找值 x 返回的指针地址减掉数组起始的指针地址就得到了数组下标，结果存在 tmp1 中
    int tmp2=lower_bound(a+1,a+1+n,x)-a;  //在数组 a 中 [1,n] 的范围内查找值 x ,结果存在 tmp2 中
    int tmp3=lower_bound(a.begin(),a.end(),x)-a.begin();   //对于STL容器查找时的使用示范
    //注意，执行查找时，查找的区间必须是从小到大排好序的！
    
上述函数复杂度都是 $O( \log(n))$。

---------

完整 AC 代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
    int n,ans=1;
    scanf("%d",&n);
    int a[n],sa[n];
    for(int i=0;i<n;i++)
        scanf("%d",&a[i]);
    sa[ans]=a[0];
    for(int tz,i=1;i<n;i++){
        if(sa[ans]<a[i]){
            ans++;
            sa[ans]=a[i];		
        }else{
            tz=lower_bound(sa,sa+ans,a[i])-sa;
            //这里用tz临时存储找到的下标
            sa[tz]=a[i];
        }
    }
    printf("%d",n-ans);
    return 0;
}

```


---

## 作者：hsfzLZH1 (赞：18)

此题所求为一个数列的最长递增子序列，我们可以用DP思想来考虑求解这个问题。

O(N^2)算法：定义f[i]表示以位置i为结尾的LIS长度。边界条件为f[0]=1，状态转移方程为

f[i]=max(f[i],f[j]+1)(j=1...i-1 a[i]>=a[j])

我们观察到，f[i]的值由前面的数字推得，所以我们只要从前往后转移，就可以保证每次使用的数字都是已经确定的值。

最后的答案即为f数组中的最大值。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
int n,a[maxn],f[maxn],ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",a+i);
    for(int i=1;i<=n;i++)f[i]=1;
    for(int i=2;i<=n;i++)for(int j=1;j<i;j++)if(a[i]>=a[j])f[i]=max(f[i],f[j]+1);
    for(int i=1;i<=n;i++)ans=max(ans,f[i]);
    printf("%d\n",n-ans);
    return 0;
}
```
O(N^2)代码（只能得50分）：

我们发现，O(N^2)时间复杂度的算法不能满足我们在这题的性能需求，所以我们需要使用O(N\*log N)时间复杂度的解法

考虑两个数a[x]和a[y]，若x<y且f[x]==f[y]，那么在转移的过程中，选择a[x]更有潜力，可以获得最优的值，所以当f数组的值一样时，应选择最小的数。

按照f[i]==k分类，记录f[i]==k的所有i的最小值，f有两个特点：

1)f[i]在计算过程中单调不升

2)f数组是有序的，f[i]<=f[i+1]

根据这些性质，可以方便地求解：

1)设当前求出的LIS长度为ans（初始值为1），当前元素为a[x]

2)如果a[x]>f[ans]，直接加入f数组的末尾，且ans++；否则在f数组中二分查找，找到第一个比a[x]小的数字f[k]，f[k+1]=a[x]，这样做保证a[x]<=f[k+1]（根据性质1，2）

3)最后的ans即为答案

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
int n,a[maxn],f[maxn],ans,cur;
int bs(int k,int l,int r)
{
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(k>=f[mid])l=mid+1;
        else r=mid;
    }
    return l;
}
int main()
{
    scanf("%d",&n);
    for(register int i=0;i<n;i++)scanf("%d",a+i);
    f[1]=a[0];
    for(register int i=1;i<n;i++)
    {
        if(f[ans]<a[i])cur=++ans;
        else cur=bs(a[i],1,ans+1);
        f[cur]=a[i];
    }
    printf("%d\n",n-ans);
    return 0;
}
```

---

## 作者：1433223o (赞：9)

###  算法：二分
### 分析：
一道十分基础的二分，求最长上升子序列长度len，n-len即为答案。
### 代码：
```
# include <bits/stdc++.h>
using namespace std;
int n, a[1000000], f[1000000],ans;
int find(int l, int r, int x)
{
    int p = 0;
    while (l < r)
    {
        int mid = (l + r) / 2;
        if (x > f[mid]) 
        {
            l = mid + 1;
            p = mid;
        }
        else r = mid;
    }
    if (!p) p = l;else p++;
    return p;
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    f[1] = a[1];
    ans=1;
    for (int i = 2; i <= n; i++)
    {
        if (a[i] > f[ans]) 
        {
            f[++ans] = a[i];
            continue;
        }
        int j = find(1,ans+1,a[i]);
        f[j] = a[i];
    }
    printf("%d", n - ans);
}
```


---

## 作者：jijidawang (赞：9)

- [博客区体验](https://www.luogu.com.cn/blog/writeSTL/solution-p3902)

## 前置知识

1. LIS - 最长上升子序列；
2. STL 中的 `lower_bound`。

## 算法分析

因为数字可以修改为实数，又因为实数集合不可数，所以说对于任意两个实数 $a,b$ 都存在一个实数 $k$ 满足 $a<k<b$，更何况整数呢。

所以求一下 LIS 再用 $n$ 减去 LIS 序列长度就是答案QAQ。

- $50\%$ 数据可以 $\mathcal O(n^2)$ 过掉。

- $100\%$ 数据是 $10^5$ 级别的，要用 $\mathcal O(n\log n)$ 算法，用 `lower_bound` 函数~~水过~~即可。

### Code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100001;
int a[N],dp[N];
int main()
{
    int n,ans=1;
    scanf("%d",&n);
    for (int i=0;i<n;i++) scanf("%d",a+i);
    dp[ans]=a[0];
    for (int tmp,i=1;i<n;i++)
	{
        if (dp[ans]<a[i]) ans++,dp[ans]=a[i];       
        else{tmp=lower_bound(dp,dp+ans,a[i])-dp;dp[tmp]=a[i];}
    }
    printf("%d",n-ans);
    return 0;
}
```
## 更深一步

那么，如果数字只能修改为整数该怎么办呢？

如果最后的数列是非严格单调递增的，我们可以用 LIS 求解，但是题目是严格单调递增的TAT。

考虑问题转换。

我们知道，对于任意 $a,b\in \mathbb{Z},a<b$，有 $a+1\le b$，当且仅当 $a=b-1$ 时等号成立。

对于序列 $A_1,A_2,\dots,A_n$，要满足$A_1<A_2<A_3<\dots<A_n$。

转换一下：$A_1+(n-1)\le A_2+(n-2)\le\dots\le A_n$

预处理一下再求 LIS 即可。

---

## 作者：于丰林 (赞：4)

一道最长上升子序列的模板题（就是双倍经验的题），这里还是从头来好好讲一遍吧。。。

对于这道题，显然：如果要改动最小，那么只要改掉除了最长上升子序列以外的数就行了，答案就是总长-最长上升子序列长度。

什么是最长上升子序列？

简单来说，最长上升子序列就是求一个序列中最长的连续上升的字串长度，题目说的是严格递增，但是数据大于和大于等于都过了。。。强烈要求加强数据qaq

一看数据范围，显然n^2一定会超时，那么考虑一种nlogn的做法

我们设low[i]表示序列长度为i最小的结尾元素是多大。

那么我们从头开始扫，对于每一个数，只有两种情况：（对于这道题）

1.大于目前low数组的最后一个元素，那么显然我们应该将它加入到low数组中，数组长度加1

2.小于等于，那么这个元素也不是一无是处，我们就用它来更新low数组的值，我们找到第一个比他大的数，那么长度为该数下标的最长上升子序列末尾的最小值就是这个新元素啦！

有人可能还是会说：

你这个在极端数据面前还是n^2啊。。。

我说：

你会二分查找吗？。。。

最后，附上本题代码：

```cpp
#include<cstdio>
using namespace std;
int a[100005],low[100005],ans;
int dfs(int*a,int r,int x)
{
    int l=1,mid;
    while(l<=r)
    {
        mid=(l+r)>>1;
        if(a[mid]<=x)
        {
            l=mid+1;
        }
        else
        {
            r=mid-1;
        }
    }
    return l;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    {
        scanf("%d",&a[i]);
    }
    low[1]=a[1];
    ans=1;
    for(int i=2; i<=n; i++)
    {
        if(a[i]>low[ans])
        {
            low[++ans]=a[i];
        }
        else
        {
            low[dfs(low,ans,a[i])]=a[i];
        }
    }
    printf("%d",n-ans);
    return 0;
}
```


---

## 作者：huhuhuhaha (赞：4)

在一坨紫/蓝中间找到一个橙。。。激动。。。

需要修改多少个数，那么如果知道有多少个数是不变的，就可以轻松地得出结论了。

而求多少个数不变，就是求多少个数满足严格递增，就是最长上升子序列。

用$O(n log n)$的方法求解即可，要用二分。

这题C++的代码用库可以写的很简单。。。。

```
var
	n,i,t:longint;
	a,s:array[-1..100000] of longint;
function find(l,r:longint):longint;
var mid:longint;
begin
	while l<=r do begin
		mid:=(l+r) shr 1;
		if (s[mid]>a[i])and(s[mid-1]<=a[i]) then exit(mid);
		if s[mid]<a[i] then l:=mid+1 else r:=mid-1;
	end;
	exit(l);
end;
begin
	read(n);
	for i:=1 to n do read(a[i]);
	t:=1;
	s[1]:=a[1];
	for i:=2 to n do
		if a[i]>s[t] then begin
			inc(t);
			s[t]:=a[i];
		end
		else s[find(1,t)]:=a[i];
	write(t);
end.
```

---

## 作者：zhylj (赞：3)

通过观察我们发现（没要求不能弄成非整数）

```要修改的数=序列长度-最长上升子序列```
故用最长上升子序列的程序即可，但是普通的程序会超时：
```cpp
```cpp
会TLE5个点，故采用优化版的最长上升子序列
优化思路：
原先在每次计算的时候都使用b数组记录**包含a[i]的最长上升子序列**
现在b数组记录**最长子序列长度为i的最小值**
为什么要这样记录呢？可以发现，如果有3个数4、5、6，假设包含他们的最长上升子序列长度均为4，那么
b[i]显然存入4更加优秀。（因为对于5和6来说，4能成为更多序列的一部分）
接下来的每个数就在b[i]里面寻找第一个比它大的值然后替换即可。
此时b数组长度即为最长上升子序列。
```cpp
```cpp
```
#include<bits/stdc++.h>
using namespace std;
int n,a[10000000],b[10000000]={0},maxn,zmax;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i];
    b[n-1]=0;
    for(int i=n-1;i>=0;i--)
    {
        maxn=-1;
        for(int j=i+1;j<n;j++)
            if(b[j]>=maxn&&a[i]<=a[j]) maxn=b[j];
        if(maxn!=-1) b[i]=maxn+1;
        else b[i]=1;
    }
    zmax=-1;
    for(int i=0;i<n;i++)
        if(b[i]>zmax) zmax=b[i];
    cout<<n-zmax<<endl;
    return 0;
}
#include<bits/stdc++.h>
using namespace std;
int n,a[1000000],b[1000000]={0},zmax=0;
int main()
{
    cin>>n;
    for(register int i=0;i<n;i++)   //register加快速度
        cin>>a[i];
    for(register int i=0;i<n;i++)    //依次判断每个数
        for(register int j=zmax;j>=0;j--)   //倒序查找，找到第一个比它小的，此时j+1即为正序第一个比它大的值。
            if(b[j]<a[i])    //寻找比第一个a[i]小的值
            {
                if(j==zmax) zmax++;   //如果需要填入新的值（扩展b数组），子序列长度+1
                b[j+1]=a[i];   //操作
                break;   //退出循环
            }
    cout<<n-zmax<<endl;    //输出结果
    return 0;
}
显然b数组一定是有序的，还可以在此基础上继续优化（使用二分查找），但是由于数据太水，故不做优化，即可AC。
```cpp

---

## 作者：comfort (赞：1)

此题是一个很明显的一维dp，有严格递增可知。那么具体怎么做呢？其实就是一个整体减去最长不下降子序列，而且令人开心的是，此题允许实数的存在，所以根据整数的稠密可知，最长不下降子序列即可。


还是列一下四要素吧：

数组  g[i] 表示最长上升子序列的长度为i时的结尾最小值

答案：n-sz。

转移方程：int pos = lower_bound(g, g + sz + 1, a[i]) - g;

           g[pos] = a[i];
        
           sz = max(sz, pos);

初值：0即可

在介绍一下lower_bound，通俗的来说（二分），就是找一个数在一个数组中按升序排列第一个大于等于其的数字（也可以用cmp）

具体形式是这样的

lower_bound（数组开始，数组结尾，查找的数字，cmp）

只不过其返回的是一个地址，一般要减去它。

贴一下代码吧

```
#include<bits/stdc++.h>
using namespace std;
int n,sz,a[100010],g[100010];
int main()
{
    cin>>n;
    for(long long i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
    	int pos=lower_bound(g,g+sz+1,a[i])-g;
    	g[pos]=a[i];
    	sz=max(sz,pos);
	}
    cout<<n-sz;
    return 0;
} 

```

---

## 作者：屈ll子 (赞：1)

//题目显而易见是要求最长上升序列，而且只要求输出最长上升序列的长度，所以用一个f数组，来存长度为i的最长上升序列的最优的情况。举一个例子。
   3 7 43 5 1 46
先将f数组附为极大值，然后开始改，从3开始，以3结尾的最长上升序列长度为1，所以f[1]=3,
然后到7，以7结尾的最长上升序列长度为2，所以f[2]=7,
然后是43，以43结尾的最长上升序列长度为3，所以f[3]=43,
到5，以5结尾的最长上升序列长度为2，而且5比7小，从而将f[2]改为5,而后同理将f[1]=1,将f[4]=46.这么一来f数组不为极大值的内容的长度就为最长的上升序列。

这就是这种思路的大概想法，那么如何将5放进数组呢？跑循环是一种较为简单的思路，但代码麻烦，
所以我用的是lower_bound()函数，返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value 的值 [1]。该函数为C++ STL内的函数。 （这是百度说的，大家自行理解） emmmmmmmm其实我这个学的并不是很好，关于这个函数大家可以自己理解一下。大家直接看代码吧。



```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<vector>
using namespace std;     //前面这些应该没什么
const int maxn=1000000; //无脑开数组
int f[maxn];
int n;
int main()
{
    cin>>n;
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)
    {
       int x;   
       cin>>x;    //因为每个数据只会用一次，所以不需要存数据，直接读入后跑，求出来他在f数组里的位置
       *lower_bound(f+1,f+n+1,x)=x; //如果这个数比之前的数小,用lower_bound()函数找到它适合的位置将这个数放进去
    }
    cout<<n-(lower_bound(f+1,f+n+1,f[0])-f-1);    //再用lower_bound()函数找出f数组里第几个没有被改变，减去1就是最长递增序列的长度。用n减去他就是要改变的数字的数目。
    //system("pause");
    return 0;
}  
      
      
      
//萌新的处女题解，大佬轻喷。      
      
```



---


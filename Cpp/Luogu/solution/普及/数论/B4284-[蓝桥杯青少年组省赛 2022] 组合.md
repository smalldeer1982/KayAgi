# [蓝桥杯青少年组省赛 2022] 组合

## 题目描述

某商店将一种糖果按照数量打包成 $N$ 和 $M$ 两种规格来售卖（$N$ 和 $M$ 为互质数，且 $N$ 和 $M$ 有无数包）。这样的售卖方式会限制一些数量的糖果不能买到。现在给出 $N$ 和 $M$ 的值，请你计算出最多不能买到的糖果数量。


## 样例 #1

### 输入

```
3 5```

### 输出

```
7```

# 题解

## 作者：xuyixuan_123 (赞：3)

## 思路：
**塞瓦维斯特定理**
> 已知 $a$ 和 $b$ 为大于1的正整数，且 $\gcd(a,b)=1$ ，则使不定方程 $ax + by=C$ 不存在非负整数解的最大整数为 $C=a \times b − a − b$。

于是就有了这个公式：
 $$n \times m − n − m$$ 
当然，我们有了公式还不行，还得有证明。
## 证明:
- 我们先来证明 $a \times b - a - b$ 一定不能被取到。利用反证法，我们假设存在 $x,y \ge 0$ 满足 $ax + by=a \times b - a - b$ 。我们将 $ab$ 除到左边来，即 $a(x + 1) \div ab + b(y + 1) \div ab=1$ ，在消一下即可得到 $(x + 1) \div b+(y + 1) \div a=1$ 。这与我们假设中的 $a(x + 1)+b(y + 1)=ab$ ， $a \ge 0,b \ge 0$ 矛盾。因此，假设不成立，即不存在 $x,y \ge 0$ ，满足 $ax + by=a \times b - a - b$ 。
- 接下来，我们需要证明当 $C>a \times b - a - b$ 时， $ax + by=C$ 一定存在非负整数解。考虑到 $ax + by = C$ 可以通过扩展欧几里得算法求解，而扩展欧几里得算法可以在 $\gcd(a,b)=1$ 的情况下找到 $ax + by = \gcd(a,b)$ 的整数解。由于 $a$ 和 $b$ 互质，我们可以找到 $ax+by=1$ 的整数解。因此，对于任何大于 $a \times b - a - b$ 的 $C$ ，我们都可以通过将 $ax + by = 1$ 的解乘以适当的系数来找到 $ax + by = C$ 的非负整数解。

>综上所述，我们已经证明了塞瓦维斯特定理（不定方程）：对于互质的正整数 $a$ 和 $b$ ，不定方程 $ax+by=C$ 不存在非负整数解的最大整数 $C$ 等于 $a \times b - a - b$。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
	cin>>n>>m;
	cout<<n*m-n-m;
	return 0;
}
```

---

## 作者：Make_China_Great (赞：3)

## 思路

题目说将一种糖果按照数量打包成 $N$ 和 $M$ 两种规格来售卖（$N$ 和 $M$ 互质，且 $N$ 和 $M$ 有无数包），让我们求出最多不能买到的糖果数量。

我看了大家的几篇题解，大多都是套用那个公式的，所以我在这里提供一个动态规划的做法。

1. 建立一个布尔类型的数组 $dp$。作用是什么呢？作用就是 $dp_i$ 表示是否可以用题目中提到的“组合”来得到数量为 $i$ 的糖果。

1. 对于每个数，检查 $i-n$ 或者 $i-m$ 它呢是能组成，如果满足就把这个位置标记为可以组成。

1. 最后看看最大的是哪一个就可以了！

转移方程：

如果 $i\ge n$ 且 $ dp_{i-n}\ne 0$ 那么 $dp_i=1$。

如果 $i\ge m$ 且 $dp_{i-m}\ne 0$ 那么 $dp_i=1$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, t, maxx;
bool dp[20005];
int main() {
	cin >> n >> m;
	dp[0] = true;
	for (int i = 1; i <= 2 * n * m; ++i) {
		if (i >= n && dp[i - n]) dp[i] = true;
		if (i >= m && dp[i - m]) dp[i] = true;
	}
	for (int i = 2 * n * m; i >= 1; --i) {
		if (!dp[i]) {
			maxx = i;
			break;
		}
	}
	cout << maxx << endl;
	return 0;
}
```

---

## 作者：Noah03 (赞：2)

### 分析

---

解决这道题需要用到塞瓦维斯特定理。

定理内容：设有 $a,b$ 两正整数互质，则不满足方程 $ax+by=c$（$x,y$ 均为整数）的最大正整数 $c$ 为 $a \times b-a-b$。

证明：首先，根据方程可以得到 $0 \le x \lt b$（若 $x \ge b$，则 $ax+by=a(x-b)+b(a+y)$）。如果 $y\ge0$，则 $c$ 一定是能被表示出来的，所以 $y$ 取 $-1$（$y$ 再减小就达不到最大了）。又因为 $c$ 取最大，所以 $x$ 取最大，即 $x=b-1$，得出结论 $c=ax+by=a(b-1)-b=a \times b-a-b$，证毕。

根据这个定理，可以得到答案就是 $a \times b-a-b$。

### 代码

---

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    scanf("%d %d",&n,&m);
    printf("%d\n",n*m-n-m);
    return 0;
}
```

代码十分简单，不作解释。

**The End.**

---

## 作者：__CJY__ (赞：1)

## 思路
### 塞瓦维斯特定理
>已知 $a,b$ 为大于 $1$ 的数，则 $\gcd(a,b)=1$，那么使不定方程 $ax+by=C$ 不存在非负整数解的最大整数 $C=a \times b-a-b$。

直接套用公式输出即可：
$$n \times m-n-m$$
这里就不证明了，想要深度学习请参考[这里](https://www.cnblogs.com/My-flurry/p/11610075.html)。
### 动态规划
这题一看就是典型 DP。

我们用 $f_i$ 表示是否可以组合成 $i$ 个糖果。显而易见的是，当 $f_{i-n}=1 \lor f_{i-m}=1$ 时，$f_i \gets 1$。

最后**从后往前**找到最大值就行了。

记住把 $f_0 \gets 1$。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;cin>>n>>m;
	cout<<n*m-n-m;
}
```
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10005;
bool f[maxn];
int n,m;
int main(){
	cin>>n>>m,f[0]=1;
	for(int i=1;i<=n*m;i++){
		if((i>=n&&f[i-n])||(i>=m&&f[i-m])) f[i]=1;//要判断 i>=n 和 i>=m
	}
	for(int i=n*m;i;i--){
		if(!f[i]){cout<<i;return 0;}
	}
}
```

---

## 作者：huxuanrui19 (赞：1)

# B4284题解
[题目传送门](http://luogu.com.cn/problem/B4284)

这又是一道原题 [原题传送门](https://www.luogu.com.cn/problem/P3951)
## 题目大意
给定两个素数 $a$ 和 $b$，保证 $\gcd(a,b)=1$，求出最大的 $c$ 使得不定方程 $ax + by = c$ 无非负整数解。

### 思路
这里就是~~著名的~~塞瓦维斯特定理：
>对于已知 $a$ 和 $b$ 为大于 $1$ 的正整数，$\gcd(a,b)=1$，使不定方程 $ax + by = c$ 无非负整数解的最大整数 $c$ 为 $ab−a−b$ 。
### 证明

证明分为三个部分：

第一部分：证明 $ab - a - b$ 无解。

假设存在非负整数解 $(x,y)\geq 0$ 使得：
$ ax + by = ab - a - b $
整理得：
$ a(x + 1) + b(y + 1) = ab $

由于 $a$ 与 $b$ 互素，可得：
$$\begin{align*}
a \mid (y + 1) &\Rightarrow y + 1 = ka \quad (k \geq 1) \\
b \mid (x + 1) &\Rightarrow x + 1 = \ell b \quad (\ell \geq 1)
\end{align*}$$

代入原式：
$ a(\ell b) + b(ka) = ab $

$ \ell ab + k ab = ab $

$ \ell + k = 1 $

这与 $\ell, k \geq 1$ 矛盾。因此 $c = ab - a - b$ 无解。

___

第二部分：证明所有 $c > ab - a - b$ 都有解。

设 $c > ab - a - b$。

因为 $\gcd(a,b)=1$，存在整数解 $(x_0,y_0)$ 

满足：
$ ax_0 + by_0 = c$

通解可表示为：

$$\begin{align*}
x = x_0 + bt \\
y = y_0 - at \\
\end{align*}$$

其中 $t$ 为任意整数。

取适当的 $t$ 使得 $0 \leq y = y_0 - at < a$（即取 $t = \lfloor y_0/a \rfloor$）。

此时：
$ ax = c - by > ab - a - b - b(a-1) = -a $

因为 $ax > -a$ 且 $a>0$，故 $x \geq 0$。
因此 $(x,y)$ 是非负整数解。

___

第三部分：证明 $ab - a - b$ 是最大的无解数。

由第一部分知 $ab - a - b$ 无解，第二部分表明所有更大的整数都有解，因此 $ab - a - b$ 确为最大的无解整数。
## 代码
主体也只剩下这一句话了：
```cpp
cout<<a*b-a-b;
```
谢谢阅读。

---

## 作者：封禁用户 (赞：1)

题解：B4284 [蓝桥杯青少年组省赛 2022] 组合
---
这道题有一个公式，不用特判套公式即可，但是重要的是正确性证明。

---

### 思路
这是一道可以使用**鸡块定理**完成的题目。

定理如下：

对于两个互质的整数 $n$ 和 $m$（记 $n<m$），我们有:

- 无法表示为 $n$ 和 $m$ 的非负整数组合的最大可能数 $K=nm-n-m$。
- 也就是说，对于任意正整数 $x>K$，存在两个整数 $a,b$ 使得：$x=an+bm$。

于是我们就可以使用这样的代码解决问题：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n, m;
    cin >> n >> m;
    cout << n * m - n - m;
    return 0;
}
```
考场上，套公式即可，那么鸡块定理是如何得来的呢？

---

### 证明
我们利用初中学习到的“反证法”证明。

假设有两个非负整数 $a,b$ 使得：
$$
nm-n-m=an+bm
$$
等式两边同时加上 $n+m$ 得：
$$
nm=an+bm+n+m=n(a+1)+m(b+1)
$$
令 $A=(a+1),B=(b+1)$，所以：$$nm=nA+mB$$。

---

对上式两边模 $$n$$ 得  
$$ nm \equiv nA + mB \pmod{n} $$
由于 $$nA$$ 是 $$n$$ 的倍数，且 $$nm \equiv 0 \pmod{n}$$，所以
$$ mB \equiv 0 \pmod{n} $$

---
将 $$B = nk$$ 代入方程 $$nm = nA + mB$$ 中得  
$$ nm = nA + m(nk) = nA + nmk $$
整理后两边同时除以 $$n$$ 得 $$ m = A + mk $$。

---
由于 $$A = a+1$$ 为正整数，所以 $$A > 0$$，因此必须有 $$ m(1 - k) > 0 $$，即 $$ k < 1 $$。

然而，由于 $$k$$ 是正整数，故必有 $$k \ge 1$$。当 $$k = 0$$ 时，$$B = nk = 0$$，与 $$B = b+1 \ge 1$$ 产生矛盾；当 $$k \ge 1$$ 时，$$1 - k \le 0$$，同样与 $$A > 0$$ 产生矛盾。

因此不存在非负整数 $$a, b$$ 满足 $$ nm - n - m = an + bm $$。

这也证明了 $$nm - n - m$$ 为无法表示的最大整数。

所以我们可以通过这个公式来解决这道题目，上面给过的的就是代码。

---

## 作者：b__b (赞：1)

# [B4284](https://www.luogu.com.cn/problem/B4284)
~~[双倍经验](https://www.luogu.com.cn/problem/P3951)~~

塞瓦维斯特定理：
> 已知 $a$ 和 $b$ 为大于 $1$ 的正整数，$\gcd(a,b)=1$，则使不定方程 $ax+by=c$ 不存在非负整数解的最大整数 $c=ab-a-b$。

证明可看[这个大佬](https://www.cnblogs.com/My-flurry/p/11610075.html)。

```cpp
#include <cstdio>
int main() {
    int a, b;
    scanf("%d%d", &a, &b);
    printf("%d", a * b - a - b);
    return 0;
}
```

---

## 作者：TJB_LHY (赞：0)

# 思路

一道~~略有难度的~~数学题。因为 $n$ 和 $m$ 互质，所以 $k \times m \bmod n$（$k$ 为非负整数）是一定可以覆盖在模 $n$ 意义下大于 $m\times(n-1)$ 的整数的。所以只需要用完全背包求出小于等于 $m\times(n-1)$ 中不可以买到的糖果数量，取最大值即可。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
int n, m, k, maxn;
bool dp[10105];
int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n >> m;
	k = m * (n - 1);
	dp[0] = 1;	// 什么也没有，可以买到
	for (int i = n; i <= k; i++) dp[i] = dp[i] | dp[i - n];
	for (int i = m; i <= k; i++) dp[i] = dp[i] | dp[i - m];	 // 完全背包
	for (int i = 1; i <= k; i++)
		if (!dp[i]) maxn = max(maxn, i);  // 取最大值
	cout << maxn;
	return 0;
}
```

（本题有一定思考难度 ~~，大家请自主思考，锻炼思维~~）

---

## 作者：wangjue233 (赞：0)

# 题目背景与证明

我们可以把这道题看作 **Frobenius 硬币问题** 的一个简单例子。题目的意思是：店里有两种规格的糖果包装，分别为 $n$ 和 $m$（且二者互质），也就是说对于足够大的数，我们都可以使用它们来进行组合，但对于较小的数，有一些是凑不出来的。这种问题也叫鸡尾酒问题。

**结论**：对于两个互质的正整数 $n$ 和 $m$，最大的买不到的糖果数量是：
$
n \times m - n - m.
$

例如，当 $n = 2$ 且 $m = 3$ 时：
- $2$：买 1 包 2 个  
- $3$：买 1 包 3 个  
- $4$：$2+2$  
- $5$：$2+3$  
- $6$：$3+3$ 或 $2+2+2$  
但是 $1$ 凑不出来，这正好符合公式：  
$
2 \times 3 - 2 - 3 = 1.
$

---

## 理论证明

证明可以分为两部分：

### 1. 证明 $ n \times m - n - m $ 不可表示

**证明思路（反证法）：**

假设存在非负整数 $a,b$ 使得
$
n \times m - n - m = a \times n + b \times m.
$
两边同时加上 $a + b$ 得到：
$
n \times m = n \times (a+1) + m \times (b+1).
$
设定：
$
a' = a+1,\quad b' = b+1,
$
那么 $ a' \ge 1, b' \ge 1 $ 且等式变为
$
n \times m = n \times a' + m \times b'.
$
经过整理，可以写成
$
n (m - a') = m \times b'.
$

由于 $n$ 与 $m$ 互质，而 $n$ 不能整除 $m$（因此也不能整除 $ m \times b' $ 除非整除 $ b' $，就必定存在一个正整数 $k$ 使得

$
b' = k \cdot n.
$
将其代入原式后得到矛盾，从而证明了 $ n \times m - n - m $ 无法表示成 $ a \times n + b \times m $ 的形式。

> **补充说明**：另一种证明方法是利用数学归纳法证明所有大于等于 $(n-1)(m-1)$ 的数均可以表示，而由
> $$
> (n-1)(m-1) = n \times m - n - m + 1,
> $$
> 可推出最大不可表示数为 $ n \times m - n - m $。

### 2. 证明所有大于 $ n \times m - n - m $ 的正整数均可表示

根据经典的鸡尾酒证明，两个互质正整数 $ n $ 和 $ m $ 可表示所有大于或等于 $(n-1)(m-1)$ 的整数。而
$
(n-1)(m-1) = n \times m - n - m + 1,
$
所以任一大于 $ n \times m - n - m $ 的正整数都可以表示出来。

---

## AC CODE


```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    cout << n * m - n - m << endl;
    return 0;
}
```
时间复杂度：$O(1)$ 可以通过此题

---

## 作者：LINYUHENG2 (赞：0)

这个问题要从一个叫做弗罗贝尼乌斯硬币问题的问题说起。

主要来说，如果只有面值为 $a$ 和 $b$ 的两种硬币，且 $a$ 和 $b$ 互质，那么不能支付的最大金额是 $ab-a-b$。

证明：

设 $a<b$，答案为 $x$。

若 $x \equiv ma \ (\bmod b)(1 \le m \le b-1)$，即 $x = ma+nb(1 \le m \le b-1)$。

显然当 $n \ge 0$ 时 $x$ 可以用 $a,b$ 表示出来，不合题意。

因此当 $n=−1$ 时 $x$ 取得最大值，此时 $x=ma−b$。

显然当 $m$ 取得最大值 $b−1$ 时 $x$ 最大，此时 $x=(b−1)a−b=ab−a−b$。

因此 $a,b$ 所表示不出的最大的数是 $ab−a−b$。

那么，本题的答案就出来了，是 $N \times M -N-M$。

注：本题解中证明部分出自[该文章](https://www.luogu.com.cn/article/hth3bc8e)，如有侵权，请联系删除。

---


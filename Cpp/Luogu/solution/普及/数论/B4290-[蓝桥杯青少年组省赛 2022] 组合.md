# [蓝桥杯青少年组省赛 2022] 组合

## 题目描述

某商家将一种汤圆按照数量不同，分装成 $N$ 种规格来售卖。这样的售卖方式会限制一些数量的汤圆买不到。

例如：
- 当 $N=2$ 时，$2$ 种规格的汤圆分别装 $3$ 个和 $5$ 个，这种情况下限制了 $1$、$2$、$4$、$7$ 四种数量的汤圆不能买到。

给出 $N$ 及 $N$ 种规格的汤圆数量，请计算出有多少种数量的汤圆不能买到。如果有无限种数量的汤圆不能买到，就输出 $-1$。

## 样例 #1

### 输入

```
2
3 5```

### 输出

```
4```

# 题解

## 作者：yxszcxl (赞：2)

### 思路
---
这题暴力过不了，因此蒟蒻问了一下 DeepSeek 思路（但并没有复制粘贴）。

首先计算出所有汤圆规格的最大公约数 $pd$，若 $pd$ 等于 1，则说明所有规格数互质。知道这个条件可以干什么呢？举个例子，若输入是
~~~
2
2 4
~~~
2 和 4 它们并不互质，它们的最大公约数是 2，则只要不是 2 的倍数，如 5、7、11 都不行，这样的数有无数个，所以只要不互质，输出 -1 即可。

```cpp
int pd = num[0];
rep(i, 1, n) {
    pd = gcd(pd, num[i]);
}
if (pd != 1) {
    cout << -1;
    return 0;
}
```
在遍历过程中，初始的判断数组首项设为真，表示 0 个汤圆是可被组合的。当连续可以组合的汤圆数量达到最小规格便可以停止遍历。

AC Code
---

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define upto(i,a,b) for(int i=a;i<=b;i++)
const int N = 1e6 + 10;//上限
typedef long long ll;
using namespace std;
int num[30], n;
int cnt = 0, tmp = 0, maxcnt = 0;
bool check[N];

int gcd(int a, int b) {//辗转相除法求最大公约数
	if (b == 0) {
		return a;
	} else {
		return gcd(b, a % b);
	}
}

void input() {
	cin >> n;
	rep(i, 0, n) {
		cin >> num[i];
	}
	sort(num, num + n);
}

int main() {
	input();
	int pd = num[0];
	rep(i, 1, n) {
		pd = gcd(pd, num[i]);
	}
	if (pd != 1) {
		cout << -1;
		return 0;
	}
	memset(check, false, sizeof check);//初始化
	check[0] = true;
	rep(i, 1, N) {
		rep(j, 0, n) {
			if (num[j] > i)
				break;
			if (check[i - num[j]]) {
				check[i] = true;
				break;
			}
		}
		if (check[i]) {
			tmp++;
			if (tmp >= num[0]) {
				maxcnt = i - num[0];
				break;
			}
		} else {
			cnt++;
			tmp = 0;
		}
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：ryderyang (赞：1)

# 解题思路
设这 $n$ 个数的最大公因数为 $sum$。如果 $sum \neq 1$，就直接输出 $-1$，因为它们只能让我们买到 $sum$ 的倍数个汤圆。然后，我们可以用 $dp_i$ 表示是否能买到 $n$ 个汤圆。对于每一个 $1 \leq j \leq n$，如果 $dp_{i-a_j}$ 的值是 $1$，那么 $dp_i$ 的值也是 $1$。
# 最大上限
$i$ 最大是多少呢？是这 $n$ 个数的和。可以用反证法证明：假设存在一个数字 $num$ 不能被凑出来，那么 $num$ 的倍数肯定也凑不出来。但是这不适用于 $num \lt \sum_{i=1}^{n} a_i$ 的情况，因为不是每一个数字都用到了。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[21],maxn=1000000,sum,ans,cnt;
bool dp[1000005];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(i==1)
		sum=a[i];
		else
		sum=__gcd(sum,a[i]);
		cnt+=a[i];
	}
	if(sum!=1)
	{
		printf("-1");
		return 0;
	}
	dp[0]=true;
	for(int i=1;i<=cnt;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i<a[j])
			continue;
			if(dp[i-a[j]]==true)
			{
				dp[i]=true;
				break;
			}
		}
		if(dp[i]==false)
		ans++;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4290)

## 题目大意：

题目给了 $N$ 个数，分别为 $a_i$。

有一个集合 $m$，里面的元素无法用 $a_{j_1}+a_{j_2}+a_{j_3}+...$ 表示出来，且满足 $j_1 \le j_2 \le j_3 \le j_{...}$，求集合 $m$ 中的元素个数，如果有无数个输出 ```-1```。

## 思路：

注意到 $N \le 20$ 和 $a_i \le 100$，都非常小，考虑 DFS 暴力判断每个数是否可以被表示出来。

但是题目要求判断 $m$ 中的元素是否有无数个，因此需要进行分类讨论：

### 对于所有大于 $\sum_{k=1}^{N} a_k$ 的数：

计 $\sum_{k=1}^{N} a_k =S $，题目所给数 $a$ 中的最小值为 $w$，注意到只需要判断 $S+1$ 到 $S+w$ 之间所有数是否能被表示出来，只要这些数能被表示出来，那么大于 $S$ 的数都可以被表示出来。

显然的，对于任何一个大于 $S$ 的数，都可以用 $w \times l(l \ge 0)$ 和一个 $S+1$ 到 $S+w$ 之间的数的和来表示。

### 对于所有小于等于 $\sum_{k=1}^{N} a_k$ 的数：

通过数据范围发现 $\sum_{k=1}^{N} a_k \le 2000$，考虑暴力计算，注意判重剪枝和枚举剪枝即可。 

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int x;
int m[505];
int s=0;
int mina;
int flag=0;
bool f[2005];

void checker_dfs(int n,int la){
	if(f[n]==true) return ;
	if(flag==1) return ;
	f[n]=true;
	for(int i=1;i<=x;i++){
		if(n%m[i]==0){
			flag=1;
			return ;
		}
	}//由于每个数都有无数个，所以只要能被整除就相当于能被表示出来 
	for(int i=la+1/*剪枝*/;i<=x;i++){
		if(n>=m[i]) checker_dfs(n-m[i],i);
		if(n>=m[i]*2) checker_dfs(n-m[i]-m[i],i);
		f[n]=false;//判重 
	}
	
}

int main(){
	cin>>x;
	for(int i=1;i<=x;i++){
		cin>>m[i];
		s+=m[i];
	} 
	sort(m+1,m+1+x);
	mina=m[1];
	for(int i=s+1;i<=s+mina;i++){
		memset(f,false,sizeof(f));//清空
		flag=0;
		checker_dfs(i,0);
		if(flag==0){
			cout<<"-1";
			exit(0);
		}
	}//分讨1 
	int da=0;
	int mq=0;
	for(int i=1;i<=s;i++){
		memset(f,false,sizeof(f));//清空 
		flag=0;
		checker_dfs(i,0);
		if(flag==0) da++;
	}//分讨2，暴力判断 
	cout<<da;
    return 0;
}
```
[通过记录](https://www.luogu.com.cn/record/211832997)

---

## 作者：yuruilin2026 (赞：1)

## 一些闲话：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540)，不需要理由。
## 题意：
有 $n$ 个数，问这 $n$ 个数能仅通过加法不能凑出多少个数（每个数可以用多次）。
## 思路：
### 若没有无限个不能凑出的数：
假设目前的 $n$ 个数有有限种数凑不出来，那凑不出来的数一定小于等于这 $n$ 个数的和。\
反证法，假设存在一个数 $x$ 不能被凑出来，那 $x$ 的倍数也一定凑不出来，这就有无限个数凑不出来。\
这不适用于 $x$ 小于等于这 $n$ 个数的和的情况，因为有数没用到。\
这种情况可以 DP，对于每一个数，判断能否凑出来，最后凑不出来的就是答案。
### 若有无限个不能凑出的数：
这种情况最难，估计就是这道题被评黄的原因。
#### 二进制分解定理：
每个数都能被拆成若干个形如 $2^n$ 的数的和的形式。\
可以根据这一点来判断。
#### 判断方法：
因为每个数可以用无限次，所以 $2^n$ 是可以表示成 $2^m \times 2^{n-m}$ 的形式，不用在意较大的指数。\
若输入的所有数的按位或的结果的二进制位每一位都是 $1$，那就能凑出来大于等于这些数的和的所有数。\
因为较大的二进制位可以用较小的二进制位翻倍而来，所以不用在意较大的二进制位。
## AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int ans,a[25],n,m,num;
bool dp[2005] = {1};
bool check(int x){//判断是否二进制位全是 1 
	while(x != 0){
		if(x % 2 == 0) return 1;
		x /= 2;
	}
	return 0;
}
int main(){
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;++i) cin >> a[i];
	for(int i = 1;i <= n;++i) ans |= a[i],m += a[i];
	if(check(ans)){//ans存储按位或之后的结果 
		cout << -1;
		return 0;
	}
	for(int i = 1;i <= m;++i){//枚举现在判断的数 
		for(int j = 1;j <= n;++j){//枚举要用的数 
			if(i - a[j] >= 0) dp[i] |= dp[i - a[j]];//如果有可能转移 
		}
		if(dp[i] == 0) ++num;//如果不可能凑出来 
	}
	cout << num;
	return 0;
}
```

---

## 作者：YWT130508 (赞：0)

### 题目大意
给你 $n$ 个数字，要你求有几个数字不能由他们相加得到，每个数字可用无数次，无数个则输出 $-1$，是不是挺像完全背包的题目描述，可这题明显是要用到数论。
### 思路
学过多重背包二进制优化的就知道，给你 $2^n$ 到 $2^0$ 的数，就可以通过他们相加得到 $2^n - 1$ 以内的所有数，这也正是二进制优化的原理和逻辑，而这题则是任意自然数，我们其实也可以通过按位或的方式来求是否有无穷个不能得到的数，只要打一个循环按位或 $a_1 \sim a_n$，再判断它的二进制里面有没有 $0$，有则输出 $-1$。

接下来是有限个求数量的方法，通过分析不难发现，算不出来的数都小于 $a$ 数组的总和，所以有了范围，我们可以直接用完全背包的方法来求解。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[25];
bool f(int x){
	while(x){
		if(x%2==0)return 1;
		x/=2;
	}
	return 0;
}
int main(){
cin>>n;
int sum=0;
int k=0;
for(int i=1;i<=n;i++){
	cin>>a[i];
	sum+=a[i];
	k|=a[i];
}
bool flag=f(k);
if(flag){
cout<<-1;
return 0;
}
else{
	bool dp[2010]={0};
	dp[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=a[i];j<=sum;j++){
			dp[j]=dp[j]|dp[j-a[i]];
		}
	}
	int ans=0;
	for(int i=1;i<=sum;i++){
		ans+=dp[i]==0;
	}
	cout<<ans;
}
return 0;
}

```

---


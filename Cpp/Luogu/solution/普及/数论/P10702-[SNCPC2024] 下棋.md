# [SNCPC2024] 下棋

## 题目描述

LNC 喜欢所有 $k$ 进制下所有数位的乘积为自身因子的数。他称之为 LNC 数。例如：

当 $k = 10$ 时，$y = (36)_{10}$ 是 LNC 数，因为 $(3 \times 6) \mid 36$。

当 $k = 4$ 时，$y = (12)_4$ 是 LNC 数，因为转换成十进制后 $(12)_4 = (6)_{10}$，而 $(1 \times 2) \mid 6$。

当 $k = 2$ 时，$y = (1101)_2$ 不是 LNC 数，因为转换成十进制后 $(1101)_2 = (13)_{10}$，而 $0$ 不是 $13$ 的因子。

LNC 在和 LJJ 玩一个游戏，LJJ 给出 $x$ 枚棋子，然后 LNC 选定一个整数 $k$ ($k \geq 2$)。随后他们交替取走若干枚棋子，要求取走的棋子数量是 $k$ 进制意义下的 LNC 数。LNC 先手，先取完的获胜。两个人都绝顶聪明，故都会选择最优的策略。

LJJ 觉得这个游戏很不公平，他们一共玩了 $T$ 局游戏，对于每局游戏他给出的 $x$，他希望知道最小的 $k$ 使得 LNC 先手必胜。

## 说明/提示



当 $x=5$ 的时候，LNC 可以选择 $k=2$。$x=(5)_{10}=(101)_2$。

LNC 先手拿掉 $(11)_2$，此时 $x=(10)_2$，LJJ 只能拿走 $(1)_2$，LNC 拿走最后的 $(1)_2$ 获胜。

又因为 $k=2$ 已经不能再小了，所以最终答案为 $k=2$。 

## 样例 #1

### 输入

```
3
9
5
10
```

### 输出

```
2
2
3
```

# 题解

## 作者：MingDynasty (赞：6)

[题目链接](https://www.luogu.com.cn/problem/P10702)

# 题目思路：

考虑最优方式。如果 $LNC$ 取了 $y$ 个棋子，$LJJ$ 取 $k - y\bmod k$，可以让 $LNC$ 先手必赢。这也是最优的方案。换言之，如果当前的 $y$ 一次性不能被取完，那么此时的 $y$ 就是答案。由于 $3\leq x$，所以 $y$ 需要从 $2$ 开始枚举。      
于是这个题变成了求最小的 $k$，使得 $k \nmid x$ 且 $k$ 最小。

时间复杂度最高 $O(T \log x)$。

**需要注意 $x \le  10^{18}$。**

# Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int ans(int x){
	for(int i=2;i<=x;i++){
		if(x%i!=0) return i;
	}
	return -1;
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	int k;
	cin>>k;
	while(k--){
		int x;
		cin>>x;
		cout<<ans(x)<<'\n';
	}
	return 0;
}
```

---

## 作者：STA_Morlin (赞：4)

[题目](https://www.luogu.com.cn/problem/P10702)

## 思路简析

先局部地考虑，通过观察样例，大胆猜测所有奇数都是能被 $2$ 表示的。

下面是证明：

显然 $0$ 不是 $2$ 的因数，所以 $y$ 在二进制下必须全是 $1$，那么 $10$ 进制下的 $y$ 就是奇数。在二者都只能取奇数的情况下先手必胜。

Q.E.D.

通过以上证明可以扩展到，$k$ 进制下的 LNC 数一定不能被 $k$ 整除（注意是在 $10$ 进制下），原因如下：

具体是 $k$ 进制的 LNC 数的任何一位都不能是 $0$，而 $k$ 进制的数最低位不为零就一定不能整除 $k$。

所以当目前的棋子数 $o$ 能整除 $k$ 时，先手必败，你考虑先手取走了 $p_1\cdot k+a_1(1\leq a< k)$，那么剩下的就是 $(n-p_1)\cdot k +(n-a_1)$，后手取走一个部分使剩下的棋子数仍是 $k$ 的倍数，就仍保持了先手（你的对手）必败。

这样只要使输入的 $x$ 为因数 mex，就可以保证先手必胜。

## _CODE_
Time complexity：$\omega(T) \sim O(Tn)$
```cpp
#include <bits/stdc++.h>
namespace {
#define filein(x) freopen(x".in", "r", stdin)
#define fileout(x) freopen(x".out", "w", stdout)
#define files(x) filein(x), fileout(x)
using namespace std;
#define ll long long
#define db double

const int man = 1e5+10;
}

int T;
ll x;
int main () {
#ifndef ONLINE_JUDGE
    files("test");
#endif
    scanf("%d", &T);
    while (T --) {
        scanf("%lld", &x);
        for (int i = 2; i <= 203565; ++ i) 
            if (x%i) {
                printf("%d\n", i);
                break;
            }
    } return 0;
}

// ---
```

---

## 作者：xiezheyuan (赞：2)

## 思路

首先一个关键的观察，如果一个数是 $k$ 进制下的 LNC 数，则这个数在 $k$ 进制下的各数位，除了前导零外，不能包含其它的 $0$。一个特殊的情况就是末尾不能为 $0$。

假如先手时石子个数末尾为 $0$，则一定拿完后石子个数末尾非 $0$。而后手可以拿走末位个石子来使末位恢复到 $0$。如此操作，先手最后会遇到没有石子可以拿的局面。因此只要石子个数末尾为 $0$，则先手必败，否则先手必胜。

考虑解决原问题，我们发现只需要找到一个 $k$，使得 $n\not\equiv0\pmod{k}$，暴力从小到大枚举这个 $k$ 时间复杂度是低于 $O(\log n)$ 的。

时间复杂度上界为 $O(T\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int t; cin >> t;
    while(t--){
        int n; cin >> n;
        for(int x=2;;x++){
            if(n % x){
                cout << x << '\n';
                break;
            }
        }
    }    
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：dctc1494 (赞：2)

题目传送门

[P10702 [SNCPC2024] 下棋](https://www.luogu.com.cn/problem/P10702)

### 思考

如果 $k$ 是 $x$ 的一个因数，那么先手每次取石子的数量就不能是 $k$ 的倍数。假设先手取了 $n$ 个石子，后手就可以取 $k - n \bmod k$ 个石子。这个策略是可行的，并且可以证明其正确性。因此，先手处于劣势。

相反地，如果 $k$ 不是 $x$ 的因数，先手首次取 $x \bmod k$ 个石子，这样问题就转变成了之前讨论的情况，此时先手有必胜的策略。


### 时间复杂度

$O(t \log n)$

### AC 代码

```cpp
#include <bits/stdc++.h>

#define int long long // 不开 long long 见祖宗

using namespace std;

int t, n;

signed main() {
    cin >> t;
    while (t--) {
        cin >> n;
        for (int i = 2; ; ++i) {
            if (n % i) {
                cout << i << endl;
                break;
            }
        }
    }

    return 0;
}
```

---

## 作者：DeepSleep_Zzz (赞：1)

**begin**
# [P10702 题目传送门](https://www.luogu.com.cn/problem/P10702)
# 前置证明
在分析思路之前我们要先来证明一个东西：

关于一个数 $x$，若其在 $k$ 进制下末尾位为 $0$，则 $x$ 一定可以被 $k$ 整除。反之则不能。
  
证明如下：

$$令：x=(\overline{abcde})_k$$

转化为 $10$ 进制为：

$$a \times k^4+b \times k^3+c \times k^2+d \times k+e$$

若想要其为 $k$ 的倍数，不难发现要使 $e=0\ 或\ k$。

但是因为 $e$ 为 $k$ 进制数下的一位数字，所以 $0\le e\le k-1$，且 $e$ 为整数。

所以只有当 $e=0$ 时，$x$ 为 $k$ 的倍数。反之亦然。

# 题目分析

题意简洁明了，就不多赘述了。

这道题是一个明显的数论题（人话~~诈骗~~思维题）。

设：$x$ 为棋子个数，$k$ 为进制数。

接下来我们来分两个情况来讨论：

- $k \mid x$：
  
  显然不管 LNC 先手拿走多少枚符合数量要求的棋子，LJJ 都可以通过拿走一定量符合数量要求的棋子来维持剩余棋子的个数仍然是 $k$ 的倍数（你们可以自己去试验一下），即始终保持 $x$ 在 $k$ 进制下末尾位始终为 $0$。而这样 LNC 是必输的。
- $k \nmid x$：

  LNC 一定可以先拿走一定符合数量要求的棋子使剩余的棋子数量是 $k$ 的倍数（实践才能出真知不是吗）。从而将问题转化为上一种的情况。此时 LNC 是必赢的。

此时此刻，我们成功地将问题转化为了寻找第一个 $k$ 使 $k \nmid x$（那么现在这道题可以~~降红~~了）。

最后勉为其难地放一下简单得不能再简单的代码吧（其实好像纯数论题大部分都是这样的）。
# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
ll t,x;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>t;
    while (t--)
    {
        cin>>x;
        for (ll k=2;;k++)
        {
            if (x%k!=0)
            {
                cout<<k<<"\n";
                break; // 记得结束循环
            }
        }
    }
    return 0;
}
```
**end**

---

## 作者：ZHUSITAOcccccc (赞：1)

## 思路
因数问题。

如果 $k$ 为 $x$ 的因子，LNC 无论拿几颗棋子都没有必胜策略，所以不一定会获胜。

相反，如果 $k$ 不为 $x$ 的因子，那 LNC 先取 $x \bmod k$ 颗棋子，然后，LJJ 取 $m$ 枚棋子，LNC 取 $k - m$ 颗棋子，那 LNC 必胜无疑。

## 代码

因此，就可以写代码了。

代码仅供参考，禁止抄袭。


```cpp
#include <bits/stdc++.h>
#define int long long int
using namespace std;
inline int read() {
	register int x = 0, f = 1;
	register char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
inline void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}
int t, n, i;
main() {
	ios::sync_with_stdio(false);
	t = read();
	while (t--) {
		n = read();
		i = 2;
		while (1) {
			if (n % i) {
				write(i);
				puts("");
				break;
			}
			i++;
		}
	}
}
```

---

## 作者：lzh_ovo (赞：0)

# P10702题解

[题目传送门](https://www.luogu.com.cn/problem/P10702)


## 题目大意

题中给出了一个定义： LNC 数是在 $k$ 进制下所有数位的乘积为自身因子的数。主要内容即 LNC 和 LJJ 下棋，给出 $x$ 个棋子，求出符合 LNC 数的最小值并且还让 LNC 必胜。

## 题目思路

（看来一眼其他巨佬的题解，发现还是有几位巨佬和本蒟蒻的思路差不多）这道题其实并没有那么复杂，想通了之后就直接变成入门题。然后我们就可以开始列举了。假设 $k=2$，那么 $2$ 进制的数字必定没有 $0$ ，因为 $0$ 不是任何正整数的因数。那么十进制的 $y$ 就肯定是偶数。再假设 $k=3$，推一下。最后即可得出 $k$ 进制下的 LNC 数一定不能被 $k$ 整除。这样就只需要求出不能被 $x$ 整除的最小的 $k$ ，这个怎么求就不多说了，看代码吧。

## 上代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long k;
	cin>>k;
	while(k--){
		long long x;
		cin>>x;
        for(long long i=2;i<=x;i++){
    		if(x%i!=0){
                cout<<i<<endl;
                break;
            }
    	}
	}
	return 0;
}
```

---

## 作者：xiaowenxu_qwq (赞：0)

# 题目意思
给定初始棋子数 $n$，两位玩家轮流取棋子，每次取的棋子数量必须满足特定条件。我们需要找到最小的 $k$ 使得 LNC 有必胜策略。

# 思路

当 $k$ 是 $n$ 的因数时，LNC 无法直接取 $k$ 的倍数的石子，LJJ 可以通过特定策略获胜。当 $k$ 不是 $n$ 的因数时，LNC 可以通过取 $n \bmod k$ 个石子，将问题转化为 LJJ 无法必胜的局面。

# 解法

遍历 $k$ 从 $2$ 开始，找到第一个不整除 $n$ 的 
$k$。这个 $k$ 即为所求的最小值，确保 LNC 有必胜策略。

代码。
```cpp
#include <bits/stdc++.h>
#define int __int128
using namespace std;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}//快读
void write(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else write(x/10),putchar(x%10+'0');
}//快输
signed main()
{
    int t=read();
    while(t--){
        int n=read();
        for(int k=2;;k++){
            if(n%k!=0){
                write(k),printf("\n");
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：ridewind2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10702)

## 思路

如果 $x$ 是 $k$ 的倍数，那么先手每次取石子的数量就不能是 $k$ 的倍数。


$k$ 进制下的 LNC 数一定不能被 $k$ 整除。

直接从 $2$ 开始暴力枚举 $k$。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long t;
	cin>>t;
	while(t--){
		long long n;
		cin>>n;
		for(long long i=2;;i++){
            if(n%i!=0){
                cout<<i<<"\n";//输出答案 
                break;
            }
        }
	}
	return 0;
}
```

---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

定义在 $k$ 进制下各位数字乘积为自身因子的数为 LNC 数，现在有 $x$ 枚棋子，每次只能取 $k$ 进制下的 LNC 数枚的棋子，求使得先手必胜的最小 $k$ 值。

### 2. 思路

观察样例不难发现对于每组 $x$ 和 $k$，都有 $k\nmid x$，由此猜想当且仅当 $k\nmid x$ 时先手必胜。

证明如下：

当 $k\nmid x$ 时，先手可取走 $x \bmod k$ 枚棋子，且容易发现，当 $i<k$ 时，$i$ 一定是 $k$ 进制下的 LNC 数，这样不管后手拿走多少颗棋子，先手一定能使其回复到 $k\mid x$ 的情况，因而当最后 $x<k$ 时，先手可拿走全部棋子，先手必胜。

至此问题转化为求一个最小的 $k$ 使得 $k\nmid x$，暴力枚举即可。

### 3. 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,x;
signed main() {
	cin>>t;
	while(t--){
		cin>>x;
		for(int i=2;i<=x;i++){
			if(x%i!=0){
				cout<<i<<endl;
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：Erica_N_Contina (赞：0)

## 我的博客

更多相关（或者不相关）知识点快戳：[oi-beats](https://ntsc-yrx.github.io/oi-beats/site/)，[个人博客](https://ntsc.flowus.cn/)。

## 做法

说明：下文中 $n$ 为棋子总数，$x$ 为每一次取的数量。

首先我们可以知道：

$k$ 确定后 $x$ 可选的值也就确定了。

假设我们选定进制为 $k$，那么 $1\sim k-1 $ 都是可取的，$k$ 的倍数都是不可取的，其他数字未知。这启示我们答案的构造很可能和 $k$ 的倍数以及 $1\sim k-1$ 有关。

那么我们要让先手必胜，我们可以让 $k$ 为**非 $n$ 因数**（即让 $k$ 不是 $n$ 的因数）。这样先手取 $n\bmod k$，留给后手的就是 $k$ 的因数 $n'$。

此时后手必然不可全取。令后手取 $m$，分类讨论：

- $n'-m>k$，那么先手可以再次将剩余的棋子取到剩下的数量是 $k$ 的倍数。

- $n'-m<k$，那么先手接下来可以一次性取完。

现在我们以及找到了一组可行答案，那么怎么样证明最小的**非 $n$ 因数**就是答案呢？

很显然，如果 $k$ 是 $n$ 的因数，首先先手不可能一次性取完，必然留下 $n'$。此时后手就可以构造合法的方法，使得留给先手的棋子数量是 $k$ 的倍数个。

```C++
/*                                                                                
                      Keyblinds Guide
     				###################
      @Ntsc 2024

      - Ctrl+Alt+G then P : Enter luogu problem details
      - Ctrl+Alt+B : Run all cases in CPH
      - ctrl+D : choose this and dump to the next
      - ctrl+Shift+L : choose all like this
      - ctrl+K then ctrl+W: close all
      - Alt+la/ra : move mouse to pre/nxt pos'
	  
*/
#include <bits/stdc++.h>
#include <queue>
using namespace std;

#define rep(i, l, r) for (int i = l, END##i = r; i <= END##i; ++i)
#define per(i, r, l) for (int i = r, END##i = l; i >= END##i; --i)
#define pb push_back
#define mp make_pair
#define int long long
#define ull unsigned long long
#define pii pair<int, int>
#define ps second
#define pf first

// #define innt int
#define itn int
// #define inr intw
// #define mian main
// #define iont int

#define rd read()
int read(){
    int xx = 0, ff = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
		if (ch == '-')
			ff = -1;
		ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
      xx = xx * 10 + (ch - '0'), ch = getchar();
    return xx * ff;
}
void write(int out) {
	if (out < 0)
		putchar('-'), out = -out;
	if (out > 9)
		write(out / 10);
	putchar(out % 10 + '0');
}

#define ell dbg('\n')
const char el='\n';
const bool enable_dbg = 1;
template <typename T,typename... Args>
void dbg(T s,Args... args) {
	if constexpr (enable_dbg){
    cerr << s;
    if(1)cerr<<' ';
		if constexpr (sizeof...(Args))
			dbg(args...);
	}
}

#define zerol = 1
#ifdef zerol
#define cdbg(x...) do { cerr << #x << " -> "; err(x); } while (0)
void err() { cerr << endl; }
template<template<typename...> class T, typename t, typename... A>
void err(T<t> a, A... x) { for (auto v: a) cerr << v << ' '; err(x...); }
template<typename T, typename... A>
void err(T a, A... x) { cerr << a << ' '; err(x...); }
#else
#define dbg(...)
#endif


const int N = 2e5 + 5;
const int INF = 1e18;
const int M = 1e7;
const int MOD = 1e9 + 7;

/*
k确定后x可选的值也就确定了。


1~k-1  都是可取的
k的倍数都是不可取的
其他数字未知

 */

bool check(int x,int K){
	int res=1;
	int t=x;
	if(!x)return 0;
	while(x){
		res*=x%K;
		x/=K;
	}
	if(!res)return 0;
	return t%res==0;
}



void solve(){
	int n=rd;
	for(int i=2;i<=(int)3e5;i++){
		if(n%i){
			cout<<i<<endl;
			return ;
		}
	}

	cout<<-1<<endl;

}




signed main() {
    freopen("num.in","r",stdin);
    freopen("num.out","w",stdout);


    int T=rd;
    while(T--){
    	solve();
    }
    return 0;
}
```

---

## 作者：huanglihuan (赞：0)

### 思路

如果取 $k$ 为 $x$ 的因子即 $x \bmod k = 0$，那么先手拿不完所有棋子，则后手可以拿完，先手必输。

所以我们要使 $x \bmod k \ne 0$，模拟即可。

### 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main ()
{
	int T;
	cin >> T;
	while (T --)
	{
		int x;
		cin >> x;
		for (int k = 2;k <= 114514;k ++)
		{
			if (x % k != 0)
			{
				cout << k << endl;
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：宋怡芃 (赞：0)

### 题解：P10702 [SNCPC2024] 下棋

[题目传送门](https://www.luogu.com.cn/problem/P10702)

#### 分析一下：
如果 $k$ 是 $x$ 的一个因数，那么先手每次取棋子的数量绝对不可能是 $k$ 的倍数。如果先手取了 $n$ 个棋子，后手就可以取  $k-n \bmod k$  个棋子，就可以证明其正确性。所以，这时的先手处于劣势。

相反，如果这里的 $k$ 不是 $x$ 的因数，先手第一次拿了  $x \bmod k$  个棋子，这样问题就转变成了上面讨论的情况，此时先手必胜。

#### code：

```cpp
#include <bits/stdc++.h>
using namespace std;
//这里题目中的T和N超出了int范围，要用long long
long long T,N;
int main() 
{
    cin >> T;
    while (T--)
	{
        cin >> N;
        for (int i = 2; ; ++i) 
		{
            if (N % i) 
  			{
                cout << i << endl;
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：迟暮天复明 (赞：0)

如果选的 $k$ 是 $x$ 的因数，那么先手每次取的石子个数一定不能是 $k$ 的因数（见题目描述里第三个例子）。那么如果先手取了 $N$ 个石子，那么后手就可以取 $k-n\bmod k$ 个石子。不难证明这个东西一定是成立的。于是先手就输了。

同时，如果 $k$ 不是 $x$ 的因数，那么先手第一次取 $x\bmod k$ 个石子，问题就转化成了前面的情况，于是先手必胜。

---

## 作者：liuyi0905 (赞：0)

首先我们会发现，如果一个数 $a$ 是 $k$ 进制下的 LNC 数，那么 $a$ 在 $k$ 进制下末尾一定不为 $0$（任何数的因数都不包括 $0$）。

如果先手的棋子数量在 $k$ 进制下末尾是 $0$，此时肯定不能那完所有棋子，所以拿完棋子后末尾肯定会不为 $0$；此时后手就有可能选完所有棋子，若不能，则又可以选一些棋子使得选完后的棋子数量末尾是 $0$，此方案下先手必败。

所以，只要棋子数量在 $k$ 进制下末尾不为 $0$，则先手胜，否则后手胜。

因此，只需暴力找到一个最小的 $k$ 使得 $x$ 在 $k$ 进制下末尾不为 $0$，即 $x\bmod k>0$，时间复杂度肯定低于 $O(\log x)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using LL=long long;
int t;
int main(){
	cin>>t;
	for(LL x;t;t--){
		cin>>x;
		for(int i=2,f=0;!f;i++)
			x%i&&(cout<<i<<"\n",f=1);
	}
	return 0;
}
```
记得开 `long long`。

---


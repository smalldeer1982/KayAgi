# [GESP202412 八级] 排队

## 题目描述

小杨所在班级共有 $n$ 位同学，依次以 $1,2,\dots,n$ 标号。这 $n$ 位同学想排成一行队伍，其中有些同学之间关系非常好，在队伍里需要排在相邻的位置。具体来说，有 $m$ 对这样的关系（$m$ 是一个非负整数）。当 $m\geq 1$ 时，第 $i$ 对关系（$1\leq i\leq m$）给出 $a_i,b_i$，表示排队时编号为 $a_i$ 的同学需要排在编号为 $b_i$ 的同学前面，并且两人在队伍中相邻。

现在小杨想知道总共有多少种排队方式。由于答案可能很大，你只需要求出答案对 $10^9+7$ 取模的结果。

## 说明/提示

对于 $20\%$ 的测试数据点，保证 $1\leq n\leq 8$，$0\leq m\leq 10$。

对于另外 $20\%$ 的测试数据点，保证 $1\leq n\leq 10^3$，$0\leq m\leq 1$。

对于所有测试数据点，保证 $1\leq n\leq 2\times 10^5$，$0\leq m\leq 2\times 10^5$。

## 样例 #1

### 输入

```
4 2
1 3
2 4```

### 输出

```
2```

## 样例 #2

### 输入

```
3 0```

### 输出

```
6```

## 样例 #3

### 输入

```
3 2
1 2
2 1```

### 输出

```
0```

# 题解

## 作者：FJ_EYoungOneC (赞：13)

### 解题思路

当 $m = 0$ 时，即求解 $n$ 个同学排队的方案数：$A_n^n$，即 $n!$。

当 $m = 1$ 时，我们可以使用**捆绑法**，将两个同学打包，变为一个同学，那么方案数为 $(n - 1)!$。

那么本题转换为，将有特殊需求的同学进行捆绑之后，剩余的同学数量。

那么如何对每一条关系做处理？假设 $a$ 要在 $b$ 前面，那么我们可以使用两个数组进行标记，$r_a = b$，$l_b = a$，表示 $a$ 的右边是 $b$，$b$ 的左边是 $a$。当出现 $a$ 在多个人前面，或者是 $b$ 在多个人后面，则直接输出 $0$。

接下来我们考虑如何处理成环的情况，如样例三所示，$1$ 要在 $2$ 前面，且 $2$ 要在 $1$ 前面，可以成功通过我们上述处理。考虑用并查集维护每一个特殊处理的区间，当 $a$ 与 $b$ 为同一个区间时，则直接输出 $0$。

另外本题特别坑的地方在于，某条建议可能重复出现，如下样例：

```
2 2
1 2
1 2
```

那么我们可以进行特判出现过的情况，若 $r_a = b$ 且 $l_b = a$，则表示一出现过该关系，即 `continue`。

最后，如何判断一个是一个小团体，还是一个人呢？

可以用并查集，若当前点的祖先为自己，则算做一个人，这样一个团体仅会被算一次。

### AC_Code

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2e5 + 10, MOD = 1e9 + 7;

typedef long long LL;

int n, m;
int p[N];
int l[N], r[N];

int find(int x)
{
    if (x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; ++ i )
        p[i] = i;
    
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        if (r[a] == b && l[b] == a)
            continue;
        if (r[a] || l[b] || find(a) == find(b))
        {
            cout << 0 << endl;
            return 0;
        }
        r[a] = b, l[b] = a;
        a = find(a), b = find(b);
        p[a] = b;
    }
    
    int res = 1, k = 1;
    for (int i = 1; i <= n; ++ i )
        if (find(i) == i)
            res = (LL)res * k ++ % MOD;
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：N0_1 (赞：10)

### 思路
不难想到将每一条限制关系抽象成建立了一条 $a_i$ 指向 $b_i$ 的边。

令最后图的连通块数量为 $num$，则答案为 $num!$。

考虑判无解的情况：

令 $i$ 的入度为 $dep_i$，

- 有两条边指向了 $v$，即 $dep_v > 1$。
- $u, v$ 本身就属于同一个连通块。

注意可能有重边，需要去重。

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long LL;
const int N = 2e5 + 10;
const LL p = 1e9 + 7;

int f[N], inDep[N];

int find(int x) {
    return x == f[x] ? x : f[x] = find(f[x]);
}

bool inSame(int x, int y) {
    return find(x) == find(y);
}

bool isPar(int x) {
    return x == find(x);
}

void merge(int x, int y) {
    f[find(x)] = find(y);
}

map<pair<int, int>, int> ump;

int main() {
    vector<pair<int, int>> arr;
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) f[i] = i;
    for (int i = 1; i <= m; i++) {
        int a, b;
        cin >> a >> b;
        if (ump[{a, b}]) continue;
        ump[{a, b}] = 1;
        arr.emplace_back(pair<int, int>(a, b));
    }

    bool ok = 1;
    for (auto &it : arr) {
        if (!ok) break;
        int u = it.first, v = it.second;
        if (inSame(u, v)) ok = 0;
        inDep[v]++;
        if (inDep[v] > 1) ok = 0;
        merge(u, v);
    }

    if (!ok) cout << 0 << endl;
    else {
        int cnt = 0;
        for (int i = 1; i <= n; i++) cnt += isPar(i);

        LL ans = 1;
        for (int i = 1; i <= cnt; i++) ans = (ans * i) % p;
        cout << ans << endl;
    }

    // system("pause");
    return 0;
}

---

## 作者：LastKismet (赞：7)

# 前言
我可能是为数不多的初三还在打这个的蒟蒻了吧。

# 思路
这就是一道水题，因为题目中要求给出关系的两者前者必须在后者前并且相邻，不难发现符合条件的关系必须满足以下两点：
* 建图，则每个点的出入度最大不超过 $1$，也就是链式，才存在符合条件的排队方式。
* 图中不能存在环，否则前后顺序矛盾。

然后就没有然后了。

这样我们找出所有不符合条件的情况，下面考虑怎么统计个数。

不难发现，我们把所有点分成了一个个连通块，所有互相存在关系的点的相对位置都是固定的，我们可以把它们当作一个整体看待，也可以说成“缩点”。

缩完点之后就已经很傻了，直接找排列数即可，答案也就是 $n!$。这里的 $n$ 指缩完点之后的连通块数。

思路已经很详细。~~所以就懒得提供代码了。~~

---

## 作者：ZPB2011 (赞：4)

# 排队

## 前言

~~这次八级咋这么水啊……~~

之前代码有些错误在此谢罪,谢谢 lujiayi654321 & gfxym
 指出错误。

## 思路

我们可以根据题目给出的数据建个并查集。

考虑输出 $0$ 的情况：

- 如果一个连通块有环，则肯定无法成立，输出 $0$。
- 有两个入度。

结果为 $A_{cnt}^{cnt}$ （cnt 为连通块数量）。

## AC code

```cpp
#include <iostream>
#define int long long
using namespace std;

const int N = 2e5 + 5, mod = 1e9 + 7;

int fa[N], nxt[N], pre[N];

int find(int x) {
	return x == fa[x] ? x : fa[x] = find(fa[x]);
}

signed main() {
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++) fa[i] = i;
	for(int i = 1; i <= m; i++) {
		int a, b;
		cin >> a >> b;
		if(pre[b] == a || nxt[a] == b) continue;//重边
		if(pre[b] != 0 || nxt[a] != 0 || find(a) == find(b)) {//不合法
			cout << 0 << endl;
			exit(0);
		}
		fa[find(a)] = find(b);
		pre[b] = a;
		nxt[a] = b;
	}
	int cnt = 0;
	for(int i = 1; i <= n; i++) {
		if(find(i) == i) cnt++;
	}
	int mul = 1;
	for(int i = 1; i <= cnt; i++) mul = mul * i % mod;
	cout << mul << endl;
	return 0;
}
```

---

## 作者：Statax (赞：3)

## 前言

GESP 真是越出越水了啊，幸好后来没打了，~~真就是 CCF 骗钱呗。~~

~~没用并查集、图论但是更为【数据删除】的一种方法。~~

## 分析

一道非常简单的排列组合，这里使用捆绑法就可以轻松解决此题。

具体来说，算有多少个人具有连续的相邻关系，最后乘法原理。

### 注意事项：

最主要的就是判断无解：

1. 一个人后面有多个相邻关系。
2. 关系形成环。

上面的判断好了问题就迎刃而解了。

## 代码

时间复杂度 $O(n + m)$，空间复杂度 $O(n)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
constexpr int MAXN = 2e5 + 5;
constexpr int INF = 0x3f3f3f3f;
constexpr int MOD = 1e9 + 7;

int n, m;
int a[MAXN], b[MAXN];
int nxt[MAXN], cone[MAXN];

int calc(int x)
{
    int ans = 1;
    for (int i = 1; i <= x; ++i)
        ans = (ans * i) % MOD;
    return ans;
}

void Check()
{
    for (int i = 1; i <= n; ++i) {
        int j = i;
        while (nxt[j]) {
            j = nxt[j];
            if (j == i)
                puts("0"), exit(0);
        }
    }
}

signed main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        cin >> a[i] >> b[i];
        if (nxt[a[i]] && nxt[a[i]] != b[i])
            return puts("0"), 0;
        nxt[a[i]] = b[i];
    }
    Check();
    int cnt = n;
    for (int i = 1, st = 1; i <= n; ++i, st = i)
        while (!cone[st] && nxt[st])
            --cnt,
                cone[st] = 1, st = nxt[st];
    cout << calc(cnt) << endl;
    return 0;
}

```

---

## 作者：tomAmy (赞：2)

# P11380 [GESP202412 八级] 排队 题解

思路：

每次输入时与之前标记过的边矛盾，或形成环，则答案为 $0$。

否则统计连通块个数，求全排列数即阶乘。

考虑维护并查集即可。

代码：
```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;

const int mod = 1e9 + 7, N = 200005;
int f[N], p[N], q[N];

int find(int x)
{
	if (f[x] == x) return x;
	return f[x] = find(f[x]);
}

void merge(int x, int y)
{
	f[find(x)] = find(y);
}

int main()
{
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) f[i] = i;
	bool flag = true;
	while (m--)
	{
		int a, b;
		cin >> a >> b;
		if (p[b] == a || q[a] == b) continue; // 重边
		if (p[b] != 0 || q[a] != 0 || find(a) == find(b)) // 重边矛盾或形成环
		{
			flag = false;
			break;
		}
		merge(a, b);
		p[b] = a, q[a] = b;
	}
	if (!flag) cout << 0;
	else
	{
		int cnt = 0, ans = 1;
		for (int i = 1; i <= n; i++) // 求连通块个数
			if (find(i) == i)
				cnt++;
		for (int i = 1; i <= cnt; i++) // 求阶乘
			ans = (1ll * ans * i) % mod;
		cout << ans << endl;
	}
	return 0;
}
``````

有帮助记得点个赞~

---

## 作者：LG086 (赞：2)

看了一眼有了大致思路，再多一眼就爆炸了。

首先考虑 $m=0$ 时，答案就是 $n!$。在要求两人站一块，且先后顺序已经确定时，我们可以将他们融合为同一人。想到合并就想到并查集。根据样例，我们知道 $m$ 条关系间可能会有矛盾导致无解。那么无解情况有哪些？

1. 形式如既要满足 $a$ 在 $b$ 前，又要满足 $b$ 在 $a$ 前的情况。
2. 形式如 $a$ 和 $b$ 都要排在 $c$，且都和 $c$ 相邻的情况。
3. 形式如满足 $b$ 排在 $c$ 后，$c$ 在 $a$ 后，且 $a$ 在 $b$ 后的情况。

我们使用 $nxt_i$ 和 $fst_i$ 分别表示排在 $i$ 后的一个人与排在 $i$ 前的一个人。那么判断无解部分的核心代码如下：
```cpp
while(m--){
  cin>>u>>v;
  if(find(v)==u)return cout<<0,0;
  if(nxt[u]!=0 and nxt[u]!=v)return cout<<0,0;
  if(fst[v]!=0 and fst[v]!=u)return cout<<0,0;
  if(nxt[v]==u)return cout<<0,0;
  if(fst[u]==v)return cout<<0,0;
  nxt[u]=v;
  fst[v]=u;
  query(u,v);
}
```

其余部分代码很简单，在这里并不给出。

---

## 作者：chenxi2009 (赞：1)

# 思路
题目要求若干同学有相邻的前后顺序，显然有一下两种无解情况：要求一名同学前面同时是多名同学，以及后面是多名同学。这种情况我们在线保存一个同学前/后面有无同学以及同学的编号即可判断。

发现 3 号样例还给了一种情况，就是成环，对于这种情况我们可以使用一个并查集来表示一个点所属的链，集的根为最后面的一个同学，我们只需要判断有没有首尾相连即可，其他的情况被前面的判断涵盖了。

有解时，发现互相有关系的同学构成一条内部顺序固定的链，可以当做一个同学来看待，答案即同学数的阶乘。

时间复杂度 $O(m\alpha(n))$，$\alpha(n)$ 近似为一次并查集的复杂度。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long MOD = 1000000007;
int n,m,a,b,f[200001],cnt,nxt[200001],pre[200001];
long long ans = 1ll;
int find(int x){
	return x == f[x] ? x : f[x] = find(f[x]);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i ++) f[i] = i;//并查集初始化 
	for(int i = 1;i <= m;i ++){
		scanf("%d%d",&a,&b);
		if(nxt[a] && nxt[a] != b || pre[b] && pre[b] != a || find(b) == a){//a 后有不是 b 的数，或 b 前有不是 a 的数，或成环 
			ans = 0ll;
			break;
		}
		f[a] = b,nxt[a] = b,pre[b] = a;
	}
	for(int i = 1;i <= n;i ++) if(f[i] == i) cnt ++;//集根的数量就是并查集的数量 
	for(int i = 2;i <= cnt;i ++) ans = ans * i % MOD;//计算阶乘 
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：1)

# P11380 题解

~~GESP 真是越考越简单了。~~

## 思路

所有关系去重之后合并起来，如果有解，那一定会形成若干条链，这些链可以按照任意顺序互相拼接起来，设链的数量为 $k$，则方案数为 $A_k^k$，即 $k$ 个排列。

求合并后链的数量，可以用并查集维护，并查集内不同值的数量就是链的数量，将每一组关系的两个值所在的并查集合并即可。

最后考虑无解的情况。假设已有 A 指向 B，又有 C 指向 B，则无解。若 A 指向 B，A 又指向 C，也无解。若 A 和 B 已在同一个并查集，但之前尚不存在一组 A 指向 B 的关系，而现在 A 指向 B，则无解。

记 $L_i$ 表示 $i$ 指向了哪一个，$R_i$ 表示哪一个指向了 $i$。当不存在 $L_a$ 和 $R_b$ 且 $a,b$ 不在同一个并查集时，可以合并；否则如果不是与之前的某一组关系重复，则无解；再否则，可以合并。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define TIMESTAMP cerr<<fixed<<setprecision(3)<<clock()*1.0/CLOCKS_PER_SEC<<"s"<<endl;
#define _rep(i,a,b) for (int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for (int i=(a);i<=(b);c)
#define _rrep(i,a,b) for (int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for (int i=(a);i>=(b);c)
#define _iter(i,a) for (auto i=a.begin();i!=a.end();++i)
#define _graph(i,u) for (int i=h[u];~i;i=ne[i])
#define rint register int
#define LL long long
typedef pair<int,int> pii;

const int N=200005;
const int mod=1e9+7;

int n,m;
int p[N];
int L[N],R[N];
unordered_set<int> hs;

int find(int x) {
    return (p[x]==x)?p[x]:(p[x]=find(p[x]));
}

void merge(int a,int b) {
    p[find(a)]=find(b);
    L[a]=b,R[b]=a;
}

int main() {
    scanf("%d %d",&n,&m);
    _rep(i,1,n) p[i]=i;
    bool ok=true;
    while (m--) {
        int a,b;
        scanf("%d %d",&a,&b);
        if (!L[a] && !R[b] && find(a)!=find(b)) merge(a,b);
        else if (!(L[a]==b && R[b]==a)) ok=false;
        else merge(a,b);
    }
    if (!ok) {
        puts("0");
        return 0;
    }
    LL ans=1;
    _rep(i,1,n) hs.emplace(find(i));
    _rep(i,2,(int)hs.size()) ans=ans*i%mod;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Roy_2010 (赞：0)

# [GESP202412 八级] 排队
## 思路
观察这一题，我们会发现一个很有意思的性质，就是有限制的人们会构成一个顺序固定的连通块，可以看做一个人。\
那么问题就变成了如何求一些人的排列数，很简单，排列一下即可。\
问题来到如何判无解。\
有一些情况。\
首先，若有两人同时排在同一个人前或同一个人后，则无解。\
其次，若人们排成了一个首尾相连的环，则无解。这个可以用并查集。\
最后，有重边，注意去重。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MOD (1000000007)

int n,m,cnt=0;
struct Union_set{
	int fa[200050],sz[200050];
	Union_set(){
		for(int i=1;i<200050;++i){
			fa[i]=i;
			sz[i]=1;
		}
	}
	int Find(int x){
		if(x==fa[x])return x;
		else return fa[x]=Find(fa[x]);
	}
	bool Union(int x,int y){
		int fu=Find(x),fv=Find(y);
		if(fu==fv){
			return 0;
		}
		else{
			if(sz[fu]>sz[fv]){
				swap(fu,fv);
			}
			fa[fu]=fv;
			sz[fv]+=sz[fu];
			return 1;
		}
	}
}s;
//并查集

int To[200050];
int In[200050],Out[200050];

int Mul(int x){
	int ans=1;
	for(int i=1;i<=x;++i){
		ans=(1ll*ans*i)%MOD;
	}
	return ans%MOD;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int a,b;
		cin>>a>>b;
		if(To[b]==0){
			To[b]=a;
			++In[a];
			++Out[b];
			if(!s.Union(a,b)){//情况二
				cout<<0<<'\n';
				return 0;
			}
		} 
		else if(To[b]!=a){//重边
			cout<<0<<'\n';
			return 0;
		}
	}
	for(int i=1;i<=n;++i){
		if(In[i]>1||Out[i]>1){//情况一
			cout<<0<<'\n';
			return 0;
		}
		if(In[i]==0){//统计连通块数
			++cnt;
		}
	}
	cout<<Mul(cnt)<<'\n';
	return 0;
} 
```

---

## 作者：_Weslie_ (赞：0)

赛时一秒出思路，半小时调代码，把我给干红温了。

## Solution P11380

### Idea

对于一条限制关系 $(a_i,b_i)$，我们将其看作 $a_i$ 向 $b_i$ 连边。

那么我们可以发现以下的情况是不合法的：

- 图上有环。这是一个序列，哪里来的环。
- 一个点有多条出边。一个人右边只有一个位置，哪里安的下两个人。

判断完特殊情况，不难发现这个图有很多连通块，根据乘法原理，若连通块数为 $cnt$，则答案为 $1\times 2\times 3\times \cdots \times (cnt-1) \times cnt$。

### Code

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=200005;
int nxt[N],vis[N],n,m,pre[N],cnt;
void dfs(int now){
	if(now==0)return;
	if(vis[now]){
		printf("0");
		exit(0); 
	}
	vis[now]=1;
	dfs(nxt[now]);
}
main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1,u,v;i<=m;i++){
		scanf("%lld%lld",&u,&v);
		if(nxt[u]!=0&&nxt[u]!=v){
			printf("0");
			return 0;
		}
		nxt[u]=v;
		pre[v]=u;
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]&&pre[i]==0){//找入度为 0 的点遍历，不然可能遍历不完整张图
			dfs(i);
			cnt++;
		}
	}
	if(cnt==0){
		printf("0");
		return 0;
//如果整个图只有一个环，上面 dfs 找不到。在这里特判
	}
	long long ans=1;
	for(int i=1;i<=cnt;i++)ans=ans*i%1000000007;
	printf("%lld",ans);
}
```

---


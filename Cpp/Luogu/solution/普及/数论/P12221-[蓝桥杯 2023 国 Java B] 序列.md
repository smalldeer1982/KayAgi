# [蓝桥杯 2023 国 Java B] 序列

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a_1, a_2, \ldots, a_n$，同时有一个首项为 $d$，公差为 $d$，项数为 $n$ 的等差数列 $\{b_1 = d, b_2 = 2d, \ldots, b_n = nd\}$。

定义 $S_d = \displaystyle \sum_{a_i | b_i} 1$，即 $S_d$ 表示当公差为 $d$ 时有多少对 $(a_i, b_i)$ 满足 $b_i$ 被 $a_i$ 整除，请求出 $\displaystyle \sum_{i=1}^{n} S_i$。

## 说明/提示

### 样例说明

- 当公差等于 $1$：$b = \{1, 2, 3, 4\}$, 有 3 对 $(a_i, b_i)$ 满足条件，$S_1 = 3$。
- 当公差等于 $2$：$b = \{2, 4, 6, 8\}$, 有 4 对 $(a_i, b_i)$ 满足条件，$S_2 = 4$。
- 当公差等于 $3$：$b = \{3, 6, 9, 12\}$, 有 3 对 $(a_i, b_i)$ 满足条件，$S_3 = 3$。
- 当公差等于 $4$：$b = \{4, 8, 12, 16\}$, 有 4 对 $(a_i, b_i)$ 满足条件，$S_4 = 4$。

所以答案为 $3 + 4 + 3 + 4 = 14$。

### 评测用例规模与约定

- 对于 $20\%$ 的数据, 保证 $n \leq 10^3$。
- 对于 $100\%$ 的数据, 保证 $1\leq n \leq 10^5$，$1\leq a_i \leq n$。


## 样例 #1

### 输入

```
4
2 2 3 1```

### 输出

```
14```

# 题解

## 作者：Ahws_rwhy (赞：5)

### 题目大意

给定一个长度为 $n$ 的正整数序列 $a$，以及一个首项为 $d$、公差为 $d$ 的等差数列 $b$（其中 $b_i=i×d$）。定义 $S_d$ 为满足 $a_i$ 整除 $b_i$ 的 $(a_i,b_i)$ 对数，要求计算所有 $d$ 从 $1$ 到 $n$ 的 $S_d$ 之和。

### 解题思路：
对于每个 $d$，需要统计满足 $a_i∣(i×d)$ 的 $i$ 的数量，最终目标是求 $\sum^{n}_{d=1}S_d$，即所有 $d$ 对应的满足条件的 $i$ 的数量总和。

判断 $a_i∣(i×d)$ 的充要条件为 $d$ 是 $a′$ 的倍数。

设 $g=\gcd(a_i,i)$，则 $a_i=g×a′$，$i=g×i′$（其中 $\gcd(a′,i′)=1$）。故条件转化为：$g×a′∣g×i′×d$，约去 $g$ 得 $a′∣i′×d$，由于 $\gcd(a′,i′)=1$，所以等价于 $a′∣d$。令 $k_i=a′=\gcd(a_i,i)$，故得证。

于是问题转化为求 $\sum^{n}_{i=1}n⌊\frac{n}{k_i}⌋$，其中 $k_i=\frac{a_i}{\gcd(a_i,i)}$。

我们可以定义 ``cnt`` 数组计算每个 $k$ 的数量（用类似埃氏筛的思想，将 ``cnt`` 数组中的数累加即可），具体情况可以看代码。

时间复杂度 $\mathcal O(n \log n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int sum[100001], a[100011], cnt[100001];
int gcd(int a, int b) {
	while (b) {
		int tmp = b;
		b = a % b;
		a = tmp;
	}
	return a;
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) {
		int g = gcd(a[i], i), k = a[i] / g;
		if (k <= n) cnt[k]++;
	}
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j += i) {
			sum[j] += cnt[i];
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) ans += sum[i];
	cout << ans;
//	cout << ans;
	return 0;
}

```

---

## 作者：yanmingqian (赞：2)

考虑求贡献。

要求 $a_i|b_i$，就是要求 $b_i \bmod a_i=0$，也就是 $d\times i \bmod a_i=0$，再转化一下就变为了 $d\bmod \frac{a_i}{\gcd(a_i,i)}=0$。那么对于每个 $i$，设 $m=\frac{a_i}{\gcd(a_i,i)}$，贡献就为 $\lfloor \frac{n}{m} \rfloor$。直接计算即可。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100010];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    long long ans=0;
    for(int i=1;i<=n;i++){
        ans+=n/(a[i]/__gcd(a[i],i));
    }
    cout<<ans;
    return 0;
}
```

```java
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n+1];
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }
        long ans = 0;
        for (int i = 1; i <= n; i++) {
            ans+=n/(a[i]/gcd(a[i],i));
        }
        System.out.println(ans);
    }
    private static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```

时间复杂度 $O(n \log n)$，其中计算最大公约数是 $O(\log n)$ 的。

---

## 作者：__Confringo__ (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P12221)

对于每个 $d$，我们需要计算有多少个 $i$ 满足 $a_i$ 整除 $i \cdot d$。即 $a_i \mid i \cdot d$。

根据整除的性质，$a_i \mid i \cdot d$ 等价于 $\frac{a_i}{\gcd(a_i, i)} \mid d$。设 $k = \frac{a_i}{\gcd(a_i, i)}$，则 $d$ 必须是 $k$ 的倍数。

对于每个 $i$，所有满足 $d$ 是 $k$ 的倍数的 $d$ 都会贡献 $1$ 到 $S_d$。因此，$i$ 对总和的贡献是 $\left\lfloor \frac{n}{k} \right\rfloor$。

使用欧几里得算法计算 $\gcd(a_i, i)$。

对于每个 $i$，计算 $k$ 后，统计 $1$ 到 $n$ 中 $k$ 的倍数的个数。

每个 $i$ 的计算包括一次 $\gcd$ 和一次除法，$\gcd$ 的时间复杂度为 $O(\log(\min(a_i, i))$，总时间复杂度为 $O(n \log n)$。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+5;
int n,a[N];
long long ans;

int main()
{
    cin >> n;
    for (int i = 0;i < n;i++) cin >> a[i];
    for (int i = 1;i <= n;i++){
        int now = a[i-1];
        int g = __gcd(i,now);
        int k = now / g;
        ans += n / k;
    }
    cout << ans << endl;
    
    return 0;
}
```

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0;i < n;i++)
            a[i] = scanner.nextInt();
        long ans = 0;
        for (int i = 1;i <= n;i++){
            int now = a[i - 1];
            int g = gcd(i, now);
            int k = now / g;
            ans += n / k;
        }
        System.out.println(ans);
    }
    private static int gcd(int a, int b){
        while (b != 0){
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}
```

---

## 作者：封禁用户 (赞：1)

# [P12221 [蓝桥杯 2023 国 Java B] 序列](https://www.luogu.com.cn/problem/P12221)
## 题目简介：

给定一个长度为 $n$ 的正整数序列 $a_1, a_2, \ldots, a_n$，同时有一个首项为 $d$，公差为 $d$，项数为 $n$ 的等差数列。

其实 $d$ 就是 $1, 2, \ldots, n$。

当公差为 $d$ 时有多少对 $(a_i, b_i)$ 满足 $b_i$ 被 $a_i$ 整除，请求出一共有多少组这样的数对。

## 题目分析：
大不了直接枚举，但也要先化简式子：

$(a_i, b_i)$ 满足 $b_i$ 被 $a_i$ 整除，就是 $d\times i$ 能被 $a_i$ 整除，也就是 $d$ 能被 $\frac{a_i}{\operatorname{gcd}(a_i, i)}$ 整除。

奉上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[100010], sum;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    for(int i = 1; i <= n; i++){
        sum += n / (a[i] / __gcd(a[i], i));//精髓
    }
    cout << sum << endl;
    return 0;
}
```

谢谢观看，求过，求赞。

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12221)

# 题目分析

不难想到，可以分别对每一个 $a_i$ 计算有多少个满足条件的 $d$，记为 $P_i$，则答案等于 $\sum\limits_{i=1}^{n} P_i$。

下面考虑如何求 $P_i$。由于 $a_i\mid i\times d$，则 $\frac{a_i}{(a_i,i)}\mid \frac{i}{(a_i,i)}\times d$。而又因为 $(\frac{a_i}{(a_i,i)},\frac{i}{(a_i,i)})=1$，所以 $\frac{a_i}{(a_i,i)} \mid d$。

由此，问题就变成了小于等于 $n$ 的数中有多少是 $\frac{a_i}{(a_i,i)}$ 的倍数，显然 $P_i=\lfloor \frac{n\times (a_i,i)}{a_i} \rfloor$。

# 代码

```cpp
#include<bits/stdc++.h>
#define N 200001
using namespace std;
int gcd(int a,int b){
    if(b==0){
        return a;
    }
    return gcd(b,a%b);
}
int a[N];
long long ans=0;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        int g=gcd(a[i],i);
        a[i]/=g;
        ans+=(long long)n/(long long)a[i];
    }
    cout<<ans;
    return 0;
}
```

---


# [蓝桥杯 2024 国 C] 六一儿童节

## 题目描述

在蓝桥小镇，每年的六一儿童节是许多孩子最期待的日子。在这一天，神秘的数字精灵会出现，为孩子们带来惊喜和祝福。

今年的六一儿童节格外特别，因为数字精灵带来了一项有趣的挑战给小镇上的孩子们。

挑战的内容是：从数字 $1$ 至 $20240601$ 中找出两个不同的整数 $x$ 和 $y$，使得 $x, y$ 满足 $x$ 小于 $y$，且 $x^x + y^y$ 能够被 $6421$ 整除。成功找到这样一对数字的孩子们将会得到数字精灵准备的豪华大礼包。

对此，请你帮助孩子们计算出所有符合条件的整数对 $(x, y)$ 的数量，帮助小镇上的孩子们解决数字精灵的挑战，让他们能够在六一儿童节收获满满的快乐和难忘的回忆！

# 题解

## 作者：SCma (赞：5)

# 思路
这是一道数学题，但其实它的难度并不大。
### 数学转换：
问题本身其实等价于找到 $(x^x + y^y) \equiv 0 \pmod{6421}$，即：
$$ y^y \equiv -x^x \pmod{6421} $$
因此，统计每个数 $n \in [1,20240601]$ 的 $n^n \bmod 6421$ 值，并计算互补余数的组合数。

### 周期性：
$n^n \bmod 6421$ 的值由 $n \bmod 6421$ 和 $n \bmod 6420$ 共同决定。而最大周期为 $\text{lcm}(6421,6420) = 38943840$，远大于 $20240601$，故直接遍历计算就行了，不需要重复计算。

# 复杂度分析
因为使用了快速幂，所以时间复杂度是 $O(N\log N)$。

# 代码
```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define MIN(a,b,c) min(min(a,b),c)
#define MAX(a,b,c) max(max(a,b),c)
#define ri register int
#define int long long
#define fixedset(a) fixed << setprecision(a)
#define pii pair<int,int>
#define mp(a,b) make_pair(a,b)
#define ls(x) x<<1
#define rs(x) x<<1|1
#define MAXN 20240601
#define inf 2114514
#define mf 5011
#define sf 1011
#define MOD 6421
#define PHI_MOD 6420 
using namespace std;
mt19937_64 randint{std::chrono::steady_clock::now().time_since_epoch().count()};
int tot,cnt[inf]={0};
int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1) res=(res*a)%MOD;
		a=(a*a)%MOD;
		b>>=1;
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	//freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    
    for(ri i=1;i<=MAXN;i++) {
        if(i%MOD==0) ++cnt[0];
        else ++cnt[ksm(i%MOD,i%PHI_MOD)];
    }
    for(ri r=0;r<MOD;r++) {
        int s=(MOD-r)%MOD;
        if(r<s) tot+=cnt[r]*cnt[s];
        else if(r==s) tot+=cnt[r]*(cnt[r]-1)/2;
    }
    
    cout << tot << endl;
    return 0;
}
```

---

## 作者：yuruilin2026 (赞：4)

## 一些闲话：
### 关于题解：
这是一个数论并不好的人的暴力题解，只用了最简单的组合和取模，~~适合不喜欢数学的同学食用~~。
### 一些私货：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540) 和 TA 的 npy [chenyuexiC2026](https://www.luogu.com.cn/user/1499441)。
## 思路：
要求 $x^x+y^y$ 能被 $6401$ 整除，其实就是 $x^x+y^y$ 对 $6401$ 取模等于 $0$。\
那么幂次方中大于 $6401$ 的数就没有用了，可以直接取模掉。\
那就有一个超级暴力的思想了：对于每一个 $i$，预处理 $i^i$ 的结果，然后算匹配数。\
预处理 $i^i$ 可以用快速幂，时间复杂度 $O(n \log n)$，这里 $n$ 是数据范围，也就是 $20240601$。\
乍一看过不了，但是不用担心，~~这是一道输出答案题~~。\
令 $mi_i$ 表示 $i^i$ 对 $6041$ 取模后的结果。\
预处理之后，建立一个桶，表示余数出现次数，从小到大枚举 $i$，答案累加 $6041-mi_i$ 的出现次数。\
为神马呢？\
每一个 $mi_i$ 能相加刚好凑成 $0$，或者说 $6041$ 的不就是 $6041-mi_i$ 吗？\
还有一个注意点，如果 $mi_i = 0$，累加的应该也是 $0$ 的出现次数。\
那么，输出答案就可以了。
## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define p 6421
#define int long long
int mi[20240605],tong[6425],ans;
int Fastpow(int a,int b){//快速幂 
    int sum = 1;
    a = a % p;
    while(b > 0){
        if(b & 1) sum = (sum * a) % p;
        a = (a * a) % p;
        b = b >> 1;
    }
    return sum % p;
}
signed main(){
	for(int i = 1;i <= 20240601;++i) mi[i] = Fastpow(i,i);
	for(int i = 1;i <= 20240601;++i){
		ans += tong[(6421-mi[i]) % p];
		++tong[mi[i]];
	}
	cout << ans;
	return 0;
}
```
虽然理论会超时，但直接用这段代码其实也能 AC。
## 答案：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	cout << "51349141107";
	return 0;
}
```

---

## 作者：__YiChaQAQ__o_O (赞：2)

因为 $x^x$ 与 $y^y$  的值是固定的，并不会随着 $x$ 与 $y$ 的改变而所代表的值改变，于是我们可以求出 $x^x$ 与 $y^y$ 模 $6421$ 的值，再使用标记数组 $flag$ 在模的数位上加 $1$，因为 $x<y$，所以 $i$ 要从 $1$ 枚举到 $6421$ 折半，也就是 $3210$，之后再加模 $6421$ 为 $0$ 的特判。

综上所述，最后的答案即为 $(\sum_{i = 1}^{3210}{flag_i \times flag_ {n-i}})+\frac{flag_0\times(flag_0-1)}{2}$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//需要开long long 
const int N=6425,mod=6421;
int flag[N];
int ksm(int x){
	int y=x,ans=1;
	while(x){
		if (x&1)	ans*=y,ans%=mod;
		y*=y;
		x>>=1;
		y%=mod;
	}
	return ans;
}//快速幂 
int ans;
signed main(){
	for (int i=1;i<=20240601;i++)	flag[ksm(i)]++;
	for (int i=1;i<=3210;i++)	ans+=flag[i]*flag[mod-i];
	cout<<ans+flag[0]*(flag[0]-1)/2<<"\n";
	return 0;
} 
```

---

## 作者：封禁用户 (赞：2)

# [P12312 [蓝桥杯 2024 国 C] 六一儿童节](https://www.luogu.com.cn/problem/P12312)
# 题目简介：
从 $1$ 到 $20240601$ 中找 $x$ 和 $y$ 两个数，使 $x$ 小于 $y$，并且 $x$ 的平方加上 $y$ 的平方能被 $6421$ 整除。
# 思路分析：
最简单的方法，暴力枚举，二重循环，单出来结果要好久，所以启用，但也行。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int ans = 0;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	for (int i = 1; i <= 20240601; i++) {
		for (int j = 1; j <= 20240601; j++) {
			if ((i * i + j * j) / 6421 == 0) {
				ans ++;
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```
然后思考正解。

根据欧拉定理和中国剩余定理，可以发现 $n$ 的平方模 $6421$ 的值由 $n$ 模 $6421$ 和 $n$ 模 $6420$ 来决定，也就是说最大周期为 $6421\times 6240$，也就是 $38943840$，直接遍历即可，用快速幂加快速度。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int p = 6421;
int ul[20240605],un[6425],ans;
int f(int a, int b) {//快速幂 
    int sum = 1;
    a = a % p;
    while (b > 0) {
        if(b & 1) {
			sum = (sum * a) % p;
		} 
        a = (a * a) % p;
        b = b >> 1;
    }
    return sum % p;
}
signed main() {
	for(int i = 1; i <= 20240601; i++) {
		ul[i] = f(i,i);
	} 
	for(int i = 1; i <= 20240601; i++) {
		ans += un[(6421-ul[i]) % p];
		++ un[ul[i]];
	}
	cout << ans;
	return 0;
}
```
因为只要答案，所以超时没事。

最终答案 $51349141107$。

谢谢观看，求过。

---

## 作者：JIN_LONG (赞：2)

## 思路分析：
以知 $x^x+y^y\equiv0$。

可以转化为，$y^y\equiv-x^x$。

所以，对于每一个 $x$，我们需要找到 $y>x$ 使得以上等式成立。

由于 $6421$ 是一个质数，我们可以利用模运算的性质，$φ(6421)=6420$。

因为 $x$ 的周期是 $6421$，$x$ 的周期是 $6420$，所以最大周期为 $38943840$，大于 $20240601$，所以直接遍历就行了。

代码步骤如下。

- 遍历 $y$ 从 $1$ 到 $20240601$，计算 $y^y$，用一个桶数组 $tong$，$tong$ 的第 $y^y$ 加一。同时，可以记录每个 $y$ 的 $y^y$ 的值，以便后续统计，注意 $y^y$ 的值都要取余。

- 然后遍历 $x$ 从 $1$ 到 $20240601$，统计有多少个数字符合题意。
## 代码：

```cpp
#include<bits/stdc++.h>
#define LL long long 
using namespace std;
LL f(LL a,LL b){ 
	LL sum=1;
	while(b){
		if(b&1){
			sum=(sum*a)%6421;
		}
		a=a*a%6421;
		b/=2;
	}
	return sum;
}
LL a[2000001];
int main(){
	LL sum=0;
    for(LL i=1;i<=20240601;i++){ 
        if(i%6421==0){
        	a[0]++;
		}
        else {
        	a[f(i%6421,i%6420)]++;
		}
    }
    for(LL i=0;i<6421;i++){ 
        if(i<(6421-i)%6421){
        	sum+=a[i]*a[(6421-i)%6421];
		}
        else if (i==(6421-i)%6421){
        	sum+=a[i]*(a[i]-1)/2;
		}
    }
    cout<<sum<<endl;
    return 0;
}
```
输出答案代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<"51349141107"<<endl;
    return 0;
}
```

打完后得到答案为 $51349141107$。

---

## 作者：the_Short_Path (赞：2)

一道数学题，其实还是比较水的。

题目要求找到：
$$x^x+y^y\equiv0\pmod{6421}$$
即：
$$y^y\equiv-x^x\pmod{6421}$$
所以我们可以枚举所有满足 $n\in[1,20240601]$ 且 $n^n\bmod6421$。

根据欧拉定理和费马小定理，可知 $n^n\bmod m$ 的值为 $n\bmod m$ 和 $n\bmod \varphi(m)$ 共同商定。

但因为 $6421$ 是质数，所以
$$
\begin{aligned}   \varphi(6421)&=6421-1\\
      &=6420
\end{aligned}
$$
即最大周期为
$$\operatorname {lcm}(6241,6240)=38943840$$
这个数大于 $20240601$，所以可以愉快地遍历，因为它不会重复计算。

可以用 $O(n\log n)$ 的复杂度实现，需要用快速幂。
# Code
```
#include<bits/stdc++.h>
#define int long long // 十年 OI 一场空，不开 long long 见祖宗
const int mod = 6421;
using namespace std;
int ans, cnt[1919810];
int qpow(int x, int y) { // 快速幂
	int ret = 1;
	while (y) {
		if (y & 1) ret = (ret * x) % mod;
		x = x * x % mod, y /= 2;
	}
	return ret;
}
signed main(){
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // 输入输出的优化
    for (int i = 1; i <= 20240601; i++) { // 预处理
        if (i % mod == 0) cnt[0]++;
        else cnt[qpow(i % mod, i % (mod - 1))]++;
    }
    for (int i = 0; i < mod; i++) { // 组合数计算
        int j = (mod - i) % mod;
        if (i < j) ans += cnt[i] * cnt[j];
        else if (i == j) ans += cnt[i] * (cnt[i] - 1) / 2;
    }
    cout << ans << endl;
    return 0;
}
```
经过计算，答案其实就是 $51349141107$。

---

## 作者：cse071549 (赞：1)

### 题目大意
从数字 $1$ 至 $20240601$ 中找出两个不同的整数 $x$ 和 $y$，使得 $x, y$ 满足 $x$ 小于 $y$，且 $x^x + y^y$ 能够被 $6421$ 整除，要计算出所有符合条件的整数对 $(x, y)$ 的数量。

### 思路详解
可以预处理 $1$ 到 $20240601$ 每个数的 $x^x \bmod 6421$ 并统计每个余数出现次数，对于每个余数，计算答案个数，最后输出。

### 代码示例
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=6421;
long long q(long long x,long long y){
	long long r=1;
	while(y!=0){
		if(y&1) r=r*x%Mod;
		x=x*x%Mod;
		y>>=1;
	}
	return r;
}
long long cnt[Mod];
int main(){
	for(int i=1;i<=20240601;i++){
		long long e=i%6420;
        long long r=q(i%Mod,e);
        cnt[r]++;
	}
	long long ans=0;
    for(int i=0;i<Mod;i++){
        int b=(Mod-i)%Mod;
        if(i==b){
            ans+=cnt[i]*(cnt[i]-1)/2;
        }else if(i<b){
            ans+=cnt[i]*cnt[b];
        }
    }
    cout<<ans;
	return 0;
}
```

---

## 作者：lifeiyang1 (赞：1)

这道题是一道提交数学答案题，但不建议运行题解而获得答案。

## 思路

问题本身在是 $x^x + y^y \equiv 0 \pmod{6421}$ 范围 $x \in A\begin{bmatrix} 1 , 20240601 \end{bmatrix}$ 和 $y \in A\begin{bmatrix} 1 , 20240601 \end{bmatrix}$。 我们把第一个式子移一下就变成了 $x^x \equiv -y^y \pmod{6421}$ 然后我们就依次枚举 $x ^ x\bmod{6421}$ 的值就可以求出 $y ^ y\bmod{6421}$ 所需要的值。比如 $x ^ x\bmod{6421} = 3274$ 那么 $y ^ y\bmod{6421}=3147$ 就满足同余所以我们只需要预处理对于 $\begin{bmatrix} 1 , 20240601 \end{bmatrix}$ 范围里的 $x ^ x\bmod{6421}$ 的值，然后把每一种结果的数量记录在桶里，就可以了。当然，我们还需要一种优化就是 $x^x\bmod{6421} = {x \bmod 6421}^{x\bmod6420}$ 大体的思路就是这样。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXNLEN=20240601,MOD=6421;
int a[MOD+5],b[MOD+5];
long long qpow(long long a,long long b){
	long long sum=1;
	while(b){
		if(b&1)sum=sum*a%MOD;
		a=a*a%MOD;
		b/=2;
	}
	return sum%MOD;
}
int main(){
	for(int i=1;i<=MAXNLEN;i++){
		if(i%MOD==0)a[0]++;
		else a[qpow(i % MOD, i % (MOD - 1))]++;
	}
	long long ans=0;
	for(int i=0;i<MOD;i++){
		int j=(MOD-i)%MOD;
		if(i<j)ans+=a[i]*a[j];
		if(i==j)ans+=a[i]*(a[i]-1)/2;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：long_long_inf (赞：0)

# 思路

这题是可以暴力枚举的！

我们可以用快速幂先预处理出所有 $x ^ x$ 除以 $6421$ 的余数，然后用箱存起来。

根据余数的性质可得，如果两个数除以 $6421$ 的余数之和为 $6421$ 或两个数都是它的倍数，那么它们的和就是 $6421$ 的倍数。

## 暴力代码

```cpp
#include <iostream>
using namespace std;
int p = 6421; 
long long power(long long a, long long b) {
	long long t = 1;
	while (b > 0)
	{
		if (b & 1)
			t = t * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return t;
} // 快速幂
int b[6425]; // 箱
int main() {
	for (int i = 1; i <= 20240601; i++) b[power(i, i)]++; // 预处理
	long long ans = 0;
	for (int i = 1; i <= 3210; i++) ans += 1ll * b[i] * b[6421 - i]; // 乘法原理可得
	ans += b[0] * (b[0] - 1) / 2; // 特判没有余数的情况
	cout << ans << endl;
	return 0;
}
```

运行时间比较长，先在编译器运行出结果再输出。

# 代码

```
print(51349141107)
```

[AC](https://www.luogu.com.cn/record/215151841)

---

## 作者：TLE_qwq (赞：0)

## 核心思路
- 模运算转化：因为要使 $x^x + y^y$ 能被 $6421$ 整除，等价于 $x^x \equiv -y^y \pmod{6421}$，即找到满足此同余关系的数对 $(x, y)$ 。
- 费马小定理优化：对于质数 $p = 6421$，根据费马小定理，计算 $a^b \bmod p$ 时，指数 $ b$ 可以简化为 $b \bmod (p - 1)$，也就是 $a^b \equiv a^{b \bmod (p - 1)} \pmod{p}$。这样可以大大减少计算量。

## 代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long LL;
const LL MOD = 6421;
const LL MAX = 20240601;

// 快速幂计算
LL powMod(LL a, LL b) {
    LL res = 1;
    while (b > 0) {
        if (b & 1) res = (res * a) % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    // 用于记录每个余数出现的次数
    vector<LL> cnt(MOD, 0);
    // 预处理每个数的余数
    for (LL i = 1; i <= MAX; i++) {
        if (i % MOD == 0) {
            cnt[0]++;  // 处理 i 是 6421 的倍数的情况
        } else {
            LL base = i % MOD;
            LL exp = i % (MOD - 1);  // 使用费马小定理优化指数
            LL rem = powMod(base, exp);
            cnt[rem]++;
        }
    }

    // 计算满足条件的数对数目
    LL ans = 0;
    for (LL i = 0; i < MOD; i++) {
        LL j = (MOD - i) % MOD;
        if (i < j) {
            ans += cnt[i] * cnt[j];  // 不重复计数
        } else if (i == j) {
            ans += cnt[i] * (cnt[i] - 1) / 2;  // 对称情况
        }
    }

    cout << ans << endl;
    return 0;
}
```

最终答案是 $51349141107$。

---


# 「Wdoi-5」樱点收集

## 题目背景

119 季 5 月，明明本应是樱花盛开的春天，幻想乡却依然下着大雪。异变的主谋**西行寺幽幽子**在古书上看到，只要使妖樱西行妖满开便会有什么人复活，便出于兴趣命令妖梦收集幻想乡中的春度，一手策划成了这场异变。在收集春度的过程中散落的能量在西行妖的影响下化为**樱点**，散落在幻想乡各处。

出发解决**春雪异变**的灵梦将前往冥界旅途划分为了若干段，每一段都可以收集到一定的樱点。收集齐一定程度的樱点，就会立即开出樱之结界。开出樱之结界后可以短暂地屏蔽一切攻击，并且获得相应的增益。

但是樱之结界何时开放仅由樱点的收集情况所决定，她不得不对樱点进行「规划」。通过某些途径规避某一段路上樱点的收集，借此使得在将来的某几段路程里，灵梦得以恰好在该段的末尾开放樱之结界。  

但是现实往往不尽人意。也就是说，可能有某些要求无法达成。灵梦希望找出一个方案，使得她可以达成的要求最多。灵梦委托八云紫帮忙决策，于是这个重任就被一条懒紫交给了式神八云蓝。尽管八云蓝擅长计算，但是八云紫睡觉去了没有给她编程，因而现在这个任务就落到了你的手上。

## 题目描述

灵梦当前拥有的樱点可以使用一个**变量** $c$ 存储，初始时为 $0$。当樱点在某个瞬间**恰好**变为了 $k$，灵梦就会展开樱之结界，同时 $c$ 变为 $0$。

现在她把路程**依次**划分为了 $n$ 个关卡，其中第 $i$ 关上，灵梦一共可以获得 $a_i$ 点樱点。这些樱点是均匀分布在这关的路程上的。也就是说，随着这段路程的进行，灵梦的樱点个数会依次增加，每次增加 $1$ 个单位（$c\gets c+1$），恰好在这段路程结束的瞬间会收集到这关中第 $a_i$ 点樱点。

![](https://cdn.luogu.com.cn/upload/image_hosting/3yuiywt0.png)

**【需要注意的是，这只是图示参考，不满足实际的数据限制。】**

在这个例子里，灵梦将路径划分为了四个关卡。这四个关卡的樱点个数分别为 $2,0,3,1$。

灵梦提出了 $m$ 个要求。第 $i$ 个要求 $b_i$ 表示灵梦希望在第 $b_i$ 段路程结束的瞬间，**恰好**展开樱之结界（如果在这段路程的中途展开但是结束的瞬间没有展开，那就不算达成了要求）。

灵梦可以选择在某个关卡开头放 bomb，**跳过**整个关卡的樱点收集。这样的机会**有且仅有**一次（当然，灵梦可以选择不使用 bomb）。

现在需要求出，在最优的选择下，灵梦**最多**可以达成多少个要求。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{sukura2.in/sakura2.ans}}$。该样例约束与测试点 $1\sim 8$ 一致。  
样例 $3$ 见下发的附件 $\textbf{\textit{sukura3.in/sakura3.ans}}$。该样例约束与测试点 $9\sim 14$ 一致。  
样例 $4$ 见下发的附件 $\textbf{\textit{sukura4.in/sakura4.ans}}$。该样例约束与测试点 $15\sim 20$ 一致。

#### 样例 1 解释

- 在不使用 bomb 时，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在统计序列中，满足要求数为 $1$。
- 在第 $1$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $2$ 关使用 bomb，灵梦会在第 $4$ 关开出樱之结界，且第 $4$ 关在统计序列中，满足要求数为 $1$。
- 在第 $3$ 关使用 bomb，灵梦会在第 $2$ 关开出樱之结界，且第 $2$ 关不在统计序列中，满足要求数为 $0$。
- 在第 $4$ 关使用 bomb，灵梦会在第 $2$、$3$ 关开出樱之结界，其中第 $3$ 关在序列中，满足要求数为 $1$。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{k\le} \cr\hline
1\sim 8 & 200 & 10^3 \cr\hline
9\sim 14 & 2\times 10^3 & 10^5 \cr\hline
15\sim 20 & 3\times 10^5 & 10^6 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，保证 $1\le m\le n\le 3\times 10^5$，$1\le k\le 10^6$，$1\le a_i\le 10^9$，$1 \le b_i \le n$，$b$ 序列递增。

## 样例 #1

### 输入

```
4 3 2
1 3 4
1 1 2 1```

### 输出

```
1```

# 题解

## 作者：WardLee (赞：19)

题意：

一个人吃豆豆，沿路上有若干段豆豆，这个人挨着吃，吃 $k$ 个就会立马吐光继续吃。某些相邻两段之间有垃圾桶，这个人可以选择一段不吃，问最多往垃圾桶里吐几次。

假设每一段都有豆豆。

首先考虑不能不吃的情况：

将每段豆豆数量做前缀和，统计有垃圾桶且前缀和模 $k$ 等于0的位置数。

再加上可以有一段不吃的情况：

枚举跳过的一段，如果后面某一个位置的前缀和减去这段豆豆数后模 $k$ 的值为 $0$，
那么它模 $k$ 就等于这段豆豆数模 $k$。所以这一段后面统计前缀和模 $k$ 等于 这段豆豆数模 $k$ 的位置数，这一段前面仍然只统计前缀和模 $k$ 等于 $0$ 的位置数(均有垃圾桶)，二者相加即可。

由于 $k$ 只有 $10^6$，开两个大小为 $10^6$ 的数组 $l$ 和 $r$，$l[i]$ 和 $r[i]$ 分别存储**某一段**前面和后面有垃圾桶且前缀和模 $k$ 为 $i$ 的位置数。假定这段初始时为 $0$ 或 $n+1$，则先把全部有垃圾桶且前缀和模 $k$ 为 $i$ 的位置数储存在 $r[i]$ 或 $l[i]$ 中，从前往后或从后往前边枚举跳过的一段，边更新 $l$ 和 $r$ 和答案即可。

计算时若某一段无豆豆，则跳过，不用其前缀和更新。

时间复杂度：$O(n)$

代码：
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

typedef long long LL;

const int N = 300010, M = 1000010;
int n, m;
LL a[N], s[N], res, K;
int nl[M], nr[M];
bool st[N];

int main(){
    scanf("%d%d%lld", &n, &m, &K);
    for(int i = 1; i <= m; i ++){
        int t;
        scanf("%d", &t);
        st[t] = true;
    }

    for(int i = 1; i <= n; i ++){
        scanf("%lld", &a[i]);
        s[i] = a[i] + s[i - 1];
        if(a[i] && st[i]) nl[s[i] % K] ++;
    }

    int res = nl[0];
    for(int i = n; i >= 1; i --){
        if(a[i] && st[i]) nl[s[i] % K] --;
        res = max(res, nl[0] + nr[a[i] % K]);
        if(a[i] && st[i]) nr[s[i] % K] ++;
    }
    printf("%d\n", res);
    return 0;
}
```

---

## 作者：minstdfx (赞：18)

题目要求是给定 $n$ 个数 $a_1,a_2,\ldots,a_n$，以及一个数 $k$ 。

计数器 $c$ 一开始为 $0$，一次只能加 $1$，且 $c$ 这个计数器每一次到 $k$ 都会跳回 $0$。

再给定一些下标 $b_1,b_2,\ldots,b_m$，表示如果在加 $a_{b_i}$ 个 $1$ 的时候刚好有加最后一个数时计数器跳回 0，那么称达成一次事件。我们要达成尽量多的事件。

我们将依次把计数器加 $a_1$ 次 $1$ ，$a_2$ 次 $1$ ，$\ldots$，$a_n$ 次 $1$ ，但我们可以用bomb跳过其中一段加数。问达成事件数量的最大值。

---

首先，由于计数器每加到 $k$ 跳回 $0$ ，所以只要有某一次加 $1$ 使得加完后总共（计数器不跳回）的数字为 $k$ 的倍数，那么就可以认定这一次加 $1$ 导致计数器跳回。

所以，在不使用 bomb 的情况下，如果对于某一个**在 $b$ 中的** $i$，要使加完 $a_i$ 时触发事件只要 $a_1+a_2+...+a_i$ 是 $k$ 的倍数。

---

如果使用 bomb，假设放在了 $j$ 位，则对所有的 $i$ 小于 $j$ ，加到 $a_i$ 时加的 $1$ 的数量仍然为 $a_1+a_2+...+a_i$ ，不改变对触发事件数量的贡献。

由于加 $a_j$ 被跳过，加完 $a_j$ 不应当触发事件。

对于另外的 $i$ 大于 $j$ ，加到 $a_i$ 时加的 $1$ 的数量变为 $a_1+a_2+...+a_i -a_j$，其为 $k$ 的倍数当且仅当$a_1+a_2+...+a_i$ 和 $a_j$ 模 $k$ 同余。

---

记 $S_i=a_1+a_2+\ldots+a_i$ 表示数组 $a_n$ 的第 $i$ 个前缀和。

我们可以先统计 $a_n$ 数组的 $n$ 个前缀是 $k$ 的倍数的**在 $b$ 中的下标**个数记为 $t$，并将答案设置成不放 bomb 的情况，也就是 $t$。

接着，我们可以把放 bomb 的位置 $j$ 从 $n$ 开始枚举到 $1$。我们让 $t$ 表示 $S_1,S_2,\ldots,S_{j}$ 中 $k$ 的倍数，只统计在 $b$ 中的。

我们开一个数组 $x_0,x_1,\ldots,x_{k-1}$，在每一个 $j$ 时表示 $S_{j+1},S_{j+2}...,S_n$ 中模 $k$ 余 $i$ 的数有 $x_i$ 个。

由于每一次考虑的是 $S_1,S_2,\ldots,S_{j-1}$中 $k$ 的倍数的个数 以及和 $S_{j+1},S_{j+2},...,S_n$ 中与 $a_j$ 具有模 $k$ 相同余数的数的个数。

如果 $S_j$ 是 $k$ 的倍数，我们让 $t$ 变成 $t-1$ ，这样 $t$ 就表示 $S_1,S_2,\ldots,S_{j-1}$中 $k$ 的倍数的个数了。

然后将答案更新为 $t+x_{a_j}$（及和先后答案取 $\max$）。

最后，如果 $j$ 在 $b$ 中，将 $x_{S_j\mod k}$ 这个数加 $1$ ，以便 $j$ 变为 $j-1$ 时 $x$ 数组表示  $S_j,S_{j+1},...,S_n$ 中**关键点**模 $k$ 余 $i$ 的数有 $x_i$ 个。

---

枚举完成后输出答案即可。

---

## 作者：lyhqwq (赞：8)

### 简化题意

给定两个个序列 $a_1 , a_2 ,\cdots, a_n$ , $b_1 , b_2 ,\cdots, b_m$ 和 $k$

可以删除 $0$ 或 $1$ 个 $a_i$ 使得 $(\sum_{j=1}^{b_i}a_j)mod \:k=0$ 的 $i$ 最多

### 思路
考虑维护一个前缀和数组 $sum$

不妨设将 $a_x$ 删除，对于 $sum_1$ 到 $sum_{x-1}$ 都不会受影响，而 $sum_x$ 到 $sum_n$  都减少了 $a_x$

所以我们不妨枚举删除每一个 $a_i$ 去统计答案的变化

当我们删除 $a_x$ 时，答案为 $\sum_{i=1}^{x-1}[sum_i \equiv 0\:(mod\:k)]+\sum_{i=x}^nsum_i \equiv a_x\:(mod\:k)$

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans;
int b[300005],sum[300005],a[300005],t[300005];
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++){
        int x;
        scanf("%d",&x);
        b[x]=1;
    }
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        sum[i]=(sum[i-1]+a[i])%k;
        if(b[i]) t[sum[i]]++;
    }
    int tmp=0;
    for(int i=1;i<=n+1;i++){
        if(b[i]) t[sum[i]]--;
        ans=max(ans,tmp+t[a[i]%k]);
        if(!sum[i]&&b[i]) tmp++;
    }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：sgl654321 (赞：6)

### 题意描述
- 有一个数列 $a$ 共 $n$ 个数，每个数为 $a_i$。
- 一开始 $c=0$，之后每次将 $c$ 加上 $a_i$，在对 $k$ 取模。如果此时 $c$ 变为了 $0$，则称在 $i$ 阶段达成了要求。
- 每一次开始时，都有一次 bomb 机会，可以跳过任意一个 $a_i$。
- 请问在给定的 $b$ 数列中，对于所有的 $b_j$ 阶段有几个达成了要求？
### 解题思路
$40$ 分做法：模拟。遍历每一个 $a_i$，将 bomb 用在该数上（当然也可以不使用 bomb）。然后暴力遍历，如果遍历到 $c=0$，则在 $b$ 数列中寻找有没有 $b_j=i$，如果有 $ans$ 就自增 $1$，最后输出 $ans$。时间复杂度 $O(n^2k)$。代码不提供。

$70$ 分做法：

方法 $1$：将 $40$ 分做法中的查找改为二分查找即可。时间复杂度变为 $O(n^2\log k)$。代码见下面参考代码的第一个代码（我考场的做法）。

方法 $2$: 由于所有的 $b_i$ 都在 $[1,n]$ 范围内，所以我们可以直接开一个数组 $p$ 表示该处是否有要求，之后就不用查找了，直接看 $p_{b_i}$ 是否为真。时间复杂度 $O(n^2)$。代码与满分代码比较相似，不提供。

满分做法：由于 $n$ 达到了 $3\times10^5$，所以考虑如何将 $O(n^2)$ 压到 $O(n)$。

观察题目可以发现：在 $i$ 处使用 bomb，只影响了 $i\in [i,n]$ 的所有的 $a_i$。

所以，我们可以先用一个前缀和 $sum$，用 $sum_i$ 表示 $a$ 数列前 $i$ 项之和。再用一个数组 $num$，用 $num_j$ 表示所有的有需求的 $sum_i$ 对 $k$ 取模后，值为 $j$ 的个数。遍历每一个 $a_i$，将 bomb 作用在该数上。

如果这是一个有需求的数，那么 $sum_i\bmod k$ 的数量就会减少 $1$。

我们用 $now$ 表示在 bomb 之前的答案贡献值。在使用炸弹后，如果此时在 bomb 之前的结果（即 $now$）加上 bomb 之后的结果大于答案，那么就把答案替换为此时的值。

接下来，如果此时 $sum_i\bmod k=0$ 且这个位置是有需求的，那么下次操作它就可以为炸弹之前做贡献，$now$ 要自增 $1$。

最后输出答案即可。

### 参考代码
$70$ 分方法 $1$：[这里自取](https://www.luogu.com.cn/record/71889996) qwq

满分代码：
```cpp
#include<bits/stdc++.h>
#define maxn 900010
using namespace std;
long long n,now,ans,m,k,b[maxn],a[maxn],sum[maxn],num[1000100];
bool p[maxn];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>b[i];
		p[b[i]]=1;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
	}
	for(int i=1;i<=n;i++)
		if(p[i])
			num[sum[i]%k]++;
	ans=num[0];
	for(int i=1;i<=n;i++){
		if(p[i])num[sum[i]%k]--;
		if(now+num[a[i]%k]>ans)ans=now+num[a[i]%k];
		if(sum[i]%k==0&&p[i])now++;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：lsj2009 (赞：4)

## 题目大意
给定序列 $\{a_n\}$，$\{b_m\}$ 和常数 $k$。

可以删除 $x(0\le x\le1)$ 个 $a_i$（为 $0$），使得 $(\sum\limits_{i=1}^{b_i} a_i)\bmod k=0$ 的 $b_i$ 最多。

## 思路

先来考虑暴力：我们可以枚举删除哪一个 $a_i$ 然后遍历序列 $a$，前缀和依次每一个计算 $(\sum\limits_{j=1}^{i} a_j)\bmod k$，统计满足条件 $b_i$ 有几个就行了。

上述程序时间复杂度 $\Theta(n^2)$，可以通过 $\frac{14}{20}=70\%$ 的数据。

接下来我们考虑优化。

其实思考之后可以发现，我们过多的把时间浪费在了对于删除每一个 $a_i$ 的****前缀和计算上****。思考一下如果我们删除了 $a_i$，那么哪些点的前缀和会受到影响呢？是的，前 $i-1$ 个点并不会因此而受到影响，真正受到影响的值是 $a_i$ 至 $a_n$，准确来说是每一个满足 $(\sum\limits_{j=1}^{t} a_j)\bmod k=0$ 且 $t\ge i$ 的 $a_t$ 和 $(\sum\limits_{j=1}^{t} a_j)\bmod k=a_i$ 的 $a_t$。

前者受到影响的原因是去掉了 $a_i$ 他们的前缀受影响而不再满足条件，后者受影响是因为他们的前缀变成了 $\sum\limits_{j=1}^{t} a_j-a_i=a_i$，$\bmod k$ 后变为 $a_i-a_i=0$，从不满足条件变成满足条件。

也就是说，去掉 $a_i$ 后满足条件的 $b_t$ 变成了 $t<i$ 满足条件的 $b_t$ 数量加上 $t\ge i$ 满足 $(\sum\limits_{j=1}^{b_t} a_j)\bmod k=a_i$ 的 $b_t$ 数量。

那么我们要怎么统计上述两项的值呢？

首先对于第一点，我们不妨用 $c_{i-1}$ 来表示 $t<i$ 满足条件的 $b_t$ 数量。那么当 $(\sum\limits_{j=1}^{i} a_j)\bmod k=0$ 且 $i\in \{b_n\}$ 时我们就将 $c_i\gets c_{i-1}+1$，否则保存 $c_{i-1}$ 的值。

对于第二点，我们不妨反着循环 $i$ 从 $n$ 到 $1$，看见 $k\le10^6$，那么不如使用桶计数 $t_x$ 表示在循环到 $i$ 之前前缀为 $x$ 的 $b_t$ 的数量。

接下来取最大值即可。

## Code:

```cpp
#include<bits/stdc++.h>
#define pd push_back
//#define int long long
#define PII pair<int,int>
#define _for(a,b,c) for(int a=b;a<=c;a++)
#define _rep(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
template <typename T> inline void read(T& x) {
	x=0; T f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch&15); ch=getchar(); }
	x=x*f;
	return;
}
template <typename T,typename ...Arg>void read(T& x,Arg& ...arg){
	read(x); read(arg...);
}
const int N=1e6+5;
int a[N],b[N],used[N],c[N],sum[N],tmp[N],n,m,k,ans;
signed main() {
	read(n,m,k);
	_for(i,1,m)
		read(b[i]),used[b[i]]=1;
	_for(i,1,n) {
		read(a[i]); a[i]%=k; sum[i]=(sum[i-1]+a[i])%k; c[i]=c[i-1];  if(used[i]&&sum[i]==0) ++c[i];
	}
	ans=c[n];
	_rep(i,n,1) {
		ans=max(ans,c[i-1]+tmp[a[i]]); if(used[i]) tmp[sum[i]]++;
	}
	printf("%d",ans);
	return 1;
}
```

---

## 作者：蒟蒻炒扇贝 (赞：4)

难度适中的思维题，但我觉得放在PJT2偏难。

![](https://cdn.luogu.com.cn/upload/image_hosting/hwk6msvy.png)

------------

先说一个虽然显然，但却是解出本题核心的一个结论：如果在第 $i$ 关使用一个bomb，那这个bomb不会影响 $[1,i-1]$ 这一区间对答案的贡献，仅仅会影响区间 $[i,n]$ 对答案的贡献。毕竟在使用炸弹之前的关卡中我们可以展开樱之结界的次数是恒定的。

我们来简化问题，如果把 $b$ 数组的限制去掉，该怎么做？

我们首先维护一个前缀和数组 $sum$，表示 $a$ 数组的前缀和。

定义数组 $wt$ （want），表示对于第 $i$ 个关卡，在关卡末恰好展开樱之结界（在下文称之为“合法”）还需去掉的最少的樱点数。可以发现在不使用bomb的情况下，$wt_i=sum_i \%k$。

为什么呢？因为若想在第 $i$ 个关卡合法，我们需要让我们目前所累积的樱点数量之和为 $k$ 的倍数。如果目前樱点数之和并不是 $k$ 的倍数，那么唯一可能使这个点合法的办法，就是在它这个关卡之前使用bomb，使得炸掉这个关卡 $i$ 满足 $a_i\%k=wt_i$，这样就能使该关卡与其他在 $i$ 关卡之后（ $j>i$ ），同样满足 $a_j\%k=wt_j$ 的 $j$ 关卡合法。

我们发现，如果我们在第 $i$ 关卡使用bomb，根据文章开头的结论，在 $[i,n]$ 区间中原先合法的关卡就会变得不合法。设进行“bomb”操作之后对答案的变化为 $\Delta ans$，那么 $\Delta ans$ 的值就是我们现在进行操作后变成合法的关卡数量之和减去在所被影响到区间内原先合法的关卡数之和。如果我们可以用 $O(1)$ 的复杂度算出 $\Delta ans$ ，再套上复杂度为 $O(n)$ 的枚举进行“bomb”操作的点，算出最大的 $\Delta ans$，那这题就可以被我们愉快的A掉了。设不使用炸弹时答案为 $ans$ ，则最终答案即为 $ans+\Delta ans$。

看到 $k\le10^6$，考虑开桶。用桶来记录 $i∈[1,n]$ 区间中的 $wt$ 数组中数字的出现次数。设桶名为 $bu$，$A$ 区间为目前桶内元素所包含的区间。那么 $bu_0$ 就指 $A$ 区间中原先合法的关卡数量，那么对于关卡 $i$，$bu_{a_i\%k}$ 就是对 $i$ 关卡使用炸弹后所能增多的合法关卡数量。我们在枚举 $i$ 的同时可以将桶里的元素扔出去，以保证 $A$ 区间始终是所能贡献答案的区间。炸掉这一个关卡所得到的 $\Delta ans=bu_{a_i\%k}-bu_0$。

需要注意，当 $wt_i\neq0$ 时，$A$ 区间是 $[i+1,n]$，否则便为 $[i,n]$。在 $wt_i\neq0$ 的情况中，炸掉 $i$ 关卡后，若按照 $A=[i,n]$ 计算，此时 $i$ 关卡已经没有樱花，而调用 $bu_{a_i\%k}$ 的时候，这个点就会被当做有樱花被计算一次，导致喜提错误结果。反之亦然。

引入 $b$ 数组后这道题还是可以这样做，只不过 $A$ 内的元素有所变化，变成了一个元素均来自 $b$ 数组的集合。

### Code Time！
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read()
{
    int x=0,fh=1;
    char ch=getchar();
    while(!isdigit(ch))
	{
        if(ch=='-') fh=-1;
        ch=getchar();
    }
    while(isdigit(ch))
	{
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x*fh;
}
const int MAXN=3e5+5,MAXB=1e6+5;
int n,m,k,a[MAXN],b[MAXN],sum[MAXN],ans,wt[MAXN],bu[MAXB];
signed main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)b[i]=read();
	for(int i=1;i<=n;i++)a[i]=read(),sum[i]=sum[i-1]+a[i];
	for(int j=1;j<=m;j++)
	{
		int i=b[j];
		wt[i]=sum[i]%k;
		bu[wt[i]]++;
	}
	for(int i=1;i<=m;i++)if(sum[b[i]]%k==0)ans++;
	int j=1,maxn=0;//这里的maxn就是文中最大的delta_ans。初始值为0，因为如果delta_ans为负，那还不如不使用bomb。 
	for(int i=1;i<=n;i++)
	{
		if(i==b[j]&&wt[i])bu[wt[i]]--,j++;
		maxn=max(maxn,bu[a[i]%k]-bu[0]);
		if(i==b[j]&&!wt[i])bu[wt[i]]--,j++;
	}
	cout<<ans+maxn;
	return 0;
}
```

---

## 作者：happybob (赞：3)

要是赛时对 `pb_ds` 有掌握就 $200$ 分了！

提供一个平衡树写法，虽然平衡树我并不会写，但是 `pbds` 内置有平衡树啊，所以我们考虑用内置的平衡树写，注意要用 `rb_tree_tag` 而非 `splay_tree_tag`，内置的 Splay 很慢，开了 O2 还是超时，而内置红黑树不开 O2 都能过。

说了用平衡树，但是具体什么意思呢？我们考虑记录前缀和，对于每一个 $sum_i$ 我们记录 $sum_i$ 模 $k$ 的余数出现在哪些位置，那么显然对于每一个地方 $i$ 放炸弹他的答案其实就是： $\sum_{j=1}^{i-1} \begin{cases} 1 & sum_j \equiv 0 \pmod k  \\ 0 & \text{otherwise}\end{cases} + \sum_{j=i+1}^n \begin{cases} 1 & sum_j \equiv a_i \pmod k \\ 0 & \text{otherwise} \end{cases}$。

显然这两个东西可以平衡树计算，总复杂度 $O(n \log n)$，事实上你会发现这个东西可以值域线段树，常数更小，不过这样也能过。

代码：

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds; 

#define ll long long

constexpr int N(3e5 + 5);

tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> tr[N];

int n, m;
ll k, ans = 0;

ll a[N], sum[N], b[N];

int main()
{
	scanf("%d%d%lld", &n, &m, &k);
	for (register int i(1); i <= m; ++i)
	{
		scanf("%lld", &b[i]);
	}
	for (register int i(1); i <= n; ++i)
	{
		scanf("%lld", &a[i]);
		sum[i] = sum[i - 1] + a[i];
	}
	for (register int i(1); i <= m; ++i)
	{
		tr[sum[b[i]] % k].insert(b[i]);
	}
	for (register ll i(1); i <= n; ++i)
	{
		ans = max(ans, (ll)(tr[0].order_of_key(i) - tr[0].order_of_key(1) + (tr[a[i] % k].order_of_key(n + 1) - tr[a[i] % k].order_of_key(i + 1))));
	}
	ans = max(ans, (ll)(tr[0].order_of_key(n + 1) - tr[0].order_of_key(1)));
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：wanglingZ1Z (赞：2)

## P8226 「Wdoi-5」樱点收集 题解

​		普及月赛的第二题（确实很普及）

[![R1xCpv.png](https://www.helloimg.com/images/2022/03/22/R1xCpv.png)](https://www.helloimg.com/image/R1xCpv)

### 题意分析

​		简单抽象一下题意就是 $n$ 长度的序列，若在恰好在 $b_i$ 的位置前的 $a_i$ 的前缀和为 $k$ 的倍数，满足的条件数就会 $+1$ ，还有一种操作 $bomb$ ，可以在序列中去掉释放 $bomb$ 位置的 $a$ ，求解在可以释放一次 $bomb$ 的情况下（可以不释放）能满足的最多要求数。

​		在 $bomb$ 之前的部分都是很好解决的，但我们要考虑 $bomb$ 操作到底意味着什么

​		先考虑 $bomb$ 对 $j$ 之前的影响（$j$ 记为 $bomb$ 释放的位置），因为我们需要的是序列的前缀和，所以 $bomb$ 对 $j$ 之前的序列**没有影响**，**对之前的满足要求数也没有影响**，我们就可以分别记录在 $j$ 位置之前的要求满足数在之后可以直接使用，释放 $bomb$ 时的答案变成了
$$
ans_j=j 之前的满足要求数+bomb所影响的后面的满足要求数
$$
​		$j$ 之前的满足要求数可以在计算前缀和的过程中边模边记

​		$bomb$ 所影响的后面相当于在后面全部前缀和共同减去 $a_j$ ，根据模运算的性质，**后面满足要求的数量相当于原本前缀和模 $k$ 等于 $a_j$ 的数量**（$a_j-a_j=0$），我们用一个桶来存储

### 代码实现

​		考场代码：

```cpp
//前缀和求余
//bomb一定不会在Stage last使用
//bomb对前后的影响：
//bomb对前面的情况没有影响
//前面不同位置的达成要求的数量可以累加
//bomb对后面的影响：
//桶的思想向前推导
//qwq
//先求一遍前缀和求余，记录每一个位置及之前的无影响满足要求的状态
//从后面过一遍桶再相加

#include<iostream>
using namespace std;

int k,n,m,tot[1000005],a[300005],b[300005],s[300005],ans[300005],lastans;

void read ()
{
	int x;
	cin>>n>>m>>k;
	for (int i=1;i<=m;i++)
	{
		cin>>x;
		b[x]++;
	}
	for (int i=1;i<=n;i++)
	{
		cin>>a[i];
		s[i]=(s[i-1]+a[i])%k;
		if (b[i]&&!s[i])
			ans[i]++;
		ans[i]+=ans[i-1];
	}
	return;
}

void tong ()
{
	lastans=ans[n];
	for (int i=n-1;i>=1;i--)
	{
		tot[s[i+1]]+=b[i+1];
		ans[i-1]+=tot[a[i]%k];
		lastans=max(ans[i],lastans);
	}
	lastans=max(ans[0],lastans);
	return;
}

void print ()
{
	cout<<lastans;
	return;
}

int main()
{
	read();
	tong();
	print();
	return 0;
}

---

## 作者：Ginger_he (赞：2)

本文同步更新于[博客园](https://www.cnblogs.com/Gingerhe/p/16029769.html)
# 前言
截止到 $3.21$，最优解 $rank1$。
# 题解
先求出 $a_i$ 在模 $k$ 意义下的前缀和，记为 $s_i$，顺便用桶记录下每种余数出现的次数。  
接下来我们 $O(n)$ 枚举对每个关卡使用 bomb 的答案，假设枚举到第 $x$ 关。不难发现，我们不选 $a_x$ 对 $s_1,s_2,\cdots,s_{x-1}$，没有影响，仅仅会让 $s_{x+1},s_{x+2},\cdots s_n$ 都减掉 $a_x$。所以对于每个 $x$，答案为 $\sum\limits_{i=1}^x[s_i\equiv0(\mathrm{mod}\;k)]+\sum\limits_{i=x+1}^n[s_i\equiv a_x(\mathrm{mod}\;k)]$，用刚才的桶进行计算即可。
## 注意
- 循环到 $n+1$ 是因为要计算不使用 bomb 时的答案。
- 记得每次更新桶。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
const int maxx=3e5+5;
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}//快读
int n,m,k,a[maxx],t[maxn],tmp,res,ans;
bool vis[maxx];
int main()
{
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++)
		vis[read()]=1;
	for(int i=1;i<=n;i++)
	{
		a[i]=(a[i-1]+read())%k;//记得取模
		if(vis[i])
			t[a[i]]++;//用桶记录模k的余数
	}
	for(int i=1;i<=n+1;i++)
	{
		tmp=(a[i]-a[i-1]+k)%k;//计算原来的a[i],但有可能为负数，因此加上k再取模
		if(vis[i])
			t[a[i]]--;//记得要减掉
		ans=max(ans,res+t[tmp]);
		if(vis[i]&&!a[i])
			res++;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：SCWLine (赞：1)

[P8226](https://www.luogu.com.cn/problem/P8226)  
我们把题意稍微简化一下先：

>从数列将某一个数用 $ 0 $ 替代（也可以不操作），使得该数列形成的前缀和在某些指定位置上尽可能多的落在 $ k $ 的倍数的集合之中


那我们就先将数列的前缀和给计算出来，然后将其对 $ k $ 取模，表示我们还需要少拿这么多的点数（当然再多少拿 $ n * k $ 的点数也是可以的，类似于周期函数有多个解的情况）才能满足该点的要求，如果该点处理完得到的值为$ 0 $,表示不用 bomb 的情况下，这个点也是可以完成任务的，
**但如果你在这个点之前使用 bomb ，这个点就没法完成了。**  


同时，对该关卡所能得到的点数也对 $ k $ 取模，表示如果不拿这个点的点数，对后面结果有多大的**实际**影响。  

那么这里最关键的思想来了，在关卡 $ i $ 处使用 bomb 和不使用 bomb，其实就相当于将关卡 $ i $ 之后所有进行取模后的前缀和，减去当前关卡所能得到的点数，如果减去之后的值是 $ 0 $ 或者 $ - n * k $ 的话，就表示这个点可以完成任务。（对当前关卡做取模的原因就在这，因为得到的前缀和减到 0 与减到 $ - n * k $ 的数值上，都表示可以完成，那么我们将它进行取模，就可保证进行上述操作之后，得到的结果一定为一个非负整数,方便我们直接用当前点关卡的值直接去查询是否能完成）

所以我们就可以想到以下操作：  
1.  **全程不使用 bomb:**  
$ \text{可完成的任务数} = \text{处理后的前缀和列表数字0的个数} $  
1.   **在关卡 $ i $ 处使用 bomb:**  
$ \text{可完成的任务数} =  \text{i之前处理后的前缀和列表数字0的个数} + \text{i之后处理后的前缀和列表中处理后的对应该关卡点数的数字的个数}   $    

**然后让 $ i $ 从 $ 1 $ 开始进行 $ n $ 轮循环,不断比较上面两种操作哪个最大，并将过程中能得到的最大值存储起来**

这里需要注意的就是你使用 bomb 只会对之后的关卡造成影响，而前面的点是不受影响的，所以用于统计的列表要更改。

AC Code:(附带一些解释)
```cpp
#include<iostream>
const int MAX_N=3e6+5;
using namespace std;

int n,m,k,temp;
bool Achipoint[MAX_N];//记录需要做任务的点
int Sumlist[MAX_N],Selflist[MAX_N],ans;
//Sumlist统计前缀和，Selflist统计关卡本身数值
int counter[MAX_N];
//这个是用来统计在关卡i之后的前缀和余数个数的表格



int main()
{
	cin >> n >> m >> k;
	for(int i = 1;i <= m;i ++)
	{
		cin >> temp;
		Achipoint[temp] = true;
	}
	for(int i=1;i<=n;i++)
	{
		cin >> Selflist[i];
        
		Selflist[i] %= k;
		Sumlist[i] = (Selflist[i] + Sumlist[i-1]) % k;
      //这里用了mod运算性质,理解成这两个数组都需要对k取模处理就好
       
		if(Achipoint[i]) 
        counter[Sumlist[i]] ++;
        
		if( (!Sumlist[i]) && Achipoint[i] )	
			ans ++;//统计不需要时候bomb的最大值
	}
	int tra0 = 0;//统计关卡i之前的不用bomb就可以完成的个数
	for(int i = 1;i <= n;i ++)
	{
		if(Achipoint[i])
			counter[Sumlist[i]] --;//本轮完不成的，之后也不行，删掉
		ans=max(ans,tra0 + counter[Selflist[i]]);
		if( Achipoint[i] && (!Sumlist[i]) )//如果不用bomb也能完成
			tra0 ++;//那在它后面炸，这个点也是可以完成任务的
	}
	cout << ans;
}
```


---

## 作者：duchengjun (赞：1)

# 分析

不使用 bomb 的情况是用前缀和，再与 $k$ 取模，若是 0 且又在统计序列中，就求它们的个数。

使用 bomb 的情况是用前缀和减去跳过的关卡所获得的樱点个数，再与 $k$ 取模，若是 0 且又在统计序列中，就求它们的个数，则若使用 bomb，只有前缀和与 $k$ 取模的值是跳过的关卡所获得的樱点个数且又在统计序列中，这个关卡就是一个合法解。

# 思路

先计算 $ai$ 数组的前缀和 $sum$ 数组，记得需要与 $k$ 取模。

再在所有的要求中求 $sum[i]$ 的个数。

枚举所有的 bomb 地点，与以前的最优答案取最大值。

当第 $i$ 个点作为 bomb 地点的合法关卡个数为 $sum$ 数组中值为 $ai[i]$ 总共个数，减去 $1\sim i-1$ 中 $sum$ 数组中值为 $ai[i]$ 总共个数，加上 $1\sim i-1$ 中 $sum$ 数组中值为 0 总共个数。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=3*1e5+10,K=1e6+10;
int n,m,k;
int b[N];
int ai[N],sum[N],a[K],tong[K];
int ans,t;
signed main(){
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++)
		b[read()]=true;
	for(int i=1;i<=n;i++){
		ai[i]=read()%k;
		sum[i]=(sum[i-1]+ai[i])%k;
		if(b[i])
			a[sum[i]]++;
	}
	ans=a[0];
	for(int i=1;i<=n;i++){
		if(b[i])
			tong[sum[i]]++;
		if(a[ai[i]]-tong[ai[i]]+t>ans)
		    ans=a[ai[i]]-tong[ai[i]]+t;
		if(b[i]&&sum[i]==0)
			t++;
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：苏联小渣 (赞：1)

这题质量很高。认识的人都用 $O(n)$ 过了就我一个是 $O(n \log m)$ 的……

提供一种类似于莫队的从暴力优化的思路，个人感觉比较好想。

---

### Step 1

首先考虑题目的退化版本：如果没有 bomb 操作，那么我们可以统计一个前缀和 $s_i=s_{i-1}+a_i$，如果到了某一个点 $x$，$s_x \mod k=0$，那么这一个点就可以展开樱之结界。原因很显然：但凡樱点个数到达了 $k$ 就会归零，所以 $s_x$ 和 $s_x \mod k$ 意义是一样的。

当加上了 bomb 操作，我们先考虑暴力：对于题目要求的 $b$ 中的每一个 $b_i$，令 $d_{b_i}\gets s_{b_i} \mod k$。我们用 $p_x$ 表示走到点 $x$ 时，**没有任何** bomb 操作所能展开樱之结界的次数。容易发现在 $i$ 进行 bomb 操作时，展开樱之结界次数就是 $p_{i-1}+q$，$q$ 表示 $[i+1,n]$ 能展开樱之结界的点数。这个 $q$ 要怎么求呢？设一个点 $y\in[i+1,n]$，$y$ 的樱点就会减去 $a_i$，**原来 $\mod k=a_i$ 的点现在就变成 $\mod k=0$ 了**。我们找到 $b$ 中**第一个大于** $i$ 的数，设为 $b_{pos}$，然后从 $pos$ 到 $m$ 枚举，找到 $d_{b_j} \mod k=a_i $ 的 $b_j$ 个数。$b_{pos}$ 可以通过二分查找得到，然后寻找 $b_j$ 可以通过 $O(m)$ 的循环得到。复杂度是 $O(nm\log m)$，其实 $O(nm)$ 更容易写，~~只不过为了引出下文才强行加了个 $\log$~~。

暴力[代码](https://www.luogu.com.cn/paste/i2xwwqot)可以自取，AC 代码是在暴力代码基础上略微修改得到的。

---

### Step 2

暴力代码慢在哪里？原因就在于 $O(m)$ 的查找。我们分析一下这个查找的本质是什么：从 $pos$（即为上述 $b$ 中第一个大于 $i$ 的点）到 $n$，寻找 $d_{b_j}$ 模 $k$ 等于 $a_i$ 的 $j$，也就是**寻找区间某个数出现的次数**。有没有一种熟悉的感觉，这不就是**莫队**吗！只不过区间右端点是恒为 $n$ 的。那这个莫队就简单很多了，复杂度也只是 $O(n)$ 的。你只需要一个数组，先预处理出 $i \in [1,m]$ 中每一个 $d_{b_{i}}$ 出现次数。然后每次莫队暴力转移。先二分查找 $pos$，从上一次的点转移到 $pos$，把扫过的点的 $d$ 值出现次数全部减 $1$，就得到了你要找的答案了。复杂度是 $O(n \log m)$ 的，瓶颈在二分。其实二分是可以优化（预处理）掉的，就留给读者自行思考了。

另外，为什么要从 $1$ 枚举到 $n+1$ 呢？因为你可以不进行 bomb 操作啊！到了 $n+1$，$p_n$ 恰好就代表了不进行操作所能得到的答案。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, k, ans, maxx, a[300010], b[300010], s[300010];
int d[300010], p[300010], cnt[300010];
map <int, int> mp;
void shan(int x){
	mp[d[b[x]]] --;
}
signed main(){
	memset(d, 9, sizeof(d));
	scanf ("%lld%lld%lld", &n, &m, &k);
	for (int i=1; i<=m; i++){
		scanf ("%lld", &b[i]);
	}
	for (int i=1; i<=n; i++){
		scanf ("%lld", &a[i]);
		s[i] = s[i-1] + a[i];
	}
	for (int i=1; i<=m; i++){
		d[b[i]] = s[b[i]] % k;
	}
	for (int i=1; i<=n; i++){
		if (d[i] == 0) p[i] = p[i-1] + 1;
		else p[i] = p[i-1];
		a[i] %= k;
	}
	int l = 0;
	for (int i=1; i<=m; i++){
		mp[d[b[i]] % k] ++;
	}
	for (int i=1; i<=n+1; i++){
		ans = 0;
		ans += p[i-1];
		if (i > b[m]){
			maxx = max(maxx, ans);
			continue;
		}
		int pos = lower_bound(b+1, b+m+1, i) - b;
		while (l < pos) shan(++l);
		ans += mp[a[i]];
		maxx = max(maxx, ans);
	}
	printf ("%lld\n", maxx);
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：0)

这道题容易发现，设原来的每个地方樱点为 $a$，在 $k$ 位置放出 $\texttt{bomb}$ 后，接下来的樱点为：

$$a_1,a_2\cdots a_{k-1}, 0,a_{k+1}-a_k,a_{k+2}-a_k,\cdots a_n-a_k$$

我们再开一个桶统计没有 $\texttt{bomb}$ 的情况下到 $i$ 为止最多能满足多少要求，再记一下从后往前到现在同余的数即可。

至此，思路就很明确了，开一个桶维护后缀到现在模 $k$ 同余的数，从后往前扫，统计答案再加上前缀不使用 $\texttt{bomb}$ 的答案即可，代码如下：

```cpp
//By: Luogu@?Ì¿ÖÎÀÉ?(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=998244353;
const long double EPS=1e-7;

struct Stage_t{
	bool IsRequire;
	int StageId;
	int PreSum;
};
int SakuraPowerSum[300010];
int SakuraPower[300010];
bool IsRequired[300010];
int PreSum[300010];
int BackSum[1000010];

signed main()
{
	int n,m,k;

	cin>>n>>m>>k;

	for(int i=1;i<=m;i++)
	{
		int t;

		cin>>t;

		IsRequired[t]=1;
	}

	int Sum=0;

	for(int i=1;i<=n;i++)
	{
		cin>>SakuraPower[i];
		
		SakuraPower[i]%=k;
		SakuraPowerSum[i]=SakuraPowerSum[i-1]+SakuraPower[i];
		SakuraPowerSum[i]%=k;
	
		PreSum[i]=PreSum[i-1]+(SakuraPowerSum[i]==0 && IsRequired[i]);
		SakuraPowerSum[i]=SakuraPowerSum[i-1]+SakuraPower[i];
	}

	int ans=PreSum[n];

	for(int i=n;i>=1;i--)
	{
		ans=max(ans,PreSum[i-1]+BackSum[SakuraPower[i]%k]);
		
		BackSum[SakuraPowerSum[i]%k]+=IsRequired[i];
	}

	cout<<ans<<endl;

	return 0;
}
```

---

## 作者：zhongcy (赞：0)

### Solution

------------

- 首先考虑不使用 bomb 的情况。显然，只要在一次加 $ 1 $ 后（不清零）为 $ k $ 的倍数，就会导致 $ c \gets 0 $。因此，$ \forall 1\le x\le m $，事件触发的条件为 $ \sum\limits_{i=1}^{b_x}\mod k =0 $。

- 再考虑使用 bomb 的情况。设放在第 $ j $ 位，则对于 $ i<j $，事件触发条件不变。但对于 $ i>j $，由于跳过了 $ a_j $，因此，事件触发条件变为 $ \sum\limits_{i=1}^{b_x}-a_j\mod k =0 $。

由于需要求区间和，可以用前缀和把时间复杂度从 $ \Theta(n^2) $ 降至 $ \Theta(n) $。

### Code
 
------------

根据结论直接模拟即可。时间复杂度  $ \Theta(n) $。

```cpp
#include<bits/stdc++.h>
#define N 300001
#define ll long long
using namespace std;
ll n,m,k;
ll cnt,ans;
ll b[N],a[N];
ll x[N],pre[N];
map<int,int>mp;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
		cin>>b[i],mp[b[i]]=1;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		pre[i]=pre[i-1]+a[i];
		ans+=(pre[i]%k==0&&mp[i]);
	}
	cnt=ans;
	for(int i=n;i>=1;i--)
	{
		cnt-=(pre[i]%k==0&&mp[i]);
		ans=max(ans,cnt+x[a[i]%k]);
		x[pre[i]%k]+=mp[i]; 
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：koishi_offical (赞：0)

先考虑没有放符的情况：

计算数列模 $k$ 意义下的前缀和，统计有多少标记位置（即 $b_n$ 数组）前缀和为 0 .

然后考虑放符的情况：

定义一个计数器 $cnt$ ,初始化为不放符情况下的答案 $ans$ .

从 $n$ 逆序遍历到 1 ，显然当灵梦在第 $i$ 个位置放符卡时，第 $i$ 关肯定不会展开结界，同时 $s_i$ 到 $s_n$  ( $s$ 为前缀和数组） 减少 $a_i$ .

所以我们每次遍历到 $i$ 的时候，答案即为 $[1,i-1]$ 有多少标记位置的前缀和为 0 加上 $[i+1,n]$ 有多少标记位置的前缀和为 $a_i$ .


若遍历到的 $i$ 为标记位置且前缀和为 0，则 $cnt--$。

新创建一个数组 $sum_i$ ,意义为 $[i+1,n]$ 中有多少标记位置前缀和为 $i$ 的。


每次统计答案即为 $cnt-sum(a_i)$ ,然后和现有答案比较，取最大值即可。


代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N],b[N],s[N],sum[N];
int n,m,k;
int ans,cnt;
int main() {
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++)
      {
          int x;
          cin>>x;
          b[x]=1;
      }
    for(int i=1;i<=n;i++)
      {
          cin>>a[i];
          a[i]%=k;
          s[i]=(s[i-1]+a[i])%k;
          if(s[i]==0&&b[i]) ans++;
      }
    cnt=ans;
    for(int i=n;i>=1;i--)
      {
          if(b[i]&&s[i]==0) cnt--;
          cnt+=sum[a[i]];
          ans=max(ans,cnt);
          cnt-=sum[a[i]];
          if(b[i]) sum[s[i]]++;
      }
    cout<<ans;
}
```


---


# [蓝桥杯 2016 省 AB] 最大比例

## 题目描述

X 星球的某个大奖赛设了 $M$ 级奖励。每个级别的奖金是一个正整数。

并且，相邻的两个级别间的比例是个固定值。

也就是说：所有级别的奖金数构成了一个等比数列。比如：

$$16,24,36,54$$

其等比值为：$3/2$。

现在，我们随机调查了一些获奖者的奖金数。

请你据此推算可能的最大的等比值。

## 说明/提示

时限 3 秒, 256M。蓝桥杯 2016 年第七届省赛

蓝桥杯 2016 年省赛 A 组 J 题（B 组 J 题）。

## 样例 #1

### 输入

```
3
1250 200 32```

### 输出

```
25/4```

## 样例 #2

### 输入

```
4
3125 32 32 200```

### 输出

```
5/2```

## 样例 #3

### 输入

```
3
549755813888 524288 2```

### 输出

```
4/1```

# 题解

## 作者：言琢დ (赞：23)

## gcd 有关的两个设问

1. 分数的 $\gcd$

   给定两个既约分数 $\dfrac{a}{b}$ 和 $\dfrac{c}{d}$，要求出一个最大的既约分数 $\dfrac{e}{f}$，满足：$\dfrac{a}{b}=k_1\cdot\dfrac{e}{f}$ 且 $\dfrac{c}{d}=k_2\cdot\dfrac{e}{f}$，其中 $k_1$，$k_2$ 均为整数；

2. 分数的最大底数

   给定两个既约分数 $\dfrac{a}{b}$ 和 $\dfrac{c}{d}$，要求出一个最大的既约分数 $\dfrac{e}{f}$，满足：$\dfrac{a}{b}=\left(\dfrac{e}{f}\right)^{k_1}$ 且 $\dfrac{c}{d}=\left(\dfrac{e}{f}\right)^{k_2}$，其中 $k_1$，$k_2$ 均为整数。

注意：两个设问的回答并不一致。

例如：当 $\dfrac{a}{b}=\dfrac{25}{4},\dfrac{c}{d}=\dfrac{125}{8}$ 时，对于设问 $1$ 的回答应为 $\dfrac{25}{8}$，即：
$$\begin{aligned}
\dfrac{25}{4}=2\times\dfrac{25}{8}\\
\dfrac{125}{8}=5\times\dfrac{25}{8}\end{aligned}
$$
这里我们注意到，$\gcd(2,5)=1$，这预示着最终得到的 $\gcd(k_1,k_2)=1$

同样的输入对于设问 $2$ 的回答则应为 $\dfrac{5}{2}$，即：
$$\begin{aligned}
\dfrac{25}{4}=\left(\dfrac{5}{2}\right)^2\\
\dfrac{125}{8}=\left(\dfrac{5}{3}\right)^3\end{aligned}
$$
这里我们注意到，$\gcd(2,3)=1$，这预示着最终得到的 $\gcd(k_1,k_2)=1$

## 两个设问分别对应的解决办法

对于第一个设问，我们考虑一个比较明显的公式：
$$
gcd(k\cdot x_1,k\cdot x_2)=k\cdot\gcd(x_1,x_2)
$$
据此，我们可以将 $\dfrac{a}{b}$ 和 $\dfrac{c}{d}$ 做如下变换：
$$\begin{aligned}
\dfrac{a}{b}\rightarrow \dfrac{a}{b}\times\text{lcm}(b,d)\\
\dfrac{c}{d}\rightarrow \dfrac{c}{d}\times\text{lcm}(b,d)
\end{aligned}$$
据此，对变换后的两个分数做朴素的整数 $\gcd$，假设求出的结果为 $g$，根据上面的公式，直接令：
$$
g\leftarrow g\div\text{lcm}(b,d)
$$
注意这里的除法应为约分，即将 $\dfrac{g}{\text{lcm}(b,d)}$ 直接约分变成 $\dfrac{e}{f}$ 的既约分数形式。

---

对于第二个设问，我们考虑对于答案来构造策略：

$$\begin{aligned}\dfrac{a}{b}=\left(\dfrac{e}{f}\right)^{k_1}\\\dfrac{c}{d}=\left(\dfrac{e}{f}\right)^{k_2}\end{aligned}$$

此时不妨设 $k_1\ge k_2$，特别地当 $k_1=k_2$ 时，符合要求的 $\dfrac{e}{f}$ 应满足使得 $k_1=k_2=1$ —— 事实上此时 $\dfrac{a}{b}=\dfrac{c}{d}$，直接输出两者中任何一个即可。

对于 $k_1>k_2$ 的情况，考虑辗转相除法，直接对 $\dfrac{a}{b}$ 重新赋值：
$$
\dfrac{a}{b}\leftarrow \dfrac{a/b}{c/d}
$$
此时的实际效果：（体现在次数上）
$$
(k_1-k_2,k_2)\leftarrow (k_1,k_2)
$$
很明显，根据这种策略，始终能找到一个时刻满足 $k_1=k_2$（更相减损术的本质）

## 本题解法

根据第二个设问，先对序列排序去重，此后每相邻两项形成一个分数，对形成的 $n-1$ 个分数两两之间做 “分数的最大底数” 运算即可。

---

## 作者：0x282e202e2029 (赞：7)

# P8636 [蓝桥杯 2016 省 AB] 最大比例 题解
## c++的耻辱
刚准备写题解，看了一下之前发题解的大佬们的代码，发现 python 是有专门的 fraction 库的……而且只需要一行
```python
from fractions import Fraction
```
就可以了？？？

~~（c++ 党发出了美妙的 ++ 声）~~

自己用 struct 造一个！

这里，蒟蒻整理了一下需要用到的功能，分别为输入、约分、比较、相除。

解决方法也很简单，只需要写一个 $\gcd$ 函数，再运用一些小学知识，就可以完成搭建。具体参见 AC 代码。
## 真正的辗转相除
这才是真正的重头戏。根据题目要求，我们发现需要写一个函数，返回两数的「最大公底数」，记为 $f(x, y)$，使得其为所有满足 $x = a ^ i \text{ and } y = a ^ j$ 的 $a$ 中最大的一个。

这种运算与求最大公因数很类似，最大公因数的很多性质在其上也得以体现。

类比于辗转相除法的

$$\gcd(a,b) = \gcd(b, a \bmod b)$$

我们可以推出

$$f(a,b) = f(b, \frac{a}{b})$$

同时，类比于最大公因数的运算，我们也可以自然地得出

$$f(a,b,c,\cdots) = f(a,f(b,f(c,\cdots)\cdots)$$

因此我们将除法得出的结果进行运算时，可以不用考虑顺序。

回过头来看，为什么我将该运算求解过程称为「真正的辗转相除」呢？还不是因为它的递推式真的有辗转相「除」。~~（冷笑话）（一点都不好笑。）~~
## 要注意的点
蒟蒻没怎么被坑，但是有几个点要特别注意！！！

1.要开`long long`！有一句俗话叫做——

十年 OI 一场空，没开`long long`见祖宗。

应该没有人会忘吧？

2.读进去的数据要`sort`！题目没有说给你的数一定有序！

3.蒟蒻被坑的点：f 函数要加
```cpp
if(y > x)
{
	swap(x, y);
}
```
这一段一定要加！否则样例 #3 会报错！

蒟蒻甚至修了好久 bug，后来才发现是这个地方没有加！
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
unsigned long long gcd(unsigned long long x, unsigned long long y)
{
	if(!y)
    {
		return x;
	}
	return gcd(y, x % y);
}//最大公因数
struct Fraction
{
    unsigned long long numerator, denominator;//分子，分母
    void read()
    {
        cin >> numerator;
        denominator = 1;
    }//输入
    void reduction()
    {
    	unsigned long long g = gcd(numerator, denominator);
        numerator /= g, denominator /= g;
    }//约分函数，内置更方便
}x[105], ans;
bool cmp(Fraction x, Fraction y)
{
    return x.numerator * y.denominator > y.numerator * x.denominator;
}//分数比较，sort要用，一定是x比y大返回true，否则输出的是答案的倒数
Fraction divide(Fraction x, Fraction y)
{
	Fraction res;
    res.numerator = x.numerator * y.denominator;
    res.denominator = y.numerator * x.denominator;
    res.reduction();
    return res;
}//分数相除
unsigned long long gcd_pow(unsigned long long x, unsigned long long y)
{
    if(y > x)
    {
        swap(x, y);
    }
	if(y == 1)
    {
		return x;
	}
	return gcd_pow(y, x / y);
}//上文f函数
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        x[i].read();
    }//输入
    sort(x + 1, x + n + 1, cmp);//这里一定要sort！
    for(int i = 1; i < n; i++)
    {
        x[i] = divide(x[i], x[i + 1]);//存储相邻两项之比
    }
    ans = x[1];//ans为答案
    for(int i = 2; i < n; i++)
    {
        ans.numerator = gcd_pow(ans.numerator, x[i].numerator);
        ans.denominator = gcd_pow(ans.denominator, x[i].denominator);//更新答案
    }
    cout << ans.numerator << "/" << ans.denominator;//输出
    return 0;
}
```


---

## 作者：CarlosLiu (赞：4)

## 题意描述
给你一堆数，代表一些级别。所有大小相邻级别之比 $k$ 恒定，但并不是所有的级别都给到了你。你要根据拿到的级别，判断 $k$ 的最大值。
## 解题思路
首先，看到一堆没有任何顺序关系的数就不太好，先把输入的数进行排序。

然后，把相邻的数两两相除，求出一些比值，用他们判断答案————等等，有个问题。可能会出现有相邻的两个数相等（比如样例二）。这不处理就会在后面的算法中产生离谱的问题。所以，先把重复的数删去。

然后，我们可以两两相除了。因为题中的要求，要用两个整型数组存储分子和分母。所以，这个与其说是除，不如说是约分。约分也很简单，辗转相除求出最大公约数，然后除掉。

那现在面对一堆分数，怎么求出最大比例呢？在数学中，求出一大堆数的最大公约数，正常的方法是求出前两个数的最大公约数，用结果和第三个数求，再用结果和第四个数求，依此类推。

我们可以先求出两个数对应的最大比例，用结果依次往后再求。甚至求出最大比例的方法也可以用辗转相除。

最后，就可以求出答案了。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int n;
long long t[200],a[200],b[200];
void d(int i) {
	if(a[i]==a[i+1]) return;
	if(a[i]>a[i+1]) {
		while(a[i]>a[i+1]) a[i]/=a[i+1];
		while(b[i]>b[i+1]) b[i]/=b[i+1];
		d(i);
		return;
	}
	if(a[i]<a[i+1]) {
		while(a[i]<a[i+1]) a[i+1]/=a[i];
		while(b[i]<b[i+1]) b[i+1]/=b[i];
		d(i);
		return;
	}
}
long long c(long long x,long long y) {
	if(x%y==0) return y;
	if(y%x==0) return x;
	if(x<y) return c(y%x,x);
	if(x>y) return c(x%y,y);
}
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%lld",&t[i]);
	sort(t+1,t+n+1);
	for(int i=1;i<n;i++) {
		if(t[i]==t[i+1]) {
			for(int j=i+1;j<=n;j++) {
				t[j]=t[j+1];
			}
			n--;
		}
	}
	for(int i=1;i<n;i++) {
		a[i]=t[i+1]/c(t[i+1],t[i]);
		b[i]=t[i]/c(t[i+1],t[i]);
	}
	for(int i=1;i<n-1;i++) d(i);
	cout<<a[n-1]<<"/"<<b[n-1];
	return 0;
}
```


---

## 作者：andyli (赞：4)

设公比为 $\dfrac{A}{B}$ ，给定序列排序去重（随机调查）后相邻两数的比值一定满足 $\dfrac{a}{b} = \dfrac{A^{k_i}}{B^{k_i}}$，其中 $k_i$ 为正整数。因此我们想分别求出 $A^{\gcd (k_1, k_2, \cdots)}$ 和 $B^{\gcd (k_1, k_2, \cdots)}$。可以用类似求最大公约数的方法求得。  

具体来说，设 $f(r^x, r^y)$ 表示 $r^{\gcd (x, y)}$，不妨设 $r^x>r^y$，则有：  
$$f(r^x,r^y)=f(r^y,r^{x-y}), f(r^x, 1) = r^x$$
则已知 $a,b$ 可分别表示为 $r^x, r^y$ 的情况下可以写成： $f(a, b) = f(b, \dfrac{a}{b})$。  
```python
from fractions import Fraction
n, *a = map(int, open(0).read().split())
a = sorted(set(a)) # 去重+排序
a = [Fraction(a[i + 1], a[i]) for i in range(len(a) - 1)] # 相邻比值

def f(x, y):
    if x < y:
        x, y = y, x
    return x if y == 1 else f(y, x // y)

A = B = 1
for d in a:
    A = f(A, d.numerator)
    B = f(B, d.denominator)
print(f'{A}/{B}')
```

---

## 作者：Noah03 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8636)

### 题目大意

在有若干个数的等比数列中，在其中随机选 $n$ 个数，构成一个新数列，已知这个新数列，求原来的等比数列最大的比值是多少。（题目还是很好理解的）

### 思路&解析&做法

根据题目，可以创建结构体存储分子分母。读入数据后 去重+排序，然后求出每一项与后一项的商。接着，我们每次都要求一个函数 `GcdPow`，更新 `ans` 的分子和分母，最后输出 `ans` 即可。

依据题目，可以发现 `GcdPow(a,b)` 就是要求满足 
$$a  \gets x^i \ \land \ b \gets x^j$$ 
中 $a$ 最大的那一个，类比 `gcd`（最大公约数），我们可以得到 `GcdPow(a,b)` 的一般写法：
```cpp
ll GcdPow(ll a,ll b){
	if (b>a) swap(a,b);
	if (b==1) return a;
	return GcdPow(b,a/b);
}
```

再类比 `gcd`，我们可以得到 `GcdPow` 的两个性质：
$$1.\ GcdPow(a,b,c,d,e,...)=GcdPow(a,GcdPow(b,GcdPow(c,GcdPow(d,e,...))))$$

$$2.\ GcdPow(a,b,c,d,e,...)=GcdPow(a,e,d,b,c,...)$$

**即 `GcdPow` 满足交换律和结合律，所以在处理数据时不用考虑顺序问题。**

### 易错点
1. 十年 OI 一场空，不开 `long long` 见祖宗。
2. 读完数据后要排序，数据不保证已经排过序。
3. 排序时要按升序排序，不然分子就和分母反了，输出的答案是正确答案的倒数。
4. 一定一定要约分，不然你连样例都过不去。
5. 约分时用 `gcd`，对 `ans` 操作时用 `GcdPow`，千万不要弄混了。
6. 写 `GcdPow` 时一定要加上 `if (b>a) swap(a,b);`，我被这个坑了好久。

### 代码

又到了代码环节啦！！！

**警告:珍爱账号，远离抄袭！！！**

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
struct stu{
	ll fz,fm;
}a[110];
ll gcd(ll a,ll b){ //求最大公约数 
	if (b==0) return a;
	return gcd(b,a%b);
}
ll GcdPow(ll a,ll b){ //求幂的最大公约数 
	if (b>a) swap(a,b);
	if (b==1) return a;
	return GcdPow(b,a/b);
}
void yf(stu &x){ //对x进行约分 
	ll gcdnum=gcd(x.fz,x.fm);
	x.fz/=gcdnum,x.fm/=gcdnum;
	return;
}
bool operator != (stu x,stu y){ //判断x和y是否不相等 
	return x.fm!=y.fm||x.fz!=y.fz;
}
stu operator / (stu x,stu y){ //分数除法 
	stu ans;
	ans.fz=x.fz*y.fm;
	ans.fm=x.fm*y.fz;
	yf(ans);
	return ans;
}
void operator /= (stu &x,stu y){ //使x=x/y 
	x=x/y;
	yf(x);
	return;
}
bool cmp(stu A,stu B){ //排序函数 
	return A.fz>B.fz;
}
int main(){
	int n;
	scanf("%d",&n);
	//读入数据 
	for(int i=1;i<=n;i++){
		ll x;
		scanf("%lld",&x);
		a[i]={x,1};
	}
	//排序 
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<n;i++){
		a[i]/=a[i+1]; //a[i]变成a[i]和a[i+1]的商 
	}
	stu ans=a[1];
	for(int i=2;i<n;i++){
		//修改ans 
		ans.fz=GcdPow(ans.fz,a[i].fz);
		ans.fm=GcdPow(ans.fm,a[i].fm);
	}
	yf(ans); //对ans进行约分，千万不要忘 
	printf("%lld/%lld\n",ans.fz,ans.fm);
	return 0;
}
```

本人亲测 AC，提交记录如下：

[吸氧](https://www.luogu.com.cn/record/209000214)

[不吸氧](https://www.luogu.com.cn/record/209000221)

吸氧 31ms，不吸氧 30ms，速度特别快（话说为什么不吸氧还比吸氧快了 1ms 啊？）

### 写在最后

这道题我感觉还是挺难的，感觉应该评绿（普及+/提高），或许是我太蒟蒻了吧。

题解如有误，欢迎各位 dalao 指出，我会及时修改。

~~话说我写这篇题解好像就是为了涨咕值啊，毕竟2025年还能写题解的题少了去了~~

### **The End.**

---

## 作者：sxwgysh (赞：2)

## 题解：P8636 [蓝桥杯 2016 省 AB] 最大比例

[题目传送门](https://www.luogu.com.cn/problem/P8636)

### 题意
给你一些级别，所有大小相邻的级别的比 $k$ 恒定，但并不是所有的级别都给出，你要根据拿到的级别，判断 $k$ 的最大值。

### 思路

1. 本题要注意开 long long，$X_i$ 范围可是到了 $10^{12}$ 的。  
2. 注意 sort 一下，便于处理且题目输入不一定有序。

#### 重要步骤：
- 遍历排序后的数组，计算每对相邻奖金数的比值,$\dfrac{s_i}{s_{i-1}}$ 的分子和分母，并存储在两个数组中，这里我们只考虑不同的奖金数就可以了。
- 对于存储的分子和分母数组，分别求出其最大公约数，为此，我们可以使用辗转相除法。

---

## 作者：__Ginka__ (赞：2)

### 大致思路

1. 输入处理：将其存储在数组中。
2. 排序：将奖金数进行排序，以便后续比较相邻数值的比值。
3. 相邻比值：遍历**排序后的数组**，计算每对相邻奖金数的比值 $\displaystyle \frac{s_i}{s_i-1}$ 的分子和分母，并存储在两个数组中。这里我们只考虑**不同的奖金数**就可以了。
4. 求最大公约数：对于存储的分子和分母数组，分别求出其最大公约数。为此，我们可以使用辗转相减法，确保可以处理可能的幂次问题。
5. 输出结果：最终将分母和分子以互质的形式输出。

每项比值的幂题目没说，所以无法通过辗转相除法来做，辗转相减法可以来求幂的最大公约数。

所以我们用辗转相除法分别求出公比的分子和分母的幂的最大公约数即可。

时间复杂度：$O(N \log N)$ 。

```cpp
#include<bits/stdc++.h>
using namespace std;
//用于存储输入的奖金数和计算的分子、分母。
long long a[1145],b[1145],x[1145],n,c;
long long gcd(long long a,long long b)
{
    return (!b)?a:gcd(b,a%b);
}
//两个数的幂的最大公约数。
long long gs(long long a, long long b)
{
    if(a<b) swap(a,b);
    if(b==1) return a;
    return gs(b,a/b);
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>x[i];
    sort(x+1,x+1+n);//奖金数排序。
    //初始化c(c是计数器)。
    for(int i=2;i<=n;i++)
	{
        if(x[i]!=x[i-1])
		{
            c++;//增加计数。
            long long t=gcd(x[i],x[i-1]);//计算相邻奖金数的最大公约数。
            a[c]=x[i-1]/t;//分子。
            b[c]=x[i]/t;//分母。
        }
    }
    long long zi=a[1],mu=b[1];
    for(int i=2;i<=c;i++)
	{
        //所有分子的最大公约数。
        zi=gs(zi, a[i]);
        //所有分母的最大公约数。
        mu=gs(fu, b[i]);
    }
    cout<<mu<<"/"<<zi;
    return 0;
}

```

---

## 作者：FISH酱 (赞：2)

## 前置知识

python 是有专门的 fractions 库，作用是可以把相邻两数的比值求出，在本题中作用极大。

```python
from fractions import Fraction
```

## 分析题目

首先进行输入，注意格式即可。

通过样例2可轻松发现，题目数据可能会有多个重复数字，所以要先去重和排序（python 里要实现去重，可以使用集合自动去重，不需要桶数组等方法）。

```python
x = sorted(set(x))
```

接着使用 fraction 库中的 Fraction 函数求比值。

最后用 numerator 与 denominator 求分子和分母。

## 代码参考

记得先理解再看代码。

```python
from fractions import Fraction
import math

n = int(input())
x = list(set(list(map(int, input().split(' ')))))
ans1=1
ans2=1

def gcd(a, b):
    if b>a:
        a,b = b,a
    if b==1:
        return a
    else:
        return gcd(b, math.floor(a/b))

ls = sorted(x)
for i in range(len(x)-1):
    x[i] = Fraction(ls[i+1],ls[i])

for ls1 in x[:-1]:
    ans1 = gcd(ans1, ls1.numerator)
    ans2 = gcd(ans2, ls1.denominator)

print(ans1,end='/')
print(ans2)
```

---

## 作者：Daniel_xu (赞：1)

# 题意简述
**[题目传送门](https://www.luogu.com.cn/problem/P8636)**\
在同一个等比数列中，随机挑选 $n$ 个数，请求该等比数列的最大公比。
# 大致思路
对于一个长度为 $n$，升序且去重的数组 $a$，设 $p_i=\frac{a_{i+1}}{a_{i}}$ 且 $1 \le i < n$。由于在 $a_{i}$ 与 $a_{i+1}$ 两项之间可能还间隔着多个元素，所以若只考虑 $a_{i}$ 与 $a_{i+1}$ 两个元素，则公比可能为 $\sqrt[k]{p_{i}}$，其中 $\sqrt[k]{p_{i}}$ 为有理数且 $k$ 为正整数。\
故我们对于每一个 $1 \le i < n$ 和任意正整数 $k_{i}$，求相等且在有理数范围内的 $\sqrt[k_{i}]{p_{i}}$ 的最大值。
# 具体实现
1. 进行排序并且去重：由于 $X_{i} \le 1 \times 10^{12}$，推荐使用 set 处理。
2. 求解 $p_{i}$：枚举 $1 \le i < n$，求 $p_{i}$。由于可能涉及有理数，建议使用 pair 存储分子与分母避免精度问题并且注意约分。
3. 求解每一个 $\sqrt[k_{i}]{p_{i}}$。由于 $p_{i}$ 为分数，对于分子、分母分别求解即可。由于 $2^{60} > 1 \times 10^{12}$，只需要枚举 $1 \le k < 60$ 即可。对于每一个 $k$ 用二分法与快速幂求其 $k$ 次方根即可。
4. 用 set 数组存储对于每一个 $i$ 的所有 $\sqrt[k_{i}]{p_{i}}$。
5. 寻找每一个 set 中共有元素的最大值并输出。
# 注意事项
- 本题 $X_{i} \le 10^{12}$，应用 long long 存储。
- 枚举 $k$ 时可以从小到大枚举，并且用 vector 记录下第一个 set，可以从大到小枚举，避免进行分数比大小。
- 遍历 vector 时若使用形如 
```cpp
for(int i:vct)
```
的语句，注意在提交时使用 C++11 及以上版本。
# AC 代码
具体细节详见代码。

```cpp
#include<iostream>
#include<set>
#include<cmath>
#include<algorithm>
#include<vector>
#define pll pair<ll,ll>
#define vct vector<pair<ll,ll> >
#define fi first
#define se second
using namespace std;
const int N=105;
typedef long long ll;
ll a[N];
pll p[N];
pll huajian(pll pr){//化简一个分数 
	ll g=__gcd(pr.fi,pr.se);
	return {pr.fi/g,pr.se/g};
}

ll qpow(ll x,ll y){//快速幂 
	ll res=1;
	while(y){
		if(y&1)res*=x;
		if(res>1e12 || res<0)return 9e18;//越界直接返回极大值，避免影响二分结果 
		x*=x;
		y>>=1;
	}
	return res;
}

pll pair_pow(pll pr,ll n){//分数的n次幂 
	return {qpow(pr.fi,n),qpow(pr.se,n)};
}

ll my_sqrt(ll x,ll y){//y的x次方根 
	ll l=0,r=y;
	while(l<r){
		ll mid=l+r>>1;
		ll p=qpow(mid,x);
		if(p>=y)r=mid;
		else l=mid+1;
	}
	if(qpow(l,x)==y)return l;
	return -1;//无有理数根 
}

pll pair_sqrt(ll x,pll p){//分数p的x次方根 
	ll a=my_sqrt(x,p.fi),b=my_sqrt(x,p.se);
	if(a<0 || b<0)return {-1,0};//无有理数根，返回特殊值 
	else return {a,b};
}

vct find_sq(pll pr){
	vct res;
	for(ll i=1;i<60;i++){//枚举k 
		pll p=pair_sqrt(i,pr);
		if(p.fi!=-1)res.push_back(p);
	}
	return res;
}
int main(){
	set<ll> st;
	set<pll> st2[N];
	ll n,x;
	cin>>n;
//set去重 
	for(ll i=1;i<=n;i++){
		cin>>x;
		st.insert(x);
	}
	ll cnt=0;
	for(auto it=st.begin();it!=st.end();it++){
		a[++cnt]=*it;
	}
//得到p[i] 
	for(ll i=1;i<cnt;i++){
		p[i]=huajian({a[i+1],a[i]});
	}
//每一个i计算 
	vct fst;//i=1时所有值，便于之后枚举 
	for(ll i=1;i<cnt;i++){
		vct v(find_sq(p[i]));
		for(pll pr:v){
			if(i==1)fst.push_back(pr);
			st2[i].insert(pr);
		}
	}
//找共有元素
	for(pll num:fst){
		bool ok=true;
		for(ll i=2;i<cnt;i++){
			if(!st2[i].count(num)){
				ok=false;
				break;
			}
		}
		if(ok){//有共有元素，第一个枚举到的即为最大值 
			cout<<num.fi<<'/'<<num.se;
			break;
		}
	}
	return 0;
}

```

---

## 作者：W_C_B_H (赞：0)

Update 2025.05.07：补充了一句话，并修改了代码中的一个错误。

考虑将 $X$ 从小到大排序，则题意可转换为：求最大的 $k$，使得对于每个在 $[1,N)$ 范围内的整数 $i$，都存在自然数 $n$ 满足 $k^n\times X_i=X_{i+1}$（即 $\dfrac{X_{i+1}}{X_i}=k^n$）。

我们引入“最大公底数”的概念：对于两个有理数 $x,y$，它们的最大公底数为最大的实数 $w$，使得存在自然数 $u,v$ 满足 $w^u=x$ 且 $w^v=y$（例：$4$ 和 $8$ 的最大公底数为 $2$，此时可取 $u=2,v=3$，并且没有更大的答案）。而且此时 $u,v$ 互质（考虑反证，若存在 $\ge2$ 的正整数 $q$，使得 $q\mid u$ 且 $q\mid v$，则 $w^q$ 也是 $x,y$ 的公底数）。同理可证，若 $w^u=x,w^v=y$ 且 $u,v$ 互质，则 $x,y$ 的最大公底数为 $w$。

设 $p_i=\dfrac{X_{i+1}}{X_i}$，则本题答案即为所有 $p_i$ 的最大公底数（假设这个值为 $k$，那么对于每个 $i\in[1,N)$，总有自然数 $n$ 满足 $k^n=p_i$，即 $\dfrac{X_{i+1}}{X_i}=k^n$）。

接下来考虑如何求出两个有理数的最大公底数。设 $f(x,y)$ 表示 $x,y$ 的最大公底数（为了方便起见，我们假设 $x\ge y$，实际计算时若 $x<y$ 则交换 $x,y$ 即可），显然，当 $y=1$ 或 $x=y$ 时，$f(x,y)=x$；否则，$f(x,y)=f(y,\dfrac{x}{y})$（若 $f(x,y)=w$，则存在互质的自然数 $u,v$，使得 $w^u=x,w^v=y$，则上式相当于 $f(w^u,w^v)=f(w^v,w^{u-v})$，又因为 $u,v$ 互质，所以 $v$ 和 $u-v$ 也互质，即等式右边也等于 $w$）。

根据定义可得，对于两个有理数 $\dfrac a b$ 和 $\dfrac c d$（其中 $a,b,c,d\in\N_+$，且 $a,b$ 互质、$c,d$ 互质），则 $f(\dfrac{a}{b},\dfrac{c}{d})=\dfrac{f(a,c)}{f(b,d)}$，这样我们就可以将分数的运算转换为整数的运算。

故直接计算所有 $p_i$ 的最大公底数即可。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>
#define fi first
#define se second
#define N 105
int k,a[N],p=1,q=1;
pii b[N];
pii f(pii x)    // 约分
{
	int i=x.fi, j=x.se;
	return {i/__gcd(i,j), j/__gcd(i,j)};
}
int max_bas(int x,int y)    // 最大公底数
{
    if(x==y)
    {
        return x;
    }
	if(x<y)
	{
		swap(x,y);
	}
	if(y==1)
	{
		return x;
	}
	return max_bas(y,x/y);
}
signed main()
{
	cin>>k;
	for(int i=1;i<=k;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+1+k);
	for(int i=1;i<k;i++)
	{
		b[i]=f({a[i+1],a[i]});
		p=max_bas(p,b[i].fi);
		q=max_bas(q,b[i].se);
	}
	cout<<p<<"/"<<q;
	return 0;
}
```

---

## 作者：aaa1145141919810 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P8636)

简要题意：给出一个等比数列中的几项，求其公比的最大值。

注意到题目并未保证数据有序排列，所以应该先将数据从大到小排序。

我们考虑令答案为 $\dfrac{x}{y}$，则对于数据中的任意两项 $x_1,x_2(x1>x2)$，存在一个正整数 $k$ 使得 $(\dfrac{x}{y})^k = \dfrac{x_1}{x_2}$。所以我们所求的答案即是所有能使 $(\dfrac{x}{y})^k = \dfrac{x_1}{x_2}$ 的 $\dfrac{x}{y}$ 中的最大值。

我们定义函数 $f(x,y)$ 表示所有满足 $k^a=x$ 且 $k^b=y$ 的 $k$ 的最大值 $(a,b\in\N)$，不妨令 $x \ge y$，接下来就是~大力推式子~认真思考环节

当 $y=1$ 时，显然 $f(x,y)=x$；
对于其它情况，因为 $k^a=x，k^b=y$ 所以 $f(x,y)=f(k^a,k^b)$。

在这个式子中，$a,b$显然是互质的。考虑使用反证法，若 $a, b$ 不互质，令 $a = k^\prime t_1, b=k^\prime t_2 $，则：
$$x=k^a=k^{k^\prime t_1}=(k^{k^\prime})^{t_1}$$
$$y=k^b=k^{k^\prime t_2}=(k^{k^\prime})^{t_2}$$
$$f(x,y) = f(k^a,k^b)=f((k^{k^\prime})^{t_1},(k^{k^\prime})^{t_2})=k^{k^\prime} > k$$

与定义矛盾，于是 $a,b$ 必然互质。

我们依旧可以发现，$f(k^a,k^b)=f(k^b,k^{a-b})$。继续使用反证法，假设 $f(k^a,k^b)\ne f(k^b,k^{a-b})$，则必定有一个数 $k_2 = k^n(n>1)$ 使得 $f(k^b,k^{a-b})=k_2$，将 $k_2$ 代回原式，则有 $f(k_2^{\tfrac{b}{n}},k_2^{\tfrac{a-b}{n}})$，根据定义，$\dfrac{b}{n}, \dfrac{a-b}{n}为整数$，所以 $\dfrac{a}{n}$ 为整数，故 $f(k^a,k^b)=f(k_2^{\tfrac{a}{n}},k_2^{\tfrac{b}{n}})=k_2=k^n>k$，与定义矛盾，所以 $f(k^a,k^b)=f(k^b,k^{a-b})$，即 $f(x, y)=f(y,x/y)$。

根据以上推导 我们可以得出 $f$ 函数的实现，如下：
```cpp
LL max_bas(LL x, LL y) //即上文f函数 
{
	if(x < y)swap(x, y);//这行一定要加，不然会WA
	if(y == 1)return x;
	return max_bas(y, x/y);
}
```

类比于最大公因数，$f(a,b,c)=f(a,f(b,c))$，我们就可以求多个数的 $f$ 函数值。

总结这题的做法，先将输入数据从大到小排序，然后对任意相邻两数求比值，对这些比值求 $f$ 函数值，输出即可。

以下是 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using LL = long long;

const int N = 105;
int n;
LL a[N];

struct frac
{
	LL fz, fm;
	
	void yf()
	{
		LL t = __gcd(fz, fm);
		fz /= t, fm /= t;
	}
	
	void output()
	{
		printf("%lld/%lld", fz, fm);
	}
	
	bool operator < (frac b)
	{
		return fz*b.fm < fm*b.fz;
	}
	frac operator / (frac b)
	{
		frac res;
		res.fz = fz/b.fz, res.fm = fm/b.fm;
		return res;
	}
	bool operator == (frac b)
	{
		return fz==b.fz&&fm==b.fm;
	}
}b[N];

bool cmp(frac a, frac b)
{
	return a.fz*b.fm > a.fm*b.fz;
}

LL max_bas(LL x, LL y)//即上文f函数 
{
	if(x < y)swap(x, y);
	if(y == 1)return x;
	return max_bas(y, x/y);
}

int main()
{
//	freopen("ratio.in", "r", stdin);
//	freopen("ratio.out", "w", stdout);
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
	{
		scanf("%lld", &a[i]);
	}
	sort(a+1, a+n+1);
	for(int i = 1; i < n; i++)
	{
		b[i].fm = a[i], b[i].fz = a[i+1];
		b[i].yf();
	}
	sort(b+1, b+n, cmp);
	int k = unique(b+1, b+n)-b-1;
	
	frac ans;
	for(int i = 1; i < n; i++)
	{
		if(i == 1)ans = b[i];
		else 
		{
			ans.fz = max_bas(b[i].fz, ans.fz);
			ans.fm = max_bas(b[i].fm, ans.fm);
			ans.yf();
		}
	}
	ans.yf();
	ans.output();
	puts("");
	
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/216018338)

---

## 作者：xk2013 (赞：0)

题目传送门：[P8636 [蓝桥杯 2016 省 AB] 最大比例](/problem/P8636)

很久没有关注过洛谷了，洛谷发生了翻天覆地的变化，然鹅社区贡献也掉了一堆，于是前来补题解。

## 前置知识
- 两个数的最大公约数 $\gcd$；
- 两个数的幂的最大公约数 $\gcd^2$←（划掉）。

## 题意简述
给定一个等比数列中的几项（可能乱序，可能重复），求这个等比数列的最大比值。

## 解题思路
因为可能是乱序的，所以先排个序，然后取个重，这步很好理解。

然后计算出每两项之间比值分子分母的最大公约数。

最后对两个处理过后的分子分母的序列求一次幂的最大公约数就可以过掉啦！

时刻谨记：十年 OI 一场空，不开 `long long` 见祖宗。

## 完整代码
看完上面再看这儿，不能只看这儿，更不能 Copy！

```cpp
#include <algorithm>
#include <cstdio>

typedef long long int ll;
constexpr int N = 105;
ll n, x, y, a[N], b[N], c[N]; // 数列、分子、分母

ll gs(ll a, ll b) // 所谓的 gcd^2（划掉）
{
	if (a < b) std::swap(a, b);
	if (b <= 1) return a;
    return gs(b, a / b);
}

int main(void)
{
	scanf("%lld", &n);
	
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	
	std::sort(a + 1, a + 1 + n); // 排序
	n = std::unique(a + 1, a + 1 + n) - a; // 去重
	
	for (int i = 2; i <= n; i++) // 处理分子分母
	{
		b[i] = a[i] / std::__gcd(a[i], a[i - 1]);
		c[i] = a[i - 1] / std::__gcd(a[i], a[i - 1]);
	}
	
	x = b[1];
	y = c[1];

	for (int i = 2; i <= n; i++) // 处理最终答案
	{
		x = gs(x, b[i]);
		y = gs(y, c[i]);
	}
	
	printf("%lld/%lld", x, y);
	
	#define _ 0
	return ~~(0^_^0);
	#undef _
}

```
----------------------
这是本五年级蒟蒻小学生的第 26 篇题解，不喜可喷，但求你不要喷太猛了哦~

## 更新日志
- 2025/03/24：初版。

---

## 作者：liupei (赞：0)

## 思路
等比数列必然有一个首项，显然要先将等比数列排序之后两两相除，以此获得一个没有首项的序列。这里有一点需要注意，就是题目中有可能会出现两个一样的数字，这个时候相除答案会是 $1$，但是 $1$ 是所有正整数的最小公因数，显然不是我们要找的数字，所以读入数据的时候需要去重。

之后，获得了相邻两项的商。本来做到这里，我天真的以为只要对这些商求最大公因数就行了，事实上如果存在 $1$、$8$、$80$ 这样的序列，求商后得 $8$、$10$，如果简单得求最大公因数会得到错误答案 $8$。

一开始我也没考虑到，因为如果公比为 $8$，就无法从序列中得到由 $8$ 变为 $80$ 的情况。

这是为什么？本质上是因为没有没有考虑到公比之间的变化，那如何考虑公比之间的变化。以上面的数据举例，如果存在 $q$，则必然存在 $q^{n_1}=8$，$q^{n_2}=10$，如果考虑 $n_1$，$n_2$ 的存在性情况，也就是说需要满足 $q^{n_2-n_1}=\frac{4}{5}$，其中 $n_2-n_1$ 属于整数。相当于对商数列求最大公因数的时候，多了这一个条件就足够。

所以只需要在获得商数列的基础上，增加这些条件即可。这些条件的获得，直接通过对商数列的排序，然后对相邻的商进行相除即可。获得条件后，其实条件和商数列形式上是完全一样的，也就是这些数值需要出现在整个数列中。

所以我们通过在商数列后面追加这些数值即可。
## 代码
```python
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def lgcd(a, b):
	return [gcd(a[0],b[0]),gcd(a[1],b[1])]


while True:
	try:

		n = int(input())
		l = list(set(map(int, input().split())))
		l.sort()
		n = len(l)
		tl = []
		for i in range(n - 1):
			g = gcd(l[i], l[i + 1])
			tl.append((l[i + 1] // g, l[i] // g))

		tl=list(set(tl))
		tl.sort(key=lambda x:x[0]/x[1])
		n=len(tl)
		for i in range(n-1):
			tl.append((tl[i+1][0]/tl[i][0],tl[i+1][1]/tl[i][1]))


		g = tl[0]
		for i in tl:
			g = lgcd(g, i)

		print('%d/%d' % (g[0], g[1]))
	except:
		break


```

---

## 作者：SSTF2022ywh (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8636)

## 思路

为了解决这个问题，我们可以使用 **二进制** 搜索来找到相邻级别奖金之间的最大可能比率。我们可以从 $1$ 的下限和最高奖金除以最低奖金的上限开始。然后，我们可以计算下限和上限的中点，并通过将其与实际奖金水平之间的比率进行比较来检查它是否是有效的比率。如果中点是一个有效的比率，我们将下限更新为中点。否则，我们将上限更新到中点。我们重复这个过程，直到下限和上限收敛到一个值，这是最大可能的比率。

## C++ Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; // 奖金数的个数
unsigned long long gcd(unsigned long long x, unsigned long long y) { // 求最大公约数
    if (!y) {
        return x;
    }
    return gcd(y, x % y);
}

struct Fraction { // 分数结构体
    unsigned long long numerator, denominator; // 分子和分母

    void read() { // 读入分数
        cin >> numerator;
        denominator = 1;
    }

    void reduction() { // 约分
        unsigned long long g = gcd(numerator, denominator);
        numerator /= g, denominator /= g;
    }
};

Fraction x[105], ans; // 奖金数和最大等比值

bool cmp(Fraction x, Fraction y) { // 比较函数
    return x.numerator * y.denominator > y.numerator * x.denominator;
}

Fraction divide(Fraction x, Fraction y) { // 除法
    Fraction res;
    res.numerator = x.numerator * y.denominator;
    res.denominator = y.numerator * x.denominator;
    res.reduction();
    return res;
}

unsigned long long gcd_pow(unsigned long long x, unsigned long long y) { // 求幂次最大公约数
    if (y > x) {
        swap(x, y);
    }
    if (y == 1) {
        return x;
    }
    return gcd_pow(y, x / y);
}

int main() {
    cin >> n; // 读入奖金数的个数

    for (int i = 1; i <= n; i++) { // 读入奖金数
        x[i].read();
    }

    sort(x + 1, x + n + 1, cmp); // 按照分数大小排序

    for (int i = 1; i < n; i++) { // 计算相邻奖金数的比值
        x[i] = divide(x[i], x[i + 1]);
    }

    ans = x[1]; // 初始化最大等比值

    for (int i = 2; i < n; i++) { // 计算最大等比值
        ans.numerator = gcd_pow(ans.numerator, x[i].numerator);
        ans.denominator = gcd_pow(ans.denominator, x[i].denominator);
    }

    cout << ans.numerator << "/" << ans.denominator; // 输出最大比例
```
[AC记录](https://www.luogu.com.cn/record/111719445)

## 注意

 **要开long long**。 




---


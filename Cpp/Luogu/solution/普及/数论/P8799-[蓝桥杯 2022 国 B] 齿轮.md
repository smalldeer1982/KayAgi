# [蓝桥杯 2022 国 B] 齿轮

## 题目描述

这天，小明在组装齿轮。

他一共有 $n$ 个齿轮，第 $i$ 个齿轮的半径为 $r_{i}$, 他需要把这 $n$ 个齿轮按一定顺序从左到右组装起来，这样最左边的齿轮转起来之后，可以传递到最右边的齿轮，并且这些齿轮能够起到提升或者降低转速（角速度）的作用。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_8ee8d95d6d0319bca20dg-17.jpg)

小明看着这些齿轮，突然有 $Q$ 个疑问: 能否按一定顺序组装这些齿轮使得最右边的齿轮的转速是最左边的齿轮的 $q_{i}$ 倍?


## 说明/提示

**【样例说明】**

询问 $1$ 方案之一：`23341`。

询问 $2$ 方案之一：`42331`。

询问 $3$ 没有方案。

**【评测用例规模与约定】**

对于 $15 \%$ 的数据，保证 $n, Q \leq 100$;

对于 $30 \%$ 的数据，保证 $n, Q \leq 2000$;

对于 $100 \%$ 的数据，保证 $n\ge 2,n, Q \leq 2 \times 10^{5} ; a_{i}, q_{i} \leq 2 \times 10^{5}$。

蓝桥杯 2022 国赛 B 组 I 题。

## 样例 #1

### 输入

```
5 3
4 2 3 3 1
2
4
6```

### 输出

```
YES
YES
NO```

# 题解

## 作者：cwfxlh (赞：30)

# P8799
### [题目传送门](https://www.luogu.com.cn/problem/P8799)
____

upd:2023 年 4 月 10 日的时候被 feecle6418 的加强数据橄榄了，所以重写一发。

首先，齿轮之间的半径很明显决定了它们的速度关系，两个咬合在一起的齿轮，它们的速度之比与它们的半径之比成反比。
也就是 
$$R_1:R_2=V_2:V_1$$  
那么，对于一系列连在一起的齿轮，  
$$V_1:V_n=R_n:R_1$$  
这个可以通过把比例乘起来得到，不多讲。  
到了这里，题意就很清楚了，它要我们求出数列 $a_{1...n}$ 中有没有一对数的比值为 $q_i$。

因为 $Q$ 的范围过大，所以每次询问时进行处理不太可能，同时离线下来也没有什么帮助。所以考虑预处理答案。   
对于每一个合法的 $q_i$，其必然可以表示为 $\frac{a_i}{a_j}$ 的形式，则考虑枚举 $a_j$，便能做到 $\Theta(n\log n)$ 级别的预处理，可以通过此题。

上代码  
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,k1,mp[300003],ans[300003],a[300003];
signed main(){
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		mp[a[i]]++;
	}
	sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        if(i>1&&a[i]==a[i-1])continue;
    	for(int j=a[i];j<=a[n];j+=a[i]){
    	    if(!mp[j])continue;
    	    if(mp[j]==1&&j==a[i])continue;
        	ans[j/a[i]]=1;
        }
    }
	while(q--){
		scanf("%lld",&k1);
		if(ans[k1]==1)printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```


---

## 作者：Bitter_Tea (赞：6)

蓝桥杯国赛中分值很高的一个题，但是难度不大。

这些齿轮的线速度$\ v\ $是相同的，那么转速就与半径成反比。
如果能满足$\ q_i\ $倍，就要存在一个齿轮的半径是另一个齿轮半径的$\  q_i\ $倍。

对于倍数为$\ 1\ $的情况，我们单独处理。

对其他倍数的情况，我们依次枚举判断即可。

直接上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int n, q;
int v[N];
bool ans[N];

int main() {
	cin >> n >> q;
	for (int i = 1; i <= n; i++){
		int x;
		cin >> x;
		v[x]++;
	}
	int s = 200000;
	for (int i = 1;i <= s; i++)
	if (v[i] >= 2) ans[1] = 1; 
	for (int i = 2; i <= s; i++)
	for (int j = 1; j <= s / i; j++) {
		if (v[j] && v[j * i]) {
			ans[i] = 1;
			break;
		}
	}
	while (q--)
	{
		int x;
		cin >> x;
		if (ans[x]) cout << "YES\n";
		else cout << "NO\n";
	}
	return 0;
}


```

---

## 作者：liupei (赞：6)

## 题意
给一个数组为齿轮大小，问能不能换顺序后，尾转的速度是首转的速度的 $q_i$ 倍，询问 $Q$ 次。

## 思路
不难发现这个中间的没有用，就是首的半径 $=$ 尾的半径 $\times q_i$ 就可。而且这种排序是随便的，只需要找这个数组中有没有两个数相除是否等于  $q_i$ 即可。

那么需处理出这个数组所有的可有倍数即可。具体看代码更容易理解，这个时间复杂度是 $n \times \log n$ 的，对 ```1e6```也应该能用，注意倍数 $1$ 的判断。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x3f3f3f3f
#define LL long long
#define M 1000005
int MAX=400005;
int n,m,flag=0;
int a[M];
int vis[M],ans[M];
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(vis[a[i]]==1) flag=1;        //单独判断ans[1]
        vis[a[i]]=1;            //表明数组有这个数
    }
    if(flag) ans[1]=1;
    for(int i=1;i<=MAX;i++){
        if(vis[i]==1){
            for(int j=i*2;j<=MAX;j+=i){
                if(vis[j]==1) ans[j/i]=1;
            }
        }
    }
    int x;
    while(m--){
        cin>>x;
        if(ans[x]) cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }
    return 0;
}
```

---

## 作者：_Above_the_clouds_ (赞：5)

# [题目传送门](https://www.luogu.com.cn/problem/P8799)
### 题目分析：
首先，让我们来看一下，如何计算齿轮：设齿轮半径依次为 $a_{1 \sim n}$，那么齿轮的转速比分别为 ${\frac{a_1}{a_2}}{\times}{\frac{a_2}{a_3}}{\times}{\frac{a_3}{a_4}}{\times}{\dots}{\times}{\frac{a_{n-1}}{a_n}} = {\frac{a_1}{a_n}}$，也就是说，我们需要在 $N$ 个数里面寻找两个数，使得这两个数的商为 $q_i$。

我们可以先将每一个数的倍数列举出来枚举是否存在一个数是它的倍数。以样例为例：如图，$2$，$3$，$4$ 既是 $1$ 的倍数，又在给出的数里面，所以当输入 $2$，$3$，$4$ 时，输出 `YES`，否则输出 `NO`。

### 代码：
为查找方便，应使用桶存储。
~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=2e5+10;
int n,m,q;
int r[Maxn],t[Maxn],ans[Maxn];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) scanf("%d",&r[i]);
	sort(r+1,r+n+1);//排序
	for(int i=1; i<=n; i++) t[r[i]]++;//用桶存储，方便访问。考虑到可能会有重复的部分，所以是将值加一而不是将值设为一。
	for(int i=n<10000?n:n/100;i; i--) {
		t[r[i]]--;//因为齿轮半径可重复，即自己能被自己整除，所以这里需要减一。
		for(int j=r[i]; j<=r[n]&&j; j+=r[i]/*枚举倍数*/) if(t[j]/*如果倍数存在*/) ans[j/r[i]]=1;//ans数组是存储哪些转速比有解，哪些无解。
		t[r[i]]++;//将减去的一加回来，方便后续操作。
	}
	while(m--){
		scanf("%d",&q);
		if(ans[q]) printf("YES\n");
		else printf("NO\n");//直接使用桶即可
	}
	return 0;
}

---

## 作者：Magic_1e6 (赞：2)

## 题意：
给定 $n$ 个数，询问 $Q$ 次，问你数组中是否有一个数是另一个数的 $q_i$  倍。
## 做法：
首先考虑每次朴素枚举，复杂度 $O(n^3)$ 显然不可行。

其次考虑标记降低复杂度，枚举数组中最小值到最大值的区间，看第 $j$ 号位和第   $q_i \times j$ 号为的访问情况，复杂度 $O(n\log{n})$ 可行。

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int mx;
int n, q;
map<int, int> mp; //记录数的出现次数
int x;
bool cz() {
	if (n == 1) { //注意n为1时的判断
		if (x == 1) //注意1倍时判断
			return 1;
		else
			return 0;
	}
	for (register int i = 1; 1ll * i * x <= mx; i++) { //i*x可能爆int导致死循环，提前转long long
		if (x == 1) { //注意1倍时判断
			if (mp[i] > 1)
				return 1;
		} else if (mp[i] > 0 && mp[i * x] > 0)
			return 1;
	}
	return 0;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> q;
	for (register int i = 1; i <= n; i++) {
		cin >> x;
		mx = max(x, mx);
		mp[x]++;
	}
	while (q--) {
		cin >> x;
		if (cz())
			cout << "YES\n";
		else
			cout << "NO\n";
	}

	return 0;
}

```

---

## 作者：Maysoul (赞：1)

来一发 STL版本的。

## 简述思路：

我们不难发现，整行齿轮的转速只和最左边的齿轮转速有关。

换句话说，我们只需要保证最一头齿轮的转速是另一头的 $ q_{i} $ 倍就可以了。

再换句话说，对于每一个 $ q_{i} $，我们要从 $ n $ 个齿轮中找出两个齿轮 $ a $,$ b $，满足 $ a=q_{i}\times b $。

转换一下就能得到 $ q_{i}=\frac{a}{b} $ ，这就是保证 $ q_{i} $ 满足条件的结论。

按照这个思路我们可以想到枚举 $ a $, $ b $。以求出每一个满足条件的$ q_{i} $ 再依次进行比对，可是这种算法的复杂度为 $ O(n^{2}) $，无法通过本题，我们考虑换一种思路。

观察  $ a=q_{i}\times b $ 这个式子，可以发现，枚举可能的 $ q_{i} $ 比枚举  $ a $, $ b $ 的复杂度要小的多。按照这个思路走下去，我们枚举 $ b $ 的每一个倍数，如果存在一个齿轮$ a $ 与它相等，那么这个倍数就是可行的 $ q_{i} $。

我们可以用 STL 中的 `set` 来实现上述操作。

一开始，我们把齿轮都放入一个集合中，然后再枚举这个集合里的元素，同时枚举它的倍数，如果它的倍数依然在集合中，则把这个倍数放进另一个集合。

而另一个集合，就是所有满足条件的 $ q_{i} $。

当然除了 `set` 之外，也可以使用 `map`，甚至使用数组模拟，STL的常数确实很大，但是其优点就是直观，一目了然。写起来思路清晰，非常优雅。

## CODE：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=2e5+10;
unordered_set<int> se,ans;//unordered_set常数小
int a,mx;
signed main()
{
	int n,q;
	cin>>n>>q;
	for (int i=1;i<=n;i++){
		cin>>a;
		if(se.count(a)) ans.insert(1);//这里需要特判两个数相等的情况
		se.insert(a);
		mx=max(mx,a);
	}
	for (int i:se){
		for (int j=2;i*j<=mx;j++){//枚举倍数
			if(se.count(i*j)) ans.insert(j);
		}
	}
	for (int i=1;i<=q;i++){
		int k;
		cin>>k;
		if(ans.count(k)) cout<<"YES"<<endl;
		else cout<<"NO"<<endl;
	}
	return 0;
} 

```


---

## 作者：kkksc1223 (赞：1)

分析

这道题目是一道比较经典的贪心题目，我们可以从最右边的齿轮开始考虑，假设最右边的齿轮的转速是 $q_i$ 倍，那么我们可以得到最右边的齿轮的半径为 $r_n \times q_i$，然后我们可以考虑倒数第二个齿轮，它的转速是最右边的齿轮的转速的 $\frac{r_n}{r_{n-1}}$ 倍，那么它的半径为 $r_{n-1} \times \frac{r_n}{r_{n-1}} \times q_i = r_n \times q_i$，这样我们就可以得到倒数第二个齿轮的半径，以此类推，我们可以得到所有齿轮的半径，然后我们只需要判断这些齿轮的半径是否满足从左到右的单调不降即可。

代码：
```cpp
#include<iostream>
using namespace std;

int main(){
    int n,Q,arr[2000000] = {0},con = 0,i,j,temp,min = 0,max = 0,q[200005],con2 = 0;
    //arr一定要开大
    cin>>n>>Q;
    for(i = 0;i<n;i++){
        cin>>temp;
        if(temp<min){
            min = temp;
        }
        if(temp>max){
            max = temp;
        }
        if(arr[temp] == 1){
            con = 1;
            continue;
        }
        arr[temp] = 1;
    }
    for(i = 1;i<=Q;i++){
        cin>>q[i];
    }
    for(i = 1;i<=Q;i++){
        con2 = 0;
        if(q[i] == 1){
            if(con == 1){
                cout<<"YES"<<endl;
            }else{
                cout<<"NO"<<endl;
            }
        }else{
            for(j = min;j<=(max/q[i])+1;j++){
                if(arr[j] == 0){
                    continue;
                }
                if(arr[j*q[i]] == 1){
                    cout<<"YES"<<endl;
                    con2 = 1;
                    break; 
                }//判断
            }
            if(con2 == 0){
                cout<<"NO"<<endl;
            }
        }
    }
    return 0;
}
```




---

## 作者：sunhaocheng (赞：1)

思路：

输入 $n$ 和 $Q$ 以及 $r$ 和 $q$ 数组。如果需要调换顺序的话，中间的齿轮没有用，要把最后一个齿轮的半径 $×q$ 的第 $i$ 项。因为每个齿轮的线速度是相同的，所以转速和半径成反比，再加上要满足 $Q$ 的第 $i$ 项倍，必须有一个齿轮的 $x×Q$ 的第 $i$ 项 $=q$ 的第 $i$ 项。输出答案。

代码就不附了。

---

## 作者：Kobe_Kuli (赞：1)

## 题意：
$ N $ 个齿轮中每个齿轮保证半径为 $ r_i $，从左到右装起来；给出 $ Q $ 个询问，让你判断能否按一定顺序组装齿轮让最右边齿轮的转速为最左边齿轮的转速的 $ q_i $ 倍。

## 推断：
因为齿轮半径依次为 $ r_1 $ 到 $ r_n $，我们将齿轮的转速比转换为公式。

## 公式：
转换的公式为 $ \frac{r_1}{r_2} \times \frac{r_2}{r_3} \times \frac{r_3}{r_4} \times \cdots \times \frac{r_n-1}{r_n} $。

我们仔细观察这个公式，发现第 $ n-1 $ 项的分母可以与 $ n $ 的分子相乘后相互抵消。

最后简化的等式为 $ \frac{r_1}{r_n} $。

## 方法：
前面我们已经将公式推断出来了，根据推断我们的方法也可以得出。

我们可以先将我们的倍数枚举推断出来，然后在使用桶进行统计，最后直接使用前面的桶即可。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,q;
long long r[200005],a[200005],b[200005];
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++)
		cin>>r[i];
    sort(r+1,r+n+1);
    for(int i=1;i<=n;i++)
		a[r[i]]++;
    for(int i=n<10000?n:n/100;i;i--){
        a[r[i]]--;
        for(int j=r[i];j<=r[n]&&j;j+=r[i])
			if(a[j]!=0)
				b[j/r[i]]=1;
        a[r[i]]++;
    }
    for(int i=1;i<=q;i++){
    	long long x;
    	cin>>x;
        if(b[x]!=0)
			cout<<"YES"<<endl;
        else
			cout<<"NO"<<endl;
	}
}
```
本蒟蒻的第一篇题解，求过。

---

## 作者：oscar0866 (赞：0)

这道题还是有点难度滴。由题目可以推出：相邻齿轮的线速度相同，可以推出第一个齿轮和最后一个齿轮的线速度也是相同的。

**思路**：

对于每个齿轮半径，判断该半径值的所有约数是否为齿轮半径，如果是就将他俩的商标记。

AC 代码：
```cpp
#include<iostream>
#include<stdio.h>
#include<math.h>
using namespace std;
const int N=200005;
int n,q,t;
int st[N];
int a[N],flag[N];   //flag 存当前数组中的数能构成哪些商值，作为 qi 
int main()
{
	scanf("%d %d",&n,&q);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&t);
		st[t]=1;
		a[i]=t;
	}
	//标记数组中任意两个数的商值，分解每个数的约数，将在数组中的约数标记为 1 就行 
	for(int i=1;i<=n;i++)
	{
		int up=sqrt(a[i]);
		
		for(int j=1;j<=up;j++)
		{
			if(a[i]%j==0) 
			{
				//j在数组里，则商就标记为 1 
				if(st[j])  flag[a[i]/j]=1;
				if(st[a[i]/j])   flag[j]=1;
			}
		}
	}
	for(int i=0;i<q;i++)
	{
		scanf("%d",&t);
		if(flag[t]) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}



---

## 作者：GWBailang (赞：0)

#### [原题传送](https://www.luogu.com.cn/problem/P8799)
别看那么多的齿轮，其实真正有用的只有头和尾两个齿轮，我们只需要看它们两个中半径大的是不是半径小的 $q_i$ 倍，也就是大齿轮的半径除小齿轮的半径需要等于 $q_i$，如果没有两个齿轮的半径为 $q_i$ 倍输出 ```NO```，否则输出 ```YES```，注意大小写。

#### 代码：
```
#include<bits/stdc++.h>
using namespace std;
long long hx[2000005];
bool bs[2000005];
int main(){
	long long n,q,da,sr;
	cin>>n>>q;
	for(long long i=1;i<=n;i++){
		cin>>sr;
		if(hx[sr])bs[1]=true;
		//注意判断qi=1，否则你会有1个可怕的WA
		hx[sr]++;
		da=max(sr,da);
	}
	for(long long i=1;i<=da;i++){//看每一个数
		if(hx[i]){//输入的数中有没有这个数
			for(long long j=2;j*i<=da;j++){//j倍
				if(hx[j*i]){//如果有
					bs[j]=true;
				}
			}
		}
	}
	while(q--){
		cin>>sr;
		if(bs[sr])cout<<"YES\n";//如果有为da倍的，就输出YES
		else cout<<"NO\n";//否则输出NO，注意大小写和换行
	}
	return 0;
}
```
###### ~~不出意外这是红名前的最后一片题解，求管理过审。~~

---

## 作者：StarRain3 (赞：0)

来写一个自己的想法。

#### 分析
根据题意容易发现齿轮转动倍数，跟中间那些齿轮半径都没有关系。只跟最开始和最后那个有关系，如果是这个倍数关系是 $n$ 倍，只需要最后那个齿轮的半径是最开始那个的 $n$ 倍就能满足题目所需要求了。

因此首先我们将每个数都存入进去，然后再开一个数组，我们分别用下标表示**这个齿轮的半径**。

如果存在我们就把这个数组的第 $i$ 个赋值为 $1$，如果这个数已经存在，再有一个相同的，我们就将 $f$ 赋值为 $1$，最后判断就可以了。

#### 代码
```
#include<iostream>
using namespace std;
const int N = 2e5+5;
int a[N];
int f = 0,n,i,j,T;
int q[N],f2 = 0;
int Min = 0,Max = 0;
int main(){
    
    cin>>n>>T;
    for(i = 0;i<n;i++){
    	int k;
        cin>>k;
        if(k<Min) Min = k;
        if(k>Max) Max = k;
        
        if(a[k] == 1) f = 1,continue;
        a[k] = 1;
    }
    for(i = 1;i<=T;i++){
    	int q;
    	cin >> q;
        f2 = 0;
        if(q == 1){
            if(f == 1) cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
            
        }else{
            for(j = Min;j<=( Max / q) + 1;j++){
                if(a[j] == 0) continue;
                int Q1=j*q;
                if(a[Q1] == 1){
                  cout<<"YES"<<endl;
                  f2 = 1;
                  break; 
                }
            }
            if(f2 == 0){
            	cout<<"NO"<<endl;
		    }
        }
        
    }
    return 0;
}

```

---

## 作者：__zfy__ (赞：0)

### 思路
如果换顺序的话，中间的齿轮是没有用的，只需将最后一个齿轮的半径 $\times q_i$ 即可（下列这个数称为 $x$）。而且因为每个齿轮的线速度是相同的，所以转速和半径就成反比，再加上要满足 $Q_i$ 倍，就必须有一个齿轮的 $x \times Q_i = q_i$。

### 注意事项：
- 如果 $x \times Q_i = 1$，就说明倍数为 $1$，需要特殊处理。
- 其他倍数需要一个个枚举。
- 有一个相同的就把 $temp$ 设为 $1$。
- 输出是只要判断 $temp$ 是否等于 $1$。

已经解释的很清楚了，代码就不附了。

---

## 作者：SilverLi (赞：0)

[齿轮 の 传送门](https://www.luogu.com.cn/problem/P8799)

这里涉及到一个物理公式，线速度 $v$，角速度 $w$，以及半径 $r$ 之间的关系。

它们之间满足：$v=w\times r$。

而齿轮模型是一个经典的物理模型，**所有的齿轮的线速度都一样**。

对于齿轮 $a$ 和齿轮 $b$ 之间都一定满足：$w_a\times r_a=w_b\times r_b$。

我们设最左边的的齿轮半径为 $r1$ 最右边的齿轮半径为 $r2$，那么使得最右边的齿轮的转速（即角速度）是最左边的齿轮的 $q$ 倍，则需要让 $w_{r1}\times q=w_{r2}$。

观察上面的两个式子可得：$r_a=r_b\times q$。

所以我们只需判断所有齿轮的半径中是否存在两个齿轮的半径是 $q$ 倍的关系。

又因为倍数关系，所以说明两个齿轮的半径其中一个必然是另外一个的因数。

我们定义 $f_i$ 表示是否有半径相差 $q$ 倍的两个齿轮。

我们将齿轮半径**从小到大进行排序**，对于每个齿轮的半径 $r_i$，分解所有的因数。

如果存在某个数 $x$ 是 $r_i$ 的因数，并且之前已经出现过半径为 $x$ 的齿轮，则说明当 $q=\frac{r_i}{x}$ 时，可以完成要求。

每次判断一个数后我们将其放入一个 `set` 中，在判断该数的因数在是否出现也是看 `set` 中是否存在。

因为**每个数的因数一定小于等于数的本身**，所以排序确保了如果一个数的因数存在，那么一定会在它之前出现。

注意一下，齿轮的个数可能只有一个，那么此时左齿轮恰好就是右齿轮，如果查询的 $q$ 为1时，是符合要求的，需要特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
int n,Q,r[N];
int f[N],q;
set<int> s;
int main() {
	cin>>n>>Q;
	for(int i=1;i<=n;i++)	cin>>r[i];
	sort(r+1,r+n+1);
	for(int i=1;i<=n;i++) {
		int v=r[i];
		for(int i=1;i<=v/i;i++) {
			if(v%i==0) {
				//存在这个半径为i的齿轮
				if(s.find(i)!=s.end())	f[v/i]=1;
				//存在这个半径为v/i的齿轮
				if(s.find(v/i)!=s.end())	f[i]=1;
			}
		}
		s.insert(r[i]);
	}
	while(Q--) {
		cin>>q;
		if(n==1&&q==1||f[q])	cout<<"YES"<<endl;
		else	cout<<"NO"<<endl;
	}
    return 0;
}
```

---

## 作者：Kobe_BeanBryant (赞：0)

## [题目传送带](https://www.luogu.com.cn/problem/P8799)
## AC步骤：
如何将这道题的代码打对呢？请先按照下面的步骤进行。
1. 点击题目传送带，先阅读题目自行思考。
2. 理解题意，见题目大意。
3. 然后阅读数据范围，思考方法。
4. 思考后，我们发现这道题是为了计算齿轮。
5. 推出如何算齿轮，详情请见方法推断。
6. 总结方法，开始打代码。

## 题目大意：
在 $ N $ 齿轮中每个齿轮的半径为 $ r_i $，按一定顺序从左到右组装起来后对于 $ Q $ 个疑问，判断能否按一定顺序组装这些齿轮使得最右边的齿轮的转速是最左边的齿轮的 $ q_i $ 倍。
## 方法推断：
先设齿轮半径依次为 $ a_1 $ 到 $ a_n $，那么齿轮的转速比分别为 $ \frac{a_1}{a_2} \times \frac{a_2}{a_3} \times \frac{a_3}{a_4} \times \cdots \times \frac{a_n-1}{a_n} $，简化得到等式为 $ \frac{a_1}{a_n} $。

就是说需要在 $ N $ 个数中找到两个商为 $ q_i $ 的数。

我们先将每个数的倍数列举出来进行枚举，然后判断是否存在一个数为它的倍数。

总结：根据推断，对于这道题我们可以先枚举倍数后直接运用桶。
## AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=2e5+10;
int n,m,q;
int r[Maxn],t[Maxn],ans[Maxn];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) scanf("%d",&r[i]);
	sort(r+1,r+n+1);
	for(int i=1; i<=n; i++) t[r[i]]++;//桶存储，考虑到可会有重复的部分，所以将值加一
	for(int i=n<10000?n:n/100; i; i--) {
		t[r[i]]--;//因为齿轮半径可重复，所以这里需要减一
		for(int j=r[i]; j<=r[n]&&j; j+=r[i]) if(t[j]) ans[j/r[i]]=1;//ans数组是存储哪些转速比有解
		t[r[i]]++;//将减去的一加回来
	}
	while(m--) {
		scanf("%d",&q);
		if(ans[q]) printf("YES\n");
		else printf("NO\n");//直接使用桶
	}
	return 0;
}
```

---


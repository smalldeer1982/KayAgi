# [信息与未来 2019] 新斐波那契数列

## 题目描述

给定正整数 $a(a\ge1)$，新斐波那契数列 $f_a$ 按如下方式定义：
- $f_a(1) = 1$；
- $f_a(2) = a$；
- $f_a(n) = f_a(n − 1) + f_a(n − 2)\ (n > 2)$。

例如，给定 $a = 4$，有 $f_4(1) = 1, f_4(2) = 4, f_4(3) = 5, f_4(4) = 9, f_4(5) = 14, \cdots$ 现在已知新斐波那契数列中的一项 $x$，但并不知道 $n$ 和 $a$ 的值是多少。请你求出所有可能的 $n,a(n\ge2)$ 满足 $f_a(n) = x$。

## 说明/提示

对于 $60\%$ 的测试数据，有 $2\le x\le10^6$。

对于 $100\%$ 的测试数据，有 $2\le x\le10^9,1\le T\le20$。
> 本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
2
9
123```

### 输出

```
2 9
3 8
4 4
2 123
3 122
4 61
6 24
10 3```

# 题解

## 作者：LoongPig (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/B3752)

## 题目思路

我们可以设传统的斐波那契数列第 $n$ 项为 $f(n)$。

则新斐波那契数列的通项公式可以表示为：
$$f_a(n)=a\times f(n-1)+f(n-2)$$



然后我们要求的就变成了对于新斐波那契数列的某一项 $x$，解方程：
$$a\times f(n-1)=[x-f(n-2)] $$

且 $x\geq f(n-2)$，$f(n-1)\mid (x-f(n-2))$，$a\geq 1$。

## 代码实现

首先，预处理传统的斐波那契数列；

然后，特殊处理 $n=2$，因为根据定义 $f_a(2)=a$，直接得到解 $(2,x)$；

最后，枚举 $n$ 的值，如果对应的 $a$ 合法，那么就输出这个解。

## 题目标程
```cpp
#include <bits/stdc++.h>
using namespace std;
int fib[50] = {0, 1, 1};//传统斐波那契数列
void init() {
	//预处理
	for (int i = 3; i <= 50; i++) {
		fib[i] = fib[i - 1] + fib[i - 2];
	}
}
int main() {
	init();
	int T;
	scanf("%d", &T);
	while (T--) {
		int x;
		scanf("%d", &x);
		int m = 2;
		while (fib[m] <= x) {
			m++;
			//求出 n 的范围
		}
		printf("%d %d\n", 2, x);
		//输出特殊解
		for (int i = 3; i < m; ++i) {
			int t = x - fib[i - 2];
			if (t > 0 && fib[i - 1] != 0 && t % fib[i - 1] == 0) {
				//判断对应的 a 是否合法
				int a = t / fib[i - 1];
				if (a >= 1) {
					printf("%d %d\n", i, a);
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：Noah03 (赞：3)

### 题目大意

[题目传送门](https://www.luogu.com.cn/problem/B3752)

已知新斐波那契数列 $f_a$，令 $f_a$ 的第 $n$ 项为 $f_a(n)$，输入 $x$，求出所有的 $a$ 和 $n$，满足 $f_a(n)=x$。

其中 $f_a$ 的定义如下：

- $f_a(1)=1$；
- $f_a(2)=a$；
- $f_a(n)=f_a(n-1)+f_a(n-2)$。

### 思路&解析&做法

设原斐波那契数列的第 $n$ 项为 $F(n)$，则可以得到 $f_a(n)=a \times F(n-1)+F(n-2)$（证明不难，不再给出）。

有了这个式子后，我们就可以枚举 $i$，然后使 $a \times F(i-1)+F(i-2)=x$即可，所以我们可以得到每一个 $i$ 所对应的 $a$：
$$a=\frac{x-F(i-2)}{F(i-1)}$$
那么我们就只需要判断 $a$ 是否为整数就好了，循环什么时候结束呢？应该是在 $x-F(i-2)<F(i-1)$ 的时候，因为分子都小于分母了，所以一定不整除，此时就可以结束循环了。

### 代码

直接上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		ll x;
		scanf("%lld",&x);
		ll a=1,b=0;
		for(int i=2;;i++){
			if (x-b<a) break;
			if ((x-b)%a==0) printf("%lld %lld\n",i,(x-b)/a);
			int c=a;a=b+c;b=c; 
		}
	}
	return 0;
}
```

代码中，使用 $a,b$ 分别代表 $F(n-1),F(n-2)$，节省空间。

### 写在最后
本人写题解可能会出现语言上的不严谨和其他错误，如有误，请 $dalao$ 指出！

---

## 作者：RonL (赞：2)

[传送门](https://www.luogu.com.cn/problem/B3752)

# 题解 by RonL

这道题~~一看就像~~是一个数学题。拿到这道题如果直接用暴力的方法做，可是妥妥的超时。这个时候我们就要想一想，有没有别的方案，把这个暴力枚举的过程精简一下呢？

这个时候我们就会发现，其实我们可以把这个新斐波那契数列表示成一下这个形式：

对于一个新斐波那契数列 $f_a$，
$$
f_a(1) = 1+0a,\\ 
f_a(2) = 0+1a,\\
f_a(3) = 1+a,\\
f_a(4) = 1+2a,\\
f_a(5) = 2+3a,\\
f_a(6) = 3+5a,\\
f_a(7) = 5+8a...
$$

我们会轻而易举地发现，每一项中的一个常数和一个系数，这些常数可以形成一个数列 $f_b$：
$$
f_b(1) = 1,\\
f_b(2) = 0,\\
f_b(n) = f_b(n-1)+f_b(n-2)(n>2)
$$

再看 $a$ 前面的系数，也可以形成一个数列 $f_c$：
$$
f_c(1) = 0,\\
f_c(2) = 1,\\
f_c(n) = f_c(n-1)+f_c(n-2)(n>2)
$$

知道了这个就好办了，我们可以把这两个数列预处理出来，这样过一会枚举的时候就不用浪费太多的空间和时间。

```cpp
//预处理
const int N = 100005;
pair<int,int> arr[N];
arr[1] = make_pair(1,0);
    arr[2] = make_pair(0,1);
    for(int i=3;i<N;i++){
        arr[i] = make_pair(arr[i-1].first+arr[i-2].first,arr[i-1].second+arr[i-2].second);
    }
```
这样我们再来枚举，此处不再赘述，见代码：
```cpp
//对于每一组样例
int x;
    cin >> x;
    for(int i=2;i<N;i++){
        if(arr[i].second == 0)continue;\\防止除以0
        if(x-arr[i].first < 0)continue;\\剪枝
        if((x-arr[i].first)/arr[i].second*arr[i].second == x-arr[i].first && (x-arr[i].first)>=0){//判断是否整除
            int a = (x-arr[i].first)/arr[i].second;
            if(a >= 1)cout << i << " " << a << endl;
        }
    }
```
**一定要注意是多测呀！**

完整代码如下
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 100005;

pair<int,int> arr[N];

void solve(){
    //1+0a,0+a,1+a,1+2a,2+3a,3+5a
    int x;
    cin >> x;
    for(int i=2;i<N;i++){
        if(arr[i].second == 0)continue;
        if(x-arr[i].first < 0)continue;
        if((x-arr[i].first)/arr[i].second*arr[i].second == x-arr[i].first && (x-arr[i].first)>=0){
            int a = (x-arr[i].first)/arr[i].second;
            if(a >= 1)cout << i << " " << a << endl;
        }
    }

}

signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    arr[1] = make_pair(1,0);
    arr[2] = make_pair(0,1);
    for(int i=3;i<N;i++){
        arr[i] = make_pair(arr[i-1].first+arr[i-2].first,arr[i-1].second+arr[i-2].second);
    }

    int T;
    cin >> T;
    while(T--)solve();
    return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/213761418)

---

## 作者：getchar_unlocked (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3752)

### 思路

普通的斐波那契数列递推公式为：

$$F(n)=F(n-1)+F(n-2)$$

同理，放到本题的“新斐波那契数列”中即为：

$$f_a(n)=F(n-2)\times a+F(n-1)$$

由于给定 $f_a(n)=x$，将 $x$ 代入，解得：

$$a=\frac{x-F(n-1)}{F(n-2)}$$

令 $M$ 为斐波那契数列的长度（即至少需要几个数使 $F_M>x$）。枚举 $N$，若 $x-F(n-3)$ 是 $F(n-2)$ 的倍数，就输出 $N$ 和 $\frac{x-F(n-3)}{F(n-2)}$。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=105;
int f[N];
int main(){
	int T=read();
	while(T--){
		int x=read();
		f[0]=f[1]=1;
		int m=2;
		while(f[m-1]+f[m-2]<=x)
			f[m]=f[m-1]+f[m-2],++m;
		printf("2 %d\n",x);
		for(int i=3;i<=m;++i)
			if((x-f[i-3])%f[i-2]==0&&(x-f[i-3])/f[i-2]>=1)
				printf("%d %d\n",i,(x-f[i-3])/f[i-2]);
	}
	return 0;
}
```

---

## 作者：copper_ingot (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3752)

设原斐波那契数列的第 $i$ 项为 $F_i$，即 $F_0=0,F_1=1,F_i=F_{i-1}+F_{i-2}(i>1)$。

我们看看新斐波那契数列的每一项：

$$f_{a,1}=1,f_{a,2}=a,f_{a,3}=a+1,f_{a,4}=2a+1,f_{a,5}=3a+2\cdots$$

我们可以提出猜想：对于每个 $i \ge 2$，$f_{a,i}=aF_{i-1}+F_{i-2}$。

当 $i=2$ 或 $i=3$ 时，上式显然成立。

当 $i>3$ 时，假设已经证明对于 $i-1$ 和 $i-2$ 成立，$f_{a,i}=f_{a,i-1}+f_{a,i-2}=aF_{i-2}+F_{i-3}+aF_{i-3}+F_{i-4}=aF_{i-1}+F_{i-2}$，成立。所以上述猜想成立。

接下来就好办了：如果对于某个 $i$ 使得 $aF_{i-1}+F_{i-2}=x$，那么 $a=\dfrac{x-F_{i-2}}{F_{i-1}}$，如果 $a$ 是整数就输出它。当 $x-F_{i-2}<F_{i-1}$ 时退出。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t, x, a, b;//a为F[i-1]，b为F[i-2]
signed main(){
	scanf("%lld", &t);
	while (t--){
		scanf("%lld", &x);
		a = 1, b = 0;//记得初始化
		for (int i = 2; ; i++){//i从2开始
			if ((x - b) % a == 0) printf("%lld %lld\n", i, (x - b) / a);
			if (x - b < a) break;//终止条件：x-b<a
			int c = a; a = b + c, b = c;//递推
		}
	}
	return 0;
}
```

---

## 作者：2b2b2bbb (赞：0)

# 思路
|项数|$1$|$2$|$3$|$4$|$5$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|答案|$1$|$a$|$1 + a$|$1 + 2a$|$2 + 3a$|

我们观察表格可以发现两个斐波那契数列，~~什么？你没发现?那别写完了~~我们将每一项的两个答案补全，然后观察 $a$ 的系数和另一个常数。

然后，我们就发现了一个开头是 $1$ 和 $0$ 的常数斐波那契数列，和开头是 $0$ 和 $1$ 的系数斐波那契数列。根据这个性质我们就可以能够求出 $a$。


```cpp
for(int i = 3 ; i <= 50 ; i ++){
    a[i] = a[i - 1] + a[i - 2];
}
for(int i = 3 ; i <= 50 ; i ++){
    b[i] = b[i - 1] + b[i - 2];
}
```

然后，我们就可以枚举 $n$，当我们知道这是第几个的时候，我们常数知道，$a$ 的系数也知道，那么 $a$ 就知道。但是，因为 $a$ 是整数所以要看看通过 $x$ 和 $i$ 求出的 $a$ 是否正确哦。
## code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000005],b[1000005];
int main(){
	int T;
	cin >> T;
	while(T --){
		a[1] = 0;
		a[2] = 1;
		b[1] = 1;
		b[2] = 0;
		long long x;
		cin >> x;
		for(int i = 3 ; i <= 50 ; i ++){
			a[i] = a[i - 1] + a[i - 2];
		}
		for(int i = 3 ; i <= 50 ; i ++){
			b[i] = b[i - 1] + b[i - 2];
		}
		for(int i = 2 ; i <= 50 ; i ++){
			if(x < b[i] || (x - b[i]) < a[i]){
				break;
			}
			if((x - b[i]) % a[i] == 0){
				cout << i << " " << (x - b[i]) / a[i] << endl;
			}
			
		}	
	}
	
	return 0;
}
```

---

## 作者：piano_pei (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/B3752)

### 思路

首先，朴素的斐波那契数列（$f_1=f_2=1$）的增长是极快的，$n=45$ 时 $f_i>10^9$，所以我们可以直接暴力枚举长度，然后二分确定 $a$。时间复杂度 $O(Tn^2\log x)$，其中 $n=45$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
typedef long long ll;
const int N = 110;
ll f[N];
il bool chk(int i, int mid, int x)
{
	memset(f, 0, sizeof(f));
	f[1] = 1;
	f[2] = mid;
	for(int j = 3;j <= i;++j)
	{
		f[j] = f[j - 1] + f[j - 2];
		if(f[j] > x && j < i) return false;
	}
	return f[i] <= x;
}
int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		int x;
		cin >> x;
		for(int i = 2;i <= 45;++i)
		{
			int l = 1, r = x;
			while(l < r)
			{
				int mid = (l + r + 1) >> 1;
				if(chk(i, mid, x)) l = mid;
				else r = mid - 1;
			}
			chk(i, l, x);
			if(f[i] == x)
				cout << i <<" " << l <<"\n";
		}
	}
	return 0;
}
```

---

## 作者：longhaoyuan (赞：0)

一道纯思路的题。
## 分析：
对于这种数列，一眼就知道 $f$ 一定有规律。很明显的思考方法就是把常数项和带 $a$ 的项分开思考。可以发现：由于  常数项  和  带 $a$ 的项的系数  构成的列表  都满足正常斐波那契数列的规律，所以……  
令 $F(x)$ 表示数列 $1,0,1,1,2,3,5,8,13,\cdots$。则 $f_a$ 数列为：
$$
f_a(1)=F(1)+F(2)a=1+0a \\
f_a(2)=F(2)+F(3)a=0+1a \\
f_a(3)=F(3)+F(4)a=1+1a \\
f_a(4)=F(4)+F(5)a=1+2a \\
f_a(5)=F(5)+F(6)a=2+3a \\
f_a(6)=F(6)+F(7)a=3+5a \\
f_a(7)=F(7)+F(8)a=5+8a \\
$$
这下，程序就好写了。
对于每个询问，直接跑一边斐波那契数列。由于斐波那契数列增长极快，所以根本不用担心复杂度问题。
Demo:
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double dbl;

int main(){
	int T; scanf("%d", &T);
	while (T--){
		ll x, a = 0, b = 1, c = 2; scanf("%lld", &x);
		while (a < x){
			if ((x - a) % b == 0) printf("%lld %lld\n", c, (x - a) / b);
			int t = a;
			a = b;
			b += t;
			c++;
		}
	}
    return 0;
}
```

---

## 作者：YWT130508 (赞：0)

这道题主要跟数学有关，已知斐波那契数列的递推公式为：
$$
f(1) = 1,f(2) = 1,f(i) = f(i - 1) + f(i - 2)
$$
而这个新斐波那契数列的公式为：
$$
f_a(1) = 1,f_a(2) = a,f_a(i) = f_a(i - 1) + f_a(i - 2)
$$
举个栗子：
如果 $a = 4$，那么 $f_a(1) = 1,f(2)_a = 4,f_a(3) = 1 \times 1 + 4 \times 1,f_a(4) = 1 \times 1 + 4 \times 2,f_a(5) = 1 \times 2 + 4 \times 3,f_a(6) = 1 \times 3 + 4 \times 5$，是不是觉得眼熟，这两个数的系数是一个斐波那契数列。所以我们可以推出 $f_a$ 的递推公式：
$$
f_a(1) = 1,f_a(i) = f(i - 2) + f(i - 1) \times a
$$
则反推出：
$$
a = \frac{f_a(i) - f(i - 2)}{f(i - 1)}
$$
而题目给出的 $x$ 正是公式中的 $f_a(i)$，那题目就变成了一个枚举，不用想，只需枚举小于 $x$ 的所有 $f(i - 1)$ 即可，如果这个分式求出的值是整数，就直接输出。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long fib[65],t,n;
int main(){
//freopen(".in","r",stdin);
//freopen(".out","w",stdout);
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
fib[1]=fib[2]=1;
for(int i=3;i<=60;i++){
	fib[i]=fib[i-1]+fib[i-2];
}
cin>>t;
while(t--){
	cin>>n;
	int m=1;
	while(fib[m]<n)m++;
	for(int i=2;i<=m;i++){
		int x=(n-fib[i-2])%fib[i-1];
		if(!x)cout<<i<<' '<<(n-fib[i-2])/fib[i-1]<<endl;
	}
}
return 0;
}
```

---


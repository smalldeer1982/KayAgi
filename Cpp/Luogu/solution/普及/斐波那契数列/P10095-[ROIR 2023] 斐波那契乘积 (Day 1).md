# [ROIR 2023] 斐波那契乘积 (Day 1)

## 题目背景

翻译自 [ROIR 2023 D1T2](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day1.pdf)。

斐波那契数指斐波那契数列（$f_0=1,f_1=1,f_i=f_{i-2}+f_{i-1}$）中出现的数。

## 题目描述

给定一个自然数 $n$，求出将其表示为若干个大于 $1$ 的斐波那契数的乘积的方案数。

## 说明/提示

样例解释：
- $2=2$。
- $7$ 无法被表示为斐波那契乘积。
- $8=8=2\times2\times2$。
- $40=5\times8=2\times2\times2\times5$。
- $64=8\times8=2\times2\times2\times8=2\times2\times2\times2\times2\times2$。

本题使用捆绑测试。

| 子任务编号 | 分值 | $2\le n\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $100$ |
| $2$ | $17$ | $10^5$ |
| $3$ | $9$ | $n$ 是 $2$ 的整数次幂 |
| $4$ | $38$ | $10^9$ |
| $5$ | $21$ | $10^{18}$ |

对于所有数据，$1\le t\le50$，$2\le n\le10^{18}$。

## 样例 #1

### 输入

```
5
2
7
8
40
64```

### 输出

```
1
0
2
2
3```

# 题解

## 作者：Nightsky_Stars (赞：15)

因为在 $10^{18}$ 的范围的斐波那契数只有 $86$ 项，所以考虑暴搜。

看每一个斐波那契数能否整除 $n$，能就除掉接着找，不能就从比他小的下一个开始。

如果 $n = 1$，就不能再除了，以及如果除数为 $1$ 时，也不能继续。
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll f[105]={1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,308061521170129,498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676221,23416728348467685,37889062373143906,61305790721611591,99194853094755497,160500643816367088,259695496911122585,420196140727489673,679891637638612258,1100087778366101931};//预处理斐波那契数
ll dfs(ll n,ll x){
	if(n==1){
		return 1;
	}
	if(x==1){
		return 0;
	}//处理边界
	while(n<f[x]){
		x--;
	}
	ll ans=0;
	if(!(n%f[x])){
		ans+=dfs(n/f[x],x);//选这个数
	}
	return ans+dfs(n,x-1);//不选这个数，进入下一层
}
int main(){
	ll t,n;
	cin>>t;
	while(t--){
		cin>>n;
		cout<<dfs(n,86)<<"\n";
	}
	return 0;
}
```


---

## 作者：Mu_shao (赞：8)

### 思路
斐波那契数列增长极快，$10^{18}$ 内只有 $86$ 个数，直接暴搜。
#### 出口
1. 当 $n = 1$，不能继续除，介时退出。介时退出。
2. 当 $k = 0$ 或 $k = 1$ 时，数列都是 $1$，无意义会死循环，介时退出。

为避免多余操作，寻找第一个小于 $a$ 的数 $x$。

除得尽，接着除。 否则，往下找能除尽的。
### Code
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll F[90] = {1, 1};
ll T, n;
ll dfs(ll a, ll x) {
	if (a == 1) return 1;  //a等于1时,无法继续除,返回1
	if (x <= 1) return 0;  //k<=2时斐波那契数为1， 无法进行
	while (a < F[x]) x--;
	ll ans = 0;
	if (!(a % F[x])) {
		ans += dfs(a/F[x], x);
	}
	return ans + dfs(a, x-1);
}

int main() {
	scanf("%lld", &T);
	for (ll i = 2;i <= 86; i++)
		F[i] = F [i-1] + F[i-2];  //预处理
	while(T--) {
		scanf("%lld", &n);
		printf("%d\n", dfs(n,86));
	}
	return 0;
}
```


---

## 作者：cff_0102 (赞：6)

据官方题解说，这题 DP 速度不如递归。

先把斐波那契数列给跑一遍。

```cpp
fib.push_back(2);
fib.push_back(3);
ll f1 = 2;
ll f2 = 3;
while (f1 + f2 <= MAX) {
    fib.push_back(f1 + f2);
    ll t = f1 + f2;
    f1 = f2;
    f2 = t;
}
```

接着，编写一个函数，它会返回将 $n$ 分解为斐波那契乘积的方法数。

对于每个 $n$，直接从头到尾枚举斐波那契数列中的数，碰到一个 $n$ 的因数 $x$ 就直接递归调用自己，传参 $\dfrac{n}x$ 还有目前枚举到的斐波那契数下标（防止重复枚举前面的因数），直到最后 $n=1$，或者已经枚举完范围内的斐波那契数了，或者 $n$ 已经小于当前枚举的数，都有返回，其中注意 $n=1$ 时要返回 $1$。

```cpp
ll bt(ll n, int p) {
    if (n == 1) return 1;
    if (p >= fib.size()) return 0;
    if (n < fib[p]) return 0;
    ll res = bt(n, p + 1);
    if (n % fib[p] == 0) {
        res += bt(n / fib[p], p);
    }
    return res;
}
```

---

## 作者：huangzixi071018 (赞：4)

问题：给定一个自然数 $n$ ，求出将其表示为大于 $1$ 的斐波那契数的乘积的方式数量。

思路：可以反过来想，将 $n$ 拆成大于 $1$ 的斐波那契数的乘积，提前预处理一个数组 $f$ 存所有小于 $n$ 的斐波那契数，发现只有 $88$ 个，于是可以用 DFS 算法来解，不断对 $n$ 试除直到 $n$ 除到只剩 $1$ 或除数大于 $n$ 为止。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll f[105],s;
void dfs(ll x,ll n){
	if(n==1){
		s++;
		return ;
	}
	if(f[x]>n){
		return ;
	}
	ll k=n;
	while(k%f[x]==0){
		dfs(x+1,k/f[x]);
		k/=f[x];
	}
	dfs(x+1,n);
}
int main(){
	ll t,n,len=1;
	f[0]=1;
	f[1]=1;
	while(f[len]<=1e18){
		f[len+1]=f[len]+f[len-1];
		len++;
	}
	cin>>t;
	while(t--){
		cin>>n;
		s=0;
		dfs(2,n);
		cout<<s<<"\n";
	}
	return 0;
}
```


---

## 作者：I_AK_CTS (赞：3)

# 解题思路
首先发现斐波那契数列增长速度非常之快，在 `long long` 范围内的话大概只能有 $85$ 项，考虑暴力搜索。

发现数列中除了 $1$ 以外最小的就是 $2$，那么假设全部选择 $2$ 这个因子，那么也只需要 $64$ 个，所以递归次数不会太多。

思路就没了，关键还有些代码细节。
1. `long long` 千万别忘了，否则十年 OI 一场空了。
2. 递归的时候我们不用考虑太多。以前的暴力搜索大部分都是判断我们能选什么，而这次我们只考虑选不选这个阶段。如果看不懂的话可以参考代码。

# code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t;
const int N = 1e18, M = 1e6 + 6;
ll len, f[M];
ll dfs(ll n, ll id) {
    if (n == 1) return 1;
    if (id == 1) return 0;//做个解释，此时n肯定不是1，但是我们的id已经到1了，那么这个时候无论如何也凑不出n了，所以返回0就行
    while (n < f[id]) id--;
    ll ans = 0;
    if (n % f[id] == 0) ans += dfs(n / f[id], id);//如上，我们选这个数
    return ans + dfs(n, id - 1);//不选这个数，进入下一层
}
int main() {
    cin >> t;
    f[0] = 1, f[1] = 1;
    len = 1;
    while (true) {
        f[len + 1] = f[len] + f[len - 1];
        len++;
        if (f[len] > N) break;
    }
    len--;
    while (t--) {
        ll n;
        cin >> n;
        cout << dfs(n, len) << endl;
    }
    return 0;
}
```

完结撒花。

---

## 作者：b1tset (赞：2)

### 思路

很简单，预处理出斐波那契数列小于 $10^8$ 的每一项并检查是否可以整除。于是爆搜即可。

我们就可以打出如下代码，[698ms](https://www.luogu.com.cn/record/144562874)：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

LL f[100];
int res = 0;

void dfs(LL x, int k)
{
	if (k == 87) return ;
    if (x == 1) { res++; return ; }
    
    if (x % f[k] == 0)
    	dfs(x / f[k], k);
	
    dfs(x, k + 1);
}

int main()
{
    f[0] = f[1] = 1;
    for (int i = 2; i <= 86; i++)
        f[i] = f[i - 1] + f[i - 2];

    int t; LL x;
    scanf("%d", &t);
    while (t--)
    {
    	res = 0; 
	    scanf("%lld", &x);
	    dfs(x, 2);
	    printf("%d\n", res);
	}
    return 0;
}
```

### 考虑优化

尽管通过了，但是还可以优化。我们不需要一个一个搜索下去，可以用 ```for``` 直接将所有可以整除的数找出来并搜索，使得搜索深度变小。

核心代码如下，[31ms](https://www.luogu.com.cn/record/144562963)，应该是**目前**的最优解:

```cpp
void dfs(LL x, int k)
{
    if (x == 1) { res++; return ; }
    for (int i = k; i >= 2; i--)
        if (x % f[i] == 0)
            dfs(x / f[i], i);
}

```

---

## 作者：Loser_Syx (赞：1)

考虑算出 $\leq 10^{18}$ 的斐波那契数，因为只有 $86$ 个，所以考虑爆搜。

因为一个数 $n$ 的因子最多有 $\log n$ 个，而 $\log n\ (n \leq 10^{18})$ 又严格小于 $\log 2^{64}$，可以理解为每个因子最多 $64$ 个。

则 $86$ 个数每个最多 $64$ 个一共有 $86\times 64=5504$ 个数，对于 $n$ 的答案也只有这 $5504$ 个数有效，直接暴力从大到小除即可。

复杂度大约为 $O(t \log^2 n)$。

```cpp
int fib[1010], len=1, up=1e18;
int dfs(int n, int i) {
	if (n==1) return 1;
	if (i==1) return 0;
	while (n<fib[i])i--;
	int ans=0;
	if (n%fib[i]==0) ans+=dfs(n/fib[i],i);
	return ans+dfs(n,i-1);
}
signed main() {
	fib[0]=fib[1]=1;
	while (fib[len]+fib[len-1]<=up) fib[len+1]=fib[len-1]+fib[len],++len;
	int t=read();
	while (t--) {
		write(dfs(read(),len),'\n');
	}
	return 0;
}
```

---

## 作者：wflhx2011 (赞：1)

# Solution

声明：斐波那契数以下皆为从 $1$ 开始。

看到这道题，第一想法就是暴力，看每一个斐波那契数能否整除 $n$，能就除掉接着找，不能就从比他小的下一个开始。

事实上，这就是正解！

1. 因为斐波那契数增长速度是惊人的，在 $10^{18}$ 内也只有 $86$ 个，	所以完全能预处理。

1. 假设反复除以 $2$ ，最多也才 $60$ 左右次，超不了一点。

这道题就非常简单了，我用递归函数做的：

设 $\operatorname{dfs}(n,k)$ 为 $n$ 除以第 $k$ 个斐波那契数。

1. 出口

不难想到，如果 $n=1$，就不能继续除；如果 $n\ne1$ 并且 $k=1$ 或 $2$，即要除的斐波那契数为 $1$，也不行。

2. 过程 

首先为避免浪费递归次数，我们先将 $k$ 设为第一个小于等于 $n$ 的数。

之后，如果除尽了，就除掉后接着除。

否则，就接着往下找能除尽的。

代码比较简洁：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,bp[90];
long long dfs(long long n,long long k)
{
	if(n==1)
		return 1;
	if(k<=2)
		return 0;
	while(bp[k]>n)
		k--;
	long long ans=0;
	if(n%bp[k]==0)
		ans+=dfs(n/bp[k],k);
	return ans+dfs(n,k-1);
}
int main()
{
	cin>>t;
	bp[0]=bp[1]=1;
	for(long long i=2;i<=86;i++)
		bp[i]=bp[i-1]+bp[i-2];
	while(t--)
	{
		cin>>n;
		cout<<dfs(n,86)<<endl;
	}
	return 0;
}

---

## 作者：IcyFoxer_XZY (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10095)

### 分析

这题我们可以使用递归搜索的方式去枚举数量。我们先要构建出斐波那契数列，然后对于每个输入，从这个数开始依次往下枚举斐波那契数，最后统计数量。

注意看题目数据范围，不要掉坑了。

我们可以发现大小在 $10^{18}$ 内的斐波那契数有 $86$ 个，那么时间复杂度就是 $O(86t)$ 左右了，显然能通过本题。

### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int fib[100005],tot,t;
int dfs(int n,int dep){//递归求解
	if(n==1)return 1;
	if(dep<=1)return 0;//题目要求用大于1的树表示,矛盾返回0
	while(n<fib[dep])dep--;//先求出小于n的最大的斐波那契数 
	int ans=0;
	if(n%fib[dep]==0)ans+=dfs(n/fib[dep],dep);//当前数满足,从当前数开始继续递归 
	return ans+dfs(n,dep-1);//当前数不满足,从下一个数开始递归 
}
signed main(){
	fib[0]=fib[1]=1;
	for(int i=2;;++i){//构建斐波那契数组
		fib[i]=fib[i-2]+fib[i-1];
		if(fib[i]>1e18){
			tot=i-1;
			break;
		}
	}
	cin>>t;
	while(t--){
		int n;
		scanf("%lld",&n);
		printf("%lld\n",dfs(n,tot));
	}
	return 0;
}
```
Bye！

---

## 作者：Aveiro7 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10095)

### 题目大意：

斐波那契数指斐波那契数列（$f_0=1,f_1=1,f_i=f_{i-2}+f_{i-1}$）中出现的数。

给定一个自然数 $n$，求出将其表示为大于 $1$ 的斐波那契数的乘积的方式数量。


### 思路：

斐波那契数列增长得很快，在 $10^{18}$ 范围内的斐波那契数仅有 $86$ 个，所以这 $86$ 项我们可以枚举出来，随后使用 DFS 即可解决。

### Code:

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll f[87],T,n,i;
int dfs(ll a, ll b) {
	ll ans=0;
	if (a==1)
		return 1;  
	if (b<=1) 
		return 0;
	while(a<f[b]) 
		b--;
	if (a%f[b]==0) {
		ans+=dfs(a/f[b],b);
	}
	return ans+dfs(a,b-1);
}

int main() {
	cin>>T;
	f[0]=1;
	f[1]=1;
	for(i=2;i<=86;i++)f[i]=f[i-1] + f[i-2];//计算前86个斐波那契数 
	while(T--) 
	{
		cin>>n; 
		cout<<dfs(n,86)<<endl;
	}
	return 0;
}
```


---

## 作者：wht_1218 (赞：0)

已知 $10^{18}$ 内只有 $86$ 个数在斐波那契数列中，所以搜索的时间复杂度~~完全~~足够。

注意：枚举种数时，要**从 $2$ 开始**，从 $1$ 开始会~~炸~~死循环。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int fib[100]={1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,308061521170129,498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676221,23416728348467685,37889062373143906,61305790721611591,99194853094755497,160500643816367088,259695496911122585,420196140727489673,679891637638612258},ans=0;
void check(int n,int now){//统计方案
	if(y==1){
		ans++;
		return;
	}//成功的方案。
    if(n==87)return;//醒醒，超限啦。
	if(now%fib[x]==0)check(now/fib[x]);//能除尽的除一下试试。
	check(n+1,now);
   return;
}signed main(){
    int T,n;
	cin>>T;
	while(T--){
    		ans=0;//对于每一组数据，ans都要归0。
		scanf("%lld",&n);
		check(1,n);
		printf("%d\n",ans);
	}return 0;
}
```
~~偷偷埋了几个坑，应该没人发现吧。~~

---

## 作者：jbjbjbjb (赞：0)

斐波那契数列第 $86$ 项是 $679891637638612258$，第 $87$ 项是 $1100087778366101931$，所以枚举到第 $86$ 项。因为 $86$ 很小，所以可以直接深搜。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[100],s;//用long long
void g(int x,long long y){
	if(y==1){
		s++;
		return;
	}
	if(x==87)return;
	if(y%f[x]==0)g(x,y/f[x]);//可以整除，就按可以整除计算
	g(x+1,y);//继续往后枚举
}
int main()
{
	f[0]=1,f[1]=1;
	for(int i=2;i<=86;i++){
		f[i]=f[i-1]+f[i-2];//计算斐波那契数列
	}
	int t;
	long long n;
	scanf("%d",&t);
	while(t--){
		scanf("%lld",&n);
		s=0;
		g(2,n);//计算种数，从第二项开始是因为第二项是第一个大于1的斐波那契数
		printf("%d\n",s);
	}
	return 0;
}

```


---

## 作者：luoguDomi (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/solution/P10095)

这道题可以使用递归。

我们把斐波那契数列算到给出的数据中最大的数据的一半大小，再把每个数据都去与斐波那契数列数列中的数相除，进行分解并记录方案数，再把无法分解的输出 $0$ 即可。我们在除的时候每发现一个数可以与之整除，我们就先记为一种方案，再对其中一个数除，分解一次记一次，直到无法分解时再去除另一个数。整个过程有点类似于 dfs 搜索二叉树。

以下是代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long f,n[55],bp[105];/*用int会爆*/ 
int t; 
long long a(long long N,long long k){/*递归函数*/ 
	if(N==1)return 1;
	if(k<=2)return 0;
	while(bp[k]>N)k--;
	long long ans=0;
	if(n%bp[k]==0)ans+=a(n/bp[k],k);/*调用自己进行递归*/ 
	return ans+a(n,k-1);
}
int main(){
	cin>>t;
	for(int i=1;i<=t;i++)cin>>n[i];
	sort(n+1,n+t+1);
	f=n[1]/2,bp[1]=bp[2]=1;/*设定递归和斐波那契数列范围，初始化斐波那契数列的前 2 位*/ 
	for(int i=3;i<=f;i++)bp[i]=bp[i-1]+bp[i-2];/*计算斐波那契数列*/ 
	for(int i=1;i<=t;i++)cout<<a(n[i],f)<<endl;
	return 0;
}
```

---

## 作者：2021zjhs005 (赞：0)

Description
------------

给定 $T$ 个 $n$，求 $n$ 被分为**严格大于 $1$** 的**斐波那契数**的乘积的方案数。

斐波那契数列：$f_0 = f_1 = 1$，$f_i = f_{i-1} + f_{i-2}$（$i\le 2$）。

附：题目中斐波那契数列是从 $0$ 开始，但以下文章默认从 $1$ 开始，可能会带来不便。

solution
------------
首先容易想到递归暴力，但这其实就是正解。

观察数据，$n$ 最多只有 $10^{18}$。你可以用[该代码](https://www.luogu.com.cn/paste/079aw0b2)测一测，发现有 $86$ 个在 $10^{18}$ 以内的斐波那契数。

$\boxed{1}\ \ $把这 $86$ 个斐波那契数先预处理。


我们不妨假设 $n$ 除下去除的都是 $2$，那么最多会除进行 $\log n$ 次，因此不会 `TLE`。

#### $\boxed{2}\ \ $正式进行 dfs：

我们不妨设 $dfs(n,step)$ 表示 $n$ 准备除第 $step$ 个斐波那契数，但是不知道能不能被除尽。

- 边界值$\ \ \begin{cases}n=1\\step=1\end{cases}$

  分别表示$n=1$，不可能继续除了，以及 $step=1$，除法不会除 $f_1 = 1$，除数必须严格大于 $1$。
  
- 调整 $f_{step}$ 直到 $f_{step}\le n$。

- 分两种情况递归，即 $n\bmod f_{step} = 0$ 和 $n\bmod f_{step} \ne 0$。

code
------------
```cpp
#include <iostream>
using namespace std;
#define int long long
int T,n,i,f[90];
inline int read(){int s=0;char c=getchar();while(!isdigit(c)) c=getchar();while(isdigit(c)){s=(s<<1)+(s<<3)+(c^48);c=getchar();}return s;}
int dfs(int n,int step){
    if(n==1) return 1;
    if(step<=2) return 0;//两个边界值。
    while(f[step]>n) step--;//调整 step。
    int ans=0;
    if(!(n%f[step])) ans+=dfs(n/f[step],step);//如果除得尽，继续选这个数并且整除。
    return ans+dfs(n,step-1);//否则选下一个数，不进行除法。
}
signed main(){
    T=read();
    f[1]=f[2]=1;
    for(i=3;i<=86;i++) f[i]=f[i-1]+f[i-2];//预处理斐波那契数。
    while(T--){
        n=read();
        printf("%lld\n",dfs(n,86));
    }
    return 0;
}
```

---

## 作者：lgydkkyd (赞：0)

# P10095 [ROIR 2023 Day 1] 斐波那契乘积 题解
不得不说，出题人还是很良心的，因为给的 $n$ 不算大，而时间限制给了一秒，要知道由于斐波那契数列的增长速度极快，所以第一百项时就已经超过了题目给的范围。于是我们可以放心写爆搜了。

------------

接下来上核心思路，通过粗略的估计我们发现对 $n$ 而言的答案大约在五千五百多，上面可能讲的太快了，我们补充一个证明，要使一个数的因子个数尽量多，我们应该把该数拆成多个二相乘，而 $n$ 分解过后可以发现 $n$ 最多拥有六十四个因子，因为 $n$ 最大时为六十四个二相乘，而斐波那契数列在第八十七项时会超过 $n$，就得到了上述的值。

------------

我们接着讲代码实现：写爆搜大概率不会超时，然后我们可以暴力从大往小的因子开始除，也就是降序，最后累加输出结果即可，不要忘记换行。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long fbnq[101]={1,1},t,n,l=2;
long long dfs(long long n,long long i){//爆搜 
    if(n==1)return 1;//递归边界1 
    if(i==1)return 0;//递归边界2 
    while(n<fbnq[i])i--;
    long long ans=0;//定义答案变量 
    if(n%fbnq[i]==0)ans+=dfs(n/fbnq[i],i);//累加答案 
    return ans+dfs(n,i-1);//接着递归 
}
int main(){
	while(1){//打表斐波那契数列 
		if(fbnq[l-1]+fbnq[l-2]>1e18)break;
		fbnq[l]=fbnq[l-1]+fbnq[l-2];
		l++;
	}
	scanf("%lld",&t);//输入数据组数
	while(t--){
		scanf("%lld",&n);//输入n
		cout<<dfs(n,l-1)<<"\n";//输出答案别忘了换行 
	}
	return 0;
}
```

---


# 椰子

## 题目背景

众所周知，椰子是一种椰子，但这和题目好像没什么关系。

## 题目描述

给出一个长度为 $n$ 的序列 $a$，我们保证 $1\sim n$ 中的每一个数都恰好在 $a$ 中出现了一次，对于每一个 $1\le i\le n$，求出在序列中将值为 $i$ 的数的值修改成 $1$ 后，序列有多少种不同的区间 $\gcd$ 的值。

严格来说，记将值为 $x$ 的数修改为 $1$ 后的序列为 $A^x$。集合 $S_x=\{\gcd\limits_{i=l}^r(A^x_i)|1\le l\le r\le n\}$，求出所有 $|S_i|$ 的值。

## 说明/提示

### 样例解释 1

对于将 $1$ 变成 $1$，有 $\{1,2,3\}$ 共 $3$ 种不同的区间 $\gcd$ 值，分别可以对应区间 $[1,3],[3,3],[1,1]$。

对于将 $2$ 变成 $1$，有 $\{1,3\}$ 共 $2$ 种不同的区间 $\gcd$ 值，分别可以对应区间 $[2,3],[1,1]$。

对于将 $3$ 变成 $1$，有 $\{1,2\}$ 共 $2$ 种不同的区间 $\gcd$ 值，分别可以对应区间 $[1,2],[3,3]$。

### 数据规模与约定

**本题采用捆绑测试**。

| $\text{Subtask}$ | 分数 | 数据范围 | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $n\le 20$ | 无特殊限制 |
| $2$ | $20$ | $n\le 200$ | 无特殊限制 |
| $3$ | $30$ | $n\le 2000$ | 无特殊限制 |
| $4$ | $20$ | 无特殊限制 | $A$ |
| $5$ | $20$ | 无特殊限制 | 无特殊限制 |

$A$：对于所有 $1\le i\le n$，有 $a_i=i$。

对于所有的数据，$2\le n\le 5\times 10^5$，我们保证 $1\sim n$ 中的每一个数都恰好在 $a$ 中出现了一次。

## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
3 2 2```

## 样例 #2

### 输入

```
6
3 6 4 1 5 2```

### 输出

```
6 6 5 5 5 5```

# 题解

## 作者：2huk (赞：8)

本题解的复杂度分析中均视求 $\gcd$ 是 $\mathcal O(1)$ 的。 

## 题意

给定 $n$ 的排列 $a$。对于每个数字 $i$，求将排列中值为 $i$ 的数修改为 $1$ 后，所有区间的 $\gcd$ 的种类数。$n \le 2 \times 10^5$。

## 做法

令 $p_i$ 表示值 $i$ 在 $a$ 中的出现位置。有 $p_{a_i} = a_{p_i} = i$。

注意到答案一定是 $n$ 或 $n - 1$。

当 $i = 1$ 时的答案（也就是原序列的答案）一定是 $n$。这是因为长度为 $1$ 的区间的 $\gcd$ 就是这个数本身，而我们可以将这些区间取完。

而对于其它的 $i$，如果存在区间 $[l, r]$ 且 $p_i \not \in [l, r]$ 且 $\gcd (a_l \dots a_r) = i$，那么 $i$ 的答案为 $n$。否则为 $n - 1$。原因与上面类似。

枚举区间，暴力求 $\gcd$ 是 $\mathcal O(n^4)$ 的。如果优化求区间 $\gcd$ 的过程可以做到 $\mathcal O(n^3)$。

同时特殊性质 $A$ 也很好做了。由于 $\gcd(i,i+1)=1$，所以除 $i = 1$ 外所有答案都是 $n - 1$。

考虑正解。我们要优化的是判断是否存在区间 $[l, r]$ 满足：

- $p_i \not \in [l, r]$；
- 且 $\gcd (a_l \dots a_r) = i$。

我们构造一个新序列 $b$，其中：

$$
b_j = \left\{ \begin{matrix} 0 &, p_i = j \\ 0 &,i \nmid a_j \\ \frac{a_j}i &, \text{otherwise.}\end{matrix}\right.
$$

那么原问题等价于判断 $b$ 中是否存在区间 $[l, r]$，满足 $\gcd(b_l \dots b_r) = 1$。

其必要条件是 $b_l\dots b_r \ne 0$。你验证一下发现上面两个条件刚好都满足了。

注意到，如果 $[l, r]$ 是合法的（这里合法指 $\gcd (b_l \dots b_r) = 1$）且 $b_{r+1} \ne 0$，那么 $[l, r + 1]$ 也一定是合法的。但其逆命题是假的。因此我们可以求出每个 $b_j \ne 0$ 的极长连续段，判断这个段内所有元素的 $\gcd$ 即可。

这里**极长连续段**指一个区间 $[l, r]$，满足 $b_l \dots b_r \ne 0$ 且 $b_{l-1}=b_{r+1}=0$（如果 $b_{l-1},b_{r+1}$ 存在）。

此时得到了一个 $\mathcal O(n^2)$ 做法。仍然不够优秀。

注意到 $1 \sim n$ 中所有数的倍数个数和是**调和级数** $\mathcal O(n \log n)$，这就意味着对于每个 $i$ 而言，$b$ 中不为 $0$ 的位置是很少的。因此我们可以优化找极长连续段的过程，总复杂度 $\mathcal O(n \log n)$。

快速求一个区间的 $\gcd$ 可以用 ST 表。

[$\mathcal O(n^3),\mathcal O(n^2),\mathcal O(n \log n)$ 的代码实现](https://www.luogu.com.cn/paste/z3k3vosh)。

---

## 作者：wangshi (赞：7)

显然，除了修改之外的位置 $x$ ，都可以选 $\left [x,x\right ]$，所以答案至少为 $n-1$。

然后我们考虑什么时候答案为 $n$ ，我们发扬一下智慧，容易发现 $\gcd$ 肯定减小的很快，所以我们只需要维护相邻两个数和三个数的 $\gcd$，即可通过该题。

实际复杂度 $O(n \log n)$。

### code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define fi first
#define se second
#define wang_shi return 0
#define See_Time cerr<<(clock()-Time)*1.0/CLOCKS_PER_SEC<<'\n'
#define See_Memory cerr<<abs(&M2-&M1)/1024.0/1024.0<<"MB\n"
using namespace std;
const int N=5e5+10;
typedef pair<int,int> PII;
bool M1;
int n,a[N],pos[N],d[N];
void solve()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		pos[a[i]]=i;
		if(i>1) d[__gcd(a[i],a[i-1])]++;
		if(i>2) d[__gcd(a[i],__gcd(a[i-1],a[i-2]))]++;
	}
	for(int i=1;i<=n;++i)
	{
		int ans=n-1;
		if(pos[i]>1) d[__gcd(a[pos[i]],a[pos[i]-1])]--;
		if(pos[i]>2) d[__gcd(a[pos[i]],__gcd(a[pos[i]-1],a[pos[i]-2]))]--;
		if(pos[i]<n) d[__gcd(a[pos[i]],a[pos[i]+1])]--;
		if(pos[i]<n-1) d[__gcd(a[pos[i]],__gcd(a[pos[i]+1],a[pos[i]+2]))]--;
		ans+=(d[i]>0);
		cout<<ans<<" \n"[i==n];
		if(pos[i]>1) d[__gcd(a[pos[i]],a[pos[i]-1])]++;
		if(pos[i]>2) d[__gcd(a[pos[i]],__gcd(a[pos[i]-1],a[pos[i]-2]))]++;
		if(pos[i]<n) d[__gcd(a[pos[i]],a[pos[i]+1])]++;		
		if(pos[i]<n-1) d[__gcd(a[pos[i]],__gcd(a[pos[i]+1],a[pos[i]+2]))]++;
	}
}
bool M2;
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	ios::sync_with_stdio(0); cin.tie(0);
	int Time=clock();
	int t=1; //cin>>t;
	while(t--) solve();
	See_Memory; See_Time;
	wang_shi;
}








```

---

## 作者：huangrenheluogu (赞：5)

把一个数 $x$，变成 $1$ 之后，看有没有区间 $\gcd$ 可以得到这个数，因为其他数都可以自己这个区间求 $\gcd$ 得到。

把一个数 $x$ 的倍数的位置求出来，显然所有的倍数可以表示成 $k_ix,k_i\in\mathbb{N}$ 的形式，我们需要让这些倍数连续的一段区间 $[l,r]$ 满足 $\gcd_{i=l}^r k_i=1$，那么就贪心地尽量取最长的区间。

总时间复杂度 $\mathcal{O}(n\log ^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5;
int n, a[N], pos[N], ans[N];
int stk[N], t, now;
int main(){
//	freopen("data.in", "r", stdin);
//	freopen("code.out", "w", stdout);
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%d", &a[i]);
		pos[a[i]] = i;
	}
	ans[1] = n;
	for(int i = 2; i <= n; i++){
		for(int j = i * 2; j <= n; j += i){
			stk[++t] = pos[j];
		}
		sort(stk + 1, stk + t + 1);
		ans[i] = n - 1;
		now = a[stk[1]];
		for(int j = 2; j <= t; j++){
			if(stk[j] != stk[j - 1] + 1){
				now = a[stk[j]];
				continue ;
			}
			now = __gcd(now, a[stk[j]]);
			if(now == i){
				ans[i] = n;
				break ;
			}
		}
		t = 0;
	}
	for(int i = 1; i <= n; i++){
		printf("%d ", ans[i]);
	}
	puts("");
	return 0;
}
```

---

## 作者：Night_sea_64 (赞：2)

现在的题解中好像没有我这个做法？

首先如果把一个数改成 $1$，那么只有 $\text{gcd}$ 为它自己的段有可能不存在了。因为其他的数可以自己为一个区间。也就是说，只要看一看有没有 $\text{gcd}$ 为自己且不包含自己的段。如果有的话答案为 $n$，没有的话答案为 $n-1$。

众所周知，区间 $\text{gcd}$ 可以使用 st 表维护。枚举左端点，然后不断二分下一个 $\text{gcd}$ 不等于当前值的右端点，直到找不到这个位置。设当前左端点 $l$，右端点 $r$，$\text{gcd}$ 为 $g$。当前找到的就是左端点为 $l$，$\text{gcd}$ 为 $g$ 时最短的段。再变长没有价值。然后在这里判断一下就行了。

复杂度的话，不会超过 $n$ 以内所有数的因数个数和乘以 $\log n$，约为 $O(n\log^2n)$。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[500010],pos[500010],lg[500010];
int st[500010][20];
bool flag[500010];
void pre()
{
    lg[0]=-1;
    for(int i=1;i<=n;i++)
        st[i][0]=a[i],lg[i]=lg[i/2]+1;
    for(int k=1;(1<<k)<=n;k++)
    {
        int len=(1<<k);
        for(int l=1;l+len-1<=n;l++)
            st[l][k]=__gcd(st[l][k-1],st[l+(len>>1)][k-1]);
    }
}
int query(int l,int r)
{
    int k=lg[r-l+1];
    return __gcd(st[l][k],st[r-(1<<k)+1][k]);
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        pos[a[i]]=i;
    }
    pre();
    flag[1]=1;
    for(int i=1;i<=n;i++)
    {
        int now=i,ngcd=a[i];
        while(1)
        {
            int l=now+1,r=n,ans=0;
            while(l<=r)
            {
                int mid=(l+r)/2;
                if(query(i,mid)<ngcd)r=mid-1,ans=mid;
                else l=mid+1;
            }
            if(!ans)break;
            now=ans,ngcd=query(i,ans);
            if(i>pos[ngcd]||now<pos[ngcd])
                flag[ngcd]=1;
        }
    }
    for(int i=1;i<=n;i++)
        cout<<(flag[i]?n:n-1)<<" ";
    cout<<endl;
    return 0;
}
```

---

## 作者：xz001 (赞：2)

我们维护每个数作为左端点时不修改有的区间最大公约数（重复的只统计一次），和为右端点时不修改有的区间最大公约数（重复的只统计一次），然后直接统计答案即可，会发现每个位置的数量不可能超过它的约数个数，总数不超过 $n\ln n$，由于需要求最大公约数，所以总时间复杂度为 $O(n\ln n \log n)$。

代码：

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 1e6 + 10;

int n, a[N], ans[N], cnt[N], sum;

vector <int> q[N], h[N];

signed main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; ++ i ) scanf("%lld", a + i);
    q[1].push_back(a[1]);
    for (int i = 2; i <= n; ++ i ) {
    	q[i].push_back(a[i]);
    	for (int j : q[i - 1]) {
    		q[i].push_back(__gcd(a[i], j));
		}
		sort(q[i].begin(), q[i].end());
		q[i].erase(unique (q[i].begin(), q[i].end()), q[i].end());
	}
	h[n].push_back(a[n]);
	for (int i = n - 1; i >= 1; -- i ) {
		h[i].push_back(a[i]);
		for (int j : h[i + 1]) {
			h[i].push_back(__gcd(a[i], j));
		}
		sort(h[i].begin(), h[i].end());
		h[i].erase(unique (h[i].begin(), h[i].end()), h[i].end());
	}
	for (int i = 1; i <= n; ++ i ) {
		for (int j : h[i]) {
			++ cnt[j];
			if (cnt[j] == 1) ++ sum;
		}
	}
	for (int i = 1; i <= n; ++ i ) {
		for (int j : h[i]) {
			-- cnt[j];
			if (cnt[j] == 0) -- sum;
		}
		for (int j : q[i - 1]) {
			++ cnt[j];
			if (cnt[j] == 1) ++ sum; 
		}
		ans[a[i]] = sum + !cnt[1];
	}
	for (int i = 1; i <= n; ++ i ) printf("%lld ", ans[i]);
	return 0;
}

```

---

## 作者：鲤鱼江 (赞：2)

$O(n\log^2n)$ 的做法。

注意到答案肯定是 $n$ 或 $n-1$（只有当前数可能凑不出来），所以可以只考虑当前数是否能凑出来。

这个过程可以选择枚举 $i$ 的倍数（调和级数复杂度，即 $O(n \log n)$ 总时间），然后排序，再拿出连续段（指区间内全是 $i$ 的倍数的极长区间）求 $\gcd$，可以发现把一个连续段内的数全部一起求 $\gcd$ 一定不劣（因为都是 $i$ 的倍数），总时间 $O(n\log^2 n)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

namespace Fread {
	const int SIZE=1<<21;char buf[SIZE],*S,*T;
	inline char getchar() {if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return '\n';}return *S++;}
}
namespace Fwrite {
	const int SIZE=1<<21;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}
	inline void putchar(char c){*S++=c;if(S==T)flush();}
	struct POPOSSIBLE{~POPOSSIBLE(){flush();}}ztr;
}
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio{
	struct Reader{
	    template<typename T>
    	Reader& operator >> (T& x) {
        	char c=getchar();T f=1;
        	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}x=0;
        	while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}x*=f;
	        return *this;
    	}
	    Reader(){}
	}cin;
	struct Writer{
	    template<typename T>
	    Writer& operator << (T x) {
	        if(x==0){putchar('0');return *this;}
	        if(x<0){putchar('-');x=-x;}
	        static int sta[45];int top=0;
	        while(x){sta[++top]=x%10;x/=10;}
	        while(top){putchar(sta[top]+'0');--top;}
	        return *this;
    	}
    	Writer& operator << (char c) {putchar(c);return *this;}
    	Writer(){}
	}cout;
}
#define endl '\n'
#define ls now<<1
#define rs now<<1|1
#define cin Fastio :: cin
#define cout Fastio :: cout

const int N=5e5+10;
int a[N],n,p[N],idx,c[N],res,fg;

int gcd(int x,int y){return y?gcd(y,x%y):x;}

signed main(){
	cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=1;i<=n;++i) c[a[i]]=i;
	for(int i=1;i<=n;++i){
		idx=res=fg=0;if(i==1) fg=1;
		for(int j=i+i;j<=n;j+=i) p[++idx]=c[j];
		sort(p+1,p+1+idx);
		for(int j=1;j<=idx;++j){
			if(p[j]!=p[j-1]+1) res=0;
			res=gcd(res,a[p[j]]);
			if(res==i) fg=1;
		}
		cout<<(n-1+fg)<<' ';
	}
	return 0;
}
```

---

## 作者：CNS_5t0_0r2 (赞：2)

想了半个小时想不出来，想出来之后觉得自己是申必。

~~观察样例~~，可以得出修改 $i$ 后不同区间 $\gcd$ 的数量要么为 $n$，要么为 $n - 1$。

其实挺好证明的：

显然区间 $\gcd$ 不可能超过 $n$。

对于每个长度为 $1$ 的区间（没有修改的时候），$[1,1],[2,2],\cdots,[n,n]$，其区间 $\gcd$ 值均不相同。假设 $i$ 被修改，那么只有区间 $\gcd = i$ 的区间可能消失。

那先在就判断修改 $i$ 是否会使答案变为 $n - 1$。

~~不过我感觉不变更好判一些。~~

我们找到所有 $i$ 的倍数（**不包括 $i$ 本身，因为 $i$ 会被修改掉**），若存在一个**下标连续的子段**满足其 $\gcd$ 值等于 $i$，那么说明修改了答案还是 $n$ （因为这个连续的子段是没有被修改的），否则就是 $n - 1$。

注意 $1$ 要特判掉（像样例 $1$ 用这个判定方法就会出问题）。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 9;
int n;
int a[N],bel[N],ans[N];
vector<int> vec[N];
int GCD(int x,int y){
	return y ? GCD(y,x % y) : x;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		bel[a[i]] = i;
	}
	ans[1] = n;
	for(int i = 2;i <= n;i++){
		for(int j = (i << 1);j <= n;j += i)
			vec[i].push_back(bel[j]);
		sort(vec[i].begin(),vec[i].end());
		int siz = vec[i].size();
		if(siz == 0){
			ans[i] = n - 1;
			continue;
		}
		bool f = false;
		int tmp = a[vec[i][0]];
		for(int j = 1;j < siz;j++){
			if(vec[i][j - 1] + 1 == vec[i][j]){
				tmp = GCD(tmp,a[vec[i][j]]);
				if(tmp == i){
					f = true;
					break;
				}
			}
			else
				tmp = a[vec[i][j]];
		}
		if(f)
			ans[i] = n;
		else
			ans[i] = n - 1;
	}
	for(int i = 1;i <= n;i++)
		cout << ans[i] << ' ';
	return 0;
}
```

---

## 作者：lrqcs (赞：1)

**注意：以下我所说的期望得分为极限数据下可得分数而非题目测试点可得分数。**

### 1. 10pts 暴力
暴力枚举每个区间并暴力求出每个区间的 $\gcd$ 值并统计，时间复杂度 $O(2^n\log n)$，其中 $O(\log n)$ 为 $\gcd$ 最坏复杂度。

### 2. 20pts 特殊性质
因为任何长度为 $1$ 的区间 $\gcd$ 值为其中唯一值本身，所以在不改变任何数的任何长度为 $n$ 的序列上 $\gcd$ 值的数量有 $n$ 种。  
又因为改变一个数（除 $1$ 本身）为 $1$ 时只会导致该数 $\gcd$ 值**可能**取不到，所以所有答案最小值不会小于 $n-1$。  
改变 $1$ 为 $1$ 没有任何影响，此时答案为 $n$。  
本题特殊性质保证序列顺序为 $1$ 到 $n$，而相邻两正数 $\gcd$ 值为 $1$，所以将任意一个数（除 $1$ 本身）改变为 $1$ 时该数 $\gcd$ 值**一定**取不到，所以此时答案为 $n-1$。  
最终答案为 $n$ 和 $n-1$ 个 $n-1$。

### 3. 20/30pts 错解
因为改变一个数（除 $1$ 本身）为 $1$ 时该数 $\gcd$ 值仍能取到当且仅当至少有一个区间 $\gcd$ 值与其相等，所以我们可以枚举每一个长度小于等于 $len$ 的区间。  
有人（包括我）把 $len$ 设成了 $2$ 或 $3$，但这样不能得到全分（实际上 $len$ 设成 $3$ 时过了）。考虑以下数据：  
```text
in:
12
4 12 6 7 5 3 2 1 8 9 10 11

out:
12 12 11 11 11 11 11 11 11 11 11 11
```
此时 $len$ 设为 $2$ 会导致第二个 $12$ 变为 $11$。  
$\gcd(4,12,6)=2$，但 $\gcd(4,12)=4$，$\gcd(12,6)=6$，所以会出现此类错误。

还有以下数据：  
[因为数据过大就放在云剪贴板里了](https://www.luogu.com.cn/paste/0485aj1r)[（如果前面的炸了用这个）](https://www.luogu.com/paste/0485aj1r)

### 4. 100pts 正解
实际上只要把 $len$ 开大就可以过，但具体开大多少不知道。

观察到此类极端数据前几个数为 $2\times2\times3\times5\times7\times11\times...$（中间少一点）的形式，且 $2$ 为其最大公约数。所以可在右边质数中任选一个作为一部分数（包含在原来这一些数里）的最大公约数，并在剩下的几个数中选取，每一个数有选与不选两种情况，根据乘法原理可知总情况为 $2^a$ 种，其中 $a$ 为剩余数的个数。

[在这里给出为什么这样造的数据最为极端](https://www.luogu.com.cn/paste/h76mzwp2)[（如果前面的炸了用这个）](https://www.luogu.com/paste/h76mzwp2)

因为 $2\times2\times3\times5\times7\times11\times13\times17>5\times10^5$ 且 $2\times2\times3\times5\times7\times11\times13<5\times10^5$，所以剩余数不超过 $6$ 个。

在此基础上数量还要加 $1$ 以把多的那个质数剔出最大公约数。

所以 $len$ 最小为 $2^6+1=65$ 才可以通过全部极端数据。

时间复杂度近似于 $O(n\log^2n)$，空间复杂度 $O(n)$。

**code:**
```cpp
#include<stdio.h>
#define getchar getchar_unlocked//快一点
int re();//快读
int n,a[500050];
bool b[500050];
int gcd(int a,int b){
	for(int c;b;a=b,b=c)c=a%b;
	return a;
}
signed main(){
	n=re();
	for(int i=1;i<=n;++i)a[i]=re();
	for(int i=1,x,y;i<n;++i){//长度为1的区间没必要求gcd了
		x=a[i];
		for(int j=1;j<=64&&i+j<=n;++j){//j+1->len
			y=gcd(x,a[i+j]);
			if(x>y&&a[i+j]>y)b[y]=1;//两个数中有自己的不能要，因为自己被设为1时就不对了
			x=y;
		}
	}
	for(int i=1;i<=n;++i)printf("%d ",n-!b[i]);//b[i]==1时为有其他区间gcd值为i
	return 0;
}
int re(){
	int x=0;char c=getchar();
	while(c<48||c>57)c=getchar();
	while(c<58&&c>47)x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x;
}
```
最慢的点跑了 300ms 多，速度较慢。

---

## 作者：__Cby___ (赞：1)

## 思路
显然，答案只有 $n$ 或 $n-1$ 两种。我们只需要统计将这个数变成 $1$ 之后这个序列还有没有办法产生子段使其 $\gcd$ 为这个数。  
于是开一个数组，存储每个数所在的位置。对于 $i$，我们把 $i$ 的倍数所在的位置取出来，判断是否存在连续子段的 $\gcd$ 为 $i$。
## 代码
```
#include<iostream>
#include<algorithm>
using namespace std;
long long int a[500025];
long long int mp[500025];
long long int t[500025];
int main(){
	long long int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)mp[a[i]]=i;
	for(int l=1;l<=n;l++){ 
		long long int cnt=0;
		for(int j=l*2;j<=n;j+=l)t[++cnt]=mp[j];
		sort(t+1,t+1+cnt);
		if(!cnt){
			cout<<n-1<<" ";
			continue;
		}
		bool y=0;
		long long int nw=a[t[1]];
		for(int i=2;i<=cnt;i++){
			if(t[i]==t[i-1]+1){
				nw=__gcd(nw,a[t[i]]);
			}
			else{
				if(nw==l){
					y=1;
					break;
				}
				nw=a[t[i]];
			}
		}
//		cout<<endl;;
		if(nw==l)y=1;
		if(l==1){
			cout<<n<<" ";
			continue;
		}
		if(y)cout<<n<<" ";
		else cout<<n-1<<" ";
	}
	cout<<endl;
	return 0;
}
```

---

## 作者：DGFLSzfd (赞：1)

## 思路
由于每一个只有一个数的区间，其最大公约数都是这个区间本身。  
所以我们不难得出，**不管你把哪一个数变成 $1$ 不同的公约数数量至少为 $n-1$**。

那什么时候将一个数改成 $1$ 后的答案为 $n$ 呢。当有一些数的最大公因数为被改成 $1$ 的那个数时，且这些数中没有与这个公因数相等的数。此时答案为 $n$。

不过显然预处理一遍所有情况的最大公因数会超时。

所以我在这里告诉大家一个取巧的方法 ~~（赌样例不够完善）~~。其实这也是 IOI 赛制中的合理技巧。

那就是**对于每个点只枚举长度最多为 $10$ 的区间**并记录这个区间的最大公因数。

为什么这样可以呢？因为我认为 $10$ 个数约出的数小之又小，大概率其他区间的数依然可以约出来。而且一些数，两三个数约不出来，一堆数就更约不出来了。

于是我这份抽象的代码就对了。

## 代码展示
注意：用数组记录并清空数组会大大增加用时。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5*1e5+10;
int n,a[N],t[N],ff[N];

unordered_map<int,bool>m;

int gcd(int a, int b) 
{
  while (b != 0) 
  {
    int tmp = a;
    a = b;
    b = tmp % b;
  }
  return a;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++)
	{
		m.clear(); 
		int g=a[i]; m[a[i]]=1;
		for(int j=i+1;j<=min(i+10,n);j++)
		{
			m[a[j]]=1;
			
			g=gcd(a[j],g);
			
			if(g==1) break;
			
			if(m[g]) continue;
			else t[g]=1;
		}
	}
	cout<<n;
	for(int i=2;i<=n;i++)
	{
		cout<<' '<<n-1+t[i];
	}
	
	
}
```

---

## 作者：Fantasy_Segment_Tree (赞：1)

发现一个送分点：答案一定只有 $n - 1$ 和 $n$ 两种。因为可以把单点看作一个区间。

那么一个数 $x$ 变成 $1$ 之后仍然有 $n$ 种最大公因数当且仅当有一个最大公因数为 $x$ 的区间不经过 $x$ 所在的位置。

所以 $O(n^2\log{n})$ 的做法非常显然：枚举区间左右端点，记录每个数出现的位置，若 $[l, r]$ 区间的 $\gcd$ 不在区间中出现，则把这个数变成 $1$ 之后仍然有 $n$ 种最大公因数。

那么如何进行优化呢？

**注意：作者此处本来只想试一下能否通过，但是直接通过了。**

我们可以设一个计数器 $t$，每次把区间右端点右移时就让 $t + 1$，若最大公因数为 $1$，则直接退出。若直到 $t$ 到达某个常数时，最大公因数仍不为 $1$，直接进行判断、标记，并退出循环。

经过本人实测，当常数为 $450$ 时，可以直接通过本题。

本做法纯属胡扯，但是为什么会对？依照本人想法，$450$ 个 $\leq n$ 的数的最大公因数等于 $1$ 的概率极大，或者可能数据有些水，导致本人不正确的写法可以通过。并且 $\gcd$ 的常数比 $1$ 小得多，程序中又有多个 break 语句，导致远远跑不满表面上的复杂度。

代码非常简短，就不放了。

P.S. 其实当这个常数为 $4$ 时都能通过，所以强烈建议加强数据！！！

---

## 作者：wbqhasvcf (赞：1)

看见题解区大佬的代码都很高深莫测，就提供了一段简单的代码：

首先我们简化题意，将一个数变成 $1$，再求修改完之后 $1\sim n$ 中有多少个数为整个数列中任意一个长度为任意长度的区间的最大公约数，这什么玩意儿？除了这个修改为 $1$ 的数，剩下的数只要取它本身组成一个区间不就满足条件了吗？输出的每个答案不是 $n-1$ 就是 $n$ 呀，也就是说我们只用考虑每个数满足不满足上述条件就行了。

这题实际上有一个非常简单的思路，先用一个 $d$ 数组记录相邻两个数的最大公约数，如果相邻两个数的最大公约数不是两个数本身，就用一个布尔类型的数组 $f$ 标记，这样可以知道哪些数为任意一个长度为 $2$ 的区间的最大公约数。紧接着再对 $d$ 数组进行处理，另开一个布尔类型的数组 $f2$ 用来直接标记 $d$ 数组中相邻两个数的最大公约数，这样可以知道哪些数为任意一个长度大于 $2$ 的区间的最大公约数。

可以证明对于一个长度为 $n$ 的区间，将相邻两个数进行 $\gcd$ 得到 $n-1$ 个数，再将这 $n-1$ 个数中相邻两个数进行 $\gcd$ 操作得到 $n-2$ 个数，在这 $n-2$ 个数中总会有一个数是整个区间所有数的最大公约数。

因此这道题我们就分析完了，亮出我比赛时打出的一段时间复杂度大约为 $O(n \log n)$ 的代码：


```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=5e5+5;

int n,a[N],d[N];
bool f[N],f2[N];//两个f数组 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	    cin>>a[i];
	for(int i=1;i<n;i++)
	{ 
		d[i]=__gcd(a[i],a[i+1]);//众所周知，algorithm里自带gcd函数 
		//记录每个长度为2的区间的最大公约数
		//这里注意一定要判断这个数是否为两个数本身，否则不能标记，样例中的前两个数3 6就是个例子 
		if(d[i]!=a[i]&&d[i]!=a[i+1]) 
		    f[d[i]]=true;
	}
	//第二轮标记，记录每个长度大于2的区间的最大公约数 
	for(int i=1;i<n-1;i++)
	    f2[__gcd(d[i],d[i+1])]=true;
	//对于1到n的每个数，只要f[i]和f2[i]有一个为true即满足条件，就需要加上一个1 
	for(int i=1;i<=n;i++) 
	    cout<<n-1+(f[i]|f2[i])<<" "; 
	return 0;
}
```
仅仅 $22$ 行（两个头文件可以缩成万能头，我习惯的换行去掉就是 $22$ 行）就可以解决本题，此代码是不是非常简洁明了？？！

---

## 作者：sbno333 (赞：1)

感觉很好的题，虽然同学用判断连续三个 gcd 艹过去了。

考虑正解。

首先，答案要么是 $n$，要么是 $n-1$。

把 $x$ 变为 $1$ 后，对于其他可能的 $\gcd$。显然是在 $1\sim n$ 之间的，因为对于更高的 $\gcd$，我们找不到它的倍数。

而对于其他数，我们都可以选择那一个数作为一个区间，显然都有解。

然后对于 $x$，我们可以试图去找有没有这样的区间使得 $\gcd$ 为 $x$，且不包含 $x$ 的位置。

我们自然地能够想到把 $x$ 的倍数都拿出来，由这些数组成的**连续**区间 $\gcd$ 为 $x$ 的倍数。

我们可以直接拿出来这些数，每个数在输入时记录下标，这样拿出来 $x$ 的倍数就可以 $O(\frac{n}{x})$ 做，根据调和级数得到这是正确的。

此时我们得到了一个由若干下标组成的序列，考虑计算 $\gcd$ 为 $x$ 的倍数的区间数量，这里注意**不要包含** $x$。

为了统计 $\gcd$ 为 $x$ 的区间数量，我们需要减去 $\gcd$ 为 $x$ 的倍数且不是 $x$ 的区间数量。

枚举 $x$ 的倍数 $y$，让区间数量减去包含 $y$ 的 $\gcd$ 为 $y$ 的区间数量。

然后我们发现要维护 $\gcd$ 为 $x$ 的包含 $x$ 的区间数量，同理，也是统计后减去即可。

最后判断每一个是否存在。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000009];
int b[1000009];
int n;
int qj[1000009];
int qqj[1000009];
int q[1000009];
int inn;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[a[i]]=i;
	}
	for(int i=n;i>=1;i--){
		inn=0;
		for(int j=2;i*j<=n;j++){
			q[++inn]=b[i*j];
		}
		sort(q+1,q+1+inn);
		if(inn)
		qj[i]=1;
		int z;
		z=2;
		for(int j=2;j<=inn;j++){
			if(q[j]==q[j-1]+1){
				qj[i]+=z;
				z++;
			}else{
				z=2;
				qj[i]++;
			}
		}
		for(int j=2;i*j<=n;j++){
			qj[i]-=qqj[i*j];
		}
		q[++inn]=b[i];
		sort(q+1,q+1+inn);
		if(inn)
		qqj[i]=1;
		z=2;
		for(int j=2;j<=inn;j++){
			if(q[j]==q[j-1]+1){
				qqj[i]+=z;
				z++;
			}else{
				z=2;
				qqj[i]++;
			}
		}
		for(int j=2;i*j<=n;j++){
			qqj[i]-=qqj[i*j];
		}
	}
	cout<<n<<" ";
	for(int i=2;i<=n;i++){
		cout<<(qj[i]?n:n-1)<<" ";
	}
	return 0;
}
```

---

## 作者：mahaihang1 (赞：0)

## 60pts
对于 $\forall i \in [1,n]$，因为每次只将值为 $i$ 的数变为 $1$，因此 $|S_i|=n$ 或 $n-1$。

考虑暴力枚举 $b_{l,len}=\gcd\limits_{i=l}^{l+len-1}(a_i)|1\le l\le l+len-1\le n$，如果值为 $b_{l,len}$ 的下标 $j \notin [l,r]$，则当将值为 $b_{l,len}$ 的数变为 $1$ 后，仍有 $b_{l,len}$ 的值不变，答案也不变。

## 100pts
发现是暴力枚举 $b_{l,len}$ 时的复杂度过高，考虑在 $len$ 逐渐增加的过程中 $b_{l,len}$ 单调不增，则当 $b_{l,len}=1$ 时，$b_{l,len}$ 不会再变了，这时不如直接结束计算。

同理，我们进一步发现当 $b_{l,len}$ 为质数时，$b_{l,len}$ 只会可能变成 $1$，因此此时再进行计算也没有用了。

然后我们只需算出 $1$ 到 $n$ 的质数，进行对枚举优化即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=500010;
int n,a[N],b[N],c[N],d[N],p[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		d[a[i]]=i;
	}
	p[0]=1;
	for(int i=2;i<=n;i++){
		if(!p[i]){
			if((long long)i*i>n) continue;
			for(int j=i*i;j<=n;j+=i){
				p[j]=1;
			}
		}
	}//质数筛
	for(int j=1;j<=n;j++){
		for(int i=1;i+j-1<=n;i++){
			if(!p[c[j]]) break;//优化枚举
			c[j]=__gcd(c[j],a[j+i-1]);
			if(!(d[c[j]]>=j&&d[c[j]]<=j+i-1)) b[c[j]]=1;
		}
	}
	cout<<n<<" ";
	for(int i=2;i<=n;i++) cout<<n-!b[i]<<" ";
	return 0;
}
```

---


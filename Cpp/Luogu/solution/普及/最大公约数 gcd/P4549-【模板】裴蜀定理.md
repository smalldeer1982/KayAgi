# 【模板】裴蜀定理

## 题目描述

给定一个包含 $n$ 个元素的**整数**序列 $A$，记作 $A_1,A_2,A_3,...,A_n$。

求另一个包含 $n$ 个元素的待定**整数**序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 20$，$|A_i| \le 10^5$，且 $A$ 序列不全为 $0$。

## 样例 #1

### 输入

```
2
4059 -1782
```

### 输出

```
99```

# 题解

## 作者：RainAir (赞：51)

据说 NOIP 前发题解会 rp++？我数学这么差当然要让我的数学rp++了！

根据题目可知，这个题目要用裴蜀定理。

## 定理内容
对于任意整数 $a,b,d$，
$$ (a,b)|d \Leftrightarrow \exists \ u,v \ \text{such that}\ ua+vb = d $$

证明可以通过递归构造解来证明：

首先显然当 $u=1,v=0$ 的时候显然成立。

假设存在 $u',v'$,使得 $u'b+v'(a\ mod\ b)=d$.

注意到 $$a\ mod\ b = a-\lfloor\frac{a}{b}\rfloor b$$

可得 $$ u'b + v'(a-\lfloor\frac{a}{b}\rfloor b) = d$$

整理可以得到：
$$ u'b + v'a- v'\lfloor\frac{a}{b}\rfloor b = d$$

$$ v'a + (u'-\lfloor\frac{a}{b}\rfloor v')b = d $$

归纳证明该定理正确。

扩展到求 $ax+by=c$ 的最小非负 $c$,显然 $c$ 要满足 $(a,b)|c$,所以 $c$ 取 $(a,b)$ 是最小的。

扩展到这个题目，如果有多个数字的话，考虑前两个数字 $a_1,a_2$,有 $a_1x+a_2y=S \Rightarrow (a_1,a_2)|d$,$ k(a_1,a_2) =d$

所以把这两个的答案合并直接去取下一个就可以了。

注意到这个题目有负数输入，将其取绝对值就可以了。因为系数的最终答案没有影响。

## 代码
```c++
#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <map>
#include <set>
#define Re register
#define LL long long
#define U unsigned
#define FOR(i,a,b) for(Re int i = a;i <= b;++i)
#define ROF(i,a,b) for(Re int i = a;i >= b;--i)
#define SFOR(i,a,b,c) for(Re int i = a;i <= b;i+=c)
#define SROF(i,a,b,c) for(Re int i = a;i >= b;i-=c)
#define CLR(i,a) memset(i,a,sizeof(i))
#define BR printf("--------------------\n")
#define DEBUG(x) std::cerr << #x << '=' << x << std::endl
namespace fastIO{
    #define BUF_SIZE 100000
    #define OUT_SIZE 100000
    #define ll long long
    bool IOerror=0;
    inline char nc(){
        static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
        if (p1==pend){
            p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin);
            if (pend==p1){IOerror=1;return -1;}
        }
        return *p1++;
    }
    inline bool blank(char ch){return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';}
    inline void read(int &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    inline void read(ll &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    #undef ll
    #undef OUT_SIZE
    #undef BUF_SIZE
};
using namespace fastIO;

int N,gcd;
int main(){
    read(N);
    FOR(i,1,N){
        if(i==1) read(gcd);
        else{
            int x;read(x);x = std::abs(x);
            gcd = std::__gcd(gcd,x);
        }
    }
    printf("%d\n",gcd);
    // system("pause");
    return 0;
}
```

---

## 作者：RyanLi (赞：4)

传送门：[P4549 【模板】裴蜀定理](https://www.luogu.com.cn/problem/P4549)

更佳的阅读体验：[洛谷 P4549 题解](https://blog.ryanli.top/index.php/archives/280/)

---

## 算法介绍

给定一个长度为 $n$ 的整数序列 $A$ 和一个待定整数序列 $X$，求 $S = \sum \limits_{i = 1}^{n} A_i \times X_i$ 在正数范围内的最小值。

看上去似乎有点无从下手。

那先从简单的开始！我们来考虑 $n = 2$ 的情况，此时问题简化为求 $A_1 X_1 + A_2 X_2$ 的最小值。

如果我们设 $a, b$ 是不全为 $0$ 的整数，那么有**裴蜀定理**（Bézout's Lemma）：

- 对于任意整数 $x, y$，有 $\gcd (a, b) \mid (ax + by)$。
- 存在整数 $x, y$，使得 $ax + by = \gcd (a, b)$。

因此，$ax + by$ 的最小正整数值显然是 $\gcd (a, b)$。上述问题的答案就是 $\gcd(A_1, A_2)$。

那么，当 $n \ge 3$ 呢？我们尝试推广裴蜀定理。

假设有三个整数 $a, b, c$。我们首先对前两个数应用裴蜀定理，存在整数 $x_1, x_2$，使得 $ax_1 + bx_2 = \gcd (a, b)$。接下来，将这个结果与第三个数 $c$ 结合，即存在整数 $k, x_3$，使得 $\gcd (a, b) \times k + cx_3 = \gcd( \gcd(a, b), c)$。

我们知道，最大公约数有性质：$\gcd (a, b, c) = \gcd (\gcd(a, b), c)$，因此存在整数组合使得 $ax_1 + bx_2 + cx_3 = \gcd(a, b, c)$，且不存在更小的正数解。

这样推广下去，最终无论 $n$ 的大小，问题的最小正数解都是所有 $A_i$ 的最大公约数的绝对值。因此，我们只需要计算整个序列 $A$ 的最大公约数，并取其绝对值即可。

## 正确性证明

我们设 $a, b$ 是不全为 $0$ 的整数，那么一定有 $\gcd(a, b) \mid a$ 且 $\gcd(a, b) \mid b$。设 $x, y$ 为整数，则有 $\gcd(a, b) \mid ax$ 且 $\gcd(a, b) \mid bx$，因此 $\gcd(a, b) \mid (ax + by)$。

对于定理的第二点，若 $a$ 和 $b$ 任意一个等于 $0$，则 $\gcd(a, b)$ 的值为非零数的值，此时定理显然成立。

若 $ab \neq 0$，由于 $\gcd(a, b) = \gcd(a, -b)$，我们不妨设 $a, b$ 都大于 $0$，$a \ge b$，且有 $\gcd(a, b) = d$。

对 $ax + by = d$，两边同时除以 $d$，得到 $a_1x + b_1y = 1$，其中 $a_1, b_1$ 互质。接下来证明 $a_1x + b_1y = 1$。

我们先来回顾一下辗转相除法：$\gcd(a, b) \rightarrow \gcd(b, a \bmod b) \rightarrow \cdots$。我们把模出来的数记作 $r$，则有：
$$
\gcd(a_1, b_1) = \gcd(b_1, r_1) = \gcd(r_1, r_2) = \cdots = \gcd(r_{n - 1}, r_n) = 1
$$
把辗转相除法中的运算展开成带余除法，得到：
$$
\begin{align*}
a_1 & = q_1b_1 + r_1 & (0 \le r_1 < b_1) \\
b_1 & = q_2r_1 + r_2 & (0 \le r_2 < r_1) \\
r_1 & = q_3r_2 + r_3 & (0 \le r_3 < r_2) \\
& \cdots & \\
r_{n - 3} & = q_{n - 1}r_{n - 2} + r_{n - 1} & \\
r_{n - 2} & = q_nr_{n - 1} + r_n & \\
r_{n - 1} & = q_{n + 1}r_n
\end{align*}
$$
我们令辗转相除法在除到互质的时候退出，则 $r_n = 1$，所以有：
$$
r_{n - 2} = q_nr_{n - 1} + 1
$$
即：
$$
1 = r_{n - 2} - q_nr_{n - 1}
$$
用倒数第三个式子 $r_{n - 1} = r_{n - 3} - q_{n - 1}r_{n - 2}$ 代入上式，得：
$$
1 = (1 + q_nq_{n - 1}) r_{n - 2} - q_nr_{n - 3}
$$
然后用同样的办法逐个地消去 $r_{n - 2}, \cdots, r_1$，即可证得 $1 = a_1x + b_1y$。

## 代码实现

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, a, ans;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> n >> a;
    ans = a;
    for (int i = 2; i <= n; ++i)
        cin >> a, ans = __gcd(ans, abs(a));
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：0Io_oI0 (赞：2)

# 内容
$ax+by=c$ 是一个关于 $x,y$ 的整系数二元一次方程有整数解的充要条件是 $\gcd(a,b)\ |\ c$。

# 证明
我们可以先只考虑 $ax+by=1$ 的解。

1. 若 $\gcd(a,b)=d>1$ 则左右模 $d$ 不同余。

   对于 $ax+by=c$ 若 $d$ 不为 $c$ 的因子则同样无解。
2. 若 $\gcd(a,b)=1$ 则我们考虑 $ax+by=1$ 左右同时模 $b$ 有 $ax\equiv 1(\mathrm{mod}\ b)$，因为 $\left\{1,2,\dots,b \right\}$ 为模 $b$ 的完系，且 $\gcd(a,b)=1$，所以 $\left\{a,2a,\dots,ab\right\}$ 也为模 $b$ 的完系。所以必存在 $x_0∈\left\{1,2,\dots,b\right\}$ 使得 $ax_0\equiv 1(\mathrm{mod}\ b)$。我们可以记 $ax_0=1+kb$ 代入 $ax+by=1$ 有 $y=-k$。所以 $ax+by=1$ 有整数解。到这里我们可以发现其实这也就相当于 $ax+by=c$ 有整数解，因为你把 $ax+by=1$ 的整数解乘上 $c$ 就好了。

这样充分性就证明完毕了！

接下来上代码：
```cpp
#include<bits/stdc++.h>
#define I using
#define AK namespace
#define IOI std
#define i_ak return
#define ioi  0
#define i_will signed
#define ak main
#define IMO ()
#define int long long
#define double long double
I AK IOI;
int n,ans,x;
i_will ak IMO{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	//freopen("","r",stdin);
	//freopen("","w",stdout);
	cin>>n>>ans; 
	ans=abs(ans);
	while(n--){
		cin>>x;
		ans=__gcd(ans,abs(x));
	}
    cout<<ans;
	i_ak ioi;
}
```
亲测可过，请勿抄袭！

---

## 作者：yangrunze (赞：2)

刚学会裴蜀定理，顺便来给大家讲一下：


首先来看看裴蜀定理是个什么东西哈：

> 对于一个二元一次方程$ax+by=c$，如果 **$c$是$\gcd(a,b)$的倍数**，那么**这个方程一定有整数解**

那这个东西到底咋证捏？别急，咱们要分两个阶段来完成证明！

### Section A

> 证明$ax+by=\gcd(a,b)$这个方程有整数解

首先，咱们要用的是一个很基础的东西——**辗转相除法**

对，没错，就是求最大公因数的那个

还记得辗转相除法的核心柿子吗？没错！就是$\gcd(a,b)=\gcd(b,a\bmod b)$

那咱们就用这个式子来证明它！

设$\gcd(a,b)=g$

则$ax+by=g$

我们设已经找到了一组解$x',y'$，使$bx'+(a \bmod b)y'=\gcd(a,b)$

$bx'+(a \bmod b)y'=g$

由于商\*除数+余数=被除数，$a\bmod b$可以这么表示：

$bx'+(a-\lfloor\frac{a}{b}\rfloor\times b)y'=g$

给它稍微变个形：

$bx'+ay'-a/b\times by'=g$

$ay'+b(x'-\lfloor\frac{a}{b}\rfloor\times y')=g$

和原式对比一下，你会惊奇地发现：

$\begin{cases}x=y'\\y=x'-\lfloor\frac{a}{b}\rfloor\times y'\end{cases}$

由于$b=0$时$\begin{cases}x=1\\y=0\end{cases}$，我们可以用刚才的式子一步一步向上把原来的解求出来

对于每一个$a$和$b$，我们都可以如法炮制，所以肯定都是有解哒！

P.S:刚才咱们用的方法，其实是辗转相除法的升级版——**扩展欧几里得算法**，也就是传说中的**exgcd**，又学会了一个新方法，开心不开心？（我才不会告诉你这一块是从扩欧的笔记那里cv过来的呢QωQ）

### Section B

> 证明每一个$c$都是$gcd(a,b)$的倍数

这就非常简单了，咱还是设 $\gcd(a,b)=g$

由于$g$是$a$和$b$的最大公因数，所以$g$肯定能被他俩整除

从刚才的得到的结论出发，我们设已知$ax'+by'=g$，$g\times q=c$

两边同时乘$q$，这样的话就可以发现$ax'\times q+by'\times q=g\times q$，即$ax'\times q+by'\times q=c$

$\begin{cases}x=x'\times q\\y=y'\times q\end{cases}$就是方程的一组解啦

**如果你认为这一切就是裴蜀定理的话 你就太小看它了**

裴蜀定理不光正着说没问题，反着说也成立！

> 对于一个二元一次方程$ax+by=c$，如果这个方程有整数解，那么c一定是$\gcd(a,b)$的倍数

那这个东西该咋证明呢？咱们还是可以考虑从最大公因数扩展

我们设$a=a'g,b=b'g,c=c'g+r$（$r<g$，我们还不知道$c$到底是不是$g$的倍数，那就先设上个$r$吧）

这样的话，原方程可以变为：$a'g x+b'g y=c'g+r$

两边同时除以$g$，得到$a'x+b'y=c'+\frac{r}{g}$

别忘了我们的已知条件：方程有整数解！所以$\frac{r}{g}$一定是个整数，$r$只能是$0$，所以$c$一定是$g$的倍数

那我们现在就可以大胆地说出来：

>对于一个二元一次不定方程$ax+by=c$，$c$是$\gcd(a,b)$的倍数，是这个方程有整数解的**充要条件**

**如果你认为这一切就是裴蜀定理的话 你就太小看它了**

裴蜀定理不仅如此，还可以扩展到更多元的不定方程！

>对于一个 **$n$元一次不定方程** $a_1x_1+a_2x_2+a_3x_3+\cdots+a_nx_n=c$，$c$是$\gcd(a_1,a_2,a_3,\cdots,a_n)$的倍数，是这个方程有整数解的充要条件

类比一下多个数求最大公因数的过程，证明这个应该很简单

好不容易完成了证明，来看看题吧！

>给定一个包含 $n$ 个元素的整数序列 $A$，记作 $A_1,A_2,A_3,...,A_n$ 
求另一个包含 $n$ 个元素的待定整数序列 $X$，记 $S=\sum\limits_{i=1}^nA_i\times X_i$，使得 $S>0$ 且 $S$ 尽可能的小。

不难发现，这题的$S$，其实就是定理里面的$c$

也就是说，要找一个最小的$c$使方程有解

根据定理， **$S$必须是$\gcd(A_1,A_2,A_3,\cdots,A_n)$的倍数**，**一个数最小的倍数就是它自己**，也就是说，只要**求这些数的最大公因数**就成啦！（出现负数不要慌，不用管它，直接取相反数就行）

code:（就是求最大公因数，不用注释了吧qwq）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
int tql,wyx,akioi;
inline int nb(){//快读
	char c=getchar();
	int f=1,x=0;
	while(c<'0'||c>'9'){
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	return x*f;
}
inline int txdy(int a,int b){//求两个数的gcd
	if(b==0)
	return a;
	return txdy(b,a%b);
}
int main(){
	tql=nb();
	while(tql--){
		wyx=nb();
		if(wyx<0)wyx=-wyx;
		akioi=txdy(wyx,akioi);//很简单的操作啦！
	}
	printf("%d",akioi);
}
```
The end

---

## 作者：Vozeo (赞：1)

这道题写的是`Bézout`定理，不过可能要用到一个最大公约数理论的定理：
> 设$a_1,\cdots ,a_i$是不全为0的整数，有$$\gcd(a_1,\cdots,a_i) = \min(s = a_1x_1+\cdots+a_ix_i)$$其中$x_j \in \mathbb{Z}(1 \le j \le i), s > 0$，即$\gcd(a_1,\cdots ,a_i)$等于$a_1,\cdots ,a_i$的所有整系数线性组合组成的集合中的最小正整数。

给出一个~~可能不太完备的~~证明（引用的部分是对这句证明的解释）：

设$S$表示$a_1,\cdots ,a_i$的所有整系数线性组合组成的集合，则$S$中必有一个最小的正整数，设为$s_0$。

对$a_1,\cdots ,a_i$的任一个公约数$d$，都有$d \mid s_0$，所以$|d| \le s_0$。**即$s_0$不小于$a_1,\cdots ,a_i$的任一个公约数。**
> 因为$d$是$a_1,\cdots ,a_i$的公约数，所以必然能整除$a_1,\cdots ,a_i$的所有线性组合。

对任意$a_j$，设$a_j = q_js_0 + r_j$，其中$0 \le r_j < s_0$，则有$r_j \in S$。
> 因为$a_j \in S$，$s_0 \in S$，且有$r_j = a_j - q_js_0$，所以$a_j$和$s_0$的线性组合$r_j \in S$。

若$r_j>0$，则与$s_0$是$S$中最小的正整数矛盾，所以$r_j=0$，即$s_0 \mid a_j$。**也即$s_0$是$a_1,\cdots,a_i$的公约数。**

所以$s_0 = \gcd(a_1,\cdots,a_i)$。

$$\mathcal{Q.E.D}$$

这个定理在一些数论书上能够见到（比如《初等数论》）。

所以这道题只需要求一下所有数字的$\gcd$就好啦。代码就不放了。

---

## 作者：shigengxin (赞：0)

### 裴蜀定理
**裴蜀定理**是数论中的重要分块，其内容大致如下：
对于任意不全为零的整数 $a$ 和 $b$，存在整数 $x$ 和 $y$，使得：
$$
ax + by = \gcd(a,b)
$$
将这个定理推广到多个整数的情况。对于 $n$ 个整数 $A_1,A_2,A_3,\ldots,A_n$（不全为零），存在整数序列 $X_1,X_2,X_3,\ldots,X_n$ 使得：
$$
\sum_{i=1}^n A_i \times X_i = \gcd(A_1,A_2,A_3,\ldots,A_n)
$$
### 题目解析
题目要求我们找到一个整数序列 $X$，使得 $S = \sum\limits_{i=1}^n A_i \times X_i$ 为正数，并且 $S$ 尽可能小。根据定理，$S$ 的最小正值就是所有 $A_i$ 的绝对值的最大公约数。这是因为：
* 裴蜀定理告诉我们，$S$ 可以取到 $\gcd(A_1,A_2,A_3,\ldots,A_n)$ 的值。
* 任何 $S$ 的正值都必须是 $\gcd(A_1,A_2,A_3,\ldots,A_n)$ 的倍数（因为 $\gcd$ 是所有 $A_i$ 的线性组合的最小正值）。
* 因此，最小的正值 $S$ 就是 $\gcd$ 本身。
### 解题步骤
* 计算所有 $A_i$ 的绝对值的最大公约数 $m$。
* 最终的 $m$ 就是答案。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a;
int gcdd(int a,int b){
	return (!b) ? a : gcd(b,a % b);//辗转相除法
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    int m = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a;
        a = abs(a);
        m = gcdd(m, a);
    }
    cout << m;
    return 0;
}
```
### 复杂度分析
* 时间复杂度：$O(n \cdot \log(\max(|A_i|)))$。
* 空间复杂度：$O(n)$。

---

## 作者：ni_ju_ge (赞：0)

## 裴蜀定理
[模版](https://www.luogu.com.cn/problem/P4549)。

一定存在 $x,y$ 满足 $ax+by=\gcd(a,b)$。

该定理对不定方程是否有整数解做出了一个判定方式。
### 证明
设取整数 $x_0,y_0$ 时，$ax_0+by_0=m$，$\gcd(a,b)=k$，$m$ 为满足条件的最小正整数。

现在要证 $m=k$。

因为 $x_0,y_0$ 为整数，所以有 $k\mid ax_0,k\mid by_0$，则 $k\mid ax_0+by_0$，得 $k\mid m$（1）。

设 $a=qm+r(0\le r<m)$，则有

$$r=a-qm=a-q(ax_0+by_0)=a-aqx_0-bqy_0=a(1-qx_0)+b(-qy_0)$$

因为 $qx_0,qy_0$ 均为整数，所以可以使 $x=1-qx_0,y=-qy_0,r=ax+by$。

由于 $r<m$ 且 $m$ 是满足条件的最小正整数，所以 $r=0,a=qm$，因此 $m\mid a$，同理得 $m\mid b$，故 $m\mid k$（2）。

综合（1）（2）得：$m=k$ 得证。

简单思考一下可以发现，若 $ax'+by'=k\times\gcd(a,b)$，则 $x',y'$，变为原解的 $k$ 倍即可，故形如 $ax+by=c$ 的不定方程只要满足 $c=k\times\gcd(a,b)$ 就有整数解，$k$ 为整数。

同理可得，$n$ 个未知数的不定方程 $\sum_{i=1}^{n} a_ix_i=s$ 满足 $s=k\times\gcd(a_i)$ 时有整数解（$k$ 为整数）。

根据上面的结论求出 $\gcd(\left|A_i\right|)$ 即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int G(int x, int y) {//gcd 模版
	return y ? G(y, x%y) : x;
}
long long n;
int main() {
	cin>>n;
	long long ans,a;
    ans=0;
	for(int i=1; i<=n; i++) {
		cin>>a;
		if(a<0)a=-a;
		ans=G(ans,a);
	}
	cout<<ans;
}
```

---


# [GESP202312 七级] 商品交易

## 题目描述

市场上共有 $N$ 种商品，编号从 $0$ 至 $N-1$ ，其中，第 $i$ 种商品价值 $v_i$ 元。

现在共有 $M$ 个商人，编号从 $0$ 至 $M-1$ 。在第 $j$ 个商人这，你可以使用你手上的第 $x_j$ 种商品交换商人手上的第 $y_j$ 种商品。每个商人都会按照商品价值进行交易，具体来说，如果 $v_{x_j}>v_{y_j}$，他将会付给你 $v_{x_j}-v_{y_j}$元钱；否则，那么你需要付给商人 $v_{y_j}-v_{x_j}$ 元钱。除此之外，每次交易商人还会收取 $1$ 元作为手续费，不论交易商品的价值孰高孰低。

你现在拥有商品 $a$ ，并希望通过一些交换来获得商品 $b$ 。请问你至少要花费多少钱？（当然，这个最小花费也可能是负数，这表示你可以在完成目标的同时赚取一些钱。）

## 说明/提示

**数据范围**

对于30%的测试点，保证 $N ≤ 10$ ，$M ≤ 20$。

对于70%的测试点，保证 $N ≤10^3$ ，$M≤10^4$。

对于100%的测试点，保证 $N≤10^5$，$M≤2×10^5$。

## 样例 #1

### 输入

```
3 5 0 2
1 2 4
1 0
2 0
0 1
2 1
1 2```

### 输出

```
5```

## 样例 #2

### 输入

```
3 3 0 2
100 2 4
0 1
1 2
0 2```

### 输出

```
-95```

## 样例 #3

### 输入

```
4 4 3 0
1 2 3 4
1 0
0 1
3 2
2 3```

### 输出

```
No solution```

# 题解

## 作者：一扶苏一 (赞：32)

容易发现，如果经过了 $k$ 次交易后从 $a$ 得到 $b$，假设商品的交易过程是 $a \to x_1 \to x_2 \to \dots \to x_{k - 1} \to b$，那么收益就是 $(v_{x_1} - v_a + 1) + (v_{x_2} + v_{x_1} + 1) + \dots + (v_b - v_{k - 1} + 1)$。把 $+1$ 都提出来，共有 $k$ 个。余下的项去括号，可以看到 $v_{x_i}$ 的符号以正负各出现了一次，被抵消掉了。所以总收益就是 $v_b - v_a + k$。

$v_b$ 和 $v_a$ 是定值，所以只需要最小化交易次数 $k$。

对于一个交换 $x_i$ 和 $y_i$ 商品的商人，连边 $y_i \to x_i$，表示从 $y_i$ 得到 $x_i$ 需要一次交易。那么从 $a$ 到 $b$ 的最短路就是最小交换次数。

边权全为 $1$，跑 bfs 即可。

```cpp
#include <bits/stdc++.h>

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, a, b;
  std::cin >> n >> m >> a >> b;
  std::vector<int> v(n);
  for (auto &i : v) std::cin >> i;
  std::vector<std::vector<int>> chg(n);
  for (int x, y; m; --m) {
    std::cin >> x >> y;
    chg[x].push_back(y);
  }
  std::vector<int> f(n, 1100000000);
  f[a] = 0;
  std::queue<int> Q;
  for (Q.push(a); !Q.empty(); Q.pop()) {
    int u = Q.front();
    for (auto v : chg[u]) {
      if (f[v] > f[u] + 1) {
        f[v] = f[u] + 1;
        Q.push(v);
      }
    }
  }
  if (f[b] == 1100000000) {
    std::cout << "No solution\n";
  } else {
    std::cout << f[b] + v[b] - v[a] << std::endl;
  }
}
```

---

## 作者：Cute__yhb (赞：13)

## 思路

设从 $a$ 到 $b$ 上经过的点为 $a_{1,2,\cdot\cdot\cdot,k}$。

那么这条路径的花费为 $v_{a_2}-v_{a_1}+1+v_{a_3}-v_{a_2}+1+\cdot\cdot\cdot+v_{a_{k}}-v_{a_{k-1}}+1$。

化简一下，上面那个式子就相当于 $v_{a_k}-v_1+k-1$。

点数为 $k$，$k-1$ 就是边数。

直接广搜即可。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define fi first
#define se second
#define pii pair<int,int>
#define pb push_back
int n,m,a,b,v[100005],vis[100005];
vector<int>g[100005];
int main(){
	cin>>n>>m>>a>>b;
	for(int i=0;i<n;i++) cin>>v[i];
	while(m--){
		int x,y;
		cin>>x>>y;
		g[x].pb(y);//有向边
	}
    //广搜
	queue<pii>q;
	q.push({a,0});
	while(!q.empty()){
		int x=q.front().fi;
		int y=q.front().se;
		if(x==b){//到达终点
			cout<<y+v[b]-v[a];
			return 0;
		}
		q.pop();
		for(auto i:g[x]){
			if(!vis[i]){
				vis[i]=1;
				q.push({i,y+1});
			}
		}
	}
	cout<<"No solution";//无解
    return 0;
}
```


---

## 作者：PR_CYJ (赞：10)

# [题目传送门](https://www.luogu.com.cn/problem/P10110)
# 题意
这道题题意很明显，就是最短路。
# 思路
本来看到这道题有负边权，以为要用 SPFA，但是考虑到其容易被卡出翔，所以本蒟蒻就在想如何才能用 Dijkstra。

稍微思考一下，此题路径中的中间商品因为负权的存在直接抵消了，所以实际花费应该是 $ v_b-v_a+s $。其中 $ s $ 为交换次数，即路径长度。具体原因[一扶苏一的题解](https://www.luogu.com.cn/blog/fusu2333/solution-p10110)中已经讲过了，本篇题解就不详细叙述。因为 $ v_a $ 和 $ v_b $ 已知，所以我们要最小化 $ s $。将每次交易看成建立一条边权为 $ 1 $，由 $ x_i $ 向 $ y_i $ 的有向边，直接跑 Dijkstra。注意要用**小根堆**！！！
# 代码
- 请勿抄袭！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=250000;
int n,m,bg,ed,ans,cnt,a[N],h[N],to[N],nt[N],w[N],dis[N];
bool vis[N];
inline void add(int u,int v)
{
	cnt++;
	w[cnt]=1;
	to[cnt]=v;
	nt[cnt]=h[u];
	h[u]=cnt;
}
inline void dijkstra()
{
	priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> q;//小根堆 
	memset(dis,127,sizeof(dis));
	dis[bg]=0;
	q.push({dis[bg],bg});
	while(!q.empty())
	{
		int pos=q.top().second;
		q.pop();
		if (vis[pos])
			continue;
		vis[pos]=true;
		for(int i=h[pos];i;i=nt[i])
		{
			if (dis[to[i]]>dis[pos]+w[i])
			{
				dis[to[i]]=dis[pos]+w[i];
				q.push({dis[to[i]],to[i]});
			}
		}
	}
}
int main()
{
	cin>>n>>m>>bg>>ed;
	for(int i=0;i<n;i++)
		cin>>a[i];
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		add(u,v);
	}//建图 
	dijkstra();
	if (dis[ed]==2139062143)
		cout<<"No solution"<<endl;
	else
	cout<<a[ed]-a[bg]+dis[ed]<<endl;//输出答案 
}
```

---

## 作者：封禁用户 (赞：10)

这里证明最朴素的 SPFA 是线性的。

首先，分析 `dis` 数组，由于每条路径 $a_1-a_2-\cdots-a_{k+1}$ 的权值 $(v_{a_2}-v_{a_1}+1)+(v_{a_3}-v_{a_2}+1)+\dots+(v_{a_{k+1}}-v_{a_k}+1)$，化简后得到 $v_{a_{k+1}}-v_{a_1}+k$，而对于固定的顶点 $a_{k+1}$，$v_{a_{k+1}}-v_{a_1}$ 是固定的，且对于相邻的顶点的三角不等式，$dis_x+(v_y-v_x+1)<dis_y \iff v_x-v_1+len_x+v_y-v_x+1<v_y-v_1+len_y \iff len_x+1<len_y$ 与 $v$ 无关，所以 $v$ 数组对于 SPFA 的时间复杂度无关，下面不妨设 $\forall i,v_i=0$。

于是 SPFA 在更新时每个点会往下一个点连一条权值为 $1$ 的边，而如果此时将 SPFA 分成很多轮，每轮将**本轮开始前的队列清空**，就会等价于 BFS 的一轮，故整个过程等价于 BFS。

综上所述，本题 SPFA 时间复杂度 $=$ BFS 时间复杂度 $= O(n+m)$。

证毕。

---

## 作者：2023gdgz01 (赞：5)

模版 SPFA 算法。

我们把问题抽象成：有编号为 $0$ 到 $n-1$ 的 $n$ 个点和 $m$ 条带权有向边，请你求出从 $a$ 点到 $b$ 点的最短路径长度，若不能从 $a$ 点到 $b$ 点，输出 `No solution`。根据题意，第 $j$ 条边为 $x_j\to y_j$，边权为 $v_{y_j}-v_{x_j}+1$。由于边权可能为负（交易时商人付我们钱），所以使用 SPFA 算法。

代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

struct edge { //链式前向星存图
	int next, to, w;
};

bool in[100005];
int n, m, a, b, x, y, cur, v[100005], dis[100005], head[100005];
queue<int> q;
edge e[200005];

inline void add(int u, int v, int w) { //链式前向星加边
	++cur;
	e[cur] = {head[u], v, w};
	head[u] = cur;
}

inline void spfa() { //最短路径之 SPFA 算法（关于 SPFA，它 GESP 了）
	memset(dis, 0x3f, sizeof(dis));
	dis[a] = 0;
	q.push(a);
	while (!q.empty()) {
		x = q.front();
		q.pop();
		in[x] = false;
		for (register int i = head[x]; i; i = e[i].next) { //松弛
			y = e[i].to;
			if (dis[x] + e[i].w < dis[y]) {
				dis[y] = dis[x] + e[i].w;
				if (!in[y]) {
					q.push(y);
					in[y] = true;
				}
			}
		}
	}
}

int main() {
	scanf("%d%d%d%d", &n, &m, &a, &b);
	for (register int i = 0; i < n; ++i)
		scanf("%d", v + i);
	while (m--) {
		scanf("%d%d", &x, &y);
		add(x, y, v[y] - v[x] + 1); //注意边权
	}
	spfa();
	if (dis[b] == 0x3f3f3f3f)
		printf("No solution");
	else
		printf("%d", dis[b]);
	return 0;
}
```

[AC 链接](https://www.luogu.com.cn/record/144950188)

---

## 作者：Remarks (赞：3)

~~看扶苏老师的帖子过来的。~~

看这道题题解区并没有非 SPFA 做法，那就写一篇吧。

做法：BFS ，时间复杂度 $O(M)$。

关注到，假如我们现在持有商品 A ，以此交换商品 B ，再交换商品 C ，我们付出的代价是 $(V_B-V_A+1)+(V_C-V_B+1)=V_C-V_A+2$。感性理解，即为我们交换到一个商品之后变成了我们的筹码，而商品的价值不变，因此我们知己上付出的代价只与 $V_a,V_b$ 与交换商品的次数有关。

直接建图，有商人愿意交换就连一条权值为 $1$ 的边。从 $a$ 到 $b$ 的最短路即为要付出的最小总手续费，即为这一部分用 BFS 即可在 $O(M)$ 的时间内完成。如果 $a,b$ 不连通则输出 `No solution`。最后的答案为 $V_a-V_B+ans$。

注意一下点的编号是 $[0,n-1]$，可以在读入的时候手动 $+1$。

code:

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;

const int NR=100050;
const int MR=200050;
struct edge{
    int t=0;edge* nxt;
}link[MR];edge* hd[NR];int tote=0;
void adde(int f,int t){link[++tote].t=t;link[tote].nxt=hd[f];hd[f]=link+tote;return;}
//链式前向星存图，本人有压行习惯，见谅。
queue<int>q[100050];//最多走100000步就能到。
bool vis[100050];
int bfs(int f,int t){
    //直接bfs就结束了。
    q[0].push(f);
    vis[f]=0;
    for(int step=1;!q[step-1].empty();step++){
        while(!q[step-1].empty()){
            int s=q[step-1].front();q[step-1].pop();
            vis[s]=true;
            for(edge* x=hd[s];x!=link+0;x=x->nxt){
                if(vis[x->t])continue;
                if(x->t==t)return step;
                q[step].push(x->t);
                //放到对应层就行了。
            }
        }
    }
    //上一步空了，那这一步肯定没有，返回-1.
    return -1;
}
int main(){
    int n,m,f,t;
    cin>>n>>m>>f>>t;f++;t++;
    int vf=0;//事实上我们只需要关心起始和终止的价差是多少
    for(int i=1;i<=n;i++){
        int x;scanf("%d",&x);
        if(i==f)vf+=x;
        if(i==t)vf-=x;
        hd[i]=link+0;
    }
    for(int i=1;i<=m;i++){
        int f,t;scanf("%d%d",&f,&t);
        adde(f+1,t+1);
    }
    int ans=bfs(f,t);
    if(ans==-1)cout<<"No solution\n";
    else cout<<-(vf-ans)<<endl;
    return 0;
}
```

---


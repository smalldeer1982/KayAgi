# [Opoi 2024] 数据转换

## 题目背景

![](data:image/jpeg;base64,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)

![](https://tse2-mm.cn.bing.net/th/id/OIP-C.ojcWO_62WQhtFFaZSdmbgAHaEo?w=244&h=180&c=7&r=0&o=5&pid=1.7)

Arrda 家里面有很多五花八门的用电器和数据线，而且很多用电器的插头种类都不一样，这导致每次 Arrda 想要共享两个用电器的数据时都要一半天用来买到合适的数据线，而且有的时候数据线很贵！

于是 Arrda 想让你求出花钱最少的数据转换方案。

## 题目描述

Arrda 家中有 $n$ 类，$2n$ 种数据线接头，每一类插头有 $2$ 种不同接头，种类分别为 $i$ 和 $n+i$，**有且只有同一类的不同接头可以互相连接（你可以理解为 $i$ 是凸出的接头，$n + i$ 是凹的接头，可以连接可以理解为插上）**。

商城里售卖着 $m$ 种双向数据线，每根双向数据线两端各有一个接头，种类分别为为 $u_i,v_i$。同时，第 $i$ 种双向数据线有一个购买价格 $w_i$，每种数据线可以购买无限条。

Arrda 想要交换两个用电器的数据，其中两个用电器的接头种类编号为 $S,T$，求能使这两个用电器能直接或由若干条数据线相连的最小总价格（毕竟买数据线需要钱），如果无解，输出 `I have no idea how to solve it.`，注意，**两个用电器的接口不能直接连接数据线，因为它们在用电器上，而非数据线两端！**

## 说明/提示

### 样例 1 解释：

![picture](https://cdn.luogu.com.cn/upload/image_hosting/4j95t4xl.png)

```
1=5->6=2->3=7->8=4
```

可以证明，没有总代价更小的方案。

### 样例 4 解释

![222](https://cdn.luogu.com.cn/upload/image_hosting/k88cjz1t.png)

```
1=6->8=3->5=10->3=8->6=1->9=4->7=2
```
`4->6` 有两种数据线，我们选择代价为 $182080546$ 的那一根，因为其代价更小。

可以证明，没有总代价更小的方案。

### 数据范围

对于 $100\%$ 的数据，$1\le n,m \le 10^5$，$1\le u_i,v_i,s,t \le 2 \times n$，$1\le w_i \le 10^9$。

## 样例 #1

### 输入

```
4 4
5 8 10
7 8 2
2 3 1
5 6 5
1 4```

### 输出

```
8```

## 样例 #2

### 输入

```
4 1
2 3 1
1 8```

### 输出

```
I have no idea how to solve it.```

## 样例 #3

### 输入

```
4 1
2 3 1
1 5```

### 输出

```
0```

## 样例 #4

### 输入

```
5 10
1 2 603124134
2 3 373980902
2 4 6578324
3 5 936364479
4 6 182080546
4 7 340293479
6 8 753053273
1 9 274129271
3 10 616764767
4 6 255802600
1 2```

### 输出

```
3673658542```

# 题解

## 作者：shuqiang (赞：11)

这个题目分成两个部分，题目转化和求最短路。

### 题目转化

因为题目说每一类插头有 $2$ 种不同接头，种类分别为 $i$ 和 $n+i$，有且只有同一类的不同接头可以互相连接，所以存边可以存这个电线可以连的电线，而不是这个电线本身的类型，这样题目就变成一个简单的求最短路问题了。

### 求最短路
求最短路可以使用 Dijkstra 算法，这个算法的时间复杂度上限是 $\mathcal{O}(n^2)$，用堆优化后复杂度为$\mathcal{O}(m\log n)$，明显可以过这题。在这之前建议先完成 [P3371](https://www.luogu.com.cn/problem/P3371)。

Dijkstra 算法的流程：
1. 先初始化 $dis_{s}=0$，其它为无穷大。
2. 找一个最小的 $dis_{i}$，此时 $dis_{i}$ 已经是最小的，所以不可能有别的路径可以更新 $dis_{i}$，这个步骤可以用堆优化。
3. 找到所有与点 $i$ 连接的点 $j$，如果通过这个点的路径更短，更新 $dis_{j}$ 为 $dis_{i}+i$ 到 $j$ 的距离。
4. 如果全部点都访问完毕，跳出循环，否则回到第 2 步。
5. 如果 $dis_{t}$ 还是无穷大，说明无解，输出 `I have no idea how to solve it.`，否则输出 $dis_{t}$。

AC 代码：
```cpp
#include<iostream>
#include<vector>
#include<cstring>
#include<queue>

using namespace std;
typedef long long ll;

struct node{
	ll dis, u;
	bool operator > (const node & o) const{
		return dis > o.dis;
	}
};
priority_queue<node, vector<node>, greater<node>> pq;

struct Edge{
	ll to, w;
};

const int N = 1e5 * 2 + 10;
const ll inf = 1e18;
vector<Edge> e[N];
ll dis[N], n, m, s, t, u, v, w;
bool vis[N];

void dijkstra(int s){
	for(int i = 0; i < N; i++) dis[i] = inf;
	dis[s] = 0;
	pq.push({0, s});
	while(!pq.empty()){
		int u = pq.top().u;
		pq.pop();
		if (vis[u]) continue;
		vis[u] = true;
		for(auto ed: e[u]){
			int v = ed.to, w = ed.w;
			if(dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				pq.push({dis[v], v});
			}
		}
	}
}

int main(){
	cin >> n >> m;
	for(int i = 0; i < m; i++){
		cin >> u >> v >> w;
		if(v > n) v -= n;
		else v += n;
		e[u].push_back({v, w});
		if(v > n) v -= n;
		else v += n;
		if(u > n) u -= n;
		else u += n;
		e[v].push_back({u, w});
	}
	cin >> s >> t;
	if(s > n) s -= n;
	else s += n;
	dijkstra(s);
	if(dis[t] == inf) cout << "I have no idea how to solve it.";
	else cout << dis[t];
	return 0;
} 
```

---

## 作者：yywlp (赞：5)

~~考场上看这题切的人多就先来做的欺软怕硬的屑~~

挺有意思的，第一眼以为简单的连边，再把 $(i,n+i)$ 连一下跑最短路就行，结果发现过不了样例。

仔细思考了下，发现直接连边会导致没办法保证 $(i,n+i)$ 的转换条件。比如有两条边 $(2,4)\ (4,6)$，直接连边会导致出现这样的路径： $2\longrightarrow 4\longrightarrow 6$。

中间忽略了 $4$ 只能和 $4+n$ 匹配的限制，所以我们需要：**拆点**！

我们把 $1\sim 2n$ 的点都拆出一个 $i'$ 挂在天上当中转站，对于一条边 $(u,v,w)$，都要分配一个新编号，我们让 $c_1$ 代表 $u$，$c_2$ 代表 $v$。

这里我们定义 

$$f(x)=\begin{cases}x+n,x\le n
 \\x-n,x>n 
\end{cases}$$

用人话来说就是**为一个接头找到它的配对接头**。

那么我们这样连边 $(v',c_1,w),(c_1,f(u'),0),(u',c_2,w),(c_2,f(v'),0)$，$u',v'$ 就是上面提到的挂在天上的中转点。

**注意：这里连的都是单向边。**

对于 $(c_1,f(u'),0)$ 保证这个接口要往后连一定会匹配它的配对接头。

对于 $(v',c_1,w)$ 保证了 $(v,u)$ 的连通性。

对于 $(c_2,f(v'),0),(u',c_2,w)$ 则与上一个意义相反。

这样我们就使 $(u,v)$ 联通而且在继续连的时候保证匹配关系了。

最后从 $f(s')$ 开始跑最短路，$t'$ 就是答案了。

点的个数是 $D=2\times m+2\times n$，边的个数同阶。

所以复杂度 $\Theta(D\log{D})$，可以通过。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int M=1e6+10;
int n,m;
struct EDGE{
	int v,w;
};
vector<EDGE>G[M];
void add(int u,int v,int w){
	G[u].push_back(EDGE{v,w});
}
int dis[M];
struct NODE{
	int v,id;
	bool operator <(NODE A)const{
		return v>A.v;
	}
};
int cnt=0;
bool pd[M];
void dij(int s){
	for(int i=0;i<M;i++)dis[i]=1e15;
	dis[s]=0;
	priority_queue<NODE>q;
	q.push(NODE{0,s});
	while(!q.empty()){
		NODE zc=q.top();
		q.pop();
		int u=zc.id;
		if(pd[u])continue;
		pd[u]=true;
		for(EDGE it:G[u]){
			int v=it.v,w=it.w;
			if(dis[u]+w<dis[v]){
				dis[v]=dis[u]+w;
				q.push(NODE{dis[v],v});
			}
		}
	}
}
int getf(int x){
	if(x<=4*m+n)return x+n;
	return x-n;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,w;scanf("%lld%lld%lld",&u,&v,&w);
		add(4*m+v,++cnt,w);
		add(cnt,getf(4*m+u),0);
		add(4*m+u,++cnt,w);
		add(cnt,getf(4*m+v),0);
	}
	int s,t;cin>>s>>t;
	s=getf(4*m+s),t+=4*m;
	dij(s);
	if(dis[t]==1e15)puts("I have no idea how to solve it.");
	else cout<<dis[t]<<endl;
	return 0;
}
```

---

## 作者：chenzhaoxu2027 (赞：5)

# 前言

官方题解我完全不懂，我不太会这种最短路 DIJ 上边的 DP，所以我写的是一种奇妙做法，竟然 AC 了？

# 分析

首先，我们假定编号小于 $n$ 的插头是凹的，其他插头是凸的。

数据线的连接遵循以下规律（$=$ 是直接插入，$-$ 是数据线连接。）：电脑 1$=a_1-b_1=a_2-b_2=\dots=a_{m-1}-b_{m-1}=a_m-b_m=$ 电脑 2。

所以不妨把一个等于与一个杠看为整体，比如说命名为 $\odot$，那么连接过程变为：电脑 1$\odot b_1\odot b_2\odot \dots \odot b_{m-1}\odot b_m=$ 电脑 2。

所以说，只要把 $\odot$ 关系看作边，电脑 2 给换成互补的插头，再跑一遍最短路即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct edge{
    int to,dis,next;
}e[500005];//前向星
int head[200005],dis[200005],cnt;
bool vis[200005];
int n, m, s;
int canmatch(int x){//求互补点
	if(x>n){
		return x-n;
	} 
	return x+n;
}
void add_edge( int u, int v, int d ){
    cnt++;
    e[cnt].dis=d;
    e[cnt].to=v;
    e[cnt].next=head[u];
    head[u]=cnt;
}
struct node{
    int dis,pos;
    bool operator <(const node &x)const{
        return x.dis<dis;
    }
};
priority_queue<node> q;
void dij(){
    dis[s]=0;
    q.push({0,s});
    while(q.size()){//堆优化 dij
        node tmp=q.top();
        q.pop();
        int x=tmp.pos,d=tmp.dis;
        if(vis[x]){
        	continue;
	}
        vis[x]=1;
        for(int i=head[x];i;i=e[i].next){
            int y=e[i].to;
            if(dis[y]>dis[x]+e[i].dis){
                dis[y]=dis[x]+e[i].dis;
                if(vis[y]==0){
                    q.push({dis[y], y});
                }
            }
        }
    }
}
int t;
signed main(){
	cin>>n>>m;
    for(int i=1;i<=2*n;i++){
    	dis[i]=2e18;
	}
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add_edge(canmatch(u),v,w);
		add_edge(canmatch(v),u,w);
	} 
	cin>>s>>t;
	t=canmatch(t);
	dij();
	if(dis[t]==2e18){
		cout<<"I have no idea how to solve it.";
	}
	else{
		cout<<dis[t];
	}
    return 0;
}
```

---

## 作者：qiliu (赞：4)

俺寻思这题应该放前两道（第二题没想出来 qwq）。

------------

## 思路

不难发现，这题**几乎**是赤裸裸的最短路问题。我们先建边，分两种情况：

- 一根连接 $u_i$ 和 $v_i$ 价值为 $w_i$ 的数据线就相当于有一条 $u_i$ 和 $v_i$ 间权为 $w_i$ 的无向边。

- 因为接头 $i$ 和 $n+i$ 相互匹配不需要数据线，所以每一对 $i(i\leq\frac{n}{2})$ 和 $n+i$ 之间就有一条权为零的边。

我们考虑邻接表建图，因为有权值不同的重边，邻接表刚好能解决这个问题。

至于为什么上问提到“**几乎**”……你可以先交一个最短路的板子上去，会发现只有五十五分。我们以样例四为例，对比一下我们的图和样例解释的图。

我们的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/tyxqnsxt.png)

注意节点四，直接写最短路会直接从 ```6->4``` 这条边跑到 ```4->2``` 这条边。我们发现，对于一个点 $i$，和他链接的点必须是与他配套的 $n+i$，反之亦然。所以我们写最短路时，往下拓展的那一条边起点不能是这个点本身，应该从他配套的点开始拓展。感性理解一下，如果有两个 USB 插头，你不能直接把他们怼到一块去，你需要一个两段都是 USB 接口的数据线把他们接在一起。

举个例子，如果我们来到了节点四，正常来讲我们应该从四的边里往下选一条拓展。但是由于上述性质，我们需要从节点九向下拓展。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define DEBUG(x) cerr<<#x<<'='<<x<<endl
using namespace std;
const int MAX=6e6+100;
int n,m;
struct ed
{
	int to,w,next;
}edge[MAX];
int head[MAX],cnt;
void add(int u,int v,int w)
{
	edge[++cnt] = (ed){v,w,head[u]}; head[u]=cnt;
}
//邻接表存图。本人太菜不敢用指针。
int dis[MAX];
bool use[MAX];
inline int change(int x)//获取与当前接头匹配的另一个接头。
{
	if(x>n/2)return x-n/2;
	return x+n/2;//因为题目里说有2*n种接头，所以在输入完之后就把n乘2了。于是这里的n都变成了n/2。
}
void dijkstra(int s)
{
	for(int i=1;i<=n;i++)
	{
		dis[i]=1e18;
	}
	dis[s]=0;
	priority_queue< pair<int,int> ,vector< pair<int,int> > ,greater< pair<int,int> > >q;
	q.push( make_pair(0,s) );
	while(!q.empty())
	{
		int v=q.top().second;
//		cout<<v<<' '<<dis[v]<<' '<<q.top().first<<endl;
		q.pop();
		if(use[v])continue;
		use[v]=1;
		for(int i=head[change(v)];i;i=edge[i].next)//要从与v匹配的另一个开始，另一个就是change(v)
		{
			if(dis[edge[i].to]>dis[v]+edge[i].w)
			{
				dis[edge[i].to]=dis[v]+edge[i].w;
				q.push(make_pair(dis[edge[i].to],edge[i].to));
			}
		}
	}
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
    	int u,v,w;
    	cin>>u>>v>>w;
    	add(u,v,w);
    	add(v,u,w);
	}
    int s,t;
    cin>>s>>t;
	n*=2;//呼应上文了
	dijkstra(s);
	if(dis[change(t)]==1e18)//实际上到另一个机箱的最短路线就是到另一个机箱匹配的插口的最短路。所以是change(t)。
	{
		cout<<"I have no idea how to solve it.";
	}
	else
	{
		cout<<dis[change(t)];
	}
    //fclose(stdin);
    //fclose(stdout);
	return 0;
}
```
感谢观看！希望有帮到你！

---

## 作者：xmkxk (赞：3)

这题做法应该挺多的，讲一下我的简单做法，有点类似于动态规划（动态规划不太熟，若讲的有错请指出）。另外，建议加强数据（原因见下文）。

------------

首先开一个数组 $f$，设 $f[k]$ 为第 $k$ 种接头接在末尾的最小花费。对于第 $i$ 根线的两种接头 $u[i]$ 和 $v[i]$，分别设其能接上的接口种类为 $uu$ 和 $vv$，显然：
>$f[vv] = \min\{f[vv],f[u[i]]+w[i]\}$

>$f[uu] = \min\{f[uu],f[v[i]]+w[i]\}$

但是有一个问题，我们不能保证数据线一定是按照所给出的顺序连接的，即无法保证无后效性。对于这个问题，我的处理就是在1秒内尽可能多地循环求解。但是这应该并不是正解（出题人不这么想的话就当我没说），所以我觉得数据可以加强。

代码：

```cpp
#include <stdio.h>
#include <string.h>
typedef long long ll;
ll min(ll a,ll b){return a<b?a:b;}

int u[100009],v[100009],w[100009];
ll f[200009];
int main(){
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&u[i],&v[i],&w[i]);
	int s,t;scanf("%d%d",&s,&t);
	int ss=s<=n?s+n:s-n,tt=t<=n?t+n:t-n;
  	//开头要接的和结尾要接的
	memset(f,0x3f,sizeof f);
	f[ss]=0;//记得初始化
	for(int j=1;j<=1e7/m;j++)
	for(int i=1;i<=m;i++){
		if(u[i]==v[i]+n||v[i]==u[i]+n)continue;
      		//接了等于没接，直接跳过
		int uu=u[i]<=n?u[i]+n:u[i]-n;
		int vv=v[i]<=n?v[i]+n:v[i]-n;
		f[vv]=min(f[vv],f[u[i]]+w[i]);
		f[uu]=min(f[uu],f[v[i]]+w[i]);
	}//答案就是用电器接在末尾
	if(f[t]!=0x3f3f3f3f3f3f3f3f)
		printf("%lld",f[t]);
	else printf("I have no idea how to solve it.");
	return 0;
}
```

---

## 作者：流水行船CCD (赞：3)

数据人题解。

这题的题面赛前已经经过一次重构了，没想到仍然很抽象，在此致歉。

## 思路

一眼图论最短路，正权图考虑 Dijkstra，考虑这题与普通图论的区别。考虑后效性，对于一种插头 $i$，其状态可以看作两种：可以成为数据线的一端去连接或者插上一个插头 $i \pm n$。设 DP 方程 $d_{x,0/1}$ 表示将数据转换为第 $x$ 种插头且可不可以成为数据线的一端（可以为 $1$，不可以为 $0$）去连接其它插头的最少贡献。则有：

$$d_{v,0}=\min\{(u,v) \in E | d_{u,1}+w_{u,v}\}$$

$$d_{v,1}= d_{v \pm n,0}$$

最后可以看作是从 $d_{S,0}$ 到 $d_{T,1}$ 的最短路，跑最短路板子即可。由于是正权图，以上贪心算法拥有正确性。

## AC Code

```cpp
#include <bits/stdc++.h>

#define REP(i, l, r) for (int i = l; i <= r; ++i)
#define rep(i, l, r) for (int i = l; i < r; ++i)
#define PER(i, l, r) for (int i = l; i >= r; --i)
#define per(i, l, r) for (int i = l; i > r; --i)

typedef long long ll;
typedef unsigned long long ull;
using namespace std;

namespace fast_IO {
//省略快读
} using namespace fast_IO;

const int N = 1e5 + 7;
const ll inf = 1e17;

namespace clion {
	int n, m, S, T, t_S, t_T;
	int vis[N << 1][2];
	ll d[N << 1][2];
	vector<pair<int, int> > NTT[N];
#define other(x) (x > n ? x - n : x + n)
	struct Node{
		ll val; int avaliable, id;
		bool operator < (const Node &x) const {return val > x.val;}
	};
	priority_queue<Node>q;
	signed main() {
		io >> n >> m;
		int x, y, z;
		REP(i, 1, m) {
			io >> x >> y >> z;
			NTT[x].emplace_back(y, z), NTT[y].emplace_back(x, z);
		}
		io >> S >> T;
		if (other(S) == T) {
			io << "0\n";
			return 0;
		}
		q.push((Node){0, 0, S});
		REP(i, 1, (n << 1)) d[i][0] = d[i][1] = inf;
		d[S][0] = 0;
		while (!q.empty()) {
			int now = q.top().id, avaliable = q.top().avaliable; q.pop();
			if(vis[now][avaliable])continue;
			vis[now][avaliable] = 1;
			if (avaliable) {
				for(auto i : NTT[now]) {
					int v = i.first, w = i.second;	                
					if (d[v][0] > d[now][1] + (ll)w) {
//	                	io<< now <<"->"  <<v<<'\n';
						d[v][0] = d[now][1] + (ll)w;
						q.push((Node){d[v][0], 0, v});
					}
				}
			} else {
				
				if (d[other(now)][1] > d[now][0]) {
//					io <<now<<"=>"<<other(now)<<" "<<d[other(now)][1]<<'\n';
					d[other(now)][1] = d[now][0];
					q.push((Node){d[other(now)][1], 1, other(now)});
				}
			}
		}
		if(!vis[T][1])io << "I have no idea how to solve it.\n";
		else io << d[T][1] << '\n';
		return 0;
	}
}

signed main() {
#ifndef FAST_IO
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
#endif
#ifndef ONLINE_JUDGE
	//    freopen("std.in", "r", stdin);
	//    freopen("user.out", "w", stdout);
	//    freopen("debug.out", "w", stderr);
#endif
	clion::main();
	return 0;
}
```

---

## 作者：MnZnOIer (赞：2)

### 题意简述
每个用电器表示一个节点，而该用电器不能直接连接别的用电器（你可以试试），而需要一个插头和一根数据线，插头为 $x\pm n$（$x$ 为该用电器），数据线只能与插头相连接，不能与用电器相连接（你也可以试试）。但是最后，需要一个插头插到最重要到达的用电器上。

总而言之，其实你也可以通过给手机充电来理解，电源为起始点，手机（即用电器）为终点。

### 解题思路
得知了题意，我们就知道，这是一道模版性较强的最短路问题。如果不知道最短路的朋友，先去做做[这题](https://www.luogu.com.cn/problem/P4779)。

回到本题，瞅一眼数据范围：$n,m\le10^5$。看看这些最短路径算法：
| 算法 | 时间复杂度 |
| :----------: | :----------: |
| Floyd | $\Theta(n^3)$，$10^{15}$，T 飞了 |
| 纯 Dijkstra | $\Theta(n^2)$，$10^{10}$，照样得挂 |
| Bellman-Ford | $\Theta(nm)$，几乎同 Dijkstra |
| SPFA | 极其玄学，最坏为 $\Theta(nm)$ |
| 堆优化 Dijkstra | $\Theta(m\log n)$，约为 $1.6\times 10^6$，十分优秀 |

如果用前三个，得 T 出天际，所以我们考虑后两个。但是关于 SPFA，他死了，所以我们使用堆优化后的 Dijkstra。

但是需要注意，转移邻接点时，需要转移他的插头的对应邻接点。并且他有 $2n$ 个节点，初始化时要小心。

### 代码部分
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5, INF = 1e17;
struct edge {int v, w;};
vector <edge> e[N];邻接表存图
int n, m, s, t, d[N];
priority_queue <pair <int, int>, vector <pair <int, int> >, greater <pair <int, int> > > q;
int cht (int x){return x > n ? x - n : x + n;}计算 x 的插头
signed main ()
{
	ios::sync_with_stdio (0), cin.tie (0), cout.tie (0);
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		int u, v, w;
		cin >> u >> v >> w;
		e[u].push_back ({v, w}), e[v].push_back ({u, w});双向边
	}
	cin >> s >> t;
	if (cht (s) == t)特判插个插头就可以
	{
		cout << 0;
		return 0;
	}
	for (int i = 1; i <= 2 * n; i++)d[i] = INF;初始化极大值
	d[s] = 0;起始点初始化为 0
	q.push ({0, s});
	while (! q.empty ())
	{
		int uu = q.top ().second;
		int u = cht (uu);从当前点的插头开始
		q.pop ();
		for (int i = 0; i < e[u].size (); ++ i)
		{
			int v = e[u][i].v, w = e[u][i].w;
			if (d[uu] + w < d[v])不是从插头开始转移，是从用电器开始转移
			{
				d[v] = d[uu] + w;
				q.push ({d[uu] + w, v});
			}
		}
	}
	if (d[cht (t)] == INF)cout << "I have no idea how to solve it.";最后还要插个插头
	else cout << d[cht (t)];
    return 0;
}
```
写题不易，给个赞再走吧！

---

## 作者：WhiteNight__ (赞：1)

# P10535 题解
## 题目链接
[P10535](https://www.luogu.com.cn/problem/P10535)
## 题目简述
从用电器 $S$ 点连接用电器 $T$ 点，中间可用数据线连接，每个数据线连接着两个数据线接头，只有第 $i$ 个数据线接头插入第 $n+i$ 个数据线接头（或者反着插入）才能对应上，但是两个用电器 $S$ , $T$ 中间不能直接用数据线连接。
## 思路分析
由于数据范围比较大，很容易想到用 Dijkstra 算法求 $S$ , $T$ 两点之间的最短路径。

可以想到当跑到一个点时用的是第 $i$ 个数据接头时，继续往后时应该用第 $n+i$ 个数据接头才能对应（反之同理）。
## 代码实现
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>

#define int long long 
// 一个小技巧 ，直接把 int 换为 long long 
// 后面把 "int main()" 改为 "signed main()" 就可以了

inline int ask (int);
inline void Input_P ();
inline void Output_P ();
inline void Add_Edge (int , int , int);
void Dijkstra (int);

struct Edge { // 链式前向星
	int to , next , dis;
}edge[400050];

struct Ques {
	int to , dis;
	bool operator < (const Ques &k) const {
		return k.dis < dis;
	}
};

int N , M , S , T , cnt , head[200050] , dis[200050]; // 数组要多开一倍
bool vis[200050];

inline int ask (int x_) // 求相对应的数据接头编号
{
	return x_ > N ? x_ - N : x_ + N;
}

inline void Input_P ()
{
	scanf("%lld%lld",&N,&M);
	for(int i = 1 ; i <= M ; i ++)
	{
		int u , v , w;
		scanf("%lld%lld%lld",&u,&v,&w);
		Add_Edge(u , v , w);
		Add_Edge(v , u , w);
	}
	scanf("%lld%lld",&S,&T);
}

inline void Output_P ()
{
	if(dis[ask(T)] == 0x3f3f3f3f3f3f3f3f) 
		// 判断时要判断与T点相对应的点的最短路
		// 因为只有与T点相对应的点才能插入T接头
		printf("I have no idea how to solve it.\n");
	else printf("%lld\n",dis[ask(T)]);
}

inline void Add_Edge (int in_ , int ou_ , int dis_)
{
	// 链式前向星
	++ cnt;
	edge[cnt].dis = dis_;
	edge[cnt].to = ou_;
	edge[cnt].next = head[in_];
	head[in_] = cnt;
}

void Dijkstra (int s)
{
	std::priority_queue <Ques> q;
	memset (dis , 0x3f , sizeof dis); // 注意long long的初始化
	memset (vis , false , sizeof vis);
	
	dis[s] = 0 , q.push({s , 0});
	
	while (!q.empty())
	{
		const Ques t = q.top();
		q.pop();
		if(vis[t.to]) continue;
		vis[t.to] = true;
		
		for(int i = head[ask(t.to)] ; i ; i = edge[i].next)
		{
			// 跑到t.to这个点时用与t.to相对应的接头
			// 相当于转换为跑到了与t.to相对应的接头的最短路
			const int to_ = edge[i].to , dis_ = edge[i].dis;
			if(dis[to_] > dis[t.to] + dis_)
			{
				dis[to_] = dis[t.to] + dis_;
				
				if(!vis[to_])
					q.push({to_ , dis[to_]});
			}
		}
	}
}

signed main()
{
	Input_P();
	Dijkstra(S);
	Output_P();
	return 0;
}
```

---

## 作者：Chu_awa_xing (赞：0)

# P10535 题解

### idea 思路

这道题是一道比较裸的最短路，唯一需要注意的点是在找下一个点时应该以当前点所对应的线的另一点为起点，即 $u+i$ 或 $u-i$ 号点。剩下的就是注意一共有 $2n$ 个点并且是无向图。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=5e5+5;
int s,t;
const int inf=2147483647;
int n,m,cnt;
int f[maxn*2],vis[maxn*2];
struct edge{
	int to;
	int next;
	int w;
}v[maxn*4];
int head[maxn*2];
void add_edge(int u,int v2,int w){
	v[++cnt].next=head[u];
	v[cnt].to=v2;
	v[cnt].w=w;
	head[u]=cnt;
} 
struct node{
	int d,fd;
	friend bool operator<(node a,node b){
		return a.fd>b.fd;
	}
}tmp;
priority_queue<node> q; 
int query(int x){
	if(x>n){
		return x-n;
	}
	else return x+n;
}
void dij(){
	memset(f,0x3f,sizeof(f));
	f[s]=0;
	tmp.d=s,tmp.fd=0;
	q.push(tmp);
	while(!q.empty()){
		int u=q.top().d;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[query(u)];i;i=v[i].next){
			if(f[v[i].to]>f[u]+v[i].w){
				f[v[i].to]=f[u]+v[i].w;
				tmp.fd=f[v[i].to],tmp.d=v[i].to;
				q.push(tmp);
			}
			
		}
	}
}
signed main(){
	
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b,c;
		cin>>a>>b>>c;
		add_edge(a,b,c);
		add_edge(b,a,c);
	}
	cin>>s>>t;
	dij();
	if(f[query(t)]==0x3f3f3f3f3f3f3f3f){
		cout<<"I have no idea how to solve it."<<endl;
	}
	else cout<<f[query(t)]<<endl;
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：0)

这道题只需要注意一下建边就变成了一个最短路问题。

我们定义 $\text{cal}(x)$ 为：

$$
\text{cal}(x)=\left\{
\begin{array}{rcl}
x-n,       &      &	& x>n\\
x+n,			&		 &   & \text{otherwise}\\
\end{array} \right.
$$

可以发现，这是将 $x$ 种类的接头转换成另外一种形式。

这启发我们将 $u$ 和 $\text{cal}(v)$，$v$ 和 $\text{cal}(u)$ 连边，这样恰好满足两端一边凹，一边凸，再跑一遍最短路即可。

注意数组要开 $2n$ 的大小。

代码如下：
```cpp
vector < pair < ll, ll> > G[200006];
int n, m;
bool vis[200006];
ll d[200006];
#define cal(t) (t > n ? t - n : t + n)
int main() {
	read(n, m);
	rep(i, 1, m, 1) {
		ll u, v, w;
		read(u, v, w);
	    G[u].push_back( {cal(v),w} );
	    G[v].push_back( {cal(u),w} );
	}
	ll s, t;
	read(s, t);
	s = cal(s);
	queue <int> q;
	rep(i, 1, n * 2, 1) d[i] = 1e18;
	d[s] = 0;
	q.push(s);
	while (!q.empty()) {
		ll u = q.front();
		q.pop();
		for (auto p : G[u]) {
			ll v = p.first, w = p.second;
			if (d[v] > d[u] + w) {
				d[v] = d[u] + w;
				q.push(v);
			}
		}
	}
	if (d[t] == 1000000000000000000) {
		cout << "I have no idea how to solve it.";
	}
	else cout << d[t];
}
```

---

## 作者：sbno333 (赞：0)

看到变量名用的 $u_i,v_i,w_i$，想到图论。

假设此时链接的最后一个头为 $x$。

此时想要改变则需要一根带有与 $x$ 对应的接头的数据线，变成数据另一头，花费 $w_i$ 代价。

于是可以抽象成最短路，每根数据线都代表一对边，最后要求连到与 $t$ 对应的边。

注意有 $2n$ 个节点。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s;
int h[400009];
struct td{
	int ne,v,w;
}sd[800009];
int inn;
int ans[400009];
bool vis[400009];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
void add(int a,int b,int c){
	sd[++inn].v=b;
	sd[inn].w=c;
	sd[inn].ne=h[a];
	h[a]=inn;
}
int zz(int s){
	if(s>n/2){
		s-=n/2;
	}else{
		s+=n/2;
	}
	return s;
}
signed main(){
	for(int i=0;i<200009;i++){
		ans[i]=1e18;
	}
	cin>>n>>m;
	n*=2;
	for(int i=1;i<=m;i++){
		int a,b,c;
		cin>>a>>b>>c;
		add(zz(a),b,c);
		add(zz(b),a,c);
	}//连边
	cin>>s;//起始点
	ans[s]=0;
	q.push(make_pair(0,s));
	while(q.size()){
		pair<int,int> s1=q.top();
		q.pop();
		if(vis[s1.second]){
			continue;
		}
		vis[s1.second]=1;
		for(int i=h[s1.second];i;i=sd[i].ne){
			if(ans[sd[i].v]>ans[s1.second]+sd[i].w){
				ans[sd[i].v]=ans[s1.second]+sd[i].w;
				q.push(make_pair(ans[sd[i].v],sd[i].v));
			}
		}
	}
	int t;
	cin>>t;
	t=zz(t);
	if(ans[t]<1e16){
		cout<<ans[t]<<endl;
	}else{
		cout<<"I have no idea how to solve it.";
	}
	return 0;
}
```

---


# [GESP202503 八级] 上学

## 题目描述

C 城可以视为由 $n$ 个结点与 $m$ 条边组成的无向图。 这些结点依次以 $1, 2, \ldots, n$ 标号，边依次以 $1 \leq i \leq m$ 连接边号为 $u_i$ 与 $v_i$ 的结点，长度为 $l_i$ 米。

小 A 的学校坐落在 C 城的编号为 $s$ 的结点。小 A 的同学们共有 $q$ 位，他们想在保证不迟到的前提下，每天尽可能晚地出门上学。但同学们并不会计算从家需要多久才能到学校，于是找到了聪明的小 A。第 $i$ 位同学 ($1 \leq i \leq q$) 告诉小 A，他的家位置于编号为 $h_i$ 的结点，并且他每秒钟能行走 1 米。请你帮小 A 计算，每位同学从家出发需要多少秒才能到达学校呢？

## 说明/提示

**本题采用捆绑测试。**

对于 $20\%$ 的测试点，保证 $q = 1$。

对于另外 $20\%$ 的测试点，保证 $1 \leq n \leq 500$，$1 \leq m \leq 500$。

对于所有测试点，保证 $1 \leq n \leq 2 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq q \leq 2 \times 10^5$，$1 \leq u_i, v_i, s, h_i \leq n$，$1 \leq l_i \leq 10^6$。

## 样例 #1

### 输入

```
5 5 3 3
1 2 3
2 3 2
3 4 1
4 5 3
1 4 2
5
1
4```

### 输出

```
4
3
1```

# 题解

## 作者：laiyouming (赞：7)

#### 思路
我们发现图是双向的。$x$ 到 $y$ 的距离等于 $y$ 到 $x$ 的距离。所以我们可以从学校进行一遍最短路。来统计答案。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,t,b[200001],d[200001],qd;
vector<pair<long long,long long>>a[200001];
set<pair<long long,long long>>c;
void dijkstra(){
	for(long long i=1;i<=n;i++){
		b[i]=1e18;
		c.insert({b[i],i});
	}
	c.erase({b[qd],qd});
	c.insert({0,qd});
	b[qd]=0;
	for(;!c.empty();){
		long long x=(*c.begin()).second;
		c.erase(c.begin());
		for(auto j:a[x]){
			if(b[x]+j.second<b[j.first]){
				c.erase({b[j.first],j.first});
				b[j.first]=b[x]+j.second,d[j.first]=x;
				c.insert({b[j.first],j.first});
			}
		}
	}
}
int main(){
	scanf("%lld%lld%lld%lld",&n,&m,&qd,&t);
	for(long long i=1;i<=m;i++){
		long long x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		a[x].push_back({y,z});
		a[y].push_back({x,z});
	}
	dijkstra();
	for(long long i=1;i<=t;i++){
		long long x;
		scanf("%lld",&x);
		printf("%lld\n",b[x]);
	}
}
```

---

## 作者：FJ_EYoungOneC (赞：4)

### 解题思路

**40pts**

对于每个询问 $x$，做一遍 `Dijkstra` 即可得出 $x$ 从家出发到学校的最短时间。

时间复杂度 $O((n + m)q\log m)$。

**100pts**

由于每个询问的终点均为学校，那么我们可以考虑以学校为起点做一遍 `Dijkstra`，这样就可以求出从学校到所有点的最短时间。

时间复杂度 $O((n + m)\log m + q)$。

### AC_Code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <queue>

#define x frist
#define y second

using namespace std;

typedef long long LL;
typedef pair<LL, int> PLI;

const int N = 2e5 + 10, M = 2 * N;

int n, m, s, q;
int h[N], e[M], w[M], ne[M], idx;
LL dist[N];
bool st[N];

void add(int a, int b, int c)
{
	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

void dijkstra()
{
	memset(dist, 0x3f, sizeof dist);
	dist[s] = 0;
	priority_queue<PLI, vector<PLI>, greater<PLI>> heap;
	heap.push({0, s});

	while (heap.size())
	{
		auto t = heap.top();
		heap.pop();

		auto ver = t.y;
		if (st[ver])
			continue;
		st[ver] = true;

		for (int i = h[ver]; ~i; i = ne[i] )
		{
			int j = e[i];
			if (dist[j] > dist[ver] + w[i])
			{
				dist[j] = dist[ver] + w[i];
				heap.push({dist[j], j});
			}
		}
	}
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> n >> m >> s >> q;

	memset(h, -1, sizeof h);

	while (m -- )
	{
		int a, b, c;
		cin >> a >> b >> c;
		add(a, b, c), add(b, a, c);
	}

	dijkstra();

	while (q -- )
	{
		int x;
		cin >> x;
		cout << dist[x] << '\n';
	}

	return 0;
}
```

---

## 作者：lzy120406 (赞：3)

## [类双倍经验](https://www.luogu.com.cn/problem/P1629)
最短路模板题。

## 思路
一看这道题，一种暴力做法是直接 $q$ 次 `dijkstra`，然而这样子的复杂度是$ \mathcal{O}(q(n+m) \log m) $，显然超时。

观察发现，每次询问都需要从 $h_i$ 到 $s$，跑一遍 `dijkstra`，那么可不可以从 $s$ 直接跑一遍最短路，然后求出所有的 $dis_{h_i}$ 呢？

显然是可以的，这时就要用到一个图论中很重要的思想**建反图**，就是把原题中从 $u \to v$ 的边在代码中变成从 $v \to u$，这种方法可以有效解决这种问题。

因为本题是无向图，所以直接正常建边就可以，无需对最短路代码模板做任何改动。

具体细节看代码。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std ;
ll n , m , i , u , v , w , s , q , dis[200005] ;
bool vis[200005] ;
struct edge{
	ll v , w ;
	bool operator<(const edge &t) const{
		return t.w<w ;
	}
} ;
vector<edge> a[200005] ;
void dijkstra(ll s){
	memset(dis,0x3f,sizeof(dis)) ;
	memset(vis,false,sizeof(vis)) ;
	priority_queue<edge> q ;
	dis[s] = 0 ;
	q.push({s,0}) ;
	while(q.size()){
		ll u = q.top().v ;
		q.pop() ;
		if(vis[u]){
			continue ;
		}
		vis[u] = true ;
		for(auto &&k : a[u]){
			ll v = k.v , w = k.w ;
			if(dis[v]>dis[u]+w){
				dis[v] = dis[u]+w ;
				q.push({v,dis[v]}) ;
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(false) ;
	cin.tie(0) ;
	cout.tie(0) ;
	cin >> n >> m >> s >> q ;
	for(i=1;i<=m;i++){
		cin >> u >> v >> w ;
		a[u].push_back({v,w}) ;
		a[v].push_back({u,w}) ;
	}
	dijkstra(s) ;
	while(q--){
		cin >> v ;
		cout << dis[v] << '\n' ;
	}
	return 0 ;
}
```
时间复杂度 $ \mathcal{O}((n+m) \log m + q) $，可以通过本题。

---

## 作者：anruochen12345 (赞：3)

## **思路：**

---

这道题相当于是给你一个源点，从这个源点向外扩散，求每个结点与源点之间带权路径的最小值。

我看到题的第一眼想要用 **bfs** 写，也就是从学校往外搜索，将路径长度数组每次加上路径的权值，即如下代码。
```
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
int n,m,s,p;
int u,v,l,h;
int ver[N],Next[N],head[N],w[N],tot=-1;
int q[2*N],front,rear;
long long level[N];
bool vis[N];
void add(int x,int y,int z){
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
	w[tot]=z;
}
void bfs(int x){
	vis[x]=1;
	q[rear++]=x;
	while(front!=rear){
		x=q[front];
		for(int i=head[x];i!=-1;i=Next[i]){
			if(!vis[ver[i]]){
				vis[ver[i]]=1;
				q[rear++]=ver[i];
				level[ver[i]]=level[x]+w[i];
			}
		}
		front++;
	}
}
int main(){
	memset(head,-1,sizeof head);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>s>>p;
	for(int i=1;i<=m;i++){
		cin>>u>>v>>l;
		add(u,v,l);
		add(v,u,l);
	}
	bfs(s);
	for(int i=1;i<=p;i++){
		cin>>h;
		cout<<level[h]<<'\n';
	}
	return 0;
}
```

然后你将会发现......~~**你爆0啦！**~~

为什么会爆0呢，让我们看看题目。

题目说每条路径长度为 l,但再让我们看看上边的代码：

```
for(int i=head[x];i!=-1;i=Next[i]){
    if(!vis[ver[i]]){
        vis[ver[i]]=1;
        q[rear++]=ver[i];
        level[ver[i]]=level[x]+w[i];
    }
}

```
问题就出在路径长度是 l，因为这段代码是将路径长度存完之后就不管了，并没有判断这条路径是否是最短的，但我们仔细一想, bfs 好像没有很好的方法进行改进。

**那有没有一个算法能做出这道题呢。**

ok，那让我们掏出 dijkstra ，因为 **dijkstra** **就是一种用于求解单源最短路径问题的算法。**

我们清楚该用什么算法之后，我们就可以开始写AC代码啦！

## **AC代码**
```
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
int n,m,s,p;
int u,v,l,h;
int ver[N],Next[N],head[N],w[N],tot=-1;
long long level[N];
bool vis[N];
void add(int x, int y, int z) {
    ver[++tot]=y;
    Next[tot]=head[x];
    head[x]=tot;
    w[tot]=z;
}
void dijkstra(int x) {
    fill(level,level+N,LONG_LONG_MAX);
    level[x]=0;
    priority_queue<pair<long long,int>,vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
    pq.push({0,x});
    while(!pq.empty()){
        int u=pq.top().second;
        long long d=pq.top().first;
        pq.pop();
        if(d>level[u]) continue;
        for(int i=head[u];i!=-1;i=Next[i]){
            int v=ver[i];
            long long Dist=level[u]+w[i];
            if(Dist<level[ver[i]]) {
                level[v]=Dist;
                pq.push({Dist, ver[i]});
            }
        }
    }
}
int main(){
    memset(head,-1,sizeof head);
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m>>s>>p;
    for (int i=1;i<=m;i++){
        cin>>u>>v>>l;
        add(u,v,l);
        add(v,u,l);
    }
    dijkstra(s);
    for(int i=1;i<=p;i++){
        cin>>h;
        cout<<level[h]<<'\n';
    }
    return 0;
}
```
## **时间复杂度：**

构建邻接表的时间复杂度为 **(O(m))**

Dijkstra 算法使用优先队列优化，时间复杂度 **(O((m+n)log n))**

读取每位同学家的结点编号并输出结果的时间复杂度 **(O(q))**

总体时间复杂度为 **(O((m+n)log n + q))**

---

## 作者：WA2025 (赞：2)

## 题意

给定一张无向图，包含 $n$ 个结点和 $m$ 条边，每条边连接两个结点，长度已知。学校位于结点 $s$，有 $q$ 个同学，他们分别位于 $h_i$ 号结点，每秒钟行走 $1$ 米。求每位同学从家到学校的最短时间。

## 思路

注意到这道题所有的询问，终点是同一点 $s$，并且给的是一张无向图，所以可以想到从 $s$ 点跑一遍 Dijkstra 求出从 $s$ 点开始到其他点的最短路。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int inf = 0x3f3f3f3f3f3f3f3f;
const int N = 2e5 + 10;
int n, m, s, q;
struct edge {
    int v, w;

    edge(int _v, int _w) : v(_v), w(_w) {}
};
vector<edge> G[N];
int dis[N];

void dijkstra() {
    queue<int> q;
    q.emplace(s);
    fill(dis, dis + N, inf);
    dis[s] = 0;

    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (const auto& e : G[u])
            if (dis[u] + e.w < dis[e.v]) {
                dis[e.v] = dis[u] + e.w;
                q.emplace(e.v);
            }
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();

    cin >> n >> m >> s >> q;
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;

        G[u].emplace_back(v, w);
        G[v].emplace_back(u, w);
    }

    dijkstra(); 

    while (q--) {
        int x;
        cin >> x;

        cout << dis[x] << '\n';
    }

    return 0;
}
```

---

## 作者：Jasonshan10 (赞：2)

最短路板子题。

给定一张 $n$ 个点 $m$ 条边的无向图，其中编号为 $u_i$ 和 $v_i$ 的节点被一条长度为 $l_i$ 的边连结。$q$ 次询问，对于每次询问求出编号为 $h_i$ 的节点到学校 $s$ 的最短路长度。

如果我们对于每一个询问跑一遍最短路，时间复杂度为 $O(mq\log m)$，无法通过此题。

只需要以学校为起点跑一遍 Dijkstra 求出学校到每个点的最短路存下来，我们就可以在 $O(1)$ 的时间内解决每个询问。

时间复杂度 $O(m\log m)$，可以通过本题。

代码与 P4779 极为相似，故不放代码。

---

## 作者：wyyinput (赞：1)

## 题意
求每个同学家到 $s$ 的最短路。
## 性质
因为图是无向图，所以 $u$ 到 $v$ 的最短路和 $v$ 到 $u$ 的最短路相等。所以题目要求的就是 $s$ 到每个同学家的最短路。
## 做法
由此想到迪杰斯特拉。起点是 $s$ 点。注意开双倍边。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+1;
int n,m,s,q,u,v,w,a,cnt,h[N],d[N];
bool vis[N];
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;
struct edge{
    int to,ne,w;
}b[2*N];
void add(int u,int v,int w){
    b[++cnt]={v,h[u],w};
    h[u]=cnt;
    return;
}
void dij(){
    for(int i=1;i<=n;i++)
        d[i]=0x3fffffffffffffff;
    d[s]=0;
    pq.push({0,s});
	while(!pq.empty()){
		int t=pq.top().second;
		pq.pop();
		if(!vis[t]){
			vis[t]=true;
			for(int i=h[t];i;i=b[i].ne){
				if(!vis[b[i].to]){
					d[b[i].to]=min(d[b[i].to],d[t]+b[i].w);
					pq.push({d[b[i].to],b[i].to});
				}
			}
		}
	}
    return;
}
signed main(){
    scanf("%lld%lld%lld%lld",&n,&m,&s,&q);
    for(int i=1;i<=m;i++){
        scanf("%lld%lld%lld",&u,&v,&w);
        add(u,v,w);
        add(v,u,w);
    }
    dij();
    for(int i=1;i<=q;i++){
        scanf("%lld",&a);
        printf("%lld\n",d[a]);
    }
    return 0;
}
```

---

## 作者：Chase12345 (赞：1)

最短路板子。

注意到需要计算每个 $h_i \to s$ 的最短路径。终点恒不变，起点不同。那么可以起终点转换。就变成最短路模板了。

由于是无向图，所以不用存反图。直接将终点设置为起点，起点设置为终点即可。并且由于没有负权边，直接 Dijkstra 就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
using pli = pair<i64, int>;
const int N = 100010, M = 1e3 + 5;
const i64 INFLL = 0x3f3f3f3f3f3f3f3f;

struct Edge {
	int to, w;
};
vector<Edge> adj[N];
i64 d[N];
int a[N];
int n, m;

void Dijkstra(int s) {
	memset(d, 0x3f, sizeof(d));
	d[s] = 0;
	priority_queue<pli, vector<pli>, greater<pli> > pq;
	pq.push({0, s});
	while (!pq.empty()) {
		pli p = pq.top();
		pq.pop();
		int u = p.second;
		if (d[u] < p.first)
			continue;
		for (int i = 0; i < adj[u].size(); i++) {
			int v = adj[u][i].to, w = adj[u][i].w;
			if (d[u] + w < d[v]) {
				d[v] = d[u] + w;
				pq.push({d[v], v});
			}
		}
	}
}

int main() {
    int s, q;
	cin >> n >> m >> s >> q;
	for (int i = 1, u, v, w; i <= m; i++) {
		cin >> u >> v >> w;
		adj[v].push_back({u, w});
		adj[u].push_back({v, w});
	}
	Dijkstra(s);
	for (int i = 1, x; i <= q; i++) {
		cin >> x;
		cout << d[x] << endl;
	}
	return 0;
}
```

---

## 作者：LG086 (赞：1)

同学们上学，想知道各自到学校的最短路是多少。

现在给你一个 $n$ 个点，$m$ 条边的无向图，要从 $q$ 个点 $x_1,x_2,\dots,x_q$ 分别走到终点 $s$，即学校的位置。每次要你答出从 $x_i$ 到 $s$ 之间的最短路长度。

显然，若每次从 $x_i$ 出发求一次最短路，无法通过本题。注意到 $s$ 是不变的。我们可以转换为以 $s$ 为起点分别走到 $x_1,x_2,\dots,x_q$，也就是让学校派人把同学们抓进去。这样写个 SPFA 求一轮最短路，记录下从 $s$ 到每个点的最短路，每次查询时直接输出答案即可。

做完了。

---

## 作者：foglake (赞：1)

显然对每个起点求最短路要超时，但注意到它们的终点一定为学校。那我们不妨“反过来”，以学校为起点，由于是无向边，所以这样的路程是一样的。

然后敲个堆优化就行，注意 long long。


```
#include <cstdio>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;
const int maxn = 2e5 + 10;
struct Point {
	int p;
	long long val;
	bool operator <(const Point &a) const{
		return val > a.val;
	}//堆默认大根堆，所以定义小于为大于方便操作 
};
priority_queue <Point> q;
vector <pair<int, long long> > e[maxn];//first 存终点，second 存权值 
long long dis[maxn];
void dijkstra(int s) {
	dis[s] = 0;
	q.push({s, 0}); 
	while (!q.empty()) {
		Point a = q.top();
		q.pop();
		for (int i = 0; i < e[a.p].size(); i++)
			if (dis[a.p] + e[a.p][i].second < dis[e[a.p][i].first]) {
				dis[e[a.p][i].first] = dis[a.p] + e[a.p][i].second;
				q.push({e[a.p][i].first, dis[e[a.p][i].first]});
			}
	}
}
int main() {
	int n, m, s, que;
	scanf("%d%d%d%d", &n, &m, &s, &que);
	for (int i = 1; i <= n; i++) dis[i] = 1e18;//初始化 
	for (int i = 1; i <= m; i++) {
		int u, v;
		long long val;
		scanf("%d%d%lld", &u, &v, &val);
		e[u].push_back({v, val});
		e[v].push_back({u, val}); 
	}
	dijkstra(s);
	for (int i = 1; i <= que; i++) {
		int p;
		scanf("%d", &p);
		printf("%lld\n", dis[p]);
	}
}
```

---

## 作者：dg114514 (赞：1)

很容易发现，在**无向图**中，$s\rightarrow t$ 的最短路等价于 $t\rightarrow s$ 的最短路，因为可以把 $s\rightarrow t$ 的最短路路径反过来即可得到 $t\rightarrow s$ 的最短路路径。所以可以对 $s$ 点做单源最短路，然后回答 $q$ 个查询即可。对于查询 $h_i$ 的情况时，输出 $dis_{h_i}$ 就可以了。

---

## 作者：andycode (赞：0)

## 思路
容易发现这是一道单源最短路裸题，直接用复杂度为 $\mathcal{O}((m+n)\log n)$ 的堆优化 Dijkstra 就行了。

注意要开 long long。
## 代码
```cpp
//堆优化 Dijkstra
#include <bits/stdc++.h>
using namespace std;

const int N=2e5+5;

struct Edge{
    int to;
    long long val;
};

bool operator<(Edge x,Edge y){
    return x.val>y.val;
}

int n,m,s,t;
long long dist[N];
vector<Edge> g[N];
priority_queue<Edge> q;
bool use[N];

int main(){
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }
    memset(dist,63,sizeof(dist));
    dist[s]=0;
    q.push({s,0});
    for(int tot=1;tot<=n;tot++){
        while(use[q.top().to])
            q.pop();
        int x=q.top().to,len=g[x].size();
        q.pop(),use[x]=1;
        for(int i=0;i<len;i++)
            if(dist[g[x][i].to]>dist[x]+g[x][i].val)
                dist[g[x][i].to]=dist[x]+g[x][i].val,q.push({g[x][i].to,dist[g[x][i].to]});
    }
    while(t--){
        int u;
        scanf("%d",&u);
        printf("%lld\n",dist[u]);
    }
    return 0;
}
```

---

## 作者：linjinkun (赞：0)

由于如果每个同学都跑一遍最短路看到学校的最短时间是多少就太慢了，发现由于是无向边，从起点到终点和从终点到起点的最短时间一定一样，所以可以从学校跑一遍最短路，然后每次询问就输出 $dis_x$ 就行了。

拓展：其实如果是有向边也可以做，只需要建图的时候将边反着建就行了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
struct node
{
	int x;
	int w;
	bool operator<(const node&a)const
	{
		return w>a.w;
	}
};
vector<node>a[N];
priority_queue<node>q;
long long d[N];
int vis[N];
int main()
{
	int n,m,s,_;
	scanf("%d %d %d %d",&n,&m,&s,&_);
	for(int i = 1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d %d %d",&x,&y,&z);
		a[x].push_back({y,z});
		a[y].push_back({x,z});
	}
	memset(d,0x3f,sizeof(d));
	q.push({s,0});
	d[s] = 0;
	while(q.size())
	{
		int x = q.top().x;
		q.pop();
		if(vis[x])
		{
			continue;
		}
		vis[x] = 1;
		for(int i = 0;i<a[x].size();i++)
		{
			int v = a[x][i].x;
			int w = a[x][i].w;
			if(d[x]+w<d[v])
			{
				d[v] = d[x]+w;
				q.push({v,d[v]});
			}
		}
	}
	while(_--)
	{
		int x;
		scanf("%d",&x);
		printf("%lld\n",d[x]);
	}
	return 0;
}
```

---


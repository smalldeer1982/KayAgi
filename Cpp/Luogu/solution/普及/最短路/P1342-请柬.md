# 请柬

## 题目背景

在电视时代，没有多少人观看戏剧表演。 Malidinesia 古董喜剧演员意识到这一事实，他们想宣传剧院,尤其是古色古香的喜剧片。

## 题目描述

他们已经打印了请帖和所有必要的信息和计划。许多学生被雇来分发这些请柬。每个学生志愿者被指定一个确切的公共汽车站，他或她将留在那里一整天,邀请人们参与。

这里的公交系统是非常特殊的：共有 $n$ 个站点和 $m$ 个线路，所有的线路都是单向的，连接两个站点。公共汽车离开起始点，到达目的地之后又空车返回起始点。

学生每天早上从总部所在的 $1$ 号站点出发，乘公交车到一个预定的站点邀请乘客。每个站点都被安排了一名学生。在一天结束的时候，所有的学生都回到总部。现在需要知道的是，学生所需的公交费用的总和最小是多少。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq n, m \leq 10^6$。
- $1 \leq u, v \leq n$，$1 \leq w \leq 10^9$。
- 从 $1$ 出发可以到达所有的站点。

## 样例 #1

### 输入

```
4 6
1 2 10
2 1 60
1 3 20
3 4 10
2 4 5
4 1 50```

### 输出

```
210 ```

# 题解

## 作者：笃行 (赞：30)

看到还没有用stl优先队列优化的spfa，那就来一发吧。

模板题，唯一的不同就是在建图时同时建正向图\*1+反向图\*1，然后各跑一遍spfa，各把1到其他点的花费都加起来就好了（long long）。

Code：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int MAXN=1000000+5;
const int inf=2147483647;
int m,n,sx=1,num1,num2;
struct line 
{
    int from,to,dis;
}d[MAXN],f[MAXN];
int head1[MAXN],head2[MAXN];
bool inq[MAXN];
int dis[MAXN];
long long ans;
int r() 
{ 
    int f=1,p=0;
    char c=getchar(); 
    while(c>'9'||c<'0')
      {
        if(c=='-') f=-1;
        c=getchar();
      } 
    while(c>='0'&&c<='9')
      {
         p=p*10+c-'0';
         c=getchar();
      } 
    return f*p; 
}
void add(int x,int y,int v)
{
    d[++num1].to=y;
    d[num1].from=head1[x];
    head1[x]=num1;
    d[num1].dis=v;
    f[++num2].to=x;
    f[num2].from=head2[y];
    head2[y]=num2;
    f[num2].dis=v;
}
void spfa1()
{
    deque <int> q;
    q.push_front(sx);
    fill(dis+2,dis+n+1,inf);
    while(!q.empty())
      {
          int x=q.front();
          q.pop_front();
          inq[x]=0;
          for(int k=head1[x];k;k=d[k].from)
            {
                int v=d[k].to,w=d[k].dis;
                if(w+dis[x]<dis[v])
                  {
                        dis[v]=w+dis[x];
                        if(!inq[v])
                          {
                                if(q.empty()||dis[v]<dis[q.front()]) q.push_front(v);
                                else q.push_back(v);
                                inq[v]=1;
                    }
              }
          }
      }
    for(int i=2;i<=n;i++)
      ans+=dis[i];
}
void spfa2()
{
    deque <int> t;
    t.push_front(sx);
    fill(dis+2,dis+n+1,inf);
    while(!t.empty())
      {
          int x=t.front();
          t.pop_front();
          inq[x]=0;
          for(int k=head2[x];k;k=f[k].from)
            {
                int v=f[k].to,w=f[k].dis;
                if(w+dis[x]<dis[v])
                  {
                        dis[v]=w+dis[x];
                        if(!inq[v])
                          {
                                if(t.empty()||dis[v]<dis[t.front()]) t.push_front(v);
                                else t.push_back(v);
                                inq[v]=1;
                    }
              }
          }
      }
    for(int i=2;i<=n;i++)
      ans+=dis[i];
}
int main()
{
    n=r();m=r();
    for(int i=1;i<=m;i++)
      {
          int x,y,z;
          x=r(); y=r(); z=r();
          add(x,y,z);
      }
    spfa1();
    spfa2();
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：shadowice1984 (赞：22)

dijkstra裸题啊。。。

其实楼下那些优化就一个堆优化即可的

算法复杂度（m+logm）

这里讲一个堆优化的注意（stl显然的对不对）

记得在遍历出边时打标记即可

还有记得加 long long

这样的话好像没啥好讲的了

上代码吧~

```cpp
#include<stdio.h>
#include<queue>
using namespace std;
struct data//第一个邻接表存正向图
{
    int v;int next;int val;
}edge[1000010];int cnt;
int alist[1000010];
void add(int u,int v,int val)
{
    edge[++cnt].v=v;
    edge[cnt].val=val;
    edge[cnt].next=alist[u];
    alist[u]=cnt;
    return;
}
struct data2//第二个邻接表存反向图（回城的路径）
{
    int v;int next;int val;
}edge2[1000010];int cnt2;
int alist2[1000010];
void kid(int v,int u,int val)
{
    edge2[++cnt2].v=v;
    edge2[cnt2].val=val;
    edge2[cnt2].next=alist2[u];
    alist2[u]=cnt2;
    return;
}
struct node//一开始脑残想到了最小生成树，不要理我。。。直接int即可
{
    int d;int n;
    friend bool operator <(node a,node b)
    {
        return a.d>b.d;
    }
}d[1000010],now;
priority_queue <node> pq;//这里是int就好，不要学我
bool book[1000010];
int n;int m;
long long res;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++)
    {
        int u;int v;int val;
        scanf("%d%d%d",&u,&v,&val);
        add(u,v,val);//正向建图
        kid(u,v,val);//反向建图
    }
    for(int i=1;i<=n;i++)//初始化
    {
        d[i].d=0x3f3f3f3f;
        d[i].n=i;
    }
    d[1].d=0;pq.push(d[1]);
    while(!pq.empty())//dijkstra膜板
    {
        now=pq.top();pq.pop();
        //printf("now %d\n",now.n);
        book[now.n]=true;
        int next=alist[now.n];
        while(next)
        {
            int v=edge[next].v;
            int val=edge[next].val;
            if(book[v]==false)
            {
                if(d[v].d>now.d+val)
                {
                    d[v].d=now.d+val;
                    pq.push(d[v]);
                    //printf("->d[%d]=%d\n",v,d[v].d);
                }
            }
            next=edge[next].next;
        }
    }
    for(int i=1;i<=n;i++)//处理出城车费
    {
        res+=d[i].d;
    }
    for(int i=1;i<=n;i++)//省个数组是个数组
    {
        d[i].d=0x3f3f3f3f;
        d[i].n=i;
    }
    d[1].d=0;pq.push(d[1]);
    while(!pq.empty())//再来一遍dijkstra膜板
    {
        now=pq.top();pq.pop();
        //printf("now %d\n",now.n);
        book[now.n]=false;
        int next=alist2[now.n];
        while(next)
        {
            int v=edge2[next].v;
            int val=edge2[next].val;
            if(book[v]==true)//数组能省就省
            {
                if(d[v].d>now.d+val)
                {
                    d[v].d=now.d+val;
                    pq.push(d[v]);
                    //printf("->d[%d]=%d\n",v,d[v].d);
                }
            }
            next=edge2[next].next;
        }
    }
    for(int i=1;i<=n;i++)//处理回城费用
    {
        res+=d[i].d;
    }
    printf("%lld",res);
    return 0;
}

```

---

## 作者：PrincessYR✨～ (赞：19)

~~一道关于Dij+堆优化的最短路的问题。（废话）~~

看见其他大佬都用的前式链向星和priority_queue自定义比较器，没有用vector的，所以我来发一篇vector和STL的题解。

首先来了解一下Dij，Dij是求求最短路时比较快的一种方法，思路简单，但也有一个缺点，那就是无法判权值为负的情况。

[Dij加堆优化讲解](https://www.luogu.com.cn/paste/u2ed81ja)

这道题就是让我们先求一遍1到所有点的最短距离，再求一遍从各个点到1的最短距离，再将值都加起来，就是最终答案。

看似简单，相信在求每个点到1的最短路时，第一个想到的，肯定是一个for，循环每一个点，求一遍Dij，在把所有的d[1]加起来。

恭喜您，丰收了4个[TLE](https://www.luogu.com.cn/record/31586138)

那我们来思考一下正解，我们可以把图正着存一遍，然后再反着存一遍，分别求Dij(1)。

正着的图求出来的遗爱到每个点的距离，及所有人出发到每个点的费用；

反着存图，求出来的也是1到每个点的最短路，但这张图是反着的，举个例子：反着的图中1到6的值在正着的图中就是6到1的最短路。所以，反着的图到每个点的距离就是正着的图中每个点到1的距离。

这样我们就可以大大缩短时间，从而求得正解。

```
#include<bits/stdc++.h>
using namespace std;
#define si 1000009
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
struct edge
{
	int to,cost;
};
int INF=2147483647;
typedef pair<long long,long long> P;
vector<edge> g[si];
vector<edge> g2[si];
int d[si];
priority_queue<P, vector<P>, greater<P> > q;
int n,m,a,b,c;
long long ans;
void dij(int x)
{
	fill(d,d+1+n,INF);
	d[x]=0;
	q.push(P(0,x));
	while(!q.empty())
	{
		P p=q.top();q.pop();
		int v=p.second;
		if(d[v]<p.first) continue;
		for(int i=0;i<g[v].size();i++)
		{
			edge e=g[v][i];
			if(d[e.to]>d[v]+e.cost)
			{
				d[e.to]=d[v]+e.cost;
				q.push(P(d[e.to],e.to));
			}
		}
	}
}
void dij2(int x)
{
	fill(d,d+1+n,INF);
	d[x]=0;
	q.push(P(0,x));
	while(!q.empty())
	{
		P p=q.top();q.pop();
		int v=p.second;
		if(d[v]<p.first) continue;
		for(int i=0;i<g2[v].size();i++)
		{
			edge e=g2[v][i];
			if(d[e.to]>d[v]+e.cost)
			{
				d[e.to]=d[v]+e.cost;
				q.push(P(d[e.to],e.to));
			}
		}
	}
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		a=read();b=read();c=read();
		g[a].push_back(edge{b,c});
		g2[b].push_back(edge{a,c});
	}
	dij(1);
	for(int i=2;i<=n;i++)
	ans+=d[i];
	dij2(1);
	for(int i=2;i<=n;i++)
	ans+=d[i];
	cout<<ans;
	return 0;
}
```


---

## 作者：szr666 (赞：12)

我这里推荐一下[我的博客](https://www.luogu.org/blog/szr666--blog/)

在博客里观看更美观哦~

[题目](https://www.luogu.org/problemnew/show/P1342)
------------


------------

华丽的分割线
# 解析
问题的实质为
##### 求1到各个点的最短路和各个点到1的最短路
用dijkstra+堆优化求最短路再跑反图最短路

注意dijkstra函数参数传数组头指针(int*)

链式前向星add函数一次操作存正反两条边

不会dijkstra+堆优化？[戳这里](https://www.luogu.org/blog/szr666--blog/ti-gao-xing-xuan-zhuan-ti-shu-zhuang-shuo-zu-li-san-hua-p4779-mu)

## 答案要开long long ~~血的教训~~
# 代码
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#define ll long long
using namespace std;
struct node
{
    int to;
    int val;
    int next;
};
struct data
{
    int val;
    int dis;
    data(int v,int d)
    {
        val=v;
        dis=d;
    }
    data()
    {
        
    }
    friend bool operator < (data x1,data x2);
};
bool operator < (data x1,data x2)
{
    return x1.dis==x2.dis ? x1.val<x2.val : x1.dis>x2.dis;
}
priority_queue<data> q;
node e1[1100001],e2[1100001];
int head1[1100001],head2[1100001],dis[1100001];
bool book[1100001];
int n,m,s,tot;
void read(int &x)
{
    int f;
    f=1;
    x=0;
    char c;
    c=getchar();
    while((c<'0'||c>'9')&&c!='-')
    {
        c=getchar();
    }
    if(c=='-')
    {
        f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    x=x*f;
}
void add(int a,int b,int v)
{
    tot++;
    e1[tot].val=v;
    e1[tot].to=b;
    e1[tot].next=head1[a];
    head1[a]=tot;
    e2[tot].val=v;
    e2[tot].to=a;
    e2[tot].next=head2[b];
    head2[b]=tot;
}
void dijkstra(node *e,int *h)
{
    int j;
    data now;
    memset(book,0,sizeof(bool)*(n+100));
    memset(dis,0x3f3f3f3f,sizeof(int)*(n+100));
    dis[s]=0;
    q.push(data(s,dis[s]));
    while(!q.empty())
    {
        now=q.top();
        q.pop();
        if(book[now.val]==0)
        {
            book[now.val]=1;
            for(j=h[now.val];j!=0;j=e[j].next)
            {
                if(dis[e[j].to]>dis[now.val]+e[j].val)
                {
                    dis[e[j].to]=dis[now.val]+e[j].val;
                    q.push(data(e[j].to,dis[e[j].to]));
                }
            }
        }
    }
}
int main()
{
    int i,u,t,v;
    ll ans;
    read(n);
    read(m);
    s=1;
    tot=0;
    ans=0;
    for(i=1;i<=m;i++)
    {
        read(u);
        read(t);
        read(v);
        add(u,t,v);
    }
    dijkstra(e1,head1);
    for(i=2;i<=n;i++)
    {
        ans+=dis[i];
    }
    dijkstra(e2,head2);
    for(i=2;i<=n;i++)
    {
        ans+=dis[i];
    }
    printf("%lld",ans);
}
```


---

## 作者：爷，无限霸气 (赞：8)

看到没有~~无结构体~~的堆优化dij，介绍下我的思路

# 一道最短路裸题

![](https://cdn.luogu.com.cn/upload/image_hosting/cef3poyt.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如图 输出：210

不难想到：此题意思就是让你以1为起点跑最短路，答案把1到所有点最短路径加起来

再以其他点为起点跑最短路，把这些点到1的长度加起来

于是开开心心的提交，~~完美TLE~~

代码（~~暴力~~）：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn 2000065
#define next Next
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
priority_queue< pair<ll,ll> >q;
ll ans,n,m,tot,ver[Maxn],head[Maxn],next[Maxn],edge[Maxn],d[Maxn],v[Maxn];
void add(ll x,ll y,ll z)
{
	ver[++tot]=y;
	next[tot]=head[x];
	head[x]=tot;
	edge[tot]=z;
}
void dijkstra(ll s)
{
	memset(d,0x7f,sizeof(d));
	memset(v,0,sizeof(v));
	d[s]=0;
	q.push(make_pair(0,s));
	while(q.size())
	{
		ll x=q.top().second;q.pop();
		if(v[x]) continue;
		v[x]=1;
		for(int i=head[x];i;i=next[i])
		{
			ll y=ver[i],z=edge[i];
			if(d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				q.push(make_pair(-d[y],y));
			}
		}
	}
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		ll x=read(),y=read(),z=read();
		add(x,y,z);
	}
	dijkstra(1);
	for(int i=1;i<=n;i++) ans+=d[i];
	for(int i=2;i<=n;i++)
	{
		dijkstra(i);
		ans+=d[1];
	}
	cout<<ans<<endl;
	return 0;
}
```

很显然，上面的代码达到了（n^2logn）的~~大~~时间复杂度

那我们考虑一种优化的思路

我们~~奇妙的~~发现，各个点到1的最短距离就是建反图后1到各个点的最短距离

这样，只要建反图，优化成了（2nlogn）。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn 2000005
#define next Next
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
priority_queue< pair<ll,ll> >q,q1;
ll ans,n,m,tot,tot1,ver[Maxn],head[Maxn],next[Maxn],edge[Maxn],d[Maxn],v[Maxn];
ll ver1[Maxn],head1[Maxn],next1[Maxn],edge1[Maxn],d1[Maxn],v1[Maxn];
void add(ll x,ll y,ll z)
{
	ver[++tot]=y;
	next[tot]=head[x];
	head[x]=tot;
	edge[tot]=z;
}
void add1(ll x,ll y,ll z)
{
	ver1[++tot1]=y;
	next1[tot1]=head1[x];
	head1[x]=tot1;
	edge1[tot1]=z;
}
void dijkstra(ll s)
{
	memset(d,0x7f,sizeof(d));
	memset(v,0,sizeof(v));
	d[s]=0;
	q.push(make_pair(0,s));
	while(q.size())
	{
		ll x=q.top().second;q.pop();
		if(v[x]) continue;
		v[x]=1;
		for(int i=head[x];i;i=next[i])
		{
			ll y=ver[i],z=edge[i];
			if(d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				q.push(make_pair(-d[y],y));
			}
		}
	}
}
void dijkstra1(ll s)
{
	memset(d1,0x7f,sizeof(d1));
	memset(v1,0,sizeof(v1));
	d1[s]=0;
	q1.push(make_pair(0,s));
	while(q1.size())
	{
		ll x=q1.top().second;q1.pop();
		if(v1[x]) continue;
		v1[x]=1;
		for(int i=head1[x];i;i=next1[i])
		{
//			cout<<i<<endl;
			ll y=ver1[i],z=edge1[i];
//			if(z==10) cout<<"找了我好久！"<<y<<endl;
//			if(y==3) cout<<"往来款";
			if(d1[y]>d1[x]+z)
			{
				d1[y]=d1[x]+z;
				q1.push(make_pair(-d1[y],y));
			}
		}
	}
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		ll x=read(),y=read(),z=read();
		add(x,y,z);
		add1(y,x,z);
	}
	dijkstra(1);
	dijkstra1(1);
	for(int i=2;i<=n;i++)
	{
		ans+=d[i]+d1[i];
//		cout<<d[i]<<" "<<d1[i]<<endl;
	}
	cout<<ans<<endl;
	return 0;
}
```

最后，附注几点易错（~~我就错了~~）：

1.数组别开大：我开2000065就MLE了

2.反图别建错：我反图的head1打成head1了

# 完结撒花！！！

---

## 作者：ysner (赞：7)

核心思想:两遍最短路.

邮局去各地的时间直接套最短路模板,各地到邮局时间用逆向思维,视为求邮局沿反边到各地的时间即可.

另外,这道题可以从各种方面提高效率:

1、用Dijkstra+堆优化算法，这种算法虽可能比SPFA慢一点点，但复杂度稳定可算；而SPFA复杂度不稳定，有很多题目都有专卡SPFA的数据；

2、用结构体代替数组，写着方便；

3、手写邻接表+加边；

4、在局部函数前加inline；

5、在局部变量前加register；

6、使用读入优化。

有这些效率加成的程序，优于楼下程序。我本为过P1629而编此程序，在P1629提交后，直接放大数据范围在此也可AC。


```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#define ll long long
#define re register
#define il inline
#define inf 214748364
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
int n,m,h[1000005],cnt=0,inq[1000005]={},dis[1000005]={},h1[1000005]={};
ll ans=0;
struct Edge
{
    int to,next,w;
}e[1000005],e1[1000005];
struct Node
{
    int l,d;
    Node(){}
    Node(int l,int d):l(l),d(d){}
    bool operator < (const Node& zsy) const
        {
            return l>zsy.l;
        }
};
il void add(re int u,re int v,re int w)
{
    e[++cnt]=(Edge){v,h[u],w};h[u]=cnt;
}
il void add1(re int u,re int v,re int w)
{
    e1[cnt]=(Edge){v,h1[u],w};h1[u]=cnt;
}
il int gi()
{
    re int x=0;
    re int t=1;
    re char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x*t;
}
il void Dijkstra()
{
    fp(i,1,n) dis[i]=inf;
    dis[1]=0;
    priority_queue<Node>Q;
    Q.push(Node(0,1));
    while(!Q.empty())
    {
        Node u=Q.top();Q.pop();
        if(inq[u.d]) continue;
        inq[u.d]=1;
        for(re int i=h[u.d];i+1;i=e[i].next)
        {
            re int v=e[i].to,w=e[i].w;
            if(u.l+w<dis[v])
            {
                dis[v]=u.l+w;
                Q.push(Node(dis[v],v));
            }
        }
    }
}
il void Dijkstra1()
{
    fp(i,1,n) dis[i]=inf;
    dis[1]=0;
    memset(inq,0,sizeof(inq));
    priority_queue<Node>Q;
    Q.push(Node(0,1));
    while(!Q.empty())
    {
        Node u=Q.top();Q.pop();
        if(inq[u.d]) continue;
        inq[u.d]=1;
        for(re int i=h1[u.d];i+1;i=e1[i].next)
        {
            re int v=e1[i].to,w=e1[i].w;
            if(u.l+w<dis[v])
            {
                dis[v]=u.l+w;
                Q.push(Node(dis[v],v));
            }
        }
    }
}
int main()
{
    memset(h,-1,sizeof(h));memset(h1,-1,sizeof(h1));
    n=gi();m=gi();
    fp(i,1,m)
    {
        int u=gi(),v=gi(),w=gi();
        add(u,v,w);
        add1(v,u,w);
    }
    Dijkstra();
    fp(i,2,n) ans+=dis[i];
    Dijkstra1();
    fp(i,2,n) ans+=dis[i];
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：寒冰大大 (赞：5)

这道题很适合作为P1629的加强版

因为这道题其实体现了反向建图的高效性

反向建图后：

单终点最短路径→单源最短路径。

因此两边Dij，然后再累计和即可

代码部分不难弄。直接上

先说明以下程序，有1的变量名与第一次dij有关（学生出来）

带2的与第二次dij有关（学生回家）
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<queue>
#include<cstring>

using namespace std;

int n,m;
int h1[2100000],h2[2100000];
int s1,s2;
struct edge{
	int next,to,dis;
};
int v1[2100000],v2[2100000];  //注意数据范围
long long d1[2100000],d2[2100000];
edge e1[2100000],e2[2100000];

void addedge1(int next,int to,long long dis)
{
	e1[++s1].dis=dis;
	e1[s1].next=h1[next];
	e1[s1].to=to;
	h1[next]=s1;
}

void addedge2(int next,int to,long long dis)
{
	e2[++s2].dis=dis;
	e2[s2].to=to;
	e2[s2].next=h2[next];
	h2[next]=s2;
}

void dij1(int start)
{
	priority_queue <pair<long long,int> > q;  
    //这是优先队列的一个比较容易理解的写法，之所以long long 是因为可总和可能爆int
	memset(d1,0x3f,sizeof(d1));
	memset(v1,0,sizeof(v1));
	q.push(make_pair(0,start));
	d1[1]=0;
	while(!q.empty())
	{
		int i,j;
		long long k;
		int t=q.top().second;
		q.pop();
		if(v1[t]) continue;
		v1[t]=1;
		for(i=h1[t];i;i=e1[i].next)
		{
			j=e1[i].to;
			k=e1[i].dis;
			if(d1[t]+k<d1[j])
			{
				d1[j]=d1[t]+k;
				q.push(make_pair(-d1[j],j));
			}
		}
	}
}

void dij2(int start)
{	
	priority_queue <pair<long long ,int> > q; 
	memset(d2,0x3f,sizeof(d2));
	memset(v2,0,sizeof(v2));
	q.push(make_pair(0,start));
	d2[1]=0;
	while(!q.empty())
	{
		int i,j;
		long long k;
		int t=q.top().second;
		q.pop();
		if(v2[t]) continue;
		
		v2[t]=1;
		for(i=h2[t];i;i=e2[i].next)
		{
			j=e2[i].to;
			k=e2[i].dis;
			if(d2[t]+k<d2[j])
			{
				d2[j]=d2[t]+k;
				q.push(make_pair(-d2[j],j));
			}
		}
	}
}

int main()
{
	int i,j;
	scanf("%d %d",&n,&m);
	for(i=1;i<=m;i++)
	{
		int t1,t2;
		long long t3;
		scanf("%d %d %lld",&t1,&t2,&t3);
		addedge1(t1,t2,t3);
		addedge2(t2,t1,t3);  //反向建图，防止建在同一张图里面影响程序运行
	}
	long long tot=0;
	dij1(1);
	dij2(1);
	for(i=1;i<=n;i++)
	{
		tot+=d1[i]+d2[i];  
	}
	printf("%lld",tot);
	return 0;
}
```


---

## 作者：就皮这一下 (赞：3)

### 教你如何用结构体简化程序~~偷懒~~的题解
##### 文末有完整代码。
首先我们先来考虑此题如何解决。

**要做题，先分析样例。** 下面红色点表示学生的岗位站点。

- $1 \to \color{red}2\color{black} \to 4 \to 1$ 花费65
- $1 \to \color{red}3\color{black} \to 4 \to 1$ 花费80
- $1 \to 2 \to \color{red}4\color{black} \to 1$ 花费65

合计210。

只需简单思考便可知：整个过程是从1号点出发到某个点再回到1点，那么，**求出1到所有点的距离之和，再加上所有点到1的距离之和，就是题目的答案**！

换言之，在 _原图和反图上_ 分别跑一次最短路算法，答案就会出现！

考虑到SPFA~~死了~~太过玄学，我们选择了Dijkstra算法。

#### 划重点！偷懒的时候到了！
又考虑到我们需要在原图和反图分别跑dij，这里我们采取函数的方式跑最短路。
``` cpp
priority_queue<Heapnode> Q;
Q.push(Heapnode(0,1));
dis[1] = 0;
while(!Q.empty()) {
    Heapnode cur = Q.top();Q.pop();
    if (vis[cur.num]) continue;
    vis[cur.num] = true;
    for (unsigned int i = Head[cur.num]; i!=0; i=g.Next[i]) {
        int to = Tow[i];
        if (dis[to] > dis[cur.num] + Fee[i]) {
            dis[to] = dis[cur.num] + Fee[i];
            Q.push(Heapnode(dis[to],to));
        }
    }
}
```
然而这份堆优化的Dij虽然可以满足我们对分数的渴望，却无法满足我们偷懒的欲望——我们需要对原图反图各自写一次Dij。

正反图的Dij算法除了数组名需要改，剩下的**完全不需要改动**。因此，我们可以利用结构体来偷懒。
``` cpp
struct Graph {
    static const int N = 1e6+3;
    int Head[N],Next[N],Tow[N],Fee[N],cnt;
    long long dis[N];
    bool vis[N];
    Graph () {memset(dis,0x3f,sizeof dis);}
    void Addedge (int u,int v,int c,bool single) {//加边代码，支持加有向和无向边
        if (!single) {
            Addedge(u,v,c,true);Addedge(v,u,c,true);
        }else{
            cnt++;
            Next[cnt] = Head[u];
            Head[u] = cnt;
            Tow[cnt] = v;Fee[cnt] = c;
        }
    }
}G,RevG;//G：原图。RevG：反图。
```
接下来，对Dij的函数稍作改动，并将最后“求出1到所有点的距离之和”也封装到函数里。
``` cpp
struct Heapnode {int dis,num;Heapnode(int dis,int num):dis(dis),num(num){}};
bool operator < (const Heapnode&a,const Heapnode&b) {return a.dis>b.dis;}
long long Dij (Graph &g,int n) {
//注意！这里Graph选用了传引用，避免了数据的复制。
//这里如果选用传值，四个数据点加在一起会整整慢上0.17s。当n，m变大，对效率的影响将更加明显。
    priority_queue<Heapnode> Q;
    Q.push(Heapnode(0,1));
    g.dis[1] = 0;
    while(!Q.empty()) {
        Heapnode cur = Q.top();Q.pop();
        if (g.vis[cur.num]) continue;
        g.vis[cur.num] = true;
        for (unsigned int i = g.Head[cur.num]; i!=0; i=g.Next[i]) {
            int to = g.Tow[i];
            if (g.dis[to] > g.dis[cur.num] + g.Fee[i]) {
                g.dis[to] = g.dis[cur.num] + g.Fee[i];
                Q.push(Heapnode(g.dis[to],to));
            }
        }
    }
ans = 0;
    for (int i = 1; i<=n; ++i) {
        ans += g.dis[i];
    }
    return ans;
}
```
空间复杂度不必赘述，这里两次Dij都是O($n\log{n}$)的，对付$n=10^6$绰绰有余。
最后，**开longlong，开longlong，开longlong！不要到考场上后悔！**

完整代码如下，请放心食用~
``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <cctype>
using namespace std;

template<typename Tp>
int read (Tp &x) {
    x=0;int i=1,c;
    while(!isdigit(c=getchar())) {if(c=='-') i=-1;if(c==EOF) return 0;}x=c-'0';
    while (isdigit(c=getchar())) x=x*10+c-'0';x*=i;
    return 1;
}
template<typename Tp,typename...type>
int read (Tp &x,type &...a) {return read(x)+read(a...);}
struct Graph {
    static const int N = 1e6+3;
    int Head[N],Next[N],Tow[N],Fee[N],cnt;
    long long dis[N];
    bool vis[N];
    Graph () {memset(dis,0x3f,sizeof dis);}
    void Addedge (int u,int v,int c,bool single) {
        if (!single) {
            Addedge(u,v,c,true);Addedge(v,u,c,true);
        }else{
            cnt++;
            Next[cnt] = Head[u];
            Head[u] = cnt;
            Tow[cnt] = v;Fee[cnt] = c;
        }
    }
}G,RevG;
struct Heapnode {int dis,num;Heapnode(int dis,int num):dis(dis),num(num){}};
bool operator < (const Heapnode&a,const Heapnode&b) {return a.dis>b.dis;}
long long Dij (Graph &g,int n) {
    priority_queue<Heapnode> Q;
    Q.push(Heapnode(0,1));
    g.dis[1] = 0;
    while(!Q.empty()) {
        Heapnode cur = Q.top();Q.pop();
        if (g.vis[cur.num]) continue;
        g.vis[cur.num] = true;
        for (unsigned int i = g.Head[cur.num]; i!=0; i=g.Next[i]) {
            int to = g.Tow[i];
            if (g.dis[to] > g.dis[cur.num] + g.Fee[i]) {
                g.dis[to] = g.dis[cur.num] + g.Fee[i];
                Q.push(Heapnode(g.dis[to],to));
            }
        }
    }
    long long ans = 0;
    for (int i = 1; i<=n; ++i) {
        ans += g.dis[i];
    }
    return ans;
}
int main () {
    #ifdef LOCAL
    freopen("testdata.in","r",stdin);
    #endif
    int n,m;
    read(n,m);
    for (int i = 1; i<=m; ++i) {
        int u,v,c;
        read(u,v,c);
        G.Addedge(u,v,c,true);
        RevG.Addedge(v,u,c,true);
    }
    long long ans = Dij(G,n)+Dij(RevG,n);
    cout << ans << endl;
    return 0;
}
```

---

## 作者：寻旧 (赞：3)

思路大家都讲得非常清楚了

建正图，从1跑最短路

建返图，从1跑最短路

然而蒟蒻一看，大家都是分开建

其实像这种多个图的最短路问题

可以讲最短路图封装在结构体里面

非常简洁方便

话不多说，上代码~

```
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
typedef long long LL;
LL read()
{
	LL w=0;bool f=true;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=false;c=getchar();}
	while(c>='0'&&c<='9')w=(w<<1)+(w<<3)+(c^48),c=getchar();
	return f?w:~w+1;
}
const int N=1e6+50;
int n,m;LL Ans;
struct node
{
	int id,dis;
	friend bool operator <(node n1,node n2)
	{
		return n1.dis>n2.dis;
	}
};
struct Graph
{
	int to[N],val[N],nxt[N],fir[N],tot;
	LL d[N];bool b[N];
	void Add(int x,int y,int z)
	{
		to[++tot]=y;val[tot]=z;nxt[tot]=fir[x];fir[x]=tot;
	}
	void dijkstra(int S)
	{
		priority_queue<node>q;
		memset(d,127/3,sizeof(d));
		
		d[S]=0;q.push((node){S,d[S]});
		
		while(!q.empty())
		{
			int x=q.top().id;q.pop();
			if(b[x]) continue;
			b[x]=true;
			for(int k=fir[x];k;k=nxt[k])
			{
				int y=to[k],z=val[k];
				if(d[y]>d[x]+z)
				{
					d[y]=d[x]+z;
					q.push((node){y,d[y]});
				}
			}
		}
	}
}G1,G2;  //构建最短路图

int main()
{
	n=read();m=read();
	for(int i=1;i<=m;++i)
	{
		int x=read(),y=read(),z=read();
		G1.Add(x,y,z);G2.Add(y,x,z);// G1存正图，G2存返图
	}
	G1.dijkstra(1);G2.dijkstra(1);//分别跑最短路
	for(int i=2;i<=n;++i) Ans+=G1.d[i]+G2.d[i];//直接累加
	printf("%lld\n",Ans);
	return 0;
}
```


Thanks for watching！

---

## 作者：寒鸽儿 (赞：2)

就是要正图反图都对 1 号点跑一边 dij。  
技巧:  
1）建图的话考虑 $+n$ 为反图。对应的表头和下一结点都 $+n$。  
2）可以使用大根堆 `priority_queue< Type, vector<Type>, greater<Type> >`。 Type需要定义大于号。  
没啥说的。贴代码  
```cpp
#include <iostream>
#include <cstring>
#include <queue>
#define ll long long

using namespace std;

const ll inf = 10000000000000010;
const int N = 1234567, M = 1234567;
ll wei[M << 1];
int head[N << 1], ver[M << 1], nex[M << 1], tot;

inline void addedge(int u, int v, int w) {
    ver[tot] = v; wei[tot] = w; nex[tot] = head[u]; head[u] = tot++;
}

struct noded {
    ll dis;
    int x;
    noded(ll DIS, int X): dis(DIS), x(X) {}
    bool operator > (const noded& o) const { return dis > o.dis; }
};
priority_queue< noded, vector<noded>, greater<noded> > q;
ll dis[N << 1];
void dij(int s) {
    dis[s] = 0;
    q.push(noded(0, s));
    while(!q.empty()) {
        noded cur = q.top(); q.pop();
        if(dis[cur.x] < cur.dis) continue;
        for(int i = head[cur.x]; ~i; i = nex[i]) {
            if(dis[ver[i]] > dis[cur.x] + wei[i]) {
                dis[ver[i]] = dis[cur.x] + wei[i];
                q.push(noded(dis[ver[i]], ver[i]));
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    memset(head, -1, sizeof(head));
    ll u, ans;
    int n, m, v, w;
    cin >> n >> m;
    for(int i = 1; i <= m; ++i) {
        cin >> u >> v >> w;
        addedge(u, v, w);
        addedge(v + n, u + n, w);
    }
    for(int i = 1; i <= (n << 1); ++i) dis[i] = inf;
    dij(1);
    ans = 0;
    for(int i = 2; i <= n; ++i) ans += dis[i];
    dij(n + 1);
    for(int i = n + 2; i <= (n << 1); ++i) ans += dis[i];
    cout << ans << '\n';
    return 0;
}

```

---

## 作者：Yic_ (赞：2)

[P1342 请柬](https://www.luogu.org/problemnew/show/P1342)
### 思路

分别建一张原图，一张与原图中所有边方向相反、边权相同的反图。在两张图上分别跑一遍SPFA，再计算出两次dis数组的和即可。

需要注意的是本题中存储答案的变量需要开long long。

### Code
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
typedef long long LL;
#define maxn 1000005

using namespace std;

int n,m;
int pre1[maxn],last1[maxn],other1[maxn],len1[maxn],tot1;
int pre2[maxn],last2[maxn],other2[maxn],len2[maxn],tot2;
int dis1[maxn],dis2[maxn];
bool vis1[maxn],vis2[maxn];

inline void add1(int x,int y,int z){
    tot1++;
    pre1[tot1]=last1[x];
    last1[x]=tot1;
    other1[tot1]=y;
    len1[tot1]=z;
}

inline void add2(int x,int y,int z){
    tot2++;
    pre2[tot2]=last2[x];
    last2[x]=tot2;
    other2[tot2]=y;
    len2[tot2]=z;
}

void spfa1(int s){
    queue<int>q;
    memset(dis1,0x3f,sizeof(dis1));
    q.push(s);
    dis1[s]=0;
    vis1[s]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis1[u]=0;
        for(register int p=last1[u];p;p=pre1[p]){
            int v=other1[p];
            if(dis1[v]>dis1[u]+len1[p]){
                dis1[v]=dis1[u]+len1[p];
                if(!vis1[v]){
                    q.push(v);
                    vis1[v]=1;
                }
            }
        }
    }
}

void spfa2(int s){
    queue<int>q;
    memset(dis2,0x3f,sizeof(dis2));
    q.push(s);
    dis2[s]=0;
    vis2[s]=1;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis2[u]=0;
        for(register int p=last2[u];p;p=pre2[p]){
            int v=other2[p];
            if(dis2[v]>dis2[u]+len2[p]){
                dis2[v]=dis2[u]+len2[p];
                if(!vis2[v]){
                    q.push(v);
                    vis2[v]=1;
                }
            }
        }
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=m;i++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add1(x,y,z);
        add2(y,x,z);
    }
    spfa1(1);
    spfa2(1);
    LL ans=0;
    for(register int i=1;i<=n;i++) ans+=dis1[i]+dis2[i];
    printf("%lld",ans);
}

```


---

## 作者：Smallbasic (赞：1)

题目讲的不是很清楚(可能只是因为我太蒟了)

题意是给您一个有向图，求出$1$号点到每个点的最短路和每个点到一号点的最短路之和。

先单看$\color{red}{\text{“1号点到每个点的最短路”}}$这一部分，很明显是个单源最短路的板子。。。不过数据范围很大，必须用堆优化的$dijkstra$才能过。

难点在于$\color{red}{\text{“每个点到一号点的最短路”}}$，这时候直接求最短路不好求，所以去思考能否把它转化成单元最短路问题？

看下图：

```
1 →2
↑  ↓
3 ←4
```

从$4$到$1$的路径为：


```
1 ←2
   ↑
   4
```

它同时又等价于：

```
1 →2
   ↓
   4
```

发现没有，实际上$\color{red}{\text{每个点到一号点的最短路}}$是等价于原图反向连边后$\color{red}{\text{1号点到每个点的最短路}}$的。

所以就有了大致的思路，在原图和反向连边后的图上分别跑一次堆优化的$dijkstra$，求出所有$dis[i]$的和就好啦！！！(用$SPFA$小心被卡)。

~~什么？您不会dijkstra?[洛谷日报包教包会](https://www.luogu.org/blog/61966/dijkstra)~~

代码：

```
#include <bits/stdc++.h>

using namespace std;

int a, b, c;

namespace dij1 { //原图
	struct Edge {
		int head, to, nxt, val;
	}edge[2000005];
	
	struct node {
		int step, val;
		node(int ST = 0, int VAL = 0) : step(ST), val(VAL) {}
		inline bool operator < (const node& b) const {
			return val < b.val;
		}
			inline bool operator > (const node& b) const {
				return val > b.val;
		}
	};
	
	priority_queue<node, vector<node>, greater<node> >q;

	int edgenum(0), n, m, dis[1000005], vis[1000005];
	
	void addedge(int from, int to, int val) {
		edge[++edgenum].to = to; edge[edgenum].val = val;
		edge[edgenum].nxt = edge[from].head; edge[from].head = edgenum;
	}
	
	void dij() {
		q.push(node(1, 0));
		for (register int i = 1; i <= n; ++i) dis[i] = 2147483647; dis[1] = 0;
		while (!q.empty()) {
			int x = q.top().step; q.pop();
			if (vis[x]) continue; vis[x] = 1;
			for (register int i = edge[x].head; i; i = edge[i].nxt) 
				if (!vis[edge[i].to] && dis[edge[i].to] > dis[x] + edge[i].val) 
					dis[edge[i].to] = dis[x] + edge[i].val, q.push(node(edge[i].to, dis[x] + edge[i].val));
		}
	}
}

namespace dij2 {  //反向连边后的图
	struct Edge {
		int head, to, nxt, val;
	}edge[2000005];
	
	struct node {
		int step, val;
		node(int ST = 0, int VAL = 0) : step(ST), val(VAL) {}
		inline bool operator < (const node& b) const {
			return val < b.val;
		}
			inline bool operator > (const node& b) const {
				return val > b.val;
		}
	};
	
	priority_queue<node, vector<node>, greater<node> >q;

	int edgenum(0), n, m, dis[1000005], vis[1000005];
	
	void addedge(int from, int to, int val) {
		edge[++edgenum].to = to; edge[edgenum].val = val;
		edge[edgenum].nxt = edge[from].head; edge[from].head = edgenum;
	}
	
	void dij() {
		q.push(node(1, 0));
		for (int i = 1; i <= n; i++) dis[i] = 2147483647; dis[1] = 0;
		while (!q.empty()) {
			int x = q.top().step; q.pop();
			if (vis[x]) continue; vis[x] = 1;
			for (register int i = edge[x].head; i; i = edge[i].nxt) 
				if (!vis[edge[i].to] && dis[edge[i].to] > dis[x] + edge[i].val) 
					dis[edge[i].to] = dis[x] + edge[i].val, q.push(node(edge[i].to, dis[x] + edge[i].val));
		}
	}
}

int main() {
	scanf("%d%d", &(dij1 :: n), &(dij1 :: m));
	dij2 :: n = dij1 :: n;
	dij2 :: m = dij1 :: m;
	for (register int i = 1; i <= dij1 :: m; ++i) {
		scanf("%d%d%d", &a, &b, &c);
		dij1 :: addedge(a, b, c); dij2 :: addedge(b, a, c);
	}
	dij1 :: dij();
	dij2 :: dij();
	long long ans = 0;
	for (register int i = 1; i <= dij1 :: n; ++i) ans += dij1 :: dis[i] + dij2 :: dis[i];
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：bztMinamoto (赞：1)

乍一看，这是一道单元最短路径的题目。但问题就在于，从1点到达每一个点之后，还要回到1点，要求的是此基础上的最小值

我们可以换个思路：从1点到i点可以用单元最短路算法求解，从i点回到1点可以视为在边取反的有向图上从1点到i点

于是乎，我们可以存两个图，一个原图，一个原图取反，在两张图上分别求出单源最短路径，最后两张图上1到所有点的距离之和就是所求的答案

具体细节看注解，上代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int N=1000050,M=1000050;
typedef long long LL;
int edge[M],ver[M],Next[M],head[N],used[N],d[N];
int edge2[M],ver2[M],Next2[M],head2[N],f[N];
int n,m,tot;
LL ans;
void add(int x,int y,int z)
{
    ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
    ver2[tot]=x,edge2[tot]=z,Next2[tot]=head2[y],head2[y]=tot;
    //一个链表用来存原图，一个存反向图
    return;
}
void spfa()
{
//求原图上的单源最短路径
    memset(d,0x3f,sizeof(d));
    memset(used,0,sizeof(used));
    queue<int> q;
    q.push(1);
    d[1]=0,used[1]=1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        used[x]=0;
        for(int i=head[x];i;i=Next[i])
        {
            int y=ver[i],z=edge[i];
            if(d[y]>d[x]+z)
            {
                d[y]=d[x]+z;
                if(!used[y]) q.push(y),used[y]=1;
            }
        }
    }
    return;
}
void spfa2()
{
//求反向图上的单源最短路径
    memset(f,0x3f,sizeof(f));
    memset(used,0,sizeof(used));
    queue<int> q;
    q.push(1);
    f[1]=0,used[1]=1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        used[x]=0;
        for(int i=head2[x];i;i=Next2[i])
        {
            int y=ver2[i],z=edge2[i];
            if(f[y]>f[x]+z)
            {
                f[y]=f[x]+z;
                if(!used[y]) q.push(y),used[y]=1;
            }
        }
    }
    return;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
    }
    spfa();
    spfa2();
    for(int i=1;i<=n;i++)
    ans+=f[i]+d[i];
    //答案即为两张图上的距离之和
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：理想气体 (赞：1)

先膜楼上各位dalao；

实际上这道题数据规模看上去很吓人，但做起来并不会特别难。dij跑的话需要优化，然而SPFA可以裸过；

至于邻接表也不需要手写，用STL的vector不会炸。

思路是存两遍图，正向一遍反向一遍，然后分别跑SPFA最后结果相加。本来想着不用高精可能会爆，然而并不会= =

总之这题还是很友好的。

最后，如果用这种比较裸的方法，建议输入能用scanf就用，用iostream要冒着RE的风险加一句cin.sync\_with\_stdio(false);否则很可能超时

代码如下







```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
struct po
{
    int p,v;
};
vector<po> m1[1000005],m2[1000005];
int m,n;
int d1[1000005] , d2[1000005];
const int INF = 2000000000;
queue<int> q;
bool isin[1000005];
void SPFA1()
{
    q.push(1);isin[1] = true;d1[1] = 0;
    while(!q.empty())
    {
        int x = q.front();q.pop();isin[x] = false;
        for(vector<po>::iterator ite = m1[x].begin() ; ite != m1[x].end() ; ite++)
        {
            if(d1[(*ite).p] > d1[x] + (*ite).v)
            {
                d1[(*ite).p] = d1[x] + (*ite).v;
                if(!isin[(*ite).p])
                {
                    q.push((*ite).p);
                    isin[(*ite).p] = true;
                }
            }
        }
    }
    return;
}
void SPFA2()
{
    q.push(1);isin[1] = true;d2[1] = 0;
    while(!q.empty())
    {
        int x = q.front();q.pop();isin[x] = false;
        for(vector<po>::iterator ite = m2[x].begin() ; ite != m2[x].end() ; ite++)
        {
            if(d2[(*ite).p] > d2[x] + (*ite).v)
            {
                d2[(*ite).p] = d2[x] + (*ite).v;
                if(!isin[(*ite).p])
                {
                    q.push((*ite).p);
                    isin[(*ite).p] = true;
                }
            }
        }
    }
    return;
}
int main()
{
    cin.sync_with_stdio(false);
    cin>>n>>m;
    for(int i = 1 ; i <= m ; i++)
    {
        int x,y,z;cin>>x>>y>>z;
        m1[x].push_back((po){y,z});
        m2[y].push_back((po){x,z});
    }
    for(int i = 0 ; i <= n ; i++)
        d1[i] = d2[i] = INF;
    SPFA1();
    memset(isin , 0 , sizeof(isin));
    SPFA2();
    long long ans = 0;
    for(int i = 1 ; i <= n ; i++)
    {
        ans += (d1[i] + d2[i]);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：XZYQvQ (赞：1)

这题卡常啊。

邻接表不能用手写的真链表，会超时。。。

用stl的链表就更不用说了。

只能手动模拟链表。

因为真链表会动态申请内存，比较慢。。。


至于思路，楼下的已经讲的很清晰了。

建立反向图，以1节点为源点在正反图上分别跑一遍spfa。

答案就是所有点到1节点的最短路长度之和。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
static const int maxs=1000000;
template<typename _Tp>inline void in(_Tp & dig)
{
    char c=getchar();dig=0;
    while(!isdigit(c))c=getchar();
    while(isdigit(c))dig=dig*10+c-'0',c=getchar();
}
struct graph
{
    int to[maxs+5],dis[maxs+5],nxt[maxs+5],head[maxs+5],size;
    inline graph(){memset(head,-1,sizeof(head)),size=0;}
    inline void push(int u,int v,int w)
    {
        to[size]=v,dis[size]=w,nxt[size]=head[u],head[u]=size,size++;
    }
};
int n,m;
LL dis[maxs+5],ans;
graph l,ul;
queue<int> que;
bool inque[maxs+5];
void spfa(graph*l)
{
    for(int i=2;i<=n;i++)dis[i]=LLONG_MAX;
    que.push(1),inque[1]=1;
    while(!que.empty())
    {
        int f=que.front();que.pop(),inque[f]=0;
        for(int i=l->head[f];i!=-1;i=l->nxt[i])
            if(dis[l->to[i]]>dis[f]+l->dis[i])
            {
                dis[l->to[i]]=dis[f]+l->dis[i];
                if(!inque[l->to[i]])que.push(l->to[i]),inque[l->to[i]]=1;
            }
    }
    for(int i=2;i<=n;i++)ans+=dis[i];
}
int main()
{
    in(n),in(m);
    for(int i=1,u,v,w;i<=m;i++)in(u),in(v),in(w),l.push(u,v,w),ul.push(v,u,w);
    spfa(&l),spfa(&ul),printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Memorize (赞：1)

算最短路的一道裸题了 正向建图跑一遍 反向建图跑一遍 用一个ans记录答案即可 适合初学者做

```cpp
 #include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#define ll long long
using namespace std;
int m,n,k1=0,k2=0,x,y,z;
struct node{
    int to,next;
    ll w;
};
node e[2000010],ed[2000010];
ll dist[1000010],ans=0;
int head1[2000010],head2[2000010];
int queue[4000010],qhead,qtail;
bool vis[1000100];
void add1(int u,int v,ll w)
{
    e[++k1].next=head1[u];
    e[k1].to=v;
    e[k1].w=w;
    head1[u]=k1;
}
void add2(int u,int v,ll w)
{
    ed[++k2].next=head2[u];
    ed[k2].to=v;
    ed[k2].w=w;
    head2[u]=k2;
}
void spfa1()
{
    memset(vis,false,sizeof(vis));
    memset(dist,127,sizeof(dist));
    qhead=0,qtail=1;
    dist[1]=0,vis[1]=true;queue[1]=1;
    while(qhead<qtail)
    {
      int p=queue[++qhead];
      vis[p]=false;
      for(int i=head1[p];i;i=e[i].next)
      {
          if(dist[e[i].to]>dist[p]+e[i].w)
          {
              dist[e[i].to]=dist[p]+e[i].w;
              if(!vis[e[i].to])
              {
                  vis[e[i].to]=true;
                queue[++qtail]=e[i].to;          
            }
        }
      }   
    }
    for(int i=2;i<=n;i++) ans+=dist[i];
}
void spfa2()
{
    memset(vis,false,sizeof(vis));
    memset(dist,127,sizeof(dist));
    qhead=0,qtail=1;
    dist[1]=0,vis[1]=true;queue[1]=1;
    while(qhead<qtail)
    {
      int p=queue[++qhead];
      vis[p]=false;
      for(int i=head2[p];i;i=ed[i].next)
      {
          if(dist[ed[i].to]>dist[p]+ed[i].w)
          {
              dist[ed[i].to]=dist[p]+ed[i].w;
              if(!vis[ed[i].to])
              {
                  vis[ed[i].to]=true;
                queue[++qtail]=ed[i].to;          
            }
        }
      }   
    }
    for(int i=2;i<=n;i++) ans+=dist[i];    
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
      scanf("%d%d%d",&x,&y,&z);
      add1(x,y,z);
      add2(y,x,z);
    }
    spfa1();
    spfa2();
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Kwork (赞：1)

非常常见的技巧，我们对于原图做一遍最短路，得到起点到其他每个点的代价的最小值，然后就需要求出其他每个点到起点的最小代价值，我们只需要将原图反向，从起点做最短路就可以得到其他点到起点的最小代价值。

然后就是写最短路，其实没什么spfa，dij都可以（dij需要优化，spfa没试过）。







```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
using namespace std;
const int maxn=1000000+20;
struct edge{int to,w;};
typedef vector<edge> graph[maxn];
typedef pair<long long,int> P;
typedef long long ll;
graph G,rG;
int n,m;
ll d[maxn],ans=0;
priority_queue<P,vector<P>,greater<P> > que;
inline void read(int &n){
    n=0;int f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    n=n*f;
    return;
}
void write(ll n){
    if(n<0){
        putchar('-');
        n=0-n;
    }
    if(n>=10) write(n/10);
    putchar((n % 10)+'0');
    return;
}
inline void add_edge(int u,int v,int w){
    edge e;
    e.to=v,e.w=w;
    G[u].push_back(e);
    e.to=u;
    rG[v].push_back(e);
    return;
}
void init(){
    read(n);read(m);
    int u,v,w;
    for(int i=1;i<=m;i++){
        read(u);read(v);read(w);
        add_edge(u,v,w);
    }
    return;
}
void dijkstra(graph &g){
    for(int i=1;i<=n;i++) d[i]=1234567890;
    while(!que.empty()) que.pop();
    d[1]=0;P p(0,1);
    que.push(p);
    while(!que.empty()){
        P pp=que.top();
        que.pop();
        int u=pp.second;
        if(d[u]<pp.first) continue;
        for(int i=0;i<g[u].size();i++){
            int v=g[u][i].to;
            int temp=d[u]+g[u][i].w;
            if(d[v]>temp){
                d[v]=temp;
                P p(d[v],v);
                que.push(p);
            }
        }
    }
    for(int i=1;i<=n;i++)
        ans+=d[i];
    return;
}
void solve(){
    dijkstra(G);
    dijkstra(rG);
    write(ans);
    return;
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：Uranus (赞：1)

一行神奇的代码：

```cpp
ios::sync_with_stdio(false);
```

加之前3TLE，加之后AC，所以这是一道**省选基础-读入/输出优化**题（确信）。

附上SPFA代码AC：

```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
#define MAXN 1000010
int n,m,x,y,z,dis[MAXN];
long long ans;///记住一定要long long!!!
bool vis[MAXN];
struct Node
{
    int v,d;
};
bool operator < (Node a,Node b)
{
    return a.d>b.d;
}
vector<Node>G[MAXN];
vector<Node>ReG[MAXN];///表示反边
priority_queue<Node>Q;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    while(m--)
    {
        cin>>x>>y>>z;
        G[x].push_back((Node){y,z});
        ReG[y].push_back((Node){x,z});
    }
    memset(dis,0x7f,sizeof dis);
    dis[1]=0;
    Q.push((Node){1,0});
    while(!Q.empty())
    {
        int now=Q.top().v;Q.pop();
        if(vis[now]) continue;
        vis[now]=true;
        ans+=dis[now];
        for(int i=0;i<G[now].size();i++)
        {
            Node hjj=G[now][i];
            if(!vis[hjj.v]&&dis[hjj.v]>dis[now]+hjj.d)
            {
                dis[hjj.v]=dis[now]+hjj.d;
                Q.push((Node){hjj.v,dis[hjj.v]});
            }
        }
    }
    ///跑完正边跑反边
    memset(dis,0x7f,sizeof dis);
    memset(vis,0,sizeof vis);
    while(!Q.empty())
        Q.pop();
    dis[1]=0;
    Q.push((Node){1,0});
    while(!Q.empty())
    {
        int now=Q.top().v;Q.pop();
        if(vis[now]) continue;
        vis[now]=true;
        ans+=dis[now];
        for(int i=0;i<ReG[now].size();i++)
        {
            Node hjj=ReG[now][i];
            if(!vis[hjj.v]&&dis[hjj.v]>dis[now]+hjj.d)
            {
                dis[hjj.v]=dis[now]+hjj.d;
                Q.push((Node){hjj.v,dis[hjj.v]});
            }
        }
    }
    cout<<ans;
    return 0;
}

```


---

## 作者：chenzida (赞：0)

题意简述：

在一个有向图中求从 $1$ 号点到其他每个点的往返距离之和。

思路解析：

如果我们只是要求从 $1$ 号点到其他点的走一趟的距离和，那么这是十分容易的，我们就跑一次 $dijkstra$ 或者 $spfa$ 即可，但是如果要求往返怎么办呢？

我们是不是可以反着跑呢？就是从 $1$ 号点不管走哪一条都“逆行”，就可以了。所以为了解决这个问题我们，建两张图，分别是正图和反图，这样我们就能通过在反图上跑单源最短路来求出从每个点到 $1$ 的距离和。

那我们用什么方法呢？我原本用的是 $SPFA$ ，但是被毒瘤数据卡得 $T$ 飞了。所以我就用一个神奇的优化，那就是 $spfa$ 堆优化，这种优化在通常情况下都是正优化，而且更不容易卡，但是如果真的被卡了，那么可能会到 $O(k\times m\times log(m))$ 的时间，但是这样在一个只卡普通 $spfa$ 的数据情况下还是很好用的。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
const int NR=1e6+10;
const int MR=1e6+10;
int x[NR];
int n,m,s;
int dis[NR];
bool vis[NR];
int to[MR*2],nxt[MR*2],val[MR*2];
int head[NR];
int tot=1;
void add(int x,int y,int z)
{
	to[tot]=y;
	val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot++;
}
struct cmp
{
    bool operator ()(int x, int y) const
    {
        return dis[x] > dis[y];
    }
};
int dis2[NR];
bool vis2[NR];
int to2[MR*2],nxt2[MR*2],val2[MR*2];
int head2[NR];
int tot2=1;
void add2(int x,int y,int z)
{
	to2[tot2]=y;
	val2[tot2]=z;
	nxt2[tot2]=head2[x];
	head2[x]=tot2++;
}
priority_queue<int, vector<int>, cmp> q;
priority_queue<int, vector<int>, cmp> q2;
void SPFA()
{
	memset(dis,999999,sizeof(dis));
	dis[s]=0;
	q.push(s);
	vis[s]=1;
	while(!q.empty())
	{
		int x=q.top();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(dis[y]>dis[x]+val[i])
			{
				dis[y]=dis[x]+val[i];
				if(!vis[y])
				{
					vis[y]=1;
					q.push(y);
				}
			}
		}
	}
}
void SPFA2()
{
	memset(dis2,999999,sizeof(dis2));
	dis2[s]=0;
	q2.push(s);
	vis2[s]=1;
	while(!q2.empty())
	{
		int x=q2.top();
		q2.pop();
		vis2[x]=0;
		for(int i=head2[x];i;i=nxt2[i])
		{
			int y=to2[i];
			if(dis2[y]>dis2[x]+val2[i])
			{
				dis2[y]=dis2[x]+val2[i];
				if(!vis2[y])
				{
					vis2[y]=1;
					q2.push(y);
				}
			}
		}
	}
}
signed main()
{
//	freopen("25.in","r",stdin);
//	freopen("25.out","w",stdout);
	n=read(),m=read(),s=1;
	for(int i=1;i<=m;i++)
	{
		int x,y,z1;
		x=read(),y=read(),z1=read();
		add(x,y,z1),add2(y,x,z1);
	}
	SPFA();
	SPFA2();
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		ans+=dis[i]+dis2[i];
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：DEADFISH7 (赞：0)

看见大家一下子都是直接两个两个的写我有些慌张；

于是写了一份简洁版的题解，避免了写两次函数时可能出现的变量混乱、懒得ctrl+e等一系列问题；

一道最短路的模板题

以为大数据所以加了堆优化

这个stl堆优化也是较为好写

考前发题解RP++
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const long long N = 1000005 ;
const long long maxn = 0x3f3f3f3f;
int n,m;
long long —=0;
long long head1[N];
long long head2[N];
long long dis[N];
struct node
{
	long long to,nxt,val;
}e1[N*2],e2[N*2];
void add(int f,int t,long long w,long long *head,node *e,long long _)
{
	e[_]=(node){t,head[f],w};
	head[f]=_;
}
struct data 
{
	long long id,dis;
	friend bool operator < (data a,data b)
	{ return a.dis>b.dis; }
};
void dij(int st,long long *d,long long *head,node *e)
{
	priority_queue <data> q;
	for(int i=1;i<=n;i++) d[i]=maxn;
	d[st]=0;q.push((data){st,0});
	while(!q.empty())
	{
		data t=q.top();q.pop();
		int u=t.id;
		if(t.dis!=d[u]) continue;
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(d[v]>d[u]+e[i].val)
			{
				d[v]=d[u]+e[i].val;
				q.push((data){v,d[v]});
			}
		}
	}
}
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
	{
		long long u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		_++;
		add(u,v,w,head1,e1,_);
		add(v,u,w,head2,e2,_);
	}
	long long ans=0;
	dij(1,dis,head1,e1);
	for(int i=1;i<=n;i++) ans+=dis[i];
	dij(1,dis,head2,e2);
	for(int i=1;i<=n;i++) ans+=dis[i];
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：abandentsky (赞：0)

题意：我就不说了，就是求从1出发到达各个点的最短路，然后求各个点的最短路。然后求一遍各个点到1的最短路之和。看了大家写的代码，我觉得代码有点多，各种优化，我直接来个dijkstra代码，裸的，也能过。
思路：先正向建图，跑一边dijkstra，再反向建图，跑一边dijkstra。然后求和就完了。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 1000005
#define maxnode 1000005
#define sigma_size 26
#define md 12345678
#define INF 0x3f3f3f3f
#define pii pair<int,int>
using namespace std;

typedef long long LL;
int n,m;
struct Edge
{
    int from;
    LL to,dist;
    Edge(int from=0,int to=0,LL dist=0):from(from),to(to),dist(dist){};
};
struct Heapnode
{
    int u;
    LL dis;
    Heapnode(int u=0,LL dis=0):u(u),dis(dis){};
    bool operator < (const Heapnode &rah) const
    {
        return dis>rah.dis;
    }
};
struct Dijkstra
{
    int s,t;
    vector<Edge> edges;
    vector<int> G[MAXN];
    LL d[MAXN];
    bool done[MAXN];

    void AddEdge(int from,int to,LL dis)
    {
        edges.push_back({from,to,dis});
        int mm=edges.size();
        G[from].push_back(mm-1);
    }

    LL solve()
    {
        memset(d,INF,sizeof(d));
        priority_queue<Heapnode> Q;
        Q.push({s,0});
        d[s]=0;
        while(!Q.empty())
       {
            Heapnode X=Q.top();
            Q.pop();
            if(done[X.u])
                continue;
            done[X.u]=true;
            for(int i=0;i<G[X.u].size();i++)
            {
                  Edge &e=edges[G[X.u][i]];
                  if(d[e.to]>d[X.u]+e.dist)
                  {
                        d[e.to]=d[X.u]+e.dist;
                        Q.push({e.to,d[e.to]});
                  }
            }
       }
       LL ans=0;
       for(int i=1;i<=n;i++)
              ans+=d[i];
       return ans;
    }
}mm,nn;



int main()
{
    scanf("%d %d",&n,&m);
    int u,v;
    LL w;
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d %lld",&u,&v,&w);
        mm.AddEdge(u,v,w);
        nn.AddEdge(v,u,w);
    }
    mm.s=nn.s=1;
    LL sum=0;
    sum+=mm.solve();
    sum+=nn.solve();
    printf("%lld\n",sum);
    return 0;
}

```



---

## 作者：TheShadow (赞：0)

#### 差不多是Dijkstra的裸题吧。。。
- 这道题可以分为来回两个阶段。
- 去的时候很简单，直接用一次Dijkstra，然后统计答案。
- 回来的时候就有些巧妙了，虽然表面上是每个点回到起点，但是何尝不可将其看成从起点出发，逆着每个点过来的路去找一次每个点？所以只需要存边的时候处理一下，然后直接跑Dijkstra就行了。
- 附上代码。
```cpp
#include<bits/stdc++.h>
#define clean(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
using namespace std;
template<class T>il read(T &x)
{
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
const int MAXN = 1e6+5;
int n,m,u,v,d,head[MAXN],num_edge,dis[MAXN];
ll ans;
struct Edge{
	int next,to,dis,type; //存边的时候用了一个type标记，1表示它为正向边，2表示它为反向边
	Edge(){}
	Edge(int next,int to,int dis,int type):next(next),to(to),dis(dis),type(type){}
}edge[MAXN<<1];
il add_edge(int u,int v,int dis){
	edge[++num_edge]=Edge(head[u],v,dis,1);head[u]=num_edge; //加正边
	edge[++num_edge]=Edge(head[v],u,dis,2);head[v]=num_edge; //加反边
}
struct Node{
	int pos,dis;
	Node(){}
	Node(int pos,int dis):pos(pos),dis(dis){}
	bool operator <(const Node &t) const{
		return dis>t.dis;
	}
};
bool tr[MAXN];
il dijkstra(int type){
	priority_queue<Node> q;q.push(Node(1,0));
	for(ri i=2;i<=n;i++) dis[i]=2147483647;
	clean(tr,0);
	while(!q.empty()){
		Node tmp=q.top();q.pop();
		ri pos=tmp.pos;
		if(tr[pos]) continue;
		tr[pos]=true;
		for(ri i=head[pos];i;i=edge[i].next){
			if(edge[i].type!=type) continue; //进行判断
			if(dis[edge[i].to]>dis[pos]+edge[i].dis){
				dis[edge[i].to]=dis[pos]+edge[i].dis;
				if(!tr[edge[i].to]) q.push(Node(edge[i].to,dis[edge[i].to]));
			}
		}
	}
	for(ri i=2;i<=n;i++) ans+=dis[i]; //统计答案
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	for(ri i=1;i<=m;i++) read(u),read(v),read(d),add_edge(u,v,d);
	dijkstra(1);dijkstra(2);
	printf("%lld",ans); //答案记得开long long
	return 0;
}
```
- 这道题其实更优的方法是开两个结构体，分别来存正反边，这样时间复杂度会小一些（毕竟不用每条边正反两个每次都要跑），但是为什么我没有这样写呢？~~当然是我懒啊~~
- OK，完工。[]~(￣▽￣)~*

---

## 作者：muller (赞：0)

发现好像要枚举一下那个点

但是每当枚举一次就要spfa一次

发现非常耗时

多算了许多无用的东西

所以我们考虑只spfa一边的高效算法

于是考虑直接反见图，然后spfa3遍

最后求一下和，去个min即可

然而sofa好像有被卡了qwq

只好写dj了

代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define Maxn 5000500
#define int long long
using namespace std;
template <typename tn> void read(tn &a){
    tn x = 0, f = 1; char c = getchar();
    while(!isdigit(c)){if (c == '-') f = -1; c = getchar();}
    while(isdigit(c)) x = x * 10 + c - 48, c = getchar();
    a = x * f;
}

struct node{
    int u, l;
};
struct E{
    int u, v, l;
} e[Maxn];
struct Edge{
    int v, l, next;
} edge[Maxn];
bool operator > (node p, node q){
    return p.l > q.l;
}
priority_queue<node, vector<node>, greater<node> > que;
int first[Maxn], dis[Maxn];
int Top = 0, ans = 0;

void addedge(int u, int v, int l){
    edge[++Top].v = v;
    edge[Top].l = l;
    edge[Top].next = first[u];
    first[u] = Top;
}
void dijstra(){
    while (que.size()) que.pop();
    que.push({1, 0});
    memset(dis, 63, sizeof(dis)); dis[1] = 0;
    while (que.size()){
        node p = que.top(); que.pop(); 
        int u = p.u, d = p.l;
        if (dis[u] < d) continue;
        for (int i = first[u]; i; i = edge[i].next){
            int v = edge[i].v, l = edge[i].l;
            if (dis[u] + l < dis[v]){
                dis[v] = dis[u] + l;
                que.push({v, dis[v]});
            }
        }
    }
}
main(){
    int n, m; read(n); read(m);
    for (int i = 1; i <= m; i++){
        read(e[i].u); read(e[i].v); read(e[i].l);
        addedge(e[i].u, e[i].v, e[i].l);
    }
    dijstra();
    for (int i = 1; i <= n; i++) ans += dis[i];
    
    memset(first, 0, sizeof(first)); Top= 0;
    for (int i = 1; i <= m; i++)
        addedge(e[i].v, e[i].u, e[i].l);
    dijstra();
    for (int i = 1; i <= n; i++) ans += dis[i];
    
    cout << ans << endl;
    return 0;
}
```


---

## 作者：设计涉及社稷 (赞：0)

# [P1342 请柬](https://www.luogu.org/problemnew/show/P1342)
### 采用SLF优化

SLF优化法就是把SPFA原来的函数中加了一个判断，就是如果修改后从1到y的距离len[y]>len[q.front()]，**就把它推到用来存点的队列q的末尾，反之存在开始处。**
要达到这个操作目的，需要用到双向队列deque，在这里主要讲讲它的几种操作：

- 队列前面插入元素，就是q.push_ front()
- 末尾就是q.push_ back()，
- 弹出元素pop同理。

这种优化法的原因就是尽量减少更新判断成功后的更新步骤，也就是说要尽量让短路靠前，那么我们就把长路放后面，短路放前面。
```
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
#define N 1000010
#define INF 2147483647
#define ll long long 
int m,n,cnt1,cnt2;

struct Edge{
    int v,next,dis;
}e1[N],e2[N];

int head1[N],head2[N];
bool inq[N];
int dis[N];
ll ans;

int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}

void add(int u,int v,int w)
{
    e1[++cnt1].v=v;
    e1[cnt1].next=head1[u];
    head1[u]=cnt1;
    e1[cnt1].dis=w;
    
    e2[++cnt2].v=u;
    e2[cnt2].next=head2[v];
    head2[v]=cnt2;
    e2[cnt2].dis=w;
}

void spfa1()
{
	deque<int>q;
	q.push_back(1);
	fill(dis+2,dis+n+1,INF);
	while(!q.empty())
	{
		int u=q.front();
		q.pop_front();
		inq[u]=0;
		for(int i=head1[u];i;i=e1[i].next)
		{
			int v=e1[i].v,w=e1[i].dis;
			if(dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				if(!inq[v])
				{
					if(q.empty() || dis[v]<dis[u])
						q.push_front(v);
					else
						q.push_back(v);
					inq[v]=1;  
				}
			}
		}
	} 
	rep(i,2,n)
		ans+=dis[i];
}

void spfa2()
{
    deque <int> q2;
    q2.push_front(1);
    fill(dis+2,dis+n+1,INF);
    while(!q2.empty())
      {
          int u=q2.front();
          q2.pop_front();
          inq[u]=0;
          for(int i=head2[u];i;i=e2[i].next)
            {
                int v=e2[i].v,w=e2[i].dis;
                if(w+dis[u]<dis[v])
                {
                    dis[v]=w+dis[u];
                    if(!inq[v])
                    {
                    	if(q2.empty() || dis[v]<dis[u]) 
							q2.push_front(v);
                        else 
							q2.push_back(v);
                        inq[v]=1;
                	}
              	}
          	}
      	}
    rep(i,2,n)
      	ans+=dis[i];
}

int main()
{
    n=read(),m=read();
    rep(i,1,m)
    {
        int x,y,z;
        x=read(),y=read(),z=read();
        add(x,y,z);
    }
    spfa1();
    spfa2();
    printf("%lld",ans);
    return 0;
}
```
---
# [P1359 租用游艇 ](https://www.luogu.org/problemnew/solution/P1359)
### LLL（Large Label Last）优化

### 它的策略是：对每个要出对的元素u，比较dis[u]和队列中dis的平均值，如果dis[u]更大，那么将它弹出放到队尾，取队首元素在进行重复判断，直至存在dis[x]小于平均值

## 注：本代码是SLF和LLL的结合版
```
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++) 
#define N 205
using namespace std;

int n, dis[N], sum = 0, cnt = 0;
int G[N][N];
bool inq[N];

int main()
{
    memset(dis, 0x3f, sizeof(dis));
    scanf("%d",&n);
    rep(i,1,n-1)
    	rep(j,i+1,n)
    		scanf("%d",&G[i][j]);
    deque<int> Q;
    Q.push_back(1);
    inq[1]=1;
    dis[1]=0;
    cnt=1;
    while(!Q.empty())
    {
    	int u=Q.front();
    	while(cnt*dis[u]>sum)
    	{
    		Q.pop_back();
    		Q.push_back(u);
			u=Q.front(); 	
		}
		Q.pop_front();
		cnt--;
		sum-=dis[u];
		inq[u]=0;
		rep(i,u+1,n)
		{
			if(dis[i]>dis[u]+G[u][i])
			{
				dis[i]=dis[u]+G[u][i];
				if(!inq[i])
				{
					if(dis[i]<=dis[Q.front()])
						Q.push_front(i);
					else 
						Q.push_back(i); 
					inq[i]=1;
					sum+=dis[i];
					cnt++; 
				}
			}
		}
	}
    printf("%d",dis[n]);
}
```

---

## 作者：SFWR (赞：0)

就只是比p1629多了一点范围啊。
~~然而被卡时间了~~
正着跑，我：SPFA!
反着跑，我：~~每个都来！~~


------------
我们可以这样考虑，既然是从目标节点回去，那就是从节点到目标的逆路！
但是，路是单向的，如果是无向图x2
那有向图呢？
反过来存啊！
~~有这样一位数竞大佬在期末考试后说：负负得正~~
这样就得到了代码
将spfa写两遍，存两个图

code

```c
#include<bits/stdc++.h>
using namespace std;
int m,n,s,a,b,c,k,t,num_edge=0,num_edge2=0;
long long sum;
int head[1000001],vist[1000001],vist2[1000001],head2[1000001]; 
long long int dis[5000005],dis2[5000005];
struct Edge{int to,dis,next;}edge[5000005];
struct Edge2{int to,dis,next;}edge2[5000005];
inline void adde(int from,int to,int dis)
{
  edge[++num_edge].next=head[from];
  edge[num_edge].to=to;
  edge[num_edge].dis=dis;
  head[from]=num_edge; 
}
inline void adde2(int from,int to,int dis)
{
  edge2[++num_edge2].next=head2[from];
  edge2[num_edge2].to=to;
  edge2[num_edge2].dis=dis;
  head2[from]=num_edge2; 
}
inline void spfa(){
    queue<int> q;
    for(register int i=1; i<=n; i++) dis[i]=2147483647; 
    q.push(1); dis[1]=0; vist[1]=1;
    while(!q.empty()){
    int u=q.front();
    q.pop();vist[u]=0;
    for(register int i=head[u];i;i=edge[i].next)
        if(dis[edge[i].to]>dis[u]+edge[i].dis){
            dis[edge[i].to]=dis[u]+edge[i].dis;
            if(vist[edge[i].to]==0){vist[edge[i].to]=1;q.push(edge[i].to);}
        }   
    }
}
inline void spfa2(){
    queue<int> q2;
    for(register int i=1; i<=n; i++) dis2[i]=2147483647; 
    q2.push(1); dis2[1]=0; vist2[1]=1;
    while(!q2.empty()){
    int u=q2.front();
    q2.pop();vist2[u]=0;
    for(register int i=head2[u];i;i=edge2[i].next)
        if(dis2[edge2[i].to]>dis2[u]+edge2[i].dis){
            dis2[edge2[i].to]=dis2[u]+edge2[i].dis;
            if(vist2[edge2[i].to]==0){vist2[edge2[i].to]=1;q2.push(edge2[i].to);}
        }   
    }
}
inline  int gi()
{
    register int x=0;
    register int t=1;
    register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x*t;
}
int main(){
    cin>>n>>m;
    while(m--){a=gi();b=gi();c=gi();adde(a,b,c);
	adde2(b,a,c);}
	spfa();
    spfa2();
    for(int i=2;i<=n;i++)sum+=(dis[i]+dis2[i]);
    cout<<sum;
	return 0;
}
```

---

## 作者：doby (赞：0)

堆优化dijkstra/SPFA

乘车回到总部如果每个点求到1的最短路复杂度大概是O(n^2logm)……

这部分可以反向建边，反向建边时1到i的最短路就相当于正向建边时i到1的最短路

因此分别跑一遍最短路就好了……

边权小于10^9，答案要用longlong
```cpp
#include<cstdio>
#include<queue>
using namespace std;
int n,m,x,y,z,p,q,cnt,h1[1000010],h2[1000010];
long long dis[1000010],ans;
bool d[1000010];
struct Edge
{
    int to,next,dis;
}e1[1000010],e2[1000010];//所有的边都要存两遍
struct Heap
{
    int dis,id;
    bool operator<(const Heap &h1)const
    {
        return dis>h1.dis;
    }
};
void Add(int x,int y,int z)
{
    e1[++cnt].next=h1[x],
    e1[cnt].to=y,
    e1[cnt].dis=z,
    h1[x]=cnt,
    e2[cnt].next=h2[y],//反向建边
    e2[cnt].to=x,
    e2[cnt].dis=z,
    h2[y]=cnt;
}
void Dijkstra()
{
    priority_queue<Heap>h;
    Heap x;
    for(int i=0;i<=n;++i){dis[i]=1109260817,d[i]=0;}
    dis[1]=0,x.dis=0,x.id=1;
    h.push(x);
    while(!h.empty())
    {
        x=h.top();h.pop();
        p=x.id;
        if(d[p]){continue;}
        d[p]=1;
        for(int i=h1[p];i;i=e1[i].next)
        {
            q=e1[i].to;
            if(dis[p]+e1[i].dis<dis[q])
            {
                dis[q]=dis[p]+e1[i].dis,
                x.dis=dis[q],x.id=q;
                h.push(x);
            }
        }
    }
    for(int i=2;i<=n;++i){ans+=dis[i],dis[i]=1109260817,d[i]=0;}//重新初始化
    dis[1]=0,d[1]=0,x.dis=0,x.id=1;
    h.push(x);
    while(!h.empty())
    {
        x=h.top();h.pop();
        p=x.id;
        if(d[p]){continue;}
        d[p]=1;
        for(int i=h2[p];i;i=e2[i].next)
        {
            q=e2[i].to;
            if(dis[p]+e2[i].dis<dis[q])
            {
                dis[q]=dis[p]+e2[i].dis,
                x.dis=dis[q],x.id=q;
                h.push(x);
            }
        }
    }
    for(int i=2;i<=n;++i){ans+=dis[i];}
}
void SPFA()
{
    for(int i=2;i<=n;i++){dis[i]=1009260817;}
    dis[1]=0,d[1]=1;
    q.push(1);
    while(!q.empty())
    {
        x=q.front();q.pop();
        d[x]=0;
        for(int i=h1[x];i;i=e1[i].next)
        {
            y=e1[i].to;
            if(dis[y]>dis[x]+e1[i].dis)
            {
                dis[y]=dis[x]+e1[i].dis;
                if(!d[y]){d[y]=1;q.push(y);}
            }
        }
    }
    for(int i=2;i<=n;i++){ans+=dis[i],dis[i]=1009260817,d[i]=0;}
    dis[1]=0,d[1]=1;
    q.push(1);
    while(!q.empty())
    {
        x=q.front();q.pop();
        d[x]=0;
        for(int i=h2[x];i;i=e2[i].next)
        {
            y=e2[i].to;
            if(dis[y]>dis[x]+e2[i].dis)
            {
                dis[y]=dis[x]+e2[i].dis;
                if(!d[y]){d[y]=1;q.push(y);}
            }
        }
    }
    for(int i=2;i<=n;i++){ans+=dis[i];}
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i)
    {
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z);
    }
    Dijkstra();
    //SPFA();
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：小知青 (赞：0)

###### 这道题可以简化为如下内容：给定一个有向图，求起点到每个点的最短路以及每个点到起点的最短路，并相加。
###### 对于起点到每个点的最短路，可以用裸的spfa求出；
###### 接下来思考每个点到起点的最短路：
###### 我们以下图为例![](https://cdn.luogu.com.cn/upload/pic/28249.png)
###### 上图中，从u到起点，路径为u->v->起点；而显然此路径等价于从起点->v->u;
###### 这里有人会问，题目中没有起点->v->u的路径啊！
###### 没有就自己连呗！
###### 于是我们不妨在建图时，同时建一个反向图；这样问题就可以简化为，在原图和反向图上分别跑一边spfa即可
###### 本题的数据范围是相当大的，但是我们可以发现两点：第一，用stl中的vector是可以存下图的；第二，直接跑spfa的话，如果出题人没有特意出卡spfa的数据，spfa在本题表现的相当优秀。
###### 小坑点：统计答案要用longlong。否则会炸。
###### 顺便吐槽一句，这个题的难度刷的好像有点高了，应该归到普及+/提高较为合适
###### 请勿抄袭，我在非关键代码处做了改动，抄袭会导致CE，但是spfa和建图保证没有问题，请放心食用~

下面是代码了，超级短~~（我会告诉你我压行了吗）~~
------------
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
const int maxn=1000005;
struct node
{
	int st,en,dist;
};
vector<node>v1[maxn];
vector<node>v2[maxn];
int dis[maxn],vis[maxn],m,n;
long long ans;
void add(int x,int y,int z)
{
	node xx,yy;
	xx.st=x;xx.en=y;xx.dist=z;
	v1[x].push_back(xx);
	yy.st=y;yy.en=x;yy.dist=z;
	v2[y].push_back(yy);
}
void spfa_one(int s)
{
	memset(dis,127,sizeof(dis));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(s);vis[s]=1;dis[s]=0;
	while(!q.empty()){
		int h=q.front();
		q.pop();vis[h]=0;
		for(int i=0;i<v1[h].size();i++)
		{
			node t=v1[h][i];
			if(dis[t.en]>dis[t.st]+t.dist){
				dis[t.en]=dis[t.st]+t.dist;
				if(!vis[t.en]){
					vis[t.en]=1;
					q.push(t.en);
				}
			}
		}
	}for(int i=1;i<=n;i++)ans+=dis[i];
}
void spfa_two(int s)
{
	memset(dis,127,sizeof(dis));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(s);vis[s]=1;dis[s]=0;
	while(!q.empty()){
		int h=q.front();
		q.pop();vis[h]=0;
		for(int i=0;i<v2[h].size();i++)
		{
			node t=v2[h][i];
			if(dis[t.en]>dis[t.st]+t.dist){
				dis[t.en]=dis[t.st]+t.dist;
				if(!vis[t.en]){
					vis[t.en]=1;
					q.push(t.en);
				}
			}
		}
	}for(int i=1;i<=n;i++)ans+=dis[i];
}
int mian()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	spfa_one(1);spfa_two(1);
	cout<<ans;
	return 0;
}
```

---

## 作者：王将飞扬Cliffly (赞：0)

说实话这题不就是P1629的数据加强版吗。。。

本想直接把那份代码交过来。。结果反正各种错误改了好久

可以说本质思路上还是一样的，正着一次SPFA再建反边来一次。

只是防MLE和TLE把那道题用的数组换成两个结构体再复制一个SPFA（反正那题我是这么写的。。。）

```cpp
#include<bits/stdc++.h>
#define R register
#define rep(i,j,n) for(R int i=j;i<=n;i++)
#define CLEAR(x) memset(x,0,sizeof(x))
#define per(i,j,n) for(int i=j;i>=n;i--)
using namespace std;
typedef long long ll;
inline int read() {
    int x;    char ch ;
    while(ch=getchar() , ch>'9'||ch<'0') ; x=ch-'0';
    while(ch=getchar() , ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0'; return x;
}
const int N=1000010;
int n,m,cnt1,cnt2,head1[N],head2[N],dis[N];
ll ans;    //一定记得开long long ，这里改了好多次。。。
queue<int> q; bool vis[N];
struct edge {
    int next,to,w;
}a[N],b[N];
inline void ins(int x,int y , int w) {  //直接把正向和反向边都插入好了
    cnt1++; a[cnt1]=edge{head1[x],y,w}; head1[x]=cnt1;
    cnt2++; b[cnt2]=edge{head2[y],x,w}; head2[y]=cnt2;  
}
inline ll spfa1() {
    CLEAR(vis) ; memset(dis,0x7f,sizeof(dis));  //记得初始化
    dis[s]=0; vis[s]=true;
    q.push(s) ; 
    while(!q.empty()) {
        int x=q.front() ; q.pop() ; vis[x]=false;
        for(int i=head1[x] ; i ;i=a[i].next){
            int v=a[i].to;
            if(dis[v]>dis[x]+a[i].w) {
                dis[v]=dis[x]+a[i].w;
                if(!vis[v]) {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    rep(i,2,n) ans+=dis[i];    //累积总和
}
inline int spfa2(int s, int t) {  //用反边再来一次
    CLEAR(vis) ; memset(dis,0x7f,sizeof(dis));
    dis[s]=0; vis[s]=true;
    q.push(s) ; 
    while(!q.empty()) {
        int x=q.front() ; q.pop() ; vis[x]=false;
        for(int i=head2[x] ; i ;i=b[i].next){
            int v=b[i].to;
            if(dis[v]>dis[x]+b[i].w) {
                dis[v]=dis[x]+b[i].w;
                if(!vis[v]) {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    rep(i,2,n) ans+=dis[i];
}
int main(){
    n=read() ; m=read() ; 
    int x,y,v; 
    rep(i,1,m) x=read() , y=read() , v=read() , ins(x,y,v);
    spfa1(1,n) ;
    spfa2(1,n) ;  //好吧这个自变量是没用的。。
    printf("%lld\n",ans);
    return 0;
}
```

---


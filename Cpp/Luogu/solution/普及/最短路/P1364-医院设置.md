# 医院设置

## 题目描述

设有一棵二叉树，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kawht13x.png)

其中，圈中的数字表示结点中居民的人口。圈边上数字表示结点编号，现在要求在某个结点上建立一个医院，使所有居民所走的路程之和为最小，同时约定，相邻接点之间的距离为 $1$。如上图中，若医院建在 $1$ 处，则距离和 $=4+12+2\times20+2\times40=136$；若医院建在 $3$ 处，则距离和 $=4\times2+13+20+40=81$。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$0 \leq u, v \leq n$，$1 \leq w \leq 10^5$。

## 样例 #1

### 输入

```
5						
13 2 3
4 0 0
12 4 5
20 0 0
40 0 0
```

### 输出

```
81```

# 题解

## 作者：Huami360 (赞：552)

现有的题解基本是用Floyed或者其他稍优的算法跑的，其时间复杂度均在$O(n^2)$以上。

那么问题来了，

**你们经历过绝望吗**

这题作为我们图论考试的一道题，n的范围直接到了10000，此时N^2的算法也无法AC。

有句写居里夫人的话：“**别人摸瓜她寻藤，别人摘叶他问根**”

我们也要做那个“她”， 不能只满足于通过此题，而且要了解本题的$O(N)$算法正解：带权树的重心。

### 树的重心的定义：
树若以某点为根，使得该树最大子树的结点数最小，那么这个点则为该树的重心，一棵树可能有多个重心。

### 树的重心的性质：
1、树上所有的点到树的重心的距离之和是最短的，如果有多个重心，那么总距离相等。

2、插入或删除一个点，树的重心的位置最多移动一个单位。

3、若添加一条边连接2棵树，那么新树的重心一定在原来两棵树的重心的路径上。

当然，这题我们只需要用到第一条性质。

### 怎么求树的重心：
定义几个数组：$f[u]$表示以u为根的总距离，$size[u]$表示以u为根的子树的大小（结点数，**此题每个点要乘以权值**，下文结点数均指此）。

显然，$ans=min(f[i],1<=i<=n)$

首先我们任意以一个点为根dfs一遍，求出以该点为根的总距离。方便起见，我们就以1为根。

接下来就是转移，对于每个u能达到的点v，有：
$$f[v]=f[u]+size[1]-size[v]-size[v]$$
怎么来的呢？试想，当根从u变为v的时候，v的子树的所有节点原本的距离要到$u$，现在只要到$v$了，每个结点的距离都减少1，那么总距离就减少$size[v]$，同时，以v为根的子树以外的所有节点，原本只要到$u$就行了，现在要到$v$，每个节点的路程都增加了1，总路程就增加了$size[1]-size[v]$，其中$size[1]$就是我们预处理出来的整棵树的大小，减去$size[v]$就是除以v为根的子树以外的结点数。

最后取最小值，得解。时间复杂度$O(n)$

附上代码：
```cpp
#include <cstdio>
#define rep(i, m, n) for(register int i = m; i <= n; ++i)
#define INF 2147483647
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
using namespace std;
inline int read(){
	int s = 0, w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') { if(ch == '-') w = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { s = s * 10 + ch - '0'; ch = getchar(); }
	return s * w;
}
const int MAXN = 10010;
struct Edge{
	int next, to;
}e[MAXN << 1];
int head[MAXN], num, w[MAXN], n, size[MAXN];
long long ans = INF, f[MAXN];
inline void Add(int from, int to){
	e[++num].to = to;
	e[num].next = head[from];
	head[from] = num;
}
void dfs(int u, int fa, int dep){ //预处理f[1]和size
    size[u] = w[u];
	for(int i = head[u]; i; i = e[i].next){
	   if(e[i].to != fa)
	     dfs(e[i].to, u, dep + 1), size[u] += size[e[i].to];
	}
	f[1] += w[u] * dep;
}
void dp(int u, int fa){  //转移
    for(int i = head[u]; i; i = e[i].next)
       if(e[i].to != fa)
         f[e[i].to] = f[u] + size[1] - size[e[i].to] * 2, dp(e[i].to, u);
    ans = min(ans, f[u]); //取最小值
}
int a, b;
int main(){
    //Open("hospital");
    ans *= ans;
    n = read();
    rep(i, 1, n){
       w[i] = read();
       a = read(); b = read();
       if(a) Add(i, a), Add(a, i);
       if(b) Add(i, b), Add(b, i);
    }
    dfs(1, 0, 0);
    dp(1, 0);
    printf("%lld\n", ans);
    //Close;
    return 0;
}

```

---

## 作者：ShineEternal (赞：165)

这是一道简单的二叉树应用问题，问题中的结点数并不多，数据规模也不大，采用邻接矩阵存储，用Floyed法求出任意两结点之间的最短路径长，然后穷举医院可能建立的n个结点位置，找出一个最小距离的位置即可。当然也可以用双链表结构或带父结点信息的数组存储结构来解决，但实际操作稍微麻烦了一点。
```
#include<cstdio>
using namespace std;
int a[101],g[101][101];
int main()
{
	int n,l,r,min,total;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			g[i][j]=1000000;
		}
	}
	for(int i=1;i<=n;i++)//读入、初始化
	{
		g[i][i]=0;
		scanf("%d%d%d",&a[i],&l,&r);
		if(l>0)g[i][l]=g[l][i]=1;
		if(r>0)g[i][r]=g[r][i]=1; 
	}
	for(int k=1;k<=n;k++)//用Floyed求任意两结点之间的最短路径
	{
		for(int i=1;i<=n;i++)
		{
			if(i!=k)
			{
				for(int j=1;j<=n;j++)
				{
					if(i!=j&&k!=j&&g[i][k]+g[k][j]<g[i][j])
						g[i][j]=g[i][k]+g[k][j];
				}
			}
		}
	}
	min=0x7fffffff;
	for(int i=1;i<=n;i++)//穷举医院建在N个结点，找出最短距离
	{
		total=0;
		for(int j=1;j<=n;j++)
			total+=g[i][j]*a[j];
		if(total<min)min=total;
	}
	printf("%d",min);
	return 0;
}
```
在各种竞赛中经常遇到这样的问题：N-1条公路连接着N个城市，从每个城市出发都可以通过公路到达其它任意的城市。每个城市里面都有一定数量的居民，但是数量并不一定相等，每条公路的长度也不一定相等。X公司（或者是政府）决定在某一个城市建立一个医院/酒厂/游乐场……，问：将它建在哪里，可以使得所有的居民移动到那里的总耗费最小？这种题目都是本题的“变型”，一般称为“树的中心点问题”。

**选自一本通，希望给大家提供精准的题解**

求过

---

## 作者：雪风舞者 (赞：68)

###第一次写题解好激动\(≧▽≦)/

好了不多说了

下面的题解区代码好多\_floyd\_的……

那我就写个别的好了O(∩\_∩)O~

###思路

用普通图的形式存储，

进行n遍bfs，然后每遍都进行答案的比较更新

###时间复杂度

由于bfs每遍都是O(V+E)的，而这里特殊之处在于本身是个树，所以是n个节点和n-1条边

所以总复杂度近似为O($n^2$)，完美解决

——————————————————————————朴实的分割线——————————————————————————————

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
bool g[105][105]={0};            //这里n小我就直接邻接矩阵了，如果用邻接表还能快点 
bool v[105]={0};
int n,num[105],ans=1<<30;
struct node{
    int u,step;
};
int bfs(int x){                    //bfs找当前点x为医院设置点时的总距离 
    memset(v,0,sizeof(v));
    queue<node> q;
    v[x]=1;
    q.push((node){x,0});
    int sum=0;
    while(!q.empty()){
        node now=q.front();
        q.pop();
        for(int i=1;i<=n;i++)
            if(g[now.u][i]&&!v[i]){
                node next={i,now.step+1};
                sum+=num[i]*next.step;
                v[i]=1;
                q.push(next);
            }
    }
    return sum;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int a,l,r;
        scanf("%d%d%d",&a,&l,&r);
        num[i]=a;
        if(l) g[i][l]=g[l][i]=1;
        if(r) g[i][r]=g[r][i]=1;
    }
    for(int i=1;i<=n;i++)
        ans=min(ans,bfs(i));
    printf("%d",ans);
    return 0;
}
```

---

## 作者：ღ﹏ﻬ北❦栀 (赞：50)

## 我这个蒟蒻第一次写题解好激动(≧▽≦)
（真心希望能通过，之前写过题解，不过因为排版问题没有通过）

好了，不多说了
题解区代码好多floyd，Dijkstra，spfa（他死了算法），还有用队列的，本蒟蒻不才只能用弗洛伊德加dp做...

## 下面附代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int q[101];
int w[101][101];//w[i][j]为第i个节点到第j个节点的距离
int main() {
	int n,i,j,k,l,r,min,total;
	cin>>n;
	for(i=1; i<=n; i++) //记得在一开始把数据初始化 
	{
		for(j=1; j<=n; j++) {
			w[i][j]=1000000;
		}
	}
	for(i=1; i<=n; i++) //开始读入数据并将数据初始化 
	{
		w[i][i]=0;
		cin>>q[i]>>l>>r;
		if(l>0) w[i][l]=w[l][i]=1;
		if(r>0) w[i][r]=w[r][i]=1;
	}
	for(k=1; k<=n; k++) //开始dp+弗洛伊德算法，至于为什么要用dp+上弗洛伊德，打开算法标签，有动态规划。并且动态规划能更好的找出最小距离和 
	{
		for(i=1; i<=n; i++) {
			if(i!=k) {
				for(j=1; j<=n; j++) {
					if(i!=j&&k!=j&&w[i][k]+w[k][j]<w[i][j])
						w[i][j]=w[i][k]+w[k][j];
				}
			}
		}
	}
	min=0x7fffffff;
	for(i=1; i<=n; i++)////穷举医院建在n个节点，找出最短距离。  
	 {
		total=0;//将初始数据清零 
		for(j=1; j<=n; j++) {
			total+=w[i][j]*q[j];
		}
		if(total<min) min=total;//如果有更小的值将那就将更小的值替换掉 
	}
	cout<<min<<endl;
	return 0;
}

```
希望大家喜欢！！！


---

## 作者：lizongru (赞：30)

- 看了一下题解几乎都是用的$O(n^3)$的$Floyd$或复杂度更优的SPFA的做法，然而这道题用$O(n)$的树形$dp$就可以做。
- 具体来说就是先一遍以$1$为树的根一遍$dfs$预处理出子树大小以及树的深度。然后算出将医院设在$1$上时的答案，再$O(1)$转移。
- 最终时间复杂度为$O(n)$
- 其实就是求树的重心，如果$n$再大一点就必须用这个方法做了。
- 下面贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x){
    char c=getchar();
    int p=1;
    x=0;
    while(!isdigit(c)){
        if(c=='-')p=-1;
        c=getchar();
    }
    while(isdigit(c)){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x*=p;
}//快读
const int maxn=1000;
int head[maxn],tot,n,deep[maxn],sz[maxn],pre[maxn],ans,dis[maxn];
struct edge{
    int to,next;
}e[maxn<<1];
inline void add(int u,int v){
    e[++tot].to=v;
    e[tot].next=head[u];
    head[u]=tot;
}
inline void dfs(int rt,int fa){
    deep[rt]=deep[fa]+1;
    for(register int i=head[rt];i;i=e[i].next){
        if(e[i].to==fa)continue;
        dfs(e[i].to,rt);
        pre[rt]+=pre[e[i].to];
    }
}//dfs预处理
inline void dp(int rt,int fa){
    for(register int i=head[rt];i;i=e[i].next){
        if(e[i].to==fa)continue;
        dis[e[i].to]=dis[rt]+pre[1]-pre[e[i].to]-pre[e[i].to];
        if(dis[e[i].to]<ans)ans=dis[e[i].to];
        dp(e[i].to,rt);
    }
}
int main(){
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    read(n);
    for(register int i=1;i<=n;++i){
        int a,b;
        read(sz[i]);read(a);read(b);
        pre[i]=sz[i];
        if(a){
            add(i,a);
            add(a,i);
        }
        if(b){
            add(i,b);
            add(b,i);
        }
    }
    deep[0]=0;
    dfs(1,0);
    for(register int i=1;i<=n;++i){
        dis[1]+=(deep[i]-1)*sz[i];
    }
    ans=dis[1];
    dp(1,0);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Invisible (赞：30)

这道题蒟蒻看来还是只会Floyed，但是三重for循环并不会超出限制，数据范围比较小嘛；

首先输入很简单，注意是双向图，所以dis[i][l]=dis[l][i]，同理dis[i][r]=dis[r][i];

然后就是最基本的三重for循环，只要注意重点(即k要放在最外面一层）就不会错了；

找到最短路后，按题意计算即可，不是很难；

下面附上代码，很简单，有点冗杂，请大佬指教

            
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define big 100000007
int p[101],dis[101][101],sum;
int n,l,r;
using namespace std;
int main()
{
    cin>>n;
    memset(dis,big,sizeof(dis));
    for(int i=1;i<=n;i++)
    {
        dis[i][i]=0;
        cin>>p[i];
        cin>>l>>r;
        if(l>=0) dis[i][l]=1;dis[l][i]=1;  //注意双向路
        if(r>=0) dis[i][r]=1;dis[r][i]=1;//同上
    }
    for(int k=1;k<=n;k++)
    {
        for(int i=1;i<=n;i++)
        {
            if(i!=k)
            {
                for(int j=1;j<=n;j++)
                {
                    if(i!=j&&k!=j&&dis[i][j]>dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j];//求最短路
                }
            }
        }
    }
    int minn=big;
    for(int i=1;i<=n;i++)
    {
        sum=0;
        for(int j=1;j<=n;j++)
        {
            if(i!=j&&dis[i][j]!=-1) sum+=p[j]*dis[i][j];  //注意i不等于j，根据题意计算
        }
        if(minn>sum) minn=sum;
    }
    cout<<minn<<endl;
    return 0;
}
```

---

## 作者：万弘 (赞：20)

以那暴力模拟向正解吊唁~~~

利用树的性质，任意一个点到另一个点的路径唯一确定，所以Floyed有些浪费了

于是我枚举每一个点，再花$O(n)$时间算出代价，去取最小代价

总时间复杂度$O(n^2)$常数不大

（为了方便，将父亲和儿子混为一谈（大雾），并开一个vis记录此次访问过的点（勿忘此次结束后memset0））

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
typedef long long ll;
const ll INF=1ll<<60;//很大的一个数
ll n,ans=INF,tmp;
bool vis[1001];
struct tree
{
	std::vector<ll>to;
	ll w;
}t[1001];
void start()
{
	scanf("%lld",&n);
	ll l,r;
	for(ll i=1;i<=n;++i)
	{
		scanf("%lld%lld%lld",&t[i].w,&l,&r);
		if(l)t[l].to.push_back(i),t[i].to.push_back(l);
		if(r)t[r].to.push_back(i),t[i].to.push_back(r);
	}
}
ll dfs(ll u,ll step)
{
	ll res=step*t[u].w;
	vis[u]=1;
	for(ll i=t[u].to.size()-1;i>=0;--i)
	{
		if(!vis[t[u].to[i]])res+=dfs(t[u].to[i],step+1);
	}
	return res;
}
int main()
{
	start();
	for(ll i=1;i<=n;++i)
	{
		memset(vis,0,sizeof(vis));
		tmp=dfs(i,0);
		if(tmp<ans)ans=tmp;
	}
	printf("%lld",ans);
	return 0;
}
```

还有不懂可以在评论区提出或私信我

---

## 作者：无羡qwq (赞：19)

/\*虽然用的算法可能和楼下差不多

但是觉得大神写的过程注释不够详细啊。。。。

作为一个小白表示一边看一边百度真是费尽心思。。。。。。

这里纯手打了一份新的FLOYED算法

注释比较详细

！！！！求管理员给过！！！！。。。。。。\*/

    
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
    int people[101];
    int dis[101][101];//大数组开外面
int main(){
    int n,l,r,total;   cin>>n;    //r右边的孩子 l是左边的孩子  n是结点个数
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            dis[i][j]=1000000;//这是一个很大的数  表示两个数之间不连接
        }
    }
    for(int i=1;i<=n;i++)
    {
        dis[i][i]=0;  //初始化
        cin>>people[i]>>l>>r;
        if(l>0)     dis[i][l]=dis[l][i]=1;
        if(r>0)     dis[i][r]=dis[r][i]=1;
    }
    //这里是输入   因为相邻两个点之间的距离为1
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            for(int k=1;k<=n;k++)
            {
                if(i!=j&&i!=k&&j!=k&&dis[i][j]+dis[j][k]<dis[i][k])//两点不重复   
                   dis[i][k]=dis[i][j]+dis[j][k];
            }
        }
    }
```
/\*这里是Floyed算法求两点之间的最短路径
因为数据比较小。。。。这个三个循环套一起的O(n的三次方)竟然也能过

这个算法是最简单的最短路径算法   负边权也适用

这里的算法表示如果三个点i j k

如果从i->k的路径长度大于（i->j）+（j->k）那么就替换成后者

\*/
    
     
```cpp
    int min=0x7fffffff;       //这是int 32的最大值 
    for(int i=1;i<=n;i++)
    {
        total=0;
        for(int j=1;j<=n;j++)
        {
            total+=dis[i][j]*people[j];
        }
        if(total<min)    min=total;      //找最短距离
     } 
    cout<<min<<endl;//输出————————大功告成！
    return 0;
}
```

---

## 作者：jklover (赞：15)

数据过水，100的n，即使是O（n\*n\*n）的Floyd也能暴力过。



```cpp
#include<bits/stdc++.h>
using namespace std;
int p[101],f[101][101],minn=99999999; //存储每个结点居民数，邻接矩阵与最优解
int main()
{
    for(int i=1;i<=100;i++)
        for(int j=1;j<=100;j++)
            if(i==j)
                f[i][j]=0;
            else
                f[i][j]=9999999;//初始化
    int n,a,b;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        {
            scanf("%d%d%d",&p[i],&a,&b);
            if(a)
                f[a][i]=f[i][a]=1;
            if(b)
                f[b][i]=f[i][b]=1;
```
}//读入
```cpp
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);//Floyd的核心，思路类似于松弛操作
    for(int i=1;i<=n;i++)
        {
            int s=0;
            for(int j=1;j<=n;j++)
                s+=f[i][j]*p[j];
            if(s<minn)
                minn=s;
        }            //模拟
    printf("%d",minn);
    return 0;
}

```

---

## 作者：汤嘉炜 (赞：9)

//本题解用非图论奥数方法推出，欢迎各位大佬点评

var f:array[0..100] of longint;

    g:array[1..100,1..3] of byte;//存图
    h:array[1..100] of word;//存人数
    q:array[1..100] of boolean;
    a,b,e,i,j,k,n:longint;
procedure sss(i,j,s:longint);//求j节点到i节点的权值（i：所求节点，j：遍历到的节点，s：距离，h[]：人数）

var k,l:longint;

begin

        if j=0 then exit;
       f[j]:=f[j]+h[i]*s;
       l:=s+1;
       q[j]:=false;//标记已遍历过节点，以下为遍历
       if (g[j,1]<>0) and q[g[j,1]] then sss(i,g[j,1],l);
       if (g[j,2]<>0) and q[g[j,2]] then sss(i,g[j,2],l);
       if (g[j,3]<>0) and q[g[j,3]] then sss(i,g[j,3],l);
end;

begin

        readln(n);
        for i:=1 to n do
        begin
                readln(h[i],a,b);
                if a<>0 then
                begin
                        g[i,1]:=a;//左子节点
                        g[a,3]:=i;//父节点
                end;
                if b<>0 then
                begin
                        g[i,2]:=b;//右子节点
                        g[b,3]:=i;//父节点
                end;
        end;
        for i:=1 to n do
        begin
                for j:=1 to n do q[j]:=true;
                sss(i,i,0);//计算每一个节点权值（其他节点人数*到本节点距离之和）

        end;
        e:=100000000;
        for i:=1 to n do
        begin
       if f[i]<e then e:=f[i];//找节点权值最小值
        end;
        writeln(e);
        
end.

---

## 作者：zht467 (赞：8)

正解应该是求带权树的重心（如果数据再大些的话。。）

每个节点的值都相当于它的size，我们通过dfs求出第一个以它为根的子树的size \* 2 >= 总size值的节点，那么这个节点就是树的重心。

然后再通过一边dfs求出答案。







```cpp
#include <cstdio>
#include <cstring>
#define MAXN 1001
using namespace std;
int n, cnt, tot, ans, sum;
int head[MAXN], next[MAXN], to[MAXN], val[MAXN], size[MAXN], dis[MAXN], f[MAXN];
inline void add(int x, int y)
{
    to[cnt] = y;
    next[cnt] = head[x];
    head[x] = cnt++;
}
inline void dfs(int u)
{
    int i, v;
    size[u] += val[u];
    for(i = head[u]; i != -1; i = next[i])
    {
        v = to[i];
        if(v != f[u])
        {
            f[v] = u;
            dfs(v);
            size[u] += size[v];
        }
    }
    if(2 * size[u] >= tot && !ans) ans = u;
}
inline void dfs1(int u)
{
    int i, v;
    sum += (dis[u] - 1) * val[u];
    for(i = head[u]; i != -1; i = next[i])
    {
        v = to[i];
        if(!dis[v])
        {
            dis[v] = dis[u] + 1;
            dfs1(v);
        }
    }
}
int main()
{
    int i, x, y;
    scanf("%d", &n);
    memset(head, -1, sizeof(head));
    for(i = 1; i <= n; i++)
    {
        scanf("%d %d %d", &val[i], &x, &y);
        if(x) add(i, x), add(x, i);
        if(y) add(i, y), add(y, i);
        tot += val[i];
    }
    dfs(1);
    dis[ans] = 1;
    dfs1(ans);
    printf("%d", sum);
    return 0;
}
```

---

## 作者：Joyce_Jiang (赞：7)

即使这道题数据很水，但是我们还是要用正解试试，树形dp，做法很简单，维护两个值，sum代表子树和，

dp【i】表示以i为根的子树，在i处建医院的消耗（注意只是i的子树），然后很容易可以推出一个方程dp[i]+=dp[j]+sum[j]；

最重要的就是我们第一次是默认1为根，然后我们可以用个换根函数进行根的替换和递推，不懂可以研究一下代码

右儿子纯属写完左儿子复制然后改了一下lr，所以看懂左边就好了


        
    
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
struct node
{
    int l,r;
}t[500];
int dp[200];
int f[200];
int sum[200];
int ans=0x7f7f7f;
void dfs(int i)
{
    sum[i]+=f[i];
    if(t[i].l)
    {
        dfs(t[i].l);
        sum[i]+=sum[t[i].l];
        dp[i]+=sum[t[i].l]+dp[t[i].l];
    }
    if(t[i].r)
    {
        dfs(t[i].r);
        sum[i]+=sum[t[i].r];
        dp[i]+=sum[t[i].r]+dp[t[i].r];
    }
}
void change(int i)
{
    if(t[i].l)
    {        
        int all=sum[i];
        int all1=sum[t[i].l];
        int all2=dp[i];
        int all3=dp[t[i].l];
        dp[i]=dp[i]-dp[t[i].l]-sum[t[i].l];
        sum[i]=all-sum[t[i].l];
        sum[t[i].l]=all;
        dp[t[i].l]=sum[i]+dp[t[i].l]+dp[i];
        ans=min(ans,dp[t[i].l]);
        change(t[i].l);
        sum[i]=all;
        sum[t[i].l]=all1;
        dp[i]=all2;
        dp[t[i].l]=all3;
    }
    if(t[i].r)
    {
        int all=sum[i];
        int all1=sum[t[i].r];
        int all2=dp[i];
        int all3=dp[t[i].r];
        dp[i]=dp[i]-dp[t[i].r]-sum[t[i].r];
        sum[i]=all-sum[t[i].r];
        sum[t[i].r]=all;
        dp[t[i].r]=sum[i]+dp[t[i].r]+dp[i];
        ans=min(ans,dp[t[i].r]);
        change(t[i].r);
        sum[i]=all;
        sum[t[i].r]=all1;
        dp[i]=all2;
        dp[t[i].r]=all3;
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        t[i].l=y;
        t[i].r=z;
        f[i]=x;
    }
    dfs(1);
    ans=min(ans,dp[1]);
    change(1);
    printf("%d",ans);
}
```

---

## 作者：Dvelpro (赞：6)

蒟蒻来贡献一份dfs  看大佬都用的Floyd 什么的 可是窝只会dfs xjb 暴力
```c
#include<bits/stdc++.h>
using namespace std;
vector<int>q[1001];
int dis[1001];
bool fa[1001];
int n;
int dfs(int x,int y){                 //x 父亲  y 代表距离
    int ans=0;
    for(int j=0;j<q[x].size();j++){
       if(!fa[q[x][j]]){
          fa[q[x][j]]=1;             // 下面就是递归找儿子路径还有就是 标记啦    
          ans+=dis[q[x][j]]*y;
          ans+=dfs(q[x][j],y+1);
       }
    }
    return ans;
}
int main(){
    cin>>n;
    for(int j=1;j<=n;j++){
       int x,y,z;
       cin>>x>>y>>z;
       if(y){                  //存父子关系 由于是无向图 注意下没有儿子的情况
          q[j].push_back(y);
          q[y].push_back(j);
       }
       if(z){
          q[j].push_back(z);
          q[z].push_back(j);
       }
       dis[j]=x;
    }
    int mi=999999999;
    for(int j=1;j<n;j++){          //枚举每个点的 
        memset(fa,0,sizeof(fa));
        fa[j]=1;
        mi=min(mi,dfs(j,1));
    }
    cout<<mi<<endl;
}

```

---

## 作者：JK_LOVER (赞：5)

看了标签有bfs，蒟蒻瞎想了一串代码，第一次交题解，望通过。
思路见代码
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n,sum=2<<19;//初始化 
bool pd[101];
struct node{
    int dist;//距离
    int ren;//人口
    int root;
    int l;
    int r;
}dian[100];
void bfs(int col)//这里用广搜 
{
    int ans=0;
    queue <node> q;
    dian[col].dist=0;
    q.push(dian[col]);
    while(!q.empty())//三个方向 
    {
    	//if(ans>sum) return ;这题不用剪枝也可以过 
        node now,next;
        now=q.front();
        q.pop();
        if(pd[now.l])
        {
            pd[now.l]=false;
            dian[now.l].dist=now.dist+1;
            next=dian[now.l];
            ans+=next.dist*next.ren;
            q.push(next);
        }
        if(pd[now.r])
        {
            pd[now.r]=false;
            dian[now.r].dist=now.dist+1;
            next=dian[now.r];
            ans+=next.dist*next.ren;
            q.push(next);
        }
        if(pd[now.root])
        {
            pd[now.root]=false;
            dian[now.root].dist=now.dist+1;
            next=dian[now.root];
            ans+=next.dist*next.ren;
            q.push(next);
        }
    }
    sum=min(ans,sum);//取值 
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>dian[i].ren>>dian[i].l>>dian[i].r;//左右儿子 
        dian[dian[i].l].root=i;//连通的 
        dian[dian[i].r].root=i;
    }
    for(int i=1;i<=n;i++)
    {
        memset(pd,true,sizeof(pd));
        pd[i]=false;//初始化 
        pd[0]=false;//一定要注意没有0点 
        bfs(i);
    }
    cout<<sum<<endl;//输出 
    return 0;
}
```


---

## 作者：Eric100911 (赞：5)

本人作为一个蒟蒻，并不能想到时间复杂度相对小的算法。考虑到要求树上距离，结合LCA打了一个$O(n^2logn)$偏暴力的办法。虽说复杂度偏大，但是并不难想：对所有设置位置进行枚举，在每一个位置用LCA计算总距离，并不断更新ans即可。
```cpp
#include<bits/stdc++.h>
#define MAXN 105
#define dis(x,y) (dep[x]+dep[y]-2*dep[LCA(x,y)])//树上距离计算式
using namespace std;
int H[MAXN],N,W[MAXN],lg[MAXN],dep[MAXN],fa[MAXN][10],tot;
struct edge{int v,nxt;} E[MAXN<<1];
void addedge(int x,int y){
	E[++tot].v=y;
	E[tot].nxt=H[x];
	H[x]=tot;
}
void lgCalc(){
	for(int i=1;i<=N;i++){
		lg[i]=lg[i-1]+((1<<lg[i-1])==i);
		lg[i-1]--;
	}
	lg[N]--;
}//以2为底预处理1~N对数表
void DFS(int cur,int anc){
	dep[cur]=dep[anc]+1;fa[cur][0]=anc;
	for(int i=1;i<=lg[dep[cur]];i++) fa[cur][i]=fa[fa[cur][i-1]][i-1];
	for(int i=H[cur];i;i=E[i].nxt){
		if(E[i].v==anc) continue;
		DFS(E[i].v,cur);
	}
}
int LCA(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y]) x=fa[x][lg[dep[x]-dep[y]]];
	if(x==y) return x;
	for(int i=9;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}//中规中矩的倍增LCA，不多做赘述，如需详解，移步P3379
int main(){
	cin>>N;
	int x,y,sum=0,ans=2147483647;
	for(int i=1;i<=N;i++){
		cin>>W[i]>>x>>y;
		if(x){
			addedge(i,x);
			addedge(x,i);
		}
		if(y){
			addedge(i,y);
			addedge(y,i);
		}//建双向边
	}
	lgCalc();DFS(1,0);
	for(int i=1;i<=N;i++){
		sum=0;
		for(int j=1;j<=N;j++) sum+=W[j]*dis(i,j);
		ans=min(ans,sum);
	}//超级无敌暴力的求解
	cout<<ans<<endl;//~~最令人舒心的一行~~
	return 0;
}
```

---

## 作者：caramel_qwq (赞：5)

~~小声地吐槽一下。题解区很多大佬都说很多人都写了 dijkstra 的解，但蒟蒻翻了一下，好像没人写捏。~~

------------
### 题目分析
$n$ 的范围不大（$100$ 以内），可以考虑裸暴力，这里蒟蒻写的是堆优化的 dijkstra，运行完速度还算快，半秒不到。dijkstra 算法是一种单源最短路算法，采用松弛操作求出最短路。

补充：

- 这道题除了很多人写的 Floyd 和~~还没完全死透的~~ SPFA，也可以写写朴素的 dfs 或 bfs。
- [关于 dijkstra 的介绍](https://oiwiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95)

------------
### 关于 dijkstra 的坑点
1. 每一步增加的距离是固定的，就是起点的人数。
1. 起点和终点都不固定，注意每一次跑 dijkstra 的时候起点终点别传错。

分析一下此题代码的时间复杂度，堆优化后的 dijkstra 时间复杂度是 $O(n\log n)$ 同时在 dijkstra 外还套了两层循环，所以整体是 $O(n^3\log n)$，这道题数据范围不大，暴力一点也没关系。

------------
### 无毒代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
const int MAXN=208;
const int awa=2147483647;
int n,k[MAXN];
int dis[MAXN],ans=INT_MAX;
struct node{
    int to,nxt;
}a[MAXN];
bool vis[MAXN];
int head[MAXN],tot=0;
void add(int u,int v){
    a[++tot].to=v;
    a[tot].nxt=head[u];
    head[u]=tot;
    return ;
}
int dijkstra(int st,int ed){
    priority_queue< pii,vector<pii>,greater<pii> > q;
    for(int i=1;i<=n;i++) dis[i]=awa;
    memset(vis,0,sizeof(vis));
    dis[st]=0;
    q.push(make_pair(0,st));
    while(!q.empty()){
		int x=q.top().second;
		q.pop();
		if(vis[x]==true) continue;
		vis[x]=true;
		for(int i=head[x];i!=0;i=a[i].nxt){
			int y=a[i].to,z=k[st];
			dis[y]=min(dis[y],dis[x]+z);
			q.push(make_pair(dis[y],y));
		}
	}
    return dis[ed];
}
void choose(int thi){
	int nowcnt=0;
	for(int i=1;i<=n;i++){
		if(i==thi) continue;
		nowcnt+=dijkstra(i,thi);
	}
	ans=min(ans,nowcnt);
	return ;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int l,r;
        scanf("%d%d%d",&k[i],&l,&r);
        if(l!=0) add(i,l),add(l,i);
        if(r!=0) add(i,r),add(r,i);
    }
    for(int i=1;i<=n;i++) choose(i);
    printf("%d\n",ans);
    return 0;
}
```
你要抄就抄，反正洛谷查得出来的。

---

## 作者：zhengrunzhe (赞：4)

翻了一遍题解区，并没有用树剖求lca的

树上两点(x,y)距离公式(边权为1)

### dis(x,y)=dep(x)+dep(y)-2dep(lca)

预处理出所有点对的距离(求答案的时候算也一样)O(n^2 log n)

然后枚举医院放置的点，求其他点到它的答案(n^2)
```cpp
#include<cstdio>
#include<climits>
#include<utility>
#include<algorithm>
using std::min;
using std::pair;
using std::make_pair;
const int N=110;
int n,dep[N],w[N],top[N],size[N],wson[N],fa[N],dis[N][N],head[N],cnt,ans=INT_MAX;
pair<int,int>e[N<<1];
inline void add(int a,int b)
{
	e[++cnt]=make_pair(b,head[a]);
	head[a]=cnt;
}
inline void dfs(int p)
{
	size[p]=1;
	for (int i=head[p];i;i=e[i].second)
	{
		int son=e[i].first;
		if (son==fa[p])continue;
		fa[son]=p;dep[son]=dep[p]+1;
		dfs(son);size[p]+=size[son];
		if (size[son]>size[wson[p]])wson[p]=son;
	}
}
inline void dfs(int p,int tp)
{
	top[p]=tp;
	if (wson[p])dfs(wson[p],tp);
	for (int son,i=head[p];i;i=e[i].second)
		if ((son=e[i].first)!=fa[p]&&son!=wson[p])
			dfs(son,son);
}
inline int getlca(int a,int b)
{
	while (top[a]!=top[b])
		dep[top[a]]>dep[top[b]]
		?a=fa[top[a]]:b=fa[top[b]];
	return dep[a]<dep[b]?a:b;
}
inline int distance(int a,int b) //算树上距离
{
	return dep[a]+dep[b]-(dep[getlca(a,b)]<<1);
}
inline void getdis()
{
	for (int i=1;i<n;i++)
		for (int j=i+1;j<=n;j++)
			dis[j][i]=dis[i][j]=distance(i,j);
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		int lson,rson;
		scanf("%d%d%d",&w[i],&lson,&rson);
		if (lson)add(i,lson),add(lson,i); //改成邻接表存图比较方便
		if (rson)add(i,rson),add(rson,i);
	}
	dfs(1);dfs(1,1);getdis();
	for (int i=1;i<=n;i++)
	{
		int nowans=0;
		for (int j=1;j<=n;j++)
			if (i!=j)nowans+=dis[i][j]*w[j];
		ans=min(ans,nowans);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：henry_y (赞：4)

简单题啊...

树的重心或者爆搜都行

然后爆搜实际效率吊打树的重心（雾）

二叉树储存太麻烦了，储存成图那样子

## 爆搜做法

这题题意就是求在树上找一个点其他点到它的距离最小

那么我们按题意爆搜就好了

让这个点为根

然后就分出来一个三叉树，随便搜一下三条分支统计答案就ok

```cpp
#include <bits/stdc++.h>

#define ll long long
#define inf 0x3f3f3f3f 
#define il inline 

#define in(a) a=read()
#define out(a) printf( "%d" , a ) 
#define outn(a) out(a),putchar('\n')

#define I_int int 
inline I_int read() {
    
    I_int x = 0 , f = 1 ; char c = getchar() ;
    while( c < '0' || c > '9' ) {
        if( c == '-' ) f = -1 ;
        c = getchar() ;
    }
    while( c >= '0' && c <= '9' ) {
        x = (x << 1) + (x << 3) + c - 48 ;
        c = getchar() ;
    }
    return x * f ;
}
#undef I_int

using namespace std ;

#define N 100010

int n , m , c[ N ] , fa[ N ] ;
int head[ N ] , cnt ;
struct node {
    int to , nxt ;
} e[ N ] ;

void ins( int u , int v ) {
    e[ ++ cnt ].to = v ;
    e[ cnt ].nxt = head[ u ] ;
    head[ u ] = cnt ;
}

int dfs( int u , int f , int dep ) {
    int ans = dep * c[ u ] ;
    for( int i = head[ u ] ; i ; i = e[ i ].nxt ) {
        if( e[ i ].to == f ) continue ;
        ans += dfs( e[ i ].to , u , dep + 1 ) ;
    }	
    return ans ;
}

int main() {
    int ans = inf ;
    in( n ) ;
    for(int i = 1 ; i <= n ; i ++ ) {
    	in( c[ i ] ) ;
    	int v ;
    	in( v ) ;
    	if( v ) { ins( i , v ) ; ins( v , i ) ; fa[ v ] = i ; }
    	in( v ) ;
    	if( v ) { ins( i , v ) ; ins( v , i ) ; fa[ v ] = i ; }
    }
    for( int i = 1 ; i <= n ; i ++ ) {
        ans = min( ans , dfs( i , fa[ i ] , 0 ) + dfs( fa[ i ] , i , 1 ) ) ;
    }
    outn( ans ) ;
}
```

爆搜复杂度是$O(n^2)$的..

## 树的重心做法

树的重心板子，处理出深度和子树数目，那么再搜一遍统计答案就可以了

```cpp
#include <bits/stdc++.h>

#define ll long long
#define inf 0x3f3f3f3f 
#define il inline 

#define in(a) a=read()
#define out(a) printf( "%d" , a ) 
#define outn(a) out(a),putchar('\n')

#define I_int int 
inline I_int read() {
    
    I_int x = 0 , f = 1 ; char c = getchar() ;
    while( c < '0' || c > '9' ) {
        if( c == '-' ) f = -1 ;
        c = getchar() ;
    }
    while( c >= '0' && c <= '9' ) {
        x = (x << 1) + (x << 3) + c - 48 ;
        c = getchar() ;
    }
    return x * f ;
}
#undef I_int

using namespace std ;

#define N 100010

int siz[ N ] , dep[ N ] , f[ N ] ;
int n , m , c[ N ] , fa[ N ] ;
int head[ N ] , cnt , ans = inf ;
struct node {
	int to , nxt ;
} e[ N ] ;

void ins( int u , int v ) {
	e[ ++ cnt ].to = v ;
	e[ cnt ].nxt = head[ u ] ;
	head[ u ] = cnt ;
}

void dfs( int u ) {
	siz[ u ] = c[ u ] ;
	for( int i = head[ u ] ; i ; i = e[ i ].nxt ) {
		if( e[ i ].to == fa[ u ] ) continue ;
		dep[ e[ i ].to ] = dep[ u ] + 1 ;
		dfs( e[ i ].to ) ;
		siz[ u ] += siz[ e[ i ].to ] ;
	}
	f[ 1 ] += c[ u ] * dep[ u ] ;
}

void dp( int u ) {
	for( int i = head[ u ] ; i ; i = e[ i ].nxt ) {
		if( e[ i ].to == fa[ u ] ) continue ;
		f[ e[ i ].to ] = f[ u ] + siz[ 1 ] - 2 * siz[ e[ i ].to ] ;
		dp( e[ i ].to ) ;
	}
	ans = min( ans , f[ u ] ) ;		
}

int main() {
    in( n ) ;
    for(int i = 1 ; i <= n ; i ++ ) {
    	in( c[ i ] ) ;
    	int v ;
    	in( v ) ;
    	if( v ) { ins( i , v ) ; ins( v , i ) ; fa[ v ] = i ; }
    	in( v ) ;
    	if( v ) { ins( i , v ) ; ins( v , i ) ; fa[ v ] = i ; }
	}
	dfs( 1 ) ; dp( 1 ) ;
	outn( ans ) ;
}
```

---

## 作者：fry404006308 (赞：4)

1、暴力

医院建的位置就是root点

数据结构是一个双向图

代价=步长\*人数

时间复杂度：O（n\*n）








```cpp
#include <bits/stdc++.h>
const int N=1e2+10;
const int INFINITE=1<<30;
using namespace std;
vector<int> vct[N];
int val[N],n,ans=INFINITE;
bool vis[N];
void init(){
    cin>>n;
    int w,l,r;
    for(int i=1;i<=n;i++){
        cin>>w>>l>>r;
        val[i]=w;
        if(l){
            vct[i].push_back(l);
            vct[l].push_back(i);
        }
        if(r){
            vct[i].push_back(r);
            vct[r].push_back(i);
        }
    }
}
int find(int r,int step){
    if(vis[r]) return 0;
    vis[r]=true;
    int ans=val[r]*step;
    for(int i=0;i<vct[r].size();i++){
        int v=vct[r][i];
        ans+=find(v,step+1);
    }
    return ans;
}
void search(){
    for(int i=1;i<=n;i++){
        memset(vis,false,sizeof(vis));
        int tmp=find(i,0);
        if(tmp<ans) ans=tmp; 
    }
} 
int main(){
    //freopen("in.txt","r",stdin);
    init();
    search();
    cout<<ans<<endl;
    return 0;
} 
```
2、最短路解法
spfa解法

求出医院的那个点到其它点的距离

时间复杂度：O（n\*2e+n\*n） e大概等于2n

只列出了最短路里面的一种解法，当然也可以用其它最短路来做









```cpp
#include <bits/stdc++.h>
const int N=1e2+10;
const int INFINITE=1<<30;
using namespace std;
vector<int> vct[N];
int val[N],n,ans=INFINITE;
bool vis[N];
void init(){
    cin>>n;
    int w,l,r;
    for(int i=1;i<=n;i++){
        cin>>w>>l>>r;
        val[i]=w;
        if(l){
            vct[i].push_back(l);
            vct[l].push_back(i);
        }
        if(r){
            vct[i].push_back(r);
            vct[r].push_back(i);
        }
    }
}
int find(int r,int step){
    if(vis[r]) return 0;
    vis[r]=true;
    int ans=val[r]*step;
    for(int i=0;i<vct[r].size();i++){
        int v=vct[r][i];
        ans+=find(v,step+1);
    }
    return ans;
}
void search(){
    for(int i=1;i<=n;i++){
        memset(vis,false,sizeof(vis));
        int tmp=find(i,0);
        if(tmp<ans) ans=tmp; 
    }
} 
int main(){
    //freopen("in.txt","r",stdin);
    init();
    search();
    cout<<ans<<endl;
    return 0;
} 
```
3、树形dp解法
dp[i]表示以i为根的子树的最优值。

v是i的孩子

dp[i] =dp[v]+i的孩子和

时间复杂度：O（n\*n）







```cpp
#include <bits/stdc++.h>
const int N=1e2+10;
const int INFINITE=1<<30;
using namespace std;
vector<int> vct[N];
int val[N],n,ans=INFINITE,dp[N];
bool vis[N];
void init(){
    cin>>n;
    int w,l,r;
    for(int i=1;i<=n;i++){
        cin>>w>>l>>r;
        val[i]=w;
        if(l){
            vct[i].push_back(l);
            vct[l].push_back(i);
        }
        if(r){
            vct[i].push_back(r);
            vct[r].push_back(i);
        }
    }
}
int dfs(int r){
    if(vis[r]) return 0;
    vis[r]=true;
    int sum=0;
    for(int i=0;i<vct[r].size();i++){
        int v=vct[r][i];
        if(!vis[v]){
            sum+=(val[v]+dfs(v)); 
            dp[r]+=dp[v];
        } 
    }
    dp[r]+=sum;
    return sum;
}
void search(){
    for(int i=1;i<=n;i++){
        memset(vis,false,sizeof(vis));
        memset(dp,0,sizeof(dp));
        dfs(i);
        if(dp[i]<ans) ans=dp[i]; 
    }
} 
int main(){
    //freopen("in.txt","r",stdin);
    init();
    search();
    cout<<ans<<endl;
    return 0;
} 

```

---

## 作者：huang_yue (赞：3)

注意到本题的n非常小，所以可以直接暴力求解。对于每个点使用dfs求出距离总和，取最小值即可。

作为一个压行压惯了的人，献上一份我丑陋的代码：
```
#include<iostream>
#include<algorithm>
#include<cstring> //这个特别容易掉
using namespace std;

//w数组是每个点的人数，ls[i]与rs[i]分别代表节点i的左儿子和右儿子，fa[i]代表节点i的父亲，vis[i]代表在dfs中点i是否访问过
int w[110], ls[110], rs[110], fa[110];
bool vis[110];

int dist(int i, int mul =0) {
	if (vis[i]) return 0;
	vis[i] = ++mul; //这里++mul > 0，所以vis[i]=true
	return i ? (!vis[ls[i]] * w[ls[i]] + !vis[rs[i]] * w[rs[i]] + !vis[fa[i]] * w[fa[i]]) * mul + dist(ls[i], mul) + dist(rs[i], mul) + dist(fa[i], mul) : 0;
/*
    
这个复杂的表达式可以拆成几个部分：

return i ? ... : 0 ：当i==0时，也就是一个节点没有左儿子/右儿子/父亲时，显然应该返回0，而且不再继续递归。

... + dist(ls[i], mul) + dist(rs[i], mul) + dist(fa[i], mul)：递归计算出左右儿子与父亲的总距离，并累加。

剩下的用乘法分配律拆开，取一部分，其余同理：!vis[ls[i]] * w[ls[i]] * mul
当左儿子已经访问过(也就是!vis[ls[i]] == 0)的时候，就不必再计算本节点到左儿子的距离了；否则!vis[ls[i]] == 1，乘上也不会有任何影响。而w[ls[i]] * mul也就是左儿子的人口乘上到原来调用这个函数的节点的距离，这个距离在参数传递之中累加。
*/
}

int main() {
	int n, ans = 2147483647; cin >> n;
	for (int i = 1; i <= n; ++i) //读入
		cin >> w[i] >> ls[i] >> rs[i], fa[ls[i]] = fa[rs[i]] = i;
	for (int i = 1; i <= n; ++i) //记得清空vis数组
		memset(vis, 0, sizeof(vis)), ans = min(ans, dist(i));
	cout << ans << endl;
	return 0;
}
```


---

## 作者：jiangzhiou (赞：3)

这道题数据不大，暴力能过，这里提供一种简单的优化方法，（虽然并没有优化到哪里去）其中融入了优先队列与结构体，能理解的话这题就很简单了。

其实大体思路就是算出每个点到指定点的对应最短距离，乘上点的居民人数，相加，取最小。


代码如下：

    
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
using namespace std;
struct sd{
    int num,d;
    bool operator < (const sd &x) const //重载预算符
    {
        return x.d<d;
    }
};
vector<sd>mp[100005];
priority_queue<sd>hhh;//从大到小的队列
int dist[100005];
bool vis[100005];
int x[1005];
int main()
{
    int m,n;
    scanf("%d",&m);
    sd w;
    for(int a,b,c,i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        x[i]=a;//记录居民数
        if(b!=0)
        {
            w.num=b;w.d=1;mp[i].push_back(w);// 表示 i 到b的距离为d
            w.num=i;mp[b].push_back(w);
        }
        if(c!=0)
        {
            w.num=c;w.d=1;mp[i].push_back(w);
            w.num=i;mp[c].push_back(w);
        }
    }
    int ans=0,min=0xfffffff;
    for(int l=1;l<=m;l++)
    {
        int v=hhh.size();
        while(v)
        {
            v--;
            hhh.pop();
        }
        memset(dist,127,sizeof(dist));
        memset(vis,false,sizeof(vis));
        ans=0;
        vis[l]=true;
        for(int j=mp[l].size()-1;j>=0;j--)
        {
            if(dist[mp[l][j].num]>mp[l][j].d)
            {
                dist[mp[l][j].num]=mp[l][j].d;
            }
            hhh.push(mp[l][j]);
        }
        for(int i=1;i<m;i++)
        {
            int k;
            while(true)
            {
                int k=hhh.size();
                if(k==0) break;
                w=hhh.top();
                hhh.pop();
                if(!vis[w.num]) break;
            }
            if(k==0) break;
            k=w.num;
            vis[k]=true;
            for(int j=mp[k].size()-1;j>=0;j--)
            {
                int t=mp[k][j].num;
                if(!vis[t]&&mp[k][j].d+dist[k]<dist[t])
                {
                    dist[t]=mp[k][j].d+dist[k];
                    w.num=t;
                    w.d=dist[t];
                    hhh.push(w);
                }
            }
        }
        for(int i=1;i<=m;i++)//算出居民需要移动的距离总数
        {
            if(i!=l)
            {
                ans+=(dist[i]*x[i]);
            }
        }
        if(min>ans) min=ans;//取最小值
    }
    printf("%d",min);
    return 0;
}
```

---

## 作者：Drinkwater (赞：2)

楼下的floyed是不是复杂度太高了，我有两个想法，第一个用O(n)的时间预处理出每两个点在树上的距离，然后O(n)跑一遍？

我实际做法是第二种，O(n^2)的，0ms，直接枚举每个点然后O(n)遍历就好了










```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
#define REP(i,a,b) for(register int i = (a), i##_end_ = (b); i <= i##_end_; ++i)
typedef long long ll;
inline int read()
{
    char c = getchar();register int fg = 1, sum = 0;
    while(c < '0' || c > '9')
    {
        if(c == '-')fg = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9')
    {
        sum = sum * 10 + c - '0';
        c = getchar();
    }
    return fg * sum;
}
const int inf = 0x3f3f3f3f;
const int maxn = 1010;
int n,w[maxn];
int be[maxn],ne[maxn],to[maxn],e;
void add(int x,int y)
{
    to[++e] = y;
    ne[e] = be[x];
    be[x] = e;
}
int vis[maxn],sum = 0,ans = inf;
void dfs(int x,int d)
{
    vis[x] = 1;
    for(int i = be[x]; i; i = ne[i])
    {
        int v = to[i];
        if(!vis[v])
        {
            sum += (d+1) * w[v];
            dfs(v,d+1);
        }
    }
}
int main()
{
    n = read();
    REP(i,1,n)
    {
        w[i] = read();int l = read(),r = read();
        if(l)add(i,l),add(l,i);
        if(r)add(i,r),add(r,i);
    }
    REP(i,1,n)
    {
        memset(vis,0,sizeof(vis));
        sum = 0;
        dfs(i,0);
        ans = min(ans,sum);
    }
    printf("%d\n",ans);
}

```

---

## 作者：doby (赞：2)

这题很水……

可以使用Floyd直接解决……

其实左右链接就相当于在图中连出两条无向边……

```cpp
#include<cstdio>
using namespace std;
int n,x,y,a[109],g[109][109],t,m=233333333,out,fh;
char cc;
int read()//依然没有什么卵用的读入优化……
{
    out=0,fh=1,cc=getchar();
    if(cc=='-'){fh=-1;}
    while(cc>'9'||cc<'0'){cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
int min(int a,int b)//更无卵用的手写min……
{
    if(a<b){return a;}
    else{return b;}
}
int main()
{
    n=read();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            g[i][j]=23333;//初始化，保证没连上的不可能成为最优解……
        }
    } 
    for(int i=1;i<=n;i++)
    {
        a[i]=read(),x=read(),y=read();//读入
        if(x){g[i][x]=1,g[x][i]=1;}//链接x与i
        if(y){g[i][y]=1,g[y][i]=1;}//链接y与i
    }
    for(int k=1;k<=n;k++)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            { 
                if((i!=k)&&(i!=j)&&(j!=k))
                {
                    g[i][j]=min(g[i][j],g[i][k]+g[k][j]);//Floyd……
                } 
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        t=0;
        for(int j=1;j<=n;j++)
        {
            if(i!=j){t=t+g[i][j]*a[j];}//按题意模拟……
        }
        m=min(m,t);//不停地找最优解……
    }
    printf("%d",m);
}
```

---

## 作者：chaijing (赞：2)

这是一道简单的二叉树应用问题，问题中的结点数并不多，数据规模也不大，采用邻接矩阵存储，用Floyed法求出任意两结点之间的最短路径长，然后穷举医院可能建立的n个结点位置，找出一个最小距离的位置即可。当然也可以用双链表结构或带父结点信息的数组存储结构来解决，但实际操作稍微麻烦了一点。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[101],g[101][101];
int main()
{
    int n,i,j,k,l,r;
    scanf("%d",&n);
    memset(g,1,sizeof g);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d%d",&a[i],&l,&r);
        if(l>0) g[i][l]=g[l][i]=1;
        if(r>0) g[i][r]=g[r][i]=1;
        g[i][i]=0;
    }
    for(k=1;k<=n;k++)   //利用floyed算法求两点间最短距离 
      for(i=1;i<=n;i++)
        if(i!=k)
          for(j=1;j<=n;j++)
            if(i!=j&&j!=k)
              g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
    int mixn=99999999,tot;
    for(i=1;i<=n;i++)        //穷举医院建在第i个结点，找出最短距离
    {
        tot=0;
        for(j=1;j<=n;j++)
          tot+=g[i][j]*a[j];
        mixn=min(mixn,tot);
    }
    printf("%d\n",mixn);
    return 0;
}
```

---

## 作者：依依 (赞：2)

解：

此题暴力枚举在哪个点设置医院，然后以那个点为根进行DFS即可，

复杂度O(n^2)

也可以用树形DP来写，复杂度O(n)

ok[i]表示以i为根的最优答案，首先我们预处理出ok[1]

sz[i]表示i这棵子树的大小（节点数目之和）

对于( u -> v ) 已知ok[u]

我们只需要减去sz[v],加上除了sz[v]以外的节点数目

即ok[v]=ok[u]-sz[v]+sz[1]-sz[v]=ok[u]+sz[1]-2*sz[v]

得解。


[详见博客啦](http://www.cnblogs.com/adelalove/p/8848791.html)

---

## 作者：yz0414 (赞：1)

这题思路就是先读入，对左边和右边预处理，再跑一遍佛洛依德，求出最短路径，最后一个一个点枚举，保存最便宜的，输出。

祝大家AC愉快，一定听懂了吧，嘻嘻

代码：

```pascal
var f:array[0..101,0..101]of longint;
    v:array[0..101]of longint;
    n,i,j,k,x,y,max,s:longint;
begin
   readln(n);
   fillchar(f,sizeof(f),63);
   for i:=1 to n do f[i,i]:=0;
   for i:=1 to n do
     begin
        readln(v[i],x,y);
        if x<>0 then begin f[i,x]:=1;f[x,i]:=1; end;
        if y<>0 then begin f[i,y]:=1;f[y,i]:=1; end;
     end;
   for k:=1 to n do
     for i:=1 to n do
       for j:=1 to n do
         if f[i,k]+f[k,j]<f[i,j] then
          f[i,j]:=f[i,k]+f[k,j];
   max:=maxlongint;
   for i:=1 to n do
     begin
        s:=0;
        for j:=1 to n do
          s:=s+f[i,j]*v[j];
        if s<max then max:=s;
     end;
   writeln(max);
end.
```


---

## 作者：睿屿青衫 (赞：1)

#貌似没有spfa？我来贴一发

##注意是双向边，我最开始看错了，打了个当左右节点都不为0时建边，炸了，左右判断

###我的40分找出了错误，minn初始化不要0x7f，太小！多跟几个fff

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 11000
using namespace std;
int head[maxn],team[maxn],exist[maxn],dis[maxn],minn=0x7ffff;
int n,sum,p[maxn];
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         x=x*10+ch-'0';
         ch=getchar();
     }
    return x;
}
struct EDGE
{
    int next;
    int to;
    int co;
}edge[maxn*3];
int qr;
void add(int from,int to,int co)
{
    edge[++qr].next=head[from];
    edge[qr].to=to;
    edge[qr].co=co;
    head[from]=qr;
}
void spfa(int x)
{
    memset(dis,0x7f,sizeof(dis));
    memset(exist,0,sizeof(exist));
    int h=0,t=1;
    dis[x]=0;exist[x]=1;team[1]=x;
    while(h<t)
    {
        h++;
        int u=team[h];exist[u]=0;
        for(int i=head[u];i!=0;i=edge[i].next)
         {
             int v=edge[i].to;
             if(dis[v]>dis[u]+edge[i].co)
              {
                  dis[v]=dis[u]+edge[i].co;
                  if(!exist[v])
                   {
                       exist[v]=1;
                       t++;
                       team[t]=v;
                   }
              }
         }
    }
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
     {
         int l,r;
         p[i]=read();
         l=read();r=read();
         if(l!=0) add(i,l,1),add(l,i,1);
         if(r!=0) add(i,r,1),add(r,i,1);
     }
    for(int i=1;i<=n;++i)
     {
         spfa(i);sum=0;
         for(int j=1;j<=n;++j)
          {
//              printf("***%d\n",dis[j]*p[j]);
              sum+=dis[j]*p[j];
          }
        minn=min(minn,sum);
     }
    printf("%d",minn);
    return 0;
}
```

---

## 作者：OrangeDog (赞：1)

这道题是真的水，我本来只是想打个搜索看看，结果就过了。看了看题解，发现没人打过搜索。。。

主要思想就是先建一个无向图，然后从每个点出发，遍历一遍，求出每个点的深度，再乘上这个点的值（真的只是暴力），找出最小的；

下面是代码；



```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 500
using namespace std;
int n,dis[maxn],sum,ans=0x7f7f7f7f;
struct node
{
    int next,to;
}edge[maxn];
int head[maxn],k=0;
inline void add(int x,int y)
{
    edge[++k].to=y;
    edge[k].next=head[x];
    head[x]=k;
} 
int di[maxn];
int dfs(int x,int fa)
{
    for(int i=head[x];i;i=edge[i].next)
    {
        if(edge[i].to!=fa)
        {
            int v=edge[i].to;
            di[v]=di[x]+1;
            sum+=di[v]*dis[v];
            dfs(v,x);
        }
    }
}
int main()
{
//    freopen("s.txt","r",stdin);
    scanf("%d",&n);
    for(int y,z,i=1;i<=n;i++)
    {
        scanf("%d%d%d",&dis[i],&y,&z);
        if(y)
        {
            add(i,y);
            add(y,i);
        }
        if(z)
        {
            add(i,z);
            add(z,i);
        }
```
}//无向图

```cpp
    for(int i=1;i<=n;i++)
    {        
        sum=0;
        memset(di,0,sizeof(di));
        dfs(i,i);
        ans=min(ans,sum);
```
}//遍历

    printf("%d",ans);

    return 0;

}
这代码还是自己打吧，不要抄；


---

## 作者：xukuan (赞：1)

图论之最短路之Floyd

先用Floyd求出两点之间的最短距离，再依次枚举在每个点设医院人要走的距离

请注意：这是一个无向图，所以要将两边都赋成可以通过

当然也可以考虑Dijskla或SPFA，在此不做多述



```pascal
uses math;

var
 i,j,y,z,n,minn,ans:longint;
 b:array[0..110] of longint;
//b[i]代表每一个点的人数
 a:array[0..110,0..110] of int64;
//a[i,j]代表从i到j的最短距离

procedure floyd;//弗洛伊德
 var
  i,j,k:longint;
 begin
  for k:=1 to n do
   for i:=1 to n do
    for j:=1 to n do
     a[i,j]:=min(a[i,j],a[i,k]+a[k,j]);
end;

begin
 readln(n);
 for i:=1 to n do
  for j:=1 to n do
   if i<>j then a[i,j]:=maxlongint;//别忘了赋初值！
 for i:=1 to n do
  begin
   readln(b[i],y,z);
   if y<>0 then//左边有路
    begin
     a[i,y]:=1;
     a[y,i]:=1;
    end;
   if z<>0 then//右边有路
    begin
     a[i,z]:=1;
     a[z,i]:=1;
    end;
  end;

 floyd;

 minn:=maxlongint;
 for i:=1 to n do//穷举设医院的点
  begin
   ans:=0;
   for j:=1 to n do//穷举每个点的居民
    inc(ans,a[i,j]*b[j]);//居民要走的路的和
   minn:=min(minn,ans);//取较小值
  end;
 writeln(minn);
end.
```

附测评结果：

#1 AC 0ms/4855KB

#2 AC 0ms/4855KB

#3 AC 0ms/4855KB

#4 AC 0ms/4855KB

#5 AC 4ms/4855KB


---

## 作者：汇文客 (赞：1)

这道题数据很水，先建二叉树，再将各点逐一BFS，最后取最小答案。

```delphi

var bt:array[0..100,0..3]of longint;
    v:array[1..100]of boolean;
    q:array[0..10010,1..2]of longint;
    a,b,n,i,j,l,r,h,t:longint;
    ans,min:qword;
begin
  fillchar(bt,sizeof(bt),0);
  readln(n);
  for i:=1 to n do
  begin
    readln(bt[i,0],bt[i,1],bt[i,2]);//建树
    l:=bt[i,1];r:=bt[i,2];
    if l<>0 then bt[l,3]:=i;
    if r<>0 then bt[r,3]:=i;
  end;
  min:=maxlongint;
  for i:=1 to n do//BFS
  begin
    fillchar(v,sizeof(v),true);
    ans:=0;
    v[i]:=false;
    h:=0;t:=1;
    q[1,1]:=i;q[1,2]:=0;
    while h<t do
    begin
      inc(h);
      for j:=1 to 3 do
      begin
        l:=bt[q[h,1],j];
        if l<=0 then continue;
        if v[l] then
        begin
          inc(t);
          v[l]:=false;
          q[t,1]:=l;
          q[t,2]:=q[h,2]+1;
          ans:=ans+bt[l,0]*q[t,2];
        end;
      end;
    end;
    if min>ans then min:=ans;
  end;
  writeln(min);
end.

```

---


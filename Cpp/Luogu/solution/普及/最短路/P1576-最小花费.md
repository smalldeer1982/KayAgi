# 最小花费

## 题目描述

在 $n$ 个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 $A$ 最少需要多少钱使得转账后 $B$ 收到 $100$ 元。

## 说明/提示

$1\le n \le 2000,m\le 100000$。

## 样例 #1

### 输入

```
3 3                                     
1 2 1
2 3 2
1 3 3
1 3
```

### 输出

```
103.07153164```

# 题解

## 作者：_LanFeng_ (赞：62)

算法：Dijkstra+堆优化（题解里为什么没有啊。。。，spfa能不用就千万别用，这个算法非常地危险）
思路其他题解都已经讲的很清楚了，我们来讲一下具体代码如何实现：
```cpp
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
int n,m,A,B;
double dis[2010];
bool mark[2010];
struct Node//固定格式：因为最短路里面是从小到大，那么最长路就要反过来，从大到小 
{
	int Num;
	double dis;
	bool operator<(const Node &a) const
	{
		return a.dis>dis;//再次提醒 
	}
};
struct node
{
	int Num;
	double dis;
};
vector<node> G[2010];
inline void Dij()
{
	priority_queue<Node> q;//建立优先队列 
	Node temp;
	temp.Num=A;
	temp.dis=1;
	q.push(temp);//初始化 
	while(!q.empty())//Dij算法，不会请自行百度了解基本思想 
	{
		int u=q.top().Num;//取出队首的元素 
		q.pop();
		if(mark[u]==1) continue;
		mark[u]=1;
		for(int i=0;i<G[u].size();i++)//讨论与队首元素相关的点 
		{
			int v=G[u][i].Num;
			double l=G[u][i].dis;
			if(mark[v]==0&&dis[v]<dis[u]*l)//最长路更新 
			{
				dis[v]=dis[u]*l;
				temp.Num=v;
				temp.dis=dis[v];
				q.push(temp);//入队 
			}
		}
	}
}
int main()
{
	node temp;
	scanf("%d%d",&n,&m);//输入点，边 
	memset(dis,-0x3f,sizeof(dis));//因为是求最长路，所以初始化为负无穷 
	for(int i=1;i<=m;i++)
	{
		int x,y;
		double z;
		scanf("%d%d%lf",&x,&y,&z);//输入一条线的两端以及长度 
		temp.Num=y;
		temp.dis=1-z/100;
		G[x].push_back(temp);
		temp.Num=x;
		G[y].push_back(temp);//双向边，用的vector存图，链式前向星同理 
	}
	scanf("%d%d",&A,&B);//输入起始点，终止点 
	dis[A]=1;//起始点到自己的距离要初始化为1，不能是0，否则等下与之相乘的数就会是0了 
	Dij();//跑 
	printf("%.8lf",100/dis[B]);//输出答案 
	return 0;
}
```

---

## 作者：The_Key (赞：48)

很裸的一道最“短”路问题，因为1<=n<=2000并且不存在负边权的情况，所以迪杰斯特拉也可以做，下面给出SPFA做法

首先我们可以发现两个人之间实际的汇率是 1-z% 那么我们就可以将人抽象成点，把两个人之间的汇率记做边权

如果A到B的汇率是 x ,B到C的汇率是y那么A到C的汇率就是x\*y,所以原来SPFA模板中更新权值就可以改成乘的形式

因为最后要求出最少的汇款，所以就要求A与B之间的汇率最大，那么现在就很显然了

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
int n,m,A,B,cnt;
double dis[2005],head[2005];//dis数组存的是起点到其余每个点的汇率 
bool vis[2005];
struct node//结构体邻接表存图 
{
    int to,next;
    double val;
}edge[1000005];//边数具体的大小没说，所以一开始开小结构体数组Re了两次 TAT，这里开1000000肯定能过 
void add(int x,int y,double z)
{
    cnt++;
    edge[cnt].to=y;
    edge[cnt].val=1-z;
    edge[cnt].next=head[x];
    head[x]=cnt;
}
void spfa()
{
    int u,v;
    queue<int>q;
    q.push(A);
    dis[A]=1;//起点与它本身的汇率是1 
    vis[A]=true;
    while(!q.empty())
    {
        u=q.front();
        q.pop();
        vis[u]=false;
        for(int i=head[u];i;i=edge[i].next)
        {
            v=edge[i].to;
            if(dis[v]<dis[u]*edge[i].val)//依次更新最大汇率 
            {
                dis[v]=dis[u]*edge[i].val;
                if(!vis[v])
                {
                    q.push(v);
                    vis[v]=true;
                }
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    fill(dis+1,dis+n+1,0);//因为存的是最大汇率所以将dis数组初始化为一个小的数，但是涉及到了乘法所以不能设为负数，初始化为0即可 
    for(int x,y,z,i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,(double)z/100);//将z转化成小数 
        add(y,x,(double)z/100);
    }
    scanf("%d%d",&A,&B);
    spfa();
    printf("%.8lf",100/dis[B]);//用100除以最大的汇率就是最少需要汇多少钱 
    return 0;
```
}//其实这道题只是模板的一个小小的变通，还是很简单的^-^
//最后祝各位以及自己 NOIP2017 RP++


---

## 作者：zjy111 (赞：44)

这道题本质上就是一道最短路的变种，转账时候收取1%手续费可以理解为这条边边权为0.99，而且边权是相乘而不是相加

为了更好理解，这里解释一下样例：要求从1到3，如果从1到2，手续费1%，那么钱数就乘0.99；2到3再乘0.98，这样总倍数是0.9702，优于直接1给3的0.97倍，所以答案是**100/0.97**。
### p.s.注意不是转化率，是到账100元最少需要的总费用！！！

这是我用priority_queue优化过的dijkstra写的代码

关于dijkstra的详细知识可以看[P4779](https://www.luogu.org/problem/P4779)的题解或者[最短路 - OI Wiki](https://oi-wiki.org/graph/shortest-path/)
```cpp
#include <bits/stdc++.h>
using namespace std;
struct edge{
	int to,nxt;
	double dis;
}e[100002];
double head[2002],dis[2002];
bool vis[100002];
int n,m,s,cnt,a,b;
void addedge(int u,int v,int d){
	e[++cnt].dis=1.0-d/100.0;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
struct node{
	double dis;
	int pos;
	bool operator <(const node &x)const{
		return x.dis<dis;
	}
};
priority_queue<node>q;
void init(){
	for(int i=1;i<=n;i++)
		dis[i]=0x7fffffff;
}
void dijkstra(){
	dis[a]=1.0;
	q.push((node){1.0,a});
	while(!q.empty()){
		node tmp=q.top();
		q.pop();
		int x=tmp.pos;
		if(vis[x])continue;
		vis[x]=1;
		for(int i=head[x];i;i=e[i].nxt){
			int y=e[i].to;
			if(dis[y]>dis[x]*e[i].dis){
				dis[y]=dis[x]*e[i].dis;
				if(!vis[y])q.push((node){dis[y],y});
			}
		}
	}
}
int main() {
	int i;
	cin>>n>>m;
	init();
	for(i=0;i<m;i++){
		int u,v,d;
		scanf("%d%d%d",&u,&v,&d);
		addedge(u,v,d);
	}
	cin>>a>>b;
	dijkstra();
	printf("%.8lf",100/dis[b]);
	return 0;
}

```
~~copy题解的同志们发现“祖国江山一片红”——而且样例还过了，是不是很神奇？~~
这是为什么呢？

让我们来分析一下题目

bug1：要求对方到账100元且自己花费最少，那么就是要求总倍数最高，也就是说
### 求的是最长路而不是最短路！！！！！
所以我们需要在松弛操作时找尽可能长的边，同时把运算符“<”重载成“>”，保证找到的路径最长

~~于是copy题解的同志们把这两处改了却发现“大红灯笼高高挂”~~
都在bug后面标序号1了，怎么可能没有bug2呢？

bug2：继续[读题](https://www.luogu.org/problem/P1576)，可以发现题目中的第一行描述是：
### 在n个人中，某些人的银行账号之间可以*互相*转账。
## 互相！！！
由于这份代码的核心部分是P4779（**单源**最短路径）的变体，所以之前写的时候一直当转账是单向的在处理，其实这题的图是无向图，也就是说我们要 _双向建边！_ 

~~于是copy题解的同志加了一个addedge后发现“万紫千红总是春”~~
事实上因为建一条双向边相当于两条单向边，所以我们所有关于边的数组空间都要开2倍
~~（其实我所有数组都开了2倍）~~

献上码风奇特的代码（保证AC）
```cpp
#include <bits/stdc++.h>
using namespace std;
struct edge{
	int to,nxt;
	double dis;
}e[200010];
double head[4010],dis[4010];
bool vis[200010];
int n,m,s,cnt,a,b;
void addedge(int u,int v,int d){ //建边
	e[++cnt].dis=1.0-d/100.0;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
struct node{
	double dis;
	int pos;
	bool operator <(const node &x)const{
		return x.dis>dis;  //注意重载成大于！！！
	}
};
priority_queue<node>q;
void init(){  //初始化
	for(int i=1;i<=n;i++)
		dis[i]=0;   //注意不要设置成正无穷！！！
}
void dijkstra(){   //优先队列优化的dijkstra
	dis[a]=1.0;
	q.push((node){1.0,a});
	while(!q.empty()){
		node tmp=q.top();
		q.pop();
		int x=tmp.pos;
		if(vis[x])continue;
		vis[x]=1;
		for(int i=head[x];i;i=e[i].nxt){
			int y=e[i].to;
			if(dis[y]<dis[x]*e[i].dis){  //注意这里是发现更大的dis时更新！！！
				dis[y]=dis[x]*e[i].dis;
				if(!vis[y])q.push((node){dis[y],y});
			}
		}
	}
}
int main() {
	int i;
	cin>>n>>m;
	init();
	for(i=0;i<m;i++){
		int u,v,d;
		scanf("%d%d%d",&u,&v,&d);
		addedge(u,v,d);
		addedge(v,u,d);  //注意建边2次！！！
	}
	cin>>a>>b;
	dijkstra();
	printf("%.8lf",100.0/dis[b]);  //注意是100/dis[b]
	return 0;
}

```



---

## 作者：「QQ红包」 (赞：22)

其实是最短路.

把起点和终点反过来求最短路.

就是松弛操作改一改就好.

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(s>='0'&&s<='9'));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(s>='0'&&s<='9')
    {
        k=k*10+(s-'0');
        s=getchar();
    }
    return k*base;
}
void write(int x)
{
    if(x<0)
    {
        putchar('-');
        write(-x);
    }
    else
    {
        if(x/10)write(x/10);
        putchar(x%10+'0');
    }
}
int n,m,X,Y,Z,id,s,t,u,v;
int to[4000010];
int wi[4000010];
int ne[4000010];
int po[4000010];
int vis[4010];
double dis[4000];
queue<int> q;
inline void add(int x,int y,int z)
{
    id++;
    to[id]=y;
    wi[id]=z;
    ne[id]=po[x];
    po[x]=id;
}
int main()
{
    n=read();
    m=read();
    for (int i=1;i<=m;i++)
    {
        X=read();Y=read();Z=read();
        add(X,Y,Z);//加双向边
        add(Y,X,Z);
    }
    t=read();s=read();//起点和终点反一下
    for (int i=0;i<=n+1;i++) dis[i]=23333333.0;
    q.push(s);
    dis[s]=100.0;
    vis[s]=1;
    while (!q.empty())
    {
        u=q.front();q.pop();
        vis[u]=0;
        for (int i=po[u];i;i=ne[i])
        {
            v=to[i];
            if (dis[v]>(double)(dis[u])/(1-0.01*wi[i]))//松弛操作
            {
                dis[v]=(double)(dis[u])/(1-0.01*wi[i]);
                if (vis[v]==0)//入队
                {
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    printf("%.8lf",dis[t]);//输出
    return 0;
}

```

---

## 作者：文艺平衡树 (赞：19)

很明显可以抽象成图。
i，j互相转账就相当于节点i和j之间有一条权值为（1-z%）的边，求一条路径使路径上各边权值乘积最大。结果就是100/max。
最大权值积可以用Dijkstra，省的写队列。
```
#include<stdio.h>
#include<stdlib.h>
double map[2001][2001],dis[2001],book[2001];
int main(){
	int n,m,i,j,x1,x2,x3,t,l,r;
	double q,max,ans;
	scanf("%d%d",&n,&m);
	//建图 
	for(i=1;i<=n;i++)
		map[i][i]=1;
	for(i=1;i<=m;i++){
		scanf("%d%d%d",&x1,&x2,&x3);
		q=(100-x3)/100.0;
		if(q>map[x1][x2]) map[x1][x2]=map[x2][x1]=q;
	}
	scanf("%d%d",&l,&r);
	for(i=1;i<=n;i++){
		dis[i]=map[l][i];
	}
	book[l]=1;
	//Dijkstra 
	for(i=1;i<n;i++){
		max=0;
		//找与源点路径上积最大的点 
		for(j=1;j<=n;j++){
			if(!book[j]&&dis[j]>max){
				max=dis[j];
				t=j;
			}
		}
		book[t]=1;
		//用这个点的出边去更新其余顶点 
		for(j=1;j<=n;j++){
			if(!book[j]&&dis[t]*map[t][j]>dis[j]){
				dis[j]=dis[t]*map[t][j];
			}
		}
	}
	ans=100/dis[r];
	printf("%.8lf",ans);//注意精度问题 
	return 0;		
}
```

---

## 作者：会打沙包的猫 (赞：19)

~~鉴于spfa已经死了~~

我们使用 dij+堆+链式前向星 来实现最短路
~~~
至于为什么要用最短路。。。这个其实很简单：
1.最小花费不就是把每个人看做一个点；
2.每次转账看做一个边；
3.把花费看做边权
4.注意一定要建双向边（蒟蒻wa了好几次）
5.结果要处理一下，因为不是输出汇率，而是最小花费
~~~

、、、cpp

~~~cpp
#include<bits/stdc++.h>
using namespace std;
struct xing{
	int next,to;double w;
};//没想到静态临接表还有前向星这么个可爱的名字❤
xing xx[200009];
double dis[200009],vis[200009];int cnt;
int hhh;
priority_queue< pair<double,int> > q;//pair存储边权和边的序号（优先队列实现大根堆）
int head[200009],n,m,g;//head数组是接某个点的最后一条边
inline void spfa()
{
	q.push(make_pair(1,g));//起点入队
	dis[g]=1;
	while(!q.empty())
	{
	    int now=q.top().second;//取出对首（编号）
		q.pop();
		if(vis[now]==1)continue;
		vis[now]=1;
		for(int j=head[now];j;j=xx[j].next)//临界表遍历接此点的边
		{
			int v=xx[j].to;
			if(dis[v]<dis[now]*xx[j].w)//松弛操作
			  {
			  	dis[v]=dis[now]*xx[j].w;
			  	q.push(make_pair(dis[v],v));
			  }
		}
	}
}
int main()
{
     cin>>n>>m;;
     int a,b;double c;
     memset(dis,-0x3fff,sizeof(dis));
     for(int i=1;i<=m;i++)
     {
     	cin>>a>>b>>c;
     	xx[++cnt].to=b;
     	xx[cnt].next=head[a];
     	xx[cnt].w=1.0-(double)(c/100);
     	head[a]=cnt;
     	xx[++cnt].to=a;
     	xx[cnt].next=head[b];
     	xx[cnt].w=1.0-(double)(c/100);
     	head[b]=cnt;
     }
     cin>>g>>hhh;
     spfa();
     printf("%.8f",100/dis[hhh]);//结果要处理一下，因为不是输出汇率
}

~~~

---

## 作者：顽皮 (赞：13)

### 第二篇题解解诶~~~



##### 解析：

构图是关键！！！

本题其实是求从A到B的最短路径问题，解题的关键是构图：以人员编号为顶点，若x号人和y号人之间可以相互转账则在x和y之间连一条边，边的权为100/（100-z）。

###### 样例：

因为B到帐后收到100元，所以，原题等价于求从B到A的最短路径（权值相乘），由于乘法满足交换律，故也可求从A到B的最短路径。对于样例，从A到B的最短路径为：1→2→3，权值为：[100/(100-1)]*[100/(100-2)]= 1.0307153164，最后的结果为：103. 07153164（保留小数点后8位）

### AC代码：
	#include<iostream>
	#include<cstdio>
	using namespace std;
	double a[2222][2222],dis[2222]={0},minn;
	int n,m,i,j,k,x,y;
	int f[2222]={0};//一定要记得赋初值为零
	void init()
	{
		cin>>n>>m;输入总人数和可以互相转账的人的对数
		for(int i=1;i<=m;i++)
		{
			scanf("%d%d",&j,&k);//循环输入
			scanf("%lf",&a[j][k]);
			a[j][k]=(100-a[j][k])/100;
			a[k][j]=a[j][k];
		}
		cin>>x>>y;
	}
	void dijkstra(int x)
	{
		for(int i=1;i<=n;i++)
			dis[i]=a[x][i];//把人数存进dis数组中
		dis[x]=1;
		f[x]=1;把f数组中x的位置标记为1
		for(int i=1;i<=n-1;i++)
		{
			minn=0;
			for(int j=1;j<=n;j++)
				if(f[j]==0 && dis[j]>minn)//f数组中j的位置还没有被标记且dis数组中j大于minn的值
				{
					k=j;//就把j的值给k
					minn=dis[j];更新minn的值
				}
			f[k]=1;标记
			if(k==y)//如果k==y，就直接break掉，下面的程序就没有做的必要来了
				break;
			for(int j=1;j<=n;j++)
				if(f[j]==0 && dis[k]*a[k][j]>dis[j])//最为重要的一部分程序就是这里了
				dis[j]=dis[k]*a[k][j];
		}
	}
	int main()
	{
		init();
		dijkstra(x);
		printf("%0.8lf",100/dis[y]);//保留八位小数输出
		return 0;
	}

---

## 作者：宸之辰 (赞：11)

此题没有给出m的值，所以我感觉用BMF还是有点方的，万一是个稠密图就GG了，不过看数据应该还是稀疏图，所以BMF还是完全可以的，这就成了一道BMF模板题，思路是从B点倒推A点

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b,u[205000],v[200500];
double dis[2050],w[200500],w2[200400];
const double inf=99999999;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        cin>>u[i]>>v[i]>>w[i];  //按照边输入； 
        w[i]=w[i]/100;  //w为手续费率； 
        w2[i]=(1/(1-w[i]));  
    }
```
/\*w2是从B倒推A所用的系数，比如A有Y元，传给B，B获得x元，
则Y\*（1-k）=X，移项得 Y=X/(1-k),w2存储的就是 1/(1-k)\*/

```cpp
    for(int i=1;i<=n;i++)
    {
        dis[i]=inf; //bmf标准步骤，距离初始化为无穷，实际存储的是各点至少要汇给B多少钱 
    }
    cin>>a>>b;
    dis[b]=100;   // B到自己的距离设为100即可，可以理解为B至少要给自己100快 
    for(int k=1;k<=n-1;k++)
    {
        int check=0;//BMF的小优化 
        for(int i=1;i<=m;i++)
        {
            if(dis[v[i]]>dis[u[i]]*w2[i])//无向图，所以要进行两个if判断 
            {
                dis[v[i]]=dis[u[i]]*w2[i];
                check++;
            }
            if(dis[u[i]]>dis[v[i]]*w2[i])
            {
                dis[u[i]]=dis[v[i]]*w2[i];
                check++;
            }
        }
        if(check==0)
        {
            break;
        }
    }
    printf("%0.8lf",dis[a]);//保留8位小数输出 
    return 0;
} 
个人感觉思路还是很好理解的，写法也应该很好理解
```

---

## 作者：猫粮寸断 (赞：11)

通过动态数组实现的SPFA

建立两个动态数组，一个保存和每个人相连的人，另一个保存该边的权值

（蒟蒻不会把这两东西合在一起）

保存权值的时候要注意最后算的是除法，所以直接换算成小数

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
int dui[200100];
double minn[2010];
vector<double> g[2010]; 
vector<int> man[2010];
int main()
{
    //freopen("money.in","r",stdin);
    //freopen("money.out","w",stdout);
    int n,m,a,b,x,y,head=1,tail=1,now,i;
    double z;
    memset(minn,127,sizeof(minn));
    cin>>n>>m;
    for(i=1;i<=m;i++)
    {
        scanf("%d %d %lf",&x,&y,&z);
        z=z/100.0;
        z=1.0-z;
        g[x].push_back(z);
        g[y].push_back(z);
        man[x].push_back(y);
        man[y].push_back(x);
    }
    cin>>a>>b;
    dui[1]=a;
    minn[a]=100.0;
    while(head>=tail)
    {
        now=dui[tail];
        for(i=0;i<man[now].size();i++)
        {
            if(minn[man[now][i]]>minn[now]/g[now][i])
            {
                minn[man[now][i]]=minn[now]/g[now][i];
                head++;
                dui[head]=man[now][i];
            }
        }
        tail++;
    }
    printf("%.8lf\n",minn[b]);
    return 0;
}
```

---

## 作者：ღ﹏ﻬ北❦栀 (赞：10)

### 看各位大佬各种方法层出不穷，我这个蒟蒻不才，只能用迪杰斯特拉了，废话不多说，直接上代码。
```cpp

#include <iostream>
#include <cstdio>
using namespace std;
int n, m, tx, ty; // tx：起点 ty：终点
double map[2010][2010], dis[2010]; // map：邻接表 dis：最短路存值
bool vis[2010]; // 访问数组，防止在求出到最短路得点，重复访问
int main() {
	int u,v,z;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>u>>v>>z;
		map[u][v]=map[v][u]=double(100 - z) /100;
		// 邻接表存储，并把值转化为 1 - 0.01 * z
	}
	cin>>tx>>ty;
	dis[tx]=1;// 最短路，从tx开始的，并赋值为1（别问为什么不赋值为0，你把一个数乘以0给我看看）
	for(int i=1;i<=n;i++) { // dijkstra 主体，开始喽。
		int mark=0;
		double maxn=0; // mark 存最大值的下标， maxn 自己看下面，注意要double类型
		for(int j= 1;j<=n;j++) if(!vis[j] && dis[j]>maxn)
				maxn=dis[mark=j]; // 这里就是更新manx，和找最大值的下标，别看写的短
		vis[mark]=true; // 找到最大值下标，vis设访问过。
		for(int j=1;j<=n;j++) if(!vis[j]) // 这里就更新dis的值了，max 要找dis最大嘛（相乘哦，理解式子） -_-||
				dis[j]=max(dis[j], dis[mark] * map[mark][j]);
	}
	printf("%.8lf",100/dis[ty]);// 这里再来一句废话，精确到8位小数
	return 0;
}
```
如果各位大佬有什么更好的方法，还请各位大佬教教我。

---

## 作者：QHhee004 (赞：8)


## 题解 P1576 【最小花费】

图论

Dijkstra的模板题

Dijkstra的痕迹很明显，要求两人之间的转账最小总费用，与图论中要求两点之间的最短路是一个意思。

A要转账给B，已知B要得到100元钱，要求A所花费的费用，即求B到A的“最短路”。

将所有的点分为两个集合，一个是B直接能到的点，一个是B不能直接到的点。

从B开始走，到B所有能到点开始遍历，每次将被遍历的点所能到的点，并记下他的费用，然后加入Ｂ能到的点。

但是若只是这样，不加任何优化的Dijkstra，时间复杂度是Ｏ（ｎ＊ｎ）。

如果思考一下，在算法中多余的部分是大部分点会被重复遍历，求费用的最小值，大胆假设如果一开始遍历所带来的费用就是最小值，程序肯定会跑得飞快！

在集合按费用大小从小到大遍历！

因为在计算加入点的费用时，是由Ｂ到被遍历的点的费用与遍历点和加入点的费用决定的。

可以借助数据结构，更加方便，如堆，优先队列，multiset。

记下费用和两点是否联通可以用结构体或pair

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b;//意思如题意
bool mark[2005];//记下该点有无被遍历过
double d[2005];//B点到该点的费用
vector < pair <int,int> > s[2005];//用可变数组来记两点之间能否到达和费用如何，相较于普通数组更加方便
multiset <pair <int,int> > f;//multiset里用pair 是按前面的数排序
void dij() {
	for(int i=1; i<=n; i++) d[i]=1e9;//若B到达不了，则费用无限大
	d[b]=100;//B到B，100元
	f.insert(make_pair(d[b],b));
	for(int i=1; i<=n; i++) {
		while(!f.empty()&&mark[(*f.begin()).second]) f.erase(f.begin());//如果该点被遍历过则不要
		int p=(*f.begin()).second;//遍历点
		mark[p]=1;
		for(int j=0; j<s[p].size(); j++) {
			int h=s[p][j].second,z=s[p][j].first;//h为加入点
			double mon=d[p]/(100-z)*100;//费用
			if(mon<d[h]) {
				d[h]=mon;
				f.insert(make_pair(d[h],h));
			}//取最小，加入。
		}
	}
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=0; i<m; i++) {
		int u,v,w;//u、v为点，w为费用
		scanf("%d%d%d",&u,&v,&w);
		s[u].push_back(make_pair(w,v));
		s[v].push_back(make_pair(w,u));
	}
	scanf("%d%d",&a,&b);
	dij();
	printf("%.8f",d[a]);
	return 0;
}
```


---

## 作者：___new2zy___ (赞：5)

# 题解 P1576 【最小花费】


** 题目传送门：：
https://www.luogu.org/problemnew/show/P1576 **

======================================================================下面请听我瞎掰=================

本题属于**图论中最短路**的变式

既然是要**找最小转账花费**，那么我们求出**最大的汇率**就行啦

**（最大的汇率是指让最后能剩下的钱最多）**

所以我们直接**SPFA求出"最长路"**即可

（因为本人很弱，不会用 diji+heap ）

注意要用double存dis（最大汇率）哦，

同时**初始化**dis也很重要，本人因为这个WA了一次= =

更详细的在代码里哦

不多说，直接上code= =

==================================================

    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    #include<queue>
    using namespace std;
    typedef long long ll;
    const int inf=1e9+7;
    inline int read()
    {
        int p=0,f=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
        while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
        return f*p;}
    struct Edge
    {
	    int from,to;
	    double w;
    }p[200050];
    int n,m,cnt,head[2050],vis[2050],Begin,End;
    double dis[2050];//注意存的是每个人对Begin的最大汇率 
    queue <int> q;
    void add_edge(int x,int y,int W)//存边
    {
	    cnt++;
	    p[cnt].from=head[x];
	    head[x]=cnt;
	    p[cnt].to=y;
	    p[cnt].w=1.0-0.01*(double)W;
	    //每条边存的都是两个人的汇率(不是损失的手续费)
    }
    void Init_()
    { 
	    n=read(),m=read();
	    for(int i=1;i<=m;i++)
		    {
			    int x=read(),y=read(),w=read();
			    add_edge(x,y,w);//无向图边正反存两遍 
			    add_edge(y,x,w);
		    }
    }
    void prework()
    {
	    Begin=read(),End=read();//输入起点与终点
	    //这里没有dis数组的初始化,由于要求最长路,不能附成inf
	    //默认为0即可(乘法的话也不能附成负数) 
	    dis[Begin]=1.0;//初始点到自身汇率为1 
	    vis[Begin]=1;
	    q.push(Begin);//起点入队
    }
    void SPFA()//求最大汇率(最长路)即可 
    {
	    prework();
	    while(!q.empty())
		      {
		  	    int x=q.front();
		  	    q.pop();
		  	    vis[x]=0;
		  	    for(int i=head[x];i;i=p[i].from)
		  		    {
		  			    double t1=dis[x]*p[i].w;
					      //注意要乘,汇率不能加 
		  			    if(dis[p[i].to]<t1)
		  			       {
		  			   	   dis[p[i].to]=t1;
		  			   	   if(!vis[p[i].to])
		  			   	      {
		  			   	   	  vis[p[i].to]=1;
		  			   	   	  q.push(p[i].to);
		  			   	      }
		  			       }
		  		    }
		      }
    }
    int main()//简洁的主函数= =
    {
	    Init_();//输入以及存边
	    SPFA();//求"最长路"即可
		       //最小费用*最大汇率==100.0
	    printf("%.8lf",100.0/dis[End]);//反推初始钱数
	    return 0;
    }
    
code到此就结束啦~~

===================小伙伴的评论====================

小伙伴：：
  歪，楼主你的代码真丑= =

楼主：：~~（我就是丑你来咬我呀）~~

==================================================

好啦，最后推广一下my blog::

https://www.luogu.org/blog/new2zy/


拜拜~~~ >=<

---

## 作者：KaisuoShutong (赞：4)

蒟蒻的第一篇题解~~竟然是Dijkstra~~

翻来覆去总不明白为什么楼下大佬要用堆优化---

~~无脑~~

很简单的一道luo -D ijk str a- 题目啊！

贴代码贴代码——


------------

```cpp
#include<iostream>
#include<cmath>
#include<iomanip>
#define maxn 0x7fffffff
using namespace std;
int n,m,get[2001],p[2001],a1,a2;
double bj[2001][2001],d[2001];
void dijkstra()
{
	d[a1]=100;p[a1]=a1;
	for(int i=1;i<=n;i++)
	{
		int ma=-maxn,k;
		for(int j=1;j<=n;j++)
			if(!get[j]&&ma<d[j]) ma=d[j],k=j;
		get[k]=1;
		for(int j=1;j<=n;j++)
			if(bj[k][j]&&!get[j]&&d[k]*bj[k][j]>d[j]) d[j]=d[k]*bj[k][j],p[j]=k;
	}
}
int main()
{
	int qw,er,ty;
    cin>>n>>m;
    for(int i=1;i<=m;i++) cin>>qw>>er>>ty,bj[er][qw]=bj[qw][er]=(100.0-ty)/100;
    cin>>a2>>a1;
    dijkstra();
	cout<<fixed<<setprecision(8)<<100.0/d[a2]*100<<endl;
}
```


声明：p[2001]标记father是为了方便需要输出路径的-题用，此题请无视

~~-DaLao请无视-~~

---

## 作者：Kindness (赞：4)

//师承 猫粮寸断

第一次在落谷写题解，也是第一次用spfa做题；

解决了猫哥存数的问题，其他基本一样，多了些讲解；

上代码：




```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
inline int read()
{
    int ee=0;
    char ss=getchar();
    while(ss<'0'||ss>'9')ss=getchar();
    while(ss>='0'&&ss<='9')
    {
        ee=(ee<<1)+(ee<<3)+ss-'0';
        ss=getchar();
    }
    return ee;
} //拙劣的读正整数的快读
struct my_s
{
    int p;//people，存人
    double r;//rate，存汇率
};vector<my_s> a[2005];//动态数组结构体
int x,y,A,B,n,m,now,head=1,tail=1,que[50005];//队列要开大些
double z,minn[2005];//minn数组来存最短路
int main()
{
    memset(minn,127,sizeof(minn));
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        x=read();y=read();z=read();
        z/=100;z=1-z;
        a[x].push_back((my_s){y,z});//按结构体顺序存储
        a[y].push_back((my_s){x,z});//无向图
    }
    A=read();B=read();
    que[head]=A;minn[A]=100;
    while(head<=tail)//spfa模板
    {
        now=que[head];//算是枚举邻接表
        for(int i=0;i<a[now].size();i++)
        {
            if(minn[a[now][i].p]>minn[now]/a[now][i].r)//更新最短路
            {
                minn[a[now][i].p]=minn[now]/a[now][i].r;
                tail++;
                que[tail]=a[now][i].p;
            }
        }
        head++;
    }
    printf("%.8lf",minn[B]);//输出
    return 0;
}
```

---

## 作者：友利奈绪 (赞：3)

//看到各位大佬大部分都用邻接表做的这道题，那本蒟蒻就发一个邻接矩阵的题解吧。思路spfa，数据范围不大，主要便于初学图论的朋友理解...
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int maxm=100010;
const int maxn=2010;

int e[maxn][maxn];  //邻接矩阵
double dis[maxn];
bool b[maxn];
int team[maxn];


int main(){
	int n,m;
	int s=0,t=0;
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=m;i++)
	{	
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		e[x][y]=z;
		e[y][x]=z;
	}
	int p1,p2;
	scanf("%d%d",&p1,&p2);
	//初始化 
	for(int i=1;i<=n;i++)
	{
		dis[i]=1e9;
	}
	dis[p2]=100;				
	
	
	team[t]=p2;
	t++;
	b[p2]=true;
	
	
	while(s!=t)
	{
		int now=team[s];
		s++;
		s%=n;
		b[now]=false;
		for(int i=1;i<=n;i++)
		{
			if(e[now][i]!=0) //now到i有边 
			{
				double tem=dis[now]/(100.0-e[now][i])*100;
				if(tem<dis[i])
				{
					dis[i]=tem;
					if(b[i]==false)
					{
						team[t]=i;
						t++;
						t%=n;
						b[i]=true;
					}
				}
			}
		}
		
	}
	
	printf("%.8lf",dis[p1]);
	return 0;
}

```

---

## 作者：灵宥 (赞：3)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double a[2001][2001],dis[2001]={0},minn;
int n,m,i,j,k,x,y,f[2001]={0}; 
void init () //定义该函数以处理录入数据
{
    cin>>n/*总人数*/>>m/*可以相互转账的人的对数*/;
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&j,&k);/*录入可以相互转账的两人的序号*/
        scanf("%lf",&a[j][k]);/*将这两人的手续费转存入该数组中*/
        a[j][k]=(100-a[j][k])/100;/*改变手续费的形式（即，将原来的扣除百分比 转换 为剩余百分比）*/
        a[k][j]=a[j][k];/*a传给b的手续费等于b传给a的手续费*/
    }
    cin>>x>>y;/*输入要求计算的两人*/
}
void dijkstra(int x)/*定义该函数以确定最小的手续费*/
{
    for(i=1;i<=n;i++)/*该循环用以将手续费重新赋值给dis数组，f机制用于判断是否以确定出最小值*/
    {
        dis[i]=a[x][i];/*赋值*/
        dis[x]=1;/*x转账给x的手续费为1(即没有手续费)*/
        f[x]=1;/*x以被确定为本轮中必须要走的最小中转点*/
    }
    for(i=1;i<=n-1;i++)/*该循环用以重新定义从a点转账到b点的手续费*/
    {
        minn=0;/*剩余最少为0*/
        for(j=1;j<=n;j++)/*该循环用以穷举*/
        {
            if(f[j]==0&&dis[j]>minn)/*如果j点并未被确定，并且x转账到j点所能余留的存款最多*/
            {
                k=j;/*将j点赋值给k点*/
                minn=dis[j];/*minn用以记录x到j点所需的"最小“手续费，类似于广搜*/
            }
        }
        f[k]=1;/*声明k点被确定*/
        if(k==y)
        {
            break;
        }
        for(j=1;j<=n;j++)
        {
            if(f[j]==0&&dis[k]*a[k][j]>dis[j])/*如果j点没被确定并且x到k点再到j点的所能余留下的存款比x直接转给j点要多*/
            {
                dis[j]=dis[k]*a[k][j];/*重新定义x到j点的最小手续费*/
            }
        }
    }
}
int main()
{
    init();
    dijkstra(x);
    printf("%0.8lf",100/dis[y]);
    return 0;
}
/*（TMD 别人的代码真摸不着头脑）*/
```

---

## 作者：xkzxkzxkz (赞：2)

#### 分析：
>在n个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问A最少需要多少钱使得转账后B收到100元。

设扣A最少需要a元钱，经过p1,p2...pn扣除手续费w1%,w2%...wn%，那么剩下r=a(1-w1%)(1-w2%)...(1-wn%)元,由题意r=100，即


------------

>>>`a=100/(1-w1%)(1-w2%)...(1-wn%)`


------------


因此我们需要使分子部分尽可能大，即可取得a的最小值。结合题意，可求出以1-w%作为权值的图上的最长路径。因此，我的想法是可以对Dijkstra算法或者Floyd稍作改动完成这个操作。由于Floyd算法时间复杂度比较高，经过尝试无法完成，故采用改动后的堆优化的Dijkstra算法。

```cpp
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <cstdint>
#include <queue>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <array>

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::vector;
using std::sort;
using std::priority_queue;
using std::pair;
using std::array;
using std::make_pair;
using std::max;


#define DIJSTRA
//#define FLOYD

#ifdef DIJSTRA
struct edge
{
	int v;
	double w;

	edge(int _v, double _w)
	{
		v = _v;
		w = _w;
	}

	bool operator<(const edge &e)const
	{
		return this->w < e.w;
	}
};

const size_t data_size= 2010;
vector<edge> graph[data_size];
double costs[data_size];
bool visited[data_size];

void calc_largest(int s)
{
	memset(costs, -0x3f, sizeof(costs));
	memset(visited, false, sizeof(visited));
	costs[s] = 1;

	priority_queue<edge> q;
	q.push(edge(s, 1));
	while (!q.empty())
	{
		edge top = q.top(); q.pop();
		int u = top.v;

		if (visited[u])
		{
			continue;
		}

		visited[u] = true;
		for (int i = 0; i < graph[u].size(); i++)
		{
			int v = graph[u][i].v;
			double w = graph[u][i].w;
			if (!visited[v]&&costs[v] < costs[u] * w)
			{
				costs[v] = costs[u] * w;
				q.push(edge(v, costs[v]));
			}
		}
	}
}

int main(void)
{
	int n = 0, m = 0;
	cin >> n >> m;

	for (int i = 0; i < m; i++)
	{
		int x = 0, y = 0;
		double w = 0;
		cin >> x >> y >> w;
		graph[x].push_back(edge(y, 1-w/100.0));
		graph[y].push_back(edge(x, 1-w/100.0));
	}

	int a = 0, b = 0;
	cin >> a >> b;
	calc_largest(a);

	double largest_cost = costs[b];

	cout << std::fixed << std::setprecision(8) << (double(100) / double(largest_cost)) << endl;

	return 0;
}
#endif

#ifdef FLOYD

array<array<double, 2010>, 2010> costs;

int main()
{
	int n = 0, m = 0;
	cin >> n >> m;
	for (int i = 0; i <= n + 1; i++)
	{
		costs[i].fill(1);
	}

	for (int i = 0; i < m; i++)
	{
		int u = 0, v = 0;
		double w = 0;
		cin >> u >> v >> w;
		w = 1.0 - w / 100.0;
		costs[u][v] = costs[v][u] = w;
	}

	for (int k = 1; k <= n; k++)
	{
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
			{
				costs[i][j] = max(costs[i][j], costs[i][k] * costs[k][j]);
			}
		}
	}

	int a = 0, b = 0;
	cin >> a >> b;
	double lowest = costs[a][b];
	cout << std::fixed << std::setprecision(8) << double(100) / lowest << endl;
	return 0;
}

#endif
```

---

## 作者：stone123 (赞：2)

同样用SPFA，dis[x]设为100即可，因为此题是无向图，所以要将边数乘以2.

c++代码

```cpp
#include<bits/stdc++.h>
using namespace std;
    int n,m,fir[1100],ne[1100000],u[1100000],v[1100000],w[1100000],a,b; double dis[1100]; bool f[1100];
    queue<int> q;
void spfa(int x){
    for(int i=1;i<=n;i++)dis[i]=99999999999.0;
    memset(f,false,sizeof(f));
    dis[x]=100.0; q.push(x); f[x]=true;
    while(!q.empty()){
        int fj=q.front();
        q.pop(); f[fj]=false;
        for(int i=fir[fj];i!=-1;i=ne[i]){
            double sum=dis[fj]*100/(100-w[i]); 
            if(sum<dis[v[i]]){
                dis[v[i]]=sum;
                if(!f[v[i]]){
                    q.push(v[i]);
                    f[v[i]]=true;
                }
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    memset(fir,-1,sizeof(fir)); memset(ne,-1,sizeof(ne));
    for(int i=1;i<=m;i++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        int j=i*2;
        u[j]=x; u[j+1]=y; v[j]=y; v[j+1]=x; w[j]=z; w[j+1]=z;
        ne[j]=fir[u[j]];
        fir[u[j]]=j;
        ne[j+1]=fir[v[j]];
        fir[v[j]]=j+1;
    }
    scanf("%d%d",&a,&b);
    spfa(a);
    printf("%.8lf",dis[b]);
}
```

---

## 作者：cleverman (赞：2)

//使用的是Dijkstra算法，楼上爆0是因为邻接矩阵的最大值在以下进行处理的时候会变成0.

//看成从B点转钱到A点即可，符合Dijkstra先处理的确定值大于后续估计值的前提



    
        
```cpp
#include<iostream>
#define MAXN 2001
#define inf 99999
using namespace std;
int N,M,A,B;
double m[MAXN][MAXN];
int main()
{
    int i,j;
    cin>>N>>M;
    cout.setf(ios::fixed);
    for (i=0;i<N;i++)
        for (j=0;j<N;j++)
            m[i][j]=1/inf;
    for (i=0;i<M;i++)
    {
        int x,y,t;
        cin>>x>>y>>t;
        x--; y--;
        m[x][y]=m[y][x]=1-(t/100.0);        //exchange to weight
    }
    cin>>A>>B;
    A--; B--;
    //dijkstra
    double dis[MAXN];                            //dis i:money needed to trans 100 to i
    bool book[MAXN];
    book[B]=true;
    for (i=0;i<N;i++)
    {
        dis[i]=100/m[B][i];                    //init dis[]
        book[i]=false;                            //init book[]
    }
    for (j=0;j<N;j++)
    {
        int nmin;
        double min=inf;
        for (i=0;i<N;i++)
            if (dis[i]<min&&!book[i])
            {
                nmin=i;
                min=dis[nmin];                    //find #min->nmin
            }
        book[nmin]=true;                        //record in book[]
        for (i=0;i<N;i++)
            if (min/m[nmin][i]<dis[i]&&!book[i])        //relax
                dis[i]=min/m[nmin][i];
    }
    cout.precision(8);
    cout<<dis[A];
    return 0;
}
```

---

## 作者：pupuvovovovovo (赞：2)

为什么没有人打pascal的SPFA?

我来放一个。

可以把它当做求最长路。

再拿一个数去除。

为了精度我用了extended，初始值为100。

接下来是代码：

```cpp
var first,last:array [1..2000] of longint;
next,en,fee:array [1..2000000] of longint;
f:array [1..2000] of extended;
dl:array [1..8000] of longint;
b:array [1..2000] of boolean;
h,t,n,m,s,endd,i,top,x,y,z:longint;
ans:extended;
procedure add(x,y,z:longint);
begin
  inc(top);
  if first[x]=0 then first[x]:=top
  else next[last[x]]:=top;
  last[x]:=top;
  en[top]:=y;
  fee[top]:=z;
end;//邻接表
begin
  read(n,m);
  for i:=1 to m do
  begin
    read(x,y,z);
    add(x,y,z);
    add(y,x,z);
  end;
  read(s,endd);
  dl[1]:=s;
  f[s]:=100;
  fillchar(b,sizeof(b),true);
  t:=1;
  repeat
    inc(h);
    b[dl[h]]:=true;
    i:=first[dl[h]];
    while i>0 do
    begin
      if f[en[i]]<f[dl[h]]*(100-fee[i])/100 then//因为是最长路，所以是小于号。
      begin
        f[en[i]]:=f[dl[h]]*(100-fee[i])/100;
        if b[en[i]] then
        begin
          inc(t);
          b[en[i]]:=false;
          dl[t]:=en[i];
        end;
      end;
      i:=next[i];
    end;
  until h=t;//SPFA
  ans:=10000/f[endd];
  write(ans:0:8);
end.
```

---

## 作者：zcl1024 (赞：1)

这道题其实挺水的，用SPFA即可（~~虽然它已经死了~~）  
由于数据小，所以没有用邻接表，（~~我才不告诉你我不会呢~~）
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int s,t;//s=A,t=B
int a[2100][2100];//存手续费的
int n,m;
bool f[21010];
double d[2100];
int xa[100000];
void spfa(int x)//SPFA大家应该都会吧
{
	int h=0,t=1;
	xa[1]=s;
	int i;
	int y;
	while (t!=h)
	{
		h++;
		y=xa[h];
		f[y]=false;
		for (i=1;i<=n;i++)
		if(a[i][y]!=0&&d[y]/(1-(a[i][y]/100.0))<d[i])//千万不能写成(1-(a[i][y]/100)
		{
			d[i]=d[y]/(1-(a[i][y]/100.0));
			if (f[i]==false)
			{
				t++;f[i]=true;xa[t]=i;
			}	
		}
	}
}
int main()
{
	cin>>n>>m;
	int i;
	int x,y,z;
	for (i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		a[x][y]=z;a[y][x]=z;//可以互相转账,相当于无向图
	}
	cin>>s>>t;
	for (i=1;i<=n;i++)
    d[i]=500000000;
    d[s]=100;//转账后B要收到100元
    f[s]=true;
	spfa(s);
	printf("%.8lf\n",d[t]);
	return 0;
}
```

---

## 作者：hicc0305 (赞：1)

简单的一道SPFA。同楼下大神，转化为求最长路，除一下就可以啦。（SPFA不会的自行百度）

重点提醒：数组开够！本人被此坑死了，交了好几遍……

以下贴代码：



```cpp
    #include<cstdio>
    #include<cstring>
    #include<iostream>
    using namespace std;
    int n,m,cnt=0;
    int head[400001],nxt[400001],to[400001];
    int q[400001],f[400001];
    double dis[400001],val[400001];
    void addedge(int x,int y,double z)
    {
        cnt++;
        nxt[cnt]=head[x];
        head[x]=cnt;
        to[cnt]=y;
        val[cnt]=z;
    }
    void spfa(int a,int b)
    {
        int l=0,r=1,u;
        q[1]=a;
        f[a]=1;
        dis[a]=1;
        while(l<r)
        {
            u=q[++l];//手打队列~
            f[u]=0;
            for(int i=head[u];i!=0;i=nxt[i])
            {
                if(dis[to[i]]<dis[u]*val[i])//别忘是乘
                {
                    dis[to[i]]=dis[u]*val[i];
                    if(!f[to[i]])
                    {
                        q[++r]=to[i];
                        f[to[i]]=1;
                    }
                }
            }
        }
    }
    int main()
    {
        memset(dis,0,sizeof(dis));
        memset(f,0,sizeof(f));
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++)
        {
            int x,y;
            double z;
            scanf("%d%d%lf",&x,&y,&z);
            addedge(x,y,double((100-z)/100));//邻接表
            addedge(y,x,double((100-z)/100));
        }
        int a,b;
        scanf("%d%d",&a,&b);
        spfa(a,b);//最短路，其实最长路(￢_￢)
        printf("%.8lf",100/double(dis[b]));
        return 0;
}
```

---

## 作者：noip (赞：1)

很裸的spfa吧

记得用数学推一下松弛条件和答案

还有要用double







```cpp
#include <iostream>
#include <stdio.h>
#include <vector>
#include <queue>
using namespace std;
int n , m;
vector < int > linker[2000 + 2];
vector < double > value[2000 + 2];
queue < int > q;
double dist[2000 + 2];
int a , b , z;
bool use[2000 + 2];
double spfa()
{
       int now , i , cur;
       double v;
       q.push( a );
       for( i = 1 ; i <= n ; i++ )
            dist[i] = 0;
       dist[a] = 1;
       while( !q.empty() )
       {
              now = q.front();
              q.pop();
              use[ now ] = 0;
              for( i = 0 ; i < linker[ now ].size(); i++ )
              {
                   cur = linker[ now ][i];
                   v = value[ now ][i];
                   if( dist[ cur ] < dist[ now ] * v )
                   {
                       dist[ cur ] = dist[ now ] * v;
                       if( !use[ cur ] )
                       {
                           use[ cur ] = 1;
                           q.push( cur );
                       }
                   }
              }
       }
       return dist[b];
}
int i;
int main()
{
    scanf( "%d %d" , &n , &m );
    for( i = 0 ; i < m ; i++ )
    {
         scanf( "%d %d %d" , &a , &b , &z );
         linker[a].push_back( b );
         linker[b].push_back( a );
         value[a].push_back( 1 - 1.0 * z / 100 );
         value[b].push_back( 1 - 1.0 * z / 100 );
    }
    scanf( "%d %d" , &a , &b );
    printf( "%.8lf\n" , 100 / spfa() );
    return 0;
}
```

---

## 作者：Mr_Li (赞：1)

这道题不用SPFA，只要使用类似迪杰斯特拉算法就可以了（把求路径和改成求100依次除以路径权值的商的最小值），算法的正确性是可以证明的。

特别说一下：

测试点 #10：通过该测试点。 得分10，耗时**998ms**，内存34189kB。


---

## 作者：从不再见 (赞：0)

### [P1576](https://www.luogu.org/problem/P1576)

   这道题目看到最小，又有多个人，就直接最短路，可是又有一些~~不同~~，如果之间去找扣除中的最少，那么就会更大，所以我先把两个人之间可以收到百分之多少算出来，
```
vertex[a][b]=(100-c)/100.0;
vertex[b][a]=vertex[a][b];
```
   再跑一边最短路，总之，我认为这和模板没有太大的区别，只是多了在输入时，多计算一边。
   
   我想，很多人都用的floyd，但我用的是dijkstra,因为这道题求的是A到B的最小花费，是单源最短路，所以没必要用floyd，直接dijkstra就好了。在此，我也不再过多的赘述，_代码_如下：
```
#include<bits/stdc++.h>
using namespace std;
double dis[2010],vertex[2010][2010];//dis维护单点间最小距离 ，vertex[i][j]是点i到j的直接距离 
int n,m,s,e;
struct node{
    int id;
    double longs;
    bool operator<(const node & next) const	//重置运算符 
    {
        return longs < next.longs;
    }
};
void dijkstra(int s){	//dijkstra+优先队列（堆优化） 
    priority_queue<node> pq;//小->大 
    for(int i=1;i<=n;i++)
        dis[i]=0;
    dis[s]=1;
    node cur;
    cur.id=s,cur.longs=dis[s];
    pq.push(cur);
    while(!pq.empty()){
        int u=pq.top().id;//队首就是图中初始点到每个点的距离最小的点 
        pq.pop();
        for(int i=1;i<=n;i++){
            if(dis[u]*vertex[u][i]>dis[i]){
                dis[i]=dis[u]*vertex[u][i];
                node next;
                next.id=i;
                next.longs=dis[i];
                pq.push(next);
            }	
        }
    }
} 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			vertex[i][j]=(i==j)? 1 : 0; //初始化vertex 
	for(int i=1;i<=m;i++){
		int a,b,c;
		cin>>a>>b>>c;
		vertex[a][b]=(100-c)/100.0;//题目是扣除c%的手续费 
		vertex[b][a]=vertex[a][b];//无向，两人之间 
	}
	cin>>s>>e;
	dijkstra(s);
	double ans=100.0/dis[e];//dis储存的最小扣除的百分比 
	printf("%.8lf",ans);
	return 0;
}
```


---

## 作者：Sakura_Peng (赞：0)

我们一开始看到题目可能会觉得无从下手

但是我们可以看一下输入的数据

每两个人之间的“汇率”，

又让求怎么样可以使得A用最少钱转到B手中使B得到正好100RMB（~~事真多~~ ）

我们如果直接从A来看最短路是肯定很麻烦的

我们可以看到，输入的两个人之间的“汇率”是互相的

按照图的思想就是输入的是无向边

那么我们可以尝试求出B到A的最短路

把原来求单源最短路dis数组意义设置为dis[i]是第i个人到第B个人使得B转账得到的正好为100元这个第i个人最少初始钱数

我们设dis[B]点的最短路为100（RMB）

则使用SPFA算法，只需要把松弛操作稍微改变一下即可

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
struct CZP
{
	int next,to;
	double dis;
}a[200002];
double dis[200002];
int n,m,sx,ex,que[2000002],b[10001],h[10001],top;
void cun(int from ,int to,double dis)
{
	a[++top].next=h[from];
	a[top].to=to;
	a[top].dis=dis;
	h[from]=top;
}  //使用邻接表存储
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	h[i]=-1;
	for (int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		cun(x,y,(double)z);
		cun(y,x,(double)z);  //注意将z进行小数化，要不然会卡，就因为这个卡了很长时间！
	}
	scanf("%d%d",&sx,&ex);
	int head=0,tail=1;
	for (int i=1;i<=n;i++)
	dis[i]=10000000000.0;  
	dis[ex]=100.0,b[ex]=1,que[1]=ex;
	do
	{
		head=head%10001+1;
		int v=que[head];
		b[v]=0;
		int k=h[v];
		while (k!=-1)
		{
			if (dis[a[k].to]>dis[v]/(1-a[k].dis/100))  //这里的松弛语句稍加改变
			{
			dis[a[k].to]=dis[v]/(1-a[k].dis/100);
			if (!b[a[k].to])
			{
				tail=tail%10001+1;
				b[a[k].to]=1;
				que[tail]=a[k].to;
			}
		}
		k=a[k].next;
	}
}while (head<tail);  //其他部分均为SPFA的模板没有改变
    printf("%.8lf",dis[sx]);
	return 0;
}
```




---

## 作者：Yosame (赞：0)

求最小花费，没有负边权，满足Dijkstra的条件，所以直接堆优化Dijkstra。Dijkstra本来用于求最短路，移植到本题求最小比例，显然没有问题。本题要注意B才是已知，A是未知，所以是从B到A而不是从A到B，别被惯性思维误导了。
（两种求法：1、点上存比例，2、点上存在这个点需要转的钱，都没有问题，下面的代码写的是第二种）

如何避免精度问题？可以无脑上long double，对于本题数据来说没有多大影响（注意用scanf和printf时需要Lf而不是lf）。

```cpp
#include<cstdio>
#include<queue>
#define mp 2048
#define ml 262144
#define ci const int
#define ldb long double
using namespace std;
int head[mp],ver[ml],nxt[ml],edge[ml],n,m,tot;
ldb d[mp];
struct pr{
    ldb d;int p;
    pr(ldb a=0,ci b=0){d=a;p=b;}//构造函数，用于初始化结构体的值，不会可自行百度 
    inline bool operator < (const pr a)const{return d<a.d;} 
};
priority_queue<pr>q;
inline void adds(ci a,ci b,ci c){
    ver[++tot]=b;
    nxt[tot]=head[a];
    head[a]=tot;
    edge[tot]=c;
}
inline int rd(){
    int io=0;char in=getchar();
    while(in<'0'||in>'9')in=getchar();
    while(in>='0'&&in<='9')io=io*10+in-'0',in=getchar();
    return io;
}
int main(){
    n=rd(),m=rd();
    for(int t=1;t<=n;++t)d[t]=2000000000;//long double不能memset 
    for(int t=1;t<=m;++t){
        int x=rd(),y=rd(),z=rd();
        adds(x,y,z);
        adds(y,x,z);//百分比作为边权 
    }
    int a=rd(),b=rd();
    d[b]=100,q.push(pr(100,b));
    while(!q.empty()){//dijkstra
        int x=q.top().p;
        q.pop();
        for(int t=head[x];t;t=nxt[t]){
            int y=ver[t];
            ldb dist=d[x]/(1-(ldb)edge[t]/100);//计算：把边权存储的百分比复原为这个点真实需要转的钱  
            if(dist<d[y]){
                d[y]=dist;
                q.push(pr(-dist,y));
            }
        } 
    }
    printf("%.8Lf",d[a]);
    return 0;
}
```


---

## 作者：rediserver (赞：0)

# P1576 最小花费

[原题地址](https://www.luogu.org/problemnew/show/P1576)

[GitHub题解](https://github.com/jerrykcode/luogu)


## 思路

### 问题：

b需要100元，a至少需要转出多少?

### 边权：

设x到y的边权为z，则：

* 若x向y转账n元，则y收到`n*z`元，(即输入 1 2 3，则1到2的边权为0.97)

* 若x向y转账，且y需要收到n元，则x需要转出`n/z`元

### 对dijkstra改造：

* 终点des向起点src转账，src需要100元

* 顶点的dist值表示，该顶点至少需要转出多少，src才能得到100元

* src的dist值为100

* 收录dist值最小的顶点，设该顶点为min_vertex，其dist值为min_dist，对所有邻接点，设边权为weight，若`min_dist/weight`小于邻接点的dist值则更新(即对于这一个邻接点，经过min_vertex转账到src，花费可以更少)

## C++代码

* 邻接表表示图(对每个顶点用一个vector存储其所有的邻接点)

* dijkstra算法实现封装在MinCost类中

* 顶点改为从0开始编号

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
using namespace std;

#define NO_VALUE -1

//邻接点结构体
struct AdjNode {
	int v; //邻接顶点
	double weight; //邻接边权重
	AdjNode(int v, double weight) : v(v), weight(weight) {}
};

//计算最小花费类
class MinCost {
public:
	MinCost() {}
	~MinCost() {}

	/* 返回src需要得到num，des至少需要多少花费。*/
	double minCost(vector<AdjNode> *graph, int nv, int src, int des, double num);
private:
	//优先队列使用的结构体
	struct Node {
		int v;
		double dist;
		Node(int v, double dist) : v(v), dist(dist) {}
	};
	struct cmp {
		bool operator() (Node& a, Node& b) {
			return a.dist > b.dist;
		}
	};

	//类变量
	double *dist_;
	bool *collected_;
};

double MinCost::minCost(vector<AdjNode>* graph, int nv, int src, int des, double num) {
	//dijkstra
	dist_ = new double[nv];
	fill(dist_, dist_ + nv, NO_VALUE);
	collected_ = new bool[nv];
	fill(collected_, collected_ + nv, false);
	dist_[src] = num;
	priority_queue<Node, vector<Node>, cmp> q;
	q.push(Node(src, dist_[src]));
	int min_vertex, adj_vertex;
	double adj_weight, tmp_dist;
	while (!q.empty()) {
		min_vertex = q.top().v;
		q.pop();
		if (collected_[min_vertex]) continue;
		collected_[min_vertex] = true;
		if (min_vertex == des) {
			while (!q.empty()) q.pop();
			break;
		}
		for (AdjNode adj_node : graph[min_vertex]) { //遍历邻接点
			adj_vertex = adj_node.v;
			adj_weight = adj_node.weight;
			if (!collected_[adj_vertex]) {
				tmp_dist = dist_[min_vertex] / adj_weight; //adj_vertex经过min_vertex到达src的花费
				if (tmp_dist < dist_[adj_vertex] || dist_[adj_vertex] == NO_VALUE) {
					//更新
					dist_[adj_vertex] = tmp_dist;
					q.push(Node(adj_vertex, dist_[adj_vertex]));
				}
			}
		}
	} //while
	double result = dist_[des];
	free(dist_);
	free(collected_);
	return result;
}

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	vector<AdjNode> *graph = new vector<AdjNode>[n];
	int x, y, z, a, b;
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &x, &y, &z);
		//改为从0开始编号
		x--; y--;
		graph[x].push_back(AdjNode(y, ((double)(1.0) - (double)(0.01) * z)));
		graph[y].push_back(AdjNode(x, ((double)(1.0) - (double)(0.01) * z)));
	}
	scanf("%d %d", &a, &b);
	a--; b--;
	MinCost min_cost;
	printf("%.8lf", min_cost.minCost(graph, n, b, a, (double)(100.0)));
	for (int i = 0; i < n; i++)
		vector<AdjNode>().swap(graph[i]);
	return 0;
}
```

---

## 作者：Hiraeth (赞：0)

### 双向边数组开两倍

### 双向边数组开两倍

### 双向边数组开两倍

#### 重要的事情说三遍

不然会出现RE的情况

[大型翻车现场…](https://www.luogu.org/recordnew/show/17358584)

来看一下题目：

每两个账户之前在支付一定手续费的情况下可以相互转账，A使得B到账100元最少需要的总费用。

大家在平时的数学课上应该做到过这样一个问题：

~~也许是小学数学~~

A有100元，从A到B要扣除5%，从B到C要扣除7%.

求C最后获得的钱数.

相信很快就能把答案算出来 100 * 95% * 97%

类比到本题而言 要求的就是已知C最后获得100元 求A汇出的钱数.

很明显 最终得到的钱数一定的情况下 当比率之积最大时 汇出的钱数最少

把每个账户看作点数 边权看作手续费 这样就可以建立起一个图的模型了

从A点出发 $d[a]=1$ 如果松弛操作中得到的答案比他大的话 那么就更新当前节点

这里求的应该是单源最长路

现有题解中很多人都说 $spfa$ 已死

但是就本人的观点而言 最短路用 $dijkstra$  最长路用 $spfa$

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int head[200005],next[200005],ver[200005],edge[200005],v[200005],tot;
int n,m,x,y,z,a,b;
double d[2005];
queue <int> q;
inline void add(int x,int y,int z){
	ver[++tot]=y;
	edge[tot]=z;
	next[tot]=head[x];
	head[x]=tot;
}
inline void spfa(){
	q.push(a);
	d[a]=1;
	while (!q.empty()){
		x=q.front();
		q.pop();
		v[x]=0;
		for (int i=head[x];i;i=next[i]){
			y=ver[i];
			z=edge[i];
			if (d[y]<(d[x]*(100-z)/100)){
				d[y]=d[x]*(100-z)/100;
				if(!v[y]) {v[y]=1;q.push(y);} 
			}
		} 
	} 
} 
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) {
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	scanf("%d%d",&a,&b);
	spfa();
	printf("%.8lf\n",100*1.0/d[b]);
	return 0;
} 
```


---

## 作者：清风我已逝 (赞：0)

为什么没有spfa的题解？

1.建图：照样建就可以了
2.spfa更新：怎么做？？
```
首先你知道终点的价值，那么题目所要求的就是起点的价值

t->s终点->起点

z表示标号为x的人和标号为y的人之间互相转账需要扣除z%的手续费

显然，x->y w[y]=w[x]*(1-z%)
那么，y->x w[x]=w[y]/(1-z%)
```

奉上代码
```
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
#include<vector>
#define N 200000

using namespace std;
void in(int &x){
    register char c=getchar();x=0;int f=1;
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    x*=f;
}

int n,m,head[N],tot;
struct node{
	int to,next,w;
}e[N];

void add(int u,int v,int w){
	e[++tot].to=v;e[tot].next=head[u];head[u]=tot;e[tot].w=w;
}

int s,t;
bool vis[N];
double d[N];
queue<int>Q; 
void spfa(){
	vis[t]=0;Q.push(t);
	for(int i=1;i<=n;i++) d[i]=0x3fffffff;
	d[t]=100;
	while(!Q.empty()){
		int u=Q.front();Q.pop();vis[u]=0;
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			double p=d[u]/(1.0-e[i].w/100.0);
			if(d[v]>p){
				d[v]=p;
				if(!vis[v]){
					Q.push(v);vis[v]=1;
				}
			}
		}
	}
}

int main()
{
	in(n);in(m);
	for(int i=1;i<=m;i++){
		int u,v,w;
		in(u);in(v);in(w);
		add(u,v,w);add(v,u,w);
	}in(s);in(t);
	spfa();
	printf("%.8f",d[s]);
	return 0;
}
```

---

## 作者：Hydroxyl (赞：0)

果断的单元最短路径 迪吉斯卡尔算法啊

然后果断的copy了老师给我们的中间的一段代码

然后大概就是下面这样了



然后就是这样了 也就是每次都直接按照百分率算 不过你要记得百分率小的要大 然后下面的大于号小于号要记得弄清楚

const oo=200000000;     你不觉得这个oo很像无穷大吗？




```cpp
var g:array[0..2001,0..2001] of real;     开数组
    v:array[0..2001] of boolean;      判断是否访问过这个节点 
    min:real;      下面用就对了
    x,y,z,i,j,k,n,m,a,b:longint;   一大堆什么都不知道的垃圾玩意
begin
    readln(n,m);
    for i:=1 to m do
    begin
      read(x,y,z);
      g[x,y]:=1-z/100;
      g[y,x]:=g[x,y];
    end;
    readln(a,b);
    for i:=1 to n do
     for j:=1 to n do
     if g[i,j]=0 then g[i,j]:=0;     读入输出等各种处理也就不讲了
    v[a]:=true;   从a节点开始遍历
    for i:=2 to n do     其实只要n-1次就够了因为第一个节点都是出发的节点，但是好像1开始也没关系啊
    begin
      min:=0;
      for j:=1 to n do
      if (not v[j]) and (g[a,j]>min) then      没有访问然后又比他小就ok 这里是一部贪心的思想
      begin
        min:=g[a,j];    更换
        k:=j;    记录位置
      end;
      v[k]:=true;   遍历get
      for j:=1 to n do
       if (not v[j]) and (g[a,k]*g[k,j]>g[a,j]) then   大于号 乘号记得要弄 
        g[a,j]:=g[a,k]*g[k,j];    ok
    end;
    writeln(100/g[a,b]:0:8);     最后输出倒着除一下 记得长宽设置好
end.
```
然后奉献上这个的模板

```cpp
for i:=1 to n do
     for j:=1 to n do
      if g[i,j]=0 then g[i,j]:=oo;
    v[p]:=true;
    for i:=2 to n do
    begin
      min:=oo;
      for j:=1 to n do
       if (not v[j]) and (g[p,j]<min) then
       begin
         min:=g[p,j];
         k:=j;
       end;
       v[k]:=true;
       for j:=1 to n do
        if (not v[j]) and (g[p,k]+g[k,j]<g[p,j]) then
          g[p,j]:=g[p,k]+g[k,j];
    end;

```

---

## 作者：Kwork (赞：0)

这道题坑了我好久啊。一开始作死用了堆优化的Dijkstra算法，但是WA，爆0。绝望的我老老实实地打了一遍SPFA，感觉好没意思。

这道题其实很简单。我们只要求出两个人之间的最大路径s，100/s就是答案。所以关键是最短路，最短路的松弛操作中的加法换成乘法就可以了。事实上这就是一道最短路题目。

```cpp

#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>
#include <vector>
using namespace std;
const int maxn=2005;
struct edge{int to;double cost;};
double d[maxn],z;
int n,m,s,t,x,y;
vector<edge>Graph[maxn];//邻接表，不会的可以用Graph[maxn][maxn]代替，但是数据大了就过不了，还是要学邻接表哦，这里不赘述。
//spfa模板
void solve(){
    bool f[maxn];memset(f,false,sizeof(f));
    queue<int>que;
    for(int i=1;i<=n;i++) d[i]=0;
    d[s]=1; f[s]=true;
    que.push(s);
    while(!que.empty()){
        int p=que.front();que.pop();
        f[p]=false;
        for(int i=0;i<Graph[p].size();++i){
            edge e=Graph[p][i];
            if(d[e.to]<d[p]*e.cost){
                d[e.to]=d[p]*e.cost;
                if(!f[e.to]){
                    f[e.to]=true;
                    que.push(e.to);
                }
            }        
        }
    }
    double ans=100/d[t];
    printf("%.8lf",ans);
    
    return;
}
int main(){
    //freopen("1.txt","r",stdin);
    //freopen("2.txt","w",stdout);
    std::ios::sync_with_stdio(false);

    cin>>n>>m;
    for(int i=1;i<=m;i++){//这里是双向的路，一开始看成单向路了。
        cin>>x>>y;cin>>z;
        z=(100-z)/100;
        edge e;
        e.to=y;
        e.cost=z;
        Graph[x].push_back(e);
        e.to=x;
        Graph[y].push_back(e);
    }
    cin>>s>>t;
    solve();

    return 0;
}

```

---

## 作者：The_Dark_Knight (赞：0)

PASCAL最小花费题解（迪杰斯特拉算法）

```delphi

var a,b,m,n,i,j,x,y,z,u:longint;s,min1:real;
    dist:array[1..3000,1..3000] of real;//存储两点间距离
    min:array[1..3000] of real;//存储从A点到任意一点所需花费
    visit:array[1..3000] of boolean;//查看是否遍历
begin
    for i:=1 to 3000 do
      for j:=1 to 3000 do
      begin
        dist[i,j]:=maxlongint;
        min[j]:=maxlongint;
      end;//初始化
    readln(n,m);
    for i:=1 to m do
    begin
        readln(x,y,z);
        dist[x,y]:=z/100;
        dist[y,x]:=z/100;
    end;
    readln(a,b);
    min[a]:=100;//赋初始值
    for i:=2 to n do//迪杰斯特拉算法
    begin
        min1:=maxlongint;
        for j:=1 to n do
          if (min[j]<min1)and(visit[j]=false) then
          begin
              min1:=min[j];
              u:=j;
          end;
        visit[u]:=true;
        for j:=1 to n do
          if (min[u]/(1-dist[u,j])<min[j])and(visit[j]=false)and(min[u]<>maxlongint)and(dist[u,j]<>maxlongint) then min[j]:=min[u]/(1-dist[u,j]);
    end;
    writeln(min[b]:0:8);
end.

```

---

## 作者：IcSaku (赞：0)

这一道题主要是需要靠用y来倒推（这点很坑，卡了很久）
不说了，直接上代码（不喜勿喷）
```c
#include<bits/stdc++.h>
#define Big 2005
using namespace std;
double a[Big][Big],d[Big],maxn;
int t[Big];
int n,m,x,y,k;
void Read();
void Dijkstra(int x);
int main()
{
	Read();
	Dijkstra(x);
	return 0; 
}
void Read()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int j,k;
		scanf("%d%d",&j,&k);
		scanf("%lf",&a[j][k]);//从k到j所需的费用 
		a[j][k]=(100-a[j][k])/100;
		a[k][j]=a[j][k];//反向储存 
	}
	scanf("%d%d",&x,&y);	
}
void Dijkstra(int x)
{
	for(int i=1;i<=n;i++) d[i]=a[x][i];
	d[x]=1;//初始化d数组 
	t[x]=1;//将初始位置的桶标记已用 
	for(int i=1;i<n;i++)
	{
		maxn=0;//找最大 
		for(int j=1;j<=n;j++)
			if(!t[j]&&maxn<d[j])//如果没有被访问且大于最大值就更改 
			{
				k=j;//记录
				maxn=d[j];
			}
		t[k]=1;
		if(k==y) break;//已经到y了，直接输出答案 
		for(int j=1;j<=n;j++)//松弛操作
			if(!t[j]&&d[k]*a[k][j]>d[j]) d[j]=d[k]*a[k][j];
	}
	printf("%.8lf",100/d[y]);//经典的printf()偷懒输出
}
```

---


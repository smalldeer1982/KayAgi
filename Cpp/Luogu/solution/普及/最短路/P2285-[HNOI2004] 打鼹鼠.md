# [HNOI2004] 打鼹鼠

## 题目描述

鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 $n \times n$ 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果 $i$ 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 $(i, j)$ 的网格移向 $(i-1, j), (i+1, j), (i, j-1), (i, j+1)$ 四个网格，机器人不能走出整个 $n \times n$ 的网格。游戏开始时，你可以自由选定机器人的初始位置。

现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。


## 样例 #1

### 输入

```
2 2	         
1 1 1		
2 2 2
```

### 输出

```
1
```

# 题解

## 作者：SIXIANG32 (赞：48)

这道题好像是我 19 年在 ** 机构试听的时候给做的题。~~woc 我当时连红题都切不稳让我做蓝~~  
现在再看这道题刚开始我只想到了三维状态，看到题解的一维状态恍然大悟 Orz 各路神仙先。  
闲话少说，切入正题——  

---
首先这道题我们显然会想到 $f_{t,x,y}$ 表示在 $t$ 这个时间节点中身处 $(x,y)$ 这个地方最多能打多少鼹鼠。  
然后我们四连通填表就好惹，但是，这个空间开不下去呀/fad  

所以我们要另寻捷径。我们换一种思路，设 $f_p$ 为抓鼹鼠序列以 $p$ 结尾时我们最多能抓多少小鼠。  

---
当我们确定好了状态之后，这道题已经完成了一大半了。我们先枚举 $p$ 作为起点（毕竟起点任意，能抓就抓），那么考虑转移，显然我们可以枚举一个 $i$ 为下一个我们要抓的鼹鼠。  

那么怎么判定能抓呢？我们记录不了路径啊，可是由于起点任意，所以我们可以假装在这个鼹鼠的位置，拓展我们又假装在那个鼹鼠的位置。也就是说，我们可以直接枚举一个 $i$ 作为下一个要抓的鼹鼠。  

怎么判断能不能抓到呢？我们只要算一算他们的曼哈顿距离（$\left| (x_0-x_1)\right|+\left| (y_0 - y_1)\right|$）能不能够跑（$val_p-val_i$） 就可以转移了。  

转移方程是什么呢？不难写出来是 $f_p = \max(f_p, f_i + 1)$。  

如何初始化呢？因为我们枚举的 $p$ 作为起点可以抓所以 $f_p = 1$。  

最后的答案可能不一定是 $f_m$，因为不一定这就是最大的，要从头到尾在枚举一遍才行。  

---
上代码：  
```cpp
#include <iostream> 
#include <cmath>
#define MAXN 100000
using namespace std;
struct node {
	int x, y, val;
}in[MAXN + 10];
int n, m, f[MAXN + 10], ans = 0;
int max(int x, int y) {return ((x > y) ? (x) : (y));}
int dist(int x, int y, int xx, int yy) {//计算曼哈顿距离
	return abs(x - xx) + abs(y - yy);
}
int main() {
	cin >> n >> m;
	for(int p = 1; p <= m; p++)
		cin >> in[p].val >> in[p].x >> in[p].y;
	for(int p = 1; p <= m; p++) {
		f[p] = 1;
		for(int i = 1; i < p; i++)
			if(dist(in[p].x, in[p].y, in[i].x, in[i].y) <= in[p].val - in[i].val)//是否可以转移
				f[p] = max(f[p], f[i] + 1);
	}	
	for(int p = 1; p <= m; p++)//求最大值
		ans = max(ans, f[p]);
	cout << ans << endl;
}
```

---

## 作者：Konnyaku_ljc (赞：25)

显而易见，本题需要用DP解决。  
为更好的理解，读完题后，就自己去造了个数据——
```cpp
4 5
1 1 1
2 4 3
3 2 3
4 4 1
5 1 4
```
如图所示  
![](https://cdn.luogu.com.cn/upload/image_hosting/17g5knpb.png)   
在指定的时间内可以到达的有——  
1 -> 3 , 1 -> 4 , 1 -> 5 , 2 -> 4 , 2 -> 5 , 3 -> 5。  
##### STEP 1 
易发现，若 A 能到 B ， B 能到  C ，那么 A 一定能到 C 。  
所以，在进行预处理之后，用类似于 FLoyd 的松弛操作便能达成我们的目的。  
但是此时，O(N^3) 的时间复杂度与 10000 的二维数组将时间和空间都爆掉了。。。  
##### STEP 2
看着看着，我发现若将预处理第一维进行倒序循环，便可以将时间复杂度降到 O(N^2) ，本意就是若 C 能到 B  ， B 能到 A ，那么 A 便能经过 3 个点。  
现在，只要将dp降到一维，就可以完美AC了！  
##### STEP 3
秃然发现突破点——不管 dp[A] 现在是多少，只要 A 能达到 B 那么  
$dp_A$ $=$ $max$($dp_B$+1,$dp_A$)  
降维成功！此时答案只要取最大值就好了。  

贴代码
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int M = 1e4+5;
int n,m,dp[M],ans;
struct node{
	int t,x,y;
}a[M];//存位置结构体 
int main()
{
	cin >> n >> m;
	for ( int i = 1;i <= m; i++ )
	{
		dp[i] = 1;//开始，所有位置都能达到它自己 
		scanf ("%d%d%d",&a[i].t,&a[i].x,&a[i].y);
	}
	for ( int i = m; i > 1; i-- )
	    for ( int j = i-1; j >= 1; j-- )
	    {
	    	if (a[i].t-a[j].t>=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y))
	    	{
	    		dp[j] = max(dp[i]+1,dp[j]);
	    		//若在规定时间内i能达到j，dp更新 
			}
		}
	for ( int i = 1; i <= m; i++ ) 
	{    
	    ans = max(dp[i],ans);
	    //结果取最大值，达到点最多 
	} 
	printf ("%d",ans);//输出 
	return 0;
}
```
###### ACCEPT！

---

## 作者：ShineEternal (赞：19)

每次打鼹鼠的机器人总是从某一次打鼹鼠的地方走过来的

对鼹鼠出现时间从小到大排序

f[i]表示到第i个鼹鼠（打第i个）最多能打多少个鼹鼠

$f[i]=max(f[j]+1)$ 要求$|xj-xi|+|yj-yi|<=time[i]-time[j]$

时间复杂度$O(m^2)$

# [代码](https://blog.csdn.net/kkkksc03/article/details/83239130)


---

## 作者：Exber (赞：9)

## 做法
这道题很明显是一个披着狼皮的最长不下降子序列。

首先我们知道 $time_i$ 是升序给出的，所以可以用 $dp_i$ 表示以第 $i$ 只鼹鼠结尾的打鼹鼠序列最多能打到多少只鼹鼠，最后对整个 DP 数组求一下 $\max$ 输出就行了。

那么运用最长不下降子序列求解的思想，枚举 $i$ 前面的每一只鼹鼠，如果可以从第 $j$ 只鼹鼠的位置走到第 $i$ 只鼹鼠的位置，那么就可以把第 $i$ 只鼹鼠接到以第 $j$ 只鼹鼠结尾的打鼹鼠序列上去，更新 $dp_i$。

那么怎样判断是否可以从第 $j$ 只鼹鼠的位置走到第 $i$ 只鼹鼠的位置呢？由于机器人不能斜着走，所以两只鼹鼠之间的距离就是 $\left|x_i-x_j\right|+\left|y_i-y_j\right|$。如果两只鼹鼠之间的距离小于等于 $t_i-t_j$，那么就走得到，反之就走不到。

## AC 代码
```cpp
#include <iostream>
#include <cmath>
#include <cstdio>

using namespace std;

struct node
{
	int t,x,y;
}mou[10005];

int n,m,ans=-1e9,dp[10005];

int main()
{
	scanf("%d%d",&n,&m); // n 其实没啥用 
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&mou[i].t,&mou[i].x,&mou[i].y);
	}
	for(int i=1;i<=m;i++)
	{
		dp[i]=1; // 以第 i 只鼹鼠结尾的打鼹鼠序列 
		for(int j=1;j<i;j++) // 枚举前面的鼹鼠 
		{
			int ddx=abs(mou[i].x-mou[j].x);
			int ddy=abs(mou[i].y-mou[j].y);
			int len=ddx+ddy;            // 距离 
			int time=mou[i].t-mou[j].t; // 可用时间 
			if(time>=len) // 走得到 
			{
				dp[i]=max(dp[i],dp[j]+1); // 接上去 
			}
		}
		ans=max(ans,dp[i]); // 求解答案 
	}
	printf("%d\n",ans); 
	return 0;
}
```


---

## 作者：circlegg (赞：8)

动态规划

从题目中可以发现是一个时间递增的过程，所以只要是在后面的点都是后出现的，换句话说，在条件达成时，前面的点可以到达后面的点，求最长的一条链，非常的像LIS（最长上升子序列），只是将 f[i]>=f[j] 的条件变为 abs(x[i]-x[j])+abs(y[i]-y[j])<=t[i]-t[j] 即可

但是此题不可以用 LIS 的优化，变为 nlogn 的复杂度，因为此题的序列没有传递性。

比如 LIS 中 a,b,c 三个数 a<b,b<c 则 a<c 。但是此题没有这个规律，所以不能进行优化。但是可以通过 break 来减少时间

定义数组 mx ， mx[i] 表示 f[1] 到 f[i] 的最大值，所以 mx[i]>=mx[i-1] ，所以第二层循环从后向前循环，如果 mx[j]+1<=f[i] 那说明之后就没有状态可以转移了，就 break

···
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
int n,m,f[10005],x[10005],y[10005],t[10005],ans,mx[10005];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&t[i],&x[i],&y[i]);
        f[i]=1;
    }
    mx[1]=1;
    for(int i=2;i<=m;i++){
        for(int j=i-1;j>=1;j--){
            if(mx[j]+1<=f[i]){
                break;
            }
            if(abs(x[i]-x[j])+abs(y[i]-y[j])<=t[i]-t[j]){
                f[i]=max(f[i],f[j]+1);
            }
        }
        mx[i]=max(mx[i-1],f[i]);
        ans=max(ans,f[i]);
    }
    printf("%d\n",ans);
    return 0;
}
···
```

---

## 作者：kradcigam (赞：5)

首先，坐标为 $(x,y)$ 到坐标为 $(a,b)$ 的网格需要的时间为 $|x-a|+|y-b|$

由于题目已经自动帮我们按时间排好序了，所以，我们可以直接 $dp$

考虑背包

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct node{
	int t,x,y;
}a[10010];
ll n,k,dp[10010];
int main(){
	cin>>n>>k;
	for(int i=1;i<=k;i++){
		ll x,y,z;cin>>x>>y>>z;
		a[i].t=x;a[i].x=y;a[i].y=z;
	}
	for(int i=1;i<=k;i++){
		dp[i]=1;
		for(int j=1;j<i;j++){
			int z=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y);
			if(a[j].t+z<=a[i].t)dp[i]=max(dp[i],dp[j]+1);
		}
	}ll ans=0;
	for(int i=1;i<=k;i++)ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：1517460958dyc (赞：5)

# 想法很简单，但实现很f**k（不能骂脏话）
#### 和大家一样，都是对每只鼹鼠进行转移，O(m^2)。没有像某些大佬一样用mx数组，而是加了一个存下标的~~（毒瘤）~~链表，其中的元素（即ans数组下标）对应ans数组的值单调不增。
#### 显然，遍历到可以更新，for循环就可以break了（此后即使有合法转移，也并未更优），然后，倒退至上一位置直至ans数组的值有变化，插入这一新答案（即在合法位置插入新答案）。
### 评测状态
#### Accepted  100
#### 用时: 34ms / 内存: 1192KB
#### 在最优解第5页（被挤出去了请联系我upd）
```cpp
#include<cstdio>
using namespace std;
int n,m,ans[10010]={},x[10010]={},y[10010]={},t[10010]={},hcnt=0;
struct node
{
    int val;
    node *prev,*next;
    node(int x=0,node *p=NULL,node *n=NULL)
    {
        val=x;
        prev=p;
        next=n;
    }
}fakeheap[10010];
inline int iabs(int x)
{
    return (x>0)? x:-x;
}
inline int read()
{
    int x=0;
    char c=getchar();
    while (c<'0'||c>'9')
        c=getchar();
    while (c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x;
}
int main()
{
    n=read();m=read();
    for (register int i=1;i<=m;++i)
        t[i]=read(),x[i]=read(),y[i]=read();
    ans[0]=10001;
    ans[1]=1;
    fakeheap[0]=node(0,NULL,&fakeheap[1]);
    fakeheap[1]=node(1,&fakeheap[0],&fakeheap[10001]);
    fakeheap[10001]=node(0,&fakeheap[1],NULL);
    hcnt=1;
    int ansmax=1;
    #define abs iabs
    #define tail (&fakeheap[10001])
    for (register int i=2;i<=m;++i)
    {
        bool flag=1;
        for (register node *p=fakeheap[0].next;(p->next)!=NULL;p=p->next)
            if ((t[i]-t[p->val])>=(abs(x[i]-x[p->val])+abs(y[i]-y[p->val])))
            {
                ans[i]=ans[p->val]+1;
                if (ans[p->val]==ans[fakeheap[0].next->val])
                    ansmax=ans[i],p=fakeheap[0].next;
                while (ans[p->prev->val]==ans[p->val])
                    p=p->prev;
                fakeheap[++hcnt]=node(i,p->prev,p);
                p->prev->next=&fakeheap[hcnt];
                p->prev=&fakeheap[hcnt];
                flag=0;
                break;
            }
        if (flag)
            fakeheap[++hcnt]=node(i,tail->prev,tail),tail->prev->next=&fakeheap[hcnt],tail->prev=&fakeheap[hcnt],ans[i]=1;
    }
    printf("%d",ansmax);
    return 0;
}
```

---

## 作者：cyffff (赞：4)

# P2285 [HNOI2004]打鼹鼠
#### [_传送门_](https://www.luogu.com.cn/problem/P2285)
## 思路
由题知，一次只能向四个方向走 $1$ 步，所以从一个点（$x1,y1$）到另一个点（$x2,y2$）的最短距离则为这两个点的**曼哈顿距离**（$abs(x1-x2)+abs(y1-y2)$）。

如果 $t1$ 在（$x1,y1$）有一只鼹鼠,$t2$（$t1<=t2$）在（$x2,y2$）有一只鼹鼠,则 $t2-t1\leqslant abs(x1-x2)+abs(y1-y2)$ 时可以打到两只鼹鼠，否则只能打一只。

有了这个思路，我们可以写出一个简单的 $dp$，类似于最长上升子序列，此值便为答案。

由于要打到这只鼹鼠必须在这个时间站在这只鼹鼠的点，所以这个操作无后效性，$dp$ 不会出错。

$code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int n,m,t,x,y,ans,dp[N],maxn;
struct node{
	int x,y,t;
}a[N];
inline int read(){
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
	return x*f;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		a[i].t=read(),a[i].x=read(),a[i].y=read();
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<i;j++){
			if(abs(a[i].t-a[j].t)>=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y)){
				dp[i]=max(dp[i],dp[j]);
			}
		}
		maxn=max(maxn,++dp[i]);
	}
	printf("%d",maxn);
	return 0;
}
```
那就再见了$qwq$~

---

## 作者：Tyyyyyy (赞：3)

# 《一维DP直接水过蓝题》
看起来好像是个三维$dp$，但是仔细想一想，

定义$dp[i]$表示一个以第$i$只鼹鼠为结尾的

打鼹鼠序列可打到最多鼹鼠的数量，那么只需

要两点之间的曼哈顿距离不超过两点的时间之

差即可。

**因为时间是递增给的，甚至不需要排序。**

所以就可以推得如下方程：
```
for(int i=1;i<=m;i++)
    {
    	dp[i]=1;
    	for(int j=1;j<i;j++)
    	{
    		if(mhd(s[i].x,s[i].y,s[j].x,s[j].y)<=s[i].t-s[j].t)
		{
			dp[i]=max(dp[i],dp[j]+1);
		}
	}
	ans=max(ans,dp[i]); 
}
 ```
 (这里$mhd$函数表示求曼哈顿距离）
 
 所以说直接一维$m^2$的就过了。就过了。
 
 
 完整代码如下：（勿抄袭）
 ```
 #include<bits/stdc++.h>
using namespace std;
int n,m,dp[10010],ans;
struct node
{
	int t,x,y;
}s[10010];
int mhd(int sx,int sy,int ex,int ey)
{
	return abs(sx-ex)+abs(sy-ey);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&s[i].t,&s[i].x,&s[i].y);
	dp[0]=1;
    for(int i=1;i<=m;i++)
    {
    	dp[i]=1;
    	for(int j=1;j<i;j++)
    	{
    		if(mhd(s[i].x,s[i].y,s[j].x,s[j].y)<=s[i].t-s[j].t)
			{
				dp[i]=max(dp[i],dp[j]+1);
			}
		}
		ans=max(ans,dp[i]); 
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：AuCloud (赞：3)

挺离谱的

第一眼看：$10^4$？$N^2$悬啊

10分钟后，JZW：切了切了，$N^2$跑的挺快的

我：？？？？？？

-------

题面里给了保证时间递增，就很容易想到按时间dp

设dp[i]表示现在在i号鼹鼠的位置，最多打多少只

则有状态转移方程

$$dp_i=max(dp_j+1),dis[i][j] < t[i]-t[j]$$

$N^2$枚举j进行转移即可

# 代码

```
#include <bits/stdc++.h>
using namespace std;
struct hehe{
	int t, x, y;
}a[10001];
int f[10001];
int dis(int i, int j)
{
	return abs(a[i].x - a[j].x) + abs(a[i].y - a[j].y);
}
int main()
{
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= m; i++)
	{
		cin >> a[i].t >> a[i].x >> a[i].y;
	}
	for(int i = 1; i <= m; i++)
	{
		f[i] = 1;
		for(int j = 1; j < i; j++)
		{
			if(a[i].t - a[j].t >= dis(i, j))
				f[i] = max(f[i], f[j] + 1);
		}
	}
	int ans = 0;
	for(int i = 1; i <= m; i++)
	{
		ans = max(ans, f[i]);
	}
	cout << ans;
	return 0;
}
```

~~吐槽：这个m是真的反人类（（（~~

---

## 作者：MD_17L (赞：3)

1. 题意:
- 在一个n*n的网络中,给出m个鼹鼠出来的时间和坐标(x,y)
- 机器人每一时间只能向上,向下,向左,向右移一格
- 求出机器人最多能打的鼹鼠数量

2. 方法:
## 明显的DP
- 机器人要移到当前打鼠位置,必须从上一个打鼠位置移来
- 用f[i]表示在第i只鼹鼠出来时能打多少只鼹鼠
- 状态转移方程:f[i]=max(f[i],f[j]+1) 
- 初值:f[1]=1 无论何时必能打死一只鼹鼠
- i:2--m,j:i-1--1
- 条件:abs(x[i]-x[j])+abs(y[i]-y[j])<=abs(t[i]-t[j])
- 时间复杂度O(m^2)

3. 奇怪的优化:用res数组记录最优答案,将不优情况break

 附上代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=10005;
int f[N],t[N],x[N],y[N],res[N],ans,n,m;

 int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1; i<=m; i++) 
	{
		scanf("%d%d%d",&t[i],&x[i],&y[i]);
		f[i]=1;
	}
	res[1]=1;
	for (int i=2; i<=m; i++)
	{
		for (int j=i-1; j>=1; j--)
		{
			if (res[j]+1<f[i]) break;
			if (f[j]+1>f[i])
				if (abs(x[i]-x[j])+abs(y[i]-y[j])<=abs(t[i]-t[j]))
					f[i]=max(f[i],f[j]+1);
		}
		res[i]=max(res[i-1],f[i]);
		if (f[i]>ans) ans=f[i];
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：Deny_小田 (赞：3)

本题主要是时间。。

动规思路很好想，状态转移方程也很好想。


暂时不说这个，先说下时间。

注意：坑点，数据1，n = m = 0。

输出为2？！


我有些不太理解。


大家最好用

```cpp
#include <algorithm>
```

这个头文件里的abs和max函数，要不然可能会超时（就像我）


然后读入也没有加优化，就过了。


---

## 作者：__int (赞：2)

本题其实是求最长不下降子序列的变式，不下降的为时间，只不过并非简单地判断大小 
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename t>inline void read(t&x)
{
	int f=1;char c=getchar();x=0;
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<3)+(x<<1)+(c^48);
	if(f<0)x=-x;
}								//输入优化 
struct ys
{
	int t,x,y;
}a[10005];
int n,m,dp[10005],ans;	  //dp[i]表示出现第i只鼹鼠后最多能打爆的鼹鼠数目 
inline bool ch(ys a,ys b) //判断能否在打爆鼹鼠b后再打爆a 
{
	int s=abs(a.x-b.x)+abs(a.y-b.y);//求两鼹鼠距离 
	return s<=a.t-b.t;   			 
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;++i) 
	{
		read(a[i].t);read(a[i].x);;read(a[i].y);
		for(int j=i-1;j>=1;--j)
			if(ch(a[i],a[j])&&dp[i]<=dp[j])
				dp[i]=dp[j];
		++dp[i];
		ans=max(ans,dp[i]);
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：我是小何子啊 (赞：2)

# **这道题要用DP！**
这题想法较简单，可能是题目中“你可以自由选定机器人的初始位置”难到了一些人，其实只要把位置定在会出现鼹鼠的位置即可，接着就是去别的会出现鼹鼠的位置。

那如何判断是否能在鼹鼠出现前到达鼹鼠位置呢？很简单，直接判断两鼠出现的时间是否不小于两者的距离即可，两鼠距离就是两鼠横坐标之差+纵坐标之差，最后用方程：f[i]=max(f[i],f[j]+1);求出最多能打多少只鼹鼠

# code：
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,mx,f[10001];//mx记录最多打鼹鼠只数
struct node{
	int t,x,y;//结构体方便！
}a[10001];
int cmp(node x,node y){
	return x.t<y.t;//把时间小的排前面，好判断先后
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i) scanf("%d%d%d",&a[i].t,&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmp);//排序一下！
	for(int i=1;i<=m;++i){
		for(int j=1;j<i;++j){
			if(a[i].t-a[j].t>=abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y)){//如果能够在鼹鼠出现前到达其位置
				f[i]=max(f[i],f[j]+1);//那么打到鼹鼠的只数加一
			}
		}
	}
	for(int i=1;i<=m;++i) mx=max(mx,f[i]);//取能打到鼹鼠的最大只数
	printf("%d",mx+1);//记得原先我们选的位置上还有一只鼹鼠，只数要加一
	return 0; 
}
```


---

## 作者：玫葵之蝶 (赞：2)

看到最短路的标签，我就想试试，结果10分（笑）

我仅仅是给你们一个思路，你们可以试试，说不定能过呢？

就是如果时间差>=坐标差，就建一条边，然后若干遍SPFA，最后算出来，以下是建边代码：

```cpp
        for(int i=1;i<=m;i++){
        int t,tx,ty;
        scanf("%d %d %d",&t,&tx,&ty);
        tme[i]=t;
        x[i]=tx;
        y[i]=ty;
        for(int j=1;j<i;j++){
            int dis=abs(tx-x[j])+abs(ty-y[j]);
            if(dis<=abs(t-tme[j])){
                addedge(j,i,-1);
            }
        }
    }
```
以下是找答案的代码，SPFA的代码省去。

```cpp
        int ans=0;
    for(int i=1;i<=m;i++){
        spfa(i);
        int mn=0;
        for(int j=i;j<=m;j++){
            mn=min(mn,d[j]);
        }
        mn=abs(mn);
        if(mn>=m-i){
            ans=mn;
            break;
        }
        else{
            ans=max(mn,ans);
        }
    }
    cout<<ans;
```
希望哪个后来者可以用我的思路AC这个题吧！


---

## 作者：Dawn_Chase (赞：2)

**P党的福利**


题目里告诉我们“Time按递增的顺序给出“，这就提示了我们

——**最长不下降子序列！！**


理解了最长不下降子序列的由来后，我们便可以轻松地写出代码了。


当机器人可以达到这个点的时候，更新答案。


最后的答案便是所以最长不下降子序列的最大值。



下面贴代码

--------------------分割线---------------------

```cpp
var n,m,i,j,ans:longint;
    f,a,xx,yy:array[1..10000] of longint;
function max(x,y:longint):longint;         //返回两个数的最大值
begin
  if x>y then
   exit(x);
  exit(y);
end;
function dis(x,y:longint):longint;      //返回两个点之间，机器人需要的时间
begin
  exit(abs(xx[x]-xx[y])+abs(yy[x]-yy[y]));
end;
begin
  read(n,m);
  for i:=1 to m do
   begin
    read(a[i],xx[i],yy[i]);
    f[i]:=1;
    for j:=1 to i-1 do                  //最长不下降子序列
     if dis(i,j)<=a[i]-a[j] then
      f[i]:=max(f[i],f[j]+1);
    ans:=max(f[i],ans);
   end;
  writeln(ans);
end.
```

---

## 作者：傅思维666 (赞：1)


## 题解：

思路：最优化：想DP。

想状态：第一种状态是dp[i]表示前i个鼹鼠都被打完后的答案。但是这显然是错误的。因为前i个鼹鼠不一定都要被打。第二种状态是dp[i]表示打到第i个鼹鼠（也就是不一定前i个都被打）时，能打到的最多的鼹鼠只数。

这个貌似可以。尝试转移。

转移：判断是否能在时限内从当前位置挪到另外的位置，就是横纵坐标差绝对值的和（Manhaton曼哈顿距离）和时间差做比较，如果可以跑到这个位置，就能转移。

转移方程当然很好想：
$$
dp[i]=\max(dp[i],dp[j]+1)
$$
答案是所有dp[i]的最大值。

代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#define R register
using namespace std;
const int maxn=10010;
int n,m,ans;
int t[maxn],x[maxn],y[maxn],dp[maxn];
char *p1,*p2,buf[100000];
#define nc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0,f=1;
    char ch=nc();
    while(ch<48||ch>57)
    {
        if(ch=='-')
            f=-1;
        ch=nc();
    }
    while(ch>=48&&ch<=57)
        x=x*10+ch-48,ch=nc();
   	return x*f;
}
int main()
{
    n=read();m=read();
    for(R int i=1;i<=m;i++)
    {
        t[i]=read();x[i]=read();y[i]=read();
        dp[i]=1;
    }
    for(R int i=1;i<=m;i++)
        for(R int j=1;j<i;j++)
            if(abs(x[i]-x[j])+abs(y[i]-y[j])<=abs(t[i]-t[j]))
                dp[i]=max(dp[i],dp[j]+1);
    for(R int i=1;i<=m;i++)
        ans=max(ans,dp[i]);
    printf("%d",ans);
    return 0;
}
```


---

## 作者：秋秋秋秋秋 (赞：0)

其实题目不用动规。。楼下两个想复杂了。。

因为没有给定时间限制  只是一段时间可打的最大数

而且题目都说时间是递增的

只要前后两次的时间差大于两次的横纵坐标差的和就代表当前这个鼹鼠可以打

存个最大值

双重循环搞定


---


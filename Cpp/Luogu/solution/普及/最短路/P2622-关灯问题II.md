# 关灯问题II

## 题目描述

现有 $n$ 盏灯，以及 $m$ 个按钮。每个按钮可以同时控制这 $n$ 盏灯——按下了第 $i$ 个按钮，对于所有的灯都有一个效果。按下 $i$ 按钮对于第 $j$ 盏灯，是下面 $3$ 中效果之一：如果 $a_{i,j}$ 为 $1$，那么当这盏灯开了的时候，把它关上，否则不管；如果为 $-1$ 的话，如果这盏灯是关的，那么把它打开，否则也不管；如果是 $0$，无论这灯是否开，都不管。

现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 数据，输出无解可以得分。
- 对于 $20\%$ 数据，$n \le 5$。
- 对于 $20\%$ 数据，$m \le 20$。

上面的数据点可能会重叠。

对于 $100\%$ 数据 $n \le 10,m \le 100$。

## 样例 #1

### 输入

```
3
2
1 0 1
-1 1 0```

### 输出

```
2```

# 题解

## 作者：niiick (赞：53)

关灯问题——状态压缩经典 
 所谓状态压缩

**就是将问题可能遇到的每一个状态用一个唯一的二进制数表示**

其复杂度一般都是指数级的
 这也注定了状压类的题数据规模都不会太大
*******************************************
此题中我们以1表示开灯状态，0表示关灯状态

这样我们可以以一个**长度为n的二进制数唯一的表示每个状态**

接着就可以依靠既定的开关关系将每个状态连接起来

即将隐式图转化为显式图通过BFS最短路解决

以灯全开状态为起点

**二进制为n个1 ，十进制表示为（1<< n）-1**

开始枚举m个开关以得到接下来的m个状态

```
for(int i=1;i<=m;i++)
{
    ss=（1<< n）-1;
    for(int j=1;j<=n;j++)
    {
        if( a[i][j]==1 && (ss&(1<<j-1)) ) ss^=(1<<j-1);
        else if( a[i][j]==-1 && !(ss&(1<<j-1)) ) ss|=(1<<j-1);
    }      
}
```
**ss&(1<< j-1)**此运算用以检查**当前状态的第j位是否为1**

**1<< j-1**意思是将1左移j-1位，移动后只有第j位上是1

若开关操作为1且当前状态第j位是1 

则**ss^=(1<< j-1)**   表示 **1与1异或后得0**

若开关操作为-1且当前状态第j位是0

则**ss|=(1 << j-1)** 表示 **1或0 后得1** （此处异或操作也对，因为**1异或0得1**）

之后便用相同的方法在得到的每个状态上再不断搜索每个状态

由于是BFS，所以一旦某一步**状态表示为0**（十进制二进制的0写法都是0）

则当前步数必定是最短操作数

若遍历完所有状态都没有0，则输出-1

**记得搜索过的状态要打vis标记避免重复访问**

****************************************************

```
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

void print(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>9)print(x/10);
    putchar(x%10+'0');
}

int n,m;
int a[110][1010];
struct node{int s,step;};//s存储状态，step存储当前步数
bool vis[1000010];

int spfa()
{
    int ss;
    queue<node> q;
    q.push( (node) {(1<<n)-1,0} );
    vis[(1<<n)-1]=true;//以全开为初始状态，二进制为n个1，十进制如代码
    
    while(!q.empty())
    {
        node u=q.front();
        q.pop();
        if(u.s==0){return u.step;}//若状态为0，则返回当前步数
        
        for(int i=1;i<=m;i++)
        {
            ss=u.s;
            for(int j=1;j<=n;j++)//由于开关对所有灯都影响，所以每个灯都遍历
            {
                if( a[i][j]==1 && (ss&(1<<j-1)) ) ss^=(1<<j-1);
                else if( a[i][j]==-1 && !(ss&(1<<j-1)) ) ss|=(1<<j-1);
            }//位运算解释如上文本
            
            if(!vis[ss])//若该状态未访问，就加入队列
            {
                q.push( (node) {ss,u.step+1} );
                vis[ss]=true;
            }
        }
    }
    return -1;
}

int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
    a[i][j]=read();//保存每个开关操作对灯的影响
    
    print(spfa());
    return 0;
}
```

---

## 作者：pzc2004 (赞：23)

[题目传送门](https://www.luogu.org/problem/P2622)

这道题我用的是记忆化BFS。

用状态压缩将每盏灯的开关压为一个数字（1表示开，0表示关）。

用$f_i$表示从初始状态（即$2^n-1$）状态到达状态i时的最少步数，因为是BFS，所以一开始搜到的即是最少的步数，一搜到0时便输出当前步数并退出，如果搜完了所有能搜到的状态也搜不到0便输出-1。

对于每个状态，将每个开关都试一遍，如果得到了新的状态就推入队列。

对于每个开关，如果$a_{i,j}$是1，就将该状态&上$2^n-1-2^{j-1}$，如果是0就跳过，如果是-1，就将该状态|上$2^{j-1}$。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[101][11],f[4096];//f[i]表示从初始状态到达状态i的最少步数
queue<int>q;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)for(int j=1;j<=n;j++)scanf("%d",&a[i][j]);
	for(int i=0;i<=(1<<n)-1;i++)f[i]=9999;//初始化
	f[(1<<n)-1]=0;
	q.push((1<<n)-1);
	while(!q.empty())
	{
		int b=q.front();
		q.pop();
		for(int i=1;i<=m;i++)//每个开关都试一遍
		{
			int x=b;
			for(int j=1;j<=n;j++)
			{
				if(a[i][j]==0)continue;
				if(a[i][j]==1)x&=(1<<n)-1-(1<<(j-1));
				if(a[i][j]==-1)x|=1<<(j-1);
			}
			if(x==0){printf("%d",f[b]+1);return 0;}//因为是BFS，所以第一次搜到的一定是最小的，直接输出并退出
			if(f[b]+1<f[x])//如果该状态还未到达过，就推入队列并更新该状态
			{
				f[x]=f[b]+1;
				q.push(x);
			}
		}
	}
	printf("-1");//无解则输出-1
}
```
![](https://www.luogu.org/images/congratulation.png)

---

## 作者：浅色调 (赞：23)

### Solution：

　　本题状压dp~~水题~~。

　　定义$f[j]$表示当前灯的状态为$j$的最小花费，初始状态$f[0]=0$，目标状态$f[(1<<n)-1]$（$0$为开，$1$为关）。

　　用$a_i,b_i$记录下每个按钮的开关效果，然后跑最短路，转移时就二进制捣鼓一下。

　　具体来说，若$(i,j)$输入的$x==1$则$a_i|=1<<(j-1)$，若输入的$x==-1$则$b_i|=1<<(j-1)$。

　　转移时当前状态$sta$转移为$(sta|a_i)\&(\thicksim b_i)$就能做到灯的开关变换了。
  
$\quad\;\;$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9853076.html)（蒟蒻写题解不易，转载请注明出处，万分感谢～！）

### 代码：
```cpp
/*Code by 520 -- 10.16*/
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define RE register
#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
using namespace std;
const int N=105;
int n,m,a[N],b[N],f[1<<11];
bool vis[1<<11];
queue<int>q;

int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m; int x,lim=(1<<n)-1;
	For(i,1,m) For(j,1,n) {
		cin>>x;
		if(x==1) a[i]|=(1<<j-1);
		if(x==-1) b[i]|=(1<<j-1);
	}
	memset(f,0x3f,sizeof(f));
	f[0]=0;q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		For(i,1,m) {
			int sta=(u|a[i])&(~b[i]);
			if(f[sta]>f[u]+1) {
				f[sta]=f[u]+1;
				if(!vis[sta]) vis[sta]=1,q.push(sta);
			}
		}
	}
	cout<<(f[lim]==0x3f3f3f3f?-1:f[lim]);
	return 0;
}
```

---

## 作者：Kevin_Zhen (赞：19)

## $\mathfrak{bfs}$ 详解
题目链接 [$\mathfrak{P2622}$](https://www.luogu.com.cn/problem/P2622)。

### 题目大意
你有 $n$ 盏灯、$m$ 个按钮。状态 $a[i][j]$ 表示，按下第 $i$ 个按钮会对第 $j$ 盏灯如何操作。按下第 $i$ 个按钮，如果 $a[i][j]=1$，判断第 $j$ 盏灯是否开着，如果开着就关掉；如果 $a[i][j]=-1$，判断第 $j$ 盏灯是否关着，如果关着就打开。  

问你令所有灯全部关闭的最少步数。

### 为何此题状压 $\mathfrak{dp}$ 不应是正解？
下面给出证明。

在写状压 $dp$ 时，我们设 $now$ 为按完开关后所有灯的状态，$i$ 为原状态。  
因为初始状态是全 $1$，询问状态是全 $0$，所以需要倒序枚举 $i$。  

求出来 $now$ 之后用 $f[i]$ 更新 $f[now]$ 的值，因为 $dp$ 的无后效性，$f[i]$ 的值应是已经确定的，即 $i$ 的值应比 $now$ 大。但是在此题，显然我们算出来的 $now$ 的值既可能比 $i$ 小，也可能比 $i$ 大，所以无法保证无后效性，不应选用 $dp$ 的做法。

### 思路
此题要求最少步数。对于每一个状态，我们进行相应的操作，直到找到所有灯全部关闭，即全 $0$ 的状态。显然可以 $bfs$。

**介绍一下变量：**  
$a[i][j]$：如题，记录按下第 $i$ 个按钮对第 $j$ 盏灯进行的操作。  
$vis[ttx]$：记录状态 $ttx$ 是否入队过（即是否得到过状态 $ttx$）。  
$step[ttx]$：记录状态 $ttx$ 是第几步得到的。  
因为此题 $n<=10$，即最多有 $10$ 盏灯，所以状压最大值（全 $1$ 时）为 $2^{10}-1=1023$，数组开 $2000$ 足够够的了。

**第一步：处理输入。**  
没啥好说的，**代码实现如下：**  
```cpp
scanf("%d%d", &n, &m);
for (int i = 1; i <= m; ++i) {
	for (int j = 1; j <= n; ++j) {
		scanf("%d", &a[i][j]);
	}
}
```
注意 $n$ 为灯数，$m$ 为按钮数。

**第二步：初始状态入队。**  
把全 $1$ 的状态入队，并将其 $vis$ 值修改为 $true$。如何得到全 $1$ 的状态呢？  
手玩一下，设 $n=4$。  
首先，我们求一下 $1<<n$，得到：
```cpp
1 0 0 0 0
```
然后我们将这个值 $-1$，得到：
```cpp
0 1 1 1 1
```
这就是我们想要的初始状态。  
推而广之，我们的初始状态就应是 $(1<<n)-1$。注意运算符的优先级，此处应加括号。  
**代码实现如下：**  
```cpp
q.push((1 << n) - 1);
vis[(1 << n) - 1] = true;
```

**第三步：$bfs$ 主体。**  
首先拿出队头，队头出队：
```cpp
int tx = q.front(); q.pop();
```
然后判断一下，如果队头状态是全 $0$，输出队头的 $step$ 值：
```cpp
if (!tx) { printf("%d", step[tx]); return 0; }
```
如果队头状态不是全 $0$，我们就需要遍历全部的 $m$ 个按钮，然后将得到的新状态入队。  
对于每一盏灯的操作应如何用位运算表示？还是手玩一下。  
需要提前声明的是，为了在写代码时便于思考，我们**用最低位表示第 $1$ 盏灯，高位依次类推**。即，状态：
```cpp
0 0 0 1 0
```
表示第 $2$ 盏灯开着，其他的灯都关着。  
**假设：**$n=5$，我们已经遍历到了第 $i$ 个按钮，正在对第 $2$ 盏灯进行操作。  
**先模拟关灯的操作：**  
假设 $a[i][2]=1$，初始状态如下：
```cpp
1 0 1 1 0
```
我们要把第 $2$ 位置为 $0$。因为 $\&1$ 原值不变，$\&0$ 原值置 $0$，可以将原序列如下操作：
```cpp
  1 0 1 1 0
& 1 1 1 0 1
-------------
  1 0 1 0 0
```
推而广之，将序列 $ttx$ 第 $j$ 位置为 $0$，可以如下操作：
```cpp
ttx &= ~(1 << (j - 1));
```
**再模拟一下开灯的操作：**  
假设 $a[i][2]=-1$，初始状态如下：
```cpp
1 0 1 0 0
```
我们要把第 $2$ 位置为 $1$。因为 $|0$ 原值不变，$|1$ 原值置 $1$，可以将原序列如下操作：
```cpp
  1 0 1 0 0
| 0 0 0 1 0
-------------
  1 0 1 1 0
```
推而广之，将序列 $ttx$ 第 $j$ 位置为 $1$，可以如下操作：
```cpp
ttx |= 1 << (j - 1);
```
然后我们就得到了修改后的新状态。判断一下新状态是否已经入队，如果没有就将新状态入队，并修改 $vis$ 和 $step$ 的值。**代码实现如下：**
```cpp
if (!vis[ttx]) q.push(ttx), vis[ttx] = true, step[ttx] = step[tx] + 1;
```

**第四步：输出无解情况。**  
如果 $bfs$ 结束，程序仍然没有结束，说明无解。输出 $-1$ 即可。
```cpp
printf("-1");
```

### AC CODE
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

int n, m;
int a[110][15];
bool vis[2000];
int step[2000];
queue<int> q;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++i) {
		for (int j = 1; j <= n; ++j) {
			scanf("%d", &a[i][j]);
		}
	}
	q.push((1 << n) - 1);
	vis[(1 << n) - 1] = true;
	while (q.size()) {
		int tx = q.front(); q.pop();
		if (!tx) { printf("%d", step[tx]); return 0; }
		for (int i = 1; i <= m; ++i) {
			int ttx = tx;
			for (int j = 1; j <= n; ++j) {
				if (a[i][j] == 1 && (tx & (1 << j - 1))) ttx &= ~(1 << (j - 1));//此处判断 ttx & (1 << j - 1) 亦可，因为当前位置 j 的值并未被修改 
				if (a[i][j] == -1 && !(tx & (1 << j - 1))) ttx |= 1 << (j - 1);
			}
			if (!vis[ttx]) q.push(ttx), vis[ttx] = true, step[ttx] = step[tx] + 1;
		}
	}
	printf("-1");
	return 0;
}
```
## 感谢观赏！

---

## 作者：MarsTraveller (赞：10)

提供一种 **状压 DP** 的写法。


**Hack 数据貌似是专门卡这个的，不过这题用此方法是完全可以的。**

普通状压写法由于**有后效性**会被卡掉，所以我们能否**去除**这样的后效性呢？

观察到，此题后效性主要为：

从状态 $i$ 按按钮变为状态 $st$ 时，可能会出现 $st < i$ 的情况。

**由于从小到大枚举，此时的 $st$ 会被遗漏，导致原本可能实现的方案无法实现。**

考虑一种极端情况，按下一个按钮后，**状态变为较大值**。接下来按按钮**每次都会使状态变小**，最后一次按按钮从极小值变为最终状态，此时答案为 $m$。

这种情况有什么特点呢？

这样的情况告诉我们，最多只会出现 $m$ 次 $st<i$ 的情况，所以我们只需要在普通 DP 的做法最外层加一个 $m$ 次的循环（也就是重复做 $m$ 次 DP），这样子每次都会重新枚举到上一次被忽略的状态 $st$，排除后效性。

```cpp
#include <iostream>
#include <cstring>
#define big long long
using namespace std;
const big INF = 1e18;
big n,m,dp[(1<<12)+5],a[1000][1000];
int main()
{
	cin >> n >> m;
	for(big i = 1;i <= (1<<n);i++)
	{
		dp[i] = INF;
	}
	for(big i = 1;i <= m;i++)
	{
		for(big j = 1;j <= n;j++)
		{
			cin >> a[i][j];
		}
	}
	// 1：关
	// 0：开
	// 用逆序存储，即从低到高位表示1~n盏灯（可以方便左移与右移）
	for(big x = 1;x <= m;x++) // 排除后效性 
	{
		for(big i = 0;i < (1<<n);i++) // 枚举灯的状态 
		{
			for(big j = 1;j <= m;j++) // 枚举按了第几个按钮 
			{
				big st = i;
				for(big k = 0;k < n;k++) // 枚举第 (k+1) 个灯按这个按钮后的状态 
				{
					// 更新状态 
					if(a[j][k+1] == 1)
					{
						if(!((1<<k)&i))
						{
							st = st^(1<<k);
						}
					}
					if(a[j][k+1] == -1)
					{
						if((1<<k)&i)
						{
							st = st^(1<<k);
						}
					}
				}
				dp[st] = min(dp[st],dp[i]+1); // 转移 
			}
		}
	}
	
	if(dp[(1<<n)-1] == INF)
	{
		printf("-1");
	}
	else
	{
		printf("%lld",dp[(1<<n)-1]);
	}
	return 0;
}
```

---

## 作者：早右昕 (赞：6)

####广搜，~~难度估高了~~（仅作参考）

另外，数据巨坑，好像a[i][j]除了1,-1,0还有其他数，所以第一二次打成```else if(a[i][j]&&!(nxt.x&(1<<j))) nxt.x|=(1<<j);```就爆了，应该为```else if(a[i][j]==-1&&!(nxt.x&(1<<j))) nxt.x|=(1<<j);```
好了，看代码：

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
int n,m,a[100][10];
bool vis[1<<11];
struct pii {int x,s;};
queue<pii>que;
void out(int x,int dep)//输出二进制用 
{
    if(dep==n) putchar('\n');
    if(!dep)  return ;
    out(x/2,dep-1),printf("%d",x%2);
}
int bfs(int st)//模版打法 
{
    que.push((pii) {st,0});
    vis[st]=1;
    pii now,nxt;
    while(!que.empty()) {
        now=que.front();
        que.pop();
        nxt.s=now.s+1;
        for(int i=0; i<m; i++) {
            nxt.x=now.x;
            for(int j=0; j<n; j++)
                if(a[i][j]==1&&(nxt.x&(1<<j))) nxt.x^=(1<<j);
                else if(a[i][j]==-1&&!(nxt.x&(1<<j))) nxt.x|=(1<<j);
            if(!nxt.x) return nxt.s;//end是000...（n位） 
            if(vis[nxt.x]) continue;
            vis[nxt.x]=true,que.push(nxt);
        }
    }
    return -1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++)
            scanf("%d",&a[i][j]);
    }
    printf("%d\n",bfs((1<<n)-1));//st初始化为111...（n位） 
    return 0;
}
```cpp
至此，问题完美解决


---

## 作者：PBCWZCC (赞：3)

发现好多$\mathcal{DALAO}$都在用`A[i][j]`数组啊，为什么不把$A$的第二维也压缩一下呢？

这题是一道状态压缩的经典题，所有灯的亮$(1)$暗$(0)$可以用一个二进制数表示；正常的做法就是在每次操作中遍历每一个灯的处理，用$\mathrm{DP}$，或者别出心裁的最短路算法即可完美通过此题。

但是，在某一次操作中，我们可不可以在$\mathrm{O(1)}$的时间里一次性处理完所有的灯呢？

研究开关灯操作，不难发现，如果将所有灯的状态用一个$01$串表示，

$$\mathsf{\text{操作序列中的}}\ 1\ \mathsf{\text{就表示把}}01\mathsf{\text{串中的}}1\mathsf{\text{变为}}0$$

$$\mathsf{\text{操作序列中的}}-\!1\ \mathsf{\text{就表示把}}01\mathsf{\text{串中的}}0\mathsf{\text{变为}}1$$

$$\mathsf{\text{操作序列中的}}\ 0\ \mathsf{\text{对}}01\mathsf{\text{串没有影响}}$$

我们这里先将一次操作中的开灯和关灯分开考虑。看到操作数$-1$对应的操作，我们就可以~~很自然地~~想到或运算，也就是把指定位置的灯$(0/1)$变成$1$；而操作数$1$就表示把指定位置的灯$(0/1)$变成$0$。

于是，我们有了这样的转换：

```cpp
原操作
-1 0 1
处理之后
100 // 这个是开灯操作，让指定位置（操作序列中是 1 的位）的灯变成打开的（如果已经是了也没有影响）；通过对原01串进行 或·运·算 实现
110 // 这个是关灯操作，让指定位置（操作序列中是 0 的位）的灯变成关闭的（如果已经是了，同上）；通过对原01串进行 与·运·算 实现
```

然后，用一个二维数组$opt[i][0/1]$来存储这些操作串，按照上面说的方式处理即可。

这里代码使用的是$\mathrm{DFS+}$记忆化，记录的是搜索的深度（也就是已进行的操作的次数）。

同时注意，同一个操作连续重复多次与一次的效果相同，因此在搜索时要注意避免连续选择同一个操作。

附上源码：
```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#define PBCWZCC
using namespace std;
#define MAXN 130
#define MAXM 100
#define MAXSQR 5000
#define LL long long
#define DEBUG
#define MODIT
template<class T>inline void read(T&X)
{
    X=0;
    char symbol('\0'),ch(getchar());
    for(;ch<'0'||'9'<ch;(ch=='-')?(symbol='\1'):(1),ch=getchar());
    for(;'0'<=ch&&ch<='9';X=(X<<3)+(X<<1)+(ch^48),ch=getchar());
	(symbol)?(X=-X):(1);
}
int n,m;
int opt[MAXM+3][2];
int F[MAXSQR];
char ifsuc;
void dfs(int now,int pre/*上一次操作的编号*/,int dd)
{
	if(!now)
	{
		ifsuc = '\1';
		return;
	}
	int i,vv;
	for(i=1;i<=m;++i)
	{
		if(!(i^pre)) continue;
		vv = (now|opt[i][0])&opt[i][1];
		if(dd<F[vv])
		{
			F[vv] = dd;
			dfs(vv,i,dd+1);
		}
	}
}
int main()
{
	memset(F,0x3f,sizeof F);
	int i,j,x;
	read(n);
	read(m);
	for(i=1;i<=m;++i)
	{
		for(j=n-1;0<=j;--j)
		{
			read(x);
			(x<=0)?
			(opt[i][1] |= (1<<j) , (x)?(opt[i][0] |= (1<<j)):(1) ):
			(1);
		}
	}
	dfs((1<<n)-1,0,1);
	printf("%d\n",(ifsuc)?(F[0]):(-1));
	return 0;
}

```
这种搜索比$\mathrm{DP}$略慢，不吸氧跑了$80\mathrm{ms}$





---

## 作者：_D06 (赞：3)

1. 状压DP+随机化
1. 设f[i][j]表示已经决定前j盏灯的开关，当前状态为i的最少按按钮次数，则有状态转移方程f[i][j]=min(f[i][j-1],f[k][j-1]+1),初始化f[(1<<n)-1][0]=0。
1. 以上状态转移方程是有后效性的，但是它的出错概率不高，于是我们可以每次随机交换两盏灯，运行一次状压DP，取最优值作为答案，这样出错的概率会降低，代码中随机了500次即可得到正确答案。（需要注意的是，随机次数太多会时间超限，太少会答案错误）
1. 代码：
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
int a[105][105];
int f[3005][105];
int main()
{
    int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
		}
	} 
	int ans=INT_MAX;
	srand(time(NULL));
	for(int t=1;t<=500;t++)
	{
		int a1,b1;
		a1=rand()%m+1;
		b1=rand()%m+1;
		for(int j=1;j<=n;j++)
		{
			swap(a[a1][j],a[b1][j]); 
		}//随机处理
		memset(f,0x3f,sizeof(f));
		f[(1<<n)-1][0]=0;
		for(int j=1;j<=m;j++)
		{
			for(int i=0;i<(1<<n);i++)
			{
				f[i][j]=f[i][j-1];
				int k=i;
				for(int l=1;l<=n;l++)
				{
					if(a[j][l]==1&&((i>>(l-1))&1)==0)
					{
						k=k|(1<<(l-1)); //把第(l-1)位赋值为1
					}
					if(a[j][l]==-1&&((i>>(l-1))&1)==1)
					{
						k=k&(~(1<<(l-1))); //把第(l-1)位赋值为0
					}
				}
				f[i][j]=min(f[i][j],f[k][j-1]+1);
			}
	    }
		if(f[0][m]>m)
		{
	
		}
		else
		{
			ans=min(ans,f[0][m]);
		}
	}
	if(ans==INT_MAX)
	{
		cout<<-1<<endl;
	}
	else
	{
		cout<<ans<<endl;
	}
    return 0;
}
```




---

## 作者：jins3599 (赞：2)

本来是奔着状压$dp$来的...结果发现没必要$dp$..

一个很显然的思路就是，二进制压缩一下灯的状态，然后用`bfs`求最小步数。

我们发现复杂度是可以忍受的，而且这样写还比较优美。

考虑最大状态$2^{10}$很小，直接用数组就能判重。

$2$操作很简单，直接`tans |= (1 << (i - 1))`即可

然后对于$1$操作，我们可以把状态取反之后当成操作$2$，完成之后再取反即可。

于是这道题就完成了。

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

int n , m;
int a[100][105];
bool vis[2005];

int change (int s , int opt) {
	int now = s;
	for(int i = 1 ; i <= n ; ++ i) {
		if(a[opt][i] == 1) {
			if(now & (1 << (i - 1))) {
				now = ~now;
				now |= (1 << (i - 1));
				now = ~now;
			}
		}  
		if(a[opt][i] == -1) now |= (1 << (i - 1));  
	}
	return now;
}

void Bfs() {
	queue <pair<int , int> > q;
	int sta = 0;
	sta |= (1 << n); sta -= 1;
	vis[sta] = 1;
	q.push(make_pair(sta , 0));
	while(!q.empty()) {
		int now = q.front().first;
		int dep = q.front().second; q.pop();
		if(now == 0) {
			printf("%d\n" , dep); return;
		}
		for(int i = 1 ; i <= m ; ++ i) {
			int nxt = change(now , i);			

			if(vis[nxt]) continue;
			vis[nxt] = 1;
			q.push(make_pair(nxt , dep + 1));
		}
	}
	puts("-1");
}

int main () {
	cin >> n >> m;
	for(int i = 1 ; i <= m ; ++ i)
		for(int j = 1 ; j <= n ; ++ j) cin >> a[i][j]; 
	Bfs();
	return 0;
} 
```

---

## 作者：CXY07 (赞：2)

这题的灯只有开或者关两种选择，数据范围又很小，很明显跟**二进制**有关系，所以肯定会想到**位运算**

了解位运算的可跳过分割线中的内容

------------

若对位运算还不够了解，可以先参考一下大佬的博客

**搬运**：[位运算总结(按位与,或,异或)](https://blog.csdn.net/sinat_35121480/article/details/53510793)

这里给几个小技巧：
1. 一个数异或上$0$等于他自己
2. 一个数或上一个$1$可以在该位置上添加一个$1$，即把$0$变为$1$，$1$不变
1. 一个数与上一个$1$可以判断该位置上是否为$1$


------------

先来分析下题目

已知有$n$盏灯和$m$个按钮，每个按钮都可以影响某一些灯的开关状态，开始时所有灯都打开，求最少按几次按钮可以使灯全部关闭。

看到**最少**这个字眼的时候$Julao$们一定都~~浮想联翩~~想到了很多算法，但是如果是和位运算结合起来，也就是可以很简单地将一个状态转化为另一个一步就可以到达的状态时，自然地想到

# **BFS！！！**

总体算法出来之后就来考虑位运算的部分~~有点长~~

我们把每个按钮对每盏灯的影响存在$ctrl$数组中，则$ctrl[i][j]$代表第$i$个按钮对第$j$盏灯产生的影响哪一种（$1$，$0$或者$-1$）。

每盏灯的开合明显用$1$、$0$来表示，而现在我们需要做的就是设计一种方法，把按钮的信息存到数组中，从而让我们在做下面操作时可以很快地得出按下某一个按钮后的新状态。

这是按下按钮对灯变化的规定
```
如果ctrl[i][j]为1，那么当这盏灯开了的时候，把它关上，否则不管；
如果为-1的话，如果这盏灯是关的，那么把它打开，否则也不管；
如果是0，无论这灯是否开，都不管。
```

那么怎么做呢？先让我们看看样例

```
3
2
1 0 1
-1 1 0
```
一开始灯的状态是$111$，当我们把它认为是一个二进制时，它可以变成十进制的$7$。由于按钮对灯的变化有$-1$、$1$、$0$三种数，所以我们需要分类（以下均用$1$、$0$表示灯的打开和关闭）：

1. 当某一个$ctrl[i][j]=1$时，按下按钮后灯$j$一定会变成$0$，而如果把这和位运算扯上关系，我们可以发现，当这盏灯开着，也就是二进制的从右边数的第$j$位是$1$，我们将其 **异或** 上一个二进制数，这个数除了从右边数的第$j$位为$1$之外全部为$0$，这样的话，若本处本为$1$，则会变为$0$，否则对原来的数无修改，符合上面“当这盏灯开了的时候，把它关上，否则不管”；

2. 当某一个$ctrl[i][j]=-1$时，按下按钮后灯$j$一定会变成$1$,这是只要 **或** 上一个和上方相同的二进制数，即除了从右边数的第$j$位为$1$之外全部为$0$，若本处本为$0$,则会变为$1$,否则不会修改；

3. 当某一个$ctrl[i][j]=0$时，直接跳过。

~~十分~~有点抽象哈，可以用笔模拟一下这个过程，弄明白之后就按照这个方法进行状态更新就好啦

上代码：
```cpp
//Code By CXY
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1000010;//使得十进制最大的状态不会超过这个数字 

int n,m,light = 0;
int ctrl[101][11];
int que[MAXN][2];//que[i][0]表示该状态,que[i][1]表示走到该状态的步数 
bool vis[MAXN]={false};

int main() {
    cin >> n >> m;
    for(int i = 1;i <= m; ++i)
        for(int j = 1;j <= n; ++j)
            cin >> ctrl[i][j];//ctrl数组 
    int head=0,tail=1;//BFS标配~~ 
    que[head][0] = (1 << n) - 1;//这就是初始状态 -> 所有灯都开着，在十进制中间是 2^n - 1 
    que[head][1] = 0;
    vis[que[head][0]] = true;//已经到过此处 
    while(head < tail) {//BFS不解释 
        int step = que[head][1];//取出队头 
        int now = que[head][0];//如上 
        for(int i = 1;i <= m; ++i) {//枚举按下一个按钮 
            now = que[head][0];//每次都要重新赋值 
            for(int j = 1;j <= n; ++j) {//枚举被影响的每一盏灯 
                if(ctrl[i][j] == 1) {//情况 1 
                    if((now & (1 << (j - 1))))//如果该位置上的灯是亮着的 
                        now = (now ^ (1 << (j - 1)));//灭掉它 
                }
                if(ctrl[i][j] == -1) {//情况 2 
                    if(!(now & (1 << (j - 1))))//如果该位置上的灯是灭的 
                        now = now | (1 << (j - 1));//点亮它 
                }
            }
            if(now == 0) {//即最终状态 -> 全部熄灭 
                cout << step + 1 <<endl;//记得 +1 
                return 0;//直接退出 
            } 
        	if(!vis[now]) {//如果没有到达过这种状态 
                que[tail][0] = now;//放到对位 
                que[tail++][1] = step + 1;//步数 +1，尾指针 +1 
                vis[now] = true;//标记 
            }
        }
        head++;//头指针 +1 
    }
    cout << -1 << endl;//若跳出while循环即为无解，输出 -1 
    return 0;//华丽丽地结束 
}
```
初二的$OIer$，请多关照


---

## 作者：鹭天 (赞：1)

#### [题目传送门](https://www.luogu.org/problemnew/show/P2622)
#### 题目描述：
现有n盏灯，以及m个按钮。每个按钮可以同时控制这n盏灯——按下了第i个按钮，对于所有的灯都有一个效果。按下i按钮对于第j盏灯，是下面3中效果之一：如果a[i][j]为1，那么当这盏灯开了的时候，把它关上，否则不管；如果为-1的话，如果这盏灯是关的，那么把它打开，否则也不管；如果是0，无论这灯是否开，都不管。
现在这些灯都是开的，给出所有开关对所有灯的控制效果，求问最少要按几下按钮才能全部关掉。
***
输入输出格式
输入格式：
前两行两个数，n m
接下来m行，每行n个数,a[i][j]表示第i个开关对第j个灯的效果。
***
输出格式：
一个整数，表示最少按按钮次数。如果没有任何办法使其全部关闭，输出-1
***
输入输出样例
输入样例#1： 
3
2
1 0 1
-1 1 0

输出样例#1： 
2
***
说明

对于20%数据，输出无解可以得分。

对于20%数据，n<=5

对于20%数据，m<=20

上面的数据点可能会重叠。

对于100%数据 n<=10,m<=100
***
[博客](https://blog.csdn.net/huang_ke_hai/article/details/86666609)
#### 分析：
很多人看到这道题的取值范围后，第一时间的想法就是——[搜索](https://blog.csdn.net/huang_ke_hai/article/details/79066214)??
###### 不过，这并不是搜索，而是一道[状压dp](https://blog.csdn.net/huang_ke_hai/article/details/86669489)，其实是否是状压dp其实很好判断，你只要看一看数据范围就可以了，状压的数据范围一般不会超过30，只要数据范围过了关，再看一眼题目是否像状压dp就可以了。
接下来看怎么做：
###### 我们先预处理出t[i][j]表示第i个开关开j状态后的状态。将每一个状态，每一个开关打开后所对应得状态预处理出来.
预处理部分如下：

```cpp
    for (int i=0;i<(1<<n);i++) 
      for (int j=1;j<=m;j++){
      	int ans=0;
	    for (int k=1;k<=n;k++){
		    if (a[j][k]==1) if (i&(1<<n-k)) ans=ans;else;//如果当前的操作是1，如果当前的灯是亮着的，把它关上，否则不管 
		    else if (a[j][k]==-1) ans=ans+(1<<n-k);//如果当前的操作是-1，直接加上 
		    else if (a[j][k]==0) if (i&(1<<n-k))ans+=(1<<n-k);else;else;//如果当前的操作是0，如果当前的灯是开着的，累加；否则不管 
		}
		t[j][i]=ans;
	}
```
###### 预处理完之后，我们很容易知道题目的意思就是让我们求所有的灯都是0的状态，即让我们求0的时候的状态，因为开始时所有的灯都是开的，所以开始时的状态就是(1<<n)-1的状态。我们只要以(1<<n)-1为起点，0为终点做一遍BFS，记录步数即可

那么具体代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[110][110];
queue < int > q;
int t[2001][2001];
int dp[2001];
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=m;i++)
      for (int j=1;j<=n;j++) scanf("%d",&a[i][j]);
    for (int i=0;i<(1<<n);i++) 
      for (int j=1;j<=m;j++){
      	int ans=0;
        for (int k=1;k<=n;k++){
            if (a[j][k]==1) if (i&(1<<n-k)) ans=ans;else;//如果当前的操作是1，如果当前的灯是亮着的，把它关上，否则不管 
            else if (a[j][k]==-1) ans=ans+(1<<n-k);//如果当前的操作是-1，直接加上 
            else if (a[j][k]==0) if (i&(1<<n-k))ans+=(1<<n-k);else;else;//如果当前的操作是0，如果当前的灯是开着的，累加；否则不管 
        }
        t[j][i]=ans;
    }
//	for (int i=0;i<(1<<n);i++){
//	    for (int j=1;j<=m;j++) cout<<t[j][i]<<' ';
//	    cout<<endl;
//	}
    memset(dp,-1,sizeof(dp));
    dp[(1<<n)-1]=0;
    q.push((1<<n)-1);
    while (!q.empty()){
        int x=q.front();q.pop();
        for (int i=1;i<=m;i++){
            int y=t[i][x];
            if (dp[y]==-1) dp[y]=dp[x]+1,q.push(y);
        }
    }
//	for (int i=(1<<n)-1;i>=0;i--) cout<<dp[i]<<' ';
//	cout<<endl;
    printf("%d",dp[0]);
    return 0;
}
```



---

## 作者：JustinRochester (赞：1)

感觉大佬们的代码在读入上的处理比本蒟蒻优秀多了，于是，一个AFO蒟蒻弱弱地提出一下自己的看法

---
**【分析】**
--

首先，对于 $n$ 那么小，肯定是状压啦

对于读入，本蒟蒻开了两个数组来储存每个按钮的效果：$Open_i$ 和 $Close_i$ 分别表示在按下第 $i$ 个按钮后，它对于开着的开关和关闭的开关所造成的影响

那么我们分开来想：

如果一个状态 $Set$ 中，为 $1$ 的位表示开着的灯， $0$ 表示关闭的

那么，对于关闭的灯，如果 $Close_i$ 对它有影响，那么一定是将它开启

所以我们将 $Close_i$ 能影响到的灯的状态直接打上 $1$

即如果开关效果为
```
1 0 -1 -1 0
```

那么我们将 $Close_i$ 存为 $00110_{(2)}=6_{(10)}$

我们在使用它效果时则可以做到：

如果 $Set\bigcup Close_i$，本身 $Close_i$ 中为 $0$ 的位不影响

$Close_i$ 中本身为 $1$ (即能影响到的位) 中，对于开着的，没有影响，对于关闭的，造成影响并打开

---

而对于 $Open_i$， 它的效果恰巧反过来，如果开着，则一定关闭

因此，我们将能影响到的灯的状态打上 $0$

对于上面那组数据，我们将 $Open_i$ 存为 $01111_{(2)}=15_{(10)}$

使用时，我们就可以直接这么做 $Set\bigcap Open_i$

这样可以保证对于 $Open_i$ 中为 $1$ 的位(即不能影响的位)，不会造成影响

而对于会造成影响的位，如果本身是 $0$ 的不会造成影响，而对于 $1$ 的则关闭

完美地达到了要求

---

因此，我们初始化 $Close_i$ 为空集，$Open_i$ 为全集

如果读入第 $i$ 个开关第 $j$ 个灯为 $1$ ，则 $Open_i$ 去掉这一位，如果为 $-1$ ，则 $Close_i$ 加上这一位

使用时，对于每个状态 $Set$ ，和第 $i$ 个开关，它们能达到的状态就是 $Set\bigcup Close_i\bigcap Open_i$

而对于最小步，直接 bfs 即可，详情可以看本蒟蒻代码

---

**【代码】**
--

那本蒟蒻就放 ~~我码风极丑的~~ 代码了

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define f(a,b,c) for(register int a=b;a<=c;a++)
#define g(a,b,c) for(register int a=b;a>=c;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
typedef long long int ll;
typedef unsigned long long int ull;
inline ll read(){
	register ll ans=0;register char c=getchar();register bool neg=0;
	while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
	while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
	return neg?-ans:ans;
}//前面条件反射，莫管
int main(){
	int N=read(),M=read(),U=(1<<N)-1;
	int Close[110],Open[110],Minn[1<<10];
    //Minn[i] 表示到状态 i 的最小步数
	f(i,1,M) Close[i]=0,Open[i]=U;
	f(i,0,U) Minn[i]=-1;
	f(i,1,M)
		f(j,1,N){
			int Tmp=read();
			if(Tmp==1) Open[i]^=1<<j-1;
			else if(Tmp==-1) Close[i]|=1<<j-1;
		}
	int Queue[1<<10],Head=0,Tail=0;
	Queue[Tail++]=U;
	Minn[U]=0;
    //一开始全部开着
	while(Head<Tail){
		int Set=Queue[Head++];
		f(i,1,M){
			int Tmp=Set&Open[i]|Close[i];
			if(Minn[Tmp]>=0) continue;
            //之前搜到肯定更优
			Minn[Tmp]=Minn[Set]+1;
			Queue[Tail++]=Tmp;
		}
	}
	printf("%d",Minn[0]);
	return 0;
}
```

---

## 作者：万弘 (赞：1)

第一道AC的状压DP，发篇题解庆祝一下

状压DP，即状态压缩优化动态规划，本质思想是将一个状态（比如集合）压缩成一个二进制编码

通常用一个整形来表示这个二进制编码，这使得一些操作可以通过位运算实现

比如：

此题中的一个状态：开开开关关

压缩成：
11100

比如要把从右往左数第三盏灯关掉，只要

```cpp
tmp&=~(1<<2)//tmp就是11100
```

tmp就会变成11000

再把这盏灯打开，只要
```cpp
tmp|=(1<<2);
```

现在进入此题：（读入就略了）

要求最少步数，显然要依靠广搜，先手打队列（STL巨慢）
```cpp
typedef long long ll;
typedef std::pair<ll,ll> pll;//用pair在弹出队首时更方便
ll a[101][11];
ll n,m;
struct MY_queue
{
	pll a[100001];
	ll head,tail;//头尾指针
	void clear()
	{
		head=tail=1;//初始化
	}
	void push(pll x)
	{
		a[tail++]=x;
		if(tail>100000)tail=1;//循环队列
	}
	void pop()
	{
		++head;
		if(head>100000)head=1;
	}
	pll front()
	{
		return a[head];
	}
	bool empty()
	{
		return head==tail;
	}
}q;
```
然后是bfs

在打bfs前，要先想到开一个vis判重，不仅仅为了加快速度，更为了**防止无解时不会结束**
```cpp
ll bfs()
{
	ll now=(1<<n)-1,p;//开始都是1，p是当前次数
	vis[now]=1;
	q.push(pll{now,0});
	while(!q.empty())
	{
		now=q.front().first;
		p=q.front().second;
		q.pop();
		for(ll i=1;i<=m;++i)//每个开关
		{
			ll tmp=now;//再开一个变量可以省去回溯
			for(ll j=1;j<=n;++j)//每盏灯
			{
				if(a[i][j]==1)tmp&=~(1<<(n-j));
				if(a[i][j]==-1)tmp|=1<<(n-j);
			}
			if(vis[tmp])continue;
			vis[tmp]=1;
			if(tmp==0)return p+1;
			q.push(pll{tmp,p+1});
		}
	}
	return -1;
}
```

---

## 作者：maomao9173 (赞：1)

### 题目不难，直接搜索，其他dalao们说的神仙解法我是看不明白。
### 搜索爆空间的话可能是因为优化的不到位，这个搜索要注意下面这几个优化：
- 最优性剪枝：如果回到同一个状态就应该跳过
	
    - 然而最好是先把状态判断是否可用再往队列里面扔，不然可能爆空间？(没试过不知道)
    
- 定义的状态结构体里面，对状态的表示应该尽可能用状态压缩来表示来省空间+加速（是状态压缩！和状压DP没半点关系！）
	
    - ~~再不济也得用个bool吧qwq~~
    
然后就是硬核玩家的作风，直接硬搜硬过。

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
//#define Test
#define Anti_copy() printf("我永远喜欢CYDqwq\n");
using namespace std;
int n,m,bg=1,vis[(1<<10)+5],arr[105][11];
struct node{
	int sit;//状态压缩表示当前状态
	int step; 
}; 
queue<node>que;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		for(int j=1;j<=n;++j){
			scanf("%d",&arr[i][j]);
		}
	}
	for(int i=1;i<=n;++i){
		bg|=1<<(i-1);
	}//设置初始状态 
	que.push((node){bg,0});
	vis[bg]=true;//初始状态打上vis 
	while(!que.empty()){
		node t=que.front();
#ifdef Test 
		printf("sit=%d step=%d\n",t.sit,t.step);
		getchar();
#endif
		if(t.sit==0){//到达最终状态 
			Anti_copy(); 
			printf("%d\n",t.step);
			return 0;
		}
		que.pop();
		for(register int i=1;i<=m;++i){
			node s=t;
			for(int j=1;j<=n;++j){
				if(arr[i][j]==1)s.sit&=bg^(1<<(j-1)); 
				if(arr[i][j]==-1)s.sit|=(1<<(j-1));
			}//考量每一种状态 
#ifdef Test
			printf("i=%d s={ %d , %d }\n",i,s.sit,s.step);
#endif
			if(!vis[s.sit]){
				++s.step;
				vis[s.sit]=true;
				que.push(s);//可用就入队 
			}
		}
	}
	printf("-1\n");
	return 0;
} 
```

---

## 作者：Erutsiom (赞：1)

[洛谷P2622](https://www.luogu.org/problemnew/show/P2622)

tag：状态压缩

【题目大意】

n个灯，m个按钮，每个按钮都可以控制所有灯，给出每个按钮对每个灯的影响，求从全开到全关的最短步数。

【题目分析】

每盏灯只有两个状态，即开与关，记为0和1，则所有灯的状态总数为2^n（n=3时，有000,001,010,100……）

对每个状态单独分析，可以把每个开关看作一条有向边，这样把不同的状态连起来（也可能出现自环），因此，此题就变成了最短路问题，可以广搜解决。

接下来要考虑的是如何将按钮变成边，即如何确定经过按钮的操作，当前状态将转变成哪个状态。

回想二进制操作（与、或、非、抑或），经过尝试，我们发现“与”操作可以帮助我们解决关灯问题。比如：当原状态为100时（1表示开灯，0关），按钮1可以让1和3号灯关上，我们就可以令按钮1等于010.

100&010=000

“或”操作可以解决开灯问题，如：原状态为110，按钮2可以让1和3打开

110|101=111

当按钮3可以让1和3关上，让2打开时，就可以与010，或010，顺序不会影响结果。

【代码实现】

将二进制直接放到数组里？这是不现实的，所以还是用十进制来实现。

如何提取其中的一位呢？

###### a & (1<<j)

表示提取a的第j位，若结果是0，说明为0，若结果不为0，说明是1。


标程

```
#include<bits/stdc++.h>//2622
using namespace std;
int n , m , state[1200];//n<=10,所以前1023是有用的   表示到达i状态需要走的步数 
int trans[1200][105]; //trans[i][j]表示对状态i按下按钮j的状态 
int q[1200000],now;//q代表即将处理的队列 
int temp,open[110],close[110];
int main()
{
	int l=1,r=1; 
	scanf("%d%d", &n ,&m);
	for( int i = 1 ; i <= m ; i++)  close[i] = (1<<n)-1;//open[i]=0; 
	q[1] = (1<<n)-1;//初始状态：所有灯都开着，每一位都是1 
	for(int i = 0 ; i <= (1<<n) ; i++)  state[i]=-1;//所有状态初始化-1，表示之前没有遍历到这个状态 
	state[(1<<n)-1]=0;// 当前位置不需要移动就可以到达 
	for(int i = 1; i <= m ; i++)//m个按钮 
	  for(int j =1 ; j <= n ; j++){//每个按钮对灯j的控制情况 
		scanf("%d", &temp);
		if( temp == 1 )  close[i] -= (1<<(j-1));//按钮i可以让灯j关上 
		if( temp == -1 ) open[i] += (1<<(j-1));//打开 
		}
	for( int i = 0 ; i < (1<<n); i++ )//枚举从000到111的所有状态 
		for( int j =1 ; j<= m ; j++)//枚举每一个按钮 
		 trans[i][j] = ( i & close[j] ) | open[j];//经过按钮j，i会变成trans[i][j] 

	while( l <= r ){//当队列中还有任务时 
	    if(state[0]!=-1) break;
		now=q[l];
		l++;
		for(int i = 1 ; i <= m ; i++){//对于每一个按钮 
			if( state[trans[now][i]] == -1 ){//如果没有到过这个状态 
				state[trans[now][i]] = state[now]+1;//这个状态可以由now状态走一步得到 
				q[++r] = trans[now][i];//准备处理这个状态 
			}
		} 
	}
	cout<<state[0]<<endl;//到0状态需要走的步数 
	return 0;
}
```



---

## 作者：WenDavid (赞：1)

这道题挺水的，1和-1就是所谓的位设置、位清除，所以就相当于是一条边，每一个相应的状态就是一个点，很简单用二进制存一下就行了，所以随便跑一个SPFA（其实随便什么都行）就能够完美过了（其实这是我第一次动手写SPFA，但却一次就过了）。

```cpp

# include <cstdio>
using namespace std;
const int MAXSTATE = 2048;
const int MAXM = 101;
const int MAXN = 11;
const int MAXQ = 5001;        /*Faster And Safer : Round Queue*/
const int INF = 10000000;    /*Infinite*/

int Q[MAXQ];
int head,tail;
int Qhead,Qtail;
int NowState;
int NewState;
int LightWay[MAXSTATE];
int Way[MAXM][MAXN];

/*N - Light(Point) Number, M - Oper(Way) Number*/
int N,M;
int StateSize;

int main(){
    scanf("%d%d",&N,&M);
    for (int i=0;i!=M;++i){
        for (int j=0;j!=N;++j){
            scanf("%d",&Way[i][j]);
        }
    }
    
    /*Init: All Point Expect Begining's Way is INF*/
    StateSize = (1 << N);
    for (int i=0;i!=StateSize;++i){
        LightWay[i] = INF;
    }
    LightWay[StateSize - 1] = 0;
    
    /*Init Queue*/
    Qhead = Qtail = head = tail = 0;
    Q[Qtail] = StateSize - 1;
    
    /*!!!Begin SPFA!!!*/
    
    while (head >= tail){
        NowState = Q[Qtail];
        for (int i=0;i!=M;++i){
            /*To Every Opers*/
            NewState = NowState;
            for (int j=0;j!=N;++j){
                if (Way[i][j] == -1){
                    NewState = (NewState | (1<<j));            //Set
                }
                else if (Way[i][j] == 1){
                    NewState = (NewState & (~(1<<j)));        //Clean
                }
            }
            
            if (LightWay[NewState] > LightWay[NowState] + 1){
                LightWay[NewState] = LightWay[NowState] + 1;
                ++Qhead;
                ++head;
                if (Qhead == MAXQ) Qhead = 0;
                Q[Qhead] = NewState;
            }
        }
        ++Qtail;
        ++tail;
        if (Qtail == MAXQ) Qtail = 0;
    }
    
    if (LightWay[0] == INF){
        printf("-1\n");
    }
    else{
        printf("%d\n",LightWay[0]);
    }
    
    return 0;
} 

```

---


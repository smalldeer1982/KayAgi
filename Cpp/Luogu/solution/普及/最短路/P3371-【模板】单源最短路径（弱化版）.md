# 【模板】单源最短路径（弱化版）

## 题目背景

本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 [P4779](https://www.luogu.org/problemnew/show/P4779)。

## 题目描述

如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。


## 说明/提示

【数据范围】    
对于 $20\%$ 的数据：$1\le n \le 5$，$1\le m \le 15$；  
对于 $40\%$ 的数据：$1\le n \le 100$，$1\le m \le 10^4$；   
对于 $70\%$ 的数据：$1\le n \le 1000$，$1\le m \le 10^5$；   
对于 $100\%$ 的数据：$1 \le n \le 10^4$，$1\le m \le 5\times 10^5$，$1\le u,v\le n$，$w\ge 0$，$\sum w< 2^{31}$，保证数据随机。

**Update 2022/07/29：两个点之间可能有多条边，敬请注意。**

对于真正 $100\%$ 的数据，请移步 [P4779](https://www.luogu.org/problemnew/show/P4779)。请注意，该题与本题数据范围略有不同。


样例说明：

![](https://cdn.luogu.com.cn/upload/pic/7641.png)

图片1到3和1到4的文字位置调换


## 样例 #1

### 输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4```

### 输出

```
0 2 4 3```

# 题解

## 作者：微雨燕双飞 (赞：658)

来一份题解，嗯。。真好吃。

新手刚学spfa（太菜了），第一次自己写过，在此发表题解留念，还望各位巨佬及大神指点批评。

好，言归正传。本题根据数据边数m<=500000，邻接矩阵存不下，只能使用静态邻接表存储。然后见楼下有写dijkstra+堆优化的，有floyd优化的，有各种牛X方法，本人太菜，只会套模板，这里提供一份教科书式的邻接表+spfa的解决方法共大家参考。

具体代码如下：

```cpp
#include<bits/stdc++.h>
const long long inf=2147483647;
const int maxn=10005;
const int maxm=500005;
using namespace std;
int n,m,s,num_edge=0;
int dis[maxn],vis[maxn],head[maxm];
struct Edge
{
  int next,to,dis;
}edge[maxm]; //结构体表示静态邻接表
void addedge(int from,int to,int dis) //邻接表建图
{ //以下是数据结构书上的标准代码，不懂翻书看解释
  edge[++num_edge].next=head[from]; //链式存储下一条出边
  edge[num_edge].to=to; //当前节点编号
  edge[num_edge].dis=dis; //本条边的距离
  head[from]=num_edge; //记录下一次的出边情况
}
void spfa()
{
  queue<int> q; //spfa用队列，这里用了STL的标准队列
  for(int i=1; i<=n; i++) 
  {
    dis[i]=inf; //带权图初始化
    vis[i]=0; //记录点i是否在队列中，同dijkstra算法中的visited数组
  }
  q.push(s); dis[s]=0; vis[s]=1; //第一个顶点入队，进行标记
  while(!q.empty())
  {
    int u=q.front(); //取出队首
    q.pop(); vis[u]=0; //出队标记
    for(int i=head[u]; i; i=edge[i].next) //邻接表遍历，不多解释了（也可用vector代替）
    {
      int v=edge[i].to; 
      if(dis[v]>dis[u]+edge[i].dis) //如果有最短路就更改
      {
        dis[v]=dis[u]+edge[i].dis;
        if(vis[v]==0) //未入队则入队
        {
          vis[v]=1; //标记入队
          q.push(v);
        }
      }
    }
  }
}
int main()
{
  cin>>n>>m>>s;
  for(int i=1; i<=m; i++)
  {
    int f,g,w;
    cin>>f>>g>>w; 
    addedge(f,g,w); //建图，有向图连一次边就可以了
  }
  spfa(); //开始跑spfa
  for(int i=1; i<=n; i++)
    if(s==i) cout<<0<<" "; //如果是回到自己，直接输出0
      else cout<<dis[i]<<" "; //否则打印最短距离
  return 0;
} //结束
应该讲得非常清楚了，再不懂就翻书吧。（虽然我曾经也不懂）
```

---

## 作者：Nemlit (赞：322)

[原文地址](https://www.cnblogs.com/bcoier/p/10363284.html)

这里给大家介绍三种最短路常用算法：

floyd(O(n^3))、dijkstra(O(nlogn))、SPFA(O(KE))

其实还有一个Bellman-Ford（O(nm)）算法，但由于不常用而且SPFA是这个算法的改进版本，在这里就不列举了

# floyd：效率较低，只有70分

具体思路：将所有节点的距离都存在一个数组里，由于要枚举所有的两两组合以及每一个组合的“中转点”，再进行松弛操作

在求单源最短路径的时候就会浪费许多空间，但在求多源最短路时，复杂度仍是O(n^3)使用很广
```
#include<bits/stdc++.h>
using namespace std;
#define inf 1234567890
#define maxn 10005
inline int read()
{
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}//快读
int a[maxn][maxn],n,m,s;
inline void floyd()
{
    for(int k=1;k<=n;k++)
    //这里要先枚举k（可以理解为中转点）
	{
        for(int i=1;i<=n;i++)
		{
            if(i==k||a[i][k]==inf)
            {
                continue;
			}
			for(int j=1;j<=n;j++)
			{
                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
                //松弛操作，即更新每两个点之间的距离
                //松弛操作有三角形的三边关系推出
                //即两边之和大于第三边
            }
        }
    }
}
int main()
{
    n=read(),m=read(),s=read();
    for(int i=1;i<=n;i++)
	{
        for(int j=1;j<=n;j++)
		{
            a[i][j]=inf;
        }
    }
	//初始化，相当于memset(a,inf,sizeof(a))
    for(int i=1,u,v,w;i<=m;i++)
	{
        u=read(),v=read(),w=read();
        a[u][v]=min(a[u][v],w);
        //取min可以对付重边
    }
    floyd();
    a[s][s]=0;
    for(int i=1;i<=n;i++)
    {
        printf("%d ",a[s][i]);
    }
    return 0;
}
```
# dijkstra：对于无负边的情况下可以达到O(nlogn)且很难被卡
具体思路：Dijkstra是基于一种贪心的策略，首先用数组dis记录起点到每个结点的最短路径，再用一个数组保存已经找到最短路径的点

然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点记为已经找到最短路

此时完成一个顶点，再看这个点能否到达其它点（记为v），将dis[v]的值进行更新

不断重复上述动作，将所有的点都更新到最短路径

这种算法实际上是O(n^2)的时间复杂度，但我们发现在dis数组中选择最小值时，我们可以用一些数据结构来进行优化。~~线段树？平衡树？~~

其实我们可以用STL里的堆来进行优化，堆相对于线段树以及平衡树有着常数小，码量小等优点，并且堆的一个妙妙的性质就是可以在nlogn的时限内满足堆顶是堆内元素的最大（小）值，之不正是我们要的嘛？

```
以下是用堆优化dijkstra代码：
#include<bits/stdc++.h>
using namespace std;
#define maxn 10005
#define maxm 500005
#define INF  1234567890
inline int read()
{
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}
struct Edge
{
    int u,v,w,next;
}e[maxm];
int head[maxn],cnt,n,m,s,vis[maxn],dis[maxn];
struct node
{
    int w,now;
    inline bool operator <(const node &x)const
    //重载运算符把最小的元素放在堆顶（大根堆）
    {
        return w>x.w;//这里注意符号要为'>'
    }
};
priority_queue<node>q;
//优先队列，其实这里一般使用一个pair，但为了方便理解所以用的结构体
inline void add(int u,int v,int w)
{
    e[++cnt].u=u;
    //这句话对于此题不需要，但在缩点之类的问题还是有用的
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].next=head[u];
    //存储该点的下一条边
    head[u]=cnt;
    //更新目前该点的最后一条边（就是这一条边）
}
//链式前向星加边
void dijkstra()
{
    for(int i=1;i<=n;i++)
    {
        dis[i]=INF;
    }
    dis[s]=0;
    //赋初值
    q.push((node){0,s});
    while(!q.empty())
    //堆为空即为所有点都更新
    {
        node x=q.top();
        q.pop();
        int u=x.now;
        //记录堆顶（堆内最小的边）并将其弹出
        if(vis[u]) continue; 
        //没有遍历过才需要遍历
        vis[u]=1;
        for(int i=head[u];i;i=e[i].next)
        //搜索堆顶所有连边
        {
            int v=e[i].v;
            if(dis[v]>dis[u]+e[i].w)
            {
            	dis[v]=dis[u]+e[i].w;
            	//松弛操作
            	q.push((node){dis[v],v});
            	//把新遍历到的点加入堆中
            }
        }
    }
}
int main()
{
    n=read(),m=read(),s=read();
    for(int i=1,x,y,z;i<=m;i++)
    {
        x=read(),y=read(),z=read();
        add(x,y,z);
    }
    dijkstra();
    for(int i=1;i<=n;i++)
    {
        printf("%d ",dis[i]);
    }
    return 0;
}
```
# SPFA：考场慎用，在毒瘤数据面前可能退化到O(nm)
具体思路：这里用的是STL队列，首先用数组dis记录起点到每个结点的最短路径，用邻接表来存储图，用vis数组记录当前节点是否在队列中

具体操作为：用队列来保存待优化的结点（类似于BFS），优化时每次取出队首结点，并且用队手节点来对最短路径进行更新并进行松弛操作

如果要对所连点的最短路径需要更新，且改点不在当前的队列中，就将改点加入队列

然后不断进行松弛操作，直至队列空为止。
```cpp

#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0,k=1; char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}
#define maxn 10005
#define maxm 500005
#define inf 1234567890
int n,m,s,tot,dis[maxn],head[maxn];
bool vis[maxn];
struct Edge
{
      int next,to,w;
}h[maxm];
void add(int u,int v,int w)
{
    h[++tot].next=head[u];
    h[tot].to=v;
    h[tot].w=w;
    head[u]=tot;
}
//上面和dijkstra算法基本上一样
queue<int> q;
//队列优化
inline void spfa()
{
    for(int i=1; i<=n; i++)
    {
        dis[i]=inf;
        //赋初值
    }
    int u,v;
    q.push(s);
    dis[s]=0;
    //将起点的值负为0
    vis[s]=1;//这句话可加可不加，因为循环的时候vis[s]又会被赋为0
    while(!q.empty())
    //当队列里没有元素的时候，那就已经更新了所有的单源最短路径
	{
        u=q.front();
        //将队手节点记录并弹出队首节点
        q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=h[i].next)
        //寻找与u相连的边
		{
            v=h[i].to;
            if(dis[v]>dis[u]+h[i].w)
			{
                dis[v]=dis[u]+h[i].w;
                //松弛操作，和floyd比较相似
                if(!vis[v])
				{
                //已经在队列里的点就不用再进入了
                      vis[v]=1;
                      q.push(v);
                }
            }
        }
    }
}
int main(){
    n=read(),m=read(),s=read();
    for(int i=1,u,v,w;i<=m;i++)
	{
        u=read(),v=read(),w=read();
        add(u,v,w);
    }
    spfa();
    for(int i=1; i<=n; i++)
    {
        printf("%d ",dis[i]);
    }
    return 0;
}
```

---

## 作者：2018一维 (赞：311)



# 单源最短路算法——Dijkstra


------------

## 实现方法：
**1.**定义ans[100000]，ans[i]代表到达i点的最小花费

**2.**定义bool数组visit，代表是否来过这里

- 注意：这里的访问过，是指“以这个点为中心计算过”，而不是ans值被更新过

**2.**ans[起点]=0,其余的赋值为inf

**3.**定义一个curr变量，visit[current]=1（访问过），代表现在的位置，初始值为起点。

**4.**列举所有与curr相联通的的点，将这些点(i)的ans值更新：

$ ans[i]=min(ans[i],ans[curr]+ $到这些点需要的花费 $)$

**5.** 列举所有没有过的的点，找到ans值最小的点，赋值给curr，visit[current]=1（访问过）

**6** 所有点都访问过（visit[i]都==1），程序结束。此时，ans[i]代表从起点到i的最短路径


------------

## 伪代码
```cpp
bool vis[1000000];//是否访问过
int ans[1000000];
int curr=起点;
memset(ans,0x7fffffff,sizeof(ans))
while(vis[curr]==0)
{
	vis[curr]=1;
	for(int i;列举所有curr连通的点）
    {
    	ans[i]=min(ans[i],ans[curr]+k)//k代表从curr点到i点的最短路
    }
    int minn=2147483647;
    for(int i=1;i<=m;i++)//列举所有点
    {
    	if(vis[i]==0&&ans[i]<minn)//没访问过且小
        {
        	minn=ans[i];//更新最小值
            curr=i;//更新下一个点
        }
    }
}

```


------------

## 存图方式
链式前向星
**以下是关于链式前向星的介绍 ，会的可以跳过：**
 


## 边的存储

这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。


在链式前向星存图中，我们需要定义一个结构体：
```
struct EDGE 
{
    int next;
    int to;
}edge[1000000];
```
和一个数组：
```
int head[1000000];
```
和一个变量：
```
int cnt=0;//指针
```
你会发现竟然没存起点！！其实起点是用$head$存的
 ### 举例：
 ![](https://cdn.luogu.com.cn/upload/pic/43957.png   )


如图：这样的一个有向图，输入是：

```
1 2
1 3
1 4
2 3
```

### 逐步分析：

#### 1.输入1 2，代表1连向2。
```
cnt++;//作为结构体下标，没有意义
head[1]=cnt;//结点1的第一个儿子存在了edge[cnt]里面
edge[cnt].to=2;结点1的儿子是2
```
此时：
$cnt=1$

| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $0$| $ 0$| $0$ |
|  $next$|$ 0 $|$0 $ | $0$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $1 $|$ 0 $|$ 0 $|$ 0 $|



#### 2.输入1 3，代表1连向3。
```
cnt++;
head[1]=cnt;
edge[cnt].to=3;结点1的儿子是3
//这时,3成为了结点1的儿子，不过2被挤了下去...
//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2
//所以代码要换成：
cnt++;
edge[cnt].to=3;//结点1连向3
edge[cnt].next=head[1];//3的兄弟是2
head[1]=cnt;//更新head
```

此时：
$cnt=2$

| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $3$| $ 0$| $0$ |
|  $next$|$ 0 $|$1 $ | $0$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $2 $|$ 0 $|$ 0 $|$ 0 $|



#### 3.输入1 4，代表1连向4。

此时：
$cnt=3$



| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $3$| $ 4$| $0$ |
|  $next$|$ 0 $|$1 $ | $2$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $3 $|$ 0 $|$ 0 $|$ 0 $|


#### 4.输入2 3，代表2连向3。

此时：
$cnt=4$

| $edge$| $cnt=1$ | $cnt=2$ |$ cnt=3$ |$cnt=4$  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $to $| $2$ |  $3$| $ 4$| $3$ |
|  $next$|$ 0 $|$1 $ | $2$ | $0$|

| $head $| 下标$=1 $| 下标$=2$ |下标$=3 $ | 下标$=4 $|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  值| $3 $|$ 4 $|$ 0 $|$ 0 $|



### 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$


#### 若需要记录权值，在结构体中加入一个元素即可

代码：(带权值）
```
#include<iostream>
using namespace std;
struct edge 
{ 
    int next;
    int to;
    int wei;
}edge[MAXM];
int head[MAXN];//head[i]为i点的第一条边
int cnt=0;
void addedge(int u,int v,int w) //起点，终点，权值 
{
    edge[++cnt].next=head[u];//更新cnt
    edge[cnt].to=v;
    edge[cnt].w=w;
    head[u]=cnt;
}
int main()
{
	int n;
    for(int i=1;i<=n;i++)
    {
    	int a,b,wei;
        addedge(a,b,wei);
        //如果是无向图，还要addedge(b,a,wei);
    }
}
```
 
#### 注意：
 
 这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。



------------

## 边的遍历

在遍历以x为起点的所有边时，只需要这样就行

		for(int i=head[x];i!=0;i=edge[i].next)

这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。




------------

## 优势与特点


既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。

 

------------

## 代码
```
#include<iostream>
using namespace std;
int head[100000],cnt;
long long ans[1000000];
bool vis[1000000];
int m,n,s;
struct edge
{
	int to;
	int nextt;
	int wei;
}edge[1000000];
void addedge(int x,int y,int z)
{
	edge[++cnt].to=y;
	edge[cnt].wei=z;
	edge[cnt].nextt=head[x];
	head[x]=cnt;
}
int main()
{
	cin>>m>>n>>s;
	for(int i=1;i<=n;i++)
	{
		ans[i]=2147483647;
	}
	ans[s]=0;
	for(int i=1;i<=n;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		addedge(a,b,c);
	}
	int pos=s;
	while(vis[pos]==0)
	{
		long long minn=2147483647;
		vis[pos]=1;
		for(int i=head[pos];i!=0;i=edge[i].nextt)
		{
			if(!vis[edge[i].to]&&ans[edge[i].to]>ans[pos]+edge[i].wei)
			{
				ans[edge[i].to]=ans[pos]+edge[i].wei;
			}
		}
		for(int i=1;i<=m;i++)
		{
			if(ans[i]<minn&&vis[i]==0)
			{
				minn=ans[i];
				pos=i;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		cout<<ans[i]<<' ';
	}
}
```

---

## 作者：KesdiaelKen (赞：183)

看到各位大佬都上了各种各样的SPFA，本蒟蒻只好弱弱地上一个dijstra（不用堆优化）。

dijstra的思路很简单，基本上就可以算是一个DP，就是找到与起点距离最短距离一定的点，然后继续往外拓展，更新其它点对于起点的最短距离。注意：在所有已知距离起点的距离中，最短的那个就是新的起点（因为它距离起点的距离不能再短了）。将整张图搜完，就大功告成了。

本人还加了一个前向星存边优化（开始直接暴搜，二维存边，只得了10分......）（前向星是什么东西？看本人以前的题解或网上去查一下就行了），这样就可以进行优化，直达AC！

下为代码：


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
struct Edge//前向星存边
{
    int z;//此边的子节点
    int val;//此边的权值
    int nexty;//与它最近的父节点一样的边的编号
}edge[1000000];
int head[20000];//以某点为父节点引出的最后一条边
int cnt=0;//边编号
inline void add(int a,int b,int c)//存边
{
    cnt++;
    edge[cnt].z=b;
    edge[cnt].val=c;
    edge[cnt].nexty=head[a];
    head[a]=cnt;//更新head
}
int main()
{
    bool visit[20000]={0};//是否作为过起点
    long long dis[20000];//距离
    int n,m,s;
    int a,b,c;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=n;i++)dis[i]=2147483647;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
    }
    int curr=s;
    dis[s]=0;
    long long minn;
    while(!visit[curr])//即搜完整张图
    {
        visit[curr]=true;//已做为过起点
        for(int i=head[curr];i!=0;i=edge[i].nexty)//链式前向星搜边
        {
            if(!visit[edge[i].z]&&dis[edge[i].z]>dis[curr]+edge[i].val)
            dis[edge[i].z]=dis[curr]+edge[i].val;//更新操作
        }
        minn=2147483647;
        for(int i=1;i<=n;i++)
        {
            if(!visit[i]&&minn>dis[i])//取新的最小值
            {
                minn=dis[i];
                curr=i;
            }
        }
    }
    for(int i=1;i<=n;i++)printf("%lld ",dis[i]);
    return 0;
}
```

---

## 作者：Ophelia (赞：94)

## 详解dijsktra的堆优化
dijkstra的时间复杂度是$O(N^2)$(基于邻接矩阵)、$O((N+M)logN)$(基于邻接表或链式前向星)。$N^2 $的时间复杂度是很高的。而对于稠密图来说，$(N+M)logN$比$N^2$还要慢。那么应该怎么做？

我们知道这一题用基于邻接矩阵的dijkstra是会炸的。这里我们需要基于链式前向星的dijkstra。

我们知道，dijkstra每次进行选择距离起点最近的顶点需要$O(N)$的时间，这样每次都需要耗费很长时间选择。我们可以采用**堆**的方式进行优化，使每次选择时间降至$O(logN)$。

代码如下，注解比较详细。
```
#include<bits/stdc++.h>
#include<cmath>
using namespace std;
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;//STL优先队列（使用pair的情况下）的定义方法。由于要采用小根堆，所以需要这样定义。注* 
int fir[500001],to[500001],val[500001],nex[500001],n,m,s,u,v,w,cnt;
const int inf=2147483647;
long long dis[10001];//为了避免判定相加时爆掉int成负数，此处采用long long。注1* 
bool book[100001];
void add_edge(int a,int b,int c)//链式前向星存图，不懂的可以问度娘 
{
	to[++cnt]=b;
	val[cnt]=c;
	nex[cnt]=fir[a];
	fir[a]=cnt;
}
int main()
{
	cin>>n>>m>>s;
	for(int i=1; i<=m; i++)
	{
		cin>>u>>v>>w;
		add_edge(u,v,w); 
	}
	for(int i=1; i<=n; i++)
		dis[i]=inf;
	dis[s]=0;//初始化dis数组 
	q.push(make_pair(0,s));//这里采用C++自带二元组编写。注2* 
	while(q.size())//当堆中还有元素 
	{
		int x=q.top().second;//q.top()取出堆顶，也就是当前距离起点最近的点。 
		q.pop();//取完就删 
		if(book[x]) continue;//如果这个定点标记过了，就不用。注3* 
		book[x]=1;//标记一下 
		for(int i=fir[x]; i; i=nex[i])
		{
			if(dis[to[i]]>dis[x]+val[i])//dijkstra算法核心语句 
			{
				dis[to[i]]=dis[x]+val[i];
				q.push(make_pair(dis[to[i]],to[i]));//每次松弛成功，把关于当前点的信息压入堆。 
			}
		}
	}
	for(int i=1;i<=n;i++)
		cout<<dis[i]<<" "; 
	return 0;
}
/*
注：priority_queue<(数据类型)>的定义方法默认是大根堆。只有priority_queue<(数据类型),vector<(数据类型)>,greater<(数据类型)> >的方法才能定义小根堆。另外，应该用空格分开两个连在一起的尖括号(<<或>>)，否则编译器会把它识别成流读取运算符。
 	当然，你也可以选择重载运算符，不过我觉得这样更好些。毕竟不少人不会重载。
 	另外，优先队列虽然等价于堆，但是内部原理是通过给予变量一个优先值来实现的，与堆不同。 
注1：C++的计算过程中的数据是以两个变量中最高的数据类型存储的，与结果保存变量无关。两个int相加保存在一个long long变量里，如果结果超出int，还是会炸的。
注2：C++自带的二元组pair,定义方法是pair<(数据类型1),(数据类型2)>(名称)。相当于一个包含两个变量的结构体。pair中的两个成员使用.first和.second进行访问。在优先队列里，pair是以first为第一关键字、以second为第二关键字排序的。向pair中插入元素可以直接像结构体一样赋值，也可以使用make_pair()插入。 
注3：这里采用的是懒惰删除的思想。因为STL的优先队列不支持对内部元素的随机删除，所以采用一个标记。如果曾经使用过，那么在它到堆顶的时候就不使用它。相当于把删除操作延迟到堆顶进行。 
*/
```
这样就可以实现堆优化。当然，这题使用SPFA也是可以过的。但是考试的时候可能会出毒瘤数据卡死你。

最后：
## 关于SPFA:它死了

---

## 作者：扬皓2006 (赞：63)

众所周知，这是一道最短路的模板

目录:

1.松弛操作

2.Floyd（70分）(n^3)

3.Dijkstra+优先队列(不能用于有负边权的情况)(AC)(m log n)

4.SPFA(已死)(AC)(Km)(在某些图（例如菊花图）可能会退化到nm)

首先，我们来讲一下松弛操作:

它是由三角形的（两边之和大于第三边）推出的:

代码如下:
```
for(int k=1;k<=n;k++)//初学者容易写成i,j,k，要注意！
    {
        for(int i=1;i<=n;i++)
        {
            if(i==k||a[i][k]==inf)
            {
                continue;
            }
            for(int j=1;j<=n;j++)
            {
                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);//松弛操作
            }
        }
    }
```
学习了基础的松弛操作后，我们来学习最朴素的Floyd算法:

代码如下:
```
#include<bits/stdc++.h>//万能头
#define inf 2147483647//inf
#define maxn 7005
using namespace std;
long long  a[maxn][maxn],s,n,m,u,v,d;
int main()
{
	cin>>n>>m>>s;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			a[i][j]=inf;
		}
	}//把邻接矩阵数组重置为inf
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v>>d;
		a[u][v]=min(a[u][v],d);
	}//邻接矩阵存储
	for(int k=1;k<=n;k++)
    {
        for(int i=1;i<=n;i++)
        {
            if(i==k||a[i][k]==inf)
            {
                continue;
            }
            for(int j=1;j<=n;j++)
            {
                a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
            }
        }
     }//松弛操作
    a[s][s]=0;//起点标记为0
    for(int i=1;i<=n;i++)
    {
    	printf("%d ",a[s][i]);//输出
	}
	return 0;
}
```
接下来，是Dijkstra

代码如下:
```
#include<bits/stdc++.h>
#define inf 2147483647
using namespace std;
int n,m,x,y,z,tot=0,s;
int d[100001],v[1000001],hea[1000001];
priority_queue< pair<int,int> > q;//大根堆（优先队列），第一维为d的相反数（变成小根堆），第二维为节点编号
struct Edge{
	int next,to,dis;
}edge[1000001];//邻接表存储
void add(int x,int y,int z)
{
	edge[++tot].next=hea[x];
	edge[tot].to=y;
	edge[tot].dis=z;
	hea[x]=tot;
}//存下一条(x,y)，权值为z的边（算法书上都有）
int main()
{
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}//邻接表存边
	for(int i=1;i<=n;i++)
	{
		d[i]=inf;v[i]=0;
	}//重置
	d[s]=0;q.push(make_pair(0,s));//起点最短路为0，入队
	while(!q.empty())//队列非空
	{
		int x=q.top().second;q.pop();//取出堆顶
		if(v[x]) continue;
		v[x]=1;
		for(int i=hea[x];i;i=edge[i].next)//扫描所有出边
		{
			int y=edge[i].to;
			if(d[y]>d[x]+edge[i].dis)
			{
				d[y]=d[x]+edge[i].dis;
				q.push(make_pair(-d[y],y));
			}//松弛操作，插入堆
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<d[i]<<' ';
	}
	return 0;
}
```
最后的SPFA

代码如下:
```
#include<bits/stdc++.h>
#define inf 2147483647
using namespace std;
int d[100001];
int v[1000001];
int hea[1000001];
int m,n,x,y,z,tot=0,s;
struct Edge{
	int next,to,dis;
}edge[1000001];//仍然是邻接表
void add(int x,int y,int z)
{
	edge[++tot].next=hea[x];
	edge[tot].dis=z;
	edge[tot].to=y;
	hea[x]=tot;
}
int main()
{
	queue<int> q;//队列
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	for(int i=1;i<=n;i++)
	{
		d[i]=inf;v[i]=0;
	}//前面都一样
	q.push(s);d[s]=0;v[s]=1;//起点入队并重置
	while(!q.empty())
	{
		int x=q.front();q.pop();v[x]=0;//取出队首并重置
		for(int i=hea[x];i;i=edge[i].next)//扫描所有出边
		{
			int y=edge[i].to;
			if(d[y]>d[x]+edge[i].dis)
			{
				d[y]=d[x]+edge[i].dis;//松弛操作
				if(v[y]==0)//如果没有走过
			{
				v[y]=1;//设成已走过
				q.push(y);//入队
			}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<d[i]<<' ';
	}
	return 0;
}
```
经过3种最短路的讲解，大家想必都有些了解了吧，最短路是图论中一种灵活的题目，大家一定要学好！

最后，希望管理员大大能通过这篇题解！

---

## 作者：2018李泽明 (赞：50)

### 前言：

------------

### 第一次接触链式前向星就知道这不是个容易懂的东西

#### 好不容易把CHW大佬问生气后终于懂了

这是一篇~~写给自己看的~~题解：[P3371 【模板】单源最短路径（弱化版）](https://www.luogu.org/problemnew/show/P3371)，一道模板题。


求带权有向图上一个源点到其他点的最短路径距离

如果没有非负边权，我们自然可以想到Dijkstra。但是如果有负边权呢？这时候就要用SPFA算法求解。

题意没有什么好讲的，只是代码实现问题~~

代码里面有很多注释，打了我半天呢！


------------

## Code
```
//SPFA 
#include<cstdio> 
using namespace std; 
int dis[500010],n,m,f,g,w,t=1,s,q[200000],h,st[500010],tot;
bool vis[100010];
/*
st[i]表示到达i点的最后一条边的编号； 
dis[i]表示从起点到i点目前为止的最短距离； 
vis[i]=true表示点i在队列里； 
vis[i]=false表示点i不在队列里； 
数组q是队列； 
h是指队列的头指针，t是指队列的尾指针； 
*/
struct node //不开结构体，变量有点乱，所以开结构体； 
{ 
    int to;//这条边连接的终点； 
    int v;//这条边的长度； 
    int last;//前一条边； 
}e[500010]; 
void add(int from,int to,int val)
/*
val表示传入的这条边的权值； 
from表示传入的这条边的起点； 
to表示传入的这条边的终点； 
*/
{     
    tot++;//表示当前这条边的编号； 
    e[tot].to=to;//更新当前这条边的终点； 
    e[tot].v=val;//更新当前这条边的长度（权）； 
    e[tot].last=st[from];
/*
    e[tot].last表示的是当前读入的这条边的上一条边； 
    st[from]表示的是 到当前读入的边为止（不包括这条边） 的上一条边的序号； 
*/
    st[from]=tot;//更新为 当前读入的边为止（包括这条边） 的上一条边的序号；
} 
void SPFA()//核心最短路；
{
    while(h<=t)//队列不为空； 
    {
        h++; 
        int u=q[h];//取出队首
        vis[u]=0;//队首出队
        for(int i=st[u]; i!=0; i=e[i].last)
/*
st[u]是指可以到达点u的上一条边，如果存在st[u]（也就是st[u]不为0，因为0是初始值），
说明有一条边可以到达点u。所以i变成st[u]。e[i].last是指可以到达st[u]这条边的起点的边的编号
*/
        {
            int v=e[i].to;
            if(dis[v]>dis[u]+e[i].v)
/*
如果从起点到v的距离大于从起点到点i，再从点i到点u，再从点u到点v的距离，更新从起点
到点v的最短路； 
*/
            {
                dis[v]=dis[u]+e[i].v;
                if(vis[v]==0)//没有入过队就入队； 
                {
                    vis[v]=1;//标志改为1，表示已经入队； 
                    t++;
                    q[t]=v; 
                }
            }
        }
    } 
}  
int main() //主程序； 
{  
    scanf("%d %d %d",&n,&m,&s); 
    for(int i=1;i<=m;i++) 
    { 
        scanf("%d %d %d",&f,&g,&w);//输入这条边的起点f，终点g和长度w;  
        add(f,g,w);//建图;
    } 
    for(int i=1;i<=n;i++)//因为题目要我们求一个点到其余点的最短路; 
        dis[i]=2147483647;//所以初始化全部赋为int的最大值; 
    dis[s]=0;//起点到本身的的距离为0;
    q[t]=s;//起点入队； 
    vis[s]=true;//标志改为true表示起点已入队； 
    SPFA(); //运行最短路； 
    for(int i=1;i<=n;i++)//循环输出答案； 
        printf("%d ",dis[i]);
    return 0; 
}

---

## 作者：fanhy (赞：45)

既然楼下大佬都把算法讲清楚了，那我就蒻蒻地上一个 堆优化的dijkstra...

有些堆优化的代码对于新人不是很友好，比如：
```cpp
struct cmp
{
    bool operator()(int a,int b)
    {
        return dis[a]>dis[b];
    }
};
priority_queue<int,vector<int>,cmp> q;
```
还有：
```cpp
struct Node
{
    int dis,nodeid;
    bool operator < (const Node &a) const
    {
        return dis>a.dis;
    }
};
priority_queue<Node> q;
```
~~我上这两段代码不是给大牛看的~~

好吧，接下来我介绍一个数据类型：`pair`。

这个数据类型可以将两个数据进行打包，比如
```cpp
pair<int,int>
```
就是将两个int型进行打包。

而且使用优先队列时，优先队列会根据你打包的第一个数据进行排序。

那么问题来了，怎么将他们打包呢？

有个函数叫做make_pair()。

使用时：
```cpp
make_pair(0,1);
```
即把 0,1 打包。

好了，现在我们可以直接使用
```
priority_queue<int,vector<pair<int,int> >,greater<pair<int,int> > >q;
```
就可以省去写排序函数了。

其中pair的第一个数存长度，第二个数存节点编号。

下面是AC代码：
```
#include<bits/stdc++.h>
using namespace std;

int n,m,s;

struct node
{
    int next,to,len;
}edge[500005];

int cnt;
int head[100005];
bool visit[100005];
int dis[100005];

priority_queue<int,vector<pair<int,int> >,greater<pair<int,int> > >q;

void Add(int a,int b,int c)
{
    cnt++;
    edge[cnt]=(node){head[a],b,c};
    head[a]=cnt;
}

int main()
{
    for(int i=0;i<100005;i++) head[i]=0;
    for(int i=0;i<100005;i++) dis[i]=INT_MAX;
    cin>>n>>m>>s;
    for(int i=1;i<=m;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        Add(a,b,c);
    }
    dis[s]=0;
    q.push(make_pair(0,s));      //将源点入队
    while(!q.empty())
    {
    	int now=q.top().second;     //取节点编号
    	q.pop();    //弹出
    	if(visit[now]) continue;    //已经遍历过
        visit[now]=true;
        for(int i=head[now];i;i=edge[i].next) if(!visit[edge[i].to] && dis[edge[i].to]>dis[now]+edge[i].len)     //标准前向星遍历
        {
            dis[edge[i].to]=dis[now]+edge[i].len;
            q.push(make_pair(dis[edge[i].to],edge[i].to));    //入队
        }
    }
    for(int i=1;i<=n;i++) cout<<dis[i]<<' ';
    return 0;
}
```
同时，此代码也可通过 [P4779](https://www.luogu.org/problem/show?pid=P4779)。

祝大家刷题愉快。

---

## 作者：Niko (赞：27)

这里介绍一种线段树优化Dijkstar。

Dijkstra要查询当前点中dis的最小值可以用堆优化，似乎线段树也可以。

线段树储存点的编号，每取一个点，把它的值改成INF表示这个点已经访问过，其他的点直接在树上修改就好，每次查询整个线段树的最小值即可。复杂度nlog(n),用zkw线段树，常数也不算大，写的比较丑240ms

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm> 
using namespace std;
const int maxn =10007;
const int maxm = 500007;
const int INF = 0x7fffffff;
int n,m;
inline int read() {
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9') 
        c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x;
}
struct node{
    int v,next,w;
}edge[maxm];
int num=0,head[maxn];
inline void add_edge(int a,int b,int c) {
    edge[++num].v=b;edge[num].w=c;edge[num].next=head[a];head[a]=num;
} 
int dis[maxn],ans[maxn],s,t;
int tree[maxn<<2],leaf;
inline int check(int i,int j) {
    return dis[i]<dis[j]?i:j;
 } 
inline void build() {
    std::memset(dis,0x3f,sizeof dis);// for(int i=0;i<=n+1;i++) dis[i]=INF;
    for(leaf=1;leaf<=n;leaf<<=1);--leaf;
    for(int i=1;i<=n;++i)tree[leaf+i]=i;
}
inline void modify(int x,int y) {
    dis[x]=y,x+=leaf,x>>=1;
    while(x) tree[x]=check(tree[x<<1],tree[x<<1|1]),x=x>>1;
}
void dijkstra(int s) {
    build();
    dis[s]=0;
    int u=s;
    for(int i=1;i<=n;++i) {
        ans[u]=dis[u];
        const int disu=dis[u];
        modify(u,INF); 
        for(int j=head[u];j;j=edge[j].next){
              int v=edge[j].v;
              if(dis[v]<INF&&dis[v]>disu+edge[j].w)
                modify(v,disu+edge[j].w);
        }
        u=tree[1];
      }
}
inline void put(int x)
{
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);   
}

int main() {
    int k;
    n=read(),m=read(),k=read();
    for(int a,b,c,i=1;i<=m;++i) {
        a=read(),b=read(),c=read();
        add_edge(a,b,c);
    }
    dijkstra(k);
    for(int i=1;i<=n;++i) {
        if(dis[i]==0x3f3f3f3f)ans[i]=INF;
       // put(ans[i]), putchar(' ');
        printf("%d ",ans[i]);
    }
    return 0;
}
```

---

## 作者：兴安黑熊 (赞：21)

本意是最短路的入门题，题解很多，都是spfa居多，有人用dijkstra+优先队列求解，本人感觉纯的dijkstra也应该能过，只要使用邻接矩阵就行，本人习惯使用STL，果断采用vector建立邻接表，然后将结构体压入即可。至于dijkstra的基本原理，随意找个帖子看看就行，本题本人用了四种方法都AC 了（纯dijkstra,dijkstra+优先队列，spfa+vector，spfa+链式前向星），综合比较，spfa比较好写，容易上手！下面发一下纯dijkstra的代码：
```cpp
#include <iostream>
#include <vector>
using namespace std;
struct edge{int to;int cost;};
vector<edge>g[50005];
int d[50005];
int vis[50005];
int n;
const int inf=2147483647;
int djs(int s)
{   int min1,k;
    for(int i=1;i<=n;i++) d[i]=inf;
       
        d[s]=0;
        for(int i=1;i<n;i++)
        {
           min1=inf;k=s;


            for(int j=1;j<=n;j++)
            if (!vis[j]&&min1>d[j])
                {min1=d[j];k=j;}
               
            vis[k]=1;
            //cout<<"k="<<k<<endl;
            for(int j=0;j<g[k].size();j++)
            {  int tm=g[k][j].to;
                if(!vis[tm]&& min1+g[k][j].cost<d[tm])
                    d[tm]=min1+g[k][j].cost;

            }


        }
     return 0;

}

int main()
{   ios::sync_with_stdio(false);
    int m,s,x;
    cin>>n>>m>>s;
    edge tmp;
    for(int i=1;i<=m;i++)
    {
        cin>>x>>tmp.to>>tmp.cost;
        g[x].push_back(tmp);
    }
    
    djs(s);
    for(int i=1;i<=n;i++)
        cout<<d[i]<<" ";


    return 0;
}
```

---

## 作者：ljc20020730 (赞：17)

更好的体验：http://www.cnblogs.com/ljc20020730/p/7622200.html

千年不过的不用指针的spfa；

原来各位dalao是骗我的！

根本不用ff数组来判重！

加上这题目pas题解比较少就来谈谈5种AC的思路（顺便总结一下）；

①floyd算法 时间：O(n^3)；空间：O（n^2）;

对于20%的数据：N<=5，M<=15

对于40%的数据：N<=100，M<=10000

②dijkstra算法

时间： O(n^2); 空间：O（n^2）;

对于70%的数据：N<=1000，M<=100000

```cpp
uses math; 
const maxn=5000;
var g:array[1..maxn,1..maxn] of longint;
    d:array[1..maxn] of longint; //pre[i]指最短路径上I的前驱结点
    n,m,s,x,y,w,i,j:longint;
procedure dijkstra(v0:longint);
 var u:array[1..maxn] of boolean;
     i,j,k:longint; min:longint;
begin
  fillchar(u,sizeof(u),false);
  for i:=1 to n do d[i]:=g[v0,i];
  d[v0]:=0;
  u[v0]:=true;
  for i:=1 to n-1 do begin   //每循环一次加入一个离1集合最近的结点并调整其他结点的参数
    min:=2147483647; k:=0; //k记录离1集合最近的结点
    for j:=1 to n do
      if (not u[j]) and (d[j]<min) then begin
        k:=j; min:=d[j];
    end;
    if k=0 then break;
    u[k]:=true;
    for j:=1 to n do
      if (not u[j]) and (g[k,j]+d[k]<d[j]) then d[j]:=g[k,j]+d[k];
  end;
end;
begin
  readln(n,m,s);
  for i:=1 to n do
    for j:=1 to n do if i=j then g[i,j]:=0 else g[i,j]:=2147483647;
  for i:=1 to m do begin
    readln(x,y,w);
    g[x,y]:=min(w,g[x,y]);
  end;
  dijkstra(s);      //找出最短路径
  for i:=1 to n do write(d[i],' ');
  writeln;
end.
```
③dijkstra+前向星空间优化+堆优化
时间： O(n log n); 空间：O（kn）;

对于100%的数据：N<=10000，M<=500000



```cpp
type rec=record
 pre,en,w:longint;
end;
rec2=record
 id,val:longint;
end;
const inf=233333333;
      maxm=500000;
      maxn=10000;
var i,j,n,m,s,x,y,z,tot,nd:longint;
    d,head:array[-maxn..maxn]of longint;
    a:array[-maxm..maxm]of rec;
    dui:array[0..4*maxm]of rec2;
procedure swap(var a,b:rec2);
var t:rec2;
begin
 t:=a; a:=b; b:=t;
end;
procedure adde(u,v,w:longint);
begin
 inc(tot); a[tot].en:=v;
 a[tot].pre:=head[u];
 head[u]:=tot;
 a[tot].w:=w;
end;
procedure swap(var a,b:longint);
var t:longint;
begin t:=a;a:=b;b:=t;end;
procedure up(x:longint);//将一个结点“上浮”
begin
  while x>1 do begin //没有上浮到最顶层
    if dui[x].val>dui[x div 2].val then break;//如果上方的结点小于此节点，则暂停上浮
    swap(dui[x],dui[x div 2]);//交换上方结点与此结点
    x:=x div 2;
  end;
end;
procedure down(x:longint);//将一个节点“下沉”
  var y:longint;
begin
  while x<nd do begin
    y:=x+x;//y是x的左儿子
    if y>nd then break;//x已经沉到底部
    if (y<nd)and(dui[y+1].val<dui[y].val) then inc(y);//如果x存在右儿子，且右儿子比左儿子小，则将y赋值到右儿子
    if dui[x].val<=dui[y].val then break;//若两个儿子中的较小值仍然比x大，则停止下沉
    swap(dui[x],dui[y]);//下沉
    x:=y;
  end;
end;
function pop():longint;
begin
  pop:=dui[1].id;
  swap(dui[1],dui[nd]);//将最后的结点（保证其没有儿子）与最顶端交换
  dec(nd);
  down(1);//下沉顶端
end;
procedure dijkstra(v0:longint);
var i,j,k,minn,u,v,p:longint;
    vis:array[-maxn..maxn]of boolean;
begin
 fillchar(vis,sizeof(vis),false);
 for i:=1 to n do d[i]:=inf;
 d[v0]:=0;
 dui[1].val:=0;
 dui[1].id:=v0;
 nd:=1;
 for i:=1 to n do begin
  u:=pop();
  while vis[u] and (nd>0) do u:=pop();
  vis[u]:=true;
  p:=head[u];
  while p>0 do begin
   v:=a[p].en;
   if (not vis[v]) and(d[u]+a[p].w<d[v]) then begin
    d[v]:=d[u]+a[p].w;
    inc(nd);
    dui[nd].id:=v;
    dui[nd].val:=d[v];
    up(nd);
   end;
   p:=a[p].pre;
  end;
 end;
end;
begin
 readln(n,m,s);
 for i:=1 to m do begin
  readln(x,y,z);
  adde(x,y,z);
 end;
 dijkstra(s);
 for i:=1 to n do
 if d[i]=inf then write(2147483647,' ')else write(d[i],' ');
 writeln;
```
④ spfa队列优化+指针邻接表空间优化
时间： O(KE); 空间：O（KE）;

对于100%的数据：N<=10000，M<=500000；




```cpp
type pp=^node;
      node=record
      en,w:longint;
      pre:pp;
      end;
const maxn=50040;
var dis:array[0..maxn]of longint;
    a:array[0..maxn]of pp;
    n,m,b,u,v,x,y,i,j,l,w,s:longint;
procedure adde(u,v,w:longint);
var p:pp;
begin
 new(p);
 p^.pre:=a[u]^.pre;
 p^.en:=v; p^.w:=w;
 a[u]^.pre:=p;
end;
procedure spfa;
var f:array[0..maxn]of boolean;
    q:array[0..4*maxn]of longint;
    p:pp;
    head,tail,u,v:longint;
begin
 q[1]:=s; dis[s]:=0;
 head:=0; tail:=1;
 fillchar(f,sizeof(f),false);
 while head<tail do begin
  inc(head); u:=q[head]; p:=a[u];
  while p^.pre<>nil do begin
   p:=p^.pre; v:=p^.en; w:=p^.w;
   if dis[v]>dis[u]+w then begin
    dis[v]:=dis[u]+w;
    if not f[v] then begin
     f[v]:=true;
     inc(tail); q[tail]:=v;
    end;
   end;
  end;
  f[u]:=false;
 end;
end;
begin
 readln(n,m,s);
 for i:=1 to n do begin
  new(a[i]);
  a[i]^.pre:=nil;
 end;
 for i:=1 to m do begin
  readln(u,v,w);
  adde(u,v,w);
 end;
  for i:=1 to n do
  dis[i]:=maxlongint div 3;
 spfa;
// writeln;
 for i:=1 to n do
  if dis[i]=maxlongint div 3 then write('2147483647 ')
  else write(dis[i],' ');
 close(input);
 close(output);
end.
```
⑤ spfa队列优化+链式前向星空间优化
时间： O(KE); 空间：O（KE）;

对于100%的数据：N<=10000，M<=500000


```cpp
type rec=record
 w,en,pre:longint;
end;
var n,m,s,x,y,z,tot,i:longint;
    head,q,d:array[1..1000000]of longint;
    a:array[1..1000000]of rec;
procedure adde(u,v,w:longint);
begin
 inc(tot);
 a[tot].en:=v;
 a[tot].pre:=head[u];
 a[tot].w:=w;
 head[u]:=tot;
end;
procedure spfa;
var h,t,i,v,u:longint;
begin
 for i:=1 to n do d[i]:=maxlongint;
 q[1]:=s; d[s]:=0;
 h:=0; t:=1;
 while h<t do begin
  inc(h);
  u:=q[h];
  i:=head[u];
  while i>0 do begin
   v:=a[i].en;
   if d[v]=maxlongint then begin
    d[v]:=d[u]+a[i].w;
    inc(t);q[t]:=v;
   end else
   if d[v]-d[u]>a[i].w then begin
    inc(t);q[t]:=v;
    d[v]:=a[i].w+d[u];
   end;
   i:=a[i].pre;
  end;
 end;
end;
begin
 readln(n,m,s);
 for i:=1 to m do begin
  readln(x,y,z);
  adde(x,y,z);
 end;
 spfa;
 for i:=1 to n do
  if d[i]=maxlongint then write('2147483647 ')
  else write(d[i],' ');
end.
```

---

## 作者：元夕 (赞：11)

# spfa 入门
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000+10;//节点最大值
const int inf=1000000000;//边权最大值
struct node{
    int nxt,val;//下一条边编号，这条边的值
};
int n,m,s;//节点数，边数，源点
int p[maxn],d[maxn];//经过标记，长度
vector<node>e[maxn];//vector代替邻接表
queue<int>q;//queue优化
int main(){
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=m;i++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        node tmp;tmp.nxt=y;tmp.val=z;
        //新建边，边权为z，边编号为y
        e[x].push_back(tmp);
        //加入x的vector
    }
    for(int i=1;i<=n;i++)
        d[i]=inf;
    //全体初始最大化
    d[s]=0;q.push(s);p[s]=1;
    //初始化源点
    while(!q.empty()){//直到队列不为空
        int x=q.front();//取队头
        q.pop();//对头出队
        for(int i=0;i<e[x].size();i++){
            //循环vector[e[x]]的每一条边
            int u=e[x][i].nxt,v=e[x][i].val;
            //u为e[x][i]的编号，v为e[x][i]的权值
            if(d[u]>d[x]+v){
                d[u]=d[x]+v;//如果d[u]不如d[x]+v短，则更改d[u]的权
                if(!p[u]){
                    q.push(u);//u入队
                    p[u]=1;//标记u被经过
                }			
            }		
        }
        p[x]=0;//标记p[x]重置为0
    }
    for(int i=1;i<=n;i++)
        if(d[i]<inf)
            printf("%d ",d[i]);
        else 
            printf("2147483647 ");
    //输出
    return 0;
}
```

---

## 作者：huangzirui (赞：11)

# **P3371**

----
[题目链接](https://www.luogu.org/problemnew/show/P3371)
                  							     
                                                   
(因为我太弱了,所以大佬还是不要吐槽了 : ),谢谢)--大佬席------>

----
# 算法

----
我们用一种非常腻害的算法——$SPFA$

# 先来一组样例:

![](https://cdn.luogu.com.cn/upload/pic/21990.png)
# （起点为1）
用一个队列维护搜索的依次顺序，再用一个数组维护**目前从1号点到i号点的最短长度(权值)**，然后命名为vis。当目前不可以到达时，先调整为INF。当输出时判断:当最短距离==INF，输出2147483647。

对了，要记得
```cpp
vis[1]=0;
```
然后可以开始搜了!

(目前在队列中的点: $1$)

----
## 开始搜索点1:

**因为从1号点可以到达点2，且从点1到达点2的距离 $1+0$ 小于原本的距离 $INF$。所以我们更新vis[2]，并把点2加入队列。**

同理，调整vis[5]，把点5加入队列。
![](https://cdn.luogu.com.cn/upload/pic/21989.png)

(目前在队列中的点: $2$,$5$)

----
## 开始搜索点2:

**因为从2号点可以到达点3，且从点1到达点3的距离 $4+1$ 小于原本的距离 $INF$。所以我们更新vis[3]，并把点3加入队列。**

同理，调整vis[4]，把点4加入队列。
![](https://cdn.luogu.com.cn/upload/pic/21992.png )

(目前在队列中的点: $5$,$3$,$4$)

----
## 开始搜索点5:

**因为从5号点可以到达点3，且从点1到达点3的距离 $1+2$ 小于原本的距离 $4$。所以我们更新vis[3]，又因为点3已经加入了队列，所以不用重复加入。**

![](https://cdn.luogu.com.cn/upload/pic/21993.png )

(目前在队列中的点: $3$,$4$)

----
## 开始搜索点3:

**因为从3号点~~可以到达幻想乡~~什么也不能到达，所以什么也没有发生QWQ。**

![](https://cdn.luogu.com.cn/upload/pic/21993.png )

(目前在队列中的点: $4$)

----
## 开始搜索点4:

**虽然从4号点可以到达点5，但从点4到达点3的距离 $1+4$ 大于原本的距离 $2$。所以我们不用更新vis[3]。**

![](https://cdn.luogu.com.cn/upload/pic/21993.png )

(目前在队列中的点:无)

----
于是输出:
```
0 1 3 4 2
```
## 算法部分完毕！

----
# 建图

----
观察数据规模:

**对于100%的数据：N<=10000，M<=500000**

QWQ......

考虑使用邻接矩阵...
```cpp
int a[10010][10010];
```

~~点一下有惊喜~~

[![](https://cdn.luogu.com.cn/upload/pic/21996.png )](https://www.luogu.org/recordnew/show/8094663)

QWQ......

好吧，不说了，加入正题：

# 新的建图方法——链式前向星！！！

~~已经会了的dalao们就跳过吧QWQ~~

----

窝不想讲吗~~~(捂脸)人家不想讲吗

[戳一下](http://baidu.apphb.com/?q=%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F)

(窝还是提供一份链式前向星的代码吧~~~)

```cpp
int head[maxn];//从i点出发的第一条边
struct egde{
	int to,next_,w;//分别代表每条线目的地,下一条线的下标和权值
}a[maxm]
//这样就可以用下列代码来依次把从now点出发的边遍历
for(i=head[now];i;i=a[i].next_)
//是不是很神奇啊!
//后面的是加入一条边的
void add(int u,int y,int o){
	//建图
    len++;
    c[len].next_=head[u];
    c[len].to=y;
    c[len].dis=o;
    head[u]=len;
}
```

----

## 我再放上代码吧！

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
int i,j,k,n,m,s,len;
int vis[10010];
int dis[10010];//判断是否进队
int head[500010];
int dl[500010],l,r;
struct stu{
    int next_,to,w;
}c[500010];
void add(int u,int y,int o){
    //建图
    len++;
    c[len].next_=head[u];
    c[len].to=y;
    c[len].w=o;
    head[u]=len;
}
void SPFA(){
    //初始化
    for(i=1;i<=n;i++){
        vis[i]=INF;
    }
    vis[s]=0;
    l=0;r=1;dl[r]=s;dis[s]=1;
    //设置队列
    while(l^r/*没用的位运算,也就是j!=r*/){
        l++;
        int u=dl[l];
        dis[u]=0;
        for(i=head[u];i;i=c[i].next_){//遍历每条从i点出发的边
            int v=c[i].to;
            if(vis[v]>vis[u]+c[i].w){//如果路径长度小于原长度
                vis[v]=vis[u]+c[i].w;//调整
                if(!dis[v]){
                    //入队
                    dis[v]=1;
                    r++;
                    dl[r]=v;
                }
            }
        }
    }
}
int main(){
    cin>>n>>m>>s;
    //输入
    for(i=1;i<=m;i++){
        int u,y,o;
        scanf("%d%d%d",&u,&y,&o);
        add(u,y,o);
    }
    SPFA();
    //输出
    for(i=1;i<=n;i++)
        if(vis[i]==INF)cout<<2147483647<<" ";
        else cout<<vis[i]<<" ";
    return 0;
}
```

---

## 作者：C2H6O (赞：11)

### Dijkstra+zkw线段树题解

楼下貌似也有zkw线段树的题解不过没有细讲，我给大家安利一波

事实上有人拿stl以及pb_ds库里的各种priority_queue做过Dijkstra测试，实践证明线段树强无敌!(顺便再安利一波pb_ds库，带支持查询排名BST和的可并堆)

![](https://cdn.luogu.com.cn/upload/pic/18381.png)

zkw线段树是一种非递归的线段树，出处：清华大学 张昆玮(zkw) - ppt 《统计的力量》所以被广大网友崇为zkw线段树

由于二叉树的节点编号非常明确，严格满足左儿子=父亲*2，右儿子=父亲*2+1，所以每个叶子结点的编号是既知的，每次更新直接从叶子开始即可

zkw线段树对于单点修改和区间查询非常方便（区间修改略麻烦，思路会发生改变，具体可以百度），由于大量位运算所以速度极快，代码极短（不超过3行）。每次只需从叶子更新到根，即可。

用线段树优化Dijkstra的方式很简单，每个叶子结点对应一个图上的点，通过区间最小值查询d最小的点，对于已完成和不连通的点只需将其d设为极大即可

附上丑陋的代码
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define lc minv[i << 1]
#define rc minv[i << 1 | 1]
#define N 10010
#define M 500010
#define INF 0x7fffffff
int n, m, s, L, minv[N << 2], d[N];
int to[M], nxt[M], v[M], head[N], ecnt;
inline void init() {//初始化线段树， L所记录的是叶子结点层的开始下标
	for (L = 1; L < n; L <<= 1);
	for (int i = 1; i <= n; i++) minv[i + L - 1] = i;
	for (int i = L - 1; i; i--) minv[i] = d[lc] < d[rc] ? lc : rc;//向上更新最小值
}
inline void update(int x) {//更新某结点到根
	for (int i = x + L - 1 >> 1; i; i >>= 1) minv[i] = d[lc] < d[rc] ? lc : rc;
}
inline void addedge(int& x, int& y, int& z) {
	to[++ecnt] = y;
	v[ecnt] = z;
	nxt[ecnt] = head[x];
	head[x] = ecnt;
}
void dijkstra() {
	bool done[N];
	memset(done, 0, sizeof(done));
	for (int i = 0; i <= n; i++) d[i] = INF;
	d[s] = 0;
	init();
	for(int i = 1; i <= n; i++) {
		int x = minv[1];//minv[]存的是d最小节点的编号，出队最小节点
		done[x] = 1;
		minv[x + L - 1] = 0;//默认0号节点d为无穷大，相当于出队x
		update(x);
		for (int i = head[x]; i; i = nxt[i]) {
			int& u = to[i];
			if (!done[u] && d[x] + v[i] < d[u]) {
				d[u] = d[x] + v[i];
				update(u);
			}
		}
	}
}
int main() {
	scanf("%d%d%d", &n, &m, &s);
	while (m--) {
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		addedge(x, y, z);
	}
	dijkstra();
	for (int i = 1; i <= n; i++) printf("%d ", d[i]);
	return 0;
}
```

---

## 作者：蔡俊黠 (赞：10)

初三准备中考 好久好久好久~都没有来洛谷刷题了

中考超常发挥上重点中学 写篇模板题解纪念一下

今天距NOIP还有100天 一起加油吧

题解如下：
```cpp
#include<iostream>
#include<queue>
#include<vector>
#include<cstring> 
#define N 500001
using namespace std;
struct kind{
	int to; //此边的目的地 
	int w; //此边的长度 
}e; //e表示边 
vector <kind> map[N]; //邻接矩阵 
queue <int> q; 
int visit[N],n,m,s; //visit用来记录这个结点有没有被访问过
long long cost[N]; //cost 记录起始点到i点的最短路长度 
void spfa()  //个人最熟悉SPFA 
{
	memset(visit,0,sizeof(visit)); //一开始啥结点也没访问过 
	q.push(s);  //s结点入队 
	visit[s]=1; //访问s结点做标记 
	cost[s]=0; //s点到s点的最短路为0 
	while (!q.empty())  //队列非空，如果空了说明全部结点访问完毕 
	{
		int t=q.front(); visit[t]=1; //入队，做标记 
		for (int i=0;i<map[t].size();i++) //一个个地访问t结点连着的结点 
		{
			int to=map[t][i].to; //to表示t点的目标点 
			if (cost[to]>cost[t]+map[t][i].w) //如果可被松弛 
			{
				cost[to]=cost[t]+map[t][i].w; //松弛 
				if (!visit[to]) //没有被访问过的结点入队 
				{
					q.push(to);
					visit[to]=1;
				}
			}
		}
		visit[t]=0;
		q.pop(); //出队 
	}
}
int main()
{
	cin>>n>>m>>s;
	for (int i=1;i<=m;i++) 
	{
		int a,b,c;
		cin>>a>>b>>c;
		e.to=b; e.w=c;
		map[a].push_back(e); //建图 
		cost[i]=2147483647; //初始化 
	}
	spfa(); //去吧SPFA 
	for (int i=1;i<=n;i++) cout<<cost[i]<<" ";
	return 0;
}
```



---

## 作者：Leaved_ (赞：9)

[二倍经验](https://www.luogu.org/problem/P4779) P4779

~~话说这题就是一道Dij板子~~

这个弱化版的数据较弱，普通Dij也能过，但[P4779](https://www.luogu.org/problem/P4779)就很毒瘤，要用堆优化...

使用c++STL优先队列，用链式前向星存图

使用Dijkstra要注意的是，它是一种单源最短路算法...

代码：（堆优化dij）

```
#include <bits/stdc++.h>

#define INF 0x3f3f

using namespace std;

int n,m,s,tot;
long long dis[1000010<<1],h[2000010<<1];
bool used[2000010<<1];

priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;//pair的优先队列
//一定要加空格，要不然在编译器眼里等价与右移

struct Node {
	long long to,w,next;
}e[2000010<<1];

void add_edge(long long x,long long y,long long z) {
	++tot;
	e[tot].to=y;
	e[tot].next=h[x];
	e[tot].w=z;
	h[x]=tot;
}

void input() {
	long long u,v,w;
	cin>>n>>m>>s;
	for(long long i=1;i<=m;i++) {
		cin>>u>>v>>w;
		add_edge(u,v,w);//链式前向星存图
	}
}

void Dijkstra() {
	while(q.size()) {
		long long u=q.top().second;
		q.pop();
		if(used[u]) continue;
		used[u]=1;
		for(int i=h[u];i;i=e[i].next) {
			long long v=e[i].to;
			if(dis[v]>dis[u]+e[i].w) {//松弛，更换最短路径
				dis[v]=dis[u]+e[i].w;
				q.push(make_pair(dis[v],v));
			}
		}
	}
}

void output() {
	for(int i=1;i<=n;i++) {
		cout<<dis[i]<<" ";
	}
}

int main() {
	input();
	for(int i=1;i<=n;i++) {
		dis[i]=2147483647;
	}
	dis[s]=0;
	q.push(make_pair(0,s));
	Dijkstra();
	output();
}
```

---

## 作者：KellyFrog (赞：7)

## $\text{spfa}$ 
> --队列优化的[$\text{bellman-ford}$算法](https://www.luogu.com.cn/blog/ThereMust/textbellman-ford)

$\text{spfa}$算法，即队列优化的$\text{bellman-ford}$算法,有$O(|e|\times|v|)$的复杂度上界,在疏松图中往往是$O(k\times|e|)$级别的复杂度,其中$k$是常数

观察$\text{bellman-ford}$的运行（从我bf算法的博客摘来的）:

![1](https://cdn.luogu.com.cn/upload/image_hosting/13n2qds1.png)
![2](https://cdn.luogu.com.cn/upload/image_hosting/3q0urgnd.png)
![3](https://cdn.luogu.com.cn/upload/image_hosting/vj61p32p.png)
![4](https://cdn.luogu.com.cn/upload/image_hosting/1vdhugzy.png)

发现有些点,你从前$i$个点根本松弛不到,于是我们采用广搜的方式(即用队列)对图进行遍历,避免时间的浪费，但是普通的广搜在寻找最短路的时候无法保证当前的节点是最优的，看张图：
![bfs-wrong](https://cdn.luogu.com.cn/upload/image_hosting/7ok8n82u.png)
要是之前的某个点不是最优的，后边搜到的点也无法保证最优

于是我们的$\text{spfa}$算法非常聪明地避免了这一情况，将需要更新的节点重新入队（如果它不在队列中），以保证后边搜到的点的权值最优（~~大不了重新搜一遍后边的点吗~~）

以上边的图为例，在点3松弛完点2时，重新入队点2，于是

![right](https://cdn.luogu.com.cn/upload/image_hosting/4p4fx51g.png)

但也是这条给了毒瘤出题人卡$\text{spfa}$算法的空间，即让元素一遍一遍地重新入队，已达到时间退化的效果

综上，$\text{spfa}=\text{bfs}(\text{queue})+\text{bellman-ford}$

[$\text{spfa}$判负环](https://www.luogu.com.cn/blog/ThereMust/)（~~咕咕咕咕~~）

code:[$\text{spfa}$模板](https://www.luogu.com.cn/problem/P3371)
```cpp
#include <iostream>
#include <fstream>
#include <queue>
#include <cstdlib>

using namespace std;

const int MAXN = 5e5 + 5;

int head[MAXN], next[MAXN], to[MAXN], weight[MAXN];
int tot = 0;

int n, m, s;
int dis[MAXN], vis[MAXN];
bool inQueue[MAXN];
queue<int> q;

void AddEdge(int u, int v, int w) {
  next[++tot] = head[u];
  to[tot] = v;
  weight[tot] = w;
  head[u] = tot;
}

bool Relax(int u, int v, int w) {
  if(dis[v] > dis[u] + w) {
    dis[v] = dis[u] + w;
    return true;
  }
  return false;
}

void Error() {
  cout << "negetive loop!" << endl;
  exit(0);
}

void Spfa(int start) {
  for(int i = 0; i < MAXN; i++) {
    dis[i] = 2147483647;
  }
  q.push(start);
  inQueue[start] = true;
  dis[start] = 0;
  vis[start] = 1;
  while(!q.empty()) {
    int u = q.front();
    q.pop();
    vis[u]++;
    inQueue[u] = false;
    if(vis[u] > n) { //判负环 
      Error();
    }
    for(int i = head[u]; i; i = next[i]) {
      int v = to[i];
      int w = weight[i];
      if(Relax(u, v, w) && !inQueue[v]) {
	q.push(v);
        inQueue[v] = false;
      }
    }
  }
}

int main() {
  ifstream inFile("spfa.in");
  cin >> n >> m >> s;
  for(int i = 0; i < m; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    AddEdge(u, v, w);
  }
  Spfa(s);
  for(int i = 1; i < n + 1; i++) {
    cout << dis[i] << ' ';
  }
  cout << endl;
  return 0;
}
```

---

## 作者：约修亚_RK (赞：7)

单源最短路，趁着这题复习一波Dijkstra。

0) 选定起点，将其加入队列【队列中为待访问的点】；

while (队列不为空)

1) 把队列中离起点最短的点提出来（用优先队列实现）；

2) 查看所有以这个点为起点的边，更新距离目标点的最短距离( dis[目标点] > dis[当前点] + w[当前边] 的话 )。一旦更新，就把目标点丢到队列里去。


然后dis[k]就是起点到目标点的最短距离了。


```cpp
/* P3371
 * Au: SJoshua
 */
#include <cstdio>
#include <cstring>
#include <queue> 
#include <vector>

using namespace std;

struct edge {
    int u, v, w;
} edges[500001];

struct node {
    int u, d;
    bool operator < (const node &n) const {
        return d > n.d;
    }
} temp;

vector <int> map[10001];
priority_queue <node> q; 
int dis[10001]; 
bool visited[10001];

int main(void) {
    int n, m, s;
    scanf("%d %d %d", &n, &m, &s);
    for (int k = 1; k <= m; k++) {
        scanf("%d %d %d", &edges[k].u, &edges[k].v, &edges[k].w);
        map[edges[k].u].push_back(k); 
    } 
    memset(dis, 0x3f, sizeof(dis));
    dis[s] = 0;
    temp.u = s;
    q.push(temp);
    while (!q.empty()) {
        node tmp = q.top();
        q.pop();
        if (visited[tmp.u]) {
            continue; 
        } 
        visited[tmp.u] = true;
        for (unsigned int k = 0; k < map[tmp.u].size(); k++) {
            edge &e = edges[map[tmp.u][k]];
            if (dis[e.v] > dis[e.u] + e.w) {
                temp.d = dis[temp.u = e.v] = dis[e.u] + e.w;
                q.push(temp);
            }
        }
    }
    for (int k = 1; k <= n; k++) {
        printf("%d ", dis[k] == 0x3f3f3f3f ? 2147483647 : dis[k]); 
    } 
    return 0;
} 
```

---

## 作者：MuYC (赞：6)

这道题，标准的SPFA板子题;

### 注意
这道题的n比较大，不能用连接矩阵存储。

此时，应当选用连接表。我在用连接表的时候加上了二分来优化（效果不是很明显，但还是有的。）

## 那么什么是SPFA？
```
若给定的图存在负权边，类似Dijkstra算法等算法便没有了用武之地，
SPFA算法便派上用场了。
简洁起见，我们约定加权有向图G不存在负权回路，即最短路径一定存在。
用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。
我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，
优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，
如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。
这样不断从队列中取出结点来进行松弛操作，直至队列空为止。

定理：只要最短路径存在，上述SPFA算法必定能求出最小值。
证明：每次将点放入队尾，都是经过松弛操作达到的。
换言之，每次的优化将会有某个点v的最短路径估计值d[v]变小。
所以算法的执行会使d越来越小。
由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。
因此，算法不会无限执行下去，随着d值的逐渐变小，
直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。
```
此解释来源于网络。

来个图解：（还是文本版的图表）

首先，我们赋值一个距离数组Dis，Dis[i]它表示从s到i的距离，先将s入队，然后依次扩张（类似于BFS），每次取出后又放入扩张出来的节点，不存在负环时，一条路径最多经过n个节点。而用连接表，我将边先按起点排序（因为它是有向的），然后我取出一个节点时，将它作为起点，扩张，此时二分就起了作用，可以快速找到起点为此节点的路径，没错，EZ啦

所以SPFA时间复杂度为O(KE),就是酱紫.

# CODE
```
#include <bits/stdc++.h>
using namespace std;
int n,m,s;
struct node{
	int s,t,v;
}R[500000+5];
int book[10000+5];
int find( int x ){//二分查找优化SPFA
	int l=1,r=m,mid=(l+r)>>1;
	while( l < r ){
		if(R[mid].s>x)r=mid-1;
		if(R[mid].s<x)l=mid+1;
		if(R[mid].s==x)return mid;
		mid=(l+r)>>1;
	}
	return (l+r)>>1;
}
int SPFA( int x ){//人畜无害的SPFA
	int i,q[100000+5],vis[10000+5],dis[10000+5],v,k,head=0,tail=1;
	q[1]=s,vis[s]=1;
	for ( i = 1 ; i <= n; i ++)dis[i]=2147483647;
	dis[s]=0;
	while(head < tail){
		head++;v=q[head],vis[v]=0;
		if(book[v]!=0){	
			i=find(v);
			for( ;i >= 1 ; i --)if(R[i].s!=v)break;//二分残留的BUG修改，我太弱了
			i++;//二分残留的BUG修改
			for ( ; i <= m ; i ++){
				if(R[i].s!=v)break;//终止循环
					else if(dis[v] + R[i].v< dis[R[i].t]){//松弛操作
						dis[R[i].t]=dis[v] + R[i].v;
						if(vis[R[i].t]!=1)tail++,q[tail]=R[i].t,vis[R[i].t]=1;//入队
					}
			}
		}
	}
	for ( i = 1 ; i <= n; i ++)cout<<dis[i]<<" ";//out
	return 0;
}
int cmp( node a , node b){return a.s<b.s;}
int main(){
	int i,j,k;
	cin>>n>>m>>s;
	for ( i = 1 ; i <= m; i ++)cin>>R[i].s>>R[i].t>>R[i].v,book[R[i].s]=1;
	sort( R +1 , R +1+ m,cmp);
	SPFA(s);
	return 0;
}
```
有点小丑，不喜无喷，谢谢。

---

## 作者：zhouyanyu321 (赞：5)

## 队列优化的Bellman

~~哭唧唧，大家都把Bellman忘了~~

### 其实SPFA就是这个算法的改进版

~~不幸的是它已经die掉了~~
![](https://cdn.luogu.com.cn/upload/pic/25108.png)

### 算法具体思路就是不断尝试对边进行松弛，若松弛成功就将点加入到队列中，之后的松弛操作就只对队列中的点进行，优化了时间复杂度


------------


## 那么如何判断负权回路呢~


### 如果一个顶点被加入到队列中的次数超过n次，说明经过n轮松弛操作后仍存在最短路，那么此图一定存在负权回路

~~（但是这道题并没有带负环的数据）~~

废话不多说，上代码大家自己研究吧  ~^0^~

```cpp
#include<iostream>
#include<queue>//用到队列 

using namespace std;

#define loop1 for(int t=first[q.front()];t!=-1;t=nxt[t])//装逼专用 

const int max_n=100005;//n的最大值 
const int max_m=500005;//m的最大值 
const int inf=2147483647;//正无穷 

queue<int> q;//维护已松弛的顶点 

int u[max_m]/*始边 */,v[max_m]/*终边 */,w[max_m]/*权值 */,n,m,a/*询问的始边 */;
int first[max_n]/*每个顶点第一条边的编号 */,nxt[max_m]/*当前边下一条边的编号 */;
int dis[max_n];//存储松弛结果 
int sum[max_n];//判断负权回路 
bool vis[max_n]/*标记顶点是否在队列中*/,flag/*判断负权回路 */;

void init()//初始化 
{
	for(int i=1;i<=n;i++)
		dis[i]=inf;
	dis[a]=0;
	for(int i=1;i<=n;i++)
		first[i]=-1;
	return;
}

void read()//输入 
{
	for(int i=1;i<=m;i++)
	{
		cin>>u[i]>>v[i]>>w[i];
		nxt[i]=first[u[i]];//更新下一条边 
		first[u[i]]=i;/*更新当前顶点所对的第一条边*/ 
	}	
	return;
}

void write()//输出 
{
	for(int i=1;i<=n;i++)
		cout<<dis[i]<<" ";
	return;
}

int main()
{
	cin>>n>>m>>a;
	init();
	read();
	q.push(a);//入队 
	vis[a]=true;//标记a已入队 
	while(!q.empty())//队列不为空时循环 
	{
		loop1//遍历，详见最上方的装逼代码
		{
			if(dis[v[t]]>dis[u[t]]+w[t])/*如果松弛成功*/ 
			{
				dis[v[t]]=dis[u[t]]+w[t];/*存储松弛后的值 */
				if(!vis[v[t]])//如果不在队列中 
				{
					q.push(v[t]);//入队 
					vis[v[t]]=true;//标记 
					sum[v[t]]++;//记录入队次数 
					易夫(sum[v[t]]>n)/*如果入队次数大于n,说明存在负权回路 */
					{
						flag=true;/*标记负权回路 */
						break;/*不存在最短路，直接退出 */
					}
				}
			}
		}
		if(flag) break;/*不存在最短路，直接退出 */
		vis[q.front()]=false;//取消队首的标记 
		q.pop();//出队
	}
	if(flag) cout<<"-1";/*有负权回路则输出-1(虽然题目数据中没有) */
	else write();//输出松弛后的dis数组 
	cout<<endl;
	return 零;
}

//送上数据一波~ ^0^ 

/*一般数据  
input:

5 7 1

1 2 2
1 5 10
2 3 3
2 5 7
3 4 4
4 5 5
5 3 6

output:0 2 5 9 9

*/
/*负权回路构造检测  
input: 

6 6 1

1 2 1
2 3 -2
3 4 -2
4 5 -2
5 2 -2
4 6 1

output:-1
 
*/
```
#### 注：代码思路来自于《啊哈！算法》一书，作者  啊哈磊

---

## 作者：litangxingxing (赞：5)

模板
单元最短路一般有两种写法

SPFA和dijkstra

个人喜欢后者（虽然好像写法和时间复杂度都不怎么优）。


一开始我没看数据，裸的dij就拍上去了。

崩
70
dijkstra需要堆优化

这里使用STL一个叫priority\_queue的神(zhe)奇(xue)的数据结构。

里面跑的就是一个堆。

它支持用struct修改排序规则。

详细看代码。


下面70分代码


```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int inf=2147483647;
struct edge{
    int to,next,s;
}e[500005];
int n,m,sta,mn;
int head[10005];
int dis[10005];
bool vis[10005];
void dijkstra(int sta){
    for(int i=1;i<=n;i++){
        dis[i]=inf;
    }
    dis[sta]=0;
    int now;
    for(int k=1;k<n;k++){
        mn=inf;
        for(int i=1;i<=n;i++){
            if(!vis[i]&&dis[i]<mn){
                now=i;
                mn=dis[i];
            }
        }
        vis[now]=1;
        int c=head[now];
        while(c){
            int mu=e[c].to;
            if(dis[mu]>dis[now]+e[c].s)dis[mu]=dis[now]+e[c].s;
            c=e[c].next;
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&sta);
    int u,v,c;
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&u,&v,&c);
        e[i].to=v;
        e[i].next=head[u];
        e[i].s=c;
        head[u]=i;
    }
//    dijkstra(sta);
    for(int i=1;i<=n;i++){
        printf("%d ",dis[i]);
    }
    return 0;
}
```
堆优化

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int inf=2147483647;
struct edge{
    int to,next,s;
}e[500005];
struct point{
    int na,s;
}dis[10005];
struct cmp1{
    bool operator ()(point &a,point &b){
        return a.s>b.s;
    }
};
priority_queue<point,vector<point>,cmp1> q;
int n,m,sta,mn;
int head[10005];
bool vis[10005];
void dijkstra(int sta){
    for(int i=1;i<=n;i++){
        dis[i].na=i;
        dis[i].s=inf;
    }
    dis[sta].s=0;
    int now=0;
    vis[0]=1;
    q.push(dis[sta]);
    for(int k=1;k<n;k++){
        while(vis[now]){
            now=q.top().na;
            q.pop();
        }
        vis[now]=1;
        int c=head[now];
        while(c){
            int mu=e[c].to;
            if(dis[mu].s>dis[now].s+e[c].s){
                dis[mu].s=dis[now].s+e[c].s;
                q.push(dis[mu]);
            }
            c=e[c].next;
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&sta);
    int u,v,c;
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&u,&v,&c);
        e[i].to=v;
        e[i].next=head[u];
        e[i].s=c;
        head[u]=i;
    }
//    dijkstra(sta);
    for(int i=1;i<=n;i++){
        printf("%d ",dis[i].s);
    }
    return 0;
}
```
SPFA感觉非常简单又好懂
开一个队列，先入先出，不断拿队头的元素松弛，松弛成功的话把对象丢进队列（在队里就省略进队操作）

效率迷之高


100分代码


```cpp
#include<cstdio>
#include<cstring>
#define inf 2147483647
using namespace std;
struct edge{
    int to,next,s;
}e[500005];
int h[10005],tot;
int n,m,st;
int dis[10005];
int q[10000005],tail,head;
bool inq[10005];
void add(int u,int v,int s){
    e[++tot].to=v;
    e[tot].next=h[u];
    e[tot].s=s;
    h[u]=tot;
}
void SPFA(){
    for(int i=1;i<=n;i++){
        dis[i]=inf;
    }
    dis[st]=0;
    q[tail++]=st;
    inq[st]=1;
    while(head<tail){
        int u=q[head++];
        inq[u]=0;
        for(int c=h[u];c;c=e[c].next){
            int v=e[c].to;
            if(dis[u]+e[c].s<dis[v]){
                dis[v]=dis[u]+e[c].s;
                if(!inq[v]){
                    q[tail++]=v;
                    inq[v]=1;
                }
            }
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&st);
    for(int i=1;i<=m;i++){
        int u,v,s;
        scanf("%d%d%d",&u,&v,&s);
        add(u,v,s);
    }
//    SPFA();
    for(int i=1;i<=n;i++){
        printf("%d ",dis[i]);
    }
    return 0;
}
```
顺便
SPFA真迷……


---

## 作者：median_dxz (赞：4)

##什么是前向星

前向星是一种效率高，使用简便的存图方式，和其他大部分方式比，有着很大的优势：

● 对于动态数组，不用使用麻烦的STL和队列

● 对于邻接链表，不用操作指针

● 对于邻接矩阵，效率很高


##基本实现

一个数据结构，里面的成员可以存储起点，终点和权值，要有一个数组维护每点连出去的边的起点。


##链式前向星


#构造

上面的前向星是需要排序的，事实上大部分时间我们使用的都是链式前向星。链式前向星就是数组模拟链表，其基本实现如下：

```cpp
struct edge
{
     int next;//设i为这条边的起点，它指向以这条边为起点的下一条边
     int to;//这条边的终点
     int w;//权值
};
```
还有一个head数组用来维护以i为起点的第一条边，里面初始化为全负一。


#加边

前向星，顾名思义，我们应该让后面的边指向前一条边，这可能有点不直观。事实上，前向星存边是倒着存的。当加入新的边，这条边就是第一条边，同时链接到之前的第一条边，因此遍历时实际上是倒着遍历的。

```cpp
void add(int from;int to;int w)
{
edge[cut].w=w;
edge[cut].to=to;
edge[cut].next=head[from];
head[from]=cut;
cut++;
};
```

#遍历

从第一条边开始，e[k].[next]中即为下一条边的编号，从而遍历以sp为起点的所有边，当边的编号为-1时即跳出循环。

```cpp
for(k=head[sp];k!=-1;k=e[k].next)//源点为sp
```



```cpp
#include<iostream>
#include<cstring>
#define MAXN 10005
#define MAXM 500005
#define MAXI 2147483647

using namespace std;

struct edge{
    int from;//从哪条边出发
    int to;//到哪条边
    int next;//上一条同起点的边
    int w;//权值
};

void add(int u,int v,int w);
void spfa();

edge e[MAXM];
int head[MAXM];
int n,m,s,fi,gi,wi,i,cut=0;
int map[MAXN][MAXN];
int dis[MAXN];
int v[MAXN];
int push[500005];

int main(){
    cin>>n>>m>>s;
    
    for(i=1;i<=m;i++)
        head[i]=-1;
    
    for(i=1;i<=m;i++){
        cin>>fi>>wi>>gi;
        add(fi,wi,gi);       
    }
    
    for(i=1;i<=n;i++){
        dis[i]=MAXI;    
    }
       
    dis[s]=0;
    
    spfa();
    
    for(i=1;i<=n;i++){
        cout<<dis[i]<<' ';
    }
    return 0;
}

void spfa(){
    int k,j,h,t,sp;

    t=1;
    h=0;
    v[s]=1;
    push[1]=s;
    
    while(h<t){
        h++;
        sp=push[h];
        v[sp]=0;
        
        for(k=head[sp];k!=-1;k=e[k].next){//前向星遍历，e[k].to等价于邻接矩阵的map[sp][k]
            if(dis[e[k].to]>e[k].w+dis[sp]){
                dis[e[k].to]=e[k].w+dis[sp];
                if(v[e[k].to]==0){
                    t++;
                    v[e[k].to]=1;
                    push[t]=e[k].to;
                }
            }        
        }
    }
}
void add(int u,int v,int w){
    e[cut].w=w;
    e[cut].from=u;
    e[cut].to=v;
    e[cut].next=head[u];//上一条边是第一条边
    head[u]=cut;//把这条边变成第一条边
    cut++;
}
```

---

## 作者：fl_334 (赞：3)

因为c++有人交了题解所以转成pas给pas党带点福利

这么裸的模板sa

```cpp
        for i:=1 to v do
                first[i]:=-1;          //初始化
for i:=1 to e do
        begin
                read(s[i],d[i],w[i]);
                next[i]:=first[s[i]];              //这里我用的是邻接表，因为邻接矩阵会爆QAQ
                first[s[i]]:=i;
        end;
        for i:=0 to v do
                dis[i]:=maxlongint;                  //我大pa好哉，maxlongint就是2147什么来着
        q[1]:=ss;           //队列初始化
        h:=1;
        t:=1;
        book[ss]:=1;     dis[ss]:=0;        
        inc(t);
        while (h<t) do
        begin
                tmp:=q[h];         //队列里存的是节点编号
                k:=first[tmp];
                while (k<>-1) do
                begin
                        if (dis[d[k]]>dis[s[k]]+w[k]) then           //把tmp的所有出边遍历掉
                        begin
                                dis[d[k]]:=dis[s[k]]+w[k];         //更迭dis的值
                                if book[d[k]]=0 then
                                begin
                                        q[t]:=d[k];
                                        inc(t);                     //入队
                                        book[d[k]]:=1;           //标记
                                end;
                        end;
                        k:=next[k];              //找下条边
                end;
                inc(h);          //出队
                book[tmp]:=0;        
        end;
//核心代码23
```

---

## 作者：Mine_King (赞：3)

这题正解是$SPFA$，$dij$什么的都是秀  
以上瞎扯，不用管。  
简单介绍一下$SPFA$：先把所有点的值赋为INF，然后找到起点，标位零，将其压入队列（都到这里了，应该没人不会队列了吧…），下面的步骤要循环经行，直到队列为空。找到延生出来的节点，如果节点的值大于当前的点的值加边的长度（设当前节点的值是$v_i$，延伸出来的点的值是$v_j$，边的长度是$d_i$，则上面那句话的意思是如果$v_i$+$d_i$>$v_j$），就更新并加入队列。  
具体实现就是这个亚子：  
![](https://cdn.luogu.com.cn/upload/pic/71246.png)  
看到第三幅图的那个箭头了吗？那里是不能加入队列的，因为队列里已经有4号点了，这是$SPFA$最容易打错的地方。  
![](https://cdn.luogu.com.cn/upload/pic/71248.png)  
（图片来源与洛谷2019夏令营的课件）  
这里再说一下有关$SPFA$的其他的东西：

1. 上面更新点的最短路的操作称为松弛操作
2. $SPFA$可以有负权边，但$dij$不行
3. $SPFA$也可以判负权环，就是一个点被松弛了n次，该题没有负权环，因为负权环会使最短路无限小，而题面没有给出处理方法

接下来是最激动人心的时刻：**上代码！！！**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
queue<int>q;//系统自带队列，不懂的看底下
vector<int>g[200005];//同上
vector<int>dis[200005];
bool f[100005];//用于标记是否加入队列
int v[100005];//每个点离起点的最短路径
int main()
{
	cin>>n>>m>>s;
	for(register int i=1;i<=m;i++)
	{
		int ff,tt,dd;
		cin>>ff>>tt>>dd;
		g[ff].push_back(tt);
		dis[ff].push_back(dd);//建图
	}
	for(int i=1;i<=n;++i) v[i]=1e10;//初始化，SPFA的初始化必须是一个很大的值，因为它要处理负权边
	v[s]=0;
	f[s]=true;
	q.push(s);//压入起点
	while(!q.empty())//直到队列为空为止
	{
		int xx=q.front();q.pop();//取出第一个元素并弹出
		f[xx]=false;//标记为没有加入队列
		for(register int i=0;i<g[xx].size();i++)//该节点延伸出来的点
		 if(v[g[xx][i]]>v[xx]+dis[xx][i])//松弛操作
		 {
	 		 if(!f[g[xx][i]]) q.push(g[xx][i]),f[g[xx][i]]=true;//加入队列
			 v[g[xx][i]]=v[xx]+dis[xx][i];//更新
		 }
	}
	for(register int i=1;i<=n;i++)
	 if(v[i]!=1e10) cout<<v[i]<<' ';
	 else cout<<"2147483647"<<' ';
	return 0;
}
```
附：[$queue$](https://www.luogu.org/blog/yhdhg1395754790/solution-p1540) [$vector$](https://www.luogu.org/blog/yhdhg1395754790/vector-jian-jie) 以及 [本蒟蒻的博客](https://www.luogu.org/blog/yhdhg1395754790/)

---

## 作者：bowen404 (赞：2)

这题用 python 略坑，cpp 用 Dijkstra 就可以，python 写 Dijkstra 就得用堆优化。

当然，写完了 P4779 也可以直接过，不亏~

同时，读入也需要用 `sys.stdin.readline()` 来加速读入，大概能加速 30% - 60%。

另外还有个优化方法是使用 pypy3，这道题差别不大，有的题写不出来可以试试，速度大概能加速 30% - 60%。


```python
"""
这题不要求路线, 所以不需要存储前驱结点, 数据结构可以使用二维列表, 并且使用堆排序优化, 需要将距离放前边
"""

import heapq
import sys
import time

# t = time.time()
# inf = float('inf')
inf = 2 ** 31 - 1  # 题目规定了具体数值, 不能用上方无穷大

def dijkstra(start, g):  # 1, {1: [(2, 10), (4, 8)], 2: [(5, 5), ], ...}
    """
    给定起始点 start 和图 g, 求该点到其他所有点的最短距离
    return: 0 6 4 1
    """

    # 需要保存的信息及结构: [0, 距离s->1, 距离s->2, ...]
    dis = [inf] * 10010
    dis[0], dis[start] = 0, 0

    visited = [False] * 10010  # 编号基本连续, 用bool列表比set还快20%
    visited[0] = True

    q = []
    heapq.heappush(q, [0, start])

    # bfs 开始
    while q:
        # 在**routes中所有未访问过的点**中找最小值, 决定下一个点, 可以用堆优化
        min_weight, current = heapq.heappop(q)
        if visited[current]:
            continue

        visited[current] = True

        # 找到邻接顶点
        adj = g[current]  # adj = g[1] = [(3, 10), (5, 30), (6, 100)]

        # 根据当前点到邻接点的距离, 更新路径列表
        for vertex, weight in adj:
            min_weight_from_start = dis[current] + weight
            if min_weight_from_start < dis[vertex]:     # dijkstra 核心
                dis[vertex] = min_weight_from_start  # 3: 10

                # 如果 vertex 没有访问过, 就把当前最小权值和位置加进 q
                if not visited[vertex]:
                    heapq.heappush(q, [min_weight_from_start, vertex])

    return dis


n, m, s = map(int, sys.stdin.readline().split())
g = {i: [] for i in range(1, n+1)}
for i in range(m):
    u, v, w = map(int, sys.stdin.readline().split())
    g[u].append((v, w))

routes = dijkstra(s, g)

print(*routes[1:n+1])  # 用*可将序列解包, 元素之间自动加空格
```

---

## 作者：_Grey (赞：2)

## 发现题解中竟然没有SPFA的SLF优化

## 我就来写一个

## SPFA算法有两个小优化，虽然效率提升不多，但还是有的

## 一种叫SLF 另一种叫LLL

## 不过我更喜欢SLF一点 ~~（SLF好写）~~

### 关于SLF + LLL 优化版本

## [提交记录(吸了所有氧气)](https://www.luogu.org/record/22890685)

## 好了言归正传

## SLF（Small Label First）优化

## 思路:用deque，对一个要加入队列的点u，如果dis[u] < dis[v]，那么就加入到队首元素，否则加入到队尾。

```
#include <bits/stdc++.h>
#define maxn 100001
using namespace std;
int cnt,head[maxn],n,m,dis[maxn],s;
bool vis[maxn];
struct node{
	int v,c,nxt;
}e[maxn];
inline void add_edge(int u,int v,int c){
	e[++cnt].v = v;
	e[cnt].c = c;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
void SpfaSLF(){
	deque <int> q;
	for (int i = 1;i <= n;++i)dis[i] = INT_MAX;
    q.push_back(s);vis[s] = true;dis[s] = 0;
    while (!q.empty()) {
        int u = q.front();
        q.pop_front();
        vis[u] = false;
        for (int i = head[u]; i; i = e[i].nxt) {
        	int v = e[i].v;
            if (dis[v] > dis[u] + e[i].c) {
                dis[v] = dis[u] + e[i].c;
                if (!vis[v]) {
                    if (dis[v] <= dis[u]) q.push_front(v);
                    else q.push_back(v);
                    vis[v] = true;
                }
            }
        }
    }	
}
int main()
{
    cin >> n >> m >> s;;
    for (int i = 1;i <= m;++i){
    	int u,v,c;
    	cin >> u >> v >> c;
    	add_edge(u,v,c);
    }
   	SpfaSLF();
   	for (int i = 1;i <= n;++i)
    cout << dis[i]<<" ";
}
```

---

## 作者：KING__Arthur (赞：2)

# 一个story：
2018.10.3，晚上，在与我校是竞争关系的学校的机房（去一起集训）训练。


我：（颓）

对方教练：（走过来）

我：（赶快开始假装研究SPFA）

对方教练：这是？最短路？

我：是啊是啊（疯狂掩饰尴尬）

对方：这是SPFA?

我：是啊是啊（疯狂掩饰尴尬）

对方：嗯，为什么不写dijstra？

我：因为.嗯...这个，因为...SPFA好写！~~（雾）~~

对方：dijkstra也很好写啊

我：这个..因为......SPFA好用啊，啊呵呵呵呵~~~~

对方：嗯?可是它会被卡啊，我从来只写dijkstra。

我：啊哈哈或或哈哈哈，好吧

#### 于是我研究了一下dijkstra，哦哦哦，除了不能处理负权，还是很好用的，~~教练没有坑我~~
##### 在这里发一下STL堆优化的dijkstra，因为用负值处理，所以甚至不用写比较函数，代码自然比一般STL还要简洁，666

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<stack>
#include<set>
#include<map>
#include<cmath>
#include<list>
#include<cstring>
#include <climits>//bei
using namespace std;
priority_queue< pair<int,int> > q;
long long cnt=0,dis[1000000],vis[1000000],hand[1000000],n,m,g;
struct aa//静态邻接表，好写又不占太多空间，抱走了
{
	int to,next,w;
};
aa xx[10000000];
inline void djstl()
{
	for(int i=1;i<=n;i++)
	  dis[i]=2147483647;
	q.push(make_pair(0,g));dis[g]=0;
	while(!q.empty())
	{
		int now=q.top().second;
		q.pop();
		if(vis[now]==1) continue;
		vis[now]=1;
		for(int i=hand[now];i;i=xx[i].next)
		{
			int v=xx[i].to;
			if(dis[v]>dis[now]+xx[i].w)
			{
				dis[v]=dis[now]+xx[i].w;
				q.push(make_pair(-dis[v],v));
			}
		}
	}
	
}
int main()
{
	cin>>n>>m>>g;
	for(int i=1;i<=m;i++)//处理边，读入静态邻接表
	{
		int a,b,c;
		cin>>a>>b>>c;
		xx[++cnt].to=b;
		xx[cnt].next=hand[a];//存的是上一条边
		xx[cnt].w=c;
		hand[a]=cnt;
	}
	djstl();
	for(int i=1;i<=n;i++)
	{
		if(g==i) cout<<0<<" ";
		else cout<<dis[i]<<" ";
	}
	cout<<endl;
	return 0;
}

```

---

## 作者：ikka (赞：2)

emm指针这么好用为什么没有人用呢（滑稽

指针邻接链表+堆优化Dijkstra只跑了180ms

那我就来补一篇**指针邻接链表+堆优化Dijkstra+IO优化**的题解吧

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
/*IO优化*/ 
#include <cctype>
#define rc register char
#define ri register int
char ss[1<<17],*A=ss,*B=ss;
inline char gc() { return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?EOF:*A++; }
template<class T>inline void read(T& x) {
    rc c;ri y=1;while(c=gc(),!isdigit(c))if(c=='-')y=-1;x=c^48;
    while(c=gc(),isdigit(c))x=x*10+(c^48);x*=y;
}
char sr[1<<20],z[20];int C=-1,Z;
template<class T>inline void wer(T x){
    ri y=0;if(x<0)y=1,x=-x;
    while(z[++Z]=x%10+'0',x/=10);if(y)z[++Z]='-';
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
/*结束*/
using namespace std;
const int maxn = 1e4 + 10;
const int inf = 0x6ffffff;
struct node {
    int v,w;
    node* next;
    node(int to,int dist,node* n): v(to),w(dist),next(n) {}
}*adj[maxn];//邻接链表存图
struct po {
    int d,u;
    po(int a,int b): d(a),u(b) {}
    int operator < (const po& rhs) const {
        return d>rhs.d;
    }
};
int vis[maxn],d[maxn];

int main() {
    int n,m,s;
    int u,v,w;
    read(n);read(m);read(s);
    for(int i=0;i<m;++i) {
        read(u);read(v);read(w);
        adj[u]=new node(v,w,adj[u]);
    }
    /*主算法*/
    for(int i=1;i<=n;++i) d[i]=inf;
    d[s]=0;
    priority_queue<po> q;//优先队列
    q.push(po(0,s));
    while(!q.empty()) {
        po buf=q.top();q.pop();
        if(vis[buf.u]) continue;
        vis[buf.u]=1;
        for(node* i=adj[buf.u];i!=NULL;i=i->next) {
            if(d[i->v]>d[buf.u]+i->w) {
                d[i->v]=d[buf.u]+i->w;
                q.push(po(d[i->v],i->v));
            }
        }
    }
    /*结束*/
    for(int i=1;i<=n;++i) {
        if(d[i]!=inf) wer(d[i]);
        else wer(2147483647);
    }
    fwrite(sr,1,C+1,stdout);
    return 0;
}
```
~~哇IO优化好像写的比主算法都长诶~~

不管了只要我们过了就好

---

## 作者：MadCreeper (赞：2)

弱鸡花了好久。。

这个是个dijkstra的优先队列优化，用的vector 存储边

之前数组开10000就SE了 开大果然好了。。

还有STL大法好 233






```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<utility>
#include<vector>
#include<queue>
#define MAXN 20000
#define INF 2147483647
using namespace std;
typedef pair<int,int> pii;
priority_queue<pii,vector<pii>,greater<pii> > pq;
struct edge
{
    int to;
    int cost;
};
vector<edge> G[MAXN];//g[i]--i to g[i].to cost cost
int n,m,s;
int dis[MAXN];
void dijk(int s)
{
    for(int i=1;i<=n;i++)
        dis[i]=INF;
    dis[s]=0;
    pq.push(make_pair(0,s));
   // cout<<dis[s]<<endl;
    while(!pq.empty())
    {
        pii u = pq.top();
        pq.pop();
        int x = u.second; // bian hao
        //cout<<x<<endl;
        for(int i=0;i<G[x].size();i++)
        {
            edge e=G[x][i];
            if(dis[e.to]>dis[x]+e.cost)
            {
                dis[e.to]=dis[x]+e.cost;
                pq.push(make_pair(dis[e.to],e.to));
               // cout<<dis[e.to]<<endl;
            }
        }
    }
}
int main()
{
    cin>>n>>m>>s;
    int from,to,cost;
    edge in;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d%d",&from,&to,&cost);
        in.to=to; in.cost=cost;
        G[from].push_back(in);
    }
   // cout<<endl;
    dijk(s);
    for(int i=1;i<=n;i++)
        printf("%d ",dis[i]);
    return 0;
}

```

---

## 作者：alpq010815 (赞：2)

SPFA!!
用二维数组会爆！！！数据太大了，可以用动态数组+结构体。

            
```cpp
#include<cstdio>
#include<vector>
using namespace std;
//int pre[19999];
int v,u;
bool flag[19999];//蓝白点
int du[19990009];//队列
struct turr{
    int to;//邻接点
    int cost;//边权
};
vector <turr> w[10009];
int dis[19999];
int n;
int m;
int main()
{
    scanf("%d%d",&n,&m);
    scanf("%d",&v);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
            turr e1;
            e1.to=y;
            e1.cost=z;
            w[x].push_back(e1);//放入动态数组
    }
    flag[v]=1;
    for(int i=1;i<=n;i++)
      dis[i]=2147483647;
    du[1]=v;dis[v]=0;
    int head=0,tail=1;//初始化
    do
    {
        head++;
        int o=du[head];
        flag[o]=0;
        for(int i=0;i<w[o].size();i++)
        {
            int t=w[o][i].to;
            if(dis[t]>dis[o]+w[o][i].cost)
            {
                dis[t]=dis[o]+w[o][i].cost;
//                pre[t]=o;
                if(!flag[t])
                {
                    flag[t]=1;
                    du[++tail]=t;
                }
            }
        }
    }
    while(head<tail);//spfa算法
    for(int i=1;i<=n;i++)
    printf("%d ",dis[i]);
    return 0;
}
```

---

## 作者：「QQ红包」 (赞：2)

啊™是有向图啊。

2种方法。

具体见注释

SPFA：

```cpp
/*
ID: ylx14271
PROG: spfa
LANG: C++     
*/
#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
using namespace std;
int n,m,p,i;//p:出发点序号 
int xx,yy,zz;
vector<int> f[10001];//存编号 
vector<int> fs[10001];//存长度 
int fl[10001];
int q[500100];
int l,r,s; 
int d[10001];
int flag[10001];
void in(int xxx,int yyy,int zzz)//邻接表 
{
    fl[xxx]++;
    f[xxx].push_back(yyy);
    fs[xxx].push_back(zzz);
    return;
}
int main() 
{
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout); 
    scanf("%d%d%d",&n,&m,&s);
    for (i=1;i<=m;i++)//读边 
    {
        scanf("%d%d%d",&xx,&yy,&zz); 
        in(xx,yy,zz);//插入边 
    }
    l=0;r=1;//点s入队 
    q[1]=s;
    flag[s]=1;
    for (i=1;i<=n;i++)//赋初值 
    {
        d[i]=2000003647;
    }
    d[s]=0;
    while (l!=r)
    {
        l=l%10000+1;//出队。 
        flag[q[l]]=0;//去标记（flag数组标记该点是否在队列中 
        for (i=0;i<fl[q[l]];i++)
        {
            if (d[q[l]]+fs[q[l]][i]<d[f[q[l]][i]]||(d[f[q[l]][i]]==2000003647))//松弛操作 
            {
                if (flag[f[q[l]][i]]==0)//没在队列中 
                {
                    r=r%10000+1;//入队
                    q[r]=f[q[l]][i];
                    flag[f[q[l]][i]]=1;
                }
                d[f[q[l]][i]]=d[q[l]]+fs[q[l]][i];//松弛操作 
            }
        }
    } 
    for (i=1;i<=n;i++)//输出 
    if (d[i]==2000003647) printf("2147483647 "); else 
    printf("%d ",d[i]);
    return 0;
}
```
Dijkstra迪杰斯特拉+堆优化

```cpp
#include<vector>
#include<map>
#include<queue>
#include<algorithm>
#include<set>
#include<iostream>
#include<cstdio>
#include<list>
#include<string>
#include<cmath>
#include<cstring>
#include<stack>
using namespace std;
struct ha//小根堆
{
    int x; 
    int d;//节点编号 
    bool operator < (const ha &a) const 
    {
        return x>a.x;
    }
}; 
struct haha//小根堆
{
    int x; 
    int d;//节点编号 
}; 
ha e;
haha ee;
int d[1000010];
priority_queue <ha> q;
int n,m,s,xx,yy,zz,i;
vector<haha> a[1000000];
int main()
{
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    scanf("%d%d%d",&n,&m,&s);
    for (i=1;i<=m;i++)
    {
        scanf("%d%d%d",&xx,&yy,&zz);
        ee.d=yy;
        ee.x=zz;
        a[xx].push_back(ee);
    }
    for (i=1;i<=n;i++) d[i]=2000003647;
    e.d=s;
    e.x=0; 
    d[s]=0;
    q.push(e);//入队 
    while (!q.empty())//队列非空 
    {
        e=q.top();q.pop();//出队 
        int v=e.d;//取出节点编号 
        int d1=e.x;
        if (d[v]<d1) continue;//说明在这个点再此之后又入队了
        //此次出队的并不是s到这个点的最短路，
        //所以在这次更新前点v所连的点已经更过一次了 
        //所以后面也不会进行松弛操作 
        int len=a[v].size(); 
        for (i=0;i<len;i++)
        {
            haha g=a[v][i];
            if ((d[v]+g.x<d[g.d])||(d[g.d]==-233))//松弛操作 
            {
                d[g.d]=d[v]+g.x;
                e.d=g.d;
                e.x=d[g.d];
                q.push(e);
            }
        }
    }
    for (i=1;i<=n;i++) //输出 
    if (d[i]==2000003647)cout<<2147483647<<" "; else cout<<d[i]<<" ";
    return 0;
}
```

---

## 作者：fengjunjie (赞：2)

练练堆优dij

pas 福利（没有STL真伤感）







```cpp
program dij;
type
    rec=record
          n,t,d:longint;
        end;
    rec2=record
          num,data:longint;
         end;
var n,m,s,cnt:longint;
    w:array[0..500000] of rec;
    h,d,pl:array[0..10000] of longint;
    v:array[0..10000] of boolean;
    small:array[0..100000] of rec2;
procedure init;
var i,tot:longint;
    x,y,z:longint;
begin                                             //读入，模拟邻接表存图
  readln(n,m,s); tot:=0;
  for i:=1 to m do
  begin
    readln(x,y,z);
    inc(tot);
    w[tot].n:=h[x]; h[x]:=tot; w[tot].t:=y; w[tot].d:=z;
  end;
  for i:=1 to n do d[i]:=maxlongint;
  d[s]:=0; cnt:=0;
  fillchar(small,sizeof(small),127);
  small[0].data:=0;
end;
procedure swap(a,b:longint);      //交换位置
var p:rec2; q:longint;
begin
  q:=pl[small[a].num]; pl[small[a].num]:=pl[small[b].num]; pl[small[b].num]:=q;
  p:=small[a]; small[a]:=small[b]; small[b]:=p;
end;
procedure put(x:longint);            //堆的加入操作
var k:longint;
begin
  if pl[x]=0 then                        //判断是否在堆中已经存在（pl数组标记元素在堆中的位置）
  begin
    inc(cnt);
    pl[x]:=cnt;
    small[cnt].num:=x;
    small[cnt].data:=d[x];
    k:=cnt;
  end
  else
  begin
    small[pl[x]].data:=d[x];          //如果已经存在，直接修改
    k:=pl[x];
  end;
  while small[k].data<small[k div 2].data do   //维护堆的性质
  begin
    swap(k,k div 2);
    k:=k div 2;
  end;
end;
function get:longint;                               //堆的取出操作
var k:longint;
begin
  get:=small[1].num;
  pl[small[cnt].num]:=1;                          //维护堆的性质
  small[1]:=small[cnt];
  small[cnt].data:=maxlongint;
  k:=1;  dec(cnt);
  if cnt>0 then
  while (small[k].data>small[k*2].data) or (small[k].data>small[k*2+1].data) do
  begin
    if small[k*2].data<small[k*2+1].data then
    begin
      swap(k,k*2);
      k:=k*2;
    end
    else
    begin
      swap(k,k*2+1);
      k:=(k*2+1);
    end;
  end;
end;
procedure find(x:longint);                       //拓展某一点的所有出边（当然是没走过的）
var k:longint;
begin
  k:=h[x];
  while k>0 do
  begin
    if not v[w[k].t] then
      if w[k].d+d[x]<d[w[k].t] then
      begin
        d[w[k].t]:=w[k].d+d[x];
        put(w[k].t);
      end;
    k:=w[k].n;
  end;
end;
procedure dijkstra(x:longint);                  //dijkstra
var i:longint;
    p,min:longint;
begin
  v[x]:=true;
  find(x);
  for i:=1 to n-1 do
  begin
    if cnt>0 then
     p:=get                                               //这里将循环取得最小值改为在堆中判断最小值
    else
     break;
    v[p]:=true;
    find(p);
  end;
end;
procedure print;
var i:longint;
begin
  for i:=1 to n do
   write(d[i],' ');
end;
begin
  init;
  dijkstra(s);
  print;
end.
```

---

## 作者：WLQ567 (赞：2)








```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
const int INF=0x3f;
const int maxn=500000+100;
int d[maxn];
bool vis[maxn];
vector <int> G[10001];
int n,m,s;
struct Edge{
    int u,v,w;
}edges[maxn];
struct HeapNode{
    int d,u;
    bool operator < (const HeapNode& rhs)const{
        return d>rhs.d;
    } 
};
void dijkstra(int s){
    priority_queue<HeapNode> Q;//d值小的优先出队 
    memset(d,INF,sizeof(d));
    d[s]=0;
    Q.push((HeapNode){0,s});//紫书上的高级用法 
    while(!Q.empty()){
        HeapNode x=Q.top();Q.pop();
        int u=x.u;
        if(vis[u])continue;//防止节点的重复扩展 
        vis[u]=true;
        for(int i=0;i<G[u].size();i++){
            Edge& e=edges[G[u][i]];
            if(d[e.v]>d[u]+e.w){//松弛 
                d[e.v]=d[u]+e.w;//注意：不能将变量名搞混了 
                Q.push((HeapNode){d[e.v],e.v}); //松弛成功后需改变e.v的优先级 
            }
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&edges[i].u,&edges[i].v,&edges[i].w);
        G[edges[i].u].push_back(i);
    }
    dijkstra(s);
    for(int i=1;i<=n;i++){
        printf("%d ",d[i]==0x3f3f3f3f?2147483647:d[i]);//这个地方需要注意了，话说我也不知道为什么0x3f3f3f3f改成INF会wa 
    }        
    return 0;
}
//上网搜了一下：
//0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就
//不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），
//我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，
//现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！
//所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。
//http://blog.csdn.net/u011394362/article/details/39135107
```

---

## 作者：Miss_dijkstra (赞：2)

这题用的Dj来写的但是它是强化版的

~~（对于我们这种蒟蒻来说）~~

但也没有太强（至少模版是过不了的）想这题的正常

版[p4779](https://www.luogu.org/problemnew/show/P4779)

需要用到dj加堆优化~~（所以我们这种蒟蒻来说是过不了的）~~



------------强行拉回主题------------

我用了vector来节省空间来避免RE；

首先我们需要两个数组

1：dis[100];//答案数组

2：vis[100];//判断是否已经用过（改过最小值）

其次结构体也是不可少的



------------
```cpp
struct node
{
	int ed/*终点*/,w/*权值*/;	
};
```

------------

开始主函数


------------
```cpp
for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		struct node now;
		now.ed=y;//y放入结构体的ed里
		now.w=z;//同上
		vt[x].push_back(now);/*这是重点为什么把x作为下标来存因为vt这个vector是存的以x为开头的线又因为这是单向图所以是这样*/
        dj();//进入dj；
        
	}
```
一个正常的输入~~（虽然刚开始的时候更本不会）（现在也差不多）~~

下面上dj的代码
------------
```cpp
void dj()
{
	memset(vis,false,sizeof(vis));//初始化
	memset(dis,INF,sizeof(dis));//初始化INF上定义为了0x3f3f3f3f(一个超大值)
	for(int i=0;i<vt[s].size()/*以s开头的vector的大小*/;i++)
	{
		dis[vt[s][i].ed]=min(dis[vt[s][i].ed],vt[s][i].w);//把于起点相连的点先初始化
	}
	dis[s]=0;//答案为0
	vis[s]=true;//标记置为true
	
	for(int i=1;i<=n;i++)//循环模拟
	{
		int mis=INF,pos=0;//初始化mis用来找最小值 pos用来找下标
		for(int j=1;j<=n;j++)
		{
			if(!vis[j]&&dis[j]<mis)//如果没有被用过且这个点小于mis
			mis=dis[j],pos=j;//更新
		}
		vis[pos]=true;//置为true
		for(int j=0;j<vt[pos].size()/*以pos开头的vector的大小*/;j++)
		{
			if(!vis[vt[pos][j].ed]/*vt[pos][j].ed是指与这个点相连的第j个数*/&&dis[vt[pos][j].ed]/*记答案的值*/>dis[pos]/*本生这个pos点的值*/+vt[pos][j].w/*权值*/)
			dis[vt[pos][j].ed]=dis[pos]+vt[pos][j].w;//更新
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(dis[i]==INF)//如果没有更改值就改为2147483647
		dis[i]=2147483647;
		cout<<dis[i]<<" ";//输出
	}
}
```


最后附上完整代码
------------

```cpp
#include<iostream>
#include<vector>
#include<cstring>
using namespace std;
int n,m,s;
int dis[10201];
bool vis[10201];
struct node
{
	int ed,w;	
};
vector<struct node> vt[10200];
int INF=0x3f3f3f3f;
void dj()
{
	memset(vis,false,sizeof(vis));
	memset(dis,INF,sizeof(dis));
	
	for(int i=0;i<vt[s].size();i++)
	{
		dis[vt[s][i].ed]=min(dis[vt[s][i].ed],vt[s][i].w);
	}
	dis[s]=0;
	vis[s]=true;
	
	for(int i=1;i<=n;i++)
	{
		int mis=INF,pos=0;
		for(int j=1;j<=n;j++)
		{
			if(!vis[j]&&dis[j]<mis)
			mis=dis[j],pos=j;
		}
		vis[pos]=true;
		for(int j=0;j<vt[pos].size();j++)
		{
			if(!vis[vt[pos][j].ed]&&dis[vt[pos][j].ed]>dis[pos]+vt[pos][j].w)
			dis[vt[pos][j].ed]=dis[pos]+vt[pos][j].w;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(dis[i]==INF)
		dis[i]=2147483647;
		cout<<dis[i]<<" ";
	}
}

int main()
{
	cin>>n>>m>>s;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		struct node now;
		now.ed=y;
		now.w=z;
		vt[x].push_back(now);
	}
	dj();
    return 0;
}
```
------------

完事！





---

## 作者：HarryHu (赞：2)

乱写的SPFA，自认为挺好理解的适合新手使用 什么优化都没加（差点ML而且E要是有一个测试点把所有边都连到同一个点上就201了）

```pascal
uses math; //好像并不需要但是习惯性的加这个（就不用写min函数和max函数了还可以乘方和求log）；
var q:array[0..200001]of longint;//队列
    t,f:array[0..10001]of longint;//t:以某顶点为起点的边数 f:最终起点到某点的最短路径值
    vis:array[0..10001]of boolean;//是否在队中
    w,aim:array[0..10001,0..2001]of longint;//w:某边权值 aim:某边终点（p.s.第二个参数为了防坑开到1000本题150就能A）
    n,m,s,x,y,z,i,j,head,tail:longint; 
begin
  readln(n,m,s);
  for i:=1 to m do
    begin
      readln(x,y,z);
      inc(t[x]);//统计以x为起点的边数
      aim[x,t[x]]:=y;//记录以x为起点的最新一条边终点为y，权值为z
      w[x,t[x]]:=z;
    end;//读入完毕
  for i:=1 to n do f[i]:=maxlongint; f[s]:=0;//翻译：初始化所有顶点到起点的距离为题目要求的那个数（maxlongint）并且起点到起点的距离为0（不要忘记！）
  q[1]:=s; head:=0; tail:=1; vis[s]:=true;// 翻译：队列第一个元素为起点；初始化队列； 标记起点已在队列中
  while head<=tail do
    begin
      inc(head);//翻译：队首出队
      vis[q[head]]:=false;//翻译：标记队列头的元素已不在队列中
        for i:=1 to t[q[head]] do//翻译：从1到以队列头为起点的总边数与枚举所有边
          if f[aim[q[head],i]]>f[q[head]]+w[q[head],i] then//翻译：如果起点到队列头的元素的第i条边的终点的距离大于起点到队列头的元素的距离加上队列头的第i条边的权值
            begin
              f[aim[q[head],i]]:=f[q[head]]+w[q[head],i];//更新起点到队列头的元素的第i条边的终点的距离为起点到队列头的元素的距离加上队列头的第i条边的权值
              if not vis[aim[q[head],i]] then//如果不在队列中则入队
                begin
                  inc(tail); q[tail]:=aim[q[head],i];//入队操作
                  vis[aim[q[head],i]]:=true;//标记
                end;
            end;
    end;
  for i:=1 to n do write(f[i],' ');//输出答案
end.
```
本题解有以下好处：

1. 代码注释详细

2. 易理解

3. 想背代码背不下来的同学可以背中文然后考试的时候实现就可以了


---

## 作者：lxyhhhhhh (赞：2)

这个困惑我许久的链表终于有一点改善了，这道题显然不能用Floyd，会炸

那么我们怎么办呢？（把大家当傻瓜的说），那么请见下图：

 ![](https://cdn.luogu.com.cn/upload/pic/8456.png) 

简单来说就是~~：

a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。


b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。


c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。


d.重复步骤b和c直到所有顶点都包含在S中。

实在没有看懂的话可以去看一个很赞的博客： 最短路径—Dijkstra算法和Floyd算法 - as\_ - 博客园（请叫我雷锋）

代码奉上：





        
        
         

    
    
    
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<climits>
#define MAX 2147483647
#define maxn 50001
using namespace std;
struct node
{
    int to,next=0,w;
}edge[maxn];
int head[maxn];
int dis[maxn],n,m,k,t;    //struct存边 ，dis存距离，vis判断遍历条件；                         
void dj(int k)
{
    bool vis[maxn]={false};
    for(int i=1;i<=n;i++)
    {    
        int mi=MAX,t=-1;                    //定义判断条件； 
        for(int j=1;j<=n;j++)                //遍历每个点； 
        {
            if(!vis[j] && dis[j]<mi)        //未遍历过且连接有边 ； 
            {
                mi=dis[j];
                t=j;                        //存边，存最小值 ； 
            } 
        }    
        if(t==-1 || mi==MAX)                //MAX就是无限大，也就理解为没有边； 
        break;
        vis[t]=true;                        //即第j个点已经遍历过了； 
        //接下来是本羸弱最不能理解的地方（链表没学好 ~ —o —~ ）； 
        for(int j=head[t];j;j=edge[j].next)    //从head头找起，一个一个连上找； 
        {
                                            //如果该点没有找过，并且源点到该点的距离更小；
            if(!vis[edge[j].to] && dis[edge[j].to]>(edge[j].w+dis[t]))
            dis[edge[j].to]=edge[j].w+dis[t];
                                            //那么更新；
        }
    }
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++)                    //初始化所有的点都不连接； 
    dis[i]=MAX;                                 
    dis[k]=0;                                //到开始的点的距离为0 ； 
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);            //简化输入，应该都懂吧（如果不懂请见《啊哈，算法》）； 
        edge[i].to=y;
        edge[i].w=z;
        edge[i].next=head[x];
        head[x]=i; 
    }    
    dj(n);//开始查询！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！                                    
    for(int i=1;i<=n;i++)
        printf("%d ",dis[i]);
    //完美输出 
    return 0;
}
```
/\*
input:
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4

output:

0 2 4 3


\*/
如果还不懂，那你很棒棒；

我无能为力了。

看看别的大佬写的代码吧


---

## 作者：interestingLSY (赞：2)

#SPFA算法

##有一些人说SPFA暴死TLE，但我全AC了呀...

#SPFA原理

设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。

#代码

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <queue>
#include <vector>
#include <string.h>
using namespace std;
#define uint unsigned int
#define ll long long
#define ull unsigned ll
#define pii pair<int,int>
#define pb push\_back
#define mp make\_pair
#define INF 2147483647
#define LINF 9999999999
#define ms(l) memset(l,0,sizeof(l))

uint n,m,spoint;
uint dis[10001];
class Edge{
public:
    uint to,cost;
};
vector<Edge> data[10000];

void addedge(uint fr,uint to,uint co){
    Edge e1;
    e1.to = to; e1.cost = co;
    data[fr].pb(e1);
}

void spfa(void){
    queue<uint> q;        bool at[10001];
    q.push(spoint);        ms(at);
    for(uint i = 1;i <= n;i++)
        dis[i] = INF;
    dis[spoint] = 0;    at[spoint] = 1;
    while(!q.empty()){
        uint u;
        u = q.front();
        q.pop();            at[u] = 0;
        for(uint i = 0;i < data[u].size();i++)
            if(dis[u]+data[u][i].cost < dis[data[u][i].to]){
                dis[data[u][i].to] = dis[u]+data[u][i].cost;
                if(!at[data[u][i].to]){
                    at[data[u][i].to] = 1;
                    q.push(data[u][i].to);
                }
            }
    }
}
int main(){
    //freopen("i.txt","r",stdin);
    cin >> n >> m >> spoint;
    for(uint i = 1;i <= m;i++){
        uint f,t,c;
        cin >> f >> t >> c;
        addedge(f,t,c);
    }
    spfa();
    for(uint i = 1;i <= n;i++)
        cout << dis[i] << ' ';
    cout << endl;
    return 0;
}

---

## 作者：Red_w1nE (赞：2)

#用的是SPFA 还有算法核心 （没错 就是怕你们抄==其实是我懒得加了）

#1 算法简介

SPFA(Shortest Path Faster Algorithm)是Bellman-Ford算法的一种队列实现，减少了不必要的冗余计算。也有人说SPFA本来就是Bellman-Ford算法，现在广为流传的Bellman-Ford算法实际上是山寨版。


#2 算法流程

SPFA算法采用了一个队列来进行维护和实现：

（1）初始时，将源点加入队列。

（2）每次从队列中（队首）取出一个元素，并对所有与该队首顶点相邻的点进行松弛（“松驰”的含义与上面Bellman-Ford算法中描述的一样）。若某个相邻的点松弛成功，则将其入队（加入队尾）。

（3）一直对队列进行操作，直到队列为空时算法结束。


简单地说，这个算法就是利用队列优化过的Bellman-Ford算法，是利用了每个点的更新次数不会太多这一特点而发明的算法。

SPFA可以在O(kE)的时间复杂度内，求出源点到其他所有点的最短路径，并且可以处理负边。

SPFA的实现甚至比Dijkstra或者Bellman-Ford还要简单：

设Dist[i]代表源点S到任一顶点 i 的当前最短距离，Fa代表S到 i 的当前最短路径中，i 点之前的一个点的编号。开始时，Dist全部为+∞，只有Dist[S]=0，Fa全部为0。

维护一个队列，里面存放所有需要进行迭代的点。初始时，队列中只有一个点S。此外，再用一个布尔数组，记录每个点当前是否在队列中。

每次迭代时，取出队首的点v，依次枚举从v出发的边v->u：设该边的长度为len，判断Dist[v] + len是否小于Dist[u]，若小于则改进Dist[u]（即松弛成功），将Fa[u]记为v（即v是u的父亲或前趋）。

进一步地，由于S到u的最短距离变小了，进而有可能通过u来改进其他点的最短距离，所以若u不在队列中，就将它放入队尾。

这样一直迭代下去，直到队列变空，也就是S到所有点的最短距离都确定下来时，算法结束。

若一个点的入队次数超过了n(??)，则说明图中有负权的环（回路）{ Why？}。

SPFA 在形式上和宽度优先搜索非常类似，不同的是：

在宽搜过程中，一个点出了队列后就不可能再重新进入队列了；

相反地，在SPFA中，一个点可能在出队之后再次被放入队列。

也就是说，一个点改进过其他的点之后，过了一段时间，可能该点本身又被改进了，于是，它又被再次用来改进其他的点，就这样反复迭代下去。


设一个点用来作为迭代点对其他点进行改进的平均次数为k，有办法证明对于通常的情况，k在2左右。


2.3 SPFA的实现代码

【C++版】


```cpp
void spfa()
{
memset(que, 0, sizeof(que));
head = 0;  tail = 0;
memset(inque ,false, sizeof(inque));
 // inque[i] 用于判断点 i 当前是否在队列中
for (i=1; i<=n; i++)
 dist[i] = MAXINT;  // 初始化
```
 
```cpp
tail++;
 que[tail] = 1;
inque[1] = true;
dist[1] = 0;   // 这里把顶点1作为源点
```
 

```cpp
while (head != tail) {
        head++;
x = que[head];
inque[x] = false;    // 队首元素出队了
     for (i=1; i<=n; i++)    // 找相邻的、可改进的点
           if ( weight[x][i]>0 && dist[x]+weight[x][i]<dist[i]) {
              // 此条件合理否？
              dist[i] = dist[x] + weight[x][i];
              if (! inque[i]) {
                  tail++;
 que[tail] = i;
inque[i] = true;
              }
          }
}
}
```
【算法伪代码】{加入“某一个点入队次数达n-1即停止”}
   
```cpp
procedure SPFA;
begin
   initialize-single-source(G, s);
   initialize-queue(Q);
   enqueue(Q, s);
while not empty(Q) do
 begin
       u := dequeue(Q);
       for each v ∈ adj[u] do
begin
           old := dist[v];
           relax(u, v);
           if ( old <> dist[v] ) and (not v in Q) then
 enqueue(Q,v);
       end;
   end;
end;
```
【或者】
```cpp
procedure spfa;
begin
fillchar(que, sizeof(que), 0);
head := 0;  tail := 0;
fillchar(inque ,sizeof(inque), false);
     // inque[i]用于判断点i当前是否在队列中
for i:=1 to n do
 dist[i] := maxint;  // 初始化
```
 
```cpp
inc(tail);
 que[tail] := 1;
inque[1] := true;
dist[1] := 0;   // 这里把顶点1作为源点
```
 
```cpp
while head <> tail do
begin
        head := (head mod n) + 1;
x := que[head];
inque[x] := false;    // 队首元素出队了
     for i := 1 to n do    // 找相邻的、可改进的点
          if (weight[x,i]>0) and    // 此条件合理否？
(dist[x] + weight[x,i] < dist[i]) then
          begin
              dist[i] := dist[x] + weight[x,i];
              if not(inque[i]) then
              begin
                  tail := (tail mod n)+1;
 que[tail] := i;
inque[i] := true;
              end;
          end;
end;
```

---

## 作者：q2368126021 (赞：1)

###### 这道题是一道模板题，但我还是做得复杂一些，作为一道优化算法的模板
###### 算法：SPFA+链式前向星+SLF和LLL优化
###### SLF优化：如果现在的这一个要加入队列的点，也就是now，与队首元素相判断，如果小于则插入头首，大于则加进头尾，在这里我用了一个双向队列来表示，较为容易
###### LLL优化：中途算一个队列的平均值total，然后头首元素的dis与其相比较。
###### 链式前向星。。。这里就不做详细解释了，上网搜
```cpp
#include<cstdio>
#include<queue>
using namespace std;
int n,m,begin;
struct pel//链式前向星
{
    int to;//这一条边的终点
    int next;//下一个储存位置
    int dis;//这一条边的长度
};
pel a[500001];
int num=0;
int dis[500001];
int h[500001];
deque<int> q;
void add(int x,int y,int z)
{
    num++;
    a[num]=(pel){y,h[x],z};
    h[x]=num;
}
void SPFA()
{
    int i;
    dis[begin]=0;
    q.push_front(begin);
    int total=0,cnt=0;//total是平均值，cnt是队列所拥有的元素总数
    while(!q.empty())
     {
        int past=q.front();
        while(dis[past]*cnt>total){//开头lll，与其判断
        	q.pop_front();
        	q.push_back(past);
        	past=q.front();
		}
        q.pop_front();
        total-=dis[past];//不要忘了减去
        cnt--;
        for(i=h[past];i;i=a[i].next)
         {
         	int now=a[i].to;//其指向路径
         	if(dis[now]>dis[past]+a[i].dis)
         	 {
         	  dis[now]=dis[past]+a[i].dis;
              if(!q.empty()&&dis[now]<dis[q.front()])//SLF优化
         	 	q.push_front(now);
         	 	 else q.push_back(now);
         	 	 total+=dis[now];
         	 	 cnt++;//算平均值
         	 }	
         }
     }
}
int main()
{
    scanf("%d%d%d",&n,&m,&begin);
    int i;
    int x,y,z;
    for(i=1;i<=m;i++)
     {
     	scanf("%d%d%d",&x,&y,&z);
     	add(x,y,z);//构建路径，如果是双向下面再加上一句add(y，x，z)；
     }
     for(i=1;i<=m;i++)//初始化路径
      dis[i]=2147483647;
     SPFA();
     for(i=1;i<=n-1;i++)
     printf("%d ",dis[i]);
     printf("%d",dis[n]);
}

---

## 作者：云雾繁星 (赞：1)

SPFA模板题，手打queue轻松过。

因为STL里的队列比较慢，所以手打。

大体思路是先使用一个队列，在开始的时候从起始点开始判断，如果与当前所连的边能更新权值，那就将其放入队列，不断地进行松弛操作。

SPFA最重要的有几点：

1.用邻接链表存图。

2.队列初始化。

3.队列更新操作。

4.如果边权太多怎么办？普通的SPFA会将时间复杂度提高到O（n^2）.所以我们要用一个vis数组来判断元素是否在队列中。如果在，更新时就不必再放进去。这样会大大降低时间复杂度（虽然SPFA的时间复杂度一直都是玄学orz）

具体代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,s;
struct pan
{
    int to,next,val;
}run[510000];//邻接链表存图，来节省空间 
int head[500100],vis[510000],dis[510000],queue[510000];
int node=0;
void init()
{
    memset(dis,0x3f,sizeof(dis));
    for(int i=1;i<=m;i++)
    {
        head[i]=-1;
    }
}
void add(int u,int v,int w)
{
    run[++node].to=v;
    run[node].val=w;
    run[node].next=head[u];
    head[u]=node;
}
void spfa()
{
    int u,l=0;
    int r=1;
    queue[1]=s;
    vis[s]=1;
    dis[s]=0;//上面几步为SPFA的初始化 
    while(l<r)
    {
        u=queue[++l];//队列的第一个元素出列，然后找该元素相连的其它点 
        vis[u]=0;//出列操作 
        for(int i=head[u];i!=-1;i=run[i].next)
        {
            if(dis[run[i].to]>dis[u]+run[i].val)//如果新的边比原先的短，那就更新权值 
            {
                dis[run[i].to]=dis[u]+run[i].val;
                if(vis[run[i].to]==0)//如果被更新的点原先不在队列里，就把它加进来，这样做的好处是避免了每一个点的重复询问，降低了时间复杂度 
                {
                    vis[run[i].to]=1;
                    queue[++r]=run[i].to;//被更新的点加入队列 
                }
            }
        }
    }
}
int main()
{
    int u,v,w;
    cin>>n>>m>>s;
    init();
    for(int i=1;i<=m;i++)
    {
        cin>>u>>v>>w;
        add(u,v,w);
    }
    spfa();//SPFA主体 
    for(int i=1;i<=n;i++)
    {
        if(i==s) cout<<0<<" ";
        else
        {
            if(dis[i]==0x3f3f3f3f) cout<<2147483647<<" ";//如果没有被连，那就输出2147483647 
            else cout<<dis[i]<<" ";
        }    
    }
return 0;
```

---

## 作者：zcyaya (赞：1)

dalao们都说朴素Dijkstra不行，很多还说Dijkstra即使加优化也不行……

本蒟蒻因为不会写SPFA 只好写Dijkstra 然后提交无数次失败 无数次调试后 堆优迪杰和朴素迪杰都过了。

因为已经有用堆优迪杰的题解了，这里只贴上自己的代码用于对比，（很好奇为什么我的朴素不会TLE 233）

代码：

```cpp
#include<cstdio>
#include<iostream>
#define MAXN 10021
#define INF 0x7fffffff
using namespace std;

struct Edge {
    int succ, value, next;
};

int n, m, s, t, flag;
int h[MAXN], vis[MAXN], dist[MAXN];

Edge graph[1000021];

int main() {
    scanf("%d%d%d", &n, &m, &s);//读入，n为点数，m为边数，s为起点 
    flag = n;//用于记录扩展次数的变量 
    for (int i=1; i<=m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        graph[++t] = {b, c, h[a]};
        h[a] = t;
    } //读图 
    fill(dist+1, dist+n+1, INF);//赋各点到起点的距离为无穷大 
    dist[s] = 0;
    while (flag--) {
        int mini = INF, num = 0;
        for (int i=1; i<=n; i++)
            if (!vis[i]) {
                num = dist[i] < mini ? i : num;
                mini = min(mini, dist[i]);
            }//找到还没被访问的与s距离最小的点num 
        vis[num] = 1;//将num扩展进集合 
        for (int i=h[num]; i; i=graph[i].next)
            dist[graph[i].succ] = min(dist[graph[i].succ], dist[num] + graph[i].value);
    }//对num的所有邻居更新dist 
    for (int i=1; i<=n; i++)
        printf("%d ", dist[i]);//输出 
    puts("");//个人习惯，输出一个换行符，不写一样 
    return 0;
}
```
还有一个值得讨论的地方 我的赋初值放在while内之后AC，但是放在while内会WA三个点，好奇。

※注:flag变量的使用仅仅是为了少一个循环变量，用for效果一样


---

## 作者：王将飞扬Cliffly (赞：1)

这里是一个相对较快的SPFA模板(不到400ms)

总而言之，SPFA的关键还是队列优化，这点写顺了BFS的同学可能会觉得比较相似

邻接表还是比较好用的，当初理解也花了挺久。。



```cpp
#include<bits/stdc++.h>
#define rep(i,j,n) for(int i=j;i<=n;i++) 
using namespace std;
const int N=10010,M=500010;
inline int read(){  //读入优化
    int x; char ch; 
    while(ch=getchar(),ch>'9'||ch<'0') ; x=ch-'0';
    while(ch=getchar(),ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0';     return x;
}
int head[N],dis[N],n,m,s,x,y,w,cnt;  //head[x]为点x连接的第一条边，dis[i]为所求距离，cnt为边总数
struct edge{  //邻接表插边
    int next,to,w;  //next为边e[i]的下一条边 , to为边e[i]的终点
}e[M];
inline void ins(int x, int y, int v) { 
    cnt++; e[cnt]=edge{head[x],y,v} ; head[x]=cnt;
}
queue<int> q;
bool inq[N];  //是否在队中
int main(){
    n=read() ; m=read() ; s=read();
    rep(i,1,m) {
        x=read() ; y=read() ; w=read();
        ins(x,y,w);}
    rep(i,1,n) dis[i]=2147483647;  //别的题这里可能会有问题，最好结合实际选择
    dis[s]=0;    
    q.push(s); dis[s]=0; inq[s]=true;  //源点入队
    while(!q.empty()) {
        int x=q.front() ; q.pop(); inq[x]=false;
        for(int i=head[x]; i; i=e[i].next){   //遍历队首连出的所有边
            int v=e[i].to;
            if( dis[v]>dis[x]+e[i].w) {  //松驰
                dis[v]=dis[x]+e[i].w;
                if(!inq[v]) inq[v]=true,q.push(v); //新点入队
            }
        }
    }
    rep(i,1,n) printf("%d ",dis[i]) ;
    return 0;
}
```

---

## 作者：乒乓高手 (赞：1)

一道很玄学的题，数据大到居然cin和cout都会超时，于是乎只好用了scanf和printf，真的是很坑啊。


回到正题，一道很水的最短路。


看到数据那么大，很自然的就用到了SPFA.


一个裸地SPFA的模板。


其实这是我的第二次提交了，第一次居然没过，很惊讶。


首先开一个队列，起点入队列，然后不断找与他相邻的边，再入队列，当发现通过这个点的进入时，有其他的路线变短了，如果没有在队列里，那么再次入队列，如果入过了就更新它的值。


以上就是SPFA的原理。


具体解释看代码。


PS：其实暴力DFS也是可以骗分的。


当然地泽斯特拉和贝尔曼福德也是可以的，但是可能会超时‘


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>//头文件
#define maxn 100100
#define maxm 5000100
#define inf 2147483647//无脑define
using namespace std;
int n,m,p,i,s,t;
int h[maxm],v[maxm],w[maxm],next[maxm];
int q[maxn*5],d[maxm];
bool f[maxn];
void spfa(int start)//代码开始
{
    int head=0,tail=1;
    q[1]=start;
    f[start]=true;//入队列
    while(head<tail)//操作队列
      {
          head++;
          i=q[head];//出队列
          f[i]=false;//注意一定要更改值，因为可能会重复入队列
          p=h[i];//下一条边
          while(p>0)
            {
                if(d[i]+w[p]<d[v[p]])//松弛操作
                  {
                      d[v[p]]=d[i]+w[p];
                      if(f[v[p]]==false)//如果没用过就再次入队列
                        {
                            tail++;
                            q[tail]=v[p];
                            f[v[p]]=true;
                        }
                  }
                p=next[p];//下一条边
            }
      }
}
void add(int i,int j,int k)//邻接表存图
{
    p++;
    w[p]=k;
    v[p]=j;
    next[p]=h[i];
    h[i]=p;
}
int main()
{
    int x,y,z;
    cin>>n>>m>>s;//输入
    for(int i=1;i<=n;i++)//也可以用memset
      d[i]=inf;
    d[s]=0;//起点附0
    for(int i=1;i<=m;i++)
      {
       scanf("%d%d%d",&x,&y,&z);
       add(x,y,z);
      }
    spfa(s);
    for(int i=1;i<=n;i++)
      {
          printf("%d ",d[i]);//输出
      }
    return 0;//结束
}
```

---

## 作者：JamesHen (赞：1)

#又暴力，又赤裸的***算法

##萌新向

（我已经不知道自己在干什么了）

看看大神们的教程，什么优化，我完全不会啊，所以就先写了个纯粹的单源最短路算法，可能是SPFA（我自创的你信吗）。啪一交过了，开心。

**STL用的较多，那些喜欢纯粹的代码的同学对不住了。**

我用一个类似链表的东西存储图。首先弄个点集（按编号有序），每个点存储着一个边的序列，对于边我记载了他的目标点和长度。

可以用数组实现点集（毕竟下标的方便），用 vector 实现边的序列（防炸，如果开10005的数组的话BOOM！），用 pair 记录边。

那就变成了这样：

```cpp
typedef pair<int, int> mp;
vector<mp> graph[10005];
```
这样做会避免邻接表和邻接矩阵带来的复杂度增加，而且方便。

接下来广搜这张图！

先把 dis 数组（记录到每个点的距离）全部初始化为 INF。

松弛就是：如果我现在从这条边走到你那里比你现在在 dis 数组里的值要短，那么就把你 dis 的值改掉。

从点 S 开始使用所有 S 的边松弛点 S 直接相连的点。这一步做完后，按同样的方法处理由点 S 松弛过的点，直到没有点可以处理。

是不是很简单？！接下来扒出~~超级美的~~代码：

```cpp
#include <cstdio>
#include <queue>
#include <vector>
#include <utility> // for std::pair
using namespace std;

const int INF(2147483647);
typedef pair<int, int> mp;
vector<mp> graph[10005];
int dis[10005], N, M ,S;

int main()
{
    scanf("%d%d%d", &N, &M, &S);
    for (int i(0); i < M; ++i)
    {
        int st, en, len;
        scanf("%d%d%d", &st, &en, &len);
        graph[st].push_back(mp(en, len)); // mp(int, int) 是一个构造函数，他构造了一个临时容器，可以把它推进vector
    }
    for (int i(1); i <= N; ++i) dis[i] = INF;
    dis[S] = 0; // 自己到自己当然是0
    queue<int> nbs; // 队列，广搜有用，应该见怪不怪了吧
    nbs.push(S);
    while (!nbs.empty()) // 简直广搜
    {
        int now(nbs.front());
        for (mp x : graph[now]) // 骚操作，c++11 基于范围的 for 循环，遍历容器十分方便
        {
            if (dis[now] + x.second < dis[x.first]) // 松弛
            {
                dis[x.first] = dis[now] + x.second;
                nbs.push(x.first);
            }
        }
        nbs.pop();
    }
    for (int i(1); i <= N; ++i)
    {
        printf("%d ", dis[i]);
    }
    return 0;
}
```
看我写代码那么铺张浪费，是不是还很短啊：）

~~得意忘形~~


---

## 作者：公元某年的猫 (赞：1)

虽说是dijkstra的模板，但单纯的dijkstra是过不了的，这里需要用的STL的优先队列，说白了就是堆优化的dijkstra，虽说看到楼下已有大神用了这种优化，但并不是说的很明白，所以我来补充下对堆优化的dijkstra算法的说明。


首先是需要一个pair，用来放从源点到指定点的距离和指定点，然后见一个pair类型的优先队列（最小堆），长度短的就在队首，所以接下来有点像用队列优化spfa，当队列不为空时，依次取出没有确定的点，通过该点进行松弛，这就是dijkstra了。大体上就是这个思想。

附上AC代码，也是一个很常用的模板。






```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
const int MAX_E = 500010, MAX_P = 10010, INF = 2147483647;
typedef pair<int, int> pii;
priority_queue<pii, vector<pii>, greater<pii> > q;
struct edge {
    int v, w, next;
} e[MAX_E];
int head[MAX_P], dis[MAX_P], tot, n, m, s;
bool vis[MAX_P];
void add(int a, int b, int c) {
    e[++tot].v = b;
    e[tot].w = c;
    e[tot].next = head[a];
    head[a] = tot;
}
void init() {
    int i;
    for (i = 1; i <= n; i++) {
        head[i] = -1;
        dis[i] = INF;
    }
} 
void  dijkstra(int s) {
    int i;
    dis[s] = 0;
    q.push(make_pair(dis[s], s));
    while (!q.empty()) {
        pii tmp = q.top();
        q.pop();
        int x = tmp.second;
        if(vis[x]) continue;
        else {
            vis[x] = true;
            for(i = head[x]; i + 1; i = e[i].next) {//i+1就是i！=-1，因为head数组初始化为-1
                if(dis[e[i].v] > dis[x] + e[i].w) {
                    dis[e[i].v] = dis[x] + e[i].w;
                    q.push(make_pair(dis[e[i].v], e[i].v));    
                }
            }
        }
    }
}
int main() {
    scanf("%d%d%d", &n, &m, &s);
    int i, f, g, w;
    init();
    for (i = 1; i <= m; i++) {
        scanf("%d%d%d", &f, &g, &w);
        add(f, g, w);
        //add(g, f, w);双向图时用的
    }
    dijkstra(s);
    for (i = 1; i <= n; i++) 
        printf("%d ", dis[i]);
    return 0;
}
```

---

## 作者：RedContritio (赞：1)

作为一个模板题，很显然应该写普适性的模板。

同时包含了分支限界，Dijkstra 以及 Bellman Ford 算法。

另外，Dij朴素40，BmF 不判断松弛完毕的话70，这体现了算法复杂度相等（相似）的情况下，压低常数的重要性。

代码如下，为了提高普适性，大量使用了预处理命令（代码说明见代码注释）

CPP（基本上是 C 的架构）


    
    


    
    

    
    

    
    
    
    
    


```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define min(a,b) (((a)<(b))?(a):(b)) // 定义min
//#define USING_DIJ // 是否编译 Dijkstra 算法
#define USING_BMF // 是否编译 Bellman Ford 算法
//#define USING_BAB // 是否编译 分支限界 算法
#ifdef USING_BAB // 如果使用分支限界
#define tagBRANCH_DEF // 是否编译 分支结构 结构体
#endif
typedef struct tagLINK // 边
{
    int F;
    int G;
    int W;
}LINK;
typedef LINK* PLINK ;
#ifdef tagBRANCH_DEF
typedef struct tagBRANCH // 分支
{
    int dis;
    int s;
}BRANCH;
typedef BRANCH* PBRANCH;
#endif
typedef int* PINT ;
typedef bool* PBOOL ;
#ifdef USING_DIJ
PINT Dijkstra(const int N,const int M,const int Start,PLINK links); // 40 
// 用法是 创建一个 int型的指针 ， 令其等于 Dijkstra(const int N,const int M,const int Start,PLINK links) 
// 参数分别为 N ： 点的数量 ， M：边的数量，Start：开始节点，links：所有边构成的数组
#endif
#ifdef USING_BMF
PINT BellmanFord(const int N,const int M,const int Start,PLINK links); // 70 
// 用法 同Dij ， 只是函数名不同
#endif
#ifdef USING_BAB
PINT Branch_and_Bound(const int N,const int M,const int Start,PLINK links); // 40 
// 用法 同Dij ， 只是函数名不同
void BAB_EnQuene( PBRANCH& quene , BRANCH state , int& begin , int& end , int& size );//BAB辅助函数
BRANCH BAB_DeQuene( PBRANCH quene , int& begin , int& end  , int& size );// BAB辅助函数
#endif
int link_cmp(const void* A,const void* B){PLINK a=(PLINK)A,b=(PLINK)B;return a->W - b->W;} // 边权升序排序
int main()
{
    int N,M,S;
    scanf("%d%d%d",&N,&M,&S);
    S -- ; // 将 S 从 1~N 重置为 0 ~ N-1
    PLINK links = (PLINK)calloc(M,sizeof(LINK));
    for(int i=0;i<M;i++)
    {
        scanf("%d%d%d",&links[i].F,&links[i].G,&links[i].W); // 读入边
        links[i].F -- ;// 将 起点 从 1~N 重置为 0 ~ N-1
        links[i].G -- ;// 将 终点 从 1~N 重置为 0 ~ N-1
    }
    qsort(links,M,sizeof(LINK),link_cmp); // 权重升序 
    PINT ans = BellmanFord(N,M,S,links); // 调用BMF 生成答案数组 （如果使用其它算法，请更改调用函数的函数名）
    for(int i=0;i<N;i++)printf("%d%c",ans[i],((i<N-1)?0x20:0x0A)); // 输出结果
    free(ans); // 释放内存
}
#ifdef USING_DIJ
PINT Dijkstra(const int N,const int M,const int Start,PLINK links) // dij 算法
{
    PINT Distance = (PINT)calloc(N,sizeof(int)); // 初始化最短距离数组
    PINT dis = Distance ; // 创建最短距离数组的别名 dis
    for(int i=0;i<N;i++)dis[i] = 0x7FFFFFFF; // 初始化为 INT_MAX
    dis[Start] = 0 ;
    PBOOL vis = (PBOOL)calloc(N,sizeof(bool));
    vis[Start] = true ;
    for( int SizeofS = 1 ; SizeofS < N ; SizeofS ++ ) // 最多N-1次
    {
        int best = 0 , MinL = 0x7FFFFFFF ;  // 最佳选择和最短路长度
        for(int i=0;i<M;i++)
        {
            if( vis[links[i].F] == true && vis[links[i].G] == false )
            {
                if( MinL > links[i].W + dis[links[i].F] )
                {
                    best = links[i].G ;
                    MinL = links[i].W + dis[links[i].F] ;
                }
            }
        }
        if( vis[best] )continue ;
        vis[best] = true ;
        dis[best] = MinL ;
    }
    free(vis);
    return Distance;
}
#endif
#ifdef USING_BMF
PINT BellmanFord(const int N,const int M,const int Start,PLINK links)
{
    // 初始化部分同理
    PINT Distance = (PINT)calloc(N,sizeof(int));
    PINT dis = Distance ;
    for(int i=0;i<N;i++)dis[i] = 0x7FFFFFFF;
    dis[Start] = 0 ;
    for(int i=0;i<N;i++)
    {
        bool changed = false ; // 本轮操作有意义
        for(int j=0;j<M;j++)
        {
            if( dis[links[j].F] < 0x7FFFFFFF && dis[links[j].G] > dis[links[j].F] + links[j].W ) // 若起点被访问且可以有更短的路径
            {
                dis[links[j].G] = dis[links[j].F] + links[j].W; // 更新最短距离
                changed = true ; 
            }
        }
        if( changed == false )break ; //  判断是否行为有意义。不加这句70 ， 加上 AC  。
    }
    return Distance;
}
#endif
#ifdef USING_BAB
PINT Branch_and_Bound(const int N,const int M,const int Start,PLINK links) // 分支限界 （自己好像没有理解其精髓，写的类似于BFS）
{
    // 初始化部分同理
    PINT Distance = (PINT)calloc(N,sizeof(int));
    PINT dis = Distance ;
    for(int i=0;i<N;i++)dis[i] = 0x7FFFFFFF;
    dis[Start] = 0 ;
    PINT chart_width = (PINT)calloc(N,sizeof(int)); // 邻接链表的宽度
    PLINK** chart = (PLINK**)calloc(N,sizeof(PLINK*)); // 邻接链表
    for(int i=0;i<N;i++)chart[i] = (PLINK*)calloc(M,sizeof(PLINK)); // 分配邻接链表空间
    for(int i=0;i<M;i++)
    {
        chart[links[i].F][chart_width[links[i].F]] = links + i ;
        chart_width[links[i].F] ++ ;
    }
    PBRANCH quene = (PBRANCH)calloc( N*N ,sizeof(BRANCH));
    int quene_begin = 0 , quene_end = 0 , quene_size = N*N ;
    for(int i=0;i<chart_width[Start];i++)BAB_EnQuene( quene , (BRANCH){chart[Start][i]->W,chart[Start][i]->G} , quene_begin , quene_end , quene_size );
    while( quene_begin != quene_end ) // 当队列中有元素
    {
        BRANCH state = BAB_DeQuene( quene , quene_begin , quene_end , quene_size ); // 出队
        if( state.dis <  dis[state.s] ) // 如果小于当前最短距离
        {
            dis[state.s] = state.dis ;
            for(int i=0;i<chart_width[state.s];i++)
            {
                if( state.dis + chart[state.s][i]->W < dis[chart[state.s][i]->G] )
                {
                    BRANCH temp = { state.dis + chart[state.s][i]->W , chart[state.s][i]->G };
                    BAB_EnQuene( quene , temp , quene_begin , quene_end  , quene_size );
                }
            }
        }
    }
    for(int i=0;i<N;i++)free(chart[i]); // 释放所有空间
    free(chart);    free(chart_width);
    free(quene);
    return dis ;
}
void BAB_EnQuene( PBRANCH& quene , BRANCH state , int& begin , int& end , int& size ) // 入队
{
    quene[end] = state ;
    end = (end+1) % size ;
    return ;
}
BRANCH BAB_DeQuene( PBRANCH quene , int& begin , int& end  , int& size ) // 出队
{
    BRANCH temp = quene[begin];
    begin = (begin+1)% size ;
    return temp;
}
#endif
```

---

## 作者：司徒冰雨 (赞：1)

###**STL版Dijkstra**

**花了好长时间才AC了，不容易啊TAT**

**这次的题解使用了一些比较好用的模板，初学STL的同学可以拿来练练手：**

1. priority\_queue

2. vector

3. pair(一个奇怪的东西。。。

**算法原理我就不多说了，下面贴代码**

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<utility>
#include<queue>
#include<vector>
#define Heap pair<int,int>
#define Inf 2147483647
using namespace std;
struct data {
    int from,to;
    int w;    
}edge[500005];
vector<int> poin[10005];
int s,n,m;
int v[10005];
int main()
{
    int i,j;
    scanf("%d%d%d",&n,&m,&s);
    for(i=1;i<=m;i++) {
        scanf("%d%d%d",&edge[i].from,&edge[i].to,&edge[i].w);
        poin[edge[i].from].push_back(i);
    }
    //start
    for(i=1;i<=n;i++) v[i]=Inf;
    priority_queue< Heap,vector<Heap>,greater<Heap> > Q;
    v[s]=0;
    Q.push(make_pair(0,s));
    while(!Q.empty()) {
        Heap N=Q.top();
        Q.pop();
        int u=N.second;
        if(v[u]!=N.first) continue;
        for(int i=0;i<poin[u].size();++i) {
            data e=edge[poin[u][i]];
            if(v[e.to]>v[u]+e.w){
                v[e.to]=v[u]+e.w;
                Q.push(make_pair(v[e.to],e.to));
            }
        }
    }
    for(i=1;i<=n;i++) printf("%d ",v[i]);
    return 0;
}
```

---

## 作者：zzozz (赞：1)

分析：


单源最短路，看了看数据N<=10000，M<=500000用bellman——ford会超时，单纯的用dijkstra也要超时，先讲一下dijkstra算法的思想；dijkstra算法包括两个步骤：1找到最短距离已经确定的点。2从这个点出发确定相邻的点的最短距离。在最开始只有s——s的最短路径是确定的，所以先从s开始，那么如果模拟出来，定义d[i]表示从s到i号顶点的最短距离。


代码：


复制代码


 

```cpp
#include<cstdio>
#include<iostream>
#define ll long long 
#define INF 2147483647
using namespace std;
int n,m,s;
ll cost[10010][10010];
ll d[10010]; 
bool used[10010];
void dijkstra(int s){
    fill(d,d+n+1,INF);
    fill(used,used+n+1,false);
    d[s]=0;
    while(1){
        int v=-1;
        for(int u=1;u<=n;u++)
            if(!used[u]&&(v==-1||d[u]<d[v])) v=u;
        if(v==-1) break;
        used[v]=true;
        for(int u=1;u<=n;u++)
            d[u]=min(d[u],d[v]+cost[v][u]);
    }
}
int main(){
    for(int i=0;i<=10001;i++)
        for(int j=0;j<=10001;j++) if(i!=j) cost[i][j]=INF;
    cin>>n>>m>>s;
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        cost[u][v]=w;
    }
    dijkstra(s);
    for(int i=1;i<=n;i++) printf("%lld ",d[i]);
    cout<<endl;
    return 0;
}
```
复制代码
这个程序复杂度是v\*v的很明显对于题目中的数据范围要超时的，想想怎么优化，取出最小值。。。。想到什么了，小顶堆，对，可以用小顶堆维护最短路径，用邻接表来维护边，那么复杂度就变成了ElogV，下面是代码，简单易懂；


优化版


复制代码




```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
#include<algorithm>
#define ll long long 
#define INF 2147483647
using namespace std;
int n,m,s,head[50010],ecnt;
ll d[10010]; 
bool used[10010];
struct edge{
    int to,next,w;
}es[500010];
void addedge(int u,int v,int w){
    es[ecnt].to=v;
    es[ecnt].next=head[u];
    es[ecnt].w=w;
    head[u]=ecnt++;
```
}//邻接表存边。
```cpp
typedef pair<int,int> P;//用于存到达点的最短路径
void dijkstra(int s){
    priority_queue<P,vector<P>,greater<P> > q;//按照P第一个元素从小到大取出的队列
    fill(d,d+n+1,INF);
    fill(used,used+n+1,false);
    d[s]=0;
    q.push(P(0,s));
    while(!q.empty()){
        P p=q.top();q.pop();
        int u=p.second;
        if(used[u]) continue;
        used[u]=true;
        int pp=head[u];
        while(pp!=-1){
            int v=es[pp].to;
            if(!used[v]&&d[v]>d[u]+es[pp].w){
                d[v]=d[u]+es[pp].w;
                q.push(P(d[v],v));
            }
            pp=es[pp].next;
        }
    }
}
int main(){
    memset(head,-1,sizeof(head));
    cin>>n>>m>>s;
    for(int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        addedge(u,v,w);
    }
    dijkstra(s);
    for(int i=1;i<=n;i++) printf("%lld ",d[i]);
    putchar('\n');
    return 0;
}
```
复制代码
总结：没什么总结的，这个是dijkstra算法的模板。

[点我进博客](http://www.cnblogs.com/zzozz/p/6378526.html)


---

## 作者：暮光 (赞：1)

感觉写了一个年度最丑的 SPFA算法

用邻接表存储边，冗余稍大，但感觉还是不错的……吧

第一次提交队列开小了，还挂了三个点-.-












```cpp
#include <iostream>
using namespace std;
const int Infinity = 2147483647;
struct Side{
    int src;
    int des;
    int dist;
    Side *next;
};
int n,m,st;
int dist[11111];    //光棍节，多来几个1
Side* s[51111];     //同上
int queue[111111];
int qs,qt;
int main()
{
    cin >> n >> m >> st;
    int i;
    for (i = 1; i <= n; i++){
        s[i] = new Side;
        s[i]->src = s[i]->des = i;
        s[i]->dist = 0;
        s[i]->next = NULL;
        dist[i] = Infinity;
    }
    dist[st] = 0;
    int src,des,dis;
    Side *tmp;
    for (i = 0; i < m; i++){ //有向边
        cin >> src >> des >> dis;
        tmp = new Side;
        tmp->src = src;
        tmp->des = des;
        tmp->dist = dis;
        //if (s[src]->next != NULL)
            tmp->next = s[src]->next;
        //else
            //tmp->next = NULL;
        s[src]->next = tmp;
    }
    queue[qs] = st;
    Side *side;
    while (qs <= qt){
        src = queue[qs++];
        side = s[src]->next;
        while (side != NULL){
            if (dist[side->des] > dist[src]+side->dist){
                dist[side->des] = dist[src]+side->dist;
                qt++;
                queue[qt] = side->des;
            }
            side = side->next;
        }
    }
    for (i = 1; i <= n; i++)
        cout << dist[i] << " ";
    return 0;
}

```

---

## 作者：The_Dark_Knight (赞：1)

附带此题我用各种方法的总时间：

SPFA：689ms

SPFA双优化：627ms

dijkstra堆优化：617ms

裸dijkstra：2194ms（简直了）

以下我就给出SPFA的双优化以及Dijkstra的堆优化两种方法吧



双优化版SPFA——PASCAL党的福利：众所周知SPFA的时间复杂度并不稳定，所以有两个著名的优化：SLF和LLL


SLF优化：将新加入的结点与队首比较，如果比队首更优则加入队首，否则加入队尾，这样能保证尽可能的把每次松弛变得更有效


LLL优化：队首h出队时，假设全队的距离平均值为aver，如果d[q[h]]>aver则把当前队首放到队尾，直到找到一个<=aver的再进行松弛


据网上某一大神所说，SLF能优化10%-20%，双优化能快几乎50%。


不知为何此题我加上优化后虽然确实快了一些，但是效果并非那么明显，可能是此题的数据不是很残暴吧。但是这两种优化的方法还是值得推荐的




```cpp
const max=2147483647;
var d,f,last:array[0..10000] of longint;
    e,next,w:Array[1..600000] of longint;
    q:array[-10000..5000000] of longint;//注意对于我的代码来说，队列要开到负数，不然会RE，具体原因往下看就知道了
    x,y,z,i,j,k,m,n,s,h,t,p,po,poo,tot,now:longint;aver:double;
begin
    assign(input,'P3371.in');reset(input);
    readln(n,m,s);
    for i:=1 to m do
    begin
        readln(x,y,z);
        e[i]:=y;w[i]:=z;next[i]:=last[x];last[x]:=i;
    end;
    h:=0;t:=1;
    for i:=0 to n do
      d[i]:=max;
    d[s]:=0;f[s]:=1;q[1]:=s;aver:=0;tot:=0;
    while h<t do
    begin
        inc(h);
        while d[q[h]]>aver do//LLL优化的比较操作
        begin
            inc(t);
            q[t]:=q[h];
            inc(h);
        end;
        dec(tot,d[q[h]]);
        if t=h then aver:=tot else aver:=tot/(t-h);//如果h=t那么队中只有一个元素，aver=tot/1
        p:=last[q[h]];
        while p<>0 do
        begin
            po:=e[p];
            if d[q[h]]+w[p]<d[po] then
            begin
                d[po]:=d[q[h]]+w[p];
                if f[po]=0 then
                begin
                    f[po]:=1;
                    if (d[po]<=d[q[h+1]])and(h+1<t) then//SLF优化操作
                    begin
                        poo:=q[h];
                        q[h]:=po;now:=h;
                        dec(h);//一不小心可能h就小于0了
                        q[h]:=poo;
                    end else
                    begin
                        inc(t);
                        q[t]:=po;now:=t;
                    end;
                    inc(tot,d[q[now]]);
                    aver:=tot/(t-h);
                end;
            end;
            p:=next[p];
        end;
        f[q[h]]:=0;
    end;
    for i:=1 to n do
      write(d[i],' ');
end.
```
继续pascal福利：写了一遍堆优化的dijkstra算法，毕竟是模板题就当练练各种方法了吧，下面也有某些神犇的堆优化代码，所以我觉得注释写尽量多一点吧....
我们知道dijkstra算法最重要的一点就是每次查找未染色的点中距离最小的点，每次都要枚举的话显然非常耽误时间，这就是为什么裸的dijkstra算法是O（n^2），数据大一点就完蛋。由于是每次都只求最小值，所以考虑用堆来优化（毕竟pascal没有优先队列这玩意儿）。堆最大的优点在于每次求最小值的时候都是log级别的，就要快很多，所以优化后的dijkstra算法复杂度基本保持在O（nlogn），比起SPFA都要稳定很多

```cpp
const max=2147483647;
type node=record
     data,num:longint;//data存距离数值，num存此结点的编号
     end;
var last,f,d:Array[1..10000] of longint;
    e,next,w:array[1..500000] of longint;
    dui:Array[0..2000000] of node;//堆数组
    i,j,k,m,n,nd,x,y,z,p,t,u,s,po:longint;
procedure down(pos:longint);//堆有著名的上传下放过程，不懂的还是先学一下堆结构吧，也不是特别难
var i:longint;k:node;
begin
    i:=pos;k:=dui[pos];
    if (2*pos<=nd)and(k.data>dui[2*pos].data) then//nd为堆的结点数量
    begin
        i:=2*pos;
        k:=dui[2*pos];
    end;
    if (2*pos+1<=nd)and(k.data>dui[2*pos+1].data) then
    begin
        i:=2*pos+1;
        k:=dui[2*pos+1];
    end;
    if i<>pos then
    begin
        dui[i]:=dui[pos];
        dui[pos]:=k;
        down(i);
    end;
end;
procedure up(pos:longint);
var i:longint;k:node;
begin
    if pos=1 then exit;
    if dui[pos].data<dui[pos div 2].data then
    begin
        k:=dui[pos];
        dui[pos]:=dui[pos div 2];
        dui[pos div 2]:=k;
        up(pos div 2);
    end;
end;
function pop:longint;//弹出堆顶，然后再更新一遍堆
begin
    pop:=dui[1].num;
    dui[1]:=dui[nd];
    dec(nd);
    if nd<=1 then exit;
    down(1);
end;
begin
    assign(input,'P3371.in');reset(input);
    readln(n,m,s);
    for i:=1 to m do
    begin
        readln(x,y,z);
        e[i]:=y;
        next[i]:=last[x];
        last[x]:=i;
        w[i]:=z;
    end;
    for i:=1 to n do
      d[i]:=max;
    d[s]:=0;dui[1].data:=0;dui[1].num:=s;nd:=1;
    for i:=1 to n do
    begin
        u:=pop;
        while (f[u]=1)and(nd>0) do u:=pop;//默默地弹出我们需要的结点
        f[u]:=1;
        p:=last[u];
        while p<>0 do
        begin
            po:=e[p];
            if (d[u]+w[p]<d[po])and(f[po]=0) then
            begin
                d[po]:=d[u]+w[p];
                inc(nd);
                dui[nd].num:=po;dui[nd].data:=d[po];
                up(nd);//松弛后入堆
            end;
            p:=next[p];
        end;
    end;
    for i:=1 to n do
      write(d[i],' ');
end.
```

---

## 作者：Continue (赞：1)


SSSP(单源最短路) Summary

SSSP(单源最短路)的常见算法有两种:Dijkstra,SPFA;

下面给出有/无优化的Dijkstra,SPFA;


Dijkstra(无优化):

实测2164ms,耗时主要原因是查找最近点的时间复杂度过高;

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int INF=2147483647;
const int maxn=10000+10;
const int maxm=500000+10;
int n,m,s;
int fir[maxn],nxt[maxm],to[maxm],val[maxm],cnt;
void add_edge(int u,int v,int w)
{
    nxt[++cnt]=fir[u];fir[u]=cnt;to[cnt]=v;val[cnt]=w;
}
int dis[maxn],vis[maxn];//vis[i]指i点是否被访问过
void Dijkstra(int s)
{
    for(int i=1;i<=n;i++) dis[i]=INF; dis[s]=0;
    for(int i=1;i<=n;i++) {
        int pos,mn=INF;
        for(int j=1;j<=n;j++) if(!vis[j]&&dis[j]<mn) mn=dis[pos=j];//更新点到源点dis
        vis[pos]=1;
        for(int e=fir[pos];e;e=nxt[e]) {
            int v=to[e],w=val[e];
            if(!vis[v]&&mn+w<dis[v]) dis[v]=mn+w;
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for(int u,v,w,i=0;i<m;i++) {
        scanf("%d%d%d",&u,&v,&w);
        add_edge(u,v,w);
    }
    Dijkstra(s);
    for(int i=1;i<=n;i++) printf("%d ",dis[i]);
    return 0;
}
```

Dijkstra(堆优化):

实测516ms;

堆优化是指在寻找最近点时,用堆log时间复杂度取点,用priority\_queue(堆/优先队列)实现;

较朴素算法,利用了堆,能更快取得最近点;

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const int INF=2147483647;
const int maxn=10000+10;
const int maxm=500000+10;
int n,m,s;
int fir[maxn],nxt[maxm],to[maxm],val[maxm],cnt;
void add_edge(int u,int v,int w)
{
    nxt[++cnt]=fir[u];fir[u]=cnt;to[cnt]=v;val[cnt]=w;
}
struct Node {
    int d,id;
    Node(){}
    Node(int d,int id):d(d),id(id){}
    bool operator < (const Node& rhs) const {
        return d>rhs.d;//重载<,方便堆
    }
};
int dis[maxn],vis[maxn];
void Dijkstra(int s)
{
    for(int i=1;i<=n;i++) dis[i]=INF; dis[s]=0;
    priority_queue<Node>Q;
    Q.push(Node(0,s));
    while(!Q.empty()) {
        Node u=Q.top(); Q.pop();
        if(vis[u.id]) continue;//若某个点已经被更新到最优,就不用再次更新其他点
        vis[u.id]=1;
        for(int e=fir[u.id];e;e=nxt[e]) {
            int v=to[e],w=val[e];
            if(u.d+w<dis[v]) {
                dis[v]=u.d+w;
                Q.push(Node(dis[v],v));
            }
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for(int u,v,w,i=0;i<m;i++) {
        scanf("%d%d%d",&u,&v,&w);
        add_edge(u,v,w);
    }
    Dijkstra(s);
    for(int i=1;i<=n;i++) printf("%d ",dis[i]);
    return 0;
}
```
SPFA(无优化):

766ms;
耗时主要原因是可能某个能将更多点尽可能优化的,却放进了队尾;
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const int INF=2147483647;
const int maxn=10000+10;
const int maxm=500000+10;
int n,m,s;
int fir[maxn],nxt[maxm],to[maxm],val[maxm],cnt;
void add_edge(int u,int v,int w)
{
    nxt[++cnt]=fir[u];fir[u]=cnt;to[cnt]=v;val[cnt]=w;
}
int dis[maxn],inq[maxn];
void SPFA(int s)
{
    for(int i=1;i<=n;i++) dis[i]=INF; dis[s]=0;
    queue<int>Q;Q.push(s);
    while(!Q.empty()) {
        int u=Q.front(); Q.pop();
        for(int e=fir[u];e;e=nxt[e]) {
            int v=to[e],w=val[e];
            if(dis[u]+w<dis[v]) {
                dis[v]=dis[u]+w;
                if(!inq[v]) Q.push(v);
            }
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for(int u,v,w,i=0;i<m;i++) {
        scanf("%d%d%d",&u,&v,&w);
        add_edge(u,v,w);
    }
    SPFA(s);
    for(int i=1;i<=n;i++) printf("%d ",dis[i]);
    return 0;
}

```
SPFA(SLF优化):

实测497ms;

SLF优化是指,当前进队的dis值与队首的dis值比较,若<=进队首,否则进队尾,用deque(双向队列)实现;
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const int INF=2147483647;
const int maxn=10000+10;
const int maxm=500000+10;
int n,m,s;
int fir[maxn],nxt[maxm],to[maxm],val[maxm],cnt;
void add_edge(int u,int v,int w)
{
    nxt[++cnt]=fir[u];fir[u]=cnt;to[cnt]=v;val[cnt]=w;
}
int dis[maxn],inq[maxn];
void SPFA(int s)
{
    for(int i=1;i<=n;i++) dis[i]=INF; dis[s]=0;
    deque<int>Q;
    Q.push_front(s);
    while(!Q.empty()) {
        int u=Q.front(); Q.pop_front(); inq[u]=0;
        for(int e=fir[u];e;e=nxt[e]) {
            int v=to[e],w=val[e];
            if(dis[u]+w<dis[v]) {
                dis[v]=dis[u]+w;
                if(!inq[v]) {
                    if(Q.empty()||dis[v]<=dis[Q.front()]) Q.push_front(v);
                    else Q.push_back(v);
                    inq[v]=1;
                }
            }
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for(int u,v,w,i=0;i<m;i++) {
        scanf("%d%d%d",&u,&v,&w);
        add_edge(u,v,w);
    }
    SPFA(s);
    for(int i=1;i<=n;i++) printf("%d ",dis[i]);
    return 0;
}
```
总结:

对于此题而言,时间效率:SPFA(ELF优化)>Dijkstra(堆优)>SPFA>Dijkstra;

实际上SPFA的时间复杂度不够稳定,有些时候易被出题人卡,建议使用更稳定的Dijkstra;


---

## 作者：wwyx2001 (赞：1)

C++学者证明了不用STL库的SPFA

但是这个题一定要用邻接表呀，不然过不了的

【羞耻的模板题】数组模拟队列也是可以的！！！

```cpp
#include <cstdio>
#include<iostream> 
#include <cstring>
using namespace std;
int front[100050],que[500050],dis[100050];bool c[100050]; 
int zs=0;
struct hh
{
    int to,next,dis;
}edge[500050];
void cs(int from,int to,int dis)
{
    edge[++zs].next=front[from];
    edge[zs].to=to;
    front[from]=zs;
    edge[zs].dis=dis;
}
int main()
{
    int i,j,n,p,cc;
    scanf("%d%d%d",&n,&p,&cc);
    for (i=1;i<=p;i++)
      {
          int x,y,diss;
          scanf("%d%d%d",&x,&y,&diss);
          cs(x,y,diss);
      }
    int minn=2139062143;
    int mi=0;
    memset(c,0,sizeof(c));
    memset(que,0,sizeof(que));
    memset(dis,0x7f,sizeof(dis));
    int head=0,tail=1;
    que[1]=cc;c[cc]=true;dis[cc]=0;
    do{
        head++;
        int x=que[head];
        c[x]=false;//千万不要忘了去标记。 
        for (i=front[x];i!=0;i=edge[i].next)
          if (edge[i].dis+dis[x]<dis[edge[i].to])
          {
              dis[edge[i].to]=edge[i].dis+dis[x];
             if (!c[edge[i].to])
              {
                  tail++;
                  que[tail]=edge[i].to;
                  c[edge[i].to]=true;
            } 
         }
        }while (head<tail);
    for (i=1;i<=n;i++)
      if (dis[i]==2139062143) printf("2147483647 ");
      else printf("%d ",dis[i]);
}
```

---

## 作者：远航之曲 (赞：1)

最短路有两种比较快速的思路，一是堆优化dij，一是spfa

1、堆优化dij

效率 O（v\*lgn）

流程
假设存在G=<V,E>，源顶点为V0，U={V0},dist[i]记录V0到i的最短距离，path[i]记录从V0到i路径上的i前面的一个顶点。

1.从V-U中选择使dist[i]值最小的顶点i，将i加入到U中；

2.更新与i直接相邻顶点的dist值。(dist[j]=min{dist[j],dist[i]+matrix[i][j]})

3.直到U=V，停止。

dij可以用堆优化。就是当把点放入最短路径集合的时候，把边压入一个小根堆，更新的时候直接弹出来。。。


代码如下



```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define MAXN 10010
using namespace std;
typedef pair<int,int>Pair;
struct node
{
    int u,w,v,next;
}e[500010];
int dis[MAXN],st[MAXN];
bool flag[MAXN];
int tot,start,n,m,x,y,z;
void add(int x,int y,int z)
{
    e[++tot].u=x;
    e[tot].v=y;
    e[tot].w=z;
    e[tot].next=st[x];
    st[x]=tot;
}
int dijsktra(int start)
{
    memset(dis,127,sizeof dis);
    memset(flag,0,sizeof flag);
    dis[start]=0;
    priority_queue< Pair,vector<Pair>,greater<Pair> >que;
    que.push(make_pair(dis[start],start));
    while (!que.empty())
    {
        Pair now=que.top();
        que.pop();
        if (flag[now.second]) continue;
        flag[now.second]=1;
        for (int i=st[now.second];i;i=e[i].next)
            if (dis[now.second]+e[i].w<dis[e[i].v])
            {
                dis[e[i].v]=dis[now.second]+e[i].w;
                if (!flag[e[i].v]) que.push(make_pair(dis[e[i].v],e[i].v));
            }
    }
    for (int i=1;i<=n;i++)
    {
        if (dis[i]==2139062143)
            dis[i]=2147483647;
        printf("%d ",dis[i]);
    }
}
main()
{
    scanf("%d%d%d",&n,&m,&start);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        //add(y,x,z);//有向图 
    }
    dijsktra(start);
}
```
2.spfa算法
流程
初始化： d数组全部赋值为INF（无穷大）；p数组全部赋值为s（即源点），或者赋值为-1，表示还没有知道前驱

然后d[s]=0;  表示源点不用求最短路径，或者说最短路就是0。将源点入队；

（另外记住在整个算法中有顶点入队了要记得标记vis数组，有顶点出队了记得消除那个标记）

队列+松弛操作

读取队头顶点u，并将队头顶点u出队（记得消除标记）；将与点u相连的所有点v进行松弛操作，如果能更新估计值（即令d[v]变小），那么就更新，另外，如果点v没有在队列中，那么要将点v入队（记得标记），如果已经在队列中了，那么就不用入队

以此循环，直到队空为止就完成了单源最短路的求解


代码

                
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
struct node
{
    int v,l,next;
}e[500010];
int vis[10010],dis[10010],st[10010];
int en,t,c,s,end,start,x,y,z;
int add(int x,int y,int z)
{
    en++;
    int i=en;
    e[i].l=y;
    e[i].v=z;
    e[i].next=st[x];
    st[x]=i;
}
main()
{
    memset(dis,127,sizeof dis);
    //memset(st,0,sizeof st);
    scanf("%d%d%d",&t,&c,&s);
    for (int i=1;i<=c;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        //add(y,x,z);
    }
    start=s;
    vis[start]=1;
    dis[start]=0;
    queue<int>que;
    que.push(start);
    while (!que.empty())
    {
        int now=que.front();
        que.pop();
        int t=st[now];
        vis[now]=0;
        while (t!=0)
        {
            if (dis[e[t].l]>dis[now]+e[t].v)
            {
                dis[e[t].l]=dis[now]+e[t].v;
                if (vis[e[t].l]==0)
                {
                    vis[e[t].l]=1;
                    que.push(e[t].l);
                }
            }
            t=e[t].next;
        }
    }
    for (int i=1;i<=t;i++)
    {
        if (dis[i]==2139062143)
            dis[i]=2147483647;
        printf("%d ",dis[i]);
    }
}
```

---

## 作者：iceselen (赞：1)

阅读本文您需要了解：

1. 链式前向星建图
2. 图的BFS遍历
3. stl优先队列的使用

可参考：
[图论—建图与遍历](https://www.luogu.org/blog/iceselen/graph-build)

# 图论算法 - 最短路

## Dijkstra

### 简单介绍

Dijkstra（迪杰斯特拉）可以解决单源点到其他顶点的最短路径问题。在不带负权的图中，这是已知的最快算法。

- 时间复杂度：O（n^2，使用堆优化可达到O（nlogn)

- 使用要求：图中不存在负边权。

### 原理

Dijkstra算法采用的是一种贪心的策略.

声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合T。

初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。

若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时就完成了一个顶点。

接着，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短。

如果是，那么就替换这些顶点在dis中的值。

然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。

用伪代码描述就是:

``` cpp
//G为图；数组d为源点到达各点的最短路径长度，s为起点
Dijkstra(G, d[], s)
{
     初始化;
     for(循环n次)
     {
          u = 使d[u]最小的还未被访问的顶点的标号;
          记u已被访问;
          for(从u出发能到达的所有顶点v)
          {
               if(v未被访问 && 以u为中介点使s到顶点v的最短距离d[v]更优)
               {
                    优化d[v];
               }
          }
     }
}
```

### 代码

Dijksatra算法可以使用堆优化，传说中的优先队列内部就是用根实现的，这样时间复杂度就近似的变成了O（nlogn)。

优先队列嘛，手写是不可能手写的，也就用用stl这样子。

- 链式前向星建立边 + 优先队列Dijkstra求最短路完整代码

``` cpp
#include <cstdio>
#include <cstring>
#include <queue>

struct Edge{
    int to, nxt;
    int value;
    Edge(int a = 0, int b = 0, int c = 0)
    :to(a),nxt(b),value(c){}
    //初始化结构体
    inline bool operator < (const Edge &tmp) const{
        return tmp.value < value;
    }
    //重载小于符以让优先队列使用
};

const int maxn = 1000;
const int maxm = 1000;
const int INF = 0x3f3f3f3f;

struct Edge edge[maxm];
struct Edge nowedge;
struct Edge nextedge;

int head[maxm];
int dis[maxn];
bool vis[maxm];
int n = 0, m = 0, cnt = 1;

std::priority_queue<Edge> que;

void init();
void add(int u, int v, int w);
void dijkstra(int startnode);

int main()
{
    init();
    scanf("%d",&n);
    scanf("%d",&m);
    for(register int i = 0; i < m; ++ i){
        int u = 0, v = 0, w = 0;
        scanf("%d%d%d",&u,&v,&w);
        add(u, v, w);
        add(v, u, w);
    }

    dijkstra(1);
    return 0;
}

void init()
{
    memset(head, -1, sizeof(head));
    memset(dis, INF, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    return;
}

void add(int u, int v, int w)
{
    edge[cnt].to = v;
    edge[cnt].value = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
    ++ cnt;
    return;
}

void dijkstra(int x)
{
    dis[x] = 0;//把起点的初始值设定为0;
    nowedge.to = x;
    que.push(nowedge);//把第一条边压入队列;

    while(! que.empty()){
        nowedge = que.top();
        que.pop();

        if(vis[nowedge.to]){
            continue;
            //如果当前边的下一条边已经走过，跳过进入下一轮
        }

        vis[nowedge.to] = 1;//把这条边标记为走过

        for(int i = head[nowedge.to]; ~ i; i = edge[i].nxt){

            int u = edge[i].to;

            if(! vis[u] && dis[u] > dis[nowedge.to] + edge[i].value){
                dis[u] = dis[nowedge.to] + edge[i].value;
                //比较当前遍历的路径和储存的路径，如果当前路径短，就更新。
                nextedge.to = u;
                nextedge.value = dis[u];
                que.push(nextedge);
                //把更新后的路径压入队列
            }
        }
    }
    printf("%d\n",dis[n]);
    //输出从1到n的最短路
    return;
}
```

### 参考题目

luogu P3371 AC代码

``` cpp
#include <cstdio>
#include <cstring>
#include <queue>

inline int read()
{
    int a = 0;
    char x = getchar();
    bool f = 0;
    while((x < '0' || x > '9') && x != '-'){
        x = getchar();
    }
    if(x == '-'){
        f = 1,x = getchar();
    }
    while(x >= '0' && x <= '9'){
        a = a * 10 + x -'0';
        x = getchar();
    }
    return f ? -a : a;
}

struct EDGE{
    int star,to,nxt;
    int value;
};

struct NODE{
    int w,nownum;
    inline bool operator < (const NODE &tmp)const{
        return w > tmp.w;
    }
};

const int maxn = 10200;
const int maxm = 500200;
const int INF = 2147483647;

struct EDGE edge[maxm];
int head[maxn], dis[maxn];
bool vis[maxn];
int n = 0, m = 0, cnt = 0;
int thestart = 0;

std::priority_queue<NODE> que;
struct NODE nownode;
struct NODE nextnode;
void init();
void add(int u, int v, int w);
void dijkstra(int thestart);

int main()
{
    n = read(); m = read();
    thestart = read();
    init();

    for(register int i = 1; i <= m; ++ i){
        int u = read(); int v = read();
        int w = read();
        add(u, v, w);
    }

    dijkstra(thestart);

    for(int i = 1; i <= n; ++ i){
        printf("%d ",dis[i]);
    }

    return 0;
}

inline void init()
{
    memset(head, -1, sizeof(head));
    memset(vis, 0, sizeof(vis));
    for(register int i = 1; i <= n; ++ i){
        dis[i] = INF;
    }
    return;
}

inline void add(int u, int v, int w)
{
    edge[++ cnt].star = u;
    edge[cnt].to = v;
    edge[cnt].value = w;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
    return;
}

void dijkstra(int thestart)
{
    dis[thestart] = 0;
    que.push((NODE){0 , thestart});

    while(! que.empty()){
        nownode = que.top();
        que.pop();
        int topedge = nownode.nownum;
        if(vis[topedge]) continue;
        vis[topedge] = 1;
        for(register int i = head[topedge]; ~ i; i = edge[i].nxt){
            int nextedge = edge[i].to;
            if(dis[nextedge] > dis[topedge] + edge[i].value){
                dis[nextedge] = dis[topedge] + edge[i].value;
                nextnode.w = dis[nextedge];
                nextnode.nownum = nextedge;
                que.push(nextnode);
            }
        }
    }

    return;
}
```

---

## 作者：高手寂寞 (赞：1)

pascal的题解不是很多 贡献一个 注意 更新距离是不用理会节点是否在队列里面 是否入队是要判断是否在队列里面 。。不然只有十分

```cpp
program spfa;
 type s1=record
  go,next,w:longint;
  end;
 var
  head:array[1..10000] of longint; //head:=-1
  edge:array[1..500000] of s1;
  dis:array[1..10000] of longint;
  dl:array[1..1000000] of longint;
  ju:array[1..10000] of boolean;
  n,m,s,cnt,fi,gi,wi,loop:longint;
 procedure add(f,t,we:longint);
  begin
   edge[cnt].go:=t;             //cnt:=1
   edge[cnt].w:=we;
   edge[cnt].next:=head[f];
   head[f]:=cnt;
   inc(cnt);
  end;
 procedure spfa(h:longint);
  var
   f,t,loop,visit,cur:longint;
  begin
   f:=1;
   t:=1;
   ju[h]:=true;
   dl[1]:=h;
   dis[h]:=0;
   while f<=t do
    begin
     visit:=head[dl[f]];
     while visit<>-1 do
      begin
       cur:=edge[visit].go;
     ** ### if  ((dis[dl[f]]+edge[visit].w)<dis[cur]) then** 注意此处 不用 ju数组判断
        begin
         dis[cur]:=dis[dl[f]]+edge[visit].w;
        ### if not ju[cur] then 这里要 
         begin
           inc(t);
         dl[t]:=cur;
         ju[cur]:=true;
         end;
        end;
       visit:=edge[visit].next;
      end;
     ju[dl[f]]:=false;
     inc(f);
    end;
  end;
 begin
  readln(n,m,s);
  fillchar(ju,sizeof(ju),false);
  for loop:=1 to n do
   head[loop]:=-1;
  for loop:=1 to n do
   dis[loop]:=2147483647;
   cnt:=1;
  for loop:=1 to m do
   begin
    read(fi,gi,wi);
    add(fi,gi,wi);
   end;
  spfa(s);
  for loop:=1 to n do
   write(dis[loop],' ');
end.
```

---

## 作者：happyZYM (赞：0)

我这篇题解主要是对SPFA采用SLF和LLL贪心优化，具体解释详见代码：[原文](http://www.cnblogs.com/vongang/archive/2012/03/05/2380127.html)
```cpp
#include<cstdio>
using namespace std;
typedef long long ll;
const int maxn=10005;
const int maxm=500005;
const ll oo=2147483647;
struct char_reader
{
	FILE* f;
	char *buf,*p1,*p2;
	int size;
	char_reader(FILE* fin,int bufsize=65536)
	{
		f=fin;
		size=bufsize;
		p1=p2=0;
		buf=new char[bufsize];
	}
	inline int operator()()
	{
		return p1==p2&&(p2=(p1=buf)+fread(buf,1,size,f),p1==p2)?EOF:*p1++;
	}
};
struct char_writer
{
	FILE* f;
	char *buf,*p,*end;
	char_writer(FILE* fout,int bufsize=65536)
	{
		f=fout;
		buf=new char[bufsize];
		p=buf;
		end=buf+bufsize;
	}
	~char_writer()
	{
		fwrite(buf,p-buf,1,f);
	}
	inline char operator()(char ch)
	{
		return end==p&&(fwrite(buf,end-buf,1,f),p=buf),*p++=ch;
	}
};
char_reader gch(stdin);
char_writer wch(stdout);
inline void read(int &x)
{
	bool f=true;int ch;
	x=0;
	while(ch=gch(),!(ch=='-'||ch>='0'&&ch<='9'));
	if(ch=='-') f=false,ch=gch();
	x=ch-'0';
	while(ch=gch(),ch>='0'&&ch<='9') x=x*10+ch-'0';
	if(!f) x=-x;
}
inline int write(ll x)
{
	if(x==0) return wch('0');
	if(x<0) wch('-'),x=-x;
	static char buf[20],top;
	top=0;
	while(x>0) buf[top++]=x%10+'0',x/=10;
	while(top>0) wch(buf[--top]);
}//快读
struct Edge
{
	int to;
	ll dist;
	Edge *next;
};
ll d[maxn];
bool vis[maxn];
Edge *e[maxn],mem[maxm],*ecnt=mem;
int n,m,s;
inline void AddEdge(int from,int to,ll dist)
{//链式向前星
	ecnt->to=to; ecnt->dist=dist; ecnt->next=e[from];
	e[from]=ecnt++;
}
class deque
{//双端队列，用于实现SLF和LLL贪心优化（STL有点儿慢）
	private:
		int Size;
		int Q[maxn];
		int head,tail;
	public:
		inline int size() { return Size; }
		inline int front() { return Q[head]; }
		inline void pop_front()
		{
			Size--;
			head=(head+1)%maxn;
		}
		inline void push_front(int v)
		{
			Size++;
			head=(head-1+maxn)%maxn;
			Q[head]=v;
		}
		inline void push_back(int v)
		{
			Size++;
			Q[tail]=v;
			tail=(tail+1)%maxn;
		}
	deque() { Size=head=tail=0; }
};
int main()
{
#ifdef local
	freopen("pro.in","r",stdin);
#endif
//	scanf("%d%d%d",&n,&m,&s);
	read(n);read(m);read(s);
	for(int i=1;i<=n;i++) d[i]=oo;
	d[s]=0;
	int f,t,dist;
	ll sum=0;
	for(int i=0;i<m;i++)
	{
//		scanf("%d%d%lld",&f,&t,&dist);
		read(f);read(t);read(dist);
		AddEdge(f,t,dist);
	}
	deque Q;
	Q.push_back(s);
	vis[s]=true;
	while(Q.size())
	{
		int u;
		while(true)
		{
			u=Q.front();Q.pop_front();
			if(d[u]*Q.size()<=sum) break;
			Q.push_back(u);
		}
/*
LLL：Large Label Last 策略，设队首元素为i，队列中所有dist值的平均值为x，
若dist(i)>x则将i插入到队尾，查找下一元素，直到找到某一i使得dist(i)<=x，则将i出对进行松弛操作。
*/
		vis[u]=false;
		sum-=d[u];
		for(Edge *it=e[u];it;it=it->next)
			if(d[it->to]>d[u]+it->dist)
			{
				if(!vis[it->to])
				{
					d[it->to]=d[u]+it->dist;
					if(Q.size()>0&&d[Q.front()]>d[it->to]) Q.push_front(it->to);
					else Q.push_back(it->to);
//SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j)<dist(i)，则将j插入队首，否则插入队尾。
					vis[it->to]=true;
					sum+=d[it->to];
				}
				else
				{
					sum-=d[it->to];
					d[it->to]=d[u]+it->dist;
					sum+=d[it->to];
				}
			}
	}
	for(int i=1;i<=n;i++)
		write(d[i]),wch(' ');
	wch('\n');
	return 0;
}
```

---

## 作者：MashPlant (赞：0)

Dijkstra算法复杂度为O(ElgV)

<del>众所周知</del>Dijkstra算法可以用斐波那契堆进行优化，复杂度变成O(E+VlgV)

<del>当然了如此高大上的算法常数一定很大啦</del>

不开O2 288ms，开O2 380ms 没指望比普通Dijkstra快，但是优化后变慢了是smg???????

一定是我的算法写的太好了，编译器根本没法优化，不接受反驳


我的程序是从我写的抽象的数据结构里面扒出来的，所以全都是模板，看起来可能比较费劲，不过差不多是那个意思啦


好了说正经的，斐波那契堆是一组树的集合，每组树都满足小根堆的性质

树间用循环链表组织，节点的孩子也用循环链表组织，对应代码

1.Container<Node \*> roots; //Container是FibHeap模板参数的一部分，我会给它传list

2.
struct Node

{
private:

```cpp
    K key;
    Node *p = nullptr;
    typename Container<Node *>::iterator self; //为了快速删除节点，每个节点保存自己在链表中的迭代器
    Container<Node*> childs;
    bool marked = false; //FibHeap算法的一部分
    explicit Node(const K & key) :key(key) {}
```
public:

```cpp
    friend FibHeap;
    int degree()const { return childs.size(); } //返回「孩子节点的数目」(称为度数)
    const K& getKey() const { return key; }
};
```
保存一个min指针，每次插节点直接往根链表插，并且比较一下min和新节点，复杂度O(1)

然后是最重要的两个操作：弹出最小元素和节点减值，O(1)的合并也很炫但是这里没用到，就不讲了

1.弹出最小元素 均摊O(lgn)

```cpp
void pop()
{
    for (auto it : min->childs)
        it->p = nullptr;
    roots.splice(roots.end(), min->childs);
    roots.erase(min->self);
    popFix();
}
```
总而言之，把min指针的孩子全部加入根链表，从根链表删除min，然后调用popFix()

```cpp
Node *aux[32];
void popFix()
{
    memset(aux, 0, sizeof(aux));
    for (auto it = roots.begin(); it != roots.end();)
    {
        Node *x = *it;
        ++it; //it与it.next的连接可能被下面的link改变，所以提前++
        while (Node *y = aux[x->degree()])
        {
            aux[x->degree()] = nullptr;
            if (y->key < x->key)
                link(y, x), x = y;
            else
                link(x, y);
        }
        aux[x->degree()] = x;
    }
    //-----------------------------------以上是前半段
    //-----------------------------------以下是后半段
    roots.clear();
    min = nullptr;
    for (int i = 0; i < 32; ++i)
        if (aux[i])
        {
            iterator it = roots.insert(roots.end(), aux[i]);
            aux[i]->self = it;
            if (!min || aux[i]->key < min->key)
                min = aux[i];
        }
}
```
popMin函数比较长，分前后两段讲
前半段的目的是尽可能合并根链表中的节点，使得每个节点的「孩子节点的数目」(称为度数)都不相同，从而减小树的数目

这样做是为了维持均摊O(lgn)的pop，至于为什么就需要一点数学证明，<del>我不会</del>


现在来看它是怎么保证每个节点的度数都不相同的

while (Node \*y = aux[x->degree()]) 既做赋值也做判断，判断这个度数之前有没有填过

没有填过的话跳出循环，把x填到那里去

填过的话，进行合并操作，把原来那个和x合并成一颗树，方法很简单，只需要判断以下谁大，然后把大的变成小的孩子就行了

这是link函数

void link(Node \*x, Node \*y) //把y从根链表中移除并且加入x的孩子


```cpp
{
    y->marked = false; //节点减值中的case2
    y->p = x;
    x->childs.splice(x->childs.end(), roots, y->self);
}
```
后半段很简单，清空根链表，然后把填好的那些新树填回根链表，并且维护一下min
<del>我真的很难相信这么复杂的操作居然是均摊O(lgn)的</del>


2.节点减值:均摊O(1)

mark属性的含义是:该node「已经经历了以下过程中的哪一步」


```cpp
-case1:node变成了根 -> mark = false
//但是实际上前面某一步"把min的孩子"加入根的时候并没有mark，是因为实际上根的mark并没有任何作用。分析一下代码可以看出。
-case2:node变成了别人的孩子 -> mark = false
-case3:node失去了一个孩子 && mark == false -> mark = true
-case4:node失去了一个孩子 && mark == true -> mark = false，并对node执行操作
void decreaseKey(Node *x, const K &key)
{
    x->key = key; //请自觉保证x->key >= key
    Node *y = x->p;
    if (y && x->key < y->key)
    {
        cut(x);
        cascadingCut(y);
    }
    if (x->key < min->key)
        min = x;
}
```
decreaseKey很简单，就是减值，调用两个函数，然后维护一下min

```cpp
void cut(Node *x) //x被切掉并放到根
{
    roots.splice(roots.end(), x->p->childs, x->self);
    x->p = nullptr;
    x->marked = false; //case 1 个人感觉可以去掉这句话，但是算法导论上有
}
```
cut也很简单，把x切掉并放到根并且做适当的标记

```cpp
void cascadingCut(Node *y)
{
    while (y->p) //y不是根
    {
        if (!y->marked) //节点减值在cut(x)之后紧接一步cascadingCut(x->p),所以是case3
        {
            y->marked = true;
            break;
        }
        Node *tmp = y->p; //cut把y->p置为nullptr了，所以记录一下y->p
        cut(y); //case4
        y = tmp;
    }
}
```
所以case4中的"操作"指的是把node切掉并且放到根

这些操作和标记都是为了维持节点减值的均摊O(1)复杂度，我也很希望我能理解这个算法背后的数学原理，但是实在是才疏学浅，没办法完全理解


最后附上完整代码

我之前还写过一个手写链表的版本，只是bug太多怎么调也调不出来，就弃了....

#include <bits/stdc++.h>

template<typename K, template <typename T, typename = std::allocator<T>> class Container>//洛谷的编译器把class改成typename会报错,vs就能编译

class FibHeap

{
public:

    struct Node

    {
private:

```cpp
        K key;
        Node *p = nullptr;
        typename Container<Node *>::iterator self;
        Container<Node*> childs;
        bool marked = false;
        explicit Node(const K & key) :key(key) {}
```
public:
```cpp
        friend FibHeap;
        int degree()const { return childs.size(); }
        const K& getKey() const { return key; }
    };
    typedef typename Container<Node *>::iterator iterator;
    Node* push(const K &key)
    {
        Node *x = new Node(key);
        iterator it = roots.insert(roots.end(), x);
        x->self = it; //不写在一行，因为x既被修改也被取用，未定义行为
        if (!min || key < min->key)
            min = x;
        return x;
    }
    void decreaseKey(Node *x, const K &key)
    {
        x->key = key;
        Node *y = x->p;
        if (y && x->key < y->key)
        {
            cut(x);
            cascadingCut(y);
        }
        if (x->key < min->key)
            min = x;
    }
    void delNode(Node *x)
    {
        decreaseKey(x, 1 << 31);
        pop();
    }
    const K &top() const { return min->getKey(); }
    void pop()
    {
        for (auto it : min->childs)
            it->p = nullptr;
        roots.splice(roots.end(), min->childs);
        roots.erase(min->self);
        popFix();
    }
    void merge(FibHeap &src)
    {
        roots.splice(roots.end(), src.roots);
        if (!min || (src.min&&src.min->key < min->key))
            min = src.min;
        src.min = nullptr;
    }
    bool empty()const { return roots.empty(); }
```
private:







```cpp
    Node *min = nullptr;
    Container<Node *> roots;
    void cut(Node *x) //x被切掉并放到根
    {
        roots.splice(roots.end(), x->p->childs, x->self);
        x->p = nullptr;
        x->marked = false;
    }
    void cascadingCut(Node *y)
    {
        while (y->p)
        {
            if (!y->marked) //节点减值在cut(x)之后紧接一步cascadingCut(x->p)，如果x->没有标记那么这里标记上
            {
                y->marked = true;
                break;
            }
            Node *tmp = y->p;
            cut(y); //cur把y->p置为nullptr
            y = tmp;
        }
    }
    Node *aux[32];
    void popFix()
    {
        memset(aux, 0, sizeof(aux));
        for (auto it = roots.begin(); it != roots.end();)
        {
            Node *x = *it;
            ++it;
            while (Node *y = aux[x->degree()])
            {
                aux[x->degree()] = nullptr;
                if (y->key < x->key)
                    link(y, x), x = y;
                else
                    link(x, y);
            }
            aux[x->degree()] = x;
        }
        roots.clear();
        min = nullptr;
        for (int i = 0; i < 32; ++i)
            if (aux[i])
            {
                iterator it = roots.insert(roots.end(), aux[i]);
                aux[i]->self = it;
                if (!min || aux[i]->key < min->key)
                    min = aux[i];
            }
    }
    void link(Node *x, Node *y) //把y从根链表中移除并且加入x的孩子
    {
        y->marked = false;
        y->p = x;
        x->childs.splice(x->childs.end(), roots, y->self);
    }
};
typedef std::vector<int> vi;
typedef std::pair<int, int> pii;
const int inf = 0x3f3f3f3f;
const int maxn = 1e4 + 10;
int d[maxn];
int vCnt, eCnt;
struct Edge
{
    int to, w;
    Edge(int _to, double _w) : to(_to), w(_w) {}
};
typedef std::vector<Edge> ve;
ve edges[maxn];
typedef typename FibHeap<pii, std::list>::Node Node;
Node *nodes[maxn];
void dijkstra(int s)
{
    memset(d, 0x3f, sizeof(d));
    FibHeap<pii, std::list> fib;
    for (int i = 1; i <= vCnt; ++i) //O(1)*V
        if (i != s)
            nodes[i] = fib.push({ inf ,i });
        else
            nodes[i] = fib.push({ 0,i });
    d[s] = 0;
    while (!fib.empty())
    {
        pii cur = fib.top();
        fib.pop(); //O(lgV)*V
        int v = cur.second, dis = cur.first;
        d[v] = dis;
        ve &e = edges[v];
        for (int i = 0; i < e.size(); ++i)
        {
            int to = e[i].to;
            if (d[v] + e[i].w < d[to]) //O(1)*E
            {
                d[to] = d[v] + e[i].w;
                fib.decreaseKey(nodes[to], { d[to],to });
            }
        }
    }
}
inline int read()
{
    static char ch;
    bool sgn = false;
    while ((ch = getchar()) < '0' || ch > '9')
        if (ch == '-')
            sgn = true;
    int res = ch - 48;
    while ((ch = getchar()) >= '0' && ch <= '9')
        res = res * 10 + ch - 48;
    return sgn ? -res : res;
}
int main()
{
    vCnt = read(), eCnt = read();
    int s = read();
    while (eCnt--)
    {
        int from = read(), to = read(), w = read();
        edges[from].push_back(Edge(to, w));
    }
    dijkstra(s);
    for (int i = 1; i <= vCnt; ++i)
        printf("%d ", d[i] == inf ? 2147483647 : d[i]);
    return 0;
}

```

---

## 作者：EncodeTalker (赞：0)

一道适合在noip之前刷的模板题，有一些细节要注意：

1、本题为无向图（因为看成无向图而爆0的蒟蒻）

2、N<=10000，M<=500000说明只能用邻接表而非邻接矩阵

剩下的就只是标准的spfa了

```cpp
#include<iostream>
#include<string>
#include<string.h>
#include<stdio.h>
#include<algorithm> 
using namespace std;
struct node{
    int a,b,w;
}sq[1000500];
```
int visit[500500],dist[500500],n,m,s,
inde[500500],team[500500];//inde存的是每个点在图中有几条连向其他点的边，好像不能用index做数组名

bool cmp(node x,node y)

{
    return ((x.a<y.a) || ((x.a==y.a) && (x.b<y.b)));

}//对sq排序，方便在spfa时循环




```cpp
void spfa()
{
    int i,j,f=0,r=1;
    memset(visit,0,sizeof(visit));
    for (i=1;i<=n;i++) dist[i]=21474836;
    dist[s]=0;team[r]=s;visit[s]=1;
    while (f<r)
    {
        f++;i=team[f];
        for (j=inde[i-1]+1;j<=inde[i];j++)
        {
            if (dist[i]+sq[j].w<dist[sq[j].b])
            {
              dist[sq[j].b]=dist[i]+sq[j].w;
              if (!visit[sq[j].b])
              {r++;visit[sq[j].b]=1;team[r]=sq[j].b;}
            }
        }
        visit[i]=0;
    }
}
void out()
{
    int i;
    for (i=1;i<=m;i++)
      cout << sq[i].a << ' ' << sq[i].b << ' ' << sq[i].w << endl;
     for (i=1;i<=n;i++)
       cout << inde[i] << ' ';
      cout  << endl; 
}
int main()
{
    int i;
    scanf("%d%d%d",&n,&m,&s);
    memset(inde,0,sizeof(inde)); 
    for (i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        sq[i].a=x;sq[i].b=y;sq[i].w=z;
        inde[x]++;
    }
    sort(sq+1,sq+1+m,cmp);
    for (i=1;i<n;i++) inde[i+1]+=inde[i];//储存前缀和，方便循环
    //out();
    spfa();
    for (i=1;i<=n;i++)
      if (dist[i]==21474836) printf("2147483647 "); 
      else printf("%d ",dist[i]);
    return 0;
}
```

---

## 作者：dormantbs (赞：0)

最短路的算法楼下已经介绍得很清楚了，这里介绍一种Dijkstra的奇异优化。

楼下似乎已经是有了堆优化了吧，而对于Dijkstra，既然要查询当前点中dis的最小值，那么我们何不采用线段树呢？

每取一个点，把它的值改成max\_int表示这个点已经访问过，其他的点的值也可以直接在线段树上修改，每次查询整个线段树的最小值即可。

然后有一些小细节，比如说线段树存下的是点的编号，这样会好写一点吧。


大概复杂度也是mlogn吧，但常数大概会比priority\_queue小一点吧，还跑的挺快的 192ms。


具体看代码吧。


```cpp
#ifndef X_CPP
#define X_CPP
#include<cstdio>
#include<cstring>
#define Files "work"
using namespace std;
#undef read
#undef write
#ifdef Files
#undef redir
#define redir(name) freopen(name".in","r",stdin),freopen(name".out","w",stdout)
extern inline char gc(){
    static char buf[1<<17],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<17,stdin),p1==p2)?EOF:*p1++;
}
#else
#undef gc
#define gc getchar
#endif
template <class T>
extern inline void read(T&n){
    int sign=1;register char ch=gc();
    for(n=0;(ch<'0'||ch>'9')&&ch!='-';ch=gc());
    for(ch=='-'?ch=gc(),sign=-1:0;ch>='0'&&ch<='9';ch=gc()) n=(n<<1)+(n<<3)+ch-'0';
    n*=sign;
}
#ifdef Files
namespace out {
    char buf[1<<17],*p1=buf,*p2=buf+(1<<17);
}
using namespace out;
extern inline void pc(register char ch) {
    *(p1++)=ch,p1==p2?fwrite(buf,1,p1-buf,stdout),p1=buf:0;
}
#else
#undef pc
#define pc putchar
#endif
template <class T>
extern inline void write(T val) {
    if(val<0) pc('-'),val=-val;
    if(!val) pc('0');
    register int num=0;
    char ch[24];
    while(val) ch[++num]=val%10+'0',val/=10;
    while(num) pc(ch[num--]);
}
#ifndef _STL_ALGOBASE_H
#undef max
#undef min
template <class T> inline T max(const T a,const T b){return a>b?a:b;}
template <class T> inline T min(const T a,const T b){return a<b?a:b;}
#endif
template <class T> inline void ckmax(T&a,const T b){a<b?a=b:0;}
template <class T> inline void ckmin(T&a,const T b){a>b?a=b:0;}
const int N=10010,M=500010;
int pre[N],nx[M],to[M],w[M],cnt;
inline void add(int u,int v,int c){
    nx[++cnt]=pre[u],pre[u]=cnt,to[cnt]=v,w[cnt]=c;
}
int tree[N<<2];
int dis[N],n,m,s;
int leaf;
inline void build(){
    leaf=1; memset(dis,0x3f,sizeof(dis));
    while(leaf<=n) leaf=leaf<<1;--leaf;
    for(register int i=1;i<=n;++i) tree[i+leaf]=i;
}
inline int ck(unsigned short i,unsigned short j){
    return dis[i]<dis[j]?i:j;
}
inline void change(int x,int y){
    dis[x]=y,x+=leaf,x=x>>1;
    while(x) tree[x]=ck(tree[x<<1],tree[x<<1|1]),x=x>>1;
}
int ans[N];
inline void dj(){
    build();
    register unsigned short u=s,tot=0;;
    dis[s]=0;
    while(tot<=n){
        ++tot,ans[u]=dis[u];
        const int disu=dis[u];change(u,0x7fffffff);
        for(register int e=pre[u];e;e=nx[e])
            if(dis[to[e]]<0x7fffffff&&dis[to[e]]>disu+w[e]) change(to[e],disu+w[e]);
        u=tree[1];
    }
}
int main(){
#ifdef Files
    if(fopen(Files".in","r")) redir(Files);
#endif
    read(n),read(m),read(s);
    for(register int i=1,u,v,c;i<=m;++i) read(u),read(v),read(c),add(u,v,c);
    dj();
    for(register int i=1;i<=n;++i) write(ans[i]==0x3f3f3f3f?2147483647:ans[i]),pc(' ');
#ifdef Files
    fwrite(buf,1,p1-buf,stdout);
#endif
    return 0;
}
#endif
```

---

## 作者：mydiplomacy (赞：0)

我来写一个C++版指针邻接表的题解.这个题目已经有不少题解,写这个题解的原因是大家大多数介绍的是前向星之类的算法,没有指针邻接表,然而相信写指针邻接表的同学也不少.

思路:Bellman-Ford算法,外加SPFA

先跟大家说一说为什么选BF算法吧.最短路主要有三种算法,Floyd,Dijkstra和Bellman-Ford.

首先看时间复杂度 Floyd是O(N^3) (指N的三次方,下同,不是位运算),Dijkstra是O(MlogN+NlogN),Bellman-Ford是O(NM)

于是Floyd就首先被排除掉了.

空间复杂度 Floyd O(N^2) 剩下两种都是O(M) 没有问题

适用情况,dijkstra和Floyd都比较适合稠密图,因为它们都和顶点密切相关,而Bellman-Ford较适用稀疏图,因为跟边密切相关.

而题中m远小于n^2,所以用Bellman-Ford

代码解释见注释



```cpp
#include <iostream>
using namespace std;
const int maxn=10005,maxm=500005;    //大家务必注意数据范围
const int inf=2147483647;    //因为题目如果不联通就输出2147483647,所以inf设成这个数
struct Node
{
    int v,c;
    Node *next;
}*h[maxn],pool[maxm];    //标准指针邻接表
int n,m,i,j,k;
int dis[maxn],vis[maxn];  //dis[x]指起始点离x的最短距离,vis表示是否在队列里
int q[maxm],head=1,tail=1;    //spfa的队列
int tot=0;
int root;
void addEdge(int u, int v, int c)    //加边
{
    Node *p=&pool[++tot];
    p->v=v;
    p->c=c;
    p->next=h[u];
    h[u]=p;
}
int main()
{
    cin>>n>>m>>root;
    for(int i=1;i<=n;i++) dis[i]=inf;    //初始化
    dis[root]=0;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        addEdge(x,y,z);
    }
    q[tail]=root;
    tail++;
    vis[root]=1;     //起始点入队
    while(head<tail)
    {
        k=q[head];
        for(Node *p=h[k];p;p=p->next)   //遍历k连着的所有点.第二个分号里的p实际上是p!=NULL的简写
        {
            if(dis[p->v]>dis[k]+p->c)    //Bellman-Ford核心语句,松弛
            {
                dis[p->v]=dis[k]+p->c;
                if(vis[p->v]==0)
                {
                    q[tail]=p->v;    //入队
                    tail++;
                    vis[p->v]=1;
                }
            }
        }
        vis[q[head]]=0;    //出队
        head++;
    }
    for(int i=1;i<=n;i++) 
    {
        cout<<dis[i]<<' ';
    }
    return 0; 
}

```

---

## 作者：chenzijie (赞：0)

单源最短路径最快的用贝尔曼福特算法

稍微优化了一下

大概思路就是

先把所有点到一个点的距离定为无穷大

如果有直接到的就附初值

然后一个一个点看能否通过这个点使其他点到终点的路径减短

附上代码：


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct note
{
    int start;
    int end;
    int length;
};
int cmp(const note &a,const note &b)
{
    if(a.start<b.start)
        return 1;
    if(a.start>b.start)
        return 0;
    if(a.end<b.end)
        return 1;
    return 0;
}
struct note que[500005];
int main()
{
    int i,k,n,m,s;
    int con[10005]={0},dis[10005];
    int dui[50010],book[10005];
    int head=1,tail=2;
    scanf("%d %d %d",&n,&m,&s);
    for(i=1;i<=n;i++)
        dis[i]=9999999;    
    dis[s]=0;
    for(i=1;i<=m;i++)
        scanf("%d %d %d",&que[i].start,&que[i].end,&que[i].length);
    sort(que+1,que+1+m,cmp);
    for(i=1;i<=m;i++)
        if(que[i].start!=que[i-1].start)
            con[que[i].start]=i;
    dui[1]=s;
    book[s]=1;
    while(tail>head)
    {
        if(con[dui[head]]==0)
        {
            head++;
            continue;
        }
        i=con[dui[head]];        
        while(que[i].start==dui[head])
        {
            if(dis[que[i].end]>dis[que[i].start]+que[i].length)
            {
                dis[que[i].end]=dis[que[i].start]+que[i].length;
                if(book[que[i].end]==0)
                {
                    dui[tail]=que[i].end;
                    book[dui[tail]]=1;
                    tail++;
                }
            }
            i++;
        }
        book[dui[head]]=0;
        head++;
    }
    for(i=1;i<=n;i++)
        if(dis[i]==9999999)
            printf("2147483647 ");
        else
            printf("%d ",dis[i]);
    return 0;
}

```

---

## 作者：Randyhoads (赞：0)

作为一道单源最短路径的题（模板），应该是需要用到Dijstra或者Bellman—Ford,本蒟蒻用的是Bellman—Ford（没有用队列来优化，但是还是加了优化），用Bellman—Ford的时间复杂度是O（NM），加上优化，也应该不会TLE

```cpp
#include<bits/stdc++.h>
using namespace std;
int u[500001],v[500001],w[500001];//u存储第i条信息中的出发点，同理-----
long long dis[500001];//点 s 到第i点的距离
int n,m,s;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);//这里加了加速cin,cout防止TLE
   cin>>n>>m>>s;
   for(int i=1;i<=n;i++)
       dis[i]=2147483647;把每条边先附成这个值，方便输出
       dis[s]=0;//s到s显然是0
   for(int i=1;i<=m;i++)
   {
       cin>>u[i]>>v[i]>>w[i];//输入第i条信息
   }
   for(int i=1;i<=n-1;i++)//标准Bellman_ford
   {
          int ch=0;//判断在松弛中是否还会更新
          for(int j=1;j<=m;j++)
          {
              if(dis[v[j]]>dis[u[j]]+w[j]) 
              {
                  ch=1;//更新了
                   dis[v[j]]=dis[u[j]]+w[j];因为v[j]是一个点的编号，而n<=10000所以数组不会爆
              }
          }
          if(ch==0) break;//再也更新不了了
   }
   for(int i=1;i<=n;i++) cout<<dis[i]<<" ";
    return 0;
}

```

---

## 作者：风灵无畏YY (赞：0)

###SPFA+SLF优化

本题是个模板题，具体说明就放在代码中了QWQ

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<deque>
using namespace std;
struct arr{
    int nd,nx;
    long long co;
}bot[1000000];
int head[11000];
long long dis[11000];
int f[11000];
int n,m,s,cnt;
deque<int>q;//定义一个双端队列
inline void add(int u,int v,int w){bot[++cnt].nd=v;bot[cnt].co=w;bot[cnt].nx=head[u];head[u]=cnt;}
//这里是用邻接链表存储边
inline void SPFA(int s){
    for(int i=1;i<=n;i++) dis[i]=2147483647;
    dis[s]=0;f[s]=1;
    q.push_back(s);
    while(!q.empty()){
        int now=q.front();
        q.pop_front();
        f[now]=0;
        for(int i=head[now];i;i=bot[i].nx){
            int v=bot[i].nd;
            if(dis[v]>dis[now]+bot[i].co){
                dis[v]=dis[now]+bot[i].co;
                if(!f[v]){
                    f[v]=1;
                    if(q.empty()||dis[v]>dis[q.front()]) q.push_back(v);
                    else q.push_front(v);//SLF优化，不懂的可以去这里[SPFA的优化](http://tzdyy.lofter.com/post/1e3cd119_10c05810)
                }
            }
        }
    }
}
inline int read(){//读入优化
    int x=0,w=1;char ch=0;
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
    return x*w;
}
int main(){
    n=read();m=read();s=read();
    int x,y,w;
    for(int i=1;i<=m;i++) x=read(),y=read(),w=read(),add(x,y,w);
    SPFA(s);
    for(int i=1;i<=n;i++)
     if(dis[i]!=2147483647) printf("%d ",dis[i]);
     else printf("2147483647 ");//输出
}
```

---

## 作者：pcy190 (赞：0)

很多dalao用的SPFA。。这儿贴上用朴素的queue来实现**SPFA**；

stl中的deque,priority等等也能实现，对于自己写队列来说，还要防止队列的空间假死。。

用queue来做，一般不会超时。。。。然而这道题目没有卡SPFA的常数。。。用dji来做的话，朴素的只能拿到40-60吧。

当然也可以单调队列优化。。。。


考虑到这是一个###模板题，直接queue贪心了。。。（貌似也不是贪心。。。）

另外这个不能用邻接矩阵。。。。不然。。。。。空间BOOM。。

用vector或者list都可以，，，，貌似list的push速度比vector在某些范围内跟快。。。。。


那就用queue吧。。。。初始化的时候  dis全部是2147483647，而是dis[s]=0；这个在输出的时候有用。。





```cpp
 // P3371### 【模板】单源最短路径.cpp :
//SPFA
#include<vector>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cmath>
#include<list>
using namespace std;
const int maxn = 500000+10;
struct nodes {
    int u, to, w ;
};//貌似edge来命名比较好，，这个是每条边的结构体。。。其实不需要u。。。（to表示末点，w表示长度）
int dis[10000 + 20];
typedef struct nodes node;//方便后面的定义。。
list<node> v[10000+20];//边集，list和vector都可以。。
int n, m, s;
int inq[10000 + 20]; //用inq来表示点是否在queue中，判重和记忆。。
queue<int> q;//不解释了、、
int main()
{    
    cin >> n >> m >> s;
    for (int i = 0; i < m; i++) {
        int x, y, z;
        cin >> x >> y >> z;
        v[x].push_back({ x,y,z });    //用list来读入边集
    }
    for (int i = 0; i < 10000 + 20; i++) dis[i] = 2147483647; //初始化的时候  dis全部是2147483647，而是dis[s]=0；这个在输出的时候有用。。
    dis[s] = 0;
    q.push(s);
    inq[s] = 1;    //用来判断点是否在队列里面，，类似记忆。。
    while (!q.empty()) {
        int cur = q.front(); q.pop();//取出待松弛的边
        inq[cur] = 0;
        for (list<node>::iterator it = v[cur].begin(); it!=v[cur].end(); it++) {//遍历
            if (dis[cur] + it->w < dis[it->to]) {//这个是松弛操作的核心。。如果过一点的距离+该点长度小于末点的dis值，就更新末点的dis
                dis[it->to] = dis[cur] + it->w;
                if (!inq[it->to]) {//判断是否in queue
                    q.push(it->to);//松弛之后，加入queue，等待接下来的松弛。。
                }
            }
        }
    }
    for (int i = 1; i <= n; i++) {
            cout << dis[i] << " ";
    }
    system("pause");
    return 0;
}
```
其中，cin没有读入优化过，想要AC不超时，，把cin改成scanf就可以了。。。。
理解思想，，才是重点！！！


---

## 作者：汇文客 (赞：0)

C++STL是一个神一般的存在，在SPFA的实现上可以体现这一点：






```cpp
#include<cstdio>
#include<string>
#include<vector>
#include<queue>
using namespace std;
struct node
{
    int id,e;
};
const int maxint=2147483647;
vector<node> g[10001];
int n,m,s,dist[10001];
bool f[10001];
void init()
{
    scanf("%d%d%d",&n,&m,&s);
    int i,a,b,w;
    node p;
    for(i=1;i<=n;i++)
    {
        if(i==s)dist[i]=0;
        else dist[i]=maxint;
        f[i]=true;
    }
    for(i=0;i<m;i++)
    {
        scanf("%d%d%d",&a,&b,&w);
        p.e=w;p.id=b;
        g[a].push_back(p);//vector实现的邻接表，代码相对简短
    }
}
bool relax(int u,int v)
{
    if(dist[g[u][v].id]>dist[u]+g[u][v].e)
    {
        dist[g[u][v].id]=dist[u]+g[u][v].e;
        return true;
    }
    else return false;
}
void SPFA()
{
    queue<int> q;q.push(0);//队列，这个的应用更普遍
    int v,i;
    q.push(s);f[s]=false;
    while(!q.empty())
    {
        q.pop();if(q.empty())break;
        v=q.front();
        f[v]=true;
        for(i=0;i<g[v].size();i++)
        if((relax(v,i))&&(f[g[v][i].id]))
        {
            q.push(g[v][i].id);
            f[g[v][i].id]=false;
        }
    }
    for(i=1;i<=n;i++)printf("%d ",dist[i]);
}
int main()
{
    init();
    SPFA();
    return 0;
}
两个STL应用使代码简短了很多。然而还是那句话，天上不会掉馅饼，程序的效率还是有所下降的。然而，效率不是全部，人们宁可牺牲三倍效率用Java而不用C语言就是最好的例子（from_Charles E Leiserson_），具体取舍要看情况。
```

---

## 作者：悠猫丶月贰 (赞：0)

#Dijkstra+优先队列

存图用的是数组模拟邻接表

由于优先队列不做其它定义的话 top() 返回是队列里最大的数

我们希望越小的数优先级越高，这里定义一个运算符：



bool operator < (const node&pd) const{

        return d>pd.d;

}
##扣上精(rong)美(chang)的代码：


```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#define For(x) for (int i=1;i<=x;i++) 
#define bl(x) for (int h=head[x],o=v[h];h;o=v[h=to[h]])//遍历操作 
using namespace std;
const long long N=500000+10;
const long long INF=~0u>>1;//将32位的0取反后右移一位,即2147483647
long long head[N],to[N],v[N],w[N],num,dis[N],vis[N],n,m,s,ans;
struct node
{
    long long d,pos;
    bool operator < (const node&pd) const{
        return d>pd.d;//小的优先级高 
    }
}tmp;
void get_node(){
    long long U,V,W;
    scanf("%lld%lld%lld",&U,&V,&W);
    to[++num]=head[U],head[U]=num,v[num]=V,w[num]=W;
}
priority_queue <node> q; 
int main(){
    scanf("%lld%lld%lld",&n,&m,&s);
       for(long long i=0;i<m;i++) dis[i]=INF;//初始化 
    For(m) get_node();dis[s]=0;
    q.push((node){0,s});
    while (!q.empty()){
        tmp=q.top();q.pop();
        long long uu=tmp.pos;
        if (vis[uu]) continue;
        bl(tmp.pos){
            if (dis[o]>dis[uu]+w[h]){
                dis[o]=dis[uu]+w[h];
                q.push((node){dis[o],o});
            }
        }
        vis[uu]=1;
    }
    For(n) printf("%lld ",dis[i]);
}
```

---

## 作者：xueyangkai (赞：0)

#SPFA的优化

SPFA存在两种优化方式，一种是SLF(Small Label First)优化，另外一种为LLL(Large Label Last)优化。个人感觉SLF好理解一些；

##SLF具体操作

设队首元素为 i，队列中要加入节点 j，在 dj<=di 时加到队首而不是队尾，否则和普通的 SPFA 一样加到队尾。

##速度

在本身有读入优化的前提下，由677ms优化为406ms

##代码

```cpp
#include <cstdio>
#include <limits.h>
#include <iostream>
#include <algorithm>
using namespace std;
const int maxne = 600001;
const int maxnn = 20001;
const unsigned long long int inf = 6000000000;
int n,e,s,t,cnt;
int last[maxne],q[maxne],check[maxnn];
long long dis[maxnn];
bool is[maxnn],fuhuan;
int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9') {x=x*10+ch-'0'; ch=getchar();} return x*f;
}
struct line {int to,next,v;}l[maxne];
void add(int u,int v,int w) { l[++cnt].to=v; l[cnt].next=last[u]; last[u]=cnt; l[cnt].v=w; }
void spfa(int a)
{
    for(int i=1;i<=n;i++) dis[i]=inf;
    dis[a]=0; is[a]=1; q[0]=a; check[a]++;
    int head=0,tail=1;
    while(head!=tail)
    {
        int now=q[head++];
        if(head==n+1) head=0;
        for(int i=last[now];i;i=l[i].next)
        {
            if( dis[now]+l[i].v<dis[l[i].to] && dis[now]!=inf)
            {
                dis[l[i].to]=dis[now]+l[i].v;
                if(!is[l[i].to])
                {
                    is[l[i].to]=1;
                    if(dis[l[i].to]<dis[q[head]])
                    {
                        head--; if(head==-1) head=n;
                        q[head]=l[i].to;
                        check[l[i].to]++;
                        if(check[l[i].to]==n) { fuhuan=1; return;}
                    }
                    else
                    {
                        q[tail++]=l[i].to;
                        if(check[l[i].to]==n) { fuhuan=1; return;}
                        if(tail==n+1) tail=0;
                    }
                }
            }
        }
        is[now]=0;
    } 
}
int main()
{
    int u,v,w;
    n=read();e=read(); 
    s=read();
    for(int i=1;i<=e;i++)
    {
        u=read();v=read(); w=read();
        add(u,v,w);
    }
    spfa(s);
    for(int i=1;i<=n;i++)
    {
        if(dis[i]==inf) cout<<"2147483647 ";
        else cout<<dis[i]<<" "; 
    }
    return 0;
}
```

---


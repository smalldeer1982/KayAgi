# [TJOI2007] 线段

## 题目描述

在一个 $n \times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。

你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。

更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。

## 说明/提示

我们选择的路线是

```
 (1, 1) (1, 6)
 (2, 6) (2, 3)
 (3, 3) (3, 1)
 (4, 1) (4, 2)
 (5, 2) (5, 6)
 (6, 6) (6, 4) (6, 6)
```
不难计算得到，路程的总长度是 $24$。 

对于 $100\%$ 的数据中，$n \le 2 \times 10^4$，$1 \le L_i \le R_i \le n$。

## 样例 #1

### 输入

```
6
2 6
3 4
1 3
1 2
3 6
4 5```

### 输出

```
24```

# 题解

## 作者：Huami360 (赞：150)

裸DP。感觉楼下的好复杂，我来补充一个易懂的题解。

f[i][0]表示走完第i行且停在第i行的左端点最少用的步数

f[i][1]同理，停在右端点的最少步数。

那么转移就很简单了，走完当前行且停到左端点，那么一定是从右端点过来的，那么从上一行左端点转移的话就是

f[i][0]=abs(上一行左端点的坐标-本行右端点的坐标+本行线段长度)

从上一行右端点转移同理。
不需要什么判断。边界f[1][0]=r[1]+r[1]-l[1]-1,f[1][1]=r[1]-1，然后直接搞就行了，时间复杂度O(n)。
```cpp
#include <iostream>
#include <cstdio>
#define rep(i,m,n) for(int i=m;i<=n;++i)
using namespace std;
inline int read(){
    int s = 0, w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
    while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0',ch = getchar();
    return s * w;
}
const int MAXN = 20010;
int n;
int l[MAXN], r[MAXN], f[MAXN][2];
int main(){
    n = read();
    rep(i, 1, n) l[i] = read(), r[i] = read();
    f[1][0] = r[1] + r[1] - l[1] - 1;
    f[1][1] = r[1] - 1;
    rep(i, 2, n)
       f[i][0] = min(f[i-1][0] + abs(l[i-1] - r[i]) + r[i] - l[i] + 1, f[i-1][1] + abs(r[i-1] - r[i]) + r[i] - l[i] + 1),
       f[i][1] = min(f[i-1][0] + abs(l[i-1] - l[i]) + r[i] - l[i] + 1, f[i-1][1] + abs(r[i-1] - l[i]) + r[i] - l[i] + 1);
    printf("%d\n", min(f[n][0] + n - l[n], f[n][1] + n - r[n]));
    //rep(i, 1, n){ rep(j, 0, 1) printf("f[%d][%d] = %d, ", i, j, f[i][j]); puts(""); }
    return 0;
}

```

---

## 作者：pzc2004 (赞：74)

[题目传送门](https://www.luogu.org/problem/P3842)

**UPD:2021/6/19 修改了一个错误**

这题就是一个简单的 dp 题。

用 $f_{i,0}$ 表示走到第 $i$ 行的线段的左端点的最少步数，用 $f_{i,1}$ 表示走到第 $i$ 行的线段的右端点的最少步数。

那么可以得到 $f_{1,1}=dis(1,r_1),f_{1,0}=dis(1,r_1)+dis(r_1,l_1)$（$dis$ 表示距离）。

显然 $f_{i,0}$ 只能从 $f_{i-1,0}$ 和 $f_{i-1,1}$ 转移过来，如果是从 $f_{i-1,0}$ 转移过来，显然需要从第 $i-1$ 行的线段的左端点先往下移一格，再移到第i行的线段的右端点，再移到左端点；如果是从 $f_{i-1,0}$ 转移过来，显然需要从第 $i-1$ 行的线段的右端点先往下移一格，再移到第 $i$ 行的线段的右端点，再移到左端点。

那么就可以得到：

$$f_{i,0}=\min(f_{i-1,0}+dis(l_{i-1},r_i)+dis(r_i,l_i),f_{i-1,1}+dis(r_{i-1},r_i)+dis(r_i,l_i))+1$$

同理，对于 $f_{i,1}$ 也是一样：

$$f_{i,1}=\min(f_{i-1,0}+dis(l_{i-1},l_i)+dis(l_i,r_i),f_{i-1,1}+dis(r_{i-1},l_i)+dis(l_i,r_i))+1$$

然后就可以愉快的AC了。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,a[20001][2],f[20001][2];//a[i][0]表示l[i],a[i][1]表示r[i]
int dis(int a,int b)//计算距离
{
	return abs(a-b);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i][0],&a[i][1]);
	f[1][0]=dis(a[1][1],1)+dis(a[1][1],a[1][0]);
	f[1][1]=dis(a[1][1],1);
	for(int i=2;i<=n;i++)//状态转移
	{
		f[i][0]=min(f[i-1][0]+dis(a[i-1][0],a[i][1])+dis(a[i][1],a[i][0]),f[i-1][1]+dis(a[i-1][1],a[i][1])+dis(a[i][1],a[i][0]))+1;
		f[i][1]=min(f[i-1][0]+dis(a[i-1][0],a[i][0])+dis(a[i][0],a[i][1]),f[i-1][1]+dis(a[i-1][1],a[i][0])+dis(a[i][0],a[i][1]))+1;
	}
	printf("%d",min(f[n][0]+dis(a[n][0],n),f[n][1]+dis(a[n][1],n)));//最后的答案还要加上到(n,n)的距离
}

---

## 作者：aakennes (赞：72)

# P3842 [TJOI2007]线段

---

# 思路

## 1.出发点

显然显然显然（重要的事情说三遍），这一行的终点可能是线段的左边也可能是线段的右边，所以要想走完这一行的线段，就需要从上一行的左端点或右端点，进而就有了下面的讨论

## 2.讨论

计f[0][i]为走完第i行的线段且

### 情况1：上一行线段在左，下一行线段在右
    
此时分两种图：
      
![](https://cdn.luogu.com.cn/upload/image_hosting/ynpw0784.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/w0a60x8p.png)

很显然，这两种可能可以合并

#### 第一种图：     

图1： 
![](https://cdn.luogu.com.cn/upload/image_hosting/9qza3xz4.png)


这里指出一个误区：明明线路$2$比线路$1$要优秀，为什么还要考虑呢？其实很简单，$f[0][i-1]$可能要比$f[1][i-1]$小很多，而不是$f[1][i-1]$一定大于$f[0][i-1]$，所以$f[0][i-1]+abs(r[i]-l[i-1])$（从上一行左端点到这一行右端点）可能小于$f[1][i-1]+abs(r[i-1]-r[i])$（从上一行右端点到这一行右端点）

图2：
![](https://cdn.luogu.com.cn/upload/image_hosting/zx347eeb.png)

状态转移方程为：

      f[0][i]=min(f[0][i-1]+abs(r[i]-l[i-1]),f[1][i-1]+abs(r[i-1]-r[i]))+len[i]+1;
      f[1][i]=min(f[0][i-1]+abs(l[i-1]-l[i]),f[1][i-1]+abs(r[i-1]-l[i]))+len[i]+1;

#### 第二种图：
      
图1：
![](https://cdn.luogu.com.cn/upload/image_hosting/6ojakgsr.png)

图2：
![](https://cdn.luogu.com.cn/upload/image_hosting/42rif5c5.png)


状态转移方程为：

      f[0][i]=min(f[0][i-1]+abs(r[i]-l[i-1]),f[1][i-1]+abs(r[i-1]-r[i]))+len[i]+1;
      f[1][i]=min(f[0][i-1]+abs(l[i-1]-l[i]),f[1][i-1]+abs(r[i-1]-l[i]))+len[i]+1;

惊奇的发现，状态转移方程竟然一样，这样就减少判断缩减了代码

### 情况2：上一行线段在中，下一行线段在中

此时也分两种图：
      
![](https://cdn.luogu.com.cn/upload/image_hosting/hsnnri3a.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0olsk314.png)

显然这两种也可以合并

同样四张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3m5uq8cg.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/b67ypgo2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/s29zmml9.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0qyibkga.png)

状态转移方程：

      f[0][i]=min(f[0][i-1]+abs(r[i]-l[i-1]),f[1][i-1]+abs(r[i-1]-r[i]))+len[i]+1;
      f[1][i]=min(f[0][i-1]+abs(l[i-1]-l[i]),f[1][i-1]+abs(r[i-1]-l[i]))+len[i]+1;
      
我们又要口矣了，两种大情况的状态转移方程也一样诶，显然第三种情况（上一行线段在右，下一行线段在左）也是这个状态转移方程，都可以合并就不用判断了诶诶诶（当然可以自己在画画第三种情况的图）

# 代码：

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=2e4+5,INF=0x3f3f3f3f,mol=1000007;
int n,m,f[2][maxn],a[maxn],l[maxn],r[maxn],len[maxn];
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int main(){
	//freopen("a.in","r",stdin);
	n=read();
	for(int i=1;i<=n;i++)l[i]=read(),r[i]=read(),len[i]=r[i]-l[i];
	f[0][1]=r[1]-1+len[1];f[1][1]=r[1]-1;
	for(int i=2;i<=n;i++){
		f[0][i]=min(f[0][i-1]+abs(r[i]-l[i-1]),f[1][i-1]+abs(r[i-1]-r[i]))+len[i]+1;
		f[1][i]=min(f[0][i-1]+abs(l[i-1]-l[i]),f[1][i-1]+abs(r[i-1]-l[i]))+len[i]+1;
	}
	cout<<min(f[0][n]+n-l[n],f[1][n]+n-r[n]);
	
}
```
 OVER～







            

---

## 作者：_TMT_ (赞：47)

看到大家都写的dp题解，我来发一篇最短路的题解

以上一行的点为起点，到当前行的点之间的距离必然为上一行的点到当前行另外一点的距离加上当前行线段长度，即边权（因为必须经过每一行的线段）

个人觉得比较易懂

~~（其实我是因为最短路标签找的这道题，嘿嘿）~~
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#define Pair pair<int, int>
using namespace std;
int ne,n,m=1;
int head[40010],vis[40010],l[20010],r[20010];
long long dis[40010];
struct edge
{
	int to,next,v;
}e[50000005];
priority_queue<Pair, vector<Pair>, greater<Pair> > Heap;
void insert(int u,int v,int d)//建图
{
	ne++;
	e[ne].to=v;
	e[ne].next=head[u];
	e[ne].v=d;
	head[u]=ne;
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
    {
        cin>>l[i]>>r[i];
        m++;//左边的点
        if(i==1)//起点开始建图
        {
            insert(1,m,r[i]-1+r[i]-l[i]);
        }
        else//前一行的两个点分别建图
        {
            insert(m-2,m,abs(r[i]-l[i-1])+r[i]-l[i]);
            insert(m-1,m,abs(r[i]-r[i-1])+r[i]-l[i]);
        }
        m++;//右边的点
        if(i==1)//同上
        {
            insert(1,m,r[i]-1);
        }
        else//同上
        {
            insert(m-3,m,abs(l[i]-l[i-1])+r[i]-l[i]);
            insert(m-2,m,abs(l[i]-r[i-1])+r[i]-l[i]);
        }
    }
    m++;
    insert(m-2,m,n-l[n]);
    insert(m-1,m,n-r[n]);//最终向终点建图
	for(int i=1;i<=m;i++)dis[i]=999999999;
	Heap.push(Pair(0,1));
	dis[1]=0;
	while(!Heap.empty())
	{
		int u=Heap.top().second;
		Heap.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(dis[u]+e[i].v<dis[v])
			{
				dis[v]=dis[u]+e[i].v;
				Heap.push(Pair(dis[v],v));
			}
		}
	}
    cout<<dis[m]+n-1;//记住加上每次到下一行移动1，共n-1
	return 0;
}
```


---

## 作者：Rubyonly (赞：16)

# P3842 【[TJOI2007]线段】

## 思路

不难看出，路程长度由两个部分组成：左右走的距离 $+$ 上下走的距离，因为上下走的距离一定是 $n$，所以我们只需要求出左右走的最小距离即可。

很明显，当我们走完一行的线段时，我们会处在左端点/右端点，这样我们就需要在线性 $dp$ 的基础上加一维来表示走完这一行处在左/右端点。

所以我们定义一个 $f[i][0/1]$，表示走完第 $i$ 行的线段后，我们处在左/右端点。

然后我们就可以用上一行的状态来推出下一行了。

分为 $4$ 种情况：

上一行在左端点，下一行走到左端点；
上一行在左端点，下一行走到右端点；
上一行在右端点，下一行走到左端点；
上一行在右端点，下一行走到右端点；

我们以"上一行在右端点，下一行走到右端点"为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/irlvkowk.png)

这样我们就可以推出状态转移方程了。

```c++
f[i][1]=min(f[i-1][1]+abs(l[i]-r[i-1])+r[i]-l[i]+1,f[i-1][0]+abs(l[i]-l[i-1])+r[i]-l[i]+1);//本行走到右端点，上一行走到左/右端点，取最小值
f[i][0]=min(f[i-1][1]+abs(r[i]-r[i-1])+r[i]-l[i]+1,f[i-1][0]+abs(r[i]-l[i-1])+r[i]-l[i]+1);//本行走到左端点，上一行走到左/右端点，取最小值
```

最后不要忘了初始化第 $1$ 行就可以了。

##代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn=2e4+50;
int n;
int l[maxn],r[maxn];
int f[maxn][2];

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&l[i],&r[i]);
    }
    f[1][0]=2*r[1]-l[1]-1;//第1行往返，走到右端点再回来
    f[1][1]=r[1]-1;//直接走到右端点
    for(int i=2;i<=n;i++){
        f[i][1]=min(f[i-1][1]+abs(l[i]-r[i-1])+r[i]-l[i]+1,f[i-1][0]+abs(l[i]-l[i-1])+r[i]-l[i]+1);//本行走到右端点，上一行走到左/右端点，取最小值
        f[i][0]=min(f[i-1][1]+abs(r[i]-r[i-1])+r[i]-l[i]+1,f[i-1][0]+abs(r[i]-l[i-1])+r[i]-l[i]+1);//本行走到左端点，上一行走到左/右端点，取最小值
    }
    printf("%d\n",min(f[n][1]+n-r[n],f[n][0]+n-l[n]));//因为最后还要走到(n,n)的地方，加上剩下的距离，再加上上下走的距离即可
    return 0;
}
```



---

## 作者：Y_B_Y (赞：10)

首先观察题目,不难发现,这是一题$\operatorname{DP}$,但是我们发现这一题走路的方向有3中,并且$n$较大,一格格走非常不方便,那么我们可以考虑用贪心来优化一下.

怎么贪心呢,不难发现如果我们要从一行走到下一行,那么我们一定是在线段的左端或右端,因为题目要求我们要走完整条线段,那么我们如果用最优的方法走的话,最后一步肯定是在端点处,所以我们可以设$f[i][0]$为走到第$i$行,最后再左端点停下的最短路,$f[i][1]$则为在右端点停下的最短路

这时我们可以先考虑一个问题,当我们在第$i$行的第$j$列,那么如果我们要走到第$i+1$行并走一遍的线段,然后再右端停下,我们要走的最短路是多少,如图

![](https://cdn.luogu.com.cn/upload/image_hosting/qnfe8u91.png)

所以我们可以推出状态转移方程

$f[i][0]=min(f[i-1][0]+r[i]-l[i]+abs(r[i]-l[i-1]),f[i-1][1]+r[i]-l[i]+abs(r[i]-r[i-1]))+1$($r[i]-l[i]+abs(r[i]-l[i-1])$其实就是从上一条线段的左端点先走完这一条线段,再在左端点停下的最短路径)

$f[i][1]=min(f[i-1][0]+r[i]-l[i]+abs(l[i]-l[i-1]),f[i-1][1]+r[i]-l[i]+abs(l[i]-r[i-1]))+1$

其实就是从上一条线段的左右端点选一点更优的,注意加上向下走一步的路程长度1

还有$\operatorname{DP}$数组的初始化

$f[1][0]=2\times r[1]-1-l[1]$,因为从(1,1)开始走

$f[1][1]=r[1]-1$

剩下细节看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l[20001],r[20001],f[20001][2];
inline long long read()
{
    char c=getchar();long long sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++) l[i]=read(),r[i]=read();
	f[1][0]=2*r[1]-1-l[1];
	f[1][1]=r[1]-1;
	for(int i=2;i<=n;i++)
	{
		f[i][0]=min(f[i-1][0]+r[i]-l[i]+abs(r[i]-l[i-1]),f[i-1][1]+r[i]-l[i]+abs(r[i]-r[i-1]))+1;
		f[i][1]=min(f[i-1][0]+r[i]-l[i]+abs(l[i]-l[i-1]),f[i-1][1]+r[i]-l[i]+abs(l[i]-r[i-1]))+1;
	}
	return printf("%d",min(f[n][1]+n-r[n],f[n][0]+n-l[n])),0;
}
```


---

## 作者：小手冰凉 (赞：9)

貌似比前面那位大佬的DP好理解一点，所以就发了上来


f[i][0]表示第i行结束时在左端点时最小用时


f[i][1]表示第i行结束时在右端点时最小用时


首先我们可以很轻松的发现每次走完行时，一定在这个线段的左端点或者右端点


那么每次DP时枚举


从上一行的左边转移到下一行右边

从上一行的右边转移到下一行右边

从上一行的左边转移到下一行左边

从上一行的右边转移到下一行左边


递归方程具体看下程序吧，这个画下图基本就很明显了


可以把第一维压成滚存，让空间复杂度更小(\*^▽^\*)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20005;
int n;
int f[N][2];
int l[N],r[N];
int len[N];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&l[i],&r[i]);
        len[i]=r[i]-l[i]+1;
    }
    memset(f,127/3,sizeof(f));
    f[1][0]=r[1]+r[1]-l[1]-1;//初始化时注意走到左边的是要先到右端点再到左边（貌似可以不用这句，因为开始第一行右端点最优）
    f[1][1]=r[1]-1;
    for(int i=2;i<=n;i++){//递归方程，len是预处理出来的这行中走线段所需用时
        if(l[i-1]<r[i])f[i][0]=min(f[i][0],f[i-1][0]+r[i]-l[i-1]+len[i]);
        else f[i][0]=min(f[i][0],f[i-1][0]+l[i-1]-r[i]+len[i]);
        if(r[i-1]<r[i])f[i][0]=min(f[i][0],f[i-1][1]+r[i]-r[i-1]+len[i]);
        else f[i][0]=min(f[i][0],f[i-1][1]+r[i-1]-r[i]+len[i]);
        if(l[i-1]>l[i])f[i][1]=min(f[i][1],f[i-1][0]+l[i-1]-l[i]+len[i]);
        else f[i][1]=min(f[i][1],f[i-1][0]+l[i]-l[i-1]+len[i]);
        if(r[i-1]>l[i])f[i][1]=min(f[i][1],f[i-1][1]+r[i-1]-l[i]+len[i]);
        else f[i][1]=min(f[i][1],f[i-1][1]+l[i]-r[i-1]+len[i]);
    }
    printf("%d",min(f[n][0]+n-l[n],f[n][1]+n-r[n]));//最后别忘了走到（n,n）
    return 0;
}
```

---

## 作者：Tarsal (赞：5)

大家写的都是普通的dp

我来写一发滚动dp

何为滚动dp？

就是在转移的时候不断利用无用的空间，来避免 $MLE$  ~~虽然这里没有必要~~

$f[i][0]$ 表示走完第i行且停在第i行的左端点最少用的步数

$f[i][1]$ 表示走完第i行且停在第i行的右端点最少用的步数

那么递推方程很好推：

```
f[i][0] = min(f[i-1][0] + abs(l[i-1] - r[i]), f[i-1][1] + abs(r[i-1] - r[i])) + r[i] - l[i] + 1,
f[i][1] = min(f[i-1][0] + abs(l[i-1] - l[i]), f[i-1][1] + abs(r[i-1] - l[i])) + r[i] - l[i] + 1;
```

这时候你可以发现，当前的状态只与 $f[i - 1][0/1]$ 有关。

所以可以得到以下代码 : 

```
f[i % 2][1] = min(f[i % 2 ^ 1][0] + abs(L[i % 2] - L[i % 2 ^ 1]), f[i % 2 ^ 1][1] + abs(R[i % 2 ^ 1] - L[i % 2])) + 1 + R[i % 2] - L[i % 2];
f[i % 2][0] = min(f[i % 2 ^ 1][0] + abs(R[i % 2] - L[i % 2 ^ 1]), f[i % 2 ^ 1][1] + abs(R[i % 2 ^ 1] - R[i % 2])) + 1 + R[i % 2] - L[i % 2];
```

完整代码：

```
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#define N 5010
#define M 1000010
#define ls x << 1
#define rs x << 1 | 1
#define inf 0x3f3f3f3f
#define inc(i) (++ (i))
#define dec(i) (-- (i))
#define mid ((l + r) >> 1)
 #define int long long
//#define ll long long
#define XRZ 19260817
#define pai acos(-1)
#define debug() puts("XRZ TXDY");
#define mem(i, x) memset(i, x, sizeof(i));
#define Next(i, u) for(register int i = head[u]; i ; i = e[i].nxt)
#define file(x) freopen(#x".in", "r", stdin), freopen(#x".out", "w", stdout);
#define Rep(i, a, b) for(register int i = (a) , i##Limit = (b) ; i <= i##Limit ; inc(i))
#define Dep(i, a, b) for(register int i = (a) , i##Limit = (b) ; i >= i##Limit ; dec(i))
using namespace std;
inline int read() {
    register int x = 0, f = 1; register char c = getchar();
    while(c < '0' || c > '9') {if(c == '-') f = -1;c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c 	- 48, c = getchar(); 
    return x * f;
}
inline int read_plus() {
    register int res = 0, ch = getchar();
    while(!isdigit(ch) and ch != EOF) ch = getchar();
    while(isdigit(ch)) res = ((res << 3) + (res << 1) + (ch - '0')) % XRZ, ch = getchar();
    return res;
}
int dx[10] = {0, 1, 1, 2, 2, -1, -1, -2, -2};
int dy[10] = {0, 2, -2, 1, -1, 2, -2, 1, -1};
int exgcd(int a, int b, int &x, int &y) {
	if(b == 0) { x = 1, y = 0; return a;}
	int now = exgcd(b, a % b, x, y);
	int yy = x; x = y, y = yy - a / b * y;
	return now;
}
int n, L[2], R[2], f[2][2];
signed main() { n = read(), L[1] = read(), R[1] = read(), f[1][0] = R[1] * 2 - L[1] - 1, f[1][1] = R[1] - 1;
	Rep(i, 2, n) { L[i % 2] = read(), R[i % 2] = read();
		f[i % 2][1] = min(f[i % 2 ^ 1][0] + abs(L[i % 2] - L[i % 2 ^ 1]), f[i % 2 ^ 1][1] + abs(R[i % 2 ^ 1] - L[i % 2])) + 1 + R[i % 2] - L[i % 2];
		f[i % 2][0] = min(f[i % 2 ^ 1][0] + abs(R[i % 2] - L[i % 2 ^ 1]), f[i % 2 ^ 1][1] + abs(R[i % 2 ^ 1] - R[i % 2])) + 1 + R[i % 2] - L[i % 2];
//		printf("1 : %d %d\n", f[i % 2][0], f[i % 2][1]); 
	} printf("%d", min(f[n % 2][0] + n - L[n % 2], f[n % 2][1] + n - R[n % 2]));
	return 0;
}
```

---

## 作者：Doubeecat (赞：3)

线性 DP.

首先我们观察题目中的三种操作，可以概括成：

- 在横坐标上 +1 -1
- 在纵坐标上 +1

初步定义 $f_{i,j}$ 代表在第 $i$ 行第 $j$ 列里的最短长度。

然而我们很快可以发现，这里的 $n \leq 20000$ ，而且转移时并不是很好写，有许多冗余状态（横坐标在最长线段外的点我们显然不可能走到）

我们再对这个过程进行深入分析，发现其实在走线段的过程中只有横坐标会变化，而且这个变化并不用 DP 维护，暴力加上即可。

所以我们再定义 $f_{i,0/1}$ 代表在第 $i$ 行时，若为 0，则说明**走完这条线段后**在线段的左端点，若为 1，则说明**走完这条线段后**在线段的右端点。

这样我们的转移也呼之欲出了，

$f_{i,0}$ 可以从 $f_{i-1,0}$ 或 $f_{i-1,1}$ 转移来，转移方程为

$$f_{i,0} = \min(f_{i-1,0} + \operatorname{dis}(l_{i-1},r_i),f_{i-1,1} + \operatorname{dis}(r_{i-1},r_i)) + len + 1$$

上述方程表示由上一行的线段的左端点转移来时，先走到当前行的右端点再向下走，最后走一遍到当前线段的左端点。右端点同理。

同理，

$f_{i,1}$  可以从 $f_{i-1,0}$ 或 $f_{i-1,1}$ 转移来，转移方程为

$$f_{i,1} = \min(f_{i-1,0} + \operatorname{dis}(l_{i-1},l_i),f_{i-1,1} + \operatorname{dis}(r_{i-1},l_i)) + len + 1$$

上述方程表示由上一行的线段的左端点转移来时，先走到当前行的左端点再向下走，最后走一遍到当前线段的左端点。右端点同理。

因为其满足各个维度线性增长，故其为线性 DP ，时间复杂度 $O(n)$

```cpp
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cctype>
#include <cmath>
#define ll long long
#define ri register int

char buf[1 << 20], *p1, *p2;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2)?EOF: *p1++)
template <typename T> inline void read(T &t) {
	ri v = getchar();T f = 1;t = 0;
	while (!isdigit(v)) {if (v == '-')f = -1;v = getchar();}
	while (isdigit(v)) {t = t * 10 + v - 48;v = getchar();}
	t *= f;
}
template <typename T,typename... Args> inline void read(T &t,Args&... args) {
	read(t);read(args...);
}

template <typename T> inline T min(T x,T y) {return x<y?x:y;}
template <typename T> inline T max(T x,T y) {return x>y?x:y;}
const int INF = 0x3f3f3f3f;
const ll inf = 0x3f3f3f3f3f3f3f3fLL;
const int N = 25100;

int f[N][2],l[N],r[N],n;

inline int dis(int x,int y) {return abs(x-y);}

signed main() {
	read(n);
	for (int i = 1;i <=  n;++i) read(l[i],r[i]);
	f[1][1] = dis(1,r[1]),f[1][0] = dis(1,r[1]) + dis(l[1],r[1]);
	for (int i = 2;i <= n;++i) {
		int len = dis(l[i],r[i]);
		f[i][0] = min(f[i-1][0]+dis(l[i-1],r[i]),f[i-1][1]+dis(r[i-1],r[i])) + len + 1;
		f[i][1] = min(f[i-1][0]+dis(l[i-1],l[i]),f[i-1][1]+dis(r[i-1],l[i])) + len + 1;
	}
	int ans = min(f[n][0] + dis(l[n],n),f[n][1] + dis(r[n],n));
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：happy_dengziyue (赞：3)

### 1 思路

首先输入 $n$。

然后输入线段端点。设 $a[i][0]$ 为第 $i$ 条线段的左端点，$a[i][1]$ 为右端点。

设 $dp[i][0]$ 为，走完第 $i$ 条线段后人在左端点的最短距离，$dp[i][1]$ 为走完第 $i$ 条线段后人在右端点的最短距离。

首先考虑第一条线段。可以得出：

$$dp[1][0]=a[1][1]+a[1][1]-a[1][0]-1$$

$$dp[1][1]=a[1][1]-1$$

然后就考虑第 $i\ (2\le i\le n)$ 条线段。

可以看出，为了达到最优解，如果结束时人在左端点，那么一定要从右往左走线段；如果人在右端点则从左往右。

所以，我们得出了动规方程：

$$dp[i][0]=\operatorname{min}(dp[i-1][0]+\left|a[i-1][0]-a[i][1]\right|+a[i][1]-a[i][0]+1,dp[i-1][1]+\left|a[i-1][1]-a[i][1]\right|+a[i][1]-a[i][0]+1)$$

$$dp[i][1]=\operatorname{min}(dp[i-1][0]+\left|a[i-1][0]-a[i][0]\right|+a[i][1]-a[i][0]+1,dp[i-1][1]+\left|a[i-1][1]-a[i][0]\right|+a[i][1]-a[i][0]+1)$$

但是，最后还要走到点 $(n,n)$。所以答案就是：

$$ans=\operatorname{min}(dp[n][0]+n-a[i][0],dp[n][1]+n-a[i][1]$$

然后就可以愉快地切掉它啦。

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define max_n 2000000
int n;
int a[max_n+2][2];
int dp[max_n+2][2];
inline int absi(int a){
	return a>0?a:-a;
}
inline int mi(int a,int b){
	return a<b?a:b;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P3842_1.in","r",stdin);
	freopen("P3842_1.out","w",stdout);
	#endif
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d%d",a[i],a[i]+1);
	}
	dp[1][0]=a[1][1]+a[1][1]-a[1][0]-1;
	dp[1][1]=a[1][1]-1;
	for(int i=2;i<=n;++i){
		dp[i][0]=mi(dp[i-1][0]+absi(a[i-1][0]-a[i][1])+a[i][1]-a[i][0]+1,dp[i-1][1]+absi(a[i-1][1]-a[i][1])+a[i][1]-a[i][0]+1);
		dp[i][1]=mi(dp[i-1][0]+absi(a[i-1][0]-a[i][0])+a[i][1]-a[i][0]+1,dp[i-1][1]+absi(a[i-1][1]-a[i][0])+a[i][1]-a[i][0]+1);
	}
	printf("%d\n",mi(dp[n][0]+n-a[n][0],dp[n][1]+n-a[n][1]));
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/54869756)

By **dengziyue**

---

## 作者：YZhe (赞：3)

      # 本题显然需要利用**动态规划**求最优值
    简单说说思路吧
	到达每个线段的最小路径长度分为从左端进入和从右端进入两种
	无论从左端进入或是从右端进入的最短路径都是当前线段长度， 1（到下一行必须走一步），到上一条线段的最优值，上一条线段的左端点或右端点与当前线段左端点或右端点的水平距离之和
    附上代码，带有注解
   ```cpp
#include<bits/stdc++.h>
using namespace std;
int linel[20005];//保存左端点 
int liner[20005];//保存右端点 
int linelen[20005];//保存线段长度 
int disl[20005];//保存从线段左端进入右端出去的最优解 
int disr[20005];//保存从线段右端进入左端出去的最优解 
int jd(int a,int b)//求绝对值 
{
	if(a>=b) return a-b;
	return b-a;
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>linel[i]>>liner[i];//输入线段的左端点和右端点 
		linelen[i]=liner[i]-linel[i];//求线段的长度 
	}
	disl[1]=liner[1]-1;
	disr[1]=liner[1]+linelen[1]-1;//初始化 
	for(int i=2;i<=n;i++)
	{
		disl[i]=linelen[i]+1+min(disl[i-1]+jd(liner[i-1],linel[i]),disr[i-1]+jd(linel[i-1],linel[i]));
        disr[i]=linelen[i]+1+min(disl[i-1]+jd(liner[i-1],liner[i]),disr[i-1]+jd(linel[i-1],liner[i]));
	}//DP 
    cout<<min(disl[n]+n-liner[n],disr[n]+n-linel[n]);//输出最小值 
}
```

---

## 作者：Mathison (赞：2)

一道比较不错的题

### 【题意描述】
在一个 $n*n$ 的平面上，在每一行中有一条线段，第 i 行的线段的左端点是$(i, L(i))$，右端点是$(i, R(i))$，其中 $1 ≤ L(i) ≤ R(i) ≤ n$。
从$(1, 1)$点出发，要求沿途**走完所有的线段**，最终到达$(n, n)$点，且所走的路程长度要尽量短。

### 【题意关键】

1. 每条线段要**走完**

1. 向下走也要**计算步数**

1. 目标是从$(1,1)$走到$(n,n)$

### 【设计转移】

 $f[i][0]$表示走到第 $i$ 行的线段的左端点的最少步数

 $f[i][1]$表示走到第 $i$ 行的线段的右端点的最少步数

 $l[i],r[i]$表示第 $i$ 行线段的左端点和右端点
 
 ### 【注意细节】
 
 最开始的初值：$f[1][1]=r[i]-1$这个没什么问题
 
 注意从$(1,1)$走到线段左端点要先走到右端点再返回左端点，这样才能**走完**第一条线段，即$ f[1][0]=r[1]+r[1]-l[1]-1$
 
 ### 【代码实现】
 ```
#include<bits/stdc++.h>
using namespace std;
const int N=20005;
int n,l[N],r[N],len[N],f[N][2],o;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]),len[i]=r[i]-l[i]+1;//注意此处加1的含义 
    memset(f,127,sizeof f);
    //f[i][0]=abs(上一行左端点的坐标-本行右端点的坐标)+本行线段长度
    f[1][0]=r[1]+r[1]-(l[1]+1);//(1,1)-->右端点-->左端点 
    f[1][1]=r[1]-1;//(1,1)-->右端点 
    for(int i=2;i<=n;i++)
	{
        f[i][0]=min(f[i][0],f[i-1][0]+abs(r[i]-l[i-1])+len[i]);//左-->左
        f[i][0]=min(f[i][0],f[i-1][1]+abs(r[i]-r[i-1])+len[i]);//右-->左
        f[i][1]=min(f[i][1],f[i-1][0]+abs(l[i-1]-l[i])+len[i]);//左-->右
        f[i][1]=min(f[i][1],f[i-1][1]+abs(r[i-1]-l[i])+len[i]);//右-->右
    }
    printf("%d",min(f[n][0]+n-l[n],f[n][1]+n-r[n]));//min(右-->(n,n),左-->(n,n))
    return (o^0^o);//卖个萌 
}
 ```
 ### 【空间优化】
 
 我们发现转移只与上一个状态有关，所以可以运用滚动数组
 
 ```
 #include<bits/stdc++.h>
using namespace std;
const int N=20005;
int n,l[N],r[N],len[N],f[2][2];//好小有木有
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]),len[i]=r[i]-l[i]+1;
    f[1][0]=r[1]+r[1]-(l[1]+1),f[1][1]=r[1]-1;
    for(int i=2;i<=n;i++)
	{
        f[i&1][0]=min(f[(i+1)&1][0]+abs(r[i]-l[i-1])+len[i],f[(i+1)&1][1]+abs(r[i]-r[i-1])+len[i]);
        f[i&1][1]=min(f[(i+1)&1][0]+abs(l[i-1]-l[i])+len[i],f[(i+1)&1][1]+abs(r[i-1]-l[i])+len[i]);
    }
    printf("%d",min(f[n&1][0]+n-l[n],f[n&1][1]+n-r[n]));
    return 0;
}
 ```

---

## 作者：wenjie (赞：2)

有没有一开始像我一样写三重循环，考虑每一个中间点的？这样的话，不仅会爆时间，还会爆空间。（可以过三个点）
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int dp[5000][5000];
int l[20005],r[20005];
int ans=999999999;
int main()
{
	int n;
	n=read();
	for(int i=1;i<=n;i++)
	{
		l[i]=read();
		r[i]=read();
	}
	memset(dp,0x3f,sizeof(dp));
	for(int i=l[1];i<=r[1];i++)
	{
		dp[1][i]=i-1;
	}
	for(int i=2;i<=n;i++)
		for(int j=l[i];j<=r[i];j++)
		{
			for(int k=l[i-1];k<=r[i-1];k++)
			{
				dp[i][j]=min(dp[i][j],dp[i-1][k]+r[i-1]-l[i-1]+min(abs(r[i-1]-k)+abs(l[i-1]-j),abs(l[i-1]-k)+abs(r[i-1]-j)));
			}
		} 
	for(int i=l[n];i<=r[n];i++)
	ans=min(ans,dp[n][i]+r[n]-l[n]+min(abs(r[n]-i)+n-l[n],abs(l[n]-i)+n-r[n]));
	cout<<ans+n-1;
}
```
##### 这里dp[i][j]意义为第i行时从上一行下来指针在j(还未走完第i行，只是刚刚下来)。
然而，我们需要更好的方法
首先，行数不可优化了，显然列数不能是20000，考虑能不能只利用左右两个端点。
于是
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int dp[30000][2];
int l[20005],r[20005];
int ans=999999999;
int main()
{
	int n;
	n=read();
	for(int i=1;i<=n;i++)
	{
		l[i]=read();
		r[i]=read();
	}
	memset(dp,0x3f,sizeof(dp));
	dp[1][0]=r[1]-1+r[1]-l[1];
	dp[1][1]=r[1]-1;
	for(int i=2;i<=n;i++)
	{
		dp[i][0]=min(dp[i-1][0]+abs(r[i]-l[i-1])+r[i]-l[i],dp[i-1][1]+abs(r[i]-r[i-1])+r[i]-l[i]);
		dp[i][1]=min(dp[i-1][0]+abs(l[i]-l[i-1])+r[i]-l[i],dp[i-1][1]+abs(l[i]-r[i-1])+r[i]-l[i]);
	}
	cout<<min(dp[n][0]+n-l[n],dp[n][1]+n-r[n])+n-1;
}
```
这里dp[i][j]表示在第i行走完后终止于左（j==0）,右（j==1）;


---

## 作者：Celebrate (赞：2)

[MyBlog](https://blog.csdn.net/zsyzClb/article/details/84953491)

不难计算得到，路程的总长度是 24。 100%的数据中，n ≤ 20 000。

 

因为这一道题的题目要求要走完全部的线段，注意不是走过，是整条线段走完

所以我们不能用贪心来做 ， 经过观察，可以发现

往下走的都是到达了本行线段的某一个端点并且走完了这一个线段，所以dp只用继承前一条线段的两个端点

代码 （用滚动数组优化）

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
 
using namespace std ;
 
const int N = 2e4 + 10 ;
int n , zb[2][2] ; //zb[][0]表示线段的左端点的位置，zb[][1]表示线段右端点的位置 
int dp[2][2] ;  
 
int main() {
	memset ( dp , 63 , sizeof ( dp ) ) ; 
	cin >> n >> zb[1][0] >> zb[1][1] ; 
	dp[1][1] = zb[1][1] - 1 ;
	for ( int i = 2 ; i <= n ; i ++ ) {
		cin >> zb[i&1][0] >> zb[i&1][1] ;
		for ( int j = 0 ; j < 2 ; j ++ ) //左右两端点分别继承 
			dp[i&1][j] = min ( //继承左右端点，先要从继承的那个点下来，然后到另一个点去，再到这个点 
				dp[i&1^1][0] + abs ( zb[i&1][1-j] - zb[i&1^1][0] )  ,
				dp[i&1^1][1] + abs ( zb[i&1][1-j] - zb[i&1^1][1] ) 
			) + 1 + zb[i&1][1] - zb[i&1][0] ;
	}
	cout << min ( dp[n&1][0] + abs( n - zb[n&1][0] ) , dp[n&1][1] + abs ( n - zb[n&1][1] ) ) << endl ;
	return 0 ;  
}

```

---

## 作者：逝星DS (赞：2)

P3842 【[TJOI2007]线段】

题目描述

在一个 n*n 的平面上，在每一行中有一条线段，第 i 行的线段的左端点是(i, L(i))，右端点是(i, R(i))，其中 1 ≤ L(i) ≤ R(i) ≤ n。

你从(1, 1)点出发，要求沿途走过所有的线段，最终到达(n, n)点，且所走的路程长度要尽量短。

更具体一些说，你在任何时候只能选择向下走一步（行数增加 1）、向左走一步（列数减少 1）或是向右走一步（列数增加 1）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。

输入输出格式

输入格式：
输入文件的第一行有一个整数 n，以下 n 行，在第 i 行（总第(i+1)行）的两个整数表示

L(i)和 R(i)。

输出格式：
输出文件仅包含一个整数，你选择的最短路程的长度。

输入输出样例

输入样例#1： 
6
2 6
3 4
1 3
1 2
3 6
4 5
输出样例#1： 
24
说明

我们选择的路线是

(1,1) (1,6)
 (2,6) (2, 3)
 (3, 3) (3, 1)
 (4, 1) (4, 2)
 (5, 2) (5, 6)
 (6, 6) (6, 4) (6, 6)
不难计算得到，路程的总长度是 24。 100%的数据中，n ≤ 20 000。

思路：dp;
设fl[maxN],fr[maxN]，fl[i]为第i行走完线段后停在左端时的最短路,fr同;

附上代码：（详细注释）

```cpp
#include <iostream>
#include <cmath>
#define maxN 20010
using namespace std;
int N;
int _left[maxN],_right[maxN];  //左右端点； 
int fl[maxN],fr[maxN];  //fl[i]为第i行走完线段后停在左端时的最短路,fr同;
int main()  {
	cin>>N;
	if(N==1)  {  //N=1,直接输出0（相信我，有这个点)； 
		cout<<0;
		return 0;
	}
	for(int i=1;i<=N;i++)  {
		cin>>_left[i]>>_right[i];
	}
	fl[1]=2*_right[1]-_left[1]-1;  //初始化；
	fr[1]=_right[1]-1;
	for(int i=2;i<N;i++)  {  //最后一行特殊处理（因为必须到点（N,N））； 
	     fl[i]=min(fl[i-1]+_right[i]-_left[i]+(int)abs(_right[i]-_left[i-1]),fr[i-1]+(int)abs(_right[i]-_right[i-1])-_left[i]+_right[i]);
	     fr[i]=min(fl[i-1]+(int)abs(_left[i]-_left[i-1])+_right[i]-_left[i],fr[i-1]+(int)abs(_right[i-1]-_left[i])+_right[i]-_left[i]);
	}
	//最后一行，到达(N,N)； 
	int ans=min(fl[N-1]+(int)abs(_left[N]-_left[N-1])+N-_left[N],fr[N-1]+(int)abs(_right[N-1]-_left[N])+N-_left[N])+N-1;//别忘+N-1; 
	cout<<ans;
	return 0;
} 
```


---

## 作者：wtxy2006 (赞：1)

#### 题目大意：
有 $n$ 条线段，要求从上至下走完所有的线段并且使路程最短，求最短的距离。
#### 题目分析：
显然是动态规划的水题，定义状态 $f[i][0]$ 表示已走完第 $i$ 列的线段，并且在线段的左端点，$f[i][1]$ 表示已走完第 $i$ 列，且在线段的右段点。

考虑转移，发现当前行的状态只和上一行的状态有关，则：
- 走完这行在这行的右端点：从上一行的左端点到这一行的左端点的距离,和从上一行的右段点到这一行的左端点的距离中的最小值加一(上下移动所花费的距离)再加上这条线段的长度。
$$f[i][1] = \min(f[i - 1][0] + abs(ls[i - 1] - ls[i]),f[i - 1][1] + abs(rs[i - 1] - ls[i])) + l[i] + 1;$$
- 走完这行在这行的左端点：从上一行的左端点到这一行的右端点的距离,和从上一行的右段点到这一行的右端点的距离中的最小值加一(上下移动所花费的距离)再加上这条线段的长度。
$$f[i][0] = \min(f[i - 1][0] + abs(ls[i - 1] - rs[i]),f[i - 1][1] + abs(rs[i - 1] - rs[i])) + l[i] + 1$$

空间还可以用滚动数组继续优化，首先规定：
``` cpp
#define pre(i) ((i + 1) % 2)
#define now(i) (i % 2)
```
所以可将转移方程改成这样：
$$\begin{cases}f[now(i)][0] = \min(f[pre(i)][0] + abs(ls[i - 1] - rs[i]),f[pre(i)][1] + abs(rs[i - 1] - rs[i])) + l[i] + 1;\\f[now(i)][1] = \min(f[pre(i)][0] + abs(ls[i - 1] - ls[i]),f[pre(i)][1] + abs(rs[i - 1] - ls[i])) + l[i] + 1;\end{cases}$$
所以只要 $4$ 个 $int$ 空间就可以存下所有的状态。
#### 完整代码：
``` cpp
// P3842 [TJOI2007]线段
#include <cmath>
#include <cstdio>
#include <iostream>
#define MN 20005
#define pre(i) ((i + 1) % 2)
#define now(i) (i % 2)
using namespace std;
inline int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-') f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9')
    x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
  return x * f;
}
int n, ls[MN], rs[MN], f[2][2], l[MN];
int main() {
  n = read() - 1;
  for (int i = 0; i <= n; i++)
    ls[i] = read(), rs[i] = read(), l[i] = rs[i] - ls[i];
  f[0][0] = rs[0] + l[0], f[0][1] = ls[0] + l[0];
  for (int i = 1; i <= n; i++)
    f[now(i)][0] = min(f[pre(i)][0] + abs(ls[i - 1] - rs[i]),
                       f[pre(i)][1] + abs(rs[i - 1] - rs[i])) +
                   l[i] + 1,
    f[now(i)][1] = min(f[pre(i)][0] + abs(ls[i - 1] - ls[i]),
                       f[pre(i)][1] + abs(rs[i - 1] - ls[i])) +
                   l[i] + 1;
  printf("%d\n", min(f[now(n)][0] - ls[n], f[now(n)][1] - rs[n]) + n);
  return 0;
}
```
时间复杂度 $O(n)$。

---

## 作者：ShineEternal (赞：0)

[更护眼的阅读效果。](https://blog.csdn.net/kkkksc03/article/details/105544432)

## description

在一个 $n\times n$ 矩阵中每一行都有一条线段，找出从 $(1,1)$ 出发不重不漏地遍历每一条线段并走到 $(n,n)$ 结束所需的步数。

## solution

**使用 dp。**

考虑设 $f[i][0/1]$ 表示当前以及遍历完了第 $i$ 行的线段，在左（$0$）/ 右（$1$）端点结束遍历（即准备从这个端点跳到下一行）。

**那么我们可以考虑两行之间衔接的四种情况：**

- 左端点到左端点：$f[i][0]=f[i-1][0]+ abs(L[i]-L[i-1])+R[i]-L[i]+1$，其中 $abs(L[i]-L[i-1])$ 为两个左端点之间列数的差距，$R[i]-L[i]$ 为遍历一个线段的步数，而因为向下了一行所以要 $+1$。

- 右端点到左端点：$f[i][0]=f[i-1][1]+ abs(L[i]-R[i-1])+R[i]-L[i]+1$，这个时候同理，只是变换了第 $i-1$ 行的下行节点和转移来的 $f$ 的值。

- 左端点到右端点：$f[i][1]=f[i-1][0]+ abs(R[i]-L[i-1])+R[i]-L[i]+1$。

- 右端点到右端点：$f[i][1]=f[i-1][1]+ abs(R[i]-R[i-1])+R[i]-L[i]+1$。

那么对于 $f[i][0]$ 和 $f[i][1]$ ，我们选择上一行的最优端点转移下来就行了。

**初始化：**

如果刚开始到左端点的话要走两遍线段长，如果右端点可以直接一次性走过去。

**输出：**

由于 $f$ 的值是以线段端点为结束的，而题目要求以 $(n,n)$ 为终点，所以要走到 $n$。






## code
```cpp
#include<cstdio>
using namespace std;
int f[20005][3];//设f[i][0]表示走完了第i行且走到左端点；设f[i][1]表示走完了第i行且走到了右端点。 
int abs(int x)
{
	if(x<0)return -x;
	return x;
}
int min(int x,int y)
{
	if(x<y)return x;
	return y;
}
int L[20005],R[20005];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&L[i],&R[i]);
	}
	f[1][0]=L[1]-1+(R[1]-L[1])*2;
	f[1][1]=R[1]-1; 
	for(int i=2;i<=n;i++)
	{
		f[i][0]=min(f[i-1][1]+abs(R[i-1]-R[i]),f[i-1][0]+abs(L[i-1]-R[i]))+R[i]-L[i]+1;
		f[i][1]=min(f[i-1][1]+abs(R[i-1]-L[i]),f[i-1][0]+abs(L[i]-L[i-1]))+R[i]-L[i]+1;
	}
	printf("%d\n",min(f[n][0]+n-L[n],f[n][1]+n-R[n]));
	return 0;
}
```

---


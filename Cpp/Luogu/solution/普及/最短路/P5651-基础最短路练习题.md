# 基础最短路练习题

## 题目背景

YSGH 牛逼

## 题目描述

给定 $n$ 个点 $m$ 条边的简单无向连通图 $G$，边有边权。保证没有重边和自环。

定义一条简单路径的权值为路径上所有边边权的异或和。

保证 $G$ 中不存在简单环使得边权异或和不为 $0$。

$Q$ 次询问 $x$ 到 $y$ 的最短简单路径。

## 说明/提示

| 数据点编号 | $n, Q \le$ | 特殊性质 |
| :--: | :--: | :--: |
| $1,2$ | $10$ | 无 |
| $3,4$ | $20$ | 无 |
| $5,6$ | ${10}^5$ | $m = n - 1$ |
| $7,8$ | ${10}^5$ | $v \le 1$ |
| $9,10$ | ${10}^5$ | 无 |

对于 $100\%$ 的数据，满足 $1 \le n \le {10}^5$，$1 \le m \le 2n$，$0 \le v < 2^{30}$。

## 样例 #1

### 输入

```
3 2 1
1 2 2
2 3 3
1 3```

### 输出

```
1```

# 题解

## 作者：Crab_Dave (赞：80)

考场上挂了，想到了生成树，但没想到正解qwq

题中有一句话十分重要——

>**保证$G$中不存在简单环使得边权异或和不为$0$。**

这句话是什么意思呢？

**$G$中的环（如果存在）边权异或和都为$0$！**

~~那我们走环干啥qwq~~

**对啊，那我们走环干啥！**

~~不走了呗~~

**对啊，不走了呗！**

另外，从一条路径增广到另一条路径的必要条件（应该是必要条件吧，~~反正逻辑什么的口胡一下就行2333~~）是这两条路径能够成一个环。

在这道题中，就是这两条路径的权值 异或和为$0$。

~~那不就是相等吗？~~

**是啊，就是这两条路径相等啊！**

推广一下这个结论，我们可以得到一个看似口胡的结论（当然只适用于这道题）——

>$(x,y)$之间任一路径权值相等，即所有路径等价。

好了，大功告成！

随便求棵生成树，dfs$O(n)$预处理，$O(q)$询问，完毕~

详见代码qwq
```cpp
#include<cstdio>
using namespace std;

int n,m,q,fa[100005],s[100005];
int head[100005],k=1;
struct edge
{
	int to,next,w;
}e[400005],eg[200005];//存边
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}//并查集带路径压缩的查找

void adde(int u,int v,int w)//链式前向星加边
{
	e[k].to=v;
	e[k].w=w;
	e[k].next=head[u];
	head[u]=k++;
}

void Produce()//求生成树
{
	for(register int i=1;i<=n;i++)fa[i]=i;//并查集初始化
	for(register int i=1;i<=m;i++)
	{
		int fu=find(eg[i].next),fv=find(eg[i].to);//一条边两个端点的父亲
		if(fu==fv)continue;//如果父亲相同，则已经联通，再连边就会成环
		fa[fu]=fv;//合并两点
		adde(eg[i].next,eg[i].to,eg[i].w);//加边
		adde(eg[i].to,eg[i].next,eg[i].w);
	}
}

void dfs(int u,int fa)//dfs预处理异或和
{
	for(register int i=head[u];i;i=e[i].next)//遍历子节点
	{
		int v=e[i].to;
		if(v==fa)continue;//父亲则跳过
		s[v]=s[u]^e[i].w;//s[i]表示i到根节点的距离
		dfs(v,u);//继续深搜
	}
}

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(register int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		eg[i]=(edge){u,v,w};//先暂时存一下边
	}
	Produce();//求生成树
	dfs(1,0);//预处理
	while(q--)
	{
		int x,y;
		scanf("%d%d",&x,&y);//读入x,y
		printf("%d\n",s[x]^s[y]);//s[x]和s[y]异或时，lca(x,y)及以上的部分就抵消掉了，只留下最短路上的点
	}
	return 0;//结束了罪恶的一生
}
```
求资瓷qwq

---

## 作者：月离 (赞：37)

#### bfs~~简单~~题

因为题目说

>保证GG中不存在简单环使得边权异或和不为0。

所以对于一个简单环

![](https://cdn.luogu.com.cn/upload/image_hosting/0rr2d4b1.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0sz8cx5u.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/qlc7oqu0.png)

所以我们可以忽略图中的环，跑bfs来查询异或和

当然，跑q遍bfs必然超时，这里需要另引入一个性质

如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/oy0rm8xc.png)

其中

$dis[s] = w1 \oplus w2 $

$dis[e] = w1 \oplus w2 \oplus w3 \oplus w7$

那么可以推出

$dis[s] \oplus dis[e] = w1 \oplus w1 \oplus w2 \oplus w2 \oplus w3 \oplus w7$

$dis[s] \oplus dis[e] = 0 \oplus 0 \oplus w3 \oplus w7$

这里的$dis[s] \oplus dis[e]$也就是我们要求的s到e的最大异或和

所以我们只需要一遍bfs吧所有的dis求出来就能推出q组答案

感谢@Blue_wonders 提供的latex %%%

完整代码：


```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
using namespace std;
int n,m,q;
int cnt;
int dis[400010];
bool vis[400010];
int head[400010];
struct edge{
    int v,w,nex;
}e[400010];
inline void addedge(int u,int v,int w){
    ++cnt;
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].nex=head[u];
    head[u]=cnt;
}
inline void bfs(int s){//平平无奇的bfs
    queue<int>q;
    for(re int i=1;i<=n;i++){
        dis[i]=0;
        vis[i]=0;
    }
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        if(vis[u]==1)continue;
        vis[u]=1;
        for(re int i=head[u];i;i=e[i].nex){
            int v=e[i].v;
            int w=e[i].w;
            if(!vis[v]){
                dis[v]=dis[u] xor w;
                q.push(v);
            }
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&q);
    for(re int i=1;i<=m;i++){
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        addedge(u,v,w);
        addedge(v,u,w);
    }
    bfs(1);//bfs预处理出dis来
    for(re int i=1;i<=q;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        printf("%d\n",dis[v] xor dis[u]);//见上面的性质
    }
    return 0;
}
```


---

## 作者：大头 (赞：30)

考虑性质：图上不存在xor不为0的环。

这说明，我们可以给每个点一个点权$a_x$，满足对于图上所有的边$(x,y)$,$v_{x,y}=a_x\ xor\ a_y$。

我们考虑一条简单路径的权值，设其经过节点为$p_1,p_2,\cdots,p_n$，则权值为$a_{p_1}\ xor\ a_{p_2}\ xor\ a_{p_2}\ xor\ a_{p_3}\ xor\ \cdots\ xor\ a_{p_n}$。

因为一个数字加入异或和两次对答案不会贡献，也就是说答案为$a_{p_1}\ xor\ a_{p_n}$。

因此，路径权值和经过路径的方案无关，均为$a_{p_1}\ xor\ a_{p_n}$,直接输出即可。

权值的构造可以直接指定$a_1=0$，其余使用dfs依次推导。

时间复杂度$O(n+m+Q)$

code:
```cpp#include<bits/stdc++.h>
#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)
#define ll long long
using namespace std;
const int N=100005;
struct edge{
	int to,next,v;
}e[N*4];
int head[N],tot,n,m,Q;
int vis[N],val[N];
void add(int x,int y,int v){
	e[++tot]=(edge){y,head[x],v};
	head[x]=tot;
}
void dfs(int x){
	vis[x]=1;
	for (int i=head[x];i;i=e[i].next)
		if (!vis[e[i].to]){
			val[e[i].to]=val[x]^e[i].v;
			dfs(e[i].to);
		}
}
int main(){
	scanf("%d%d%d",&n,&m,&Q);
	For(i,1,m){
		int x,y,v;
		scanf("%d%d%d",&x,&y,&v);
		add(x,y,v); add(y,x,v);
	}
	dfs(1);
	while (Q--){
		int x,y;
		scanf("%d%d",&x,&y);
		printf("%d\n",val[x]^val[y]);
	}
}


```

---

## 作者：爷，无限霸气 (赞：24)

## 既然是最短路练习题

那么肯定第一个想到的是最短路啦！

# 40分思路：

在dij的基础上异或，每次更新都dij一遍，可以过40分

代码:

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn 1000005
#define next Next
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
priority_queue< pair<ll,ll> >h;
ll tot,n,m,q,ver[Maxn],head[Maxn],edge[Maxn],next[Maxn],d[Maxn],v[Maxn];
void add(ll x,ll y,ll z)
{
	ver[++tot]=y;
	next[tot]=head[x];
	head[x]=tot;
	edge[tot]=z;
}
void dijkstra(ll s)
{
	memset(d,0x7f,sizeof(d));
	memset(v,0,sizeof(v));
	d[s]=0;
	h.push(make_pair(0,s));
	while(h.size())
	{
		ll x=h.top().second;
		h.pop();
		if(v[x]) continue;
		v[x]=1;
		for(int i=head[x];i;i=next[i])
		{
			ll y=ver[i],z=edge[i];
			if(d[y]>d[x]^z)
			{
				d[y]=d[x]^z;
				h.push(make_pair(-d[y],y));
			}
		}
	}
}
int main()
{
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++)
	{
		ll x=read(),y=read(),z=read();
		add(x,y,z);

		add(y,x,z);

	}
	for(int i=1;i<=q;i++)
	{
		ll x=read(),y=read();
		dijkstra(x);

		cout<<d[y]<<endl;
	}
	return 0;
}
```


# 80分思路

我们考虑到不需每次都dij，发现一条路上的异或和只要以1为起点跑的最短路，每次询问d[x]^d[y]即可

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn 1000005
#define next Next
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
priority_queue< pair<ll,ll> >h;
ll cnt,tot,n,m,q,ver[Maxn],head[Maxn],edge[Maxn],next[Maxn],d[Maxn],v[Maxn];
void add(ll x,ll y,ll z)
{
	ver[++tot]=y;
	next[tot]=head[x];
	head[x]=tot;
	edge[tot]=z;
}
void dijkstra(ll s)
{
	memset(d,0x7f,sizeof(d));
	memset(v,0,sizeof(v));
	d[s]=0;
	h.push(make_pair(0,s));
	while(h.size())
	{
		ll x=h.top().second;
//		cout<<x<<endl;
		h.pop();
		if(v[x]) continue;
		v[x]=1;
		for(int i=head[x];i;i=next[i])
		{
			ll y=ver[i],z=edge[i];
//			if(d[x]==1&&z==1) d[y]=0;
//			else if(d[x]==1&&z==0) d[y]=1;
//			else if(d[x]==0&&z==1) d[y]=1;
//			else if(d[x]==0&&z==0) d[y]=0;
//			cout<<y<<" "<<z<<" "<<d[y]<<" "<<d[x]<<" "<<z<<" "<<(d[x]^z)<<endl;
			if(d[y]>=d[x]^z)
			{
				d[y]=d[x]^z;
				h.push(make_pair(-d[y],y));
			}
		}
	}
}
int main()
{
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++)
	{
		ll x=read(),y=read(),z=read();
		add(x,y,z);
		add(y,x,z);
		if(z<=1) cnt++;
	}
	if(cnt==m)
	{
		for(int i=2;i<=tot;i+=2)
		{
			d[i]=edge[i];
//			cout<<edge[i]<<" ";
		}
		goto lyk;
	}
	dijkstra(1);
	lyk:;
//	for(int i=1;i<=n;i++) cout<<d[i]<<" ";
	for(int i=1;i<=q;i++)
	{
		ll x=read(),y=read();
//		cout<<d[x]<<" "<<d[y]<<endl;
		cout<<(d[x]^d[y])<<endl;
	}
	return 0;
}
/*
4 3 1
1 2 0
2 3 0
3 4 1
1 4
*/
```

# 100分思路

用80分思路提交，发现只会Wa了7，8两个点，发现7,8有特殊性质v<=1

考试的时候，调试代码发现怎么样他都进不去这-》

```
if(d[y]>d[x]^z)
```

所以我们特判一下当有这个特殊性质时必进此判断即可AC

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Maxn 1000005
#define next Next
using namespace std;
ll read()
{
	ll r=0,f=1;char c=getchar();
	while((c<'0'||c>'9')&&(c!='-')) c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();
	return r*f;
}
priority_queue< pair<ll,ll> >h;
ll cnt,tot,n,m,q,ver[Maxn],head[Maxn],edge[Maxn],next[Maxn],d[Maxn],v[Maxn];
void add(ll x,ll y,ll z)
{
	ver[++tot]=y;
	next[tot]=head[x];
	head[x]=tot;
	edge[tot]=z;
}
void dijkstra(ll s)
{
	memset(d,0x7f,sizeof(d));
	memset(v,0,sizeof(v));
	d[s]=0;
	h.push(make_pair(0,s));
	while(h.size())
	{
		ll x=h.top().second;
//		cout<<x<<endl;
		h.pop();
		if(v[x]) continue;
		v[x]=1;
		for(int i=head[x];i;i=next[i])
		{
			ll y=ver[i],z=edge[i];
//			if(d[x]==1&&z==1) d[y]=0;
//			else if(d[x]==1&&z==0) d[y]=1;
//			else if(d[x]==0&&z==1) d[y]=1;
//			else if(d[x]==0&&z==0) d[y]=0;
//			cout<<y<<" "<<z<<" "<<d[y]<<" "<<d[x]<<" "<<z<<" "<<(d[x]^z)<<endl;
			if(d[y]>=d[x]^z||cnt==m)
			{
				d[y]=d[x]^z;
				h.push(make_pair(-d[y],y));
			}
		}
	}
}
int main()
{
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++)
	{
		ll x=read(),y=read(),z=read();
		add(x,y,z);
		add(y,x,z);
		if(z<=1) cnt++;
	}
//	if(cnt==m)
//	{
//		d[1]=0;
//	
//		goto lyk;
//	}
	dijkstra(1);
//	for(int i=1;i<=n;i++) cout<<d[i]<<" ";
	for(int i=1;i<=q;i++)
	{
		ll x=read(),y=read();
//		cout<<d[x]<<" "<<d[y]<<endl;
		cout<<(d[x]^d[y])<<endl;
	}
	return 0;
}
/*
4 3 1
1 2 0
2 3 0
3 4 1
1 4
*/
```


---

## 作者：Inkyo (赞：21)

>这里是墨攸，平生没有什么爱好，就喜欢做B题

吐槽一些题解：这题哪里用得着求生成树啊...

- ## 思路

**重要性质：保证$G$中不存在简单环使得边权异或和不为$0$。**

根据异或的自反性（$a ~~xor~~ a=0$），我们发现，从一个点$u$抵达另一个点$v$，不管走那条路，它最后的贡献值都是一样的。所谓的最短路只是一个幌子，其实每两个点的距离就只有唯一解。（上面也有很多DALAO解释的很清楚了）

于是我们只需要求一个点与其他所有点的距离。我们假设求$1$号点与其他$n-1$个点的距离，分别计入$dis$数组中。那么$u$到$v$的距离显然是：$dis[u] ~~xor~~dis[v]$

OK，既然走哪条路都是一样的，构造生成树确实能够解决问题。因为生成树的两点之间仅有唯一路径。

那么问题来了：

## **为啥不用 记忆化的$dfs / bfs$呢？？？？？**

我们大可用 $bfs$ 或 $dfs$ 更新出未更新点的$dis$值。**假设这个点已经被更新过了，我们就不再去更新它了** （毕竟走哪条路都是一样的）。 这样，我们遍历整张图，同样每个点只进过了一次，比构造生成树再去跑$lca$要优多了。

一旦遍历了所有点，直接退出然后回答每个询问即可

时间复杂度 $O(n+m+Q)$ ，比带$log$优了很多。比求生成树的算法还要小一个量级的常数。

## $dfs$写法

```cpp
#pragma GCC optimize("Ofast,fast-math,unroll-loops")
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define orz 0
#define maxn 200005
using namespace std;

int n, m, p;
int dis[maxn], js;
int head[maxn], nxt[maxn << 1], to[maxn << 1], val[maxn << 1], cnt;
queue <int> q;

inline void add_edge(int u, int v, int w)
{
	nxt[++ cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
	val[cnt] = w;
}

inline void dfs(int x)
{
	if(js == n) return;
	for(int i = head[x]; i; i = nxt[i])
		if(dis[to[i]] == -1) 
		{
			++ js;
			dis[to[i]] = dis[x] ^ val[i];
			dfs(to[i]);
		}
}

int main()
{
	scanf("%d%d%d", &n, &m, &p);
	for(register int i = 1; i <= m; i ++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		add_edge(u, v, w); add_edge(v, u, w);
	}
	for(register int i = 1; i <= n; i ++) dis[i] = -1;
	dis[1] = 0;
	dfs(1);
	for(register int i = 1; i <= p; i ++)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		printf("%d\n", dis[x] ^ dis[y]);
	}
	
	return orz;
}
```

## $bfs$写法

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define orz 0
#define maxn 200005
using namespace std;

int n, m, p;
int dis[maxn];
int head[maxn], nxt[maxn << 1], to[maxn << 1], val[maxn << 1], cnt;
queue <int> q;

void add_edge(int u, int v, int w)
{
	nxt[++ cnt] = head[u];
	head[u] = cnt;
	to[cnt] = v;
	val[cnt] = w;
}

void bfs(int s)
{
	memset(dis, -1, sizeof(dis));
	dis[s] = 0;
	q.push(s);
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		for(int i = head[u]; i; i = nxt[i])
		{
			int v = to[i], w = val[i];
			if(dis[v] == -1)
			{
				dis[v] = dis[u] ^ w;
				q.push(v);
			}
		}
	}
}

int main()
{
	scanf("%d%d%d", &n, &m, &p);
	for(int i = 1; i <= m; i ++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		add_edge(u, v, w); add_edge(v, u, w);
	}
	bfs(1);
	for(int i = 1; i <= p; i ++)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		printf("%d\n", dis[x] ^ dis[y]);
	}
		
	return orz;
}
```

---

## 作者：xht (赞：11)

由于「保证 $G$ 中不存在简单环使得边权异或和不为 $0$」，因此随便找一条路径即可。

```cpp
const int N = 1e5 + 7;
int n, m, q, v[N], d[N];
vector< pi > e[N];

void dfs(int x) {
	v[x] = 1;
	for (ui i = 0; i < e[x].size(); i++) {
		int y = e[x][i].fi;
		if (v[y]) continue;
		d[y] = d[x] ^ e[x][i].se;
		dfs(y);
	}
}

int main() {
	rd(n), rd(m), rd(q);
	for (int i = 1, x, y, z; i <= m; i++) {
		rd(x), rd(y), rd(z);
		e[x].pb(mp(y, z)), e[y].pb(mp(x, z));
	}
	dfs(1);
	for (int i = 1, x, y; i <= q; i++) {
		rd(x), rd(y);
		print(d[x] ^ d[y]);
	}
	return 0;
}
```

---

## 作者：Meatherm (赞：7)

Update：一开始交错了交到了 T1，现在改过来。

---

一开始看到这个题是毫无头绪的。

直到发现了一句话：

> 保证 $G$ 中不存在简单环使得边权异或和不为 $0$。

于是就有了如下做法。

----

我们求出原图的任意一棵生成树，可以证明这棵生成树上任意两点 $(x,y)$ 之间的路径权值异或和最小。

证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/m37ahxgk.png)

观察这张图。如果在生成树上 $x$ 到 $y$ 的路径都是 $x \to z \to y$，而红色边是不在生成树上的一条边。设 $x \to z $ 的权值为 $a$，$z\to y$ 的权值是 $b$，$x \to y$ 的权值是 $c$。

观察到这三条边构成了一个简单环。根据题目描述，任意简单环的权值异或和都是 $0$。那么一定有 $a$ $\text{xor}$ $b=c$，这样这个简单环的权值异或和才是 $0$。

所以对于红色的边，它对答案没有任何影响！

于是求出任意一棵生成树即可。

求出生成树后，以任意一个节点为根，从根节点开始遍历，记根节点到点 $x$ 的路径的权值异或和为 $dis[x]$。

对于每个询问，起点和终点分别是 $x,y$。那么 $x$ 到 $y$ 的路径的权值异或和为 $dis[x]$ $\text{xor}$ $dis[y]$。

这也是一个很巧妙的做法呢！

下面证明一下这个做法的正确性。

![](https://cdn.luogu.com.cn/upload/image_hosting/rhmva2az.png)

如上图，因为根节点到 $\text{LCA}(x,y)$ 的路径权值异或和被统计了两次，根据异或的性质（一个数连续异或两次同一个数等于原数） ，$dis[x]$ $\text{xor}$ $dis[y]$ 会将这一部分抵消掉，所以最后得到的结果就是 $x$ 到 $y$ 的路径权值异或和。

所以这道题真的是非常随意呢~

```cpp
//提前声明：因为这个程序是打部分分的时候想出来的，所以有一些无用的变量和函数
# include <bits/stdc++.h>
# define rr register
const int N=100010;
struct Edge{
	int to,next,v;
}edge[N<<1];
struct Node{
	int u,v,w;
}Aedge[N<<1];
int head[N],sum;
int n,m,Q;
int dis[N];
bool inque[N];
int f[N];
inline int read(void){
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')
		res=res*10+c-48;
	return res*f;		
}
void print(int x){
	if(x<0)
		putchar('-'),x=-x;
	if(x>9)
		print(x/10);
	putchar(x%10+'0');
	return;		
}
inline void add(int x,int y,int w){
	edge[++sum].to=y;
	edge[sum].next=head[x];
	edge[sum].v=w;
	head[x]=sum;
	return;
}
void dfs(int i,int fa){
	for(rr int j=head[i];j;j=edge[j].next){
		if(edge[j].to==fa)
			continue;
		dis[edge[j].to]=dis[i]^edge[j].v;
		dfs(edge[j].to,i);
	}
	return;
}
int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}
inline void solve_tree(void){
	for(rr int i=1,x,y,w;i<=m;++i){
		Aedge[i].u=read(),Aedge[i].v=read(),Aedge[i].w=read();
	}
	for(rr int i=1;i<=n;++i)
		f[i]=i;
	int cnt=0;	
	for(rr int i=1;i<=m;++i){
		if(find(Aedge[i].u)!=find(Aedge[i].v))
			f[find(Aedge[i].u)]=find(Aedge[i].v),add(Aedge[i].u,Aedge[i].v,Aedge[i].w),add(Aedge[i].v,Aedge[i].u,Aedge[i].w),++cnt;
		if(cnt==n-1)
			break;
	}
	dfs(1,0);
	int x,y;
	while(Q--){
		x=read(),y=read();
		print(dis[x]^dis[y]);
		putchar('\n');
	}
}
int main(void){
	n=read(),m=read(),Q=read();
	solve_tree();
	return 0;
}
```

---

## 作者：Rainbow_qwq (赞：7)

[P5651 【基础最短路练习题】](https://www.luogu.org/problem/P5651)

---

# 思路

作为比赛题，我们应该观察数据范围，分段骗分。

1.$n\leq 20$部分。

可以直接$\text{Floyd}$ , $O(n^3)$求出所有点对最短路。

但是由于是异或最短路，还是要做一些变化。

转移时，如果$f[i][k]$或$f[k][j]$都是极大值，那就不能到达，就不转移。

期望得分：$\text{40 pts}$

代码：

```cpp
#define rev (1<<30)//置为一个极大值
int n,m,Q;
int f[505][505];
namespace force{
	void solve()
	{
		For(i,1,n)
			For(j,1,n)
				f[i][j]=rev;
		For(i,1,m){
			int u=read(),v=read(),w=read();
			f[u][v]=f[v][u]=w;
		}
      //Floyd求出所有点对距离
		For(k,1,n)
			For(i,1,n)
				For(j,1,n)
				{
					if(f[i][k]==rev||f[k][j]==rev)continue;//不转移
					f[i][j]=min(f[i][j],f[i][k]^f[k][j]);
				}
			
		while(Q--)
		{
			int u=read(),v=read();
			printf("%d\n",f[u][v]);
		}
	}
}
```
2.特殊性质 m=n−1 部分

m=n−1 就是一棵树。

树上点对路径只有一条，就直接以$1$为根$\text{dfs}$一遍，求出$dis[i]$表示$u\rightarrow 1$路径的异或值。

对于每个询问输出$dis[u] \ \text{xor}\ dis[v]$即可。

顺便水掉[让我们异或吧](https://www.luogu.org/problem/P2420)

期望得分：$\text{60 pts}$

代码：
```cpp
int n,m,Q;
struct edge{
	int to,nxt,w;
}e[200007];
int tot,head[100007];
inline void adde(int u,int v,int w){
	e[++tot]=(edge){v,head[u],w};
	head[u]=tot;
}
int dis[100007];
void dfs(int u,int fa)//dfs求出dis[i]
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa)continue;
		dis[v]=dis[u]^e[i].w;//v->1的距离=u->1的距离 异或 边权
		dfs(v,u);
	}
}
namespace tree{
	void solve()
	{
		For(i,1,m){
			int u=read(),v=read(),w=read();
			adde(u,v,w);adde(v,u,w);
		}
		dfs(1,0);
		while(Q--)
		{
			int u=read(),v=read();
			printf("%d\n",dis[u]^dis[v]);
		}
	}
}
```
3. 正解

发现题目中有这样一句话：

> 保证$G$中不存在简单环使得边权异或和不为$0$。

放张图

![](https://cdn.luogu.com.cn/upload/image_hosting/p3b9w22p.png)

其中$\text{3 xor 7 xor 2 xor 4 xor 2}=0$,符合

此时$1\rightarrow 5$长度为$2$，$1\rightarrow 2\rightarrow 3\rightarrow 4\rightarrow 5$长度为$\text{3 xor 7 xor 2 xor 4}=2$

我们发现，环上两个方向走，路径长度相同！！

也就是说，把$1\rightarrow 5$这条边断掉，也能从另一方向走，对结果毫无影响。

证明：设环上$x\rightarrow y$从一个方向走异或值为$a$，从另一个方向走异或值为$b$，那$\text{a xor b}=$简单边权异或和$=0$。

所以$a=b$

那就在每个环上断一条边。环没了，图就变成树了，可以直接用上文方法解决。

使用$\text{Kruskal}$的思想，如果$2$个点在一个联通块中，再加边会形成环，就不加边。

直接在原图上跑生成树，然后用上文对树的解决方法。

代码，在$\text{Kruskal}$生成树部分做了注释。
```cpp
int n,m,Q;
struct edge{
	int to,nxt,w;
}e[200007];
int tot,head[100007];
inline void adde(int u,int v,int w){
	e[++tot]=(edge){v,head[u],w};
	head[u]=tot;
}
int dis[100007];
void dfs(int u,int fa)//dfs求出dis[i]
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa)continue;
		dis[v]=dis[u]^e[i].w;//v->1的距离=u->1的距离 异或 边权
		dfs(v,u);
	}
}
namespace qwq{
	int fa[100005];//维护并查集
	int getf(int x){
		if(x==fa[x])return fa[x];
		return fa[x]=getf(fa[x]);
	}
	void solve()
	{
		For(i,1,n)fa[i]=i;//并查集初始化
		For(i,1,m){
			int u=read(),v=read(),w=read();
			int fu=getf(u),fv=getf(v);
			if(fu==fv)continue;//Kruskal的思想，如果2个点在一个联通块中，再加边会形成环，就不加边
			fa[fu]=fv;//加边，并合并成一个联通块。
			adde(u,v,w);adde(v,u,w);
		}
		dfs(1,0);
		while(Q--)
		{
			int u=read(),v=read();
			printf("%d\n",dis[u]^dis[v]);
		}
	}
}
```
最后放一个完整代码做参考。主函数做了分类讨论。
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
#define rev (1<<30)
int n,m,Q;
int f[505][505];
struct edge{
	int to,nxt,w;
}e[200007];
int tot,head[100007];
inline void adde(int u,int v,int w){
	e[++tot]=(edge){v,head[u],w};
	head[u]=tot;
}
int dis[100007];
void dfs(int u,int fa)
{
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa)continue;
		dis[v]=dis[u]^e[i].w;
		dfs(v,u);
	}
}
namespace force{
	void solve()
	{
		For(i,1,n)
			For(j,1,n)
				f[i][j]=rev;
		For(i,1,m){
			int u=read(),v=read(),w=read();
			f[u][v]=f[v][u]=w;
		}
		For(k,1,n)
			For(i,1,n)
				For(j,1,n)
				{
					if(f[i][k]==rev||f[k][j]==rev)continue;
					f[i][j]=min(f[i][j],f[i][k]^f[k][j]);
				}
			
		while(Q--)
		{
			int u=read(),v=read();
			printf("%d\n",f[u][v]);
		}
	}
}
namespace tree{
	void solve()
	{
		For(i,1,m){
			int u=read(),v=read(),w=read();
			adde(u,v,w);adde(v,u,w);
		}
		dfs(1,0);
		while(Q--)
		{
			int u=read(),v=read();
			printf("%d\n",dis[u]^dis[v]);
		}
	}
}
namespace qwq{
	int fa[100005];
	int getf(int x){
		if(x==fa[x])return fa[x];
		return fa[x]=getf(fa[x]);
	}
	void solve()
	{
		For(i,1,n)fa[i]=i;
		For(i,1,m){
			int u=read(),v=read(),w=read();
			int fu=getf(u),fv=getf(v);
			if(fu==fv)continue;
			fa[fu]=fv;
			adde(u,v,w);adde(v,u,w);
		}
		dfs(1,0);
		while(Q--)
		{
			int u=read(),v=read();
			printf("%d\n",dis[u]^dis[v]);
		}
	}
}
int main()
{
	n=read(),m=read(),Q=read();
	if(n<=500)force::solve();//n小，暴力Floyd
	else if(m==n-1)tree::solve();//树形
	else qwq::solve();
    return 0;
}
```

---

## 作者：封禁用户 (赞：6)

#### 前置知识：

#### 异或 ： 
>两个二进制数如果相同位置的数相同则它们的异或值的那一位为 $0$ ， 反之则为 $1$ ， 符号就是 “ ^ ” 或 “ $xor$ ”；

#### 异或和：
>$a$ , $b$ , $c$ 的异或和就是 $a$ ^ $b$ ^ $c$ ；

------------

#### 首先我们先分析一波题意：

1.保证G中不存在简单环使得边权异或和不为0。

这个是说在图中如果有环的话这个环的

### 异或和的值是 $0$

这个信息非常重要，它告诉了我们 :

#### 这个图上的任意两个点之间的的异或和是唯一的！！！

证明：

设 $x$ 和 $y$ 分别为图上某一环上的两点；

设 $x$ 到 $y$ 之间的两条路的边权的异或和分别为 $a$ 和 $b$ ；

由题意得：$a$ ^ $b$ = $0$；

∴ $a$ = $b$ ；

### 然后我们就可以非常愉快的搜索去求他询问的两个点之间的边权异或和辣！

~~然而一定会T~~

------------

接下来我们开始思考该如何优化才能加快它的效率

#### 我们这个时候就可以设一个中间点来求两点之间的之间的异或和

我们设点 $a$ 到点 $b$ 的异或和为 $x$ ；

然后我们再设点 $c$ 到点 $b$ 的异或和为 $y$ ;

很容易看出：

#### $c$ 到 $a$ 的异或和其实就是 $x$ ^ $y$ ；

这样我们就可以先求一遍任意一点到其他点的异或和（$dis$），然后在询问时输出起点的 $dis$ 值异或一下终点的 $dis$ 值就好了；

------------

## 下面上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
#define in inline
#define inf 1000000000 
using namespace std;
in int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int n,m,q,tot=0;
int dis[400001],nx[400001];
bool vis[400001];
struct edge{int v,w,next;}e[400001];
in void addline(int u,int v,int w){
	e[++tot].v=v; e[tot].w=w;e[tot].next=nx[u]; nx[u]=tot;
}
in void bfs(int s){
	queue<int>q;
	memset(dis,0,sizeof(dis));
	memset(vis,0,sizeof(vis));
	q.push(s);
	while(!q.empty()){
		int u=q.front(); q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(re int i=nx[u];i;i=e[i].next){
			int v=e[i].v,w=e[i].w;
			if(!vis[v]){q.push(v); dis[v]=dis[u]^w;}
		}
				
	}
}
int main(){
	n=read(); m=read(); q=read();
	for(re int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		addline(u,v,w); addline(v,u,w);
	}
	bfs(1);
	for(re int i=1;i<=q;i++){
		int x=read(),y=read();
		int ans=dis[x]^dis[y];
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：Priori_Incantatem (赞：6)

~~感觉像神仙结论题~~

这题思路有些难想，但想出来后代码还是很好写的

与普通最短路不一样的是，这里最短路的距离求的是异或和，而这里的关键就是异或的重要性质：逆反性

首先，随便选一个点$s$当起点，跑一边最短路，求出dis数组，$dis[x]$表示点$x$到起点的最短路长度。  
当询问点$x$到点$y$的最短路时，分两种情况：

1. 点$x$到点$y$的最短路径经过点$s$，那$x$到$y$的最短路就是`dis[x]^dis[y]`

2. 点$x$到点$y$的最短路径不经过点$s$，如下图:  
![image.png](https://i.loli.net/2019/11/13/mh2dtQPuaHJS3vY.png)

$x$到$y$的最短路为$c$，$dis[x]=a$的话，可证明出`dis[y]=a ^ c`，而这样的话`dis[x] ^ dis[y] = a ^ c ^ a = c`  
所以，点$x$到点$y$的最短路还是`dis[x]^dis[y]`

推出了这个，那下面的代码就很好写啦

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
const int Maxn=100000+20,inf=0x3f3f3f3f;
struct edge{
	int v,len;
};
struct node{
	int pos,dis;
	bool operator <(const node &x)const
	{
		return x.dis<dis;
	}
};
vector <edge> e[Maxn];  //vector 存图，大佬勿喷
int dis[Maxn],n,m,k;
bool vis[Maxn];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
void dijkstra()
{
	priority_queue <node> q;
	fill(dis+2,dis+1+n,inf);
	dis[1]=0,vis[1]=1;
	q.push(node{1,0});
	while(!q.empty())
	{
		int x=q.top().pos;
		q.pop();
		for(int i=0;i<e[x].size();++i)
		{
			int y=e[x][i].v;
			if(dis[y]>(int)(dis[x] ^ e[x][i].len));
			{
				dis[y]=(int)(dis[x] ^ e[x][i].len);
				if(!vis[y]){vis[y]=1;q.push(node{y,dis[y]});}
			}
		}
	}
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;++i)
	{
		int x=read(),y=read(),c=read();
		e[x].push_back(edge{y,c});
		e[y].push_back(edge{x,c});
	}
	dijkstra();
	for(int i=1;i<=k;++i)
	{
		int x=read(),y=read();
		int ret=int(dis[x] ^ dis[y]);
		printf("%d\n",ret);
	}
	return 0;
}
```

---

## 作者：saxiy (赞：4)

最短路 $\times$ ， 树上差分 $\sqrt{}$ 。。

#### 题目分析：

比赛的时候这个 "最短路" 卡了我好久。。后来才看到

> 保证 $G$ 中不存在简单环使得边权异或和不为 $0$

这句话可以说是解题的关键吧，考虑所有 $x$ 到 $y$ 的路径，两两不同的路径会构成一个环（或一部分重叠，一部分构成一个或多个环），而题目保证所有简单环异或为 $0$ ，即所有 $x$ 到 $y$ 的路径两两异或都等于 $0$ ，一个数什么时候会与另一个数异或为 $0$ 呢？那就是这个数自己。

所以，所有 $x$ 到 $y$ 的路径距离（指异或和）相等，否则会出现存在异或和不为 $0$ 的环，那么只需存 $x$ 到 $y$ 的 **一条** 路径即可，任意一棵生成树就能存下所有必要的路径。

现在再考虑求一棵树上两点路径异或和（也是 #$5$,#$6$ $\text{subtask}$），依靠异或的自反性，可以记录根节点（随意指定）到 $i$ 的路径异或和 $val_i$ ，这样异或 $val_x$ 和 $val_y$ 后不属于 $x$ 到 $y$ 的路径的边权就会相互抵消，直接得到答案。

当然也可以用 $\text{LCA}$ 做（倍增，树剖等），但时间复杂度就劣于差分 $O(n+m)-O(1)$ 。

#### 代码实现：

卡了一手常 ~~，阅读应该不会感到不适吧。。。~~

```cpp
#pragma GCC optimize("Ofast,fast-math,unroll-loops")
#include <bits/stdc++.h>
#define RS register
#define N 100005
using namespace std;

int n, m, q, dep[N], bcj[N], val[N];
int head[N], to[N << 1], nxt[N << 1], len[N << 1], cnt = 2;

//生成树的并查集
int fa(int x) { return x == bcj[x] ? x : bcj[x] = fa(bcj[x]); }
inline void un(int a, int b) {//按秩合并
	a = fa(a); b = fa(b);
	if(dep[a] <= dep[b]) {
		bcj[a] = b;
		if(dep[a] == dep[b]) dep[b]++;
	} else bcj[b] = a;
}
inline bool isin(int a, int b) { return fa(a) == fa(b); }

void addedge(int u, int v, int l) {
	to[cnt] = v;
	len[cnt] = l;
	nxt[cnt] = head[u];
	head[u] = cnt++;
}

void dfs(int p, int fa) {
	for(RS int i = head[p];i;i = nxt[i])
		if(to[i] != fa) {
			val[to[i]] = val[p] ^ len[i];
			dfs(to[i], p);
		}
}

int main() {
	read(n); read(m); read(q);//快读
	for(RS int i = 1;i <= n;i++) bcj[i] = i;
	RS int a, b, l;
	for(RS int i = 0;i < m;i++) {
		read(a); read(b); read(l);
		if(isin(a, b)) continue;//生成树
		addedge(a, b, l);
		addedge(b, a, l);
		un(a, b);
	}
	dfs(1, 0);
	while(q--) {
		read(a); read(b);
		printf("%d\n", val[a] ^ val[b]);
	}
	return 0;
}
```

---

## 作者：云殊呀 (赞：4)

如果这就是CSP S D1 T2，那么~~俩速度就发了设计大赛~~

	做这个题还是想了一会的，毕竟水得一*：
	1.因为有10W个点，所以只能存链表。
	2.因为一个数异或上另一个可能会变小，所以可以认为存在负权边。
	3.所有的环的异或和为0，也就是说最短路上的环不会影响路径长度。
	4.x~y的最短路径等于1~x异或上1~y，为什么？因为是连通图，如果在x和y在1的同一条分支上，则公共路径异或两次等于没异或；如果不在一条分支上，那么异或的先后顺序不会改变最后结果。
	综上所述，用spfa可过，要注意的是输入的第一条边可能不是1，0异或一个数可能不是原数。我的代码有点丑，请见谅。
    最后吐个槽，如果这就是D1T1，那祝我爆0退役！
```
#include<iostream>
#include<queue>
#include<string.h>
#include<stdio.h>
using namespace std;
#define ll long long
const ll maxn=400004,inf=0x7ffffffffff;
struct node{
       ll y,w,next;
}e[maxn];
ll h[maxn],w[maxn],x[maxn],y[maxn],d[maxn];
ll visit[maxn];
ll n,m,p=0,qq;//p为边的数量
ll first,ans;
queue<ll>q;
void init(ll x,ll y,ll w){//x是父节点
    e[++p].y=y;
    e[p].w=w;
    e[p].next=h[x];//指向上一条边
    h[x]=p;//h[]记录x的被记录的最后一条边是第几条
}
void spfa(){
      ll i,x,y;
      d[first]=0;
      visit[first]=1;
      for(i=1;i<=n;i++){
      	if(i==first)continue;
         d[i]=inf;
         visit[i]=0;
      }
      for(i=h[first];i;i=e[i].next){//我不知道是否多余，我觉得如果直接与d[first]异或可能会错
      	d[e[i].y]=e[i].w;//所以与first直接相连的赋值为边权
      	q.push(e[i].y);
      	visit[e[i].y]=1;
	  }
      while(!q.empty()){
         x=q.front();
         q.pop();
         for(i=h[x];i;i=e[i].next){
            y=e[i].y;
            if((e[i].w^d[x])<d[y]){
              d[y]=e[i].w^d[x];
              if(!visit[y]){
                visit[y]=1;
                q.push(y);
              }
              }
            }
         }
      
 }
          
int main(){
    ll t,i,j,l,r;
    scanf("%lld%lld%lld",&n,&m,&qq);
    memset(h,0,sizeof(h));
    for(i=0;i<m;i++){
    	scanf("%lld%lld%lld",&x[i],&y[i],&w[i]);
    	if(i==0 )first = x[i];
       	init(x[i],y[i],w[i]);
       	init(y[i],x[i],w[i]);//无向图一条边相当于两条有向边
    }
    p=0;
    spfa();
    for(i=0;i<qq;i++){
    	scanf("%lld%lld",&l,&r);
    	if(l==first)printf("%lld\n",d[r]);
    	else if(r==first)printf("%lld\n",d[l]);
//这个if我也不确定是否多余，想得很乱    	
  if(l!=first&&r!=first)printf("%lld\n",d[l]^d[r]);
	}
    return 0;  
}
/*
5 5 123
1 2 4
2 4 2
1 3 0
4 3 1
1 5 0
1 3

6 6 12
1 2 2
2 3 3
3 4 4
4 5 5
5 2 6
2 6 7
1 6
*/
```


---

## 作者：E17bits (赞：3)

upd：2019/11/14 更改了一些内容，感谢[@Mr_H](https://www.luogu.org/user/179868) 大佬的指正

这是一道求多对点间路径上所有的边权异或和的题目。

我们先来看看数据，毕竟面向数据编程也是一种很好的习惯。

1, 2, 3, 4 $n,q<=20$

5, 6 $m=n-1$

7, 8 $v<=1$

100% $n, q<=10^5$

~~孔老先生有言：萝莉是人类进步的阶梯,~~ 所以我们分步来~~骗~~得分
## 思路一：floyd，40pts
观察到$n$居然只有不到100！？！？！？

那么使用最为简单粗暴的floyd即可通过，时间复杂度为$O(n^3)$

代码：

```cpp
#include <bits/stdc++.h>
#include "getvar.h"//自己写的快读头文件
#define N 200005
#define rep(i,n) for(register int i=1; i<=n; i=-~i)
using namespace std;
int n, m, q;
int main() {
	cin>>n>>m>>q;
	if(n<=400) {//1, 2, 3, 4，你懂我意思吧~
		int f[405][405];
		rep(i, 402)
			rep(j, 402)
				f[i][j]=INT_MAX;//赋初值
		rep(i, m) {
			int u=read(), v=read(), w=read();
			f[u][v]=f[v][u]=w;
		}
		rep(k, n)
			rep(i, n)
				rep(j, n)
					if(f[i][k]!=INT_MAX && f[k][j]!=INT_MAX) //避免异或和变成0
						f[i][j]=min(f[i][j], f[i][k]^f[k][j]); //floyd
		rep(i, q) {
			int u=read(), v=read();
			cout<<f[u][v]<<endl;
		}
	}
}

```

40pts，搞定！！！
## 思路二：DFS，60pts
此时$n$比较大了，我们不可能用floyd或每次都跑一遍最短路，显然需要$O(1)$回答。

接着看到了$m=n-1$ ！？

这句话的意思是，**给出的图是棵树**。

有什么用呢？

请看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/05v26kpt.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**其中，红色代表节点编号，蓝色代表边权。**

例如我们要求4到5路径上的所有边权的异或和，答案是 19^1=18。

那么怎么求它的路径呢？

~~锵锵，树链剖分登场！~~

这题不用树剖的！

异或有个性质：

a ^ a = 0

a ^ 0 = a

比如我们求4到5的路径：19 ^ 1

可以写成：19 ^ 510 ^ 1 ^510

我倒！？

因为510 ^ 510 = 0，而 19 ^ 1 ^ 0 = 19 ^ 1

也就是说，$u$点和$v$点间的路径异或和 就是 $u$点到根节点的路径异或和 和 $v$点到根节点的路径异或和 的路径异或和！！！~~（好奇怪的描述）~~

说白了，**想象两条线段摆在同一直线上， 其中重合的部分消掉了，剩下的就是要求的东西。**

于是答案出来了。我们DFS求出根节点到每个节点i的路径异或和$dis[i]$，询问$u$，$v$时直接输出$dis[u]$ ＾ $dis[v]$ 就好了。

不知道根是什么，就设1为根 ~~（反正在树上可以乱搞嘛！）~~

其实就是这道题的~~代码~~方法：[P2420 让我们异或吧](https://www.luogu.org/problem/P2420)

代码:

```cpp

#include <bits/stdc++.h>
#include "getvar.h"
#define N 200005
#define rep(i,n) for(register int i=1; i<=n; i=-~i)
using namespace std;

int n, m, q, cnt;
int hd[N];
int to[N<<1], nxt[N<<1], val[N<<1];

int dis[N], ccnt;//5, 6

void add1(int u, int v, int w) {
	to[++cnt]=v;
	nxt[cnt]=hd[u];
	val[cnt]=w;
	hd[u]=cnt;
}

void dfs(int x, int fa) {
	for(int i=hd[x]; i; i=nxt[i]) {
		int go=to[i];
		if(go==fa) continue;
		dis[go]=dis[x]^val[i];
		dfs(go, x);
	}
}

int main() {
	cin>>n>>m>>q;
	if(n<=400) {//1, 2, 3, 4
		...
	}
	else
	if(m==n-1) {//5, 6
		rep(i, m) {
			int u=read(), v=read(), w=read();
			add1(u, v, w);
			add1(v, u, w);
		}
		dfs(1, 0);
		rep(i, q) {
			int u=read(), v=read();
			cout<<(dis[u]^dis[v])<<endl;
		}
	}
	return 0;
}

```


## 思路三：SPFA，100pts

现在是一张图了，DFS显然会爆炸。

注意到 **“保证$G$中不存在简单环使得边权异或和不为$0$”**，
所以，我们引用一下@Mr_H 大佬的话：

> 因为题目说 不存在简单环 使得边权异或和不为0，就是说 环的异或和一定为0，有环就说明 有两个路径可以到达一点，又因为 环的异或和一定为0，所以 两条路径异或和相等，因此跟选哪一条路径无关，只需到达即可，这就是为什么SPFA可以乱搞AC，我想DIJ好像也可以 

于是SPFA闪亮登场！！！

~~（SPFA：劳资没死！！！）~~

使用SPFA搞了一搞，获得所有点到$1$号点的$dis$，像思路二一样输出就好了！

~~（然后爆了）~~

在赋初值时：
```cpp
memset(dis, -1, sizeof(dis));
```
为什么要赋为-1？请看松弛操作中的细节：
```cpp
int go=to[i];
if(dis[go]==-1 || dis[go]>(dis[x]^val[i])) { // 注意运算符优先级！
	dis[go]=dis[x]^val[i];
```
这样就可以避免某种奇怪的错误（输出某个神奇的数），请读者自行思考。

然后就没有了。

代码：

```cpp
#include <bits/stdc++.h>
#include "getvar.h"
#define N 200005
#define rep(i,n) for(register int i=1; i<=n; i=-~i)
using namespace std;

int n, m, q, cnt;
int hd[N], dis[N], vis[N];
int to[N<<1], nxt[N<<1], val[N<<1];

void add1(int u, int v, int w) {
	to[++cnt]=v;
	nxt[cnt]=hd[u];
	val[cnt]=w;
	hd[u]=cnt;
}

void spfa(int o) {
	queue<int> q;
	memset(dis, -1, sizeof(dis));
	vis[o]=1;
	dis[o]=0;
	q.push(o);
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=hd[x]; i; i=nxt[i]) {
			int go=to[i];
			if(dis[go]==-1 || dis[go]>dis[x]+val[i]) {
				dis[go]=dis[x]^val[i];
				if(!vis[go]) {
					vis[go]=1;
					q.push(go);
				}
			}
		}
	}
}

int main() {
	cin>>n>>m>>q;
	rep(i, m) {
		int u=read(), v=read(), w=read();
		add1(u, v, w);
		add1(v, u, w);
	}
	spfa(1);
	rep(i, q) {
		int u=read(), v=read();
		cout<<(dis[u]^dis[v])<<endl;
	}
	return 0;
}
完了。
```
那么，这就是我CSP前最后一篇题解了（准确来说可能是OI路上最后一篇了，~~虽然我也没写多少~~），最后祝大家CSP2019 rp++！！！

---

## 作者：寒鸽儿 (赞：3)

考虑无环的情况,即一棵树:  
两点路径唯一。我们直接用一遍dfs保存结点到根的xor和,记为$S$。然后两个结点$u,v$的xor和即为$S_u \space xor \space S_v$。(根据异或的自反性lca到根节点的部分会被消掉)  
这一部分等价于这一道题[P2420让我们异或吧](https://www.luogu.org/problem/P2420)  
然后考虑有环,其实就是在树上添加一些边。考虑两个环上的结点$u,v$，它们在树上的xor路径和为$S_u \space xor \space s_v$,考虑到xor的自反性,环上剩下的边构成的路径的xor和也为$S_u \space xor \space S_v$  
因此对于任意一棵dfs树答案都是成立的  
复杂度$O(n+m)$  
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 100010, M = N*2;
int head[N], ver[M<<1], wei[M<<1], nex[M<<1], tot;
inline void addedge(int u, int v, int w) {
	ver[tot] = v; wei[tot] = w; nex[tot] = head[u]; head[u] = tot++;
}

int xsum[N], vis[N];
void dfs(int cur, int pre) {
	vis[cur] = 1;
	for(int i = head[cur]; ~i; i = nex[i])
		if(!vis[ver[i]]) {
			xsum[ver[i]] = xsum[cur] ^ wei[i];
			dfs(ver[i], cur);
		}
}

int main() {
	memset(head, -1, sizeof(head));
	int n, m, q, u, v, w;
	scanf("%d %d %d", &n, &m, &q);
	for(int i = 1; i <= m; ++i) {
		scanf("%d %d %d", &u, &v, &w);
		addedge(u, v, w); addedge(v, u, w);
	}
	dfs(1, 0);
	while(q--) {
		scanf("%d %d", &u, &v);
		printf("%d\n", xsum[u] ^ xsum[v]);
	}
	return 0;
}
```

---

## 作者：K2sen (赞：3)

## P5651
#### 题目大意
求一个x到y简单路径的异或和.
#### 思路：
因为图中肯定有环我们肯定是不能走环的.

然后我就随便找了一颗生成树，然后在生成树上找到每一个点到根节点
异或和，查询的时候直接将两个异或和异或起来就好了

关于子树上的点到根节点路径重复的问题？

因为我们可以知道两个点从他们的lca到根节点的路径都是重复的

然后两个值异或起来之后就消掉了，所以我们可以直接将两个点到根节点的异或值直接异或起来.

#### code:
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

#define N 100010
#define M 1010

using namespace std;
struct node {
	int next, to, dis;
}edge[N << 1];
struct tree {
	int x, y, dis;
}bian[N];
int n, m, q, head[N << 1], add_edge;
int fath[N], dis[N];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void add(int from, int to, int dis) {
	edge[++add_edge].next = head[from];
	edge[add_edge].to = to;
	edge[add_edge].dis = dis;
	head[from] = add_edge;
}

bool cmp(tree a, tree b) {
	return a.dis < b.dis;
}

int father(int x) {
	if (x != fath[x]) fath[x] = father(fath[x]);
	return fath[x];
}

void kruskal() {
	for (int i = 1; i <= n; i++) fath[i] = i;
	int cnt = 0;
	for (int i = 1; i <= m; i++) {
		if (father(bian[i].x) != father(bian[i].y)) {
			fath[bian[i].x] = bian[i].y;
			add(bian[i].x, bian[i].y, bian[i].dis);
			add(bian[i].y, bian[i].x, bian[i].dis);
			cnt ++;
		}
		if (cnt == n - 1) break;
	}
}

void dfs(int x, int fa) {
	for (int i = head[x]; i; i = edge[i].next) {
		int to = edge[i].to;
		if (to == fa) continue;
		dis[to] = (dis[x] ^ edge[i].dis);
		dfs(to, x);
	}
}

int main() {
	n = read(), m = read(), q = read();
	for (int i = 1; i <= m; i++) 
		bian[i].x = read(), bian[i].y = read(), bian[i].dis = read();
	kruskal();
	dfs(1, 0);
	for (int i = 1, x, y; i <= q; i++) {
		x = read(), y = read();
		printf("%d\n", (dis[x] ^ dis[y]));
	}
	return 0;
}
```

---

## 作者：KSToki (赞：2)

题目中告诉我们所有环的边权异或和都为 $0$，所以当我们经过一个环时，随便走哪一条路的边权异或和都是一样的，因为只有一样才可以异或成 $0$。

因此我们只需对图跑出随便一个生成树即可，将问题转化到了树上。这时我们定义数组 $v$，$v[x]$ 表示点 $x$ 到节点 $1$（这里认为是根节点）的简单路径的边权异或和，每次询问直接输出 $v[x]$^$v[y]$ 即可。对于 $x$ 和 $y$ 的 lca 到节点 $1$（根节点）的路径的边权被异或了两次，自然成为 $0$，不对答案造成影响。

时间复杂度 $O(n+q)$，代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,v[100001],head[100001],to[400001],nxt[400001],w[400001],tot,x,y,z;
bool vis[100001];
inline void add(int x,int y,int z)
{
	to[++tot]=y;
	w[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot;
}
void dfs(int x)
{
	vis[x]=1;
	for(register int i=head[x];i;i=nxt[i])
		if(!vis[to[i]])
		{
			v[to[i]]=v[x]^w[i];
			dfs(to[i]);
		}
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	while(m--)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	dfs(1);
	while(q--)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",v[x]^v[y]);
	}
	return 0;
}
```


---

## 作者：sp201613 (赞：2)

做的时候乍一看觉得很难,后来发现自己漏掉了一个重要的条件

**保证G中不存在简单环使得边权异或和不为0**

(~~双重否定表肯定~~)

这也就意味着

假如有一个环,这个环上有n条边，那么边权异或和为0

那么我们就会发现，假如环上有两点x,y,那么根据异或的结合律可知，x,y的所有路径异或和为0

所以我们惊喜地发现，由上述结论可推知，x,y之间的所有路径相等（ a^b=0 <=> a=b ）

所以我们就可以把图构造成树，记录节点到根的异或和即可，题中要求x,y之间的最短路径，令dp[x]表示根节点到x节点的异或和，那么答案就是dp[x]^dp[y]（显然lca以上的部分异或后变成0，正好剩下x,y之间的异或路径QAQ）

下面放一下我写的代码（事实上我树构造的麻烦了点，并不需要构造最小生成树，~~我只是手欠了~~），不喜勿喷

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
#define rg register
const int N=1e5+5;
int n,m,Q,h[N],cnt,k,fa[N],dp[N];
struct edge{int to,nxt,w;}e[N<<2];
struct node{int u,v,w;}a[N<<1];
template<class T>inline void read(T &x)
{
	x=0;int f=0;char ch=getchar();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=f?-x:x;
}
inline bool cmp(node i,node j){return i.w<j.w;}
inline void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=h[u];
	h[u]=cnt;
}
inline int find(int x)
{
	if(fa[x]^x) fa[x]=find(fa[x]);
	return fa[x];
}
inline void dfs(int x,int f)
{
	for(rg int i=h[x],y,z;~i;i=e[i].nxt){
		y=e[i].to;z=e[i].w;
		if(y^f) dp[y]=dp[x]^z,dfs(y,x);
	}
}
int main()
{
	read(n);read(m);read(Q);
	memset(h,-1,sizeof(h));
	for(rg int i=1;i<=m;++i)
		read(a[i].u),read(a[i].v),read(a[i].w);
	sort(a+1,a+m+1,cmp);
	for(rg int i=1;i<=n;++i) fa[i]=i;
	for(rg int i=1;i<=m;++i){
		int u=find(a[i].u),v=find(a[i].v);
		if(u^v){
			fa[u]=v;
			add(a[i].u,a[i].v,a[i].w);
			add(a[i].v,a[i].u,a[i].w);
			++k;
			if(k==n-1) break;
		}
	}
	dfs(1,0);
	for(rg int i=1,x,y;i<=Q;++i){
		read(x);read(y);
		printf("%d\n",dp[x]^dp[y]);
	}
	return 0;
}
```


---

## 作者：Develop (赞：2)

该题直播中讲的是将每一个点设一个点权，先人为设定$f[1]=1$，

再通过$DFS$算出其他点的点权，复杂度$O(n+Q)$

不过我还是想分享一下我的想法：

~~暴力分类讨论~~我们先不考虑图中含有环的情况:（其实就是一棵树）

我们如果先以任意一个点为源点跑一边最短路的话，记到$i$点的最短路为$f[i]$

当我询问的两个点的最短路包含这个点，将他们的$f[a]$和$f[b]$异或起来恰好是最短路(最小异或和)

当最短路不包含这个点时，(如图，求1到3的最短路，以6为源点)因为描红的边被计算了两遍($ a$ $xor$ $a$ $==0$，异或的影响被抵消)，所以此时也恰好是最短路


![](https://cdn.luogu.com.cn/upload/image_hosting/ryuu01v8.png)


而加入环之后，我们注意到，题目中有一句话：

 ### 保证$G$中不存在简单环使得边权异或和不为$0$。
 
 于是我们就有，对于任意一个环内，我从一个点到另一个点的一条路径异或和，和另一条路径的异或和相等(只有$ a1$ $xor$ $a2$ $==0$才有整个环为$0$呀)
 
 于是就可以愉快的把环给砍掉，其余证明同上
 
 复杂度没有直播中的这么优秀，但是也可供参考
 
 ~~顺便在CSP前提醒同学们一句，一定要尝试根据数据范围猜测正解~~
 
 ~~我会告诉你我看到$n,Q<=10^{5}$又想到要用最短路就口胡$O(1)$询问，然后利用$IOI$赛制的特点，打完就交然后过了吗~~
 
 咳咳，正经说一句，这个技巧在$OI$中还是确实很重要的

---

## 作者：陈刀仔 (赞：2)

一道非常优秀的思维题（虽然命名有点恶臭）

拿到题目一开始会以为是线性基

但题目中有一个特殊条件

每一个简单环中的边的异或和都是０

所以考虑DFS过程中，一个既可以下一步走进环中，又可以离开环的点

如果他走进环里，那当他走出环时，环给他贡献的异或和是０

而一个数异或０仍是原数

所以环对他当前的异或和没有贡献

所以我们可以去掉图中的环

我们只需在建图时用并查集判断加完该边后会不会出现环

如果不会，就将他加入图中

此时该图就成了一棵树

我们假设１号结点为根，并用DFS计算每个点到根的路径的异或和 h

再考虑x到y的路径异或和

异或和h_x和h_y一定会重叠一部分，就是h_lca(x,y)

又因为异或有结合律和交换律，且相同两数的异或和是０

所以我们将h_x和h_y异或起来，两个数都拥有的h_lca(x,y)的部分一定会被抵消掉

所以答案就是h_x xor h_y
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=100050;
int n,m,q;
int fa[maxn];
int cnt,head[maxn],to[maxn*2],w[maxn*2],nex[maxn*2];
int h[maxn];
int find(int x)
{
	if(fa[x]==x)
		return x;
	return fa[x]=find(fa[x]);
}
void add(int x,int y,int z)
{
	cnt++;
	to[cnt]=y;
	w[cnt]=z;
	nex[cnt]=head[x];
	head[x]=cnt;
}
void dfs(int u,int f)
{
	for(int i=head[u];i;i=nex[i])
	{
		int v=to[i];
		if(v^f)
		{
			h[v]=h[u]^w[i];
			dfs(v,u);
		}
	}
}
int main()
{
	freopen("b.in","r",stdin);
	freopen("b.out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		int f1=find(x),f2=find(y);
		if(f1^f2)
		{
			fa[f1]=f2;
			add(x,y,z);
			add(y,x,z);
		}
	}
	dfs(1,0);
	while(q--)
	{
		int x,y;
		cin>>x>>y;
		cout<<(h[x]^h[y])<<endl;
	}
	return 0;
}
```


---

## 作者：big_news (赞：2)

不难发现怎么走路径长度都是一样的。

为什么呢？简单的证明：

1. 在原图是一棵树的情况下，该结论显然成立；
2. 在原图是一棵基环树时，我们考虑环上的两个点$(u,v)$，则$u\to v$有两种走法：正着绕环和反着绕环。考虑环的异或和为$0$，那么这两种走法的路径长度相同。推广到任意节点$u,v$，不难发现该结论依然成立；
3. 推广到原图存在若干简单环：对于任意点对$(u,v)$，$u\to v$的路径要么经过若干简单环，要么不经过任何一个简单环。对于后者结论显然成立；对于前者，则该路径可以被拆分成若干段“简单环上的路径”和若干段“不经过简单环的路径”，而对于每一段路径，其距离都为定值。那么$u\to v$的距离一定，于是结论依然成立。

于是只需要预处理出节点1到每个节点任意一条路径的边权异或和就好了，不需要mst。剩下的问题就是这个题的模型了：[P2420 让我们异或吧](https://www.luogu.org/problem/P2420)。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<queue>
using namespace std;

const int CN = 1e5+5;

class fs{
  public: int to,nxt,di; void init(int t,int n,int d) {to=t;nxt=n;di=d;}
}E[CN << 2];
int hd[CN],ecnt = 0;
void add(int x,int y,int z) {E[++ecnt].init(y, hd[x], z); hd[x] = ecnt;}

int n,m,q;

int d[CN]; bool vis[CN];
void dfs(int u){
    vis[u] = true;
    for(int k=hd[u];k;k=E[k].nxt){
        int v = E[k].to;
        if(!vis[v]) d[v] = d[u] ^ E[k].di,dfs(v);
    }
}

int main()
{
    // freopen("b.in", "r", stdin);

    scanf("%d%d%d",&n,&m,&q);
    while(m--){
        int u,v,x; scanf("%d%d%d",&u,&v,&x);
        add(u, v, x); add(v, u, x);
    }

    dfs(1); 
    while(q--){
        int u,v; scanf("%d%d",&u,&v); 
        printf("%d\n",d[u] ^ d[v]);
    }

    return 0;
}
```

---

## 作者：chinaxjh (赞：2)

# 前言
明明只要直接暴力$SPFA$跑一边就好了，我非得删边成树之后$dfs$瞎搞......
# 分析
题目里有一句话非常重要
- 保证$G$中不存在简单环使得边权异或和不为$0$。

就是告诉我们如果出现环的话，到达一个点的不同得到的结果是一样的，所以我们可以依靠这点删边，删掉无论哪条边的结果都是一样的，然后$dfs$一下得出这个点到根节点的所有路径的异或值

~~因为我前天刚做了最长异或路径一题，所以满脑子就是建树~~

所以$dis[x]\quad xor \quad dis[y]$就是它们之间简单路径的异或值，相同一段已经抵消掉了
# $AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=40;
const int NN=500005;
int a[NN],b[NN],nxt[NN],las[NN],fa[NN],str[N],d[NN],a1[NN],b1[NN],c1[NN],las1[NN],nxt1[NN];
int q,n,m,i,lenn,j,len,ans,k,t,elen,x,y,z,elen1;
bool visit[NN],del[NN];
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}//快读
void add(int x,int y,int z)
{
	elen1++;
	a1[elen1]=y;
	b1[elen1]=z;
	c1[elen1]=x;
	nxt1[elen1]=las1[x];
	las1[x]=elen1;
}//建图的边
void add1(int x,int y,int z)
{
	elen++;
	a[elen]=y;
	b[elen]=z;
	nxt[elen]=las[x];
	las[x]=elen;
}//建树的边
void dfs(int x)
{
	int i;
	for (i=las[x];i;i=nxt[i])
	if (a[i]!=fa[x])
	{
		fa[a[i]]=x;
		d[a[i]]=d[x]^b[i];
		dfs(a[i]);
	}
}//dfs预处理
void sc(int father,int x)
{
	int i;
	visit[x]=true;
	for (i=las1[x];i;i=nxt1[i])
	if (a1[i]!=father)
	{
		if (visit[a1[i]])
		{
			del[i]=true;
			del[1^i]=true;
		}
		else sc(x,a1[i]);
	}
}//判环删边
int main()
{
	cin>>n>>m>>q;
	elen1=1;
	for (i=1;i<=m;i++)
	{
		x=read(); y=read(); z=read();
		add(x,y,z);
		add(y,x,z);
	}
	visit[1]=true;
	sc(0,1);//删边
	for (i=2;i<=elen1;i++)
	if (!del[i]) add1(c1[i],a1[i],b1[i]);//没删掉的边为树的边
	dfs(1);
	for (i=1;i<=q;i++)
	{
		x=read();
		y=read();
		printf("%d\n",d[x]^d[y]);//直接xor
	}
}
```
~~其实我先写出来了这个$SPFA$，然后傻傻的每次询问一次$SPFA$，甚至傻到离线乱搞~~
$$SPFA\quad AC\quad Code$$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int a[N],b[N],nxt[N],las[N],q[N],dis[N];
int len,n,m,t,x,y,z,i;
void add(int x,int y,int z)
{
	len++;
	a[len]=y;
	b[len]=z;
	nxt[len]=las[x];
	las[x]=len;
}//建图
void spfa(int kk)
{
    int i,l,r,x;
    l=1; r=1; q[1]=kk;
    dis[kk]=0;
    while (l<=r)
    {
        x=q[l];
        for (i=las[x];i;i=nxt[i])
        if (dis[a[i]]==-1)
        {
            dis[a[i]]=dis[x]^b[i];
            r++;
            q[r]=a[i];
        }
        l++;
    }
}//SPFA模板
int main()
{
	cin>>n>>m>>t;
	for (i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	memset(dis,-1,sizeof(dis));//-1为潍坊问过的
	spfa(1);
	for (i=1;i<=t;i++)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",dis[y]^dis[x]);//直接xor即可
	}
}
```


---

## 作者：StudyingFather (赞：2)

一道非常棒的思维题。

首先考虑没有环的情况，这时候我们随便取一个点作为根节点进行 DFS，求出每个点 $i$ 到根节点路径的权值 $dis_i$。

这时候 $u$ 到 $v$ 路径的权值显然为 $dis_u \oplus dis_v$。

接下来考虑有环的情况。

题目中给的图性质非常特殊：保证 $G$ 中不存在简单环使得边权异或和不为 $0$，也即所有环的权值均为零。

这意味着，如果我们把一个环分割为两段，这两段的权值相等（否则环的权值就不为 $0$ 了）。

因此假如从 $u$ 到 $v$ 的路径经过了一个环，我们只需保留环的其中一段即可（另外一段和这一段是一样的）。

这样，我们求出图的任意一个生成树，就可以把问题转化为树的情况。

到此，问题得到了完美解决。

```cpp
#include <cstdio>
struct edge
{
 int v,w,next;
}e[400005];
int fa[100005],head[100005],dis[100005],cnt;
void addedge(int u,int v,int w)
{
 e[++cnt].v=v;
 e[cnt].w=w;
 e[cnt].next=head[u];
 head[u]=cnt;
}
int find(int x)
{
 return fa[x]==x?x:fa[x]=find(fa[x]);
}
void unionn(int x,int y)
{
 fa[y]=x;
}
void dfs(int u,int fa,int w)
{
 dis[u]=w;
 for(int i=head[u];i;i=e[i].next)
  if(e[i].v!=fa)
   dfs(e[i].v,u,w^e[i].w);
}
int main()
{
 int n,m,q;
 scanf("%d%d%d",&n,&m,&q);
 for(int i=1;i<=n;i++)
  fa[i]=i;
 for(int i=1;i<=m;i++)
 {
  int u,v,w;
  scanf("%d%d%d",&u,&v,&w);
  int fu=find(u),fv=find(v);
  if(fu!=fv)
  {
   unionn(fu,fv);
   addedge(u,v,w);
   addedge(v,u,w);
  }
 }
 dfs(1,0,0);
 while(q--)
 {
  int u,v;
  scanf("%d%d",&u,&v);
  printf("%d\n",dis[u]^dis[v]);
 }
 return 0;
}
```


---

## 作者：MoXiaodu (赞：1)

### 题目背景

YSGH牛逼
### 题目描述

给定$n$个点$m$条边的无向简单联通图$G$，边有边权。保证没有重边和自环。

定义一条简单路径的权值为路径上所有边边权的异或和。

保证$G$中不存在简单环使得边权异或和不为$0$。

$Q$次询问$x$到$y$的最短简单路径。

------------
### 思路
既然是最短路练习题，我们当然要用最短路来做惹（$Dijkstra$手写堆）。

### 四十分做法
每一次都跑一边最短路，时间复杂度：$O( Q m log m)$

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct pa{
	int ha,dis,ne;
}q[500001];
struct note{
	int dis,pos;
}d[500001];
int line_cd,cnt=0,n,m,s,h[100001],v[100001],dis[100001],qq;
void push_d(int a,int bh){
	line_cd++;
	d[line_cd].dis=a;
	d[line_cd].pos=bh;
	if(line_cd==1)
	return;
	int dq=line_cd;
	int next=line_cd/2;
	while(next>=1){
		if(d[dq].dis<d[next].dis){
			swap(d[dq],d[next]);
			dq=next;
			next/=2;
		}
		else return;
	}
}
note top_pop_d(){
	int res=d[1].dis;
	int bh=d[1].pos;
	d[1]=d[line_cd];
	line_cd--;
	if(line_cd==1)return note{res,bh};
	int dq=1;
	int next=2;
	while(next<=line_cd){
		if(d[next].dis>d[next+1].dis)next++;
		if(d[dq].dis>d[next].dis){
			swap(d[next],d[dq]);
			dq=next;
			next*=2;
		}
		else return note{res,bh};
	}
	return note{res,bh};
}
void in(int x,int y,int z){
	cnt+=1;
	q[cnt].dis=z;
	q[cnt].ne=y;
	q[cnt].ha=h[x];
	h[x]=cnt;
}
void djstl(){
	dis[s]=0;
	push_d(0,s);
	while(line_cd){
		note tp=top_pop_d();
		int x=tp.pos,d=tp.dis;
		if(v[x])continue;
		v[x]=1;
		for(int i=h[x];i;i=q[i].ha){
			int y=q[i].ne;
			if(dis[y]>dis[x]^q[i].dis){
				dis[y]=dis[x]^q[i].dis;
				if(!v[y]){
					push_d(dis[y],y);
				}
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&qq);
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		in(x,y,z),in(y,x,z);
	}
	for(int i=1;i<=qq;i++){
		int t;
		scanf("%d%d",&s,&t);
		memset(dis,0x3f,sizeof(dis));
		djstl();
		memset(v,0,sizeof(v));
		cout<<dis[t]<<endl;
	}
	return 0;
}
```
但这样时间完全不够，怎么办呢？

### 50分 做法
我们再来仔细的读题，看到这句话：
>保证$G$中不存在简单环使得边权异或和不为$0$。

所以就是告诉我们如果出现环的话，到达一个点的不同得到的结果是一样的，所以我们可以依靠这点删边，删掉无论哪条边的结果都是一样的，答案为dis[s] xor dis[t].

```cpp
#include<bits/stdc++.h>
using namespace std;
struct pa{
	int ha,dis,ne;
}q[500001];
struct note{
	int dis,pos;
}d[500001];
int line_cd,cnt=0,n,m,s,h[100001],v[100001],dis[100001],qq;
void push_d(int a,int bh){
	line_cd++;
	d[line_cd].dis=a;
	d[line_cd].pos=bh;
	if(line_cd==1)
	return;
	int dq=line_cd;
	int next=line_cd/2;
	while(next>=1){
		if(d[dq].dis<d[next].dis){
			swap(d[dq],d[next]);
			dq=next;
			next/=2;
		}
		else return;
	}
}
note top_pop_d(){
	int res=d[1].dis;
	int bh=d[1].pos;
	d[1]=d[line_cd];
	line_cd--;
	if(line_cd==1)return note{res,bh};
	int dq=1;
	int next=2;
	while(next<=line_cd){
		if(d[next].dis>d[next+1].dis)next++;
		if(d[dq].dis>d[next].dis){
			swap(d[next],d[dq]);
			dq=next;
			next*=2;
		}
		else return note{res,bh};
	}
	return note{res,bh};
}
void in(int x,int y,int z){
	cnt+=1;
	q[cnt].dis=z;
	q[cnt].ne=y;
	q[cnt].ha=h[x];
	h[x]=cnt;
}
void djstl(){
	dis[1]=0;
	push_d(0,1);
	while(line_cd){
		note tp=top_pop_d();
		int x=tp.pos,dd=tp.dis;
		if(v[x])continue;
		v[x]=1;
		for(int i=h[x];i;i=q[i].ha){
			int y=q[i].ne;
			if(dis[y] > (dd xor q[i].dis)){
				dis[y] = (dd xor q[i].dis);
				if(!v[y]){
					push_d(dis[y],y);
				}
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&qq);
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		in(x,y,z),in(y,x,z);
	}memset(dis,0x3f,sizeof(dis));
	djstl();
	for(int i=1;i<=qq;i++){
		int t;
		scanf("%d%d",&s,&t);
		cout<<(dis[t] ^ dis[s])<<endl;
	}
	return 0;
}
```
导致这个程序错误的地方在这里：
```cpp
if(dis[y] > (dd xor q[i].dis)){//这里
	dis[y] = (dd xor q[i].dis);
		if(!v[y]){
			push_d(dis[y],y);
		}
	}
```
### 80分做法：
修改刚刚错误的地方，就有80分了（但是会被v<=1卡掉）
```cpp
#include<bits/stdc++.h>
using namespace std;
struct pa{
	int ha,dis,ne;
}q[500001];
struct note{
	int dis,pos;
}d[500001];
int line_cd,cnt=0,n,m,s,h[100001],v[100001],dis[100001],qq;
void push_d(int a,int bh){
	line_cd++;
	d[line_cd].dis=a;
	d[line_cd].pos=bh;
	if(line_cd==1)
	return;
	int dq=line_cd;
	int next=line_cd/2;
	while(next>=1){
		if(d[dq].dis<d[next].dis){
			swap(d[dq],d[next]);
			dq=next;
			next/=2;
		}
		else return;
	}
}
note top_pop_d(){
	int res=d[1].dis;
	int bh=d[1].pos;
	d[1]=d[line_cd];
	line_cd--;
	if(line_cd==1)return note{res,bh};
	int dq=1;
	int next=2;
	while(next<=line_cd){
		if(d[next].dis>d[next+1].dis)next++;
		if(d[dq].dis>d[next].dis){
			swap(d[next],d[dq]);
			dq=next;
			next*=2;
		}
		else return note{res,bh};
	}
	return note{res,bh};
}
void in(int x,int y,int z){
	cnt+=1;
	q[cnt].dis=z;
	q[cnt].ne=y;
	q[cnt].ha=h[x];
	h[x]=cnt;
}
void djstl(){
	dis[1]=0;
	push_d(0,1);
	while(line_cd){
		note tp=top_pop_d();
		int x=tp.pos,dd=tp.dis;
		if(v[x])continue;
		v[x]=1;
		for(int i=h[x];i;i=q[i].ha){
			int y=q[i].ne;
			if(dis[y] > dd xor q[i].dis){
				dis[y] = (dd xor q[i].dis);
				if(!v[y]){
					push_d(dis[y],y);
				}
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&qq);
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		in(x,y,z),in(y,x,z);
	}
	memset(dis,0x3f,sizeof(dis));
	djstl();
	for(int i=1;i<=qq;i++){
		int t;
		scanf("%d%d",&s,&t);
		cout<<(dis[t] ^ dis[s])<<endl;
	}
	return 0;
}
```
### 满分做法：
在刚刚80分的基础上判断是不是v<=1,如果是的，就用50分做法（正所谓负负得正qwq）
```cpp
#include<bits/stdc++.h>
using namespace std;
struct pa{
	int ha,dis,ne;
}q[500001];
struct note{
	int dis,pos;
}d[500001];
int line_cd,cnt=0,n,m,s,h[100001],v[100001],dis[100001],qq;
void push_d(int a,int bh){
	line_cd++;
	d[line_cd].dis=a;
	d[line_cd].pos=bh;
	if(line_cd==1)
	return;
	int dq=line_cd;
	int next=line_cd/2;
	while(next>=1){
		if(d[dq].dis<d[next].dis){
			swap(d[dq],d[next]);
			dq=next;
			next/=2;
		}
		else return;
	}
}
note top_pop_d(){
	int res=d[1].dis;
	int bh=d[1].pos;
	d[1]=d[line_cd];
	line_cd--;
	if(line_cd==1)return note{res,bh};
	int dq=1;
	int next=2;
	while(next<=line_cd){
		if(d[next].dis>d[next+1].dis)next++;
		if(d[dq].dis>d[next].dis){
			swap(d[next],d[dq]);
			dq=next;
			next*=2;
		}
		else return note{res,bh};
	}
	return note{res,bh};
}
void in(int x,int y,int z){
	cnt+=1;
	q[cnt].dis=z;
	q[cnt].ne=y;
	q[cnt].ha=h[x];
	h[x]=cnt;
}
void djstl(){
	dis[1]=0;
	push_d(0,1);
	while(line_cd){
		note tp=top_pop_d();
		int x=tp.pos,dd=tp.dis;
		if(v[x])continue;
		v[x]=1;
		for(int i=h[x];i;i=q[i].ha){
			int y=q[i].ne;
			if(dis[y] > dd xor q[i].dis){
				dis[y] = (dd xor q[i].dis);
				if(!v[y]){
					push_d(dis[y],y);
				}
			}
		}
	}
}
void djstl2(){
	dis[1]=0;
	push_d(0,1);
	while(line_cd){
		note tp=top_pop_d();
		int x=tp.pos,dd=tp.dis;
		if(v[x])continue;
		v[x]=1;
		for(int i=h[x];i;i=q[i].ha){
			int y=q[i].ne;
			if(dis[y] >( dd xor q[i].dis)){
				dis[y] = (dd xor q[i].dis);
				if(!v[y]){
					push_d(dis[y],y);
				}
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&qq);
	bool pppd=0;
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		in(x,y,z),in(y,x,z);
		if(z>1)pppd=1;
	}
	memset(dis,0x3f,sizeof(dis));
	if(pppd)
	djstl();
	else djstl2();
	for(int i=1;i<=qq;i++){
		int t;
		scanf("%d%d",&s,&t);
		cout<<(dis[t] ^ dis[s])<<endl;
	}
	return 0;
}
```
大功告成！这道题就做完惹

时间复杂度：$O(mlongm+Q)$

---

## 作者：幻影星坚强 (赞：1)

由于一个环的异或和为0， 所以一个点到另一个点的异或和是不变的， 所以预处理出所有点到任意一个点的路径异或和， 询问时将两点到这一个点的路径异或和异或起来就好了

代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, m, q;
struct bian
{
	int from, to, w;
}eg[400100];
int front[100100], num, vis[100010], nnn[100100];
void lian(int x, int y, int w)
{
	eg[++ num].to = y;
	eg[num].from = front[x];
	front[x] = num;
	eg[num].w = w;
}
void dfs(int o, int w)
{
	if(vis[o] == 1)
	return;
	vis[o] = 1;
	nnn[o] = w;
	for(int i = front[o]; i; i = eg[i].from)
	{
		int to = eg[i].to;
		dfs(to, w ^ eg[i].w);
	}
}
int main()
{
	scanf("%d%d%d", &n, &m, &q);
	for(int i = 0; i < m; ++ i)
	{
		int x, y, w;
		scanf("%d%d%d", &x, &y, &w);
		lian(x, y, w);
		lian(y, x, w);
	}
	dfs(1, 0);
	for(int i = 0; i < q; ++ i)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		printf("%d\n", nnn[x] ^ nnn[y]);
	}
}
```


---

## 作者：TEoS (赞：1)

**题意分析**

给出一个无向图，有多个询问，每个询问求两个节点之间的异或和最小的简单路径。这个图有一个特殊的性质：**不存在简单环使得边权异或和不为0**。

**思路分析**

这个图的这个特殊性质是解题的关键，它决定了这道题是div2的签到题。如果两个点之间的路径不只一条，那么这些路径的任意两条一定构成简单环，而简单环边权异或和都为$0$，因为异或的逆运算也是异或，因此任意两条路径的长度一定相等，也就是说，任意两个点之间的所有路径都相等。因此，我们只要求出两点间任意一条路径的边权异或和就可以了。

**具体实现**

根据上面的分析，求出每个点到$1$的边权异或和，然后对于询问的两个点，将它们与$1$的边权异或和异或起来就是答案。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e5+100,M=2e5+100;
int n,m,q,tot;
int head[N],ver[2*M],edge[2*M],Next[2*M];
int d[N];
bool v[N];
void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edge[tot]=z,Next[tot]=head[y],head[y]=tot;
}
void dfs(int x,int now)
{
	v[x]=1;d[x]=now;
	for(int i=head[x];i;i=Next[i])
		if(!v[ver[i]])
			dfs(ver[i],now^edge[i]);
}//dfs求边权异或和
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1,x,y,z;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	dfs(1,0);
	for(int i=1,x,y;i<=q;i++)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",d[x]^d[y]);//异或和
	}
	return 0;
}
```

---

## 作者：DPair (赞：1)

## 【前言】
月赛结束似乎没人写题解？我随便水一篇。

## 【思路】
这道题难度不大，主要在于你有没有想到那一个点。

反正我是读了四五遍题才理解这句话的真正含义的：

**保证$G$中不存在简单环使得边权异或和不为$0$。**

那么这句话有什么用呢？想通了的巨佬可以退出了。

下面讲一下这句话的实际意义

我们可以这么想。

对于一个环，你把它分成任意两半，**每一半的异或和之异或值等于$0$，即把任意一个环分成两半，这两半异或和值相同**

还没看懂？我们继续。。。

由此可见，对于每一条“分岔”的路（且都能到达终点），我们一定能找到一个点，使得这两条路“会集”（否则根本到不了同一个终点）。那么，把那个点，和你目前分岔的这个点全部断开，使这个环变为两半，这两半是**等效**的！

换句话说，这幅图没有最短路，因为所有路的权值都相等。。。

所以，我们就可以直接用树的做法来做，任选一个根节点，然后考虑每一个叶子结点到根节点路径上的异或和。每次查两个点的时候，把这两个点**到根的异或和异或起来**就是答案（根据$a~xor~a=0$）。

我们需要做的，就是使得每一个点只被访问到一次，这样就是一棵树了。

代码不放了。

---

## 作者：gyh20 (赞：1)

初看这道题感觉有些复杂，看到异或就会想到按位计算，但此题只是T2难度，况且还有多组数据，再次思考。

我们发现，两点之间的路径不是唯一的，但两两都在一个环上，而题目保证环的异或值为0。设两条路径权值分别为a,b。则a^b==0，所以a==b。

所以所有路径都是相等的！！！

选n-1条边建一棵树，再求树上距离即可，又因为是异或，连lca也不用求！！！

代码如下:
```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include<bits/stdc++.h>
#define re register
using namespace std;
char rbuf[6500002];
int pt;
inline char gc(){
	return rbuf[pt++];
}
inline int read() {
	re int t=0;
	re char v=gc();
	while(v<'0'||v>'9')v=gc();
	while(v>='0'&&v<='9') {
		t=(t<<3)+(t<<1)+v-'0';
		v=gc();
	}
	return t;
}
int q,fa[100002],n,m,a,b,c,head[400002],cnt,dis[400002];
struct edge{
	int to,next,w;
}e[400002];
inline void bu(re int x,re int y,re int z){
	e[++cnt].to=y;
	e[cnt].next=head[x];
	head[x]=cnt;
	e[cnt].w=z;
} 
inline int root(re int x){
	return (x==fa[x])?(x):(fa[x]=root(fa[x]));
}
inline void dfs(re int x,re int y){
	for(re int i=head[x];i;i=e[i].next){
		if(e[i].to!=y){
			dis[e[i].to]=dis[x]^e[i].w;
			dfs(e[i].to,x);
		}
	}
}
inline void write(re int x){
	if(x>=10)write(x/10);
	putchar((x%10)^48);
}
int main(){
	fread(rbuf,1,6500000,stdin);
	n=read();
	m=read();
	q=read();
	for(re int i=1;i<=n;++i)fa[i]=i;
	for(re int i=1;i<=m;++i){
		a=read();
		b=read();
		c=read();
		if(root(a)!=root(b)){
			fa[a]=b;
			bu(a,b,c);
			bu(b,a,c);		}
	}
	dfs(1,1);
	while(q--){
		a=read();
		b=read();
		write(dis[a]^dis[b]);
		putchar('\n');
	}
}
```


---

## 作者：超级玛丽王子 (赞：0)

[在窝的博客食用更佳](https://www.luogu.com.cn/blog/LXLDuliu-IAKIOI/solution-p5651)

一道非常简单的基础图论题目。核心算法是 `邻接表/链式前向星 + bfs`。

首先拿到这个题也许大家第一反应是 `Floyd-Warshall` 或者 `Johnson`，然而看到数据范围直接放弃。进一步观察题目，发现题目中有一个巧妙的提示：
>保证 $G$ 中不存在简单环使得边权异或和不为 $0$。

这是什么意思呢？这告诉我们，所谓的最短路就是个幌子。原因是，对于任何简单环，无论从环上半部分绕还是从下半部分绕，经过的点异或和均为 $0$。因此，我们只需要暴力跑一遍bfs就好了。

下面是具体实现。考虑为每个点赋“异或点权”，第 $i$ 个点的点权是 $w_i$，那么满足如下性质：
$$\large\forall_{edge(x,y)}\ v_{x,y}=w_x\ \oplus\ w_y$$
点 $p_0$ 到 $p_n$ 的最短路径就等于所有经过的边的边权异或和。形式化地讲，令 $p_0$ 到 $p_n$ 经过 $p_1,p_2,\cdots,p_{n-1}$，那么其最短路径长度为
$$\large\operatorname{dis}_{x,y}=v_{p_0,p_1}\ \oplus\ v_{p_1,p_2}\ \oplus\ \cdots\ \oplus\ v_{p_{n-1},p_n}$$

将这个柿子展开可以得到：
$$\large\operatorname{dis}_{x,y}=a_{p_0}\ \oplus\ a_{p_1}\ \oplus\ a_{p_1}\ \oplus\ a_{p_2}\cdots\ \oplus\ a_{p_{n-1}}\ \oplus\ a_{p_{n-1}}\ \oplus\ a_{p_n}$$

根据异或运算的反身性，即 $a\ \oplus\ a=0$，可得
$$\large\operatorname{dis}_{x,y}=a_{p_0}\ \oplus\ a_{p_n}$$

这样我们就可以 $O(n)$ 预处理，$O(1)$ 查询了！

核心代码：
```cpp
while(!q.empty()) {   //bfs
        int t=q.front();q.pop();  
        if(*(vis+t)) continue;  //记忆化
        *(vis+t)=1;
        for(int i=*(h+t);i;i=(e+i)->next) {
            int u=(e+i)->to,w=(e+i)->w;
            if(!*(vis+u)) *(d+u)=*(d+t)^w,q.push(u); //求点权，保存在dis数组中
        }
    }
```

另外，代码中使用了大量指针，请注意以下问题：
```cpp
struct edge{
	int to,next,w
} e[400010];
int a=1;
int w_error=*(e+a).w; //错误
int w_correct=(e+a)->w; //正确
```
大概是优先级冲突的问题。

完结撒花~

看我写的这么详细，不点个赞再走嘛？

---

## 作者：pomelo_nene (赞：0)

发现了idea大致相同的题。。。所以好像有很多种算法可以过这种题

因为题目中的一句话降低了难度

> 保证$G$中不存在简单环使得边权异或和不为$0$。

也就是说图中的环异或和都为$0$，所以我们没有必要走环，也就是说我们不管怎么走，只要是从$u$走到$v$，答案都是一样的。

所以说我们可以直接用$dfs$或者$Dijkstra$求最短路，前者是正解，后者只是方便找一条路径

或者是求生成树然后上$dfs$，方法一样

方法1

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#define Edge pair<int,int>
#define mp make_pair
using namespace std;
bool vis[100005];
int n,m,q,Xor[100005],Last[100005];
vector<Edge> G[100005];
void dfs(int now,int path)
{
	if(vis[now])	return ;
	vis[now]=true;
	Xor[now]=path;
	for(unsigned long i=0;i<G[now].size();++i)	dfs(G[now][i].second,path^G[now][i].first);
}//dfs求任意路径
int main(){
	scanf("%d %d %d",&n,&m,&q);
	for(int i=1;i<=m;++i)
	{
		int u,v,value;
		scanf("%d %d %d",&u,&v,&value);
		G[u].push_back(mp(value,v));
		G[v].push_back(mp(value,u));
	}
	dfs(1,0);
	while(q-->0)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		printf("%d\n",Xor[u]^Xor[v]);//直接输出
	}
	return 0;
}
```

方法2

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<queue>
#include<cstring>
#define Edge pair<int,int>
#define mp make_pair
#define inf 2147483647ll
using namespace std;
priority_queue<Edge,vector<Edge>,greater<Edge> > PQ;
vector<Edge> G[100005];
int dis[100005],Xor[100005];
int read()
{
	int x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar(); 
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
int main(){
	int n=read(),m=read(),T=read();
	for(int i=1;i<=m;++i)
	{
		int u=read(),v=read(),value=read();
		G[u].push_back(mp(value,v));
		G[v].push_back(mp(value,u));
	}
	int s=1;
	for(int i=1;i<=n;++i)	if(i!=s)	dis[i]=inf;
	PQ.push(mp(0,s));
	while(PQ.size())
	{
		Edge now=PQ.top();
		PQ.pop();
		int u=now.second,value=now.first;
		if(dis[u]<value)	continue;
		for(unsigned int i=0;i<G[u].size();++i)
		{
			if(G[u][i].first+dis[u]<dis[G[u][i].second])
			{
				Xor[G[u][i].second]=Xor[u]^G[u][i].first;
				dis[G[u][i].second]=G[u][i].first+dis[u];
				PQ.push(mp(dis[G[u][i].second],G[u][i].second));
			}
		}
	}//求出最短路，顺便求出1到每个点的异或和
	while(T-->0)
	{
		int u=read(),v=read();
		printf("%d\n",Xor[u]^Xor[v]);
	}
	return 0;
}
```

方法三代码缺失

---

在赛时有人发现了这道题撞了[idea](http://noi.ac/problem/41)，但是有人说题目要求是“带权树”，所以帖子被删，不了了之

但是我们仔细想一想，因为不用走环，所以它就是一棵树啊。。。删点边就完了

---

当然 同机房大佬写了一个线性基的代码，跑的还挺快？？

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int he[1000005], ne[1000005], to[1000005], w[1000005], s[1000005], a[1000005], b[1000005], lb[105], at[105];
bool vis[1000005];
inline void chkmn(int &x, int y) {
    if (x > y)
        x = y;
}
void dfs(int x) {
    vis[x] = 1;
    for (int y, i = he[x]; i != 0; i = ne[i]) {
        if (!vis[y = to[i]]) {
            s[y] = s[x] ^ w[i];
            dfs(y);
        }
    }
}
int main() {
    int n, m, q, p = 0, x, y, e;
    scanf ("%d %d %d", &n, &m, &q);
    for (int i = 1; i <= m; ++i) {
        scanf("%d %d %d", &x, &y, &e);
        ne[++p] = he[x];
        to[he[x] = p] = y;
        ne[++p] = he[y];
        to[he[y] = p] = x;
        w[p] = w[p - 1] = e;
    }
    dfs(1);
    memset(he + 1, 0, n << 2);
    for (int i = 1; i <= q; ++i) {
        int ss, tt;
        scanf("%d %d", &ss, &tt);
        b[i] = s[ss] ^ s[tt];
    }
    for (int r = 1; r <= m; ++r) {
        x = a[r];
        p = r;
        for (int i = 30; ~i; --i)
            if (1 << i & x) {
                if (!lb[i]) {
                    lb[i] = x;
                    at[i] = p;
                    break;
                }
                if (at[i] < p) swap(lb[i], x), swap(at[i], p);
                x ^= lb[i];
            }
        for (int x = he[r]; x; x = ne[x]) for (int i = 30; ~i; --i) chkmn(b[x], b[x] ^ lb[i]);
    }
    for (int i = 1; i <= q; i++) printf("%d\n", b[i]);
    return 0;
}
```

---

## 作者：潜伏之OI (赞：0)

### 以下为一些心路历程，可以跳过
----------------------
看到题，天真的以为最短路

一眼数据范围？？？？？

思考10分钟后吴无果

在网上搜了下异或的性质

```latex
A^A =0
A^0 = A
(A^B)^C=A^(B^C)
```
然后……

-----------------------

由于本人太蒟，并没有想到标算

有了异或的性质

我们先来看一道题

假设给定一个树

让我们任意求两点的简单路径值（同本题，异或和）

设求a到b

我们可以用dfs预处理出根到a的路径异或和

求出根到b的路径异或和

然后

**我们只用将根到a的异或和乘上根到b的异或和**

想一想为什么

--------------
#### 标重点

设两点lca值为c

a到c的路径异或和为A

b到c的路径异或和为B

根到c的路径异或和为C

first： 所以根到a的路径异或和为A^C 

second： 根到b的路径异或和为B^C

third： a到b的路径异或和为A^B

我们将first^second得到：A^C^B^C

由异或的性质我们得到 C^C=0

那么first^second=third

--------------
那么问题来了

我们如何将原图转换成一棵树呢？

思考一下

我们可以求出原图的最小生成树

设在最小生成树上的边为树边

不在最小生成树上的边为非树边

其实发现非树边对答案并没有任何贡献

（想一想为什么）

然后这道题就可以愉快的A掉了

 ︿(￣︶￣)︿

附上一份代码助于理解
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	return f*x;
}
#define maxn 100005
int n,m,q;
struct node
{
	int x,y,w;
}t[maxn*2];
inline bool cmp(node q,node p)
{
	return q.w<p.w;
}
int fa[maxn];
inline int find(int x)
{
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);
}
struct edge
{
	int v,nxt,w;
}e[maxn*2];
int head[maxn*2],k=0;
inline void adde(int u,int v,int w)
{
	e[++k].v=v;
	e[k].w=w;
	e[k].nxt=head[u];
	head[u]=k;
}
int d[maxn];
inline void dfs(int u,int fa)
{
	
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v==fa) continue ; 
		d[v]=d[u]^e[i].w;
		dfs(v,u);
	}
}
int main()
{
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++)
	{
		t[i].x=read();
		t[i].y=read();
		t[i].w=read();
	}
	sort(t+1,t+m+1,cmp);
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int u=t[i].x;
		int v=t[i].y;
		int fu=find(u);
		int fv=find(v);
		if(fu!=fv)
		{
			fa[fu]=fv;
			adde(u,v,t[i].w);
			adde(v,u,t[i].w);
		}
	}
	dfs(1,0);
	for(int i=1;i<=q;i++)
	{
		int a=read(),b=read();
		printf("%d\n",d[a]^d[b]); 
	}
	return 0;
}
```
留个赞再走呗

 ︿(￣︶￣)︿

---

## 作者：封禁用户 (赞：0)

#### 前置知识：

#### 异或 ： 
>两个二进制数如果相同位置的数相同则它们的异或值的那一位为 $0$ ， 反之则为 $1$ ， 符号就是 “ ^ ” 或 “ $xor$ ”；

#### 异或和：
>$a$ , $b$ , $c$ 的异或和就是 $a$ ^ $b$ ^ $c$ ；

------------

#### 首先我们先分析一波题意：

1.保证G中不存在简单环使得边权异或和不为0。

这个是说在图中如果有环的话这个环的

### 异或和的值是 $0$

这个信息非常重要，它告诉了我们 :

#### 这个图上的任意两个点之间的的异或和是唯一的！！！

证明：

设 $x$ 和 $y$ 分别为图上某一环上的两点；

设 $x$ 到 $y$ 之间的两条路的边权的异或和分别为 $a$ 和 $b$ ；

由题意得：$a$ ^ $b$ = $0$；

∴ $a$ = $b$ ；

### 然后我们就可以非常愉快的搜索去求他询问的两个点之间的边权异或和辣！

~~然而一定会T~~

------------

接下来我们开始思考该如何优化才能加快它的效率

#### 我们这个时候就可以设一个中间点来求两点之间的之间的异或和

我们设点 $a$ 到点 $b$ 的异或和为 $x$ ；

然后我们再设点 $c$ 到点 $b$ 的异或和为 $y$ ;

很容易看出：

#### $c$ 到 $a$ 的异或和其实就是 $x$ ^ $y$ ；

这样我们就可以先求一遍任意一点到其他点的异或和（$dis$），然后在询问时输出起点的 $dis$ 值异或一下终点的 $dis$ 值就好了；

------------

## 下面上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define re register
#define in inline
#define inf 1000000000 
using namespace std;
in int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int n,m,q,tot=0;
int dis[400001],nx[400001];
bool vis[400001];
struct edge{int v,w,next;}e[400001];
in void addline(int u,int v,int w){
	e[++tot].v=v; e[tot].w=w;e[tot].next=nx[u]; nx[u]=tot;
}
in void bfs(int s){
	queue<int>q;
	memset(dis,0,sizeof(dis));
	memset(vis,0,sizeof(vis));
	q.push(s);
	while(!q.empty()){
		int u=q.front(); q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(re int i=nx[u];i;i=e[i].next){
			int v=e[i].v,w=e[i].w;
			if(!vis[v]){q.push(v); dis[v]=dis[u]^w;}
		}
				
	}
}
int main(){
	n=read(); m=read(); q=read();
	for(re int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		addline(u,v,w); addline(v,u,w);
	}
	bfs(1);
	for(re int i=1;i<=q;i++){
		int x=read(),y=read();
		int ans=dis[x]^dis[y];
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：xzlhxc_ed (赞：0)

[博客内食用更佳](https://www.luogu.org/blog/xzlhxc/p5651-report)/
[题目链接](https://www.luogu.org/problem/P5651?contestId=23456)    
**前置芝士：LCA，并查集**   
**觉得题解有问题或者看不懂的请私信笔者！**

------------
这场，咕咕月赛真的是信心赛啊，部分分给得特别良心，然而还是掩盖不了我菜的事实。

------------

## ①题意
给你一个带权无向图，边权非负，每个环的所有边权值异或的结果为0，定义经过一条路径的费用为路径上所有的边权异或后的值，有$q$个询问，询问$x ---> y$的最小费用。$ ( 0 < n,q \leq 10^5;0 < m \leq 2*n )$   

~~没有负权边？最短路？dijkstra，上！~~   
可以发现，本题中的路径没有最有子结构，由于异或的性质，2个很大的数$xor$后有可能会变小，所以$x --->y$最短路径上的子路径不一定是最短路径。不能用$dijkstra$。    

## ②解法    
- 40$pts$    

由于本题部分分给得很足，暴力就能拿40$pts$，所以果断先打个暴力。   
怎么暴力？dfs！   
```cpp
void dfs(int x,int len)
{
	if(x==goal)//到达目标点，更新结果
	{
		ans=min(ans,len);
		return;
	}
	for(int i=hd[x];i;i=nx[i])//邻接表存图
	 if(!vis[to[i]])//求简单路径，所以一个点最多走一次
	 {
		vis[to[i]]=true;
		dfs(to[i],len^val[i]);
	 	vis[to[i]]=false;//回溯
	 }
	return;
}
```
- 60$pts$   

由于有20分的数据是一棵树，所以2个点的路径就唯一了，码个倍增LCA求出2个点的路径费用就可以了。   

设```w[x][i]```为$x$到它的$2^i$辈祖先的路径费用，异或满足结合律，在求```f[x][i]```，即$x$的第$2^i$辈祖先的时候可以顺便求出来。   

下面是在dfs中求解$f,w$的核心代码：
```cpp
for(int i=1;i<=lo[dep[x]];i++)
 w[x][i]=w[x][i-1]^w[f[x][i-1]][i-1],f[x][i]=f[f[x][i-1]][i-1];
```
求完后，在求2个点的$LCA$的时候顺便累计答案就可以了
```cpp
inline int lca(int x,int y)
{
	int ans=0;
	if(dep[x]<dep[y])swap(x,y);
	while(dep[x]!=dep[y])
	 ans^=w[x][lo[dep[x]-dep[y]]],x=f[x][lo[dep[x]-dep[y]]];//1
	if(x==y)return ans;//2
	for(int i=lo[dep[x]];i>=0;i--)
	 if(f[x][i]!=f[y][i])
	  ans^=w[x][i]^w[y][i],x=f[x][i],y=f[y][i];//3
	ans^=w[x][0]^w[y][0];//4
	return ans;
}
```
码风清奇，各位重点看看有注释的那几行，就是答案的求解方式。剩下的代码，就都是模板了……    

- 80$pts$ 我不会。（逃   

- 100$pts$   

对于每一个环，如果一条路径没有经过这个环上的边，那么删去环上某条边对环没有影响；如果经过环上的某一条边，由于题意，**它不可能经过这一整个环**，所以这条路径在环上至少有2种走法。   

又因为每个环边权异或和为0，所以将这个环的所有边任意分成2个集合，这**2个集合的内部的边的异或和相等**，这意味着只走环上的边，不论怎么走，环上的任意2点的路径**费用**不变。（仔细思考一下呗）    

所以，当一条路径经过一个环，无论在这个环上怎么走，费用不变。所以我们可以删掉环上任意一条边。**让图变成一颗树！**

然后，就套用60$pts$做法的$LCA$就能过了。     

**读入边的时候用个并查集判断2个点是否联通，如果非联通就把这条边加入，否则不加入。**

## ③AC！
题目评价：这个部分分还能起到引发思路的作用，很不错。   
喜欢就点个赞呗$Orz$

---

## 作者：shiwt (赞：0)

已知无向图每个环的异或值都为0

我们可以得出推论：对于图中任意两点u、v，若u、v之间有2条及以上不同的路径，那么这些路径的异或和一定相等。

所以随便找出这张图的任意一个生成树，树上两点间的距离就是这两点的最短距离。

要找树上两点间的“异或距离”（感性理解谢谢），只需要随便找一个根进行遍历，计算每个点到根的异或距离sum，u、v两点间的异或距离即sum[x]^sum[y].

（设dis[x,y]为x、y两点间的异或距离，则sum[x]^sum[y].可以表示为dis[root,lca]^dis[lca,x]^dis[root,lca]^dis[lca,y]。由于dis[root,lca]^dis[root,lca]即为0 所以dis[x,y]=sum[x]^sum[y])

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100010;
const int MAXM=200010;
int n,m,q;
struct mapa {
	int u,v,w;
}e1[MAXM];
struct mapb {
	int c,v,nxt;
}e[MAXN<<1];
int head[MAXN],cnt=0,sum[MAXN];
int f[MAXN];
int getf(int u) {
	if(f[u]==u) return u;
	return f[u]=getf(f[u]);
}
void merge(int x,int y) {
	f[getf(x)]=getf(y);
}
void read(int x,int y,int z) {
	e[++cnt].c=y;
	e[cnt].v=z;
	e[cnt].nxt=head[x];
	head[x]=cnt;
}
void dfs(int sur,int fa) {
	for(register int i=head[sur];i;i=e[i].nxt) {
		int child=e[i].c;
		if(child==fa) continue;
		sum[child]=sum[sur]^e[i].v;
		dfs(child,sur);
	}
}
int query(int x,int y) {
	return sum[x]^sum[y];
}
int main()
{
	int x,y,z;
	scanf("%d%d%d",&n,&m,&q);
	for(register int i=1;i<=n;i++) f[i]=i;
	for(register int i=1;i<=m;i++) {
		scanf("%d%d%d",&e1[i].u,&e1[i].v,&e1[i].w);
	}
	int used=0;
	for(register int i=1;i<=m;i++) {
		if(getf(e1[i].u)==getf(e1[i].v)) continue;
		merge(e1[i].u,e1[i].v);used++;
		read(e1[i].u,e1[i].v,e1[i].w);
		read(e1[i].v,e1[i].u,e1[i].w);
		if(used==n-1) break;
	}
	dfs(1,0);
	while(q--) {
		scanf("%d%d",&x,&y);
		printf("%d\n",query(x,y));
	}
	return 0;
}
```


---

## 作者：B_Qu1e7 (赞：0)

~~听说考时有人发题解……去瞄了一眼，不咋地……虽然我的也不咋地~~

直接跑简单最短路明显会超时。

我们假设由$A$到$B$有两条包含至少一个不同点的路径$a$和$b$，易知$a$和$b$构成了一个包含点$A$和$B$的环。由于`保证G中不存在简单环使得边权异或和不为0。`的条件的存在，得到$a$ ^ $b=0$（即按位异或）。

所以，由$A$到$B$的任意一条路径的长度都等长。因此，只要找到$A$到$B$的任意一条路径即可。

从任意一个点$A$开始，$dis[i]$表示点$A$到点$i$的简单路径长度，每次在与集合$S$中的点相连的点构成的集合中找到任意一个没被加入集合$S$的点$B$，更新$dis[B]$。最后在询问中$O(1)$回答$dis[u]$ ^ $dis[v]$即可。

```
#include<cctype>
#include<cstdio>
#define R register
const int SIZE=100005;
struct edge{
	int to,next,val;
} e[SIZE<<2];
int N,M,Q,head[SIZE],cnt=0,d[SIZE],vis[SIZE]={0};
template<class T>inline void read(R T &m)
{
	m=0;
	R char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))m=(m<<3)+(m<<1)+(c&15),c=getchar();
}
template<class T>inline void write(R T m)
{
	if(m>9)write(m/10);
	putchar(m%10+48);
}
inline void add(R int u,R int v,R int w)
{
	e[++cnt].next=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].val=w;
}
inline void DFS(R int u,R int s)
{
	d[u]=s,vis[u]=1;
	for(R int i=head[u],v; i; i=e[i].next)
	{
		v=e[i].to;
		if(!vis[v])
		{
			DFS(v,s^e[i].val);
		}
	}
}
int main()
{
	read(N),read(M),read(Q);
	for(R int i=1,w,u,v; i<=M; ++i)
	{
		read(u),read(v),read(w),
		add(u,v,w),add(v,u,w);
	}
	DFS(1,0);
	while(Q--)
	{
		R int u,v;
		read(u),read(v),
		write(d[u]^d[v]),
		putchar('\n');
	}
}
```

---

## 作者：thoq (赞：0)

**保证G中不存在简单环使得边权异或和不为0**

没有这句话，这就是一道[紫题](https://www.luogu.org/problem/P4151)

但是有了这句话，这就是一道**黄题**，

因为我们可以发现一条性质：无论怎么走，路径的权值都是一样的

然而比赛时被我做成了**蓝题**：任意一棵生成树，lca求路径权值，代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int N = 100010;
const int LOG = 25;
int n,m,q,cnt,h[N];
int vis[N],dep[N],fa[N];
int f[N][LOG+5],d[N][LOG+5];
struct stEdge
{
	int u,v,w;
	stEdge(int u=0,int v=0,int w=0):
		u(u),v(v),w(w){}
}e0[N*4];
struct Edge
{
	int to,nxt,w;
}e[N*2];
void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].w=w;
	e[cnt].nxt=h[u];
	h[u]=cnt;
}
int findf(int x){return x==fa[x]?x:fa[x]=findf(fa[x]);}
void ST()
{
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		int u=e0[i].u,v=e0[i].v;
		int fu=findf(u),fv=findf(v);
		if(fu==fv)continue;
		add(u,v,e0[i].w);
		add(v,u,e0[i].w);
		fa[fu]=fv;
	}
}
void dfs(int u)
{
	for(int i=h[u];~i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(!vis[v])
		{
			vis[v]=1;
			dep[v]=dep[u]+1;
			f[v][0]=u;
			d[v][0]=e[i].w;
			dfs(v);
		}
	}
}
void init()
{
	ST();
	vis[1]=1;
	dfs(1);
	for(int j=1;j<=LOG;j++)
		for(int i=1;i<=n;i++)
		{
			f[i][j]=f[f[i][j-1]][j-1];
			d[i][j]=d[i][j-1]^d[f[i][j-1]][j-1];
		}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	int k=dep[x]-dep[y],t=0,ans=0;
	while(k)
	{
		if(k&1)
		{
			ans^=d[x][t];
			x=f[x][t];
		}
		k>>=1,t++;
	}
	if(x==y)return ans;
	for(int i=LOG;i>=0;i--)//【1】
	{
		if(f[x][i]!=f[y][i])
		{
			ans^=d[x][i]^d[y][i];
			x=f[x][i],y=f[y][i];
		}
	}
	ans^=d[x][0]^d[y][0];
	return ans;
}
int main()
{
	memset(h,-1,sizeof(h));
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		e0[i]=stEdge(u,v,w);
	}
	init();
	while(q--)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		printf("%d\n",lca(x,y));
	}
	return 0;
}
```
不仅如此，【1】处还被我写成了
```cpp
for(int i=LOG;i>=1;i--)
```
导致**WA10分**

比赛后才调出来，上述代码是**AC**的，时间复杂度$O(qlogn)$

然后和机房同学讨论，发现自己就是脑残：既然怎么走路径权值都一样，走重复的边也无所谓吧？任意选择一个点（就称作根结点），得出它到各点的异或路径权值，两点之间的异或路径权值就是这两个点到根结点的异或路径权值再异或一下

代码不写了，会有其他题解写的

------------
以下是一些本质性的思考：

1.此题难点：性质的推出

2.为什么多次询问树上两点距离（边权和）要用lca？也就是说，为什么不能像异或一样，将两点到根节点的距离相加成为最后的答案？显然，这条路径上会有重复的边权相加，而异或则满足a xor a= 0,重复计算会抵消。

3.不管是哪种做法，都基于**异或的结合律**

4.对于这种题型，生成树+lca其实是较常见的，如[P1967货车运输](https://www.luogu.org/problem/P1967)。这是我思路的来源，但也是我思维定势的原因。

愿 CSP2019 RP++

---

## 作者：OuOu2021 (赞：0)

### 思考过程

- 异或最短路，首先发现它不满足贪心，并不能直接跑最短路算法。这样直接做还是很麻烦的

- 但我们发现题目有一个重要性质：保证G中不存在简单环使得边权异或和不为0。  意思是所有环的边权异或和都为0，这意味着绕任意一个环绕一圈都并不能带来贡献，所以我们可以无视这些环，把原图看作任意一颗生成树，以任一点为根dfs一遍（注意打vis标记，每个点只走一遍）
- 然后a到c的最短路就是$dis[a]$^$dis[c]$，这是因为它分别到根节点的路径异或和被抵消了

------------
### 总结

- 我们有时会发现题目“看起来很难”，这时与其想一些较高级的算法、数据结构，不如先再仔细点看题，看看数据或者题面里有没有什么性质和特点

------------

### Talk is cheap,give me the code!
```cpp
#include <bits/stdc++.h>
#define ri register int
#define mid ((l+r)>>1)
#define ll long long
using namespace std;

inline int read(){
	int f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch))sum=sum*10+(ch^48),ch=getchar();
	return f*sum;
}
inline void print_num(int x){
	if(x>9)print_num(x/10);
	putchar(x%10+'0');
}
inline void print(int x){
	if(x<0)x=-x,putchar('-');
	print_num(x);
	puts("");
}
struct edge{int v,w,next;}e[400010];
int head[100010],cnt,n,m,q;
int dis[100010],vis[100010];
inline void addedge(int u,int v,int w){
	e[++cnt].v=v,e[cnt].w=w,e[cnt].next=head[u],head[u]=cnt;
}
void dfs(int u){
	for(ri i=head[u];i;i=e[i].next){
		int v=e[i].v;
		if(!vis[v])vis[v]=1,dis[v]=dis[u]^e[i].w,dfs(v);
	}
}
int main(){
	n=read(),m=read(),q=read();
	ri u,v,w,st,ed;
	for(ri i=1;i<=m;i=-~i){
		u=read(),v=read(),w=read();
		addedge(u,v,w),addedge(v,u,w);
	}
	dfs(1);
	for(ri i=1;i<=q;i=-~i){
		st=read(),ed=read();
		print(dis[st]^dis[ed]);
	}
	return 0;
}
```

------------

### NY OIer出品

---

## 作者：wym1111 (赞：0)

~~本蒟蒻太菜，将题意理解为了求最大XOR路径，结果用线性基竟然A了~~（[线性基模板]）(https://www.luogu.org/problem/P3812)


![](http://wx4.sinaimg.cn/mw690/0060lm7Tly1ft7xo17vhuj30if09xmx5.jpg)
假设B为最大异或和的路径，我们可以任选一条路径A，则B就是A异或这个大环。
那么我们首先固定一个点s，然后将所有的环扔进线性基，再随便找一条链以它作为初始值更新出其余点到s的最大异或和，记录为dis[i]。
那么对于x，y，则其最大异或和dis[x] XOR dis[y]


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
const int N=110010,M=110010;
struct Edge{int to,next;LL capa;} e[M<<2];
int h[N],sum=0,n,m;
bool vis[N];
LL dis[N],base[70];
void add_edge(int u,int v,LL w){
    e[++sum].to=v;
    e[sum].capa=w;
    e[sum].next=h[u];
    h[u]=sum;
}
void insert(LL x){
    for(int i=60;i>=0;i--)
        if(x&(1ll<<i))
        {
            if(base[i]) x^=base[i];
            else{base[i]=x;break;}
        }
}
void dfs(int u){
    vis[u]=1;
    for(int tmp=h[u];tmp;tmp=e[tmp].next)
    {
        int v=e[tmp].to;
        if(vis[v]) insert(dis[u]^dis[v]^e[tmp].capa);
        else dis[v]=dis[u]^e[tmp].capa,dfs(v);
    }
}
LL query(LL x){
    for(int i=60;i>=0;i--)
        if((x^base[i])>x) x^=base[i];
    return x;
}
int q;
int main(){
    n=read();m=read();q=read();
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),w=read();
        add_edge(u,v,w);
        add_edge(v,u,w);
    }
    dfs(1);
    while(q--){
    	int x=read(),y=read();
    	printf("%d\n",dis[x]^dis[y]);
	}
    return 0;
}
```

后来~~仔细读题~~（听了讲评）发现正解为求出某个点到其余点的异或和，再将x，y，的结果异或就能得出答案

---

## 作者：AntiO2 (赞：0)

因为**保证G中不存在简单环使得边权异或和不为0**，也就是说一个环的异或和为0.那一个环上任意两点之间不管怎么走异或和都是一样的，所以两点间任意一条路径就是答案。。。

那先生成树，再lca预处理出来异或和就可以log级别的查询了

```cpp
#include<bits/stdc++.h>
#define debug cout<<"debug"<<endl;
using namespace std;

int n,m,xx,yy,zz,x,y;
int tot,fa[600005];
vector<pair<int ,int > > edge[200005];
int work[100005][20],work2[100005][20],dep[100005];
int vis[100005], q;
struct node {
	int uu,ne,to,val;
}a[600005];
void add(int u,int v,int w) {
	tot++;
	a[tot].uu = u;
	a[tot].to = v;
	a[tot].val  = w;
}
bool cmp(node AAAA,node BBBB) {
	return AAAA.val > BBBB.val;
}

int find(int x) {
	return fa[x] == x?x:fa[x] = find(fa[x]);
}

void dfs(int x,int fa,int vvv) {
	if(x==fa) dep[x] = 1;
	else dep[x] = dep[fa] + 1;
	vis[x] = 1;
	work[x][0] = fa;
	work2[x][0] = vvv;
	for(int i = 0;i<edge[x].size();i++) {
		int v = edge[x][i].first;
		if(vis[v]) continue;
		dfs(v,x,edge[x][i].second);
	}
}

int main() {
	cin>>n>>m>>q;
	for(int i = 1 ;i <= m; i++) {
		scanf("%d%d%d",&xx,&yy,&zz);
		add(xx,yy,zz);
	}
	sort(a+1,a+1+m,cmp);
	for(int i = 1;i<=n;i++) {
		fa[i] = i;
	}
	for(int i = 1;i<=m;i++) {
		int u = a[i].uu ,v = a[i].to ,w = a[i].val ;
		int fu = find(u),fv = find(v);
		if(fu == fv) continue;
		fa[fu] = fv;
		edge[u].push_back(make_pair(v,w));
		edge[v].push_back(make_pair(u,w));
	}
	for(int i = 1;i<= n;i++) {
		if(!vis[i]) dfs(i,i,0);
	}
	for(int i = 1;i <=18;i++) {
		for(int j = 1;j<=n;j++) {
			work[j][i] = work[ work[j][i-1] ][i-1];
			work2[j][i] = work2[j][i-1]^work2[work[j][i-1]][i-1];
		}
	}
	while(q--) {
		cin>>x>>y;
		int ans  = 0;
		if(dep[x]<dep[y]) swap(x,y);
		for(int i = 18;i>=0;i--) {
			if(dep[work[x][i]]>=dep[y]) {
				ans ^=work2[x][i];
				x = work[x][i];
			}
			if(x==y) break;
		}
		if(x==y) {
			cout<<ans<<endl;
		}
		else {
			for(int i = 18;i>=0;i--) {
				if(work[x][i]!=work[y][i]) {
					ans ^=work2[x][i];
					ans ^=(ans,work2[y][i]);
					x = work[x][i];
					y = work[y][i];
				}
			}
			ans ^=work2[x][0];
			ans^=work2[y][0];
			cout<<ans<<endl;
		}
	}
	return 0;
}

```


---

## 作者：无意识躺枪人 (赞：0)

这题的难点在于对题面这句话的理解：

**"保证G中不存在简单环使得边权异或和不为0"**

意思是，图里面出现的环，其上的权值异或和一定为0

思考一下这样的环有什么特点呢？

无论在这个环上怎么走，走一边和另一边的答案一定是相同的！

因为两个相同的数异或为0，即这个环的两边的边权是一样的。

所以我们只需要在图上随便跑出一棵树，直接输出两个点之间的路径异或值即可

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 500005
using namespace std;

int n,m,q,u,v;
ll w;

struct Edge
{
	int next,to;
	ll dis;
}edge[N<<1];
int cnt=0,head[N];

inline void add_edge(int from,int to,ll dis)
{
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	edge[cnt].dis=dis;
	head[from]=cnt;
}

int dep[N];
ll dis[N];
void dfs(int u,int fa)
{
	for(register int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==fa) continue;
		if(dep[v]!=0x3f3f3f3f) continue;
		dep[v]=dep[u]+1;
		dis[v]=dis[u]^edge[i].dis;
		dfs(v,u);
	}
}

template<class T>inline void read(T &res)
{
	char c;T flag=1;
	while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
	while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}

int main()
{
	read(n);read(m);read(q);
	for(register int i=1;i<=m;++i)
	{
		read(u);read(v);read(w);
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
	memset(dep,0x3f,sizeof(dep));
	dep[1]=0;
	dfs(1,0);
	while(q--)
	{
		read(u);read(v);
		printf("%lld\n",dis[u]^dis[v]);
	}
	return 0;
}
```

---


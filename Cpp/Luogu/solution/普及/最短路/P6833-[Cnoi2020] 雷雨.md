# [Cnoi2020] 雷雨

## 题目背景

> 令人不安的云开始笼罩天空。  
巨大的建筑在强风中轧轧作响。  
幻想乡中响彻着不和协音。  
——「东方辉针城 ～ Double Dealing Character」

一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。

似乎有什么大事要发生，Cirno 在小屋静静地中思考着。

## 题目描述

幻想乡的纵切面可以抽象成一个 $n\times m$ 的矩形。

其中每一个 $1\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。

闪电从**雷雨云**上的 $\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\texttt{A}(1,b)$ 与*迷途竹林* $\texttt{B}(1,c)$。

雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\texttt{O}$ 到 $\texttt{A}$ 与 $\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。

所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。

## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)

如图黄色线为闪电的路径。

## 数据范围与约定

对于 $100\%$ 的数据保证：$0<n,m \le 1000$，$0 \le R_{i,j}\le 10^9$，$0< a,b,c \le m$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: $R_{i,j}\in\{1\}$。
 - Subtask2（$10\%$）: $R_{i,j}\in\{0,1\}$。
 - Subtask3（$10\%$）: $a=b=c$。
 - Subtask4（$10\%$）: $n,m \le 5$。
 - Subtask5（$60\%$）: 无特殊限制。
 

## 样例 #1

### 输入

```
5 5 1 2 4
1 8 1 6 6
1 1 1 2 4
8 3 1 2 2
1 2 1 9 1
1 0 9 1 1```

### 输出

```
15```

# 题解

## 作者：Unordered_OIer (赞：77)

# P6833 题解
## 题意
求从 $(1,a)$ 开始分别到达 $(n,b)$ 和 $(n,c)$ 的路径之和减去其共有路径。（题目中的坐标被作者转化过了）
## 建模
从 $(1,a)$ 到达 $(n,b),(n,c)$ 。这个描述一看就知道是路径问题，于是我们可以想到 $dfs$ ，分别求出 $(1,a) \rightarrow (n,b)$ 和 $(1,a) \rightarrow (n,c)$ 的路径然后减去其共有路径即可。

但是这样做有一个问题：共有路径并不确定。我们在 $dfs$ 的过程中，只保存了最小值，并没有保存路径信息，因此理论上无法快速求出共有路径。所以我们需要把这个问题给规避掉。

我们发现， $(1,a) \rightarrow (n,b),(n,c)$ 的路径中一定有一个转折点 $(i,j)$ ，从 $(1,a)$ 到转折点 $(i,j)$ 后开始分叉分别到达 $(n,b),(n,c)$ 。

但如果我们无脑的从 $(1,a)\ dfs$ 到 $(n,b),(n,c)$ ，就无法确定这个 $(i,j)$ 。那么我们现在就有了一个明确的思路：枚举这个 $(i,j)$ 。

于是路径就被拆成了 $3$ 段：
1. $(1,a) \rightarrow (i,j)$
2. $(i,j) \rightarrow (n,b)$
3. $(i,j) \rightarrow (n,c)$

这三种情况分别求出最短路然后求和即是**转折点为 $(i,j)$ 时的路径** 。  
然后我们每次枚举 $(i,j)$ 的时候分别进行 $dfs$ 即可。复杂度 $\Theta(nmR),R=dfs$ 的复杂度。

## Code
$dfs$ 代码：
```cpp
void dfs(ll x, ll y, ll len) {
	if (len >= min_d[x][y]) return;
	min_d[x][y] = len;
	if (x == tx && y == ty) return;
	for (ll k = 0; k < 4; k ++){
		ll nx = x + dx[k], ny = y + dy[k];
		if (nx >= 1 && nx <= n && ny >= 1 && ny <= m)
			dfs(nx, ny, len + R[nx][ny]);
	}
}
```

## 优化
然而 $dfs$ 并不行，因为单次 $dfs$ 的复杂度过高（~~然而是我写的不好~~）而导致 $\colorbox{#052242}{\color{white}{TLE}}$ 。

于是我们可以把 $dfs$ 改为 $bfs$ 提高算法效率。并通过一开始直接的三次 $bfs$ 统计完所有的路径。

## Code
```cpp
void bfs(ll t, ll tx, ll ty) {
	memset(v, 0, sizeof v);
	priority_queue<node> que;
	que.push((node){tx, ty, min_d[t][tx][ty]});
	while (!que.empty()) {
		node now = que.top(); que.pop();
		if (v[now.x][now.y]) continue;
		v[now.x][now.y] = 1;
		for (int i = 0; i < 4; i ++) {
			ll nx = now.x + dx[i], ny = now.y + dy[i];
			if (nx < 1 || nx > n || ny < 1 || ny > m || v[nx][ny]) continue;
			min_d[t][nx][ny] = min(min_d[t][nx][ny], min_d[t][now.x][now.y] + r[nx][ny]);
			que.push((node){nx, ny, min_d[t][nx][ny]});
		}
	}
}
```
## 后记
算是搜索的半模板题，只要转个弯就能够想到正解。  
~~既然如此你为什么考场上想不到。~~  
最后祝洛谷月赛
### 越办越好
完结撒花，顺便求赞![](https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0/img/qq/%E5%8F%AF%E6%80%9C.gif)

---

## 作者：Lonely_NewYear (赞：31)

# 洛谷 P6833 题解

现在才知道不能加防抄袭，这是修改的，求管理重新放上。

十年 OI 一场空，不开 long long 见祖宗。

## 题目描述

给定一个起点，和两个终点，求最小的**起点到两个终点的路径的并集**上的点权和。

其实就是说如果两条路径重复了一段的话，那一段只算一次。

## 题目分析

其实会发现这个闪电的路径是由三条最短路组成的，一条连向雷雨云，两条分别连向红魔馆和迷途竹林。

考虑枚举三条路径的交叉点，并用 dijkstra（spfa死了）求出这个点到雷雨云，红魔馆和迷途竹林的最短路。如果枚举每个点再求的话浪费多少时间复杂度就不用说了，所以可以从三个源点各跑一遍 dijkstra，最后计算答案时把从三个源点跑出来的最短路相加即可。

跑 dijkstra 时可以把起始点的最短路设成点权，然后到任意一个点后就加上新的点权。注意这样算的话枚举的交叉点的点权会被多算两次，计算答案时要减掉。

时间复杂度就是三遍 dijkstra，即 $O(nm\times log(nm))$，可过。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
struct node
{
	long long x,y,dis;
	bool operator <(const node &b)const
	{
		return dis>b.dis;
	}
};
long long num[1001][1001],dis[3][1001][1001];
int n,m,a,b,c,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
void dijkstra(int k,int sx,int sy)
{
	priority_queue<node> q;
	q.push((node){sx,sy,num[sx][sy]});
	bool vis[1001][1001]={0};
	for(int i=1;i<=1000;i++)
	{
		for(int j=1;j<=1000;j++)
		{
			dis[k][i][j]=1e18;
		}
	}
	dis[k][sx][sy]=num[sx][sy];
	while(!q.empty())
	{
		int x=q.top().x,y=q.top().y;
		q.pop();
		if(vis[x][y])
		{
			continue;
		}
		vis[x][y]=1;
		for(int i=0;i<4;i++)
		{
			int tx=x+dx[i],ty=y+dy[i];
			if(tx<1||tx>n||ty<1||ty>m)
			{
				continue;
			}
			if(dis[k][tx][ty]>dis[k][x][y]+num[tx][ty])
			{
				dis[k][tx][ty]=dis[k][x][y]+num[tx][ty];
				q.push((node){tx,ty,dis[k][tx][ty]});
			}
		}
	}
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&a,&b,&c);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%lld",&num[i][j]);
		}
	}
	dijkstra(0,1,a);
	dijkstra(1,n,b);
	dijkstra(2,n,c);
	long long ans=1e18;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			ans=min(ans,dis[0][i][j]+dis[1][i][j]+dis[2][i][j]-2*num[i][j]);//注意这里交叉点的部分会多算两次，所以要减掉
		}
	}
	printf("%lld",ans);
    return 0;
}
```

谢谢观看！

---

## 作者：InformationEntropy (赞：7)

本题第一眼看就是求地上两个点到天上点的最短路。然而，题上说要求路径的并集的最小值，即重合的路径只算一次，那么，怎么处理呢？

可以发现，如果地上的点为不同的点，那么雷电必定会在走完所有重合路径后在一点处分叉，分别电击地上的两个点。我们只需要找到一个分叉点使经过的路径最小即可。（PS： 如果地上的两个点重合，那么分叉点就是重合的那个点）。由于出发点相同，故二叉状路径一定是最短的，因为出发点到分叉点的一段路径一定是重合路径。

设 $dis_{i,j}$ 为 $i$ 到 $j$ 的最短路，$R_i$ 为点 $i$ 的电阻计量值，天上的点为 $a$，地上两点为 $b,c$，分叉点为 $x$，那么易得最短路径为：

$$dis_{a,x}+dis_{b,x}+dis_{c,x}-2\times R_x$$

PS：由于记录的是点权，所以分叉点算了 3 遍，而实际上只需算 1 遍，故要减去 $2\times R_x$。

所以，本题思路就是跑三遍最短路，得出所有点分别到   $a,b,c$ 的最短路，然后枚举分叉点 $x$。

需要注意以下的几点：

- 由于是网格图，故只需方向数组即可，并不需要建图。

- SPFA 它再一次死了，需要用 Dijkstra+堆优化 完成本题。

- ~~不开 long long 见祖宗~~。

Code:

```cpp

#include <iostream>
#include <cstdio>
#include <cmath>
#include <queue>
#include <cstring>
#define inf 1000000000000000
using namespace std;
typedef long long ll;
inline void read(int &x)
{
	x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		{
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-48;
		ch=getchar();
	}
	x*=f;
}
int ma[1001][1001];
bool vis[1001][1001];
ll dis[3][1001][1001];
/* dis[0],dis[1],dis[2]分别为从三点出发到每个点的最短路
*/
struct node
{
	ll minx, miny, mindis;
	friend bool operator >(node a, node b)
	{
		return a.mindis<b.mindis;
	}
	friend bool operator <(node a, node b)
	{
		return a.mindis>b.mindis;
	}
};
int n, m, a, b, c;
const int dx[]={1, 0, -1, 0};
const int dy[]={0, 1, 0, -1};
inline void dijkstra(int sx, int sy, int p)
{//Dijkstra求最短路
	priority_queue<node>q;
	q.push((node){sx, sy, ma[sx][sy]});
	memset(vis, 0, sizeof(vis));
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=m; j++)
		{
			dis[p][i][j]=inf;
		}
	}
	dis[p][sx][sy]=ma[sx][sy];
	while(!q.empty())
	{
		node h=q.top();
		q.pop();
		int x=h.minx;
		int y=h.miny;
		if(vis[x][y])
		{
			continue;
		}
		vis[x][y]=1;
		for(int i=0; i<4; i++)//方向数组代替前向星
		{
			int xx=x+dx[i];
			int yy=y+dy[i];
			if(xx>=1&&xx<=n&&yy>=1&&yy<=m)
			{
				if(dis[p][xx][yy]>dis[p][x][y]+ma[xx][yy])
				{
					dis[p][xx][yy]=dis[p][x][y]+ma[xx][yy];
					q.push((node){xx, yy, dis[p][xx][yy]});
				}
			}
		}
	}
}
int main()
{
	read(n);
	read(m);
	read(a);
	read(b);
	read(c);
	for(int i=n; i>=1; i--)
	{
		for(int j=1; j<=m; j++)
		{
			read(ma[i][j]);
		}
	}
	dijkstra(n, a, 0);
	dijkstra(1, b, 1);
	dijkstra(1, c, 2);//跑三遍最短路
	ll ans=inf;
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=m; j++)
		{
			ll s=dis[0][i][j]+dis[1][i][j]+dis[2][i][j]-2*ma[i][j];
			ans=min(s, ans);
		}
	}
	cout << ans;
	return 0;
}



---

## 作者：Rubidium_Chloride (赞：5)

9月月赛I 兼[Cnoi2020] B题题解

## 0.前言

[$\color{Red}{\text{在}}\color{orange}\text{博}\color{yellow}\color{green}\text{客}\color{Turquoise}\text{里}\color{blue}\text{看}\color{purple}\color{Red}\text{效}\color{orange}\text{果}\color{yellow}\text{更}\color{green}\text{好}\color{Turquoise}\text{哦}\color{blue}!$](https://www.luogu.com.cn/blog/Rolling-blog1424/solution-p6833)

## 1.题目大意

为了作者的习惯，现在将题目中的地图全部上下翻转，即 $(x,y)\rightarrow (n+1-x,y)$。

- 给定正整数 $a,b,c$，每一个点上有一个值，坐标为 $(i,j)$ 上的值为 $R_{i,j}$；

- 要求两条分别从 $ A (1,a)$ 到 $B(n,b)$ 和 $A(1,a)$ 到 $C(n,c)$ 的路径，使得路径并集上的所有点的 $R_{i,j}$ 的总和最小。输出这个最小的总和；

- $n,m\le 1000$，$0\le R_{i,j} \le 10^9$，$0< a,b,c \le m$。

## 2.算法分析

一个“类·最短路问题”。我们可以求出 $A\rightarrow B$ 的最短路，也可以求出 $A\rightarrow C$ 的最短路，但是路径并集不一定是最短的。

我们先来考虑，如果一个节点引出了 $3$ 条或者及以上的边，我们将它称为“交叉点”。可以证明最优情况下，交叉点只有一个。

如果有 $\ge2$ 个的交叉点，考虑每两个交叉点之间的路径，如果都改成**同一条**最短路径的话一定不会变得更差，而 $2$ 个交叉点合并成了 $1$ 个交叉点。因此结论成立！

所以我们在主程序就可以枚举每一个点作为分叉点的情况，设 $d_{0,i,j}$ 为 $A\rightarrow (i,j)$ 的最短路长度，$d_{1,i,j}$ 为 $B\rightarrow (i,j)$ 的最短路长度，$d_{2,i,j}$ 为 $C\rightarrow (i,j)$ 的最短路长度。

所以在主程序里我们可以直接枚举 $(i,j)$，通过预计算的 $d$ 数组可以求出该点的答案就是 $\sum\limits_{k=0}^{2} d_{k,i,j} - R_i,j\times 2$。

代码：

```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		ans=min(ans,dst[0][i][j]+dst[1][i][j]+dst[2][i][j]-2*r[i][j]);
}
```

接下来的问题就是：怎么预计算 $d$ 数组？

这里找到的是从一个点到其他所有点的所有最短距离，而且整个地图是一个网格图……

所以我们是不是可以很容易地想到bfs？

可是这里的点都是带权的，所以……

我们用**优先队列bfs**吧！

优先队列bfs是一个类似优先队列dijkstra的算法，每次选择当前距离最小的点，然后扩展。如果已经扩展过就不再扩展。

优先队列bfs可以求有向图上的单源多汇问题。

在遍历整幅图的时候顺带着统计答案就可以了。

代码如下：

```cpp
void bfs(ll t,ll tx,ll ty){//t代表算的种类
	fill(vst[0],vst[0]+N*N,0);
	priority_queue<NODE> q;//其实需要写一个小根堆的bool operator
	q.push((NODE){tx,ty,dst[t][tx][ty]});//插入源点
	while(!q.empty()){
		NODE x=q.top();q.pop();
		if(vst[x.x][x.y]) continue;//每个点之扩展一次
		vst[x.x][x.y]=1;
		for(int i=0;i<4;i++){
			ll nx=x.x+dx[i],ny=x.y+dy[i];
			if(nx<1||nx>n||ny<1||ny>m||vst[nx][ny]) continue;//是否可以走
			dst[t][nx][ny]=min(dst[t][nx][ny],dst[t][x.x][x.y]+r[nx][ny]);//更新距离
			q.push((NODE){nx,ny,dst[t][nx][ny]});//插入到队列中
		}
	}
}
```

因为每个点都只扩展一次，所以优先队列bfs的时间复杂度为 $\Theta(n^2\times \log_2 n)$。

## 3.CODE

```cpp
#include<bits/stdc++.h>
#define N 1009
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read() {
    ll x=0,f=1;int c=getchar();
    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
ll n,m,a,b,c,r[N][N],dst[3][N][N],ans=INF,vst[N][N];
const ll dx[4]={1,0,0,-1},dy[4]={0,1,-1,0};//扩展方向
struct NODE{
	ll x,y,v;
	bool operator<(const NODE&a)const{
		return v>a.v;//小根堆的bool operator
	}
};
void bfs(ll t,ll tx,ll ty){
	fill(vst[0],vst[0]+N*N,0);
	priority_queue<NODE> q;
	q.push((NODE){tx,ty,dst[t][tx][ty]});
	while(!q.empty()){
		NODE x=q.top();q.pop();
		if(vst[x.x][x.y]) continue;
		vst[x.x][x.y]=1;
		for(int i=0;i<4;i++){
			ll nx=x.x+dx[i],ny=x.y+dy[i];
			if(nx<1||nx>n||ny<1||ny>m||vst[nx][ny]) continue;
			dst[t][nx][ny]=min(dst[t][nx][ny],dst[t][x.x][x.y]+r[nx][ny]);
			q.push((NODE){nx,ny,dst[t][nx][ny]});
		}
	}
}
int main(){
	n=read(),m=read(),a=read(),b=read(),c=read();
	for(int i=n;i>=1;i--)
		for(int j=1;j<=m;j++) r[i][j]=read();
	fill(dst[0][0],dst[0][0]+3*N*N,INF);
	dst[0][n][a]=r[n][a];//初始化
	dst[1][1][b]=r[1][b];
	dst[2][1][c]=r[1][c];
	bfs(0,n,a);bfs(1,1,b);bfs(2,1,c);//三遍bfs求完d数组
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			ans=min(ans,dst[0][i][j]+dst[1][i][j]+dst[2][i][j]-2*r[i][j]);
	}	
	printf("%lld",ans);
	return 0;
}

```

## 4.后记

祝愿洛谷月赛越办越好！

Update：2020.9.24

感谢评论区的大佬 @[vectorwyx](https://www.luogu.com.cn/space/show?uid=238408)指出算法复杂度的错误！

---

## 作者：超级玛丽王子 (赞：4)

这道题和 P6832 一样，都很新颖。

首先讲一下赛时很多人骗到 $10$ 分的方法：首先把 $b,c$ 按从小到大排序。由于点权全部为 $1$，可以采用 bfs 的思路，走直线最近。注意对最后一行的额外水平距离的处理（也就是判断雷雨和两个终点的位置关系））

接下来讲正解。观察样例解释中的图片。明显可以看出图中有一个交点，连接了三条路线。

![](https://cdn.luogu.com.cn/upload/image_hosting/mwxooqp0.png)

这给我们两个思路：
1. 暴力思路——枚举交点；
2. 类双向 bfs 思路——从三个源点搜最短路，再枚举交点。

显然，暴力思路有很多的浪费。因此我们选择第二种才能 AC。**注意，SPFA 已经死了 我们不能使用 SPFA** ~~其实是因为SPFA不能跑网格图~~。

至于本题的代码，这里就不贴了。只是提几个注意事项：
1. Dijkstra 搞成扩展点权；
2. 源点到自己的距离是自己的点权
3. 要跑三遍 Dij，注意卡常。
4. **枚举交点时交点会被算三次，注意减掉两次**。

这里简单讲下 Dij 的实现：

利用结构体 `vertex` 记录节点的**坐标和 dis**；Dijkstra 的优先队列每次推入结构体（而非点编号），然后贪心地维护一个 `dis[3][maxn][maxn]` （第一维是 $3$ 代表 $3$ 次 Dijkstra）即可！可以参考 `bfs` 广搜中常用的 `dx,dy` 数组标记移动方向。别忘了用 `vis` 标记数组剪枝~

## 那么这篇题解究竟有什么特别的地方呢？
答案是 `bitset`。

`bitset` 是 C++ STL 中的一种专门存储**真正的**布尔型变量的容器。其头文件是 `bitset.h`，当然你也可以用万能头。`bitset` 最大的优点是每一个变量真的**只占用 1bit**。[这里](https://www.luogu.com.cn/paste/87bpo37x)是 `bitset` 的一些操作。


这样我们就可以使用 `bitset` 这种紧凑的数据结构存储 `bool` 数组啦！

例如，`vis` 数组的下面两种写法等价：
```cpp
bool vis[maxn][maxn];
bitset<maxn>vis[maxn];
```

## 完结撒花~求赞求互关QAQ

---

## 作者：dead_X (赞：3)

## 思路
记两条路径的交集为 $A$ ，两条路径分别为 $A+B$ 和 $A+C$ ，那么所求答案即为 $A+B+C$ 。

注意到 $ABC$  三个格集必定在闪电分叉处交汇，因此我们可以枚举分叉处。

接下来，我们需要求分叉处距离三个目标格的距离，显然只需要三遍最短路预处理即可。答案即为所有分叉处答案的最小值。
## 代码
```
#include<bits/stdc++.h>
#define mp make_pair
inline int read() {
	int s=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s;
}
inline int to[4000003],nxt[4000003],val[4000003],head[1000003],cnt;
using namespace std;
priority_queue<pair<long long,int>,vector<pair<long long,int> >,greater<pair<long long,int> > > q;
inline long long x[1000003],y[1000003],z[1000003],t[1003][1003];
inline void addedge(int x,int y,int z) { to[++cnt]=y,val[cnt]=z,nxt[cnt]=head[x],head[x]=cnt; }
bool vis[1000003];
int main() {
	memset(x,0x3f,sizeof(x)),memset(y,0x3f,sizeof(y)),memset(z,0x3f,sizeof(z));
	int n=read(),m=read(),a=read(),b=read(),c=read();
	for(int i=0,xx; i<n; ++i) for(int j=1; j<=m; ++j) 
	{
		t[i][j]=xx=read();
			if(i!=0) addedge((i-1)*m+j,i*m+j,xx);
			if(i!=n-1) addedge((i+1)*m+j,i*m+j,xx);
			if(j!=1) addedge(i*m+j-1,i*m+j,xx);
			if(j!=m) addedge(i*m+j+1,i*m+j,xx);
			if(i==0 && j==a) x[j]=xx;
			if(i==n-1 && j==b) y[(n-1)*m+b]=xx;
			if(i==n-1 && j==c) z[(n-1)*m+c]=xx;
	}
	q.push(mp(x[a],a));
	while(!q.empty()) 
	{
		pair<long long,int> tmp=q.top();
		q.pop();
		int p=tmp.second;
		long long d=tmp.first;
		if(vis[p]) continue;
		vis[p]=1;
		for( int i=head[p]; i; i=nxt[i]) if(x[to[i]]>x[p]+val[i]) 
		{
			x[to[i]]=x[p]+val[i];
			if(!vis[to[i]]) q.push(mp(x[to[i]],to[i]));	
		}
	}
	memset(vis,0,sizeof(vis));
	q.push(mp(y[b],(n-1)*m+b));
	while(!q.empty()) 
	{
		pair<long long,int> tmp=q.top();
		q.pop();
		int p=tmp.second;
		long long d=tmp.first;
		if(vis[p]) continue;
		vis[p]=1;
		for( int i=head[p]; i; i=nxt[i]) if(y[to[i]]>y[p]+val[i]) 
		{
			y[to[i]]=y[p]+val[i];
			if(!vis[to[i]]) q.push(mp(y[to[i]],to[i]));	
		}
	}
	memset(vis,0,sizeof(vis));
	q.push(mp(z[c],(n-1)*m+c));
	while(!q.empty()) 
	{
		pair<long long,int> tmp=q.top();
		q.pop();
		int p=tmp.second;
		long long d=tmp.first;
		if(vis[p]) continue;
		vis[p]=1;
		for( int i=head[p]; i; i=nxt[i]) if(z[to[i]]>z[p]+val[i]) 
		{
			z[to[i]]=z[p]+val[i];
			if(!vis[to[i]]) q.push(mp(z[to[i]],to[i]));	
		}
	}
	long long ans=1000000000000000LL;
	int qwq=0;
	for(int i=0; i<n; i++) for(int j=1; j<=m; j++) ans=min(ans,x[++qwq]+y[qwq]+z[qwq]-t[i][j]*2ll);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：RBI_GL (赞：3)

### 思路


可以想到，这题其实就是找一个点满足这个点到题目要求的三个点的最短路之和最小（去除重复部分），所以直接用 $Dijkstra$
求出三个点到每个点的最短路，然后 $O(N^2)$ 扫描每个点找出满足上述条件的点即可。

注意：输入的矩阵第一行是 $n$ 然后递减，所以如果是从 $1$ 开始输入的需要把题目中 $1$ 和 $n$ 替换。

**此题需要 $long$ $long$ 。**


--------


### Code:


```cpp

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int A = 1e3 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};
bool vis[A][A];
int n, m, a, b, c;
ll dis[3][A][A], mapp[A][A];

struct node {
	int x, y;
	ll val;
	bool operator < (const node &b) const {
		return val > b.val;
	}
};


inline void Dij(int sx, int sy, int tag) {
	priority_queue <node> Q;
	memset(dis[tag], inf, sizeof(dis[tag]));
	memset(vis, 0, sizeof(vis));
	dis[tag][sx][sy] = mapp[sx][sy];
	Q.push((node) {
		sx, sy, dis[tag][sx][sy]
	});
	while (!Q.empty()) {
		int x = Q.top().x, y = Q.top().y;
		Q.pop();
		if (vis[x][y]) continue;
		vis[x][y] = 1;
		for (int i=0; i<4; i++) {
			int bx = x + dx[i], by = y + dy[i];
			if (bx > n || bx < 1 || by > m || by < 1) continue;
			if (dis[tag][bx][by] > dis[tag][x][y] + mapp[bx][by]) {
				dis[tag][bx][by] = dis[tag][x][y] + 1ll * mapp[bx][by];
				Q.push((node) {
					bx, by, dis[tag][bx][by]
				});
			}
		}
	}
}

int main() {
	cin>>n>>m>>a>>b>>c;
	for (int i=1; i<=n; i++) for (int j=1; j<=m; j++) cin>>mapp[i][j];
	Dij(1, a, 0);
	Dij(n, b, 1);
	Dij(n, c, 2);
	ll ans = 1e18;
	for (int i=1; i<=n; i++) {
		for (int j=1; j<=m; j++) {
			ans = min(ans, dis[0][i][j] + dis[1][i][j] + dis[2][i][j] - 2 * mapp[i][j]);
		}
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：wzkdh (赞：2)

## 题意：
给定三个点，求这三个点连通后的最短距离

## 分析：
按照题意，雷电从起点出发后经过一段距离一定会分成两部分，而三点连通的最短距离就是这个点到给出的三个点的三条边距离之和最小（即使分叉点位于起点或者一个终点，依旧可以认为是三条边，只是其中一条的距离为0）

所以我们可以枚举每一个点作为分叉点，求出他到三个点的最小距离并求和，取其中的最小值。

但是如果每个点都跑最短路，时间肯定不足。但是我们可以反过来考虑，一个点到给出三个点的距离也就是给出三个点到它的距离，所以我们可以从给出的三个点跑最短路，得到他们到每一个点的距离，然后从第一个点开始枚举求和，最后最小值就是答案。

## 细节：
本题可以在原图上直接跑最短路，但是我选择了先转化为邻接表，再跑堆优化迪克斯特拉（~~其实就是过于蒟蒻不会原图~~），在构图的时候可以把坐标转化为节点编号，最终再转化回来，这样在写最短路的时候本人认为会好写一些。

## 蒟蒻代码：
```
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,a,b,c,w[1100][1100];
int lin[1000010],tot,v[1000010];
long long d[3][1000010];
struct edge{
	int to,w,next;
}ed[50000010];
struct node{
	int v;
	long long step;
	bool operator < (const node x)const{
		return step>x.step;
		}
};
priority_queue<node> q;
void add(int x,int y,int w)
{
	ed[tot].to=y;
	ed[tot].w=w;
	ed[tot].next=lin[x];
	lin[x]=tot++;
}
void dic(int s,int o)
{
	memset(v,0,sizeof(v));
	memset(d[o],0x3f,sizeof(d[o]));
	d[o][s]=0;
	q.push((node){s,0});
	while(!q.empty())
	{
		node cur=q.top();
		q.pop();
		int t=cur.v;
		if(v[t]==0)
		{
			v[t]=1;
			for(int i=lin[t];i!=-1;i=ed[i].next)
			{
				if(v[ed[i].to]==0&&d[o][ed[i].to]>d[o][t]+ed[i].w)
				{
					d[o][ed[i].to]=d[o][t]+ed[i].w;
					q.push((node){ed[i].to,d[o][ed[i].to]});
				}
			}
		}
	}
}

int main()
{
	memset(lin,-1,sizeof(lin));
	scanf("%d%d%d%d%d",&n,&m,&a,&b,&c);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&w[i][j]);
		}
	}
	int st=a,z1=(m*(n-1)+b),z2=(m*(n-1)+c);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int d1,d2=-1,d3=-1;
			d1=(i-1)*m+j;
			if(j!=m)
				d2=(i-1)*m+j+1;
			if(i!=n)
				d3=i*m+j;
			if(d2!=-1)
			{
				add(d1,d2,w[i][j+1]);
				add(d2,d1,w[i][j]);
			}
			if(d3!=-1)
			{
				add(d1,d3,w[i+1][j]);
				add(d3,d1,w[i][j]);	
			}
		}
	}
	dic(st,0);
	dic(z1,1);
	dic(z2,2);
	long long ans=1000000000000000000;
	for(int i=1;i<=n*m;i++)
	{
		int xx=i/m;
		if(xx*m<i)
			xx++;
		int yy=i-(xx-1)*m;
		if(ans>d[0][i]+d[1][i]+d[2][i]-w[xx][yy]*2ll+w[1][a]+w[n][b]+w[n][c])
		{
			ans=d[0][i]+d[1][i]+d[2][i]-w[xx][yy]*2ll+w[1][a]+w[n][b]+w[n][c];
		}
	}
	printf("%lld",ans);
	return 0;
}

---

## 作者：yewanxingkong (赞：2)

题面仔细研究一下就会发现这是个最短路问题。

我一开始也想过 $dp$ ，但是后来想到这个闪电是可以扭来扭去的，甚至可以扭成一个 $s$ 型，不符合 $dp$ 的要求，于是就放弃了这个想法。

# **建边**

既然是最短路，那么不管怎么样都要把边先存下来。我这边是把每个点的编号定为了 $(i - 1) * m + j$ ，然后把每个点与它周围的四个点都建一条有向边，边权就是该点的点权。

下面是我丑陋的建边代码
```cpp
for(int i=n;i>=1;i--)
	for(int j=1;j<=m;j++){
		int o=read();
		dian[i][j]=o;
		if(j+1<=m)cun[(i-1)*m+j].push_back(node{(i-1)*m+(j+1),o});
		if(i+1<=n)cun[(i-1)*m+j].push_back(node{i*m+j,o});
		if(j-1>0)cun[(i-1)*m+j].push_back(node{(i-1)*m+(j-1),o});
		if(i-1>0)cun[(i-1)*m+j].push_back(node{(i-2)*m+j,o});
	}
```

# **思路**

接下来就该想解题思路了。

一开始的思路是在雷雨云那跑一遍 $dijkstra$ 堆优化，但是发现这两道闪电重复的地方只算一次电阻值，也就是说这是其实是一道会分叉的闪电。

那么这就麻烦了，因为为了减少总的电阻值，这道分叉闪电可以与雷雨云到两个点的最短路差的很远。

于是我想到在雷雨云和两个地点跑三次 $dijkstra$ 堆优化，然后枚举分叉点。但因为我们的建边问题，这道分叉闪电经过的总电阻值还要加上这个分叉点的点权。

这样时间复杂度其实是蛮高的，但我看了看限时是 $2$ 秒——完全够用。（我看有的大佬耗时极低，甚至进了 $1$ 秒，我也不知道是思路不一样还是大佬的常数优化太强了）

下面是代码实现
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<vector>
using namespace std;
struct nod{
	long long a,b;
	bool operator<(const nod &x)const{
		return a>x.a;
	}
};
struct node{
	int c,d;
};
priority_queue<nod>q;
vector<node>cun[1000010];
long long bian[4][1000010],quan,chu=1000000000000000000;
int	qu,n,m,a,b,c,dian[1010][1010];
bool biao[4][1000010];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
int main(){
	n=read();
	m=read();
	a=read();
	b=read();
	c=read();
	for(int i=n;i>=1;i--)
		for(int j=1;j<=m;j++){
			int o=read();
			dian[i][j]=o;
			if(j+1<=m)cun[(i-1)*m+j].push_back(node{(i-1)*m+(j+1),o});
			if(i+1<=n)cun[(i-1)*m+j].push_back(node{i*m+j,o});
			if(j-1>0)cun[(i-1)*m+j].push_back(node{(i-1)*m+(j-1),o});
			if(i-1>0)cun[(i-1)*m+j].push_back(node{(i-2)*m+j,o});
		}
	memset(bian,0x7f,sizeof(bian));
	q.push(nod{0,(n-1)*m+a});
	while(!q.empty()){
		nod zan=q.top();
		q.pop();
		quan=zan.a;
		qu=zan.b;
		if(biao[1][qu])continue;
		biao[1][qu]=1;
		bian[1][qu]=quan;
		for(int i=0;i<cun[qu].size();i++){
			int ququ=cun[qu][i].c,quanqu=cun[qu][i].d;
			if(!biao[1][ququ]&&bian[1][ququ]>bian[1][qu]+quanqu){
				bian[1][ququ]=bian[1][qu]+quanqu;
				q.push(nod{bian[1][ququ],ququ});
			}
		}
	}
	q.push(nod{0,b});
	while(!q.empty()){
		nod zan=q.top();
		q.pop();
		quan=zan.a;
		qu=zan.b;
		if(biao[2][qu])continue;
		biao[2][qu]=1;
		bian[2][qu]=quan;
		for(int i=0;i<cun[qu].size();i++){
			int ququ=cun[qu][i].c,quanqu=cun[qu][i].d;
			if(!biao[2][ququ]&&bian[2][ququ]>bian[2][qu]+quanqu){
				bian[2][ququ]=bian[2][qu]+quanqu;
				q.push(nod{bian[2][ququ],ququ});
			}
		}
	}
	q.push(nod{0,c});
	while(!q.empty()){
		nod zan=q.top();
		q.pop();
		quan=zan.a;
		qu=zan.b;
		if(biao[3][qu])continue;
		biao[3][qu]=1;
		bian[3][qu]=quan;
		for(int i=0;i<cun[qu].size();i++){
			int ququ=cun[qu][i].c,quanqu=cun[qu][i].d;
			if(!biao[3][ququ]&&bian[3][ququ]>bian[3][qu]+quanqu){
				bian[3][ququ]=bian[3][qu]+quanqu;
				q.push(nod{bian[3][ququ],ququ});
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			chu=min(chu,bian[1][(i-1)*m+j]+bian[2][(i-1)*m+j]+bian[3][(i-1)*m+j]+dian[i][j]);
	cout<<chu;
	return 0;
}
```


---

## 作者：pigstd (赞：2)

我们观察样例可以知道，若分叉点为$P$，那么答案就是$dis_{O,P} + dis_{A,P} + dis_{B,P}$，其中$dis_{i,j}$表示$i$点到$j$点的最短路，那么我们只要分别以$O,A,B$为源点跑三次 dijkstra 就可以了。

但是题目给的不是边权，而是点权。为了偷懒，我们可以直接把点权转化成边权。如果点$i$和点$j$是相邻的，那么我们就连一条$i$到$j$，边权为$f_j$的边，再连一条$j$到$i$，边权为$f_i$的边就可以了。这样做之后就可以得到$dis_{i,j} = l_{i,j}+f_i$（其中$l_{i,j}$表示连边后$i$到$j$的最短路，$f_i$表示$i$的点权）

此外，本题给出的是二维的点，我们要转成一维的点，那么对于点$(x,y)$，我们转换成$( ( x - 1 ) \times m + y )$就可以了

这样做要注意空间，连边的时候不能开 `long long`

[code](https://www.luogu.com.cn/paste/f4lssik0)

---

## 作者：Remake_ (赞：2)

我们知道要求的是两条路径的并集的电阻计量值的和最小，所以我们可以枚举点$\texttt{P}$，让$\texttt{O}\to\texttt{P}$的路径为$\texttt{O}\to\texttt{A},\texttt{O}\to\texttt{B}$的路径的交集，紧接着答案就变成了$\texttt{O}\to\texttt{P}+\texttt{P}\to\texttt{A}+\texttt{P}\to\texttt{B}$的最小值（显然要求最小值需要知道这三条路径所分别对应的最短路），由于$\texttt{P}$是我们要枚举的，无法预处理最短路，可以将式子看做$\texttt{O}\to\texttt{P}+\texttt{A}\to\texttt{P}+\texttt{B}\to\texttt{P}$，这样的话思路就比较清晰了，预处理以$\texttt{O},\texttt{A},\texttt{B}$为源点的最短路（跑三遍堆优dij），然后枚举每个$\texttt{P}$，答案为$\min\left\{dist_o[p]+dist_a[p]+dist_b[p]-2R_p\right\}$（因为$\texttt{P}$的电阻实际上被算了$3$次，所以需要减掉$2$次），其中$dist_i[j]$表示以$i$为源点到$j$的最短路径。

---

## 作者：mot1ve (赞：1)

楼上是在原图上跑的最短路，我比较菜，只想到了显式建图做法，思路就是三次dijkstra预处理出闪电到每个点的最短路和劈中的两个点分别到每个点的最短路，然后枚举图上每一个点作为分叉点。这个点权转边权写的挺麻烦的，我是先建完横向边，再建竖向边，注意边界判断。还有就是这个题给的图是坐标轴的形式，要注意读入的时候循环从 $n$ 枚举到 $1$ 。
```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const long long INF=3e18;
struct node{
    int nxt,to,w;
}edge[5000010];
int temp[1000010];
int head[1000010];
int n,m,a,b,c,op,idx,num;
int vis[1000010];
int w[1010][1010];
int star1[4],star2[4];
LL dis[1000010][3];
LL ans=2*INF,id;
void add(int u,int v,int w)
{
    edge[++idx].nxt=head[u];
    edge[idx].to=v;
    edge[idx].w=w;
    head[u]=idx;
}
priority_queue<pair<LL,int> > q;
void dijkstra(int s,int cnt)//cnt=1时存的是闪电的单源最短路， 
{
    for(int i=1;i<=n*m;i++)//初始化 
    {
        vis[i]=0;
    }
    q.push(make_pair(0,s));
    ++op;
    dis[s][cnt]=w[star1[op]][star2[op]];
    while(q.size())
    {
        int x=q.top().second;
        q.pop();
        if(vis[x])
        continue;
        vis[x]=1;
        for(int i=head[x];i;i=edge[i].nxt)
        {
            int y=edge[i].to;
            if(dis[x][cnt]+edge[i].w<dis[y][cnt])
            {
                dis[y][cnt]=dis[x][cnt]+edge[i].w;
                q.push(make_pair(-dis[y][cnt],y)); 
            }
        }
    }
}
int main()
{
    cin>>n>>m>>a>>b>>c;
    star1[1]=n,star1[2]=1,star1[3]=1;
    star2[1]=a,star2[2]=b,star2[3]=c;
    for(int i=n;i>=1;i--)
    {
        for(int j=1;j<=m;j++)
        {
            scanf("%d",&w[i][j]);
            temp[++id]=w[i][j];
        }
    }
    int i=n,j=1;
    num=1;
    while(1)//先存横向边 
    {
        if(j>=m)//j==m时,j+1溢出,换到下一行
        {
            if(i==1)//已经是最后一行了 
            break;
            i--;
            j=1;
            num++;//5到6之间没边 
        } 
        add(num,num+1,w[i][j+1]);//1->2 w=8 
        add(num+1,num,w[i][j]);//2->1 w=1
        j++;
        num++;
    }
    i=n,j=1,num=1;
    while(1)//再存竖向边
    {
        if(j>m)
        {
            if(i==2)
            break;
            i--;
            j=1;
        }
        add(num,num+m,w[i-1][j]);//i=5,j=1,,i=4,j=1
        add(num+m,num,w[i][j]);//i=5,j=1
        j++;
        num++;
    }
    int st1=a,st2=(n-1)*m+b,st3=(n-1)*m+c;//算出起点坐标对应点的编号
    for(int i=1;i<=n*m;i++)//总点数 
    {
        for(int j=1;j<=3;j++)
        {
            dis[i][j]=INF;
        }
    }
    dijkstra(st1,0);
    dijkstra(st2,1);
    dijkstra(st3,2);
    for(int i=1;i<=n*m;i++)
    {
        ans=min(ans,dis[i][0]+dis[i][1]+dis[i][2]-2*temp[i]);
    }
    cout<<ans;
    return 0;
} 

---

## 作者：vectorwyx (赞：1)

# 题外话
1.这题和[[CSPJX2019]道路拆除](https://www.luogu.com.cn/problem/P5683)几乎一模一样……~~不打算爆破比赛吗~~

2.为啥要评黄啊，这题怎么说也得是个绿吧

3.关于SPFA：它死了（

# 正文
我们把这个矩阵看成一张有$n\times m$个点的图。

首先，闪电不会走环，那么**闪电走过的路径就是一棵树**。**这棵树最多有三个叶子结点**（一个是起点，两个是终点）。

因此，这棵树可以被划分为**三条从叶子结点连向同一个顶点的最短路**。这三条最短路互不重叠，那么**树的大小就是其长度之和**。

所以，我们只需要跑三遍Dijkstra，预处理出三个叶子结点到每一个结点的最短路，然后枚举一下三条最短路的顶点。对于每一个可能的顶点，求出它所对应的树的大小，取一个min，这题就愉快的解决了。

时间复杂度为$O(n\times m\times log(n\times m)+n\times m)$，稍微有点大但还是能过的qwq

（附：本题略卡空间，请注意空间上的耗费QwQ）

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define ll long long 
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
#define get(x,y) (x-1)*n+y//把两维的坐标(x,y)压成一维的，好处理 
using namespace std;

inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}

const int maxn=1005,maxm=1e6+5;
const ll INF=5e17;
int S[3],mp[maxn][maxn];//S存储三个叶子结点的纵坐标 

struct Edge{
	int to,next,val;
	Edge(){}
	Edge(int x,int y,int w){to=x,next=y,val=w;}
}e[maxm<<2];
int head[maxm],tot,d[maxm],n,m;
ll dis[maxm][3],ans=INF;

struct Node{
	int num;
	ll dist;//不开longlong见祖宗
	Node(){}
	Node(int x,ll y){num=x,dist=y;}
};

bool operator<(const Node &x,const Node &y){
	return x.dist>y.dist;
}

inline void connect(int x,int y,int val){
	e[++tot]=Edge(y,head[x],val);
	head[x]=tot;
}

priority_queue<Node> q;

void dij(int ss,int od,int nn){//Dijkstra 
	memset(d,0,sizeof d);
	fo(i,1,nn) dis[i][od]=INF;
	dis[ss][od]=0;
	fo(i,1,nn) q.push(Node(i,dis[i][od])); 
	fo(i,1,nn){
		while(!q.empty()&&d[q.top().num]) q.pop();
		if(q.empty()) break;
		int x=q.top().num;
		q.pop();d[x]=true;
		for(int j=head[x];j;j=e[j].next){
			int p=e[j].to;
			if(dis[p][od]>dis[x][od]+e[j].val&&!d[p]){
				dis[p][od]=dis[x][od]+e[j].val;
				q.push(Node(p,dis[p][od])); 
			}
		}
	}
	while(!q.empty()) q.pop();
}

int main(){
	n=read(),m=read();fo(i,0,2) S[i]=read();
	fo(i,1,n)
		fo(j,1,m)
			mp[i][j]=read();
	fo(i,1,n)//把矩阵转为图
		fo(j,1,m){
			int x=get(i,j),y=get(i,j+1),z=get(i+1,j);
			if(j<m)connect(x,y,mp[i][j+1]),connect(y,x,mp[i][j]);
			if(i<n)connect(x,z,mp[i+1][j]),connect(z,x,mp[i][j]);
		}
	int nm=n*m;
	//跑三遍Dijkstra 
	dij(get(1,S[0]),0,nm);
	dij(get(n,S[1]),1,nm);
	dij(get(n,S[2]),2,nm);
	//枚举顶点 
	fo(i,1,n)
		fo(j,1,m){
			int qwq=get(i,j);
			ll kkk=dis[qwq][0]+dis[qwq][1]+dis[qwq][2]-2*mp[i][j];
			if(kkk<ans) ans=kkk;//求最小值 
		}
	cout<<ans+mp[1][S[0]]+mp[n][S[1]]+mp[n][S[2]];//不要忘了把三个叶子结点的点权也加上 
	return 0;
}
```


---

## 作者：MZMH (赞：1)

这道题赛时的时候想了一个奇怪的做法但是没过，后来经过[Stay_hungry](https://www.luogu.com.cn/user/105922)的提示就码了这道题。

雷电必定会在一点处分叉，分别电击地上的两个点，我们只需要枚举这个分叉点。那么怎么算出这个点和目标点的距离呢，很容易可以想到用最短路来求解。在仔细算一下复杂度$O({V}log{E}+n^2)$ ($V$为点的个数 $E$为边的个数)

这道题其实可以转化为图论题，就是从起点和两个终点分别跑一遍最短路，然后枚举那个闪电⚡分开的点，在将三个$dis_x$($x$为当前枚举的点的编号)加起来，取个$Min$就可以了。

细节处理都在代码中

```cpp
//必须要开 long long 不然电阻R加起来会炸
//但是#define int long long 会MLE
//所以就把几个dis数组开long long就好了

#include <bits/stdc++.h>
#define Reg register
using namespace std;
const int N=1e3+10;
inline long long Min(long long a,long long b) { return a<b?a:b; }
inline int read() {
	int x=0,f=0; char c=getchar();
	while(!isdigit(c)) f|=(c=='-'),c=getchar();
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return f?-x:x;
}
struct node {
    int u;
	long long d;
    inline bool operator <(const node &rhs) const {
        return d>rhs.d;
    }
} ;
struct Edge {
	int next,to,w;
} edge[N*N*6];
int n=read(),m=read(),sx=read(),e1=read(),e2=read(),tot;
long long ans=5e18;
int head[N*N],a[N][N];
long long diss[N*N],dis1[N*N],dis2[N*N];
//建边
inline void Addedge(int u,int v,int w) {
	edge[++tot]=(Edge){head[u],v,w};
	head[u]=tot;
}
//Dijkstra
inline void Dijkstra(int s,long long *dis) {
    for(Reg int i=1;i<=n*m;i++)
		dis[i]=5e18;
   //将起点的初值设置为这个位置的电阻值
	if(s%m)
		dis[s]=a[s/m+1][s%m];
	else
		dis[s]=a[s/m][m];
    priority_queue<node>que;
    que.push((node){s,0});
    while(!que.empty()) {
        node front=que.top(); que.pop();
        int u=front.u;
//        if(d==dis[u])
    		for(Reg int i=head[u];i;i=edge[i].next) {
         	   	int v=edge[i].to,w=edge[i].w;
//			cout<<u<<' '<<v<<' '<<w<<'\n';
            		if(dis[u]+w<dis[v]) {
                		dis[v]=dis[u]+w;
                		que.push((node){v,dis[v]});
            		}
        	}
    }
}
signed main() {
	//将网格图转化为有向图
	for(Reg int i=1;i<=n;i++)
		for(Reg int j=1;j<=m;j++) {
			a[i][j]=read();
        	//将每个点的编号设为从左往右数，从上往下数第几个
        	//连边时连的是它四周的四个点连向它自己，所以边权是为这个点的电阻值
			if(j>1)//这是防止向上一个网格连的时候越界，下同
				Addedge((i-1)*m+j-1,(i-1)*m+j,a[i][j]);
			if(j<m)
				Addedge((i-1)*m+j+1,(i-1)*m+j,a[i][j]);
			if(i>1)
				Addedge((i-2)*m+j,(i-1)*m+j,a[i][j]);
			if(i<n)
				Addedge(i*m+j,(i-1)*m+j,a[i][j]);
		}
	Dijkstra(sx,diss)/*,puts("---")*/,Dijkstra(m*(n-1)+e1,dis1)/*,puts("---")*/,Dijkstra(m*(n-1)+e2,dis2);
   //跑三遍Dijkstra
   //枚举中间点
	for(Reg int i=1;i<=n;i++)
		for(Reg int j=1;j<=m;j++)
			//因为中间点会被计算三次，所以要减去两次
			ans=Min(ans,diss[(i-1)*m+j]+dis1[(i-1)*m+j]+dis2[(i-1)*m+j]-2*a[i][j])/*,printf("I=%d,J=%d,Dis=%d,%d,%d\n",i,j,diss[(i-1)*m+j],dis1[(i-1)*m+j],dis2[(i-1)*m+j])*/;
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Suuon_Kanderu (赞：0)

课间瞄了一眼，没看出来这是什么题/kk。上完课冷静一下发现确实像出题人所说的“经典模型”。

样例非常明显地告诉我们策略：一个二叉形状的闪电是最优的。

我们先分别考虑这两条路径 $O$ 到 $A$ 和 $O$ 到 $B$。$OA$ 和 $OB$ 显然不会交叉。如果有了交叉点 $C$，我们珂以找到一条更优的路径：从 $O$ 到 $C$ 再从 $C$ 到 $A,B$。

得到结论后，然后我们只需要枚举 $C$ 的位置即可。根据 $OC , AC , AB$ 的最短路算出二叉闪电的长度。

标程里用了带优先队列的 SPFA。然而我觉得这样做……很谔谔，于是就用了堆优 dijkstra。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <queue>
#include <vector>
using namespace std;
#define int long long
struct node{
	int x , y , v;
	bool operator < (const node &x) const {
		return x.v < v;
	}
};const int N = 1000 + 5;
int n , m , a , b , c;
int disA[N][N] , disB[N][N] , disC[N][N];
int (*dis)[1005];
priority_queue<node> q;
bool vis[N][N];
int map[N][N] , dd[4][2] = {{0 , 1} , {0 , -1} , {1 , 0} , {-1 , 0}};
bool p(int x , int y) {
	return 0 < x && x <= n && 0 < y && y <= m;
}
void ee(int d[][1005] ,  int x , int y) {//模板
	dis = d;
	memset(vis , 0 , sizeof(vis));
	q.push(node{x , y , map[x][y]});
	while(!q.empty()) {
		node t = q.top();
		q.pop();
		int x = t.x , y = t.y , v = t.v;
		if(vis[x][y])continue;
	//	printf("------------\%d %d\n" , x , y);
		vis[x][y] = true; dis[x][y] = v;
		for(int i = 0; i < 4; i++) {
			int dx = x + dd[i][0]  , dy = y + dd[i][1];
			if(!p(x , y) || vis[dx][dy])continue;
			q.push(node{dx , dy , v + map[dx][dy]});
		}
	}
}
signed main() {
	scanf("%lld%lld%lld%lld%lld" , &n , &m , &a , &b , &c);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			scanf("%lld" , &map[i][j]);
	ee(disA , 1 ,  a);ee(disB , n , b);ee(disC , n , c);
// (1,a) 即为上文中的 O , (n , b) 是 A ， (n , c) 是 B (c++二维数组)
//	for(int i = 1; i <= n; i++ , puts(""))
//		for(int j = 1; j <= m; j++)printf("%lld " , disA[i][j]);
	int ans = 1e18;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m ;j++)
		ans = min(ans , disA[i][j] + disB[i][j] + disC[i][j] - 2 * map[i][j]);
  	//因为 （i,j） 被计算了三遍。
	printf("%lld\n" , ans);
}
```


---

## 作者：星空舞涵 (赞：0)

~~写篇题解纪念一下自己交了60多遍~~

这道题的意思题目已经说的很清楚了就是**求从一个点到另外两个点的路径和的最小值**

我们首先想到的便是最短路算法：

$SPFA$我们要首先排除，毕竟$SPFA$是不能跑网格图的。

所以我们考虑用$dij$算法。

但是一次$dij$算法并无法求出路径和的最小值，所以我们考虑以交点为分界点求出三个点到交点的和再减去重复计算的交点的值。

所以我们就可以从三个点分别跑一次全源最短路，然后枚举每一个点作为交点就可以了。

### 注意：

$1.$这道题卡$int$所以我们要用$longlong$

$2.$建边时，想四周四个点各建一条边，注意不要出界。

$3.$源点到自己的距离不是$0$,而是自己的点值

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long dis[1001*1001+1],cnt,minn=0-1,ans[1001*1001+1];
long long  aa[1001][1001],n,m,a,b,c,head[1010*1010+1];
bool l[1001*1001+1];
struct cxk{
	int to,zhi,next;
}e[4001*1001+1];

inline void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
void add(int p,int y,int z){
	cnt++;
	e[cnt].to=y;
	e[cnt].zhi=z;
	e[cnt].next=head[p];
	head[p]=cnt; 
}
struct node{
	unsigned long long  zhi;
	int xv;
	bool operator <(const node &u)const{
		return u.zhi<zhi;	
	} 
};
priority_queue<node>q;
int main()
{
	cin>>n>>m>>a>>b>>c;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>aa[i][j];
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(i!=1)add((i-1)*m+j,(i-2)*m+j,aa[i-1][j]);
			if(i!=n)add((i-1)*m+j,i*m+j,aa[i+1][j]);
			if(j!=1)add((i-1)*m+j,(i-1)*m+j-1,aa[i][j-1]);
			if(j!=m)add((i-1)*m+j,(i-1)*m+j+1,aa[i][j+1]);
		}
	memset(dis,0x7f,sizeof(dis));
	node x;
	x.zhi=aa[1][a];
	x.xv=a;
	q.push(x);
	dis[a]=aa[1][a];
	while(!q.empty())
	{
		node x=q.top();
		q.pop();
		int y=x.xv;
		long long  z=x.zhi;
		if(l[y]==1)continue;
		else l[y]=1;
		for(int i=head[y];i;i=e[i].next)
		{
			int too=e[i].to;
			if(l[too]==1)continue;
			if(z+e[i].zhi<dis[too])
			{
				dis[too]=z+e[i].zhi;
				node o;
				o.zhi=dis[too];
				o.xv=e[i].to;
				q.push(o);
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans[(i-1)*m+j]=ans[(i-1)*m+j]+dis[(i-1)*m+j];	
	memset(dis,0x7f,sizeof(dis));
	memset(l,0,sizeof(l));
	x.zhi=aa[n][b];
	x.xv=(n-1)*m+b;
	q.push(x);
	dis[(n-1)*m+b]=aa[n][b];
	while(!q.empty())
	{
		node x=q.top();
		q.pop();
		int y=x.xv;
		long long  z=x.zhi;
		if(l[y]==1)continue;
		else l[y]=1;
		for(int i=head[y];i;i=e[i].next)
		{
			int too=e[i].to;
			if(l[too]==1)continue;
			if(z+e[i].zhi<dis[too])
			{
				dis[too]=z+e[i].zhi;
				node o;
				o.zhi=dis[too];
				o.xv=e[i].to;
				q.push(o);
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			ans[(i-1)*m+j]=ans[(i-1)*m+j]+dis[(i-1)*m+j];
			
	memset(dis,0x7f,sizeof(dis));
	memset(l,0,sizeof(l));
	x.zhi=aa[n][c];
	x.xv=(n-1)*m+c;
	q.push(x);
	dis[(n-1)*m+c]=aa[n][c];
	while(!q.empty())
	{
		node x=q.top();
		q.pop();
		int y=x.xv;
		long long  z=x.zhi;
		if(l[y]==1)continue;
		else l[y]=1;
		for(int i=head[y];i;i=e[i].next)
		{
			int too=e[i].to;
			if(l[too]==1)continue;
			if(z+e[i].zhi<dis[too])
			{
				dis[too]=z+e[i].zhi;
				node o;
				o.zhi=dis[too];
				o.xv=e[i].to;
				q.push(o);
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			ans[(i-1)*m+j]=ans[(i-1)*m+j]+dis[(i-1)*m+j];
			ans[(i-1)*m+j]=ans[(i-1)*m+j]-2*aa[i][j];
			minn=min(minn,ans[(i-1)*m+j]);
		}
	cout<<minn;
}
```


---


# [蓝桥杯 2015 国 AC] 穿越雷区

## 题目描述

$X$ 星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。

某坦克需要从 $A$ 区到 $B$ 区去（$A$，$B$ 区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？

已知的地图是一个方阵，上面用字母标出了 $A$，$B$ 区，其它区都标了正号或负号分别表示正负能量辐射区。

例如：

```
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -
```

坦克车只能水平或垂直方向上移动到相邻的区。


## 说明/提示

时限 1 秒, 512M。蓝桥杯 2015 年第六届国赛

## 样例 #1

### 输入

```
5
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -```

### 输出

```
10```

# 题解

## 作者：fish_love_cat (赞：5)

[01 迷宫](https://www.luogu.com.cn/problem/P1141)的弱化版，BFS 版子题，哪要什么最短路……

唯一的区别就是没有墙了，改成只能走不同辐射区域。定义数组存辐射区能量正负极和安全区，所以要用整型变量。初始所有图内的点全部为真能走，走过的点不再重走置为假。所以只要这地方为真而且正负极与当前不同，即可入队。

如果下一步是目的地，直接返回值即可。

代码长这样：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sx,sy,ex,ey;
int f[105][105];
bool b[105][105];
struct wz{
    int x,y,ans;
};
queue<wz> q;
int gx[4]={1,-1,0,0};
int gy[4]={0,0,1,-1};
int bfs(){
    wz a;
    a.x=sx;
    a.y=sy;
    a.ans=0;
    q.push(a);
    b[sx][sy]=false;
    while(!q.empty()){
        a=q.front();
        q.pop();
        for(int i=0;i<4;i++){
            wz xin;
            xin.x=a.x+gx[i];
            xin.y=a.y+gy[i];
            xin.ans=a.ans+1;
            if(xin.x==ex&&xin.y==ey) return xin.ans;
            if(b[xin.x][xin.y]&&f[xin.x][xin.y]!=f[a.x][a.y]) q.push(xin),b[xin.x][xin.y]=false;
        }
    }
    return -1;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            char c;
            cin>>c;
            if(c=='+') f[i][j]=1;
            if(c=='-') f[i][j]=-1;
            if(c=='A') sx=i,sy=j;
            if(c=='B') ex=i,ey=j;
            b[i][j]=true;
        }
    }
    cout<<bfs();
    return 0;
}
```

---

## 作者：Trump__Biden (赞：2)

### 题意：

有一个小车，要从一个坐标走到另一个坐标，只能向上下左右走，并且每两次穿越的地方性质不可相同。

### 思路：

输入数组时记录每个点的性质与起点坐标，然后直接搜索。搜完之后进行回溯，搜到终点后取最小值，最后输出答案。需要注意的点是一个点不能与他的上一个点性质不同，需要进行一下判断。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[110][110];
bool vis[110][110];
int n,ans=1e9,ax,ay;
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
void dfs(int x,int y,int sum){
	if(a[x][y]=='B'){
		ans=min(sum,ans);
		return;
	}
	for(int i=0;i<4;++i){
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(!vis[xx][yy]&&(xx>=1&&xx<=n&&yy>=1&&yy<=n&&a[xx][yy]!=a[x][y])/*判断是否合法*/){
			vis[xx][yy]=true;
			dfs(xx,yy,sum+1);
			vis[xx][yy]=false;
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			cin>>a[i][j];
			if(a[i][j]=='A'){
				ax=i;ay=j;
				vis[ax][ay]=true;
			}
		}
	}
	dfs(ax,ay,0);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：SilverLi (赞：2)

[穿越雷区 の 传送门](https://www.luogu.com.cn/problem/P8628)

让我们求的是 $A$ 区到 $B$ 区的最少移动步数，所以考虑 DFS。

直接用 DFS 模板，然后一点改动就是**交替地穿越正能量辐射区和负能量辐射区**，这个地方其实不用取反，因为开始位置是 `A`，目的地是 `B`，其它位置是 `+` 和 `-`，单纯取反不好操作，其实只需要下一步走到的位置跟当前位置不一样就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,Ax,Ay,Bx,By;
int step=1<<30;
bool vis[107][107];
char mapp[100+7][100+7];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
bool check(int x,int y,int new_x,int new_y){
	if(new_x<1||new_x>n||new_y<1||new_y>n||mapp[x][y]==mapp[new_x][new_y])
		return false;
	return true;
}
void dfs(int x,int y,int cnt){
	if(mapp[x][y]=='B'){
		step=min(step,cnt);
		return;
	}
	for(int i=0;i<4;i++){
		int new_x=x+dir[i][0];
		int new_y=y+dir[i][1];
		if(!vis[new_x][new_y] && check(x,y,new_x,new_y)){
			vis[new_x][new_y]=true;
			dfs(new_x,new_y,cnt+1);
			vis[new_x][new_y]=false;
		}
	}
}

int main(){
	cin>>n;
	memset(vis,0,sizeof(vis));
	for(int i=1;i<n+1;i++){
		for(int j=1;j<n+1;j++){
			cin>>mapp[i][j];
			if(mapp[i][j]=='A'){
				Ax=i;Ay=j;
				vis[Ax][Ay]=true;
			}
		}
	}
	dfs(Ax,Ay,0);
	cout<<(step==1<<30?-1:step)<<endl;
	return 0;
}

```

---

## 作者：Dreamer_Boy (赞：1)

看见另一位大佬用了 DFS 解法，这里给出 BFS。

我们 BFS 从最后一个出现的 `A` 开始，建立一个队列，放入当前的坐标以及步数，然后用 BFS 模板进行搜索，我们只要考虑正、负能量辐射区，**只要当前的与之前的不相同，并且没有走过，还得不超过这个图**，就从这里开始枚举，如果当前是 `B` 的话，就输出当前的步数。最后队列中所有点都走完了还没有能找到一个最短的移动方案就输出没找到。

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1005;

int n;
char a[N][N];
bool v[N][N]; 
int dxy[][2]={{1,0},{0,-1},{0,1},{-1,0}}; 

struct st
{
	int x,y,step;
	st(int a,int b,int c)
	{ 
		x=a,y=b,step=c; 
	}
};

bool check(int x,int y){
	if(x > 0 && x <= n && y > 0 && y <= n) return true;
	return false;
}
void bfs(int x,int y)
{
	queue<st> q;
	st p(x,y,0);
	q.push(p);
	v[x][y]=true;
	while(!q.empty())
	{
		st k=q.front();
		q.pop();
		for(int i=0;i<4;i++)
		{
			int nx=k.x+dxy[i][0],ny=k.y+dxy[i][1];
			if(check(nx,ny)&& !v[nx][ny] && a[k.x][k.y]!=a[nx][ny])
			{
				if(a[nx][ny]=='B'){ 
					cout << k.step+1;
					return; 
				}
				v[nx][ny]=true;
				q.push(st(nx,ny,k.step+1));
			}
		}
	}

	cout<<-1<<endl;
}

int main()
{
	int firstx,firsty;
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]=='A')
				firstx=i,firsty=j;
		}
	bfs(firstx,firsty);
	return 0;
}


```

[AC记录](https://www.luogu.com.cn/record/108528086)。

---

## 作者：Iniaugoty (赞：1)

[传送门](/problem/P8628)。

单源最短路简单题，适合新手练习。

***

## 题意

一个包含 $\texttt A$、$\texttt B$、$\texttt +$、$\texttt -$ 几种字符的方阵，初始时在 $\texttt A$，要到达 $\texttt B$。有一系列移动规则，问从 $\texttt A$ 到 $\texttt B$ 最少移动距离。

***

## 解法

依题意建图，然后从 $\texttt A$ 开始跑一边堆优化 dijkstra 即可。

建图操作：

- $\texttt A$ 或 $\texttt B$：向周围 $4$ 个点各连一条边。

- $\texttt +$：向周围 $4$ 个点中，不是 $\texttt +$ 的点连边（注意这其实还包括 $\texttt A$ 和 $\texttt B$）。

- $\texttt -$：向周围 $4$ 个点中，不是 $\texttt -$ 的点连边。

**注意：一定要判断出界！**

一个小技巧，将点的坐标转为编号的公式：$id=n\times(x-1)+y$。

***

## 代码

码风比较清奇，将就看看吧。

这份代码采用的是链式前向星存图。

```
#include<bits/stdc++.h>
#define N 105
#define inf 0x3f3f3f3f
#define id(x,y) ((x-1)*n+y)//转化公式
using namespace std;
struct star{//链式前向星存图
	int next,to;
}e[N*N<<2];
int head[N*N],cnt;
void add(int u,int v){//连边操作
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
int vis[N*N],dis[N*N];
struct node{
	int u,val;
};
bool operator<(node a,node b){
	return a.val>b.val;
}
void dijkstra(int x){//堆优化 dijkstra
	memset(vis,0,sizeof vis);
	memset(dis,inf,sizeof dis);
	priority_queue<node>pq;
	pq.push(node{x,0});
	dis[x]=0;
	while(!pq.empty()){
		int t=pq.top().u,d=dis[t]+1;
		pq.pop();
		if(vis[t])
			continue;
		vis[t]=1;
		for(int i=head[t];i;i=e[i].next){
			int y=e[i].to;
			if(dis[y]>d)
				dis[y]=d,pq.push(node{y,d});
		}
	}
}
const int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};//方向数组
int n,s1,s2;
char ch[N][N];
signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>ch[i][j];
	//以上是输入，下面的循环是建图部分
	for(int i=1,k=1;i<=n;i++)
		for(int j=1;j<=n;j++,k++)
			if(ch[i][j]=='+')
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(ch[x][y]!='+'&&x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			else if(ch[i][j]=='-')
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(ch[x][y]!='-'&&x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			else if(ch[i][j]=='A'){
				s1=k;
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			}
			else if(ch[i][j]=='B'){
				s2=k;
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			}
	dijkstra(s1);
	cout<<(dis[s2]==inf?-1:dis[s2]);
	return 0;
}
```

***

全文完。

---


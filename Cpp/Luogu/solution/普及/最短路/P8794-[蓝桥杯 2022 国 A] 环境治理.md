# [蓝桥杯 2022 国 A] 环境治理

## 题目描述

LQ 国拥有 $n$ 个城市，从 $0$ 到 $n - 1$ 编号，这 $n$ 个城市两两之间都有且仅有一条双向道路连接，这意味着任意两个城市之间都是可达的。每条道路都有一个属性 $D$，表示这条道路的灰尘度。当从一个城市 A 前往另一个城市 B 时，可能存在多条路线，每条路线的灰尘度定义为这条路线所经过的所有道路的灰尘度之和，LQ 国的人都很讨厌灰尘，所以他们总会优先选择灰尘度最小的路线。

LQ 国很看重居民的出行环境，他们用一个指标 $P$ 来衡量 LQ 国的出行环境，$P$ 定义为：

$$P=\sum \limits_{i=0}^{n-1} \sum \limits_{j=0}^{n-1} d(i,j)$$

其中 $d(i,j)$ 表示城市 $i$ 到城市 $j$ 之间灰尘度最小的路线对应的灰尘度的值。

为了改善出行环境，每个城市都要有所作为，当某个城市进行道路改善时，会将与这个城市直接相连的所有道路的灰尘度都减少 $1$，但每条道路都有一个灰尘度的下限值 $L$，当灰尘度达到道路的下限值时，无论再怎么改善，道路的灰尘度也不会再减小了。

具体的计划是这样的：

- 第 $1$ 天，$0$ 号城市对与其直接相连的道路环境进行改善；
- 第 $2$ 天，$1$ 号城市对与其直接相连的道路环境进行改善；

……
- 第 $n$ 天，$n - 1$ 号城市对与其直接相连的道路环境进行改善；
- 第 $n + 1$ 天，$0$ 号城市对与其直接相连的道路环境进行改善；
- 第 $n + 2$ 天，$1$ 号城市对与其直接相连的道路环境进行改善；

……

LQ 国想要使得 $P$ 指标满足 $P \leq Q$。请问最少要经过多少天之后，$P$ 指标可以满足 $P \leq Q$。如果在初始时就已经满足条件，则输出 $0$；如果永远不可能满足，则输出 $-1$。

## 说明/提示

**【样例说明】**

初始时的图如下所示，每条边上的数字表示这条道路的灰尘度：

![](https://cdn.luogu.com.cn/upload/image_hosting/5lz6auke.png)

此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：

- $d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3$；
- $d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1$；
- $d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0$。

初始时的 $P$ 指标为 $(2 + 3 + 1) \times 2 = 12$，不满足 $P \leq Q = 10$;

第一天，$0$ 号城市进行道路改善，改善后的图示如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/mrhf5wx6.png)

注意到边 $(0, 2)$ 的值减小了 $1$，但 $(0, 1)$ 并没有减小，因为 $L_{0,1} = 2$ ，所以 $(0, 1)$ 的值不可以再减小了。此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：

- $d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 3$，
- $d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 1$，
- $d(2, 0) = 3, d(2, 1) = 1, d(2, 2) = 0$。

此时 $P$ 仍为 $12$。

第二天，1 号城市进行道路改善，改善后的图示如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tjxis3yb.png)

此时每对顶点之间的灰尘度最小的路线对应的灰尘度为：

- $d(0, 0) = 0, d(0, 1) = 2, d(0, 2) = 2$，
- $d(1, 0) = 2, d(1, 1) = 0, d(1, 2) = 0$，
- $d(2, 0) = 2, d(2, 1) = 0, d(2, 2) = 0$。

此时的 $P$ 指标为 $(2 + 2) \times 2 = 8 < Q$，此时已经满足条件。

所以答案是 $2$。

**【评测用例规模与约定】**

- 对于 $30\%$ 的评测用例，$1 \leq n \leq 10$，$0 \leq L_{i,j} \leq D_{i,j} \leq 10$；
- 对于 $60\%$ 的评测用例，$1 \leq n \leq 50$，$0 \leq L_{i,j} \leq D_{i,j} \leq 10^5$；
- 对于所有评测用例，$1 \leq n \leq 100$，$0 \leq L_{i,j} \leq D_{i,j} \leq 10^5$，$0 \leq Q \leq 2^{31} - 1$。

蓝桥杯 2022 国赛 A 组 F 题。

## 样例 #1

### 输入

```
3 10
0 2 4
2 0 1
4 1 0
0 2 2
2 0 0
2 0 0```

### 输出

```
2
```

# 题解

## 作者：wuhan1234 (赞：15)

## 1. 编程思路。
用二分法来求最少要经过多少天后 P 指标可以满足要求。

初始定义治理需要的最少天数 $left=0$，治理需要的最多天数可设为每个城市治理十万天，置 $right=100000\times n$，取 $left$ 和 $right$ 的中值 $mid$，计算经过 $mid$ 天治理后的 P 指标值。若 P 指标值满足要求，说明还有减少治理天数的希望，置 $right=mid-1$；若 P 指标值不满足要求，说明治理的天数不够，需要增加治理天数，置 $left=mid$。

在计算治理 $mid$ 天后的 P 指标值时，采用 Floyed 算法求任意两个城市间的最短距离（最小的灰尘度的值）。

## 2. 源程序。
```c
#include <stdio.h>
#include <string.h>
int d[105][105];
int limit[105][105];
int n;
int min(int a,int b)
{
    return a<b?a:b;
}
int calc(int day)          // 计算经过day 天治理后的P指标值
{
    int tmp[105][105];     // 用于治理的辅助数组
	int i,j,k;
	for (i =0; i<n; i++)
		for (j =0; j<n; j++)
			tmp[i][j]=d[i][j];
	for (i =0; i<n; i++)
	{
		int val = day/n+(day%n>=i+1?1:0);
		for (j =0 ; j<n; j++)
		{
		    tmp[i][j]-=val;
		    if (tmp[i][j]<limit[i][j]) tmp[i][j]=limit[i][j];
		    tmp[j][i]-=val;
		    if (tmp[j][i]<limit[j][i]) tmp[j][i]=limit[j][i];
		}
	}
	for (k =0 ; k<n; k++)        // floyed 算法求最短路径
		for (i =0 ; i<n; i++)
			for (j =0 ; j<n; j++)
				tmp[i][j]=min(tmp[i][j],tmp[i][k]+tmp[k][j]);
	int res =0 ;
	for (i =0; i<n; i++)     // 计算治理后的P指标值
		for (j =0; j<n; j++)
			res+=tmp[i][j];
	return res ;
}
int main()
{
    int q;
	scanf("%d %d",&n,&q);
	int i,j;
	for (i =0; i<n; i++)
		for (j =0 ; j<n; j++)
			scanf("%d",&d[i][j]);
	for (i =0; i<n; i++)
		for (j =0 ; j<n; j++)
			scanf("%d",&limit[i][j]);
	int  left =0,right= 100000*n,ans =-1;
	while (left<=right)
	{
		int mid = (left+right)/2;
		if (calc(mid)<=q)
		{
			right= mid -1;
			ans = mid;
		}
		else
			left=mid+1;
	}
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：行吟啸九州 (赞：2)

题目中要求我们求的指标 $P$，就是任意两点之间的最短距离之和。这个可以用 Floyd 算法求，单次求值复杂度 $O(n^3)$。

考虑暴力模拟，每次道路改善后进行一次暴力计算，由于最多进行 $O(nD_i)$ 次道路改善，故总体复杂度 $O(n^4D_i)$。这个暴力可以优化到 $O(n^3D_i)$，但对正解并无帮助，故不赘述。

由于道路改善发生的次数越多，指标 $P$ 越小。故根据这种单调性，可以采用二分，二分道路改善次数 $x$。已知道路改善次数的情况，我们可以很快的知道图上每一条边当下的边权，然后我们可以用 Floyd 算法计算一下指标 $P$，判断指标 $P$ 是否小于等于 $Q$ 即可，复杂度 $O(n^3 \log K)$，其中 $K$ 为最大的道路改善次数，设成 $10^{9}$ 左右即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 105
#define int long long
#define inf 2002102828
#define mid (l + r >> 1)
#define For(i, j, n) for(int i = j ; i <= n ; ++i)
int n, Q, l, r, ans = inf;
int D[N][N], L[N][N], dis[N][N], down[N];

inline int check(int x){
	int t = x / n, P = 0;
	For(i, 1, n) For(j, 1, n) dis[i][j] = inf;
	For(i, 1, n) dis[i][i] = 0;
	For(i, 1, n) down[i] = t;
	For(i, 1, x - n * t) ++down[i];
	For(i, 1, n) For(j, 1, n) dis[i][j] = max(L[i][j], D[i][j] - down[i] - down[j]);
	For(k, 1, n) For(i, 1, n) For(j, 1, n) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
	For(i, 1, n) For(j, 1, n) P += dis[i][j];
	if(P <= Q) return 1;
	else return 0;
}

signed main(){
	scanf("%lld %lld", &n, &Q);
	For(i, 1, n) For(j, 1, n) scanf("%lld", &D[i][j]);
	For(i, 1, n) For(j, 1, n) scanf("%lld", &L[i][j]);
	l = 0, r = inf;
	while(l <= r){
		if(check(mid)) ans = min(ans, mid), r = mid - 1;
		else l = mid + 1;
	}
	if(ans == inf) printf("-1");
	else printf("%lld", ans);
	return 0;
}

---


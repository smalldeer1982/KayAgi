# [GESP202312 八级] 大量的工作沟通

## 题目描述

某公司有 $N$ 名员工，编号从 $0$ 至 $N-1$。其中，除了 $0$ 号员工是老板，其余每名员工都有一个直接领导。我们假设编号为 $i$ 的员工的直接领导是 $f_i$。

该公司有严格的管理制度，每位员工只能受到本人或直接领导或间接领导的管理。具体来说，规定员工 $x$ 可以管理员工 $y$，当且仅当 $x=y$，或 $x=f_y$，或 $x$ 可以管理 $f_y$。特别地，$0$ 号员工老板只能自我管理，无法由其他任何员工管理。

现在，有一些同事要开展合作，他们希望找到一位同事来主持这场合作，这位同事必须能够管理参与合作的所有同事。如果有多名满足这一条件的员工，他们希望找到编号最大的员工。你能帮帮他们吗？

## 说明/提示

**样例解释 1**

对于第一场合作，员工 $3,4$ 有共同领导 $2$ ，可以主持合作。

对于第二场合作，员工 $2$ 本人即可以管理所有参与者。

对于第三场合作，只有 $0$ 号老板才能管理所有员工。

**数据范围**

对于 $25\%$ 的测试点，保证 $N \leq 50$。 

对于 $50\%$ 的测试点，保证 $N \leq 300$。

对于所有测试点，保证 $3 \leq N \leq 10^5$，$Q \leq 100$，$m \leq 10^4$。


------------
2024/2/8 添加一组 hack 数据。

## 样例 #1

### 输入

```
5
0 0 2 2
3
2 3 4
3 2 3 4
2 1 4```

### 输出

```
2
2
0```

## 样例 #2

### 输入

```
7
0 1 0 2 1 2
5
2 4 6
2 4 5
3 4 5 6
4 2 4 5 6
2 3 4```

### 输出

```
2
1
1
1
0```

# 题解

## 作者：W_s_W (赞：18)

难度约为绿。

前置知识：倍增求最近公共祖先。

---
### 思路
将领导关系抽象为一棵树，要求的就是 $x_1,x_2,\dots,x_m$ 的所有公共祖先中编号最大的。

定义 $\operatorname{lca}(x_1,x_2,\dots,x_m)$ 表示 $x_1,x_2,\dots,x_m$ 的最近公共祖先。  

显然对于每次合作，如果不考虑编号，则 $\operatorname{lca}(x_1,x_2,\dots,x_m)$ 可以成为主持者。  
因此我们可以先求出 $\operatorname{lca}(x_1,x_2,\dots,x_m)$。

可以通过最近公共祖先的性质，求得 $\operatorname{lca}(x_1,x_2,\dots,x_m)=\operatorname{lca}(\operatorname{lca}(\operatorname{lca}(x_1,x_2),x_3)\dots,x_m)$。  

已知最近公共祖先后，所有能成为主持者的人必定都在 $0\sim\operatorname{lca}(x_1,x_2,\dots,x_m)$ 的这条链上，我们只需要求出这条链上编号最大的即可。  
在 dfs 时预处理前缀最大值，就能在后面的询问中 $O(1)$ 求出链上最大值。  

总时间复杂度为 $O(N+Qm\log N)$。

具体细节请看代码。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,q,m;
int fa[100003][30];
int mx[100003],dep[100003];
int l2[100003];
vector<int>edg[100003];

void dfs(int x,int f,int mxn){
	if(x>mxn)mxn=x;
	mx[x]=mxn;  dep[x]=dep[f]+1;//预处理前缀最大值和深度
	if(x!=0){
		fa[x][0]=f;
		for(int i=1;i<=l2[dep[x]];i++)
			fa[x][i]=fa[fa[x][i-1]][i-1];//预处理2^i级祖先
	}
	for(int i=0;i<edg[x].size();i++)
		dfs(edg[x][i],x,mxn);//向下递归
}

int lca(int a,int b){
	if(dep[a]<dep[b])swap(a,b);
	while(dep[a]>dep[b]){//调平深度
		a=fa[a][l2[dep[a]-dep[b]]];
	}
	if(a==b)return a;//特判
	for(int i=l2[dep[a]];i>=0;i--){//求祖先
		if(fa[a][i]!=fa[b][i]){
			a=fa[a][i];
			b=fa[b][i];
		}
	}
	return fa[a][0];
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	l2[0]=-1;
	for(int i=1;i<n;i++){
		l2[i]=l2[i>>1]+1;//预处理对数
		int f;  cin>>f;
		edg[f].push_back(i);//连边
	}
	dfs(0,0,0);
	cin>>q;
	while(q--){
		int F,x;
		cin>>m>>F;
		while(--m){
			cin>>x;
			F=lca(F,x);
		}
		cout<<mx[F]<<'\n';
	}
	return 0;
}
```

---

## 作者：Chengjintian (赞：11)

# 一种时间复杂度 $O(nq)$ 的做法
### DFS，树剖？

~~好吧，我也不知道我的做法算不算树剖（思想），毕竟这么高级的算法对于我这种蒟蒻来说还是太先进了。~~

[题目传送门](https://www.luogu.com.cn/problem/P10113)

索引
>
>Part 0 题意
>
>Part 1 思路
>
>Part 2 代码实现
>
>Part 3 后~~寄~~记


Part 0 题目大意
------------
>
>给出一棵有 $n$ 个节点的树，节点的编号在 $[0,n-1]$ 区间。给出 $q$ 个询问，每次询问 $m$ 个节点的公共祖先中最大编号的节点。
>
>$n\le1\times10^5,m\le1\times10^4,q\le1\times10^2$。

Part 1 思路
-------------

由于父节点的编号不一定比子节点的编号小，所以想知道一个节点的祖先中编号最大的那个，我们就要从此节点遍历到根节点。

由此有一个很暴力的想法，

>对于 $m$ 个点，从当前节点向上遍历，同时开一个数组 $cnt$，每到一个节点，使此节点 $cnt++$，然后 for 循环从 $n-1$ 到 $0$ 扫一遍，当第一次 $cnt_i=m$ 时，输出 $i$。

综上，此暴力算法的时间复杂度是 $O(nmq)$，~~直接高上天~~。

我们发现，暴力算法之所以很暴力，是因为重复搜了很多的节点，换而言之，是因为我们**不清楚每一个节点的子树的子节点都有谁**，所以我们暴力询问了这 $m$ 个节点在谁的子树中。

如果我们可以预处理出每个节点的管辖范围，就可以以 $O(n)$ 的优秀复杂度代替 $O(nm)$ 的暴力复杂度。如何处理呢？接下来介绍一种思想。（应该是树剖的入门用法吧（我不到啊））

![示例](https://cdn.luogu.com.cn/upload/image_hosting/iutz18ug.png)

如上，我们把每个节点**重新命名**，新编号代表着以 dfs 序遍历到的时间。此时，这棵树有一个重要性质：在同一棵树上的节点编号是连续的，比如，在以 $2$ 为根的子树的编号区间是 $[2,4]$，即 $2,3,4$ 都在以 $2$ 为根的子树上,以 $5$ 为根的子树的编号区间是 $[5,8]$。

以 $i$ 为根的子树的编号区间（管辖范围）是 $[i,j]$，其中 $j$ 是 $i$ 的子孙节点中，以 dfs 序遍历到的最晚的节点。

我们用数组 $to$，表示 $i$ 的子孙节点，以 dfs 序遍历到的最晚的节点。那么，节点 $i$ 的管辖范围就是 $[i,to_i]$。

知道了每个节点的管辖范围，我们就可以扫一遍询问的 $m$ 个节点，记录编号极值，随后扫一遍 $n$，看看最大的节点的管辖范围是否与编号极值是包含关系。举个栗子，我们知道了编号极值 $3,6$，意味着我们至少要找一个节点的管辖范围包含 $3,6$，即新编号为 $1$ 的节点可以管辖这些点。

我们需要注意，节点的编号不一定与 dfs 序访问到的时间一样，因此我们要重命名，用数组 $name$，$name_i$ 表示 $i$ 的新编号，即被 dfs 序访问的时间。

还有不懂的地方见代码，代码很直白清楚，很容易理解。

Part 2 代码
----
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,q;
vector<ll>d[(ll)1e5+15];
ll now=1,name[(ll)1e5+15],to[(ll)1e5+15];//now是dfs序的时间，name,to,见上文 
void dfs(ll id){//以 dfs 序遍历时间重命名节点 
	if(d[id].size()==0)to[id]=id;//如果一个节点是叶子节点，则管辖范围是[id,id] 
	for(int i=0;i<d[id].size();i++) {
		ll son=d[id][i];
		name[son]=(++now);//以时间重命名此节点 
		dfs(son);
		if(i+1==d[id].size())to[id]=to[son];//一个节点的to等于访问时间最晚的子节点的子节点的子节点的……
		//通俗的讲，就是递推 
	}
}
int main(){
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);//关闭同步流
	cin>>n;
	for(int i=1;i<n;i++){
		ll a;
		cin>>a;
		d[a].push_back(i);//vector单向建边 
	}
	cin>>q;
	ll m;
	name[0]=now;
	dfs(0);//重命名以预处理出管辖范围 
	for(int i=1;i<=q;i++){
		cin>>m;
		ll a,l=INT_MAX,r=INT_MIN;
		for(int j=1;j<=m;j++){
			cin>>a;
			l=min(l,name[a]);
			r=max(r,name[a]);//确定极值，即管理的人的管辖范围至少要包含[l,r] 
		}
		for(int j=n-1;j>=0;j--)//从 n-1 开始扫，确保编号最大 
			if(l>=name[j] and name[to[j]]>=r){//看看 j 的管辖范围是否包含[l,r] 
				cout<<j<<"\n";
				break; 
			}
	} 
	return 0;
}
```
Part 3 后记
-----

时间复杂度 $O(nq)$

算法考察: dfs


---

## 作者：Mystic_dragon (赞：11)

题意已经很清晰了，$0$ 号节点即为树的根节点，先由根节点遍历整棵树，再预处理出每两个节点之间的**最近公共祖先**。

接下来，对于每组访问，数据加强后，不只是简单的求出这 $m$ 个节点的最近公共祖先。而是这 $m$ 个节点的**最近公共祖先到根节点中编号最大的那个点**。这一步在递归遍历树的时候就可以实现预处理。

这里选用倍增来求解最近公共祖先。
```cpp
#include<bits/stdc++.h>
#include<cstdio>
using namespace std;
typedef long long i64;
int n,f[100010];
int Q,m,g[100010];
int anc[100010][20];
int dis[100010];
int maxnode[100010];
vector <int> G[100010];
void dfs(int u,int fa,int max_value){
	 max_value=max(max_value,u);
	maxnode[u]=max_value;
	for(auto v : G[u]){
		if(v==fa) continue;
		dis[v]=dis[u]+1;
		anc[v][0]=u;
		dfs(v,u,max_value);
	}
}
int LCA(int u,int v){
	if(dis[v]>dis[u]) swap(u,v);
	for(int i=18;i>=0;i--){
		if(dis[anc[u][i]]>=dis[v]){
			u=anc[u][i];
		}
	}
	if(u==v) return u;
	for(int i=18;i>=0;i--){
		if(anc[u][i]!=anc[v][i]){
			u=anc[u][i],v=anc[v][i];
		}
	}
	return anc[u][0];
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++){
		scanf("%d",&f[i]);
		i64 u=f[i],v=i;
		G[u].push_back(v);//无向图 
		G[v].push_back(u);
	}
	dis[0]=1; 
	dfs(0,-1,0);
	for(int j=1;j<=18;j++){
		for(int i=1;i<=n;i++){
			anc[i][j]=anc[anc[i][j-1]][j-1];//LCA预处理 
		}
	}
	scanf("%d",&Q);
	while(Q--){
		int ans;
		scanf("%d",&m);
		for(int i=1;i<=m;i++){
			scanf("%d",&g[i]);
			if(i==1) ans=g[i];
			else ans=maxnode[LCA(ans,g[i])];
		}
		printf("%d\n",ans);
	}
	return 0;
}




```

---

## 作者：T_TLucas_Yin (赞：2)

是双倍经验。依旧是最近公共祖先的模板题，这里由于数据量更大了，必须使用倍增的方法优化。这样一次查找的时间复杂度是 $O(\log n)$。

对于给定的一组 $m$ 个员工，我们先求出能同时管理前两位员工的职位最低（深度最大）的领导，然后再求出能同时管理这位领导与第三名员工的职位最低的领导，以此类推，最后求到的就是能同时管理这 $m$ 个员工的职位最低的领导，也就是它们在职位树上的最近公共祖先。

找到最近公共祖先后其实并没有完。我们知道这个最近公共祖先的祖先结点也都是给出的 $m$ 名员工的公共领导，题目并没有表示最近的公共祖先一定是编号最大的，但让我们求的是编号最大的公共祖先。所以还要顺着最近的祖先往根节点的路径找其中编号最大的结点。由于倍增为我们省下了很多时间，所以这里可以暴力找。

```cpp
#include<bits/stdc++.h>
using namespace std;
int di[500005],f[500005][25],dep[500005];
int ver[1000005],ne[1000005],head[1000005],tot;
int n,t,m,root,a[1000005],x,b,cnt,maxn=20;
void add(int x,int y){
    ver[++tot]=y,ne[tot]=head[x],head[x]=tot;
}
void dfs(int x){
    for(int i=head[x];~i;i=ne[i]){
        int y=ver[i];
        if(!dep[y]) dep[y]=dep[x]+1,f[y][0]=x,dfs(y);
    }
}
void init(int root){
    dep[root]=1,dfs(root);
    for(int k=1;k<=maxn;k++) for(int i=1;i<=n;i++)
        f[i][k]=f[f[i][k-1]][k-1];
}
int lca(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    int d=dep[x]-dep[y];
    for(int k=0;k<=maxn;k++) if(1<<k&d) x=f[x][k];
    if(x==y) return x;
    else{
        for(int k=maxn;k>=0;k--)
            if(f[x][k]!=f[y][k]) x=f[x][k],y=f[y][k];
        if(x==y) return x;
        else return f[x][0];
    }
}//以上为一个字符都没改的 LCA 模板
int main(){
    memset(head,-1,sizeof(head));
    cin>>n;
    for(int i=1;i<n;i++){
        cin>>a[i];
        add(a[i],i),add(i,a[i]);
    }
    init(0);
    cin>>t;
    while(t--){
        cin>>m>>x;
        for(int i=1;i<m;i++){
            cin>>b;
            x=lca(x,b);//依次找到上一个最近祖先与这个节点的最近祖先
        }
        for(int i=x;i!=0;i=a[i]) x=max(x,i);//往根节点找编号最大的
        cout<<x<<"\n";
    }
    return 0;
}
```

---

## 作者：zyn_ (赞：2)

前置芝士：倍增求 LCA。

对 $1\le i\le N-1$，将 $i$ 与 $f_i$ 连边，则 $N$ 名员工的关系形成一棵以 $0$ 为根的树。

$x$ 可以管理 $y$，意思就是 $x$ 是 $y$ 的祖先。于是，若 $x$ 可以管理 $y_1,y_2,\dots,y_m$，则 $x$ 是所有 $y_i$ 的祖先，即这些 $y_i$ 的 LCA 的祖先（这里祖先包括自己），也就是，结点 $0$ 到所有 $y_i$ 的 LCA 的路径上的点。

于是，预处理出每个点 $i$ 到结点 $0$ 的路径上，结点编号的最大值。现在的问题就是求出多个点的 LCA。

以下令结点 $y_1,y_2,\dots,y_m$ 的 LCA 为 $f(y_1,y_2,\dots,y_m)$。

### 方法一

对于 $y_1,y_2,\dots,y_m$，有 $f(y_1,y_2,\dots,y_m)=f(f(y_1,y_2),y_3,y_4,\dots,y_m)$。也就是说，这样实现：

```cpp
int ans=y[1];
for(int i=2;i<=m;++i)ans=lca(ans,y[i]);
printf("%d\n",ans);
```

这是 $O((\sum m)\log N)$ 的。

### 方法二

有一个结论：**多个点的 LCA，等于其中 dfs 序最小的点与 dfs 序最大的点的 LCA。**

结点 $i$ 的 dfs 序，指在 dfs 过程中结点 $i$ 是第几个被遍历到的。

dfs 序有一个性质：**子树中的结点，dfs 序为连续的正整数。**

下面证明上述结论。

使用反证法。若结论不成立，不妨设在所有 $y_i$ 中，$y_1$ 的 dfs 序最小，$y_2$ 的 dfs 序最大。设 $f(y_1,y_2,\dots,y_m)=p$，$f(y_1,y_2)=q$。由 LCA 的定义知 $p$ 为 $q$ 的祖先。

若 $p\neq q$，则由于 $y_1,y_2$ 在子树 $q$ 中，知 $y_1,y_2$ 在 $p$ 的同一子树中。

而由 $f(y_1,y_2,\dots,y_m)=p$ 知存在另一个 $y_k$，与 $y_1,y_2$ 不在 $p$ 的同一子树中。

再由 dfs 序的性质，$y_1,y_2$ 所在子树的 dfs 序为连续正整数，故 $y_k$ 的 dfs 序不能在 $y_1$ 与 $y_2$ 的 dfs 序之间。

这与 $y_1$ 的 dfs 序最小，$y_2$ 的 dfs 序最大相矛盾！

结论得证。

于是，只需预处理出所有结点的 dfs 序。询问多个点的 LCA 时，只需找出 dfs 序最小与最大的结点求 LCA 即可。

这样做单次询问 $O(m+\log N)$，$Q$ 次询问 $O((\sum m)+Q\log N)$。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100009
int n,x,q,m,a,dfn[N],mx,s,mn,t,cnt,fa[N][20],dep[N],id[N];
vector<int> v[N];
inline void addedge(int a,int b){v[a].push_back(b),v[b].push_back(a);}
void dfs(int p,int f){
	dfn[p]=++cnt;
	fa[p][0]=f,dep[p]=dep[f]+1,id[p]=max(id[f],p);
	for(int i=1;i<=18;++i)fa[p][i]=fa[fa[p][i-1]][i-1];
	for(int i:v[p])if(i!=f)dfs(i,p);
}
int lca(int a,int b){
	if(dep[a]<dep[b])a^=b^=a^=b;
	for(int i=18;i>=0;--i)if(dep[a]-(1<<i)>=dep[b])a=fa[a][i];
	if(a==b)return a;
	for(int i=18;i>=0;--i)if(fa[a][i]!=fa[b][i])a=fa[a][i],b=fa[b][i];
	return fa[a][0];
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;++i)scanf("%d",&x),addedge(x+1,i+1);
	dfs(1,0);
	scanf("%d",&q);
	while(q--){
		scanf("%d",&m);
		mn=0x3f3f3f3f,mx=0;
		for(int i=1;i<=m;++i){
			scanf("%d",&a);++a;
			if(dfn[a]>mx)mx=dfn[a],s=a;
			if(dfn[a]<mn)mn=dfn[a],t=a;
		}
		printf("%d\n",id[lca(s,t)]-1);
	}
	return 0;
}
```

---

## 作者：lqsy002 (赞：1)

## 题目大意

给定一棵有 $n$ 个节点，其中根节点为 $0$ 的树，有 $Q$ 次询问，每次询问给出一个长度为 $m$ 的序列，找出序列中所有点的最近公共祖先。[题目链接](https://www.luogu.com.cn/problem/P10113)。

## 解题思路

本题为 [P10109](https://www.luogu.com.cn/problem/P10109) 的加强版。

倍增法求 LCA。

这题求的是多个节点的最近公共祖先，只需要先求出每个节点与其他节点的最近公共祖先，再找最大编号即可。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e5+10;
int n,q,m,head[maxn],idx,dep[maxn],fa[maxn][25],ans;
struct edge{
    int to;
    int nxt;
}e[maxn*2];
void add(int u,int v){
    e[++idx]={v,head[u]};
    head[u]=idx;
}
void dfs(int u,int f){
    dep[u]=dep[f]+1;
    for(int i=1;i<=20;++i)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v!=f)
            dfs(v,u);
    }
}
int lca(int a,int b){
    if(dep[a]<dep[b])
        swap(a,b);
    for(int i=20;i>=0;--i)
        if(dep[fa[a][i]]>=dep[b])
            a=fa[a][i];
    if(a==b)
        return a;
    for(int i=20;i>=0;--i)
        if(fa[a][i]!=fa[b][i]){
            a=fa[a][i];
            b=fa[b][i];
        }
    return fa[a][0];
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<n;++i){
        cin>>fa[i][0];
        add(fa[i][0],i);
        add(i,fa[i][0]);
    }
    dfs(0,0);
    cin>>q;
    while(q--){
        int p,p1;
        cin>>m>>p;
        for(int i=2;i<=m;++i){
            cin>>p1;
            p=lca(p,p1);
        }
        ans=p;
        while(p){
            ans=max(ans,fa[p][0]);
            p=fa[p][0];
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：Fp0cY1tZ6Nn4Rd_ (赞：0)

### 思路
这题是 [P10109](/problem/P10109) 的加强版，要用树上最近公共祖先做。

由于数据量较大，所以要用倍增优化的 LCA。

> 最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。 ——OI Wiki

我们首先想到的肯定就是暴力往上爬，直到它们相遇。但是这个算法在数据量很大的时候就会超时。因此我们有了倍增优化的 LCA。

倍增是什么呢？顾名思义，就是每次翻倍跳。但是在这里，我们不是从小到大跳，而是从大到小跳。

那么这个算法怎么实现呢？我们先保存每个节点的深度和祖先节点。其中 `fath[x][i]` 表示节点 $x$ 的第 $2^i$ 个祖先，可以用 dfs 预处理出来，`from[x]` 表示节点 $x$ 的父节点，`depth[x]` 表示节点 $x$ 的深度。

现在我们就我们可以开始求 LCA 了。第一步，我们要将 $u,v$ 两点跳转到同一深度。计算出 $u,v$ 的深度之差 $y$，对 $y$ 进行二进制的拆分，也就是将 $y$ 次跳转优化为 $y$ 的二进制中所含的 $1$ 的个数次跳转。如果两点相遇则问题解决。第二步，我们从可能的最大步数开始一直进行尝试，不断减半，如果跳到的地方相同就不跳，否则就跳，再一步一步往上调整，直到找到最近公共祖先。

这题求的是多个节点的最近公共祖先，只需要让每个节点与其他节点的最近公共祖先求最近公共祖先再找最大编号即可。

### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
using namespace std;
const int N=5e5+5;
int fath[N][20],from[N],depth[N],n,m,c,k,x,y,q,u,v,t,ans,root=0;
vector<int> G[N];
void getDepth_dfs(int root){
	for(unsigned i=0;i<G[root].size();i++){
		int next=G[root][i];
		depth[next]=depth[root]+1;
		getDepth_dfs(next);
	}
}
void getParents(){
	for(int up=1;(1<<up)<=n;up++)
		for(int i=1;i<=n;i++)
			fath[i][up]=fath[fath[i][up-1]][up-1];
}
int LCA(int u,int v){
	if(depth[u]<depth[v])
		swap(u,v);
	int i=-1;
	while((1<<(i+1))<=depth[u])
		i++;
    for(int j=i;j>=0;j--)
        if(depth[u]-(1<<j)>=depth[v])
            u=fath[u][j];
    if(u==v) return u;
    for(int j=i;j>=0;j--) {
        if(fath[u][j]!=fath[v][j]) {
            u=fath[u][j];
            v=fath[v][j];
        }
    }
    return fath[u][0];
}
int main(){
	ios::sync_with_stdio(false);
	memset(fath,-1,sizeof(fath));
	memset(from,-1,sizeof(from));
	memset(depth,-1,sizeof(depth));
	cin>>n;
	for(int i=1;i<=n-1;i++){
		cin>>x;
		G[x].push_back(i);
		fath[i][0]=x;
		from[i]=x;
	}
	depth[root]=1;
	getDepth_dfs(root);
	getParents();
	cin>>m;
	while(m--){
		cin>>c>>k;
		t=k;c--;
		while(c--){
			cin>>k;
			t=LCA(t,k);
		}
		ans=t;
		while(t!=0){
			t=fath[t][0];
			ans=max(ans,t);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：int32 (赞：0)

本质上与 P10109 是同一道题。

题目给出的公司结构是一颗以 $0$ 为根节点的树，因此对于每个合作询问的答案即为参与这次合作的员工的**编号最大的公共祖先**。

考虑先求出这些结点的最近公共祖先，再从它向父亲暴力跳到根，找其中最大编号的结点即为答案。

与 P10109 不同的是本题的 $n$ 和 $m$ 都扩大了，使用暴力求 LCA 肯定会 TLE。改用倍增或树链剖分求 LCA 可以通过。

```cpp
//
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
const int S=25;
int n, m, T;
int dep[N];
int fa[N][S];
int lg[N];
int head[N], cntedge;
struct node{int v, nxt;}e[N<<1];
void edge(int U, int V){
    e[++cntedge]=(node){V,head[U]};
    head[U]=cntedge;
}
void dfs(int u, int f){
    dep[u]=dep[f]+1;
    for(int i=1;i<=lg[dep[u]];i++)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(int i=head[u];i;i=e[i].nxt){
        int to=e[i].v;
        if(to!=f) dfs(to,u);
    }
}
int lca(int x, int y){
    if(dep[x]<dep[y]) swap(x,y);
    while(dep[x]>dep[y])
        x=fa[x][lg[dep[x]-dep[y]]-1];
    if(x==y) return x;
    for(int i=lg[dep[x]]-1;i>=0;i--)
        if(fa[x][i]!=fa[y][i]){
            x=fa[x][i];
            y=fa[y][i];
        }
    return fa[x][0];
    // while(x!=y){
    //     if(dep[x]>=dep[y]) x=fa[x][0];
    //     else y=fa[y][0];
    // }
    // return x;
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        lg[i]=lg[i-1]+(1<<lg[i-1]==i);
    for(int i=1;i<n;i++){
        cin>>fa[i][0];
        edge(fa[i][0],i);
        edge(i,fa[i][0]);
    }
    dfs(0,0);
    cin>>T;
    while(T--){
        int ans=0;
        cin>>m;
        int _;
        cin>>_;
        int l=_;
        for(int i=2;i<=m;i++){
            cin>>_;
            l=lca(l,_);
        }
        ans=l;
        while(l){
            ans=max(ans,fa[l][0]);
            l=fa[l][0];
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---


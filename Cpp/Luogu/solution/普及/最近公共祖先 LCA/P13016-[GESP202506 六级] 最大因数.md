# [GESP202506 六级] 最大因数

## 题目描述



给定一棵有 $10^9$ 个结点的有根树，这些结点依次以 $1, 2, \dots, 10^9$ 编号，根结点的编号为 $1$。对于编号为 $k$（$2 \leq k \leq 10^9$）的结点，其父结点的编号为 $k$ 的因数中除 $k$ 以外最大的因数。

现在有 $q$ 组询问，第 $i$（$1 \leq i \leq q$）组询问给定 $x_i, y_i$，请你求出编号分别为 $x_i, y_i$ 的两个结点在这棵树上的距离。两个结点之间的距离是连接这两个结点的简单路径所包含的边数。


## 说明/提示


对于 $60\%$ 的测试点，保证 $1 \leq x_i, y_i \leq 1000$。

对于所有测试点，保证 $1 \leq q \leq 1000$，$1 \leq x_i, y_i \leq 10^9$。

## 样例 #1

### 输入

```
3
1 3
2 5
4 8```

### 输出

```
1
2
1```

## 样例 #2

### 输入

```
1
120 650```

### 输出

```
9```

# 题解

## 作者：weifengzhaomi (赞：16)

## 思路：

题目给出的树很特别，一个点的父亲节点是这个点的编号的最大因数（不包括根）。现在，我们我们要求出两点的距离。

那么，我们如何计算距离？

我们可以这样想，我们求出 $x$ 点和 $y$ 点到根的路径，然后比较两条路径的公共前缀，直到有不同的编号，我们就可以算出两点的距离。

那么，我们如何求出到根的路径？

我们可以设计一个函数，该函数每次传进一个参数，然后返回这个数的最大因数（不能是它本身），这个应该很好写，不过多描述。

然后，我们每次都把 $x$ 和 $y$ 传进这个函数里，用两个`vector`记录每次返回的值，然后赋值给 $x$ 和 $y$。

那么两者结合起来就是这道题的解决方案。

总时间复杂度：$O(q\sqrt{\max(x,y))}$。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,x,y;
int f(int x){//寻找最大因数
	if (x == 1) return 0;
	if (x % 2 == 0) return x / 2;
	for (int i = 3;i * i <= x;i += 2) if (x % i == 0) return x / i;
	return 1;
}
vector<int> check(int x){//生成路径
	vector<int> s;
	while (x != 0) s.push_back(x),x = f(x);
	return s;
}
int clec(int x,int y){//计算距离
	vector<int> a = check(x),b = check(y);
	int i = a.size() - 1,j = b.size() - 1;
	while (i >= 0 && j >= 0 && a[i] == b[j]) i--,j--;
	return i + j + 2;
}
int main(){
	scanf("%d",&t);
	while (t--) scanf("%d%d",&x,&y),printf("%d\n",clec(x,y));
}
```

---

## 作者：xw_qwq (赞：8)

[题目传送门。](https://www.luogu.com.cn/problem/P13016)

#### 前言

GESP 6 级真的好水啊，场上一个小时就出来了。

~~比 5 级简单。~~

upd on 2025.8.21，发现一个错误，更正。

#### 题目思路

lca 最近公共祖先问题~~暴力即可通过的~~削弱版。

两个点在树上的距离，可以看作两个点到它们的最近公共祖先的距离之和。观察到数据范围小，每个节点的父节点的值最多是这个节点的 $\frac{1}{2}$，所以可以直接暴力模拟往上跳的过程，统计跳的次数之和，即为答案。

给出两个点 $l$ 和 $r$，他们的父节点分别为 $fl$ 和 $fr$，跳的过程如下：
- 当 $l < r$ 时，$l = fl$。
- 当 $l > r$ 时，$r = fr$ 。
- 当 $l = r$ 时，说明已经跳好，返回答案即可。

这样可以有效地求出最近公共祖先。

另外求父节点时运用了类似质数筛的思想，因为往后就重复了，所以枚举最小因数只需从 $2$ 枚举到 $\sqrt n$ 即可。注意判断为质数的情况，直接跳到根节点即可。
#### code

```cpp
#include <bits/stdc++.h>
using namespace std;
int jump(int x)
{
	for (int i = 2; i <= sqrt(x); i++)
		if (x % i == 0)
			return x / i;
	return 1;
}
int lca(int l, int r)
{
	int cnt = 0;
	while (l != r)
	{
		if (l < r)
			r = jump(r);
		else
			l = jump(l);
		cnt++;
	}
	return cnt;
}
void solve()
{
	int q;
	cin >> q; 
	while (q--)
	{
		int l, r;
		cin >> l >> r;
		cout << lca(l, r) << "\n";
	}
}
int main()
{
	solve();
	return 0;
}
```

---

## 作者：wky_wsy_ (赞：4)

六级考生前来报到。

---

先说两句题外话：当时考场上 T1 给我拖了 20 分钟才看出来是完全背包，T2 一刻钟竟然就切掉了。（话说这好像是我场切的唯二两道黄）。    
Upd on 7.1：有一道降橙了。

---

# 题目分析
首先这道题的第一句话很吓人：给定一棵有 $10^9$ 个结点的有根树。并且对于所有的数据，输入的 $x$ 和 $y$ 都是有可能卡数据上限 $10^9$。所以，即使优化到 $O(n)$ 暴力一定会 TLE。  

那么该怎么使用一些简单的东西把它优化一下呢？

首先你可能会想到质因数分解，但很明显：对于这道题，质因数分解只是**使用了它的思路**。  

---

到这里为止，请你自己尝试按照质因数分解的板子写一下正解，不过改动可能非常大。  

---

# 打通大动脉
首先我们仔细想一想，质因数分解使用了**迭代**进行不断缩小问题范围，最终得出结论。而题目中有一句：其父结点的编号为 $k$ 的因数中除 $k$ 以外**最大的因数**。那我们不就可以每次用一个上限 $O(\sqrt{n})$ 的循环枚举出当前节点编号中最大的因数（不包括自己），再加上一个上限是 $O(\log_2n)$ 的迭代求出每个节点的所有父节点，存入任意可遍历的容器，对另一个询问的节点进行同样操作，最后暴力枚举两个节点的**最近公共祖先**不就完事了吗？  

---

# 关于时间复杂度
首先我们需要明确，这个算法的单组询问时间复杂度最高是 $O(\sqrt{n}\log_2n)$。  
那么你可能会问：$10^9$ 开个根号是三万多，取 $\log$ 也有将近 $30$，再乘一下询问次数的 $1000$ 不就炸了吗？  
但请你注意一下细节：单组询问时间复杂度里的 $O(\sqrt{n})$ 和 $O(\log_2n)$ 最坏情况下只能跑满一个。也就是当一个节点编号是 $2$ 的正整数次方时，$O(\log_2n)$ 会跑满，但是每次枚举到 $2$ 就能得出这个数的最大因数；当一个节点的编号是质数时，$O(\sqrt{n})$ 跑满后就到 $1$ 号根节点了，不可能继续往下跑。所以这个算法炸不了。  

---

# 考场上的小代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int q,x,y;
int maxys(int a){//获取每个数的最大因数，从小到大枚举可以有效控制时间复杂度
    for(int i=2;i*i<=a;i++){
        if(a%i==0){
            return a/i;
        }
    }
    return 1;
}
vector<int> wksy(int a){//迭代求出每个节点的所有父节点
    vector<int> ans;
    ans.push_back(a);
    while(a!=1){
        int b=maxys(a);
        ans.push_back(b);
        a=b;
    }
    return ans;
}
signed main(){
    cin.tie(0)->sync_with_stdio(0);
    cin>>q;
    while(q--){
        cin>>x>>y;
        vector<int> a=wksy(x);
        vector<int> b=wksy(y);
        int la=a.size(),lb=b.size();
        for(int i=0;i<la;i++){//暴力枚举LCA
            for(int j=0;j<lb;j++){
                if(a[i]==b[j]){
                    cout<<i+j<<'\n';
                    goto hhh;
                }
            }
        }
        hhh:;
    }
    return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

观察题目，很容易发现这是一个最近公共祖先（LCA）的问题，但是点的数量为 $10^9$，显然我们无法创建这么多节点。

考虑 LCA 算法的过程，求 $a, b$ 的最近公共祖先时，深度较深的点先往上跳，当两个点深度相同时，再一起往上跳，直到相同为止。

同样本道题可以用此思路，由于我们无法快速算出深度，那么可以考虑，当两个数字不相同时，数值大的先往上跳，直至相同。

因为往上跳是一个变小的过程，最终定会相遇，并且代价最小。

### AC_Code

```python
T = int(input())

def get(x):
    i = 2
    while i <= x // i:
        if x % i == 0:
            return x // i
        i += 1
    return 1

for _ in range(T):
    a, b = map(int, input().split())
    res = 0
    while a != b:
        if a > b:
            a = get(a)
        else:
            b = get(b)
        res += 1
    print(res)
```

---

## 作者：Enoch2013 (赞：3)

# 前言
这其实挺简单的（我赛时用了不到八分钟就通过了）。

# 思路
对于每个节点 $k$，我们要寻找它的父亲，我们可以找到它的最小因数 $p$，然后 $k \div p$ 即可得到父亲，代码如下：

```cpp
int get_fa(int x) // 寻找节点x的父亲
{
    int res = 0;
    for (int i = 2; i <= x / i; i++) if (!(x % i)) { res = i; break; } // 找到最小因数（从2开始算）
    if (res == 0) res = 1; // 如果x为质数，将它的父亲设为1
    else res = x / res; // 得到最大因数（注意：最大因数不包含x本身）
    return res;
}
```

对于节点 $x$ 和节点 $y$，我们将它们之间的路径记为 $x \rightarrow lca_{x, y} \rightarrow y$，长度为 $cnt_{x \rightarrow lca_{x, y}} + cnt_{lca_{x, y} \rightarrow y}$，我们可以一边寻找 $lca_{x,y}$ 一边计算路径长度即可，代码如下：

```cpp
int get_ans(int x, int y)
{
    int cnt_x = 0, cnt_y = 0;
    if (x == y) return 0; // 如果相等，无需计算
    if (x > y) swap(x, y); // 保证y的深度大于x
    while (x != y) // 一步一步往上爬
        if (y > x) y = get_fa(y), cnt_y++; // 边爬边计算
        else x = get_fa(x), cnt_x++; // 边爬边计算
    return cnt_x + cnt_y; // 返回总长
}
```

最后附上无注释的代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int q, x, y;
int get_fa(int x)
{
    int res = 0;
    for (int i = 2; i <= x / i; i++) if (!(x % i)) { res = i; break; }
    if (res == 0) res = 1;
    else res = x / res;
    return res;
}
int get_ans(int x, int y)
{
    int cnt_x = 0, cnt_y = 0;
    if (x == y) return 0;
    if (x > y) swap(x, y);
    while (x != y)
        if (y > x) y = get_fa(y), cnt_y++;
        else x = get_fa(x), cnt_x++;
    return cnt_x + cnt_y;
}
signed main()
{
    cin >> q;
    while (q--)
    {
        cin >> x >> y;
        cout << get_ans(x, y) << endl;
    }
    return 0;
}
```

---

## 作者：Heyg_future (赞：2)

# P13016 [GESP202506 六级] 最大因数
## [题目在此](https://www.luogu.com.cn/problem/P13016)
气死我也，本次考级，本废物考七级，结果七级第二题，调了两个小时没调出来，一出考场就发现自己哪里写错了，~~只能来拿这道六级题出气~~。

## solution
首先，看到树上简单路径，马上想到最近公共祖先，可是本题显然不可以建树，但是可以仿照 LCA 的思想来写。注意，LCA 意思为最近公共祖先。

进来的 $x$ 与 $y$ 像求 LCA 一样分别向上跳。因为一个不是 $1$ 的数的最大因数一定比它小。所以我们便可以将较大的那个数向上跳，这样我们在它们没有相遇的时候反复将较大的那个数向上跳，直到它们相遇为止。

简单证明一下，**因为一个不是 $1$ 的数的最大因数一定比它小，那么较大那个数的在这棵树里的深度一定在这两个数的 LCA 下方，所以我们将大的那个数往上跳就是在不断接近 LCA**，所以这样一定是正确的。

至于找一个数的最大因数，代码非常简单。只需要找到最小的一个除了 $1$ 以外能被它整除的数。那么这个数就是它的最大因数。

那么本题的全部代码就如下。代码非常简洁且好看。
```cpp
#include<iostream>
#include<cmath>
using namespace std;
int q,x,y,ans;
int ys (int x) {
	for (int i=2;i<=sqrt(x);i++) {
		if (x%i==0) {
			return x/i;	
		}
	}
	return 1;
}
signed main() {
	cin>>q;
	for (;q--;) {
		ans=0;
		cin>>x>>y;
		while (x!=y) {
			while (x>y) x=ys(x),ans++; 
			while (x<y) y=ys(y),ans++;
		}
		cout<<ans<<"\n";
	}
    return 0;
}

```
跑的非常快，如果加个记忆化就更快了。

---

## 作者：SRQ_321 (赞：2)

### 思路

直接跑一遍 $\operatorname{dfs}$。

但是在知道怎们跑 $\operatorname{dfs}$ 前，我们要知道怎们找父节点？我们可以用质数判定法来确认：

```cpp
int f(int x){
    for(int i=2;i*i<=x;i++){
        if(x%i==0){
            return x/i;//x的父节点是x/i(i尽量小)
        }
    }
    return 1;//质数的父节点是1
}
```

定义 $\operatorname{dfs}$ 有 3 个参数：$x$，$y$，$len$。

其中 $len$ 是当前步数。

分四种情况讨论：

1. $x=y$ 时，完成目标 (两点相遇)，返回 $len$。
2. $x \bmod y = 0$ 时，$y$ 是 $x$ 的祖先，只有 $x$ 动，返回 $dfs(f(x),y,len+1)$。
3. $y \bmod x = 0$ 时，$x$ 是 $y$ 的祖先，只有 $y$ 动，返回 $dfs(x,f(y),len+1)$。
4. 以上都不成立时，两个都动，返回 $dfs(f(x),f(y),len+2)$。

输出 $dfs(x,y,0)$ 即可。

```cpp
include<bits/stdc++.h>
using namespace std;
int q,x,y;
int f(int x){
    for(int i=2;i*i<=x;i++){
        if(x%i==0){
            return x/i;
        }
    }
    return 1;
}
int dfs(int x,int y,int len){
    if(x==y){
        return len;
    }
    if(x%y==0){
        return dfs(f(x),y,len+1);
    }
    if(y%x==0){
        return dfs(x,f(y),len+1);
    }
    return dfs(f(x),f(y),len+2);
}
int main(){
    cin>>q;
    while(q--){
        cin>>x>>y;
        cout<<dfs(x,y,0)<<'\n';
    }
    return 0;
}
```

---

## 作者：A7F3jK9pR0xf_ (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P13016)

### 思路

设 $k$ 质因数分解后的 $k=\Pi_{i=1}^m\alpha_i$($\alpha$从小到大排，可重复)，那么根据整数的唯一分解定理，显然它的第 $\beta$ 级祖先为 $\Pi_{i=\beta+1}^m\alpha_i$。那就好做了，先给 $x$ 和 $y$ 质因数分解，存到 ```mp[0]``` 和 ```mp[1]``` 里面，计算交集 ```s```，想算 LCA 那么只需要计算交集里最大的下标 $id$ 使得 ```mp[0][s[id]]``` 和 ```mp[1][s[id]]``` 不相等即可。答案就是 $\sum_{i=1}^{id-1}mp_{0,s_i}+mp_{1,s_i}+|mp_{0,s_{id}}-mp_{1,s_{id}}|$，时间复杂度 $O(q\sqrt n\log\sqrt n)$，$\log$ 是 map 贡献的。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
#define fst first
#define sed second
#define ins insert
#define cl clear
map<int, int> mp[2];
set<int> s;
il void qwq(int x, int id)
{
	for(int i = 2;i <= x / i;++i)
	{
		while(x % i == 0)
		{
			mp[id][i]++;
			s.ins(i);
			x /= i;
		}
	}
	if(x > 1)
	{
		mp[id][x]++;
		s.ins(x);
	}
}
int main()
{
	int q;cin >> q;
	while(q--)
	{
		s.cl(), mp[0].cl(), mp[1].cl();
		int x, y;cin >> x >> y;
		if(x == y)
		{
			cout << "0\n";
			continue;
		}
		qwq(x, 0);qwq(y, 1);
		int cnt = 0, id = 0;
		for(auto i : s)
			if(mp[0][i] != mp[1][i]) id = i;
		for(auto i : s)
		{
			if(i > id) break;
			if(i == id) cnt += abs(mp[0][i] - mp[1][i]);
			else cnt += mp[0][i] + mp[1][i];
		}
		cout << cnt << "\n";
	} 
	return 0;
}
```

---

## 作者：easy42 (赞：1)

这不很好想吗，哪里有黄啊。

首先，题目显然叫我们求出两点之间的最近公共祖先，且要求出 $a,b$ 与它们之间祖先的长度，使用暴力跳祖先的方法，找到祖先则需要预处理出 $\sqrt{10^9}$ 内的质数，可以把时间复杂度做到 $O(q \times primes \times ans)$，其中 $primes$ 是 $\sqrt{10^9}$ 内的质数个数。

时间复杂度与 $ans$ 有关，但是答案实际上非常小，应该是在 $a=2^x$ 和 $b=3^y$ 时取到最大，不会超过 $30$。

然后第二个是 $\sqrt{10^9}$ 内的质数个数，这个也大约在几千左右。

于是就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int q;
int f[100005],cnt;
int check(int x){
	if(x<=1) return 0;
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0) return 0;
	}
	return 1;
}
signed main(){
	cin>>q;
	for(int i=2;i<=sqrt(1e9);i++){
		if(check(i)) f[++cnt]=i;
	}
	while(q--){
		int a,b;
		cin>>a>>b;
		int ans=0;
		while(1){
			if(a==b) break;
			if(a>b){
				if(check(a)){
					a=1;
				}
				for(int i=1;i<=cnt;i++){
					if(a%f[i]==0){
						a=a/f[i];
						break;
					}
				}
			}
			else{
				if(check(b)){
					b=1;
				}
				for(int i=1;i<=cnt;i++){
					if(b%f[i]==0){
						b=b/f[i];
						break;
					}
				}				
			}
			ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：b__b (赞：1)

定义 $\mathrm{depth}_i$ 为树上第 $i$ 个结点的深度（根节点的深度为 $0$），结点 $x$ 和结点 $y$ 的最近公共祖先为 $\mathrm{LCA}(x,y)$，树上的结点 $x$ 和结点 $y$ 的距离 $\mathrm{dist}_{x,y}=\mathrm{depth}_x+\mathrm{depth}_y-2\mathrm{depth}_{\mathrm{LCA}(x,y)}$。

于是问题就变成找到两个数所代表的结点的深度和最小公共祖先的深度。

我们先将题目转化一下。
> 对于编号为 $k$（$2 \leq k \leq 10^9$）的结点，其父结点的编号为 $k$ 的因数中除 $k$ 以外最大的因数。

$k$ 的因数中除 $k$ 以外最大的因数就是 $k$ 除以它最小的因数，而最小的因数就是最小的质因数。

于是我们可以参照质因数分解的朴素算法算出一个结点到根结点的路径：
```cpp
//这个函数调用完后会将primes存储为k到根结点的路径，primenum表示路径的长度
template <int *primes, int &primenum> void getprimes(int k) {
    primenum = 0;
    for (int g = 2; g * g <= k; ++g)
        while (!(k % g)) //这是一个质因数
            primes[primenum++] = k, k /= g; //记录它的一个父节点后更新p
    if (k != 1) primes[primenum++] = k; //还漏了一个质因数
    if (primes[primenum - 1] != 1) primes[primenum++] = 1; //将根节点补上
}
```
计算完成后显然有 $\mathrm{depth}_p=\mathrm{primenum}-1$。

我们对于 $x$ 与 $y$ 分别调用一次上面的函数，这样 $x$ 与 $y$ 到根结点的路径和 $x$ 与 $y$ 的深度就算出来了。现在我们只需要算出 $\mathrm{LCA}(x,y)$。

定义 $\mathrm{path}_a$ 表示编号为 $a$ 的结点到根结点的路径。显然调用上面的函数后 $\mathrm{path}_x$ 与 $\mathrm{path}_y$ 就已经得到了。由于我们已经得到了 $\mathrm{path}_x$ 与 $\mathrm{path}_y$，因此我们只需要遍历 $\mathrm{path}_y$，遍历到一个结点时，如果它在 $\mathrm{path}_x$ 里，那么它显然就是 $\mathrm{LCA}(x,y)$。

具体实现时，由于 $\mathrm{path}_x$ 与 $\mathrm{path}_y$ 显然单调递减，于是我们可以直接二分查找优化复杂度。

找到 $\mathrm{LCA}(x,y)$ 后，设 $\mathrm{LCA}(x,y)$ 在 $\mathrm{path}_y$ 的第 $p$ 个位置，那么 $\mathrm{depth}_{\mathrm{LCA}(x,y)}=\mathrm{depth}_y-p$。

于是

$$
\begin{aligned}
\mathrm{dist}_{x,y}&=\mathrm{depth}_x+\mathrm{depth}_y-2\mathrm{depth}_{\mathrm{LCA}(x,y)}\\
&=\mathrm{depth}_x+\mathrm{depth}_y-2(\mathrm{depth}_y-p)\\
&=\mathrm{depth}_x-\mathrm{depth}_y+2p
\end{aligned}
$$

时间复杂度：
1. 在有 $n$ 个质因数的数里面 $2^n$ 显然是最小的数字，因此对于一个正整数 $a$，它的因数数量最多为 $\lfloor \log_2a \rfloor$。所以任何一个结点的深度最多是 $\lfloor \log_2a \rfloor$。因此上文的 getprimes 函数复杂度为 $\mathcal{O}(\log n)$。
2. 显然 $\mathrm{path}_x$ 的长度为 $\lfloor \log_2x \rfloor+1$，$\mathrm{path}_y$ 的长度为 $\lfloor \log_2y \rfloor+1$。在 $\mathrm{xp}$ 查找一个数的复杂度为 $\mathcal{O}(\log x)$，$\mathrm{yp}$ 里面的每一个数都要查找一次，总复杂度为 $\mathcal{O}((\log x)(\log y))$，在本题内可以接受。

代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <functional>
int xprimes[32], yprimes[32], xprimenum, yprimenum;
template <int *primes, int &primenum> void getprimes(int p) {
    primenum = 0;
    for (int g = 2; g * g <= p; ++g) while (!(p % g)) primes[primenum++] = p, p /= g;
    if (p != 1) primes[primenum++] = p;
    if (primes[primenum - 1] != 1) primes[primenum++] = 1;
}
int main() {
    int q;
    scanf("%d", &q);
    for (int x, y; q--;) {
        scanf("%d%d", &x, &y), getprimes<xprimes, xprimenum>(x), getprimes<yprimes, yprimenum>(y);
        for (int i = 0; i < yprimenum; ++i) if (*std::lower_bound(xprimes, xprimes + xprimenum, yprimes[i], std::greater<int>()) == yprimes[i]) {
            printf("%d\n", xprimenum - yprimenum + 2 * i);
            break;
        }
    }
}
```

---

## 作者：huhengrui2013 (赞：1)

### 题解：P13016 [GESP202506 六级] 最大因数

[传送门](https://www.luogu.com.cn/problem/P13016)

### 思路：

我们可以先写一个 $\operatorname{fa}$ 函数来求一个数的父亲，那么对于两个节点，它们之间的最短路径就等于他们到根的距离加起来减掉他们最近公共祖先到根节点的距离乘以二（因为两个节点都多走了，所以要乘以二），数据较宽，普通最近公共祖先可过。

### AC Code:

```cpp
#include<bits/stdc++.h> 
using namespace std;
int fa(int x){ //求 x 的父亲节点 
    if(x==1) return 1;
    for(int i=2;i<=sqrt(x);i++)
    	if(x%i==0) return x/i;
    return 1;
}
int get(int x){ //求 x 到根节点的距离 ，即深度 
    int dep=0;
    while(x!=1){
        x=fa(x);
        dep++;
    }
    return dep;
}
int lca(int x,int y) { //求 x 到 y 的最近公共祖先（lca） 
    int dx=get(x);
    int dy=get(y);
    if(dx<dy){//确保 x 的深度大于 y 的深度（即到根节点的距离） 
        swap(x,y);
        swap(dx,dy);
    }
    while(dx>dy){ //将 x ，y 跳至同一层 
        x=fa(x);
        dx--;
    }
    while(x!=y) { //同时往上跳，求最近公共祖先 
        x=fa(x);
        y=fa(y);
    }
    return x;
}

int main() {
    int q;
    cin>>q;
    while(q--){
        int x,y;
        cin>>x>>y;
        int l=lca(x,y); // 求 x ，y 的最近公共祖先 
        int dx=get(x);  // 求 x 到根节点的距离 
        int dy=get(y);	// 求 y 到根节点的距离 
        int dl=get(l);  // 求 x，y的最近公共祖先到根节点的距离 
        int ans=dx+dy-2*dl;// x 到根节点的距离 + 求 y 到根节点的距离 - 2倍的x，y的最近公共祖先到根节点的距离 
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：蒟蒻whker (赞：0)

[题目传送门](problem/P13016)  
考场上 20min 切掉~
### 题意
一棵树上，每个节点的祖先是自己以外的最大因数，求两点距离。

### 思路
显然，每次去找两个点中较大者的祖先，随后比较找到的祖先与另一个点的大小关系，重复此流程，记录步数，直到两者相同时输出步数即可。


### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int fa(int k){
	for(int i=2;i<=sqrt(k);i++){
		if(k%i==0)return k/i;//寻找祖先
	}
	return 1;//注意质数的祖先为1
}
int solve(int x,int y){
	int step = 0;
	while(x!=y) {
		if (x>y) {//寻找较大者的祖先
			x=fa(x);
			step++;
		} else {
			y=fa(y);
			step++;//统计步数
		}
	}
	return step;
}
int main() {
	int Q;
	cin>>Q; 
	while(Q--) {
		int x,y;
		cin>>x>>y;
		cout<<solve(x,y)<<endl;
	}
	return 0;
}


```

---

## 作者：noiiloveyou (赞：0)

## 知识点

GESP 五级：因数（初等数论）。

GESP 六级：树（树的定义，构造与遍历）。

## 题目分析

**注意：本文所说的最大因数不包含此数，最小因数不包含 $1$。**

题意很容易理解，简单地说，就是把 $x$ 或 $y$ 修改为它的最大因数（它的父结点），一直到这两个数相等（找到了两数的最近公共祖先），统计找了多少次最大因数（到最近公共祖先的距离）即可。

### 问题 1：如何快速找到一个数（用 $n$ 表示）的最大因数？

很简单，先找到 $n$ 的最小因数，接着用 $n$ 除以这个最小因数，得到的就是 $n$ 的最大因数。容易发现，除 $n$ 外，最小因数不会超过 $\sqrt{n}$，理由：假设 $n$ 的最小因数超过 $\sqrt{n}$，那一定存在一个小于 $\sqrt{n}$ 的因数，与它相乘为 $n$，矛盾。但因为最小因数不能为一（会发生死循环），所以如果我们发现 $n$ 最小因数大于 $\sqrt{n}$，就可以直接断定：$n$ 是个质数，最小因数为 $n$。

### 问题 2：应当先找 $x$ 还是 $y$ 的最大因数？

由于我们的目标是在一番操作后，$x$ 与 $y$ 相等（即找到了最近公共祖先），而最大因数严格小于原数，因此应当将 $x$ 与 $y$ 中的较大数设为它的最大因数。如果 $x$ 与 $y$ 任然不相等，就重复这一过程。记得统计次数哦。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int q;
int main(){
    cin>>q;
    int x,y;
    for(int i=0;i<q;++i){
        cin>>x>>y;
        int xmax=2,ymax=2,ans=0;
        //分别表示目前找到 x 的最小因数，y 的最小因数和答案

        //一直执行，直到 x 等于 y
        while(x!=y){
            //x 较大
            if(x>y){
                //找最小因数
                while(x%xmax!=0){
                    //若最小因数超过 sqrt(x)，直接断定
                    if(xmax>sqrt(x)){
                        xmax=x;
                        break;
                    }
                    //否则，尝试下一个数
                    ++xmax;
                }
                //得到 x 的最大因数
                x/=xmax;
                ++ans;
            }

            //y 较大，与上类似
            else{
                while(y%ymax!=0){
                    if(ymax>sqrt(y)){
                        ymax=y;
                        break;
                    }
                    ++ymax;
                }
                y/=ymax;
                ++ans;
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：sybs1145 (赞：0)

# [P13016 最大因数](https://www.luogu.com.cn/problem/P13016) 题解

## 思路

### 60pts

强模拟即可，核心代码如下：

```cpp
int ans = 0;
while(x!=y){
  if(x<y) swap(x,y);
  for(int i = x-1;i;i--){
      if(x%i==0){
          ans++,x=i;
          break;
      }
  }
}
```

### 100pts

看到数据范围 $1 \le x_i,y_i \le 10^9$，考虑得到一个稍微合理的时间复杂度。

所以我们要对寻找最大因数的部分进行优化。

我们可以发现在寻找因数时，若直接枚举寻找最大因数，复杂度是 $O(n)$ 级别的，但是我们如果通过寻找最小因数，再用原数除以最小因数的方法得到最大因数，复杂度则是 $O(\sqrt{n})$ 级别的。
    
but 这样仍是 60pts，于是寻找复杂度瓶颈。

可以发现当 $x_i$ 或 $y_i$ 为质数时，寻找最大因数的时间复杂度仍是 $O(n)$ 的。

又因为根据题意，编号为质数的父结点一定为 1。

所以在每次操作时进行一次质数判断即可。

时间复杂度 $O(q\sqrt{W}\log W)$（W 为值域），完结撒花（~~什么逆天复杂度~~）。

## AC code
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int q,x,y;
bool isprime(int a){
    for(int i = 2;i*i<=a;i++)
        if(a%i==0)
            return 0;
    return 1;
}
int main()
{
    ios::sync_with_stdio(0);
    cin>>q;
    while(q--){
        cin>>x>>y;
        int ans = 0;
        while(x!=y){
            if(x<y) swap(x,y);
            if(isprime(x)){
                ans++,x=1;
                continue;
            }
            for(int i = 2;;i++){
                if(x%i==0){
                    ans++,x/=i;
                    break;
                }
            }
        }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：Amiyawasdonkey (赞：0)

# 思路

讲一个比较好理解的方法。

我们可以求出根节点 $1$ 到 $x$ 和 $y$ 的路径，再根据这两条路径来求 $x$ 和 $y$ 的最近公共祖先（LCA），那么这两个节点之间最短路径的长度就是 $x$ 到 LCA 的距离加上 $y$ 到 LCA 的距离。

查找 LCA 的方法：将两条路径从根节点开始比对，最后一个相同的节点就是 LCA。

# Code

```cpp
#include<bits/stdc++.h>
#define Iseri namespace
#define Nina std
#define Kawaragi int
#define Momoka main
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define ll long long
#define ull unsigned long long
#define endl "\n"
const int maxn=200005;
const int inf=0x7fffffff;//无意义宏定义

using Iseri Nina;

inline ll read(){//快读
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

//===========================================================

ll q,x,y;
vector<ll>a,b;//用来存储路径

inline ll fa(ll k){//求父节点
    if(k==1)return 0;//特判
    for(int i=2;i*i<=k;i++)if(k%i==0)return k/i;//求最大因数
    return 1;
}

Kawaragi Momoka(){
	q=read();
	while(q--){
		x=read(),y=read();
		a.clear(),b.clear();//多测不清空，爆零两行泪TAT

		while(x!=0){//求根节点到被询问节点的路径
			a.push_back(x);
			x=fa(x);
		}
		while(y!=0){
			b.push_back(y);
			y=fa(y);
		}
		reverse(a.begin(),a.end());//从根节点开始比对
		reverse(b.begin(),b.end());

		ll p=0;
		while(p<a.size()&&p<b.size()&&a[p]==b[p])p++;//size就是两条路径的长度

		printf("%lld\n",(a.size()-p)+(b.size()-p));//快乐输出
	}
	return 0;
}
```
[提交记录](https://www.luogu.com.cn/record/221842999)

---

## 作者：CSP_S_2023_T2 (赞：0)

容易发现结点 $i$ 的父结点即为 $i$ 除以 $i$ 的最小质因子。

可以通过质因数分解找到结点 $x,y$ 的父节点，进一步推出结点 $x,y$ 到根结点的简单路径。

找到两条路径中的最大重合结点，答案即为该结点到结点 $x,y$ 的路径长度之和。

完结撒花。

代码如下：


```cpp
#include<bits/stdc++.h>

using namespace std;

int x,y,a[114],b[514];

void solve(){
	cin>>x>>y;
	memset(a,0,sizeof(a));
	int nowx=0,nowy=0;
    //质因数分解寻找路径
	a[0]=x;
	b[0]=y;
	for(int i=2;i*i<=x;i++){
		while(x%i==0){
			x/=i;
			a[++nowx]=x;
		}
	}
	if(x>1) a[++nowx]=1;
	for(int i=2;i*i<=y;i++){
		while(y%i==0){
			y/=i;
			b[++nowy]=y;
		}
	}
	if(y>1) b[++nowy]=1;
    //寻找最大重合结点
	for(int i=0;i<=nowx;i++){
		for(int j=0;j<=nowy;j++){
			if(a[i]==b[j]){
				cout<<i+j<<'\n';
				return ;
			}
		}
	}
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int t;
    cin>>t;
    while(t--) solve();
    return 0;  //完结撒花
}
```

[AC Record](https://www.luogu.com.cn/record/221829430)。

---

## 作者：tonghaoxuan (赞：0)

[传送门](https://www.luogu.com.cn/problem/P13016)

### 大致题意：

有一棵树，$ 1 $ 为根，每一个正整数编号节点链接编号为除它本身之外的最大因数的节点，求任意两点的距离。

### 思路：

首先，链接编号为除它本身之外的最大因数的节点，可以理解为链接除以它最小的因数后的数。

其次，如果两点在完全不同的分支上，那么两点之间的距离就是两数因数个数之和。

那么，一个思路出来了！

先计算两数因数个数之和，再通过模拟链接的过程，构造分别根到两点的路径。每有一个重复的点，就让答案减 $ 2 $。

### AC 代码：

```
#include<bits/stdc++.h>
using namespace std;
int q;
pair<int,string> fd(int x){
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0){
			pair<int,string> ls=fd(x/i);
			return {ls.first+1,ls.second+to_string(i)+","};
		}
	}
	if(x!=1){
		return {1,to_string(x)+","};
	}else{
		return {0,""};
	}
}
int main(){
	cin>>q;
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		pair<int,string> xg=fd(x),yg=fd(y);
		int ans=xg.first+yg.first;
		string xl=xg.second,yl=yg.second;
		int str=min(xl.size(),yl.size());
		for(int i=0;i<str;i++){
			if(xl[i]!=yl[i]){
				break;
			}
			if(xl[i]==','){
				ans-=2;
			}
		}
		cout<<ans<<'\n';
	}
}
```
（代码很简单，都能看得懂吧，不作注释了）

### 声明：

思路为比赛时想出，代码是后来写的。代码不是太短，时间也不优秀，肯定有更优解法，我的代码就凑合看看吧。

---


# 【模板】最近公共祖先（LCA）

## 题目描述

如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。

## 说明/提示

对于 $30\%$ 的数据，$N\leq 10$，$M\leq 10$。

对于 $70\%$ 的数据，$N\leq 10000$，$M\leq 10000$。

对于 $100\%$ 的数据，$1 \leq N,M\leq 5\times10^5$，$1 \leq x, y,a ,b \leq N$，**不保证** $a \neq b$。


样例说明：

该树结构如下：

 ![](https://cdn.luogu.com.cn/upload/pic/2282.png) 

第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。

第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。

第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。

第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。

第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。

故输出依次为 $4, 4, 1, 4, 4$。


2021/10/4 数据更新 @fstqwq：应要求加了两组数据卡掉了暴力跳。

## 样例 #1

### 输入

```
5 5 4
3 1
2 4
5 1
1 4
2 4
3 2
3 5
1 2
4 5```

### 输出

```
4
4
1
4
4
```

# 题解

## 作者：Alex_Wei (赞：502)

- 2023.7.17：该技巧目前已知的最早来源：[skip2004](https://www.cnblogs.com/skip2004/p/12240164.html)。
- 2024.7.6：修订文章。

DFS 序求 LCA 无论是在时间常数，空间常数还是好写程度均吊打欧拉序。

### 定义

DFS 序表示对一棵树进行深度优先搜索得到的 **结点序列**，而 **时间戳** dfn 表示每个结点在 DFS 序中的位置。需要区分这两个概念。

### 算法介绍

考虑树上的两个结点 $u, v$ 及其最近公共祖先 $d$，使用欧拉序而不是 DFS 序求 LCA 的原因是在欧拉序中，$d$ 在 $u, v$ 之间出现过，但在 DFS 序中，$d$ 没有在 $u, v$ 之间出现过。

DFS 序的性质：祖先先于后代遍历，即若 $u$ 是 $v$ 的祖先，则 $dfn_u < dfn_v$。

不妨设 $dfn_u < dfn_v$，那么 $v$ 不是 $u$ 的祖先。

- 当 $u$ 不是 $v$ 的祖先时，DFS 的顺序为从 $d$ 下降到 $u$，再回到 $d$，再下降到 $v$。因为到达 $u$ 在到达 $d$ 之后，而到达 $v$ 在离开 $d$ 之前，所以 $u, v$ 的 DFS 序之间的所有结点一定落在 $d$ 的子树内（不含 $d$）。

  考察 $d$ 在 $v$ 方向上的第一个结点 $v'$，即设 $v'$ 为 $d$ 的「子树包含 $v$ 的」儿子。根据 DFS 的顺序，$v'$ 一定在 $u, v$ 的 DFS 序之间。这说明只需求 $u, v$ 的 DFS 序之间深度最小的任意结点，那么 **它的父亲** 即为 $u, v$ 的 LCA。换言之，在 $u, v$ 的 DFS 序之间一定存在 $d$ 的儿子。

- $u, v$ 形成祖先-后代关系的情况容易判断，但不优美，因为还需记录每个结点的子树大小，不能体现出 DFS 求 LCA 的优势：简洁。

  此时 $u$ 一定是 $v$ 的祖先。考虑令查询区间从 $[dfn_u, dfn_v]$ 变成 $[dfn_u + 1, dfn_v]$。对于情况 1，$u\neq v'$，所以情况 2 对于算法进行的修改仍适用于情况 1。

综上，若 $u\neq v$，则它们的 LCA 等于 DFS 序上位置在 $[dfn_u + 1, dfn_v]$ 的深度最小的任意结点的父亲。若 $u = v$，则它们的 LCA 就等于 $u$，这是唯一需要特判的情况。

一种避免记录每个结点的父亲和深度的方法是直接在 ST 表的最底层记录父亲，比较时取时间戳较小的结点。如果你完全理解了 DFS 序求 LCA，自然能够理解这个技巧的正确性。

预处理 ST 表的复杂度仍为 $\mathcal{O}(n\log n)$，但常数减少一半。以下是模板题 [P3379](https://www.luogu.com.cn/problem/P3379) 的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 5e5 + 5;
int n, m, R, dn, dfn[N], mi[19][N];
vector<int> e[N];
int get(int x, int y) {return dfn[x] < dfn[y] ? x : y;}
void dfs(int id, int f) {
  mi[0][dfn[id] = ++dn] = f;
  for(int it : e[id]) if(it != f) dfs(it, id); 
}
int lca(int u, int v) {
  if(u == v) return u;
  if((u = dfn[u]) > (v = dfn[v])) swap(u, v);
  int d = __lg(v - u++);
  return get(mi[d][u], mi[d][v - (1 << d) + 1]);
}
int main() {
  scanf("%d %d %d", &n, &m, &R);
  for(int i = 2, u, v; i <= n; i++) {
    scanf("%d %d", &u, &v);
    e[u].push_back(v), e[v].push_back(u);
  }
  dfs(R, 0);
  for(int i = 1; i <= __lg(n); i++)
    for(int j = 1; j + (1 << i) - 1 <= n; j++)
      mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 << i - 1)]);
  for(int i = 1, u, v; i <= m; i++) scanf("%d %d", &u, &v), printf("%d\n", lca(u, v));
  return 0;
}
```

### 和各种 LCA 算法的对比

对比 DFS 序和欧拉序，不仅预处理的时间常数减半（欧拉序 LCA 的瓶颈恰在于预处理，DFS 是线性），空间常数也减半（核心优势），而且更好写（对于很多题目不需要再同时求欧拉序和 DFS 序），也无需担心忘记开两倍空间。

对比 DFS 序和倍增，前者单次查询复杂度更优。

对于 DFS 序和四毛子，前者更好写。

对于 DFS 序和树剖，前者更好写，且单次查询复杂度更优。不过树剖常数较小，如果求 LCA 不是瓶颈且其它部分需要使用树剖，则树剖 LCA 也是不错的选择。

**将 DFS 序求 LCA 发扬光大，让欧拉序求 LCA 成为时代的眼泪！**

---

## 作者：UnyieldingTrilobite (赞：102)

本文介绍了一种基于斜二进制的 LCA 算法，算是一个省流，完整版请看 <https://www.luogu.com.cn/article/u81tks5o>。

本文介绍的算法此前在 Codeforces 有所出现，但是并未被引入 OI。笔者独立发明该算法（及其相关体系）后认为其值得被引入。其在 LCA 问题上有较大优势。

该算法复杂度为 $O(n)$ 预处理 $O(\log n)$ 查询。其对比树剖存在跑得更快，空间更少，代码更短，思路更简单的优势。

太长不看版：

```cpp
void dfs(int x) {
  int p = fa[x], q = lb[p], r = lb[q];
  d[x] = d[p] + 1;
  lb[x] = d[p] - d[q] != d[q] - d[r] ? p : r;
  for (int y : es[x])
    if (y != p) fa[y] = x, dfs(y);
}
int lca(int u, int v) {
  if (d[u] < d[v]) swap(u, v);
  while (d[u] > d[v])
    if (d[lb[u]] < d[v])
      u = fa[u];
    else
      u = lb[u];
  while (u != v)
    if (lb[u] == lb[v])
      u = fa[u], v = fa[v];
    else
      u = lb[u], v = lb[v];
  return u;
}
```

如果不想了解原理的话可以直接背板，它并不长。

---

+ 斜二进制

斜二进制是一种奇怪的进制。它从低到高第 $i\ge1$ 位位权为 $2^i-1$。用斜二进制表示一个数时，需要满足至多一位为二且低于此位者均为零，其余位不超过一。定义一个斜二进制数的最低有效位是它最低位值非零的位。

我们将使用一种归纳构造的方式来生成每个自然数的斜二进制分解。0 的斜二进制是 0。我们假设已经对于 $n$ 生成了它的斜二进制分解，那么 $n+1$ 的斜二进制将在此基础上进行分类：

1. $n$ 的斜二进制分解最低有效位为二。

不妨这是第 $i$ 位，那么乘上二的位值即为 $2\times(2^i-1)=2^{i+1}-2$，再加上新多出来的一就是 $2^{i+1}-1$。于是我们清除这两位并向前一位进一即可。

2. $n$ 的斜二进制分解最低有效位不为二。

在第一位上加一即可。

不难验证以此法生成的斜二进制分解符合它应有的性质。

这么讲可能比较抽象，我们来举点例子。

+ 0 的斜二进制是 0。

+ 1 的斜二进制是 1。因为 0 的最低有效位不为二。

+ 2 的斜二进制是 2。因为 1 的最低有效位不为二。

+ 3 的斜二进制是 10。因为 2 的最低有效位为二，向前进一。

+ 4 的斜二进制是 11。因为 10 的最低有效位不为二。

+ 5 的斜二进制是 12。因为 11 的最低有效位不为二。

+ 6 的斜二进制是 20。因为 12 的最低有效位为二，向前进一。

+ 7 的斜二进制是 100。因为 20 的最低有效位为二，向前进一。

+ 8 的斜二进制是 101。因为 100 的最低有效位不为二。

+ 9 的斜二进制是 102。因为 101 的最低有效位不为二。

+ 10 的斜二进制是 110。因为 102 的最低有效位为二，向前进一。

+ 11 的斜二进制是 111。因为 110 的最低有效位不为二。

+ 12 的斜二进制是 112。因为 111 的最低有效位不为二。

+ 13 的斜二进制是 120。因为 112 的最低有效位为二，向前进一。

总之大概就是这样。注意我们并不关心一个数的斜二进制是否唯一。

我们定义 $\textit{skew\_lowbit}(x)$ 表示 $x$ 在斜二进制下的最低有效位的位权。我们定义 $d_x$ 为树上一个点到根路径上的节点数，称为该节点的“深度”。我们定义 $\textit{lb}_x$ 为一个点 $x$ 的 $\textit{skew\_lowbit}(d_x)$ 级祖先。若该祖先不存在，则定义其为 $0$。定义 $d_0=\textit{lb}_0=\textit{skew\_lowbit}(0)=0$。可以发现，$d_x-d_{\textit{lb}_x}=\textit{skew\_lowbit}(d_x)$。也即，$d_{\textit{lb}_x}$ 是 $d_x$ 在斜二进制下将最低有效位减一后的结果。

我们考虑怎么递推这个 $lb$。我们考虑现在要计算 $lb_x$。我们定义 $p$ 为 $x$ 的父亲 $\textit{fa}_x$，$q$ 为 $\textit{lb}(p)$，$r$ 为 $\textit{lb}(q)$。我们考虑将 $d_p$ 加上 $1$ 转移到 $d_x$ 只有两种可能性：若 $d_p$ 在斜二进制下的最低有效位上不为 $2$，则将其最低位直接修改为 $1$；此时，$\textit{skew\_lowbit}(d_x)=1$，也即 $\textit{lb}_x=p$。若 $d_p$ 在斜二进制下的最低有效位上为 $2$，则对其进行进位；此时，$\textit{skew\_lowbit}(d_p)=\textit{skew\_lowbit}(d_q)$，且 $\textit{lb}_x=r$。手玩一下斜二进制，这是简单的。

现在我们考虑怎么用求出的 $\textit{lb}$ 求 LCA。我们直接看开头的这段代码：

```cpp
int lca(int u, int v) {
  if (d[u] < d[v]) swap(u, v);
  while (d[u] > d[v])
    if (d[lb[u]] < d[v])
      u = fa[u];
    else
      u = lb[u];
  while (u != v)
    if (lb[u] == lb[v])
      u = fa[u], v = fa[v];
    else
      u = lb[u], v = lb[v];
  return u;
}
```

它的正确性是显而易见的，因为对于 $d_x=d_y$ 一定有 $d_{\textit{lb}_x}=d_{\textit{lb}_y}$。于是我们只需要证明它的复杂度。上下两个 `while` 的本质是相同的，即为从 $u$ 开始找到一个最低的满足某个条件的祖先。

我们以上面那个 `while` 为例：

```cpp
  while (d[u] > d[v])
    if (d[lb[u]] < d[v])
      u = fa[u];
    else
      u = lb[u];
```

在第一次走第一个 `if` 之前，$u$ 会一直跳到 $\textit{lb}_u$。由于 $d_u$ 的斜二进制最低有效位上至多为 $2$，这里我们每至多两步就会让 $d_u$ 斜二进制的最低有效位升高。由于这个有效位至多升高到 $O(\log n)$，这一部分的复杂度也是 $O(\log n)$。

在第一次走第一个 `if` 之后，设每次走一次第一个 `if` 之前 $\textit{skew\_lowbit}(d_u)=w$，则下一个 $\textit{skew\_lowbit}(d_{u'})\ge w$ 的点 $u'$ 正是 $lb_u$，而它已经被我们宣告不合法了。于是每走一次 `if` 都会带来 $d_u$ 斜二进制的最低有效位降低，且无法再次升高。进一步，根据斜二进制的退位特征，我们发现走一次 `if` 一定会使该有效位降低恰一位。而每至多两步第二个 `if` 就会让 $d_u$ 斜二进制的最低有效位升高，于是每次第一个 `if` 后至多跟着一次第二个 `if`。而第一个 `if` 的总数量是 $O(\log n)$ 的，于是总复杂度也是 $O(\log n)$ 的。

于是我们得到了一个 $O(n)$ 预处理 $O(\log n)$ 查询的简单 LCA 算法，做完了。

---

## 作者：Brute_Force (赞：25)

# 算法介绍
本题解介绍倍增法求 LCA。
## 倍增法
倍增法的本质是通过已知的一段内容，将该内容求解的范围扩大一倍，进而求解整个问题，从而提升程序效率。
## 倍增法求解 LCA
我们令 $f_{i,j}$ 表示节点 $i$ 向上跳 $2^j$ 步，所到的节点。显然，$f_{i,0}$ 表示节点 $i$ 的父亲节点。

现在有了初始化，那么我们就有了求解所有 $f_{i,j}$ 的基础。想要求解每一个 $i$ 节点跳 $2^j$ 到的节点，等同于 $i$ 节点先往上跳 $2^{j-1}$ 步到的节点，再往上跳 $2^{j-1}$ 步到的最终节点。由上述描述，可得递推式：
$$f_{i,j} = f_{f_{i,j-1},j-1}$$

注意，往上跳的过程中，不能跳出根节点。

求解 LCA 时，只需将两个节点拉直同一深度，如果两个节点相同，则返回两者之间任一节点，否则一起往上跳相同步数直至求出 LCA 为止。
# 正确性证明
## 时间复杂度证明
预处理时，对于 $n$ 个节点在不跳出根节点的情况下，每次最多循环 $\log n$ 次。预处理复杂度 $O(n \log n)$。

每次查询时，最坏情况下两个深度最高的节点的 LCA 是根节点，拉至 LCA 的总时间复杂度为 $O(\log n)$。
## 递推式证明
如果程序在求解 $1$ 到 $n$ 跳跃 $2^j$ 步达到的节点，必然求解了 $1$ 到 $n$ 跳跃 $2^{j-1}$ 步的节点。所以递推式正确。

本棵树边界条件是条链，因此，一个节点最多跳的步数小于 $n$。
## 查询证明
一个节点到另一个节点的深度是唯一确定的，因此跳跃的步数也是唯一确定的。所以相同深度的两个节点到 LCA 的步数也是相同的。而我们已经用倍增法记录下了每个 $f_{i,j}$，所以该算法是正确的。
# 代码实现
对于每一个节点 $i$ 求 $f_{i,0}$，我们可以直接用 DFS 求解，并记录下此时节点 $i$ 的深度以及 $f_{i,0}$。代码如下：
```cpp
inline void dfs (int u, int fa) {
	f[u][0] = fa;//记录父亲节点
	dep[u] = dep[fa] + 1;//记录深度
	for (auto v : e[u])
		if (v != fa) dfs (v, u);
}
```
对于求解每一个 $f_{i,j}$，代码如下：
```cpp
inline void init () {
	for (int j = 1; (1 << j) <= n; ++j)//边界范围
		for (int i = 1; i <= n; ++i)
			f[i][j] = f[f[i][j - 1]][j - 1];
}
```
接下来是核心的求解 LCA，代码如下：
```cpp
inline int lca (int u, int v) {
	if (dep[u] < dep[v]) swap (u, v);
	for (int i = 22; i >= 0; i--) {
		if (dep[f[u][i]] >= dep[v]) u = f[u][i];
	}//跳至同一深度
	if (u == v) return u;//此时节点为 LCA
	for (int i = 22; i >= 0; i--) {
		if (f[u][i] != f[v][i]) {
			u = f[u][i];
			v = f[v][i];
		}
	}//一起往上跳
	return f[u][0];
}
```
完整代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 1;
int n, m, s, f[N][33], dep[N];
vector <int> e[N];
bool vis[N];
inline void dfs (int u, int fa) {
	f[u][0] = fa;
	dep[u] = dep[fa] + 1;
	for (auto v : e[u])
		if (v != fa) dfs (v, u);
}//求 f[i][0]
inline int lca (int u, int v) {
	if (dep[u] < dep[v]) swap (u, v);
	for (int i = 22; i >= 0; i--) {
		if (dep[f[u][i]] >= dep[v]) u = f[u][i];
	}
	if (u == v) return u;
	for (int i = 22; i >= 0; i--) {
		if (f[u][i] != f[v][i]) {
			u = f[u][i];
			v = f[v][i];
		}
	}
	return f[u][0];
}//求两个节点的 LCA
inline void init () {
	for (int j = 1; (1 << j) <= n; ++j)
		for (int i = 1; i <= n; ++i)
			f[i][j] = f[f[i][j - 1]][j - 1];
}//求 f[i][j]
int main () {
	ios :: sync_with_stdio (0);
	cin.tie (0), cout.tie (0);
	cin >> n >> m >> s;
	for (int i = 1; i < n; ++i) {
		int x, y;
		cin >> x >> y;
		e[x].push_back (y);
		e[y].push_back (x);
	}
	dfs (s, 0);
	init ();
	for (int i = 1; i <= m; ++i) {
		int u, v;
		cin >> u >> v;
		cout << lca (u, v) << "\n";
	}
	return 0;
}
```

---

## 作者：langmouren (赞：17)

# Tarjan LCA
## 前言

Tarjan 老爷爷太聪明了，他不仅开发出来了求解图的连通性问题的算法，还开发出了求解 LCA 的算法。

Tarjan LCA 利用了并查集，可以在线性时间内离线求解。

其过程是记录下来所有询问，进行搜索，将搜索完的点记录到 $vis$ 数组，并向自己的父亲合并，在一个点 $x$ 的子树处理完毕后处理所有和 $x$ 点有关的询问，若另外一个点也已经访问过，则答案为另外一个点的并查集所指向的节点。

## 前置知识

- DFS。
- 并查集。
- 对于本篇题解，你还需要会使用 vector。

## 结合图片分析

口述难以理解，我们结合图片分析。假定我们要查询 $6$ 和 $4$ 的 LCA。

约定 `find(x)` 为并查集的搜索函数；`merge(x,y)` 为并查集的合并函数，其意义为将 $x$ 合并到 $y$。

![](https://cdn.luogu.com.cn/upload/image_hosting/n50s2r5a.png)

1. 搜索到节点 $1$，设 $vis_1$ 为 true。
2. 搜索到节点 $3$，设 $vis_3$ 为 true。
3. 搜索到节点 $6$，设 $vis_6$ 为 true。没有儿子，`merge(6,3)`。发现需要查询 $6$ 和 $4$ 的 LCA，但是此时 $vis_4$ 为 false，所以不进行操作。
4. 回溯到 $3$，没有其他儿子，`merge(3,1)`。
5. 回溯到 $1$，搜索到节点 $2$，设 $vis_2$ 为 true。
6. 搜索到节点 $4$，设 $vis_4$ 为 true。没有儿子，`merge(4,2)`，发现需要查询 $4$ 和 $6$ 的 LCA，此时 $vis_6$ 为 true，将两者答案设置为 `find(6)`，即 $1$。

这样子，一次求解就完成了。

## 复杂度

对于大小为 $n$ 的图进行遍历，进行 $m$ 次询问，由于是离线查询，一次就可以完成，故时间复杂度为 $O(n+m)$。

## 代码实现

古希腊掌管 vector 的神。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MN=5e5+10;
int fa[MN],vis[MN],ans[MN],n,m,s;
vector<int> v[MN];
vector<pair<int,int>> ask[MN];

int find(int x){
    if(fa[x]!=x) fa[x]=find(fa[x]);
    return fa[x];
}

void merge(int x,int y){
    x=find(x);
    y=find(y);
    fa[x]=y;
}

void tarjan(int x){
    vis[x]=true;

    for(int i=0;i<v[x].size();i++){
        int y=v[x][i];

        if(vis[y]) continue;//无向图 防止遍历自己爹

        tarjan(y);
        merge(y,x);
    }

    for(int i=0;i<ask[x].size();i++){
        int y=ask[x][i].first;
        int id=ask[x][i].second;
        if(vis[y]) ans[id]=find(y);
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    for(int i=1;i<MN;i++) fa[i]=i;//初始化并查集
    
    cin>>n>>m>>s;

    for(int i=1;i<n;i++){
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
        v[y].push_back(x);
    }

    for(int i=1;i<=m;i++){
        int a,b;
        cin>>a>>b;

        if(a==b) ans[i]=a;
        else{
            ask[a].push_back({b,i});
            ask[b].push_back({a,i});
        } 
    }

    tarjan(s);

    for(int i=1;i<=m;i++){
        cout<<ans[i]<<"\n";
    }
    return 0;
}
```

---

## 作者：chu_yh (赞：15)

update on 2025.4.20：修改了 @[Fire_flys](luogu://user/803348) 提出的问题。详情见讨论区。

---
忠告：别偷懒用 AI（尤其是豆包）写题解，否则你会被格式整崩溃，~~比如我~~。

欢迎踩[博客](https://blog.csdn.net/Chu_yh/article/details/146613168?sharetype=blogdetail&sharerId=146613168&sharerefer=PC&sharesource=Chu_yh&spm=1011.2480.3001.8118)，数剖做法请见《[题解：P3379 【模板】最近公共祖先（LCA）树剖](https://www.luogu.com.cn/article/tie9fzcq)》。

## 倍增求最近公共祖先

一棵有根**树** $T$ 的两个结点 $a$、$b$ 的最近公共祖先表示一个结点 $x$，满足 $x$ 是 $a$、$b$ 的祖先且 $x$ 的深度尽可能大。本题解讲解用**倍增法**求两节点的最近公共祖先。

### 暴力

首先计算出结点 $a$ 和 $b$ 的深度 $d1$ 和 $d2$。如果 $d1>d2$，将 $a$ 结点向上移动 $d1-d2$ 步，如果 $d1<d2$，将 $b$ 结点向上移动 $d2-d1$ 步，现在 $a$ 结点和 $b$ 结点在**同一个深度**了。下面只需要同时将 $a$、$b$ 结点向上移动，直到它们**相遇**（到达同一个结点）为止，相遇的结点即为 $a$、$b$ 结点的最小公共祖先。

该算法时间复杂度为 $O(nm)$，对于多次询问的题目（比如本题）不能解决。

### 思想

倍增法其实是在上一种方法的基础上进行了优化。我们希望向上查找更快，可以事先预处理出**数组 $p_{u,i}$，表示 $u$ 往上移动 $2^i$ 步到达的结点**，利用 $p$ 数组可以快速的将结点 $u$ 向上移动 $n$ 步，方法是将 $n$ 表示为二进制数。

例如 $n = (110)_2$ ，那么利用 $p$ 数组先向上移动 $2^2$ 步，然后再继续移动 $2^1$ 步，即 $p_{p_{u,2},1}$。这样在查找时就不用一个点一个点地往上跳，直接大跳，将大大节约时间。

### 求 $p$ 数组

有定义可知：

- 当 $j=0$ 时，$p_{u,i} = fa_u$，即 `p[u][0]=fa_u`。
- 当 $j \ge 1$ 时，$p_{u,i} = p_{p_{u,i-1},i-1}$，即 `p[u][i]=p[p[u][i-1]][i-1]`。


其中，$fa_u$ 是 $u$ 节点的**父亲节点**。

显然，我们可以利用 DFS 或 BFS 处理出 $p$ 数组。下面的代码使用 DFS。

```cpp
void dfs(int u,int fa){//u为当前节点，fa为u节点的父亲
	d[u]=d[fa]+1,p[u][0]=fa;//d[i]表示i节点深度
	for(int i=1;(1<<i)<=d[u];i++)//不能跳出根节点，从小往大处理
		p[u][i]=p[p[u][i-1]][i-1];//核心
	for(int v:e[u]) if(v!=fa) dfs(v,u);
}
```

### 求最近公共祖先

现在要求结点 $a$ 和 $b$ 的最近公共祖先。

#### 将 $a$ 和 $b$ 对齐

我们事先准备数组 $d_u$ 表示 $u$ 节点的深度。

假设 $d_a \le d_b$。那我们先**将 $b$ 挪到和 $a$ 同一深度的位置**。代码实现如下：

```cpp
if(d[a]>d[b]) swap(a,b);//强制让b的深度更大
for(int i=20;i>=0;i--)//要把i从20到0枚举
    if(d[a]<=d[b]-(1<<i))//b向上跳后深度仍不大于a
        b=p[b][i];//b跳到p[b][i]
```

特别的，若此时 $a$、$b$ 已**重合**，那这时 $a$ 点（或 $b$ 点）就是 $a$ 和 $b$ 的最近公共祖先。

```cpp
if(a==b){//若a、b重合
    printf("%d\n",a);
    continue;
}
```

#### 让 $a$ 点和 $b$ 点上跳直到它们重合

$a$、$b$ 利用 $p$ 数组同步上跳，直到它们重合。

```cpp
for(int j=20;j>=0;j--)//也要把i从20到0枚举
    if(p[a][j]!=p[b][j])//不能重合就继续往上跳
        a=p[a][j],b=p[b][j];
printf("%d\n",p[a][0]);
```

#### 为什么要把 $i$ 从 $20$ 到 $0$ 枚举？

很好理解，举个例就明白了。如：要从点 $u$ 向上跳 $666$ 步跳到 $v$。

过程：把 $i$ 从 $20$ 到 $0$ 枚举（或把 $i$ 从 $0$ 到 $20$ 枚举），若 $2^i \le x$ （即 $d_{p_{u,i}} \ge d_{v}$），就把 $u$ 向上跳 $2^i$ 步。

- 若是把 $i$ 从 $20$ 到 $0$ 枚举，上面的例子就会依次跳 $2^9$、$2^7$、$2^4$、$2^3$、$2^1$ 步，并且 $2^9+2^7+2^4+2^3+2^1=666$，可得把 $i$ 从 $20$ 到 $0$ 枚举是**正确**的。
- 若是把 $i$ 从 $0$ 到 $20$ 枚举，上面的例子就会依次跳 $2^0$、$2^2$、$2^3$、$2^4$、$2^5$、$2^6$、$2^7$、$2^8$ 步，并且 $2^0+2^1+2^3+2^4+2^5+2^6+2^7+2^8 \ne 666$，可得把 $i$ 从 $0$ 到 $20$ 枚举是**错误**的。

看完这个例子，要把 $i$ 从 $20$ 到 $0$ 枚举的原因就不言而喻了。

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e6+5;
int n,m,s,d[N],p[N][21];
vector<int> e[N];

void dfs(int u,int fa){
	d[u]=d[fa]+1,p[u][0]=fa;
	for(int i=1;(1<<i)<=d[u];i++) p[u][i]=p[p[u][i-1]][i-1];
	for(int v:e[u]) if(v!=fa) dfs(v,u);
}

int main(){
	scanf("%d%d%d",&n,&m,&s);
	for(int i=1,x,y;i<n;i++){
		scanf("%d%d",&x,&y);
		e[x].push_back(y),e[y].push_back(x);
	}
	dfs(s,0);
	for(int i=1,a,b;i<=m;i++){
		scanf("%d%d",&a,&b);
		if(d[a]>d[b]) swap(a,b);
		for(int j=20;j>=0;j--) if(d[a]<=d[b]-(1<<j)) b=p[b][j];
		if(a==b){printf("%d\n",a);continue;}
		for(int j=20;j>=0;j--) if(p[a][j]!=p[b][j])	a=p[a][j],b=p[b][j];
		printf("%d\n",p[a][0]);
	}
	return 0;
}
```

---

## 作者：xpigeon (赞：14)

$2025.3.29$ 修正一处错别字。

$2025.4.29$ 修改了后记。
# 树链剖分求 LCA

## 前言
树剖求 LCA 的基本思想是将树按一定方式剖分成链，随后便可以在链上进行快速操作求得 LCA，单次求解的时间复杂度在 $O(\log{n})$。

## 树剖基本内容

在讲解如何进行树剖求 LCA 前，我们需要先了解树剖的一些相关定义以及性质（有过了解的同学可以自行跳过这部分）。

### 定义

- 重儿子：某个父节点的儿子中，子树大小（也就是子树中节点最多的）最大的节点。（同时规定一个节点的重儿子只有一个）
- 轻儿子：某个父节点的儿子中，非重儿子的节点。
- 重边：父节点与其重儿子连成的边。
- 轻边：父节点与其轻儿子连成的边。
- 重链：由多条重边连成的链。（叶子节点单独成链）

放一张图辅助理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/duojmqm5.png)

上图内容不难从定义推得，我挑取一部分详细解释一下（认为自己能够完全理解定义的同学可以跳过了）：

- $1$ 节点的重儿子是 $4$（其子树大小为 $4$ 并且无法在 $1$ 节点的其他儿子节点找到子树大小更大的）。
- $2$ 节点的重儿子是 $5$（因为只有一个儿子，所以你当然无法找到第二个子树大小更大的）。
- $3$ 节点的重儿子可以在 $6$ 或者 $7$ 中任意选得，因为它们的子树大小是一样的，但我们需要保证一个子树的重儿子只有一个。
- $1$ 节点到 $10$ 节点连成的重链中 $4$ 是 $1$ 的重儿子，$9$ 是 $4$ 的重儿子，$10$ 是 $9$ 的重儿子。
- 节点 $6$ 没有重儿子，单独成链（因为我们要让树全部剖分成链，如果没有重边连成重链，就单独成链），同理，节点 $8$ 也是。

### 性质

我们再次观察上图，不难发现有如下性质：

1. 当前节点 $x$ 每次向下走一条轻边到达轻儿子 $y$，自身的子树大小至少除以 $2$。（否则 $y$ 就应该变为 $x$ 的重儿子）
2. 每条重链的链顶一定是轻儿子。
3. 任意两点的路径可以被不超过 $\log{n}$ 条链覆盖。（可以从性质第一条推导）

至此，树剖的基本定义和性质都已讲解完毕，接下来趁热打铁，具体看看我们究竟是如何进行链上的操作，快速求出两点的最近公共祖先的。

## 求解 LCA

### 操作流程

假设我们现在已经求得各节点的重儿子，并且知道了如何剖分这颗树，并把每个点 $i$ 所在链的链顶记录进了 $top[i]$。

在树上我们随便找两个点，这两个点的编号我们分别假设为变量 $x$ 和变量 $y$，如果我们现在想求得点 $x$ 和点 $y$ 的 LCA，我们需要每次查看这两个点是否在同一条链上，即 $top[x]$ 是否等于 $top[y]$，如果不等于，就让链顶深度更深的点跳出这个链，也就是跳到链顶的父节点，再次判断是否在同一条链上，直到它们跳到了同一条链，此时深度更浅的点就是我们想求得的 LCA。

如下图，模拟了点 $13$ 和点 $9$ 的 LCA 求解过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/7w9w26vw.png)

### 单次操作的时间复杂度

由性质三可以知道，任意两点间的路径至多被 $\log{n}$ 条链覆盖，所以我们的单次链操作求解 LCA 的时间复杂度是在 $O(\log{n})$ 级别的。

## 具体代码实现

想要实现树剖求解 LCA，我们的核心代码需要三部分：两遍 dfs 和求解 LCA 的函数。

1. ```dfs1()```：用于求解整颗树各节点的：子树大小 $siz[i]$、深度 $dep[i]$、父节点 $fa[i]$、重儿子 $hson[i]$。
2. ```dfs2()```：用于求解每个节点所在链的链顶 $top[i]$。
3. ```LCA()```：按照之前讲解的流程求解 LCA。

### 第一遍 dfs

遍历了整棵树求解节点信息，时间复杂度 $O(n)$。

```cpp
//       当前节点  父节点 
void dfs1(int x,int f){
	siz[x]=1;//siz数组先初始化为1，表示目前自身大小为1 
	fa[x]=f;//记录父节点 
	dep[x]=dep[f]+1;//深度比父节点深1 
	for(int i=head[x];i;i=e[i].next){//遍历子节点 
		int y=e[i].to;
		if(y!=f){//注意别遍历回去了 
			dfs1(y,x); 
			siz[x]+=siz[y];//递归回来时，子节点的大小已经被计算完毕，直接加给父节点
			//每次递归判断是否能够更新重儿子节点 
			if(siz[hson[x]]<siz[y] || !hson[x]){
				hson[x]=y;
			}
		}
	}
}
```
### 第二遍 dfs 

注意我们求解各节点所在链的链顶时，有重儿子要先遍历重儿子，直到找不到重儿子再返回。

这是因为沿着重边一路走下去的节点一定在同一条重链，其链顶是一样的，如果找不到重儿子，则说明该重链结束了，需要重新传入链顶参数进行新重链的求解。
同样遍历了一遍整棵树，时间复杂度 $O(n)$。

```cpp
//     当前节点  链顶 
void dfs2(int x,int t){
	top[x]=t;//记录当前节点所在链的链顶 
	if(!hson[x]) return ;//如果找不到重儿子就返回 
	else dfs2(hson[x],t);//继续求解当前重链
	//递归后说明重链已经走完，接下来遍历轻儿子 
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		//这里的判断很容易理解，不能走到父节点还需要满足是轻儿子 
		if(y!=fa[x] && y!=hson[x]){
			dfs2(y,y);//根据性质，轻儿子就是当前新重链的链顶 
		}
	}
}
```
### LCA 函数

上文已经把求解过程描述得很清楚了，具体细节看代码吧。


```cpp
int LCA(int x,int y){
	//如果不在同一条链上 
	while(top[x]!=top[y]){
		//选择链顶深度更深的那个点跳上来 
		if(dep[top[x]]<dep[top[y]]){
			swap(x,y);
		}
		//跳出当前链 
		x=fa[top[x]];
	}
	//如果在一条链上，此时深度更浅的节点就是两个点的LCA 
	return dep[x]<dep[y]?x:y;
	//给不会三目运算符的小朋友解释一下，上面那行的意思是
	/*if(dep[x]<dep[y]){
		return x;
	}
	else{
		return y;
	}*/ 
}
```

## 总时间复杂度
因为两次 dfs 都是 $O(n)$ 的，单次求解 LCA 的时间复杂度是 $O(\log{n})$ 的，一共 $m$ 次操作，故本题的总时间复杂度是 $O(n+m\log{n})$ 的，常数很小，实际运行的速度十分可观。

## 完整代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
struct node{
	int next,to;
}e[N<<1];
int tot,head[N];
int dep[N],siz[N],hson[N],fa[N];
int top[N];
int n,m,s;
void add(int x,int y){
	e[++tot].to=y;
	e[tot].next=head[x];
	head[x]=tot;
}
void dfs1(int x,int f){
	siz[x]=1;
	fa[x]=f;
	dep[x]=dep[f]+1;
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		if(y!=f){
			dfs1(y,x);
			siz[x]+=siz[y];
			if(siz[hson[x]]<siz[y] || !hson[x]){
				hson[x]=y;
			}
		}
	}
}
void dfs2(int x,int t){
	top[x]=t;
	if(!hson[x])return ;
	dfs2(hson[x],t);
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].to;
		if(y!=fa[x] && y!=hson[x]){
			dfs2(y,y);
		}
	}
}
int LCA(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){
			swap(x,y);
		}
		x=fa[top[x]];
	}
	return dep[x]<dep[y]?x:y;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n>>m>>s;
	for(int i=1;i<n;i++){
		int x,y;
		cin>>x>>y;
		add(x,y);
		add(y,x);
	}
	dfs1(s,0);
	dfs2(s,s);
	for(int i=1;i<=m;i++){
		int a,b;
		cin>>a>>b;
		cout<<LCA(a,b)<<'\n';
	}
	return 0;
}
```
## 后记

树链剖分的用途不仅仅是用来求最近公共祖先的，其更大的价值体现在能够快速地进行树上的修改与查询操作，学有余力的同学接下来可以查看我的这篇题解：[题解：P3384 【模板】重链剖分/树链剖分](https://www.luogu.com.cn/article/v9eresjb) 来进行进一步的学习。

#### 至此所有内容已经讲解完毕，笔者力求语言简洁直观，希望大家看到这篇题解都能有所收获，若有不足之处，欢迎私信批评指出，笔者一定认真倾听。

谢谢大家，完结撒花。

---

## 作者：xgzc (赞：7)

这里讲一种硬核做法。

首先$\mathrm{dfs}$整棵树，求出这棵树的欧拉序，然后$\mathrm{LCA}$问题就变成了$\pm 1\mathrm{RMQ}$问题。

考虑$\mathrm{O}(n)$解决$\pm 1\mathrm{RMQ}$问题。

将原序列分块，每一块长度为$\dfrac {\log_2 n}2$，块外用$\mathrm{ST}$表预处理，复杂度$\mathrm{O}(n)$，考虑块内如何$\mathrm{O}(1)$回答。

因为相邻两项之差最多为$1$，所以块内本质不同的状态只有$2 ^ {\frac {\log n} 2} = \sqrt n$种。

那么可以设$f[S][l][r]$表示状态为$S$时，区间$[l, r]$的最小值。

于是块内就能$\mathrm{O}(1)$解决了，这一部分预处理的复杂度为$\mathrm{O}(\sqrt n \log^2n)$。

因为以上操作复杂度均没有超过$\mathrm{O}(n)$，所以预处理的复杂度为$\mathrm{O}(n)$，总复杂度为$\mathrm{O}(n) - \mathrm{O}(1)$。

代码见我的[$\texttt{blog}$](https://www.cnblogs.com/cj-xxz/p/11142232.html)

---

## 作者：jzl_1210 (赞：4)

最近刚学了最近公共祖先，趁此机会来写一篇倍增法题解。

# 算法介绍

## 定义
在一棵有根树中，有 $u$ 和 $v$ 两个结点。我们需要找到一个点 $x$，满足 $x$ 既是 $u$ 的祖先又是 $v$ 的祖先。这个结点 $x$，就是 $u$ 和 $v$ 的最近公共祖先。

最近公共祖先的倍增法可以很好地解决这一问题。

## 实现
容易想到，我们可以先将深度大的结点跳到和深度小的结点的深度一样，然后在一层层地往上寻找，直到两个结点相同，此时所在结点就是最近公共祖先。

但是，这样的写法会超时。该怎么办呢？

我们可以参考倍增的做法，每次不跳一格，而是跳多格，这样子就可以达到节省时间的效果。

## 流程

先搜索得出每个结点深度。

定义 $lg_i$ 表示一个非负整数 $x$，使得 $2^x$ **不大于** $i$，满足条件的 $x$ 的最大值即为 $lg_i$。

定义 $f[i][j]$ 表示结点 $i$ 往上跳 $2^j$ 格会到哪里。

预处理部分就很简单了，如果不会的请移至[此题](https://www.luogu.com.cn/problem/P3865)。

不一样的是，$i$ 往上跳 $2^j$ 格，可以分解成 $i$ 往上跳 $2^{j-1}$ 格，再往上跳 $2^{j-1}$ 格。这样就可以预处理好 $f$ 数组了。

当他们在同一深度了，要继续往上跳时，如果跳到的这个结点是 $u$ 和 $v$ 的公共祖先，由于我们无法确定这个结点是不是最近公共祖先。所以是不可行的，只有当跳到的结点不是 $u$ 和 $v$ 的最近公共祖先才能继续往上跳。

最后，可以~~神奇的~~发现，这个点的父亲结点就是最近公共祖先了。

# 正确性证明
## 时间复杂度
预处理 $f$ 数组，时间复杂度为 $O(n \log n)$。  
单此查询，时间复杂度为 $O(\log n)$。

总体来说，倍增法可以通过此题。

## 递推式

因为要知道某个点跳 $2^j$ 格到哪，就要知道某个点跳 $2^{j-1}$ 格，而在上次循环中已经求出了每个点跳 $2^{j-1}$ 格会到哪里。所以递推式正确。

## 查询
一开始需要将两个不同深度的结点跳到同一深度，设 $u$ 为深度大的结点，$v$ 为深度小的结点，$c$ 为 $u$ 的深度与 $v$ 的深度的差值，那么每次都要跳 $2^c$ 格，这样循环，最后两个结点深度一定相同。

需要同时往上跳时，只要跳到的结点不是公共祖先就可以往上跳，那么最后一定是在最近公共祖先的下一层。

因此，查询的部分也是正确的。

综上所述，该算法是正确的。


# 代码实现

朴素方法的部分代码（会超时）：


```cpp
if(dep[x] < dep[y]){
	swap(x, y);
}
int t = x, p = y;
while(dep[t] != dep[p]){
	t = f[t];//先让深度大的结点往上跳
}
while(t != p){
	t = f[t], p = f[p];//再让两个结点同时往上跳
}
```

倍增法代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 500005, M = N;
int n, m, s, lg2[N], f[N][22], head[N], ct, dep[N], maxd = -1;
//lg2[i]:log2(i)向下取整后的值 
//dep[i]:结点i的深度 
struct edge{
	int to, nxt;//简单的链式前向星 
} a[N << 1];
void add(int u, int v){
	a[++ct].to = v, a[ct].nxt = head[u], head[u] = ct; 
	//简单的链式前向星
}
void dfs(int x, int fa){
	f[x][0] = fa;//点x的父亲就是fa 
	dep[x] = dep[fa] + 1;//计算出结点x的深度 
	if(dep[x] > maxd) maxd = dep[x];//计算最大深度 
	for(int i = head[x];i > 0;i = a[i].nxt){
		int tod = a[i].to;
		if(tod != fa){//防止遍历自己的父亲 
			dfs(tod, x);//继续搜索 
		}
	}
}
int lca(int u, int v){
	if(dep[u] < dep[v]) swap(u, v);
	while(dep[u] > dep[v]){
		u = f[u][lg2[dep[u] - dep[v]]];
		//先让两个结点跳到同一深度 
	}
	if(u == v) return u;
	for(int i = lg2[dep[u] - 1];i >= 0;i--){
		if(f[u][i] != f[v][i]){
			u = f[u][i], v = f[v][i];
			//两个结点同时往上跳 
		}
	}
	return f[u][0];//最后的父亲结点就是最近公共祖先 
}
int main(){
	scanf("%d%d%d", &n, &m, &s);
	for(int i = 2;i <= n;i++) lg2[i] = lg2[i / 2] + 1;
	//预处理lg2数组 
	for(int i = 1;i < n;i++){
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v), add(v, u);
	}
	dfs(s, 0);
	for(int j = 1;j <= lg2[maxd];j++){
		for(int i = 1;i <= n;i++){
			f[i][j] = f[f[i][j - 1]][j - 1];
		}//预处理f数组 
	}
	for(int i = 1;i <= m;i++){
		int u, v;
		scanf("%d%d", &u, &v);
		printf("%d\n", lca(u, v));//计算lca 
	}
	return 0;
} 
```

---

## 作者：sieve (赞：2)

upd：2025.4.20 更新了一处笔误。

## 最近公共祖先（LCA，Lowest Common Ancestor）

### 定义

如果有两个点 $x$ 和 $y$，那么点 $z$ 是 $\operatorname{LCA}(x , y)$ 当且仅当 $z$ 是 $x$ 的祖先且 $z$ 是 $y$ 的祖先且满足前两个条件的情况下，$z$ 的深度最大。

### 求解

1. 暴力做法（无预处理，查询 $O(n)$）

首先从 $x$ 出发一直往根走，把沿途的点都标记，然后 $y$ 再往根走，如果遇到了被标记的点，则最先遇到的就是 $\operatorname{LCA}(x , y)$。

2. 倍增做法（预处理 $O(n \log n)$，查询 $O(\log n)$）

- 预处理

我们定义 $f_{i , j}$ 为当前点是 $i$，然后往根节点方向跳 $2 ^ j$ 步的**节点**。

还要预处理出每个节点的深度。

然后就是对倍增进行更新。

我们知道：$2 ^ k = 2 ^ {k - 1} + 2 ^ {k - 1}$，所以我们可以拆分，就得到了状态转移：

$$
f_{i , j} \gets
f_{f_{i , j - 1} , j - 1}
$$

也就是从上一级转移过来（$i$ 是当前节点，$j$ 是枚举的幂次）。

那么初始值就是 $f_{i , 0} = fa_i$（$fa_i$ 表示 $i$ 的父节点）。

- 查询

我们定义 $dep_x \ge dep_y$，其中 $dep_i$ 是第 $i$ 个点的深度。

那么，我们可以从大到小枚举跳的幂次，如果跳了这么多后，$dep_x$ 还是 $\ge dep_y$，那么说明可以跳上去。

跳完后，判断两个是不是相等，因为有可能 $y$ 是 $x$ 的祖先。

然后，只要跳上去后 $x$ 和 $y$ 不相等，就一直跳，因为如果相等了，但是不一定是最近的，所以我们找到最后一个不相等的，再往上跳一步就是 $\operatorname{LCA}(x , y)$ 了。

```cpp
void Search(int u, int fa) // 预处理
{
	dep[u] = dep[fa] + 1, f[u][0] = fa; // 处理深度，及f的初始化
	for (int i = 1; i <= 20; ++i) f[u][i] = f[f[u][i - 1]][i - 1]; // 转移
	for (int v : g[u]) if (v != fa) Search(v, u); // 下一个
	return;
}

int query(int x, int y) // 查询
{
    if (dep[x] < dep[y]) swap(x, y); // 满足上述规则
    for (int i = 20; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i]; // 跳到和y深度一样
    if (x == y) return x; // 特判
    for (int i = 20; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; // 再一起跳
    return f[x][0]; // 返回答案
}
```

### 完整代码

```cpp
#include <iostream> 
#include <cstdio> 
#include <algorithm> 
#include <cmath>
#include <queue>
#include <string>
#include <vector>
#include <cstring>
#include <bitset>
#define int long long

using namespace std;

const int N = 5e5 + 5, INF = 1e18;
int n, q, s, dep[N], f[N][25];
vector<int> g[N];

void Search(int u, int fa)
{
	dep[u] = dep[fa] + 1, f[u][0] = fa;
	for (int i = 1; i <= 20; ++i) f[u][i] = f[f[u][i - 1]][i - 1];
	for (int v : g[u]) if (v != fa) Search(v, u);
	return;
}

int query(int x, int y)
{
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = 20; i >= 0; --i) if (dep[f[x][i]] >= dep[y]) x = f[x][i];
    if (x == y) return x;
    for (int i = 20; i >= 0; --i) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
    return f[x][0];
}

signed main()
{
	cin.tie(0)->sync_with_stdio(false);
	cin >> n >> q >> s;
	for (int i = 1, x, y; i < n; ++i)
	{
		cin >> x >> y;
		g[x].emplace_back(y), g[y].emplace_back(x);
	}
	Search(s, 0);
    for (int x, y; q--; cout << '\n')
    {
        cin >> x >> y;
        cout << query(x, y);
    }
	return 0;
}
```

麻烦管理重新审核一下

---

## 作者：collegiate (赞：2)

## 前言

我们看到这道题的时候，先考虑暴力。

但是如果这一颗树退化成一条链，那么让你查询一个最下面的节点你不就炸了吗？

所以我们考虑**最近公共祖先**算法，这里我们着重讲解**倍增法**。

## 思路

既然是倍增法，那么肯定有倍增的思想。

我们一般的最近公共祖先都是两个节点一个一个父节点往上跳，但是这样显然时间复杂度会爆炸。

所以我们使用倍增思想来解决。

我们设 $f_{k,j}$ 表示节点 $k$ 往上跳 $2^j$ 层，那么 $f_{k,0}$ 就表示节点 $k$ 的父亲节点了。

来到了最难的地方——推公式，其实思考一会也能做出来，但是也需要思维含量。

我们知道 $f_{k,j}$ 表示节点 $k$ 往上跳 $2^j$ 层，那么 $f_{k,j}$ 是否就等同于先往上跳 $2^{j-1}$ 层，再跳 $2^{j-1}$ 层呢？正确！

那么我们就可以得出一个关于 $f_{k,j}$ 的式子：

$$f_{k,j} = f_{f_{k,j-1},j-1}$$

解释一下，式子 $f_{k,j-1}$ 表示节点 $k$ 往上跳 $2^{j-1}$ 层，所以 $f_{f_{k,j-1},j-1}$ 就是节点 $k$ 往上跳 $2^{j-1}$ 层之后所在的节点再往上跳 $2^{j-1}$ 层，和刚才推的一样。

但是不能跳出根节点！在不跳出根节点的情况下，时间复杂度是 $O(n \log n)$。

最后的答案就是我们存下的 $f_{k,j}$ 了。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e5+5,M=5e5+5;
struct node{
	ll next,to;
}edge[M<<1];
ll head[N],cnt;
ll n,q,s,x,y,ans;
ll fa[N][25],lg[N],depth[N];
void add(ll from,ll to){
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	head[from]=cnt;
}
void dfs(ll now,ll father){
	fa[now][0]=father;//更新父亲节点 
	depth[now]=depth[father]+1;//更新深度 
	for(int i=1;i<=22;i++) fa[now][i]=fa[fa[now][i-1]][i-1];//当前节点的i级祖先是当前节点的i-1级祖先的i-1级祖先 
	for(int i=head[now];i;i=edge[i].next) if(edge[i].to!=father) dfs(edge[i].to,now); 
}
ll LCA(ll x,ll y){
	if(depth[x]<depth[y]) swap(x,y);//让x的深度>y的深度
	for(int i=22;i>=0;i--) if(depth[x]-(1<<i)>=depth[y]) x=fa[x][i]; 
	if(x==y) return x;////如果x是y的祖先，那他们的LCA肯定就是x了
	for(int k=22;k>=0;k--)//同时往上跳 
		if(fa[x][k]!=fa[y][k])
			x=fa[x][k],y=fa[y][k];
	return fa[x][0];//最后返回x的祖先，即LCA(x,y); 
}
int main(){
	cin>>n>>q>>s;
	for(int i=1;i<n;i++){
		cin>>x>>y;
		add(x,y);//加边 
		add(y,x);
	} 
	dfs(s,0);//深度优先搜索 
	for(int i=1;i<=q;i++){
		cin>>x>>y;
		ans=LCA(x,y);//输出答案 
		cout<<ans<<endl;
	}
	return 0;
}


```

---


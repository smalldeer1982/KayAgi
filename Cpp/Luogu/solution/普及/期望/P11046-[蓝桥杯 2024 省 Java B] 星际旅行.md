# [蓝桥杯 2024 省 Java B] 星际旅行

## 题目背景

备注：原题（Java）时间限制 3.0s，空间限制 512 MB。

## 题目描述

小明国庆节准备去某星系进行星际旅行，这个星系里一共有 $n$ 个星球，其中布置了 $m$ 道双向传送门，第 $i$ 道传送门可以连接 $a_i$，$b_i$ 两颗星球（$a_i \neq b_i$ 且任意两颗星球之间最多只有一个传送门）。

他看中了一款 “旅游盲盒”，一共有 $Q$ 个盲盒，第 $i$ 个盲盒里的旅行方案规定了旅行的起始星球 $x_i$ 和最多可以使用传送门的次数 $y_i$。只要从起始星球出发，使用传送门不超过规定次数能到达的所有星球都可以去旅行。

小明关心在每个方案中有多少个星球可以旅行到。小明只能在这些盲盒里随机选一个购买，他想知道能旅行到的不同星球的数量的期望是多少。

## 说明/提示

【样例解释】

- 第一个盲盒可以旅行到 $1, 2, 3$。
- 第二个盲盒可以旅行到 $2$。
- 第三个盲盒可以旅行到 $1, 2$。

所以期望是 $(3 + 1 + 2) / 3 = 2.00$。

【数据范围】

- 对于 $20 \%$ 的评测用例，保证 $n \leq 300$。
- 对于 $100 \%$ 的评测用例，保证 $n \leq 1000$，$m \leq \min \left\{\dfrac{n(n - 1)}{2}, 5n\right\}$，$Q \leq 50000$，$0 \leq y_i \leq n$，$1 \leq x_i \leq n$。

## 样例 #1

### 输入

```
3 2 3
1 2
2 3
2 1
2 0
1 1```

### 输出

```
2.00```

# 题解

## 作者：Forge_Unique (赞：7)

## 简化题意
给定 $n$ 个点，$m$ 条双向边，求从 $x_i$ 点出发最多经过 $y_i$ 条边，所能到达的点的个数。

## 思路
我们用一个二维数据 $d_{i,j}$ 表示从第 $i$ 个点走到第 $j$ 个点最少要经过几条边，可以跑一遍迪杰斯特拉来求出来。然后对于第 $k$ 个盲盒，从 $1$ 枚举到 $n$ 算出有几个点 $i$ 满足 $d_{x_k,i}\leq y_k$ 。

[代码](https://www.luogu.com.cn/paste/f1vdck76)

---

## 作者：Aleph_Drawer (赞：5)

请大家认真考虑本题的难度以及做题对象，省赛 B 组的 E 题就要用到堆优化 Dijkstra / 二分但 G 就是简单数据结构，显然是不合理的题目设置，本题不应当使用任何数据结构完成。

结合本题的较为宽松的时限和神秘的 $m \leq 5n$ 的限制，以及标签的提示，我们可以考虑采用 $\mathcal O(mq)$ 的朴素广度优先搜索完成。

---

首先明确期望的求法，由于 $q$ 种情况等可能，我们只需要将 $q$ 种情况的每一种的数量都算出来，记为 $cnt_i$，那么答案就是 $\sum q^{-1}cnt_i$。

下面就是求 $cnt_i$ 的部分。注意到这个可以 $\mathcal O(m)$ 的使用广度优先搜索解决。

---

计算量最多为 $m \times q = 2.5 \times 10^8$，可以通过。

---

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1e5 + 105;
const ll MOD = 998244353;
const ll INF = 0x3f3f3f3f;

vector<int> e[N];
int n, m, q;
int cnt[N]; int dis[N];
queue<int> Q;
bool inq[N];

void bfs(int num, int pos, int lim) {
    queue<int>().swap(Q);
    for(int i = 1; i <= n; i++)
        dis[i] = INF;
    dis[pos] = 0;
    Q.push(pos);
    cnt[num]++;
    while(!Q.empty()) {
        int x = Q.front(); Q.pop();
        if(dis[x] == lim) continue;
        for(int v : e[x]) {
            if(dis[v] == INF) {
                cnt[num]++;
                dis[v] = dis[x] + 1;
                Q.push(v);
            }
        }
    }
    return;
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m >> q;
    for(int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        e[x].push_back(y), e[y].push_back(x);
    }
    long double ans = 0;
    for(int i = 1; i <= q; i++) {
        int pos, lim;
        cin >> pos >> lim;
        bfs(i, pos, lim);
        ans += 1.0 * (1.0 / q) * cnt[i];
    }
    cout << fixed << setprecision(2) << ans;
    return 0;
}
```

---

## 作者：zhangshiyan (赞：4)

# P11046 [蓝桥杯 2024 省 Java B] 星际旅行
[R177825581 记录详情](https://www.luogu.com.cn/record/177825581)

## Main Idea
有 $n$ 个点，$m$ 条边，第 $i$ 条边表示一条连接 $u$ 与 $v$ 的无向边。

接下来有 $Q$ 个询问，求从 $x_i$ 出发，最多经过 $y_i$ 条边，所能到达的点的个数。

输出一行能到达的点的个数的期望是多少。

## Solution
从每个点跑一遍单源最短路，求出 $dis_{i,j}$ 表示从 $i$ 到 $j$ 所经过的边数。

对于每个询问，统计所有从 $u$ 出发到每一个点的距离小于等于 $y_i$ 的点数。

## Code
```cpp
#include <bits/stdc++.h>
#define INF 0x7fffffff
using namespace std;
typedef long long ll;
inline ll read()
{
	register ll x = 0, f = 1;
	register char ans = getchar();
	while(ans < '0' || ans > '9')
	{
		if(ans == '-')
			f = -1;
		ans = getchar();
	}
	while(ans >= '0' && ans <= '9')
	{
		x = x * 10 + ans - 48;
		ans = getchar();
	}
	return x * f;
}
inline ll gcd(ll a, ll b)
{
	return b > 0 ? gcd(b, a % b) : a;
}
ll p, nxt[300005], val[300005], head[300005], to[300005];
void add(ll u, ll v, ll w)
{
	nxt[++p] = head[u];
	head[u] = p;
	to[p] = v;
	val[p] = w;
}

struct node
{
	ll dis, id;
	bool operator<(const node &cmp) const
	{
		return cmp.dis < dis;
	}
};

ll n, m, q;
ll dis[1005][5005];
ll vis[1005][5005];
ll a[300005], nnn;

void dijkstra(ll s)
{
	for(ll i = 0; i <= n; i++)
	{
		dis[s][i] = INF;
	}
	dis[s][s] = 0;
	node t;
	t.dis = 0;
	t.id = s;
	priority_queue<node> q;
	q.push(t);
	while(!q.empty())
	{
		ll u = q.top().id;
		q.pop();
		if(vis[s][u])
		{
			continue;
		}
		vis[s][u] = 1;
		for(ll i = head[u]; i; i = nxt[i])
		{
			ll v = to[i];
			ll w = val[i];
			if(dis[s][v] > dis[s][u] + w)
			{
				dis[s][v] = dis[s][u] + w;
				if(!vis[s][v])
				{
					node t;
					t.dis = dis[s][v];
					t.id = v;
					q.push(t);
				}
			}
		}
	}
}

int main()
{
	n = read(), m = read(), q = read();
	for(ll i = 1; i <= m; i++)
	{
		ll u = read(), v = read();
		add(u, v, 1);
		add(v, u, 1);
	}
	for(ll i = 1; i <= n; i++)
	{
		dijkstra(i);
	}
	ll ans = 0;
	for(ll i = 1; i <= q; i++)
	{
		ll u = read(), cost = read();
		for(ll i = 1; i <= n; i++)
		{
			if(dis[u][i] <= cost)
			{
				ans++;
			}
		}
	}
	printf("%.2lf", ans * 1.0 / q);
	return 0;
}
```

---

## 作者：andycode (赞：3)

# 题目大意
给出一张无向图，总共有 $Q$ 次询问，求所有与 $x_i$ 的距离不超过 $y_i$ 的结点的个数，输出每次询问的答案的平均数。
# 思路讲解
由于时限较大且数据较小，所以我们可以考虑直接 `bfs` 统计所有距离不超过 $y_i$ 的结点，将答案累加后再除 $Q$。

算法复杂度为 $O((n+m) \times Q)$。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF=(1LL<<31-1);
int n,m,q;
vector<int> g[1003];
int bfs(int x,int y){
    int sum=1,dist[1003];//要算上x，初始化为1
    queue<int> q;
    q.push(x);
    for(int i=1;i<=n;i++)
        dist[i]=INF;//初始化dist数组
    dist[x]=0;
    while(q.size()){
        int f=q.front(),len=g[f].size();
        q.pop();
        if(dist[f]==y)//如果为y，说明已经没有距离不超过y的未被访问的点
            break;//跳出循环
        for(int i=0;i<len;i++)
            if(dist[g[f][i]]==INF)
                sum++,dist[g[f][i]]=dist[f]+1,q.push(g[f][i]);
    }
    return sum;
}
int main(){
    int ans=0;
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=m;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        g[a].push_back(b);
        g[b].push_back(a);
    }
    for(int i=1;i<=q;i++){
        int a,b;
        scanf("%d%d",&a,&b);
        ans+=bfs(a,b);//累加答案
    }
    printf("%.2lf",1.0*ans/q);
    return 0;
}
```

---

## 作者：grass_dream (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11046)

# 题意：

给定一个 $n$ 个点 $m$ 条边的无向图，进行 $Q$ 次询问：求所有到点 $x$ 距离不超过 $y$ 条边的点的总点数；不过，不用一次一次的回答，而是在最后一次询问结束后让你回答这 $Q$ 次询问的平均值。

# 思路：

看到题目范围，这道题的数据其实还挺水的，可以直接使用广度优先搜索解决。

解决方法：用一个数组记录下每次询问的答案，然后在最后把它们加起来，然后在除以 $Q$ 就可以了。

# AC code:

```cpp

#include<bits/stdc++.h>
using namespace std;
const int INF=0x3f3f3f3f;
long long n,m,Q;
vector<int>w[1001];
int step[50001],sum[50001];
void bfs(int t,int x,int y){
	memset(step,INF,sizeof(step));//初始化
	queue<int>q;sum[t]++;
	q.push(x);
	step[x]=0;
	while(!q.empty()){
		int a=q.front();q.pop();
		if(step[a]==y)continue;//如果已经走了y步的话就不能走了
		for(int i=0;i<w[a].size();++i){
			int gg=w[a][i];
			if(step[gg]!=INF)continue;//已经走过，不能走
			q.push(gg);//入队
			step[gg]=step[a]+1;//最小步数
			sum[t]++;//又多了一个可以走的点
		}
	}
}
int main(){
	cin>>n>>m>>Q;
	double ans=0;
	for(int i=1;i<=m;++i){//输入
		int a,b;cin>>a>>b;
		w[a].push_back(b);
		w[b].push_back(a);
	}
	for(int i=1;i<=Q;++i){//询问
		int x,y;cin>>x>>y;
		bfs(i,x,y);
	}
	for(int i=1;i<=Q;++i)ans+=sum[i];//求和
	printf("%.2lf\n",(ans*1.0)/(Q*1.0));//输出平均值
	return 0;
}

```

---

## 作者：Aventurine_stone (赞：1)

## 1. 题目分析
题目意思简单明了，最终期望就是将每个 $x$ 点能到达星球的总和除以 $Q$ 即可。
## 2. 题目做法
这题的唯一难点就在于如何快速求出到达星球的总和。  
首先想到的做法便是依次计算每一个 $x$ 可到达的点数，再将它们加起来。这样做反正我没过，其他人有些过了，但几乎都是最劣解，~~建议加强数据~~。  
我们只需加一个小优化即可，我们先记录每个点最多走多少步就可以遍历所有点。如果 $y$ 大于等于这个值，我们不能直接加 $n$，因为图可能不连通，所以我们还要顺带记录每个点最多可以走到几个点。
## 3. 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010,M=10010;
inline int read()
{
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}
int head[N],ne[M],e[M],idx;
inline void add(int x,int y)
{
	ne[++idx]=head[x];
	head[x]=idx;
	e[idx]=y;
}
int n,m,q;
int dist[N],best[N],sum[N],t,s,cl[N],cnt;
int d[N],l,r;
double bfs(int x,int y)
{
	if(!y)
		return 1;
	if(y>=best[x])
		return sum[x];
	s=l=r=1;
	d[1]=x,dist[x]=1;
	cnt=0;
	cl[++cnt]=x;
	while(l<=r)
	{
		t=d[l];
		for(int i=head[t];i;i=ne[i])
		{
			int c=e[i];
			if(!dist[c])
			{
				dist[c]=dist[t]+1;
				s++;
				cl[++cnt]=c;
				if(dist[t]!=y)
					d[++r]=c;
			}
		}
		l++;
	}
	for(int i=1;i<=cnt;i++)
		dist[cl[i]]=0;
	return s;
}
void bfs2(int x)
{
	s=l=r=1;
	d[1]=x,sum[x]=dist[x]=1;
	while(l<=r)
	{
		t=d[l];
		for(int i=head[t];i;i=ne[i])
		{
			int c=e[i];
			if(!dist[c])
			{
				dist[c]=dist[t]+1;
				d[++r]=c;
				sum[x]++;
			}
		}
		l++;
	}
	for(int i=1;i<=n;i++)
		best[x]=max(best[x],dist[i]),dist[i]=0;
	best[x]--;
}
int x,y;
double z,ans;
int main()
{
	n=read(),m=read(),q=read();
	while(m--)
	{
		x=read(),y=read();
		add(x,y),add(y,x);
	}
	for(int i=1;i<=n;i++)
		bfs2(i);
	z=q;
	while(q--)
	{
		x=read(),y=read();
		ans+=bfs(x,y);
	}
	printf("%.2lf",ans/z);
	return 0;
}
```

---

## 作者：OODY (赞：1)

## 题解
题意即给一张无向图以及 $Q$ 个询问，每次询问第 $i$ 点走 $j$ 步能到达几个点。

由于 $n$ 的范围可以支持 $O(n^2)$ 复杂度的算法，所以直接跑一遍全源最短路（注意用堆优化）就能求出所有点对之间的最短距离。

开个桶存下离第 $i$ 个点距离为 $s$ 的点的数量，求一个前缀和，就能知道某个点走 $s$ 步能够到达的点的数量。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
    int u,dis;
    bool operator<(const node &t)const{return dis>t.dis;}
    //默认大顶堆，修改后是小顶堆
};
const int maxn=2000;
int n,m;
int dis[maxn][maxn];
int cnt[maxn][maxn];
int vis[maxn];
priority_queue<node>q;
vector<int>e[maxn];
void dijkstra(int s){//起始点
    memset(vis,0,sizeof(vis));
    q.push({s,0});
    dis[s][s]=0,cnt[s][0]=1;
    while(!q.empty()){
        int u=q.top().u;q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto v:e[u]){
            if(dis[s][v]>dis[s][u]+1){
                if(dis[s][v]<2000)cnt[s][dis[s][v]]--;
                dis[s][v]=dis[s][u]+1;
                cnt[s][dis[s][v]]++;
                q.push({v,dis[s][v]});
            }
        }
    }
}
void solve(){
    int Q;
    cin>>n>>m>>Q;
    memset(dis,0x3f,sizeof(dis));
    for(int i=1;i<=m;++i){
        int u,v;
        cin>>u>>v;
        e[u].emplace_back(v);
        e[v].emplace_back(u);
    }
    for(int i=1;i<=n;++i){
        dijkstra(i);
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            cnt[i][j]+=cnt[i][j-1];
        }
    }
    double ans=0;
    for(int i=1;i<=Q;++i){
        int a,t;
        cin>>a>>t;
        //cout<<dis[2][1]<<'\n';
        //cout<<cnt[a][t]<<'\n';
        ans+=cnt[a][t];
    }
    cout<<fixed<<setprecision(2)<<ans/Q<<'\n';
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    //fstream in("in.txt",ios::in);cin.rdbuf(in.rdbuf());
    int t=1;
    //cin>>t;
    while(t--) solve();
    return 0;
}
```

---

## 作者：xueshengyi (赞：1)

题目中这 $m$ 道双向传送门可以看成是 $m$ 条双向边，$n$ 个星球可以看成 $n$ 个节点，然后这道题就可以简化成图了。

瓶颈就在时间复杂度上，然后我们可以发现，由于 $n$ 很小，所以可以预处理 $n$ 个点相互之间的最短路。

当预处理完第 $i$ 个节点到其他节点的距离时，可以将这个点到其它点的距离进行排序，最后询问时用二分查找，将得到的答案减 $1$ 即可。

这里注意一个坑点，因为题目中有可能会有一个节点到达不了的节点，但是他们的距离在数组中是 $0$，所以在二分查找后需要将得到的答案 $p$ 减去 $x$ 无法到达的点的个数之后再减 $1$。

当然，也可以把记录距离的数组初值设为极大值，这样就规避掉了上面的坑点。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define For(i,x,y,...) for(long long i=(x),##__VA_ARGS__;i<=(y);++i)
#define foR(i,x,y,...) for(int i=(x),##__VA_ARGS__;i>=(y);--i)
#define Rep(i,x,y,...) for(int i=(x),##__VA_ARGS__;i<(y);++i)
#define endl '\n'
#define debug(...)
#define debug1(a,i,...) cout<<i<<" "<<a[i]<<endl;
typedef long long ll;
#define fi first
#define se second
#define PII pair<int,int>
#define me(s,x) memset(s,x,sizeof s)
#define pb emplace_back

template<typename T=int>T read(){T x;cin>>x;return x;}
const int mod=998244353;
struct mint{
	int x;mint(int x=0):x(x<0?x+mod:x<mod?x:x-mod){}
	mint(ll y){y%=mod,x=y<0?y+mod:y;}
	mint& operator += (const mint &y){x=x+y.x<mod?x+y.x:x+y.x-mod;return *this;}
	mint& operator -= (const mint &y){x=x<y.x?x-y.x+mod:x-y.x;return *this;}
	mint& operator *= (const mint &y){x=1ll*x*y.x%mod;return *this;}
	friend mint operator + (mint x,const mint &y){return x+y;}
	friend mint operator - (mint x,const mint &y){return x-y;}
	friend mint operator * (mint x,const mint &y){return x*y;}
};mint Pow(mint x,ll y=mod-2){mint z(1);for(;y;y>>=1,x*=x)if(y&1)z*=x;return z;}
const int N=1010,M=5010;
vector<int> e[M<<1];
int n,m,Q;
bool vis[N];
queue<int> q;
int dis[N][N];
int ca[N];
bool bk[N][N];
void MAIN(){
	cin>>n>>m>>Q;
	For(i,1,m,u,v){
		cin>>u>>v;
		e[u].pb(v),e[v].pb(u);
		ca[u]++,ca[v]++;
		bk[u][v]=bk[v][u]=1;
	}
	For(i,1,n){
		ca[i]++;
		bk[i][i]=1;
		me(vis,0);
		dis[i][i]=0;
		q.push(i);
		while(!q.empty()){
			int u=q.front();
			q.pop();
			for(int v:e[u]){
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
					dis[i][v]=dis[i][u]+1;
					if(!bk[i][v]){
						ca[i]++;
						bk[i][v]=1;
					}
				}
			}
		}
		dis[i][i]=0;
		sort(dis[i]+1,dis[i]+n+1);
	}
	int ans=0;
	int l=Q; 
	while(Q--){
		int x,y;
		cin>>x>>y;
		int p=upper_bound(dis[x]+1,dis[x]+n+1,y)-dis[x];
		p-=n-ca[x];
		ans+=p-1;
	}
	printf("%.2lf",ans*1.0/l);
}signed main(){
	int t=1;while(t--){
		MAIN();
	}
	return 0;
}
```

---

## 作者：shaotianyu (赞：0)

很裸的最短路题目，看到这个连接两点的双向传送门很容易联想到图论知识点，往后看发现他就是一道求多源汇最短路的题目，计算对于第 $i$ 个盲盒的起点   $x_i$ 走到其他点走过的传送门数量（可以考虑每条边边权为 1 ）不多于 $y_i$    的数量之和再除盲盒总数便是其期望。

注意到时间限制为 2 秒，所以直接每个盲盒起点都跑一次  dijkstra  也能过，时间复杂度约为  $O(q\cdot m \log n)$  代码如下，基本就是模板了：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#define int long long
using namespace std;
const int N=1010;
int a[N][N];
bool vis[N];

struct node{
	int v,x;
	bool operator <(const node&A) const{
		return x>A.x;
	} 
};

vector <node> v[N];
priority_queue <node> q;
int n,m,Q;

void dijkstra(int s){
	memset(vis,0,sizeof(vis));
	a[s][s]=0;
	q.push({s,0});
	while(!q.empty()){
		node tp=q.top();
		int k=tp.v;
		q.pop();
		if(vis[k]) continue;
		vis[k]=1;
		for(auto y:v[k]){
			if(!vis[y.v]&&a[s][y.v]>a[s][k]+y.x){
				a[s][y.v]=a[s][k]+y.x;
				q.push({y.v,a[s][y.v]});
			}
		}
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin>>n>>m>>Q;
	memset(a,0x3f,sizeof(a));

	while(m--){
		int u,x;
		cin>>u>>x;
		v[u].push_back({x,1});
		v[x].push_back({u,1});
	}

	int cnt=0;
	for(int i=1;i<=Q;i++){
		int s,x;
		cin>>s>>x;
		dijkstra(s);
		for(int i=1;i<=n;i++) if(a[s][i]<=x) cnt++;
	}

	printf("%.2lf",cnt*1.0/Q);
	return 0;
}
```

---


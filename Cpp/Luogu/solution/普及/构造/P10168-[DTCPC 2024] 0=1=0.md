# [DTCPC 2024] 0=1=0

## 题目描述

给你一个只含 $0$ 和 $1$ 的字符串 $s$。

每次你可以选择 $i\in [1,n)$，并将 $s_i$ 和 $s_{i+1}$ 分别取反。

定义 $1$ 取反结果为 $0$，$0$ 取反结果为 $1$。

要求使得顺序对数量最大，即使得 $i\lt j$ 且 $s_i\lt s_j$ 的 $(i,j)$ 个数最大。

输出方案。

## 样例 #1

### 输入

```
111100```

### 输出

```
8
2
1 5```

# 题解

## 作者：szh_AK_all (赞：16)

### 题意
我们需要进行若干次操作，使得字符串 $s$ 的顺序对数量最大。每次操作可以将 $s$ 中相邻的两个值取反。

### 分析
由于 $s$ 只包含 $0$ 和 $1$，所以为了使顺序对数量最大，我们尽可能将 $1$ 放在末尾，将 $0$ 尽可能放在前面。可以发现，经过操作后，$0$ 或 $1$ 的数量会发生改变。所以，这也为我们后续的操作奠定了基础。

首先，我们将问题简化：我们可以让字符串 $s$ 末尾有任意数量的 $1$，开头有任意数量的 $0$，那么我们该如何分配 $1$ 和 $0$ 的数量，使得顺序对数量最大呢？

相信大家都明白这个道理吧：在周长相等的正方形与长方形中，正方形面积总比长方形大。为什么？因为正方形的边长相等，也就是差值为 $0$。

转换为数学逻辑就是：$x1\times x2$ 与 $y1\times y2$ 相比（$x1+x2=y1+y2$，为了方便起见，设 $x1\le x2,y1\le y2$），若 $x2-x1<y2-y1$，则 $x1\times x2>y1\times y2$；反之同理。

举个例子：若 $s$ 的长度为 $5$，则最优情况下 $s$ 中有两个 $0$，三个 $1$，或者有三个 $0$，两个 $1$。

清楚这个问题后，再来考虑题目。我们要尽可能让 $1$ 靠后，$0$ 考前，且 $1$ 的数量与 $0$ 的数量相差小，则我们由字符串的末尾像中间枚举，若枚举到的字符为 $0$，则使用一次操作；同理，再由字符串的开头像中间枚举，若枚举到的字符为 $1$，则使用一次操作。

枚举 $1$ 的情况时若枚举到的字符为 $0$，则使用一次操作，为什么这样可以保证字符串从中间到末尾都为 $1$ 呢？假设该字符前一个字符为 $0$，则两全其美，这两个字符都变为了 $1$；若前一个字符为 $1$，则在操作之后，前一个字符变为 $0$，但是不用担心，因为在下一轮的枚举中前一个字符又会变为 $1$。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int ans, a[200005];

int main() {
	string s;
	cin >> s;
	int n = s.size();
	for (int i = n - 1; i >= n / 2; i--) {
		if (s[i] == '0') {
			a[++ans] = i;
			s[i] = '1';
			if (s[i - 1] == '0')
				s[i - 1] = '1';
			else
				s[i - 1] = '0';
		}
	}
	for (int i = 0; i < n / 2; i++) {
		if (s[i] == '1') {
			a[++ans] = i + 1;
			s[i] = '0';
			if (s[i + 1] == '0')
				s[i + 1] = '1';
			else
				s[i + 1] = '0';
		}
	}
	long long o = 0;
	for (int i = 0; i < n; i++)
		if (s[i] == '1')
			o++;
	long long tmp = 0;
	for (int i = 0; i < n; i++) {
		if (s[i] == '0')
			tmp += o;
		else
			o--;
	}
	cout << tmp << endl << ans << endl;
	for (int i = 1; i <= ans; i++)
		cout << a[i] << " ";
}
```
打字不易，请管理大大通过吧！也请各位点个赞！

另外附上[赛事记录](https://www.luogu.com.cn/record/147171177)

---

## 作者：Fujxxx (赞：6)

提供一种贪心思路。

显然左边一半 $0$ 尽量多而右边一半 $1$ 尽量多时顺序对个数取到最大。

用类似冒泡排序的方法将 $0$ 不断左移而 $1$ 不断右移即可。

这样就可以在线性复杂度下解决这个问题。

下面提供参考代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s;
int cnt,len,maxx;
vector<int> sol;
signed main(){
	std::ios::sync_with_stdio(0);
	cin>>s;
	for(register int i=0;i<s.size();i++){
		if(s[i]=='1') cnt++;
	}
	len=s.size();
	for(register int i=0;i<=len/2-1;i++){
		if(s[i]=='1'){
			s[i]='0';
			if(s[i+1]=='0') s[i+1]='1';
			else s[i+1]='0';
			sol.push_back(i);
		}
	}
	for(register int i=len-1;i>len/2;i--){
		if(s[i]=='0'){
			s[i]='1';
			if(s[i-1]=='0') s[i-1]='1';
			else s[i-1]='0';
			sol.push_back(i-1);
		}
	}
	if(len%2==0){
		if(abs(len/2-cnt)%2==0){
			maxx=(len/2)*(len/2);
		}else{
			maxx=(len/2-1)*(len/2+1);
		}
	}else{
		maxx=(len/2)*(len-len/2);
	}
	cout<<maxx<<'\n';
	cout<<sol.size()<<'\n';
	for(register int i=0;i<sol.size();i++) cout<<sol[i]+1<<" ";
	return 0;
}
```


---

## 作者：Register_int (赞：5)

首先，题目中的操作并不会改变 $1$ 个数的奇偶性。但是他们的位置和数量可以任意啊！所以我们最终的目标就是：$1$ 的个数 $m$ 最接近 $n$ 的一半，然后位置是从结尾开始的连续的一大段。这样顺序对个数可以达到最大的 $m(n-m)$。

考虑如何构造。首先可以从前往后贪心，将所有 $1$ 消的只剩 $\le 1$ 个，并将他扔到序列末尾。再从末尾开始隔两个点一个来补足少的 $1$ 即可。操作次数总和显然不超过 $n$，可以通过。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 4e5 + 10;

int n, m; char s[MAXN];

int a[MAXN], cnt;

int main() {
	scanf("%s", s + 1), n = strlen(s + 1);
	for (int i = 1; i <= n; i++) if (s[i] & 1) m++;
	for (int i = 1; i < n; i++) if (s[i] & 1) a[++cnt] = i, s[i + 1] ^= 1;
	int tot = n >> 1; if ((tot ^ m) & 1) tot++;
	for (int i = n - 1 - (m & 1); i >= n - tot + 1; i -= 2) a[++cnt] = i;
	printf("%lld\n%d\n", (ll)tot * (n - tot)), cnt;
	for (int i = 1; i <= cnt; i++) printf("%d ", a[i]);
}
```

---

## 作者：ivyjiao (赞：1)

~~DOTA CPC~~。

我们思考，最终的构造一定是前面一串 $0$，后面一串 $1$，而且要使两者的数量差距尽量小。

我们可以从左往右依次判断每个位置是不是 $0$，直到这个串的一半为止，如果不是就进行一次反转。

我们再从右往左依次判断每个位置是不是 $1$，直到这个串的一半为止，如果不是就进行一次反转。

这样就可以保证最终的构造是前面一串 $0$，后面一串 $1$，而且两者的数量差距尽量小（不超过 $1$）。

至于两次反转结束后中间会不会有浪费，一定不会有，因为第一次我们是从左往右翻的，所以翻完后中间一定会是 $\cdots0001\cdots$，第二次我们是从右往左翻的，所以翻完后中间一定会是 $\cdots0111\cdots$，结合两者，中间不会有浪费。

次数最多为 $|S|-1$ 次，不超过限制。

代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s;
bool p[200001];
int a[200001],l,a1,a2,r;
signed main(){
    cin>>s;
    for(int i=0;i<s.size();i++) p[i]=s[i]-'0';
    for(int i=0;i<=s.size()/2-1;i++) if(p[i]) p[i]=!p[i],p[i+1]=!p[i+1],a[++l]=i+1;
    for(int i=s.size()-1;i>s.size()/2;i--) if(!p[i]) p[i]=!p[i],p[i-1]=!p[i-1],a[++l]=i;
    for(int i=0;i<s.size();i++){
        if(p[i]) break;
        a1++;
    }
    cout<<a1*(s.size()-a1)<<endl;
    cout<<l<<endl;
    for(int i=1;i<=l;i++) cout<<a[i]<<" ";
}
```

---

## 作者：Crsuh2er0 (赞：1)

赛时交了 16 发，全部 WA #2，对拍拍了 $3 \times 10^5$ 组没拍出来。

结果赛后 5 分钟想起来没开 long long。

十年 OI 一场空，不开 long long 见祖宗。

## Solution

考虑如何最大化顺序对数量。

根据基本不等式，显然，当 $s$ 从中间分成两半，左边一半全是 $0$，右边一半全是 $1$ 时顺序对数量最大。

把 $s$ 分成两半贪心直接做即可。

- 对前一半，从前往后遍历，当遇到 $1$ 时，使用取反操作。
- 对后一半，从后往前遍历，当遇到 $0$ 时，使用取反操作。

如此即可把序列分成左 $0$ 右 $1$ 的两半。

需要注意的是，遍历后一半进行取反时，需要将 $s_i$ 和 $s_{i-1}$ 取反，才能符合贪心的性质。

然后手造几组小样例对 Corner Case 进行调整即可。

代码如下：

```cpp
#include <bits/extc++.h>
using namespace std;
typedef long long LL;
string s;
LL ans, cnt, c;
basic_string<int> opt;

void rev(int i) { s[i] = (s[i] == '1' ? '0' : '1'); }

void work() {
    int i, j;
    for (i = 0; i * 2 + 2 < s.length(); i++) {
        if (s[i] == '1') rev(i), rev(i + 1), cnt++, opt += i;
    }
    for (j = s.length() - 1; j - i >= 1; j--) {
        if (s[j] == '0') rev(j), rev(j - 1), cnt++, opt += (j - 1);
    }
}

int main() {
    cin >> s;
    work();
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '0')
            c++;
        else
            ans += c;
    }
    cout << ans << '\n' << cnt << '\n';
    for (int i = 0; i < opt.length(); i++) cout << opt[i] + 1 << ' ';
    return 0;
}
```

---

## 作者：ran_qwq (赞：1)

一眼丁真，鉴定为操作后所有 $0$ 在所有 $1$ 之前。

设 $cnt0$ 为 $0$ 个数，$cnt1$ 为 $1$ 个数。则顺序对个数为 $cnt0\times cnt1$。

考虑操作前后 $d=cnt0-cnt1$ 模 $4$ 的余数。

- 如果操作的是两个 $0$，操作后 $cnt0\leftarrow cnt0+2,cnt1\leftarrow cnt1-2,d\leftarrow d+4$。

- 如果操作的是两个 $1$，操作后 $cnt0\leftarrow cnt0-2,cnt1\leftarrow cnt1+2,d\leftarrow d-4$。

- 如果操作的是一个 $0$ 一个 $1$，操作后 $cnt0,cnt1,d$ 均不变。

综上所述，操作过程中 $d$ 模 $4$ 余数不变。

找一对使得 $x\times y$ 最大，$x-y$ 和初始时 $0$ 个数减去 $1$ 个数模 $4$ 同余的 $x,y$，构造方案。

怎么构造方案？从后往前扫，扫到第 $i$ 位，如果当前第 $i$ 位和目标不一样，就反转，否则不反转。

```cpp
string s;
void QwQ() {
	cin>>s;int n=s.size(),cnt0=0,cnt1=0,x=-1,y=-1;ll mx=0;
	for(int i=0;i<n;i++) cnt0+=s[i]=='0',cnt1+=s[i]=='1';
	for(int _0=0;_0<=n;_0++) {
		int _1=n-_0;
		if((((_1-_0&3)+4)&3)==(((cnt1-cnt0&3)+4)&3)&&1ll*_0*_1>mx) x=_0,y=_1,mx=1ll*_0*_1; 
	}
	wrll(mx,"\n");vi v;
	for(int i=n-1;i>=1;i--)
		if(i>=x) {
			if(s[i]=='0') {
				v.pb(i),s[i-1]^=1,s[i]^=1;
				if(i>x&&s[i-1]=='1') i--;
			}
		} else {
			if(s[i]=='1') {
				v.pb(i),s[i-1]^=1,s[i]^=1;
				if(s[i-1]=='0') i--;
			}
		}
	wr(v.size(),"\n");
	for(int x:v) wr(x," ");
}
```

---

## 作者：zyn_ (赞：0)

# P10168 [DTCPC 2024] 0=1=0

以下令 $n=|S|$。

操作顺序是不重要的。

**操作次数的限制也不重要**。因为对同一个 $i$ 操作两次相当于不操作。所以无论实际操作次数有多少，都相当于每个 $i$ 被操作 $0$ 或 $1$ 次。这样，操作数不超过 $n-1$。

下面分两步构造 $S$。

### Step One

从 $1$ 到 $n-1$ 枚举 $i$。对每个 $i$，如果 $s_i=1$，则将 $s_i$ 与 $s_{i+1}$ 取反。

第 $i$ 次操作后有 $s_i=0$，故第一步结束时，$s_n$ 可能为 $0$ 或 $1$，其余的 $s_i$ 均为 $0$。

### Step Two

取一个 $k$，对 $i=1,2,\dots,k$，对 $n-2i+1-s_i$ 进行操作。也就是说，操作完后 $S$ 的**后 $2k+s_i$ 项均为 $1$，前 $n-2k-s_i$ 项均为 $0$**。

令 $m=2k+s_i$。

可以发现，在第二步后得到的 $S$ 是所有含有 $n-m$ 个 $0$，$m$ 个 $1$ 的 $S$ 中，顺序对最多的一个。这个 $S$ 有 $m(n-m)$ 个顺序对。

于是只需取一个 $k$，使 $m(n-m)$ 最大。这是显然的二次函数极值问题，容易解决。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000009
#define ll long long
char c[N];ll n,op[N],cnt,a,b,mx;
int main(){
	scanf("%s",c+1);
	n=strlen(c+1);
	for(ll i=1;i<=n;++i)c[i]-='0';
	if(n==1){
		printf("0\n0\n");
		return 0;
	}
	for(ll i=1;i<n;++i){
		if(c[i]){
			op[i]^=1;
			c[i]^=1;
			c[i+1]^=1;
		}
	}
	if(c[n]){
		a=1;
		b=n-1;
		mx=a*b;
		for(ll i=n-1;i>=1;i-=2){
			if(a*b>=(a+2)*(b-2))break;
			a+=2,b-=2;mx=a*b;
			op[i-1]^=1;
			c[i]^=1;c[i-1]^=1;
		}
	}else{
		a=0;
		b=n;
		mx=a*b;
		for(ll i=n;i>=1;i-=2){
			if(a*b>=(a+2)*(b-2))break;
			a+=2,b-=2;mx=a*b;
			op[i-1]^=1;
			c[i]^=1;c[i-1]^=1;
		}
	}
	for(ll i=1;i<=n;++i)if(op[i])++cnt;
	printf("%lld\n%lld\n",mx,cnt);
	for(ll i=1;i<=n;++i)if(op[i])printf("%lld ",i);
	return 0;
}
```

---

## 作者：lzkAK2009 (赞：0)

## 分析
很好发现，当 `1` 在 `0` 前面时，肯定可以通过一次变换把 `0` 放在 `1` 前面，使顺序对数量加 $1$。因此，可以做到把字符串变换为一串 `0` 连上一串 `1` ，且这样是最优的，答案为两个字符数量之积。同时，两个字符数量之和一定，差越小，积越大，但每次变换，字符数量之差的变化只可能是 $0$ 或 $4$。因此，我们计算 `0` 和 `1` 之差再对 $4$ 取模作为新的差，重新计算 `0` 和 `1` 的数量。不过 `0` 比 `1` 取模过后多 $3$ 时，`1` 比 `0` 多 $1$ 更好，这时需要把差设为 $-1$。计算好新的数量后，我们从 $1$ 循环到 $n$，每次遇到不符合的就把它和后一个一起取反，可以证明最后得到的和我们预期的一模一样。
## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

char s[200005];

long long num, ans, tmp[200005];

int main () {
	scanf ("%s", s + 1);
	int len = strlen (s + 1);
	for (int i = 1; i <= len; i++)
		if (s[i] == '1')
			num++; //统计1的数量
	long long cnt = ((len - num * 2) % 4 + 4) % 4; //计算新的差
	if (cnt == 3)
		cnt = -1; //将3改为-1
	num = (len + cnt) / 2; //计算0的最终数量
	cout << num * (len - num) << "\n"; //输出顺序对数量
	for (int i = 1; i <= num; i++) //将前num个都改为0
		if (s[i] == '1') {
			tmp[++ans] = i; //记录步骤
			s[i + 1] = '1' - s[i + 1] + '0';
		}
	for (int i = num + 1; i <= len; i++) //将其余的都改为1
		if (s[i] == '0') {
			tmp[++ans] = i; //记录步骤
			s[i + 1] = '1' - s[i + 1] + '0';
		}
	cout << ans << "\n";
	if (ans) 
		for (int i = 1; i <= ans; i++)
			printf ("%d ", tmp[i]); //输出步骤
	return 0;
}
``````

---

## 作者：I_will_AKIOI (赞：0)

首先我们先考虑第一小问：最大化顺序对的个数。

最好的情况肯定是 $1$ 都放在后面，$0$ 都放在前面。这样顺序对个数就是他们个数之积。根据小学知识，两个数和相同，越接近，积越大，所以我们希望 $1$ 和 $0$ 各占一半。

但是，我们看看样例，你会发现最好情况是 $\texttt{001111}$ 或 $\texttt{000011}$。因为 $1$ 和 $0$ 个数的奇偶性是不变的。若你翻转了两个相同的数，一个 $-2$，另一个 $+2$。若翻转不同的数，个数不变。

所以，我们得根据 $1$ 和 $0$ 的个数来构造一个顺序对个数最大的字符串。最后把原串照着他进行修改即可。

注意开 ```long long```。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s;
int n,x,cnt,ans,u,w,a[200005],f[200005];
vector<int>v;
signed main()
{
  ios::sync_with_stdio(0);
  cin>>s;
  n=s.size();
  for(int i=0;i<n;i++) cnt+=(s[i]=='1'),a[i]=(s[i]=='1');
  if(n%2==0)
  {
    if(n/2%2==cnt%2) x=0;
    else x=1;
  }
  else
  {
    if(n/2%2==cnt%2) x=1;
    else x=0;
  }//计算得出与0的数量与标准相差多少
  for(int i=0;i<n;i++)
  {
    if(i<n/2+x) f[i]=0,u++;
    else f[i]=1,w++;
  }//构造标准字符串
  for(int i=n-2;i>=0;i--)
  {
    if(a[i+1]!=f[i+1])//不相等进行修改
    {
      v.push_back(i+1);
      a[i]=1-a[i];
      a[i+1]=1-a[i+1];
    }
  }
  cout<<u*w<<"\n"<<v.size()<<"\n";
  for(int i=0;i<v.size();i++) cout<<v[i]<<" ";
  return 0;
}
```

---

## 作者：yszkddzyh (赞：0)

~~一个不那么正经的做法。~~

题目要求顺序对最多，就是尽量让 $0$ 都在 $1$ 的前面。记 $0$ 的个数为 $c_0$、$1$ 的个数为 $c_1$，那么由乘法原理，此时顺序对的个数为 $c_0\times c_1$。小学奥数告诉我们：两数和一定时，两数差越小，积越大。而 $c_0+c_1$ 就是字符串的长度，是固定的，所以我们要使 $c_0$ 与 $c_1$ 尽可能接近，此时顺序对的数量最多。

手算很多例子，我们发现，这些字符串都能使所有 $0$ 在所有 $1$ 的前面，所以我们可以猜测所有字符串都可以这样（如果你不放心可以尝试证明一下）。另外，我们发现，无论怎样操作，$c_0$ 和 $c_1$ 的奇偶性永远不变（证明也比较简单）。这样，字符串的目标状态就确定了！我们即是要保证 $c_0,c_1$ 奇偶性不变的情况下使它们的差最小。这时可以分类讨论，然后输出的第一行就完成了，具体见代码。

那我们如何输出操作方法呢？我们首先确定目标状态中第一个 $1$ 的位置为 $i$，在实现上一段所说的之后，这就比较的简单。然后我们从后往前，从末尾枚举到 $i$，因为目标状态中，这一个区间全是 $1$，所以我们如果在 $j$ 处遇到 $0$，就将 $j$ 和 $j-1$ 取反，同时记录答案。接着，我们从 $i-1$ 枚举到 $1$（其实枚举到 $2$ 就行了，第 $1$ 个数字一定会变成 $0$），同理，我们如果在 $j$ 处遇到 $1$，就将 $j$ 和 $j-1$ 取反，然后就能完成操作。由于篇幅限制，大家可以自行尝试证明操作的正确性（~~我才不会告诉你我不会证明~~）。显然这样的操作次数不超过 $2\times10^5$。

代码如下（~~又臭又长~~）：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 2e5 + 5;
string s;
int c0, c1, tot, p[N], a[N];

int main(){
	
	ios :: sync_with_stdio(false);
	cin >> s;
	ll len = s.size();
	for(int i = 0; i < len; i++){
		a[i + 1] = s[i] - '0';
		if(s[i] == '0') c0++;
		else c1++;
	}
	if(len % 2){//长度为奇数，此时目标状态类似 00111、00011 等 
		cout << (len / 2 + 1) * (len / 2) << endl;//答案可以自行推理得出（根据乘法原理） 
		//以下至于为什么要分两种情况，是因为两种情况下第一个1的位置与len的关系不同 
		if(c0 % 2){//类似00011的情况 
			//以下要分两种情况的原因同上 
			if((len + 1) % 4 == 0){//类似0001111的情况 
				for(int i = len; i >= len / 2 + 1; i--){//可以发现此时第一个1的位置是len/2+1 
					if(a[i]) continue;//对1不做处理 
					p[++tot] = i - 1;//记录答案 
					a[i] ^= 1, a[i - 1] ^= 1;//异或1就是0变1、1变0 
				}
				for(int i = len / 2; i > 1; i--){//大于号也可以是大于等于 
					if(!a[i]) continue;//对0不做处理 
					p[++tot] = i - 1;//记录 
					a[i] ^= 1, a[i - 1] ^= 1;//同上 
				}
			}
			else{//类似00011的情况 
				//后面的for循环代码只有第一个1的位置不同 
				for(int i = len; i >= len / 2 + 2; i--){//第一个1在len/2+2处（这些式子都是找规律找出的） 
					if(a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
				for(int i = len / 2 + 1; i > 1; i--){
					if(!a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
			}
		}
		else{//类似00111的情况 
			//这种情况与上面的if(c0 % 2)内的语句类似 
			if((len + 1) % 4 == 0){
				for(int i = len; i >= len / 2 + 2; i--){//第一个1在len/2+2处 
					if(a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
				for(int i = len / 2 + 1; i > 1; i--){
					if(!a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
			}
			else{
				for(int i = len; i >= len / 2 + 1; i--){//第一个1在len/2+1处 
					if(a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
				for(int i = len / 2; i > 1; i--){
					if(!a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
			}
		}
	}
	else{//长度为偶数，此时目标状态类似于 000111、001111 等 
		if(c0 % 2 == len / 2 % 2){//类似于000111、00001111，即0和1的个数可以一样 
			cout << len * len / 4 << endl;//答案同样可以自行推出 
			for(int i = len; i >= len / 2 + 1; i--){//与上面的for循环几乎无异 
					if(a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
				for(int i = len / 2; i > 1; i--){
					if(!a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
		}
		else{//类似于001111等，即目标状态中0和1的个数不一样 
			cout << len * len / 4 - 1 << endl;//自行推出 
			for(int i = len; i >= len / 2; i--){
					if(a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
				for(int i = len / 2 - 1; i > 1; i--){
					if(!a[i]) continue;
					p[++tot] = i - 1;
					a[i] ^= 1, a[i - 1] ^= 1;
				}
		}
	}
	cout << tot << endl;//输出答案 
	for(int i = 1; i <= tot; i++)
		cout << p[i] << ' ';
	
	return 0;
}
```

~~比赛时正在上课，极域让我写不了题，结果比赛结束了（悲）。~~

---

## 作者：DerrickLo (赞：0)

设最终的操作序列是 $a_1,a_2,\ldots,a_n$，那么我们考虑对于 $i\in [2,n]$，如果 $a_i=a_{i-1}+1$，那么 $s_{a_i}$ 就会被操作两次，也就是不变，然后我们就能发现，操作完的字符串 $s'$ 中，满足 $s'_i\neq s_i$ 的 $i$ 必然有偶数个。

那么我们可以枚举断点 $i$，看看能否使得 $[1,i]$ 全是 $0$，$(i,n]$ 全是 $1$，答案就是所有可行的 $i$ 中 $i\times (n-i)$ 的最大值。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,sum0[200005],sum1[200005],ans,a[200005],cnt;
string s;
signed main(){
	cin>>s,n=s.size(),s=" "+s;
	for(int i=1;i<=n;i++)sum0[i]=sum0[i-1]+(s[i]=='0'),sum1[i]=sum1[i-1]+(s[i]=='1');
	for(int i=1;i<=n;i++){
		int aa=sum1[i]+(sum0[n]-sum0[i]);
		if(aa%2==0)ans=max(ans,i*(n-i));
	}
	cout<<ans<<"\n";
	for(int i=1;i<=n;i++){
		int aa=sum1[i]+(sum0[n]-sum0[i]);
		if(aa%2==0&&ans==i*(n-i)){
			for(int j=1;j<=i;j++)if(s[j]=='1')a[++cnt]=j;
			for(int j=i+1;j<=n;j++)if(s[j]=='0')a[++cnt]=j;
			int sum=0;
			for(int j=1;j<=cnt;j+=2)sum+=a[j+1]-a[j];
			cout<<sum<<"\n";
			for(int j=1;j<=cnt;j+=2){
				for(int k=a[j];k<a[j+1];k++)cout<<k<<' ';
			}
			return 0;
		}
	}
}
```

---

## 作者：Night_sea_64 (赞：0)

这题很水，感觉不该是绿题啊。

把相邻两个取反，取反完了之后异或和不变。所以取反完了之后新序列和原序列的异或和应该相同。

所以显然可以取反完了使前面一些值是 $0$，后面一些值是 $1$。这时设有 $k$ 个 $1$，顺序对个数是 $k(n-k)$。

那么 $k$ 应接近于 $\frac n2$。如果原序列异或和为 $1$，那么 $k$ 应是奇数。否则应是偶数。

构造方案就随便来了，如果当前这位应该取反就将它和下一个都取反。

```cpp
#include<iostream>
using namespace std;
int a[200010];
int main()
{
    string s;
    cin>>s;
    int n=s.size();
    s=' '+s;
    int sum=0;
    for(int i=1;i<=n;i++)
        if(s[i]=='1')sum^=1;
    int k=n/2;
    if(sum)
    {
        if(k%2==0)k++;
        for(int i=1;i<=n;i++)
            if(i>=n-k+1)a[i]=1;
    }
    else
    {
        if(k%2)k++;
        for(int i=1;i<=n;i++)
            if(i>=n-k+1)a[i]=1;
    }
    cout<<1ll*k*(n-k)<<endl;
    string t=s;
    int cnt=0,flag=0;
    for(int i=1;i<n;i++)
        if(t[i]-'0'!=a[i])
            cnt++,t[i+1]^=1;
    cout<<cnt<<endl;
    for(int i=1;i<n;i++)
        if(s[i]-'0'!=a[i])
        {
            cout<<i<<" ";
            s[i+1]^=1;
        }
    return 0;
}
```

---


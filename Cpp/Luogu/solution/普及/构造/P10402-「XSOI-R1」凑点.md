# 「XSOI-R1」凑点

## 题目描述

小 T 会给你一个长度为 $n$ 的整数数列，你手上有一个数 $x$，初始为 $0$，你可以执行以下操作，使得最终 $x$ 与 $c$ 的差小于 $10^{-4}$。

你可以对 $x$ 进行至多 $k$ 次操作：

- `add i`，对计数器 $x$ 加上 $a_i$，然后 $a_i$ 不能再进行任何操作。

- `sub i`，对计数器 $x$ 减上 $a_i$，然后 $a_i$ 不能再进行任何操作。

- `mul i`，对计数器 $x$ 乘上 $a_i$，然后 $a_i$ 不能再进行任何操作。

- `sqrt i`，将 $a_i$ 赋值为 $\sqrt {a_i}$，每个 $a_i$ 只能开方一次。

- `pow f`，将计数器 $x$ 变为 $x^f$，$f$ 可以为浮点数。

所有 $a_i$ 都必须给 $x$ 进行一次加或减或乘操作。

在运算过程中，$a_i$ 和 $x$ 的值均不能超过 $10^{10}$。题目保证有解，如有多种方案，输出一种即可。

本题精度要求较大，请提高算法的精度。

## 说明/提示

**【样例解释 #1】**

- $x$ 加上 $a_1$，此时 $x$ 为 $3$。

- $x$ 加上 $a_2$，此时 $x$ 为 $6$。

- $x$ 减去 $a_3$，此时 $x$ 为 $3$。

- $x$ 减去 $a_4$，此时 $x$ 为 $0$。

- $x$ 加上 $a_5$，此时 $x$ 为 $3$。

**【样例解释 #2】**

- 将 $a_2$ 开根号，此时 $a=[1,\sqrt3,3]$。

- 将 $a_3$ 开根号，此时 $a=[1,\sqrt3,\sqrt3]$。

- $x$ 加上 $a_1$，此时 $x$ 为 $1$。

- $x$ 乘上 $a_2$，此时 $x$ 为 $\sqrt3$。

- $x$ 乘上 $a_3$，此时 $x$ 为 $3$。

**【样例解释 #3】**

- $x$ 加上 $a_1$，此时 $x$ 为 $4$。

- $x$ 加上 $a_2$，此时 $x$ 为 $9$。

- 将 $x$ 变为 $x^2$，此时 $x$ 为 $81$。

- 将 $x$ 减去 $a_3$，此时 $x$ 为 $77$。

### 数据规模与约定


**本题采用捆绑测试。**

- subtask 0（10 pts）：$n\leq 5$，$k=n^2$，保证可以使用加与减的运算得到解。

- subtask 1（20 pts）：$n \leq 5$，$k=n^2$，保证可以可以使用加、减、乘、开方运算得到解。

- subtask 2（15 pts）：$n \leq 10$，$a_i \leq 2$，$k=n+1$。

- subtask 3（55 pts）：$k=n+1$。

对于所有数据：$0 \leq n \leq 10^{5}$，$\sum_{i=1}^{n}{a_i} \le 10^{10}$，$0 \leq c\leq 10^{10}$。

## 样例 #1

### 输入

```
5 25 3
3 3 3 3 3```

### 输出

```
5
add 1
add 2
sub 3
sub 4
add 5
```

## 样例 #2

### 输入

```
3 9 3
1 3 3```

### 输出

```
5
sqrt 2
sqrt 3
add 1
mul 2
mul 3
```

## 样例 #3

### 输入

```
3 9 77
4 5 4```

### 输出

```
4
add 1
add 2
pow 2
sub 3```

# 题解

## 作者：Brain_Huger (赞：5)

写一篇不用二分的题解。

## 思路

首先我们发现，题目中可以这么修改：

`pow f`，将计数器 $x$ 变为 $x^f$，$f$ 可以为**浮点数**。

我们可以观察下幂函数 $y=2^x$ 的图像：

![](https://s21.ax1x.com/2024/05/05/pkA5H2j.md.png)

在 $x \ge 0$ 时，值域为 $[1,\infty)$。也就是说，我们可以直接执行一次 `pow` 操作，使其变成任何大于等于 $1$ 的数。接着发现 $\sum_{i=1}^n a_i\le10^{10}$。我们可以直接花 $n$ 次操作把 $x$ 变为 $\sum_{i=1}^n a_i$。

接着就是这个式子：

$$x^p=c\\p=\log_xc$$

根据换底公式用 c++ 自带的 $\log$ 函数即可，操作次数 $n+1$。

注意 $c$ 可能为 $0$，当 $c=0$ 时方法就不多说了，操作次数 $n$。

## 代码
```
#include<bits/stdc++.h>
#define int long long
int n,x,y,X;
signed main(){
	scanf("%lld%lld%lld",&n,&x,&y),x=0;
	if(y==0){
	    printf("%lld\n",n);
	    for(int i=1;i<=n;i++)scanf("%lld",&X),printf("mul %lld\n",i);
	    return 0;
	}
	printf("%lld\n",n+1);
	for(int i=1;i<=n;i++)scanf("%lld",&X),x+=X,printf("add %lld\n",i);
	long double ans=log10(y)*1.0000/log10(x),s=pow(x,ans);//此处用 log,log2都行
	if(fabs(s-y)>1e-4)while(printf("sto wmr orz"));
	printf("pow %.114510Lf",ans);
	return 0;
}
```

---

## 作者：nannangua (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P10402)
## 大致思路
第一眼看题目感觉很难，但发现题目中的加、减、乘操作，而开方和幂操作会有精度问题，所以我们尽可能少使用。这样再看题目只用 `add i` 与 `pow f` 两个函数写，就不会这么难了。

思路大概就是先 `add i` 将 $x$ 变为一个正数,再用 `pow f` 操作次方回去将 $x$ 最大限度的变回靠近 $c$ 的浮点数 (可以使用二分也可以用换底公式)。

## 代码实现
思路详见代码:
```cpp 
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,c,a;
long double x,ans;
void tepan() //这里有个特判
{
	cout<<n<<endl;
	for(int i=1;i<=n;++i)
	{
		cout<<"mul "<<i<<endl;
	}
	return;
} 
signed main()
{
	// 思路 ：加完之后次方回去 
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k>>c;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		x+=a;
	}
	if(c==0)  
	{   
		tepan();
		return 0; 
	}
	cout<<n+1<<endl; // 加一是因为预留一次次方回去 
	for(int i=1;i<=n;i++) 
	{
		cout<<"add "<<i<<endl;
	}
	ans=(1.0*logl(c)) / (logl(x)); // 换底公式  
	printf("pow %.20Lf",ans);
	return 0;
}
```
## 注意事项
* 二分可以替换成换底公式。
* 题目要求精度较高,需要开 `long double`

---

## 作者：Xssion37_XY (赞：2)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/P10402)

[更好的阅读体验](https://www.luogu.com.cn/article/cqc5bmzw)

### 题目大意

给你 $5$ 种操作和一个长度为 $n$ 的数列，使 $x$ 与给定的 $c$ 的差尽可能的小（当然数列中的每一个值都只能且必须进行 $1$ 次操作）。

### 实际分析

既然要使 $x$ 与给定的 $c$ 的差尽可能的小，那么我们就要选择**相对可控**的操作来改变 $x$ 的值。

什么是**相对可控**的操作？

就是题目中的加、减、乘操作，而开方和幂操作会有精度问题，所以我们尽可能少使用。

观察题目，发现 $c$ 的值可以有两种情况，即 $c=0$ 和 $c\neq0$。

- 当 $c=0$ 时：

因为 $x$ 初始为 $0$，要想进行操作过后还是 $0$，很容易想到让 $x$ 乘上所有的 $a_i$，最后的结果依然是 $0$，操作次数为 $n$ 次。

- 当 $c\neq0$ 时：

~~这个的精度差点坑死我。~~

我们可以让 $x$ 加上所有的 $a_i$，最后的结果是 $\sum_{i=1}^{n}a_i$。

然后我们使用换底公式（不了解的可以[看看这](https://zhuanlan.zhihu.com/p/357159782)），令 $e=\sum_{i=1}^{n}a_i$，我们想让 $e$ 变为 $c$，可以将式子转化为 $e^{\log_ec}$，操作次数为 $n+1$ 次。

此时我们不得不使用不可靠的幂操作了，但是要注意精度！

### 代码部分

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#define int long long
#define double long double
using namespace std;
const int MAXX = 1e6 + 11;
int a[MAXX];
double sum;
double logg(double a,double b) { // 换底
	return 1.0 * log(b) / log(a);
}
signed main() {
	int n,k;
	double c;
	cin >> n >> k >> c;
	for (int i = 1; i <= n; i ++) {
		cin >> a[i];
	}
	if (c == 0) { // c == 0
		cout << n << endl;
		for (int i = 1; i <= n; i ++) {
			cout << "mul " << i << endl;
		}
		return 0;
	} else { // c != 0
		cout << n + 1 << endl;
		for (int i = 1; i <= n; i ++) {
			sum += a[i];
			cout << "add " << i << endl;
		}
		printf("pow %.233Lf",logg(sum,c)); // 注意精度
	}
	return 0;
}
```

完结撒花！

---

## 作者：LostKeyToReach (赞：2)

一道坑题。

我们分类讨论 $c$ 的取值：

- 当 $c=0$ 时，我们可以把所有 $a_i$ 都乘一遍，此时 $x$ 为 $0$，满足要求。操作次数为 $n$。

- 否则，我们把所有 $a_i$ 都加一遍，然后再进行一次 `pow` 操作，设 $t=\sum_{i=1}^n a_i$，$f$ 即为 $\log_t c$。此时操作次数为 $n+1$。求对数用换底公式即可，可以将式子转换为 $\frac{\ln c}{\ln t}$。

代码如下：
```cpp
ll n, k;
long double c;
long double a[100006];
long double log(long double a, long double b) {
	return 1.0 * logl(b) / logl(a);
}
int main() {
	read(n), read(k);
	cin >> c;
	if (c == 0) {
		writeln(n);
		rep(i, 1, n, 1) {
			cout << "mul " << i << endl;
		}
		return 0;
	}
	rep(i, 1, n, 1) {
		cin >> a[i];
	}
	cout << n + 1 << endl;
	long double res = 0.0;
	rep(i, 1, n, 1) {
		cout << "add " << i << endl;
		res += a[i];
	}
	cout << "pow ";
	printf("%.20Lf", log(res, c));
}
```

---

## 作者：Infinite_Loop (赞：1)

# P10402
## 题意
给定一个长度为 $n$ 的数列，你可以对 $x$ 进行若干次操作，并且操作次数要小于等于 $k$，使得 $x$ 与 $c$ 的差小于 $10^{-4}$，输出操作次数与每个操作。
## 思路
本题考虑找规律。

我们发现，最后一个操作：将 $x$ 变为 $x^{f}$，$f$ 可以为浮点数。这个操作可以使得 $x$ 变成任何数。

所以我们可以先将 $x$ 变成 $\sum_{i=1}^{n}a_{i}$，然后使用一次 ```pow``` 操作，就是以下这个式子：

$$x^f=c$$
$$f=\log_xc$$

最后还要考虑 $c=0$ 时的情况，由于 $x$ 一开始就是 $0$，所以不需要操作。

注意精度要高一些。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
int n,k,c,a[N],x;
signed main(){
	cin>>n>>k>>c;
	for(int i=1;i<=n;i++)cin>>a[i];
	if(c==0){
		cout<<0;
	}else{
		cout<<n+1<<'\n';
		for(int i=1;i<=n;i++){
			x+=a[i];
			cout<<"add "<<i<<'\n';
		}
		long double f=1.0*log(c)/log(x);
		printf("pow %.114514Lf",f);
	}
	return 0;
}
```

---

## 作者：fangminding (赞：1)

第一眼看题感觉很奇怪，毫无思路。但是立即发现操作 $5$ 是一个很好的操作，可以将一个正数转为任意目标正数。

由此即可得出此题解法：当 c 等于 $0$ 时，不用操作即可。

否则，将所有数加起来得到一个正整数，再由操作 $5$ 即可得出目标正整数。

注意点：此题精度要求极高，可以通过手写二分实现，精度达小数点后 $15$ 位左右比较好，既不会有精度误差，也不会超时。

AC 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,k,c;
int A[100005];
long double lg(int d,int x)
{
	long double let=-1e4,rit=1e4,mid,x2=x;
	while(rit-let>1e-15)
	{
		mid=(let+rit)/2;
		if(pow<long double>(d,mid)>x2)rit=mid;
		else let=mid;
	}
	return let;
}

signed main()
{
	cin>>n>>k>>c;
	if(c==0)
	{
		cout<<0;
		return 0;
	}
	int steps = 0;
	for(int i = 1; i <=n; i++)cin>>A[i];
	cout<<n+1<<endl;
	int x = 0;
	for(int i = 1; i <=n; i++)
	{
		x+=A[i];
		cout<<"add "<<i<<endl;
	}
	printf("pow %.45Lf",lg(x,c));
	return 0;
}
```

---

## 作者：Zhl2010 (赞：1)

比赛后，发现这题~~太坑太坑了~~ 。

样例和思路根本不沾边。

## 题目概括
执行一些操作，使一个数变成另一个数。
## 思路
先将数的和算出来（因为每一个数都要用），减掉之后，最后能用 `pow` 的用 `pow` 求。

~~的确，思路简单，但根本想不到，一开始以为是bfs~~。

解释：因为 `pow` 的幂你可以自己选（可以是小数，小数的结果就很多了），所以 `pow` 无所不能。 

所以这题就是看数据能不能用 `pow`，分类讨论。

具体看代码注释。

**细节**：开 `long double`，不然容易炸。
## 代码+注释
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
ld a[100010];
int main() {
	int n,k;
	ld c;
	cin>>n>>k>>c;
	ld sum=0;
	for(int i=1; i<=n; i++){
		cin>>a[i];
		sum+=a[i];
	}
	if(c==0) {//c=0,x怎么乘都是0，所以可以是全部乘法 
		cout<<n<<"\n";
		for(int i=1; i<=n; i++){
			cout<<"mul "<<i<<"\n";
		}
		return 0;
	}
	if(c==1&&sum==1) {//取巧一下，全部减法，因为1-1=0 
		cout<<n<<"\n";
		for(int i=1; i<=n; i++){
			cout<<"add "<<i<<"\n";
		}
		return 0;
	}
	//后面的不能取巧 ，但因为sum^f不管怎样，都可以等于c ，我们只需要求f 
	cout<<n+1<<endl;
	for(int i=1;i<=n;i++){
		cout<<"add "<<i<<"\n";
	}
	ld l=0,r=1;
	ld y=sum;
	while(sum<=c) r++,sum*=y;//求出f右边界 
	sum=y;
	r++;
	while(r-l>1e-16) {//二分 
		ld mid=(l+r)/2;
		if(pow(sum,mid)<c) l=mid;
		else r=mid;
	}
	printf("pow %.30Lf\n",l);
}
```

---

## 作者：xuan_never (赞：1)

老师挑选的测试题。

## 思路
通过 `pow` 操作，可以由非一正整数得到**大多数**非零数，用换底公式算出。  
而非一正整数可以由全部 $a_i$ 加起来保证。

如果 $c=0$ 呢？因为计数器里原本也是 $0$，所以通过全部相乘就可以达到。

因为 $k\le n+1$，所以上述思路可行。

## 代码
本题精度要求确实高。

~~我竟然因为忘记输出 g wa了~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, k;
ll c, x, t;
int main() {
//	ios::sync_with_stdio(false);
//	cin.tie(nullptr), cout.tie(nullptr);
	scanf("%d%d%lld", &n, &k, &c);
	if (!c) {
		printf("%d\n", n);
		for (int i = 1; i <= n; ++i)
			printf("mul %d\n", i);
		return 0;
	} printf("%d\n", n + 1);
	for (int i = 1; i <= n; ++i)
		scanf("%lld", &t), x += t, printf("add %d\n", i);
	long double ans = log(c);
	ans /= log(x);
	printf("pow %.16Lf", ans);
	return 0;
}
```

---

## 作者：LOSpace (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P10402)

## 解题思路
比较诈骗的题目。

容易发现，突破点在于 `pow` 操作：因为指数可以是浮点数，所以任何正数都可以通过它变成其他正数。那么，对于 $c>0$ 的情况，只要用计数器 $x$ 算出 $\sum_{i=1}^{n}a_i$，再求出 $\log_x c$ 即可，可通过 [换底公式](https://baike.baidu.com/item/%E6%8D%A2%E5%BA%95%E5%85%AC%E5%BC%8F/6731201) 或者二分来计算，建议使用前者。

但是 $c$ 可以为 $0$。考虑到 $x$ 初值为 $0$，所以直接乘上所有数即可。

**注意**：本题精度要求高，要开 `long double`，并输出小数点后至少 $15$ 位。

## 代码实现
```cpp
// By Oier moonspace
#include <bits/stdc++.h>

namespace moonspace {

using ll = long long;
using ldb = long double;

const int maxn = 1e5 + 5;
ldb a[maxn];

signed main() {
    int n; ll k; ldb c, x = 0.0; scanf("%d%lld%Lf", &n, &k, &c);
    if (c == 0.0) {
        printf("%d\n", n);
        for (int i = 1; i <= n; i++) printf("mul %d\n", i);
    } else {
        printf("%d\n", n + 1);
        for (int i = 1; i <= n; i++) scanf("%Lf", &a[i]), printf("add %d\n", i), x += a[i];
        printf("pow %.20Lf\n", (ldb)std::log10(c) / std::log10(x));
    }
    return 0;
}

}

signed main() {
    return moonspace::main();
}
```

---

## 作者：DFM_O (赞：1)

## [P10402 题目](https://www.luogu.com.cn/problem/P10402)

### 解题思路
其实这道题中除了最后一种操作，其他都是混淆视听的。

因为这道题要求所有 $a_i$ 都必须给 $x$ 进行一次加或减或乘操作,所以我们可以给 $x$ 进行 $n$ 次加操作，对于第 $i$ 次操作，给 $x$ 加上 $a_i$。

然后我们发现最后一种操作中的 $f$ 是不受序列 $a$ 的限制的，所以我们只要找到一个合适的 $f$ 使得 $x^f$ 与 $c$ 的差小于 $10^{-4}$ 即可。

至于如何找到一个合适的 $f$，可以直接二分，最后再注意一下精度即可，代码很好写，所以就不贴了。

---

## 作者：Shadow_T (赞：1)

### 题目分析

我们可以先加上所有 $a_i$，设和为 $sum$，然后我们知道 $\operatorname{pow}$ 函数是可以为小数的，我们只要找到满足 $sum^f=c$ 的 $f$ 就可以了。$f$ 是满足单调性的，直接二分即可，注意精度问题。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ld long double
const int maxn=1e5+10;
ld a[maxn];
int main()
{
	int n,k;
	cin>>n>>k;
	ld c;
	cin>>c;
	ld sum=0;
	for(int i=1;i<=n;i++)
	cin>>a[i],sum+=a[i];
	if(c==0)
	{
		cout<<n<<"\n";
		for(int i=1;i<=n;i++)
		cout<<"mul "<<i<<"\n";
		return 0;
	}
	if(c==1&&sum==1) 
	{
		cout<<n<<"\n"; 
		for(int i=1;i<=n;i++)
		cout<<"add "<<i<<"\n";
		return 0;
	}
	cout<<n+1<<"\n";
	for(int i=1;i<=n;i++)
	cout<<"add "<<i<<"\n";
	ld l=0,r=1;//sum^f=c
	ld y=sum;
	while(sum<=c) r++,sum*=y;
	sum=y;
	r++;
	while(r-l>1e-16)
	{
		ld mid=(l+r)/2;
		if(pow(sum,mid)<c) l=mid;
		else r=mid;
	}
	printf("pow %.30Lf\n",l);
}
```

---

## 作者：_Hzx_ (赞：0)

没打比赛，赛后看了题，感觉就是精度很坑。

---------

【**解法**】 

注意到题面的最后几句提到本题要尤为注意精度误差，我们应该立即反应开方以及幂操作不能过多使用，最好使用加，减，乘来完成操作。

然后对于这一道题目，不难想到让 $x$ 的值与 $c$ 相等显然是最好的。于是我们对于 $c$ 可以进行简单的分讨，观察数据范围，对于 $c$ 只有两种可能： 

- $c = 0$ 的情况，对于这个情况，我们想起小学的一个结论，任意个数个数与 $0$ 相乘，结果都得 $0$，那我们直接让 $c$ 乘上每个 $a_i$ 就行了，那么也就是 $c \times \prod _ {i = 1} ^ {n} a_i$，显然得 $0$。

- $c$ 为正数的情况（$c > 0$），也是偏数学，还是要强调精度问题，设 $sum = \sum _ {i = 1} ^ {n} a_i$，令 $x$ 加上 $sum$。现在要使 $sum$ 接近 $x$，运用换底公式（不懂 bdfs）转换式子并计算即可。  

记得开 ```long double```。

-----------

[AC Record](https://www.luogu.com.cn/record/166279944) 

【**代码**】 

代码过于简单，就不放了。

---

## 作者：Archy_ (赞：0)

## 题目大意
[传送门](https://www.luogu.com.cn/problem/P10402)

一个长度为 $n$ 的整数数列，你手上有一个数 $x = 0$，执行五种运算操作，使得最终 $x$ 与 $c$ 的差小于 $10^{-4}$。

## 题目思路

首先看到 `pow f`，将计数器 $x$ 变为 $x^f$，$f$ **可以为浮点数**。我们很容易想到把 $x$ 加上数列中所有的数字，然后进行一次 $\text{pow}$ 运算，一共是 $n + 1$ 次运算，正好是 $k$ 的最大值。

则第 $n+1$ 次运算有 $x^f=c$，$f=log_{x}{c}$。cmath 库中有 $\log$ 运算的函数， 但默认是以 $e$ 为底数的。所以我们要用到换底公式。
$$\frac{\log_{x}{a}}{\log_{x}{b}}=\log_{b}{a}$$
题目中，
$$f=\frac{\ln{c}}{\ln{x}}$$

但考虑到真数是要大于 $0$，而题目中 $c$ 有等于 $0$ 的情况。$x$ 的初始值为 $0$，所以这时候直接把数列中的数相乘，输出即可。

## CODE
```cpp
#include <iostream>
#include <cmath>
using namespace std;
long long n, k, c; 
double x;
int main() {
	scanf("%lld %lld %lld", &n, &k, &c);
	if(c == 0) {
		printf("%lld\n", n);
		for(int i=1; i<=n; i++) 
			printf("mul %d\n", i);
		return 0;
	}
	printf("%d\n", n+1);
	for(int i=1; i<=n; i++) {
		int tmp; scanf("%d", &tmp);
		x += tmp;
		printf("add %d\n", i);
	}
	printf("pow %.50lf\n", log(c*1.0)/log(x));
	return 0;
        //这里输出位数要多，否则精度不够。
        //log替换为log2，log10均可。
}
```

---

## 作者：编程小贝壳 (赞：0)

其实不需要写二分。

刚读完题目可能没什么思路，但是定睛一看发现乘方操作的幂次可以是小数，那就好办了：对于任意一个数 $n$，$n^{\log_{n}{m} } = m$，也就是说任意一个数都能通过乘方操作转变成另外一个任意的数。

又因为题目要求所有数都要进行一次加或减或乘操作，因此在开始时先将所有数相加记为 $s$，再将 $s$ 变为 $s^{\log_{s}{c} }$ 即可。$\log_{s}{c}$ 的值用换底公式转化为 $\frac{\lg_{c}}{\lg_{s}}$ 即可。

~~最后记得开高精度，不开高精度只有30 pts。~~

 
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,c,a;
long double x,ans;
signed main(){
	scanf("%lld%lld%lld",&n,&k,&c);
	for(int i=1;i<=n;++i){
		cin>>a;
		x += a;
	}
	if(c == 0){
		printf("%lld\n",n);
		for(int i=1;i<=n;++i) printf("mul %lld\n",i);
		return 0;
	}
	printf("%lld\n",n+1);
	for(int i=1;i<=n;++i) printf("add %lld\n",i);
	ans = 1.0*logl(c)/logl(x);
	printf("pow %.20Lf",ans);
	return 0;
}
```

---

## 作者：_xdd_ (赞：0)

可以把 $a_i$ 都加上，设和为 $s$，然后进行一次 `pow` 操作，使 $s^f=c$，即 $f=\log_sc$。

记得特判 $c=0$ 的情况：只需把 $a_i$ 都乘上（因为 $x$ 初始化是 $0$，且 $0$ 乘任何数都得 $0$）。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,c,sum;
signed main(){
    cin >> n >> k >> c;
    if(!c){
        cout << n << '\n';
        for(int i=1;i<=n;i++){
            cout << "mul " << i << '\n';
        }
        return 0;
    }
    cout << n+1 << '\n';
    for(int i=1;i<=n;i++){
        int x;
        cin >> x;
        sum+=x;
        cout << "add " << i << '\n';
    }
    long double ans=1.0*log(c)/log(sum);//换底公式
    printf("pow %.30Lf",ans);
    return 0;
}
```

---


# 纯白之箭

## 题目背景

搭建，纯白之箭！

## 题目描述

给定长度为 $n$ 的正整数序列 $a$，构造一个长度为 $n+1$ 的字符串序列 $S$，使得对于每个 $1\le i\le n$ 都有 $\operatorname{border}(S_iS_{i+1})=a_i$。

定义：
- 对于两个字符串 $S_1,S_2$，$S_1S_2$ 是它们的拼接。
- 对于一个长度为 $l$ 的字符串 $S$，$\operatorname{border}(S)$ 是最大的正整数 $k<l$ 使得对于每个 $1\le i\le k$ 有 $S_i=S_{l-k+i}$，也即 $S$ 的最长 border 的长度。

由于某些原因，你构造的字符串序列需要满足：
- 每个字符串都是非空的且只包含小写字母。
- 所有字符串的长度之和不超过 $2\times10^6$。

保证有解。

## 说明/提示

**本题采用捆绑测试。**

数据范围：
- Subtask 1 (10pts)：$n=2$。
- Subtask 2 (20pts)：$n\le 26$。
- Subtask 3 (30pts)：序列 $a$ 单调不降。
- Subtask 4 (40pts)：无特殊限制。

对于全部数据，$1\le n,a_i\le 10^5$，$\sum a_i\le 10^5$。

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
abc
dabc
bda
b```

# 题解

## 作者：Register_int (赞：4)

构造：

- $S_1$：$a_1$ 个 `a`。
- $S_2$：$a_2$ 个 `b` 后接 $a_1$ 个 `a`。
- $S_3$：$a_3$ 个 `a` 后接 $a_2$ 个 `b`。
- $S_4$：$a_4$ 个 `b` 后接 $a_3$ 个 `a`。
- $\vdots$

即可。

---

## 作者：jijidawang (赞：3)

这样构造：

$S_1=\texttt{aaa}\cdots\texttt{aa}$ 其中 $a_1$ 个 $\texttt{a}$。   
$S_2=\texttt{bbbb}\cdots\texttt{bcaaa}\cdots\texttt{aa}$ 其中 $a_1$ 个 $\texttt{a}$、$a_2$ 个 $\texttt{b}$。    
$S_3=\texttt{aaaa}\cdots\texttt{adbbb}\cdots\texttt{bb}$ 其中 $a_2$ 个 $\texttt{b}$、$a_3$ 个 $\texttt{a}$。   
$S_4=\texttt{bbbb}\cdots\texttt{bcaaa}\cdots\texttt{aa}$ 其中 $a_3$ 个 $\texttt{a}$、$a_4$ 个 $\texttt{b}$。    
……

就可以了。

Bonus：只用两种字母？

---

## 作者：粥2414 (赞：1)

# 题目描述
给你 $n$ 个数 $a_1,a_2,\dots,a_n$，要求构造一个方案，输出 $n+1$ 个仅含小写字母的字符串，使得第 $i$ 与第 $i+1$ 个字符串之间的最长公共前后缀长度为 $a_i$。其中取 $i$ 的前缀与 $i+1$ 的后缀。
# 思路
既然是道构造体，那么就要想想如何才能构造出合法的方案（~~废话~~）。

首先发现一个字符串的前缀只与下一个字符串有要求，后缀只与上一个字符串有要求。那么可以考虑用不同的字母，对于第 $i$ 个字符串，只要前面的字母为 $a_{i+1}$ 个，后面的字符为 $a_i$ 个，且前后不同即可。
# 实现
那么构造就很简单了。我利用了 pbds 库中十分方便的 ``rope`` 模板实现。预处理出每个字母对应的字符串，这样可以方便后续的加入。

枚举 $a_i$，在第 $i$ 个字符串前加入字母，在第 $i+1$ 个字符串后也加入同样的字母，然后让字母向后移一位即可。

设 $a$ 为元素个数，``rope`` 单次操作的复杂度为 $O(\sqrt{a})$（一说超大常数 $O(\log a)$），所以时间复杂度 $O(n\sqrt{a})$。
# 代码

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace __gnu_cxx;
using namespace std;
#define ll long long
const ll N=1e5+9;
rope<char>r[N];
ll a[N],n;
char s[30][N];
ll maxx;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		maxx=max(maxx,a[i]);
	}
	for(int j=0;j<maxx;j++)
	for(int i=0;i<26;i++){
		s[i][j]=i+'a';
	}
	int now=0;
	for(int i=1;i<=n;i++,now++,now%=26){
		r[i-1].insert(0,s[now],a[i]);
		r[i].insert(r[i].size(),s[now],a[i]);
	}
	for(int i=0;i<=n;i++){
		cout<<r[i]<<endl;
	}
	return 0;
}
```

---

## 作者：Vae_L (赞：1)

很【数据删除】的构造。

什么字符串中只能出现小写字母完全就是误导人的，其实手玩几组数据就能发现两个字母其实就够了。

因为拼接之后，公共前后缀的长度为 $a$，所以将前面的 $a$ 个字符和后面的 $a$ 个字符保证相同就是合法解了。

于是就出现了一个非常【数据删除】的构造策略。

对于每一个字符串，我们对 $i$ 的奇偶性分类讨论，将其的后缀与上一个的前缀相同，前缀与下一个的后缀相同，注意到字符一定，所以我们只关心长度。

然后就可以了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string s[100005];
int n,a[100005];
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=a[1];i++) s[0]+='a';
	for(int i=1;i<=n;i++)
	{
		char c=(i&1?'b':'a');
		for(int j=1;j<=a[i+1];j++) s[i]+=c;
		c=(i&1?'a':'b');
		for(int j=1;j<=a[i];j++) s[i]+=c;
	}
	for(int i=0;i<=n;i++) cout<<s[i]<<"\n";
	return 0;
}

---

## 作者：_O_v_O_ (赞：1)

6。

咋其他题解都没有思路历程啊，~~虽然这题确实简单~~。

我们注意到 $S_i$ 会与 $a_i$ 和 $a_{i-1}$ 沾上关系。

那么我们就希望，$S_i$ 作为 $a_i$ 的 border 的部分和作为 $a_{i-1}$ 的 border 的部分尽量不要相交，否则，有些难处理。

那么我们不妨令 $S_i$ 作为 $a_i$ 的 border 的部分和作为 $a_{i-1}$ 的 border 的部分使用两个不用的同种字母。

那么构造就显然了起来（我们定义 $A(i)$ 为 $i$ 个 `a` 拼合的字符串，$B(i)$ 为 $i$ 个 `b` 拼合的字符串）：

- $S_1=A(a_1)$；
- $S_2=B(a_2)A(a_1)$；
- $S_3=A(a_3)B(a_2)$；
- $S_4=B(a_4)A(a_3)$；
- 以此类推。

---

## 作者：M1__ (赞：0)

# 题解：P12387 纯白之箭
[题目传送门](https://www.luogu.com.cn/problem/P12387)
## 题目思路
构造题。

结论如下：

$$S_n=
\left\{\begin{matrix} 
   \underbrace{\texttt{bbbb}\cdots}_{a_n 个 b}\underbrace{\texttt{aaaa}\cdots}_{a_{n-1} 个 a} ,& n\bmod 2=0\\  
    \underbrace{\texttt{aaaa}\cdots}_{a_n 个 a}\underbrace{\texttt{bbbb}\cdots}_{a_{n-1} 个 b} ,& n\bmod 2\neq 0
\end{matrix}\right.
$$
考虑证明：
- 显然可以看到，$S_n$ 与 $a_{n-1}$ 和 $a_n$ 存在某种联系。
- 也就是说，$S_n$ 可以分成 $2$ 个部分，前半部分是 $a_{n}$ 的 border 部分，则后半部分为 $a_{n-1}$ 的 border 部分。
- 所以用不同的字母表示两个部分即可。字母不一定是 `a` 或 `b`。

## 代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
ll a[N],n;
string s[N];
void slove(){
	for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=a[1];i++) s[0]+='x';
    for(int i=1;i<=n;i++){
        for(int j=1;j<=a[i+1];j++){
			if(i%2==1) s[i]+='y';
			else s[i]+='x';
		}
        for(int k=1;k<=a[i];k++){
			if(i%2==1) s[i]+='x';
			else s[i]+='y';
		}
    }
    for(int i=0;i<=n;i++) cout<<s[i]<<'\n';	
}
int main(){
    cin>>n;
    slove();
    return 0;
}
```
时间复杂度 $O(n^2)$。

---

## 作者：fish_love_cat (赞：0)

完全不会做，于是随机构造使 border 长度不少于要求，玄学得到 60pts。

我们发现可以使所有字符串都由 $\texttt{ab}$ 两个字符组成，然后使得拼接后的字符串形如 $\texttt{aa\dots abb\dots baa\dots a}$ 或者 $\texttt{bb\dots baa\dots abb\dots b}$，然后令两者交替出现，同时使两端字母个数满足条件，这样就可以极其容易构造出序列了。

然后做完了？？？

这硬控我 1h 啊。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005];
string s[100005];
int main(){
    srand(time(0));
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=a[1];i++)
        s[0]+='a';
    for(int i=1;i<=n;i++){
        for(int j=1;j<=a[i+1];j++)
            s[i]+=(i%2?'b':'a');
        for(int j=1;j<=a[i];j++)
            s[i]+=(i%2?'a':'b');
    }
    for(int i=0;i<=n;i++)
        cout<<s[i]<<'\n';
    return 0;
}
```

---

## 作者：DrDuck (赞：0)

构造题。

从数据范围入手。注意到 Subtask 2 中 $n \le 26$，又联系到英文小写字母刚好是 $26$ 个，不难想到是要把所有字母轮换着用一遍。

我的构造方法是把字符串分成两个部分，让 $S_i$ 的前半部分和 $S_{i + 1}$ 的后半部分中出现相同数量的相同字母，以使它们拼起来的最长公共前后缀满足要求，并且 $S_i$ 的后半部分和 $S_{i + 1}$ 的前半部分字母不同，以防最长公共前后缀的长度因中间的公共部分而改变。

比如样例：
```cpp
3
3 2 1
```
我们先看第一个数。对于 $a_1$，不难给出这样的构造：
```cpp
bbba
cbbb
```
这样拼起来结果是 `bbbacbbb`，最长公共前后缀刚好是 $3$。

但是 $a_2 = 2$，也就是说上面的第二个要进行一些小修改，只需将其改为 `ccbbb` 就可以了，然后让第三个字符串沿用上述套路，即为 `dcc`。

也就是说：
* 字符串  $S_i$ 的后半部分等于  $S_{i - 1}$ 的前半部分，且长度等于 $a_i$。
* 字符串  $S_i$ 的前半部分等于  $S_{i + 1}$ 的后半部分，且长度等于 $a_{i + 1}$。

按顺序确定字符串序列中的字母即可。大概类似于下面的形式：
```cpp
ba
cb
dc
ed
...
zy
az
```
如果 $26$ 个字母都用完了，从 `a` 重新开始即可。具体操作可用取模实现。
# 赛时代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 1e+5 + 5;
const int mod = 'z' - 'a';
int n;
int a[maxn];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    a[n + 1] = 1;
    for (int j = 1; j <= a[1]; j++)
    {
        cout << 'b';
    }
    for (int i = 1; i <= a[1]; i++)
    {
        cout << 'a';
    }
    cout << '\n';
    for (int i = 1; i <= n; i++)
    {
        char xx = 'a' + (i + 1) % mod;
        char yy = 'a' + i % mod;
        for (int j = 1; j <= a[i + 1]; j++)
        {
            cout << xx;
        }
        for (int j = 1; j <= a[i]; j++)
        {
            cout << yy;
        }
        cout << '\n';
    }
    return 0;
}
```

---


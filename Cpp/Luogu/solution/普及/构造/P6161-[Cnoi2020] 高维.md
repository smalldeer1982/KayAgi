# [Cnoi2020] 高维

## 题目背景

> 本质上，幻想乡是高维的。

## 题目描述

Cirno 捕获了一只 $n$ 维蚂蚁，它想从 $S(0,0,...,0)$ 爬到 $T(1,1,...,1)$ 。

被封闭在这个 $1\times1\times...\times1$ 的方格中，蚂蚁每一步只能爬向一个坐标相邻的点。

现在 Cirno 想考考你蚂蚁最多能找到多少条从 $S$ 到 $T$ 的路径两两没有交点( 除 $S$, $T$ )。

并要求你构造这样一组路径。

## 说明/提示

**「本题使用 Special Judge」**

### Sample1解释

第 $1$ 条路径：$(0,0) \rightarrow (0,1) \rightarrow (1,1)$

第 $2$ 条路径：$(0,0) \rightarrow (1,0) \rightarrow (1,1)$

二者除了 $S$ 与 $T$ 无交点。

### 数据范围约定

**「本题不采用捆绑测试，数据有梯度」**

对于 100% 的数据 $3 \le n \le 60$。

### 后置代码片段

 - 二进制压位函数

```cpp
/**
 * For only cpp11, cpp14, cpp17, cpp20.
 *
 * @param: __s : The binary high-dimension position inputed.
 * @return: Standard output format( U64 ).
**/

unsigned long long zip( std::string __s ) 
  { unsigned long long __r = 0;
    for( auto __c : __s ) 
      { ( __r <<= 1ull ) |= ( __c - 0x30 ); }
    return __r; }

```
 - SPJ代码
```cpp
//SPJ
#include "testlib.h"
#include<bits/stdc++.h>

typedef unsigned long long ULL;
typedef std::vector<std::string> SEQ;
typedef std::string STR;

SEQ split( std::string _par, char _sgn )
  { SEQ _rat = SEQ();
	STR _rem = STR();
	
    for( char __c : _par )
      { if( __c = _sgn ) _rat.push_back( _rem ), _rem = "";
	    else _rem += __c; }
	
	if( _rem != "" ) _rat.push_back( _rem );
	
	return _rat; }

ULL to_ULL( std::string _str ) 
  { ULL _rat = 0;
	
	for( char __c : _str )
	  { ( _rat *= 10ull ) += (ULL)( __c - '0' ); }
	
	return _rat; }

bool isPw2( ULL x )
  { return !( x & (x - 1ull) ); }

std::map<ULL, bool> MP;

int main(int argc, char* argv[]) {
    registerTestlibCmd(argc, argv);
	
	ULL n = inf.readLong();
	ULL S = 0, T = (1ull << n) - 1ull;
	ULL N = ouf.readLong();
	
	if( N != n ) quitf( _wa, "Count paths wrongly." );
	
	ouf.readEoln();
	
    while( n -- ) {
    	std::string path = ouf.readLine();
    
    	ULL _lst = 0;
    	
    	for( auto N : split( path, " " ) )
    	  { ULL _now = to_ULL( N );
    		if( _now != S and _now != T and MP[_now] ) 
			  { quitf( _wa, "Paths crossing" ); }
    	    if( !isPw2( _now ^ _lst ) ) 
			  { quitf( _wa, "Wrong path format" ); }
    	    _lst = _now; MP[_now] = true; }
    	
    	if( _lst != T ) quitf( _wa, "Wrong path ending" );
	}
	
	quitf( _ok, "Accepted" );
	
    return 0;
} 
```


## 样例 #1

### 输入

```
2```

### 输出

```
2
0 1 3
0 2 3```

# 题解

## 作者：Rubidium_Chloride (赞：16)

~~谔谔谔这题是数学+构造题。~~

进[博客](https://www.luogu.com.cn/blog/Rolling-blog1424/)看效果更好呦！

进入正题：

## 1.题目大义

有一个长为$n$的$01$串，初始值为$0$，每次可以将它的一位取反，最终值为$2^{n}-1$，让你求出这样不相交的的$01$串的个数的最大值。

## 2.分析

~~看到样例和SPJ第一问应该就出来了吧……~~

对于$3$维的情况，很容易构造出一种$3$条的情况如下：

$0$-$1$-$3$-$7$

$0$-$2$-$6$-$7$

$0$-$4$-$5$-$7$

对于这种情况，本蒟蒻就猜想，是不是对于每一个$n$,答案的第一问都是$n$呢？

## 3.证明

### 3.1 先证对于每一个$n$，$n$维空间中最多$n$条不相交路径

$\because$ 在$n$维空间中，每个点连出$n$条边；（考虑其每一个二进制位取反所得的结果即可得到。）

$\therefore$ 0号节点也不例外；

$\because$ 路劲都不能相交；

$\therefore$ 最多有$n$条路径，命题成立。

### 3.2 再给出一组构造

对于每一个$n$位$01$串，从右开始其每一位分别设为$a_{0}\ a_{1}$……$a_{n-1}$.

于是我们可以轻松地给出这样$n$条路径的一组构造（以下均写改变的$a_{i}$的下标）：

$0$ -- $1$ …… -- $n-1$

$1$ -- $2$ …… -- $n-1$ -- $0$

……

$n-1$ -- $0$ …… -- $n-2$

## 4.CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll k[69]={1},n;//n<=60，所以要开long long 
inline int read(){//快读提高速度 
    register int x=0;char ch=getchar();
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x;
}
int main(){
	n=read();
	printf("%lld",n);//由3.证明，直接输出n即可 
	for(register int i=1;i<=n-1;i++) k[i]=k[i-1]<<1;//预计算2的幂次，为下面压缩2进制数做准备 
	for(register int i=0;i<=n-1;i++){
		printf("\n0");//有特殊的输入要求就按题目说的来，行末无空格 
		for(register ll j=0,m=0;j<=n-1;j++){
			m+=k[(i+j)%n];printf(" %lld",m);//同Line15，千万不能忘了mod n，否则RE 
		}
	}
	return 0;
}//皆大欢喜

```
~END~（祝大家看得开心，有意见可以提出来

---

## 作者：樱雪喵 (赞：9)

本次比赛的第三题，总体来说还可以，但可能题意不太好理解（卡了我两个小时QAQ）

**题意简述**

给定一个数 n ,每次把 n 个0中的一个变为1，直到全部变为1，求其中不相交路径个数。

**主要思路**

举例，如果n=4,那么

第一种情况：

step1: 1 0 0 0

step2: 1 1 0 0

step3: 1 1 1 0

step4: 1 1 1 1

第二种情况：

step1: 0 1 0 0

step2: 0 1 1 0

step3: 0 1 1 1

step4: 1 1 1 1

第三种情况：

step1: 0 0 1 0

step2: 0 0 1 1

step3: 1 0 1 1

step4: 1 1 1 1

情况4请以此类推。

所以我们得到了避免路径相交的方法：

第 n 种情况就是先将第 n 个0变为1，然后把后面的0依次变为1，如果到了最后一个就从第一个开始。（不太难吧）

具体请看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[61];
long long zip()//把二进制码压缩成十进制
{
	long long m=1;
	long long ans1=0;
	while(m<=n)
	{
		ans1+=a[m]*pow(2,m-1);
		m++;
	}
	return ans1;
}
int main()
{
	cin>>n;
	cout<<n<<endl;//n维的就一定有n条路径，从上面的思路里应该不难得出
	for(long long i=1;i<=n;i++)//循环n条路径
	{
		for(long long j=1;j<=n;j++)
		{
			a[j]=0;//把a数组清零
		}
		cout<<"0"<<" ";//起始点为0
		long long b=i;//b是一个指针，代表应该把哪一位的0变为1
		for(long long j=1;j<n;j++)
		{
			a[b]=1;
			long long c=zip();//压缩
			cout<<c<<" ";//输出
			b++;//指针向后移动一位
			if(b>n) b-=n;//如果超过了n就从1开始
		}
		long long d=pow(2,n)-1;//最后一个数的二进制是n个1，转化成十进制就是2^n-1
		cout<<d<<endl;//因为pow的返回值不是整型，所以要把它转化成long long型的
	}
	return 0;//结束！
}
 
```



---

## 作者：YellowBean_Elsa (赞：3)

这题我刚开始拿着魔方捣鼓了半天……

然后还是选择了用超空间系来理解。

此空间有编号为 0 到 n - 1 共 n 维，

刚开始每一维都是 0，然后每次把一维变成 1，变 n 次到达终点。

把每次变的维度的编号按顺序排好，则**刚好是 0 到 n - 1 的一个排列**

我们又要求除了起点和终点外，其它点不重复经过

那么问题转化为：**最多能选出多少排列，满足 $\forall{i \in [1,n-1]}$ 每个排列的前 i 个数所组成集合互不相同**

首先 $i=1$ 时，我们就只有 $n$ 个选择，故最多能选的排列不超过 $n$ 个。

能不能取到呢？构造一个不就是啦。~~（MOer 都知道）~~

我们考虑循环队列式构造：

$$(1,2,…,n)$$
$$(2,3,…n,1)$$
$$……$$
$$(n,1,2…n-1)$$
~~显然~~符合要求

那这道题就做完了

处理行末空格好烦啊

```cpp
//coder: Feliks a Hacker of IOI == GM-YB an AKer of IMO
#include<bits/stdc++.h>
#define fu(i,a,b) for(int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(int i = a, I = (b) - 1; i > I; --i)
typedef long long ll;
using namespace std;
template <class T> inline void read(T &x) {
    x=0;T f=1;char ch=getchar();
    while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    x*=f;
}int n;ll p;
int main(){
	read(n);printf("%d\n",n);
	fu(i,1,n){//以i为排列起点 
		printf("%lld ",p=0LL);//起点
		//(i,i+1…,n,1,2…,i-1)的顺序 
		//i对应的二进制压缩为 2^(i-1) 
		fu(j,i,n-1)printf("%lld ",p+=(1LL<<(j-1)));
		printf("%lld",p+=(1LL<<(n-1)));
		if(i!=1)printf(" "); //行末空格特判QwQ
		if(i>2)fu(j,1,i-2)printf("%lld ",p+=(1LL<<(j-1)));
		if(i>=2)printf("%lld",p+=(1LL<<(i-2)));
  		//处理最后一个，没有行末空格
		puts("");
	}return 0;
}
```


---

## 作者：pyqpyq (赞：3)

蒟蒻第一次写构造题，发篇题解纪念一下。
# 题目分析
其实别联想 n 维的蚂蚁是怎么爬的，我们是三维生物想不出的。~~联想三维以下的情况的当我没说。~~

那怎么办呢？我们最好用 01 串说话。

考虑一个 01 串，它表示一个坐标。而蚂蚁的移动，就可以看成是 01 串中选一个数字取反，要么是 0 到 1，要么是 1 到 0。

当然，我们从贪心的角度考虑，我们希望所有的数字都是从 0 到 1 的。所以，蚂蚁的移动从 S 到 T 的移动，就变成了把 01 串中的 0 按照一定顺序改为 1。

再考虑具体方案。从 S 出发，只有 n 个方向可以走，所以方案数最多为 n。

那方案数是否就是 n 呢？~~样例和数据证明~~没错。我们可以构造一种解法使方案数为 n：枚举第一次填 1 的位置，然后每次往后填 1，填到尾则继续填头，直到填完为止。

用 $n=4$ 来说明：
- 第 1 种：0000 1000 1100 1110 1111

- 第 2 种：0000 0100 0110 0111 1111

- 第 3 种：0000 0010 0011 1011 1111

- 第 4 种：0000 0001 1001 1101 1111

~~通过观察法可以得出~~这种选法是不会走重点的。因为在这种选法中，每个 1 都可以看成一段区间，而区间的左端点在每种走法中都不一样，而区间的右端点又在各自走法中的每一步中不同，所以最终走过的坐标都不相同。

（当然这个“区间”是个抽象的概念，你可以理解成循环队列的头尾指针。）

然而第一次填 1 的位置有 n 种选择，所以最终构造出来的走法会有 n 个。

在实际代码中由于题目要求 $n\le60$，所以要开 longlong，且要进行一定的位运算。

（当然，开 ull 更保险。）

最后注意，由于 spj 缺陷，**行末一定不能有空格**，否则都不知道怎么 WA 的。

（好吧其实题面有讲，出题人不喜勿喷。）
# 参考代码
很短，仅 17 行。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
unsigned long long p;
int main()
{
	scanf("%d",&n);
	printf("%d\n",n);
	for(int i=0;i<n;++i)
	{
		printf("%llu",p=0);
		for(int j=0;j<n;++j)
			printf(" %llu",p|=1ull<<(i+j)%n);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Fatalis_Lights (赞：3)

一道构造题。

题意不再此叙述一遍。

## Solution

题目主要分成两个问题：

+ 最多能找到多少条从 $S$ 到 $T$ 的路径两两没有交点（除 $S$ , $T$ ）。

+ 构造这些路径。

第一个问题比较好想。

我们就当作一个高维立方体去想。

可以发现，在前一半过程中，每一次合法的路径数都在扩展。

举个例子，好想点的。一个立方体（三维）。

走一步，有 $3$ 条路。

走两步呢？有 $6$ 条路。

在后一半的过程中呢？

和前一半对称，每一次合法的路径数都在减少。

减少到多少？ $n$ 。一开始有多少？ $n$ 。

所以第一问的答案就是 $n$ 。

----

第二问就是构造：构造 $n$ 条除了 $S$ , $T$ 两点外不相交的路径。

于是开始构造。

对于第 $i$ 条路径，它的轨迹为：

+ 从第 $i$ 维开始，循环将第 $i$ 维坐标加一，直到加过所有坐标。

例子: 四维。

路径二: $(0,0,0,0)->(0,0,1,0)->(0,1,1,0)->(1,1,1,0)->(1,1,1,1)$

可以证明这条路径的轨迹并不会与其它路径交与异于 $S$ , $T$ 的点，读者可自行尝试。

代码实现见下：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long mp[100][100];
unsigned long long n;
void print(unsigned long long x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
void read(unsigned long long &x){
    unsigned long long f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
inline unsigned long long ksm(unsigned long long a, unsigned long long k){
    unsigned long long ans=1;
    while(k){
        if(k&1) ans=(ans*a);
        a=(a*a);
        k>>=1;
    }
    return ans;
}
void color(int x){ // starting point 
	int tmp=x;
	for(int i=1;i<=n+1;i++)
		mp[tmp][i]=mp[tmp][i-1]+ksm(2,(x+i-1)%n);
}
int main(){
	read(n);
	print(n); puts("");
	for(int i=1;i<=n;i++) color(i);
	for(int i=1;i<=n;i++,puts(""))
		for(int j=0;j<=n;j++){
			print(mp[i][j]);
			if(j!=n) putchar(32);
		}
	return 0;
}
```


---

## 作者：huangzirui (赞：2)

询问在一个 $n$ 维立方体中，最多有多少条从点 $S(0,0, ... ,0)$ 到点 $T(1,1, ... ,1)$ 的路径且它们互不相交。并输出一组满足上述条件的解。

---

首先，因为起点只有 $n$ 种走法，显然答案至多是 $n$ 。

经过一番手算后，可以得到 $n=1,2,3$ 的解如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/w1vztbd9.png)

我们发现答案就是 $n$ ，且其中的每种方案都分别从每个维度的方向走了一次。

例如 $n=3$ 时：

路线红：上 — 右 — 前

路线蓝：右 — 前 — 上

路线黄：前 — 上 — 右

咦？我们发现将路线红的第一个操作移到最后就得到路线蓝，将路线蓝的第一个操作移到最后就得到路线黄，将路线黄的第一个操作移到最后就得到路线红。

于是我们猜想：只要对于任何一种可行的路径，经过这种操作 $n-1$ 得到的 $n$ 条路径（包括原路径）互不相交。

（这个证明很 easy ， 所以不写）

于是随便找到一条路径然后做上面的那个操作就可以构造一组合法解。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
int i,j,k,n,m;
int a[65],tmp[65],now[65],X[65];
void OUT(__int128 x){
	int S=0;
	while(x){
		X[++S]=x%10;
		x/=10;
	}
	for(int i=S;i>=1;i--)printf("%d",X[i]);
}
int main(){
	cin>>n;
	for(i=1;i<=n;i++)a[i]=i-1;
	cout<<n<<endl;
	for(i=1;i<=n;i++){
		__int128 now=0;
		printf("0");
		for(j=1;j<=n;j++){
			now+=((__int128(1))<<a[j]);
			printf(" ");
			OUT(now);
		}printf("\n");
		for(j=1;j<=n;j++)tmp[j%n+1]=a[j];
		for(j=1;j<=n;j++)a[j]=tmp[j];
	}return 0;
}
```

---

## 作者：Legitimity (赞：2)

这题我在比赛的时候因为各种玄学错误，导致折腾了半天，在最后 $20$ 分钟才过 $\ldots\ldots$

首先，这道题太啰嗦了，其实把题意简化一下，我们就会发现。对于 $i$ 维，除去起点和终点路径长度就是 $i-1$，要求这些节点互不相同。我们分析一下，$i$ 维其实就有 $2^i-2$ 个节点，我们把它们一相除，就会发现结果是 $i$，就是有 $i$ 条路径。~~（以上有可能是我瞎 yy 的）~~

怎么求出每一条路径呢？可能一下子想到的是枚举并用一个哈希表判断是否重复，但这种做法又费空间又费时间，那么就要用到我在比赛时灵光一闪的方法了（放烟花）

------------

大体思路是用一个一维数组，下标 $i$ 对应着**在操作时路径上的节点 $i$ 需改变的维度**。初始化为 $0$，对应第 $1$ 维。一次操作后，就将它加 $1$，留给下一条路径；并且，经过观察，我们不难发现，$f_{i+1}$ 对应的维度就是 $f_i$ 的维度加 $1$，即可满足题目要求。

但可能会有一个问题，如果一直加下去，$f_i$ 迟早会超过 $n$。怎么办？那就取个模呗！即 $f_{i+1}=(f_i+1)\mod n$。

同理，操作后要 $f_i\gets f_i+1$。

至于这个方法的原理，我也不知道，只是比赛时的一个猜想。如果有哪位 dalao 想证明此方法，可以自己研究一下。日后如果我想到了证明方法，就会补上来。

如果您到现在还没有理解，结合代码食用更佳。

**AC 代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,f[65];    
long long last;  //终点的压缩坐标。 
string now;  //now 为当前节点的坐标。 
long long po(long long x)  //手打一个计算幂的函数。 
{
	long long re=1;
	for(register long long i=0;i<x;i++) re*=2;
	return re;
}
long long zip(string a)   //如题，微改的压缩函数。 
{
	long long size=a.length();
	long long h=0;
	for(register long long i=size-1;i>=0;i--) 
		 if(a[i]=='1')
			h+=po(i);
	return h;
}
int main()
{
  	cin>>n;
  	cout<<n<<endl;   //n 条路径 。 
  	last=po(n)-1;  
  	for(register long long i=0;i<n;i++)
	{
  		cout<<0<<" ";  //起点 
  		for(register long long j=0;j<n;j++)
  			now+='0';  //这是 now 的初始化，将坐标赋为 0。 
		for(register long long j=1;j<n;j++)
  		{
			now[f[j]]='1';   //精髓，将需改变的维度改变。 
			f[j+1]=(f[j]+1)%n;  //求出 f[i+1]。 
			f[j]=(f[j]+1)%n;    //为防止下一条路径重复，本身也要改变。 
			long long g=zip(now);
			cout<<g<<" ";  //输出压缩后的路径。 
  		}
  		cout<<last<<endl;
  		now.clear();  //记住！！！一定要清空。 
  	}
    return 0;
}
```


PS：还有这题我一直搞不懂的是：我在比赛的一开始**用 cmath 的 pow 函数来计算幂**，但是一直会 WA 三个点；后来**用手打了一个求幂函数**就过了（大雾



---

## 作者：SUNCHAOYI (赞：1)

**我们开始找规律，慢慢进行构造。以$n = 3$为例，首先是$(0,0,0)->(0,0,1)->(0,1,1)->(1,1,1)$,这便是一种可能。   那么如何做到以下的路径没有重复呢？以上经过的两个点肯定是不能再经过了，那么还剩下$(0,1,0),(1,0,0),(1,0,1),(1,1,0)$。经过构造后发现还有2组可能：$(0,0,0)->(0,1,0)->(1,1,0)->(1,1,1)$和$(0,0,0)->(1,0,0)->(1,0,1)->(1,1,1)$。**

**由特殊推广到一般，对于一个$n$维的数组，第$k$步会有$k$个$1$出现，且第$n-1$步时会有$C_n^{n - 1}$种可能，我们将其化简得$\frac{1*2*…*(n-1)*n}{1*2*…*(n-1)}$,同时除以$1*2*…*(n-1)$，得原式等于$n$（其实$C_n^{n - 1} = C_n^1 = n$）因此对于一个$n$维的数组，最多将会有$n$条路径。**

------------

那么如何进行二进制压位呢？我们进行一个预处理就行了。先尝试算出$2^{1…n}$
```
a[1] = 1;
for(int i = 2;i <= n;i++) a[i] = a[i - 1] * 2;//预处理 
```
然后对于每条路径第$k$个点，将会有$k$个$1$，因此有：
```
for(int j = 1;j <= n;j++)
{
	k += a[j];//表示第j个点（有j个1） ，二进制对应位相加
	cout<<k;
	if(j != n) cout<<" ";//不要多输出空格！ 
}
```
最后使得每条路径不同，我们只要把这个预处理的数组进行轮即可
```
long long now = a[1];
for(int l = 1;l < n;l++) a[l] = a[l + 1];//类似循环队列 把1,2,4-->2,4,1-->4,1,2…… 
a[n] = now;
cout<<endl;
```

------------

**最后记得：不开$long$ $long$~~你懂的~~**
```
#include <iostream>
using namespace std;
long long a[65];
int main()
{
	a[1] = 1;
	int n;
	cin>>n;
	cout<<n<<endl;
	for(int i = 2;i <= n;i++) a[i] = a[i - 1] * 2;//预处理 
	for(int i = 1;i <= n;i++)
	{
		cout<<0<<" ";//起点 
		long long k = 0;
		for(int j = 1;j <= n;j++)
		{
			k += a[j];//表示第j个点（有j个1） 
			cout<<k;
			if(j != n) cout<<" ";//不要多输出空格！ 
		}
		long long now = a[1];
		for(int l = 1;l < n;l++) a[l] = a[l + 1];//类似循环队列 把1,2,4-->2,4,1-->4,1,2…… 
		a[n] = now;
		cout<<endl;
	}
	return 0;
}
```



---

## 作者：Spasmodic (赞：1)

这是一道典型的构造题，要求输出总数再输出方案，还给了SPJ程序

首先，我们仔细地观察SPJ程序，可以找到这一段代码：
```cpp
	ULL n = inf.readLong();
	ULL S = 0, T = (1ull << n) - 1ull;
	ULL N = ouf.readLong();
   
	if( N != n ) quitf( _wa, "Count pathes wrongly." );
```
这说明，总数一定就是$n$。

于是，第一问就搞定了。

Q:那应该怎么证明？

A:~~我也不知道怎么证~~我们可以发现蚂蚁从$S$点向外走一共有$n$条路，所以显然答案不会超过$n$。

然后写个程序跑了几遍发现可以构造，于是第一问答案就是$n$。

下面我们就要去构造这个结论，由于$n$比较小，所以可以直接暴力构造。

注意到路径必须一条一条找，否则就会重叠，因此我们可以考虑不使用`dfs`，直接`for`循环枚举下一个点即可。

不过这题还是有一些很坑的小细节的，比如每一行末尾不能有多余的空格，不然由于SPJ使用的是`getline`，无法过滤，所以就会像我一样爆0。

代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=65;
ll n,num;
set<ll>S;
int main(){
	scanf("%lld",&n);
	printf("%lld",n);
	for(ll t=1;t<=n;t++){
		printf("\n0 ");
		for(ll id=1,s=0;id<=n;id++)
			for(ll i=0;i<n;i++)
				if((s&(1LL<<i))==0&&((s|(1LL<<i))==(1LL<<n)-1||!S.count(s|(1LL<<i)))){
					S.insert(s|=(1LL<<i));
					if(id!=n)printf("%lld ",s);
					else printf("%lld",s);//判断是不是最后一个数
					break;
				}
	}
	return 0;
}

```

---

## 作者：流绪 (赞：0)

这不是正解！这不是正解！这不是正解！大佬跳过！

这是一篇搜索的题解,比赛时发现可能是构造，好像不太会写，想着先混个分再说，没想到直接水过了，成功收获最长运行时间的解法。

首先是有几条路径的问题，任意路径不能经过同一个点，模拟一下 n=2 和 n=3 的情况，发现走的路线刚好就是 n 条。

搜索挺好想的，终点是二进制下有 n 位 1，那么我们搜索时，每次找一个位置来放 1。因为走过的点不能再走，那么搜完一条路可以直接回到开头。

核心的是怎么记录那个点走过了，我这里是直接开一个数组记录，然后每次遍历数组看有没有存过。对于极限的 n=60，他一共会走过 58*60=3480 个点，所以还是能水过的。

下面是 AC 代码。
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define ld long double
#define inf 0x7f7f7f7f
#define maxn 10000010
#define ri register int
#define il inline
#define mod 1000000009
using namespace std;
int s[100] = {0};
int v[maxn] = {0};
int n,p=1;
int check(int x)
{
	for(int i=1;i<=p;i++)
		if(v[i] == x)
			return 0;
	return 1;
}//查找有没有走过
void dfs(int dep,int num)
{
	if(dep == n)
	{
		for(int i=0;i<n;i++)
			cout << s[i] << " ";//输出中间走过的点
		cout << ((int)1<<n)-1 << endl;//输出终点
		return ;
	}
	for(int i=0;i<n;i++)
		{
			int x = (((int)1<<i)|num);//枚举往哪走
			if(check(x))
			{
				s[dep] = x;//记录答案
				v[p++] = x;//记录走过了
				dfs(dep+1,s[dep]);//往下搜
				if(dep>1)//如果这不是第一层,就不用往下搜了
					break;//因为此时再搜的话走的第一个点就重复了
			}
		}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin >> n;
	cout << n <<endl;
	dfs(1,0);
  	return 0;
}
```


---

## 作者：Lithium_Chestnut (赞：0)

考虑过我们小六的感受吗qwq

**指针解法**

用一个指针把$>=n$的数全部从$0$改为$1$。

注意要开```long long```，并且算次方的函数$pow$（在```cmath```头文件库中）一定也要强制类型转换为```long long```。

代码里有注释，可以借助注释理解。

$Code:$

```cpp
#include<bits/stdc++.h>//万能头文件 
#define fori for(ll i=1;i<=n;i++)
#define forj for(ll j=1;j<=n;j++)
#define forn for(ll j=1;j<n;j++)
#define memset0 memset(a,0,sizeof(a));
#define ll long long
using namespace std;//命名空间 
int n;//输入的数 
ll last,a[101],check;//最后一个数，a数组，指针 
int main()
{
	cin>>n;//输入 
	cout<<n<<endl;//找规律 
	last=(ll)pow(2,n)-1;//最后一个数是2^n-1，但注意强制类型转换，变成long long 
	fori
	{
		forj memset0;//数组清0 
		cout<<"0 ";//直接输出0 
		ll check=i;//指针=i 
		forn
		{
			a[check++]=1;
			ll ins=1,ans=0;//2进制转10进制 
    		while(ins<=n) ans+=a[ins]*(ll)pow(2,ins-1),ins++;
			cout<<ans<<" ";//输出答案 
			if(n<check) check=1;//指针归1 
		}
		cout<<last<<endl;//输出最后一个数 
	}
	return 0;//程序结束，返回0 
}
```


---


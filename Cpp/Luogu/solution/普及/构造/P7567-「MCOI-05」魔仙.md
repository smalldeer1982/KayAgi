# 「MCOI-05」魔仙

## 题目背景

你是魔仙堡里的占星魔仙。

## 题目描述

魔仙女王的宝石被古娜拉黑暗之神偷走了！古娜拉黑暗之神藏在魔仙堡的 $n$ 个穹顶中的任意一个里面，这 $n$ 个穹顶编号为 $1 \sim n$，第 $i$ 个穹顶可以将其赋予 $a_i$ 的魔力，$a_i$ 必须是整数。

如果所有穹顶的魔力之和为 $0$，之积为 $n$，那么我们称这种情况是可以轻易搜索出古娜拉黑暗之神的。

魔仙女王让占星魔仙求一种赋予魔力的情况使得是可以轻易搜索出古娜拉黑暗之神的。

## 说明/提示

#### 样例 1 解释

$1 +(-1)+2+(-2)=0$，$1 \times (-1) \times 2 \times (-2)=4$。

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（5 pts）：$n\le 1$
 - Subtask 2（20 pts）：$n,\sum n\le 100$
 - Subtask 3（75 pts）：没有特殊限制。

对于 $100\%$ 的数据，$1 \le n\le10^6$，$\sum n\le 5\times10^6$，$1\le T\le10^5$。

**本题采用 Special Judge**，你只需要输出其中一种序列。

## 样例 #1

### 输入

```
2
4
114513```

### 输出

```
1 -1 2 -2
w33zAKIOI```

## 样例 #2

### 输入

```
1
1```

### 输出

```
w33zAKIOI```

# 题解

## 作者：FuriousC (赞：19)

[题目传送门](https://www.luogu.com.cn/problem/P7567)

这题我在比赛中推了30min才推出来结果发现是原题。。。

菜是原罪

### 先证一下n是4的倍数：

设这$n$个整数分别为$a_1,a_2...a_n$，则$a_1\times a_2\times ...\times a_n=n$，$a_1+a_2+...+a_n=0$

**1.数列中有$0$个偶数：**

则$n$为$n$个奇数之积，故也为奇数

所以$a_1+a_2+...+a_n$为奇数个奇数之和，必为奇数

与$a_1+a_2+...+a_n=0$矛盾

**2.数列中有$1$个偶数：**

则$n$为$n-1$个奇数与$1$个偶数之积，故为偶数

所以$n-1$为奇数

所以$a_1+a_2+...+a_n$为奇数个奇数之和再加一个偶数，必为奇数

再次与$a_1+a_2+...+a_n=0$矛盾

**3.数列中有$2$个偶数：**

则$n$为$n-2$个奇数与$2$个偶数之积，故为偶数

所以$n-2$为偶数

所以$a_1+a_2+...+a_n$为偶数个奇数之和再加两个偶数，必为偶数

不与$a_1+a_2+...+a_n=0$矛盾

因此，此序列中至少有$2$个偶数，即$n$能被$4$整除

### 再来看看怎么求出数列：

因为$n$为$4$的倍数，所以设$n=4k$（$k$为正整数）

**1.当$k$为奇数时：**

$n=2\times (-2k)\times 1^{3k-2}\times (-1)^k$

验证：

(1).和：

$2-2k+3k-2-k=0$

(2).积：

$2\times (-2k)\times 1^{3k-2}\times (-1)^k$

$=-4k\times 1\times -1$

$=4k=n$

**2.当$k$为偶数时：**

$n=(-2)\times (-2k)\times 1^{3k}\times (-1)^{k-2}$

验证：

(1).和：

$-2-2k+3k-k+2=0$

(2).积：

$(-2)\times (-2k)\times 1^{3k}\times (-1)^{k-2}$

$=4k\times 1\times 1$

$=4k=n$

### 代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		int n;
		scanf("%d",&n);
		if(n%4==0){
			int k=n/4;
			if(k%2==1){
				printf("2 -%d ",k*2);
				for(int i=1;i<=3*k-2;i++){
					printf("1 ");
				}
				for(int i=1;i<=k;i++){
					printf("-1 ");
				}
			}else{
				printf("-2 -%d ",k*2);
				for(int i=1;i<=3*k;i++){
					printf("1 ");
				}
				for(int i=1;i<=k-2;i++){
					printf("-1 ");
				}
			}
			printf("\n");
		}else{
			printf("w33zAKIOI\n");
		}
	}
	return 0;
}
//w33z AK IOI!
```


---

## 作者：滑蒻稽 (赞：9)

**Description**

[P7567 「MCOI-05」魔仙
](https://www.luogu.com.cn/problem/P7567)

**Solution**

我来教大家作为一名蒟蒻如何在赛场上做出这道题。

首先写一个可以过前两个 Subtask 的暴力搜索：

```cpp
#include <bits/stdc++.h>

using namespace std;
int T,n;
int a[1005],p;
bool ok;

void dfs(int p,int mul) {
	if(n%mul!=0) return; // 剪枝，如果当前无法被除尽，后面也不可能
	if(abs(mul)>n) return; // 剪枝，如果当前乘积超过了目标，不再继续搜索
	if(ok) return; // 如果搜到一个解就不再搜了
	if(p==n) { // 如果搜到了目标
		int cnt=0,mul=1;
		for(int i=1;i<=p;i++) { // 计算和与积
			cnt+=a[i];
			mul*=a[i];
		}
		if(cnt==0 && mul==n) { // 如果符合条件
			for(int i=1;i<=p;i++) cout<<a[i]<<' '; // 输出解
			cout<<endl;
			ok=true; // 标记搜到了解
		}
		return;
	}
	for(int i=max(-n,a[p]);i<=n;i++) { // 从上一个数开始枚举，保证答案序列递增，不会搜到重复解
		if(i==0) continue; // 不能乘 0
		a[p+1]=i; // 记录解
		dfs(p+1,mul*i);
	}
}

int main() {
	ios::sync_with_stdio(false);
	freopen("test.out","w",stdout); // 输出到文件
	cin>>T;
	for(int i=1;i<=T;i++) {
		n=i;
		cout<<"#"<<i<<": "; // 当前分解数
		ok=false; // 将可分解标记置为 false
		a[0]=-1e9;
		dfs(0,1); // 开始搜索
		if(ok==false) cout<<"w33zAKIOI\n"; 
	}
	
	return 0;
} 
```

注意代码中的变量 `ok`，这保证我们搜到一组可行解后就退出程序。你也可以试试注释掉所有与 `ok` 有关的语句看看程序会输出什么。

并注意 dfs 里循环的起始条件为 `i=max(-n,a[p])`，这保证我们不会搜到本质上相同的解（比如 `-2 -1 1 2` 和 `-2 -1 2 1`）。

输入 `T=30`，这个程序会输出：

```cpp
#1: w33zAKIOI
#2: w33zAKIOI
#3: w33zAKIOI
#4: -2 -1 1 2 
#5: w33zAKIOI
#6: w33zAKIOI
#7: w33zAKIOI
#8: -4 -2 1 1 1 1 1 1 
#9: w33zAKIOI
#10: w33zAKIOI
#11: w33zAKIOI
#12: -6 -1 -1 -1 1 1 1 1 1 1 1 2 
#13: w33zAKIOI
#14: w33zAKIOI
#15: w33zAKIOI
#16: -8 -2 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 
#17: w33zAKIOI
#18: w33zAKIOI
#19: w33zAKIOI
#20: -10 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 
#21: w33zAKIOI
#22: w33zAKIOI
#23: w33zAKIOI
#24: -12 -2 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
#25: w33zAKIOI
#26: w33zAKIOI
#27: w33zAKIOI
#28: -14 -1 -1 -1 -1 -1 -1 -1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 
#29: w33zAKIOI
#30: w33zAKIOI
```

无论多蒟的蒟蒻都可以发现，**似乎**只有当  $n$ 能被 4 整除的时候有解。并且，若设 $n=4k$，当 $k$ 为奇数或偶数时，输出的解的**形式**会有有所不同。

仔细观察并归纳一下：

设 $n=4k$。若 $k$ 是奇数，有 $n=2\times \frac {n} {-2} \times (-1)^{k}\times 1^{3k-2}$；若 $k$ 为偶数，有 $n=(-2)\times \frac {n} {-2} \times 1^{3k}\times (-1)^{k-2}$。

验算一下，我们构造解的方式显然没有问题。至于为什么在 $n$ 不被 4 整除时没有解，其他的大佬已经证了。

**My code**

```cpp
#include <bits/stdc++.h>

using namespace std;
int T,n;

int main() {
	ios::sync_with_stdio(false);
	cin>>T;
	for(int i=1;i<=T;i++) {
		cin>>n;
		if(n%4!=0) cout<<"w33zAKIOI\n"; // 如果没有解
		else {
			int k=n/4;
			if(k%2==0) { // 若 k 为偶数
				cout<<-2<<' '<<n/-2<<' ';
				for(int i=1;i<=3*k;i++) cout<<1<<' ';
				for(int i=1;i<=k-2;i++) cout<<-1<<' ';
			} else { // 若 k 为奇数
				cout<<2<<' '<<n/-2<<' ';
				for(int i=1;i<=k;i++) cout<<-1<<' ';
				for(int i=1;i<=3*k-2;i++) cout<<1<<' ';
			}
			cout<<endl;
		}
	}
	
	return 0;
} 
```

---

## 作者：DYan_Hyaena (赞：8)

闲话：这道好像是有过原题，这才发现自己事帧菜a，鵺！

### 题目大意
给你一个数字 $n$ ，请问能否将 $n$ 分解为 $n=\prod_{i=1}^n a_i$ 的形式，使 $\sum_{i=1}^n a_i=0$

#### 题目分析：

我们先假设

$$n=a_1\times a_2\times a_3\times \cdots\times a_n$$

经过一番思考，我们可以发现一个显然的事实： **能分解的 $n$ 不可能是奇数**。

我们在证明之前，先注意这几个性质：

- 所有的奇数都不可能有偶数因子，换句话说，奇数的因子都是奇数

- 奇数个奇数相加，得到的结果一定是奇数

- 偶数个奇数相加，得到的结果一定是偶数

- 不管多少个偶数加上一个数字，都不会改变这个数字的奇偶性

`注：这里说的奇数包括正数与负数`

现在让我们证明一下：如果存在可以被分解的奇数 $n$ ，那么 $a_1,a_2,a_3,\cdots,a_n$ 一定全都是奇数，那么 $a_1+a_2+a_3+\cdots+a_n$ 必为奇数个奇数相加，是奇数，而 $0$ 又是个偶数，不符合题意，所以 $n$ 不可能是奇数。

再经过一段的打草稿，你会发现诸如 $4,8,12,16$ 这类数字可以按照题意分解，但 $2,6,10,14$ 这类却不行。我们不如猜想：可以分解的数字一定是 $4$ 的倍数。

事实上，上面的猜想是成立的： $n=4k,k\in \text{N}$ 是 $n$ 可以被分解的充要条件。我们的证明如下：

我们发现， **偶数个偶数的积一定可以被4整除** ，所以原要证明的论题变为： $a_1,a_2,a_3,\cdots,a_n$ 中一定有偶数个偶数。

这个论题很好证了。假设结论不成立，那么如果 $a_1,a_2,a_3,\cdots,a_n$ 中有奇数个偶数，那么 $n=\prod a_i$ 仍然可以满足上述的分解。

但是注意到我们先前论证了 $n$ 一定是偶数，那么假设 $a_i$ 中有 $k$ 个偶数 ( $k$ 是奇数 )，那么剩下的 $(n-k)$ 个 $a_i$ 一定都是奇数了。

但是 $(n-k)$ 又是一个奇数 ( $n$ 为偶数， $k$ 为奇数 )，所以实际上 $\sum a_i$ 变成了 

$$(\text{偶数}) +(\text{奇数个奇数})$$

的形式，结果一定是一个奇数，不可能为 $0$ ，与题目要求矛盾，故原命题得证。

所以我们便明白了， $n$ 可以被分解当且仅当 $n=4k,k\in \text{N}$ 。接下来我们需要求这个分解出的序列了。

~~通过打表~~ 我们可以发现：
$$
\begin{aligned}
4&=2*(-2)*1*(-1)\\

8&=(-2)*(-4)*1^6*(-1)^0\\

12&=2*(-6)*1^7*(-1)^3\\

16&=(-2)*(-8)*1^{12}*(-1)^2\\

&\cdots\cdots
\end{aligned}
$$

我们发现当 $k$ 为奇数的时候， $n$ 的分解式前两项为 $2\times (-2\times k)$

当 $k$ 为偶数的时候，分解式前两项为 $-2\times (-2\times k)$

所以我们不如各自针对这两个情况列两个方程：

当 $k$ 为奇数的时候，设分解式里面有 $x$ 个 $1$ 与 $y$ 个 $-1$，即：

$$
\begin{aligned}
n&=4k\\
&=2\times(-2\times k)\times
\begin{matrix}\underbrace{1\times 1\times\cdots\times1}\\x\text{个}\ 1\end{matrix}\times\begin{matrix}\underbrace{(-1)\times (-1)\times\cdots\times(-1)}\\y\text{个}-1\end{matrix}
\end{aligned}
$$

那么我们可以列出一个方程组：
$$
 \begin{cases}
 -2k+2+x-y=0\\
 x+y+2=4k\\
 \end{cases}
$$
前一个方程意思是 $\sum a_i=0$

后一个方程意思是保证分解式总共有 $n$ 项

解得
$$
 \begin{cases}
x=3k-2\\
y=k\\
 \end{cases}
$$

所以我们得知，当 $k$ 为奇数的时候，

$$n=2\times(-2k)\times1^{3k-2}\times-1^k$$

同理可以得到当 $k$ 为偶数的时候

$$n=(-2)\times(-2k)\times 1^{3k}\times(-1)^{k-2}$$

到这里这道题就彻底解决了。AC代码如下：（请各位看官忽略缺省源的宏定义）

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&(~x+1)
#define Ilove return//差不多
#define lsh 0;//得了
using namespace std;
typedef long long ll;
typedef unsigned int ut;
typedef const int coi;
typedef unsigned long long ul;
inline int rd(){
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){ans=(ans<<3)+(ans<<1)+ch-48;ch=getchar();}
	return ans*f;}
int T=rd(),judge;
int main(){
	while(T--){
		int n=rd();
		if(n%4!=0){
			printf("w33zAKIOI\n");
			continue;
		}
		judge=n/4;
		if(judge&1){
			printf("2 %d ",-2*judge);
			for(int i=1;i<=3*judge-2;i++)printf("1 ");
			for(int i=1;i<=judge;i++)printf("-1 ");
		}
		else{
			printf("-2 %d ",-2*judge);
			for(int i=1;i<=3*judge;i++)printf("1 ");
			for(int i=1;i<=judge-2;i++)printf("-1 ");
		}
		putchar('\n');
	}
	Ilove lsh
}
```

---

## 作者：一只书虫仔 (赞：7)

#### Description

> 求构造一个长度为 $n$ 的序列 $a_i$（$a_i \in \bf Z$）使得：
>
>$$\sum\limits_{i=1}^n a_i=0$$
>$$\prod\limits_{i=1}^n a_i=n$$
>
>或者指出无解。
>
>$1 \le n \le 10^6$。

#### Solution


首先判断无解，不难发现 $n \bmod 4=0$，下面进行证明。

如果全部是奇数，那么 $n$ 也是奇数，这样就无法配出和为 $0$ 的序列了。

如果只有一个偶数，那么 $\displaystyle \sum\limits_{i=1}^n a_i$ 可以简化为一个偶数加一个奇数，同样不是一个偶数。

所以至少有两个偶数。

所以：

$$n=\prod\limits_{i=1}^n a_i\to n\bmod 4=0$$

证毕。

下面考虑构造。

- $n \bmod 8=0$：
	- $2,\frac n 2$ 凑 $n$。
    - $\frac n 2+2$ 个 $-1$ 抵消。
    - $\frac n 4-2$ 对 $(1,-1)$ 占位。
- $n \bmod 8=4$：
	- $-2,\frac n 2$ 凑 $-n$。
    - $\frac n 2-2$ 个 $-1$ 抵消。
    - $\frac n 4$ 对 $(1,-1)$ 占位。

---

## 作者：mianTzQwQ (赞：5)

这题，是一道数论题。

将题目简化，我们得到：

>有 $n$ 个整数，乘积为 $n$，和为 $0$。给你 $n$，问你有没有符合的解。

通过尝试，不难发现当 $4\ \mid\ n$ 时，有符合的解。

---

下面给出严格论证及构造：

若 $n$ 为奇数时有满足要求的解，则$\prod\limits_{i\ =\ 1}^na_i = n$ 为奇数。

因此 $n$ 个整数均为奇数，即 $a_1$ 到 $a_n$ 中有奇数个奇数。

而奇数个奇数之和仍为奇数，与 $\sum\limits_{i\ =\ 1}^na_i = 0$ 为偶数矛盾。

因此 $n$ 不为奇数，即 $2\ \mid\ n$，所以 $\prod\limits_{i\ =\ 1}^na_i = n$ 为偶数。

从而 $a_1$ 到 $a_n$ 中至少有一个偶数。

若 $2\ \mid\mid\ n$，即 $a_1$ 到 $a_n$ 中只有一个偶数，不妨设为 $a_n$。

此时有 $(n\ -\ 1)$ 个奇数。

因为 $2\ \nmid n\ -\ 1$，所以 $\sum\limits_{i\ =\ 1}^{n\ -\ 1}a_i$ 为奇数。

此时 $\sum\limits_{i\ =\ 1}^na_i\ =\ \sum\limits_{i\ =\ 1}^{n\ -\ 1}a_i + a_n$ 为奇数加偶数，即为奇数，与 $\sum\limits_{i\ =\ 1}^na_i = 0$ 为偶数矛盾。

所以 $4\ \mid\ n$，构造如下。

对于 $n = 4k$：

当 $2\ \mid\ k$ 时，$\begin{cases}a_1\ =\ 2,\\\ a_2\ =\ 2k,\\\ a_3\ =\ a_4\ =\ \cdots\ =\ a_k\ =\ 1,\\\ a_{k\ +\ 1}\ =\ a_{k\ +\ 2}\ =\ \cdots\ =\ a_{4k}\ =\ -1\end{cases}$ 时成立；

当 $2\ \nmid\ k$ 时，$\begin{cases}a_1\ =\ -2,\\\ a_2\ =\ 2k,\\\ a_3\ =\ a_4\ =\ \cdots\ =\ a_{3k}\ =\ 1,\\\ a_{3k\ +\ 1}\ =\ a_{k\ +\ 2}\ =\ \cdots\ =\ a_{4k}\ =\ -1\end{cases}$  时成立。

综上，$4\ \mid\ n$ 时有符合的解。

```cpp
#include <iostream>
using namespace std;
int main()
{
    int q;
    cin >> q;
    while (q--)
    {
        int n;
        cin >> n;
        if (n % 4 != 0)
        {
            cout << "w33zAKIOI\n";
            continue;
        }
        else
        {
            int k = n / 4;
            if (k % 2 == 0)
            {
                cout << "2 " << 2 * k << " ";
                for (int i = 1; i <= k - 2; i++)
                    cout << "1 ";
                for (int i = 1; i <= 3 * k; i++)
                    cout << "-1 ";
                cout << endl;
            }
            else
            {
              cout << "-2 " << 2 * k << " ";
              for (int i = 1; i <= k; i++)
                  cout << "1 ";
              for (int i = 1; i <= 3 * k - 2; i++)
                  cout << "-1 ";
              cout << endl;
            }
        }
    }
    return 0;
}
```

---

## 作者：HSY666 (赞：3)

质因数分解+深搜+剪枝。

首先题目要求给 $ T $ 组数据，给定一个正整数 $ n $ ，要求构造一个整数序列 $ a_1,a_2 \cdots a_n $ ，使得

$$
\sum\limits_ {i=1}^n a_i = 0
$$

$$
\prod\limits_ {i=1}^n a_i = n
$$

显然当 $ n $ 为质数时无解。

我们可以想到 $ \left\vert a_i \right\vert $ 必须是 $ n $ 的因数，因此可以对 $ n $ 进行质因数分解（若还不会分解质因数，请看百度百科[分解质因数](https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/2253749?fromtitle=%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3&fromid=10305400&fr=aladdin)），假设 $ n $ 有 $ m $ 个质因数，分别为 $ p_1,p_2 \cdots p_m $ （当 $ p_m = n $ 时， $ n $ 为质数，即无解），显然 $ m < n $ 且它们都可以放到 $ a $ 数组里，剩下的数可以用 $ 1 $ 或 $ -1 $ 来补满 $ n $ 个数。接下来就是 $ a_i $ 的符号了，最朴素的，我们可以用深搜，将 $ a $ 数组里的数确定好了以后，直接深搜回溯然后判断是否符合条件即可，但是这样做的时间复杂度是惊人的，大概是 $  O(2^n) $ ，所以我们不能直接对 $ a $ 数组进行朴素的深搜回溯，还需要一些优化和剪枝。

关注 $ a $ 数组和题目条件，可以发现 $ a_i $ 的正负号的数量**几乎**是均匀的，因此我们可以做一个优化：使得 $ a_i $ 尽量有序（这个在质因数分解时即可做到），当 $ i $ 为奇数时，先搜 $ a_i $ 为正，再搜 $ a_i $ 为负；反之先搜 $ a_i $ 为负，再搜 $ a_i $ 为正。这样同样能搜完所有情况，并能更快的接近解，在要搜的数量很多时优化效果明显，~~不过当要搜的数量很少时，它和朴素的深搜回溯在时间上没有太大的差别qwq。~~

然而在 $  O(2^n) $ 复杂度面前，优化也显得无力，观察 $ a $ 数组可以发现，数组中 $ 1 $ 和 $ -1 $ 的数量较多，我们可以只搜质因数部分，然后再统一处理所有的 $ 1 $ 和 $ -1 $ 即可，设 $ 1 $ 和 $ -1 $ 的数量为 $ num $ ，显然 $ num = n - m $ ，设

$$
0 - \sum\limits_ {i=1}^m p_i = d
$$

$$
\prod\limits_ {i=1}^m p_i = dul
$$

显然 $ dul = n $ 或 $ -n $ 。

那么，若 $ \left\vert d \right\vert > num $ 或 $ num -\left\vert d \right\vert $ 为奇数，即无法使得

$$
\sum\limits_ {i=1}^n a_i = 0
$$

就不是解，回溯；反之若满足 $ num - \left\vert d \right\vert $ 为偶数，我们令

$$
D=\begin{cases} \dfrac{ num - d }{2} & d \geqslant 0
\\
\dfrac{ num - d }{2} + d & d < 0 \end{cases}
$$

其中， $ D $ 为 $ a $ 数组中 $ -1 $ 的数量，显然，此时有解，当 $ dul = -n $ 且 $ D $ 为奇数，或， $ dul = n $ 且 $ D $ 为偶数。有解就直接输出此时所有的 $ p_i $ 和 $ D $ 个 $ -1 $ ， $ num $ 个 $ 1 $ 即可。

若深搜做完后并没有搜到解，还不能说明它无解，设搜索到某一状态时，满足 $ num - \left\vert d \right\vert $ 为偶数，但不满足 $ dul = -n $ 且 $ D $ 为奇数，或， $ dul = n $ 且 $ D $ 为偶数，我们可以找到其中两个质因数 $ p_i,p_j $ ，使得 $ p_i + p_j $ 和 $ p_i \times p_j $ 同为奇数或同为偶数，并把 $ p_i $ 和 $ p_j $ 替换成 $ p_i \times p_j $ ，这样， $ num = num + 1 $ ，其它没变，就可以使其有解了。

于是我们当一遍深搜做完并没有搜到解时，遍历一遍所有质因数，找到满足上述条件的两个质因数并替换（若没找到，就真的无解了），再做一遍深搜即可，若仍未搜到解，则无解。

加上上面的优化就可以过了，~~虽然不加也可以过……~~

下面是代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

int T,n,ret[1000005],cnt,sum,dul,num;
bool q;

void Prime (int x)  //分解质因数 
{
    cnt=0;
    for(int i=2;i<=x;i++)
    {
        while(x!=i)
        {
            if(x%i==0)
            {
                ret[++cnt]=i; 
                x=x/i;
            }
            else break;
        }
    }
    ret[++cnt]=x;
}

int abs (int x) 
{
    return x>0 ? x : -x;
}

void solve (int x)
{
    q=1;
    for (int i=1;i<=cnt;++i)
    {
        printf ("%d ",ret[i]);
    }
    for (int i=cnt+1;i<=n;++i)
    {
        if (x)
        {
            printf ("-1 ");
            --x;
        }
        else  printf ("1 ");
    }
    printf ("\n");
}

void dfs (int x)
{
    if (q)  return ;  //已有解 
    if (x>cnt)
    {
        int d=0-sum;
        if (abs(d)>num||((num-abs(d))&1))  return ;  //判断是否符合条件 
        if (d>0)  d=(num-d)/2;
        else  d=(num+d)/2-d;
        if ((dul<0&&(d&1))||(dul>0&&!(d&1)))  solve(d);
        return ;
    }
    if (x&1)  //优化 
    {
        sum+=ret[x];
        dul*=ret[x];
        dfs(x+1);
        sum-=(2*ret[x]);
        dul=-dul;
        ret[x]=-ret[x];
        dfs(x+1);
        ret[x]=-ret[x];
        sum+=ret[x];
        dul=((-dul)/ret[x]);
    }
    else
    {
        sum-=ret[x];
        dul*=(-ret[x]);
        ret[x]=-ret[x];
        dfs(x+1);
        ret[x]=-ret[x];
        sum+=(2*ret[x]);
        dul=-dul;
        dfs(x+1);
        sum-=ret[x];
        dul/=ret[x];
    }
}

int main ()
{
	scanf ("%d",&T);
    for (int i=1;i<=T;++i)
    {
        scanf ("%d",&n);
        Prime(n);
        if (ret[cnt]==n)
        {
            printf ("w33zAKIOI\n");
            continue;
        }
        num=n-cnt;  //记录1和-1有多少个 
        sum=0;
        dul=1;
        q=0;
        dfs (1);  //深搜+剪枝 
        if (!q)
        {
        	bool p=0;
            for (int j=1;j<cnt;++j)
            {
            	for (int k=j+1;k<=cnt;++k)
				{
					int x=ret[j]+ret[k],y=ret[j]*ret[k];
	                if ((x&1&&y&1)||(!(y&1)&&!(x&1)))  //没搜到，合并再搜一次 
	                {
	                	p=1;
	                    ret[j]=y;
	                    ret[k]=ret[cnt];
	                    --cnt;
	                    break;
	                }
				}
				if (p)  break;
            }
            if (!p)  //无法合并，无解 
            {
            	printf ("w33zAKIOI\n"); 
            	continue;
			}
            num=n-cnt;
            sum=0;
            dul=1;
            q=0;
            dfs (1);
            if (!q)  printf ("w33zAKIOI\n");
        }
    }
	return 0;
}
```


---

## 作者：Sparkle_ZH (赞：3)

## Description
+ 给定 $n$，构造一个长度为 $n$ 的序列，和为 $0$，积为 $n$，或者指出无解。
+ $1 \le n \le 10^6$，$1 \le \sum{n} \le 5\times10^6$，$1 \le T \le 10^5$，其中 $T$ 为数据组数。

## Solution
首先判断无解，容易发现 $n\bmod 4 = 0$，证明如下：

如果 $n$ 为奇数，则序列中所有数皆为奇数，于是和为奇数，矛盾，故 $n\bmod 2 = 0$。

设 $n = 2k$，易知序列中至少有 $1$ 个偶数，设其为 $2p$。

假如剩余的 $2k-1$ 个数都是奇数，那么和为 $2k-1$ 个奇数加 $2p$，为奇数，矛盾，故至少有 $2$ 个偶数。

$\therefore n\bmod 4 = 0$。

接着考虑构造，我们发现可以巧用 $1, -1$ 来抵消。

令 $q$ = $\frac{n}{4}$：

+ $q \bmod 2 = 0$：
  + $-2, -2q$ 来凑 $n$。
  + $3q$ 个 $1$，$q-2$ 个 $-1$ 来抵消。

+ $q \bmod 2 = 1$：
  + $2, -2q$ 来凑 $-n$。
  + $3q-2$ 个 $1$，$q$ 个 $-1$ 来抵消。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int T, n, k;

int main() {
	scanf("%d", &T);
	while (T--) {
		scanf("%d", &n);
		if (n%4 != 0) {
			printf("w33zAKIOI\n");
			continue;
		}
		
		k = n/4;
		
		if (k & 1) {
			printf("2 -%d ", k*2);
			for (int i = 1; i <= 3*k-2; i++)
				printf("1 ");
			for (int i = 1; i <= k; i++)
				printf("-1 ");
			printf("\n");
		} else {
			printf("-2 -%d ", k*2);
			for (int i = 1; i <= 3*k; i++)
				printf("1 ");
			for (int i = 1; i <= k-2; i++)
				printf("-1 ");
			printf("\n");
		}
	}
	
	return 0;
}
```

---

## 作者：Legitimity (赞：1)

比赛时在 Typora 上瞎推着式子结果就出来了（


------------


先给出一个结论，满足条件的 $N$ 一定至少有两个偶数因子，也就是 $N\mod 4=0 $。

证明：

设 $N=\prod^n_{i=1}a_i$，则 $\sum^n_{i=1}a_i=0$。

令 $N$ 为奇数，则它所有的因子也都是奇数，即 $a_1, a_2,\ldots,a_n $ 都是奇数，一共有 $N$ 个数，所以数字的个数也是奇数，奇数个奇数之和是奇数，即 $\sum^n_{i=1}a_i$ 为奇数，与 $\sum^n_{i=1}a_i=0$ 矛盾，不成立。

令 $N$ 只有一个偶数因子，不妨设这个偶数因子为 $a_1$，移项，得：$\sum^n_{i=2}a_i=-a_1$ ，$N$ 为偶数，则 $N-1$ 为奇数，奇数个奇数之和为奇数，即 $\sum^n_{i=2}a_i$ 为奇数，与 $\sum^n_{i=2}a_i=-a_1$ 矛盾，不成立。

所以 $N\mod 4=0$。

那么怎么说明当 $N\mod 4=0$ 时一定有解呢？

构造出解就行了（逃

令 $N=4k$，

若 $k$ 为奇数，则 $2\times (-2k)\times 1^{3k-2}\times (-1)^k=N $，$1+1+3k-2+k=N$，$2-2k+3k-2-k=0$，满足条件。

若 $k$ 为偶数，则 $(-2)\times (-2k)\times 1^{3k}\times (-1)^{k-2}=N$ ,$1+1+3k+k-2=N$，$-2-2k+3k-(k-2)=0$，满足条件。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define ll long long
#define inf 0x7f7f7f7f
#define mod 998244353
inline int read(){
	rg int ret=0,f=0;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-48;ch=getchar();}
    return f?-ret:ret;
}
int t,n;
int main(){
    t=read();
    while(t--){
    	n=read(); 
    	if(n%4) puts("w33zAKIOI"); //无解。
    	else{
    		int p=n/4;
    		if(p&1){   //根据 k 分类。
    			printf("%d %d ",2,-2*p);
    			for(rg int i=1;i<=3*p-2;++i) putchar('1'),putchar(' ');
    			for(rg int i=1;i<=p;++i) putchar('-'),putchar('1'),putchar(' ');
    		}else{
    			printf("%d %d ",-2,-2*p);
    			for(rg int i=1;i<=3*p;++i) putchar('1'),putchar(' ');
    			for(rg int i=1;i<=p-2;++i) putchar('-'),putchar('1'),putchar(' ');
    		}
    		putchar('\n');
    	}
    }
    return 0;
}
//My bones are titanium,but my heart is made of stars
```


---

## 作者：_SkyBlue (赞：1)


假令 $n$ 为奇数，那么所有 $a_i$ 都是奇数，$a_i \equiv 1 \pmod 2$，$\sum a_i \equiv n \equiv 1 \pmod 2$，不符合题意。

同理，当 $n$ 为 $2(2k+1)$（$k$ 为正整数）时，令 $a_1=2$，则对于 $\forall i$ 满足 $2 \le i \le n$，$\sum_{i=2}^n a_i \equiv 2(2k+1)-1\equiv1\pmod2 $，$\sum a_i\equiv1\pmod2$，仍然不满足条件。

所以 $n\equiv0\pmod4$。

这是一个无界定的构造。如果 $n$ 满足条件，平凡情况下我们用 $-1$ 与 $1$ 去构造。（为什么？留给读者自己思考。）

下面给出简要的构造方案。读者不难证明正确性。

$n\equiv0\pmod8$ 时，$2$，$\dfrac{n}{2}$，$-1$，$\cdots$，$-1$（$\dfrac{n}{2}+2$ 个），$1$，$-1$，$\cdots$，$1$，$-1$（$\dfrac{n}{2}-4$ 个）

$n\equiv4\pmod8$ 时，$-2$，$\dfrac{n}{2}$，$-1$，$\cdots$，$-1$（$\dfrac{n}{2} - 2$ 个），$1$，$-1$，$\cdots$，$1$，$-1$（$\dfrac{n}{2}$ 个）

另，个人认为这题不应该多组询问。输出量本来就很大。

```cpp
#define _for(x) for(int i=1;i<=x;i++)
int main() {
  int T,n;cin>>T;
  while(T--){
    cin>>n;if(n%4!=0){cout<<"w33zAKIOI";}
    else if(n%8==0){
      cout<<2<<" "<<n/2<<" ";
      _for(n/2+2)cout<<-1<<" ";
      _for(n/4-2)cout<<1<<" "<<-1<<" ";
    }else if(n%8==4){
      cout<<-2<<" "<<n/2<<" ";
      _for(n/2-2)cout<<-1<<" ";
      _for(n/4)cout<<1<<" "<<-1<<" ";
    }
    cout<<endl;continue;
  }
}
```

---

## 作者：InformationEntropy (赞：1)

题意：

对于整数 $n$，构造出一个方案使得 $n$ 个数的和为 0，积为 $n$ 。

由于和为 0，故 $n$ 个数中必可分为正数和负数两个部分，所有正数绝对值的和等于所有负数绝对值的和且所有数必是 $n$ 的因数（可正可负）和若干个 $1(-1)$。

可以借助分类讨论来分析这个问题：

当 $n$ 为奇数时，所分解的因数也必定是奇数，设将其分成 $k$ 个因数相乘，其中 $a$ 个为正数，$k-a$ 个为负数，为使正负和的绝对值相等需要补充 $m$ 个 $1(-1)$，剩余的位置放入若干对 $1,-1$ 凑数。

- $k$ 为奇数，$a$ 和 $k-a$ 必为一奇一偶（奇+奇=偶，偶+偶=偶），正负和的绝对值也必为一奇一偶（奇数个奇数相加为奇数，偶数个奇数相加为偶数），则 $m$ 必为奇数（奇与偶差为奇），最终 $n-k-m$ 为奇数，无法成对放入 $1(-1)$，舍去。

- $k$ 为偶数，$a$ 和 $k-a$ 为两偶或两奇，正负和的绝对值为也为两偶或两奇，则 $m$ 为偶数（两偶之差或两奇之差均为偶数）,最终 $n-k-m$ 亦为奇数，舍去。

即当 $n$ 为奇数时，不存在一种满足要求的构造方案。

再看当 $n$ 为偶数时。首先，可以轻易想出两种方案，即可将 $n$ 分为 $\dfrac{n}{2}$ 和 $-2$ 两个因数，加入 $|\dfrac{n}{2}-2|$ 个 $1(-1)$，剩余填入 $\dfrac{n}{4}$ 对 $1,-1$ 凑数。当且仅当 $n \bmod4=0,\dfrac{n}{4}\bmod2=1$ 时才能保证可分解且乘积为正。

或将 $n$ 分为 $-\dfrac{n}{2},-2$ ，加入 $2+\dfrac{n}{2}$ 个 $1$，剩余填入 $\dfrac{n}{4}-2$ 对 $1,-1$ 凑数，当且仅当 $n\bmod8=0$ 时可保证能分解且乘积为正。

现在，只需判断 $n\bmod4\not=0$ 时是否可构造即可。
这种情况下可将其分解为 $2$ 和 $k$ 个奇数，并补充 $m$ 个 $1(-1)$ 。不妨仿照上述 $n$ 为奇数的过程先忽略 $2$ 处理 $k$ 个奇数的正负。由上文知：

- $k$ 为奇，正负和绝对值为一奇一偶，这时将 $2$ 归入正数或负数，对正负和的绝对值无影响（奇加偶为奇，偶加偶为偶），$m$ 也为奇数。$n-1-k-m$ 为奇，无法分出成对的 $1,-1$。

- $k$ 为偶，正负和绝对值为两奇或两偶，将 $2$ 归入正或负时，正负和绝对值无改变，$m$ 依旧为偶，$n-1-k-m$ 为奇，不成立。

结论：当且仅当 $n\bmod 4=0$ 时，存在构造方案。由于输出大部分都为 $1(-1)$，可用倍增输出优化。

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template<class T>inline void read(T &x)
{
    char c=getchar();x=0;bool f=0;
    for(;!isdigit(c);c=getchar()) f^=!(c^45);
    for(;isdigit(c);c=getchar()) x=x*10+(c^48);
    if(c=='.')
    {
        c=getchar();
        db w=10;
        for(;isdigit(c);c=getchar())
        {
            x+=db(c^48)/w;
            w*=10;
        }
    }
    if(f)x=-x;
}//快读
void print(int x, int m)//m为模式
{
    string s;
    if(m==0) s="1 ";
    else s="1 -1 ";//成对输出
    while(x)
    {
        if(x&1)
        {
            cout << s;
        }
        x>>=1;
        s=s+s;
    }
}//这里是倍增输出，将输出数量二进制分解，输出的同时扩大 s 的长度。
int main()
{
    int t;
    read(t);
    while(t--)
    {
        int n;
        read(n);
        if(n<=1)
        {
            cout << "w33zAKIOI\n";
            continue;
        }
        if(n%2==1)
        {
            cout << "w33zAKIOI\n";
            continue;
        }
        if(n%4!=0)
        {
            cout << "w33zAKIOI\n";
            continue;
        }
        if(n/4%2==1)
        {
            cout << 2 << " " << -n/2 << " ";
            print(n/2-2, 0);
            print(n/4, 1);//方案一构造
        }else{
            cout << -2 << " " << -n/2 << " ";
            print(2+n/2, 0);
            print((n/2-4)/2, 1);//方案二构造
        }
        cout << "\n";
    }
    return 0;
}
```



---

## 作者：Kacho (赞：1)

看题目的第一眼，一个思路清晰的构造题。

因为有Special Judge，所以说不一定要按照样例的输出来输出，那这下子就简单了。

## 题意：

这道题其实很简单， $T$ 个数据，每次给你一个 $n$ ，然后用 $n$ 数所组成的数列对这个数进行表示，要求是数列中的所有数字之和为 0 ，乘积为 $n$。
如果可表示，那么输出一种情况，如果不可以，请输出“w33zAKIOI”。

## 特判：

我们要先判断一下这个 $n$ 如果可以被拆分，那么它一定是 4 的倍数。让我们现来证明一下这个东西。

首先，如果这个数为奇数，那么也就是说，想要这个数列中的所有数的和为 0 的话，一定存在一个数为 0 ，那么此时乘积一定为 0。


但是 乘积是数列中数的个数，不可能为 0 ，所以这个 $n$ 不可能是奇数。

那么，我们可以假设这个 $n = 2k$ 那么此时由于数列中的每个数乘积是 $n$ 为偶数，那么假设存在一个 $n = 2p \times \frac {k} {p}$。

那么此时，数列中就还存在 $2 \times k - 1$ 个数，此时这 $2 \times k - 1$ 个数，我们假设全部都是奇数，那么此时，显然 $2 \times k - 1$ 个整数和 $2p$ 的和是一个奇数，与 $n$ 是一个偶数相悖，所以我们可以知道这 $2 \times k - 1$ 个数之中，至少还有一个偶数，我们将其记作 $2q$。

那么此时，显然 $n = 2 \times q \times 2 \times p \times \frac {k} {p \times q}$ ，那么此时显然 $n$ 可以被 4 整除。

以上，证毕。

## 构造：

现在我们知道了 $n$ 是一个 4 的倍数，那么此时， 我们就要进行构造了。

关于我的构造的话，挺简单的，就是把一个数（记作 $x$ ），将其分作 -2 或者 2 和另一个数 $y$ 的乘积。

因为我在对于是否为 4 的倍数的特判之后加入了一步，所以，我之后会判断是否为 2 的倍数，但是 我们还是以 8 进行讲述。上一下代码：
```cpp
if(x % 4 != 0){
   printf("w33zAKIOI\n");
   continue;
}        
x /= 4;//这一段是对是否为 4 的倍数进行了特判，如果不是，下一组数据
```

$x$ 为 4 的倍数， 要分为
```cpp
1、x % 8 == 4
2、x % 8 == 0
```
为什么要这么分呢？因为如果一个数是 8 的倍数的话，此时，我们要是对其进行一个考虑，因为有些数它是 4 的倍数，但是它不是 8 的倍数。

那么这个时候我们就需要对这个数进行一个操作了：
```cpp
x /= 4;
```
为什么呢？

因为我们知道，如果是 8 的倍数并且不是 4 的倍数，我们如果把这个数除以 4， 那么这时，这个数它一定不是 2 的倍数。

下面给出一种情况的构造说明，这时我们只需要做这一步：
```cpp
if(x % 2 == 0){
   printf("%d %lld ", -2, -2 * x);
   for(int i = 1; i <= x * 3; i++) printf("1 ");
   for(int i = 1; i <= x - 2; i++) printf("-1 ");
   printf("\n");
}
```

这个就是我们提到的构造了。

为什么要这么进行构造呢？首先我们已经证明了 $n$ 一定会是 4 的倍数，倘若这时，这个数也是 2 的倍数的话，我们可以发现一个显然的事实，这个数可以被拆分为 -2 与 $\frac {-x}{2}$ 的乘积，这时候我们 用一个 $sum$ 来暂时作为和的统计（代码中不会出现）。

此时的 $sum$ 显然等于 $\frac {-n}{2} - 2$ ，那么这时，我们还需要输出的数就有 $n - 2$ 个,为了做到数列中的所有数的和为零，显然我们的所有负数的和的绝对值是 $\frac {3n}{4}$ 。那么我们就还需要输出 $x - 2$ 个 -1。同样的对于 1 来说就还有 $3 \times x$ 个。

这样子，当 $x$ 是 4 的倍数，而不是 8 的倍数的情况就被讨论完了，接着就是另一种情况了，不做详细分析，因为实质只是把正负情况改了一点，一点最重要的依旧没变：

此时的 $sum$ 显然等于 $\frac {-n}{2} - 2$ ，那么这时，我们还需要输出的数就有 $n - 2$ 个,为了做到数列中的所有数的和为零，显然我们的所有负数的和的绝对值是 $\frac {3n}{4}$。
 
现在放上 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

signed main (){

    int T;
    scanf("%d", &T);
    while(T--){
        long long x;
        scanf("%lld", &x);
        if(x % 4 != 0){
            printf("w33zAKIOI\n");
            continue;
        }        
        x /= 4;
        if(x % 2 == 0){
            printf("%d %lld ", -2, -2 * x);
            for(int i = 1; i <= x * 3; i++) printf("1 ");
            for(int i = 1; i <= x - 2; i++) printf("-1 ");
            printf("\n");
        }
        else{
            printf("%d %lld ", 2, -2 * x);
            for(int i = 1; i <= x * 3 - 2; i++) printf("1 ");
            for(int i = 1; i <= x; i++) printf("-1 ");
            printf("\n");
        }
    }

    return 0;

}
```

---

## 作者：xfrvq (赞：0)

[P7567 「MCOI-05」魔仙](/problem/P7567)

[可能更好的阅读体验](/blog/368107/solution-p7567)

---

### 题意

给定一个 $n$ ，让你构造出一个 $a$ 数组，使得

$\prod_{i=1}^{i\leqslant n}a_i=n$

且

$\sum_{i=1}^{i\leqslant n}a_i=0$

如果构造不出来，输出 `w33zAKIOI`

---

### 解法

一道数学题。~~显然是这个菜鸡的弱项~~

---

#### $\text{Part 1}$

证明 $n$ 必定为 $4$ 的倍数：

如果 $n$ 不是 $2$ 的倍数，于是 $a_1,a_2,\cdots,a_n$ 都是奇数（只有奇数相乘才能得到奇数），它们的和就是奇数个奇数，一定是奇数，就不可能是0

如果 $n$ 是 $2$ 的倍数，但不是 $4$ 的倍数，则 $a_1,a_2,\cdots,a_n$ 中有  $1$ 个奇数， $n-1$ 个偶数，它们的和等于奇数个偶数加奇数，结果应是奇数，不可能是 $0$ 

如果 $n$ 不是 $4$ 的倍数，输出 `w33zAKIOI`

---

#### $\text{Part 2}$

构造方案：

由于 $n$ 是 $4$ 的倍数，设 $n=4k$

如果 $2\mid k$ ，构造为

$$2,-2k,1^{3k-2},-1^k$$

和为 $0$ 且积为 $n$

如果 $2\nmid k$ ，构造为

$$-2,-2k,1^{3k},-1^{k-2}$$

和为 $0$ 且积为 $n$

---

#### [$\color{#52C41A}\texttt{AC CODE}$](https://www.luogu.com.cn/record/51105786)

```cpp
#include<stdio.h>
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		int n;
		scanf("%d",&n);
		if(n & 3) puts("w33zAKIOI"); // 位运算判断是不是4的倍数
		else{
			int k = n >> 2; // 位运算，等于除4
			if(k & 1){ // 位运算判断是不是2的倍数
				printf("%d %d",2,-2 * k);
				for(int i = 1;i <= 3 * k - 2;++i) printf(" 1");
				for(int i = 1;i <= k;++i) printf("-1");
				printf("\n");
			} else {
				printf("%d %d",-2,-2 * k);
				for(int i = 1;i <= 3 * k;++i) printf(" 1");
				for(int i = 1;i <= k - 2;++i) printf(" -1");
				printf("\n");
			}
		} 
	}
	return 0;
}

```

---

## 作者：Cocoly1990 (赞：0)

题意简述：构造长度为$n$的序列使
$\sum\limits_{i=1}^na_i=0,\prod\limits_{i=1}^na_i=n$

首先这么想，必然有 $2\mid n$. 为什么呢，因为如果 $2\nmid n$，那么这$n$个数应该都是奇数，**那么他们的和一定是奇数，不为**$0$ 

所以$n$一定是偶数，又如果这$n$个数中**奇数偶数的个数分别是奇数个**，那么和一定是奇数，所以有偶数个偶数

**所以有**$4\mid n$

然后设$n=4a$，就可以构造序列了，构造的话不会很难，但注意要分$a$的奇偶情况讨论，还有就是序列的长度为$n$.

给出一种构造

$2\mid a$时 序列为$2\times 2k\times 1^{k-2} \times (-1)^{3k+2}$

$2\nmid a$时 序列为$2\times (-2k)\times 1^{3k-2} \times (-1)^{k}$

构造证明从略，代码很好写

---

## 作者：Fidel (赞：0)

## 解法：搜索 + 打表 + 观察数据法

~~数论？不存在的~~

## 题意简述

输出一个有 $n$ 个项的**整数**序列 $a_1, a_2, \ldots,a_n$，使得：

$$ \sum_{i=1}^{n}a_i = 0, \space \prod_{i=1}^{n}a_i=n $$

若无解，输出 `w33zAKIOI`。

共 $T$ 组询问。$1 \leq n \leq 10^6$，
$\sum n \leq 5 \times 10 ^ 6$，$1 \leq T \leq 10^5$。

## 解法

### 25 pts

对 $n$ 分解质因数，搜索**乘积**组成 $n$ 的可能的方式，**需要考虑正负数**。若不足 $n$ 个因数则**补上若干个 $1$ 或 $-1$**。

由于 $1 \leq n \leq 10^6$，故 $n$ 的质因数个数不会超过 $\lceil\log_{2}10^6\rceil = 20$，可以**用一个 `int` 标记每个质因数是否使用**。

搜索时记录当前的和 $sum$ 与乘积 $prod$。

当所有质因数都被使用时，使用 `check` 函数判断答案合法性：

- 若 $|prod| \neq n$，答案不合法。

- 若 $|sum| > n - d$，即不可能补不超过 $n-d$ 个 $1$ 或 $-1$ 使得 $sum = 0$，答案不合法。

利用**贪心**的思想，对剩下 $(n-d)$ 个质因数补上 $1$ 或 $-1$：

- 若 $sum=0$，只需要考虑使 $prod=n$，即 $prod$ 为**正数**:

  - 若 $prod<0$，即 $prod$ 为负数，补上 $-1$ 使得符号反转；

  - 反之，若 $prod>0$，补上 $1$。

- 若 $sum \neq 0$，考虑使 $sum$ 向 $0$ 靠近：

  - 若 $sum<0$，补上 $1$；

  - 反之，若 $sum>0$，补上 $-1$；

最后判断是否满足 $sum = 0, \space prod = n$ 即可。

```cpp
bool check(int d, int sum, int prod) {
    if (abs(prod) != n) return false;
    if (abs(sum) > n - d) return false;
    for (int i = d + 1; i <= n; i++) {
        if (sum == 0)
            fact[i] = prod < 0 ? -1 : 1;
        else
            fact[i] = sum > 0 ? -1 : 1;
        sum += fact[i], prod *= fact[i];
    }
    return (sum == 0 && prod == n);
}

bool dfs(int x, int d, int used, int sum, int prod) {
    if (d != 0) fact[d] = x, sum += x, prod *= x;
    if (used == full) return check(d, sum, prod);

    for (int add = full ^ used; add;
         add &= add - 1) {  // 位运算小技巧，遍历未使用的质因数组合
        int newfact = 1;
        for (int j = 0, t = add; t; j++) {
            if (t & 1) newfact *= prime[j];
            t >>= 1;
        }
        if (dfs(newfact, d + 1, used | add, sum, prod)) return true;
        if (dfs(-newfact, d + 1, used | add, sum, prod)) return true;
    }
    return false;
}

bool solve() {
    if (n & 3) return false;

    fcnt = 0;
    memset(prime, 0, sizeof(prime));
    memset(fact, 0, sizeof(fact));

    for (int i = 2, t = n; i <= t; i++)
        while (t % i == 0) {
            t /= i;
            prime[fcnt++] = i;
        }

    full = (1 << fcnt) - 1;
    return dfs(0, 0, 0, 0, 1);
}
```

此方法可以得到 25 分（最后一个点 TLE）。

### 100 pts

使用上面的程序打表，得到数据：

（为方便观察对输出格式进行了一些修改）

```plain
n=1: No Solution
n=2: No Solution
n=3: No Solution
n=4: 2 -2 -1 1 
n=5: No Solution
n=6: No Solution
n=7: No Solution
n=8: 4 2 -1 -1 -1 -1 -1 -1 
n=9: No Solution
n=10: No Solution
n=11: No Solution
n=12: 6 -2 -1 -1 -1 -1 -1 1 1 -1 -1 1 
n=13: No Solution
n=14: No Solution
n=15: No Solution
n=16: 8 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 1 
......
```

可以发现，当且仅当 $n$ 为 $4$ 的倍数时**有解**。

继续观察数据，对于有解的情况：

- 第 $1$ 个数为 $\dfrac{n}{2}$；

- 若 $n$ 为 8 的倍数，第 $2$ 个数为 $2$，否则为 $-2$。

- 接下来 $(n-2)$ 个数为若干个 $1$ 和 $-1$。

  这些 $1$ 和 $-1$ 可以用上面提到的方法求出。

  当然，也不难直接算出 $1$ 的个数（见代码）。

```cpp
void solve(int n) {
    if (n & 3) {  // n % 4
        puts("w33zAKIOI");
        return;
    }
    int a = n >> 1;
    int b = n & 7 ? -2 : 2;  // n % 8
    int t = a + b;
    printf("%d %d ", a, b);
    for (int i = 0; i < t; i++) printf("-1 ");
    for (int i = 2 + t; i < n; i += 2) printf("-1 1 ");
    putchar('\n');
}
```


---

## 作者：信守天下 (赞：0)

## [洛谷传送门](https://www.luogu.com.cn/problem/P7567)
## 思路
这是一道数学题，推式子可以分成两部分。

- 证明如果有解， $n$ 一定是 $4$ 的倍数。

- 构造方案。

### 证明： $n$ 一定是 $4$ 的倍数。
设 $n$ 个整数为 $a_1$ ，$a_2$ ，… ，$a_n$。

由题意得， $a_1a_2...a_n = n$ ， $a_1 + a_2 + ... + a_n = 0$ 。

如果 $n$ 为奇数，那么 $a_1$ ，$a_2$ ，... ，$a_n$ 均为奇数。

于是 $a_1 + a_2 + ... + a_n$ 是奇数个奇数的和，不可能为 $0$ 。

所以 $n$ 必为偶数，从而 $a_1$ ，$a_2$ ，...，$a_n$ 中至少有一个是偶数。

又若 $a_1$ ，$a_2$ ，... ，$a_n$ 中只有一个偶数，设为 $a_1$ 。

则 $a_2$ + $a_3$ + ... + $a_n$ 是奇数个（ $n - 1$ 个）奇数之和，故必为奇数。

从而 $a_1 + a_2 + ... + a_n$ 是奇数，与 $a_1 + a_2 + ... + a_n = 0$ 矛盾。

故 $a_1 ，a_2 ，... ，a_n$ 中至少有两个偶数，所以 $n = a_1a_2...a_n$ 能被4整除。

### 构造方案
设 $n = 4k$ 。

当 $k$ 为奇数时，$n = 2 \times (-2k) \times 1^{3k-2} \times(-1)^k$ 。

而 $2 , -2k , (3k-2)$ 个 $1$ 与 $k$ 个 $-1$ 共 $4k$ 个数之和为 $0$ 。

当 $k$ 为偶数时，$n = (-2) \times(-2k) \times 1^{3k} \times(-1)^{k-2}$ 。

而 $-2$ ， $-2k$ ，$3k$ 个 $1$ 与 $(k-2)$ 个 $-1$ 共 $4k$ 个数之和为 $0$ 。

## $code$
~~~cpp
#include <algorithm>
#include <iostream>
using namespace std;
int t, n;
int main() {
  cin >> t;
  while (t--) {
    cin >> n;
    if (n % 4 != 0) {
      cout << "w33zAKIOI" << endl;
      continue;
    }
    int k = n / 4;
    if (k & 1) {
      cout << 2 << " " << -2 * k;
      for(int i = 1 ; i <= 3 * k - 2 ; i++){
        cout << " " << 1;
      }
      for (int i = 1; i <= k; i++) {
        cout << " " << -1;
      }
      cout << endl;
    } else {
      cout << -2 << " " << -2 * k;
      for (int i = 1; i <= 3 * k; i++) {
        cout << " " << 1;
      }
      for (int i = 1; i <= k - 2; i++) {
        cout << " " << -1;
      }
      cout << endl;
    }
  }
  return 0;
}
~~~

---

## 作者：芝麻xxxx (赞：0)

## P7567 魔仙 题解

[原题链接](https://www.luogu.com.cn/problem/P7567) $\;$ [博客链接](https://www.luogu.com.cn/blog/xxxx-LuoguOJ/p7567-ti-xie)

### 题目概述

- 来源：[【LGR-085】洛谷 5 月月赛 & MCOI Round 5](https://www.luogu.com.cn/contestnew/show/30514)，[B 题](https://www.luogu.com.cn/problem/P7567)

- 分类： 构造题

- 给定 $n$，求一个有 $n$ 个整数的序列，使得各个数字之和为 $0$， 之积为 $n$。

### 题解概要

- 首先，将 $n$ 表示为 $n$ 个正整数之积；
- 通过列出较小的 $n$ 的构造方案，发现存在合法构造的必要条件是这 $n$ 个正整数的和为偶数，并以此排除 $4k+1,4k+2,4k+3$ 型整数；
- 在剩下的 $4k$ 型整数中，根据 $n$ 除以 $8$ 所得余数进行分类讨论，得到正解。

### 题解正文

打开题目，看了看条件：各个数字之和为 $0$， 之积为 $n$。

两个条件同时满足有些困难，我们应该用其中一个条件作为突破口。显然是先用后者更方便。因此，**考虑先将 $n$ 拆成 $n$ 个正整数之积**。这里拆得越小越好，可以为之后的合并（合并，即把拆得的 $a,b$ 两个数替换为 $ab,1$，积不变）做准备。满足积为 $n$ 后，只需进行适当的合并，调整各个数字的符号，把和凑成 $0$ 即可。

接着，可以举 $1-4$ 的整数为例找规律：

$1=1$

$2=2\times 1$

$3=3\times 1\times 1$

这三者显然就不行。因为给数字添上正负号使总和为 $0$， 本质上就是把这 $n$ 个数字分为正、负两组，使得两组数字的和相等。而上面三个数字经过拆分所得的数字总和分别为 $1,3,5$，都是奇数，自然就无法拆成数字和相等的两部分。更进一步，我们就得到了存在合法构造的必要条件：**将 $n$ 拆成 $n$ 个正整数之积后，这 $n$ 个正整数的和为偶数**。

继续举例：

$4=2\times 2\times 1\times 1=2\times(-2)\times 1\times(-1)\quad$ 成立

若将 $2\times 2$ 合并为 $4\times 1$，则：

$4=4\times 1\times 1\times 1\quad$ 不行（理由同上）

可以发现，将拆得的数字合并，可能改变这 $n$ 个正整数的和的奇偶性。具体而言，设 $a,b$ 为合并前的两个数，合并后得到 $ab,1$，则：

- 若 $a,b$ 都是奇数，则合并前 $a+b$ 为偶数，合并后 $ab+1$ 也为偶数，奇偶性不变；
- 若 $a,b$ 一奇一偶，则合并前 $a+b$ 为奇数，合并后 $ab+1$ 也为奇数，奇偶性不变；
- 若 $a,b$ 都是偶数，则合并前 $a+b$ 为偶数，合并后 $ab+1$ 为奇数，奇偶性改变；

可以看出，**当且仅当 $a,b$ 皆为偶数时，合并 $a,b$ 能改变总和的奇偶性**。由 $a,b$ 皆为偶数，可以推知 $n$ 是 $4$ 的倍数。根据这点，我们可以**将正整数分为 $4k,4k+1,4k+2,4k+3$ 四类进行讨论**：

- 当 $n$ 为 $4k+1,4k+3$ 型数时，拆成的 $n$ 个数都是奇数，总和是奇数，且无论怎样合并都无法改变总和的奇偶性，故可以排除；
- 当 $n$ 为 $4k+2$ 型数时，拆成的 $n$ 个数中包含 $1$ 个 $2$ 与 $n-1$ 个奇数，总和也是奇数，且无论怎样合并都无法改变总和的奇偶性，故可以排除；
- 当 $n$ 为 $4k$ 型数时，可以通过合并两个偶数改变总和的奇偶性，可能形成合法序列；

对于 $n=4k$ 的情况，可以尝试构造。不难发现，$\dfrac{n}{4}$ 的奇偶性对构造方案有影响，**故将 $n$ 分为 $8k,8k+4$ 两类讨论构造的方案**：

- 当 $n$ 为 $8k$ 型数时，拆成 $2\times 2\times \dfrac{n}{4}$ 会使总和为奇数，故合并 $2,\dfrac{n}{4}$ 为 $\dfrac{n}{2},1$。接着，假定 $2$ 与 $\dfrac{n}{2}$ 之前的符号都为正，调整后面一大串 $1$ 的符号可得：

$$ \begin{matrix}\quad\quad\quad\quad\frac{3n}{4}\quad\quad\quad\quad\quad\quad\frac{n}{4}-2\\\dfrac{n}{2}+2+\overbrace{(-1)+\cdots+(-1)}+\overbrace{1+\cdots+1}=0\end{matrix}$$

按照相同的方法，可以得到：

- 当 $n$ 为 $8k+4$ 型数时，
$$ \begin{matrix}\quad\quad\quad\quad\frac{3n}{4}-2\quad\quad\quad\quad\quad\quad\frac{n}{4}\\\dfrac{n}{2}+(-2)+\overbrace{(-1)+\cdots+(-1)}+\overbrace{1+\cdots+1}=0\end{matrix}$$

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
    return x;
}
int main(){
    int t=read();
    for(int i=1;i<=t;i++){
        int n=read();
        if(n%8==0){
            printf("%d 2 ",n/2);
            for(int j=1;j<=n/4*3;j++) printf("-1 ");
            for(int j=1;j<=n/4-2;j++) printf("1 ");
        }
        else if(n%8==4){
            printf("%d -2 ",n/2);
            for(int j=1;j<=n/4*3-2;j++) printf("-1 ");
            for(int j=1;j<=n/4;j++) printf("1 ");
        }
        else printf("w33zAKIOI");
        printf("\n");
    }
    return 0;
}
```










---


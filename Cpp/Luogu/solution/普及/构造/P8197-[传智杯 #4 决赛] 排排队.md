# [传智杯 #4 决赛] 排排队

## 题目描述


cyq 在 tsyz 担任了体育老师，负责排队一事。

在 tsyz 中，每个人都有一个身高 $a_{i}$，并且只有**相邻**的两个人可以交换位置。cyq 带领的队伍有 $n$ 个人,他现在要给大家排队形。

给定一个长度为 $n$ 的序列 $b$，一个队形被认为美观，当且仅当对于所有的 $i = 1, 2, 3, \dots n$，$a_{i} =b_{i}$。cyq 想知道，他能否让大家的队形变得美观，并且交换相邻两个人的次数不超过 $n^2$ 次。这个问题把 $cyq$ 难住了，请你帮他来解决这个问题，如果存在合法的交换方案，输出 `YES`，并给出一组方案；否则，输出 `NO`。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1\leq T \leq 10$，$1\leq n \leq 10^3$，$1\leq a_{i},b_{i}\leq 10^9$，且各个测试点 $n$ 之和不超过 $1000$，即 $\sum n\leq 10^3$。

### 提示
- 请注意大量的输出输出对程序效率造成的影响，不要频繁刷新缓冲区。例如，对于使用 `std::cout` 的 C++ 选手，请使用 `'\n'` 而不是 `std::endl` 来换行；对于 java 选手，请选择高效率的输出方式，如使用 PrintWriter；python 选手可以正常的使用 print 而无需考虑效率问题。
- 请按照输出格式的要求输出您的答案，如果格式不符合要求，返回的评测信息将可能是 TLE、RE、WA、UKE 等任何结果。

### C++ 语言的高效输出样例
```cpp
#include <iostream>
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  for (int i = 1; i <= 5; ++i) {
    std::cout << i << '\n'; // 注意这里不能使用 std::endl
  }
}
```

### Java 语言的高效输出样例
```java
import java.io.PrintWriter;

public class Main {
  public static void main(String[] args) {
    PrintWriter ot = new PrintWriter(System.out);
    for (int i = 1; i <= 5; ++i) {
      ot.println(i);
    }
    ot.flush(); // 请务必保证在程序结束时运行本条语句，否则在缓冲区的内容无法输出
  }
}

## 样例 #1

### 输入

```
3
4
1 2 2 3
3 2 2 1
3
1 2 3
1 2 4
1
1
1
```

### 输出

```
YES
4 3
2 3
1 2
3 2
3 4
0 0
NO
YES
0 0
```

# 题解

## 作者：一扶苏一 (赞：13)

## C. 排排队

**题意**：给定两个长度为 $n$ 的序列 $a, b$，每次操作只能交换 $a$ 中相邻两个数，求能否在 $n^2$ 次操作内使 $a, b$ 相同，如果可以则构造方案。

$1 \leq n \leq 10^3$，$1 \leq a_i, b_i \leq 10^9$。

**关键词**：构造，选择排序，冒泡排序。

**参考难度**：橙/黄。

**分析**：考虑如果存在一个数 $x$，满足 $x$ 在 $a, b$ 内的出现次数不同，则显然无解。换句话说，如果 $a, b$ 都从小到大排序以后不同，则无解，因此可以先用另一个数组对二者排序，判掉这种情况。

考虑判掉无解以后的情况构造有解的方法：使用类似选择排序的方法，从 1 到 $n$ 枚举 $i$，若 $a_i \neq b_i$，则在 $i$ 后面找到一个 $j$ 满足 $a_j =b_i$，然后交换 $(j, j -1), (j - 1, j - 2), \dots (i + 1, i)$，这样就可以把 $j$ 交换到 $i$。

对于每个 $b_i$ 找到对应的 $j$ 是一个类似选择排序的过程，因此这一步是单次 $O(n)$ 的；将 $j$ 交换到 $i$ 是一个类似冒泡排序的过程，对于每个 $i$，交换的过程也是 $O(n)$。注意这两部分是相互独立的，因此时间复杂度是相加而不是相乘。枚举 $i$ 还有 $O(n)$ 的复杂度，因此总的复杂度是 $O(n^2)$。

考虑交换的次数：显然对于一个 $i$，其交换次数不会超过 $n$，因此总的交换次数不超过 $n^2$。更精细的分析可以发现交换次数的上界是 $\frac{n(n - 1)}{2}$。因为交换是一个类似冒泡排序的过程，因此也可以套用冒泡排序的理论，得到总交换次数不超过 $n^2$ 的结论。

(C++)

```cpp
#include <array>
#include <iostream>
#include <algorithm>

const int maxn = 1005;

std::array<int, maxn> a, b, c, d;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  int T, n;
  for (std::cin >> T; T; --T) {
    std::cin >> n;
    a.fill(0); b.fill(0);
    for (int i = 1; i <= n; ++i) std::cin >> a[i];
    for (int i = 1; i <= n; ++i) std::cin >> b[i];
    c = a; d = b;
    std::sort(c.begin(), c.end());
    std::sort(d.begin(), d.end());
    if (c != d) {
      std::cout << "NO\n";
    } else {
      std::cout << "YES\n";
      for (int i = 1; i <= n; ++i) if (a[i] != b[i]) {
        for (int j = i; j <= n; ++j) if (a[j] == b[i]) {
          for (int k = j; k > i; --k) {
            std::swap(a[k], a[k - 1]);
            std::cout << k << ' ' << k - 1 << '\n';
          }
          break;
        }
      }
      std::cout << "0 0\n";
    }
  }
}
```

(java)

```java
import java.util.Scanner;
import java.util.Arrays;
import java.io.PrintWriter;

public class Main {
  public static void main(String[] args) {
    Scanner cin = new Scanner(System.in);
    PrintWriter out = new PrintWriter(System.out);
    for (int T = cin.nextInt(); T != 0; --T) {
      int n = cin.nextInt();
      int[] a = new int[n], b = new int[n], c = new int[n], d = new int[n];
      for (int i = 0; i < n; ++i) {
        c[i] = a[i] = cin.nextInt();
      }
      for (int i = 0; i < n; ++i) {
        d[i] = b[i] = cin.nextInt();
      }
      Arrays.sort(c);
      Arrays.sort(d);
      boolean flag = true;
      for (int i = 0; i < n; ++i) if (c[i] != d[i]) {
        flag = false; break;
      }
      if (flag == false) {
        out.println("NO");
      } else {
        out.println("YES");
        for (int i = 0; i < n; ++i) if (a[i] != b[i]) {
          for (int j = i + 1; j < n; ++j) if (a[j] == b[i]) {
            for (int k = j; k > i; --k) {
              out.println((k + 1)+ " " + k);
              int t = a[k]; a[k] = a[k - 1]; a[k - 1] = t;
            }
            break;
          }
        }
        out.println(0 + " " + 0);
      }
    }
    out.flush();
  }
}
```

(Python)

```python
T = int(input())
for t in range(T):
  n = int(input())
  a = list(map(int, input().split()))
  b = list(map(int, input().split()))
  c, d = list(), list()
  for i in a:
    c.append(i)
  for i in b:
    d.append(i)
  c.sort()
  d.sort()
  if c != d:
    print("NO")
  else:
    print('YES')
    for i in range(0, n): 
      if a[i] != b[i]:
        for j in range(i, n):
          if (a[j] == b[i]):
            k = j
            while (k != i):
              print(k, k + 1)
              a[k], a[k - 1] = a[k - 1], a[k]
              k -= 1
            break
    print(0, 0)
```

---

## 作者：沉石鱼惊旋 (赞：8)

### 题目思路

从交换相邻这里，我们可以明显看出来，这有些类似冒泡排序。

但是，我们要来思考一下怎样情况输出 `NO`。

我们就用冒泡排序的代码来分析一下。为了方便分析，就用 `for` 循环版的。

```cpp
for(int i=1;i<=n-1;i++)
{
	for(int j=1;j<=n-i;j++)
	{
		if(a[j]<a[j+1])
		{
			swap(a[j],a[j+1]);
		}
	}
}
```

我们能很快的反应出来，$(n-1)\times (n-i)$ 肯定是比 $n^2$ 要小的。

所以，$n^2$ 的操作绰绰有余。

因此，我们只要判断数组元素是否相同就可以了，不用考虑能否在 $n^2$ 次操作内完成。

我们先写出判断一样的代码。

```cpp
int n=read();
int a[n+1],b[n+1],c[n+1],d[n+1];
for(int i=1;i<=n;i++)
{
	cin>>a[i];
	c[i]=a[i];
}
for(int i=1;i<=n;i++)
{
	cin>>b[i];
	d[i]=b[i];
}
sort(c+1,c+n+1);
sort(d+1,d+n+1);
//因为不能打乱ab数组，就用别的数组代替。如果排序后一模一样，里面元素也一样。
for(int i=1;i<=n;i++)
{
	if(c[i]!=d[i]){puts("NO");return;}//判断ab数组元素是否相同
}
```

接着，如果可以构造出来，我们就可以每次确定一个数的位置，最后就能创造出来。

```cpp
puts("YES");
for(int i=1;i<=n;i++)//循环b的元素
{
	int x;
	for(int j=1;j<=n;j++)
	{
		if(a[j]==b[i])
		{
			x=j;//找位置
			break;
		}
	}
	for(int j=x;j>i;j--)//交换
	{
		swap(a[j],a[j-1]);
		cout<<j<<" "<<j-1<<'\n';
	}
}
cout<<0<<" "<<0<<'\n';
```

### 完整代码

[完整代码戳这](https://www.luogu.com.cn/paste/33v2dfh4)



---

## 作者：little_cindy (赞：3)

## 思路
我们先考虑无解的情况，显然如果 $a$ 数组和 $b$ 数组排序后不一样，直接输出 `NO` 即可。

如果有解，先输出 `YES`。

对于任意 $i$ 满足 $a_i\not=b_i$，找到一个 $b_j$ 使得 $a_i=b_j$，一步一步把 $b_j$ 向前交换至 $b_i$ 即可。

## code
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,a[1005],b[1005],c[1005],d[1005];
int main(){
    cin>>t;
    while(t--){
        cin>>n;
        for(int i = 1;i <= n;i ++){
			cin>>a[i];
			c[i]=a[i];
		} 
        for(int i = 1;i <= n;i ++){
        	cin>>b[i];
			d[i]=b[i];
		}
        sort(c+1,c+n+1);
		sort(d+1,d+n+1);//排序
		bool ok = true;//标记是否有不同的 
        for(int i = 1;i <= n;i ++){
			ok &= (c[i] == d[i]);//有不同
		}
        if(!ok){
			puts("NO");//无解
		}
        else{
            puts("YES");//有解
            for(int i=1;i<=n;i++){
                if(a[i]==b[i]){
                	continue;
				}
                int pos=0;
                for(int j=i;j<=n;j++){//因为前 i-1 项都调整好了
                    if(a[j]==b[i]){//找到与a[i]相同的b[j] 
                        pos=j;
                        break;
                    }
                }
                for(int j=pos;j>i;j--){//一步一步交换 
                    cout<<j<<' '<<j-1<<endl;
                    swap(a[j],a[j-1]);
                }
            }
            cout<<"0 0";
            if(t!=0){
				cout<<endl;
			}
        }
    }
    return 0;
}
```

---

## 作者：a1co0av5ce5az1cz0ap_ (赞：2)

插入排序学过吧？这道题相当于指定顺序的插入排序。

我们要让每一个数都到达位置。对于第 $i$ 个数，首先找到离当前位置最近的 $j$ 符合 $b_i=a_j$ ，然后就从后往前交换。这本质上就是个插入排序嘛！

为什么不会超过 $n^2$ 次呢？我们插入排序的时候，找到的数肯定在 $[i+1,n]$ 中间，最多交换次数就是 $(n-1)+(n-2)+...+1$ ，远小于 $n^2$。

代码：
```cpp
#include<iostream>
#include<map>
using namespace std;
int a[1005],b[1005];
map<int,int> mp;
int main(){
	ios::sync_with_stdio(0);//加速加速加速
	cin.tie(0);
	cout.tie(0);
	int t;
	cin>>t;
	int n,pos;
	bool f;
	while(t--){
		f=1;
		cin>>n;
		mp.clear();//判断NO
		for(int i=1;i<=n;i++){
			cin>>a[i];mp[a[i]]++;
		}
		for(int i=1;i<=n;i++){
			cin>>b[i];mp[b[i]]--;
		}
		for(int i=1;i<=n;i++){
			if(mp[a[i]]||mp[b[i]]){//说明数量不同
				f=0;
				break;
			}
		}
		if(f) cout<<"YES"<<'\n';
		else{
			cout<<"NO"<<'\n';
			continue;
		}
		for(int i=1;i<n;i++){//对于每一个i
			pos=0;
			for(int j=i;j<=n;j++){
				if(a[j]==b[i]){//找到合适的j
					pos=j;
				}
			}
			for(int j=pos;j>i;j--){//逐个交换回来
				cout<<j<<" "<<j-1<<'\n';
				swap(a[j],a[j-1]);
			}
		}
		cout<<"0 0"<<'\n';//结束了
	}
	return 0;
}
```

---

## 作者：dingshengyang (赞：2)

- 无解：如果 $a$ 和 $b$ 排序之后的结果不一样，直接输出 `NO`。（显然，交换人员并不能改变值）

- 有解：输出 `YES`。然后对于每一个人 $i$，只要 $a_i \not= b_i$，找到 $b_j(a_i=b_j)$，然后每次交换 $a_j$ 和 $a_{j-1}$，直到把他交换过来为止。注意，一定要**知行合一**！要 `swap` 一下！

放代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,a[1005],b[1005],c[1005],d[1005];
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i = 1;i <= n;i ++)scanf("%d",&a[i]),c[i]=a[i];//备份
		for(int i = 1;i <= n;i ++)scanf("%d",&b[i]),d[i]=b[i];
		sort(c+1,c+n+1);sort(d+1,d+n+1);//sort 一下
		bool ok = true;
		for(int i = 1;i <= n;i ++)ok &= (c[i] == d[i]);//如果有不同的，ok 为 false
		if(!ok)puts("NO");//输出无解
		else{
			puts("YES");//输出有解
			for(int i = 1;i <= n;i ++){
				if(a[i] == b[i])continue;//不用交换了
				int pos = 0;//捕捉与 a[i] 一样的 b[j]
				for(int j = i;j <= n;j ++){//因为前 i-1 项都调整好了
					if(a[j] == b[i]){//捕捉成功！扣款 0 元！
						pos = j;//记录
						break;//节省时间
					}
				}
				for(int j = pos;j > i;j --){
					printf("%d %d\n",j,j-1);//一路交换
					swap(a[j],a[j-1]);//知行合一
				}
			}
			printf("0 0");//别忘了善后
			if(t)puts("");//如果不是最后一行，输出换行
		}
	}
	return 0;
}
```

---

## 作者：pengzy___ (赞：2)

### 思路：

这题实现其实很简单。

首先判断，对 $a,b$ 两个数组进行快排，如果两个数组里的元素还是不相同，则直接结束。否则的话，先输出可以。

然后可以用双层循环来枚举两个数组中相同的元素，并记录下来，最后再一边循环交换元素一边输出。

交换次数是肯定是小于 $n^{2}$ 的，因为就算是最坏情况也不会超出 n 。

总的来说就是如果两个数组中有元素相同，而位置不等，我们就不断地交换相邻元素，直到不存在位置不等的情况，并输出操作过程中的两个数。

### 代码：
```cpp
for(int i=1;i<=n;i++){cin>>a[i];c[i]=a[i];}
for(int i=1;i<=n;i++){cin>>b[i];d[i]=b[i];}
sort(c+1,c+n+1);
sort(d+1,d+n+1);
for(int i=1;i<=n;i++)
	if(c[i]!=d[i])cout<<"NO"<<endl;
cout<<"YES"<<endl;
for(int i=1;i<=n;i++) 
	for(int j=1;j<=n;j++) {
		if(a[j]==b[i]){t=j;break;}
		for(int j=t;j>i;j--) {
			swap(a[j],a[j-1]);
			cout<<j<<' '<<j-1<<<<endl;
		}
	}
	cout<<0<<" "<<0<<<<endl;
```


---

## 作者：Eason2009 (赞：1)

这道题挺简单的，主要考查的知识点是模拟和冒泡排序，详情见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[1005],b[1005],c[1005],d[1005];
int main()
{
	cin>>t;
	while(t--)
	{
		bool flag=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			c[i]=a[i];
		}
		for(int i=1;i<=n;i++)
		{
			cin>>b[i];
			d[i]=b[i];
		}
		sort(c+1,c+n+1);
		sort(d+1,d+n+1);
		for(int i=1;i<=n;i++)
		{
			if(c[i]!=d[i])//判断原队形和美观队形排序后是否完全一样，若不一样，则不存在合法的交换方案
			{
				cout<<"NO"<<'\n';
				flag=1;
				break;
			}
		}
		if(flag) continue;
		cout<<"YES"<<endl;//若原队形和美观队形一样，那么移动次数最多为n*(n-1)/2，因此一定存在合法方案
		for(int i=1;i<=n;i++)
		{
			int num;
			for(int j=i;j<=n;j++)
			{
				if(b[i]==a[j])
				{
					num=j;//对于美观队形的每个数i，找到它在原队形中的位置num
					break;
				}
			}
			for(int j=num;j>i;j--)//交换位置
			{
				cout<<j<<' '<<j-1<<'\n';
				swap(a[j],a[j-1]);
			}
		}
		cout<<"0 0"<<'\n';//不要忘记！！！
	}
	return 0;
}
```


---

## 作者：3a51_ (赞：0)

建议评级：橙

采用冒泡的思想，每一次在 $a$ 序列中找到 $b$ 中对应的元素，然后挪到相对位置即可。如果某一次寻找找不到的话那就输出`No`。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct Node{
	int x,y;
};//结构体存储每一次交换的两数
int n,a[1005],b[1005],cnt=1,flg=0;
Node ans[1000005];//ans是最终交换的答案
signed main(){
	int T;
	cin>>T;
	while(T--){
		cnt=1;flg=0;//flg判断找不找得到，需要刷新
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++) cin>>b[i];
		for(int i=1;i<=n;i++){
			int now=b[i];
			int nowp;
			for(int j=1;j<=n;j++){
				if(a[j]==now){//寻找位置
					nowp=j;
					break;
				}
				if(j==n){
					flg=1;
					break;
				}
			}
			if(nowp<i){
				for(int j=nowp+1;j<=i;j++){
					Node aj;
					aj.x=j-1;
					aj.y=j;//这里做交换并存储答案
					swap(a[j],a[j-1]);
					ans[cnt++]=aj;
				}
			}
			if(nowp>i){//需要分情况讨论往前走还是往后走
				for(int j=nowp-1;j>=i;j--){
					Node aj;
					aj.x=j+1;
					aj.y=j;
					swap(a[j],a[j+1]);
					ans[cnt++]=aj;
				}
			}
		}
		if(flg==1){//如果某一次没找到
			cout<<"NO"<<endl;
			continue;
		}
		cout<<"YES"<<endl;
		for(int i=1;i<cnt;i++){
			cout<<ans[i].x<<" "<<ans[i].y<<endl;
		}//输出
		cout<<"0 0"<<endl;
	}
	return 0;
}
```

---


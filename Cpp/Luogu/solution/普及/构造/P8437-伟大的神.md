# 伟大的神

## 题目背景

伟大的神 $\text{T}\color{red}\text{nyieldingUrilobite}$ （以下简称 TU）喜欢字符串，在 AK 了 IOI 后的第 $998244353$ 天后，伟大的神 TU 勒令小 s 找出他喜欢的字符串。

否则，小 s 就要被吊打 $10^{998244353}$ 年。（虽然找出来了也要被吊打）

## 题目描述

伟大的神 TU 认为 ，一个所有出现的字符的数量相等的字符串是属于神的，他称之为神之字符串。

对于一个字符串 $S$，如果它的一个子串为神之字符串，即称这个子串为神之子串。

神 TU 认为，他喜欢的字符串只能由 `l` 和 `r` 构成，并且还要满足以下条件：

   - 字符串的长度为 $n$。
   - 字符串中最长神之子串长度为 $m$。
   - 字符串中连续的相同的字符的数量不能超过 $k$。

弱小的神小 s 找不出神 TU 喜欢的字符串，现在他找到了你，你能帮帮他吗？

## 说明/提示

**本题采用捆绑测试。**

对于 $100\%$ 的数据，保证 $1\le k\le10^5$，$4\le m\le n \le 10^5$。

数据保证可以找出神 TU 喜欢的字符串。

Subtask 1：对于 $5\%$ 的数据，保证 $k=1$。

Subtask 2：对于另外 $10\%$ 的数据，保证 $n=m$。

Subtask 3：对于另外 $30\%$ 的数据，保证 $k \ge 3$。

Subtask 4：无特殊性质。



## 样例 #1

### 输入

```
10 6 3```

### 输出

```
lllrrlrlll```

# 题解

## 作者：chen_zhe (赞：33)

值得一提的是，本题赛时 AC 率并非洛谷月赛 div.2A 最低，但是我单方面认为这是洛谷月赛最难的 div.2A。

---

本题的最大切入口在于：

- 数据保证可以找出神 TU 喜欢的字符串。
- 输入的 $m$ 均为偶数。

## Subtask 1 

本 subtask 满足性质 $k=1$。

因为连续的相同的字符的数量不能超过 $1$，为了确保 $S$ 中存在一个子串是“神”的，即所有出现的字符的数量相等，只需构造出 $\texttt{lrlrlrlr\dots}$ 的字符串即可。因为数据保证一定存在解，所以这样做是可行的。

## Subtask 2

本 subtask 满足性质 $n=m$。

也就是说字符串 $S$ 为最长神之子串。实际上，Subtask 1 中构造出的 $\texttt{lrlrlrlr\dots}$ 即可符合这个要求。这是因为，$S$ 为最长神之子串，则 $S$ 必然是个偶数，否则无法满足 $\texttt l$ 与 $\texttt r$ 的个数相等。

## Subtask 3

本 subtask 满足性质 $k \geq 3$。

我们的想法是：可以先构造出一个长度为 $m$ 的最长神之子串，然后再在后面随意添加字符，使得后面的部分不构成神之子串。

而在满足不能有超过 $k$ 个连续字符的情况下，前面的神之子串可以仿照上面两个 subtask 进行构造，即构造出长度为 $m$ 的字符串 $\texttt{lrlr\dots}$。需要注意的是 $m$ 为偶数，所以前面的神之子串在这样的构造情况下结尾字符是 $\texttt r$。接着为了让后面构成不了神之子串，我们可以放 $2$ 个 $\texttt{l}$ 与 $1$ 个 $\texttt{r}$。这样恰好满足连续字符不超过 $k$，且最长神之子串的长度为 $m$。

## Subtask 4

注意，这里有个大坑点！在 $k=2$ 的情况下，上述构造不一定适用。以一组数据为例：

$\texttt{Input Data: 10 6 2}$

以上面的构造会得出如下结果：

$\texttt{Output Data: lrlrlrllrl}$

这个结果经不起推敲，因为该字符串从第 $2$ 位取到第 $9$ 位的话，正好存在 $4$ 个 $\texttt l$ 和 $4$ 个 $\texttt r$，使得实际的最长神之子串的长度是 $8$ 而不是 $6$。

实际上，这种情况只会在一开始的循环字符串 $\texttt{lr}$ 的后段，与后面的 $\texttt{lll\dots r}$ 段的前面会发生。因此，我们可以考虑破坏掉一开始的循环字符串后端，将最后一个 $\texttt{lr}$ 转化成 $\texttt{rl}$。

这样再仿照上述构造，即可完成本题。

```cpp
#include <iostream>
using namespace std;
int main()
{
	int n,m,k;
	cin >> n >> m >> k;
	if (k==1)
	{
		for (int i=1;i<=n;i++)
			cout << (i&1?'l':'r');
		return 0;
	}
	for (int i=1;i<=m-2;i++)
		cout << (i&1?'l':'r');
	int cnt=1;
	cout << "rl";
	for (int i=m+1;i<=n;i++)
	{
		if (cnt==0)
			cout << 'l';
		else
			cout << 'r';
		cnt++;
		cnt%=3;
	}
	return 0;
}
```

打个广告：可爱[八云蓝](https://www.luogu.com.cn/user/149196)的 [adhoc 计划](https://www.luogu.com.cn/blog/YakumoRanqwq/)。对解决此类问题有着大大的帮助。

---

## 作者：Jeremiahy (赞：7)

# 分析

最初看见这道题，一般会有一些思路，但是并不完善，于是我们可以尝试去做子任务（~~骗分~~），顺便理清此题的思路。

### Subtask 1

由于 $k=1$，所以只能 ```l``` 和 ```r``` 交替出现，又因为题目保证有解，所以肯定是对的（不然就无解了）。

### Subtask 2

这个同样是 ```l``` 和 ```r``` 交替出现，因为 $n=m$，又为了连续字符不超过 $k$，这是最保险且很正确的做法。

### Subtask 3

$k\ge 3$，这时我们可以使用一种贪心算法：先 ```l``` 和 ```r``` 交替出现，知道长度达到 $m$，接下来，因为 $m$ 为偶数，所以刚刚最后输出的字符为 ```r```，那么输出 $k$ 个 ```l```，再输出一个 ```r```，再输出 $k$ 个 ```l```······循环直到总长度达到 $n$。

容易证明，因为 $k\ge 3$，所以前面的不会与后面的构成更长的神之子串，而后面的最多也就出现长度为 $2$ 的神之子串，对于 $m\ge 4$ 来说根本不会出错。

### Subtask 4

这里增加了 $k=2$ 的情况，如果按照上述做法构造，就会出错，比如看下面这组例子。

输入： ```10 4 2 ```

输出： ```lrlrllrllr```

我们发现，第 $2$ 到 $7$ 个字符构成了一个长度为 $6$ 的神之子串，而且我们还发现，是一个 ```rllr``` 的子串坏了好事，那么我们考虑特殊构造数据：循环输出 $m-4$（留 $4$ 个位置给 ```rllr```） 个 ```rl```，然后循环输出 ```rll``` 直到达到长度 $n$。

由于考试时间紧张，代码非常的丑陋与粗糙，这里只放个[链接](https://www.luogu.com.cn/paste/bma6tppr)。

下面放修缮过的代码。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k;
signed main() {
	cin >> n >> m >> k;
	if (k == 1 || n == m) //subtask 1 & 2
		for (int i = 1; i <= n; i++)
			if (i % 2)//循环输出 l , r 
				cout << 'l';
			else
				cout << 'r';
	else if (k == 2) {
		int num = (m - 4) / 2; //计算输出多少个 rl，因为 rl 占两个字符，所以要除以 2 
		for (int i = 1; i <= num; i++)
			cout << "rl"; 
		for (int i = 1; i <= n - num * 2; i++)
			if (i % 3 == 1) //输出 rll 
				cout << 'r';
			else
				cout << 'l';
	}
	else {
		for (int i = 1; i <= m; i++)
			if (i % 2)//输出 l ，r直到到达 m 
				cout << 'l';
			else
				cout << 'r';
		for (int i = m + 1; i <= n; i++) {//输出 k 个 l，1 个 r，循环。 
			for (int j = 1; j <= k; j++) {
				if (i > n)
					break;
				cout << 'l', i++;
			}
			if (i <= n)
				cout << 'r';
		}
	}
	return 0;
}
//当然，上述代码也可以用问号表达式等方法进一步精简（不过懒得改了 
```


---

## 作者：sycqwq (赞：6)

__Subtask1:__

​	因为 $k=1$ 所以构造方法只能为 `lrlrlr...` 或 `rlrlrlrl... `

​	因为数据保证有解，所以直接输出 `lrlrlr...` 即可。

__Subtask2:__

​	因为 $n=m$，所以只需要输出 $\dfrac{m}{2}$ 个 `lr` 就可以了

__Subtask3:__

​	因为 $k \ge 3$，所以直接按先放 $\dfrac{m}{2}$ 个 `lr`，再按放一个 `l`，$k$ 个 `r` 的比例进行构造。 

__Subtask4:__ 

​	首先，我们可以考虑把构造出来的最长神之子串放在最左边，然后保证之后不会出现更长的长神之子串

​	构造最长优美子串，可以直接用 $\dfrac{m}{2}$ 个 `lr` 进行构造，之后可以每放 $k$ 个 `l` 放一个 `r`，这样就不会构成更长的神之子串了。

​	而当 $k=2$ 时，这样的构造方法是有问题的，详见以下一组数据（这也是很多人被卡的原因）：

​	`10 6 2`

​	此时根据上面的方法进行构造，构造出来为 `lrlrlrllrl`，不难发现最长神之子串的长度为 $8$，为子串 `rlrlrllr`。

​	可以发现，这个时候因为有 `r` 开头 `r` 结尾的情况，所以会导致答案增加 $2$ 。

​	这个时候，只要少放一个 `lr` ，然后去掉开头的第一个`l`就可以保证最长神之子串在最左边，并且长度为 $k$ 了。

​	所以最终的构造方法为 `rlrlrl...lrllrllrllr...`，期中 `rl` 的数量为 $\dfrac{m}{2}-1$，之后再添加一组 `lr` ，最后一直添加 `llr` 即可。（长度不够就能添加多少添加多少，反正之后的方案为每放 $2$ 个 `l` 放一个 `r` ）

​	注意到，除了一开始构造的神之子串，后面放的 `llrllrllr...` 会产生长度为 $4$ 的神之子串，但因为题目保证了 $m \ge 4$，所以没有影响。

​	对于 $k \ge 3$ 的时候，直接按 $k=2$ 的时候进行构造即可，显然符合题目要求。
   

---

## 作者：浪客侠星 (赞：5)

### Subtask 1,2

显然，当 $n = m$ 时，整个串是神之字符串；当 $k = 1$ 时，必须把所有的 'l' 和 'r' 间隔放，这样的话整个串就也是神之字符串，同时满足 $n=m$ 的情况。

所以我们把这两种情况一起讨论，放 "lrlrlr...lr" 就行了。

### 另外的情况

我们可以把神之子串间隔着放在答案字符串里，然后假如说我们使神之子串的模板为 "lrlr...lr（共 $m$ 个字符）"，则要使右侧的字符不被包含进神之子串里，那么我们只需要连续放两个一样的字符就行了。于是答案字符串的模板就变成了 "lrlr...lrll(右边再放一个神之子串)lrlrl...lrlllrlr...（以此类推）"。然而这么放并不满足 $k=2$ 的情况。

因为我现在的神之子串开头是 'l', 结尾是 'r'，如果我在我的神之子串之间放了两个 'l' 或者 'r' 那么它总会与两侧的神之子串的开头或者结尾连起来，使 $k=3$ 。所以我要使神之子串的开头和结尾是同一个字符。

这个非常好办，只要把我的神之子串的结尾加一个 'rl'，变成 "lrlr...lrrl"，这样它的首尾就统一了，而且题目说了，$4\le m\le 10^5$，也就是说我的神之子串保证能放 "lrrl"，然后右边放 "rr"，再放神之子串，以此类推，答案字符串模板就变成了 "lr..lrrlrrlr..lrrl..."。

这样写起来有点麻烦，因为第二个及以后的神之子串 "lrlr...lrrl"左边有对少个 "lr"并不重要，所以我们可以把它们简化成 "lrrl"，这样我的答案就是神之子串 "lrlr...lrrl" 加上右边无数个 "rrl"。然后这道题就非常好写了。

下面放上我的代码。
```cpp
#include<cstdio>
int n,m,k;
char ans[100005];
int i,p,q;
int main(){
	scanf("%d%d%d",&n,&m,&k);
	if(k==1||n==m){
		for(i=1; i<=n; i++)
			if(i&1) putchar('l');
			else putchar('r');
		return 0;
	}
	p=m-2;
	for(i=1; i<=p; i++)
		if(i&1) ans[i]='l';
		else ans[i]='r';
	ans[++p]='r';
	ans[++p]='l';
	q=(n-m)/3;
	for(i=1; i<=q; i++){
		ans[++p]='r';
		ans[++p]='r';
		ans[++p]='l';
	}
	ans[++p]='r';
	ans[++p]='r';
	for(i=1; i<=n; i++)
		putchar(ans[i]);
}
```


---

## 作者：ztntonny (赞：4)

## 题意
先解释一下“神之子串”，就是一串字符，其中所有字符出现的频率一致。输入时，给三个数 $n$、$m$、$k$，第一个表示输出数列的长度，第二个表示最长“神之子串”的长度，第三个表示最多连续同样字母的长度。特别的，所有你需要输出的只有 ```l``` 和 ```r```。
## 思路
构造+分类，首先想 $k > 2$ 时，只需要最多连续 $3$ 个来构造，在等于 $2$ 和 $1$ 时单独判定，下面是构造法的代码，证明在下面。
```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
int main()
{
	int k , m , n;
	cin >> n >> m >> k;
	if ( k >= 3 )
	{
		for ( int i = 1; i <= n - m; i++ )
		{
			if ( i % 4 == ( ( n - m ) % 4 + 1 ) % 4 )
			cout << "r";
			else
			cout << "l";
		}
		for ( int i = 1; i <= m; i++ )
		{
			if ( i % 2 == 0 )
			cout << "l";
			else
			cout << "r";
		}
	}
	if ( k == 1 )
	{
		for ( int i = 1; i <= n; i++ )
		{
			if ( i % 2 == 0 )
			cout << "l";
			else
			cout << "r";
		}
	}
	if ( k == 2 )
	{
		for ( int i = 1; i < n - m + 2; i++ )
		{
			if ( i % 3 == ( n - m - 1 ) % 3 )
			cout << "r";
			else
			cout << "l";
		}
		for ( int i = 1; i <= m - 2; i++ )
		{
			if ( i % 2 == 0 )
			cout << "l";
			else
			cout << "r";
		}
		cout << "l";
	}
	return 0;
}
```
## 证明
第一种情况：核心在于，形如此的 ```rlllrlllrlll``` 字符串，在后面添加形如此的 ```rlrlrlrl``` 字符串，能保证“神之子串”的最长长度即为后者 ```rlrlrlrl``` 的长度，因为如果往前再寻找下一个 ```r``` 代价就是三个 ```l```，即使后面又能补上一个 ```r``` 也无法补回来。所以构造方法就是前面输出 $n - m$ 个 ```rlllrlllrlll```，并保证其结尾为 ```lll```，在后面填上 $m$ 个 ```rlrlrlrl``` 即可。第二种就很简单了不说了。第三种情况因为再寻找第三个 ```r``` 时代价为四个 ```
l```，补不回来，同理会多出一组 ```rl```，所以只需要少输出一组即可。

---

## 作者：cst_123 (赞：4)

### - [传送门](https://www.luogu.com.cn/problem/P8437)

------------

### 题意

首先需了解神之子串，就是在一个长度是 $n$ 并且只包含 `l` 和 `r` 的字符串里，最长的神之子串长度为 $m$，也要使这个子串中出现的 `l` 和 `r` 数量相等。还需要注意的是该字符串中连续相同的字符数量不能超过 $k$。


### 思路

- Subtask 1：当 $k=1$ 时，我们就能想到 `lrlr……` 直到第 $m$ 个，剩下的 $m-n$ 个就破坏 `l` 和 `r` 个数相同即可，输出 $m-n$ 个 `l` 就行，这样就可以过了。

	举个例子。

	```cpp
	8 6 1
	```
	输出就为 `lrlrlrll`。

   可以发现 `l` 只会在最后重复一组，就不用再去考虑 $k$ 的问题了。

- Subtask 2:这里 $n=m$，那么思路与 Subtask 1 一样，上面的特殊限制让我们知道 $n$ 和 $m$ 之差便是 $0$，所以最后输出不了剩下的 `l`，那么这也就过了。

- Subtask 3:我们先满足 $m$ 的要求，方法同上，之后我们需破坏后面的字符串，让它们无法构成神之子串，可用 `llr……` 直至这两步之和达到 $n$ 的个数。

- Subtask 4:现在是无限制，我们能从上面看出这应是 $k=2$ 的情况了。那还能用 Subtask 3 的方法吗？再举一个例子。
	```cpp
	12 8 2
	```
   我们会输出 `lrlrlrlrllrl`，但是现在神之子串的长度便不是 $m$ 的 $8$ 了，而是从第 $2$ 位到第 $11$ 位的 $10$ 了，明显不对。
   那么我们就把第 $1$ 组 `lr` 改成 `rl`，再试一下上面的例子，输出就是 `rllrlrlrllrl`，这样就可以解决了 Subtask 4 了。
   
### 代码

因为 Subtask 1 和 2 的解法相同，于是我把这两个合在了一起。我又把 3 和 4 的解法也放在了一起，是因为 3 输出的神之子串先输出 `rl` 再输出剩下的字符串是不会影响答案的。

```cpp
//tot存的是l和r单个的位数
if(k==1||n==m){
	tot=m/2;
	for(int i=1;i<=tot;i++)
		printf("lr");
	for(int i=1;i<=n-m;i++)
	  	printf("l");
}else{
	tot=m/2-1;
	//首先输出的是rl，所以位数之和要减1
	printf("rl");
	while(tot--)
   		printf("lr");
	now=n-m;
	//now表示剩下的位数
	if(now<=0)
		return 0;
	else{
		yushu=now%3;
		//yushu表示余数，因为之后需输出llr，所以要求出余数
		now=(now-yushu)/3;
		while(now--)
			printf("llr");
	   	if(yushu==1)
	    	printf("l");
		if(yushu==2)
	    	printf("ll");
	}
}
```

---

## 作者：Creeper_luogu (赞：3)

# P8437 「伟大的神」题解

[题面链接](https://www.luogu.com.cn/problem/P8437)

## 题意解释

* 给出 $3$ 个正整数 $n,m,k$；
* “神之字串”是 $1$ 个字符串中的 $1$ 段子串，且其中所有字符出现的频率一致；
* 我们需要输出一段长度为 $n$，且其中最长的“神之子串”长度为 $m$，最多连续同样字母的长度为 $k$ 的字符串；
* 保证 $1 \le k \le 10^5$，$4 \le m \le n \le 10^5$，$m$ 一定为偶数，输入的数据一定能找到所需输出的字符串。

## 题目分析

这道题是一道构造题，我们可以分类构造，对于 $k = 1$ 时以及 $k = 2$ 时特判。

对于 $k \ge 3$ 时，我们采用以下方法：

首先添加 $1$ 段长度为 $n - m$ 的形如 `lrrr…` 的字符串，这样无论如何都不能形成“神之子串”。

接下来，我们再添加长度为 $m$ 的形如 `lr…` 的字符串，其一定为“神之子串”，这样就一定可以保证最长的“神之子串”长度为 $m$。

对于 $k = 2$ 时，同理，少输出一组即可。

对于 $k = 1$ 时，很简单，只需输出长度为 $m$ 的形如 `lr…` 的字符串即可。

## AC代码

```cpp
#include <iostream>
using namespace std; //预编译

int n, m, k; //定义变量

int main()
{
    cin >> n >> m >> k; //输入
    if(k >= 3) //k >= 3 时的情况
    {
        for(int i = 1; i <= n - m; i++)
        {
            if(i % 4 == ((n - m) % 4 + 1) % 4)
            {
                cout << "l";
            }
            else
            {
                cout << "r";
            }
        }
        for(int i = 1; i <= m; i++)
        {
            if(i % 2 == 0)
            {
                cout << "r";
            }
            else
            {
                cout << "l";
            }
        }
    }
    else if(k == 2) //k = 2 时的情况
    {
        for(int i = 1; i < n - m + 2; i++)
        {
            if(i % 3 == (n - m - 1) % 3)
            {
                cout << "l";
            }
            else
            {
                cout << "r";
            }
        }
        for(int i = 1; i <= m - 2; i++)
        {
            if(i % 2 == 0)
            {
                cout << "r";
            }
            else
            {
                cout << "l";
            }
        }
        cout << "r";
    }
    else if(k == 1) //k = 1 时的情况
    {
        for(int i = 1; i <= n; i++)
        {
            if(i % 2 == 0)
            {
                cout << "r";
            }
            else
            {
                cout << "l";
            }
        }
    }
    cout << endl;
    return 0;
}
```

---

## 作者：Register_int (赞：3)

首先，对于一组 $n,m,k$，我们很容易可以构造出如下方案：  
$$\overbrace{lrlrlrlr\cdots}^{m\texttt{个}}\;\underbrace{lllll\cdots}_{k\texttt{个}}\;rlllll\cdots r\cdots$$
很容易发现，在第 $m$ 个字符之后，$l$ 字符的数量始终大于 $r$ 字符的数量。所以可以始终保证最大的神之子串长度为 $m$。  
但是有一个小小的问题。当 $n=10,m=6,k=\color{red}2$ 时，就会出现这种情况：
$$l\;\overbrace{rlrlrllr}^{8?}\;l$$
很明显，我们的算法炸了。原因就出在中间 $rllr$ 这一段。由于 $k=2$，所以在后缀第一次进入循环时，$l$ 会恰好等于 $r+1$。也就是说，去掉头一个 $l$，就能得到更长的子串。因此，我们需要做一些小小的改动，把 $rllr$ 纳入子串里，即：
$$\overbrace{lrlrlrlr\cdots rl}^{m\texttt{个}}\;rrlrrl\cdots$$
特判一下即可得到正确答案。
# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, k;

int main() {
	scanf("%d%d%d", &n, &m, &k);
	if (k != 2) { // 特判k
		for (int i = 1; i <= m; ++i) putchar(i & 1 ? 'l' : 'r'); // lr循环字串部分
		for (int i = m + 1; i <= n; i += k + 1) {  //lll...r循环部分
			for (int j = i; j < i + k && j <= n; ++j) putchar('l');
			if (i + k <= n) putchar('r');
		}
	} else {
		for (int i = 1; i <= m - 2; ++i) putchar(i & 1 ? 'l' : 'r'); putchar('r'), putchar('l'); //lrlr...rl（小改动）
		for (int i = m + 1; i <= n; i += 3) {
			putchar('r');
			if (i + 1 <= n) putchar('r');
			if (i + 2 <= n) putchar('l');
		}
	}
}
```

---

## 作者：qzhwlzy (赞：3)

## 题目大意
构造一个长度为 $n$ 的字符串，满足：

1. 仅由字符 $\mathtt{l}$ 和 $\mathtt{r}$ 组成；
2. 存在一个长度为 $m$ （$m$ 为偶数）的子串使得 $\mathtt{l}$ 和 $\mathtt{r}$ 的个数相同（即原题中的「神之子串」）且不存在有长度大于 $m$ 的子串使得 $\mathtt{l}$ 和 $\mathtt{r}$ 的个数相同；
3. 连续的相同字符数量不超过 $k$。

## 思路
我们观察到 subtask 1 和 subtask 3 分别给了 $k=1$ 和 $k\ge 3$ 的数据范围，说明本题的解法与 $k$ 有关系。

首先是 $k = 1$ 的 subtask 1，因为不存在连续 $2$ 个及以上的连续字符，所以构造的字符串一定是形如 $\mathtt{lrlrlrlr…}$ 之类的。观察到这个串的最长神之子串恰好是本身，故存在 $n=m$，特判即可水过 subtask 1 和 subtask 2。

之后我们考虑构造 subtask 3 的字符串，我们可以先构造出它的神之子串，然后用各种方法把它凑到 $n$ 个。例如，神之子串根据 subtask 2 可以被构造为 $\mathtt{lrlrlr…}$，然后是将长度凑到 $n$。一般来讲，肯定是把神之子串放在开头（或结尾），然后在后面放上 $\mathtt{llll…}$ 来防止其能够凑出更长的神之子串，而因为同一字符不超过 $k$ 个，所以放 $k$ 个 $\mathtt{l}$ 就用一个 $\mathtt{r}$ 隔开。也就是说，最终的答案就是形如 $\mathtt{lrlrlrlr…lllllrlllllr…}$ 的字符串。

最后我们看到 $100\%$ 数据的 $k=2$ 的情况，我们发现，根据我们刚才的字符串变成了 $\mathtt{lrlrlrlrllrllr}$（以 $n=14,m=8$ 为例，下同），此时，我们发现串中存在一个更大的神之子串（原来我们期望的神之子串用下划线表示，更长的神之子串用红色标识） $\mathtt{\underline{l}\underline{\color{red}rlrlrlr}\color{red}{llr}\color{black}{llr}}$，这是因为 $k=2$ 时我们堆的 $\mathtt{l}$ 太薄了，导致我们想要的神之子串能够舍掉最前面的 $\mathtt{l}$ 而向后得到 $\mathtt{llr}$ 从而变成了一个更大的神之子串。有以下两种改进方法：

1. 首先是我的一个想法。为解决矛盾，我们想让我们期望的神之子串不能够越过 $\mathtt{ll}$ 形成更大的神之子串，那么，我们可以稍作改进，将字符串变成 $\mathtt{rllrlrlrllrllr}$，也就是让我们期望成为神之子串的字符串变成 $\mathtt{rllrlrlr}$，这样它就不可以像原来一样放弃最左边的 $\mathtt{l}$ 得到 $\mathtt{llr}$ 变成大的神之子串（因为此时最左边是 $\mathtt{r}$，右边的 $\mathtt{l}$ 比 $\mathtt{r}$ 多，舍掉了这个 $\mathtt{r}$ 右边不能补充回来）；

2. 其次是我写题解时想到的解法。既然我们很难处理，我们干脆就让它变成神之子串，考虑到它的长度是 $m+2$，我们将读入的 $m$ 减 $2$ 再按原来的方法构造即可。

而我比赛时不知道为什么把神之子串放在了串中间，然后两边用一堆 $\mathtt{llll…}$ 防止能够凑出新的神之子串，因为两边都要放 $k$ 个 $\mathtt{l}$ 作分隔（因为若有一边是 $\mathtt{l}$ 的话连着占位的 $\mathtt{l}$ 就超过 $k$ 个了），自然地就将神之子串变成了 $\mathtt{rlrllrlr}$ 的形式，直接规避了 $k=2$ 的问题（但是 $k=1$ 和 $n=m$ 还是要特判）。

下面是代码，三种方法都能够过本题。

## 代码
方法一：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,k; 
int main(){
//	freopen(".in","r",stdin); freopen(".out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	if(k==1||n==m){for(int i=1;i<=n-1;i+=2) printf("lr"); if(n%2) printf("l");return 0;}
	// 特判 k=1 及 n=m 的情况 
	printf("rl"); for(int i=2;i<=m/2;i++) printf("lr");
	// 神之子串（前两位反转以防存在更优的神之子串） 
	for(int i=m+1;i+k<=n;i+=(k+1)){for(int j=1;j<=k;j++) printf("l"); printf("r");}
	for(int i=1;i<=(n-m)%(k+1);i++) printf("l");
	// 占位（k个l 1个r 如此循环） 
	return 0;
}
```

码题解时想出来的方法（方法二）：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,k; 
int main(){
//  freopen(".in","r",stdin); freopen(".out","w",stdout);
    scanf("%d%d%d",&n,&m,&k); if(k==1||n==m){for(int i=1;i<=n-1;i+=2) printf("lr"); if(n%2) printf("l");return 0;}
	if(k==2) m-=2; //k=2 就少构造一组 lr 
    for(int i=1;i<=m/2;i++) printf("lr");
    // 构造神之子串 
    for(int i=m+1;i+k<=n;i+=(k+1)){for(int j=1;j<=k;j++) printf("l"); printf("r");}
    for(int i=1;i<=(n-m)%(k+1);i++) printf("l");
    // 占位 
    return 0;
}
```

考试时我的代码（是把神之子串放在中间的）（~~非常不可读，建议看上面的两个~~）：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,k; 
int main(){
//	freopen(".in","r",stdin); freopen(".out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	if(k==1||n==m){for(int i=1;i<=n-1;i+=2) printf("lr"); if(n%2) printf("l");return 0;}
	for(int i=1;i<=(n-m)/2;i++) if(((n-m)/2+1-i)%(k+1)) printf("l"); else printf("r");
	for(int i=1;i<=m;i+=2) if(i<=m/2) printf("rl"); else printf("lr");
	for(int i=1;i<=(n-m-(n-m)/2);i++) if(i%(k+1)) printf("l"); else printf("r");
	return 0;
}

```

---

## 作者：Disjoint_cat (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8437)

## P8437 伟大的神

我并不理解为什么很多人说这道构造题很难。下面来说说我的解法。

### Subtask $1$

此 subtask 满足 $k=1$。此时字符串只能是 $\mathtt{lrlrlrlr\ldots}$ 或者 $\mathtt{rlrlrlrl\ldots}$，注意到题目中说**数据保证可以找出神 TU 喜欢的字符串**，所以直接输出即可。

### Subtask $3$

我们想，这道题只要求我们构造出一种方案，那么我们可以暴力，让前 $m$ 个数为 $\mathtt{lrlrlr\ldots lr}$（或者其他的方法也行，但是我认为这样最好想），然后只要让后面不能与前面构成“神之子串”，注意到前 $m$ 个字符是 $\mathtt{\ldots lrlr}$，所以我们在后面循环地接 $k$ 个 $\mathtt{l}$ 和一个 $\mathtt{r}$，可以证明这样做在 $k\ge3$ 的时候是成立的。实测这样也可以通过 subtask $2$。

### 满分做法

如果仅仅这样，会发现 subtask $1\sim3$ 全过了，说明 $k=1$ 和 $k\ge3$ 的情况都解决了，而 subtask $4$ 却 WA 了一大片，说明仅剩的 $k=2$ 的情况爆炸了。让我们尝试构造一组数据。

输入 $10\ 6\ 2$

输出 $\mathtt{l\color{Red}{rlrlrllr}\color{Black}l}$

可以看出，红色部分构成了长度为 $8$ 的“神之子串”，所以 subtask $3$ 的构造方法在这里会爆炸。

考虑对字符串进行调整，前 $m$ 个字符调整为 $\mathtt{lrlr\ldots lrrl}$，然后后面接 $\mathtt{rrlrrl\ldots}$，连起来就是 $\mathtt{\color{Red}lrlr\ldots lrrl\color{Black}rrlrrl\ldots}$，可以发现黑色部分最长的“神之子串”可以是 $\mathtt{lrrl}$，注意到题目中说 $m\ge4$，所以构造成立。

~~我也不知道为什么 subtask $4$ 里面那么多 $k=2$ 的数据。~~

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,k;
int main()
{
	cin>>n>>m>>k;
	if(k==1)for(int i=1;i<=n;i++)putchar(i&1?'l':'r');
	else if(k==2)
	{
		for(int i=1;i<=m-2;i++)putchar(i&1?'l':'r');
		printf("rl");
		for(int i=m+1;i<=n;i++)putchar((i-m)%3?'r':'l');
	}
	else
	{
		for(int i=1;i<=m;i++)putchar(i&1?'l':'r');
		if(m<n)putchar('l');
		for(int i=m+2;i<=n;i++)putchar((i-1)%k?'l':'r');
	}
	return 0;
}
```

---

## 作者：Dream_weavers (赞：2)

~~思路搬运的是月赛讲评的，希望管理给过~~

## 题意

构造一个长度为 $n$ 且仅包含 `l` 和 `r` 的字符串，使得其最长的满足 `l` 出现次数与 `r` 相等的子串长度为 $m$，同时不能出现超过 $k$ 个连续的相同字符。

## 思路

### 15 分解法

上来先想到的是骗分（

Sub2 已经说了 $n=m$，也就是神之字串的长度等于字符串的长度，这种情况统一按照 $k=1$ 的策略构造。构造方法就是 `lrlr...` 这样交替出现的字符串，长度为 $n$。

这样 Sub1&Sub2 的 $15\text{pts}$ 轻松到手，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	cin>>n; 
	for(int i=1;i<=n;i++){
		if(i&1)printf("l");
		else printf("r");
	}
	return 0;
}
```

------------

### 100 分解法

想要拿 $100\text{pts}$ 就要换一种构造方法，本质都是不变的。

先放 $\frac{m}{2}$ 个 `lr`，然后连续接上 $k$ 个 `l` 和 $1$ 个 `r`，直到把字符串放满，也就是长度为 $n$ 时停止。

但这种方法不能解决 $k$ 为偶数的情况。比如输入 `10 6 2`，会输出 `lrlrlrllrl`，$[2,9]$ 的字串 $m=8$。可以在前面少放一个 `lr`，也就是 $\frac{m}{2}-1$ 个 `lr`，就能解决这种情况了。对于 $k\ge 2$ 都可以用 $k=2$ 的方法取构造。

此方法还不能解决 $n=m$ 的情况，只要前面加一个特判就可以了。$100\text{pts}$ 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,tmp=1,cnt;
int main(){
	cin>>n>>m>>k;
	if(n==m){
		for(int i=1;i<=n;i++){
			if(i&1)printf("l");
			else printf("r");
		}
		return 0;
	} 
	if(k>=2)k=2;
	for(int i=1;i<m/2;i++){
		printf("lr");
		cnt+=2;
	}
	while(cnt<n){
		for(int i=1;i<=k;i++){
			printf("l");
			cnt++;
			if(cnt==n)return 0;
		}
		printf("r");cnt++;
		if(cnt==n)return 0;
	}
	return 0;
}

```	





---

## 作者：what_can_I_do (赞：2)

 [传送门](https://www.luogu.com.cn/problem/P8437?contestId=73946)
 
此篇题解是为了纪念比赛当天出去吃饭忘了参加比赛这件事。

这道题目我个人认为最大的难点在于怎么使神之子串的长度不超过 $m$，并且还要特判 $k = 2$。

### 题目描述


------------
伟大的神 TU 认为 ，一个所有出现的字符的数量相等的字符串是属于神的，他称之为神之字符串。

对于一个字符串 $S$，如果它的一个子串为神之字符串，即称这个子串为神之子串。

神 TU 认为，他喜欢的字符串只能由 l 和 r 构成，并且还要满足以下条件：

- 字符串的长度为 $n$。   
- 字符串中最长神之子串长度为 $m$。   
- 字符串中连续的相同的字符的数量不能超过 $k$。   

弱小的神小 s 找不出神 TU 喜欢的字符串，现在他找到了你，你能帮帮他吗？



------------
那么这一道题我们就可以先把题目中说的神之子串先输出出来，然后再用一个 while 循环输出其余的部分。我们可以先一直输出 l，这样子可以避免神之子串的长度增加，接下来再输出 r 来防止连续的相同的字符的数量不超过 $k$。并且我们还要特判 $k=2$ 的情况。


------------
直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,k,i=1,j=1;
	cin>>n>>m>>k;
	if(k==2) m-=2;                   //特判 k==2,m-2 的原因是因为当你测试数据 10 6 2 时，会输出 lrlrlrllrl，
                                         //长度最大神之子串长度为 8,就是 rlrlrllr 这一段，         
                                         //要处理就得让这个字符串少一个 lr，所以要把神之子串长度 m 减 2。
	while(i<=m)
	{
		cout<<"lr";i+=2;         //先处理神之子串。
	}
	while(i<=n)
	{
		while(j<=k&&i<=n)
		{
			cout<<"l";       //疯狂输出 l 来使长度最大的神之子串不会大于 m。
			j++,i++;
		}
		j=1;
		if(i<=n) cout<<"r",i++;  //输出完 l 之后如果长度没超过 n 就输出一个 r 来使连续的相同字符 l 的数量小于等于 k，
                                         //并且只输出一个防止神之子串的长度增加。
	}
	return 0;
}
```


---

## 作者：南阳刘子骥 (赞：2)

本题保证数据有解，那么我们就不需要担心判无解的部分了。

## 思路

### 15 分解法

首先，我们可以看到 Subtask 1 和 Subtask 2 都可以用一种策略来完成，就是填 `lrlrlrlr...`。  
并且因为题目保证有解，Subtask 1 中的 $m$ 和 $n$ 肯定相差不大于 $1$，因为截断一个神之字符串需要 $k \geq 2$（比如 `lr...lrllr`）。

这样就可以骗到 15 分了。

### 100 分解法

我们首先先考虑一下 $k = 2$ 时的情况。

我们考虑将上面能截断神之字符串的那个例子变换一下，将后面的 `llr` 提到前面来，变成了 `llrlr...lr`。  
继续往前面添加 `llr`，我们可以发现其在倒数第二个 `r` 处截断了神之字符串，此时神之字符串为 `rllrlr...lr`。

为了弥补 $n$ 与 $m$ 之间的差距，我们不断在前面补 `llr`，直到总长度到达 $n$。最后补的那一段可以不完整。

这样，我们成功地把前面那一段中神之字符串的最长长度控制在了 $4$。

然后我们可以向 $k \geq 3$ 来推广，可以发现上面的构造方法对与所有的 $k \geq 3$ 都是合法的。

## 构造

我们将我们的目标字符串分为两部分：`llr` 部分和 `lr` 部分。

`lr` 部分的长度是 $m-4$，因为题目保证了 $m$ 是偶数，所以直接接到尾部即可。

`llr` 部分的长度是 $n-m+4$。这一段最后可以不完整，直接循环即可。

考虑到从头插入字符不是很简单，我这里利用了 C++ 的 `string` 容器可以与其它 STL 容器一样使用 `push_back()` 的性质，向尾部添加字符之后再翻转。

示例代码：

``` cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1000010;
int main()
{
	int n, m, k;
	scanf("%d%d%d", &n, &m, &k);
	string res;
	if(k == 1 || n == m)
	{
		for(int i = 1; i <= n; i++)
		{
			if(i & 1)res.push_back('l');
			else res.push_back('r');
		}
		cout << res << endl;
		return 0;
	}
	for(int i = 2; i <= m - 4; i += 2)
	{
		res.push_back('r');
		res.push_back('l');
	}
	for(int i = 0; i * 3 < (n - m + 4); i++)
	{
		res.push_back('r');
		if(i * 3 + 1 == n - m + 4)break;
		res.push_back('l');
		if(i * 3 + 2 == n - m + 4)break;
		res.push_back('l');
	}
	reverse(res.begin(), res.end());
	cout << res << endl;
	return 0;
}
```

（如果有锅或者没有说明清楚的地方私信找我修）

---

## 作者：sgl654321 (赞：1)

##### 写在前面
赛时写挂了，打表找规律找了一小时愣是每找出来……

## 题目大意
输入三个数 $n$，$m$，$k$，其中 $m$ 为不小于 $4$ 的偶数，$n$ 为不小于 $4$ 的整数。

试构造一个字符串，由字符 ```l``` 和 ```r``` 构成。并且需满足以下条件：

- 字符串的长度为 $n$。
- 字符串中最长的 ```l``` 和 ```r``` 数量相等的字串长度为 $m$。
- 字符串中连续的相同字符数量不能超过 $k$。

## 解题思路
考虑部分分。

### Subtask 1，$k=1$
即连续的字符数量不能超过 $1$，因此就是 ```l``` 和 ```r``` 交替出现。
### Subtask 2，$n=m$
即字符串长度与最长的数量相等的子串长度相等。和 Subtask 1 一样，让 ```l``` 和 ```r``` 交替出现即可。前两个都很好想。
### Subtask 3，$k\ge 3$
连续的字符数量的上限比 $3$ 大。我们在做前面两个 subtask 时，想到了让 $l$ 和 $r$ 交替出现。因此我们考虑让**前 $m$ 个字符交替出现**，然后**后面的 $n-m$ 个字符都以 ```lllr``` 的形式出现**。可以[证明](https://www.luogu.com.cn/record/80456010)这种构造方法是对的。

证明： 设字符串的每一位分别为 $1,2,3,4\cdots$。

**条件 $1$：** 
$m+(n-m)=n$，该构造字符串长度为 $n$。 

**条件 $2$：**
在 $[1,m]$ 和 $[2,m+1]$ 中的字符构成 ```l``` 与 ```r``` 数量相等的子串，且长度均为 $m$。

假设还存在比 $m$ 长的这样的子串，考虑贪心得知是从 $2$ 号位置开始，但是在 $m+1$ 位置以后，每经过了一个 ```lllr``` 的子串，$l$ 的数量都会比 $r$ 多 $1$ 个（具体可以自己手动模拟参考）, 因此假设不成立。所以最长的这样的子串长度为 $m$。

**条件 $3$：**
在子串 $[1,m]$ 中最长相同字符数量为 $1$，在子串 $[m+1,n]$ 中最长相同字符数量为 $3$。因为 $k\ge 3$，所以整个字符串满足最长相同字符数量比 $k$ 小。

### Subtask 4，无特殊性质。
其实本 subtask 就是考察 $k=2$ 的情况。这个时候如果我们还按照 Subtask 3 的方法来构造的话，就会出现问题。

**有问题的方法**： 前 $m$ 个字符让 ```l``` 和 ```r``` 交替出现，之后的 $n-m$ 个字符以 ```llr``` 的形式出现，因为 $k=2$ 了。

那么我们来随便举一个样例：$n=10,m=6,k=2$。 按照如上方法，我们构造出来的字符串应该是 ```lrlrlrllrl```，但是我们发现 $[2,9]$ 的子串 ```l``` 和 ```r``` 的数量也相等。所以最长的这样的子串长度应该是 $8$ 了。

考虑新的构造方法，我们可能发现没有思路了，这时我们就可以用一种朴素的方法：[打表](https://www.luogu.com.cn/paste/7ql71t3z)找规律。

输进去几个样例，我们会发现有一种这样的构造方法：就是把第 $1$ 和 第 $2$ 个字符给调换一下，变成 ```rl```，其他都一模一样。例如刚才的样例，输出 ```rllrlrllrl```

我们要用严谨的态度来解决问题，所以我们再次[证明](https://www.luogu.com.cn/record/80453481)一下这样的正确性：

证明: 设字符串的每一位分别为 $1,2,3,4\cdots$。

**条件 $1$：**
不说了。

**条件 $2$：** 
仍然考虑贪心，得知是从 $2$ 号位置开始，能够得到长度最大的这样的字符串。但是这个时候，我们发现第 $2$ 个位置变成了 $l$。 因此，经过第一次 ```llr``` ，我们发现 ```l``` 的个数会比 ```r``` 多 $2$。此后每经过一次，差增加 $1$。所以最长的这样的子串就是 $[1,m]$，长度为 $m$。

**条件 $3$：** 
不说了。

因此这种构造方法是正确的。


## 代码
其实经过整合之后，Subtask 2 和 Subtask 3 都可以合并到 Subtask 4 里，所以只需要讨论 Subtask 1 和 Subtask 4 就可以了。我这里为了方便，把所有情况都写上了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,now,tot;
char a[100010];
bool p; 
int main(){
	cin>>n>>m>>k;
	if(k==1){
		for(int i=1;i<=n;i++)
			if(i%2==1)cout<<"l";
			else cout<<"r";
		return 0; 
	}
	if(n==m){
		for(int i=1;i<=n;i++)
			if(i%2==1)cout<<"l";
			else cout<<"r";
		return 0; 
	}
	if(k>=3){
		for(int i=1;i<=m;i++)
		if(i%2==1)cout<<"l";
		else cout<<"r";
		tot=m+1;
		now=1;
		while(tot<=n){
			if(now==1||now==2||now==3){
				cout<<"l";
				now++; 
			}else{
				cout<<"r";
				now=1;
			}
			tot++;
		}	
		return 0;
	}
	cout<<"rl";
	for(int i=3;i<=m;i++){
		if(i%2==1)cout<<"l";
		else cout<<"r";
	}
	for(int i=1;i<=n-m;i++)
		if(i%3==1||i%3==2)cout<<"l";
		else cout<<"r";
	cout<<endl;
	return 0;
}
```

[题目传送门](https://www.luogu.com.cn/problem/P8437)。不得不说这道题挺难的。

---

## 作者：幸存者 (赞：1)

## 思路
看到这道题后，不难想到这样一种构造方式：先将 `lr` 交替排列 $\dfrac{m}{2}$ 组，剩余 $n-m$ 个按 $k$ 个 `l`，一个 `r` 的方式排列，这样前 $m$ 个字符就构成了一个神之子串。

但是这样做有什么问题呢？不难发现当 $k=2$ 时第二个字符至第 $m+3$ 个字符构成了一个长度为 $m+2$ 的神之子串，不满足要求。

下面通过一个例子更好的理解一下：

当 $n=10,m=6,k=2$ 时，使用上述方法构造出的字符串会变成 `lrlrlrllrl`，最长的神之子串为第二个字符至第九个字符构成的长度为 $8$ 的字符串，不符合题意。这是因为当 $k=2$ 时，即使从第 $m+1$ 个字符开始交替排列的两个 `l` 比一个 `r` 多一个，但可以通过去掉字符串的第一个字符，添加字符串的从第 $m+1$ 个字符开始的三个字符，使得 `l` 和 `r` 的个数相同，从而使得最长神之子串的长度比 $m$ 多 $2$。

所以当 $k=2$ 时先将 $m$ 的值减二即可。
## $\text{AC Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    if (k == 2) m -= 2;
    for (int i = 1; i < m; i++) cout << (i % 2 == 1 ? 'l' : 'r');
    for (int i = m; i <= n; i++) cout << (i % (k + 1) == (m - 1) % (k + 1) ? 'l' : 'r');
    return 0;
}
```

---

## 作者：Ask_sum (赞：1)

# P8437 伟大的神 题解

P8437 这道题是本次月赛 T1，总体难度并不算高 ~~（然而我比赛时只打了 45pts）。~~

我本以为他是个大模拟，后来才发现这是个**数学题**。
## Sol 0 (Subtask 1 Subtask 2) 15pts
首先可以看到 Subtask 1 和 Subtask 2 的数据是极其地水。

Subtask 1 的数据 $k=1$，不用想，直接交替输出 ```lr``` 输出 $n$ 个字符即可。

Subtask 2 的数据 $n=m$，稍微一想就能想到也与上组一样交替输出。

~~然后你就能得到 15pts。~~ 

## Sol 1 (Subtask 3) 45pts
基于前面的 15pts，然后再看 Subtask 3。

当 $k \geq 3$ 时，显然可以在**前 $m$ 个字符**交替输出 ```lr```。

后面我们可以**输出 $k$ 个 ```l```，$1$ 个 ```r```**，这样轮回输出（只要判一下 $i \bmod (k+1)$ 就可以了）。

然后我们就能过掉 Subtask 3，得到 45pts。

## Sol 1.5 (Subtask 4) 45pts
考虑 $k=2$ 的情况，可以试图采用之前的算法，然而你会发现 WA 掉了。

可以发现每次发现输出被 hack 掉时，实际上神之子串的长度要比 $m$ 大 $2$，但是我不知道为什么我当时要打个 dfs（时间复杂度 $O(n^3)$，除了 WA 改成了 TLE 什么也没变）。

## Sol 2 (Subtask 4) 100pts
因为这道题是数学题，所以重新考虑 $k=2$ 的情况，有上个思路的神之子串的长度要比 $m$ 大 $2$，因为如果我们后面反复 ```llr```，所以从输出字符串的 $a_2$ 至 $a_{m+3}$ 位会成为一个神之子串，所以我们为何不把 ```lr``` 的循环条件改成 $m-2$ 呢？

实际上，正解正是这个！

所以，问题迎刃而解啦！

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, k;
int num = 1;

int main(){
	cin >> n >> m >> k;

	bool flag = true;//用来判别应该输出什么
	if(k == 1 || n == m){//15pts
		for(int i = 1; i <= n; i++)
			cout << (flag ? 'r' : 'l'), flag = !flag;
		return 0;
	}

	if(k >= 3){//45pts
		for(int i = 1; i <= m; i++){//前m位
			cout << (i % 2 ? 'l' : 'r');
		}
		for(int i = 1; i <= n - m; i++)//后面轮回输出
			cout << (i % (k + 1) ? 'l' : 'r');
		return 0;
	}
	if(k == 2){//100pts
		for(int i = 1; i <= m - 2; i++){//特判k==2，循环条件要减2
			cout << (i % 2 ? 'l' : 'r');
		}
		for(int i = 1; i <= n - m + 2; i++)
			cout << (i % (k + 1) ? 'l' : 'r');
	}
	return 0;
}

---

## 作者：ztlh (赞：1)

**~~考场上氵过A题就开始颓废，135分孤独终老。~~**

这是一道传统构造题，我们先来看部分分。

### Subtask 1：对于 $5\%$ 的数据，保证 $k=1$。

- 由于 **连续的相同的字符** 的数量 **不能超过** $k$，直接 $l$，$r$ 交替即可。

### Subtask 2：对于另外 $10\%$ 的数据，保证 $n = m$。

- 同 **Subtask 1**。

### Subtask 3：对于另外 $30\%$ 的数据，保证 $k \ge 3$。

- 考虑让前 $m$ 位作为“神之子串”，$l$，$r$ 交替出现，随后以 $3$ 个 $l$，$1$ 个 $r$ 为一个循环节，不难证明它的正确性。

### Subtask 4：无特殊性质。

- 根据前几个子任务的条件，我们可以得出：**这个子任务中，$k = 2$！**

- 然后就很明显了，还是让前 $m$ 位作为“神之子串”，其中前 $m - 2$ 位同 **Subtask 3**，$m - 1$，$m$ 位分别为 $r$ 和 $l$。

- 接下来以 $2$ 个 $r$，$1$ 个 $l$ 为循环节即可。

## AC代码（考场代码丑，请见谅）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main(){
	scanf("%d%d%d",&n,&m,&k);
	if(k==1||n==m){
		for(int i=1;i<=n;i++) printf("%c",i%2?'l':'r');
		return 0;
	}
	if(k==2){
		for(int i=1;i<=m-2;i++) printf("%c",i%2?'l':'r');
		printf("rl");
		char c1='l',c2='r';
		for(int i=1,j=1;i<=n-m;i++,j++){
			if(j%(k+1)==0) printf("%c",c1);
			else printf("%c",c2);
		}
		return 0;
	}
	for(int i=1;i<=m;i++) printf("%c",i%2?'l':'r');
	char c1='l',c2='r';
	for(int i=1,j=1;i<=n-m;i++,j++){
		if(j%(k+1)==0) printf("%c",c2);
		else printf("%c",c1);
	}
	return 0;
}
```

---

## 作者：Devwallem (赞：0)

### 一道有意思的思维题

拿到题目先考虑题意

1. 神之字符串 ： 指一段区间内，若  $l$ 和 $r$ 出现次数相等就可以被称为神之字符串。

2. 神之子串 ： 子串中有神之字符串就是神之子串，那最长子串也就是最长神之字符串

3. $k$ 值 ： 不能出现连续 $k+1$ 个相同字母

理解了题意，我们就开始分析，将问题拆分成最小可解单元，如何能在满足k值条件情况下 出现神之字符串 和 不出现神之字符串

观察 $lr$ 和 $rl$ 两种情况，他们自身都能满足以 $2$ 为单位成为一个神之字符串，那么只要连续出现 $m/2$ 个连续的这两个子串，就可以满足出现长度为 $m$ 的最长神之子串条件，又因为最小单元重复每个字母最多出现 $1$ 次，也就满足了 $k$ 的要求

在想如何不出现神之字符串，观察  $r\begin{matrix}k\\\overbrace{l...l}\end{matrix}$  和 $\begin{matrix}k\\\overbrace{l...l}\end{matrix}r$ 两种情况，其想成为对神之字符串有贡献，其后至少要补充 $k-1$ 个 $r$ ，我们只需要重复出现这两种单元中的一个，就能避免其对神之字符串进行贡献

思路明确之后，我们开始组合答案。首先要有一个不贡献部分，其长度为 $k+1$ ，贡献部分，其长度为 $m$ ，那么可以得到以下算式

$n = x(k+1) + m + (0/1)$

为什么会多出后面的 $(0/1)$ ，根据数学知识可以了解到$k \geqslant 1$，那么而 $ m = 2f $  ,其中 $f$ 为重复单元数，那么相当于答案肯定最后会对2取模，可能出现的常数就为 $(0/1)$ 

**但要注意一个问题，如果我们选取 $rlll$ 作为不贡献子串，而选 $lr$ 作为贡献子串，最后末尾的不贡献子串需要特殊处理，不然就不满足k的要求,因此更新算式**

$n = x(k+1) + k + m + b \Rightarrow n = (x+1)(k+1) + m -1 + b$ 

理解以上操作，我们在对 $k$ 进行细致考虑

$ k = 1$ 时，没有避免贡献结构，但题目保证一定有结果，所以最长子串一定等于 $n$

$ k \geqslant 3$ 时，不贡献组最小单元为 $rlll$ ，尾端为 $rll$ ，一定不影响贡献组贡献答案。

$ k = 2 $ 时，不贡献组最小单元为 $rll$ ，尾端为 $rl$ 变成了一个贡献组，那么就让贡献组数目减去 $1$ ，然后在末尾补上另一组不贡献组 $llr$ 防止出现错误

综上，可以得出代码的具体思路，有些地方可以简化，比如判断末尾位数，到代码里有注释。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+7;
int n,m,k;
int main()
{
	cin>>n>>m>>k;
	int lc = n - m + 1;
	int tot = lc / (k+1) - 1, y = n;
	// 完成算式 n = x(k+1) + k + m + b => n = (x+1)(k+1) + m - 1 + b
   // 因为可能有 k == 2 情况特判末尾比较繁琐 干脆直接计算剩余位数，也就是y的含义
	for(int i=1;i<=tot;i++) //补充不贡献组
	{
		cout<<"r";
		for(int i=1;i<=k;i++) cout<<"l";
		y = y - 1 - k;
	}
	if(tot >= 0) // 补充不贡献组末尾，只有存在不贡献组时，又因为tot的含义是不贡献组数目 - 1 那么当出现tot = 0说明不贡献组只有一组也是尾端组，才会有末尾组
	{
	    cout<<"r";
        for(int i=1;i<k;i++) cout<<"l";
        y = y - k;
	}
	int rc; //计算需要补充贡献组数目
	if(k == 2 && tot >= 0) rc = m/2 - 1;  //存在末尾组且k == 2时，才需要让贡献组减一
	else rc = m/2;
	for(int i=1;i<=rc;i++) 
	{
		cout<<"lr"; y = y - 2;
	}
	tot = y / (k+1); y = y % (k+1); //对剩余位数补充完整
	for(int i=1;i<=tot;i++)
	{
		for(int i=1;i<=k;i++) cout<<"l";
		cout<<"r";
	} 
	for(int i=1;i<=y;i++) cout<<"l";
	return 0;
}
```


---

## 作者：NightTide (赞：0)

这是一道不算太难的构造题，我们可以从每个 Subtask 一步步分析，有特殊的情况推广到更普遍的情况

#### Subtask 1

因为 $k = 1$，显而易见的，要求的字符串只能够是 `l` 和 `r` 交替排列的。

代码如下

```cpp
for(int i = 1; i <= n; i++){
    if(i % 2) printf("l");
    else printf("r");
}
printf("\n");
```

#### Subtask 2

因为 $n = m$，所以我们只需要让整个字符串中的 $l$ 和 $r$ 相等就可以了。为了满足连续的相同的字符的数量不能超过 $k$ 的限制，我们只需要构造一个 `l` 和 `r` 交替排列的字符串就好了，这和 Sub 1 的情况是一样的。

#### Subtask 3

Sub 3 给出的特殊性质是 $k \ge 3$，这似乎并没有起到什么提示作用，我们需要自己思考。

观察到题面对要求的字符串提出了三个限制：

> - 字符串的长度为 $n$。
> - 字符串中最长的神之字串长度为 $m$。
> - 字符串中连续的相同的字符的数量不能超过 $k$。

同时要求这个字符串只能够由 `l` 和 `r` 组成，并定义神之字串为 `所有出现的字符的数量相等的字符串`。

第一个和第三个限制比较容易满足，剩下的问题在于第二个限制。

考虑先构造一个长度为 $m$ 的神之字串，目前，第二个条件就满足了。这个长度为 $m$ 的神之子串也可以用之前 Sub 1 和 Sub 2 的构造方法。

但是我们的字符串还没有满足第一点限制。于是我们考虑在构造的长度为 $m$ 的字符串之后在不断添加字符，但必须维护已经满足了的限制二。

由于需要维护限制二，我们在之后就不能出现比 $m$ 更长的神之子串。考虑这样一种做法：假设我们前面构造的神之字串的最后一个字符是 `r`，我们不断重复以下过程

> 1. 连续添上 $k$ 个 `l`。
> 2. 添上 $1$ 个 `r`。

为什么这样能够保证之后就不会出现比 $m$ 更长的神之子串呢，我们可以模拟一下：

按照上面的方式构造出来的字符串是：

`lrlrlrlrlr……lr(长度为 m)lll……l(长度为 k)rlll……(长度为 k)r……`

首先考虑 $m$ 之后的情况。由于 $k \ge 3$，所以最好的情况是 `lllrlllrlll……`。

由于 $m \ge 4$，所以至少要两个 `r` 和两个 `l`。但是我们发现，如果要截取到两个 `r`，势必会截取到三个以上的 `l`。而如果 $k$ 更大的话，截取得到的 `l` 还会更多。

同样地，考虑后面一段在接上前面的 $m$ 个字符构成神之子串。

这显然也是不合理的。如果想要构造出来，就必须要有一个紧接在 $m$ 后面的一个神之子串，同样得不到。

于是代码新鲜出炉：

```cpp
 for(int i = 1; i <= m; i++){
     if(i % 2) printf("l");
     else printf("r");
 }
for(int i = m + 1; i <= n; i++){
    for(int j = 1; j <= k && i + j <= n; j++, i++){
        printf("l");
    }
    if(i <= n); printf("r");
}
```

#### Subtask 4

注意到我们前面的感性证明用到了 Sub 3 给出的特殊条件，如果 $k < 3$ 会怎么样呢？对于 $k = 1$ 的情况我们在 Sub 1 中做过了，接下来只需要考虑 $k = 2$ 的情况。

如果依旧按照之前做法，那么我们得出的字符串就是：

`lrlrlrlrlr……lr(长度为 m)llrllr……`

虽然从第一个字符算起后面添加的字符无法衔接上，但是如果从第二个字符算起答案就不同了。

`l` `rlrlrlrlr……l` `rllr` `llr……`

我把它们分隔开来，显然的，中间一段是长度为 $m - 2$ 的 `rlrlrlrl……` 序列，而后面的 `rllr` 也是一个神之子串。我们把它们接起来，就成为了一个长度为 $m + 2$ 的神之字串。这样一来，限制二就不满足了。

如何解决呢？既然答案会变成 $m + 2$，我们就把前面的序列缩短两个字符不就好了？

代码如下：

```cpp
for(int i = 1; i <= m - 2; i++){ // 这里是 m - 2 哦
    if(i % 2) printf("l");
    else printf("r");
}
for(int i = m - 1; i <= n; i++){
    for(int j = 1; j <= k && i + j <= n; j++, i++){
        printf("l");
    }
    if(i <= n); printf("r");
}
```



---

## 作者：luo_shen (赞：0)

**题意**  
构造一个字符串，使得其中 $l$ 与 $r$ 数量相等的子串长度最长为 $m$。而且连续的 $l$ 或 $r$ 的数量不得超过 $k$ , $m$ 一定为偶数。

**分析**  
1. 当 $k = 1$ 时，此时很明显，我们只需要一个 $l$ 一个 $r$ 输出就行。因为一定会有一个符合条件的字符串，所以此时 $n$ 一定等于 $m$。
2. 当 $k \neq 1$ 时，此时我们还是考虑到先一个一个输出。但我们不能直接输出总长度为 $m$ 的神之子串。如果这样输出，易证得当 $k=2$ 时，我们就一定会找到长度为 $m+2$ 的神之子串。所以我们将最后一个子串 $lr$ 变成子串 $rl$ , 接着再在后面接子串 $rrl$ ，此时对于任何一个长度为 $m+2$ 的子串，$r$ 的数量均会多于 $l$ 的数量。 

**代码**  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int main(){
    scanf("%d%d%d",&n,&m,&k);
    if(k==1){//第一种情况，k=1，依次输出
        bool f=0;
        for(register int i=1;i<=n;i++){
        	if(i&1){
        		putchar('l');
			}
			else{
				putchar('r');
			}
        }
        return 0;
    }
    //其它情况
    for(register int i=1;i<=m-2;i++){
        if(i&1){
            putchar('l');
        }
        else{
            putchar('r');
        }
    }//输出长度为m-2的lr子串
    putchar('r');
    putchar('l');//最后一个lr反向输出
    for(register int i=m+1;i<=n;i++){//输出rrl
        if((i-m)%3==0){
            putchar('l');
        }
        else{
            putchar('r');
        }
    }
    return 0;
}
```
完结撒花。

**题外话**  

请以后的出题团队不要再在A题出这种可怕的构造题了，太耗脑细胞了啊！！！

---

## 作者：CSP_Sept (赞：0)

## 题意

定义「神串」为所有出现的字符的数量相等的字符串，给定 $n,m,k$，要求构造一个仅由 $\tt l,r$ 构成的字符串 $s$，满足：

- $\text{length}(s)=n$；
- 「神串」$p$ 是 $s$ 的**子串**，则所有 $p$ 中，$\max\{\text{length}(p)\}=m$；
- $s$ 中的连续字符长度不得超过 $k$。

$1\le k\le 10^5$，$4\le m\le n\le 10^5$。

## 解法

无法令人理解的 adhoc 题，不知道为什么可以放在 2A，想出来之前感觉黄，想出来后代码实现红。感觉放在某本教材的例题供读者思考可能比较不错。

既然是 adhoc，那么我们来详细谈谈想到正解的过程。

___

我们先考虑如何构造出 $p$，显然 $p$ 的左右具有对称性，所以我们把 $p$ 置于 $s$ 的开头。需要最小化连续字符长度，那么我们重复 $0.5\cdot m$ 次 $\texttt{rl}$ 即可完成任务。

### Subtask 1 & 2

- $n=m$ 时我们已经完成任务；
- $k=1$ 时，我们有 $n-m\le 1$，证明显然，于是在后面直接补 $\texttt r$ 即可。

### Subtask 3

$k\ge3$ 的情况，考虑到我们不能出现除了 $p$ 外的其他「神串」，于是考虑让 $\tt l,r$ 中的某个字母出现次数远远大于另外一个，于是考虑后面跟个 $\texttt{ll}$。这样字符出现的次数 $c_\texttt l>c_\texttt r$，可以完成。

由于有 $k$ 的限制，我们无法继续添加 $\texttt l$ 来保证优势，所以考虑增加 $\texttt r$。然后我们需要迅速靠 $\texttt l$ 挽回局面。

所以考虑输出 $p$ 后循环构造 $\texttt{llr}$，发现一定符合条件。

至此我们解决了 $k\ge 3$ 的情况，那么 $k=2$ 显然会是一个瓶颈。

### Subtask 4

随机考虑一组 $k=2$，例如在此条件下 $n=10,m=4$，我们依照上述方法（即 $p$ 后三字母循环）随意构造一个 $s$：

$$
\texttt{r}\texttt{\color{#F07C82}lrllrr}\texttt{lrr}
$$

上面粉色部分是一个「神串」，且长度为 $6>4$（当然还有更长的，但没必要指出）。

构造几个后我们发现，这样的情况均发生与 $p$ 的后段与后面循环节的前段。

考虑破坏 $p$ 的后段，最后决定将 $p$ 的最后两个字符改为 $\texttt{lr}$。

这样我们可以在 $p$ 的后面仿照 Sub 3 的解法在后面循环构造 $\texttt{llr}$，容易发现这样和 Sub 3 是等价的。

有的读者可能会问，为什么我们不在开始就采用这样的方法？原因是显然的，因为 $p$ 的末尾也是 $\texttt l$。

这样我们就解决了 $k=2$ 的情况，容易发现这对 $k\ge 2$ 是普适的。

___

至此我们解决了本题的所有情况，读者不难看出部分分对正解的引导作用。

## 思考

读者不妨考虑一下本题的 SPJ 的重要组成部分，即下面的子问题：

>给定字符串 $s(1\le |s|\le 10^5)$，求出其中最长的「神串」子串 $p$ 的长度。

容易发现以空间换时间的 $O(n)$ 解法是显然的，即每次统计 $c_\texttt l-c_\texttt r$ 并将其下标插入桶中，每次查询求得最大值即可。

___

想掌握 adhoc 题的话，你还没关注蓝的 Ad-hoc 练习计划吗。

[指路](https://www.luogu.com.cn/blog/YakumoRanqwq/)。

---

## 作者：封禁用户 (赞：0)

首先题目**保证有解**，所以可以直接排除无解的情况，。

因为题目说了，对于 $100\%$ 的数据，保证 $1\le k\le10^5$，$4\le m\le n \le 10^5$，所以你开个 `int` 就好了。

题目分为两个思路：

- 由 `lr` 的顺序凑够 $m$ 个，也就是 $k=1$ 和 $n=m$ 的时候。

- 普通的方法，每次放 $k$ 个 $l$ 和 $1$ 个 $r$。

但是你得注意一个大坑点，就是当 $k=2$ 的时候，长度会多 $2$，所以这里要特判， $m$ 得减去 $2$ 。

最后请根据以上条件推出代码，代码不给了。

---

## 作者：Asimplename (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8437)

## 思路

$1. ~\texttt{Subtask 1、2}$

Subtask 1 中保证 $k=1$，也就是只能出现一个连续的字符。那么只能是 $l$ 和 $r$ 字符交替排列，即 $lrlrlr......$，我们只要保证这个字符串的长度为 $n$ 即可。

Subtask 2 中保证 $n = m$，也就是说构造出长度为 $m$ 的子串后，从第 $2,3,4...m$ 个字符开始到 $n$ 的子串的长度都不可能超过开始构造的长度为 $m$ 的子串。所以按照 Subtask 1 的构造方法构造即可。

$2. ~\texttt{Subtask 3}$

现在可以换一种思路。即构造完长度为 $m$ 的最长子串后，添加一个字符后保证整个字符串不是一个满足要求的字符串，长度为 $m$ 的这个子串就一定是最长的满足要求的子串。

所以对于第 $m + 1$ 到第 $n$ 个字符，每次判断如果连续的 $l$ 超过了 $k$，那么就加一个 $r$。否则增加一个 $l$。由于我们能加一个 $l$ 就加一个 $l$，这样的构造方法一定能保证 $l$ 和 $r$ 的个数不一样。

$3. ~\texttt{Subtask 4}$

但是按照上述构造方法，你会发现你只能得 $45$ 分。

问题其实出在了 $k=2$ 上。如果 $n=10,m=4,k=2$，程序会输出 $lrlrllrllr$，但是我们发现，虽然从第 $1$ 个字符到其他大于 $m$ 个的字符都不构成神之字符串，但是形成了一个神串 $rlrllr$，它的长度是大于 $4$ 的。

并且这个神串长度一定是 $m+2$，因为它包含了前面的 $m-1$ 个字符（不包含第一个字符），还有一个 $llr$。为什么其他数据不会出现这种情况？因为我们能加 $l$ 就加 $l$，其他情况不管从哪位开始，包含进去的 $l$ 和 $r$ 的数量都不可能相等。但 $k=2$ 的情况从第二位开始，也就是 $l$ 的数量先减 $1$，然后又加 $2$（$m$ 个字符后的 $ll$），相当于加 $1$，$r$ 的个数也加 $1$ 后和 $l$ 的个数一样了。

所以，我们只要判断 $k=2$，然后 $m-2$ 即可。这时我们刚才得出的更长的子串长度也会减二。就可以满足题目条件了。

## 代码：

```cpp
#include<iostream>
using namespace std;
int n,m,k = 0;
string str;
int lnum, rnum = 0;
int main () {
    cin >> n >> m >> k;
    if(k == 1 || m == n){
        for(int i = 1; i <= n; i ++){
            if(i % 2 == 0){
                cout << "r";
            }
            else{
                cout << "l";
            }
        }
    }
    else{
    	if(k == 2){
    		m -= 2;
		}
        for(int i = 1; i <= m; i ++){
            if(i % 2 == 0){
                str += 'r';
            }
            else{
                str += 'l';
            }
        }
        int ll = 0;
        if(m < n){
            for(int i = m + 1; i <= n; i ++){
                if(ll + 1 > k){
                    str += 'r';
                    ll = 0;
                }
                else{
                    ll ++;
                    str += 'l';
                }
            }
        }
    } 
    cout << str;
    return 0;
}

---


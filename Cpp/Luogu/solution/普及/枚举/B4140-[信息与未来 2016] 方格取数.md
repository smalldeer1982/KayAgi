# [信息与未来 2016] 方格取数

## 题目描述

在 $n$ 行 $m$ 列的方格矩阵中，每个方格都包含一个数字。小明可以从任意方格出发开始移动。每次移动可以移到与当前方格有一条边相邻的方格（即向上、下、左或右方向移动 $1$ 格，且不能移出边界）。除此之外，你移动到的方格中的数字必须比当前方格中的数字更大。

请你帮助小明编程规划移动路径，使路径上经过的所有数字之和最大。

## 说明/提示

### 样例 $\textbf 1$ 解释
样例数据 1 对应的矩阵如下。图中路径数字之和 $4+5+7+8=24$。
$$
\begin{array}{|c|c|c|c|c|}\hline 
9 & 7 & 10 & 10 & 8\\\hline
2 & 9 & 2 & 5 &3\\\hline
2 & 5 & \red5 & \red7 & 7\\\hline
5 & 8 & \red4 & \red8 & 5\\\hline
\end{array}
$$
### 数据范围
$1\le n,m\le 100,1\le s\le 19997$。
> 本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4 5 97```

### 输出

```
24```

## 样例 #2

### 输入

```
40 50 1```

### 输出

```
47```

# 题解

## 作者：Max_robot (赞：1)

这道题数据量很大，我们一条一条梳理。

#### 方格

注意到这道题方格里的数需要自己算出来，所以我们按照题目中的代码写一下就好了，问题应该不是很大。


```cpp
for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			s=(s*345)%19997;
			a[i][j]=(s%10)+1;
		}
	}
```

#### 搜索

这题的算法就是搜索，但是用记忆化搜索可以不重不漏的搜，然后里面可能参杂着一点动态规划的元素吧。

然后怎么搜就是文章的重点了。

首先，我们判断这个点我们是不是已经找到了，如果是，我们就直接返回，否则就继续。

然后我们枚举上下左右四个方向，我们可以用两个数组来表示四个方向。然后呢，判断四个方向是否都是成立的。如果成立，就判断这个点原来的数是不是比四个方向的数大，如果大就交换。

我们再来讲判断条件。判断条件就简单了。首先看这个点是不是在方格里面，然后判断这个点的元素是不是比我们要算的点的元素要大。如果都满足，比较就行了。如何比较请看上一段。


```cpp
long long dx[4]={-1, 1, 0, 0}, dy[4]={0, 0, -1, 1};
long long f(int x, int y) {
    if(dp[x][y]) return dp[x][y];
    dp[x][y]=a[x][y];
    for(int i=0;i<4;i++){
        int nx=x+dx[i], ny=y+dy[i];
        if (nx>=1 && nx<=n && ny>=1 && ny<=m && a[nx][ny]>a[x][y]){
            dp[x][y]=max(dp[x][y], f(nx, ny)+a[x][y]);
        }
    }
    return dp[x][y];
}
```


#### 答案

注意哈，题目没有固定起点和终点，所以我们就不能直接输出。而是找方格里面的最大值输出。


```cpp
for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)	
			ans=max(ans,f(i,j));
```

#### 代码

把代码拼一拼就好了，注释放在下面了。


```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long n, m, s;
long long a[1010][1010];
long long dp[1010][1010];//每个点的答案
long long dx[4]={-1, 1, 0, 0}, dy[4]={0, 0, -1, 1};//四个方向
long long ans;//最终答案
long long f(int x, int y) {
    if(dp[x][y]) return dp[x][y];//如果早就找到了，那就直接返回这个答案
    dp[x][y]=a[x][y];//把这个点的答案先初始化成这个点的数
    for(int i=0;i<4;i++){//枚举四个方向
        int nx=x+dx[i], ny=y+dy[i];//坐标
        if (nx>=1 && nx<=n && ny>=1 && ny<=m && a[nx][ny]>a[x][y]){//如果成立
            dp[x][y]=max(dp[x][y], f(nx, ny)+a[x][y]);//看我从哪个方向过来最划算
        }
    }
    return dp[x][y];//返回这个点的答案
}
int main(){
    cin>>n>>m>>s;//输入答案
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			s=(s*345)%19997;//构造方格里面的数
			a[i][j]=(s%10)+1;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)	
			ans=max(ans,f(i,j));//寻找答案
	cout<<ans<<endl;//输出答案
    return 0;//结束程序
}
```

---

## 作者：lizhixun (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/B4140)

### $\texttt{Description}$

有一个 $n$ 行 $m$ 列的数字矩阵，我们从一个点出发，每次只能向这个点四周比它大的数字所在的点移动。现在你可以选择一个点出发，问移动到的点上所有的数字的总和的最大值是多少？

### $\texttt{Solution}$

首先数字矩阵中的值是需要我们自己生成的，只需要根据题意模拟即可。注意题目中的左箭头就是赋值符号。

接着我们考虑正解，最合适的是记忆化搜索。因为 $n,m \le 100$，所以直接无脑爆搜是会超时的。

我们定义 $dp_{x,y}$ 是从坐标为 $(x,y)$ 的点出发能够获得的最大总和的值，则答案就是 $\max\{dp_{x,y}\}$，其中 $\begin{cases} 1 \le x \le n \\ 1 \le y \le m\end{cases}$ 是 $x,y$ 的取值范围。

- 状态转移：$dp_{x,y}=\max(dp_{x,y},f(tx,ty)+a_{x,y})$。其中 $f(tx,ty)$ 是搜索函数，表示即将要去的点能够获得的最大总和的值，而 $a$ 就是矩阵。

- 初始化：$dp$ 数组最开始全部赋值为 $-1$，在搜索时 $dp_{x,y}$ 的初始值为 $a_{x,y}$。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int maxn = 1e3 + 5;
int n, m, s, a[maxn][maxn];
int ans = INT_MIN, dp[maxn][maxn];

const int fx[] = {0, 0, 1, 0, -1};
const int fy[] = {0, 1, 0, -1, 0};

void init() {
	cin >> n >> m >> s;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			s = (s * 345) % 19997;
			a[i][j] = (s % 10) + 1;
		}
	}
	
	memset(dp, -1, sizeof(dp));
	return;
}

int dfs(int x, int y) {
	if (dp[x][y] != -1) return dp[x][y];
	
	dp[x][y] = a[x][y];
	for (int i = 1; i <= 4; i++) {
		int tx = x + fx[i];
		int ty = y + fy[i];
		if (tx <= 0 || tx > n || ty <= 0 || ty > m) continue;
		if (a[tx][ty] <= a[x][y]) continue;
		dp[x][y] = max(dp[x][y], dfs(tx, ty) + a[x][y]);
	}
	
	return dp[x][y];
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	init();
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			ans = max(ans, dfs(i, j));
		}
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：_Deer_Peach_ (赞：0)

题意：

给出构造方格矩阵的方法，可以从任意方格出发，每次走到相邻的一个比该方格值小的方格，求最大路径之和。

思路：

构造矩阵的方法给了，模拟即可：
```cpp
for(int i=1;i<=n;i++){
	for(int j=1;j<=m;j++){
		(s*=345)%=Mod;
		num[i][j]=(s%10)+1;
	}
}
```

起点不固定，数据范围小，所以枚举每一个点作为起点时的最大路径之和。求最大路径之和就是简单的搜索。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=105,Mod=19997;
int n,m,s;
int num[N][N];
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};
signed main() {
	IOS;cin>>n>>m>>s;
	for(int i=1;i<=n;i++){//构造出矩阵
		for(int j=1;j<=m;j++){
			(s*=345)%=Mod;
			num[i][j]=(s%10)+1;
		}
	}int res=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){//枚举起点
			queue<int>qx,qy,qs,qne;//搜索答案
			qx.push(i),qy.push(j),qs.push(num[i][j]),qne.push(num[i][j]);
			while(!qx.empty()){
				int Tx=qx.front();
				int Ty=qy.front();
				int ans=qs.front();
				int nex=qne.front();
				res=max(res,ans);
				qx.pop(),qy.pop(),qs.pop(),qne.pop();
				for(int k=0;k<4;k++){
					int tx=Tx+dx[k];
					int ty=Ty+dy[k];
					if(tx<1||ty<1||tx>n||ty>m||num[tx][ty]>=nex)continue;
					qx.push(tx),qy.push(ty),qs.push(ans+num[tx][ty]),qne.push(num[tx][ty]);
				}
			}
		}
	}cout<<res;return 0;
} 
```

---


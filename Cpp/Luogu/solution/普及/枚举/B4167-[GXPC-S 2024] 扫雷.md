# [GXPC-S 2024] 扫雷

## 题目背景

小林最近迷上了扫雷游戏。

## 题目描述

一个扫雷游戏可以被抽象成一个 $n$ 行 $m$ 列的字符矩阵，不妨记第 $i$ 行第 $j$ 列的字符为 $S_{i,j}$。

若 $S_{i,j}=\texttt{*}$，表示格子 $(i,j)$ 上有一个地雷；

若 $S_{i,j}=\texttt{?}$，表示格子 $(i,j)$ 情况未知；

若 $S_{i,j}\in [0,8]$，表示格子 $(i,j)$ 周围的 $8$ 个格子中有 $S_{i,j}$ 个地雷（这个格子本身没有地雷）。
形式化地说，记

$$
f(i,j)=\begin{cases}
1, & (i,j)\text{ 上有地雷} \\
0, & \text{其他情况} \\
\end{cases}
$$

特别地，对于超出棋盘边界的情况，规定 $f(i,j)=0$。
则 $\displaystyle S_{i,j}=\sum_{p=-1}^1\sum_{q=-1}^1 f(i+p,j+q)$。

给定一个棋盘，你可以任意决定每个 $\texttt{?}$ 格子上是否有炸弹。你想要知道是否存在方案使得这个棋盘是合法的。
我们定义一个棋盘**合法**，当且仅当填有数字 $x$ 的格子周围的八个格子上恰好有 $x$ 个炸弹。

你需要解决 $T$ 组数据。

## 说明/提示

对于第一组数据：问号处选择不填是一种合法方案。可以证明这是唯一的合法方案。

**本题采用捆绑测试。**

- Subtask 1（20pts）：至多存在 $1$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- Subtask 2（80pts）：无额外约束。

对于 $100\%$ 的数据，保证：

- $1\le T,n,m\le 10$；
- 至多存在 $10$ 组 $(i,j)$，使得 $S_{i,j}=\texttt{?}$；
- $\forall 1\le i\le n,1\le j\le m$，保证 $S_{i,j}\in\{0,1,2,3,4,5,6,7,8,\texttt{?},\texttt{*}\}$。


## 样例 #1

### 输入

```
3
2 2
**
2?
2 2
*1
3?
2 2
**
21```

### 输出

```
YES
NO
NO```

# 题解

## 作者：Sliarae (赞：0)

注意到数据范围中说，至多存在 $10$ 组 $(i, j)$，使得 $s_{i, j} = \texttt{?}$。

这说明可能的地雷分布是很少的，具体而言枚举每个 $\texttt{?}$ 是不是地雷，只有不超过 $2^{10}$ 种状态，先把它们全部搜出来。

接下来问题就是判合法性。原先已经确定不是地雷的格子会有形如“与格子 $(i, j)$ 八连通的格子中，有恰好 $k$ 个是地雷”，枚举 $8$ 个格子判断一下，如果所有限制全部满足就输出 `Yes`。

时间复杂度 $O(nm2^k)$。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int kN = 12;

int n, m;
char s[kN][kN];

void Solve () {
	cin >> n >> m;
	vector<pair<int, int>> vec;
	for (int i = 1; i <= n; ++i) 
		for (int j = 1; j <= m; ++j) { 
			cin >> s[i][j];
			if (s[i][j] == '?') vec.push_back({i, j});
		}
	bool ans = 0; 
	for (int st = 0; st < (1 << vec.size()); ++st) {
		for (int i = 0; i < vec.size(); ++i) {
			int x = vec[i].first, y = vec[i].second;
			s[x][y] = ((st >> i) & 1 ? '*' : '.');
		}
		bool valid = 1;
		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= m; ++j) {
				if (s[i][j] >= '0' && s[i][j] <= '8') {
					int cnt = s[i][j] - '0';
					const int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
					const int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};
					for (int k = 0; k < 8; ++k) {
						int x = i + dx[k];
						int y = j + dy[k];
						if (x >= 1 && x <= n && y >= 1 && y <= m && s[x][y] == '*')
							--cnt;
					} 
					valid &= !cnt;
				}
			}
		}
		ans |= valid;
	}
	cout << (ans ? "YES" : "NO") << '\n';
}

int main () {
	cin.tie(0)->sync_with_stdio(0);
	int T;
	cin >> T;
	while (T--) Solve();
	return 0; 
}
```

---


# [常州市赛 2021] 烧菜

## 题目背景

搬运自 <http://czoj.com.cn/p/440>。

## 题目描述

小 $\text{X}$ 正在指挥 $M$ 个机器人做一道家常菜：白灼青菜。  
把一根青菜烧成菜肴需要两个步骤：洗菜和水煮。显然，一根青菜不可能同时被清洗和水煮，也不可能先被水煮后被清洗。  
现在小 $\text{X}$ 告诉你他是怎么指挥的。每当一个机器人空下来： 
- 如果有青菜还没被清洗，就让这个机器人清洗这根青菜
- 否则如果有青菜还没被水煮，就让这个机器人水煮这根青菜
- 都没有就让这个机器人关机

现在一共需要把 $N$ 根青菜烧成菜肴，任何一个机器人清洗都要花 $A$ 分钟，水煮要花 $B$ 分钟。小 $\text X$ 想请你告诉他多少分钟后所有菜能被烧好。

## 说明/提示

### 样例解释
为了方便说明，把机器人标号为 $1$ 号机器人和 $2$号机器人；把青菜标号为 $1$ 号、 $2$ 号、 $3$ 号青菜。实际上，机器人间是没有区别的，青菜间也是没有区别的。  
- 第 $0$ 分钟， $1$ 号机器人开始洗 $1$ 号青菜， $2$ 号机器人开始洗 $2$ 号青菜。  
- 第 $9$ 分钟， $1$ 号机器人开始洗 $3$ 号青菜， $2$ 号机器人开始煮 $1$ 号青菜。  
- 第 $14$ 分钟， $2$ 号机器人开始煮 $2$ 号青菜。  
- 第 $18$ 分钟， $1$ 号机器人开始煮 $3$ 号青菜。  
- 第 $19$ 分钟， $2$ 号机器人关机。  
- 第 $23$ 分钟，所有菜都被烧好了， $1$ 号机器人关机。
### 数据范围
本题共有 $20$ 个测试点。  
对于所有数据，满足 $1\le N,M,A,B\le 2000$。
|测试点编号|$N,M,A,B$|特殊性质|
|:-:|:-:|:-:|
|$1\sim2$|$\le50$|$M>N$|
|$3\sim4$|$\le50$|$M=1$|
|$5\sim6$|$\le50$|$A=B$|
|$7\sim10$|$\le50$|无|
|$11\sim12$|$\le2000$|$M>N$|
|$13\sim14$|$\le2000$|$M=1$|
|$15\sim16$|$\le2000$|$A=B$|
|$17\sim20$|$\le2000$|无|

## 样例 #1

### 输入

```
3 2 9 5```

### 输出

```
23```

# 题解

## 作者：Sliarae (赞：2)

容易想到维护一个小根堆 $q$，$q$ 中的一个数 $x$ 表示在 $x$ 时刻一个机器人做完了手中的事情，处于空闲状态。

那么我们一开始在 $q$ 中加入 $m$ 个 $0$。每次取 $q$ 的堆顶 $t$。此时我们认为已经到达了时间 $t$，于是就获得一个空闲的机器人。

我们给它分配任务：维护未清洗的白菜数量 $p$ 和未水煮的白菜数量 $q$。若 $p > 0$，则让这个机器人在 $[t, t + a)$ 这个时间段内清洗白菜，相当于在 $q$ 中加入 $t + a$，并令 $p \gets p - 1$。否则类似的在队列中加入 $t + b$，并令 $q \gets q - 1$。

但是这样做有问题。可能出现一个机器人想煮菜，但还没有菜被洗完的情况。hack 数据如下：

```
3 2 1000 1 
```

这时上述算法会输出 `2000`，但答案为 `2001`。

考虑额外维护小根堆 $p$，表示下一个洗完的白菜什么时候才能到。一个时间为 $t$ 的机器人洗菜的时候同时在 $p, q$ 中加入 $t + a$。而煮菜的时候判一下 $t$ 是否小于 $p$ 的堆顶，如果小于就将 $p$ 的堆顶放入 $q$，并什么也不做。

```cpp
#include <iostream>
#include <queue>

using namespace std;

int n, m, t, a, b;

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n >> m >> a >> b, t = n, m = min(m, n);
	priority_queue<int, vector<int>, greater<int>> q, p;
	for (int i = 1; i <= m; ++i) q.push(0);
	while (n || t) {
		int tp = q.top();
		q.pop();
		if (n) --n, p.push(tp + a), q.push(tp + a);
		else if (tp + b < p.top()) q.push(p.top()); 
		else --t, p.pop(), q.push(tp + b);
	}  
	int ans = 0; 
	for (; !q.empty(); q.pop()) ans = q.top();
	cout << ans << '\n';
	return 0; 
}
```

---

## 作者：why17 (赞：1)

看到这道题题解居然只有两篇，~~那我也来水一篇吧~~

我们可以用一个小根堆来维护每个机器人的可用时间点，然后循环分配任务，如果有未清洗的青菜，就分配清洗任务，水煮任务也是一样的逻辑。注意题目中的一个关键点：如果一个机器人空闲时没有任务可以分配，这个机器人就会关机（后续的任务这个机器人就不能参加了）。这也是导致我调了好久的原因。再用两个小根堆来存储每次清洗和水煮任务的完成时间，所有任务都分配完毕后再取出最后一次水煮的结束时间就是答案（即总共用时）。

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,b;
priority_queue<int,vector<int>,greater<int> > q,t1,t2;//t1，t2分别存储清洗和水煮任务的完成时间
int main(){
	cin>>n>>m>>a>>b;
	for(int i=0;i<m;i++) q.push(0);//初始可用时间为0
	int cnt1=0,cnt2=0;
	while(cnt1<n||cnt2<n){//循环分配任务
		if(q.empty()) break;//没有可用机器人
		int time=q.top();
		q.pop();
		if(cnt1<n){
			t1.push(time+a);
			q.push(time+a);
			cnt1++;
		}
		else if(cnt2<n){
			if(t1.empty()) break;//没有已经清洗好的青菜就不能开始水煮
			int st=max(time,t1.top());
			t1.pop();
			t2.push(st+b);
			q.push(st+b);
			cnt2++;
		}
		else continue;
	}
	int ans=0;
	while(!t2.empty()){//寻找最后一个水煮任务的完成时间
		ans=t2.top();
		t2.pop();
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：Manchester_City_FC (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4204)

简单的模拟题。

先模拟完成每根青菜的清洗并记录各蔬菜的结束时间，然后对这些时间进行排序，再利用机器人当前空闲时间模拟水煮任务，注意水煮开始时间必须不早于相应蔬菜的清洗结束时间。

时间复杂度 $\mathcal O(nm)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2001;
int n,m,a,b,x[N],y[N],z[N],ans;
int main(){
    cin>>n>>m>>a>>b;
    //每次选择最早空闲的机器人给下一根青菜洗菜
    for(int i=1;i<=n;i++){
        int p=x[1],q=1;
        for(int j=2;j<=m;j++){
            if(x[j]<p){
                p=x[j];
                q=j;
            }
        }
        y[i]=x[q]+a,x[q]=y[i];
    }
    sort(y+1,y+n+1);
    for(int i=1;i<=m;i++) z[i]=x[i];
	// 将各机器人在完成洗菜之后的空闲时间复制到新的数组中，
    // 这就是水煮任务开始时各机器人可用的起始时间
    for(int i=1;i<=n;i++){
        int p=z[1],q=1;
        for(int j=2;j<=m;j++){
            if(z[j]<p){
                p=z[j];
                q=j;
            }
        }
        z[q]=max(z[q],y[i])+b;
    }
    for(int i=1;i<=m;i++) ans=max(ans,z[i]);
    cout<<ans;
}
```

---


# [常州市赛 2021] 数字翻转

## 题目背景

搬运自 <http://czoj.com.cn/p/442>。数据为民间数据。

## 题目描述

小 $\text X$ 在做数学题的时候发现了一类有趣的数字。把这样的数字写在一张不透明的纸上，倒过来（把纸旋转 $180$ 度，转轴垂直于纸面）看还是同样的数字。例如 $69$ 就是这样的数字。  

![](https://cdn.luogu.com.cn/upload/image_hosting/71ognnjx.png)

注意，小 $\text X$ 用的是以下字体：  

![](https://cdn.luogu.com.cn/upload/image_hosting/ll5qcrqa.png)

现在小 $\text X$ 会问你 $Q$ 次问题，每次问你 $L$ 到 $R$ 之间有多少个这样有趣的数字。

## 说明/提示

### 样例解释
$1$ 到 $260$ 中有趣的数字： $2,5,8,22,55,69,88,96,202,222,252$。
### 数据范围
本题共有 $10$ 个测试点，每个测试点 $10$ 分。  
对于所有数据，$1\le Q\le10^5$，$1\le L\le R<10^{14}$。
|测试点编号|$Q$|$R$|
|:-:|:-:|:-:|
|$1$|$=1$|$<10$|
|$2$|$\le10^5$|$<10$|
|$3$|$=1$|$<10^3$|
|$4$|$\le10^5$|$<10^3$|
|$5$|$=1$|$<10^6$|
|$6$|$\le10^5$|$<10^6$|
|$7$|$=1$|$<10^{10}$|
|$8$|$\le10^5$|$<10^{10}$|
|$9$|$=1$|$<10^{14}$|
|$10$|$\le10^5$|$<10^{14}$|


## 样例 #1

### 输入

```
3
1 260
3333 8888
1 1234567654321```

### 输出

```
11
17
77758```

# 题解

## 作者：joshua0729 (赞：0)

# B4206 [常州市程序设计小能手 2021] 数字翻转 
## 思路
### 暴力
~~首先考虑打表~~，看一眼数据范围，$10^{14}$，啥都不用想，就算你打出了数组代码也一定会太长。

那么，我们就可以写一个函数，遍历 $L$ 到 $R$ 之间的数，检查，如果是，就增加答案数。

70 分的超时代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int change[10]={0,-1,2,-1,-1,5,9,-1,8,6};
//#define int unsigned long long
int daozhi(int x){
	int ans=0;
	while(x!=0){
		ans+=x%10;
		x/=10;
		ans*=10;
	}
	return ans/10;
}
int weishu(int x){
	int ans=0;
	while(x!=0){
		ans++;
		x/=10;
	}
	return ans;
}
string check(int x){
	x=daozhi(x);
	int n=weishu(x);
	string ans=to_string(x);
	for(int i=0;i<n;i++){
		ans[i]=change[ans[i]-'0']+'0';
	}
	return ans;
}
signed main(){
	int T;
	cin>>T;
	while(T--){
		int l,r;
		cin>>l>>r;
		int ans=0;
		for(int i=l;i<=r;i++){
			if(check(i)==to_string(i)){
				ans++;
			}
		}
		cout<<ans<<endl;
	}
    return 0;
}
```
### 优化
#### 优化思路
可以看到，在 70 分代码中，数字在翻转时调用了很多的函数，导致时间复杂度爆炸。我们可以优化这个翻转的过程。
#### 优化过程
首先看到翻转数字的部分。我把两部分分开了，但是可以把两部分合到一起。

再看到检查函数部分。我的写法是每一位先翻转再把翻转后的结果返回并比较两个结果的关系。但是其实可以一边剥离每一位，另一边检查这一位翻转后是否有意义，并合成回原数字。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll q,r,l,a[11]={0,-1,2,-1,-1,5,9,-1,8,6};
int main(){
    cin>>q;
    for(int i=1;i<=q;i++){
        cin>>l>>r;
        int cnt=0;
        for(int j=l;j<=r;j++){
            bool vis=true;
            int t=j,f=0;
            while(t){
                if(a[t%10]==-1){
                    vis=0;
                    break;
                }
                f=f*10+a[t%10];
                t/=10;
            }
            if(f==j&&vis==1){
                cnt++;
            }
        }
        cout<<cnt<<endl;
    }
    return 0;
}
```
[通过记录](https://www.luogu.com.cn/record/216743302)

---

## 作者：Ag2WO4 (赞：0)

这数位 DP 细节量也太爆炸了吧？

#### 思路
首先枚举成对外壳的所有可能性，有 $00,22,55,69,88,96$ 六种选择，它们是翻转不变的；然而如果位数为奇数，中间的芯就只有 $0,2,5,8$ 四种选择；

接下来，从外向内统计外壳严格小于目标值时中间剩余自由数字位数能带来的总可能性数，若位数 $n$ 为偶数即为 $6^{\frac n2}$ 种（即六的外壳层数次幂），否则为 $4\times6^{\lfloor\frac n2\rfloor}$ 种，即在前者基础上再乘以内芯的可能性数。最后特判不保证外壳严格小于目标值的最终状态是否符合。差分即可。复杂度 $O(q\log n)$。

#### ~~爆多的~~注意事项
1. 注意外壳是两位两位剥离的，所以要单独加上奇偶性不同的那一系列的总和；前导零不需要单独考虑，刚好象征着更小的值（把前导零和成对的后缀零抹了就是少两位的情况）。我的做法其实会多算一个零，但是差分的时候会差分掉所以就没特判。
2. 注意 $6$ 和 $9$ 不能当芯。
3. 最后特判时，要求差分被减数目标值**大于等于**最终状态，减数目标值**严格大于**最终状态。
#### 代码
```python
for _ in range(int(input())):
    a,b=input().split();d=len(a);e=len(b);c=6**((e-1)//2)*4**((e-1)&1)-6**((d-1)//2)*4**((d-1)&1)
    for i in range((d+1)//2):
        x=6**(d//2-1-i)*4**(d&1)if d-i*2>1 else 1
        if'0'<a[i]:c-=x
        if'2'<a[i]:c-=x
        if'5'<a[i]:c-=x
        if'6'<a[i]and d-i*2>1:c-=x
        if'8'<a[i]:c-=x
        if a[i]not in'025689':break
    if all(i in'025689'for i in a[:(d+1)//2])and not(d&1 and a[d//2]in'69')and a[:d//2]+a[(d-1)//2::-1].replace('6','.').replace('9','6').replace('.','9')<a:c-=1
    for i in range((e+1)//2):
        x=6**(e//2-1-i)*4**(e&1)if e-i*2>1 else 1
        if'0'<b[i]:c+=x
        if'2'<b[i]:c+=x
        if'5'<b[i]:c+=x
        if'6'<b[i]and e-i*2>1:c+=x
        if'8'<b[i]:c+=x
        if b[i]not in'025689':break
    if all(i in'025689'for i in b[:(e+1)//2])and not(e&1 and b[e//2]in'69')and b[:e//2]+b[(e-1)//2::-1].replace('6','.').replace('9','6').replace('.','9')<=b:c+=1
    print(c)
```

---


# [蓝桥杯青少年组国赛 2022] 翻卡片

## 题目描述

小蓝在玩翻卡片游戏，每张卡片一面写着大写字母 `A`，另一面写着大写字母 `B`。首先将卡片排成一个 $N \times N$ 的矩阵。有的卡片是 `A` 面朝上，有的卡片是 `B` 面朝上。

现给定 $N$ 的值，及 $N \times N$ 矩阵中每张卡片的状态，请你帮助小蓝挑选一张 `B` 面的卡，翻转成 `A` 面，使得翻转后的上、下、左、右四个方向相连的 `A` 面卡片最多，并将相连最多的卡片数量输出。

例如：$N=3$，$3 \times 3$ 的矩阵中的卡片状态如下：

| A | B | B |
|---|---|---|
| A | B | A |
| B | A | B |

选择第二行第二列的那张 `B` 面卡片，翻转为 `A` 面，可以使翻转后四个方向相连的 `A` 面卡片最多，为 $5$ 张。

| A | B | B |   | A | B | B |
|---|---|---|---|---|---|---|
| A | B | A | $\rightarrow$ | A | A | A |
| B | A | B |   | B | A | B |

## 样例 #1

### 输入

```
3
A B B
A B A
B A B```

### 输出

```
5```

# 题解

## 作者：yuruilin2026 (赞：3)

## 一些闲话：
膜拜神犇 [Hootime](https://www.luogu.com.cn/user/1275540)。
## 思路：
超级大暴力，枚举翻转哪一个卡片，然后用一个搜索判断有多少个联通的 `A` 卡片。\
接下来给所有枚举的 `B` 卡片搜到的答案取最大值就完了。
## AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define max(a,b) (a>b?a:b)
int n,ans,now,fx[4] = {1,0,-1,0},fy[4] = {0,1,0,-1};
char a[55][55];
bool vis[55][55];
void check(int x,int y){
	++now;
	vis[x][y] = 1;
	for(int i = 0;i < 4;++i){
		int xx = x + fx[i],yy = y + fy[i];
		if(xx <= 0 || yy <= 0 || xx > n || yy > n || vis[xx][yy] == 1 || a[xx][yy] == 'B') continue;
		check(xx,yy);
	} 
}
signed main(){
    cin.tie(0),cout.tie(0);
    cin >> n;
    for(int i = 1;i <= n;++i){
		for(int j = 1;j <= n;++j){
			cin >> a[i][j];
		}
	}
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= n;++j){
			if(a[i][j] == 'A') continue;
			memset(vis,0,sizeof(vis));//初始化 
			a[i][j] = 'A',now = 0;//初始化*2 
			check(i,j);//搜索看看有几个A联通 
			ans = max(now,ans);//取最大值 
			a[i][j] = 'B'; 
		}
	}
	cout << ans;
    return 0;
}
```

---

## 作者：xuyixuan_123 (赞：2)

[B4297 [蓝桥杯青少年组国赛 2022] 翻卡片](https://www.luogu.com.cn/problem/B4297)  
刚学 DFS ，我就用 DFS 写吧。
## 思路：
对于每个 ```B``` 面卡片，把它翻转成 ```A``` 面卡片后，只要 ```A``` 面卡片连通块的大小比之前大，就更新答案，并复原卡片，最后输出。  
懂了思路后，就可以开始写了。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int n,ans,cnt;
char a[60][60];
bool vis[60][60];
void dfs(int x,int y){
	vis[x][y]=true;
	cnt++;
	for(int i=0;i<4;i++){
		int tx=x+dx[i];
		int ty=y+dy[i];
		if(tx>=1 && tx<=n && ty>=1 && ty<=n && !vis[tx][ty] && a[tx][ty]=='A'){//判断边界是个好习惯 
			dfs(tx,ty);
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(a[i][j]=='B'){
				cnt=0;
				memset(vis,0,sizeof(vis));//清除vis数组 
				a[i][j]='A';
				dfs(i,j);
				a[i][j]='B';//回溯 
				ans=max(ans,cnt);
			}
		}
	}
	cout<<ans;
	return 0;
}
```
最后提醒一句：题解虽好，但不能抄袭哟！

---

## 作者：Blackox_xxx (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4297)

其实就是一道连通块的模板题。

## 连通块的实现

一般来说，连通块的实现方法都是一致的，那就是使用 dfs。 

在当前方格中，向四个方向扩散，判断它们是否越界，是否在扩散后方格中的字母或数字是不是合法的，是否已经走过了。在此题中，不合法的就是字母 `B`，然后设定此方格**已经走过了**，将答案增加一，然后再对这个合法的方格再次进行这样的操作，直到没有一个方格是连通且合法的。

## 代码实现

由于本题中不合法的是字母 `B`，可以得到这样的判断代码：
```cpp
if(newx >= 1 && newx <= N && newy >= 1 && newy <= N && g[newx][newy] == 'A' && vis[newx][newy] == false)
```

其中，$newx$ 代表着向四面扩散后的新的 $x$，$newy$ 同理，布尔数组 $vis$ 代表是否已经走过。

而我们每次枚举矩阵数组 $g$ 中的 `B`，可以作出这样的代码：

```
for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
        {
            if(g[i][j] == 'B')
            {
                memset(vis, false, sizeof vis);
                g[i][j] = 'A';
                vis[i][j] = true;
                cnt = 1;
                dfs(i,j);
                ans = max(ans,cnt);
                g[i][j] = 'B';
            }
        }
    }
```

其中，$cnt$ 代表本次选择的翻片所可以带来的连通数，$ans$ 代表最终的答案。

**写 memset 时要记得带上头文件 cstring。**

最后，我们就可以得到完整的代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int cnt = 0;
int ans = 0, N;
bool vis[55][55];
char g[55][55];
int dx[] = {0,0,1,-1};
int dy[] = {1,-1,0,0};
void dfs(int x, int y)
{
    for(int i = 0;i < 4; i++)
    {
        int tx = x + dx[i],ty = y + dy[i];
        if(tx >= 1 && tx <= N && ty >= 1 && ty <= N && g[tx][ty] == 'A' && vis[tx][ty] == false)
        {
            cnt++; 
            vis[tx][ty] = true;
            dfs(tx,ty);
        }
    }
    return;
}
int main()
{
    cin >> N;
    for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
            {
                cin >> g[i][j];
            }
    }
    for(int i = 1; i <= N; i++)
    {
        for(int j = 1; j <= N; j++)
        {
            if(g[i][j] == 'B')
            {
                memset(vis, false, sizeof vis);
                g[i][j] = 'A';
                vis[i][j] = true;
                cnt = 1;
                dfs(i,j);
                ans = max(ans,cnt);
                g[i][j] = 'B';
            }
        }
    }
    cout << ans;
    return 0;
}
```

---

## 作者：qianyuzhe (赞：1)

## 题意简述

给定一个由 `A` 和 `B` 组成的 $n\times n$ 的方阵，要求将其中一个含 `B` 的方格变为 `A`，使其所在的 `A` 连通块的大小最大，输出该大小。

## 题目分析

注意到翻转一个含 `B` 的方格后，其所在的 `A` 连通块的大小就等于其相邻四个 `A` 连通块的并的大小 $+1$。我们可以预处理出初始时每个 `A` 连通块的标号和大小，然后枚举每一个方格求最大值即可。

时间复杂度 $O(n^2)$，空间复杂度 $O(n^2)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,t,i,j,x[2005],y[2005],w[2005],f[55][55];
char c[55][55];
void dfs(int x,int y){
	if(!x||!y||x>n||y>n||c[x][y]=='B'||f[x][y])return;
	w[f[x][y]=t]++;//连通块大小+1
	dfs(x-1,y);
	dfs(x+1,y);
	dfs(x,y-1);
	dfs(x,y+1);
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(i=1;i<=n;i++)for(j=1;j<=n;j++)cin>>c[i][j];
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			if(c[i][j]=='A'&&!f[i][j]){
				x[++t]=i;//标记连通块
				y[t]=j;
				dfs(i,j);
			}
		}
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			if(c[i][j]=='B'){
				a=w[f[i-1][j]]; 
				if(f[i+1][j]!=f[i-1][j])a+=w[f[i+1][j]];
				if(f[i][j-1]!=f[i-1][j]&&f[i][j-1]!=f[i+1][j])a+=w[f[i][j-1]];
				if(f[i][j+1]!=f[i-1][j]&&f[i][j+1]!=f[i+1][j]&&f[i][j+1]!=f[i][j-1])a+=w[f[i][j+1]];
				m=max(m,a+1);//注意加上当前方格 
			}
		}
	}
	cout<<m;
}
```

---

## 作者：yihang2011 (赞：0)

### [B4297 [蓝桥杯青少年组国赛 2022] 翻卡片](https://www.luogu.com.cn/problem/B4297)

连通块搜索好题。

看到 $n \le 50$，说明不存在什么剪枝优化，主打的就是一个暴力。

对于每个 `B` 面朝上的卡，把它翻转一下变成 `A` 面朝上，然后从这张卡开始搜索 `A` 连通块的大小，最后更新答案并把这张卡复原。

时间复杂度 $\mathcal{O}(n^4)$，轻松水过。

代码如下。

```cpp
#include <iostream>
#include <utility>
#include <vector>
#include <cstring>
using namespace std;

int n;
int cnt, ans;
char a[60][60];
bool vis[60][60];
vector<pair<int, int>> d = {make_pair(1, 0), make_pair(-1, 0), make_pair(0, 1), make_pair(0, -1)};

void dfs(int x, int y) {
    if (x < 1 || x > n || y < 1 || y > n) {
        return ;
    }
    if (a[x][y] == 'B') {
        return ;
    }
    if (vis[x][y]) {
        return ;
    }
    vis[x][y] = true;
    cnt++;
    for (auto [dx, dy] : d) {
        dfs(x + dx, y + dy);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> a[i][j];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (a[i][j] == 'B') {
                a[i][j] = 'A';
                memset(vis, false, sizeof vis);
                cnt = 0;
                dfs(i, j);
                ans = max(ans, cnt);
                a[i][j] = 'B';
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

~~最近 STL 写魔怔了码风有点奇怪。~~

[AC Record](https://www.luogu.com.cn/record/215826057)

---

## 作者：PDcccc_M (赞：0)

## 题意：
有一个 $ N×N $
 的卡片矩阵，矩阵中的每个卡片有 A 和 B 两面。现在可以选择翻转任意一张 B 面朝上的卡片，使其变为 A 面朝上。求翻转一张卡片后，相连的 A 面卡片的最大数量。这里的相连指的是上下左右相邻。
## 思路：
对每个 B 类卡片使用 DFS 计算翻转后相连的 A 面卡片数量，并找出最大值。
## 代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;

char mp[55][55];
bool vis[55][55];
int N;

// DFS 函数
int dfs(int a, int b) {
    int cnt = 0;
    if (vis[a][b] || a >= N || a < 0 || b >= N || b < 0 || mp[a][b] == 'B') return 0; // 如果越界或搜到了 B，返回 0
    vis[a][b] = 1; // 标记为已访问
    cnt += dfs(a + 1, b); // 加上点右边的连通块个数
    cnt += dfs(a - 1, b); // 加上点左边的连通块个数
    cnt += dfs(a, b + 1); // 加上点上边的连通块个数
    cnt += dfs(a, b - 1); // 加上点下边的连通块个数
    cnt++; // 加上这个点本身
    return cnt;
}

int main() {
    cin >> N;

    for (int i = 0;i < N;i++) {
        for (int j = 0;j < N;j++) {
            cin >> mp[i][j];
        }
    }

    int maxx = 0;

    // 对每个点进行 DFS，找出最大值
    for (int i = 0;i < N;i++) {
        for (int j = 0;j < N;j++) {
            if (mp[i][j] == 'B') { // 只能反转 B 朝上的卡片
                mp[i][j] = 'A'; // 翻转卡片
                maxx = max(maxx, dfs(i, j)); // 更新最大值
                memset(vis, 0, sizeof(vis)); // 回溯
                mp[i][j] = 'B'; // 回溯
            }
        }
    }

    cout << maxx << endl;
    return 0;
}
```
时间复杂度 $ O(N^4) $ ，可以通过本题。

---

## 作者：Yi_chen123 (赞：0)

## 思路

搜就完了！\
我们可以枚举每一个卡片上面的数字是否是 `B`，如果是，将其翻转成 `A`，再使用深搜计算联通块的大小，如果大小比之前的最大值更大，那么更新答案。

## 正解

```cpp
#include<bits/stdc++.h>
using namespace std;

char card[55][55];
bool vis[55][55];
const int fx[] = {1, -1, 0, 0};
const int fy[] = {0, 0, 1, -1};

int n, cnt = 0;
void dfs(int x, int y){ //深搜
	++cnt;
	vis[x][y] = true;
	for(int i = 0; i < 4; ++i){
		int tx = x + fx[i];
		int ty = y + fy[i];
		if(card[tx][ty] == 'A' && !vis[tx][ty]){
			dfs(tx, ty);
		}
	}
}
int main(){
	cin >> n;
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= n; ++j){
			cin >> card[i][j];
		}
	}
	int ans = 0;
	for(int i = 1; i <= n; ++i){
		for(int j = 1; j <= n; ++j){
			if(card[i][j] == 'A') continue; //是 A 面不需要反转
            memset(vis, 0, sizeof(vis)); //数据不清空，亲人两行泪
            cnt = 0;
            card[i][j] = 'A'; //翻转
            dfs(i, j); //深搜
            card[i][j] = 'B'; //回溯
            ans = max(ans, cnt); //取最大值
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

# 解题思路
一眼看到数据范围，$n\leq 50$，考虑暴力。先枚举所有的 `B` 面卡片，尝试将其翻转。然后我们暴力深搜从这个卡片开始求连通块。时间复杂度 $O(n^4)$，由于 $n$ 很小，我们可以 AC 这道题。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[51][51];
char ch;
int n,a[51][51],ans,sum;
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
void dfs(int x,int y)
{
	sum++;
	vis[x][y]=true;
	for(int i=0;i<4;i++)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(nx<1||nx>n||ny<1||ny>n||vis[nx][ny]||a[nx][ny]==2)
		continue;
		dfs(nx,ny);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>ch;
			if(ch=='B')
			a[i][j]=2;
			else
			a[i][j]=1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]==1)
			continue;
			a[i][j]=1;
			for(int k=1;k<=n;k++)
				for(int l=1;l<=n;l++)
					vis[k][l]=false;
			sum=0;
			dfs(i,j);
			ans=max(ans,sum);
			a[i][j]=2;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4297)
### 思路
这是一道模拟题。   
因为 $n$ 的范围较小，所以可以枚举改变的那一位，将其变成 `A`，再宽搜查找相连的 `A` 面卡片的最大数量。宽搜就是宽搜模板，向上下左右搜，在此不再赘述。记得最后把这个位置变回 `B`。  
没有考虑全都是 `A` 的情况，似乎没有这种恶心的数据。(￣_￣|||)   
### 程序

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,i,j,f[101][101],t,w,b[100001],c[100001];
int s,ma,fx,fy,x,y;
char a[101][101];
void sc(int sx,int sy){
	if(sx>=1&&sx<=n&&sy>=1&&sy<=n)
		if(a[sx][sy]=='A'&&f[sx][sy]==0){
			w++;
			b[w]=sx,c[w]=sy;
			f[sx][sy]=1;
		}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			cin>>a[i][j];
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			if(a[i][j]=='B'){
				a[i][j]='A';
				t=w=1;s=0;
				b[1]=i,c[1]=j;
				for(x=1;x<=n;x++)
					for(y=1;y<=n;y++)
						f[x][y]=0;
				f[i][j]=1;

				while(t<=w){//宽搜
					s++;
					fx=b[t],fy=c[t];
  					sc(fx-1,fy),sc(fx+1,fy);
					sc(fx,fy-1),sc(fx,fy+1);
					t++;
				}
				a[i][j]='B';
				ma=max(ma,s);//求最大
			}
	cout<<ma;
}
```

---

## 作者：lizhixun (赞：0)

### $\texttt{Solution}$

看到 $n \le 50$，想到搜索求联通块。

我们直接将所有的是字母 $\texttt{B}$ 的格子坐标存起来，然后每一次将这个含有 $\texttt{B}$ 的格子换成字母 $\texttt{A}$，然后从这里开始求 $\texttt{A}$ 的连通块并更新答案，记得算完之后还要把当前的格子换回 $\texttt{B}$。还有就是每次记得清空标记数组。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
#define mkp make_pair
using namespace std;

typedef pair<int, int> Pair;
const int maxn = 55;
char a[maxn][maxn];
bool vis[maxn][maxn];
vector<Pair> vec;

const int fx[] = {0, 0, 1, 0, -1};
const int fy[] = {0, 1, 0, -1, 0};

int cnt = 0;

void dfs(int x, int y) {
	cnt++;
	vis[x][y] = 1;
	for (int i = 1; i <= 4; i++) {
		int tx = x + fx[i];
		int ty = y + fy[i];
		if (tx <= 0 || tx > n || ty <= 0 || ty > n) continue;
		if (vis[tx][ty] == 1) continue;
		dfs(tx, ty);
	}
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n; 
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a[i][j];
			if (a[i][j] == 'B') {
				vec.push_back(mkp(i, j));
			}
		}
	}
	
	int ans = 0;
	for (int i = 0; i < vec.size(); i++) {
		memset(vis, 0, sizeof(vis));
		int xx = vec[i].first, yy = vec[i].second;
		cnt = 0;
		dfs(xx, yy);
		ans = max(ans, cnt);
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：hexuchen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4297)

[更好的阅读体验？](https://www.luogu.com.cn/article/3zb38cs8)

## 题目大意

给出一个 $N \times N$ 的仅包含字母 A 或 B 的字符矩阵，每次可以将一个字母 B 改为字母 A，求翻转后相邻的字母 A 数量最多是多少。

## 思路分析

一道基础的搜索题。

由于题目数据范围很小，$N \le 50$，所以可以直接枚举每一个字母 B，将它改为字母 A，再使用广度优先搜索求相邻数量即可。

## AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,ans=0; //注意有可能一个 B 都没有，要初始化为一
int dh[5]={0,-1,0,1,0};
int dl[5]={0,0,1,0,-1};
bool f[60][60]; //标记数组，防止重复
char s[60][60];
int bfs(int x,int y){
	int sum=1; //相邻字母的数量
	memset(f,false,sizeof(f)); //初始化标记数组
	queue<int> qx,qy;
	qx.push(x);
	qy.push(y);
	f[x][y]=true;
	while(!qx.empty()){
		int h=qx.front(),l=qy.front();
		qx.pop();
		qy.pop();
		for(int i=1;i<=4;i++){
			int dx=h+dh[i],dy=l+dl[i];
			if(dx>=1 && dx<=n && dy>=1 && dy<=n){
				if(!f[dx][dy] && s[dx][dy]=='A'){
					f[dx][dy]=true;
					sum++; //数量加一
					qx.push(dx);
					qy.push(dy);
				}
			}
		}
	}
	return sum;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>s[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(s[i][j]=='B'){ //枚举每一个字母 B
				ans=max(ans,bfs(i,j));
		    }
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：TYLOO_259 (赞：0)

[题面](https://www.luogu.com.cn/problem/B4297)

## 思路
看到题，首先就能想到搜索，看数据范围应该能过，就一遍过了。

输入后遍历矩阵，如果遇到 `B` 就把它当作 `A` 搜联通块，每次搜索记录最大答案，记得每次要先清空标记数组。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55;
int n;
char a[N][N];
int px[4]={1,-1,0,0},py[4]={0,0,1,-1};
bool vis[N][N];
int ans;
void bfs(int x,int y){
    memset(vis,0,sizeof(vis));
    queue<pair<int,int>> q;
    q.push({x,y});
    int res=0;
    vis[x][y]=1;
    while(!q.empty()){
        res++;
        int nx=q.front().first,ny=q.front().second;
        q.pop();
        for(int i=0;i<4;i++){
            int ux=nx+px[i],uy=ny+py[i];
            if(ux<1||ux>n||uy<1||uy>n||vis[ux][uy]||a[ux][uy]=='B') continue;
            vis[ux][uy]=1;
            q.push({ux,uy});
        }
    }
    ans=max(ans,res);
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(a[i][j]=='B') bfs(i,j);
        }
    }
    cout<<ans;
    return 0;
}
```

---


# [NOIP 2008 普及组] 立体图

## 题目描述

小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。

小渊有一块面积为 $m \times n$ 的矩形区域，上面有 $m \times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放：

$$
\def\arraystretch{1e-10}
\begin{aligned}
&\verb!  +---+!\\
&\verb! /   /|!\\
&\verb!+---+ |!\quad\textsf{高}\\
&\verb!|   | +!\\
&\verb!|   |/ !\quad\textsf{宽}\\
&\verb!+---+  !\\
& \quad\textsf{长}
\end{aligned}$$


每个顶点用 $1$ 个加号 `+` 表示，长用 $3$ 个 `-` 表示，宽用 $1$ 个 `/`，高用两个 `|` 表示。字符 `+`，`-`，`/`，`|` 的 ASCII 码分别为 $43$，$45$，$47$，$124$。字符 `.`（ASCII 码 $46$）需要作为背景输出，即立体图里的空白部分需要用 `.` 来代替。立体图的画法如下面的规则：

若两块积木左右相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+---+!\\
\verb!./   /   /|!\\
\verb!+---+---+ |!\\
\verb!|   |   | +!\\
\verb!|   |   |/.!\\
\verb!+---+---+..!\\
\end{aligned}
$$

若两块积木上下相邻，图示为：


$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!..+---+!\\
\verb!./   /|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/|!\\
\verb!+---+ |!\\
\verb!|   | +!\\
\verb!|   |/.!\\
\verb!+---+..!\\
\end{aligned}
$$

若两块积木前后相邻，图示为：

$$
\def\arraystretch{1e-10}
\begin{aligned}
\verb!....+---+!\\
\verb!.../   /|!\\
\verb!..+---+ |!\\
\verb!./   /| +!\\
\verb!+---+ |/.!\\
\verb!|   | +..!\\
\verb!|   |/...!\\
\verb!+---+....!\\
\end{aligned}
$$

立体图中，定义位于第 $(m,1)$ 的格子（即第 $m$ 行第 $1$ 列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。


## 说明/提示

NOIP2008普及组第四题


## 样例 #1

### 输入

```
3 4
2 2 1 2
2 2 1 1
3 2 1 2
```

### 输出

```
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......```

# 题解

## 作者：ZUTTER_ (赞：296)

重点重点啦（敲黑板）：**思路**是先把图形存在数组中，然后从后往前，从下往上，从左往右依次覆盖。

###例
```cpp
               +---+     +---+          +---+        
              /   /|    /   /|         /   /|        
             +---+ |   +---+ |        +---+ |        
     +---+   |   | +   |   | +---+    |   | +---+    
    /   /|   |   |/|   |   |/   /|    |   |/   /|    
   +---+ |   +---+ |   +---+---+ |    +---+---+ |    
   |   | +   |   | +   |   |   | +   /   /|   | +    
   |   |/    |   |/    |   |   |/   +---+ |   |/     
   +---+     +---+     +---+---+    |   | +---+      
                                    |   |/           
                                    +---+            
```
重点是要找到每个立方体输出的**位置**，程序里有讲


至于输出每个立方体，~~打个表~~就好了吖(￣▽￣)／


##程序


```cpp
#include<iostream>
#include<stdio.h>

using namespace std;

int i,m,n,j,k,l,o,p,a[1001][1001],ma[1001],maxx,maxy,z[6]={2,1,0,0,0,0},s[6]={6,6,6,6,5,4};

char c[1001][1001],c1[10][10]={
"  +---+",
" /   /|",
"+---+ |",
"|   | +",
"|   |/",
"+---+",
};//打表(￣▽￣)／

void fg(int x,int y)
{
    int i,j;
    for(i=5;i>=0;i--)//立方体需要倒过来存入数组
        for(j=z[i];j<=s[i];j++)//分别是这一行的宽度
        {
            c[5-i+x][j+y]=c1[i][j];
            if(5-i+x>maxx) maxx=5-i+x;
            if(j+y>maxy) maxy=j+y;//分别记录最大长宽
        }
}

int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=0;j<m;j++)
            scanf("%d",&a[i][j]);
    for(o=1;o<=n;o++)//层数
        for(k=0;k<m;k++)//列循环
            for(l=0;l<a[o][k];l++)//高度
                fg((n-o)*2+1+3*l,(n-o)*2+1+4*k);//表示立方体左下角位置

    for(i=maxx;i>=1;i--)
    {    
        for(j=1;j<=maxy;j++)
            if(c[i][j]=='\000') printf(".");
            else printf("%c",c[i][j]);
        printf("\n");
    }
}
```
~~居然做出了第四题，鸡冻到内牛满面(\*/ω＼\*)~~


---

## 作者：Sino_E (赞：31)

有点复杂的模拟。

为了方便，坐标用平面直角坐标系的第一象限来表示，转换到二维数组需要注意一些细节。

大体绘制思路：定位这个立方体在二维平面的左下角坐标进行绘制，从下到上，从左往右，从前往后。上把下覆盖，右把左覆盖，前把后覆盖。

观察这个正方形：

 ![](https://cdn.luogu.com.cn/upload/pic/7650.png) 

我们发现我们只用绘制三个面。根据坐标的规律，我们分别对这一块的坐标进行绘制。

同时我们可以发现这个图形坐标的规律。假设一个立方体的高度为z,所在坐标为x,y（整个矩阵中，左下角的坐标为(0,0)）坐标，那么这个立方体的左下角坐标为：

$x=2*y+4*x$

$y=2y+3z$

通过上面的图，也可以知道整个图的右上角坐标为：

$x=2y+4x+6$

$y=2y+3z+5$

我们将这个右上角坐标取最大值，就是整张图的范围。

然后按照顺序进行绘制就可以了。注意，无论是输入还是输出还是处理，都要使用【左下角】坐标是(0,0)的思想，这样会使过程更加直观容易理解，但如果写代码的思路不清晰很可能会弄错。

更多细节请见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000;
char mz[N][N];
int Z[N][N];

void mdraw(int x,int y){
    /*正面矩阵绘制*/
    mz[x][y+3]=mz[x][y]=mz[x+4][y]=mz[x+4][y+3]='+';
    for(int i=x+1;i<x+4;i++)
        mz[i][y]=mz[i][y+3]='-';
    for(int i=y+1;i<y+3;i++)
        mz[x][i]=mz[x+4][i]='|';
    for(int i=x+1;i<x+4;i++)
        for(int j=y+1;j<y+3;j++)
            mz[i][j]=' ';
    /*顶面矩阵绘制*/
    mz[x+1][y+4]=mz[x+5][y+4]='/';
    mz[x+2][y+5]=mz[x+6][y+5]='+';
    for(int i=x+2;i<=x+4;i++)
        mz[i][y+4]=' ';
    for(int i=x+3;i<=x+5;i++)
        mz[i][y+5]='-';
    /*侧面矩阵绘制*/
    mz[x+5][y+1]='/';
    mz[x+6][y+2]='+';
    mz[x+5][y+2]=mz[x+5][y+3]=' ';
    mz[x+6][y+3]=mz[x+6][y+4]='|';
}

void putout(int x,int y){
    for(int j=y;j>=0;j--){
        for(int i=0;i<=x;i++)
            if(!mz[i][j])putchar('.');
            else putchar(mz[i][j]);
        putchar('\n');
    }//按照平面直角坐标系顺序进行输出 
}

int main(){
    int mx=0,my=0;
    int m,n;
    scanf("%d%d",&m,&n);
    for(int y=m-1;y>=0;y--)
        for(int x=0;x<n;x++)
            scanf("%d",&Z[x][y]); //注意输入 
    for(int y=m-1;y>=0;y--)
        for(int x=0;x<n;x++)
            for(int z=0;z<=Z[x][y]-1;z++){
                mx=max(mx,2*y+4*x+6);
                my=max(my,2*y+3*z+5);
                mdraw(2*y+4*x,2*y+3*z);
            } //注意绘制顺序 
    putout(mx,my); //输出 
    return 0;
}
```

---

## 作者：HasNoName (赞：21)

### 思路
感觉这道题还是有思维含量的。

考虑如何得到一张立体图。

如果从前往后依次放方块是非常困难的。

所以可以从后往前建方块。

然后可以发现前面的其实可以覆盖后面方块的图，左边的可以覆盖右边的，同一个位置上面的可以覆盖下面的。所以从后往前，从左往右，从下往上作图。

具体的，可以从给出的矩阵的左上角开始建，从上往下，从左往右，在对于每一个矩阵中的位置，从下往上堆方块。堆方块时可以设置一个单位正方体的图，从图形的左下角开始，每次将纵坐标向上移动，对于单位方格有实际意义的位置，直接覆盖原来位置的字符即可。

可以用画图软件操作一下。比如这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/upz7bew1.png)

理解了这些之后这题就非常简单了。

但是这样的方式在数组中存储的位置并不确定。

所以可以将作图的其实位置放在数组中间，上下左右给其充分大的空间，再在作图过程中更新打印时图的大小即可。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int num[55][55],u=1e9,d=0,l=1e9,r=0;
char a[4005][4005];//答案数组
char cube[10][10]={"..+---+",
				   "./   /|",
				   "+---+ |",
				   "|   | +",
				   "|   |/.",
				   "+---+.."};//单个方块
void print(int x,int y,int h)//每个二维中同样位置从下往上堆方块
{
	x-=5;
	for(int k=1;k<=h;k++)
	{
		for(int i=0;i<6;i++)
			for(int j=0;j<7;j++)
				if(cube[i][j]!='.')
					a[x+i][y+j]=cube[i][j];
		x-=3;//打印方块起始位置移动
	}
	u=min(u,x+3);//更新上界
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>num[i][j];
	int x=3000,y=1000;
	for(int i=1;i<=n;i++)
	{
		int y_=y;
		for(int j=1;j<=m;j++)//从左到右打印
		{
			print(x,y_,num[i][j]);
			y_+=4;
		}
		r=max(r,y_+2);//右界
		x+=2;
		y-=2;
	}
	d=x-2;//下界
	l=y+2;//左界
	for(int i=u;i<=d;i++)
	{
		for(int j=l;j<=r;j++)
		{
			if(!a[i][j])cout<<".";
			else cout<<a[i][j];
		}
		cout<<'\n';
	}
	return 0;
}
```

---

## 作者：skx_515 (赞：4)

拿到这道题，我的第一个想法是：  

**方块的前后关系是什么样子的？？？**

很显然，从最前面看，一定先看到最前面，最上面的方块，再由于我们观看的角度问题，我们可以得出结论：
>在输入中，由于先输入的为后面的方块，所以可以先打印后面的，再打印前面的，同时，再打印同一列时，我们需要先打印下面的，再打印上面的

所以，我们可以~~轻松~~写出代码(具体移动过程见内)：
```cpp
#include<bits/stdc++.h>
#define N 2005
using namespace std;
int n,m,a[N][N],tx,mnx=INT_MAX,mny=INT_MAX,mxx,mxy;
int x=500,y=1;//记录每一个方块的左上角坐标，从(500,1)开始 
char mp[N][N];
char jc[8][8]={{'.','.','+','-','-','-','+'},
			   {'.','/',' ',' ',' ','/','|'},
			   {'+','-','-','-','+',' ','|'},
			   {'|',' ',' ',' ','|',' ','+'},
			   {'|',' ',' ',' ','|','/','.'},
			   {'+','-','-','-','+','.','.'}};//存储一个方块 
int main(){
	memset(mp,'.',sizeof(mp));//初始化背景为'.' 
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		y=(n-i)*2+1;
		for(int j=1;j<=m;j++){
			cin>>a[i][j];//输入 
			tx=x;//记录左上角 
			for(int t=1;t<=a[i][j];t++){
				for(int xx=0;xx<6;xx++){//直接在需要的地方 
					for(int yy=0;yy<7;yy++){
						if(jc[xx][yy]!='.') mp[tx+xx][y+yy]=jc[xx][yy];//'.代表的是空的地方
						mnx=min(mnx,tx+xx),mxx=max(mxx,tx+xx);//记录图形的四个角 
						mny=min(mny,y+yy),mxy=max(mxy,y+yy);
					}
				}
				tx-=3;//向上三格打印上面的
			}
			y+=4;//向右四格到下一个
		}
		x+=2;//向下两个到下一行
	}
	for(int i=mnx;i<=mxx;i++){
		for(int j=mny;j<=mxy;j++) cout<<mp[i][j];
		cout<<"\n";
	} 
	return 0;
}
```

---

## 作者：Moco_jof (赞：3)

## 题目传送门：

[P1058题目传送门](https://www.luogu.com.cn/problem/P1058)


## 基本思路：

### **~~最讨厌这种题了~~**

其实一开始一看也很懵，但仔细一想就开窍了

像这种**~~无耻地~~**让我们输出图案的题目，其实我们可以从后往前来填充方块

比如样例：


```cpp
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
我们可以先填这个：

```cpp
        |    
......+-V-+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
再填这个：

```cpp
            |
......+---+-V-+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
填完这一行后，再填下一行，以此类推……
这样，让这个数组一次次覆盖，最终形成最后的图案。

最后输出，别忘了背景

然后就没了

就没了

## 代码之前：

1.可以建一个二维字符数组用来存储


```cpp
  +---+
 /   /|
+---+ | <-这个东西
|   | +
|   |/ 
+---+  
```
2.再建一个二维字符数组用来存储最终图案

3.应该没了
## 代码

终于到你们最喜欢的代码了~

代码（ ）坑，可安息食用


```cpp
#include <iostream>
#define max(a,b) a>b?a:b
#defie min(a,b) a<b?a:b
using namespace std;
int m,n,x=3000,y=1000,_y,a=2147483647,b,c,d=-2147483648,_x;
//a,b,c,d是上下左右限
int zb[51][51];
char ans[4005][4005];
char ch[8][8]={"..+---+","./   /|","+---+ |","|   | +","|   |/.","+---+.."};
/*
  +---+
 /   /|
+---+ |
|   | +
|   |/ 
+---+  
*/
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>m>>n;
    for(int i=1;i<=m;++i){
        for(int j=1;j<=n;++j){
            cin>>zb[i][j];
        }
    }
    for(int i=1;i<=m;++i){
        _y=y;
        for(int j=1;j<=n;++j){
            _x=x;
            _x-=5;
            for(bool k=1;k<=zb[i][j];++k){//填充一个方块
                for(int l=0;l<=5;++l){
                    for(int o=0;o<=5;++o){
                        if(ch[l][o]!='.'){
                            ans[x+l][_y+o]=ch[1][o];
                            //填充
                        }
                    }
                }
                _x-=3;
            }
            a=min(a,_x+3);
            _y+=4;//下一列
        }
        x+=2;
        y-=2;//下一行
        d=min(d,_y+2);
    }
    b=x-2;
    c=y+2;
    for(int i=a;i<=b;++i){
        for(int j=c;j<=d;++i){
            if(ans[i][j]){
                cout<<'.';//背景
            }else{
                cout<<ans[i][j];
            }
        }
        cout<<'\n';
    }
    return 0;
}

```
千万别点赞

---

## 作者：cwxcplh (赞：1)

一道特别具有思维挑战性的模拟题 ~~（我绝对不会告诉你我花了一个多小时去做这道题）~~。

题目简化：给定一个立体几何的每一列的个数，画出这个立体几何。

第一眼看到，很容易想到模拟。我们只需要确定每个立方体的左上角的位置，然后在此基础上放一个立方体就行了。

听着很简单，怎么做呢？我们先打出一个最基本的立方体：

```
..+---+
./   /|
+---+ |
|   | +
|   |/.
+---+..
```

然后以这个立方体为中心，向它的前后左右上下依次加一个立方体，看看左上角的横纵坐标有什么变化。

如果在它的右边加了一个立方体，那么这个新加的立方体的左上角的列数就会加 $4$，而这与这个立方体在俯视图中的列有关。如果在上面加，那么行数会减去 $3$，二者与层数有关。如果在如果在后面加，那么行数会减去 $2$，列数会增加 $2$。所以我们不免大胆猜测：在一个立方体的左上角的坐标 $(x,y)$（$x$ 为行，$y$ 为列）经过变化后会变成:
$$(x+3\times(a_{i,j}-k)+2\times(i-1)+1,y+2\times(n-i)+4\times(j-1)+1)$$

那如果我们把这个点拖到原点 $(0,0)$，那我们就得到了每个点的坐标公式：

$$(3\times(a_{i,j}-k)+2\times(i-1)+1,2\times(n-i)+4\times(j-1)+1)$$

因为前面会覆盖后面、右边会覆盖左边、上面会覆盖下面，所以我们会按照从后往前、从左往右、从下往上的顺序循环。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,mxx,mxy,a[56][56];
char c[1006][1006],cube[16][16]={//单个立方体块，方便后面组装
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
}; 
void tc(int x,int y)//填充立方体
{
	for(int i=0;i<6;i++)
	{
		for(int j=0;j<7;j++)
		{
			c[x+i][y+j]=cube[i][j];
			if(x+i>mxx)
			{
				mxx=x+i;
			}
			if(y+j>mxy)
			{
				mxy=y+j;
			}
		}
	}
}
signed main()
{
	memset(c,'.',sizeof(c));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=a[i][j];k++)
			{
				tc(3*(a[i][j]-k)+2*(i-1)+1,2*(n-i)+4*(j-1)+1);//杠杠的公式
			}
		}
	}
	for(int i=1;i<=mxx;i++)
	{
		for(int j=1;j<=mxy;j++)
		{
			cout<<c[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

但这会出现一个问题，请看样例：

输入：`1 2 1 1`。

输出：

```
..+-..+---+
./  ./   /|
+---+---+ |
|   |   | +
|   |   |/.
+---+---+..
```

其实就是 `.` 符号可能会挡住前面的字符，填充时加个判断就行：

```cpp
if(c[x+i][y+j]!='.'&&cube[i][j]=='.')
{
	continue;
}
```

但加上后这个代码仍然有问题，请看下面这组样例：

输入：`1 2 1 2`。

输出：

```
..+---+---+
./   /   /|
+---+---+ |
|   |   | +
|   |   |/|
+---+---+ |
....|   | +
....|   |/.
....+---+..
```

我们会发现：右边的那个方块悬空了。这是因为我们刚刚的坐标式是只看了自己的坐标，而没看其他的，因此不会受到其他方块的影响。为此，我们需要加一个“重力常数”，让这个方块可以落下去。

不难发现：如果你比最高的方块要矮 $z$ 层，那么行数就需要加 $3z$ 格。所以最后的坐标公式就是：

$$(3\times(a_{i,j}-k)+2\times(i-1)+1+3\times(mx-a_{i,j}),2\times(n-i)+4\times(j-1)+1)$$

但加上去之后这份代码仍然有问题，请看最后一组样例：

输入：`2 1 1 2`。

输出：

```
.........
.........
..+---+..
./   /|-+
+---+ |/|
|   | + |
|   |/| +
+---+ |/.
|   | +..
|   |/...
+---+....
```

这是因为我们是按照最高的对齐，然而最高的却会按照原本的位置站，所以上面会留出原本不属于它的空间。这也很好办，我们只需要一个循环把上面的去掉就行了：

```cpp
int i=1;
while(i<=mxx)
{
	bool flag=false;
	for(int j=1;j<=mxy;j++)
	{
		if(c[i][j]!='.')
		{
			flag=true;
			break;
		}
	}
	if(flag)
	{
		break;
	}
	i++;
}
```

到这，这道题才算是完美解决了。

[提交记录，完美 AC](https://www.luogu.com.cn/record/201487576)

**最终代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,mxx,mxy,mx,a[56][56];
char c[1006][1006],cube[16][16]={
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
}; 
void tc(int x,int y)
{
	for(int i=0;i<6;i++)
	{
		for(int j=0;j<7;j++)
		{
			if(c[x+i][y+j]!='.'&&cube[i][j]=='.')
			{
				continue;
			}
			c[x+i][y+j]=cube[i][j];
			if(x+i>mxx)
			{
				mxx=x+i;
			}
			if(y+j>mxy)
			{
				mxy=y+j;
			}
		}
	}
}
signed main()
{
	memset(c,'.',sizeof(c));
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			mx=max(mx,a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			for(int k=1;k<=a[i][j];k++)
			{
				tc(3*(a[i][j]-k)+2*(i-1)+1+(mx-a[i][j])*3,2*(n-i)+4*(j-1)+1);
			}
		}
	}
	int i=1;
	while(i<=mxx)
	{
		bool flag=false;
		for(int j=1;j<=mxy;j++)
		{
			if(c[i][j]!='.')
			{
				flag=true;
				break;
			}
		}
		if(flag)
		{
			break;
		}
		i++;
	}
	for(;i<=mxx;i++)
	{
		for(int j=1;j<=mxy;j++)
		{
			cout<<c[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

~~我感觉废话好像多了点。~~

---

## 作者：superLouis (赞：1)

## 题解：P1058 [NOIP2008 普及组] 立体图

这道题目其实就是朴素的算算下表就能通过。

----------
### 1. 解题思路
我们可以采用画布思想，先把整个数组都变成 `.`，在这里可以使用 `fill` 来实现，大致就是这样：`fill(&a[0][0], &a[maxn - 1][maxn - 1], '.')`。

我们定义一个 `draw` 函数，传的参数就是你要在 $i$ 行 $j$ 列画出一个立方体。详见下面：

```
*.+---+
./   /|
+---+ |
|   | +
|   |/.
+---+..
```
其中标记 `*` 的点就是 $i$ 行 $j$ 列的点，也就是 `draw` 函数的参数。`draw` 就是传入 $i$ 和 $j$，画出一个 `*` 在 $i$ 行 $j$ 列的立方体。

随后，我们考虑应该按照什么顺序来画立方体。注意到立方体们会互相覆盖，所以我们一层一层的盖楼，每一层从左上角开始，一行一行搭建，这样搭满一层。

形式化的讲，先从一层一层的搭建，每一层从下标为 $(1,1)$ 开始搭建，搭到 $(n,m)$。搭建顺序是：

$$(1,1) \to (1,2) \to (1,3) \to \dots \to (1,m) \to \\ \vdots \\ \to (n,1) \to (n,2) \to (n,3) \to \dots \to (n, m)$$

顺序讲完了，该说说下标问题了。考虑三种情况，分别是在二维数组下标 $i$ 行 $j$ 列的立方体向右、前、上搭建第 $k$ 一个立方体的下标。

1. 向右搭建（right）：下标是 $(i, j+4k)$。
2. 向前搭建（front）：下标是 $(i+2k, j-2k)$。
3. 向上搭建（up）：下标是 $(i-3k, j)$。

这些下表都要自己算一遍。

但是，计算这个图形要多大的数组很难，所以可以直接从中间开始画，画完之后再去确定最大最小的横纵坐标即可。

----------
### 2. 代码实现
思路明白了，代码很好写。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 60;
const int maxm = 3010;
const int st = maxm >> 1;
int n, m, a[maxn][maxn], mxheight;
int stx = maxm, sty = maxm, edx, edy;
char ans[maxm][maxm]; 
void draw(int x, int y) {
	ans[x][y + 2] = ans[x][y + 6] = ans[x + 2][y] = 
	ans[x + 2][y + 4] = ans[x + 3][y + 6] = ans[x + 5][y] = 
	ans[x + 5][y + 4] = '+';
	ans[x + 1][y + 1] = ans[x + 1][y + 5] = ans[x + 4][y + 5] = '/';
	ans[x][y + 3] = ans[x][y + 4] = ans[x][y + 5] = 
	ans[x + 2][y + 1] = ans[x + 2][y + 2] = ans[x + 2][y + 3] =
	ans[x + 5][y + 1] = ans[x + 5][y + 2] = ans[x + 5][y + 3] = '-';
	ans[x + 1][y + 6] = ans[x + 2][y + 6] = ans[x + 3][y] =
	ans[x + 4][y] = ans[x + 3][y + 4] = ans[x + 4][y + 4] = '|';
	ans[x + 1][y + 2] = ans[x + 1][y + 3] = ans[x + 1][y + 4] = ' ';
	ans[x + 2][y + 5] = ans[x + 3][y + 5] = ' ';
	ans[x + 3][y + 1] = ans[x + 3][y + 2] = ans[x + 3][y + 3] = ' ';
	ans[x + 4][y + 1] = ans[x + 4][y + 2] = ans[x + 4][y + 3] = ' ';
}
void print() {
	for (int i = stx; i <= edx; i++) {
		for (int j = sty; j <= edy; j++) cout << ans[i][j];
		cout << "\n";
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	fill(&ans[0][0], &ans[maxm - 1][maxm - 1], '.');
	cin >> n >> m;
	for (int i = 1; i <= n; i++) 
		for (int j = 1; j <= m; j++) cin >> a[i][j], mxheight = max(mxheight, a[i][j]);
	// right: draw(i, j + 4k);
	// front: draw(i + 2k, j + (-2k));
	// up:    draw(i + (-3k), j);
	for (int h = 1; h <= mxheight; h++) {
		for (int i = 1; i <= n; i++) 
			for (int j = 1; j <= m; j++) 
				if (a[i][j] >= h) draw(st + (i - 1) * 2 - 3 * (h - 1), st + (j - 1) * 4 - 2 * (i - 1));
	}
	for (int i = 1; i < maxm - 30; i++) 
		for (int j = 1; j < maxm - 30; j++) 
			if (ans[i][j] != '.') {
				stx = min(stx, i);
				sty = min(sty, j);
				edx = max(edx, i);
				edy = max(edy, j);
			}
	print();
	return 0;
} 
```

---

## 作者：LiJunze0501 (赞：1)

这道题就是一道模拟，是二维数组的覆盖。  
那么我们要搞清楚这几点：

- 最后长（$L$）是多少？
- 最后宽（$K$）是多少？
- 怎样覆盖？

第一个问题，长（$L$）怎么求。
```
......+---+---+...+---+
..+---+  /   /|../   /|
./   /|-+---+ |.+---+ |
+---+ |/   /| +-|   | +
|   | +---+ |/+---+ |/|
|   |/   /| +/   /|-+ |
+---+---+ |/+---+ |/| +
|   |   | +-|   | + |/.
|   |   |/  |   |/| +..
+---+---+---+---+ |/...
|   |   |   |   | +....
|   |   |   |   |/.....
+---+---+---+---+......
```
$L \gets 4 \times N+2 \times M+1$  
长上有 $N$ 个立方体，我们把 `+---` 看为一个整体，那就会有 $4 \times N$ 个字符。  
宽上有 $M$ 个立方体，我们把 `+/` 看为一个整体，那就会有 $2 \times M$ 个字符。  
最后还会有一个 `+`，所以再加一。
最后就会得到如上的式子。

---
第二个问题，宽（$K$）怎么求。  
这里不再赘述，在循环中 $ K \gets \max(K,a_{i,j} \times 3+2 \times (M-i+1)+1)$。  
示意代码：

```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		cin>>a[i][j];
		k=max(k,a[i][j]*3+2*(n-i+1)+1);
	}
```


---
最后是覆盖，从左下向右上覆盖，最后替换。

---
# AC Code
在代码中因为书写习惯，我把 $N$ 和 $M$ 调换了顺序。
```cpp
#include<bits/stdc++.h>
using namespace std;
char dy[10][10]={
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
};//打表一个立方体

char ans[2001][2001];
void add(int x,int y)
{
	for(int i=0;i<=5;i++)
		for(int j=0;j<=6;j++)
			if(dy[6-i-1][j]!='.')
				ans[x-i][y+j]=dy[6-i-1][j];
}

int a[51][51];
int main()
{
	int n,m,k=0,l;
	cin>>n>>m;
	l=4*m+2*n+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];
			k=max(k,a[i][j]*3+2*(n-i+1)+1);
		}
	for(int i=1;i<=k;i++)
		for(int j=1;j<=l;j++)
			ans[i][j]='.';
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			int x=k-2*(n-i);
			int y=2*(n-i)+4*(j-1)+1;
			while(a[i][j]--)
			{
				add(x,y);
				x-=3;
			}
		}
	for(int i=1;i<=k;i++)
	{
		for(int j=1;j<=l;j++)
			cout<<ans[i][j];
		cout<<endl;
	}
} 
```

---

## 作者：prh_rpjiajia (赞：0)

## 思路：
- 放置顺序。
- 计算输出的尺寸。
- 怎么让代码更清晰。
***
### 第一部分：
类比生活中放置，最前面肯定是最显眼的。所以，我们采用**从后到前，从左到右，从下往上**的放置方式。

另外，改怎么放呢？打表！提前存在数组里。
### 第二部分：
这部分是最困难的，实际的 $h$、$w$，与 $n,m$ 没有直接关系。**我提供了一种与其他题解不同的方法。**

**思考：**
高要在循环内求，在侧面一层会让高涨 $2$，在正面，一层会让高涨 $3$，$m-i$ 表示层数。宽也以此类推，每一个块的宽首先是点是层数乘 $2$ 的，接着是两个加号两个减号是层数乘 $4$ 的，当然，还要考虑 $a[i][j]$，所以分别加六加七了。累加起来就是了。（具体代码我会在程序里标注）。
### 第三部分：
提到让代码给清晰，大多数人也可以想到它——**函数**。
我们创建一个 $draw$ 函数，枚举左上角和右下角去放块。

## 代码

```cpp
#include<bits/stdc++.h>
#define I return
#define LOVE 0
#define LOUGU ;
using namespace std;
const int MAXN=55,MAXM=550;
char c[MAXM][MAXM],s[6][8]={//打表
"..+---+",
"./   /|",
"+---+ |",
"|   | +",
"|   |/.",
"+---+.."
};
int m,n,a[MAXN][MAXN],h,w;
void draw(int x,int y)
{
    for (int i=0;i<6;++i)
        for (int j=0;j<7;++j)
            if (s[i][j]!='.')c[x+i][y+j]=s[i][j];
}
int main()
{
    cin>>m>>n;
    for (int i=1;i<=m;++i)
    {
        for (int j=1;j<=n;++j)
        {
            cin>>a[i][j];
            h=max(h,(m-i)*2+(a[i][j]-1)*3+6);//高
            w=max(w,(m-i)*2+(j-1)*4+7);//宽
        }
    }
    memset(c,'.',sizeof(c));//初始化
    for (int i=1;i<=m;++i)
        for(int j=1;j<=n;++j)
		for (int k=1;k<=a[i][j];++k)draw(h-1-(m-i)*2-(k-1)*3-5,(m-i)*2+(j-1)*4);
    for (int i=0;i<h;++i)
    {
        c[i][w]='\0';//设置字符串结尾
        cout<<c[i]<<"\n";
    }
    I LOVE LOUGU
}
```
完结，撒花。

---

## 作者：gac497 (赞：0)

# 问题描述

小渊有一块面积为 $m \times n$ 的矩形区域，上面有 $m \times n$ 个边长为 $1$ 的格子，每个格子上堆了一些同样大小的积木（积木的长宽高都是 $1$）。要求根据输入的矩阵，绘制出这些格子的立体图。

# 解题思路

## 1.积木的表示：

每个积木的图形由 $6$ 行组成，每行的字符数和位置是固定的。我们可以用一个二维数组 $c2$ 来存储一个积木的图形。

## 2.绘制积木：

对于每个格子上的积木，根据其位置和高度，计算出它在立体图中的起始坐标，然后调用 $\text{build}$ 函数将积木绘制到全局的字符数组 $c$ 中。

## 3.坐标计算：

积木的起始坐标需要根据其在矩阵中的位置和高度来计算。具体来说，第 $i$ 行第 $j$ 列的格子上的第 $k$ 个积木的起始坐标为 $((n-i) \times 2+1+3 \times k, (n-i) \times 2+1+4 \times j)$。

## 4.绘制立体图：

在绘制完所有积木后，根据 $maxx$ 和 $maxy$ 的值来确定立体图的大小，并输出字符数组 $c$ 中的内容。空白部分用 `.` 填充。

# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,maxx,maxy,a[1010][1010],dxy[6]={2,1,0,0,0,0},s[6]={6,6,6,6,5,4};
char c[1010][1010],c2[15][15]={
		"  +---+",
		" /   /|",
		"+---+ |",
		"|   | +",
		"|   |/",
		"+---+",
};

void build(int x,int y){
    for(int i=5;i>=0;i--){
        for(int j=dxy[i];j<=s[i];j++){
            c[5-i+x][j+y]=c2[i][j];
            if(5-i+x>maxx){
				maxx=5-i+x;
            }
            if(j+y>maxy){
				maxy=j+y;
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++){
            scanf("%d",&a[i][j]);
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<m;j++){
            for(int k=0;k<a[i][j];k++){
                build((n-i)*2+1+3*k,(n-i)*2+1+4*j);
            }
        }
    }
    for(int i=maxx;i>=1;i--){    
        for(int j=1;j<=maxy;j++){
            if(c[i][j]=='\0'){
				printf(".");
            }else{
				printf("%c",c[i][j]);
            }
        }
        printf("\n");
    }
    return 0;
}
```

---


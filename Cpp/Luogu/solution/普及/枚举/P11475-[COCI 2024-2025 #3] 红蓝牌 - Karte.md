# [COCI 2024/2025 #3] 红蓝牌 / Karte

## 题目背景


译自 [COCI 2024/2025 #3](https://hsin.hr/coci/) T2。$\texttt{1s,0.5G}$。满分为 $70$。


## 题目描述

在 Vito 的桌子上，有 $N$ 张编号分别为 $1\sim N$ 的红牌和 $M$ 张编号分别为 $1\sim M$ 的蓝牌。

将一张红牌和一张蓝牌称为「一对」，给定若干个二元组 $(c,p)$。若一对牌中，红牌编号为 $c$，蓝牌编号为 $p$，则称这对牌是**好对**。

一个牌堆包含若干张红牌和若干张蓝牌。定义一个牌堆的**价值** $w$ 为牌堆中选出一对，使得这个对是一个好对的方案数。

令 $r$ 为牌堆中红牌的数量，$b$ 为牌堆中蓝牌的数量，定义牌堆的**强度** $\mathrm{strength}$ 为：

$$\mathrm{strength}=w-X\cdot r-Y\cdot b$$

其中 $X$ 和 $Y$ 是给定的常数。

帮助 Vito 确定：选择若干张红牌和蓝牌构成一个牌堆，这个牌堆的最大强度为多少。注意，他也**可以一张牌都不选**（即构成一个空的牌堆）。

## 说明/提示



### 样例解释

样例 $1$ 中，Vito 可以选择所有的卡牌，能产生 $3$ 个好对，牌堆的最大强度为 $3$。

样例 $2$ 中，Vito 可以选择编号为 $1,2$ 的红牌和所有的蓝牌，能产生 $6$ 个好对，牌堆的最大强度为 $4$（由于选择了两张红牌，所以要将好对数减去 $2X=2$ 作为牌堆的强度）。

### 数据范围


对于 $100\%$ 的数据，保证：

- $1\le N,M\le 21$；
- $0\le X,Y\le 30$；
- 输入的字符串中仅包含 $0$ 和 $1$。


| 子任务编号 | 特殊性质 | 得分 |
| :-: | :-: | :-: |
| $1$ | $Y=0$ | $18$ |
| $2$ | $1\le N,M\le 9$ | $11$ |
| $3$ | $1\le N,M\le 15$ | $24$ |
| $4$ | 无 | $17$ |

## 样例 #1

### 输入

```
2 2 0 0
11
10```

### 输出

```
3```

## 样例 #2

### 输入

```
3 3 1 0
111
111
000```

### 输出

```
4```

## 样例 #3

### 输入

```
3 3 1 1
111
101
011```

### 输出

```
1```

# 题解

## 作者：一扶苏一 (赞：10)

## 解析

规模很小，考虑枚举选择了哪些蓝牌。

假设选择了集合 $lhs$ 里的蓝牌，我们可以知道选择每张红牌贡献的好对数。具体来说，如果第 $i$ 张红牌能和集合 $\mathrm{matched}_i$ 里的蓝牌产生好对，那么第 $i$ 张牌贡献的好对数就是 $rhs(i) = |lhs \bigcap \mathrm{matched}_i|$。因为牌的数量很少，所以 $lhs$ 和 $\mathrm{matched}_i$ 都可以压位成 `int`，集合求交可以对两个整形做按位与，求集合大小可以通过 `std::popcount` 来实现。

注意这里 $lhs$ 是蓝牌选牌集合，$rhs(i)$ 是第 $i$ 张牌的贡献，两者含义不是对称的。

接下来考虑枚举选了几张红牌。显然尽可能选择贡献较大的红牌是优的，所以把 $rhs$ 数组从大到小排序，贪心地选前几项并尝试更新答案即可。

时间复杂度 $O(2^m \times n \times t(w))$，其中 $t(w)$ 表示一次 `popcount` 的时间。

## 代码

```cpp
#include <bits/stdc++.h>

int main() {
  int n, m, x, y;
  std::cin >> n >> m >> x >> y;
  std::vector<int> matched(n);
  for (auto &i : matched) {
    std::string s;
    std::cin >> s;
    for (int j = 0; j < m; ++j) if (s[j] == '1') i ^= 1 << j;
  }
  int ans = 0;
  for (int lhs = 0, upc = 1 << m; lhs < upc; ++lhs) {
    std::vector<int> rhs(n);
    for (int i = 0; i < n; ++i) {
      rhs[i] = std::popcount(static_cast<unsigned>(matched[i] & lhs));
    }
    std::sort(rhs.begin(), rhs.end(), std::greater<int>());
    int matchedCnt = 0;
    int lhsCnt = std::popcount(static_cast<unsigned>(lhs));
    for (int j = 0; j < n; ++j) {
      matchedCnt += rhs[j];
      ans = std::max(ans, matchedCnt - y * lhsCnt - x * (j + 1));
    }
  }
  std::cout << ans << std::endl;
}
```

---

## 作者：E_firework (赞：8)

### 法一

前置知识：位运算。

因为 $n,m$ 都非常小，所以我们可以考虑枚举选取的红牌的集合，再看每一张蓝牌选取后是否让答案变大，也就是比较选取了的红牌中与这张蓝牌组成好对的数量与 $Y$ 之间的大小，如果能让答案变大那就需要选取这张蓝牌。因为确定了选取的红牌的集合后蓝牌之间的决策互不影响，所以这个算法是正确的。时间复杂度为 $O(2^nnm)$。如果在求解一个红牌的集合与一张蓝牌组成好对的数量时加上位运算的优化可以做到 $O(2^nm)$

无优化的代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mes(s, x) memset(s, x, sizeof s)
#define Maxn 25
using namespace std;
inline LL read(){char c;c = getchar();while(!(('0' <= c && c <= '9') || c == '-')) c = getchar();bool flag = 0;if(c == '-'){flag = 1;c = getchar();}LL tot = 0;while('0' <= c && c <= '9'){tot = 10 * tot + c - '0';c = getchar();}return flag ? -tot : tot;}
char c[Maxn][Maxn];
int main(){
	#ifndef ONLINE_JUDGE
		freopen("in","r",stdin);
		freopen("out","w",stdout);
	#endif
    int n = read(), m = read(), x = read(), y = read(), ans = 0, tmp, s;
    for(int i = 1; i <= n; i++) scanf("%s", c[i] + 1);
    for(int i = 0; i < 1 << n; i++){//枚举子集
        tmp = 0;
        for(int j = 1; j <= n; j++) if((i >> (j - 1)) & 1) tmp -= x;
        for(int k = 1; k <= m; k++){
            s = 0;
            for(int j = 1; j <= n; j++) if(((i >> (j - 1)) & 1) && c[j][k] == '1') s++; 
            if(s > y) tmp += s - y;
        }
        ans = max(tmp, ans);
    }
    printf("%d\n", ans);
    return 0;
}
```

有优化的代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mes(s, x) memset(s, x, sizeof s)
#define Maxn 25
using namespace std;
inline LL read(){char c;c = getchar();while(!(('0' <= c && c <= '9') || c == '-')) c = getchar();bool flag = 0;if(c == '-'){flag = 1;c = getchar();}LL tot = 0;while('0' <= c && c <= '9'){tot = 10 * tot + c - '0';c = getchar();}return flag ? -tot : tot;}
char c[Maxn][Maxn];
int a[Maxn];//与一张蓝牌组成好对的红牌集合
int main(){
	#ifndef ONLINE_JUDGE
		freopen("in","r",stdin);
		freopen("out","w",stdout);
	#endif
    int n = read(), m = read(), x = read(), y = read(), ans = 0, tmp, s;
    for(int i = 1; i <= n; i++) scanf("%s", c[i] + 1);
    for(int i = 1; i <= m; i++){
        for(int j = 1; j <= n; j++){
            if(c[j][i] == '1') a[i] |= 1 << (j - 1);
        }
    }
    for(int i = 0; i < 1 << n; i++){//枚举子集
        tmp = 0;
        for(int j = 1; j <= n; j++) if((i >> (j - 1)) & 1) tmp -= x;
        for(int j = 1; j <= m; j++){
            s = __builtin_popcount(i & a[j]);
            if(s > y) tmp += s - y;
        }
        ans = max(tmp, ans);
    }
    printf("%d\n", ans);
    return 0;
}
```

### 法二

前置知识：**最小割**。

需要注意，网络流并不属于 NOI 大纲划定的入门级或提高级考察范围。

我们可以使用最小割算法解决这个问题，我们需要构造一个图使得其最小割等于为方案中未包含的好对数与选取的牌的代价之和的最小值（选红牌的代价为 $X$，选蓝牌的代价为 $Y$。）。好对的总数减去图的最小割即为答案。

我们把每张牌当成一个节点，再建立一个源点 $S$ 和一个汇点 $T$。钦定一组割的方案中与 $S$ 在一个集合的节点为选取了的牌，那么首先每张牌要向 $T$ 连一条容量为选这一张牌的代价的有向边。

在构造未包含的好对数时可以用二元关系最小割的方法分析。

![](https://cdn.luogu.com.cn/upload/image_hosting/3m4r04np.png)

考虑一个好对 $(u,v)$，只有在 $u,v$ 同时属于 $S$ 集合时选取的牌可以包含这一个好对，那么有：

$$
\begin{cases}
a+b=1\\
c+d=0\\
a+d+f=1\\
b+c+e=1
\end{cases}
$$

解得 $c=d=0$，$a=e$，$b=f=1-a$。为了方便，我们可以直接令 $a=e=1$，$b=c=d=f=0$。也就是说，对于每一个好对 $(u,v)$，我们需要从源点向 $u$ 连一条容量为 $1$ 的有向边，从 $u$ 向 $v$ 连一条容量为 $1$ 的有向边。这样图就建完了。

注意到这一做法可以扩展到好对不是一红一蓝的情况，因为分析中并没有用到二分图的性质。

如果使用 dinic 算法求解最小割，那么时间复杂度不会超过 $O((n+m)^2nm)$。

代码:

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mes(s, x) memset(s, x, sizeof s)
#define Maxn 50
#define Maxm 2005
#define inf 0x3f3f3f3f3f3f3f3f
using namespace std;
inline LL read(){char c;c = getchar();while(!(('0' <= c && c <= '9') || c == '-')) c = getchar();bool flag = 0;if(c == '-'){flag = 1;c = getchar();}LL tot = 0;while('0' <= c && c <= '9'){tot = 10 * tot + c - '0';c = getchar();}return flag ? -tot : tot;}
int hd[Maxn], nxt[Maxm], v[Maxm], f[Maxm], cnt;
void addedge0(int x, int y, int z){
    nxt[++cnt] = hd[x];
    hd[x] = cnt;
    v[cnt] = y;
    f[cnt] = z;
}
void addedge(int x, int y, int z){
    // printf("%d %d %d\n", x, y, z);
    addedge0(x, y, z);
    addedge0(y, x, 0);
}
void clear(){
    mes(hd, -1);
    cnt = -1;
}
int d[Maxn], cur[Maxn], lid, rid, s, t;
bool bfs(){
    mes(d, -1);
    d[s] = 0;
    queue<int> q;
    q.push(s);
    int x, y;
    while(q.size()){
        x = q.front();
        q.pop();
        for(int j = hd[x]; j != -1; j = nxt[j]){
            y = v[j];
            if(f[j] && d[y] == -1){
                d[y] = d[x] + 1;
                q.push(y);
            }
        }
    }
    return d[t] != -1;
}
LL dfs(int i, LL a){
    if(a == 0 || i == t) return a;
    LL s = 0, x;
    int j, y;
    while(cur[i] != -1){
        j = cur[i];
        y = v[j];
        if(d[i] + 1 == d[y]){
            x = dfs(y, min(a, 1ll * f[j]));
            a -= x;
            s += x;
            f[j] -= x;
            f[j ^ 1] += x;
            if(a == 0) break;
        }
        cur[i] = nxt[j];
    }
    return s;
}
LL dinic(){
    LL sum = 0;
    while(bfs()){
        for(int i = lid; i <= rid; i++) cur[i] = hd[i];
        sum += dfs(s, inf);
    }
    return sum;
}
char c[25][25];
int a[25];
int main(){
	#ifndef ONLINE_JUDGE
		freopen("in","r",stdin);
		freopen("out","w",stdout);
	#endif
    clear();
    int n = read(), m = read(), x = read(), y = read(), d = 0;
    lid = s = 0, rid = t = n + m + 1;
    for(int i = 1; i <= n; i++){
        scanf("%s", c[i] + 1);
        for(int j = 1; j <= m; j++){
            if(c[i][j] == '1'){
                a[i]++;
                d++;
                addedge(i, n + j, 1);
            }
        }
    }
    for(int i = 1; i <= n; i++){
        addedge(s, i, a[i]);
        addedge(i, t, x);
    }
    for(int i = 1; i <= m; i++){
        addedge(n + i, t, y);
    }
    printf("%d\n", d - dinic());
    return 0;
}
```

---

## 作者：大宋宝宝 (赞：4)

为啥我翻了一下其他大佬的题解，他们都没一个用递归来写啊，我来发一篇递归的！
# 思路
注意到本题数据范围极小考虑使用递归算法。我们可以递归枚举选择那些蓝牌，然后计算选择这些蓝牌可以构造出牌堆的最大强度（枚举每个红牌，看看选上这个红牌能不能增加牌堆的强度，能就把它选上）。
# 代码
带有详细注释代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,ans,f[22];
bool ff[22][22],fff[22][22];
char c;
int js()
{
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		f[i]=0;
		//清空，否则一分没有（别问我怎么知道的） 
		for(int j=1;j<=m;j++)
		{
			f[i]+=fff[i][j];
		}
	}
	//对于每张红牌，算出选它能和多少张蓝牌组成好对。 
	for(int i=1;i<=n;i++)
	{
		sum+=max(0,f[i]-x);
		//如果选这张红牌能贡献答案，就选上它，否则不选。 
	}
	return sum;
}
void dfs(int now,int w)
//参数分别表示现在枚举的是第几张蓝牌，现在选上的蓝牌已经对答案产生了多少负的贡献 
{
	if(now==m+1)
	{
		ans=max(ans,js()-w);
		return ;
	}
	//如果已经选完了，就计算并更新答案。 
	for(int i=1;i<=n;i++)
	{
		fff[i][now]=ff[i][now];
	}
	//如果选了这张蓝牌，就把这张蓝牌所对应的所有红牌标记为可用（前提是它本身就能组成好对） 
	dfs(now+1,w+y);
	//继续递归 
	for(int i=1;i<=n;i++)
	{
		fff[i][now]=0;
	}
	//回溯 
	dfs(now+1,w);
	//不选 
}
int main()
{
	cin>>n>>m>>x>>y;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			ff[i][j]=c-'0';
		}
	}
	//读入数据 
	dfs(1,0);
	//递归 
	cout<<ans;
	//输出 
	return 0;
}
```

[AC证明](https://www.luogu.com.cn/record/203596091)

求过

---

## 作者：xiaoshumiao (赞：2)

注意到数据范围很小，因此考虑暴力枚举选哪些红牌。

令 $w_i$ 代表选了第 $i$ 张蓝牌的话，会有哪些红牌和他产生贡献。为了方便，可以转化成二进制数存储。显然这个东西可以预处理出来。

设当前选的红牌集合为 $i$（也是一个二进制数），可以枚举所有蓝牌。对于第 $j$ 张蓝牌，如果该蓝牌的贡献 $i \cap w_j$（实现时可以使用按位与运算）比 $y$ 大，那么表示选第 $j$ 张蓝牌是赚的。将其贡献累加到计数器上，最后减去 $x \times \operatorname{popcount}(i)$ 就是答案。

时间复杂度 $O(2^NM)$，代码实现如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=30; char s[N][N]; int w[N];
int main() {
    ios::sync_with_stdio(false),cin.tie(nullptr);
    int n,m,x,y,ans=0; cin>>n>>m>>x>>y;
    for(int i=1;i<=n;i++) cin>>(s[i]+1);
    for(int i=1;i<=m;i++) for(int j=1;j<=n;j++) if(s[j][i]-'0') w[i]|=(1<<(j-1));
    for(int i=0;i<(1<<n);i++) {
        int sum=-x*__builtin_popcount(i);
        for(int j=1;j<=m;j++) sum+=max(__builtin_popcount(i&w[j])-y,0);
        ans=max(ans,sum);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：tujize (赞：2)

# P11475题解
一群大佬都用了一些我不知道的方法，我感觉我被降维打击了，为什么不用暴力？

---

## 我的脑子里：
$
n
$
的范围很小，我立刻想到了**状压枚举红牌状态**，蓝牌在红牌一定时选的状态是一定的，一张蓝牌只要和红牌组成好对的对数大于
$
Y
$
那么收益为正，选。时间复杂度
$
O(2^n\times n^2)
$
，我立马干了起来，但不优化我就是不爽，所以我把时间复杂度优化成了
$
O(2^n\times n)
$
，也不算太麻烦吧

---

## code
有注释版：

```cpp
# include <bits/stdc++.h>//万能头
# define int LL
# define bpc __builtin_popcount
# define geti(x, i) (((x) >> (i)) & 1)
# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)//一堆define
using namespace std;
using LL = long long;
int n, m, x, y, ans, val, cnt;
char ok[25][25]；
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m >> x >> y;//输入
	rep(i, 1, n){
		cin >> ok[i] + 1;
	}
	rep(s, 0, (1 << n) - 1){//枚举红牌 
		val = bpc(s) * (-x);//先把-x*r算出来
		rep(i, 1, m){
			cnt = 0;//归零
			rep(j, 0, n - 1){
				if(geti(s, j)) cnt += (ok[j + 1][i] - '0');//如果可以和这一位组成好对 
			}
			if(cnt - y > 0) val += cnt - y;//更新价值 
		}
		ans = max(ans, val);
	}
	cout << ans;//输出
	return 0;//完美撒花，结束
}
```
清爽无注释：

```cpp
# include <bits/stdc++.h>
# define int LL
# define bpc __builtin_popcount
# define geti(x, i) (((x) >> (i)) & 1)
# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
using namespace std;
using LL = long long;
const int N = 25;
int n, m, x, y, ans, val, cnt;
char ok[N][N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m >> x >> y;
	rep(i, 1, n){
		cin >> ok[i] + 1;
	}
	rep(s, 0, (1 << n) - 1){
		val = bpc(s) * (-x);
		rep(i, 1, m){
			cnt = 0;
			rep(j, 0, n - 1){
				if(geti(s, j)) cnt += (ok[j + 1][i] - '0'); 
			}
			if(cnt - y > 0) val += cnt - y;
		}
		ans = max(ans, val);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：mzyexueda (赞：1)

## 分析
题目数据范围很小，可以想到暴力。

暴力和位运算枚举选了哪些红牌，再循环求出蓝牌的贡献值，取最大即可，复杂度足以通过题目。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,x,y,c=0,z=0,f=0;
char a[1000][1000];
int main(){
cin>>n>>m>>x>>y;
for(long long i=0;i<n;i++){
for(long long k=0;k<m;k++){
cin>>a[i][k];
}
}
for(long long i=0;i<1<<n;i++){//枚举红牌
z=0;
for(long long j=0;j<n;j++){
if((i>>j)&1){
z-=x;
}
}
for(long long k=0;k<m;k++){
c=0;
for(long long j=0;j<n;j++){
if((i>>j)&1 && a[j][k]=='1'){
c++;
}
}
if(c>y){
z+=c-y;
}
}
f=max(z,f);//求最大强度
}
cout<<f;
return 0;
} 
```

---

## 作者：Cells (赞：1)

这道题成功让我降智，胡了半天 DP，最后暴力过了……楼上金牌爷的 dinic 看的鄙人瑟瑟发抖，默默写下了暴力题解……

[COCI 2024/2025 #3 Unofficial Mirror赛后总结](https://www.cnblogs.com/MrTourist/p/18638929)。

## 思路

$n$ 的范围很小，很难不让人状压枚举红牌状态，蓝牌在红牌一定时选的状态是一定的，一张蓝牌只要和红牌组成好对的对数大于 $Y$ 那么收益为正，选。时间复杂度 $O(2^n \times n ^ 2)$，如果把是不是好对再压，可以做到 $O(2^n \times n)$。

## Code

```c++
# include <bits/stdc++.h>
# define int LL

# define bpc __builtin_popcount
# define geti(x, i) (((x) >> (i)) & 1)

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
using namespace std;

using LL = long long;

const int N = 25;

int n, m, x, y, ans, val, cnt;
char ok[N][N];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> m >> x >> y;
	
	rep(i, 1, n){
		cin >> ok[i] + 1;
	}
	
	rep(s, 0, (1 << n) - 1){//枚举红牌 
		val = bpc(s) * (-x);//先把-X*r算出来
		
		rep(i, 1, m){
			cnt = 0;
			
			rep(j, 0, n - 1){
				if(geti(s, j)) cnt += (ok[j + 1][i] - '0');//如果可以和这一位组成好对 
			}
			
			if(cnt - y > 0) val += cnt - y;//更新价值 
		}
		
		ans = max(ans, val);
	}
	
	cout << ans;
	
	return 0;
}
```

膜拜金牌爷%%%

---

## 作者：__CJY__ (赞：1)

## 题意简述
选择红蓝牌构成牌堆，计算牌堆强度，强度为好对数减去红牌数乘 $X$ 和蓝牌数乘 $Y$，求最大强度。
## 思路
先把该读的都读入进来。

使用位运算枚举所有可能的红牌组合（$0\sim2^N-1$）。对于每种组合，初始化好对数量 $ans$ 为 $0$。

对于每种蓝牌，计算当前红牌组合中能与这张蓝牌形成好对的红牌数量 $c$。如果 $c>Y$，则对强度有正面贡献，贡献为 $c-Y$。

对于当前红牌组合，减去选择的红牌数量乘 $X$，并更新最大强度 $ma$。

最后输出 $ma$ 就行了！

以下是做题步骤：
* 读入信息。
* 枚举所有红牌组合：
  * 遍历所有蓝牌：
    * 计算当前蓝牌能与多少张选中的红牌形成好对。
    * 如果好对数量大于 $Y$，则对强度有正面贡献。
  * 减去选择的红牌数量乘 $X$。
  * 更新 $ma$。
* 输出 $ma$。

---

## 作者：RAY091016 (赞：0)

### 1. 题目解释

题目写得比较清楚了，自己看题吧。

### 2. 思路

看到 $1\le N,M\le21$，不难联想到状态压缩（数据范围这么小的好像也只有状压和 DFS）。

我们考虑用一个 $N$ 位二进制数表示红牌的状态，如果这个二进制数的第 $i$ 位为 $1$，就代表选了第 $i$ 张红牌。

然后我们考虑选了第 $i$ 张蓝牌后牌堆强度会如何变化。

首先牌堆的强度会下降 $X$。

其次，我们将这张蓝牌与红牌一一匹配，假如是“好对”，就将强度加一。

如果“好对”的数量大于等于 $X$，我们就选出这张蓝牌。

并且因为蓝牌之间是没有影响的，所以上述策略一定是正确的。

### 3. 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,x,y,maxn=-1e9;
char a[100][100];
signed main(){
	cin>>n>>m>>x>>y;
	for(int i=1;i<=n;i++){
		string s;
		cin>>s;
		for(int j=0;j<s.size();j++){
			a[i][j+1]=s[j];
		}
	}
	for(int i=0;i<(1<<n);i++){
		int ans=0;
		for(int k=1;k<=m;k++){
			int cnt=0;
			for(int j=0;j<n;j++){
				if(((i>>j)&1)==1&&a[j+1][k]=='1'){
					cnt++;
				}
			}
			if(cnt>y){
				ans+=cnt-y;
			}
		}
		for(int j=0;j<n;j++){
			if(((i>>j)&1)==1){
				ans-=x;
			}
		}
		maxn=max(maxn,ans);
	}
	cout<<maxn;
	return 0;
}
```

---


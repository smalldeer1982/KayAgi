# 安全逃离（数据有误）

## 题目背景

**注意本题数据有误，请暂时不要提交**

## 题目描述

农夫`john`最近在研究如果发生重大事故，如何让农场里的奶牛逃离问题。他想要确信在紧急情况下，所有的奶牛都有一个安全逃离方案。因为在紧急情况下，奶牛们都会失去观察和判断能力，所以最近`john`一直在教奶牛们逃离的方法，他的方法很简单，就是任何时候都只向北方或东方逃离，北方是行坐标减1的方向，东方是列坐标加1的方向。奶牛们虽笨，不过这一点事关自己的生命，所以他们牢记在心，而且也一定会这么做。

当然也会出问题，奶牛们在逃离的方向上会横冲直撞，为了阻止奶牛之间互相冲撞造成伤害，`john`要求任何一个奶牛的逃离路线不能经过其它奶牛的初始位置。一个逃离方案是安全的如果它能够满足上面的要求，反之它就是不安全的。

奶牛们所在的土地（农场）被划分成了$r$行和$c$列的一个矩形地图。奶牛们都待在这个矩形中的某一个位置。

请帮助`john`确定给定的一个地图上是否存在一个安全的逃离方案。

比如，下面的两个图：

左边的例子表示了一个能够安全逃离的地图，因为没有任何一个奶牛的逃离路线上包括其他奶牛。右边的例子表示了一个不安全的地图，因为位于$(4,1)$的奶牛不论是向东逃离还是向北逃离，它的路线上都会有别的奶牛，从这个图中拿掉任意一头奶牛，这个地图都会变成安全的。

```plain
  安全     不安全
- ||||C--  C.....
- ||||C--  ^.....
- |C||C--  |.....
- CC++---  C-->C.
- ..CCC--  ......
```

`C` 表示奶牛，直线表示逃离路线。

## 样例 #1

### 输入

```
5 5
5
1 1
2 4
3 1
2 2
2 1
```

### 输出

```
1
5
```

# 题解

## 作者：jacky567 (赞：21)

# **C++题解**

这一题的题目有问题（我在百度上查了，所有题目都是错的。多亏了洛谷的在线测评，把题解复制在上面执行，就可以知道题目错误了。）。我之前的题解有一些地方错了，C++党是可以拿到100分的。我整整研究了一天才研究出来。最后，我是在另一个人提交的AC程序上找出了我的错误。这个错误你根本是不可能想到的（虽然我不知道以前的人是怎么发现的），这个错误是：再输入完一组数据后，**会输入多余的字符！！！**其实这个问题我在另一个OJ上也有注意到（那个OJ可以下载不完整的数据），但是我并不知道这是一个漏洞。

这道题的第一个思路就是模拟，首先遍历所有的奶牛，若全部安全，则输出0，结束。如果不是全部安全的，则每次将一只奶牛删除，再遍历全部，看看是否全是安全的，如果是，则**输出该奶牛编号，不停止程序，也不输出1**（这就是题目错误的另一个地方）直到所有情况都遍历完了，在讨论-1的情况。

第二个思路是我一开始的方法，先将每只奶牛的北边和东边的奶牛数目算出来，再进行判断。

思路一的代码如下：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int m[50][50],h,l,n;
struct cow{     //结构体，也可以用x[101]和y[101] 
  int x,y;
};
cow a[51];
int anquan(int x,int y){     //每头奶牛安全的条件 
  int t1=1,t2=1;
  for(int i=1;i<x;i++) if(m[i][y]) {t1=0;break;}     //如果北面有奶牛，那么t1=0 
  for(int i=y+1;i<=l;i++) if(m[x][i]) {t2=0;break;}     //如果东面有奶牛，那么t2=0 
  if(t1==0&&t2==0) return 0; else return 1;     //如果两边都有奶牛，则不安全，反之安全 
}
int qaq(){     //所有奶牛都安全 
  for(int i=1;i<=h;i++) for(int j=1;j<=l;j++) if(m[i][j]) if(!(anquan(i,j))) return 0;     //遍历整个农场，如果有奶牛不安全，那么返回0 
  return 1;     //否则返回1 
}
int aq(int x,int y){     //去掉一只奶牛后安全
  m[x][y]=0;     //删除奶牛
  return qaq();
}
int main()
{
  int temp=0;
  char s[50];
  cin>>h>>l>>n;
  memset(a,0,sizeof(a));memset(m,0,sizeof(m));     //初始化 
  for(int i=1;i<=n;i++){
    cin>>a[i].x>>a[i].y;     //输入 
    m[a[i].x][a[i].y]=i;     //也可以赋值为1 
    gets(s);
  }
  if(qaq()) {cout<<0;return 0;}     //如果全部安全，输出0，结束 
  for(int i=1;i<=n;i++){
  	if(aq(a[i].x,a[i].y)) /*如果去掉后安全*/if(!temp) /*如果是第一次输出*/cout<<i,temp++; else cout<<endl<<i; 
  	m[a[i].x][a[i].y]=i;     //这步非常重要，不然第二次执行的时候就删除了两只奶牛 
  }
  if(!temp) cout<<1;     //如果删掉任何一只奶牛都不安全，输出-1 
  return 0;
}
```
思路二代码：
```cpp
//此代码只能得90分
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
struct cow{     //结构体 
  int x,y,no,d,b;
};
cow a[101];
int main()
{
  int m[51][51],h,l,n,temp=0/*用来判断有没有删除奶牛*/,bh=0;
  char s[100];
  cin>>h>>l>>n;
  memset(a,0,sizeof(a));memset(m,0,sizeof(m));     //初始化 
  for(int i=1;i<=n;i++){     //输入 
    cin>>a[i].x>>a[i].y;
    a[i].no=i;     //这一步其实没用 
    m[a[i].x][a[i].y]=i;     //一定要定义为奶牛的编号，便于操作
    gets(s);
  }
  for(int i=1;i<=n;i++){
    for(int j=1;j<a[i].x;j++) if(m[j][a[i].y]) a[i].b++;     //统计北边的奶牛数量 
    for(int j=a[i].y+1;j<=l;j++) if(m[a[i].x][j]) a[i].d++;     //统计东边的奶牛数量 
    if((a[i].b>1&&a[i].d>1)&&temp==0){     //删除该奶牛本身 
      temp=1;bh=i;continue;
    }
    if((a[i].b>1&&a[i].d>1)&&temp!=0||(a[i].b==1&&a[i].d>=1||a[i].d==1&&a[i].b>=1)&&temp!=0){     //这头奶牛怎么走都走不出去了 
      cout<<-1;return 0;
    }
    if((a[i].b==1&&a[i].d>=1||a[i].d==1&&a[i].b>=1)&&temp==0){     //该奶牛需要删除一只奶牛后就可以逃生（也可以删除该奶牛本身） 
      temp=1;bh=i;continue;
    }
  }
  if(temp==0){     //没有删除奶牛 
    cout<<0;
  }
  else{
    if(a[bh].b>1&&a[bh].d>1){     //两边都有不止一只的奶牛 
      cout<<bh;
    }
    if(a[bh].b==1&&a[bh].d>1){     //北边只有一只，东边不止一只奶牛 
      for(int i=1;i<a[bh].x;i++){
        if(m[i][a[bh].y]){
          cout<<min(m[a[bh].x][a[bh].y],m[i][a[bh].y])<<endl<<max(m[a[bh].x][a[bh].y],m[i][a[bh].y]);break;     //可以删除它本身，也可以删除北边的那一只 
        }
      }
    }
    if(a[bh].d==1&&a[bh].b>1){     //东边只有一只，北边不止一只奶牛 
      for(int i=a[bh].y+1;i<=l;i++){
        if(m[a[bh].x][i]){
          cout<<min(m[a[bh].x][a[bh].y],m[a[bh].x][i])<<endl<<max(m[a[bh].x][a[bh].y],m[a[bh].x][i]);break;     //可以删除它本身，也可以删除东边的那一只
        }
      }
    }
    if(a[bh].d==1&&a[bh].b==1){     //东边只有一只，北边也只有一只奶牛
      int t1,t2=m[a[bh].x][a[bh].y],t3;
      for(int i=a[bh].y+1;i<=l;i++){
        if(m[a[bh].x][i]){
          t1=m[a[bh].x][i];break;
        }
      }
      for(int i=1;i<a[bh].x;i++){
        if(m[i][a[bh].y]){
        	t3=m[i][a[bh].y];     //可以删除它本身，北边的那一只，也可以删除东边的那一只
        	if(t1>t2) swap(t1,t2); if(t2>t3) swap(t2,t3); if(t1>t2) swap(t1,t2);     //三个数排序 
          cout<<t1<<endl<<t2<<endl<<t3;break;
        }
      }
    }
  }
  return 0;
}
```

---

## 作者：Eraine (赞：6)

**101枚举**NO:06

该题解选自本人CSDN博客[P1172](https://blog.csdn.net/lanyecch/article/details/105882399)
# 题面（题目有误，略加更改）
[P1172](https://www.luogu.com.cn/problem/P1172)

难度：☆☆☆（普及/提高-）

知识点：01枚举，暴力；02模拟
## 输出格式
如果这块土地是安全的，输出0。

如果移走任意一头奶牛这块土地还是不安全，输出-1。否则输出1，并且在下一行输出移走的那头奶牛的编号，如果有多个奶牛满足要求，按字典序输出所有。
# 思路
这是洛谷里枚举算法的第6道题目。
## 定义结构体

其实做法很简单。首先，因为一头牛可能有多个信息，所以当然要用到结构体啦！每个结构体储存的分别是每头奶牛所在的行和列。
```C++
struct nn{
	int x,y;//x和y分别表示每头奶牛所在的行和列
}b[101];
```
题目中有给我们**3**种情况，就来一一枚举。
## 定义安全函数
在这里我们可以定义一个函数，因为第一种情况和第二种情况都要用到，即判断是否安全逃离的情况。这里因为数据很小，所以思路简单些，就是判断每头奶牛是否**上方**（北边）和**右方**（东边）都有奶牛。若**都**有，则这头奶牛是不安全的，反之，则是安全的。
```C++
bool p(int x,int y){
	bool g=true;//这里的g是用来储存是否该行是安全的
	for(int i=x-1;i>0;i--){
		if(a[i][y])g=false;
	}
	for(int i=y+1;i<=c;i++)if(a[x][i]&&g==false)return true;//当g==false，即该行不安全时，再进行判断
	return false;
}
```
## 第一种情况
第一种情况：本身即可安全逃离

我们从第1头奶牛到第n头奶牛一直判断，思路比较简单。（注：若有出现第一种情况，则程序不再运行）
```C++
bool g=true;
	for(int i=1;i<=n;i++){
		if(p(b[i].x,b[i].y))g=false;
	}
	if(g==true){
		cout<<"0";
		return 0;
	}
}
```
## 第二种情况
第二种情况：可以去掉一头奶牛，使土地安全
这种情况是基于上一种情况上的复杂版。思路是这样子的：当然从第1头奶牛从第n头奶牛一直模拟，每层模拟中把第i头奶牛去掉，也就是里面的判断是否安全的循环需要忽略第i头奶牛。
```C++
bool l=true;
for(int i=1;i<=n;i++){
	a[b[i].x][b[i].y]=false;//不把第i头奶牛存入地图
	bool h=true;
	for(int j=1;j<=n;j++){
		if(i==j)continue;//省略第i头奶牛
		if(p(b[j].x,b[j].y))h=false;
	}
	if(h){
		cout<<i<<endl;
		l=false;//这里是用来判断是否有存在第二种情况的可能出现
	}
	a[b[i].x][b[i].y]=true;
}
```
## 第三种情况
第三种情况比较简单，就是如果不出现第二种情况，即l=true，则执行。代码如下：
```C++
if(l)cout<<"-1";
```
# AC代码
```C++
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int r,c;
char t[205];
struct nn{
	int x,y;
	bool g;
}b[101];
bool a[51][51];
bool p(int x,int y){
	bool g=true;
	for(int i=x-1;i>0;i--){
		if(a[i][y])g=false;
	}
	for(int i=y+1;i<=c;i++)if(a[x][i]&&g==false)return true;
	return false;
}
int main(){
	memset(a,0,sizeof(a));
	int n;
	cin>>r>>c>>n;
	for(int i=1;i<=n;i++){
		cin>>b[i].x>>b[i].y;
		a[b[i].x][b[i].y]=true;
		gets(t);
	}
	bool g=true,l=true;
	for(int i=1;i<=n;i++){
		if(p(b[i].x,b[i].y))g=false;
	}
	if(g==true){
		cout<<"0";
		return 0;
	}
	for(int i=1;i<=n;i++){
		a[b[i].x][b[i].y]=false;
		bool h=true;
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			if(p(b[j].x,b[j].y))h=false;
		}
		if(h){
			cout<<i<<endl;
			l=false;
		}
		a[b[i].x][b[i].y]=true;
	}
	if(l)cout<<"-1";
	return 0;
}
```

---

## 作者：梧桐灯 (赞：3)

我来清楚的盘点一下此题的问题：

1. 读完每一头奶牛的横纵坐标，请用gets读一下（数据后面可能有乱码），但不能用快读，因为乱码中有数字（快读70）

1. 最后输出1的情况其实应该从小到大输出牛的编号。比如样例应该输出：

```
1
5

```

代表删除1号奶牛和5号奶牛可以使图变得安全。

至于模拟，我则用了纯暴力$O(n^3)$

```cpp
#include <cstdio>
using namespace std;

int n, m;
struct stu {
	int x;
	int y;
}s[105];

char r[55];

int main () {
	scanf ("%d %d", &n, &m);
	int i, j, k, u;
	scanf ("%d", &k);
	for (i = 1; i <= k; i++) {
		scanf ("%d %d", &s[i].x, &s[i].y);
        gets (r); //读入乱码
    }
	bool f1, f2;
	for (i = 1; i <= k; i++) {
		f1 = f2 = 0;
		for (j = 1; j <= k; j++) {
			if (i == j)
				continue;
			if (s[j].y == s[i].y && s[j].x < s[i].x)
				f1 = 1;
			if (s[i].x == s[j].x && s[j].y > s[i].y)
				f2 = 1;
		}
		if (f1 && f2)
			break;
	}
	if (i > k) {
		puts ("0");
		return 0;
	} //如果全部安全输出0
    bool wh = 1;
	for (i = 1; i <= k; i++) { //枚举删除第i号奶牛
		for (j = 1; j <= k; j++) {
			if (j == i)
				continue;
			f1 = f2 = 0;
			for (u = 1; u <= k; u++) {
				if (u == i || u == j)
					continue;
				if (s[u].y == s[j].y && s[u].x < s[j].x)
					f1 = 1;
				if (s[u].x == s[j].x && s[u].y > s[j].y)
					f2 = 1;
			}
			if (f1 && f2)
				break;
		}
		if (j > k) {
			printf ("%d\n", i);
		    wh = 0;
		}
	}
    if (wh)	puts ("-1");
	return 0;
}
```


---

## 作者：猪猪 (赞：3)

//就是纯模拟...对每一个牛能否走出去进行判断








```cpp
var a:array[0..50,0..50] of boolean;
x,y:array[1..100] of longint;
b,e,f,b1:boolean;
    r,c,n,i,j:longint;
procedure pd(d:longint);//这是删除牛后的判断
 var b:boolean; i1:longint;
   begin
   b:=true;
     for i1:=1 to n do
        begin
        if d<>i1 then
        begin
        e:=true;
        for j:=1 to x[i1]-1 do if a[j,y[i1]] then e:=false;
        if e then  continue;
        if not e then
         begin
          e:=true;
          for j:=y[i1]+1 to c do if a[x[i1],j] then e:=false;
         end;
         if not e then begin b:=false; break; end;
       end;
      end;
   if b then
     begin
      b1:=true;
      writeln(d);
     end;
   end;
      begin
       readln(r,c);
       readln(n);
      for i:=1 to n do
       begin
        readln(x[i],y[i]);
        a[x[i],y[i]]:=true;
       end;
   b:=true;
     for i:=1 to n do
        begin
        e:=true;
        for j:=1 to x[i]-1 do if a[j,y[i]] then e:=false;//判断上方
        if e then  continue;
        if not e then
         begin
          e:=true;
          for j:=y[i]+1 to c do if a[x[i],j] then e:=false;//判断右方
         end;
         if not e then begin b:=false; break; end;
       end;
        if b then begin  writeln(0); halt; end;//如果都可行就输出0
 b1:=false;
   if not b then
     begin
      for i:=1 to n do//枚举删除牛的位置
        begin
          a[x[i],y[i]]:=false;//删除
          pd(i);//然后再判断
          a[x[i],y[i]]:=true;//复原..这步一定要...不然可能会炸
        end;
     end;
    if not b1 then writeln(-1);
 end.

```

---

## 作者：姬海棠果 (赞：2)

首先判断所有奶牛，如果它右边和上边都有奶牛，那么它不能逃离

如果都能逃离，输出0

再枚举删掉哪只奶牛，并进行与开始相同的操作，如果枚举到奶牛i其他的都可逃离，直接输出，不必继续枚举

如果枚举完毕还没有输出，就输出-1

代码如下：




```cpp
program Evac;
const
maxr=50;
maxn=100;
var
a:array[1..maxr,1..maxr] of byte;
N:byte;
cows:array[1..maxn,1..4] of byte;
R,C:byte;
procedure init;
var i:byte;
begin
assign(input,'evac.in');
reset(input);
assign(output,'evac.out');
rewrite(output);
readln(R,C);
fillchar(a,sizeof(a),0);
readln(N);
fillchar(cows,sizeof(cows),0);
for i:=1 to N do
begin
readln(cows[i,1],cows[i,2]);
a[cows[i,1],cows[i,2]]:=i;
end;
close(input);
end;
procedure solve;
var id,i,j,t,t1,x:byte;
flag:boolean;
begin
t:=0;
for id:=1 to N do
begin
for i:=1 to cows[id,1]-1 do
if a[i,cows[id,2]]<>0 then inc(cows[id,3]);
for j:=cows[id,2]+1 to C do
if a[cows[id,1],j]<>0 then inc(cows[id,4]);
end;
for id:=1 to N do if cows[id,3]*cows[id,4]<>0 then inc(t);
if t=0 then
begin writeln(0);exit;end;
flag:=true;
for id:=1 to N do
begin
t1:=t;
if cows[id,3]*cows[id,4]<>0 then dec(t1);
for i:=cows[id,1]+1 to R do
if a[i,cows[id,2]]>0 then
begin
x:=a[i,cows[id,2]];
if (cows[x,3]=1)and(cows[x,4]<>0) then dec(t1);
end;
for j:=1 to cows[id,2]-1 do
if a[cows[id,1],j]>0 then
begin
x:=a[cows[id,1],j];
if (cows[x,4]=1)and(cows[x,3]<>0) then dec(t1);
end;
if t1=0 then
begin writeln(id);flag:=false; end;
end;
if flag then writeln(-1);
end;
begin
init;
solve;
close(output);
end.
```

---


# [KOI 2024 Round 2] 路灯

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在一条数轴表示的直线道路上，安装了 $N$ 盏路灯。每盏路灯的位置按从左到右依次为 $A_1 < A_2 < \cdots < A_N$。

我们定义某个位置 $x$ 的“黑暗程度”为该位置到所有路灯之间距离的最小值。即，黑暗程度等于数列 $|A_1 - x|, |A_2 - x|, \dots, |A_N - x|$ 中的最小值。其中，$|y|$ 表示 $y$ 的绝对值，若 $y \geq 0$，则 $|y| = y$；若 $y < 0$，则 $|y| = -y$。

例如，若 $N = 3$，且路灯分别位于 $A_1 = 1$、$A_2 = 4$、$A_3 = 8$，那么从位置 $x = 0$ 到 $x = 10$ 的黑暗程度如下：

| 位置 $x$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|----------|---|---|---|---|---|---|---|---|---|----|----|
| 黑暗程度 | 1 | 0 | 1 | 1 | 0 | 1 | 2 | 1 | 0 | 1  | 2  |
| 是否有灯 |   | O |   |   | O |   |   |   | O |    |    |

给定一个整数 $L$，我们关心从 $x = 0$ 到 $x = L$ 这 $L+1$ 个整数位置的黑暗程度。请你编程，输出其中按黑暗程度从小到大排序后的前 $K$ 小的值。

## 说明/提示

**约束条件**

- 所有输入为整数。
- $1 \leq L \leq 10^{18}$
- $1 \leq N \leq 3 \times 10^5$
- $1 \leq K \leq 5 \times 10^5$
- $K \leq L + 1$
- $0 \leq A_1 < A_2 < \cdots < A_N \leq L$

**子问题**

1. （10 分）$N = 1$  
2. （20 分）$N \leq 2\,500,\ L \leq 2\,500$  
3. （15 分）$2 \leq N$ 且 $N - 1$ 整除 $L$，且 $A_i = \dfrac{L}{N-1} \times (i - 1)$  
4. （20 分）$L \leq 5 \times 10^6$  
5. （35 分）无额外限制条件

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
10 3 4
1 4 8```

### 输出

```
0
0
0
1```

## 样例 #2

### 输入

```
4 5 5
0 1 2 3 4```

### 输出

```
0
0
0
0
0```

## 样例 #3

### 输入

```
7 1 4
3```

### 输出

```
0
1
1
2```

## 样例 #4

### 输入

```
9 4 10
0 3 6 9```

### 输出

```
0
0
0
0
1
1
1
1
1
1```

# 题解

## 作者：Heyg_future (赞：5)

# P12648 [KOI 2024 Round 2] 路灯
## [题目在这里](https://www.luogu.com.cn/problem/P12648)
~~哇，这题差点搞死我啊，卡了我好好好久。~~
## Solution
其实本题看似复杂其实一点也不复杂，看似要用各种各样的离奇优化方式，其实就是一道暴力题，只要做法想出来了就直接暴力即可。

看到这种看似要给每个位置遍历一遍的题目，一定要往另一个方向去想。

既然不可以遍历位置，那我们可以遍历到路灯的距离。

首先，路灯所在地的黑暗程度绝对为 $0$，~~废话~~。

```cpp
for(int i=1;i<=min(k,n);i++) cout<<"0\n";
k-=n; 
```
然后枚举是否可以与路灯 $j$ 距离为 $i$ 处形成一个点使这个点未被遍历过且在 $j$ 与 $j+1$，$j$ 与 $j-1$ 之间，如果成立，输出即可，否则继续。

代码也十分简单。
```cpp
for(int i=1;i<=l;i++){
	for(int j=1;j<=n;j++){
		if(a[j]-a[j-1]>i&&f.find(a[j]-i)==f.end()) 
			cout<<i<<"\n",k--,f[a[j]-i]=1;
		if(!k) return 0;
		if(a[j+1]-a[j]>i&&f.find(a[j]+i)==f.end()) 
			cout<<i<<"\n",k--,f[a[j]+i]=1;
		if(!k) return 0;
	}
}
```
注意，要将位置 $-1$ 与位置 $L+1$ 也当作有一个路灯来框定范围，并且这两个位置不用加入上述处理。

代码。
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<map>
#define int long long
using namespace std;
const int N=405000;
int n,l,k,a[N],s;
map<int,int> f;
signed main(){
	cin>>l>>n>>k;
	a[0]=-1;
	a[n+1]=l+1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=min(k,n);i++) cout<<"0\n";
	k-=n; 
	if(k<=0) return 0;
	for(int i=1;i<=l;i++){
		for(int j=1;j<=n;j++){
			if(a[j]-a[j-1]>i&&f.find(a[j]-i)==f.end()) 
				cout<<i<<"\n",k--,f[a[j]-i]=1;
			if(!k) return 0;
			if(a[j+1]-a[j]>i&&f.find(a[j]+i)==f.end()) 
				cout<<i<<"\n",k--,f[a[j]+i]=1;
			if(!k) return 0;
		}
	}
    return 0;
}
```
## 证明
为什么这个时间复杂度可以通过。

~~最优复杂度 $O(k)$。~~

看似这个方法在一些特殊情况下可能会出现极坏复杂度。如全部路灯挤在一起或每两个之间只相差一个距离时，可能会让它多次从遍历已经没有可以出现点的路灯。但是假设在一种情况中，一共有 $n$ 个路灯，两两距离为 $1$。$k$ 极大，为 $1\times 10^{5}$ 时。在处理完距离为 $0$ 与距离为 $1$ 的以后，一共运行了 $2n$ 次，那么剩下的输出次数为 $k-2n$ 次。若它剩余每一次都要运行至最后一个路灯时才出现符合条件的情况时，情况最坏。往坏里算要运行 $n(k-2n)=nk-2n^{2}$ 次。所以不管 $n$ 是大是小，运行次数都不大，可以稳稳通过此题。

[记录](https://www.luogu.com.cn/record/219901471)在这里。

最后，最最最重要的一点，你们知道我为什么卡了这么久吗。

那我问你，十年 OI 一场空，下一句是什么？

---

## 作者：XuZile (赞：3)

# P12648 题解
## 前言
为了解这道题也是做疯了，其实说实话就是一道模拟题。完全没必要来看题解，不过你来看了就给你介绍一下吧。我用的方法应该是最简单易懂的，~~但我看题解区的大佬就没有跟我一个方法的倒~~。
## 解题思路
首先分析数据大小，发现 $L$ 的数据太大了，无法用这个进行遍历。但是 $K$ 和 $N$ 的数据很小，我们可以以此当做突破口。我们可以去枚举黑暗值从小到大以此枚举，并统计前 $K$ 个黑暗值。

第一步：要完成这个需要维护个数组，用来统计第 $i$ 个路灯与第 $i-1$ 个路灯之间的长度。

第二步：从小到大枚举黑暗值，再枚举 $N$，寻找两个路灯间有几个符合条件的黑暗值。这里就是这篇代码除思路外最重要的地方 ~~（其实也很简单）~~，我在这里设第 $i$ 个与第 $i-1$ 个路灯间的距离为 $S$，所枚举到的黑暗值为 $X$。那么我们可以发现如果 $\dfrac{S}{2} \ge X$，那么这两个路灯间就有 2 个满足条件的黑暗值产生，如果 $X\times2-1=S$，那么就有 1 个满足条件的黑暗值产生。

第三步：等到前 $K$ 个黑暗值全部产生后，输出得到的所有黑暗值。

本篇题解的时间复杂度约为 $O(K)$。
## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int l,n,k,c;
int b[1000010];
int a[1000010];
int s[1000010];
bool flag[1000010];
signed main(){
	cin >> l >> n >> k;
	if(k<=n){
		for(int i=1;i<=k;i++) cout << "0\n";
		return 0;
	}
	a[0]=-1;
	for(int i=1;i<=n;i++) cin >> a[i];
	for(int i=1;i<=n;i++) b[i]=a[i]-a[i-1]-1;
	b[n+1]=l-a[n];
	int id=1;
	for(int i=1;i<=n;i++) s[++c]=0;
	k-=n;
	while(k){
		if(b[1]>=id) s[++c]=id,k--;
		if(k==0) break;
		if(b[n+1]>=id) s[++c]=id,k--;
		if(k==0) break;
		for(int i=2;i<=n;i++){
			if(flag[i]) continue; 
			if(b[i]/2>=id){
				s[++c]=id,k--;
				if(k==0) break;
				s[++c]=id,k--;
				if(k==0) break;
			}else if(id*2-1==b[i]) s[++c]=id,k--;
			else flag[i]=1;
			if(k==0) break;
		}
		id++;
	}
	for(int i=1;i<=c;i++) cout << s[i] << "\n";
	return 0;
}
```

---

## 作者：ylch (赞：1)

$L=10^{18}$，直接枚举每个点的值为多少肯定不行。

考虑从每个路灯入手，距离为 $0$ 的点就是每个路灯的所在位置，距离为 $1$ 的点就是每个路灯所在位置减一或加一……

所以可以从小到大枚举距离 $d$，然后枚举每个路灯 $i$，判断 $a_i-d$ 和 $a_i+d$ 是否合法。

判断条件：

1. 位置 $x$ 在坐标轴上，即位置 $x \in [0,L]$。
   
2. $i$ 一定是距离 $a_i-d$ 和 $a_i+d$ 最近的路灯，否则这个位置的黑暗程度就不是由路灯 $i$ 主导的，会被其他路灯“捷足先登”。

3. 确保这个位置是第一次访问，用 map 标记一下即可。

时间复杂度 $O(K \log N)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 3e5 + 7;

ll L, n, k, a[maxn], now;
map<ll, bool> vis;

void solve()
{
	cin >> L >> n >> k;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	a[0] = -1e18-1, a[n + 1] = 1e18+1; // 初始化边界，不然在n=1时会有问题
	
	for(int d = 0; d <= k; d ++){ // 枚举距离
		for(int i = 1; i <= n; i ++){
			ll l = a[i] - d, r = a[i] + d;
			if(l >= 0 && l - a[i - 1] >= d/*确保a[i]是距离l最近的路灯*/ && !vis[l]){
				cout << d << '\n'; now ++; vis[l] = 1;
			}
			if(now == k) return ;
			if(d == 0) continue; // 只有当前位置，特判一下
			if(r <= L && a[i + 1] - r >= d && !vis[r]){
				cout << d << '\n'; now ++; vis[r] = 1;
			}
			if(now == k) return ;
		}
	}
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```

---

## 作者：cln2012 (赞：1)

翻了翻 dalao 们的题解，发现好像没人写 bfs，模拟的程序调了半天还是没搞出来。那本蒟蒻就写一篇用 bfs 的题解。~~调了两个半小时，累死我了。~~

思路
---
把每一盏路灯当作 bfs 的起点，初始的黑暗程度都是 $0$。之后入队的每个点的黑暗程度就是让 TA 入队的点的黑暗程度 $+1$。记得边入队边输出，$L$ 的范围是 $1\le L \le10^{18}$。

code
---
```cpp
#include <iostream>
#include <unordered_set>
#include <queue>
#define int long long
using namespace std;
unordered_set<int> xyx; 
int a[300005],l,n,k;
struct node{
	int x,s;
};
void bfs(){
	queue<node> q;
	for(int i=1;i<=n;i++){
		xyx.insert(a[i]);
		q.push({a[i],0});
		printf("0\n"); 
		k--;
		if(k==0) return ;
	}
	while(!q.empty()){
		node tmp=q.front();
		q.pop();
		if(xyx.find(tmp.x-1)==xyx.end()&&tmp.x!=0){
			xyx.insert(tmp.x-1);
			q.push({tmp.x-1,tmp.s+1});
			printf("%lld\n",tmp.s+1);
			k--;
			if(k==0) return ;
		}
		if(xyx.find(tmp.x+1)==xyx.end()&&tmp.x!=l){
			xyx.insert(tmp.x+1);
			q.push({tmp.x+1,tmp.s+1});
			printf("%lld\n",tmp.s+1);
			k--;
			if(k==0) return ;
		}
	}
	return ;
}
signed main(){
	cin >>l>>n>>k;
	for(int i=1;i<=n;i++) cin >>a[i];
	bfs();
	return 0;
}
```

---

## 作者：Hughpig (赞：1)

因为 $L\le 10^{18}$，直接枚举位置，记录每个点的亮度再排序是不行的。

考虑换个做法，去枚举距离 $d$。对于一个点 $a_i$，到它距离为 $d$ 的点有两个，$a_i-d$ 和 $a_i+d$。对于左边的点 $a_i-d$，它要符合以下条件才可行：
* 在坐标轴上，即 $0\le a_i-d\le L$。
* 到左边的灯的距离要大于等于 $d$，否则这个点亮度就会被左边的灯影响了。
* 先前没被访问过，这一点可以通过用一个 `map` 来记录。

对右边的点同理。

因为 $L,a_i\le10^{18}$，记得开 `long long` 哦。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define up(l,r,i) for(int i=(l);i<=(r);++i)

constexpr int N=3e5+7;

ll l,n,k,a[N],cnt;

map<ll,bool> vis;

int main(){
	cin>>l>>n>>k;
	up(1,n,i)cin>>a[i];a[0]=-2e18;a[n+1]=2e18;
	up(0,k,d){
		up(1,n,i){
			ll left=a[i]-d,right=a[i]+d;
			if(left>=0&&left-a[i-1]>=d&&vis[left]==0)cout<<d<<'\n',++cnt;
			vis[left]=1;
			if(cnt>=k)return 0;
			if(d==0)continue;
			if(right<=l&&a[i+1]-right>=d&&vis[right]==0)cout<<d<<'\n',++cnt;
			vis[right]=1;
			if(cnt>=k)return 0;
		}
	}
}
```

---

## 作者：ZackofZHOU (赞：1)

# 思路
## 解析
寻找的 $|a_1 - x|, |a_2 - x|, \dots, |a_n - x|$ 的最小值，可以理解为枚举每一个 $a_i$，寻找 $a_i + x$ 和 $a_i - x$，若未标记，则输出 $x$，然后对 $a_i + x$ 或 $a_i - x$ 进行标记；若标记，则跳过。
## 方法
枚举每一个 $a_i + x$ 和 $a_i - x$，$x$ 从 0 开始枚举，最终找到的数未标记的输出 $x$。
## 警示
 * 十年 OI 一场空，不开 `long long` 见祖宗。
 * $x$ 记得从小到大枚举，这样使得 $a_i + x$ 或 $a_i - x$ 是当前最小。

[AC 记录](https://www.luogu.com.cn/record/220008874)

完整代码：（有注释）
```cpp
#include<unordered_map>
#include<iostream>
#include<cmath>
using namespace std;
typedef long long ll; // 十年OI一场空，不开long long见祖宗。 
const int N = 3e5 + 10;
int n,k,cnt;
ll L,a[N];
unordered_map <ll,bool> vis; // 标记 
void Make(ll x,ll y) // 判断输出 
{
	ll z = x + y;
	if(0 <= z && z <= L) // 是否在范围之内 
	{
		if(vis.count(z))
			return;
		vis[z] = true;
		cout << abs(y) << '\n'; // 输出 
		cnt++;
		if(cnt == k)
			exit(0);
	}
}
void Work(ll x)
{
	for(int i = 1;i <= n;i++) // 枚举每一个a_i 
	{
		Make(a[i],x);
		Make(a[i],-x);
	}
	Work(x + 1); // 递归，仍然是枚举 
}
int main()
{
	cin >> L >> n >> k;
	for(int i = 1;i <= n;i++)
		cin >> a[i];
	Work(0);
	return 0;
}
```

---

## 作者：wangjunyee (赞：1)

### 题目分析
题目要求在长度为 $L$ 的数轴上，给定 $N$ 个路灯位置，计算区间 $[0, L]$ 内所有整数位置的黑暗程度（到最近路灯的距离），并输出前 $K$ 小的黑暗程度值。由于 $L$ 可达 $10^{18}$，直接枚举所有位置显然不行，需用优先队列按黑暗程度从小到大生成位置。

### 思路
使用一个优先队列（小顶堆）存储黑暗程度与位置，初始将所有路灯位置（黑暗程度为0）入队。每次弹出黑暗程度最小的位置，检查左右邻居（位置 $±1$）：若邻居在 $[0, L]$ 内且未访问，计算其黑暗程度。

对每个邻居位置，用二分查找到最近路灯，取最小距离。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
typedef long long ll;
typedef pair<ll, ll> pll; //(黑暗程度, 位置)

ll l, k, n, a[MAXN];
priority_queue<pll, vector<pll>, greater<pll>> q;
unordered_set<ll> vis; // 访问标记

//二分 
ll solve(ll x) {
    int idx = lower_bound(a, a+n, x) - a;
    ll res = 1e18;
    if (idx < n) 
        res = min(res, a[idx] - x);
    if (idx > 0) 
        res = min(res, x - a[idx-1]);
    return res;
}

int main() {
    cin >> l >> n >> k;
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // 初始化
    for (int i = 0;i < n; i++) {
        q.push({0, a[i]});
        vis.insert(a[i]);
    }

    ll cnt = 0;
	  while (!q.empty() && cnt < k) {
	    ll d = q.top().first;
	    ll pos = q.top().second;
	    q.pop();
	    cout << d << endl;
	    cnt++;
	    if (cnt >= k) break;
	
	    // 检查邻居
	    for (int i = 0; i < 2; i++) {
	        ll dir = (i == 0) ? -1 : 1; // -1左邻居，+1右邻居
	        ll nxt = pos + dir;
	        if (nxt < 0 || nxt > l || vis.count(nxt)) 
	            continue;
	        vis.insert(nxt);
	        ll nd = solve(nxt);
	        q.push({nd, nxt});
	    }
	}
    return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：0)

# P12648 [KOI 2024 Round 2] 路灯 题解

[题目传送门](https://www.luogu.com.cn/problem/P12648)

## 题目分析

由于 $L$ 很大，我们不能直接开数组计算，更不可能再进行排序。根据题目，我们可以发现，每个路灯类似于从中间开始向外扩展。因此，我们可以模拟这个扩展的过程完成此题。

### 提前处理
我们可以知道，对于每个路灯，它所在的位置的黑暗程度都为 $0$，因此我们可以先将它们都输出，方便后续处理。

要注意的是，题目中有前 $K$ 小的限制，输出时要判断有没有超过限制。

### 扩展过程
我们可以给每个路灯两个指针 $l_i,r_i(1\le i\le N,l_i \le r_i)$，表示这个路灯**下一次**将要进行扩展的位置。

接着，我们从黑暗程度为 $1$ 时开始计算，每次我们会输出当前的黑暗程度，并将左指针 $l_i$ 向左移，右指针 $r_i$ 向右移，直到输出了前 $K$ 小的。

当然，其间也有一定的限制要判断：  
* 判断指针是否在 $0$ 到 $L$ 的范围内。  
* 判断指针所在的位置是否**还没有被其它指针给抢先占领**。

对于第二条，我们可以进行分析。  
对于一个左指针 $l_i$，**最先**可能抢占它的位置的一定是**它左边的右指针**，即 $r_{i-1}$；而对于一个右指针 $r_i$，**最先**可能抢占它的位置的一定是**它右边的左指针**，即 $l_{i+1}$。

因此，只要满足上面的条件，我们就可以输出并扩展。

代码如下：  
```cpp
#include <iostream>
using namespace std;
long long L,n,k,a[300005],lft[300005],rht[300005],cnt;

int main(){
	ios::sync_with_stdio(NULL);
	cin.tie(0),cout.tie(0); 
	cin >> L >> n >> k;
	a[0] = -1,a[n+1] = 4e18; // 最右边的限制一定要先处理好
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 0;i <= n+1;i++) lft[i] = a[i]-1,rht[i] = a[i]+1; // 分配指针

	for(int i = 1;i <= min(n,k);i++) cnt++,cout << "0\n"; // 提前处理
	for(int val = 1;cnt < k;val++){
		for(int i = 1;i <= n && cnt < k;i++){
			if(lft[i] >= 0 && lft[i] >= rht[i-1]) // 在范围内且没被别的指针抢占
               lft[i]--,cnt++,cout << val << "\n";
			if(cnt >= k) break;
			if(rht[i] <= L && rht[i] <= lft[i+1]) // 同上
               rht[i]++,cnt++,cout << val << "\n";
		}
	}
	return 0;
} 
```

## 总结
是一道基础的题，考察模拟以及细节。

感谢您的阅读！

---

## 作者：A6TVhmj (赞：0)

我的做法或许特别一些。

看到题目是，我们看到题目中要从小到大输出前几个黑暗程度，我们可以想到用 multiset （有序可以重复的集合）储存
建三个 set（集合）$a,b,c$。$a$ 是 multiset ，用来从小到大储存黑暗程度；$b,c$ 是 unordered_set （无序不可重复），分别用来储存每个路灯的位置和黑暗程度已经加到集合 $a$ 中的位置。

代码思路如下：读入数据，顺便在 $a$ 中插入 $n$ 个 $0$，表示每个路灯的黑暗程度，表示每个路灯的黑暗程度。并把每个路灯的位置插入集合 $b$ 和 $c$ 中。建一个距离变量 $i$，初始值为 $1$，求出集合 $b$ 中每个元素左右距离为 $i$ 的位置（设第 $j$ 个路灯位置在 $A_j$ 的话就是 $A_j-i$ 和 $A_j+i$），如果位置没有超出范围且不在 $c$ 集合内（在的话说明这个位置是路灯）就把位置插入集合 $c$，黑暗程度正好是到路灯的距离 $1$，插入集合 $a$，至此，所有黑暗程度为 $0$ 和 $1$ 的位置都找到了。

之后把 $i$ 增加 $1$，重复之前的步骤，由于每次插入前会看一下位置是否在 $c$ 中（出现了表示已经被其他离这里更靠近的路灯记录了），所以 $a$ 中黑暗程度不会来自同一个地方。最坏情况下距离变量 $i$ 要增加到 $k$ 的最大值 $5\times 10^5$，但其实我们可以发现集合元素数量只要超过给定的 $k$ 就可以跳出循环了。时间复杂度 $O(n+k\log{k})$，可以通过。

但这种思路我们可以发现，multiset 中的元素本来就是有序的，于是可以换成一个 vector 来储存，效率提升了不知道多少（~~写到一半想到的~~）。[multiset 评测](https://www.luogu.com.cn/record/223165619)，[vector 评测](https://www.luogu.com.cn/record/223232219)。

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(0);
    long long Le,n,k,tmp;
    vector<long long> a;
    unordered_set<long long>b,c;
    cin>>Le>>n>>k;
    for(long long i=0;i<n;i++){
        cin>>tmp;
        a.push_back(0);
        b.insert(tmp);
        c.insert(tmp);
    }
    for(long long i=1;i<=5e5;i++){
        for(long long j:b){
            long long l=j-i,r=j+i;
            if(l>=0&&c.find(l)==c.end())c.insert(l),a.push_back(i);
            if(r<=Le&&c.find(r)==c.end())c.insert(r),a.push_back(i);
            if(a.size()>=k)break;
        }
        if(a.size()>=k)break;
    }
    for(long long i:a){
        k--;
        cout<<i<<endl;
        if(!k)break;
    }
    return 0;
}
```

---


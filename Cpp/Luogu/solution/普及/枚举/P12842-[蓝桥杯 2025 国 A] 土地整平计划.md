# [蓝桥杯 2025 国 A] 土地整平计划

## 题目描述

小蓝作为一个二维生物快乐地生活在二维坐标系中，他最近得到了一块土地，他想把这块土地整平用于修建花园。具体来说，这块土地从左到右长度为 $n$ 格，第 $i$ 格的高度为 $h_i (i \in [1, n])$。小蓝每次可以花费代价 $w$ 将一段连续的区间 $[l, r]$ 中的土地高度都变为 $w$，其中 $l \leq r$，这段区间需要满足以下三组条件之一：

1. $l = 1$, $r < n$，且对于 $i \in [l, r]$ 有 $h_i \neq h_{r+1}$，此时代价 $w = h_{r+1}$；
2. $l > 1$, $r = n$，且对于 $i \in [l, r]$ 有 $h_i \neq h_{l-1}$，此时代价 $w = h_{l-1}$；
3. $1 < l \leq r < n$，$h_{l-1} = h_{r+1}$，且对于 $i \in [l, r]$ 有 $h_i \neq h_{l-1}$，此时代价 $w = h_{l-1} = h_{r+1}$。

小蓝希望在若干次操作之后将这块土地整平，即所有格子的高度都相等，并且花费的代价总和最小。请你帮助他计算一下最小花费。


## 说明/提示

**【样例说明】**

选择将土地高度都变为 $5$，只需操作两次：将 $[2,5]$ 和 $[7,7]$ 的高度都变为 $5$，代价总和为 $10$。

**【评测用例规模与约定】**

对于 50% 的评测用例，$1 \leq n \leq 5000$；

对于所有评测用例，$1 \leq n \leq 10^6$，$1 \leq h_i \leq 10^6$。

## 样例 #1

### 输入

```
8
5 4 10 4 20 5 4 5```

### 输出

```
10```

# 题解

## 作者：Sakura_Emilia (赞：3)

# Solution

贪心解法。从前往后扫一遍，记录每一种数出现的位置。再来对每一种数的位置进行从前往后遍历，只要有间隔就有代价，统计最小总代价即可，思路很简单。

最常规的思路就是使用 `map<int, queue<int>>` 来记录每一种数所出现的各个下标。但是本题卡 `map`，这种写法只能得 $60$ 分，需要手写数组模拟链表来实现。

模拟链表最简单的一种方案就是直接使用图论板子里面的链式前向星，记录每一种数的各个下标。这里需要注意的是，一般链式前向星的板子是基于头插法加入新节点，对应下标其实是从后往前遍历，这里需要注意。

# Code

$60$ 分的解法如下：

```cpp
#include <bits/stdc++.h>
#define Ciallo main
#define int long long
using namespace std;

int n, t, key, pre, ans, cost;
map<int, queue<int>> mp;

signed Ciallo(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> n;
    for(int i=1; i<=n; i++){
        cin >> t;
        mp[t].push(i);
    }

    ans = LONG_LONG_MAX;
    for(const auto& tem : mp) {
        key = tem.first;
        auto q = tem.second;
        cost = pre = 0;
        while(!q.empty()){
            t = q.front();
            q.pop();
            if(t != pre + 1)
                cost += key;
            pre = t;
        }
        if(pre != n)
            cost += key;
        ans = min(ans, cost);
    }
    cout << ans << endl;

    return 0;
}
```

$100$ 分代码如下：

```cpp
#include <bits/stdc++.h>
#define Ciallo main
#define int long long
using namespace std;
const int N = 2e6 + 8;

inline int read() {
    int _x = 0, _w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-') _w = -1;
#ifdef __linux__
        ch = (char)getchar_unlocked();
#else
        ch = (char)_getchar_nolock();
#endif
    }
    while (ch >= '0' && ch <= '9') {
        _x = (_x << 3) + (_x << 1) + (ch - '0');
#ifdef __linux__
        ch = (char)getchar_unlocked();
#else
        ch = (char)_getchar_nolock();
#endif
    }
    return _x * _w;
}

inline void write(int _x){
    if(_x < 0) {
#ifdef __linux__
        putchar_unlocked('-');
#else
        _putchar_nolock('-');
#endif
        _x = -_x;
    }
    static int _sta[130];
    int _top = 0;
    do {
        _sta[_top++] = _x % 10, _x /= 10;
    } while(_x);
    while(_top)
#ifdef __linux__
        putchar_unlocked(_sta[--_top] + 48);
    putchar_unlocked('\n');
#else
        _putchar_nolock(_sta[--_top] + 48);
    _putchar_nolock('\n');
#endif
}

int n, t, pre, ans, cost, u;
int has[N], hasIdx;
int h[N], e[N], ne[N], idx;
bool st[N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

signed Ciallo() {
    n = read();
    memset(h, -1, sizeof h);
    for(int i = 1; i <= n; i++) {
        t = read();
        if(!st[t]){
            has[++hasIdx] = t;
            st[t] = true;
        }
        add(t, i);
    }

    ans = LONG_LONG_MAX;
    for(int i = 1; i <= hasIdx; i++) {
        u = has[i];
        if(h[u] == -1)
            continue;
        cost = 0, pre = n + 1;
        for(int j = h[u]; j != -1; j = ne[j]) {
            t = e[j];
            if(t != pre - 1)
                cost += u;
            if(cost >= ans)
                break;
            pre = t;
        }
        if(pre != 1)
            cost += u;
        ans = min(ans, cost);
    }
    write(ans);

    return 0;
}
```

---

## 作者：postpone (赞：2)

赛时还有一个信息补充，没有写在题面里：每一个土地至多只能平整一次——这个信息就是在告诉我们，对每个高度统计答案，最后取最小值即可。

实现不用多说：维护一个 `lst[]` 记录每个数上一次出现的位置，以及以每个数作为最终高度进行平整的花费 `cost[]`。从前到后扫过去就行了，复杂度是线性的。

需要注意的是，$\texttt{std::map}$ 在大数据范围下的性能很差，而且复杂度多一个 $\log$，这道题可能是过不去的，最好用数组。

```cpp
constexpr int N = 1e6 + 1;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    vector<int> h(n);
    for (int i = 0; i < n; i++) {
        cin >> h[i];
    }

    vector<int> lst(N);
    vector<i64> cost(N);
    vector<bool> vis(N);
    for (int i = 0; i < n; i++) {
        if (not vis[h[i]]) {
            vis[h[i]] = true;
            cost[h[i]] += h[i];
        } else if (lst[h[i]] != i - 1) {
            cost[h[i]] += h[i];
        }
        lst[h[i]] = i;
    }

    i64 ans = 1e18;
    for (int x = 0; x < N; x++) {
        if (not vis[x]) {
            continue;
        }
        if (x == h.front()) {
            cost[x] -= x;
        }
        if (x != h.back()) {
            cost[x] += x;
        }
        ans = min(ans, cost[x]);
    }

    cout << ans << "\n";

    return 0;
}
```

---

## 作者：_ACGODs_ (赞：0)

# P12842 题解
## 思路
暴力 + 桶优化。  

题意：给定数组 $A$，你可以选定 $A$ 中一段所有元素不等于 $w$ 且这个区间左右两个数（如果有）为 $w$ 的区间，把区间内所有元素变成 $w$，代价也为 $w$。求将这个数组 $A$ 的所有元素变成一个数的代价。  

用一个桶 $B_i$ 记录当 $w=B_i$ 时需要修改几个区间。  
根据植树问题的思路，可以先把每个 $B_{A_i}$ 先设为 $1$（两边都不植树）。  
再对于每个 $A_i$ 使 $B_{A_i}=B_{A_i} +1$。  
然后，将 $B_{A_1}$ 和 $B_{A_n}$ 分别减去 $1$。（一边植树或者两边植树）。  
最后，在 $A_{\min} \sim A_{\max}$ 范围内找到 $B_i \times i$ 的最小值，且 $B_i ≠ 0$（$A$ 中有 $i$ 这个数）。  

特判：当 $A$ 中只有一个整数（例：`3 3 3 3`）时，输出 $0$。  

## 代码优化
写在思路里了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000010], b[1000010], n, maxn, minn, mina = 0x3f3f3f3f, cnt;
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		if (b[a[i]] == 0) cnt++;
		b[a[i]] = 1;
		maxn = max(maxn, a[i]);
		minn = min(minn, a[i]);
	}
	if (cnt == 1) {
		//当 A 中只有一个整数
		cout << 0 << endl;
		return 0;
	}
	for (int i = 1; i <= n; i++) {
		if (a[i] != a[i - 1]) b[a[i]]++;
	}
	b[a[1]]--;
	b[a[n]]--;
	for (int i = minn; i <= maxn; i++) {
		if (b[i] != 0) mina = min(mina, b[i] * i);
	}
	cout << mina << endl;
	return 0;
}
```
$\mathfrak{Bye Bye}$

---


# 倒水

## 题目描述

一天，CC 买了 $N$ 个容量可以认为是无限大的瓶子，开始时每个瓶子里有 $1$ 升水。接着 CC 发现瓶子实在太多了，于是他决定保留不超过 $K$ 个瓶子。每次他选择两个当前含水量相同的瓶子，把一个瓶子的水全部倒进另一个里，然后把空瓶丢弃。（不能丢弃有水的瓶子）

显然在某些情况下 CC 无法达到目标，比如 $N = 3$、$K = 1$。此时 CC 会重新买一些新的瓶子（新瓶子容量无限，开始时有 $1$ 升水），以达到目标。

现在 CC 想知道，最少需要买多少新瓶子才能达到目标呢？


## 样例 #1

### 输入

```
3 1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
13 2```

### 输出

```
3```

## 样例 #3

### 输入

```
1000000 5```

### 输出

```
15808```

# 题解

## 作者：pantw (赞：222)

纯二进制题目。


因为所有的水都是由两份相同的水合并而成的，因此每瓶水的体积一定是$2^i,(i\in N)$升。

最后保留k个瓶子，那么最后总的升数的二进制表示中，1的个数一定<=k。

那么我们只要贪心地往n上加上lowbit(n)即可。

这个lowbit就是树状数组那个lowbit啦


简化代码的trick：

使用内置函数`\_\_builtin\_popcount()`来计算一个数的二进制表示中1的数量。


这样下来，代码简化到仅剩7行。

惊不惊喜，意不意外？

那么问题来了，为什么这题是 `提高+/省选-` 呐？


```cpp
#include <cstdio>
int n, k, ans;
int main() {
    scanf("%d%d", &n, &k);
    while(__builtin_popcount(n) > k) ans += n & -n, n += n & -n;
    printf("%d", ans);
}
```

---

## 作者：诗乃 (赞：78)

这个题解写得很详细给蒟蒻看的，大神看下面的。

依题意可得，每2^x个瓶子可以合成一个瓶子。

以样例13 5来说，

13=8+4+1.

也就是说13个瓶子可以合并成3个瓶子，但此时不满足“小于k个”条件，所以需要购买空瓶子。

买1个，14=8+4+2，没有什么卵用。

买2个，15=8+4+2+1，好像更糟。

买3个，16=16,搞定。

根据上述过程可以得出初步思路：算出n可以分成几个2^x相加，也就是可以合成几个瓶子。如果结果>k那么买一个空瓶重复上述过程。

但是这里需要一个小技巧，如果你分解数的时候暴力枚举，时间肯定爆炸。

由于是2^x，所以我们很容易地想到2进制。所有2的倍数的二进制都是100000……（好多好多的0）

观察样例13的二进制： 1101.相当于二进制1000+100+1即十进制8+4+1.

得出结论，要统计有多少个因子（好像不叫因子，反正就那意思），只需要数数当前瓶子数的2进制下有多少个1即可。

那么我们需要一位位比较。如果把整个数转成二进制时间不说了。

如何快速的获得此数二进制数下的某一位呢？

我们只需要构造一个数，这个的二进制数是0000000000000000000100000000（1<<N）

然后再把当前数与该数按位与，就可以得出当前数二进制下某一位。（啥？你不知道啥叫按位与？）

交上去发现悲伤的超时了一个点。

所以我们需要优化。其实每一次加1的目的就是为了让数中的0变少。就是需要进位。

此时我们把瓶子数量的二进制取反再加一，进位就变得容易多了（好像只快一点点）

稍有常识的人都会知道，n的二进制取反再加一就是-n。

好了看代码吧。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <bitset>
using namespace std;
int main()
{
    long long n,k,ping=0,count1;
    scanf("%lld%lld",&n,&k);
    while(1)
    {
        count1=0;
        for(int i=0;i<64;i++)
        if((n&((long long)1<<i))>0)count1++;
        if(count1<=k)break;
        //cout<<count1<<" "<<n<<endl;
        ping+=n&(-n);
        n+=n&(-n);
        //system("pause");
    }
    printf("%d\n",ping);
}
```

---

## 作者：Golden_Winter (赞：68)

这题第一眼看到就知道和二进制有关。


| 合并前 | 二进制 | 合并后 |
| ---: | --: | ---: |
|1个瓶子|   1 |1个瓶子|
|2个瓶子|  10 |1个瓶子|
|3个瓶子|  11 |2个瓶子|
|4个瓶子| 100 |1个瓶子|
|5个瓶子| 101 |2个瓶子|
|6个瓶子| 110 |2个瓶子|
|7个瓶子| 111 |3个瓶子|
|8个瓶子|1000 |1个瓶子|
|...   |...  |...    |

根据上列式子，我们知道n个有水的瓶子，最后合并成的瓶子个数，就是这个数转成二进制1的个数。

我们知道，二进制有一个很好的取各位上1的个数的方法。

首先我们来认识一个式子：



i&-i(C++),i and -i(pascal)

这个式子返回的值就是从后往前数，到第一个1出现为止的数(二进制下)。

来列个表：


|i  |i(2) |i&-i|i&-i(2)|
|---|----:|----|------:|
|1  |1    |1   |1      |
|2  |10   |2   |10     |
|3  |11   |1   |1      |
|4  |100  |4   |100    |
|5  |101  |1   |1      |
|6  |110  |2   |10     |
|7  |111  |1   |1      |
|8  |1000 |8   |1000   |

然后，如果要取x中1的个数(二进制下)，那么就写这样一段代码：

```CPP
int work(int x){int num=0;for(;x;x-=x&-x) num++;return num;}
```
num就是1的个数。

然后，我们解决添加的问题，一个个添加太慢了，我们应该一次添加一堆，这一堆添上去，刚好能让总共的水杯个数减少（或不变）。

我们有个贪心的想法，从少的开始添，否则就浪费了，明明可以要黄金，你却偏偏喜欢白银(我也无能为力)。

那么就用到上面的这个式子了，在最后一位1再添上个1，那么就会进位，水杯的个数只会减少（或不变），而不会增多。

最后个数小于等于k时就可以停了。

```CPP
#include<cstdio>
using namespace std;
int n,k,ans;
int work(int x){int num=0;for(;x;x-=x&-x) num++;return num;}
int main(){
    scanf("%d%d",&n,&k);
    while(work(n)>k) ans+=n&-n,n+=n&-n;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：TARMO (赞：26)

（一个不会二进制的蒟蒻在dalao中瑟瑟发抖）

一开始的思路当然是模拟啦，然后就是愉快地爆内存，超时间...（我还非常天真地提交了好几次）

后来终于意识到这道题需要一点数学思想，然后测评结果就变得五颜六色起来（爽）


思路和大多数dalao都不一样，就发一篇题解吧

解释都在代码里
```cpp
//你没看错，代码改到了如此之短
//正经点啊，开始一场头脑风暴啦
//既然只剩下不到k个瓶子，那我们不妨看成剩下k个瓶子（无视特殊情况）
//剩下的k个瓶子每个里肯定都有2^n升水，而所有水的总和就是n+sum（sum为输出结果）
//然后最后一个瓶子肯定大于sum
//给自己一点时间思考一下
//这样思路就明确了，开始码代码
#include<bits/stdc++.h>//妙甚的万能头
using namespace std;//妙甚的命名空间
unsigned long long n,k,sum;//妙甚的变量定义
int main()
{
    cin>>n>>k;//妙甚的输入
    if(k>32) k=32;//本句可以无视
    //敲黑板！！！
    while（k>1&&n>0)//n>0不加的话程序会卡死于此
    for(int i=63;i>=0;i--)
    if(pow(2,i)<=n){n-=pow(2,i);k--;break;}//任何一个自然数都可以拆分成若干个2的幂的和
    //敲黑板的手停下
    if(n==0){cout<<"0";return 0;}//特判
    for(int i=0;;i++)
    {
        if(pow（2,i)>=n)
        {
            cout<<(unsigned long long)pow(2,i)-n;//妙甚的输出
            break;//看看for循环后边的括号里
        }
    }
    return 0;
}
```
本蒟蒻的第一篇题解（防抄袭）

---

## 作者：Dr_殇 (赞：25)

#这题特别简单，就是二进制模拟，我就不知道为什么要提高省选-难度。

#题目分析：

这道题其实就是二进制，让我们先来看第一个样例：

n=3 m=1

我们先把n转化为二进制，得11。

这就说明n个瓶子能合并成2个瓶子，但由于不满足题意，所以应该再减少一个瓶子。

二进制11想要将它变成只含有一个1的，那么就+1，得100，所以答案就是1。也就是说先从右往左数第一个1的位置+1，再加上其二的方幂，然后继续找，直至满足题意。

再看第二个样例：

n=13 m=2

还是将n转化为二进制，得1101

说明n个瓶子能合并成3个瓶子。

按第一题得到的规律，先从右往左数第一个1的位置+1，再加上其二的方幂，然后继续找，直至满足题意。

第三个样例也是如此：

n=1000000 m=5

将n转化为二进制，得1111 0010 0100 0000

仍按第一题得到的规律，先从右往左数第一个1的位置+1，再加上其二的方幂，然后继续找，直至满足题意。


##代码如下：







```cpp
#include <ctime>
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>//头文件准备
using namespace std;
int t,n,m;
long long b[70];//定义二进制数组，用于打表
void bit(){//这就是传说中的打表
    b[0]=1;//注意：一定要将b[0]赋为1，要不然按我这种打表法会全部为0
    for (int i=1;i<=62;i++){//好吧，其实不用穷举这么多的，不过怕错，就这样了
        b[i]=b[i-1]*2;
    }
}
void work(){
    int bi[70];//二进制数组
    int x=n,ans=0;
    int k=-1;
    while (x){//将十进制转为二进制，这个直接就是从右往左的
        bi[++k]=x%2;
        x/=2;
    }
    int t=0;
    for (int i=0;i<=k;i++){
        if (bi[i])t++;//穷举它已经合并为多少个瓶子了
    }
    if (t<=m){printf ("0\n");return;}//如果合并的瓶子已经少于或者等于需要的瓶子，那么一个都不要买
    for (int i=0;t>m;i++){
        if (bi[i]>1){bi[i]=0;bi[i+1]++;t--;}//如果b[i]>1（也就是b[i]==2），那么就将它的下一位+1，并且因为两个合并为一个瓶子，所以t--
        if (bi[i]){ans+=b[i];bi[i+1]++;}//如果b[i]==1，那么也将它的下一位+1，但是由于还要买其二的方幂，所以ans要增加，虽然买了一个后是两个合并为一个了，但是增加了一个又减少了一个，所以没变
    }  
    printf ("%d\n",ans);//最后输出ans
}
int main(){
    bit();//二的方幂打表大法
    scanf ("%d %d",&n,&m);
    work();
    return 0;
}
```
完成^\_^

#珍爱生命，拒绝抄袭！


---

## 作者：Qiu233 (赞：21)

很痛苦，看了题解一堆大佬我才发现原来我就是一个只会用蠢方法的小蒟蒻。。。
不管怎么说这个算法也是我自己想出来的。

思路：
首先明确一点，每个瓶中的水量都是2的幂，这个不难证明。
其次，想要瓶子更少，则要尽可能把瓶子合并，这是什么意思呢？
举个例子，输入N=13，K=2，先不考虑购买新瓶子和K，给出13个瓶子的两种合并方案，4 4 4 1和8 4 1。不废话，后者显然更好。
其实也不难证明上面这条的最优性质，总之，我们总是希望尽可能把多的瓶子合并。
实际算法不难，首先把瓶子先进行合并，最后总会得到一个无法再合并的结果，比如上面的8 4 1，但是这时候我们仍有三个瓶子，而数据要求我们最多剩下2个瓶子，所以我们第二步就是对最后两个瓶子进行合并，这时候直接4-1=3，即所求需要购买的瓶子数，于是最后两个瓶子可以合并为一个蓄水量为8的瓶子。

算法设计也比较简单，我这里用的是递归来实现。

func1(n,r):
返回将n个瓶子存入数组f之后，所使用的数组长度，r传入1。
我们在这个函数中找到小于n的最大的2的幂y，这个数字填充数组当前位置，然后再递归调用func1(n-y,r+1)，返回其返回值。
边界条件为n==0，此时直接返回r-1。

func2(n,r):
合并数组f中下标为r~n的瓶子，通常r<=n。
两个边界条件：1.n<r+1，直接返回0，因为n绝对小于r，不需要合并。2.n==r+1，说明要合并的瓶子是相邻的两个，直接将他们合并，然后返回就好了。
如果需要合并且合并的不是相邻两个瓶子，那么我们可以递归地调用func2(n,r+1)，这样会把编号为r+1到n的瓶子合并，于是我们就可以直接再把编号为r和r+1的瓶子合并，注意要计算结果。


```cpp
#include <iostream>
#include <algorithm>
using namespace std;

#define ll long long

ll f[1000];
ll n,k;

ll func1(ll n,ll r)
{
	if(!n)
		return r-1;
	ll y=1;
	while(1)
	{
		ll t=y*2;
		if(t>n)
			break;
		y=t;
	}
	f[r]=y;
	return func1(n-y,r+1);
}

ll func2(ll n,ll r)
{
	if(n<r+1)
		return 0;
	if(n==r+1)
	{
		ll y=f[r]-f[n];
		f[r]*=2;
		return y;
	}
	ll u=func2(n,r+1);
	ll e=f[r]-f[r+1];
	f[r]*=2;
	return u+e;
}


int main()
{
	cin>>n>>k;
	int t=func1(n,1);
	int y=func2(t,k);
	cout<<y<<endl;
	
	return 0;
}
```

---

## 作者：jingyangzhi (赞：17)

**CC可真是闲呢
  由于楼下的各位daolao所写的题解对于初学者非常的不友好，
####   所以特写此篇给像我一样蒟蒻的人，大佬请往下走。
  首先，先让我们了解一些知识：
###   1   c语言自带函数__builtin_popcount(n)可表示n这个数在二进制表达下面所含‘1’的个数，例：9的二进制为1001 由2个1所以    __builtin_popcount(9)=2；
###  2   位运算中 n&-n 表示n在二进制中最后一个1所代表的值 例:  10二进制表示为 1010 最后一个1在倒数第二位 所以 10&-10==2（2的一次方）；
  那么题目就可以做了
###   首先由题目可知水瓶使用2个体积相同的瓶子合并而来，固定为2的次方L在二进制下表示为1后面加上次方-1个0；所以当留下K个瓶子的时候L的总数在二进制表现下有做多K个1；
##    所以只要N加上新瓶子的总数在二进制下有小于等于K个1就行了！！
####     因为a&-a表示二进制的最后一个1，所以让n加上n&-n使末位的1往前移动与倒数第二个1相加从而消去n多余1的最小数字方法。
以下是AC代码：
###### #include <iostream>
###### using namespace std;
###### int n, k, ans;
###### int main() {
######     cin>>n>>k;
######     while(__builtin_popcount(n) > k) {ans += n & -n;n+=n&-n;}//
####    不断的将n末位的1往前移动直至n的1的个数小于等于k，并记录将n末位1往前移动所需加上的数字。//
######     cout<<ans<<endl;
}

 高一萌新呕心沥血抽空写的第一篇题解，请管理员大大~~看在未成年保护法~~的份上给过了吧！！！

**

---

## 作者：YLWang (赞：10)

贪心无误。

考虑到每个瓶子里的水的体积在任何时刻都是2的幂次方，二进制表示为$(10000...0)_2$

因为遗留下了k个瓶子，所以需要的水的体积总数一定可以表示为$2^{a_1}+2^{a_2}+....+2^{a_k}$, 其中$a_i$为正整数。

因为上式有k项，而每一项在二进制中给最终的结果至多添加了一个1（简单列个竖式即可证明），故二进制中最终的结果中有至多k个1。

故转化问题为：找到一个大于n的正整数m使得m最小且m的二进制表示中，1的个数小于k。

那么先算出n的二进制表示中1的个数（关于__builtin_popcount的用法已经有人讲了，这里不再赘述），考虑一一枚举比n大的数。


这里我们证明枚举不会TLE：

因为$k \geqslant 1 $ (若$k = 0$则没有答案），故大于等于n的最小的$2^t$一定满足。

因为$n \leq 2 * 10 ^ 9 $ ,所以$n \leq 2^{30} $

所以一一枚举最多只会枚举$2^{30}$，约等于$10^9$次


卡卡常可以过。
```
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define mst(a,b) memset(a,b,sizeof(a))
#define For(i, k, j) for(int i = (k); i <= (j); i++)
using namespace std;
inline int read()
{
    int num = 0, flag = 1;
    char c=' ';
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') flag = -1;
    for(;c>='0'&&c<='9';num=(num<<1)+(num<<3)+c-48,c=getchar());
    return num * flag;
}
int main()
{
    int n = read(), k = read();
    int ans = 0;
    while(__builtin_popcount(n) > k) 
    {
    	ans++；
        n++;
    }
    cout << ans << endl;
    return 0;
}

```
打字不易，望通过！


---

## 作者：JOHNKRAM (赞：10)

1.每次寻找n二进制位上最小的"1"和1的个数

2.如果1的个数≤k，停止

3.否则结果加上这个"1"，n也加上这个"1"。

4.跳到1

重复上述过程即可得到最后结果。


---

## 作者：shenbear (赞：7)

**这道题的本质就是将n转为二进制后找到一个比它大且1的数量<=k的二进制数,然后再用此数-n**

各位大佬好像都是用二进制做的,我也是,好巧

但是二进制具体如何实现上有点区别

至于为什么是二进制,楼上楼下的各位大佬已经讲的很清楚了,我就不重复了

重点讲如何实现

首先当然要先把n化为二进制,长度为l

然后去找,在前k个一中的最后一个为0的位置

如果不存在,则直接用2^(l+1)-n(前面无论怎么将1改0都没用,必须多加一位,才能使1的数量<=k

如果找到了,那就把这位变成1,后面全改为0,再拿此数去-n

------------
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,n,k,a[111],l=-1,s;
ll pw(int b,int c) //建议手写pow
{
    ll sum=1;
    for(int i=1;i<=c;i++)
    {
        sum*=b;
    }
    return sum;
}
ll check()
{
	ll zz=-100;
    for(int i=l,j=1;j<=k;i--)//找位置
    {
        if(!a[i]) 
		{
        	zz=i;
			//return zz;
		}
		else j++;
    }
    if(zz==-100)
    return 0;
    else return zz;
}
int main()
{
    cin>>n>>k;
    x=n;
    while(x)//转二进制
    {
        l++;
        s+=x%2;
        a[l]=x%2;
        x/=2;
    }
   if(s<=k)//根本不用做的
   {
       cout<<"0";
       return 0;
   }
   //cout<<check();
   ll z=check();
    if(!z) //没有找到
    {
        cout<<pw(2,l+1)-n;
    }
    else //找到了
    {
    	
    	a[z]=1;
        ll sum=0;
        for(int i=z;i<=l;i++)
        {
            sum+=pw(2,i)*a[i];
        }
    //    cout<<sum<<endl;
        cout<<sum-n;
    }
    
}
```


---

## 作者：zyj_Orz (赞：6)

# 基础不是特别扎实的萌新孩纸们看过来

自然这种题目主要是数学，首先想到进制转化。但是~~我这么弱怎么打得出来~~希望有更好的方法，毕竟进制转化代码长度还是很长的，那些什么函数啊异或啊我又掌握得不好……

大致推了一下，发现其实想保留的那各个瓶子总含水量当然要大于且尽可能地接近含水量，所以大致就是实现一下前k-1个瓶子含水量总和小于尽可能接近总含水量，再在最后找一个第一个大于剩下含水量的水量，相减即为解。

哦，你问31是什么？就是数据范围第一次大于2×10的9次方的2的次幂啊！$QWQ$

代码虽然比各dalao神犇的什么```__builtin_popcount(n)```的长度长得多，但是我的代码好理解啊！那些函数在考场上很难背出来哒！所以走过路过千万不要错过啦！


------------
### 华丽的代码分割线
 

```
#include<bits/stdc++.h>
using namespace std;
long long a[32],c2=1,zyj_Orz;
int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=0;i<=31;i++)
	a[i]=c2，c2*=2;
	for(;k>1;)
	{
		for(int i=0;i<=31;i++)
		{
			if(a[i]>n)
			{
				n-=a[i-1];
				k--;
				break;
			}
			if(a[i]==n)
			{
				cout<<"0";
				return 0;
			}
		}
	}
	for(int i=0;i<=31;i++)
	{
		if(a[i]>=n)
		{
			zyj_Orz=a[i]-n;
			cout<<zyj_Orz;
			return 0;
		}
	}
}
```

---

## 作者：巨型菜鸟 (赞：5)

**本人的第一反应：~~经典的~~进制题**

正如前几位dalao所说，每个瓶子中装的水一定是2^i(i∈N),并且每一个符合题意的解中水的总量转化为二进制后含有的“1”的数量一定不大于k。

看了前几位dalao的分析，本人忽然有了一个~~新~~想法：题目要求满足题意的最小值，也就是说，
### 假设ans为所求，那么ans应满足以下性质：

1、ans转化为二进数后含有的“1”的数量不大于k；

2、ans>=n；

3、∀ans'满足性质1、2，ans<=ans'；

## 那么我们怎么去求这个ans呢？

直接枚举太慢，~~肯定T到飞起~~

我们不妨从二进制的角度考虑这个问题（以下分析均为二进制）。我们要让ans最小但仍大于n，应该使ans的字典序大于n但最接近n。如果此时ans中含有的“1”超过了k，那么只好进位，也只可能进一位。

接下来我们来具体实现。∀m，我们要求字典序大于m且最接近m的数我们应当吧m的最后一个“1”往前推，后面的位清空~~（这个证明不难，相信大家都有这个能力）~~。若前一位为1，直接进位就好。注意，若出现进位，就是两个“1”合并，数字中“1”的数两要-1.一旦出现满足题意的解，结果就呼之欲出了。好了，话不多说，AC代码奉上，详细见注释！

```
#include<bits/stdc++.h>
using namespace std;
string bgn;//本人喜欢字符串，该字符串当然可以用数组替换 
long long n,k;//如题面
long long m;//n的副本 
int l;//二进数长度，
int cnt;//二进数中“1”的个数 
long long ans;//结果（不是最终结果，而是满足题意的最小的数） 
int main()
{
	cin>>n>>k;
	m=n;
	/////////////////////////////////////////////////////////////////十进数转二进数 
	while(m)
	{
		bgn+=(m%2+'0');
		m/=2;
	}
	l=bgn.length();
	bgn+='0';//如果结果进位，这是提前为它准备的 
	for(int i=0;i<l;i++) swap(bgn[i],bgn[l-1-i]);//下标从低位开始 
	//////////////////////////////////////////////////////////////////
	for(int i=l-1;i>=0;i--) if(bgn[i]=='1') cnt++;
	if(cnt<=k)//如果直接可以达到目标，输出0结束 
	{
		cout<<0;
		return 0;
	}
	//////////////////////////////////////////////////////////////////向高位推数 
	cnt++;//推数预处理 
	bgn[0]++;
	for(int i=0;i<l;i++)//从低向高走 
	{
		if(bgn[i]=='2')//进位情况 
		{
			cnt--;//两个“1”合并，“1”的个数-1 
			bgn[i]='0';//本位清空 
			bgn[i+1]++;//前一位+1 
			goto A;
		}
		////////////////本位复原，前一位+1，吧“1”向前推 
		bgn[i+1]++;
		bgn[i]--;
		A:if(cnt<=k) goto B;
	}
	B:;
	////////////////////////////////进位特判 
	if(bgn[l]=='1') l++;
	if(bgn[l-1]=='2')
	{
		bgn[l-1]='0';
		bgn[l]='1';
		l++;
	}
	////////////////////////////////
	////////////////////////////////////////////////二进数转十进数 
	for(int i=l-1;i>=0;i--) 
	{
		ans*=2;
		ans+=bgn[i]-'0';//秦九韶算法 
	}
	//得到最小的瓶子总数（空瓶都没扔）
	cout<<ans-n;
	return 0;
}
```

~~蒟蒻~~第一篇题解，写得不好，大家见谅，谢谢！

---

## 作者：Bronya18C (赞：4)

# 第一种做法（20分）：
#### 计算二进制位里有多少个一，然后乘相应的位权。
#### 比如有13杯水，要剩2杯。
#### 13=二进制的1101，
#### 先算从右向左的第一位，位权是1，然后前一位是0，再加上位权是2.最后结果是2+1=3.
#### 可是如果样例是1000000 5就会错。QWQ ~~（原因自己想）~~
```
#include<bits/stdc++.h>

using namespace std;
long long N,K,n[100005],k,x,ans,l;
int main()
{
    cin>>N>>K;
    for(int i=N;i>0;i/=2)
    {
        if(i%2==1)
        {
            n[++k]=x;
        }
        ++x;
    }
    for(int i=1;i<=k-K;i++)
    {
        ans+=pow(2,n[i]);
        l=n[i];
        l++;
        while(n[i+1]!=l)
        {
            cout<<l<<endl;
            ans+=pow(2,l++);
        }
    } 
    cout<<ans<<endl; 
    return 0;
}
```
---
# 第二种解法（100分）：
### 一个一个买新的瓶子试，但会超时。

## 所以，可以一次性买现在数二进制从右往左数的第一个1的位权个。

## 比如有14（1110）个，就直接买2^1次方个，变成16（10000）。

# 正确代码：
```
#include<bits/stdc++.h>

using namespace std;
long long N,K,x,ans,k;
bool a;
int main()
{
    cin>>N>>K;
    for(register int i=N;i>0;)
    {
        if(i%2==1)
        {
            x++;
        }
        i>>=1;
    } 
    if(x<=K)
    {
        cout<<0<<endl;
        return 0;
    }
    for(register int j=1;;)
    {
    k=0;
    x=0;
    a=false;
    for(register int i=N+j;i>0;)
    {
        if(i%2==1)
        {
            x++;
            a=true;
        }
        if(a==false&&i%2==0)
        {
            k++;
        }
        i>>=1;
    } 
    if(x<=K)
    {
        ans=j;
        break;
    }
    j+=pow(2,k);
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：LOFTER_OI (赞：4)

蒟蒻写题解可能有些不足qwq
这一题，不用二进制，

最后一个点需要900多ms，

一不小心就会炸，
看了看大家的题解，

我写了一个lowbit求1的个数，这样就可以优化大20ms

```
#include<bits/stdc++.h>    //万头文件
using namespace std;
int k,n,ans=0,i=1;
int lowbit(int x)          //自定义
{
	int y=0;
	while(x)
	{
		x=x-((x)&(-x));     //x&（-x）是求0的个数，所以x-((x)&(-x))是求1的个数
		y++;
	}
	return y;               //x为2进制是1的个数
}
int main()
{
	scanf("%d%d",&n,&k);
	while(lowbit(n)>k）
	{
		ans+=((n)&(-n));
		n+=((n)&(-n));
	}
	printf("%d",ans);
}
```
这题玩过2048的大佬都知道不管怎么合并都是2的次幂

所以用2进制可以很快

lowbit很有用，而且代码简单，背下就可以了

而且只要背  **x&(-x)**  就可以了

这个在写树状数组的时候也很有用！！！

加油！！！

---

## 作者：樱花飞舞 (赞：4)

前言：翻了几页题解，发现大家主要是用二进制做的，也有极少几份题解用的是像我一样的类似贪心的做法。但是思路不外乎将$2$的整数次幂预处理出来，这里提供一个用数学进行这个步骤的方法。
## 前置知识：
- ###  log函数（指数学上的log函数）
~~自行baidu 这个高中数学应该会很详细的讲的吧？~~

注：这一段是基础内容，已经了解的请直接跳过

**log函数即对数函数，用于在知道底数和幂的情况下求指数。**

如果我们设
$$a^n=b$$
那么就有
$$\log_ab=n$$
**举个例子：**

我们知道
$$2^5=32$$
那么就有
$$\log_232=5$$

- ### log函数在解这道题中需要推出一个柿子
$$\log_ab=\frac{\log_cb}{\log_ca}$$
证明：

我们设$c^m=a,a^n=b$，那么易知:
$$c^{mn}=b$$
分别将$c^m=a,c^{mn}=b$改写为对数形式就有：
$$\log_ca=m\log_cb=mn$$
用后边的柿子去除以前边的柿子，就得到了：
$$\frac{\log_cb}{\log_ca}=n$$
其中$n$又等于$\log_ab$，代入就推出了原来的柿子。

## 下手题目
- ### 从样例下手：
样例2：
```
1 1 1 1 1 1 1 1 1 1 1 1 1
```
首先我们会想到将尽可能多的$1$倒到一起，这样就变成了
```
2 2 2 2 2 2 1
```
重复进行这一操作，最后会得到：
```
8 4 1
```
这样我们只需要再来$3$桶水，与剩下的$1$倒到一起，即可与剩下的$4$合并,只剩下$2$桶。

容易发现，任何一个桶中水的量，必定是$2$的非负整数次幂。

这样，我们就有了这个近似贪心的做法：

一开始，我们有$13$桶水。将其中的$2^3$桶水合并成一桶，剩下$5$桶水需要合并成一桶，我们就需要$3$桶来补齐到$2^3$桶，才能合并成$1$桶。

类似的，我们对样例3进行一下测试：(电脑计算器在燃烧！)

第一桶水量为$524288$，第二桶$262144$，第三桶$131072$，第四桶$65536$，还有$16960$桶，这时就需要补齐到$32768$桶，因此就需要再买$15808$桶。

多次测试后发现，我们的贪心思路是正确的。

因为$2^n$这个函数的值会随着$n$的增大越来越稀疏，所以剩下的桶越少，想要补齐到$2$的整数次幂需要的桶数也就越少。
- ### 如何实现
每一次，都要取到尽可能大的非负整数$n$，使得$2^n\leq N$（注意这两个$n,N$的大小写，前者是指数后者是桶数）。$p$可以这样求:
$$p=\lfloor \log_2N\rfloor$$
此时将$2^p$桶合并为一桶，从$N$中减去这个数，再对剩下的同属进行这个操作。

当需要将剩下的桶合并为$1$桶时，先判断剩下的桶数是否已经是$2^p$的形式。（判断方法：求出$p$，判断$N$是否等于$2^p$）

如果是就输出$0$，否则就输出$2^{p+1}-N$，即补齐需要的桶数。

在过程中如果总桶数还没有到$K$，就已经合并完了所有的桶，就直接输出$0$.

c++中自带$log$函数，但是它是以$e$为底的，这时我们就需要用到刚刚推出的柿子：将$\log_eN$去除以$\log_e2$，得到的结果就是$\log_2n$

- ### 小问题
在做这道题的时候，第10个测试点，由于得数比较大，直接输出`pow(2,log2(N)+1)-N`的话，$luogu$评测姬会输出一个科学计数法，导致WA，因此需要先将其存入一个变量再输出。

最后贴上~~写得奇丑的~~AC代码：

```
#include<bits/stdc++.h>
#define log2(p) floor(log(p)/log(2))
using namespace std;
long long N,K;
int main()
{
    cin>>N>>K;
    for(int i=1;i<K;i++)
    {
        N-=pow(2,log2(N));
        if(N==0)
        {
            cout<<0;
            return 0;
        }
    }
    if(N==pow(2,log2(N))) cout<<"0";
    else
    {
        long long ans=pow(2,log2(N)+1)-N;
        cout<<ans;
    }
    
    return 0;
}
```

---

## 作者：ailanxier (赞：2)

# DEQUE容器

   本人蒟蒻，~~不甚了解位运算~~（留下了不学无术的眼泪），看了一眼题解没有用STL的，就发一篇deque容器的题解吧，思路比较容易想到。

我的想法是这样的：

利用deque容器（主要是因为deque容器可以以常数项时间进行头插还有随机读取），先处理输入进来的n（原有的瓶数），将它的二进制中的“1”的位置按从小到大的顺序头插进deque。

PS：如例二13    3
  
  $n=13$(10进制）    $1101$（二进制）
  
  13 的 “1” 的位置为 3  2  0（第一位位置为 0）
  
  头插结果：先插 0 ，再把 2 插在 0 前面，最后把 3 插在最前面。
  
####   即$13=2^3+2^2+2^0$
  
  处理n的代码：
  
  ```cpp
while( n ){
        if(n & 1) q.push_front( num++ );//  判断n的就奇偶性
        else num++;//  num原为0，num记录这是是2的几次方
        n >>= 1;
    }
```
解释一下，如果$n\&1$真（等价于$n\%2==0$）说明$n$是奇数，所以就要把这个位置num头插进q中；如果是偶数说明num这个位置没有1。

例如对 13 进行处理，q中数分布如下3 2 0 。里面的三个数就代表三个瓶子啦，第一个瓶子装 $2^3$ 升水，第二个装 $2^2$ 升水，第三个就是 $2^0$ 升水。我们发现这三瓶水大于了我们要保留的瓶数 2，于是进入开心的while循环缩减瓶数中。


```cpp
num=0;//下面num代表新增瓶子总数
//limit是要保留的瓶数，q.size()是“1”的总数，目前为3

while((int)q.size() > limit){

   q.push_back(0);//每次放一个1升水的瓶子
   num++;//num增一

   while(q[(int)q.size() - 1] == q[(int)q.size() - 2])
//看看最后两个瓶子是否能合并 
   {
       q[(int)q.size() - 2]++;//可以合并倒数第二个瓶子的2的次方数加一
       q.erase(q.end() - 1);//开心的扔掉最后一个瓶子
       
       if((int)q.size() <= limit) 
       {//正好符合题意就输出答案
           cout<<num;
           exit(0);}
   }
}
```
模拟一下，

一开始  q.size() $=$ 3 $>$ 2

需要新的瓶子。

加入第一个瓶子，num ++；

发现可以与q中倒数第二个瓶子合并。

q（3 2 0 0）---> (3 2 1)

然后第二次while循环。

q（3 2 1 0）没有办法合并，num ++；

那就第三次吧 ，num ++；

q（3 2 1 0 0）---> (3 2 1 1) ---> (3 2 2) ---> (3 3)

成功了num $=$ 3。

测试样例，全对，信心满满地就交上去了，然后就会~~不出意外~~地TLE最后一个点。

是STL太慢了吗（吸氧气也冲不过）。。。

然后发现，每次只加一个一升瓶子去试太慢了，完全可以加到q中最后一个数的 2 次方升水来合并掉最后一瓶水嘛，num不就是加上2的这个次方吗？

优化一下就好了。

```cpp
    while((int)q.size()>limit){
        //优化如下
        q.push_back(q[(int)q.size()-1]);//加上与最后一瓶水相同体积的水
        num+=pow(2,q[(int)q.size()-1]);
        //num加上构成这瓶水需要的瓶子数
        while(q[(int)q.size()-1]==q[(int)q.size()-2]){
            q[(int)q.size()-2]++;
            q.erase(q.end());
            if((int)q.size()<=limit) {
                cout<<num;
                exit(0);
            }
        }
    }
```
~~大功告成了，不懂位运算可以拿来救急~~

巨丑的完整代码：
```cpp
#include <bits/stdc++.h>

using namespace std;
  
typedef long long LL;
  
LL n,limit,num;
  
deque<LL>q;
  
int main(){
    cin>>n>>limit;
  
    while(n){
        if(n&1) q.push_front(num++);
        else num++;//num记录是2的几次方
        n>>=1;
    }
  
    num=0;//下面num为当前新增瓶数
  
    while((int)q.size()>limit){
        q.push_back(q[(int)q.size()-1]);
        num+=pow(2,q[(int)q.size()-1]);
        while(q[(int)q.size()-1]==q[(int)q.size()-2]){
            q[(int)q.size()-2]++;
            q.erase(q.end()-1);
            if((int)q.size()<=limit) {
                cout<<num;
                return 0;
            }
        }
    }
    cout<<num;//不加这个只能得80分
    return 0;
}


```
有疑惑或者发现代码写错了可以私信我 , 新年快乐！
## 蒟蒻第一篇题解，求过


---

## 作者：bigbigdoggy (赞：2)

### 蒟蒻的第二篇题解ing：

------------



## 这里介绍的是一种一点也不快，一点也不短，但不用2进制的解


### 看大佬题解的眼神中带着一丝忧伤


##### 因为代码极易理解，四十行不到，所以就不加注解了

放抄袭已开启，直接复制会有两个点错掉

------------

```cpp
#include<bits/stdc++.h>

using namespace std;

int main()

{

	int n,k,t,x=1;
	int ans=-1;
	t=0;
	cin>>n>>k;
	while(t+1<=k)
	{
		x=1;
		while(n>x)
		{
			x=x*2;
		}
		if(n<x)
		{
			x=x/2;
			n=n-x;
			t++;
		}
		else if(n-x+t+1<=k)
		{
			ans=0;
			break;
		}
	}
	if(ans==-1)
	{
		ans=x-n;
	}
	cout<<ans<<endl;
	return 0;
}
```

###### 我死也不会告诉你，把int改longlong就好了

---

## 作者：贞白徐晟 (赞：2)

（好久没发题解，来水一波）

第一次看到这道题时，直接跳过了，还是~~(旁边一个人提醒了我)~~但是后来想想还是试一把吧

思路：

现将所有的相同的水量合并在一个瓶子里
比如
以13为例


```cpp
1 1  1 1  1 1  1 1  1 1  1 1  1
 2    2    2    2    2    2   1
 
2 2  2 2  2 2  1  
 4    4    4   1         

4 4  4 1   
 8   4 1

8 4 1
```
       
我们可以用一个优先队列来存储

while循环，每次判断队列里的元素个数

当小于K是就退出

```cpp
#include <cstdio>
#include <queue>
using namespace std;
int n, k, a, b, ans, o = 1;
priority_queue <int, vector <int>, greater <int> > q;   //优先队列，越小的整数优先级越高的队列 
int main ()
{
	scanf ("%d %d", &n, &k);
	while (n > 0){
		a = n % 2;
		if (a == 1)
			q.push (o);
		o = o * 2; 	
		n = n / 2;
	}//将能合并的水合在一起 
	while (q.size () > k){ //判断队列的元素个数是否小于等于k 
		a = q.top (); 
		q.pop ();
		b = q.top ();
		q.pop ();
		//取出最小的两个元素 
		if (a == b)
			q.push (a + b);//如果相同则合并 
		else{
			q.push (b);
			ans = ans + a;
			q.push (a * 2);//不相同则买a个瓶子合并 
		}
	}	
	printf ("%d", ans);//输出 
	return 0;
}
  
```

---

## 作者：塔罗兰 (赞：2)

这是一个进制的问题，需要我们把n转化为二进制

1的个数则为当前可以合并成的最小的瓶子数

我们需要使1变少，那么怎么办呢？

假设有一组数据为

5 1

5转化为二进制为101

买一个瓶子为110

再买一个111

再买一个1000符合题目要求

简单来说就是101->110->1000

由此可以推出买2^i个瓶子可以使二进制数n的i位+1

一直向前推到下一位为1时，比之前的瓶子数-1

晕了吗

代码帮助理解：~~其实原理建议看其他dalao的题解~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int v[28]={0,2,4,8,16,32,64,126,256,512,1024,2048,4096,8192,17384,32768,65536,131072,262144,524188,104853,2097152,4194304,8688608,16057216,379224432,64638864,2333317728};\\打表2^i
int n,k,i,j,sum,l;
int a[666666666666]; 
int main()
{
	scanf("%lld%lld",6n,6k);
	for(i=0;n>0;i++)
	{
		a[i]=n%2;
		if(a[i]==0)
		sum++;\\统计当前的瓶子数
		n/=2;
	}\\转化为二进制数
	if(sum<=k)
	{
		printf("lld",&0);
		return 6;
	}\\如果不需要多买瓶子的情况
	for(j=0;j<=i+1;j++)
	if(a[j]==1)
	{
		l+=v[j];
		a[j+1]++;
	}\\如果这位为1则加上需要的瓶子数合并为2^i+1体积的瓶子
	else
	if(a[j]==2)\\如果这里不需要买瓶子就可以进位
	{
		a[j+1]++;
		sum--;\\瓶子数会-1
		if(sum<=k)
		{
			printf("%lld",&l);
			return 6;
		}\\符合条件则输出结果并结束程序
	}
}
```
请认准图灵冯诺依曼牌标志：\\\

代码有小坑，Ctrl+c会怎么样就不知道了(阴险)，但主要思路是对的

---

## 作者：lamboo (赞：2)

本题纯数学题

可理解为

求k个2^x的和，使其为大于等于n中最小的数，并算出与n的差

对样例3进行模拟

输入 1000000 5

```cpp
1000000    -524288    =475712
475712    -262144    =213568
213568    -131072    =82496
82496    -65536    =16960
```
先求出k-1个2^x，使其为小于n中最大的
每一步都是求2^x，使其为小于n中最大的，并算出差

32768    -16960    =15808

最后只要算出2^x，使其为大于n中最小的

最后的15808即为所求的数

```cpp
var n,m,i,j:longint;
    f:array[0..40] of int64;
    //题中N最大不超过2^31，我这里开得稍微大了点
begin
readln(n,m);
f[0]:=1;
for i:=1 to 40 do f[i]:=f[i-1]*2;  //f[i]保存2^i
for i:=1 to m-1 do  //先做m-1次
  for j:=0 to 40 do //枚举2^x
    if f[j]>n then  //f[j-1]小于n中最大的
      begin
      n:=n-f[j-1];
      if n=0 then begin writeln(0);halt; end;  //如果倒水已经满足要求，就输出0
      break;  
      end;
  for i:=0 to 40 do
    if f[i]>=n then
      begin
      writeln(f[i]-n);
      break;
      end;
end.
```

---

## 作者：_蒟蒻__ (赞：1)

两两合并——2的某一次方。

转化成2进制处理，统计1的个数，想办法从低位尽可能把1往上提，从而想办法消掉。这时候就能联想到树状数组的lowbit，每次上提对答案贡献为lowbit(n)，n为当前的二进制数（状态）。

其实以上大佬们都讲了，蒟蒻只是提一提，~~显得字数多一点~~

咋统计1呢，大佬们有用__builtin_popcount（）的，但一看开头的下划线就明白——放弃吧，NOIP不会让用的。 另外呢，还可以暴力枚举。

生命苦短，我选择bitset

```cpp
#include<iostream>
#include<bitset>
#define int long long  //懒人专用 
#define lowbit(x) x&(-x)
using namespace std;

signed main()
{
	int n,k;
	cin>>n>>k;
	bitset<50>a(n); //传说中的构造函数语法。 
	int ans=0;
	while(a.count()>k)
	{
		ans+=lowbit(n);
		n+=lowbit(n);
		a=n; // 神奇 
	}
	cout<<ans;
	return ~~ (0 - 0);
}
```


---

## 作者：Tanktt (赞：1)

突然发现做一年前做过的题是很有意思的。

这道题实际上能用二进制来做。因为一开始每个瓶子装有1升水，只有当前体积相同的瓶子才能合并，所以每次合并后水的体积都是2的幂次。我们只要把n拆成二进制，每次把最后一个一变成零，即向前进一位，不断往复，直到n中1的个数<=m时就结束了。

17行代码：
```cpp
#include<cstdio>
using namespace std;
long long n,w,ans;
int m,cnt;
int main()
{
	scanf("%lld%d",&n,&m);
	while (1)
	{
		cnt=0;w=n;
		while (w) cnt+=w&1,w>>=1;
		if (cnt<=m) break;
		ans+=n&(-n);
		n+=n&(-n);
	}
	return printf("%lld\n",ans),0;
}
```

---

## 作者：不知不觉lb (赞：1)

好像还没有人用****递归****做=.=
被卡常改了N次

顺便膜楼下二进制dalao们

------------

水一发  递归题解

f（N,K）就是题意求的至少需要的瓶子个数

然后就发现

1+1=2

2+2=4

4+4=8

就想到了~~2048小游戏~~2的若干次幂

要求的即是求K个2的若干次幂且他们的和与N的差最小

## 递归边界：

N=1的时候不需要加瓶子 f(1,K)=0

K=1的时候呢只可能是添加许多瓶子使这一个瓶子装2^i的水使得2^i和N最小即最小的i使得2^i>=N

~~一看范围2e9 log下来不过30然后就简单枚举就超时~~
(优化在后面)

f(N,1)=2^i-N

------------

否则的话肯定是用目前有的一个瓶子装尽量多的水，但不能超过N，否则没法递归了=.=

这个瓶子装的水也是2的若干次幂
用一下上面的i就可以得到

f(N,K)=f(N-2^(i-1),	K-1)

若当前就可以装完的话也是可以继续递归的，反正最后使得K=1的时候 return 2^i-N 等于0 也不会变多，也可以特判一下跑的更快

还有求i的优化不用循环求
直接$\log_2N$向上取整

综上可以得到
```cpp

inline ll f(int N,int K)
{
	if (N<=1) return 0;
	int i=1+(int)(log(N-1)/log(2));
	if (K==1) return (1<<i)-N;
	if (N==(1<<i))	return 0;
	return f(N-(1<<(i-1)),K-1);
}

```



---

## 作者：方方小逗逼 (赞：1)


##~~出自wǎnjiāng装逼集团 fy~~


简单的数论题

分析可得，对于n个瓶子，进行一次操作后，会合并成（（n div 2）+（n mod 2）），其中，n div 2个可进行下一次操作

综上所述，可很自然联系到2进制，这简直和十转二的方法一模一样

于是，分析可得，对于n个瓶子，最后会合并成其二进制下“1”的个数的瓶子

例如
（13）10=（1011）2 所以13会合并为3个瓶子

所以，答案即为下一个二进制数中“1”的个数小于k的数减去n（具体的方法见程序）



```cpp
var
  a,b:array [0..1000] of longint;
  n,m,i,j,k,s:longint;
  l,r:int64;
begin
  read(n,m);
  k:=0;
  s:=0;
  while n>1 do
  begin
    inc(k);
    a[k]:=n mod 2;
    b[k]:=a[k];
    s:=s+a[k];
    n:=n div 2;
  end;
  inc(k);
  a[k]:=1;
  b[k]:=1;
  inc(s);
  i:=1;
  if s<=m then
  begin
    write(0);
    exit;
  end;
  while s>=m do
  begin
    s:=s-b[i];
    b[i]:=0;
    inc(i);
  end;
  while b[i]=1 do
  begin
    b[i]:=0;
    inc(i);
  end;
  b[i]:=1;
  if i>k then k:=i;
  for i:=1 to k do
  begin
    if b[i]<a[i] then
    begin
      dec(b[i+1]);
      b[i]:=b[i]+2;
    end;
    b[i]:=b[i]-a[i];
  end;
  l:=1;
  for i:=1 to k do
  begin
    r:=r+b[i]*l;
    l:=l*2;
  end;
  write(r);
end.
```
##~~出自wǎnjiāng装逼集团 fy~~

---

## 作者：夏色祭 (赞：1)

#玄学的数学方法

楼下都没有Pas的，那我来补一发

可以看出2^m个瓶子肯定能合成一个，那么我们就先把这n个瓶子先合并成能合并的最少瓶子数，然后把最小的一瓶水和第二小的能合并成新的一瓶水，使总瓶数少一，然后重复之前的操作（合并最小的体积和第二小的体积）直到总瓶数<=m，然后输出每次最小的体积和第二小的体积差之和。。。

##这样居然过了

##我只能说：水题水题

献上AC代码：

```cpp
var
  a:array[0..1000000]of longint;
  i,x,n,m,ans:longint;
  sum:int64;
begin
  readln(n,m);
  while n>1 do 
    begin
      sum:=1;
      inc(x);
      while sum<=n do sum:=sum*2;
      a[x]:=sum >> 1;
      dec(n,sum >> 1);
    end;//那么我们就先把这n个瓶子先合并成能合并的最少瓶子数
  inc(x);
  a[x]:=n;
  while x>m do 
    begin
      inc(ans,a[x-1]-a[x]);//加上第一小和第二小的瓶子里的水的体积的差之和
      dec(x);
      a[x]:=a[x]*2;//合并体积最小的和第二小的，其实就是直接去掉最小的，然后把第二小的体积*2
      while a[x]=a[x-1] do //因为第二小的值改变了，看看它是否能和之前的合并
        begin
          dec(x);
          a[x]:=a[x]*2;
        end;
    end; 
  writeln(ans);
end.

```

---

## 作者：_Andy_Lin_ (赞：0)

[又忍不住宣传我的博客了](https://www.luogu.com.cn/blog/linguosheng/)

------------

最初每个瓶子中都是1升水，也就是2^0升水。每次都是相同的水量相加，2^0升与2^0升相加变为2^1升，2^1升与2^1升相加变为2^2升······以此类推。所以瓶子里的水量就总是2的整数次幂。所以我们可以将n打包成一个二进制数。每买一个瓶子就往二进制数里加一。当二进制数中的1的数量小于k时，就输出加的瓶子数量。

------------
当然，计算机内部就是二进制，所以可以用更快的位运算，还不用化二进制。此外，我们还可以加一个贪心：当有n升水时，每次加lowbit(n)个（学过树状数组的应该知道这个概念）。因为小于lowbit(n)，再怎么加也只会让瓶子的数量增加，更不可能小于k个。

------------
最后附上AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans,t;
inline int lowbit(int x){
	return x&(-x);
}
int main(){
	scanf("%d%d",&n,&k);
	while(1){
		t=0;
		for(int temp=n;temp;temp-=lowbit(temp))t++;
		if(t<=k)break;
		int x=lowbit(n);
		ans+=x;
		n+=x;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：hmyll (赞：0)

[P1582 倒水](https://www.luogu.org/problem/P1582)
因为每次都是两个体积一样的瓶子合并，所以k个瓶子里每个瓶子装的都是2的次方的数。而每个2次方的数的二进制都是左边第一位是1，右边的数都是0。

所以**用k个瓶子装的时候就要保证瓶子的数量化成2进制的时候有不大于k个1**.
如k为3的时候可以为装的数量为111,1110,11001以及1的个数小于3的时候。
再看n，**n化成2进制的数的1的数量就要不大于k数量才能刚好装完**。
以样例2位例:
13的2进制是1101，1101有3个1，就需要3个瓶子，而k为2，所以需要加瓶子。
要怎么加呢？一个一个的加太慢了，可以从n的2进制最末尾的1加起，2进制1+1进1取0.
如13的2进制为1101，末位为1，加1为1110，然后加上二进值10，就是10000，1的数量不大于k，符合条件，一共加了3个瓶子，结束。
放代码，剩下的就好理解了：
```c
#include<stdio.h>
#include<math.h>
int lowbit(int n){
	int c=0;
	while(n){
		n-=n&(-n);//计算n的2进制中从左到右最后一位1及后面的0值
		c++;	  //循环相减就可以求得n中1的个数了
	}
	return c;
}
int main(void)
{ 
   int i,n,k,j,ans=0;
   scanf("%d %d",&n,&k);
   while(lowbit(n)>k){
    	ans+=n&(-n);
    	n+=n&(-n);
	}
	printf("%d",ans);
  return 0;
} 
```


---

## 作者：老咸鱼了 (赞：0)

这里介绍一种打表过的方式，题目告诉你是每两瓶水就能合并成一个更大的，那么我们就把所有2的倍数都存起来注意要把0也存上，有2组数据答案是0，不存0的话过不去。

解法就是一种贪心的思想，每次取最大的能取的2倍的整数就拿样例的1000000 5来说我们先取出524288瓶，这么多可以当成一瓶剩下475712再取262144瓶剩下213568瓶一直取最后剩下82496并且你只能剩一瓶的时候我们就找距离他最近的比他大的2的整数倍1048576用这个减去剩下的就是还要新买的瓶子的数量了
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
long long int a[33]={0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648};
int main()
{
	scanf("%d%d",&n,&k);
	while(k>1)
	{
		for(int i=0;i<=32;i++)
		{
			if(a[i]>n)
			{
				n-=a[i-1];				
				k--;
				break;
			}
		}
	}
	for(int i=0;i<=32;i++)
	{
		if(a[i]>=n)
		{
			ans=a[i]-n;
			break;
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Soledad_S (赞：0)

思路和楼下一样，主要介绍下$bitset$的做法

楼下的大佬用了__$builtin$_$popcount$函数，目的是计算一个数的二进制表示中1的数量。但$Noip$是不能用下划线开头的函数的，怎么办呢？如果用$lowbit$硬拆未免太暴力，这时$STL$大法就有用了。

$bitset$可以看作一个多位二进制数或$bool$数组，它不仅支持普通的位运算，还支持取出任意位，和$int$，$string$类的强转等操作。其中，$count$函数能返回1的个数。

那么愉快地写完了。

关于$bitset$的更多，可以问度娘哟 ~~（其实是我懒得写了）~~

```cpp
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<bitset>
using namespace std;
#define int long long
inline int read() {
    char ch;
    bool bj=0;
    while(!isdigit(ch=getchar()))
        bj|=(ch=='-');
    int res=ch^(3<<4);
    while(isdigit(ch=getchar()))
        res=(res<<1)+(res<<3)+(ch^(3<<4));
    return bj?-res:res;
}
bitset<64>tmp;
int ans,n,k;
inline int lowbit(int x) {
    return x&(-x);
}
signed main() {
    n=read();
    k=read();
    tmp=n;
    while(tmp.count()>k) {
        ans+=lowbit(n);
        n+=lowbit(n);
        tmp=n;
    }
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：paper_plane (赞：0)

题目描述

一天，CC买了N个容量可以认为是无限大的瓶子，开始时每个瓶子里有1升水。接着~~CC发现瓶子实在太多了，于是他决定保留不超过K个瓶子。每次他选择两个当前含水量相同的瓶子，把一个瓶子的水全部倒进另一个里，然后把空瓶丢弃。(不能丢弃有水的瓶子)

显然在某些情况下CC无法达到目标，比如N=3,K=1。此时CC会重新买一些新的瓶子(新瓶子容量无限，开始时有1升水)，以到达目标。

现在CC想知道，最少需要买多少新瓶子才能达到目标呢？

输入输出格式

输入格式：
一行两个正整数， N,K(1≤N≤2×10^
9
 ,K≤1000)。

输出格式：
一个非负整数，表示最少需要买多少新瓶子。

		解题思路：
		  可以把个数转化为二进制，
              然后利用lowbit快速求解
              题如其名，是道大水题
              code:
```cpp
#include <iostream>
#include <cmath>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=10005;
long long lowbit(long long x){
	return x&(-x);
}
long long work(long long x){
	long long cnt=0;
	while(x){
		x-=lowbit(x);
		cnt++;
	}
	return cnt;
}

int main(){
	freopen("1582.in","r",stdin);
	freopen("1582.out","w",stdout);
	long long n,k,ans=0;
	scanf("%lld%lld",&n,&k);
	while(work(n)>k){
		ans+=lowbit(n);
		n+=lowbit(n);
	}
	printf("%lld\n",ans);
	return 0;
}

```

          

---

## 作者：＂黎筱っ (赞：0)

## $P1582$倒水

真心是第一道做着顺手的数学题。

通过打表可以发现，$N$的二进制中有多少个$1$，就能合并到几个瓶子里。

如果$k \leq 1$的个数，那就一个也不用加。

反之，我们就要让$n$加上一个数后的二进制中的$1$的个数小于$k$。

假设当前超出了$x$个$1$，那么就要去掉$x + 1$个$1$，然后在第$x$个$1$的更高一位加上一个$1$。

答案就是这个数和$n$的差。

代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
inline long long read(){
    long long x = 0; int f = 0; char c = getchar();
    while(c < '0' || c > '9') f |= c == '-', c = getchar();
    while(c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return f? -x:x;
}

long long n, m;
int k, a[37], cnt, sum;
int main(){
    n = read(); k = read();
    m = n;
    while(m){
        ++cnt;
        if(m & 1) a[cnt] = 1, sum++;//拆分n
        m >>= 1;
    }
    if(sum <= k){printf("%d\n", 0); return 0;}
    int num = sum - k + 1, p = 0;//num表示要去掉多少个1
    for(int i = 1; i <= cnt; ++i){
        if(a[i] == 1) p++;
        if(p == num){//个数达到了就记录并退出循环
            m = 1 << i, p = i;
            break;
        }
    }
    n = 0;
    for(int i = 1; i <= p; ++i)//只统计要修改部分的值即可
        n |= (a[i] << i - 1);
    printf("%d\n", m - n);
    return 0;
}
```



---

## 作者：greyishsong (赞：0)

### 贪心思路的证明

本人水平有限，如果大家发现纰漏之处，还望不吝赐教。

题意实际上是如下的数学问题：

将 $n+p$ 分解为$n+p=b_{1}2^{a_{1}}+b_{2}2^{a_{2}}+\dots+b_{n}2^{a_{n}}$，求在 $\displaystyle\sum_{i=1}^{n} b_i \leq k$ 的前提下， $p$ 的最小值

给出一种购买方案：初始时 $p=0$ 

$1^{\circ}$：$n$ 在二进制表示下，1的个数大于 $k$ 则跳转到 $2^{\circ}$ ，否则结束

$2^{\circ}$：$n=n+lowbit(n),p=p+lowbit(n)$

下面证明这就是最佳的购买方案， $p$ 就是最终要购买的瓶子数量。



------------


定义概念：

* 最小分解数：
$\forall{x}\in\mathbb{N}$ , 将 $x$ 分解为$x=b_{1}2^{a_{1}}+b_{2}2^{a_{2}}+\dots+b_{n}2^{a_{n}}$,可以取得的 $\displaystyle\sum_{i=1}^{n} b_i$ 的最小值( $a_1<a_2<\dots<a_n$ )

则有：$P_1$：将任意分解方案中的一个 $2^{m}$ 替换为一个 $2^{m-1}$ ，这个分解方案不会更优。

$\implies P_2$：将任意个2的高次幂替换为2的低次幂，方案不会更优。

$\implies P_3$：最佳的分解方案中，$b_i$ 应当取1，否则可以用2的更高次幂替换。即求最佳的分解方案等同于求 $x$ 的二进制表示。



------------


由命题 $P_3$ ，若题中 $n$ 的最小分解数 $>k$ ，

则 $n+p(p<lowbit(n))$ 的最小分解数 $>k$
.

故欲使 $n+p$ 的最佳分解数减小，必有 $p\geq lowbit(n)$.

若 $\exists p>lowbit(n)$，使得 $n+p$ 在二进制下1的个数比 $n$ 减少，则必 $\exists p^{'}<p$ ，可以达到至少不更差的效果，因为二进制下所有低位的和必定小于高位。

例如 $(11101)_2+(100)_2=(100001)_2$，但是 $(11101)_2+(11)_2=(100000)_2$

综上，每次取 $p=lowbit(n)$ 的贪心策略是正确的。



------------

思路完毕，代码我写得并不是很好（先做出的题才想出的证明）就不贴了。

---

## 作者：wine (赞：0)


这个绿题好烧脑QAQ，
按照题意1和1可以合并成2,2和2合并成4,4和4合并成8，这不就是游戏[2048](http://2048game.com)吗。我们先让方块尽量合并，如果剩下的比k多，那就新产生一些1，使其合并成为值等于已有的最小的方块，这样那个方块的值×2，如果正好有是它2倍的方块，那就合并，拥有方块数减一，再看有没有它4倍的......，如果没有它2倍的方块，就继续产生1，合并，直到它足够大能与第二小的方块合并。


------------
用二进制表示的话比想象中的简洁，n的二进制为有几个1就代表有几个不同的格子，如（0001001）代表一个1，一个8两个格子。。
t & -t是[二进制表达式中最低位的1所对应的值](https://blog.csdn.net/qq853674765/article/details/70050306)，即最小的格子。
。合并成一个格子所需的1的个数就是格子的值。
我是用go写的，学c++应该能看懂。

------------



```go
package main

import "fmt"

func main() {
	var n, k, ans int
	ans = 0
	fmt.Scanf("%d%d", &n, &k)
	for true {
		var s, t = 0, n
		for t != 0 {
			s++
			t ^= t & -t
		}
		if s <= k {
			break
		}
		ans += n & -n
		n += n & -n
	}
	fmt.Println(ans)
}


```

---

## 作者：朝花夕拾_勿忘 (赞：0)

由题目可知，含水量相同的瓶子可以合并，但如果两两枚举，一个个的合并比较，那速度就很慢了，这时就需要----二进制转化orz。
至于二进制转化有两种，一种是lowbit(),还有一种就是————手动拆。
```c
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<stack>
#define LL long long
#define rs register
#define inl inline
using namespace std;
LL n,k;
inl LL qk(LL a,LL b){
	if(b==0) return 1;
	LL ans=1;
	while(b){
		if(b&1) ans*=a;
		a*=a;
		b>>=1;
	}
	return ans;
}
LL sc;
stack<LL> q;
int main(){
	scanf("%lld%lld",&n,&k);
	LL p=n;
	while(p>1){
		LL ci=log(p*1.0)/log(2.0);求能拆出的2的最大次方
		LL u=qk(2,ci);//求它有多大
		q.push(u);
		p-=u;
	}
	if(p>0) q.push(p);//最后可能为1
	LL num=q.size();//while条件用q.size()要报错，我也不知道为什么
	while(num>k){
		LL a=q.top();q.pop();
		LL b=q.top();q.pop();
		if(a==b){
			q.push(a+b);//不用买瓶子，直接合并
		}
		else{
			sc+=abs(a-b);//差多少补多少
			q.push(2*(a>b?a:b));//合并后放回去
		}
		num=q.size();
	}
	printf("%lld",sc);
	return 0;
}

```
其实这题可以打while模拟的原因是2的k次方是指数函数，呈爆炸性增长，所以在题目的范围之内也拆不出几个~~~~~~~~

---

## 作者：MrBlack (赞：0)

```cpp
#include<iostream>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
int two[32];  //存储2的0次到2的31次，下标为指数
int book[32];  //标记该2的次方是否用到
int sum;  //需要的额外瓶子数
int main()  //2的次方的瓶子都能合并成1个
{
    int count = 0;  //总共可以合并到的最少瓶子
    two[0] = 1;
    for (int i = 1; i <= 32; i++)  //给two数组赋值
    {
        two[i] = 2 * two[i - 1];
    }
    int N, K;
    cin >> N >> K;  //瓶子数和要求合并到的瓶子数
    if (N < K)  //如果瓶子数比要求合并的少，只需要买到要求合并的即可，每个瓶子1升水
    {
        cout << K - N;
        return 0;
    }
    for (int i = 30; i >= 0; i--)
    {
        //N必定减到0，参考二进制
        //这是能合并到的最少瓶子数，相当于贪心，把瓶子数N尽可能的减掉
        //而根据二进制，每位最高只能是1，是2就能向上合并
        if (N >= two[i])  //其实这里用二进制来取位运算更快
        {
            N -= two[i];
            book[i]++;  //标记该次方已经用过
            count++;  //统计可以合并到的最少瓶子
            if (!N)  //N为0就已经统计完毕了
                break;
        }
    }
    if (count <= K)
    {
        cout << 0;
        return 0;
        //要求瓶子数比可以合并的最少瓶子数大
        //而又比最多瓶子数少，说明一定能满足
        //因为增加瓶子数很简单，只要高次方向低1次的拆就能多一个瓶子，最多拆到每份都是1个瓶子
        //并且说明了瓶子数的增加是连续的而不是离散的
    }
    for (int i = 0; i <= 32; i++)
    {
        //减少瓶子数只需要将不同位的two元素移到同一位并合并即可
        //每次合并瓶子数减少1
        //而且从数组底部开始合并更省
        //比如128升1位要用128个瓶子，而比128小的升到128与它合并最多只要127个瓶子
        if (book[i] == 1)
        {
            sum += two[i];
            book[i] = 0;
            book[i + 1]++;
        }
        if (book[i] == 2)
        {
            book[i] = 0;
            book[i + 1]++;
            count--;
            if (count == K)  //已经满足要求的数目
            {
                cout << sum;
                return 0;
            }
        }
    }
    return 0;
}
```

---

## 作者：bjrjk (赞：0)

这道题很有意思，所以要在这里好好的写一下题解。

由“开始时每个瓶子里有**1升水**”和“新瓶子容量无限，开始时有**1升水**”、“他选择两个当前**含水量相同**的瓶子，把一个瓶子的水全部倒进另一个里”，很容易联想到但凡不是空瓶子，每个瓶子里水的数量**一定都是以2为底的幂**，如1、2、4、8、16、32、64……等等。由此我们可以将这些数字放到**二进制**视角下来思考。

由题中说“他决定保留不超过K个瓶子”，可将其转化为“CC最终所具有的**瓶子总数** $n_f$ **在二进制表示形式下有总计不超过K个1**”。

（下面说的所有东西可能都不太好想，请认真思考。）

然而我们需要买空瓶子……所以结果的数字只能大不能小，因此我们需要通过去除数字末尾的1，**保留数字前面的1**来使数字达到要求。

除了Lowbit之外，我还有一种做法（这个做法其实就是Lowbit和加综合起来的底层实现、本人不是特别会Lowbit）。这个做法分为三步：

1、找到数字中倒数第一个1.

2、把接下来从后向前连续的所有1变成0.

3、再把接下来不是1的第一个0变成1.

举例：原数：001011

第二步完成后：001000

第三步完成后：001100

重复进行这一操作，直到满足要求“瓶子总数 $n_f$ 在二进制表示形式下有总计不超过K个1”即可。

代码如下：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<string>
#include<deque>
#include<map>
#include<cstring>
using namespace std;
inline int & setBit(int & v, int sv, int p) {
	if (sv) {
		v |= 1 << p;
	}
	else {
		v &= ~(1 << p);
	}
	return v;
}
inline int getBit(int v, int p) {
	return (v >> p) & 1;
}
bool checkBits(int value, int num) {
	int cnt = 0;
	for (int i = 0; i < 32; i++) {
		cnt += getBit(value, i);
	}
	return cnt <= num;
}
int main() {
	int n, k;
	cin >> n >> k;
	int no = n;
	while (!checkBits(n, k)) {
		int ptr = 0;
		while (!getBit(n, ptr))ptr++;
		while (getBit(n, ptr)) {
			setBit(n, 0, ptr);
			ptr++;
		}
		setBit(n, 1, ptr);
	}
	cout << n-no;
}
```

---

## 作者：Zachary_260325 (赞：0)

 ~~蒟蒻开始瞎写题解划水~~
 
### - 思路
读题之后发现说明了每个瓶子开始有水1升，也就是说最开始瓶子的数量就是水的总量。

因为任意有相同量的水的瓶子可以合并成一个瓶子，所以**2$^n$**个瓶子可以合并为一个瓶子。在减少瓶子到需求值之前，需要先对瓶子进行初步的合并再进行操作。

例如题目中的瓶子数量为3时，可以把3视作**2$^1$+2$^0$**，所以可以合并为两个瓶子；瓶子数量为13的时候可以视作**2$^3$+2$^2$+2$^0$**，所以可以合并为3个瓶子。

因此可以得出初步合并的瓶子数量计算的代码：
```cpp
while(n)
{
	if(n&1)
		now++;
	n>>=1;
}
```


------------

知道了如何初步合并，就应该想办法减少瓶子。

比如样例里的13**（2$^3$+2$^2$+2$^0$）**，想要减少一个瓶子，需要通过增加瓶子来使两个已经瓶子再合并，有两个方法：

一个是增加**2$^2$**个瓶子，让原来装水**2$^2$**升与**2$^3$**升的两个瓶子合并为一个**2$^4$**的瓶子，消耗4个瓶子。

另一个是先增加**2$^0$**个瓶子让**2$^0$**的瓶子变成**2$^1$**的，再增加**2$^1$**个瓶子使**2$^1$**的瓶子与**2$^2$**的合并为**2$^3$**的（实际上会直接会与原来的**2$^3$**的合成一个**2$^4$**的......不过已经达到**now<=k**的目的就没必要继续管了......），消耗3个瓶子。

再考虑一下其他情况，显然从小开始向上加是最优的减少瓶子的方案。

------------

### - 代码实现方式

我是建立一个queue来安照从小到大记录所有合并成的瓶子的大小，然后就可以开始疯狂合并直到达到**now<=k**,因为数据里**k**一定大于等于**1**（不然没法做到合并成0个瓶子），所以一定可以合并完成。

### - 代码
```cpp
#include<cstdio>
#include<queue>
std::queue<int> que;
int n,k,now,x=1,ans;
int main()
{
	scanf("%d%d",&n,&k);
	while(n)
	{
		if(n&1)
		{
			now++;
			que.push(x);//直接就是按顺序存了，非常移动 
		}
		x<<=1;
		n>>=1;
	}
	int a=que.front();
	que.pop();
	while(now>k)
	{
		while(que.front()!=a)//暂时无法与已经有的其他瓶子合并 
		{
			ans+=a;//买a个瓶子 
			a<<=1;//向上组成一个新的 
		}
		while(que.front()==a)//可以继续合并就合并 
		{
			a<<=1; 
			que.pop();//已经合并了，所以就直接变成一个更大的了 
			now--;
		}
	}
	printf("%d",ans);
	return 0;
}
```

~~简单易懂的题解......~~

---

## 作者：NTG_Adiord (赞：0)

不知道这个办法重没重复......
二进制，二进制
首先开个100大小的cun，每个单独的数组存一位
开一个res存答案
开一个k存瓶数
开一个sheng存剩下的瓶数
开一个优先队列存一下那些位是1（按位数从小到大排列）

直接把n存到cun[1]里，开一个zhi指向当前位，初始为1
接下来跑个while，只要当前所指>1就跑while，zhi+1那位自然等于zhi那位除以2，然后zhi等于那位%1，并且剩下的瓶数+1
如果%完还剩1，那么就扔到优先队列里

只要zhi+1那位比1大，那么就让zhi++
这个样子就完成二进制转化了

接下来再跑一个while，只要剩下的大于k，先判断当前队列队头所对的值是不是0，是就pop掉，然后再取出一个数给zhi赋值，然后pop掉，同时再开一个默认为1的add，让add乘上zhi-1次的add,加到res里

接下来把zhi这一位清空，让zhi+1位+1，如果等于1的话就丢到队列里，如果等于2就让zhi+1位清空，同时剩的瓶子数-1(毕竟消掉了)zhi+2位+1，依次类推跑个while就好

然后代码
```cpp
#include <cstdio>
#include <queue>
using namespace std;
int bol[100];//存位
int res;//所需瓶子
int zhi=1;//默认指向
int sheng;//还剩多少个瓶子
int k;//需要留下的瓶数
priority_queue<int,vector<int>,greater<int> > cun;//存位数
int main(){
	scanf("%d%d",&bol[1],&k);
	while(bol[zhi]>1)
		{
				bol[zhi+1]=bol[zhi]/2;//进位
				bol[zhi]=bol[zhi]%2;//这一位剩的
				if(bol[zhi]==1)cun.push(zhi);//剩1就丢到队列里
				sheng+=bol[zhi];//同时再把剩下的瓶子数+1，最后一定是这些瓶子再不买瓶子情况下里最后剩了多少
				if(bol[zhi+1]>=1){
					zhi++;//需要进位，++
				}
			}
		sheng++;//打头的那一位不会被while跑掉，手动加
		while(sheng>k){
			//剩下的
			while(bol[cun.top()]==0){
				cun.pop();//清理
			}
			zhi=cun.top();//取完了就扔
			cun.pop();
			int add=1;//需要加上的瓶子
			for(int w=1;w<zhi;w++){
				add=add*2;
			}
			res+=add;
			bol[zhi]=0;//清空这一位
			bol[zhi+1]+=1;
			while(bol[zhi+1]==2){//如果zhi+1位需要进位
				zhi++;
				bol[zhi]=0;
				bol[zhi+1]+=1;
				sheng--;
			}
				if(bol[zhi+1]==1)cun.push(zhi+1);
		}//还剩1个，zhi+1位丢进队列
		printf("%d",res);
	}

```
大概就这样


---

## 作者：hongzy (赞：0)

### 二进制下的枚举


若一些瓶子能合并成一个，那么一定有2^x个瓶子


二进制下：


2^1 - 10


2^2 - 100


2^3 - 1000


..

可以推出：X个瓶子，能最少合并成几个瓶子就是二进制1的个数


比如10，二进制为 1010


1010 = 1000 + 10，就是说把10分成8和2，8个可以合成1瓶，2个合成1瓶，所以10最少合成2瓶


所以从N开始枚举，若i二进制1的个数小于等于K，得到解，结束


不过这样枚举会超时


.

### 优化

因为枚举目的是让1的个数尽可能少，所以每次i不要+1了，改为进位


比如当前枚举到1100，下一步应该+100进位，然后就变成10000，少了一个1


总结进位方法：+2^k,k是末尾0的个数


（这不就是树状数组BIT里的lowbit函数嘛！）


所以是 + x&(-x)


再推一下为什么x&(-x)


计算机里用的是补码，-x就是位 取反 再+1


假如一个数...10000,取反之后，应该是....01111


这时候再+1，进位，....10000


此时，与原数比起来，1之前的所有位都取反了，而末尾都是0，但有个进位出来的1是相同的


按位与(&)一下，就得到了那个1.


.

### 技巧





1 1<<i 表示2的i次方

2 (1<<i) & j 表示j的二进制第i+1位

3 C++ 中的 1LL 等同于 (long long)1

.

### 参考代码（0ms）

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main() {
    long long N, K, i, j, CNT;
    cin >> N >> K;
    for(i=N; ; i+=(i & -i)) {
        CNT = 0;
        for(j=0; j<64; j++) //long long 是 64位的 
            if(i&(1LL<<j)) CNT ++; //统计1的个数
        if(CNT <= K) break; //满足要求
    }
    cout << i - N << endl;
    return 0;
}

```

---

## 作者：邓晓蓝 (赞：0)

//这题实际上是一题有关二进制枚举的一道题。大家知道，无论怎么倒水，杯子里的水一定是：1,2,4,8,16,32,64,128……升。这些数都和二进制有关。

大家请看：

十进制          二进制

2                  10

4                  100

8                  1000

16                10000

32                100000

这道题之所以可以使用找二进制下1的个数来判断，就是这个原因。除了第一位之外，2的几次方的其它位都是0.如果某个数除了第1位之外其它位有1，则说明有水瓶无法再向其它瓶子倒水，只要无法再向其它瓶子倒水的瓶子个数<=k，就可以了。

```cpp
#include<cstdio>
using namespace std;
long long n,t,k,j;
int main()
{
          scanf("%lld%lld",&t,&k);
          long long js=0;
          do
          {
              long long zs=0;
              for (j=0;j<63;j++)
                if ((t&(1LL<<j))>0) zs++;   //这是与运算。可以快速判断这个数二进制下某位是否为1，若为1，则计数
              if (zs<=k) break;   //如果可以，就退出。
              js++;  //每次枚举加1个空瓶
              t++;
          } while (1==1);
          printf("%lld",js);
    return 0;
}
```
这道题用这个思路是对的，但是超时，因为效率不高，所以我们要在这个基础上进行优化。我们需要用到反码补码。其实要使1的个数减少，就要想办法进位，这样自然就想到要使用反码补码。
```cpp
#include<cstdio>
using namespace std;
long long t,k,js=0,i;
int main()
{
    scanf("%lld%lld",&t,&k);
    do
    {
        long long zs=0;
        for (i=0;i<63;i++)
          if ((t&(1LL<<i))>0) zs++;
        if (zs<=k) break;
        js+=t&(-t);   //每次不枚举加1个空瓶了。
        t+=t&(-t);
    } while (1==1);
    printf("%lld",js);
    return 0;
}
```

---


# [HNOI2005] 汤姆的游戏

## 题目描述

汤姆是个好动的孩子,今天他突然对圆规和直尺来了兴趣。于是他开始在一张很大很大的白纸上画很多很多的矩形和圆。画着画着,一不小心将他的爆米花弄撒了,于是白纸上就多了好多好多的爆米花。汤姆发现爆米花在白纸上看起来就像一个个点,有些点落在矩形或圆内部,而有些则在外面。于是汤姆开始数每个点在多少个矩形或圆内部。毕竟汤姆还只是个孩子,而且点、矩形和圆又非常多。所以汤姆数了好一会都数不清,于是就向聪明的你求助了。你的任务是：在给定平面上N个图形(矩形或圆)以及M个点后，请你求出每个点在多少个矩形或圆内部(这里假设矩形的边都平行于坐标轴)。


## 说明/提示

对于100%的数据，$N,M\le 500$


## 样例 #1

### 输入

```
3 4 
r 1.015 0.750 5.000 4.000
c 6.000 5.000 2.020
r 6.500 7.200 7.800 9.200
3.500 2.500
4.995 3.990
2.300 8.150
6.900 8.000
```

### 输出

```
1
2
0
1
```

# 题解

## 作者：Grisses (赞：7)

[题面](https://www.luogu.com.cn/problem/P2313)

建议加上标签“枚举，暴力”

首先，看看数据范围，500 直接暴力，也就 $n^2$。

对于一个点 $A=(x,y)$，我们枚举所有的图形：

1. 如果这是一个矩形 $(x_1,y_1,x_2,y_2)$，判断 $\min(x_1,x_2)<x<\max(x_1,x_2)$ 且 $\min(y_1,y_2)<y<\max(y_1,y_2)$，成立就表示 $A$ 在这个矩形中。

2. 如果这是一个圆，判断 $A$  到圆心的距离是否小于半径即可。

代码：
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,m,ans;
  struct node{
      char op;
      double a,b,c,d;
  }a[505];//储存所有的图形
  double x,y;
  double len(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}//求距离
  int main()
  {
      scanf("%d%d\n",&n,&m);
      for(int i=1;i<=n;i++){
          scanf("%c%lf%lf%lf",&a[i].op,&a[i].a,&a[i].b,&a[i].c);
          if(a[i].op=='r')scanf("%lf",&a[i].d);
          scanf("\n");
      }
      for(int i=1;i<=m;i++){
          scanf("%lf%lf",&x,&y);
          ans=0;
          for(int j=1;j<=n;j++){
              if(a[j].op=='r'){
                  if(min(a[j].a,a[j].c)<x&&x<max(a[j].a,a[j].c)&&min(a[j].b,a[j].d)<y&&y<max(a[j].b,a[j].d))ans++;
              }
              else{
                  if(len(x,y,a[j].a,a[j].b)<a[j].c)ans++;
              }
          }//暴力
          printf("%d\n",ans);
      }
      return 0;
  }
```

---

## 作者：Drifterming (赞：5)

这么好(shui)的题，让我来开第一炮。


/\*按输入把每种图形存起来，然后输入点的时候暴力枚举判断就行了\*/




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
using namespace std;
char type;
int n,m,sr,sc,tot;
double x,y,xx,yy,rr,minx,miny,maxx,maxy;
struct rec
{
    double minx,miny,maxx,maxy;
}r[505];
struct cir
{
    double x,y,r;
}c[505];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        cin>>type;
        if(type=='r')
        {
            scanf("%lf%lf%lf%lf",&x,&y,&xx,&yy);
            minx=min(x,xx);maxx=max(x,xx);    //找矩形的边界 
            miny=min(y,yy);maxy=max(y,yy);
            r[++sr].minx=minx;
            r[sr].miny=miny;
            r[sr].maxx=maxx;
            r[sr].maxy=maxy;
        }
        else
        {
            scanf("%lf%lf%lf",&x,&y,&rr);
            c[++sc].x=x;c[sc].y=y;c[sc].r=rr;
        }
    }
    for(int i=1;i<=m;i++)
    {
        tot=0;
        scanf("%lf%lf",&x,&y);
        for(int j=1;j<=sr;j++)        //如果在矩形内部，那么x一定在minx和maxx之间，y一定在miny和maxy之间 
        {
            if(x>r[j].minx&&x<r[j].maxx&&y>r[j].miny&&y<r[j].maxy) tot++;
        }
        for(int j=1;j<=sc;j++)    //在圆内，那么到圆心的距离一定小于半径r 
        {
            if(sqrt((x-c[j].x)*(x-c[j].x)+(y-c[j].y)*(y-c[j].y))<c[j].r) tot++;
        }
        printf("%d\n",tot);
    }
    return 0;
}
```

---

## 作者：EthanOI (赞：2)

## 前言
这道题相对来说不是很难，枚举即可
## 思路
对于每个圆，考虑圆心与该点的距离与半径的关系

可以运用勾股定理，考虑圆心与距离的关系，学过解析几何的应该都会，详情见代码

对长方形，考虑横纵坐标是否在范围内即可

具体表现为 $x$ 是否在 $(x_1$, $x_2)$ 内, $y$ 是否在 $(y_1$ ,  $y_2)$ 内

核心代码：
```cpp
for (int i = 1; i <= N; i++)
{
	if (g[i].c == 'r' && g[i].x1 < d.x && g[i].x2 > d.x && g[i].y1 < d.y && g[i].y2 > d.y) cnt++;
	if (g[i].c == 'c' && (d.x - g[i].x) * (d.x - g[i].x) + (d.y - g[i].y) * (d.y - g[i].y) < g[i].r * g[i].r) cnt++;
}
```


由于数据很小，显然不会超时

## 献上AC code：
放到[云剪贴板](https://www.luogu.com.cn/paste/5ij5jf29)上了
## 总结
珍惜生命，远离抄袭，若有棕名，后果自负

---

## 作者：foryou_ (赞：1)

本题数据范围较小，可直接采用 $O(nm)$ 的朴素算法来解决。


对于每个点 $(x,y)$，如何判断它在一个图形中呢？

- 若该图形是一个矩形 $(x1,y1,x2,y2)$，则判断 $x$ 是否未超出该矩形 $x$ 轴上的界限（即判断 $x$ 是否 $> \min(x1,x2)$ 且 $< \max(x1,x2)$），并判断 $y$ 是否未超出该矩形 $y$ 轴上的界限（即判断 $y$ 是否 $> \min(y1,y2)$ 且 $< \max(y1,y2)$），如果都成立就说明点 $(x,y)$ 在该矩形中。 

- 若该图形是一个圆形，那么只需判断点 $(x,y)$ 和圆心的距离是否大于半径，如果成立则说明点 $(x,y)$ 在该圆中。需要用到[距离公式](https://baike.baidu.com/item/%E4%B8%A4%E7%82%B9%E9%97%B4%E8%B7%9D%E7%A6%BB%E5%85%AC%E5%BC%8F/6773405)。

---

一些需要注意的地方：

- 如果你是这样存储图形的：

	```cpp
	struct node{
       char op;
   	   double x,y,z,r;
	};
	```
    那么在输入部分就需要特判一下：如果输入的是矩形，则$\texttt{x}$、$\texttt{y}$、$\texttt{z}$、$\texttt{r}$全都要输入，否则就只输入$\texttt{x}$、$\texttt{y}$、$\texttt{z}$。

- 距离公式别打错了。~~我就是在这里被卡了一个多小时~~。

- 每处理完一个点后，记得把答案清空。

---

$ \Large\texttt{CODE} $

```cpp
#include<bits/stdc++.h>
using namespace std;

struct node{
    char op;
    double x,y,z,r;
}a[531]; //定义结构体存储图形
int n,m,ans;
double dx,dy;
double dis(double X1,double Y1,double X2,double Y2){
    return sqrt((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2));
} //距离公式

int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i].op>>a[i].x>>a[i].y>>a[i].z;
        if(a[i].op=='r') cin>>a[i].r;
    } //注意读入有坑
    for(int i=1;i<=m;i++){
        cin>>dx>>dy;
        for(int j=1;j<=n;j++){
            if(a[j].op=='r'){
                if(min(a[j].x,a[j].z)<dx&&dx<max(a[j].x,a[j].z)&&min(a[j].y,a[j].r)<dy&&dy<max(a[j].y,a[j].r))
                    ans++; //若点(x,y)在矩形中，计入答案
            }
            else{
                if(dis(dx,dy,a[j].x,a[j].y)<a[j].z)
                    ans++; //若点(x,y)在圆中，也计入答案
            }
        }
        cout<<ans<<'\n';
        ans=0; //记得清空答案
    }
    return 0;
}
```

---

## 作者：int08 (赞：1)

# 前言

十分钟就过了。

这大概是我过得最快的黄题~~之一~~。

我觉得可以降橙了。

# Solution

## 1、整体思路

看了看标签“枚举，暴力”，又看了看数据范围 $N,M≤500$，我们明白了一切。

只需要一个一个判断就行了。只要判断一个的复杂度是 $O(1)$，总复杂度就是 $O(N*M)$。

## 2、判断是否在矩形内

直接看点坐标来判断是有困难的，因为他给的两个点，既可能是左下右上，也可能是左上右下。

但是我们可以知道，如果一个点在一个矩形之内，它的横坐标和纵坐标值肯定是介于两个对角点的横坐标和纵坐标值之间的。

这样我们可以提前给给出的两点的横坐标、纵坐标比大小，小的放前面，大的放后面。这样就容易比对大小，看给出的点是不是在矩形内了。

## 3、判断是否在圆形内

需要用到平面直角坐标系中两点间的距离公式 $dis=\sqrt{(x1-x2)^2+(y1-y2)^2}$。

只需要看一下给出的点和圆心的距离是否小于该圆的半径，如果小于就说明在这个圆内。

## 4、注意逝项

1、题目中有说到，“当某点在一个图形的边界上时，我们认为该点**不在**这个图形的内部”。所以在出现等于情况的时候该点是在图形的边界上，而不是内部，不记入。

2、空间绝对是够的，建议开长双精度浮点。然后直接比大小就行了，~~否则容易翻车~~。

# AC代码

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,i,j,rr,cc,ans;long double r[520][4],c[520][3],p[520][2];char a;  //当 场 表 白
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		cin>>a;
		if(a=='r')
		{
			rr++;
			cin>>r[rr][0]>>r[rr][1]>>r[rr][2]>>r[rr][3];
			if(r[rr][0]>r[rr][2]) swap(r[rr][0],r[rr][2]);
			if(r[rr][1]>r[rr][3]) swap(r[rr][1],r[rr][3]);
		}
		if(a=='c')
		{
			cc++;
			cin>>c[cc][0]>>c[cc][1]>>c[cc][2];
		}
	}
	for(i=1;i<=m;i++)
	{
		cin>>p[i][0]>>p[i][1];
	}
	for(i=1;i<=m;i++)
	{
		ans=0;
		for(j=1;j<=rr;j++)
		{
			if(p[i][0]>r[j][0]&&p[i][1]>r[j][1]&&p[i][0]<r[j][2]&&p[i][1]<r[j][3]) ans++; 
		}
		for(j=1;j<=cc;j++)
		{
			if((p[i][0]-c[j][0])*(p[i][0]-c[j][0])+(p[i][1]-c[j][1])*(p[i][1]-c[j][1])<c[j][2]*c[j][2]) ans++; 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：过往梦魇之殇 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P2313)

思路简述：

暴力枚举每个点与每个图形，复杂度$O$（$nm$）

对圆和矩形进行讨论：

$1.$ 当判断点是否在圆内时：

圆（面）的定义：到定点小于等于定长的点的点集。

由题可知：在圆的内部才算，所以该点到圆心的距离应当小于圆的半径。

又有两点$(x1,y1),(x2,y2)$间距离公式：$dis=sqrt((x1-x2)^2+(y1-y2)^2)$

不会的童鞋就构造一个$Rt$△，勾股算一下就出来了。

~~还不会就自行缅币~~

$2.$ 当判断点是否在矩形内时：

同样的，在边界的点不算。

矩形应该更好判断吧，内部点的横坐标都大于左边两顶点的横坐标，小于右边两定点的横坐标。

纵坐标亦然。

但题目中说：$x1,y1,x2,y2$，表示**该矩形的一对对角顶点的坐标**分别为$(x1,y1)$和$(x2,y2)$

无法确定是哪条对角线。所以，用“或”判断。

大致思路完毕。（真的很简单...

代码展示：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
struct node{
    char id;
    double x1,y1,r;
    double x2,y2;
}shape[510];
int n,m;
double q1,q2;
int main(){
    scanf("%d%d",&n,&m);
    for(re int i=1;i<=n;++i){
        cin>>shape[i].id;
        if(shape[i].id=='r'){
            scanf("%lf%lf%lf%lf",&shape[i].x1,&shape[i].y1,&shape[i].x2,&shape[i].y2);
        }
        else{
            scanf("%lf%lf%lf",&shape[i].x1,&shape[i].y1,&shape[i].r);
        }
    }
    for(re int i=1;i<=m;++i){
        int cnt=0;
        scanf("%lf%lf",&q1,&q2);
        for(re int j=1;j<=m;++j){
            if(shape[j].id=='c'){
                if(sqrt((q1-shape[j].x1)*(q1-shape[j].x1)+(q2-shape[j].y1)*(q2-shape[j].y1))<shape[j].r){
                    ++cnt;
                }
            }
            else{
                if((shape[j].x1<q1&&q1<shape[j].x2&&shape[j].y1<q2&&q2<shape[j].y2)||(shape[j].x1>q1&&q1>shape[j].x2&&shape[j].y1>q2&&q2>shape[j].y2)){
                    ++cnt;
                }
            }
        }
        printf("%d\n",cnt);
    }
    return 0;
}

```


完结撒花～

>$Thanks$ $For$ $Watching!$


---

## 作者：EarthGiao (赞：1)

## 【思路】

数学基础 + 枚举    

求一个点在多少个图形的里面    
很暴力的一道题目，   
看n和m的范围只有500   
所以完全可以枚举每一个点   
再去和每一个图形的范围去比较   
如果在范围内   
那就计数器累加   
如果不咋那就跳过去  
直到枚举完成每一个图形   
这个时候输出计数器     
那么这个点的任务就完成了    

上面就是总体的思路   
再来说一下细枝末节    

输入的时候怎么搞呢？   
用一个结构体储存！       
但是这有两种情况啊？！难道要开两个结构体！  
完全不需要的，你开一个结构体     
里面放着一个存字符的acioi和整形的x1,x2,y1,y2    
这样如果acioi是r那整形的四个变量都要用到    
储存两个对角顶点的坐标  
如果acioi是c那就只用到里面的三个  
x1是圆心的x坐标，y1是圆心的y坐标   
x2则是圆的半径   
注意：我这样处理仅仅是个人喜好！看起来方便！也没有多么考虑空间哪一个更优一些   

然后再说一下判断是否在某一个图形里面      
如果是矩形的话     
那只要你这个点的x和y同时满足x>x1，y>y1,,x<x2,y<y2或者同时满足x<x1,y<y1,x>x2,y>y2     
也就是这个点的坐标在其中一个点的左下方，在另一个点的左上方
如果是圆的话     
那这个就很好处理了，因为圆在每个方向上的长度都是一样的
都是半径r（结构体中即为x2）    
用两点之间距离公式求出这个点到圆心的距离    
然后和半径比较    
如果比半径小那就是在这个点的范围内   
反之则不在   

注意：要开double或者float类型!   
提示：两点之间距离等于 $\sqrt{(x1-x2)^2 + (y1 - y2) ^ 2}$ 
    
## 【完整代码】

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>

using namespace std;
const int Max = 505; 
struct node
{
	char acioi;
	double x1,y1;
	double x2,y2;
}a[Max];
 
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;++ i)
	{
		cin >> a[i].acioi;
		if(a[i].acioi == 'r')
			cin >> a[i].x1 >> a[i].y1 >> a[i].x2 >> a[i].y2;
		else
			cin >> a[i].x1 >> a[i].y1 >> a[i].x2;
	}
	double x,y;
	for(int i = 1;i <= m;++ i)
	{
		cin >> x >> y;
		int js = 0;
		for(int j = 1;j <= n;++ j)
		{
			if(a[j].acioi == 'r')
			{
				if((a[j].x1 > x && a[j].y1 > y && a[j].x2 < x && a[j].y2 < y) || (a[j].x1 < x && a[j].y1 < y && a[j].x2 > x && a[j].y2 > y) )
					js ++;
			}
			else
			{
				if( sqrt((a[j].x1 - x) * (a[j].x1 - x) + (a[j].y1 - y) * (a[j].y1 - y)) < a[j].x2)
					js ++;
			}
		}
		cout << js << endl;
	}
	return 0;
}
```

---

## 作者：plank_black (赞：0)

[原题](https://www.luogu.com.cn/problem/P2313)

## 思路

1. 读入矩形与圆。
2. 对于每个点，判断其是否在某个圆或矩形内部。（由于数据范围较小，直接枚举即可）

判断一个点是否在一个矩形内部也是很容易的，我们分为矩形与圆两个部分来考虑：

### 矩形
&emsp;&emsp;设左下的点为 $point1$，右上的点为 $point2$，我们要比较的点为 $t$。

&emsp;&emsp;当 $point1.x < t.x < point2.x$ 并且 $point1.y < t.y < point2.y$ 时点 $t$ 在此矩形内。
### 圆中
&emsp;&emsp;设圆心为 $point$，半径为 $r$，我们要比较的点为 $t$。

&emsp;&emsp;当 $dis(point, t) < r$ 时，点 $t$ 在此圆内，其中 $dis(a, b)$ 指的是 $a, b$ 两点间的笛卡尔距离。

但是有两点需要注意：

- 在边界上要判断为不在此图形内。
- 矩形的输入并没有保证两个顶点是左下与右上的两个点，所以需特殊处理。



上代码：
```cpp
#include<iostream>
#include<cmath>
using namespace std;

const int N = 510;
int n, m;
int rec_cnt, cir_cnt;

struct Rectangle {
	double x1, y1, x2, y2;
}rec[N];

struct Circle {
	double x, y, r;
}cir[N];

double get_dis(double x, double y, double _x, double _y); // 求两点的笛卡尔距离

int main( ) {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		char op;
		cin >> op;
		if(op == 'r') {
			double x1, y1, x2, y2;
			cin >> x1 >> y1 >> x2 >> y2;
			rec[++rec_cnt].x1 = min(x1, x2), rec[rec_cnt].x2 = max(x1, x2), rec[rec_cnt].y1 = min(y1, y2), rec[rec_cnt].y2 = max(y1, y2); //处理顶点
		}
		else cin >> cir[++cir_cnt].x >> cir[cir_cnt].y >> cir[cir_cnt].r;
	}
	
	for(int t = 1; t <= m; t++) {
		double x, y;
		cin >> x >> y;
		int ans = 0;
		for(int i = 1; i <= rec_cnt; i++)
			if(x > rec[i].x1 && y > rec[i].y1 && x < rec[i].x2 && y < rec[i].y2) // 判断此点是否在矩形内，注意在边界上应判为不在此矩形内
				ans++;
		
		for(int i = 1; i <= cir_cnt; i++)
			if(get_dis(x, y, cir[i].x, cir[i].y) < cir[i].r) // 判断此点是否在圆内
				ans++;
		
		cout << ans << endl;
	}
	return 0;
}

double get_dis(double x, double y, double _x, double _y) {
	return sqrt((x - _x) * (x - _x) + (y - _y) * (y - _y));
}
```


---

## 作者：Na2PtCl6 (赞：0)

## 题意简述
在一个平面上，有若干个矩形和圆，每次询问一个向量，问这个向量在多少个图形内部。

## 注意事项
- 每个矩形和坐标轴平行
- 当一个向量在某个图形的边界上时，它不在该图形内

## 分析题目
我们发现$N$和$M$都很小，可以想到一个$O(NM)$的暴力，先把每个图形存下来，然后依次对每个点判断它在多少个图形内。

对于矩形:
我们先确定边界，再进行判断。
```cpp
ex=min(rec[j].a,rec[j].c);
gx=max(rec[j].a,rec[j].c);
fy=min(rec[j].b,rec[j].d);
hy=max(rec[j].b,rec[j].d);
```
其中a,c为矩形上对角点中的x坐标；b,d为矩形上对角点的y坐标。通过确定它们，就可以求出矩形上最大、最小的x坐标和y坐标，即`gx`,`ex`,`hy`,`fy`，从而确定整个矩形。

而判断就是`qus.x>ex&&gx>qus.x&&qus.y>fy&&hy>qus.y`，其中qus是询问的向量。

对于圆：
我们直接算出圆心离该点的距离，做出判断
```cpp
point cmp;
cmp.x=cir[j].x,cmp.y=cir[j].y;
if(dis(qus,cmp)<cir[j].r)
	cnt++;
```
如果距离小于圆的半径，就符合条件的。

## 完整代码
```cpp
#include<cmath>
#include<cstdio>
#include<vector>
#include<iostream>
#define checkx qus.x>ex&&gx>qus.x
#define checky qus.y>fy&&hy>qus.y
using namespace std;
char type;
int N,M ,recs,cirs;
struct point {double x,y;} qus;
struct R {double a,b,c,d;} ;//矩形 
struct C {double x,y,r;} ;//圆 
vector < R > rec;
vector < C > cir;

const double sqr(const double &x) {return x*x;}

const double dis(const point &a,const point &b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
} 

int main(){
	cin>>N>>M ;
	for(int i=0;i<N;i++){
		cin>>type;
		if(type=='r'){
			R t;
			//输入x1,y1,x2,y2
		    cin>>t.a>>t.b>>t.c>>t.d;
		    rec.push_back(t);
		}
		else{
			C tmp;
			cin>>tmp.x>>tmp.y>>tmp.r;
			cir.push_back(tmp);
		}
	}
	recs=rec.size(),cirs=cir.size();
	for(int i=0;i<M;i++){
		int cnt=0;
		cin>>qus.x>>qus.y;
		for(int j=0;j<recs;j++){
			double ex,fy,gx,hy;
			ex=min(rec[j].a,rec[j].c);
			gx=max(rec[j].a,rec[j].c);
			fy=min(rec[j].b,rec[j].d);
			hy=max(rec[j].b,rec[j].d);
			if(checkx&&checky)
			   cnt++;
		}
		for(int j=0;j<cirs;j++){
			point cmp;
			cmp.x=cir[j].x,cmp.y=cir[j].y;
			if(dis(qus,cmp)<cir[j].r)
			    cnt++;	
		}
		printf("%d\n",cnt);
	}
	return 0;
}
```

---

## 作者：Forgotten_0114507666 (赞：0)

直接用OOP（逃

两点之间距离公式为：

$|AB|=\sqrt{(A_x-B_x)^2+(A_y-B_y)^2}$

先$ni\acute{a}n\ ti\bar{e}$一下代码：
（有点长）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
inline bool between(double up,double cur,double down){
	if(down<up){
		double t=up;up=down;down=t;
	}
	return (cur>up&&cur<down);
}
struct circle{
	double x,y,r;
};
struct rectangle{
	double x1,y1,x2,y2;
};
union sh{
	struct circle vc;
	struct rectangle vr;
};
struct shape{
	bool rect_or_crcl;
	union sh vis;
	void in(){
		char ch;
		cin>>ch;
		rect_or_crcl = (ch=='r');
		if(rect_or_crcl){
			cin>>vis.vr.x1>>vis.vr.y1>>vis.vr.x2>>vis.vr.y2;
		}
		else{
			cin>>vis.vc.x>>vis.vc.y>>vis.vc.r;
		}
	}
}shapes[501];
struct popcorn{
	double x,y;
	bool isinshape(shape s){
		if(s.rect_or_crcl){
			return(between(s.vis.vr.x1,x,s.vis.vr.x2)&&between(s.vis.vr.y1,y,s.vis.vr.y2));
		}
		else{
			double dist = sqrt((x-s.vis.vc.x)*(x-s.vis.vc.x)+(y-s.vis.vc.y)*(y-s.vis.vc.y));
			return(dist<s.vis.vc.r);
		}
	}
}popcorns[501];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		shapes[i].in();
	}
	for(int i=1;i<=m;i++){
		int cnt=0;
		cin>>popcorns[i].x>>popcorns[i].y;
		for(int j=1;j<=n;j++){
			if(popcorns[i].isinshape(shapes[j]))cnt++;
		}
		cout<<cnt<<endl;
	}
    return 0;
}
```

知识点：

[OOP](https://baike.sogou.com/v168048911.htm?fromTitle=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80)

[联合union](https://wenwen.sogou.com/z/q829242390.htm)

---

## 作者：紫妹只有17岁 (赞：0)

我以为是一道跟上次模拟赛李哥给的神仙T1然后大家都用数组就我用特判的全世界都会T1就我不会一类的神仙题(参见某年某月的USACO月赛)

然后发现N,M<500

尼玛O(n^3)<125000000

为什么不直接枚举呢?

然后这道题就变成了一道很好写的暴力水题

值得注意的是

1.~~蒟蒻wyy刚开始用struct的时候没看清题……~~

2.注意是在图形内，不能用到<=或者>=，要用<和>（别问我是怎么知道的！！！）

就这样啦

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=501;
int n,m;
struct four//为了简化结构体，four表示四边形
{
	double lx;//左边和右边两个点的坐标位置
	double ly;
	double rx;
	double ry;
}squ[N];//数组
struct two//两边形……（好像圆并不是两边形
{
	double yx;//两个圆心位置
	double yy;
	double rR;//半径
}cir[N];//数组
int tot;//总共在几个图形内
int cnf=0,cnt=0;//分别用来记录当前圆和矩形读了几个
char ch;//读入用的
double x,y;
double Dis(double x,double y,int k)//两点的欧几里得距离
{
	return (cir[k].yx-x)*(cir[k].yx-x)+(cir[k].yy-y)*(cir[k].yy-y);//这里我判的是和rR^2的关系，所以没有开根号
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)//读入的过程
	{
		scanf("%s",&ch);
		if(ch=='r')
		{
			cnf++;
			scanf("%lf%lf%lf%lf",&squ[cnf].lx,&squ[cnf].ly,&squ[cnf].rx,&squ[cnf].ry);
			if(squ[cnf].rx<squ[cnf].lx)//这里可能是我多此一举了，如果两个点第一个读入的比第二个大
			{
				swap(squ[cnf].rx,squ[cnf].lx);//那么交换他们的信息
				swap(squ[cnt].ry,squ[cnt].ly);
			}
		}
		else
		{
			cnt++;
			scanf("%lf%lf%lf",&cir[cnt].yx,&cir[cnt].yy,&cir[cnt].rR);
		}
	}
	for(int i=1;i<=m;i++)//对于每个读入的点，将其和每个矩形、圆判断就行了
	{
		tot=0;
		scanf("%lf%lf",&x,&y);
		for(int i=1;i<=cnf;i++)
		{
			if(x>squ[i].lx&&x<squ[i].rx&&y>squ[i].ly&&y<squ[i].ry)
				tot++;
		}
		for(int i=1;i<=cnt;i++)
		{
			if(Dis(x,y,i)<cir[i].rR*cir[i].rR)//同上所说
				tot++;
		}
		printf("%d\n",tot);
	}
	return 0;
}
```

---

## 作者：顾z (赞：0)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述--->[p2313 [HNOI]汤姆的游戏](https://www.luogu.org/problemnew/show/P2313)

## 分析

~~说不上是分析~~.

数据范围给出来,这题明显暴力啊emmm。

### 个人认为的坑点.

这题不要判精度,判精度会挂掉.

输入点之后,直接暴力枚举图形去判断其是否在这个图形中。

本来以为长方形给的都是 左上角和右下角.

结果**这题给的是右上角和左下角**.

搞得我取了半天$max,min$.

(代码自己看着都有点恶心.

(还是我没有看清题的说  emmm.

注意计算**点到圆心的距离的公式**是

$\sqrt{(x_i-x_j) \times (x_i-x_j) +(y_i-y_j)\times (y_i-y_j))}$

------------------代码-------------------

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#define R register 
using namespace std;
int n,m;
struct cod
{
	char shape;
	double a,b,c,d,r;
}s[508];
int main()
{
	scanf("%d%d",&n,&m);
	for(R int i=1;i<=n;i++)
	{
		cin>>s[i].shape;
		switch(s[i].shape)
		{
			case 'r':
				{
					scanf("%lf%lf%lf%lf",&s[i].a,&s[i].b,&s[i].c,&s[i].d);
					break;
				}
			case 'c':
				{
					scanf("%lf%lf%lf",&s[i].a,&s[i].b,&s[i].r);
					break;
				}
		}
	}
	for(R int i=1;i<=m;i++)
	{
		R double x,y;R int cnt=0;
		scanf("%lf%lf",&x,&y);
		for(R int j=1;j<=n;j++)
		{
			if(s[j].shape=='c')
			{
				double dis=sqrt((s[j].a-x)*(s[j].a-x)+(s[j].b-y)*(s[j].b-y));
				if(dis<s[j].r)
					cnt++;
			}
			else
			{
				if(x==s[j].a or x==s[j].c)continue;	
				if(y==s[j].b or y==s[j].d)continue;
				if(x>min(s[j].a,s[j].c) and x<max(s[j].c,s[j].a)and y<max(s[j].b,s[j].d) and y>min(s[j].d,s[j].b))
				cnt++;
			}
		}
		printf("%d\n",cnt);
	}
	
}
```

---


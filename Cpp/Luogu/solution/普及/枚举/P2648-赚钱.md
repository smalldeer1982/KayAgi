# 赚钱

## 题目背景

改编自某题


## 题目描述

zzy现在决定环游中国，顺便赚点钱。zzy在一个城市最多只能赚D元，然后他可以选择退休也就是停止赚钱，或者去其它城市工作。当然，他可以在别处工作一阵子后又回到原来的城市再赚D元。这样的往返次数是没有任何限制的。

城市间有P条单向路径连接，共有C座城市，编号从1到C。路径i从城市Ai到城市Bi，在路径行走上不用任何花费。

zzy还可以乘飞机从某个城市飞到另一个城市。共有F条单向的航线，第i条航线是从城市Ji飞到另一座城市Ki，费用是Ti元。假如zzy身上没有现钱，他可以用以后赚的钱来付机票钱。

zzy可以从任何一个城市出发开始赚钱，并且选择在任何时候、任何城市退休。现在zzy想要知道，如果在工作时间上不做限制，那么zzy共可以赚多少钱呢？如果赚的钱也不会出现限制，那么就输出orz。


## 说明/提示

对于100%的数据，1<=D<=1000，1<=P<=200，2<=C<=300，1<=F<=400。


## 样例 #1

### 输入

```
100 3 5 2
1 5
2 3
1 4
5 2 150
2 5 120```

### 输出

```
250```

# 题解

## 作者：绝顶我为峰 (赞：39)

我上来一看

这不是板子题吗？

然后又一看

最长路

## 淦。

还好有$SPFA$，我们可以把边权取相反数存边，然后跑最短路，输出时再次取相反数就是最长路啦

那么考虑边权是什么

显然，免费路边权是$d$，收费路边权是$d-w$（都要取相反数），然后为了节省时间，我们建一个超级源点，和每个点连一条权值为$d$的边（也要取相反数），然后跑一遍$SPFA$，如果有负环就输出$orz$

就是这样啦

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
using namespace std; 
struct edge
{
	int node,weight;
	edge(int node_,int weight_):
		node(node_),weight(weight_){}
};
vector<edge> v[301];
int d,p,c,f,r[301],dis[301];
bool vis[301];
inline bool SPFA()//板子
{
	memset(dis,127/3,sizeof(dis));
	queue<int> q;
	q.push(0);
	dis[0]=0;
	vis[0]=1;
	while(!q.empty())
	{
		int k=q.front();
		q.pop();
		vis[k]=0;
		++r[k];
		if(r[k]>c)
			return 1;
		for(vector<edge>::iterator it=v[k].begin();it!=v[k].end();++it)
			if(dis[it->node]>dis[k]+it->weight)
			{
				dis[it->node]=dis[k]+it->weight;
				//cout<<it->node<<" "<<dis[it->node]<<endl;
				if(!vis[it->node])
				{
					vis[it->node]=1;
					q.push(it->node);
				}
			}
	}
	return 0;
}
int main()
{
	cin>>d>>p>>c>>f;
	while(p--)
	{
		int x,y;
		cin>>x>>y;
		v[x].push_back(edge(y,-d));//免费边
	}
	while(f--)
	{
		int x,y,w;
		cin>>x>>y>>w;
		v[x].push_back(edge(y,w-d));//收费边
	}
	for(int i=1;i<=c;++i)
		v[0].push_back(edge(i,-d));//和源点连边
	if(SPFA())
		cout<<"orz\n";//有负环
	else
	{
		int ans=0;
		for(int i=1;i<=c;++i)
			ans=min(ans,dis[i]);//统计
		cout<<-ans<<endl;//再用相反数输出
	}
	return 0;
}
```


---

## 作者：Created_equal1 (赞：31)

首先添加一个超级源，然后从超级源开始跑一遍SPFA求最长路并且判正权环即可。

实际上这题数据特别水，暴力地从每个点出发都跑一遍SPFA也可以通过所有测试点。


---

## 作者：JohnJoeZhu (赞：12)

### 一道 ~~简（sha）单（bi）~~ 模板题

首先，分析在什么情况下**orz**~~（你就是orz）~~

因为有免费的路，又有可以有钱再交钱的飞机，所以只要出现环就orz了

那么用什么判环呢？————**SPFA！**（其实也就这样了）

然后，我们考虑如何求解

既然要用SPFA，那么就要考虑边权与源点的设定

设边权为花费的值

如果每次到达一个城市，就一定赚d元，那么每次松弛的时候就+d再-边权，取大值，源点初始化为d

或者，将免费边的边权设为-d，其余的设为w-d，那么每次就取小值，源点初始化为0

鉴于数据实在是太水而我还T了一个点，所以得出两种设置源点的方法

可以每个点都设置为源点，SPFA一遍，记录最大收益值

或者建立一个超级源点，只要SPFA一遍

#### 代码

以下代码采用超级源点+负边权（-d的那种）（90分）
~~~cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct Edge{
	int v,w,nex;
}edge[610];//邻接表
int head[310],top=0;
int d,p,c,f,dis[310],in[310];
bool vis[310];
void add(int u,int v,int w)
{
	edge[++top].v=v;
	edge[top].w=w;
	edge[top].nex=head[u];
	head[u]=top;
}
bool SPFA()//板子
{
	memset(dis,127/3,sizeof(dis));
	queue<int>q;
	q.push(0);
	dis[0]=0;
	vis[0]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		in[u]++;
		if(in[u]>c+1) return 1;//判环
		for(int i=head[u];i;i=edge[i].nex)
		{
			int v=edge[i].v;
			if(dis[v]>dis[u]+edge[i].w)
			{
				dis[v]=dis[u]+edge[i].w;
				if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return 0;
}
int main()
{
	scanf("%d%d%d%d",&d,&p,&c,&f);
	int u,v,w;
	for(int i=1;i<=p;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v,-d);
	}
	for(int i=1;i<=f;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w-d);
	}
	for(int i=1;i<=c;i++) add(0,i,-d);
	if(SPFA()) printf("orz");
	else 
	{
		int ans=0;
		for(int i=1;i<=c;i++) ans=min(ans,dis[i]);
		printf("%d",-ans);
	}
	return 0;
}
~~~

以下采用每个点都SPFA一遍+正边权（免费边用0的那种）（AC）
~~~cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
struct Edge{
	int v,w,nex;
}edge[610];
int head[310],top=0;
int d,p,c,f,dis[310],in[310];
bool vis[310];
void add(int u,int v,int w)
{
	edge[++top].v=v;
	edge[top].w=w;
	edge[top].nex=head[u];
	head[u]=top;
}
bool SPFA(int x)
{
	memset(in,0,sizeof(in));
	memset(vis,0,sizeof(vis));
	memset(dis,-1e9,sizeof(dis));
	queue<int>q;
	q.push(x);
	dis[x]=d;
	vis[x]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		in[u]++;
		if(in[u]>c) return 1;
		for(int i=head[u];i;i=edge[i].nex)
		{
			int v=edge[i].v;
			if(dis[v]<dis[u]-edge[i].w+d)
			{
				dis[v]=dis[u]-edge[i].w+d;
				if(!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return 0;
}
int main()
{
	int ans=0;
	scanf("%d%d%d%d",&d,&p,&c,&f);
	int u,v,w;
	for(int i=1;i<=p;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v,0);
	}
	for(int i=1;i<=f;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	for(int i=1;i<=c;i++)
	{
		if(SPFA(i))//每个点都搞一次
		{
			printf("orz");
			return 0;
		}
		for(int j=1;j<=c;j++) ans=max(ans,dis[j]);
	}
	printf("%d",ans);
	return 0;
}
~~~

---

## 作者：ghj1222 (赞：7)

```
#include <bits/stdc++.h>
using namespace std;

int D, P, C, F;
int g[310][310], d[310], v[310], cnt[310];

void Floyed()
{
	for (int k = 1; k <= C; k++)
		for (int i = 1; i <= C; i++)
			for (int j = 1; j <= C; j++)
				g[i][j] = max(g[i][j], g[i][k] + g[k][j]);
}

int Find()
{
	int ans = 0xc0c0c0c0;
	for (int i = 1; i <= C; i++)
		for (int j = 1; j <= C; j++)
			ans = max(ans, g[i][j]);
	return ans;
}

int main()
{
	scanf("%d%d%d%d", &D, &P, &C, &F);
	memset(g, 0xc0, sizeof(g));
	for (int x, y, i = 1; i <= P; i++)
	{
		scanf("%d%d", &x, &y);
		g[x][y] = D;
	}
	for (int x, y, z, i = 1; i <= F; i++)
	{
		scanf("%d%d%d", &x, &y, &z);
		g[x][y] = D - z;
	}
	Floyed();
	int ans = Find();
	Floyed();
	int ans2 = Find();
	if (ans != ans2)
		puts("orz");
	else
		printf("%d\n", ans + D);
	return 0;
}
/*
简化版题目大意：
给定一个有向图，点有点权(每个点点权都一样)，有的边有负边权，有的边有0边权
判断是否存在正环，如果没有就输出图中最长路
--------------------------------------
由于一条路径的点数等于边数+1
把边权加等点权，最后答案加等于一个d
先跑一遍Floyed找最长路
再来一遍，如果两次最长路值不一样那么就有正环。
*/
```

---

## 作者：loi_ys (赞：3)

## 正如出题人所说 ~~数据真的很水~~
每一个点都跑一遍spfa

接下来就是~~板子~~了
废话不多说，上代码
# ~~一条华丽的分割线~~


------------


code：
------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define inf -1e9
#define maxn 2001
using namespace std;
int num,d,m1,n,m2,f,g,w,ans=-1; 
struct node
{
	int next,to,dis;
}edge[maxn];
int head[maxn],dis[maxn],vis[maxn],du[maxn];
queue <int> q;//stl标准队列 
void add(int from,int to,int dis)//链式前向星存边 
{
	edge[++num].next=head[from];
	edge[num].to=to;
	edge[num].dis=dis;
	head[from]=num;
}
inline void spfa(int x)//板子 
{
	memset(dis,inf,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(du,0,sizeof(du));
	q.push(x);
	dis[x]=d;//开始时d不是0！！ 
	vis[x]=1;
	while(!q.empty())
	{
		int u=q.front();
		vis[u]=0;
		q.pop();
		for(int i=head[u];i;i=edge[i].next)//邻接表遍历 
		{
			int v=edge[i].to;
			if(dis[v]<dis[u]-edge[i].dis+d)
			{
				dis[v]=dis[u]-edge[i].dis+d;
				du[v]++;
				if(du[v]>n)//判正环 
				{
					cout<<"orz"<<endl;
					exit(0);//直接结束程序的玄学东东 
				}
				if(vis[v]==0)
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,dis[i]);
	}
}
int main()
{
	ios::sync_with_stdio(false);//可以加快cin 
	cin>>d>>m1>>n>>m2;//输入不解释 
	for(int i=1;i<=m1;i++)
	{
		cin>>f>>g;
		add(f,g,0);
	}
	for(int i=1;i<=m2;i++)
	{
		cin>>f>>g>>w;
		add(f,g,w);
	}
	for(int i=1;i<=n;i++)
	{
		spfa(i);
	}
	cout<<ans<<endl;
	return 0;
}
```

#  **  _~~完美结束~~_** 

---

## 作者：顾z (赞：2)

题目描述--->[p2648 赚钱](https://www.luogu.org/problemnew/show/P2648)

分析就不讲了 qwq

之前  Created_equal1 大佬orz已经讲过了,只是来放一下加了超级源的代码

**需要注意的一点**

与暴力的不同的是,$dis[s]=0$

(即超级源处无城市,我们不能打工赚钱

ps:$dis[i]$的定义是到达i能赚的钱.

因此我们的$ans$要取$max$

$24ms$

-----------------代码------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
#define N 666
using namespace std;
IL void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int head[N],tot,s,dis[N],cnt[N];
bool vis[N];
int n,m,f,D,ans;
struct cod{int u,v,w;}edge[N];
IL void add(int x,int y,int z)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	edge[tot].w=z;
	head[x]=tot;
}
IL bool spfa(int s)
{
	vis[s]=true;dis[s]=0;cnt[s]=0;
	queue<int>q;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();vis[u]=false;
		if(cnt[u]>n+1)return true;
		for(RI i=head[u];i;i=edge[i].u)
		{
			if(dis[edge[i].v]<dis[u]-edge[i].w+D)
			{
				dis[edge[i].v]=dis[u]-edge[i].w+D;
				if(cnt[edge[i].v]>n+1)return true;
				if(!vis[edge[i].v])
				{
					vis[edge[i].v]=true;
					cnt[edge[i].v]++;
					q.push(edge[i].v);
				}
			}
		}
	}
	for(RI i=1;i<=n;i++)
		ans=max(ans,dis[i]);
	return false;
}
int main()
{
	in(D),in(m),in(n),in(f);s=n+1;
	for(RI i=1,a,b;i<=m;i++)
	{
		in(a),in(b);
		add(a,b,0);
	}
	for(RI i=1,a,b,c;i<=f;i++)
	{
		in(a),in(b),in(c);
		add(a,b,c);
	}
	for(RI i=1;i<=n;i++)add(s,i,0),dis[i]=-2147483647;
	if(spfa(s)) puts("orz");
	else printf("%d",ans);
}
```

---


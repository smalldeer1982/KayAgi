# 纪念邮票

## 题目描述

邮局最近推出了一套纪念邮票，这套邮票共有 $N$ 张，邮票面值各不相同，按编号顺序为 $1$ 分，$2$ 分，……，$N$ 分。

小明是个集邮爱好者，他很喜欢这套邮票，可惜现在他身上只有 $M$ 分，并不够把全套都买下，但是他希望刚好花光所有的钱。作为一个集邮爱好者，小明也不想买的邮票编号断断续续，所以小明打算买面值 $a$ 分至 $b$ 分的 $b-a+1$ 张连续的邮票，且总价值刚好为 $M$ 分。

你的任务是求出所有符合要求的方案，以 $\left[a,b\right]$ 的形式输出。

## 样例 #1

### 输入

```
20 15```

### 输出

```
[1,5]
[4,6]
[7,8]
[15,15]```

# 题解

## 作者：佑月之星 (赞：16)

咳咳，某蒟蒻第二次发题解

第一次看这题内心OS：

哇哦，好水哦 ~~又能混一道黄题了~~

于是噼里啪啦三重循环

### 然后 ~~原地~~ 爆炸 

深思熟虑后改了双重循环

### 照样爆炸

仔细看了看题：10^9

当场吐血身亡

（一开始看成109）

~~被老师要求~~拿出纸和笔

开始写：

a是第一个数，b是最后一个数，len为长度

（a+b）* len / 2 = m     (公式）

然鹅介里有两个变量，就意味着要两重循环

所以开始启动我们的 数 学 模 式

(咳咳，敲黑板）

```
因为len=b-a+1
所以b=len+a-1
那么式子就变成了（a+a+len-1)*len/2=m
然后移项 2a+len-1=2m/len
2a=2m/len-len+1
a=(2m/len-len+1)/2
```
那么，我们只要枚举len就好啦ヾ(◍°∇°◍)ﾉﾞ

代码：

```
#include<bits/stdc++.h>
using namespace std;
int m,n;
int main()
{
	cin>>n>>m;
	for(int i=n;i>=1;i--)
	{
    	        //当式子中的数不是整数或超出范围，就continue掉
		if((2*m)%i!=0)continue;
		if(((2*m/i)-i+1)%2!=0)continue;//不是整数
        
		int a=((2*m/i)-i+1)/2;
        
		if(a<1)continue;
		if(a+i-1>n)continue;//超出范围
		cout<<"["<<a<<","<<a+i-1<<"]"<<endl;
	}	
	return 0;	
}
```
兴高采烈的交上去(ﾉﾟ▽ﾟ)ﾉ

三个点TLE !!!∑(ﾟДﾟノ)ノ  

_(:ι」∠)_心态爆炸

只好去问大佬

得出：查找范围应该在 2m½ 范围内（根号打不出来QAQ随意吧）

最终代码 ：



------------


### ↑↑↑ i=n改成i=sqrt（2*m）就好了 

（你以为我会给你直接抄的机会吗哈哈哈不可能的）

(o°ω°o)管理员大大求过




---

## 作者：SqrtSecond (赞：7)

一看数据范围$m,n≤10^9$，就知道不能用$O(n)$或$O(m)$做

所以顶多只能用$O(\sqrt{m})$或$O(\sqrt{n})$的算法



------------

# 简要分析

给定$n$和$m$，求末项不大于$n$的非负等差数列，使其公差为$1$，和为$m$。

小学知识，易知$m=$首项末项之和$\times$项数$\div$2

所以先把$m$乘上$2$

于是可以知道首项末项之和与项数之积为$m$。

设首项末项之和为$sum$，项数为$t$

从公差为$1$可知$sum>t$

不妨依次枚举$t$

由于要从小到大输出，所以$t$要从大到小枚举

当$t\mid m$时，就能知道$sum$了

且首项末项之差就是$t-1$

则由基本的和差问题可知，首项为$\frac{sum+t-1}{2}$，末项为$\frac{sum-t+1}{2}$

证毕，上14行简洁代码：

```cpp
#include<bits/stdc++.h>
int n,m,sum;
int main()
{
	scanf("%d%d",&n,&m);
	m*=2;//提前乘2 
	for(int i=sqrt(m);i;--i)
	{
		if(m%i)continue;//判断是否整除 
		sum=m/i;//首项末项之和 
		if((sum-i+1)&1||(sum+i-1)/2>n)continue; //判断答案是否合规范 
		printf("[%d,%d]\n",(sum-i+1)/2,(sum+i-1)/2);//输出答案 
	}
	return 0;//华丽结束 
}
```
~~写完了，我溜了~~


---

## 作者：Register (赞：6)

### 题意描述
按$l$值从小到大输出所有$1\le l\le r\le n$且$\sum_{i=l}^{r}i=m$的```[l,r]```
### 解题思路
设$a=l,i=r-l+1$，即首项与项数

$\sum_{i=l}^{r}i$即$m$可表示为$\frac{i\times(2a+i-1)}{2}$

所以，$2m=i\times(2a+i-1)$

可以看出$i$是$2m$的因数且$i<2a+i-1$则$i<\sqrt{2m}$

我们可以从小到大枚举小于$\sqrt{2m}$的$i$判断是否整除，并判断$2a$是否是偶数

如果成立的话，可以储存首项$a$和末项$a+i-1$，最后倒序输出（我们从小到大枚举的是$i$，项数越少即$l$越大）

代码实现上有问题请参考代码
### 代码
```cpp
#include <cstdio>
int n,m,ans,a[100000],b[100000];
inline int read(){
	char ch=getchar();int res=0,w=1;
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}
	return res*w;
}
int main(){
	n=read();m=read()<<1;
	for(register int i=1;i*i<m;i++)
		if(m%i==0&&((m/i-i)&1)&&(m/i-i+1)/2+i-1<=n) {a[++ans]=(m/i-i+1)/2;b[ans]=a[ans]+i-1;}
	while(ans--) printf("[%d,%d]\n",a[ans+1],b[ans+1]);
	return 0;
}
```

---

## 作者：Saber_Master (赞：6)


~~蒟蒻又来发题解了！！！~~

~~这题最耀眼的颜色就是TLE~~

~~ _为此推了n套公式，终于找到一套常数级的了????_ ~~

下面推导公式：

------------


------------
把一个数sum分成一段连续正整数(a,a+1,a+2,a+...)的和，首先来看：

分成一段：sum=a;

分成两段：sum=a+a+1=2a+1；

分成三段：sum=a+a+1+a+2=3a+3；

.........

分成n段：sum=a+a+1+a+2+...+a+n-1=n×a+n(n-1)/2;

化简得    a=(sum-n(n-1)/2)/n

所以枚举1到n,再验证答案，问题就解决了，下面附上AC代码

------------


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans[1000][2],h=0,wa=0;//ans[i][0]记录区间下界，ans[i][1]记录区间长度，故区间上界为ans[i][0]+ans[i][1]-1;
int main(){
	long long n,m;
	cin>>n>>m;
	long long a,i=0;
	while(1){
    //枚举区间长
		i++;
		a=(m-i*(i-1)/2)/i;
		if(i*a+(i*(i-1))/2==m&&a!=0) {
			h++;
			ans[h][0]=a;
			ans[h][1]=i;
		}
//	若段数过多，跳出循环	if(i*a+(i*(i-1))/2>m) break;
	}
for(long long i=h;i>=1;i--){
	if(ans[i][0]>n||ans[i][0]+ans[i][1]-1>n) return 0;
	printf("[%lld,%lld]\n",ans[i][0],ans[i][0]+ans[i][1]-1);
}	
}
```


---

## 作者：Yujinhe469 (赞：3)

题意：求 $[1,n]$ 范围内的等差数列，和为 $m$ ，公差为 $1$ 。

$$m=\sum_{i=a}^{b}i$$

$m=(a+b)(b-a+1)/2$

$2m=(a+b)(b-a+1)$

枚举 $2m$ 的两个对应的因数。

看数据范围： $ 1≤N,M≤10^9 $ 

$O(N)$ 或者 $O(M)$ 的算法是无法 $AC$ 的。

也就是说不能暴力枚举不超过 $2m$ 的所有正整数。

只需枚举不超过 $\sqrt{2m}$ 的所有正整数。（对于超过 $\sqrt{2m}$ 的正整数 $k$ ， ${\color{blue} \frac{2m}{k}}$ 会被枚举到）

令 $x=a+b,y=b-a+1$

得 $a=\frac{x-y+1}{2},b=\frac{x-y+1}{2}$

注意这里的 $a$ 和 $b$ 都是正整数。

**AC代码如下：**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,m;
int main(){
	cin>>n>>m;
	m*=2;
	for(ll y=sqrt(m);y>=1;y--){
		if(m%y!=0) continue;
		ll x=m/y;
		if((x-y+1)%2==1) continue;
		ll a=(x-y+1)/2,b=(x+y-1)/2;
		if(a<1||a>n||b<1||b>n) continue;
		cout<<"["<<a<<","<<b<<"]"<<endl;
	}
	return 0;
}
```
~~注：不开longlong见祖宗~~

---

## 作者：lllmmmxxx (赞：1)

# 题目分析
本题因为求区间和，所以可以用两个数记录区间的头和尾，并用一个数数记录他的区间和。
# 代码
代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
   std::ios::sync_with_stdio(false);
	std::cin.tie(0); //使时间更快
   int n , m , h=1 , t=1 , qjh=1;//w是记录区间尾，t是区间头，qjh就是区间和
	scanf("%d%d",&n,&m);
	while(h <= n){
		if(qjh > m) //判断是否大于总价值
			qjh-=h , h++; //将区间和减少区间尾，继续向前走
		else{
        	       if(qjh == m) cout << "[" << h << "," << t <<"]" << endl;//如果区间和等于总价值,就输出
			t++ , qjh+=t; //头往前，区间和加头
		}
	}
	return 0;//完美的结尾
}
```


可惜此代码必须要开 O2 ，望管理员通过

---

## 作者：SIGSEGV (赞：1)

这题数据千万别看错，是10e9，不是109！

我们可以枚举这个数列（邮票序列）的长度，然后判断该长度是否有可行解。若有，则输出。

具体看代码注释
贴上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,len;
int main ()
{
	scanf("%d%d",&n,&m);
	len = sqrt(2 * m) + 10;
	while ((1 + len) * len / 2 >= m) --len;
	++len;//会多减
	for (int i = len;i > 0;i--)
	{
		if (i % 2) //分奇数偶数讨论
		{
			int mid = m / i;//对于长（项数）为奇数：如果确实存在这个总和为m等差数列的话，
            //那么mid是它中间的数
			if (mid * i != m) continue;//数列存在吗？？？
			int le = mid - i / 2,ri = mid + i / 2;//计算左右值
			if (le < 0 || ri > n) continue;//千万别超限
			printf("[%d,%d]\n",le,ri);
		}
		else
		{
			int mid = m / i;//对于项数为偶数：mid，mid + 1为数列中间两个数
			if ((m / i * 2 + 1) * (i / 2) != m) continue;//判断
			int le = mid - i / 2 + 1,ri = mid + i / 2;//同上
			if (le < 0 || ri > n) continue;
			printf("[%d,%d]\n",le,ri);
		}
	}
	return 0;
}
```
最后，它是怎么做到按a的顺序输出的呢？

关键点就在于循环！

---

## 作者：_Luminous (赞：1)

### · 题意

------------

求1 ~ n个数中哪些区间满足：**区间内数字相加**的**和为m**

### · 解题思路 & 方法


------------

算法 ： 穷举 ~~（暴力）~~

- 方法一 ：真 · 穷举 + 数学公式

由题目中 “ 面值a分至b分的b-a+1张连续的邮票 ” ，很容易就联想到一个熟悉的数学公式——**高斯求和公式**
```
(a+b)*(b-a+1)/2=m
```
令 v = a + b , u = b - a + 1

则 v * u=2 * m,v > u，

所以穷举u从sqrt( 2*m)到1即可。

另，u和v奇偶性不同。

#### · Code

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int n,m;
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
    for(int u=int(sqrt(2.0*m));u>=1;u--)
        if(2*m%u==0 && (2*m/u+u)%2==1){
            int v=2*m/u,a=(v-u+1)/2,b=(u+v-1)/2;
            if(a<=n && b<=n)
            	cout<<"["<<a<<","<<b<<"]"<<endl;
        }
    return 0;
}
```
时间复杂度：O(log 2m)

- 方法二 ： 回滚法 ~~（垃圾取名）~~

在说这个方法之前，先说明一下：这个方法是**不能过**的（不开O2优化4个点**超时**，开O2优化2个点超时），在这里提及是为了扩展更多的思路，如果对此不感兴趣，完全可以跳过这个部分。

首先定义两个变量 l 和 r （类似于指针），均赋值为1，意为：当前这个区间的左端点为 l ，右端点为 r 。

然后用变量sum依次加上区间[l , r]里所有元素的值，如果sum依旧小于m，则右端点++（向后滚动，扩大区间范围），sum加上当前r的值（因为第r个数字就是r）；若sum大于m，则sum减去当前l的值，左端点++（这里要注意左右端点及sum的加减**顺序**）；若sum等于m，说明找到一组解，直接输出l和r，右端点继续++，sum加上r的值（否则等到下一次循环，sum会一直等于m，所以要提前处理好）。

#### · Code

```cpp
#include <iostream>
using namespace std;
int n,m;
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	int l=1,r=1,sum=1;
	while(r<=n)
		if(sum<m)
			r++,sum+=r;
		else if(sum>m)
			sum-=l,l++;
		else{
			cout<<"["<<l<<","<<r<<"]"<<endl;
			r++,sum+=r;
		}
	return 0;
}
```

时间复杂度：O(n)

---

## 作者：荣耀南冥 (赞：0)

# 一定注意不要答案越界
[题目传送门](https://www.luogu.com.cn/problem/P3910)

题其实考察了等差数列求和公式，然后就没了，对就是这么简单。其他题解都说了等差数列了，我就不赘述了，等差数列求和公式如下:

$$S_n=na_1+\frac{n\times (n-1)}{2}\times d$$

题中求得是连续区间和，所以$d =1$ 可忽略。$ S_n $就是 m 。大家都知道 n 最大就是 $\sqrt{2\times n}$  ~~（不会真的有人不知道吧）~~ 所以枚举区间长度，移项后 

$$ a_1=\frac{(S_n-\frac{n\times (n-1)}{2})}{n} $$

这样就求出了 $a_1$ （代码中为beg），$a_1 + n -1$ 就是 end 。
最后按格式输出beg和end即可。枚举n的时候一定从 $\sqrt{2\times n}$  开始枚举。不然最后结果是倒着的。

$Code$
```c++
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;
long long n,m,k;
long long beg,end;
int main(){
	cin>>n>>m;
	k=sqrt(2*m)+10;//计算最大长度
	for(int i=k;i>=1;--i){//枚举区间
		beg=(m-i*(i-1)/2)/i;
		if(beg*i+i*(i-1)/2==m&&beg>=1&&beg<=n&&beg+i-1<=n)//判断区间是否合法
			printf("[%lld,%lld]\n",beg,beg+i-1);//输出结果，注意记得-1
	}
	return 0;
}//虽然end没有用，但仍是一个完美的结局
```

---


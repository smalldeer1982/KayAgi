# [Code+#4] 喵呜

## 题目描述

在马路边有一排整齐的 $n$ 棵樱花树，每棵树的高度都恰好为 $h$。某天，一只可爱的小猫偶然跑到树上来玩，但是这只小猫有些对樱花过敏，所以她现在想赶快离开这些樱花树。

具体来说，现在小猫位于第 $x$ 棵樱花树上高度为 $y$ 的位置，她可以通过两种跳跃来离开樱花树：

轻轻跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度下降 $b$，即一次轻轻跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y-b$ 的位置，注意当小猫所在高度不大于 $b$ 时不可以使用轻轻跳。

使劲跳：向左或向右移动 $a$ 棵樱花树的同时，所在高度上升 $b$，即一次使劲跳可以从起点移动到第 $x+a$ 或 $x-a$ 棵树上高度为 $y+b$ 的位置，注意当小猫所在高度大于 $h-b$ 时不可以使用使劲跳。

为了离开这片樱花树，小猫需要移动到第 $1$ 或第 $n$ 棵树上，高度为 $h$ 或 $1$ 的位置（这样她可以呼吸新鲜空气或者直接走开樱花树）。现在小猫想知道，自己最少需要多少次跳跃才能达成目标。由于她是一只可爱的小猫，所以希望由你来告诉她。


## 说明/提示

| 测试点编号 | $n,h$ 的范围 | 特殊约定 |
| :----------: | :----------: | :----------: |
|$1,2$  | $\le10$ | $b=1$ |
|$3,4$  |  $\le10$| $a=b=1$ |
|$5,6,7,8$  |$\le10$  | 无 |
|$9,10$  | $\le500$ | $b=1$ |
|  $11,12$| $\le500$ | $a=b=1$ |
|$13,14,15$  | $\le500$ | 无 |
|$16,17$  | $\le10^5$ | $h\le10$ |
|$18,19,20$  | $\le10^5$ | 无 |
| $21,22$ | $\le10^{15}$ | $h\le10$ |
| $23,24,25$ | $\le10^{15}$ | 无 |

对于所有数据，保证 $n \geq 2$，$a < n$，$b \leq h$。

Credit: https://www.luogu.org/discuss/show/38908

## 样例 #1

### 输入

```
3
5 5 3 3 2 2
5 7 3 5 2 2
5 7 4 6 1 1```

### 输出

```
1
1
1```

## 样例 #2

### 输入

```
3
5 5 3 3 3 2
5 7 1 4 2 2
5 7 1 2 1 2```

### 输出

```
-1
-1
-1```

## 样例 #3

### 输入

```
4
999999999999 999999999999 454545454545 454545454545 1 1
777777777777 777777777777 343434343434 343434343434 1 1
777777777777 999999999999 343434343434 454545454545 1 1
999999999999 777777777777 454545454545 343434343434 1 1```

### 输出

```
454545454544
343434343433
-1
-1```

# 题解

## 作者：Rosemary_dream (赞：9)

说难也难，说易也易。

###### ~~话说，审了这么多次，都是 $\LaTeX$ 的问题，能不能**确切的**指明到底是哪里的错误啊……求求了~~

从“**模拟**”题签里抽出来的，当然需要模拟，但这题还有一点**数学**的成分。

题目说：

>在一个平面直角坐标系中，给出一个坐标。
>
>从坐标处走到 $(1,1)$ 或 $(n,1)$ 或 $(1,n)$ 或 $(n,n)$ 处的最短路径所需步数是多少，如果走不到，输出 -1 。

题一看就很奇妙，因为不是一个一个点移动，而是移动 $a,b$ 这样的点数，那么第一个问题就是如何确定走的方向（样例1第一组数据）：

![](https://cdn.luogu.com.cn/upload/image_hosting/xh15sccs.png)

这样看的话~~什么也看不出来~~，我们要想确定一个行走的最短路径，首先必须**保证它行得通。**

那么根据行走的**特性**，我们仔细想想。

先看一个化简后的问题：

![](https://cdn.luogu.com.cn/upload/image_hosting/q06j94jp.png)

一次走两格，向哪里走能走出去？

不难看出是向右走，那么规模再大一点呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/x34v3poc.png)

右边有十一个格子，左边有六个格子，明显这一次必须要向左走了。

那么，从上面的例子中可以得出，向那边走出去，那边的距离就一定要可以被步数距离**整除（余数为零）。**

得到了这个，确定方向就不难了：

Code1:

```cpp
(!(R%a))?m[0][0]=x/a:m[0][0]=-1;//向右能走吗？能走顺便存一下步数。
(!(x%a))?m[0][1]=R/a:m[0][1]=-1;//向左能走吗？能走顺便存一下步数。
(!(U%b))?m[1][0]=y/b:m[1][0]=-1;//向上能走吗？能走顺便存一下步数。
(!(y%b))?m[1][1]=U/b:m[1][1]=-1;//向下能走吗？能走顺便存一下步数。
```
if 版：

```cpp
if(R%a==0) m[0][0]=R/a;
else m[0][0]=-1;
if(x%a==0) m[0][0]=x/a;
else m[0][0]=-1;
if(U%a==0) m[0][0]=U/a;
else m[0][0]=-1;
if(y%a==0) m[0][0]=y/a;
else m[0][0]=-1;
```

以例子为例，计算后的数组长这样：

```cpp
m[0][0]=1;//向右1步
m[0][1]=1;//向左1步
m[1][0]=1;//向上1步
m[1][1]=1;//向下1步
```


那么确定了方向，还要**确定步数。**

这其实是一个难点，~~想通了也不难~~ 。

因为猫猫是同时向**两个**方向走，所以要解决**两个**问题。

~~然而没有必然联系。~~

以下默认  $(a=2,b=1)$ 

第一个：

>我到了你没到.jpg

![](https://cdn.luogu.com.cn/upload/image_hosting/ngm6mmln.png)

尴尬了,我还没到第一颗树……~~所以为什么我不能走开~~

怎么办？

**我等你一下，我先回去**

![](https://cdn.luogu.com.cn/upload/image_hosting/bylmda5p.png)

于是问题解决了

问题二：

> 我到了你却到不了

![](https://cdn.luogu.com.cn/upload/image_hosting/tcy54jo4.png)

### 到不了？

我们不是**计算了**能不能到了吗？

事实上，这里的“到不了”说的是“**不能同时到**”。

明显看出，这边无论怎么绕，也绕不出这个圈子。

上面那个例子为什么能绕出去？

因为向左的步数给了向下的步数**两个回合**的斡旋时间。

向上走一次向下走一次相当于坐标没有变，所以**如果想保持在某条与 $x$ 轴或 $y$ 轴平行的的直线上移动,两种移动的步数差定为偶数!**

根据这一点,我们就可以~~理~~感性地写出一份模拟四个方向的代码:

Code2:

```cpp
for(register int i=0;i<=1;i++){
		for(register int j=0;j<=1;j++){
			if((~m[0][i])&&(~m[1][j])&&(m[1][j]-m[0][i])%2==0){
				ll temp=max(m[1][j],m[0][i]);
				if(ans>temp||!(~ans)) ans=temp;
			}
		}
	}
```


硬性模拟版:

```cpp
if((~m[0][0])&&(~m[1][0])&&(m[0][0]-m[1][0])%2==0){
	ll temp=max(m[0][0],m[1][0]);
	if(ans>temp||!(~ans)) ans=temp;
}
if((~m[0][0])&&(~m[1][1])&&(m[0][0]-m[1][1])%2==0){
	ll temp=max(m[0][0],m[1][1]);
	if(ans>temp||!(~ans)) ans=temp;
}
if((~m[0][1])&&(~m[1][0])&&(m[0][1]-m[1][0])%2==0){
	ll temp=max(m[0][1],m[1][0]);
	if(ans>temp||!(~ans)) ans=temp;
}
if((~m[0][1])&&(~m[1][1])&&(m[0][1]-m[1][1])%2==0){
	ll temp=max(m[0][1],m[1][1]);
	if(ans>temp||!(~ans)) ans=temp;
}
```


#### tips:

```cpp
// ~ 运算符其实等同于！=-1
```
那么综合~~核~~一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	long long num;char c;
	bool flag=false;
	while((c=getchar())=='\n'||c=='\r'||c==' ');
	c=='-'?flag=true:num=c^48;
	while(isdigit(c=getchar())){
		num=(num<<3)+(num<<1)+(c^48);
	}
	return (flag?-1:1)*num;
}
ll T,n,h,x,y,a,b;
ll U,R,l,r;
ll m[2][2];
void check(ll ans){
	for(register int i=0;i<=1;i++){
		for(register int j=0;j<=1;j++){
			if((~m[0][i])&&(~m[1][j])&&(m[1][j]-m[0][i])%2==0){
				ll temp=max(m[1][j],m[0][i]);
				if(ans>temp||!(~ans)) ans=temp;
			}
		}
	}
	printf("%lld\n",ans);
}
int main()
{
	T=read();
	while(T--){
		n=read(),h=read(),x=read(),y=read();
		a=read(),b=read();
		R=n-x,U=h-y;x--,y--;
		(!(x%a))?m[0][0]=x/a:m[0][0]=-1;
		(!(R%a))?m[0][1]=R/a:m[0][1]=-1;
		(!(y%b))?m[1][0]=y/b:m[1][0]=-1;
		(!(U%b))?m[1][1]=U/b:m[1][1]=-1;
		check(-1);
	}
	return 0;
}
```
完结撒花~

---

## 作者：3_soon (赞：4)

# 一道有点是数论的题
##### ~~那怎么做呢？~~


------------

## 思路一：暴力
首先，四种情况（树数->）2* (高度->)2=4

模拟去做一遍 ~~（一定会TLE）~~


------------

## 思路二：数学分析
### 先建系

从（x,y）直接只走x轴或只走y轴可以O(1)求出，那么不妨理解为四种走法：

1.x+a; 2.x-a; 3.y+b; 4.y-b;

先用p 存四种走法直接跳的步数(要求整数步跳到，即为其倍数)

乱搞一下，不难发现：如果要其中一个坐标等待另一个跳过来，那它只能后退再回来，也就是停在原地。

### 画一下，发现跳的次数必为2的倍数！！！（最重要的一点）

只要判断两个轴上的两种走法的四个组合中，两者步数差是否为偶数

若是，总步数为两者中大的那个

最后，取个最小值



------------
## 代码如下：

~~~c++
#include<bits/stdc++.h>
using namespace std;
#define re register
#define LL long long
#define DB double
#define For(x,a,b) for(re int x=a;x<=b;x++)
#define For2(x,a,b) for(re int x=a;x>=b;x--)
#define LFor(x,a,b) for(re LL x=a;x<=b;x++)
#define LFor2(x,a,b) for(re LL x=a;x>=b;x--)
LL T;
LL ans;
inline LL gcd(LL x,LL y) {return x==0? y:gcd(y%x,x);}
inline LL mmax(LL x,LL y) {return x>y? x:y;}
LL n,m,x,y,a,b;
LL p[2][2];

int main()
{
	cin>>T;
	while(T--)
	{
		scanf("%lld%lld%lld%lld%lld%lld",&n,&m,&x,&y,&a,&b);
		if((x-1)%a==0) p[0][0]=(x-1)/a;
		else p[0][0]=-1;
		if((n-x)%a==0) p[0][1]=(n-x)/a;
		else p[0][1]=-1;
		if((y-1)%b==0) p[1][0]=(y-1)/b;
		else p[1][0]=-1;
		if((m-y)%b==0) p[1][1]=(m-y)/b;
		else p[1][1]=-1;//存步数
		ans=-1;
		For(i,0,1)
			For(j,0,1)
			{
				if(p[0][i]!=-1&&p[1][j]!=-1&&(p[1][j]-p[0][i])%2==0)
				{
					LL pp=mmax(p[1][j],p[0][i]);
					if(ans==-1||ans>pp) ans=pp;
				}
			}
//		printf("%lld %lld\n%lld %lld\n",p[0][0],p[0][1],p[1][0],p[1][1]);
		printf("%lld\n",ans);
	}
	
	return 0;
}
~~~

---

## 作者：liangledong (赞：2)

## 题意：
帮助可爱的小猫从点 $(x,y)$ 跳到点 $(1,1)$ 或 $(1,h)$ 或 $(n,1)$ 或 $(n,h)$。  
设小猫当前位置为 $(p,q)$ 则移动的方式如下：  
1. 若 $q\ge h$，可选择水平方向上移动 $a$，且竖直方向上减少 $b$，即把坐标变为 $(p-a,q-b)$ 或 $(p+a,q-b)$。
1. 若 $q\le h-b$，可选择水平方向上移动 $a$，且竖直方向上增加 $b$，即把坐标变为 $(p-a,q+b)$ 或 $(p+a,q+b)$。

严格意义上来说，当 $p-a<1$ 时不能向左移动，同理，当 $p+a>n$ 时不能向右移动。~~但是题目没说，以防万一还是写上吧。~~  
问：在此情况下，若小猫能到达目标位置的其中之一，则输出最小移动次数，否则输出 $-1$。

## 思路：
~~做题时，首先要思考怎么骗分~~
1. 对于 $n,h\le10$，可以直接暴力，递归暴力往合法的方向跳，不要一直跳重复的位置就行。期望得分：$32pts$。
1. 对于 $n,h\le500$，可以用宽搜，能得 $60pts$。
1. 用数学方法（即正解）。

~~当然你也可以输出 $-1$ 骗分，会有 $20pts$~~。

## 考虑正解：
看到 $n,h\le10^{15}$，想到这题应该是数学题。

先来分析一下满足什么条件才能到达目标坐标：
- 条件一：我们不难发现，每次移动，横坐标都会变化 $a$，纵坐标都会变化 $b$，所以只有在**初始坐标和目标坐标的横坐标之差为 $a$ 的整数倍，且纵坐标只差为 $b$ 的整数倍**时，才有可能到达。
- 条件二：横、纵坐标**同时**达到目标。

举个例子：当前坐标为 $(3,2)$，目标坐标为 $(1,1)$，$a=1,b=1$，这显然可以满足条件一，但是自己手动模拟一下，就会发现最靠近目标坐标的情况为 $(1,2)$ 和 $(2,1)$，无论如何都不能达到目标，就像象棋里的象不能走到棋盘的角落。

那如果当前位置为 $(1,3)$，目标坐标为 $(1,1)$，$a=1,b=1$，是不是不能到达了呢？

并不是。我们可以先跳到 $(2,2)$，再跳到 $(1,1)$，可以达到目标坐标。

我们不难发现这两步操作实际上是**保持了横坐标不变，纵坐标改变了 $b\times2$**。  
同理，我们可以用相同的操作做到**保持纵坐标不变，横坐标改变 $a\times2$**。

所以我们可以把条件二改为：

- 到达目标横坐标所需的步数与到达目标纵坐标所需的**步数差**为**偶数**

那么我们便可以写出以下程序：（以目标坐标为 $(1,1)$ 为例）

```cpp
if((x-1)%a==0&&(y-1)%b==0)//条件一
{
	if(((x-1)/a-(y-1)/b)%2==0)//条件二
	{
		__________
		//可以到达目标坐标
	}
}
```
判断了能不能到达，还要求要多少步：  
到达目标横坐标所需的步数与到达目标纵坐标所需的步数可以分别算出来。  
当其中一个到达后，还需要等另外一个也到达。  
所以，我们可以补充上面程序的空：

```cpp
ans=max((x-1)/a,(y-1)/b);
```

其他三个角同理。

最后提醒：本题数据范围非常大，记得开 `long long`。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long T,n,h,x,y,a,b,ans;
int main(){
	cin>>T;
	while(T--){
		cin>>n>>h>>x>>y>>a>>b;
		if((x==1&&y==h)||(x==1&&y==1)||(x==n&&y==h)||(x==n&&y==1)){//如果一开始就在目标坐标
			cout<<"0\n";
			continue;
		}
		if(x-a<1&&x+a>n){//如果不能移动，直接输出-1
			cout<<"-1\n";
			continue;
		}
		ans=1e18;//多组测试数据，别忘了初始化
		if((x-1)%a==0&&(h-y)%b==0){//左上
			if(((x-1)/a-(h-y)/b)%2==0)ans=min(ans,max((x-1)/a,(h-y)/b));
		}
		if((x-1)%a==0&&(y-1)%b==0){//左下
			if(((x-1)/a-(y-1)/b)%2==0)ans=min(ans,max((x-1)/a,(y-1)/b));
		}
		if((n-x)%a==0&&(h-y)%b==0){//右上
			if(((n-x)/a-(h-y)/b)%2==0)ans=min(ans,max((n-x)/a,(h-y)/b));
		}
		if((n-x)%a==0&&(y-1)%b==0){//右下
			if(((n-x)/a-(y-1)/b)%2==0)ans=min(ans,max((n-x)/a,(y-1)/b));
		}
		if(ans==1e18)cout<<"-1\n";//不能到达
		else cout<<ans<<"\n";
	}
	return 0;
}
```


---

## 作者：wunaidedanjuan (赞：1)

### 简化题意

给定一个在长 $n$ 宽 $h$ 网格中的点 $(x,y)$，判断通过四种移动方式能否达到网格四角，即点 $(1,1)$、$(1,h)$、$(n,1)$ 或 $(n,h)$，若能输出最小移动次数，否则则输出 $-1$。

四种移动方式：
1. 前提：$y>b$，$(x,y) \Rightarrow (x-a,y-b)$；
2. 前提：$y>b$，$(x,y) \Rightarrow (x+a,y-b)$；
3. 前提：$y<h-b$，$(x,y) \Rightarrow (x-a,y+b)$；
4. 前提：$y<h-b$，$(x,y) \Rightarrow (x+a,y+b)$；

### 思路分析

**先分别考虑横纵坐标的移动。** 

因为横坐标的移动单位为 $a$，所以若想从横坐标为 $x$ 的点移动到另一个点，这两个点的水平距离必须能被 $a$ 整除，结合下图可知，若想到达最左侧，需满足 $(x-1)\bmod a=0$，移动次数即为 $(x-1)\div a$，同理，要想到达最右侧，需满足 $(n-x)\bmod a=0$，移动次数为 $(n-x)/a$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jrn226ap.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

结合上图，同理可得，想达到最上侧，需满足 $(h-y)\bmod b=0$，移动次数为 $(h-y)\div b$，想达到最下侧，需满足 $(y-1)\bmod b=0$，移动次数为 $(y-1)\div b$。

结合上述分析，我们可以知道，**题目有解的充要条件 $1$ 为：至少有一对相邻方向均有解**，由此可以初步判断是否有解。

**再考虑横纵坐标一起移动。**

以向左上方移动为例，若单独考虑可以到达最左侧和最上侧，我们便要考虑是否能到达左上角 $(1,h)$。

设 $l=(x-1)\div a,u=(h-y)\div b$。考虑先只使用移动方式 $3$，直到到达最左侧或最上侧为止。此时，若 $l=u$，则可以达到 $(1,h)$；若 $l>u$，则先到达最上侧，且距点 $(1,h)$ 差 $(l-u)\times a$ 个水平单位；若 $u<l$，则先到达最左侧，且具点 $(1,h)$ 差 $(u-l)\times b$ 个竖直单位。

![](https://cdn.luogu.com.cn/upload/image_hosting/5i37bhoc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

![](https://cdn.luogu.com.cn/upload/image_hosting/ntx9ofx9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

结合上面两图可知，移动方式可以进行合并，即消耗两次移动次数使 $(x,y) \Rightarrow (x\pm 2a,y)$ 或 $(x,y) \Rightarrow (x,y\pm 2b)$,因此可知，当 $\left|l-u\right|$ 为偶数，即 $\left|l-u\right|\bmod2=0$ 时，可以到达 $(1,h)$，此时所需的移动次数为 $\min(l,u)+\left|l-u\right|\div 2\times 2$，即：$\min(l,u)+\left|l-u\right|$，再化简可得 $\max(l,u)$。

由上述结论推广可以得知：**当相邻方向所需移动次数的差值为偶数时可以到达相应顶点（题目有解的充要条件 $2$），所需移动次数为单独考虑时两个方向中所需移动次数较多的。**

### 思路总结

- 判断能否到达上下左右四个边界；

- 计算达到四个边界所需的步数;

- 根据题目有解的充要条件 $1$ 判断是否有解；

- 分四个方向计算所需的移动次数；

- 得到最小移动次数；

### 代码呈现
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<ctime>
#include<queue>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#include<string>
#include<bitset>
#include<cctype>
#include<cstdlib>
#include<functional>
#include<istream>
#include<sstream>
#define int long long 
using namespace std;
const int N=1000010,inf=0x3f3f3f3ff3f3f3f,mod=pow(2,31);
signed main()
{
	int t,n,h,x,y,a,b;
	scanf("%lld",&t);
	while(t--)
	{
		int l=-1,r=-1,u=-1,d=-1,ans=inf;//记录只考虑到达左右上下所需的最小移动次数，若不能到达则为-1 
		scanf("%lld%lld%lld%lld%lld%lld",&n,&h,&x,&y,&a,&b);
		if((x-1)%a==0)//到达最左侧
			l=(x-1)/a;
		if((n-x)%a==0)//最右侧
			r=(n-x)/a;
		if((h-y)%b==0)//最上侧
			u=(h-y)/b;
		if((y-1)%b==0)//最下侧
			d=(y-1)/b;
		if((l==-1&&r==-1)||(u==-1&&d==-1))//不满足有解的充要条件1 
		{
			printf("-1\n");
			continue;
		}
		if(u!=-1&&l!=-1&&abs(u-l)%2==0)//左上
			ans=min(ans,max(l,u));
		if(u!=-1&&r!=-1&&abs(u-r)%2==0)//右上
			ans=min(ans,max(r,u)); 
		if(d!=-1&&r!=-1&&abs(d-r)%2==0)//右下
			ans=min(ans,max(r,d)); 
		if(d!=-1&&l!=-1&&abs(d-l)%2==0)//左下
			ans=min(ans,max(l,d));
		if(ans==inf)
			printf("-1\n");
		else
			printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Moon_Traveller (赞：1)

[>> 传送门 <<](https://www.luogu.com.cn/problem/P4368)

## 题目大意

有一个矩形，四个顶点的坐标为 $(1,1)$、$(1,h)$、$(n,1)$、$(n,h)$。小猫在坐标 $(x,y)$ 处。

大概是这样：

| $(1,h)$ | $\dots$ | $(n,h)$ |
| :----------: | :----------: | :----------: |
| $\dots$ | $(x,y)$ | $\dots$ |
| $(1,1)$ | $\dots$ | $(n,1)$ |

小猫不喜欢这个矩形，所以它想离开这个矩形（“离开”指小猫 **刚好** 到达矩形的某一个顶点）。

小猫每一步可以在左右方向行进 $a$ 个单位，**并** 在上下方向行进 $b$ 个单位。即：小猫从起点可以走到 $(x+a,y+b)$、$(x+a,y-b)$、$(x-a,y+b)$、$(x-a,y-b)$ 这四个位置。

小猫不可以超出矩形的范围，即小猫必须在 $(1\sim n,1\sim h)$ 的范围内。

小猫想知道，它最少需要走几步才能离开这个矩形，如果无法离开，请输出 `-1`。

## 思路

这道题可以主要分解为两个小问题：

1. 能不能走？
2. 需要走几步？

我们只需要对四个行进方向（右上、右下、左上、左下）分别考虑这两个问题即可。

### 能不能走？

我们可以先分别判断两个正方向（上下左右）是不是可以走，再判断两个方向能否同时到达终点。比如说我们想向右上方向走，那么我们可以先判断右、上两个方向是不是都可以走，再判断这两个方向能不能同时走到终点 $(n,h)$。

判定方法：

> 1. **判断两个方向是否都能整除 $a$ 或 $b$（除哪个需要看是左右方向还是上下方向）。**

第一点稍微想一下就可以得到，毕竟如果不能整除，就不可能到达目标点。

> 2. **判断两个方向的（整除）步数差值是否为偶数。**

这里可以自己画一个图，假设我们往左下走可以走到终点，如果向下先到了边缘（即 $y$ 坐标为 $1$），那么我们就需要等待向左也到边缘。

但是显然我们不能直线向左走，因为在上下方向也必须要移动。所以，我们要先向上回一步，再向下走回去。这样一来，相当于往左多走了两步，而往下的步数还是不变。

如果还是没有到达，就再来两步，直到到达终点为止。

所以，我们需要判断两个方向的步数差是否为偶数。（这个可能有些绕，画个图就能理解了。）

### 需要走几步？

这个很简单，自己画一个图就明白了（也可以借助其他题解的图，我比较手残，就不画了 qwq）。

结论：

> 1. **对于每个方向：取两个正方向步数的最大值。**

为什么要取最大值？还记得我们的上一个结论是怎么推的吗？向下走的需要等待向左走的，因为左方向还没有到达边缘。所以最终我们要取向下走的步数还是向左走的步数？当然是取多的，也就是向左（上下横跳相当于没走）。

> 2. **取四个方向中的最小值。**

这个就不用多说了，是题目要求的。


## 代码
```cpp
#include <iostream>
using namespace std;
#define int long long

int T;
int n, h, x, y, a, b;
int u, d, l, r; // 能不能走？需要走几步？（上、下、左、右）
int minn = 1e14;
bool flag;

signed main()
{
    cin >> T;
    while(T--)
    {
        cin >> n >> h >> x >> y >> a >> b;
        minn = 1e14; // 每次要把minn赋一个极大值（这里我一开始用的是1e9，得了80pts，后来才发现不够大）
        flag = false; // 标记是否可以走出去

        if((h - y) % b == 0) // 向上走（h方向）可以吗？
            u = (h - y) / b; // 可以？需要走几步？
        else
            u = -1; // 不可以？赋成负值！
        if((y - 1) % b == 0) // 向下走（1方向）可以吗？
            d = (y - 1) / b; // 同上
        else
            d = -1;
        if((n - x) % a == 0) // 向右走（n方向）可以吗？
        {
            r = (n - x) / a; // 同上
            if(u != -1 && abs(u - r) % 2 == 0) // 能向右上走吗？
            {
                minn = min(minn, max(u, r)); // 取最小值
                flag = true; // 可以走出去！
            }
            if(d != -1 && abs(d - r) % 2 == 0) // 右下？
            {
                minn = min(minn, max(d, r));
                flag = true;
            }
        }
        if((x - 1) % a == 0) // 向左走（1方向）可以吗
        {
            l = (x - 1) / a;
            if(u != -1 && abs(u - l) % 2 == 0) // 左上？
            {
                minn = min(minn, max(u, l));
                flag = true;
            }
            if(d != -1 && abs(d - l) % 2 == 0) // 左下？
            {
                minn = min(minn, max(d, l));
                flag = true;
            }
        }
        
        if(flag)
        {
            cout << minn << endl;
        }
        else
        {
            cout << -1 << endl;
        }
    }
    return 0;
}
```

---

## 作者：lmrttx (赞：1)

题意很清晰，先建立一个平面直角坐标系。

所以，小猫的坐标，即出发点就是 $(x,y)$，而根据题意，小猫可以从一个位置去的另一些位置分别为:

$$(x+a,y-b);(x-a,y-b);(x+a,y+b);(x-a,y+b).$$

所以，思路就来了。

1.暴力： 算了吧，没什么分数的。

2.深搜与广搜：根据我的~~垃圾~~计算，顶多70分。

于是明白这是一道数学题。

我们发现：小猫走到四个边界点，就可以呼吸。而最优方式是**沿着 $x$ 轴与 $y$ 轴走**，哪边**更优**，哪边**可以整除**，就往哪边走。不然，如果无法整除，往那个方向就走不到终点。存下条件，就可以非常快地AC了。

加了防复制的代码：

```cpp
#include<bist/stcd++.h>
using namesapce sdt;
#define ll long lo1g
ll t,ans,n,h,x,y,a,b,f[2][2];
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld%lld%lld%lld%lld%lld",&n,&h,&x,&y,&a,&b);
		if( (x-1) %a == 0) f[0][0]=(x-1)/a;
		else f[0][0]=-1;
		if( (n-x) %a == 0) f[0][1]=(n-x)/a;
		else f[0][1]=-1;
		if( (y-1) %b == 0) f[1][0]=(y-1)/b;
		else f[1][0]=-1;
		if( (h-y) %b == 0) f[1][1]=(h-y)/b;
		else f[1][1]=-1;
        //记录整除的条件
		ans=-1;//由于走不到要输出-1，所以初始化为-1.
		for(register int i=0;i<=1;i++)
		 for(register int j=0;j<=1;j++){
		 	if(f[0][i]!=-1 && f[1][j]!=-1 && (f[1][j]-f[0][i])%2==0){
		 		ll tmp=max(f[1][j],f[0][i]);
		 		if(ans>tmp||ans==-1)ans=tmp;
			 }//判断行走的条件及保存答案
		 }
		 printf("%lld\n",ans);
	}
	return 0;
} 
```

谢谢阅读。

---

## 作者：anideahe (赞：1)

## [Code+#4]喵呜
### 题意分析：
给出当前横坐标与纵坐标以及横速度与纵速度，求到 $(1,h)$、$(n,h)$、$(1,1)$、$(n,1)$ 四个点的距离中的最短距离，如果到任意一点的时间都不为整数，则输出 -1 。
***
### 算法分析：
将目标的横坐标与纵坐标存在数组里，取到四个点的距离的最小值，先判断是否为整数，还要判断是否合法，怎样判断是否合法呢？例如，横坐标已满足要求，纵坐标还未，那么只有后退一步再前进一步，走两步，即纵坐标的时间玉横坐标的时间相差偶数，其它情况也是一样，如果可行，更新最小值，最后输出即可。
***
## _Code_：
```cpp
  #include<bits/stdc++.h>
  #define ll long long
  using namespace std;
  ll t,n,h,x,y,a,b,xx,yy;
  int js(ll xxx,ll yyy){
      if(!(max(xxx/a,yyy/b)-min(xxx/a,yyy/b))%2) return 0;
      else return 1;
  }
  int main(){
      cin>>t;
      while(t--){
          cin>>n>>h>>x>>y>>a>>b;
          xx=n-x,yy=h-y;
          x--,y--;
          ll  aa[2]={x,xx},bb[2]={y,yy},maxx=1e18;
          for(ll i=0;i<=1;i++)
              for(ll j=0;j<=1;j++)
                  if(!js(aa[i],bb[j])&&!aa[i]%a&&!bb[j]%b)
                      maxx=min(maxx,max(aa[i]/a,bb[j]/b));
          if(maxx!=1e18)
              cout<<maxx<<endl;
          else
              cout<<-1<<endl;
      } 
      return 0;
  }
 ```

---

## 作者：MSX78 (赞：0)

先分析题目发现，不论怎么跳，当前位置的坐标 $x$ 和 $y$ 必须满足向任意方向跳跃的总距离能被 $a$ 和 $b$ 整除。

如果跳的步数不相同，就绕一下。

但这就要跳的步数之差能被 $2$ 整除。

废话不多说，上代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

void solve(){//这是核心部分
	long long n, h, x, y, a, b;
	cin >> n >> h >> x >> y >> a >> b;
	long long l, r, u, d;// l 表示向左跳多少步，r 是向右， u 向上， d 向下。
	if((x-1)%a==0){//本蒟蒻只会写又臭又长的 if
		l = (x-1)/a;
	}	
	else{
		l = -1;
	}
	if((n-x)%a==0){
		r = (n-x)/a;
	}	
	else{
		r = -1;
	}	
	if((y-1)%b==0){
		d = (y-1)/b;
	}	
	else{
		d = -1;
	}
	if((h-y)%b==0){
		u = (h-y)/b;
	}	
	else{
		u = -1;
	}
	if((l==-1&&r==-1)||(u==-1&&d==-1)){//判断能不能跳整数步
		cout << -1 << "\n";
		return ;
	}
	long long ans = LLONG_MAX;
	if(l!=-1&&u!=-1){
		if((max(l,u)-min(l,u))%2==0){//如果 l 和 u 的差不被 2 整除，就没法绕。
			ans = min(ans,max(l,u));
		}
	}
	if(l!=-1&&d!=-1){
		if((max(l,d)-min(l,d))%2==0){
			ans = min(ans,max(l,d));
		}
	}	
	if(r!=-1&&u!=-1){
		if((max(r,u)-min(r,u))%2==0){
			ans = min(ans,max(r,u));
		}
	}
	if(r!=-1&&d!=-1){
		if((max(r,d)-min(r,d))%2==0){
			ans = min(ans,max(r,d));
		}
	}
	if(ans == LLONG_MAX){
		cout << -1 << "\n";
	}
	else{
		cout << ans << "\n";
	}
}

int main(){//主函数，没什么好说的
	int t;
	cin >> t;
	while(t--){
		solve();
	}
	return 0;
}
```
记得开 long long。

---

## 作者：lqsy002 (赞：0)

## 题目大意
题目已经写得很清楚了。[题目链接](https://www.luogu.com.cn/problem/P4368)。
## 解题思路
注意到题目要求小猫走到四个角上，而每一步移动的距离是知道的，那么我们可以考虑用数学来做这道题。
1. 由于每次移动的距离是固定的，所以不能被移动距离整除的肯定不对。
2. 建立坐标系，我们发现小猫沿 $x$ 轴，$y$ 轴方向每次移动的距离都是 $2\times a$ 或 $2\times b$（比如向 $x$ 轴正方向移动相当于先向右上，再向右下）。
3. 以到达右上角为例，我们先让小猫往右上跳，那么每次坐标改变量都是 $a$ 和 $b$，直到达到棋盘某一边。此时我们再横向或纵向移动，以横向移动为例，若能到达右上角，则距离应该为 $n$ 倍的 $2\times a$，移动步数应该为 $2\times n$，而这个 $2\times n$ 就是横向移动比纵向移动多出来的步数，所以我们可以判断横向移动与纵向移动的步数差，若为偶数，则能到达，否则不能。
4. 此时所需的步数就是横向或纵向移动步数中较大的那一个。
## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,ans,n,h,x,y,a,b,f[2][2],tmp;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>h>>x>>y>>a>>b;
        if((x-1)%a==0)
            f[0][0]=(x-1)/a;
        else
            f[0][0]=-1;
        if((n-x)%a==0)
            f[0][1]=(n-x)/a;
        else
            f[0][1]=-1;
        if((y-1)%b==0)
            f[1][0]=(y-1)/b;
        else
            f[1][0]=-1;
        if((h-y)%b==0)
            f[1][1]=(h-y)/b;
        else
            f[1][1]=-1;
        ans=-1;
        for(int i=0;i<=1;i++)
            for(int j=0;j<=1;j++)
                if(f[0][i]!=-1&&f[1][j]!=-1&&(f[1][j]-f[0][i])%2==0){
                    tmp=max(f[1][j],f[0][i]);
                    if(ans>tmp||ans==-1)
                        ans=tmp;
                }
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 题目描述

一只小猫位于一排整齐的 $n$ 棵樱花树上，每棵树的高度都是 $h$。小猫的目标是跳跃到第 $1$ 或第 $n$ 棵树上，高度分别为 $h$ 或 $1$ 的位置。她可以通过两种跳跃方式达成目标：

1. 轻轻跳：向左或向右移动 $a$ 棵樱花树，同时高度下降 $b$。
2. 使劲跳：向左或向右移动 $a$ 棵樱花树，同时高度上升 $b$。

小猫所在的位置由两个参数 $x$ 和 $y$ 表示，其中 $x$ 是树的编号，$y$ 是高度。她想知道离开樱花树所需的最少跳跃次数。

请你帮助小猫解决这个问题。
### 思路：
我们可以把这一排樱花树看成棋盘，这样看起来好像有点像马走日，但暴力肯定会 TLE。

这时我们注意到题目要求小猫走到四个角上，而每一步移动的距离是知道的，那么我们可以考虑用数学来做这道题。

首先，由于每次移动的距离是固定的，所以不能被移动距离整除的肯定不对，即：
```cpp
if(x%a!=0 || y%b!=0) 
  return INF;
```
满足这一个条件后我们再往下考虑：

首先建立坐标系，我们发现小猫沿 $x$ 轴、$y$ 轴方向每次移动的距离都是 $2 \times a$ 或 $2 \times b$（比如向 $x$ 轴正方向移动相当于先向右上，再向右下），所以我们可以这么考虑：

以到达右上角为例，我们先让小猫往右上跳，那么每次坐标改变量都是 $(a,b)$，直到达到棋盘某一边。此时我们再横向或纵向移动，以横向移动为例。

若能到达右上角，则距离应该为 $n$ 倍的 $2 \times a$，移动步数应该为 $2 \times n$，而这个 $2 \times n$，就是横向移动比纵向移动多出来的步数，所以我们可以判断横向移动与纵向移动的步数差，若为偶数，则能到达，否则不能。
```cpp
if((x/a-y/b)%2 == 0) 
  return max(x/a,y/b);
```
此时所需的步数就是横向或纵向移动步数中较大的那一个。
### 完整代码：
```cpp
#include <stdio.h>
#include <iostream>
using namespace std;
#define INF 0x3f3f3f3f3f3f3f3f

long long T,n,h,x,y,a,b,ans;

long long step(long long x, long long y){
	if(x%a!=0 || y%b!=0) return INF;
	if((x/a-y/b)%2 == 0) return max(x/a,y/b);
	return INF;
}
int main(void){
	cin >> T;
	for(int i=1;i<=T;i++){
		ans = INF;
		cin >> n >> h >> x >> y >> a >> b;
		ans = min(ans,step(x-1,y-1));
		ans = min(ans,step(n-x,y-1));
		ans = min(ans,step(x-1,h-y));
		ans = min(ans,step(n-x,h-y));
		if(ans == INF)	cout << "-1" << endl;
		else			cout << ans  << endl;
	}
	return 0;
}

```


---


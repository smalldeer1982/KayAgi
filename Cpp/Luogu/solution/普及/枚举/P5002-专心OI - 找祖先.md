# 专心OI - 找祖先

## 题目背景

Imakf 是一个小蒟蒻，他最近刚学了 LCA，他在手机 APPstore 里看到一个游戏也叫做 LCA 就下载了下来。

## 题目描述

这个游戏会给出你一棵树，这棵树有 $N$ 个节点，根结点是 $R$，系统会选中 $M$ 个点 $P_1,P_2 \cdots P_M$，要Imakf 回答有多少组点对 $(u_i,v_i)$ 的最近公共祖先是 $P_i$。Imakf 是个小蒟蒻，他就算学了 LCA 也做不出，于是只好求助您了。



## 说明/提示

样例 1 的树如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/37971.png)

 对于询问 1 $~(1,1)
(1,2)
(1,3)
(1,4)
(1,5)
(1,6)
(1,7)
(2,1)
(2,3)
(2,6)
(2,7)
(3,1)
(3,2)
(3,4)
(3,5)
(4,1)
(4,3)$

$
(4,6)
(4,7)
(5,1)
(5,3)
(5,6)
(5,7)
(6,1)
(6,2)
(6,4)
(6,5)
(7,1)
(7,2)
(7,4)
(7,5)$ 共 $31$ 组点对。

询问 2 $(2,2)
(2,4)
(2,5)
(4,2)
(4,5)
(5,2)
(5,4)$ 共 $7$ 组点对。

对于询问 3 $(4,4)$ 共 $1$ 组点对。

$1\le R\le N\leq10000$，$0\le M\leq50000$。

## 样例 #1

### 输入

```
7 1 3
1 2
1 3
2 4
2 5
3 6
3 7
1 2 4```

### 输出

```
31
7
1```

# 题解

## 作者：llzzxx712 (赞：88)

## 虽然标签有LCA，但根本没有用到求LCA（~~谁写的标签）~~
先是存树，我习惯用的是领接表~~（本人太弱，不会用vector）~~
```cpp
int n,m,r,tot;
int to[N],ne[N],head[N],son[N],ans[50002],de[N];
void add(int x,int y){
	to[++tot]=y,ne[tot]=head[x],head[x]=tot;
}
```
n,m,r如题意所示，son数组记录每个子树的大小，de数组记录每个节点深度，ans数组记录每个点对应的答案

本题的核心就是求每棵子树的大小,然后排列组合一下
```cpp
void dfs(int x,int fa){
	son[x]=1;//子树包括自身 
	de[x]=de[fa]+1;//暂时没什么用的深度 
	for(int i=head[x];i;i=ne[i]){//邻接表遍历 
		if(to[i]!=fa){//没了它你的dfs就会在根节点和一个子树上反复横跳 
			dfs(to[i],x);
			son[x]+=son[to[i]]%mo;//递归，求出其儿子的子树的大小后再加上去，递归边界是叶子节点,son[]为1 
		}
	}
}
```
这样我们就快乐地求出了所有子树的大小

接下来就是分析题目了，题问有多少对节点（x，y）的LCA为p，很容易发现以下性质

1. x,y一定在p的子树中
1. 如果x，y都！=p，那么x，y绝对不是p的同一个儿子的 子树

总结一下就会发现要么一个节点为p，另一个节点为子树p中的任一节点（一共son [ p ]对）；要么一个节点在p的儿子的子树中，另一个节点在p的其它儿子的子树中（包括p节点）。那么我们就可以遍历p的儿子，每一个儿子的子树大小乘上p子树中除该子树的大小，最后加上son[p]
```cpp
int getans(int p){
	int x,y=0,z=0;//x为p的子树大小，y为本次遍历到的子树的大小
	z=x=son[p];//z为计算结果
	for(int i=head[p];i;i=ne[i]){
		if(de[to[i]]<de[p]) continue;//通过深度来保证搜索的其儿子
		y=son[to[i]];
		z+=(long long)((x-y)*y)%mo;
	}
	return z;
}
```
用了这个，就可以针对每一个询问的p求出相应的结果
```cpp
for(int i=1;i<=m;i++){
	int p;
	cin>>p;
        ans[p]=getans(p);
}
for(int i=1;i<=m;i++) cout<<ans[i]<<endl;
```

然后。。。然后就TLE了一个点

怎么回事呢？再回去看看题目，M<=50000而N<=10000，诶，询问次数比点要多，说明很多点被重复询问了多次（~~好坑啊~~）

```cpp
	for(int i=1;i<=n;i++) ans[i]=getans(i);
	for(int i=1;i<=m;i++){
		int p;
		read(p);
		cout<<ans[p]<<endl;
	}
```
所以我们就把每个点都处理一遍，最后直接输出就好了

**完整代码**
```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 20002
#define mo 1000000007
using namespace std;
int n,m,r,tot;
int to[N],ne[N],head[N],son[N],ans[50002],de[N];
void add(int x,int y){
	to[++tot]=y,ne[tot]=head[x],head[x]=tot;
}
void read(int &x) {
    int f = 1; x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
void dfs(int x,int fa){
	son[x]=1;//子树包括自身
	de[x]=de[fa]+1;//暂时没什么用的深度 
	for(int i=head[x];i;i=ne[i]){//邻接表遍历 
		if(to[i]!=fa){//没了它你的dfs就会在根节点和一个子树上反复横跳 
			dfs(to[i],x);
			son[x]+=son[to[i]]%mo;//递归，求出其儿子的子树的大小后再加上去， 
		}
	}
}
int getans(int p){
	int x,y=0,z=0;
	z=x=son[p];
	for(int i=head[p];i;i=ne[i]){
		if(de[to[i]]<de[p]) continue;
		y=son[to[i]];
		z+=(long long)((x-y)*y)%mo;
	}
	return z;
}
int main()
{
    read(n),read(r),read(m);
    for(int i=1;i<n;i++){
    	int x,y;
    	read(x),read(y);
    	add(x,y),add(y,x);
	}
	dfs(r,r);
	for(int i=1;i<=n;i++) ans[i]=getans(i);
	for(int i=1;i<=m;i++){
		int p;
		read(p);
		cout<<ans[p]<<endl;
	}
	return 0;
}

```
**~~写题解不易，点个赞呗~~**







---

## 作者：ZAGER (赞：31)

## 题解

传送门：[透彻](https://www.cnblogs.com/ZAGER/p/9911398.html)

看到这是洛谷新出的题，看着有点思路就做了。

我在$dfs$时就预处理出了$ans$数组，即为每个点的答案，所以时间复杂度是$O(max(n,m))$

对于每个点$x$，我们可以把答案分成跨过$x$的和没有跨过$x$的方案两部分。

#### 没有跨过x的部分：

很显然，其中一个点一定是$x$，所以这部分的答案为$x$的$siz$大小的$2$倍$-1$（因为是点对并且(1,1)算一种）。

即$ans1=2*siz[x]-1$.

#### 跨过$x$的部分:

根据乘法原理，所有$x$的儿子$son_i$的$siz$大小相乘即为这部分的答案。

设$x$一共有$k$棵子树即

$$ans2=\sum_{i=1}^{k}\sum_{j=1}^{k}siz[son[i]]*siz[son[j]]$$
$$=\sum_{i=1}^{k}siz[son[i]]*(siz[x]-1)$$
$$=(siz[x]-1)*(siz[x]-1)$$

但是我们会发现不对，因为我们算重了一部分，就是$(i==j)$的部分。

所以我们还要减去$\sum_{i=1}^{k}siz[son[i]]^2$.

所以$ans2=(siz[x]-1)^2-\sum_{i=1}^{k}siz[son[i]]^2$

#### 综上：

$$Ans=ans1+ans2$$
$$=2*siz[x]-1+(siz[x]-1)^2-\sum_{i=1}^{k}siz[son[i]]^2$$
$$=siz[x]^2-\sum_{i=1}^{k}siz[son[i]]^2$$

我们只需要维护一下每个点子树的$siz[son[i]]^2$的和即可获得答案。

#### 吐槽一句：这题Ans最大是$N^2$，居然要去取模。。。。

## code：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#define N 10005
#define R register
using namespace std;
template<typename T>inline void read(T &a){
    char c=getchar();T x=0,f=1;
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    a=f*x;
}
int n,rt,m,tot,p;
int siz[N],ans[N],h[N],sum[N];
struct node{
    int nex,to;
}edge[N<<1];
inline void add(R int u,R int v){
    edge[++tot].nex=h[u];
    edge[tot].to=v;
    h[u]=tot;
}
inline void dfs(R int x,R int f){
    siz[x]=1;
    for(R int i=h[x];i;i=edge[i].nex){
        R int xx=edge[i].to;
        if(xx==f)continue;
        dfs(xx,x);
        siz[x]+=siz[xx];
        sum[x]+=siz[xx]*siz[xx];
    }
    ans[x]=siz[x]*siz[x]-sum[x];
}
int main(){
    read(n);read(rt);read(m);
    for(R int i=1,u,v;i<=n-1;i++)
        read(u),read(v),add(u,v),add(v,u);
    dfs(rt,0);
    while(m--){
    	read(p);
    	printf("%d\n",ans[p]);
    }
    return 0;
} 
```



---

## 作者：0x3F (赞：22)

先来考虑一下在哪些情况下 $x, y$ 的 LCA 是 $k$ 。
1. $x, y$ 中有一个为 $k$, 另一个在 $k$ 所在的子树内。
1. $x, y$ 属于 $k$ 的两个不同的儿子所在的子树。

对于第一种情况， $k$ 所在的子树大小乘以 $2$ 再减去 $1$ 即可。

对于第二种情况， $k$ 的所有儿子所在的子树大小两两相乘，这一步可以通过前缀和优化，~~其实不优化也行反正 $O (n^2)$ 也能过~~。

注意一下 $x, y$ 是有序的，所以要乘以 $2$。

然后就没有然后了。

```cpp
#include <bits/stdc++.h>
#define _ 10010
#define mod 1000000007
using namespace std;
int n, r, m, a, b;
int siz[_], cnt[_];
vector<int> G[_];
void dfs(int x, int f) {
	for (int i = 0; i < G[x].size(); i++) {
		if (G[x][i] != f) {
			dfs(G[x][i], x);
			cnt[x] = (cnt[x] + 1ll * siz[x] * siz[G[x][i]]) % mod;
			siz[x] += siz[G[x][i]];
		}
	}
	cnt[x] = (cnt[x] + siz[x]) % mod;
	cnt[x] = cnt[x] * 2 % mod;
	siz[x]++;
	cnt[x]++;
}
int main() {
	cin >> n >> r >> m;
	for (int i = 1; i < n; i++) {
		cin >> a >> b;
		G[a].push_back(b);
		G[b].push_back(a);
	}
	dfs(r, 0);
	while (m--) {
		cin >> r;
		cout << cnt[r] << endl;
	}
	return 0;
}
```
码风奇丑

$\color{white}{\texttt{第一次写题解，求过QWQ}}$

---

## 作者：mulberror (赞：13)

来写一篇比较容易看懂的题解。

---
我们还是先将一下算法的步骤，待会再解释起来方便一点。

## 算法步骤
首先我们算出每个子树的$size$。

我们就设当前访问的节点

然后我们就得到了当前这个节点的答案是这个树整个的$size$的两倍$-1$，再加上两两子树的$size$的积。

也就是$ans=size[u] \times 2 - 1 +\sum size[i] * size[j] $

其中$i$和$j$是u的儿子。

----

一下就是核心代码：
```cpp
register LL ans = sz[p] * 2 - 1;
for (Ri i = head[p] ; i ; i = edge[i].next) 
{
     if ( edge[i].to == fa[p]) continue;
     sz_rest = sz[p] - sz[edge[i].to] - 1 ;
     ans = (ans + (sz_rest *  sz[edge[i].to]  ) ) % Mod;
}
```

---

## 解释一下

首先，我们要明白，如果要以当前这个节点为$LCA$的话，那么两个节点必须不能是是这个当前这个要查询的节点的父亲，这个应该没有问题。

那么这两个节点必须是在当前查询节点上，或者是在这个节点的**不同**子树中。（**注：这个一定是要在不同的子树中，不然$LCA$就会是在这个子树当中，而不是当前的节点**）

那么我们要考虑两种情况

* 如果其中一个点是我们要访问的节点，那么另外一个点就可以是这个这棵子树中任意的点，但是要注意两个细节，这些点对是有顺序的，所以答案需要$\times 2$，第二个细节是我们要注意根节点是只算一次的，因为相同的点放前放后都是一样的，只算一种。

* 如果两个点是在不同的子树中，那么一棵子树中每一个节点都一定可以和另外一课子树中的任意一点相组成一个合法的点对，那么就根据乘法原理，将这些子树中的节点数相乘在相加就是我们得到的答案了。

那么我们就得到了答案呀，答案就是上文中所提到的$ans=size[u] \times 2 - 1 +\sum size[i] * size[j] $

----
以下是代码，但是是错的，会TLE一个点。

```cpp
# include <bits/stdc++.h>
# define Ri register int
# define for1(i,a,b) for (Ri i(a) ; i <= b; i++ )
# define for2(i,a,b) for (Ri i(a) ; i >= b; i-- )

using namespace std;

typedef long long LL;

const int Mod = 1e9 + 7;
const int Maxn = 50005;

struct Edge {
    int to , next ;
} edge[Maxn<<1] ;

int head[Maxn<<1];
int sz[Maxn], fa[Maxn];
int root, n ,m , Nedge;

inline int read ()
{
    int w = 0,x = 0; char ch = 0;
    while ( !isdigit(ch) ) { w |= ch == '-'; ch = getchar() ; }
    while ( isdigit(ch) ) { x = (x<<1) + (x<<3) + (ch^48); ch = getchar() ; }
    return w ? -x : x ;
}

inline void Add_Edge (int u, int v) 
{
    edge[Nedge] = (Edge) {v , head[u]};
    head[u] = Nedge++;
}

inline void dfs (int u , int fat) 
{
    fa[u] = fat;
    sz[u] = 1;
    for (int i = head[u] ; i != -1; i = edge[i].next )
    {
        int v = edge[i].to;
        if ( v == fa[u] ) continue;
        dfs (v ,u );
        sz[u] += sz[v];
    }
}

int main ()
{
    memset( head, -1 ,sizeof(head) );
    n = read(), root = read(), m = read();
    for1 (i , 1 , n-1) 
    {
        int u = read(),v = read();
        Add_Edge(u, v);  Add_Edge(v, u);
    }
    dfs (root , -1);
    for1 (T ,1 , m ) 
    {
        int p = read(); 
        LL ans = sz[p] * 2 - 1;
        for (int i = head[p] ; i != -1 ; i = edge[i].next) 
        {
            for (int j = head[p] ; j != -1 ; j = edge[j].next) 
            {
                if (i == j || edge[i].to == fa[p] || edge[j].to == fa[p]) continue;
                ans = (ans + sz[edge[i].to] * sz[edge[j].to]) % Mod;
            }
        }
        printf ("%lld\n", ans);
    }
    return 0 ;
}

```
用尽了卡常技巧，都没法A掉最后一个点，为什么？

因为最后一个点太大了，如果按照我们的做法，是$O(n^3+n^2+ m + n)$的复杂度，这样实在是太不优美了。

我们来想一想优化。

其实我们并不需要枚举两个儿子，因为我们还有一个父亲没有用到，因为任意一个儿子需要$\times$不属于这个子树的节点的数量，那么这个数量就是父亲的$size-$儿子$size-1$。**$-1$是减去父亲的节点**
那么也就是优化成$O(2\times n^2 + n + m)$

其实也就是优化了主程序的一小部分。
```cpp
for1 (T ,1 , m ) 
    {
        register int p = read() ;
        register int sz_rest; 
        register LL ans = sz[p] * 2 - 1;
        for (Ri i = head[p] ; i != -1 ; i = edge[i].next) 
        {
            if ( edge[i].to == fa[p]) continue;
            sz_rest = sz[p] - sz[edge[i].to] - 1 ;
            ans = (ans + (sz_rest *  sz[edge[i].to]  ) ) % Mod;
        }
        printf ("%lld\n", ans);
    }
```
但是还是做不了，还是会T掉一个点，那么我们就需要更加牛逼的优化了，因为答案不大，我们就用一个桶记录这个答案，这样我们就把超大的$m$缩小成了$n$了，这样我就刚好过掉了，而且速度老快惹QAQ！

----
以下是正解代码
```cpp
# include <cstdio>
# include <cstring>
# include <ctype.h>
# define Ri register int
# define for1(i,a,b) for (Ri i(a) ; i <= b; i++ )
# define for2(i,a,b) for (Ri i(a) ; i >= b; i-- )

using namespace std;

typedef long long LL;

const int Mod = 1e9 + 7;
const int Maxn = 50005;

struct Edge {
    int to , next ;
} edge[Maxn<<1] ;

int head[Maxn<<1];
int sz[Maxn], fa[Maxn];
int root, n ,m , Nedge;
LL Ans[Maxn];

inline int read ()
{
    int w = 0,x = 0; char ch = 0;
    while ( !isdigit(ch) ) { w |= ch == '-'; ch = getchar() ; }
    while ( isdigit(ch) ) { x = (x<<1) + (x<<3) + (ch^48); ch = getchar() ; }
    return w ? -x : x ;
}

inline void Add_Edge (int u, int v) 
{
    edge[Nedge] = (Edge) {v,head[u]};
    head[u] = Nedge++;
}

inline void dfs (int u , int fat) //计算size，并标记父亲
{
    fa[u] = fat; sz[u] = 1;
    for (Ri i = head[u] ; i ; i = edge[i].next )
    {
        int v = edge[i].to;
        if ( v == fa[u] ) continue;
        dfs (v ,u );
        sz[u] += sz[v];//累加size
    }
}

int main ()
{
    n = read(), root = read(), m = read(); Nedge=1;
    for1 (i , 1 , n-1) 
    {
        int u = read(), v = read();
        Add_Edge(u, v);  Add_Edge(v, u);
    }
    dfs (root , -1);
    for1 (T ,1 , m ) 
    {
        register int p = read() ;
        if ( Ans[p] != 0 ) {printf("%lld\n", Ans[p] ); continue; } //如果当前的答案已经算过了，直接输出
        register int sz_rest; //表示剩下的
        register LL ans = sz[p] * 2 - 1; //算第一部分的答案
        for (Ri i = head[p] ; i ; i = edge[i].next) 
        {
            if ( edge[i].to == fa[p]) continue;
            sz_rest = sz[p] - sz[edge[i].to] - 1 ;//算第二部分的答案。
            ans = (ans + (sz_rest *  sz[edge[i].to]  ) ) % Mod;//累加答案
        }
        Ans[p] = ans ;
        printf ("%lld\n", ans);
    }
    return 0 ;
}
```

---

## 作者：Imakf (赞：9)

本题受[P1351 联合权值](https://www.luogu.org/problemnew/show/P1351)启发而出，数据极水

## $5pts~~$  $!CE$

人口普查分

## $85pts$ 暴力......

实在是数据水，想卡$O(n^2*log~n*m)$的暴力但是不会……

直接暴力枚举$(u,v)$，树剖求$LCA$，(没试过倍增)，然后就没有然后了

不会求$LCA?$请移步[模板](https://www.luogu.org/problemnew/show/P3379)，里面有很多优质的题解！

## $85pts$ 简单数学优化 (~~你没看错还是85pts~~)

以样例为例![](https://cdn.luogu.com.cn/upload/pic/37971.png)

询问点$1$，为什么答案是$31$呢？(以下$size$指子树大小（包括节点本身）)

1. 点$1$ 有 $2$棵子树，两棵子树的$size$分别为$3,3~~~$ 乘法原理可得 $ans+=3*3*2$（$*2$是因为$(u,v)$可以反过来变成$(v,u)$）

2. 点$1$ 的 $size$ 为 $8$ $~~~\therefore ans+=8*2-1~~~~~~$ ($-1$是因为$(1,1)$被重复计算了)

如果询问的点$P_i$有$k$棵子树，并且子树$size$分别为$a_i$，那么$ans=(\sum^k_{i=1}\sum^k_{j=1}a_i*a_j)-\sum^k_{i=1} (a_i)^2+size_{P_i}*2-1$

左边这个东西可以$O(k)$求出来，不就用**完全平方公式搞一下**吗？

```cpp
long long solve(long long now) {
    long long sigma=0,chengji=0;	//sigma是相加的和
    //chengji是平方和
    for(register long long i=head[now]; i; i=h[i].next) { //枚举儿子
        long long d=h[i].node;
        if(d==fa[now]) continue;	//不能枚举父亲节点鸭
        sigma+=son[d];
        sigma%=mod;
        chengji+=son[d]*son[d];
        chengji%=mod;
    }
    return (son[now]*2%mod-1+sigma*sigma%mod-chengji+mod)%mod;
    //小心出现负数！
}
```
## $100pts$ 存储重复答案

当您发现$M>N$时，您就应该想到这一点！

## $STD$

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define maxn (100000+3)
#define mod (1000000007)

long long head[maxn],tot;
struct edge {
    long long node,next;
} h[maxn<<1];
void addedge(long long u,long long v) {
    h[++tot].next=head[u];
    head[u]=tot;
    h[tot].node=v;
}
long long n,r,m;
long long son[maxn],fa[maxn],ans[maxn];
void dfs(long long now,long long f) {	//树剖常规操作，预处理size,fa,son
    fa[now]=f;
    son[now]=1;
    for(register long long i=head[now]; i; i=h[i].next) {
        long long d=h[i].node;
        if(d==f) continue;
        dfs(d,now);
        son[now]+=son[d];
    }
}
long long solve(long long now) {
	if(ans[now])	return ans;
    long long sigma=0,chengji=0;
    for(register long long i=head[now]; i; i=h[i].next) {
        long long d=h[i].node;
        if(d==fa[now]) continue;
        sigma+=son[d];
        sigma%=mod;
        chengji+=son[d]*son[d];
        chengji%=mod;
    }
    return ans[now]=(son[now]*2%mod-1+sigma*sigma%mod-chengji+mod)%mod;
}
int main() {
    scanf("%lld%lld%lld",&n,&r,&m);
    for(register long long i=1,u,v; i<n; ++i) {
        scanf("%lld%lld",&u,&v);
        addedge(u,v);
        addedge(v,u);
    }
    dfs(r,0);
    for(register long long i=1,p; i<=m; ++i) {
        scanf("%lld",&p);
        printf("%lld\n",solve(p));
    }
    return 0;
}
```


---

## 作者：wanghanjun (赞：5)

然而这道题和LCA并没有什么关系。。。

这道题有点像小学时学的排列组合

拿样例来说，P=1时，有左右两颗子树，从每颗子树中选出一个点，他们的LCA就是P，点P和任何一个它的子节点的LCA都是P，总共31组（不要忘了u,v可以互换）

一般情况：若P的所有子树的节点数分别为q1,q2,...,qk，则P一共有s=q1+q2+...+qk+1个节点，那么总共有(s-1)^2-q1^2-q2^2-...-qk^2+s*2-1组(u,v)

那么我们用sum[i]记录i节点的子节点（包括i）个数，用ans[i]记录P=i时有多少组(u,v)，然后用dfs遍历一遍就可以了

代码：
```cpp
#include <iostream>
using namespace std;

const int MAXN=10005;
struct node{
	int v;//邻接表存图
	node*next;
}*h[MAXN],pool[MAXN<<1];
int sum[MAXN],ans[MAXN],n,r,m,a,b,tot=0;

void addedge(int u,int v){
	node*p=&pool[++tot];
	p->v=v;p->next=h[u];h[u]=p;
}

void dfs(int u,int f){
	sum[u]=1;ans[u]=0;//sum初始值为1
	for(node*p=h[u];p!=NULL;p=p->next){
		if(p->v!=f){
			dfs(p->v,u);//向下遍历
			sum[u]+=sum[p->v];//记录sum
		}
	}
	for(node*p=h[u];p!=NULL;p=p->next){
		if(p->v!=f){
			ans[u]+=sum[p->v]*(sum[u]-sum[p->v]-1);
		}
	}//求ans
	ans[u]=ans[u]+sum[u]*2-1;
}

int main(){
	cin>>n>>r>>m;
	for(int i=1;i<n;i++){
		cin>>a>>b;
		addedge(a,b);
		addedge(b,a);
	}
	dfs(r,0);
	for(int i=1;i<=m;i++){
		cin>>a;
		cout<<ans[a]<<endl;
	}
	return 0;
}
```
因为我太弱了，所以有什么用词不当的地方请帮我改正，谢谢。

---

## 作者：珈乐唯毒 (赞：4)

题目思路：我们可以对于每一个点去找以它为lca的节点对数

而对于每一个点，总共只有三张情况下可以使得选定的两个点的lca为这一个点。

1. 两个点在它的两棵不同子树上
	
   如图,5和4的lca是1

   ![](https://cdn.luogu.com.cn/upload/image_hosting/04c7moyr.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
1. 一个点是他本身，另一个点在他的一颗子树上
	
   如图，1和5的lca是1
   
   ![](https://cdn.luogu.com.cn/upload/image_hosting/kfwr44h1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
1. 两个点都是他本身，这里懒得放图

这里我们对于每一个点，我们只需要记录下以他为根的子树的结点个数，就可以通过运算求出答案了。

部分代码如下：
```cpp
//u是当前节点，v是它的儿子
for(int i=1;i<=n;i++){
	int u=i;
	for(int j=head[u];j;j=edge[j].next){
		int v=edge[j].to;
		if(fa[u]==v)continue;
		ans[u]+=(size[u]-size[v])*size[v];
		ans[u]%=10000000007;
	}	
	ans[u]=(ans[u]+size[u])%10000000007;			
}
```

然后就可以AC了

上完整代码（~~大家最关注的地方~~）
```
#include<bits/stdc++.h> 
using namespace std;
const int N=100005;
struct Edge{
	int next,to;
}edge[N*2];
int head[N],en,size[N];
void add(int u,int v){
	edge[++en].next=head[u];
	head[u]=en;
	edge[en].to=v;
	return;
}
int fa[N],n,r,m;
long long ans[N];
void dfs(int u){
	size[u]=1; 
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(fa[u]!=v){
			fa[v]=u;
			dfs(v);
			size[u]+=size[v];
		}
	}
	return; 
}
int main(){
	cin>>n>>r>>m;
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs(r);
	for(int i=1;i<=n;i++){
		int u=i;
		for(int j=head[u];j;j=edge[j].next){
			int v=edge[j].to;
			if(fa[u]==v)continue;
			ans[u]+=(size[u]-size[v])*size[v];
			ans[u]%=10000000007;
		}	
		ans[u]=(ans[u]+size[u])%10000000007;			
	}
	for(int i=1;i<=m;i++){
		int u;
		scanf("%d",&u);
		printf("%lld\n",ans[u]);
	}
	return 0;
}
```
感谢[Graph Editor](https://csacademy.com/app/graph_editor/)提供的画图支援

---

## 作者：LinkZelda (赞：3)

刚学完倍增LCA的来介绍自己的~~乱搞~~解题过程：

 - ### 直接暴力枚举 LCA  $O$（$n^2\log n $）45pts:
直接按照题意，暴力找每个点对的[最近公共祖先](https://www.luogu.com.cn/problem/P3379)，代码如下：~~（其实加个快读和O2应该可以拿50pts的）~~
```cpp
#include<cstdio>
#include<vector>
using namespace std;
vector<int>G[50005];

void add(int u,int v)//存图 
{
	G[u].push_back(v);
	G[v].push_back(u);
 } 

int fa[50005][35],deep[50005],lg[50005],n,m,s;

void dfs(int now,int father)
{
	 
	fa[now][0]=father;//向上跳 2^0 就是跳到父亲
	deep[now]=deep[father]+1;//自己的深度就是父亲深度加一
	for(int i=1;i<=lg[deep[now]];i++)//处理向上跳 2^i 到达的点 
	{
		fa[now][i]=fa[fa[now][i-1]][i-1];//从 now 向上跳 2^i 可到达从 now 向上跳 2^(i-1) 再向上跳 2^(i-1) 所到达的点 
	 } 
	for(int i=0;i<G[now].size();i++)
	{
		if(G[now][i]!=father)dfs(G[now][i],now);//再处理一下自己儿子的信息 
	}
}

int LCA(int x,int y)
{
	if(deep[x]<deep[y])swap(x,y);//保证 x的深度大
	while(deep[x]>deep[y])//让两个点深度一样 
	{
		x=fa[x][lg[deep[x]-deep[y]]-1];//快快跳 
	 } 
	if(x==y)return x;//如果两点为同一点 (y是x的祖先), 直接返回
	for(int k=lg[deep[x]]-1;k>=0;k--)//倒着枚举2^k,看看能不能到同一点 
	{
		if(fa[x][k]!=fa[y][k])//避免跳过头
			x=fa[x][k],y=fa[y][k]; 
	 } 
	return fa[x][0];//x 的父亲就是lca 
 } 
 
int main()
{
	int n,r,m,ans[10005]={0};
	scanf("%d%d%d",&n,&r,&m);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i=1;i<=n;i++)//预处理出 log_2(i)+1 的值 
	{
		lg[i]=lg[i-1]+(1<<lg[i-1]==i);
	 } 
	 dfs(r,0);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int lca=LCA(i,j);
			ans[lca]++;
		}
	}
	for(int i=0;i<m;i++)
	{
		int p;
		scanf("%d",&p);
		printf("%d\n",ans[p]);
	}
	return 0;
 } 
```



 - ### 正解：$dfs$ + 找规律 $O$（$n+m$）:
 我们看一下样例给的图，~~很容易~~就可以找规律发现：
 $$ans[p]=size[p]^2-\sum_isize[i]^2
 $$
 其中 $i$ 表示 $p$ 的子节点，然后我们只需要 $dfs$ 一次全部节点的子树大小，然后再求出结果即可。
 
 有一个细节：我们发现 $n\leq m$ ,所以我们可以开一个数组记忆化一下，然后就可以完美 $AC$ 啦：
 
```cpp
#include<cstdio>
#include<vector>
#include<algorithm> 
using namespace std;
vector<int>G[10005];
void add(int u,int v)//存图
{
	G[u].push_back(v);
	G[v].push_back(u);
}
int size[10005],fa[10005],ans[10005];//size记录子树大小，fa记录每个节点的父亲，ans记忆化答案

int dfs(int now,int father)//dfs一下算子树大小
{
	size[now]=1;
	fa[now]=father;
	for(int i=0;i<G[now].size();i++)
	{
		if(G[now][i]!=father)size[now]+=dfs(G[now][i],now);
	}
	return size[now];
}

int main()
{
	int n,m,s;
	scanf("%d%d%d",&n,&s,&m);
	for(int i=0;i<n-1;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(s,0);
	for(int i=0;i<m;i++)
	{
		int p;
		scanf("%d",&p);
		int anss=size[p]*size[p];
		if(!ans[p])for(int i=0;i<G[p].size();i++)//如果这个点还没记忆化，就算一次
		{
			if(G[p][i]!=fa[p])anss-=size[G[p][i]]*size[G[p][i]];
			ans[p]=anss;
		}
		printf("%d\n",ans[p]);//输出答案，记得空行
	}
	return 0;
}
```

---

## 作者：Viston (赞：3)

重点是树的遍历。    
因为他让你求LCA为改点的点对个数，很容易就想到DFS一遍树，把各个子树相乘，就是该点的answer了。     
至于怎么遍历.....百度搜索dfs包教包会。    
```
#include<bits/stdc++.h>
using namespace std;
struct edge{int nex;int to;}c[100002];
int a,b,d,f[100002],head[100002],tail[100002],top;
long long qz[100002];
bool vis[100002];
inline int read(){
    int X=0;char ch=getchar();
    while(isspace(ch)) ch=getchar();
    while(isdigit(ch)) X=X*10+(ch^48),ch=getchar();
    return X;
}
int dfs(int wz){
    vis[wz]=1;
    long long tot=1;
    for(int i=head[wz];i;i=c[i].nex)
        if(!vis[c[i].to]){
            long long w=dfs(c[i].to);
            qz[wz]+=tot*w*2;qz[wz]%=mod;tot+=w;
        }
    return tot;
}
inline void add(int g,int h){
    top++;
    if(!head[g]) head[g]=top;
    else c[tail[g]].nex=top;
    c[top].to=h;tail[g]=top;
}
int main(){
    a=read(),b=read(),d=read();
    for(int i=1;i<a;i++){
        qz[i]=1;
        int g=read(),h=read();
        add(g,h);add(h,g);
    }
    qz[a]=1;
    dfs(b);
    for(int i=1;i<=d;i++)
        cout<<qz[read()]<<'\n';
}

```
~~不加取模似乎也能过~~

---

## 作者：FutureThx (赞：2)

一道橙题？恶评？

### 题意简述

给出一个树和其根节点

然后有 $M$ 个询问，每次询问都有一个数 $P$ 

求这颗树中有多少对节点的 LCA 是 $P$

### 思路

很简单的一道树的遍历题

首先观察数据范围 $1 \le N \le 10^4 ,1 \le M \le 5 \times 10^4$ 

显然，普通的暴力求 LCA  肯定是不行的，会超时

这个时候观察数据可以发现，每个询问的答案都与 $P_i$ 的各个子树和相关

如果您有一些小学奥数的知识，使用排列组合的知识就可以轻松解决此题

手玩样例，很容易看出，答案就是 $ \sum\limits_{i=1}^{P_n} 
size_{P_i} \cdot (size_P - size_{P_i} ) $ 其中 $P_n$ 表示节点 $P$ 的子树个数，$size_x$ 表示以节点 $x$ 为根的子树节点和

$85pts$ 数学算法超时的同学 注意：这里 $N \le M$ ,所以必须采用记忆化节约时间

### 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;
#define MAX_N 100010
struct tree{
    vector<int> next;
}node[MAX_N];
long long son_tree[MAX_N],answer[MAX_N];
int dfs_tree(int now,int fa){
    int ans = 0,x = 1;
    for(int i = 0;i < node[now].next.size();i++){
        int v = node[now].next[i];
        if(v != fa)
            ans += dfs_tree(v,now),x = 0;
    }
    if(x == 1){
        son_tree[now] = 1;
        return 1;
    }
    son_tree[now] = ans + 1;
    return son_tree[now];
}
int main() {
    int n,r,m;
    cin >> n >> r >> m;
    for(int i = 1;i < n;i++){
        int u,v;
        cin >> u >> v;
        node[u].next.push_back(v);
        node[v].next.push_back(u);
    }
    dfs_tree(r,-1);
    for(int i = 1;i <= m;i++){
        int q,ans = 0;
        cin >> q;
        if(answer[q] != 0){
            cout << answer[q] << endl;
            continue;
        }
        for(int i = 0;i < node[q].next.size();i++){
            int v = node[q].next[i];
            if(son_tree[v] < son_tree[q])
                ans += son_tree[v] * (son_tree[q] - son_tree[v]);
        }
        answer[q] = (ans + son_tree[q]) % 1000000007;
        cout << answer[q] << endl;
    }

    return 0;
}

```

### 后记

$Updata \ 2020.11.16 \ $ 完成题解

---

## 作者：Argon_Cube (赞：1)

* **【题目链接】**

[Link:P5002](https://www.luogu.com.cn/problem/P5002)

* **【解题思路】**

首先，我们要思考一下在什么情况下 $P_i$ 与 $P_j$ 的LCA是 $P_r$。

* $P_i$ 与 $P_j$ 在两个 $P_r$ 的不同的子树内。（拿样例来说，假设 $P_j=1$，则 $P_i\in\{2,4,5\},P_j\in\{3,6,7\}$ 或 $P_i\in\{3,6,7\},P_j\in\{2,4,5\}$）

* $P_i=P_r$ 或 $P_j=P_r$。（即有一个点是根节点，也可以两个点都是根节点。）

于是，我们就可以开始做了：

首先，我们只有这些边是没法确定父节点和子节点的关系的。

于是我们要理一下这些信息。

我们可以从根节点开始，一个一个地根据这些信息遍历树：

1. 遍历连接这个点的每条边，如果这条边上的另一个点已经被遍历过，说明这是父节点；如果没有就是子节点。

2. 对遍历到的子节点重复第一步。

3. 遍历完所有的边后，如果本步的点是根节点，结束处理。如果不是，返回父节点（结束本层递归）。

那么，如何统计符合条件的 $(P_i,P_j)$ 呢？（以下均默认点对无序）

首先，我们应该统计每个节点的子节点数。这个可以在遍历树的过程中顺便完成。

接着，假设 $P_r$ 有 $cnt$ 个子树，第 $i$ 个子树有 $node_i$ 个节点，则满足开头提到的条件 $2$ 的点对个数为：

$$\sum_{i=1}^{cnt}node_i$$

其实就是每一个节点都可以和根节点配对。

满足条件 $1$ 的点对个数为：

$$\sum_{i=1}^{cnt-1}\sum_{j=i+1}^{cnt}node_inode_j$$

即每一个节点都可以和其他子树的任一节点配对。

注意到点对是有序的，所以结果为：

$$2\left[\left(\sum_{i=1}^{cnt}node_i\right)+\sum_{i=1}^{cnt-1}\sum_{j=i+1}^{cnt}node_inode_j\right]+1$$

没错，因为这里算不到 $(1,1)$，所以要加一。

注意到计算这个式子的复杂度为 $\Theta(cnt^2)$，会T。

* **如何优化？**

以下均默认点对无序。

注意到，

$$\sum_{i=1}^{cnt}node_i$$

即为 $P_r$ 的子节点个数。这里我们可以在遍历树的过程中顺便处理。

而

$$
\sum_{i=1}^{cnt-1}\sum_{j=i+1}^{cnt}node_inode_j
$$
$$=\sum_{i=2}^{cnt}node_i\sum_{j=1}^{i-1}node_j$$

它的意义是：每搜索到一个新子树，它每个节点都可以和以前搜到的所有子树的任一节点配对。

设前 $k$ 个子树的节点数和为 $nodesum_k$，则显然有

$$nodesum_k=\begin{cases}node_1&k=1\\nodesum_{k-1}+node_k&k>1\end{cases}$$

式子化为

$$\sum_{i=2}^{cnt}node_inodesum_{i-1}$$

而每一轮的 $nodesum_i$ 都可以由前一轮的 $nodesum_{i-1}~\Theta(1)$ 推出。

于是，计算这个式子的时间复杂度降到了 $\Theta(cnt)$。

* **【实现细节】**

注意到每个点的

$$\sum_{i=2}^{cnt}node_inodesum_{i-1}$$

与

$$\sum_{i=1}^{cnt}node_i$$

均可以在遍历树时顺便全部预处理。

于是，整个程序的时间复杂度为 $\Theta(N+M)$。

不用对每个节点单独开桶记录答案。

还有，本题不用取模。

因为，本题中答案最多为 $(10^4)^2+1=10^8+1$，**远远达不到** $\mathbf{10^9+7}$。

* **【代码实现】**

```cpp
#include <iostream>
#include <vector>
#include <bitset>
#include <array>

using namespace std;

array<vector<int>,10001> tree;
array<int,10001> cnt_son;//记录满足条件2的点对数，即每个节点的子节点数
array<int,10001> cnt_pairs;//记录满足条件1的点对数
bitset<10001> is_searched;

int construct_tree(int root)//遍历树+预处理
{
	vector<int> tmp_sons;
	int tmp;
	tmp_sons=move(tree[root]);
	tree[root].clear();
	for(int i=0;i<tmp_sons.size();i++)//核心部分
		if(!is_searched[tmp_sons[i]]&&(is_searched[tmp_sons[i]]=true))
			tree[root].push_back(tmp_sons[i]),tmp=construct_tree(tmp_sons[i]),
			cnt_pairs[root]=cnt_pairs[root]+cnt_son[root]*tmp,cnt_son[root]+=tmp;
	return cnt_son[root]+1;//返回该子树的节点数
}

int main(int argc,char* argv[],char* envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int cntpoint,cntquery,node_a,node_b,root;
	cin>>cntpoint>>root>>cntquery;
	for(int i=0;i<cntpoint-1;i++)
		cin>>node_a>>node_b,tree[node_a].push_back(node_b),tree[node_b].push_back(node_a);
	is_searched[root]=true;
	construct_tree(root);
	while(cntquery--)
		cin>>root,cout<<(cnt_son[root]+cnt_pairs[root])*2+1<<endl;
	return 0;
}

```

---

## 作者：BreakPlus (赞：1)

### Update on 2020.11.18 

好多错误，改正一下而已。

----

[原题传送门](https://www.luogu.com.cn/problem/P5002)

## Part1 部分分算法

听说第一个点 $M=0$，所以直接一个 ```main(){}//zcy吊打集训队``` 就可以过第一个点了。

另外如果用暴力的思想，枚举树上的两个点进行 LCA，听说能拿 $85pts$。

~~管理员能不能把部分分的数据范围加上去啊~~

## Part2 由浅入深进行讨论

### Part2.1 如果这是一棵二叉树

1. $P_i$ 和其本身的 LCA 就是 $P_i$。
2. $P_i$ 和其两个子树的任意一个节点的 LCA 是 $P_i$。
3.  $P_i$ 的左子树和右子树中分别取一个节点，它们的 LCA 是 $P_i$。

我们不妨先一个 dfs 求出每一个子树的大小，然后求答案。

### Part2.2 如果这是一棵多叉树

从 Part2.1 的思路推导而来：

1. $P_i$ 和其本身的 LCA 就是 $P_i$。
2. $P_i$ 和其子树中的任意一点的 LCA 是 $P_i$
3. $P_i$ 子树中任取两棵子树，分别区它们的任意两点的的 LCA 是 $P_i$

把 1,2 两点结合，得 $Ans1=2\times Size_{P_i} -1$

第三点简单讲就是 $Ans2= (u,v)$ 的个数，其中 $u,v$ 为 $P_i$ 的两个子树中的节点。

最终答案为 $Ans1+Ans2$。

仔细看看第三点（（（

艹这不就是联合权值嘛！[P1351](/problem/P1351)

推一下柿子，对于每一棵子树他和其他任意子树中分别取俩点，LCA 为 $P_i$ 的是（设 $P_i$ 的子树为 $z_1 \sim z_k$，该子树为 $z_u$）：

$\color{blue}\sum \limits_{i=1}^k (Size_{z_u}\times Size_{z_i}) \color{black} - \color{red}{Size_{z_u}}^2$

我们不如把蓝色部分和红色部分分别维护。

不难发现对应所有子树之和推一下就是 $\sum \limits_{i=1}^k (Size_{z_u}\times Size_{z_i}) -(\sum  \limits_{i=1}^k Size_{z_u})^2$，前面部分就等价于 $(Size_{P_i}-1)^2$，那么这个问题就解决了！

## Part3 Code

```cpp
/*
  Author: BreakPlus
  Online Judge: Luogu
  Problem: P5002
  Date: 2020/8/17
*/
#include<cstdio>
#include<vector>
using namespace std;
vector<int>vec[10010];
int n,r,m,l,t,p;
int sz[10010],ans[10010];
void sizing(int x,int f)
{
  int len=vec[x].size();
  int ans1=0;
  sz[x]=1;
  for(register int i=0;i<len;i++)
  {
    int tmp=vec[x][i];
    if(tmp==f) continue;
    sizing(tmp,x);
    sz[x]+=sz[tmp];
    ans1+=sz[tmp]*sz[tmp];
  }
  int ans3=2*sz[x]-1+(sz[x]-1)*(sz[x]-1)-ans1;
  ans[x]=ans3;
}
int main()
{
  scanf("%d%d%d",&n,&r,&m);
  for(register int i=1;i<n;i++)
  {
    scanf("%d%d",&l,&t);
    vec[l].push_back(t);
    vec[t].push_back(l);
  }
  sizing(r,0);
  for(register int i=1;i<=m;i++)
  {
    scanf("%d",&p);
    printf("%d\n",ans[p]);
  }
  return 0;
}
```

---

## 作者：木木！ (赞：1)

给一个预处理$\Theta(n)$，查询$\Theta(1)$的做法。

一遍`DFS`就能求出各个子树的大小和自己的大小。分情况讨论，一种情况是前面一个元素在`x`的子树上，另一种是前面一个元素在`x`上。

对于第一种情况，我们枚举一遍子树，累加出$(siz[x]-siz[ch])\times siz[ch]$。对于第二种情况，容易得出就是$siz[x]$。

最终只需要`DFS`一遍，时间复杂度为$\Theta(n)$。不需要开$long\space long$。

附AC代码：

```cpp
#include <cstdio>
using namespace std;

#define mod 1000000007

int beg[10005];
int ed[20005];
int nxt[20005];
int top;

void addedge(int a,int b)
{
	++top;
	ed[top] = b;
	nxt[top] = beg[a];
	beg[a] = top;
}

int fa[10005];
int siz[10005];
int ans[10005];

void dfs(int x)
{
	siz[x] = 1;
	for(int p=beg[x]; p; p=nxt[p])
		if(ed[p]!=fa[x])
		{
			fa[ed[p]] = x;
			dfs(ed[p]);
			siz[x] += siz[ed[p]];
		}

	for(int p=beg[x]; p; p=nxt[p])
		if(ed[p]!=fa[x])
		{
			ans[x] += siz[ed[p]]*(siz[x]-siz[ed[p]]);
			ans[x] %= mod;
		}

	ans[x] += siz[x];
	ans[x] %= mod;
}

int main()
{
	int n,r,m;
	scanf("%d%d%d",&n,&r,&m);
	for(int i=1; i<n; ++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		addedge(a,b);
		addedge(b,a);
	}

	dfs(r);

	for(int i=1; i<=m; ++i)
	{
		int x;
		scanf("%d",&x);
		printf("%d\n",ans[x]);
	}
}
```

---

## 作者：King丨帝御威 (赞：1)

首先，我是用搜索套一个树型dp的思想做的，~~可能我太弱了，只会搜索吧~~……

废话不多说，这道题可以考虑一个类似树型dp的思想，先求出对于每个节点的子树的结点数，这里设第i个结点子树结点数为f[i],用搜索从下往上更新即可，然后进行第二次搜索，我们可以发现，以i点为LCA的点对的个数，等于f[i]+sigma(f[j]*(f[i]-f[j]))，其中j为i的子结点。然后这次搜索自上而下更新。之后就可以先预处理出f数组和ans数组，最后O(1)查询。

具体实现看代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#define ll long long
#define maxn 10001
#define mod 1000000007
using namespace std;
int n,num,r,m,head[maxn],f[maxn];   //f为一个结点的子树结点个数。
ll ans[maxn];               //ans就是以i点为LCA的点对的个数，模数都到了1e9+7了，显然要开long long。
inline int qread()             //快读。
{
	char c=getchar();int num=0,f=1;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) num=num*10+c-'0';
	return num*f;
}
struct node
{
	int v,nxt;
}e[100001];
inline void ct(int u,int v)    //链式前向星存图。
{
	e[++num].v=v;
	e[num].nxt=head[u];
	head[u]=num;
}
void dfs1(int u,int fa)    //第一次搜索，更新f数组。
{
	f[u]=1;
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v!=fa)
		{
			dfs1(v,u);
			f[u]+=f[v];	
		}
	}
}
void dfs2(int u,int fa)            //第二次搜索，更新ans数组。
{
	ans[u]=f[u];
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].v;
		if(v!=fa)
		{
			ans[u]+=(f[v]*(f[u]-f[v]))%mod;
			ans[u]%=mod;
			dfs2(v,u);
		}
	}
}
int main()
{
	n=qread(),r=qread(),m=qread();
	for(int i=1,u,v;i<n;++i)
	{
		u=qread(),v=qread();
		ct(u,v);
		ct(v,u);
	}
	dfs1(r,0);
	dfs2(r,0);
	for(int i=1,u;i<=m;++i)        //O(1)查询。
	{
		u=qread();
		cout<<ans[u]<<'\n';
	}
	return 0;
}
```

代码仅供参考，最好还是自己写。

---

## 作者：风火 (赞：1)

# 其实很简单啦
由题目的意思：

我们就要考虑每个点的答案是由什么贡献的，

于是我们发现每一个点的答案必然是和他的儿子有关的
继而发现，

## 每一个点的答案就是

他自身与所有儿子的连线与他所有儿子中$任意两个不在同一个子树里面的儿子之间的连线$

所以我们就可以愉快的统计答案了，只要一遍dfs就可以完成，要记得 * 2，因为每个点对有2个答案

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <map>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;
#define inf 0x3f3f3f3f
typedef long long ll;
const int oo=1e5+24;
int n,rt,m,cnt;
int h[oo];
ll ans[oo],siz[oo];
struct cx{
    int nxt,to;
}p[oo<<1];
inline int reade_int(){
    int x=0,f=0; char ch=getchar();
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f ? -x : x;
}
void adde(int x,int y){
    p[++cnt].nxt=h[x];
    p[cnt].to=y;
    h[x]=cnt;
}
void dfs(int x,int fa){
    siz[x]=1;
    for(int i=h[x];i;i=p[i].nxt){
        int u=p[i].to;
        if(u==fa) continue ;
        dfs(u,x);
        ans[x]+=siz[u]*(siz[x]-1)*2;
        siz[x]+=siz[u];
    }
    ans[x]+=siz[x]*2-1;
    return ;
}
int main(){
    n=reade_int(); rt=reade_int(); m=reade_int();
    for(int i=1;i<n;i++){
        int a=reade_int(),b=reade_int();
        adde(a,b); adde(b,a);
    }
    dfs(rt,0);
    for(int i=1;i<=m;i++){
        int x=reade_int();
        printf("%lld\n",ans[x]);
    }
    return 0;
}
```

---

## 作者：Lacrymabre (赞：0)

题意简述：给定一棵树和 $m$ 个点，求给出的点中有多少个点 为任意二元组 $(u_i,v_i)$ 的 LCA。

首先拿到这个题目，很高兴地写了个 LCA 板子对每个 $m_i$ 进行计算操作，没想到只拿了 $45pts$, TLE。

认真分析发现，若一组节点 $u_i,v_i$  LCA 为点 $p$ 那么

1. 节点 $p$ 的子树里面随便取得两棵子树的 LCA 都是 $p$ 
2. 点 $p$ 和点 $p$ 下任意一棵子树的 LCA 为 $p$
3. $u_i,v_i$ 总在 $p$ 的不同子树中。

遍历 $p$ 的儿子，每一个儿子的子树大小乘上 $p$ 子树中除了刚刚计算的子树的大小，最后加上 $p$ 的大小。


注意到 $N≤M$ 所以可能要重复问一个点，记得开个桶全部记录答案更快哦；

```
#include<bits\stdc++.h>
#define ll long long
#define N 100001
using namespace std;

inline long long read()
{
    ll f=1,s=0;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*f;
}

const int mod=1e9+7;
ll n,m,s,x,y,z,maxdep;
ll siz[100001],Ans[100001];
ll dep[100001],deep[100001];
ll f[100001][22],lg[100001],dis[100001];
ll from[N*2],net[N*2],to[N*2],cnt,v[N*2];

inline void add(ll x,ll y){
	to[++cnt]=y;
//	v[cnt]=var;
	net[cnt]=from[x];
	from[x]=cnt;
}

void dfs(ll now,ll fa,ll ifuckccf){
	//f[now][0]=fa;
	dep[now]=dep[fa]+1;
	siz[now]=1;
	//for(int i=1;i<=lg[dep[now]];i++) f[now][i]=f[f[now][i-1]][i-1];
	for(int i=from[now];i;i=net[i]) if(to[i]!=fa) dfs(to[i],now,ifuckccf+1),siz[now]+=siz[to[i]]%mod;
}

ll LCA(ll x,ll y){
	if(dep[x]<dep[y]) swap(x,y);
	while(dep[x]>dep[y])
		x=f[x][lg[dep[x]-dep[y]]-1];
	if(x==y) return x;
	for(int i=15;i>=0;i--)
		if(f[x][i]!=f[y][i])
			x=f[x][i],y=f[y][i];
	return f[x][0];
}

bool cmp(ll a,ll b){
	return a>b;
}

ll cheakall(ll now){
	ll res=x=siz[now];
	for(int i=from[now];i;i=net[i]){
		if(dep[to[i]]<dep[now]) continue;
		y=siz[to[i]];
		res+=(long long)((x-y)*y)%mod;
	}
	return res;
}

int main(){
	n=read();s=read();m=read();
	for(int i=1;i<n;i++){
		x=read();y=read();
		add(x,y);add(y,x);
	}
	for(int i=1;i<=n;i++) lg[i]=lg[i>>1]+1;
	dfs(s,s,1);
	for(int i=1;i<=n;i++) Ans[i]=cheakall(i);
 	while(m-->0) cout<<Ans[read()]<<endl;
	 return 0;
} 
```


---

## 作者：SIXIANG32 (赞：0)

一道很有趣的题，一看就不是一道 LCA。  
我才不会告诉你我犯了一个弱智推柿子错误导致保龄……  
阅读前请注意，处于习惯我用 $u$ 代表这个点，$v$ 代表 $u$ 的某个儿子。  
闲话少说，切入正题。

---
首先，看着这友好的数据范围就知道单纯的暴力 LCA 是不行的，不然这题也没啥意思对吧，然后一眼就是数学那方面想。  

不难得出这样一条结论，就是只有两点于 $u$ 不同的子树上，这两点的 LCA 才是 $u$。因为如果两点于同一个子树，那么至少可以跳到更浅的这颗子树的根，所以一定是这样。  

然后对于每个点，我们要把它们的贡献分为两类：  
1. 元素在 $u$ 的子树上，非 $u$。    
	这种状况是该题的核心。首先，我们要预处理每个子树和，因为上面说了这是和子树有关的。  
   然后呢根据常识，除去这个点 $v$ 的子树大小 $siz_v$，则是有剩下 $siz_u-siz_v$ 个可选的。根据乘法原理，每个 $v$ 的贡献为：$(siz_u-siz_v)\times siz_v$。
2. 有元素是 $u$  
	在这种状况下我就无需多废口舌了，肯定都知道肯定带来的贡献为 $siz_u$。  
    
然后我们 DFS 根据上面的贡献预处理一下，就能用 $O(n)$ 的预处理，$O(1)$ 时间复杂度完美 AC！  
代码：  
```cpp
#include<iostream>
#include<vector>
#define int long long
#define Mod 1000000007
#define MAXN 10000
using namespace std;
int siz[MAXN+10],ans[MAXN+10];
vector<int>gra[MAXN+10];
int n,m,r;
void link(int x,int y)
{
	gra[x].push_back(y);
	gra[y].push_back(x);
}
void dfs(int u,int fa)
{
	siz[u]=1;//算上自己，同时叶子节点子树为 1
	int rest=1;
   //算子树和
	for(int p=0;p<gra[u].size();p++)
	{
		int v=gra[u][p];//儿子
		if(fa!=v)//这是无向图，如果跟着父亲跑就会无限打转
		{
			dfs(v,u);//找 v 的子树
			siz[u]=(siz[u]+siz[v])%Mod;//记得取余！
		}
	}
	for(int p=0;p<gra[u].size();p++)//统计贡献
	{
		int v=gra[u][p];
		if(fa!=v)
			ans[u]=(ans[u]+((siz[u]-siz[v])*siz[v])%Mod)%Mod;//1 类贡献
	}
	ans[u]=(ans[u]+siz[u])%Mod;//2 类贡献
}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin>>n>>r>>m;
	for(int p=1,x,y;p<=n-1;p++)
	{
		cin>>x>>y;
		link(x,y);
	}
	dfs(r,0);
	for(int p=1,x;p<=m;p++)
		cin>>x,cout<<ans[x]<<endl;
}
```


---

## 作者：mot1ve (赞：0)

一道披着LCA外衣的组合计数题。

一开始的思路：暴力求解，$O(n^2logn)$，咳咳。

想正解吧，分析一下样例。

![](https://cdn.luogu.com.cn/upload/image_hosting/65tbitjo.png)

对于以 $1$ 为LCA的点对共有31组，这31组是怎么来的呢？

我们可以看出，LCA为1的点对 $(x,y)$ ，要么 $x,y$ 其中有一个是1，要么分居于1的两棵不同的子树下。

其中有一个是1的点对个数是 $(size[1]-1)*2+1$。

分居于1的两棵不同子树下的点对个数是两两子树大小的乘积。

答案其实已经出来了，但这样在代码实现里不太好统计。

我们可以把答案重新整理一下，拆成两部分，对于子树两两乘积，写作$size[v]*(size[lca]-size[v])$ 因为每一棵子树都可以和除了这个子树的其他在lca子树下的点构成一个合法的点对。

最后加上点对 (lca,子树内每个点) ，也就是 $size[i]$ 。

总答案 $size[i]+size[v]*(size[lca]-size[v])$ 。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int idx,n,r,m,res;
int head[100010],size[100010],dep[100010],ans[100010];
struct node{
	int nxt,to;
}edge[200010];
void add(int u,int v)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
void dfs(int now,int fath)
{
	dep[now]=dep[fath]+1;
	size[now]=1;
	for(int i=head[now];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fath)
		continue;
		dfs(v,now);
		size[now]+=size[v];
	}
}
signed main()
{
	cin>>n>>r>>m;
	for(int i=1;i<=n-1;i++)
	{
		int u,v;
		scanf("%lld%lld",&u,&v);
		add(u,v);
		add(v,u); 
	}
	dfs(r,0);
	for(int i=1;i<=n;i++)//预处理出每个点的答案
	{
		ans[i]=size[i];
		for(int j=head[i];j;j=edge[j].nxt)
		{
			int v=edge[j].to;
			if(dep[v]<dep[i])
			continue;
			ans[i]+=((size[i]-size[v])*size[v]);
		}
	} 
	while(m--)//O(1)查询 
	{
		int x;
		scanf("%lld",&x);
		printf("%lld\n",ans[x]);
	}
	return 0;
}
```

---

## 作者：Mine_King (赞：0)

我们考虑什么情况下点对 $(u,v)$ 的 $LCA$ 为 $p$？首先，$p$ 必须是 $u,v$ 的祖先。然后，满足这个条件下：

- $u,v$ 中的任意一个是（或两个都是）$p$，$LCA(u,v)=p$。
- $u,v$ 在 $p$ 的子树中的任意两棵不同的子树中，$LCA(u,v)=p$。如果他们在同一棵子树中的话，那么他们的公共祖先就会有这棵子树的根，而这棵子树的根明显是比 $p$ 更近的。

对于第一个情况，我们把答案记做$ans1$；对于第二种情况，我们把答案记做$ans2$；最终结果记做$Ans$。

第一种情况：

首先，当 $u,v$ 都等于 $p$ 时，这种情况的数量为 $1$。然后，只有一个等于 $p$ 时，数量为 $2 \times (size_p - 1)$（这里 $size_i$ 表示 $i$ 的子树大小，下同），因为 $u = p$时为$size_p - 1$，$v=p$ 时也一样，所以要乘 $2$。那么，最终的 $ans1$ 就是

$$ans1 = 2 \times size_p - 1$$

然后是第二种情况：

这种情况下，很明显就可以得到

$$ans2=\sum\limits_{i=1}^k \sum\limits_{j=1}^k size_{son_i} \times size_{son_j}$$
$$=\sum\limits_{i=1}^k size_{son_i} \times (size_p - 1)$$
$$=(size_p - 1) \times (size_p - 1)$$

(这里的 $son_i$ 表示 $p$ 的第 $i$ 个儿子，$k$ 表示 $p$ 的儿子数量，下同)

上面那个式子看上去好像没什么问题，但忘记处理 $i = j$ 的情况了。所以还要再减去 $\sum\limits_{i=1}^k size_{son_i} \times size_{son_i}$，也就是

$$ans2 = (size_p - 1) \times (size_p - 1) - \sum\limits_{i=1}^k size_{son_i} \times size_{son_i}$$

那么最终结果就是

$$Ans=ans1+ans2$$
$$= 2 \times size_p - 1 + (size_p - 1) \times (size_p - 1) - \sum\limits_{i=1}^k size_{son_i} \times size_{son_i}$$
$$= size_p \times size_p - \sum\limits_{i=1}^k size_{son_i} \times size_{son_i}$$

然后呢，我们发现这个 $m$ 可能会大于 $n$，所以我们可以 $O(n)$ 预处理出所有的答案，最终 $O(1)$ 查询。  
另外，这题的 $Ans$ 最大为 $n^2$，所以取不取模都没关系。  

**code:**
```cpp
#include<cstdio>
using namespace std;
int n,r,m,size[10005],ans[10005];
//size意义同上，ans为答案
struct graph//链式前向星存图
{
	int tot;
	int hd[10005];
	int nxt[20005],to[20005];
	void add(int u,int v)
	{
		tot++;
		nxt[tot]=hd[u];
		hd[u]=tot;
		to[tot]=v;
		return ;
	}
}g;
void dfs(int now,int f)//预处理
{
	size[now]=1;
	int sum=0;//sum即为上面的式子中要减去的那一坨
	for(int i=g.hd[now];i;i=g.nxt[i])
		if(g.to[i]!=f)//判掉父节点
		{
			dfs(g.to[i],now);
			size[now]+=size[g.to[i]];//记录size
			sum+=size[g.to[i]]*size[g.to[i]];//记录答案
		}
	ans[now]=size[now]*size[now]-sum;//记录最终答案
	return ;
}
int main()
{
	scanf("%d%d%d",&n,&r,&m);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		g.add(u,v);
		g.add(v,u);
	}
	dfs(r,0);
	for(int i=1;i<=m;i++)
	{
		int p;
		scanf("%d",&p);
		printf("%d\n",ans[p]);
	}
	return 0;
}
```

---

## 作者：HPXXZYY (赞：0)

$\color{blue}{\texttt{[Problem]}}$

- 给你一棵以 $r$ 为根的含有 $n$ 个点的树和一个序列 $P_{1..m}$。
- 要求对于每个 $P_i(1 \leq i \leq m)$，求出有多少对 $(u_j,v_j)$ 满足 $u_j$ 和 $v_j$ 的最近公共祖先（即常说的 $\texttt{LCA}$）。
- 答案对 $1 \times 10^9+7$ 取模。$1 \leq n \leq 1 \times 10^4,1 \leq m \leq 5 \times 10^4$。

---------------------------------------

$\color{blue}{\texttt{[Solution]}}$

记 $s_u$ 表示以 $u$ 为根的子树中有多少个节点，一遍 `dfs`，即可求出所有的 $s_i(1\leq i \leq n)$。该步时间复杂度为 $O(n)$。

考虑 $\texttt{LCA}$ 的性质：如果两个节点的 $\texttt{LCA}$ 为点 $u$，那么要么其中一个点是点 $u$，另一个点为 $u$ 的后代，要么这两个点分属 $u$ 的两棵子树。

配上图应该好理解一点：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531134857604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

这是我们的原树，然后我们钦定一个点为 $u$：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531134947683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

我们发现，如果两个点中有任意一个点不是 $u$ 或者 $u$ 的后代，那么它们的 $\texttt{LCA}$ 都不可能是 $u$。

当一个点是 $u$，另一个点为 $u$ 的后代时，大概是这样：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531135242593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

红色框线代表我们所选的两点，显然它们的 $\texttt{LCA}$ 就是 $u$。大家可以举另外的例子。

当两个点都不是 $u$ 时，它们必须分属 $u$ 的两棵子树，其 $\texttt{LCA}$ 才是 $u$。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531135558929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

如图，当两个点在 $u$ 的同一颗子树时，显然它们的 $\texttt{LCA}$ 不是 $u$。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200531135649578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

只有当两个点分属 $u$ 的任意两棵子树时，它们的 $\texttt{LCA}$ 才是 $u$。

考虑每种情况对答案的贡献：

- 情况一：其中第一个点是 $u$，另一个点是 $u$ 的后代，所以总的可能情况为 $1 \times (s_u-1)$ 种。注意！由于本题允许有 $u_j=v_j$ 的情况，所以一共有 $s_u$ 种方案。注意这里不包括第二个点为 $u$ 的情况。
- 情况二：我们选定一个点在 $u$ 的一棵子树 $y$ 中，有 $s_y$，另外一个点即有 $s_u-s_y$ 种情况，注意另外一个点为 $u$ 的情况上面为考虑，所以这里不需要减一。总方案数为 $s_y \times (s_u-s_y)$。枚举 $y$ 并统计即可。

好，既然如此，我们再来一遍 `dfs`，分这两种情况讨论，即可求出答案。当然这两遍 `dfs` 其实是可以合并为一遍的。可以证明这一步也是 $O(n)$ 的，所以总的时间复杂度为 $O(n)$，可以通过更大的数据（比如 $1 \times 10^6$）。

------------------------------------

$\color{blue}{\texttt{[code]}}$

```cpp
const int N=1e4+100;
int ans[N],size[N],n,m;
struct edge{//链式前向星 
	int next,to;//两量存图 
}e[N<<1];int h[N],tot,root;
inline void add(int a,int b){
	e[++tot]=(edge){h[a],b};h[a]=tot;
	e[++tot]=(edge){h[b],a};h[b]=tot;
}
const int mod=1e9+7;//记得对1e9+7取模 
inline int f(int a,int b){//方便使用 
	return (size[a]-size[b])*size[b]%mod;
}//情况二的方案数计算（b为指定儿子） 
void dfs_init_and_calc(int u,int fa){
	size[u]=1;//注意初始!u也是有大小的! 
	for(int i=h[u];i;i=e[i].next){//遍历 
		register int to=e[i].to;//to:儿子 
		if (to==fa) continue;//可行性判断 
		dfs_init_and_calc(to,u);//递归计算 
		size[u]+=size[to];//累加子树的大小 
	}//前半段:求以u为根的子树的大小size[u] 
	for(int i=h[u];i;i=e[i].next){//遍历 
		register int to=e[i].to;//to:儿子 
		if (to==fa) continue;//可行性判断 
		ans[u]=(ans[u]+f(u,to))%mod;//更新 
	}
	ans[u]=(ans[u]+size[u])%mod;
//	注意LCA(u,u)也等于u,这也是方案 
}//两遍 dfs 可以合并为一遍
int main(){
//	freopen("t1.in","r",stdin);
	scanf("%d%d%d",&n,&root,&m);
	for(int i=1,u,v;i<n;i++){
		scanf("%d%d",&u,&v);
		add(u,v);//加入边(u,v) 
	}
	dfs_init_and_calc(root,-1);
	for(int i=1,u;i<=m;i++){
		scanf("%d",&u);
		printf("%d\n",ans[u]);
	}
	return 0;
}
```

---

## 作者：three_trees (赞：0)

蒻蒟的第一篇题解

------------
第一眼看上去感觉用不上lca,然后，真的用不上

我们分析一下，对于有根树上一点u，如果它是两个其他节点的lca，那么有两种情况。

1.这个其他节点中的一个是u节点，也就是说，u节点和其子树上的任意节点的lca为u节点。

2.这个两个节点分别为u节点子树节点且两个节点不在一个子树上。

我们可以设num[u]为u节点及u节点以下所有节点的数量，dp[u]为以u节点为lca的节点组合数量。由上知，第一种情况贡献num[u]对（一个节点是u节点，另一个节点有num[u]种可能）。对于第二种情况，我们可以枚举u节点的每个子节点，则这个子节点与其余节点也产生贡献，共有$\sum_{i=1}^{t}{(num[u]-zz[i])}$对。

dp[u] = (num[u] + $\sum_{i=1}^{t}{(num[u] - zz[i])}$) % mod

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 1e9 + 7;
const int N = 5e4 + 5;
const int inv2 = 500000004;
ll dp[N], num[N];
struct node 
{
    int to, next;
}edge[N];
int head[N], tot = 0;
int n, r, m;
void add(int u, int v)
{
    edge[tot].to = v;
    edge[tot].next = head[u];
    head[u] = tot ++;
}
void dfs(int u, int fa)
{
    num[u] = 1;
    vector <int> zz;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int to = edge[i].to;
        if(to == fa)
            continue;
        dfs(to, u);
        zz.push_back(num[to]);
        num[u] += num[to];
    }
    for(auto it : zz)
    {
        dp[u] = (dp[u] + (num[u] - it) * it % mod) % mod;
    }
    dp[u] = (dp[u] + num[u]) % mod;
}
int main()
{
    freopen("test.in", "r", stdin);
    ios::sync_with_stdio(false);
    memset(head, -1, sizeof(head));
    memset(dp, 0, sizeof(dp));
    memset(num, 0, sizeof(num));
    cin >> n >> r >> m;
    for(int i = 0; i < n - 1; i ++)
    {
        int u, v;
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    dfs(r, 0);
    while(m --)
    {
        int d;
        cin >> d;
        //cout << num[d] << endl;
        cout << dp[d] << endl;
    }
}
```


---

## 作者：江yyyz1911 (赞：0)

![](https://cdn.luogu.com.cn/upload/pic/37971.png)

由图可知：

计算1方案总数的步骤为：

子树2方案数：size[2]*(size[1]-aize[2])=size[1]*size[2]-size[2]^2;

子树3方案数:  size[3]*(size[1]-aize[3])=size[1]*size[3]-size[3]^2;

1自己方案数：size[1];

ans[1]=
			size[1]*size[2]-size[2]^2+size[1]*size[3]-size[3]^2+size[1]；

        =size[1]*(1+size[2]+size[3])-size[2]^2-size[3]^2;
        
        =size[1]^2-size[2]^2-size[3]^2;

由此可知：
ans[x]=size[x]^2-(x的子树的平方和);

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+4,mod=1e9+7;
int n,m,s;
int size[N],ans[N];
struct ege{
	int v,next;
}e[2*N];
int h[2*N];
int cnt;
void add(int x,int y)
{
	cnt++;
	e[cnt].v=y;
	e[cnt].next=h[x];
	h[x]=cnt;
}
void find(int x,int fa)
{
	size[x]=1;
	int sum=0;
	for(int i=h[x];i;i=e[i].next)
	{
		int v=e[i].v;
		if(v==fa) continue;
		find(v,x);
		size[x]+=size[v];
		sum=(sum+size[v]*size[v])%mod;
	}
	ans[x]=(size[x]*size[x]%mod-sum);
}
int main()
{
	scanf("%d%d%d",&n,&s,&m);
	for(int i=1;i<=n-1;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);
	}
	find(s,0);
	for(int i=1;i<=m;i++)
	{
		int p;
		scanf("%d",&p);
		cout<<ans[p]<<endl;
	}
	return 0;
}
```


---

## 作者：RocketTurtle (赞：0)

这道题emmmm自闭了许久，自己的代码找不出反例。于是借鉴了@Chhokmah对组数的处理。

我的思路和大多数人差不多，就是dfs建树+保存每颗子树的size大小。

**以下是AC代码**

先贴我的dfs代码

~~~
inline void dfs(int temp){
	for(int i=head[temp];i;i=edge[i].prev){
		int to=edge[i].to;if(to==fa[temp]) continue;
                fa[to]=temp;
		dfs(to);size[to]++;size[temp]+=size[to];
	}
}
~~~
这个dfs函数应该能看懂吧,不过记得把根节点size的初始值初始化为1。因为把每个节点的size值打印出来就会发现根节点的size值要少1。

~~~
inline void solve(){
    build(r);
    fp(i,1,m){
    	int p=read();
    	if(Ans[p]!=0) {printf("%lld\n",Ans[p]);continue;}
    	int size_rest;
    	ll num=size[p]*2-1;
    	for(int j=head[p];j;j=edge[j].prev){
    		int to=edge[j].to;
    		if(to==fa[p]) continue;
    		size_rest=size[p]-size[to]-1;
    		num=(num+(size_rest*size[to]))%Mod;
		}
		Ans[p]=num;
		printf("%lld\n",num);
	}
}
~~~
emmm这部分就是借鉴了大佬的处理方法了.....
下面就直接贴AC的全部代码吧
~~~
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int read(){
	char c=getchar();int x=0,f=1;
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x*f;
}
inline void out(int a){
	if(a<0){
		putchar('-');
		a=-a;
	}
	if(a>9) out(a/10);
	putchar(a%10+'0');
}
int n,r,m;
#define maxium 60000
#define fp(i,w,n) for(int i=w;i<=n;i++)
struct Edge{
	int to,prev;
}edge[maxium*2];
int head[20000],fa[20000],cnt;
inline void add(int x,int y){
	edge[++cnt].to=y;
	edge[cnt].prev=head[x];
	head[x]=cnt;
}
int size[20000];
inline void start(){
	n=read(),r=read(),m=read();
	fp(i,1,n-1){
		int x,y;x=read(),y=read();
		add(x,y);add(y,x);
	}
	fp(i,1,n) fa[i]=i;
	size[r]=1;
}
inline void dfs(int temp){
	for(int i=head[temp];i;i=edge[i].prev){
		int to=edge[i].to;if(to==fa[temp]) continue;fa[to]=temp;
		dfs(to);size[to]++;size[temp]+=size[to];
	}
}
inline void build(int root){
	dfs(root);
}
ll Ans[20000];
const int Mod=1e9+7;
inline void solve(){
    build(r);
    fp(i,1,m){
    	int p=read();
    	if(Ans[p]!=0) {printf("%lld\n",Ans[p]);continue;}
    	int size_rest;
    	ll num=size[p]*2-1;
    	for(int j=head[p];j;j=edge[j].prev){
    		int to=edge[j].to;
    		if(to==fa[p]) continue;
    		size_rest=size[p]-size[to]-1;
    		num=(num+(size_rest*size[to]))%Mod;
		}
		Ans[p]=num;
		printf("%lld\n",num);
	}
}
int main(){
	start();
	solve();
	return 0;
}
~~~

---

## 作者：decoqwq (赞：0)

一道比较水的树$dfs$题

我们来想一想，哪些点对$(x,y)$的最近公共祖先会是一个点$p$

$1.$ $x,y$处于$p$的不同子树内

$2.$ $x,y$中有一个是$p$

对于情况$1$，我们讲点$p$所有子树的$siz$两两相乘即可，但要注意不能枚举子树，会被那种$n-1$叉树卡死，答案为$\sum_{x\in P,y\in P,x\neq y} siz[x]*siz[y]$(设$p$所在的子树的结点集合为$P$)

对于情况$2$，有一个是点$p$，另一个点在其子树内，答案就是$siz[u]*2-1$(有一个点对为$(p,p)$，只能算一次)

然后$dfs$一遍就好了

代码${1:}$
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,r,m,fa[10010];
long long ans[10010],siz[10010];
vector<int> out[10010];
void dfs(int u)
{
    siz[u]=1;
    for(int i=0;i<out[u].size();i++)
    {
        int v=out[u][i];
        if(v==fa[u])
        {
            continue;
        }
        fa[v]=u;
        dfs(v);
        siz[u]+=siz[v];
    }
}
void makeans(int u)
{
    for(int i=0;i<out[u].size();i++)
    {
        for(int j=0;j<out[u].size();j++)
        {
            if(i==j)
            {
                continue;
            }
            int v1=out[u][i],v2=out[u][j];
            if(v1==fa[u])
            {
                break;
            }
            if(v2==fa[u])
            {
                continue;
            }
            ans[u]+=siz[v1]*siz[v2];
            ans[u]%=mod;
        }
    }
    ans[u]+=(siz[u]<<1)-1;
    ans[u]%=mod;
    for(int i=0;i<out[u].size();i++)
    {
        int v=out[u][i];
        if(v==fa[u])
        {
            continue;
        }
        makeans(v);
    }
}
int main()
{
    cin>>n>>r>>m;
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        out[x].push_back(y);
        out[y].push_back(x);
    }
    dfs(r);
    makeans(r);
    for(int i=1;i<=m;i++)
    {
        int x;
        scanf("%d",&x);
        printf("%d\n",ans[x]);
    }
}
```
很明显，这种会被$n-1$叉树卡死，我们需要优化

注意到乘法分配律，有$ab+bc=(a+c)b$，很显然，在第一种情况中，每一个子树会和其他所有子树都乘一遍，所以我们对于每个子树，直接用它的$siz$乘上总$siz$减去它的$siz$再$-1$的差即可

代码${2:}$
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,r,m,fa[10010];
long long ans[10010],siz[10010];
vector<int> out[10010];
void dfs(int u)
{
    siz[u]=1;
    for(int i=0;i<out[u].size();i++)
    {
        int v=out[u][i];
        if(v==fa[u])
        {
            continue;
        }
        fa[v]=u;
        dfs(v);
        siz[u]+=siz[v];
    }
}
void makeans(int u)
{
    for(int i=0;i<out[u].size();i++)
    {
        int v=out[u][i];
        if(v==fa[u])
        {
            continue;
        }
        ans[u]+=siz[v]*(siz[u]-siz[v]-1);
        ans[u]%=mod;
    }
    ans[u]+=(siz[u]<<1)-1;
    ans[u]%=mod;
    for(int i=0;i<out[u].size();i++)
    {
        int v=out[u][i];
        if(v==fa[u])
        {
            continue;
        }
        makeans(v);
    }
}
int main()
{
    cin>>n>>r>>m;
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        out[x].push_back(y);
        out[y].push_back(x);
    }
    dfs(r);
    makeans(r);
    for(int i=1;i<=m;i++)
    {
        int x;
        scanf("%d",&x);
        printf("%d\n",ans[x]);
    }
}
```

---


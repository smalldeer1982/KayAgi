# [COCI 2011/2012 #2] ZADAĆA

## 题目描述

给定 $N$ 个正整数 $A_1,A_2,...,A_N$ 和 $M$ 个正整数 $B_1,B_2,...,B_M$，求：

$$\gcd(\prod\limits_{i=1}^NA_i,\prod\limits_{i=1}^MB_i)$$

## 说明/提示

#### 【样例 1 解释】

$\gcd(30,20) = 10$，因此答案为 $10$。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N,M \le 1000$，$1 \le A_i,B_i \le 10^9$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $100$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #2](https://hsin.hr/coci/archive/2011_2012/contest2_tasks.pdf)** ___T3 ZADAĆA___。

## 样例 #1

### 输入

```
3
2 3 5
2
4 5```

### 输出

```
10```

## 样例 #2

### 输入

```
4
6 2 3 4
1
1```

### 输出

```
1```

## 样例 #3

### 输入

```
3
358572 83391967 82
3
50229961 1091444 8863```

### 输出

```
000012028```

# 题解

## 作者：EricWan (赞：4)

这题数据范围还是很小的，于是考虑暴力。

这里枚举 $n \times m$ 个数对，如果有公因数，就约掉，并累成在答案里。

可以发现，不可能有一个约数约不掉。

看看数据范围，$O(n \times m \times \log_2 \max\{\max_{i = 1}^{n}A_i,\max_{i = 1}^{m}B_i\})$ 能过，于是，就可以开心的写代码了。

AC 代码部分 `main` 函数：
```cpp
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++) {
		k = gcd(a[i],b[j]);
 		a[i] /= k;
		b[j] /= k;
		ans *= k;
		if (ans >= mod) flag = 1;
		ans %= mod;
	}
}
```

---

## 作者：technopolis_2085 (赞：4)

P7616 [COCI2011-2012#2] ZADAĆA 题解


------------
分析：

有两种方法。

第一种方法：

两重循环遍历数组，将 $a_i$ 和 $b_j$ 的最小公倍数算入答案，然后判断一下答案的大小就行了。

时间复杂度大概是 $O(nm)$ 再乘上最小公倍数的时间复杂度。

代码比较简单，这里不贴了。

第二种方法：

由于两个数组所有元素的乘积会太大，所以考虑分解质因数，然后看每一个质因数的指数。将指数较小的算入答案。

#### 有一点容易出错

如果有一个元素中的因子中有一个特别大的质数或者它就是一个质数，按上面的方法可能不会被考虑到。所以我们可以开两个映射表，将两个数组中特别大的质数存入。然后遍历映射表，取指数较小的，乘入答案。

时间复杂度不会太大，大致为 $n$ 再乘一个根号。


------------
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int mod=(int)1e9;

map<int,int> biga;
map<int,int> bigb;
int flag=0;

const int maxn=1e5+10;
bool f[maxn];
int prime[maxn];
int a[maxn],b[maxn];
int tot=0;

void init_prime(){//欧拉筛
	for (int i=2;i<=1e5;i++){
		if (f[i]==false) prime[++tot]=i;
		for (int t=1;t<=tot&&i*prime[t]<=1e5;t++){
			f[i*prime[t]]=true;
			if (i%prime[t]==0) break;
		}
	}
}

int cnta[maxn],cntb[maxn];

int solve(int x,int op){//分解质因数
	int i=1,cnt=0;
	
	while (x>1&&i<=tot){
		if (x%prime[i]==0){
			x/=prime[i];
			cnt++;
		}
		else{
			if (op==1) cnta[i]+=cnt;
			else cntb[i]+=cnt;
			
			cnt=0;
			i++;
		}
	}

	if (op==1) cnta[i]+=cnt;
	else cntb[i]+=cnt;
	
	return x;
}

signed main(){
//	freopen("in.txt","r",stdin);
	init_prime();
	int n,m;
	scanf("%lld",&n);
	for (int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		int x=solve(a[i],1);
		if (x!=1) biga[x]++;
	}

	scanf("%lld",&m);
	for (int i=1;i<=m;i++){
		scanf("%lld",&b[i]);
		int x=solve(b[i],2);
		if (x!=1) bigb[x]++;
	}
	
	int ans=1;
	
	for (int i=1;i<=tot;i++){
		int b=min(cnta[i],cntb[i]);
		for (int j=1;j<=b;j++){
			if (ans*prime[i]>=mod){
				flag=1;
				ans=ans*prime[i]%mod;
			}
			else ans=ans*prime[i];
		}
	}
	
	for (map<int,int>::iterator it=biga.begin();it!=biga.end();it++){
		int x=it->first;
		int b=min(it->second,bigb[x]);
		
		for (int j=1;j<=b;j++){
			if (ans*x>=mod){
				flag=1;
				ans=ans*x%mod;
			}
			else ans=ans*x;
		}
	}
	
	if (flag){
		int num[9];
		memset(num,0,sizeof(num));
		int len=0;
		while (ans>0){
			num[len]=ans%10;
			ans/=10;
			len++;
		}
	
		reverse(num,num+9);
		for (int i=0;i<9;i++) printf("%lld",num[i]);
	}else printf("%lld",ans); 
	return 0;
}
```


---

## 作者：_lfxxx_ (赞：3)

**题目传送门：[P7616 [COCI2011-2012#2] ZADAĆA](https://www.luogu.com.cn/problem/P7616)**
### 题意：
给定 $N$ 个正整数 $A_1,A_2,\cdots,A_N$ 和 $M$ 个正整数 $B_1,B_2,\cdots,B_M$ ，求：
$$\gcd(\prod_{i=1}^NA_i,\prod_{i=1}^MB_i)$$
### 思路：
1. 暴力算出两组数的积再求最大公因数。

但这要用到高精度，所以选择用 Python 。
#### Python 代码：
```python
from math import* 
n=int(input())
a=input().split()
s1=1
for i in a:
    s1*=int(i)
n=int(input())
a=input().split()
s2=1
for i in a:
    s2*=int(i)
ans=gcd(s1,s2)
if ans>999999999:
    ans%=1000000000
    print("%09d"%ans)#取最后9位
else:
    print(ans)
```
时间&空间： $161$ ms / $3.22$ MB 。

2. 分解质因数，求公共质因数，这也是平常的做法。

题目中让我们输出最后 $9$ 位，也暗示着我们要这么做。

考虑到 $10^9$ 的数据就不能直接开一个特别大的数组，于是想到 `map` 。

我选择的是开一个 `map` 存那 $n$ 个数，之后读入 $m$ 个数跟 `map` 作比较。
#### 注意：
记录公因数的变量要开 `long long` （ `unsigned long long` 也行）。

**输出最后 $9$ 位不是直接 $\bmod$ $10^9$ ，要输出前导 $0$ ！（具体请看样例3）**
#### C++代码：
```cpp
#include<iostream>
#include<map>
using namespace std;
map<int,int>M;
bool f;//标记要不要输出最后9位
const int mod=1000000000;
inline void modd(unsigned long long &x){
	if(x>=mod)
		x%=mod,f=1;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);//优化
	int n,m,a;
	unsigned long long ans=1;
	cin>>n;
	while(n--){
		cin>>a;
		while(!(a&1))
			M[2]++,a>>=1;
		for(int i=3;i*i<=a;)
			if(!(a%i))
				M[i]++,a/=i;
			else
				i+=2;//分解质因数
		M[a]++;//最后如果是质数，需要加上，如果不是，后面答案乘1相当于没变
	}
	cin>>m;
	while(m--){
		cin>>a;
		while(!(a&1))
			if(M[2]>0)
				a>>=1,modd(ans<<=1),M[2]--;
			else
				break;
		for(int i=3;i*i<=a;)
			if((!(a%i))){
				a/=i;
				if(M[i]>0)
					modd(ans*=i),M[i]--;
			}
			else
				i+=2;
		if(M[a]>0)
			modd(ans*=a),M[a]--;//在map里面找
	}
	if(f)
        cout.width(9),cout.fill('0');//除了printf还可以这么格式化输出
    cout<<ans<<endl;
	return 0;
}
```
时间&空间： $93$ ms / $748.00$ KB 。

---

## 作者：CuteMurasame (赞：3)

Update on 2023/09/02: 修改把 Ruby 打成 Python 的笔误。

来一发不一样的题解。

## 思路

首先看数据范围：$1\leq A_i,B_i\leq 10^9$，用 C++ 算 $\prod\limits_{i=1}^{N}A_i$ 或 $\prod\limits_{i=1}^{M}B_i$ 最大可以到 $(10^{9})^{1000}=10^{9000}$，肯定会爆 `__int128`，考虑自带高精度的语言。这里我们使用 Python 和 Ruby。

### Python 详解

如果你熟悉 Python，请跳过此部分。

- Python 输入列表可以使用 `<列表名>=list(map(<列表中变量类型>,input().split()))`。本题即为 `a=list(map(int,input().split()))` 和 `b=list(map(int,input().split()))`；
- Python 遍历列表元素更方便的方法是 `for i in <列表名>`，相当于 C++ 的 `for(auto i:<数组名>)`，**注意不是 `for(auto &i:<数组名>)`**；
- 至于算 $\gcd(\prod\limits_{i=1}^{N}A_i,\prod\limits_{i=1}^{M}B_i)$，用 math 库自带的函数 `math.gcd` 就行了，~~当然你想手写也可以~~；
- 我们再来看题目描述：**如果答案超过九位数，你只需输出它的最后九位即可**。这里我们可以将最终答案转成字符串，判断字符串长度并进行处理，具体代码如下：
   ```python
    ans=str(res) # res 是算出的答案
    if len(ans)>9: # 答案超过九位数
        print(ans[len(ans)-9:len(ans)]) # 截取下标为 len(ans)-9 到 len(ans) 的字符串
    else:
        print(ans) # 否则直接输出
   ```

### Python 代码

```python
import math # 导入 math 库以使用 math.gcd 函数
n=int(input())
a=list(map(int,input().split())) # 列表输入
m=int(input())
b=list(map(int,input().split())) # 列表输入
ja,jb=1,1
for i in a:
    ja*=i
for i in b:
    jb*=i
res=math.gcd(ja,jb) # 算 gcd
ans=str(res)
if len(ans)>9: # 答案超过九位数
    print(ans[len(ans)-9:len(ans)]) # 截取下标为 len(ans)-9 到 len(ans) 的字符串
else:
    print(ans) # 否则直接输出
```

### Ruby 详解

如果你熟悉 Ruby，请跳过此部分。

- Ruby 输入列表可以使用 `<列表名>=gets.split.map(&:to_i)`。本题即为 `a=gets.split.map(&:to_i)` 和 `b=gets.split.map(&:to_i)`；
- Ruby 遍历列表元素更方便的方法是 `<列表名>.each do |i|`，相当于 C++ 的 `for(auto i:<数组名>)`，**注意也不是 `for(auto &i:<数组名>)`**；
- 至于算 $\gcd(\prod\limits_{i=1}^{N}A_i,\prod\limits_{i=1}^{M}B_i)$，用自带的函数就行了。比如 $\gcd(x,y)$ 写作 `x.gcd(y)`；
- 我们再来看题目描述：**如果答案超过九位数，你只需输出它的最后九位即可**。这里我们可以将最终答案转成字符串，判断字符串长度并进行处理，具体代码如下：
   ```ruby
    ans=res.to_s # res 是算出的答案
    if ans.length>9 # 答案超过九位数
        puts ans[-9..-1] # 截取后九位
    else
        puts ans # 否则直接输出
    end
   ```

### Ruby 代码

```ruby
n=gets.to_i
a=gets.split.map(&:to_i) # 列表输入
m=gets.to_i
b=gets.split.map(&:to_i) # 列表输入
ja=1
jb=1
a.each do |i|
    ja*=i
end
b.each do |i|
    jb*=i
end
res=ja.gcd(jb) # 算 gcd
ans=res.to_s
if ans.length>9 # 答案超过九位数
    puts ans[-9..-1] # 截取后九位
else
    puts ans # 否则直接输出
end
```

---

## 作者：_Trangle_ (赞：1)

首先进入正题，这道题是要我们求 $\gcd(\prod\limits_{i=1}^na_i,\prod\limits_{i=1}^mb_i)$ ， 根据奥数知识，可得：
$$\prod\limits_{i=1}^na_i={p_1}^{c_1}\times
{p_2}^{c_2}\times\cdots{p_n}^{c_n}$$
$$\prod\limits_{i=1}^mb_i={p1_1}^{c1_1}\times{p1_2}^{c1_2}\times\cdots{p1_m}^{c1_m}$$
定义变量 $i,j(1\leqslant i \leqslant n  ,1\leqslant j\leqslant m)$ 有
$$ans=ans\times{p_i}^{\min(c_i,c1_j)}\ (p_i =p1_j)$$
接下来题目变成了两个子问题：

1. 分解 $\prod\limits_{i=1}^na_i$ 和 $\prod\limits_{i=1}^mb_i$ 的质因数。
2. 按第二个总结求出 $ans$ 。

### 接下来放代码：
```cpp
#include <stdio.h>
#include <algorithm>
#include <vector>
#define ll long long
#define pii pair<ll, ll>
using namespace std;

ll n, m, ans = 1;
ll a[1005];
bool flag;
vector<pii> f1, f2;

void mod(ll &val) {
	if (val >= 1e9) {
	    flag = 1;
	    val %= (ll)1e9;
	} //若变量大于等于1e9，那么答案要输九位
}

void zyz(ll x, vector<ll> &v) { //引用更方便
	for (ll i = 2; i * i <= x; i++)
		while (x % i == 0) {
			v.push_back(i);
			x /= i;
		}
	if (x > 1) v.push_back(x);
} //分解质因数

void factor(vector<pii> &fact) {
	scanf("%lld", &n);
	for (ll i = 1; i <= n; i++) scanf("%lld", a + i);
	vector<ll> set;
	for (ll i = 1; i <= n; i++) zyz(a[i], set);
	sort(set.begin(), set.end());
	for (auto i: set) {
		if (fact.empty() || fact.back().first != i) fact.push_back({i, 1});
		else fact.back().second++; 
	}//将序列总积分解质因数
}

ll power(ll a, ll n) {
	ll p = 1;
	while (n) {
		if (n & 1) p = p * a; mod(p); //若求幂结果大于等于1e9，答案一定大于等于1e9
		a = a * a % (ll)1e9;
		n >>= 1;
	}
	return p;
}

int main() {
	factor(f1); factor(f2);
	for (auto i1 = f1.begin(), i2 = f2.begin(); i1 != f1.end() && i2 != f2.end(); i1++) {
		while (i2 != f2.end() && (*i2).first < (*i1).first) i2++; //找两总积公共质因数
		if ((*i1).first == (*i2).first) ans = ans * power((*i1).first, min((*i1).second, (*i2).second)); //小学求gcd法
		mod(ans); //判断答案是否大于等于1e9
	}
	printf(flag ? "%09lld" : "%lld", ans); //判断答案是否大于等于1e9，是输出9位
	return 0;
}
```

---

## 作者：Nuyoah_awa (赞：1)

### 题目分析

解法一：

首先想到分解质因数，将 $a$ 分解为 $d_{1}^{~aq_{1}} \times d_{2}^{~aq_{2}} \times …… \times d_{k}^{~aq_{k}}$，$b$ 同理，分解为 $d_{1}^{~bq_{1}} \times d_{2}^{~bq_{2}} \times …… \times d_{k}^{~bq_{k}}$。

大多数 $d \le \sqrt{10^{9}}$，每个数至多有一个因数大于 $\sqrt{10^9}$，所以在最后特殊处理一下就好了。

最后答案就是 $ans = d_{1}^{~\min(aq_{1},bq_{1})} \times d_{2}^{~\min(aq_{2},bq_{2})} \times …… \times d_{k}^{~\min(aq_{k},bq_{k})}$。

总的时间复杂度是 $O(n \times \sqrt{10^{9}})$。

解法二：

根据解法一，可以发现最后答案的某个 $d^q$ 一定是通过 $\gcd(a_i, b_j)$。

所以我们可以枚举 $i, j$ 计算所有 $\gcd(a_i,a_j)$ 之和。

总的时间复杂度是 $O(n \times m \times \log(n))$。

### code(解法二)
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

const long long N = 1e3 + 5, MOD = 1e9;
long long n, m, a[N], b[N], ans = 1, g;
bool flag = false;

int main()
{
	scanf("%lld", &n);
	for(long long i = 1;i <= n;i++)
		scanf("%lld", &a[i]);
	scanf("%lld", &m);
	for(long long i = 1;i <= m;i++)
		scanf("%lld", &b[i]);
	for(long long i = 1;i <= n;i++)
	{
		for(long long j = 1;j <= m;j++)
		{
			g = __gcd(a[i], b[j]);
			if(ans * g >= MOD)
			{
				flag = true;
				ans = (ans * g) % MOD;
			}
			else
				ans *= g;
			a[i] /= g, b[j] /= g;
		}
	}
	if(flag)
		printf("%09lld", ans);
	else
		printf("%lld", ans);
	return 0;
}
```

---

## 作者：_xxy_ (赞：1)

**数据范围：**

 $ 1 \le N , M \le 1000 $ ， $ 1 \le A_i , B_i \le 10^9 $ ，暴力乘起来求肯定不行。
 
回顾求最大公因数的过程，如下：

对于 $ 30 $ 和 $ 42 $ ，先将它们分解质因数。

 $ 30 = 2 \times 3 \times 5 $ 
 
 $ 42 = 2 \times 3 \times 7 $ 
 
取质因数公共部分，它们的公因数便是 $ 2 \times 3 = 6 $ 。

于是，我们可以将 $ a $ 数组中的每个数分解质因数，分别记录出现过的质因数及其出现的次数，然后对于 $ b $ 数组的每个数，分别分解质因数，同样进行记录，最后模拟求最大公因数的过程即可。

对于输出，只需用一个变量记录答案是否超过九位数即可。

**Ac Code:**

```cpp
#include<cstdio>
#include<set>
#include<map>
#include<vector>
#define mod 1000000000
using namespace std;
map<int,int> ma,mb;
vector<int> v;
inline int minn(int a,int b){
	return a<b?a:b;
}
void work(int a){
	for(int i=2;i*i<=a;i++){
		while(a%i==0){
			ma[i]++;
			if(ma[i]==1) v.push_back(i);
			a/=i;
		}
	}
	if(a>1){
		ma[a]++;
		if(ma[a]==1) v.push_back(a);
	}
}
void work2(int b){
	for(int i=2;i*i<=b;i++){
		while(b%i==0){
			mb[i]++;
			b/=i;
		}
	}
	if(b>1) mb[b]++;
}
inline int read(){
	int x=0,f=1;
	char ac=getchar();
	while(ac<'0'||ac>'9'){
		if(ac=='-') f=-1;
		ac=getchar();
	}
	while(ac>='0'&&ac<='9'){
		x=x*10+(ac-'0');
		ac=getchar();
	}
	return x*f;
}
int main(){
	int n=read();
	while(n--){
		int a=read();
		work(a);
	}
	int m=read();
	while(m--){
		int b=read();
		work2(b);
	}
	long long ans=1;
	int len=v.size();
	bool p=false;
	for(int i=0;i<len;i++){
		int sum=minn(ma[v[i]],mb[v[i]]);
		while(sum--){
			ans*=v[i];
			if(ans>=mod){
				p=true;
				ans%=mod;
			}
		}
	}
	p?printf("%09lld",ans):printf("%lld",ans);
	return 0;
} 
```

---

## 作者：fz20181223 (赞：1)

upd on 2021/08/04:修改了部分不符合题解规范但是一开始没有审核出来的地方

下面是正文：

众所周知，对于两个数 $a=\prod\limits_{i=1}^nA_i^{P_i} \cdot \prod\limits_{i=1}^mB_i^{Q_i}$ 和 $b=\prod\limits_{i=1}^nA_i^{R_i} \cdot \prod\limits_{i=1}^lC_i^{S_i}$ 中， $\gcd(a,b)=\prod\limits_{i=1}^nA_i^{\operatorname{Min}(P_i,R_i)}$（保证 $A$，$B$，$C$集合中的元素为质数）

观察此题，我们可以发现它只是把上文中的 $a$ 和 $b$ 分别改为了若干个数的乘积，但是质因数还是可以统计的，所以，有了如下的思路：

1.将每个读入的数分解质因数，将数据累加至对应的数

2.枚举任意一个数的数据，与另一个数的数据做匹配，如果找到了，则将两个数对应的质数的次数中取最小值，乘进最大公因数中，再对 $10^9$ 取模

此时就有问题了：将样例 $1$ , $2$ 和 $3$ 比较，我们发现如果答案位数本来就没有 $9$ 位，则根本就不用补零（参见样例 $1$ ， $2$ ），但如果答案位数远超了 $9$ 位，而答案与 $10^9$ 取模后小于 $10^8$ 时，我们要通过在答案前面补 $0$ 直至答案为数到 $9$ 为止。

这时通过在快速幂对答案取模前加入判断：如果当前快速幂的临时结果乘上原来的最大公因数的位数大于 $9$ 位数，则说明答案需要补零。因为答案在不模的情况下只会越来越大，当你的答案一旦超过 $10^9$ ，只要不取模，答案永远大于 $10^9$

附：AC代码（不要抄！）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int err=-120712^7869^12174,mod=1e9;
typedef long long ll;
map<ll,ll>a,b;
ll n,m,ans;bool flag;
ll qp(ll a,ll b,ll f){
	ll ret=1;
	while(b){
		if(b&1){
			ret=ret*a;
			if(ret*f>=mod) flag=1;//一个神奇的判断
			ret=ret%mod;
		}
		a=a*a%mod;
		b>>=1;
	}
	return ret;
}
void asep(ll x){
    while(!(x&1)){
        a[2]++;
        x>>=1;
    }   
    for(int i=3;i*i<=x;){
        if(!(x%i)){
            a[i]++;
            x/=i;
        }   
        else
            i+=2;
    }   
    a[x]++;
}
void bsep(ll x){
	while(!(x&1)){
        b[2]++;
        x>>=1;
    }   
    for(int i=3;i*i<=x;){
        if(!(x%i)){
            b[i]++;
            x/=i;
        }   
        else
            i+=2;
    }   
    b[x]++;
}
ll getsize(ll x){
	string st;stringstream ss;
	ss<<x;ss>>st;
	return st.size();
}
int main(){
    scanf("%lld",&n);
    for(ll i=0,tmp;i<n;++i){
    	scanf("%lld",&tmp);
    	asep(tmp);
	}
	scanf("%lld",&m);
    for(ll i=0,tmp;i<m;++i){
    	scanf("%lld",&tmp);
    	bsep(tmp);
	}
//	for(map<ll,ll>::iterator it=a.begin();it!=a.end();++it)printf("%lld^%lld ",it->first,it->second);
//	printf("\n");
//	for(map<ll,ll>::iterator it=b.begin();it!=b.end();++it)printf("%lld^%lld ",it->first,it->second);
//	printf("\n");
	ans=1;
	for(map<ll,ll>::iterator ait=a.begin();ait!=a.end();++ait){
		map<ll,ll>::iterator bit=b.find(ait->first);
		if(bit!=b.end()){//common factor
			ll base=ait->first,up=min(ait->second,bit->second);
//			printf("%d^%d ",base,up);
			ans=(ans*qp(base,up,ans))%mod;
		}
	}
	if(flag){
		ll dig=9-getsize(ans);
		for(;dig>0;dig--) printf("0");
	}
	printf("%lld",ans);
    return 0;}

```

---

## 作者：zk_y (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7616)

我们发现这道题目就是让我们求出几个数的积的最大公约数，但是由于乘积太大，所以我们可以考虑分开考虑。

我们发现，如果 $A_i$ 和 $B_j$ 有最大公约数 $C$。那么，我们最终的答案 $X$，所以我们可以每次计算两个数的最大公约数 $C$，我们最后只需要将所有的最大公约数相乘就可以了。

我们可以暴力枚举 $A_i$ 和 $B_j$，时间复杂度为 $O(nm)$。并不会超时。

还有一点是关于输出最后九位数的，我们就需要来记录当前数是否大于 $1\times 10^9$，如果大于，那么我们最后使用 ``printf`` 的自动占零的功能就可以了。

---
# AC 代码
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
const int N=1e9;
const int M=1e6+200,mod=1e9;
int numa[M],numb[M];
#define ll long long
ll ans=1;
int n,m,k;
bool flag;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&numa[i]);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)scanf("%d",&numb[i]);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			k=__gcd(numa[i],numb[j]);
			numa[i]/=k;numb[j]/=k;
			ans*=k;
			if(ans>mod){
				flag=1;
				ans%=mod;
			}
		}
	}
	if(!flag)printf("%lld",ans);
	if(flag){
		printf("%09lld",ans);//保留最后几位
	}
	return 0;
}
```


---

## 作者：ruanwentao666 (赞：0)

# P7616 [COCI2011-2012#2] ZADAĆA题解
[~~凹凸曼传送门~~](https://www.luogu.com.cn/problem/P7616)

## 问题分析
题目让我们求一个~~非常简单的~~式子的值，那就得把这个式子搞懂，我们逐个进行翻译。

$\gcd(\prod _ {i = 1} ^ N A_i,\prod _ {i = 1} ^ M B_i)$

首先，gcd 是最大公约数的意思，就是对括号里的两个式子取最大公约数。括号里的两个式子分别表示对 $A$ 数组累乘和对 $B$ 数组累乘得到的结果。

那么这个式子的意思就出来了，即对 $A$ 数组和 $B$ 数组分别累乘，得到的结果再取最大公约数。

## 解法分析
对于上述思路，我们首先想到的就是暴力，但是数据过大，行不通，我们就要想其他方法。

如何快速的求两个数的最大公约数？那必须是分解质因数。没错，对两个数组的每一个数都做质因数分解的操作。用 map 累加，最后求最大公约数即可。

**注意：输出的格式要注意。如果答案超过九位数，只需输出它的最后九位即可。**

## 代码展示
```cpp
#include<iostream>
#include<string>
#include<cmath>
#include<map>
using namespace std;
const int maxn = 1005;
const int mod = 1e9;
int n, m, a[maxn], b[maxn];
map<int, int>mp1, mp2;
bool f;
void add1(int x) {
	int d = sqrt(x);
	for (int i = 2; i <= d; i++) {
		while (x % i == 0) {
			mp1[i]++;
			x /= i;
		}
	}
	if (x != 1)mp1[x]++;
}
void add2(int x) {
	int d = sqrt(x);
	for (int i = 2; i <= d; i++) {
		while (x % i == 0) {
			mp2[i]++;
			x /= i;
		}
	}
	if (x != 1)mp2[x]++;
}
int Judge() {
	long long sum = 1;
	for (map<int, int>::iterator it = mp1.begin(); it != mp1.end(); it++) {
		int t = min(it->second, mp2[it->first]);
		for (int i = 1; i <= t; i++) {
			sum = sum * (it->first);
			if (sum > mod) {
				f = 1;
				sum %= mod;
			}
		}
	}
	return sum;
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	cin >> m;
	for (int i = 1; i <= m; i++) {
		cin >> b[i];
	}
	for (int i = 1; i <= n; i++) {
		add1(a[i]);
	}
	for (int i = 1; i <= m; i++) {
		add2(b[i]);
	}
	int ans = Judge();
	int t=ans;
	if (f) {
		string s = "";
		while (ans) {
			s = char(ans % 10 + '0') + s;
			ans /= 10;
		}
		int t = 9 - s.size();
		for (int i = 1; i <= t; i++) {
			cout << "0";
		}
	}
	cout << t;
	return 0;
}

```


---

## 作者：c2209YR (赞：0)

通常来说，我们用分解质因数，求公共质因数的方法，求两个较大的数的 $\gcd$。但是因为这题 $n$ 只有 $1000$，所以我们可以直接暴力求解。

大概思路如下：

两个数 $a_i$ 与 $b_j$ 取 $\gcd$，两数再同除这个数，$ok$ 用来记录最终最大公约数是否超过 $10^9$。

代码如下，仅供参考。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=1e9;
ll n,m,a[1010],b[1010],ans=1;
bool ok; 
ll gcd(ll x,ll y){
    if(y==0) return x;
    return gcd(y,x%y);
}//辗转相除法求最大公因数
int main()
{
    cin>>n;
    for(ll i=1;i<=n;i++) cin>>a[i];
    cin>>m;
    for(ll i=1;i<=m;i++) cin>>b[i];
    for(ll i=1;i<=n;i++){
        for(ll j=1;j<=m;j++){
            if(a[i]==1) break;
            if(b[j]==1) continue;
            int gcds=gcd(a[i],b[j]);//取最大公因数
            if(gcds!=1){
                ans*=gcds;
                if(ans>=maxn){
                    ok=true;
                    ans%=maxn;
                }//取模
                a[i]/=gcds,b[j]/=gcds;
            }
        }
    }
    if(ok) printf("%09lld\n",ans);//补前导0
    else printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Xdl_rp (赞：0)

~~这道题挺不错的。~~

进入正题：
------------
用暴力直接把 $a$ 数组和 $b$ 数组挨个乘起来，答案肯定是爆 `long long` 的，如果用高精度的话，也不好求最大公因数。

- 突然我又想起了我老师（小学）交给我关于最大公因数的知识

例如：

$3$

$2 \ 3 \ 5$

$2$

$4 \ 5$

我们先把 $2 \ 3 \ 5$ 分解质因数，发现他们都是质数，所以 $a$ 数组的乘积就是 $2 \times 3 \times 5$。而 $b$ 数组中的 $4$ 可以分解为 $2 ^ 2$，所以 $b$ 数组的乘积就是 $2 ^ 2 \times 5$。

接下来，我们将他们一一比对，最大公因数就是两个数的某一个质因数，取这两个数中指数小的连乘，第一个是 $2$，取 $2 ^ 1$ 和 $2 ^ 2$ 中指数小的，显然是 $2$，第二个是 $3$，取 $3 ^ 1$ 和 $3 ^ 0$ 中最小的，显然取 $3 ^ 0$，最后一个是 $5$，取最小的就是 $5 ^ 1$。

最后乘起来，$2 ^ 1 \times 3 ^ 0 \times 5 ^ 1 = 10$。就做完了。

$\therefore$ 对于每个 $a_i$，对其进行质因数分解，可以统计出每个质因数 出现的次数，用 $cnta_x$ 记录在 $a$ 的所有数中，质因数 $x$ 出现的次数。 类似地，用 $cntb_x$ 记录 $b$ 的所有数中，质因数 $x$ 出现的次数。 对于每个质因数 $x$，$cnta_x$ 和 $cntb_x$ 中的最小值就是 $x$ 在最终答案 中出现的次数。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
map<int, int> cnta, cntb, ans;
const int mod = 1e9;
vector<int> q;
void solve_a (int x) {
	for (int i = 2; i * i <= x; i++) {
		while (x % i == 0) {
			cnta[i]++;
			if (cnta[i] == 1) q.push_back(i);
			x /= i;
		}
	}
	if (x > 1) cnta[x]++;
	if (cnta[x] == 1) q.push_back(x);
}
void solve_b (int x) {
	for (int i = 2; i * i <= x; i++) {
		while (x % i == 0) {
			cntb[i]++;
			if (cntb[i] == 1 && cnta[i] == 0) q.push_back(i);
			x /= i;
		}
	}
	if (x > 1) cntb[x]++;
	if (cntb[x] == 1 && cnta[x] == 0) q.push_back(x);
}
signed main() {
	int n;
	cin >> n;
	int maxn = -1;
	while (n--) {
		int a;
		cin >> a;
		maxn = max(maxn, a);
		solve_a(a);
	}
	int m;
	cin >> m;
	while (m--) {
		int b;
		cin >> b;
		maxn = max(maxn, b);
		solve_b(b);
	}
	for (int i = 0; i < q.size(); i++) {
		ans[q[i]] = min(cnta[q[i]], cntb[q[i]]);
	}
	int bigans = 1, flag = 0;
	for (int i = 0; i < q.size(); i++) {
		while (ans[q[i]]--) {
			bigans *= q[i];
			if (bigans > mod) {
				flag = 1;
				bigans %= mod;
			}
		}
	}
	if (flag == 1) printf("%09lld\n", bigans);
	else printf("%lld\n", bigans);
	return 0;
}
```


---

## 作者：fls233666 (赞：0)

为了方便描述，我们首先做出如下约定： 

$$X= \prod^{N}_{i=1}A_i,Y= \prod^{M}_{i=1}B_i$$

考虑如何求 $\gcd(X,Y)$ 。根据算术基本定理，我们知道**对于任何一个大于 $1$ 的正整数都能唯一分解为有限个质数的乘积**。于是我们可以分解得到：

$$X=p_1^{c_1} \times p_2^{c_2} \times p_3^{c_3} \times ... \times p_x^{c_x}$$

$$Y=p_1^{d_1} \times p_2^{d_2} \times p_3^{d_3} \times ... \times p_x^{d_x}$$

其中 $p_i$ 为质数，且满足 $p_1 < p_2 < p_3 < ... < p_x$，$c_i$ 与 $d_i$ 为**非负整数**。

分解完成后，根据最大公约数的定义，我们可以有如下表示：

$$\gcd(X,Y)=p_1^{\min(c_1,d_1)} \times p_2^{\min(c_2,d_2)} \times p_3^{\min(c_3,d_3)} \times ... \times p_x^{\min(c_x,d_x)}$$

既然最大公约数可以有这样的表示法，我们何不尝试对这个表达式进行求解呢？

那么下面我们考虑求解表达式的各部分。

--------

首先我们肯定要对 $X$ 和 $Y$ 进行质因数分解。由于$X= \prod^{N}_{i=1}A_i,Y= \prod^{M}_{i=1}B_i$ ，我们只需要对每个 $A_i,B_i$ 做质因数分解即可。  

但是我们注意到，$1\le A_i,B_i \le 10^9$，这意味着 $A_i,B_i$ 中可能存在大质数因子。普通的筛法显然不能在时间限制内把 $[1,10^9]$ 的质数全筛出来。

这时我们想到，对于一个数 $n$，如果它不能被 $[1,\sqrt{n}]$ 中的所有数字整除，它就能被判定为质数。那么我们可以将 $[1,10^5]$ 的质数用筛法全筛出来，将这些数字依次试除每个 $A_i,B_i$ 。试除完成后，剩下的不为 $1$ 的 $A_i,B_i$ 即为大质数，另外统计即可。

那么剩下的事情就很简单了：依次扫描 $X$ 和 $Y$ 有的各项质因子，对它们的指数取 $\min$，然后依次乘起来即可。由于要输出后九位数字，我们还需要另外实现高精度数乘低精度数。

于是这题的解析就告一段落了。下面放出代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define rgt register int
#define qmn(a,b) a<b?a:b
using namespace std;

const int mxn = 1111;
const int mxp = 1e5+5;

bool del[mxp];
ll inpr[mxp],len_pr;
ll ans=1,num[mxn],out[12];
int n,len1,len2,len_res,len_out;

struct pi{
	ll pr;
	int cnt;
}pi1[mxn],pi2[mxn],res[mxn];

inline bool cmp(struct pi p1,struct pi p2){
	return p1.pr<p2.pr;
}

inline void mul(ll mul_x){  //高精度乘低精度，只保留最后九位数
	for(rgt i=1;i<=len_out;i++)
		out[i]*=mul_x;
	for(rgt i=1;i<=len_out;i++){
		if(out[i]>9){
			out[i+1]+=out[i]/10;
			out[i]%=10;
		}
	}
	while(len_out<9&&out[len_out+1]){
		len_out++;
		out[len_out+1]+=out[len_out]/10;
		out[len_out]%=10;
	}
	out[len_out]%=10;
}

int main(){
	bool ck;
    
	for(rgt i=2;i<mxp;i++){
		if(!del[i]){
			len_pr++;
			inpr[len_pr]=i;
			for(rgt j=i+i;j<mxp;j+=i)
				del[j]=true;
		}
	}  //暴力筛质数
    
	pi1[0].pr=pi2[0].pr=0;
	scanf("%d",&n);
	for(rgt i=1;i<=n;i++)
		scanf("%d",&num[i]);  //读入
        
	for(rgt i=1;i<=len_pr;i++){  //拿筛出来的每个质数依次试除
		for(rgt j=1;j<=n;j++){
			if(num[j]%inpr[i]==0){
				if(pi1[len1].pr!=inpr[i]){
					len1++;
					pi1[len1].pr=inpr[i];
					pi1[len1].cnt=0;
				}  //是新的质数因子，加入
				while(num[j]%inpr[i]==0){
					num[j]/=inpr[i];
					pi1[len1].cnt++;
				}  //计算指数
			}
		}
	}
    
	for(rgt i=1;i<=n;i++){
		if(num[i]!=1){  //加入剩下的大质数
			ck=false;
			for(rgt j=1;j<=len1;j++){
				if(pi1[j].pr==num[i]){
					pi1[j].cnt++;
					ck=true;
					break;
				}  //判断大质数是否已经在质数因子集中,如果在，直接指数+1后跑路
			}
			if(!ck){  //否则加入质数因子集
				len1++;
				pi1[len1].pr=num[i];
				pi1[len1].cnt=1;
			}
		}
	}
    
	sort(pi1+1,pi1+len1+1,cmp);  //按质数因子大小排序，方便之后的 gcd 处理
	
   //上面处理了 Ai，下面按相同方式处理了 Bi
	scanf("%d",&n);
	for(rgt i=1;i<=n;i++)
		scanf("%d",&num[i]);
        
	for(rgt i=1;i<=len_pr;i++){
		for(rgt j=1;j<=n;j++){
			if(num[j]%inpr[i]==0){
				if(pi2[len2].pr!=inpr[i]){
					len2++;
					pi2[len2].pr=inpr[i];
					pi2[len2].cnt=0;
				}
				while(num[j]%inpr[i]==0){
					num[j]/=inpr[i];
					pi2[len2].cnt++;
				}
			}
		}
	}
    
	for(rgt i=1;i<=n;i++){
		if(num[i]!=1){
			ck=false;
			for(rgt j=1;j<=len2;j++){
				if(pi2[j].pr==num[i]){
					pi2[j].cnt++;
					ck=true;
					break;
				}
			}
			if(!ck){
				len2++;
				pi2[len2].pr=num[i];
				pi2[len2].cnt=1;
			}
		}
	}
    
	sort(pi2+1,pi2+len2+1,cmp);
	
   //因为之前按质数因子大小排序了，所以现在可以双指针遍历两个质数因子集取 min
	int ti=1,tj=1;
	while(ti<=len1&&tj<=len2){
    
		if(pi1[ti].pr<pi2[tj].pr){
			ti++;
			continue;
		}
		if(pi1[ti].pr>pi2[tj].pr){
			tj++;
			continue;
		}
        //质因子不相等，移动指针
        
		if(pi1[ti].pr==pi2[tj].pr){
			len_res++;
			res[len_res].pr=pi1[ti].pr;
			res[len_res].cnt=qmn(pi1[ti].cnt,pi2[tj].cnt);
			ti++;
			tj++;
		}  //相等了，取较小指数，加入答案
	}
	
	out[1]=1;
	len_out=1;
	for(rgt i=1;i<=len_res;i++){
		for(rgt j=1;j<=res[i].cnt;j++)
			mul(res[i].pr);
	}//暴力算答案
    
	for(rgt i=len_out;i>=1;i--)
		printf("%lld",out[i]);  //输出
	return 0;
}
```


---


# [蓝桥杯 2018 省 B] 递增三元组

## 题目描述

给定三个整数数组 $A = [A_1, A_2,\cdots, A_N]$，$B = [B_1, B_2,\cdots, B_N]$，$C = [C_1, C_2,\cdots,C_N]$。

请你统计有多少个三元组 $(i, j, k)$ 满足：
1. $1 \le i, j, k \le N$  
2. $A_i < B_j < C_k$

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$。

对于 $60\%$ 的数据，$1 \le N \le 1000$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$0 \le A_i, B_i, C_i \le 10^5$。

## 样例 #1

### 输入

```
3
1 1 1
2 2 2
3 3 3```

### 输出

```
27```

# 题解

## 作者：liruixiong0101 (赞：28)

## P-1 前言：
双倍经验：[[ABC077C] Snuke Festival](https://www.luogu.com.cn/problem/AT_arc084_a)。

## P0 前置知识：
[二分](https://blog.csdn.net/Mr_dimple/article/details/114656142/)。

## P1 题意：
给定三个长度为 $n$ 的整数数组 $a,b,c$。  
请你统计有多少个三元组 $(i,j,k)$ 满足：
1. $1\le i,j,k\le n$  
2. $a_i < b_j < c_k$

## P3 思路：
首先想到的就是暴力，三层循环枚举。  
时间复杂度：$O(n^3)$，分数：60pts，不可过。  
暴力应该人人都会写，就不提供代码了。

---

暴力过不了就想优化。  
我们枚举了前两层循环 $i,j$，若 $a_i<b_j$ 那么就不必再枚举所有的 $k$ 只需要所有大于 $b_j$ 的 $k$ 的取值种数，加上即可。这可以用二分解决。  
时间复杂度：$O(n^2\log n)$，分数：72pts，不可过。  
代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 5;
int n , a[N] , b[N] , c[N] , ans;
signed main(){
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) cin >> b[i];
	for(int i = 1; i <= n; i++) cin >> c[i];
	sort(a + 1 , a + 1 + n);
	sort(b + 1 , b + 1 + n);
	sort(c + 1 , c + 1 + n);
	//排序，好进行二分
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			if(a[i] >= b[j]) continue;
			//二分的前提是a[i] < b[j]
			int num = upper_bound(c + 1 , c + 1 + n , b[j]) - c;
			ans += n - num + 1;
			//二分找出所有大于b[j]的c[k]，ans累加
		}
	}
	cout << ans;
	return 0;
}
```

---

既然你都可以用二分来找出满足条件的 $k$，那我为什么不可以换一种枚举方式把满足条件的 $i$ 或 $j$ 也给找出来呢。  
仔细看条件二：$a_i<b_j<c_k$。  
有没有发现这个 $b_j$ 很特殊，他在这个不等式的中间。  
我们现在把这个不等式变一下。
$$a_i<b_j<c_k$$
$$
	\begin{cases}
		a_i<b_j\\
		c_k>b_j\\
	\end{cases}
$$
（下面的两个不等式为且的关系）  
你发现了吗？  
我们可以枚举 $j$ 再通过二分找出满足条件的 $i,k$ 的种类数分别记为 $cnta,cntb$。根据乘法原理，在每次循环将 $cnta\times cntb$ 累计到 $ans$ 里即可。  
时间复杂度：$O(n\log n)$，分数：100pts，可过。  

## P4 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 5;
int n , a[N] , b[N] , c[N] , ans;
signed main(){
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) cin >> b[i];
	for(int i = 1; i <= n; i++) cin >> c[i];
	sort(a + 1 , a + 1 + n);
	sort(c + 1 , c + 1 + n);
	//排序，好进行二分
	for(int j = 1; j <= n; j++){
		int cnta = lower_bound(a + 1 , a + 1 + n , b[j]) - a - 1;
		int cntc = upper_bound(c + 1 , c + 1 + n , b[j]) - c;
		cntc = n - cntc + 1;
		//二分找出i的种类数和j的种类数
		ans += cnta * cntc;//乘法原理累计答案
	}
	cout << ans;
	return 0;
}
```
记得开 `long long`！！！

---

## 作者：卷王 (赞：6)

## 题目大意

题目对我们很友好。[略。](https://www.luogu.com.cn/problem/P8667) 

## 思路

吐槽一下：$O(n^3)$ 题目里说是 $30\%$ 的数据，但是我打了一下，怎么是 $60$ 分？？？

别看他这上面有 dp 的标签，其实不用 dp 也可以迅速的做完。

由于题目中有小于号，我们可以把这里看成突破口。

嗯，我们可以用 ```std::lower_bound``` 和 ```std::upper_bound``` 解决啊！

首先对 $a,b,c$ 进行排序，然后从 $1$ 到 $n$ 遍历，每一次统计比 $b_i$ 小的 $a$ 数组数字个数和比 $b_i$ 大的 $c$ 数组数字个数即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n; ll cnt = 0;
int a[100007], b[100007], c[100007];
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
int main() {
	n = read();
	for(int i = 1; i <= n; i++) a[i] = read();
	for(int i = 1; i <= n; i++) b[i] = read();
	for(int i = 1; i <= n; i++) c[i] = read();
	sort(a + 1, a + n + 1);
	sort(b + 1, b + n + 1);
	sort(c + 1, c + n + 1);
	for(int i = 1; i <= n; i++) {
		ll n1 = lower_bound(a + 1, a + n + 1, b[i]) - a - 1;
		ll n2 = upper_bound(c + 1, c + n + 1, b[i]) - c - 1;
		cnt += n1 * (n - n2);
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：__pig__ (赞：6)

P8667

## 题意

已经很清晰了，就不说了。

## 思路

$O(n ^ 3)$

显而易见，枚举 $i,j,k$ 的位置即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x;
}
int n,a[100006],b[100006],c[100006],ans;
int main(){
	n=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)b[i]=read();
	for(int i=1;i<=n;++i)c[i]=read();
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			for(int k=1;k<=n;++k){
				if(a[i]<b[j]&&b[j]<c[k])++ans;
			}
		}
	}cout<<ans;
}
```

$O(n \log n)$

考虑优化，我们可以先枚举 $b _ {i}$，然后用二分找到在 $a$ 数组最大且小于 $b _ {i}$ 的数和 $c$ 数组最小且大于 $b _ {i}$ 的数。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x;
}
int n,a[100006],b[100006],c[100006],ans;
int l(int x){
	int l=1,r=n,mid,sum=0;
	while(l<=r){
		mid=l+r>>1;
		if(a[mid]<x){
			l=mid+1;
			sum=mid;
		}
		else r=mid-1;
	}return sum;
}
int r(int x){
	int l=1,r=n,mid,sum=0;
	while(l<=r){
		mid=l+r>>1;
		if(c[mid]>x){
			l=mid+1;
			sum=mid;
		}
		else r=mid-1;
	}return sum;
int main(){
	n=read();
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=n;++i)b[i]=read();
	for(int i=1;i<=n;++i)c[i]=read();
	sort(a+1,a+n+1);sort(c+1,c+n+1,greater<int>());
	for(int i=1;i<=n;++i)ans+=l(b[i])*r(b[i]);
	cout<<ans;
}
```
$O(1)$ 也就是常数复杂度。

看见 $a _ {i},b _ {i},c _ {i} \le 10 ^ 5$，考虑用桶排。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=100000007;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){f=ch=='-'?-f:f;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f*x;
}
int n,a[100006],b[100006],c[100006],x,y,ans;
int main(){
	n=read();
	for(int i=1;i<=n;++i)++a[read()];
	for(int i=1;i<=n;++i)++b[read()];
	for(int i=1;i<=n;++i)++c[read()];
	for(int i=0;i<=1000000;++i){
		if(i)x+=a[i-1];
		y+=c[i];
		ans=(ans+(x*(n-y)*b[i]));
	}cout<<ans;
}
```

## 最后

记得开 $\text{long long}$，因为 $ 10 ^ 5 \times 10 ^ 5 \times 10 ^ 5 > 2 \times 10 ^ 9$。

不知道是数据水还是怎么回事，桶数组大小只用开 $10 ^ 4$。

---

## 作者：technopolis_2085 (赞：4)

分析：

观察数据范围，发现 $A_i$，$B_i$，$C_i$ 都小于 $10^5$。

所以可以开桶记录每一个数的出现次数。

然后对于 $A$ 数组，记录前缀和 $sum1_i$ 表示在 $A$ 数组中小于 $i$ 的个数。

对于 $C$ 数组，记录前缀和 $sum2_i$ 表示在 $C$ 数组中大于 $i$ 的个数。

最后，对于每一个 $B_i$，对答案的贡献为 $sum1_{B_i-1}$ 乘上 $sum2_{B_i+1}$。

时间复杂度趋近于 $O(n)$。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1e5+10;
int sum1[maxn],sum2[maxn];
int a[maxn],b[maxn],c[maxn];

signed main(){
	int n;
	scanf("%lld",&n);
	for (int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for (int i=1;i<=n;i++) scanf("%lld",&b[i]);
	for (int i=1;i<=n;i++) scanf("%lld",&c[i]);
	
	for (int i=1;i<=n;i++){
		sum1[a[i]]++;
		sum2[c[i]]++; 
	}
	
	for (int i=1;i<=(int)1e5;i++){
		sum1[i]+=sum1[i-1];
	}
	
	for (int i=(int)1e5;i>=0;i--){
		sum2[i]+=sum2[i+1];
	}
	
	int ans=0;
	
	for (int i=1;i<=n;i++){
		ans+=sum1[b[i]-1]*sum2[b[i]+1];
	}
	
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Zaku (赞：4)

标签里有动态规划，我实在看不出这咋用 Dp 做？？

查找题，应该可以用二分做。但我刻意用双指针。感觉比较优雅（？

### 思路：
先尝试用暴力思维。先枚举 $B$ 数组，在 $A$ 数组中寻找小于 $B_i$ 的数的个数 $cnt$，在 $C$ 数组中寻找大于 $B_i$ 的数的个数 $cnt'$，带 $B_i$ 的合法选择数就是 $cnt\times cnt'$。

普通查找明显 $\Theta(n^2)$，超时没跑了。

考虑双指针优化以查找 $cnt$ 与 $cnt'$（前提是数组排好序）。因为每个指针最多移动 $n$ 次，故查找的时间复杂度降到 $\Theta(n)$。

双指针策略是枚举 $B_i$，双指针记录 $cnt$ 和不大于 $B_i$ 的数的个数（这是为了统一枚举顺序，方便一些），每轮双指针后答案加上 $cnt\times (n-cnt')$。

#### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
typedef long long LL;
int a[N], b[N], c[N];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &b[i]);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &c[i]);
    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 1);
    sort(c + 1, c + n + 1);//先把数组排序，否则无法双指针 
    LL ans = 0;//不开long long见祖宗 
    int cnt = 1, cnt_ = 1;
    //双指针，记录a中小于b[i]的个数和c中不大于b[i]的个数 
    for (int i = 1; i <= n; i ++ ){
        while (cnt <= n && a[cnt] < b[i]) cnt ++;//查找a中小于b[i]的个数 
        while (cnt_ <= n && c[cnt_] <= b[i]) cnt_ ++;//为了方便。实际是在查找c中大于b[i]的个数 
        ans += (LL) (cnt - 1) * (n - cnt_ + 1); 
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Lizj (赞：3)

题意：给出 $N$ 和三个数组 $A,B,C$，求出有多少个三元组 $(i,j,k)$ 满足：

- $1\leq i,j,k\leq N$

- $A_i< B_j<C_k$

思路：可以三重循环枚举 $(i,j,k)$ 计算出符合条件的三元组数量。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t;
int a[100010],b[100010],c[100010];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}for(int i=1;i<=n;i++){
		cin>>b[i];
	}for(int i=1;i<=n;i++){
		cin>>c[i];
	}for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				if(a[i]<b[j]&&b[j]<c[k]){
					t++;	//枚举符合条件的三元组数量
				}
			}
		}
	}cout<<t;
	return 0;
}
```

时间复杂度 $O(n^3)$，会超时，只有 $60$ 分，所以需要考虑优化。

二分解法：

其实可以不用 DP 解，可以使用二分优化。

先对 $A,C$ 两个数组排序，再枚举每一个 $B_j$，使用 `lower_bound` 求出符合要求的 $A_i$ 后，再用 `upper_bound` 求出符合要求的 $C_k$ 的数量，相乘，就是这一个 $B_j$ 可以组成的三元组数量，最后进行累加，可以得出答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t;
int a[100010],b[100010],c[100010];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}for(int i=1;i<=n;i++){
		cin>>b[i];
	}for(int i=1;i<=n;i++){
		cin>>c[i];
	}sort(a+1,a+n+1);	//预处理数组
	sort(c+1,c+n+1);
	for(int i=1;i<=n;i++){
		int wa=lower_bound(a+1,a+n+1,b[i])-a-1;
		int wc=n-(upper_bound(c+1,c+n+1,b[i])-c)+1;
		t+=(long long)wa*wc;	//开 long long，否则会溢出
	}cout<<t;
	return 0;
}
```
时间复杂度 $O(n\log_2{n})$，$100$ 分，可以通过此题。

---

## 作者：_Wind_Leaves_ShaDow_ (赞：1)

~~感谢管理员大大的审核！管理员大大辛苦了！~~

### 乱搞（不想看可以直接跳正解）

_曾经有人说过：**看到题目先打暴力枚举。**_

很简单，三层枚举，反正会 [超时（60 pts）](https://www.luogu.com.cn/record/107590960)，就不贴代码了。

稍微思考，可以想到用排序。排序完之后从 $c$ 枚举起，如果 $b$ 不满足要求代表以后的 $b$ 都不满足要求，退出循环。$a$ 同理。

贴个代码 [（72 pts 多A一个点）](https://www.luogu.com.cn/record/107592045)：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a[100050],b[100050],c[100050],ans=0;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)cin>>b[i];
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)cin>>c[i];
	sort(c+1,c+n+1);
	for(int k=1;k<=n;k++){
		for(int j=1;j<=n;j++){
			if(c[k]<=b[j])break;
			for(int i=1;i<=n;i++){
				if(b[j]<=a[i])break;
				ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}
```
发现这个想法应该很像正解，可以继续优化。问题来了，怎么优化呢？

## 正解

### 给个前置芝士：

在我们的 $\text {STL}$ 模板库中，有两个超级有用的函数：```lower_bound( , , )``` 和 ```upper_bound( , , )```。它们可以帮助我们找到 **有序数组中第一个不小于我的的数的位置** 和 **有序数组中第一个大于我的的数的位置。注意它们返回的是内置下标，请减去原数组头再食用**。并且，它的实现是 **由二分来完成的**，非常的快捷。

其中，前两个填数组位，具体用法和 ```sort``` 相同，最后一个填我们要找的参。

### 回归正题：

那么，该怎么优化呢？

分析一下，可以发现，在排序后，当前的 $c$ 只要小于等于这个 $b$，那么对于之后的 $b$，这个 $c$ 一样也不会满足。而在这之前的所有 $b$ 都是正确的。也就是说，**当前 $b$ 的值只和第一个小于等于它的 $c$ 有关**。

到什么了？ ```lower_bound``` 啊！

同理我们可得，**当前 $b$ 的值只和第一个大于它的 $a$ 有关**。用一个 ```upper_bound``` 完事。

~~散会！~~，还有一件事，当我们二分找到了这个符合的 $a$ 和 $c$ 之后，该如何确定有多少个？~~自己数。~~ 稍微一个数学思维就可以知道，留在这里等人思考。

### 好吧，具体的放到代码里了：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,a[100050],b[100050],c[100050],ans=0;
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//关闭流同步好习惯
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)cin>>b[i];
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)cin>>c[i];
	sort(c+1,c+n+1);
	for(int i=1;i<=n;i++){
		b[i]=(lower_bound(a+1,a+n+1,b[i])-a-1)*(n-(upper_bound(c+1,c+n+1,b[i])-c)+1);//自己看式子思考，小学数学。注意用乘号组合。
		ans+=b[i];
		//懒，直接拿 b 数组储存了
	}
	cout<<ans;
	return 0;
}
```
~~给个双倍经验，[[ABC077C] Snuke Festival](https://www.luogu.com.cn/problem/AT_arc084_a)~~

---

## 作者：asas111 (赞：1)

## 思路

暴力枚举时间复杂度 $O(n^3)$，肯定会超时。

显然对数组进行排序不会对答案有任何影响，于是考虑二分。

枚举 $B$，对 $A$ 和 $C$ 进行二分，得到的答案可以进行相乘，因为在 $B_i$ 固定的情况下，对于每一个 $A_i$，它都不会对 $C$ 的答案数造成影响，对 $C$ 也一样。

时间复杂度 $O(n\log n)$，可以通过此题。

## 代码
```cpp
#include<bits/stdc++.h>
#define N 100009
#define ll long long
using namespace std;
ll n,s=0;//要开long long,不然会WA
ll a[N],b[N],c[N];
int main(){
	cin>>n;
	for(int i=0;i<n;i++)cin>>a[i];
	for(int i=0;i<n;i++)cin>>b[i];
	for(int i=0;i<n;i++)cin>>c[i];
	sort(a,a+n);
	sort(c,c+n);
	for(int i=0;i<n;i++){
		ll x=lower_bound(a,a+n,b[i])-a,y=n-(upper_bound(c,c+n,b[i])-c);//二分
		s+=x*y;
	}
	cout<<s;
	return 0;
}

```


---

## 作者：5k_sync_closer (赞：0)

枚举 $j_0$，考虑有多少满足条件的三元组的 $j=j_0$。

根据题意，$(i,j_0,k)$ 满足条件当且仅当  $a_i<b_{j_0}<c_k$，

则 $(i,j_0,k)$ 的个数即为 $a_i<b_{j_0},c_k>b_{j_0}$ 的 $(i,k)$ 的对数，

即 $\sum[a_i<b_{j_0}<c_k]=(\sum[a_i<b_{j_0}])(\sum[c_k>b_{j_0}])$。

对每个 $j_0$ 分别二分 $\sum[a_i<b_{j_0}],\sum[c_k>b_{j_0}]$ 即可。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, a[100050], b[100050], c[100050];
long long q;
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d", a + i);
    for (int i = 1; i <= n; ++i)
        scanf("%d", b + i);
    for (int i = 1; i <= n; ++i)
        scanf("%d", c + i);
    sort(a + 1, a + n + 1);
    sort(c + 1, c + n + 1);
    for (int i = 1; i <= n; ++i)
        q += 1ll * (lower_bound(a + 1, a + n + 1, b[i]) - a - 1) * (n - (upper_bound(c + 1, c + n + 1, b[i]) - c - 1));
    return !printf("%lld", q);
}
```


---


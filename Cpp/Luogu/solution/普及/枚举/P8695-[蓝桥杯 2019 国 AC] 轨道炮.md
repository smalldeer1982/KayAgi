# [蓝桥杯 2019 国 AC] 轨道炮

## 题目描述

小明在玩一款战争游戏。地图上一共有 $N$ 个敌方单位，可以看作 2D 平面上的点。其中第 $i$ 个单位在 $0$ 时刻的位置是 $(X_i, Y_i)$，方向是 $D_i$ (上下左右之一, 用 `U`/`D`/`L`/`R` 表示)，速度是 $V_i$。小明的武器是轨道炮，只能使用一次，不过杀伤力巨大。小明可以选择在某个非负整数时刻释放轨道炮，轨道炮一次可以消灭在一条直线 (平行于坐标轴) 上的所有敌方单位。请你计算小明最多能消灭多少敌方单位。

## 说明/提示

对于所有评测用例，$1 \le N \le 1000$，$-10^6 \le X_i, Y_i \le 10^6$，$0 \le V_i \le 10^6$。

蓝桥杯 2019 年国赛 A 组 H 题（C 组 J 题）

## 样例 #1

### 输入

```
4
0 0 1 R
0 10 1 R
10 10 2 D
2 3 2 L
```

### 输出

```
3```

# 题解

## 作者：wuhan1234 (赞：11)

## 1. 编程思路。

由于题目中给定的点的个数 $N$ 不超过 $1000$，数据规模不大，因此采用简单的暴力枚举可以解决本问题。

先定义 $4$ 个数组 $X$、$Y$、$vx$ 和 $vy$ 分别保存每个敌方单位的位置坐标 $(X_i,Y_i)$ 以及其在 X 轴正方向和 Y 轴正方向上的速度。在输入时预处理后保存。

以输入样例的 $4$ 个敌方单位为例，输入预处理后，$4$ 个数组相应数组元素的值可列举如下：

$X[1]=0, Y[1]=0, vx[1]=1, vy[1]=0$  （向右为 X 轴正方向）

$X[2]=0, Y[2]=10, vx[1]=1, vy[1]=0$  

$X[3]=10, Y[3]=10, vx[3]=0, vy[1]=-2$  （向下为 Y 轴负方向）

$X[4]=2, Y[4]=3, vx[4]=-2, vy[4]=0$  （向左为 X 轴负方向）

枚举的具体做法如下：

在 $N$ 个敌方单位中依次选择某个敌方单位作为基准点，设编号为 $i$，在其他的 $N-1$ 个敌方单位中统计有多少个单位与基准点同列（X 坐标相同）或同行（Y 坐标相同）。下面以同列的统计进行说明。

与基准点 $i$ 同列的某个敌方单位 $j$ 的情况分为两种：

1）$X_i$ 与 $X_j$ 相同，$vx_i$ 也与 $vx_j$ 相同，这样它们任何时刻都同列，将这样的单位的个数记录到变量 $cnt$ 中。当然，若 $vx_i$ 与 $vx_j$ 相同，但 $X_i$ 与 $X_j$ 不相同，这样的两个单位永远不可能同列，直接忽略掉。

2）$vx_i$ 与 $vx_j$ 不相同。计算这两个单位可能的同列时刻。计算方法为距离差除以速度差。即

$$t=\frac{X_i-Xj}{vx_i-vy_j}$$

计算后，若 $t$ 不小于 $0$ 并且距离差能整除速度差（相当于 $t$ 确实为整数时刻），则相应的数组元素 $h[t]$ 加 $1$，表示在 $t$ 时刻与基准点同列的单位多了 $1$ 个。

找出这两者同列点数和的最大值就是某时刻与基准点同列的最多单位。

每个点作为基准点所求得同列点数的最大值就是激光炮在一列上能消灭的最多敌方单位。

同理，可以求得激光炮在一行上（同 Y 坐标）能消灭的最多敌方单位。

取二者的最大值就是所求的答案。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int ans;
int h[2000005];    // h[i]保存 i 时刻与给定点同X的点的个数
void calc(int X[],int vx[],int n)
{
    int i,j;
    for (i=1;i<=n;i++)   // 对每个点进行枚举，看有多少个点在某时刻与其同列（同X坐标）
    {
        memset(h,0,sizeof(h));
        int cnt=1;
        for (j=1;j<=n;j++)
        {
            if (j==i) continue;
            if (vx[i]==vx[j])
            {
                if (X[i]==X[j])     // 同初始X坐标同速度，任何时刻同X
                   cnt++;
                if (ans<cnt) ans=cnt;
                continue;
            }
            int dx=X[i]-X[j];       // 两个点的距离差
            int dv=vx[j]-vx[i];     // 两个点的速度差
            int t=dx/dv;            // 两个点相遇的时间
            if (dx%dv || t<0)   continue;
            h[t]++;                 // 在 t 时刻到达同X的点数加1
            if (ans<h[t]+cnt)  ans=h[t]+cnt;
        }
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    int X[1010],Y[1010],vx[1010]={0},vy[1010]={0};
    for (int i=1;i<=n;i++)
    {
        int v;
        char d[3];
        scanf("%d%d%d%s",&X[i],&Y[i],&v,d);
        switch (d[0])
        {
            case 'R': vx[i]=v; break;
            case 'L': vx[i]=-v; break;
            case 'U': vy[i]=v; break;
            case 'D': vy[i]=-v; break;
        }
    }
    ans=0;
    calc(X,vx,n);
    calc(Y,vy,n);
    printf("%d\n",ans);
    return 0;
}
```









---

## 作者：Lian_zy (赞：4)

# 0 题目传送门

[点我传送](https://www.luogu.com.cn/problem/P8695)

# 1 题目分析
首先看一眼 $n$ 的范围~~题目标签~~可以得出此题可以使用枚举。

我们首先枚举时间，枚举到 $400$ 即可，因为这个范围已经足以枚举出所有可能是答案的情况。

然后统计有多少人在同一行、同一列。

由于 $-10^6 \le X_i,Y_i \le 10^6$，而且 $V_i$ 也很大，用数组统计可能会 MLE，我们观察到，$n \le 1000$ ~~废话~~，也就是说不在同一行或同一列的人最多只有几千个。所以我们可以使用 STL 中的 map 来储存。

# 2 代码时间

~~莫抄袭，没了 AC 记录，空悲切。~~

``` cpp
#include <map>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 1e3 + 10;
char ch[maxn];
map<int, int> tx, ty;
int n, ans, x[maxn], y[maxn], v[maxn], d[maxn];
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d %d %d %s", x + i, y + i, v + i, ch);
		if (ch[0] == 'U') d[i] = 1;
		if (ch[0] == 'D') d[i] = 2;
		if (ch[0] == 'L') d[i] = 3;
		if (ch[0] == 'R') d[i] = 4;
		tx[x[i]]++;
		ty[y[i]]++;
	}
	for (auto it : tx) ans = max(ans, it.second);
	for (auto it : ty) ans = max(ans, it.second);
	for (int t = 1; t <= 400; t++) {
		tx.clear();
		ty.clear();
		for (int i = 1; i <= n; i++) {
			if (d[i] == 1) y[i] += v[i];
			if (d[i] == 2) y[i] -= v[i];
			if (d[i] == 3) x[i] -= v[i];
			if (d[i] == 4) x[i] += v[i];
			tx[x[i]]++;
			ty[y[i]]++;
		}
		for (auto it : tx) ans = max(ans, it.second);
		for (auto it : ty) ans = max(ans, it.second);
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：jackwahaha (赞：3)

**[题目](https://www.luogu.com.cn/problem/P8695)**
# 思路
学过动点的人都知道，表示一个点可以用如下公式（其中 $v$ 表示速度， $t$ 表示运动时间）：
$$\text{起始点}\pm vt$$
在这里，二维直角坐标系上考虑 $x$ 轴和 $y$ 轴的运动。再遍历时间，用桶统计当时 $x$ 轴和 $y$ 轴分别能消灭最多多少个敌方单位，求最大值。
# 代码

```cpp
#include <iostream>
#include <map>
using namespace std;
#define int long long
#pragma G++ optimize(2)
int n,ans;
struct node{
	int sx,sy,vx,vy;//s是起始点，v是速度 
}a[1005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		int x,y,v;
		char d;
		cin>>x>>y>>v>>d;
		a[i].sx=x,a[i].sy=y;
		if(d=='U'){//上 
			a[i].vx=0;//x轴不动 
			a[i].vy=v;//y轴向正方向移动 
		}
		else if(d=='D'){//下 
			a[i].vx=0;//x轴不动 
			a[i].vy=-v;//y轴向负方向移动 
		}
		else if(d=='L'){//左 
			a[i].vx=-v;//x轴向负方向移动 
			a[i].vy=0;//y轴不动 
		}
		else if(d=='R'){//右 
			a[i].vx=v;//x轴向正方向移动 
			a[i].vy=0;//y轴不动 
		}
	}
	for(int i=0;i<=1111;i++){//遍历时间 
		map <int,int> x,y;
		for(int j=1;j<=n;j++){//装桶 
			x[a[j].sx+a[j].vx*i]++;//套公式
			y[a[j].sy+a[j].vy*i]++;
		}
		for(auto j=x.begin();j!=x.end();j++){//x轴最大值 
			ans=max(ans,j->second);
		}
		for(auto j=y.begin();j!=y.end();j++){//y轴最大值 
			ans=max(ans,j->second);
		}
	}
	cout<<ans;
	return 0;
}
//AC！！！ 
```

---

## 作者：封禁用户 (赞：2)

### 读题
我们发现，$N$ 只有 $1000$ 并不大。\
又发现只需要考虑敌人在 $x$ 轴上的移动情况，如果敌人在 $y$ 轴上移动，可以直接讲移动速度设为 $0$。
对于每一对敌人 $a_i$ 和 $a_j$ 我们发现：
- 如果 $a_i$ 的移动速度和 $a_j$ 相同，初始的 $x$ 坐标相同，移动方向相同，那么这两个敌人始终在同一条线上。
- 如果 $a_i$ 的移动速度和 $a_j$ 相同，初始的 $x$ 坐标不同，移动方向相同，那么这两个敌人永远不会在同一条直线上。
- 如果 $a_i$ 的移动速度和 $a_j$ 相同，初始的 $x$ 坐标相同，移动方向不同，那么这两个敌人永远不会在同一条直线上。
- 如果 $a_i$ 的移动速度和 $a_j$ 相同，初始的 $x$ 坐标不同，移动方向不同（向外），那么这两个敌人永远不会在同一条直线上。

### 解题
可以用枚举思想，$n^2$ 的复杂度解决\
对于上述的特殊情况，只需要在循环中特判\
对于非特殊情况，我们需要计算 $a_i$ 和 $a_j$ 相遇的时间，即
$$ \frac{X_i-X_j}{V_i-V_j} $$
路程差除以速度差。

最后用一个表示相遇时间的桶，保存每两个敌人的相遇时间（记得去重），最后取最大值输出就行了。

---

## 作者：Sweet_2013 (赞：1)

# 我的解题思路
- 定义一些常量、变量和数据结构。其中， $N$ 是单位的最大数量， $T$ 是模拟的最大时间。定义了一个 $Unit$ 结构体，表示单位，包括单位的位置 $(x, y)$，速度 $v$ 和方向 $d$。定义了两个哈希表 $cntX$ 和 $cntY$，用于记录每个坐标上的单位数量。定义了一个哈希表 $dir$，用于记录每个方向的位移。
- 从输入中读取单位数量 $n$ 和每个单位的信息，包括位置、速度和方向。然后进行 $T$ 轮模拟，每轮模拟中，先清空 $cntX$ 和 $cntY$，然后对每个单位进行移动，并更新 $cntX$ 和 $cntY$。
- $cntX$ 和 $cntY$ 可以看作是桶，键是坐标，值是该坐标上的单位数量。对于每个单位，根据其位置更新 $cntX$ 和 $cntY$，将单位分布到桶中。然后找出 $cntX$ 和 $cntY$ 中的最大值，更新最大消灭单位数量 $ans$。
- 输出 $ans$。
# 上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long maxi, ans;
map<int, long long> cntX, cntY;
map<char, pair<int, int>> dir;
struct Unit {int x, y, v;char d;} unit[2000005];
int main() {
	dir.clear();
	dir['L'] = {-1, 0};
	dir['R'] = {1, 0};
	dir['U'] = {0, 1};
	dir['D'] = {1, -1};
	cin >> n;
	for (int i = 1; i <= n; i++) {
		int x, y, v;
		char d;
		cin >> x >> y >> v >> d;
		unit[i] = {x, y, v, d};
	}
	for (int t = 0; t <= 405; t++) {
		cntX.clear();
		cntY.clear();
		for (int i = 1; i <= n; i++) {
			auto u = unit[i];
			cntX[u.x]++;
			cntY[u.y]++;
		}
		for (const auto i : cntX) maxi = max(maxi, i.second);
		for (const auto i : cntY) maxi = max(maxi, i.second);
		ans = max(ans, maxi);
		for (int i = 1; i <= n; i++) {
			int v = unit[i].v;
			auto dd = dir[unit[i].d];
			unit[i].x += v * dd.first;
			unit[i].y += v * dd.second;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：gengchenghao (赞：1)

### 思路
此题的思路是枚举时间，我们可以根据速度和枚举的是时间来算出在第 $i$ 时刻每个敌人的坐标，再用把重复坐标的个数进行统计，注意坐标可能为负数所以要进行离散处理。
### 代码
``` cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int x,y,v;
	char f;
}a[10001];
map<int,int>t1,t2;//用map离散
int ans;
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y>>a[i].v>>a[i].f;
		t1[a[i].x]++;
		t2[a[i].y]++;
	}
	for(auto j:t1) ans=max(j.second,ans);
	for(auto j:t2) ans=max(j.second,ans);
  //注意第一次也有可能是最优打击时间
	for(int i=1;i<=500;i++){
		t1.clear();
		t2.clear();
		for(int j=1;j<=n;j++){ //判断第i时间点各个坐标
			if (a[j].f == 'U') a[j].y += a[j].v;
			if (a[j].f == 'D') a[j].y -= a[j].v;
			if (a[j].f == 'L') a[j].x -= a[j].v;
			if (a[j].f == 'R') a[j].x += a[j].v;
			t1[a[j].x]++;
			t2[a[j].y]++;
		}
		for(auto j:t1) ans=max(j.second,ans);
		for(auto j:t2) ans=max(j.second,ans);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：lqsy002 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P8695)。

## 解题思路

每个点的速度是不同的，超出一定的时间后，就不可能在同一条坐标轴线上。

所以暴力枚举每个时刻，统计每个时刻有多少点在同一行或者同一列，更新最大值即可。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std; 
const int maxn=1e3+5;
int n,ans;
struct node{
    int x;
    int y;
    int v;
    char d;
}a[maxn];
map<int,int>x,y;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;++i)
        cin>>a[i].x>>a[i].y>>a[i].v>>a[i].d;
    for(int t=0;t<=(maxn-5);++t){
        x.clear();
        y.clear();
        for(int i=1;i<=n;++i)
            if(a[i].d=='R'){
                ++x[a[i].x+t*a[i].v];
                ++y[a[i].y];
            }else if(a[i].d=='L'){
                ++x[a[i].x-t*a[i].v];
                ++y[a[i].y];
            }else if(a[i].d=='U'){
                ++x[a[i].x];
                ++y[a[i].y+t*a[i].v];
            }else{
                ++x[a[i].x];
                ++y[a[i].y-t*a[i].v];
            }
        for(auto p=x.begin();p!=x.end();++p)
            ans=max(ans,p->second);
        for(auto p=y.begin();p!=y.end();++p)
            ans=max(ans,p->second);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：liguangjun2023 (赞：0)

#### 题意概述
平面上有 $n$ 个点，沿着四个方向（上下左右）之一以速度 $v$ 运动，问同一条直线（平行于坐标轴）上最多有多少个点。
#### 解题思路
1. 核心思想是枚举算法，枚举不同时刻，计算共线的点数量。
2. 定义结构体数组保存点信息：起始位置、方向、速度。
3. 枚举每个时刻，计算每个点位置，分别保存在行桶数组和列桶数组。
4. 打擂台求出最大值。
5. 为节省空间，桶数组用 map 结构较为合适。
   

---


```cpp
#include <bits/stdc++.h>
using namespace std;

struct node{
	int px,py,vt;
	char dr;
}a[1010];
int n,ans;
map<int,int> rw,cl; 

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].px>>a[i].py>>a[i].vt>>a[i].dr;
	}
  
	for(int i=0;i<=1200;i++){//枚举时刻  
		rw.clear(),	cl.clear();//初始化行桶和列桶
		for(int j=1;j<=n;j++){	//枚举点，计算共线数量		
			int dr=(a[j].dr=='L' || a[j].dr=='D')?-1:1;
			int x=0,y=0;
			if(a[j].dr=='L' || a[j].dr=='R'){
				x=a[j].px+dr*a[j].vt*i,		y=a[j].py;
			}else {
				x=a[j].px,		y=a[j].py+dr*a[j].vt*i;
			}			
			rw[x]+=1,		cl[y]+=1;
		}
    //打擂台，求最大值
		for(auto j=rw.begin();j!=rw.end();j++){
			ans=max(ans,j->second);
		}
		for(auto j=cl.begin();j!=cl.end();j++){
			ans=max(ans,j->second);
		}
	}
	cout<<ans;

	return 0;
}
```

---

## 作者：a1co0av5ce5az1cz0ap_ (赞：0)

正解就是计算出任意两个敌方单位出现在同一横或纵坐标的所有时间（如果一直在同一横或纵坐标就忽略），然后计算所有时间能做到的最大值。有可能出现全被忽略的情况，所以先加入时刻 0。

但是我看见这题的时候选择了直接分讨，请大家鉴赏美食：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int n;
struct nd{//一个轨道炮
    ll x,y,v;char d;
}a[1005];
unordered_map<ll,int> cntx,cnty;
set<int> v;
char opo(char c){return c=='U'?'D':c=='D'?'U':c=='L'?'R':'L';}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].x>>a[i].y>>a[i].v>>a[i].d;
    }
    v.insert(0);
    for(int i=1;i<=n;i++){// 计算时间
        for(int j=1;j<i;j++){
            if(a[i].x==a[j].x&&a[i].y==a[j].y&&a[i].v==a[j].v&&a[i].d==a[j].d) continue;
            if(a[i].d=='U'){//y+=v
                if(a[j].d=='U'){
                    if(a[j].v>=a[i].v&&a[j].y>a[i].y||a[j].v<=a[i].v&&a[j].y<a[i].y) continue;
                    if(a[i].v==a[j].v) continue;
                    if(abs(a[i].y-a[j].y)%abs(a[i].v-a[j].v)) continue;
                    v.insert(abs(a[i].y-a[j].y)/abs(a[i].v-a[j].v));
                }
                if(a[j].d=='D'){//容易发现其实 D 和 U 差别不大
                    if(a[j].y<a[i].y) continue;
                    if(!a[i].v&&!a[j].v) continue;
                    if(abs(a[i].y-a[j].y)%abs(a[i].v+a[j].v)) continue;
                    v.insert(abs(a[i].y-a[j].y)/abs(a[i].v+a[j].v));
                }
                if(a[j].d=='L'){//LR 和 D 差别也不大，就是换一下 x y
                    if(a[j].v&&a[j].x>=a[i].x&&(a[j].x-a[i].x)%a[j].v==0) v.insert((a[j].x-a[i].x)/a[j].v);
                    if(a[i].v&&a[i].y<=a[j].y&&(a[j].y-a[i].y)%a[i].v==0) v.insert((a[j].y-a[i].y)/a[i].v);
                }
                if(a[j].d=='R'){
                    if(a[j].v&&a[j].x<=a[i].x&&-(a[j].x-a[i].x)%a[j].v==0) v.insert(-(a[j].x-a[i].x)/a[j].v);
                    if(a[i].v&&a[i].y<=a[j].y&&(a[j].y-a[i].y)%a[i].v==0) v.insert((a[j].y-a[i].y)/a[i].v);
                }
            }
            if(a[i].d=='D'){//y-=v
            	//后面的部分跟上面的几乎完全一致，只有一些符号和 x y 需要修改，所以其实考虑起来并不难
                if(a[j].d=='D'){
                    if(a[j].v>=a[i].v&&a[j].y<a[i].y||a[j].v<=a[i].v&&a[j].y>a[i].y) continue;
                    if(a[i].v==a[j].v) continue;
                    if(abs(a[i].y-a[j].y)%abs(a[i].v-a[j].v)) continue;
                    v.insert(abs(a[i].y-a[j].y)/abs(a[i].v-a[j].v));
                }
                if(a[j].d=='U'){
                    if(a[j].y>a[i].y) continue;
                    if(!a[i].v&&!a[j].v) continue;
                    if(abs(a[i].y-a[j].y)%abs(a[i].v+a[j].v)) continue;
                    v.insert(abs(a[i].y-a[j].y)/abs(a[i].v+a[j].v));
                }
                if(a[j].d=='L'){
                    if(a[j].v&&a[j].x>=a[i].x&&(a[j].x-a[i].x)%a[j].v==0) v.insert((a[j].x-a[i].x)/a[j].v);
                    if(a[i].v&&a[i].y>=a[j].y&&-(a[j].y-a[i].y)%a[i].v==0) v.insert(-(a[j].y-a[i].y)/a[i].v);
                }
                if(a[j].d=='R'){
                    if(a[j].v&&a[j].x<=a[i].x&&-(a[j].x-a[i].x)%a[j].v==0) v.insert(-(a[j].x-a[i].x)/a[j].v);
                    if(a[i].v&&a[i].y>=a[j].y&&-(a[j].y-a[i].y)%a[i].v==0) v.insert(-(a[j].y-a[i].y)/a[i].v);
                }
            }
            if(a[i].d=='R'){//x+=v
                if(a[j].d=='R'){
                    if(a[j].v>=a[i].v&&a[j].x>a[i].x||a[j].v<=a[i].v&&a[j].x<a[i].x) continue;
                    if(a[i].v==a[j].v) continue;
                    if(abs(a[i].x-a[j].x)%abs(a[i].v-a[j].v)) continue;
                    v.insert(abs(a[i].x-a[j].x)/abs(a[i].v-a[j].v));
                }
                if(a[j].d=='L'){
                    if(a[j].x<a[i].x) continue;
                    if(!a[i].v&&!a[j].v) continue;
                    if(abs(a[i].x-a[j].x)%abs(a[i].v+a[j].v)) continue;
                    v.insert(abs(a[i].x-a[j].x)/abs(a[i].v+a[j].v));
                }
                if(a[j].d=='U'){
                    if(a[i].v&&a[i].x<=a[j].x&&-(a[i].x-a[j].x)%a[i].v==0) v.insert(-(a[i].x-a[j].x)/a[i].v);
                    if(a[j].v&&a[j].y<=a[i].y&&(a[i].y-a[j].y)%a[j].v==0) v.insert((a[i].y-a[j].y)/a[j].v);
                }
                if(a[j].d=='D'){
                    if(a[i].v&&a[i].x<=a[j].x&&-(a[i].x-a[j].x)%a[i].v==0) v.insert(-(a[i].x-a[j].x)/a[i].v);
                    if(a[j].v&&a[j].y>=a[i].y&&-(a[i].y-a[j].y)%a[j].v==0) v.insert(-(a[i].y-a[j].y)/a[j].v);
                }
            }
            if(a[i].d=='L'){//x-=v
                if(a[j].d=='L'){
                    if(a[j].v>=a[i].v&&a[j].x<a[i].x||a[j].v<=a[i].v&&a[j].x>a[i].x) continue;
                    if(a[i].v==a[j].v) continue;
                    if(abs(a[i].x-a[j].x)%abs(a[i].v-a[j].v)) continue;
                    v.insert(abs(a[i].x-a[j].x)/abs(a[i].v-a[j].v));
                }
                if(a[j].d=='R'){
                    if(a[j].x>a[i].x) continue;
                    if(!a[i].v&&!a[j].v) continue;
                    if(abs(a[i].x-a[j].x)%abs(a[i].v+a[j].v)) continue;
                    v.insert(abs(a[i].x-a[j].x)/abs(a[i].v+a[j].v));
                }
                if(a[j].d=='U'){
                    if(a[i].v&&a[i].x>=a[j].x&&(a[i].x-a[j].x)%a[i].v==0) v.insert((a[i].x-a[j].x)/a[i].v);
                    if(a[j].v&&a[j].y<=a[i].y&&(a[i].y-a[j].y)%a[j].v==0) v.insert((a[i].y-a[j].y)/a[j].v);
                }
                if(a[j].d=='D'){
                    if(a[i].v&&a[i].x>=a[j].x&&(a[i].x-a[j].x)%a[i].v==0) v.insert((a[i].x-a[j].x)/a[i].v);
                    if(a[j].v&&a[j].y>=a[i].y&&-(a[i].y-a[j].y)%a[j].v==0) v.insert(-(a[i].y-a[j].y)/a[j].v);
                }
            }
        }
    }
    int mx=0;
    for(auto j:v){// 计算最大值
        cntx.clear();cnty.clear();
        for(int i=1;i<=n;i++){
            ll tx=a[i].x,ty=a[i].y,tv=a[i].v;
            char td=a[i].d;
            if(td=='U') ty+=j*tv;
            if(td=='D') ty-=j*tv;
            if(td=='R') tx+=j*tv;
            if(td=='L') tx-=j*tv;
            cntx[tx]++;cnty[ty]++;
            mx=max({mx,cntx[tx],cnty[ty]});
        }
    }
    cout<<mx<<endl;
    return 0;
}
```

其实分讨并不难写，大部分都是复制粘贴然后改横纵坐标和符号，只要想清楚两种情况（U 和 U，U 和 L）即可。

---

## 作者：_cpp (赞：0)

### Part 1 思路：
由于此题 $n$ 较小，所以可以考虑枚举时间 $t$ 来判断在同一时间每个点的位置。至于 $t$ 枚举到多少，就取决于各位 dalao 的判断，小了可能 WA，大了可能会消耗更多的时间，所以在此我试出来 $t$ 的最佳范围是 $0 \sim 400$。

在题目中，每个敌人都会朝不同的方位行进，参考下图：[![pPMWQoR.png](https://s1.ax1x.com/2023/08/15/pPMWQoR.png)](https://imgse.com/i/pPMWQoR)
根据 $s = vt$ 计算出当前时间每个敌人的具体位置。

计算好每个敌人的位置后，可以用两个桶来分别统计平行于 $x$ 轴和平行于 $y$ 轴上的敌人位置。最后遍历一遍两个桶，找出最大值即可。


### Part 2 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
struct g{
    int x,y,way,v;
}a[1010];
char ch;
int n,dx[] = {1,-1,0,0},dy[] = {0,0,1,-1},max1;
int main()
{
    cin >> n;
    for(int i = 1;i <= n;i++){
        cin >> a[i].x >> a[i].y >> a[i].v >> ch;
        if(ch == 'U') a[i].way = 2;
        if(ch == 'R') a[i].way = 0;
        if(ch == 'D') a[i].way = 3;
        if(ch == 'L') a[i].way = 1; //算出方位
    }
    for(int t = 0;t <= 400;t++){
        map<int,int> mx;
        map<int,int> my;
        for(int i = 1;i <= n;i++){
            mx[a[i].x + dx[a[i].way] * t * a[i].v]++;
            my[a[i].y + dy[a[i].way] * t * a[i].v]++; //计算坐标
        }
        for(auto it : mx)
            if(it.second > max1) max1 = it.second;
        for(auto it : my)
            if(it.second > max1) max1 = it.second; //遍历桶，找最大值（由于题目中x坐标和y坐标可能为负，所以得用map映射表）
    }
    cout << max1;
    return 0;
}
```


---

## 作者：Dreamer_Boy (赞：0)

#### 题目大意
一个平面上有 $n$ 个点分别向上、下、左、右四个方向移动，每个点有速度 $v$ 求解最多会有几个点会在同一行或同一列上，即纵坐标或横坐标相同。

题目样例图示如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/17072351.png)

$x$ 轴上的两个点永远在同一行上，向下走的点在某一时刻也会到达 $x$ 轴，这样最多有 $3$ 个点在同一直线上。

我们再创建两个列表存储每个点的横坐标和纵坐标，当然也可以创建一个列表，每个子列表存储每个点的坐标，两个列表存储每个点在横方向的速度和在纵方向的速度 $X$ 表示存储每个点的横坐标，$Y$ 表示存储每个点的纵坐标，$vx$ 表示存储每个点在横方向的速度，$vy$ 表示存储每个点在纵方向的速度。

当然速度需要规定方向。

设定 $x$ 方向向右为正，向左为负，设定 $y$ 方向向上为正，向下为负。

最后我们解决了一系列难点，就可以得出贪心结论，我们锁定每一个点，求它最多会和几个点共线，然后再找所有点的同 $x/y$ 时刻 $t$ 的点数的最大值，我们还可以开一个 map 维护。

#### 代码
仅给出重要部分，想要完整的同学可以私信。

```
for(int t=0;t<=1000;t++)
    {
        for(int i=1;i<=n;i++)
        {
            nx[i] = sx[i] + dx[dir[i]]*t*v[i];
            ny[i] = sy[i] + dy[dir[i]]*t*v[i];
        }
        map<int,int> mx;
        map<int,int> my;
        for(int i=1;i<=n;i++)
        {
            mx[nx[i]]++;
            my[ny[i]]++;
        }
        for(auto o : mx)
        {
            if(o.second>maxn)
            {
                maxn = o.second;
                maxm = o.first;
            }
        }
        for(auto o : my)
        {
            if(o.second>maxn)
            {
                maxn = o.second;
                maxm = o.first;
            }
        }
    }
```

---


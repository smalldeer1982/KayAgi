# [蓝桥杯 2020 省 A1] 整数小拼接

## 题目描述

给定一个长度为 $n$ 的数组 $A_1,A_2,\cdots,A_n$。你可以从中选出两个数 $A_i$ 和 $A_j$($i\neq j$)，然后将 $A_i$ 和 $A_j$ 一前一后拼成一个新的整数。例如 `12` 和 `345` 可以拼成 `12345` 或 `34512`。注意交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，即便是 $A_i=A_j$ 时。

请你计算有多少种拼法满足拼出的整数小于等于 $K$。


## 说明/提示

对于 $30\%$ 的评测用例 $1\le n\le1000$，$1\le k\le10^8$，$1\le A_i\le10^4$。

对于所有评测用例，$1\le n\le10^5$，$1\le k\le10^{10}$，$1\le A_i\le10^9$。

蓝桥杯 2020 第一轮省赛 A 组 H 题。

## 样例 #1

### 输入

```
4 33
1 2 3 4```

### 输出

```
8```

# 题解

## 作者：Zaku (赞：16)

这题考双指针和排序。

#### 解法：
从数组里面选取两个数字，进行拼接，暴力枚举时间复杂度为 $\Theta(n^2)$，会超时。

我们可以使用类二分的双指针算法，先将数组进行排序，左指针指向数组开始点，右指针指向数组结束点，向中间移动。对于两个指针选取到的数，进行拼接。

- 如果拼接后的数字小于 $k$，那么因为 $r$ 指针指向的是目前的最大值，所以 $[l,r]$ 区间内的所有数字与 $l$ 拼接的结果都小于 $k$，所以答案加上 ```r - l```，并且更新左指针 ```l ++```；

- 如果拼接后的数字等于 $k$，同理答案加上 ```r - l```，但是此时需要同时更新左、右指针 ```l ++, r –-```；

- 如果拼接后的数字大于 $k$，不更新答案，更新右指针 ```r –-``` 即可。

由于交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，所以我们跑两遍双指针，分别放前面、放后面即可。

对于拼接操作，如果直接使用数字进行拼接比较麻烦，可以用  ```to_string``` 转化为字符串再进行拼接，但需要自己手写一个字符串比较大小的函数。

#### 代码：
```cpp
#include <bits/stdc++.h> 
using namespace std;
const int N = 1e5 + 5;
typedef long long ll;
ll a[N];
string s[N], str;//s[i]表示转为字符串的 a[i];str表示转为字符串的 k 
ll n, k;
int cmp(string s1, string s2) {//字符串大小比较，不解释 
    if (s1.size() == s2.size()) { 
        if (s1 == s2) return 0;
        else if (s1 < s2) return 1;
        else return -1;
    }
    if (s1.size() < s2.size()) return 1;
    else return -1;
}
void init() {//初始化，不解释 
	cin >> n >> k;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    sort(a + 1, a + 1 + n);
    for (int i = 1; i <= n; i ++ ) s[i] = to_string(a[i]);
    str = to_string(k);
}
int main() {
	init();
    ll res = 0;
    //第一遍双指针 
    int l = 1, r = n;
    while(l <= r) {
        int t = cmp(s[l] + s[r], str);
        //l放前面，r放后面 
        if(t == 1) {//拼接后小于k 
            res += r - l;
            l ++;
        } else if(t == 0) {//拼接后等于k 
            res += r - l;
            l ++, r --;
        } else r --;//拼接后大于k 
    }
    //第二遍双指针 
    l = 1, r = n;
    while(l <= r) {
        int t = cmp(s[r] + s[l], str);//r放前面l放后面 
        if(t == 1) {//同第一遍
            res += r - l;
            l ++;
        } else if(t == 0) {
            res += r - l;
            l ++, r --;
        } else r --;  
    }
    cout << res;
    return 0;
}
```
个人马蜂有变化，不喜勿喷

---

## 作者：AndyPomeloMars (赞：10)

## P8708 [蓝桥杯 2020 省 A1] 整数小拼接 题解

### 题目大意

* 给定一个长度为 $n$ 的数组 $A_1,A_2,\cdots,A_n$。从中选出两个数 $A_i$ 和 $A_j$（$i\neq j$），然后将 $A_i$ 和 $A_j$ 一前一后拼成一个新的整数（交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，即便是 $A_i=A_j$ 时），请你计算有多少种拼法满足拼出的整数小于等于 $K$。

* 其中：$1\le n\le10^5$，$1\le k\le10^{10}$，$1\le A_i\le10^9$。

### 题目分析

如果直接从数组里面选取两个数进行拼接，那么时间复杂度是 $O(n^2)$ 的。根据题目条件：$1\le n\le10^5$，可得知暴力解法是超时的，不能通过本题。

因此，我们可以先将数组用 `sort` 函数排序，再使用类似于双指针的方法解决。

我们使用变量 $P$ 来表示当前最大可行范围。

1. 初始化 $P = N$。

2. 进行 `for` 循环：```for (int i = 1; i <= N; ++i) ```（其中 $i$ 代表左指针）。

3. 使用 `while` 循环来确定 $P$ 的最大下标。

4. 将答案 $ANS$ 加上 $P$。

5. 如果 $i \leq P$，$ANS$ 减去 $1$。

这道题的另外一个重点是如何将两个数拼起来。

一种可行的办法是用 `while` 循环来计算位数，然后再使用数学方法来拼接。

另一种更优的方法是：使用 `to_string` 和 `stoll` 函数，这样我们只需要把数字转换成字符串，再将字符串转换成 `long long` 类型即可，具体代码如下：

```cpp
inline long long connect(long long a, long long b){
    return stoll(to_string(a) + to_string(b));
}
```

### 题目结论

1. `sort` 函数进行排序。

2. `for` + `while` + `connect` 计算答案。

3. 输出答案。

### 题目代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int MAXN = 100010;

ll N, K, P, ANS;
ll A[MAXN];

inline ll connect(ll a, ll b){
    return stoll(to_string(a) + to_string(b));
}

int main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> N >> K;
    for (int i = 1; i <= N; ++i) cin >> A[i];
    sort(A + 1, A + N + 1);
    P = N;
    for (int i = 1; i <= N; ++i){
        while (P > 0 && connect(A[P], A[i]) > K) --P;
        ANS += P, ANS -= (P >= i);
    }
    cout << ANS << endl;
    return 0;
}
```

---

## 作者：Crasole (赞：4)

## 题意

----

给出一个长度为 $n$ 的数组 $A_1,A_2,...,A_n$。可以从中两个数 $A_i$ 和 $A_j$，然后拼接起来，如 `12` 和 `345` 可以拼出 `12345` 和 `34512`，要特别注意的是，交换 $A_i$ 和 $A_j$ 的顺序被视为 $2$ 种拼法，即便是 $A_i = A_j$ 时。

现在问：一共有多少种拼法满足拼出的结果小于等于 $K$。

## 思路

---

因为 $n \le 10^5$ 所以暴力枚举肯定会超时。

假设数组是有序的，那么我们就可以运用双指针。

假设现在 $i$ 指针指向 $A_i$，$j$ 指针指向 $A_j$。有两种情况：

- 如果 $A_i$ 与 $A_j$ 进行拼接得到的结果小于等于 $k$，那么 $A_i$ 与 $A_{i+1},...,A_r$ 这些数字拼起来都小于 $K$，然后答案加上 `j-i`，并且同时移动 $i$ 指针，也就是 `i++`。

- 如果 $A_i$ 与 $A_j$ 进行拼接得到的结果大于 $K$ 那么移动 $j$ 指针，也就是 `j--`。

## 代码

---

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,s;
ll k,a[100010];
ll pj(int i,int j){//整数i与整数j拼接
	ll tj=j,sj=1;
    while(tj>0){sj*=10;tj/=10;}//算出整数j的位数
    return i*sj+j;
}
int main(){
	scanf("%d%lld",&n,&k);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);//将数组从小到大排列
	int i=1,j=n;
	while(i!=j){
		ll t=pj(a[i],a[j]);
		if(t<=k){s+=j-i;i++;}//如果小于等于k，那么统计答案
		else j--; //否则移动j指针，缩小范围
	}
 	//反着再拼一遍 
	i=1;j=n;
	while(i!=j){
		ll t=pj(a[j],a[i]);
		if(t<=k){s+=j-i;i++;}
		else j--; 
	}
	printf("%d",s);
	return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 更新：
1.2023.7.25：题解通过后本人发现两处笔误，进行修改。请管理重新审核，谢谢！

---

### 性质：
假设我们要将 $A,B$ 和 $A,C$ 两组数拼起来（$A$ 在前）。  
为了避免字太多影响阅读，我称上面操作为 $A$ 拼 $B$ 和 $A$ 拼 $C$。   
设 $B\le C$。如果 $A$ 拼 $B$ 大于 $K$，那么 $A$ 拼 $C$ 必然大于 $K$。 如果 $A$ 拼 $C$ 小于等于 $K$，那么 $A$ 拼 $B$ 必然小于等于 $K$。 

证明：
* 当 $B,C$ 位数不同时，必然是 $C$ 位数更多。那么 $A$ 拼 $C$ 的位数多于 $A$ 拼 $B$ 的位数。所以 $A$ 拼 $C$ 大于 $A$ 拼 $B$。
* 当 $B,C$ 位数相同时，从高位往低位比较。$A$ 拼 $C$ 前面一段高位上的数等于 $A$ 拼 $B$ 前面一段高位上的数（都是 $A$）。从 $B,C$ 原本的最高位开始比较，结果就是 $B,C$ 原本的大小关系，即 $A$ 拼 $C$ 大于等于 $A$ 拼 $B$。  

---

### 思路：
根据上面的性质，我们发现 $A$ 拼另一个数是否成功是单调的。  
首先将数列 $A$ 排序。  
如果我们发现 $A_i$ 拼 $A_j$ 小于等于 $K$，那么 $A_i$ 拼 $A_1,A_2,\dots,A_{i-1}$ 肯定都小于等于 $K$，考虑二分。  
循环从 $1\sim n$ 枚举 $A_i$，对于每个 $A_i$，找到能拼的最大的 $A_j$。那么 $A_i$ 能拼的数有 $j$ 个。  
**注意：当 $j\ge i$ 时，$A_i$ 能拼的数包括了 $A_i$ 自己，但是题意中不能自己拼自己，所以答案要减一。**  
因为我们从 $1\sim n$ 枚举的是拼时在前的数，因此不会漏解，也不会多解。

---

### 代码和[提交记录](https://www.luogu.com.cn/record/117308638)
```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;

int n;
int l,r,mid;
ull cnt;
ull ans;
ull k,a[100003];

bool check(ull x,ull y){
	ull y2=y;
	while(y2){
		x*=10;
		y2/=10;
	}
	return x+y<=k;
}

int main(){
	scanf("%d%u",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%u",&a[i]);
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		ans=l=0;
		r=n;
		while(l<=r){
			mid=l+r>>1;
			if(check(a[i],a[mid])){
				ans=mid;
				l=mid+1;//找能拼的最大的A[j]
			}
			else r=mid-1;
		}
		cnt+=ans;
		if(ans>=i)--cnt;
	}
	printf("%u",cnt);
	return 0;
}
```

---

## 作者：A_Bit_Cold (赞：3)

$\texttt {update at 2023.4.24}$：发现 $s$ 没赋初值 $0$。

[P8708 [蓝桥杯 2020 省 A1] 整数小拼接 的传送门](https://www.luogu.com.cn/problem/P8708)

数据范围 $1\le n\le10^5$，$\Theta(n^2)$ 显然过不了，考虑 $\Theta(n)$ 算法。

双指针是一个很好的选择，即有左指针 $l$，右指针 $r$，判断 $A_l$ 和 $A_r$ 拼成的整数是否小于等于 $k$，从而决定左右指针的移动。

由于交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，所以我们需要做两次双指针，一次是 $A_l$ 和 $A_r$ 拼，一次是 $A_r$ 和 $A_l$。

又因为是双指针，需要排序，这样才能保证指针移动的正确性。

在移动指针时考虑一下三种情况：

- 若 $A_l$ 和 $A_r$ 拼出的数大于 $k$，说明这种情况不合法，答案不加，右指针 $r$ 往左移，使 $A_l$ 和 $A_r$ 拼出的数更小。

- 若 $A_l$ 和 $A_r$ 拼出的数等于 $k$，说明这种情况合法，则$A_l$ 与 $A_{i\in(l,r]}$ 这些数拼出的数都小于等于 $k$，即将答案加上 $r-l$，此时将右指针 $r$ 往左移，找到更小的符合 $A_l$ 和 $A_r$ 拼出的数小于等于 $k$ 的数，但由于 $A_l$ 与 $A_{r-1}$ 在刚才已经统计过了，不能重复，所以左指针 $l$ 要往右移，这样才能避免重复。

- 若 $A_l$ 和 $A_r$ 拼出的数小于 $k$，说明这种情况合法，则$A_l$ 与 $A_{i\in(l,r]}$ 这些数拼出的数都小于 $k$，即将答案加上 $r-l$，此时将左指针 $l$ 往右移，是 $A_l$ 和 $A_r$ 拼出的数更大。

$A_i$ 和 $A_j$ 拼接的方法：由于数字不大，所以可以采用数字拼接法，如下：

若 $A_j$ 有 $t$ 位，则 $A_i$ 和 $A_j$ 的拼接可以表示为 $A_i \cdot10^t+A_j$，即那 $t$ 个 $0$ 分别让给 $A_j$ 的各个位。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
long long a[N];
int w(long long x) {//计算x的位数
	int s=0;
	while(x) x/=10,s++;
	return s;
}
long long power(long long x,long long y) {//快速幂
	if(!y) return 1;
	long long k=power(x,y>>1);
	if(y&1) return k*k*x;
	else return k*k;
}
int main() {
	long long n,k,ans=0;
	cin>>n>>k;
	for(long long i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);//排序
	long long l=1,r=n;
	while(l<=r) {
		if(a[l]*power(10,w(a[r]))+a[r]>k) r--;//大于k，左移r
		else if(a[l]*power(10,w(a[r]))+a[r]<k) ans+=r-l,l++;//小于k，右移l
		else ans+=r-l,l++,r--;//等于k，左移r，右移l
	}
	l=1,r=n;//将指针还原
	while(l<=r) {//同上
		if(a[r]*power(10,w(a[l]))+a[l]>k) r--;
		else if(a[r]*power(10,w(a[l]))+a[l]<k) ans+=r-l,l++;
		else ans+=r-l,l++,r--;
	}
	cout<<ans;
   return 0;
}
```


---

## 作者：封禁用户 (赞：2)

## 题目描述

[[蓝桥杯 2020 省 A1] 整数小拼接](https://www.luogu.com.cn/problem/P8708)

### 注意事项

本题用了双指针，不会的同学先看看[这个](https://blog.csdn.net/qq_52595134/article/details/121385996)。

## 算法思路

#### 算法：双指针

我们用 $l$ 表示左端点，$r$ 表示右端点。

- 如果 $a_l$ 和 $a_r$ 这两个数合并起来比 $k$ 小，那么 $a_r$ 之前的数与 $a_l$ 合并起来都一定比 $k$ 小。这时就有了 $r - l$ 个组合满足条件。统计完之后把 $l + 1$。

- 如果 $a_l$ 和 $a_r$ 这两个数合并起来比 $k$ 大，那么就继续寻找下一个数。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//日常开long long 
struct st
{
	ll now,len;//now记录值，len记录长度 
	bool operator < (const st &u)const//重载运算符 
	{
		return now<u.now;
	}
};
const ll N=100010;
ll n,m,power[N],tmp,l,r,ans;
st a[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	power[0]=1;
	for(int i=1;i<=18;i++)//求10的幂次 
	{
		power[i]=power[i-1]*10;
	}
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].now;
		tmp=a[i].now;
		while(tmp)//求长度 
		{
			a[i].len++;
			tmp/=10;
		}
	}
	sort(a+1,a+n+1);//sort排序 
	l=1;
	r=n;
	while(l<r)//双指针two-pointer 
	{
		tmp=a[l].now*power[a[r].len]+a[r].now;//合并 
		if(tmp<m)//可行 
		{
			ans+=r-l;//答案加上 
			l++;
		}
		else//不可行 
		{
			r--;
		}
	}
	l=1;
	r=n;
	while(l<r)//反正再做一遍 
	{
		tmp=a[r].now*power[a[l].len]+a[l].now;
		if(tmp<=m)
		{
			ans+=r-l;
			l++;
		}
		else
		{
			r--;
		}
	}
	cout<<ans<<"\n";//输出
	return 0;
}
```

---

## 作者：01Dragon (赞：2)

### 思路
本题可以使用双指针做。
先把左指针 $l$ 和右指针 $r$ 放在两头：

- 如果指针指向的两个数拼接起来比 $k$ 小，那么右指针之前的的所有数与左指针拼接起来都一定比 $k$ 小。这时就有了 $r-l$ 个组合满足条件。统计完之后把左指针 $l$ 向右移动一格。
- 如果指针指向的两个数拼接起来比 $k$ 大，那么那么就继续寻找，将右指针 $r$ 向左移动一格。

因为拼接有两种方式，所以我们要循环两遍。

关于两个数的拼接，我们可以用数学的方法。举个例子： $123$ 拼接 $45$ 就可以用 $123\times 100 + 45$ 计算。其中的 $100$ 就是将 $10$ 乘 $45$ 的位数次。
### 代码
```cpp
#include<iostream> 
#include<cstdio> 
#include<algorithm> 
#include<cmath> 
#include<deque> 
#include<vector> 
#include<queue> 
#include<string> 
#include<cstring> 
#include<map> 
#include<stack> 
#include<set> 
using namespace std;
long long n,k,a[100005],r,ans,l=1;
int siz(int x)//判断一个数的位数，用于拼接两个数
{
	int ans=0;
	while(x>0)
	{
		x/=10;
		ans++;
	}
	return ans;
}
int main()
{
	cin>>n>>k;
	r=n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	while(r>l)第一次查找
	{
		long long shu1=a[l]*pow(10,siz(a[r]))+a[r];//拼接
		if(shu1<k)
		{
			ans+=r-l;
			l++;
		}
		else
		{
			r--;
		}
	}
	r=n;
	l=1;
	while(r>l)第二次查找
	{
		long long shu1=a[r]*pow(10,siz(a[l]))+a[l];//拼接
		if(shu1<=k)
		{
			ans+=r-l;
			l++;
		}
		else
		{
			r--;
		}
	}
	cout<<ans;
	return 0;
} 
```



---

## 作者：Light_Star_RPmax_AFO (赞：1)

## 前言

[传送门](https://www.luogu.com.cn/problem/P8708)

[blog](https://www.luogu.com.cn/blog/JJL0610666/solution-p8708)

# 思路

这种选出两个数拼接在一起的题，一看就可以使用 two-point，我们使用 $l$ 和 $r$ 分别从最大的和最小的开始搜索，进行两次。

1. 以 $l$ 为头，$r$ 为尾。

2. 以 $r$ 为头，$l$ 为尾。

如何比较大小呢？我们可以先去做[宇宙总统](https://www.luogu.com.cn/problem/T300162)这道题。

首先排序的 $cmp$：

```cpp
bool cmp(string x,string y){
	if(x.size() != y.size())return x.size() < y.size();
	else return x < y; 
}
```

然后是比较拼接的数的大小的 $check$：

```cpp
int check(string x,string y){
	if(x == y)return -1;
	else return cmp(x,y);
}
```
这样我们就可以完成排序与比大小了。

# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;

string a[100010];

bool cmp(string x,string y){
	if(x.size() != y.size())return x.size() < y.size();
	else return x < y; 
}

int check(string x,string y){
	if(x == y)return -1;
	else return cmp(x,y);
}

int main(){
	int n;
    string k;
    cin>>n>>k;
    for(int i = 1;i <= n;i++){
    	cin>>a[i];
	}
	sort(a + 1,a + 1 + n,cmp);
	int l = 1,r = n;int ans = 0;
	while(l < r){
		int ch = check(a[r] + a[l],k);
		if(ch == -1){
			ans += r - l;
			l++,r--;
		}else
			if(ch == 1){
				ans += r - l;
				l++;
			}else{
				r--;
			}
	}
	l = 1,r = n;
	while(l < r){
		int ch = check(a[l] + a[r],k);
		if(ch == -1){
			ans += r - l;
			l++,r--;
		}else
			if(ch == 1){
				ans += r - l;
				l++;
			}else{
				r--;
			}
	}
	cout<<ans;
}
```

---

## 作者：DengDuck (赞：1)

这道题我的思路是双指针。

首先，给数字排个序。

假设我们将 $a_j$ 拼接在 $a_i$ 后面，观察满足条件的 $j$ 的取值。

我们分两种情况考虑：

- 当 $i<j$ 时，不难发现 $j$ 随着 $i$ 增大而减小。
- 当 $i>j$ 时，不难发现 $j$ 也是随着 $i$ 增大而减小。

这是因为排序之后，数组满足一个单调性，拼接的值，当 $i$ 增大时，都会增大，所以满足条件的 $j$ 会变少。

所以我们根据这两种不同的情况各来一次双指针求解。

每次求解出最大的 $j$，其贡献为 $j-i$。

这里的数字我们用字符串维护很方便，但是根据字符串的比较特性，我们要手动加上先看长度的特性。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,ans;
string k,a[200005];
bool cmp(string x,string y)
{
	if(x.size()<y.size())return true;
	if(x.size()>y.size())return false;
	return x<y;
}
int main()
{
	scanf("%lld",&n);
	cin>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);
	LL t=n;
	for(int i=1;i<=n&&i<t;i++)
	{
		while(i<t&&cmp(k,a[i]+a[t]))t--;
		ans+=t-i;
	}
	t=n; 
	for(int i=1;i<=n&&i<t;i++)
	{
		while(i<t&&cmp(k,a[t]+a[i]))t--;
		ans+=t-i;
	}
	printf("%lld",ans);
}
```

---

## 作者：jb123456 (赞：1)

### 暴力+二分+判断
看到题目，首先想到的是暴力枚举两个数，判断是否成立，但我们可以想到，如果从小到大排序过后，第二个数越大，拼起来就越大，符合了二分的单调性，那就找到最大的成立的地方，答案加上就可以了。但是，如果仔细看题，可以发现不可以选择下标同样的，也就是说如果二分的答案比第一个数的下标大，就需要减去一，其余就没有什么了。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005];
long long f(int x,int y){//判断下标是x和y时是否成立。 
	long long k=a[y],u=1;
	while(k){
		u*=10;
		k/=10;
	}//判断位数。
	return a[x]*u+a[y];
}
int main()
{
	int n;
	long long k;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	long long s=0;
	for(int i=1;i<=n;i++){
		int l=1,r=n;
		while(l<=r){
			int o=(l+r)/2;
			if(f(i,o)<=k)l=o+1;
			else r=o-1;
		}
		if(r>=i)r--;//解释中有。 
		s+=r;
	}
	cout<<s;
	return 0;
}
```


---

## 作者：zhangjiting (赞：1)

## 思路

首先，要对数组 $a$ 排序，并用 $len$ 数组记录拼接后，若这个数放在后面，那么另一个数要乘的倍率。

然后，若 $a$ 与 $e$ 拼接的数（$ae$）比 $k$ 小，那么 $ab$、$ac$、$ad$ 都应该比 $k$ 小（他们符合单调递增规律），因此只需找到 $a$ 在前时，与最后一个与 $a$ 结合小于 $k$ 的数，这里可以用二分法提高效率。

注意点：若找到最后一个与 $a$ 结合小于 $k$ 的数 $e$，此时要注意减去 $aa$ 这种情况，因为要选两个整数拼接，不可以选取同一个数。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100005;
typedef long long ll;
ll len[N];
ll a[N];
ll n,k;
ll num;
ll l,r,mid;
ll ans;
int main()
{
    cin>>n>>k;

    for(int i=1;i<=n;++i) cin>>a[i];

    sort(a+1,a+n+1);

    num=k;
    len[0]=1;
    while(num)
    {
        len[0]*=10;
        num/=10;
    }
    for(int i=1;i<=n;++i){
        num=a[i];
        len[i]=1;
        while(num)
        {
            len[i]*=10;
            num/=10;
        }
    }


    for(int i=1;i<=n;++i)
    {
        l=0,r=n;
        while(l<r)
        {
            mid= l+r+1 >> 1;
            if(a[i]*len[mid]+a[mid]<k&&a[i]*len[mid]+a[mid]>0) l=mid;
            else r=mid-1;
        }
        if(l>=i) l--;
        ans+=l;
    }

    cout<<ans<<endl;

    return 0;
}
```


---

## 作者：liangbob (赞：0)

### P8708 题解

#### 思路分析

二分题。

证明一个小结论：

设 $a$ 和 $c$ 拼接小于 $k$，若存在 $b \leq c$ ，则 $a$ 和 $b$ 拼接必然小于 $k$。

这个非常显然的其实，因为比较的时候，$a$ 部分是不影响的，所以就由 $b$ 和 $c$ 来决定这个大小，而 $b$ 和 $c$ 的大小显然，所以得证。

于是根据这个结论，我们可以认为答案具有单调性，不过是在原数组排序的前提下。

然后二分就 OK 了。我们遍历数组，每次找到最后一个和遍历到的拼接满足条件的就可以了，根据结论，那个最后一个数的下标就是答案。

但是需要注意，如果下标大于遍历到的数的下标，答案还得减去一，因为自己不能和自己拼接。

#### 代码

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
#include <string>
#include <algorithm>
#include <cstdio>
#include <cstring>
#define endl '\n'
#define int long long
#define IL inline
using namespace std;
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;

IL int read()
{
    int x = 0,f = 1;
    char c = getchar();
    while(c <'0'|| c >'9'){if(c == '-') f = -1;c = getchar();}
    while(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0',c = getchar();
    return x * f;
}

void write(int x)
{
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int a[N];
int n, k;

bool check(int x, int y)
{
	int w = log10(y) + 1;
	int g = x * __builtin_fabs(10, w) + y;
	return g <= k;
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> k;
    for(int i = 1;i <= n;i++)
    {
    	cin >> a[i];
	}
	sort(a + 1, a + n + 1);
	int ans = 0;
	for(int i = 1;i <= n;i++)
	{
		int l = 1, r = n;
		while(l <= r)
		{
			int mid = (l + r) >> 1;
			if(check(a[i], a[mid]))
			{
				l = mid + 1;	
			} 
			else
			{
				r = mid - 1;
			}
		}
		if(r >= i) r--;
		ans += r;
	}
	cout << ans << endl;
    return 0;
}                    
```

---

## 作者：SilverLi (赞：0)

[整数小拼接 の 传送门](https://www.luogu.com.cn/problem/P8708)

## 暴力

两两暴力，并判断连在一起是否小于 $K$。

时间复杂度为 $O(n^2)$。

## 二分

将原序列排序，枚举每一个 $A_i$，二分找出能和它配对的 $A_j$，时间复杂度为 $O(n\log{n})$。

拼接两个整数时可以用 `log10(x)+1` 计算整数 $x$ 的位数。

二分没必要自己写，可以用 `upper_bound`。

先介绍一下 `upper_bound`。

`upper_bound(s,t,x)` 表示在 $s$ 到 $t$ 这个区间内第一个**大于** $x$ 的数的位置。

例如有查找 $x$ 在长度为 $n$ 的 $a$ 数组中第一个比它大的数 `upper_bound(a+1,a+n+1,x)-a`。

为什么要减去 $a$ 呢？因为 `upper_bound` 返回的是一个该数在内存中的地址，而减 $a$ 后就得到该内存地址在 $a$ 数组中对应的位置。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 100100;
int n;
long long k, a[MAX_N], ans;
int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i)	cin >> a[i];
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i) {
        if (a[i] > k % (long long)pow(10, int(log10(a[i]) + 1))) {
            ans += upper_bound(a + i + 1, a + n + 1, k / (long long)pow(10, int(log10(a[i]) + 1)) - 1) - 1 - a - i;
            ans += upper_bound(a + 1, a + i, k / (long long)pow(10, int(log10(a[i]) + 1)) - 1) - 1 - a;
        } else {
            ans += upper_bound(a + i + 1, a + n + 1, k / (long long)pow(10, int(log10(a[i]) + 1))) - 1 - a - i;
            ans += upper_bound(a + 1, a + i, k / (long long)pow(10, int(log10(a[i]) + 1))) - 1 - a;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---


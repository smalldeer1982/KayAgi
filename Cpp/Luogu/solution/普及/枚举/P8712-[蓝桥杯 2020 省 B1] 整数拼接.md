# [蓝桥杯 2020 省 B1] 整数拼接

## 题目描述

给定一个长度为 $n$ 的数组 $A_1,A_2,\cdots,A_n$。你可以从中选出两个数 $A_i$ 和 $A_j$（$i\neq j$），然后将 $A_i$ 和 $A_j$ 一前一后拼成一个新的整数。例如 `12` 和 `345` 可以拼成 `12345` 或 `34512`。注意交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，即便是 $A_i=A_j$ 时。

请你计算有多少种拼法满足拼出的整数是 $K$ 的倍数。


## 说明/提示

对于所有评测用例，$1\le n\le10^5$，$1\le k\le10^5$，$1\le A_i\le10^9$。

蓝桥杯 2020 第一轮省赛 B 组 I 题。

## 样例 #1

### 输入

```
4 2
1 2 3 4```

### 输出

```
6```

# 题解

## 作者：qiuqiuyaq (赞：9)

### 题意简述
给出 $n$ 个整数 $a_1$ $∼$ $a_n$，需要从中挑下标不同的两个数，例如挑选 $12$ 和 $345$ 可以拼接为 $12345$ 或者 $34512$
，问一共有多少种拼接方式使得拼接之后的数是 $k$ 的倍数？
#### 注意

拼接的顺序不同算不同的方案，即使 $A_i$ 等于 $A_j$。
#### 时间复杂度分析

$n$ 为 $10^5$ 时间复杂度要控制在 $\mathcal{O}(n \log n )$ 以内。
#### 实现思路

考虑枚举加优化。

我们可以枚举后面这个数 $A_i$，枚举完 $A_i$ 之后，$A_i$ 就固定了，然后再枚举一下前面有多少种不同的选法，使得 $A_jA_i$ 这个数是 $k$ 的倍数。

用 $k_i$ 表示 $A_i$ 的位数，例如 

$123$ $=$ $12$ $\times$ $10$ $+$ $3$，$A_i$ 的位数为 $1$ 位。


当我们枚举 $i$ 之后，$k_i$ 与 $A_i$ 都是固定的，变量就只剩下 $j$，相当于问有多少个 $j$ 使得 $A_j \times 10^{k_i} + A_i$ 恰好能够整除 $k$？

可以用哈希表或者数组存储
，所有数的范围是从 $1$ 到 $10^9$，位数最多是 $10$ 位。

开 $11$ 个哈希表，第 $u$ 个哈希表存储 $A_j \times 10^u \bmod k$，$u∈ (0,10)$ 的余数出现的次数。

预处理的时间复杂度为 $A_j$ 的个数 $n$ $\times$ $11$。

#### 公式推导

由

$A_i \times 10^{k_i} + A_i  \equiv  0 \pmod k$

得

$A_j \times 10^{k_i} \equiv -A_i \pmod k$

在第 $ki$ 个哈希表中查找有多少个 $A_j \times 10^{ki} \bmod k$ 的余数等于 $-A_i$，查询哈希表的时间复杂度为 $O(1)$。
#### 本题步骤
1. 枚举整体数组来预处理 $s$ 数组。

2. 再依次枚举这个数组中的每个数 $A_i$。然后在上述预处理之后的数组中找出一个或多个数字，这一个或多个数字 $A_j$ 满足 $A_j$ $\times$ $10^ {k_i}$ == $-A_i$ $\bmod$ $k$。

3. 其中每次算结果的时候需要判重。因为之前在计算预处理数组时候一定会枚举到自身，并将自身 $\times$ $10$ 的 $j$ 次方 $\bmod$ $k$ 存入到 $s$ 数组中。因此在这次计算结果的时候一定就要判断有无自己，有则结果减 $1$。

#### 一些细节

利用 `res += s[len][(k - t) % k]` 得到数学中的余数，例如在 C++  中 $-5$ $\bmod$ $3$ $=$ $-2$，而在数学中答案应该是 $1$

如果我们想得到余数 $1$，可以用 `(k - t) % k`，实现 $(3$ $-$ $(5$ $\bmod$ $3))$ $\bmod$ $3$ $=$ $1$

```cpp
#include <iostream>
#include <cstring>
#include <algorithm> 

using namespace std;

typedef long long LL;
const int N = 100010;

int n, m;
//用a数组存储每个数 k只有10^5 开一个数组当作哈希表即可
int a[N], s[11][N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    //枚举每个数 预处理哈希表
    for (int i = 0; i < n; i ++ )
    {
        LL t = a[i] % m;
        //枚举当前数在每种指数下%k的余数是多少
        for (int j = 0; j < 11; j ++ )
        {
            //第j个哈希表的余数是t
            s[j][t] ++ ;
            //幂次*10
            t = t * 10 % m;
        }
    }

    LL res = 0;
    for (int i = 0; i < n; i ++ )
    {
        LL t = a[i] % m;
        //求出ai的位数
        int len = to_string(a[i]).size();
        //位数为len 在第len个哈希表中查找有多少个 Aj 满足 Aj × 10^ki % k 的余数等于 -Ai
        res += s[len][(m - t) % m];
		//余数为(m - t) % m
        LL r = t;
        //判断Ai本身是否也在统计的范围内-> 计算 Ai × 10^ki % k 是否等于 Ai
        while (len -- ) r = r * 10 % m;
        //满足说明计算重复需要-1
        if (r == (m - t) % m) res -- ;
    }

    printf("%lld\n", res);

    return 0;
}
```


---

## 作者：QCurium (赞：4)

[原题链接](https://www.luogu.com.cn/problem/P8712)

[视频讲解（顺便点个赞吧](https://www.bilibili.com/video/BV1ej41187bz/?vd_source=a8f2ca9bd086cb49d933fb93cb7409c0)

## 题意

给你 $n$ 个数，让你计算把任意两个数拼在一起是 $k$ 的倍数的方案数。

## 题目分析

我们将这两个数命名为 $a$ 和 $b$，将两数拼在一起的实质就是 $a \times 10^{lenb}+b$，或者 $b \times 10^{lena}+a$，我们称这个数为 $c$。

我们发现，$c$ 是 $k$ 的倍数其实就是 $a \times 10^{lenb}$ 除 $k$ 的余数加上 $b$ 除 $k$ 的余数的和等于 $0$ 或者 $k$。

那么，我们就可以与处理一下，将处理完的数据存在 `fl[i][j]` 里，其中存储的是有多少个数乘了 $10^i$ 后模 $k$ 等于 $j$。

现在，这道题就好做多了。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n,k,mx=-1,ans=0;
int a[N],fl[11][N];//第一维表示乘了10的几次方，第二位表示余数。 
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		mx=max(mx,a[i]);
	}
	int cnt=0;
	for(;mx>0;){
		cnt++;
		mx/=10;
	}
	for(int i=1;i<=n;i++){
		int asd=10;
		for(int j=1;j<=cnt;j++){
			fl[j][(a[i]*asd)%k]++;
			asd*=10;
		}
	}
	for(int i=1;i<=n;i++){
		cnt=0;
		int aa=a[i];
		for(;aa>0;){
			cnt++;
			aa/=10;
		}
		int b=a[i]%k,c=(k-b)%k;
		ans+=fl[cnt][c];
		int asd=1;
		for(int j=1;j<=cnt;j++)
			asd*=10;
		if((a[i]*asd)%k==c)
			ans--;
	}
	cout<<ans;
	return 0;
}

```

[AC 记录](https://www.luogu.com.cn/record/125981115)

---

## 作者：wuhan1234 (赞：2)

## 1. 编程思路。

设 $cnt_{i,j}$ 表示在前面访问过的数的后面补 $i$ 个 $0$ 对 $K$ 取余后，余数为 $j$ 的数的个数。

对于数组中的某个整数 $A_i$，设其位数为 $len$，其对 $K$ 取余后相对于 $K$ 的补数为 $t$，$t=(K-A_i \bmod K)\bmod k$，若它接在前面某个数 $A_j$ 的后面，若 $A_j \times 10 ^{len}$ 对 $K$ 取余的余数为 $t$，则 $A_i$ 接在 $A_j$ 后面形成的新数一定是 $K$ 的倍数，累加 $cnt_{len,t}$ 的值即可。

之后，分别统计 $A_i$ 后面添加 $1$ 至 $9$ 个 $0$ 后所得到的数对 $K$ 取余后余数的出现情况，并累计到 $cnt_{i,j}$ 中。

用循环从前往后走一遍，表示 $A_i$ 是接在 $A_1 \sim A_{i-1}$ 之后，累加方案数；再用循环从后往前走一遍，表示 $A_i$ 是接在 $A_{i+1} \sim A_n$ 之后，同样累加方案数。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int cnt[10][100005]={0};
int length(int n)     // 求整数n的位数
{
    int res = 0;
    do {
       res ++;
       n /= 10;
    }while (n);
    return res;
}
int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    int i,j;
    int a[100005];
    for (i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    int len,t,p;
    long long ans = 0;
    for (i = 1; i <= n; i++)
    {
        len = length(a[i]);
        t = (k - a[i] % k) % k;
        ans += cnt[len][t];
        p = 10;
        for (j = 1; j <= 9; j++)
        {
            cnt[j][1LL * p * a[i] % k]++;
            p = 10 * p;
        }
    }
    memset(cnt, 0, sizeof(cnt));
    for (i = n; i >= 1; i--)
    {
        len = length(a[i]);
        t = (k - a[i] % k) % k;
        ans += cnt[len][t];
        p = 10;
        for (j = 1; j <= 9; j++)
        {
            cnt[j][1LL * p * a[i] % k]++;
            p = 10 * p;
        }
    }
    printf("%lld\n", ans);
    return 0;
}

```


---

## 作者：Ericzc (赞：1)

这道题我第一眼以为是 **~~高难度~~** 数论，**~~给我吓傻了~~**，结果再扫了眼题目，发现就是一道见见丹丹的水题 **QWQ**。
### 题目分析
首先，这道题是要求我们去在序列中，找到一个形如 {$x$ , $y$} 的数对，且 $$(x+y) \bmod k$$ 为 $0$ 。

然后我们会发现构成一个模 $k$ 为 $0$ 的数，只关系着选的这两个数模 $k$ 的值，如果这两个数的模数之和为 $k$ ，那么答案 $+1$。这里要注意一个地方，因为他是拼数，所以不能用普通的加减，而是要：$${10}^{\lvert{b}\rvert}x + b$$，$$\lvert{b}\rvert$$ 为 $$b$$ 的位数。

接下来我们就来想想，如何用渐进 $O(N)$ 的时间复杂度，解决配对问题。都知道如果一个个去试时间复杂度为 $$O({N}^{2})$$ 。但我们仔细想想，会发现一个一个每次只能发现一个，效率低下，那我们能不能通过预处理的方式来降低时间复杂度呢？答案是可以的，我们可以开一个功能类似于桶的二维数组，一维存取模的数，一维存这是在第几位（数位）上的，输入时我们就可以处理出 $a_i$ 的第一位到第九位时取模 $k$ 的值。输入完了再遍历 $$n$$ 个点，然后从二维数组去找模数为 $$k - a_i \bmod k$$ 第 $$\lvert{a_i}\rvert$$ 的数的个数。**特别地，上述条件有可能出现自己拼自己的情况所以我们去判断如果 $${10}^{\lvert{a_i}\rvert}a_i \equiv k - a_i\pmod k$$ 的话，答案 $-1$。**

### Code

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef unsigned long long uLL;		//十年 OI 一场空，不开 uLL 见祖宗  

const int MAXN = 1e5 + 10;
int n,k;					//数的个数，和取模的值  
uLL a[MAXN],rem[MAXN][11];		//输入的原数组和 a_i Mod k 的结果 p 在第 j 位的统计数目，相当于是一个映射数组 
uLL ans;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);					//输入量大开个玄学优化，虽然不开也能过 
	cin >> n >> k;
	
	for(int i = 1;i <= n;i ++)
	{
		cin >> a[i];
		uLL sum = 1;		//统计 10 的次方 
		for(int j = 0;j <= 10;j ++)
		{
			rem[a[i] * sum % k][j] ++;			//对 a_i 在第 j 位下 Mod k 数目 +1 
			sum *= 10;
		}
	}
	
	for(int i = 1;i <= n;i ++)
	{
		int t = a[i],Size = 0;		//算出 a_i 的位数 
		while(t) t /= 10,Size ++;
		ans += rem[(k - a[i] % k) % k][Size];		//加入余数与 a_i 的和为 k 的数量，也就是当 a_i 为第一个数时，可以组合的数的数量 
		int sum = a[i] % k;
		while(Size --) sum = sum * 10 % k;
        if(sum == (k - a[i] % k) % k) ans --;		//减去重复计算是部分 
	}
	
	cout << ans; 
	return 0;
}
```

---

## 作者：Yesod (赞：1)

# 思路

从左到右存储每个数乘 $ 10 $ 的 $ 1 $ 到 $ 10 $ 次方模 $ k $ 的余数和 $ 1 $ 到 $ 10 $ ，查找后面数是否相同，相同就将答案加上个数，然后再从右到左来一次，最后输出。

# code

```
#include<bits/stdc++.h>
using namespace std;
long long n,k,l,ans;
int a[12][1000005],b[1000005];
void d()
{
	for(int i=1;i<=n;i++)
	{
		ans+=a[(int)log10(b[i])+1][(k-b[i]%k)%k];//答案加方案数
		for(int j=1,p=10;j<=10;j++)
		{
			a[j][(b[i]%k*p)%k]++;//这个次方和次方余数方案加1
			p=p*10%k;
		}
	}
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>b[i];
	d();
	reverse(b+1,b+n+1);//翻转
	memset(a,0,sizeof(a));//注意清空数组
	d();
	cout<<ans; 
	return 0;
}
```

---

## 作者：superLouis (赞：1)

## 题解：P8712 [蓝桥杯 2020 省 B1] 整数拼接
我又来切水题啦～在这里挑战 $O(n \log_{10}{\max a_i })$ 复杂度。

update：2025.01.01 将错别字“激素”改成了“计算”，感谢尽职尽责的管理员的提醒。

----------
### 1. 解题思路
直接枚举每一个 $i,j$ 显然不太合理，$O(n^2)$ 的时间复杂度直接免费上门找你。所以我们考虑一个类似动态规划的做法。（但显然不是动态规划）

在这里，我们直接储存每一个数乘上 $10^1, 10^2, \dots, 10^9$ 后模 $k$ 的方案数，按照余数查找。

扫描 $a$ 数组，每次答案加上 $a_i$ 对应位数和余数（这里的余数为了模 $k$ 余 $0$，则剩下的余数就是 $k-a_i$ 模 $k$ 的余数）。

随后再去把每一个 $a_i$ 乘 $10^1, 10^2, \dots, 10^9$ 后模 $k$ 的方案数进行更改。

----------
### 2. 时间复杂度
看起来只有扫描 $a$ 数组的 $O(n)$ 复杂度，其实每次扫描到 $a_i$ 是还需要计算 $a_i$ 的位数，就多了额外的 $O(\log_{10}{a_i})$ 时间复杂度（但是位数不会超过 $10$ 位。但是可以直接理解成常数，即 $O(n)$ 的复杂度）。

所以，总的时间复杂度为 $O(n \log_{10}{\max a_i})$，十分优秀。

----------
### 3. 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 1e5 + 10;
const int P[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};
int n, k, ans, f[20][maxn], a[maxn];
inline int digits(const int &r) { return log10(r) + 1; }
void work() {
    for (int i = 1; i <= n; i++) {
        ans += f[digits(a[i])][(k - a[i] % k) % k];
        for (int j = 1; j <= 9; j++)
            f[j][(a[i] * P[j]) % k]++;
    }
}
signed main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    work(); reverse(a + 1, a + n + 1);
    memset(f, 0, sizeof(f)); work();
    cout << ans << "\n"; 
    return 0;
}
```
[测评记录](https://www.luogu.com.cn/record/196735258)

---

## 作者：zyxjeek (赞：0)

## 1.题目描述

> 给定一个长度为 $n$ 的数组 $A_1,A_2,\cdots,A_n$。你可以从中选出两个数 $A_i$ 和 $A_j$（$i\neq j$），然后将 $A_i$ 和 $A_j$ 一前一后拼成一个新的整数。例如 `12` 和 `345` 可以拼成 `12345` 或 `34512`。注意交换 $A_i$ 和 $A_j$ 的顺序总是被视为 $2$ 种拼法，即便是 $A_i=A_j$ 时。
>
> 请你计算有多少种拼法满足拼出的整数是 $K$ 的倍数。

## 2.思路

由于 $1 \le n \le 10^5$，使用时间复杂度为 $\mathcal O(n^2)$ 的算法枚举每种拼接显然不可行。面对这个问题，我们需要一种储存数组 $A$ 中信息的方法，可以让我们在每次遍历 $A_i$ 时以较少的时间复杂度得知能与 $A_i$ 拼接的整数个数。

设数组中两个元素 $A_j$ 和 $A_i$ 的数字位数分别为 $v$ 和 $u$，因为拼接后的数是 $K$ 的倍数，所以有 $A_j \cdot 10^u + A_i \equiv 0 \pmod K$，即 $A_j \cdot 10^u \equiv -A_i \pmod K$。由于 $A_i \le 10^9$，即 $A_i$ 最多有十位，我们可以开 $10$ 个哈希表，对于第 $p$ 个哈希表，存储 $A_i \cdot 10^u \mod K$ 的每个值出现的次数。这样我们在遍历时就能用哈希表里的值进行快速相加了。

## 3.注意事项

- 由于 $K \le 10^5$，我们把两个模 $K$ 的余数相乘时会超出`int`的范围。此外拼接方法的总数在极限情况下也会超出`int`的范围。所以记得开`long long`。

- 按以上方法计算会多算到自己与自己拼接的情况。所以当 $A_i \cdot 10^u + A_i \equiv 0 \pmod K$ 时，要把答案减 $1$。

- 可以用`log10(x) + 1`快速计算 $x$ 的数字位数。

## 4.代码

  ```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+5;
int n, k, a[N];
long long pw[11]; // 10^u % k
unordered_map<int, int> mp[11];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> k;
    pw[0] = 1;
    for (int i = 1; i <= 10; i++)
        pw[i] = (pw[i-1] * 10) % k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        for (int j = 1; j <= 10; j++)
            mp[j][a[i] * pw[j] % k]++;
    }
    long long ans = 0;
    for (int i = 1; i <= n; i++) {
        int len = log10(a[i]) + 1, mod = (k - a[i] % k) % k; // mod等价于数学上的-a[i] mod k
        ans += mp[len][mod];
        if (a[i] * pw[len] % k == mod)
            ans--;
    }
    cout << ans << endl;
    return 0;
}
  ```

## 5.复杂度分析

时间复杂度：$\mathcal O(n \log_{10} \max A_i)$



---

The End

---

## 作者：K_yuxiang_rose (赞：0)

对于两个整数 $A_i$ 和 $A_j$，$A_j$ 放前面，$A_i$ 放后面，将它们拼在一起得到的数就是：

$A_j^{len(A_i)}+A_i$

其中 $len(A_i)$ 表示 $A_i$ 的位数。

通过取模的性质，我们可以推出：

$(A_j^{len(A_i)}+A_i)\bmod k$
$=A_j^{len(A_i)}\bmod k+A_i\bmod k$

因为 $A_i$ 是已知的，那么我们通过预处理 $A_j^{len(A_i)}$，再逐一枚举以 $A$ 数组里的每个数为结尾的满足条件的数字个数即可。

预处理方式如下：建立二维数组 $f$，$f_{i,j}$ 为数组 $A$ 中的数乘上 $10^i$ 再对 $k$ 取模的数为 $j$ 的个数。这样就可以按照上面推导出的式子直接计算了。

需要注意的是，拼数时我们要避免两数是同一个数的情况，遇到这种情况需要将答案减一。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005];
int f[15][100005];
int len(int x)
{
	int sum=0;
	while(x) sum++,x/=10;
	return sum;
}
signed main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	{
		int x=a[i]%k;
		for(int j=0;j<=10;j++)
		{
			f[j][x]++;
			x*=10;
			x%=k;
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		int la=len(a[i]);
		int x=a[i]%k;
		ans+=f[la][(k-x)%k];//这里对k-x取模是为了避免x=0的情况
		if((a[i]*(int)(pow(10,la)))%k==(k-x)%k) ans--;
        //判断是否有可能造成这个数拼自己的情况
	}
	cout<<ans;
	return 0;
}
```

---


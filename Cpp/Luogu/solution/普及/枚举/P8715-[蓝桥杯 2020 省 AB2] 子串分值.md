# [蓝桥杯 2020 省 AB2] 子串分值

## 题目描述

对于一个字符串 $S$, 我们定义 $S$ 的分值 $f(S)$ 为 $S$ 中恰好出现一次的字符个数。例如 $f\left({ }^{\prime \prime} \mathrm{aba}{ }^{\prime \prime}\right)=1$，$f\left({ }^{\prime \prime} \mathrm{abc}{ }^{\prime \prime}\right)=3$，$f\left({ }^{\prime \prime} \mathrm{aaa} \mathrm{a}^{\prime \prime}\right)=0$ 。

现在给定一个字符串 $S[0 . . n-1]$（长度为 $n$），请你计算对于所有 $S$ 的非空 子串 $S[i . . j](0 \leq i \leq j<n)$，$f(S[i . . j])$ 的和是多少。


## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq n \leq 10$;

对于 $40 \%$ 的评测用例, $1 \leq n \leq 100$;

对于 $50 \%$ 的评测用例, $1 \leq n \leq 1000$;

对于 $60 \%$ 的评测用例, $1 \leq n \leq 10000$;

对于所有评测用例, $1 \leq n \leq 100000$。

蓝桥杯 2020 第二轮省赛 A 组 H 题（B 组 H 题）。

## 样例 #1

### 输入

```
ababc```

### 输出

```
21```

# 题解

## 作者：BEST_CAT (赞：12)

# P8715 [蓝桥杯 2020 省 AB2] 子串分值 题解
## 思路一

这题首先想到的是暴力：
1. 枚举区间左端点。
2. 枚举区间右端点。
3. 遍历当前所枚举的区间，累加仅出现一次的字母个数。

[代码](https://www.luogu.com.cn/paste/y2wkr6f5)

时间复杂度为 $O(n^3)$，提交后就能 [TLE](https://www.luogu.com.cn/record/103044075) 了。

---
## 思路二
我们不妨稍微优化一下，这里就不细说了，直接上代码。

[代码](https://www.luogu.com.cn/paste/4e3i2pnj)

时间复杂度为 $O(n^2)$，提交后就又能 [TLE](https://www.luogu.com.cn/record/103046410) 了。

---
## 思路三（正解）
用乘法原理做。

操作步骤：
1. 统计每个字母在只出现一次的情况下，能被多少子串所包含；
2. 用 $pre_i$ 记录第 $i$ 个字母上一次出现的位置，用 $nx_i$ 记录第 $i$ 个字母下一次出现的位置；
3. 那么往左最多能延伸到 $pre_i+1$，其到第 $i$ 个字母一共有 $i-pre_i$ 个字母；
4. 同理往右最多能延伸到 $nx_i-1$，其到第 $i$ 个字母一共有 $next_i-i$ 个字母；
5. 二者相乘，就是该字母被不同子串所包含的总次数；
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100010,M=150;
string s;
ll pre[N],nx[N],idx[M];
int main(){
    cin>>s;
    ll n=s.size();
    s=' '+s;
    for(int i=1;i<=n;i++){
        pre[i]=idx[s[i]];
        idx[s[i]]=i;
    }
    for(int i=97;i<=122;i++){
        idx[i]=n+1;
    }
    for(int i=n;i>=1;i--){
        nx[i]=idx[s[i]];
        idx[s[i]]=i;
    }
    ll ans=0;
    for(int i=1;i<=n;i++){
        ans+=(i-pre[i])*(nx[i]-i);
    }
    cout<<ans;
    return 0;
}
```

时间复杂度：$O(n)$，提交之后发现：终于过了。

---

## 作者：Luckies (赞：9)

## 题目大意

给定一个由小写字母组成的字符串 $S$，定义分值 $f(S)$ 为字符串 $S$ 中的只出现过一次的字母的个数，求 $S$ 的所有非空字串的分值总和。

## 思路

### 暴力做法

我们只需枚举子串的左端点和右端点，再分别求出它们的分值。

时间复杂度为 $O(n^3)$，显然超时，这里不再细说。

### 正解

我们阅读题目后（~~当然阅读了题目，不然怎么做？~~）可以发现，我们需要求出字符串中只出现一次的字符个数，那么我们只需要求出字符串中每一个字符所做出来的贡献不就行了？

那么怎么求出每一个字符所做出来的贡献呢？

我们可以发现，每一个字符 $c$ 的贡献都仅局限于字串中只有一个 $c$ 的字串，那我们只需要求出这个字符 $c$ 上一次出现的位置和下一次出现的位置，那么在这两个位置之间的子串，不就都是 $c$ 可以做出贡献的字串了吗？

那么这道题就好做了。

我们设 $last_i$ 为字符 $i$ 上一次出现的位置，$nxt_i$ 为字符 $i$ 下一次出现的位置。如果字符 $i$ 前面没有和它相同的字符了，那么 $last_i$ 为 $0$；如果字符 $i$ 后面没有和它相同的字符了，那么 $nxt_i$ 为 $n+1$；那么字符 $i$ 所做出来的贡献就是 $(i - last_i) \times (nxt_i - i)$。

那么这道题我们就做完了！

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long//记得开long long
using namespace std;
const int N = 1e5 + 5, S = 27;
int last[N], nxt[N], a[S];
int ans;
string s;
signed main()
{
	cin >> s;
	int len = s.size();
	s = '#' + s;//使字符串下标从1开始
	for(int i = 1; i <= len; i++)//求last
	{
		last[i] = a[s[i] - 'a'];
		a[s[i] - 'a'] = i;
	}
	for(int i = 0; i < 26; i++)//初始化a
		a[i] = len + 1;
	for(int i = len; i >= 1; i--)//求nxt
	{
		nxt[i] = a[s[i] - 'a'];
		a[s[i] - 'a'] = i;
	}
	for(int i = 1; i <= len; i++)//求答案
		ans += (i - last[i]) * (nxt[i] - i);
	cout << ans;
	return 0;
}
```

---

## 作者：DreamLand_zcb (赞：7)

### 简要题意

定义字符串 $S$ 的分值为 $S$ 中恰好出现一次的字符个数。求该字符串 $S$ 的所有子串分值之和。

### 思路

首先考虑枚举字符串每一位上的字母对分值之和的贡献，拿样例举例：


对于样例第一个字符 $a$，贡献是：$\color{red}a\color{black}babc$、$\color{red}ab\color{black}abc$，一共是 $2$。


对于样例第二个字符 $b$，贡献是：$\color{red}ab\color{black}abc$、$a\color{red}b\color{black}abc$、$a\color{red}ba\color{black}bc$、$\color{red}aba\color{black}bc$，一共是 $4$。


同理求出其他字符贡献得到：


| 下标 | $1$ | $2$ | $3$ | $4$ | $5$ |
|---|---|---|---|---|---|
| 字母 | $a$ | $b$ | $a$ | $b$ | $c$ |
| 贡献 | $2$ | $4$ | $6$ | $4$ | $5$ |


可以发现，每一个字符可以做出贡献的子字符串是上一个出现该字符的位置和下一个出现该字符的位置之间的字符串。通俗点讲就是：

$ab\color{red}{ca}\color{blue}{b}\color{red}{caca}\color{black}b$


对于这个例子中的蓝 $\color{blue}b$，它可以做出贡献的是这个子字符串：$\color{red}{ca}\color{blue}{b}\color{red}{caca}$。


下一个问题，怎么求贡献？


再看这个例子，$\color{red}{ca}\color{blue}{b}\color{red}{caca}$，它做出的贡献是这个子字符串的所有包含蓝 $\color{blue}b$ 的子字符串的个数。


**当然也有特殊情况，如果这个字符没有前一个相同的字符的话，就将前一个字符出现的下标设为 $0$，同意如果没有后一个相同的字符的话，就将后一个字符出现的下标设为 $n-1$。**


通过小学就学过的乘法原理可以知道所有包含蓝 $\color{blue}b$ 的子字符串的个数等于蓝 $\color{blue}b$ 及其左侧的字符个数乘上蓝 $\color{blue}b$ 及其右侧的字符个数就是他的贡献。


最后就是找前后两个 $b$ 的下标的位置，定义两个变量 `lastpos` 和 `nextpos` 记录就行了。


### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

string s;
ll ans;
int main()
{
	ios::sync_with_stdio(false);
	cin >> s;
	int l=s.size();//比较习惯用l，没用题目中所给的n
	for(int i=0;i<l;i++)
	{
		int lastpos=-1, nextpos=-1;
		for(int j=i-1;j>=0;j--)
		{
			if(s[j] == s[i])
			{
				lastpos=j+1;
				break;
			}
		}
		if(lastpos == -1)	lastpos=0;
		for(int j=i+1;j<l;j++)
		{
			if(s[j] == s[i])
			{
				nextpos=j-1;
				break;
			}
		}
		if(nextpos == -1)	nextpos=l-1;
		//cout << s[i] << ": " << lastpos << " " << nextpos << endl;
		ans+=(i-lastpos+1)*(nextpos-i+1);//左侧个数是(i-lastpos+1)个，右侧是(nextpos-i+1)个
	}
	cout << ans;
	return 0;
}

```

---

## 作者：xhhhh36 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P8715)
# 题意
给定一个只由小写字母组成的字符串 $S$，定义 $f(A)$ 为字符串 $A$ 中只出现了一次的字母个数，求 $S$ 中所有非空子串的 $f(A)$ 值之和。
# 思路
可以用乘法原理，将每一个字符对答案的贡献都处理出来。设 $pr(i)$ 为字符 $S(i)$ 在字符串 $S$ 中上一次出现的位置，$nx(i)$ 为字符 $S(i)$ 在字符串 $S$ 中下一次出现的位置。如果字符 $i$ 在它前面没有出现过那么 $pr(i)=0$，如果字符 $i$ 在它后面没有出现过那么 $nx(i)=0$。

所以从 $pr(i)+1$ 到 $nx(i)-1$ 中间字符 $i$ 只出现了一次，那么字符 $i$ 的对答案的贡献为 $(i-pr(i))\times(nx(i)-i)$。然后按照推出的公式递推即可。
# AC code
```cpp
#include <bits/stdc++.h>

using namespace std;
string s;
int a[27];
int pr[100005],nx[100005];
signed main()
{
	cin>>s;
	memset(a,-1,sizeof(a));
	for (int i=0;i<s.length();i++) nx[i]=s.length();
	for (int i=0;i<s.length();i++) pr[i]=-1;
	for (int i=0;i<s.length();i++)
	{
		if (a[s[i]-'a']==-1)
		{
			pr[i]=-1;
			a[s[i]-'a']=i;
			continue;
		}
		pr[i]=a[s[i]-'a'];
		nx[a[s[i]-'a']]=i;
		a[s[i]-'a']=i;
	}
	long long ans=0;
	for (int i=0;i<s.length();i++)
	{
		ans+=(i-pr[i])*(nx[i]-i);
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：liaoxingrui (赞：3)

## Content

给你一个字符串 $S$，长度为 $n$，让你取一个长度为 $l - r ( 0 \le l \le r < n )$ 的字符串，里面有几个恰好出现一次的字符就为这个 $l - r$ 这个区间的分值，最后将这些区间的分值加起来便是答案。

## Solution

因为这道题的数据范围为：$1 \le n \le 10^5$

所以暴力是肯定不行的，要用其他方法。

因为每个字母一旦出现两次，那它这个字母是不会为它所在区间增加分值的。

所以我们可以统计它前面有几个不与自己相同（如果遇到与自己相同的字符则再往前面的不同字符就不在计数）的字符（包括它自己，设有 $x$ 个）和后面有几个不与自己相同（如果遇到与自己相同的字符则再往后面的不同字符就不在计数）字符（不包括它自己，设有 $y$ 个），将它们互相匹配，则这个字符可以为它所在的所有区间增加共 $x \times y$ 的分值。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string S;
int len,ans;
int nextcx[30],nextl[100005],nextr[100005];
//S 是字符串 。
//len 是字符串 S 的长度 ，ans 为答案 。
//nextcx 是最近一次出现与它自己相同的字符所在位置 。
//nextl 是字符与它自己相同的前一个字符出现在哪 ， nextr 是字符与它自己相同的后一个字符出现在哪 。 
//若字符就为最前一个 ， 则它的前一个与它相同的字符所在位置视为 0。
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>S;
	len=S.size();
	for(int i=0;i<len;i++){
	//统计前面一个与自己相同的字符出现在哪 。 
		nextl[i]=nextcx[int(S[i]-96)];
		nextcx[int(S[i]-96)]=i;
	}
	for(int i=1;i<=26;i++)
	//若字符就为最后一个 ， 则它的后一个与它相同的字符所在位置视为字符串 S 的长度 。 
		nextcx[i]=len;
	for(int i=len-1;i>=0;i--){
	//统计后面一个与自己相同的字符出现在哪 。 
		nextr[i]=nextcx[int(S[i]-96)];
		nextcx[int(S[i]-96)]=i;
	}
	for(int i=0;i<len;i++)
	//这里要特判一下 S[i] 的上一次出现在 0 的位置的情况 ， 特别的要判断一下 i==0 的情况 。 
	//前面有 (i-nextl[i]+(!nextl[i]&&(S[0]!=S[i]||i==0))) 个字符 （ 包括字符自己 ） 。 
	//后面有 (nextr[i]-i) 个字符 （ 不包括字符自己 ） 。 
		ans+=(i-nextl[i]+(!nextl[i]&&(S[0]!=S[i]||i==0)))*(nextr[i]-i);
	cout<<ans;
	return 0;
}
```

---

## 作者：lqsy002 (赞：0)

## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P8715)。

## 解题思路

一道思维题。

考虑每个字符对最终答案的贡献。

设每个字符左侧连续与之不相同字符个数为 $pre$，右侧与之不相同字符个数为 $nxt$，二者均不包括自己。

则每个字符的贡献为 $(pre+1)\times(nxt+1)$。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int l,pre[maxn],nxt[maxn],siz[30],ans;
string s;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>s;
    l=s.size();
    memset(siz,-1,sizeof(siz));
    for(int i=0;i<l;++i){
        pre[i]=i-siz[s[i]-'a'];
        siz[s[i]-'a']=i;
    }
    for(int i=0;i<30;++i) 
        siz[i]=l;
    for(int i=l-1;i>=0;--i){
        nxt[i]=siz[s[i]-'a']-i;
        siz[s[i]-'a']=i;
    }
    for(int i=0;i<l;++i) 
        ans+=pre[i]*nxt[i];
    cout<<ans;      
    return 0;
}
```

---

## 作者：Silence_World (赞：0)

# 思路

题意很简单，不过多赘述，暴力做法就 $O(n^3)$ 扫一遍，考虑优化。

我们思考一个字符对于答案的贡献，对于一个字符，只要他在一个子串里面，那后面的
所有包含他的串如果有和他一样的字符，那么这个子串则对答案没有贡献，然后暴力扫，复杂度 $O(n^2)$，很明显还是过不了。

我们再仔细思考一下这个问题，由二做法得任意一个字符在一个串里的贡献肯定是只有  1 或 0 的，我们考虑其贡献为一的子串有多少个，就是有且没有与它重复字符的所有子串，把每个子串的结果统计出来就行了，那这个子串怎么求捏，用一个人尽皆知的东西：乘法原理，我们统计一个字符上一个出现的位置和下一个出现的位置，这两个之间就是只包含一个他的子串所有可能在的区间，那这个问题就变成了：在一个区间内，包含第 $i$ 个字符的子串共有多少个，这时就可以乘法原理了，举个例子，$i=3$，字符为 $12345$。

我们先看由 1 开头包含 3 的子串，很明显 3 个,欸，这个时候，我们已经发现一个问题，在 $i$ 前的所有字符，每个都能和 $i$ 及其以后的每个字符构成完全包含 $i$ 的子串，也就是对于 $i$ 及其前的每个字符，每个能构成 $n-i+1$ 个子串，乘法原理易求，时间复杂度 $O(n)$，可过。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int last[1000005];
int last1[1000005];
int next1[1000005];
int next2[1000005];
signed main(){
	string s;
	cin>>s;
	for(char i='a';i<='z';i++){
		last1[i]=-1;
		next1[i]=s.length();
	}
	for(int i=0;i<s.length();i++){
		last[i]=last1[s[i]];
		last1[s[i]]=i;
	}
	for(int i=s.length()-1;i>=0;i--){
		next2[i]=next1[s[i]];
		next1[s[i]]=i;
	}
	int sum=0;
	for(int i=0;i<s.length();i++){
		sum+=(i-last[i])*(next2[i]-i);
	}
	cout<<sum;
	return 0;
}
```


---

## 作者：_Emperorpenguin_ (赞：0)

## 思路

正序遍历每个字符，用 $last_i$ 记录这个字符上一次出现的位置。

倒序遍历每个字符，用 $next_i$ 记录这个字符下一次出现的位置。

最后，对于第 $i$ 每个字符，根据乘法原理，$(i-last_i)\times (next_i-i)$ 就是恰好包含一个这种字符的子串的总数。

将总数累加就是最后的答案。

## $Code$

```cpp
#include<bits/stdc++.h>
#pragma G++ optimize(2)
using namespace std;

string s;
int last[100005],nxt[100005]; 
int t[30];
int ans;

signed main(){
//	freopen("test.in","nxt",stdin);
//	freopen("test.out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin>>s;
	int n=s.length();
	s=" "+s;
	for(int i=1;i<=n;i++){
		last[i]=t[s[i]-'a'];
		t[s[i]-'a']=i;
	}
	for(int i=0;i<26;i++)
		t[i]=n+1;
	for(int i=n;i>=1;i--){
		nxt[i]=t[s[i]-'a'];
		t[s[i]-'a']=i;
	}
	for(int i=1;i<=n;i++)
		ans+=(i-last[i])*(nxt[i]-i);
	cout<<ans;
	return 0;
}
```

---


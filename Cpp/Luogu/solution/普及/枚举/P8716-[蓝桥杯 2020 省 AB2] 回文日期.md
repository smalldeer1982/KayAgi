# [蓝桥杯 2020 省 AB2] 回文日期

## 题目描述

2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按 `yyyymmdd` 的格式写成一个 $8$ 位数是 `20200202`，恰好是一个回文数。我们称这样的日期是回文日期。

有人表示 `20200202` 是“千年一遇” 的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：`20211202` 即 2021 年 12 月 2 日。

也有人表示 `20200202` 并不仅仅是一个回文日期，还是一个 `ABABBABA` 型的回文日期。对此小明也不认同，因为大约 $100$ 年后就能遇到下一个 `ABABBABA` 型的回文日期：`21211212` 即 2121 年12 月12 日。算不上“千年一遇”，顶多算“千年两遇”。

给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 `ABABBABA` 型的回文日期各是哪一天。


## 说明/提示

对于所有评测用例，$10000101 \le N \le 92200229$，保证 $N$ 是一个合法日期的 $8$ 位数表示。

蓝桥杯 2020 第二轮省赛 A 组 G 题（B 组 G 题）。

## 样例 #1

### 输入

```
20200202```

### 输出

```
20211202
21211212
```

# 题解

## 作者：Zaku (赞：16)

[题目](https://www.luogu.com.cn/problem/P8716)

### 解法
首先，这题是模拟题中的日期问题。~~显而易见~~

对于此题，我们可以进行如下分析：

- 遍历从 $N$ 开始的所有回文日期。
- 判断日期是否合法。
- 找到第一个合法回文日期后输出。
- 判断该回文数是否为 ```ABABBABA``` 型。
- 找到第一个 ```ABABBABA``` 型回文日期后输出。
- 结束。

其中，对于判断日期是否合法，我们可以进行如下分析：
- 抽取年、月、日。
- 判断月份是否合法。
- 根据月份判断日期是否合法。

对于判断回文日期，可以采用双指针算法，~~比较高级~~代码更为简洁。

对于判断特殊情况，直接在代码中给予说明。

```cpp
#include<bits/stdc++.h>
using namespace std;
int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};//打个月份表
//判断合法 
bool check_valid(int date){
    int year=date/10000;
    int month=date%10000/100;
    int day=date%100;//分离年月日 
    if(day==0||month<=0||month>12)return false;//显然的不合法情况 
    if(month!=2&&day>months[month])return false;//月份不是2，day不合法就不合法 
    if(month==2){//月份是2 
        if((year%4==0&&year%100!=0)||(year%400==0))if(day>29)return false;//是闰月， day必须<=29 
        else if(day>28)return false;//是平月，day必须<=28 
    }
    return true;
}
//判断回文 
bool check_huiwen(string s){
	int len=s.size();
    for(int i=0,j=len-1;i<j;i++,j--)//i从前往后，j从后往前扫一遍 
        if(s[i]!=s[j])return false;//不对称，就不回文 
    return true;
}
//判断ABABBABA 
bool check_ABAB(string s){
	if(check_huiwen(s)){//首先它得是个回文数 
		//接下来只需判断前4位是否合法 
		if(s[0]!=s[2]||s[1]!=s[3]||s[0]==s[1])return false;
		//结合ABABBABA思考 
		return true;
	}
	return false;
}
int main(){
    int n;cin>>n;
    bool flag=0;
    for(int i=n+1;;i++){//枚举回文数 
        if(check_valid(i)){//合法 
            string s=to_string(i);//仅在C++11标准及以后出现，比较好用 
            if(check_huiwen(s)&&!flag){//输出第一个回文数 
                cout<<i<<endl;
                flag=1;
            }
            if(check_ABAB(s)){//输出第一个特殊回文数 
                cout<<i;
                return 0;
            }
        }
    }
    return 0;
}
```

---

## 作者：wuhan1234 (赞：3)

## 1.编程思路。
在一个日期中，月份只能取 1~12，每月的日数也是确定的。因此可以用二重循环对一个日期中的月（用变量 $m$ 表示)和日（用变量 $d$ 表示)的组合情况进行枚举，一共有 366 种组合情况。

对于月 $m$ 和日 $d$ 的每种组合情况，$m\times 100+d$ 组成了一个日期的后 4 位，$m\times 100+d$ 这个数的逆序数就构成了一个日期的年份（用变量 $y$ 表示)。若 $y$ 是一个4位数，则 $10000\times y+100\times m+d$ 就是一个合法的回文日期。

由此可知，合法的回文日期最多不超过 366 个。可以用一维数组 $table1[366]$ 来保存，用变量 $cnt1$ 保存回文日期的个数。

同样可以用一维数组 $table2[15]$ 来保存 ABABBABA 型的回文日期，用变量 $cnt2$ 保存这种类型回文日期的个数。由于一个日期中月份只有 12 个月，因此这种类型的回文日期最多有 12 个。

通过二重循环枚举求得了回文日期后，将数组 $table1$ 和 $table2$ 中保存的日期均按从小到大的顺序排列。这样对于输入的日期 $N$，用简单的顺序查找法在两个数组中分别找到第 1 个大于指定日期 $N$ 的整数就是所求的答案。

另外，这种采用二重循环对月和日的组合情况进行枚举求回文日期的方法。不用特别考虑闰年的情况。因为对于闰年而言，有 2 月 29 日，其逆序的年份为 9220，正好是一个闰年，92200229 也是一个合法的回文日期。
## 2.源程序。
```c
#include <stdio.h>
void sort(int a[],int n)
{
    int i,j,t;
    for (i=0;i<n-1;i++)
        for (j=0;j<n-1-i;j++)
           if (a[j]>a[j+1])
           {
              t=a[j];  a[j]=a[j+1];  a[j+1]=t;
           }
}
int main()
{
    int month[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};
    int table1[366],table2[15];
    int cnt1=0,cnt2=0;
    int y,m,d,num;
    for (m=1;m<=12;m++)
    {
        for (d=1;d<=month[m];d++)
        {
            num=100*m+d;
            y=(num/1000)+(num%1000/100)*10+(num%100/10)*100+(num%10)*1000;
            if (y<1000) continue;  // 年份不足4位，舍弃
            table1[cnt1++]=y*10000+m*100+d;   // 将求得的回文日期保存
            if (m/10==d/10 && m%10==d%10)     // 是否为ABABBABA 型的回文日期
               table2[cnt2++]=y*10000+m*100+d;
        }
    }
    sort(table1,cnt1);   // 将求得的回文日期按从小到大排列
    sort(table2,cnt2);   // 将求得的ABABBABA 型回文日期按从小到大排列
    int n;
    scanf("%d",&n);
    int i;
    for (i=0;i<cnt1;i++)
        if (table1[i]>n) break;
    printf("%d\n",table1[i]);
    for (i=0;i<cnt2;i++)
        if (table2[i]>n) break;
    printf("%d\n",table2[i]);
    return 0;
}

```


---

## 作者：_xEr_ (赞：2)

### 这题一眼看上去，有两种解法

1. 枚举合法日期，判断是否为回文数以及属于哪种回文数。
2. 枚举合法回文数，判断是否为合法日期以及属于哪种回文数。

我们先估算一下时间复杂度：

第一种方案，需要枚举年月日+判断回文数，时间复杂度为  $O(n^3)$。  
注：其实真正的复杂度大约是 $(12 \times 31) n$。

第二种方案，枚举回文数可以枚举一半，另一半转换一下便出来了，只需要判断是否为合法日期。时间复杂度 $O(n)$。

比较一下两种方法的时间复杂度，不难发现第二种方法更快一点，所以我的思路即是第二种思路。

在这一题中，我用变量 $a$ 枚举每一个年份，构造出相对应的年月日（ $y,m,d$ ），判断合法日期不多赘述。通过数字转字符串判断是哪种回文日期，下面给出代码。
________
```cpp
#include<iostream>
using namespace std;
int month[]={
	0,31,28,31,30,31,30,31,31,30,31,30,31
};
string n;
int yr,yr2;
bool run(int n){//判断闰年
	if(n%100==0){
		if(n%400==0)return 1;
	}else if(n%4==0)return 1;
	return 0;
}
int main(){
	cin>>n;
	int a=atoi(n.substr(0,4).c_str());//把前四位字符转为数字
	a++;
	while(1){
		int y=a,m=(((a%10)*10)+a%100/10),d=(((a%1000)/100*10)+(a/1000));//推出年月日
		string A=to_string(a);
		if(m==2){//特判二月
			if(d<=(28+run(y))){//判断日期是否合法
				if(yr==0)printf("%d%.02d%.02d\n",y,m,d),yr=1;//标记已出现并输出，%.02d 自动在不足2位的数前填充 0 以达到二位
				if(yr2==0&&A[0]==A[2]&&A[1]==A[3]&&A[0]!=A[1])printf("%d%.02d%.02d\n",y,m,d),yr2=1; //判断是否属于特殊回文日期，标记已出现并输出
			}
		}else if(m<=12&&m>0){//普通月份，其余同上
			if(d<=month[m]){
				if(yr==0)printf("%d%.02d%.02d\n",y,m,d),yr=1;
				if(yr2==0&&A[0]==A[2]&&A[1]==A[3]&&A[0]!=A[1])printf("%d%.02d%.02d\n",y,m,d),yr2=1;
			}
		}
		a++;//年份++
		if(a>9999||yr&&yr2)return 0;//输出完了就结束程序
	}
}
```



---

## 作者：QWQ_SenLin (赞：1)

### 前言
题意这里就不细说了，直接开始分析。

### 分析

看完题目的第一思路是直接从当前日期开始枚举，直到枚举出答案。但是看到数据范围：

> $10000101 \le N \le92200229$

最大大约 $9 \times 10^7$，枚举可能会超时，所以我换了一种思路：枚举每一位，取符合要求的日期的最小值。

接下来，我来细讲下这种思路。

#### 找下一个回文日期

如果直接暴力枚举每一位，时间大约是 $\mathcal O(10^{8})$ 的，有点大。。

但我们可以发现，回文日期是左右对称的，即第 $i$ 位的数字 $=$ 第 $8 - i + 1$ 位的数字，因此我们可以通过枚举的日期的前四位来求出完整日期，这样时间复杂度就下降到了 $\mathcal O(10^{4})$ 了。

如何枚举呢，这里就给个小建议，当遇到需要 $\text{for}$ 循环很多层时，可以选择用 $\text{dfs}$ 代替，代码可能会简洁很多。

还有枚举日期时一定不要从 $N_i$（$N$ 的第 $i$ 位）开始枚举，必须从 $0$ 开始，因为有可能从 $N_i$ 开始枚举的答案比正确答案大。

```cpp
void dfs_huiwen(int x){ //x 表示当前枚举到第 x 位，要从 1 开始枚举。
    if(x > 4){ //枚举 4 位了，可以求出完整的回文日期了。
        for(int i = 5;i <= 8;i++)
            ans[i] = ans[8 - i + 1]; //倒着复制一遍
        update(ans); //这个是更新答案用的函数
        return ;
    }
    for(int i = 0;i <= 9;i++){
        ans[x] = i;
        dfs_huiwen(x + 1);
    }
}
```

#### 找下一个 ABABBABA 型的回文日期

思路和上面「找下一个回文日期」差不太多，我们同样可以发现，对于所有的 `ABABBABA` 型的回文日期（以下缩写为 $\texttt{AB}$ 型日期），均只有两个数字 $A$ 和 $B$ 组成。所以我们可以枚举 $A$ 和 $B$ 来组合出完整的 $\texttt{AB}$ 型日期。

这种方法构造出来的 $\texttt{AB}$ 型日期是不用判断是否为回文日期的，因为 `ABABBABA` 本身就是对称的了。

时间复杂度是个常数，应该是 $\mathcal O(10^{2})$。

```cpp
void dfs_ABAB(int x){
    if(x > 2){ //枚举完 2 位了，直接构造
        int A = ans[1] , B = ans[2];
        int tmp[15] = {0 , A , B , A , B , B , A , B , A};
        //tmp 数组为构造完后的数组。
        for(int i = 3;i <= 8;i++)
            ans[i] = tmp[i];
        update(ans);
        return ;
    }
    for(int i = 0;i <= 9;i++){
        ans[x] = i;
        dfs_ABAB(x + 1);
    }
}
```

#### 判断合法/更新答案

搜完了不要忘了检测答案是否合法啊。对于所有合法的日期，要满足：

- $1 \le$ 月 $\le 12$。
- $1 \le$ 日 $\le$ 对应月份的天数。
- $1000 \le$ 年 $\le 9220$。

当此日期为闰年时，二月天数是 $29$ 天，否则为 $28$ 天。判断是否是闰年就不说了，不知道可以看看[这个](https://baike.baidu.com/item/%E9%97%B0%E5%B9%B4/27098)。

检测答案是否符合要求是多余的，因为构造出来的答案一定符合要求。

```cpp
inline bool judge(int day[15]){ //判断日期 day 是否合法
    int year = day[1] * 1000 + day[2] * 100 + day[3] * 10 + day[4];
    int month = day[5] * 10 + day[6];
    int dday = day[7] * 10 + day[8];
    if(year < 1000 || year > 9220)
        return false;
    if(year % 100 == 0 && year % 400 != 0)
        months[2] = 29; //世纪闰年
    else if(year % 100 != 0 && year % 4 == 0)
        months[2] = 29; //普通闰年
    else
        months[2] = 28; //不是闰年
    if(month <= 0 || month > 12)
        return false;
    if(dday > months[month] || day <= 0)
        return false;
    return true;
}

void update(int a[15]){ //更新答案
    int aa = 0;
    for(int i = 1;i <= 8;i++)
        aa = aa * 10 + a[i];
    if(aa <= N || !judge(a) || aa > 92200229)
        return ; //不合法就不更新答案
    output = min(output , aa);
}
```

### 结尾
写完后发现好像我的第一思路（直接从原数开始枚举）也能过，只能说我想太复杂了。。

---

## 作者：liupei (赞：0)

## 思路
一、普通回文日期的特点，即正着看和倒着看一样，即 ABCDDCBA 型，又因为每年只有一个年份，所以说每年只有一个回文日期。

二、ABABBABA 型的回文日期的特点，既具备普通回文日期的特点，又有自己的特点，即日期只有两种数字且交替成为年份。

三、根据两种回文日期的特点可知，只要遍历每年的年份，把年份倒着写，两者连接组成回文日期，再判断是否合法即可

四、合法性判断，只要满足 $0 < month \le 12$,每个月的天数在该月的最大天数之内即可

注意：

1、需要判断输入的这一年是否有回文日期。

2、闰年平年在二月时的天数不一样。（能被 $4$ 整除却不能被 $100$ 整除或能被 $400$ 整除的年份就是闰年）

3、输入的日期是 $89991231$ 之前，但是输出的日期可以是 $89991231$ 之后的。
定义函数是较优选择！

## 代码
```python
ymd=input()
year=int(ymd[:4]) #年
daymonth=int(ymd[8:3:-1])  #月日取反
 
#用于判断日期是否合法,合法返回1，不合法返回0
def  TF(ymd): 
    month1=[0,31,28,31,30,31,30,31,31,30,31,30,31]  #平年各月天数
    month2=[0,31,29,31,30,31,30,31,31,30,31,30,31]  #闰年各月天数
    ymd=str(ymd)   #将日期转化成字符串类型，方便分割
    year=int(ymd[:4])   #年
    month=int(ymd[4:6])   #月
    day=int(ymd[6:8])     #日
    
    #判断是否为闰年,不是闰年用month1,闰年用month2
    #能被4整除却不能被100整除或能被400整除的年份就是闰年
    if (month>=1)and(month<=12):
        if ((year%4==0)and (year%100!=0))or(year%400==0):
            if day>month2[month]:
                return 0
            else:
                return 1
        else:
            if day>month1[month]:
                return 0
            else:
                return 1        
    else:
        return 0
#两种回文型日期的个数       
ABCDDCBA=0     
ABABBABA=0
 
if year==daymonth:   #本身回文,说明这一年不会有回文日期，则年数加一
    year=year+1
elif int(ymd[3::-1])>int(ymd[3:8]):       #本年可能存在回文日期，且在输入的日期之后
    YMD=ymd[:4]+ymd[3::-1]  #为方便连接，直接使用字符串拼接
    
    #判断是否合法
    if TF(YMD)==1:
        if (YMD[0]!=YMD[1])and(YMD[0]==YMD[2])and(YMD[1]==YMD[3]):     #是否为ABABBABA型
            ABABBABA=int(YMD)
        else:
            ABCDDCBA=int(YMD)
else:      #回文日期不在今年
    year=year+1
 
while (ABABBABA==0)or(ABCDDCBA==0):
    Y=str(year)
    YMD=Y[:]+Y[::-1]
    if TF(YMD)==1:  #合法性判断
        if (YMD[0]!=YMD[1])and(YMD[0]==YMD[2])and(YMD[1]==YMD[3])and(ABABBABA==0):   #是否为ABABBABA型
            ABABBABA=int(YMD)
        elif ABCDDCBA==0:
            ABCDDCBA=int(YMD)
    year=year+1
    
#打印结果       
print(ABCDDCBA)
print(ABABBABA)
```

---

## 作者：lmy_2011 (赞：0)

本题需要运用到模拟，十分简单，但很考验代码能力。

#### 思路
1. 从 $n+1$ 开始枚举 $8$ 位数。
2. 对于枚举到的整数 $i$，既需要是一个回文数，又需要是合法日期。
3. 设计一个函数检查一个 $8$ 位数是否是 $\tt ababbaba$ 型，换句话说，就是这个数在回文的前提下，第 $1$、$2$ 位上数字和 $3$、$4$ 位上的数字相同，且第 $1$ 个和第 $2$ 个数字不同，因为他是个 $\tt abab$ 型，$\tt a$ 与 $\tt b$ 是不能相同的。

#### 代码设计
本代码要设计 $3$ 个函数，分别检查他是否回文、他是否为 $\tt ababbaba$ 型的回文数、它是否为合法日期。

对于每个函数，代码上有详细思路，请大家观看：
```cpp
#include<iostream>
using namespace std;
int a[]={0,31,29,31,30,31,30,31,31,30,31,30,31};//之所以将二月定为29，是因为以29结尾的回文合法日期只有“92200229”。
bool hui(int x)//这里采用的方法是将数倒过来，看是否相等。
{
	int y=0,tmp=x;
	while(tmp!=0)
	{
		y=y*10+tmp%10;//将x的末尾提取出来，再加上。（注意要乘10）
		tmp/=10;//将当前的末尾删掉。
	}
	return x==y;//如果过相同就返回“真”，不相同返回“假”。
}
bool checkab(int x)
{
	int n1=x/1000000,n2=x/10000%100;//一个提取1、2位，一个提取3、4位。
	if(n1==n2/*1、2位与3、4位相等，这样才能是abab型*/&&n1%10!=n1/10/*提取1、2位。因为是abab，所以a与b不能相等*/)
	{
		return true;
	}
	return false;
}
bool isdate(int x)
{
	int month=x/100%100;//月份。
	int day=x%100;//日期。
	if(month>=1/*不能有0月*/&&month<=12/*不能有13月*/&&day>=1/*不能有0日*/&&day<=a[month]/*不能超过这个月份的日期*/)
	{
		return true;
	}
	return false;
}
int main()
{
	int n,cnt=0;//统计输出的次数，只能输出两次，一次为回文日期，一次为ababbaba的回文日期。
	cin>>n;
	for(int i=n+1;;i++)//从n+1开始，一直往上加。
	{
		if(isdate(i)==false)//不是一个合法日期（例如：22月56日）就跳过。
		{
			continue;
		}
		if(cnt==0&&hui(i)==true)//找到第一问，他是一个回文数。由于第一问的条件比第二问少，所以无论如何第一问会比第二问先找到。（或同时）
		{
			cnt++;
			cout<<i<<endl;
		}
		if(cnt==1&&hui(i)==true&&checkab(i)==true)//是一个ababbaba型的回文数。
		{
			cout<<i<<endl;
			return 0;//注意要直接结束。
		}
	}
	return 0;
}

```


---


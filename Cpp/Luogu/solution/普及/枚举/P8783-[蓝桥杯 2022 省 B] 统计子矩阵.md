# [蓝桥杯 2022 省 B] 统计子矩阵

## 题目描述

给定一个 $N \times M$ 的矩阵 $A$，请你统计有多少个子矩阵 (最小 $1 \times 1$, 最大 $N \times M)$ 满足子矩阵中所有数的和不超过给定的整数 $K$。


## 说明/提示

**【样例说明】**

满足条件的子矩阵一共有 $19$，包含:

大小为 $1 \times 1$ 的有 $10$ 个。

大小为 $1 \times 2$ 的有 $3$ 个。 大小为 $1 \times 3$ 的有 $2$ 个。

大小为 $1 \times 4$ 的有 $1$ 个。

大小为 $2 \times 1$ 的有 $3$ 个。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据, $N, M \leq 20$.

对于 $70 \%$ 的数据, $N, M \leq 100$.

对于 $100 \%$ 的数据, $1 \leq N, M \leq 500,0 \leq A_{i j} \leq 1000,1 \leq K \leq 2.5\times10^8$. 

蓝桥杯 2022 省赛 B 组 F 题。

## 样例 #1

### 输入

```
3 4 10
1 2 3 4
5 6 7 8
9 10 11 12```

### 输出

```
19```

# 题解

## 作者：sgl654321 (赞：64)

### 题目大意
给定一个 $n\times m$ 的矩阵，求其中有多少个子矩阵的所有元素之和小于等于 $k$。

### 解题思路

- $30$ 分做法：

要想确定一个矩阵，只需要确定其左上角的点 $(x1,y1)$ 和右下角 $(x2,y2)$ 的点即可。注意 $x1\le x2,y1\le y2$。

枚举左上角的点和右下角的点，再扫描 $x\in[x1,x2],y\in[y1,y2]$ 的所有点，暴力加起来，就得到了一个矩阵中的所有元素之和。与 $k$ 比较并统计答案。

时间复杂度 $O(n^3\times m^3)$。

- $70$ 分做法：

与 $30$ 分做法相同，扫描左上角与右下角的点，耗费 $O(n^2\times m^2)$ 的时间复杂度。考虑如何 $O(1)$ 求出矩阵中的元素之和。

使用二维前缀和，用 $sum[i][j]$ 表示矩阵中 $x\in[1,i],y\in[1,j]$ 的所有元素之和。其递推式为 $sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]$，具体不再赘述。

所以矩阵该矩阵的元素之和就可以用 $sum[x2][y2]-sum[x2-1][y1]-sum[x1-1][y2]+sum[x1-1][y1-1]$ 来表示。我们就做到了 $O(1)$ 求出矩阵中的元素之和。

时间复杂度 $O(n^2\times m^2)$

- 满分做法：

考虑如何把复杂度压到三次方的级别。

我们可以假想有水平的两条横线，切出了中间一块区域。用 $O(n^2)$ 的时间，枚举这两条横线（如下图所示）。
![](https://cdn.luogu.com.cn/upload/image_hosting/cwaq4wm9.png)

枚举出两条横线之后，就可以把中间的每一列数给当成一个整体，例如上图 $l1=1,l2=2$ 的情况下，就可以把矩阵视为一个序列 $[6,8,10,12]$。

我们只需要求出在这个序列中，有几个子序列的元素之和小于等于 $k$ 即可。这就**把二维问题转化为了一维问题**，这种“降维打击”的方法，是很多题目解题的切入点。

那么现在我们还有 $O(m)$ 的时间来处理子序列的问题。考虑有两个指针 $l$ 和 $r$，代表子序列的左端点与右端点。注意到矩阵中所有的元素都是正数，那么显然有下面两个结论：

1. 若 $sum(l,r)\le k$，且 $l+1\le r$，则 $sum(l+1,r)\le k$。
2. 若 $sum(l,r)>k$，且 $r+1\le n$，则$sum(l,r+1)>k$。

在遍历 $r$ 时，如果当前的子序列元素和小于等于 $k$，那么就有 $r-l+1$ 个新答案。如果大于 $k$ 了，就考虑向右移动 $l$，使得最终的子序列元素和仍然小于等于 $k$。

举个例子：有一个序列 $[1,3,4,3]$，试求出其中有多少个子序列，满足该子序列的所有元素之和小于等于 $10$。

- $l=1,r=1,sum=1,ans=0+(1-1+1)=1$
- $l=1,r=2,sum=4,ans=1+(2-1+1)=3$

批注：因为 $l=1,r=2$ 都可以，那么 $l=2,r=2$ 肯定可以。

- $l=1,r=3,sum=8,ans=3+(3-1+1)=6$
- $l=1,r=4,sum=11$

批注：此时考虑移动 $l$ 使得 $sum\le k$。 只需要向右移动一格 $l$ 就行了。

- $l=2,r=4,sum=10,ans=6+(4-2+1)=9$

此时 $r=4$，且有解了，停止循环。

### 参考代码与总结
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,a[510][510],sum[510][510],b[510];
long long l,r,now,ans;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int j=1;j<=m;j++)
		for(int i=1;i<=n;i++)
			sum[i][j]=sum[i-1][j]+a[i][j];
	for(int x=1;x<=n;x++)
		for(int y=x;y<=n;y++){
		//	cout<<x<<" "<<y<<":"<<endl;
			for(int j=1;j<=m;j++)
				b[j]=sum[y][j]-sum[x-1][j];
			//双指针
			l=1;r=1;now=0;
			for(r=1;r<=m;r++){
				now+=b[r];
				if(now<=k){
				//	cout<<l<<" "<<r<<" "<<now<<endl; 
					ans+=r-l+1;
				}
				else{
					while(now>k){
						now-=b[l];
						l++;
					}
					ans+=r-l+1;
				}
			}
		//	cout<<"-------"<<endl;
		}
	cout<<ans<<endl;
	return 0;
}
```

总结：该题的解题方法：

1. “降维打击” 法：把二维问题转化为一维。
2. 双指针法：把 $O(n^2)$ 的复杂度，通过单调性等优秀性质，转化为 $O(n)$。

---

## 作者：fengben123 (赞：32)

[P8783 [蓝桥杯 2022 省 B] 统计子矩阵](https://www.luogu.com.cn/problem/P8783)

8.15

 

------------

# **双指针**


 
双指针：维护 $ [L,R] $ 

枚举  $ L $  , 使   $ R $  一直达到使区间值满足要求的位置，然后再右移动一次 $ L $ 端点，再 **不断使 $ R $ 达到相应位置**，这样的区间值是不断  $ ≥ $   要求值

枚举 $ L $ ，使 $ R $ 第一次到达区间值满足要求位置，然后**再不断移动 $ L $ 端点**，使 $ [L,R] $ 满足，这样的区间值是不断 $ ≤ $ 要求值(~~也就是这道题要用的~~)

1.**固定 $ L $**，得到的 $ ≥ $ 要求值

2.**固定 $ R $**，得到的  $ ≤ $ 要求值；
根据变化，选择固定哪个端点，做题会更加方便 




------------



题意：

1. 找到其中的矩阵让矩阵的和 $ ≤ k $
2. 一看是二维的矩阵求值，那么就会想到前缀和，但是普通前缀和又要找到矩阵起始位置和结束位置，那时间复杂度简直太大了
3. 所以就想到降维了，变化成在 $ [l,r] $ 区间内的连续和 $ ≤ k $ ;那么区间求值，就能想到双指针了
建议先看  [P1638 逛画展](https://www.luogu.com.cn/problem/P1638)  了解下双指针的

然后就开始愉快的写代码了



------------


~~~cpp

#include<bits/stdc++.h>
#define int long long 
using namespace std;
int a[505][505],s[505][505];
int b[505];
signed main(){
	
	int n,m,k,ans=0;
	cin >> n >> m >> k;
	
	for(int i = 1 ; i <= n ; ++i )
		for(int j = 1 ; j <= m ; ++j )
			cin >> a[i][j];
	
	for(int j = 1 ; j <= m ; ++j )
		for(int i = 1 ; i <= n ; ++i )
			s[i][j]=s[i-1][j]+a[i][j];//按列前缀和，s[i][j]=a[1][j]+a[2][j]+...+a[i][j];

	for(int ii = 1 ; ii <= n ; ++ii ){  
				
		for(int i = ii ; i <= n ; ++i ){  
			
			for(int j = 1 ; j <= m ; ++ j ) b[j]=s[i][j]-s[ii-1][j];//压成一维  是从i行到j行的和； 
				
			int L=1,R=0,sum=0;//双指针 r=0初始化，所以下面while里每次R++ ps：while要R<n防止R++后越界 
			
			while(R<m){//如果右端点没越界 
				
				R++;
				
				sum+=b[R];//更新区间值 
				
				if(sum <= k) ans+=(R-L+1);//如果区间值满足了条件，所以个数就是R-L+1个 
				
				else {//如果区间值大了，那么移动左端点，然后再不断移动右端点，使区间和满足条件也就是 sum≤k时 
					
					while(sum > k ){
						sum-=b[L];//更新左端点 使区间和<=k 
						L++;
					}
					
					ans+=R-L+1;
					
				}
				
			}
			
		}
			
	}
	
	cout << ans;
	return 0;
}

~~~
可以说这道题调了好长时间才发现的这个，我太弱了

---

## 作者：DreamLand_zcb (赞：27)

### 简要题意
对于 $n \times m$ 矩阵 $a$ ，求有多少个 $a$ 的子矩阵，满足子矩阵中所有数之和小于等于 $k$。

### 思路
首先定义个指针：矩阵 $a$ 中子矩阵的上 $y$ 坐标 $up$ ，下 $y$ 坐标    $down$ ，左 $x$ 坐标 $left$ ，右 $x$ 坐标 $right$， 如图：![](https://cdn.luogu.com.cn/upload/image_hosting/zpx83xin.png)

然后定义一个二维前缀和数组 $s$ 维护矩阵 $a$ ，对于矩阵 $a$ 的任意一个子矩阵的所有数总和，如图：![](https://cdn.luogu.com.cn/upload/image_hosting/hmynjknw.png)
观察可以发现，子矩阵的所有数总和，即：

$S_\text{黑四边形}=S_\text{黄四边形}-S_\text{绿四边形}-S_\text{蓝四边形}+S_\text{红四边形}$ 

也就是：

 子矩阵所有数之和 $=s_{right, down}-s_{left-1, down}-s_{right, up-1}+s_{left-1, up-1} $ 

之后枚举指针 $up$ 和 $down$ 的位置，并且对于 $up$ 和 $down$之间的任意一个以 $left$指针为左边， $right$ 指针为右边的矩阵进行判断其总和是否小于等于 $k$ 。

__但是如果用这种方法将四个指针全部枚举一遍，时间复杂度是$O(n^2m^2)$ 会喜提TLE__，所以需要进行优化，优化如下：

假如一个子矩阵满足题目要求，那么这个子矩阵的子矩阵也是符合要求的，所以每当我们计算出一个符合要求的子矩阵时，我们也要计算出这个子矩阵的子矩阵有几个，但是由于有些子矩阵的子矩阵可能会被重复计算，所以我们只需要计算宽度为 $1$ 的子矩阵的子矩阵就足够了（长度 $> 1$ 的矩阵在枚举当前子矩阵之前或枚举当前子矩阵之后被枚举到了）。

代码如下：(四个指针的变量缩写了)
```cpp
#include <bits/stdc++.h>
#define ll long long
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

ll n, m, k, ans=0;
int a[505][505];
int s[505][505];

int get_sum(int rx, int ry, int lx, int ly)
{
	return s[rx][ry]-s[rx][ly-1]-s[lx-1][ry]+s[lx-1][ly-1];
}
int main()
{
	ios::sync_with_stdio(false);
	mem(s, 0);
	cin >> n >> m >> k;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin >> a[i][j];
			s[i][j]=s[i-1][j]+s[i][j-1]+a[i][j]-s[i-1][j-1];
		}
	}
	int up, dn;//上指针，下指针 
	int le, ri;//左指针，右指针 
	for(up=1;up<=n;up++)
	{
		for(dn=up;dn<=n;dn++)
		{
			for(le=1, ri=1;ri<=m;ri++)
			{
				while(le <= ri && get_sum(dn, ri, up, le) > k)	le++;//枚举直到子矩阵符合题意
				if(le <= ri)	ans+=ri-le+1;//判断当前子矩阵是否合法
			}
		}
	}
	cout << ans;
	return 0;
}

```

---

## 作者：JXkcy (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P8783)
## 1.先看题

看到这道题题面，其大意就是：对于 $ n \times m $ 矩阵 $ a $，求有**多少个**子矩阵满足此子矩阵中所有数之和不大于 $ k $。

## 明思路

###### 注：如果您看不懂以下的题解，~~大概率是不懂二维前缀和~~，[请走此门](https://oi.wiki/basic/prefix-sum/)

首先我们可以想到就是**前缀和**，希望利用前缀和来**统计矩阵和**。

可以很容易的想到：使用二维前缀和，在初始化矩阵数组时计算前缀和。

然后再去判断子矩阵与 $ k $ 的关系，统计答案输出即可。

## 2.浅敲一些代码

我们定义一个二维数组 $ a $，代表输入的矩阵。

再定义一个二维数组 $ s $，代表从 $ i = 1 $，$ j = 1 $ 到目标点的前缀和。

最后用一个变量 $ ans $ 来存放最终输出的答案。

我们定义 $ i $ 为行，$ j $ 为列。

相信大家都可以轻易的写出以下代码：
```cpp
for(int i = 1;i <= n;i ++){
    for(int j = 1;j <= m;j ++){
        scanf("%d",&a[i][j]);//输入矩阵 
        s[i][j] = a[i][j] + s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1];//计算前缀和 
    }
}
```
我们定义一个函数，传入子矩阵的**左上角**表示的点。**由于前缀和公式的原因**，我们直接传入的坐标为 ($ i - 1 $,$ j - 1 $)。

然后在函数中再~暴力枚举每一个点作为子矩阵的右下角:
```c
void find(int x1,int y1){//左上角的点
    for(int x2 = x1 + 1;x2 <= n;x2 ++){
        for(int y2 = y1 + 1;y2 <= m;y2 ++){//右下角的点
            int sum = s[x2][y2] - s[x1][y2] - s[x2][y1] + s[x1][y1];
            if(sum <= k)ans++;
        }
    }
}
```

我们传入**左上角**。
```
for(int i = 1;i <= n;i ++){
    for(int j = 1;j <= m;j ++){
        find(i-1,j-1);
    }
}
```
可能描述得有点抽象，但是下面就不抽象了:

## 3.完整代码
```c
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
const int MAXN = 507;
int a[MAXN][MAXN];
int s[MAXN][MAXN];
int ans=0;
void find(int x1,int y1){//左上角，右下角 
    for(int x2 = x1 + 1;x2 <= n;x2++){
        for(int y2 = y1 + 1;y2 <= m;y2++){
            int sum=s[x2][y2]-s[x1][y2]-s[x2][y1]+s[x1][y1];
            if(sum <= k)ans++;
        }
    }
}
int main(){
    scanf("%d %d %d",&n,&m,&k);
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            scanf("%d",&a[i][j]);//输入矩阵 
            s[i][j] = a[i][j] + s[i][j-1] + s[i-1][j] - s[i-1][j-1];//计算前缀和 
        }
    }
    for(int i = 1;i <= n;i++){
        for(int j = 1;j <= m;j++){
            find(i - 1,j - 1);//以i，j为左上角的点，i-1，j-1就是矩阵的《左上角的左上角》 
        }
    }
    printf("%d",ans);
    return 0;
}
```
[提交记录详情](https://www.luogu.com.cn/record/121115466)

不出意料地 T 了两个点，时间复杂度 $ O( n ^ 4 ) $ 的方法是只能拿部分分的。

那就不能用 4 重 for 循环了，得用另外一种方法：

我们构造这样的循环：使矩阵中遍历的所谓左上角的点行和列都小于右下角的点，在不满足条件的同时做遍历，所以就会用到一个新的东西：**双指针**。

双指针这个东西是不怎么学就可以理解的，说白了就是同时使用两个指针维护区间信息。由于这道题是二维的，确定两个点就用了 4 个指针。而用法详见[双指针](https://oi.wiki/misc/two-pointer/)。

### 浅讲述一下双指针这个本题重点：

1. 定义 4 个变量，用来表示左上端点的坐标和右下端点的坐标。

2. 遍历右下端点维护左上端点，符合此题描述。

3. 简述第二条：确定一个左上端点，**枚举**所有右下端点。

4. 在枚举完之后/过程中发现与条件不可能再符合的时候，重置（具体放哪看题意）。

~~一点也不~~抽象

意思就是定义 4 个指针，分别代表左上角和右下角，满足 $ i < j $ 且 $ l < r $，遍历所有可能的情况，算入所有满足条件的情况。

这里代码的第二个大循环可以自行模拟以助理解。
### 注意细节：

按照题目的数据范围，$ ans $ 最大时是可能会超过 int 的范围的。

也就是说不开 long long 的话会[这样](https://www.luogu.com.cn/record/121115923)

所以为了防止这种情况的发生，**我们至少要给 $ ans $ 开 long long**。
```c
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
const int MAXN = 507;
int a[MAXN][MAXN];
int s[MAXN][MAXN];
long long ans = 0;
int main(){
    scanf("%d %d %d",&n,&m,&k);
    for(int i = 1;i <= n;i++){
            for(int j = 1;j <= m;j++){
            scanf("%d",&a[i][j]);
            s[i][j] = a[i][j] + s[i][j-1] + s[i-1][j] - s[i-1][j-1];
        }
    }
    for(int i = 1;i <= n;i++){
        for(int j = i;j <= n;j++){
            for(int l = 1,r = 1;r <= m;r++){
                while(l <= r && s[j][r] - s[i - 1][r] - s[j][l - 1] + s[i - 1][l - 1] > k)l++;
                ans += r - l + 1;//注意细节要+1
            }
        }
    }
    printf("%lld",ans);
    return 0;
}
```
[提交结果](https://www.luogu.com.cn/record/121049041)

## 4.总结

这道题主要用到了**前缀和**与**双指针**，通过枚举两个端点搜出所有的情况。

只要我们认真读题，看好数据范围，也是可以写出来的。

蒟蒻第一次写题解，膜拜各位神犇，望管理员通过。

---

## 作者：strcmp (赞：12)

**题目大意：**

给定一个 $n \times m$ 的**正整数**矩阵 $a$，要求统计有多少个子矩阵满足**其元素和不大于 $k$。** 对于全部的数据，保证 $n,\,m \le 500$。

$\large \text{Solution}$

首先可以写一个很 naive 的暴力，六重循环枚举左上端点，右下端点，求矩阵元素和，然后当其元素和不大于 $k$ 的时候加入答案。时间复杂度 $\mathcal O(n^3m^3)$，在 O2 的加持下可以获得 $30$ 分的好成绩。

考虑在暴力基础上优化，枚举端点那里比较难优化，但是矩阵元素和相对来说比较好维护，具体的，考虑**前缀和优化。**

设 $b_{i,j}$ 为以 $(1,\,1)$ 为左上端点，以 $(i,\,j)$ 为右下端点的矩阵元素和。则可以 $\mathcal O(nm)$ 递推出 $b$。

假设当前已经知道了 $b_{i-1,j}$、$b_{i,j-1}$、$b_{i-1,j-1}$ 和 $a_{i,j}$ 的值。则可以作图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3y43ucw4.png)

发现 $b_{i-1,j}$ 和 $b_{i,j-1}$ 加起来已经包含了两次 $b_{i-1,j-1}$ 的贡献，于是 $b_{i,j}$ 不仅不需要加上 $b_{i-1,j-1}$，还需要再减去一次 $b_{i-1,j-1}$。于是可得递推式：

$$
b_{i,j} \leftarrow 
\begin{cases}
b_{i,j-1} + a_{i,j} & i = 1\\
b_{i-1,j} + a_{i,j} & j = 1\\
b_{i-1,j} + b_{i,j-1} + a_{i,j} - b_{i-1,j-1} & i \ne 1 ,\, j \ne 1
\end{cases}
$$

对于一个查询左上端点为 $(x_1,\,y_1)$，右下端点为 $(x_2,\,y_2)$ 的询问，同理可直接得到该矩阵的元素和为 $b_{x2,y_2} - b_{x_2,y_1-1} - b_{x_1-1,y_2} + b_{x_1 - 1,y_1-1}$。

此时总时间复杂度被优化为 $\mathcal O(n^2m^2)$，经过测试获得了 $80$ 分的好成绩。代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
ll a[505][505], b[505][505], k, ans = 0; int n, m;
inline ll getval(int x1, int y1, int x2, int y2) {
	return b[x2][y2] - b[x2][y1 - 1] - b[x1 - 1][y2] + b[x1 - 1][y1 - 1];
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(), cout.tie(); cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
			if (i == 1)b[i][j] = b[i][j - 1] + a[i][j];
			if (j == 1)b[i][j] = b[i - 1][j] + a[i][j];
		}
	}
	for (int i = 2; i <= n; i++) {
		for (int j = 2; j <= m; j++) {
			b[i][j] = b[i - 1][j] + b[i][j - 1] + a[i][j] - b[i - 1][j - 1];
		}
	}ll sum = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			for (int d = i; d <= n; d++){
			    for (int l = j; l <= m; l++){
			        if (getval(i, j, d, l) <= k)++ans;
			    }
			}
		}
	}
	cout << ans << "\n";
	return 0;
}
```

考虑继续优化时间复杂度，枚举左上端点已经无法优化，考虑如何将加入答案的时间复杂度优化到 $\mathcal O(n+m)$。

容易发现一个性质，如果**当前矩阵的总和**已经不大于 $k$ 时，则矩阵**任意的子矩阵元素和**都不大于 $k$。而且，每次加入一行或一列数，矩阵元素和**单调不减。**

先 $\mathcal O(nm)$ 枚举左上端点。接着可以设 $l$ 为当前考虑到的矩阵右端点的纵坐标，$r$ 为矩阵右端点的横坐标，想问作用的话先别急。

刚开始的时候，将 $l$ 一直增加，同时更新当前元素和 $v$ 的值，一直到 $v > k$ 或者 $l = n$ 的时候结束，同时更新答案（相当于加上 $l - i + 1$）。现在可以考虑将 $r$ 开始往右推进了，现在每次矩阵加入的必然是一个列，将元素和加上这个列，然后考虑每次加入的时候更新答案。

接下来有两种情况：

- $v \le k$，此时将答案加上 $l - i + 1$，因为加入一个长度为 $p$ 的列相当于新增了 $p$ 个子矩阵，又因为**子矩阵中最大的子矩阵元素和不大于 $k$** ，且加入的列长度为 $l - i + 1$，所以可以直接将答案加上 $l - i + 1$。所以其实 $v$ 所维护的相当于加入子矩阵中最大的子矩阵元素和。

- $v > k$，此时因为我们不能将 $r$ 指针回退，所以只能考虑**将 $l$ 回退**，每次更新元素和，一直到 $v \le k$，则转化为情况 $1$。

循环一直到 $r = m$ 时退出，当前所统计的答案就是以当前端点为左上端点的合法子矩阵数。容易证明，这个方法不重不漏地统计了所有的子矩阵。

计算时间复杂度，**指针 $l$ 在增加完之后单调不增**，$r$ 单调递增。于是 $l$ 最多增加 $n$ 次，减少 $n$ 次，且 $r$ 最多增加 $m$ 次，又因为我们每次都只在指针移动的时候更新 $v$，于是**这个部分的时间复杂度是 $\mathcal O(n + m)$ 的。**

总时间复杂度为 $\mathcal O(n^2m + nm^2)$，可以通过本题，代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
ll a[505][505], b[505][505], k, ans = 0; int n, m;
inline ll getval(int x1, int y1, int x2, int y2) {
	return b[x2][y2] - b[x2][y1 - 1] - b[x1 - 1][y2] + b[x1 - 1][y1 - 1];
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(), cout.tie(); cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> a[i][j];
			if (i == 1)b[i][j] = b[i][j - 1] + a[i][j];
			if (j == 1)b[i][j] = b[i - 1][j] + a[i][j];
		}
	}
	for (int i = 2; i <= n; i++) {
		for (int j = 2; j <= m; j++) {
			b[i][j] = b[i - 1][j] + b[i][j - 1] + a[i][j] - b[i - 1][j - 1];
		}
	}int l, r; ll sum = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			l = i - 1, r = j; sum = 0;
			while (sum + a[l + 1][j] <= k && l + 1 <= n)sum += a[++l][j], ++ans;
			while (r < m) {
				sum = getval(i, j, l, ++r);
				while (sum > k && l >= i)sum = getval(i, j, --l, r);
				if (l >= i)ans += l - i + 1;
				else break;
			}
		}
	}
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：DengDuck (赞：3)

首先有个朴素的思想，利用二维前缀和，我们可以在 $O(1)$ 的时间复杂度求出一个子矩阵中的元素之和。

同时，描述一个矩阵只需要描述其左上角坐标 $(x_1,y_1)$ 与右下角坐标 $(x_2,y_2)$ 即可。

于是可以枚举 $x_1,x_2,y_1,y_2$ ，然后找出 $k$ 以下的子矩阵的数量，时间复杂度 $O(n^4)$。

但是观察数据 $n,m\leq 500$ ，这种做法不可通过，我们要 $O(n^3)$ 左右的时间复杂度。

于是我们想到少枚举其中一个量,我的做法是不枚举 $y_2$。

然后剩下的问题就可以用一个双指针来做，因为剩下的决策可以看作是一维数组了，非常好维护。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL n,m,K,a[505][505],sum[505][505],b[505],ans;
int main()
{
	scanf("%lld%lld%lld",&n,&m,&K);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%lld",&a[i][j]); 
			sum[i][j]=sum[i-1][j]+a[i][j];//注意这个不是二维前缀和，是对于第 j 列的前缀和。
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		{
			for(int k=1;k<=m;k++)
			{
				b[k]=b[k-1]+sum[j][k]-sum[i-1][k];//二维转一维
			}
			LL t=0;
			for(int k=1;k<=m;k++)
			{
				while(t+1<=m&&b[t+1]-b[k-1]<=K)t++;
				if(t>=k)
				{
					ans+=t-k+1;
				}
			}
		}
	}
	printf("%lld",ans);
}
```

---

## 作者：pxb0801 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8783)

---------------
## 1.分析：

这道题的数据范围是 $1\leq n,m\leq 500$，所以时间复杂度很容易确定是立方级别，即 $O(n^3)$。

首先很容易想到用前缀和优化时间，但很多同学第一时间想到的可能是二维前缀和（包括我），这样就会导致不管怎么做都是四方级别的时间。那么，我们是不是可以只用一维前缀和，配上用于解决**静态区间问题**的王牌——**[尺取](https://blog.csdn.net/m0_74486855/article/details/127818875)**！

当然，~~为了我尺取的时候写的舒服一点~~，我决定前缀和按照列来做，也就是 ```cnt[i][j]=cnt[i-1][j]+a[i][j]```。然后再用变量 $i$ 和 $j$ 分别表示区间的上边和下边，至于左右边的确定就靠尺取啦。

--------------
## 2.AC 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long//光k的范围就超int了
using namespace std;
ll n,m,k,a[505][505],cnt[505][505],ans;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%lld",&a[i][j]);
			cnt[i][j]=cnt[i-1][j]+a[i][j];//按列做的前缀和
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){//确定上边界和下边界，注意j从i开始枚举
			ll s=0;
			for(int l=1,r=1;r<=m;r++){///双指针模板
				s+=cnt[j][r]-cnt[i-1][r];//这里加的是一个用前缀和优化的区间
				while(s>k){
					s-=cnt[j][l]-cnt[i-1][l];//减的当然也是区间
					l++;
				}
				ans+=r-l+1;//把所有可以的答案加到ans里
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：xrtbclx (赞：1)

# P8783 [蓝桥杯 2022 省 B] 统计子矩阵题解
## [题目传送门](https://www.luogu.com.cn/problem/P8783)

### part one 暴力解法——
最容易的做法便是 暴力枚举 坐标 $O(n^2m^2)$，再进行求和 $O(nm)$，总复杂度 $O(n^3m^3)$。由数据范围可知这绝对无法全部 AC。

### part two 前缀和 优化——
考虑使用 前缀和 优化，使求和 $O(nm)$ 优化为 $O(1)$，总复杂度为 $O(n^2m^2)$。可这个复杂度依旧太高，无法全部 AC。

### part three 前缀和+双指针——
标算正解，AC 代码！枚举子矩阵的上、下坐标 $O(n^2)$，左、右坐标使用 双指针 $O(m)$，求出总和不大于 k 的子矩阵。总复杂度 $O(n^2m)$。当然，你也可以枚举左、右坐标，双指针 上、下坐标，$O(m^2n)$。可 AC 本题所有测试点。
### 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

long long n,m,num[505][505],k,s[505][505],ans;//定义变量（保险起见，用 long long）。
int main()
{
	cin >>n>>m>>k;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			cin >>num[i][j];
		}
	}
    //输入。
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + num[i][j];
		}
	}
    //求 前缀和。
	for(long long up = 1; up <= n; up++)
	{
		for(long long dow = up; dow <= n; dow++)
		{
            //枚举上、下、坐标。
			long long l = 1,sum = 0;//定义子矩阵相关变量。
			for(long long r = 1;r <= m; r++)
			{
				sum = s[dow][r] - s[up-1][r] - s[dow][l-1] + s[up-1][l-1];
                //求子矩阵和。
				while(sum > k && l <= r)
				{
					l++;
					sum = s[dow][r] - s[up-1][r] - s[dow][l-1] + s[up-1][l-1];
				}
                //若和大于 k，则增加左指针。
				if(sum <= k && l <= r)ans+=r-l+1;
                //记录答案。
			}
		}
	} 
	cout <<ans;
    //输出。
    return 0;
    //AC 结束！
}
```

---

## 作者：WydnksqhbD (赞：1)

# [P8783](https://www.luogu.com.cn/problem/P8783) 题解
**Update 2024/1/4:发现原错误（复杂度写成了 $O(N^3)$）**，求管理大大再审核一下。
## 思路
思路很简单：在矩形中取两条横着的线，把中间这一块的每一列就看成一个数。然后使用双指针（虽然听上去很高大上，其实就是俩变量 $l,r$）以及储存前面数的和的变量 $cnt$，先指向第 $1$ 列，接着**重复进行以下操作：**

+ $cnt$ 加上目前这一列数的总和。
+ 如果 $cnt>k$，说明接下来不能再加了（和超过 $k$ 了），则 $l+1$，$cnt$ 减去刚刚加上的数。
+ 答案加 $r-l+1$。

然后呢？没了啊，输出 $ans$ 就可以了。

本方法时间复杂度 $O(N^2M)$，空间复杂度 $O(NM)$，根据数据范围，由于 $500^3=125000000=1.25\times 10^8$，可以 $122ms$ 通过。

**超级细节处理：记住，开 `long long`！**

当然了，还有一些细节，如**前缀和**（你不用试试）、**预处理**等等，实在不会可以参考一下我的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=505;
int n,m;
ll k,ans;
ll a[N][N],s[N],sum[N][N];
int main()
{
	scanf("%d %d %lld",&n,&m,&k); //scanf输入，记得%lld。
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%lld",&a[i][j]);
		}
	}
	for(int j=1;j<=m;j++)
	{
		for(int i=1;i<=n;i++)
		{
			sum[i][j]=sum[i-1][j]+a[i][j]; //前缀和。
		}
	}
	int up,down; //即那两条线。
	for(up=1;up<=n;up++)
	{
		for(down=up;down<=n;down++)
		{
			for(int i=1;i<=m;i++)
			{
				s[i]=sum[down][i]-sum[up-1][i]; //这里需要处理一些前缀和。
			}
			int left=1,right=1,cnt=0; //l、r和cnt。
			for(;right<=m;right++)
			{
				cnt+=s[right]; //这个看不出来什么意思的可以退了。
				if(cnt>k) //判断第一种情况。
				{
					while(cnt>k)
					{
						cnt-=s[left++];
					}
				}
				ans+=right-left+1; //统计答案
			}
		}
	}
	printf("%lld",ans); //输出，记得%lld。
	return 0; //完美结束。
}
```

最后说一下，对结论有质疑的，可以想一下，是不是会扫到所有的矩形。

---

## 作者：Y_Aridy (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P8783)

**题意理解：**

在 $ n \times m $ 的矩阵中统计总和不超过给定整数 $ K $ 的子矩阵数。

子矩阵：原矩阵中大小为 $ i \times j $ 的矩阵（其中 $ 1 \le i \le n,1 \le j \le m $）。

------------

**前置知识：**

1. 双指针：

	双指针用于**维护区间信息**，在本题中优越性在于将 $ O(n^2) $ 的复杂度降为 $ O(n) $ 的复杂度。
    
###     [双指针具体请戳](https://oi-wiki.org/misc/two-pointer/)

2. 降维：

	将**二维问题转化为一维问题**，便于计算。
    
3. 前缀和：

	前缀和是一种重要的预处理方式，能降低**查询**的时间复杂度。
    
###     [前缀和具体请戳](https://oi-wiki.org/basic/prefix-sum/)

------------

根据题意，前缀和预处理的是二维中列的和，用于后续降维，降维后用双指针对答案进行维护，最终输出答案即可。

------------

# 代码（贴）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500+7;
//警钟：在int类型下，sum值可能溢出，需要long long 
//十年OI一场空，不开long long见祖宗 
long long n,m,k,ans=0;
long long a[maxn][maxn],b[maxn],s[maxn][maxn];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			s[i][j]=s[i-1][j]+a[i][j];//求列的前缀和 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			for(int g=1;g<=m;g++){
				b[g]=s[j][g]-s[i-1][g];//对i-j行进行降维 
			}
			int l=1,r=0,sum=0;
			while(r<=m){ 
				r++;
				if(r>m) break;
				sum+=b[r];
				if(sum<=k){
					//答案维护，符合区间个数为r-l+1 
					ans+=r-l+1;
				}
				else{
					//不满足要求下，将左指针右移 
					while(sum>k){
						sum-=b[l];
						l++;
					}
					ans+=r-l+1;
				}
			}
		}
	}
	cout<<ans;
	return 0;
} 
```


---

## 作者：liushuaishuai (赞：1)

# 题目大意

求矩阵的和不超过 $k$ 的子矩阵的个数。

# 思路一

运用[二维前缀和](https://blog.csdn.net/justidle/article/details/103754960)优化，依次枚举左上角坐标、右下角坐标。

但时间复杂度为 $O(n^2 \times m^2)$ 会超时。

这时要考虑 $O(n^3)$ 的做法。

# 思路二

可以发现数都是从小到大进行排列的，说明这些数具有单调性，那就可以用[尺取法](https://blog.csdn.net/qq_45735851/article/details/109137237)来优化双重循环。

## 尺取代码

```cpp
for (int left = 1, right = 1; right <= m; right++){ // 一个双指针枚举
				
				while (left <= right && s[j][right] - s[i - 1][right] - s[j][left - 1] + s[i - 1][left - 1] > k)
				
					left++; // 左指针右移

				sum += right - left + 1; // 算长度+1
				
			}
```

这个是我写的尺取。

### 初值

一开始 $l$ 和 $r$ 赋值为 $1$。

### 循环条件

我是用一个 ``while`` 循环来写循环条件的。

```cpp
left <= right
```

左指针小于等于右指针。

```cpp
s[j][right] - s[i - 1][right] - s[j][left - 1] + s[i - 1][left - 1] > k
```

这一段是对坐标 $i$，$left$ 到 $r$，$right$ 的求和，其实就是一个基础的二维前缀和求和，另外注意是 $>k$ 而非 $\ge k$。

### $i,j$ 变化

右指针一直右移，左指针按情况右移。

# 代码
```cpp
#include <bits/stdc++.h>

const int N = 510;

using namespace std;

long long n, m, k, sum; //注意要开long long，第一次没加WA了(sum变量)

long long a[N][N], s[N][N]; // a为输入数组， s为预处理数组

int main(){
	
	cin >> n >> m >> k;
	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j];
			
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			s[i][j] = a[i][j] + s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1]; // 一个二维预处理
			
    for (int i = 1; i <= n; i++)
		for (int j = i; j <= n; j++)
			for (int left = 1, right = 1; right <= m; right++){ // 一个双指针枚举
				while (left <= right && s[j][right] - s[i - 1][right] - s[j][left - 1] + s[i - 1][left - 1] > k)
					left++; // 左指针右移
				sum += right - left + 1; // 算长度，记得+1
			}
	
	cout << sum;
	return 0;
}
```


---

## 作者：didi2012 (赞：0)

### P8783题解
法一：暴力枚举  
最容易的做法便是暴力枚举坐标 $O(n^2m^2)$，再进行求和 $O(nm)$，总复杂度为 $O(n^3m^3)$。由数据范围可知这绝对无法全部 AC。  
法二：前缀和优化
考虑使用前缀和优化，使求和 $O(nm)$ 优化为 $O(1)$，总复杂度为 $O(n^2m^2)$。可这个复杂度依旧太高，无法全部 AC，仍然会 TLE 几个点（不信自己去算）。  
法三：前缀和+双指针  
可以 AC 了！！！代码如下：  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, m, num[505][505], k, s[505][505], ans;

int main() {
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> num[i][j];
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + num[i][j];
		}
	}
	for (ll up = 1; up <= n; up++) {
		for (ll dow = up; dow <= n; dow++) {
			ll l = 1, sum = 0;
			for (ll r = 1; r <= m; r++) {
				sum = s[dow][r] - s[up - 1][r] - s[dow][l - 1] + s[up - 1][l - 1];
				while (sum > k && l <= r) {
					l++;
					sum = s[dow][r] - s[up - 1][r] - s[dow][l - 1] + s[up - 1][l - 1];
				}
				if (sum <= k && l <= r)
					ans += r - l + 1;
				//cout <<up<<' '<<dow<<' '<<l<<' '<<r<<"\n";
			}
		}
	}
	cout << ans <<endl;
	return 0;
}
```

---


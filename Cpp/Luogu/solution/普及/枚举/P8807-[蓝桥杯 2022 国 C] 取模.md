# [蓝桥杯 2022 国 C] 取模

## 题目描述

给定 $n, m$，问是否存在两个不同的数 $x,y$ 使得 $1 \le x < y \le m$ 且 $n \bmod x = n \bmod ⁡y$。

## 说明/提示

对于 $20\%$ 的评测用例，$T \le 100$，$n, m \le 1000$；

对于 $50\%$ 的评测用例，$T \le 10000$，$n, m \le 10^5$；

对于所有评测用例，$1\le T \le 10^5$，$1\le n\le 10^9$，$2\le m \le 10^9$。

蓝桥杯 2022 国赛 C 组 C 题。

## 样例 #1

### 输入

```
3
1 2
5 2
999 99```

### 输出

```
No
No
Yes```

# 题解

## 作者：晴空一鹤 (赞：32)

### Solution

看起来像是求 $n$ 在 $\le m$ 的值域是否存在 $2$ 个及以上的因子，然后使用某种优化，其实不是。

不妨回到最原始的暴力，我们考虑让 $n$ 对 $[1,m]$ 范围内的整数取模。

对 $1$ 取模，只有 $1$ 种可能，为 $0$。

对 $2$ 取模，只有 $2$ 种可能，为 $0,1$。

……

直到出现一个数使 $n$ 取模后与前面某个数取模结果相等。

看起来是 $O(m)$ 的？

其实不是，我们可以发现，想让循环继续，$n\bmod2$ 必须是 $1$，因为 $0$ 已经出现过了，$n \bmod 3$ 必须是 $2$，因为 $0,1$ 都已经出现过了...... $n \bmod m$ 必须是 $m-1$，因为 $0,1,2,...,m-2$ 都已经出现过了。

于是我们可以得到一堆同余式，前 $i$ 个同余式的最小解增长迅速，而 $n$ 最多只有 $10^9$，所以这个循环不会循环太多次（经测验最多 $13$ 次）。

所以我们就可以放心大胆的打~~暴力~~正解啦！

#### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
void inline slove(){
  cin>>n>>m;
  if(m>n+1)
  printf("Yes\n");
  else{
  for(int i=1;i<=m;i++)
  if(n%i!=i-1){
  printf("Yes\n");
  return ;
  }
  printf("No\n");
  }
}
int main(){
   cin>>t;
   while(t--)slove();
}
```

---

## 作者：yizcdl2357 (赞：25)

# 题意

给定 $n, m$，问是否存在两个不同的数 $x,y$ 使得 $1 \le x < y \le m$ 且 $n\bmod x = n\bmod y$。$n,m\le 10^9$。
# 前置知识
[抽屉原理](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fr=kg_general)，最小公倍数，看完本文证明的耐心（~~这算前置知识吗~~）。

# 题解

考虑问题的**反面**，我们发现条件不成立，当且仅当 $n$ 对 $1\sim m$ 中的所有数取模，其结果**两两不同**。

记 $L=\text{lcm}(1,2,\cdots,m)$。显然，当 $n$ 加上或减去 $L$ 时，$n\bmod 1,n\bmod 2,\cdots,n\bmod m$ 的值都是不变的，因此答案也不变，不妨把 $n$ 对 $L$ 取模。

手玩几个比较小的 $m$ 可以发现，当且仅当 $n=L-1$ 时，$n\bmod 1,n\bmod 2,\cdots,n\bmod m$ 才两两不同。接下来证明这点。

当且仅当 $n=L-1$ 时才有 $n\bmod x=x-1(1\le x\le m)$。

因此，如果 $n<L-1$，一定能找到一个 $x$ 满足 $n\bmod x\le x-2$。

此时考虑 $n\bmod 1,n\bmod 2,\cdots,n\bmod x$：这 $x$ 个数的取值范围都在 $0\sim x-2$ 之间，也就是有 $x-1$ 种可能取值。

轮到伟大的[抽屉原理](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fr=kg_general)出场了！

此时这 $x$ 个数就像 $x$ 个物品，被放到 $x-1$ 个抽屉里，此时必有两个物品放在同一个抽屉里，即必有两个数相等。

故此时应输出 `Yes`，即当且仅当 $n\bmod L=L-1$ 时输出 `No`。

# 代码

首先记得开 `long long`。

其次，因为 $\text{lcm}(1,\cdots,30)>10^9$，所以当 $m>30$ 时一定有 $n\bmod L<L-1$，直接输出 `No`；

又因 $\text{lcm}(1,\cdots,30)<2^{63}$，所以可以预处理 $a_i=\text{lcm}(1,\cdots,i)\quad(1\le i\le 30)$ 不会超过 `long long` 范围，转移方程 $a_i=\text{lcm}(a_{i-1},i)$。
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
inline int gcd(int x,int y)
{if(y==0)return x;return gcd(y,x%y);}
inline int lcm(int x,int y)
{return x/gcd(x,y)*y;}
int L[31],T,n,m;
signed main()
{
	L[1]=1;
	for(int i=2;i<=30;i++)
		L[i]=lcm(L[i-1],i);
	cin>>T;
	while(T--)
	{
		cin>>n>>m;
		if(m>30){printf("Yes\n");continue;}
		if(n%L[m]==L[m]-1) printf("No\n");
		else printf("Yes\n");
	}
	return 0;
}
```


---

## 作者：J2a0m0e8s (赞：6)

在博客食用效果更佳！ [blog](https://www.luogu.com.cn/blog/zyyjulao/qu-mu-ti-xie)

# 思路

看到这道题，有些困难，首先考虑打表找规律。

然后发现打表出来的数据奇奇怪怪，根本没有规律。于是~~果断切题~~考虑用数学知识证明。

# 证明

若不存在满足条件的 $ x,y $ ，使得题述条件成立。

由于任何数模 $ 1 $ 都为 $ 0 $ ，而任何数模 $ 2 $ 只能为 $ 0 $ 或 $ 1 $，故必须有 $ n \bmod 2 =1 $。

因此 $ n \bmod 3$ 不能等于 $ 0 $ 或 $ 1 $, 故只能有 $ n \bmod 3 = 2 $ 。

以此类推可得当且仅当 $n \bmod i = i-1 (i=1,2,3 ,… ,m) $ 都成立时，不存在满足条件的 $ x,y $ 。

而当 $ m $ 很大时，一定存在符合条件的 $ x,y $ ,打表知 $ m>18 $ 时一定存在。

因此就可以打出代码了。

```
#include <bits/stdc++.h>
using namespace std;
#define LL long long  
int T,i;LL n,m;
int main() {
    cin>>T;
    while(T--){
    	cin>>n>>m;
    	if(m>=19){puts("Yes");continue;}
    	for(i=2;i<=m;i++) 
    	if(n%i!=i-1){puts("Yes");--i;break;} //依次判断是否符合条件
    	if(i==m+1)puts("No");
	}
	return 0;
}
```

不开 $O2$ 条件下可以在 $83ms$ 内通过最大数据。

当然，本题也可以考虑用剩余定理优化。

由剩余定理，$n \bmod i = i-1 (i=1,2,3 ,… ,m) $ 等价于 $n \bmod \operatorname{lcm}(1,2,…,m) = \operatorname{lcm}(1,2,…,m)-1 $ ，故可以利用这一点优化。但是对于实际的大水数据，由于预处理常数与栈空间较大，及数据可能极小，并没有快多少。。。

作者的代码如下。

```
#include <bits/stdc++.h>
using namespace std;
#define LL long long
int T,i;LL n,m,fac[35];
LL gcd(LL x,LL y){
	if(x<y)return gcd(y,x);
	if(y==0)return x;
	return gcd(y,x%y);
}
LL lcm(LL x,LL y){   //求最小公倍数
	return x*y/gcd(x,y);
}
int main() {
    cin>>T;
    fac[0]=1;
    for(int i=1;i<=19;i++)
	fac[i]=lcm(fac[i-1],i); //预处理最小公倍数
    while(T--){
    	cin>>n>>m;
    	if(m>=19){puts("Yes");continue;}
    	if(n%fac[m]!=fac[m]-1)puts("Yes"); //剩余定理直接判断
    	else puts("No");
	}
	return 0;
}
```


---

## 作者：_wjr_ (赞：5)

这是一道比较简单的数论题。

每组数据中，若存在 $n \bmod x = n \bmod y$，那么 $n \bmod \operatorname{lcm}(x,y) \le \min (x,y)$。原因显然。

而且，当 $m \ge 23$ 时，由于 $\operatorname{lcm}(1,2,\cdots,23) - 1 > 10^9$，所以显然有解。我们的暴力只需要依次枚举 $1 \le x < y \le 12$ 就可以啦~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int gcd (int x, int y)//最大公因数，为求最小公倍数
{
    if (!y) return x;
    return gcd (y, x % y);
}

int lcm (int x, int y)//最小公倍数
{
    return x * y / gcd (x, y);
}

signed main()
{
    
    int T;
    cin >> T;
    while (T--)
    {
        int n, m;
        cin >> n >> m;
        if (m >= 25) cout << "Yes" << endl;
        else
        {
            bool flag = false;
            for (int i = 1; i < m; i++)//暴力枚举！
                for (int j = i + 1; j <= m; j++)
                    if (n % lcm (i, j) < min (i, j) && !flag) 
                    {
                        cout << "Yes" << endl;
                        flag = true;
                    }
            if (!flag) cout << "No" << endl;
        }
    }
    return 0;
}
```

完结撒花~

---

## 作者：Sktic (赞：3)

[P8807 [蓝桥杯 2022 国 C] 取模](https://www.luogu.com.cn/problem/P8807)



首先，可以发现 $m$ 很大的时候一定有解。



然后对于 $m$ 较小的情况，我们可以从 $1$ 到 $m$ 暴力枚举每个 $x$，并且记录下 $n\bmod x$，若之前枚举时已经出现过 $n \bmod x$ ，则说明存在两个不同的 $x,y$ 。这样可以避免 $O(n^2)$ 的暴力枚举。判重的地方可以用 $\texttt{set}$ 或者 $\texttt{mutiset}$ 解决。



跑得很快，最大点只有 $\text{50ms}$ 。

AC Code：

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
typedef long long ll;
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	while(n--)
	{
		int x,y;
		cin>>x>>y;
		if(y>=30)
			cout<<"Yes"<<endl;
		else
		{
			int fl=0;
			multiset<int> p;
			for(int i=1;i<=y;i++)
			{
				p.insert(x%i);
				if(p.count(x%i)>=2)
				{
					cout<<"Yes"<<endl;
					fl=1;
					break;
				}
			}
			if(!fl)
				cout<<"No"<<endl;
		}
	} 
	return 0;
}
```



---

## 作者：BFSDFS123 (赞：1)

可以发现，最坏情况下，$n$ 取模的余数每个都不同。

我们可以设 $x \equiv n-1  \mod n$。

容易发现，对于 $1\sim n$ 中的所有整数，满足条件的第一个数肯定是 $\operatorname{lcm}(1,2,\dots,n)-1$，其中 $\operatorname{lcm}$ 代表的是最小公倍数。

又因为 $n \le 10^9$，容易发现，只要 $\operatorname{lcm}(1,2,\dots,n)-1$ 大于 $10^9$，$n \mod x=n\mod y$ 一定成立。

为什么呢？

因为其中构不成 $n$ 项余数全不相同的情况。

计算得到当 $n=23$ 时，$\operatorname{lcm}(1,2,\dots,n)-1 \ge 10^9$。

所以当 $m \ge 23$ 的时候，$n \mod x=n\mod y$ 一定成立。

剩余情况，可以暴力枚举。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
#define eps 1e-8
const int inf=0x3f3f3f3f;
int gcd(int x,int y)
{
	return y==0?x:gcd(y,x%y);
}
int lcm(int x,int y)
{
	return x/gcd(x,y)*y;
}
int endpos=-1;
void prepare_work()
{
	int ans=1;
	for(int i=1;i<=1e9;i++)
	{
		ans=lcm(ans,i);
		if(ans-1>1e9)
		{
			endpos=i;
			break;
		}
	}
}
signed main()
{
	prepare_work();
	int T;
	scanf("%lld",&T);
	while(T--)
	{
		int n,m;
		scanf("%lld%lld",&n,&m);
		if(m>endpos)
		{
			puts("Yes");
			continue;
		}
		int calcrange=m;
		bool flag=false;
		map<int,int> mp;
		for(int i=1;i<=m;i++)
		{
			for(int j=i+1;j<=m;j++)
			{
				if(i==j) continue;
				if(n%i==n%j) flag=true;
			}
		}
		if(!flag) puts("No");
		else puts("Yes");
	}
	return 0;
}

```

---


# [蓝桥杯 2022 国 C] 斐波那契数组

## 题目描述

如果数组 $A = (a_0,a_1,\cdots,a_{n − 1})$ 满足以下条件，就说它是一个斐波那契数组：

1. $n>2$。
2. $a_0=a_1$。
3. 对于所有的 $i\ge2$ 都有 $a_i=a_{i-1}+a_{i-2}$。

现在，给出一个数组 $A$，你可以执行任意次修改，每次修改将数组中的某个位置的元素修改为一个大于 $0$ 的整数。请问最少修改几个元素之后，数组 $A$ 会变成一个斐波那契数组。

## 说明/提示

**【样例说明】**

将原数组修改为 $(1,1,2,3,5)$，最少修改三个元素变成了一个斐波那契数组。

**【评测用例规模与约定】**

对于所有评测用例， $3 ≤ n ≤ 10^5$，$1 ≤ a_i ≤ 10^6$。

蓝桥杯 2022 国赛 C 组 E 题。

## 样例 #1

### 输入

```
5
1 2 2 4 8```

### 输出

```
3```

# 题解

## 作者：离散小波变换° (赞：16)

## 题解

记 $\mathrm{Fib}(i)$ 表示斐波那契数列的第 $i$ 项。其中，

$$\mathrm{Fib}(n)=\begin{cases}1 & n = 0 \text{ or } n = 1 \\ \mathrm{Fib}(n - 1)+\mathrm{Fib}(n - 2) & n > 1\end{cases}$$

记修改完后的序列为 $b$。取 $e=b_0$。由题设，$b_0=b_1=e$，也就有 $b_0=\mathrm{Fib}(0)\cdot e,b_1=\mathrm{Fib}(1)\cdot e$。

容易根据数学归纳法得到，

$$b_n=b_{n-1}+b_{n-2}=(\mathrm{Fib}(n-1)+\mathrm{Fib}(n-2))\cdot e=\mathrm{Fib}(n)\cdot e$$

假如 $a_n=b_n$，也就是我们不需要修改这个位置的数，那就有：

$$e=a_n\div \mathrm{Fib}(n)$$

不过，这个式子成立的前提是 $\mathrm{Fib}(n)\mid a_n$。如果不成立的话那就找不到这个 $e$，这个位置就必须要被修改了。另外斐波那契数列的增长速度很快的。当 $\mathrm{Fib}(n)$ 已经大于值域 $m=10^6$ 那也就不用管了。

当然，最终 $e$ 肯定只能有唯一一个。于是要使结果最小，也就是保留最多的位置，那就选择出现次数最多的那个 $e$。开一个桶统计一下就行。

时间复杂度 $\mathcal O(m)$。比楼下的快很多。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
int qread(){
    int w=1,c,ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
const int MAXN = 1e6 + 3;
int H[MAXN], u = 1, v = 1, t, m = 1e6;
int main(){
    int n = qread();
    up(1, n, i){
        int a = qread(); if(a % u == 0) H[a / u] ++;
        if(u < m) t = v, v = u + v, u = t;
    }
    int ans = INF;
    up(1, m, i) ans = min(ans, n - H[i]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：一扶苏一 (赞：14)

### Analysis

注意到即使 $f_0 = f_1 = 1$，$f_{30}$ 也达到了 $1346269 > 10^6$。这就是说，原数列第 $30$ 位之后的元素都一定会被修改。

不妨枚举 $a_0$ 被修改后的值，算出此时 $a_1$ 到 $a_{29}$ 修改后的值。$a_0$ 只有 $10^6$ 种可能，故一共只要算不超过 $3 \times 10^7$ 个数。

对于每种修改的方案，把这 $30$ 个数和 $a_0 \sim a_{29}$ 逐个匹配，就可以算出该情况下有多少个数需要被修改。所有情况取最大值即可。

时间复杂度 $O(n F(a_i))$，其中约定 $F(x)$ 表示 Fibonacci 函数的反函数，在本数据范围下最大为 30。

### Code
```cpp
#include <array>
#include <vector>
#include <iostream>
#include <algorithm>

const int maxn = 1000006;

int a[maxn];
std::vector<int> b[maxn];

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int n; std::cin >> n;
  std::generate_n(a, n, []() { int x; std::cin >> x; return x; });

  for (int i = 1; i <= 1000000; ++i) {
    b[i].push_back(i);
    b[i].push_back(i);
    for (int j = 2; j <= 30; ++j) {
      int x = b[i][j - 1] + b[i][j - 2];
      if (x > 1000000) break;
      b[i].push_back(x);
    }
  }

  int ans = n;
  for (int i = 1; i <= 1000000; ++i) {
    int tans = (n > b[i].size()) ? (n - b[i].size()) : 0;
    for (int j = 0; j < std::min(n, int(b[i].size())); ++j) if (a[j] != b[i][j]) {
      ++tans;
    }
    ans = std::min(ans, tans);
  }

  std::cout << ans << std::endl;

}
```
### Gen
```python
from random import randint
import os
import sys

lim = 1000000
fib = list()
m = 30
fib.append(1)
fib.append(1)
for i in range(2, m):
  fib.append(fib[i - 1] + fib[i - 2])

for T in range(10):
  inf = 'data' + str(T) + '.in'
  anf = 'data' + str(T) + '.ans'

  f = open(inf, 'w', newline = '\n')

  if T < 3:
    n = 10 * (T + 1)
  else:
    n = 100000
  if T == 4: n = 30
  c = randint(1, lim // fib[min(n, 30) - randint(1, 5)])
  a = fib[:]
  for i in range(m):
    a[i] *= c
    a[i] %= lim
  for i in range(m, n):
    a.append(randint(1, lim))
  cnt = randint(1, m)
  for i in range(cnt):
    a[randint(0, m - 1)] = randint(1, lim)
  if T == 4: a = fib[:]
  
  if T >= 7:
    c = 10 - T
    mm = 24
    for i in range(mm):
      t = i % c + 1
      a[i] = fib[i] * t
    for i in range(mm, m):
      a[i] = randint(1, lim)
    if T != 8:
      a[randint(1, mm)] = randint(1, lim)
      a[randint(1, mm)] = randint(1, lim)
  print(n, file = f)
  for i in range(n - 1):
    print(a[i], end = ' ', file = f)
  print(a[n - 1], end = '\n', file = f)
  f.flush()
  op = 'std.exe < ' + inf + ' > ' + anf
  print(op, file = sys.stderr)
  os.system(op)
```

---

## 作者：MvemiY (赞：8)

话说蓝桥杯为什么不给部分分啊。

本文所有 $f$ 表示原始的[斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145)。
# 暴力
考虑枚举每一个 $a_1$，构造斐波那契数组，然后逐个比较。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXN = 1e5 + 10;
ll a[MAXN], b[MAXN], n, ans = MAXN, maxi, az;
int main(){
	cin >> n;
	for(int i = 1; i <= n; i++)
		scanf("%lld", &a[i]), maxi = max(maxi, a[i]);
	for(int i = 1; i <= maxi; i++){
		ll tem = 0;
		memset(b, -1, sizeof(b));
		b[1] = b[2] = i;
		for(int j = 3; j <= n; j++)
			b[j] = b[j - 1] + b[j - 2];
		for(int j = 1; j <= n; j++){
			tem += (a[j] != b[j]);
			if(tem >= ans)
				break;
		}
		ans = min(ans, tem);
	}
	cout << ans ;
	return 0;
}
```
结果全部 T 掉，然后我头一次知道蓝桥杯没有部分分。
 
#  正解
 
## 前置知识
首先我们来证明一个东西：

如果 $a$ 是一个斐波那契数组，那么满足以下关系式：

$$a_i = f_i \times a_1(i \ge 3)$$

其中，$f$ 表示原始的[斐波那契数列](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145)。

证明如下：

设 $a_1 = a_2=x$，则 $a_3=2x,a_4 =(1+2)x = 3x,a_5 = (2+3)x=5x$ ······，将每个系数记到 $b$ 里：$b_1 = b_2 = 1$，$b_i=b_{i-1}+b_{i-2}(i\ge3)$，与 $f$ 的递推式是相同的。

## 进一步的思考
将修改后合法的斐波那契数组记为 $s$。

于是我们就可以想到，因为并不可以 插入 或 删除，所以每个 $a$ 数组元素的位置是固定不动的，对应的 $f_i (i \ge3)$ 也是唯一的。

所以我们可以枚举每一个 $a_i$，看看它对应的 $s_1$ ，如果 $a_i \nmid f_i$ 就说明它一定要被修改，直接无视就可以了。然后找到对应元素最多的 $s_1$，最后答案就是 $n$ 减去对应元素最多的 $s_1$ 对应的元素数。

## 数据类型与解决方案
众所周知，`long long` 连 $f_{100}$ 都表示不了，即使是 `__int128` 也无能为力， $f_{5000}$ 大约为 $6\times 10^{1046}$，而 `__int128` 所对应的最大值仅仅为 $170141183460469231731687303715884105727$。（大约为 $10^{38}$）~~高精？我才不要打。~~

考虑到 $a_i \le 10^6$，因此当 $f_i>10^6$ 时，$a_i \nmid f_i$ 一定成立，所以我们直接求出小于等于 $10^6$ 的 $f_i$ 就可以了！

## 小问题：关于容器

因为 $1\le a_i\le 10^6$，直接用 `桶` 就可以了。

## AC代码，细节看注释
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXN = 1e5 + 10;
ll f[MAXN], a[MAXN], bot[1000010], n, ans, m, maxc = -1, az = -1;
int main(){
	cin >> n;
	for(int i = 1; i <= n; i++)
		scanf("%lld", &a[i]),
		az = max(az, a[i]);
	// 找到 max{a[i]} 是优化，但是直接跑到 1e6 也不会 T
	f[1] = f[2] = 1;
	for(int i = 3; i <= n; i++){
		f[i] = f[i - 1] + f[i - 2];
		if(f[i] > 1e6){
			m = i - 1;
			break;
		}
	}
	// m 表示的是第一个 <= 1e6 的 f[i] 的位置
	// 当 m 没有改变，说明 f[n] <= 1e6，直接赋值为 n 即可
	if(m == 0)
		m = n;
	for(int i = 1; i <= m; i++)
		if(a[i] % f[i] == 0)
			bot[a[i] / f[i]] ++;
	for(int i = 1; i <= az; i++)
		maxc = max(maxc, bot[i]);
	cout << n - maxc;
	return 0;
}
```
这个做法是可以过掉讨论帖里的 hack 数据的。

（再次提交：代码被hack掉是因为手滑将 `1e6` 写成 `1e5`，现已AC）


---

## 作者：Xy_top (赞：6)

看到了暴力代码有了思路。仅需改一行就可以过了。

暴力是枚举以每一个数为斐波那契数列的起点，那么问题来了，这个数最大是多少呢？

暴力的代码选的最大数是 $n$ 个数里的最大数，其实并不需要选这么大。

仅需选择 $\max(16\times \log_2(a[i]))$ 就可以了。

我们发现，$\log_{100000}$ 就是 $16$，$100000$ 是 $n$ 的最大值。

至于 $\log_{a[i]}$，刚刚说过了斐波那契数列是 $2^n$ 级别增长的。

注意，数据 $2$ 范围很小，但非常毒瘤，所以要开到 $16$，其他的数据都很水，开到 $\log_2(a[i])$ 就可以过。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a[100005], b[100005], lg[1000005];
ll n, ans = 100005, ma;
int main()
{
	ios::sync_with_stdio (false);
	cin >> n;
	lg[1] = 0;
	for (int i = 1; i <= 1000000; i ++) lg[i] = lg[i / 2] + 1;
	for (int i = 1; i <= n; i ++)
	{
		cin >> a[i];
		ma = max (ma, 16 * lg[a[i] ]);
	}
	for (int i = 1; i <= ma; i ++){
		ll t = 0;
		b[1] = b[2] = i;
		for (int j = 3; j <= n; j ++) b[j] = b[j - 1] + b[j - 2];
		for (int j = 1; j <= n; j ++){
			t += (a[j] != b[j]);
			if (t >= ans) break;
		}
		ans = min(ans, t);
	}
	cout << ans;
	return 0;
}
```


---

## 作者：liaoxingrui (赞：5)

## Content

给出一个长度 $n$ 的正整数数组 $A$，求最少经过几次修改，$A$ 数组可以被修改为一个斐波那契数组。

修改在题目中指将 $A$ 的任意一个数修改为一个正整数；

斐波那契数组实际上就是一个长度大于 $2$ 的满足斐波那契数列定义的数组，但是 $a_0$ 和 $a_1$ 可以为**任意正整数**，只需要满足 $a_0 = a_1$ 这个条件即可。

数据范围：$3 \le n \le 10^5$，$1 \le a_i \le 10^6$。

## Solution

注意到数据范围，$1 \le a_i \le 10^6$，也就是说斐波那契数组至多也是 $30$ 项，所以我们可以先把斐波那契数列预处理出来，统计答案也只需要 $30$ 个数，最后输出把后面的数加上就行了。

因为只需要满足 $a_0 = a_1$ 这个条件，所以我们斐波那契数组是可以在一般的斐波那契数列上乘倍数，最坏情况下是需要乘 $10^6$ 的。

因为之前预处理了斐波那契数列，所以当前的数列与乘完倍数的斐波那契数组不同的个数的最小值，便是答案。

**注意**：文中“斐波那契数列”与“斐波那契数组”是有区别的，“斐波那契数列”指的是一般的斐波那契数列，而“斐波那契数组”指的是经过修改 $A$ 数组后得到的题面中所描述的斐波那契数组。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 30 + 9, M = 1e6;
int n, ans = 0x3f3f3f3f, a[N], f[N];

int main(){
	scanf ("%d", &n);
    for (int i = 1; i <= min(n, 30)/*只需要统计前 30 个数的答案*/; ++i) scanf ("%d", &a[i]);
    
    f[1] = f[2] = 1; 
    for (int i = 3; i <= 30; ++i) f[i] = f[i - 1] + f[i - 2];
    
    for (int i = 1; i <= M; ++i) {
    	int cnt = 0;
        for (int j = 1; j <= min(n, 30) ; ++j) cnt += (a[j] != i * f[j]);
        ans = min(ans, cnt);
    }
    
    printf ("%d", ans + max (0, n - 30)); // 别忘记加上后面的答案
    
    return 0;
}

```

---

## 作者：王熙文 (赞：4)

## 思路

首先，斐波那契数组的增长速度是飞快的。以斐波那契数列为例（$a_0=a_1=1$ 的斐波那契数组），在第 $30$ 项左右就超过 $10^6$ 了。又因为所有 $a_i$ 都小于等于 $10^6$，所以在 $30$ 项以后的 $a_i$ 都必须修改。现在我们只需要考虑前 $30$ 项是否可以不改了。

如果确定了 $a_0$ 的值，就可以确定整个斐波那契数组了。当 $a_0 > 10^6$ 则都需要改，所以我们只需要在 $1 \sim 10^6$ 中枚举 $a_0$，从而算出整个斐波那契数组。然后看最多有多少个数不需要改即可。

## 代码

代码中为了防止溢出，用了一个方法：如果当前已经大于 $10^6$ 了，则以后也都会大于 $10^6$，直接赋值为 $0$ 即可。

```cpp
#include<bits/stdc++.h> // 下标从 1 开始
using namespace std;
int n; int a[100010];
int f[60];
int main()
{
    cin>>n; for(int i=1; i<=n; ++i) cin>>a[i];
    int ans=n;
    for(int i=1; i<=1e6; ++i)
    {
        int nowans=max(n-31,0);
        f[1]=f[2]=i;
        for(int j=3; j<=min(n,31); ++j)
        {
            if(f[j-1]+f[j-2]>1e6)
            {
                for(int k=j; k<=min(n,31); ++k) f[k]=0;
                break;
            }
            f[j]=f[j-1]+f[j-2];
        }
        for(int j=1; j<=min(n,31); ++j) nowans+=(f[j]!=a[j]);
        ans=min(ans,nowans);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：KarmaticEnding (赞：2)

看一道题，第一重要的是算法，第二重要的是数据范围。

题目给定：$1 ≤ a_i ≤ 10^6$，让我们看看，$a_1$ 和 $a_2$ 都取得最小值，即 $a_1=1$，$a_2=1$ 的时候斐波那契数列会长什么样子。

上百度一搜（或用程序跑一遍）之后，发现 $a_{30}=832040,a_{31}=1346269>10^6$，所以当 $n>30$ 的时候，$a_{31}$ 后面的数全部需要改变，不用再往后推。

这样，$n$ 的范围就被我们缩小到了 $3≤n≤30$。那么对于 $3≤n≤30$ 范围里的 $n$，由于数据范围极小，我们可以直接开始枚举。将 $a_1$ 从 $1$ 枚举到 $10^6$，然后依次对比后面的数改变了多少个，取出最小的一个值作为常数。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[35],b[35];//b数组用来记录a[1]在不同情况下的斐波那契数列
int main(){
	int n;
	scanf("%d",&n);
	for(int i=0;i<n && i<30;++i){
		cin>>a[i];
	}
	int maxnumber;
	int output=2147483647;//一定要初始化，否则34行可能不起作用 
	//Fibonacci核心枚举阶段
	for(int i=1;i<=1000000;++i){
		maxnumber=0;//多测不清空，爆零两行泪 
		b[0]=i;
		b[1]=i;
		if(a[0]!=b[0]){
			++maxnumber;
		}
		if(a[1]!=b[1]){
			++maxnumber;
		}
		//Fibonacci递推公式:b[i]=b[i-1]+b[i-2]
		int j;
		for(j=2;j<n && j<30;++j){
			b[j]=b[j-1]+b[j-2];
			if(a[j]!=b[j]){
				++maxnumber;
			}
		}
		maxnumber=maxnumber+(n-j);//如果n>=30,那么后面的数就全部需要更新 
		output=min(output,maxnumber);
	}
	printf("%d",output);
} 
```


---

## 作者：AirQwQ (赞：1)

首先第一步想到的肯定是暴力，枚举 $1$ 到 $10^6$ 每个数分别作为开头，然后与原数组对比每一项，当然时间复杂度 $O(a_i \times n)$ 毫无疑问 T 了。

发现 $a_i \leqslant  10^6$，又当 $a_1$ 取到最小值 $1$ 时 $a_{30} = 832040$ 而 $a_{31} > 10^6$ 所以不用再往后考虑，这时时间复杂度为 $O(a_i)$ 加上一个大约 $30$ 的常数，完全足以通过本题。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[300005],b[35],ans=2e9,maxn,j;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=1e6;i++){
        maxn=0,b[1]=i;
        if(a[1]!=b[1]) maxn++;//记得判断第一项
        for(j=2;b[j-1]<1e6;j++)//与暴力不同点，只用枚举到10e6
            b[j]=b[j-1]+b[j-2],maxn+=(b[j]!=a[j]);
        maxn+=(n-j+1);//它可以适应j与n的所有情况，具体原因交给读者自己推了
        ans=min(maxn,ans);
        //cout<<maxn<<' ';
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：what_can_I_do (赞：1)

[传送门](https://www.luogu.com.cn/problem/P8808)

~~这题最初我只判断了 $a_1$ 和 $a_2$ 不变和 $a_2$ 变为 $a_1$ 的情况，结果还被水过去了。~~

其实这道题不难。在某次做某某市信息竞赛的初赛时发现了一个规律：
$$a_i=f_i\times a_1$$
其中 $a$ 数组为前 $2$ 项把斐波那契数组 $f$ 扩大的斐波那契数组。

其实不难证明，$a_i=a_{i-1}+a_{i-2}$，那么就有 $a_3=a_2+a_1$，其中 $a_2=f_2\times x$，$a_1=f_1\times x$，直接合并同类项可得 $a_3=x\times(f_2+f_1)=x\times f_3$，那么就可得 $a_i=x\times f_i$，其中 $x=a_1\div f_1=a_1$。

那么我们就可以先求出 $f$ 数组，然后看 $a$ 数组中每个元素是 $f$ 数组中相对应的元素的几倍，如果不为整数倍则不管。接着用一个数组 $t$ 作为桶，$t_i$ 表示有几个 $a$ 数组中的元素是 $f$ 数组中相对应的元素的 $i$ 倍。（$f_i$ 数组只需计算到 $10^6$ 就行了，因为 $a_i$ 最大也就到 $10^6$，绝对比后面的斐波那契数更小，所以不用管大于 $10^6$ 的斐波那契数。）

最后我们只需要把 $t$ 数组中最大的元素求出，用 $n$ 减掉就是答案了。（就相当于是除了为那个倍数以外的所有数都得改。）

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010],s=0,t[1000010],maxx=-1,f[100010]={0,1,1},l=2,maxxx=1000000;
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++) scanf("%d",&a[i]),maxx=max(maxx,a[i]);
    while(1)
    {
    	if(f[l-1]+f[l]>maxxx) break;
    	l++;
    	f[l]=f[l-2]+f[l-1];
	}
	for(register int i=1;i<=l;i++) if(a[i]%f[i]==0) t[a[i]/f[i]]++;
	for(register int i=1;i<=maxx;i++) s=max(s,t[i]);
    printf("%d",n-s);
    return 0;
}
```

---

## 作者：hyl_____ (赞：1)

## Step 0
~~据说 AC 代码是这样的？~~

```cpp
#include<bits/stdc++.h>  
using namespace std;  
int main()  
{  
	int n;
	cin>>n;
	cout<<n-1;
	return 0;//华丽结束 
}  
```
蓝桥杯的题是真让人大开眼界啊。

## Step 1
由于确定的只有 $a_0$，$a_1$，所以只需要爆枚 $a_0$ 和 $a_1$ 的值，然后比较原数组和现数组的不同之处累加，取最小。

枚举到多少呢？

因为题目说 $a_i \leq 10 ^ 5$，所以只需要枚举到 $10 ^ 5$ 即可。

但因为 $n\leq 10 ^ 5$，即使是普通斐波那契数列，一个个比对也会超 `__int128`。但不难发现，在最基础的斐波那契数列中，到了第 $27$ 项就已是 $1.21397 \times 10 ^ 5$，就已经超出了题目的范围，所以只能更改。

所以我们只用在循环条件中加上 $a_i \le 10 ^ 5$ 即可。

## AC CODE

```cpp
#include<bits/stdc++.h>  
using namespace std;  
long long a[100010],b[100010];//数组开大，数据不炸
int main()  
{  
	int n;
	cin>>n;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	int ans1;
	int minn=2e9;
	for(int i=1;i<=100000;i++)
	{
		ans1=0;//累加器清零
		int num;
		b[1]=b[2]=i;
		if(b[1]!=a[1]) ans1++;
		if(b[2]!=a[2]) ans1++;//要判断前两项
		for(int j=3;b[j-1]<1e6;j++)
		{
			b[j]=b[j-1]+b[j-2]; 
			if(b[j]!=a[j]) ans1++;
			num=j;
		}
		ans1+=(n-num-1+1);//因为只累加到了小于等于1e6的部分，所以还要将大于1e6的数量加上
		minn=min(minn,ans1);//取最小值
	}
	cout<<minn;
    return 0;//华丽结束 
}  
```

---

## 作者：WindowsWKP (赞：0)

# 思路
枚举 $f_1$ 和 $f_2$。

这题的范围是 $a_i\le 10^6$，所以枚举范围只需要设定在 $1\le f_1\le 10^6$ 即可。

而斐波那契数列的第 $30$ 项就大于了 $10^6$，所以枚举时只需要枚举到第 $30$ 项即可，剩下的一律判作需要修改。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[40];
int a[40];
int ans=100000,tmp;
int main(){
    int n;
    cin>>n;
    for (int i=1;i<=min(n,30);i++)
        cin>>a[i];
    for (int i=1;i<=1000000;i++){
        f[1]=f[2]=i;
        tmp=0;
        tmp+=((f[1]!=a[1])+(f[2]!=a[2])+max(n-30,0));
        for (int j=3;j<=min(30,n);j++){
            f[j]=f[j-1]+f[j-2];
            tmp+=(f[j]!=a[j]);
        }
        ans=min(ans,tmp);
    }
    cout<<ans;
    return 0;
}
```
# 鸣谢
感谢[OIerYang](https://www.luogu.com.cn/article/yr9e57n6)提供了部分思路。

---

## 作者：ny_Dacong (赞：0)

# 思路

比较水的黄题。

发现即使 $f_0 = f_1 = 1$，$f_{30} = 1346269 > 10^6$。如果 $f_0$ 更大，后面的数也只会越来越大。

而题目保证 $1 \le a_i \le 10^6$，所以我们只需要考虑前三十个数即可。剩下的一定得改。

那么我们暴力枚举 $f_0$，范围为 $1 \sim 10^6$。然后递推出 $f_1 \sim f_{30}$，然后扫描一遍 $f_0 \sim f_{30}$ 判断是否需要修改。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans = 0x3f3f3f3f,ex = 0;
long long num[40],New[40];
void generate(){
    New[1] = New[0];
    for(long long i = 2; i < n; i++){
        New[i] = New[i-1]+New[i-2];
    }
    return;
}
int main(){
    scanf("%lld",&n);
    if(n > 30){
        ex = n-30;
        n = 30;
    }
    for(long long i = 0; i < n; i++){
        scanf("%lld",&num[i]);
    }
    for(long long i = 1; i <= 1000000; i++){
        static long long tp;
        tp = 0;
        New[0] = i;
        generate();
        for(long long j = 0; j < n; j++){
            if(New[j] != num[j]){
                tp++;
            }
        }
        ans = min(ans,tp);
    }
    printf("%lld",ans+ex);
    return 0;
}
```

---

## 作者：OIerYang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8808)

根据题目描述可以得知，此题正解或暴力和~~斐波那契本尊~~斐波那契数列有关。

然后粗劣想一下，即可发现改后数组中的 $f_1=f_2$。

因为：

$$
f_2=f_1+f_0=f_1
$$

之后考虑斐波那契数列的性质。

可以知道 $f_1$ 可以控制之后的 $f_2\to f_n$。

为什么？实践一下。

当 $f_1=2$ 时：

$$
f_2=f_1=2
$$

$$
f_3=f_2+f_1=4
$$

$$
f_4=f_3+f_2=6
$$

$$
f_5=f_4+f_3=10
$$

$$
\vdots
$$

当 $f_1=3$ 时：

$$
f_2=f_1=3
$$

$$
f_3=f_2+f_1=6
$$

$$
f_4=f_3+f_2=9
$$

$$
f_5=f_4+f_3=15
$$

$$
\vdots
$$

实践就轻松得到一个结论：

当 $f_1=x$ 时，剩下的书则为 $f_i=F_i\times x$。

然后可以发现时间复杂度最大为 $10^5\times10^6$，远远大于 $10^8$，所以我们考虑优化 $n$ 或 $x$。

这时我们发现斐波那契数列即使 $f_1=1$ 时，$F_{30}=1346269>10^6$。

所以在 $i>30$ 后的都得改，我们就无需考虑。

这时时间复杂度问题就解决了。

code：(代码中有详细注释)
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int a[31],fei[31];
void solve(){
	int n;cin>>n;
	int p=max(0ll,n-30);//当i>30的个数
	if(n>30)n=30;
	for(int i=1;i<=n;i++)cin>>a[i];
	fei[1]=fei[2]=1;
	for(int i=3;i<=n;i++)fei[i]=fei[i-1]+fei[i-2];
	//求出斐波那契数列
	int ans=0x3f;
	for(int i=1;i<=1000000;i++){//枚举a[1]
		int cnt=0;
		for(int j=1;j<=n;j++){
			if(a[j]!=i*fei[j])cnt++;//需改变的操作个数
		}
		ans=min(ans,cnt);//求出最优值
	}
	cout<<ans+p;//前30项的修改结果再加上后面的
}
signed main(){
	ios::sync_with_stdio(0);
	int T;T=1;
	// cin>>T; 
	while(T--)solve();
	return 0;
}
```

---

## 作者：jixiyue114514 (赞：0)

# 第一思路：暴力（40分）
第一思路比较容易想到的是暴力算法。

即枚举每一个作为“起点”的元素构造一个斐波那契数列，之后对比输入的数列与枚举的数列中“区别最小”的情况，即可得到答案。

```cpp
#include<bits/stdc++.h>
const int MAX = 1e5+10;
using namespace std;
int arr1[MAX];
int arr2[MAX];
int main()
{
	int n,MAX=INT_MIN,ans=INT_MAX;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>arr1[i];
		if(arr1[i]>MAX)MAX=arr1[i];
	}
	for(int i=1;i<=MAX;i++){//枚举[1,MAX]之间的数作为起点 
		arr2[0]=arr2[1]=i;
		int temp=0;
		for(int j=2;j<n;j++){//构造数列 
			arr2[j]=arr2[j-1]+arr2[j-2];
		}
		for(int j=0;j<n;j++){//比较数列 
			temp+=(arr1[j]!=arr2[j]);
		}
		if(temp<ans)ans=temp;
	}
	cout<<ans<<endl;
	return 0;
}
```
# 第二思路
我们仔细读题不难发现，实际上由输入的数列变化得到的斐波那契数列必然是“起点”为 $1$ 的斐波那契数列的倍数，那么，我们只需对比输入数列的每一个元素与“起点是 $1$ 的斐波那契数列”的倍数关系，找到出现的倍数关系次数最多的数，此时将其他不是该倍数关系的数进行更改即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAX=1e6+10;//注意范围 
 
int f[MAX];
int arr[MAX];
 
signed main(){
	int n,ma=INT_MIN,ans;
	cin>>n;
	
	f[0]=f[1]=1;
	for(int i=2;i<n;i++){
		f[i]=f[i-1]+f[i-2];//得到正常的斐波那契数列 
	}
	for(int i=0;i<n;i++){
		int temp;
		cin>>temp;
		if(temp>ma)ma=temp;//得到所有元素的最大元素值
		int num=temp%f[i];
		if(num==0){
			arr[temp/f[i]]++;//对应倍数进行计数 
		} 
	}
	int maxx=INT_MIN; 
	for(int i=1;i<=ma;i++){//找到出现次数最多的倍数 
		if(arr[i]>maxx){
			maxx=arr[i];
		}
	} 
	ans=n-maxx;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Ljh421 (赞：0)

**斐波那契数列**，大家应该很熟悉了，不知道的看题也能懂。

### 题意描述

给出一个长度为 $n$ 的数组，求最少修改几个数可以让该数组成为斐波那契数列。

### 题目分析

$ 3\le n \le 10^5$，$1 \le a_i \le 10^6$，乍一眼好像没什么问题，可你仔细品，如果 $a_i$ 没问题，$n$ 真的能到 $10^5$ 吗？

好像并不是，我自己测的是32（测得可能不对）。

哈哈，既然测试数据是假的，那就可以暴力了！

我的**思路**是这样的：

枚举求出 $a_0$，然后循环求后面的数，如果与 $a_i$ 不相等 $ans$ 就加一，最后求最小的 $ans$，输出就行。

### 代码展示

温馨提示：不要复制！不要复制！不要复制！


```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100005],small=9999999;
int main(){
	
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=1000;i++){ 
		int x=i,y=i,z=i*2,ans=0;
		if(a[0]!=i) ans++;
		if(a[1]!=i) ans++;
		for(int j=2;j<n;j++){
			if(a[j]!=z){
				ans++;
			}
			x=y;
			y=z;
			z=x+y;
		}
		small=min(small,ans);
	}
	printf("%d",small);
	
	return 0;
}
```

好了，到这里这篇题解就结束了，希望能帮到你，谢谢！

---

## 作者：0x282e202e2029 (赞：0)

# P8808 [蓝桥杯 2022 国 C] 斐波那契数组 题解

[题目传送门](https://www.luogu.com.cn/problem/P8808)

水炸了。

## 思路

读题可知，一个「斐波那契数组」$\{F_n\}$ 的任一项 $F_i = c \cdot fib_i$。其中，$c$ 为常数，$\{fib_n\}$ 表示斐波那契数列。即，**斐波那契数组的每一项与斐波那契数列的每一项成正比**。

考虑优化。在题目最下面，有着不起眼的一句话：

>对于所有评测用例， $3 ≤ n ≤ 10^5$，$1 ≤ a_i ≤ 10^6$。

注意这个数据范围，$a_i$ 的最大值只有 $10^6$，而 $fib_{31} = 1346269$，已经超过了此范围！

因此，可以将 $n$ **在任何情况下**缩小至最大值仅仅为 $30$，只需再枚举 $c$ 即可。且同时，$c$ 的可能最大值也仅为 $10^6$。在辅以~~不要脸的~~打表，轻松水过。

总复杂度为常数，轻松 AC。

## AC 代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int fib[35] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040};//打表
const int MAXN = 1e5 + 5, INF = 0x3f3f3f3f;
int n;
int a[MAXN];
int ans, res = INF, cnt;
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
    	scanf("%d", &a[i]);
	}//输入
	if (n >= 30)
	{
		ans += n - 30, n = 30;//n变为30，剩余部分只能修改
	}
	for (int i = 1; i <= 1e6; i++)//即上文c
	{
		cnt = 0;//改变的数字个数
		for (int j = 1; j <= n; j++)
		{
			cnt += int(a[j] != i * fib[j]);//如果a_j ≠ i·fib_j（要修改），则cnt++，反之则不变
		}
		res = min(cnt, res);//改变答案
	}
	printf("%d", ans + res);//最终答案为两部分答案之和
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/112898629)

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

对于一个数组 $a$，如果这个数组满足如下条件，我们就称这个数组为斐波那契数组：

$$a_n = \begin{cases}a_{0} = a_{1} \\ a_{n-1}+a_{n-2} & n > 1\end{cases}$$

给定一个数组 $a$，求这个数组更改几个数后可以成为一个斐波那契数组。

### 题目分析

我们设原始数组为 $a$，更改后的数组为 $b$，斐波那契数列为 $F$（$F_0 = F_1 = 1$）。

由于题目规定，$a_0 = a_1$，所以我们可以设 $b_0 = b_1 = k$。

根据通项公式 $b_i = b_{i-1} + b_{i-2}$，我们可以得出：

$$b_n = \begin{cases}b_n = k & n \le 1 \\ b_n = k \times F_n & n > 1 \end{cases}$$

即：

$$\forall i \in [1, n],b_i = F_i \times k$$

对于每个 $a_i$，我们可以通过 $a_i$ 和 $F_i$ 求出此项不改变时的 $k$。特别地，因为 $a_i$ 必须是整数，所以 $a_i$ 和 $F_i$ 必须除 $k$ 同余。即：

$$k = a_i \div F_i~(a_i \equiv F_i~(\bmod k))$$

我们可以开个桶子 $cnt$ 记每个 $k$ 出现的次数，则 $cnt_i$ 表示 $F_i$ 扩了 $cnt_i$ 倍后，有几个数与 $a$ 数组相同。所以，答案为 $n - cnt_{\max}$。

时间复杂度是 $\mathcal O(V)$ 的（$V$ 为值域范围）

### code
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

const int INF = 1e9, N = 1e6 + 5;
int f[N], n, u, v, t, m = 1e6;

int main()
{
    scanf("%d", &n);
    u = v = 1;
    for(int i = 1, a;i <= n;i++)
    {
        scanf("%d", &a);
        if(a % u == 0)
            f[a / u]++;
        if(u < m)
            t = v, v = u + v, u = t;
    }
    int ans = INF;
    for(int i = 1;i <= m;i++)
        ans = min(ans, n - f[i]);
    printf("%d", ans);
    return 0;
}
```

---

## 作者：liangbob (赞：0)

### P8808 题解

#### 思路分析

思维吧，但也不是很难，嘲讽蓝桥杯。

记 $F_i$ 为 $a_1=a_2=i$ 的斐波那契数列。

首先，斐波那契数列的“形式固定”，即任意一个斐波那契数列，都是 $F_1$ 的倍数。

然后，我们就可以看看，每个数是 $F_1$ 扩大几倍得到的。

我们开一个桶，对于 $x=1 \sim Z_{\max}$（$Z_{\max} = 10^6$），记录 $F_1$ 扩大 $x$ 倍后，得到的数有多少个与 $a$ 相同。

那么显然，$n$ 减去桶记录的数，就是需要改动的数，对于每个计算结果，取最小即可。

怎么去计算桶里的值呢？很简单，我们来个“回手掏”，每次，如果对应的 $F_1$ 的数能整除这个原数组里面的数，我们记 $k$ 为原数组里面的数除以对应的 $F_1$ 的数。易证 $F_1$ 扩大 $k$ 倍后，扩大后对应的 $F_k$ 的数必然与此数相同，假设这个桶为 $\text{cnt}$，于是此时可以让 $\text{cnt}_k$ 加一。

然后就做完了。

#### 关键代码

```cpp
int n;
cin >> n;
f[1] = f[2] = 1;
for(int i = 3;i <= 1000000;i++)
{
    f[i] = f[i - 1] + f[i - 2]; //求 F1
}
for(int i = 1;i <= n;i++)
{
    int t;
    cin >> t;
    if(t % f[i] == 0) //统计桶
    {
        cnt[t / f[i]]++;
    }
} 
int minv = numeric_limits<int>::max(); //相当于 INT_MAX
for(int i = 1;i <= 1000000;i++)
{
    minv = min(minv, n - cnt[i]); //求最小
}
cout << minv << endl;
```



 

---


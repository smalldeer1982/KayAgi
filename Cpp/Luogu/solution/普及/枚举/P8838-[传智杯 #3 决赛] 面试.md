# [传智杯 #3 决赛] 面试

## 题目背景

disangan233 和 disangan333 去面试了，面试官给了一个问题，热心的你能帮帮他们吗？

## 题目描述

现在有 $n$ 个服务器，服务器 $i$ 最多能处理 $a_i$ 大小的数据。

接下来会有 $k$ 条指令 $b_k$，指令 $i$ 表示发送 $b_i$ 的数据，需要你分配一个空闲的服务器。

请你算出一个序列 $p_k$ 表示指令 $i$ 的数据分配给服务器 $p_i$，且 $p_k$ 的字典序最小；如果无法分配，输出 "-1"。

对于所有数据，$n,k\leq 6$，$a_i,b_i \leq 10$。 

## 说明/提示

### 样例解释

第 1 条指令分给服务器 1；  
第 2 条指令分给服务器 3；  
第 3 条指令分给服务器 2；  
第 4 条指令分给服务器 4；  
第 5 条指令分给服务器 6；  
第 6 条指令分给服务器 5。

## 样例 #1

### 输入

```
6 6
1 9 1 9 8 1
1 1 4 5 1 4```

### 输出

```
1 3 2 4 6 5```

# 题解

## 作者：_H17_ (赞：5)

## 思路分析

这道匹配的题，可以让数据选择设备，并且标记上这个设备已经被匹配了。

我们可以使用深度优先搜索实现，把每一种合法排列搜索一遍，第一次输出并标记上，后面搜到就不输出，然后如果没有则输出 `-1`。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[7],b[7],p[7];
//按题目名称定义变量&数组
bool f=1,u[7];
//f用来判断是不是最小的全排列，u数组用来判断是否被使用过
void dfs(int s){
    if(s==k+1){
        if(f)
            for(int i=1;i<=n;i++)
                printf("%d ",p[i]);
        //字典序最小
        f=0;
        //标记
        return;
    }
    //边界
    for(int i=1;i<=n;i++)
        if(a[i]-b[s]>=0/*够用*/&&!u[i]/*没用过*/){
            p[s]=i,u[i]=1;
            dfs(s+1);
            u[i]=0;
            //标记是否使用过
        }
        //让每次数据匹配一个机器
    return;
}
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
        scanf("%d",a+i);
    for(int i=1;i<=k;i++)
        scanf("%d",b+i);
    //输入
    dfs(1);
    //深度优先搜素
    if(f)
        puts("-1");
    //没有输出-1
    return 0;
}
```

---

## 作者：fengziyi (赞：1)

### 主要思想
观察数据在 $ n,k \leq 6 $ 范围，尝试使用搜索方法解决问题。  
由于我们是按顺序搜索，所以回溯的部分不需要将改变的 `ans[]` 数组置回零。  
下面我在注释中详细讲述搜索过程。
### 贴个代码
```cpp
bool dfs(int i)
{
    // a[] 储存服务器处理能力
    // b[] 储存请求大小
    // ans[] 储存每个请求的结果
    if (i > k)
    {
        // 对于每一个请求都找到了对应的服务器，结束并输出
        for (reg int i = 1; i <= k; ++i)
            printf("%d ", ans[i]);
        printf("\n"); return true;
    }
    for (reg int j = 1; j <= n; ++j)
        // 枚举每一个服务器
        if (a[j] >= b[i] && vis[j] == false)
        // 检查能否处理当前请求，是否已经处理了一个请求
        {
            vis[j] = 1; ans[i] = j; // 标记访问，储存结果
            if (dfs(i + 1)) return true; // 搜索下一个请求
            vis[j] = 0; // 回溯
        }
    return false;
}
int main()
{
    ...
    if (!dfs(1)) printf("-1\n"); // 特殊结果
    ...
}

```
勿抄袭！

---

## 作者：zaochen (赞：1)

## 一些话
本题数据范围很小，做法可以是深度优先搜索或者排列枚举。  
本题解的做法是排列枚举。

## 做法
每条指令需要分配一个空闲的服务器，所以若答案存在，则答案是数字 $ 1 $ 到 $ n $ 的全排列中满足条件（每个服务器都足够处理对应数据）的。  
时间复杂度为 $ O(n!) $ 可以通过所有数据。  

## 细节问题
判断是否满足每个服务器都足够处理对应数据可以直接循环。  
```cpp
bool check(){
    for (int i=1;i<=n;i++)
        if (a[ans[i]]<b[i]) // 如果有一台服务器不能处理对应数据
            return false;
    return true;
}
```

在 C++ STL 中，可以用 `next_permutation()` 函数来枚举排列，用法如下。   
```cpp
next_permutation(ans+1,ans+n+1);
```

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,k;
int a[8],b[8],ans[8];

void print(){
    for (int i=1;i<=n;i++)cout<< ans[i] << ' ';
    cout << endl;
}

int j(int n){ // 求阶乘
    int ans=1;
    for (int i=2;i<=n;i++) ans*=i;
    return ans;
}

bool check(){
    for (int i=1;i<=n;i++)
        if (a[ans[i]]<b[i])
            return false;
    return true;
}

int main()
{
    cin >> n >> k;
    for (int i=1;i<=n;i++) cin >> a[i];
    for (int i=1;i<=n;i++) cin >> b[i];
    for (int i=1;i<=n;i++) ans[i]=i;
    for (int i=1;i<=j(n);i++){ // n 个元素的全排列最多有 n 的阶乘种
        if (check()) {
            print();
            return 0;
        }
        next_permutation(ans+1,ans+n+1);
    }
    cout << -1 << endl; // 无解
	return 0;
}

```


---


# [信息与未来 2019] 堆栈计算机

## 题目描述

有一种新型的堆栈计算机，计算机的内存是一个初始为空的数列，计算机支持三种操作：
- $\tt 1$ - 将整数 $1$ 放入数列的尾部。任意时刻都可执行此操作。
- $\tt dup$ - 将数列尾部的数字复制一份，放入数列尾部。只有数列非空时才能执行此操作。
- $\tt add$ - 取出（并删除）数列尾部的两个数字，相加后放回数列的尾部。只有数列中至少有两个数字时才能执行此操作。

给定一个正整数，你需要输出一个长度不超过 $200$ 的程序（操作的序列），它在执行结束后，恰好得到一个长度为 $1$ 的数列，并且数列中的数字恰好为 $n$。下图展示了一个最终得到 $8$ 的程序。

![](https://cdn.luogu.com.cn/upload/image_hosting/unim6xbj.png)



## 说明/提示

对于 $60\%$ 的测试数据，有 $1\le n\le10^4$。

对于 $100\%$ 的测试数据，有 $1\le n\le10^9$。
> 本题原始满分为 $15\text{pts}$。

## 样例 #1

### 输入

```
1```

### 输出

```
1```

## 样例 #2

### 输入

```
8```

### 输出

```
1
1
add
dup
add
dup
add```

# 题解

## 作者：WsW_ (赞：13)

### 思路一   

我们需要使栈中所有元素之和为 $n$，再全部加起来即可。  
最简单的方法是直接往栈中放 $n$ 个 $1$，似乎一个点都过不了。  
为了使操作次数尽可能少，我们需要最大化单次的收益。收益指让栈中的元素之和增加了多少。  
* 操作 $\mathtt{1}$，收益为 $1$。
* 操作 $\mathtt{dup}$，收益为 $top$。
* 操作 $\mathtt{add}$，收益为 $0$。

第一次操作一定是操作 $\mathtt{1}$，因为此时栈中还没有数字。
如果之后我们重复依次执行操作 $\mathtt{dup}$ 和 $\mathtt{add}$，那么执行 $2x$ 次操作后，栈中的数字变成了 $2^x$。 

将 $n$ 拆成二进制，再按照上述方法制作二进制下 $n$ 的每一位的数字即可。  

能够获得 $60\%$ 的分数。

### 代码和[提交记录](https://www.luogu.com.cn/record/126264746)
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
int n;
bool f=1;
void make(int x){
	puts("1");
	while((x>>1)>0){
		x>>=1;
		puts("dup");
		puts("add");
	}
}

int main(){
	scanf("%d",&n);
	while(n){
		make(lowbit(n));
		if(f)f=0;
		else puts("add");
		n-=lowbit(n);
	}
	return 0;
}
```


---
### 思路二
先看一个例子。  

输入：
```
6
```
我们的代码会从 $1$ 开始制作 $2$，再从 $1$ 开始制作 $4$，最终加起来得到结果。  

如果我们将制作出的 $2$ 进行 $\mathtt{dup}$，再在复制的 $2$ 的基础上制作 $4$，那么就可以省去一部分步骤。  
这时我突然想到了[快速幂](https://www.luogu.com.cn/problem/P1226)的思想。我们一个变量记录栈顶元素，不停地对其进行 $\mathtt{dup}$ 和 $\mathtt{add}$，如果二进制的 $n$ 在这一位是 $1$，那就把它额外复制一遍留着，最终把所有保留的加起来即可。

### 代码和[提交记录](https://www.luogu.com.cn/record/126266317)
```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
using namespace std;
int n;
int x=1;
int cnt=-1;
bool f=1;

int main(){
	scanf("%d",&n);
	puts("1");
	while(x<n){
		cnt+=bool(x&n);//记录一下最终要加几个数
		if(x&n)puts("dup");//赋值保存下来
		n-=n&x;//将这一位变为0
		x<<=1;
		if(x<=n)puts("dup\nadd");//继续增长
	}
	while((cnt--)>=0)puts("add");
	return 0;
}
```

---

## 作者：xiaoshumiao (赞：6)

其实没有 WsW 大佬所说的那么复杂。

看到这道题的设置，我们不难想到递归处理。定义函数 `solve(n)` 为输出一个输出 $n$ 的程序的函数。

- 当 $n=1$ 时，直接输出 $1$。

- 否则，先 `solve(n>>1)` 一下，使得栈内有一个 $\lfloor{\dfrac{n}{2}}\rfloor$，然后 `dup` 一下 `add` 一下，栈内就有一个 $2 \times \lfloor{\dfrac{n}{2}}\rfloor$ 了。如果 $n$ 是奇数需要加一个 $1$ 随后再 `add` 一下，就能得到 $n$ 了。

因为最多递归调用 $\log n$ 即 $29$ 层，极端情况下需要输出约 $4 \times 29 =116$ 行，题目的限制绰绰有余。（实测当 $n=2^{29}-1$时会输出 $113$ 行。）

实现起来很简单。
```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(int n) {
    if(n==1) return cout<<"1\n",void();
    else solve(n>>1),cout<<"dup\nadd\n";
    if(n&1) cout<<"1\nadd\n";
}
int main() {
    ios::sync_with_stdio(false),cin.tie(nullptr);
    int n; cin>>n,solve(n);
    return 0;
}
```

---

## 作者：wst000 (赞：1)

# 题意

本题是让你用三种操作使栈中有一个 $n$。

# 思路
考虑递归。定义函数 `f(x)` 为输出一个使栈中有一个 $x$ 的操作序列。当 $x = 1$ 时，输出 1，否则调用 `f(x/2)` 得到一个 $\Large\lfloor \frac{x}{2} \rfloor$，将其乘2，即使用 `dup` 和 `add`，如果 $x$ 为单数，则加 1，即使用 1 和 `add`。其实这思路和快速幂挺像的。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
ll n,m,k,ans;
void f(ll a){
	if(a==1)printf("1\n");
	else {
		f(a/2),printf("dup\nadd\n");
		if(a%2)printf("1\nadd\n");
	}
}
int main() {
	scanf("%lld",&n);
	f(n);
	return 0;
}
```

---

## 作者：Mark_Pei (赞：1)

## solution

一道**栈和进制构造题**。

要解决这个问题，我们要通过一系列操作生成一个长度为 $1$ 的数列，并且数列中的数字恰好为给定的正整数 $n$。

先初始状态，将数列设为空。再选择操作，我们可以通过 $1$ 操作将数字1放入数列，通过 `dup` 操作复制数列尾部的数字，通过 `add` 操作将数列尾部的两个数字相加并放回数列。

对于给定的数字 $n$，如果 $n$ 是偶数，我们可以通过 `dup` 和 `add` 操作来得到它。如果 $n$ 是奇数，我们可以通过 `1` 操作来得到它，然后递归处理 $n-1$。

通过一系列操作，我们最终可以得到一个长度为 $1$ 的数列，且数列中的数字为 $n$。

我们可以采用递归的思路来生成操作序列。具体来说，我们可以从目标数字 $n$ 开始，逆向推导出如何通过 `1`、`dup` 和 `add` 操作得到这个数字。

**AC** ~~code~~


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,x=1,s=-1;
    bool f=1;
    cin>>n;
    cout<<1<<endl;
	while(x<n)
    {
		s+=bool(x&n);
		if(x&n) 
        {
            cout<<"dup"<<endl;
        }
		n-=n&x;
		x<<=1;
		if(x<=n)
        {
            cout<<"dup"<<endl;
            cout<<"add"<<endl;
        }
	}
	while((s--)>=0)
    {
            cout<<"add"<<endl;
    }
	return 0;
}
```

---

## 作者：getchar_unlocked (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B3753)

### 思路

首先将 $n$ 转为二进制，并遍历每一位。对于每一位，分类讨论：

- 若为奇数，需要翻倍后加 $1$，即 $\texttt{dup add 1 add}$。
- 若为偶数，需要翻倍，即 $\texttt{dup add}$。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}

int main(){
	int n=read();
	string bin="";
	while(n){
		bin=char(n&1)+bin;
		n>>=1;
	}
	printf("1\n");
	for(int i=1;i<bin.size();++i)
		if(bin[i])
			printf("dup\nadd\n1\nadd\n");
		else printf("dup\nadd\n");
	return 0;
}
```

---

## 作者：ZinfI_Sh (赞：1)

[题目链接](https://www.luogu.com.cn/problem/B3753)

根据题目样例很容易想到二进制拆分，即，首先对于一个数 $2^k$（$k\in \N$），只要先进行一次 `1` 操作，再进行 $k$ 次的 `dup-add` 操作。

所以有一种 $60$ 分做法，就是对 $n$ 进行二进制拆分，然后依次操作即可。

> ## 二进制拆分是什么？
>
> 因为任意非负整数都可以表示为一个二进制数，而二进制数的每一位都代表一个二的非负整数次幂，所以我们可以把任意一个非负整数分解成**若干个互不相同的二的非负整数次幂**。如：$25=16+8+1$。

但是这样操作，操作次数太多，所以我们要进行优化。

想到，比如我们要构造两个数字 $2^a$ 和 $2^b$，其中 $b>a$，我们先处理 $2^a$，那么 $2^b$ 就可以表示成 $2^a\times 2^{b-a}$，所以我们构造出一个需要的二的非负整数次幂后，可以进行操作 `dup-dup-add`，就可以大大缩短操作次数了。

# AC 代码

```
#include <bits/stdc++.h>
#define int long long
#define lowbit(x) (x & -x)
using namespace std;
const int DM[8][2] = {0, 1, 0, -1, 1, 0, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
const int HASHMOD = 9223372036854775783;
const int HASHBASE = 131;
const int HASHITEM = 999997;
int tot = 0, a[100001], k;
signed main()
{
    int n;
    cin >> n;
    int tmp = n;
    for (int i = 29; i >= 0; i--)
    {
        // cout << tmp << ' ' << (2 << i) << '\n';
        if (tmp - (1 << i) >= 0)
        {
            a[++k] = i;
            tmp -= (1 << i);
        }
    }//二进制拆分
    sort(a + 1, a + k + 1);//其实后面倒序枚举也行，这个排序无关紧要
    tmp = 1;
    cout << "1\n";
    for (int i = 1; i <= k; i++)
    {
        while ((1 << a[i]) != tmp)
        {
            cout << "dup\nadd\n";
            tmp *= 2;
        }
        if (i < k)
        {
            cout << "dup\ndup\nadd\n";
            tmp *= 2;
        }
    }
    for (int i = 1; i < k; i++)
    {
        cout << "add\n";
    }
    return 0;
}
```

---

## 作者：huangzhiyuanhzy (赞：0)

这道题目并不是很难，思路如下：通过一系列操作生成一个长度为 $1$ 的数列，并且数列中的数字恰好为给定的正整数 $n$，具体做法如下：

先初始状态，将数列设为空。再选择操作，我们可以通过 $1$ 操作将数字 $1$ 放入数列，通过 `dup` 操作复制数列尾部的数字，通过 `add` 操作将数列尾部的两个数字相加并放回数列。

对于给定的数字 $n$，如果 $n$ 是偶数，我们可以通过 `dup` 和 `add` 操作来得到它。如果 $n$ 是奇数，我们可以通过 $1$ 操作来得到它，然后递归处理 $n−1$。

所以，我们可以采用递归的思路来生成操作序列。具体来说，我们可以从目标数字 $n$ 开始，逆向推导出如何通过 $1$、`dup` 和 `add` 操作得到这个数字。

参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x=1,s=-1;
bool f=1;
int main(){
    cin>>n;
    cout<<1<<endl;
	while(x<n){
		s+=bool(x&n);
		if(x&n){
            cout<<"dup"<<endl;
        }
		n-=n&x;
		x<<=1;
		if(x<=n){
            cout<<"dup"<<endl;
            cout<<"add"<<endl;
        }
	}
	while((s--)>=0){
        cout<<"add"<<endl;
    }
	return 0;
}
``````

---

## 作者：abs20187 (赞：0)

首先这些操作可以归为两类：

1. +1，可以使目前的数加 1。相当于一次```1```和一次```add```。
2. *2，可以使目前的数乘 2。相当于一次```dup```和一次```add```。

因此我们可以使用倒推法，把输入的 $n$ 变为 $1$。
步骤如下：

如果 $n \ge 2$ 则：
   $$x = \begin{cases}
   add,1,add,dup,n\div2 (n\mod 2 \equiv1) \\
   add,dup,n\div2  (n\mod 2 \equiv0)
\end{cases}$$
否则：就一直```add```，```1```，$n\rArr n-1$ 直到 $n=1$。

最后倒序输出即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
string mp[10];
vector<int>a;
int main()
{
	int n;
	cin>>n;
	mp[1]="1";
	mp[2]="dup";
	mp[3]="add";
	//*2 dup add
	//+1 1 add
	while(n>=2)
	{
		if(n%2==1)
		{
		    a.push_back(3);
			a.push_back(1);
			a.push_back(3);
			a.push_back(2);
			
			n/=2;
			continue;
		 } 
		a.push_back(3);
		a.push_back(2);
		n/=2;
	 } 
	while(n>1)
	{
		a.push_back(3);
		a.push_back(1);
	}
	a.push_back(1);
	for(int i=a.size()-1;i>=0;i--)
	{
		cout<<mp[a[i]]<<"\n"; 
	}
	return 0;
}
```

---

## 作者：GZXUEXUE (赞：0)

### 思路

看到题目的图片之后容易发现我们可以很快地用 $2k (0 \le k)$ 步“制作”一个形如 $2^k$ 的数。  
进一步想，如果 $n$ 二进制下第 $i$ 位是 $1$，那么我们就应该快速用 `dup` 和 `add` 操作“制作”一个 $2^i$。这时可以想到有关快速幂的思想。  
我们定义一个函数 `qpow(int x)`，按照快速幂的思想来看，应该这样实现：  
1. 如果 $x = 1$，则直接用 `1` 操作制作即可；
2. 否则，应当先继续递归“制作”$\lfloor \dfrac{x}{2}\rfloor$，然后进行 `dup` 和 `add` 操作，就得到 $\lfloor \dfrac{x}{2}\rfloor \times 2$；
3. 如果 $n$ 是个奇数，就还要再操作一次 `1`。

然后 $n$ 就被“制作”出来了。~~啊哈哈哈哈哈哈鸡汤来喽！~~

时间复杂度为 $O(\log n)$。

### 实现

```cpp
# include <iostream>
using namespace std;
void qpow(int x){
	if (x == 1){ cout << "1\n"; return;	}
	else{ qpow(x >> 1); cout << "dup\nadd\n"; }
	if (x & 1) cout << "1\nadd\n";
}int main(){
	int n; cin >> n;
	qpow(n);
	return 0;
}
```

---


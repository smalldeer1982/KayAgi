# 【深基15.习9】验证栈序列

## 题目描述

给出两个序列 pushed 和 poped 两个序列，其取值从 1 到 $n(n\le100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 `Yes`，否则输出 `No`。请注意，给定的序列一定是一个**排列**（即没有重复数字）。

为了防止骗分，每个测试点有多组数据，不超过 $5$ 组。

## 样例 #1

### 输入

```
2
5
1 2 3 4 5
5 4 3 2 1
4
1 2 3 4
2 4 1 3```

### 输出

```
Yes
No```

# 题解

## 作者：Clear_yu (赞：370)

## 蒟蒻的第二篇题解~STL大法好


------------
~~在红题里找黄题做~~

------------
通过简单地阅读题目可知，对于给定的入栈序列 poshed~~话说为什么不是pushed，错字受~~，验证序列poped是否为入栈序列可能的一个出栈序列。

由于数据范围比较小(n≤100000)不会爆栈，那为什么不用STL来模拟呢（STL大法好！~~破音~~~）


------------
下面是最爱的代码


------------
```
#include<iostream>
#include<stack>
using namespace std;
stack<int>q;//栈q 
int p,n;//p组数据，n为序列长度 
int main()
{
	cin>>p;
	while(p--)
	{
		cin>>n;
		int a[n+1],b[n+1],sum=1;//入栈队列a，待检验队列b，计数器sum 
		for(int i=1;i<=n;i++)
		cin>>a[i];
		for(int i=1;i<=n;i++)
		cin>>b[i];//平平无奇的输入 
		for(int i=1;i<=n;i++)
		{
			q.push(a[i]);//入栈 
			while((q.top())==b[sum])//当栈顶元素与b中当前元素相同时出栈 
			{
				q.pop(),sum++;//sum++到b下一个元素 
				if(q.empty())break;//注意这里，第一次RE就因为当栈空时还用了出栈操作，所以要手动结束循环 
			}
		}
		if(q.empty()) cout<<"Yes"<<endl;//如果栈为空说明出栈序列b正确 
		else cout<<"No"<<endl;
		while(!q.empty())q.pop();//清空栈 
	}
	return 0;//谢幕 
}
```


------------
喜欢就点个赞吧！


---

## 作者：MY（一名蒟蒻） (赞：90)

### 手写是个好东西（当然STL库也可以）。
本题是想判断出栈序列是否成立，所以本蒟蒻用了离线操作。
## 此处简单介绍一下栈。
栈主要支持四种操作。

~~主要是作者只知道这4种。~~

1. 入栈（push（）） 
2. 是否栈空（empty（））
3. 访问栈顶（top（））
4. 出栈（pop（））

下文的top != 0 其实就是判断是否栈空。
#### 简单的栈模拟，解释详见代码

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <cstdlib>
#include <vector>
//这么多头文件实在煤必要,大家不要学这种蒟蒻。
using namespace std;
//定义栈，进栈数组，出栈数组。
int top,zhan[100010],n,jin[100010],chu[100010];
//对应STL库中的push操作，
void push(int x) {zhan[++top]=x;}
//pop操作。
void pop() {top--;}
int main()
{
	scanf("%d",&n);//读入。
	int len,js=1；
        //js是遍历出栈序列的变量，因为本蒟蒻的栈模拟push操作是++top，所以初始化js为1。
	for(int i=0;i<n;i++)//核心部分。
	{
		scanf("%d",&len);//输入访问序列长度。
                //读入不再多说。
		for(int j=1;j<=len;j++) scanf("%d",&jin[j]);
		for(int j=1;j<=len;j++) scanf("%d",&chu[j]);
		for(int j=1;j<=len;j++)
		{
			push(jin[j]);//进栈。
			while(zhan[top] == chu[js] && zhan[top] && chu[js]) {pop(); js++;}
		}//之所以用while循环，是因为可以简单直接的让相同元素出栈。
		if(top != 0) puts("No");//如果栈非空，失败。
		else puts("Yes");
        //初始化，进入下一轮访问。
		top=0;
		js=1;
	}
	return 0;
}
```
### ~~万恶的网课！~~
**不好意思，作者已被网课逼疯。**
## 管理员大大求过！

---

## 作者：a_bottle (赞：40)

真的用栈模拟就好了啊

从头开始，按入栈顺序入栈，如果栈顶与出栈序列的最前面的数相同，就将其弹出

最后将所有入栈的数都入栈后，判断栈中剩下的数与出栈序列中剩下的数顺序相同，就按照上面的方式依次弹出，直到无法弹出或栈为空

如果栈为空，则出栈序列是合法的，输出"Yes",不为空输出"No"
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int q;
	cin>>q;
	while(q--)
	{
		int n;
		int a[100001],b[100001];
		stack<int >st;
		cin>>n;
		for(int i=1;i<=n;i++)
		cin>>a[i];
		for(int i=1;i<=n;i++)
		cin>>b[i];
		int head=1;
		for(int i=1;i<=n;i++)
		{
			st.push(a[i]);
			while(st.top()==b[head])
			{
				st.pop();
				head++;
				if(st.empty())
				break;
			}
		}
		if(st.empty())
		cout<<"Yes"<<endl;
		else 
		cout<<"No"<<endl;
	}
}
```


---

## 作者：Mine_King (赞：36)

这题就是一道简单的栈模拟。  
我的思路是枚举出栈序列的数，如果这个数当前在栈外，那么就把她前面的都放到栈里，而这个元素则抹除掉（即加入再弹出）。那如果在栈里呢？很简单，在栈里，必须是栈顶。因为其他位置，都要先把上面的元素弹掉，这就和我们原来要求的序列违背，所以是不行的。  
很明显，这个想法是对的。

接下来就是代码方面。  

- 首先，是多组数据，所以记得初始化。
- 这里，由于要一一枚举入栈序列，需要一个k记录当前枚举到的位置。
- 当前元素在不在栈内是无法快速判断的，所以可以默认不在，然后如果枚举完了还是没有，那么就是在栈内。
- 但是栈顶元素是可以知道的，所以在这之前就可以把栈顶判断好了。
- 用函数判断会更方便。
- 判断完这个元素后，k记得+1哦。
- 记得判断栈为空的情况

搞定这些，就可以写代码啦！我的代码如下：
```cpp
#include<cstdio>
#include<stack>
using namespace std;
stack<int>s;
int t,n,psh[100005],pp[100005];
int k;
bool f()
{
	for(int i=1;i<=n;i++)
	{
		if(!s.empty()&&s.top()==pp[i])//注意判断栈是否为空，否则会RE。
		{
			s.pop();
			continue;
		}
		while(k<=n&&psh[k]!=pp[i])
			s.push(psh[k]),k++;//枚举
		if(k>n) return false;
		k++;//记得k+1哦！
	}
	return true;
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		k=1;//初始化k为1，即第一个要判断的
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&psh[i]);
		for(int i=1;i<=n;i++) scanf("%d",&pp[i]);
		while(!s.empty()) s.pop();//该操作就是在清空栈。
		if(f()) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```
[非常感谢您能看到这里！](https://www.luogu.com.cn/blog/yhdhg1395754790/)

---

## 作者：zjwwjhy (赞：21)

题目想必大家都看过了 ~~（废话）~~

为了验证出栈序列有可能是所给的“poped”，我们模拟一遍每个数的入栈出栈顺序，使它们出栈时变成为“poped”，如果中途模拟不下去了，就输出No，否则输出Yes


------------

؏؏☝ᖗ乛◡乛ᖘ☝؏؏ 很好，但是怎么模拟呢（有思路的童鞋们可以先想想）


------------


既然是验证栈序列，我们就需要一个辅助栈“stack”。（温馨提示：此处用数组模拟效果极佳）

除此之外我们还需要指向入栈序列和出栈序列的下标 i 和 j，都初始化为1（但是j我初始化成了0）

 ~~反正都一样~~

首先将入栈序列的第i个元素压到“stack”中，（在i和j均小于数组长度的情况下）

判断（注意用while判断，因为可能连续弹出）“stack”中的栈顶元素是否和出栈序列中的第j个元素一致（栈为空就不用判断了）如果一致则弹出栈顶元素，j++；如果不一致则继续压入入栈序列中的第i+1个元素。

继续判断栈顶元素是否和出栈序列中的第j个元素一致，直到i到达入栈序列的末尾。

最后如果“stack”为空或指针j到达出栈序列的末尾就输出Yes，否则输出No

然后就木有啦 ١١(❛ᴗ❛)
```
#include<bits/stdc++.h>
using namespace std;
#define gc getchar
inline int read(){
	int x=0;char ch=gc();bool positive=1;
	for (;!isdigit(ch);ch=gc())	if (ch=='-') positive=0;//快读不需解释 （其实不需要快读） 
	for (;isdigit(ch);ch=gc()) x=x*10+ch-'0';
	return positive?x:-x;
}
int t,nl[100010],n,nll[100010],zhan[100010],tot;//数组模拟栈（tot为栈顶指针） 
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++){//输入入栈序列 
			nl[i]=read();
		}
		for(int i=1;i<=n;i++){//输入出栈序列 
			nll[i]=read();
		}
		int j=0,tot=0;
		for(int i=1;i<=n;i++){//遍历 
			zhan[++tot]=nl[i];//将入栈序列的第i个元素压到“stack”中
			while(nll[j+1]==zhan[tot] && tot>0){//判断“stack”中的栈顶元素是否和出栈序列中的第j个元素一致 && 栈是否为空
				tot--;//如果一致则弹出栈顶元素
				j++;//j向后移（不一致则继续压入入栈序列中的第i+1个元素）
			}
		}
		if(tot==0) cout<<"Yes"<<endl;//最后如果“stack”为空（或指针j到达出栈序列的末尾）就输出Yes
		else cout<<"No"<<endl;//否则输出No
		/*
		if(j==n) cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
		*/
	}
	return 0;
}
```


---

## 作者：DreamFox (赞：17)

本题思路：

用数组模拟栈，刚开始把出栈序列的头设为$0$，并把$xx=1$。

模拟方法：

每次入栈一个数，然后用$while$循环判断，如果栈顶等于现有出队序列的第$head$个数，则出栈，并把$head$加$1$，直到把所有元素入栈。

入栈完后，如果$head$不等于$n$，则$xx=0$。

最后，如果$xx=0$则输出$No$，否则输出$Yes$

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100000],b[100000],c[100000];
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		for(int i=0;i<n;i++)
		scanf("%d",&a[i]);
		for(int i=0;i<n;i++)
		scanf("%d",&b[i]);
		bool xx=1;
		int put=0,in=0,ok=0;
		while(put!=n)
		{
			c[in]=a[ok];
			while(c[in]==b[put]&&put!=n&&in>=0)--in,++put;
			++in;++ok;
			if(ok==n&&put!=n)
			{
				xx=0; //如果入栈完了但出栈没完，那么把xx=0
				break;
			}
		}
		cout<<(xx==0?"No\n":"Yes\n"); //如果xx为1输出Yes，否则输出No
	}
	return 0;
}

```


---


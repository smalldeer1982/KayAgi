# 【模板】单调栈

## 题目背景

模板题，无背景。  

2019.12.12 更新数据，放宽时限，现在不再卡常了。

## 题目描述

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

## 说明/提示

【数据规模与约定】

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
5
1 4 2 3 5
```

### 输出

```
2 5 4 5 0
```

# 题解

## 作者：Mine_King (赞：322)

单调栈，就是一个栈，不过栈内元素保证单调性。即，栈内元素要么从小到大，要么从大到小。   
而单调栈维护的就是一个数前/后第一个大于/小于他的数。

例题：[P5788 【模板】单调栈](https://www.luogu.com.cn/problem/P5788)  
例题就是一个求每个数后第一个大于他的数。

那么重点来了：怎么做！面对这样的数据，不好下手。那么我们把她转化一下：有$n$个人，每个人向右看，求她看到的第一个人。  
看图：  
![](https://i.loli.net/2020/01/07/8LB6ZW5qg7m9y1c.png)  
通过观察，我们会发现，在她后面的，比她矮的，一定会被她遮住。那么，这个点就没用了。而根据现实生活和刚才的推断，我们看到的人肯定是一个比一个高的，而没看到的，留着也没用，直接扔了QwQ。那么，这就是符合单调性的。再看，那些没用的人什么时候扔掉？当然是遇到比她高的人了。那么就可以一个一个地走掉，而且肯定是在已经判断过的人的前面（中间和后面的在之前就走掉了），所以就直接从前面弹出。咦？这不就像一个栈吗？没错，这就是单调栈的实现方法。

再归纳一下：

- 从后往前扫
- 对于每个点：

  - 弹出栈顶比她小的元素
  - 此时栈顶就是答案
  - 加入这个元素

由于是从前往后输出，还要把答案放到一个数组里。

放代码：
```cpp
#include<cstdio>
#include<stack>
using namespace std;
int n,a[3000005],f[3000005];//a是需要判断的数组（即输入的数组），f是存储答案的数组
stack<int>s;//模拟用的栈
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=n;i>=1;i--)
	{
		while(!s.empty()&&a[s.top()]<=a[i]) s.pop();//弹出栈顶比当前数小的
		f[i]=s.empty()?0:s.top();//存储答案，由于没有比她大的要输出0，所以加了个三目运算
		s.push(i);//压入当前元素
	}
	for(int i=1;i<=n;i++) printf("%d ",f[i]);//输出
	return 0;
}
```
[完 结 辣！](https://www.luogu.com.cn/blog/yhdhg1395754790/)

---

## 作者：封禁用户 (赞：137)

## 前言

单调栈的模板题目，本人是手写单调栈。

## 单调栈

首先了解一下什么是单调栈吧！

单调栈就是使栈内元素单调递增或者单调递减的栈，单调栈也只能在栈顶操作。

我们先来模拟一遍吧！

做一个比喻，比方说：有个集训队招人，一个数代表了一个选手的能力值，先进来的选手年龄会比较大，后面的选手年龄比较小，但是这个集训队没有人数限制，那么如果遇到一个比你小还比你强的人那么准备退役吧。

比如有 5 个能力值分别是：

1 7 5 6 3

要加进来这个单调栈。

首先是 1 也就是 选手1 ，那么集训队没有人和他比较所以进入集训队。

单调栈的情况：1 。

然后是 7  也就是 选手2 ，那么我们可以发现，选手2 比 选手1 要小，并且 选手2 的能力比 选手1 要强，那么 选手1 留着也没啥用，淘汰！~~好残酷呀！~~

单调栈的情况：7 。

然后是 5 选手3 ，选手3 比 选手2 年龄要小，但是 选手3 的能力没有 选手2 强，那么 选手3 招进集训队。

单调栈的情况：7 5 。

那么接下来是 6 选手4 ，选手4 比 选手3 年龄要小，比他还要强， 选手3 淘汰！往后比较，发现 选手2 虽然比 选手4 要大，但是他能力很强！所以不会被淘汰，将 选手4 招进集训队。

单调栈的情况：7 6 。

最后是 3 选手5 ，选手5 比 选手4 要小，但是 选手4 的能力比 选手5 要强，所以 选手4 必定也比不过 选手2 ，但由于 选手5 小所以不淘汰他。

单调栈的情况：7 6 3 。

通过这个模拟我们发现，~~如果你很强，就算你年龄大也不会被淘汰~~，其实不是这样，在单调队列(比单调栈高级的东西)里面你就算再强也终究有时候会退役的，所以好好珍惜吧！

## 分析

刚刚解析完了单调栈，那么，现在开始分析一下这道题目吧！

这道题目就是说往右边看，找出第一个(能力)大于你的数(选手)。

不妨把它反过来，从最后一个开始入单调栈。

如果说没有比它小的那么就是输出 0 。

细节看代码吧！

## Code

```cpp
#include <iostream>
#include <cstdio>
#define INF 3000005
//头文件+预处理名。
using namespace std;
int n,a[Inf],q[INF],r,f[INF];
//定义变量，其中a数组表示输入的数，q数组表示存下标的单调栈，f数组是存结果。
int main() {
	scanf("%d",&n);
	for (int i=1; i<=n; i++) scanf("%d",&a[i]);
   //上面是读入。
	for (int i=n; i>=1; i--) {
    //从最后开始枚举。
		while (a[i]>=a[q[r]] && r>0) r--;
    //如果说它找到了比矮高的人并且不是最后，那么将那个矮的人弹掉，毕竟后面也不会有人看到它了，因为如果看到它的话那么必定可以看到比它前面的还比它高的。
		f[i]=q[r];
      //存结果，因为要正向输出。
		q[++r]=i;
     //将它入栈。
	}
	for (int i=1; i<=n; i++) printf("%d ",f[i]);
   //最后正着输出。
	return 0;
}
```

## 写在后面的话

我这篇题解如果有错误，那么请在评论区里留言，我将会很感谢反映的人。

最后，宣传一下我的两个blog [洛谷的](https://www.luogu.com.cn/blog/dgt/solution-p5788)，[自己的](https://cstdios.cf/uncategorized/solution-p5788/)，记得来玩哦！

**谢谢观赏！**

---

## 作者：pomelo_nene (赞：79)

update：2019/12/13

$\ \ \ \ \ \ \ $觉得写得有点不清楚，稍微改了一下语言以及添加一道例题。

update：2020/2/17

$\ \ \ \ \ \ \ $修改了一点错别字，改了一下内容和定义。造成的曲解抱歉了。修改了伪代码使其规范。修改了题解规范。

# 单调栈

## 前言

$\ \ \ \ \ \ \ $也是晚上突然看到新增加的模板。想着没学多久，想来发篇博客，熟悉一下。

## 感谢

[lucky52529的博客](https://blog.csdn.net/lucky52529/article/details/89155694)

## 定义

$\ \ \ \ \ \ \ $我们都知道单调队列，也就是在这个队列里面存放的数据应该是有序的。当然，单调栈从这个冷艳的名字就可以看出来，这个栈存放的数据内部对应的顺序也应该是有序的。

$\ \ \ \ \ \ \ $我们根据存放下标对应元素的顺序，可以分为两种单调栈：

- 单调递减栈，指的就是栈内存放下标对应元素构成的序列对应的元素单调递减。

- 单调递增栈，指的就是栈内存放下标对应元素构成的序列对应的元素单调递增。

$\ \ \ \ \ \ \ $**一定注意，我们存放的一般是下标，而不是元素。但是作为比较的标准是下标对应的元素**。

## 模拟

$\ \ \ \ \ \ \ $让我们模拟一遍单调栈的运行过程，这里的单调栈是单调递增栈。

$\ \ \ \ \ \ \ $我们现在有 $6$ 个数 $5,2,3,4,1,6$。

$\ \ \ \ \ \ \ $首先我们要明白，我们存放的是下标。然后，我们直接把元素放在栈顶，会破坏它的单调性。所以我们需要吐出栈顶的元素，使得我们当前的元素再加进去不会破坏它的单调性。

- 我们当前栈内没有元素，将 $5$ 加入。现在栈内元素应该是 $1$。

- 当前元素为 $2$，我们发现加入之后不能单调，于是吐出 $5$，加入 $2$。当前栈内元素为 $2$。

- 接下来是 $3,4$。我们发现加入不会破坏单调性，于是直接加入，栈内元素 $2,3,4$。

- 遇到 $1$，只能吐出栈内所有元素，加入 $1$。

- 最后加入 $6$。整个算法流程完成。

## 伪代码

$\ \ \ \ \ \ \ $我们可以根据这个算法流程，打出伪代码。

```cpp
stack<int> S;
for i←1 to n
	if S.size=0 || a[S.top]>=a[i]
		then	S.push i
	else
		while S.size && a[S.top]<a[i]
			do	S.pop
			end
		S.push i
```

$\ \ \ \ \ \ \ $我猜是这样，毕竟没学过伪代码。

## 杂七杂八的问题

$\ \ \ \ \ \ \ $对于我自己来说，我学的时候会有一些问题，在这里带着自己的经验解释一下。

1. 单调栈解决的主要问题是什么呢？

$\ \ \ \ \ \ \ $就跟单调队列差不多。单调队列主要处理的是一个区间内的最大/小值，而单调栈处理的是寻找以某个值为最小/大值的最大区间。相比较，实际上单调栈用的虽然少一些，但是比单调队列更加灵活多变。

2. 为什么单调栈是正确的呢？

$\ \ \ \ \ \ \ $对于这道题来说，我们定义一个元素失效，当且仅当这个元素的 $f_i$ 被保存。我们假设将栈中已有元素。既然栈中元素没有被弹出，那么证明还没有遇到比它大的元素。当我们的元素从栈中弹出的时候，这证明了它发现了第一个比它还要大的数，这道题刚好满足，于是保存 $f_i$ ，继续算法流程。同理，对于之前的主要问题，我们找到了一个比它还要大的数，说明这个区间结束了。

3. 单调栈的时间复杂度是？

$\ \ \ \ \ \ \ $想一下，我们的每一个元素最多进栈/出栈一次，所以说时间复杂度 $O(n)$。

$\ \ \ \ \ \ \ $**下文所说元素可能不是指的下标对应元素而是直接指元素，没有提示请不要混淆。**

## 结束标识符

$\ \ \ \ \ \ \ $对于某些特殊题目，栈内元素出不完，会导致答案错误，这时候我们要添加结束标识符强制吐出所有栈内元素。

$\ \ \ \ \ \ \ $找个例子：

### 视野总和

$\ \ \ \ \ \ \ $[lucky52529的博客](https://blog.csdn.net/lucky52529/article/details/89155694)，自查第一题。

$\ \ \ \ \ \ \ $我们很容易想到构造一个单调递增栈，如果遇到大于栈顶的元素，开始更新之前不高于当前人所能看到的值即可。

$\ \ \ \ \ \ \ $但是我们发现我们 WA 了，因为遗留在栈里面的人还没有计算贡献。我们于是用结束标识符，这里是极大值，想象一个无限高的人站在最右边，那么我们所有人都能出栈，不会漏掉。

#### 代码

```cpp
#include<cstdio>
#include<stack>
#include<algorithm>
#define mp make_pair
using namespace std;
stack<long long> S;
long long a[5000005],ans;
int main(){
	long long n;
	scanf("%lld",&n);
	for(long long i=1;i<=n;++i)	scanf("%lld",&a[i]);
	a[n+1]=10086001100860011ll;//结束标识符
	for(long long i=1;i<=n+1;++i)
	{
		if(S.empty() || a[S.top()]>=a[i])	S.push(i);
		else
		{
			while(S.size() && a[S.top()]<a[i])
			{
				long long Top=S.top();
				ans+=(i-Top-1);
				S.pop();
			}
			S.push(i);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

### 直方图中最大的矩形

$\ \ \ \ \ \ \ $[lucky52529的博客](https://blog.csdn.net/lucky52529/article/details/89155694)，自查第二题。

$\ \ \ \ \ \ \ $上面都是用的单调递增栈，这次我们用单调递减栈。我们每次将元素从栈里面弹出的时候，因为我们的答案可能会出现在里面，所以我们弹出元素就计算一遍答案。

#### 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<stack>
#include<queue>
using namespace std;
long long a[100005],n;
stack<long long> S;
void debug()
{
	stack<long long> tmp=S;
	while(tmp.size())	printf("%lld ",tmp.top()),tmp.pop();
	puts("");
}
void Clear()
{
	stack<long long> tmp;
	S=tmp;
}
int main(){
	while(scanf("%lld",&n) && n)
	{
		Clear();
		long long ans=0;
		for(long long i=1;i<=n;++i)	scanf("%lld",&a[i]);
		a[n+1]=-2147483647;
		for(long long i=1;i<=n+1;++i)
		{
			if(S.empty() || a[S.top()]<=a[i])	S.push(i);
			else
			{
				long long Top=0;
				while(S.size() && a[S.top()]>a[i])
				{
//					debug();
					Top=S.top();
					ans=max(ans,(i-Top)*a[Top]);
					S.pop();
				}
				a[Top]=a[i];//why?
				S.push(Top);
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

$\ \ \ \ \ \ \ $发现我在 `a[Top]=a[i];` 这个语句后打了个 `//why?`。这是为什么呢？

$\ \ \ \ \ \ \ $我们弹出元素计算答案，相信大家都能够理解。但是为什么要更改我们的 $a$ 数组呢？

$\ \ \ \ \ \ \ $举个例子：$2,3,1$。

$\ \ \ \ \ \ \ $思考一下，我们要维持它单调，假设加入 $3$ 这个元素的时候栈只有它一个元素。我们的 $top$ 会从 $1$ 变成 $3$。但是 $1,2$ 两个元素对应的值都比它大。但是我们为了保持栈中的递增属性，并且可以让向左拓展，我们索性修改了 $i$ 的下标，将他修改为最左边的 $top$ 下标，所以当我们下次需要以他为基准获取矩形面积。

### 题解

$\ \ \ \ \ \ \ $对于这道题，我们构造一个单调递增栈，我们可以想象，我们每次出栈，都是因为找到了一个比当前栈顶元素大的元素，可以证明它一定是最早出现的，于是用数组记录答案，每次出栈保存答案。注意卡常。

```cpp
#include<cstdio>
int a[3000005],f[3000005],S[3000005],n;
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0' || c>'9')
	{
		if(c=='-')	f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x*f;
}
void write(int x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
int main(){
	n=read();
	for(int i=1;i<=n;++i)	a[i]=read();
	int top=0;//用数组模拟栈，不然会T
	for(int i=1;i<=n;++i)
	{
		while(top && !(a[S[top]]>=a[i]))	f[S[top--]]=i;//我们发现直接加入会破坏单调性，于是弹出栈顶元素，顺便计算当前元素的答案
		S[++top]=i;
	}
	for(int i=1;i<=n;++i)	write(f[i]),putchar(' ');
	return 0;
}
```

## 例题

$\ \ \ \ \ \ \ $[AT1225](https://www.luogu.com.cn/problem/AT1225)，CDQ分治套单调栈，较难。

$\ \ \ \ \ \ \ $[lucky52529的博客](https://blog.csdn.net/lucky52529/article/details/89155694)，自查第三题。

---

## 作者：phigy (赞：27)

单调栈是一种数据结构，相对而言是比较简单的数据结构

比普通栈多一个条件就是要保证栈内元素有序

分递增和递减

#### 举个例子：

现在有几个数：5，3，8，5，4，2

从左往右依次入单调递减栈

- 栈空，5直接入栈，栈：5

- 栈顶元素 5 > 3，3 入栈，栈：3，5

- 栈顶元素 3 < 8 ,将3弹出，栈顶元素 5 < 8 , 将5弹出，栈空，8直接入栈，栈：8

以此类推，试着自己写一下，接下来是：

- 5 ，8

- 4 ，5 ，8

- 2 ，4 ，5 ，8
-----
每一次入栈的过程:
```cpp
while(栈顶元素比入栈元素小 且 栈不空)
{
    栈顶元素弹出
}
元素入栈
```

如何解决这道题呢？

题目要求求每个数**后面第一个比他大**的数

我们可以构造一个单调递减的单调栈

当一个数被弹出，将要进栈的数就是$f($要弹出的数$)$

如果一直没被弹出，f值就为0

伪主要代码：
```cpp


for(遍历整个数组)
{
    while(栈顶元素比入栈元素小 且 栈不空)
    {
        f[栈顶元素下标]=入栈元素;
        栈顶元素弹出;
    }
    元素入栈;
}
while(栈不空)
{
    f[栈顶元素下标]=0;
    栈顶元素弹出;
}
for(遍历答案数组)
{
    输出;
}

```

其中有个地方就是要把元素和下标联系起来

所以建一个结构体

伪代码：
```cpp
struct 数与下表
{
    数，下标
}输入数组;
```

---

接下来推荐去做一做：[滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)

## 感谢管理员审核！！！

---

## 作者：king_xbz (赞：11)

最近做题时遇到了几道单调栈的题，偶然发现了洛谷还有这个板子，于是就过来水一波。

仔细翻阅了10篇已有的题解，发现大多是用手写栈或者一个stl栈+数组写的；

既然这是一道栈的模板题，那就很有必要用充满栈味儿的做法来做。

因为单调栈的处理需要倒序，即
```cpp
for(int i=n;i>=1;i--)
```
而输出的时候需要正序输出，这恰好符合先进后出的栈的特性，所以我就想到用两个STL的栈来解决。

定义双栈：
```cpp
stack <int>q;//单调栈
stack <int>s;//数组下标栈
int a[p];//a[数组]表示我们输入的项数为n的整数数列
```
处理q栈的单调性与在s栈中存数组下标我们只要一个for循环即可搞定
```cpp
for(fint i=n;i>=1;i--)
{
	while(!q.empty()&&a[q.top()]<=a[i])//若不符合单调性就一直弹出
		q.pop();
	s.push(q.empty()?0:q.top());//如果没有第i个元素之后第一个大于a[i]的元素的下标那么0进栈，否则该下标进栈。
	q.push(i);//下一个元素进入q栈
}
```
这样的话函数主体就已经完成了。

最后，上完整代码：
```cpp
#include<bits/stdc++.h>
#define p 3000009
#define fint register int
using namespace std;
stack <int>q;
stack <int>s;
int a[p];
inline int read();
signed main()
{
	int n;
	n=read();
	for(fint i=1;i<=n;i++)
	a[i]=read();
	for(fint i=n;i>=1;i--)
	{
		while(!q.empty()&&a[q.top()]<=a[i])
			q.pop();
		s.push(q.empty()?0:q.top());
		q.push(i);
	}
	while(!s.empty())
	cout<<s.top()<<" ",s.pop();
	return 0;
}

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
```
特别提醒，该题数据不是很毒瘤，int即可过，无需long long，如果TLE，可以尝试用scanf，printf或者快读快输代替cin cout

祝大家ac愉快！

---

## 作者：LCuter (赞：8)

猜了下单调栈的定义，然后发现有很好的性质，口胡了一个做法，结果居然过了……

## $\text{Description}$

给定 $\{a_n\}$，求 $\forall i\in [1,n],\min_{j>i,a_j>a_i}\{j\}$。

## $\text{Solution}$

有一个很显然的 $O(n^2)$ 的暴力，但是复杂度过高，考虑找性质优化。

先说一个结论：

- 一个数只可能成为是原序列的**单调不升子序列**中的数的答案

只需用反证法证明即可。

这启发我们按 $1-n$ 枚举(下文所说的当前位置是枚举到的位置)，维护一个单调不升的序列，每次判断序列末尾的值是否小于当前值，若小于，则当前位置是序列末尾的答案，更新答案后删除，若大于，则停止判断，因为当前位置不可能成为前面的数的答案了，然后把它加入序列。

我们发现所做的操作类似与栈，便将上述算法称为单调栈，我们所做的就是维护一个单调不升的栈。

注意到每个元素至多被出栈入栈一次，故时间复杂度为 $O(n)$。

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
#define REG register
#define MAXN 3000005
using namespace std;
inline int read(){
    REG int x(0);
    REG char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x*10)+(c^48),c=getchar();
    return x;
}

int n;

int a[MAXN],Mysta[MAXN],ans[MAXN],top;

int main(){
    n=read();
    for(REG int i=1;i<=n;++i) a[i]=read();
    for(REG int i=1;i<=n;++i){
        while(top&&a[Mysta[top]]<a[i]) ans[Mysta[top]]=i,--top;
        Mysta[++top]=i;
    }
    for(REG int i=1;i<=n;++i) printf("%d ",ans[i]);
}
```

---

## 作者：linponess (赞：5)

### **关于单调栈：**
相信对于栈大家应该很了解，就是一个先进后出的线性数据结构，可以在栈顶进行压入和弹出操作，在这里不过多陈述。

至于单调栈，可以很好地从字面意思上看出这是一个自栈底至栈顶增减性单调的一个栈，在这里简单讲一下代码的实现：

如果要在栈顶压入一个常数$x$，若压入$x$不会对栈的单调性造成改变，那么就直接将$x$按普通栈的方法压入，否则便在栈顶持续弹出栈内元素直至压入$x$符合栈的单调性。

**代码：**
```cpp
//向一个单调递增的栈内压入n个元素。 
//stack为单调栈，t为栈顶。
int stack[3333333],t,x,n;
for(int i=1;i<=n;i++)
{
	scanf("%d",&x);
	while(sta[t]>x)
	t--;
	stack[++t]=x;
}
```

------------

### **关于本题：**
题意要求分别求出数列中第$i$个元素之后第一个大于$a_i$的元素的下标，根据标题可以联想到将数列元素压入单调栈，第一个在压入时将$i$弹出的元素就是第$i$个元素之后第一个大于$a_i$的元素。

所以很明显可以用单调栈来解决本题。

但题意要求按**下标顺序**输出答案，而单调栈弹出的元素是无序的，下标小的也可能后弹出，如何解决下标问题？

我们可以再开一个标记数组来记录栈底至栈顶元素的下标，在弹出时取出标记数组内对应元素的下标，按下标顺序将答案存入答案数组中。

如果说还有什么问题的话，就是这道题它~~卡常~~曾经卡常。

**代码：**
```cpp
#include<cstdio>
using namespace std;
int sta[3333333],t,n,a,ans[3333333],num[3333333];//sta为单调栈，t为栈顶，ans为答案数组，num为标记数组，a,n如题意所述。 
int read()
{
	int res=0;
	char c;
	c=getchar();
	while(c<'0'||c>'9')
	c=getchar();
	while(c>='0'&&c<='9')
	{
		res=res*10+c-48;
		c=getchar();
	}
	return res;
}
void write(int x)
{
	if(x>9)
	write(x/10);
	putchar(x%10+48);
}//快读快输，但因为本题现在不卡常了，所以也没什么用了，略过即可。 
int main()
{
	n=read();
	sta[0]=1234567890;//因为是单调递减的栈，所以要在栈底压入一个极大值，以确保栈为空时一定能压入元素。 
	for(int i=1;i<=n;i++)
	{
		a=read();
		while(sta[t]<a)//将所有不符合单调性的元素弹出栈。 
		{
			ans[num[t]]=i;//按照被弹出元素的下标将第一个大于a[i]的元素的下标记入答案数组。 
			t--;
		}
		sta[++t]=a;//入栈。 
		num[t]=i;//记录栈内元素的下标。 
	}
	for(int i=1;i<=n;i++)//因为答案数组的初始值为零，所以留在栈内的元素，即不存在大于a[i]的元素的答案一定为零。 
	{
		write(ans[i]);
		putchar(' ');
	}
	return 0;
}
```


------------
### **关于更多例题：**
[[USACO06NOV]糟糕的一天Bad Hair Day](https://www.luogu.com.cn/problem/P2866)，即P2866。

很模板化的USACO题，只需要在计数方面做一点小改动即可。

~~甚么？你还是不会做？那边有题解，不要来问我~~~~


---

## 作者：wenye05 (赞：5)

# 伪单调栈

~~因为看了题解后发现小蒟蒻的栈和其他dalao的单调栈不太一样qwq~~

~~但竟能AC！~~

注：这种做法应该并不能保证出栈顺序的单调性。

## 思路

保持栈内元素单调不升，从前往后依次将元素（这里元素不是指下标）与栈中元素比较，弹出更小的元素的同时更新该元素的f，即该元素之后第一个大于该元素的元素的下标，直到遇见更大的元素为止，然后入栈，也就确保了栈中元素的单调不升的性质。

~~好绕~~

我们跟踪一个元素，此时栈中元素单调不升，也就是说每个元素还没有找到更大的元素，而它们如果找到了的话说明在我们跟踪的这个元素之前就有元素干掉了这些小元素，而这些小元素的f也就定了。

我们依次让跟踪的这个元素与栈顶元素比较，当然，栈中元素在数列中是在前面的，如果跟踪的这个元素更大，说明这个栈顶元素可以退役了，于是更新它的f并抛弃它，以此类推，直到接下来遇到更为强大的元素，说明栈中下面的元素可能一个比一个强，不屑于与自己配对，于是安歇下来，入栈。

如果这个元素是在过于强大，打败了栈中所有元素，弹出栈中元素后要把它入栈（谁知道接下来有没有更强大的）。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define N 3000005

struct element{
	int v,id;
	//v存元素大小，id存元素下标 
};

int n,f[N];
stack<element>s; 

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)//i也可以看作下标
	{
		int a;
		scanf("%d",&a);//下一个元素
		while(!s.empty())//需要特判，如果为空，取top要有问题
		{
			element p=s.top();
			if(a>p.v)//如果大于，抛弃它
			{
				f[p.id]=i;
				s.pop();
			}
			else//遇到更强大的，就跳出循环，入栈
			{
				break;
                //超强元素则不会进入这里
			}
		}
        
        //入栈操作
		element k;
		k.v=a;
		k.id=i;
		s.push(k);
        //第一个元素，或者超强元素使栈中变空，也是要入栈的
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d ",f[i]);
        //output
	}
	return 0;
}
```

---

## 作者：さらばだ (赞：4)

本题我的解决思路如下：

1.设置一个栈$s$，$s$的每一个元素是一个点对，分别表示该元素的值$key$和在原序列中的序号$id$。以及用于存储序列的数组$a$,答案数组$ans$。

2.顺序扫描$a$，如果$a[i]$不大于栈顶元素，直接入栈；如果$a[i]$大于栈顶元素，则$a[i]$是第一个大于栈顶元素的值，$ans[s[p].id]=i$。即$f(s[p].id)=i$.

3.最后扫描完毕,依然留在栈中的元素，其$f(i)=0$。

代码如下：

```cpp
#include<cstdio>
#include<stack>
#include<iostream>
#include<algorithm>
using namespace std;

const int maxn = 3e6 + 5;
struct node//栈中结点
{
    int key;//栈中结点的值
    int id;//栈中结点在输入数列中的序号
};
node s[maxn];//建立一个栈
int p;//栈指针
int ans[maxn];//存储答案的数组
int n;//数列长度
int a[maxn];//存储输入的数列
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
    }
    s[0].key = 0x3f3f3f3f;//设置栈中第0个结点值为inf，便于第一个数直接进栈
    for (int i = 1; i <= n;i++)
    {
        if(a[i]<=s[p].key)//如果当前值不比栈顶值大，则将当前值进栈
        {
            node Node;
            Node.key = a[i];
            Node.id = i;
            s[++p] = Node;
        }
        else//当前值比栈顶值大，当前值的序号i即位第一个大于栈顶值元素的下标
        {
            node tmp = s[p];
            ans[tmp.id] = i;//f(s[p].id)=i
            p--;//出栈
            i--;//当前元素重新尝试入栈
        }
    }
    if(p!=0)//栈不空，则栈中的元素找不到合适的f(i)，结果全部赋值为0
    {
        for (int i = p; i > 0;i--)
        {
            node tmp = s[i];
            ans[tmp.id] = 0;
        }
    }
    for (int i = 1; i < n;i++)
    {
        printf("%d ", ans[i]);
    }
    printf("%d\n", ans[n]);
}
```



---


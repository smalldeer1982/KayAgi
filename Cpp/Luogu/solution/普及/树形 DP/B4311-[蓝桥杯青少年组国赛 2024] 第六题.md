# [蓝桥杯青少年组国赛 2024] 第六题

## 题目描述

某城市的道路构成了一个巨大的树形结构，每一条道路可视为该结构的一条边，而道路的交叉点或端点视为其中的一个节点。该城市共有 $n$ 个节点，编号分别为 $1, 2, 3, \ldots, n$。

为了实时记录道路情况，需要在某些节点部署监控设备。当部署好后，与该节点直接相连的所有道路均能被监控到。为了优化资源分配，在保证整座城市的所有道路都被监控到的前提下，部署监控设备的费用要尽可能少。给定每个节点部署监控设备的费用，请计算要使所有道路都能被监控到的最少花费是多少？

## 样例 #1

### 输入

```
8
33 12 30 22 18 10 31 28
1 2
1 3
2 4
2 5
2 6
3 7
3 8```

### 输出

```
42```

# 题解

## 作者：guoshengyu1231 (赞：2)

# 思路
这题其实并不难，就是一道裸的树形 dp，只要你懂树形 dp，这题分分钟就能做出来。但在这里我还是简单讲一下树形 dp 吧。

 $\\$ 
树形 dp，顾名思义就是在树上执行的 dp，也就是通过儿子的状态来推断出父亲的状态。好了，讲完了。是的，你没听错，树形 dp 其实非常简单，除了是在树上做，其他的和普通的 dp 没啥两样。所以最主要的还是如何去设计状态。

 $\\$ 
回归原题，我们知道整个城市的所有道路组成了**一颗树**，在树的结点中，我们可以在某些结点布置监控。当其中一个节点被布置了监控，他就可以侦察与之相连的道路。而在第 $i$ 个结点布置监控需要花费 $a_i$ 的费用。问**最少**需要多少费用才能侦察所有道路。

 $\\$ 
从“一棵树”、“最少”这些词中，我们可以很容易联想到树形 dp。既然是 dp，那三要素可不能少。
## 1.状态
我们可以知道每个结点要么装监控，要么不装。故设 $dp_{u,0}$ 为结点 $u$ 不安装监控时以 $u$ 为根节点的子树需要的最少费用。设 $dp_{u,1}$ 为结点 $u$ 安装监控时以 $u$ 为根节点的子树需要的最少费用。
## 2.边界
边界其实很简单，这里一笔带过。对于任意 $i$，$dp_{i,1}=a_i$。
## 3.转移
当自己选择不安装监控，那必须得让他的所有儿子安装监控。 $\\$ 
转移方程：
 $$ dp_{u,0}=\sum dp_{v,1}$$ 
当自己选择安装监控，那他的儿子可以安装监控，也可以不安装，取最小花费即可。 $\\$ 
转移方程：
 $$ dp_{u,1}=\sum \min(dp_{v,1},dp_{v,0})$$  
其中 $v$ 是 $u$ 的其中一个儿子。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int> g[20005];
int dp[20005][2];
void dfs(int u,int f)
{
    for(int v:g[u])
    {
        if(v==f) continue;
        dfs(v,u);
        dp[u][0]+=dp[v][1];
        dp[u][1]+=min(dp[v][0],dp[v][1]);
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>dp[i][1];
    for(int i=1;i<n;i++)
     {
         int x,y;
         cin>>x>>y;
         g[x].push_back(y);
         g[y].push_back(x);
     }
    dfs(1,0);
    cout<<min(dp[1][1],dp[1][0]); 
    return 0;
}    
```

---

## 作者：wnqnld_llx (赞：1)

## 题目描述
如题不想多说，题目已经描述的很简单了。
## 问题转换
既然这是一个树形的关系，那么我们就将这些部门转换为一棵树，而费用就是每个节点的权值。
然后考虑题目的要求。这里一定要注意，监控的是边而不是节点，一开始就是这里卡了我很久。对于每个节点，它有选和不选两个情况，所以我们的动归数组就要开二维。设 $f_{i,j}$ 表示以 $i$ 为根节点的子树选取的最小花费。$j=1$ 表示选，$j=0$ 表示不选。

下面我们设 $i$ 为当前考虑的节点，$son$ 为它的相邻节点。
- 如果我们不选 $i$ 这个节点，那么与它相邻的节点一定要选。这个应该是挺容易理解的。因为如果 $i$ 不选，那么于他相邻的几条边都无法得到它的监视，这是如果它的这几条边的另外一个节点，即 $son$ 还不选，那么这条边就无法被监视。所以我们推出动态转移方程 $f_{i,0}=\sum f_{son,1}$。
- 如果选，根据上文，容易得出它的子节点选不选都可以。$f_{i,1}=\sum\min({f_{son,1},f_{son,0}})$。
## 实现过程
用 vector 存储这棵树，用深度优先搜索遍历它，返回时更新答案。注意，由于本题是无向图，所以双向存边，在遍历时为了防止在两个点来回走出不去，要记录一下它的父亲，在代码中有体现。
### code

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int maxn=1e4+10;
int n,w[maxn],f[maxn][2],flag[maxn];
vector <int> tr[maxn];
void dfs(int u,int fa){
    f[u][1]=w[u];
    for(auto son:tr[u]){
    	if(son==fa) continue;//就是这里。
        dfs(son,u);
        f[u][1]+=min(f[son][0],f[son][1]);
        f[u][0]+=f[son][1];
    }
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>w[i];
    }
    for(int i=1;i<n;i++){
        int a,b;
        cin>>a>>b;
        tr[a].push_back(b);
        tr[b].push_back(a);
    }
    dfs(1,0);
    cout<<min(f[1][1],f[1][0]);
    return 0;//完结撒花。
}
```

---

## 作者：cjx_AK (赞：1)

乘着刷树形 dp，来水一波题解。

### 思路
用什么算法呢？标签里说了，题目里也提示了，树形 dp 毋庸置疑。

既然是 dp，总得定义状态吧。显然，这与背包 dp 类似，每个点有取与不取两种状态。

不妨设 $f[i][0]$ 为第 $i$ 号点没取的最小花费，$f[i][1]$ 为第 $i$ 号点取了的最小花费。

$i$ 号点的状态只与它的孩子有关，若它不取，则他孩子必须取，反之其孩子可取可不取。

状态转移方程：

$f[x][0]=f[x][0]+f[y][1]$ 和：$f[x][1]=f[x][1]+\min(f[y][0],f[y][1])$。 

最后输出根节点的答案即可。

oops！我们忘了初始化！

当前这个节点的值若我们没有算过，就默认他取了。

然后你就切了一道黄题。

code：

```
#include<bits/stdc++.h>
#define int long long
const int N=2e5+20;
using namespace std;
int n,f[N][3],a[N];
vector<int>ed[N];
void DP(int x,int father){
	  for(auto y:ed[x]){
		  if(y!=father){
			  DP(y,x);
			  f[x][0]=f[x][0]+f[y][1];
			  f[x][1]+=min(f[y][0],f[y][1]);
		  }
	  }
}
signed main(){
   scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%lld%lld",&u,&v);
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		f[i][1]=a[i];
	}
	DP(1,0);
	printf("%lld",min(f[1][0],f[1][1]));
	return 0;
}
```

支持壶关，忘了私信！

---

## 作者：wyyinput (赞：1)

## 思路
“某城市的道路构成了一个巨大的树形结构”，这就提示我们往树上想。从后文大概可以看出这是一道 DP，结合要往树上想，这题就是一道树形 DP。如果你是大佬，一眼就看出这是树形 DP，就当我没说。

## 状态定义
有了大致方向，不难想到两种状态：$u$ 点装了监控；$u$ 点没装监控。那么定义就出来了：  

$f[u][0]$：$u$ 点没装监控的最小花费；  
$f[u][1]$：$u$ 点装了监控的最小花费。

## 初始化
每个点单独装监控的花费是每个结点的花费（$a[i]$），所以对于每个点 $i$，$f[i][1]$ 的值等于 $a[i]$。

## 状态转移
我们由叶子往根（1号点）推。$v$ 是 $u$ 的儿子，分两种情况：

当 $u$ 不装监控时，$u$ 点到 $v$ 点的道路必须被 $v$ 监视，所以 $f[u][0]$ 要加上 $f[v][1]$。

当 $u$ 装监控时，$u$ 点到 $v$ 点的道路可以（不强制）被 $v$ 监视，所以 $f[u][0]$ 要加上 $f[v][0]$ 和 $f[v][1]$ 的较小值。

那么答案就是 $f[1][0]$ 和 $f[1][1]$ 的较小值。

## 代码
说了那么多，代码就已经出来了。边是双向边。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+1;
int n,f[N][2],head[N],cnt,u,v,k,a[N];
struct edge{
	int to,ne;
}bian[2*N];
void add(int u,int v){
	bian[++cnt]={v,head[u]};
	head[u]=cnt;
	return;
}
void dfs(int u,int fa){
    int v;
	for(int i=head[u];i;i=bian[i].ne){
        v=bian[i].to;
		if(v==fa)
			continue;
		dfs(v,u);
		f[u][0]+=f[v][1];
		f[u][1]+=min(f[v][0],f[v][1]);
	}
	return;
}
int main(){
	scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",a+i),f[i][1]=a[i];
	for(int i=1;i<n;i++){
        scanf("%d%d",&u,&v);
        add(u,v);
        add(v,u);
	}
	dfs(1,0);
	printf("%d\n",min(f[1][0],f[1][1]));
	return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

主要是设计状态，直接设计状态为 $f_{i,0/1}$，表示在当前 $i$ 的子树中，当前节点放或不放监控设备的最少放置代价，剩下的转移就非常明显了，如果当前节点放监控设备，那么必定这条边就不一定要在另一边也配置一个监控设备（如果放置也可以，可以通过构造来 hack），否则就是不放监控设备，自然就必须在另外一个节点放置一个监控设备，所以没有决策，直接加上去，得出转移式 `v[x].d[0] += v[i].d[1], v[x].d[1] += min(v[i].d[0], v[i].d[1])`，注意 `v[i].d[1]` 初始化为 $a_i$（当前放的代价）。

代码给出：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 10001;

struct V {
  vector<int> e;
  int d[2];
} v[kMaxN];
int n;

void S(int f, int x) {
  for (int i : v[x].e) {
    if (i != f) {
      S(x, i);
      v[x].d[0] += v[i].d[1], v[x].d[1] += min(v[i].d[0], v[i].d[1]);
    }
  }
}

int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> v[i].d[1];
  }
  for (int i = 1, x, y; i < n; i++) {
    cin >> x >> y;
    v[x].e.emplace_back(y), v[y].e.emplace_back(x);
  }
  S(0, 1);
  cout << min(v[1].d[0], v[1].d[1]) << '\n';
  return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

考虑树形 DP。为方便，钦定 $1$ 号节点为数的根。设 $dp_{i,0}$ 表示 $i$ 不放监控，以 $i$ 为根的树满足条件的最小代价。$dp_{i,0}$ 表示 $i$ 放监控，以 $i$ 为根的树满足条件的最小代价。于是递归求解。处理 $i$ 的儿子节点 $j$ 时，状态转移方程为： 

$dp_{i,0}=dp_{i,0}+dp_{j,1}$

$dp_{i,1}=dp_{i,1}+\min(dp_{j,0},dp_{j,1})$

也就是说，如果 $i$ 不放监控，那 $i$ 的所有儿子节点都要放监控。如果 $i$ 放监控，那 $i$ 的儿子节点可以放监控，也可以不放。

注意所有的 $dp_{i,1}$ 都要初始化成 $i$ 号节点的部署费用。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[10005],dp[10005][2];
vector<int> v[10005];
void dg(int t,int fa)
{
	for(auto x:v[t])
	{
		if(x==fa) continue;
		dg(x,t);
		dp[t][0]+=dp[x][1];
		dp[t][1]+=min(dp[x][0],dp[x][1]);
	}
}
signed main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],dp[i][1]=a[i];
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dg(1,0);
	cout<<min(dp[1][0],dp[1][1]);
    return 0;
}
```

---

## 作者：LG086 (赞：0)

树形 dp。

给你一个 $a$ 个节点的树形图，需要在节点上搞监控设备，监控所有边，求最小花费。

对于每个节点 $i$，要么在 $i$ 上有一个监控，要么 $i$ 上没有监控。  
我们于是用 $f_{i,op}$ 表示在以 $i$ 为根结点的子树中装监控的最小花费。其中 $0\le op\le 1$，若 $op = 1$ 即表示我们在 $i$ 上装监控，否则表示我们不在 $i$ 上装监控。

在节点 $i$ 装监控的花费是 $h_i$，所以初始化每个 $n_{i,1} = h_i,n_{i,0} = 0$。

假设有如下图的树。

![](https://cdn.luogu.com.cn/upload/image_hosting/ciuxtbnr.png)

我们发现，若在红色节点装监控，则它周围的 $5$ 条路都会被监控到。此时它的所有子节点上可以装监控，也可以不装。

若红色节点不装监控（如下图所示），则它的所有子节点都必须装监控才可以监控到红色节点周围的道路。

![](https://cdn.luogu.com.cn/upload/image_hosting/hpziukwm.png)

所以我们得到转移方程是：

$$
n_{i,0} = \sum n_{son,1}\\
n_{i,1} = \sum \min(n_{son,1},n_{son,0})
$$

我们默认 $1$ 是根节点。  
dfs 从节点 $1$ 开始遍历树，同时更新 $n$ 数组。最后输出 $\min(n_{1,0},n_{1,1})$ 即可。

核心代码：

```cpp
void dfs(int now,int f){
 for(int x:v[now])
  if(x!=f)
   dfs(x,now),
   n[now][0]+=n[x][1],
   n[now][1]+=min(n[x][0],n[x][1]);
 return ;
}
```

---

## 作者：zhouxuanhong (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4311)

## 思路

树 D 裸题。

我们可以定义 $dp_{i,0}$ 为在 i 节点不放置监控使 i 的子树均被监控的开销，$dp_{i,1}$ 为在 i 节点放置监控使 i 的子树均被监控的开销，$dp_{i,0}$ 这部分包含令 $i$ 的子树也被监控的开销，设 $i$ 的子树为 $son$，由定义得，这部分的转移为：

$$
dp_{i,0}=\sum dp_{son,1}
$$

同理，由定义得，$dp_{i,1}$ 这一部分包含令 $i$ 的子树也被监控的开销加上自己被监控的开销，转移为：

$$
dp_{i,1}=a_{i}+\sum \min(dp_{son,0},dp_{son,1})
$$

答案就在根上。

## 代码

```cpp
#include<map>
#include<iostream>
#include<algorithm>
#include<vector>
#include<bitset>
using namespace std;
int cnt=0,dp[10005][2],a[10005],root=0;
bitset<10005> f;
vector<int> w[10005];
void dfs(int x,int fa){
	dp[x][0]=0;dp[x][1]=a[x];
	for(int to:w[x]){
		if(to==fa)continue;
		dfs(to,x);
		dp[x][0]+=dp[to][1];
		dp[x][1]+=min(dp[to][0],dp[to][1]);
	}
}
int main(){
	int n,p,s;
	cin>>n; 
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;++i){
		cin>>p>>s;
		w[p].push_back(s);
		w[s].push_back(p);
		f[s]=1;
	}
	for(int i=1;i<=n;i++){
		if(!f[i]){
			root=i;
			break;
		}
	}
	dfs(root,0);
	cout<<min(dp[root][0],dp[root][1]);
	return 0;
}
```

---

## 作者：TJB_LHY (赞：0)

# 思路

[题目传送门](https://www.luogu.com.cn/problem/B4311)  [双倍经验](https://www.luogu.com.cn/problem/P2016)

这是一道树形 DP 题，大意就是在一棵树中选一些节点，这些点可以监控相邻的节点，问监控所有点最少花费。我们不妨先将节点 $1$ 标为根，设 $dp_{0,x}$ 为不选该节点的最少花费，初始值为 $0$；$dp_{1,x}$ 为选该节点的最少花费，初始值为在该点建造监控的费用。很容易发现：如果选择监控该点，其子节点可以选也可以不选；如果选择不监控该点，其子节点就必须选了。跑一遍 dp，再输出 $\min(dp_{1,1},dp_{0,1})$ 即可。

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
vector<int>G[10005];//存图
int n,a[10005],x,y,dp[2][10005];
void dfs(int u){
    int v;
    dp[1][u]=a[u];//选
    dp[0][u]=0;//不选
    for(int i=0;i<G[u].size();i++){
        v=G[u][i];
        dfs(v);
        dp[1][u]+=min(dp[1][v],dp[0][v]);//子节点可以选，也可以不选
        dp[0][u]+=dp[1][v];//子节点必须选
    }
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<n;i++){
        cin>>x>>y;
        if(x>y)G[y].push_back(x);
        else G[x].push_back(y);
    }//输入
    dfs(1);//树形dp
    cout<<min(dp[1][1],dp[0][1]);//输出
	return 0;
}
```

---


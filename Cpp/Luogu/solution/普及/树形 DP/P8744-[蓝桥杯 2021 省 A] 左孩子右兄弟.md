# [蓝桥杯 2021 省 A] 左孩子右兄弟

## 题目描述

对于一棵多叉树，我们可以通过“左孩子右兄弟”表示法，将其转化成一棵二叉树。

如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。

给定一棵包含 $N$ 个结点的多叉树，结点从 $1$ 至 $N$ 编号，其中 $1$ 号结点是根，每个结点的父结点的编号比自己的编号小。请你计算其通过"左孩子右兄弟"表示法转化成的二叉树，高度最高是多少。（只有根结点这一个结点的树高度为 $0$）

例如如下的多叉树：

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-11.jpg)

可能有以下 $3$ 种 (这里只列出 $3$ 种, 并不是全部) 不同的 “左孩子右兄弟” 表示: 

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-12.jpg)

其中最后一种高度最高, 为 $4$。

## 说明/提示

对于 $30 \%$ 的评测用例，$1 \leq N \leq 20$;

对于所有评测用例，$1 \leq N \leq 10^5$ 。 

蓝桥杯 2021 第一轮省赛 A 组 H 题。

## 样例 #1

### 输入

```
5
1
1
1
2```

### 输出

```
4```

# 题解

## 作者：lottle1212 (赞：28)

#  [原题链接](https://www.luogu.com.cn/problem/P8744)

这是一道 **贪心 + DP** 好题，具有一定的思维难度。

## 题目大意

- 给出一棵 $N(N \leq 10 ^ 5)$ 个节点树，求出这棵树通过“左孩子右兄弟”表示法转化成的二叉树高度最大值。

## 解题思路

首先通过 **贪心** 大法，我们容易想到一棵树根据题意处理后的最大高度即根节点儿子数 + 儿子中的最大高度。样例如图：

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-12.jpg)

我们把根节点的儿子串在一条链上，最下方是高度最大的儿子，即得答案 $4$（根节点高度为 $0$）。

最后，用简单清晰的 **树形 DP** 进行转移就可以了。

**AC Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e5 + 10; 
ll n, sz[N], head[N], dp[N], cnt, u;
struct Edge { ll nxt, to; } e[N << 1];
void add(ll u, ll v) { e[++ cnt] = {head[u], v}; head[u] = cnt; } //链式前向星
void dfs(ll u) {
	for(ll i = head[u], v; i; i = e[i].nxt) {
		v = e[i].to;
		dfs(v);
		dp[u] = max(dp[u], dp[v]);
	}
	dp[u] += sz[u];
} //树形 DP
signed main() {
	cin >> n;
	for(ll i = 2; i <= n; ++ i) cin >> u, add(u, i), ++ sz[u];
	dfs(1);
	cout << dp[1];
	return 0;
}
```


---

## 作者：Bpds1110 (赞：11)

### Preface:
[**Link**](https://www.luogu.com.cn/problem/P8744)

给定一棵节点数为 $N$ 的多叉树，求出次树按**左孩子右兄弟**变化，**最大**的深度。
### Solution:
一眼树形 dp，先观察样例，了解**左孩子右兄弟**变化，实际上就是对于每个节点，选择其中一个孩子作为左孩子，选择其中一个兄弟作为右孩子。

- **状态**：$dp_u$ 表示以 $u$ 为根的子树中最大的深度。
- **转移**：设 $u$ 节点的孩子个数为 $size$，分别为 $v_1$，$v_2$，$v_3\dots$ 则 $dp_u = \max \left\{v_1,v_2,v_3\dots\right\} + size$，表示把当前所有儿子展开成一条链，并把 $dp_v$ 最大的节点放到最下，贪心策略。
- **目标状态**：每棵树的根都是 $1$，最大深度存放在 $dp_1$ 中。

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 1;
int n, u, dp[N];
vector < int > G[N];
void dfs(int u)
{
	int size = G[u].size();
	for(int i = 0; i ^ size; i ++)
	{
		int v = G[u][i];
		dfs(v);
		dp[u] = dp[u] > dp[v] ? dp[u] : dp[v];//转移 
	}
	dp[u] += size;//转移
}
int main()
{
	cin >> n;
	for(int i = 2; i <= n; i ++)
	{
		cin >> u;
		G[u].push_back(i);//建图 
	}
	dfs(1);
	cout << dp[1]; 
	return 0;
}

```


---

## 作者：___w (赞：11)

### [P8744 [蓝桥杯 2021 省 A] 左孩子右兄弟](https://www.luogu.com.cn/problem/P8744)

#### 题意简述
给出一棵树，转换为左孩子右兄弟，求最大高度。

#### 题目分析
简单的树形 dp。

设 $dp_x$ 为以 $x$ 为根的子树的最大高度。

![图](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-12.jpg)

通过观察样例的图，我们可以发现对于一个节点，其中 $dp_x$ 最大的儿子 $x$，把它放置在其他儿子之上不如被其他儿子垫在脚下，这样子对答案的贡献会更多。再把节点的儿子之和 $size$ 加到答案里，所以得到状态转移方程：
$$dp_x=size+\max_{y\in \text{son}(x)}dp_y$$
详细见代码。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5, M = N;
struct edge {
	int to, next;
} e[M];
int n, tot, f[N], head[N];
void add(int x, int y) {
	e[++tot] = (edge){y, head[x]};
	head[x] = tot;
}
void dfs(int x) {
	int size = 0;
	for (int i = head[x]; i; i = e[i].next) {
		int y = e[i].to;
		dfs(y); ++size;
		f[x] = max(f[x], f[y]);
	}
	f[x] += size;
}
int main() {
	cin >> n;
	for (int i = 2, x; i <= n; ++i) {
		cin >> x;
		add(x, i);
	}
	dfs(1);
	cout << f[1];
	return 0;
}
```
[record](https://www.luogu.com.cn/record/112846781)

---

## 作者：xrxtcl (赞：7)

本题思路：

**贪心** $+$ **树形 DP**。

首先，对于每个节点，我们**只能**展开它的其中 $1$ 个儿子，其它的儿子就只有根 $1$ 个点。

那么根据**贪心**，我们就必须选最大的儿子。

考虑**树形 DP**。

显然 $dp_p=\max dp_t+size_p$。

下面给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct lsqxx{
	int t,nxt;
}e[114514];
int num[114514],tot;
void ae(int f,int t){
	e[++tot].t=t;
	e[tot].nxt=num[f];
	num[f]=tot;
}
int dp[114514];
void dfs(int p,int f){
	int size=0,tmp=0;
	for(int i=num[p];i;i=e[i].nxt){
		int t=e[i].t;
		size++;
		dfs(t,p);
		tmp=max(tmp,dp[t]);
	}
	dp[p]=size+tmp;
}
signed main()
{
	int n;
	cin>>n;
	for(int i=1;i<n;i++){
		int t;
		cin>>t;
		ae(t,i+1);
	}
	dfs(1,-1);
	cout<<dp[1];
    return 0;
}
```

---

## 作者：DengDuck (赞：7)

这道题我们设 $f_x$ 表示 $x$ 的子树通过左孩子右兄弟表示法转化成的二叉树高度最高。

那么，对于 $x$ 的孩子们，我们的最佳决策显然是直接一个孩子一层，形成一个链，然后最后一个孩子再继续展开。

那么显然这里的变量是最后一个孩子，我们希望最后一个孩子子树通过左孩子右兄弟表示法转化成的二叉树高度最高。

所以我们应该在 $x$ 的孩子中找到一个 $f$ 值最高的，转移方程为：

$$
f_x=\max f_{xson}+size_{xson}
$$

$f_1$ 即为所求,代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,f[100005];
vector<long long>v[100005]; 
void dfs(long long x)
{
	for(auto i:v[x])
	{
		dfs(i);
		f[x]=max(f[x],f[i]);
	}
	f[x]+=v[x].size();
} 
int main()
{
	scanf("%lld",&n);
	for(int i=2;i<=n;i++)
	{
		scanf("%lld",&x);
		v[x].push_back(i);
	}
	dfs(1); 
	cout<<f[1]<<endl; 
}
```

---

## 作者：MspAInt (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P8744)

一眼树形 dp，考虑状态设计。

$dp_i$ 表示以 $i$ 为根的子树能够形成的最大深度。

然后考虑每个结点的转移。

* 首先把 $i$ 的所有儿子一层层往下放，这样做能把树拉得最长。
* 结点的放置顺序对答案的贡献是有影响的，如何决策才能最佳呢？
* 显然我们如果把 $dp$ 值最高的儿子放在上面就是埋没人才，不如用它的子树作为末端，延伸出更多的深度，这样明显是最优策略，然后再去看样例的图就会豁然开朗。
* 整理后得出转移方程，其中 $s(i,j)$ 表示结点 $i$ 的第 $j$ 个儿子的编号，$c(i)$ 表示结点 $i$ 的儿子个数：$dp_i=c(i)+max_{j=1}^{c(i)} dp_{s(i,j)}$。



Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct edge{
	int ed,next;//习惯链式前向星
}a[N];
int dp[N],nbs[N],n,tot;
void add(int x,int y){
	tot++;
	a[tot].ed=y;
	a[tot].next=nbs[x];
	nbs[x]=tot;//建边，可以用vector代替
	return;
}
void read(){
	scanf("%d",&n);
	for(int i=2,x;i<=n;i++){
		scanf("%d",&x);
		add(x,i);
	}
	return;
}
void dfs(int k){//深搜转移
	int cnt=0;//儿子数量
	for(int x=nbs[k];x;x=a[x].next){
		int u=a[x].ed;
		dfs(u);cnt++;
		dp[k]=max(dp[k],dp[u]);//取孩子中最高的dp值
	}
	dp[k]+=cnt;//其他兄弟垫在上面
	return;
}
signed main(){
	read();dfs(1);
	printf("%d",dp[1]);//按状态输出答案
	return 0;
}
```

[record](https://www.luogu.com.cn/record/101735301)

---

## 作者：Zhangikun (赞：4)

## 一道很简单的树形 dp
温馨提示，图文结合风味更佳。
 
## 思路：
题目要求，将多叉树转换成二叉树（如下图）：
![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-11.jpg)
![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-12.jpg)
## 先说状态：
$dp_{cur}$ 表示以 $cur$ 为根节点的子树能够形成的最大深度。我们可以发现，规律就是，将同一深度的同一子树的子节点连成一条链，链首和这棵子树的根节点连一条边。
- 也就是说，对于一棵子树，假设它的所有子节点都是叶子节点，那么，它的深度就是它的子节点的数量。

- 再往深点想，对于一棵子树，它的深度就等同于它的所有子树的深度加上这个子节点前面的兄弟节点数量的最大值。

- 一个点的一棵子树的深度是最大的，如果放链首，那么，它的贡献就是 $dp_{cur}+0$，显然，亏大了。于是我们考虑放链尾。此时我们发现，放最后一个，显然对答案的贡献是最大的，于是，状态转移方程即刻推出。
## 状态转移：
```cpp
  for(int i=0;i<nbr[cur].size();i++)
  {
    int nxt=nbr[cur][i];
    dfs(nxt);
    dp[cur]=max(dp[cur],dp[nxt]);
  }
  dp[cur]+=nbr[cur].size();
```

## 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int cxk=100005;
int dp[cxk],a[cxk];
vector<int>nbr[cxk];
void dfs(int cur)
{
  for(int i=0;i<nbr[cur].size();i++)
  {
    int nxt=nbr[cur][i];
    dfs(nxt);
    dp[cur]=max(dp[cur],dp[nxt]);//把最长的放到最深的地方去
  }
  dp[cur]+=nbr[cur].size();
  return;
}
signed main()
{
  int n;
  cin>>n;
  for(int x=2,y;x<=n;x++)
  {
    cin>>y;
    nbr[y].push_back(x);//连边
  }
  dfs(1);
  cout<<dp[1];//整个树的最大深度
  return 0;
}
```


---

## 作者：chang_an_1029 (赞：3)

## 题意简述

我们可以通过“左孩子右兄弟”表示法，

将一棵多叉树转化成一棵二叉树，

计算用“左孩子右兄弟”表示法转化成的二叉树，

高度最高是多少。


------------

## 思路

一眼没思路，通常是 dp，

和树有关，那就是树形 dp 了。

### 简单介绍

树形 DP 即将 DP 建立在树状结构的基础上，一般有两种模式：

选择节点类或树形背包类，

此题显然与背包无关，属于前者，

选择节点类通常以以下方式的变式求解：

```
 	dp[u][0]=dp[v][1] 

 	dp[u][1]+=max(dp[v][0],dp[v][1])//或+=min(dp[v][0],dp[v][1]) 
```


其中 u 为 v 的父亲，其中动规数组的第二维填 true 或 false，代表这个节点是否被选择。状态转移在树上以递归进行。

### 回到此题

开一个 f 数组，表示的是以其下标为根节点的树的最大高度。

vector 存每个点的孩子，sons 数组存孩子数量，

状态转移时每次往下找拥有直接相连的孩子数最多的点，有几个孩子则加几层，

注意子节点的搜索应放在状态转移后，因为其状态转移所需要用到子节点的最大值应先得到。

具体细节都写在注释中了。

## CODE

```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}//快读 
const int N=1e5+1;
vector<int>tree[N];//记录父亲节点与孩子节点
int sons[N];//孩子数量
int f[N];//dp数组 f[u]表示的是以u为根节点的树的最大高度
int ans=0;//答案储存 
void dfs(int x){//当前节点.x
	for(int i=0;i<tree[x].size();i++){
		int j=tree[x][i];//x的第i个孩子j
		f[j]=f[x]+sons[x];//状态转移:每次往下找拥有直接相连的孩子数最多的点
		//有几个孩子则加几层 
		ans=max(ans,f[j]);//求最大值 
		dfs(j);//dfs放在状态转移后 因为dfs(j)的状态转移所需要用到的f[j]应先得到 
	}
}
int main(){
	int n=read();//读入
	for(int i=2;i<=n;i++){
		int x=read();//读入
		tree[x].push_back(i);//i是x的儿子 
		sons[x]++;//x的孩子多一个i
	}
	dfs(1);//1号结点是根
	printf("%d",ans);//输出答案 
	return 0;
}

```



------------
## THE END

---

## 作者：Coffins (赞：3)

前置知识:[**树形 dp**](https://oi-wiki.org/dp/tree/)。

1.   题意

给出一棵树，用左孩子右兄弟表达，问最高高度。

2.   思路

容易想到可以对于每棵子树逐个求解，于是采用树形 dp。

3.    实现

既然是dp的话需要推一下状态转移方程，设 $\operatorname{dp}(x)$ 表示这颗树高度 **+1**。

假设 $x$ 共有 $len(x)$ 个儿子，且其儿子中的一个 $s$ 使 $\operatorname{dp}(s)$ 最大，于是可以将 $s$ 的所有兄弟都变成他的祖先，让其离根最远，至于这些祖先的顺序不重要，没影响，此时有：

$\operatorname{dp}(x)=len(x)+\operatorname{dp}(s)$
 
取得最大值，设 $son(x,i)$ 表示结点 $x$ 的第 $i$ 个儿子，于是有了状态转移方程：
 
$\operatorname{dp}(x)=len(x)+\max_{i=1}^{len(x)}\operatorname{dp}[son(x,i)]$
 
Ps:每个结点都只被访问 1 次，于是复杂度 $O(n)$,绰绰有余 QwQ。

然后 dfs 求解即可。

核心 dfs：
```cpp
void dfs(int k)
{
	if(len[k]==0)
	{
		dp[k]=1;
		return;
	}
	int maxx=-1;
	for(int i=0;i<=len[k]-1;i++)
	{
		int x=son[k][i];
		dfs(x);
		maxx=max(maxx,dp[x]);
	}
	dp[k]=len[k]+maxx;
}
```
然后强调 2 个细节：

* 注意 dfs 至根时要返回 1；

* 输出时要**减一**！！！

4.  AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> son[100001];//链表存儿子
int len[100001]={0};
int n,u;
int dp[100001];
void dfs(int k)
{
	if(len[k]==0)
	{
		dp[k]=1;
		return;
	}
	int maxx=-1;//dp 值最大的儿子的 dp 值
	for(int i=0;i<=len[k]-1;i++)
	{
		int x=son[k][i];
		dfs(x);
		maxx=max(maxx,dp[x]);
	}
	dp[k]=len[k]+maxx;
}
int main()
{
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		cin>>u;
		len[u]++;
		son[u].push_back(i);
	} 
	dfs(1);//从根开始 dfs
	cout<<dp[1]-1<<endl;
	return 0;
}
```

---


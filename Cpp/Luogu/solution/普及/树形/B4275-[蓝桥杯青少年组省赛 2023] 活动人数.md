# [蓝桥杯青少年组省赛 2023] 活动人数

## 题目描述

有一个大型企业集团，由 $N$ 个部门组成，编号从 $1$ 到 $N$。这些部门之间的层次关系形成了一个树状结构，一个上级部门可能会有 $1$ 个或多个直接下级部门，一个下级部门只有一个直接上级部门。  

本月集团举办了一个大型活动，这次的活动组织方按如下要求安排活动：  

1. 来的人越多越好；  
2. 如果一个上级部门参加本次活动，那么他们的直接下级部门就不能参加，而他的间接下级部门可以参加（如下图，如果部门 $1$ 参加，那么部门 $2,3$ 不能参加，而部门 $4,5,6$ 可以参加）。  

请你帮他们计算一下，如何安排可以使参加活动的人数最多，并输出参加活动的最多人数。  

例如：当 $N=6$，每个部门编号为 $1$ 到 $6$，部门上下级关系和部门的人数如下图所示：  

![](https://cdn.luogu.com.cn/upload/image_hosting/ej7lvi7g.png)

注意：示例中，部门 $1$ 是层级最高的部门，没有直接上级，故将其直接上级部门设为 $0$；  

当安排（$1,4,5,6$）这 $4$ 个部门参加活动时，人数最多，为 $11$，所以输出 $11$。  

## 说明/提示

**【评分标准】**

- $10$ 分：能正确输出第一组数据；  
- $10$ 分：能正确输出第二组数据；  
- $10$ 分：能正确输出第三组数据；  
- $10$ 分：能正确输出第四组数据；  
- $10$ 分：能正确输出第五组数据；  
- $10$ 分：能正确输出第六组数据；  
- $10$ 分：能正确输出第七组数据；  
- $10$ 分：能正确输出第八组数据；  
- $10$ 分：能正确输出第九组数据；  
- $10$ 分：能正确输出第十组数据。

## 样例 #1

### 输入

```
6
0 1 2
1 2 4
1 3 3
2 4 3
3 5 2
3 6 4```

### 输出

```
11```

# 题解

## 作者：lym2022 (赞：8)

树形 dp 的板子题。

[双倍经验](https://www.luogu.com.cn/problem/P1352)

### 题目大意
给定一棵树的每条边和每个点的点权，规定如果点 $u$ 选了，那么点 $u$ 的儿子 $v$ 就不能选,问可以选出的方案中点权和最大是多少。当 $u$ 为 $0$ 时，点 $v$ 为根节点。

### 思路
典型的树形 dp。

$f[u][0]$ 表示以 $u$ 为根节点的子树，节点 $u$ 不选时的最大值，初始化时因为没人来，所以 $f[u][0]$ 初始化为 $0$；

$f[u][1]$ 表示以 $u$ 为根节点的子树，节点 $u$ 选时的最大值，初始化时因为只有 $u$ 一个节点，所以 $f[u][0]$ 初始化为 $u$ 的点权；

转移时从下向上转移：

当 $u$ 不选时儿子 $v$ 可选可不选，所以 $f[u][0]$ 就加上 $f[v][0]$ 和 $f[v][1]$ 较大的那个（~~不写函数是因为不会用格式~~）;

当 $u$ 选时儿子 $v$ 就不能选，所以 $f[u][1]$ 就加上 $f[v][0]$。

最后就输出根节点选或不选的最大值就好了。

### Code


```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;

int n,a[N],f[N][2],root;     //a数组就是点权，root存根节点 

vector<int> e[N];

void dfs(int u) {                        //树形dp 
	f[u][0] = 0;                         //不选时，初始化为 0 
	f[u][1] = a[u];                      //选时，初始化为 u 的点权 
	for(auto v : e[u]) {                 //便利每个儿子 v 
		dfs(v);                          //先搜下去，等到儿子的答案确定了再转移 
		f[u][1] += f[v][0];              //如果 u 选，v 就不能选 
		f[u][0] += max(f[v][0],f[v][1]); //否则 v 就可选可不选 
	} 
}

int main() {
	cin >> n;
	for(int i = 1;i<=n;i++) {
		int u,v,w;
		cin >> u >> v >> w;
		a[v] = w;
		if(u == 0) {          //如果 u 为 0,那么 v 就是根节点  
			root = v;         //记录根节点 
			continue;
		}
		e[u].push_back(v);    //邻接表存图 
	}
	dfs(root);           //从根节点开始搜 
	cout << max(f[root][0],f[root][1]);     //输出根节点选或不选时答案较大的情况 
	return 0;
}
```
有兴趣的话可以浏览一下蒟蒻写的前两篇题解：

[P1032 子串变换](https://www.luogu.com.cn/article/h31491m5)  [P10687 True Liars](https://www.luogu.com.cn/article/6qetz03f)

---

## 作者：FJ_EYoungOneC (赞：3)

### 解题思路

板题链接：[P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

原题链接：[B4275 活动人数](https://www.luogu.com.cn/problem/B4275)

---

考虑 DP：

- $f_{i,1}$ 表示以 $i$ 为根且选了 $i$ 的最大价值。
- $f_{i,0}$ 表示以 $i$ 为根且不选 $i$ 的最大价值。

那么答案就是 $\max(f_{root, 1},f_{root, 0})$，其中 $root$ 表示根节点。

对于 $f_{i, 1}$，由于 $i$ 已经选了，那么他的孩子就都不能选，所以 $f_{i, 1} = \sum f_{j, 0}$（$j$ 表示 $i$ 的孩子）。

对于 $f_{i, 0}$，由于 $i$ 未选，那么他的孩子可选可不选，所以 $f_{i, 0} = \sum \max(f_{j, 0}, f_{j,1})$（$j$ 表示 $i$ 的孩子）。

时间复杂度 $O(n)$。

### AC_Code

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e5 + 10, M = N;

int n, root;
int h[N], e[M], ne[M], idx;
int w[N];
int f[N][2];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

void dfs(int u)
{
    f[u][1] = w[u];
    for (int i = h[u]; ~i; i = ne[i] )
    {
        int j = e[i];
        dfs(j);
        f[u][1] += f[j][0];
        f[u][0] += max(f[j][0], f[j][1]);
    }
}

int main()
{
    cin >> n;

    memset(h, -1, sizeof h);
    
    for (int i = 1; i <= n; ++ i )
    {
        int a, b, c;
        cin >> a >> b >> c;
        if (!a)
            root = b;
        add(a, b);
        w[b] = c;
    }

    dfs(root);

    cout << max(f[root][0], f[root][1]) << endl;
    
    return 0;
}
```

---

## 作者：_Corange_ (赞：1)

~~为什么这么水的树形 dp 都没人发题解呀？~~

公司中的部门级别关系其实可以抽象成一棵树，一个部门的儿子就是他的直接下级部门。

对于一个部门来说，他是可去可不去的。他若不去，那他的直接儿子也是可去可不去的；但要是他去了，那他的儿子就肯定不去。

我们不妨设一个部门编号为 $u$，其直接下级编号为 $v$；用 $0$ 表示该部门不去，用 $1$ 表示该部门去。则我们得到如下状态转移方程。

$$\begin{cases}dp_{u,0}=dp_{u,0}+\max(dp_{v,0},dp_{v,1})\\dp_{u,1}=dp_{u,1}+dp_{v,0}\end{cases}$$

由于本题可能有多个最高级部门，所以我们让这些部门的直接上层如题目中所讲的都为 $0$。而设 $0$ 的父为一个虚拟的根节点 $-1$。

# [AC](https://www.luogu.com.cn/record/211496358) Code
```cpp
#include<bits/stdc++.h>
using namespace std;
static constexpr int N=1e6+3;
int head[N],nxt[N<<1],to[N<<1],weight[N<<1],tot;
inline void add(const int& u,const int& v,const int& w=1){
	to[++tot]=v;weight[tot]=w;
	nxt[tot]=head[u];head[u]=tot;
	return;
}
int dp[N][2];
inline void dfs(const int& fa,const int& u){
    for(int i=head[u];i;i=nxt[i]){
        int v=to[i],w=weight[i];
        if(v==fa) continue;
        dfs(u,v);
        dp[u][0]+=max(dp[v][0],dp[v][1]);
        dp[u][1]+=dp[v][0];
    }
    return;
}
int main(){
    ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr);
    int n;cin>>n;
    for(int i=1,u,v,w;i<=n;++i){
        cin>>u>>v>>w;
        add(u,v,w),add(v,u,w);
        dp[v][1]=w;
    }
    dfs(-1,0);
    cout<<max(dp[0][0],dp[0][1]);
    return 0;
}
```

---

## 作者：wyyinput (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4275)  
[双倍经验&模板题](https://www.luogu.com.cn/problem/P1352)

## 思路
“形成了一个树状结构”提示我们往树上想。所以这道题是树形 DP。如果你是大佬，一眼就看出这是树形 DP，就当我没说。

## 状态定义
$f[u][0]$：$u$ 部门不来的情况下 $u$ 子树最大人数；  
$f[u][1]$：$u$ 部门来了的情况下 $u$ 子树最大人数。

## 初始化
每个部门单独来的情况下人数就是这个部门本身的人数。所以  $f[u][1]=a[u]$。$a[u]$ 为 $u$ 部门的人数。

## 状态转移
我们由叶子往根推。没有上司的节点就是根。$v$ 是 $u$ 的儿子，分两种情况：

当 $u$ 部门不来时，$v$ 部门可来可不来。所以 $f[u][0]$ 取 $f[v][0]$ 和 $f[v][1]$ 的较大值。

当 $u$ 部门来时，$v$ 部门必须不来。所以 $f[u][1]$ 取 $f[v][0]$。

那么答案就是 $f[root][0]$ 和 $f[roor][1]$ 的较大值。其中 $root$ 为根。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100001;
int n,r[N],f[N][2],head[N],cnt,u,v,root;
struct edge{
	int to,ne;
}bian[N];
void add(int u,int v){
	bian[++cnt]={v,head[u]};
	head[u]=cnt;
	return;
}
void dfs(int u){
    int v;
	for(int i=head[u];i;i=bian[i].ne){
        v=bian[i].to;
		dfs(v);
		f[u][0]+=max(f[v][0],f[v][1]);
		f[u][1]+=f[v][0];
	}
	return;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&u,&v);
        scanf("%d",r+v);
        f[v][1]=r[i];
		add(u,v);
        if(u==0)
            root=v;
	}
	dfs(root);
	printf("%d\n",max(f[root][0],f[root][1]));
	return 0;
}
```

---

## 作者：huxuanrui19 (赞：1)

来温习一下树形 DP。

[题目传送门](https://www.luogu.com.cn/problem/B4275)

本来是一道树形 DP 经典好题，可是这道题有[原题](https://www.luogu.com.cn/problem/P1352)。

话不多说，直接来看。

# 题目描述

$N$ 个部门组成编号从 $1$ 到 $N$ 的**树状结构**，如果一个上级部门参加本次活动，那么他们的直接下级部门就**不能参加**，而他的间接下级部门**可以参加**。（**注意看题**）

求最多人数。
# 题目思路
定义状态 $dp[n][2]$（$dp[u][0]$ 表示不选 $u$，$dp[u][1]$ 表示选 $u$）。

这里直接给出状态转移方程（定义 $C_u$ 为 $u$ 部门的人数，$children(u)$ 为 $u$ 部门的直接下属部门集合。）
$\begin{cases}
dp[u][1] = C_u + \sum\limits_{v \in \text{children}(u)} dp[v][0] \\
dp[u][0] = \sum\limits_{v \in \text{children}(u)} \max(dp[v][1], dp[v][0]) \\
\end{cases}$

然后用 vector 动态存图，做一遍 dfs，

初始化叶子结点为 $\begin{cases}dp[u][1] = C_u \\dp[u][0] = 0\end{cases}$，再逐层计算，

最后输出 $\max(dp[\text{root}][1],dp[\text{root}][0])$，

其中根节点为 $\text{root}$。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[int(1e5+10)],dp[int(1e5+10)][2];
vector<int> G[int(1e5+10)];
void dfs(int s){
	if(G[s].size()==0){
		dp[s][0]=0;
		dp[s][1]=a[s];
		return;
	}
	for(int i=0;i<G[s].size();i++){
		dfs(G[s][i]);
		dp[s][0]+=max(dp[G[s][i]][1],dp[G[s][i]][0]);
		dp[s][1]+=dp[G[s][i]][0];
	}
	dp[s][1]+=a[s];
	return;
}
int main(){
	int n;
	cin>>n;
	int fa=0;
	for(int i=1;i<=n;i++){
		int u,v,w;
		cin>>u>>v>>w;
		if(u==0){
			fa=v;  //记得要找父节点
		}
		G[u].push_back(v);
		a[v]=w;
	}
	dfs(fa);
	cout<<max(dp[fa][0],dp[fa][1]);
	return 0;
} 
```

给备战2025蓝桥杯青少年组省赛的选手放个福利，

谢谢阅读。

---

## 作者：nahidaQ_Q (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/B4275)
## 思路
看到这一题，第一时间就想到了~~我们的老朋友~~[没有上司的舞会](https://www.luogu.com.cn/problem/P1352)。
###  Part 1 题意及理解
给定一棵**树**，**树**的每个节点有一个**权值**，当取一个树的节点时就不能取他的父亲，问能取得的**最大**权值是多少。  
###  Part 2 思考过程
**第一件事**还是将这棵**树**读进来，然后我们开始思考，如何取得最大的权值。  
首先贪心肯定**不行**，只能过部分分。这是我们就想到了**树形 dp**，因为有**树**又有**权值**。  
我们很自然的就想到定义 $dp_{u,0}$ 为以 $u$ 为根并且**不取** $u$ 的能取得的**最大**权值，$dp_{u,1}$ 为以 $u$ 为根并且**取** $u$ 的能取得的**最大**权值。  
如何转移呢？  
当 $u$ 选时便不能选其子节点，而不选 $u$ 时既可选子节点也可不选，所以最优即为 $\max(dp_{u,0},dp_{u,1})$ 同时，我们应**从下往上**转移，每个状态都由其**子节点**转移。  
若设 $son_i$ 为 $u$ 的第 $i$ 个孩子，$u$ 共有 $n$ 个儿子，则：
$$
    dp_{u,0}=\sum_{i = 1}^{n} \max(dp_{son_i,0},dp_{son_i,1})
$$
同时，
$$
dp_{u,1}=\sum_{i = 1}^{n} dp_{son_i,0}
$$
最后再输出 $\max(dp_{0,1},dp_{0,0})$ 即可。

## Code
``````cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n;
int dp[N][2];
//1 含 0 不含 
struct node{
	vector<int> son;//这里我采用vector模拟邻接表
//链式向前星也是一种好选择
	int num=0;//代表权值
}G[N];
int f,s,c;
void init(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d %d %d",&f,&s,&c);
		G[s].num=c;
		G[f].son.push_back(s);   
        G[s].son.push_back(f);//双向边
	}
}
void dfs(int u,int fa){
	dp[u][0]=0,dp[u][1]=G[u].num;
	for(int v : G[u].son){
		if(u!=fa){//避免搜回父亲
			dfs(v,u);//先求得子节点的解
			dp[u][1]+=dp[v][0];
			dp[u][0]+=max(dp[v][0],dp[v][1]);
		}
	}
}
int main(){
	init();
	dfs(0,-1);//根节点没有父亲
	printf("%d",max(dp[0][0],dp[0][1]));
	return 0;
}
``````
进阶题 [P4084](https://www.luogu.com.cn/problem/P4084)。

---

## 作者：wwwidk1234 (赞：0)

## 题目解析

### 问题背景

本题为一道[树形动态规划](https://oi-wiki.org/dp/tree/)的入门题，也是一道十分经典的题目。

### 构建联系

题目中说到这些部门之间的层次关系形成了一个**树状结构**，其中部门 $u$ 及其所有下级部门可以看做一棵以 $u$ 为根结点的子树（如图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ej7lvi7g.png)

### 状态设计

观察题目发现，对于每一个部门 $u$ 有两种决策：**参加**或**不参加**，所以可以设置**动态规划状态**：

- $dp_{u,0}$ 为以 $u$ 为根结点的子树，并且部门 $u$ **不参加活动**的最多参加人数；
- $dp_{u,1}$ 为以 $u$ 为根结点的子树，并且部门 $u$ **参加活动**的最多参加人数；

### 状态转移

设 $v$ 为 $u$ 的儿子，$c_i$ 为第 $i$ 个部门的人数，$root$ 为根结点，那么：

- 当 $u$ 参加活动时，$v$ 一定不能参加活动，所以可以得到状态转移方程：$dp_{u,1}=\sum dp_{v,0}+c_u$。
- 当 $u$ 不参加活动时，$v$ 可参加可不参加，我们选取其中人数最多的一个，可以得到状态转移方程 $dp_{u,0}=\sum \max \left\{dp_{v,1},dp_{v,0} \right\}$。

最终 $\max\left\{dp_{root,0},dp_{root,1}\right\}$ 即为所求。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
constexpr int N=100007;
int n;
vector<int> g[N];
int dp[N][2];
int c[N];
void dfs(int u)
{
    dp[u][0]=0;
    dp[u][1]=c[u];
    for(int v:g[u])
    {
        dfs(v);
        dp[u][0]+=max(dp[v][0],dp[v][1]);
        dp[u][1]+=dp[v][0];
    }
}
int main()
{
    // freopen("neuvillette.in","r",stdin);
    // freopen("neuvillette.out","w",stdout);
    int u,v,w,root=-1218;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>v>>u>>w;
        if(v==0) root=u;
        else g[v].push_back(u);
        c[u]=w;
    }
    dfs(root);
    cout<<max(dp[root][0],dp[root][1]);
    return 0;
}
/*
dp[u][0/1]表示以u为根结点、u不参加/参加活动的最大人数
*/
```

---

## 作者：ryderyang (赞：0)

# 解题思路
  - 设 $dp_{i,0}$ 为以 节点 $i$ 为根节点的子树，最多有多少人能参加，但是 $i$ 不参加。

  - 再设 $dp_{i,1}$ 为以 节点 $i$ 为根节点的子树，最多有多少人能参加，并且 $i$ 参加。

那么对于每一个儿子 $u$，首先先肯定进入下一层递归，然后就是状态转移。

  - $dp_{i,0}$ 要加上 $\max(dp_{u,0},dp_{u,1})$，因为节点 $u$ 可以参加，也可以不参加。
  - $dp_{i,1}$ 要加上 $dp_{u,0}$，因为节点 $u$ 不能参加。
  - $dp_{i,1}$ 记得加上 $a_i$，因为我们选了这个节点。 

我们的答案就是 $\max(dp_{root,0},dp_{root,1})$，其中 $root$ 是这颗树的根节点。

# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
vector<int> edges[N];
int n,dp[N][2],a[N],root;
void dfs(int i)
{
	dp[i][1]+=a[i];
	for(auto u:edges[i])
	{
		dfs(u);
		dp[i][0]+=max(dp[u][0],dp[u][1]);
		dp[i][1]+=dp[u][0];
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int f,s,c;
		scanf("%d%d%d",&f,&s,&c);
		edges[f].push_back(s);
		a[s]=c;
		if(f==0)
		root=s;
	}
	dfs(root);
	printf("%d",max(dp[root][0],dp[root][1]));
	return 0;
}
```

---

## 作者：Restart_Justin (赞：0)

## 正解
暴力没啥好打的，直接正解。

可以用树状 dp 实现。
### 状态
容易想出用 $f_{i, k}(1\leq i\leq n,k\in \{0, 1\})$ 来表示从 $1$ 遍历到 $i$ 中 $i$ 选或不选的最佳方案（$k=0$ 表示不选，$k=1$ 表示选）。

这样转移就好办了。

直接上转移方程（$u$ 为当前节点，$v$ 为 $u$ 的子节点）：

$$f_{u,0}=\sum \max(f_{v,0},f_{v,1})$$（如果 $u$ 没选，那么它的儿子可选可不选。）

$$f_{u,1}=(\sum f_{v,0})+C_u$$（如果 $u$ 选了，那么它的儿子只能不选，因为选了所以还要加上它的部门人数。）

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int n, c[maxn], dp[maxn][2], f[maxn];
vector <int> G[maxn];
void solve(int u) {
    for (int v : G[u]) {
        solve(v);
        dp[u][0] += max(dp[v][0], dp[v][1]);
        dp[u][1] += dp[v][0];
    }
    dp[u][1] += c[u];
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int f, s, c;
        cin >> f >> s >> c;
        ::f[s] = f, ::c[s] = c;
        G[f].push_back(s);
    }
    solve(1);
    cout << max(dp[1][0], dp[1][1]);
}
```

---

## 作者：Ag2WO4 (赞：0)

一道重题拷贝数很多的动态规划，算是经典题型了。

根据题意，状态为节点编号 $i$（及它的所有子节点编号 $j_k$）和上级是否参加，转移方程为 
- $\text{dp}_{i,0}=\max(a_{j_k}+\sum\text{dp}_{j_k,1},\sum\text{dp}_{j_k,0})$；
- $\text{dp}_{i,1}=\sum\text{dp}_{j_k,0}$。

最终答案为 $\text{dp}_{0,0}$。本题使用记忆化搜索的写法。
```python
a={0:[[],0]};import sys,functools;sys.setrecursionlimit(1<<30)
@functools.cache
def f(i,j):return max(sum(f(k,0)for k in a[i][0]),0 if j else a[i][1]+sum(f(k,1)for k in a[i][0]))
for i in range(int(input())):b,c,d=map(int,input().split());a[b][0].append(c);a[c]=[[],d]
print(f(0,0))
```

---


# [GESP202406 六级] 二叉树

## 题目描述

小杨有一棵包含 $n$ 个节点的二叉树，且根节点的编号为 $1$。这棵二叉树任意一个节点要么是白色，要么是黑色。之后小杨会对这棵二叉树进行 $q$ 次操作，每次小杨会选择一个节点，将以这个节点为根的子树内所有节点的颜色反转，即黑色变成白色，白色变成黑色。

小杨想知道 $q$ 次操作全部完成之后每个节点的颜色。

## 说明/提示

#### 样例解释

第一次操作后，节点颜色为：$\texttt{011010}$

第二次操作后，节点颜色为：$\texttt{000000}$

第三次操作后，节点颜色为：$\texttt{010000}$

#### 数据范围

| 子任务编号 | 得分 | $n$ | $q$ | 特殊条件 |
| :--: | :--: | :--: | :--: | :--: |
| $1$ |  $20$ | $\le 10^5$ | $\le 10^5$ |对于所有 $i\ge 2$，节点 $i$ 的父亲节点编号为 $i-1$
| $2$ |  $40$ | $\le 1000$ | $\le 1000$ | |
| $3$ | $40$ | $\le 10^5$ | $\le 10^5$ | |

对于全部数据，保证有 $n,q\le 10^5$。

## 样例 #1

### 输入

```
6
3 1 1 3 4
100101
3
1
3
2```

### 输出

```
010000```

# 题解

## 作者：stripe_python (赞：20)

给一个类似线段树的考场思路。

在每个节点维护一个当前颜色 $col$，一个标记 $tag$，表示实际颜色与 $col$ 是否相同。

更新的时候，注意先下传标记，修改结束后再写个 dfs 全部下传一遍。复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define N 100005
using namespace std;

int n, fa, ls[N], rs[N], col[N], rev[N], q, a;
char x;

void pushdown(int rt) {
	if (!rev[rt]) return;
	rev[rt] ^= 1, col[rt] ^= 1;
	rev[ls[rt]] ^= 1, rev[rs[rt]] ^= 1;
}
void dfs(int rt) {
	if (!rt) return;
	pushdown(rt);
	dfs(ls[rt]), dfs(rs[rt]);
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	for (int i = 2; i <= n; i++) {
		cin >> fa;
		(ls[fa] ? rs[fa] : ls[fa]) = i;
	}
	for (int i = 1; i <= n; i++) cin >> x, col[i] = x - '0';
	for (cin >> q; q--; ) {
		cin >> a;
		pushdown(a); 
		rev[a] ^= 1;
	}
	dfs(1);
	for (int i = 1; i <= n; i++) cout << col[i];
	return 0;
}
```

---

## 作者：stylus (赞：13)

#### 题目大意：
给定一棵树，每个节点可以进行翻转操作。翻转操作会影响节点及其所有子节点的状态。题目要求我们根据给定的翻转操作序列，输出每个节点最终的状态。
# 思路：
本题的关键在于理解树结构中翻转操作的传递性：一旦父节点翻转，其所有子节点也会随之翻转。我们便可得到公式：
$$ \texttt{每个结点翻的次数=父节点翻的次数+本身翻的次数。}$$
这使得问题可以通过递归的方式来解决。
### 代码君：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,p[100005],a[100005],b[100005],op;
//p[i]表示i的父节点，对第i个节点的操作次数，第i个节点变化的总次数
string s;
int dfs(int x){
    if (b[x]>0)return b[x];//如果已计算，直接返回结果
    b[x]=a[x]+dfs(p[x]);//当前节点的操作次数加上父节点的总操作次数
    return b[x];
}int main() {
    cin>>n;
    for(int i=2;i<=n;i++)cin>>p[i];
    cin>>s>>q;
    for(int i=1;i<=q;i++)cin>>op,a[op]++;
    b[1]=a[1]+2;//多两次操作不影响结果，可以保证b数组都大于0
    for(int i=1;i<=n;i++)
        if(!b[i])dfs(i);//如果没计算，递归计算
    for(int i=0;i<n;i++){//枚举字符串的每一位
        bool x=s[i]-'0';//转换成布尔值
        if(b[i+1]%2==0)cout<<x;//偶数次，直接输出
        else cout<<!x;//奇数次，输出相反
    }return 0;
}
```

---

## 作者：__zhuruirong__ (赞：12)

## 题目大意

懒得写了，自己看去

[link](https://www.luogu.com.cn/problem/P10722)

## 方法一

学过 DFS 序的应该知道，一个子树内的 DFS 序是连续的，利用这个性质，可以把题目转化为区间问题，然后一眼就看得出来可以用差分。

## 方法二

线段树中有一个“懒标记”，而且两次等于没取反。利用这个性质，以每次询问的子树的树根打一个懒标记，最后输出答案时懒标记下传就行了。

## 方法一代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, q, sum[N], ans[N], l[N], r[N], id[N], cnt;
string s;
vector<int> E[N];

void dfs(int x, int fa) {
	l[x] = ++cnt;
	id[cnt] = x;
	for(int i = 0; i < E[x].size(); i++) {
		int y = E[x][i];
		if(y == fa) {
			continue;
		}
		dfs(y, x);
	}
	r[x] = cnt;
}

int main() {
	cin >> n;
	for(int i = 2; i <= n; i++) {
		int f;
		cin >> f;
		E[f].push_back(i);
	}
	dfs(1, 0);
	cin >> s;
	s = " " + s;
	for(int i = 1; i <= n; i++) {
		sum[l[i]] = s[i] - '0';
	}
	for(int i = n; i >= 1; i--) {
		sum[i] ^= sum[i - 1];
	}
	cin >> q;
	while(q--) {
		int x;
		cin >> x;
		sum[l[x]] ^= 1;
		sum[r[x] + 1] ^= 1;
	}
	for(int i = 1; i <= n; i++) {
		sum[i] ^= sum[i - 1];
	}
	for(int i = 1; i <= n; i++) {
		ans[id[i]] = sum[i];
	}
	for(int i = 1; i <= n; i++) {
		cout << ans[i];
	}
}
```

## 方法二代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, q, a[N], tag[N];
string s;
vector<int> E[N];

void dfs(int x, int fa) {
	a[x] ^= tag[x];
	for(int i = 0; i < E[x].size(); i++) {
		int y = E[x][i];
		if(y == fa) {
			continue;
		}
		tag[y] ^= tag[x];
		dfs(y, x);
	}
}

int main() {

	cin >> n;
	for(int i = 2; i <= n; i++) {
		int f;
		cin >> f;
		E[f].push_back(i);
	}
	cin >> s;
	s = " " + s;
	for(int i = 1; i <= n; i++) {
		a[i] = s[i] - '0';
	}
	cin >> q;
	while(q--) {
		int x;
		cin >> x;
		tag[x] ^= 1;
	}
	dfs(1, 0);
	for(int i = 1; i <= n; i++) {
		cout << a[i];
	}
	
	return 0;
}
```

---

## 作者：liaoxingrui (赞：7)

## Content

给你一个 $n$ 个节点，根节点为 $1$ 的树。然后再给你一个长度为 $n - 1$ 的序列，表示第 $i$ 个节点的父亲，和一个长度为 $n$ 的序列，表示第 $i$ 个节点的值，为 $1$，代表黑色，为 $0$，代表白色。

再给你一个正整数 $q$。和 $q$ 个询问，每个询问一个正整数，把以这个数为根的子树内所有节点的颜色反转，即黑色变成白色，白色变成黑色。

## Solution

这道题与[文艺平衡树](https://www.luogu.com.cn/problem/P3391)的基本思路一样，直接暴力是不行的。

但是有可能会有重复操作，如果一个询问是节点 $i$，我们可以将节点 $i$ 的标记反转，在最后把标记下传，也就是如果节点 $i$ 的标记为 `true`，就将它的儿子的标记反转，就可以做到 $O(n)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,x;
char c;
bool flag[N];
struct node{
	int l,r;
	bool val;
}tree[N];
inline void dfs(int node){
	const int tmpl=tree[node].l,tmpr=tree[node].r;
	if(!tmpl)
		return;
	if(flag[node]){
		flag[tmpl]^=1;
		flag[tmpr]^=1;
	}
	dfs(tmpl);
	if(tmpr)
		dfs(tmpr);
}
int main(){
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>x;
		if(tree[x].l)
			tree[x].r=i;
		else
			tree[x].l=i;
	}
	for(int i=1;i<=n;i++){
		cin>>c;
		tree[i].val=(c^48);
	}
	cin>>m;
	while(m--){
		cin>>x;
		flag[x]^=1;
	}
	dfs(1);
	for(int i=1;i<=n;i++)
		cout<<(tree[i].val^flag[i]);
	return 0;
}
```

---

## 作者：ttq012 (赞：6)

说一个考场降智做法。

看到子树修改单点查询，显然想到把序列拍平然后在线段树上处理。这个题目中值为 $0/1$，子树需要区间异或 $1$，只需要线段树维护每一段区间上的异或和（$0$ 或 $1$）即可。

时间复杂度为 $O(n\log n)$。代码很好写（只有 $120$ 行）不放了。

---

## 作者：CaiZi (赞：5)

## [GESP202406 六级] 二叉树 题解
**[题目链接](https://www.luogu.com.cn/problem/P10722)**
### 题目分析
为了方便进行 DFS，我们读入的有根树可以直接存成有向图。

我们每次取反时在 $a_i$ 打标记，打标记时对原标记取反，因为进行两次取反等于不进行取反。

然后我们用 DFS 推下去，推的时候的标记遇到标记时，也进行取反。最终更新完整棵树。

在写代码过程中，善用 C++ 的异或（`^`）运算可以直接进行取反操作，极大降低了代码长度。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a,b[100001],c[100001];
char s;
vector<int>g[100001];
inline void dfs(int u,int v){
	if(v){
		b[u]^=1;
	}
	for(int i:g[u]){
		dfs(i,v^c[i]);
	}
	return;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>a;
		g[a].push_back(i);
	}
	for(int i=1;i<=n;i++){
		cin>>s;
		b[i]=s-'0';
	}
	cin>>q;
	while(q--){
		cin>>a;
		c[a]^=1;
	}
	dfs(1,c[1]);
	for(int i=1;i<=n;i++){
		cout<<b[i];
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/164810111)**

---

## 作者：lucasincyber (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P10722)
## 思路
我们知道要将哪些节点以及它们的子树换颜色。我们就可以统计每一个节点会被当做要被改变的子树的根会被改几次（也就是 $a_i$）。最后跑一边 dfs，就可以把每一个节点会被改变多少次算出来，这样就可以按题目要求得出答案。

因为 dfs 只会到达 $n$ 个节点，所以时间复杂度为 $O(n)$。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;

int n, q;
string s;
int sum[N];
bool co[N];
vector<int> tr[N];

void dfs(int u) // dfs
{
    bool x = (sum[u] % 2 == 1); // 判断当前节点是否要改变颜色
    if (x) co[u] = !co[u];
    for (int v : tr[u])
    {
        sum[v] += sum[u];
        dfs(v);
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 1, x; i < n; i++)
    {
        scanf("%d", &x);
        tr[x].push_back(i + 1);
    }
    cin >> s;
    for (int i = 0; i < s.size(); i++)
        if (s[i] == '1') co[i + 1] = true;
    scanf("%d", &q);
    while (q--)
    {
		int x;
		scanf("%d", &x);
		sum[x]++;
	}
	dfs(1);
	for (int i = 1; i <= n; i++)
		cout << co[i];
	return 0;
}
```

---

## 作者：_anll_ (赞：4)

## 大体思路
令 $1$ 表示黑，$0$ 表示白，很容易想到每次反转都相当于进行一次异或。由于只需要在最后输出，因此不必手搓树剖线段树，我们完全可以思考 $O(1)$ 修改 $O(n)$ 输出的办法。

发现修改只对 $x$ 的子树造成影响，换言之，对于每个节点而言，是否被反转仅与祖先节点及自己有关。所以我们完全可以对每个结点开一个 $a$ 数组来存它是否需要被反转。最后在遍历时对每个点开个 $cnt$ 表示是否需要反转，先将其异或 $a[x]$ 再更新 $ans[x]$，最后再下传即可。

## 代码部分
```cpp
#include<iostream>
#define int long long
using namespace std;
const int N=1e5+5;
struct Edge{
	int l,nxt;
}edges[N<<1];
int n,q,tt,head[N],ans[N],a[N];
string s;
void add_edge(int f,int l){
	edges[++tt]={l,head[f]};
	head[f]=tt;
}
void dfs(int x,int cnt){
	cnt^=a[x];ans[x]^=cnt;
	for(int i=head[x];i;i=edges[i].nxt)
		dfs(edges[i].l,cnt);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;int x;
	for(int i=2;i<=n;i++){cin>>x;add_edge(x,i);}
	cin>>s>>q;
	for(int i=0;i<s.size();i++) ans[i+1]=s[i]-'0';
	for(int i=1;i<=q;i++){cin>>x;a[x]^=1;}
	dfs(1,0);
	for(int i=1;i<=n;i++) cout<<ans[i];
	return 0;
}
```

---

## 作者：fangminding (赞：3)

这里来提供一种不同的树状数组加 dfs 序的解法，复杂度较劣，但可以通过。

注意到操作是对树上一点的子树进行的，故想到使用 dfs 序来维护（dfs 序有一个很好的性质，一个点及其子树上所有点在 dfs 序中是连续的，非常方便进行子树操作）。

而同一个点每修改两次就会变回原来的颜色，故用差分树状数组维护每个点的更改次数即可。

最后输出时判断奇偶性并与初始颜色进行计算即可得到结果。

不会差分树状数组的[点这里](https://www.luogu.com.cn/problem/P3368)。

完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int>son[500005];
int fa[500005],frt[500005],dfsx[500005],cnt,n,q,siz[500005],tree[500005];
int low(int a)
{
	return a&(-a);
}
void add(int ass,int k)
{
	while(ass<500005)
	{
		tree[ass]+=k;
		ass+=low(ass);
	}
}
int ask(int rit)
{
	int ans=0;
	while(rit>0)
	{
		ans+=tree[rit];
		rit-=low(rit);
	}
	return ans;
}
void dfs(int u)
{
	dfsx[u]=++cnt;
	for(int i = 0;i <son[u].size();i++)
		dfs(son[u][i]);
	siz[u]=1;
	for(int i = 0;i <son[u].size();i++)
		siz[u]+=siz[son[u][i]];
	return;
}
signed main()
{
	cin>>n;
	for(int i = 2;i <=n;i++)
		cin>>fa[i];
	char ct;
	for(int i = 1;i <=n;i++)
	{
		cin>>ct;
		frt[i]=ct-'0';
	}
	for(int i = 2;i <=n;i++)
		son[fa[i]].push_back(i);
	dfs(1);
	cin>>q;
	for(int i = 1;i <=q;i++)
	{
		int t;
		cin>>t;
		add(dfsx[t],1);
		add(dfsx[t]+siz[t],-11);
	}
	for(int i = 1;i <=n;i++)
		cout<<(frt[i]+ask(dfsx[i])+100000000)%2;
	return 0;
}
```

[AC 记录(巨慢无比)](https://www.luogu.com.cn/record/164954322)

---

## 作者：Redamancy_Lydic (赞：2)

## 题意

一颗 $n$ 节点的二叉树，每个节点非黑即白，给你 $Q$ 次操作，每次给你一个 $u$，把 $u$ 的子树内所有节点颜色反转，问最终每个节点的颜色。

## 分析

看到数据范围，首先把操作离线。

容易发现如果一个节点重复操作奇数次，等效于操作一次，如果重复操作偶数次，等效于没操作。所以我们可以先把这 $Q$ 次操作用桶存一下，分别判断操作次数的奇偶性，根据上面的分析，可以同时用另一个桶表示该节点是否被操作。

然后从 $1$ 号节点开始遍历，因为一个节点的情况只会受其祖先的影响，所以同时用 $sum$ 记录当前节点的祖先的总操作数，根据奇偶判断当前节点的最终情况，最后输出即可。

一个小细节，每个节点的情况是以字符串形式读入，读入的时候不要读成数字。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=1e9+7;
const int maxn=1e6+10;
int n,Q;
vector<int> G[maxn];
int d[maxn];
int x[maxn],mp[maxn],y[maxn],tot;
bool f[maxn];
void dfs(int x,int fa,int sum)
{
	int v=0;
	if(y[x])v=1;
	if((sum+v)&1)f[x]=1;
	for(auto y : G[x])
	{
		if(y==fa)continue;
		dfs(y,x,sum+v);
	} 
}
signed main()
{
	cin>>n;
	for(int i=2;i<=n;i++)
	{
		int x=read();
		G[x].push_back(i);
		G[i].push_back(x);
	}
	for(int i=1;i<=n;i++)
	{
		char x;cin>>x;
		d[i]=x-'0';
	}
	Q=read();
	for(int i=1;i<=Q;i++)x[i]=read(),mp[x[i]]++;
	for(int i=1;i<=Q;i++)if(mp[x[i]]&1)y[x[i]]=1;
	dfs(1,0,0);
	for(int i=1;i<=n;i++)cout<<(f[i]?d[i]^1:d[i]);
	return 0;
}
```

---

## 作者：liyifan202201 (赞：2)

## 思路
首先，我们可以直接想到，对于每次操作，可以将 $a_i$ 的子树使用 dfs 遍历并取反；时间复杂度 $O(q * n)$

这肯定是超时的，我们可以考虑线段树的懒标记思想。
1. 每个节点只有取反和不取反两种操作；

2. 维护 $rf_x$ 表示以 $x$ 为根的子树是否需要取反；

3. $q$ 次询问，每一次用 $O(1)$ 的时间复杂度标记；

4. 跑一遍 dfs，从根节点开始下传标记；

5. 将 dfs 处理完的值输出

## 代码
```cpp
//具体思路在上面应该是很清楚的，建议用这个代码巩固具体思路。

#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
vector<int>nbr[N];
int wb[N],rf[N];
void dfs(int cur,int crf){
	if(crf==1){
		wb[cur]=!wb[cur];
	}
	for(auto i:nbr[cur]){
		dfs(i,(crf+rf[i])%2);
	}
}	
int main(){
	int n;
	cin>>n;
	for(int i=2;i<=n;i++){
		int a;
		cin>>a;
		nbr[a].push_back(i);
	}
	string s;
	cin>>s;
	for(int i=1;i<=n;i++){
		wb[i]=s[i-1]-'0';
	}
	int q;
	cin>>q;
	while(q--){
		int b;
		cin>>b;
		rf[b]=!rf[b];
	}
	dfs(1,rf[1]);
	for(int i=1;i<=n;i++){
		cout<<wb[i];
	}
}
```

---

## 作者：xinxin2022 (赞：0)

## 题意

有一棵每个节点仅有两种状态的二叉树，给出初始状态，对该二叉树进行 $q$ 次操作，每次操作给定节点 $a_i$，将 $a_i$ 的所有子树的所有节点的状态反转，问 $q$ 次操作完成后整棵二叉树每个节点的状态。

## 思路

### 暴力模拟

最简单的做法，每次都更改给出的 $a_i$ 的子树全部节点的状态，时间复杂度最坏为 $O(qn)$，可得 $40$ 分。

### 记录子树状态更改次数

可以第 $i$ 次操作时让统计更改状态次数的数组的第 $a_i$ 项加一，做完全部操作后进行一次深搜，更改所有被操作过的节点的状态。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> p[100005];
//存储树，使用vector可以避免定义用不到的变量，导致内存浪费
int n,q;
int r;
int cnt[100005];//统计每个节点的输入次数
int cou[100005];//记录初始状态
string s;
int ans[100005];//计算每个节点的全部操作次数
inline void dfs(int now){
    //inline是优化
    ans[now]+=cnt[now];//加上该节点本身被输入的次数
    for(int i=0;i<p[now].size();i++){
        ans[p[now][i]]+=ans[now];
        //子节点加上全部祖先的操作次数
        dfs(p[now][i]);
    }
}
int main(){
    cin>>n;
    for(int i=2;i<=n;i++){
        cin>>r;
        p[r].push_back(i);
        //建树
    }
    cin>>s;
    for(int i=0;i<s.size();i++) cou[i+1]=s[i]-'0';//记录初始状态
    cin>>q;
    for(int i=1;i<=q;i++){
        cin>>r;
        cnt[r]++; 
        //统计被输入的次数
    }
    dfs(1);//统计每个节点被操作的次数，也可以用BFS
    for(int i=1;i<=n;i++){
        cout<<(ans[i]+cou[i])%2;
        //输出最终状态
    }
    return 0;
}
```

时间复杂度是 $O(q+n)$ 的，可以拿到满分。

---

## 作者：Your_Name (赞：0)

### 题目大意
给一个以 $1$ 号节点为根的 $n$ 个节点的二叉树，每个节点有一个颜色（黑或者白），给出 $q$ 次操作，每次操作把以此节点为根的子树（含根）颜色反转。

最后输出 $1$ 号节点到 $n$ 号节点的颜色。

### 思路
很容易发现：

* 当一个节点被反转偶数次时，就相当于没反转。
* 操作的顺序不影响最后的结果。

因此，我们可以把每个节点的操作次数模上 $2$，在遍历时统计当前节点被反转的次数，若为奇数则反转，否则不反转。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, q, x;
int sum;            // 存这个节点被反转了几次
int c[N];           // 存颜色
int f[N];           // 存这个节点被操作了几次
vector<int> son[N]; // 二叉树没必要写，但加孩子比较方便
void dfs(int x, int fa)
{
    if (f[x])
        sum++;
    if (sum % 2)
    { // 是奇数就反转
        if (c[x] == 1)
            c[x] = 0;
        else
            c[x] = 1;
    }
    for (auto i : son[x])
    {
        if (i == fa)
            continue;
        dfs(i, x);
    }
    if (f[x])
        sum--;//回溯
}
int main()
{
    cin >> n;
    for (int i = 2; i <= n; i++)
    {
        cin >> x;
        son[x].push_back(i); // 加单向边即可
    }
    for (int i = 1; i <= n; i++)
    {
        char ss;
        cin >> ss;
        c[i] = ss - '0'; // 无空格，要这么输入
    }
    cin >> q;
    while (q--)
    {
        cin >> x;
        f[x]++;
    }
    for (int i = 1; i <= n; i++)
    {
        f[i] %= 2;
    }
    dfs(1, 0);
    for (int i = 1; i <= n; i++)
    {
        cout << c[i];
    }
    return 0;
}
```

---

## 作者：Spark_King (赞：0)

# P10722 二叉树 题解

## 题目分析

这道题要求对一个二叉树进行操作，因此很明显我们要先**处理出二叉树**。

我们对于每一个节点，都保存其**两个子节点的编号**（如果有），这样可以有助于我们**遍历二叉树**。

第二步，我们将原来的颜色存入数组。（常规操作）

对于修改操作，我们可以对**每一个节点进行标记**，然后在遍历二叉树的过程中**修改节点的颜色**并**将标记下传**。

### 关于标记

由于只有两种颜色，因此对于任意一个节点只有**修改**和**未修改**两种状态。在修改和标记下传的过程中，如果该节点已经有标记了，则**将标记去除**，表示再次修改。（因为将同一节点修改两次**等价于未修改**）

在遍历二叉树时，如果当前节点拥有标记，则**将其颜色修改并下传标记**。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n, q;
bool c[100010], f[100010];
pair<ll, ll> r[100010];//用于保存子节点
void dfs(ll p) {
	if (f[p]) {
		c[p] = !c[p];
		f[r[p].first] = !f[r[p].first];
		f[r[p].second] = !f[r[p].second];//修改并下传标记
	}
	if (r[p].first) dfs(r[p].first);
	if (r[p].second) dfs(r[p].second);//遍历子节点
	return;
}
int main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n;
	for (ll i = 2, fa; i <= n; i++) {
		cin >> fa;
		if (!r[fa].first) r[fa].first = i;
		else r[fa].second = i;
	}
	for (ll i = 1; i <= n; i++) {
		char a;
		cin >> a;
		c[i] = (bool)((ll)a - 48ll);//处理颜色
	}
	cin >> q;
	while (q--) {
		ll x;
		cin >> x;
		f[x] = !f[x];//处理标记
	}
	dfs(1);//从根节点开始遍历
	for (ll i = 1; i <= n; i++) cout << c[i];
	return 0;
}
```

---

## 作者：luuia (赞：0)

### 题目大意

给定一颗二叉树，每个节点有黑白两种颜色，每次操作改变一颗子树内所有点的颜色，求最终每个节点的颜色。

### Solution

暴力深搜是很容易想到的方法，每次询问直接挨个遍历改变颜色即可，但是这样的复杂度最坏是 $O(nq)$ 的，所以考虑优化。

我们发现一个节点如果改变两次就相当于没有改变，于是我们可以建出树来，每次给要改变的子树的根打上懒标记，在所有操作结束后再整棵树深搜一遍下传标记即可。

时间复杂度 $O(n+q)$，空间复杂度 $O(n)$，可以通过本题。

### Code

[AC 记录](https://www.luogu.com.cn/record/164812658)
```cpp
#include<bits/stdc++.h>
using namespace std;

long long read()
{
    long long s = 0,w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        s = (s << 1) + (s << 3) + (ch ^ 48);
        ch = getchar();
    }
    return s * w;
}

void write(long long a)
{
    if(a < 0) putchar('-'),a = -a;
    if(a > 9) write(a / 10);
    putchar(a % 10 + '0');
}

const int N = 1e6 + 10,inf = 2147483647;

long long n,a,x,y,z,fa,opt;

struct Tree
{

long long cnt,tot,root;
long long val[N],tag[N],son[N][2];//tag 表示翻转懒标记

void pushdown(int p)//下传懒标记
{
    if(tag[p])
    {
        if(son[p][0]) tag[son[p][0]] ^= 1;
        if(son[p][1]) tag[son[p][1]] ^= 1;
        val[p] ^= 1,tag[p] = 0;
    }
}

void dfs(int p)//整体深搜下传标记
{
    pushdown(p);
    if(son[p][0]) dfs(son[p][0]);
    if(son[p][1]) dfs(son[p][1]);
}

}tree;

int main()
{
    // freopen("input.in","r",stdin);
    cin >> n;
    for(int i = 2;i <= n;i++)//建树
    {
        cin >> fa;
        if(tree.son[fa][0] == 0) tree.son[fa][0] = i;
        else tree.son[fa][1] = i;
    }
    for(int i = 1;i <= n;i++) 
    {
        char ch;
        cin >> ch;
        tree.val[i] = ch - '0';
    }
    int q = read();
    while(q--)
    {
        x = read();
        tree.tag[x] ^= 1;
    }
    tree.dfs(1);//整体深搜
    for(int i = 1;i <= n;i++) cout << tree.val[i];//输出答案
    return 0;
}
```

---


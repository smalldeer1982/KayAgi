# 遍历问题

## 题目描述

我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：

![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)

所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。



## 样例 #1

### 输入

```
abc                           
cba
```

### 输出

```
4```

# 题解

## 作者：青丝、暮成雪 (赞：413)

只有一个儿子 的节点 才会在知道 前序后序 的情况下有不同的中序遍历，所以将题目转化成找 只有一个儿子的节点个数。

可以很容易的找出这类节点在前序后序中出现的规律。（前序中出现AB，后序中出现BA，则这个节点只有一个儿子）

每个这类节点有两种中序遍历（及儿子在左，儿子在右）根据乘法原理中序遍历数为 2^节点个数 种

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int ans;
char str1[233],str2[233];
int main()
{
        scanf("%s",str1);
        scanf("%s",str2);
        for(int i=0;i<strlen(str1);i++)
         for(int j=1;j<strlen(str2);j++)
          if(str1[i]==str2[j]&&str1[i+1]==str2[j-1])
           ans++;
        printf("%d",1<<ans);
        return 0;
}
```

---

## 作者：xzyxzy (赞：69)

##本题思路：

我们首先可以明确的是，在一棵树上若有一个结点是只有一个子结点的那么这个子结点在左在右不影响先序后序的遍历顺序，那么总树数就要乘以2（乘法原理，这个子结点有两种选择，一种成为左子树，一种成为右子树），为了找到只有一个子结点的结点数，我们继续。。

我们可以得到一个规律，在先序遍历中某一元素A的后继元素B，如果在后序遍历中A的前驱元素是B，那么A只有一个子树，问题即得解

然后为什么呢。。

楼下提醒了我，先序遍历中，如果A只有一个子树B，那么在先序遍历中A一定在B前，在后序遍历中B一定在A前，根据先序遍历和后序遍历的定义和性质可以看出，那么这样想到了的话，实现起来就简单了，大概是###O(n2)可以跑过

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
char a[10002],b[10002];//分别记录前序和后序 
int main()
{
            scanf("%s\n%s",&a,&b);
            int len=strlen(a),ans=1;
            for(int i=0;i<=len-2;i++)
                     for(int j=0;j<=len-1;j++)
                              if(b[j]==a[i]&&b[j-1]==a[i+1]) ans*=2;
            cout<<ans;
            return 0; 
}
```

---

## 作者：YuJieSong (赞：18)

给一篇string类的题解吧

string相比于char数组的优势：

可以直接cin，cout

内存动态申请

而且还有很多字符串常见操作的函数可以直接套用

回到本题的话，关键点在于找前序中相邻的两个字符在后序中有没有反转输出

那么我们就可以直接用一下string类的substr子字符串函数、reverse反转函数和find匹配函数啦

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    int i;
    long long c=1;
    string s1,s2,s3;
    cin >> s1 >> s2;
    for (i=0; i<s1.length()-1; i++) {
        s3 = s1.substr(i,2); // 截取相邻的两个字符串
        reverse(s3.begin(),s3.end()); // 反转
        if (s2.find(s3) != string::npos) c *= 2; // 匹配成功则总数*2
    }
    cout << c << endl;
}
```


---

## 作者：fl_334 (赞：18)

前->前序遍历      中->中序遍历         后->后序遍历

**思路：给定中能确定树的具体结构，是因为可以确定是左子树还是右子树，而之给定前和后，则不能确定，这就是会出现不同树结构的原因。**


只有 前和 后 那么主要问题就是没有办法处理只有一个子树の情况，因为 这种情况 不知道子树 究竟是这个节点的左子树还是右子树，也就是说其实这道题要判断遍历中存在着多少个只有一棵子树的情况。对于前，如果一个结点的下个结点等于后中对应结点的前一个结点的话，那么这个结点就是根节点且其只有一个子树。sum初始化为1，出现一个只有一棵子树的情况，就把sum\*2（每次会出现两种不同的情况，分别是出现左子树和出现右子树）。


还是蛮简单的

附AC代码

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
using namespace std;
int main()
{
    char s[255],s1[255];
    scanf("%s",s);
    scanf("%s",s1);
    int len=strlen(s);
    int sum=1,k=0;
    for (int i=0;i<=len-1;i++)
    {
        k=0;
        for (int j=0;j<=len;j++)
        if (s[i]==s1[j]) 
        {
            k=j;    
            break;                                              //找它在后序遍历中出现的位置。ps：c+没pos函数真心不爽
        }
        if ((k!=0)&&(s1[k-1]==s[i+1])) sum<<=1;          //判断成功就sum=sum<<1
    }
    cout<<sum;
}

```

---

## 作者：吴国铨 (赞：11)

考虑以A为根的树，S和S'分别表示其前序和后序遍历

根据两种遍历的特征我们有S=ALR，S'=L'R'A，其中L,L',R,R'分别为其左右子树的前后序遍历。

由于LR等价，所以当L为空或R为空的时候有F[S]=2F[LR]，此时LR[1]=L'R'[n]

当LR均不为空的时候，子树是确定的，由乘法原理F[S]=F[L]\*F[R]，其中L和R可以通过在L'R'中查找L[1]来确定。

边界：一个节点当然只有一种情况啦！

```cpp
var s1,s2:string;
function dp(s1,s2:string):longint;
    var i,p,L:longint;
    begin
      L:=length(s1);
      if L=1 then exit(1);
      delete(s1,1,1);
      delete(s2,L,1);
      dec(L);
      dp:=0;
      if s1[1]=s2[L] then dp:=2*dp(s1,s2)
         else begin
            p:=pos(s1[1],s2);
            dp:=dp(copy(s1,1,p),copy(s2,1,p))*dp(copy(s1,p+1,255),copy(s2,p+1,255));
         end;
    end;
begin
  readln(s1);
  readln(s2);
  writeln(dp(s1,s2));
end.
```

---

## 作者：YTand17 (赞：10)

我感觉是前中，后中遍历的变形题
```
	a	b	c
	c	b	a
```
首先得明确几个点：
- 因为前序遍历，头节点a的下一个点一定是他的子节点b 
  后序遍历，对于前序遍历的b，一定是以b为头节点的子树
  的后序遍历的最后一个位置。
（也就是对应着第一个序列的b的位置，和第二个序列的b位置） 

- 对于序列永远都是左子树的各节点遍历完，才到右子树的各节点

- 如果第二个序列以b结尾，之后就再也没有节点了
说明a节点，只有一个子节点，上面的样例就是这种情况。


------------
```
那么给一个不是这种情况的序列，找个规律：
	a	b	c
	b	c	a   这个序列的a就有两个子节点 
```
------------

- 采用第二个的结论，当只有一个子节点b的时候这个子节点无论在父节点a 
的左孩子，还是右孩子，对前序和后序遍历都不会有影响 所以这里就有
两种情况(k==2)了;那么有两个子节点的时候，根本动不了，所以只有一种情况



```cpp
#include<bits/stdc++.h>
using namespace std;
int flag[200];
char a[1001],b[1001];
int DFS(int sa,int ea,int sb,int eb){
	if(sa>=ea) return 1; //如果只有一个节点了，或者无节点就是一种情况 
	int len=flag[a[sa+1]]-sb+1,k=1; //len得到左子树序列节点的个数
	if(sa+len==ea) k=2;      //a[sa]这个节点只有一个子节点那么这个k==2 
	return (DFS(sa+1,sa+len,sb,sb+len-1) * DFS(sa+len+1,ea,sb+len,eb)) * k; //组合数
} 
int main(){
	scanf("%s%s",a,b);
	for(int i=0;b[i]!='\0';i++){
		flag[b[i]]=i; //标识每一个点在后序遍历序列中的什么位置 
	}
	printf("%d",DFS(0,strlen(a)-1,0,strlen(b)-1));//xu chu 
}
```


---

## 作者：封禁用户 (赞：9)

这其实是一道很简单题目，让我们来稍加分析。

首先由于二叉树的性质可知：答案必为2的次方（因为每一个不确定的节点都只可能成为左子节点或者右子节点这两种可能）

然后由先序遍历和后序遍历的性质可知：根节点（包括子树的根节点）都会位于先序遍历的最前方以及后序遍历的最后方

于是就有整体思路：

定义四个下标，分别进行递归操作

若遇到相等的情况则说明这个点是确定的，继续执行

若遇到不相等的情况则说明这个点是不确定的，ans\*=2

详细情况请参考程序：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
using namespace std;
int n,len1,len2;
char s1[401],s2[401];
int ans=1;
void dfs(int f1,int l1,int f2,int l2)
{
    int i,j;
    if(f1>l1)return;
    while(s1[f1]==';')f1++;
    while(s2[l2]==';')l2--;
    if(f1>l1)return;
    if(s1[f1]==s2[l2])
    {
        ans*=2;
        dfs(f1+1,l1,f2,l2-1);
    }
    else
    {
        for(i=f1+1;i<=l1;i++)
        if(s1[i]==s2[l2])
        {
            s1[i]=';';
            break;
        }
        for(j=f2;j<=l2-1;j++)
        if(s2[j]==s1[f1])
        {
            s2[j]=';';//本人就直接将它们修改为分号了，其实可以随意一点
            break;
        }
        dfs(f1+1,i-1,f2,j-1);
        dfs(i+1,l1,j+1,l2-1);
    }
}
int main()
{
    freopen("travel.in","r",stdin);
    freopen("travel.out","w",stdout);
    int i,j;
    cin>>s1>>s2;
    len1=strlen(s1);len2=strlen(s2);
    dfs(1,len1-1,0,len2-2);
    cout<<ans;
    return 0;
}
```

---


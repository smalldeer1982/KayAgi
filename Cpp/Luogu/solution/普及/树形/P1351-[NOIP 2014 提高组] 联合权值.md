# [NOIP 2014 提高组] 联合权值

## 题目背景

NOIP2014 提高组 D1T2

## 题目描述

无向连通图 $G$ 有 $n$ 个点，$n-1$ 条边。点从 $1$ 到 $n$ 依次编号,编号为 $i$ 的点的权值为 $W_i$，每条边的长度均为 $1$。图上两点 $(u, v)$ 的距离定义为 $u$ 点到 $v$ 点的最短距离。对于图 $G$ 上的点对 $(u, v)$，若它们的距离为 $2$，则它们之间会产生 $W_v \times W_u$ 的联合权值。

请问图 $G$ 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少？

## 说明/提示

**样例解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/5zkpab9k.png)

本例输入的图如上所示，距离为 $2$ 的有序点对有$(1,3)$ 、$(2,4)$ 、$(3,1)$ 、$(3,5) $、$(4,2)$ 、$(5,3) $。

其联合权值分别为 $2,15,2,20,15,20$。其中最大的是 $20$，总和为 $74$。

 
**数据说明**

- 对于 $30\%$ 的数据，$1 < n \leq 100$；
- 对于 $60\%$ 的数据，$1 < n \leq 2000$；
- 对于 $100\%$ 的数据，$1 < n \leq 2\times 10^5$，$0 < W_i \leq 10000$。

保证一定存在可产生联合权值的有序点对。

## 样例 #1

### 输入

```
5  
1 2  
2 3
3 4  
4 5  
1 5 2 3 10 ```

### 输出

```
20 74```

# 题解

## 作者：wucstdio (赞：301)

神一般的题……

经过了一整天的冥思苦想，终于AC了。

下面是思路：（99.9%都是自己想不出来，老师告诉我的）

1、联合的两个节点距离为二，所以必定有一个中转点。所以，我们可以枚举每一个中转点。（震惊！！！）

2、假设每个中转点周围有两个点，权值分别为a、b，则联合权值为2ab=(a+b)^2-(a^2+b^2)。

3、若有三个点，权值分别为a、b、c，则联合权值为2ab+2bc+2ac=(a+b+c)^2-(a^2+b^2+c^2)。

4、综上，以某个节点为中转点的联合权值之和等于权值和的平方减去权值的平方和。（+1！！！！！）

5、为了找到最大的联合权值，只需找到周围最大的两个权值max1，max2，相乘判断即可。

注意：虽然题目让%10007，但最大联合权值是不能%10007的！！！（40分WA的看这里！！）

下面是代码：

```cpp
#include<cstdio>
using namespace std;
struct edge
{
    int next;
    int to;
}a[400005];
int edgenum,head[200005],w[200005];
int n,ans,maxx;
void add(int u,int v)//加入一条从u到v的边
{
    a[++edgenum].next=head[u];
    a[edgenum].to=v;
    head[u]=edgenum;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v);
        add(v,u);
    }
    for(int i=1;i<=n;i++)
      scanf("%d",&w[i]);
    for(int i=1;i<=n;i++)
    {
        int max1=0,max2=0;//最大的两个权值
        int t1=0,t2=0;//t1代表和的平方，t2代表平方和
        for(int j=head[i];j;j=a[j].next)
        {
            if(w[a[j].to]>max1)max2=max1,max1=w[a[j].to];
            else if(w[a[j].to]>max2)max2=w[a[j].to];
            t1=(t1+w[a[j].to])%10007;
            t2=(t2+w[a[j].to]*w[a[j].to])%10007;
        }
        t1=t1*t1%10007;
        ans=(ans+t1+10007-t2)%10007;
        if(maxx<max1*max2)maxx=max1*max2;
    }
    printf("%d %d\n",maxx,ans);
    return 0;
}
```

---

## 作者：OIerWu_829 (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P1351)

抢个题解求过啊！

---

我们在输入过程中构建图的邻接表 $G$，然后对于每个节点 $i$，定义邻居节点权值之和 $pos$、最大权值 $mx$ 以及次大权值 $smx$，然后遍历 $i$ 的邻居节点，并更新权值之和，同时找到最大权值和次大权值，然后计算通过当前节点 $i$ 产生的联合权值中的最大值，并更新答案，然后再次遍历节点 $i$ 的邻居节点，通过 $pos$ 和当前邻居节点权值计算联合权值总和，并更新答案，最后输出答案。

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 2e5 + 5;
const int mod = 10007;

int a[N];
vector<int> G[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i < n; i++)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    int ans = 0, sum = 0;
    for (int i = 1; i <= n; i++)
    {
        int pos = 0, mx = 0, smx = 0;
        for (int u : G[i])
        {
            pos = (pos + a[u]) % mod;
            if (a[u] > mx)
            {
                smx = mx;
                mx = a[u];
            }
            else if (a[u] > smx) smx = a[u];
        }
        ans = max(ans, mx * smx);
        for (int u : G[i])
            sum = (sum + (pos - a[u]) * a[u]) % mod;
    }
    cout << ans << " " << sum;
    return 0;
}
```

---

## 作者：CaiZi (赞：4)

首先我们知道，一张 $n$ 个点 $n-1$ 条边的无向连通图是一颗树，而树上两点之间路径和距离是唯一的。我们现在要求所有距离为 $2$ 的点对 $(u,v)$，那么 $(u,v)$ 有唯一的一个中转点 $s$，满足存在 $u\to s$ 和 $s\to v$ 的边。

先考虑联合权值最大值，对于每个 $s$，我们求出连向 $s$ 的点的 $W_i$ 的最大值和非严格次大值（可以与最大值重复），相乘再取最大即可。

再考虑联合权值之和，我们枚举 $s$，求出连接向 $s$ 的点的集合 $T$，那么我们所有联合权值之和就是 $\sum_{i\in T}\sum_{j\in\land i<j}2\times W_i\times W_j$。回想一下初中数学的因式分解，可以发现这个值等于 $(\sum_{i\in T}W_i)^2-\sum_{i\in T}W_i^2$。所以我们对于每个 $s$，求出连向 $s$ 的点的 $W_i$ 的和以及平方的和即可。

注意联合权值最大值不需要取模。

时间复杂度 $O(n)$。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 10007
using namespace std;
int n,x,y,w[200001],a[200001],b[200001],c[200001],d[200001],s1,s2;
vector<int>g[200001];
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=1;i<=n;i++){
		x=y=0;
		for(int j:g[i]){
			if(w[j]>w[x]){
				x=j;
			}
		}
		for(int j:g[i]){
			if(w[j]>w[y]&&j!=x){
				y=j;
			}
		}
		s1=max(s1,w[x]*w[y]);
		x=y=0;
		for(int j:g[i]){
			x=(x+w[j])%mod;
			y=(y+w[j]*w[j])%mod;
		}
		s2=(s2+x*x%mod-y+mod)%mod;
	}
	cout<<s1<<' '<<s2;
	return 0;
}
```

---

## 作者：albertting (赞：4)

楼上大佬的淀粉质小蒟蒻不会（哭）。

那就来一篇十分简短（但是不易懂？）的题解吧！

### 推式子

首先我们可以发现，这张图有 $N$ 个节点和 $N - 1$，所以这张图实际上是一棵无根树，两点之间有唯一路径。

对于每一对 $(u, v)$，必然会有一点（就叫 $k$ 吧）在这两点之间。

所以对于每一个点 $k$，可产生联合权值：
$$
\sum\limits_{i=1}^m\sum\limits_{j=1}^m{w_i}{w_j}
$$
（$m$ 是与 $k$ 相邻的点的个数）

化简亿下：
$$
\begin{aligned}
\sum\limits_{i=1}^m\sum\limits_{j=1}^m{w_i}{w_j}
&=\sum\limits_{i=1}^m({w_i\sum\limits_{j=1}^m}{w_j})
\newline
&=(\sum\limits_{i=1}^m{w_i})(\sum\limits_{j=1}^m{w_j})
\newline
&=(\sum\limits_{i=1}^m{w_i})^2
\end{aligned}
$$

Clever OIer 肯定都看出来了：

照这么算，肯定会出现 $u = v$。

辣么，把多算的减掉就好了！

式子变成：
$$
(\sum\limits_{i=1}^m{w_i})^2-(\sum\limits_{i=1}^m{w_i^2})
$$

把所有的 $k$ 遍历一遍加起来，式子变成：

$$
\sum\limits_{k=1}^n((\sum\limits_{i=1}^{m_k}{w_i})^2-(\sum\limits_{i=1}^{m_k}{w_i^2}))
$$

大功告成！

哦对，还有 __最大值__！

对于每个 $k$，找一下与之相连的最大的 $w_u$ 和 $w_v$ 乘一下再和 `ans` 比个大小就好了！

### Code!

```cpp
#include <bits/stdc++.h>
#define __Made return
#define in 0
#define China__ ;
using namespace std;

int n;
int u, v;
vector<int> mp[200005];
long long w[200005];
long long ans1, ans2;

void solve(int x)
{
    long long max1 = 0, max2 = 0;
    long long sum1 = 0, sum2 = 0;
    for(auto i : mp[x])
    {
        if(w[i] >= max1) max2 = max1, max1 = w[i];
        else if(w[i] >= max2) max2 = w[i];
        sum1 += w[i];
        sum2 += w[i] * w[i];
    }
    ans1 = max(ans1, max1 * max2);
    ans2 += sum1 * sum1 - sum2;
    ans2 %= 10007;
}

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n - 1; i++)
    {
        scanf("%d %d", &u, &v);
        mp[u].push_back(v);
        mp[v].push_back(u);
    }
    for(int i = 1; i <= n; i++)
        scanf("%lld", &w[i]);
    for(int i = 1; i <= n; i++)
        solve(i);
    printf("%lld %lld", ans1, ans2);
    __Made in China__
}

```

---

## 作者：WsW_ (赞：3)

### 思路
和其他已有的题解似乎都不太一样。如果你做过图上倍增的题如[P3509 [POI2010] ZAB-Frog](https://www.luogu.com.cn/problem/P3509)，那么会更好理解本题解。  
本题解并不是从“中转点”这一角度出发推式子的。

连通图的边数比点数小 $1$，说明这个图是棵树。  
由于要求点对的距离为 $2$，我们考虑如何找到一对距离为 $2$ 的点。  
显然，我随便从一个点出发，随便往一条边走一步，再随便往一条边走一步，最后到达的点要么是**出发点**要么是**一个和出发点距离为 $2$ 的点**。  
假设从出发点出发走一步到达点 $u$，那把和点 $u$ 直接相连的所有点里面扣掉出发点，剩下的点就是和出发点距离为 $2$ 的点。剩下的每个点都会和出发点产生联合权值。  
同样，把和点 $u$ 直接相连的所有点的**点权和**里面扣掉出发点的点权，剩下的点权和就是和出发点距离为 $2$ 的点的点权和。剩下的点权和乘上出发点的点权就是这些点和联合权值和。  
所以可以对每个点预处理它直接相连的所有点的点权和。然后从每个点出发，和与它直接相连的点上面的点权和，去计算联合权值和。  
然后把这些联合权值和全部加起来就得到了所有的联合权值之和。  

接着再考虑怎样求最大值。  
还是同样的思路，假设从出发点出发走一步到达点 $u$，那把和点 $u$ 直接相连的所有点里面扣掉出发点，剩下的点就是和出发点距离为 $2$ 的点。剩下的每个点都会和出发点产生联合权值。 
在这些没被扣掉的点里面选择最大的，它就会和起点产生最大的联合权值。这些最大的联合权值里面再找最大的。  
扣掉的点有两种情况，一种是扣掉了原来的最大值，一种是没扣掉原来的最大值。如果扣掉了原来的最大值，那么原来的次大值就变成了最大值，所以预处理的时候还得存次大值。  

时间复杂度为 $O(n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
const int N=2e5+3;
const int m=1e4+7;

int n;
vector<int>edg[N];
int w[N];
pii mx[N][2];
int sum[N];
int asum,amax;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		int u,v; cin>>u>>v;
		edg[u].push_back(v);
		edg[v].push_back(u);
	}
	for(int i=1;i<=n;i++)cin>>w[i];
	
	for(int i=1;i<=n;i++){
		for(auto to:edg[i]){
			(sum[i]+=w[to])%=m;
			if(mx[i][0].first<=w[to]){//比最大值大
				mx[i][1]=mx[i][0];//最大值变次大值
				mx[i][0]={w[to],to};
			}
			else if(mx[i][1].first<=w[to])mx[i][1]={w[to],to};//比最大值小，且比次大值大，用它替换掉次大值
		}
	}
	
	for(int i=1;i<=n;i++){
		for(auto to:edg[i]){
			(asum+=w[i]*(sum[to]-w[i])%m)%=m;
			if(mx[to][0].second!=i)amax=max(amax,mx[to][0].first*w[i]);//没扣掉最大值
			else amax=max(amax,mx[to][1].first*w[i]);//扣掉了最大值
		}
	}
	cout<<amax<<' '<<asum;
	return 0;
}
```

---

## 作者：qhr2023 (赞：3)

## solution

先要知道有 $n$ 个点 $n-1$ 条边的无向联通图就是一棵树，显然，若树上两个点距离为 $2$，这两个点只能是**兄弟**或**祖孙**关系，这两个可以分开算。

我们先考虑第二问。设 $W_i$ 是 $i$ 点的权，$S_i$ 表示 $i$ 的子节点点权之和，$i$ 有 $k$ 个儿子。那么这部分兄弟对答案的贡献就是 $$\begin{aligned} \sum_{j=1}^k W_j \times (S_i-W_j) \end{aligned}$$，为了方便实现我们可以记录一个 $sum$ 累加点权，边加边乘，和这个式子是等价的。这部分祖孙对答案的贡献是 $$\begin{aligned} \sum_{j=1}^k W_i \times S_j \end{aligned}$$。

第一问是类似的。额外维护一个 $M_i$ 表示 $i$ 点最大儿子的权值，遍历时维护一个 $Max$ 表示当前最大权值，若 $j$ 是 $i$ 的儿子，兄弟间的答案就是 $W_j \times Max$ 的最大值，祖孙间的答案就是 $W_i \times M_j$ 的最大值。

$S$ 和 $M$ 都可以预处理，计算答案扫一遍树就行，时间复杂度 $\mathcal O(n)$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5, mod=10007;
long long n, w[200005], s[N], mx[N], ans1, ans2; 
vector<int> e[200005];
void dfs(int u, int fa){
	long long sum = 0, Max = 0;
	for (int i:e[u]) {
		if (i==fa)
			continue;
		dfs(i, u);
		s[u]=(s[u]+w[i])%mod;
		mx[u]=max(mx[u], w[i]);
		ans2=(ans2+w[u]*s[i]%mod+w[i]*sum%mod)%mod;
		ans1=max({ans1, w[u]*mx[i], w[i]*Max});
		sum=(sum+w[i])%mod;
		Max=max(Max, w[i]);
	}
}
int main () {
	cin >> n;
	for (int i=1, u, v; i<n; ++i)
		cin >> u >> v,
		e[u].push_back(v),
		e[v].push_back(u);
	for (int i=1; i<=n; ++i)
		cin >> w[i];
	dfs(1, 1);
	cout << ans1 << ' ' << 2*ans2%mod;
	return 0;
}
```

---

## 作者：oisdoaiu (赞：3)

~~淀粉质板子~~

看到这种关于点对距离的问题，怎么能少了~~淀粉质~~点分治呢

~~14页题解没有一篇淀粉，那我就来写一篇吧~~

---

## 思路

~~淀粉~~点分套路部分掠过，主要讲一下怎么处理过根的点对

对每个子树记录两个信息：$Sum[3],Max[3]$

$Sum[i]$表示（距离当前根节点距离为$i$的点）的权值和

$Max[i]$表示（距离当前根节点距离为$i$的点）的最大权值

然后再开两个数组$Pre\_Sum[3],Pre\_Max[3]$

$Pre\_Sum[i]$表示（**之前处理过的所有子树中**）（距离当前根节点距离为$i$的点）的权值和

$Pre\_Max[i]$表示（**之前处理过的所有子树中**）（距离当前根节点距离为$i$的点）的最大权值

## 计算答案
### 权值和
过根的贡献：
$$\sum_{\text{合法有序点对}(i,j)}val_i\cdot val_j$$
再变个样子：
$$\sum_ival_i\cdot\sum_{\text{能和}i\text{组成合法点对的}j}val_j$$
这个时候我们维护的$Pre\_Sum$数组就有用了，如果你还看不出来的话，再把上面的式子变个样子：
$$\sum_{\text{子树}v}(\sum_{\text{属于当前子树的点}i}val_i\cdot\sum_{\text{之前处理过的子树中能和}i\text{组成合法点对的}j}val_j)$$
然后你就会发现第三个$\sum$就是我们维护的$Pre\_Sum$，第二个$\sum$就是我们维护的$Sum$

### 最大权值
和*权值和的维护* 同理
### $Code$
```cpp
for(register int i=0; i<=2; i++){
	Max_Val = max(Max_Val,Pre_Max[i]*SubTree_Max[2-i]);
	Sum = (Sum+Pre_Sum[i]*SubTree_Sum[2-i]%MOD)%MOD;
}
```

## 维护
维护嘛……~~显然~~

直接上代码

### $Code$
```cpp
for(register int i=0; i<=2; i++){
	Pre_Max[i] = max(Pre_Max[i],SubTree_Max[i]);
	Pre_Sum[i] = (Pre_Sum[i]+SubTree_Sum[i])%MOD;
}
```
---
然后就是~~淀粉质~~点分治板子啦~

上代码

*$PS$：注意一下最后权值和要乘以2，因为之前计算的是无序点对，而题中给的是有序点对*
## $Code$


```cpp
#include<bits/stdc++.h>
using namespace std;

template<typename T>
inline void Read(T &n){
	char ch; bool flag=0;
	while(!isdigit(ch=getchar()))if(ch=='-')flag=1;
	for(n=ch^48;isdigit(ch=getchar());n=(n<<1)+(n<<3)+(ch^48));
	if(flag)n=-n;
}

typedef long long ll;
const int MAXN = 200005;
const ll MOD = 10007;

struct _{
	int nxt, to;
	_(int nxt=0, int to=0):nxt(nxt),to(to){}
}edge[MAXN<<1];
int fst[MAXN], tot;

inline void Add_Edge(int f, int t){
	edge[++tot] = _(fst[f], t); fst[f] = tot;
	edge[++tot] = _(fst[t], f); fst[t] = tot;
}

int n;
ll Max_Val, Sum, val[MAXN];
bool vis[MAXN], Centered[MAXN];

int Total_Size, Center, Min_Weight, sz[MAXN];
void Get_Center(int x){//找重心 
	vis[x] = true;
	
	sz[x] = 1;
	int Weight=0;
	
	for(register int u=fst[x]; u; u=edge[u].nxt){
		int v=edge[u].to;
		if(vis[v]==true or Centered[v]==true) continue;
		Get_Center(v);
		sz[x] += sz[v];
		Weight = max(Weight,sz[v]);
	}
	Weight = max(Weight,Total_Size-sz[x]);
	
	if(Weight<Min_Weight){
		Min_Weight = Weight;
		Center = x;
	}
		
	vis[x] = false;
}

ll SubTree_Sum[3]/*Sum数组*/, SubTree_Max[3]/*Max数组*/, Pre_Sum[3], Pre_Max[3];
void Work_SubTree(int x, int dis_root){//处理子树
	if(dis_root>2) return;
	vis[x] = true;
	
	SubTree_Sum[dis_root] = (SubTree_Sum[dis_root]+val[x])%MOD;
	SubTree_Max[dis_root] = max(SubTree_Max[dis_root], val[x]);
	
	for(register int u=fst[x]; u; u=edge[u].nxt){
		int v=edge[u].to;
		if(Centered[v]==true or vis[v]==true) continue;
		Work_SubTree(v,dis_root+1);
	}
	
	vis[x] = false;
}

void Divide(int x, int Size){//点分套路
	Min_Weight = n+1; Total_Size = Size;
	Get_Center(x);
	x = Center;
	Centered[x] = true;
	//Get Center
	
	memset(Pre_Sum,0,sizeof Pre_Sum);
	memset(Pre_Max,0,sizeof Pre_Max);
	Pre_Sum[0] = Pre_Max[0] = val[x];
	//Clear
	
	for(register int u=fst[x]; u; u=edge[u].nxt){
		int v=edge[u].to;
		if(Centered[v]==true) continue;
		
		memset(SubTree_Max,0,sizeof SubTree_Max);
		memset(SubTree_Sum,0,sizeof SubTree_Sum);
		//Clear
	
		Work_SubTree(v,1);
		//Dfs
		
		for(register int i=0; i<=2; i++){
			Max_Val = max(Max_Val,Pre_Max[i]*SubTree_Max[2-i]);
			Sum = (Sum+Pre_Sum[i]*SubTree_Sum[2-i]%MOD)%MOD;
		}
		//Calc Ans
		
		for(register int i=0; i<=2; i++){
			Pre_Max[i] = max(Pre_Max[i],SubTree_Max[i]);
			Pre_Sum[i] = (Pre_Sum[i]+SubTree_Sum[i])%MOD;
		}
		//Update
	}
	//Work SubTree
	
	for(register int u=fst[x]; u; u=edge[u].nxt){
		int v=edge[u].to;
		if(Centered[v]==true) continue;
		Divide(v,sz[v]);
	}
	//Solve SubTree
}

int main(){
	//Input
	Read(n);
	for(register int i=1; i<n; i++){
		int from, to;
		Read(from); Read(to);
		Add_Edge(from,to);
	}
	for(register int i=1; i<=n; i++) Read(val[i]);
	
	//Solve
	Divide(1,n);
	
	printf("%lld %lld\n",Max_Val, Sum*2%MOD);//注意乘以2
	return 0;
}
```


---

## 作者：yanxu_cn (赞：2)

特别提醒一下，要记得开 `long long`。因为一个 `long long` 调了半天，我也是醉了。

那么言归正传，我们可以轻易的发现这是一颗树。我们可以直接遍历每个节点，与其相连的节点之间的距离都为 $2$。那么我们可以直接计算任意两个节点的权值积，再对其求和即可得。

对于一个节点，求权值积的和的操作事实上是可以优化到 $\Theta(n)$ 的，这也是这道题的玄妙之处。

我们记对于一个节点其相邻节点的权值为数组 $e$，相邻节点的数目为 $k$。易于注意到的是我们要统计的其实是 $\displaystyle{(\sum_{i=1}^{k}s)^2-\sum_{i=1}^{k}s^2}$。

这样就将求和的步骤压缩到了 $\Theta(n)$。

这里可以再提一种思维上更简单的做法：

> 我们注意到其实求这个东西的瓶颈是在于求除掉一个数后数组中其他的数的和。那么我们可以预先将数组中所有数的和求出，每次计算去掉一个值即可。注意到这样则也可以优化到理想的复杂度。

对于最大值，对于每个节点只需考虑权值最大的两个点。STL 中的 `nth_element` 可以完成这个任务（当然直接快排一遍也无不可）。

那么这道题就做完了。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int maxn=2e5+7;
vector<int>ed[maxn];
constexpr int mod=10007;
int w[maxn];
inline long long max_ll(long long x,long long y)
{
	return x>y?x:y;
}
int main()
{
	long long n(readint()),allsum(0),allmax(0);
	for(int i=1;i<n;i++)
	{
		int u(readint()),v(readint());
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	for(int i=1;i<=n;i++)
	{
		w[i]=readint();
	}
	for(int i=1;i<=n;i++)
	{
		long long sum=0,biggest0=0,biggest1=0;
		for(int j=0;j<ed[i].size();j++)
		{
			sum+=w[ed[i][j]];
			allsum-=w[ed[i][j]]*w[ed[i][j]];
			if(w[ed[i][j]]>=biggest0)
			{
				biggest1=biggest0;
				biggest0=w[ed[i][j]];
			}
			else if(w[ed[i][j]]>=biggest1)
			{
				biggest1=w[ed[i][j]];
			}
		}
		allmax=max_ll(allmax,biggest1*biggest0);
		allsum+=sum*sum;
	}
	writeint(allmax);
	putchar(' ');
	writeint(allsum%10007);
	return 0;
}
```

---

## 作者：hwc2011 (赞：1)

观察此题，联合权值的要求是距离为 $2$，那么我们就可以枚举中转点，计算和它连接的各个节点之间的联合权值。  
本题有两个值要求，先看最大值，这个好做，每次枚举中转站时找出最大的两个权值，计算它们的联合权值，选取最大值即可，注意不要取模。  
接下来是总和，可以发现联合权值总和是被算了两遍的，所以我们可以先算一遍，使用乘法分配律优化，最终再乘以 $2$ 即可，注意要取模。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,u,v,w[200005];
vector<int>e[200005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d%d",&u,&v);
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i=1;i<=n;i++) scanf("%d",w+i);
	int maxx=-1,ans=0,mod=10007;
	for(int i=1;i<=n;i++){
		int sum=0,max1=-1,max2=-1;
		for(auto j:e[i]){
			ans=(ans+sum*w[j]%mod)%mod;
			sum=(sum+w[j])%mod;
			if(w[j]>max1){
				max2=max1;
				max1=w[j];
			}
			else if(w[j]>max2) max2=w[j];
		}
		maxx=max(maxx,max1*max2);
	}
	printf("%d %d",maxx,ans*2%mod);
}
```

---

## 作者：xiaohuang (赞：1)

[更好的阅读体验](https://xiaohuang888.github.io/2019/08/21/%E3%80%8E%E9%A2%98%E8%A7%A3%E3%80%8F%E6%B4%9B%E8%B0%B7P1351%20%E8%81%94%E5%90%88%E6%9D%83%E5%80%BC)

### Solution

我们先看一下题目：无向连通图$\mathrm G$有$n$个点，$n - 1$条边。

不难发现题目给出的是一颗树。

我们看一个例子：

![](https://s2.ax1x.com/2019/08/22/macLHP.png)

这个图的联合权值和为$W_2 \times W_3 + W_4 \times W_5 + W_4 \times W_6 + W_5 \times W_6 + W_7 \times W_8$。


![](https://s2.ax1x.com/2019/08/22/magjq1.png)

不难发现，我们求的是对于每一棵子树的非根节点的所有子结点两两相乘的权值和。但是我们对每一棵子树都遍历一遍显然要超时。我们可以找到如下性质：

$(a + b) ^ 2 = a ^ 2 + b ^ 2 + 2ab$

$(a + b + c) ^ 2 = a ^ 2 + b ^ 2 + c ^ 2 + 2ab+ 2ac + 2bc$

$(a + b + c + d) =  a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 + 2ab+ 2ac + 2ad + 2bc + 2bd + 2cd$

$\cdots \cdots$

我们要求的就是平方项后面的一半。就是 $\texttt{和的平方} - \texttt{平方的和}$ 。

统计最大值是只需要找出最大的两项，然后相乘就可以了。

这样就这道题就解决了。

### Code

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>

using namespace std;

typedef long long LL;
const int INF = 0x3f3f3f3f, MAXN = 400005, MAXM = 200005, mod = 10007;
struct EDGE {
    int to, nxt;
} edge[MAXN];
int n, u, v, cnt, w[MAXM], head[MAXN];
inline void addedge(int u, int v) {
    edge[++cnt].to = v; edge[cnt].nxt = head[u]; head[u] = cnt;
}
int main() {
    scanf("%d", &n);
    memset(head, -1, sizeof(head));
    for (int i = 1; i < n; i++) {
        scanf("%d%d", &u, &v);
        addedge(u, v); addedge(v, u);//加边
    }
    for (int i = 1; i <= n; i++)
        scanf("%d", &w[i]);
    LL Max = -INF, ans = 0;
    for (int i = 1; i <= n; i++) {
        LL Max1 = -INF, Max2 = -INF, tot1 = 0, tot2 = 0;//Max1表示最大的权值，Max2表示第二大的权值，tot1表示和的平方，tot2表示平方的和
        for (int j = head[i]; ~j; j = edge[j].nxt) {//遍历每一个点
            if (w[edge[j].to] > Max1) {
                Max2 = Max1;
                Max1 = w[edge[j].to];
            } else
            if (w[edge[j].to] > Max2 && w[edge[j].to] <= Max1) Max2 = w[edge[j].to];//找两个最大的
            tot1 += w[edge[j].to]; tot2 = (tot2 + w[edge[j].to] * w[edge[j].to]) % mod;//累计当前点的权值
        }
        tot1 = (tot1 % mod * tot1 % mod) % mod;//和的平方
        ans = (ans + tot1 - tot2 + mod) % mod;//累加答案
        Max = max(Max, Max1 * Max2);//找最大权值
    }
    printf("%lld %lld\n", Max, ans);
    return 0;
}
```

### Attachment

测试数据下载：https://www.lanzous.com/i5q1vdg

---

## 作者：Genius_Star (赞：0)

### 思路：

首先令 $1$ 为根，那么距离为 $2$ 的两个点 $u, v$ 当且仅当：

- $fa_u = fa_v$。

- 或者 $u = fa_{fa_v}$，即 $v$ 的父亲的父亲。

考虑对于这两个分别计算。

预处理 $s_u, Max_u$ 表示所有 $u$ 的儿子权值的和与最大儿子的权值，这样就可以计算第二种情况。

第一种情况扫儿子的时候维护一下前面扫过的权值和 $sum$ 和最大权值 $MAX$ 即可。

时间复杂度为 $O(N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
const int N = 2e5 + 10, mod = 1e4 + 7;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, u, v, ans1, ans2;
int a[N], s[N], Max[N];
vector<int> E[N];
inline void add(int u, int v){
	E[u].push_back(v);
	E[v].push_back(u);
}
inline void dfs(int u, int fa){
	int sum = 0, MAX = 0;
	for(auto v : E[u]){
		if(v == fa)
		  continue;
		dfs(v, u);
		s[u] = (s[u] + a[v]) % mod;
		Max[u] = max(Max[u], a[v]);
		ans2 = (ans2 + 1ll * a[u] * s[v] % mod) % mod;
		ans2 = (ans2 + 1ll * a[v] * sum % mod) % mod;
		ans1 = max(ans1, a[u] * Max[v]);
		ans1 = max(ans1, a[v] * MAX);
		sum = (sum + a[v]) % mod;
		MAX = max(MAX, a[v]);
	}
}
int main(){
	n = read();
	for(int i = 1; i < n; ++i){
		u = read(), v = read();
		add(u, v);
	}
	for(int i = 1; i <= n; ++i)
	  a[i] = read();
	dfs(1, 1);
	write(ans1);
	putchar(' ');
	write(ans2 * 2ll % mod);
	return 0;
}
```

---


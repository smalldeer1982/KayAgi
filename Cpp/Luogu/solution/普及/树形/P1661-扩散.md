# 扩散

## 题目描述

一个点每过一个单位时间就会向四个方向扩散一个距离，如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/cd4e53lw.png)

两个点 $a$ 、 $b$ 连通，记作 $e(a,b)$，当且仅当 $a,b$ 的扩散区域有公共部分。连通块的定义是块内的任意两个点 $u,v$ 都必定存在路径 $e(u,a_0),e(a_0,a_1),\cdots,e(a_k,v)$。给定平面上的 $n$ 个点，问最早什么时刻它们形成一个连通块。


## 说明/提示

### 数据范围及约定

对于 $20\%$ 的数据，满足 $1 \le N \le 5;1 \le X_i,Y_i \le 50$。

对于 $100\%$ 的数据，满足 $1 \le N \le 50$，$1 \le X_i,Y_i \le 10^9$。

## 样例 #1

### 输入

```
2
0 0
5 5```

### 输出

```
5```

# 题解

## 作者：封禁用户 (赞：65)

这题我拿二分答案+并查集做的，就是不断的二分时间，然后就要检测在这个时间内能不能成功形成连通块，我们用并查集来做：要是两点之间的曼哈顿距离（就是横纵坐标的差值和）不超过时间的**2倍**（这个地方很坑，因为两个点都能扩散，所以相对的扩散速度会增倍），那么就说明两个点能在一起然后就拿并查集连边，最后如果只有一个连通块就说明该时间合法，就向左区间去二分。
代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int xs[51];
int ys[51];//坐标
int ints[51];//并查集
int find(int n){
    if(ints[n]==n)return(n);
    return(ints[n]=find(ints[n]));
}
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++)cin>>xs[i]>>ys[i];
    int l=0,r=1000000000;
    int ans=0;//最终答案
    while(l<=r){
        int mid=(l+r)>>1;//二分答案
        for(register int i=0;i<n;i++){
            ints[i]=i;
        }//初始化并查集
        for(register int i=0;i<n;i++){
            for(register int j=i+1;j<n;j++){
               int dis=abs(xs[i]-xs[j])+abs(ys[i]-ys[j]);
               if(dis<=mid*2){//能扩散到就连边
                   int aa=find(i),ab=find(j);
                   if(aa!=ab)ints[aa]=ab;
               }
            }
        }
        int cnt=0;//连通块个数
        for(register int i=0;i<n;i++){
            if(ints[i]==i)cnt++;
        }
        if(cnt==1){
            ans=mid;
            r=mid-1;
        }//只有一个连通块就更新答案向下查找
        else{
            l=mid+1;
        }
    }
    cout<<ans<<endl;
    return(0);
}
```

---

## 作者：zzr8178541919 (赞：41)

本人感觉这道题并不需要那么麻烦的并查集和二分答案，当我看到题解里都是二分答案的时候，我蒙了。

#### 是我太菜了吗？？（好像是的）
仔细地分析这道题目，我认为题目的数据范围比较的友善。也就是说n三次方的暴力是完全可以过的。

### 现在我们仔细来读题：
一个点每过一个单位时间就会向四个方向扩散一个距离。

两个点a、b连通，记作e(a,b),当且仅当a、b的扩散区域有公共部分。连通块的定义是块内的任意两个点u、v都必定存在路径e(u,a0),e(a0,a1),…,e(ak,v)。给定平面上的n给点，问最早什么时刻它们形成一个连通块。

那么我们假设有两个点A，B，他们的坐标分别为（x1,y1）,（x2,y2）.那么现在我们要这两个点扩散，要多久的时间他们的扩散范围会相交呢？

### 答案是（它们的曼哈顿距离+1）/2;
让我们来证明一下：

我们假设x1<x2 并且 y1<y2。那么现在A和B想要相遇，它们肯定会尽量往对方的方向靠。
那么A点每扩散一次（假设B不动），他和B的曼哈顿距离都会减少1，那么B每次扩散一次（假设A不动），他与A的曼哈顿距离也会减少1。

#### 那么这说明什么呢？
嘿嘿！这就说明每次扩散A和B的曼哈顿距离都会减少2。
#### 1.如果曼哈顿距离（设其为dis）为奇数，那最后一次距离只差1。所以需要dis/2+1的时间，也就是（dis+1）/2;
#### 2,如果曼哈顿距离为偶数，那正好dis/2的时间后他们会正好相遇。而（dis+1）/2后对结果没有影响（因为是下取整）

## 接下来我们考虑有多个点的情况：
先假设有三个点A，B，C，他们的关系是A离B近，B离C近，由于是同时开始扩散的。

我们设AB用了t1秒相遇，BC用了t2秒相遇，如果不考虑B，设AC用了t3秒相遇。那显然会有min(t1,t2)<t3，

#### 为什么呢？
因为AB的曼哈顿距离或者BC的曼哈顿距离一定会小于AC的曼哈顿距离（因为B加在A和C的中间），由于是同时扩散，所以肯定是B这个中间节点将A和C更快地连接起来了。

那么拓展到多个节点，我们都希望每两个点都是被离它最近的点扩散到的，这样可以保证时间尽量的少。

#### 数据范围为50，发现可以用floyd直接处理出每两个点间的路径中。最大的一条路径是谁（显然只要走完了这条路径，其他的路径在哪之前就已经扩散完了）。

最后我们只需要n方枚举每两个节点，用ans更新最大值即可，找到的这个最大值就是答案。（因为这两个节点如果扩散完了，其他的节点肯定早就扩散完了）。

代码非常的短，也很好理解，AC代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
using namespace std;
struct vode
{
	int x;
	int y;
}a[105];
int place[105][105];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&a[i].x,&a[i].y);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		place[i][j]=1e9;
	}
	for(int i=1;i<=n-1;i++)
	{
		for(int j=1+i;j<=n;j++)
		{
			place[i][j]=place[j][i]=(abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y));
		}
	}
	for(int k=1;k<=n;k++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			place[i][j]=min(place[i][j],max(place[i][k],place[k][j]));
		}
	}
	int ans=0;
	for(int i=1;i<=n-1;i++)
	{
		for(int j=i+1;j<=n;j++)
		{
			ans=max(ans,place[i][j]);
		}
	}
	printf("%d\n",(ans+1)/2);
	return 0;
}
```




---

## 作者：AntaresQAQ (赞：32)

把题目要求转换一下，假设任意两点之间有边，相当于求所有点构成的最小生成树中最长的一条边。

把两点扩散连接的时长作为边的权值，开一个结构体存边，然后用kruskal算法求最小生成树，找到其中最长的边即可。








```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct edge
{
    int x,y,val;
}e[3000];
int father[3000];
int cnt,n,ans;
bool mycomp(edge x,edge y)
{
    return x.val<y.val;
}
void input()
{
    int x[51],y[51];
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>x[i]>>y[i];
    for(int i=1;i<=n;i++)
    {    
        for(int j=1;j<i;j++)//将边存入结构体中 
        {
            e[++cnt].x=i;
            e[cnt].y=j;
            int d=abs(x[i]-x[j])+abs(y[i]-y[j]);
            if(d&1) //扩散是双向的，所以求出两点的曼哈顿距离判断奇偶后求出时间 
                e[cnt].val=(d>>1)+1; 
            else 
                e[cnt].val=(d>>1);
        }
    }
}
int Find(int x) 
{
    int root=x;
    while(father[root]!=root)
        root=father[root];
    while(root!=x)
    {
        int temp=father[x];
        father[x]=root;
        x=temp;
    }
    return root;
}
void kruskal()
{
    int p=1;
    for(int i=1;i<=n;i++)
        father[i]=i;
    for(int i=1;i<=cnt;i++)
        if(Find(e[i].x)!=Find(e[i].y))
        {
            father[Find(e[i].x)]=Find(e[i].y);
            ans=max(e[i].val,ans);//寻找最大的边 
            p++;
            if(p==n)
                return ;
        }
    return ;
}
int main()
{
    input();
    sort(e+1,e+cnt+1,mycomp);//按边权值从小到大排序 
    kruskal();//并查集 
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：李小泽呵呵哒 (赞：24)

额，这道题好像直接用类似于Floyd的方法就可以过了耶


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,maxx;
int x[55],y[55];
int g[55][55];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>x[i]>>y[i];
    
	//计算点与点之间的初始距离
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            g[i][j]=abs(x[i]-x[j])+abs(y[i]-y[j]);
    
    //i和j可以通过k来连接，路径长度为两者到k的距离中更大的那个
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                g[i][j]=min(max(g[i][k],g[k][j]),g[i][j]);
                
    //寻找最大距离
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            maxx=max(maxx,g[i][j]);
            
    //注意要取上整，本人就因为这个WA了好几个点
    cout<<int(ceil(maxx*1.0/2));
    return 0;
}
```


---

## 作者：唔啊唔 (赞：10)

### ****此题本人的思路为：一次函数+排序+并查集****

由题意得，每个点往四个方向扩散，将四端点相连可得到四个一次函数。

当两点连通时，这两点的某一条函数会重合（这条函数可依据两点的位置关系判断）。

**以下列举一种情况：**

![](https://cdn.luogu.com.cn/upload/pic/58908.png )

当他们连通时函数（A1，A2）会与函数（B4，B3）重合。

![](https://cdn.luogu.com.cn/upload/pic/58909.png)

你可以试试不会有错。

**列举四个函数：**
设A(a,b)

所以A1(a-t,b),A2(a,b-t),A3(a+t,b),A4(a,b+t)

函数（A1，A2）=-x+b+a-t

函数（A2，A3）=x+b-a-t

函数（A3，A4）=-x+b+a+t

函数（A1，A4）=x+b-a+t

接下来便是用所用的t来排序

再用并查集来计算形成连通块的时间

接下来就是代码实现了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[100],y[100],cnt,father[100],cnt2=1;
struct Node{
	int t,a,b;
}wrx[3000];
inline int v(Node q,Node w){
	return q.t<w.t;
}
inline int findd(int x){
	if(x!=father[x]){
		father[x]=findd(father[x]);
	}
	return father[x];
}
inline void bcj(){
	for(int i=1;i<=cnt;i++){
		int q=findd(wrx[i].a),w=findd(wrx[i].b);
		if(q!=w){
			father[q]=w;
			cnt2++;
			if(cnt2==n){	//当每个点都连通时输出t,结束 
				cout<<wrx[i].t;
				return;
			}
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)father[i]=i;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
	}
	for(int i=1;i<=n;i++){	//关键代码 
		for(int j=i+1;j<=n;j++){
			cnt++;
//		    判断位置关系 
			if(x[i]==x[j]){	//此时是两个端点会相遇 
				wrx[cnt].t=abs(y[i]-y[j])*0.5+0.5;
			}
			else if(y[i]==y[j]){//同上 
				wrx[cnt].t=abs(x[i]-x[j])*0.5+0.5;
			}
			else{//依据位置关系判断哪两条函数会重合 
				//自己仔细想想，在此不多做解释 
				if(x[i]>x[j]){
					if(y[i]>y[j]){
						wrx[cnt].t=(x[i]+y[i]-x[j]-y[j])*0.5+0.5;
					}
					else{
						wrx[cnt].t=(y[j]-x[j]+x[i]-y[i])*0.5+0.5;
					}
				}
				if(x[i]<x[j]){
					if(y[i]>y[j]){
						wrx[cnt].t=(x[j]-y[j]-x[i]+y[i])*0.5+0.5;
					}
					else{
						wrx[cnt].t=(y[j]-x[i]-y[i]+x[j])*0.5+0.5;
					}
				}
			}
			wrx[cnt].a=i;
			wrx[cnt].b=j;
		}
	}
	sort(wrx+1,wrx+1+cnt,v);
	bcj();
	return 0;	//谢谢观赏 
}
```


---

## 作者：Reanap (赞：6)

看到这道题一眼就能看出这是一道二分答案的题，显而易见，二分时间，但是我们怎么判断是否满足条件？

首先，这些点呈菱形扩散，那么如果两点在2t个单位时间能相遇，那么两点的曼哈顿距离 < t

第二，我们可以用并查集来判断两点是否联通

```cpp

#include <cstdio>
#include <cmath>
struct node {
	int x , y;
}a[1005];
int f[1005];
int n;
bool c(int x , int y , int z) {return ((fabs(a[x].x - a[y].x)+ fabs(a[x].y - a[y].y)) <= z);}
int getf(int v) {return v == f[v]?f[v]:f[v] = getf(f[v]);}
bool check(int x) {
	int cnt = 0;
	for (int i = 1; i <= n; ++i) f[i] = i;
	for (int i = 1; i <= n; ++i) for (int j = i + 1; j <= n; ++j) if(c(i , j , x * 2) && getf(j) != getf(i)) f[getf(j)] = getf(i);
	for (int i = 1; i <= n; ++i) if(f[i] == i) cnt ++;
	return (cnt == 1);
}
int main() {
	
	scanf("%d" , &n);
	for (int i = 1; i <= n; ++i) scanf("%d %d" , &a[i].x , &a[i].y);
	int l = 0 , r = 1e9 , ans = 0; // 二分时间，在1e9个单位时间内一定能相遇
	while(l <= r) {
		int mid = (l + r) / 2;
		if(check(mid)) ans = mid , r = mid - 1; // 如果在mid个单位时间能相遇则移动右边界，记录答案，寻找更优答案
		else l = mid + 1;// 否则证明时间小了，寻找答案
	}
	printf("%d" ,ans);
	return 0;
}
```

---

## 作者：ღ﹏ﻬ北❦栀 (赞：5)

预处理任意两初始坐标之间的距离。若t秒时可以汇聚，那么超过t秒时肯定也能汇聚，因此考虑二分答案。
二分的左边界为0，观察到可能的最远距离（ 0,0 ）到（1e9 ,1 e9 ），因此 二分 的右边 的右边 界为（ 1e9+1e9  ）/2 =1e9。每次取到中点mid 后，从任意一个点出发尝试遍历所有点 ，a能够到达点b的条件一定是a到b的距离不超过2倍的mid值。如果能够成功遍历所有点，说明当前 mid 符合条件，反之则不符合条件。

下面附代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;

int n,dis[55][55],l,r=1e9,mid;
int pd[55],q[55],hd,tl;
struct node
{
    int x,y;
}p[55];//结构体用来存坐标
bool check(int mid)//判断2分中点
}
{
    int cnt=1;
    memset(pd,0,sizeof(pd));//先清零数组
    hd=0,tl=1;
    q[1]=1;
    pd[1]=1;
    while(hd^tl)//利用异或来判断
    {
        ++hd;
        for(int i=1;i<=n;++i)
        {
            if(pd[i])continue;
            if(dis[q[hd]][i]<=mid*2)pd[i]=1,q[++tl]=i;
        }
    }
    return tl==n;

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    scanf("%d%d",&p[i].x,&p[i].y);
    for(int i=1;i<n;++i)
    for(int j=i+1;j<=n;++j)
    dis[i][j]=dis[j][i]=abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y);
    while(l+1<r)
    {
    	mid=l+r>>1;
    	if(check(mid))r=mid;//指针向右移
    	else l=mid;//指针向左移动
    }
    printf("%d",r);
    return 0; 
}
```
代码就这样了，希望大家喜欢。谢谢Thanks♪(･ω･)ﾉ，如果有好的方法可以教教蒟蒻。

---

## 作者：VioletIsMyLove (赞：3)

这题目刚一入手，会认为这看起来像是一道模拟题，但题目读到它是要求在最短的时间内联通就会明白这是一道典型的最小生成树。

但是这题2点之间的距离有点难处理，但仔细一想就会发现距离就是$(abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y)+1)/2$,这题就轻松解决掉了。

Prim:
```cpp
#include<bits/stdc++.h>
#define maxn 2005
using namespace std;
struct ZS{
	int x,y;
} a[maxn];
int n,dis[maxn],g[maxn][maxn],ans;
bool vis[maxn];
void Prim(){
	for (int i=1;i<=n;i++)
	for (int j=i;j<=n;j++) g[i][j]=g[j][i]=(abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y)+1)/2;
	for (int i=1;i<=n;i++) dis[i]=g[1][i];
	vis[1]=1;
	for (int i=1;i<n;i++){
		int Min=1e9,k;
		for (int j=1;j<=n;j++)
		  if (!vis[j]&&dis[j]<Min) Min=dis[j],k=j;
		ans=max(ans,dis[k]),vis[k]=1;
		for (int j=1;j<=n;j++)
		  if (!vis[j]&&g[k][j]<dis[j]) dis[j]=g[k][j];
	}
}
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d%d",&a[i].x,&a[i].y);
	Prim();
	printf("%d\n",ans);
	return 0;
}
```


Kruskal:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct ZS{
	int x,y,w;
	bool operator <(const ZS b)const{return w<b.w;}
}a[4000005];
int n,len,ans;
int fa[4000005];
int b[2][2005];
int getfa(int x){
	int y=x;
	if(x!=fa[x])x=getfa(fa[x]);
	return fa[y]=x;
}
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){b[0][i]=read();b[1][i]=read();}
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)a[++len]=(ZS){i,j,((abs(b[0][i]-b[0][j])+abs(b[1][i]-b[1][j]))+1)/2};
	for(int i=1;i<=n;i++)fa[i]=i;
	sort(a+1,a+1+len);
	for(int i=1;i<=len;i++){
		int fx=getfa(a[i].x),fy=getfa(a[i].y);
		if(fx!=fy)fa[fx]=fy,ans=a[i].w;
	}
	printf("%d\n",ans);
	return 0;
}
```

换个角度思考，这道题是要求最短时间内联通，最大值中求最小，典型的二分来枚举结束的时刻，也可以$n(logn)$解下来，代码就不配了。

蒟蒻的第3篇题解，求过。

---

## 作者：s_ShotღMaki (赞：3)

## NO1 关于思路

鲁迅曾经说过：“在很多题里面，图是隐性的。”

这道题验证了~~鲁迅先生的说法~~，其实也不是隐性图啦...（没有误导人的意思）

这道题是同机房一[退役省队爷](https://www.luogu.org/space/show?uid=36465)在班车上给的思路

当我看到题解有一点撞有一丢丢伤心呢

**“看到这样的题目就想写模拟吗？”他问道“你错了。”**

显然，一点一点的去推肯定是要超时的，因此我们对其进行建图

看到联通块，大家都会想到最小生成树吧，但问题来了，我们怎么样才能利用我们可爱的最小生成树呢？首先我们会知道，我们将通过输入而得到若干个点，如果把他们全部用边连起来，获得每个点之间的距离，再跑一下最小生成树，看看连上的时候一共用了多少个单位的时间就好了

还有一个问题就是，我们怎么样得到时间。显然此图有很多条边，但是是每一个点同时向外扩展的，因此我们可以求出最小生成树中最长的边，其长度也就是我们连完所有边所用掉的时间了。

我们先得到大体的思路

**输入 -> 建图 -> 跑最小生成树求最长边 -> 输出答案**

## NO2 关于代码

**1输入**

```cpp
n = read ();
for (int i = 1; i <= n; i ++) x[i] = read (), y[i] = read ();
```
**2建图**

```cpp
void This_is_for_you ()
{
	for (int i = 1; i <= n; i ++)
	  for (int j = 1; j < i; j ++)
		{
			if (i == j) continue;//如果两点是一个点就直接continue
			else
			{
				edge[++ cnt].q = i;
				edge[cnt].z = j;
				int heng = abs (x[i] - x[j]);//heng向距离
				int zong = abs (y[i] - y[j]);//zong向距离
				if ( (heng + zong) % 2 == 0) edge[cnt].v = heng + zong >> 1;
				else edge[cnt].v = (heng + zong >> 1) + 1;
			}
		}
}
```
**3最小生成树**

```cpp
void So_go_and_do_it ()
{
	int num = 0;//连好的边的数目
	for (int i = 1; i <= cnt; i ++)//所有的边
	{
		int p1 = edge[i].q; int p2 = edge[i].z;
		int f1 = find (p1); int f2 = find (p2);//找爸爸
		if (f1 == f2) continue;//如果相等直接continue
		f[f1] = f2;
		ans = max (ans, edge[i].v);//找出最长的边作为ans
		num ++;//
		if (num == n - 1) return ; //如果边的数目等于点的数目 + 1那么就是连完边了
	}
}
```
### 放一下完整代码

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>

#define WA AC
#define TLE AC
#define MLE AC
#define RE AC
#define CE AC
#define maxn 55

using namespace std;

inline int read ()
{
    int f = 1, x = 0;
    char ch;
    do {ch = getchar (); if (ch== '-') f = -1;} while (ch < '0' || ch > '9');
    do {x = x * 10 + ch - '0'; ch = getchar ();} while (ch >= '0' && ch <= '9');
    return f * x;
}

struct node
{
	int q, z, v; 
} edge[23333];

int n;
int a, b;
int cnt;
int f[maxn];
int x[maxn], y[maxn];
int ans;

void This_is_for_you ()
{
	for (int i = 1; i <= n; i ++)
	  for (int j = 1; j < i; j ++)
		{
			if (i == j) continue;
			else
			{
				edge[++ cnt].q = i;
				edge[cnt].z = j;
				int heng = abs (x[i] - x[j]);
				int zong = abs (y[i] - y[j]);
				if ( (heng + zong) % 2 == 0) edge[cnt].v = heng + zong >> 1;
				else edge[cnt].v = (heng + zong >> 1) + 1;
			}
		}
}

bool cmp (node a, node b)
{
	return a.v < b.v;
}

int find (int x)
{
	if (x == f[x]) return x;
	return f[x] = find (f[x]);
}

void So_go_and_do_it ()
{
	int num = 0;
	for (int i = 1; i <= cnt; i ++)
	{
		int p1 = edge[i].q; int p2 = edge[i].z;
		int f1 = find (p1); int f2 = find (p2);
		if (f1 == f2) continue;
		f[f1] = f2;
		ans = max (ans, edge[i].v);
		num ++;
		if (num == n - 1) return ; 
	}
}

int main ()
{
	n = read ();
	for (int i = 1; i <= n; i ++) x[i] = read (), y[i] = read ();
	This_is_for_you ();
	for (int i = 1; i <= n; i ++) f[i] = i;
	sort (edge + 1, edge + cnt + 1, cmp);
	So_go_and_do_it ();
	printf ("%d", ans);
	return 0;
}
```

个人觉得这个题的思路不是很好像，因此评了个绿题



---

## 作者：HolseLee (赞：2)

题解里貌似没有用最短路的做法做的，这里蒟蒻就提供一份用floyd做的题解，思路基本相同，先求每两点之间的曼哈顿距离，然后floyd松弛，还是直接看代码吧：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
ll n,f[55][55],ans;
struct Point{
  ll x,y;
}p[55];
inline ll read()
{
  char ch=getchar();ll num=0;bool flag=false;
  while(ch<'0'||ch>'9'){if(ch=='-')flag=true;ch=getchar();}
  while(ch>='0'&&ch<='9'){num=num*10+ch-'0';ch=getchar();}
  return flag?-num:num;
}
void ready()
{
  n=read();
  for(int i=1;i<=n;i++)
    {p[i].x=read();p[i].y=read();}
}
inline ll Abs(int x)
{return x>=0?x:-x;}
inline ll getman(int i,int j)
{
  ll ka=Abs(p[i].x-p[j].x);
  ll lu=Abs(p[i].y-p[j].y);
  return (ka+lu);
}
void work()
{
  for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
      if(i!=j)f[i][j]=(getman(i,j)+1)/2;
  for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
    if(i!=j&&j!=k&&i!=k)
      f[i][j]=min(f[i][j],max(f[i][k],f[k][j]));
  for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
      if(i!=j)ans=max(ans,f[i][j]);
  cout<<ans<<endl;
}
int main()
{
  ready();work();return 0;
}

```

---

## 作者：sss7020 (赞：1)

# 《扩散》 题解

题目：loj10015 / luogu1661

可以将算法流程分为2部分：  
1. 计算点之间的距离，建图
2. 对图进行处理

## 1.计算点之间的距离
可以令点之间的距离为两点之间的[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092)$x$，则两点重合需要$\lceil x / 2 \rceil$，代码写成：

```cpp
(x + 1) / 2
```

原因：
> 点A和点B要想重合，A尽量要往B靠，同时B尽量要往A靠，两者会消耗两个曼哈顿距离

以两点之间曼哈顿距离为路径长度，任意两点连边建图

## 2.对图进行处理

介绍三种方法：

### 1.二分答案+并查集
二分枚举答案，若两点之间重合需要时间小于枚举的答案时，并查集连边。最后图是否连通即可。

代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 60;

struct Edge{
    int u, v, w;
    Edge(int u = 0, int v = 0, int w = 0): u(u), v(v), w(w){}
} G[MAXN * MAXN];

struct Node{
    int x, y;
    Node(int x = 0, int y = 0): x(x), y(y){}
} a[MAXN];

int n;
int cnt = 0;
int fa[MAXN];

inline int read(){
    int x = 0,f = 1, c = getchar();
    while(!isdigit(c)) f = (c == '-' ? -f : f), c = getchar();
    while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
    return x * f;
}

int Find(int x){
    return x == fa[x] ? x : fa[x] = Find(fa[x]);
}

inline void Merge(int x, int y){
    int fx = Find(x), fy = Find(y);
    fa[fx] = fa[fy];
}

inline bool check(int x){
    for(register int i = 1; i <= n; ++i) fa[i] = i;
    for(register int i = 1; i <= cnt; ++i){
        if(G[i].w <= x * 2) Merge(G[i].u, G[i].v);
    }
    int p = Find(1);
    for(register int i = 2; i <= n; ++i){
        if(Find(i) != p) return false;
    }
    return true;
}

int main(){
    n = read();
    for(register int i = 1; i <= n; ++i)
        a[i].x = read(), a[i].y = read();
    for(register int i = 1; i <= n; ++i){
        for(register int j = 1; j <= n; ++j)
            if(i != j)
                G[++cnt] = Edge(i, j, abs(a[i].x - a[j].x) + abs(a[i].y - a[j].y));
    }
    int l = 0, r = 2e9, ans;
    while(l <= r){
        int mid = l + r >> 1;
        if(check(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    printf("%d\n", ans);
    return 0;
}
```

### 2.最小生成树

不难发现，如果这样建图，那么答案其实是求最小瓶颈生成树的瓶颈。由于[最小生成树是最小瓶颈生成树](https://baike.baidu.com/item/%E7%93%B6%E9%A2%88%E7%94%9F%E6%88%90%E6%A0%91/2397900)，所以只要求最小生成树的最大的边即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 60;

struct Edge{
    int u, v, w;
    Edge(int u = 0, int v = 0, int w = 0): u(u), v(v), w(w){}
    friend bool operator < (const Edge &x, const Edge &y){
        return x.w < y.w;
    }
} G[MAXN * MAXN];

struct Node{
    int x, y;
    Node(int x = 0, int y = 0): x(x), y(y){}
} a[MAXN];

int n;
int cnt = 0;
int fa[MAXN];

inline int read(){
    int x = 0,f = 1, c = getchar();
    while(!isdigit(c)) f = (c == '-' ? -f : f), c = getchar();
    while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
    return x * f;
}

int Find(int x){
    return x == fa[x] ? x : fa[x] = Find(fa[x]);
}

inline void Merge(int x, int y){
    int fx = Find(x), fy = Find(y);
    fa[fx] = fa[fy];
}

inline void solve(){
    for(register int i = 1; i <= n; ++i) fa[i] = i;
    int t = 0;
    for(register int i = 1; i <= cnt; ++i){
        Edge &edge = G[i];
        if(Find(edge.u) == Find(edge.v)) continue;
        Merge(edge.u, edge.v);
        if(++t == n - 1){printf("%d\n", (edge.w + 1) / 2); exit(0);}
    }
}

int main(){
    n = read();
    for(register int i = 1; i <= n; ++i)
        a[i].x = read(), a[i].y = read();
    for(register int i = 1; i <= n; ++i){
        for(register int j = 1; j <= n; ++j)
            if(i != j)
                G[++cnt] = Edge(i, j, abs(a[i].x - a[j].x) + abs(a[i].y - a[j].y));
    }
    sort(G + 1, G + cnt + 1);
    solve();
    return 0;
}
```

### 3. floyd
这一题的数据规模较小，所以可以使用floyd算法。  
此题是floyd算法的变形。

floyd算法模板：
```cpp
for(register int k = 1; k <= n; ++k)
    for(register int i = 1; i <= n; ++i)
        for(register int j = 1; j <= n; ++j)
            if(i != j && i != k && j != k)
                G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
```

此题的floyd算法：
```cpp
    for(register int k = 1; k <= n; ++k)
        for(register int i = 1; i <= n; ++i)
            for(register int j = 1; j <= n; ++j)
                if(i != j && i != k && j != k)
                    G[i][j] = min(G[i][j], max(G[i][k], G[k][j]));
```

原因：
> floyd算法的基本思想是dp，若点i到点j通过点k，那么点i到点j的距离就是点i到点k的距离加上点k到点j的距离。然而由于此题特殊，要求两点连通，两点之间的距离会同时缩小，所以是取最大值。

最后只需要找到两点连通的最大值即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 60;

pair<int, int> dot[MAXN];
int n;
int G[MAXN][MAXN];

inline int read(){
    int x = 0,f = 1, c = getchar();
    while(!isdigit(c)) f = (c == '-' ? -f : f), c = getchar();
    while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
    return x * f;
}

int main(){
    int n = read();
    for(register int i = 1; i <= n; ++i){
        int x = read(), y = read();
        dot[i] = make_pair(x, y);
    }
    for(register int i = 1; i <= n; ++i)
        for(register int j = i + 1; j <= n; ++j)
            G[i][j] = G[j][i] = abs(dot[i].first - dot[j].first) + abs(dot[i].second - dot[j].second);
    for(register int k = 1; k <= n; ++k)
        for(register int i = 1; i <= n; ++i)
            for(register int j = 1; j <= n; ++j)
                if(i != j && i != k && j != k)
                    G[i][j] = min(G[i][j], max(G[i][k], G[k][j]));
    int ans = 0;
    for(register int i = 1; i <= n; ++i)
        for(register int j = 1; j <= n; ++j)
            if(i != j) ans = max(ans, G[i][j]);
    printf("%d\n", (ans + 1) / 2);
    return 0;
}
```
这种算法时间复杂度相对较高，但是依然值得学习。

---

## 作者：liyichun001 (赞：0)

思路：
## 任意两点的距离为两点间的曼哈顿距离。
假设任意两点间有边，那么问题就转换为求所有点构成的最小生成树中**最长的边+1 再除以 2，** 因此 **利用 Kruskal** 求出最小生成树，找到其中最长边即可
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define LL long long
const int MOD = 1E9+7;
const int N = 1000000+5;
using namespace std;
struct Edge{
    int x,y;
    int dis;
    Edge(){}
    Edge(int x,int y,int dis):x(x),y(y),dis(dis){}
    bool operator < (const Edge &rhs)const{
        return dis<rhs.dis;
    }
}edge[N];
struct Node{
    int x,y;
    Node(){}
    Node(int x,int y):x(x),y(y){}
}node[N];
int tot;
int father[N];
int getDis(int i,int j){
    return abs(node[i].x-node[j].x)+abs(node[i].y-node[j].y);
}
int Find(int x){
    return father[x]==x?x:father[x]=Find(father[x]);
}
int Kruskal(int n){
    for(int i=1;i<=n;i++)
        father[i]=i;
    int num=0;
    int res=-INF;
    for(int i=1;i<=tot;i++){
        int x=edge[i].x;
        int y=edge[i].y;
        x=Find(x);
        y=Find(y);
        if(x!=y){
            res=max(res,edge[i].dis);
            num++;
            father[x]=y;
        }
        if(num==n)
            break;
    }
    return res;
}
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&node[i].x,&node[i].y);
 
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            edge[++tot].x=i;
            edge[tot].y=j;
            edge[tot].dis=getDis(i,j);
        }
    }
    sort(edge+1,edge+1+tot);
    int res=Kruskal(n);
    printf("%d\n",(res+1)/2);
    return 0;
}

---

## 作者：lytqwq (赞：0)

P1661 扩散：[https://www.luogu.org/problemnew/show/P1661](https://www.luogu.org/problemnew/show/P1661)

题目很容易让人联想到[P1111 修复公路](https://www.luogu.org/problemnew/show/P1111)，这是一道最小生成树的水题。
和P1111的区别 只是 多对输入数据处理一下。


对于输入的点，我们求出他们之间的距离s，为“一个点每过一个单位时间就会向四个方向扩散一个距离”，所以用的时间就是(s+1)/2，用Kruskal算法求最小生成树就行了

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define N 51

int n;
int x[N],y[N],father[N],top=0,maxn;

struct d{
	int x,y,co;
	bool operator < (const d x) const
	{
		return co < x.co;
	}
}qwq[N*N];//存边


int wyh(int xx,int yy)
{
	return abs(x[xx]-x[yy])+abs(y[xx]-y[yy]);//两点之间的距离 
}



int find(int x)
{
	if(father[x]!=x)
	{
		father[x]=find(father[x]);//路径压缩 
	}
	return father[x];
}
void join(int x,int y)
{
	int fx=find(x),fy=find(y);
	father[fx]=fy;
	return ;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i];
		father[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		for(int o=i+1;o<=n;o++)
		{
			top++;
			qwq[top].x=i;
			qwq[top].y=o;
			qwq[top].co=wyh(i,o);
		}
	}
	sort(qwq+1,qwq+top+1);
	for(int i=1,o=1;i<=top,o<=n-1;i++)
	{
		int u=qwq[i].x,v=qwq[i].y,co=qwq[i].co;
		if(find(u)!=find(v))
		{
			o++;
			join(u,v);
			maxn=co;
		}
	}
	cout<<(maxn+1)/2;//我们maxn求的是最小生成树的最大边的长度s，时间则为（s+1）/2； 
}
```


---

## 作者：liuyz11 (赞：0)

发现没有二分答案加广搜的题解，来发一个。

具体思路就是先二分扩展的时间，然后从第一个点进行广搜，看是否能到达所有点。

注意：距离公式是abs(x0 - x1) + abs(y0 +y1)，两个点连通仅当距离<=时间*2。

代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>
#define rep(x, l, r) for(int x = l; x <= r; x++)
#define repd(x, r, l) for(int x = r; x >= l; x--)
#define clr(x, y) memset(x, y, sizeof(x))
#define mp make_pair
#define pb push_back
#define all(x) x.begin(), x.end()
#define SZ(x) ((int)x.size())
#define MAXN 100005
#define fi first
#define se second
using namespace std;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef long long LL;
const int INF = 1 << 30;
const int p = 1e9 + 7;

queue<int> que;
int n;
pii a[MAXN];
bool vis[MAXN];

int judge(int i, int j){
	return 	abs(a[i].fi - a[j].fi) + abs(a[i].se - a[j].se);
}

bool check(int mid){
	clr(vis, 0);
	que.push(1);
	vis[1] = 1;
	while(!que.empty()){
		int u = que.front();que.pop();
		rep(i, 1, n){
			if(vis[i] || judge(u, i) > 2 * mid) continue;
			vis[i] = 1;
			que.push(i);
		}
	}
	rep(i, 1, n)
		if(!vis[i]) return 0;
	return 1;
}

int main(){
	scanf("%d", &n);
	int r = 0;
	rep(i, 1, n){
		int x, y;
		scanf("%d%d", &x, &y);
		a[i] = mp(x, y);
		r = max(r, max(x, y));
	}
	int l = 1, ans;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(check(mid)){
			ans = mid;
			r = mid - 1;
		}
		else l = mid + 1;
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：皓芷 (赞：0)

距离不是严格的曼哈顿距离，应该是

```cpp
dis[i,j]=(max(x[i]-x[j],x[j]-x[i])+max(y[i]-y[j],y[j]-y[i])-1)/2+1;
```
可以最小生成树，但是题目可以看出是最小生成树的最大边，所以二分答案应该也可以做，但是二分答案不好调，所以放最小生成树代码。。。

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#define mysister
using namespace std;
const int maxn=50;
struct bian
{
    int u,v,w;
    bian(int a,int b,int c):u(a),v(b),w(c){}
    bool operator < (bian b)
    {
        return w<b.w;
    }
};
int n,x[maxn],y[maxn],ans=0,fa[maxn];
vector<bian>g;
int find(int u)
{
    return fa[u]==u?u:fa[u]=find(fa[u]);
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
      scanf("%d%d",&x[i],&y[i]);
      fa[i]=i;
      for(int j=0;j<i;j++)
        g.push_back(bian(i,j,(max(x[i]-x[j],x[j]-x[i])+max(y[i]-y[j],y[j]-y[i])-1)/2+1));
    }
    sort(g.begin(),g.end());
    for(int i=0;i<g.size();i++)
      if(find(g[i].u)!=find(g[i].v))
      {
          fa[find(g[i].u)]=find(g[i].v);
          ans=max(ans,g[i].w);
      }
    printf("%d",ans);
}
```

---

## 作者：ws_ccd (赞：0)

两点之间的距离是曼哈顿距离，然后最小生成树

```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#include<map>
#include<set>
#define inf 0x7fffffff>>1
#define N 100005
#define MAXN 1000005
#define LL long long 
#define mod 1000000007
using namespace std;
inline int ra()
{
    int x=0,f=1; char ch=getchar();
    while (ch<'0' || ch>'9') {if (ch=='-') f=-1; ch=getchar();}
    while (ch>='0' && ch<='9') {x=x*10+ch-'0'; ch=getchar();}
    return x*f;
}
struct node{
    int x,y,v;
}a[MAXN],b[MAXN];
int n,fa[1005],ans,cnt;
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
bool cmp(node a, node b)
{
    return a.v<b.v;
}
int c(double x)
{
    double orz=(double)int(x);
    if (orz<x) return orz+1;
        else return orz;
}
int main()
{
//    freopen("connection.in","r",stdin);
//    freopen("connection.out","w",stdout);
    n=ra();
    for (int i=1; i<=n; i++)
    {
        a[i].x=ra(),a[i].y=ra();
    }
    for (int i=1; i<=n; i++)
        for (int j=i+1; j<=n; j++)
        {
            b[++cnt].x=i;
            b[cnt].y=j;
            b[cnt].v=c((double)((double)(abs(a[i].x-a[j].x)+(double)abs(a[i].y-a[j].y))/2));
        }
    sort(b+1,b+cnt+1,cmp);
    for (int i=1; i<=n; i++) fa[i]=i;
    int tot=0;
    for (int i=1; i<=cnt; i++)
    {
        int p=find(b[i].x),q=find(b[i].y);
        if (p!=q)
        {
            fa[p]=q;
            ans=max(ans,b[i].v);
            ++tot;
        }
        if (tot==n-1) break;
    }
    cout<<ans;
//    fclose(stdin); fclose(stdout);
    return 0;
}
```

---

## 作者：gb530 (赞：0)

### 这道题很多人都用最小生成树或并查集
### 然而我看到数据范围为50后想到的方法却是
# Floyd
### O(n^3)绝对完美！
### 接下来就是建图了
### 本题中这点很明显
## 可是需要注意一些细节
```c
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			int d=(abs(a[i].x-a[j].x)+abs(a[i].y-a				[j].y)+1)/2;//记录曼哈顿距离
			dist[j][i]=dist[i][j]=d;
		}
	}
```
## 这里为什么要+1后/2呢？？？
### /2好理解，因为这是两个点同时向外扩张
## 可是为什么要先加一呢？
### 如果难以判断，可以先脑补一些简单情况
### 我们讨论仅有两个点的情况，设它们相距d，要走x步
### 当d=1 x=1
### 当d=2 x=1
### 当d=3 x=2
### 当d=4 x=2
### ~~~
### 容易总结出以上建图的代码段
#### ~~这的故事告诉我们，遇到复杂的情况时耐下心来才是王道~~
### P.s. 曼哈顿距离
### 我相信大家更了解的是欧几里得距离（即两点之间直线距离）
### 曼哈顿距离——两点在南北方向上的距离加上在东西方向上的距离，即d（i，j）=|xi-xj|+|yi-yj|。对于一个具有正南正北、正东正西方向规则布局的城镇街道，从一点到达另一点的距离正是在南北方向上旅行的距离加上在东西方向上旅行的距离，因此，曼哈顿距离又称为出租车距离。
[曼哈顿距离图示](https://baike.baidu.com/pic/曼哈顿距离/743092/0/8697397f2ff8561b29388a48?fr=lemma&ct=single#aid=0&pic=8697397f2ff8561b29388a48)
### 图中红线代表曼哈顿距离，绿色代表欧氏距离，也就是直线距离，而蓝色和黄色代表等价的曼哈顿距离。
##### 						--图片与解释来源为百度百科
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
const int maxn=55;
const int inf=0x3f3f3f3f;
int n,dist[maxn][maxn],ans=0;

struct node{
	int x,y;
} a[maxn];

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			dist[i][j]=inf;
	for(int i=1;i<=n;i++)
		dist[i][i]=0;
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			int d=(abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y)+1)/2;//记录曼哈顿距离
			dist[j][i]=dist[i][j]=d;
		}
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));//Floyd
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(i!=j) ans=max(ans,dist[i][j]);
	cout<<ans<<endl;
	return 0;//AC！！！
}
```

---

## 作者：msxc (赞：0)

纵观所有题解没有操作（雾）比在下更简单的了，在下用的是并查集+循环更换答案来A这题的。

具体思路在于先求曼哈顿距离连点建边,然后再以边权从小到大排序，之后在一遍循环扫过去，该边两点在一个联通块就不管，不在就判断该边权与最大值关系，相同就连接，大了就替换。。


---------------------~~华丽丽的分割线~~---------------------


```cpp
#include <bits/stdc++.h>
#define lolo long long 
#define INF 1000000 
#define Mod 1000000
#define pln printf("\n");
#define Open(s) freopen(s".in","r",stdin); freopen(s".out","w",stdout);
#define Close fclose(stdin); fclose(stdout);
using namespace std; 
struct stt{int x,y,c;}a[110],ed[100100];
bool cmp(const stt &a,const stt &b)
{return a.c<b.c;}
int ans,n,cnt;

int fa[100];
int f_fa(int x)
{
	if (fa[x]==x) 	   return x;
	fa[x]=f_fa(fa[x]); returnX fa[x];
}

inline int read()
{
	int k=1,sum=0;
	char c=getchar();
	for(; '0'>c || c>'9';  c=getchar())
		if(c=='-') k=-1;
	for(; '0'<=c && c<='9';c=getchar())
		sum=sum*10+c-'0';
	return sum*k;
}

inline void write(int x)
{
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

void in_1()
{
	n=read();
	for (int i=1; i<=n; i+=1)
	  a[i]=(stt){read(),read()};
}

int mhd(int x,int y)
{
	return abs(a[x].x-a[y].x)+abs(a[x].y-a[y].y);
}

void cl()
{
	for (int i=1; i<=n; i+=1) fa[i]=i;
	for (int i=1; i<n; i+=1)
	  for (int j=i+1; j<=n; j+=1)
	    ed[++cnt].x=i,ed[cnt].y=j,ed[cnt].c=mhd(i,j);
	sort(ed+1,ed+cnt+1,cmp);
}

void out_1()
{
	printf("%d\n",ans);
}

void work()
{
	int hd=1,now=0;
	if (ed[hd].c%2) now=(ed[hd].c+1)/2;
	else 			now= ed[hd].c   /2;
	for (int i=1; i<=cnt; i+=1)
	{	
		int fx=f_fa(ed[i].x),fy=f_fa(ed[i].y),nt=0;
		if (ed[i].c%2) nt=(ed[i].c+1)/2;
		else 		   nt= ed[i].c   /2;
		//printf("%d %d %d\n",ed[i].x,ed[i].y,nt);
		if (fx!=fy)
		{
			if (nt<=now) fa[fy]=fx;
			else		 fa[fy]=fx,now=nt;
		}	
	}
	ans=now;
}

int main()
{
  	//Open("ppg");

    in_1();
    cl();
    work();
    out_1();
    
  	Close;
  	return 0;  
}
```

---


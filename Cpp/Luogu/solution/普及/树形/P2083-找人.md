# 找人

## 题目描述

小明要到他的同学家玩，可他只知道他住在某一单元，却不知住在哪个房间。那个单元有 $n$ 层（$1,2,\ldots,n$），每层有 $m$（$1,2,\ldots,m$）个房间。

小明会从第一层的某个房间开始找，他找的方式也很特别，每次到了一个房间，如果不是他的同学，他就会询问这个人，然后他就会去那人告诉他的房间号，如果还不是，他就会继续按这个方法找下去，直到找到。当然，他也有可能找不到同学。他的体力也是有限的，他每爬一层楼梯就会消耗 $v$ 体力值。你的任务就是求找到同学耗费的最少体力值，如果找不到，就输出 `impossible` 。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq n\le1000$，$1 \leq m\le100$，$1 \leq v\le50$。

## 样例 #1

### 输入

```
3 3 2 2 3
1 3 3 3 2 1
2 3 1 1 2 3
1 1 1 2 2 3
```

### 输出

```
2```

# 题解

## 作者：AFOier (赞：21)

dfs大水题，当然没有记录里其它dalao的方法跑得快，但是时限是1s，dfs完美AC。。。

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int n,m,v,zx,zy,ans;
struct house{int x,y;}a[1001][1001];
int dfs(int c,int f,int s,int zs)
{
    if(c==zx&&f==zy)return s; //如果到达终点，返回当前体力
    if(zs>n*m)return 10000000;//如果走的房间数大于所有的房间数但是还没有找到同学，说明有环，直接返回不可能（我用10000000代替impossible）
    dfs(a[c][f].x,a[c][f].y,s+v*(abs(a[c][f].x-c)),zs+1);//寻找当前房间的人所告诉的房间
}
int main()
{
    ans=10000000;
    cin>>n>>m>>v>>zx>>zy;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    cin>>a[i][j].x>>a[i][j].y;//输入
    for(int i=1;i<=m;i++)
    ans=min(dfs(1,i,0,0),ans);//找最小的答案
    if(ans==10000000)cout<<"impossible"<<endl;//要是最小答案是10000000，说明肯定找不到那个同学，输出impossible
    else cout<<ans<<endl;//否则输出答案
}
```

---

## 作者：Dog_Two (赞：14)

## 吐槽

### 题意 
题意的表述真的是相当别扭啊……口语化这么厉害，会让语文不好的同学们害怕的。

对于输入数据，我真的是读了好几遍才了解句子的含义：每行会有m**对**数字，表示下一个房间所在的楼层和编号。

### 数据

- 第一次提交：习惯性地认为“下楼不耗体力”，再加上一个没有发现的弱智错误，得到20pt；

- 第二次提交：修复了“下楼不耗体力”的bug，没有发现那个“弱智错误”，得到70pt；

- 第三次提交：发现状态的优先度居然被我定义成了“楼层小的优先度大”，修复bug，得到90pt；

- 第四次提交：发现判定终点的条件被写成了“该房间的‘下一个房间‘’就是此房间”，数据中存在一个不是最终答案的房间满足这个条件，修复bug，AC；

- AC后，发现BFS中，添加初始状态的for循环里“i<=m”被写成了“i<m”，但数据里并没有“从(1,m)出发为正解”的情况，所以代码尚可hack（题解版本代码已经修复）。

### 做法

带权并查集、模拟、dfs、最短路……这里提供一个优先队列bfs的做法。

# 广搜变形

广度优先搜索一般能够保证当目标状态**第一次被取出**时，花费即为最优解。

然而对于某些状态转移有特殊变化的状态空间，普通的FIFO（first in first out）队列有时会带来错误的答案。

### 普通BFS

 普通BFS的状态空间是一个所有边权都为1的图，用FIFO队列存储状态即可。

### 双端队列BFS

 根据《算法竞赛进阶指南》的介绍，对于边权只含1和0的图，应当使用双端队列实现：花费增长为0的加入队首，否则加入队尾。
 
### 优先队列BFS

对于边权不只有0/1的状态空间，我们可以使用最短路算法来解决。但如果使用BFS，就应当用优先队列来存储状态，令**当前**最优花费（在本题中是爬楼数最少）优先度最高，这样仍能保证第一次取出目标状态时，花费为最优。

使用朴素的BFS可以在O(N^2)的时间里实现这类状态空间的求解，但显然不适用于本题。
 
# 本题解法

本题由于存在楼层跨度带来的体力消耗，状态转移的代价显然不止0/1。

所以我们要采用优先队列BFS。

需要注意的是，C++STL中的优先队列默认是大根堆，我们如果不想重新定义（刘汝佳的《算法竞赛入门经典》中有修改priority_queue优先级的实例），就要在重载运算符的时候作反向的定义。



# 代码
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+10,maxm=1e2+10;
bool vis[maxn][maxm];//判重数组 
int n,m,v,_x,_y;
struct rec{
	int cnt;//总爬楼数 
	pair<int,int> p;//当前位置，<层，房间> 
};

bool operator < (const rec &a,const rec &b){
	return a.cnt>b.cnt;//总爬楼数越小，优先度越高 
}

int flr[maxn][maxm],num[maxn][maxm];//floor number

inline pair<int,int> get_Next(const pair<int,int> &p){//获得“下一个”位置 
	int x=p.first,y=p.second;
	return make_pair(flr[x][y],num[x][y]);
}

priority_queue<rec>q;//pq实现堆 
int BFS(){
	for(int i=1;i<=m;++i){
		q.push((rec){0,make_pair(1,i)});//题目中说明从“一楼”开始 
	}
	while(!q.empty()){
		rec tmp=q.top(); q.pop();
		int x=tmp.p.first,y=tmp.p.second;
		if(vis[x][y]) continue;
		vis[x][y]=true;
		int C=tmp.cnt;
		pair<int,int> Next=get_Next(tmp.p);
		if(tmp.p==make_pair(_x,_y)) return C; 
		int del=abs(Next.first-x); 
		q.push((rec){del+C,Next});
	}
	return -1;
}

int main(){
	cin>>n>>m>>v>>_x>>_y;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j){
			int a,b; scanf("%d%d",&a,&b);
			flr[i][j]=a,num[i][j]=b;
		}
	int ans=BFS();// ans == -1，即不连通 
	if(ans==-1) puts("impossible");
	else cout<<ans*v;
	return 0;
}

```



---

## 作者：5u0i5n11i (赞：7)

蒟蒻学完并查集，看啥都是并查集。

于是我就神奇的用并查集解出了此题

思路就是从1至n*
m扫一圈，将当前房间所在位置与它指向房间merge注意必须把它merge到它指向房间的儿子节点。最后，你就会发现同学家正好是一个根节点

样例merge后样子如下，但样例中无死循环情况，这题是可能出现小明反复绕圈的情况的，所以我们要判定一下。

                    2,3
                 3,3   2,1
                1,2     1,3
               3,3       1,1
                       2,2  3,1
我们选取的存储方式为并查集中的   _建立补集法_  ，并查集数组中1至m为第一层，m+1至2*
m为第二层，以此类推，所以，并查集数组要有100000个

还有此题中切记不可用路径压缩，不然就无法完美重现找的过程。

代码如下
```
#include<bits/stdc++.h>
using namespace std;
int b[1005][100][3];
int bcj[99999999];
int hp=0,n,m,v,t=0,o=0;
void fget(int x)
{
    if (x/m!=bcj[x]/m)hp+=abs(bcj[x]/m-x/m)*v;
	if (bcj[x]==x)return;
	else fget(bcj[x]);//这里是重现找的部分，只比标准的找多一行家HP
}
int get(int x)
{
	o++;
	if (o>n*m) {o=0;return 2147483647;}//若进入了死循环，跳出
	if (bcj[x]==x){o=0;return x;}
	else return get(bcj[x]);	//并查集标准找的部分，注意没有路径压缩哦
}
void merge(int x,int y)
{
	bcj[x]=y;//不要连接到Y节点的树根部分要连接到最下面
}
int main()
{
	int i,j,x,y,ans=2147483647,k;
	cin>>n>>m>>v>>x>>y;
	for (i=1;i<=n*m;i++)bcj[i]=i;
	for (i=1;i<=n;i++)
	 for (j=1;j<=m;j++)
	 cin>>b[i][j][1]>>b[i][j][2];//每层用户的提供信息
	for (i=1;i<=n;i++)
	  for (j=1;j<=m;j++)
	  {
		  merge((i-1)*m+j,(b[i][j][1]-1)*m+b[i][j][2]);//合并部分，（i-1）*m+j为当前用户所在的i层第j间房，后面同理，不过是指向当前房间指向位置
	  }
	for (i=1;i<=m;i++)
	{
		if (get(i)==(x-1)*m+y)
		{fget(i);if (hp<ans)ans=hp;hp=0;}//若根节点为同学家，找，替换最小值
	}
	if (ans==2147483647)cout<<"impossible";
	else cout<<ans;//输出
	return 0;
}
```

撒花结束

---

## 作者：白鲟 (赞：6)

### 膜拜
题解区的大佬们让我叹为观止……本蒟蒻实在佩服……  

大家的方法都非常好……666……蒟蒻表示已经阵亡……  

### 分析
言归正传。  

这里也是一个用**最短路**来求解的方法，但是和之前那位大佬的方法有所不同，TA是把第一层的每一个房间都当作源点跑了一遍spfa。  

此处蒟蒻冥思苦想了很久发现，其实只需要跑一遍单源最短路就行了。

把要找的人所在的位置当作源点，反向存边（即把信息所指向的房间与提供信息的房间连一条有向边，边的长度即为它们两个房间的楼层差与每层所消耗的体力的乘积），跑一遍单源最短路之后再遍历所有第一层房间到源点的最短距离，找出其中的最小值即可。  

有一个小技巧（大佬勿喷），是把i层第j个房间转化为第(i-1)·m+j个点，类似于计算二维数组中某个点的内存位置，便于进行存储。  

表述可能不是太清楚，请见谅。
### 代码 （c++）
本蒟蒻很菜……码风清奇……请多海涵……有错误请指正……  

大家看到如此丑陋的代码一定不会抄的对吧……  

```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int n,m,s,v,x,y,t1,t2,total,head[100001],next[100001],from[100001],to[100001],len[100001],dis[100001];
bool exist[100001];
#define no(x,y) (((x)-1)*(m)+(y))
void add(int u,int v,int w)
{
	from[++total]=u;
	to[total]=v;
	len[total]=w;
	next[total]=head[u];
	head[u]=total;
	return;
}
void spfa(void)
{
	int minn=0x7fffffff;
	queue<int>que;
	memset(dis,0x7f,sizeof(dis));
	que.push(s);
	exist[s]=true;
	dis[s]=0;
	while(!que.empty())
	{
		int p=que.front();
		que.pop();
		exist[p]=false;
		for(int i=head[p];i;i=next[i])
		{
			if(dis[to[i]]>dis[p]+len[i])
			{
				dis[to[i]]=dis[p]+len[i];
				if(!exist[to[i]])
				{
					que.push(to[i]);
					exist[to[i]]=true;
				}
			}
		}
	}
	for(int i=1;i<=m;++i)
		minn=min(dis[i],minn);
	if(minn<0x7f7f7f7f)
		printf("%d",minn);
	else
		printf("impossible");
	return;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&v,&x,&y);
	s=no(x,y);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
		{
			scanf("%d%d",&t1,&t2);
			add(no(t1,t2),no(i,j),abs(t1-i)*v);
		}
	spfa();
	return 0;
}
```

---

## 作者：dunko (赞：5)

## **题目**
[ Click here](https://www.luogu.org/problemnew/show/P2083)
## **思路**
大水题爆搜，用DFS简单明了。   
从第一层每一个房间都搜一遍，记录最小的答案。   
注意每一次DFS前都要初始化。   
当然，为了不让代码爆栈，一定要注意是否会陷入死循环，用step记录当前走了几步，如果step大于n*m的话就说明有循环了，就立刻返回一个极大值，退出DFS。
## **代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v,ex,ey,ans,a[1111][111],b[1111][111],anss=1<<30;
//anss记录最后的答案，初始化为一个极大值，ans为从第一层的每一个房间出发到终点的花费
//a[i][j]表示第i层第j个房间提供的下一个房间在第几层
//b[i][j]表示第i层第j个房间提供的下一个房间在那一层第几个房间
bool f=0;//f表示是否找到了一个可行的路线
int dfs(int x,int y,int step){
    if(x==ex&&y==ey) {
        f=1; return ans;//如果到终点了就返回当前的花费。
    }
    if(step>n*m) return 1<<30;//如果有循环，这里走不通就返回极大值
    ans+=abs(a[x][y]-x)*v;//ans加上到下一个房间花费的值
    dfs(a[x][y],b[x][y],step+1);//向下搜索
}
int main(){
    cin>>n>>m>>v>>ex>>ey;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
      scanf("%d%d",&a[i][j],&b[i][j]);//输入
    for(int i=1;i<=m;i++){//枚举第一层每个房间，记录从这个房间到终点的花费
        ans=0;
        anss=min(anss,dfs(1,i,0));//找出最小值
    }
    if(!f) printf("impossible\n");
    else printf("%d\n",anss);
    return 0;
}
```

---

## 作者：SteinsGate0 (赞：4)

不知为何这题标签是搜索

我写的，spfa,图论啦啦啦啦啦啦！！！！！！！！！

每个房间的小朋友跟他提供信息的人链条边，len=楼梯层数差\*v（当然是单向的哦）

后泡泡spfa(直接dfs效率高些。但万一有环尼？）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#define inf 999999999LL
using namespace std;
struct node {int x,y;};
node a[100001];
queue<int>q;
int n,m,v,xx,yy,aa,k=0,tot,ans=inf;
int la[100001],ne[100001],ed[100001],dis[100001],le[100001];
bool f[100001];
int i,j;
void add(int x,int y)
{
    tot++;
    ed[tot]=y;
    le[tot]=fabs(y/m-x/m)*v;
    ne[tot]=la[x];
        la[x]=tot;
}        
void spfa(int s)
{
    int i;
    for(i=1;i<=n*m;i++)dis[i]=inf;
    dis[s]=0;f[s]=true;
    q.push(s);
    while(q.size()>0)
    {
        int t=q.front();
        f[t]=false;
        q.pop();
        int x=la[t];
        while(x>0)
        {
            int y=ed[x];
            if(dis[y]>dis[t]+le[x])
            {
                dis[y]=dis[t]+le[x];
                if(f[y]==false)
                {
                    q.push(y);
                    f[y]=true;
                }
            }
            x=ne[x];
        }
    }
}
    int main()
{
    cin>>n>>m>>v>>xx>>yy;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++)
        {
            k++;
            scanf("%d%d",&a[k].x,&a[k].y);
            add(k,m*(a[k].x-1)+a[k].y);
            }
          }
  for(i=1;i<=m;i++)
  {
      spfa(i);
          ans=min(ans,dis[(xx-1)*m+yy]);
  }
  if(ans==inf)printf("impossible");
  else cout<<ans;
}

```

---

## 作者：Chanter (赞：2)

不懂为什么这么多大佬一直在强调判环？而且剪枝也很迷？（大雾

用回溯就可以解决问题了啊，而且也不用在几个点之间绕来绕去直到超出限制。

我的思路比较清奇，也没有大佬类似思路写过题解。

来看看我们的思路：用一个check数组来记录每一次dfs的状态。如果从同一个点出发，有一个点被搜到两次，那么说明这个出发点会产生环，结束这次dfs就可以了。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define _for(i,a,b) for(register int (i)=(a);(i)<=(b);(i)++)
#define For(i,a,b) for(register int (i)=(a);(i)>=(b);(i)--)
#define INF 0x7fffffff
#define il inline
#define rg register
using namespace std;
inline long long read(){
	long long num=0;int z=1;char c=getchar();
	if(c=='-') z=-1;
	while((c<'0'||c>'9')&&c!='-') c=getchar();
	if(c=='-') z=-1,c=getchar();
	while(c>='0'&&c<='9') num=(num<<1)+(num<<3)+(c^48),c=getchar();
	return z*num;
}//快读板子
int n,m,v,x,y;
int mapl[1005][105],mapr[1005][105];
int f[1005][105];
bool check[1005][105];//记录dfs中的状态
int ans=INF;//答案先设为最大值
il void dfs(int sum,int l,int r){
	if(l==x&&r==y){
		ans=min(ans,sum);//如果到了，那么就统计答案，退出。
		return ;
	}
	if(check[mapl[l][r]][mapr[l][r]]) return ;//判断，如果一个点被搜了两次，那么就有了环，退出。
	check[mapl[l][r]][mapr[l][r]]=true;//将其标记为已走过
	dfs(sum+(mapl[l][r]>l?mapl[l][r]-l:l-mapl[l][r])*v,mapl[l][r],mapr[l][r]);//搜索下一户
	check[mapl[l][r]][mapr[l][r]]=false;//回溯前恢复原状态
	return ;
}
int main(){
	n=read(),m=read(),v=read(),x=read(),y=read();
	if(x==1) return printf("0\n"),0;
	_for(i,1,n) _for(j,1,m) mapl[i][j]=read(),mapr[i][j]=read();
	_for(i,1,m){
		memset(check,false,sizeof(check));//还原状态
		dfs(0,1,i);//dfs
	}
	if(ans==INF) return printf("impossible\n"),0;//特判，假如到不了，即ans没有被更改，输出impossible
	return printf("%d\n",ans),0;
   ^_^
}
```

望管理员大大通过^_^。


---


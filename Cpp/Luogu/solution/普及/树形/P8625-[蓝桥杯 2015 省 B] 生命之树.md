# [蓝桥杯 2015 省 B] 生命之树

## 题目描述

在 X 森林里，上帝创建了生命之树。

他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。

上帝要在这棵树内选出一个节点集合 $S$（允许为空集），使得对于 $S$ 中的任意两个点 $a,b$，都存在一个点列 ${a,v_1,v_2, \cdots ,v_k,b}$ 使得这个点列中的每个点都是 $S$ 里面的元素，且序列中相邻两个点间有一条边相连。

在这个前提下，上帝要使得 $S$ 中的点所对应的整数的和尽量大。

这个最大的和就是上帝给生命之树的评分。

经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 10$。

对于 $100\%$ 的数据，$0<n \le 10^5,$ 每个节点的评分的绝对值不超过 $10^6$。

时限 3 秒, 256M。

蓝桥杯 2015 省赛 B 组 J 题。

## 样例 #1

### 输入

```
5
1 -2 -3 4 5
4 2
3 1
1 2
2 5```

### 输出

```
8```

# 题解

## 作者：xler0915 (赞：15)

[题目传送门](https://www.luogu.com.cn/problem/P8625) / [可能有更好的阅读体验](https://www.luogu.com.cn/blog/hen-you-so-beautiful/solution-p8625)

### 题意
对于一棵树，找到其点权和最大的一个连通分量（注意可以为空），输出这个连通分量的点权和。相似于 [P1122](https://www.luogu.com.cn/problem/P1122)。

### 思路：树形 dp
我们用 $a_i$ 表示第 $i$ 个点的权值，$dp_u$ 表示在以 $u$ 为根的子树中最大的点权和，不妨设 $1$ 号节点为这棵树的根，其父亲为 $0$ 号节点。

因为对于 $u$ 的任意一个儿子 $v$，如果 $dp_v>0$，那么以 $u$ 为根的点权和最大的子树一定要加上以 $v$ 为根的点权和最大的子树，所以得到状态转移方程为：

$$dp_u = a_u+\sum\limits_{u \to v}\max\{dp_v,0\}$$

最终答案即为 $\max\{\max_{i=1}^ndp_i,0\}$（因为可以为空），实现方法较为简单。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int a[100005]; // 每个点的点权
long long dp[100005]; // 注意开 long long
vector<int> adj[100005]; // 邻接表存储

void dfs(int u, int fa) {
	dp[u] = a[u];
	for(int v : adj[u]) {
		if(v == fa) continue;
		dfs(v, u);
		dp[u] += max(dp[v], 0ll);
	}
   // 状态转移方程
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) 
		scanf("%d", &a[i]);
	for(int i = 1, u, v; i < n; i++) {
		scanf("%d%d", &u, &v);
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	dfs(1, 0);
	printf("%lld", max(*max_element(dp + 1, dp + n + 1), 0ll)); // 输出答案。
	return 0;
}
```

---

## 作者：Iniaugoty (赞：4)

[传送门](/problem/P8625)。

***

## problem

给出一棵树，求出点权和最大的子树，并输出这个点权和。

***

## solution

一看感觉就根 [P1122 最大子树和](/problem/P1122)一样的，用树型 dp 解决。因为以哪个点为根，其实都能得到正确的结果，直接把 $1$ 当作根结点。设 $dp_i$ 为以 $i$ 结点为根的子树的最大子树和，转移方程为 $dp_i=a_i+\sum_{i\to j}\max\{dp_j,0\}$。最后的答案为 $\max\{dp_i\}$。

然而，我交上代码后只得了 60pts。

仔细再读题目，发现：

> 上帝要在这棵树内选出一个节点集合 $S$（允许为空集）。

选的点集是空集，那点权和就是 $0$，这在最大子树和为负的情况下，对结果是有影响的。

那么答案就应该是 $\max\{\max\{dp_i\},0\}$。

然而，交上去还是只有 72pts。

注意到：**十年 OI 一场空，【数据删除】见祖宗**。于是加上一句 `#define int long long`，快乐地 AC 了。

***

## code

这里采用链式前向星存图。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
#define max(x,y) (x>y?x:y)
using namespace std;
struct star{//链式前向星存图
	int next,to;
}e[N<<1];
int head[N],cnt;
void add(int u,int v){//加边
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
int n,a[N],dp[N],ans;//可以选空集，所以 ans 初始化为 0
void dfs(int step,int father){//注意要把要转移的点的父节点记录下来，不然会重复计算
	dp[step]=a[step];
	for(int i=head[step];i;i=e[i].next){
		int t=e[i].to;
		if(t!=father){
			dfs(t,step);
			if(dp[t]>0)
				dp[step]+=max(dp[t],0);//转移
		}
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1,u,v;i<n;i++)
		cin>>u>>v,add(u,v),add(v,u);
	dfs(1,0);//添加一个 0 作为 1 的父节点
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：StarRain3 (赞：2)

怎么没有题解？

#### 分析
我们把它想象成一个普通的树，但是它的根不确定，先看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/58kwd2rc.png)

可以发现，我们不管怎么变换根，它的最大值都是相同的，我们不如就全部以 $1$ 为根。

解决了这个问题，我们就可以用树形动态规划模板了，建立一个二位动态规划数组，属性是最大值。

$f_{k}$ 且 $q$ 为 $0$ 表示不选取 $k$ 节点后 $k$ 子树能得到的最大值；$f_{k}$ 且 $q$ 为 $1$ 表示选取 $k$ 节点后的 $k$ 子树能得到的最大值。

动态转移方程见代码部分。

我们用邻接表维护。

找出与 $u$ 相邻的节点，如果父节点也与 $u$ 节点相邻，但不能重复遍历，然后递归获取儿子节点的信息。

值得注意的是：如果当前的能选取的最大方案它是负数，就没有必要继续了，舍弃即可。

#### 赛时代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
vector<int> linjie[N];
long long ans;
long long dp[N][3];
int w[N];
void dfs(int u,int father){
	dp[u][1] = w[u];
	dp[u][0] = 0;//初始化 
	for(int i=0; i < linjie[u].size();i++){//枚举邻接表里的内容 
		int v = linjie[u][i];//方便 
		if(v != father){
			dfs(v,u);
            
			dp[u][0] = max(dp[v][0],dp[v][1]);//DP
            
			if(dp[v][1] > 0) dp[u][1] += dp[v][1];
			 
		}
	}
	ans = max({dp[u][0],dp[u][1],ans});//c++14特性
}
int main(){
	int n;
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> w[i]; 
	}
	
	for(int i=1;i < n;i++){
		int a,b;
		cin >> a >> b;
		linjie[a].push_back(b),linjie[b].push_back(a);//加入邻接表中
	}
	dfs(1,1);//递归 
	cout << ans;
	return 0; 
}
```
[AC记录](https://www.luogu.com.cn/record/108532466)。

---

## 作者：Furina_Hate_Comma (赞：2)

一道树形 dp 题。

对于一个节点，考虑所有子节点，如果非负，就加上；否则舍弃。

状态转移方程：

$$\sum_{i=son_1}^{i\in son} dp_i\times(dp_i\ge 0)$$

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[900005];
int dp[900005];
struct lsqxx{
	int t,nxt;
}e[900005];
int tot,num[900005];
void addedge(int f,int t){
	e[++tot].t=t;
	e[tot].nxt=num[f];
	num[f]=tot;
}
void dfs(int p,int f){
	dp[p]=a[p];
	for(int i=num[p];i;i=e[i].nxt){
		if(e[i].t!=f){
			dfs(e[i].t,p);
			if(dp[e[i].t]>0)
				dp[p]+=dp[e[i].t];
		}
	}
}
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<n;i++){
		int f,t;
		cin>>f>>t;
		addedge(f,t),addedge(t,f);
	}
	int ans=dp[1];
	dfs(1,0);
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
} 
```


---


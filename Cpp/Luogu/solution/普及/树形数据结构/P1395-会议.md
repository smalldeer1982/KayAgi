# 会议

## 题目描述

有一个村庄居住着 $n$ 个村民，有 $n-1$ 条路径使得这 $n$ 个村民的家联通，每条路径的长度都为 $1$。现在村长希望在某个村民家中召开一场会议，村长希望所有村民到会议地点的距离之和最小，那么村长应该要把会议地点设置在哪个村民的家中，并且这个距离总和最小是多少？若有多个节点都满足条件，则选择节点编号最小的那个点。

## 说明/提示

#### 数据范围

对于 $70\%$ 数据 $n \le 10^3$。

对于 $100\%$ 数据 $n \le 5 \times 10^4$。

## 样例 #1

### 输入

```
4
1 2 
2 3 
3 4 
```

### 输出

```
2 4```

# 题解

## 作者：YoungNeal (赞：117)

题解在博客食用效果更佳哦~[YoungNeal](http://www.cnblogs.com/YoungNeal/p/8629717.html)  
Solution

第一想法是求出每个点到根节点的距离，然后 $O(n^2)$
lca 瞎搞，但是会 T。

所以换 O(n) 的树形 dp。

不妨钦定以 1 为根。

记录 $size[i]$ 表示 i 与 i 的子树的结点个数之和。

定义 $d[i]$ 表示在点 i 开会的距离和。

定义 $subtree(x)$ 表示以 x 为根的子树中点的集合。显然 $subtree(x)∈n$

那么对于树上的非根节点 x，设它的父亲为 y。

所以转移方程 $d[x]=d[y]+(n-size[x])-size[x]=d[y]+n-2*size[x]$

意思是，

① 考虑不在 $subtree(x)$ 中的点，它们到 x 的距离和是 它们到 y 的距离和加上 $(n-size[x])$

② 而对于那些在 $subtree(x)$ 中的点，它们到 x 的距离和就是 它们到 y 的距离和再减去 $(size[x])$

所以合并两式，$d[x]=d[y]+n-2*size[x]$

时间复杂度 $O(n)$

```
// By YoungNeal
#include<cstdio>
#define N 50005

int d[N];
int f[N];
int n,cnt;
int size[N];
bool vis[N];
int head[N];

struct Edge{
    int to,nxt;
}edge[N<<1];

void add(int x,int y){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}

void dfs1(int now){
    size[now]=1;
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(d[to]) continue;
        d[to]=d[now]+1;
        dfs1(to);
        size[now]+=size[to];
    }
}

void dfs(int now,int fa){
    f[now]=f[fa]+n-2*size[now];
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(to==fa) continue;
        dfs(to,now);
    }
}

signed main(){
    scanf("%d",&n);
    for(int x,y,i=1;i<n;i++){
        scanf("%d%d",&x,&y);
        add(x,y);add(y,x);
    }
    d[1]=1;
    dfs1(1);
    int maxn=0,idx=1;
    for(int i=1;i<=n;i++) maxn+=d[i];
    maxn-=n;
    f[1]=maxn;
    for(int i=head[1];i;i=edge[i].nxt){
        int to=edge[i].to;
        dfs(to,1);
    }
    for(int i=2;i<=n;i++){
        if(f[i]<maxn) maxn=f[i],idx=i;
    }
    printf("%d %d",idx,maxn);
    return 0;
}
```

---

## 作者：HHCY (赞：82)

/\*复杂度O(n)

这题思路就是建一棵树

我以1作为根

算出把地点定在1的距离和

用f[1]表示


从1往下遍历这棵树

假设x是当前遍历到的点

y是上个点（x的父亲）

则f[x]=f[y]-(hason[x]+1)+(n-hason[x]-1);

hason[i]表示以点i为根的子树的节点个数


这样就很容易得到答案

主要用到搜索

\*/
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
const int p=50001;
int n,hason[p],f[p],yy=1;
int u,v;
int tot,la[p*2],to[p*2],h[p];
void hsb(int x,int y)
{
    to[++tot]=y,
    la[tot]=h[x],
    h[x]=tot;
}
int hsc(int x,int y)
{
    for(int i=h[x];i;i=la[i])
    if(to[i]!=y)
    hason[x]+=1+hsc(to[i],x);
    return hason[x];
}
void hsa(int x,int y)
{
    f[x]=f[y]-(hason[x]+1)+(n-hason[x]-1);
    for(int i=h[x];i;i=la[i])
    if(to[i]!=y)hsa(to[i],x);
}
void hsd(int x,int y,int z)
{
    f[1]+=z;
    for(int i=h[x];i;i=la[i])
    if(to[i]!=y)
    hsd(to[i],x,z+1);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&u,&v);
        hsb(u,v),hsb(v,u);
    }
    hsc(1,0);
    for(int i=h[1];i;i=la[i])
    hsd(to[i],1,1);
    for(int i=h[1];i;i=la[i])
    hsa(to[i],1);
    for(int i=2;i<=n;i++)
    if(f[i]<f[yy])yy=i;
    printf("%d %d\n",yy,f[yy]);
    return 0;
}
```

---

## 作者：nothingness (赞：64)

现在的几篇题解好像都有点过于抽象，我来发布一篇容易懂的题解.

首先，阅读题目可以看出来，这道题目实际上就是求树的重心，那么我们的思路就转化为：在 $O(n)$ 内先求出树的重心，再用 $dfs$ 求出到重心的距离之和。

**树的重心**：找到一个点，其所有的子树中最大的子树节点数最少，那么这个点就是这棵树的重心，删去重心后，生成的多棵树尽可能平衡。

我们先设任意一个点为树的根（比如 $1$ 号节点），这样就把这棵树变成了有根树。考虑以 $i$ 为根的最大子树的节点数，设为 $g[i]$ ， $i$ 的所有子节点的集合为 $S$ ，则有

$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~g[i]=\sum(s[j]+1)~,~ j∈S$

其中上面的 $+1$ 指子节点本身。显然可以用一遍 $dfs$ 求出所有的 $g[i]$ 。

接下来我们设立一个数组 $f[i]$ ，表示以 $i$ 为根的最大子树的节点数。

如果当前节点 $i$ 是根节点，显然有

$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~f[i]=\max(g[j])~,~j∈S$

如果 $i$ 不是根节点，那么对于 $i$ 的所有子树，必然也满足上述等式。此外，我们还要考虑 $i$ 的父节点，也就是当 $i$ 成为根时，其父节点变成子节点后的节点数。

回归当前以 $1$ 为根的情况，设 $T$ 不包括节点 $i$ 及 $i$ 子树的其余节点的集合，那么可以判断出

$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~T~∪~\{i\}~∪~S=U~,~U$为全集

且

$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~T~∩~\{i\}=T~∩~S=\{i\}~∩~S=~\varnothing$

用 $|S|$ 表示集合 $S$ 中的元素的个数，则

$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|T|=|U|-|S|-|\{i\}|$

$∴$

$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~f[i]=n-g[i]-1$

显然 $f[i]$ 可以在求 $g[i]$ 的 $dfs$ 中求出。那么树的重心就是 $f[i]_{min}$ 时的 $i$ 值。

此外，所有点到 $i$ 点的距离之和在数值上等于以 $i$ 为根的所有子树的节点数， $∴$ 可以调用相同的 $dfs$ 函数求出距离。

## Code
```
#include "bits/stdc++.h"
#define N 1000001
using namespace std;

int n,u,v,O,vis[N],f[N],g[N],ans;
int k,b[N],first[N],next[N],last[N];//f[i]:以i为根的最大子树的节点数
									//g[i]:以i为根的子树的节点个数
void add(int x,int y)
{
	k++;
	b[k]=y;
	if(first[x]==0)
		first[x]=k;
	else
		next[last[x]]=k;
	last[x]=k;
}

void dfs(int x)
{
	vis[x]=1;
	int p=first[x];
	while(p)
	{
		if(!vis[b[p]])
		{
			dfs(b[p]);
			g[x]+=g[b[p]]+1;
			f[x]=max(f[x],g[b[p]]+1);
		}
		p=next[p];
	}
	f[x]=max(f[x],n-g[x]-1);
	vis[x]=0;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs(1);
	f[0]=INT_MAX;
	for(int i=1;i<=n;i++)
		if(f[O]>f[i])
			O=i;//树的重心可以有多个,这里取编号最小的一个
	printf("%d ",O);
	memset(g,0,sizeof(g));
	dfs(O);
	for(int i=1;i<=n;i++)
		ans+=g[i];
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Y_B_Y (赞：52)

这一题知道思路后还是非常好理解的

我们为了使这棵树有一个确定的顺序,可以先定1为根(从1开始遍历,假如从i点走向j点就记i为j的父亲)

我们定义$d[i]$为**所有点到i点的距离和**,$ct[i]$为**i点的子树的所有节点数**

对于这一题,我们可以从点1开始找最佳点,所以我们可以先求$d[1]$的值,求$d[1]$时顺便还可以求出所有$ct[i]$的值,然后我们再考虑怎么求其他的$d[i]$

我们先看一张图

![](https://cdn.luogu.com.cn/upload/image_hosting/yip9u5z1.png)

我们首先知道$d[1]=16$,我们来看$d[2]$应该怎么求,我们发现相对于$d[1]$来说,如果设2为最佳点,2,5,6其距离-1,剩下的1,4,3,7,8,9,10到其距离+1,

所以$d[2]=d[1]+3\times (-1)+7\times 1=20$

我们发现$3$为2的子树加自己的节点数,即$ct[2]+1$,$7$则为其他点的数量,即$n-(ct[2]+1),$

再试着举几个例子,不难发现,如果y为x的子树:

则,$d[y]=d[x]+(ct[y]+1)\times (-1)+(n-(ct[y]+1))\times 1$

所以我们直接**从1开始遍历**,然后**一个个算**,最后再求最小值就可以了

细节看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50005;
int n,ft[N],nx[N],to[N],d[N],ct[N],fa[N];//ft,nx,to存路径,fa[i]记录i的父亲
inline int read()
{
    char c=getchar();int sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
int cnt,ans,minn=0x3f3f3f3f;
void add(int x,int y)//添加路径
{
	nx[++cnt]=ft[x];
	ft[x]=cnt;
	to[cnt]=y;
}
void dfs(int x,int st)//st记录走了多远
{
	for(int i=ft[x];i;i=nx[i]) 
	{
		if(to[i]==fa[x]) continue;//不能往父亲走(因为本来就是从父亲走下来的)
		ct[x]++;//找到一颗子树,+1
		fa[to[i]]=x;//记录
		dfs(to[i],st+1);//进一步搜索
		ct[x]+=ct[to[i]];//x的子树的节点数=x的子树数量+x的子树的所有子树的节点数,这里加上其中一颗子树的贡献
	}
	d[1]+=st;//记录所有点到1的距离和
}
void fd(int x)//向下遍历,求d[]
{
	for(int i=ft[x];i;i=nx[i])
	{
		if(to[i]==fa[x]) continue;//同上
		d[to[i]]=d[x]-ct[to[i]]-1+(n-ct[to[i]]-1);//求d
		fd(to[i]);//继续找
	}
	return;
}
int main()
{
    n=read();
	for(int i=1;i<n;i++)
	{
	    int a=read(),b=read();
		add(a,b);add(b,a);//添加	
    }
	dfs(1,0);
    fd(1);
    for(int i=1;i<=n;i++)
    {
    	if(d[i]<minn)//找最优点
    	{
    		minn=d[i];
    		ans=i;
		}
	}
	return printf("%d %d",ans,minn),0;//输出
}
```


---

## 作者：chager (赞：33)

# ~~告诉你一个秘密，这其实是一道模拟题~~

## 解题方法/步骤：

### 一.初审题目：审清基本条件，目标

（1）可以通过“n-1条路径”，“联通”判断这是一棵树，“路径”可判断这是一棵无根树。

（2）“每条路径的长度都为1”降低了题目难度。

（3）“100%数据n<=50000”可判断该题算法时间复杂度为O（n）～O（nlogn）。

（4）“要把会议地点设置在哪个村民的家中，并且这个距离总和最小是多少？”可得目标。

### 二.初析题目：理清主要算法

1.设置地点方法

（1）既然此题给的是一棵无根树，不妨设1为根。

（2）不妨设1是我们要找的点;

![](https://cdn.luogu.com.cn/upload/pic/63542.png)

如上图，如果将1改成2,会发生什么？1到会议的距离+1，2～9到会议的距离-1，所以2优于1。

（3）进一步分析，可以发现：如果节点从x到（child（x）），则有（以child（x）为根的子树）个点距离-1，其余点距离+1。

2.求路程方法

其实只要先预处理出其他点到1的距离，再在修改过程中更改即可。

至此，该题的主要算法就出来了。

### 三.再析题目：理清次要算法和优化技巧

（1）因为要预处理出以每个节点为根的子树的节点个数，所以这里建议用邻接表存树。代码如下：
```cpp
void add(int a,int b)
{
    o++;
    to[o]=b;
    next[o]=first[a];
    first[a]=o;
    return;
}
```

（2）在节点转移时，其实只需要考虑节点最多的那棵子树就可以了。

## 整题代码如下：
```cpp
# include <stdio.h>
int o,first[50010],next[100010],to[100010],zs[50010],zdz[50010],zds[50010],ans,ro[50010];
void add(int a,int b)
{
    o++;
    to[o]=b;
    next[o]=first[a];
    first[a]=o;
    return;
}
void jdgs(int a,int b)
{
    int i,j;
    zs[a]=1;
    for(i=first[a];i;i=next[i])
    {
        j=to[i];
        if(j==b)
            continue;
        jdgs(j,a);
        zs[a]+=zs[j];
        ro[a]+=ro[j];
    }
    for(i=first[a];i;i=next[i])
    {
        j=to[i];
        if(j==b)
            continue;
        if(zs[j]>zds[a])
        {
            zds[a]=zs[j];
            zdz[a]=j;
        }
        if(zs[j]==zds[a] && zdz[a]>j)
            zdz[a]=j;
    }
    ro[a]+=zs[a]-1;
    return;
}
int main()
{
    int i,j,n,m,a,b;
    scanf("%d",&n);
    for(i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);
    }
    jdgs(1,0);
    m=1;
    ans=ro[1];
    while(1)
    {
        if(zds[m]>(n-zds[m]) || zds[m]==(n-zds[m]) && m>zdz[m])
        {
            ans=ans+n-2*zds[m];
            m=zdz[m];
        }
        else
            break;
    }
    printf("%d %d",m,ans);
}
```
~~欢迎下次光临！~~

---

## 作者：Mine_King (赞：17)

### 先看题：[P1395会议](https://www.luogu.org/problem/P1395)

**树的重心**，就是在一棵树中拆掉一个点，把这棵树分成几个部分，使得最大的部分最小，亦即拆得均匀，这个拆掉的点就是树的重心。

那么怎么求呢？我们可以从根结点开始dfs（什么？你说是无根树。那就定义节点1为根呗），反回值是这棵子树的大小。然后定义一个$mx$，$mx=max\{dfs(\text{改结点的子结点的})\}$ 。最后，在枚举完子节点后，再判断他父亲那一块的大小。然后记录值。  
现在唯一的问题就是父亲那块怎么解决呢？没错，用总结点数减去这棵子树的大小，就是他父亲那一块的大小。

**现在来解决第二问，** 这问其实可以在解决树的重心后直接dfs或bfs，然后就可以得出总的路程了。这一块就不用详细解释了。

**上代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=50005,sum=50005,road;//n是总结点数，ans是树的重心的编号,sum是其最那块的大小，road是总路程
int t[50005];//ti表示结点i到ans的距离。
queue<int>q;//q用来后面bfs用
struct graph
{
	int tot;
	int dt[100005],nxt[100005];
	int hd[50005];
	void add(int x,int y)
	{
		tot++;
		nxt[tot]=hd[x];
		hd[x]=tot;
		dt[tot]=y;
	}
}g;//graph是链式前向星。
int dfs(int x,int fa)
{
	int k=0;//k代表其所以子树的大小
	int mx=0;//mx是将这个点拆掉后最大那块的大小
	for(int i=g.hd[x];i;i=g.nxt[i])//遍历所以点子节点
	 if(g.dt[i]!=fa)//注意判该节点是否是x的父亲，不判会爆栈的
	 {
	 	int xx=dfs(g.dt[i],x);//记录这棵子树的大小
		k+=xx;//加上这棵子树的大小
		mx=max(mx,xx);//取最大值
	 }
	mx=max(mx,n-k-1);//最后判一下父亲那块，最后的-1是因为最开始没有把自己算进去
	if(mx<sum||(mx==sum&&x<ans)) sum=mx,ans=x;//如果比当前方案更优，就取这个方案
	return k+1;//返回整棵子树的大小
}
void bfs()
{
	q.push(ans);//记录最初的点
	while(!q.empty())//如果队列不为空
	{
		int xx=q.front();//记录队首
		q.pop();//弹出队首
		for(int i=g.hd[xx];i;i=g.nxt[i])//遍历链接它的节点
		{
			int yy=g.dt[i];
			if(t[yy]||yy==ans) continue;//如果这个点已经被遍历过，continue
			t[yy]=t[xx]+1;//记录距离
			road+=t[yy];//总距离要加上这个点的距离
			q.push(yy);//放进队列
		}
	}
	return ;
}
int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int from,to;
		cin>>from>>to;
		g.add(from,to);
		g.add(to,from);
	}//输入+存图，注意是双向边
	dfs(1,0);//dfs，把1的父亲设为0，就是没有父节点了（因为没有节点0）
	bfs();//求出树的重心后，求总路程
	cout<<ans<<' '<<road;
	return 0;
}
```

---

## 作者：加勒比·史努比 (赞：13)

## Solve

1.每个村民的家都为一个节点，所有的边权值为1，而且这是一个树。

2.找到[树的重心](https://five-shifts-forever.blog.luogu.org/shu-di-zhong-xin)。

3.以树的重心为源点，求出其与各个节点的距离和（使用BFS）。

## Tips

1.什么是树的重心？

链接Blog~~较为详细地~~描述了树的重心的概念。

2.为什么会议地点就是树的重心？

![](https://cdn.luogu.com.cn/upload/pic/61390.png )

这是树的重心的性质运用。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;  //标准开头
const int N=50010;  //节点数
int n,ans;  //n——节点数，ans为树的重心
int maxn=10000000;
int u,r,sum;  //u，r边的两端点，sum——距离之和
int d[N],dis[N];  //dis[i]为节点i到源点（树的重心）的距离
vector<int> G[N];  //vector建图
queue<int> q;  //BFS必备队列
bool vis[N];  //BFS中已经遍历的点
void dfs(int s,int f){  //求树的重心
    d[s]=1;
    int res=0;
    for(int i=0;i<G[s].size();i++){
        if(G[s][i]==f) continue;
        dfs(G[s][i],s);
        d[s]+=d[G[s][i]];
        res=max(res,d[G[s][i]]);
    }
    res=max(res,n-d[s]);
    if(res<maxn||(res==maxn&&ans>s)){
        maxn=res;
        ans=s;
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n-1;i++){
        scanf("%d%d",&u,&r);
        G[u].push_back(r);
        G[r].push_back(u);
    }
    dfs(1,0);
    q.push(ans);
    while(!q.empty()){  //标准BFS
        int e=q.front();
        q.pop();
        vis[e]=true;
        sum+=dis[e];
        for(int i=0;i<G[e].size();i++){
            if(!vis[G[e][i]]){
                q.push(G[e][i]);
                dis[G[e][i]]=dis[e]+1;
            }
        }
    }
    printf("%d %d",ans,sum);  //完美输出
    return 0;
}
```

---

## 作者：NGC224 (赞：10)

这是一个手把手推方程的题解，主要针对像我一样的蒟蒟蒟蒟蒻:D

另外~~因为忘记了老师讲的树的重心的模板所以~~方法比较清奇。

### **下面是方程的推理过程：**


设dp[i]为当会议在i举行时，所有点到i的路程之和；

设son1[i]为不包含i点的 i的子节点个数。栗：son1[3]=2；

设son2[i]为包含i的i的子节点个数，栗：son1[3]=3；

既然是DP，那么就会具有**可推导性，即每个当前状态会能够决策出下一状态**，也就是我们现在所处的这个点的路程之和dp[i]，是能够由i的父亲fa，即dp[fa]决策出来的，那么是如何决策出来的呢？

我们可以把所有到i的点分成两类：
 
 1.在i的子树中
  
 2.不在i的子树中

**以下面这个美丽的图为例**~~水印挡住美丽的大雁了难受~~

![example](https://cdn.luogu.com.cn/upload/pic/71578.png)

在这个图中，假设i=3，类型一的点要到点i，就必须经过i的父亲，也就是1，而在到达1的基础上，所有的点还要再前进一格才能到达3，所以我们需要把所有的点原来的路程+1，一共有多少个点就加多少个1，而一共有 **(n-son2[i])** 个点，所以对于类型一的点，到i点的总路程为 **{ dp[类型一到父亲] +(n-son[2])}**。

同理，类型二的，例如2，5到点3，就等于他们各自到3的父亲1的路程减去1，他们各自到1的路程之和为 **dp[类型二到父亲]**,再减去**son2[i]**（不理解为什么不是son2的后面解释）

**于是我们就可以合并出最后的方程了！**

###  dp[i]=dp[j]+n-2*son2[i]

ok现在我们再来解释的son2[i]的问题，因为是实际上我们用的是dp[j]，即是包含i点到它父亲的距离的，所以要用son2。

但到了这一步还没有完，因为你假设的根节点1并不满足这个dp方程啊！所以我们需要把你开始dfs的这个根节点的dp[1]算出来，直接上公式：

**dp[1]=son1[1]+son1[2]+son1[3]+son1[4]+...+son1[n]**

就是从**son1[1]一直加到son[n]**，一个循环就可以搞定。


这样我们就能算出把每个点作为会议开设点时的总路程了，最后输出时循环一遍找出最小的dp就完事啦！


**最后是一些注意事项！！都是不看清题血泪**

因为输入的时候没有说明哪个是父亲哪个是儿子，所以要存无向图，所以！数组需要是50000的两倍（别问我这个蒟蒻怎么知道的当然是疯狂RE了）

还有就是它要求输出的时候用空格不是换行……（别问我这个蒟蒻怎么知道的当然是疯狂WA了）

最后贴代码~

```cpp
#include <iostream>
using namespace std;
const M=100005;
int n,last[M],cnt,size[M],d[M],ans=999999999;
struct Node 
{
	int to;
	int nxt;
}e[M];

void pre(int x,int y) //邻接表存图预处理~
{
	cnt++;
	e[cnt].to=y;
	e[cnt].nxt=last[x];
	last[x]=cnt;
}

void dfs(int x,int fa)
{
	for(int i=last[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(y!=fa)//子树当然不包括爹地咯
		{
			size[x]++;
			dfs(y,x);
			size[x]+=size[y];
		}
		else continue;
	}
}/*这里的size相当于把son1和son2合并了，这里求的是
son1，因为son1只用来求dp[1]，所以出去之后全部+1就
可以*/

void dfs1(int x,int y)
{
	for(int i=last[x];i;i=e[i].nxt)
	{
		if(x!=1)
			d[x]=d[y]+n-2*size[x];
		if(e[i].to==y)
			continue;
		dfs1(e[i].to,x);
	}
}

int main()
{
	cin>>n;
	for(int i=1;i<n;i++)
	{
		int a,b;
		cin>>a>>b;
		pre(a,b);
		pre(b,a);//要存无向图~
	}
	
	dfs(1,0);//这里是为了求注释里的son1~
	for(int i=1;i<=n;i++)
		d[1]+=size[i];//这里的d数组就相当于dp
	
	for(int i=1;i<=n;i++)
		size[i]+=1;
		
	dfs1(1,0);//开始求总路程
	
	for(int i=1;i<=n;i++)
		if(d[i]<ans)
		{
			ans=d[i];
			cnt=i;
		}
	cout<<cnt<<" "<<ans;
	return 0;
}
```



---

## 作者：Vocalise (赞：7)

这一题树上动态规划，是我首次自己搞出来的。

以为自己的不是正解，没想到跟正解**截然无二**

当然是定义f[i]=以i为根的最小距离和。

~~随便想想可以搞出，~~ 一个状态是可以被任意一个相邻状态推出的。

设j与i相邻：

$$f[i]=f[j]+(n-size[i])-size[i]$$

，size[]指去除<i,j>这条边（也就是删去j点）后有i的这个联通块的大小（节点个数）。

### 这个方程的意思是：

把树分为包含i一块，暂且称为i块；包含j一块，称为j块。

j块上的点到j的距离，和i块上的点到j的距离，构成了f[j].

如果把j挪到i上，j块上的点（共n-size[i]个）都需要再跑一步；而i块上的点（size[i]个），都可以少跑一步。***类似于线段上取点使得距离和最小经典问题的思想？？***

但是如果顺序杂乱无章，你就很不好记录size,也就无从转移。

根据树上动态规划的基本思路，我们想到钦定1为根，按照深度分块，**size记录的也就是子树的大小了**。

此时又有一个问题：是根转叶还是叶转根呢？我们发现，就算我们知道方程，知道size,第一个f[]的值还是得暴力算出来的。

当然，求诸叶不如求一根，那么思路就基本确定了：

1.DFs1():求出size,以及f[1].

2.DFs2():求出f[]数组其他值。

**~~根据树的常识~~,以一个节点为根的距离和便是所有点深度的和。**

但是这里开一个dep[]似乎有点浪费，于是我们有两个选择：一，是记录dep,DFs1返回size（当然，是不行的,size以后还要用）,二，

就是记录size,DFs1返回dep。

于是$O(2n)$的优秀复杂度通过本题。
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define maxn 50001

int n;
struct Edge{
	int x,y,nxt;
}e[maxn<<1];
int in[maxn],tot;
inline void ins(int x,int y){
	e[++tot].x=x;
	e[tot].y=y;
	e[tot].nxt=in[x];
	in[x]=tot;
}

int size[maxn];
int DFs1(int v,int fa,int dep){
	size[v]=1;
	int deps=dep;
	for(register int i=in[v];i;i=e[i].nxt){
		int u=e[i].y;
		if(u==fa)continue;
		deps+=DFs1(u,v,dep+1);
		size[v]+=size[u];
	}
	return deps;
}
int f[maxn]; 
void DFs2(int v,int fa){
	for(register int i=in[v];i;i=e[i].nxt){
		int u=e[i].y;
		if(u==fa)continue;
		f[u]=f[v]+(n-size[u])-size[u];
		DFs2(u,v);
	}
}

int main(){
	std::cin>>n;
	for(register int i=1,x,y;i<n;i++){
		std::scanf("%d %d",&x,&y);
		ins(x,y);
		ins(y,x);
	}
	f[1]=DFs1(1,0,0);
	DFs2(1,0);
	int ans=0x3f3f3f3f,ansi=1;
	for(register int i=1;i<=n;i++)
	  if(ans>f[i]){
	  	ans=f[i];
	  	ansi=i;
	  }
	std::printf("%d %d\n",ansi,ans);
	return 0;
}
```
比较下求n次dep和的$O(n^2)$算法，这种算法更好的利用了相邻点间的数量关系。

---

## 作者：KGV7 (赞：3)

**题意**：树上选一个点使所有点到它的距离之和最小，输出其编号和最小距离之和，如有多个，输出编号最小的一个

**题解**：设dp[i]位选i点时所有点到它的距离之和，考虑父子关系可得转移方程dp[now]=dp[father]+(n-size[now])-size[now]，问题就在于从哪里开始转移？可以求得dp[1]，然后向下转移，至于dp[1]怎么求：dp[1]=Σsize(i)(i≠1)。

**一共dfs两遍**，第一遍求size和Σsize（用ssiz表示），第二遍递推dp值。
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=5e4+4;
int n;
int head[N],etot=0;
struct EDGE {
	int v,nxt;
}e[N<<1];
int dp[N],siz[N],ssiz[N];
inline int read() {
	int x=0;char c=getchar();
	while (c<'0'||c>'9') c=getchar();
	while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x; 
}
inline void adde(int u,int v) {
	e[++etot].nxt=head[u],e[etot].v=v,head[u]=etot;
}
void dfs1(int p,int fa) {
	ssiz[p]=0,siz[p]=1;
	for (int i=head[p];~i;i=e[i].nxt) {
		int v=e[i].v;
		if (v==fa) continue;
		dfs1(v,p);
		siz[p]+=siz[v];
		ssiz[p]+=ssiz[v];
	}
	ssiz[p]+=siz[p];
}
void dfs2(int p,int fa) {
	for (int i=head[p];~i;i=e[i].nxt) {
		int v=e[i].v;
		if (v==fa) continue;
		dp[v]=dp[p]+n-(siz[v]<<1);
		dfs2(v,p);
	}
}
int main() {
	memset(head,-1,sizeof(head));
	n=read();
	for (register int i=1;i<n;++i) {
		int u=read(),v=read();
		adde(u,v),adde(v,u);
	}
	dfs1(1,0);
	for (int i=head[1];~i;i=e[i].nxt)
		dp[1]+=ssiz[e[i].v];
	dfs2(1,0);
	int mn=0x3f3f3f3f;
	for (register int i=1;i<=n;++i) mn=min(mn,dp[i]);
	for (register int i=1;i<=n;++i)
		if (dp[i]==mn) {
			printf("%d %d\n",i,mn);
			break;
		}
	return 0;
}
```

---

## 作者：redegg (赞：1)

~~真的是图论吗？~~

~~真的是DP吗？~~

我们可以发现，如果我们定义dp[ i ]表示第i个点作为会议地点的总长度，则可以发现，当我们把i--->j，（这个j意思是i距离1的点）i和j之间就像一条桥，连接着两个联通块，i所在的联通块所有点到会议地点的距离都要+1，而j所在的联通块到会议地点距离都会-1。

如果我们把1作为根节点建立一棵树，m[ i ]表示i点以下的子树（包括i）的节点数，则m[1]==n。

规定从根节点1向子节点转移。

同时得到转移方程：
```cpp
dp[i]=dp[father[i]]-m[j]+m[1]-m[j];
```

简化一下就是
```
dp[i]=dp[father[i]]-2*m[j]+n;
```

转移就靠dfs一遍即可！

那么如何求dp[1]的值呢？

在转移前dfs一遍即可！

代码如下：
```
#include <bits/stdc++.h>
using namespace std;

int n;
int m[60005];
int dp[60005];
vector<int> q[60006];

int maxn=1e9;
int ans;

int dfs(int x,int father)
{
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==father)continue;
        m[x]+=dfs(nx,x);
    }
    m[x]+=1;
    if(x!=1)dp[1]+=m[x];
    return m[x];
}

void dd(int x,int father)
{
    if(maxn>dp[x])
    {
        ans=x;
        maxn=dp[x];
    }
    if(maxn==dp[x])
        ans=min(ans,x);
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==father)continue;
        dp[nx]=dp[x]-m[nx]+m[1]-m[nx];
        dd(nx,x);
    }

}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        q[x].push_back(y);
        q[y].push_back(x);
    }
    dfs(1,1);
    dd(1,1);
    printf("%d %d\n",ans,maxn);
    return 0;
}

```

---

## 作者：chuzhitairan (赞：0)

以前做过一道有类似思想的动规题，所以很快就找到了思路，即找到父节点与子节点的关系，尝试由父节点推导子节点。
***
![](https://cdn.luogu.com.cn/upload/image_hosting/f79mfif6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们规定在一棵树中：
* 1为根节点，并按在树上的层位假定一个从上到下的顺序（在上图中，节点4下方有一个节点，节点1下方有四个节点）

* $cnt1_i$表示节点$i$及以下的节点总个数

* $cnt2_i$表示节点$i$以下的节点到$i$的距离总和

* $cnt3_i$表示其余节点到节点$i$的距离总和

&nbsp;

于是，我们可以推导一下关系式：设$f$为$s$的父节点，则其余的点到$s$的距离总和可以分为除了$s$及$s$下方的点的点到$s$的距离总和和$s$下方的点到$s$的距离总和。进一步我们发现，除了$s$及$s$下方的点的点到$s$的距离总和为除了$s$及$s$下方的点以外的点到$f$的距离总和再加上除了$s$及$s$下方的点的点数（即每个点的距离加一）。~~（好吧我已经把自己说晕了）~~   
&nbsp; 

还是直接看式子吧(=^ ^=)
&nbsp; 

$cnt3_s=cnt3_f-(cnt2_s+cnt1_s)+(n-cnt1_s)+cnt2_s$

$\qquad\;\;=cnt3_f-cnt1_s\times2+n$
&nbsp; 

结果我们惊讶的发现，数组$cnt2$竟然消失了Σ(⊙▽⊙)
&nbsp; 

话不多说，直接上代码吧

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=5e4+1;
int n,cnt1[maxn],cnt2[maxn],cnt3[maxn],book[maxn],ans=1<<30,id;
vector<int> e[maxn*2];
void dfs1(int x)
{
	for(int i=0;i<e[x].size();i++)
	{
		if(book[e[x][i]]) continue;
		book[e[x][i]]=1;
		dfs1(e[x][i]);
		//注意，先往下再计算 
		cnt1[x]+=cnt1[e[x][i]];
		cnt2[x]+=cnt2[e[x][i]];
	}
	cnt1[x]++;
	cnt2[x]+=cnt1[x]-1;
}
void dfs2(int x)
{
	for(int i=0;i<e[x].size();i++)
	{
		if(book[e[x][i]]) continue;
		book[e[x][i]]=1;
		cnt3[e[x][i]]=cnt3[x]-cnt1[e[x][i]]*2+n;
		//注意，先计算再往下 
		dfs2(e[x][i]);
	}
}
int main()
{
	scanf("%d",&n);
	int x,y;
	for(int i=1;i<n;i++) 
	{
		scanf("%d%d",&x,&y);
		e[x].push_back(y),e[y].push_back(x);
	}
	memset(book,0,sizeof(book));book[1]=1;dfs1(1);//预处理cnt1和cnt2 
	cnt3[1]=cnt2[1];//cnt2的作用，根节点下方的节点就是除了根节点以外的所有节点 
	memset(book,0,sizeof(book));book[1]=1;dfs2(1);//计算cnt3 
	for(int i=1;i<=n;i++) if(ans>cnt3[i]) ans=cnt3[i],id=i;
	printf("%d %d",id,ans);
	return 0;
}
```

	

---


# 洛谷的文件夹

## 题目描述

kkksc03 是个非凡的空想家！在短时间内他设想了大量网页，然后总是交给可怜的 lzn 去实现。

洛谷的网页端，有很多文件夹，文件夹还套着文件夹。

例如：$\verb!/luogu/application/controller!$ 表示根目录下有一个名称为 $\verb!luogu!$ 的文件夹，这个文件夹下有一个名称 $\verb!application!$ 的文件夹，其中还有名为 $\verb!controller!$ 的文件夹。

每个路径的第 $1$ 个字符总是 $\verb!/!$，且没有两个连续的 $\verb!/!$，最后的字符不是 $\verb!/!$。所有名称仅包含数字和小写字母。

目前根目录是空的。kkksc03 想好了很多应该有的文件夹路径名。问题是，需要是使这些文件夹都存在，需要新建几个文件夹呢？


## 说明/提示

### 数据范围及约定


- 对于 $20\%$ 数据，有 $N \le 20$；
- 对于 $50\%$ 数据，有 $N \le 200$；
- 另有 $30\%$ 数据，有对于所有路径最多存在两个 $\verb!/!$（包含第 $1$ 个字符）；
- 对于所有数据，$N \le 1000$。

## 样例 #1

### 输入

```
2
/luogu/application/controller
/luogu/application/view
```

### 输出

```
3
4
```

## 样例 #2

### 输入

```
3
/chicken
/chicken/egg
/chicken```

### 输出

```
1
2
2```

## 样例 #3

### 输入

```
4
/a
/a/b
/a/c
/b/b```

### 输出

```
1
2
3
5```

# 题解

## 作者：Anguei (赞：52)

正如 kkk 所说，使用 C++ 的 STL，非常轻松。

首先来梳理一下思路。

1. 题目问最少需要新建多少文件夹，即是问一共有多少个目录（因为每个文件夹只需要建立一次）。每次输入的数据可能会有重复的父文件夹，所以需要使用 $\texttt{std::set}$ 来保存目录。
2. 如何保存呢？因为每一级文件夹之间用 「/」隔开，所以只需要遍历一遍读入的字符串：
 1. 首先需要一个额外的字符串变量来保存已经遍历到的目录。
 2. 如果遇到「/」，就把当前字符串变量 $\texttt{insert()}$ 到集合里面。
 3. 然后将字符串加上当前字符。
 4. 最后再 $\texttt{insert()}$ 一次，以为最后一个字符不是「/」。
3. 对于每一次询问，只需要输出当前集合大小再减一就好了。为什么要减去一？因为第一次 $\texttt{insert()}$ 的时候是「/」，不算一个文件夹。

AC 代码就这几行。
```cpp
//【P1738】洛谷的文件夹 - 洛谷 - 100
#include <set>
#include <string>
#include <iostream> 

int main() {
    int n;
    std::cin >> n;
    std::set<std::string> set;
    
    for (int i = 1; i <= n; ++i) {
        std::string s;
        std::cin >> s;
        std::string dir = "";
        for (auto j : s) {
            if (j == '/')
                set.insert(dir);
            dir += j;
        }
        set.insert(dir);
        
        std::cout << set.size() - 1 << std::endl;
    }
}
```

---

## 作者：FutureThx (赞：15)

一道模拟题，用传说中神圣的 $STL$ 就可以解决一切。
## 题意
题面：[传送门](https://www.luogu.com.cn/problem/P1738)

## 思路

共 $N$ 行路径，对于每个路径把其中每个文件夹和路径记录下来，存到一个数组中，最后进行判重，输出个数。
$ $

什么意思呢？拿样例解释一下：
$ $
```
2
/luogu/application/controller
/luogu/application/view
```
对于第 $1$ 行，我们记录下：
$ $
```
1. /luogu
2. /luogu/application
3. /luogu/application/controller
```
共$3$个文件夹
$ $

接着读入第二行，记录：
```
1. /luogu
2. /luogu/application
3. /luogu/application/view
```
合并到一起，去重一下,就变成了：
```
1. /luogu
2. /luogu/application
3. /luogu/application/controller
4. /luogu/application/view
```
长度为 $4$

## 代码
这里我运用了$C++ \ \ \ STL$库中的 $set$ 容器
$ $

$set$ 容器可以帮我们的元素自动进行去重，具体操作见[这位大佬的博客](https://blog.csdn.net/yas12345678/article/details/52601454)

$100pts$代码：
```cpp
#include <iostream>
#include <set>
using namespace std;
int main(){
    set<string> s;
    int n,j = 1;
    cin >> n;
    for(int i = 1;i <= n;i++){
        string a,x = "/",father = "";j = 1;
        cin >> a;
        while(j != a.size() + 1){
            if(j == a.size())
                s.insert(father + x);
            else if(a[j] == '/'){
                s.insert(father + x);
                father = x  + father;
                x = "/";
            }
            else
                x += a[j];
            j++;
        }
        cout << s.size() << endl;
    }
    return 0;
}
```

## 后记
$Updata \ \ 2020.8.23 \ \ 20:36 : \ $完成文章，求管理员通过此篇蒟蒻的题解

---

## 作者：Haishu (赞：8)

P1738 Luogu

发一个链表题解！

仅有24ms，排名第一哦~



圆圈代表点，每个店有两个指针，一个指向自己兄弟（同级文件夹），另一个指向自己孩子（子文件夹），还有一个保存当前名字。

有点像二叉树孩子兄弟表示法……

![](https://img-blog.csdn.net/20180527002007836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0d1eGluZ1lpbGFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

那么我们从根节点寻找。对于每个节点，先找他的兄弟有没有符合要求的当前级名字，如果有，转到该兄弟的孩子节点上；如果没有，那就新建一个，计数器+1。



代码:

```cpp
#include <cstdio>
#include <cstring>
const int S=101;
int n,res=0,l,i,j;
char o[S],r[S];
struct info
{
	struct info *c,*b;
	char a[S];
}*root;
void dfs(int i,struct info *&p,bool fg,char r[])
{
	if (!o[i] && fg) return;
	int j=i;
	if (fg)
	{
		for (j=i+1;o[j] && o[j]!='/';j++) r[j-i-1]=o[j];
		l=j-i-1;r[l]=0;
	}
	if (p && strcmp(p->a,r)) dfs(j,p->b,false,r);
	else
	{
		if (!p)
		{
			p=new struct info;
			strcpy(p->a,r);res++;
			p->b=p->c=NULL;
		}
		dfs(j,p->c,true,r);
	}
}
int main()
{
	scanf("%d",&n);
	while (n--)
	{
		scanf("%s",&o);
		dfs(0,root,true,r);
		printf("%d\n",res);
	}
	return 0;
}

```

很简洁吧！：）

---

## 作者：rickyxrc (赞：7)

update 2020/1/24更改文章主体，使用$\LaTeX\!$。

这道题有一点迷惑因素，读起来会很晕，其实可以分析一下：

例如输入:
```
/luogu/a/b/c
/luogu/a/c/b
```
第一次一共新建了几个文件夹呢？想一想。

答案是4个，分别是
$\begin{cases}/ luogu / \\ / luogu / a / \\ / luogu/ a / b / \\ / luogu / a / b / c /\end{cases}$(记做a)

很容易懂吧，
那如果单独算第二次呢？

也会新建4个文件夹，是$\begin{cases} / luogu/ \\ / luogu / a / \\ / luogu / a / c / \\ / luogu / a / c / b / \end{cases}$(记作b)

那思路清晰了吗？

我们对于每一次，只需要求  a+b 中包含的元素数,但是直接a+b,就会变成：$\begin{cases} / luogu / \\ / luogu / a / \\ / luogu/ a / b / \\ /  luogu / a / b / c /\ \\ / luogu/ \\ / luogu / a / \\ / luogu / a / c / \\ / luogu / a / c / b /  \end{cases}$

相信大家一眼就能看出来,需要去重,去重后结果为：

$\begin{cases} / luogu / \\ / luogu / a / \\ / luogu/ a / b / \\ /  luogu / a / b / c /\ \\ / luogu / a / c / \\ / luogu / a / c / b /  \end{cases}$

大声告诉我元素数是多少!

如果你的答案是6，那你就正确了.

~~现在我们开始解题~~

首先是读入，很明显，我们读入
```
/luogu/a/b/c/d
```
要返回
```
/luogu/
/luogu/a/
/luogu/a/b/
/luogu/a/b/c/
/luogu/a/b/c/d/
```
怎么做到呢?由于我是个蒟蒻，所以我用了$\begin{matrix}2^{31}-1\\\overbrace{veryvery\cdots very}\end{matrix}$ 愚蠢的方法,像这样:
```cpp
cin>>m;
    c=m[0];
    for(int i=0;i<m.length();i++,c=m[i]){
	    r+=c;
	    if(i&&c=='/'||i+1==m.length()){
			cout<<r<<endl;
		   if(r[r.length()-1]!='/')
				r=r+'/';
	    }
    }
```

那判断呢?也很简单，可以用一个map来记住文件夹全名,只需记住有没有出现
```cpp
map<string,bool>；

//下面是判断是否出现的代码：

map<string,bool>::iterator it;
it=map.find(/*字符串*/);
if(it==map.end())	//未找到
else	//找到
```

这样就可以上[AC](https://www.luogu.com.cn/record/45428130)代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,bool>flg=map<string,bool>();
map<string,bool>::iterator it;
int main(){
	ios::sync_with_stdio(false);
	int n,num=0;
	cin>>n;
	string m,r;
	char c;
	bool f=1;
	for(int i=1;i<=n;i++){  
		cin>>m;
		c=m[0];
		for(int i=0;i<m.length();i++,c=m[i]){
			r+=c;
			if(i&&c=='/'||i+1==m.length()){
				if(r[r.length()-1]!='/')
                    r=r+'/';
				it=flg.find(r);
				if(it==flg.end()){ 
					num++;
					flg[r]=1;
				}
			}
		}
		if(!f)
			cout<<endl;
		f=0;
		cout<<num;
		r=string("");
	}
}
```
祝大家~~也祝我~~早日红名

---

## 作者：doby (赞：6)

这份代码没有用什么高级的算法，你们可以自己改一下……

这个题模拟起来很麻烦……

但是处理完字符串也很简单……

```cpp
#include<string>
#include<iostream>
using namespace std;
int n,k,sl,maxnn,su,sum=0,sll[1009];
string s[1009],m[1009][3009],ls;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
        sl=0;//统计文件夹数量
        for(int j=0;j<s[i].size();j++)
        {
            if(s[i][j]=='/')//这是一个文件夹
            {
                ls="",j++;
                for(;s[i][j]!='/'&&j<s[i].size();j++){ls=ls+s[i][j];}
                j--,sl++,m[i][sl]=ls;//这里是把这个文件夹名字放进了m(ap)数组
            }
        }
        sll[i]=sl;//每一串目录下是多少个文件夹
        maxnn=0,sum=sum+sl;//提前把sum加上当前数量
        for(int k=1;k<i;k++)
        {
            su=0;
            for(int j=1;j<=sll[i]&&j<=sll[k];j++)
            {
                if(m[i][j]==m[k][j]){su++;}
                else{break;}
            }
            if(su>maxnn){maxnn=su;}//找出最大的重复的目录
        }
        sum=sum-maxnn;//减去这个最大重复，就是当前的最少数量
        cout<<sum<<endl;//输出
    }
    return 0;
}
```

---

## 作者：HanPi (赞：5)

 # [P1738 洛谷的文件夹](https://www.luogu.com.cn/problem/P1738)

**由于本人最近深受~~毒瘤~~题目:[P2262 [HNOI2004]FTP服务器](https://www.luogu.com.cn/problem/P2262)的影响,在加上发现这道题和我打的folder类特像,就愉快的改了一下实现,就AC了.**

~~可能是FTP那题WA了太多次,我感觉这个folder类挺好改的QAQ~~

## 代码:
```cpp
// P1738 洛谷的文件夹
#include <cstdio>
#include <string>
#include <vector>
int n;
char name[120];
class folder
{
public:
    std::string name;
    std::vector<folder*>folders;

    folder* Find(std::string folderName) // 找到当前路径下文件夹
    {
        for (std::vector<folder*>::iterator i = folders.begin(); i != folders.end(); i++)
        {
            if ((*i)->name == folderName)return (*i);
        }
        return NULL;
    }

    int AddFolder(std::string destName)
    {
        destName += '/'; // 要靠'/'来标识
        int l = destName.length();
        std::string str = ""; // 存储文件夹名
        folder* now = this;
        int res = 0; // 存创建了几个文件夹
        for (int i = 1; i < l; i++) //忽略第一个'/'
        {
            if (destName[i] == '/')
            {
                folder* findF = now->Find(str);
                if (findF)
                {
                    now = findF; // 找到就进入
                }
                else
                {
                    now->folders.push_back(new folder(str));
                    now = now->folders.back();
                    // 否则创建后再进入
                    res++;
                }
                str = "";
            }
            else
            {
                str += destName[i];
            }
        }
        return res;
    }

    folder(std::string folderName)
    {
        this->name = folderName;
    }
};
int main()
{
    folder f = folder("ROOT");
    int ans = 0;
    scanf("%d", &n);
    while (n--)
    {
        scanf("%s", &name);
        printf("%d\n", ans+=f.AddFolder(name));
    }
    return 0;
}
```


---

## 作者：windows250 (赞：5)

一道挺有趣的模拟题hhhh，文件夹的树形结构可以简单地用类似字典树的结构来存储，每行输入结束后输出树中节点数即可，顺便介绍下stl的map容器

**详细见代码:**

```cpp
#include<bits/stdc++.h>
#define MAXN 50001

using namespace std;

struct floor
{
    map<string,int> next;//map:映射，如next["root"]=1,即"root"文件夹在tree上的编号为1,next[str]=null时说明文件夹还未创建 
}tree[MAXN];
int N,cnt=0;

int main()
{
    ios::sync_with_stdio(false);
    cin>>N;
    for(int i=1;i<=N;i++)
    {
        char tmp[101]={0};
        string t="";
        int now=0;//每次开始操作需要把当前位置清0 
        cin>>tmp;
        for(int i=1;i<=strlen(tmp);i++)//从1开始为了忽略开头的'/',注意这里的"<=",用于判断是否已经到了行末 
            if(tmp[i]=='/' || i==strlen(tmp))//当遇到'/'或行末时进行 查找/创建 操作 
            {
                if(!tree[now].next[t])//当前层中不存在t文件夹 
                    tree[now].next[t]=now=++cnt;//新建"文件夹",并进入该文件夹,cnt是文件夹的创建数 
                else now=tree[now].next[t];//存在t就直接进入文件夹 
                t="";//每次操作完毕记得清空文件夹名 
            }
            else if(tmp[i]!='/') t+=tmp[i];//当没遇到'/':相当于逐字母输入文件夹名 
        cout<<cnt;if(i!=N) cout<<endl;//每次输出创建文件夹数cnt即可(cnt不能清0!) 
    }
    return 0;
}
//By windows250
```

---

## 作者：SIXIANG32 (赞：4)

# 本蒟蒻的题解
这是我第一道绿题诶，好激动呢，写完赶紧发个题解。  
[题目传送门](https://www.luogu.com.cn/problem/P1738)  
——————————————————————    
这道题有很多做法：如树（正常），集合（有点怪），map（有点怪），递推（什么玩意儿），等等等等。  
切入正题：  
显而易见这是一个求一个树一共有多少个节点的问题，但是我们可以想简单点，把它们想成并列的关系，这样的话就成了一个集合了，结果也不会错误，还更加的方便。集合也很简单，就是分离出每个名字去重即可，STL还有专门的set容器，但不推荐用algorihtm的unqiue来去重，因为经常出锅，令人崩溃。（亲测十分，可能是我太弱了QWQ）   
———————————————————————   
当你写完了set之后，你会发现……  
样例3过不了啊~~~  
（如雷轰顶.png）
```
/d/d
```
WHAT？？？？纳尼？？？怎么还有这种操作？？？~~kkk你出来你给我解释解释！！！~~  
怎么解决呢？其实也十分的简单，只要把它的父亲文件夹作为后缀或前缀即可。建议以```_、/、\```等分割，否则可能会出bug。这样就可以了，毕竟kkk也不会出两个同样的文件夹在同一个文件夹里的测试点吧，这样是会惹电脑生气滴。  
——————————————————————  
我的代码：
```cpp
#include<iostream>
#include<set>
#include<string>
using namespace std;
string fa;
set<string>names;//新建一个string类型的集合
int main()
{
	int n;
	cin>>n;
	string str[10000],name;
	for(int p=1;p<=n;p++){
		cin>>str[p];
		str[p]=str[p]+'/';//如果不加可能会出锅。
	}
	for(int p=1;p<=n;p++)
	{
		fa="";//初始化父亲文件夹
		for(int i=0;i<=str[p].size()-1;i++)
		{
			if(str[p][i]=='/'&&i!=str[p].size()-1){
				name="";
				while(str[p][++i]!='/')//分离名字
					name+=str[p][i];
				name=name+'_'+fa;//后缀，不然会出小问题
				fa=name;//父亲文件夹更新
				names.insert(name);//插入
				i--;//小细节，不然也会出bug
			}
		}
		cout<<names.size()<<endl;//输出，没啥可讲的
	}
    return 0;//完美的结束啦，欧耶，一道活生生的绿题就这样倒在了我们的眼前（滑稽）
}
```
听了我的一通分析，你们会做了吗？  

---

## 作者：盖矣斌峥 (赞：4)


[本人博客](https://prime.design.blog/)

看上去像一道**trie**的裸题

每次输入一串字符串，从根开始遍历，找得到就进入，找不到就新建，并ans++。

------------

推荐一个函数：substr
```
s.substr(i,x)//表示从i开始向后截取x位
//例如s="abcdefg"
//那么s.substr(2,2)="cd" 
```
这样就可以把每个‘/’前的字符串提取出来，再判一下是否建过就行了

在判是否有已经建好的子文件夹的时候用了一下map

------------
见代码：

```
#include<map>
#include<stdio.h>
#include<cstring>
#include<iostream>
using namespace std;
struct trie{
	map<string,int>hash;
}tree[1000005];
int cnt=0;
void Insert(string s)
{
	int i,root=0;
	for(i=1;i<s.length();i++)
	{
		string ss;
		if(s[i]=='/')
		{
			ss=s.substr(1,i-1);
			if(tree[root].hash[ss]==0)
			{
				tree[root].hash[ss]=++cnt;
				root=cnt;
			}
			else root=tree[root].hash[ss];
		}
	}
	s=s.substr(1,s.length()-1);
	if(tree[root].hash[s]==0)
	{
		tree[root].hash[s]=++cnt;
		root=cnt;
	}
	else root=tree[root].hash[s];
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		string s;int bj=0;
		s.resize(105,32);
		scanf("%s",&s[0]);
		for(int i=104;i>=0;i--)
			if(s[i]!=32)
			{
				bj=i;
				break;
			}
		if(bj!=0)
			s=s.substr(0,bj);
		else s=s.substr(0,1);
		Insert(s);
		printf("%d\n",cnt);
	}
}
```


---

## 作者：_Clown_ (赞：3)

## 一、目录概览
- 一、目录概览
- 二、题目大意
- 三、大致思路
- 四、代码实现
- 五、代码剖析
- 六、总结回顾
## 二、题目大意
kkksc03想好了很多应该有的文件夹路径名。

问题是，需要是使这些文件夹都存在，需要新建几个文件夹呢？

文件夹路径是什么？例如/A/B/C，表示在根目录下有A文件夹，在A文件夹里有B文件夹，在B文件夹里有C文件夹。其他路径同理。
## 三、大致思路
这道题目我们需要用set来解决。

[这里](https://baike.baidu.com/item/set/2306085)可供学习。

我们在这道题用set的无重性质。

将每个文件夹的路径都添加进set。

假设给了你一个/A/B/C。

那么你需要：

加入A的路径，set.insert("/A");

加入B的路径，set.insert("/A/B");

加入C的路径，set.insert("/A/B/C");
## 四、代码实现
**解释见第六区**
```cpp
#include<bits/stdc++.h>
using namespace std;
int Total;
string Now;
int main(void)
{
	register int i;
	cin>>Total;
	register set<string>Set;
	Set.clear();
	while(Total--)
	{
		register string Push;
		cin>>Now;
		Push="";
		for(i=0;i<Now.size();i++)
		{
			if(Now[i]=='/')
			{
				Set.insert(Push);
			}
			Push+=Now[i];
		}
		Set.insert(Push);
		cout<<Set.size()-1<<endl;
	}
	return 0;
}
```
## 五、代码剖析
```cpp
#include<bits/stdc++.h>
using namespace std;
int Total;
string Now;
int main(void)
{
	register int i;
	cin>>Total;
	register set<string>Set;//定义set
	Set.clear();//清空set
	while(Total--)
	{
		register string Push;
		cin>>Now;
		Push="";//每次加进set的字符串
		for(i=0;i<Now.size();i++)//扫描字符串
		{
			if(Now[i]=='/')//如果扫完一个文件夹
			{
				Set.insert(Push);//那么就加入路径
			}
			Push+=Now[i];//更新路径
		}
		Set.insert(Push);//加入最后文件夹的路径
		cout<<Set.size()-1<<endl;//减去“/”这个字符串
	}
	return 0;
}
```
## 六、总结回顾
这道题目，我们使用了STL_set来解决问题。set的最大特点是去重和有序性。
## The End

---

## 作者：cxh125011501 (赞：3)

简单模拟，开个set保存目录

```cpp


#include<iostream>
#include<vector>
#include<set>
#include<string>
using namespace std;
set<string> sss[52];
int main(){
    string a,b;
    int n;cin>>n;
    for(int i=0;i!=n;++i){            //外循环  按每一行 
        cin>>a;
        int tt=0;
        b="";
        for(int i=1;i!=a.size();++i)        //逐字符处理 
        {
            if(a[i]!='/') b=b+a[i];
            if(a[i]=='/'){                    //遇见/保存当前目录 
                sss[tt].insert(b);
                ++tt;
                b=b+a[i];
            }
            if(i==a.size()-1) sss[tt].insert(b);   //处理完最后一个字符保存目录 
        }
        int sum=0;
        for(int i=0;i!=51;++i){
            sum+=sss[i].size();
            cout<<sum<<endl;
        }
    }
}
    


```

---

## 作者：离散小波变换° (赞：2)

## 题目简述

给出$n$个地址，每次询问需要至少多少个文件夹才能使这些地址都合法。

$n\leq 10^3,|S_i|\leq100.$

---

## 题解

大家都写了不少$\text{Trie}$(字典树)和$\text{map}$的题解，这里就讲一讲哈希和关于字符串的一些坑点吧。

### 关于字符串哈希

一种非常简单的哈希方法：

$$H(S)=\sum_{i=1}^{|S|}(S_i\times seed^{i-1}) \mod P$$

**注：这里字符串下标从1开始**

简单地理解一下，就是将$S$当作一个$seed$进制数。这种哈希算法本质就是将它转化成十进制（并取模）。

写成代码就是

```cpp
int hash(char *s,int l){
    int ret=0;
    for(int i=1;i<=l;i++)
    ret=(ret*seed+s[i])%P;
    return ret;
}
```
通常我们可以直接使用$\text{unsigned long long}$的自然溢出（即自动对$2^{64}$取模）。

### 关于哈希的实现细节

我们已经成功写出哈希函数了。然而由于哈希碰撞（即产生了相同的哈希值，程序判断两个元素相等），~~一定是因为我太非了~~，导致这种哈希方法可能会$\red{\text{WA}}$，最后只拿了$50\text{pts}$。

因此我们可以选择链式哈希，即开数量较多的链表（比如$10^6$个），通过取模将要查找的值定位在对应的链表里，然后查找是否有相同的数字。这种方法可以**避免**因为哈希碰撞造成的问题，又可以一定程度上降低时空复杂度。

另外，这里~~为了偷懒~~用了一个可能有点迷惑的办法。在实现图的存储的时候，我们往往使用链式前向星。然而链式前向星本质就是链表。$\text{head}$数组相当于刚刚说的表头，而**加边相当于在对应链表中添加元素**。

```cpp
//注：ULL即unsigned long long
const int MAXS=1e6+3;
int head[MAXS],nxt[MAXS],tot;
ULL val[MAXS];
void add(int u,ULL w){	//经典的链式前向星加边
    nxt[++tot]=head[u],val[tot]=w,head[u]=tot;
}
char *c; int n,ans;
bool gethsh(ULL t){
    for(int i=head[t%MAXS];i;i=nxt[i]){
        if(val[i]==t) return true;
    }
    add(t%MAXS,t);	//相当于在表[t%MAXS]中添加了值为t的元素。
    return false;
}
```

这个实现方式可能比较迷惑，这里稍微说明一下。这是有向边，从表头发射的边的边权才是对应的数字，因此这条边指向谁都无所谓。（甚至可以让它们都指向同一个点）。所以我们可以直接把这些边**指向的点**都砍掉而只保留边权。

~~当然你直接用map代替哈希表当我没说~~

### 读入的细节

众所周知，因为$\text{Windows,Linux}$的差别，生成出来的数据是不一样的。（$\text{Linux}$的数据换行时会多添加一个`'/r'`）。所以往往$\text{getline,scanf,cin,fread}$等众多输入方法不得不面对这个问题。这里给出的解决方法是手写一个$\text{getline}$。（不过由于这题的特殊性质，每行只有一个字符串，所以可以大胆使用$\text{cin,scanf}$）。

**但是要注意的是读入字符串的长度问题**（可能长度会因为`'\r'`而+1之类）。所以建议手写一个读入吧。

```cpp
int readl(char *s){	//读入整行
    int l=0; char c;
    while((c=getchar())=='\r'||c=='\n'); s[++l]=c;
    while((c=getchar())!='\r'&&c!='\n')  s[++l]=c;
    return l;
}
void read(int &l,ULL &ret){	//从字符串S的第l位置读入，并将结果以哈希的形式并入ret
    char c; while((c=S[++l])!='/') ret=ret*seed+c;
}
```

### 拼接起所有的部分

对于每一次输入，我们先读入整段。然后分段进行哈希，检查哈希值是否出现过。要注意的是，'/'字符也需要并入地址中。

```cpp
n=qread(); for(int i=1;i<=n;i++){
        ULL nw=0;int p=1,l=readl(S);S[l+1]='/'; while(p<=l){
        read(p,nw); if(!gethsh(nw)) ++ans;
        nw=nw*seed+19260817;
    }
    printf("%d\n",ans);
}

```
### 该题的数据缺陷

为什么我要手写一个全行读入？因为第六个测试点结尾出现了`'/'`。原计划是边读边计算，读到`'\n'`就判断该次询问结束，`'\r'`就判断该次询问继续。然后炸惹$\text{qaq}$。

[给管理员看的帖子，内含第六个测试点的保证不会出错的数据生成器，请尽快修复第六个点](https://www.luogu.com.cn/discuss/show/192333)

[第⑥个点挂掉惹QAQ](https://www.luogu.com.cn/record/30792858)

---

## 参考程序

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
typedef unsigned long long ULL;
const ULL seed=13331;
const int MAXL =100+3;char S[MAXL];
int readl(char *s){			//全行读入
    int l=0; char c;
    while((c=getchar())=='\r'||c=='\n'); s[++l]=c;
    while((c=getchar())!='\r'&&c!='\n')  s[++l]=c;
    return l;
}
void read(int &l,ULL &ret){	//从字符串内读入
    char c; while((c=S[++l])!='/') ret=ret*seed+c;
}
const int MAXS=1e6+3;
int head[MAXS],ver[MAXS],nxt[MAXS],tot;
ULL val[MAXS]; int cnt[MAXS];
void add(int u,int v,ULL w){
    ver[++tot]=v,nxt[tot]=head[u],val[tot]=w,head[u]=tot;
}
char *c; int n,ans;
bool gethsh(ULL t){		//查询
    for(int i=head[t%MAXS];i;i=nxt[i]){
        if(val[i]==t) return true;
    }
    add(t%MAXS,++cnt[t%MAXS],t); return false;
}
int main(){
    n=qread(); up(1,n,i){
        ULL nw=0;int p=1,l=readl(S);S[l+1]='/'; while(p<=l){
            read(p,nw); if(!gethsh(nw)) ++ans;
            nw=nw*seed+19260817;
        }
        printf("%d\n",ans);
    }
    return 0;
}
//不要吐槽我为什么不用string，因为我觉得string下标从零开始等迷惑特性很难受
```


---

## 作者：happybob (赞：1)

这是个集合的题目，因为大家都知道set可以自动去重，我们就借助这个特性去做。

for循环n次，每次读入这个字符串然后遍历每个字符，是'/'就insert，因为一开始也是'/'那就输出size() - 1，还要注意的是因为最后不是'/'，循环完要再insert一次：

```cpp
#include <iostream>//cin cout头文件
#include <cstring>//string头文件，只用的话可加可不加，如果是像要用find，erase，length这些就要加上
#include <set>//set头文件
using namespace std;

set <string> st;

string s;

int main()
{
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
       cin >> s;
       string x = "";
       for(auto j : s)
       {
           if(j == '/')
           {
               st.insert(x);
           }
           x += j;
       }
       st.insert(x);
       cout << st.size() - 1 << endl;
    }
    return 0;
}
```

那这个循环auto是啥呢？对于这个字符串，auto j : s可以起到遍历每个字符的作用，更多细节自行百度

---

## 作者：fls233666 (赞：1)

要解决这个问题，最重要的就是根据文件夹之间的关系构建数据结构。

仔细观察可以发现，这些文件夹构成了一个类似Trie树的结构。显然，我们可以用Trie树把整个文件夹路径存下来，然后统计Trie树节点得到答案。

进一步分析，我们发现此题的难点在于如何构建这个Trie树。

一般用来存字符串的Trie树构建函数写法大概是这样的：

```cpp
void add(string str){
	int len=str.size();
	int p=0;
	for(int i=0;i<len;i++){
            int c=str[i]-'a';   //把字符串拆开成每个字符进行存储
            if(trie[p][c]){    //如果此节点为空则增加新节点
      	        cnt++;   //增加节点总数
                trie[p][c]=cnt;   
            }
            p=trie[p][c];   //往下一层继续存储
       }
}
```

那么，我们根据这个函数进行改造，得到了存储文件路径的如下伪代码：

```cpp
void add(文件夹路径){
    int len=文件夹路径字符串长度;
    int p=0;
    for(int i=0;i<len;i++){
       提取出文件夹路径中的文件夹字符串
       if(trie[p][文件夹]){    
      	    cnt++;   
            trie[p][文件夹]=cnt;   
       }
       p=trie[p][文件夹];   
   }
}
```

根据这段伪代码继续深入分析，我们发现，从文件夹路径提取出来的文件夹名称必定是一个字符串。字符串显然是不能直接当作数组下标的，怎么办？

这个时候，我们就可以请出 C++ 强大的 STL 容器。我们可以使用映射（map）,把 string 类型变成数组下标直接使用即可。

于是我们就可以把文件夹Trie树构建起来了。那么这题的问题就解决了。下面是本人的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<map> 
#define ll long long
#define pir pair<int,string>
#define rgt register int
using namespace std;
const int mxn = 1111;
map<pir,int>mp;
string str[mxn],tstr;
int ans,n,cnt,p;
pir tg;
int main(){
	cin>>n;
	for(rgt i=1;i<=n;i++){
		cin>>tstr;   //读入一个文件夹路径
		cnt=0;   //统计此路径中有多少个文件夹
		for(rgt ls=tstr.size(),j=1;j<ls;j++){
			if(tstr[j]=='/')
				cnt++;
			else
				str[cnt]+=tstr[j];   //提取路径中的文件夹
		}
        
     //构建Trie树
		p=0;
		for(rgt i=0;i<=cnt;i++){
			tg=make_pair(p,str[i]);  //用map把字符串当作下标
			if(!mp[tg]){
				ans++;   //增加节点
				mp[tg]=ans;
			}
			p=mp[tg];
		}
        
		cout<<ans<<endl;  //输出节点数，即答案
		for(rgt i=0;i<=cnt;i++)   
			str[i]="";
	}
	
	return 0;
}
```


---

## 作者：intel_core (赞：1)


	首先我们考虑左括号的数量一定严格大于等于右括号的数量。    
	其次我们用数组保存每一个字符，O(N)算法绝对能过，所以我们可以放心枚举每个字符（但是右括号大于左括号时return 0）     
	下附AC代码
   ```cpp
#include<bits/stdc++.h>                           
using namespace std;                            
char ch[255];                                 
int main(void){                             
	scanf("%s",ch);                       
	int len = strlen(ch),a=0,b=0;               
	for(int i=0;i<len;i++){                                                                                
		if(ch[i]=='(')                                    
			a++;                                    
		if(ch[i]==')')                      
			b++;                   
		if(b>a){                       
			cout<<"NO";                          
			return 0;                       
		}
	}                        
	if(a==b)                            
		cout<<"YES";                        
	else                 
		cout<<"NO";                     
	return 0;
}
```

---

## 作者：chengni (赞：1)

这道题数据范围比较小，所以我是用map做的

因为对于一个同一个的文件夹，他的前缀（就叫前缀吧）一定是相同的

我的做法是用map直接保存从目录到此文件夹的字符串是否存在，如果不存在则保存并计数，

我在读入的时候给行末都加了一个‘/’，并且忽略了行首的第一个‘/’.

举个栗子，比如对于第一个样例，第一行
```cpp
luogu/application/controller/
```

我的map存储的是

```cpp
luogu/
luogu/application/
luogu/application/controller/
```
对于第二行数据
```cpp
luogu/application/view/
```
在判断的时候我们发现
```cpp
luogu/
luogu/application/
luogu/application/view/
```
这三个字符串中前两个都是出现过的，于是我们只需要记一个数


在读入的时候处理一下就好了，完整的读入了一个文件夹后进行判断，因为我在最后加了一个‘/’，所以读入到‘/’时就代表读入了一个完整的文件夹名。

当然我存储的时候也把‘/’存进去了，问题不大

代码就是下面这样

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read(){
    char ch=getchar();int x=0,f=1;
    while(ch<'0' || ch>'9') {
       if(ch=='-') f=-1;
      	  ch=getchar();
    }
    while(ch<='9' && ch>='0') {
       x=x*10+ch-'0';
       ch=getchar();
    }
    return x*f;
}

map<string,int> mp;

int cnt=0;

string ch;

int main(){
    int n=read();
    while(cin>>ch){
        int l=ch.size();
        ch+='/';
        string a="";
        for(int j=1;j<=l;j++){
            a+=ch[j];
            if(ch[j]=='/'){
                if(mp[a]==0){
                    mp[a]=1;
                    cnt++;
                }
            }
        }
        n--;
        cout<<cnt<<endl;;
    }
    while(n){
        cout<<cnt<<endl;
        n--;
    }
    return 0;
}

```

第六个点似乎有问题，后面有空行，稍微处理了一下

---

## 作者：hibiki (赞：1)

可以建立一个trie树存整个目录，不过因为存在数字和'/'所以不能直接用'a'..'z'当下标而要通过函数转换。为了避免程序认为/aaa建立后已经把/aa包含在内，可以在字符串末尾再增加一个'/'，每次读到'/'时如果新建了节点就更新答案。这样的话在第一次新建'/'节点（也就是由根目录导出的'/'节点）时会多计算一次答案，所以输出时需要把答案-1，当然也可以在开始建好第一个'/'节点。

直接建立'/'节点的代码:


```cpp
Const
    MAX=100000;
Function refer(a:char):longint;
    begin
        if ('a'<=a) and (a<='z') then exit(ord(a)-ord('a')+1);
        if ('0'<=a) and (a<='9') then exit(ord(a)-ord('0')+27);
        if a='/' then exit(37);
    end;
Var
    trie:array[0..MAX,1..37] of longint;
    i,j,now,n,ans,cnt:longint;
    t:ansistring;
Begin
    ans:=0;
    cnt:=1;
        trie[0,refer('/')]:=1;
    readln(n);
    for i:=1 to n do begin
        readln(t);
        t:=t+'/';
        now:=0;
        for j:=1 to length(t) do begin
            if trie[now,refer(t[j])]<>0 then now:=trie[now,refer(t[j])] else begin
                inc(cnt);
                trie[now,refer(t[j])]:=cnt;
                if (t[j]='/') then inc(ans);
                now:=cnt;
            end;
        end;
        writeln(ans);
    end;
End.
```
答案减一的代码:

```cpp
Const
    MAX=100000;
Function refer(a:char):longint;
    begin
        if ('a'<=a) and (a<='z') then exit(ord(a)-ord('a')+1);
        if ('0'<=a) and (a<='9') then exit(ord(a)-ord('0')+27);
        if a='/' then exit(37);
    end;
Var
    trie:array[0..MAX,1..37] of longint;
    i,j,now,n,ans,cnt:longint;
    t:ansistring;
Begin
    ans:=0;
    cnt:=0;
    readln(n);
    for i:=1 to n do begin
        readln(t);
        t:=t+'/';
        now:=0;
        for j:=1 to length(t) do begin
            if trie[now,refer(t[j])]<>0 then now:=trie[now,refer(t[j])] else begin
                inc(cnt);
                trie[now,refer(t[j])]:=cnt;
                if (t[j]='/') then inc(ans);
                now:=cnt;
            end;
        end;
        writeln(ans-1);
    end;
    //writeln(ans);
End.

```

---

## 作者：学霸壹号 (赞：0)

## 前言
这是一篇C++题解，别的语言的oier请避开。
## 做法及相应程序
1. 这回我们用C++STL里面的set来做这道题。set可以自动去重，具体函数等用法去[C++官网](http://www.cplusplus.com/reference/set/set/)来学习，我们这里不一一介绍。

---
2. for循环，边读边算。这一点应该大家应该很清楚。但是我们发现，后面的代码中，不需要用到读进来的N，所以推荐一种更省事的：
```cpp
while(n--){
	...;
}
```
不会的人手推一下，应该能理解。

---
3. 这道题问你，要新建多少个文件夹？我们刚开始的想法可能是“把文件夹名字用set存下来，看有多少个名字就可以了”，但是如果有同名的文件夹，例如**/akioi/akioi**那怎么办呢？我们可以站在资源管理器（explorer)的角度来想一想，每建一个文件夹，相当于多了一条路径（path），我们可以把路径存下来，这样就不用判断是否是一个文件夹了。

---
4. 下面就是分离路径了。具体见代码哦！
```cpp
while(n--){
	cin>>x;	//这里x是个字符串！把它读进来。
	x+='/';	//拼上一个/，是为了后面的判断。
	int j=1;	//第一个/没啥用，j指向的是可用的字符。
	string sx;	//这个字符串其实就是替代substr()，慢慢累加，无多余循环。
	while(j<x.size()){	//这个字符是一个“真实存在”的字符
		while(x[j]!='/'){	把这个文件夹名字先弄到sx里。
			sx+=x[j];
			++j;
		}
		sx+='/';	//上面的循环条件一定成立，因为最“烂”的情况下，代码第3行还加了一个‘/’，不用担心出问题。先加一个‘/’，因为x[j]==‘/’。
		fo.insert(sx);	//记录路径，自动判重。
		++j;	//x[j]一定是‘/’，但是j指向的是可用字符，所以加1。补充：前置++比后置++快。
	}
	cout<<fo.size()<<endl;//打印当前路径数量。
}
```
---
你还想看什么？~~没啦！~~不对，还有
```cpp
return 0;
```
完整代码自己写。~~其实没有多少，只有定义变量~~

---


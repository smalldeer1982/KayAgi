# 树的分解

## 题目描述

给出 $N$ 个点的树和 $K$，问能否把树划分成 $\frac{N}{K}$ 个连通块，且每个连通块的点数都是 $K$。

## 说明/提示

- 对于 $60 \%$ 的数据，$1 \le N, K \le 10^3$；
- 对于 $100 \%$ 的数据，$1 \le T \le 10$，$1 \le N ,K \le 10^5$。

## 样例 #1

### 输入

```
2
4 2
1 2
2 3
3 4
4 2
1 2
1 3
1 4
```

### 输出

```
YES
NO```

# 题解

## 作者：YoungLove (赞：27)

如果存在能将一棵树分成若干个大小为$k$的联通块的方案数，那么每一个联通块都有一定是一棵子树，且分割方案是唯一的，因此我们队这棵树进行深搜，并同时记录子树大小，如果当前大小恰好为$k$的话，就将该子树大小记录为0，相当于剪去这一部分。最后只要判断剪掉的部分时候等于$n/k$就可以了。


## 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# define R register
# define LL long long

using namespace std;

int n,k,e,h[100010],x,y,T,siz[100010],tot;
struct zx{int v,pre;}ed[200010];

template <typename T> void in(R T& a){
    R char c = getchar();R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f = -1; c = getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

inline void add(R int x,R int y){
    ed[++e] = (zx){y,h[x]};
    h[x] = e;
}

inline void dfs(R int x,R int fa){
    siz[x] = 1;
    for(R int i=h[x]; i; i=ed[i].pre){
        R int p = ed[i].v;
        if(p == fa) continue;
        dfs(p,x);
        siz[x] += siz[p];
    }
    if(siz[x]==k) tot++,siz[x] -= k;
}

int main(){
//     freopen("sample.in","r",stdin);
//     freopen("sample.out","w",stdout);
    in(T);
    while(T--)
    {
        in(n),in(k);
        e=tot=0;
        memset(siz,0,sizeof(siz));
        memset(h,0,sizeof(h));
        for(R int i=1; i<n; ++i)
        {
            in(x),in(y);
            add(x,y);
            add(y,x);
        }
        if(n%k != 0) {printf("NO\n");continue;}
        dfs(1,-1);
        if(tot == n/k) printf("YES\n");
        else printf("NO\n");
    }
}

```
另外~~臭不要脸~~的推广一下我的**博客**[Youngsc](https://youngscc.github.io/);


---

## 作者：fanhy (赞：23)

20/3/7修正：修订了例子描述中的错误。

首先感谢一下redegg大佬给我的提示。

~~这题题解怎么那么少~~

****

好了，先讲一下思路。

我得承认楼下的题解我没有看得很懂。

![原图](https://cdn.luogu.com.cn/upload/pic/35675.png)

原谅我丑陋无比的图。

现在我们假设$k=2$。

从根节点(1)开始遍历。

先遍历左子树，则a[4]=1，a[3]=2。

所以（3,4）为一组。

2遍历到3时，3因为已经和4组队，所以3返回给2的值为1。

同理，1也可以和2组队。





然后遍历右子树。

因为a[6]=a[7]=1，

所以a[5]的值为3。

3已经大于k(2)了，所以不用再考虑5号节点的祖先与5号配对的情况，直接回到根节点。

所以根结点的右子树没有配对成功。

由于两个子树中只要有一个没有配对成功即失败，所以输出"NO"。

最后提醒一下食用vector之前一定要clear。

以下是AC代码：
```
#include<bits/stdc++.h>
#define Bad_Request -1
using namespace std;

int n,k,t;
int sum;
vector<int> node[100005];

int dfs(int now,int last)
{
	int ans=1;
	for(int i=0;i<node[now].size();i++)
	{
		if(node[now][i]==last) continue;
		int a=dfs(node[now][i],now);
		if(a==Bad_Request || a>k) return Bad_Request;      //已经超过了范围，所以不可能再配对，直接返回
		else if(a==k) continue;      //如果已经满足，则不再把k的值往上加
		ans+=a;
	}
	return ans;
}

int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>k;
		for(int i=0;i<=n;i++) node[i].clear();
		for(int i=1;i<n;i++)
		{
			int a,b;
			cin>>a>>b;
			node[a].push_back(b);
			node[b].push_back(a);
		}
		int ans=dfs(1,1);
		if(ans==k) cout<<"YES\n";
		else cout<<"NO\n";
	}
	return 0;
}
```

~~还是挺简单的吧。~~

---

## 作者：xhQYm (赞：13)

- 题目链接：[P3915 树的分解](https://www.luogu.com.cn/problem/P3915)

总体来说，这题出的不错，就是数据有点水了。

这题的大致意思很清楚，就是问你树可不可以被分成 $\dfrac{N}{K}$ 个大小为 $K$ 的块。

这题的思路如下：

> 开一个 `st` 数组储存一个联通块点中点的数量，有 $K$ 个点时，我们就将计数器+1，之后吧 `st[x]` 变为 $0$ ，最后判断 `cnt` 是否等于 $\dfrac{N}{K}$ 即可。

注意：如果 $N\%K\neq 0$ 时直接输出 `NO` 即可。

还有一个细节，就是这题是多组数据，记得清空邻接表数组还有计数器。

总时间复杂度：$O(N\times T)$


上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=N*2;//两倍空间
int n,k;
int h[N],e[M],ne[M],idx,cnt;
int st[N];
void add(int a,int b){e[idx]=b,ne[idx]=h[a],h[a]=idx++;}
void dfs(int x,int s)
{
    st[x]=1;//当前只有 x 这一个点
    for(int i=h[x];~i;i=ne[i])
    {
        int j=e[i];
        if(j!=s)
        {
            dfs(j,x);
            st[x]+=st[j];
        }
    }   
    if(st[x]==k){st[x]=0;cnt++;} //如果等于 k ，直接清空并且计数器+1  
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int a,b;
        memset(h,-1,sizeof h);
        memset(st,0,sizeof st);
        idx=0;cnt=0;
        scanf("%d%d",&n,&k);
        for(int i=1;i<n;i++)
        {
            scanf("%d%d",&a,&b);
            add(a,b),add(b,a);
        }
        if(n%k!=0){puts("NO");continue;}//特判
        dfs(1,0);//从1号点出发
        if(cnt==n/k) puts("YES");
        else puts("NO");
    }
    return 0;
}

```

如果有文章错误或者还有疑问欢迎在评论区或私信提出！

---

## 作者：Cry_For_theMoon (赞：7)

&emsp;&emsp;[传送门](https://www.luogu.com.cn/problem/P3915)

&emsp;&emsp;~~被赛道修建吊打只能写树的直径部分分后痛定思痛认真学习树上贪心~~

&emsp;&emsp;树上贪心入门题

&emsp;&emsp;先提一嘴[这篇](https://www.luogu.com.cn/blog/Youngsc/solution-p3915)题解中的“那么每一个联通块都有一定是一棵子树”显然是有问题的，可能是根节点下去一条链作为一个连通块，剩下的一个子树作连通块。反例太好举了（~~也可能我理解有误）~~

&emsp;&emsp;和树形DP相同的，考虑叶子节点，此时该子树大小为1。如果 $k=1$，我们就记录一个连通块，否则我们返回 1 代表这颗子树还剩下 1 个节点。这一步正确性显然，如果 $k=1$ 时你不记录，那这个节点就没有被划分；然后推广，考虑以 $u$ 为根的子树，统计所有子树 $dfs$ 的返回值，如果最后加起来依旧小于 $k$，显然我们需要返回这个值交给上面的节点去划分；如果加起来等于 $k$，则必须划分成一个连通块，返回0（证明：如果这 $k$ 节点不属于一个连通块，必有一个节点和根节点 $u$ 不属于一个连通块，而该节点不可能在子树内凑成连通块（因为加起来才等于 $k$)，而它若是想和再上面的节点组合，必须先和 $u$ 相连，矛盾）；如果加起来大于 $k$，返回 -1，代表不可能划分（证明：$u$ 和子树某些点组合后（不可能组合后不剩下点，因为点数大于 $k$）剩下的点不可能组成新的连通块。这是因为单个子树的返回值小于 $k$，如果想在组合两颗子树意味着先得与 $u$ 组合，矛盾）。如果在查询子树的过程中有某个返回 -1，则直接返回 -1，因为这个 -1 是 全局意义而言的（也就是说出现一个-1就应该输出NO）

&emsp;&emsp;这种树上贪心练习的时候一定要去思考正确性，不然考场上虽然不用证明但是也很容易想假。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10,MAXM=2e5+10;
struct Edge{
	int u,v;
}edge[MAXM];
int first[MAXN],next[MAXM],tot;
int T,n,k,cnt;
inline void addedge(int u,int v){
	edge[++tot].u=u;edge[tot].v=v;
	next[tot]=first[u];first[u]=tot;
}
int dfs(int u,int fa){
	int sum = 1;
	for(int j=first[u];j;j=next[j]){
		int v = edge[j].v;
		if(v==fa)continue;
		int tmp = dfs(v,u);
		if(tmp==-1)return -1;
		sum += tmp;
	}
	if(sum < k)return sum;
	if(sum==k){
		cnt++;
		return 0;
	}
	return -1;
}
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);
		memset(first,0,sizeof first);memset(next,0,sizeof next);
		cnt = 0;tot = 0;
		for(int i=1,x,y;i<n;i++){
			scanf("%d%d",&x,&y);
			addedge(x,y);addedge(y,x);
		}
		if(n%k != 0){
			printf("NO\n");continue;
		} 
		dfs(1,0);
		if(cnt==n/k){
			printf("YES\n");
		}else{
			printf("NO\n");
		}
	}
	
	return 0;
}
```


---

## 作者：_acat_ (赞：7)

~~建议改为 N % K Problem~~
### 题目大意
给出 $n$ 个点的树和 $k$，问能否把树划分成 $\dfrac{n}{k}$ 个连通块，且每个连通块的点数都是 $k$。
### 思路
很显然，每个连通块一定是从下往上的恰好为 $k$ 的子树。

跑个 dfs 搜索树，节点 $u$ 的 size 更新为所有子节点 $size$ 和 $+1$，如果正好是 $k$，计数加 $1$ 并把当前 $size$ 变成 $0$（相当于删除）。

最后计数是 $\dfrac{n}{k}$，则 yes。

---

## 作者：redegg (赞：6)

很简单，其实对于任意一个节点，要使其成立，就要让它的子节点个数加上他的个数合法。

对于一个节点，如果下面的子树中已经有成功分配到k的，就不管它们了，我们只需要考虑还未被分配好的子树，将这些子树里节点的个数全部加起来，最后加上1（肯定还要包括这个节点），如果发现加完后的总数很小，小于分配数，说明还要向上面传递，需要新的节点。而如果加完后的总数大于分配数了，则是说明下面无法形成合法的分配，具体情况自己画图理解啦。至于总数等于分配数，则是分配完成，就不需要新的节点了，可以直接返回这一段子树和为0上去（不会对结果有任何影响的）。

我的代码的意思是：dfs把1号点当根节点，如果发现下面的子树有不合法情况（子树节点和大于分配数，无法形成合法分配）就直接输出NO，如果发现子树已经分配完成（子树节点和等于分配数），就不用加上子树的值，如果发现子树未分配完成（节点和小于分配数），则加上子树节点和，最后加上自己这个节点return。

最后如果发现根节点是合法的输出yes，如果不是输出no。

听不懂没关系，我也不知道我在讲什么，代码贴下面啦！
```cpp
#include <bits/stdc++.h>
using namespace std;

int t;
vector<int> q[100005];
int n,m;
int dis[100050];

int dfs(int x,int last)
{
    int ans=1;
    for(int i=0; i<q[x].size(); i++)
    {
        int nx=q[x][i];
        if(nx==last)continue;
        int k=dfs(nx,x);
        if(k==-1)return -1;
        if(k==m)continue;
        if(k>m)return -1;
        ans+=k;
    }
    return ans;
}

int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d",&n,&m);
        for(int i=1; i<=n; i++)
            q[i].clear();
        for(int i=1; i<n; i++)
        {
            int x,y;
            scanf("%d%d",&x,&y);
            q[x].push_back(y);
            q[y].push_back(x);
        }
        int ans=dfs(1,1);
        if(ans==m||ans==0)
        {
            printf("YES\n");
        }
        else
        {
            printf("NO\n");
        }
    }
    return 0;
}

```

---

## 作者：LlLlCc (赞：4)

大致分四步：

- 根据给出的边将图建好（树）
- 求出每个节点的f[i]（即以该节点为树根的子树大小）
- 当一个节点的f[i]==k时，即以该节点为树根的子树可当成一个连通块。所以f[i]=0,cnt++
- **多组数据要清零**

具体操作见代码：
```
#include<bits/stdc++.h>
#define maxn 100005
using namespace std;
int f[maxn],n,T,x,y,lnk[maxn],nxt[maxn<<1],son[maxn<<1],tot,k,cnt;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
inline void add(int x,int y){nxt[++tot]=lnk[x];lnk[x]=tot;son[tot]=y;}
inline void Dfs(int x,int fa){
	f[x]=1;
	for (int i=lnk[x];i;i=nxt[i])
	  if (son[i]!=fa){
	  	Dfs(son[i],x);
	  	f[x]+=f[son[i]];
	  }
	if (f[x]==k) f[x]=0,cnt++;
}
int main(){
	T=read();
	while (T--){
		n=read(),k=read();
		memset(lnk,0,sizeof lnk);cnt=0,tot=0;
		memset(f,0,sizeof f);
		for (int i=1;i<n;i++) x=read(),y=read(),add(x,y),add(y,x);
		if (n%k){printf("NO\n");continue;}
		Dfs(1,0);
		if (cnt==n/k) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```


---

## 作者：LoverBoyInMacau (赞：3)

## P3915 树的分解
----
### 题目描述
&ensp;&ensp;&ensp;&ensp;&ensp;给出$N$个点的树和K，问能否把树划分成$\frac{N}{K}$个连通块，且每个连通块的点数都是$K$。

### 解题思路

分析样例：

「$sample1$」
  
  ![sample1](https://cdn.luogu.com.cn/upload/image_hosting/p4vbseo0.png)  
&ensp;&ensp;&ensp;&ensp;&ensp;  可被划分为$1$.$2$、$3$.$4$两个大小为$2$的连通块。

「$sample2$」

![sample2](https://cdn.luogu.com.cn/upload/image_hosting/2yw2ta50.png)  
&ensp;&ensp;&ensp;&ensp;&ensp;  无法被划分为大小为$2$的连通块
  
    
    
  我们可以整理出以下思路：
  
&ensp;&ensp;&ensp;&ensp;&ensp;[1]&ensp;若总点数$N$无法被$K$整除，则无法被恰好分成$\frac{N}{K}$个连通块。  
&ensp;&ensp;&ensp;&ensp;&ensp;[2]&ensp;考虑统计每个子树的大小，在当前子树大小恰好为$K$时将其赋值为$0$（相当于删除）并将这个连通块计入答案中。

### 注意事项
&ensp;&ensp;&ensp;&ensp;&ensp;多组测试数据时要将变量清零。


```cpp
#include<bits/stdc++.h>
#define re register
#define il inline
#define MAXN 100005
#define rep(i,a,b)  for(re int i = a;i <= b;++ i)
#define Rep(i,a,b)  for(re int i = a;i < b;++ i)
#define drep(i,a,b) for(re int i = a;i >= b;-- i)
#define Drep(i,a,b) for(re int i = a;i > b;-- i)
#define star(i,x)   for(re int i = head[x];i;i = e[i].nxt)
#define fin(a)  freopen(#a".in","r",stdin)
#define fout(a) freopen(#a".out","w",stdout)

using namespace std;

il int read(){
	int x = 0;
	char ch = 0;
	while(!isdigit(ch))
		ch = getchar();
	while(isdigit(ch)){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

il void write(int x){
	if(x > 9)
		write(x / 10);
	write(x % 10 + '0');
}

struct edge{
	int nxt,to;
}e[MAXN << 1];

int head[MAXN << 1],cnt = 0,ans = 0;
int t,n,k;
int siz[MAXN];

il void add(int u,int v){
	e[++ cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

il void dfs(int x,int fa){
	siz[x] = 1;
	
	star(i,x){
		int v = e[i].to;
		if(v != fa){
			dfs(v,x);
			siz[x] += siz[v];
		}
	}
	
	if(siz[x] == k){
		siz[x] = 0;
		ans ++;
	}
}



int main(){
    #ifndef ONLINE_JUDGE
    fin(3915);
    fout(3915);
    #endif

	t = read();
	
	while(t --){
		n = read(),k = read();
		
		ans = 0,cnt = 0;
		memset(head,0,sizeof(head));
		memset(siz,0,sizeof(siz));
		memset(e,0,sizeof(e));
		
		Rep(i,1,n){
			int u = read(),v = read();
			add(u,v);
			add(v,u);
		}
		
		if(n % k != 0){
			printf("NO\n");
			continue;
		}
		
		dfs(1,0);
			
		if(ans == n / k)
			printf("YES\n");
		else
			printf("NO\n");
	}
	
	return 0;
}
```


---

## 作者：SmallTownKid (赞：2)

好题。考察了子树的性质。如果有一个满足的联通块，那么这个联通块一定是某一个点的子树（易证）。而我们在dfs求每个点子树大小时，恰好可以把每个点**在某个时刻**的子树大小求出来。如果有一个满足条件的联通块出现了，那我们可以立即切断这个点和它的子树作为一个联通块。最后判断就可以了。注意特判 $n$ $mod$ $k$ 是否等于0时要放到建图的后面！！！ 

```
//统计子树大小的内部实现顺序要清楚 
#include<bits/stdc++.h>
using namespace std;
int T,idx,n,k,ans;
int head[100010],size[100010];
struct node{
	int nxt,to;
}edge[200010];
void add(int u,int v)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
void dfs(int now,int fath)
{
	size[now]=1;
	for(int i=head[now];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fath)
		continue;
		dfs(v,now);
		size[now]+=size[v];
	}
	if(size[now]==k)
	{
		size[now]=0;
		ans++;
	}
}
int main()
{
	cin>>T;
	while(T--)
	{
		idx=0,ans=0;
		cin>>n>>k;
		memset(size,0,sizeof(size));
		memset(head,0,sizeof(head));
		for(int i=1;i<=n-1;i++)
	    {
		    int u,v;
		    cin>>u>>v;
		    add(u,v);
		    add(v,u);
        }
        if(n%k!=0)//先判断能不能整除
	    {
	    	cout<<"NO"<<endl;
	    	continue;
		}
		dfs(1,0); 
        if(ans==n/k)
        cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
	}
	return 0;
}

---

## 作者：Linyize257 (赞：2)

 ### [传送](https://www.luogu.com.cn/problem/P3915)
 题目就是说我们要把一个树给砍了，砍成 $n/k$ 棵子树，每个子树有 $k$ 个点，能办到就输出 YES ，否则 NO 。

我个人认为，标签所说的贪心就是指我们从叶子开始，计算每个子树的点数，不可以漏过每个叶子。那么我们就从叶子开始，通过回溯求子树点数，如果，  `sum[x]==k` 那么成功数加一，最后在判断下成功数是否等于 $n/k$ ，就好了。

要注意在 `sum[x]==k` 后，要把 $sum_x$ 归 0 ，因为已经成了一个分的块了，所以他的 father 看到自己为 0 。 

## $code$:
```cpp
#include<iostream>
#include<cstring>
#define int long long
using namespace std;

int t,n,k;
int head[200005],to[200005],ne[200005],id;
void add(int x,int y){
	to[++id]=y,ne[id]=head[x],head[x]=id;
}

int sum[200005],ans;
void dfs(int x,int fa){
	sum[x]=1;//自己就有一个点，++! 
	for(int i=head[x];i;i=ne[i]){
		if(fa==to[i])continue;
		dfs(to[i],x);//遍历儿子，自己等着儿子的子树大小，回溯 
		sum[x]+=sum[to[i]];//加上儿子大小 
	}
	if(sum[x]==k){ 
		ans++;
		sum[x]=0;
	} 
}

signed main(){
	cin>>t;
	while(t--){
		memset(head,0,sizeof head);//重置 
		memset(ne,0,sizeof ne);
		ans=0;
		id=0;
		cin>>n>>k;
		for(int i=1;i<n;i++){//建边 
			int x,y;
			cin>>x>>y;
			add(x,y);
			add(y,x);
		}
		dfs(1,0);//开始从一个点开始，遍历 
		if(ans==n/k){//判断 
			cout<<"YES\n";
		}else cout<<"NO\n";
	}
}
```

---

## 作者：alvis (赞：2)

## 题意
给一棵 $n$ 个点的树，试将其分成 $\dfrac{n}{k}$ 个不重不漏的 $k$ 个点的连通块，问是否可能做到。

## 解决
显而易见的模拟。

直接递归寻找每一棵子树并计算子树大小 $siz_i$，然后判断当前节点 $u$ 作为根的子树的大小 $siz_u$ 是否为 $k$。

如果 $siz_u = k$，那直接将 $siz_u$ 变为 $0$ 即可。

然后再接下来的递归计算中，以 $u$ 的祖先为根的子树大小就不会将 $siz_u$ 计入其中。

总的时间复杂度为 $\operatorname{O(nT)}$。

然后好像没有什么特别需要注意的了~~可以愉快的上代码了~~。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6+1010;
int T, n, k, idx, cnt;
int h[N<<1], siz[N<<1];

struct node {
    int e, ne;
}g[N<<2];

//建图
void add(int a, int b) {
    g[idx].e = b;
    g[idx].ne = h[a];
    h[a] = idx ++;
}

//递归寻找每一棵子树
void dfs(int u, int f) {
	siz[u] = 1;
    for(int i = h[u];i != -1;i = g[i].ne) {
    	int j = g[i].e;
    	if(j == f) continue;
    	dfs(j, u);
    	siz[u] += siz[j];
	}
	if(siz[u] == k) cnt ++, siz[u] = 0;
}

int main() {
    cin >> T;
    while(T --) {
    	//清空上一组数据
        memset(h, -1, sizeof h);
        memset(g, 0, sizeof g);
        memset(siz, 0, sizeof siz);
        cnt = 0;
        cin >> n >> k;
        
        for(int i = 1, a, b;i < n;i ++) {
        	cin >> a >> b;
        	add(a, b);add(b, a);
		}
        //这里是个小坑点-->如果这一句放前面，会导致输入错误
		if(n % k != 0) {
            cout << "NO" << endl;
            continue;
        }
        //点1的父亲节点随便设一个负数也可以。【在值域外即可】
        dfs(1, -1);
        if(cnt == n/k) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    
    return 0;
}
```


---


# 最接近神的人

## 题目描述

破解了符文之语，小 FF 开启了通往地下的道路。当他走到最底层时，发现正前方有一扇巨石门，门上雕刻着一幅古代人进行某种活动的图案。而石门上方用古代文写着“神的殿堂”。小 FF 猜想里面应该就有王室的遗产了。但现在的问题是如何打开这扇门……。

仔细研究后，他发现门上的图案大概是说：古代人认为只有智者才是最容易接近神明的。而最聪明的人往往通过一种仪式选拔出来。仪式大概是指，即将隐退的智者为他的候选人写下一串无序的数字，并让他们进行一种操作，即交换序列中相邻的两个元素。而用最少的交换次数使原序列变成不下降序列的人即是下一任智者。

小 FF 发现门上同样有着 $n$ 个数字。于是他认为打开这扇门的秘诀就是找到让这个序列变成不下降序列所需要的最小次数。但小 FF 不会……只好又找到了你，并答应事成之后与你三七分……

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据 $1≤n≤10^4$。
- 对于 $100\%$ 的数据 $1≤n≤5\times 10^5$，$A_i\in [-2^{31}, 2^{31})$。

### 样例解释

开始序列为 $[2,8,0,3]$，目标序列为 $[0, 2, 3, 8]$，可进行三次操作的目标序列：

1. 交换 $(8,0)$，序列变成 $[2,0,8,3]$；
2. 交换 $(2,0)$，序列变成 $[0,2,8,3]$；
3. 交换 $(8,3)$，序列变成 $[0,2,3,8]$。


## 样例 #1

### 输入

```
4
2 8 0 3
```

### 输出

```
3```

# 题解

## 作者：李若谷 (赞：80)

# 为什么是逆序对

逆序对的做法已经有很篇题解讲的很好了。但是很少题解有讲为什么相邻交换的次数就是逆序对。这篇题解只是为了证明这个。


------------
首先，显然排好序的序列逆序对数一定是 0。

对于i, 和i+1, 显然如果a[i] <= a[i+1] 那么交换这两个数是多余的。因为不管后面怎么交换，最终a[i]一定在a[i+1]前面，如果交换这两个，就会增加a[i]到a[i+1]的前面的交换次数。

对于i,和j, 设i<j且a[i] > a[j], 那么最终a[j]会交换到a[i]前面, 因为只能两两相邻交换，a[i]和a[j]肯定也会交换，否则a[j]无法到a[i]前面, 因为a[j]不可能跳过a[i]。

交换两个相邻的数逆序对数会 -1。显然若a[i] > a[i+1] 交换是它们会减少1个逆序对，由于a[i]和a[i+1]中间没有数，所以不会影响其他逆序对。导致逆序对数会减少1。

既然，任意两个逆序对都要交换，并且每次交换后逆序对数都会减少1，最终的逆序对数是0，那么肯定要交换的个数就是全部逆序对的个数。




---

## 作者：s_ShotღMaki (赞：38)

# 这是一道双倍经验题

**刚刚在做[P1908逆序对](https://www.luogu.org/problemnew/show/P1908)练习树状数组的熟练度罢了**

**~~手贱点开了相关题目~~发现了一道名字显眼的题目就是他了[P1774最接近神的男人](https://www.luogu.org/problemnew/solution/P1774)，这......蒟蒻实在看不出来有什么区别，其实也就是求逆序对的数量，甚至连数据规模都一样，果断复制自己在那里的提交结果AC**

## 进入正题，思路

1关于树状数组的基础大家应该有

2这是关于树状数组求逆序对的例题

3因为数据规模，所以我们需要对其进行离散化，新创一个数组a里面来放在我们的初始序列中**在这个位置上的数是第几大的**这里还要用一个小技巧排序，关于离散化的技巧我们具体在代码里面看

4离散化之后我们只对a数组进行操作就好了，每次遇到一个数就把他插到树状数组里面去
```cpp
inline void go_and_do_it (int x)
{
	for (int i = x; i <= n; i += lb (i))
	tree[i] ++;
}
```


5每次查逆序对就跟树状数组的例题一样用find查询就好了
```cpp
inline int find (int x)
{
	int sum = 0;
	for (int i = x; i > 0; i -= lb (i))
	sum += tree[i];
	return sum;
}
```

## 完整代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>

#define WA AC
#define RE AC
#define CE AC
#define TLE AC
#define MLE AC

using namespace std;

inline int read ()
{
    int f = 1, x = 0;
    char ch;
    do {ch = getchar (); if (ch== '-') f = -1;} while (ch < '0' || ch > '9');
    do {x = x * 10 + ch - '0'; ch = getchar ();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int N = 5 * (1e5 + 7);
typedef long long ll;

ll n;
ll a[N];
ll xv[N];
ll tree[N];
ll ans;

inline bool cmp (int a, int b)//这里的cmp我们需要判重，然后按照原本的顺序排列，要不sort会出玄学乱排 
{
	return xv[a] == xv[b] ? a > b : xv[a] > xv[b];
}

inline int lb (int x)//lowbit 
{
	return x & -x;
}

inline void go_and_do_it (int x)//单点修改 ，每次加1 
{
	for (int i = x; i <= n; i += lb (i))
	tree[i] ++;
}

inline int find (int x)//查询 
{
	int sum = 0;
	for (int i = x; i > 0; i -= lb (i))
	sum += tree[i];
	return sum;
}

int main ()
{
	n = read ();
	for (int i = 1; i <= n; i ++)
	{
		xv[i] = read ();
		a[i] = i;//对其进行初始化先化成自己在进行排序 
	}
	sort (a + 1 , a + 1 + n, cmp);//对其进行排序 
	for (int i = 1 ; i <= n; i ++)
	{
		go_and_do_it (a[i]);//把数插到树状数组里面 
		ans += find (a[i] - 1);// 每次查询把前缀和加到ans里面 
	}
	printf ("%lld", ans);
    return 0;
}
```
对变量解释一下

```cpp
ll n; // 题目里的n 
ll a[N]; //离散化后的序列 
ll xv[N]; //原本的序列 
ll tree[N]; //树状数组 
ll ans; //答案，所有逆序对 
```
有没有对树状数组有了更深的理解

---

## 作者：微雨燕双飞 (赞：25)

额，楼下说的非递归版归并蒟蒻我实在不会，但是我并不是很同意他说的“非递归版的更快”这一说法，实测我的递归版归并跑了688ms（没加快读），所以效率是差不多的，代码量也差不多，但是递归版的应该更好理解一些吧。（至少我是这么认为的，就像快排也有非递归版的写法，但有人去用吗？原因就是1.不太好理解 2.通用性不强）当然，多掌握一种方法不无裨益。

好，下面献上蒟蒻的渣渣程序，供大家参考：

1.归并排序版
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
int n,a[maxn],r[maxn];
long long ans=0;
void mergesort(int s,int t)
{
  int i,j,k,m;
  if(s==t) return;
  m=(s+t)/2; //取中点
  mergesort(s,m); //递归左区间
  mergesort(m+1,t); //递归右区间
  i=s,j=m+1,k=s;
  while(i<=m&&j<=t) //二路归并（升序）过程
  {
    if(a[i]<=a[j])
    {
      r[k]=a[i]; i++; k++;
    }
    else
    {
      r[k]=a[j]; j++; k++;
      ans+=m-i+1;
    }
  } //将序列中剩余的元素接入r数组
  while(i<=m) { r[k]=a[i]; i++; k++; }
  while(j<=t) { r[k]=a[j]; j++; k++; }
  for(int i=s; i<=t; i++) a[i]=r[i]; //数组赋回
}
int main()
{
  scanf("%d",&n);
  for(int i=1; i<=n; i++) scanf("%d",&a[i]);
  mergesort(1,n); //归并求解逆序对
  printf("%lld\n",ans); //别忘了long long
  return 0;
}
```
2.树状数组版：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e5+10;
int n,a[maxn],p[maxn],tree[maxn]; //tree为树状数组
long long ans=0;
bool cmp(int x,int y) //离散化快排
{
  return a[x]<a[y];
}
int lowbit(int x)
{
  return x&(-x);
}
void update(int x,int d)
{
  while(x<=n)
  {
    tree[x]+=d;
    x+=lowbit(x);
  }
}
long long query(int x)
{
  long long ret=0;
  while(x>0)
  {
    ret+=tree[x];
    x-=lowbit(x);
  }
  return ret;
}
int main()
{ //本题数据量过大，需要离散化处理
  scanf("%d",&n);
  for(int i=1; i<=n; i++) 
  {
    scanf("%d",&a[i]);
    p[i]=i; //p记录节点编号
  } //很多人20分就是因为这里，尽量用stable_sort，不改变原序列中的元素位置（当两元素相等时）
  stable_sort(p+1,p+n+1,cmp);
  for(int i=1; i<=n; i++) a[p[i]]=i; //离散化
  for(int i=n; i>=1; i--) //倒序循环
  {
    ans+=query(a[i]-1); //查询比自己小且在自己后面的数有几个
    update(a[i],1); //值为a[i]的数的个数+1
  }
  printf("%lld\n",ans); //同样，别往long long
  return 0;
}
```
两种方法相比，经过实测，归并排序688ms，树状数组1164ms，归并快了将近一倍，代码也更短小精悍一些。（更可怕的是，归并排序是noip范围之内的，所以非常有必要掌握好），至于BIT，个人认为更通用一些，也好理解一些。

---

## 作者：asd_a (赞：14)

楼下大佬都用的是树状数组和归并，我就讲一讲线段树吧！  
这道题，楼下大佬们都讲了其实就是求逆序对。而逆序对就是求每一个数前面有多少个比它大，则考虑权值线段树。  
什么是权值线段树？ 就是以数的大小作区间的线段树。  
然而，此题数据范围太大，所以需要一个小小的预处理操作：  
例：2 8 0 3 2，我们可以排个序（要保留原版）：0 2 2 3 8  
去重：0 2 3 8，编号为：1，2，3，4。再对应回去：2 4 1 3 2  
(要开个结构体，记录原位置）  
一系列~~骚~~操作得： 1<=A[i]<=n  
好了，现在可以构造了。（值都为0）  

---
查询逆序对，先从前向后依次查询，记录总和，查询后加入线段树并回溯

献上丑陋的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
inline int rd()
{
	int x=0,flag=1;
	char ch=getchar();
	while((ch<'0' || ch>'9') && ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*flag;
}
inline LL rdl()
{
	LL x=0,flag=1;
	char ch=getchar();
	while((ch<'0' || ch>'9') && ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*flag;
}//读入优化
const int N=5e5+50;
const int TR=N<<2;
struct tree{
	int l,r,k;
}t[TR];
inline int ls(int x)//左儿子
{
	return x<<1;
}
inline int rs(int x)//右儿子
{
	return x<<1|1;
}
struct no{
	int x,i;
}cop[N];
bool comp(no x,no y)
{
	return x.x<y.x;
}
inline void build(int now,int l,int r)//建树
{
	t[now].l=l;
	t[now].r=r;
	t[now].k=0;
	if(l==r)
		return ;
	int mid=(l+r)>>1;
	build(ls(now),l,mid);
	build(rs(now),mid+1,r);
	return ;
}
inline void up(int now)//回溯
{
	t[now].k=t[rs(now)].k+t[ls(now)].k;
}
inline LL src(int now,int x)//搜索
{
	int l=t[now].l,r=t[now].r;
	LL sum=0;
	int mid=(l+r)>>1;
	if(l==r)
		return (LL)t[now].k;
	if(x<=mid) sum+=(LL)t[rs(now)].k+src(ls(now),x);//若在左儿子中，右儿子一定比它大
	else sum+=src(rs(now),x);//搜索右儿子
	return sum;
}
inline void upate(int now,int x)//加入
{
	int l=t[now].l,r=t[now].r;
	int mid=(l+r)>>1;
	if(l==r)
	{
		t[now].k++;//统计个数
		return ;
	}
	if(x<=mid) upate(ls(now),x);
	else upate(rs(now),x);
	up(now);
}
int n;
LL a[N],k[N],tot=0,ans=0;
int main()
{
	n=rd();
	for(int i=1;i<=n;i++) a[i]=rdl(),cop[i].x=a[i],cop[i].i=i;
	sort(cop+1,cop+n+1,comp);
	for(int i=1;i<=n;i++)
	{
		if(cop[i].x!=cop[i-1].x || i==1)
			k[++tot]=cop[i].x;
		a[cop[i].i]=tot;
	}//预处理
	build(1,1,n);
	for(int i=1;i<=n;i++)
	{
		ans+=src(1,a[i]+1);//大于a的个数=大于等于a+1的个数
		upate(1,a[i]);//更新
	}
	cout<<ans<<endl;
	return 0;
}
```
[广告（advertisement）](https://www.luogu.org/blog/STC-hjh/)

---

## 作者：henrytb (赞：4)

看了一眼题面...

裸的逆序对...

归并...

注意开`long long`就可以了...

附代码：

```cpp
//直接复制不能过哦
#include <cstdio>
#include <cstdlib>
#include <iostream>
#define Mid ((L+R)/2)
using namespace std;
const int N=1000005;
long long A[N],B[N],count=0,n;
void work(int L,int R){
    if(L==R)return;
  　work(L,Mid);
  　work(Mid+1,R);
    int tl=L,tr=Mid+1,t=L;
    while(tl<=Mid&&tr<=R){
        if(A[tl]<=A[tr])B[t++]=A[tl++];
      　else B[t++]=A[tr++],count+=tr-t;
    }
    while(tl<=Mid) B[t++]=A[tl++];
    while(tr<=R) B[t++]=A[tr++];
  　for(int i=L;i<=R;i++)A[i]=B[i];
}
int main(){
    scanf("%lld",&n);　
  　for(int i=1;i<=n;i++)scanf("%lld",&A[i]);
    work(1,n);
    printf("%lld",count);
    return 0;
}
//优秀的归并
```

---

## 作者：JiayanJohnnyChu (赞：4)

# 题目描述
见[p1774](https://www.luogu.org/problemnew/solution/P1774?&page=2)
# 算法描述
本题要求求交换次数，因为最优方案每交换一次必定消去且仅消去一个逆序对，所以交换次数等于逆序对数，故本题其实就是求逆序对数。
## 方法一
冒泡排序求交换次数	
时间复杂度
```latex
O(n^2)
```
这个没什么好说的，TLE
### 此方法主要代码
```cpp
for (int i = 0; i < n; i++)
    for (int j = i; j < n; j++)
    {
        if (a[i]>a[j])
        {
            b = a[j];
            a[j] = a[i];
            a[i] = b;
            t++;
        }
    }
```
## 方法二
归并排序	
时间复杂度
```latex
O(n log n)
```
此方法为正解之一，在一般的归并排序的基础上在归并时发现逆序对时执行
```cpp
ans += mid - p + 1;
``` 
即可求出逆序对数。	
此方法在不用O2优化下可达到536ms。
### 此方法主要代码
```cpp
void merge_sort(int s,int t)
{
    register int j, mid, p, q;
    if (s==t)
    {
        return;
    }//只有一个数字，无需排序
    mid = (s + t) >> 1;
    merge_sort(s, mid);
    merge_sort(mid + 1, t);
    p = s;
    q = mid + 1;
    j = s;
    while ((p<=mid)&&(q<=t))
    {
        if (a[p]>a[q])
        {
            c[j] = a[q];
            ++q;
            ++j;
            ans += mid - p + 1;
        }
        else
        {
            c[j] = a[p];
            ++p;
            ++j;
        }
    }
    --j;
    if (p<=mid)
    {
        for (int i = p; i <= mid; ++i)
        {
            ++j;
            c[j] = a[i];
        }
    }
    else
    {
        for (int i = q; i <= t; ++i)
        {
            ++j;
            c[i] = a[i];
        }
    }//将剩余的元素赋入c
    for (int i = s; i <= t; ++i)
    {
        a[i] = c[i];
    }//将数组赋回
    return;
}
```
## 方法三
树状数组	
时间复杂度
```latex
O(nlogn)
```
此方法为正解之一，由于此方法要求较高，在此不再加以描述。
# 代码
```cpp
#include<bits\stdc++.h>
using namespace std;

int a[500005], c[500005];
long long ans;

int Read()
{
	int Digital = 0, Symbol = 1;
	char gc = getchar();
	while (gc<'0' || gc>'9') 
	{ 
		if (gc == '-')Symbol = -Symbol;
		gc = getchar(); 
	}
	while (gc >= '0'&&gc <= '9')
	{
		Digital = Digital * 10 + gc - '0';
		gc = getchar();
	}
	return Digital * Symbol;
}

void merge_sort(int s,int t)
{
	register int j, mid, p, q;
	if (s==t)
	{
		return;
	}
	mid = (s + t) >> 1;
	merge_sort(s, mid);
	merge_sort(mid + 1, t);
	p = s;
	q = mid + 1;
	j = s;
	while ((p<=mid)&&(q<=t))
	{
		if (a[p]>a[q])
		{
			c[j] = a[q];
			++q;
			++j;
			ans += mid - p + 1;
		}
		else
		{
			c[j] = a[p];
			++p;
			++j;
		}
	}
	--j;
	if (p<=mid)
	{
		for (int i = p; i <= mid; ++i)
		{
			++j;
			c[j] = a[i];
		}
	}
	else
	{
		for (int i = q; i <= t; ++i)
		{
			++j;
			c[i] = a[i];
		}
	}
	for (int i = s; i <= t; ++i)
	{
		a[i] = c[i];
	}
	return;
}

int main()
{
	int n;
	n = Read();
	ans = 0;
	for (int i = 1; i <= n; ++i)
		a[i] = Read();
	merge_sort(1, n);
	printf("%lld", ans);
	return 0;
}

```

---

## 作者：Hiraeth (赞：2)

归并排序求逆序对

详细解释在代码注释里面

本题主要注意的是$ans$要开$longlong$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[600000],b[600000];
long long ans;
void merge_sort(int l,int r){
	if (l==r) return;
	int mid=(l+r)/2;
	//往下递归 
	merge_sort(l,mid);
	merge_sort(mid+1,r);
	//排序
	int i=l,j=mid+1,k=l;//操作更新的是l->r的区间 初值赋在l和r 
	while (i<=mid&&j<=r){//在底层递归结束之后 前后两个部分都应该是有序的 
		if (a[i]<=a[j]) {
			b[k]=a[i];//把较小的数据放入辅助数组 
			i++;
			k++; 
		}
		else {
			b[k]=a[j];
			ans+=mid-i+1;//前一半是有序的那么这个后面的都是逆序对 
			j++;
			k++;
		}
	}
	//剩余元素加入数组
	while(i<=mid) {
		b[k]=a[i];
		k++;
		i++;
	}  
	while (j<=r){
		b[k]=a[j];
		k++;
		j++;
	}
	for (int p=l;p<=r;p++) a[p]=b[p]; 
}
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	merge_sort(1,n);
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：hongzy (赞：2)

可以看出是树状数组求逆序对

直接按数值从小到大排序，排序时若相同数值的，位置小的保持在前面，这样避免不必要的交换.编写这样一个compare函数就避免了各种我这样的juruo不知道的奇怪技巧（stable_sort，奇怪的离散化等）.

剩下就是和 P1908逆序对 一样的求逆序对了

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int n;
long long ans;

struct P {
	int y;
	long long x;
	bool operator <(const P p2) const {
		return x == p2.x ? y < p2.y : x < p2.x;
	}
} p[500001];

int c[500001];

void update(int k, int x) {
	for(; k<=n; k += k&-k) c[k] += x;
}

long long query(int k) {
	long long ans = 0;
	for(; k; k -= k&-k) ans += c[k];
	return ans;
}


int main() {
	scanf("%d", &n);
	for(int i=1; i<=n; ++ i)
		scanf("%lld", &p[p[i].y = i].x);
	sort(p+1, p+n+1);
	for(int i=n; i; i--) {
		ans += query(p[i].y - 1);
		update(p[i].y, 1);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：微香玉烛暗 (赞：2)

这道题并不难，主要运用了分治的思想。

把一个大问题分解出许多小问题，直到小问题的解能够直接求出。**再把这些小问题重新合并**成原来的大问题。**合并**是关键！！！

分治，主要是以**递推**的形式呈现，但中心思想是较为完整的。树状数组和归并对于我这种蒟蒻还是太深奥了，所以来一波分治！

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=500010;
int a[N],b[N];//顶常量是个好习惯
long long s;//不开long long会爆

//分治！！！
void acd(int t,int w){//（我太弱了，不会定l和r，只会t和w（头和尾）
    if(t==w) return;//如果t=w，返回
    int m=(t+w)/2;//定中点
    acd(t,m);//分解小问题
    acd(m+1,w);//分治思路
    int j=m+1,l=t,x=t,y=w;
    //重要的：合并
    while(t<=m&&j<=w){
        if(a[t]<=a[j]){
            b[l++]=a[t++];
        }
        else {
            b[l++]=a[j++];
            s+=m-t+1;
        }
    }
    //合并大体结束
    while(t<=m) b[l++]=a[t++];//头没有扫干净要扫掉
    while(j<=w) b[l++]=a[j++];//尾也一样
    //合并彻底结束
    for(;x<=y;x++){
        a[x]=b[x];//记住！这一段a数组要被b数组覆盖
    }
}

int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    acd(0,n-1);//从0到n-1的大问题
    cout<<s;
    return 0;
}
```
希望能帮助大家。
**谢谢**！

---

## 作者：magolor (赞：2)

看到题解中并没有C++树状数组解法，所以加一个，注意，不要去重！




    
    
    


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 500000
#define ll long long
ll n,a[MAXN+5],num[MAXN+5],ans = 0;
inline ll lowbit(ll k)
{
    return (k&(-k));
}
bool cmp(ll a1, ll a2)
{
    return a[a1] < a[a2];
}
struct Index_Tree
{
    ll c[MAXN+5];
    void Init()
    {
        memset(c,0,sizeof(c));
        return;
    }
    void Add(ll i, ll j)
    {
        for(; i <= n; i+=lowbit(i))
            c[i] += j;
        return;
    }    
    ll Sum(ll i)
    {
        ll ans = 0;
        for(; i; i-=lowbit(i))
            ans += c[i];
        return ans;
    }
};
Index_Tree T;
int main()
{
    T.Init();
    scanf("%lld",&n);
    for(ll i = 0; i < n; i++)
        scanf("%lld",a+i),num[i] = i;
    //n = unique(a,a+n)-a;
    stable_sort(num,num+n,cmp);
    for(ll i = 0; i < n; i++)
        a[num[i]] = i;
    for(ll i = 0; i < n; i++)
        ans += T.Sum(n-a[i]), T.Add(n-a[i],1);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Nero_Claudius (赞：1)

这道题很明显是求逆序对。

所谓逆序对，就是**逆序**的数对。

譬如在下面这个数列中：

> 1 2 3 4 6 5

6 5就是一个逆序对。

------------

求逆序对的方法比较多，常见的有归并排序和树状数组（线段树当然也行）。

本题采用平衡树（leafy tree）解决。（之所以写这个才不是因为我懒呢！）

对于数列中的每一项，插入，然后查询它的rank。

累加即为答案。

写的时候因为直接黏贴模板被坑了好几次（尴尬至极），大概告诉我两件事：

1. 这题得开long long

2. 不注释文件输入可能不是RE而是TLE

速度很慢，效率很低，2212ms。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const long long N=500500;
namespace LeafyTree{
    const long long alpha=4;
    long long n,cnt,father,root;
    long long val[N<<2],size[N<<2],ls[N<<2],rs[N<<2];
    inline void newNode(long long &pos,long long v){
        pos=++cnt,size[pos]=1,val[pos]=v;
    }
    inline void copyNode(long long x,long long y){
        size[x]=size[y],ls[x]=ls[y],rs[x]=rs[y],val[x]=val[y];
    }
    void merge(long long l,long long r){
        size[++cnt]=size[l]+size[r],val[cnt]=val[r],ls[cnt]=l,rs[cnt]=r;
    }
    void rotate(long long pos,bool flag){
        if(flag){
            merge(ls[pos],ls[rs[pos]]);
            ls[pos]=cnt,rs[pos]=rs[rs[pos]];
        }else{
            merge(rs[ls[pos]],rs[pos]);
            rs[pos]=cnt,ls[pos]=ls[ls[pos]];
        }
    }
    void maintain(long long pos){
        if(size[ls[pos]]>size[rs[pos]]*alpha)rotate(pos,0);
        else if(size[rs[pos]]>size[ls[pos]]*alpha)rotate(pos,1);
        if(size[ls[pos]]>size[rs[pos]]*alpha)rotate(ls[pos],1),rotate(pos,0);
        else if(size[rs[pos]]>size[ls[pos]]*alpha)rotate(rs[pos],0),rotate(pos,1);
    }
    void pushup(long long pos){
        if(!size[ls[pos]])return;
        size[pos]=size[ls[pos]]+size[rs[pos]];
        val[pos]=val[rs[pos]];
    }
    void insert(long long pos,long long v){
        if(size[pos]==1){
            newNode(ls[pos],min(v,val[pos]));
            newNode(rs[pos],max(v,val[pos]));
            pushup(pos);
            return;
        }
        if(v>val[ls[pos]])insert(rs[pos],v);
        else insert(ls[pos],v);
        pushup(pos);
        maintain(pos);
    }
    void erase(long long pos,long long v){
        if(size[pos]==1){
            if(ls[father]==pos)copyNode(father,rs[father]);
            else copyNode(father,ls[father]);
            return;
        }
        father=pos;
        if(v>val[ls[pos]])erase(rs[pos],v);
        else erase(ls[pos],v);
        pushup(pos);
        maintain(pos);
    }
    long long kth(long long pos,long long v){
        if(size[pos]==v)return val[pos];
        if(v>size[ls[pos]])return kth(rs[pos],v-size[ls[pos]]);
        return kth(ls[pos],v);
    }
    long long rank(long long pos,long long v){
        if(size[pos]==1)return 1;
        if(v>val[ls[pos]])return rank(rs[pos],v)+size[ls[pos]];
        return rank(ls[pos],v);
    }
}
using namespace LeafyTree;
namespace Solve{
	template<typename T>inline void read(T &x){
		x=0;T f=1;char c=getchar();
		for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
		x*=f;
	}
	template<typename T>inline void write(T x){
		if(x>=10)write(x/10);
		putchar(x%10+'0');
	}
	const long long INF=9223372036854775807;
	long long n,ans;
	long long a[N];
	inline void solve(){
		read(n);
    	newNode(root,INF);
		for(register long long i=1;i<=n;++i){
			read(a[i]),insert(root,a[i]);
			ans+=i-rank(root,a[i]+1)+1;
		}
		write(ans);
	}
}
using namespace Solve;
int main(){
//	freopen("testdata.in","r",stdin);
	solve();
}
```

---

## 作者：vegetabird (赞：1)

看了一圈，写归并排序的全是递归。。。

那我就写个不用递归的归并排序

不用递归真的会快一点！

673ms，笔者的程序在写这篇题解时是最快的！唯一一个<700ms的！

归并排序其实是对~~许多~~一些长度大于1的区间进行操作

运用树的知识可知，对于一个长度为n的数列需要操作n-1次

所以我们就按处理先后的顺序把区间存在两个数组left,right里

实质是把dfs变成了bfs

然后就不用递归啦

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#include<set>
inline void getint(int &_int){
    char ch=0;
    bool neg=false;
    while(!isdigit(ch)&&ch!='-')ch=getchar();
    if(ch=='-'){
        neg=true;
        ch=getchar();
    }
    while(isdigit(ch)){
        _int=_int*10+ch-48;
        ch=getchar();
    }
    if(neg)_int=-_int;
}
int n;
int a[500010];
int left[500010],right[500010],mid[500010];
int tmp[500010];
long long cnt;
int main(){
    register int i,j,k,l;                        rigister是个好东西
    getint(n);
    for(i=1;i<=n;i++){
        getint(a[i]);
    }
    left[1]=1,right[1]=n;
    mid[1]=(1+n)/2;
    k=1;
    for(i=1;i<n;i++){
        if(left[i]+1<right[i]){
            k++;
            left[k]=left[i];
            right[k]=mid[i];
            mid[k]=(left[k]+right[k])/2;
        }
        if(left[i]+2<right[i]){
            k++;
            left[k]=mid[i]+1;
            right[k]=right[i];
            mid[k]=(left[k]+right[k])/2;
        }
    }
    for(l=n-1;l>=1;l--){                    Mergesort
        const int s1=left[l],t1=mid[l],s2=mid[l]+1,t2=right[l];
        i=k=s1,j=s2;
        while(i<=t1&&j<=t2){
            if(a[i]<=a[j]){
                tmp[k++]=a[i++];
            }else{
                tmp[k++]=a[j++];
                cnt+=s2-i;
            }
        }
        while(i<=t1)tmp[k++]=a[i++];
        while(j<=t2)tmp[k++]=a[j++];
        for(k=s1;k<=t2;k++){
            a[k]=tmp[k];
        }
    }
    std::cout<<cnt<<'\n';
}
```

---

## 作者：skylee (赞：1)

基本思路：求逆序对；

方法1：插入排序思想，时间复杂度O(n^2)，会超时，不适用。

方法2：归并排序思想，本题解采用这种思想，优点在于时间复杂度低，且易于理解。

方法3：树状数组思想，时间复杂度低，但是对于普及组平均水平来说难以掌握。

实现细节：不断地归并排序，交换的次数可转换为逆序对的数量。

注意：每次排序不要复制整个数组，否则会产生大量的时间开销。最优的做法是将排好序的数据保存在一个临时数组t里，排完序复制到主数组a中。临时数组t也不要每一个过程就开一次，可以开在主程序中，这样可以节省大量的内存开销

代码：

'''pascal

```cpp
var
    n,i:longint;
    ans:qword;
    a,t:array[1..500000]of longint;
procedure deal(l,r:longint);
    var
        mid,p,q,i:longint;
    begin
        if l=r then begin
            exit()
        end;
        mid:=(l+r)>>1;
        deal(l,mid);
        deal(mid+1,r);
        p:=l;
        q:=mid+1;
        i:=l;
        repeat
            if (a[p]<=a[q]) and (p<=mid) or (q>r) then begin
                t[i]:=a[p];
                inc(p)
            end
            else begin
                t[i]:=a[q];
                inc(q);
                ans+=mid-p+1
            end;
            inc(i)
        until (i>r);
        for i:=l to r do begin
            a[i]:=t[i]
        end;
    end;
begin
    readln(n);
    for i:=1 to n do begin
        read(a[i])
    end;
    readln;
    ans:=0;
    deal(1,n);
    writeln(ans)
end.
'''
```

---

## 作者：sxyzhml (赞：1)

```delphi

 procedure  change(p,i:longint);  
begin  
  while p<=n do  
   begin  
     tree[p]:=tree[p]+i;  
     p:=p+(p and-p);  
   end;  
end;  
  
function getsum(k:longint):longint;  
begin  
  getsum:=0;  
  while k>0 do  
     begin  
       getsum:=getsum+tree[k];  
       k:=k-k and -k;  
     end;  
end;  
begin  
readln(n);  
  
for  i:=1  to  n do  
begin  
read(a[i]);  
num[i]:=i;  
end;  
  
sort(1,n);  
  
a[0]:=maxlongint;  
for  i:=1  to  n do  
if a[i]=a[i-1] then pos[num[i]]:=pos[num[i-1]]  
else pos[num[i]]:=i;  
  
for  i:=1  to n  do  
begin  
change(pos[i],1);  
ans:=ans+getsum(n)-getsum(pos[i]);  
end;  
  
writeln(Ans);  
end.  

```
离散、去重、用树状数组求逆序对


---

## 作者：墨舞灵纯 (赞：1)

    我的第一篇题解。（请大佬们多指教。当然，如果有看不懂的地方欢迎和我私信交流。）
    题目描述中，求出变成不下降序列的次数，其实就是求逆序对的个数。
    再看样例，的确如此。所以只需求出逆序对即可。
    我的方法是：用树状数组求。
    
    #include<cstdio>
	#include<algorithm>
	using namespace std;
	const int N=2000005;
	typedef long long l;
	l t[N],ans,a[N],x[N];
	int n;
	int lowbit(int k){
		return k&(-k);
	}
	void add(int k,l num){
    	while(k<=n)
	    	t[k]+=num,k+=lowbit(k);
	}
	void calc(int k){
		while(k>0) 
    	ans+=t[k],k-=lowbit(k);
	}//到此为止，以上都是树状数组模板，不再赘述。有疑问欢迎私信交流。
	bool cmp(int p,int q){
		return a[p]<a[q];
	}
	int main(){
		scanf("%d",&n);
		int i;
		for(i=1;i<=n;i++) 
		    fr(a[i]),x[i]=i;
		stable_sort(x+1,x+1+n,cmp);//这个比较重要，就是按照原顺序排序。不懂可以百度。
		for(i=1;i<=n;i++) a[x[i]]=i;
		for(i=1;i<=n;i++) //这个for循环就是求逆序对的过程，即累加这个数之前比它大的数。
        	calc(n-a[i]+1),add(n-a[i]+1,1);
		printf("%lld",ans);
		return 0;
	}


---

## 作者：Edward_Elric (赞：0)

## 思路
很容易看出就是求一个**逆序对**。

你知道吗，逆序对有两种写法

**1.归并;2.树状数组**

所以我要上一个**Splay**，虽然效率很低了

数据处理要么离散化去重，要么**stable_sort**。尽量不改变原有顺序
```
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int maxn=5e5+100;
int ch[maxn][2];
int size[maxn],cnt[maxn],fa[maxn],val[maxn];
int  ncnt,root; 
long long ans=0;
struct c
{
    int id;
    long long val;
    bool operator<(const c& x)const 
    {
        return val<x.val;
    } 
}a[maxn]; 
inline long long read()
{
    long long x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
void pushup(int u)
{
    size[u]=size[ch[u][0]]+size[ch[u][1]]+cnt[u];
}
int chk(int u)
{
    return ch[fa[u]][1]==u;
}
void rotate(int u)
{
    int f=fa[u],ff=fa[f],k=chk(u),s=ch[u][k^1];
    ch[f][k]=s;fa[s]=f;
    ch[ff][chk(f)]=u;fa[u]=ff;
    ch[u][k^1]=f;fa[f]=u;
    pushup(u),pushup(f); 
}
void spaly(int u,int goal=0)
{
    while(fa[u]!=goal)
    {
        int f=fa[u],ff=fa[f];
        if(ff!=goal)
        {
            if(chk(u)==chk(f))rotate(f);
            else rotate(u);
        }
        rotate(u);
    }
    if(!goal)root=u;
}
void insert(int x)
{
    int u=root,f=0;
    while(u&&val[u]!=x)
    f=u,u=ch[u][x>val[u]];
    if(u)cnt[u]++;
    else 
    {
        u=++ncnt;
        if(f)ch[f][x>val[f]]=u;
        fa[u]=f;val[u]=x;
        size[u]=cnt[u]=1;
        ch[u][0]=ch[u][1]=0;
    }
    spaly(u);
}
void find(int x)
{
    int u=root;
    while(ch[u][x>val[u]]&&val[u]!=x)
    u=ch[u][x>val[u]];
    spaly(u); 
}
int main()
{
    insert(inf);
    insert(-inf);
    int n=read();
    for(int i=1;i<=n;i++)
    a[i].id=i,a[i].val=read();
    stable_sort(a+1,a+1+n);
    for(int i=n;i>=1;i--)
    {
    	insert(a[i].id);
    	find(a[i].id);
    	ans+=size[ch[root][0]]-1;
    }
    printf("%lld",ans);
    return 0;
} 
```



---

## 作者：2x6_81 (赞：0)

这道题，模拟一下，很简单的：
```
#include <bits/stdc++.h>
using namespace std;
#pragma GCC optimize("Ofast")
const int N=5e5+5.5;
long long a[N],b[N],ans;
void swap1(long long int &a,long long int &b){long long t=a;a=b;b=t;}
int main()
{
	int n;
	scanf("%d",&n);
	for(register int i=1;i<=n;i++) scanf("%lld",a+i);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n-i;j++)
	if(a[j]>a[j+1]) swap1(a[j],a[j+1]),ans++;
	printf("%lld\n",ans);
}
```
我想知道这题为什么是绿的？简直太简单了！

我们可以试着交一下，发现3个AC 2个TLE

我们来分析一下这样的时间复杂度：
```
for(int i=1;i<=n;i++)
for(int j=1;j<=n-i;j++)
if(a[j]>a[j+1]) swap1(a[j],a[j+1]),ans++;
```
看见了没，这样就可以知道时间复杂度是$O(n^2)$

`对于30%的数据1≤n≤10^4`

所以最多过3个点（~~我才不会告诉你第一个点n为1000~~）

---

这道题，用归并就可以了：

以下是分析：（是如何做）

举例：（我最喜欢举栗子了）
```
4
2 8 1 3
(其实就是样例,只是0与1的区别)
```
由于前面没有可以计算的（做完倒数第二个归并程序后，结果没变，还是`2 8 0 3`），不详细说明。

最后一次：
```
a:2 8 1 3//当前数组
b:0 0 0 0//排序后的数组
i = 1;//以1开始
j = 3;
k = 1;
ans = 0;
```
我们发现，`a[j]<a[i]`，将`a[j]`放入b数组中：
```
a:2 8 1 3
b:1 0 0 0
i = 1;
j = 4;
k = 2;
```
而 1 实际上是已经与前面的交换过了，所以`ans = ans + j - k;`，即原来的位置与排序后的位置的差。
```
ans = 2;
```
第二步：`a[i]<a[j]`
```
a:2 8 1 3
b:1 2 0 0
i = 2;
j = 4;
k = 3;
ans = 2;
```
这里就不需要交换了，因为 2 实际上已经排好序了（想一想，为什么）

后面同理，最后$ans = 3$

代码：
```
#include <iostream>
#include <stdio.h>
#include <climits>
using namespace std;
int input()
{
	int re=0; char c=getchar();
	while(c<'0' or c>'9') c=getchar();
	while(c>='0' and c<='9') re=(re<<3)+(re<<1)+(c^48),c=getchar();
	return re;
}
void print(int x)
{
	if(x<10) {putchar(x^48);return;}
	print(x/10);putchar((x%10)^48);
}
const int N=5e5+5.5;
long long a[N],b[N],ans;
void msort(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)>>1;//位运算加速
    //归并排序
	msort(l,mid);
	msort(mid+1,r);
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r)
	{
		if(a[i]<a[j]) b[k++]=a[i++];
		else b[k++]=a[j++],ans=ans-k+j;
	}
	while(i<=mid) b[k++]=a[i++];
	while(j<=r) b[k++]=a[j++],ans=ans-k+j;
	for(int t=l;t<=r;t++) a[t]=b[t];
}
int main()
{
	int n;scanf("%d",&n);
	for(register int i=1;i<=n;i++) scanf("%lld",a+i);
	msort(1,n);
	printf("%lld\n",ans);
    return 0;
}
```
时间复杂度，也就是归并排序的时间复杂度：$O(n log n)$

----
欸，如果你把上面的代码试着交一遍，发现这样子只能得到$10$分，为什么呢？

我们可以$hack$一下：
```
4
2 4 2 8
```
你会发现输出的是$2$，但是实际上只需要一步：
```
2 4 2 8
2 2 4 8
Swap(2,4)
```
为什么呢？因为在这段语句中：
```
if(a[i]<a[j]) b[k++]=a[i++];
```
模拟下：
```
2 0 0 0 | ans = 2;
```
有问题！

由于`a[i]<a[j]==false`，所以程序会认为是将`a[j]`的$2$通过一步一步换排序的，而不是由`a[i]`的$2$

所以将上面的语句改为：
```
if(a[i]<=a[j]) b[k++]=a[i++];//千万不要少等号
```

---

## 作者：不存在之人 (赞：0)

【思路】

用一下归并排序就行了。
```cpp
#include<cstdio>
#include<algorithm>
#define maxn 500000+20
using namespace std;
typedef long long ll;
ll a[maxn],B[maxn];
ll n,cnt=0;
void Merge(ll A[],int l,int mid,int r)
{
    int *B=new int[r-l+1];
    int i=l,j=mid+1,k=0;
    while(i<=mid&&j<=r)
    {
        if(A[i]<=A[j]) B[k++]=A[i++];
        else
        {
            B[k++]=A[j++];
            cnt+=mid-i+1;
        }
    }
    while(i<=mid) B[k++]=A[i++];
    while(j<=r) B[k++]=A[j++];
    for(k=0;k<r-l+1;k++) A[l+k]=B[k];
    delete []B;
}
void Mergesort(long long A[],int l,int r)
{
    if(l<r)
    {
        int mid=(l+r)>>1;
        Mergesort(A,l,mid);
        Mergesort(A,mid+1,r);
        Merge(A,l,mid,r);
    }
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    Mergesort(a,1,n);
    printf("%lld",cnt);
    return 0;
}
```

---

## 作者：attack (赞：0)

来一发树状数组+二分离散化的代码

首先，树状数组中存的是小于等于当前位置的数的个数

我们先把原来的数组排序，然后每次利用二分的方式求出待求的数在排好序的序列中出现的位置

这是因为是按顺序枚举，所以我们每次默认有i个数比正在枚举的数大，那么我们用树状数组找出小于当前数的个数即可

二分查询代码：

```cpp
    int l=1,r=n;
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(mp[mid]==num)
            return mid;
        if(mp[mid]>num)
            r=mid-1;
        if(mp[mid]<num)
            l=mid+1;
    }
    return l;
```
主要代码：
```cpp
for(int i=1;i<=n;i++)
    {
        int p=erfen(a[i]);
        add(p);
        ans+=i-query(p);
    }
```
完整代码：
http://www.cnblogs.com/zwfymqz/p/7099572.html（打个广告别介意）


---

## 作者：amstar (赞：0)

ans要开long long ，ans要开long long ，ans要开long long ，最重要的事说三遍！！！

然后在归并排序过程中完成。因为逆序对数等于左边的逆序对数加右边的逆序对数加分立两侧的逆序对数，刚好可以在归并排序中完成，算是模板题了，先理解题目最重要。




```cpp
#include<cstdio>
int n;
long long ans;
int a[500100],b[500100];    //a原数组，b暂存数组 
void merge_sort(int l,int r)    //归并 
{
    if (l==r) return ;    //一个数不用排序 
    int m = (l+r)>>1;
    merge_sort(l,m);    //排序左边 
    merge_sort(m+1,r);    //排序右边 
    int i = l, j = m+1, k = l ;    //i左边最小的位置，j右边最小的位置 
    while (i<=m && j<=r)
        if (a[i]<=a[j]) b[k++] = a[i++];
        else ans += m-i+1, b[k++] = a[j++];    //加入右半段时，逆序对数增加 
    while (i<=m) b[k++] = a[i++];    //加入左边剩余的数 
    while (j<=r) b[k++] = a[j++];    //加入右边剩余的数
    for (i=l; i<=r; ++i) a[i] = b[i];    //从暂存数组中赋值 
}
int main()
{
    scanf("%d",&n);
    for (int i=1; i<=n; ++i)
        scanf("%d",&a[i]);
    merge_sort(1,n);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：pupuvovovovovo (赞：0)

这是pascal代码。

首先，你有没有看出来这题就是求逆序对？

最优方案每移动一次必定消且仅消去一个逆序对。

so，逆序对用得上树状数组吗？

据说，有一种东西叫归并排序。（n log n）

在归并过程中改一点东西就行啦。

```cpp
var n,i:longint;
ans:int64;//由于是五十万的数据，最多的逆序对个数会爆longint。
a,b:array [1..500000] of longint;
procedure merge(l,p,r:longint);
var i,j,k,t:longint;
begin
  i:=l;
  j:=p;
  for k:=l to r do
  if (i<p) and ((j>r) or (a[i]<=a[j])) then
  begin
    b[k]:=a[i];
    inc(i);
  end
  else
  begin
    b[k]:=a[j];
    inc(j);
    ans:=ans+p-i;//小改的地方。
  end;
  for i:=l to r do
  a[i]:=b[i];
end;
procedure merge_sort(l,r:longint);
var x:longint;
begin
  if l=r then exit;
  x:=(l+r) div 2;
  merge_sort(l,x);
  merge_sort(x+1,r);
  merge(l,x+1,r);
end;
begin
  read(n);
  for i:=1 to n do
  read(a[i]);
  merge_sort(1,n);
  write(ans);
end.
```

---

## 作者：Kwork (赞：0)

```cpp

#include<iostream>
const int maxn=500005;
using namespace std;
int n,a[maxn],t[maxn];
long long ans=0;

void work(int x,int y){
    if(x==y) return;
    int mid=(x+y)/2;
    work(x,mid);
    work(mid+1,y);
    int i=x,q=mid+1,p=x;
    while(p<=mid||q<=y){
        if(q>y||(p<=mid && a[p]<=a[q])) t[i++]=a[p++];//如果右边的数列已经扫完，且左边的还没有完，那么需要继续扫。
        else {
            t[i++]=a[q++];//将较小的放入，之后下标+1；
            ans+=mid+1-p;前半个数列比这个数大的全都累加，到最后即是答案。
        }
    }
    for(int i=x;i<=y;i++) a[i]=t[i];
}

int main(){
    /*freopen("sophist.in","r",stdin);
    freopen("sophist.out","w",stdout);*/
    std::ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    work(1,n);
    cout<<ans;
    return 0;
}
```
要得到不下降数列就是对它进行排序，结合这道题，就是求逆序对个数，那么我们只需要进行归并排序即可，效率是O[nlogn]。

分治做法。唯一要注意的是一些边界的处理，以及对于递归的理解。


---

## 作者：awdx (赞：0)

```cpp

#include<iostream>
using namespace std;
int n;
int ai[610000], s[610000];
long long ans;
void merge(int l, int r)
{
    int mid=(l+r)/2;
    if (l==r) return;
    merge(l, mid);
    merge(mid+1, r);
    for (int i=l, p=l, q=mid+1; i<=r; ++i)
        if ((ai[p]<=ai[q])&&(p<=mid)||(q>r))
        {
            s[i]=ai[p++];
        }
        else 
        {
            s[i]=ai[q++];
            ans+=mid+1-p;
        }
    for (int i=l; i<=r; ++i) ai[i]=s[i];
}
int main()
{
    ios::sync\_with\_stdio(0);
    cin>>n;
    for (int i=1; i<=n; ++i) cin>>ai[i];
    merge(1, n);
    cout<<ans;
}
[/code]
容易发现，对于两个相邻的数a, b。如果有a<b逆序对会加1，如果有a>b逆序对会减1，如果相等逆序对会不变。所以题目要求的是该序列的逆序对的数列。归并排序一下即可。

要用longlong，要用longlong，要用longlong！
——重要的事要说三遍


---


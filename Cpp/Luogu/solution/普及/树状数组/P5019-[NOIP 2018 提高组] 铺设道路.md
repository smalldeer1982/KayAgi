# [NOIP 2018 提高组] 铺设道路

## 题目背景

NOIP2018 提高组 D1T1

## 题目描述

春春是一名道路工程师，负责铺设一条长度为 $n$ 的道路。 

铺设道路的主要工作是填平下陷的地表。整段道路可以看作是 $n$ 块首尾相连的区域，一开始，第 $i$ 块区域下陷的深度为 $d_i$ 。 

春春每天可以选择一段连续区间 $[L,R]$ ，填充这段区间中的每块区域，让其下陷深度减少 $1$。在选择区间时，需要保证，区间内的每块区域在填充前下陷深度均不为 $0$ 。 

春春希望你能帮他设计一种方案，可以在最短的时间内将整段道路的下陷深度都变为 $0$ 。 

## 说明/提示

【样例解释】

一种可行的最佳方案是，依次选择： 
$[1,6]$、$[1,6]$、$[1,2]$、$[1,1]$、$[4,6]$、$[4,4]$、$[4,4]$、$[6,6]$、$[6,6]$。   

【数据规模与约定】

对于 $30\%$ 的数据，$1 ≤ n ≤ 10$ ；    
对于 $70\%$ 的数据，$1 ≤ n ≤ 1000$ ；     
对于 $100\%$ 的数据，$1 ≤ n ≤ 100000 , 0 ≤ d_i ≤ 10000$ 。   

## 样例 #1

### 输入

```
6   
4 3 2 5 3 5 
```

### 输出

```
9```

# 题解

## 作者：Ark__Skadi (赞：1335)

[~~（其实是USACO原题）~~](https://www.luogu.org/problemnew/show/P3078)
## 它就是一个贪心。

题目里给的样例是4，3，2，5，3，5；

可以选择一个区间进行“填坑”操作；

所以我们的贪心策略是：

###  若a[i]>a[i-1],计数器sum+=a[i]-a[i-1]; 

那么为什么这样贪心是对的呢？

### 贪心证明

假设现在有一个坑，但旁边又有一个坑。

你肯定会选择把两个同时减1；

那么小的坑肯定会被大的坑“带着”填掉。

大的坑也会减少a[i]-a[i-1]的深度，可以说是“免费的”；

所以这样贪心是对的；

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005];
long long ans=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)     cin>>a[i];
	for(int i=2;i<=n;i++)     if(a[i]>a[i-1]) ans+=a[i]-a[i-1];
	cout<<ans+a[1];
	return 0;
}
```
记得要加上a[1]，或者在前面填一个0；
（这是本蒟蒻第一次写题解，~~支持一下哦~~。）

---

## 作者：我醉了 (赞：274)

[传送门](https://www.luogu.org/problemnew/show/P5019#sub)

看dalao没人用递推，我发个递推的方法吧。。。

其实我觉得递推代码最短了。。

说实话，当时我还觉得这道题挺不简单的。。（因为我没做过2013的那个[积木大赛](https://www.luogu.org/problemnew/show/P1969#sub)）还是我太蒟了啊。

~~听说有积木大赛这题后，我就把我的这道题的ac代码原封不动的提交上去，一下子a了（还真是一道题。。）~~

这道题我用了递推，在考场上推出了一个莫名其妙的式子。大致思路是这样：

用$f[i]$表示前i个坑所铺设的最少天数

那么要做的只需比较一下当前的$a[i]$（就是坑的深度）和$a[i-1]$，分两种情况：

如果$a[i]<=a[i-1]$，那么在填$a[i-1]$时就可以顺便把$a[i]$填上，这样显然更优，所以$f[i]=f[i-1]$;

否则的话，那么在填$a[i-1]$时肯定要尽量把$a[i]$一块填上，$a[i]$剩余的就单独填。。

所以，$f[i]=f[i-1]+(a[i]-a[i-1])$。

初始化$f[1]=a[1]$，向后推就行了。

复杂度大概是$O(n)$

说实话，我当时交上并没有抱什么希望。所以后来我听说我第一题没错后，心里还是挺惊讶的。。。

上我的代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int n,a[110000],f[110000];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	f[1]=a[1];
	for(int i=2;i<=n;i++)
	{
		if(a[i]<=a[i-1])
			f[i]=f[i-1];
		else f[i]=f[i-1]+(a[i]-a[i-1]);
	}
	cout<<f[n]<<endl;
	return 0;
}
```

我觉得挺简单易懂的。。。

其实这代码还可以更短，我们完全可以边输入边计算，这样会更加精简。


---

## 作者：_yjk (赞：82)

### [题目链接](https://www.luogu.org/problem/P5019)

[我的博客](https://www.cnblogs.com/yjkhhh/p/11357695.html)

众所周知，这道题和积木大赛是同一道题

题意就是给出一段自然数序列，每次操作$(L,R)$把区间$[L,R]$的数全部减一，不允许出现负数，问把序列变为零的最小操作次数

## 贪心做法

样例
```
6   
4 3 2 5 3 5 
```
大概长这个样子

![](https://img2018.cnblogs.com/blog/1340330/201908/1340330-20190815141753439-259503194.png)

我们考虑第一列的四块格子，最少需要$4$次操作给消除掉

![](https://img2018.cnblogs.com/blog/1340330/201908/1340330-20190815142012801-782001083.png)

在考虑第二列的$3$个格子时，发现都可以在第一列的$4$次操作中一起消除掉

第三列的格子也都可以一起消除掉

![](https://img2018.cnblogs.com/blog/1340330/201908/1340330-20190815142322612-638230394.png)

考虑第四列，我们可以发现，第四列下面的两个格子在前面的操作中可以一起消除，但是上面的三个是至少再进行三次操作才能消除的

![](https://img2018.cnblogs.com/blog/1340330/201908/1340330-20190815142525477-439492870.png)

而第五列下面的两个格子在第一列的操作中可以消除，上面的一个格子可以在第四列的操作中删除

![](https://img2018.cnblogs.com/blog/1340330/201908/1340330-20190815142718579-32650094.png)


考虑第六列，上面的$2$个格子是前面操作消除不了的，需要$2$次操作

![](https://img2018.cnblogs.com/blog/1340330/201908/1340330-20190815142849545-1760166943.png)

那么答案就是$4+3+2=9$

![](https://img2018.cnblogs.com/blog/1340330/201908/1340330-20190815143119464-380537941.png)

这样大概可以总结出做法：当$a_{i-1}<a_i$时，$ans+= a_i - a_{i-1}$

## 贪心证明

下面用差分序列给出这个贪心的证明：

我们对原序列$\{a_i\}$维护一个差分数组$\{diff_i\}$

原序列不妨在最后加一个$0$，
```
6   
4 3 2 5 3 5 0
```

差分数组是
```
4 -1 -1 3 -2 2 -5
```
每次操作可以表示为$diff[L]--$,$diff[R+1]++$

最终的状态就是差分数组全部变成$0$

首先，每次操作最多让一个大于零的$diff_i$ $-1$，所以 最优解$ans>=sum(diff_i,diff_i>0)$

下面要证明 $ans=sum(diff_i,diff_i>0)$

$a_{n+1}=0$   =>  $sum(diff_i)=0$   =>   $sum(diff_i,diff_i>0)+sum(diff_i,diff_i<0)=0$

我们只要每次操作能让一个大于$0$的$diff_i$ $-1$,同时后面一个小于$0$的$diff_i$ $+1$才能够使$ans=sum(diff_i,diff_i>0)$

然而有一个限制条件：$a_L$~$a_R$之间没有零 否则这个操作就是不合法的

我们可以利用以下性质构造解法：

性质1：由题意知任意时刻$a_i>=0$，若$diff_i>0$ 则$a_i>a_{i-1}>=0$,得$a_i>0$

性质2：由于$a_{n+1}=sum(diff_i)=0$,对于一个大于零的$diff_i$,$sum(diff_{1}$~$diff_{i})=a_i>0$,它的后面一定存在小于零的$diff_i$

于是有：每次选一个大于零的$diff_i$作为操作的左端点$L$,它右边的第一个小于零的$diff_j$作为$R+1$，已知$a_L>0$,$[L,R]$中任意$diff_k>=0$,可得任意$a_k$属于$[L,R]$,$a_k>=a_{k-1}>=a_L>0$,因此该操作合法

所以存在至少一种操作方法可以在$sum(diff_i,diff_i>0)$次操作后使得$diff$序列全部为$0$，$ans=sum(diff_i,diff_i>0)$

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;

const int MAXN=100010;

int n,ans;

int main()
{
	scanf("%d",&n);
	int x,last=0;
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		if(x>last) ans+=x-last;
		last=x;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Jr_Zlw (赞：27)

## 这题我是用分治做的

~~做完以后发现贪心的十几行代码酸了~~.............~~自挂东南枝~~

在训练的“普及练习场”中这题属于分治，我很快想到了一种解法：

### 其实就是一种搜索

```
找到一段路程中的最小值，

再给这段里的每一个数都减去这个最小值，

这样就会出现0，就会有断层，可以继续寻找，

然后填的次数+1
```

所以，只要知道要选择哪一段填，就会有这种操作计算次数。

所以，为了方便未来的主函数或搜索函数的简便，我们打出了第一个函数：

```cpp
void operate(int head,int tail)//head和tail是这段中的开始到结尾
{
	minn=0x7fffffff;//0x7fffffff是int里面最大的数
	for(int i=head;i<=tail;++i)
	{
		if(a[i]<minn)
		{
			minn=a[i];
		}
	}//找最小值
	for(int i=head;i<=tail;++i)
	{
		a[i]-=minn;
	}//在这一段中的每个数据减去最小值
	sum+=minn;//总数加上
	return;
}
```

看，已经初具形态了。

### 接下来，我们还要对其进行搜索
```

搜索中的重点其实就是枚举每一段的开始和结尾，

所以只要找到 0 就能分段了
```
所以，先找 0，再去操作 0 之前和之后的那些东西；

这个函数如下：
```
void search(int head,int tail)
{
	if(tail<head)  return;
	operate(head,tail);
	for(int i=head;i<=tail;++i)
	{
		if(a[i]==0)
		{
			search(i+1,tail);
		}
	}
	return;
}
```

~~我在浑浑噩噩之中打出了这个程序，天真的以为这是分治，结果被怼了~~

这个函数是绝对不被允许的，时间复杂度太~~mmm~~高了。

一层递推套一层循环。。。啧啧啧，结果只对了3个测试点，~~呜呼哀哉~~

### 为了能A掉这题，死也要剪枝；

其实再仔细看这个函数，其实搜了很多不必要的东西。

其实每次再 operate() 中随机找一个分界点出来分，其实就包括了所有的点。

```
所以在找最小值的时候，我将最后一个最小值的下标标为“des”，

然后在 search() 里面查找 des 的前后段就可以了
```
然后输入输出有任何问题。。。。。。还是看代码吧！

双手奉上AC代码：
```
#include<iostream>
#include<cstdio>
using namespace std;

int a[10001],minn=0x7fffffff,n,des;
unsigned long long int sum; 

void operate(int head,int tail)
{
	minn=0x7fffffff;
	for(int i=head;i<=tail;++i)
	{
		if(a[i]<minn)
		{
			minn=a[i];
			des=i;
		}
	}
	for(int i=head;i<=tail;++i)
	{
		a[i]-=minn;
	}
	sum+=minn;
	return;
}

void search(int head,int tail)
{
	if(tail<head)  return;
	operate(head,tail);
	search(des+1,tail);
	search(head,des-1);
	return;
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];
		if(a[i]<minn)
		{
			minn=a[i];
		}
	}
    search(1,n);
    cout<<sum;
    return 0;
}
```
50行的代码的确对于蒟蒻来说有点长，还是慢慢看吧。

---

## 作者：ikunTLE (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P5019)

### 思路

考虑**贪心**。想要答案最小，就要使每次填的坑最尽可能多。不难想到可以先把前面的坑填上，填后面的坑时就可以顺带把前面坑填上。如果不能一起填就只能单独填。

形式化来讲，若 $d_i\le d_{i-1}$，那么可以一起填，后面的答案不变。反之若 $d_i>d_{i-1}$，那么后面只能单独填，答案增加 $d_i-d_{i-1}$。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e5+10;
int a[N];
int main(){
	int n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	int ans=a[1];
	for(int i=2;i<=n;++i)
		if(a[i]>a[i-1])
			ans+=a[i]-a[i-1];
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：引领天下 (赞：5)

这题目就我一个人模拟吗？

普及蒟蒻，不会好算法，就来说一发模拟吧

首先一个贪心：

# 每次选一个连续正深度的坑的区间去填

为什么呢？因为只有这样，才能保证**我每次填坑的数量最多，不会造成浪费（即可以一天解决的问题我2天解决）**，也就是保证填的天数最少

于是得到了$ O(n^2* sum(a[1...n])) $，嗯，超时成什么样我就不说了

于是优化：

观察下面的表：

| d[1] | d[2] | d[3] | d[4] | d[5] | d[6] | d[7] |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 4 | 3 | 3 | 4 | 3 | 3 |
| 0 | 3 | 2 | 2 | 3 | 2 | 2 |
| 0 | 2 | 1 | 1 | 2 | 1 | 1 |
| 0 | 1 | 0 | 0 | 1 | 0 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 |

可以发现，第2行与第3行实际上是重复的

在本例中，只重了2行；

如果重个10000，100000行呢？

那么你的程序就会T。

如何优化？

不难发现，我们填坑的过程是有规律的；

于是就有了优化：

**每次循环必然要彻底填掉至少1个坑**

那么，实现就很简单了：

在找**连续整数的时候，顺便查找最小值**，然后区间减最小值，完成目标。

到此为止，你已经拿到80分了

还有两个点什么情况？

因为，尽管我们优化了，整个复杂度还是$ O(n^{2}) $，是会T的

再优化！

我们可以发现，**当我们找区间的开始的时候，其实是有单调性的**

# 即：我下一次填坑的起始点一定在本次填坑的范围中

那么在模拟减的时候就可以顺便找下一次的开始了。

你也许发现了一个问题：

> 一遍坑全部填平了怎么办？

没事，设定一个极值，最后判一下，如果没变的话就从本次的结束点往后找啦~

于是复杂度降到了$ O(n+\text{常数}) $，就AC了

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,d[100005],q=1;
long long s,ans;
int main(){
    scanf ("%d",&n);
    for (int i=1;i<=n;i++)scanf ("%d",&d[i]),s+=d[i];//读入，统计和
    int b=1;
    while (d[b]==0)b++;//找开端
    q=b;//下一个开端
    while (s){
    	b=q;
        int e=b,mn=1<<20;
        while (d[e])mn=min(mn,d[e]),e++;//找最小值
        ans+=mn,s-=mn*(e-b);//花mn天干，总和减去填的所有
        q=1<<20;
        for (int i=e-1;i>=b;i--){d[i]-=mn;if (d[i]>0)q=i;}//模拟减，同时找下一次的开端
        if (q==1<<20)for (q=e+1;q<=n;q++)if(d[q]>0)break;
    }
    printf ("%d",ans);
}
```

---

## 作者：Yxy7952 (赞：3)

## 思路
贪心题。

肯定是选择尽量多的坑来填。

我们把当前这个坑跟前一个坑的联系在一起，如果这个坑的深度比前面一个小，那么在填前一个坑的时候，就会把当前坑一起填完。否则，它需要自己填多的部分，也就是 $a_i-a_{i-1}$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s+=max(0,a[i]-a[i-1]);
	}
	cout<<s;
	return 0;
}
```

---

## 作者：WsW_ (赞：2)

### 思路
非常经典的贪心题。  
在填补第 $i$ 块区域时，如果 $d_{i-1}\ge d_{i}$，那么在填补第 $i-1$ 块区域的时候连带着填补完第 $i$ 块区域一定最优。如果 $d_{i-1}< d_{i}$，那么在填补第 $i-1$ 块区域的时候连带着给第 $i$ 块区域填补 $d_{i-1}$ 一定最优。然后剩下的再单独给第 $i$ 块区域补 $d_{i}-d_{i-1}$，这里的**单独**指的是以第 $i$ 块区域开头的填补。  
遍历一边就行了，时间复杂度为 $O(n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,h[100005],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&h[i]);
		ans+=max(h[i]-h[i-1],0);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：LXcjh4998 (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P5019)
# 题意
给定一个自然数序列，一次操作给定两个数 $L$ 和 $R$，使区间 $[L,R]$ 全部数减 $1$，且不允许出现负数。问将序列变为 $0$ 至少需要几次操作。
# 思路
考虑贪心。设序列的第 $i$ 项为 $a_i$，且该序列有 $n$ 项，将答案保存在 $ans$ 里。则当 $a_{i-1}<a_i$ 时，$ans$ 加上 $a_i-a_{i-1}$。别忘了对 $ans$ 赋初值 $a_1$（为了将 $a_1$ 变成 $0$）。

为什么这种贪心是正确的呢？我们可以对其感性理解下。

如果有 $a_{i-1}\geq a_i$，则在将 $a_{i-1}$ 减至 $0$ 时，我们也可以顺带将 $a_i$ 减至 $0$，所得的答案一定不会更劣；如果 $a_{i-1}<a_i$，则需要再用 $a_i-a_{i-1}$ 次操作将 $a_i$ 变成 $0$。

例如，对于样例，模拟的结果如下：
- $ans=a_1=4$；
- $a_1\geq a_2$，$ans$ 不变；
- $a_2\geq a_3$，$ans$ 不变；
- $a_3<a_4$，$ans$ 加上 $a_4-a_3$，得 $ans=7$；
- $a_4\geq a_5$，$ans$ 不变；
- $a_5<a_6$，$ans$ 加上 $a_6-a_5$，得 $ans=9$。

所以输出结果为：
```cpp
9
```

而在代码中，可以再用一个 $a_0=0$，对于 $a_1$，有 $a_0<a_1$，则 $ans$ 会加上 $a_1-a_0$，即加上 $a_1$，就达到了给 $ans$ 赋初值 $a_1$ 的目的。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,arr[100001],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&arr[i]);
	for(int i=1;i<=n;++i)if(arr[i-1]<arr[i])ans+=arr[i]-arr[i-1];//贪心
	printf("%d",ans);
    return 0;
}
```

---

## 作者：sea_bird (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P5019)。

# 题目分析

挺喜欢这题的，一道经典的**贪心**题目。

### 做法

这题的贪心思路便是如果每个坑比上一个深，那么新增填坑的量，就是当前坑与上一个坑的差，也就是 `cnt+=a[i]-a[i-1];` 所表达的意思。

## 思路

如何想到贪心的思路是很重要的一点。回归题目，抛去题目背景，就是对于一串数，每次操作选定一段区间的数减一，使其整串数最终都变为零。

为了让代价最小，就是让每次操作能让**尽量多的数**能减小，但是啥时候全部变为零还是要**取决于最大的**那个数，因为别的比它小的数都已经变为零时，由于其自身还有剩余，所以必然要**用额外的代价去减小**它，那么既然迟早要用这个代价，那么在代码中先算上这个代价后算上这个代价便没了区别，因此整个序列中的代价都取决于值更大的那个。当然这些数不一定有序，但这并不会影响更大的值，因为减小小的数也必然令大的数的大小减小，而由于是减去了一个比它小的数，所以大的数剩余部分如上文所说的，最后也要用代价减去，那么不如现在减掉，以此类推。当然假如是让一些正数一些负数变为零，便要多考虑些了。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt=0,n;//计数 数列的个数
long long a[100005];//存数列中每个数
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];//存入数组
	}
	for(int i=2;i<=n;i++){//遍历数列
		if(a[i]>a[i-1]){//贪心思路
			cnt+=a[i]-a[i-1];//加上为消除的大小
		}
	}
	cout<<cnt+a[1]<<endl; //别忘了消除第一个数
	return 0;
}
```

---

## 作者：GSQ0829 (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P5019)

---
### 思路：
其实这道题很简单，就是跟[积木大赛](https://www.luogu.com.cn/problem/P1969#sub)那题一模一样的。

很简单。这道题就是填坑法，所以用贪心。

假设现在有一个坑，但旁边又有一个坑。

那么你就会将两个坑一起减掉一。

那么小的坑肯定会被大的坑“带着”填掉。

大的坑也会减少相应的深度。

这就是贪心策略。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100001], n, ans = 0;

int main () {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	ans = a[1];
	for (int i = 2; i <= n; i++) {
		if (a[i - 1] < a[i]) ans += a[i] - a[i - 1];
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：yr409892525 (赞：1)

## P5019 [NOIP2018 提高组] 铺设道路 题解

我们发现把前一个减少的时候，这一个也可以减少。        
当 $d_i \le d_{i-1}$ 可以将 $d_i$ 和 $d_{i-1}$ 同时减去 $d_i$。         
当 $d_i > d_{i-1}$ 可以将 $d_i$ 和 $d_{i-1}$ 同时减去 $d_{i-1}$，再花费 $d_i-d_{i-1}$ 减去 $d_i$。             
所以最后直接按照公式模拟即可。  
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
int n;
int a[N];
int diff[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n;
	int sum=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		diff[i]=a[i]-a[i-1];
		if(diff[i]>0) sum+=diff[i];
	}
	cout<<sum<<"\n";
	return 0;
}
```

---

## 作者：glass_goldfish (赞：1)

这题是一道比较简单的贪心。  

我们发现，如果 $a_{i-1}\le a_{i}$，那么 $a_{i-1}$ 肯定会被在填 $a_i$ 的时候顺带一起被填掉，但是还是要填 $a_i-a_{i-1}$ 的深度（因为还要把 $a_i$ 填掉）。建立变量 $ans$，依次枚举即可。但是要注意，按照这种方法，第一次直接要把 $a_1$ 填了，所以 $ans$ 的初始值为 $a_1$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f
using namespace std;
int n,a[300001];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	int ans=a[1];
	for(int i=2;i<=n;i++)
		if(a[i]>=a[i-1])
			ans+=(a[i]-a[i-1]);
	cout<<ans;
	return 0;
}
```

---

## 作者：_Maverick_ (赞：1)

## 方法：递推法
从第 $1$ 个坑开始，如果后一个的深度比前一个深度小，则填充天数不变（为第一个坑的深度）。

如果后一个坑的深度比前一个坑的深度大，则填充天数要增加：后一个坑的深度减前一个坑的深度。

依次比较每个相邻高度深度，最后加上第一坑的深度，即得到答案。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
int a[N], n;
long long ans;
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];

    for(int i = 2; i <= n; i++)
    {
        if(a[i] > a[i - 1]) ans += a[i] - a[i - 1];
    }
    ans += a[1];
    cout << ans;
    return 0;
}
```

---

## 作者：_H17_ (赞：1)

## 题目分析

我们需要次数最少，又想到了贪心。贪心的说，我们肯定是对一段整体推掉 $1$ 直到有的变成 $0$。之后又可以分成更小的段继续操作。

怎么分段？我们想起了差分。每次比前一个数增大就是开始了新的一段（显然它前一个数的段会先填好，只剩下它和后面的一些数又成一段）。段的结尾不需要考虑（其实就是减少的时候），因为题目没有让我们说方案，而且结束和开始数量一样。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
short a[100001];
int ans;
int main(){
    scanf("%d",&n);
	for(int i=1;i<=n;i++)
        scanf("%d",a+i);
	ans=a[1];
	for(int i=2;i<=n;i++)
	    if(a[i]>a[i-1])
            ans+=a[i]-a[i-1];
        printf("%d",ans);
    return 0;
}
```

---

## 作者：niuniudundun (赞：1)

贪心题。

# 题目大意

有长度为 $n$ 的序列 $d$，每次操作选择区间 $[l,r]$，区间的 $d_l \sim d_r$ 减去一，求 $d$ 均为 $0$ 的操作次数。

# 解法

设答案为 $ans$。

这么贪心：

>若 $d_i>d_{i-1}$，那么 $ans\gets ans+d_i-d_{i-1}$。

为什么这么贪心呐？

看样例：

```plain
   | |
|  | |
|| |||
||||||
||||||
```

如果 $d_i>d_{i-1}$，那么填 $d_i$ 时会随带填 $d_{i-1}$，但填不满 $d_{i-1}$，填 $d_{i-1}$ 剩下的就是 $d_i-d_{i-1}$，这会对结果造成 $d_i-d_{i-1}$ 次的贡献，所以 $ans\gets ans+d_i-d_{i-1}$。

所以答案为：$\displaystyle \sum_{i=1}^{n} [d_i>d_{i-1}]\times (d_i-d_{i-1})$（其中 $[]$ 是艾弗森括号，真返回 $1$，假返回 $0$）。

# 代码

```cpp
#include<iostream>
using namespace std;
long long n,d[100001],ans=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>d[i];
	}
	for(int i=1;i<=n;i++){
		if(d[i]>d[i-1]) ans+=d[i]-d[i-1];
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法为贪心。

我们可以先来分析一下样例:
![https://cdn.luogu.com.cn/upload/image_hosting/2d1fqpb4.png](https://cdn.luogu.com.cn/upload/image_hosting/2d1fqpb4.png)
我们可以先用差分的思想把相邻两段路的陷深度算出来，然后去枚举差。我们要使操作次数越少就必须要以陷深度较小的路为标准，把它们的差填满，否则会浪费次数。如果 $a_i>a_{i-1}$ , 也就是可以以 $a_i$ 作为标准把 $a_{i-1}$ 的陷深度减少 $cha_{i}$。

**注意：若果 $a_i=a_i-1$ 就不能变化，因为有可能后面的路可以连着这些路一起移平。**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005],cha[1000005];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		cha[i]=a[i]-a[i-1];
	}
	int cnt=0;
	for(int i=1;i<=n;i++)
	{
		if(cha[i]>0) cnt+=cha[i];
	}
	cout<<cnt;
	return 0;
} 
```

---

## 作者：ChenZQ (赞：0)

首先，我们会发现，一段连续有下陷的位置，我们可以通过慢慢统一高度的方式来填。也就是说先把第一深的填成跟第二深的，然后以此类推，直到填平。

为什么呢，因为我们一次操作要尽量填多。你可能会疑问，不能把整个连续下陷的区域一起填吗？

如果整段一起填，最低的深度被填满之后，剩下的还是得按照前面说的方法慢慢填平，所以是等价的。

那么归纳一下这个填法，其实就是如果后面的深度大于前面的深度，就要填高度差。

![](https://cdn.luogu.com.cn/upload/image_hosting/jnyincfx.png)

可以画图理解一下。因为我刚刚说的方法其实就是如果一个后面的比前面的深，自然就需要补齐高度，而如果后面的比前面的浅，就可以和之前的顺带着一起被填满。

```
#include<bits/stdc++.h>
using namespace std;

int n,a[100010];
long long ans=0;

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=2;i<=n;i++) if(a[i]>a[i-1]) ans+=a[i]-a[i-1];
	cout<<ans+a[1];
}
```

---

## 作者：__galaxy_1202__ (赞：0)

## 解题思路：
考虑贪心。  


容易发现，对于若该序列单调不增，所需天数为第一个数。  
所以我们可以利用这个思路，找到每组单调不增的序列，记录下第一个数的值。 


但这个方法并不是最优的，因为在一个序列的最小值归零前，后面的数可以一起操作。所以要把每一个两个单调不增序列的最大值与上一个的最小值作差。

可借助代码更好地理解。
## CODE：

```cpp
#include <iostream>
using namespace std;
int n, ans, d[100001];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> d[i];
	for (int i = 1; i <= n; i++)
		if (d[i] > d[i - 1])
			ans += d[i] - d[i - 1];
	cout << ans;
	return 0;
}
```

---

## 作者：SuyctidohanQ (赞：0)

### 题目分析

一道经典的贪心。

想要答案最小，就要使每次填的坑最尽可能多。所以可以先把前面的坑填上，填后面的坑时就可以顺带把前面坑填上。如果不能一起填就只能单独填。

因此，答案为：$\sum_{i = 1}^{n} \max (a _ i - a_{i - 1}, 0)$。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
int main () {
	int n, x = 0, a, ans = 0;
    cin >> n; 
	for (int i = 1; i <= n; i ++) {
	    cin >> a;
	    ans += max (a - x, 0);
        x = a;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Vct14 (赞：0)

简单贪心。

如果一块区域下陷得比下一块区域深，那么在填这块区域的过程中一定可以把下一块区域顺带填完。因此答案为 $\sum\limits_{i=1}^n\max(a_i-a_{i-1},0)$，其中 $a_0=0$。

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n;cin>>n;int lst=0;long long ans=0;
	for(int i=1; i<=n; i++){
	    int a;cin>>a;
	    ans+=max(a-lst,0);lst=a;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：zhangzirui66 (赞：0)

首先进行观察，发现第 $i$ 块区域分为两种情况：

- $a_i \le a_{i-1}$，此时 $a_{i-1}$ 操作时可以带上它，无需额外操作，答案不变。
- $a_i > a_{i-1}$，此时前面带完后还需降低，答案补上差值 $a_i - a_{i-1}$。

枚举 $i$ 判断即可。

给出参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[100005], ans;
int main(){
    cin >> n;
	for(int i = 1; i <= n; i ++) cin >> a[i];
	for(int i = 1; i <= n; i ++){
		if(a[i] > a[i - 1]) ans += a[i] - a[i - 1];
	}
	cout << ans;
    return 0;
} 
```

---


# [GESP202412 七级] 燃烧

## 题目描述

小杨有一棵包含 $n$ 个节点的树，其中节点的编号从 $1$ 到 $n$。节点 $i$ 的权值为 $a_i$。

小杨可以选择一个初始节点引燃，每个燃烧的节点会将其相邻节点中权值**严格小于**自身权值的在节点间扩散直到不会有新的节点被引燃。

小杨想知道在合理选择初始节点的情况下，最多可以燃烧多少个节点。

## 说明/提示

| 子任务编号 | 数据点占比 |     $n$     |
| :--------: | :--------: | :---------: |
|    $1$     |   $20\%$   |  $\leq 10$  |
|    $2$     |   $20\%$   | $\leq 100$  |
|    $3$     |   $60\%$   | $\leq 10^5$ |

对于全部数据，保证有 $1\leq n\leq 10^5$，$1\leq a_i\leq 10^6$。

## 样例 #1

### 输入

```
5
6 2 3 4 5
1 2
2 3
2 5
1 4```

### 输出

```
3```

# 题解

## 作者：I_LOVE_XYN (赞：21)

# 题目描述
在一个有 $N$ 节点的树内，以随机一个点为根的树共有几个权值比它小的子节点。

# 知识点提炼
记忆化搜索。

# 思路
我们发现这道题有 $10^5$ 的数据范围，首先想到的是 $O(n)$ 的时间复杂度，本蒟蒻考场上只能想到深搜，可是必须使用记忆化，保证所有节点只访问一次，减少冗余运算：

搜出所有比**原点小**的儿子，**统计满足条件的儿子数量**再将其回溯到父亲节点。如果访问过了该节点，直接将已经统计完的数据返回自己的父亲。


```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
int n,a[1000006],vis[1000006];
vector<int> edge[1000006];
int dfs(int x){
	if(vis[x] != 0) return vis[x];
	//如果访问过了，直接返回之前的值，保证每个节点访问一次。 
	int cnt = 0;
	for(auto &v : edge[x])
		if(a[x] > a[v]) //如果连接的点比自己的小 
			cnt += dfs(v); //先统计 
	return vis[x] = cnt + 1;
	//这里的 1 是自己，因为自己属于节点，所以+1 
}
main(){
	cin >> n;
	for(int i = 1;i <= n; i++) cin >> a[i];
	for(int i = 1,x,y;i < n; i++){
		cin >> x >> y;
		edge[x].push_back(y);
		edge[y].push_back(x);
	}
	int ans = 0;
	for(int i = 1;i <= n; i++)
		ans = max(ans,dfs(i));
	//直接取最大值，不一定是节点1之类的 
	cout << ans;
} 
```

~蒟蒻的第一篇题解，求过求过求过~

---

## 作者：piske (赞：15)

# P11378 [GESP202412 七级] 燃烧
## [题目传送门](https://www.luogu.com.cn/problem/P11378)
思路：每个点初始都有一个可燃烧点（自己），每次循环找到没有子节点的点（序号小于自己的点），把它的可燃烧点叠加到父节点上，最后删除这个点，只保留值。这样就一层一层地赋好了值，最终找出最大值输出就可以了。
每次赋值不用一直叠加到祖先，只用向上叠加一层就可以了，减小时间复杂度。同时，每次都找没有子节点的点，这样就可以不用多次操作一个点。
## 代码
```cpp
#include <bits/stdc++.h> 
using namespace std; 
int n; 
int a[100010]; 
vector<int> b[100005];             //存储父节点 
int c[100010]; 
int vis[100010]; 
int num[100010]; 
int main( ){ 
	cin>>n; 
	for(int i=1;i<=n;i++) 
		cin>>a[i]; 
	for(int i=0;i<n-1;i++) 
	{ 
		int x,y; 
		cin>>x>>y; 
		if(a[x]<a[y]) 
			b[x].push_back(y),c[x]++,vis[y]++; 
		if(a[y]<a[x]) 
			b[y].push_back(x),c[y]++,vis[x]++;  
	} 
	for(int i=1;i<=n;i++) 
		num[i]=1; 
	for(int k=0;k<10;k++) 
	{  
		for(int i=1;i<=n;i++) 
		{	 
			if(vis[i]==0){                     //找到没有子节点的点 
				for(int j=0;j<c[i];j++) 
					num[b[i][j]]+=num[i]; 
				vis[i]=-1; 
				for(int j=0;j<c[i];j++) 
					vis[b[i][j]]--; 
			} 
		} 
	} 
	int maxn=0; 
	for(int i=1;i<=n;i++) 
		maxn=max(maxn,num[i]); 
	cout<<maxn; 
	return 0; 
} 
```

---

## 作者：lby_commandBlock (赞：4)

## 思路

通过观察题目~~标签~~得知，这道题是一个记忆化搜索的题目。

我们可以使用 $ans_v$ 表示第 $v$ 个点点燃后最大会有 $ans_v$ 个结点在燃烧。

假设现在要求 $ans_u$ 是多少，则枚举 $u$ 的**所有权值比它小的邻居**，使用深搜求出结点燃烧的个数，保存在 $ans_u$ 里即可。

## 举例

例如这个树：

![](https://cdn.luogu.com.cn/upload/image_hosting/dspgkfx3.png)

它们的权值为 $[1,2,3,4,5,6]=[30,25,14,69,25,47]$。

初始时 ans 数组为（$-1$ 表示未遍历）：

$$ans=\{-1,-1,-1,-1,-1,-1\}$$

初始时点燃哪个都可以，我们以 $1$ 举例。

点燃 $1$ 后，枚举 $1$ 的相邻结点，发现有 $2,3,6$，因为 $6$ 的权值比 $1$ 大，所以 $2,3$ 会被点燃。而 $3$ 被点燃后，虽然 $4$ 与它连边，但是 $4$ 的权值比 $3$ 大，所以不会被点燃。

于是，ans 数组变成了这样：

$$ans=\{2,1,1,-1,-1,-1\}$$

我们看到 $4,5,6$ 都还没有被遍历，则遍历 $4,5,6$ 都可以，我们拿 $4$ 举例。

$4$ 被点燃后，我们找到它们的邻居结点 $3,5$，发现 $3,5$ 的权值都比 $4$ 小。$4$ 已经被遍历过了，是 $1$，**无需再次遍历（剪枝）**，$5$ 就只有自己一个，就是 $1$，所以 $4$ 的点燃结点数量就是 $1+1=2$。最终，ans 数组就变成了这样：

$$ans=\{2,1,1,2,1,-1\}$$

由于 $6$ 还没被更新，所以看 $6$。$6$ 的相邻结点为 $1$，$1$ 的权值比 $6$ 小，所以我们看 $1$。因为 $1$ 被遍历过了，是 $2$，加上自己本身的燃烧，所以是 $2+1=3$。ans 数组最终是这样：

$$ans=\{2,1,1,2,1,3\}$$

最后，我们找到最大的一个数字即可。

- 求 $ans_u$ 时，由于是所有**严格小于**结点 $u$ 的权值的点才会被遍历到，下一次被遍历到时就可以**直接返回结果，不用更新 $ans_u$**，所以**不会被重复计算**。这样即可以保证 $ans$ 的正确性，又因为每个点也就只会被计算一次，所以时间复杂度也是线性的。

## 代码

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;

const int N = 1e5 + 9;

int n, a[N], ans[N];

vector<int> e[N];

int dfs(int u, int fa) {
	// 如果是叶子结点
	if (e[u].size() == 1 && e[u][0] == fa) {
		// 则只能自己燃烧
		return 1;
	}
	// 如果已经被计算过了，就直接返回
	if (ans[u])
		return ans[u];
	// 计算一下
	int cnt = 1;
	for (auto v : e[u])
		if (v != fa && a[v] < a[u])
			cnt += dfs(v, u);
	// 返回结点数
	return ans[u] = cnt;
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	// 邻接表村边
	for (int i = 1; i <= n - 1; i++) {
		int u, v;
		cin >> u >> v;
		// 无向边
		e[u].push_back(v);
		e[v].push_back(u);
	}
	// 枚举每一个点进行搜索
	for (int i = 1; i <= n; i++)
		dfs(i, -1);
	// 找到最大的一个点
	int cnt = 0;
	for (int i = 1; i <= n; i++)
		cnt = max(cnt, ans[i]);
	cout << cnt << endl;
	return 0;
}

```
`2024/12/10 22:07` 修改一个很严重的笔误，并且优化题解。

---

## 作者：Lcm_simida (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P11378)

思路：先假设以 $1$  为根节点，同时每个节点只能往子节点传火，此时可以使用深搜来寻找。但是每个节点都还可以往父节点传火，所以我们深搜的同时记录可以往父节点传火的点，之后从上往下处理即可。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100005],dp[100005],ans;//答案
vector<int> v[100005],num[100005];
void dfs(int x,int fu){
	queue<int> q;
	dp[x]=1;
	for(int i=0;i<v[x].size();i++){
		if(v[x][i]==fu) continue;
		dfs(v[x][i],x);
		if(a[v[x][i]]>a[x]) num[v[x][i]].push_back(x);
		if(a[v[x][i]]<a[x]) dp[x]+=dp[v[x][i]];
	}
}
void d2(int x,int fu){
	for(int i=0;i<num[x].size();i++) dp[x]+=dp[num[x][i]];
	for(int i=0;i<v[x].size();i++){
		if(v[x][i]==fu) continue;
		d2(v[x][i],x);
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1,j,k;i<n;i++){
		cin>>j>>k;v[j].push_back(k);v[k].push_back(j);
	}
	dfs(1,-1);d2(1,-1);
	for(int i=1;i<=n;i++) ans=max(ans,dp[i]);
	//for(int i=1;i<=n;i++) cout<<dp[i]<<" ";cout<<"\n";
	cout<<ans;
	return 0;
}
```

---

## 作者：Alexoip (赞：3)

## 换根 DP
看到此题容易想到用树形 DP，但是题目要求我们选择合适的初始节点，所以想到用换根 DP 解决。

令 $T$ 为以 $1$ 为根的树。

令 $f_u$ 为 $T$ 中，$u$ 子树燃烧的节点数量。容易得到转移方程：$f_u=\sum_{v \in son_u}\lbrace f_v \cdot [a_v<a_u] \rbrace$。  
$f$ 数组可对 $T$ 做一遍自下而上的 $dfs$ 求得。边界条件为 $f_{leaf}=1$。

令 $g_u$ 为选择 $u$ 为初始节点，燃烧的节点数量，即一颗根为 $u$ 的树 $T_u$ 的答案。  
则在 $T$ 中，以 $u$ 为根的子树的答案 $f_u$ 仍能贡献给 $g_u$。  
自上而下考虑 $u$ 子树外的部分，令 $p$ 为 $T$ 中 $u$ 的父亲。当 $a_p<a_u$ 时，其余部分可燃烧节点数为 $g_p$。  
故 $g_u=f_u+g_p \cdot [a_p<a_u]$，答案即为 $\max_{i=1}^n \lbrace g_i \rbrace $。

代码实现如下：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define i64 long long

const int maxn = 1e5 + 10;

int n, a[maxn];
vector<int> G[maxn];

int f[maxn];
void dfs(int u, int p) {
	f[u] = 1;
	for (int v : G[u]) {
		if (v == p) {
			continue;
		}
		dfs(v, u);
		f[u] += f[v] * (a[v] < a[u]);
	}
}

int g[maxn];
void change(int u, int p) {
	for (int v : G[u]) {
		if (v == p) {
			continue;
		}
		g[v] = f[v] + g[u] * (a[u] < a[v]);
		change(v, u);
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1, 0);
	g[1] = f[1];
	change(1, 0);
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		ans = max(ans, g[i]);
	}
	cout << ans << "\n";
	return 0;
}
``````
完结撒花！

---

## 作者：return_second (赞：3)

这道题算是比较水的。虽然题目里说的是树，但其实就是一个无向图。虽然赛后增加了难度，但加一个记忆化就行了。
# 题意

给你一个有 $n$ 个节点，$n-1$ 条边的无向图，每个节点都有一个权值 $a_i$。当节点 $i$ 与节点 $j$ 直接联通且满足 $a_i > a_j$ 时，节点 $i$ 就会引燃节点 $j$。求在合理选择初始节点的情况下，最多可以燃烧多少个节点。
# 思路

考虑使用循环枚举初始节点，再用 dfs 遍历图计算可以引燃的节点，再将这些答案取最大值即可。注意要用记忆化。

给出代码：
```cpp
#include<vector>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e5+5;
int n;
int a[N];
int dp[N];//记忆化数组 
vector<int>g[N];//使用邻接表储存图
int dfs(int k)//k指当前节点 
{
	if(dp[k])return dp[k];//如果计算过就返回 
	dp[k]=1;//点燃自己 
	for(int i:g[k])//遍历能到达的节点 
		if(a[k]>a[i])//如果符合要求 
			dp[k]+=dfs(i);//加上结果 
	return dp[k];
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
		//建图 
	} 
	//以上是输入
	int ans=0;
	for(int i=1;i<=n;i++)
		ans=max(ans,dfs(i));//取最大值
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Pollococido (赞：2)

$\operatorname{upd:2024/12/12}$ 加入第二份代码，增加说明。$\operatorname{Upd:2025/2/8}$ 修了格式和 $\LaTeX$。

### 题目大意

给定有 $n$ 个节点一棵树，点 $i$ 的权值为 $a_i$，可以引燃任意一个节点，节点着火后会蔓延到与他相连且权值小于他的节点，求最多能引燃多少节点。

### 思路 1

枚举点燃每个点能烧到的节点数，取最大即可，扩散用 dfs 实现，基本上是模板了。

### 代码 1

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, u, v, cur, ans = -1;
int a[100010];
bool vis[100010];
vector<int> g[100010];
void dfs(int x) {
	if (!vis[x]) cur++, vis[x] = true;
	for (auto c : g[x]) {
		if (a[c] < a[x]) dfs(c);
	}
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for (int i = 1; i <= n; i++) {
		cur = 0;
		memset(vis, false, sizeof vis);
		dfs(i);
		ans = max(ans, cur);
	}
	cout << ans;
	return 0;
}
```

---

但是！这份代码的时间复杂度为 $O(n^2)$，对于洛谷的数据，无法通过，所以我们要加入优化，也就是如果有一个点被遍历过，返回结果，否则则记录下结果。

### 思路 2

说一下代码步骤。

1. 读入。
2. 对每个点进行 dfs，需传入节点编号 $x$，过程如下：
   - 如果 $f$ 数组（记录答案的数组）不为 $0$，则直接返回。
   - 将 $f_x$ 设为 $1$，因为至少可以烧到一个节点（自己）。
   - 遍历跟 $x$ 连接的点，假设这个节点为 $c$，若可以引燃，则引燃，引燃后 $f_x \gets f_x + f_c$。
   - 取最大值，保存结果。
3. 遍历每一个点，进行 dfs。
   由于我们的记忆化，复杂度就变成了 $O(n)$，轻松通过。

### 代码 2

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, u, v, cur, ans = -1;
int a[100010], f[100010];
vector<int> g[100010];
void dfs(int x) {
	if (f[x]) return;
	f[x] = 1;
	for (auto c : g[x]) {
		if (a[c] < a[x]) dfs(c), f[x] += f[c];
	}
	ans = max(ans, f[x]);
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
	}
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for (int i = 1; i <= n; i++) {
		dfs(i);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：andycode (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11378)
# 思路讲解
题意已经描述得很清楚了，就不用再说了。

将 $1$ 号节点（当然其它节点也行）设为树的根节点，则不难发现，总共有两种扩张的方式，
+ 向子节点扩张
+ 向父节点扩张 

设 $f_i$ 为从节点 $i$ 开始燃烧，最多可以燃烧多少个节点。将这两种扩张方式依次解决即可。

首先，解决向子节点扩张的问题，即**统计从节点 $i$ 开始，向它的子节点扩张，最多能燃烧多少个节点**。

设节点 $i$ 的若干个子节点为 $b_{i,j}$，因为被燃烧的节点只会向权值严格小于自己权值的节点扩散，所以 $f_i$ 就等于所有权值严格小于自己权值的节点 $x$ 的 $f_x$ 之和再加上 $1$。  
即 $f_i=(\sum\limits_{a_{b_{i,j}}<a_{i}}^{}f_{b_{i,j}})+1$。

通过 `dfs` 进行统计即可，代码如下：

```cpp
void dfs1(int x){
	f[x]=1;//初始化f[x]为1
	int len=g[x].size();
	for(int i=0;i<len;i++)
		if(!deep[g[x][i]]){
			deep[g[x][i]]=deep[x]+1;//deep存储节点深度，后面会用到
			dfs1(g[x][i]);
			f[x]+=(a[g[x][i]]<a[x])*f[g[x][i]];//如果a[g[x][i]]<a[x]，加上f[g[x][i]]
		}
}
```
接下来解决向父节点扩张的问题。

我们 `dfs` 遍历这颗树。如果节点 $i$ 的一个子节点 $x$ 的权值大于 $a_i$，则说明如果节点 $x$ 燃烧，就能扩张到节点 $i$。所以 $f_x$ 就要再加上 $f_i$，因为节点 $i$ 不能扩散到节点 $x$，所以不会重复统计一些节点。

需要注意的是，此时 $f_i$ 所存储的值为从节点 $i$ 开始燃烧，顶多能扩散到多少个节点；而 $f_x$ 所存储的值为从节点 $x$ 开始燃烧，**在节点 $x$ 的子树中**，顶多能扩散到多少个节点。

代码如下：
```cpp
void dfs2(int x){
	int len=g[x].size();
	for(int i=0;i<len;i++)
		if(deep[g[x][i]]>deep[x] && a[g[x][i]]>a[x]){
		    //如果是节点x的子节点
		    if(a[g[x][i]]>a[x])
			    f[g[x][i]]+=f[x];
			//如果子节点的权值大于x的权值，则更新f[g[x][i]]
		    dfs2(g[x][i]);
        }
}
```
最终答案为所有 $f_i$ 中的最大值，即 $\max\limits_{i=1}^{n}f_i$。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,a[N],f[N],deep[N];
vector<int> g[N];
void dfs1(int x){
	f[x]=1;//初始化f[x]为1
	int len=g[x].size();
	for(int i=0;i<len;i++)
		if(!deep[g[x][i]]){
			deep[g[x][i]]=deep[x]+1;//deep存储节点深度，后面会用到
			dfs1(g[x][i]);
			f[x]+=(a[g[x][i]]<a[x])*f[g[x][i]];//如果a[g[x][i]]<a[x]，加上f[g[x][i]]
		}
}
void dfs2(int x){
	int len=g[x].size();
	for(int i=0;i<len;i++)
		if(deep[g[x][i]]>deep[x] && a[g[x][i]]>a[x]){
		    //如果是节点x的子节点
		    if(a[g[x][i]]>a[x])
			    f[g[x][i]]+=f[x];
			//如果子节点的权值大于x的权值，则更新f[g[x][i]]
		    dfs2(g[x][i]);
        }
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	deep[1]=1;
	dfs1(1);
	dfs2(1);
	int ans=0;
	for(int i=1;i<=n;i++)
		ans=max(ans,f[i]);//统计答案
	printf("%d",ans);
	return 0;
}
```
完结撒花！

---

## 作者：FJ_EYoungOneC (赞：2)

### 解题思路

首先，我们考虑暴力，枚举放火的点，对放火的点进行一次深度优先搜索计算能烧到的点，时间复杂度 $O(n^2)$，当数据如下时，会被卡掉。

```
1 <- 2 <- 3 <- 4 <- 5 <- 6 <- ...
```

我们发现，在对每一个点进行放火的过程中，可能存在一个点被多次计算的情况。例如在上述样例搜索的过程中，`dfs(5)` 会被 $4, 5, 6, \dots$ 各调用一次，效率低下。由于一个点可能被多次计算，考虑使用记忆化对深度优先搜索进行优化。

当一个点被遍历时：

- 若已经被遍历过，则直接返回结果。
- 反之，进行遍历并记录，以便下次调用。

时间复杂度 $O(n)$。

### AC_Code

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10, M = 2 * N;

int n;
int w[N];
int h[N], e[M], ne[M], idx;
int f[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int dfs(int u)
{
    if (~f[u])
        return f[u];
    int res = 1;
    for (int i = h[u]; ~i; i = ne[i] )
    {
        int j = e[i];
        if (w[u] > w[j])
            res += dfs(j);
    }
    f[u] = res;
    return f[u];
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; ++ i )
        cin >> w[i];
    
    memset(h, -1, sizeof h);
    for (int i = 1; i < n; ++ i )
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    
    memset(f, -1, sizeof f);
    int res = 0;
    for (int i = 1; i <= n; ++ i )
        res = max(res, dfs(i));
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：Cool_Windly (赞：1)

# 闲话
花了一个小时。

主要原因：条初始值硬控我半小时，题目看错硬控我半小时（悲）。

# 正文
看题目，就是求从哪个点出发所得到的所有单调下降序列的总长度最长（这个描述好奇怪，不过意思是对的）。

题目中说的是树，但其实可以当做图来做，因为题目中提到的是“节点”，而与父亲儿子节点无关，也就是说儿子节点也可以访问父亲节点。

大体思路：先输入，其中若有一条边 $(1,2)$，则在 $1$ 与 $2$ 的边中都要加入它，也就是当成无向图来做。

然后就是求最大值。

如何求最大值呢，其实每个点的最大值就是其所有值小于其本身的点的最大值的总和。然后再求每个点的最大值就可以了。

另外还要加个记忆化，记录每个点的答案的最大值，再打擂台即可 A。

总感觉我的方法过于非主流。

# AC 代码
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;//标准命名空间 
using ll = long long;//【不开longlong见祖宗】，当然这题随便 
const ll N=1e5+1;//n<=100000$ 
vector<ll> t[N];//存储节点、邻接点 
ll n,x,a,b;//临时输入变量
ll ans[N],last_ans;//存储答案

ll work(ll i)//计算编号为i的点的答案 
{
    ll not_all=1;//自己算一个节点 
    for(ll j=1;j<ll(t[i].size());++j)//循环访问与自己有边的节点 
        if(t[i][0]>t[t[i][j]][0])//严格小于 
        {
            if(!ans[t[i][j]]) ans[t[i][j]]=work(t[i][j]);//如果没有计算过就当场计算 
            not_all+=ans[t[i][j]];//加和计算 
        }
    return not_all;//返回该点的值 
}

int main()
{
    scanf("%lld",&n);//输入节点数 
    for(ll i=1;i<=n;++i)//是n个点 
    {
        scanf("%lld",&x);
        t[i].push_back(x);//存储自己的值 
    }
    for(ll i=1;i<n;++i)//注意是n-1条边，因为是树 
    {
        scanf("%lld%lld",&a,&b);
        t[a].push_back(b);//父亲节点与儿子节点 ，所以存储 
        t[b].push_back(a);//当成无向图处理 ，所以存储 
    }
    for(ll i=1;i<=n;++i)//计算n个点的答案 
		if(!ans[i])//如果在算其它点时没有算过再计算 
			ans[i]=work(i);//计算 
    for(ll i=1;i<=n;++i)//打擂台—— 
		last_ans=max(last_ans,ans[i]);//——求最大值 
    printf("%lld\n",last_ans);//输出 
    return 0;//完结撒花 
}
```

---

## 作者：chenxi2009 (赞：1)

# 思路
为什么要写动态规划？为什么要写动态规划？为什么要写动态规划？

[双倍经验](https://www.luogu.com.cn/problem/P1434)，但是是四连通图。

想必不用多说，这就是记忆化搜索板子，每个点为起点扩散的结点数只需要计算一次，就是所有相连的点中边权严格小于该点的点为起点可以到达的结点数加上这个点本身。时间复杂度 $O(n)$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],u,v,f[100001],ans;
vector<int>e[100001];
void sch(int u){
	if(f[u]) return;//记忆化 
	f[u] = 1;//这个点本身 
	for(auto v : e[u]) if(a[v] < a[u]) sch(v),f[u] += f[v];//所有可以扩散的点答案累加 
	ans = max(ans,f[u]);
}
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++) scanf("%d",&a[i]);
	for(int i = 1;i < n;i ++){
		scanf("%d%d",&u,&v);
		e[u].push_back(v),e[v].push_back(u);
	}
	for(int i = 1;i <= n;i ++) sch(i);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：tomAmy (赞：1)

本题解没有记忆化，只考虑以 $1$ 为根结点的树。

对于一个节点，它的可燃烧节点有两类。

令 $dp1_i$ 表示节点 $i$ 上面可燃烧节点的个数，代码如下。

```cpp
void dfs1(int x, int fa)
{
	if (a[x] > a[fa]) dp1[x] = dp1[fa] + 1;
	else dp1[x] = 1;
	for (int i = 0; i < v[x].size(); i++)
	{
		int y = v[x][i];
		if (y == fa) continue;
		dfs1(y, x);
	}
}
```

令 $dp2_i$ 表示节点 $i$ 下面可燃烧节点的个数，代码如下。

```cpp
void dfs2(int x, int fa)
{
	int ans = 1;
	for (int i = 0; i < v[x].size(); i++)
	{
		int y = v[x][i];
		if (y == fa) continue;
		dfs2(y, x);
		if (a[x] > a[y]) ans += dp2[y];
	}
	dp2[x] = ans;
}
```

~~完结撒花~~

提交后听取 wa 声一片。

自己画一棵树，容易发现：向上燃烧到的节点可以再向下燃烧，而向下燃烧的点无法向上燃烧，所以修改如下：

```cpp
void dfs1(int x, int fa)
{
	// 若a[x] > a[fa]，则fa向下烧不到子树x，故可以直接加上dp2[fa]。
	if (a[x] > a[fa]) dp1[x] = dp1[fa] + dp2[fa];
	else dp1[x] = 1;
	for (int i = 0; i < v[x].size(); i++)
	{
		int y = v[x][i];
		if (y == fa) continue;
		dfs1(y, x);
	}
}
```

贴上主函数：
```cpp
int main()
{
	a[0] = 1e9; // 使在求dp2[1]是初始得到1
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i < n; i++)
	{
		int x, y;
		cin >> x >> y;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dfs2(1, 0);
	dfs1(1, 0);
	int ans = 0;
	for (int i = 1; i <= n; i++)
		ans = max(ans, dp1[i] + dp2[i] - 1);
	cout << ans << endl;
	return 0;
}
```

记得点个赞再走~

---

## 作者：zyh1145 (赞：1)

[P11378 \[GESP202412 七级\] 燃烧](https://www.luogu.com.cn/problem/P11378)

---

思路：先随便设一个根，例如一号点。

然后分析题目，虽然我不会求「燃烧」的点的个数，但是，求以它为根的子树中「燃烧」的点的个数就简单了，用深搜即可。结合代码解释一下（令 $cnt_i$ 为以 $i$ 为根的子树中「燃烧」的点的个数）：

```cpp
void dfs(int u,int f)//这个函数的作用：求出 cnt[u] 。
{
	cnt[u] = 1;
	for (auto v : G[u])
	{
		if (v == f) continue;
		dfs(v,u);
		//因为这个函数的作用就是求出 cnt[ 这里的u ] ，即 cnt[v] 。
		//所以本行以后，我们都可以视作 cnt[v] 已经求好了。
		if (a[u] > a[v]) cnt[u] += cnt[v];
		//如果能烧过去，那么相加即可。如果不能烧过去，那么节点v以下的也别想了。
	}
} 
```

那么，已知 $cnt_i$，如何求 $ans_i$（以 $i$ 为起点时，「燃烧」的点的个数）呢？问题在于，如何处理不在子树中的部分，即从 $i$ 出发，向父节点 $fa$ 去烧的那部分火。

其实如果 $a_i \le a_{fa}$，那么根本烧不过去，即 $ans_i = cnt_i$。

如果能烧过去该咋求？把样例稍微改改分析一下：![](https://cdn.luogu.com.cn/upload/image_hosting/j3f69ih6.png)

不难发现，其实就是本身黄框中的（即 $cnt_i$），加上红框中以 $fa$ 为起点能「燃烧」到的（即 $ans_{fa}$。

于是这部分就会写了：

```cpp
void dfs2(int u,int f)
{
	if (a[u] <= a[f]) ans[u] = cnt[u];
	else ans[u] = cnt[f] + cnt[u];
	for (auto v : G[u])
	{
		if (v == f) continue;
		dfs2(v,u);
	}
}
```

最后求最大值即可。
完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
int n,a[N],cnt[N];
vector <int> G[N];
int ans[N],ANS = 1;
void dfs(int u,int f)
{
	cnt[u] = 1;
	for (auto v : G[u])
	{
		if (v == f) continue;
		dfs(v,u);
		if (a[u] > a[v]) cnt[u] += cnt[v];
	}
} 
void dfs2(int u,int f)
{
	if (a[u] <= a[f]) ans[u] = cnt[u];
	else ans[u] = ans[f] + cnt[u];
	for (auto v : G[u])
	{
		if (v == f) continue;
		dfs2(v,u);
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int u,v;
	cin>>n;
	for (int i = 1;i <= n;i++) 
	{
		cin>>a[i];
	}
	for (int i = 1;i <= n-1;i++)
	{
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1,1);
	dfs2(1,1);
	for (int i = 1;i <= n;i++) ANS = max(ANS,ans[i]);
	cout<<ANS;
	return 0;
} 
```

---

## 作者：xinxin2022 (赞：1)

结论题。

容易发现如果枚举起点，并对于每个节点搜索，时间复杂度为 $O(n^2)$。

考虑优化，搜索优化不外乎动态规划或记忆化，容易发现在不同节点搜索时总会搜到一些以前枚举过的起点时搜索过的点，因此记忆化每个点的答案。

因为只有严格小于时才会搜索，所以不用担心记忆化时加上已搜路径的答案。

若已搜过该点，加上该点答案即可，否则搜索并记忆化。

代码简单，记忆化模板，相信大家都写得出来。

---

## 作者：a18981826590 (赞：1)

# [P11378 [GESP202412 七级] 燃烧](https://www.luogu.com.cn/problem/P11378)
## 解题思路
这道题显然是搜索，但爆搜肯定是不行的，需要记忆化。

若节点 $A$ 可以向节点 $B$ 扩散，那么 $B$ 节点可以扩散到的节点显然也可以接着扩散下去，那么就不用再搜索下去了，直接使用 $B$ 节点所存储的 $B$ 节点可以扩散到的节点数即可。

这样每个节点只需要搜索一次，时间复杂度为 $O(n)$。

写代码时注意：
1. $1 \le n \le 10^{5}$，使用邻接表存储这棵树；
2. 若当前节点已有答案就不用接着搜索了；
3. 每个节点显然可以扩散到自己，记得将答案初始化为 $1$。
## [AC](https://www.luogu.com.cn/record/193911364) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010],b[100010],m,n,x,y;
vector<int>c[100010];
void dfs(int d){
	b[d]=1;
	for(int i=0;i<c[d].size();i++){
		if(a[d]>a[c[d][i]]){
			if(!b[c[d][i]]) dfs(c[d][i]);
			b[d]+=b[c[d][i]];
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<n;i++){
		cin>>x>>y;
		c[x].push_back(y);
		c[y].push_back(x);
	}
	for(int i=1;i<=n;i++){
		if(!b[i]) dfs(i);
		m=max(b[i],m);
	}
	cout<<m;
	return 0;
}
```

---

## 作者：fyc_LC (赞：1)

# 题解 P11378
[题目传送门](https://www.luogu.com.cn/problem/P11378)

### 先说一下朴素算法（暴搜）。
因为是无根树每次取一个点并计算能燃烧的最大个数。复杂度 $O(n^{2})$ 显然通不过。

### 优化一
考虑一下燃烧方向，由大值向小值燃烧，且若两值相等则这两点不会互相影响。故可以根据权值大小建立 $\text{DAG}$ (有向无环图）由大权值向小权值建边。为什么一定是呢？根据建图规则易得不存在 $a>b>c>a$ 即不存在环，所以建的图一定为 $\text{DAG}$ 。我们可以对此图入度为 $0$ 的进行 $\text{dfs}$ 统计个数。由于省略了一些无用起点所以时间复杂度为 $O(\displaystyle\frac{n^{2}}{4})$ 。在菊花图和反菊花图表现最好为 $O(n)$ 。

（具体证明方法蒟蒻作者不会）

此时在赛时已经可以通过水数据了。

### 优化二
可以很简单的想到每一个点的燃烧个数是确定的。故考虑将答案存下来用空间换时间，这时的时间复杂度降低到了 $O(n)$ 。可以通过此题。

### AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> v1[1006000];
int w[1000600],cnt[1000600],anc[10006000];//存答案 
int dfs(int a){
	if(anc[a]!=0){
		return anc[a];
	}
	int siz=v1[a].size();
	if(siz==0){
		anc[a]=1;
		return anc[a];
	}
	int sum=0;
	for(int i=0;i<siz;i++){
		sum+=dfs(v1[a][i]);
	}
	anc[a]=sum+1; 
	return sum+1;//统计个数 
}
int main(){
	int n;
	int u,v;
	cin>>n;
	int ans1=0;
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=1;i<n;i++){
		cin>>u>>v;
		if(w[u]<w[v]){
			swap(u,v);
		}
		if(w[u]==w[v]){//相等不影响 
			continue;
		}
		v1[u].push_back(v);
		cnt[v]++;
	}
	for(int i=1;i<=n;i++){
		if(cnt[i]==0){
			//cout<<"{"<<i<<"}"<<endl;
			ans1=max(dfs(i),ans1);
		}
	}
	cout<<ans1;
	return 0; 
}

```

---

## 作者：LG086 (赞：0)

题目意思很简单，就是求选定合适的起点后，最多可以烧几个节点。

因为火只会向权值更小的节点扩散，所以 $u,v$ 两点间的边可以看作是一条有向边。若 $a_u>a_v$，则该边是由 $u$ 到 $v$ 的；若 $a_v<a_u$，则是由 $v$ 到 $u$ 的一条边；若 $a_u=a_v$ 就不必理会。这样一个无向的树就变成了一个有向图。  
连好边之后，若直接在图上 DFS 求解，则时间复杂度较高。考虑记忆化。因为，以每个节点作为起点时，最多可以点燃的节点数唯一的。记 $ans_u$ 为以 $u$ 为起点时最多可以点燃的节点的数目，那么在 DFS 求解时，若此时的 $ans_u \ne 0$，则直接返回 $ans_u$ 即可。否则继续 DFS 直到此时的 $u$ 无路可走。更新并返回 $ans_u$ 时不要忘记节点 $u$ 本身也燃起来了。

核心代码：

```cpp
int dfs(int u){
  if(g[u].empty()){
  	ans[u]=1;
  	return 1;
  }
  if(ans[u]!=0)return ans[u];
  for(auto v : g[u]){
  	ans[u]+=dfs(v);
  }
  ans[u]++;
  return ans[u];
}
```

---

## 作者：Programming_Konjac (赞：0)

# 思路
首先建图。

然后遍历每一个点，计算每个点最多可以点燃的点，然后取最大值就可以了。

计算每个点最多可以点燃的点，就可以使用深度优先搜索进行搜索。

为了防止时超，我们还要加一个记忆化，因为每一次都有很多点进行重复计算，很影响时间，所以加上记忆化。

**本题坑点（自我认为）：无向图，所以要双向建边。**

时间复杂度：接近 $O(n)$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
vector<int> G[100005];
int dis[100005];
int a[100005],n;
int dfs(int u){
	int sum=1;
	for(int i=0;i<G[u].size(); i++){
		if(a[G[u][i]]<a[u]){
			if(dis[G[u][i]]){
				sum+=dis[G[u][i]];
			}
			else{
				sum+=dfs(G[u][i]);
			}
		}
	}
	return dis[u]=sum;
}
int main(){
	cin>>n;
	for(int i=1; i<=n; i++){
		cin>>a[i];
	}
	for(int i=1; i<n; i++){
		int u,v;
		cin>>u>>v;
		G[u].pb(v);
		G[v].pb(u);
	}
	int Max=1;
	for(int i=1; i<=n; i++){
		Max=max(Max,dfs(i));
	}
	cout<<Max;
	return 0;
}
```

---

## 作者：Ekin123 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P11378)

## 思路

### No.1 直接爆搜

遍历 $i = 1 \to n$，依次爆搜，随后取最大值。

显然，时间复杂度 $O(n^2)$，无法通过此题。

代码略。

### No.2 记忆化搜索

开一个数组。

```cpp
long long r[100005];
```

用于记录答案。这题不像 [P2921](https://www.luogu.com.cn/problem/P2921)，只需记录从 $i$ 点出发到其他点，没有多余的细节。

因为每个点只会经过一次（若重复经过直接返回已存储的答案），所以时间复杂度为 $O(n)$。

Talk is cheap,show me your CODE.

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector> 
using namespace std;

int a[100005];

vector<int> e[100005];

bool vis[100005];

long long r[100005];

long long dfs(int u)
{
	vis[u] = 1;
	if(r[u])
	{
		vis[u] = 0;
		return r[u];
	}
	long long sum = 1;
	for(auto v : e[u])
	{
		if(vis[v] == 0 && a[v] < a[u]) sum += dfs(v);
	}
	vis[u] = 0;
	return (r[u] = sum);
}

int main()
{
	int n;
	cin >> n;
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	for(int i = 1;i < n;i++)
	{
		int u,v;
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	long long ans = -9e18;
	for(int i = 1;i <= n;i++)
	{
		ans = max(dfs(i),ans);
	}
	cout << ans << endl;
	return 0;
} 
```

---

## 作者：Statax (赞：0)

## 思路

这题思路一眼丁真啊。

注意到，如果 $x$ 引燃了 $y$，那么答案一定是 $x > y$。

所以之前搜索到的点就不用再重复搜索。

但现在复杂度还是爆炸，不过加上记忆化本题就轻松过了。

## 代码

时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;
constexpr int MAXN = 1e5 + 5;
constexpr int INF = 0x3f3f3f3f;

int n, ans;
int w[MAXN];
int memo[MAXN];
vector <int> g[MAXN];
struct Node { 
	int idx, wei; 
	bool operator < (const Node & b) const {
		return wei > b.wei;
	}
} node[MAXN];

int dfs (int now) {
	memo[now] = 1;
	for (const auto &it : g[now]) 
		if (w[it] < w[now]) {
			if (!memo[it]) 
				memo[now] += dfs(it);
			else 
				memo[now] += memo[it];
		}
	return memo[now];
}

signed main () {
	cin >> n;
	for (int i = 1; i <= n; ++i) 
		cin >> w[i], node[i] = {i, w[i]};
	sort(node + 1, node + n + 1);
	for (int i = 1, u, v; i < n; ++i) {
		cin >> u >> v;
		g[u].emplace_back(v);
		g[v].emplace_back(u);
	} for (int i = 1; i <= n; ++i) 
		if (!memo[node[i].idx])
			ans = max(ans, dfs(node[i].idx));
	
	cout << ans << endl;
	return 0;
}
```

---


# [GESP202412 八级] 树上移动

## 题目描述

小杨有一棵包含 $n$ 个节点的树，其中节点的编号从 $1$ 到 $n$，每个节点的颜色要么是白色要么是黑色，小杨可以任意选择节点 $s$ 和节点 $t$ 并从节点 $s$ 出发移动到节点 $t$，移动过程中小杨不能够经过重复节点。

小杨希望自己在至多经过 $k$ 个黑色节点的前提下，经过的总节点数尽可能多，请你帮小杨选择经过最多的节点数是多少。

## 说明/提示

| 子任务编号 | 数据点占比 |     $n$     | $k$         |     特殊性质     |
| :--------: | :--------: | :---------: | ----------- | :--------------: |
|    $1$     |   $20\%$   | $\leq 100$  | $\leq 100$  | 树的形态为一条链 |
|    $2$     |   $20\%$   | $\leq 1000$ | $0$         |                  |
|    $3$     |   $60\%$   | $\leq 1000$ | $\leq 1000$ |                  |


对于全部数据，保证有 $1\leq n\leq 1000$，$0\leq k\leq 1000$，$0\leq a_i\leq 1$。

## 样例 #1

### 输入

```
5 1
0 0 1 1 1
1 2
2 3
2 5
1 4```

### 输出

```
3```

# 题解

## 作者：ZPB2011 (赞：17)

# 树上移动

## 前言

~~为啥题解都那么复杂啊~~

## 思路

在看到数据大小后剋发现 $n$ 非常的小，于是可以考虑一个非常暴力的算法。

可以直接对每个点做一次 `dfs`，算出每个点可以到的最远的点，取最大值即可。

## AC code

```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 1e3 + 5;

int n, k, maxn, col[N];
vector<int> g[N];

void dfs(int u, int fa, int cnt1, int cnt2) {
	if(cnt2 > k) return;//比k大了 
	maxn = max(maxn, cnt1);
	for(int i = 0; i < g[u].size(); i++) {
		int v = g[u][i];
		if(v != fa) {
			if(col[v] == 1) dfs(v, u, cnt1 + 1, cnt2 + 1);
			else dfs(v, u, cnt1 + 1, cnt2);
		}
	} 
}

int main() {
	cin >> n >> k;
	for(int i = 1; i <= n; i++) cin >> col[i];
	for(int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for(int i = 1; i <= n; i++) {//暴力遍历 
		if(col[i] == 1) dfs(i, 0, 1, 1);
		else dfs(i, 0, 1, 0);
	}
	cout << maxn << endl;
	return 0;
}
```

---

## 作者：Cute__yhb (赞：7)

## 思路

点分治好题怎么能不用点分治做呢？

其实这题有原，是 SP1825。

考虑 calc 怎么写。

首先，求出以当前节点为根时每个子节点到当前子树内其他节点的距离，以及路径上的黑点数。

然后，对于每一条路径，设当前经过 $x$ 个节点。

那么，只要找出其他路径中经过的黑点不超过 $x-k$ 的路径的长度的最大值，当前路径的答案就是它加上这条路径的长度。

最大值用树状数组维护一下就行。

## 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define F(i,l,r) for(int i=l;i<=r;i++)
#define UF(i,r,l) for(int i=r;i>=l;i--)
#define p_q priority_queue
#define pb push_back
#define mk make_pair
#define pii pair<int,int> 
#define ve vector
#define endl '\n'
#define fi first
#define se second
#define INF 0x3f3f3f3f
#define lowbit(x) (x&(-x))
int n,k,m,root=0,col[200005],tot=0,c[200005],vis[200005],siz[200005],cnt[200005],ans,mx[200005],dis[200005];
ve<pii>a[200005];
void add(int x,int y){
	for(int i=x;i<=k+1;i+=lowbit(i)) cnt[i]=max(cnt[i],y);
}
void readd(int x){//删除一条路径
	for(int i=x;i<=k+1;i+=lowbit(i)) cnt[i]=0;
}
int getmx(int x){
	int maxx=0;
	for(int i=x;i;i-=lowbit(i)) maxx=max(maxx,cnt[i]);
	return maxx;
}
void getrt(int x,int fa,int si){
	siz[x]=1;
	mx[x]=0;
	for(int i=0;i<a[x].size();i++){
		int y=a[x][i].fi;
		if(vis[y]||y==fa) continue;
		getrt(y,x,si);
		siz[x]+=siz[y];
		mx[x]=max(mx[x],siz[y]);
	}
	mx[x]=max(mx[x],si-siz[x]);
	if(!root||mx[x]<mx[root]){
		root=x;
	}
}
void getdis(int x,int fa,int di,int cn){
	if(cn>k) return ;
	dis[++tot]=di;
	c[tot]=cn;
	for(int i=0;i<a[x].size();i++){
		int y=a[x][i].fi,z=a[x][i].se;
		if(y==fa||vis[y]) continue;
		getdis(y,x,di+z,cn+col[y]);
	}
}
void calc(int x){
	tot=0;
	int last=0;
	for(int i=0;i<a[x].size();i++){
		int y=a[x][i].fi,z=a[x][i].se;
		if(vis[y]) continue;
		getdis(y,x,z,col[y]+col[x]);
		for(int j=last+1;j<=tot;j++){
			ans=max(ans,dis[j]+getmx(k-c[j]+1+col[x]));
		}
		for(int j=last+1;j<=tot;j++) add(c[j]+1,dis[j]);
		last=tot;
	}
	for(int i=1;i<=tot;i++) readd(c[i]+1);
}
void solve(int x,int fa){
	vis[x]=1;
	calc(x);
	for(int i=0;i<a[x].size();i++){
		int y=a[x][i].fi;
		if(y==fa||vis[y]) continue;
		root=0;
		getrt(y,x,siz[y]);
		solve(root,x);
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>col[i];
	for(int i=1;i<n;i++){
		int x,y,z;
		cin>>x>>y;
		a[x].pb(mk(y,1));//长度为1
		a[y].pb(mk(x,1));
	}
	getrt(1,0,n);
	solve(root,0);
	cout<<ans+1;
    return 0;
}
```

---

## 作者：FJ_EYoungOneC (赞：6)

### 解题思路

首先，我们考虑暴力，枚举第一个点 $a$，枚举第二个点 $b$，再从 $a$ 开始进行一次深度优先搜索，时间复杂度 $O(n^3)$。

我们发现，在 $a$ 的深度优先遍历中，会便利到每个点，那么一次搜索就可以涵盖以 $a$ 为其中一个点的情况。所以，我们仅需对每个点进行一次深度优先搜索即可。

接下来考虑如何进行搜索，由于经过的 $1$ 的数量不得超过 $k$，我们需要计算的是 $0$ 与 $1$ 的总和，那么我们可以维护一个 $cnt0, cnt1$，表示搜索过程中 $0$ 的数量以及 $1$ 的数量。当 $1$ 的数量超过 $k$ 时，即表示搜索完成，由于再搜索下去 $1$ 的个数一定大于 $k$，返回 $cnt0 + cnt1 - 1$ 即可，$-1$ 是由于当前 $1$ 的数量已经超过 $k$，故需要返回上一步。

时间复杂度 $O(n^2)$。

### AC_Code

```c
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e3 + 10, M = 2 * N;

int n, m;
int h[N], e[M], ne[M], idx;
int w[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int dfs(int u, int fa, int cnt0, int cnt1)
{
    if (cnt1 > m)
        return cnt0 + cnt1 - 1;
    int res = cnt0 + cnt1;
    for (int i = h[u]; ~i; i = ne[i] )
    {
        int j = e[i];
        if (j == fa)
            continue;
        if (w[j])
            res = max(res, dfs(j, u, cnt0, cnt1 + 1));
        else
            res = max(res, dfs(j, u, cnt0 + 1, cnt1));
    }
    return res;
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i )
        cin >> w[i];
    
    memset(h, -1, sizeof h);
    
    for (int i = 1; i < n; ++ i )
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    
    int res = 0;
    for (int i = 1; i <= n; ++ i )
        res = max(res, dfs(i, -1, w[i] == 0, w[i]));
    
    cout << res << endl;
    
    return 0;
}
```

---

## 作者：LastKismet (赞：3)

# 前言
我可能是为数不多的初三还在打这个的蒟蒻了吧。
# 思路
一眼树上动规，GESP 真的很爱考树上问题、黑白点、小杨。

首先一个状态就是以当前节点为根节点的子树中最长的满足条件的路径数。

考虑如何更新这个状态，发现只存在两种情况：某一棵子树内的答案，以及**两棵子树的最长向上连接到当前节点的链的长度之和加一。**

情况一不用解释，关于情况二，其实就是找出一条最长的、经过根节点的且进入两棵子树的链。

然后考虑还有一种特殊情况，也就是一条子树向上的最长链的长度加一。也就是以当前节点为一个端点的一条链。

到这里就自然想到第二个状态：以当前节点为一个端点的当前子树内最长满足条件的链的长度。

然后我们发现“满足条件”是个很宽泛的性质，不太好解决，发现 $k\le 1000$，于是考虑状态加一维，表示经过 $j$ 个黑色点的答案。

这样状态更新的复杂度会多出一个 $k$，但显然复杂度很对。你也可以加一些优化，像前缀和或者判断当前子树内总共的黑色节点数之类。

这样就完成了。

我认为动态规划类问题着重的是思想，并且这道题实现简单，所以代码是不必要的。~~以及太懒了。~~

---

## 作者：Bright12077 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11379)

## 思路
### 暴力
拿到题目，我们可以先思考暴力。

题目中说需要在图上选择一个起点 $s$ 和终点 $t$，因此我们不难想到可以先用两层循环枚举起点和终点，再判断从 $s$ 到 $t$ 的路径是否合法。

复杂度 $\mathcal{O}(n^3)$，预期得 $20$pts。

***

### 正解
我们不难注意到，题目是在树上进行的，所以我们也不难想到搜索。

对于一个起点搜索时，所有终点都会被访问到，因此我们只需要枚举起点即可，无需判断终点。

如果用广搜会比较麻烦，因为对于从起点到不同节点所访问过的节点不同，这意味着在每一个节点的结构体里都需要一个标记数组，因此我在这里选择了用深搜。

***

深搜的函数传参有这几个：
1. ```cur```：当前节点编号。
2. ```pass_all```：经过的节点个数。
3. ```pass_black```：经过的黑色节点个数。

向下传递时，很显然 ```pass_all``` 需要增加 $1$，```pass_black``` 在下一个节点为黑色是需要增加。

同样，也需要判断下个节点是否被访问过以及到了下一个节点后 ```pass_black``` 会不会超过 $k$。

最终，我们就可以得到代码了。

## 代码

赛时の $\color{green}\texttt{AC}$ 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef unsigned __int128 u128;
typedef __int128 i128;
int n,k;
vector<int> G[114514];//邻接表存图
int a[114514];//颜色
int ans=0;
bool v[114514];
void dfs(int cur,int pass_all,int pass_black){
	ans=max(ans,pass_all);//记录答案
	for(int i:G[cur]){
		if(v[i])continue;
		if(pass_black+a[i]>k)continue;//两个特判
		v[i]=true;
		dfs(i,pass_all+1,pass_black+a[i]);
		v[i]=false;
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);//无向图
	}
	for(int i=1;i<=n;i++){
		v[i]=true;
		dfs(i,1,a[i]);
		v[i]=false;
	}
	cout<<ans;
	return 0;
}

```
时间复杂度 $\mathcal{O}(n^2)$。

这次 GESP 真的好氵啊，半小时切两题。我考七级的时候还放了两个绿题，估计这次两个水黄就是对我的安慰吧。

---

## 作者：szh_AK_all (赞：2)

## 分析
观察 $n,k$ 的范围，发现这题十分好做，考虑枚举所选路径的端点 $s,t$，然后看着条路径上的黑色节点数是否不超过 $k$，如果不超过 $k$，则用这条路径的长度更新我们所记录的答案。

我们需要清楚的是，两个节点间的路径即为这两个节点分别到达根节点的路径的并集减去这两个节点的最近公共祖先到达根节点的路径。

那么如何求一条路径的长度及黑色节点数呢？首先一条由 $x$ 到 $y$ 的路径长度显然是 $dis_x+dis_y-2\times dis_l+1$，其中 $dis_i$ 表示 $i$ 到达根节点路径的长度，$l$ 表示 $x,y$ 的最近公共祖先。由此推广到如何求一条路径中黑色节点数量，设 $s_i$ 表示 $i$ 到达根节点路径中黑色节点数量的长度，那么由 $x$ 到 $y$ 的路径中黑色节点数量为 $s_x+s_y-2\times s_l+a_l$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int s[1005], a[1005], dis[1005], fa[1005][15];
vector<int>g[1005];

void dfs(int x, int f) {
	dis[x] = dis[f] + 1;
	s[x] = s[f] + (a[x] == 1);
	fa[x][0] = f;
	for (int i = 1; i <= 10; i++)
		fa[x][i] = fa[fa[x][i - 1]][i - 1];
	for (int y : g[x]) {
		if (y == f)
			continue;
		dfs(y, x);
	}
}

int lca(int x, int y) {
	if (dis[x] < dis[y])
		swap(x, y);
	for (int i = 10; i >= 0; i--)
		if (dis[fa[x][i]] >= dis[y])
			x = fa[x][i];
	if (x == y)
		return x;
	for (int i = 10; i >= 0; i--)
		if (fa[x][i] != fa[y][i])
			x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

int main() {
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1, 0);
	int ans = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			int l = lca(i, j);
			int hei = s[i] + s[j] - 2 * s[l] + (a[l] == 1);
			if (hei <= k)
				ans = max(ans, dis[i] + dis[j] - 2 * dis[l] + 1);
		}
	}
	cout << ans;
}
```

---

## 作者：xinxin2022 (赞：1)

送分题，场上不到半分钟看出了结论，不到十分钟通过。

## 小数据

容易根据题面~~被拉进坑~~想出枚举 $s$ 和 $t$，然后深搜判断是否可行，如果可行则与当前答案比较，较大则更新。

枚举 $s$ 为 $O(n)$，枚举 $t$ 为 $O(n)$，深搜判断为 $O(n)$，总时间复杂度为 $O(n^3)$。

## $k=0$

相当于不能经过黑节点，考虑用黑节点将树转化为多个子树，枚举每棵子树的节点并深搜该子树，找出深度最深的子树。

枚举节点为 $O(n)$，深搜为 $O(n)$ ，总时间复杂度为 $O(n^2)$。

## 正解

推广 $k=0$ 时的做法，枚举起点作为树的根，深搜找到最深能到达的深度，用深度更新答案。

枚举起点为 $O(n)$，深搜为 $O(n)$，总时间复杂度为 $O(n^2)$。

代码就不放了，相信大家学会了都能写得出来。

---

## 作者：zhang_kevin (赞：1)

由于两点之间合法路径唯一，故我们令 $f_{i,j}$ 表示 $i$ 到 $j$ 之间的路径上黑色点的个数，$dis_{i,j}$ 表示 $i$ 到 $j$ 之间的距离。

答案就是对于所有 $\leq k$ 的 $f_{i,j}$，求 $dis_{i,j}$ 的最大值。

显然进行 $n$ 次 $\mathcal{O}(n)$ 的 dfs 可以求出所有 $dis_{i,j}$，下面考虑求 $f$。

设以 $i$ 为根节点时，$u$ 的父亲为 $fa$。显然有 $f_{i,u} = f_{i,fa} + c_u$，其中 $c_u$ 表示 $u$ 的颜色，黑色为 $1$，白色为 $0$。

有了这个式子，我们就可以枚举所有根节点，然后对于所有根节点都跑一遍 dfs 解决问题。

时间复杂度 $\mathcal{O}(n^2)$。

 ```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x<<1) + (x<<3) + (ch^48);
		ch = getchar();
	}
	return x * f;
}
int n, k, c[1001], f[1001][1001], dis[1001][1001];
vector<int> e[1001];
inline void dfs(int start, int u, int fa){
	f[start][u] = f[start][fa] + c[u];
	dis[start][u] = dis[start][fa] + 1;
	for(auto v : e[u]){
		if(v != fa){
			dfs(start, v, u);
		}
	}
	return;
}
signed main(){
	n = read(), k = read();
	for(int i = 1; i <= n; i++) c[i] = read();
	for(int i = 1; i < n; i++){
		int u = read(), v = read();
		e[u].push_back(v);
		e[v].push_back(u);
	}
	for(int i = 1; i <= n; i++) dfs(i, i, 0);
	int ans = 0;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			if(f[i][j] <= k){
				ans = max(ans, dis[i][j]);
			}
		}
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：N0_1 (赞：1)

### 题意
给定 $n$ 个点，$n-1$ 条边的树，每个节点都有对应的颜色，$0$ 表示白色，$1$ 表示黑色，你可以任意选择节点 $s$ 和节点 $t$ 并从节点 $s$ 出发移动到节点 $t$，移动过程中不能够经过重复节点。请问你在经过不超过 $k$ 个黑色节点的前提下，最多能经过多少个节点。

### 分析
考虑以下这张图：

![图示](https://cdn.luogu.com.cn/upload/image_hosting/htmd5dc9.png) 

假如我们在求解 $u=6,v=5$ 这一条路径上的信息（经过了多少个黑色的节点，一共有多少个点）。

令 $col_i$ 为节点 $i$ 的颜色，$num_i$ 表示从根节点 $1$ 出发，到 $i$ 的路径上有多少个黑色节点，不难得出一个递推式：
$$num_i = num_{fa} + [col_i == 1]$$

不难得出 $u=6,v=5$ 这一条路径上黑色节点的数量为：
$$num_6 + num_5 - 2 \times num_2 + [col_2 == 1]$$ 

其中 $num_6$ 为上图中红色线，$num_5$ 为上图中蓝色线，$2 \times num_2$ 为上图中橙色线。

即 $u,v$ 两点间黑色节点的数量为：
$$num_u + num_v - 2 \times num_{lca(u, v)} + [col_{lca(u,v)} == 1]$$

其中 $lca(u, v)$ 表示 $u,v$ 的最近公共祖先。

令 $dis_i$ 为从根节点出发到节点 $i$ 的距离。

同理，$u,v$ 之间的节点数量为 $dis_u + dis_v - 2 \times dis_{lca(u, v)} + 1$。当然，这一步你也可以通过倍增 LCA 的思想在 $O(\log n)$ 的时间内计算，也可以在 `dfs` 的过程中预处理（具体看代码）。

最后 $O(n^2)$ 枚举 $u,v$ 求最大值即可。

### code

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e3 + 10;

int fa[N][20];
vector<int> g[N];
int num1[N], col[N], LOG2[N], dep[N], ds[N];

void dfs(int u, int father) {
    num1[u] = num1[father] + col[u];    
    fa[u][0] = father;
    dep[u] = dep[father] + 1;
    ds[u] = ds[father] + 1;

    for (int i = 1; i <= LOG2[dep[u]]; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }

    for (int v : g[u]) {
        if (v != father) dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);

    while (dep[u] > dep[v]) {
        int k = LOG2[dep[u] - dep[v]];
        u = fa[u][k];
    }
    if (u == v) return u;

    for (int i = LOG2[dep[u]]; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i], v = fa[v][i];
        }
    }
    return fa[u][0];
}

int dis(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);

    int d = 0;
    while (dep[u] > dep[v]) {
        int k = LOG2[dep[u] - dep[v]];
        d += (1 << k);
        u = fa[u][k];
    }
    if (u == v) return d;

    for (int i = LOG2[dep[u]]; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i]; v = fa[v][i];
            d += 2 * (1 << i);
        }
    }
    return d + 2;
}

int main() {
    LOG2[0] = -1;
    for (int i = 1; i < N; i++) LOG2[i] = LOG2[i >> 1] + 1;

    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> col[i];

    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        g[u].emplace_back(v);
        g[v].emplace_back(u);
    }
    dfs(1, 0);

    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = i; j <= n; j++) {
            int father = lca(i, j);
            
            int cnt = num1[i] + num1[j] - 2 * num1[father] + col[father];
			 // if (cnt <= k) ans = max(ans, dis(i, j) + 1); // lca 的思想求两点之间距离
            if (cnt <= k) ans = max(ans, ds[i] + ds[j] - 2 * ds[father] + 1);
        }
    }
    cout << ans << '\n';
    
    return 0;
}

---

## 作者：chenxi2009 (赞：1)

# 思路
$n\le 1000$，考虑枚举起点遍历树，时间复杂度 $O(n^2)$。

在遍历的过程中记录经过的点数、经过的黑点数，如果黑点数 $\le k$ 就把经过的点数计入答案，对所有的答案取最大值就是最终的答案。
# 代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,k,a[1001],u,v,ans;
vector<int>e[1001];
void sch(int u,int fa,int cnt,int cntc){//cnt 为总共经过的边数，cntc 为经过的黑点数 
	if(cntc <= k) ans = max(ans,cnt);
	for(auto v : e[u]) if(v != fa) sch(v,u,cnt + 1,cntc + a[v]);//防止走回头路；走到 v 时总点数 +1，黑点数根据 v 的颜色决定是否 +1 
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i = 1;i <= n;i ++) scanf("%d",&a[i]);
	for(int i = 1;i < n;i ++){
		scanf("%d%d",&u,&v);
		e[u].push_back(v),e[v].push_back(u);//vector 存图 
	}
	for(int i = 1;i <= n;i ++) sch(i,0,1,a[i]);
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：Lcm_simida (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P11379)

思路：由于经过的点不可重复，所以 $s$ 和 $t$ 之间的路程肯定是 $s$ 到**最近公共祖先**，再到 $t$ 的。因为若再往**最近公共祖先**的父节点走去，就必须原路返回，便经过了重复的点。所以只需要枚举 $s$ 和 $t$ 的同时用倍增来找**最近公共祖先**即可。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1005],f[1005][30],sum[1005][30],d[1005],ans=0;
vector<int> v[1005];
void dfs(int x,int fa,int g){
	d[x]=g;
	f[x][0]=fa;
	if(a[x]==1) sum[x][0]++;
	for(int i=1;(1<<i)<g;i++) f[x][i]=f[f[x][i-1]][i-1],sum[x][i]=sum[x][i-1]+sum[f[x][i-1]][i-1];
	for(int i=0;i<v[x].size();i++){
		if(v[x][i]==fa) continue;
		dfs(v[x][i],x,g+1);
	}
}
int main(){
//	ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];if(a[i]<=m) ans=max(ans,1);
	}
	for(int i=1,j,k;i<n;i++){
		cin>>j>>k;v[j].push_back(k);v[k].push_back(j);
	}
	dfs(1,0,1);
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			int x=i,y=j,cnt=0;
			if(d[x]<d[y]) swap(x,y);
			int cc=log2(d[x]-d[y])+1,num=d[x]-d[y];
			while(cc>=0){
				if(num>=(1<<cc)){
					cnt+=(sum[x][cc]),num-=(1<<cc);
					x=f[x][cc];
				}
				cc--;
			}
			cc=log2(n)+1;
			while(cc>=0){
				if(f[x][cc]!=f[y][cc]){
					cnt+=(sum[x][cc]+sum[y][cc]);
					x=f[x][cc],y=f[y][cc];
				}
				cc--;
			}
			if(x!=y){
				cnt+=(sum[x][0]+sum[y][0]);x=f[x][0],y=f[y][0];
			}
			if(cnt+a[x]<=m){
				ans=max(ans,d[j]+d[i]-2*d[x]+1);
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Roy_2010 (赞：0)

# [GESP202412 八级] 树上移动 题解
## 题外话
考场上看到 $O(n^2 \log{n})$ 可以做就直接冲上去了，后来发现有 $O(n^2)$ 做法而且似乎更简单呢。
## 算法
首先思路很显然，枚举起点和终点。\
那么就只要求两个东西：两点间距离以及两点间路径上黑点个数。\
两点间距离很好解决，运用两点深度及两者最近公共祖先的深度即可。\
两点间路径上黑点个数呢？我们利用前缀和的知识，统计一个节点到根节点的黑点数之和。然后利用两节点及它们的最近公共祖先即可求出。\
二者公式在代码中均有标出。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,k;
struct Node{
	int f,t,nxt;
	Node(){}
	Node(int _f,int _t,int _n):f(_f),t(_t),nxt(_n){} 
}mp[2050];
int clr[2050];
int Head[2050],cnt=0;
void Add(int _f,int _t){
	mp[++cnt]=Node(_f,_t,Head[_f]);
	Head[_f]=cnt;
}
//建树 

int fa[1050],dep[1050],sum[1050];
//fa[i]    i 的父亲 
//dep[i]   i 的深度 
//sum[i]   i 到根节点的路径上的黑色节点数 

void dfs(int x){
	sum[x]=sum[fa[x]]+clr[x];
	dep[x]=dep[fa[x]]+1;
	for(int i=Head[x];i;i=mp[i].nxt){
		if(mp[i].t==fa[x]){
			continue;
		}
		fa[mp[i].t]=x;
		dfs(mp[i].t);
	}
}
//dfs

//
int st[11][1050];
void Pre_LCA(int x){
	st[0][x]=fa[x];
	for(int i=1;i<11;++i){
		st[i][x]=st[i-1][st[i-1][x]];
	}
	for(int i=Head[x];i;i=mp[i].nxt){
		if(mp[i].t==fa[x]){
			continue;
		}
		Pre_LCA(mp[i].t);
	}
}
int LCA(int x,int y){
	if(dep[x]<dep[y]){
		swap(x,y);
	}
	for(int i=10;i>=0;--i){
		if(dep[st[i][x]]>=dep[y]){
			x=st[i][x];
		}
	}
	if(x==y){
		return y;
	}
	for(int i=10;i>=0;--i){
		if(st[i][x]!=st[i][y]){
			x=st[i][x];
			y=st[i][y];
		}
	}
	return st[0][x];
}
//LCA 模板 

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i){
		cin>>clr[i];
	}
	for(int i=1;i<n;++i){
		int f,t;
		cin>>f>>t;
		Add(f,t);
		Add(t,f);
	} 
	dfs(1); 
	Pre_LCA(1);
	int ans=0;
	for(int i=1;i<=n;++i){
		for(int j=i;j<=n;++j){
			//在树上 i 到 j 的路径与 j 到 i 的路径并无区别
			int Index=LCA(i,j);
			if(sum[i]+sum[j]-2*sum[Index]+clr[Index]<=k){
				//公式2 判断语句注意加上最近公共祖先 
				ans=max(ans,dep[i]+dep[j]-2*dep[Index]+1);
				//公式1 点的个数不是距离，注意加一 
			}  
		}
	}
	cout<<ans<<'\n';
	return 0;
} 
 
```

---

## 作者：lcfollower (赞：0)

水。

---

首先你可以枚举 $s$ 和 $t$。

记 $f_i$ 表示根节点到 $i$ 的简单路径上的**黑色**节点数量，$g_i$ 表示根节点到 $i$ 的简单路径上的节点数量。

那么答案就是 $\max\limits_{s,t\le n ,s\ne t} { \left(f_s + f_t - f_l \le k\right) \times \left(g_s + g_t - g_l\right)}$，其中 $l$ 表示 $s$ 和 $t$ 的最近共公祖先。画个图就可以明白了。

用倍增做 LCA 的话时间复杂度为 $\mathcal (n^2\log n)$，可以通过。

---

当然还有更简单的方法。

首先枚举起点 $s$。

然后搜索整张图，找到每一个合法的 $t$，统计答案比最大值就可以了。

找到合法的 $t$ 的时间复杂度就是遍历整棵树，时间复杂度为 $\mathcal O(n^2)$，可以通过。

```cpp
# include <bits/stdc++.h>

# define int long long

using namespace std;

const int N = 1005;
int n ,k ,ans ,col[N];
vector <int> edge[N];

inline void dfs (int u ,int fath ,int sum ,int res){
//u：当前节点；fath：父亲节点；sum：路径上黑色节点数量；res：路径上节点数量。
//这里默认选中起点 i 为根节点。

  if (sum > k) return ;

  ans = max (ans ,res);
  
  int len = edge[u].size ();

  for (int i = 0 ; i < len ;i ++){
    int v = edge[u][i];
    if (v == fath) continue;
    dfs (v ,u ,sum + col[v] ,res + 1);
  }
} signed main (){
  cin >> n >> k;
  for (int i = 1 ; i <= n ;i ++) cin >> col[i];

  for (int i = 1 ; i < n ; i ++){
    int u ,v;
    cin >> u >> v;
    edge[u].push_back (v) ;
    edge[v].push_back (u) ;//存图。
  }

  for (int i = 1 ; i <= n ;i ++)
    dfs (i ,0 ,col[i] ,1);//搜索。

  cout << ans << endl;
  return 0;
}
```

---


# [迷宫寻路 Round 3] 挂掉的模板

## 题目背景

**upd : [2025/1/27] Hack 数据已添加。**

某人把 LCA 板子写挂了，然后就有了这道题。

## 题目描述

有一颗 $n$ 个节点的有根树。

定义 `FakeLCA` 函数代码如下：

```cpp
int FakeLCA(int u, int v) {
	while (u != v) u = fa[u], v = fa[v];
	return u;
}
```

其中 `fa[i]` 表示节点 $i$ 的父节点，**特别的，根的父节点是根本身。**

现在给定节点数 $n$ 和每个节点的父节点，问有多少个有序数对 $(u,v)$，满足 $1\le u,v\le n$ 且 `FakeLCA(u, v)` 的结果是 $u$ 和 $v$ 的真正的最近公共祖先。

## 说明/提示

**提示：请仔细阅读题目中关于根的说明，根节点不一定是 1 号点！**

**本题采用捆绑测试。**

对于所有数据，$1\le n\le 10^6$。

| 子任务编号 | $n\leq$ | 分数 |
| :----------: | :----------: | :----------: |
| $0$ | $100$ | $25$ |
| $1$ | $1000$ | $25$ |
| $2$ | $7000$ | $25$ |
| $3$ | $10^6$ | $25$ |

## 样例 #1

### 输入

```
1
1```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 1 1 2 2```

### 输出

```
21```

## 样例 #3

### 输入

```
10
1 1 1 2 2 3 3 3 4 4```

### 输出

```
78```

## 样例 #4

### 输入

```
20
1 1 2 2 2 2 2 4 4 4 4 3 3 3 4 4 7 7 9 10```

### 输出

```
190```

## 样例 #5

### 输入

```
50
1 1 1 1 1 1 1 1 1 2 2 3 4 3 3 4 5 7 2 4 4 3 2 4 6 9 3 8 7 6 12 13 2 12 5 28 17 27 20 36 5 3 2 8 7 6 5 47 26 1```

### 输出

```
2336```

# 题解

## 作者：_zjzhe (赞：4)

## 思路


观察 `FakeLCA` 函数代码。

```cpp
int FakeLCA(int u, int v) {
	while (u != v) u = fa[u], v = fa[v];
	return u;
}
```
发现就是两个点不断向上跳的过程，思考 $(u,v)$ 有贡献的情况：

1. $u$ 为根节点，$v$ 为任意点；
2. $u$ 和 $v$ 深度相同；
3. $u$ 和 $v$ 在根节点的两棵不同子树中；
4. $u=v$。

这四种情况有重叠，考虑去重，首先统计 **1** 和 **4** 两种情况。

```cpp
ans+=2*(n-1)+n;
```
接着 dfs 一遍处理出每棵子树的大小和每个点的深度，统计 **2** 和 **3** 两种情况。


```cpp
void dfs(int u){
	siz[u]=1;dep[u]=dep[fa[u]]+1;
	for(auto v : G[u]){
		if(v==fa[u]) continue;
		dfs(v);
		siz[u]+=siz[v];
	}
}
void calc(int u){
	++cnt[dep[u]];
	for(auto v : G[u]){
		calc(v);
	}
}
//main函数中
dfs(rt);
for(auto v : G[rt]){
	ans+=siz[v]*(n-1-siz[v]);// u 和 v 在不同子树
    //已经统计了(rt,v)与(v,rt)的贡献所以要"-1"
	for(int i=1;i<=n;i++) cnt[i]=0;
	calc(v);
	for(int i=1;i<=n;i++) ans+=cnt[i]*(cnt[i]-1);
}
```

在计算根节点子树贡献时已经包括了 $u$ 和 $v$ 不在同一颗子树而 $dep[u]=dep[v]$ 的情况，所以要单独计算根节点每一棵子树内部各深度的出现次数记录在  $cnt[]$ 中，计算下一棵子树时记得清空。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;

int fa[N],n,rt,siz[N],ans,dep[N],cnt[N];
vector<int> G[N];
void dfs(int u){
	siz[u]=1;dep[u]=dep[fa[u]]+1;
	for(auto v : G[u]){
		if(v==fa[u]) continue;
		dfs(v);
		siz[u]+=siz[v];
	}
}
void calc(int u){
	++cnt[dep[u]];
	for(auto v : G[u]){
		calc(v);
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>fa[i];
		if(fa[i]==i) rt=i;
		else G[fa[i]].push_back(i);
	}
	dfs(rt);
	ans+=2*(n-1)+n;
	for(auto v : G[rt]){
		ans+=siz[v]*(n-1-siz[v]);
		for(int i=1;i<=n;i++) cnt[i]=0;
		calc(v);
		for(int i=1;i<=n;i++) ans+=cnt[i]*(cnt[i]-1);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：cmrhhh (赞：3)

#### [P11624 迷宫寻路 Round 3\] 挂掉的模板](https://www.luogu.com.cn/problem/P11624?contestId=229422)解题报告

#### 前言：

挺好的一题，对我着这种老久没打过树上问题的人来说刚刚好。

#### 思路：

首先，我们看 `FakeLCA` 函数实际上是 $u,v$ 一个一个往上跳，跳到公共点的意思，特别的，树根 $rt$ 的父节点是自己。那么对于一棵根节点的子树，以子树的根为 $u$，以子树根的子节点为 $v$ 这种情况显然是不行的。我们考虑有哪些给出贡献的情况。

1. $(u,u)$：单个节点（样例1），贡献了 $n$。

2. $(rt,u) (u,rt)$：根可以等待下面的跳上来，贡献了 $2\times(n-1)$。

3. 两点连线经过 $rt$ 的：只需选取任意两棵子树上的节点任意组合，我们枚举 $rt$ 的子节点 $u,v$，以其为根的子树（显然包含根）大小为 `sz[u],sz[v]`，每组贡献了 `sz[u]*sz[v]` 。复杂度处在 $O(n^2)$，我们考虑优化到 $O(n)$：
   $$
   \begin{equation}
   \begin{aligned}
   &\sum_{u\in son(rt)}\sum_{v\in son(rt),u\neq v}sz_u*sz_v\\
   &=\sum_{u\in son(rt)}sz_u*\sum_{v\in son(rt),u\neq v}sz_v\\
   &=\sum_{u\in son(rt)}sz_u*(n-1-sz_u)\\
   \end{aligned}
   \end{equation}
   $$
   
4. 两点连线不经过 $rt$ 的：此时需要层数 `dep[u]=dep[v]`。我们分别对每一棵**根的子树**记录各层的节点数量，其中同一层的节点显然都是合法的，`cnt[dep]` 表示记录同层节点数，每一棵子树都有贡献 $\sum cnt_{dep_i}\times (cnt_{dep_i}-1)$，注意清空。

#### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+10;
int n,root,dm,ans=0,dep[maxn+10],cnt[maxn+10],sz[maxn+10];
vector<int>g[maxn+10];
void dfs(int u){
	sz[u]=1;
	cnt[dep[u]]++;
	for(auto v:g[u]){
		dep[v]=dep[u]+1;
		dm=max(dm,dep[v]);
		dfs(v);
		sz[u]+=sz[v];
	}
	if(dep[u]==1){
		for(int i=2;i<=dm;++i)ans+=cnt[i]*(cnt[i]-1),cnt[i]=0;
		dm=0;
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i){
		int f;
		cin>>f;
		if(f==i)root=i;
		else g[f].push_back(i);
	}
	dfs(root);
	for(auto i:g[root]){
		ans+=sz[i]*(n-1-sz[i]);
	}
	cout<<ans+n+(n-1)*2;
	
	return 0;
}
```

---

## 作者：shumu (赞：3)

先预测一手大佬们肯定都是先令 $ans=n \times n$ 再容斥，但是我推不出来，这里提供一个更简单的思路。

不难注意这个函数错误错在了它没有通过倍增让两个节点的深度保持一致，所以该函数正确的情况只有下面的情况：

1. 两个节点的深度相同
2. 两个节点的 LCA 为根节点

对于两个节点的深度相同，我们可以直接通过一次 dfs 求出所有深度的节点个数，但是两个节点 LCA 为根节点又包含了同层的两个节点 LCA 为根节点，如果在这里容斥的话比较麻烦。于是我们考虑到一个充分必要条件：两个节点不在以同一个深度为二级父节点为根的子树中，接下来开一个数组记录所有深度为二的节点，然后开一个二维数组 mmp 记录某个深度为二的节点的某层的节点个数，再开一个一维数组 sz 记录深度为二的节点为根的子树的大小，但这里因为要开大数组，所以二维数组开在堆防止MLE。然后讨论一下贡献：

1. 节点深度相同： $\sum_{i=1}^{dep}cnt_{i} \times cnt_{i}   $，其中 $cnt[i]$ 表示深度为i的节点个数，$dep$ 表示树的深度
2. 根节点产生的贡献：$2 \times (n-1)$
3. 不同层产生的贡献：$\sum_{i=1}^{k}\sum_{j=2}^{dep}  mmp_{i,j} \times (n-sz_{i}-1-cnt_{j}+mmp_{i,j})$ ，其中 $mmp_{i,j}$ 表示深度为 2 的节点 $i$ 的 $j$ 层子节点个数， $sz_{i}$ 表示以 $i$ 为节点为子树的树的节点数，$k$ 为深度为二的节点总数

简单解释一下 3 这个式子， $n-sz[i]-1$ 是不跟这个节点同子树的节点个数，$-cnt[j]$ 是要求不同层，而这两个的交集正好就是 $mmp[i][j]$ ，所以我们要加回来，然后乘法原理一下就好了。详细实现看代码吧：

```c++
//
// Created by shumu on 2025/1/26.
//
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e6+100;
typedef long long ll;
map<pair<int,int>,int>mmp;
vector<int>tree[maxn];
vector<int>k;
ll n,fa[maxn],cnt[maxn],root,ans,sz[maxn],is;
void dfs(ll dep,ll u) {
    if(dep==2) {
        k.push_back(u);
    }
    sz[u]=1;
    cnt[dep]++;
    mmp[{is,dep}]++;
    for(int i:tree[u]) {
        if(dep==1) {
            is=i;
        }
        dfs(dep+1,i);
        sz[u]+=sz[i];
    }
}
int main() {
    cin>>n;
    for(int i=1;i<=n;i++) {
        cin>>fa[i];
        if(fa[i]==i) {
            root=i;
        }
        else {
            tree[fa[i]].push_back(i);
        }
    }
    dfs(1,root);
    for(int i=1;i<=n;i++) {
        if(cnt[i]==0) {
            break;
        }
        ans+=cnt[i]*cnt[i];
    }
    ans+=2*(n-1);
    for(int i:k) {
        for(int j=2;j<=n;j++) {
            if(mmp[{i,j}]==0) {
                break;
            }
            ans+=mmp[{i,j}]*(n-sz[i]-1-cnt[j]+mmp[{i,j}]);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：ztd___ (赞：3)

本题解可能**略长**。

友情提示：本题拿满分并不需要读者学会 LCA。

好题，但感觉我的实现也太抽象了。

但是为了防止下文出现了一些概念问题，这里引用一下 OI - Wiki 中对 LCA 的定义。
>最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。 为了方便，我们记某点集 $S=\{v_1,v_2,\ldots,v_n\}$ 的最近公共祖先为 $\text{LCA}(v_1,v_2,\ldots,v_n)$ 或 $\text{LCA}(S)$。
### 题意
很清楚，不赘述。

值得注意的是像 $(1,1)$ 和 $(2,1)$ 这种 $u \ge v$ 的数对也要考虑。

### 分析
#### Subtask 0
给乱搞的分的，赛时没写也懒的想了。

#### Subtask 1
明显是 $O(n ^ 2 \log n)$ 算法。带 $\log$ 是因为后面 Subtask 3 的 $n \le 7000$ 才是 $O(n ^ 2)$。

考虑什么样的算法能带 $\log$。题目已经提示我们，挂掉的模板是 LCA 模板，不难想到 LCA 暴力解决。

具体地，枚举 $u$ 和 $v$，对于任意的 $1 \le u,v \le n$，计算 $\text{LCA}(u,v)$，然后与 `FakeLCA` 计算出的结果进行比较，相同则答案加 $1$。

有一个地方就是找树根，而题目告诉了我们根的父节点是根本身，所以可以 $O(n)$ 直接找。

什么？你不会 LCA？你不知道 LCA 是什么东西？别担心，本题除了这一部分，其他不需要 LCA。

贴一下不甚美观的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 55;
const int LOG = 22;
int n, dep[N], dp[LOG][N];
vector<int> to[N];
void dfs(int u, int fa, int d) {
	dep[u] = d;
	for (int j = 1; j < LOG; j++) {
		dp[j][u] = dp[j - 1][dp[j - 1][u]];
	}
	for (int i = 0; i < to[u].size(); i++) {
		if (to[u][i] != fa) dfs(to[u][i], u, d + 1);
	}
}
int FakeLCA(int u, int v) {
	while (u != v) u = dp[0][u], v = dp[0][v];
	return u;
}
int LCA(int x, int y) {
	if (dep[x] < dep[y]) swap(x, y);
	int tmp = dep[x] - dep[y];
	for (int j = 0; tmp; j++, tmp >>= 1) {
		if (tmp & 1) x = dp[j][x];
	}
	if (x == y) return x;
	for (int k = LOG - 1; k >= 0; k--) {
		if (dp[k][x] != dp[k][y]) x = dp[k][x], y = dp[k][y];
	}
	return dp[0][x];
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	int root = 0;
	for (int i = 1; i <= n; i++) {
		cin >> dp[0][i];
		to[dp[0][i]].push_back(i);
		if (dp[0][i] == i) root = i;
	}
	dfs(root, 0, 1);
	int cnt = 0;
	for (int i = 1;i <= n;i++) {
		for (int j = 1;j <= n;j++) {
			if (FakeLCA(i, j) == LCA(i, j)) {
				cnt++;
			}
		}
	}
	cout << cnt;
	return 0;
}
```

因为 LCA 的复杂度是 $O(n \log n)$，再加上一个枚举，就是 $O(n ^ 2 \log n)$。

#### Subtask 2
严格 $O(n ^ 2)$，赛时没有想考虑相关做法，感觉有可能是正解的一个简化版本。
#### Subtask 3 & 正解
这部分的思路与官方题解类似，实现可能略有不同。

观察到数据的范围是 $n \le 10^6$，考虑线性解法。

考虑什么样的两个点经过 `FakeLCA` 的计算得出的 LCA 与真正的 LCA 没有差别。

- - -

首先，一个重要的信息是：根的父节点是根本身。

这告诉我们，如果一个点在 `FakeLCA` 里如果跳到了根节点，那么它就会**一直停留**在根节点，不再继续跳，直到另一个点跳到根再跳出循环。

举例：

![](https://cdn.luogu.com.cn/upload/image_hosting/955xmngn.png)

其中：
- 第一次跳跃：红色从 $4$ 跳到了 $2$，绿色从 $3$ 跳到了 $1$，到达根节点。
- 第二次跳跃：红色从 $2$ 跳到 $1$，绿色从 $1$ 还是跳到 $1$，**相当于没有跳**。此时两点相遇，`FakeLCA` 停止循环，返回两点的位置 $1$。

这是 `FakeLCA` 的跳跃过程，所以我们可以推理出一条信息。

- 如果两个点的最近公共祖先是根节点，那么这两个点的答案不会受到影响。

> 简单证明一下。
>
> 两个点里，不管谁先到根节点，那个点都会停在那，等待另一个点的到来。所以他们最后必然在根的地方相遇。
>
> 为什么不会在别的地方呢？如果两个点的最近公共祖先是根，那么他们必然只有唯一的公共祖先，否则就不满足“最近”了。而唯一的公共祖先，就是说他们只会在一个地方相遇。所以他们不会在别的地方相遇。
>
> 总而言之，就是这两个点在 `FakeLCA` 里的答案必然是根。
>
> 再结合前提：最近公共祖先是根节点，所以答案不会受到影响。

其实理解起来还是非常容易的，脑子转一下就能明白。

- - -

接下来就是：
- 深度相同的点的答案不会受到影响。

感性理解，这样的话两个点都是同步往上跳的，和找真正的最近公共祖先过程一样，肯定是没有影响的。

理解不了就看图。

![](https://cdn.luogu.com.cn/upload/image_hosting/ea0x8sbz.png)

显然，点 $4$ 和点 $5$ 深度相同，往上跳的时候不管跳多少，都是不会改变他们之间的相对位置，他们都是平行地跳的。

其实这个不太好描述，只能靠感性理解。实在理解不了我也没有办法。

这个其实就是 LCA 的朴素找法。

- - -

总结，答案不受影响的点对有以下特点之中的**任意一个**：
- 两个点的最近公共祖先是根。
- 两个点深度相同。

- - -

接下来需要前置知识：乘法原理。

~~虽然这个学过乘法的小朋友都会吧。~~

>小朋友们别走神了！认真听课！
>
>可是老师，我们才幼儿园啊，离学习乘法还早呢。
>
>早？教育要从娃娃抓起，现在你们会了乘法原理，上了小学后就能……
>
>好了老师，别讲了，我听。
>
>有 $3$ 个苹果，$4$ 个梨子，你要选一个苹果和一个梨子，问总共有多少种方案？
>
>老师老师我知道！答案是 $3 \times 4 = 12$。
>
>答对了！你真聪明！那我问你，$n$ 个苹果，$m$ 个梨子的答案呢？
>
>这个……应该是 $n \times m$！
>
>好聪明的小朋友呀！看来你已经学会乘法原理了！
>
>啊？老师，乘法原理这么简单吗？
>
>是的哦！乘法原理就这么简单！

我们考虑分开计算两种答案。

- - -

对于深度相同的点对，做法是简单的。

首先，可以通过 `dfs` 遍历一遍整棵树来求出各点的深度。

接着考虑将深度存进桶里面，然后扫一遍桶。

对于桶里面的每一个深度，设有这个深度的点的数量为 $x$。

则答案应是 $x ^ 2$。

感性理解。看图。

![](https://cdn.luogu.com.cn/upload/image_hosting/hfxhlnup.png)

~~有点丑，见谅。~~

一个箭头表示的是一个点对。箭头的起始点为第一个点，指向第二个点。

由于像 $(1,1)$ 和 $(2,1)$ 这种 $u \ge v$ 的数对也要考虑，所以每个点可以匹配到与自己相同深度的每一个点，**包括自己**。

显然，问题变成了有 $x$ 个点，每个点有 $x$ 个点能和它匹配，求匹配方案总数。

这不就是乘法原理的模板吗？答案显然了。~~什么幼儿园奥数题。~~

贴下代码吧。~~我真是幼儿园老师的模范，无微不至！~~
```cpp
int cnt = 0;
for (int i = 1;i <= n;i++) b[dep[i]]++;
for (int i = 1;i <= n;i++) {
	int x = b[i];
	cnt += x * x;
}
```

`dfs` 的代码在下面，因为它有别的用处。

- - -

这部分才是最复杂的。  
如果不能理解，建议仔细阅读，反复食用。

考虑计算 LCA 在根的点对数量。

这里，为方便起见，我们给出**块**的定义。

定义：将树的根节点删去后，树会变化为原树的若干棵**子树**，我们称每个子树为一个**块**。

如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/2k0jso91.png)


有一个显然的东西：如果点对 $(u, v)$ 的 LCA 为根，那么他们必然**不在**同一个块内。

反证法。  
如果他们在同一个块里面，他们就必然会有一个公共祖先是**这个块的**根，此时**整个树的**根就必然不是最近的公共祖先了。反之，如果他们的 LCA 为根，他们就必然不在同一块内。

那么就接下来的计数就需要运用到我们的**乘法原理**了！

先不考虑重复情况，每一个块内的点都可以与**其他**任意一个块内的点产生匹配，形成一个点对。这个可以预先统计好，实现在后面。

>现在老师问你，一个块内的点数有 $a$ 个，其他块的点数之和为 $b$，每一个块内的点都可以与其他任意一个块内的点产生匹配，形成一个点对。问你有多少种匹配方案？
>
>老师老师我知道！答案是 $a \times b$。
>
>真聪明啊！~~不愧是我教出来的孩子！~~

然后考虑去重。去的重只有我们之前计算过的**不同块内的同层点对**个数。怎么计算呢？

我们考虑一种方法：假定在上面的匹配过程中，同层节点不能互相匹配。这样，那些**不同块内的同层点对**相匹配就是**不合法的**。

既然要去掉这些不合法方案，那直接减去他们的个数不就行了！

那不如再统计一下这些不合法方案的总数了。

不妨预处理出每个块每层有多少的点。然后预处理出**整棵树**每层的节点数量。

即可得出：对于每个块的每层，在其他块中与该层的深度相同的节点总数。

然后又转化成了经典的匹配问题。  
对于每个块的每层，我们设该层节点数为 $x$，整棵树中的同层节点总数为 $all$，那么其他块中的同层节点个数就是 $oth = all - x$。

>现在老师问你，一个块中有 $x$ 个不合法节点，其中每个节点都可以和其他块中的不合法节点相匹配。其他块中总共有 $oth$ 个不合法节点。求匹配方案总数。
>
>老师老师我知道！答案是 $x \times oth$。
>
>真聪明啊！~~不愧是我教出来的孩子！~~

因为我们刚刚都是针对块内的节点进行计算，没有算根。而对于每个点 $u$ 来说，它和根的 LCA 必然是根。所以答案要加上 $2 \times (n - 1)$。原因自己想吧。~~总不能全靠老师讲啊。~~

然后你发现这题做完了。

- - -

讲讲实现。

归纳一下需要**预处理**的信息。
- 每个节点的深度。（求深度相同的点对时要用。）
- 每个块中的节点数。
- 除了这个块以外，其他块的总节点数。
- 这个块中，每层的节点数量。
- 除了这个块以外，其他块的每层总节点数。

唉这个是不是太多了啊！

不用担心，这个里面有很多是可以轻松解决的。

首先采用结构体 `BLOCK` 来存一个块。

然后把需要维护的所有信息一股脑塞进去。

```cpp
const int N = 1e6 + 55;
int n, dep[N], fa[N], b[N];
struct BLOCK{
	int siz, mxdep;
	vector<int> deps;
	vector<int> blkdep;
}blocks[N];
vector<int> to[N];
```

解释一下代码：
- $dep_i$ 表示节点 $i$ 的深度。
- $fa_i$ 表示节点 $i$ 的父亲节点。
- $b_i$ 表示**整棵树中**深度为 $i$ 的节点总数，是一个桶。
- `BLOCK` 结构体内部：
  - $siz$ 表示块的大小，即块中节点的个数。
  - $mxdep$ 表示块的最大深度，待会有用。
  - $deps$ 表示块中**每个点**的深度信息。注意只存深度，因为具体哪个点不重要。
  - $blkdep_i$ 表示**块中**第 $i$ 层的节点个数。
- $to$ 是存树的。$to_i$ 表示点 $i$ 能通向哪几个点。

~~看着挺恶心吧？实际确实很恶心。~~

接着我们进行 `dfs` 操作。  
考虑哪些信息可以通过 `dfs` 维护。

$dep$ 肯定是可以维护的。我们在开始的时候设置一个初始深度 $d$，之后每深入一层就将 $d \gets d + 1$。这样遍历到点 $i$ 的时候，$dep_i$ 就是 $d$了。

然后我们可以弄出来每个点隶属于哪个块。我们在 `dfs` 的时候传一个参数 $belong$，表示隶属于哪个块。这样我们直接从根节点的儿子们开始 `dfs` 即可。  
代码如下：
```cpp
int blockSum = to[root].size();
dep[root] = 1;
for (int i = 0;i < blockSum;i++) {
	dfs(to[root][i], i + 1, 2);
}
```
而 `dfs` 的格式就是：
```cpp
void dfs(int u, int belong, int d);
```
接着就可以维护 `BLOCK` 里面的信息了。

`siz` 是好维护的，直接加 $1$ 即可。  
然后 `deps` 也可以弄了，直接塞进去就好了。  
其实 `mxdep` 和 `blkdep` 也可以直接维护，但是我把他们放在主函数里面直接算了。

整个 `dfs` 就长这个样子：
```cpp
void dfs(int u, int belong, int d) {
	dep[u] = d, blocks[belong].siz++;
	blocks[belong].deps.push_back(d);
	int siz = to[u].size();
	for (int i = 0; i < siz; i++) {
		if (to[u][i] != fa[u]) dfs(to[u][i], belong, d + 1);
	}
}
```
~~感觉比较容易理解啊。~~

然后，对于深度相同的点的计算方式我们已经给出，接下来处理 LCA 为根的情况。

我采用的方式是统一将 `mxdep` 和 `blkdep` 处理出来。用 `vector` 实现，因为我们并不知道每个块的实际深度。

`mxdep` 直接取深度的最大值就好了。然后由于 `blkdep` 是一个桶，所以我们要将其初始化为 $0$。

往里面塞的 $0$ 的个数就是 $mxdep + 1$，因为 `vector` 从 $0$ 开始，我们要将 $0$ 的位置填上。

然后用这个桶直接计数就可以了。

代码。其中 `blockSum` 是块的数量。
```cpp
for (int i = 1;i <= blockSum;i++){
	int siz = blocks[i].siz;
	for (int j = 0;j < siz;j++) {
		blocks[i].mxdep = max(blocks[i].mxdep, blocks[i].deps[j]);
	}
	for (int j = 1;j <= blocks[i].mxdep + 1;j++) {
		//vector 是从 0 开始的，但是深度从 1 开始算，所以要 +1
		blocks[i].blkdep.push_back(0);
	}
	for (int j = 0;j < siz;j++) {
		blocks[i].blkdep[blocks[i].deps[j]]++;
	}
}
```
最后就是计算了。遍历每一个块，再遍历这个块的每一层。对于每层的计算公式已经给出，不再赘述。  
代码：
```cpp
for (int i = 1;i <= blockSum;i++) {
	int sum = 0;
	for (int j = 1;j <= blocks[i].mxdep;j++) {
		int x = blocks[i].blkdep[j];
		int all = b[j];
		int oth = all - x;
		sum += x * oth;
	}
	cnt += blocks[i].siz * (n - 1 - blocks[i].siz) - sum;
}
```
~~应该不难懂吧。~~

最后：
```cpp
cout << cnt + 2 * (n - 1);
```

关于时间复杂度：   
设 $B$ 为块数，$C$ 为**平均**每块层数。  
显而易见，我们的复杂度是 $O(BC)$，因为我们遍历了每个块的每一层。  
因为每个块的每一层最少也有 $1$ 个节点，所以最坏的情况就是把每个点（除根以外）都遍历一遍，即 $O(n)$。

[AC 记录。](https://www.luogu.com.cn/record/200758699)

可以看到，我们并没有运用任何 LCA 相关知识就写出了本题的正解，除了它的定义。

这道题是一道非常好的计数题，非常考验我们对~~幼儿园奥数知识~~乘法原理的应用。希望同学们能够对计数有更深刻的掌握。

---

## 作者：george0929 (赞：3)

前置知识：LCA。

`FakeLCA` 与正确 LCA 算法的唯一区别就是没有让两个点从同一深度开始向上跳。

这会导致什么问题呢？来看图片：

![](https://cdn.luogu.com.cn/upload/image_hosting/y6rv5c7o.png)

即深度较小的点会先到达根，并在根节点原地踏步。其结果为根节点。

所以 `FakeLCA` 在**两点深度不同**，且**这两点的 LCA 不是根节点**时，结果与真正的 LCA 不同。

那么 `FakeLCA` 的结果是两点真正的最近公共祖先，需要满足如下条件中的**任意一条**：

1. 两点深度相同。
2. 两点 LCA 为根节点。

其细节分别如下两图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vawf0kzk.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/pmdavsfm.png)

我们要求的是满足如下条件中任意一条的点对个数：

1. 两点深度相同。
2. 两点 LCA 为根节点。

考虑将根节点下的若干个子树分别计算。

**子树内**：子树内的贡献为深度相同的点对个数，直接遍历整个子树，统计深度为 $x$ 的点个数 $cnt_x$，答案即为 $\sum\limits_{i} (cnt_i)^2$。

**子树外**：对于子树外一个点和子树内一个点组成的点对，都满足其 LCA 为根节点，记子树大小为 $sz$，则这个子树的贡献为 $sz\times (n-sz)$。

最后别忘了根节点和每个点组成的点对也符合条件，答案还要再加上 $n$。

![](https://cdn.luogu.com.cn/upload/image_hosting/kt0tgk4k.png)

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> V[1000005];
int n,rt=0;
int sz[1000005],dep[1000005],cnt[1000005];
long long ans;
void dfs(int u,int fa){
	sz[u]=1;
	for(int v:V[u]){
		if(v==fa) continue;
		dfs(v,u);
		sz[u]+=sz[v];
		if(u==rt) ans+=1ll*sz[v]*(n-sz[v]);
	}
}
int node[1000005],pos;
void dfs2(int u,int fa){
	node[++pos]=u;
	dep[u]=dep[fa]+1;
	ans-=1ll*cnt[dep[u]]*cnt[dep[u]];
	cnt[dep[u]]++;
	ans+=1ll*cnt[dep[u]]*cnt[dep[u]];
	for(int v:V[u]){
		if(v!=fa) dfs2(v,u);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		int fi;
		cin>>fi;
		if(fi==i){
			rt=i;
			continue;
		}
		V[i].push_back(fi);
		V[fi].push_back(i);
	}
	dfs(rt,0);
	for(int v:V[rt]){
		pos=0;
		dfs2(v,rt);
		for(int i=1;i<=pos;i++){
			cnt[dep[node[i]]]=0;
		}
	}
	cout<<ans+n<<endl;
	return 0;
}
```

---

## 作者：K_J_M (赞：2)

# [迷宫寻路 Round 3] 挂掉的模板
## 题目描述

有一颗 $n$ 个节点的有根树。

定义 `FakeLCA` 函数代码如下：

```cpp
int FakeLCA(int u, int v) {
	while (u != v) u = fa[u], v = fa[v];
	return u;
}
```

其中 `fa[i]` 表示节点 $i$ 的父节点，**特别的，根的父节点是根本身。**

现在给定节点数 $n$ 和每个节点的父节点，问有多少个有序数对 $(u,v)$，满足 $1\le u,v\le n$ 且 `FakeLCA(u, v)` 的结果是 $u$ 和 $v$ 的真正的最近公共祖先。
## Solution
简单题。

题目给出的代码就是两个节点同时往上跳，问相遇那个点是真正 LCA 的有多少个**有序**整数对。值得注意的一点是，根的父亲是根本身，并且有序整数对中 $u,v$ 可以相等。

分情况讨论即可。

首先，我们找到这棵树的根 rt，那么 rt 与其他 $n-1$ 个点可以互相构成 $2n-2$ 个有序对。因为任何节点往上跳，肯定会到达根，而根只会原地不动。

然后是位于 rt **不同子树**上的点 $u,v$。它们正常的 LCA 是 rt，我们记录 $sz_u$ 表示 $u$ 子树的大小，那么这样的有序整数对一共有
$$\sum_{u∈son(rt)}\sum_{v∈son(rt),v≠u}sz_u\times sz_v$$
但是如果给出的图是菊花图，那么我们的时间复杂度会退化为 $\mathcal O(n^2)$，考虑优化。对于上面那个式子，我们可以化简
$$\sum_{u∈son(rt)}\sum_{v∈son(rt),v≠u}sz_u\times sz_v$$
$$=\sum_{u∈son(rt)}sz_u\sum_{v∈son(rt),v≠u)}sz_v$$
$$=\sum_{u∈son(rt)}sz_u\times (n-sz_u-1)$$
这样我们就做到了 $\mathcal O(n)$ 的时间复杂度。

接着，我们还需要考虑同一颗子树内的节点。由于节点是同时往上跳，所以 LCA 不是 rt 的节点 $u,v$ 必须保证**深度相同**。所以我们需要对于 rt 的每一颗子树找出深度相等的节点 $u,v$，它们可以构成一组，统计答案即可。

最后，由于有序整数对中 $u,v$ 可相等，所以我们的答案还需要加上 $n$。\
[Ac Code](https://www.luogu.com.cn/paste/40s4kf8l)

---

## 作者：ElectricArc (赞：2)

# 思路

我们发现，$\operatorname{fakeLCA}(u, v)$ 不考虑 $u, v$ 两点的高度就直接跳，而非先让较深的那个点跳到另一个点的深度，再一起跳。

现在考虑 $\operatorname{fakeLCA}(u, v) = \operatorname{LCA}(u, v)$ 成立的情况。设 $rt$ 为有根树的根。

1. 最容易想到的是 $u = v$ 的情况，有 $n$ 个满足条件的节点对数。

1. 同时，容易发现当 $u$ 或 $v$ 为 $rt$ 时，$\operatorname{fakeLCA}(u, v) = \operatorname{LCA}(u, v)$。其中一个点在向上跳的过程中，另一个点 $rt$ 一直在原地打转。除去 $u, v$ 都是 $rt$ 的情况，有 $2(n - 1)$ 个满足条件的节点对数。

	![](https://cdn.luogu.com.cn/upload/image_hosting/1pqm40cg.png)

1. 当 $u$ 和 $v$ 的深度相同时，满足 $\operatorname{fakeLCA}(u, v) = \operatorname{LCA}(u, v)$。

1. $u, v$ 不在同一个根节点下的子树时，满足 $\operatorname{fakeLCA}(u, v) = \operatorname{LCA}(u, v)$。其中一个点必然会先到（或者两个点同时到）根节点，然后在根节点处打转。

现在重点考虑后面的两种情况如何计数，这两个条件有重叠之处。

- $u, v$ 不在同一个根节点下的子树

	![](https://cdn.luogu.com.cn/upload/image_hosting/f38ecrxh.png)

	如图，很容易发现任意的子树Ⅰ中的节点 $u$ 与任意的子树Ⅱ或Ⅲ中的节点 $v$ 都满足 $\operatorname{fakeLCA}(u, v) = \operatorname{LCA}(u, v)$。若根节点有 $k$ 个孩子，节点 $i$ 为根的子树有 $s_i$ 个节点，则有 $\sum\limits_{i = 1}^{k}s_i \times (n - s_i - 1)$ 个满足条件的节点对数。

	![](https://cdn.luogu.com.cn/upload/image_hosting/gcyphy1b.png)

- $u$ 和 $v$ 的深度相同

	上一个情况中也存在 $u, v$ 会满足这种情况，但是上一个情况中 $u, v$ **不会**在同一个子树下，所以现在只需要考虑 $u, v$ 在**同子树**下的情况。

	设该子树下某一层有 $m$ 个节点，则满足条件的节点对数有 $m(m - 1)$ 个（即 $\text{A}_m^2$），而该子树满足条件的节点对数只需将每一层满足条件的节点对数相加即可，对于整棵树来说只需将每个子树满足条件的节点对数相加即可。

最后，把每一种情况满足条件的节点对数相加，就是最终答案。但是需要注意 $1 \leq n \leq 10^6$，而最大的满足条件的节点对数 $n^2$ 会超出 `int`，记得开 `long long` 哦！

# 代码

这里用 dfs 获取每个以节点 $i$ 为根的子树的节点数（`siz[i]`），用 bfs 获取每个根节点下的子树中每一**层**的节点数量，并计算贡献。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;

const int N = 1e6 + 7;
int fa[N], siz[N];
vector <int> g[N];

void dfs(int u) {
	siz[u] = 1;
	for (int v : g[u]) {
		if (v == fa[u]) continue;
		dfs(v);
		siz[u] += siz[v];
	}
}

long long bfs(int rt) {
	long long ans = 0;
	queue <int> q;
	q.push(rt);
	while (q.size()) {
		int u, cnt = 0, num = q.size();
		while (num--) {
			u = q.front(); q.pop();
			for (int v : g[u])
				if (v != fa[u]) q.push(v);
			cnt += g[u].size() - 1;
		}
		ans += (long long)cnt * (cnt - 1);
	}
	return ans;
}

int main() {
	int n, rt;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &fa[i]);
		if (i == fa[i]) {
		    rt = i;
		    continue;
		}
		g[i].push_back(fa[i]);
		g[fa[i]].push_back(i);
	}
	dfs(rt);
	long long ans = n + 2 * (n - 1);
	for (int i : g[rt])
		ans += bfs(i) + (long long)siz[i] * (n - siz[i] - 1);
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：qW__Wp (赞：1)

首先，翻译一下 `FakeLCA` 函数，就是“每次让 $u$ 和 $v$ 向上爬升，直至 $u = v$，视 $u$ 为 $lca(u,v)$”。

记树的根为 $root$，树上节点 $u$ 的深度为 $d_u$（$d_{root}=1$）。要使数对 $(u,v)$ 产生贡献，发现可以分为几种情况：

1. 对于根节点的任意两颗不同子树中的各一个节点 $u$ 和 $v$，$(u,v)$ 和 $(v,u)$ 可以产生贡献。

2. 对于在根节点的同一颗子树的两个节点 $u$ 和 $v$，若 $d_u = d_v$，则 $(u,v)$ 和 $(v,u)$ 可以产生贡献。

3. $(i,i)$ 可以产生贡献。

4. $(root,i)$ 和 $(i,root)$ 可以产生贡献（$i \neq root$）。

对于第一种情况，直观的想法是，统计出根节点的每一颗子树大小，记做 $s_1,s_2,\dots,s_k$，则贡献为 $\sum\limits_{i=1}^k \sum\limits_{j=i+1}^k s_i \times s_j \times 2$。但这样时间复杂度是 $O(n ^ 2)$。我们不妨转化下思路，设当前 dfs 到第 $i$ 颗子树，则第 $i$ 颗子树与之前的任一子树各选一个节点组合的方案为 $s_i \times \sum\limits_{j=1}^{i-1} s_j \times 2$。这里 $\sum\limits_{j=1}^{i-1}$ 是动态变化的，用一个变量记录即可。

对于第二种情况，记 $t_i$ 表示当前子树深度为 $i$ 的节点数量，贡献为 $\sum t_i \times t_{i-1}$。记得在 dfs 到下一颗子树时清空 $t_i$。

对于第三种情况，贡献为 $n$。

对于第四种情况，可以将其归入第一种情况，将根节点视为第一颗子树的一部分，即开始时 $sum = 1$。

详见代码（记得开 `long long`）：

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 5;

int hd[N], cnt, d[N], t[N], fa[N], mx;
int n, root, sum = 1, ans;

struct Edge {
	int to, nx;
} e[N];

void add(int u, int v) {
	e[ ++ cnt] = {v, hd[u]}, hd[u] = cnt;
}

int dfs(int u) {
	d[u] = d[fa[u]] + 1; t[d[u]] ++;
	mx = max(mx, d[u]);
		// mx 表示当前子树的最大深度
	int now = 1;
		// now 表示当前子树的节点数
	for (int i = hd[u]; i; i = e[i].nx) {
		int v = e[i].to;
		now += dfs(v);
	}
	if (d[u] == 2) {
		ans += now * sum * 2;
		sum += now;
			// sum 表示之前 dfs 过的子树的节点数之和（包括根节点）
		for (int i = 2; i <= mx; i ++) {
			ans += t[i] * (t[i] - 1), t[i] = 0;
		}
		mx = 0;
	}
	return now;
}

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i ++) {
		cin >> fa[i];
		if (i == fa[i]) root = i;
		else add(fa[i], i);
	}
	dfs(root);
	cout << ans + n;
	return 0;
}
```

---

## 作者：fish_love_cat (赞：1)

特判些东西，首先 $(u,u)$ 和 $(root,x)$ 一定正确，可以先算上，记答案初始值为 $n+2\times(n-1)$。

这些东西最好拎出来处理，杂在一起会很乱，容易算重。~~你怎么知道我调不出来的。~~

除上述外，显然这份代码只有在 $(u,v)$ 的 LCA 是根时和 $deep_u=deep_v$ 时可以 AC。

统计两种情况即可。

---

首先统计与根相关的。

我们找到 $root$ 每一个子节点 $x$ 的子树大小，其对答案的贡献为 $siz_x \times (n-siz_x-1)$。此时需要排除和根的关系。

---

再统计与深度相关的。

此时简单路径经过根的点对都处理完了，我们只需要对于每个子树求解即可。

对于当前子树内所有深度为 $i$ 的点，记其数量为 $cnt_i$，其对答案的贡献为 $cnt_i\times (cnt_i-1)$。此时需要排除数对中两数相同的情况。

注意求解不同子树时要清空。[**不要使用 `memset`。**](https://www.luogu.com.cn/discuss/1050547)

---

那么做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>ve[1000005];
int flc[1000005];
int siz[1000005];
int root;
int ans;
void dfs(int x,int dep){
    siz[x]=1;
    flc[dep]++;
    for(int i=0;i<ve[x].size();i++)
    dfs(ve[x][i],dep+1),siz[x]+=siz[ve[x][i]];
}
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        if(x==i)root=i;
        else ve[x].push_back(i);
    }
    for(int i=0;i<ve[root].size();i++){
        dfs(ve[root][i],1);
        ans+=siz[ve[root][i]]*(n-siz[ve[root][i]]-1);
        for(int j=1;j<=n;j++)
        if(flc[j])ans+=flc[j]*(flc[j]-1),flc[j]=0;
        else break;
    }
    cout<<ans+n+2*(n-1);
    return 0;
}
```

---

## 作者：Pig_Eat_Earth (赞：1)

# P11624 挂掉的模版 题解
[原题传送门](https://www.luogu.com.cn/problem/P11624)
## 记号约定
- $FakeLCA_{u,v}$、$fa_i$：如原题所述。
- $lca_{u,v}$：u 与 v 的最近公共祖先
- $root$：根节点
- $dep_u$：节点 u 的深度
- $sz_u$：以 u 为根的子树的大小（节点数）
- $l_d$：在统计范围内深度等于 d 的节点数
## 小观察
以下讨论 $FakeLCA_{u,v}$ 的情况。显然，u 和 v 的跳转次数相同。  
1. $dep_u=dep_v$
   $$\because dep_{lca_{u,v}}-dep_u=dep_{lca_{u,v}}-dep_v$$
   $$\therefore FakeLCA_{u,v}=lca_{u,v}$$
1. $dep_u\neq dep_v$  
   一个节点到达根节点后，会停留在根节点。
   ![](https://cdn.luogu.com.cn/upload/image_hosting/05ctxa62.png)
   图为样例 3，以 $u=5,v=9$ 为例，图中圆框为 u 跳转得，方框为 v 跳转得，同种颜色为跳转同样次数。可见，当 u 和 v 深度不同时，只有根节点处跳转次数相同，所以 $FakeLCA_{u,v}=root$。

于是，我们可以得出结论，$FakeLCA_{u,v}=lca_{u,v}$ 当且仅当满足以下两种情况：  
1. $dep_u=dep_v$（a）
1. $lca_{u,v}=root$

其中第二种情况可以分为：  
1. u 与 v 分属根节点不同子节点的子树（b）
2. $u=root$ 或 $v=root$（c）
## 解法
答案即为满足（a）（b）（c）中至少一条的有序节点对数。  
但是注意到，（a）与（b）可能重叠。因此，采用以下策略：
1. 满足（c）的总共 $2n-1$ 对，即 $\forall 1\le i\le n$，有 $(1,i)$ 和 $(i,1)$ 两对，并减去重复计算的 $(1,1)$。
2. DFS 一遍，统计出满足（b）的对数。注意到，有序对数即为无序对数的 2 倍。*（本条中“答案”指有序对数）*  
   对于一个要并入答案的子树 $i$，增加了：
   $$\sum^{i-1}_{j=1}(sz_i\cdot sz_j)=sz_i\cdot\sum^{i-1}_{j=1}sz_j$$
   注意到，$\sum sz_j$ 可以在计算答案后维护，则计算上式的值为 $O(1)$ 的。
1. 统计出满足（a）而不满足（b）的无序对数，即在以根节点的各个子节点为根的子树内统计出 $l$，并将答案增加 $\sum l_d^2$。
## 时间复杂度
除根节点外，每个节点都被 DFS 了两遍，而节点深度不会超过 $n$，故为 $O(n)$。
## Code
```cpp
#include <bits/stdc++.h>
#define UP(i, l, r) for(register int (i) = (l); (i) <= (r); ++ (i))
#define DN(i, l, r) for(register int (i) = (r); (i) >= (l); -- (i))
#define EUP(t, i, l, r, d) for(register (t) (i) = (l); (i) <= (r); (i) += (d))
#define EDN(t, i, l, r, d) for(register (t) (i) = (r); (i) >= (l); (i) -= (d))
#define INF 0x3f3f3f3f
#define INFLL 0x3f3f3f3f3f3f3f3f
#define INFB 0x3f
using namespace std;
using ll = long long;
const int N = 1e6;
int n, fa[N + 5], sz[N + 5], md, rt;
vector<int> g[N + 5];
ll ans, l[N + 5], ss;

void dfs1(int u){
	sz[u] = 1;
	for(register int v : g[u]){
		dfs1(v);
		sz[u] += sz[v];
	}
	if(fa[u] == rt && u != rt){
		ans += ss * sz[u];
		ss += sz[u];
	}
}

void dfs2(int u, int d){
	md = max(md, d);
	++ l[d];
	for(register int v : g[u]) dfs2(v, d + 1);
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	if(n == 1){
		cout << 1;
		return 0;
	}
	UP(i, 1, n){
		cin >> fa[i];
		if(fa[i] == i) rt = i;
		else g[fa[i]].push_back(i);
	}
	ans += (n << 1) - 1; // c
	dfs1(rt); // b
	ans <<= 1; // 无序转有序 
	for(register int r : g[rt]){ // a & !b
		UP(i, 1, md) l[i] = 0;
		md = 0;
		dfs2(r, 1);
		UP(i, 1, md) ans += l[i] * l[i];
	}
	cout << ans;
	return 0;
}
```

---

## 作者：nightwatch.ryan (赞：1)

### Analysis
观察题目中所提及的 `FakeLCA` 函数，再结合求解最近公共祖先（LCA）的过程，我们可以发现：`FakeLCA` 函数缺少“如果两个节点一开始不在同一深度，先爬到同一深度”的步骤，**因而，`FakeLCA` 函数的结果为两个节点真正的最近公共祖先时，只有下面两种情况：**
1. 两个节点一开始就在同一深度。
2. 两个节点的最近公共祖先为根节点。（因为深度更小的节点肯定会先跳到根节点）

下设答案，即有序数对 $(u,v)$，满足 $1\le u,v\le n$ 且 `FakeLCA(u, v)` 的结果是 $u$ 和 $v$ 的真正的最近公共祖先的个数，为 $ans$。

对于第一种情况：
- 先计算每个节点的深度，设当前节点为 $u$，其父节点为 $fa$，记它们的深度分别为 $dep_u$ 和 $dep_{fa}$。则 $dep_{fa} + 1 \to dep_u$。
- 用数组 $cnt$ 记录每个深度的节点个数，记当前节点的深度为 $dep_u$。则 $cnt_{dep_u} + 1 \to cnt_{dep_u}$。因为题目中没有要求 $u$ 和 $v$ 不能相同，所以可以直接将相同深度的节点个数乘两次，用 $ans$ 加起来，即 $cnt_{dep_u} \times cnt_{dep_u} + ans \to ans$。**注意**，在记录每个深度的节点个数之前，我们得先将 $ans$ 减去 $cnt_{dep_u} \times cnt_{dep_u}$，不然就会重复计算。
- 为什么这里只统计**子树内**深度一样的节点？请阅读下文。

对于第二种情况：
- 在 `dfs` 的过程中，我们可以计算出每个节点的子树大小，记以节点 $x$ 为根节点的子树的大小为 $Size_x$。设当前遍历到的节点为 $u$，其子节点为 $v$，则 $Size_u + Size_v \to Size_u$。
- 如果节点 $u$ 就是根节点，那么对于其的每个子节点 $v$，都有 $Size_v \times (n - Size_v)$ 个有序数对 $(u,v)$，满足 `FakeLCA(u, v)` 的结果是 $u$ 和 $v$ 的真正的最近公共祖先。**为什么？** 显然的，子树外的一个节点与子树内的一个节点的最近公共祖先**就是根节点**。
- 注意到**根节点与每一个节点都能构成一个有序数对**，所以最后 $ans$ 还要加上 $n$。

上述过程用 `dfs` 实现即可。

注意点：
- 根节点不一定是 $1$ 号节点，需要根据读入数据确定。
- 不开 `long long` 见祖宗。
### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 10;
vector<int> adj[N];
int n, root, Size[N];
int dep[N]; map<int, int> cnt;
signed main(){
    cin.tie(0) -> sync_with_stdio(0);
    cin >> n;
    for(int i = 1; i <= n; i++){
        int fa; cin >> fa;
        if(fa == i){
            root = i;
        }else{
            adj[fa].push_back(i);
            adj[i].push_back(fa);
        }
    }
    int ans = 0;
    function<void(int, int)> dfs = [&](int u, int fa){
        dep[u] = dep[fa] + 1;
        ans -= cnt[dep[u]] * cnt[dep[u]];
        ans += (++cnt[dep[u]]) * cnt[dep[u]];
        for(auto v : adj[u])
         if(v != fa) dfs(v, u); 
    };
    for(auto u : adj[root]){
        dfs(u, root);
        cnt.clear();
    }
    function<void(int, int)> dfs2 = [&](int u, int fa){
        Size[u] = 1;
        for(int v : adj[u]){
            if(v == fa) continue;
            dfs2(v, u); Size[u] += Size[v];
            if(u == root) ans += Size[v] * (n - Size[v]);
        }
    };
    dfs2(root, 0);
    cout << ans + n << endl;
}
```

---

## 作者：dddyx03 (赞：1)

### 75 分思路：
当 $\operatorname {lca}(i,j)$ 为根节点或者 $i$ 和 $j$ 的深度相同时记一次。时间复杂度：$O(n^2 \log n)$。

### AC 思路：
跑 dfs 记录每个点的父亲节点、深度、子树大小。    
1. $\operatorname {lca}(i,j)$  为根节点的一对 $( i , j )$ 一定不在同一棵**根节点的儿子节点**的子树上。  
所以可以记录根节点的每一个儿子节点的大小，那么他们一共的贡献是     $\sum^{soncnt}_{i=1}\sum^{soncnt}_{j=1}size_i\cdot size_j(i\ne j)$。


2.  当 $( i , j )$ 的深度相同且在同一棵**根节点的儿子节点**的子树上时，我们可以用一个数组 $dcnt_i$ 来存储这棵子树上深度为 $i$ 的节点个数，那么每棵子树上的贡献是  $\sum_{i=2}^{maxdeep}{dcnt_i}^2$。


3. 根节点与每一个节点组合都是成立的，他的贡献是  $size_{root}\times 2-1$。

把他们全部加起来就可以了。

```cpp

#include <bits/stdc++.h>
#define For(i,s,e) for(int i=s;i<=e;i++)
#define dFor(i,s,e) for(int i=s;i>=e;i--)
#define int long long
using namespace std;
const int MaxN=1e6+10;
struct node{
    int to,nxt;
}edge[MaxN<<2];
int tot,head[MaxN];
void add(int u,int v){
    edge[++tot]=(node){v,head[u]};
    head[u]=tot;
}
int dcnt[MaxN],mxd=-1,son[MaxN],rt,cnt;
int fa[MaxN],sz[MaxN],dep[MaxN];
void dfs(int u,int fth){
    fa[u]=fth;
	dep[u]=dep[fth]+1;
	sz[u]=1;
    dcnt[dep[u]]++;
    mxd=max(mxd,dep[u]);
    int snt=0;
    for(int i=head[u];i;i=edge[i].nxt){
        int v=edge[i].to;
        if(v==fth)continue;
        if(u==rt)memset(dcnt,0,sizeof(dcnt));
        dfs(v,u);
        if(u==rt){
        	For(i,2,mxd+1)cnt+=dcnt[i]*dcnt[i];//情况2
        	son[++snt]=sz[v];
		}
        sz[u]+=sz[v];
    }
    if(u==rt){
    	For(i,1,snt)For(j,1,snt)if(i!=j)cnt+=(son[i])*(son[j]);//情况1
    	cnt+=sz[rt]*2-1;//情况3
	}
}
signed main(){
    int n;
    scanf("%lld",&n);
    For(i,1,n){
    	int f;
        scanf("%lld",&f);
        if(f==i){rt=i;}
        else{
        	add(f,i);
        	add(i,f);
		}
    }
    dfs(rt,rt);
    cout<<cnt;
    return 0;
}
```

---

## 作者：chzhh_111 (赞：1)

我们仔细研究一下题目所给的函数，可发现：

- 如果两个点的深度并不相等，那么该函数返回值为根节点。
- 如果两个点的深度相等，那么该函数返回值为这两个点的 `LCA`。

而题目当中要我们求的是在用该函数的前提下求得 `LCA` 为的其真正的 `LCA` 的点对（注意：$(u,v)$ 和 $(v,u)$ 算两种不同的点对，还有这两个点可以是同一个点），所以可分成几个部分来讨论：

1. 考虑像 $(u,u)$ 一样的点对，很明显这样子的点对数量为 $n$ 个。

2. 考虑像 $(u,1)$ 或 $(1,u)$ 其中 $u \ne 1$ 一样的点对，这个对答案的贡献为 $(n - 1) \times 2$。

3. 考虑像两个分别来自以根节点的两个不同的儿子为根的子树的节点所组成的点对，而这样子对答案的贡献为 $\textstyle \sum_{u \in son(root)} siz_{u} \times (siz_{root} - siz_{u} - 1)$，其中的 $siz_{i}$ 表示以 $i$ 为根节点的子树的大小。

4. 考虑像两个来自以根结点的其中一个儿子为根的子树，且处于同一深度的两个节点所组成的点对，设在这个子树中一个深度 $dep$ 当中一共有 $sum_{dep}$ 个节点（以上讨论是在只有这一棵子树的情况下，就是相当于深度不是从根节点开始计算，是从这棵子树的根节点开始计算，而且统计节点数也只是统计这棵子树内的节点数），则对答案的贡献为 $\textstyle \sum_{sum_{dep} \ne 0} sum_{dep} \times (sum_{dep} - 1)$。

最后的答案就是把上面讨论的所有情况给加起来。

代码部分：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+1; 
int n,fa[N],head[N],ls,root,siz[N],sum[N],ans;
struct bian{
	int to,net;
}s[N*2];
void dfs(int x,int y)
{
	siz[x]=1;
	for(int i=head[x];i;i=s[i].net)
	{
		int u=s[i].to;
		if(u==y) continue;
		dfs(u,x);
		siz[x]+=siz[u];
	}
}
void dfss(int x,int y,int dep)
{
	ans+=sum[++dep]*2;//第四部分（这里为了方便统计，将一层的贡献转化成一个点的贡献） 
	sum[dep]++;
	for(int i=head[x];i;i=s[i].net)
	{
		int u=s[i].to;
		if(u==y) continue;
		dfss(u,x,dep);
	}
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&fa[i]);
		if(fa[i]==i) {root=i;continue;}
		s[++ls]=(bian){i,head[fa[i]]},head[fa[i]]=ls;
		s[++ls]=(bian){fa[i],head[i]},head[i]=ls;
	}
	dfs(root,0);
	for(int i=head[root];i;i=s[i].net)
	{
		int u=s[i].to;
		ans+=siz[u]*(siz[root]-siz[u]-1);//第三部分
		memset(sum,0,sizeof(sum));
		dfss(u,root,0);
	}
	printf("%lld",ans+3*n-2);//第一和第二部分  
	return 0;
}
```

---

## 作者：Noxfer (赞：1)

考虑几种对答案有贡献的点对 $(u,v)$。

令 $\operatorname{d}(u)$ 表示 $u$ 的深度，$s$ 表示根节点。
1. $\operatorname{d}(u) = \operatorname{d}(v)$
2. $u = v$
3. $(u = s) \vee (v = s)$
4. $LCA(u,v) = s$

令 $\operatorname{c}(x)$ 表示深度为 $x$ 的节点个数，$\operatorname{s}(u)$ 表示 $u$ 为根节点的子树有多少节点（含根节点），$son_i(1 \le i \le tot)$ 表示根节点的第 $i$ 个儿子。

分别计算贡献，情况 2，3 显然不再赘述。

对于情况 1，有
$$2 \times {\sum_{i=1}^{n}\sum_{j=1}^{\operatorname{c}(i)-1}j}$$
对于情况 4，有
$$\sum_{i=1}^{tot}\operatorname{s}(son_i)*(n-son_i-1)$$

对于点对 $(u,v)$，若 $\operatorname{d}(u) = \operatorname{d}(v)$ 且 $u,v$ 都在根节点的两个不同子树中，它会被重复计算。

解决方法：情况 1，统计每个 $son_i$ 的答案累加即可，这样操作后情况 1 中的点对都属于同一个子树，情况 4 中的点对都不属于同一个子树。

**CODE**

```cpp
#define MAXN 1000005
int n;
int s;
struct Edge{
    int u,v,nxt;
}e[MAXN];
int head[MAXN],cnt;
inline void addedge(int u,int v){
    ++cnt;
    e[cnt].u=u;
    e[cnt].v=v;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
long long ans=0;
int dep[MAXN],num[MAXN];//深度，某一深度上的节点数
long long sz[MAXN];//子树大小
int dfs(int u,int fa){
    dep[u]=dep[fa]+1;++num[dep[u]];
    sz[u]++;
    for (int i = head[u];i;i = e[i].nxt){
        int v=e[i].v;
        sz[u]+=dfs(v,u);
    }
    return sz[u];
}
long long sum[MAXN];
int main(){
    n=read();int fa;
    if (n==1){
        puts("1");
        return 0;
    }
    for (int i = 1;i <= n;i ++){
        fa=read();
        if (fa==i){s=i;continue;}
        addedge(fa,i);
    }
    for (int i = 1;i <= n;i ++) sum[i]=sum[i-1]+i;
    for (int i = head[s]; i ;i = e[i].nxt){//分子树讨论
        int v=e[i].v;
        fill(num+1,num+n+1,0);
        dfs(v,s);
        for (int j = 1;j <= n;j ++) ans+=sum[num[j]-1]*2;//情况1
        ans+=sz[v]*(n-sz[v]-1);情况4
    }
    cout <<ans+n+(n-1)*2;//情况2，3
    return 0;
}
```
tips：数组也要开 ll，或计算时强制转换。

---

## 作者：lzx111218 (赞：0)

# P11624 [迷宫寻路 Round 3] 挂掉的模板
[题目传送门](https://www.luogu.com.cn/problem/P11624)
## 思路

FakeLCA 是通过不断让两个节点向上移动，直到它们相遇，根节点的父节点是它自身，而不是其他节点。真正的 LCA 是两个节点的最近公共祖先。如果 $\operatorname{FakeLCA(u, v)}$ 结果与 LCA 相同，说明在 FakeLCA 的过程中，两个节点相遇的节点恰好是它们的真正 LCA。换句话说，节点对 $(u, v)$ 满足条件的情况是当一个节点是另一个节点的祖先时，FakeLCA 会返回该祖先节点，从而与真正的 LCA 相同。

我们首先需要根据父节点数组构建树，用 **DFS** 计算每个节点的深度和子树的大小。然后，对于每对节点 $(u, v)$，我们可以利用树的结构来判断它们的 FakeLCA 是否等于真实的 LCA。具体来说，如果某个节点是另一个节点的祖先，FakeLCA 会返回这个节点，因此只需要判断一个节点是否是另一个节点的祖先。

由于题目中节点数最多为 $10^6$，暴力方法遍历每一对节点的时间复杂度为 $O(n^2)$，显然不适用。肯定会 T 飞，因此，可以利用树的深度、子树大小等信息，通过 **DFS** 优化计算过程。通过合理使用树的结构特点，能避免 TLE，最后输出结果即可。


```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000005;
const int MAXM = MAXN * 2; 

int V[MAXM][2]; 
int H[MAXN]; 
int N[MAXM]; 
int E = 0; 

void addEdge(int u, int v) {
    V[E][0] = v;
    N[E] = H[u];
    H[u] = E++;
}

int n, r = 0;
int S[MAXN], D[MAXN], C[MAXN];
long long A;

void dfs1(int u, int f) {
    S[u] = 1;
    for (int e = H[u]; e != -1; e = N[e]) {
        int v = V[e][0];
        if (v == f) continue;
        dfs1(v, u);
        S[u] += S[v];
        if (u == r) A += 1LL * S[v] * (n - S[v]);
    }
}

int P[MAXN], pos;

void dfs2(int u, int f) {
    P[++pos] = u;
    D[u] = D[f] + 1;
    A -= 1LL * C[D[u]] * C[D[u]];
    C[D[u]]++;
    A += 1LL * C[D[u]] * C[D[u]];
    for (int e = H[u]; e != -1; e = N[e]) {
        int v = V[e][0];
        if (v != f) dfs2(v, u);
    }
}

int main() {
    // Use scanf and printf
    scanf("%d", &n);
    
    memset(H, -1, sizeof(H));
    
    for (int i = 1; i <= n; i++) {
        int f;
        scanf("%d", &f);
        if (f == i) {
            r = i;
            continue;
        }
        addEdge(i, f);
        addEdge(f, i);
    }

    dfs1(r, 0);
    for (int e = H[r]; e != -1; e = N[e]) {
        pos = 0;
        dfs2(V[e][0], r);
        for (int i = 1; i <= pos; i++) {
            C[D[P[i]]] = 0;
        }
    }

    printf("%lld", A + n);
    return 0;
}

```

---

## 作者：_zuoqingyuan (赞：0)

# 思路分析

假设根为 $r$，显然根的情况比较特殊，因为 $r$ 的父亲也是 $r$。

我们枚举一个点 $u$，然后数符合条件的 $v$ 的个数。所以我们分两种情况讨论：

1. $u,v$ 的最近公共祖先不是 $r$。

想要满足这种情况，则必须满足：

- $u,v$ 的根 $r$ 某个儿子 $s$ 的子树内。

- $u,v$ 深度相同（否则会条过）

我们枚举 $r$ 的每个儿子 $s$，然后分别 DFS 两次，一次求深度，一次统计答案。注意每统计完一个儿子后要清空，

2. $u,v$ 的最近公共祖先是 $r$。

想要满足这个种情况，假设 $u$ 的 $r$ 的儿子 $s$ 的子树内，则 $v$ 一定不在 $s$ 的子树中。

预处理出每个节点的子树大小 $siz$，则符合条件的 $v$ 的个数即为 $n-siz_s$。

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <map>
#include <cstdio>
#include <vector>
using namespace std;
const int N=1e6+10;
typedef long long ll;
int n,p,rt;
vector<int>G[N];
map<int,ll>mp;
ll ans,siz[N];
void dfs1(int x,int de){
    mp[de]++,siz[x]=1;
    for(auto y:G[x])dfs1(y,de+1),siz[x]+=siz[y];
}
void dfs2(int x,int de,int tp){
    ans+=mp[de]+n-siz[tp];
    for(auto y:G[x])dfs2(y,de+1,tp);
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&p);
        if(p==i)rt=i;
        else G[p].push_back(i);
    }
    for(auto s:G[rt]){
        dfs1(s,1);
        dfs2(s,1,s);
        mp.clear();
    }
    ans+=n;
    printf("%lld\n",ans);
    return 0;
}
```

---


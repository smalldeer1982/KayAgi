# [蓝桥杯 2024 省 B 第二场] 狡兔 k 窟

## 题目描述

一只兔子名叫小蓝，它异常狡猾，在土中挖了若干洞窟并且设置了很多出入口来应对紧急情况。它一共有 $n$ 个通往地面的出入口，在地面上这 $n$ 个出入口之间由 $n - 1$ 条长度为 $1$ 的双向通路连成一个连通图。第 $i$ 个出入口属于第 $c_i$ 个洞窟，因此小蓝可以在任意一个属于 $c_i$ 的出入口从地面进入洞窟然后从任意一个属于 $c_i$ 的出入口跑出到达地面。

小蓝提出了 $m$ 个逃跑路线，第 $i$ 个路线希望从出入口 $s_i$ 逃往 $t_i$，它希望在逃跑的过程中在地面上跑动的距离尽可能短，请为每条路线计算逃跑时在地面上跑动的最短距离。

## 说明/提示

### 评测用例规模与约定
- 对于 $20\%$ 的评测用例，$1 \leq n, m, c_i \leq 100$；
- 对于所有评测用例，$1 \leq n, m, c_i \leq 5000$，$1 \leq u_i, v_i, s_i, t_i \leq n$。

## 样例 #1

### 输入

```
6 3
1 3 2 1 2 3
1 2
1 3
2 4
2 5
3 6
2 6
3 2
4 3```

### 输出

```
0
1
1```

# 题解

## 作者：lym2022 (赞：4)

### 题目分析
题目说可以在任意一个属于 $c_i$ 的出入口从地面进入洞窟然后从任意一个属于 $c_i$ 的出入口跑出到达地面，这句话可以理解为所有 $c_i$ 相同的点都是互通的，两两之间可以瞬移。

### 思路
题目要求的是在地面上跑动的距离，跟进入洞窟后移动的距离无关，**所以可以将所有 $c_i$ 相同的点视作是一个集合**，这些点的所属的集合的编号就是 $c_i$，然后将给定的边转化为集合之间的边，然后就可以在新的图中跑最短路了，因为边权是 $1$，就可以 bfs。剩下的就是用 bfs 遍历图的模版了。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e3 + 5;

int n,q,c[N];

vector<int> e[N];

bool vis[N];

void bfs(int s,int t) {
	memset(vis,0,sizeof(vis));   //多测初始化！！！ 
	queue<pair<int,int> > q;
	q.push({s,0});    //first是当前点，second是当前步数 
	while(!q.empty()) {
		int u = q.front().first;
		int step = q.front().second;
		q.pop();
		if(u == t) {
			cout << step << '\n';  //搜到了就输出，bfs首解最优 
			return;
		}
		if(vis[u]) continue;   //走过了就跳过 
		vis[u] = true;         //标记 
		for(auto v : e[u]) q.push({v,step+1});   //将所有的与 u 相邻的点入队 
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> q;
	for(int i = 1;i<=n;i++) cin >> c[i];
	for(int i = 1;i<n;i++) {
		int u,v;
		cin >> u >> v;
		e[c[u]].push_back(c[v]);   //给两个集合间加边
		e[c[v]].push_back(c[u]);   //双向边 
	}
	while(q--) {
		int s,t;
		cin >> s >> t;
		bfs(c[s],c[t]);   //找集合间的最短路 
	}
	return 0;
}
```
点个赞再走吧！

---

## 作者：FJ_EYoungOneC (赞：3)

### 题意分析

有一个 $n$ 个点，$n-1$ 条边的无向图，边权均为 $1$。

每个点属于一个集合，同一个集合的点可以互相传送。

给定 $m$ 个询问，求 $x, y$ 的最短距离。

#### 最短路解法

步骤：

1. 建图。
2. 对于所有询问各跑一次最短路算法。

可选用的最短路算法：

- Spfa，单次时间复杂度 $O(n) \sim O(n^2)$，总时间复杂度 $O(n^2) \sim O(n^3)$。
- Dijkstra，单次时间复杂度 $O(n\log n)$，总时间复杂度 $O(n^2\log n)$。

#### 01 BFS 解法

观察发现，本题仅存在边权为 $0$ 和 $1$ 的边，故上述最短路算法存在多余开销，我们考虑使用 `BFS` 算法进行求解，并使用 `deque` 进行维护。

进行扩展时，若是边权为 $0$ 的边，则放入队头，反之放入队尾。

最坏时，每条边均扩展 $n$ 个点，单次时间复杂度 $O(n^2)$，总时间复杂度 $O(n^3)$。

#### BFS 解法

样例如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/aua7l8v3.png)
我们用虚线表示同一个组别中的连线。

![](https://cdn.luogu.com.cn/upload/image_hosting/r47lad8i.png)

合并 $1, 4$：

![](https://cdn.luogu.com.cn/upload/image_hosting/he1q5bza.png)
合并 $2, 6$：

![](https://cdn.luogu.com.cn/upload/image_hosting/05bj1rlf.png)
合并 $3, 5$：

![](https://cdn.luogu.com.cn/upload/image_hosting/0kil2r2p.png)
那么，在合并之后，当我们要算两个点之间的最短距离时，可以直接用 `BFS` 算法解决。

观察上图发现，因为组别内的点的边权为 $0$，所以我们可以将所有同一个组别的点进行合并，将点与点之间的最短路转换为组别与组别之间的最短路。

时间复杂度 $O(n^2)$。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <queue>

using namespace std;

const int N = 5e3 + 10, M = N * 4;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int belong[N];
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

void bfs(int u, int v)
{
    memset(dist, 0x3f, sizeof dist);
    memset(st, 0, sizeof st);
    dist[u] = 0;
    queue<int> q;
    q.push(u);
    
    while (q.size())
    {
        auto t = q.front();
        q.pop();
        
        for (int i = h[t]; ~i; i = ne[i] )
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                q.push(j);
            }
        }
    }
    
    cout << dist[v] << endl;
}

int main()
{
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;
    
    memset(h, -1, sizeof h);
    
    for (int i = 1; i <= n; ++ i )
    {
        int x;
        cin >> x;
        belong[i] = x;
    }
    
    for (int i = 1; i < n; ++ i )
    {
        int a, b;
        cin >> a >> b;
        a = belong[a], b = belong[b];
        add(a, b, 1), add(b, a, 1);
    }
    
    while (m -- )
    {
        int a, b;
        cin >> a >> b;
        bfs(belong[a], belong[b]);
    }
    
    return 0;
}
```

---

## 作者：Chengqijun2012 (赞：2)

# 题解：P12126 [蓝桥杯 2024 省 B 第二场] 狡兔 k 窟

## Updata 2025/7/24：更正了 bitset 的初始化复杂度。
## 题目大意：
有一张 $n$ 个节点 $n-1$ 条边的图，每条边的边权为 $1$，同时 $c_{i}$ 相同的节点可以互相瞬间到达。问每个 $s \to t$ 的最短路径。

## 解题思路：
我们可以把所有 $c_{i}$ 相同的节点当成一个连通分量（可以理解为一个大节点），并且每个连通分量内所有节点互相到达所用的时间都为 $0$，这样就能把题目中 $c_{i}$ 相同的情况忽略掉。

然后再跑最短路，一共有 $3$ 种算法供我们选择：
- Dijkstra：单次时间复杂度 $O(n \log n + E)$，总体时间复杂度 $O(mn \log n + Em)$。
- SPFA：单次平均时间复杂度 $O(kE)$，总体时间复杂度 $O(kEm)$。但有可能被一些~~毒瘤~~数据卡到 $O(nEm)$ 的复杂度。
- BFS：总体时间复杂度 $O(n^{2} \sim n^{3})$ 不等。

对比 $3$ 种算法后，发现 Dijkstra 和 SPFA 都必须遍历完所有节点。而 BFS 找到目标节点后便可直接输出，综合起来 BFS 复杂度下限更低，所以用 BFS 解决。

AC Code：
```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>
#include <climits>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
#include <bitset>
#include <cstdio>
#define ll long long
#define P pair<int, int>
#define MP make_pair
#define PU push_back
#define li(x) x << 1
#define ri(x) (x << 1) | 1
#define LLF LLONG_MAX >> 2
#define INF INT_MAX >> 1
using namespace std;
const int N = 5000 + 5;
int n, m, tot, head[N], d[N], c[N];
bitset<N> vis;      //可用bool数组代替，但时间和空间上都不占优

struct Edge{
	int u, v, w, nex;
}e[N << 1];

inline ll read(){
	ll f = 1, x = 0;
	char c = getchar();
	while(c < '0' || c > '9'){if(c == '-') f = -1; c = getchar();}
	while('0' <= c && c <= '9') x = (x << 3) + (x << 1) + (ll)(c - '0'), c = getchar();
	return x * f;
}

inline void write(ll x){
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

inline void add(int u, int v){
	e[++tot] = {u, v, 1, head[u]};
	head[u] = tot;
}

void BFS(int s, int t){
	vis = 0;      //bitset可以O(n/w)初始化（w为计算机的位数，一般w=32），bool数组只能O(n)
	queue<P> q;
	q.push({0, s});
	while(!q.empty()){
		int u = q.front().second;
		int stp = q.front().first;
		q.pop();
		if(u == t){      //找到了直接输出，BFS首解最优
			write(stp);
			putchar('\n');
			return;
		}
		if(vis[u]) continue;      //遍历过了就跳过，类似于Dijkstra
		vis[u] = true;     //没访问过就标记
		for(int i = head[u]; i; i = e[i].nex) q.push({stp + 1, e[i].v});	    //将所有相邻节点入队
	}
}

int main(){
    n = read(), m = read();
    for(int i = 1; i <= n; ++i) c[i] = read();
    for(int i = 1, u, v; i < n; ++i){
		u = read(), v = read();
		add(c[u], c[v]), add(c[v], c[u]);      //一定不要忘了加上c[]！！！
	}
	while(m--){
		int s, t;
		s = read(), t = read();
		BFS(c[s], c[t]);      //同上
	}
	return 0;
}
```
完结撒花！！！

---

## 作者：aizhoukai (赞：2)

## 题意分析

给定一张图，图中有 $n$ 个点，点与点之间有 $n-1$ 条边权为 $1$ 的点相连。同时，隶属于同一洞窟的点还互相有边权为 $0$ 的点相连。对于 $m$ 队 $x$ 和 $y$，你都需要求出 $x$ 到 $y$ 的最短距离。

## 思路

由于洞窟内的出入口之间的边边权为 $1$，所以在同一洞窟内的点可以视为一个点，因此我们可以重新建立一张图，这张图上的边权皆为 $1$ ，可以快乐 BFS。

单次时间复杂度为 $O(n)$，合计时间复杂度为 $O(nm)$。

## 实现

注意到原来的图并没有意义，所以我们可以在输入时直接建立经过处理后新的图。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,c[5001],b[5001],maxn;
vector<int> g[5001],vv;
map<int,bool> mm;
queue<pair<int,int>> q;
int bfs(int x,int y)
{
	q.push({c[x],0});
	for(int i=0; i<vv.size(); i++) //这里有很大的优化空间 
		b[vv[i]]=0;//朴素的初始化
	while(!q.empty())
	{
		int qx=q.front().first,qy=q.front().second;//这里的 qx 是当前洞窟的编号,qy 是当前的最短路程
		if(qx==c[y])
		{
			int ans=qy;
			while(!q.empty())
				q.pop();//手动清队列
			return ans;
		}
		for(int i=0; i<g[qx].size(); i++)
		{
			if(!b[g[qx][i]])
			{
				q.push({g[qx][i],qy+1});
				b[g[qx][i]]=1;//朴素的遍历
			}
		}
		q.pop();
	}
	return 0;
}
int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&c[i]);
		if(!mm[c[i]]){mm[c[i]]=1,vv.push_back(c[i]);}
	}
		
	for(int i=1,u,v; i<n; i++)
	{
		scanf("%d%d",&u,&v);
		g[c[u]].push_back(c[v]);
		g[c[v]].push_back(c[u]);
		//这里的边已经是按照洞窟而非出入口来建的
	}
	int x,y;
	while(m--)//少用一个变量
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",bfs(x,y));
	}
	return 0;
}
```

---

## 作者：Bill_luogu (赞：1)

## 题目思路：
用 BFS。（因为 Dijkstra 时间复杂度为 $O(mn\log n+m^2)$，会 TLE）
## BFS 步骤
先把 $c_{s_{i}}$ 加入队列，再从 $c_{s_{i}}$ 开始 BFS，走过的点标记为 $1$。因为是 BFS，所以一旦搜到 $c_{t_{i}}$ 即可输出答案（把 $c_{u_{i}}$ 和 $c_{v_{i}}$ 连双向边），时间复杂度 $O(nm)$。

记得清空！！！
## AC Code：
```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstring>
using namespace std;
bool vis[5010];
struct node{
	int x,step;
};
queue<node> q;
vector<int> v[5010];
int n,m;
int c[5010];
//int ans;
void bfs(int st,int ed)
{
	memset(vis,0,sizeof vis);
	while(q.size())q.pop();
	q.push((node){st,0});
	while(q.size())
	{
		node now=q.front();
		q.pop();
		if(now.x==ed)
		{
			cout<<now.step<<'\n';//输出答案
			return;
		}
		if(vis[now.x])continue;
		vis[now.x]=1;
		for(int i=0;i<v[now.x].size();i++)
			q.push((node){v[now.x][i],now.step+1});
	}
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>c[i];
	for(int i=1,x,y;i<n;i++)
	{
		cin>>x>>y;
        //连边
		v[c[x]].push_back(c[y]);
		v[c[y]].push_back(c[x]);
	}
	while(m--)
	{
		int x,y;
		cin>>x>>y;
		bfs(c[x],c[y]);//开始 BFS
	}
	return 0;
} 
```
然后我们就愉快的 AC 啦！

---

## 作者：yanzixuan2024 (赞：0)

因为每个点 $x$ 的操作都建立在它所属于的 $c_x$ 上，所以我们连边、建图都是 $c_i$ 来操作。题目要求我们为每条路线计算逃跑时在地面上跑动的最短距离，我们就可以建图，跑一遍最短路。

因为边权全部为 $1$，所以考虑 BFS。保存每一个点从起点到达的最短路径 $step$，但注意 $step$ 初始化全部为 $-1$。$step$ 初始化为 $0$ 时只有 $45$ 分，因为在自环情况下，初始化为 $0$ 就是把自己认作了自己的邻居，使得自己到自己的距离为 $1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5005;
int n,m,c[maxn];
vector<int> vec[maxn];
int step[maxn];
int bfs(int st,int en){
	memset(step,-1,sizeof step);
	queue<int> q;
	q.push(st),step[st]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		if(u==en) return step[en];
		for(auto i:vec[u]){
			if(step[i]==-1) q.push(i),step[i]=step[u]+1;
		}
	}
	return 0;
}
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d",c+i);
	for(int i=1;i<n;++i){
		int x,y;
		scanf("%d %d",&x,&y);
		vec[c[x]].push_back(c[y]),vec[c[y]].push_back(c[x]);
	}
	while(m--){
		int x,y;
		scanf("%d %d",&x,&y);
		printf("%d\n",bfs(c[x],c[y]));
	}
}
```

---


# [蓝桥杯 2025 国 Python A] 巡逻

## 题目背景

建议 Python 用户选择 PyPy3 提交本题。

## 题目描述

边境森林中分布着若干重要的哨站，所有哨站之间由隐秘小径相连，形成一张天然的巡逻网络。这张网络的结构恰好是一棵树。为了防止敌人渗透，小蓝每天需要执行固定长度为 $k$ 的巡逻任务。每次巡逻从一个哨站出发，经过不重复地恰好 $k$ 条道路，最终到达另一个哨站。每条道路都有一定的危险值，巡逻路径上危险值的和代表该次巡逻时的风险。两次巡逻路径不相同当且仅当它们的起点不同或终点不同。

现在指挥官希望知道，所有可能的长度为 $k$ 的巡逻路线的风险之和是多少？

## 说明/提示

**【样例说明】**

所有可能的路径及其风险值如下：

- $1 \rightarrow 2 \rightarrow 4: 8$
- $2 \rightarrow 1 \rightarrow 3: 10$
- $1 \rightarrow 3 \rightarrow 5: 10$
- $1 \rightarrow 3 \rightarrow 6: 11$
- $5 \rightarrow 3 \rightarrow 6: 7$
- $3 \rightarrow 6 \rightarrow 7: 6$

以上路径反过来也是合法的，所以总共有 14 条不同的路径，风险之和为 104。

**【评测用例规模与约定】**

对于 40% 的评测用例，$1 \leq n \leq 500$；

对于所有评测用例，$1 \leq n \leq 5000$，$1 \leq k \leq n$，$1 \leq u_i, v_i \leq n$，$1 \leq w_i \leq 10^6$。

## 样例 #1

### 输入

```
7 2
1 2 3
2 4 5
1 3 7
3 5 3
3 6 4
6 7 2```

### 输出

```
104```

# 题解

## 作者：DreamInk (赞：4)

# 题目描述
从任意一个哨站出发巡逻，经过**不重复地恰好 $k$ 条道路**，最终到达另一个哨站，每一条道路都有危险值，而巡逻的危险值就是巡逻路径上危险值和。
  
**注意：两次巡逻路径不相同当且仅当它们的起点不同或终点不同**（简单说只要起点不同或者终点不同就算不同路径）。


# 思路
我们可以发现这道题目 $n$ 的范围在 $1\leq n \leq 5000$，可以暴力搜索，就是一道简单的 $\text{dfs}$ 题。枚举每一个哨站 $i$，计算以 $i$ 作为起点经过恰好 $k$ 条道路所有危险值和，用 $sum$ 来表示。当所有哨站枚举完，以每个哨站为起点的 $sum$ 和就是所有可能的长度为 $k$ 的巡逻路线的风险之和。
因为 $w_i \leq 10^6$，累加会爆 ```int```，所以要开 ```long long```。
# 100pts Code
考虑用动态数组来存储边，可以直接得到 $i$ 与哪些哨站存在道路。

```
#include<iostream>
#include<vector>
using namespace std;
long long n,k,ans,u,v,w;
struct node{
	int v,w;
};
vector<node> G[10005];
bool vis[5005];//标记数组：标记已经走过的哨站，防止重复经过。 
void dfs(int id,int cnt,int sum){
	if(cnt==k){//已经恰好经过 k 条道路 
		ans+=sum;//累加以 i 为起点恰好经过 k 条道路的危险值 
		return;
	}
	for(int i=0;i<G[id].size();i++){//直接遍历与 u 相连的每一个哨站 
		int v=G[id][i].v,w=G[id][i].w;
		if(vis[v]==0){
			vis[v]=1;//标记
			dfs(v,cnt+1,sum+w);
			vis[v]=0;//回溯 
		}
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<n;i++){
		cin>>u>>v>>w;
		G[u].push_back((node){v,w});//动态数组以结构体的方式来存储边 
		G[v].push_back((node){u,w});//两哨站之间有道路，可以从 u 走到	v ，也可以从 v 走到 u ，所以要双向存边
	}
	for(int i=1;i<=n;i++){
		vis[i]=1;//标记起点，防止二次经过起点 
		dfs(i,0,0);
		vis[i]=0;
	}
	cout<<ans<<'\n';//输出总恰好经过 k 条道路的危险值 
	return 0;
}
```
# 完结撒花
如果这篇题解对您有帮助，就点个赞吧。

这是蒟蒻的第一篇题解，求管理员大大通过。

---

## 作者：guoshengyu1231 (赞：3)

# 前言
看了看别人的代码，居然还有用树形动态规划的，甚至还跑到了最优解。蒟蒻我根本看不懂，所以我还是来写一篇 LCA 的题解吧。话说这么好的 LCA 模板题，居然还没有 LCA 的标签，还是我第一个加上去的。那么废话不多说，直接上思路。
# 思路
题目要求在一棵树当中求任意两点之间距离为 $k$ 的所有路径的边权之和，而且要求走过的边都不重复。很容易想到，在**一棵树**当中，要求走过的边都不重复，其实就是在求最短距离，这时候我们就需要引入一个概念——**最近公共祖先 LCA**。


---


## 什么是最近公共祖先？
最近公共祖先，顾名思义，就是在一棵树中，两点 $a,b$ 的所有的公共祖先中与他们最近的，便是点 $a$ 与点 $b$ 的最近公共祖先，所以最近公共祖先的概念其实是很好理解的。
## 最近公共祖先有什么用？
虽然最近公共祖先的概念听着非常简单，但它却非常有用，比如我们要求一棵树中两点之间的最短距离，只需要算出他们的最近公共祖先 $lca$，那么两点之间的最短距离就等于点 $a$ 到根节点的距离加上点 $b$ 到根节点的距离减去两倍的点 $lca$ 到根节点的距离，所以只要我们能快速地算出最近公共祖先，我们就能快速地算出任意两点的最短距离。
## 如何求最近公共祖先？
那么现在问题又来了，如何求任意两点的 LCA？我们不妨先从暴力的角度出发。 $\\$ 
对于任意两点，我们可以首先将他们升至同一层，然后同步向上升，最后他们肯定会相遇，相遇的那一个点就是他们的最近公共祖先，但这样每一次计算的时间复杂度是 $O(n)$，还是不够优秀，所以我们需要考虑优化。 $\\$ 
那具体该怎么优化呢？我们观察暴力法的求解方案，可以发现我们都是在一步一步往上升，这样肯定很浪费时间。所以我们考虑倍增优化，首先建立 ST 表，用 $dp_{i,j}$ 表示从节点 $i$ 往上升 $2^j$ 步会到达的节点，可以很容易得到 $dp_{i,0}=f_i,dp_{i,j}=dp_{dp_{i,j-1},j-1}$。其中 $f_i$ 为 $i$ 的父节点。 $\\$ 
那么有了 ST 表，我们可以快速算出最近公共祖先，具体代码如下：

```cpp
int getlca(int x,int y)//求x,y的LCA
{
	if(dep[x]<dep[y]) swap(x,y);//保证x是较深的节点
	for(int i=log2(n);i>=0;i--)//枚举步长
	 if(dep[x]-(1<<i)>=dep[y]) x=dp[x][i];//将x升至与y同一层
	if(x==y) return x;//特判x与y在一条链上的情况
	for(int i=log2(n);i>=0;i--)//枚举步长
	 if(dp[x][i]!=dp[y][i]) x=dp[x][i],y=dp[y][i];//同时上升
	return dp[x][0];
}
```


---
接下来思路便非常简单了，枚举任意两点，利用最近公共祖先计算出两点的距离，判断是否等于 $k$ ，如果等于，就利用最近公共祖先计算出两点之间的**加权**距离，最后累加答案即可。
# 代码
## C++：
```cpp
#include<bits/stdc++.h>
#define fir first
#define sec second
#define int long long //一定要开long long！
using namespace std;
typedef pair<int,int> P;
const int maxn=5005;
int n,k,dep[maxn],dis[maxn],ans;//dep是深度，dis是边权距离
int dp[maxn][15];//ST 表
vector<P> g[maxn];//first存下一个点，second存边权
void dfs(int u,int d1,int d2,int f)//预处理dep,dis,dp
{
	dp[u][0]=f;//向上一步就是它的爸爸
	dep[u]=d1;dis[u]=d2;
	for(int i=0;i<g[u].size();i++)
	 {
	 	int v=g[u][i].fir;
	 	if(v==f) continue;
	 	dfs(v,d1+1,d2+g[u][i].sec,u);
	 }
} 
void init_ST()
{
	for(int j=1;j<=log2(n);j++)
	 for(int i=1;i<=n;i++)
	  dp[i][j]=dp[dp[i][j-1]][j-1];
}
int getlca(int x,int y)//求x,y的LCA
{
	if(dep[x]<dep[y]) swap(x,y);//保证x是较深的节点
	for(int i=log2(n);i>=0;i--)//枚举步长
	 if(dep[x]-(1<<i)>=dep[y]) x=dp[x][i];//将x升至与y同一层
	if(x==y) return x;//特判x与y在一条链上的情况
	for(int i=log2(n);i>=0;i--)//枚举步长
	 if(dp[x][i]!=dp[y][i]) x=dp[x][i],y=dp[y][i];//同时上升
	return dp[x][0];
}
signed main()
{
	cin>>n>>k;
	for(int i=1;i<n;i++)
	 {
	 	int x,y,c;cin>>x>>y>>c;
	 	g[x].push_back(P{y,c});
	 	g[y].push_back(P{x,c});
	 }
	dfs(1,0,0,0);
	init_ST();//初始化ST表
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=n;j++)
	  {
	  	int lca=getlca(i,j);
	  	int len=dep[i]+dep[j]-2*dep[lca];
	  	if(len==k) ans+=dis[i]+dis[j]-2*dis[lca];
	  }
	cout<<ans;
	return 0;
}
```
## Python：

```python
import sys
import math
from collections import deque

def main():
    sys.setrecursionlimit(1 << 25)
    n, k = map(int, sys.stdin.readline().split())
    g = [[] for _ in range(n+1)]  # 邻接表
    
    for _ in range(n-1):
        x, y, c = map(int, sys.stdin.readline().split())
        g[x].append((y, c))
        g[y].append((x, c))
    
    LOG = int(math.log2(n)) + 1
    dp = [[0]*(n+1) for _ in range(LOG)]
    dep = [0]*(n+1)
    dis = [0]*(n+1)
    
    # BFS预处理
    q = deque([1])
    dp[0][1] = 0  # 根节点的父节点设为0
    dep[1] = 0
    
    while q:
        u = q.popleft()
        for v, c in g[u]:
            if v != dp[0][u]:
                dp[0][v] = u
                dep[v] = dep[u] + 1
                dis[v] = dis[u] + c
                q.append(v)
    
    # 初始化ST表
    for j in range(1, LOG):
        for i in range(1, n+1):
            dp[j][i] = dp[j-1][dp[j-1][i]]
    
    def get_lca(x, y):
        if dep[x] < dep[y]:
            x, y = y, x
        # 将x提到与y同一深度
        for j in range(LOG-1, -1, -1):
            if dep[x] - (1 << j) >= dep[y]:
                x = dp[j][x]
        if x == y:
            return x
        for j in range(LOG-1, -1, -1):
            if dp[j][x] != dp[j][y]:
                x = dp[j][x]
                y = dp[j][y]
        return dp[0][x]
    
    ans = 0
    for i in range(1, n+1):
        for j in range(1, n+1):
            lca = get_lca(i, j)
            distance = dep[i] + dep[j] - 2 * dep[lca]
            if distance == k:
                ans += dis[i] + dis[j] - 2 * dis[lca]
    
    print(ans)

if __name__ == "__main__":
    main()

```

# 结语
代码的时间复杂度 $O(n^2\log n)$，不是很优秀。当然，这么写可以 AC，期待你的新思路！ $\\$ 
对了，如果这篇题解对你有帮助的话，那就点个赞吧。

---

## 作者：chrispang (赞：2)

这道题只需要朴素 DFS 就可以，不需要优化与剪枝。

具体操作：枚举每一个点 $x$，向 $x$ 的邻点进行拓展，转移过程中记录边权总和。在经过 $k$ 条边后，将总和记录答案。

时间复杂度为 $O(n^2)$，注意要开 `long long`。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 5010;

int n, k, ans;
bool vis[N];
struct node {
	int v, w;
};

vector<node> linker[N];
void add(int x, int y, int w) { linker[x].push_back({y, w}); }
void dfs(int x, int cnt, int sum) {
	if (cnt == k) {
		ans += sum;
		return ;
	}
	for (auto i : linker[x]) { //直接遍历与 u 相连的每一个哨站
		int v = i.v, w = i.w;
		if (!vis[v]) {
			vis[v] = 1;
			dfs(v, cnt + 1, sum + w);
			vis[v] = 0;
		}
	}
}

signed main() {
	cin >> n >> k;
	for (int i = 1, u, v, w; i < n; i++) {
		cin >> u >> v >> w;
		add(u, v, w);
		add(v, u, w);
	}
	for (int i = 1; i <= n; i++) {
		vis[i] = 1;
		dfs(i, 0, 0);
		vis[i] = 0;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Gilbert1206 (赞：2)

## 题解：P12874 [蓝桥杯 2025 国 Python A] 巡逻

[题目传送门](https://www.luogu.com.cn/problem/P12874)

## 思路

一道比较模板的 DFS 题，让你现在走不重复的 $k$ 步，求出这些路径的危险值的总和。首先要思考一个问题，为什么不能用 BFS 呢？答案很简单，因为 BFS 很难记录你是否走没走重复的路径。这道题用 DFS，其实只需要一个动态数组，记录那两条边有一条线路和路的权值为多少。这道题并且需要回溯，找到多条路径的综合，再那一个标记数组看是否走过这个点就可以了。

## code


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,ans;
vector<pair<int,int> >a[10005];
int vis[10005];
void dfs(int step,int now,int vi){
	if(vis[now]==1){//标记判重
		return;
	}
	if(step==m){//步数有了m步则不能再进行了，把答案加上。
		ans+=vi;
		return;
	}
	for(int i=0;i<a[now].size();i++){
		vis[now]=1;
		dfs(step+1,a[now][i].first,vi+a[now][i].second);//递归到下一层
		vis[now]=0;//回溯
	}
}
signed main(){
	cin>>n>>m;
	for(int i=0;i<n-1;i++){
		int ap,bp,w;
		cin>>ap>>bp>>w;
		a[ap].push_back({bp,w});
		a[bp].push_back({ap,w});
	} 
	for(int i=1;i<=n;i++){//从每个点开始寻找
		dfs(0,i,0);
	}
	cout<<ans;
    return 0;
}

```

---

## 作者：yihang2011 (赞：0)

### [P12874 [蓝桥杯 2025 国 Python A] 巡逻](https://www.luogu.com.cn/problem/P12874)

UPD 2025.8.15：

> 边权和同理，为 $dis_u + dis_v - 2 \times dis_{\text{lca}(u, v)}$。

误作

> 边权和同理，为 $dis_u + dis_v - dis_{\text{lca}(u, v)}$。

感谢大佬 [闻笛笑](https://www.luogu.com.cn/user/387929) 的指正，%%%。

---

LCA 板子题。

可怜的我读完题，就在想怎么优化，心想 $\mathcal{O}(n^2)$ 肯定是过不了的，~~然后瞟了半眼数据范围，嗯果然~~，又瞟了一眼，发现 $n \le 5000$，很好暴力秒了。

首先，先打好 LCA 板子，然后看题，给定一个带边权的树，求所有所有两个点点对树上路径为 $k$ 的路径上边权和的和。

记点 $u$ 的深度为 $dep_u$，$1 \rightarrow u$ 的边权和为 $dis_u$，这两个数组都可以在 LCA 初始化的同时求得。

以树上距离为例，树上路径 $u \rightarrow v$ 一定会经过 $\text{lca}(u, v)$，所以路径 $u \rightarrow v$ 可以拆成路径 $u \rightarrow \text{lca}(u, v)$ 和 $v \rightarrow \text{lca}(u, v)$，而 $dep_{\text{lca}(u, v)} \le dep_u, dep_v$，所以点 $u$ 到点 $\text{lca}(u, v)$ 的距离为 $dep_u - dep_{\text{lca}(u, v)}$，点 $v$ 同理，所以点 $u$ 到点 $v$ 的距离为 $dep_u + dep_v - dep_{\text{lca}(u, v)}$。边权和同理，为 $dis_u + dis_v - 2 \times dis_{\text{lca}(u, v)}$。

然后遍历点对，对于点对 $(u, v) \space (u < v)$，如果它们的距离为 $k$，那么加上它们路径的点权和，最后由题目可知，答案应乘 $2$。

时间复杂度 $\mathcal{O}(n^2)$。

C++ 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, l, r) for (int i = l; i <= r; i++) 
#define rrep(i, r, l) for (int i = r; i >= l; i--)
#define lrep(i, from, nxt) for (int i = from; i; i = nxt)
#define arep(x, s) for (auto &s : x)
#define pb push_back
#define mp make_pair
#define pqueue priority_queue
#define umap unordered_map
using ll = long long;

int rd() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0', ch = getchar();
    }
    return x * f;
}

const int N = 5010;
int n, k;
vector<pair<int, int>> g[N];
int f[N][25], dep[N], dis[N];

void dfs(int u, int pa, int w) {
    dis[u] = dis[pa] + w;
    dep[u] = dep[pa] + 1;
    f[u][0] = pa;
    rep(i, 1, 15) {
        f[u][i] = f[f[u][i - 1]][i - 1];
    }
    arep(g[u], edge) {
        int v = edge.first, w = edge.second;
        if (v == pa) {
            continue ;
        }
        dfs(v, u, w);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) {
        swap(u, v);
    }
    rrep(i, 15, 0) {
        if (dep[f[u][i]] >= dep[v]) {
            u = f[u][i];
        }
    }
    if (u == v) {
        return u;
    }
    rrep(i, 15, 0) {
        if (f[u][i] != f[v][i]) {
            u = f[u][i], v = f[v][i];
        }
    }
    return f[u][0];
}

int main() {
    n = rd(), k = rd();
    rep(i, 1, n - 1) {
        int u = rd(), v = rd(), w = rd();
        g[u].pb(mp(v, w)), g[v].pb(mp(u, w));
    }
    dfs(1, 0, 0);
    ll ans = 0;
    rep(i, 1, n) {
        rep(j, i + 1, n) {
            int a = lca(i, j);
            if (dep[i] + dep[j] - 2 * dep[a] == k) {
                ans += dis[i] + dis[j] - 2 * dis[a]; 
            } 
        }
    }
    cout << ans * 2 << endl;
    return 0;
}
```

Python 65 分不知道为什么有 RE 有 TLE，过不了。

---

## 作者：chenyanyu1 (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P12874)
## 思路
因为 $n\le 5000$，所以这道题可以直接暴力 dfs 解决。我们可以定义 dfs$(u,f,s)$ 表示起点为 $u$，上一个遍历点为 $f$，已经走了 $s$ 条路。便能写出核心代码：
```ccp
void dfs(int u,int f,int s)
{
	if(k==s)
		ans+=sum;
	for(pair<int,int> v:g[u])
		{
			if(v.first==f)
				continue;
			sum+=v.second;
			dfs(v.first,u,s+1);
			sum-=v.second;
		}
}
```
最后再加上输入之类的便能得到完整代码。
## Code
```ccp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,ans,sum,k;
vector<pair<int,int> > g[5005];
void dfs(int u,int f,int s)
{
	if(k==s)
		ans+=sum;
	for(pair<int,int> v:g[u])
		{
			if(v.first==f)
				continue;
			sum+=v.second;
			dfs(v.first,u,s+1);
			sum-=v.second;
		}
}
signed main()
{
	cin>>n>>k;
	for(int i=1;i<n;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		g[u].push_back({v,w});
		g[v].push_back({u,w});
	}
	for(int i=1;i<=n;i++)
		dfs(i,i,0);
	cout<<ans;
	return 0;
}
```
[AC](https://www.luogu.com.cn/record/221530192)

---

## 作者：yanzixuan2024 (赞：0)

直接爆搜水过。

每次选一个点作为此树的根，然后每次深搜时步数加一，距离加边权，直到步数等于 $k+1$ 时，就是要停下来了，答案加上目前走过的距离。全部这么走一遍就行了，没什么好说的。

Python 代码：

```cpp
maxn = 114514

class Node:
    def __init__(self, v, w):
        self.v = v
        self.w = w

n, x, y, z, k = 0, 0, 0, 0, 0
sum = 0
v = [[] for _ in range(maxn)]

def dfs(x, f, step, dis):
    global sum
    if step > k:
        sum += dis
        return
    for i in v[x]:
        v_node = i.v
        w = i.w
        if v_node == f:
            continue
        dfs(v_node, x, step + 1, dis + w)

n, k = map(int, input().split())
for _ in range(n - 1):
    x, y, z = map(int, input().split())
    v[x].append(Node(y, z))
    v[y].append(Node(x, z))

for i in range(1, n + 1):
    dfs(i, -1, 1, 0)

print(sum)
```

---

## 作者：jinfanhao (赞：0)

这道题数据范围如此小，直接爆搜！\
先是遍历每一个点，把每一个哨站都当作起点爆搜一遍。\
然后每回找到与其相连的点，并打上标记，如果走过了，那么便跳过。\
最后如果走到了距离为 $k$ 的，那么停止，并把路上的危险值给加上答案。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e3+1;
int n,m,u[N],v[N],w[N],ans;
struct edge{
	int v,w;
};
bool ok[N];
vector<edge> g[N];
void dfs(int now,int sum,int u){
	if(u==m+1){
		ans+=sum;
		return;
	}
	for(int i=0; i<g[now].size(); ++i){
		int v=g[now][i].v,w=g[now][i].w;
		if(ok[v])continue;
		ok[v]=true;
		dfs(v,sum+w,u+1);
		ok[v]=false;
	}
}
signed main(){
   	scanf("%lld%lld",&n,&m);
   	for(int i=1; i<n; ++i){
   		scanf("%lld%lld%lld",&u[i],&v[i],&w[i]);
		g[u[i]].push_back({v[i],w[i]});
		g[v[i]].push_back({u[i],w[i]});
	}
	for(int i=1; i<=n; ++i){
		ok[i]=true;
		dfs(i,0,1);
		ok[i]=false;
	}
	printf("%lld",ans);
   	return 0;
}
```

本蒟蒻不会 python, 所以运用了一款智能工具，请管理员大大谅解……

```cpp
n,m=map(int, input().split())
u=[0]*(n)
v=[0]*(n)
w=[0]*(n)
ans=0
g=[[]for _ in range(n + 1)]
for i in range(1, n):
    u[i], v[i], w[i] = map(int, input().split())
    g[u[i]].append((v[i], w[i]))
    g[v[i]].append((u[i], w[i]))

def dfs(now,sum_val,u_val,fa):
    if u_val==m+1:
        ans+=sum_val
        return
    for v_node,w_node in g[now]:
        if v_node==fa:
            continue
        dfs(v_node,sum_val+w_node,u_val+1,now)
for i in range(1,n+1):
    dfs(i,0,1,-1)
print(ans)
```

---

## 作者：tuboshu666 (赞：0)

# 前置知识：LCA

# 思路
注意到 $n \leq 5000$，容易想到 $O(n^2)$ 枚举每个点对。若两个点距离恰好为 $k$，则答案加上该路径上的风险之和即可。

问题在于：要怎么高效地求出一条路径的长度及这条路径的边权和？容易想到树上前缀和。

![](https://cdn.luogu.com.cn/upload/image_hosting/pzk0vg6o.png)

通过一次 dfs，求出从根节点到每个节点的深度和边权之和。分别记作 $d$ 和 $sum$。观察上图，要求 $5$ 和 $6$ 的边权和，可以通过 $5$ 和 $6$ 到根节点的边权之和减去他们 $lca$ 到根节点的边权和的两倍来构造。

记 $u$ 和 $v$ 的 $lca$ 为 $h$，则 $u$ 到 $v$ 的边权和为 $sum_u + sum_v - 2 \times sum_h$。

同理：$u$ 到 $v$ 的距离为 $d_u + d_v - 2 \times d_h$。因为深度可以看做边权为 $1$ 的边的累加。

有了树上前缀和，剩下的就很好做了。

# Code
```cpp
#include <iostream>
#include <math.h>
#include <vector>
using namespace std;

struct node
{
    int v,w;
};

const int N = 5010;
vector<node> g[N];
int fa[N][15],d[N];
long long sum[N];
int n,k;

void dfs(int pos, int pre)
{
    d[pos] = d[pre] + 1;
    fa[pos][0] = pre;
    for (int i = 1 ; i < 15 ; i++) fa[pos][i] = fa[fa[pos][i-1]][i-1];

    for (int i = 0 ; i < g[pos].size() ; i++)
    {
        int to = g[pos][i].v;
        int val = g[pos][i].w;
        if (to == pre) continue;
        sum[to] = sum[pos] + val;
        dfs(to,pos);
    }
}

int lca(int u, int v)
{
    if (d[u] < d[v]) swap(u,v);
    for (int i = 14 ; i >= 0 ; i--)
    {
        if (d[fa[u][i]] >= d[v])
        {
            u = fa[u][i];
        }
    }
    if (u == v) return u;

    for (int i = 14 ; i >= 0 ; i--)
    {
        if (fa[u][i] != fa[v][i])
        {
            u = fa[u][i];
            v = fa[v][i];
        }
    }

    return fa[u][0];
}

int queryd(int u,int v)
{
    return d[u] + d[v] - 2 * d[lca(u,v)];
}

long long queryw(int u, int v)
{
    return sum[u] + sum[v] - 2 * sum[lca(u,v)];
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> k;
    for (int i = 1 ; i < n ; i++)
    {
        int u,v,w;
        cin >> u >> v >> w;
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }

    dfs(1,0);
    long long ans = 0;
    for (int i = 1 ; i <= n ; i++)
    {
        for (int j = 1 ; j < i ; j++)
        {
            if (queryd(i,j) == k) ans += 2 * queryw(i,j);
        }
    }

    cout << ans << endl;

    return 0;
}
```

---


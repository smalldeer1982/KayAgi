# 【MX-X11-T1】「蓬莱人形 Round 1」仅此而已，就已经足够了

## 题目背景

原题链接：<https://oier.team/problems/X11B>。

---

$$\text{もうさ強がらなくてもいいんだよ}$$

$$\text{過去の夜の涙ひとつ}$$

$$\text{それを柔く持って歩いて征く}$$

$$\text{それだけで今はいいんだよ}$$

## 题目描述

定义 $f(x)=x\oplus (x+2^k)$，其中 $\oplus$ 是二进制下的异或运算。

给定两个整数 $n,k$。

请你输出 $f(0)+f(1)+f(2)+\cdots+f(n)$ 的值。

有关异或运算的知识，您可以在 [OI Wiki 相关界面](https://oi-wiki.org/math/bit/)查询到。

## 说明/提示

**【样例解释 #1】**

对于第一组样例，$f(0) = 0 \oplus (0+2^0) = 1,f(1) = 1 \oplus (1+2^0) = 3,f(2) = 2 \oplus (2+2^0) = 1,f(3) = 3 \oplus (3+2^0) = 7$，因此答案为 $1+3+1+7=12$。

**【数据范围】**

对于 $20\%$ 数据，$n,T \leq 5000$。

对于另外 $20\%$ 数据，$n \leq 10^5$。

对于另外 $30\%$ 数据，$k = 0$。

对于 $100\%$ 数据，$1\le T \leq 10^5$，$0\le n < 2^{29}$，$0\le k \leq 29$。



## 样例 #1

### 输入

```
9
3 0
15 0
9 4
3 6
17 28
9 16
8 23
15 11
4 11```

### 输出

```
12
80
160
256
4831838208
655360
75497472
32768
10240```

# 题解

## 作者：_FastFT2013 (赞：12)

本蒟蒻考试的时候也是只打了 210pts，直接场切。

# Solution:

我们考虑将 $f(x)$ 进行改变：

由于 $⊕$ 运算属于二进制运算，所以此处 $x$ 都用的是二进制。

我们可以将 $x$ 的二进制描述成以下方式：

$(x)_2 =$ 一些乱七八糟的东西 $+$ 一个 $0$ $+$ $t$ 个连续的 $1$（结尾一定是二进制第 $k$ 位，$t$ 可以为 $0$）$+$ 一些乱七八糟的东西。

这里的二进制第几位是从右往左数的，二进制串最右边才是 $2^0$。

我们把第一个“一些乱七八糟的东西” 写做二进制数 $x_
1$，把第二个“一些乱七八糟的东西” 写作二进制数 $x_2$。

注意：“一些乱七八糟的东西” 是可以没有的。

例如样例：

$3$ $0$

$(3)_2 = 101 =$ $x_1$（$1$）$+$ 一个 $0$ $+$ 一个连续的 $1$ $+$ $x_2$（没有）。

那么把一个二进制拆成这样有什么用呢？

这就要提到 $⊕$ 的计算方式了，二进制位相同得 $0$，不同得 $1$。

接下来我们将 $f(x)$ 进行变式，通过对每部分进行讨论得出：

原式：$f(x) = x ⊕ (x + 2^k)$。

对于 $x_2$ 的部分，加法只会对第 $k$ 位以上的数字作影响，所以 $x_2$ 没有动，异或值为 $0$。

对于（一个 $0$ $+$ $t$ 个连续的 $1$）这部分，加法表示在第 $k$ 位加 $1$，相当于在这部分的最右边那一位加 $1$，则整体会变为（一个 $1$ $+$ $t$ 个连续的 $0$），异或值为（连续的 $t+1$ 个 $1$）。

对于 $x_1$ 的部分，由于用一个 $0$ 来隔开加法进位了，所以不会对当前部分产生影响，不会发生改变，异或值为 $0$。

所以说我们可以将 $f(x)$ 的二进制写成这样：

$f(x) =$ 以第 $k$ 位结尾的连续的 $t+1$ 个 $1$。

那这根我们算答案有什么关系呢？

我们发现，实际上可以枚举 $t$，算出二进制中有一个 $0$ $+$ 从第 $k$ 为结尾连续 $t$ 个 $1$，并且满足这个数小于等于 $n$ 的方案数，将方案数乘上当前贡献就可以得出当前结果。

我们现在假设要满足以上条件，并且给出了 $t$。

首先（一个 $0$ $+$ 从第 $k$ 为结尾连续 $t$ 个 $1$）可以使用公式推导出来：

一个 $0$ $+$ 连续 $t$ 个 $1$ $= 2^t - 1$。

上述条件加上以第 $k$ 结尾 $=(2^t - 1) \times 2^k$。

然后我们要求出满足条件的最大的数，

这个不能使用公式进行推导，我们可以从高位枚举到低位，每次查看能不能把这个位变为 $1$ 并且满足条件，若能，就把这个位变为 $1$。

提示：在第 $k$ 位到第 $k+t$ 位不能改，应为这是（一个 $0$ $+$ 从第 $k$ 为结尾连续 $t$ 个 $1$）。

设这个满足条件的最大数为 $p$。

```c++
ll p=((1ll<<t)-1)<<k;
if(p>n)continue;//此处判断有没有方案
for(int j=30;j>=0;j--){//高位枚举到低位
	if(j>=k&&j<=k+t)continue;
	if(p+(1ll<<j)<=n){
		p+=(1ll<<j);
	}
}
```

现在我们求出来了，那怎么做呢？

我们考虑 $p$ 的 $x_1$ 和 $x_2$，将 $a$ 和 $b$ 设为这两个值（此处只是为了简便）。

公式推导 $a$ 和 $b$：

$a$ 为 $p$ 的二进制去掉后 $t + k + 1$ 位的值，

及 $a = \lfloor \frac{p}{2^{t+k+1}} \rfloor$。

$b$ 为 $p$ 的二进制后 $k-1$ 位，

及 $b = p \bmod (k-1)$。

```c++
ll a=p>>(i+k+t),b=p%(1ll<<k);
```

我们将满足条件的数的情况分为两种：

第一种：满足条件的数的 $x_1 < a$，则满足条件的数的 $x_2$ 可以为任何前 $k-1$ 位的二进制数（想不出来的可以画图理解）。

则方案数为：

（$x_1 < a$）的方案 $= a + 1 - 1 = a$（相当于减去了 $x_1 = a$ 的情况，增加了 $x_1 = 0$ 的情况）。

（$x_2$ 可以为任何 $k-1$ 位的二进制数）的方案 $= 2^k$（相当于每一位有 $2$ 种情况，从共有 $k$ 位（$0$ 这一位要记录进去））。

第一种的总方案 $=$（（$x_1 < a$）的方案）$\times$（（$x_2$ 可以为任何 $k-1$ 位的二进制数）的方案）$= a \times 2^k$ 设其为 $q_1$。

```c++
ll q1=a<<k;
```

第二种：满足条件的数的 $x_1 = a$，则满足条件的数的 $x_2$ 可以为任何 $\le b$ 位的二进制数（想不出来的可以画图理解）。

则方案数为：

（$x_1 = a$） 的方案 $= 1$。

（$x_2$ 可以为任何 $\le b$ 位的二进制数）的方案 $= b + 1$（加的 $1$ 是 $x_2 = 0$ 的情况）。

第二种的总方案 $=$（（$x_1 = a$）的方案）$\times$（（$x_2$ 可以为任何 $\le b$ 位的二进制数）的方案）$= 1 \times (b + 1)$ 设其为 $q_2$。

```c++
ll q2=b+1;
```

所以总的方案数为 $q_1 + q_2$。

答案为之前推出来的（以第 $k$ 位结尾的连续的 $t+1$ 个 $1$）$= 2^{t+1} - 1$。

当前总答案为 $(q_1 + q_2) \times (2^{t+1} - 1)$。

$t$ 这个数只需要枚举就好了。

单次时间复杂度 $O(\log^2 n)$。

# Code:

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
void solve(){
	ll n,k;
	cin>>n>>k;
	ll sum=0;
	for(int i=0;i<=30;i++){//这里的i就是t
		ll p=((1ll<<i)-1)<<k;
		if(p>n)continue;
		for(int j=30;j>=0;j--){
			if(j>=k&&j<=k+i)continue;
			if(p+(1ll<<j)<=n){
				p+=(1ll<<j);
			}
		}
        ll a=p>>(i+k+1),b=p%(1ll<<k);
		ll q1=a<<k;
		ll q2=b+1;
		sum+=(q1+q2)*(((1ll<<(i+1))-1)<<k);
	}
	cout<<sum<<"\n";
}
int main(){
	int t;
	cin>>t;
	while(t--)solve();
    return 0;
}
```

---

## 作者：P2441M (赞：6)

## 题意
给定 $n,k$，求出 $\sum_{x=0}^nx\oplus(x+2^k)$。多测，$1\leq T\leq 10^5,0\leq n<2^{29},0\leq k\leq 29$。

## 题解
赛时被干废了。

令 $b=\lfloor\log_2(n)\rfloor$，特判 $k>b$，此时 $f(x)=2^k$，答案为 $2^k(n+1)$。

接下来，考虑 $+2^k$ 能带来什么影响。显然它影响不了低 $k-1$ 位，因此
$$
f(t2^k)=f(t2^k+1)=\cdots=f((t+1)2^k-1)
$$
那么我们每 $2^k$ 个数分成一组，它们的 $f$ 值都一样，令 $x=\left\lfloor\frac{n}{2^k}\right\rfloor$，最后会有一些形如
$$
f(x2^k)=f(x2^k+1)=\cdots f(n)
$$
的余项，它们的和即为 $f(n)((n\bmod{2^k})+1)$，我们把它加到答案上。

注意到由于低 $k-1$ 位被忽略掉了，此时问题转化成了 $k=0$ 的形式。我们继续挖掘 $+2^k$ 的性质，考虑进位，发现相当于从第 $k$ 位往高位找到第一个 $0$ 的位置 $p$，把 $[k,p]$ 中的位翻转，其它位保持不变，因此 $f(x)=\sum_{i=k}^p2^i$。于是我们枚举 $p$ 然后计数即可，计数部分就是简单的不等式了。

时间复杂度 $\mathcal{O}(T\log{n})$。

## 代码
```cpp
#include <iostream>
#include <cmath>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;

ll t, n, k, x, s1, s2;
ll ans;

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> t;
    while (t--) {
    	cin >> n >> k, x = n >> k, s1 = s2 = 0;
    	int b = log2(n);
    	if (k > b) cout << (ans = (1ll << k) * (n + 1)) << '\n';
    	else {
    		ans = (n ^ (n + (1 << k))) * ((n & ((1 << k) - 1)) + 1);
    		for (int i = k; i <= b; ++i) {
	    		int c = (x - s2 - 1) >> (i - k + 1);
	    		s1 += 1 << i, s2 += 1 << (i - k), ans += ((c + 1) * s1) << k;
			}
			cout << ans << '\n';
		}
	}
    return 0;
}
```

---

## 作者：Lele_Programmer (赞：5)

# P12147 题解

赛时被硬控一个半小时。

## 思路

对于一个 $k$，$x \oplus (x + 2^k)$ 的值取决于从第 $k$ 位开始的连续 $1$ 的个数。

如果第 $k$ 位为 $0$，则值为 $2^k$。

如果第 $k$ 位为 $1$，则值为 $2^k + 2^{k+1}$。

如果第 $k$ 位和第 $k+1$ 位为 $1$，则值为 $2^k + 2^{k+1} + 2^{k+2}$。

依此类推，连续 $1$ 的个数取决于它进位的数量，进位的数量又会影响异或的值。

设 $s_{i,j}$ 为：从第 $i$ 位开始的连续 $j$ 位为 $1$，第 $i+j$ 位为 $0$，$x \oplus (x + 2^k)$ 的值，即 $\sum\limits_{a=i}^{i+j} 2^a$。

```cpp
_rep(i,0,N-1) p[i]=(1LL<<i);
_rep(i,1,N-1) p[i]+=p[i-1];
_rep(i,0,N-1) _rep(j,0,N-1) {
  if (i+j-1>=N) break;
  s[i][j]=p[i+j]-p[i-1];
}
```

如果 $n$ 的最高位 $1$ 所在位小于 $k$，那么很显然对于每一个 $i$ 满足 $0 \le i \le n$，贡献都是 $2^k$，所以答案为 $2^k \times (n+1)$。

考虑剩余情况。

设 $g$ 为 $n$ 的 $0$ 到 $k-1$ 位组成的数，$m$ 为 $n$ 的第 $k$ 位即更高位组成的数向右移 $k$ 位的数。枚举从 $k$ 开始的连续 $1$ 的数量，如果数字超过 $n$ 或等于 $n$，就退出，否则计算在这连续若干位 $1$ 的左边能有多少种情况使得右边若干位任意填都不达到 $n$，也就是左边那些位组成的数字加上连续 $i$ 位 $1$ 组成的数之后移动到右端对其第 $0$ 位之后小于 $m$。这里可以用二分求得，然后与 $2^k$ 相乘，即 $0$ 到 $k-1$ 位任意填。

因为刚刚把等于 $n$ 的情况排除了，所以最后从第 $k$ 位开始都按照 $n$ 来填，于是 $k-1$ 位及以下，共有 $g$ 种情况。

## 代码

```cpp
const int N=35;

int T,n,k;
int p[N];
int g;
int s[N][N];

i32 main() {
    _rep(i,0,N-1) p[i]=(1LL<<i);
    _rep(i,1,N-1) p[i]+=p[i-1];
    _rep(i,0,N-1) _rep(j,0,N-1) {
        if (i+j-1>=N) break;
        s[i][j]=p[i+j]-p[i-1];
    }
    read(T);
    while (T--) {
        read(n),read(k);
        if ((1LL<<k)>n) {
            writeln((1LL<<k)*(n+1));
            continue;
        }
        g=0;
        _rep(i,0,k-1) g+=(((n>>i)&1)<<i);
        n-=g;
        g++;
        int m=(n>>k);
        // cout<<"TEST: "<<n<<" "<<g<<" "<<m<<endl;
        int ans=0,cur=0;
        _rep(i,0,N-1) {
            if (cur>=n) break;
            else {
                int l=0,r=(1LL<<(N-1)),t=(cur>>k);
                while (l<r) {
                    int mid=(l+r>>1)+1;
                    int q=(mid<<(i+1));
                    q+=t;
                    if (q<m) l=mid;
                    else r=mid-1;
                }
                l++;
                ans+=l*(1LL<<k)*s[k][i];
                // printf("%lld: %lld * %lld * %lld\n",i,l,(1LL<<k),s[k][i]);
            }
            cur+=(1LL<<(k+i));
        }
        int cnt=0;
        while (m) {
            if (m&1) cnt++,m>>=1;
            else break;
        }
        ans+=s[k][cnt]*g;
        writeln(ans);
    }
    return 0;
}
```

---

## 作者：yonghu10010 (赞：4)

# P12147 解题报告
（注：本题解思路与其他题解略有不同。）

*某蒟蒻赛时被控 2h+……*
## 一些思路
题目给出 $n$，$k$，让我们求出以下式子的值：
$$\sum_{i=0}^{n} i \oplus (i+2^k)$$
### 思路一：暴力
题目很简洁，暴力很好想。

既然这是个简简单单的表达式，自然可以直接使用 for 循环去求，每次以原表达式的形式加入 $ans$，最后直接输出即可。
### 思路二：找规律
本蒟蒻无法直接摁着二进制推式子得到较为简洁的表达式，只能打表观察。

打表看规律是一种思路，尤其是题目表达式比较抽象，即无法很形象地观察到本质的时候，打表将是一种好方法，值得一试。
## 细节构思
对于暴力没什么好说的，很简单。

对于每次查询直接循环计算即可。

时间复杂度 $O(T \times n)$，期望得分 $20$ 分。

下面重点介绍思路二的延伸。

首先，看使用暴力程序打出的表：

| $x$ | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $10$ | $11$ | $12$ | $13$ | $14$ | $15$ | $16$ | $17$ | $18$ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $f(x)$ | $1$ | $3$ | $1$ | $7$ | $1$ | $3$ | $1$ | $15$ | $1$ | $3$ | $1$ | $7$ | $1$ | $3$ | $1$ | $31$ | $1$ | $3$ | $1$ |

这里展示了 $k=0$ 的情况。如果你仍感觉云里雾里，看下面这个使用了数字大小作为高度的二维图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/365zfnby.png)

连了一些辅助线，是不是豁然开朗了呢？没错，它的形式像一棵**二叉树**！（注意是“像”，虽然有很多相似之处，但这里不能直接等同）

以下是关于该规律的简要证明（此时将数字默认转换为二进制）：

- 首先，每当加 $2^{m-1}$ 次 $1$，数字的第 $m$ 位就会 $+1$，这点易得；
- 其次，对于一个有从第 $1$ 位开始长度为 $x$ 的**极长** $1$ 串的数，由于该串会连续进位产生许多 $0$ 和一个最高位的 $1$ 以和原来的对应位置不相等，它的贡献为 $2^{x+1}-1$；
- 并且，对于每种贡献，每过 $2^x$ 轮，这个数字从第 $1$ 位开始就会出现一个长度**至少**为 $x$ 的 $1$ 串；
- 对于某数字，它从第 $1$ 位开始的长度为 $x$ 连续 $1$ 串为极长 $1$ 串的充要条件为该数的第 $x+1$ 位是 $0$。
- 那么，由于每过 $2^{((x+1)-1)+1}$ 轮，第 $x+1$ 位就会进行两次 $+1$，即经过一次 $0/1$ 循环，那个长度为 $x$ 的连续 $1$ 串就会成为一次极长 $1$ 串。
- 结论：对于每种贡献每过 $2^{x+1}$ 轮，就会出现一个数，它从第 $1$ 位开始有一个长度为 $x$ 的**极长** $1$ 串，贡献为 $2^{x+1}-1$。

于是，我们可以转化题意，将它转化为一种求树上区间和的问题。鉴于刚刚使用图像所得到的直观印象，我们也就能比较轻松地得到以下设计思路：

**对于被查询一段区间，可以先计算它左一部分的和，再算右一部分的和，最后加上中间的和，即可得到结果。**

可以使用**分治**算法实现。

自然而然地，我们可以想到一些优化：

1. 对于每一个节点的值，是可以预处理得到的。问题：如何计算？
2. 如果某段区间被全覆盖，可以直接返回它的区间和。问题：如何得到区间和？

观察图像可得，对于高度为 $h$ 的一棵子树，它的根节点值为 $2^h-1$。这个可以现算，也可以预处理查询。（预处理时，每一步的值可以看作两倍上一步的值加上 $1$，后面就知道其意义了）  
其次，对于一棵子树，它的各节点的值之和等于它的两棵子树和加上它自己的根节点值（刚刚已处理出）。

所以，这里只用一次简单的预处理，后面直接调用就行，时间复杂度 $O(\log n)$。  
基本设计就已经结束了。

刚刚扯了这么一大堆，现在我们需要考虑到： **$k$ 怎么会一直安安稳稳地待在 $0$ 值不动呢？** 所以，我们需要拓展刚刚的规律。

继续打表，比如 $k=4$ 时，可以得到：$16$ 个 $16$，$16$ 个 $48$，$16$ 个 $16$，$16$ 个 $112$……

感觉有点似曾相识？把每个值除以 $16$（即 $2^4$，$2^k$），再将每 $16$ 个相同的数只保留 $1$ 个，我们就能发现这正是前文所提的 $1$，$3$，$1$，$7$……序列！至于为什么，也很简单：

- 因为加的是 $2^k$，那么对于二进制下的表示来说，低 $k$ 位均不会受到任何改变；
- 那么按位异或的时候，也就会是全 $0$ 了，得到的值也刚好就是 $k=0$ 的基础上精确放大为原来的 $2^k$ 倍；
- 至于每个数都出现 $16$ 次，也是因为这一位本身大小就是 $2^k$，自然需要加 $2^k$ 次 $1$ 才能改变一次。

整理，得到以下结论：

**对于所有的 $k$，它所形成的树的每个节点单值会成为原本的 $2^k$ 倍，且范围也会变成原来的 $2^k$ 倍，即每个节点形成了一个长度为 $2^k$ 的块。**

有了较为精确的表示方法，即可设计准确的代码表达。

首先，对于 $k=0$，以第 $h$ 层节点为根节点的树覆盖范围长度为【左子树的覆盖范围】加上【节点本身的覆盖范围】和【右子树的覆盖范围】。其中第一项和第三项相等，第二项为 $1$，即可发现它在数值上刚好等价于预处理根节点值时得到的结果，可以直接拿来用。如果 $k>0$，直接左移 $k$ 位即可。中间覆盖的长度刚好为 $2^k$。

那么，设该层树覆盖范围是 $[l,r]$，层序数为 $h$。

- 左子树覆盖的范围即为 $[l,l+(b_{h-1} \times 2^k)-1]$；
- 节点本身，即中间覆盖的范围为 $[l+(b_{h-1} \times 2^k),l+(b_{h-1} \times 2^k)+2^k-1]$；
- 最后右子树覆盖的范围是 $[l+(b_{h-1} \times 2^k)+2^k,r]$。

由于使用分治分为左右两半，于是最多约 $\log{n}$ 层，且每层节点整体最多只访问 $1$ 个，中间部分计算 $O(1)$；故总时间复杂度为 $O(T \times \log{n})$，足以通过此题。

思路整理完毕，细节见代码。
## Coding Time

```cpp
#include<cstdio>
long long T,n,k;
long long b[35];
long long b1[35];
int find(long long a){//返回最小能覆盖区间的树高度，这里使用二分查找（注意这里 res 的实际值为最大不能覆盖的高度，后面会 +1 调整）
	int l=1,r=31,mid,res=0;
	while(l<r){
		mid=(l+r)>>1;
		if(b[mid]>a){
			r=mid;
		}else{
			res=mid;
			l=mid+1;
		}
	}
	return res+1;
}
long long mn(long long a,long long b){//辅助函数
    if(a<b){
        return a;
    }
    return b;
}
long long mx(long long a,long long b){//辅助函数 +1
    if(a>b){
        return a;
    }
    return b;
}
long long query(int x,long long workl,long long workr,int bl,long long br){
    if(workl>br||workr<bl){//无交集区间，返回 0
        return 0;
    }
    if(workl>=bl&&workr<=br){
        return (b1[x]<<k)<<k;//直接返回：第一次还原长度，第二次还原值
    }
    long long res=0;
    res+=query(x-1,workl,workl+(b[x-1]<<k)-1,bl,br);//递归左子树
    res+=((mx(0,(mn(1<<k,(br-(workl+(b[x-1]<<k))+1))*b[x])))<<k);//计算中间区间。首先区间长度不能小于0，其次最大为2^k；否则就是查询区间的右端点减去中间区域的左端点。每个点的初值即为b[x]，左移k位放大即可
    res+=query(x-1,workl+(b[x-1]<<k)+(1<<k),workr,bl,br);//递归右子树
    return res;
}
void print(long long a){//朴实无华的快写
	if(a>9){
		print(a/10);
	}
	putchar(a%10+'0');
}
int main(){
    for(int i=1;i<=31;i++){//预处理：b为节点初值，b1为子树和
        b[i]=(b[i-1]<<1)|1;
        b1[i]=(b1[i-1]<<1)+b[i];
    }
    scanf("%lld",&T);
    while(T--){
        scanf("%lld%lld",&n,&k);
        if(n<(1<<k)){//如果n<2^k，所有的x的二进制第k位一定全0，即异或后会只剩下n个2^k，直接计算即可
            long long ans=(1<<k)*(n+1);
            print(ans);putchar('\n');
            continue;
        }
        long long n1=(n>>k);
        int mnum=find(n1)+1;//+1 进行调整
        print(query(mnum,0,(b[mnum]<<k)-1,0,n));putchar('\n');
    }
    return 0;//华丽结尾
}
```

-EOF-

---

## 作者：Tenil (赞：3)

# Solution

这里是博客：[Tenil](https://www.cnblogs.com/tenil)，有更好的看题体验哦~

## 题意
[原题链接](https://www.luogu.com.cn/problem/P12147)

定义 $f(x)=x\oplus (x+2^k)$，给定两个整数 $n,k$，求 $\sum_{i = 0}^{n}f(i)$ 的值。

ps:你梦熊入门题简单又直接，令我 1h 才做完。果然，题目信息里面难度是最不能相信的。

## 分析

注意到有 $30\%$ 数据满足 $k = 0$，启发我们先考虑 $k = 0$ 的特殊情况。

### 1. $k = 0$

一个很自然的想法是：按题目所给定义不可以直接求和，那么我们考虑一下找一个可以直接求和的表达式。场上果断暴力打表找规律。

[这里](https://www.luogu.com.cn/paste/ruknbjee)是 $k = 0,n=31$ 的数据表，请自行移步看一下。

观察数据，会发现几个很惊人的事实：

1. $x$ 为偶数时，$f(x) = 1$；
2. $f(x)$ 不为 $1$ 时，其取值为 $2^k-1$；
3. $x$ 为 $2^k-1$ 时，其取值为 $2^{k+1}-1$；

其实到这里，一切都比较明晰了，结论就是 $k = 0$ 时，$f(x)=2 \times \operatorname{lowbit}(x+1)-1$。基于梦熊标明的题目难度，说明一下 $\operatorname{lowbit}$：它指一个数二进制数最低位的 $1$ 及其对应的值.直观地说，就是一个数二进制下从右往左数第一个 $1$ 和它右边的所有 $0$ 共同组成的数。如 $\operatorname{lowbit}(10)=\operatorname{lowbit}((1010)_2)=(10)_2=2$。有 $\operatorname{lowbit}(x)=x \operatorname{and} (-x)$。

下面给出证明：

任意考虑一个数 $x$，若它为偶数，它的二进制下最低位为 $0$，加 $1$ 后仅最后一位与原数不同，故 $f(x)=1$，满足以上结论；若 $x$ 为奇数，则加 $1$ 后进位，$x$ 将由 $(1 \dots 01 \dots 1)_2$ 的形式变成 $(1 \dots 10 \dots 00)_2$，即 $x$ 的从右往左数第一个 $0$ 位（设为第 $r$ 位）及其以右的所有位都变了，故 $x\oplus (x+2^k)$ 的结果即为 $2^r-1=2 \times \operatorname{lowbit}(x+1)-1$。证毕。

所以说 $ans=\sum_{i = 0}^{n}f(i)=\sum_{i = 1}^{n+1} (2 \times \operatorname{lowbit}(i+1)-1)=2\sum_{i = 1}^{n+1} \operatorname{lowbit}(i+1)-(n+1)$。从而问题转变为求 $\sum_{i = 1}^{n+1} \operatorname{lowbit}(i)$。

结合 $\operatorname{lowbit}$ 定义，我们可以得到 $\sum_{i = 1}^{x} \operatorname{lowbit}(i)$ 的一个递推式（设 $\sum_{i = 1}^{x} \operatorname{lowbit}(i)=g(x)$）：

$g(x) = \begin{cases}
  \frac{n}{2}+2g(\frac{n}{2}) & x \in even\\
  \frac{n+1}{2}+2g(\frac{n-1}{2}) & x \in odd\\
\end{cases}$

为什么呢？对偶数情况进行一下说明：$[1,n]$ 中有奇数、偶数各 $\frac{n}{2}$ 个，奇数的 $\operatorname{lowbit}$ 定为 $1$；然后将所有数除以二进行同样的考虑即得。奇数同理。边界是 $g(0)=0,g(1)=1$。

于是 $k=0$ 的问题可以在 $O(T\log n)$ 的时间复杂度下解决。

### 2. $k \ne 0$

同样先给出[数据](https://www.luogu.com.cn/paste/4km9eyxe)。

定义 $h(x,y)$ 为 $f(x)$ 在 $k=y$ 时的值，有 $h(x,k)=2^kf([\frac{x}{2^k}],0)$，其中，$[x]$ 表示不大于 $x$ 的最大整数。这里直接给出直观证明：$x$ 加上 $2^k$ 后，对低于 $2^k$ 的位没有任何影响，且那些位的值也不会影响 $x\oplus (x+2^k)$ 的值，故可以直接舍去。相当于 $x$ 每增加 $2^k$ 才等价于 $k=0$ 时增加 $1$，体现在式子上就是 $[\frac{x}{2^k}]$ 项。但是对比 $k=0$ 时，变化的最低位为 $2^k$ 位，故再乘上一个 $2^k$。

于是 $n$ 相当于 $k=0$ 时完整的 $1$ 到 $[\frac{x}{2^k}]$ 与剩下一部分 $[\frac{x}{2^k}]+1$。由上亦得 $h(x,y)$ 中连续的 $2^k$ 项是相同的，故完整的数乘上 $2^k$，不完整的单独计算，得：

$ans(k)=2^k[2(2^kans_0(s)+r \operatorname{lowbit} (s+1))-(n+1)]$，

其中 $ans_0(x)$ 为 $n = x,k=0$ 时的答案，$s=\frac{n+1}{2^k},r=(n+1) \bmod 2^k$。这里的中括号不表示取整。

可能看着比较迷糊，可以这样理解：最外面的 $2^k$ 是因为“变化的最低位为 $2^k$ 位”而整体乘的，里面就形似 $2 \times \operatorname{lowbit}(x+1)-1$，其实就是前 $n$ 项和。

于是问题在 $O(T \log n)$ 的时间复杂度下解决。

感觉分析得已经比较详细了，代码没写注释，将就看下吧。

## 实现

1. $\operatorname{lowbit}$ 函数（不要宏定义，本蒟蒻因此改了至少二十分钟）；
2. $\operatorname{lowbit}$ 的求和递归式；
3. 直接计算输出。

## Code


```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <cmath>

using namespace std;

typedef long long ll;

ll fr() {
    ll x=0,f=1;
    char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) {
        x=(x<<3)+(x<<1)+(c^48);
        c=getchar();
    }
    return x*f;
}

ll t,n,k,ans;

inline ll lowbit(ll x) {return x&(-x);}

ll gets(int x) {
    if(x<=1) return x;
    return ((x&1)?((x+1)>>1):(x>>1))+(gets(x>>1)<<1);
}

int main() {
    t=fr();
    while(t--) {
        ans=0;n=fr(),k=fr();
        ll s=(n+1)/(1<<k),r=(n+1)%(1<<k);
        printf("%lld\n",(1<<k)*(2*((1<<k)*gets(s)+r*lowbit(s+1))-n-1));
    }
    return 0;
}
```

## 闲话

如果觉得有用，点个赞吧！

---

## 作者：huanglihuan (赞：3)

### Solution
容易发现，对于每个位位置 $i$，确定 $x$ 和 $x+2^k$ 在位置 $i$ 上的位是否相同。如果不同，则该位的贡献值为 $2^i$。

由于当且仅当 $2^k$ 的加法导致进位传播到位置 $i$ 时，$x$ 和 $2^k+x$ 在位置 $i$ 上的位才会不同。

因此，只需要对于每个位置 $i(i\ge k)$，计算有多少个整数 $x$ 使得 $2^k$ 的加法会导致进位传播到位置 $i$。这可以通过检查 $x$ 的从位置 $k$ 到 $i-1$ 的所有位是否都为一来确定。
### Code
```cpp
#include <bits/stdc++.h>
#include <cstdio>
#define int long long
#define ull unsigned long long
#define mod 998244353
#define MOD 1000000007
using namespace std;
const int N = 3e6 + 5,maxn = 5e3 + 5;
inline int read ()
{
	int x = 0;
	char c = getchar ();
	while (c < '0' || c > '9') c = getchar ();
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48),c = getchar ();
	return x;
}
inline void write (int x)
{
	if (x < 0) putchar ('-'),x = -x;
	if (x > 9) write (x / 10);
	putchar (x % 10 + '0');
	return ;
}
signed main ()
{
	int T;
	cin >> T;
	while (T --)
	{
		int n,k;
		cin >> n >> k;
		int ans = 0;
		int pk = 1LL << k;
		int ml = (1LL << k) - 1;
		for (int i = k;i <= 29;i ++)
		{
			int pi = 1LL << i;
			int hp = n >> i;
			int lm = i - k;
			int mm = (lm == 0) ? 0 : (1LL << lm) - 1;
			int mp = (n >> k) & mm;
			int ym = mm;
			int lp = n & ml;
			int ea;
			if (mp > ym) ea = pk;
			else if (mp == ym) ea = lp + 1;
			else ea = 0;
			int ci = hp * pk + ea;
			ans += ci * pi;
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：sbno333 (赞：3)

考虑按位考虑被贡献的次数。

低于 $2^k$ 位显然被不被贡献。

从 $2^k$ 位开始这一位被贡献当且仅当这一位之前（不含这一位）到 $2^k$ 位 $x$ 这一位都是 $1$。

计数即可，我们考虑就是这一位以及更高位每变化一次一块，每个完整块贡献 $2^k$，不完整块算一下低位就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

void _main(){
	int n,k;
	cin>>n>>k;
	int ans;
	ans=(n+1)*(1ll<<k);
	int z;
	z=0;
	for(int i=k+1;i<=29;i++){
		z+=(1ll<<(i-1));
		int p;
		p=(n)/(1ll<<i)*(1ll<<k);
		int c;
		c=(n&((1ll<<i)-1));
		c=c-z+1;
		p+=max(c,0ll);
		ans+=p*(1ll<<i);
	}
	cout<<ans<<endl;
}
signed main(){
	int t;
	cin>>t;
	while(t--){
		_main();
	}
	return 0;
}
```

---

## 作者：CleverSea (赞：2)

### 在前言前面

> 很遗憾，您的题解不符合推荐标准。原因是：非数学公式（一般英文单词、题目名、算法名、人名等）不应使用 LaTeX。

可我寻思着题面就是这么写的啊……

### 前言（读后续写）

$$\text{ほら、星屑がそっと揺れるよ}$$

$$\text{明日の風が頬を撫でる}$$

$$\text{その小さな傘、差していこう}$$

$$\text{君の物語は続いて征く}$$

这里是[翻译](https://www.luogu.com.cn/paste/x9dle4ij)（剪贴板）。（机翻没有美感）

### 题意简述

定义函数 $f(x) = x \oplus (x + 2^k)$，给定两个整数 $n$ 和 $k$，计算 $S = \sum_{x=0}^{n} f(x)$ 的值。

### 分析

注意到，函数 $f(x) = x \oplus (x + 2^k)$ 的取值取决于 $x$ 的**第 $k$ 位**：
- 如果 $x$ 的第 $k$ 位为 $0$，则 $f(x) = 2^k$。
- 如果 $x$ 的第 $k$ 位为 $1$，则 $f(x)$ 的取值不仅包括第 $k$ 位，还可能包括从第 $k$ 位开始向上连续的一段 $1$（由**进位**引起）。

---

为了高效计算 $S$，我们按位贡献考虑：

1. **第 $k$ 位**：每个 $x$ 的第 $k$ 位在 $f(x)$ 中总是 $1$，因此贡献为 $(n+1) \times 2^k$。

3. **第 $i$ 位（$i > k$）**：当且仅当 $x$ 的第 $k$ 位到第 $i-1$ 位全为 $1$ 时，$f(x)$ 的第 $i$ 位为 $1$。设满足条件的 $x$ 的个数为 $g(i, k, n)$，则第 $i$ 位的贡献为 $g(i, k, n) \times 2^i$。

So，总和 $S$ 为：

$$
S = (n+1) \times 2^k + \sum_{i=k+1}^{\text{max\_bit}} g(i, k, n) \times 2^i
$$

其中 $\text{max\_bit}$ 取足够大的值（如 $60$），因为 $n < 2^{29}$，更高位无贡献。

---

所以我们只需要考虑如何计算 $g(i, k, n)$。不妨设 $L = k$，$R = i-1$，则要求 $x$ 的二进制表示中 $[L, R]$ 位全为 $1$。构造 $M = (2^{R+1} - 1) - (2^L - 1) = 2^{R+1} - 2^L$（即 $[L, R]$ 位全 $1$ 的数）。若 $M > n$，则 $g(i, k, n) = 0$。否则，令 $T = n - M$，$W = 2^{R+1}$，$X = 2^L - 1$（低位最大值）。计算满足 $0 \leq A \leq \lfloor \frac{T}{W} \rfloor$ 的整数 $A$ 的数量，使得 $B = T - A \times W \leq X$ 或 $B \geq 0$。

然后分讨一下——对于 $g(i, k, n)$，可以分为两部分：

  1. $A$ 较小，$B$ 可取 $[0, X]$：方案数为 $(\min(A_0, A_{\max}) + 1) \times 2^L$，其中 $A_0 = \lfloor \frac{T - X}{W} \rfloor$，$A_{\max} = \lfloor \frac{T}{W} \rfloor$。

  2. $A$ 较大，$B$ 可取 $[0, T - A \times W]$：方案数为 $\sum_{A=A_0+1}^{A_{\max}} (T - A \times W + 1)$，可用小奥学的等差数列求和公式计算。

### $Code$

```cpp
#include <bits/stdc++.h>
#define Code using
#define by namespace
#define CleverSea std
typedef long long ll;

Code by CleverSea;

int main() {
    int T;
    cin >> T;
    while (T--) {
        ll n, k;
        cin >> n >> k;
        // 第 k 位的贡献：每个 x 都有贡献
        ll ans = (n + 1) * (1LL << k);
        // 枚举更高位 i (i > k)
        for (int i = k + 1; i <= 60; i++) {
            int L = k;          // 区间起点
            int R = i - 1;      // 区间终点
            // 计算 M = 2^{R+1} - 2^L，即 [L, R] 位全 1 的数
            ll M_val = (1LL << (R + 1)) - (1LL << L);
            if (M_val > n) continue;  // 无满足条件的 x
            ll T_val = n - M_val;     // 剩余值
            ll W_val = (1LL << (R + 1)); // 模数 W = 2^{R+1}
            ll A_max = T_val / W_val; // A 的最大值
            ll X_val = (1LL << L) - 1; // 低位最大值 (2^L - 1)
            // 计算 A0：满足 T_val - A*W_val >= X_val 的最大 A
            ll A0;
            if (T_val < X_val) {
                A0 = -1;
            } else {
                A0 = (T_val - X_val) / W_val;
            }
            // 第一部分：A 从 0 到 min(A0, A_max)，每个 A 贡献 2^L 个 B
            ll part1 = 0;
            ll A1 = min(A0, A_max);
            if (A1 >= 0) {
                part1 = (A1 + 1) * (1LL << L);
            }
            // 第二部分：A 从 A0+1 到 A_max，每个 A 贡献 (T_val - A*W_val + 1) 个 B
            ll part2 = 0;
            ll A_start = A1 + 1;
            ll A_end = A_max;
            if (A_start <= A_end) {
                ll cnt = A_end - A_start + 1; // A 的个数
                // 等差数列求和：Σ_{A=A_start}^{A_end} (T_val - A*W_val + 1)
                part2 = (T_val + 1) * cnt - W_val * (A_start + A_end) * cnt / 2;
            }
            ll g = part1 + part2; // 满足条件的 x 的数量
            ans += g * (1LL << i); // 第 i 位的贡献
        }
        cout << ans << '\n';
    }
    return 0;
}
```

时间复杂度为 $O(kT)$，其中 $k = 60$。

---

## 作者：__CJY__ (赞：1)

## 思路
观察到 $x+2^k$ 只是在 $x$ 的二进制表示中，将第 $k$ 位（从右往左数，第 $0$ 位为最低位）加 $1$，可能产生进位。

因此，$f(x)$ 的值主要取决于 $x$ 和 $x+2^k$ 在哪些位上不同。

* 如果 $x$ 的第 $k$ 位为 $0$，则 $ x+2^k$ 的第 $k$ 位为 $1$，其他位不变。
* 如果 $x$ 的第 $k$ 位为 $1$，则 $x+2^k$ 会产生进位，导致更高位发生变化。

观察到 $2^k$ 的贡献次数为 $n+1$，先算掉。

还观察到当第 $i$ 位产生贡献时，必然满足从第 $k$ 位到 $i-1$ 位必须全部为 $1$。

设 $n'=n+2^k $，则问题转化为统计 $n'$ 中第 $i$ 位为 $1$ 且从第 $k$ 位到第 $i-1$ 位全为 $0$ 的出现次数。

因此，答案为 $ 2^{i+1}-2^{k+1}$。

---

## 作者：fish_love_cat (赞：1)

偶遇数学题拼尽全力无法战胜，怎么会是呢。

调了三天甚至两天，耶耶耶。

---

观察到增加一个 $2^k$ 变化的位数有限，而异或统计答案只关注于变化的这些位，于是考虑按位统计答案。

注意到 $2^k$ 的贡献次数为 $n+1$，先算掉。

注意到第 $i$ 位产生贡献时，必然满足从第 $k$ 位到 $i-1$ 位必须全部为 $1$。

于是不妨 $n \gets n+2^k$，那么此时我们只需要统计第 $i$ 位是 $1$ 而从 $k$ 到 $i-1$ 位全为 $0$ 的出现次数，这是好做的。

然后贡献大小就是 $2^{i+1}-2^{k+1}$。

直接写就行，请务必保持头脑清楚以及明确每一行的作用！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
void solve(){
    int n,k;
    cin>>n>>k;
    int ans=(1<<k)*(n+1);
    n+=(1<<k);
    // cout<<n<<"! ";
    for(int i=1<<(k+1);i<=n;i*=2){
        // cout<<ans<<' ';
        int f=n/(i<<1);
        int c=min(1ll<<k,n%i+1);
        int sum=f*(1<<k);
        ans+=sum*i*2-sum*(1<<(k+1));
        // cout<<c<<' ';
        if(n&i)ans+=i*c*2-c*(1<<(k+1));
    }
    cout<<ans<<'\n';
}
/*
  0
  1
 10
 11
100

101
110
*/
signed main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
/*
72
272
50
18

4
9 2
17 3 
8 1 
4 1 
*/
```

---


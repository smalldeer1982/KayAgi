# 【MX-J15-T3】叉叉学习与自我和解

## 题目背景

原题链接：<https://oier.team/problems/J15C>。

---

允许一切的发生。

## 题目描述

你的人生是一张包含 $n$ 个节点的简单（无重边，无自环）无向图，点的编号为 $0 \sim n-1$，$0$ 号节点是你的起点，边的边权均为 $1$。

你会给你人生中的每一个节点，都找到一条从起点到它的最短路，并选中这条路上的所有边。

你会选中尽量少的边。可以证明，你最终会选中 $n-1$ 条边，且这 $n-1$ 条边会构成一棵树。

这好像是 OIer 的宿命——或是贪心或是动态规划，找到最优路径和最优解，如机器般精确地走下去。

可是，你不是机器啊，你是人啊。你想知道，人生这张图，在已知选中的 $n-1$ 条边的情况下，有多少种可能？可能性也许太多了，你需要对 $10^9+7$ 取模。

当你意识到人生还有这么多可能时，你也许就能与自我和解，不再内耗和焦虑了。

叉叉就是这么做的，他希望祝福大家。

## 说明/提示

**【样例解释 #1】**

两种可能分别为：

```
0 1
0 2
```

和

```
0 1
0 2
1 2
```

其中每行表示人生这张图中的一条边。

**【数据范围】**

对于 $100\%$ 的数据，$2 \le n \le 10^6$，输入的边构成一棵树。

| 测试点编号  | $n =$ | 特殊性质 |
| :---------: | :-----: | :------: |
|     $1$     |   $2$   |          |
| $2 \sim 3$  |   $3$   |          |
| $4 \sim 7$  |   $4$   |          |
| $8 \sim 16$ |   $5$   |          |
|    $17$     | $10^6$  | $y=x+1$  |
|    $18$     | $10^6$  |  $x=0$   |
| $19\sim 21$ | $10^3$  |          |
| $22\sim 25$ | $10^6$  |          |



## 样例 #1

### 输入

```
3
0 1
0 2```

### 输出

```
2```

## 样例 #2

### 输入

```
3
0 1
1 2```

### 输出

```
1```

## 样例 #3

### 输入

```
5
0 1
0 2
1 3
1 4```

### 输出

```
16```

# 题解

## 作者：EricWan (赞：5)

给定一颗无向无权图的最短路树，问有多少个图是可能的。

先思考无向无权图的最短路树的生成方法，先 BFS 找到每一个点和源点的距离 $dis_{0\dots n-1}$，对于每一个 $i\in[1, n)$，选择一个与之相邻且 $dis$ 小一的点，将其连边。

首先给定的边肯定是存在的，我们考虑增加一些边使得图还是有给定的这个最短路树。

容易发现，增加一些边后仍然合法的冲要条件是 $dis$ 不变。

我们还可以发现：若新加入边集 $E_1$ 后的图是合法的，新加入边集 $E_2$ 后图还是合法的，那么加入 $E_1\cup E_2$ 后图也是合法的。若新加入边集 $E_1$ 后的图是合法的，那么对于任意 $E_2\subseteq E_1$，加入 $E_2$ 也是合法的。

于是这道题转化为：求有多少条边，使得新加入这一条边后 $dis$ 不变，输出二的这么多次幂，对 $10^9+7$ 取模。

这样这题就做完了，容易发现新加的这一条边肯定在树上要不然连接两个同层的点，要不然连接两个之跨一层的点。

代码是非常好写的，没有任何细节，比 T2 简单多了。

---

## 作者：lcfollower (赞：4)

考虑到这题我们不希望从 $0$ 开始到任意点的最短路路径改变，我们应该尽量添加**无用边**，即添加了这条边，使得 $\forall i,\operatorname {len} \{\operatorname {path} (0 ,i)\}$ 不变（$\operatorname {len ,path}$ 分别为长度和两点间的最短路径）。

设无用边的条数为 $ans$，那么每次可以选择**添或不添**，运用乘法原理（~~样例~~），可知答案为 $2^{ans}$。

那么如何计算 $ans$ 呢？

以下，我们记 $0$（不要忘了它是根节点）的深度为 $1$。

考虑这么一张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/gqjmr3lf.png)

我们在**同层节点**连边为发生什么？

咦，对于一个节点，新增的路径为**到达同层节点再通过同层节点之间的连边**到达这个节点，好像长度还要大 $1$。

画画试试：

![](https://cdn.luogu.com.cn/upload/image_hosting/8pw73g1h.png)

好像真的不变！

因此，我们设同层节点的个数为 $k$，那么数量为 $\frac{k(k-1)}{2}$。

一下记最高深度为 $mxdep$，第 $i$ 层节点数量为 $sum_i$。

那么对于同层节点，贡献即为 $\sum\limits_{i = 1}^{mxdep} \frac{sum_i (sum_i - 1)}{2}$。

为了不混淆，我们记 $sum_0 = 1$，然而其实计算一下发现 $\lfloor\frac{1\times (-1)}{2}\rfloor = 0$ 也没区别。

---

那么真的就结束了吗？

不，明显还有另一种情况，~~更何况代码样例都错了~~。

其实不只是长度变大，我们还要考虑**长度不变**的情况！

有了上面的启发，也就是说，我们可以在该节点的**上一层节点（除父亲，对于非根只有 $1$ 个）到该节点连边**。

效果如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/cwchrv69.png)

那么我们能不能在上上层，上上上层连边呢？

答案是**不可以**，不然长度就减少了。下图中，$0$ 与 $4$ 连边，就会导致长度为 $1$ 而不是 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/xxihtwnq.png)

那么对于上一层节点的贡献总和为 $\sum\limits_{i = 2}^{mxdep} sum_i - 1$。

---

这些总和就是 $ans$ 了。

但是我也不知道 $ans$ 会不会被卡溢出，胆小。

于是我们用欧拉定理，当 $a$，$m$ 互质时，有：

$$a^{\phi (m)} \equiv a^{m} (\bmod\ m)$$

当 $a = 2$，$m = 1e9 + 7$ 时，$a$，$m$ 互质。

又因为 $1e9 + 7$ 是质数，所以 $\phi (1e9 + 7) = 1e9 + 6$。

那么我们只要对 $ans$ 取模 $1e9 + 6$ 就可以了。

剩下的 $2^{ans}$ 用快速幂解决。

---

```cpp
# include <bits/stdc++.h>

# define int long long
# define up(i ,x ,y) for (int i = x ; i <= y ; i ++)
# define dn(i ,x ,y) for (int i = x ; i >= y ; i --)
# define inf 1e14

using namespace std;

inline int read (){int s = 0 ; bool w = 0 ; char c = getchar () ; while (!isdigit (c)) {w |= (c == '-') ,c = getchar () ;} while (isdigit (c)){s = (s << 1) + (s << 3) + (c ^ 48) ; c = getchar ();}return w ? -s : s;}
inline void write (int x){if (x < 0) putchar ('-') ,x = -x; if (x > 9) write (x / 10) ; putchar (x % 10 | 48);}
inline void writesp (int x){write (x) ,putchar (' ');}
inline void writeln (int x){write (x) ,putchar ('\n');}

constexpr int N = 1e6 + 10 ,mod = 1e9 + 7;
int sum[N] ,ans ,n ,mxdep;
vector <int> edge[N];
inline void dfs (int u ,int fath ,int dep){
  sum[dep] ++;
  mxdep = max (mxdep ,dep);
  for (int v : edge[u]) {
    if (v == fath) continue;
    dfs (v ,u ,dep + 1);
  }  
} inline int qpow (int a ,int b){
  int res = 1;
  while (b) {
    if (b & 1) res = res * a % mod;
    a = a * a % mod;
    b >>= 1;
  } return res;
} signed main (){
  n = read ();
  up (i ,1 ,n - 1) {
    int u = read () + 1 ,v = read () + 1;
    edge[u].push_back (v) ;
    edge[v].push_back (u) ;
  } dfs (1 ,0 ,1);
  sum[0] = 1;
  up (i ,1 ,mxdep) ans += (sum[i] - 1) * sum[i] / 2 ,ans %= (mod - 1);
  up (i ,1 ,mxdep) ans += sum[i] * (sum[i - 1] - 1) ,ans %= (mod - 1);
  writeln (qpow (2 ,ans));
  return 0 ;
}
```

---

## 作者：skyx (赞：3)

# 【MX-J15-T3】叉叉学习与自我和解-题解
## 简要题意

给定一棵以 $0$ 号节点为根的树，表示从起点 $0$ 到所有其他节点的最短路树（BFS 树）。问在所有可能的原图中（边权均为 $1$），有多少种不同的图能生成这棵最短路树？答案对 $10^9 + 7$ 取模。

## 题目分析
计数题。

首先考虑到的是与动态规划相似的由下而上尝试去统计，但发现路径的选择是依赖于跨层节点去怎么样选择的，也许不能满足最优子结构性质（~~大概是我不会写吧~~）。

考虑树的本质结构，即树是由节点和边构成。每条边的存在连接了不同的层级或节点，这些边决定了不同节点之间的路径，路径选择数就可以转化为“每一层和层之间、同一层内有多少条边可以选择”，于是我们可以将问题转化为：求有多少可以添加的边。

两个特殊性质对我都有一些启发，下面从这两个特殊性质入手尝试推理。

### 同层计数
参考 $18$ 号测试点，考虑同层上能添加多少条边，给出的树必然覆盖了所有节点，并给出了其深度的关系，我们可以先获得同一深度 $d$ 有多少个节点，因为其任意两点的连接都必然不在树上（在树中，任意两个节点之间已经存在一条唯一的路径），我们可以在同层所有的节点中任选 $2$ 个添加一条无向边，于是可以添加的边数为：
$$
\binom{num_d}{2} = \frac{num_d \times (num_d - 1)}{2}
$$
其中 $num_d$ 表示深度 $d$ 有多少个节点。同时，当该层上至少有 $2$ 个节点，才能有被添加的边。

### 异层计数
参考 $17$ 号测试点，深度 $d$ 和 $d+1$ 之间共有 $num_d \times (num_{d+1})$ 种可能，但树里已经占用每个深度 $d+1$ 的节点各自与它在深度 $d$ 的父亲之间的 $1$ 条边，一共 $num_{d+1}$ 条。因此可加的边数为： 
$$ 
(num_d-1) \times num_{d+1} 
$$

- 对于深度为 $d$ 的每个节点，它可以与深度 $d+1$ 的多个节点连接，但它与深度 $d$ 的父节点的边已经占用。因此，实际上深度 $d$ 的节点只剩下 $num_d - 1$ 个自由的连接空间。

由于每条边可选可不选，总方案数是 $2^{kj}$，其中 $kj$ 是可以添加的边的总数量，由上两种情况相加得到。

## 代码实现
使用了费马小定理在最后缩小了模运算的指数，另外注意爆 `long long`。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct edge
{
	int to;
	int nxt;
} e[2000050];
int head[2000050];
int cnt;
void add(int u, int v)
{
	cnt++;
	e[cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
const int mod = 1e9 + 7;
ll qpow(ll a, ll b)
{
	ll ans = 1;
	while (b > 0)
	{
		if (b & 1) ans = ans * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return ans;
}
int dep[1000060]; //dep[i] 表示节点 i 在树中的深度
int num[1000060]; //num[d] 表示深度为 d 的层中有多少个节点
queue<int> q;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;
	for (int i = 1; i < n; i++)
	{
		int u, v;
		cin >> u >> v;
		add(u, v);
		add(v, u);
	}
	dep[0] = 1;
	num[1] = 1;
	q.push(0);
	int maxd = 1;
	while (!q.empty())
	{
		int x = q.front();
		q.pop();
		for (int i = head[x]; i; i = e[i].nxt)
		{
			int y = e[i].to;
			if (dep[y] == 0)
			{
				dep[y] = dep[x] + 1;
				maxd = max(maxd, dep[y]);
				num[dep[y]]++;
				q.push(y);
			}
		}
	} //计算每个节点的深度和每层的节点数量
	ll kj = 0;
	for (int i = 1; i <= maxd; i++)
	{
		if (num[i] >= 2) kj += 1ll * num[i] * (num[i] - 1) / 2;
	}
	for (int i = 1; i < maxd; i++)
	{
		kj += 1ll * (num[i] - 1) * num[i + 1];
	}
	cout << qpow(2, kj % (mod - 1)) % mod;
	return 0;
}
```

---

## 作者：shuqiang (赞：2)

~~感觉这题目主要难度就是要看懂。~~

### 题目大意

一张包含 $n$ 个节点的简单（无重边，无自环）无向图，点的编号为 $0 \sim n-1$，边的边权均为 $1$，每一个节点，都找到一条从 $0$ 号节点到它的最短路，并选中这条路上的所有边。

你会选中尽量少的边。可以证明，你最终会选中 $n-1$ 条边，且这 $n-1$ 条边会构成一棵树。

在已知选中的 $n-1$ 条边的情况下，有多少种可能？你需要对 $10^9+7$ 取模。

### 题目解法

先看样例 $3$：

![](https://cdn.luogu.com.cn/upload/image_hosting/kvxws93z.png)

先看每个点道第 $0$ 个点的最短路：
- $0:0$。
- $1:1 \rightarrow 0$。
- $2:2 \rightarrow 0$。
- $3:3 \rightarrow 1 \rightarrow 0$。
- $4:4 \rightarrow 1 \rightarrow 0$。

我们要保证每个节点从 $0$ 号节点到它的最短路不变，就不能存在节点经过新加入的边到达 $0$ 号节点的边数减少，所以，假设我们要加入的边为 $(u,v)$，就要保证 $|dep_u-dep_v| < 2$，先统计每个深度有多少个节点，假设深度为 $i$ 的有 $a_i$ 个，分开考虑：

1. $|dep_u-dep_v|=0$，即 $dep_u=dep_v$，可添加边数就为 $\sum^{n}_{i=1}\frac{a_i(a_i-1)}{2}$。
2. $|dep_u-dep_v|=1$，由于下面的节点都已经有一条边连向上面的节点，可添加边数就为 $\sum^{n-1}_{i=1}a_{i+1}(a_i-1)$。

每条边都可以添加或不添加，答案就是 $2$ 的可添加边数次方，可以用快速幂。

用这种方式算样例 $3$，发现有 $4$ 条边可以添加：

![](https://cdn.luogu.com.cn/upload/image_hosting/e211adeq.png)

答案就是 $2^4=16$。

参考代码：

```cpp
#include<iostream>
#include<vector>

using namespace std;
typedef long long ll;

const int N = 1e6 + 10, mod = 1e9 + 7;
int n, u, v, dep[N], cnt[N]; ll ans;
vector<int> g[N];

void dfs(int u, int f){
	dep[u] = dep[f] + 1;
	for(int v: g[u]){
		if(v == f) continue;
		dfs(v, u);
	}
}

int qpow(int x, ll y){
	int res = 1;
	while(y){
		if(y&1) res = (ll)res * x % mod;
		y >>= 1;
		x = (ll)x * x % mod;
	}
	return res;
}

int main(){
	cin >> n;
	for(int i = 1; i < n; i++){
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(0, n);
	for(int i = 0; i < n; i++) cnt[dep[i]]++;
	for(int i = 1; i <= n; i++){
		ans += (ll)cnt[i]*(cnt[i]-1)/2;
		if(i > 1) ans += (ll)cnt[i] * (cnt[i-1]-1);
	}
	cout << qpow(2, ans);
    return 0;
}

```

---

## 作者：dongzirui0817 (赞：2)

注：本文中 $\land$ 表示与，$\lor$ 表示或。

首先，以 $0$ 号点为根，可以算出这个树各个点的深度。设 $i$ 号点深度为 $d_i$。

然后你会发现一个结论：把 $i$ 号点和 $j$ 号点连一条边后还能满足条件的**不同的** $i, \, j$，当且仅当 $|d_i - d_j| \le 1 \land f_i \not = j \land f_j \not = i$。其中 $f_u$ 表示 $u$ 号点的父亲编号，特别地，$f_0 = 0$。

**证明**：如果 $i = j$，图就有自环；如果 $f_i = j \lor f_j = i$，图就有重边，均不满足。  
而如果 $|d_i - d_j| > 1$，那么添加完这条边后，从 $i$ 号点（或 $j$ 号点）到 $j$ 号点（或 $i$ 号点）的距离更短，$d_j$ 或 $d_i$ 就会发生改变，既而改变这棵树，不满足。

所以设 $s_u$ 为满足 $d_v = u \land 0 \le v < n$ 的 $j$ 的数量，$c_u$ 为 $u$ 号点的儿子和父亲的数量，那么对于一个 $i$，能与其连接的点共有 $s_{d_i} + s_{d_{i-1}}+ s_{d_{i+1}} - c_i - 1$。  
因为满足条件的点 $j$ 都在 $[d_j - 1, \, d_j + 1]$ 范围内，而 $i$ 的父亲、其本身和它的所有儿子的深度也是这个范围，要将其减去。

但一条边会被算两边，所以要除以 $2$。

所以设：

$$\begin{aligned} r &= \sum_{i=0}^{n-1} (s_{d_i} + s_{d_{i-1}}+ s_{d_{i+1}} - c_i - 1)
\\ &= \sum_{i=0}^{n-1} (s_{d_i} + s_{d_{i-1}} + s_{d_{i+1}}) - \sum_{i=0}^{n-1} c_i - n
\\ &= \sum_{i=0}^{n-1} (s_{d_i} + s_{d_{i-1}} + s_{d_{i+1}}) - 3n + 2  \end{aligned}$$

那么添加后合法的边有 $\frac{r}{2}$ 条。

最后合法的每一条边可以添加，也可以不添加，所以共有 $2^{\frac{r}{2}}$ 种情况。  
但合法的边很多，所以要快速幂。

时间复杂度 $O(n + \log n^2)$，但不知为什么，要跑近 [$900$ ms](https://www.luogu.com.cn/record/219219698)。

注：时间复杂度为 $O(n + \log n^2)$ 是因为还有快速幂，而边最多是 $O(n^2)$ 的。而且 $n = 3$ 时，$\log n^2 > n$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int p = 1e9 + 7;

int n;
vector <int> edge[1000010];
int d[1000010], fa[1000010];
int s[1000010];
int c[1000010];
ll res = 0, ans = 1, a = 2;

inline void dfs(int x) {
	for (auto y : edge[x])
		if (!d[y])
			d[y] = d[x] + 1, fa[y] = x, dfs(y);
}

int main() {
	cin >> n;
	for (int u, v, i = 1 ; i < n ; i++)
		cin >> u >> v,
		edge[u].push_back(v),
		edge[v].push_back(u);
	d[0] = 1;
	dfs(0);
	for (int i = 0 ; i < n ; i++) s[d[i]]++;
	for (int i = 0 ; i < n ; i++)
		res += s[d[i]] + s[d[i] - 1] + s[d[i] + 1];
	res = (res - 3 * n + 2) / 2;
	for ( ; res ; a = a * a % p, res >>= 1)
		ans = ans * ((a - 1) * (res & 1) + 1) % p;
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Eason_cyx (赞：1)

这不比前两题简单？

----

因为根是 $0$，所以我们可以首先从根开始做一遍 DFS，求出每个点到根的距离，记为 $dep_i$。

然后考虑新增的连边：

假设边的两端分别是 $i$ 和 $j$。不妨 $dep_i \le dep_j$。

若 $dep_j \ge dep_i+2$，那么在连了 $(i,j)$ 之后，$0$ 到 $j$ 的最短路就变成了 $dep_i+1$，与题意矛盾。

所以一个点只能和与自己深度相差不超过 $1$ 的点连边。加法原理可以算出能连多少条边。

因为这些边都相互独立，所以再用乘法原理，假设有 $p$ 条边可以连，答案就是 $2^p$。

时间复杂度 $O(n)$。加法原理的处理请看代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5, mod = 1e9 + 7;
int dep[N], cnt[N];
vector<int> e[N];
int qpow(int x) {
    int c = 1, b = 2;
    while(x) { if(x & 1) c = (c * b) % mod; b = (b * b) % mod; x >>= 1; }
    return c;
} void dfs(int now, int fa) {
    dep[now] = dep[fa] + 1; cnt[dep[now]]++;
    for(int i = 0;i < e[now].size();i++) {
        if(e[now][i] == fa) continue;
        dfs(e[now][i], now);
    }
} signed main() {
    int n; cin >> n;
    for(int i = 1, x, y;i < n;i++)
        cin >> x >> y,
        e[x].push_back(y), e[y].push_back(x);
    dep[n + 1] = -1, dfs(0, n+1);
    int ans1 = 0, ans2 = 0;
    for(int i = 1;i < n;i++) {
        ans1 += cnt[dep[i]-1] - 1, ans2 += cnt[dep[i]] - 1;
    } cout << qpow(ans1 + ans2 / 2) << endl;
    return 0;
}
```

---

## 作者：ZHR100102 (赞：1)

[Blog](https://www.cnblogs.com/zhr0102/p/18906292)


题意显然可以转化为：给定一棵有根树，有多少种加边方案使得从根到某个节点的最短路不变。

考虑如何刻画加边的限制，不难发现一条边能加当且仅当它**不影响到另一节点的最短路**且**以前从未出现过**，即 $|dep_u-dep_v|\le 1$。

于是开桶记录每个深度的节点个数，以及每个深度到下一深度的边数，那么这些边的总个数 $sum$ 即为相同深度的横叉边、相差 $1$ 深度且之前未出现过的横叉边的总个数。

因为**每条边不会影响其他边**，所以总方案数为 $2^{sum}$。


时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=1000005,inf=0x3f3f3f3f;
const ll mod=1e9+7;
int n,dep[N],tot[N],c[N];
ll sm=0;
vector<int>g[N];
ll qpow(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)res=(res*a)%mod;
        b>>=1;
        a=(a*a)%mod;
    }
    return res;
}
void dfs(int u,int fa)
{
    tot[dep[u]]++;
    for(auto v:g[u])
    {
        if(v==fa)continue;
        dep[v]=dep[u]+1;
        c[dep[u]]++;
        dfs(v,u);
    }
}
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(0,-1);
    for(int i=0;i<=n;i++)
    {
        sm+=(1ll*tot[i]*(tot[i]-1)/2);
        sm+=(1ll*tot[i]*tot[i+1]-c[i]);
    }
    cout<<qpow(2,sm)%mod;
    return 0;
}
```

---

## 作者：swate114514 (赞：1)

## 题意
给定一棵以节点 $0$ 为根的树，要求计算有多少张包含该树边的无向图，满足从节点 $0$ 到任意节点的最短路唯一，且该最短路就是树上的路径。

图可以添加额外的边，但必须满足以下条件：
1. 添加的边不能破坏从 $0$ 到任意节点的最短路（树上路径仍是最短路，且唯一）。
2. 添加的边不能是树中已存在的边。

## 关键观察
最短路的条件是：
- 设节点 $v$ 在树中的深度为 $d_v$，则从 $0$ 到 $v$ 的最短路长度必须为 $d_v$，且路径唯一。

---
添加非树边 $(u, v)$ 必须满足：
$$|d_u - d_v| \leq 1$$
**证明**：
- 若 $|d_u - d_v| \geq 2$，不妨设 $d_u \leq d_v - 2$，则路径 $0 \to u \to v$ 的长度为 $d_u + 1 \leq d_v - 1 < d_v$，比树路径更短，矛盾。
- 当 $|d_u - d_v| \leq 1$ 时，对任意节点 $w$，路径 $0 \to u \to v \to w$ 的长度满足：
  $$d_u + 1 + \delta(v,w) \geq (d_v - 1) + 1 + |d_w - d_v| \geq d_w$$
  其中 $\delta(v,w)$ 是 $v$ 到 $w$ 的最短距离，因此不会产生更短路径。

---
非树边如何计数？

深度为 $i$ 的节点数 $c_i$，则同层非树边数量为：
  $$\binom{c_i}{2} = \frac{c_i(c_i - 1)}{2}$$
  
深度 $i$ 与 $i+1$ 的节点间，总边数为 $c_i \times c_{i+1}$，树边数量为 $c_{i+1}$，故非树边数量为：
  $$c_i \times c_{i+1} - c_{i+1} = c_{i+1}(c_i - 1)$$

--- 
综上所述，总非树边数 $t$ 为：
$$
t = \sum_{i=0}^{\text{max\_depth}} \binom{c_i}{2} + \sum_{i=0}^{\text{max\_depth}-1} c_i \times c_{i+1} - (n-1)
$$

每条非树边可选可不选，故方案数为：
$$ \text{ans} = 2^t \mod (10^9+7) $$

时间复杂度 BFS 部分 $O(n)$，计算 $t$ 需 $O(n)$。

空间复杂度$O(n)$。

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

const ll M = 1000000007;

ll qp(ll b, ll e) {
	ll r = 1;
	while (e) {
		if (e & 1) r = r * b % M;
		b = b * b % M;
		e >>= 1;
	}
	return r;
}

int main() 
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin >> n;
	vector<vector<int>> g(n);
	for (int i = 0; i < n - 1; ++i) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	
	vector<ll> d(n, -1);
	vector<ll> c(n, 0);
	queue<int> q;
	q.push(0);
	d[0] = 0;
	c[0] = 1;
	ll md = 0;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (int v : g[u]) {
			if (d[v] == -1) {
				d[v] = d[u] + 1;
				c[d[v]]++;
				if (d[v] > md) md = d[v];
				q.push(v);
			}
		}
	}
	
	ll t = 0;
	for (int i = 0; i <= md; ++i) {
		t += c[i] * (c[i] - 1) >> 1;
	}
	
	for (int i = 0; i < md; ++i) {
		t += c[i] * c[i+1];
	}
	
	t -= n - 1;
	
	cout << qp(2, t);
	
	return 0;
}
```

---

## 作者：lznxes_xh (赞：1)

### 前言

或贪心或 dp 地做最优解，或 dp 或二分地解决单调性问题，dp 或组合数学地做计数，或 dp 或数学地做构造，或 dp 或搜索地做图论，或 dp 或数据结构地做可行性，或 dp 或唉声叹气地活着，我们活在 dp 里，当然，这题的 dp 含量很低，只有求深度。

### 思路

清新图论题。

首先的首先，本题解节点编号为 $1\sim n$，代码中已经做了处理。

首先，实际上，对于所有**不影响最短路**的边，都是选不选都可以，设这种边的数量为 $ans$，则答案为 $2^{ans}$。

那么接着我们来讨论哪些边不影响，显然给定的图是一颗树，那么我们让 $1$ 号点为根，节点深度 $d_i$ 就是到 $1$ 号点的距离减 $1$，这里不影响答案，我们来看样例 $3$ 的树。

![](https://cdn.luogu.com.cn/upload/image_hosting/m2t0krrl.png)

我们给出 $d$ 数组：

$$
d_1=1,d_2=2,d_3=3,d_4=4,d_5=5
$$

显然，对于 $(i,j)$，如果 $d_j>d_i+1$，那么连边后最短路更新了，不能连。考虑到重边，我们只能额外连：

- $d_i=d_j$

- $d_i=d_j+1$

第 $1$ 种的答案是 $\sum^{\infty}_{i=1}d_i\times(d_i-1)\div 2$，很好求。对于第 $2$ 种，对于 $d_i$，除了自己父亲，上一层都有 $d_{i-1}-1$ 条边与自己相连，因此答案是 $\sum^{\infty}_{i=1}(d_i-1)d_{i+1}$。当然这里无限求 $d_i$ 最大即可。

最后求和用快速幂求答案即可。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,ans,dis[1000005],f[1000005],d[10000005];
vector<int> g[1000005];
void bfs()
{
	queue<int> q;     
	q.push(1);
	f[1] = 1;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int v : g[u])
		{
			if (!f[v])
			{
				f[v] = 1;
				dis[v] = dis[u] + 1;
				q.push(v);
			}
		}
	}
}
int qpow(int a,int b,int p)
{
	int res = 1;
	while (b != 0)
	{
		if (b % 2 == 1) res = res * a % p;
		a = a * a % p,b /= 2;
		
	}
	return res;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1,u,v;i < n;i++) 
	{
		cin >> u >> v;
		u++,v++;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	bfs();
	int ma = INT_MIN,ans = 0;
	for (int i = 1;i <= n;i++)
	{
		d[dis[i] + 1]++;
		ma = max(ma,dis[i] + 1);
	}
	for (int i = 1;i < ma;i++)
	{
		ans = ans + (d[i] - 1) * d[i + 1];
	}
	for (int i = 1;i <= ma;i++)
	{
		ans = ans + (d[i] * (d[i] - 1) / 2);
	}
	const int md = 1e9 + 7;
	cout << qpow(2,ans,md);
	return 0;
}
```

---

## 作者：CaiZi (赞：1)

感觉是这场最简单题（比 T1 和 T2 还简单）。

以下记点的编号为 $1\sim n$，$1$ 号节点是你的起点。

我们要求有多少种加边方案使得点 $1$ 到每个点的最短路不变。首先我们发现，若只加边 $(a,b)$ 后的图合法，且只加边 $(c,d)$ 后的图合法，则加边 $(a,b)$ 和边 $(c,d)$ 后的图合法。因为加完 $(a,b)$ 后点 $1$ 到每个点的最短路不变。

于是现在问题就变成了有多少条边可以加，若有 $l$ 条边，则答案为 $2^l$。因为每条可以加的边有加 / 不加两种状态。

考虑先求出点 $1$ 到每个点的最短路，即以 $1$ 为根时每个点的深度，记为 $d_i$。不难发现当 $d_i-d_j=0/1$ 且树不存在边 $(i,j)$ 时可以加边 $(i,j)$。

然后考虑记 $r_e$ 表示 $d_i=e$ 的 $i$ 的个数，分两种情况计算，再加起来则为 $l$：
- $d_i-d_j=0$：此时相当于在树的同一层之间两两连边，答案为 $\sum_{i=1}^n\frac{r_e(r_e-1)}{2}$。
- $d_i-d_j=1$：枚举 $j$，那么 $i$ 在 $j$ 的父亲那一层的节点中，但是 $i$ 不能为 $j$ 的父亲，答案为 $\sum_{i=2}^n(r_{d_i-1}-1)$。

除去最终使用快速幂计算答案，时间复杂度为 $O(n)$。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int n,x,y,d[1000001],r[1000001],l;
vector<int>g[1000001];
inline void dfs(int i,int j){
	d[i]=d[j]+1;
	r[d[i]]++;
	for(int k:g[i]){
		if(k!=j){
			dfs(k,i);
		}
	}
}
inline int pw(int i,int j,int k=1){
	while(j){
		if(j&1ll){
			k=k*i%mod;
		}
		i=i*i%mod;
		j>>=1ll;
	}
	return k;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n-1;i++){
		cin>>x>>y;
		g[x+1].push_back(y+1);
		g[y+1].push_back(x+1);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++){
		l+=r[i]*(r[i]-1)/2;
	}
	for(int i=2;i<=n;i++){
		l+=r[d[i]-1]-1;
	}
	cout<<pw(2,l);
	return 0;
}
```

---

## 作者：yihang2011 (赞：0)

### [P12683 【MX-J15-T3】叉叉学习与自我和解](https://www.luogu.com.cn/problem/P12683)

**建议所有 80 分的先查一下自己取模有没有取对，应根据[拓展欧拉定理](https://oi-wiki.org/math/number-theory/fermat/)对指数取模。**

图论题。

给出以编号为 $0$ 的点为根的树，且所有边的边权均为 $1$。添加一些边将其变成简单图，并且要求对于图上每个点，图上最短路长度不小于原树上路径的长度。求添加边的方案数，答案对 $10^9 + 7$ 取模。

记 $dep_i$ 为原树点 $i$ 的深度，$dep_0 = 1$。由于原树上路径已经是最短路，所以添加边 $u \rightarrow v$ 只能有两种情况：

- $dep_u = dep_v$

- $\lvert dep_u - dep_v \rvert = 1$

考虑分类讨论。记 $cnt_i$ 为 $dep_j = i$ 的节点个数。

对于 $dep_u = dep_v$，则深度为 $dep_u$ 这一层一共可以连出 $cnt_{dep_u}(cnt_{dep_u} - 1)$ 条边；

对于 $\lvert dep_u - dep_v \rvert = 1$，设 $dep_v - dep_u = 1$，则深度为 $dep_u$ 这一层一共可以往下一层连出 $cnt_{dep_u} \cdot cnt_{dep_v} = cnt_{dep_u} \cdot cnt_{dep_{u + 1}}$ 条边。

将两种情况得到的结果求和，记为 $k$，即在图上最短路长度不小于原树上路径的长度的情况下，一共可以连出 $k$ 条边，但其中包括原本给出的 $n - 1$ 条边，剩下的边有选与不选两种情况，即最终答案为 $2^{k - (n - 1)}$。

根据[拓展欧拉定理](https://oi-wiki.org/math/number-theory/fermat/)，结果 $\displaystyle 2^{k - (n - 1)} \bmod (10^9 + 7) = 2^{[k - (n - 1)] \bmod \varphi(10^9 + 7)} = 2^{(k - n + 1) \bmod (10^9 + 6)}$。

快速幂求解即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i, l, r) for (int i = l; i <= r; i++) 
#define rrep(i, r, l) for (int i = r; i >= l; i--)
#define lrep(i, from, nxt) for (int i = from; i; i = nxt)
#define arep(x, s) for (auto &x : s)
using ll = long long;

int rd() {
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-') {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = x * 10 + ch - '0', ch = getchar();
    }
    return x * f;
}

const int mod = 1e9 + 7;
const int N = 1e6 + 10;

int n;
ll ans;
struct edge {
    int to, nxt;
} e[N << 1];
int depth;
int dep[N], cnt[N], head[N];
int tot;

void add_edge(int u, int v) {
    e[++tot].to = v;
    e[tot].nxt = head[u];
    head[u] = tot;
}

ll qp(ll x, int k) {
    ll res = 1;
    while (k) {
        if (k & 1) {
            res = (res * x) % mod;
        }
        x = (x * x) % mod;
        k >>= 1;
    }
    return res;
}

void dfs(int u, int pa) {
    dep[u] = dep[pa] + 1;
    cnt[dep[u]]++;
    depth = max(depth, dep[u]);
    lrep(i, head[u], e[i].nxt) {
        if (e[i].to == pa) {
            continue ;
        }
        dfs(e[i].to, u);
    }
}

int main() {
    n = rd();
    rep(i, 1, n - 1) {
        int u = rd(), v = rd();
        add_edge(u, v); add_edge(v, u);
    }
    dfs(0, n);
    rep(i, 1, n - 1) {
        ans = (ans + (1ll * cnt[i] * cnt[i + 1]));
    }
    rep(i, 1, n) {
        ans = (ans + (1ll * cnt[i] * (cnt[i] - 1) / 2));
    }
    ans = (ans + (mod - 1) - (n - 1)) % (mod - 1);
    cout << qp(2, ans) << endl;
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/219275767)

---

## 作者：_smart_stupid_ (赞：0)

## [题目](https://www.luogu.com.cn/problem/P12683)

我们接下来将 “深度为 $x$ 的点” 解释为在原树中与根节点距离为 $x - 1$ 的点。

我们发现，在这棵树中，如果深度为 $x$ 和深度为 $x + 2$ 的点中连了一条边，那么深度为 $x + 2$ 到 $1$ 节点的最短路就会改变，而深度为 $x$ 和 $x + 1$ 之间的点无论怎么连，最短路距离不变，深度为 $x$ 和 $x$ 同理。

接下来让 $c_x$ 代表深度为 $x$ 的点的数量，$m$ 代表原图的边数（即 $n - 1$）答案为：

$$
\LARGE{2^{\sum\limits_{i=1}^n\frac{c_i(c_i-1)}{2}+\sum\limits_{i=1}^{n-1}c_ic_{i+1}-m}}
$$

减去 $m$ 是因为原图中有 $m$ 条边的状态已经确定是连接。

## CE CODE：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
vector<int> g[1000100];
long long dep[1000100], cnt[1000100];
long long ans, mod = 1000000007;
long long fpow(long long a, long long b) {
	long long ans = 1;
	while (b) {
		if (b & 1) ans = ans * a % mod;
		a = a * a % mod, b >>= 1;
	}
	return ans;
}
void dfs(int u) {
	cnt[dep[u]]++;
	int cnt1 = 0;
	for (auto v : g[u]) {
		if (!dep[v]) {
			dep[v] = dep[u] + 1;
			dfs(v);
			cnt1++;
		}
	}
}
signed mian() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		u++, v++;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dep[1] = 1;
	dfs(1);
	for (int i = 1; i <= n; i++) {
		ans += cnt[i] * cnt[i + 1];
		ans += cnt[i] * (cnt[i] - 1) / 2;
	}
  ans -= (n - 1);
	cout << fpow(2, ans) << '\n';
	return 0;
}
```

---

## 作者：b__b (赞：0)

## 题目大意
将一个简单连通图（所有边的边权都是 $1$）从 $0$ 号点到其他所有点的最短路径上经过的边以外的边全部删除，得到一个树，把最后的树给你，求有多少个的图可以生成这样的树。

~~我也不确定有没有讲清楚。~~
## 思路
我们考虑用树反推图，求出这棵树在满足上面性质的情况下能够连多少条边。

**定理：这个树上的节点能且只能与当前同一深度的节点和上一层非其父亲的节点连边。**

（其实与下一层也是可以的，但是为了不重复连边还是这样写。）

下文用图片展示（[画图网站](https://csacademy.com/app/graph_editor)）：

![](https://cdn.luogu.com.cn/upload/image_hosting/f1ttnhmx.png)

这是一个可能的树。

我们可以这样插入这么些边，这样不会影响最后生成的树是上图的结果（而且没有重边与自环），因为原有的边仍然是最短路径（或者之一）上的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/spi6vlnp.png)

但是 $2$ 号节点不能跟 $5$ 号节点连边，因为如果连起来从 $0$ 号点出发到 $5$ 号点的最短路径就是 $0\rightarrow2\rightarrow5$，只经过三条边，而不是原来 $0\rightarrow1\rightarrow4\rightarrow5$ 的四条边，因此生成的树就会改变，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/qli45cw6.png)

综上，定理得证。

定义 $\mathrm{dn}_n$ 表示所有点中深度为 $n$ 的点的数量。

现在我们考虑第 $n$ 层（不考虑 $0$ 号节点所在的第 $1$ 层，因为显然这一层不会产生新的边）可以多出来多少条边。

首先显然同一层的节点是不会连边的，因此每一个点都可以与除自己之外（因为不能有自环）的所有点连边，因此最后就会有 $\frac{\mathrm{dn}_n(\mathrm{dn}_n-1)}{2}$ 条多的边（因为每两个点之间会重复连一次所以要除以二）。

接着同一层的每一个点与上一层有且只会有一个点相连，因此每一个点都可以与除了它父亲的点的所有点连一条边，也就是连 $\mathrm{dn}_{n-1}-1$ 条边，因此这样可以生成 $\mathrm{dn}_n(\mathrm{dn}_{n-1}-1)$ 条边。

综上，对于每一个 $2\leq i \leq n$，可以生成 $\frac{\mathrm{dn}_n(\mathrm{dn}_n-1)}{2}+\mathrm{dn}_n(\mathrm{dn}_{n-1}-1)$ 条边（下文将这个数记为 $p$）。

每一条边都可以加上也可以不加，因此会有 $2^p$ 种可能。

我们来计算一下 $p$ 最大可以是多少。

考虑一个有 $10^6$ 个点的简单全连通图，总共会有 $\frac{10^6(10^6-1)}{2}$ 条边，生成的树只有 $10^6-1$ 条边，因此会有 $\frac{10^6(10^6-1)}{2}-(10^6-1) \approx 5 \times 10^{11}$ 条边，如果一步一步乘复杂度是 $\mathcal{O}(n)$ 的，会 [TLE](https://www.luogu.com.cn/record/219254892)，因此要用到快速幂，不了解快速幂的请自行上网搜索。

最后，~~[十年 OI 一场空，不开 long long 见祖宗](https://www.luogu.com.cn/record/219221285)~~。

## 代码
```cpp
#include <cstdio>
const int N = 1e6 + 5, MOD = 1e9 + 7;
int n, x, y, i;
long long knb, base = 2, nowzs = 1, ans = 1, depthnum[N], depth[N];
int main() {
    for (scanf("%d", &n), depthnum[0] = 1; i < n - 1; ++i) scanf("%d%d", &x, &y), ++depthnum[depth[y] = depth[x] + 1];
    for (i = 1; depthnum[i]; ++i) knb += (depthnum[i] * (depthnum[i] - 1) >> 1) + depthnum[i] * (depthnum[i - 1] - 1);
    while (nowzs <= knb) {
        if (knb & nowzs) ans = (ans * base) % MOD;
        base *= base, base %= MOD, nowzs <<= 1;
    }
    printf("%lld", ans);
}
```

---

## 作者：Lian_zy (赞：0)

题意简述：

给你一棵树，随意加边，但是 $0$ 号节点到所有节点的最短路径长度不变，求方案数。

显然，加边只有这两种情况：

- 同深度的兄弟之间加边。

- 和下一层的某个节点加边（但是不能和自己的孩子连边，这样就重复了）。

我们不妨处理出每一层的节点数量记为 $a_i$。

考虑到了第 $i$ 层。

于是第一种情况最多连 $\frac{a_i\times(a_i-1)}{2}$  条边，每条边可以连或者不连，一共有：

$$
2^{\frac{a_i\times(a_i-1)}{2}}
$$

种情况。

然后是第二种情况。先不考虑重边，一共 $a_i\times a_{i+1}$ 种情况。

然后考虑重边，每个节点不能和自己的孩子链接，那么我们减去第 $i$ 层节点下接的孩子个数和，可以发现这刚好等于 $a_{i+1}$。

然后就可以写出式子：

$$
2^{(a_i-1)\times a_{i+1}}
$$

然后根据乘法原理，只要把所有层的这些贡献和都乘起来就好了。

然后我们就可以过掉了。

不过最后注意一点，这个 $(a_i-1)\times a_{i+1}$ 和 $\frac{a_i\times(a_i-1)}{2}$ 可能会很大，这样我们套一个费马小定理就可以了。

AC code:

``` cpp
#include<bits/stdc++.h>
#define N 1000005
#define ll long long
#define mod 1000000007
using namespace std;

vector<ll>G[N];
ll n,x,y,ans,cnt,d[N],a[N];
ll quick_pow(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&1)ans=(ans*x)%mod;
		x=(x*x)%mod;
		y>>=1;
	}
	return ans;
}
ll C2(ll x){
	return x*(x-1)/2;
}
void dfs(ll x,ll f){
	d[x]=d[f]+1;
	a[d[x]]++;
	cnt=max(cnt,d[x]);
	for(auto v:G[x]){
		if(v==f)continue;
		dfs(v,x);
	}
}
int main(){
	scanf("%lld",&n);
	for(int i=1;i<n;i++){
		scanf("%lld%lld",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dfs(0,0);
	ans=1;
	for(int i=1;i<=cnt;i++){
		ans*=quick_pow(2,C2(a[i])%(mod-1))*quick_pow(2,(a[i]-1)*a[i+1]%(mod-1))%mod;
		ans%=mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：shinzanmono (赞：0)

考虑这个树的性质，发现只有 $|dep_u-dep_v|\leq 1$ 的点对 $(u,v)$ 之间才可能存在边。证明考虑 $dep_v> dep_u+1$ 则到 $v$ 的最短路已经会更小。

dfs 扫出来每个点的深度，设深度为 $d$ 的点的个数为 $cnt_d$。则可能新加的边的个数 $K=\sum_{d=1}^{maxd-1}cnt_{d}\times cnt_{d+1}+\sum_{d=1}^{maxd}cnt_{d}\times(cnt_d-1)/2$。

每条边可能选或不选，所以答案是 $2^K$。

```cpp
#include<iostream>
#include<algorithm>
using ll=long long;
const int sz=1e6+10;
const ll mod=1e9+7;
ll qpow(ll base,ll exp){
  ll ans=1;
  while(exp!=0){
    if(exp&1)ans=ans*base%mod;
    base=base*base%mod,exp>>=1;
  }
  return ans;
}
std::basic_string<int>graph[sz];
int dep[sz],f[sz];
void dfs(int u,int fau){
  dep[u]=dep[fau]+1,f[dep[u]]++;
  for(int v:graph[u]){
    if(v==fau)continue;
    dfs(v,u);
  }
}
int main(){
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n;
  std::cin>>n;
  for(int i=1,u,v;i<n;i++)std::cin>>u>>v,graph[u]+=v,graph[v]+=u;
  dfs(0,0);
  long long ans=1-n;
  for(int i=1;i<=n;i++)ans+=1ll*f[i]*f[i+1]+1ll*f[i]*(f[i]-1)/2;
  std::cout<<qpow(2,ans)<<"\n";
  return 0;
}
```

---

## 作者：fish_love_cat (赞：0)

一眼题，全场最简单的。

---

假设这棵树的根为 $0$ 节点。

由于题意可知，能够连边的两个点深度差不应大于一，否则最短路将受影响。

然后容易发现边与边之间互不干扰，所以只需要统计出能连的边数 $x$，根据乘法原理即可得到答案为 $2^x$。

于是一个树形 dp 后上一个快速幂做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>ve[1000005];
int dp[1000005];
void dfs(int x,int fa){
    for(int i=0;i<ve[x].size();i++){
        if(fa==ve[x][i])continue;
        dp[ve[x][i]]=dp[x]+1;
        dfs(ve[x][i],x);
    }
}
int t[1000005];
#define flc_INF LLONG_MAX
int qpow(int a,int b,int p=flc_INF){
	int ans=1;
	if(b==0)return 1;
	while(b){
		if(b&1)ans*=a,ans%=p;
		a*=a,b>>=1,a%=p;
	}
	return ans;
}
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<n;i++){
        int x,y;
        cin>>x>>y;
        x++,y++;
        ve[x].push_back(y);
        ve[y].push_back(x);
    }
    dp[1]=1;
    dfs(1,0);
    int ans=0;
    for(int i=1;i<=n;i++)
        ans+=t[dp[i]],t[dp[i]]++;
    for(int i=1;i<=n;i++)
        ans+=t[dp[i]+1]-ve[i].size()+(i!=1);
    cout<<qpow(2,ans,1000000007);
    return 0;
}
```

---


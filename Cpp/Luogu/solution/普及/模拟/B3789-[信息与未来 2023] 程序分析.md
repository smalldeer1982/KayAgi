# [信息与未来 2023] 程序分析

## 题目描述

程序分析技术是一种用于理解和改进计算机程序的方法。它可以帮助我们找出程序中的错误、提高程序的性能、优化代码结构等。其中，静态分析技术在不运行程序的情况下对程序代码进行分析。它可以检查代码的语法、风格、潜在错误等。例如，静态分析可以帮助我们找出程序中未使用的变量、可能的数组越界等问题。

小小设计了一个自己的编程语言，并命名为 X 语言。你能为它设计一个静态分析器吗？

X 语言程序中只有两个整型变量 $x$ 和 $y$，且无需定义，可以直接使用。变量 $x$ 的值从程序外输入（输入值可以是任何 C++ int 范围内的值），$y$ 的初始值是 $0$。一个 X 语言程序由若干行组成，每行恰好包含一条命令，是以下三种命令之一：
1. 条件分支：`if (条件) {`；
2. 对 $y$ 赋值：`y = 数字;`；
3. 条件结束：`}`。

其中，“条件”要么是 `x > 数字`，要么是 `x < 数字`。赋值语句和条件中的“数字”都是 $1$ 到 $10^9$ 之间的常数。`if` 和赋值的含义同 C++ 语言中的条件和赋值语句。

请你编写一个静态分析器，分析一个 X 语言程序执行结束时，所有可能的 $y$ 的值。

## 说明/提示

对于 $100\%$ 的数据，满足 $1\le n \le 10^3$。输入数据的每行都不超过 $10^3$ 个字符。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
10
if (x > 1) {
  y = 2;
  if (x > 10) {
    y = 1;
    y = 4;
    if (x < 5) {
      y = 3;
    }
  }
}```

### 输出

```
0 2 4```

## 样例 #2

### 输入

```
(见 p4.zip 中的 2-in.txt)```

### 输出

```
(见 p4.zip 中的 2-out.txt)```

## 样例 #3

### 输入

```
(见 p4.zip 中的 3-in.txt)```

### 输出

```
(见 p4.zip 中的 3-out.txt)```

# 题解

## 作者：Greenzhe (赞：9)

简述题意：

给你一段仅由 if 和赋值语句组成的程序，输入变量 $x$，输出变量 $y$。

问：对于任意输入的在 int 范围内的 $x$，有多少种可能的输出 $y$ 值？

---

先考虑，对于一个**给定**的 $x$，如何求出 $y$ 的值？

这相对简单，直接模拟：

扫描整个程序，

1. 如果该行是 if 语句，判断 $x$ 是否满足括号内条件。不满足则跳过代码块。

2. 如果该行是赋值语句，直接将 $y$ 赋值即可。

最后得到 $y$ 值。

功能包装成函数 `simulate(x)`：

```cpp
struct sentence{ // 每一行
	bool type; // if 语句为 1，赋值语句为 0
	char op; // x>val 还是 x<val
	int val; // 判断的值
	int ed; // 与之匹配的右括号所在的行数
}se[1005];
int simulate(int x){
	int y=0;
	for(int i=1;i<=n;++i){
		if(se[i].type){ // 判断语句
			if(se[i].op=='>')
				if(x<=se[i].val) i=se[i].ed; // 不满足要求就跳
			if(se[i].op=='<')
				if(x>=se[i].val) i=se[i].ed; // 不满足要求就跳
		}
		else y=se[i].val; // 赋值语句
	}
	return y;
}
```

---

那么我们现在就有了一种初步做法，对于所有 `int` 范围内的 $x$ 进行枚举，分别求出 $y$ 的值，扔到 `std::set` 里求出答案。

然而这样做复杂度是 $10^9$ 级别的。

这个做法可以被显著优化。

由于所有赋值语句都可能对应一个 $y$ 值，合理猜测，所有 if 语句都对应一个 $x$ 值。

当语句是 `x<val` 时，对应的值是 `val-1`；当语句是 `x>val` 时，对应的值是 `val+1`。

- 从贪心的角度理解：$(\text{val} \pm 1)$ 最靠近条件的值，且满足条件，必然能通过更多的 if 语句；如果 $(\text{val} \pm 1)$ 也无法通过另外一个 if 语句，那么这两个语句必然无法同时通过。

- 从几何的角度理解：把每个不等式看做数轴上一条射线，那么覆盖 $(\text{val} \pm 1)$ 位于的点的射线一定有最多条。

于是处理出每个可能的 $x$ 值，逐个模拟一遍即可。

这道题的标算就讲到这里。以下是代码的剩余部分。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
vector<int> listx; // 可能的 x 值表
stack<int> ifs; // 括号匹配栈
set<int> answer; // 最后的 y 值表
char program[1005][1005]; // 存输入的程序源代码

int main(){
	// 输入与处理部分
	scanf("%d\n",&n);
	for(int i=1;i<=n;++i){
		gets(program[i]); // 这里写的不太优美，读者可以自行换
		int len=strlen(program[i]);
		se[i].type=false;
		int s=0;
		se[i].op='?';
		for(int j=0;j<len;++j){
			if(program[i][j]=='<') se[i].op='<'; // x<val?
			if(program[i][j]=='>') se[i].op='>'; // x>val?
			if(program[i][j]=='}'){ // 右括号
				se[i].type=true;
				int st=ifs.top();
				ifs.pop();
				se[st].ed=i;
				break;
			}
			if(j>0&&program[i][j-1]=='i'&&program[i][j]=='f'){ // 判断语句（左括号）
				se[i].type=true;
				ifs.push(i);
			}
			if(isdigit(program[i][j])){ // 累加数字
				s=s*10+program[i][j]-48;
			}
		}
		se[i].val=s;
		if(se[i].type){
			if(se[i].op=='<') listx.push_back(s-1);
			// x<val, x=val-1
			else listx.push_back(s+1);
			// x>val, x=val+1
		}
	}
    // 模拟 x 值
	for(int i=0;i<listx.size();++i)
		answer.insert(simulate(listx[i]));
    // 输出
	set<int>::iterator it;
	for(it=answer.begin();it!=answer.end();++it)
		printf("%d ",*it);
	printf("\n");
	return 0;
}

```

---

## 作者：andyli (赞：5)

用一个结构体表示程序，先将输入内容递归地转化为这样的数据，再逐个让 $x$ 为每个条件语句中的“数字”加减 $1$，去模拟程序执行过程得到 $y$ 的值，最后去重。 

构造时，我们循环读取行，若遇到条件语句则递归构造子句，遇到右大括号则退出循环。

```cpp
struct Statement: std::vector<Statement> {
    // y != -1 表示一个赋值语句，IF != 0 表示一个条件语句，此时 vector 中存放分支语句。
    // IF > 0 表示 >，IF < 0 表示 <
    int y = -1, IF = 0;
};
int main() {
    std::string s;
    io.readline(s);
    vi a{0};
    auto construct = [&](auto&& construct) -> Statement {
        Statement r;
        loop {
            std::string s;
            if (!io.readline(s))
                break;
            if (s.find("if") != s.npos) {
                Statement t;
                if (s.find('>') != s.npos) {
                    int x = std::stoi(s.substr(s.find('>') + 2));
                    t.IF = x;
                    a.push_back(x + 1);
                    a.push_back(x - 1);
                }
                else {
                    int x = std::stoi(s.substr(s.find('<') + 2));
                    t.IF = -x;
                    a.push_back(x + 1);
                    a.push_back(x - 1);
                }
                t.push_back(construct(construct));
                r.push_back(t);
            }
            else if (s.find('}') != s.npos) {
                break;
            }
            else {
                Statement t;
                t.y = std::stoi(s.substr(s.find('=') + 2));
                r.push_back(t);
            }
        }
        return r;
    };
    auto statements = construct(construct);
    vi Y;
    foreach (a, a) {
        int y = 0;
        auto&& dfs = [&](auto&& dfs, const Statement& s) -> void {
            if (s.IF) {
                if (s.IF > 0 && a > s.IF) {
                    dfs(dfs, s.front());
                }
                if (s.IF < 0 && a < -s.IF) {
                    dfs(dfs, s.front());
                }
                return;
            }
            if (s.y != -1) {
                y = s.y;
                return;
            }
            foreach (s, s)
                dfs(dfs, s);
        };
        dfs(dfs, statements);
        Y.push_back(y);
    }
    UNIQUE(Y);
    writeln(Y);
    return 0;
}
```

---


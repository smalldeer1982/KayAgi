# [NICA #2] 回来吧我的小波

## 题目背景

小波我错了，你快回来吧！

## 题目描述

给定一个仅包含数字 $1,2,3,4,5,6,7,8,9$ 的数字串 $s$，你要选择两个不交区间 $[l_1,r_1],[l_2,r_2](1\le l_1\le r_1<l_2\le r_2\le |s|)$，设 $[l_1,r_1]$ 区间串取出来的数字为 $x$，$[l_2,r_2]$ 区间串取出来的数字为 $y$，要求 $x|y$。如果存在这样两个不交区间，那么我们称数字串 $s$ 是好的。（这里的 $|$ 表示整除，你可以理解为 $x$ 为 $y$ 的一个因数）

现在给定一个仅包含数字 $1,2,3,4,5,6,7,8,9$ 的数字串 $S$，询问它有多少个子串是好的。（这里的子串**不要求**是本质不同的）

## 说明/提示

#### 样例1解释

只有一个好串 `327`，你可以选择两个不交区间 $[1,1],[2,3]$，取出来的数字分别是 $3$ 和 $27$，显然 $3$ 是 $27$ 的一个因数，所以这个串是好串。

其他子串 `3`，`2`，`7`，`32`，`27` 都不是好的，因为不存在这样的两个不交区间。

#### 样例2解释

共有 $12$ 个好串，分别为 `114514`、`11451`、`1145`、`114`、`11`、`14514`、`1451`、`145`、`14`、`4514`、`514`、`14`。（注意到里面有两个 `14`，但是由于它们位置不同，我们还是认为这是两个不同的子串）

#### 数据范围

对于所有数据，保证 $2\le |S|\le 10^6$。

## 样例 #1

### 输入

```
327```

### 输出

```
1```

## 样例 #2

### 输入

```
114514```

### 输出

```
12```

# 题解

## 作者：MTFlowCzq (赞：5)

本题第一篇题解，本人第二篇题解。

（~~考场上脑子一片空白，卡在暴力做不出来了，赛后才想到正解，就差这一题啊……~~）

# 题目大意

[题目传送门](https://www.luogu.com.cn/problem/B3832)

对于一个不含 $0$ 的数字串，如果能选出两个不交区间 $[l_1,r_1],[l_2,r_2](1\le l_1\le r_1<l_2\le r_2\le |S|)$，满足若设这两个区间取出来的数分别为 $x$ 和 $y$，则 $x\mid y$，那么称这个子串是“好的”。

现给定一个不含 $0$ 的数字串，求有多少个（位置）不同的（连续）子串是“好的”。

# 解题思路

容易想到一个暴力的方法：枚举所有的子串，对于每个子串，枚举 $l_1,r_1,l_2,r_2$ 并判断是否整除。

可惜这样的算法效率**过于低下**，时间复杂度大概是 $O(|S|^7)$，而 $|S|\le10^6$，难以通过本题。（还不包括大数除法的效率问题……）

经过仔细的思考，我们会发现一些性质：

* 一个子串如果是好的，则包含它的串也是好的；
* 一个串如果有相同的数字，那么它是好的（$x\mid x$）；
* 一个串如果含有 $1$，则大概率是好的（$1\mid x$，除非这个 $1$ 在最后）；
* 一个串如果比较长，则大概率是好的……

且慢！这里的“比较长”是多长？换句话说，是不是足够长的串一定是好的？这个“足够长”是多长？

然后我们会发现，由于串中只有 $1,2,3,4,5,6,7,8,9$，根据抽屉原理，**如果串长 $\ge10$，那么一定会出现相同的数字，这个串就一定是好的！**

于是，我们只需要用上述暴力做法，数一数串长 $\le9$ 的好的串有几个，**而串长 $\ge10$ 的串的数量，可以用数学方法算出，加在一起就是答案了！**

时间复杂度大概是 $O(|S|\times g^6)$，其中 $g=9$，可以通过本题！

（这过的也比较玄学，但是半秒过掉了，应该是因为常数小，跑不满……？还是我复杂度式子推错了？）

# 代码

细节见代码和注释，还有就是开 `long long`。

```cpp
#include<iostream>
#include<string>
using namespace std;
string s;
long long ans,n,cnt; //记得开 long long
int val(int pos,int x,int y) { // 从 pos+x 到 pos+y 组成的数值
	int ans=0;
	for (int i=x;i<=y;i++)
		ans=ans*10+s[pos+i]-'0';
	return ans;
}
bool judge(int pos,int len) { // 判定 pos 开始长为 len 是否为好的
	for (int i=0;i<len;i++) // 暴力枚举
		for (int j=i;j<len;j++)
			for (int k=j+1;k<len;k++)
				for (int l=k;l<len;l++) {
					int a=val(pos,i,j);
					int b=val(pos,k,l);
					if (b%a==0)
						return true;
				}
	return false;
}
int main() {
	cin>>s;
	n=s.size();
	for (int d=2;d<=9;d++) // 只看长度不超过 9 的串
		for (int i=0;i<=n-d;i++)
			if (judge(i,d))
				cnt++;
	ans=n*(n+1)/2;
	for (int d=1;d<=9 && d<=n;d++)
		ans-=n-d+1; // 计算长度超过 9 的子串数
	ans+=cnt;
	cout<<ans<<endl;
	return 0;
}
```

---

本人第二篇题解，如有问题和建议欢迎指出！

---

## 作者：Zheng_iii (赞：1)

## 思路
经典抽屉原理。

对于长度大于 $9$ 的子串，我们就可以认为它一定是好的，因为一定有两个数是相同的，它们可以互相整除。

对于剩下长度小于等于 $9$ 的子串，我们对它们进行暴力枚举即可。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
string s;
ll ans;

int val(int l,int r){
	int res=0;
	for(int i=l;i<=r;i++)res = res * 10 + (s[i]-'0');
	return res;
}

bool query(int l,int r){
	for(int l1=l;l1<r;l1++){
		for(int r1=l1;r1<r;r1++){
			for(int l2=r1+1;l2<=r;l2++){
				for(int r2=l2;r2<=r;r2++){
					if(!(val(l2,r2)%val(l1,r1)))return true;
				}
			}
		}
	}
	return false;
}

int main(){
	// freopen("text.in","r",stdin);
	// freopen("text.out","w",stdout);
	ios::sync_with_stdio(0),cout.tie(0),cin.tie(0);
	cin>>s;
	int n=s.size();
	for(int i=0;i<=n;i++){
		ans+=max(n-9-i,0);//先把长度大于9的加进去
		int l = min(i+8,n-1);
		for(int j=i+1;j<=l;j++){
			ans+=query(i,j);
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：chengjindong (赞：1)

[题目](https://www.luogu.com.cn/problem/B3832)

这题可以分类讨论。

- 长度大于等于 $10$，就可以利用抽屉原理，因为一定会有至少两个数是相同的，所以这两个数一定可以互相整除，这个串一定是好的。
- 否则，直接暴力枚举，不会超时的。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
string s;
bool check(int x,int y){
    //四重循环即可
	for(int i=x;i<=y;i++){
		for(int j=i;j<=y;j++){
			for(int k=j+1;k<=y;k++){
				for(int l=k;l<=y;l++){
                    int t1=atoi(s.substr(k-1,l-k+1).c_str());//k~l的数字形式
                    int t2=atoi(s.substr(i-1,j-i+1).c_str());//i~j的数字形式
					if(t1%t2==0){//判断是否满足条件
                        return 1;
                    }
                }
            }
        }
    }
	return 0;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
	cin >>s;
	int ans=0;
	for(int i=0;i<s.size();i++){//循环每一位
		bool f=0;
		int t=s.size()-i;
		for(int j=1;j<min(9ll,t);j++){
			if(check(i+1,i+j+1)){//检查
				f=1;//标记
				ans+=t-j;//答案增加
				break;//退出循环
			}
		}
		if(f==0&&t>9){//判断是否加
            ans+=t-9;//答案增加
        }
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：__zyq_666_kpzc__ (赞：1)

### 解题思路
这是一道思维题，我们分情况讨论：
- 长度大于等于 $10$ 的串，根据抽屉原理，肯定会有至少两个数是相同的，那么此时这两个数定能互相整除，这个串定为好的。
- 长度小于等于 $9$ 的串，没规律可找，暴力枚举即可，暴力枚举的时间也符合要求。

---

## 作者：Breath_of_the_Wild (赞：1)

注意到如果这个子串有两个相同的数字，就是符合要求的串。根据鸽巢原理，可以知道如果取出来的子串元素个数 $\ge10$ 个，就一定是符合要求的串。

因此只需枚举数字个数 $<10$ 即可。

时间复杂度 $O(|S|)$，（实际上还要乘上 $10^6$）能够通过本题。

---

## 作者：菲斯斯夫斯基 (赞：1)

## B3832 [NICA #2] 回来吧我的小波 题解

很好的一道思维题。

**思路**

很容易想到，如果一个子串里有两个相同的数字，那么这个子串应该就是好的。

因为有[鸽巢原理（也称抽屉原理）](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776?fromtitle=%E9%B8%BD%E5%B7%A2%E5%8E%9F%E7%90%86&fromid=731656&fr=aladdin)，然后给出的串里只有 $9$ 个数字，所以只要长度 $\ge10$ 的子串就一定会至少有 $2$ 个数字是一样的。即长度 $\ge10$ 的子串都是好串。

剩下的就很简单了，对于长度 $\le9$ 的串暴力枚举是否合法即可。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
long long ans;
int num(int l,int r)
{
	int k=0;
	for(int i=l;i<=r;i++)
		k=k*10+(s[i]-'0');
	return k;
}//一段字符串代表的数
bool ask(int l,int r)
{
	int sum=0;
	for(int l1=l;l1<r;l1++)
	for(int r1=l1;r1<r;r1++)
	for(int l2=r1+1;l2<=r;l2++)
	for(int r2=l2;r2<=r;r2++)//暴力枚举l1,r1,l2,r2
		if(num(l2,r2)%num(l1,r1)==0)return true;
	return false;
}
int main()
{
	cin>>s;
	int n=s.size();
	for(int i=0;i<n;i++)
	{
		ans+=max(n-9-i,0);//以i为起点长度大于等于10的子串个数
		for(int j=i+1;j<=min(i+8,n-1);j++)
			ans+=ask(i,j);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：lzdqwq (赞：1)

考虑暴力解法，枚举所有可能，时间复杂度 $O(|S|^7)$ ，显然不足以通过本题。

考虑数学解法，利用抽屉原理，得出枚举 $10$ 以内的字串即可，时间复杂度 $O(|S|)$。

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3832)

## 思路：

首先很显而易见的一个结论（抽屉原理）：当这个子串长度大于 $9$  时，一定会有两个相同的数字出现，所以这个子串一定是好子串。

那么 $|S|>9$ 时，就有 $((1+|S|-9)\times(|S|-9))\div2=\frac{(|S|-8)\times(|S|-9 )}{2}$ 个子串一定是好的。

那么长度小于 $10$ 的好子串通过暴力枚举即可得到。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
char x[1000005];
long long js(long long l,long long r){
	long long s=0;
	for(long long i=l;i<=r;i++){
		s=s*10+int(x[i])-48;
	}
	return s;
}
bool f(long long q,long long p){//暴力枚举函数
	long long ff=0;
	for(long long i=0;i<q;i++){
		for(long long j=i;j<q;j++){
			for(long long k=j+1;k<q;k++){
				for(long long l=k;l<q;l++){
					if(js(p+k,p+l)%js(p+i,p+j)==0){
						ff=1;
						break;
					}
					
				}
				if(ff==1) break;
			}
			if(ff==1) break;
		}
		if(ff==1) break;
	}
	return ff;
}
int main(){
	cin>>x;
	long long s=strlen(x),da=0;
	for(long long i=2;i<=9;i++){
		for(long long j=0;j<=s-i;j++){
			if(f(i,j)==true) da++;
		}
	}//暴力枚举长度小于10的好子串
	long long sss;//一定是好子串
	if(s>9){
		sss=((1+s-9)*(s-9))/2;
	}
	cout<<da+sss;
	return 0;
}

```

---

## 作者：JOE_ZengYuQiao_0928 (赞：0)

### 思路
本题非常简单，对于长度大于 $10$ 的子串，一定是好的，因为根据鸽巢原理，大于 $10$ 的子串一定有两个数字相同。

其余的子串懒的找规律了，暴力即可。

---

## 作者：DFM_O (赞：0)

## [B3832 题目](https://www.luogu.com.cn/problem/B3832)

### 解题思路
不难发现，若一个子串有任意两个数是相同的，那么这个子串就一定是好的，根据抽屉原理，若子串长度 $\ge10$，则必有两个数是相同的，也就是说这个子串一定是好的。

我们可以先算出大于长度大于 $10$ 的子串个数，长度为 $10$ 的子串有 $\max(|S|-9,0)$ 个，长度为 $11$ 的有 $\max(|S|-10,0)$ 个，长度为 $12$ 的有 $\max(|S|-11,0)$ 个，以此类推，用求和公式就能算出长度大于 $10$ 的子串有 $\max((|S|-8)\times(|S|-9),0)$ 个。

对于剩下的长度小于 $10$ 的子串，直接暴力判断是否为好的即可。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
bool pd(int len,int st)
{
	for(int i=0;i<len;i++)
	{
		for(int j=i;j<len;j++)
		{
			for(int k=j+1;k<len;k++)
			{
				for(int l=k;l<len;l++)
				{
					int s1=0,s2=0;
					for(int I=st+i;I<=st+j;I++)
						s1=s1*10+(s[I]-'0');
					for(int I=st+k;I<=st+l;I++)
						s2=s2*10+(s[I]-'0');						
					if(s2%s1==0)
						return true;
				}
			}
		}
	}
	return false;
}
signed main()
{
	cin>>s;
	long long len=s.size();
	long long ss=(len-8)*(len-9)/2;
	if(len-8<=0||len-9<=0)
		ss=0;
	for(int i=2;i<=9;i++)
	{
		for(int j=0;j<=len-i;j++)
		{
			if(pd(i,j))
				ss++;
		}
	}
	cout<<ss;
	return 0;
}
```

---

## 作者：无名之雾 (赞：0)

# [NICA #2] 回来吧我的小波 题解

~~又是抢到最优解的一天！~~

## 思路

看到这题的第一眼，直接无脑暴力，枚举 $l_1$，$r_1$，$l_2$，$r_2$。
时间复杂度 $O(|S|^7)$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll cut(string str, ll l, ll r) {
	ll ret = 0;
	for (int i = l; i <= r; i++) {
		ret = ret * 10 + (str[i] - '0');
	}
	return ret;
}
bool Judge(string str) {
	ll re1, re2;
	ll str_len = str.length();
	if (str.length() > 9) return true;
	for (int l1 = 0; l1 < str_len - 1; l1++)
		for (int r1 = l1; r1 < str_len - 1; r1++)
			for (int l2 = r1 + 1; l2 < str_len; l2++)
				for (int r2 = l2; r2 < str_len; r2++) {
					re1 = cut(str, l1, r1);
					re2 = cut(str, l2, r2);
					if (re2 % re1 == 0) {
						//	cout << str << endl;
						return true;
					}
				}
	return false;
}
int main() {
	string st;
	ll cnt = 0;
	ll len;
	cin >> st;
	len = st.length();
	for (int i = 0; i < len; i++) {
		for (int j = i + 1; j < len; j++) {
			if (j <= i + 9) {
				ll cutnum = cut(st, i, j);
				string zichuan = to_string(cutnum);
				if (Judge(zichuan) == true) {
					cnt++;
				}
			} else {
				cnt++;
			};
		}
	}
	cout << cnt;
	return 0;
}
```
而后我们进一步思考，是不是该用数学的思想去结局这题。随后我看到了这一条件：
>输入仅一行一个仅包含 $1$，$2$，$3$，$4$，$5$，$6$，$7$，$8$，$9$ 的数字串 $S$。

这不禁让我想到了学小奥时的定理[“抽屉原理”](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776)，因为只能有 $10$ 以内的数组成，所以如果长度超出 $10$ 的子串就一定是好串。

下面就只需要暴力枚举 $10$ 以内的字串了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1000001];
inline long long V(const int &i,const int &j) {
	int64_t r(0);
	for(int p=i;p<=j;p++)r=r*10+s[p - 1]-'0';
	return r;
}
inline bool Check(const int &i, const int &j){
	for(register int i1 =i;i1<=j;i1++)
		for(register int j1=i1;j1<=j;j1++)
			for(register int i2=j1+1;i2<=j;i2++)
				for(register int j2=i2;j2<=j;j2++)
					if(V(i2,j2)%V(i1,j1)==0)return true;
	return false;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>s;
	int n=strlen(s);
	long long r=0;
	for (register int i=1;i<=n;i++) {
		int lmax=n-i+1;
		bool f=false;
		for (register int l=2;l<=min(9,lmax);l++) {
			if(Check(i,i+l-1)){
				f=true;
				r+=(lmax-l+1);
				break;
			}
		}
		if(!f&&lmax>9)r+=lmax-9;
	}
	cout<<r;
	return 0;
}
```

---

## 作者：wei2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B3832)

## 思路：
首先当然是先考虑暴力啦，暴力枚举所有的子串、所有可能，时间复杂度 $\mathcal{O(\left | S \right | ^7)}$，明显过不了。

思考优化：

很好发现这个子串若有两个相同的数字就是好串，再根据小学奥数鸽巢原理，我们可发现若是此时提取出的子串元素个数大于等于 $10$ 个，便一定是个好串，这样下来就只用暴力枚举小于 $10$ 个元素的子串就可以判断了，时间复杂度大大减少，时间复杂度 $\mathcal{O(\left | S \right |)}$。
## [code](https://www.luogu.com.cn/record/154230883)

---


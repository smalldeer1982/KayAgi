# [信息与未来 2024] 数据排序

## 题目描述

在计算机世界中，“表格”是一种简单、基础而且十分通用的数据结构，在数据库、人工智能等领域中都有广泛的应用。表格由若干行、若干列的单元格组成：

| Name     | p1   | p2   | p3   | Score |
| :------- | :--- | ---- | ---- | ----- |
| ZhangSan | 40   | 30   | 28   | 98    |
| LiSi     | 40   | 28   | 30   | 98    |
| WangWu   | 40   | 25   | 20   | 85    |

CSV (Comma-Separated Values) 是一种常用的表格格式。Dr. X 需要你编程处理简化的 CSV 文
件，格式规定如下：

- CSV 文件包含 $n$ 行数据，其中第一行是标题行。
- CSV 文件每行一个字符串，对应了表格的一行。行中的单元格由**半角逗号**分隔。
- 每个单元格至少包含一个字符。单元格有两种类型：
  - **数值单元格**：由至少一个数字字符 $(0\sim 9)$ 组成。
  - **字符串单元格**：由数字字符 $(0\sim 9)$ 和大小写字母 $(\tt{a\sim z},\tt{A\sim Z})$ 组成,且至少包含一个字母。

- 标题行的所有单元格都是字符串单元格，且互不相同。标题行中包含了列的名称。

以下是一个 CSV 文件的示例：

```
Name,p1,p2,p3,Score
ZhangSan,40,30,28,98
LiSi,40,28,30,98
WangWu,40,25,20,85
```

你的任务是**根据指定的列为表格中的行排序**。例如根据 `Score- , Name+ , p3-` 排序意味着：

- 优先按 Score 列从大到小排序。Score 列都是数值单元格，因此按数值排序。

- 如果 Score 列相同，按 Name 列从小到大排序。Name 列都是字符串单元格，因此按照字典排序。

- 如果 Score 和 Name 列都相同，按 p3 列从大到小排序。p3 列都是数值单元格，因此按数
  值排序。

我们保证 CSV 文件每一行的单元格数量相同，且除标题行外，**每一列要么全是数值单元格，要么全是字符串单元格**。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \leq n \leq 100$，表格不超过 $10$ 列，字符串单元格不超过 $16$ 个字符，且数值单元格中的数值是 $0$ 到 $10^4$ 之间的整数。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
4
Name,p1,p2,p3,Score
ZhangSan,40,30,28,98
LiSi,40,28,30,98
WangWu,40,25,20,85
3
Score-
Name+
p3-```

### 输出

```
Name,p1,p2,p3,Score
LiSi,40,28,30,98
ZhangSan,40,30,28,98
WangWu,40,25,20,85```

# 题解

## 作者：FFTotoro (赞：6)

整点烂活。

因为我们不知道表格的每一列是整数还是字符串，所以我们可以用 `std::variant<int,std::string>`（需要 C++17，作用为存储一个整数**或**字符串）来存储表格中的元素。

把所有条件都存储在一个 `std::vector` 里面。因为如果条件都一样要保持原来的顺序，所以使用 `std::stable_sort` 进行排序，`cmp` 函数里当所有条件都一样时就返回 `false` 即可。 

放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline vector<variant<int,string> > f(string s){
  vector<variant<int,string> > a;
  for(int i=0,j;i<s.length();i=j+1){
    string t;
    for(j=i;j<s.length()&&s[j]!=',';j++)t+=s[j];
    bool D=true; // 是否全是数字
    for(char i:t)D&=isdigit(i);
    if(D)a.emplace_back(stoi(t));
    else a.emplace_back(t);
  }
  return a;
} // 对输入的字符串进行解析
int main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  int n; string h; cin>>n>>h;
  auto H=f(h);
  vector<string> t(n-1);
  for(auto &i:t)cin>>i;
  vector<vector<variant<int,string> > > T(n-1);
  for(int i=0;i<n-1;i++)T[i]=f(t[i]);
  vector<pair<int,int> > C;
  int m; cin>>m;
  for(int i=0;i<m;i++){
    string s; cin>>s;
    for(int j=0;j<H.size();j++)
      if(s.substr(0,s.length()-1)==get<string>(H[j])){
        C.emplace_back(j,s.back()=='+'); break;
      } // 判断是什么类型的条件
  }
  stable_sort(T.begin(),T.end(),[&](auto x,auto y){
    for(auto [a,s]:C)
      if(x[a]!=y[a])return s?x[a]<y[a]:x[a]>y[a];
    return false;
  }); // 进行排序
  cout<<h<<endl;
  for(auto x:T)
    for(int j=0;j<x.size();j++){
      if(get_if<int>(&x[j]))x[j]=to_string(get<int>(x[j]));
      cout<<get<string>(x[j])<<",\n"[j==x.size()-1];
    }
  return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：5)

码量一般的模拟。

把表头和学生信息以 `,` 为分隔符拎出来，存起来。由于（据我所知）不同类型数组不能开在一起，所以信息存的是 $3$ 个内容，分别表示为数还是字符串，以及数字的值和字符串的值。

排序部分，把排序方式先离线下来。比较两个元素时，按顺序遍历排序方式，判断升序降序，为数还是字符串，然后进行比较。

由于给定排序方法相同需要按照原顺序，所以多加一个 $id$ 用来判断全部一样时的先后顺序。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, c;
string s, t;
int cnt;
string cmp[20];
string tt;
map<string, int> title;
struct node
{
    bool op; // int 0 str 1
    int x;
    string y;
};
vector<node> a[120];
bool isstr(string s)
{
    int cnt = 0;
    for (char c : s)
        if (isdigit(c))
            cnt++;
    return cnt < s.size();
}
bool ccmp(vector<node> a, vector<node> b)
{
    for (int i = 1; i <= c; i++)
    {
        int op = cmp[i].back();
        string t = cmp[i].substr(0, cmp[i].size() - 1);
        int j = title[t];
        if (op == '+')
        {
            if (!a[j].op)
            {
                if (a[j].x == b[j].x)
                    continue;
                return a[j].x < b[j].x;
            }
            else
            {
                if (a[j].y == b[j].y)
                    continue;
                return a[j].y < b[j].y;
            }
        }
        else
        {
            if (!a[j].op)
            {
                if (a[j].x == b[j].x)
                    continue;
                return a[j].x > b[j].x;
            }
            else
            {
                if (a[j].y == b[j].y)
                    continue;
                return a[j].y > b[j].y;
            }
        }
    }
    return a[0].x < b[0].x;
}
int main()
{
    cin >> n >> s;
    tt = s;
    s += ',';
    for (int i = 0; i < s.size(); i++)
    {
        if (s[i] == ',')
        {
            title[t] = ++m;
            t = "";
            continue;
        }
        t += s[i];
    }
    for (int i = 1; i < n; i++)
    {
        a[i].resize(m + 20);
        cin >> s;
        s += ',';
        t = "";
        a[i][0].x = i;
        int cnt = 0;
        for (int j = 0; j < s.size(); j++)
        {
            if (s[j] == ',')
            {
                cnt++;
                a[i][cnt].op = isstr(t);
                if (!a[i][cnt].op)
                    a[i][cnt].x = stoi(t);
                else
                    a[i][cnt].y = t;
                t = "";
                continue;
            }
            t += s[j];
        }
    }
    cin >> c;
    for (int i = 1; i <= c; i++)
        cin >> cmp[i];
    sort(a + 1, a + n, ccmp);
    cout << tt << '\n';
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (!a[i][j].op)
                cout << a[i][j].x;
            else
                cout << a[i][j].y;
            putchar(j == m ? '\n' : ',');
        }
    }
    return 0;
}
```

---

## 作者：_WHX985_ (赞：3)

## 主题思路
估算一下模拟的时间复杂度为 $O(n\log{n}\times m)$ 代如题目中的数据范围不会超时，所以考虑模拟。现在的问题是题目中的输入让人很苦恼，一大串输入一个空格都没有。其实解决这个问题很简单，因为每个信息都由逗号隔开，所以我们可以一找到逗号就提取信息，如下代码所示。
```cpp
for(int i=1;i<n;i++){
  cin>>s;
  s+=",";
  string num="";
  for(int j=0;j<=s.size()-1;j++){
    if(s[j]==','){
      bs[++v]=num;
      num="";
    }else{
      num+=s[j];
    }
  }
}
```
同理，我们可以把条件也按此法剥离出来，这样我们就得到了所有数据，现在就可以排序了，用 sort 需要手写 cmp 下面是带注释的 cmp 排序代码。

```cpp
bool cmp(int i,int j){
	for(int k=1;k<=m;k++){//一个一个列举输入的条件
		if(x[i][b[k]]!=x[j][b[k]]){//当两数需要排序
			if(op[k]=='+'){//按升序排序
				if(!f[b[k]]){
					if(x[i][b[k]].size()!=x[j][b[k]].size()) return x[i][b[k]].size()<x[j][b[k]].size();//要排序的数长度不相等就可以直接让长度小的数排前面
					else return x[i][b[k]]<x[j][b[k]]; //否则字典序小的排前面
				}
				else return x[i][b[k]]<x[j][b[k]]; 
			}
			else{//降序排列（和升序同样的原理）
				if(!f[b[k]]){
					if(x[i][b[k]].size()!=x[j][b[k]].size()) return x[i][b[k]].size()>x[j][b[k]].size();
					else return x[i][b[k]]>x[j][b[k]]; 
				}
				else return x[i][b[k]]>x[j][b[k]]; 
			}
		}
	}
	return i<j;//都不满足字典序小的排前面
}
```
写好 sort 中的 cmp 后，我们再写一行代码就完成了排序。
```cpp
sort(a+1,a+n,cmp);
```
最后输出就行了。

---

## 作者：Moya_Rao (赞：3)

# 题目大意
给定一个表格和一种排序方式，输出排序后的表格，具体见[原题](https://www.luogu.com.cn/problem/B3982)。
# 思路
先取出每一栏的名称和表格里存储的每一个信息，由于我们不知道表格里存储的信息是数字还是字符串，因此我们开一个结构体来实现。

排序时，我们一层一层看，如果这一层能排出来，就排；否则一样，就看下一层。如果所有信息均相等，就按顺序来排。

具体细节详见代码注释。
# 代码
代码略长请原谅。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,C;
string Cmp[15];
string s,title,T;
map<string, int> GT;//总标题
struct price{
    bool type;//类型，用 0 表示 int，用 1 表示 string
    int Int;string Str;//存这里
};
vector<price> a[105];
bool Is_str(string str){//判断一个字符串是不是一个正常的字符串，是则返回 1，否则返回 0
    int cnt=0;
    for(int i=0;i<str.size();i++)
        if(str[i]>='0'&&str[i]<='9')cnt++;
    return cnt<str.size();
}
int To_int(string str){//作为一个蒟蒻，我只能手写一个让字符串变成整形的函数
    int ans=0;
    for(int i=0;i<str.size();i++)ans=ans*10+(int)(str[i]-'0');
    return ans;
}
bool cmp(vector<price> x,vector<price> y){
    for(int i=1;i<=C;i++){
        char op=Cmp[i].back();//拎出最后一个
        string t=Cmp[i].substr(0,Cmp[i].size()-1);//把除最后一部分的其他部分拿到
        int j=GT[t];//搞出对应标题是第几个
        if(op=='+'){//如果是升序排序
            if(x[j].type==0){//如果是整形
                if(x[j].Int==y[j].Int)continue;//一样的，下次再看
                return x[j].Int<y[j].Int;
            }
            else{//否则是字符串
                if(x[j].Str==y[j].Str)continue;//一样的，下次再看
                return x[j].Str<y[j].Str;
            }
        }
        else{//否则是降序排序
            if (x[j].type==0){
                if(x[j].Int==y[j].Int)continue;//一样的，下次再看
                return x[j].Int>y[j].Int;
            }
            else{
                if(x[j].Str==y[j].Str)continue;//一样的，下次再看
                return x[j].Str>y[j].Str;
            }
        }
    }
    return x[0].Int<y[0].Int;
}
int main(){
    cin>>n>>s;
    T=s;
    s+=',';//加一个分割点，方便后面判断
    for(int i=0;i<s.size();i++){
        if(s[i]==','){//如果这是一个分割点
            GT[title]=++m;//存下编号
            title="";//清空它
            continue;//退出去，不让它加上这个分割点
        }
        title+=s[i];//加上这一个字符
    }
    for(int i=1;i<n;i++){
        for(int o=0;o<20;o++)a[i].push_back({0,0,""});//预留空间
        cin>>s;
        s+=',';//加一个分割点，方便后面判断
        title="";//清空它
        a[i][0].Int=i;
        int cnt=0;
        for(int j=0;j<s.size();j++){
            if(s[j]==','){
                cnt++;
                a[i][cnt].type=Is_str(title);//获取这个信息是数字还是字符串
                if(a[i][cnt].type==0)a[i][cnt].Int=To_int(title);//存下数字
                else a[i][cnt].Str=title;//存下字符串
                title="";//清空它
                continue;
            }
            title+=s[j];//加上这一个字符
        }
    }
    cin>>C;//就是题目描述中的 m
    for(int i=1;i<=C;i++)cin>>Cmp[i];
    sort(a+1,a+n,cmp);
    cout<<T<<"\n";
    for(int i=1;i<n;i++){
        for(int j=1;j<=m;j++){
            if(a[i][j].type==0)cout<<a[i][j].Int;
            else cout<<a[i][j].Str;
            if(j==m)cout<<"\n";
            else cout<<",";
        }
    }
    return 0;
}
```
此代码已 [AC](https://www.luogu.com.cn/record/168780406)，可放心看，但请不要**直接提交**我的代码。  
也希望看到这里来了的读者们给个小小的赞，好吧？

---

## 作者：xiaoshumiao (赞：2)

这道题并不难，考验的是我们的耐心和码力。

接下来我们一步步来分析。

## 1. 读入标题行

我们循环遍历标题行，每次以 `,` 为间隔提取出每一栏的名称，并映射到 `map` 上，以便后面排序时使用。

## 2. 读入每个人的信息

每读入一个人的信息，跟处理标题行的方法一样，以 `,` 为间隔提取数据，并判断其为数还是字符串。

## 3. 排序

排序依据直接读入即可，故不多说。

重点在于 cmp 函数怎么写。我们依次遍历所有排序依据，并提取单元格名称，并在 `map` 中找到对应的下标。如果两个人的这个值不同，则根据 `+` 或 `-` 来排序，否则继续遍历下一个排序依据。

具体实现见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=20; map<string,int>idx; string sor[M]; int k;
struct Person { int a[M],id; string b[M]; bool num[M]; }a[N];
bool cmp(Person a,Person b) {
    //3. 排序
    for(int i=1;i<=k;i++) {
        string t="";
        for(int j=0,l=sor[i].size();j<l-1;j++) t+=sor[i][j];
        if(a.num[idx[t]]) {
            if(a.a[idx[t]]!=b.a[idx[t]]) {
                if(sor[i][sor[i].size()-1]=='+') return a.a[idx[t]]<b.a[idx[t]];
                return a.a[idx[t]]>b.a[idx[t]];
            }
        }
        else {
            if(a.b[idx[t]]!=b.b[idx[t]]) {
                if(sor[i][sor[i].size()-1]=='+') return a.b[idx[t]]<b.b[idx[t]];
                return a.b[idx[t]]>b.b[idx[t]];
            }
        }
    }
    return a.id<b.id;
}
int main() {
    ios::sync_with_stdio(false),cin.tie(nullptr);
    //1. 读入标题行
    int n,m=0; string l; cin>>n>>l;
    for(int i=0,L=l.size();i<L;i++) {
        int j;
        for(j=i;l[j]!=','&&j<L;j++);
        m++; string s;
        for(int k=i;k<j;k++) s+=l[k];
        i=j,idx[s]=m;
        //cout<<i<<'\n';
    }
    //for(int i=1;i<=m;i++) cout<<i<<' '<<l[i]<<'\n';
    //2. 读入每个人的信息
    for(int i=1;i<n;i++) {
        string str; cin>>str,a[i].id=i;
        for(int j=0,l=str.size(),cnt=0;j<l;j++) {
            int k;
            for(k=j;str[k]!=','&&k<l;k++);
            cnt++;
            bool flag=true;
            for(int K=j;K<k;K++) if(!(str[K]>='0'&&str[K]<='9')) { flag=false; break; }
            if(flag) {
                int num=0; a[i].num[cnt]=true;
                for(int K=j;K<k;K++) num=num*10+str[K]-'0';
                a[i].a[cnt]=num; //cout<<num<<'\n';
            }
            else for(int K=j;K<k;K++) a[i].b[cnt]+=str[K];
            j=k; //cout<<j<<'\n';
        }
        //cout<<m<<'\n';
        //for(int j=1;j<=m;j++) cout<<j<<' '<<a[i].a[j]<<' '<<a[i].b[j]<<'\n';
    }
    cin>>k;
    for(int i=1;i<=k;i++) cin>>sor[i];
    sort(a+1,a+n,cmp);
    cout<<l<<'\n';
    for(int i=1;i<n;i++)
        for(int j=1;j<=m;j++) {
            if(a[i].num[j]) cout<<a[i].a[j];
            else cout<<a[i].b[j];
            cout<<(j==m?'\n':',');
        }
    return 0;
}
```

---

## 作者：Ag2WO4 (赞：2)

来讲一种基于 Python 3 的抽象写法，先看 AC 代码：
```python
n=int(input());a=input().split(',');print(','.join(a));b=[input().split(',')for i in range(n-1)];c=[input()for i in range(int(input()))];print(*map(lambda i:','.join(i),sorted(b,key=lambda p:[[int(i)if i.isdecimal()else sum(ord(i[j])<<(8*(16-j))for j in range(len(i)))for i in p][a.index(i[:-1])]*(44-ord(i[-1]))for i in c])),sep='\n')
```
感到疑惑？接下来我逐行讲解。

先看这三行：
```python
n=int(input());a=input().split(',');print(','.join(a))
```
输入行数和标题行，然后把标题行原封不动吐出来。

然后：
```python
b=[input().split(',')for i in range(n-1)];c=[input()for i in range(int(input()))]
```
输入剩下的行，输入排序规则。

接下来就是重头戏，下面的代码我将按意群分行方便讲解：
```python
print(*map(lambda i:','.join(i),
           sorted(b,key=lambda p:
                  [[int(i)if i.isdecimal()else sum(ord(i[j])<<(8*(16-j))for j in range(len(i)))for i in p]
                   [a.index(i[:-1])]*(44-ord(i[-1]))for i in c])),
      sep='\n')
```
第一行和最后一行负责输出格式，做好字符串然后解包；

第二行确定排序的基础参数；

第三行将字符串转为数字方便取负数以实现降序功能；

第四行按排序规则取值，通过正号和负号的 ASCII 编码定正负。

就这样，我们利用 Python 3 的特性完成了这道题。

---

## 作者：GLr137 (赞：1)

[B3982  [信息与未来 2024] 数据排序](https://www.luogu.com.cn/problem/B3982)

简单模拟

**题目概述：**

输入一个 CSV 表格，再输入排序规则数组，根据排序规则顺序优先排序第一项，相同再排序第二项……以此类推，直到结束。

**思路：**

用什么存储 CSV 表格？可以用结构体，因为结构体排序正好可以满足题目中所要求的排序方式，结构体里面再建立一个数组，代表每一行的单元格数组，建立表格便完成了。

其次，怎么排序？这里肯定是用 sort 排序，但问题的关键之处是，怎么区分优先级？如何判断数字还是字符串？一个 cmp 函数完美解决了。

**详细思路（如果不理解前面思路的看这里，否则可以跳过）：**

我们定义一个名为 CSV 的数组来代表表格。

输入 $n$，读入每行用一个字符串 $s$，读到 `,` 就将前面的字符串 $z$ 塞进 $CSV_i.sz_x$ 里，并清空 $z$；如果不是 `,` 就把这个字符 $s_j$ 加入到 $z$ 中，因为我们只知道在第几行，并不知道应该放在第几列，所以这里用了 $x$ 来代表列的下标，每当塞一次字符串就加 $1$ 。并且我们需要在读入后立刻把字符串 $s$ 添加一个 `,`，因为这样才能有效地读入每行最后一列单元格内容。

其次输入 $m$ ，我们可以将排序方式一一塞进另一个数组 sz2 中。

接下来，是程序的核心：排序。
众所周知，cmp 函数是用来比较两个结构体类型数据的，所以我们将排序优先级的代码放在那里。

我们首先写三个函数：

第一个函数用来根据排序方式的字符串返回这个字符串应该是标题行中的哪一列。

第二个函数用于将字符串转换成数字。

第三个函数用于判断这个字符串是不是表示数字。

排序方式是这样的：先按 sz2 的第一项升序或降序排序，相同的话再按照第二项……以此类推。但是，我们需要注意的是，cmp 函数不是用来排序，而是比较！所以，我们在 cmp 函数中应当写一个 for 循环从 $1$ 到 $x$，表示优先级，也是 sz2 中的下标。在循环中第一步判断 $sz2_i$ 这个排序方式最后一项是 `+` 还是 `-`；第二步判断 cmp 中第一个参数所在列的字符串是否等于第二个参数所在列的字符串（要用到第一个函数）。
也就是如果不等于，那就返回哪个大或哪个小。等于就说明这个排序方式所在列的字符串一样，那啥也不干，静静等待下一轮循环；第三步判断第一个参数所在列的字符串是不是数字（要用到第一个函数和第三个函数），如果是则转换成数字与第二个参数转换成数字后比较（要用到第二个函数），不是则直接比较（默认按照字典序排序）。
其实升序和降序判断中所写的内容除了大于小于号其他完全一样（`+`应是小于号，`-`应是大于号）。这时你可能会问：为什么只判断第一个参数是不是数字？因为我们看到题目中的一句话：

我们保证 CSV 文件每一行的单元格数量相同，且除标题行外，**每一列要么全是数值单元格，要么全是字符串单元格。**

这说明第一个参数和第二个参数要么都是数值单元格，要么都是字符串单元格，它们的类型完全一样，只需判断一个便可以了。

下面是一个超级巨坑：
题目没有说不会有是所有排序方式都相同的情况，而 sort 是不稳定性排序，我们必须在 for 循环结束后返回比较两个参数里我们读入时所建立的下标数值，否则不是 WA 就是 RE  ~~（本人亲历）~~。

最后我们输出 CSV 中所有数值（每行最后一列不用输出 `,`）。

**易错点解析：**

输出每行最后一列不用输出 `,`。

sort 里最后要比较下标。

不要忘记判断数值还是字符串。

看好数据范围。

**code：**

```cpp
# include <bits/stdc++.h>
using namespace std;
struct node {
	int xb;  //下标记录 
	string sz[15];   //每一列的内容 
}CSV[105];
int n, x, m, l, L, R;
string sz2[15];
int hs1 (string s){
	for (int j = 1; j <= x; j++){
		if (CSV[1].sz[j] == s){   //寻找标题行的哪一列 
			return j;
		}
	}
}
int hs2 (string s){
	int sum = 0;
	for (int i = 0; i < s.size(); i++){
		sum = sum * 10 + (s[i] - 48);   //字符串转换成数字 
	}
	return sum;
}
bool hs3 (string s){
	for (int i = 0; i < s.size(); i++){
		if (s[i] < '0' || s[i] > '9'){   //有非数字字符便返回 "0" 
			return 0;
		}
	}
	return 1;
}
bool cmp (node a, node b){   //核心函数 
	for (int i = 1; i <= m; i++){
		if (sz2[i][sz2[i].size() - 1] == '+'){    //判断加减号 
			if (a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))] != b.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]){    //判断是否相等 
				if (hs3(a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]) == 1){      //判断数值还是字符串 
					return hs2(a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]) < hs2(b.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]);    //转换数字后比较 
				}else{
					return a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))] < b.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))];    //直接默认字典序比较
				}
			}
			//不相等静静等待下一轮 
		}else{    //此内容与上方除了大于小于号（降序或升序）完全一样 
			if (a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))] != b.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]){
				if (hs3(a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]) == 1){
					return hs2(a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]) > hs2(b.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))]);
				}else{
					return a.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))] > b.sz[hs1(sz2[i].substr(0, sz2[i].size() - 1))];
				}
			}
		} 
	}
	return a.xb < b.xb;   //别忘了最后比较下标 
}
int main (){
	string s, z;
	cin >> n;
	for (int i = 1; i <= n; i++){
		CSV[i].xb = i;
		cin >> s;
		s += ",";
		z = "";
		x = 0;
		for (int j = 0; j < s.size(); j++){
			if (s[j] == ','){
				x++;
				CSV[i].sz[x] = z;
				z = "";
			}else{
				z += s[j];
			}
		}
		CSV[i].sz[0] = "";
	}
	cin >> m;
	for (int i = 1; i <= m; i++){
		cin >> s;
		sz2[i] = s;
	}
	sort(CSV + 2, CSV + n + 1, cmp);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= x; j++){
			cout << CSV[i].sz[j];
			if (j != x){   //注意判断是不是每行最后一列的单元格 
				cout << ",";
			}
		}
		cout << "\n";
	}
	return 0;  //结束 
} 
```
[AC记录](https://www.luogu.com.cn/record/195381870)

代码仅供参考，抄袭必有后报。

希望能给大家带来帮助。

---

## 作者：vivian01 (赞：1)

# B3982 数据排序 题解

一道模拟加排序题。

#### 1. 该题难点。
                   
直接取出之前记录的关键字的编号组成的集合，这个集合的元素和表格的列一一对应，排序时根据这个集合对 vector 进行排序。                                          
先判断排序方式，然后判断字符串中是否全是数字，如果全是数字，先按照位数排序，再直接比较按照数的大小排序，否则，则可以直接比较大小。

#### 2. 该题解新颖之处。

标题行和表的内容可以用 stringstream，以逗号作为分割符，读取输入的内容，可以大大减少代码量。

输入时表的每一列可能是数字或字符串，我们统一用字符串来存储。
#### 3. 一些细节。

输出时注意最后一列数据不应该带上逗号。

如果下标从 1 开始，注意存表时需加一个空字符。

在排序的时，因为 sort 是不稳定的排序，所以可以用 stable_sort 来实现稳定排序。


## 代码


```
#include <bits/stdc++.h>
using namespace std;
string head; //标题行 
string keyWords[20]; //排序依据的列名及排序方式
int cnt; 
map<string, int> title; //表头
vector <string> cont[105]; //表的内容 
int n; //文件的行数 
int m; //排序依据列的数量 

/*
判断 str 中是否都是数字 
*/
bool isNumeric(string str) 
{
   for (int i = 0; i < str.length(); i++)
      if (isdigit(str[i]) == false)
     		return false; 
   return true; 

}
/*
排序 
*/ 
bool cmp(vector<string> x, vector<string> y)
{
    for (int i = 1; i <= m; i++) // m 个排序的准则 
    {
        char op = keyWords[i].back();
		// op = '+'为升序， op = '-'为降序 
        string num = keyWords[i].substr(0, keyWords[i].length() - 1); // num 为排序依据的列名 
		int j = title[num]; // num 对应是第j列 
        if (op == '+') //升序 
        {
        	if (isNumeric(x[j]) ) //整数  
			{
				if (x[j].length() !=  y[j].length()) //如果位数不等 
	        	{
	        		return x[j].length() < y[j].length(); //位短的排在前面 
				}
				else if (x[j] != y[j]) //位数相等 
				{
					return x[j] < y[j];  
				}
			} 
        	else //字符串 
        	{
        		if (x[j] != y[j]) 
				{
					return x[j] < y[j]; //按字典序排序 
				}
			}
		}
		else //降序 
		{
			if (isNumeric(x[j]) ) 
			{
				if (x[j].length() !=  y[j].length()) 
	        	{
	        		return x[j].length() > y[j].length();
				}
				else if (x[j] != y[j])
				{
					return x[j] > y[j]; 
				}
			} 
        	else
        	{
        		if (x[j] != y[j])
				{
					return x[j] > y[j]; 
				}
			}
		}
    }
    return 0;
}

int main()
{
	cin >> n; //文件的行数 
	cin >> head; //输入标题行 
 
	string v; //标题行中的关键字 
	stringstream str; //字符串流 
	str << head; //把字符串输出到字符串流中 
	//将流 str 中以分隔符，隔开的串提取到title中去
	while (getline(str, v, ','))
	{
		title[v] = ++cnt;
	}
	
	for (int i = 1; i < n; i++)
    {
    	string ct;
        cin >> ct;
        cont[i].push_back(" "); //下标从1开始
        
		stringstream str_s; 
		str_s << ct; //把字符串输出到字符串流中 
		//将流 str 中以分隔符，隔开的串提取到title中去
		while (getline(str_s, v, ','))
		{
			cont[i].push_back(v); 
		}
    }

	cin >> m; //排序依据列的数量
    for (int i = 1; i <= m; i++)
    {
    	cin >> keyWords[i]; //排序依据的列名及排序方式
	}

	stable_sort(cont + 1, cont + n, cmp); //排序 
	
	cout << head << endl; //输出标题 
	for (int i = 1; i < n; i++)
    {
    	int len = cont[i].size();
        for (int j = 1; j < len-1; j++)
        {
            cout << cont[i][j] <<",";
        }
        cout << cont[i][len-1]; //注意最后一列没有 ',' 
        cout << endl;
    }
	return 0;
}
```

---

## 作者：huangzhixia (赞：1)

不好评价，只能说是一个**不是**很难的模拟。

---

存的方式就很多吧，比如说把表的第一行单独存，或者说存在一起，每次判的是时候就看第一行。每个人都有自己的喜好吧，个人认为前者更好。

以我的方式第一行单独存，然后下面表的信息存在一个 ```string``` 数组里即可。读题可知，存的信息会有数字会有字符串。虽然说 ```vector``` 的 ```string``` 可以直接 ```sort```，数字也可以直接按照字典序排序也是对的，但还是分开写吧，把数字和字符串分开写。

排序，就是判，判是升序还是降序，是字符还是数字，然后就是直接排。因为题目中有强调需要**保持它们在输入文件中的相对顺序**，所以要记录一下排序前原数组的下标。

-------------

不好说吧，模拟题代码都会写就给个以上的思路。

然后就是感觉这模拟难点和坑点比较少可以说几乎没有，非常适合新手练习码力。

---

## 作者：tangzirui1016 (赞：0)

一道较为复杂的模拟题。    
废话不多说，首先讲一下我的思路。

### 模块一：处理标题行

可以发现小标题是用一个逗号来隔开的，因此我们可以在字符串的后面自行添加一个逗号，这样**每次找到第一个逗号的位置，处理一下，再删掉前面一部分**，标题行就处理好了。

![](https://cdn.luogu.com.cn/upload/image_hosting/zlvxbmhk.png)

```cpp
int cnt=0;
string head[105]; //head 数组用来储存每个标题的名称
s+=','; //s 是输入的标题行
while(s.size()>0){ 
	int pos=s.find(','); 
	head[++cnt]=s.substr(0,pos); 
	s.erase(0,pos+1);
  //每次找到 s 中第一个逗号
  //然后对前面一部分截取，最后删掉逗号及它之前的部分
  //重复这样操作，直至 s 清空
} 
```
### 模块二：处理每一行的信息

跟模块一处理方法类似，采用**逗号分割法**，如果你觉得模块一和模块二分开有点麻烦，你可以用下标 $0$ 来表示标题行。

```cpp
bool f[15]={}; //f[i] 表示第 i 列是否为字符串单元格 
string x[105][15]; //x[i][j] 表示第 i 行第 j 列的单元格 
	for(int i=1;i<n;i++){
		cin>>s;
		s+=',';
		for(int j=1;j<=cnt;j++){
			int pos=s.find(',');
			for(int k=0;k<pos;k++){ //对于第 j 列的单元格进行扫描 
				if((s[k]>='a'&&s[k]<='z')||(s[k]>='A'&&s[k]<='Z')) 
	            f[j]=1;
				//如果出现字母，则肯定是字符串单元格 
			}
			x[i][j]=s.substr(0,pos);
			s.erase(0,pos+1);
		}
	} 
```
### 模块三：处理排序顺序的数据

可以发现，每个排序顺序的组成都是 $标题行+一个符号(+/-)$，我们可以把它们分开，同时记录一下是按第几列排序的，方便排序。
```cpp
char op[105]; //op[i] 表示第 i 个排序信息的符号(+/-) 
int b[105]={}; //b[i] 表示第 i 个排序信息是按第 b[i] 列标题排序的 
	for(int i=1;i<=m;i++){
		cin>>s;
		op[i]=s.back(); //最后一个字符 
		s.erase(s.size()-1,1); //去掉最后一个符号 
		for(int j=1;j<=cnt;j++){ //暴力枚举看是属于哪一列（也可用 map 实现） 
			if(head[j]==s) b[i]=j; 
		}
	}	
```
### 模块四：排序
我们可以用 `sort` 进行排序，再考虑 `cmp` 函数。  
```cpp
int a[105]={};
for(int i=1;i<n;i++) a[i]=i;
//因为我们之前是按下标存储的，所以只需要对下标排序即可
sort(a+1,a+n,cmp);  
//注意是给 a[1]~a[n-1] 排序 
```
考虑 `cmp(i,j)` 函数。   
对于每个排序信息 $k$：
- 如果 $(i,k)$ 单元格与 $(j,k)$ 单元格相等（因为不管是数值单元格还是字符串单元格，只要相等，表示的一定相同），则继续判断下一个信息。
- 否则继续分情况讨论：
1. 如果是升序排列：
- 如果是字符串单元格，让字典序小的排在前面。
- 如果是数值单元格，（相信大家都写过高精度减法），先比较字符串的长度，若不同，让短的排在前面；若相同，让字典序小的排在前面。
2. 如果是降序排列：
- 如果是字符串单元格，让字典序大的排在前面。
- 如果是数值单元格，先比较字符串的长度，若不同，让长的排在前面；若相同，让字典序大的排在前面。

最后，如果所有要比较的信息都相同，返回下标小的。  
这里的代码不再一一解释。
```cpp
bool cmp(int i,int j){
	for(int k=1;k<=m;k++){
		if(x[i][b[k]]!=x[j][b[k]]){
			if(op[k]=='+'){
				if(!f[b[k]]){
					if(x[i][b[k]].size()!=x[j][b[k]].size()) return x[i][b[k]].size()<x[j][b[k]].size();
					else return x[i][b[k]]<x[j][b[k]]; 
				}
				else return x[i][b[k]]<x[j][b[k]]; 
			}
			else{
				if(!f[b[k]]){
					if(x[i][b[k]].size()!=x[j][b[k]].size()) return x[i][b[k]].size()>x[j][b[k]].size();
					else return x[i][b[k]]>x[j][b[k]]; 
				}
				else return x[i][b[k]]>x[j][b[k]]; 
			}
		}
	}
	return i<j;
}
```
上完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,m,a[105],b[105];
string s,head[15]; 
string x[105][15];
char op[105];
bool f[15];
bool cmp(int i,int j){
	for(int k=1;k<=m;k++){
		if(x[i][b[k]]!=x[j][b[k]]){
			if(op[k]=='+'){
				if(!f[b[k]]){
					if(x[i][b[k]].size()!=x[j][b[k]].size()) return x[i][b[k]].size()<x[j][b[k]].size();
					else return x[i][b[k]]<x[j][b[k]]; 
				}
				else return x[i][b[k]]<x[j][b[k]]; 
			}
			else{
				if(!f[b[k]]){
					if(x[i][b[k]].size()!=x[j][b[k]].size()) return x[i][b[k]].size()>x[j][b[k]].size();
					else return x[i][b[k]]>x[j][b[k]]; 
				}
				else return x[i][b[k]]>x[j][b[k]]; 
			}
		}
	}
	return i<j;
}
int main(){
	cin>>n>>s;
	s+=',';
	while(s.size()>0){
		int pos=s.find(',');
		head[++cnt]=s.substr(0,pos);
		s.erase(0,pos+1);
	}
	for(int i=1;i<n;i++){
		cin>>s;
		s+=',';
		for(int j=1;j<=cnt;j++){
			int pos=s.find(',');
			for(int k=0;k<pos;k++){
				if((s[k]>='a'&&s[k]<='z')
				||(s[k]>='A'&&s[k]<='Z')) f[j]=1;
			}
			x[i][j]=s.substr(0,pos);
			s.erase(0,pos+1);
		}
	} 
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>s;
		op[i]=s.back();
		s.erase(s.size()-1,1);
		for(int j=1;j<=cnt;j++){
			if(head[j]==s) b[i]=j;
		}
	}
	for(int i=1;i<n;i++) a[i]=i;
	sort(a+1,a+n,cmp);
	for(int i=1;i<=cnt;i++) cout<<head[i]<<(i==cnt?'\n':','); 
	for(int i=1;i<n;i++){
		int pos=a[i];
		for(int j=1;j<=cnt;j++){
			cout<<x[pos][j]<<(j==cnt?'\n':',');
		}
	}
	return 0;
}
```
### 结语
这个模拟题应该属于中等难度的模拟。大家应该多练一练模拟题，掌握对代码的熟悉程度。而且有些模拟题中还参杂了一些算法。经常练习这些题目，也可以学会优化代码。

---

## 作者：uncle_steve (赞：0)

### 题目知识点

比较复杂的模拟。

## 解题思路

1. 首先处理输入，建立结构体与数组存入信息（输入很恶心，要注意）

2. 其次是操作：

 - 可以分多个函数处理不同的功能：Score 函数处理第一列，Name 函数处理第二列等，以此类推。

 - 注意将输入时的数字字符串转换成 char 类型。
 
3. 最后将答案整合一下即可。

## 注意事项

- 输入时注意不要搞混数组的作用，防止后期函数出错！！！

- 输出整合时建议增加变量 $sum$ 判断先后顺序。

## 部分代码


```cpp
void shuru(){	
	for(int i=0;i<sump.length();i++){
		if(sump[i]==','){
			ans++;
			continue;
		}
		s[tot]+=sump[i];
	}
	return;
}
```

---

## 作者：SF_bee (赞：0)

# [B3982 [信息与未来 2024] 数据排序](https://www.luogu.com.cn/problem/B3982) 题解

本题主要考察对于自定义比较函数的使用与对整行字符串的处理。难点在于如何正确处理整行的字符串。

### 1、处理输入的字符串

* 对于输入的整行字符串，我们可以使用 `std::getline()` 来进行输入。

* 读入后，我们可以遍历读入整个字符串，以 `,` 为分隔把单个字符串使用数组存储下来。

```cpp
std::string t,input;
std::vector<std::string> key;
std::getline(std::cin,input);
for(auto i : input){
    if(i == ',') key.push_back(t),t = "";  //一定不要忘了清空
    else t += i;
}
key.push_back(t),t = "";  //因为最后一段没有逗号结尾，所以需要手动添加
```

* 需要注意的是，使用 `std::cin` 进行输入后，需要先进行一次 `std::getline()` 才能进行后续的操作，这是因为使用 `std::cin` 读入后，行末会遗留一个换行符，直接使用 `std::getline()` 会导致读入空行的情况。

* 对于表格正文内容，我们可以使用 map 进行存储，map 的每个元素由一个 key 和一个 val 组成，正好对应题目表头与内容的关系。

```cpp
std::map<std::string,std::string> a[MAX];
for(int i = 0;i < n - 1;i++){
    std::getline(std::cin,input);
    int cnt = 0;
    for(auto j : input){
        if(j == ',') a[i][key[cnt++]] = t,t = "";
        else t += j;
    }
    a[i][key[cnt++]] = t,t = "";
}
```

* 而对于排序规则，我们可以使用一个类型为 `std::pair<std::string,bool>` 的数组进行存储。其中，第一项为关键字，第二项为排序方式，0 代表从小到大，1 表示从大到小。

```cpp
std::vector<std::pair<std::string,bool> > ord;
std::cin >> m;
std::getline(std::cin,input);
for(int i = 0;i < m;i++){
    std::getline(std::cin,input);
    for(auto j : input){
        if(j == '+' || j == '-') ord.push_back({t,(j == '+' ? 0 : 1)}),t = "";
        else t += j;
    }
}
```

### 2、进行排序

* map 本身的排序方式并不能满足我们的需求，因此我们需要自定义比较函数。

* 我们遍历整个排序规则，如果比较的两项对应关键字的值不同，我们就进行比较。特别的，我们需要对关键字进行判断是否为数字，如果是数字则需要先转为数字再比较。

```cpp
bool check(const std::string s){  //判断是否是数字
    for(auto i : s)
        if('0' > i || i > '9') return 0;
    return 1;
}
int change(const std::string s){  //字符串变数字
    int res = 0;
    for(auto i : s)
        res = res * 10 + (i - '0');
    return res;
}
bool cmp(std::map<std::string,std::string> x,std::map<std::string,std::string> y){
    for(auto [ky,od] : ord){  //遍历排序方式
        if(x[ky] == y[ky]) continue;  //相同则使用下一种方式
        if(check(x[ky]) && check(y[ky]))  //是数字按数字排
            return (od ? change(x[ky]) > change(y[ky]) : change(x[ky]) < change(y[ky]));
        else  //否则按字典排
            return (od ? x[ky] > y[ky] : x[ky] < y[ky]);
    }
    return 0;
}
```

* 最后，我们应该使用 `std::stable_sort()`。因为 `std::sort()` 是不稳定的。

### 输出

* 输出排完序后的 map 即可，注意判断最后一个元素不需要加逗号。

### AC code

```cpp
#include <bits/stdc++.h>

const int MAX = 1e2 + 5;
int n,m;
std::vector<std::string> key;  //关键字
std::vector<std::pair<std::string,bool> > ord;  //关键字排序方式，0为小到大
std::map<std::string,std::string> a[MAX];
bool check(const std::string s){  //判断是否是数字
    for(auto i : s)
        if('0' > i || i > '9') return 0;
    return 1;
}
int change(const std::string s){  //字符串变数字
    int res = 0;
    for(auto i : s)
        res = res * 10 + (i - '0');
    return res;
}
bool cmp(std::map<std::string,std::string> x,std::map<std::string,std::string> y){
    for(auto [ky,od] : ord){  //遍历排序方式
        if(x[ky] == y[ky]) continue;  //相同则使用下一种方式
        if(check(x[ky]) && check(y[ky]))  //是数字按数字排
            return (od ? change(x[ky]) > change(y[ky]) : change(x[ky]) < change(y[ky]));
        else  //否则按字典排
            return (od ? x[ky] > y[ky] : x[ky] < y[ky]);
    }
    return 0;
}

int main(){
    std::ios::sync_with_stdio(0);
    std::cin.tie(0);

    std::string t,input;
    std::cin >> n;
    std::getline(std::cin,input);
    std::getline(std::cin,input);
    for(auto i : input){
        if(i == ',') key.push_back(t),t = "";
        else t += i;
    }
    key.push_back(t),t = "";
    for(int i = 0;i < n - 1;i++){
        std::getline(std::cin,input);
        int cnt = 0;
        for(auto j : input){
            if(j == ',') a[i][key[cnt++]] = t,t = "";
            else t += j;
        }
        a[i][key[cnt++]] = t,t = "";
    }
    std::cin >> m;
    std::getline(std::cin,input);
    for(int i = 0;i < m;i++){
        std::getline(std::cin,input);
        for(auto j : input){
            if(j == '+' || j == '-') ord.push_back({t,(j == '+' ? 0 : 1)}),t = "";
            else t += j;
        }
    }
    std::stable_sort(a,a + n - 1,cmp);
    for(int j = 0;j < key.size();j++){
        std::cout << key[j] << ",\n"[j == key.size() - 1];
    }
    for(int i = 0;i < n - 1;i++){
        for(int j = 0;j < key.size();j++){
            std::cout << a[i][key[j]] << ",\n"[j == key.size() - 1];
        }
    }
    return 0;
}
```

---

## 作者：queenbee (赞：0)

# B3982 数据排序 题解

## 思路
[题目传送门](https://www.luogu.com.cn/problem/B3982)，一道模拟题，将表头中的列存储在一个结构体中，表的内容存储在一个结构体中，根据给定的排序规则用 sort 函数（有坑）给结构体排序（数字和字符串要单独排），最后输出排序好的表格。

巨坑：因为 sort 是不稳定排序，题目要求**两项相同要保证相对位置不变**，所以要在两项需要比较的内容相同时**按照两项的序号排序**。
## 程序
```cpp
#include<bits/stdc++.h>	//我爱万能头 
using namespace std;
const int N=1e2+10;
const int M=20;
int n;
int m;
int tot=1;
string s1;
string s[M];	//表头 
bool text[M];	//列单元格类型 
struct Node{	//表格内容结构体 
	string ch[M];
    int num[M];
    int pos;
}f[N];
struct Order{	//排序规则 
	bool ord;
	int pos;
}e[M];
void title(){	//表头存储 
	for(int i=0;i<s1.length();i++){
		if(s1[i]==','){
			tot++;
			continue;
		}
		s[tot]+=s1[i];
	}
	return;
}
void content(int n){	//表格内容存储 
	int tt=1;
	for(int i=0;i<s1.length();i++){
		if(s1[i]==','){
			tt++;
			continue;
		}
		f[n].ch[tt]+=s1[i];
		if((s1[i]>='a'&&s1[i]<='z')||(s1[i]>='A'&&s1[i]<='Z')){
			text[tt]=1;
		}
	}
	return;
}
bool tmp(Node a,Node b,bool text,int pos){	//分类排序 
	if(text){
		return a.ch[pos]<b.ch[pos];
	}
	else{
		return a.num[pos]<b.num[pos];
	}
}
bool cmp(Node a,Node b){	//按规则优先级排序 
	for(int i=1;i<=m;i++){
		if(a.ch[e[i].pos]!=b.ch[e[i].pos]){
			if(e[i].ord){
				return tmp(a,b,text[e[i].pos],e[i].pos);
			}
			else{
				return !tmp(a,b,text[e[i].pos],e[i].pos);
			}
		}
	}
	return a.pos<b.pos;	//巨坑 
}
int chan(string a){	//将字符串转为数字 
    int n=0;
    for(int i=0;i<a.length();i++){
        n=n*10+a[i]-'0';
    }
    return n;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){	//输入并分类存储 
		cin>>s1;
		if(i==1){
			title();
		}
		else{
			content(i-1);
		}
	}
	for(int i=1;i<n;i++){
		f[i].pos=i;
	}
    for(int i=1;i<=tot;i++){
        if(!text[i]){
            for(int j=1;j<n;j++){
                f[j].num[i]=chan(f[j].ch[i]);	//按单元格内容转化 
            }
        }
    }
	cin>>m;
	for(int i=1;i<=m;i++){	//输入并存储排序规则 
		cin>>s1;
		if(s1[s1.length()-1]=='+'){
			e[i].ord=1;
		}
		s1=s1.substr(0,s1.length()-1);
		for(int j=1;j<=tot;j++){
			if(s[j]==s1){
				e[i].pos=j;
				break;
			}
		}
	}
	sort(f+1,f+n,cmp);	//排序 
	for(int i=1;i<=tot;i++){	//输出表头 
		if(i==tot){
			cout<<s[i]<<endl;
			break;
		}
		cout<<s[i]<<",";
	}
	for(int i=1;i<n;i++){	//输出排序后的表格 
		for(int j=1;j<=tot;j++){
            if(text[j]){
                if(j==tot){
				    cout<<f[i].ch[j];
				    break;
			    }
			    cout<<f[i].ch[j]<<",";
            }
            else{
                if(j==tot){
				    cout<<f[i].num[j];
				    break;
			    }
			    cout<<f[i].num[j]<<",";
            }
		}
        cout<<endl;
	}
	return 0;	//完结撒花 
} 
```

---

## 作者：fire_and_sweets (赞：0)

一道很有趣的模拟题。

我是用结构体来存储各种类型的变量的。然后，我们只要重载结构体中的比较函数，接着使用普通的冒泡排序即可。

这里主要讲一个易错点：一定要选用稳定的排序！

`sort` 函数是系统自带的，不稳定的快速排序函数。如果用了这个函数可以取得 $14$ 分。

当然本人在考场上更惨，把 `id` 写成了 `i`，所以写题解寄之。

```
#include <bits/stdc++.h>
using namespace std;
#define int long long 

const int N = 110;

vector<string> cats;
vector<pair<int, char> > rules;
map<string, int> mpid;
int n, m;
struct Typ {
	int num;
	string st;
};
struct Node {
	vector<Typ> v;
	bool operator < (const Node& _) const
	{
		for (int i = 0; i < rules.size(); i ++ )
		{
			int id = rules[i].first, typ = 0;
			if (rules[i].second == '-') typ = 1;
			if (typ == 0)
			{
				if (v[id].st != "")
				{
					if (v[id].st != _.v[id].st) return v[id].st < _.v[id].st;
				}
				else if (v[id].num != _.v[id].num) return v[id].num < _.v[id].num;
			}
			else
			{
				if (v[id].st != "")
				{
					if (v[id].st != _.v[id].st) return v[id].st > _.v[id].st;
				}
				else if (v[id].num != _.v[id].num) return v[id].num > _.v[id].num;
			}
		}
		return false;
	}
};
vector<Node> cuns;

int getnumb(string s)
{
	int num = 0;
	for (int i = 0; i < s.size(); i ++ )
		num = num * 10 + s[i] - '0';
	return num; 
}

bool ss(string s) {
	for (int i = 0; i < s.size(); i ++ )
		if (isalpha(s[i])) return true;
	return false;
}

signed main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); 
	cin >> n; n -- ;
	string s, newt;
	cin >> s;
	for (int i = 0; i < s.size(); i ++ )
		if (s[i] == ',') cats.push_back(newt), newt = "";
		else newt.push_back(s[i]);
	if (newt != "") cats.push_back(newt);
	for (int i = 0; i < cats.size(); i ++ )
		mpid[cats[i]] = i;
	for (int i = 1; i <= n; i ++ ) {
		string cur;
		cin >> cur;
		Node emp;
		string newst;
		for (int i = 0; i < cur.size(); i ++ )
		{
			if (cur[i] == ',') {
				if (ss(newst)) emp.v.push_back((Typ){-1, newst});
				else emp.v.push_back((Typ){getnumb(newst), ""});
				newst = "";
			}
			else newst.push_back(cur[i]); 
		}
		if (ss(newst)) emp.v.push_back((Typ){-1, newst});
		else emp.v.push_back((Typ){getnumb(newst), ""});
		cuns.push_back(emp);
	} 
	cin >> m;
	for (int i = 0; i < m; i ++ )
	{
		string s;
		cin >> s;
		if (s[(int)s.size() - 1] == '-') rules.push_back(make_pair(mpid[s.substr(0, (int)s.size() - 1)], '-'));
		else rules.push_back(make_pair(mpid[s.substr(0, (int)s.size() - 1)], '+'));
	}
	for (int i = 0; i < cuns.size(); i ++ )
		for (int j = 0; j < cuns.size() - i - 1; j ++ )
			if (cuns[j + 1] < cuns[j]) swap(cuns[j], cuns[j + 1]);
	cout << s << endl;
	for (int i = 0; i < cuns.size(); i ++ )
	{
		for (int j = 0; j < cuns[i].v.size(); j ++ )
		{
			if (cuns[i].v[j].st != "") cout << cuns[i].v[j].st;
			else cout << cuns[i].v[j].num;
			if (j != (int)cuns[i].v.size() - 1) cout << ',';
		}
		cout << endl;
	}
	return 0;
} 
```

---


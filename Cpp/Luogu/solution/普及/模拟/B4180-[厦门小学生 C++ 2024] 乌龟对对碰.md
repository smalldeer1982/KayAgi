# [厦门小学生 C++ 2024] 乌龟对对碰

## 题目背景

本试题为 2024 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

乌龟对对碰是网络直播平台中流行的一种盲盒玩法。主播准备了一个盲盒序列，消费者需要按盲盒序列从前到后的顺序，先购买数包树脂乌龟盲盒。消费者在下单之后，主播会现场拆开消费者的树脂乌龟盲盒进行对对碰环节。

- **对对碰环节 1**：在该环节会把消费者的乌龟盲盒按 **照原盲盒序列的顺序** 拆开放在 $9$ 宫格当中，按照从上到下从左到右的顺序给 $9$ 宫格编号 $1$ 到 $9$，按照编号从小到大的顺序给每一个格子放一个乌龟。查看 $9$ 宫格是否满足下方的特定条件，满足条件按照赠送机制对应地进行操作。当满足下面的特定条件时，会把 $9$ 宫格中的部分乌龟拿走，算作要给消费者的乌龟。  
当所有特定条件都不满足的时候，$9$ 宫格里的所有乌龟全部拿走，算作要给消费者的乌龟，对对碰环节结束。最终消费者获得 **自己购买的乌龟** 以及对对碰 **赠送的乌龟**。     
然后进入到环节 2。   

- **对对碰环节 2**：向消费者的未拆开的盲盒中，补充满足特定条件对应数量的赠送盲盒。即如果当前剩余 $x$ 个盲盒还没开，现在满足特定条件又赠送了 $y$ 个盲盒，那么现在剩余的盲盒数量增加到 $x+y$，将这 $y$ 个盲盒按顺序补在最后面，原盲盒序列的数量保证满足游戏过程中的赠送数量。然后进入到环节 $3$。

- **对对碰环节 3**：用剩余还没拆开的乌龟盲盒按照原盲盒序列的顺序去补充 $9$ 宫格，按照编号从小到大的顺序给空的格子放一个乌龟。然后再进入到环节 $1$。

| 特定条件 | 要求 | 赠送机制 |
|:----------:|:------:|:----------:|
| 条件 1 | 场上有两个颜色相同的乌龟 **（不一定相邻）** | 把场上成对出现的乌龟全部成对拿走，如果拿走了 $x$ 对乌龟那么就赠送 $x$ 个盲盒 |
| 条件 2 | 当 **按照条件 1** 拿走乌龟之后刚好场上没有任何一只乌龟 | 赠送 $8$ 个盲盒 |
| 条件 3 | 当 $9$ 宫格的各个位置 **都有乌龟** 并且每只乌龟的颜色 **各不相同** | $9$ 宫格中的所有乌龟拿走，赠送 $10$ 个盲盒（按本条件拿走所有乌龟后，不能按“条件 $2$ 清台”赠送盲盒）。 |

乌龟总共有 $10$ 种颜色（用 $0\sim 9$ 表示），现在假定有一个长度为 $n$ 的盲盒序列，序列用字符串 $S$ 表示，其中第 $i$ 个字符代表第 $i$ 个乌龟盲盒中乌龟的颜色。小 Z 看到别人买了很多乌龟也想组建自己的乌龟大军，于是小 Z 下单了 $a$ 个盲盒，即盲盒序列中的第 $1$ 个盲盒到第 $a$ 个盲盒，赠送盲盒从盲盒序列的第 $a+1$ 个盲盒依次往后赠送，现在小 Z 想知道自己最后能拿到多少只乌龟。

## 说明/提示

### 样例解释 1

1. 盲盒序列：$\tt{012334567888999}$；   
放进九宫格之前没开的盲盒：$\tt{0 1 2 3 3 4 5 6 7 8}$；   
放入九宫格之后，如下表所示：

| 0 | 1 | 2 |
|---|---|---|
| 3 | 3 | 4 |
| 5 | 6 | 7 |
2. 手里没开的盲盒：$\tt{8}$；    
已经拿走的盲盒：无；    
满足条件 1（赠送 1 个盲盒），处理之后如下表所示：

| 0 | 1 | 2 |
|---|---|---|
|   |   | 4 |
| 5 | 6 | 7 |

3. 手里没开的盲盒：$\tt{8 8}$；       
已经拿走的盲盒：$\tt{3 3}$；   
放入九宫格之后，如下表所示：   

| 0 | 1 | 2 |
|---|---|---|
| 8 | 8 | 4 |
| 5 | 6 | 7 |
4. 满足条件 1（赠送 1 个盲盒），处理之后如下表所示：

| 0 | 1 | 2 |
|---|---|---|
|   |   | 4 |
| 5 | 6 | 7 |

5. 手里没开的盲盒：$\tt{8}$；    
已经拿走的盲盒：$\tt{3 3 8 8}$；    
放入九宫格之后，如下表所示：   

| 0 | 1 | 2 |
|---|---|---|
| 8 |   | 4 |
| 5 | 6 | 7 |

6. 不满足所有 $3$ 个条件，游戏结束，$9$ 宫格里的盲盒全部拿走。   
手里没开的盲盒：无；    
已经拿走的盲盒：$\tt{3 3 8 8 0 1 2 8 4 5 6 7}$；    
因此输出答案为 $12$。
### 数据范围

**洛谷民间测试数据不满足特殊性质。**

对于所有数据，满足 $200\leq S$ 的长度 $\leq 5\times 10^5$，$10\leq a\leq 200$。

| 数据点编号 | $S$ 的长度 $\leq$ | $a\leq$ | 特殊性质 |
|:------------:|:------------:|:----:|:----------:|
| $1,2$       | $200$        | $20$ | 只满足特定条件 $1$ |
| $3,4$       | $200$        | $20$ | 只满足特定条件 $1,2$ |
| $5,6$       | $200$        | $20$ | 只满足特定条件 $1,3$ |
| $7,8,9,10$   | $5\times 10^5$     | $1\times 10^5$ | 无特殊限制 |

## 样例 #1

### 输入

```
012334567888999
10```

### 输出

```
12```

## 样例 #2

### 输入

```
2012345678901234501890123
10```

### 输出

```
23```

# 题解

## 作者：jzl_1210 (赞：3)

题目差点没看懂，终究还是我太菜了。

我本人就是是厦门的小学生，去年参加比赛，第三题写了上百行代码，似乎还是爆零了。这次来重新写一下这题。

此题其实不难写，只是有一些细节，考验码力。

# 题意简化

有一个字符串，每次要把字符串上的数填进九宫格，然后经过特定条件来获取盲盒，以此继续填充九宫格。直到所有特定条件都不满足时结束。

这只是大概流程，具体的规则以及特定条件要看题面。

# 具体过程

那么我们就逐个击破吧。

## 条件一

我用的方法可能比较麻烦，大家可以用自己的方法解决，这里提供一种思路。

用一个数组存储每种颜色的乌龟出现了多少次，遍历每种颜色，计算要赠送多少个盲盒，期间还要记得更新九宫格，可以把已经拿走的乌龟的那个位置改为负数。

此部分的代码：

```cpp
int t1(){
	//gsl:赠送了多少盲盒
	//gs[i]:颜色为i的乌龟有几只
	//jg[i][j]:这个位置的乌龟是什么颜色，-1表示没有乌龟
	int gsl = 0;
	memset(gs, 0, sizeof(gs));
	for(int i = 1;i <= 3;i++){
		for(int j = 1;j <= 3;j++){
			if(jg[i][j] == -1) continue;
			gs[jg[i][j]]++;
			//记录每种颜色乌龟的数量 
		}
	}
	for(int i = 0;i < 10;i++){
		if(gs[i] < 2) continue;
		int xcsl = gs[i] / 2 * 2;
		//xcsl:要拿走的乌龟数量 
		gsl += (gs[i] / 2);
		gs[i] %= 2;
		//期间再遍历九宫格，拿走颜色为i的乌龟 
		for(int j = 1;j <= 3;j++){
			for(int k = 1;k <= 3;k++){
				if(jg[j][k] == i){
					jg[j][k] = -1;
					if(--xcsl == 0) break;
				}
			}
			if(xcsl < 1) break;
		}
	}
	return gsl;
	//条件1就顺利完成了 
}
```

## 条件二

这个就很简单了，判断九宫格中的数是否都为负数即可。


```cpp
int t2(){
	bool no = 1;
	for(int i = 1;i <= 3;i++){
		if(jg[i][1] != -1) no = 0;
		if(jg[i][2] != -1) no = 0;
		if(jg[i][3] != -1) no = 0;
	}
	//这里要注意，在条件1中有拿走乌龟
	//并且把九宫格中所有乌龟都拿走了才符合条件2 
	if(tj1 && no){
		return 8;
	}
	return 0;
}
```

## 条件三

这个也简单，判断有没有相同颜色的乌龟，符合条件就清空九宫格。


```cpp
int t3(){
	//条件3.1：都有乌龟
	//条件3.2：各不相同 
	bool no = 0;
	//条件3.1
	for(int i = 1;i <= 3;i++){
		for(int j = 1;j <= 3;j++){
			if(jg[i][j] == -1) no = 1;
		}
	}
	if(no) return 0;
	//条件3.2
	memset(gs, 0, sizeof(gs));
	for(int i = 1;i <= 3;i++){
		for(int j = 1;j <= 3;j++){
			if(jg[i][j] == -1) continue;
			gs[jg[i][j]]++;
		}
	}
	bool flag = 1;
	//和条件1一样的方法 
	for(int i = 0;i < 10;i++){
		if(gs[i] > 1){
			flag = 0;
			break;
		}
	}
	if(flag){
		for(int i = 1;i <= 3;i++){
			for(int j = 1;j <= 3;j++){
				jg[i][j] = -1;
			}
		}	
		return 10;
	}
	return 0;
} 
```

## 主框架

这个部分要记得把赠送的盲盒补充到未开的盲盒序列中。


```cpp
int main(){
    cin >> str;
    scanf("%d", &buy);
    //str：原盲盒序列
	//wk ：未开盲盒序列 
    for(int i = 0;i < buy;i++){
    	wk += str[xl], xl++;
	}
	while(1){
		bool pd_zs = 0;
		int js = -1, len = wk.size();
		//补充九宫格 
		for(int i = 1;i <= 3;i++){
			for(int j = 1;j <= 3;j++){
				if(jg[i][j] == -1){
					if(js + 1 < len){
						jg[i][j] = wk[++js] - '0';
					}
				}
			}
		}
		//删除掉这些已补充到九宫格的盲盒 
		wk.erase(0, js + 1);
		//以此判断3个条件 
		int zs = t1();
		if(zs){
			tj1 = 1, pd_zs = 1;
			//补充未开的盲盒序列 
			for(int i = 1;i <= zs;i++){
				wk += str[xl++];
			}
			ans += zs;
		}
		zs = t2();
		if(zs){
			pd_zs = 1;
			//补充未开的盲盒序列 
			for(int i = 1;i <= zs;i++){
				wk += str[xl++];
			}
			ans += zs;
		}
		zs = t3();
		if(zs){
			pd_zs = 1;
			//补充未开的盲盒序列 
			for(int i = 1;i <= zs;i++){
				wk += str[xl++];
			}
			ans += zs;
		}
		if(!pd_zs) break;//结束条件 
	}
	printf("%d", ans + buy);
	//终于结束了 
	return 0;
}
```

# 代码

终于结束了，真不容易啊。

完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
string str, wk;
int buy, xl, gs[11], ans;
int jg[4][4] = {
	{-1, -1, -1, -1}, 
	{-1, -1, -1, -1}, 
	{-1, -1, -1, -1}, 
	{-1, -1, -1, -1}
};
//xl:当前要到第几个了 
bool tj1;
int t1(){
	int gsl = 0;
	memset(gs, 0, sizeof(gs));
	for(int i = 1;i <= 3;i++){
		for(int j = 1;j <= 3;j++){
			if(jg[i][j] == -1) continue;
			gs[jg[i][j]]++;
		}
	}
	for(int i = 0;i < 10;i++){
		if(gs[i] < 2) continue;
		int xcsl = gs[i] / 2 * 2;
		gsl += (gs[i] / 2);
		gs[i] %= 2;
		for(int j = 1;j <= 3;j++){
			for(int k = 1;k <= 3;k++){
				if(jg[j][k] == i){
					jg[j][k] = -1;
					if(--xcsl == 0) break;
				}
			}
			if(xcsl < 1) break;
		}
	}
	return gsl;
}
int t2(){
	bool no = 1;
	for(int i = 1;i <= 3;i++){
		if(jg[i][1] != -1) no = 0;
		if(jg[i][2] != -1) no = 0;
		if(jg[i][3] != -1) no = 0;
	}
	if(tj1 && no){
		return 8;
	}
	return 0;
}
int t3(){
	bool no = 0;
	for(int i = 1;i <= 3;i++){
		for(int j = 1;j <= 3;j++){
			if(jg[i][j] == -1) no = 1;
		}
	}
	if(no) return 0;
	memset(gs, 0, sizeof(gs));
	for(int i = 1;i <= 3;i++){
		for(int j = 1;j <= 3;j++){
			if(jg[i][j] == -1) continue;
			gs[jg[i][j]]++;
		}
	}
	bool flag = 1;
	for(int i = 0;i < 10;i++){
		if(gs[i] > 1){
			flag = 0;
			break;
		}
	}
	if(flag){
		for(int i = 1;i <= 3;i++){
			for(int j = 1;j <= 3;j++){
				jg[i][j] = -1;
			}
		}	
		return 10;
	}
	return 0;
} 
int main(){
    cin >> str;
    scanf("%d", &buy);
    for(int i = 0;i < buy;i++){
    	wk += str[xl], xl++;
	}
	while(1){
		bool pd_zs = 0;
		int js = -1, len = wk.size();
		//补充九宫格 
		for(int i = 1;i <= 3;i++){
			for(int j = 1;j <= 3;j++){
				if(jg[i][j] == -1){
					if(js + 1 < len){
						jg[i][j] = wk[++js] - '0';
					}
				}
			}
		}
		wk.erase(0, js + 1);
		int zs = t1();
		if(zs){
			tj1 = 1, pd_zs = 1;
			for(int i = 1;i <= zs;i++){
				wk += str[xl++];
			}
			ans += zs;
		}
		zs = t2();
		if(zs){
			pd_zs = 1;
			for(int i = 1;i <= zs;i++){
				wk += str[xl++];
			}
			ans += zs;
		}
		zs = t3();
		if(zs){
			pd_zs = 1;
			for(int i = 1;i <= zs;i++){
				wk += str[xl++];
			}
			ans += zs;
		}
		if(!pd_zs) break;
	}
	printf("%d", ans + buy);
	return 0;
}
```

---

## 作者：Bert2012 (赞：2)

### **题目跳转站:**

[B4180 [厦门小学生 C++ 2024] 乌龟对对碰](https://www.luogu.com.cn/problem/B4180)

## **代码解析:**

**纯模拟题！！！**

### **函数：**

**p1 函数：**
判断是否满足条件 1，通过统计九宫格中每种颜色乌龟数量，找出成对的乌龟并移除，返回拿走的乌龟对数（即赠送盲盒数）。

代码:


```cpp
int p1() {
    // 记录生成的新字符数量
    int n = 0;
    // 初始化计数数组
    memset(c, 0, sizeof(c));
    // 统计九宫格中每个数字出现的次数
    for (int x = 1; x <= 3; x++) {
        for (int y = 1; y <= 3; y++) {
            if (g[x][y] != -1) {
                c[g[x][y]]++;
            }
        }
    }
    // 遍历每个数字
    for (int x = 0; x < 10; x++) {
        if (c[x] < 2) continue;
        // 计算该数字可组成的对数
        int t = c[x] / 2 * 2;
        // 累加生成的新字符数量
        n += c[x] / 2;
        // 更新该数字剩余的数量
        c[x] %= 2;
        // 从九宫格中移除组成对的数字
        for (int y = 1; y <= 3; y++) {
            for (int z = 1; z <= 3; z++) {
                if (g[y][z] == x) {
                    g[y][z] = -1;
                    if (--t == 0) break;
                }
            }
            if (t < 1) break;
        }
    }
    return n;
}
```


**p2 函数：**
判断是否满足条件 2，在满足条件 1 的基础上，检查按条件 1 操作后 9 宫格是否为空，若为空返回赠送盲盒数 8，否则返回 0。

代码:


```cpp
// 处理九宫格全空的特殊情况的函数
int p2() {
    // 标记九宫格是否全空
    bool e = true;
    for (int x = 1; x <= 3; x++) {
        if (g[x][1] != -1 || g[x][2] != -1 || g[x][3] != -1) {
            e = false;
        }
    }
    // 如果满足特定条件且九宫格全空
    if (f && e) {
        return 8;
    }
    return 0;
}
```


**p3 函数：**
判断是否满足条件 3，检查 9 宫格是否全满且乌龟颜色各不相同，若满足返回赠送盲盒数 10，否则返回 0。

代码:


```cpp
// 处理九宫格无重复数字的特殊情况的函数
int p3() {
    // 标记九宫格是否有空位
    bool e = false;
    for (int x = 1; x <= 3; x++) {
        for (int y = 1; y <= 3; y++) {
            if (g[x][y] == -1) {
                e = true;
            }
        }
    }
    // 如果有空位，直接返回 0
    if (e) return 0;
    // 重新初始化计数数组
    memset(c, 0, sizeof(c));
    // 统计九宫格中每个数字出现的次数
    for (int x = 1; x <= 3; x++) {
        for (int y = 1; y <= 3; y++) {
            if (g[x][y] != -1) {
                c[g[x][y]]++;
            }
        }
    }
    // 标记九宫格中的数字是否都唯一
    bool u = true;
    for (int x = 0; x < 10; x++) {
        if (c[x] > 1) {
            u = false;
            break;
        }
    }
    // 如果数字都唯一
    if (u) {
        // 清空九宫格
        for (int x = 1; x <= 3; x++) {
            for (int y = 1; y <= 3; y++) {
                g[x][y] = -1;
            }
        }
        return 10;
    }
    return 0;
}
```


**主流程：**
读取盲盒序列和购买的盲盒数量，将购买的盲盒存入 w 。进入循环，不断将未打开的盲盒放入 9 宫格，检查三个条件。若满足条件，根据条件获得赠送盲盒并更新 w 和最终获得乌龟总数 a 。若某一轮没有获得赠送盲盒，说明游戏结束，计算并输出最终获得的乌龟总数（购买的盲盒数量 b 加上赠送的乌龟数量 a ）。

代码:


```cpp
int main() {
    // 输入字符串
    cin >> s;
    // 输入初始购买的字符数量
    scanf("%d", &b);
    // 初始购买字符添加到可用字符中
    for (int x = 0; x < b; x++) {
        w += s[i++];
    }
    while (1) {
        // 标记本轮是否有变化
        bool ch = false;
        // 可用字符的索引
        int j = -1;
        // 可用字符的长度
        int l = w.size();
        // 填充九宫格
        for (int x = 1; x <= 3; x++) {
            for (int y = 1; y <= 3; y++) {
                if (g[x][y] == -1 && j + 1 < l) {
                    g[x][y] = w[++j] - '0';
                }
            }
        }
        // 移除已使用的可用字符
        w.erase(0, j + 1);
        // 调用 p1 函数处理相同数字对
        int r = p1();
        if (r) {
            f = true;
            ch = true;
            // 生成新的可用字符
            for (int x = 1; x <= r; x++) {
                w += s[i++];
            }
            // 累加结果
            a += r;
        }
        // 调用 p2 函数处理全空情况
        r = p2();
        if (r) {
            ch = true;
            // 生成新的可用字符
            for (int x = 1; x <= r; x++) {
                w += s[i++];
            }
            // 累加结果
            a += r;
        }
        // 调用 p3 函数处理无重复数字情况
        r = p3();
        if (r) {
            ch = true;
            // 生成新的可用字符
            for (int x = 1; x <= r; x++) {
                w += s[i++];
            }
            // 累加结果
            a += r;
        }
        // 如果本轮没有变化，退出循环
        if (!ch) break;
    }
    // 输出最终结果
    printf("%d", a + b);
    return 0;
}
```

最终代码:


```cpp
#include <bits/stdc++.h>
using namespace std;

// 存储输入的字符串
string s;
// 存储当前可用的字符
string w;
// 初始购买的字符数量
int b;
// 当前处理到输入字符串的索引
int i;
// 记录每个数字出现的次数
int c[11];
// 最终结果
int a;
// 3x3 的九宫格数组，初始值为 -1 表示空位
int g[4][4] = {
    {-1, -1, -1, -1},
    {-1, -1, -1, -1},
    {-1, -1, -1, -1},
    {-1, -1, -1, -1}
};
// 标记是否满足特定条件
bool f;

// 处理九宫格中相同数字对的函数
int p1() {
    // 记录生成的新字符数量
    int n = 0;
    // 初始化计数数组
    memset(c, 0, sizeof(c));
    // 统计九宫格中每个数字出现的次数
    for (int x = 1; x <= 3; x++) {
        for (int y = 1; y <= 3; y++) {
            if (g[x][y] != -1) {
                c[g[x][y]]++;
            }
        }
    }
    // 遍历每个数字
    for (int x = 0; x < 10; x++) {
        if (c[x] < 2) continue;
        // 计算该数字可组成的对数
        int t = c[x] / 2 * 2;
        // 累加生成的新字符数量
        n += c[x] / 2;
        // 更新该数字剩余的数量
        c[x] %= 2;
        // 从九宫格中移除组成对的数字
        for (int y = 1; y <= 3; y++) {
            for (int z = 1; z <= 3; z++) {
                if (g[y][z] == x) {
                    g[y][z] = -1;
                    if (--t == 0) break;
                }
            }
            if (t < 1) break;
        }
    }
    return n;
}

// 处理九宫格全空的特殊情况的函数
int p2() {
    // 标记九宫格是否全空
    bool e = true;
    for (int x = 1; x <= 3; x++) {
        if (g[x][1] != -1 || g[x][2] != -1 || g[x][3] != -1) {
            e = false;
        }
    }
    // 如果满足特定条件且九宫格全空
    if (f && e) {
        return 8;
    }
    return 0;
}

// 处理九宫格无重复数字的特殊情况的函数
int p3() {
    // 标记九宫格是否有空位
    bool e = false;
    for (int x = 1; x <= 3; x++) {
        for (int y = 1; y <= 3; y++) {
            if (g[x][y] == -1) {
                e = true;
            }
        }
    }
    // 如果有空位，直接返回 0
    if (e) return 0;
    // 重新初始化计数数组
    memset(c, 0, sizeof(c));
    // 统计九宫格中每个数字出现的次数
    for (int x = 1; x <= 3; x++) {
        for (int y = 1; y <= 3; y++) {
            if (g[x][y] != -1) {
                c[g[x][y]]++;
            }
        }
    }
    // 标记九宫格中的数字是否都唯一
    bool u = true;
    for (int x = 0; x < 10; x++) {
        if (c[x] > 1) {
            u = false;
            break;
        }
    }
    // 如果数字都唯一
    if (u) {
        // 清空九宫格
        for (int x = 1; x <= 3; x++) {
            for (int y = 1; y <= 3; y++) {
                g[x][y] = -1;
            }
        }
        return 10;
    }
    return 0;
}

int main() {
    // 输入字符串
    cin >> s;
    // 输入初始购买的字符数量
    scanf("%d", &b);
    // 初始购买字符添加到可用字符中
    for (int x = 0; x < b; x++) {
        w += s[i++];
    }
    while (1) {
        // 标记本轮是否有变化
        bool ch = false;
        // 可用字符的索引
        int j = -1;
        // 可用字符的长度
        int l = w.size();
        // 填充九宫格
        for (int x = 1; x <= 3; x++) {
            for (int y = 1; y <= 3; y++) {
                if (g[x][y] == -1 && j + 1 < l) {
                    g[x][y] = w[++j] - '0';
                }
            }
        }
        // 移除已使用的可用字符
        w.erase(0, j + 1);
        // 调用 p1 函数处理相同数字对
        int r = p1();
        if (r) {
            f = true;
            ch = true;
            // 生成新的可用字符
            for (int x = 1; x <= r; x++) {
                w += s[i++];
            }
            // 累加结果
            a += r;
        }
        // 调用 p2 函数处理全空情况
        r = p2();
        if (r) {
            ch = true;
            // 生成新的可用字符
            for (int x = 1; x <= r; x++) {
                w += s[i++];
            }
            // 累加结果
            a += r;
        }
        // 调用 p3 函数处理无重复数字情况
        r = p3();
        if (r) {
            ch = true;
            // 生成新的可用字符
            for (int x = 1; x <= r; x++) {
                w += s[i++];
            }
            // 累加结果
            a += r;
        }
        // 如果本轮没有变化，退出循环
        if (!ch) break;
    }
    // 输出最终结果
    printf("%d", a + b);
    return 0;
}
```

---

## 作者：stardusts (赞：1)

大模拟，考察代码能力，注释见代码。

```cpp
#include <iostream>
#include <vector>
#include <deque>
#include <unordered_set>
#include <unordered_map>
#include <algorithm>
using namespace std;
// 检查条件3：9宫格满且颜色各不相同
bool check3(const vector<char>& g) {
    for(char c:g) if(c==-1) return false;  // 有空位不满足
    unordered_set<char> s;
    for(char c:g) if(s.count(c)) return false; else s.insert(c);  // 有重复颜色不满足
    return true;
}
// 检查条件1：存在至少一对相同颜色
bool check1(const vector<char>& g) {
    unordered_map<char,int> cnt;
    for(char c:g) {
        if(c==-1) continue;  // 跳过空位
        cnt[c]++;
        if(cnt[c]>=2) return true;  // 找到重复颜色
    }
    return false;
}
int main() {
    string s;  // 盲盒序列
    int a;     // 购买数量
    cin>>s>>a;  // 读取输入
    deque<char> q;  // 未拆开的盲盒队列
    for(int i=0;i<a;i++) q.push_back(s[i]);  // 初始化购买的前a个盲盒
    int giv=0;  // 已赠送的盲盒数
    int res=0;  // 最终获得的乌龟数
    vector<char> grid(9,-1);  // 9宫格，-1表示空位
    while(true) {
        // 环节3：填充9宫格空位
        for(int i=0;i<9;i++) 
            if(grid[i]==-1&&!q.empty()) {  // 有空位且还有盲盒
                grid[i]=q.front();  // 放入乌龟
                q.pop_front();     // 移除已拆盲盒
            }
        int add=0;  // 本次要赠送的盲盒数
        if(check3(grid)) {  // 满足条件3
            res+=9;         // 获得9只乌龟
            add=10;         // 赠送10个盲盒
            fill(grid.begin(),grid.end(),-1);  // 清空9宫格
        } else {
            bool c1=check1(grid);  // 检查条件1
            if(c1) {  // 满足条件1
                unordered_map<char,int> cnt;
                for(char c:grid) if(c!=-1) cnt[c]++;  // 统计每种颜色数量
                int x=0;  // 成对的数量
                for(auto& p:cnt) x+=p.second/2;
                res+=2*x;  // 获得成对的乌龟
                // 处理剩余单只乌龟
                vector<char> rem;
                for(auto& p:cnt) if(p.second%2) rem.push_back(p.first);
                sort(rem.begin(),rem.end());  // 排序保证顺序
                fill(grid.begin(),grid.end(),-1);  // 清空9宫格
                for(int i=0;i<rem.size()&&i<9;i++) grid[i]=rem[i];  // 重新放入单只乌龟
                // 检查是否清台(条件2)
                bool c2=true;
                for(int i=0;i<9;i++) if(grid[i]!=-1) {c2=false; break;}
                if(c2) add=x+8;  // 满足条件2额外加8
                else add=x;       // 只赠送成对数
            } else {  // 不满足任何条件
                int c=0;
                for(char x:grid) if(x!=-1) c++;  // 统计乌龟数
                res+=c;  // 获得所有乌龟
                add=0;   // 不赠送
                fill(grid.begin(),grid.end(),-1);  // 清空9宫格
            }
        }
        // 环节2：添加赠送盲盒
        if(add>0) {
            int st=a+giv;  // 赠送起始位置
            int ed=st+add; // 赠送结束位置
            for(int i=st;i<ed;i++) if(i<s.size()) q.push_back(s[i]);  // 添加盲盒
            giv+=add;  // 更新已赠送数
        }
        // 检查是否结束：9宫格为空且无剩余盲盒
        bool empty=true;
        for(int i=0;i<9;i++) if(grid[i]!=-1) {empty=false; break;}
        if(empty&&q.empty()) break;
    }
    cout<<res<<endl;  // 输出结果
    return 0;
}
```

---


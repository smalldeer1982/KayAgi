# [常州市赛 2022] 迷宫探险

## 题目背景

搬运自 <http://czoj.com.cn/p/459>。数据为民间数据。



## 题目描述

完成了俱乐部可人老师布置的命题任务，小 $\text{X}$ 决定和朋友们玩一款探险类游戏放松一下心情。

这个游戏的场景是在一个地下迷宫中，这个迷宫由 $N \times N$ 的网格构成，小 $\text{X}$ 和他的 朋友们每人占据一个格子，他们每人带领一支探险队。每一分钟小 $\text{X}$ 会让他的探险队员从上下左右四个方向前往相邻的格子（只要相邻的格子不是障碍物），同时他的朋友们也会跟小 $\text{X}$ 一样做相同的操作。迷宫中有些格子是空的，而有些格子有自动计分器，最早到达这个格子的队员所属的玩家会得到 $1$ 分，然后这个自动计分器会消失，即之后到达这个格子就不会获得分数，如果有多个玩家的队员同时到达有自动计分器的格子，那么这些玩家都能得到 $1$ 分。

现在小 $\text{X}$ 想知道得分最多的玩家得到了多少分，以及所有玩家一共得到了多少分。你可以认为每位玩家的手下都有足够多的探险队员。

## 说明/提示

### 样例解释
在第一分钟，位于 $(1,1)$ 的玩家派出的探险队员到达 $(1,2)$ 得到 $1$ 分，位于 $(3,3)$ 的玩家派出 的探险队员到达 $(3,2)$ 得到 $1$ 分。在第二分钟，两位玩家派出的探险队员同时到达 $(2,2)$，各得 $1$ 分，之后即使游戏再进行下去也没有意义了，因为他们不可能再得到任何分数。得分最多的玩家得到的分数为 $2$ 分，所有玩家一共得到了 $4$ 分。

### 数据规模与约定

对于所有数据，$1\le N\le 100$，玩家的数量 $≤10$。

| 测试点编号 | $N$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $\le 10$ | 只有一个玩家 |
| $2$ | $\le 10$ | 只有一个得分点 |
| $3\sim 5$ | $\le 10$ | 无 |
| $6\sim 8$ | $\le 50$ | 无 |
| $9\sim 10$ | $\le 100$ | 无 |

## 样例 #1

### 输入

```
3
@$#
#$#
#$@```

### 输出

```
2
4```

# 题解

## 作者：CJR_Rain (赞：1)

## Solution

大体思路就是将所有起点 `@` 的坐标入队，然后进行 BFS 洪水填充，在洪水填充的过程中计数，最后求出最大值与和。具体解法不太好直接讲，需要结合代码，请看代码里的注释：

## Code

```cpp
#include <bits/stdc++.h>

#define IS std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define OS std::cout.tie(nullptr) -> std::ios::sync_with_stdio(false)

using namespace std;

struct node {
    
    int row, col, id;
    //这里是 BFS 队列元素的类型，row 代表第几行，col 代表第几列，id 则是代表这个点属于第几个玩家。(因为使用函数实现洪水填充所以没有代表当前时间的变量)
};

struct visited {

    int step = INT_MAX;//注意step初始设为极大值
    bitset <15> vis_id;
    /*
    众所周知，BFS 都需要一个vis数组用来防止一个点被重复访问。然而这题比较特殊，所以需要专门开一个结构体给 vis 数组。

    step 元素用处：
    因为同一时间如果有多个人到达某个点，他们都会获得分数，所以 vis 数组需要一个 step 变量来记录最早到达这里的人到达这里的时间。
    如果 step 的值小于当前时间(不是小于等于)，那么该点就不能访问，因为访问了也没用。否则就将 step 设为当前时间并可以访问。

    vis_id 元素用处：
    对于(1, 0)和(0, 1)这两个点，他们在下一时间单位都可以访问(1, 1)，那么这两个点的拥有者就会获得 2 分。
    但是很明显，对于每个点，每个人只能获得一分，即使是在同一时间单位访问的该点。
    所以 vis_id 的作用就是存储每个到达该点的人的编号，即使是在同一时间，如果该点已经被编号相同的人访问过，那么依旧不能访问。
    */
};

int n, go_row[4] = {1, 0, -1, 0}, go_col[4] = {0, 1, 0, -1}, cnt = 0, ans[15];
//n：行数。
//go_row 和 go_col：BFS 必需品，用来计算下一个点的坐标。
//cnt：暂且按下不表，需要结合下面的代码来理解。
//ans：对于编号为 i 的人，ans[i]就是他的得分。

string maze[105];
//maze：地图。

queue <node> bfs;
//朴素的 BFS 队列。

visited vis[105][105];
//vis数组存储每个点的状态。

void flood(int len, int step) {//len 代表第 step - 1 时间单位时 BFS 队列的长度，step 代表走出这一步后是第几时间单位。

    while(len-- != 0) {//访问第 step - 1 时间单位时 BFS 队列里的所有元素。

        node front = bfs.front();
        bfs.pop();

        for(int i = 0; i < 4; ++i) {

            int next_row = front.row + go_row[i], next_col = front.col + go_col[i];//获取下一个点的坐标。

            if(next_row < 0 || next_row >= n || next_col < 0 || next_col >= n || maze[next_row][next_col] == '#') {
                //如果下一个点出界或因地形无法访问：
                continue;
            }

            if(vis[next_row][next_col].step < step || vis[next_row][next_col].vis_id[front.id] == true) {
                //如果下一个点的 step 的值小于走出这一步后的时间单位 或 下一个点已经被同一个人访问过：
                continue;
            }

            if(maze[next_row][next_col] == '$') {//如果下一个点会爆金币：

                ++ans[front.id];//这么费劲给玩家安排编号就是为了这个，这样统计时才不会弄混。
            }

            vis[next_row][next_col].step = step;//将下一个点的 step 设为走出这一步后的时间单位。
            vis[next_row][next_col].vis_id[front.id] = true;//标记下一个点的 vis_id 数组。

            bfs.push({next_row, next_col, front.id});//将下一个点入队，并将编号遗传下去。
        }
    }

    if(bfs.empty() == false) {//如果 BFS 队列里还有元素，那么继续进行洪水填充：

        flood(bfs.size(), step + 1);//递归实现。
    }

    return;
}

signed main() {

    IS;
    OS;
    
    cin >> n;
    
    for(int i = 0; i < n; ++i) {

        cin >> maze[i];

        for(int t = 0; t < n; ++t) {

            if(maze[i][t] == '@') {//如果该点为起点：
                
                vis[i][t].step = 0;
                vis[i][t].vis_id[cnt] = true;
                //初始化 vis 数组。

                bfs.push({i, t, cnt++});
                //将该点入队。可见，cnt 是该点插入前已经搜索到的起点的个数，同时将该值作为此时入队的点的编号。
            }
        }
    }

    flood(bfs.size(), 1);//开始洪水填充。

    cout << *max_element(ans, ans + cnt) << '\n' << accumulate(ans, ans + cnt, 0);
    //可以发现，搜索完所有起点后 cnt 等于起点的数量，因此可以这么写。
    
    return 0;
}
```

---


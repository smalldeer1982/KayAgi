# [常州市赛 2024] 密码

## 题目背景

搬运自 <http://czoj.com.cn/p/952>。数据为民间数据。

## 题目描述

小 Y 发现了一个密码，这个密码的初始形式排列成了 $n\times n$ 的矩阵的形式。小 Y 需要首先按照蛇形矩阵的方式解读这个密码，如下图所示，从第一行第一个字符开始，第一步向右走，然后向左下方走到边界，接下去沿着边界走一步（可能向下可能向右），再向右上方走到边界，接下去沿着边界走一步（可能向下可能向右）……不断重复这个过程直到走到第 $n$ 行的第 $n$ 列停止。

![](https://cdn.luogu.com.cn/upload/image_hosting/meopj1yd.png)

小 Y 把走过路径的字符串起来，就得到了一个长度为 $n\times n$ 的字符串 $\tt THISISAVERYGOODPOEMITHINK$，这是密码的中间形式，而小 Y 需要把这个密码排列成最终形式，最终形式是把这个中间形式的密码按照螺旋矩阵的方式填入一个 $n\times n$ 的矩形中，如下图所示，从第一行第一个字符开始，第一步开始一直向右走直到碰到边界或是已有字符 ，再向下走到边界或已有字符，再向左走到边界或已有字符，再向上走到边界或已有字符……不断重复这个过程直到无路可走停止。


![](https://cdn.luogu.com.cn/upload/image_hosting/wcb1pbkq.png)

每走一步就往当前位置中填入一个密码中间形式字符串中的字符，就得到了密码的最终形式。

现在给出密码的初始形式，小 Y 想让你告诉他密码的最终形式。

## 说明/提示

对于所有数据，$1\le n\le 500$，字符均为大写字母。

|测试点编号|$n$|特殊性质|
|:-:|:-:|:-:|
|$1\sim3$|$\le 2$|无|
|$4$|$\le100$|$\alpha$|
|$5\sim7$|$\le 5$|无|
|$8\sim10$|$\le500$|无|
- 特殊性质 $\alpha$：保证矩阵中的所有字符完全相同。

## 样例 #1

### 输入

```
2
AB
CD```

### 输出

```
AB
DC```

## 样例 #2

### 输入

```
4
ABCD
EFGH
IJKL
MNOP```

### 输出

```
ABEI
KHLF
NPOC
MJGD```

## 样例 #3

### 输入

```
5
THSAD
IIVOP
SEOOH
RGETI
YMINK```

### 输出

```
THISI
POEMS
DNKIA
OIHTV
OGYRE```

# 题解

## 作者：sfb1363II (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/B4226)

## Solution

这题我的思路是，首先用 $ch1$ 数组来存储蛇形矩阵，然后用 $ch2$ 数组在 $ch1$ 数组的基础上生成螺旋矩阵，最后输出 $ch2$ 数组。

## Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=510;
int n,i,j,d;
char a[N][N];
char ch1[N][N];
char ch2[N][N];
const int di[4]={0,1,0,-1};
const int dj[4]={1,0,-1,0};
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>a[i][j];
    //蛇形遍历生成中间形式 ch1
    i=1;j=1;d=1;
    for(int x=1;x<=n;x++){
        for(int y=1;y<=n;y++){
            ch1[x][y]=a[i][j];
            i-=d;j+=d;
            if(j>n){
                j=n;
                i+=2;
                d=-d;
            }
            else if(i>n){
                i=n;
                j+=2;
                d=-d;
            }
            else if(i<1){
                i=1;
                d=-d;
            }
            else if(j<1){
                j=1;
                d=-d;
            }
        }
    }
    //螺旋遍历填入最终形式 ch2
    d=0;//0:右,1:下,2:左,3:上
    int cnt=1;
    int left=1,right=n,up=1,down=n;
    while(left<=right&&up<=down){
        if(d==0){
            for(int i=left;i<=right;i++){
                ch2[up][i]=ch1[(cnt-1)/n+1][(cnt-1)%n+1];
                cnt++;
            }
            up++;
        }
        else if(d==1){
            for(int i=up;i<=down;i++){
                ch2[i][right]=ch1[(cnt-1)/n+1][(cnt-1)%n+1];
                cnt++;
            }
            right--;
        }
        else if(d==2){
            for(int i=right;i>=left;i--){
                ch2[down][i]=ch1[(cnt-1)/n+1][(cnt-1)%n+1];
                cnt++;
            }
            down--;
        }
        else if(d==3){
            for(int i=down;i>=up;i--){
                ch2[i][left]=ch1[(cnt-1)/n+1][(cnt-1)%n+1];
                cnt++;
            }
            left++;
        }
        d=(d+1)%4;
    }
    //输出最终形式 ch2
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++)
            cout<<ch2[i][j];
        cout<<"\n";
    }
    return 0;
}
```

---

## 作者：HanSF (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/B4226)
很模版的一道题啊，先通过**蛇形矩阵**把它转化成**一条链**，在使用**螺旋矩阵**，最后输出答案。  

~~求管理员大大通过。~~  
其余细节写在代码注释里了。
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};//定义方向数组
char a[505][505],b[250005],c[505][505];//b数组为链
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];  //读入
        }
    }
    int i=1,j=1,f=1;//定义坐标和方向变量
    for(int k=1;k<=n*n;k++){
        b[k]=a[i][j];
        i-=f,j+=f;//每回更新坐标
        if(j>n) j=n,i+=2,f=-f;//如果j大于n，i增加2，j变回n，更改方向
        else if(i>n) i=n,j+=2,f=-f;//如果i大于n，j增加2，i变回n，更改方向
        else if(i<1) i=1,f=-f;//如果i小于n，i变回1，更改方向
        else if(j<1) j=1,f=-f;//如果j小于1，j变回1，更改方向
        //注意顺序不能改
    }//蛇形矩阵
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            c[i][j] = '@';//初始化
        }
    }
    c[1][n+1] = '!';//方便判角
    c[n+1][n] = '!';//方便判角
    c[0][n] = '!';//方便判角
    i = 1,j = 1,f = 0;//重置坐标
    for(int k=1;k<=n*n;k++){
        c[i][j] = b[k];//赋值
        if(c[i+dx[f]][j+dy[f]]=='!'||c[i+dx[f]][j+dy[f]]!='@') f = (f+1)%4;//更新方向数组的索引。
        i+=dx[f],j+=dy[f];//更新坐标
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cout<<c[i][j];//输出
        }
        cout<<'\n';
    }
    return 0;//华丽结束
}
```

---

## 作者：czxuyang (赞：2)

## 思路：
这一道题其实就是一个模版题，也就是蛇形矩阵与螺旋矩阵的结合，用两个数组存储起来，然后输出


---


### 处理蛇形矩阵：
#### 1.遍历对角线：
 矩阵 $n  \times n$ 共有 $2n - 1$ 条对角线（从左上到右下）。通过 $i$ 从 $1$ 到 $2n - 1$ 遍历所有对角线。
  
#### 2.确定对角线上的元素索引：
 $l$ 代表行索引，初始为 $1$。    
 $h$ 代表列索引，初始为 $i$，然后逐步递减，$l$ 递增。      
  继续遍历，直到 $h < 1$（对角线遍历完）。     
 需要判断 $(l, h)$ 是否在矩阵范围内 $1 \le l \le n$ 且 $1 \le h \le n$，防止越界。
  
#### 3.填充顺序：
奇数对角线 $i \bmod 2 \ne 0$：从右上到左下填充
 
```cpp
b[k++] = a[h][l]
```

偶数对角线 $i \bmod 2 = 0$：从左下到右上填充

```cpp
b[k++] = a[l][h]
```
#### 4.更新索引
列索引递减，行索引递增

---


### 处理螺旋矩阵：
#### 1.初始化矩阵：
创建一个大小为 $n \times n$ 的矩阵，初始化所有元素为 $0$。

#### 2.定义边界：
在判断语句中判断下一步是否出界或遇到已经处理的字母，如果是则转向

#### 3.顺时针填充矩阵：
使用循环，按照从左到右、从上到下、从右到左、从下到上的顺序填充矩阵。

#### 4.重复步骤 2 和 3：
循环执行步骤 $2$ 和 $3$ ，直到矩阵填充完成。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[505][505],b[251000],c[505][505];
int dx[4]={0,1,0,-1};//方向数组，遍历上下左右
int dy[4]={1,0,-1,0};
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int n,k=1;
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=2*n-1;i++){//遍历对角线的索引，i从1到2*n-1
		int l=1,h=i;//l和h分别是行和列的索引
		while(h>=1){ //处理对角线上的所有元素
			if(l<=n && h<=n){ //确保索引在矩阵范围内
				if(i%2!=0){ //根据对角线的奇偶性决定填充方向
					b[k++]=a[h][l];//奇数对角线，从上到下填充
				} 
				else b[k++]=a[l][h];//偶数对角线，从下到上填充
			}
			h--;//列索引减少
			l++;//行索引增加
		}
	} 
	int x=1,y=1,d=0;
	for(int i=1;i<=n*n;i++){
		c[x][y]=b[i];//记录数组
		int tx=x+dx[d],ty=y+dy[d];//预处理下一个方位
		if(tx<1||ty<1||tx>n||ty>n||c[tx][ty]) d=(d+1)%4;//如果出界或遇到了之前的字母便转向
		x+=dx[d];//x,y更新
		y+=dy[d];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<c[i][j];//输出
		}
		cout<<endl;
	}
	return 0;
}

```

---

## 作者：beicige (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4226)

# **题意**
给出一个 $n \times n$ 的方阵，按照蛇形的方式，遍历这个方阵。得到结果的字符串后，将其以螺旋矩阵的方式填回 $n \times n$ 的方阵。

# **思路**
很明显，题目可以直接模拟。

只需要先用蛇形矩阵的方法，将读取到的字符串存储，最后再以螺旋矩阵的方式填回。

所以就是一道蛇形加螺旋方阵的题目。
先看蛇形方阵的实现。其中  $s$  为存储字符串的字符数组。


```cpp
//读取蛇形方阵 
int x=1,y=1;
s[k++]=a[1][1]; 
while(1){
    //从左下方向至右上方向
	if(x==1&&y!=n) y++;
	else x++;
	s[k++]=a[x][y];
	while(y!=1&&x!=n){
		x++,y--;
		s[k++]=a[x][y];
	}
    //从右上方向到左下方向
	if(y==1&&x!=n) x++;
	else y++;
	s[k++]=a[x][y];
	if(k==n*n){
		break;
	}
	while(x!=1&&y!=n){
		x--,y++;
		s[k++]=a[x][y];
	}
}
```
用 $x,y$ 两个变量存储当前的下标。蛇形方阵的遍历可以化为从左下方向至右上方向；和从右上方向到左下方向这两个部分。

用两个判断语句确定两种方向的出发点，并特判左下和右上两处，因为这两处可能会发生数组越界。

因为所有蛇形方阵，都是以从右上到左下结尾，所以在这部分代码后判断退出。

再看存储至螺旋方阵的代码。


```cpp
//清空
for(int i=1;i<=n;i++){
	for(int j=1;j<=n;j++){
		a[i][j]='/'; 
	} 
} 
//填入回旋方阵 	
k=0,x=1,y=0;
int t=10;
while(k!=n*n)
{
	while(y<=n&&a[x][y+1]=='/')a[x][++y]=s[k++];
	while(x<=n&&a[x+1][y]=='/')a[++x][y]=s[k++];
	while(y>=1&&a[x][y-1]=='/')a[x][--y]=s[k++];
	while(x>=1&&a[x-1][y]=='/')a[--x][y]=s[k++];
}
```

这里可以先清空原有数组的内容，便于后面填充，当然也可以重新开一个数组存储。

用 $k$ 存储当前在字符数组的下标，注意从 $0$ 开始，while语句的条件判断是否填充至最后一个字符。

然后结合两段代码，加入输入及输出即可。

# Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f=1;
char a[510][510],s[250010];
int main(){
	//读入 
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	//读取蛇形方阵 
	int x=1,y=1;
	s[k++]=a[1][1]; 
	while(1){
		if(x==1&&y!=n) y++;
		else x++;
		s[k++]=a[x][y];
		while(y!=1&&x!=n){
			x++,y--;
			s[k++]=a[x][y];
		}
		if(y==1&&x!=n) x++;
		else y++;
		s[k++]=a[x][y];
		if(k==n*n){
			break;
		}
		while(x!=1&&y!=n){
			x--,y++;
			s[k++]=a[x][y];
		}
	}
	//清空
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j]='/'; 
		} 
	} 
	//填入回旋方阵 	
	k=0,x=1,y=0;
	int t=10;
	while(t--)
	{
		while(y<=n&&a[x][y+1]=='/')a[x][++y]=s[k++];
		while(x<=n&&a[x+1][y]=='/')a[++x][y]=s[k++];
		while(y>=1&&a[x][y-1]=='/')a[x][--y]=s[k++];
		while(x>=1&&a[x-1][y]=='/')a[--x][y]=s[k++];
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<a[i][j]; 
		} 
		cout<<endl;
	} 
	return 0;
} 
```

---

## 作者：guoshengyu1231 (赞：1)

## 初步思考
纯模拟，没啥好思考的。。。
## 具体步骤
根据题意，首先按照蛇形矩阵的方式遍历初始矩阵，接着再将遍历得到的序列按照螺旋矩阵的方式填入一个  $n\times n$  的矩形。
### 遍历初始矩阵
![](https://cdn.luogu.com.cn/upload/image_hosting/meopj1yd.png)
 $\\$ 
仔细看图我们可以发现，遍历矩阵的方式为“右→左下→下→右上”这样循环往复，直到矩阵的对角线。此时分两种情况： $\\$ 
1.  $n$ 为奇数，此时遍历对角线的方式为“下→右上→下”，之后以“左下→右→右上→下”这样的方式循环往复。
2.  $n$ 为偶数，此时遍历对角线的方式为“右→左下→右”，之后以“右上→下→左下→右”这样的方式循环往复。 $\\$
   
#### 代码如下：
```cpp
void f1(){s[++k]=a[x][++y];}//右 
void f2(){s[++k]=a[++x][y];}//下 
void get1(int n){while(n--) s[++k]=a[--x][++y];}//右上 
void get2(int n){while(n--) s[++k]=a[++x][--y];}//左下
```

```cpp
s[1]=a[1][1];
for(int i=1;i<=n-2;i++)
 if(i&1) {f1();get2(i);}
    else {f2();get1(i);}
	    
if(n&1)  {f2();get1(n-1);f2();}
   else  {f1();get2(n-1);f1();}
	    
for(int i=n-2;i;i--)
 if(i&1) {get2(i);f1();}
    else {get1(i);f2();}
```

### 填充螺旋矩阵
![](https://cdn.luogu.com.cn/upload/image_hosting/wcb1pbkq.png) $\\$ 
仔细看图我们可以发现，只要没有碰到边界或是没有遇到被占用的格子，就一直往这个方向走，否则换一个方向。
#### 代码如下：

```cpp
const int fx[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//方向:右，下，左，上
```

```cpp
void go(int i)
{
	int nx=x+fx[d][0];
	int ny=y+fx[d][1];
	if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!vis[nx][ny])
	 {
		x=nx;y=ny;
		a[x][y]=s[i];
		vis[x][y]=true;	
	 }
	else
	 {
		d=(d+1)%4;
		go(i);	
	 }
} 
```

```cpp
x=1;y=0;
for(int i=1;i<=k;i++) go(i);
```
最后输出就完事了。
## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=505;
const int fx[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//方向:右，下，左，上 
char s[maxn*maxn];
char a[maxn][maxn];
bool vis[maxn][maxn];
int n,x=1,y=1,k=1,d=0;
void f1(){s[++k]=a[x][++y];}//右 
void f2(){s[++k]=a[++x][y];}//下 
void get1(int n){while(n--) s[++k]=a[--x][++y];}//右上 
void get2(int n){while(n--) s[++k]=a[++x][--y];}//左下
void go(int i)
{
	int nx=x+fx[d][0];
	int ny=y+fx[d][1];
	if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&!vis[nx][ny])
	 {
		x=nx;y=ny;
		a[x][y]=s[i];
		vis[x][y]=true;	
	 }
	else
	 {
		d=(d+1)%4;
		go(i);	
	 }
} 
void read()
{
	cin>>n;
	if(n==1)//特判
	 {
		char c;
		cin>>c;
		cout<<c;
		exit(0);
	 }
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
}
void solve()
{
	s[1]=a[1][1];
	for(int i=1;i<=n-2;i++)
	 if(i&1) {f1();get2(i);}
	    else {f2();get1(i);}
	    
	if(n&1)  {f2();get1(n-1);f2();}
	   else  {f1();get2(n-1);f1();}
	    
	for(int i=n-2;i;i--)
	 if(i&1) {get2(i);f1();}
	    else {get1(i);f2();}
	
	x=1;y=0;
	for(int i=1;i<=k;i++) go(i);
}
void write()
{
	for(int i=1;i<=n;i++) printf("%s\n",a[i]+1);
}
int main()
{
	read();
	solve();
	write();
	return 0;
}
```

---

## 作者：zhuoqizhi (赞：0)

# 题目解析
先把输入进来的数组蛇形方阵遍历 $1$ 遍，把得到的字符串再按螺旋方阵输出。
# 解法
先输入 $n \times n$ 的矩阵，然后按题意模拟。
## 蛇形方阵实现
先定义 $tag$ 确定方向，然后分讨。
当 `!(i==1&&j==n)` 时。

```cpp
while(!(i==1&&j==n)){
		if(tag==0){//右
			j++;
			mid+=num[i][j];
		}
		else if(tag==1){
			while(j!=1&&i!=n){//斜上
				
				i++;
				j--;
				mid+=num[i][j];
			}
		}
		else if(tag==2){//下
			
			i++;
			mid+=num[i][j];
		}
		else{
			while(i!=1&&j!=n){//斜下
				
				j++;
				i--;
				mid+=num[i][j];
			}
		}
		tag++;
		tag%=4;
	}
```
当 `!(i==n&&j==n)` 时。
```cpp
if(n%2){//奇数
		tag=0;
	}
	else{//偶数
		tag=1;
	}
	while(!(i==n&&j==n)){
		if(tag==0){
		
			i++;
			mid+=num[i][j];
		}
		if(tag==1){
			while(j!=1&&i!=n){
				
				i++;
				j--;
				mid+=num[i][j];
				
			}
		}
		else if(tag==2){
			j++;
			mid+=num[i][j];
		}
		else{
			while(i!=1&&j!=n){
				
				j++;
				i--;
				mid+=num[i][j];
			}
		}
		tag++;
		tag%=4;
	}
```

## 螺旋方阵实现
先确定方向数组 $x_i$ 和 $y_i$。
本题中 $x_i =\begin{Bmatrix}0,1,0,-1\end{Bmatrix}$，$y_i=\begin{Bmatrix}1,0,-1,0\end{Bmatrix}$。
1. 然后增加四个个变量，分别储存方向数组下标 $md$ 和现在取到第几个数 $cnt$（注意我是从 $0$ 开始的），还有当前 $x$ 坐标和 $y$ 坐标 $xx$ 和 $yy$。  
2. 接下来，每走一步就判断下一步是否合法，然后走下一步。
3. 如果合法，那么 $xx \gets xx+x_{md}$，$yy \gets yy+y_{md}$,$cnt \gets cnt+1$。  
4. 否则 $md \gets (md+1) \bmod 4$，$xx \gets xx+x_{md}$，$yy \gets yy+y_{md}$，$cnt \gets cnt+1$。  
5. 直到填完所有位置（$cnt=n \times n$）。
# Code
```cpp
#include<iostream>
#include<cstring>
#include<vector>
using namespace std;
int main(){
	int n;
	cin>>n;
	vector<vector<char>> num(n+1,vector<char>(n+1));
	vector<vector<int>> ans(n+1,vector<int>(n+1,-1));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>num[i][j];
		}
	}
	if(n==1){
		cout<<num[1][1];
	}
	int i=1,j=1;
	string mid;
	mid=num[1][1];
	int tag=0;
	while(!(i==1&&j==n)){
		if(tag==0){
			j++;
			mid+=num[i][j];
		}
		else if(tag==1){
			while(j!=1&&i!=n){
				
				i++;
				j--;
				mid+=num[i][j];
			}
		}
		else if(tag==2){
			
			i++;
			mid+=num[i][j];
		}
		else{
			while(i!=1&&j!=n){
				
				j++;
				i--;
				mid+=num[i][j];
			}
		}
		tag++;
		tag%=4;
	}
	if(n%2){
		tag=0;
	}
	else{
		tag=1;
	}
	while(!(i==n&&j==n)){
		if(tag==0){
		
			i++;
			mid+=num[i][j];
		}
		if(tag==1){
			while(j!=1&&i!=n){
				
				i++;
				j--;
				mid+=num[i][j];
				
			}
		}
		else if(tag==2){
			j++;
			mid+=num[i][j];
		}
		else{
			while(i!=1&&j!=n){
				
				j++;
				i--;
				mid+=num[i][j];
			}
		}
		tag++;
		tag%=4;
	}
	int cnt=0;
	int x[4]={0,1,0,-1},y[4]={1,0,-1,0};
	int md=0;
	int xx=1,yy=1;
	while(cnt<n*n){
		ans[xx][yy]=cnt;
		cnt++;
		int nx=xx+x[md],ny=yy+y[md];
		if(!(nx<=n&&ny<=n&&nx>=1&&ny>=1&&ans[nx][ny]==-1)){
			md++;
			md%=4;
			nx=xx+x[md];
			ny=yy+y[md];
		}
		xx=nx;
		yy=ny;
	}
	for(int li=1;li<=n;li++){
		for(int lj=1;lj<=n;lj++){
			cout<<mid[ans[li][lj]];
		}
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：Lacuna (赞：0)

模拟题。

#### 思路：

对于第一次操作，我们可以看作：先沿着边缘移动一次，之后向左下移动至边界，再沿边缘移动一次，再向右上移动至边界，之后重复这个过程，直到到达右下角。

对于第二次操作，我们定义一个方向数组，分别朝右下左上四个方向，用一个 $t$ 变量表示方向，每次到达边界后就换个方向，注意填过的地方不能再填，我们用 $vis$ 数组进行标记。

然后就做完了。

#### 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;

#define gc getchar
#define pc putchar
#define LL long long

const int N=505;
const int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};

int n;
char s[N][N];
vector<char> s1;
char s2[N][N]; 
bool vis[N][N];

inline LL read(){
  LL x=0,f=1;
  char ch=gc(); 
  while(!isdigit(ch)){
    if(ch=='-') f=-1;
	ch=gc();
  }
  while(isdigit(ch))
    x=(x<<1)+(x<<3)+ch-'0',ch=gc();
  return x*f;
}
inline void write_(LL x){
  if(x<0) x=-x,pc('-');
  if(x>9) write_(x/10);
  pc(x%10+'0');
}
inline void write(LL x){
  write_(x);
  pc('\n');
}

bool in(int x,int y){
  return 1<=x&&x<=n&&1<=y&&y<=n&&(!vis[x][y]);
}
void mian(){
  int x=1,y=1,t=0,i=0;
  s1.push_back(s[1][1]);
  for(;x<n||y<n;){
  	if((x==1||x==n)&&in(x,y+1)) y++;
	else if((y==1||y==n)&&in(x+1,y)) x++;
  	while(in(x,y)){
	  s1.push_back(s[x][y]);
	  x+=1,y-=1;
	}
	x-=1,y+=1;
    if((x==1||x==n)&&in(x,y+1)) y++;
	else if((y==1||y==n)&&in(x+1,y)) x++;
	while(in(x,y)){
	  s1.push_back(s[x][y]);
	  x-=1,y+=1;
	}
	x+=1,y-=1;
  } 
  x=1,y=1;
  s2[1][1]=s1[0];
  vis[1][1]=1;
  while(i<n*n){
    x+=dx[t],y+=dy[t];
    while(in(x,y)){
      s2[x][y]=s1[++i];
      vis[x][y]=1;
      x+=dx[t],y+=dy[t];
	}
	x-=dx[t],y-=dy[t]; 
	t++;
	if(t>4) t=0;
  }
  for(int i=1;i<=n;i++){
  	for(int j=1;j<=n;j++) pc(s2[i][j]);
  	pc('\n'); 
  }
}

int main(){
  n=read();
  for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
  mian();
  return 0;
}
```
时间复杂度 $O(n ^ 2)$。

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4226)

## 思路：

**按题意模拟**，将解密过程分为两步：

1. 将原码按蛇形矩阵方法转化为一个字符串。
2. 对他按螺旋矩阵格式输出。

既然是大模拟，那就来讲实现。

### 步骤一：

蛇形矩阵，我的方法好像比较怪，要分讨。

对于前 $\frac{x^2+x}{2}$ 个元素，发现它的总过程是两个连续分过程不断交替形成，即取完第一个和第二个数字后，先一直向左下角走，走不了了再向下走一格后再向右上走，走不了了再向右走一格后向左下走，以此往复。

模拟即可：


```cpp
int mqx=1,mqy=1,s=0,f=0;//f表示当前是哪一个分过程
	while(1){
		if(s==((x*x)-((x*(x-1))/2))) break;
		s++;
		ca[s]=m[mqx][mqy];
		if(f==0&&mqx==1){
		    f=1;
			mqy++;	
		}
		else if(f==1&&mqy==1){
			f=0;
			mqx++;
		}
		else if(f==1){
			mqx++;
			mqy--;
           //往左下走   
		}
		else if(f==0){
			mqx--;
			mqy++;
          //往右上走 
		} 
	}
```
接下来还要分两种，按 $x$ 的奇偶性分。

- $x \bmod 2 =1$ 时：结束上面的步骤后会在右上角的顶点，此时同样把总过程拆成两步，即先向左下走，在向右上走。

- $x \bmod 2 =0$ 时：同理，只是顺序变了，先向右上再向左下。

代码：

```cpp
if(x%2==1){
		mqx++;
		mqy=x;
		f=0;
		while(1){
			if(s==x*x) break;
			s++;
			ca[s]=m[mqx][mqy];
			if(f==0&&mqx==x){
				f=1;
				mqy++;
			}
			else if(f==1&&mqy==x){
				f=0;
				mqx++;
			}
			else if(f==0){
				mqx++;
				mqy--;
			}
			else if(f==1){
				mqy++;
				mqx--;
			}
		}
	}
	else{
		mqy=2;
		mqx=x;
		f=0;
		while(1){
			if(s==x*x) break;
			s++;
			ca[s]=m[mqx][mqy];
			if(f==0&&mqy==x){
				f=1;
				mqx++;
			}
			else if(f==1&&mqx==x){
				mqy++;
				f=0;
			}
			else if(f==0){
				mqx--;
				mqy++;
			}
			else if(f==1){
				mqx++;
				mqy--;
			}
		}
	}
```


### 步骤二：

直接预处理出 $n \times n$ 的蛇形数组，按照蛇形数组输出相应的字符即可：


```cpp
void ts(int n){
	int b,x=1,i=1;
	b=n*n;
	int y=n;
	while(i<=b){
        while(a[x][y]==0&&x<=n) {
        	a[x][y]=i;
        	x=x+1;
        	i=i+1;
		} 
		x=x-1;
		y=y-1;
		while(a[x][y]==0&&y>=1) {
        	a[x][y]=i;
        	y=y-1;
        	i=i+1;
		} 
		y=y+1;
		x=x-1;		
		while(a[x][y]==0&&x>=1) {
        	a[x][y]=i;
        	x=x-1;
        	i=i+1;
		} 
		x=x+1;
		y=y+1;
		while(a[x][y]==0&&y<=n) {
        	a[x][y]=i;
        	y=y+1;
        	i=i+1;
		} 
		y=y-1;
		x=x+1;
    }
}
```

```cpp
ts(x);
	for(int i=x;i>=1;i--){
		for(int j=1;j<=x;j++){
			cout<<ca[a[j][i]];
		}
		cout<<endl;
	}
```
其实这题没有什么细节。

## 完整代码：

不放了，把上面的拼到一起就行。

[通过记录](https://www.luogu.com.cn/record/211048372)

---


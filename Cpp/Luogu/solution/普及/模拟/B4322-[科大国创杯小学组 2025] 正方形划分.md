# [科大国创杯小学组 2025] 正方形划分

## 题目背景

Subtask 0 为民间数据，Subtask 1 为官方数据。

## 题目描述

小可可发明了一种新的正方形划分方法。

首先我们有一个正方形，我们称该图形为第 $0$ 轮的图形。我们将这个正方形均匀划分成 $4$ 个部分——左上、右上、左下和右下，分别将其编号为 $\tt{ABCD}$，称新的图形为第 $1$ 轮的图形。

![](https://cdn.luogu.com.cn/upload/image_hosting/5nh25r6b.png)

我们再将第一个图形所划分的每一个部分 $\tt{ABCD}$，分别再分成 $4$ 个部分，称新的图形为第 $2$ 轮的图形。对于该图形的每个部分的命名方式为该部分所属第 $1$ 轮的部分的编号 $+ \tt{ABCD}$。如：原来第 $1$ 轮的 $\tt A$ 部分的右上部分的编号为 $\tt{AB}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/p0ax055e.png)

第 $3$ 轮及以上的图形以此类推。这样每个方格都有一个编号，同时也有一个位置，即第几行（从上往下数）第几列
（从左往右数）。现在小可可想实现编号与其位置的相互转化，请你写一份程序帮帮他。

## 说明/提示

### 样例解释

第一行一个整数 $3$ 表示我们一共有三组测试数据。

第一组测试数据 $0 \ 1 \ 2 \ 1$，表示我们要将第 $1$ 轮图形的第 $2$ 行第 $1$ 列的位置转化为编号，根据题意描述中的图可知编号为 $\tt{C}$。

第二组测试数据 $1 \ \tt{AB}$，表示我们要求出编号为 $\tt{AB}$ 的格子的位置，根据题意描述中的图可知它在第 $2$ 轮第 $1$ 行第 $2$ 列。

第三组测试数据 $0 \ 2 \ 3 \ 4$，表示我们要将第 $2$ 轮图形的第 $3$ 行第 $4$ 列的位置转化为编号，根据题意描述中的图可知编号为 $\tt{DB}$。

### 约定和数据范围

- 数据点 $1$，$1 \leq T \leq 10$，$1 \leq n \leq 2$。
- 数据点 $2, 3$，$1 \leq T \leq 10$，$1 \leq n \leq 10$。
- 数据点 $4, 5$，$1 \leq T \leq 5 \times 10^4$，$n = 10$，即保证所有图形均为第 $10$ 轮图形。
- 数据点 $6$，$1 \leq T \leq 5 \times 10^4$，$1 \leq n \leq 30$，询问仅形如 $0$ $n$ $x$ $y$。
- 数据点 7，$1 \leq T \leq 5 \times 10^4$，$1 \leq n \leq 30$，询问仅形如 $1$ $str$。
- 数据点 $8 \sim 10$，$1 \leq T \leq 5 \times 10^4$，$1 \leq n \leq 30$。

## 样例 #1

### 输入

```
3
0 1 2 1
1 AB
0 2 3 4```

### 输出

```
C
2 1 2
DB```

# 题解

## 作者：Charles_with_wkc (赞：9)

# 思路
个人认为 $op = 1$ 非常简单，所以我们先讲 $op = 1$。
## $op = 1$
我这里考虑如下
![](https://cdn.luogu.com.cn/upload/image_hosting/rb47qlr9.png)
我们发现每有一个字母题目就会去掉 $\frac{3}{4} $ 的数据。我们一次分析 $4$ 种字母。这里我们定义 $4$ 个变量。
```cpp
int l1=1,l2=(1<<n),r1=1,r2=(1<<n);
```
这四个变量的作用是看这个 $str$ 在那个范围内，等我们搜完了以后，答案一定是 $l_1$ 和 $r_1$。（这里算到最后 $l_1 = l_2$，$r_1 = r_2$）  
我们还需要算一下，答案在第几轮，但是这个比较好算。我们这里定义 $str$ 长度为 $l$，那么 $str$ 在第 $l$ 轮出现，因为每次都会翻倍增长。  
至于，上面的 `1<<n` 这个是位运算，为 $2^n$。这里也清晰易懂，每轮都是翻倍增长的，所以，第 $n$ 轮，矩阵一定是 $2^n \times 2^n$ 大小的。  
这里定义一个特殊的变量 $pyl$ 意为偏移量。为什么需要这个变量下面会说。这你先说一下 $pyl$ 的变化，初始的时候 `pyl=1<<(n-1)` 因为，我这里不停的缩小答案范围，我们对于 $pyl$ 的初值，进行举例说明。（详细见下）我们 $pyl$ 每次都是要 $\div 2$ 的。（详细见下）
还用这个图。
![](https://cdn.luogu.com.cn/upload/image_hosting/rb47qlr9.png)
现在，我们检测到第一个字符为 $A$。我们知道如果第一个字母为 $A$，那么这个字符串，一定就在左上角。（如图）  
我们刚开始设置了 $4$ 个变量，是控制答案范围的。这里显然，$l_1$ 和 $r_1$ 都是对的，但是 $l_2$ 和 $r_2$ 需要调整。  
$r_2$ 在 $(1,4)$ 的位置，但是他应该在 $(1,2)$ 这里需要减 $2$。同理，$l_2$ 也需要减 $2$。（$2$ 怎么来的，见下文） 
比如，说我第 $2$ 个检测到了又检测到了 $A$，但是这次 $l_2$ 和 $r_2$ 都是需要减 $1$ 了。  
对比，两次举例，我们发现 $1 \times 2 = 2$，如果按照这个规律，第 $3$ 轮时，这里第一次应该减 $4$。（可以自己画图）  
根据以上的内容，我们容易发现在第 $i$ 层的时候自然就会减 $2^{i-1}$，这个就是我们前面定义的 $pyl$。  
总结一下。（以下 $s_i$ 表示 $str$ 的第 $i$ 个字符）  
当 $s_i$ 为 $A$ 时（如下）
```cpp
l2-=pyl
r2-=pyl
```
当 $s_i$ 为 $B$ 时（如下）
```cpp
l1+=pyl
r2-=pyl
```
当 $s_i$ 为 $C$ 时（如下）
```cpp
l2-=pyl
r1+=pyl
```
当 $s_i$ 为 $D$ 时（如下）
```cpp
l1+=pyl
r1+=pyl
```
恭喜你，$op = 1$ 正确了。
## $op = 2$
通过 $op =1$ 的思路，我们不难想出，可以将上面的反过来，然后暴力判断在那个范围内。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,x,y,l,nl1,nl2,nr1,nr2;
bool op,f;
string s;
void dfs1(long long id,long long l1,long long l2,long long r1,long long r2,long long pyl){
	if(f) return ;
	if(id==l){
		f=1;
		x=r1;
		y=l1;
		//我比较脑残写dfs1和dfs2的时候x和y写反了，将就看 
		//因为找到了以后l1=l2,r1=r2是一定的，所以无所谓 
		return ;
	}
	if(s[id]=='A') dfs1(id+1,l1,l2-pyl,r1,r2-pyl,pyl/2);
	else if(s[id]=='B') dfs1(id+1,l1+pyl,l2,r1,r2-pyl,pyl/2);
	else if(s[id]=='C') dfs1(id+1,l1,l2-pyl,r1+pyl,r2,pyl/2);
	else dfs1(id+1,l1+pyl,l2,r1+pyl,r2,pyl/2);
	return ;
}
void dfs2(long long id,long long l1,long long l2,long long r1,long long r2,long long pyl){
	if(f) return ;
	if(id==l){
		f=1;//找到了 
		return ;
	}
	//A
	nl1=l1;
	nl2=l2-pyl;
	nr1=r1;
	nr2=r2-pyl;
	if(nl1<=x&&x<=nl2&&nr1<=y&&y<=nr2){
		s+='A';
		dfs2(id+1,l1,l2-pyl,r1,r2-pyl,pyl/2);
	}
	//B
	nl1=l1+pyl;
	nl2=l2;
	nr1=r1;
	nr2=r2-pyl;
	if(nl1<=x&&x<=nl2&&nr1<=y&&y<=nr2){
		s+='B';
		dfs2(id+1,l1+pyl,l2,r1,r2-pyl,pyl/2);
	}
	//C
	nl1=l1;
	nl2=l2-pyl;
	nr1=r1+pyl;
	nr2=r2;
	if(nl1<=x&&x<=nl2&&nr1<=y&&y<=nr2){
		s+='C';
		dfs2(id+1,l1,l2-pyl,r1+pyl,r2,pyl/2);
	}
	//D 
	nl1=l1+pyl;
	nl2=l2;
	nr1=r1+pyl;
	nr2=r2;
	if(nl1<=x&&x<=nl2&&nr1<=y&&y<=nr2){
		s+='D';
		dfs2(id+1,l1+pyl,l2,r1+pyl,r2,pyl/2);
	}
	return ;
}
int main(){
	/*
	考场freopen 
	freopen("square.in","r",stdin);
	freopen("square.out","w",stdout);
	*/
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>op;
		if(op==1){
			cin>>s;
			l=s.size();
			cout<<l<<" ";
			f=0;
			dfs1(0,1,1<<l,1,1<<l,1<<(l-1));
			cout<<x<<" "<<y<<" "<<endl;
		}
		else{
			cin>>l>>x>>y;
			swap(x,y);
			//我比较脑残写dfs1和dfs2的时候x和y写反了，将就看 
			f=0;
			s="";
			//多测不清空，全WA等着哭 
			dfs2(0,1,1<<l,1,1<<l,1<<(l-1));
			cout<<s<<endl;
		}
	}
	return 0;
}
```

---

## 作者：haobao123456 (赞：5)

对于我来说，确实是一道好题（可能是我太菜了）。鄙人不才，请大佬轻喷 $QWQ$。
# 思路介绍：
这道题其实可以分为两部分，第一部分是 $op = 0$ 的情况，第二部分是 $op = 1$ 的情况。
## $op = 0$ 的情况：
可以用分治（递归）来做，通过打表可以得出第 $n$ 轮的图形其实就是四份第 $n-1$ 轮的图形，然后再各自加上 $A$，$B$，$C$，$D$。同样我们也可以求出第 $n$ 轮图形的长和宽为 $2^{n-1}$，所以我们就可以通过 $x$ 和 $y$，来确定第一个字母，然后在取模字符串长度，确定下一次答案在第 $n-1$ 轮的图形的位置，然后递归即可。

## $op = 1$ 的情况：
我们可以用一种类似于二分+递归的做法。当然，字符串长度也就表示是第几轮的图形。首先，我们可以通过第一个字母可以得出答案的大致位置，然后递归，依次类推，最终答案的 $x$ 和 $y$ 就会变成唯一的，这就是答案。然后，得要注意，缩小范围的时候不能直接赋值，得要减或者加。

# 代码展示：
得到思路之后，处理好一些细节就可以写出正确代码了。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
#define x first
#define y second
#define int ll
#define endl '\n'
#define IO ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
int t;
int op;
string funChar(int x,int y,int hang){ //对应op=0的操作。
	if(hang==1){ //直接返回。
		if(x==1&&y==1) return "A";
		if(x==1&&y==2) return "B";
		if(x==2&&y==1) return "C";
		if(x==2&&y==2) return "D";
	}
	string ans="";
	if(x<=hang&&y<=hang){
		ans="A";
	}
	if(x<=hang&&y>hang){
		ans="B";
	}
	if(x>hang&&y<=hang){
		ans="C";
	}
	if(x>hang&&y>hang){
		ans="D";
	}
	int mod1=x%hang;
	int mod2=y%hang;
	if(mod1==0) mod1=hang;
	if(mod2==0) mod2=hang;
	return ans+funChar(mod1,mod2,hang >> 1);
}
int ansx=0,ansy=0,xl=0,xr=0,yl=0,yr=0;
void funNum(string s,int hang,int n){ //对应op=1的操作。
	if(s.size()==1){ //直接返回。
		if(s[0]=='A') ansx=xl,ansy=yl; //赋值，保证最后答案唯一。
		if(s[0]=='B') ansx=xl,ansy=yr;
		if(s[0]=='C') ansx=xr,ansy=yl;
		if(s[0]=='D') ansx=xr,ansy=yr;
		return;
	}
	if(xl==0){
		if(s[0]=='A'){
			xl=1;
			xr=hang;
			yl=1;
			yr=hang;
		}else if(s[0]=='B'){
			xl=1;
			xr=hang;
			yl=hang+1;
			yr=(1 << n);
		}else if(s[0]=='C'){
			xl=hang+1;
			xr=(1 << n);
			yl=1;
			yr=hang;
		}else{
			xl=hang+1;
			xr=(1 << n);
			yl=hang+1;
			yr=(1 << n);
		}
	}else{
		if(s[0]=='A'){ //注意，不能直接赋值！！！
			xr=xr-hang;
			yr=yr-hang;
		}else if(s[0]=='B'){
			xr=xr-hang;
			yl=yl+hang;
		}else if(s[0]=='C'){
			xl=xl+hang;
			yr=yr-hang;
		}else if(s[0]=='D'){
			xl=xl+hang;
			yl=yl+hang;
		}
	}
	//~ cout<<xl<<" "<<xr<<" "<<yl<<" "<<yr<<endl;
	funNum(s.substr(1),hang >> 1,n);
}
signed main(){
//    freopen("square.in","r",stdin);
//    freopen("square.out","w",stdout);
    IO;
	cin>>t;
	while(t--){
		cin>>op;
		if(op==0){
			int n,x,y;
			cin>>n>>x>>y;
			int hang=(1 << (n-1)); //确定图形的长和宽。
			cout<<funChar(x,y,hang)<<endl;
		}else{
			string s;
			cin>>s;
			int n=s.size(); //表示第几轮图形。
			int hang=(1 << (n-1)); //表示图形的长和宽。
			ansx=0; //多测要清空！！！
			ansy=0;
			xl=xr=yl=yr=0;
			if(s=="A"){ //要特判只有一个字母的情况下！！！
				cout<<"1 1 1"<<endl;
			}else if(s=="B"){
				cout<<"1 1 2"<<endl;
			}else if(s=="C"){
				cout<<"1 2 1"<<endl;
			}else if(s=="D"){
				cout<<"1 2 2"<<endl;
			}else{
				funNum(s,hang,n);
				cout<<s.size()<<" "<<ansx<<" "<<ansy<<endl;
			}

		}
	}
    return 0;
}
```

---

## 作者：123ytq666 (赞：5)

令我伤心的一道题，具体文末再讲吧。

## 题目大意

[自己看，很好理解。](https://www.luogu.com.cn/problem/B4322)

## 题目解答

### 如果 $op = 0$

首先可以根据 $n$ 算出这个图形的面积 $k$。

然后我们给每个图形标出坐标。

![图一](https://cdn.luogu.com.cn/upload/image_hosting/a5z0x887.png)

如果是 ```B``` 或 ```D``` 区域，还要将他的基础 $x$ 坐标增加 $\sqrt{k} \div 2$。
如果是 ```C``` 或 ```D``` 区域，还要将他的基础 $y$ 坐标增加 $\sqrt{k} \div 2$。

然后再将 $k$ 除以 $4$，直到 $k = 1$。

### 如果 $op = 1$

比赛时，我先将所有字母分别按顺序转化为数字。

再用同样的方法计算出 $k$。

可以利用 $op = 0$ 的方法倒推即可。

### 重点/备注

$k$ 开一下```long long```。

$op = 0$ 的时候字符要清空！

本题解是按照赛时思路写的，有很多可以优化的地方，例如字符清空和 $k$，如有更简写法可自行修改。

### 赛时代码


```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
using namespace std;
char s[50];
int main(){
    //freopen("square7.in","r",stdin);
    //freopen("square.out","w",stdout);
    int T;
    cin>>T;
    for(int i=1;i<=T;i++){
        int m;
        cin>>m;
        for(int j=1;j<=40;j++)s[j]='\0';
        if(m==0){
            long long n,x,y;
            cin>>n>>x>>y;
            long long w=0,k=1;
            for(int f=1;f<=n;f++){
                k*=2;
            }
            k=k*k;
            long long yx=0,yy=0;
            while(n!=0){
                if(y-yy<=sqrt(k)/2){
                    if(x-yx<=sqrt(k)/2){
                        s[w]='A';
                    }else{
                        s[w]='C';
                        yx+=sqrt(k)/2;
                    }
                }else {
                    if(x-yx<=sqrt(k)/2){
                        s[w]='B';
                        yy+=sqrt(k)/2;
                    }else{
                        s[w]='D';
                        yx+=sqrt(k)/2;
                        yy+=sqrt(k)/2;
                    }
                }
                w++;
                k/=4;
                n--;
            }
            cout<<s<<endl;
        }
        else{
            string str;
            cin>>str;
            int lon=str.size();
            cout<<lon<<" ";
            string sz;
            for(int f=0;f<lon;f++){
                sz[f]=str[f]-'A'+'1';
            }
            long long k=1;
            for(int i=1;i<=lon;i++){
                k*=4;
            }
            long long j=0;
            long long a=1,h=1;
            while(k!=1){
                int w=sz[j]-'0';
                if(w==2||w==4)h+=sqrt(k)/2;
                if(w==3||w==4)a+=sqrt(k)/2;
                k/=4;
                j++;
            }
            cout<<a<<" "<<h<<endl;
        }
    }
    return 0;
}
```

### 回答一下开头的问题

为什么是伤心的题目？看一下这个就知道了。

```cpp
freopen("square7.in","r",stdin);
freopen("square.out","w",stdout);
```

拿到代码后我只把注释改掉了，剩下的一个也没改，懂的都懂。

---

## 作者：shaoxqy (赞：3)

由于本人编程技术不够精湛，所以以数学思维思考。
## 思路
我们观察可以发现，对于第 $n$ 级表格，它是一个边长为 $2^n$ 的正方形表格。

每一级都是在上一级的最小格子内，划分为 $2*2$ 的表格。

这么多 $2$ 让我想起二分法，于是本人的写法由此引申出来了。
## 第一种情况
分析：根据它所给的层数和坐标，输出这个格子的编号。

做法：我们从高到低逐级判断，只考虑该层 $2*2$ 表格的情况； $p$ 为这一级的权重。
1. 如果横坐标大于权重的一半，则说明其在右半表格。
2. 如果横坐标小于等于权重的一半，则说明其在左半表格。
3. 如果纵坐标大于权重的一半，则说明其在下半表格。
4. 如果纵坐标小于等于权重的一半，则说明其在上半表格。

综合一下：
1. 左上角，输出 A。
2. 右上角，输出 B。
3. 左下角，输出 C。
4. 右下角，输出 D。
```cpp
if(m==0){
			cin>>n>>x>>y;
			w=n;
			for(int i=1;i<=n;i++){
				p=f(2,w);//2的w次方 
				if(x%p==0){
					x=p;
				}
				else{
					x%=p;
				}
				if(y%p==0){
					y=p;
				}
				else{
					y%=p;
				}//预处理
				if(2*y<=p&2*x<=p){
					cout<<"A";
				}
				if(2*y>p&2*x<=p){
					cout<<"B";
				}
				if(2*y<=p&2*x>p){
					cout<<"C";
				}
				if(2*y>p&2*x>p){
					cout<<"D";
				}//输出
				w--;//判断下一级
			}
			cout<<endl;
		}
```
## 第二种情况
分析：根据它所给的编号，输出这个格子的层数和坐标。

做法： $n$ 没什么好说的，输出字符串长度即可。

坐标的话，可以使用二分的思路。

横坐标：
- 定义左边界 $l$ ，右边界 $r$
1.  输入的字符为 A 或 C，则将右边界 $r$ 移至 `(r+l)/2` 处。
2.  输入的字符为 B 或 D，则将左边界 $l$ 移至 `(r+l)/2+1` 处。

纵坐标：
- 定义上边界 $u$ ，下边界 $d$
1.  输入的字符为 A 或 B，则将下边界 $d$ 移至 `(d+u)/2`处。
2.  输入的字符为 C 或 D，则将左边界 $l$ 移至 `(d+u)/2+1` 处。

```cpp
else{
			cin>>s1;
			n=s1.length();
			cout<<n<<" ";
			p=f(2,n);
			for(int i=1;i<=n;i++){
				arr[i]=s1.at(i-1);
			}
			int u=1,l=1,d=p,r=p;
			for(int i=1;u<d;i++){
				if(arr[i]=='A'||arr[i]=='B'){
					d=(d+u)/2;
				}
				else{
					u=(d+u)/2+1;
				}
			}
			for(int i=1;l<r;i++){
				if(arr[i]=='A'||arr[i]=='C'){
					r=(r+l)/2;
				}
				else{
					l=(r+l)/2+1;
				}
			}
			cout<<u<<" "<<l<<endl;
		}
```
## 献上完整代码

```cpp
#include<iostream>
#include<string>
using namespace std;

char arr[35];

int f(int x,int y){
	int z=x;
	while(y>1){
		z=z*x;
		y--;
	}
	return z;
}

int main(){
	int T,m,n,x,y,w,p;
	string s1;
	cin>>T;
	while(T--){
		cin>>m;
		if(m==0){
			cin>>n>>x>>y;
			w=n;
			for(int i=1;i<=n;i++){
				p=f(2,w);//2的w次方 
				if(x%p==0){
					x=p;
				}
				else{
					x%=p;
				}
				if(y%p==0){
					y=p;
				}
				else{
					y%=p;
				}
//				cout<<endl<<x<<"　"<<y<<endl;
				if(2*y<=p&2*x<=p){
					cout<<"A";
				}
				if(2*y>p&2*x<=p){
					cout<<"B";
				}
				if(2*y<=p&2*x>p){
					cout<<"C";
				}
				if(2*y>p&2*x>p){
					cout<<"D";
				}
				w--;
			}
			cout<<endl;
		}
		else{
			cin>>s1;
			n=s1.length();
			cout<<n<<" ";
			p=f(2,n);
			for(int i=1;i<=n;i++){
				arr[i]=s1.at(i-1);
			}
			int u=1,l=1,d=p,r=p;
			for(int i=1;u<d;i++){
				if(arr[i]=='A'||arr[i]=='B'){
					d=(d+u)/2;
				}
				else{
					u=(d+u)/2+1;
				}
			}
			for(int i=1;l<r;i++){
				if(arr[i]=='A'||arr[i]=='C'){
					r=(r+l)/2;
				}
				else{
					l=(r+l)/2+1;
				}
			}
			cout<<u<<" "<<l<<endl;
		}
	}
	return 0; 
} 
```

---

## 作者：Dzc1317 (赞：3)

## B4322 题解
[题目链接](https://www.luogu.com.cn/problem/B4322)

先来讲讲蒟蒻的**思路**。

**第一种情况，当 $t=0$**，也就是组建编号。

首先，我们可以发现每行每列的格子数都是 $2^{轮数}$ 个（~~这个可以自己证明~~）。

那我们就可以开始画图分析了，以数据 0 2 3 4 为例，可以画出下面这张空白图。
![](https://cdn.luogu.com.cn/upload/image_hosting/j7imfgu6.png)

然后我们就可以通过坐标 $(x,y)$ 来对比现在的范围，一步步缩小范围，并打上此步骤的编号。

举个栗子：最先的范围就是上图，先比较坐标 $(3,4)$ 发现，坐标在 $D$ 区，那么我们就把坐标缩小到 $D$ 区，并记录编号 $D$，再拿这次的 $D$ 区范围继续递归，直到拿到完整编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/ja3zxtbj.png)

下为本操作代码：

```cpp
void dfs(int xa,int ya,int xb,int yb,int deep){
	if(deep>n)return ;
	if(x<=((xa+xb)>>1)){
		if(y<=((ya+yb)>>1)){
			c[deep]='A';
			dfs(xa,ya,(xa+xb)>>1,(ya+yb)>>1,deep+1);
		}
		else{
			c[deep]='B';
			dfs(xa,((ya+yb)>>1)+1,(xa+xb)>>1,yb,deep+1);
		}
	}
	else {
		if(y<=((ya+yb)>>1)){
			c[deep]='C';
			dfs(((xa+xb)>>1)+1,ya,xb,(ya+yb)>>1,deep+1);
		}
		else{
			c[deep]='D';
			dfs(((xa+xb)>>1)+1,((ya+yb)>>1)+1,xb,yb,deep+1);
		}
	}
}//xa 和 ya 是范围左上角位置， xb 和 yb 是范围右下角位置。
```
当然也可以拿 for 循环写，大家自己选择。



**第二种情况，当 $t=1$**，也就是找位置。

就是第一种情况的反操作，用编号来寻找在哪个区，直到缩小到一个格子，这里不过多阐述。

本操作代码：

```cpp
void dfs2(int xa,int ya,int xb,int yb,int deep){
	if(deep==len+1){
		printf("%d %d %d",deep-1,xa,ya);
		return ;
	}
	if(s[deep]=='A')
		dfs2(xa,ya,(xa+xb)>>1,(ya+yb)>>1,deep+1);
	else if(s[deep]=='B')
		dfs2(xa,((ya+yb)>>1)+1,(xa+xb)>>1,yb,deep+1);
	else if(s[deep]=='C')
		dfs2(((xa+xb)>>1)+1,ya,xb,(ya+yb)>>1,deep+1);
	else 
		dfs2(((xa+xb)>>1)+1,((ya+yb)>>1)+1,xb,yb,deep+1);
}
```
也可以拿 for 循环写。

最后贴一下赛事完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	int a=0,k=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')
			k=-1;
		c=getchar();
	}
	while(isdigit(c)){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*k;
}//快读 
char c[35];
int n,x,y,len;
string s;
void dfs(int xa,int ya,int xb,int yb,int deep){
	if(deep>n)return ;//结束条件 
	if(x<=((xa+xb)>>1)){
		if(y<=((ya+yb)>>1)){//A 区 
			c[deep]='A';
			dfs(xa,ya,(xa+xb)>>1,(ya+yb)>>1,deep+1);
		}
		else{//B 区 
			c[deep]='B';
			dfs(xa,((ya+yb)>>1)+1,(xa+xb)>>1,yb,deep+1);
		}
	}
	else {
		if(y<=((ya+yb)>>1)){//C 区 
			c[deep]='C';
			dfs(((xa+xb)>>1)+1,ya,xb,(ya+yb)>>1,deep+1);
		}
		else{//D 区 
			c[deep]='D';
			dfs(((xa+xb)>>1)+1,((ya+yb)>>1)+1,xb,yb,deep+1);
		}
	}
}//t=0
void dfs2(int xa,int ya,int xb,int yb,int deep){
	if(deep==len+1){//结束条件 
		printf("%d %d %d",deep-1,xa,ya);
		return ;
	}
	if(s[deep]=='A')//A 区 
		dfs2(xa,ya,(xa+xb)>>1,(ya+yb)>>1,deep+1);
	else if(s[deep]=='B')//B 区 
		dfs2(xa,((ya+yb)>>1)+1,(xa+xb)>>1,yb,deep+1);
	else if(s[deep]=='C')//C 区 
		dfs2(((xa+xb)>>1)+1,ya,xb,(ya+yb)>>1,deep+1);
	else //D 区 
		dfs2(((xa+xb)>>1)+1,((ya+yb)>>1)+1,xb,yb,deep+1);
	//有点长，大家别介意 
}//t=1 
int main(){
	freopen("square.in","r",stdin);
	freopen("square.out","w",stdout);
	int T=read(),t;
	while(T--){
		t=read();
		if(!t){
			n=read(),x=read(),y=read();
			dfs(1,1,1<<n,1<<n,1);
			for(int i=1;i<=n;i++)
				printf("%c",c[i]);
			puts("");
		}
		else{
			cin>>s;
			len=s.size();
			s=' '+s;
			dfs2(1,1,1<<len,1<<len,1);
			puts("");
		}
        //别忘了换行 ！！！ 
	}
	return 0;
}
```
**禁止抄袭题解！！！**

---

## 作者：YWT130508 (赞：2)

这题的主要思路就是分，所以可以用递归实现。

## $op = 0$
输入 $n$，$x$，$y$，通过样例不难发现第 $n$ 轮字符串的长度就是 $n$，所以函数的参数应该有当前矩阵左上角的坐标 $x$，$y$，以及当前矩阵的边长 $n$，要查找的位置 $x$，$y$，由于我用的是字符数组，所以还有一个下标 $i$。

接下来，判断查找的位置在哪一块，把当前矩阵分成四个小矩阵，再判断，左上则 $x_i=A$，右上则 $x_i=B$，左下则 $x_i=C$，右下则 $x_i=D$，再根据位置选择四个小矩阵中的一个作为新矩阵调用函数。
## $op = 1$
输入 $str$，题目要求输出它是第几轮，以及它的 $x$，$y$，第几轮其实就是它的长度，而坐标还是可以用递归算，递归参数基本和前面一样，但减少了查找位置的坐标。

函数内只需判断 $x_i$ 的值，和前面原理一样，只不过前面是根据坐标选值，这里是根据只选坐标，$x_i=A$ 则左上，$x_i=B$ 则右上，$x_i=C$ 则左下，$x_i=D$ 则右下，还是根据前面的位置递归。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t;
long long x,y;
char a[35];
void funa(int x,int y,int x1,int y1,int n,int i){
	if(n==1)return ;
	int n1=n>>1;
	int x2=x1+n1;
	int y2=y1+n1;
	if(x>=x2){
		if(y<y2){	
			a[i]='C';
			funa(x,y,x2,y1,n1,i+1);
		}
		else {
			a[i]='D';
			funa(x,y,x2,y2,n1,i+1);
		}
	}
	else {
		if(y<y2){
			a[i]='A';
			funa(x,y,x1,y1,n1,i+1);
		}
		else{
			a[i]='B';
			funa(x,y,x1,y2,n1,i+1);
		}
	}
}

void funb(int x1,int y1,int n,int i){
	if(n==1){
		x=x1,y=y1;
	return ;	
	}
	int n1=n>>1;
	int x2=x1+n1;
	int y2=y1+n1;
	if(a[i]=='A'){
		funb(x1,y1,n1,i+1);
	}
	if(a[i]=='B'){
		funb(x1,y2,n1,i+1);
	}
	if(a[i]=='C'){
		funb(x2,y1,n1,i+1);
	}
	if(a[i]=='D'){
		funb(x2,y2,n1,i+1);
	}
}
int main(){
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
cin>>t;
while(t--){
	bool b;
	cin>>b;
	if(!b){
		int n,x,y;
		cin>>n>>x>>y;
		funa(x,y,1,1,1<<n,0);
		for(int i=0;i<n;i++){
			cout<<a[i];
		}
		cout<<endl;
	}
	else{
		cin>>a;
		funb(1,1,1<<strlen(a),0);
		cout<<strlen(a)<<' '<<x<<' '<<y<<endl;
	}
}
return 0;
}

```

---

## 作者：LG086 (赞：2)

划分正方形，分为 $4$ 部分，编号为 $\tt{ABCD}$。分两种查询。


---


### 查询一

问你第 $i$ 行 $j$ 列的图形编号。

发现第 $p$ 轮的正方形，边长是原正方形的 $\dfrac{1}{2^p}$，那么记最小的正方形边长为 $1$，则原正方形边长为 $2^p$。每次划分都将大正方形分为边长为 $2^{p-1}$ 的四部分，然后 $p \leftarrow p-1$，继续划分。


记 $sz$ 为当前的 $2^{p-1}$ 的值。

发现若 $j \le sz$ 时，若 $i \le sz$，则当前位置处于一块正方形的 $\tt{A}$ 处，否则处于 $\tt{C}$ 处。若 $j \gt sz$ 时，若 $i \le sz$，则当前位置处于一块正方形的 $\tt{B}$ 处，否则处于 $\tt{D}$ 处。

我们需要保证 $(i,j)$ 在 $sz$ 的范围内，所以若此时 $i\gt sz$，$i \leftarrow i-sz$，同理若 $j \gt sz$，$j \leftarrow j-sz$。

在这之后，$sz \leftarrow \dfrac{sz}{2}$。

重复执行操作直至 $sz \le 0$。

这要得到的字符串就是答案。



---


### 查询一

问你给定的图形编号在哪里。

编号长度为 $p$，则说明在第 $p$ 轮的正方形中。  
直接先输出编号长度。

发现在异界正方形中，$\tt A$ 在 $(1,1)$，$\tt B$ 在 $(1,1+1)$，$\tt C$ 在 $(1+1,1)$，$\tt D$ 在 $(1+1,1+1)$。同理，如果是某部分的 $\tt A$ 在 $(i,j)$，则 $\tt B$ 在 $(i,j+1)$，$\tt C$ 在 $(i+1,j)$，$\tt D$ 在 $(i+1,j+1)$。

我们初始化 $i=1,j=1,o=0$。从编号字符串的末尾从后往前便利，若当前位置 $s_i$ 为 $\tt A$，$i,j$ 不变，若 $s_i$ 为 $\tt B$，$j \leftarrow j+2^o$，若 $s_i$ 为 $\tt C$，$i \leftarrow i+2^o$，若 $s_i$ 为 $\tt D$，$i \leftarrow i+2^o,j \leftarrow j+2^o$。判断完毕，$o \leftarrow o+1$。

最终得到的 $(i,j)$ 就是答案。

---



做完了。这里再给出示例代码。当然，本代码写法和上文讲解有些许不相同，请注意。

```cpp
#include<iostream>
using namespace std;
int T,_o,p,i,j;string s0;
int main(){
 cin>>T;
 while(T--){
  cin>>_o;
  if(!_o){
   cin>>p>>j>>i;
   s0="";
   int sz=(1<<p);//cout<<sz<<" ";
   while(sz>>1){
    if((sz>>1)>=i){
     if((sz>>1)>=j)s0+="A";
     else s0+="C";
    }else{
     if((sz>>1)>=j)s0+="B";
     else s0+="D";
    }
    sz>>=1,i-=sz,j-=sz;
   }
   cout<<s0<<"\n";
  }else{
   cin>>s0;
   i=0,j=0;
   cout<<s0.size()<<" ";
   int o=0;
   for(int _=-((int)(s0.size())-1);_<=0;_++){
    if(s0[-_]=='A')i+=0,j+=0;
    else if(s0[-_]=='B')i+=(1<<o);
    else if(s0[-_]=='C')j+=(1<<o);
    else i+=(1<<o),j+=(1<<o);
    o++;
    //i+=sz,j+=sz,sz<<=1;
   }
   cout<<j+1<<" "<<i+1<<"\n";
  }
 }
 return 0;
}
```

---

## 作者：wenqinghua1001 (赞：2)

~~我小学组考了 305 分，初中组只有 200 分。~~

## 思路

这题明显是递归做法。

在代码中需快速求出 $2^i$，打一个快速幂。

```cpp
long long p(long long a,long long b){
	if(b==1) return a;
	if(b==0) return 1;
	long long tmp=p(a,b/2);
	if(b%2==0) return tmp*tmp;
	else return tmp*tmp*a;
}
```

### 第一种问题

当 $op=0$ 时，要求输出第 $n$ 轮的图形中第 $x$ 行第 $y$ 列的格子的编号。遍历从 $\operatorname{dfs}(n,x-y)$ 开始，一直遍历到 $n=0$ 结束，遍历时 $\operatorname{dfs}(i,x,y)$ 有四种可能：

第一种可能：如果 $x \le 2^{i-1}$ 且 $y \le 2^{i-1}$，那么 $ans=A+\operatorname{dfs}(n-1,x,y)$。

第二种可能：如果 $x \le 2^{i-1}$ 且 $y > 2^{i-1}$，那么 $ans=B+\operatorname{dfs}(n-1,x,y-2^{i-1})$。

第三种可能：如果 $x > 2^{i-1}$ 且 $y \le 2^{i-1}$，那么 $ans=C+\operatorname{dfs}(n-1,x-2^{i-1},y)$。

第四种可能：如果 $x > 2^{i-1}$ 且 $y > 2^{i-1}$，那么 $ans=D+\operatorname{dfs}(n-1,x-2^{i-1},y-2^{i-1})$。

部分代码：

```cpp
void dfs(long long n,long long x,long long y){
	if(n==0) return ;
	long long h=p(2,n-1);
	if(x<=h&&y<=h){
		ans=ans+'A';
		dfs(n-1,x,y);
	}
	if(x<=h&&y>h){
		ans=ans+'B';
		dfs(n-1,x,y-h);
	}
	if(x>h&&y<=h){
		ans=ans+'C';
		dfs(n-1,x-h,y);
	}
	if(x>h&&y>h){
		ans=ans+'D';
		dfs(n-1,x-h,y-h);
	}
}
```

### 第二种问题

当 $op=1$ 时，就是 $op=0$ 时已知答案，倒推出过程。设 $s$ 为字符串，$c$ 为 $s$ 的长度，$x$ 和 $y$ 为查找位置的坐标。遍历从 $\operatorname{dfs}(0)$ 开始，一直遍历到 $n=c$ 结束，一开始 $x=1$ 且 $y=1$，遍历 $\operatorname{dfs}(i)$ 也有四种可能：

第一种可能：如果 $s_i=A$，那么啥都没变。

第二种可能：如果 $s_i=B$，$y=y+2^{i-1}$。

第三种可能：如果 $s_i=C$，$x=x+2^{i-1}$。

第四种可能：如果 $s_i=D$，$x=x+2^{i-1}$ 且 $y=y+2^{i-1}$。

最后输出 $c$、$x$ 和 $y$。

部分代码：

```cpp
void dfs2(string s,long long n){
	if(n==s.size())
		return ;
	long long h=p(2,s.size()-n-1);
	if(s[n]=='B')
		yy+=h;
	if(s[n]=='C')
		xx+=h;
	if(s[n]=='D'){
		xx+=h;
		yy+=h;
	}
	dfs2(s,n+1);
}
```

## 代码

[AC 记录](https://www.luogu.com.cn/record/214917794)

```cpp
#include<bits/stdc++.h>
using namespace std;
string ans="";
int xx=1,yy=1;
long long p(long long a,long long b){
	if(b==1) return a;
	if(b==0) return 1;
	long long tmp=p(a,b/2);
	if(b%2==0) return tmp*tmp;
	else return tmp*tmp*a;
}
void dfs2(string s,long long n){
	if(n==s.size())
		return ;
	long long h=p(2,s.size()-n-1);
	if(s[n]=='B')
		yy+=h;
	if(s[n]=='C')
		xx+=h;
	if(s[n]=='D'){
		xx+=h;
		yy+=h;
	}
	dfs2(s,n+1);
}
void dfs(long long n,long long x,long long y){
	if(n==0) return ;
	long long h=p(2,n-1);
	if(x<=h&&y<=h){
		ans=ans+'A';
		dfs(n-1,x,y);
	}
	if(x<=h&&y>h){
		ans=ans+'B';
		dfs(n-1,x,y-h);
	}
	if(x>h&&y<=h){
		ans=ans+'C';
		dfs(n-1,x-h,y);
	}
	if(x>h&&y>h){
		ans=ans+'D';
		dfs(n-1,x-h,y-h);
	}
}
int main(){
//  freopen("square.in","r",stdin);
//  freopen("square.out","w",stdout);
	int t;
	cin>>t;
	while(t--){
		int op;
		cin>>op;
		if(op==0){
			long long n,x,y;
			cin>>n>>x>>y;
			ans="";
			dfs(n,x,y);
			cout<<ans<<endl;
		}
		else{
			string s;
			cin>>s;
			xx=1;
			yy=1;
			dfs2(s,0);
			cout<<s.size()<<" "<<xx<<" "<<yy<<endl;
		}
	}
	return 0;
}
```

---


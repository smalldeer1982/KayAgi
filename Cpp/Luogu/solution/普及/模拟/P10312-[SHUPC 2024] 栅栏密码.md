# [SHUPC 2024] 栅栏密码

## 题目描述

栅栏密码（rail fence）是一种很基础的移位密码。

我们将明文 `Hello,World!` 按如下方式排列：

```
H...o...r
.e.l.,.o.l.!
..l...W...d
```

即把明文 `Hello,World!` 排列成若干个 `\/\/\/` 的形状，然后再逐行按从左到右的顺序取出字符，形成密文。例如第一行为 `Hor`，第二行为 `el,ol!`，第三行为 `lWd`，最终形成的密文为 `Horel,ol!lWd`。

若按上述方式排列的密文有 $h$ 行，则称该栅栏密码的高度为 $h$。

现在我们给出高度 $h$ 和一行密文字符串 $s$，请你输出一行明文字符串 $plain$。


## 样例 #1

### 输入

```
3
Horel,ol!lWd```

### 输出

```
Hello,World!```

## 样例 #2

### 输入

```
5
ccehgyaefnpeoobe{lcirg}epriec_ora_g```

### 输出

```
cyberpeace{railfence_cipher_gogogo}```

# 题解

## 作者：xyx404 (赞：10)

## 思路：
观察题目描述发现当 $h$ 等于三时，一共分成了三行。

先看第一行，打乱前的第一第五第九个字符分别变成了打乱后的第一二三个字符，相邻两个字符之间原本相差 $h-1$ 的**两倍**。

再看第二行，首行和尾行的间隔依旧不变，假设列数为 $i$，会有两种情况：
1. 若当前数为**第二行的奇数个字符**的时候，下一个字符是 $h-i$ 的**两倍**。
2. 若当前数为**第二行的偶数个字符**的时候，下一个字符是 $i-1$ 的**两倍**。

第 $h$ 行与第一行是一样的。

再画个只有数字的图来验证我们的思路。

![](https://cdn.luogu.com.cn/upload/image_hosting/30x2w3sx.png)

观察后我们可以发现，当 $h$ 为三时，一共分成了三行，打乱前的一、五、九分别变成了打乱后的第一、二、三个数，相邻两个数之间相差四也就是 $h-1$ 的两倍，第 $h$ 行与第一行相同。再看第二行你会发现，首行和尾行的间隔不变假设列数为 $i$，当前数为第二行的第奇数个数的时候，下一个数字是 $h-i$ 的两倍，若当前数为第二行的第偶数个数的时候，下一个数字是 $i-1$ 的两倍。而且每一行的第一个数字就是这一行的行数。

与我们上面的思路相同，所以可以写成代码。

## 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
char ans[100080]/* 存答案 */;
int han=0/* 第几行 */;
int h,len,pd1,pd2/* 用来判断现在的位置的字符是奇数还是偶数 */;
int check(){// 如思路
	if(han==1||han==h)return pd1+(h-1)*2;
	else{
		if(pd2%2==1)return pd1+(h-han)*2;
		else return pd1+2*(han-1);
	}
}
int main(){// 如思路
	cin>>h;
	cin>>s;
	len=s.size();
	s=" "+s;
	han=pd1=pd2=1;
	for(int i=1;i<=len;i++){ 
		ans[pd1]=s[i];
		pd1=check();
		pd2++;
		if(pd1>len){
			han++;
			pd1=han;
			pd2=1;
		}
	}
	for(int i=1;i<=len;i++)cout<<ans[i];
	return 0;
}
```

---

## 作者：PR_CYJ (赞：6)

# [题目传送门](https://www.luogu.com.cn/problem/P10312)
# 思路
这道题明显是个**模拟**题，思路就是按照栅栏密码的加密方式，预处理出每一行中的字符串，再按 V 字形依次遍历每一行，**累加**遍历到的字符，得出一个答案串 $ans$，最后将 $ans$ 输出即可。

这道题思路很简单，但是要注意**代码细节**。
# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,tt,sz[20],nw[20];
string t,ans,s[20];
int main()
{
	string t,ans;
	cin>>m>>t;
	n=t.size();
	string s[m+10]={};
	for(int i=1;i<=n;i+=2*m-2)//按照 V 字形循环，预处理出每一行中字符串的长度 
	{
		for(int j=1;j<=m&&i+j-1<=n;j++)//注意代码细节 
			sz[j]++;
		for(int j=m-1;j>1&&i+2*m-1-j<=n;j--)
			sz[j]++;
	}
	for(int i=1;i<=m;i++)//截取出每一行中的字符串 
	{
		s[i]=t.substr(tt,sz[i]);
		tt+=sz[i];
	}
	for(int i=1;i<=n;i+=2*m-2)//再次遍历，累加出答案串 
	{
		for(int j=1;j<=m&&i+j-1<=n;j++)
		{
			ans+=s[j][nw[j]];
			nw[j]++;
		}
		for(int j=m-1;j>1&&i+2*m-1-j<=n;j--)
		{
			ans+=s[j][nw[j]];
			nw[j]++;
		}
	}
	cout<<ans<<endl;
}
```

---

## 作者：FarmerDrone (赞：4)

这是一道模拟。提供一个好实现的思路：  
1. 根据 $h$ 计算出排列成`\/\/\/\/`后每一行的长度。小学生数学。  
1. 在原字符串中根据计算的长度分离出每一行。使用 substr 函数。
1. 按照`\/\/\/\/`的顺序把分离出来的每一行的字符逐个加入到答案中。这一步我的做法是给每一行一个“指针”，从而避免再做一次小学生数学。

复杂度应当是 $O(h+|s|)$，绰绰有余。  
下面是代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int h, size;
	string s; //方便输入和使用 substr 函数。
	cin >> h >> s;
	size = s.size(); //省点时间，不过意义不大。
	char ans[size];	//这里如果用 string 由于起初没有限定大小可能会有奇怪的错误。 
	string S[h + 1];
	int Size[h + 1], It[h + 1];
	//下面是计算出每一行的长度。 
	for (int i = 1; i <= h; i++)
		Size[i] = ceil((size - i + 1) / 1.0 / (2 * h - 2)), It[i] = 0;
	for (int i = 1; i < h - 1; i++)
		Size[h - i] += ceil((size - i - h + 1) / 1.0 / (2 * h - 2));
	int it = 0; //类似于指针的东西。 
	for (int i = 1; i <= h; i++)
		S[i] = s.substr(it, Size[i]), it += Size[i]; //分出每一行的字符串。 
	it = 0; //重复利用，意义完全不同。 
	//下面是把拆开的重新拼回去。 
	while (it < size)
	{
		for (int j = 1; j <= h; j++)
			if (It[j] < Size[j])
			{
				ans[it] = S[j][It[j]];
				it++;
				It[j]++;
			}
		for (int j = 1; j < h - 1; j++)
			if (It[h - j] < Size[h - j])
			{
				ans[it] = S[h - j][It[h - j]];
				it++;
				It[h - j]++;
			}
   }
	for (int i = 0; i < size; i++)
		cout << ans[i];//有的 IDE 或许可以直接 cout << ans << endl; 但交上去会 WA。
	cout << endl;
	return 0;	
}
```

---

## 作者：shicj (赞：4)

# P10312 [SHUPC 2024] 栅栏密码 题解

可以发现，这道题目主要要解决的问题是如何从输入的密文中分出加密之前每行的字母（之后按照 V 形遍历输出明文即可）。

先想到找每一行的规律，但找不出来，于是想到用模拟的方法，按照要求先模拟一遍加密，模拟中记下每个位置对应在行数。

这一部分代码如下：

```cpp
//用sum记录第j行的字符个数
for(int i=1;i<=n;){
    for(int j=1;j<=h&&i<=n;j++,i++)
        sum[j]++;
    for(int j=h-1;j>=2&&i<=n;j--,i++)
        sum[j]++;
}
```

接下来，把每一个字母放进每一行：

```cpp
//q[]是一个字符型队列数组，用来记录每一行的字母
for(int i=1,j=1;i<=h;i++)
        for(int k=1;k<=sum[i];k++,j++)
            q[i].push(s[j]);
```

再模拟一遍，输出结果：

```cpp
for(int i=1;i<=n;){
    for(int j=1;j<=h&&i<=n;j++,i++){
        cout<<q[j].front();
        q[j].pop();
    }
    for(int j=h-1;j>=2&&i<=n;j--,i++){
        cout<<q[j].front();
        q[j].pop();
    }
}
```

~~相信已经不需要代码了~~

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
queue<char>q[101];
int sum[101];
int main(){
	int h;
	string s;
	cin>>h>>s;
	int n=s.size();
	s=" "+s;
	for(int i=1;i<=n;){
		for(int j=1;j<=h&&i<=n;j++,i++){
			sum[j]++;
		}
		for(int j=h-1;j>=2&&i<=n;j--,i++){
			sum[j]++;
		}
	}
	for(int i=1,j=1;i<=h;i++){
		for(int k=1;k<=sum[i];k++,j++){
			q[i].push(s[j]);
		}
	}
	for(int i=1;i<=n;){
		for(int j=1;j<=h&&i<=n;j++,i++){
			cout<<q[j].front();
			q[j].pop();
		}
		for(int j=h-1;j>=2&&i<=n;j--,i++){
			cout<<q[j].front();
			q[j].pop();
		}
	}
	return 0;
}
```

---

## 作者：szh_AK_all (赞：2)

直接根据题意模拟即可。

## 分析
可以记录明文字符串的每一位在行数为 $h$ 的情况下会出现在第几行的第几位。得到这样的转换数组后，可以将密文字符串按顺序枚举，而转换数组也按第一行第一个数从左往右从上往下枚举，那么明文在这一转换数组所代表的位上则为密文这一位。

具体参见代码。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int k[15][100005], l[15];

int main() {
	int h;
	string s;
	cin >> h >> s;
	string ans = s;//方便设定ans(明文)的长度
	int u = 1;
	int x = 0;
	int f = 1;
	for (int i = 0; i < (int)s.size(); i++) {
		k[u][++l[u]] = x++;//转换数组
		if (u == h)//不断往右上跳
			f = -1;
		else if (u == 1)//不断往右下跳
			f = 1;
		u += f;//跳
	}
	int y = 0;
	for (int i = 1; i <= h; i++) {
		for (int j = 1; j <= l[i]; j++)
			ans[k[i][j]] = s[y++];
	}
	cout << ans;
}
```

---

## 作者：Big_Dinosaur (赞：1)

模拟题。

可以先预处理排列表中字符所在位置，记录在二维数组 $le$ 中。如样例一，$le_{1,1},le_{2,2},le_{3,3},le_{2,4},le_{1,5},le_{2,6},le_{3,7},le_{2,8},le_{1,9},le_{2,10},le_{3,11},le_{2,12}$ 被标记为 $1$。

接下来，根据标记把密文填入排列表，这一步可用二维数组，但我用了一维数组，因为每一列只有一个字符。

遍历 $le$，若 $le_{i,j}$ 为 $1$，当前要填字符为 $ch$，则最终明文第 $j$ 个字符为 $ch$。

## $\color{#48e350}\text{Code}$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace IO {
	inline int r() {
		int z=1,y=0;
		char t=getchar();
		while(t<'0'||t>'9') {
			if(t=='-')z=-1;
			t=getchar();
		}
		while(t<='9'&&t>='0') {
			y=(y<<1)+(y<<3)+(t^48);
			t=getchar();
		}
		return z*y;
	}
}
using namespace IO;
namespace D1n0 {
	char ch[114514];
	bool le[13][114514];
	inline void _() {
		string s;
		int h;
		h=r();
		cin>>s;
		int sz=s.size();
		for(int i=1,j=1; i<=sz;) {
			while(j<h&&i<=sz)le[j++][i++]=1;
			while(j>1&&i<=sz)le[j--][i++]=1;
		}
		for(int i=1,j=0; i<=h; ++i)
			for(int k=1; k<=sz; ++k)if(le[i][k])ch[k]=s[j++];
		for(int i=1; i<=sz; ++i)putchar(ch[i]);
	}
}
signed main() {
	D1n0::_();
}
```

---

## 作者：_Jocularly_ (赞：1)

按照题目模拟即可。第一步，用输入的加密过的字符串确定每一行应该有多少个字符。在处理行的时候，每次行默认加上累加器，累加器初始化为一，如果遇到第一行或者最后一行，把累加器乘负一，即改变下一次选择的方向。第二步，按照每行字符串数，算出题目中给出的解密前的二维矩阵，直接两重循环即可。

第三步，按照题目要求选字符。行数处理和第一步一样，这里用一个数组统计每一行到第几个了，即保存每一行应该选择的列数，保存在答案字符串内，最后输出答案即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
//输入和输出所需 
int n;
string s; 
string ans;
//第一次处理所需
int cnt = 1;//当前的行号 
int len[15];//每一行应该有的字符数 
int flag = 1;//方向是向上还是向下，如果一代表向下，负一代表向上 
//第二次处理所需 
string a[15];//解密前的二维矩阵 
int pos;//拿取的位置 
//第三次处理所需 
int dir = 1;//方向是向上还是向下，如果一代表向下，负一代表向上（同上） 
int now = 1;//位置 
int num[15];//这一行拿到第几个了 
int main(){
	//输入 
	cin >> n;
	cin >> s;
	//第一步 
	for(int i=0;i<s.size();i++){
		len[cnt] ++;
		cnt += flag;
		if(cnt == n || (cnt > n && (cnt+1) % n == 0) || cnt == 1) flag *= -1;
	} 
	//第二步 
	for(int i=1;i<=n;i++){
		for(int j=0;j<len[i];j++){
			a[i] += s[pos++];
		}
	}
	//第三步 
	for(int i=0;i<s.size();i++){
		ans += a[now][num[now]];
		num[now] ++;
		now += dir;
		if(now == n || (now > n && (now+1) % n == 0) || now == 1) dir *= -1;
	}
	cout << ans;
	return 0;
}

```

---

## 作者：TPJX (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10312)，[博客使用观感更佳](https://www.luogu.com.cn/article/tpgfx7oc)

### 题目要求

给定一个栅栏密码的高度 $h$ 和一个密文字符串 $s$，要求解码出原始的明文。

### 解题思路

#### 1. 理解栅栏密码的编码规则

栅栏密码是将明文按照 Z 字形（或斜线形）排列，然后逐行读取字符形成密文。因此，解码过程就是逆向操作，即根据密文和栅栏高度还原出原始的明文排列，再按照 Z 字形规则读取字符。

#### 2. 计算周期长度

在栅栏密码中，字符的排列呈现周期性。周期长度由栅栏的高度决定，具体为 $2 \times h - 2$。这个周期长度帮助我们确定每个字符在栅栏中的位置。

#### 3. 分配字符到每行

需要统计每行应该有多少个字符。这可以通过遍历密文，计算每个字符在周期中的位置，并据此确定它应该属于哪一行。然后，我们可以将字符分配到对应的行中。

#### 4. 重新组合字符形成明文

一旦有了每行的字符，就可以按照 Z 字形的规则重新组合它们形成明文。这涉及到按照周期长度逐行读取字符，并将它们按照原始的顺序组合起来。

### 代码实现

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

string solve(int h, const string& s) {
    // 计算周期长度
    int cycle = 2 * h - 2;
    // 初始化每行的字符串
    vector<string> rows(h);
    // 统计每行的字符数量
    vector<int> count(h, 0);
    for (int i = 0; i < s.length(); ++i) {
        int mod = i % cycle;
        // 根据位置确定行号
        int row = mod < h ? mod : cycle - mod;
        // 增加对应行的字符计数
        ++count[row];
    }
    // 根据统计结果，分配字符到每行
    int index = 0;
    for (int i = 0; i < h; ++i) {
        rows[i] = s.substr(index, count[i]);
        index += count[i];
    }
    // 按栅栏读取规则重新组合字符
    string plain = "";
    for (int i = 0; i < s.length(); ++i) {
        int mod = i % cycle;
        int row = mod < h ? mod : cycle - mod;
        plain += rows[row][0]; // 取出当前行的第一个字符并加到明文中
        rows[row].erase(rows[row].begin()); // 删除已经使用的字符
    }
    return plain;
}

int main() {
    int h;
    string s;
    cin >> h >> s;
    cout << solve(h, s) << endl;
    return 0;
}
```

---

## 作者：__qkj__ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10312)
## 解题思路
模拟。

我们设一个变量 $x$，表示当前元填的位置。行数从零开始。

- 当行数等于第零行或最后一行，每次 $x \gets x+2\times (n-1)$，超过了则行数加一，$x \gets 行数$。
- 否则，如果当前字符是 `\` 排列的，每次 $x \gets x+2\times n-行数 \times 2-2$，超过了则行数加一，$x \gets 行数$。
- 如果当前字符是 `/` 排列的，每次 $x \gets x+行数 \times 2$，超过了则行数加一，$x \gets 行数$。

最后，输出这个数组。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char c[100010];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	string a;
	cin>>n>>a;
	int x=0,len=a.size(),now=0;
	bool f;//f=1，表示 \ 排列，否则表示 / 排列
	for(int i=0;i<len;i++)
	{
		c[x]=a[i];
		if(now==0||now==n-1)
		{
			x+=2*(n-1);
			if(x>=len)x=++now,f=1;
		}
		else
		{
			if(f)
			{
				x+=n*2-now*2-2;
				if(x>=len)x=++now,f=0;
			}
			else
			{
				x+=now*2;
				if(x>=len)x=++now,f=0;
			}
			f=!f;
		}
	}
	cout<<c;
	return 0;
}

```

---

## 作者：_Deer_Peach_ (赞：1)

这道题给我们了加密后的密码，那我们可以先还原出在栅栏上的密码。

我们可以先找出规律：

高度为二时（$X$ 表示字母，$O$ 表示为空）：
```
XOXOXOXO
OXOXOXOX
```
第一行两个字母相差二（开始一个也算上）。

高度为三时：
```
XOOOXOOOXOOOX
OXOXOXOXOXOXO
OOXOOOXOOOXOO
```
第一、三两行差四，中间一行差二（二、二交替）。

高度为四时：
```
XOOOOOXOOOOOX
OXOOOXOXOOOXO
OOXOXOOOXOXOO
OOOXOOOOOXOOO
```
第一行和第四行差六，第二行差二、四交替，第三行二、四交替。

高度为五时：
```
XOOOOOOOXOOOOOOOX
OXOOOOOXOXOOOOOXO
OOXOOOXOOOXOOOXOO
OOOXOXOOOOOXOXOOO
OOOOXOOOOOOOXOOOO
```

第一行和最后一行差八，第二行差六、二交替，第四行差二、六交替，第三行差四（四、四交替）。

应该比较形象了，规律也差不多能找出来了。

第一行和最后一行的差就是 $(h-1) \times 2$。

中间的差有两种，设为 $dis1$ 和 $dis2$。

那么可得 $dis1=(h-i-1) \times 2$，$dis2=(h-1) \times 2-dis1$。

还原出栅栏，最后就可以按照题意解密出原字符串了。

具体代码（大佬勿喷）：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int h;//栅栏高度
string s;//加密后的字符串
signed main(){
	cin>>h;
	cin>>s;//输入
	int len=s.size();//长度
	char a[h][len];//栅栏
	for(int i=0;i<h;i++){
		for(int j=0;j<len;j++)a[i][j]=' ';//初始化
	}
	int cnt=0,dis1,dis2;//cnt表示加密后的字符串的下标
	for(int i=0;i<h;i++){
		dis1=(h-i-1)*2;
		dis2=(h-1)*2-dis1;
		if(dis1==0 or dis2==0){//第一行或者最后一行
			for(int j=i;j<len;j+=max(dis1,dis2)){
				a[i][j]=s[cnt];
				cnt++;
			}
		}else{//其他情况
        int j=i;//栅栏每一行的第一个字符都在i位置
			while(1){
				if(j<len){//判断是否还能放在这一行
					if(dis1!=0){//没用的判断
						a[i][j]=s[cnt];//赋值
						cnt++;//下标往后
						j=j+dis1;//更新			
					}
				}else break;//不能放直接结束换行
				if(j<len){//同上操作
					if(dis2!=0){
						a[i][j]=s[cnt];
						j=j+dis2;
						cnt++;		
					}	
				}else break;
			}			
		}
	
	}
	/*for(int i=0;i<h;i++){//检验栅栏是否正确
		for(int j=0;j<len;j++)cout<<a[i][j];
		cout<<endl;
	}*/
	for(int i=0;i<len;i++){//输出
		for(int j=0;j<h;j++){
			if(a[j][i]!=' '){
				cout<<a[j][i];
			}
		}
	}
	return 0;
}
```
希望尊敬的管理员能够通过这篇题解。

---

## 作者：_dbq_ (赞：0)

## 前言
没读题的同学先点击[这里](https://www.luogu.com.cn/problem/P10312)读题。

## 题目大意
给定栅栏密码的高度和密文，求明文。

## 思路
模拟求出每一行放多少个字母，用指针依次将字母放入空字符串即可。

## 代码
```cpp
#include<iostream>
#define LL long long
#define ULL unsigned long long
#define cint const int 
using namespace std;
cint N=1e5+10;
int tot[11],cnt[11];//指针和每行的数量
string s;//存密文
inline auto read(){//快读
    auto x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int main()
{
    #ifdef dbq
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    #endif
    cint n=read();
    cin>>s;//读入密文
    int now=1,dir=1;//当前在第一个位置，方向是往下
    for(int i=0;i<s.size();i++)
    {
        cnt[now]++;//当前行的数量加1
        if(now==n) dir=-1;//碰到地了就往上
        if(now==1) dir=1;//碰到顶了就往下
        now+=dir;//移动
    }
    now=1;
    tot[1]=0;
    for(int i=2;i<=n;i++)
    {
        tot[i]=tot[i-1]+cnt[i-1];//计算指针的起始位置
    }
    for(int i=0;i<s.size();i++)//顺序放入明文
    {
        cout<<s[tot[now]];//输出明文
        tot[now]++;//移动指针
        if(now==n) dir=-1;//同上
        if(now==1) dir=1;
        now+=dir;
    }
    return 0;
}
```

## 提示
这个方法的效率较低，可借鉴其他大佬的做法。

---

## 作者：jsisonx (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P10312)
# 题目分析
通过观察样例，可以看出明文相当于是波浪形的密码压平了，也就是高度为 $1$。

如何压平呢？我们发现当确定了每一行的第一个字母在明文中的位置，这一行后面的所有字符的位置都可以用数学方法计算。

# 具体算法：

设密码长度为 ```len```。

若想确定每个字符在明文中的位置，就需要确定每一行有多少字符。

1. 分组。如图所示分组
![](https://cdn.luogu.com.cn/upload/image_hosting/v5bhpqjy.png)
显然，每一组中的字符个数为 $k=2 \times (h-1)$。那么可分的组数为 $\lceil \frac{len}{k} \rceil$。由此可知，第一行的字符数量等于组数。设组数为 $g$。


2. 对于第 $2 \sim h-1$ 行，设当前在第 $x$ 行。前 $g-1$ 组每组一定有两个字符在这一行。对于最后一组，需要判断这一行上有没有字符，有几个。显然可以用取模运算解决。设 $p=len \mod k$，特别地，$p=0$ 时令 $p=k$。那么如果 $p \ge x$，那么这一组一定有一个落在字符在这一行，如果 $p \ge x+2 \times (h-x)$，那么这一行还会有第二个字符。

3. 对于最后一行，前 $g-1$ 组一定有 $1$ 个字符。对于最后一组，如果 $p \ge h$，那么最后一组也有一个字符在最后一行。

4. 知道了每行有多少字符后就好办了。首先每一行第一个字符在明文中的位置等于它的行数。对于第一行，每两个字符之间隔了 $k$ 个，对于第 $2 \sim h-1$ 行，设当前位置为第 $x$ 行第 $y$ 列，则若 $y$ 是奇数，则它与下一个字符隔了 $2 \times (h-x)$ 个，否则就隔了 $2 \times (x-1)$ 个。对于最后一行，与第一行的操作一样。

# 代码
```
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
char w[500001]={'\0'},ans[500001];
int line[15];
void out(char c[],int len){
	for(int o=0;o<len;o++){
		if(c[o]=='\0'){
			cout<<' ';
		}
		else{
			cout<<c[o];
		}
	}
	cout<<endl;
}
int main(){
	int h,k,len,group,mod;
	cin>>h>>w;
	len=strlen(w);
	k=2*(h-1);
	group=ceil((double)len/k);
	mod=len%k;
	if(mod==0){
		mod=k;
	}
	line[1]=group;
	for(int i=2;i<h;i++){
		line[i]=2*(group-1);
		if(mod>=i){
			line[i]++;
		}
		if(mod>=i+2*(h-i)){
			line[i]++;
		}
	}
	line[h]=group-1;
	if(mod>=h){
		line[h]++;
	}
	int now=0,now2=0;
	while(now2<line[1]){
		ans[now]=w[now2];
		now2++;
		now+=k;
	}
	for(int i=2;i<h;i++){
		int t=1,p=i-1,x=now2;
		for(int j=now2;j<line[i]+now2;j++){
			ans[p]=w[j];
			if(t%2==1){
				p+=2*(h-i);
			}
			else{
				p+=2*(i-1);
			}
			x++;
			t++;
		}
		now2=x;
	}
	now=h-1;
	for(int i=now2;i<len;i++){
		ans[now]=w[i];
		now+=k;
	}
	out(ans,len);
	return 0;
}
```

---

## 作者：RyanLi (赞：0)

传送门：[P10312 [SHUPC 2024] 栅栏密码](https://www.luogu.com.cn/problem/P10312)

更佳的阅读体验：[洛谷 P10312 题解](https://blog.ryanli.top/index.php/archives/48/)

---

**简要题意**：给定一个栅栏密码及其高度，求其明文字符串。

数据范围比较小，因此我们可以考虑直接将密文字符串还原到二维数组里，然后计算每个字符在明文中的出现位置。

具体地，我们在网格图上标记好“栅栏”中每个字符在密文字符串中出现的位置，然后按照“栅栏”的顺序遍历，输出即可。

``` cpp
#include <iostream>
using namespace std;

const int N = 15, M = 1e5 + 10, pos[9][18] = {
    {1, 2},
    {1, 2, 3, 2},
    {1, 2, 3, 4, 3, 2},
    {1, 2, 3, 4, 5, 4, 3, 2},
    {1, 2, 3, 4, 5, 6, 5, 4, 3, 2},
    {1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2},
    {1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2},
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 4, 3, 2},
    {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2}
};
int h, n, tot, c[N][M];
string s;

int main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cin >> h >> s;
    n = s.size();
    for (int i = 0; i < n; ++i) c[pos[h - 2][i % ((h << 1) - 2)]][i + 1] = 1;
    for (int i = 1; i <= h; ++i)
        for (int j = 1; j <= n; ++j) if (c[i][j]) c[i][j] = tot++;
    for (int i = 0; i < n; ++i) cout << s[c[pos[h - 2][i % ((h << 1) - 2)]][i + 1]];
    return 0;
}
```

---

## 作者：Ivan422 (赞：0)

题目大意：直接对一个高 $h$ 的栅栏密码进行解密。

思路：直接模拟有点难，于是先把每一层的长度预处理出来，再分割出字符串，按照顺序输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+10;
int h,n,rr,mv,bg;
string s,d[N];int len[55];
signed main(){
    cin>>h>>s;n=s.size();// 预处理长度，分割字符串。
    rr=0;mv=1;for(int i=0;i<n;i++){len[rr]++;rr+=mv;if(rr==h-1||rr==0)mv*=-1;}
    for(int i=0;i<h;i++){d[i]=s.substr(bg,len[i]);bg+=len[i];}
    rr=0;mv=1;
    for(int i=0;i<n;i++){ // 输出。
        cout<<d[rr][0];d[rr]=d[rr].substr(1,(int)d[rr].size()-1);
        rr+=mv;if(rr==h-1||rr==0)mv*=-1;
    }
    return 0;
}
```

---

## 作者：Hughpig (赞：0)

记字符串 $s$ 的长度为 $n$。本题解中字符串下标从 $0$ 开始。

我们考虑对一个 $0\sim n-1$ 的排列用栅栏密码加密。

加密后值为 $i\ (0\le i\le n-1)$ 的项的位置就是明文字符串中第 $i$ 项在 $s$ 中所在的位置。

所以我们只要对 $0\sim n-1$ 的排列模拟一遍栅栏加密，记 $i$ 的所在位置为 $pos_i$。然后依次输出 $s_{pos_i}\ (0\le i\le n-1)$ 即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
int a[100007],pos[100007],h;
vector<int> v[15],b;//b 存储模拟加密后的排列。

int main()
{
   	cin>>h>>s;
  	for(int i=0;i<s.size();++i)a[i]=i;//模拟加密
   	for(int i=0,p=0,dir=-1;i<s.size();++i){
    	v[p].emplace_back(i);
    	if(p==0||p==h-1)dir=-dir;
    	p+=dir;
	}
	for(int i=0;i<h;++i){
		for(auto x:v[i])b.emplace_back(x);
	}
	for(int i=0;i<b.size();++i)pos[b[i]]=i;//记录 pos 数组。
	for(int i=0;i<s.size();++i)cout<<s[pos[i]];//输出。
	return 0;
}
```

---

## 作者：Claire0918 (赞：0)

尝试模拟移动过程。

我们先记录第 $i$ 行的有效字符数 $num_i$，以便计算位置。这可以用模拟栅栏走向的方式处理出。

为了方便计算，我们使新的 $num_i'$ 为上文的 $num_i$ 的前缀和，即 $num_i' = \sum_{k = 1}^{i} num_k$。

则在栅栏中第 $i$ 行的第 $j$ 个有效字符为 $s_{num_{i - 1}' + j}$。

再次模拟栅栏走向，得到每一个位置的值，输出。

Code: 
```cpp
#include<bits/stdc++.h>
#define mem(a, v) memset(a, v, sizeof(a));

using namespace std;

const int maxlen = 1e5 + 10, maxh = 10;

int h;
char s[maxlen];
int num[maxh], vis[maxh];

int main(){
    scanf("%d %s", &h, s + 1);
    const int n = strlen(s + 1);
    for (int i = 1, pos = 1, direction = 1; i <= n; i++, pos += direction){
        if (pos == h && ~direction){
            direction = -1;
        }
        if (pos == 1 && !~direction){
            direction = 1;
        }
        num[pos]++;
    }
    for (int i = 1; i <= h; i++){
        num[i] += num[i - 1];
    }
    for (int i = 1, pos = 1, direction = 1; i <= n; i++, pos += direction){
        if (pos == h && ~direction){
            direction = -1;
        }
        if (pos == 1 && !~direction){
            direction = 1;
        }
        putchar(s[num[pos - 1] + ++vis[pos]]);
    }

return 0;
}
```

---


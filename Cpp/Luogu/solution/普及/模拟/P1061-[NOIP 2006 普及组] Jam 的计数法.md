# [NOIP 2006 普及组] Jam 的计数法

## 题目描述

Jam 是个喜欢标新立异的科学怪人。他不使用阿拉伯数字计数，而是使用小写英文字母计数，他觉得这样做，会使世界更加丰富多彩。

在他的计数法中，每个数字的位数都是相同的（使用相同个数的字母），英文字母按原先的顺序，排在前面的字母小于排在它后面的字母。我们把这样的“数字”称为 Jam 数字。在 Jam 数字中，每个字母互不相同，而且从左到右是严格递增的。每次，Jam 还指定使用字母的范围，例如，从 $2\sim 10$，表示只能使用 ${b,c,d,e,f,g,h,i,j}$ 这些字母。如果再规定位数为 $5$，那么，紧接在 Jam 数字 $\texttt{bdfij}$ 之后的数字应该是 $\texttt{bdghi}$。（如果我们用 $U$、$V$ 依次表示 Jam 数字 $\texttt{bdfij}$ 与 $\texttt{bdghi}$，则 $U<V$，且不存在 Jam 数字 $P$，使 $U<P<V$）。

你的任务是：对于从文件读入的一个 Jam 数字，按顺序输出紧接在后面的 $5$ 个 Jam 数字，如果后面没有那么多 Jam 数字，那么有几个就输出几个。

## 说明/提示

NOIP 2006 普及组 第三题


## 样例 #1

### 输入

```
2 10 5
bdfij
```

### 输出

```
bdghi
bdghj
bdgij
bdhij
befgh
```

# 题解

## 作者：xiangling (赞：33)

虽然这题有点水，但是逛了一圈题解区，没有令我满意的$dfs$做法。

个人认为$dfs$是十分优美的，她的自相似的性质总是如此迷人，所以我们写$dfs$的时候也要优雅一点才好。

-------------------

题意不再赘述，下面我们直接分析$dfs$过程。

```
void dfs(int pos,int step)
{
	if(pos==0)return;
	if(step==6)return;
	if(a[pos]<t&&a[pos<a[pos+1]-1)
	{
		a[pos]++;
		for(int i=pos+1;i<=w;i++)
		a[i]=a[i-1]+1;
		output();
		dfs(w,step+1);
	}
	else dfs(pos-1,step);
}
```

我们用数组$a[30]$表示$Jam$数，下标从$1$开始。

### 递归边界

- 因为最多只要输出$5$个字符串（事实上该算法也因此效率较高，不必担心超时问题），所以计算5个之后就可以直接结束了，因此
**$if(step==6)return;$**

- 宏观上讲，我们是把a数组的元素一个一个往后移，所以当第一个元素都不可以移动时，自然程序也就结束了。
**$if(pos==0)return;$**

### 状态转移

- 如果位置为$pos$的a数组元素可以向后移动，那么我们将其移动一位，同时因为要保证jam数从小到大，我们把pos后面的元素往前移动，这不难理解，前面元素的“权”大于后面元素的“权”，如果要使得序列单调递增，就必须这么做。

- 如果位置为pos的元素不能移动，那么我们就移动位置为pos-1的元素。

----------------------

代码：

```
//code by rainman
#include<bits/stdc++.h>
using namespace std;

int s,t,w,c;
int a[30],cnt;

inline void output()
{
	for(int i=1;i<=w;i++)
	cout<<(char)('a'+a[i]-1);
	cout<<endl;
}

void dfs(int pos,int step)
{
	if(pos==0)return;
	if(step==6)return;
	if(a[pos]<t&&a[pos]<a[pos+1]-1)
	{
		a[pos]++;
		for(int i=pos+1;i<=w;i++)
		a[i]=a[i-1]+1;
		output();
		dfs(w,step+1);
	}
	else dfs(pos-1,step);
}

int main()
{
	cin>>s>>t>>w;
	fflush(stdin);
	while((c=getchar())!=EOF)
	{
		int temp=c-'a'+1;
		if(temp>=1&&temp<=26)a[++cnt]=temp;
	}
	
	a[w+1]=0x7f;
	dfs(w,1);
	return 0;
}
```

---

## 作者：mohei0 (赞：23)

分析：


这道题其实是输出一个字符串（可以把a看成1，b看成2,以此类推……）满足进制的后面连续5个字符串，这个进制是t+1进制（逢t进一），最小数是s（s没什么用）。不过有一个很奇怪的规定，就是后面的数一定要比前面的数大。


拿样例来看：bdfij

首先最后一位j已经不能再+1了，那就向前一位i进一，进一后变成j，后面的数要比前面的数大，所以j还要再向f进一，f进一变成g，满足了后面两个数都可以比前一个数大的条件，这时要求和原数只差1的数，倒数第二位就变成g+1=h，最后一位就变成h+1=i，结果就是bdghi。


实现的话就是先把最后一位+1，看有没有超过进制，如果没有，就直接输出，继续下一个+1，如果有，就把前面一位+1，再看有没有超出进制，没有的话把后面的数（最后一位）依次从前往后赋值成前一个数（字符）+1，输出，有的话重复上面的步骤，如果第一位进一满足不了后面的数比前面的数大的条件的话，就终止程序，否则输出5次就行了。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
using namespace std;
int main()
{
    int a,b,n,i2=0;
    string s;
    cin>>a>>b>>n>>s;
    for(int i=1;i<=5;i++)
    {
        s[n-1]++;
        for(int q=n-1;;q--)
        {
            if(s[q]>b+96-i2)
            {
                s[q-1]++;
                if(q==0) return 0;
            }
            else
            {
                for(int j=q+1;j<=n-1;j++)
                {
                    s[j]=s[j-1]+1;
                }
                break;
            }
            i2++;
        }
        cout<<s<<endl;
        i2=0;
    }
    return 0;
}
```

---

## 作者：ikunTLE (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P1061)

### 思路

本题是**模拟**题。

与其他进制一样，JAM 的计数法也可以看作一种进制，也就是仅当最后一位比个位最大值还大时，它会向前进位。

把序列 $A$ 用作存储答案。从 $w$ 向 $1$ 遍历，统计出所有能取到最大值数量 $C$，循环 $C$ 次更新 $A_{i+j}=A_{i}+j$。注意初始化时要将字母转为数字。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=50;
char str[N];
int ans[N];
int main(){
	int s=read(),t=read(),w=read();
	scanf("%s",str+1);
	for(int i=1;i<=w;++i)
		ans[i]=str[i]-'a'+1;
	for(int i=1;i<=5;++i){
		int cnt=0;
		for(int j=w;j>=1;--j)
			if(t-ans[j]==w-j)
				++cnt;
			else{
				++ans[j];
				for(int k=1;k<=cnt;++k)
					ans[j+k]=ans[j]+k;
				cnt=0;
				break;
			}
		if(cnt)
			return 0;
		for(int j=1;j<=w;++j)
			printf("%c",ans[j]+'a'-1);
		printf("\n");
	}
	return 0;
}
```

---

## 作者：Kawaii_qiuw (赞：3)

题面很好理解，不再赘述。

### 解题思路

乍一看这题还以为要用搜索，写了一个小时，后来发现自己想复杂了，直接模拟即可！

这个故事告诉我们：一个方法做的时间超过半小时，或者思路减退、代码渐渐复杂、心态渐渐崩溃时，要及时切换思路。

从最后一位开始，尝试加一个字符，然后新加的字符以后的所有字符都要紧跟（就这一点，我用深搜写不出来，归根结底还是理解不够），才能使新增的字符串紧跟上一个字符串。

### 代码

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

int main() {
    int s, t, w;
    char str[30];
    cin >> s >> t >> w >> str;
    for (int i = 1; i <= 5; i++) {
        for (int j = w - 1; j >= 0; j--) {
            if (str[j] + 1 <= ('a' + (t - (w - j)))) {
                // 确认当前有可用字母就可以大胆用了，j就是变动位
                str[j] += 1;
                // 当前位置后的位置都是对齐位
                for (int k = j + 1; k < w; k++)
                    str[k] = str[j] + k - j;
                cout << str << endl;
                // 是每次找到一组合适的就跳出
                break;
            }
        }
    }
    return 0;
}
```

完结撒花。

---

## 作者：曦行夜落 (赞：3)

让我们以样例bdfij为例                  
bdfij，发现i和j已经无法进位（到底了），这时我们只能加f，变成g，同时将后面的字母变成g的连续后继（也就是h、i）                       
这时数字变为bdghi，然后我们发现i可以加，就加i              
变成bdghj，这时j没得加了，只好加前面的h，变成i，i后面的字母变成连续后继，这时的数字是bdgij                   
这时我们发现，g是最右边的能增加的字母了，于是我们将g变成h，后面的字母变成连续后继（不变），这时变成bdhij                          
然后bdhij中后三个到达最大，于是我们加d，变成e，后面变成e的连续后继，也就是befgh，这时已经输出五个，直接结束                  
通过样例，我们可以整理一个简单的算法：                      
1.只要没有输出到五个并且不是最大的，继续循环                       
2.从后往前找出第一个可以加的字母              
3.将其变成其后继              
4.将它后面的全部字母变成它的连续后继                 
5.输出              
6.跳回1重复执行                        
数据结构：lim数组存储最大值，a数组存储当前值                    
```cpp
#define maxn 50+5
#include<iostream>
#include<algorithm>
using namespace std;
char a[maxn],lim[maxn];

int main()
{
	int s,t,w;
	cin >> s >> t >> w;
	for (int i=1;i<=w;++i)
		cin >> a[i];
	lim[w]=t+96;
	for (int i=w-1;i>0;--i)
		lim[i]=lim[i+1]-1;
//	for (int i=1;i<=w;++i) cout << lim[i];
//	cout << endl; 
		
	for (int i=1;i<6;++i)
	{
		int p=w;
		while (a[p]==lim[p]) --p;
		a[p]++;
		for (int i=p+1;i<=w;++i) a[i]=a[i-1]+1;
		int bo=1;
		for (int i=1;i<=w;++i)
			if (a[i]!=lim[i]) bo=0;
		for (int i=1;i<=w;++i) cout << a[i];
		cout << endl;
		if (bo) break;
	}
	
	return 0;
}
```

---

## 作者：alan1118 (赞：2)

## 题意

[【题目】](https://www.luogu.com.cn/problem/P1061)

题目很清楚，不再过多解释。

## 思路

从后往前，枚举每一位，找到需要进位的那一位，然后把这一位 $+1$，从这一位往后的依次变为前一位 $+1$ 即可。

## Code

``` cpp
#include <iostream>
using namespace std;

int main()
{
	int s, t, w;
	string str;
	cin >> s >> t >> w >> str;
	for(int i = 1; i <= 5; i++)
	{
		for(int j = w-1; j >= 1; j--)
		{
			if(str[j]-'a'+1 <= j-w+t)
			{
				str[j]++;
				for(int k = j+1; k < w; k++)
					str[k] = str[k-1]+1;
				cout << str << endl;
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：Tracy_Loght (赞：1)

代码意义不大，所以讲详细一点吧。

## 题目描述：

对于给定的字符串求它的后五个合法字符串。

定义一下什么是合法的：

- 前面的字母**小于**排在它后面的字母（字典序小于）；

- 每个字母**互不相同**；

- 所有字母在一定**范围**内。

## 思路：

对于字符串的所有字母要满足字典序，我们大可以想从后一直增大，每次增大后，判断这一位有没有超出上限，超出上限及变为下限，并将前面的一位字母加一（**抽象上的加一**）。

**注**：额，上面的有点抽象，你或许可以想成 $k$ 进制数的排列，但是数有上下限制。

---

接下来判断有没有重复和是否字母字典序单调上升。

没有计算下一个，有的话输出即可。

---

## 作者：zhuangjinning (赞：1)

## 解题思路

这道题的方法就是从后往前遍历字符串，如果发现有一位可以加一，那么就将它加一，然后把它后面的都变成按顺序排列。

就拿样例来说吧，字母范围是 ```b``` 到 ```j```。最后一位是 ```j```，所以这一位没有办法再加一了，再看倒数第二位，这一位是 ```i```，它加一是 ```j```，但因为字母要互不相同，所以这一位也不能加一，再看倒数第三位，这一位是 ```f```，所以加一是 ```g```，不会重，所以可以加。加了这一位后需要将这一位后面的字母按顺序排列，即 ```ghi```，则 ```bdfig``` 后面的就是 ```bdghi```。

按照上述操作模拟即可。

## AC 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int s;
int t;
int w;
string s1;
int main(){
	cin>>s>>t>>w;
	char tmp='a'+t-1;//计算要求范围内最大的字母
	cin>>s1;
	int len=w;
	for(int i=1;i<=5;i++){
		bool ke_dong=0;//找不找得到
		for(int j=len-1;j>=0;j--){
			if(s1[j]<char(tmp-(len-1-j))){//如果可动
				s1[j]++;//加一
				char tmp1=s1[j];
				for(int k=j+1;k<len;k++){
					s1[k]=++tmp1;//将它后面的按顺序排列
				}
				cout<<s1<<endl;//输出
				ke_dong=1;//可以动
				break;
			}
		}
		if(!ke_dong){//如果不能动
			break;//跳出循环
		}
	}
	return 0;
}

```

---

## 作者：Ngo123 (赞：1)

#### 本题考察模拟
我的思路是先外层循环 5 次，每次设置一个初始下标变量 $k$，将它的初值赋为 $n-1$，然后倒序循环，每次看最大的字符 $t$ 减去当前字符串的字符 $str_{k}$ 是否大于等于 $n-k$。

若满足以上要求，那么代表从这一位开始能有一个更大的 Jam 数字，我们就终止循环，把当前数字从第 $k$ 位开始修改为更大的 Jam 数字。

若不满足要求，我们就让变量 $k$ 减一，继续寻找合法的位置。

最后我们如果一直到不到合法的位置 $k$，那么此时 $k$ 小于零，就代表没有合法的 Jam 数字了，我们便结束外层循环，终止程序。

以下是我的代码：
```
#include<bits/stdc++.h>
using namespace std;
int s,t,n;
string str;
int main()
{
    cin>>s>>t>>n>>str;
    s--; t--;
    for(int i = 1;i<=5;i++)
    {
        int k = n-1;
        while(k && t-(str[k]-'a') < n-k) k--;
        if(k < 0) break;
        for(int j = k,c = str[k]+1;j<n;j++,c++) str[j] = c;
        cout << str << '\n';
    }
    return 0;
}
```

---

## 作者：Sweet_2013 (赞：1)

此题直接**模拟**即可。

注意：从最后一位开始，尝试加一个字符，然后新加的字符以后的所有字符都要紧跟，才能使新增的字符串紧跟上一个字符串。
# 上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int s, t, w;
char str[31];
int main(){
    cin>> s>> t>> w>> str;
    for (int i = 1; i <= 5; i++){
        for (int j = w - 1; j >= 0; j--){
            if (str[j] + 1 <= ('a' + (t - (w - j)))){
                // 确认当前有可用字母就可以大胆用了，j就是变动位
                str[j] += 1;
                // 当前位置后的位置都是对齐位
                for (int k = j + 1; k < w; k++) str[k] = str[j] + k - j;
                cout << str << endl;
                // 每次找到一组合适的就跳出
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：jiqihang (赞：1)

### 题目链接
https://www.luogu.com.cn/problem/P1061
### 分析
这是一道模拟题。

步骤如下：
1. 先从右向左遍历。
2. 在确保后续位置有**足够的**字母可以填充的情况下，去试试找一个比当前位大的字母。找到了就替换并更新后续位置的字母。
3. 输出并找下一个。

当然我们也可以 DFS 求解，这里不详细赘述。

---

## 作者：qhr2023 (赞：1)

## solution

一道模拟题。

由于每个数字的位数都相同且从左到右严格递增，那么数字的每位就会有一个这一位能取的最大字母。若最后一位是它能取的最大字母，当找下一个数时这一位就不能再变了，一定是变前边的位，以此类推，直到找到能改的位。

对于给定数字，我们找它的下个数时，我们可以从尾到头遍历这个数字，若当前位是它能取的最大字母，即不能修改，计数器 $cnt$ 加一。当遍历到的第一个能改的位，修改这一位，然后修改这一位后面的 $cnt$ 位，每一位都是前一位加一（为满足递增要求），最后 $cnt$ 归零，本次修改结束。

若直到遍历结束都找不到能修改的位，那说明没有下一个数了，就不用再找了。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int s, t, w, a[35];
string tmp;
int main () {
	cin >> s >> t >> w >> tmp;
	for (int i=1; i<=w; ++i)
		a[i]=tmp[i-1]-'a'+1;
	for (int T=1; T<=5; ++T) {
		int cnt=0;
		for (int i=w; i>=1; --i) {
			if (t-a[i]==w-i) 
				cnt++;
			else {
				a[i]++;
				for (int j=1; j<=cnt; ++j)
					a[i+j]=a[i]+j;
				cnt=0;
				break;
			}
		}
		if (cnt)
			break;
		for (int i=1; i<=w; ++i)
			cout << char(a[i]+'a'-1);
		cout << '\n';
	}
	return 0;
}
```

---

## 作者：pengyirui (赞：1)

# 思路
本题为模拟题。        
**注：** 本题解所述难度仅个人观点，只用做选择写法时参考。
## 解法1 模拟
思维难度： ★。
代码难度： ★。    
按照题目进行模拟即可。字符难写可以将字符转化为数字求解。
## 解法2 搜索
思维难度： ★★。    
代码难度： ★☆。    
使用 DFS（深度优先搜索）求解。无需标记。填数时末位 $$+1$$，不行就回溯上一位。
## 重点
本题中重点有三个：
#### 1.生成下一个数字。
先进行遍历，找出可以替换的数。
#### 2.处理进位。
如果已经是可用的最后字母，那么就要尝试可否进位。
#### 3.判断边界。
如果字母已经到达了最后一个但是无法进位，则模拟结束。
# 结语
本题虽然题目长，但是是一道不 ~（hen）~ 难的题。故不提供代码。

---

## 作者：__Immorta__ (赞：1)

**前言：**

竟然还能写题解！开肝！

**题目大意：**

题目要求我们根据特定的规则生成一组 Jam 数字。（挺奇怪的哈）。Jam 数字由小写英文字母组成，每个数字的位数相同，且从左到右是严格递增的。我们需要在给定的字母范围内，找到输入的 Jam 数字之后的五个 Jam 数字。

**解题步骤：**


- 初始化：

首先，我们需要根据输入的 $s,t,w$ 确定可用的字母集合，并初始化一个计数器来跟踪当前 Jam 数字的每一位。

- 生成下一个 Jam 数字：

从最低位开始，尝试将当前位的字母替换为下一个字母，同时确保替换后的字母仍然满足 Jam 数字的规则（即严格递增且不重复）。

- 进位：

如果当前位的字母已经是可用字母集合中的最后一个字母，则需要将当前位重置为可用字母集合的第一个字母，并尝试对更高位进行替换。

- 边界条件：

如果最高位也达到了可用字母集合的最后一个字母，则表示没有更多的 Jam 数字可以生成。

----

又是一个模拟，好了完结~

有不太合理的敬请指出~

----

完结撒花★,°:.☆(￣▽￣)/$.°★。

---

## 作者：LiJunze0501 (赞：1)

# 题目标签
模拟。
# 涉及知识点
字符串+模拟。
# 题意
比较简单，不须再进行赘述。
# 思路
先解析样例，
```
输入：
2 10 5
bdfij

输出：
bdghi
bdghj
bdgij
bdhij
befgh
```
由 `bdfij` 到 `bdghi`，因为 `ij` 是范围内连续的两个字母，就将前面的 `f` 换成下一个字母 `g`，再依次用 `g` 后的 `hi` 替换 `ij`。  
因此我们可以发现，下一个字符串就是从当前字符串尾部找到连续的字母，然后将连续字母前的一个字母替换成下一个字母，再将后面依次修改为连续字母，代码如下：
```cpp
int siz=w-1;
int x=t;
while(jam[siz]==zmb[x]) siz--,x--;//找尾部的连续字母
jam[siz]=jam[siz]+1;//将连续字母前的字母换为下一个
for(int j=siz+1;j<jam.size();j++) jam[j]=jam[j-1]+1;//改为连续
```
# AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,t,w;
string zmb=" abcdefghijklmnopqrstuvwxyz";
string fin;
string jam;
int main(){
	cin>>s>>t>>w;
	fin=zmb.substr(t-w+1,w);//找到最后一个范围内的Jam数
	cin>>jam;
	for(int i=1;i<=5;i++){
		int siz=w-1;
		int x=t;
		while(jam[siz]==zmb[x]) siz--,x--;
		jam[siz]=jam[siz]+1;
		for(int j=siz+1;j<jam.size();j++) jam[j]=jam[j-1]+1;
		cout<<jam<<endl;
		if(jam==fin) break;//已经到了最后一个，提前跳出
	}
}
```

---

## 作者：chenyuan3 (赞：0)

# 题解：P1061 [NOIP2006 普及组] Jam 的计数法

## 前言

本蒟蒻的第一篇题解，求过。

[![](https://img.shields.io/badge/题目-传送门-ffc116)](https://www.luogu.com.cn/problem/P1061)

## 思路

一道简单的模拟题。

每次 $+1$ 时，从右往左扫描：

* 如果这一位无需进位，则让这一位 $+1$，并且让后面的每一位都变为它左边的一位 $+1$，输出结果；
* 若每一位都需要进位，则说明已经是最后一个 Jam 数字，立刻停止程序。

## 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
int s, t, w;
string jam;
int main()
{
	cin >> s >> t >> w >> jam;
	for (int i = 1; i <= 5; i++) // 最多加 5 次 1
	{
		bool flag = true; // 记录能不能加 1
		for (int j = w - 1; j; j--) // 从右往左扫描
		{
			if (jam[j] - 'a' + 1 <= j - w + t) // 如果这一位无需进位
			{ // 注意在 Jam 数字中第 j 位只能达到 j - w + t
				jam[j]++;
				for (int k = j + 1; k < w; k++)
				{
					jam[k] = jam[k - 1] + 1;
				}
				cout << jam << endl;
				flag = false; // 能加 1
				break;
			}
		}
		if (flag) // 不能加 1
		{
			break;
		}
	}
	return 0;
}
```

---

## 作者：wangjiawen (赞：0)

题意较为简单,不解读了。直接上思路。

我们可以把这个计数法进行简化。把 $a$ 改为 $1$，把 $b$ 改为 $2 \cdots$。~~易注意到~~这个计数法遵循一个规则： $a_i < a_{i+1}$。

我们也能得出 $a_i \le t - i + w$。

然后我们循环五次，每次给最后一位加 $1$。再判断进位。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,l;
string s;
long long a[31];
int main()
{
	cin>>n>>m>>l>>s;
	for(int i=0;i<s.size();i++)
		a[i+1]=s[i]-'a'+1;
//	for(int i=1;i<=l;i++)
//		cout<<a[i]<<" ";
//	cout<<endl<<endl;
	for(int abc=1;abc<=5;abc++)
	{
		a[l]++;
		int i;
		for(i=l;i>=1;i--)
		{
			if(a[i]<=m-l+i)
				break;
			a[i-1]++;a[i]=-1;
		}
		for(i=i+1;i<=l;i++)
			a[i]=a[i-1]+1;
		if(a[0]!=0)
			break;//如果第0位不为0，则第1位发生了进位，因此已经到了最大数，退出。
//此处还有一些问题，详见结尾。
		for(int x=1;x<=l;x++)
			cout<<char(a[x]+'a'-1);
		cout<<endl;
	}
	return 0; 
}
```
### 结尾
在 @[god_std](luogu://user/1234324) 的[此题题解](https://www.luogu.com.cn/article/vzzuutpz)中也提到了数据过水的问题，我也在讨论区中[提及到](https://www.luogu.com.cn/discuss/1038496)。详见题解 or 帖子。

---

## 作者：JingchenBian (赞：0)

## 解题思路
1. ### 模拟法
   1. 从右向左遍历当前 Jam 数字的每一位。
   2. 尝试找到一个比当前位大的字母，并确保在后续位置有足够的字母可以填充。
   3. 一旦找到可以替换的字母，将其替换并更新后续位置的字母。
   4. 输出新的 Jam 数字，并继续寻找下一个 Jam 数字。
3. ### DFS
   1. 从给定的 Jam 数字开始，逐步填充后续位置。
   2. 保证每个位置填充的字母比前一个字母大 $1$，并且符合给定的字母范围。
   3. 递归地填充所有位置，直到找到一个合法的 Jam 数字。
   4. 输出找到的 Jam 数字，并继续寻找下一个 Jam 数字。

---

## 作者：god_std (赞：0)

#### 1. 90pts 做法
直接一次一次计算，满足题意时输出即可，代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,t,w,cnt;
bool mei(string s)
{
	for(int i=1;i<s.size();i++)
	{
		if(s[i]<=s[i-1])return 0;
	}
	return 1;
}
string mapa=" abcdefghijklmnopqrstuvwxyz";
int main()
{
	cin>>s>>t>>w;
	string a;
	cin>>a;
	for(int i=0;i<5;i++)
	{
		int it=w-1;
		int c=a[it]-'a'+2;
		a[it]=mapa[c];
		#define c1 aijsijsj
		while(a[it]==mapa[t+1])
		{
			a[it]=mapa[s];
			if(it==0)return 0;
			it--;
			int c1=a[it]-'a'+2;
			a[it]=mapa[c1];
		}
		it=w-1;
		#undef c1
		while(mei(a)==0)
		{
			int it=w-1;
			int c=a[it]-'a'+2;
			a[it]=mapa[c];
			while(a[it]==mapa[t+1])
			{
				a[it]=mapa[s];
				if(it==0)return 0;
				it--;
				int c1=a[it]-'a'+2;
				a[it]=mapa[c1];
			}
			it=w-1;
		}cout<<a<<endl;
	}
	return 0;
 } 
```
[90pts记录](https://www.luogu.com.cn/record/198235227)
#### 2. 正解做法
观察第 $10$ 个测试数据，可得：直接找出最后 $a$ 个依次从大至小，且最后一位实在可允许范围内最大的（$a$ 越大越好），代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,t,w;
string mapa=" abcdefghijklmnopqrstuvwxyz#";
void c(string &a,int s,int t)
{
	int it=a.size()-1;
	int cnt=0;
	while(a[it]==mapa[t-cnt])it--,cnt++;
	a[it]++;
	for(int i=it+1;i<a.size();i++)a[i]=a[i-1]+1;
	return;
}
int main()
{
	cin>>s>>t>>w;
	string a,st;
	cin>>a;
	st=a;
	for(int i=0;i<5;i++)
	{
		c(a,s,t);
		if(a!=st)cout<<a<<endl;
	}
	return 0;
 } 
```
[AC记录](https://www.luogu.com.cn/record/198245719)
#### 3. 提醒管理员
下面这份代码会被这份数据 hack 掉，但是提交上去也是[满分](https://www.luogu.com.cn/record/198248124)。
```cpp
#include<bits/stdc++.h>
using namespace std;
int s,t,w;
string mapa=" abcdefghijklmnopqrstuvwxyz#";
void c(string &a,int s,int t)
{
	int it=a.size()-1;
	int cnt=0;
	while(a[it]==mapa[t-cnt])it--,cnt++;
	a[it]++;
	for(int i=it+1;i<a.size();i++)a[i]=a[i-1]+1;
	return;
}
int main()
{
	cin>>s>>t>>w;
	string a;
	cin>>a;
	for(int i=0;i<5;i++)
	{
		c(a,s,t);cout<<a<<endl;
	}
	return 0;
 }
```
数据是：
```
1 26 10
prstuvwxyz
```
正确答案：
```
qrstuvwxyz
```
这份程序的输出：
```
qrstuvwxyz








```

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P1061)

# 思路

为了生成紧接在给定 Jam 数字后面的 $5$ 个 Jam 数字，我们需要逐步增加当前 Jam 数字中的字母组合，确保每个字母组合都严格递增且在指定的字母范围内。

我们只需要从 Jam 数字的末尾开始向前查找，找到第一个可以增加的字母。将该字母增加到下一个可用的字母，并调整其后的字母以保持严格递增。如果无法找到可以增加的字母，说明已经到达最大 Jam 数字，无法继续生成。重复上述步骤，直到生成 5 个 Jam 数字或无法继续生成为止。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y;
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e3+5;
bool nextJamNumber(string &jamNumber,int s,int t,int w){
    char minChar='a'+s-1,maxChar='a'+t-1;
    for(int i=w-1;i>=0;i--){
        if(jamNumber[i]<maxChar-(w-1-i)){
            jamNumber[i]++;
            for(int j=i+1;j<w;j++)jamNumber[j]=jamNumber[j-1]+1;
            return true;
        }
    }
    return false;
}
int s,t,w;
string jamNumber;
int main(){
    cin>>s>>t>>w>>jamNumber;
    for(int i=0;i<5;i++){
        if(!nextJamNumber(jamNumber,s,t,w))break;
        cout<<jamNumber<<'\n';
    }
    return 0;
}
```

[**AC 记录**](https://www.luogu.com.cn/record/198150298)

---

## 作者：blankslpl (赞：0)

# P1061 [NOIP2006 普及组] Jam 的计数法
## 思路：
- 定义 $s$ 为最小字母序号 $t$ 为最大的字母序号 $w$ 表示数字的位数 $jam$ 为当前的 Jam 数字
- 从右向左遍历 Jam 数字的每一位，判断能不能增加该位的值，如果可以就将当前位 $+1$ 然后将当前这一位之后的所有位设置为递增的值。
## Ac Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _ read<int>()
template <class T>inline T read()
{
	T r=0,f=1;char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-') f=-1;c=getchar();
	}
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f*r;
}
inline void out(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
inline string read()
{
	char c=getchar();
	string s="";
	while(!((c>='a'&&c<='z')||(c>='A'&&c<='Z')||(c>='0'&&c<='9'))) c=getchar();
	while((c>='a'&&c<='z')||(c>='A'&&c<='Z')||(c>='0'&&c<='9')) s+=c,c=getchar();
	return s;
}
// 定义三个变量，s 表示使用的最小字母序号，t 表示使用的最大字母序号，w 表示数字的位数
int s, t, w;
// 定义字符串变量 jam，表示当前的 Jam 数字
string jam;
signed main() 
{
	s=_,t=_,w=_;// 读取 s, t, w 和 jam
    jam=read();
    // 输出接下来 5 个 Jam 数字
    for(int i=1;i<=5;i++) 
	{
        // 从右向左遍历 Jam 数字的每一位，尝试增加该位的值
        for(int j=w-1;j>=0;j--) 
		{
            // 判断当前这一位能不能增加
            if(jam[j]-'a'+1<t-(w-1-j)) 
			{
                // 当前这一位自增 1
                jam[j]++;
                // 将当前这一位之后的所有位设置为递增的值
                for(int k=j+1;k<w;k++) 
				{
                    jam[k]=jam[k-1]+1;
                }
                // 输出当前的 Jam 数字
                cout<<jam<<'\n';
                // 跳出当前的循环
                break;
            }
        }
    }
    
    return 0;
}
```

---

## 作者：Jerry_zpl (赞：0)

本题算法：模拟，枚举。

----
正解思路如下：
- 首先，题目要我们求给我们的 Jam 数字的后五个数字，所以我们可以循环来枚举这五个数字，$i$ 的范围是零到五。
- 题目中说：“英文字母按原先的顺序，排在前面的字母小于排在它后面的字母。”所以我们的数字也必须是从小到大排好序的。因此我们可以枚举上一个数字，将上一个数字的每一位加一，这样我们的数字一定是递增的，不会出现别的情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
string jam;
int main()
{
	int s,t,w;
	cin>>s>>t>>w;
	cin>>jam;
	for(int i=1;i<=5;i++)
	{
		for(int j=w-1;j>0;j--)
		{
			if(jam[j]-96<=j-w+t)
			{
			   jam[j]++;
			   for(int k=j+1;k<w;k++)
			   {
			   	  jam[k]=jam[k-1]+1;
			   }
			   cout<<jam<<"\n";
			   break;
			}
		}
	}
	return 0;
} 
```

---

## 作者：FastIO_DP (赞：0)

### 题目理解

Jam 的计数法使用小写字母来表示数字，每个字母代表一个数字，且字母之间递增。

### 解题思路

考虑模拟。

首先，我们将字母转换为对应的数字。（用哈希数组）

然后，就找下一个 Jam 数字：

* 从右往左遍历当前数字，找第一个可以增加的字母。
  
* 将找到的这个字母增加 $1$，并且给右边的字母排序，确保字母递增。
  
* 如果出现找不到可以增加的字母的情况，显然，当前数字已经是最大的 Jam 数字，没法再弄出下一个 Jam 数，循环结束。
  

来到最后的输出，重复上面的 5 次，输出接下来的 5 个 Jam 数字。实现这个思路做完就 AC 了！

### 代码实现

    #include <bits/stdc++.h>
    using namespace std;
    
    int s, t, w;
    int num[20];  // 存储当前 Jam 数字的字母对应的数字
    string jam;
    
    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);
    
        // 输入字母范围、数字长度和当前 Jam 数字
        cin >> s >> t >> w;
        cin >> jam;
    
        // 将字母转换为数字
        for (int i = 0; i < w; i++) {
            num[i] = jam[i] - 'a' + 1;
        }
    
        // 输出接下来的 5 个 Jam 数字
        for (int k = 0; k < 5; k++) {
            int i = w - 1;
            // 从右向左找到第一个可以增加的字母
            while (i >= 0 && num[i] == t - (w - 1 - i)) {
                i--;
            }
            // 如果找不到可以增加的字母，说明已经是最大的 Jam 数字
            if (i < 0) break;
    
            // 增加该字母，并调整右边的字母
            num[i]++;
            for (int j = i + 1; j < w; j++) {
                num[j] = num[j - 1] + 1;
            }
    
            // 输出当前的 Jam 数字
            for (int j = 0; j < w; j++) {
                cout << char(num[j] + 'a' - 1);
            }
            cout << '\n';
        }
    
        return 0;
    }

### 总结

时间复杂度为 $O(w)$。

* 遍历了 $5$ 次来输出 Jam 数字，$O(1)$。
  
* 右向左遍历 $num$ 数组，$O(w)$。
  
* 调整 $num$ 数组的字母，$O(w)$。
  
* 输出，$O(w)$。
  

空间复杂度为 $O(w)$。

* $num$ 数组和 $Jam$ 字符串，都是 $O(w)$。
  
* $s,t,w,\cdots$ 变量都为 $O(1)$。

---

## 作者：xiaobeng_0912 (赞：0)

## $\mathbf{Knowledge}$

1. 模拟

## $\mathbf{Solution}$

一道正宗的模拟题。

因为是模拟题，所以依照题意按部就班来模拟就好了。通过整理，模拟的步骤就呈现了出来：

1. 如果输出 Jam 数字的数量未达到 5 个，并且此 Jam 数字非当前计数法里的最大数字，那么：
1. 倒序遍历该 Jam 数字，找到第一个可以变大至少一次的数位；
1. 将其 ASCII 码值加一;
1. 将其后面的所有数位都变成前一位的 ASCII 码值加一的字符；
1. 输出该 Jam 数字；
1. 返回开头，重复执行直到不符合第一个步骤的条件；

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,o,flag;
string s;
int main(){
	scanf("%d%d%d",&n,&m,&o);
	cin>>s;
	for(int i=1;i<=5;i++){//步骤1（数量判断）
		flag=0;
		for(int j=s.size()-1;j>=0;j--){//步骤2
			if(s[j]-'a'!=m-(s.size()-j)){
				s[j]=char(s[j]+1);//步骤3
				for(int k=j+1;k<s.size();k++){//步骤4
					s[k]=char(s[k-1]+1);
				}
				cout<<s<<'\n';//步骤5
				break;
			}
		}
		for(int j=1;j<s.size();j++){//步骤1（数字判断）
			if(s[j]-'a'!=m-(s.size()-j)){
				flag=1;
			}
		}
		if(flag==0){
			break;
		}
	}//步骤6（返回循环开头）
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 题面解析

乍一看去，冗长的题面差点把我吓个半死，不过没有关系，其实 Jam 数字就是一种 $t - s$ 进制的计数法，将第 $s + i$ 个字母看作数字 $i$ 即可。不过，这种数字有一个特殊规定，每一位数必须比前一位大。

## 思路

1. 首先，将 Jam 数字（以下简称“数字”）的末位增加 $1$。
2. 如果发现数字的最后一位超过了题目的限制范畴，开始向前进位，过程为循环查找。如果将前一位进 $1$，并且符合题目的要求，那么将该位进 $1$ 跳出循环，否则，继续向前查找。
3. 进位成功之后，依照题面要求，需要将后面的字母变成前面一位的后继（因为需要保持递增），就得到了后一个数字。
4. 重复以上步骤，直到 $5$ 个数字被求出。

## 样例解释

初始数字：$\texttt {bdfij}$。\
将字母 $\texttt {j}$ 递增得到 $\texttt {k}$，超出了题目所给的限制，因此向前进位。\
此时，可以发现，第三位 $\texttt {f}$ 是第一个符合条件的进位位置，因此将其变为 $\texttt {g}$，并且将后两位变成字母 $\texttt {g}$ 的后继 $\texttt {h}$ 和 $\texttt {i}$，最终得到数字 $\texttt {bdghi}$。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int s, t, w;
int main(){
	cin >> s >> t >> w;
    string num;
    cin >> num;

    for(int i = 0; i < 5; ++i){
    	num[w - 1]++; //自增最后一位
    	if(num[w - 1] >= t + 'a'){ //发现超出限制
    		int pos = 0; //最佳进位位置
    		bool flag = false; //判断是否结束
    		for(int j = w - 2; j >= 0; --j){
    			int hj = w - j;
    			
                //找到了最佳进位位置
    			if(num[j] + 1 < t + 'a' && num[j] + hj < t + 'a'){
    				num[j]++;
    				pos = j;
    				flag = true;
    				break;
				}
			}
			if(!flag) break; //如果发现在每一位进位均不合法，那么结束程序
			for(int j = pos + 1; j < num.size(); ++j){
				num[j] = num[j - 1] + 1; //改变为前一位的后继
			}
		}
		cout << num << endl;
	}
    return 0;
}
```

---

## 作者：Hydra_Shouko (赞：0)

很奇怪的一个模拟题

首先套路式的把字母转化为数字,并预处理每一位的最高限制大小;

(因为如果这个数字取太大了,可能后面的数就没得选了)

用DFS做 , 每次求下一个数时 , 在最末尾的位置加1 , 如果不合法了就返回去处理前一位.处理好了之后,当前位为前一位+1;

(因为是紧挨的下一个JAM数)

处理上一位时,也应该加1,如果不合法(即超过了最大限制),就又去处理当前位的上一位,处理完毕后,当前位也是前一位+1;

如果一直到第一位都不合法呢?(即这个数已经是最后一个JAM数)

针对这种情况,我们可以把dfs改为bool型函数,true表示处理成功,false表示处理失败,如果前一位处理失败了,那么这一位也就必定失败.

如果主程序收到false,则表示此数没有下一个JAM数,直接break就行啦.

推下博客 [SIN_XIII ⑨ ](https://www.cnblogs.com/SINXIII/)

上代码
```
#include<bits/stdc++.h>

using namespace std;

int a[40],s,t,w;
int lim[40];

bool make(int now){
	a[now] ++ ;//加1
	if(a[now] > lim[now]){//如果爆限
		if(now-1 == 0) return false;//如果这一位是最高位且也爆限了 直接往回传false
		bool flag = make(now-1);
		if(flag == false) return false;
  //上一位没处理成功 这一位也不可能处理成功 往回传传false
		a[now] = a[now-1] + 1;
  //如果成功了 这一位就是上一位+1
	}
	return true;
}

void out(){
	for(int i=1;i<=w;i++) {
		char x = 'a'+ a[i] - 1;
   //别忘了减回去 刚开始时加了1
		cout<<x;
	}
	cout<<endl;
	return;
}

int main(){
	cin>>s>>t>>w;
	int what = t;
	for(int i=w;i>=1;i--){
  //预处理出每一位最大限制
		lim[i] = what;
		what--;
	}
	for(int i=1;i<=w;i++){
		char x = getchar();
		if(x <= 'z' && x >= 'a'){
  //防止误读空格回车所以要加这个if
			a[i] = x - 'a' + 1;
  //习惯性地去掉0防止奇怪BUG
		}
		else --i;
	}
	int who = 5;
	while(who--){
		if(make(w) == false) break;
  //如果这里传回来为false 那么整个数就没有下一个了 直接break
		else out();
	}
}
```


---


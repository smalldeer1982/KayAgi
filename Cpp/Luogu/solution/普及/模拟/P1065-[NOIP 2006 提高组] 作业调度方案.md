# [NOIP 2006 提高组] 作业调度方案

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 `j-k` 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 `2-4` 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，`1-1,1-2,2-1,3-1,3-2,2-2` 就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

1. 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

2. 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为 `1 1 2 3 3 2`。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下（机器号/加工时间）：


工件号 |工序 1 | 工序 2
-|-|-
$1$  |  $1/3$  |  $2/2$
$2$  |  $1/2$  |  $2/5$
$3$  |  $2/2$  |  $1/4$

则对于安排顺序 `1 1 2 3 3 2`，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$。

方案 1，用时 $10$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | `3-1` | `3-1` |  无   | `1-2` | `1-2` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

方案 2，用时 $12$：

|      时间       |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12  |
| :-------------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 机器 1 执行工序 | `1-1` | `1-1` | `1-1` | `2-1` | `2-1` |   无   |  无   | `3-2` | `3-2` | `3-2` | `3-2` |  无   |
| 机器 2 执行工序 | 无 | 无 |  无   | `1-2` | `1-2` | `3-1` | `3-1` | `2-2` | `2-2` | `2-2` | `2-2` | `2-2` |

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件 $(1.)(2.)$ 的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件 $(1.)(2.)$ 的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。


## 说明/提示

NOIP 2006 提高组 第三题


## 样例 #1

### 输入

```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```

### 输出

```
10```

# 题解

## 作者：brealid (赞：938)

## 题目解析
这是一道模拟题，主要需要考虑以下几个约束条件：

1. 每个工件的下一个工序必须在上一个工序之后 
2. 同一台机器同一时刻只能加工一个工件
3. 按题目顺序安排下一个工件

按照题目说的做，不会错。

我的题解一般会放一组福利数据，这次也不例外。洛谷官方数据测试点#2奉上，附解释。

## 数据
### input
```plain
3 3
1 1 1 2 3 3 2 2 3
1 2 3
2 1 3
2 3 1
7 2 4
3 2 5
3 2 3
```
### output
```plain
18
```
### explain(可怜我画图花了好久)
![](https://i.loli.net/2019/01/24/5c49b57ea5613.png)
## 附：我的代码

```cpp
#include <stdio.h>

int m, n;
int list[501];
struct Information {
    int id;
    // 在第 id 台机器上加工
    int cost;
    // 花费 cost 时间
} a[21][21];
// a[第几个工件][第几步]
int mac[21][100001] = {0};
// mac[机器编号][时间（话说我也不知道时间最大是多少，反正在空间限制内尽量大）]
int step[21] = {0};
// 每个工件加工到了第几步
int las_time[21] = {0};
// 每个工件上次是 las_time[工件编号] 时加工完的
int ans = 0;

int main()
{
    scanf("%d%d", &m, &n);
    for (int i = 1; i <= m * n; i++) {
        scanf("%d", list + i);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &a[i][j].id);
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            scanf("%d", &a[i][j].cost);
        }
    }
    // 以上：读入
    for (int i = 1; i <= m * n; i++) {
        int now = list[i];
        step[now]++;
        int id = a[now][step[now]].id, cost = a[now][step[now]].cost;
        /* 调试代码 */ // printf("%d: now = %d, id = %d, cost = %d\n", i, now, id, cost);
        int s = 0;
        for (int j = las_time[now] + 1; ; j++) {
            if (mac[id][j] == 0) {
                s++;
            } else {
                s = 0;
            }
            if (s == cost) {
                for (int k = j - cost + 1; k <= j; k++) {
                    mac[id][k] = 1;
                }
                /* 调试代码 */ // printf("(%d~%d. \n", j - cost + 1, j);
                if (j > ans) ans = j;
                las_time[now] = j;
                break;
            }
        }
    }
    printf("%d", ans);
    return 0;
}
```
(无耻地求踩，太烂了)

---

## 作者：ShawnZhou (赞：166)

安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

超难理解的一道题。嘴上说着是一道大模拟实际上无法理解题意就会让事情变得巨麻烦。

**强烈建议画图研究样例。**

这是目前为止我所做过的难度最大的**纯**模拟题。一般来说，模拟题的题解文字说明都比较少，因为代码具体什么意思大家一般都能看明白，但这道题不太一样，所以我打算写的稍微多一些。

这类长模拟代码看的时间久了对一些变量可能有记忆混淆的事情发生，所以我在主要过程基本没使用简单的单字母或者双字母命名变量，那样会严重丧失可读性。

我们来分析一下题意。

题目已经给出了安排好的工序，而每个工序需要在几号机上完成以及每个工序的时间也给了出来，我们要做的就是合理安排机器的工作，让总的加工时间最短。

按照题意的约定，最短方案有且只有一种，而且不必判断输入的合法性。

我们可以把机器想成若干个「时间线」，在这条时间线上去安排工作。

那么明显的，每个时间段对应的机器就只有俩状态：

1.我在干活

2.我闲着呢

而每一个工件也有自己的加工要求，对于每个工件的工序，总应该先完成小号工序再完成大号工序，也就是必须顺着编号来。

每台机器只能在某时刻进行一种工作，并且后面的安排不能把前面的安排改动掉。

模拟的思想便是从左到右无限扫描整个时间线，然后去尝试插空。

这里有三个辅助数组，如果难理解它们的作用将对我的代码有理解困难。第一个是cnt\_now\_work\_step，它表示当前取到工件的工序数。根据之前输入的workline，每个数都代表一个安排的工序，这个数组就是用来方便后面处理工序的，尽管它名字比较长。第二个是lasttime，它代表某个工件出现的最晚的时间（点），它可以用来方便我们扫描时间线，因为每一个工件必须要完全完成上一道工序后才能接着继续下一道工序。第三个是二维bool数组timeline，它代表某一台机器在某一个时间（点）上是不是正在干活。

有了这三个辅助数组，我们就可以开始按照模拟的思路写代码了。

我们取当前工件nowitem[i]，让cnt\_now\_work\_step[nowitem]++，即代表这个工件的工序+1，用nownumber记录当前工件在当前工序时位于哪一台机器，costtime表示做完这道工序应该花费的时间，lasttime[nowitem]+1便是我们扫描时间线的开端，注意lasttime记录的是时间点。这个for没有终止条件，因为时间轴可能会无穷远。

接下来是关键，判断从这个时间点到干完这道工序，机器有没有空，如果机器表示“我闲着呢”，那么就把这道工序安排给机器的这个时间段，更新timeline和lasttime（lasttime[nowitem] = time + costtime - 1，干完活之后这个工件出现的最晚的时间点应该是这道新工序做完的那一刻），然后更新操作立即break掉，继续扫描时间线。如果机器表示“这个时间段我在干其他活”，那这个任务就不能放在这一段，时间线继续扫描。

这个判断要如何写？我用了一个函数，它传入起始时间点和终止时间点和工件编号，然后去判断它的timeline就好。

循环完所有的工件，整个的时间轴也就确定了。

最后去寻找ans，ans应该等于值最大的那个lasttime（即这个工件最后才做完）。

输出ans即可。

参考代码：

```cpp
#include <iostream>
#define maxn 50
using namespace std;
int n,m;
int ans = 0;
int worklist[maxn * maxn];
int worknumber[maxn][maxn];
int worktime[maxn][maxn];
int cnt_now_work_step[maxn];
int lasttime[maxn];
bool timeline[maxn * maxn][maxn * maxn];

bool check_in_line(int begin_time_point,int end_time_length,int workid){
    for (int time = begin_time_point; time <= end_time_length;time++)
        if (timeline[workid][time])
            return false;
    return true;    
}

int main(){
    cin >> m >> n;
    for (int i=1;i<=n*m;i++)
        cin >> worklist[i];

    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            cin >> worknumber[i][j];

    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            cin >> worktime[i][j];

    for (int i=1;i<=n*m;i++){
        int nowitem = worklist[i];
        cnt_now_work_step[nowitem]++;//工序数
        int nownumber = worknumber[nowitem][cnt_now_work_step[nowitem]];
        int costtime = worktime[nowitem][cnt_now_work_step[nowitem]];
        
        for (int time = lasttime[nowitem]+1;;time++)//扫描时间轴
            if (check_in_line(time,time+costtime-1,nownumber)){
                for (int marktime = time;marktime <= time+costtime-1;marktime++)
                    timeline[nownumber][marktime] = true;
                lasttime[nowitem] = time + costtime - 1;
                break;
            }
    }

    for (int i=1;i<=n;i++)
        ans = max(ans,lasttime[i]);

    cout << ans << endl;

    return 0;
}
```

---

## 作者：SimonSu (赞：22)

大佬们把题意讲的也都是足够清楚了，我就再特别提一下一些打代码时候的技巧吧

1. 变量名尽量简洁，最好是对应的英文缩写或者汉语拼音缩写，并且一个代码里尽可能避免相似度极高的变量，如：ii , ij ,ji ,jj ,il ,li…… 当他们同时出现，你不仅容易打错，debug的时候几乎是逼近眼力极限

1. 在一个题编写的过程中可以使用调用函数的方法使代码片段化，不仅可以理清思路，而且看得更顺心。如果实在要写在主函数里，可以使用空行隔开。而且在强制压行之前应分开写完确认无误后再去删除，不然bug de到死。

1. 另外当你的数组调用时是套了几个时，可以先开变量存下来，之后再调用。

1. 适当的注释对自己对思路的理解非常有用

其他的话就是看个人习惯了，你自己觉得最舒服的就是最好的。以上建议仁者见仁，智者见智吧。

希望大家都可以提高码力

noip 2019 RP++



------------
本题 大模拟 数据这么小 跑就是了！

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<queue>
#include<stack>
#include<cmath>
#define LL long long
using namespace std;
inline void read(int &x){
	x=0;int f=1;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();	}
	while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
	x*=f;
}
struct node{
	int num,tim;
}e[22][22];
int n,m;//n工件数 m机器数及工序数 
int mac[22][40000];
int ord[400];
int now[22];
int be[22];

int main()
{
	read(m),read(n);  int tmp=n*m;
	for(int i=1;i<=tmp;i++) read(ord[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			read(e[i][j].num);
			
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			read(e[i][j].tim);
			
	int ans=0;
	for(int i=1;i<=tmp;i++)//大模拟 
	{
		int whi=ord[i];//第几个工件 
		int wha=(++now[whi]);//第几步骤
		
		int ma=e[whi][wha].num;//哪个机器 
		int go=e[whi][wha].tim;//多少时间
		
		int cnt=0,end;
		for(int j=be[whi]+1;;j++)
		{
			if(mac[ma][j]==0) cnt++;
			else cnt=0;
			if(cnt==go)
			{
				end=j;
				break;
			}
		}
		
		for(int j=end-go+1;j<=end;j++) mac[ma][j]=1;
		
		be[whi]=end;
		
		ans=max(ans,end);
	}
	
	printf("%d",ans);
	return 0;
}
```


---

## 作者：取名最烦 (赞：6)

这是一道考察审题与代码实现能力的题。
题目已经将详细算法都告诉我们了，只要照着模拟即可。

建立一个标记数组，每次操作直接扫描整条时间线，直到找到一个足够大的空档为止。

同时储存每个工件上一工序结束时间与每台机器目前的最后工作时间，供搜索时使用，会快很多。

最后在所有工件的最后工作时间里找个最大的，就是答案。

上代码，**我是P党**。
```pascal
var i,j,k,l,m,n,s,t,x,y:longint;
a,b:array[0..30,0..30]of longint;
p,c,ti,st:array[1..1000]of longint;
q:array[1..30,1..10000]of longint;
begin
 read(m,n);
 for i:=1 to n*m do read(c[i]);
 for i:=1 to n do
  for j:=1 to m do read(a[i,j]);
 for i:=1 to n do
  for j:=1 to m do read(b[i,j]);
 for i:=1 to n do st[i]:=1;
 for i:=1 to n*m do
 begin
  inc(p[c[i]]);
  k:=1;
  l:=0;
  t:=0;
  x:=st[c[i]];
  if st[c[i]]>ti[a[c[i],p[c[i]]]] then ti[a[c[i],p[c[i]]]]:=st[c[i]]-1;
  for j:=st[c[i]] to ti[a[c[i],p[c[i]]]] do
  begin
   if q[a[c[i],p[c[i]]],j]<>0 then
   begin
    if l>=b[c[i],p[c[i]]] then
    begin
     t:=1;
     break;
    end;
    l:=0;
    x:=j+1;
   end else inc(l);
  end;
  if t=0 then
  begin
   for j:=ti[a[c[i],p[c[i]]]]+1 to ti[a[c[i],p[c[i]]]]+b[c[i],p[c[i]]] do q[a[c[i],p[c[i]]],j]:=c[i];
   inc(ti[a[c[i],p[c[i]]]],b[c[i],p[c[i]]]);
   st[c[i]]:=ti[a[c[i],p[c[i]]]]+1;
  end else
  begin
   for j:=x to x+b[c[i],p[c[i]]]-1 do q[a[c[i],p[c[i]]],j]:=c[i];
   st[c[i]]:=x+b[c[i],p[c[i]]];
  end;
 end;
 for i:=1 to m do if ti[i]>s then s:=ti[i];
 writeln(s);
 {for i:=1 to m do
 begin
  for j:=1 to s do write(q[i,j]);
  writeln;
 end;}//调试环节
end.


```

---

## 作者：翠竹叶飞 (赞：5)

/\*
乍一看，不知所云；细读数遍，一头雾水。

这道题目的题面实在是很难理解，这也就是它的难度较高的最最主要原因。

这真是一道高质量的模拟题，堪称模拟中的经典，可谓融会贯通！

考察语文（审题能力）而且一定要看懂题目，否则就是扯淡。

题目很长，大意如下：

1.按照给定的安排顺序依次安排

2.同一工件的每道工序在之前工序完成后才可以开始

3.每一操作插入最前面的空档中

于是方案唯一，简单模拟即可。

附赠主要算法

1.按照安排顺序模拟

2.每个工件记录最后时间

考虑到n,m<20，无需考虑时间复杂度，只需细心即可。

由于条件复杂，需注意每个变量的含义

\*/
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int i,j,k,m,n,ans;
int a[405]; //安排顺序 
int mord[21][21],t[21][21];
int cnt[21],last_[21]; //last_ 每个工件最晚时间 
bool rec[21][8001]; //每台机器的每个时间是否被占用 
int main()
{
    scanf("%d%d",&m,&n);
    for (i=1; i<=m*n; i++)
        scanf("%d",&a[i]);
    for (i=1; i<=n; i++)
        for (j=1; j<=m; j++)
            scanf("%d",&mord[i][j]);
    for (i=1; i<=n; i++)
        for (j=1; j<=m; j++)
            scanf("%d",&t[i][j]);
    for (i=1; i<=m*n; i++) {
        cnt[a[i]]++;
        int tmp1=a[i],tmp2=cnt[tmp1]; //tmp1:工件 tmp2:工序
        int tmpm=mord[tmp1][tmp2]; //机器号 //t[tmp1][tmp2]
        for (j=last_[tmp1];;j++) {
            bool flag = 1;
            for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
                if (rec[tmpm][k]) { 
                    flag = 0;
                    break;
                }
            if (flag) {
                for (k=j+1; k<=j+t[tmp1][tmp2]; k++)
                    rec[tmpm][k] = 1; //扔入空档
                last_[tmp1] = max(last_[tmp1],j+t[tmp1][tmp2]);
                ans = max(ans,last_[tmp1]); //将新覆盖的结束点更新 
                //printf("%d : %d %d\n",i,j+1,j+t[tmp1][tmp2]);
                break;
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

一道模拟题，发现数据很小，可以用枚举时间的方法。我们先约定一些变量。

* $a_i$ 表示现在要加工第几个**工件**。
* $b_{i, j}$ 表示第 $i$ 个工件的第 $j$ 个工序所使用的**机器编号**。
* $t_{i, j}$ 表示第 $i$ 个工件的第 $j$ 个工序所用的**时间**。
* $use_{i, j}$ 表示第 $i$ 个机器在第 $j$ 个时间**是否**被使用，为 $1$ 被使用，为 $0$ 表示没被使用。
* $now_i$ 表示第 $i$ 个工件加工到**第几个工序**。
* $lst_i$ 表示第 $i$ 个工件上个工序是**几时**加工完的。

模拟过程：若当前要加工第 $i$ 工件，先更新 $now_i$，把 $now_i$ 加一，即该工件加工到第 $now_i$ 个工序，那我们就从该工件加工完上一个工序之后，找一段该工件所使用的机器没加工其他工件的时间，即从 $lst_i+1$ 开始枚举时间 $j$，找一段长为 $t_{i, now_i}$ 的时间，使这段时间内 $use_{b_{i, now_i}, j}$ 都为 $0$。找到之后，还要更新 $use$、答案和 $lst_i$。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, n, a[405], b[25][25], t[25][25], use[21][8005], now[25], lst[25], ans;
int main () {
	cin >> m >> n;
	for (int i=1; i<=m*n; ++i)
		cin >> a[i];
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=m; ++j)
			cin >> b[i][j];
	for (int i=1; i<=n; ++i)
		for (int j=1; j<=m; ++j)
			cin >> t[i][j];
	for (int i=1; i<=m*n; ++i) 
        for (int id=b[a[i]][++now[a[i]]], w=t[a[i]][now[a[i]]], s=0, j=lst[a[i]]+1; s<w; ++j) {
        	s=(use[id][j]?0:s+1);
        	if (s==w) {
        		for (int k=j-w+1; k<=j; k++) 
            		use[id][k]=1;
        		ans=max(ans, j);
        		lst[a[i]] = j;
			}
		}
	cout << ans;
    return 0;
} 
```

---

## 作者：ClV_Csy (赞：2)

# P1065 [NOIP2006 提高组] 作业调度方案
## 题意
先给出机器数 $m$（工序数也为 $m$）和工件数 $n$。再给出 $m \times n$ 个数，为安排顺序。最后给出 $2$ 组 $n$ 行，每行 $m$ 个数的数据，第一组表示每个工件的每个工序的**机器号**，第二组表示每个工件的每个工序的**加工时间**。  
按题目的约束条件完成工件加工（保证实施方案唯一），求出该方案完成全部任务所需的总时间。
## 思路
比较复杂的模拟题，需要很多变量。
1. int 数组 `l[410]`，存储给定的安排顺序。
2. 结构体 `a[30][30]`，其中 `a[i][j]` 表示第 $i$ 个工件的第 $j$ 个工序的一些性质，拥有成员变量 `id`，表示它所需的机器号以及 `time`，表示加工它所需的时间。

以上变量用于保存输入数据。
```cpp
#include <iostream>
using namespace std;
int m, n;
int l[410];
struct node {
	int id, time;
} a[30][30];
int main() {
	cin >> m >> n;
	for (int i = 1; i <= m * n; i++)
		cin >> l[i];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].id;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].time;
	return 0;
}
```
3. int 数组 `step[30]`，保存每个工件已经完成的最后一个工序编号。
4. int 数组 `last[30]`，保存每一个机器完成当前已经完成的最后一道工序的时间点。
5. bool 数组 `mac[30][8010]`，保存每个机器的每个时间点是否有在加工。
6. int 变量 `ans`，表示当前加工所需总时间。

其他的变量较为琐碎，在代码中体现。
## 代码

```cpp
#include <iostream>
using namespace std;
int m, n;
int l[410];
struct node {
	int id, time;
} a[30][30];
int step[30];
int last[30], ans;
bool mac[30][8010];
int main() {
	cin >> m >> n;
	for (int i = 1; i <= m * n; i++)
		cin >> l[i];
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].id;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			cin >> a[i][j].time;
	for (int i = 1; i <= n * m; i++) {
		int now = l[i]; //now表示当前加工的工件编号
		step[now]++; //该工件完成的工序编号加1
		int id = a[now][step[now]].id; //获取当前工序需要的机器编号
		int time = a[now][step[now]].time; //获取当前工序需要的加工时间
		int sum = 0; //统计加工所用的时间
		for (int j = last[now] + 1; ; j++) {
			if (mac[id][j]) //若当前时间点已经有工件在加工
				sum = 0;
			else {
				sum++;
				if (sum == time) {
					for (int k = j - time + 1; k <= j; k++) //循环time次，最后一次在j的时间点
						mac[id][k] = 1; //标记有工件在加工
					ans = max(ans, j); //更新加工总时间
					last[now] = j; //更新当前工件的最后一道工序的时间点
					break;
				}
			}
		}
	}
	cout << ans; //输出所得时间
	return 0;
}
```

---

## 作者：Kun_is_Me (赞：1)

### 题目分析

纯模拟。

依照题意模拟是 OIer 的必修技能，所以本题依照题意一步一步模拟即可，具体不再展开。

需要注意几个条件：

1. 每一个工件必须按照工序进行，后面的工序不能先于前面的工序进行
2. 每一台机器每一个时刻只能完成一道工序
3. 需要按题目顺序安排

### AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int lst[514];
struct inf{int id,cost;}a[25][25];
int mc[25][114514]={0},stp[25]={0},ltime[25]={0},ans=0;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>m>>n;
	for(int i=1;i<=m*n;i++)cin>>lst[i];
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)cin>>a[i][j].id;
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>a[i][j].cost;
    for(int i=1;i<=m*n;i++)
	{
        int nw=lst[i];
        stp[nw]++;
        int id=a[nw][stp[nw]].id,cost=a[nw][stp[nw]].cost;
        int s=0;
        for (int j=ltime[nw]+1;;j++)
		{
            if (mc[id][j]==0) s++;
            else s=0;
            if (s==cost)
			{
                for(int k=j-cost+1;k<=j;k++) mc[id][k]=1;
                if (j>ans) ans=j;
                ltime[nw]=j;
                break;
            }
        }
    }
    cout<<ans;
    return 0;
}
```

为了防止有人说我的 TJ 过不了，在这里把 [AC 记录](https://www.luogu.com.cn/record/201136150) 贴上。

欢迎大家前来 hack。

不说了，我要去写大模拟了，Bye！

---


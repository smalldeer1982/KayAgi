# [NOIP 2012 普及组] 寻宝

## 题目描述

传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：

藏宝楼共有 $N+1$ 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有 $N$ 层，每层 $M$ 个房间，这 $M$ 个房间围成一圈并按逆时针方向依次编号为 $0,…,M-1$。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字$x$，表示从这个房间开始按逆时针方向选择第 $x$ 个有楼梯的房间（假定该房间的编号为 $k$），从该房间上楼，上楼后到达上一层的 $k$ 号房间。比如当前房间的指示牌上写着 $2$，则按逆时针方向开始尝试，找到第 $2$ 个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。

寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。

请帮助小明算出这个打开宝箱的密钥。


## 说明/提示

【数据范围】

对于 $50\%$ 数据，有$0<N≤1000,0<x≤10^4$；  
对于 $100\%$ 数据，有$0<N≤10000,0<M≤100,0<x≤10^6$。

NOIP 2012 普及组 第二题

## 样例 #1

### 输入

```
2 3
1 2
0 3
1 4
0 1
1 5
1 2
1
```

### 输出

```
5```

# 题解

## 作者：童年如作业 (赞：183)

这题嘛，说难，其实就是一个简单的优化模拟。注意：指示牌的数是让你找有门的第ai个。这题数据多，建议用scanf读入优化。当然，从它指示牌x的数据0<x≤10^6就可以看出来，纯模拟逆时针（我怎么看都像顺时针啊）一个一个模拟是不切实际的TLE。于是我们要深入寻找优化方法。再一看，一层楼有楼梯的门就那么几个，找来找去都是它们，这让我想到了周期问题。周期问题取模是关键，我就wrong在这个点上QAQ。原来我用找门次数直接mod该层楼梯门的个数，假设一下，若ai为该层楼梯门个数，就会出现0的情况，而你现在的门又没楼梯，为了保留其原汁原味，可在模之前-1，模之后+1，这样还避免了该层门个数为一的情况。
不说了，上代码！
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
using namespace std;
int pd[10002][202],a[10002][202];
int main()
{
	//freopen("treasure.in","r",stdin);
	//freopen("treasure.out","w",stdout);
	int n,m,x,i,j,ans=0,l=0;
	scanf("%d%d",&n,&m);//以下的读入不说了
	for(i=1;i<=n;i++)
	{
		l=0;
		for(j=0;j<m;j++)
		{
			scanf("%d%d",&pd[i][j],&a[i][j]);
			if(pd[i][j]==1) l++;//记录该层楼有楼梯的门数
		}
		pd[i][m]=l;
	}
	scanf("%d",&x);
	i=1;
	while(i<=n)
	{
	    ans+=a[i][x];
		ans%=20123;//根据规律，边加边模，值不变，不用long long
	    int k=0;
		for(j=x;;j++)
		{
			if(j==m) j=0;
			if(pd[i][j]==1) k++;
			if(k==(a[i][x]-1)%pd[i][m]+1) break;//最关键的停止条件，循环找对，取模，都靠它。
		}
	    x=j;
		i++;
	}
	printf("%d",ans);//小小的输出优化~
	return 0;
}
```
谢谢大家！！！

---

## 作者：说实话我很强 (赞：102)

说实话，这道题真的~~水~~（狗头

话不多说，我们开始讲解：

------------

 首先，这是一道**纯模拟题**，相信大家也可以看出来，主要就是把数据读入，然后依靠下一层的楼梯给的关系，找到上一层的位置。
 
 经过简单的分析，相信大家都能很快地找到本题的思路：一层一层地模拟。
 
 但是，这里也有个小问题：**模拟什么？**
 
 答案是：每层的位置。根据题面中的：**从j号房间的楼梯爬到上一层到达的房间一定也是j号房间**可知，我们只需要用一个变量来储存自己的位置就行了


但是！
-
题目中有十分明显的提示：对于100%数据，有0<N≤10000 , 0<M≤100 , 0<x≤1,000,000。

看到这个x，我们立马想到，单纯的模拟是不行的，我们只需要考虑一下周期性问题，在每层模拟时用要找的数模一下当层的楼梯数，就可以解决我们的问题了！

于是便有了下面的代码：
-

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10010][110],num[10010][110],key,lo;//lo:location,当前位置
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d%d",&a[i][j],&num[i][j]);
			if(a[i][j]) a[i][0]++;//a[i][0]储存本层有多少楼梯通往上一层 
		}
	cin>>lo;lo+=1;
	for(int i=1;i<=n;i++)
	{
		key+=num[i][lo];key%=20123;
		int x=(num[i][lo])%a[i][0]+a[i][0];//优化的关键！
		//加一个a[i][0]是为了防止模了之后为0（或本层只有一个楼梯）.  
		lo--;//配合下面情况
		while(x)
		{
			lo++;//lo要前置，不然下在一层会出现加了下一个数的情况 
			if(lo>m) lo=1;
			if(a[i][lo]) x--;
		}
	}
	cout<<key%20123;
	return 0;
}
```

完结撒花！
-


---

## 作者：万弘 (赞：13)

普及组里有意思的模拟题  

我来推荐一下`vector`动态数组.它占用的空间随其中元素的增加而增加,所以可以在本题中存这一层有哪些房间是有楼梯的  
介绍最常用的两(san)种操作:(需要头文件<vector>)  
`std::vector<int>a;//定义一个叫a的动态数组`   
`a.push_back(x)//在a的末尾插入x`  
`a.size()//询问a的元素个数`  
有一个细节:可能要走的步数远远比这一层的房间数多,而多次走显然浪费时间,%a.size()即可
  
  ```cpp
  //没有代码的题解不是好题解
  //Wan Hong 2.1
//notebook
#include<iostream>
#include<cstdio>
#include<vector>
typedef long long ll;
#define INF (1ll<<58)
ll read()
{
	ll x=0,f=1;
	char c;
	do
	{
		c=getchar();
		if(c=='-')f=-1;
	}while(c<'0'||c>'9');
	do
	{
		x=x*10+c-'0';
		c=getchar();
	}while(c>='0'&&c<='9');
	return f*x;
}

#define maxn 50011
#define maxm 211
#define mod 20123
std::vector<ll>a[maxn];
ll f[maxn][maxm];
int main()
{
	ll n=read(),m=read();
	for(ll i=0;i<n;++i)
		for(ll j=0;j<m;++j)
		{
			ll x=read();
			f[i][j]=read();//数字
			if(x)a[i].push_back(j);
		}
	ll s=read(),ans=0,tmp,dex;//s:现在的房间号,ans:答案
	for(ll i=0;i<n;++i)
	{
		tmp=f[i][s];
		ans=(ans+tmp)%mod;
		for(dex=0;dex<a[i].size();++dex)
			if(a[i][dex]>=s)break;
		s=a[i][(dex+tmp-1)%a[i].size()];
	}
	printf("%lld",ans);
	return 0;
}
  ```
  
  还有疑问私信我

---

## 作者：xukuan (赞：13)

思路：模拟

题目不难，但我交了好几遍才过，原因有下：

1.把a和b打反;（……）

2.数组要开10^4\*10^2，而我开了10^3\*10^3;（别手快）

##3.优化：可能转10^4次，而一圈最多10^2个，可以用转数mod（或%）圈中1的个数+圈中1的个数！


```pascal
var
 i,j,n,m,tm,ans:longint;
 a,b:array[0..10010,0..110] of longint;
 c:array[0..10010] of longint;
begin
 readln(n,m);
 for i:=1 to n do
  for j:=0 to m-1 do
   begin
    readln(a[i,j],b[i,j]);
    inc(c[i],a[i,j]);
   end;
 readln(j);
 for i:=1 to n do
  begin
   tm:=b[i,j] mod c[i]+c[i];
   ans:=(ans+b[i,j]) mod 20123;
   while true do
    begin
     dec(tm,a[i,j]);
     if tm<=0 then break;
     inc(j);
     j:=j mod m;
    end;
  end;
 writeln(ans mod 20123);
end.
```

---

## 作者：oVo_yangxy (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P1076)

这题就是一道的模拟，模拟的过程没写错一般都能过。~~（这不废话吗？）~~

## 题目描述
有一栋楼，要上 $N$ 层才能找到宝藏，且每一层都有 $M$ 个房间，这 
 $M$ 个房间围成一圈并按逆时针方向依次编号 $0$ 到 $m-1$，每层其中一些房间有通往上一层的楼梯。每个房间里有一个指示牌，指示牌上有一个数字 $x$，表示从这个房间开始按逆时针方向选择第 $x$ 个有楼梯的房间。每层小明第一个进入的房间内指示牌上的数字总和为打开宝箱的密钥。求：打开宝箱的密钥的值是多少。

 ## 思路
 我们把这个塔想象成一个二维数组，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/786mrp9h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

输入我就不多说了，$lt$ 为该房间是否有楼梯，$zp$ 为该房间内字牌的数值，$bh$ 为第一次进入的房间编号，楼层为 $1$，$ans$ 为答案，这里我们再用一个 $c$ 数组来存该层有楼梯的房间的总数。

我们从第一层的第 $bh$ 号房间开始，让 $ans$ 加上该楼层的初始房间的字牌数值。用一个变量 $f$ 来存该楼层所进入的第一个房间的编号模上该层有楼梯的房间的总数值，用来防止多转圈。

然后我们再开个循环，现在开始转圈：

如果此房间有楼梯，那么记录该层有楼梯的房间的总数值的 $f$ 就要减一。房间编号依次往后，如果 $f$ 的值为零了就跳出循环。

在此我们需要特判一下，当小明走到编号为 $M-1$ 的房间时，如果还要接着走，那么房间编号要变成 $0$。

最后输出结果 $ans$，记得模上 $20123$。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	long long lt,zp;
}a[10005][105];
long long n,m,c[10005],ans,f,bh,mod=20123,t;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		for(int j=0;j<m;++j){
			cin>>a[i][j].lt>>a[i][j].zp;
			c[i]+=a[i][j].lt;
		}
	cin>>bh;
	for(int i=1;i<=n;++i){
		ans=(ans+a[i][bh].zp)%mod;
		f=(a[i][bh].zp-1)%c[i]+1;
		while(f>0){
			if(bh>m) bh=0;
			if(a[i][bh].lt) --f;
			++bh;
		}
		--bh;
	}
	cout<<ans%mod;
	return 0;
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/6ndu94h2.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

~~给个赞吧。~~

---

## 作者：wenqinghua1001 (赞：5)

## 一道简单的题。

#### [题目传送门](https://www.luogu.com.cn/problem/P1076)

这是一道**暴力**的题，只需按照题意来写（题目要你干什么，你就干什么）。

### AC code:


```cpp
#include<bits/stdc++.h>
//万能头 。
#define int long long
//可加可不加 。
using namespace std;
const int mod=20123;
//答案取模 。
int ok[20000][500];
//记录第i层第j个房间是否有楼梯通往上一层。
//（0表示没有，1表示有）。
int shu[20000][500];
//记录第i层第j个房间指示牌上的数字x。
//逆时针 。
int r[20000];
//记录第i层有多少个楼梯通往上一层。
signed main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=0;j<m;j++){
			cin>>ok[i][j]>>shu[i][j];
			if(ok[i][j]==1)
				r[i]++;
			//输入 。
		}
	}
	int x;
	cin>>x;
	//小明从藏宝楼底层的x号房间进入开始寻宝。
	//房间编号从0开始。
	int answer=0;
	//打开宝箱的密钥answer。
	for(int i=1;i<=n;i++){
		int _ans=shu[i][x],sum=0;
		//本轮答案 。
		int j=x;
		while(true){
			//小明现在的位置是第j个房间（第i层）。 
			j%=m;//一个环 。
			if(ok[i][j]==1)//如果此门通往上一层。
				sum++; //门数加1。
			if(sum-1==(_ans-1)%r[i])
				break; //退出循环 。
			j++;//下一个 
		}
		answer=(answer+_ans)%mod;
		//累加。
		//第i层第一个进入的房间内指示牌上的数字。
		//总和为打开宝箱的密钥。
		x=j;
	}
	cout<<answer%mod;
	//输出 。
	return 0;
	//好习惯。
}
```

谢谢各位大佬。

---

## 作者：blankslpl (赞：3)

# P1076 [NOIP2012 普及组] 寻宝
## 题意归纳：
有一栋楼，要上 $N$ 层才能找到宝藏，且每一层都有 $M$ 个房间，这 $M$ 个房间围成一圈并按逆时针方向依次编号 $0$ 到 $M−1$，每层其中一些房间有通往上一层的楼梯。每个房间里有一个指示牌，指示牌上有一个数字 $x$，表示从这个房间开始按逆时针方向选择第 $x$ 个有楼梯的房间。每层小明第一个进入的房间内指示牌上的数字总和为打开宝箱的密钥。求：打开宝箱的密钥的值是多少。
## 思路：
- **模拟**。
- 本题就是模拟按指示牌上的数字 $x$ 找房间的过程，但 
$x$ 太大了，不能直接模拟，想到取模优化，即到每层时将当前房间的 $x$ 对当前层的有楼梯房间数取模，取模后为 $0$ 后需要特判，这样取模之后再直接遍历查找房间即可。每层有楼梯房间数可以预处理。
- 不要忘记取模。
## Ac Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define _ read<int>()
template <class T>inline T read()
{
	T r=0,f=1;char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-') f=-1;c=getchar();
	}
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return f*r;
}
inline void out(int x)
{
	if(x<0) putchar('-'),x=-x;
	if(x<10) putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=50011,M=210,mod=20123;
vector<int>a[N];
int f[N][M];
signed main()
{
	int n=_,m=_;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
  			int x=_;
  			f[i][j]=_;//数字
  			if(x!=0) a[i].push_back(j);
  		}
  	}
	int s=_,ans=0,tmp,dex;//s是现在的房间号
	for(int i=1;i<=n;i++)
	{
  		tmp=f[i][s];
  		ans=(ans+tmp)%mod;
  		for(dex=0;dex<a[i].size();dex++) if(a[i][dex]>=s)break;
  		s=a[i][(dex+tmp-1)%a[i].size()];
 	}
  	out(ans);
  	return 0;
}
```

---

## 作者：Ybll_ (赞：2)

# 思路：
有点像约瑟夫哈，数据较水，模拟即可，只需要算出这层需要走几步，然后在对这层有几个楼梯取模，剩下没走完的楼梯直接暴力就行。

**重要的事情说三遍，记得对 $20123$ 取模，记得对 $20123$ 取模，记得对 $20123$ 取模！**
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[10005][105],b[10005][105],v[10005];
int main()
{
	long long n,m,ans=0,u;
	cin>>n>>m;
	for(long long i=0;i<n;i++)
	{
		for(long long j=0;j<m;j++)
		{
			cin>>b[i][j]>>a[i][j];
			v[i]+=b[i][j];//这层共有几个楼梯 
		}
	}
	cin>>u;
	for(long long i=0;i<n;i++)
	{
		ans=(ans+a[i][u])%20123;//求和 
		long long t=(a[i][u]-1)%v[i]+1;//取模求还要再这层走几个楼梯 
		while(t)
		{
			if(u>m)u=0;
			if(b[i][u])t--;
			u++;
		}
		u--;
	}
	cout<<ans%20123;
	return 0;
}
```

---

## 作者：Ngo123 (赞：2)

本题考察**模拟**，依题意写模拟寻宝的过程即可。

本题在找寻房间的过程，由于数据范围较大，不能暴力找，可以通过取模的方式优化。

本题还要注意取模后的特判情况，注意数据范围，数组不要混淆或开小。

以下是本题的代码：
```
#include<iostream>
using namespace std;
const int N = 10005,M = 105,mod = 20123;
int w[N][M],k,n,m,ans;
bool v[N][M];
int main()
{
    cin>>n>>m;
    for(int i = 0;i<n;i++)
        for(int j = 0;j<m;j++)
            cin>>v[i][j]>>w[i][j];
    cin>>k;
    for(int i = 0;i<n;i++)
    {
        int s = 0;
        for(int j = 0;j<m;j++) s += v[i][j];
        int t = w[i][k] % s;
        if(!t) t = s;
        ans = (ans + w[i][k]) % mod;
        while(t)
        {
            t -= v[i][k];
            k = (k+1) % m;
        }
        k = (k+m-1) % m;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Cold_Eyes_bystander (赞：1)

~~看了好久，终于明白之前的思路了。~~

- 暴力。

  其实就是按题意模拟。

  我们一步一步走，直到满足条件。

```c++
#include <bits/stdc++.h>
using namespace std;
int xu[10001][101][3];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<m;j++)
        {
            cin>>xu[i][j][1]>>xu[i][j][2];
        }
    }
    int asd,sum=0;
    cin>>asd;
    for(int i=1;i<=n;i++)
    {
        sum+=xu[i][asd][2];
        int zcv=xu[i][asd][2];
        sum%=20123;
        int cnt=0;
        while(1)
        {
            if(asd>=m) asd-=m;
            if(xu[i][asd][1]==1)
            {
                cnt++;
            }
            if(cnt==zcv)
            {
                break;
            }
            asd++;
        }
    }
    cout<<sum;
    return 0;
}
```

此代码五十分。

- 正解
  
  我们可以想象一个情景，你去跑步，~~你的妈妈~~叫你跑五圈操场，等你大汗淋漓的跑完时，你会发现你又回到了原点。

  这说明~~跑圈是没有意义的~~如果跑完一圈，你又会回到原点，那么在模拟过程中，我们可以对次数取模，省去跑圈的操作，每一次跑步不超过一圈。

```c++
#include <bits/stdc++.h>
using namespace std;
int xu[10001][101][3],fg[10001];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int fgh=0;
        for(int j=0;j<m;j++)
        {
            cin>>xu[i][j][1]>>xu[i][j][2];
            if(xu[i][j][1]==1) fgh++;
        }
        fg[i]=fgh;
    }
    int asd,sum=0;
    cin>>asd;
    for(int i=1;i<=n;i++)
    {
        sum+=xu[i][asd][2];
        sum%=20123;
        int cnt=0,zcv=xu[i][asd][2]%fg[i];
        if(zcv==0) zcv=fg[i];
        while(1)
        {
            if(asd==m) asd=0;
            if(xu[i][asd][1]==1)
            {
                cnt++; 
            }
            if(cnt==zcv)
            {
                break;
            }
            asd++;
        }
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：Eason_lyx (赞：1)

博客效果**更佳**->[洛谷博客](https://www.luogu.com.cn/article/mpvdcqth)。

upd on 2025.1.12：
- 修正了超链接。
## 题目大意
- 藏宝楼共有 $N+1$ 层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼**另有** $N$ 层，每层 $M$ 个房间，这 $M$ 个房间围成一圈并按**逆时针**方向依次编号为 $0,\dots,M-1$。
- 其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 $x$，表示从这个房间开始按逆时针方向选择第 $x$ 个**有楼梯**的房间（假定该房间的编号为 $k$），从该房间上楼，上楼后到达上一层的 $k$ 号房间。比如当前房间的指示牌上写着 $2$，则按逆时针方向开始尝试，找到第 $2$ 个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为**第一个**有楼梯的房间。
- 你找到**每层上楼房间**的指示牌上的数字（即每层**第一个**进入的房间内指示牌上的数字）总和为打开宝箱的密钥。
- 输出**对 $20123$ 取模**的结果即可。

## 思路
本题是一道很好的**模拟题**，确切地说是**转圈类**的模拟。这里讲重点，剩下的都在代码里注释了。

输入：当你看到这样一长串的格式时：
>接下来 $N \times M$ 行，每行两个整数，之间用一个空格隔开，每行描述一个房间内的情况，其中第 $(i-1) \times M+j$ 行表示第 $i$ 层 $j-1$ 号房间的情况（$i=1,2,\dots,N$；$j=1,2,\dots,M$）。第一个整数表示该房间是否有楼梯通往上一层（$0$ 表示没有，$1$ 表示有），第二个整数表示指示牌上的数字。注意，从 $j$ 号房间的楼梯爬到上一层到达的房间一定也是 $j$ 号房间。

翻译成普通话就是：
>按照从第 $1$ 层到第 $N$ 层的顺序，其中每层又按照从第 $0$ 间到第 $M$ 间的顺序输入。

这里特别强调一点：每一层都是从第 $0$ 间开始计算。

第 $25$ 行的 `find=(find-1)%s[i]+1;` 是典型的转圈思想，给个例子。

某一层有 $5$ 间房，均为楼梯房。某一间房上写了 $6$。代表要走 $6$ 间房，实际只位移了 $1$ 间房。本行代码降低了程序复杂度。

接着就按照题目给的顺序与要求，模拟即可。

## 代码

### 注释版：

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[10005][105];//a[i][j]表示：第i层第j个房间是否有楼梯
int to[10005][105];//to[i][j]表示：第i层第j个房间指示牌上的数
int s[10005];//s[i]表示：第i层共有多少楼梯
int n, m, pos, sum = 0;//pos为他从第1层哪里进入，sum为答案
int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
	{
		for(int j = 0; j <= m - 1; j++)
		{
			scanf("%d%d", &a[i][j], &to[i][j]);
			s[i] += a[i][j];//预处理
		}
	}
	scanf("%d", &pos);//以上为输入
	for(int i = 1; i <= n; i++)//由下往上遍历每一层
	{
		int find = to[i][pos], cnt = 0;
		cnt += a[i][pos];//先算自己
		sum = (sum + find) % 20123;//计算，更新答案
		find = (find - 1) % s[i] + 1;//优化代码，减少循环次数
		while(cnt < find)//再算别人
		{
			pos = (pos + 1) % m;
			cnt += a[i][pos];
		}
	}
	printf("%d", sum);//输出
	return 0;
}
```


### 无注释版：
```cpp
#include<bits/stdc++.h>
using namespace std;

int a[10005][105];
int to[10005][105];
int s[10005];
int n, m, pos, sum = 0;
int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
	{
		for(int j = 0; j <= m - 1; j++)
		{
			scanf("%d%d", &a[i][j], &to[i][j]);
			s[i] += a[i][j];
		}
	}
	scanf("%d", &pos);/
	for(int i = 1; i <= n; i++)
	{
		int find = to[i][pos], cnt = 0;
		cnt += a[i][pos];
		sum = (sum + find) % 20123;
		find = (find - 1) % s[i] + 1;
		while(cnt < find)
		{
			pos = (pos + 1) % m;
			cnt += a[i][pos];
		}
	}
	printf("%d", sum);
	return 0;
}
```
[评测记录](https://www.luogu.com.cn/record/197598894)。

---

## 作者：yekc2010 (赞：1)

## 题意。
有一个 $n$ 层的房子，每层 $m$ 间房间，每层的房间围成了圈，你要从底层到 $n+1$ 层。

每间房间有一个数表示是否有楼梯上楼（$0$ 表示没有，$1$ 表示有）；另一个指示牌上的数表示，要从当前房间开始逆时针走到第几个有楼梯的房间。

问每层到的第一个房间的指示牌上的数总和。

## 思路。
**先**输入，用一个二维结构体存储，是否有楼梯和指示牌的数。

```cpp
struct node{
	int b,x;//b表示是否有楼梯，x表示指示牌的数
}a[10010][110];
```
#### 然后开始枚举每层的情况。
用一个变量 $k$ 表示要走几个房间，$x$ 表示当前房间编号。得到 $k = a[i][x].x$。


特殊情况：当现在所在房间就是有楼梯时，现在房间也要算上，所以要 $k - 1$。


**不过**，这样的时间复杂度太大了，因为当 $a[i][x].x$ 大于当前楼层有楼梯的房间数时，会重复走房间。

于是用数组 $a1[10010]$ 记录每层有楼梯的房间数，优化后得到：$k = (a[i][x].x-1) \bmod a1[i] + 1$。

**最后**逆时针开始枚举每个房间的情况就是了。
```cpp
while(k--){//要走k个有楼梯的房间
	x++;//下一个房间
	if(x>m) x=1;//因为是个圆所以首尾相接
	while(!a[i][x].b){
		x++;
		if(x>m) x=1;
	}
}
```

## 做法。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
int n,m,x,mod=20123;//x表示当前房间编号
ll ans;//存每层到的第一个房间的指示牌上的数总和
struct node{
	int b,x;//b表示是否有楼梯，x表示指示牌的数
}a[10010][110];
int a1[10010];
int main(){
	IOS
    cin>>n>>m;
    //输入
    for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j].b>>a[i][j].x;
			if(a[i][j].b){
				a1[i]++;//房间数
			}
		}
	}
	cin>>x;
	x+=1;//因为房间编号从0开始
    for(int i=1;i<=n;i++){
    	//cout<<i<<" "<<x<<" "<<a[i][x].x<<"\n";
    	ans+=a[i][x].x;//加上指示牌上的数
    	ans%=mod;//记得取模
		int k=(a[i][x].x-1)%a1[i]+1;//见思路
		if(a[i][x].b){	
			k--;   
		}
		while(k--){
			x++;//下一个房间
			if(x>m) x=1;//因为是个圆所以首尾相接
			while(!a[i][x].b){
				x++;
				if(x>m) x=1;
			}
		}
	}
	ans%=mod;//取模
	cout<<ans;//输出
	return 0;
}
```

---

## 作者：qhr2023 (赞：1)

## solution

一道模拟题。

本题就是模拟按指示牌上的数字 $x$ 找房间的过程，但 $x$ 太大了，不能直接模拟，想到取模优化，即到每层时将当前房间的 $x$ 对当前层的有楼梯房间数取模，取模后为 $0$ 后需要特判，这样取模之后再直接遍历查找房间即可。每层有楼梯房间数可以预处理。

[通过记录](https://hydro.ac/record/6781517ee36c396ca82d601b)。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[10005][105], b[10005][105], x, cnt[10005], ans;
int main () {
	cin >> n >> m;
	for (int i=1; i<=n; ++i)
		for (int j=0; j<m; ++j)
			cin >> a[i][j] >> b[i][j],
			cnt[i]+=a[i][j];
	cin >> x;
	for (int i=1; i<=n; ++i) {
		ans=(ans+b[i][x])%20123;
		b[i][x]%=cnt[i];
		if (!b[i][x])
			b[i][x]=cnt[i];
		for (int j=x, num=0; ; ++j) {
			if (j==m)
				j=0;
			num+=a[i][j];
			if (num==b[i][x]) {
				x=j; 
				break;
			}
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Eric1030 (赞：1)

这是一道不太难的**模拟题**。但我交了 $2$ 遍才通过，有以下原因。

1. 刚开始没看懂题（似乎这是件尴尬的事情）。

1. 没有优化。

接下来我们就开始讲题了。


---



首先我们把数据都输入进来，然后进行一个模拟就可以了，但在模拟时要注意，房间和编号都是逆时针。

那么到底模拟什么呢？我们要模拟当前的位置。

看完这一小点思路或许你就能写出代码了，就像下面的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, fr, a[10005][105], b[10005][105], cnt[10005], yl, t;
long long sum;
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)//i表示每层楼，从1楼到n楼（顶层不算）
	{
		for (int j = 0;j <= m-1;j++)//j表示每个房间，从0号房间到m-1号房间
		{
			cin >> a[i][j] >> b[i][j];
		}
	}
	cin >> fr;
	for (int i = 1;i <= n;i++)
	{
		sum += b[i][fr];//把指示牌上的数加到sum里
		sum %= 20123;//模除20123，避免sum超出20123
		yl = 0;
		for (int j = fr;;j++)//开始逆时针找
		{
			if (j == m )//到头了，从0开始
			{
				j = 0;
			}
			if (a[i][j] == 1)
			{
				yl++;
			}
			if (yl == b[i][fr])//找到了
			{
				t = j;
				break;
			}
		}
		fr = t;//把退出内层循环时的j存到fr中，以便下次循环使用
	}
	cout << sum;
	return 0;//结束！
}
```
当你自信满满的提交时，你就会得到 [TLE 的拥抱](https://www.luogu.com.cn/record/197580418)。

因为 $n\le10^5$，$m\le10^3$，向上面这种暴力模拟一定会超时，所以我们就要给代码优化一下。

注：讲解在代码中有，我就不在这里详细讲解了。

就像这样。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, fr, a[10005][105], b[10005][105], cnt[10005], yl, t;
long long sum;
int main()
{
	cin >> n >> m;
	for (int i = 1;i <= n;i++)//i表示每层楼，从1楼到n楼（顶层不算）
	{
		for (int j = 0;j <= m - 1;j++)//j表示每个房间，从0号房间到m-1号房间
		{
			cin >> a[i][j] >> b[i][j];
			if (a[i][j] == 1)//看当前房间有没有楼梯
			{
				cnt[i]++;//如果有，当前楼层楼梯数+1
			}
		}
	}
	cin >> fr;
	for (int i = 1;i <= n;i++)//循环（i代表当前在第i层）
	{
		sum += b[i][fr];//把指示牌上的数加到sum里
		sum %= 20123;//模除20123
		yl = 0;
		for (int j = fr;;j++)//开始逆时针找
		{
			if (j == m)//出环了，重新从0开始（这个判断要放在第一位，因为有了它，才能让第二个循环的j不出界）
			{
				j = 0;
			}
			if (a[i][j] == 1)
			{
				yl++;
			}
			if (yl == (b[i][fr] - 1) % cnt[i] + 1)//找到了，用(b[i][fr] - 1) % cnt[i] + 1可以减少时间复杂度，因为逆时针第n个和逆时针第(n-1) % 当前楼层的楼梯数 +1的结果一样，大家可以去试一试
			{
				t = j;
				break;
			}
		}
		fr = t;//把退出内层循环时的j存到fr中，以便下次循环使用
	}
	cout << sum;//输出
	return 0;//结束！
}
```
现在就能 [AC](https://www.luogu.com.cn/record/197581932) 啦！

---

## 作者：ShirasuAzusaSaikou (赞：1)

典型的模拟题。  
唯一需要注意到的事情就是对于每层楼需要找到有楼梯的房间的次数可以取模优化，让最坏复杂度下降，无需重复走上限的 $10^6$ 次，上限减到房间数量上限 $100$ 。  
取模有些要点需要处理，首先需要计算每层楼有多少个房间有楼梯，然后每层要走的次数对每层楼楼梯房间数取模。  
注意：当得出的值为 $0$ 时，走的房间将为除自身外顺时针的第一个房间，若是采取的 $s-1$ 的做法，需要防止溢出问题。~~不然可能会 $40pt$ （逃~~  
代码如下：  

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, s, sum = 0;
int r[10001][101]; //房间的数字
bool t[10001][101]; //true：有楼梯 false：无楼梯
int stairs[10001]; //每层楼有楼梯的房间数

#define mod 20123

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin >> n >> m;
    memset(stairs, 0, sizeof stairs);
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            cin >> t[i][j] >> r[i][j];
            stairs[i] += t[i][j];
        }
    }
    cin >> s; //起始点
    for(int i = 0; i < n; i++){
        //cntm：需要走的第N哥房间取模，cnt：次数
        int cntm = r[i][s] % stairs[i], cnt = 0; 
        sum = (sum + r[i][s]) % mod; //每回合加进密钥
        //当取模值为0，除自身外顺时针第一个
        if(cntm == 0){
            s = (s - 1 + m) % m; //对s减1，防止溢出
            for(; s >= 0; s--){
                if(t[i][s]) break;
                if(s == 0) s = m; //若是到0，从后继续循环
            }
            continue; 
        }
        for(int j = s; j < m; j++){
            if(t[i][j]) cnt++;
            if(cnt == cntm){
                s = j; //改变s的值
                break;
            }
            //若是到m-1，从0继续循环
            if(j == m - 1) {
                j = -1;
            }
        }
    }
    cout << sum << endl;
    return 0;
}

```

---

## 作者：GSQ0829 (赞：1)

### 思路：
这题一看到，我就想到了约瑟夫的周期问题。周期问题取模是关键，我们只需要处理周期时的循环以及取模的地方

所以，本题我们有两种方法：

1. 用 ```vector``` 来做。
2. 用普通的循环来做。


---
### code:
方法一：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 20123;

// 方法一
int n, m, t, x, e, cnt = 0, ans = 0;
vector<vector<pair<int, int> > > v;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++) {
		vector<pair<int, int> > vv;
		for (int j = 0; j < m; j++) {
			scanf("%d%d", &t, &x);
			vv.push_back(make_pair(t, x));
			if (t) cnt++;
		}
		vv.push_back(make_pair(0, cnt));
		v.push_back(vv);
		cnt = 0;
	}
	scanf("%d", &e);
	for (int i = 0; i < n; i++) {
		ans = (ans + v[i][e].second) % mod;
		if (i == n - 1) break;
		int l = (v[i][e].second - 1) % v[i][m].second + 1;
		if (v[i][e].first) l--;
		while (l) {
			e = ++e % m;
			if (v[i][e].first) l--;
		}
	}
	printf("%d\n", ans % mod);
	return 0;
}
```

方法二：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 20123;

// 方法二
const int N = 10001, M = 101;
int n, m, a[N][M], num[N][M], key, lo;

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			scanf("%d%d", &a[i][j], &num[i][j]);
			if (a[i][j]) a[i][0]++;
		}
	}
	cin >> lo;
	lo += 1;
	for (int i = 1; i <= n; i++) {
		key += num[i][lo];
		key %= mod;
		int x = num[i][lo] % a[i][0] + a[i][0];
		lo--;
		while (x) {
			lo++;
			if (lo > m) lo = 1;
			if (a[i][lo]) x--;
		}
	}
	cout << key % mod;
	return 0;
}
```

---

## 作者：ZYX0716 (赞：1)

[时空隧道](https://www.luogu.com.cn/problem/P1076)

很明显这是一道**模拟**题，需要注意的是循环时的边界设置以及赋值。

## 思路：

对于每一层第一个进入的房间，其指示牌上的数表示要找出此层中第几个有楼梯的房间。最终的密钥就是所有层第一个进入的房间指示牌上的数累加后得到的值。

## 注意：

1. 由题得：每一层的房间围成一个圈，编号从 $0$ 开始。

1. 由于 $x$ 的最大值是 $10^6$ ，如果直接模拟寻找过程会超时，因此需要将 $x$ 模那一层的楼梯数，从而最多只需模拟一圈。

### AC代码
```cpp
 #include<bits/stdc++.h>
using namespace std;
const int mod=20123;
int n,m;
//n为除顶层外藏宝楼的层数，m为除顶层外每层的房间数。
int a[10005][205];
//a数组表示(i,j)房间是否有楼梯通往(i+1,j)房间。
int b[10005][205];
//b数组记录(i,j)房间指示牌上的数字。
int c[10005];
//c(i)是第i层中通往(i+1)层的楼梯的数量。
int x;
//表明出发点在底层x号房间。
int ans;
//ans是小明打开宝箱的密钥。
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=0;j<m;j++){
		//每层房间编号从0开始。
			cin>>a[i][j]>>b[i][j];
			c[i]+=a[i][j];
			//c[i]每次累加第i层j号房间是否有楼梯，若有则加1。
		}
	}
	cin>>x;
	for(int i=1;i<=n;i++){
		ans=(ans+b[i][x])%mod;
		//ans累加这层第一个进入的房间指示牌上的数。
		int cnt=0;
		//cnt在内循环中记录已经找到的楼梯数量。
		for(int j=x;j<m;j++){
//注意：j之所以从x开始，是因为此时小明正在(i,j)房间，如果这里有楼梯，也是算作第一个找到的。
			if(a[i][j]) cnt++;
			//判断(i,j)房间里是否存在楼梯；若存在，则计数器加1。
			if(cnt==(b[i][x]-1)%c[i]+1){
			//找到了第i层第b[i][x]个有楼梯的房间。
				x=j;
				break;
				//确定(i+1)层的起始房间号，并退出。
			}
			if(j+1==m)j=-1;
			/*由于j是从x开始的，而j+1==m时答案在x号房间之前，因此需要从头开始找。
这里需要注意：不能将j赋值为0，因为每次循环结束时j都会+1，所以应赋值为-1。
			*/
		}
	}
	cout<<ans%mod;
	//保险起见ans再模一次20123。
	return 0;
}
```
如有意见或疑问请私聊。

谢谢大佬！

---

## 作者：cath20 (赞：0)

[题目传送锚点](https://www.luogu.com.cn/problem/P1076)

[在博客园食用更佳](https://www.cnblogs.com/cath20/p/18678422)

本题纯纯模拟题，甚至连大模拟都算不上。别问我是怎么知道的，问就是看那恶心的题目描述、标签和题目难度仅为黄知道的。

好了，上思路。

既然是大模拟，那就按照题目描述给的思路来，一层一层往上爬呗。一下是两点注意事项：

1. 输入时，可以考虑用二维数组或结构体存储。若用普通一维数组，就不太好“上楼”；
2. 找到一个数字，准备在那一层的房间周围转圈圈的时候，应在预处理时统计一下本层有几个有楼梯的房间，以便取模，不然会超时。

大概就这些了。你学废了吗？

为防止抄袭，代码就不贴了。~~我绝对不会告诉你，我其实是怕码风太丑被喷才不贴代码的。。。~~

---

## 作者：wang6w6 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1076)

[惨不忍睹的记录](https://www.luogu.com.cn/record/list?pid=P1076&user=1051310)
## 思路
输入的同时算出每层楼的楼梯数，到每一层第一个房间时，先走到**第一个有楼梯**的房间，如果一开始就有楼梯就不用走，然后算出真正走了几个房间，也就是忽略循环时重复的，再一个一个推即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e4+5;
const int mouse_king=20123;
ll n,m,a[N][109],f[N][109],ans,now,t;
ll T[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(ll i=1;i<=n;i++){
		for(ll j=0;j<m;j++){
			cin>>f[i][j]>>a[i][j];
			T[i]+=f[i][j];//每层楼梯数 
		}
	}
	cin>>now;
	for(ll i=1;i<=n;i++){
		ll cnt=now;
		ans+=a[i][now];//求和 
		ans%=mouse_king;
		for(ll j=now;;j++){
			if(j==m) j=0;
			if(f[i][j]==1){
				now=j;//第一个有楼梯的房间 
				break;
			}
		}
		if((a[i][cnt]-1)%T[i]==0){//最后走到他自己的情况 
			continue;
		}else {
			t=(a[i][cnt]-1)%T[i];//于题目中走的方式等价，其实就是余数运算，动动手很简单 
		}
		for(ll j=now+1;;j++){//一定要从now+1开始！！！ 
			if(j==m) j=0;
			if(f[i][j]==1){
				t--;
				if(t==0){
					now=j;//上楼的房间号 
					break;
				}
			}
		}
	}
	cout<<ans%mouse_king;//qwq
	return 0;
}
```

---

## 作者：zsq9 (赞：0)

[AC 记录](https://www.luogu.com.cn/record/197503277)

## 题目大意

一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字 $x$，表示从这个房间开始按逆时针方向选择第 $x$ 个有楼梯的房间（假定该房间的编号为 $k$），从该房间上楼，上楼后到达上一层的 $k$ 号房间。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间，每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。

## 思路

这题一看到就很容易想到是约瑟夫的周期问题加上纯模拟，通过依靠下一层的楼梯给的关系，找到上一层的位置。就可发现模拟很容易做，怎么做呢？我们知道从 $j$ 号房间的楼梯爬到上一层到达的房间一定也是 $j$ 号房间，所以当到了这可以上楼时我们就上楼然后去找就可以了，但这样会超时，所以我们需要知道周期时的循环以及取模的地方，当我们知道周期时的循环以及取模的地方，循环就是 $c_i$，所以每次模一下 $c_i$ 就可以了。
![](https://cdn.luogu.com.cn/upload/image_hosting/ausrkptc.png)



## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,i,j,s,t,a[10005][105],x[10005][105],c[10005];
int main(){
ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for( i=1;i<=n;i++){
		for( j=0;j<m;j++){
			cin>>a[i][j]>>x[i][j];
			c[i]+=a[i][j];
		}
	}
	cin>>j;
	for(int i=1;i<=n;i++){
		s=(s+x[i][j])%20123;
		t=(x[i][j]-1)%c[i]+1; 
		while(t>0){
			if(j>m)j=0;
			if(a[i][j]==1)t--;
			j++;
		}
		j--;
	}
	cout<<s%20123;
return 0;
}
/*
2 3
1 2
0 3
1 4
0 1
1 5
1 2
1
*/
```

---

## 作者：lam_dyr (赞：0)

小模拟题。

## 模拟过程

开始时小明从第 $0$ 层进入，进入第一层的房间编号为 $t$。

对于每一层，做如下操作：
- 将当前房间的 $x$ 值加入总和中。
- 根据当前房间的 $x$ 值，按逆时针方向选择第 $x$ 个有楼梯的房间。如果当前房间有楼梯，则从当前房间开始计数；否则，从下一个房间开始计数。
- 小明通过选择的楼梯上楼，进入上一层的同编号房间，一直到到达顶层为止。

注意如果 $x=0$ 且当前房间有楼梯，则小明停留在当前房间。

具体细节见代码。
## Code

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
int n, m;
int fl[10010][110][2], st[110], ord[110];
//fl[i][j][0]：表示第 i 层第 j 个房间是否有楼梯（1 表示有，0 表示没有）
//fl[i][j][1]：表示第 i 层第 j 个房间的指示牌上的数字
//st 存当前层有楼梯的房间编号
//ord 存当前层楼梯的有序编号，排序规则取决于当前房间是否有楼梯
ll sum;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL); 
    cin >> n >> m;
    for(int i=1; i<=n; i++){
        for(int j=0; j<m; j++)
            cin >> fl[i][j][0] >> fl[i][j][1];
    }
    int t;
    cin >> t;
    for(int i=1; i<=n; i++){
        sum += fl[i][t][1];
        sum %= 20123;
        int c = 0;
        for(int j=0; j<m; j++) if(fl[i][j][0] == 1) st[c++] = j;
        if(c == 0) continue;
        sort(st, st + c);
        int oc=0;
        if(fl[i][t][0] == 1){// 有楼梯 
            auto it = lower_bound(st, st+c, t);
            int pos = distance(st, it);
            for(int p=pos; p<c; p++) ord[oc++] = st[p];
            for(int p=0; p<pos; p++) ord[oc++] = st[p];
        }
        else{// 没有楼梯 
            auto it = upper_bound(st, st+c, t);
            int pos = distance(st, it);
            for(int p=pos; p<c; p++) ord[oc++] = st[p];
            for(int p=0; p<pos; p++) ord[oc++] = st[p];
        }
        int x = fl[i][t][1];
        int nxt;
        if(x == 0)
            nxt = t;
        else{
            int k = x % c;//确定选择的楼梯位置
            if(k == 0) k = c;//特判，选择最后一个楼梯
            nxt = ord[k-1];
        }
        t = nxt;
    }
    cout << sum % 20123;
    return 0;
}
```

---

## 作者：qusia_MC (赞：0)

纯纯爆搜。

思路很好懂，由于不能一个个枚举从哪个楼梯上去，可以直接取模，一层楼梯数也就那么多，取个膜不就行了么。

具体看 
## 代码

```
#include <bits/stdc++.h>
using namespace std;
struct node {
	int qz, lt;
};//每个节点
struct node2 {
	int lc, fj, sum;
};//记录当前到的点
int main()
{
	int n, m, sum[10010], st;
	cin >> n >> m;
	node a[n + 1][m + 1];
	int vis[n + 1][m + 1];
	for (int i = 1; i <= n; i ++)
	{
		int cnt = 0;
		for (int j = 1; j <= m; j ++)
		{
			int x, y;
			cin >> x >> y;
			if (x == 1) cnt ++;
			a[i][j].lt = x;//有没有楼梯，1有0没有
			a[i][j].qz = y;//记录牌子上的数字
		}
		sum[i] = cnt;//这个记录每层的楼梯数
	}
	cin >> st;
	st ++;
	node2 t;
    t = {1, st, a[1][st].qz};//开始
	for (int i = 1; i <= n; i ++)
	{
		if (t.lc == n)
		{
			cout << (t.sum) % 20123;//随时取模好习惯
			return 0;
		}
		//cerr << "当前正在寻找 " << t.lc << " 楼的 " << t.fj << " 号房间，当前密钥累计为" << t.sum << endl;
//这块是调试的，注意一定把cerr删了，提交的时候，不然会卡你时间，就像我最短路被卡了
		int lt = a[t.lc][t.fj].qz % sum[i];//取模一下
        if (lt == 0) lt = sum[i];
		int cmt = 0, go;
		for (int i = t.fj; ; i ++)
		{
			if (i > m) i = 1;
			if (a[t.lc][i].lt == 1) cmt ++;
			if (cmt == lt)
			{
			    go = i;break;
			}//往后找第几个有楼梯的
		}
		t = {t.lc + 1, go, (t.sum + a[t.lc + 1][go].qz) % 20123};//往上走一层。
	}
	return 0;
}
```

本代码时间复杂度 $O(nm)$，空间也是 $nm$ 级别的，可以通过本题。

当然，也可以利用~~维克托~~ vector 存一下每个楼层的楼梯，可以优化掉一个 $m$ 的复杂度，当然，有兴趣追求最优的可以去写，我是不想写了~~我懒~~反正过了，管他呢。

---

## 作者：lihl (赞：0)

### Pre
普及组赛前集训模拟赛爆 $0$ 原题。
### 分析
小模拟。

令 $f_{i,j}\in\left\{0,1\right\}$ 表示位于 $(i,j)$ 的房间是否有楼梯，令 $r_i = \sum_{j=1}^{n} f_{i,j}$，令 $a_{i,j}$ 表示位于 $(i,j)$ 的房间的数字。

则不难发现，位于第 $i$ 层时，密码 

$$ans = (ans + a_{i,x})\bmod 20123$$

所指的房间 $s$ 为

$$ s=\begin{cases}
a_{i,x} \bmod r_i & t\ne 0\\
r_i & t=0
\end{cases}$$

这样就略去了浪费时间的循环找房间。到下一楼层时，若该房间有楼梯，即 $f_{i,x} = 1$，则 $s\to s-1$ 以满足题目要求。

接下来，以 $x$ 为指针循环找房间即可。具体地，$x\to(x+1)\bmod m$。

时间复杂度 $\mathcal{O}(n\sum s)$。

---

## 作者：LG086 (赞：0)

你要到达楼的第 $n+1$ 层。前 $n$ 层，每层有 $m$ 个房间，每个房间上都有数字，并且有的房间可以通向下一层。让你给出密码开宝箱。密码就是前 $n$ 层每层第一个进入的房间的指示牌的数字之和对 $20123$ 取模的结果。

注意到有 $0\lt n \le 10^4,0\lt m \le 10^2$，而 $x \le 10^6$。  
若每一层都循环遍历找第 $x$ 个有楼梯去下一层的房间，那么时间复杂度巨大，大概率无法通过。  
于是我们可以数出每一层都有几个房间存在楼梯。记第 $i$ 层有 $cnt_i$ 个房间，那么第 $x$ 个有楼梯的房间实际上就是该层第 $(x-1)\bmod cnt_i + 1$ 个有楼梯的房间。这样遍历次数大大减少。重复这样的操作知道你走到第 $n+1$ 层，就可以得到开宝箱的密码。

当然，你还需要注意的是：
>房间编号从 $0$ 开始。

代码略。  
我相信你已经可以拿到密码了。

---

## 作者：_H17_ (赞：0)

## 题目分析

中模拟，一定要理解好题意。

首先暴力模拟是 $O(N\times x)$，这显然不行（卡常的加油）。

考虑怎么样快速跳到一个有楼梯的。显然 $x$ 足够大的时候可以在楼中所有有楼梯的盘旋好几圈。但是这好几圈没有用，直接对总有楼梯数取余就行了。

最后时间复杂度 $O(N\times M)$。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,b[10001][1001],c[10001],ans;
bool a[10001][1001];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d%d",&a[i][j],&b[i][j]),c[i]+=a[i][j];
    scanf("%d",&k);
    k++;
    for(int i=1;i<=n;i++){
        ans+=b[i][k],ans%=20123;
        int x=b[i][k],cnt=0;
        x=(x-1)%c[i]+1;
        if(a[i][k])
            cnt++;
        while(cnt<x){
            k=k%m+1;
            if(a[i][k])
                cnt++;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：AIregister (赞：0)

## 题意 ##
告诉你每层的房间数，依靠指示牌的数字找到上一层的房间即可
## 思路 ##
只要一层一层的模拟每个房间即可，我们从 $j$ 号屋爬到的一定是下一层的 $j$ 号屋。我们用变量 $pos$ 来存储位置。
但是暴力肯定会超时，因为数据很大，所以我们发现了周期，用找的次数模楼层门数即可，但是如果号码为该层楼梯门个数，也就是余数为零，为保证正确性，加一再模即可，建议使用 scanf 呦，超时了别怪我
## 代码 ##
```cpp
#include <bits/stdc++.h>
using namespace std;
const int size=20123;
long long al = 0;
int k;
int s[10001][101], a[10001][101];
int n, m;
int main() {
	cin >> n >> m;
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < m; j++) {
			scanf("%d%d", &s[i][j], &a[i][j]);
			if (s[i][j] == 1) {
				sum++;
			}
		}
	}
	cin >> k;
	for (int i = 1; i <= n; i++) {
		int x = a[i][k];
		al = (al + x) % size;
		int t = 0;
		for (int j = 0; j < m; j++) {
			t += s[i][j];
		}
		x %= t;
		if (x == 0) {
			x = t;
		}
		if (s[i][k]) {
			x--;
		}
		while (x) {
			k = (k + 1) % m;
			if (s[i][k]) {
				x--;
			}
		}
	}
	cout << al % size;
	return 0;
}
```
如有任何问题请在评论区@我，管理大大求过！

---


# 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

## 样例 #1

### 输入

```
5 1 5
3 3 1 2 5
```

### 输出

```
3
```

# 题解

## 作者：_H17_ (赞：292)

## 题目分析

这是一道最短路问题，可以理解为每次建两条边，$i(1\le i \le n) \to i-K_i(1\le i-K_i),i+K_i(i+K_i\le n)$。

实现的算法比较多，下面会讲几乎所有方法。

## Dijkstra——单源非负权最短路

[模板题](/problem/P4779)，[关于 Dijkstra](https://oi-wiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95)。

每次建边，边权为一。

以 $A$ 为出发点，跑最短路最后输出 $D(B)$。

时间复杂度 $O(n \log n)$。

## Dijkstra 代码实现

```cpp
#include<bits/stdc++.h>
#define st first
#define nd second
using namespace std;
typedef pair<int,int> Pair;
int n,s,k,dis[100001],w[200001],tar[200001],nxt[200001],head[200001],tot;
bool u[100001];
priority_queue<Pair,vector<Pair>,greater<Pair> >q;
void add(int u,int v,int d){
    w[++tot]=d,tar[tot]=v,nxt[tot]=head[u],head[u]=tot;//邻接表存储
    return;
}
void dijkstra(int s){//Dijkstra
    q.push({0,s});
    dis[s]=0;
    while(!q.empty()){
        Pair p=q.top();
        q.pop();
        if(dis[p.nd]!=p.st)
            continue;
        for(int i=head[p.nd];i;i=nxt[i]){
            if(dis[tar[i]]>dis[p.nd]+w[i]){
                dis[tar[i]]=dis[p.nd]+w[i];
                q.push({dis[tar[i]],tar[i]});
            }
        }
    }
    return;
}
int main(){
    memset(dis,0x3f,sizeof(dis));//初始化无穷
    cin>>n>>s>>k;
    for(int i=1,v;i<=n;i++){
        cin>>v;
        if(i+v<=n)//判断越界
            add(i,i+v,1);
        if(1<=i-v)
            add(i,i-v,1);
    }
    dijkstra(s);
    cout<<(dis[k]==0x3f3f3f3f?-1:dis[k]);//注意-1
    return 0;
}
```

## SPFA——单源~~已逝~~带负权最短路

[模板 SPFA 判断负环](/problem/P3385)，[关于 SPFA](https://oi-wiki.org/graph/shortest-path/#%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96spfa "接着上文 Bellman-Ford 写的")。

由于本题目边权均为 $1$（非负），可以不考虑判断负环（但是代码里还是有）。

时间复杂度 $O(n)$（仅限本题特殊边权）。

## SPFA 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,dis[6001],f[6001],w[6001],tar[6001],nxt[6001],head[6001],tot;
bool u[6001];
queue<int>q;
void add(int u,int v,int d){
    w[++tot]=d,tar[tot]=v,nxt[tot]=head[u],head[u]=tot;
    return;
}
bool spfa(){
    q.push(a);
    dis[a]=0;
    u[a]=1;
    while(!q.empty()){
        int p=q.front();
        u[p]=0;
        q.pop();
        for(int i=head[p];i;i=nxt[i]){
            if(dis[tar[i]]>dis[p]+w[i]){
                dis[tar[i]]=dis[p]+w[i];
                if(!u[tar[i]]){
                    u[tar[i]]=1;
                    q.push(tar[i]);
                    if((++f[tar[i]])>=n)
                        return 1;//有负环（本题里不会出现）
                }
            }
        }
    }
    return 0;//无负环（本题里无需判断）
}
signed main(){
    memset(dis,0x3f,sizeof(dis));
    cin>>n>>a>>b;
    for(int i=1,v;i<=n;i++){
        cin>>v;//建图
        if(1<=i-v)
            add(i,i-v,1);
        if(i+v<=n)
            add(i,i+v,1);
    }
    spfa();//SPFA
    cout<<(dis[b]==0x3f3f3f3f?-1:dis[b]);//注意 -1
    return 0;
}
```

## DFS——深度优先搜索

从 $A$ 开始，搜索每一条路，可以更新答案再继续搜索，不然会搜索多余导致 TLE。

时间复杂度 $O(n^2)$。

## DFS 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k[201],dis[201];
void dfs(int node,int step){
	dis[node]=step;//一定可以更新
	int v=node-k[node];
	if(1<=v&&step+1<dis[v]/*可以更新在搜索*/)//下
		dfs(v,step+1);
	v=node+k[node];
	if(v<=n&&step+1<dis[v])//上
		dfs(v,step+1);
	return;
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)
		cin>>k[i];
	dfs(a,0);
	cout<<(dis[b]==0x3f3f3f3f?-1:dis[b]);
	return 0;
}
```

## Floyd——全源最短路

[模板题](/problem/B3647)，[关于 Floyd](https://oi-wiki.org/graph/shortest-path/#floyd-%E7%AE%97%E6%B3%95)。

本体数据范围很小，可以小题大做，求全源最短路。

时间复杂度 $O(n^3)$。

## Floyd 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,f[201][201];
signed main(){
    memset(f,0x3f,sizeof(f));
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++)
        f[i][i]=0;//自己
    for(int i=1,v;i<=n;i++){
        cin>>v;
        if(1<=i-v)//建边
            f[i][i-v]=min(f[i][i-v],1);
        if(i+v<=n)
            f[i][i+v]=min(f[i][i+v],1);
    }
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);//DP 求 Floyd
    cout<<(f[a][b]==0x3f3f3f3f?-1:f[a][b]);
    return 0;
}
```

## BFS——广度优先搜索

用一个队列，维护节点和步数。

开始入队 $(A,0)$，然后把上、下入队（合法的话），直到第一次出现 $B$，其实就是不记录 $dis$ 还不排序的 Dijkstra，记得打标记。

正确性：由于边权全部相等（都是 $1$），不需要用堆来进行排序（Dijkstra），直接用队列即可。

时间复杂度 $O(n)$，代码几乎同 SPFA（仅实现不同），是 Dijkstra 去掉堆优化（$\log n$）的复杂度。

## BFS 代码实现

```cpp
#include<bits/stdc++.h>
int n,a,b,k[201];
bool f,u[201];//u 是标记
int ri(){
	int x=0;
	char c=getchar(),f=1;
	while(c<'0'||c>'9'){
		if(c=='-')
			f=-f;
		c=getchar();
	}
	while(c<='9'&&c>='0')
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x*f;
}
struct node{
	int x,y;
};
std::queue<node>q;
int bfs(){
	q.push(node{a,0});//入队
	u[a]=1;
	while(!q.empty()){
		int x=q.front().x,y=q.front().y;
		q.pop();
		if(x==b)
			return y;//到了 B
		int xn=x+k[x],yn=y+1;
		if(xn<=n&&xn>0&&!u[xn])//上
			q.push(node{xn,yn}),u[xn]=1;
		xn-=2*k[x];
		if(xn<=n&&xn>0&&!u[xn])//下
			q.push(node{xn,yn}),u[xn]=1;
	}
	return-1;
}
int main(){
	n=ri(),a=ri(),b=ri();
	for(int i=1;i<=n;i++)
		k[i]=ri();
	printf("%d",bfs());
	return 0;
}
```

## Bellman-Ford——单源~~不如已逝算法~~带负权最短路

[模板 Bellman-Ford 判断负环](/problem/P3385 "由于是 SPFA 的原版，模板题相同")，[关于 Bellman-Ford](https://oi-wiki.org/graph/shortest-path/#bellmanford-%E7%AE%97%E6%B3%95)。

## Bellman-Ford 代码实现

```cpp
#include<bits/stdc++.h>
#define st first
#define nd second
using namespace std;
typedef pair<int,int> Pair;
int n,s,k,dis[100001],w[200001],tar[200001],nxt[200001],head[200001],tot;
bool u[100001];
void add(int u,int v,int d){
    w[++tot]=d,tar[tot]=v,nxt[tot]=head[u],head[u]=tot;
    return;
}
bool bellmanford(int s){//Bellman-Ford
    bool f=0;
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    for(int i=1;i<=n;i++,f=0){
        for(int u=1;u<=n;u++){
            if(dis[u]==0x3f3f3f3f)//不能松弛没有算出的点
                continue;
            for(int i=head[u],v,w;i;i=nxt[i]){
                v=tar[i],w=::w[i];
                if(dis[v]>dis[u]+w)
                    dis[v]=dis[u]+w,f=1;
            }
        }
        if(!f)//有负环（在本题中不可能出现）
            return 0;
    }
    return 1;
}
int main(){
    memset(dis,0x3f,sizeof(dis));
    cin>>n>>s>>k;
    for(int i=1,u,v,w;i<=n;i++){//建图
        cin>>v;
        if(i+v<=n)
            add(i,i+v,1);
        if(1<=i-v)
            add(i,i-v,1);
    }
    bellmanford(s);
    cout<<(dis[k]==0x3f3f3f3f?-1:dis[k]);
    return 0;
}
```



---

## 作者：yummy (赞：102)

# P1135 奇怪的电梯 solution

本题是一道非常经典的搜索练习题，在很多教材中都作为 DFS 或 BFS 的例题。然而由于当年出题人的意识薄弱，数据很水，很多时间复杂度未经证明的做法也被放了过去，并流传了下来。

我为了避免误导新人，制造了一些测试点卡掉常见的错误做法。

本题解将会较为详细地介绍各种做法的复杂度以及何时卡满。

## 最短路

Floyd, Bellman-Ford, Dijkstra 的复杂度和具体形态无关，时间复杂度分别为 $O(n^3)$，$O(n^2)$ 和 $O(n\log n)$。

SPFA 和 BFS 最坏时间复杂度是 $O(n)$。（其实你会发现，二者代码完全一致。）

## DFS+一些错误的优化

下面我们规定三种所谓“优化”：

- A：保证路径不重复经过结点。
- B：在当前步数大于等于当前答案时剪枝。
- C：倒着搜。

如果仅有 B，那么显然可以做到 $2^n$ 复杂度：只要全是 $1$ 即可。

C 本身其实不是优化，其本质相当于特判上一版数据中我的 Hack。

---

接下来主要难点就是——AB 都有时怎么卡。我目前不清楚其时间复杂度的最小上界，但是[三年前](https://www.luogu.com.cn/discuss/254934)我就给出了一个把时间复杂度卡成 $O(2^{n/3})$ 的卡法（我称之为“四边形链”）。

当时我为了图方便直接把终点设计成不可达，所以才有了倒着搜的“解法”。然而事实上，搜索四边形链时的复杂度和搜索顺序无关。

---

神通广大的谷民们并没有善罢甘休。他们有的人甚至写出来“如果要超时了那么直接输出答案”这种剪枝——因为在四边形链中，所有简单路径长度相等。要解决这个问题，我们就需要在前面加入一段二叉树，使得你在二叉树中必须选择正确的叶子结点进入四边形链，才能让步数最小。然而根据前面的特性，你规定时间内甚至无法搜索完一次四边形链。

为了防止谷民们特判答案，我还不得不引入一些随机，包括二叉树位置的摆动和终点的选取。

然而如果你不想要学习正确做法，却总想着通过特判过题，那么无论我怎么努力，都是防不住的。

## DFS+正确的剪枝

正确的剪枝是什么样的呢？

你应当考虑对每个结点 $s$ 都记录从起点到它的最少按键数 $ ans_s$。如果某一次你到 $s$ 时的步数 $t$ 并不比曾经的最优步数更优，那么就放弃搜索。例如，如果 $ans_3=6$（我曾经只花 $6$ 步就到达了 $3$ 楼），但是当前楼层是 $3$，步数为 $7$，则表明“我已经落后于我的最优记录，那么我接着往下走，不管走到哪都至少比记录落后 $1$ 步“，所以必须放弃。

你或许会问，这看上去和 B 也没有区别啊，怎么时间复杂度就对了呢？

你会发现，你每进入一次 DFS 函数，必然都会导致某一个 $ans$ 减少且至少减 $1$（否则就被剪枝了），然而每个结点的 $ans$ 至多被减少 $n$ 次，因此你只会进入 $O(n^2)$ 次 DFS 函数。

## 参考 DFS 代码

以下代码是我 2018 年的，代码风格和现在有所不同，变量名也起得不好。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int ans[205],a,b,dis[205]={0},n;
void dfs(int s,int t)
{
	ans[s]=t;
	//cout<<s<<" "<<t<<endl;
	if(s+dis[s]<=n && t+1<ans[s+dis[s]])
		dfs(s+dis[s],t+1);
	if(s-dis[s]>0  && t+1<ans[s-dis[s]])
		dfs(s-dis[s],t+1);
}
int main()
{
	//freopen("sample.in","r",stdin);
	memset(ans,0x7f,sizeof(ans));
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)
		cin>>dis[i];
	dfs(a,0);
	if(ans[b]!=0x7f7f7f7f)
		cout<<ans[b];
	else
		cout<<-1;
	return 0;
}
```





---

## 作者：cff_0102 (赞：46)

考虑用 BFS 实现，用队列存储从起点开始按 $t$ 次电梯后能到达的状态。

首先将起点入队（当然，起点和终点相等时直接输出 `0` 即可），接着重复循环，每次将队列中所有状态向前推一步。

- 如果到达了之前已经到达过的状态，那么没必要推下去，重复之前走过的路。
- 如果到达终点，直接输出当前一共向前推了几步。
- 如果到某个时刻队列为空，说明这一步没有可以到达的新的楼层了，而此时仍然没有到达目标楼层，所以直接输出 `-1`。

$N \le 200$，而每个楼层最多访问一次，所以不用担心超时。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[0xcff0102];
bool vis[0xcff0102];
int main(){
	ios::sync_with_stdio(false);
	int n,s,e;cin>>n>>s>>e;
	if(s==e){//初始楼层和目标楼层相同，不需要按电梯 
		cout<<0;
		return 0;
	} 
	for(int i=1;i<=n;i++)cin>>a[i];//输入
	queue<int>q;
	q.push(s);
	int t=0;vis[s]=1;
	while(++t){
		int x=q.size();
		if(x==0){//空了
			cout<<-1;
			return 0;
		}
		for(int i=0;i<x;i++){//将当前 q 中所有状态向前推一遍
			int p=q.front();
			q.pop();
			if(p-a[p]>0){//按下键时电梯不会跑到地底下 
				if(!vis[p-a[p]]){//这个状态没被访问过 
					if(p-a[p]==e){//到目标楼层啦 
						cout<<t;
						return 0;
					} 
					vis[p-a[p]]=1;
					q.push(p-a[p]);
				}
			}
			if(p+a[p]<=n){//按上键时电梯不会飞到天上 
				if(!vis[p+a[p]]){//这个状态没被访问过
					if(p+a[p]==e){//到目标楼层啦 
						cout<<t;
						return 0;
					} 
					vis[p+a[p]]=1;
					q.push(p+a[p]);
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：wmrqwq (赞：27)

# 题目链接

[P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)

# 解题思路

这题可以直接用深度优先搜索和剪枝，剪枝主要剪以下的部分：

1. 是否越界；

2. 这个位置是否之前抵达过且比现在抵达的次数要早；

3. 当前的次数是否超过了目前的答案。

只要判了这三点，就能轻松 AC 了。

# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,a[210],ans=1e18,minn[210];
void dfs(long long u,long long v,long long cs)
{
	if(u<1 || u>n)//剪枝1
		return ;
	if(cs>=minn[u])//剪枝2
		return ;
	if(cs>=ans)//剪枝3
		return ;
	if(u==v)//如果搜到了
	{
		ans=cs;//记录答案
		return ;
	}
	minn[u]=cs;//更新到达这个点的最小次数
	dfs(u+a[u],v,cs+1);
	dfs(u-a[u],v,cs+1);
}
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define endl '\n'
#define QwQ return 0;
int main()
{
	IOS;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i],minn[i]=1e18;
	dfs(m,k,0);
	if(ans!=1e18)
		cout<<ans;
	else
		cout<<-1;
	QwQ;
}
```

---

## 作者：liuyi0905 (赞：16)

一道很简单广搜题，在 `bfs` 里，直接按照题意去模拟即可。

只需判断向上走、向下走两种情况。若到达 $B$，则直接输出现在的步数；若队列已经为空，则返回 $-1$。

注意事项：
+ 不要忘记 `pop`。
+ 每走完一种情况，要记住标记。
+ 还要将起点入队

关键代码：
```cpp
int bfs(int s,int e){
	queue<node>q;
	memset(vis,0,sizeof(vis));
	q.push({s,0});
	while(!q.empty()){
		int v=q.front().v,p=q.front().step;
		q.pop();
		if(v==e)return p;
		int n1=v+k[v],n2=v-k[v];
		if(n1<=n&&!vis[n1])q.push({n1,p+1}),vis[n1]=1;
		if(n2>=1&&!vis[n2])q.push({n2,p+1}),vis[n2]=1;;
	}
	return -1;
}
```

---

## 作者：Pink_Cut_Tree (赞：11)

# P1135 奇怪的电梯 题解

搜索题，可以用深度优先搜索（DFS）和广度优先搜索（BFS）解决，这里讲一下 BFS 的做法。

### BFS 模板

BFS 使用**队列**完成，如果不知道队列是什么请跳转 [oi-wiki](https://oi-wiki.org//ds/queue/)。

```cpp
queue<类型>Q;
Q.push(最初状态);
while(!Q.empty()){
	类型 u=Q.front(); Q.pop();
	for(枚举所有可扩展到的状态){
		if(满足入队条件){
			Q.push(状态); //维护某些必要信息 
		}
	} 
} 
```

### 解析

首先我们把 $A$ 层入队。

对于队首的元素，如果是 $B$，则输出当前步数即可。

如果队列空了（但还没有搜到），输出 `-1`。

### 代码

```cpp
#include<queue>
#include<iostream>
using namespace std;
int n,a,b,ud[1005];
bool vis[1005]; //标记数组 
struct fl{
	int ans,id;
}u;
queue<fl>Q;
int main(){
	ios::sync_with_stdio(0);
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++){
    	cin>>ud[i];
	}
	Q.push((fl){0,a}); //推入初始值 
	while(!Q.empty()){
		u=Q.front();
		if(u.id==b){ //已经搜到答案了直接输出 
			cout<<u.ans; return 0;
		}
		Q.pop();
		if(u.id+ud[u.id]<=n&&vis[u.id+ud[u.id]]==0){ //判断没出界且该楼层还没来过 
			Q.push((fl){u.ans+1,u.id+ud[u.id]}); //入队 
			vis[u.id+ud[u.id]]=1; //打标记 
		}
		if(1<=u.id-ud[u.id]&&vis[u.id-ud[u.id]]==0){ //判断没出界且该楼层还没来过 
			Q.push((fl){u.ans+1,u.id-ud[u.id]}); //入队 
			vis[u.id-ud[u.id]]=1; //打标记 
		}
	}
	cout<<"-1"; //没有搜到答案 
return 0;
}  
```

### 题外话

《深入浅出（基础版）》对本题也有讲解，大家可以买来看。

---

## 作者：wwwidk1234 (赞：10)

[洛谷题目传送门！](https://www.luogu.com.cn/problem/P1135)

[我的个人博客！](https://wwwidk1234.github.io/)

## 前言
本题是一道经典搜索练习题。

前置知识：
- BFS 广度优先搜索算法。
- 队列。

## 解题步骤
首先看数据范围 $n \leq 200$ 很容易想到搜索，上、下楼的过程直接根据题意模拟即可。

这里用 $q$ 代表头指针，$p$ 代表尾指针的下一位，$Q$ 结构体数组用来储存队列元素。一开始 $q=1,p=2$，如果要入队则 `p++`，如果要出队则 `q++`。

## 完整代码
```cpp
//bfs广搜 
#include<bits/stdc++.h>
using namespace std;
int a,b,x[500]/*电梯上的数字*/;
bool vis[500];
int q,p; //头、尾指针 
int N;
struct node
{
	int floor,dep;
}Q[1000];
int bfs() //广搜 
{
	if(a==b) return 0; //如果开始层等于结束层,直接返回0步 
	int ans,top,k;
	Q[1]={a,0};
	q=1;p=2;
	while(q<p)
	{
		top=Q[q].floor;ans=Q[q].dep;
		for(int i=-1;i<=1;i+=2)
		{
			k=top+x[top]*i;
			if (k>=1&&k<=N&&!vis[k])
			{
				vis[k]=true;
				if(k==b) return ans+1;  //到达终点,返回答案 
				Q[p]={k,ans+1}; //入队列 
				p++;
			}
		}
		q++;
	}
	return -1;
}
int main()
{
	cin>>N>>a>>b;
	for(int i=1;i<=N;i++) cin>>x[i];
	cout<<bfs();
	return 0;
}
```

---

## 作者：tiger2008 (赞：10)

没想到前面的题解全被撤下了我就来写一篇吧。


所以这是道搜索题，对于每个楼层只能向上或向下两种方式，可以用深搜和广搜来完成，这边我用的是广搜。

这道题其实很适合当一个广搜的新手题的。

用一个队列存储要搜的位置，重复调取队头的变量并往下搜下去即可。

这边是代码：

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
struct node{
	int num;//电梯楼数
	int id;//你电梯动了几次
};
int n,a,b;
int arr[205];
bool f[205];
void bfs(){
	queue<node> q;//队列~
	q.push((node){a,0});
	while(!q.empty()){
		if(q.front().num==b){//到头了就直接输出吧
			cout<<q.front().id;
			return ;
		}
		int x1=q.front().num+arr[q.front().num];
		int x2=q.front().num-arr[q.front().num];
		if(x1>=1 && x1<=n && !f[x1]){
			f[x1]=true;
			q.push((node){x1,q.front().id+1});
		}
		if(x2>=1 && x2<=n && !f[x2]){
			f[x2]=true;
			q.push((node){x2,q.front().id+1});
		}
		q.pop();
	}
	cout<<"-1";//如果没搜到直接输出-1
	return ;
}
int main(){
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)cin>>arr[i];
	int ans=0;
	bfs();
	return 0;
}

```

总结：搜索板子题。

---

## 作者：___w (赞：7)

### [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)

#### 题意简述
$N$ 层电梯，第 $i$ 层可以上去或下去 $k_i$ 层，求 $A$ 层到 $B$ 层的最少次数，无法到达输出 $-1$。

#### 题目分析
经典 bfs 题。因为要求的是最少按键次数，所以自然想到 bfs。原因是 bfs 是广度优先搜索，第一次遇到的某个状态即为到这个状态的最优解。回到本题，我们可以设计状态 $(f,t)$ 表示当前到 $f$ 层，按键次数为 $t$。每次取出一个状态时，对上下进行拓展，并记录已经到达过的楼层。时间复杂度 $\Theta(n)$。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 205;
struct node { int f, t; } ;//f表示楼层，t表示次数 
int n, a, b, k[N], v[N];
queue <node> q;

int main() {
	ios::sync_with_stdio(0);
	cin >> n >> a >> b;
	for (int i = 1; i <= n; ++i) cin >> k[i];
	q.push((node){a, 0}), v[a] = 1;
	while (!q.empty()) {
		node now = q.front(); q.pop();
		if (now.f == b) cout << now.t, exit(0);
		for (int i = -1; i <= 1; i += 2) {//两种状态：向上和向下 
			int f = now.f+k[now.f]*i;
			if (f < 1 || f > n || v[f]) continue;//排除不合法的 
			q.push((node){f, now.t+1}), v[f] = 1;
		}
	}
	cout << -1;
	return 0;
}
```

---

## 作者：sssscy_free_stdio (赞：6)

较简单，用 BFS 又好写又快。

我们可以直接从 $A$ 开始搜，搜到 $B$ 为止，中间搜到的就标记，就说明不用再搜到这里了。

但是还要注意，有些楼层是不存在的，所以还要判断这个楼层是否合法，就是看它是否比 $1$ 大，比 $N$ 小。

中途，我们可以判断，如果已经到 $B$ 了，直接输出后结束程序。

如果搜到最后还是到不了 $B$，就输出 $-1$。

AC CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,h[210],vis[210];
struct node{
	int y,dis;
};
queue<node>q;
int main(){
    scanf("%d%d%d",&n,&a,&b);
    for(int i=1;i<=n;i++){
		scanf("%d",&h[i]);
	}q.push((node){a,0});
	while(!q.empty()){
		node x=q.front();
		q.pop();
		if(x.y==b){
			printf("%d",x.dis);
			return 0;
		}if(x.y+h[x.y]<=n&&vis[x.y+h[x.y]]==0){
			vis[x.y+h[x.y]]=1;
			q.push((node){x.y+h[x.y],x.dis+1});
		}if(x.y-h[x.y]>=1&&vis[x.y-h[x.y]]==0){
			vis[x.y-h[x.y]]=1;
			q.push((node){x.y-h[x.y],x.dis+1});
		}
	}printf("-1");
	return 0;
}
```

---

## 作者：xiaoshumiao (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P1135)

[使用博客阅读效果更佳](https://www.luogu.com.cn/blog/bianchengriji/solution-p1135)

这是一道搜索题，本题解介绍广度优先搜索（BFS）的做法。

相较于 DFS，BFS 更适合于解决“寻找走出迷宫的路线”这一类的题目。接下来给大家介绍一下如何用 BFS 实现这个问题。

1. 建立一个队列（不会队列的同学请出门右转至 [B3616 【模板】队列](https://www.luogu.com.cn/problem/B3616)）。

2. 将迷宫的入口的节点编号入队。

3. 取出队首。如果队首是终点，返回。否则，对上下左右四个方向扩展：如果该点没有被访问过，且该点没有越界，则将其入队。

4. 重复执行 3. 直到队列为空。

在本题中，迷宫的入口相当于楼层 $A$，迷宫的出口就相当于楼层 $B$。每次取出队首节点 $i$ 时，就向楼层 $i+K_i$ 和楼层 $i-K_i$ 扩展。

下面给出核心代码：
```cpp
const int MAXN=205;
int k[MAXN];
bool book[MAXN];//book[i]=0时表示第i层还没有被访问过，
                //book[i]=1时表示第i层被访问过。
struct F {
  int lc,bs;//由于题目求的是步数，所以建立一个结构体存当前楼层和步数。
};
int bfs(int n,int a,int b) {
  queue<F>q;//建立队列（步骤1）。
  q.push((F){a,0});//将楼层A入队（步骤2）。
  while(!q.empty()) {
    //------步骤3------
  	F f=q.front();//取出队首
  	q.pop();
  	if(f.lc==b)//是终点，返回步数。
  	  return f.bs;
  	if(f.lc+k[f.lc]<=n&&!book[f.lc+k[f.lc]]) {//向楼层i+k[i]扩展。
	  q.push((F){f.lc+k[f.lc],f.bs+1});
	  book[f.lc+k[f.lc]]=true;
  	}  	  
  	if(f.lc-k[f.lc]>=1&&!book[f.lc-k[f.lc]]) {//向楼层i-k[i]扩展。
	  q.push((F){f.lc-k[f.lc],f.bs+1});
	  book[f.lc-k[f.lc]]=true;
  	} 	  
  }
  return -1;//无法到达，返回-1。
}
```

---

## 作者：Argvchs (赞：5)

首先这种简单最短路的题，首先是建图然后再是最短路，我们伟大的费用流正好可以解决这一类的问题，这道题你只需要 $i$ 分别向 $i \pm K_i$ 连 $(1, 1)$ 的边然后跑最小费用最大流就可以轻松解决这个问题了。

但是这道题有一点不一样，直接跑可能流量大于 $1$，但是最短路是只能有一条的，可恶的最短路，可惜就算你路径有几条我伟大的费用流也能跑出正确最短路，怎么做呢？

我们只需要建一个新的汇点 $B'$ 然后 $B$ 向 $B'$ 连 $(1, 0)$ 的边，而最短路只能有一条？根本不在乎，我们直接这样连边，流量就不超过 $1$ 了，这样做就是对的，这世间，还有什么能够阻挡！！！！！还有什么能够阻挡我们的费用流算法！！！！！！！！！

时间复杂度 $O(n^3)$，可能还有一点小常数不过没有人在乎，这就是网络流算法的魅力，BFS 这种逆时代浪潮的做法迟早被淹没在费用流恐怖的实力之下！！！

大概就是上面这样。

```cpp
#include <bit>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
using u32 = unsigned;
using p32 = pair<int, int>;
const int N = 205, M = 405, INF = 0x3f3f3f3f;
int n, s, t, tt, a[N], h[N], dis[N], pos[N], siz[35], cur[N], head[N],
    cnt = 1, beg, top, flow, cost;
bool vis[N];
struct edge {
    int to, nex, w, c;
} e[M << 1];
queue<int> Q;
vector<int> buc[35], tmp;
void add(int u, int v, int w, int c) { e[++cnt] = {v, head[u], w, c}, head[u] = cnt; }
void addflow(int u, int v, int w, int c) { add(u, v, w, c), add(v, u, 0, -c); }
void spfa() {
    memset(h, 0x3f, sizeof(h));
    h[s] = 0, vis[s] = true, Q.push(s);
    while (!Q.empty()) {
        int u = Q.front();
        vis[u] = false, Q.pop();
        for (int i = head[u]; i; i = e[i].nex) {
            int v = e[i].to, w = e[i].w, c = e[i].c;
            if (h[v] > h[u] + c && w) {
                h[v] = h[u] + c;
                if (!vis[v]) vis[v] = true, Q.push(v);
            }
        }
    }
}
// radix heap
void insert(int x) {
    int k = bit_width<u32>(dis[x] ^ dis[top]);
    ++siz[k], pos[x] = buc[k].size(), buc[k].push_back(x);
}
void update(int x, int y) {
    int k = bit_width<u32>(dis[x] ^ dis[top]);
    --siz[k], dis[x] = y, insert(x);
}
void removemin() {
    pos[top] = -1, --siz[0];
    if (siz[0]) {
        while (pos[top = buc[0][beg]] == -1) ++beg;
        return;
    }
    int cur = 0, las = top;
    for (int i = 30; i >= 1; i--)
        if (siz[i]) cur = i;
    siz[cur] = beg = top = 0, tmp = move(buc[cur]);
    for (int i = 0; i <= cur; i++) buc[i].clear();
    for (int i = 0; i < (int)tmp.size(); i++) {
        int k = bit_width<u32>(dis[tmp[i]] ^ dis[las]);
        if (k == cur && pos[tmp[i]] == i && dis[tmp[i]] < dis[top]) top = tmp[i];
    }
    for (int i = 0; i < (int)tmp.size(); i++) {
        int k = bit_width<u32>(dis[tmp[i]] ^ dis[las]);
        if (k == cur && pos[tmp[i]] == i) insert(tmp[i]);
    }
}
bool dijkstra() {
    memset(dis, 0x3f, sizeof(dis));
    dis[top = s] = beg = 0;
    for (int i = 0; i <= 30; i++) siz[i] = 0, buc[i].clear();
    for (int i = 1; i <= n + 1; i++) insert(i);
    for (int i = 1; i <= n + 1; i++, removemin()) {
        if (dis[top] == INF) break;
        for (int j = head[top]; j; j = e[j].nex) {
            int v = e[j].to, w = e[j].w, c = e[j].c;
            if (dis[v] > dis[top] + c + h[top] - h[v] && w)
                update(v, dis[top] + c + h[top] - h[v]);
        }
    }
    return dis[t] != INF;
}
int dfs(int u, int flow) {
    if (u == t) return flow;
    int used = 0;
    vis[u] = true;
    for (int &i = cur[u]; i; i = e[i].nex) {
        int v = e[i].to, w = e[i].w, c = e[i].c;
        if (!vis[v] && dis[v] == dis[u] + c + h[u] - h[v] && w) {
            int ret = dfs(v, min(flow - used, w));
            used += ret, e[i].w -= ret, e[i ^ 1].w += ret;
            if (used == flow) break;
        }
    }
    vis[u] = false;
    return used;
}
void dinic() {
    int ret;
    spfa();
    while (dijkstra()) {
        memcpy(cur, head, sizeof(cur));
        memset(vis, 0, sizeof(vis));
        while ((ret = dfs(s, INF))) flow += ret, cost += ret * (dis[t] + h[t]);
        for (int i = 1; i <= n + 1; i++) h[i] += dis[i];
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> s >> tt, t = n + 1;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        if (i - a[i] >= 1) addflow(i, i - a[i], 1, 1);
        if (i + a[i] <= n) addflow(i, i + a[i], 1, 1);
    }
    addflow(tt, t, 1, 0);
    dinic();
    if (flow == 1) cout << cost;
    else cout << "-1";
    return 0;
}
```

---

## 作者：bigclever (赞：5)

## 思路：
可以发现 $N \le 200$，所以可以直接广搜（bfs），按题意模拟即可。对于 $i$ 号节点，可以向上走或者向下走，也就是可以走到 $i+k_i$ 或 $i-k_i$。注意判断拓展节点的范围是否合法（也就是是否在 $[1,n]$ 之间）。
## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int k[205];
bool vis[205];//标记数组 
int main(){
	int n,a,b;
    cin>>n>>a>>b;
    for(int i=1;i<=n;i++)cin>>k[i];
    queue<pair<int,int> > q;
    q.push({a,0}),vis[a]=true;//从a开始bfs 
    while(!q.empty()){
    	int t=q.front().first,step=q.front().second; q.pop();
    	if(t==b){cout<<step;return 0;}//如果到达了b，直接输出step即可
		//拓展节点
    	if(t+k[t]>0&&t+k[t]<=n&&!vis[t+k[t]])q.push({t+k[t],step+1}),vis[t+k[t]]=true;
		if(t-k[t]>0&&t-k[t]<=n&&!vis[t-k[t]])q.push({t-k[t],step+1}),vis[t-k[t]]=true;
	}
	cout<<-1;//如果bfs结束了还没有到达b，说明a无法到达b 
	return 0;
}
```

---

## 作者：yhx0322 (赞：4)

## Description
[题目传送门](https://www.luogu.com.cn/problem/P1135)
## Solution
这道题可以用 DFS，同样也可以用 BFS。

下面给出 BFS 求最短路的思路：

- 首先判断特殊情况：起点等于终点，直接输出 $0$。
- 将起始点放入队列 $q$ 中。注意这里使用的是手动模拟队列，而不是 STL 中的 `queue`。
- 因为要处理方向的变换，设置方向数组 $f$，值分别为 $1, -1$。每次循环两个方向，计算新的坐标：$q_h + {f}_{i} \times a_{q_h}$。这里 $h$ 代表当前头部元素的下标。
- 如果新的坐标 $oi$ 没有被标记过，便可以入队、标记、更新最短路了。
- 如果发现 $oi$ 正好等于终点，输出 $d_{oi}$ 即可。这里的 $d$ 数组代表起点到每个点的最短路。

## Code
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 210;
int n,s,e,a[N],q[N],d[N],t,h;
bool f[N];
int f[3] = {0,1,-1};


int main() {
	cin >> n >> s >> e;
	for (int i = 1;i <= n;i++) cin >> a[i];
	if (s == e) {
		cout << 0;
		return 0;
	}
	t = 1,h = 1;
	q[1] = s; d[s] = 0; f[s] = true; // 起点要标记
	int oi;
	while (h <= t) {
		for (int i = 1;i <= 2;i++) {
			oi = q[h] + f[i] * a[q[h]]; // 计算新的坐标
			if (oi >= 1 && oi <= n && !f[oi]) {
				t++;
                // 入队、标记、更新最短路
				q[t] = oi;
				d[oi] = d[q[h]] + 1;
				f[oi] = true;
				if (oi == e) { // 走到终点 e
					cout << d[oi];
					return 0;
				}
			}
		}
		h++;
	}
	cout << -1;
	return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 思路
把每一层抽象成一个点，把每一层坐电梯抽象成一条边。  
第 $i$ 层可以到第 $i+K_i,i-K_i$ 层，就是第 $i$ 个点向第 $i+K_i,i-K_i$ 分别连一条**无向边**，所有边的花费均为 $1$。  

之后就可以直接跑图了！  
由于所有边的花费均为 $1$，用 SPFA 来跑图时，每个点只会被更新一次，每条边只会被跑一次。  
时间复杂度为 $O(n+m)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
struct node{
	int to;
	int next;
	int val;
}edg[403];
//每个点可能有两条出边，所以边数要开到点数的两倍
int head[203];
bool vis[203];
ll ans[203];
queue<int> q;
int u,v;
int n,x;
int el;
int T;

void add(int from,int to,int val){
	++el;
	edg[el].to=to;
	edg[el].val=val;
	edg[el].next=head[from];
	head[from]=el;
}

void spfa(){
	q.push(u);
	ans[u]=0;
	while(!q.empty()){
		int f=q.front();
		q.pop();
		vis[f]=0;
		for(int i=head[f];i;i=edg[i].next){
			int t=edg[i].to;
			if(ans[t]>ans[f]+edg[i].val){
				ans[t]=ans[f]+edg[i].val;
				if(!vis[t]){
					vis[t]=1;
					q.push(t);
				}
			}
		}
	}
	if(ans[v]<1e9)printf("%d",ans[v]);
	else puts("-1");
}

int main(){
	scanf("%d%d%d",&n,&u,&v);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		if(i-x>0)add(i,i-x,1);
		if(i+x<=n)add(i,i+x,1);
		ans[i]=1e9;
	}
	spfa();
	
	return 0;
}
```

---

## 作者：Super_Builder (赞：3)

## 思路
我写的好像是动规的做法。

设 $f_{i,j}$ 表示第 $i$ 步 $j$ 个点是否可以走到，值要么为 $1$，要么为 $0$。最多走 $n$ 步，因为总共只有 $n$ 个点，每一步都肯定会多延伸出一个点，要不然就重复计算。

不难得出转移公式：

$f_{i+1,j+k_j}=f_{i,j}$  
$f_{i+1,j-k_j}= f_{i,j}$

解释一下，因为只能从后往前，不然如果从当前往上一步就有需要一层循环。

注意：

- 第一个转移执行前提是 $j+k_j \le n$。
- 第二个转移执行前提是 $1 \le j- k_j $，如果不判断就会数组越界。

## AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[205][205],n,a,b,k[205]; 
int main(){
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)cin>>k[i];
	f[0][a]=1;
	for(int i=0;i<n;i++){
		for(int j=1;j<=n;j++){
			if(f[i][j]==0)continue;
			if(j+k[j]<=n){f[i+1][j+k[j]]=f[i][j];}
			if(j-k[j]>=1)f[i+1][j-k[j]]=f[i][j];
		}
	}
	for(int i=0;i<=n;i++){
		if(f[i][b]){
			cout<<i;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}
```

---

## 作者：hjfjwl (赞：3)

这道题目会给你三个数 $n,a,b$，分别代表有 $n$ 层，要从 $a$ 到 $b$。

接着有 $n$ 个数字 $k_i$，第 $i$ 层可以到 $i + k_i$ 层或者 $i - k_i$ 层，要注意不能到小于 $0$ 或者大于 $n$ 的地方。

我们可以使用 dfs。对它从 $a$ 到 $b$ 枚举所有可能方法，对答案取最小值。还可以特判如果目前步数大于 $ans$ 就返回。


AC code:
```cpp
#include <iostream>
using namespace std;

int n, a, b;
int k[210];
bool flag[210];
int ans = 1e9;

void dfs(int step,int floora)
{
	if(step > ans)return;
    if(floora == b)
    {
    	//cout << step << endl;
    	ans = min(ans,step);
    	return;
    }
    if(floora + k[floora] <= n)
    {
    	if(flag[floora + k[floora]] == false){
    		flag[floora + k[floora]] = true;
    		dfs(step + 1,floora + k[floora]);
    		flag[floora + k[floora]] = false;
    	}
    }
    if(floora - k[floora] >= 1)
    {
    	if(flag[floora - k[floora]] == false){
    		flag[floora - k[floora]] = true;
    		dfs(step + 1,floora - k[floora]);
    		flag[floora - k[floora]] = false;
    	}
    }
}

int main()
{
	cin >> n >> a >> b;
	for(int i = 1;i <= n;i++)
	{
		cin >> k[i];
	}
	//flag[a] = true;
	dfs(0,a);
	if(ans != 1e9)cout << ans << endl;
	else cout << -1 << endl;
    return 0;
}
```

---

## 作者：Miyamizu_Mitsuha (赞：2)

基本广搜练习题，每个点存位置和当前第几步，可以写一个判合法位置函数，就是我代码中的 cm 函数。每次到一个位置，他就可以往左和往右走当前位置代表的数个格子，所以两个 if 判断掉，顺便打上标记防止重复访问。合法了就直接输出，广搜，所以保证第一次抵达的一定是最小步数。

```
#include<bits/stdc++.h>
using namespace std;
int n,sx,ex,vis[2005]={0},a[2005];
struct r{
  int x,step;
};
bool cm(int u){
  if(u>0&&u<=n)return 1;
  return 0;
}
int main(){
  cin>>n>>sx>>ex;
  for(int i=1;i<=n;i++)cin>>a[i];
  queue<r> q;
  q.push({sx,0}),vis[sx]=1;
  while(q.size()){
    r now=q.front();
    q.pop();
    if(now.x==ex){
      cout<<now.step;
      return 0;
    }
    if(cm(now.x+a[now.x])&&!vis[now.x+a[now.x]]){
      q.push({now.x+a[now.x],now.step+1});
      vis[now.x+a[now.x]]=1;
    }
    if(cm(now.x-a[now.x])&&!vis[now.x-a[now.x]]){
      q.push({now.x-a[now.x],now.step+1});
      vis[now.x-a[now.x]]=1;
    }
    
  }
  cout<<-1;
  return 0;
}
```


---

## 作者：ManGo_Mouse (赞：2)

### 思路
很明显，这是一道搜索题。

写搜索一般需要明确以下几点：
+ 搜索方式，DFS or BFS？
+ 状态表示？
+ 状态转移？
+ 搜索边界？
+ 剪枝方案？

很明显，这道题 DFS 或 BFS 均可，但是 BFS 相对更加好写（无需剪枝）。

状态表示：使用 $x$ 表示当前电梯楼层，$step$ 记录当前按电梯按钮次数（也可以说是搜索深度），方便输出答案。

状态转移：对于每次转移，都只有两种选择，Up or Down（上去或下来）$K_i$ 层，只需判断转移后会不会突破楼顶（$> N$），或遁入地下（$< 1$）。当然，不能重复转移到同一楼层，否则程序会陷入死循环（想一想，为什么？），使用一个布尔数组标记。

搜索边界：自然就是到达目标楼层时。

除此之外，没有什么需要注意的细节。只有一点——要判断如果初始楼层就是目标楼层的情况，直接输出 $0$ 即可。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,v[205],note[205];
struct florr{
    int x,step;
};
int bfs(int a,int b){
    queue<florr> q;
    florr first = {a,0};
    q.push(first);
    while(q.size()){
        florr f = q.front();
        q.pop();
        for(int i = 0;i <= 1;i ++){
            int jump = v[f.x];
            if(i == 0)jump *= -1;
            florr next = f;
            next.x += jump;
            next.step ++;
            if(next.x >= 1 && next.x <= n && !note[next.x]){
                if(next.x == b)return next.step;
                note[next.x] = 1;
                q.push(next);
            }
        }
    }
    return -1;
}
int main(){
    cin>>n>>a>>b;
    for(int i = 1;i <= n;i ++)
        cin>>v[i];
    if(a == b)cout<<0;
    else cout<<bfs(a,b);
    return 0;
}
```

---

## 作者：SSqwq_ (赞：2)

## 分析

本题可进行图论建模。

观察题面不难发现，这样建图是符合题意的：

对于第 $i$ 座电梯，从其向 $i+K_i$ 和 $i-K_i$ 分别连一条边权为 $1$ 的有向边，正确性显然。

之后使用你喜欢的最短路算法即可。题解中使用 SPFA。

令总边数为 $m$，则时间复杂度 $O(nm)$。由于每座电梯只会向外连两条有向边，所以本题中 $m$ 与 $n$ 同阶。

该算法足以通过本题。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ans,dis[201],inq[201],n,sx,ex;
int a[201];
vector<int> vc[201];
queue<int> qu;
void SPFA(){
	qu.push(sx);
	dis[sx]=0;
	inq[sx]=1;
	while(!qu.empty()){
		int p=qu.front();
		qu.pop();
		inq[p]=0;
		for(int i=0;i<vc[p].size();++i){
			int nxt=vc[p][i];
			if(dis[nxt]<=dis[p]+1)continue;
			dis[nxt]=dis[p]+1;
			if(inq[nxt])continue;
			inq[nxt]=1;
			qu.push(nxt);
		}
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>sx>>ex;
	for(int i=1;i<=n;++i){
		dis[i]=2e9;
		cin>>a[i];
		if(i+a[i]<=n)vc[i].push_back(i+a[i]);
		if(i-a[i]>=1)vc[i].push_back(i-a[i]);
	}
	SPFA();
	if(dis[ex]==2e9)dis[ex]=-1;
	cout<<dis[ex]<<"\n";
	return 0;
} 
```


---

## 作者：Auto_Accepted (赞：1)

一道萌萌广搜题。

直接依题意去模拟向上和向下两种情况即可。若已经到达了 $B$，则直接输出现在搜索到的步数即可，而若队列为空又没有到达 $B$，即所有能扩展到的点已经扩展完了，则无解，输出 `-1` 即可。

记得将每一个访问到的节点标记，避免重复情况。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int k[1000005] , n , a , b , step[1000005];
bool vis[100005];
queue <int> q;
void bfs(){
	cin >> n >> a >> b;
	for(int i = 1;i <= n;i++) cin >> k[i];
	step[a] = 0;
	if(a == b){
		cout << 0;
		exit(0);
	}
	q.push(a);
	while(!q.empty()){
        int f = q.front();
        q.pop();
        if(f >= 1 && f <= n){
            for(int i = -1;i <= 1;i += 2){
                if(f + i * k[f] < 1 || f + i * k[f] > n || vis[f + i * k[f]]) continue;
                if(f + i * k[f] == b){
                    cout << step[f] + 1;
                    exit(0);
                }
                step[f + i * k[f]] = step[f] + 1;
                q.push(f + i * k[f]);
                vis[f + i * k[f]] = 1;
            }
        }
	}
}
int main(){
	bfs();
	cout << -1;
}
```

---

## 作者：lbdontknow (赞：1)

这题其实可以使用最短路解决。  
对于每一个点 $i$ 与这个点对应的 $k_i$，我们可以进行如下处理。  
* 如果 $i + k_i \leq n$ 则连一条从点 $i$ 到点 $i + k_i$，权值为 $1$ 的边（从楼层 $i$ 按动 $1$ 次电梯上升到楼层 $i + k_i$。  
* 如果 $i - k_i \geq 1$ 则连一条从点 $i$ 到点 $i - k_i$，权值为 $1$ 的边（从楼层 $i$ 按动 $1$ 次电梯下降到楼层 $i + k_i$。    

最后使用最短路算法算出从 $A$ 点到 $B$ 点的最短路就好了。  
这份代码使用邻接矩阵存边以及弗洛伊德算法求最短路。
```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int N = 510, INF = 0x3f3f3f3f;
int f[N][N];//最短路数组，f[i][j] 代表从 i 层到 j 层最小按按钮次数
int main(){
	int n, a, b;
	cin >> n >> a >> b;
	memset(f, INF, sizeof(f));//初始化路径数组为无穷大
	for(int i = 1 ; i <= n ; i++){
		int k;
		cin >> k;
		int u = i,up = u + k, down = u - k;//up为上升可以到达的楼层，down为下降可以到达的楼层
		if(up <= n){//如果这个楼层是合法的
			f[u][up] = 1;//从楼层 i 向楼层 i + k 连一条权值为 1 的边
		}
		if(down >= 1){//同上
			f[u][down] = 1;//从楼层 i 向楼层 i - k 连一条权值为 1 的边
		}
	}
	for(int i = 1 ; i <= n ; i++)	f[i][i] = 0;//同一楼层不用坐电梯
	for(int k = 1 ; k <= n ; k++){//弗洛伊德算法
		for(int i = 1 ; i <= n ; i++){
			for(int j = 1 ; j <= n ; j++){
				f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
			}
		}
	}
	if(f[a][b] == INF)	cout << -1 << endl;//无法到达
	else	cout << f[a][b] << endl;
	return 0;
}

```

---

## 作者：_saltFish_ (赞：1)

# 简要题意

给出一个 $n$ 个点的有向稀疏图和两个点 $a,b$，求从 $a$ 到 $b$ 的最短路径。

# 思路

以下我们将按一次按钮视作当前时刻加 $1$。

对于一个点，我们明显只会关心更早到达这个点的时刻，而之后到达的我们都不关心，因为更晚到达的情况拓展出去的状态肯定是会更劣的。

所以我们希望更早地拓展时间最小的状态，以此来保证我到达某个点时的时间一定到达它的最短时间。

考虑到每个边的代价都是 $1$，那么我们可以果断使用 bfs 来解决这一问题。

首先，我们每次贪心地选择当前时间最小的点向外拓展，如果拓展到了没有到达过的点那么就更新这个点的答案，由于我们取的是当前时间最小的点，所以它拓展到的点一定是当前能拓展到的点中到达时刻最小的点，而且在它之后被拓展到的点的到达时间都不会比这个点小，也就是说到达时间小的点一定会更先被拓展，我们按照访问到的顺序把点存在队列里就行，每次取出队列的第一个拓展。

所以就这样直接 bfs 就行。

# Code

```cpp
#include <iostream>
#include <queue>

using namespace std;

const int N = 205;

int n, s, t, a[N], dis[N];
bool vis[N];
queue<int> q;

void bfs() {
	dis[s] = 0;
	q.push(s);
	
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		
		if(u == t) return ;
		
		for(int i = -1; i <= 1; i++) {
			int v = u + a[u] * i;
			if(!i || v > n || v < 1 || vis[v]) continue;
			
			vis[v] = 1;
			dis[v] = dis[u] + 1;
			q.push(v);
		}
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> s >> t;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	
	dis[t] = -1;
	bfs();
	
	cout << dis[t] << '\n';
}
```

---

## 作者：xiezheyuan (赞：1)

## 要题意

给出一个长度为 $n$ 的序列 $k$。

你需要构造一个 $n$ 个点的有向图，构造方法：

- 对于每一个 $k_i$，若 $1\leq i+k_i \leq n$，连边 $(i,i+k_i,1)$。
- 对于每一个 $k_i$，若 $1 \leq i-k_i \leq n$，连边 $(i,i-k_i,1)$。

给出 $A,B$ 两个点，求最短路径 $(A,B)$ 的长度，如果不存在，输出 $-1$。

$1 \leq n \leq 200$

## 思路

这道题是一道搜索练习题，但我感觉题解里只有搜索不太好，所以这里是最短路算法，具体来说是 Floyd 算法。

首先我们将题目要求的图中建立出来，构造一个 $01$ 矩阵 $e$，其中 $e_{i,j}$ 如果为 $1$（反正边权都是 $1$），代表存在边 $(i,j)$，否则为 $+\infty$。其实就是邻接矩阵。

然后考虑 dp，如果设 $f(i,j)$ 表示路径 $(i,j)$ 的最短路长度，则我们可以枚举路径中的某一个点 $k$，拆分成两个路径 $(i,k),(k,j)$ 来计算，最后统计一个最小值。注意如果 $i=j$，那么路径长度为 $0$。

转移方程如下：

$$
f(i,j)=\begin{cases}
0 & i = j\\
\min\left(e_{i,j},\min\limits_{k=1}^{n} (f(i,k)+f(k,j))\right) & i \neq j
\end{cases}
$$

注意一下转移的细节，如果我们按照顺序 $i,j,k$ 来枚举，可能会出现 $f(i,k),f(k,j)$ 尚未计算完成的情况，我们可以转而按照 $k,i,j$ 顺序枚举，不难发现我们解决了这个问题。

最后答案自然就是 $f(A,B)$ 啦！如果 $f(A,B)=+\infty$，代表没有可行路径，输出 $-1$ 即可。

时间复杂度 $O(n^3)$。

实现的话可以将 $e,f$ 压成一个数组。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 205;
int f[N][N],n,a,b;

signed main(){
	memset(f, 0x3f, sizeof(f));
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++) f[i][i] = 0;
	for(int i=1;i<=n;i++){
		int k;cin>>k;
		if(i+k <= n) f[i][i+k] = 1;
		if(i-k >= 1) f[i][i - k] = 1;
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
			}
		}
	}
	cout<<(f[a][b] >= f[0][0] ? -1 : f[a][b]);
	return 0;
}
```

---

## 作者：xibaohe (赞：1)

由于数据原因这道题所有题解都被撤下了，我来写一篇吧。

# 题目大意
有一种很奇怪的电梯，每一层楼都可以停，而且第 $i$ 层楼上有一个数字 $K_i$。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。如果不能满足要求，相应的按钮就会失灵。问从 $A$ 楼到 $B$ 楼至少要按几次按钮。

# 算法思路
这道题可以使用深搜做，但是个人认为广搜更容易一些且不会被 hack，因此我选择用广搜。

# 算法讲解

首先，我们需要建立一个结构体记录每个节点的位置与答案，并定义这种结构体的队列。

```cpp

struct node //每个结点的状态
{
    int x,y; //结点位置x, 结点答案y;
};
queue<node> q; //建立以每个状态为元素的队列

```

接下来我们就可以打出广搜基本模板：

```cpp
int bfs() //返回到达终点状态的答案
{
	q.push(node{a,0}); //初始状态入队
	vis[a]=true; //表示初始结点已访问
	while(!q.empty()) //只要队列非空,就继续循环
	{
		int x=q.front().x,y =q.front().y; //取队首
		q.pop(); //队首出队
		if(x==b) return y;
		//上
		
   int x_new=x+k[x],y_new=y+1; //求出子结点X
   if(x_new>=1&&x_new<=n&&vis[x_new]==false)
			{ //子结点合法的3个条件：结点编号1~n，结点未访问，结点无障碍
				q.push(node{x_new，y_new}); //扩展子结点入队
				vis[x_new]=true; //标记子结点已访问
			}
		
		//下
			x_new=x-k[x],y_new=y+1; //求出子结点
			if(x_new>=1&&x_new<=n&&vis[x_new]==false)
			{ //子结点合法的3个条件：结点编号1~n，结点未访问，结点无障碍
				q.push(node{x_new,y_new}); //扩展子结点入队
				vis[x_new]=true; //标记子结点已访问
			}
	}
	return -1; //根据题意，搜不到终点返回-1
}
```

最后按照要求输出答案即可。

```cpp
cout<<bfs()<<endl;
```

# 通过记录
[亲测可以通过。](https://www.luogu.com.cn/record/136415363)

代码是多年前的，码风比较丑陋，见谅。

---

## 作者：lzj666_luogu (赞：1)

## 做法

本题使用 BFS 来做是又快又简单的。

## 实现

BFS 广度优先搜索是使用队列（queue，先进先出）来实现，整个过程也可以看做一个倒立的树形：

1. 把根节点放到队列的末尾。
2. 每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾 (不需要排序，因为默认每次增加权重相同)。并把这个元素记为它下一级元素的前驱。
3. 找到所要找的元素时结束程序。
4. 如果遍历整个树还没有找到，结束程序。

最坏情况 $\Theta(n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define maxn 200+10
using namespace std;
int n,k[maxn],a,b,bb[maxn];
struct node{
	int k,step;
	node(int kk,int st){
		k=kk;step=st;
	}
};
queue<node> q;
inline bool p(int dx){
	return dx<=n&&dx>=1;
}
int bfs(int x,int y){
	int dx;
	if(x==y) return 0;
	q.push(node(x,0));
	bb[x]=true;
	while(!q.empty()){
		node no=q.front();
		q.pop();
		dx=no.k+k[no.k];
		if(p(dx)&&bb[dx]==false){
			bb[dx]=true;
			q.push(node(dx,no.step+1));
			if(dx==y) return no.step+1;
		}
		dx=no.k-k[no.k];
		if(p(dx)&&bb[dx]==false){
			bb[dx]=true;
			q.push(node(dx,no.step+1));
			if(dx==y) return no.step+1;
		}
	}
	return -1;
}
int main(){
	std::ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++) cin>>k[i];
	cout<<bfs(a,b)<<endl;
	return 0;
}
```

---

## 作者：_Dolphin_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1135)

## Solution

只需要将每个楼层向可到达的楼层（需要判是否超出 $1\sim n$ 层的限制）连有向边，再从 $a$ 开始跑单源最短路即可，答案为从源点 $a$ 到点 $b$ 的最短距离。注意有可能有图不连通的情况。

关于最短路的详解，请见 [P3371](https://www.luogu.com.cn/problem/P3371) 和 [P4779](https://www.luogu.com.cn/problem/P4779) 。

### Code(100 pts):

```cpp
#include<bits/stdc++.h>
#define afor(x,y,z) for(int x=y;x<=z;x++)
#define bfor(x,y,z) for(int x=y;x>=z;x--)
using namespace std;
typedef long long ll;
typedef const int cint;
cint N=210,Inf=0x3f3f3f3f;
int n,a,b,x,mp[N][N],f[N],v[N];
void dij(int x) {//单源最短路
	memset(f,0x3f,sizeof f);
	f[x]=0;
	afor(i,1,n) {
		int t=Inf,k;
		afor(j,1,n) if(!v[j]&&f[j]<t) t=f[j],k=j;
		v[k]=1;
		afor(j,1,n) if(mp[k][j]) f[j]=min(f[j],f[k]+1);
	}
}
int main() {
	scanf("%d%d%d",&n,&a,&b);
	afor(i,1,n) {
		scanf("%d",&x);
		if(i+x<=n) mp[i][i+x]=1;//向上连边
		if(i-x>=1) mp[i][i-x]=1;//向下连边
	}
	dij(a);//跑最短路
	if(f[b]==Inf) printf("-1");//不连通
	else printf("%d",f[b]);
	return 0;
}
```

---

## 作者：wangjue233 (赞：0)

# Solution
[题目传送门](https://www.luogu.com.cn/problem/P1135)

## 题目分析
我们要计算从起始楼层 $A$ 到目标楼层 $B$ 的最短距离。电梯每次移动的楼层数由当前楼层的数字 $k_i$ 决定，可以向上或向下移动。关键在于电梯的移动规则，设计一个算法来找到**最短路径**。如果无法到达目标楼层，返回 `-1`。

## 题目思路
这道题我一开始是用的 DFS 做的，但是后来发现 BFS 更好。

使用 BFS 是因为我们需要找到最短路径。BFS 适合于在未加权的图中寻找最短路径。
从起始楼层开始，将其添加到队列中。

## 解题步骤

1. 每次从队列中取出一个元素，并探索它可以直接达到的楼层（根据 $k_i$ 向上或向下移动）。

2. 如果某个可达的楼层是目的地，则返回到达该楼层所需的步数。如果无法到达目标楼层，返回 `-1`。

但是，我们还要防止重复计算，我们可以使用一个布尔数组 $vis$ 来标记已经访问过的楼层，这样可以避免重复访问同一楼层。

## AC Code
```cpp
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
const int maxn = 200 + 10;
int a[maxn];
bool vis[maxn]; //标记每层楼是否已访问
int step[maxn]; //记录到达每层楼的最小步数
//BFS 函数，计算从 st（起始楼层）到 ed（目标楼层）的最少步数
int bfs(int st, int ed, int n){
    if(st == ed) return 0; //如果起始楼层和目标楼层相同，则无需移动
    queue<int> q;
    q.push(st); //将起始楼层加入队列
    vis[st] = true; //标记起始楼层为已访问
    step[st] = 0;
    while(!q.empty()){
        int cnt = q.front();
        q.pop(); 
        //获取队列前端的楼层，并弹出这个楼层
        int up = cnt + a[cnt]; //计算向上移动的目标楼层
        int down = cnt - a[cnt]; //计算向下移动的目标楼层
        //检查向上移动是否可行
        if(up <= n && !vis[up]){
            vis[up] = true;
            step[up] = step[cnt] + 1;
            q.push(up); //将新楼层加入队列
            if(up == ed){ //如果达到目标楼层，返回步数
                return step[up];
            }
        }
        //检查向下移动是否可行
        if(down >= 1 && !vis[down]){
            vis[down] = true;
            step[down] = step[cnt] + 1;
            q.push(down); //将新楼层加入队列
            if(down == ed){ //如果达到目标楼层，返回步数
                return step[down];
            }
        }
    }
    return -1; //如果无法到达目标楼层，返回 -1
}
int main(){
    int n, st, ed;
    cin >> n >> st >> ed;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    memset(vis, false, sizeof(vis));
    int result = bfs(st, ed, n);
    cout << result << endl;
    return 0;
}
```
时间复杂度：$O(n)$，可以通过本题。

---


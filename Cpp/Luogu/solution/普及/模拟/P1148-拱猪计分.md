# 拱猪计分

## 题目描述

「拱猪」是一种很有趣的扑克牌游戏。即使你不知道它的玩法，你也可以由它的计分方式来了解它的趣味性。假设在此我们仅考虑四个人的拱猪牌局，本题要求你根据下面的计分规则，在牌局结束时计算四位玩家所得分数。

1. 我们分别以 $\texttt S, \texttt H, \texttt D, \texttt C$ 来代表黑桃、红心、方块及梅花，并以数字 $1$ 至 $13$ 来代表 $\texttt A, \texttt 2, \dots, \texttt Q, \texttt K$ 等牌点，例如：$H_1$ 为红心 $\texttt A$，$S_{13}$ 为黑桃 $\texttt K$；
2. 牌局结束时，由各玩家持有的有关计分的牌（计分牌）仅有「猪」$S_{12}$，所有红心牌，「羊」$D_{11}$ 及「加倍」$C_{10}$ 等 $16$ 张牌，其它牌均弃置不计，若一位玩家未持有这 $16$ 张牌中任意一张，则以得零分计算；
3. 若持有 $C_{10}$ 牌的玩家只有该张牌而没有任何其它牌则得 $+50$ 分，否则将其它计分牌所得分数加倍计算；
4. 若红心牌不在同一家，则 $H_1$ 至 $H_{13}$ 等 $13$ 张牌均以负分计，其数值依次为 $-50, -2, -3, -4, -5, -6, -7, -8, -9, -10, -20, -30, -40$，且 $S_{12}$ 与 $D_{11}$ 的分值分别以 $-100$ 及 $+100$ 分计算；
5. 若红心牌 $H_1$ 至 $H_{13}$ 均在同一家，则有下列情形：

+ 所有红心牌以 $+200$ 分计算。
+ 若 $S_{12}, D_{11}$ 皆在吃下所有红心牌之一家，则此玩家得 $+500$ 分。
+ $C_{10}$ 牌依旧以前文所述原则计算。

例一：若各玩家持有计分牌如下：

1. `S12 H3 H5 H13`
2. `D11 H8 H9`
3. `C10 H1 H2 H4 H6 H7`
4. `H10 H11 H12`

则各家之得分依序为：$-148, +83, -138$ 及 $-60$。

例二：若各玩家持有计分牌如下：

1. `H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13`
2. `S12 C10`
3. `D11`
4. 无

则各家之得分依序为：$+200, -200, +100$ 及 $0$。

例三：若有一玩家持有所有 $16$ 张计分牌，则得 $+1000$ 分，其余三家均得零分。

## 样例 #1

### 输入

```
4  S12  H3  H5  H13
3  D11  H8  H9
6  C10  H1  H2  H4  H6  H7
3  H10  H11 H12
13 H1  H2  H3  H4  H5  H6  H7  H8  H9  H10  H11  H12  H13  
2  S12  C10
1  D11
0
0
0
0
0
```

### 输出

```
-148 +83 -138 -60
+200 -200 +100 0
```

# 题解

## 作者：Diaоsi (赞：24)

## 传送门:[P1148](https://www.luogu.org/problem/P1148)
没啥好说的，就是一道模拟题，按照题意模拟就行。

但是题目里确实有些地方表述得不够清楚，那下面我来讲一下，给大家避避雷

	1.关于全部WA的，这题貌似不支持动态输出，要先预存答案再输出
    2.关于只AC第五个点的，这题正数前也要加符号，注意调整输出方式
    3.关于只WA第二个点的，H牌拿满后若单独存在D11、S12牌也要扣分
    4.H牌拿满只能加200分，不是加13*200分，由题目给的样例可知
    5.这题数据太弱，我A了以后才发现有持满16张牌+1000分的条件233
 _Code:_
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000010;
const int H[]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40};
const int S12=-100;
const int D11=100;
int n,cntbr,cnttot;
vector<string> s;
struct node{
	int a,b,c,d;
}sco[N];
int score(){
	int ans=0;
	int cntH=0,cntC10=0;
	int cntS12=0,cntD11=0;
	int bothS12D11=0;
	for(int i=0;i<s.size();i++){
		if(s[i][0]=='H')cntH++;
		if(s[i][0]=='C'&&s[i][1]=='1'&&s[i][2]=='0')cntC10++;
		if(s[i][0]=='S'&&s[i][1]=='1'&&s[i][2]=='2')cntS12++;
		if(s[i][0]=='D'&&s[i][1]=='1'&&s[i][2]=='1')cntD11++;
		if(cntD11&&cntS12)bothS12D11++;
	}
	if(cntH==13&&!bothS12D11)ans+=200;
	else if(cntH==13&&bothS12D11)ans+=500;
	if(s.size()==1&&cntC10)ans+=50;
	if(cntS12&&!bothS12D11)ans+=S12;
	if(cntD11&&!bothS12D11)ans+=D11;
	if(cntH<13){
		for(int i=0;i<s.size();i++){
			if(s[i][0]=='H'&&s[i][1]=='1'&&s[i].size()==2)ans+=H[1];
			if(s[i][0]=='H'&&s[i][1]=='2'&&s[i].size()==2)ans+=H[2];
			if(s[i][0]=='H'&&s[i][1]=='3'&&s[i].size()==2)ans+=H[3];
			if(s[i][0]=='H'&&s[i][1]=='4'&&s[i].size()==2)ans+=H[4];
			if(s[i][0]=='H'&&s[i][1]=='5'&&s[i].size()==2)ans+=H[5];
			if(s[i][0]=='H'&&s[i][1]=='6'&&s[i].size()==2)ans+=H[6];
			if(s[i][0]=='H'&&s[i][1]=='7'&&s[i].size()==2)ans+=H[7];
			if(s[i][0]=='H'&&s[i][1]=='8'&&s[i].size()==2)ans+=H[8];
			if(s[i][0]=='H'&&s[i][1]=='9'&&s[i].size()==2)ans+=H[9];
			if(s[i][0]=='H'&&s[i][1]=='1'&&s[i][2]=='0'&&s[i].size()==3)ans+=H[10];
			if(s[i][0]=='H'&&s[i][1]=='1'&&s[i][2]=='1'&&s[i].size()==3)ans+=H[11];
			if(s[i][0]=='H'&&s[i][1]=='1'&&s[i][2]=='2'&&s[i].size()==3)ans+=H[12];
			if(s[i][0]=='H'&&s[i][1]=='1'&&s[i][2]=='3'&&s[i].size()==3)ans+=H[13];
		}
	}
	if(s.size()>1&&cntC10)ans<<=1;
	return ans;
}
int main(){
	while(1){
		cntbr=0;cnttot++;
		for(int i=1;i<=4;i++){
			s.clear();cin>>n;
			if(n==0)cntbr++;
			for(int j=1;j<=n;j++){
				string str;
				cin>>str;
				s.push_back(str);
			}
			if(i==1)sco[cnttot].a=score();
			if(i==2)sco[cnttot].b=score();
			if(i==3)sco[cnttot].c=score();
			if(i==4)sco[cnttot].d=score();
		}
		if(cntbr==4)break;
	}
	for(int i=1;i<cnttot;i++){
		if(sco[i].a>0)printf("+%d ",sco[i].a);
		if(sco[i].a<=0)printf("%d ",sco[i].a);
		if(sco[i].b>0)printf("+%d ",sco[i].b);
		if(sco[i].b<=0)printf("%d ",sco[i].b);
		if(sco[i].c>0)printf("+%d ",sco[i].c);
		if(sco[i].c<=0)printf("%d ",sco[i].c);
		if(sco[i].d>0)printf("+%d ",sco[i].d);
		if(sco[i].d<=0)printf("%d ",sco[i].d);
		puts("");
	}
	return 0;
}
```


---

## 作者：juruo_zjc (赞：12)

# 路过的靓仔看过来！
走过路过，千万不要蒟蒻！

这道题没有任何难度，尻（考）的仅仅是码力和毒题能力。


------------
## First 分析题目
题目的含义就是，如果红心牌，全部在手中，那么就分两种情况：加百牌（D10）和扣百牌（S12）同时在他的手中，那么就总分加上500分。否则就根据加百牌（D10）和扣百牌（S12）的原加分情况计算。

如果红心牌不在同一家，那么按照表内数据加分。

加分表如下：

−50,−2,−3,−4,−5,−6,−7,−8,−9,−10,−20,−30,−40

当然,C10牌如果拥有，且有其他牌，那么C10做加倍牌食用（使用）。否则分数为50；


------------
**好了**，理清了题目条件，那么现在开始程序代码部分！
```
int Fs[17]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40,-100,100};
```
前面13个（从1开始）表示Hi牌。

然后第14个表示表示猪排QWQ（猪牌），第15个表示羊排QWQ（羊牌），猪牌扣100，羊牌加100。

最后的第16个代表C10，加倍牌，没有的分（但是很明显看到我数组开了17个）。

然后我用了一个sum数组，sum[i][j]表示第i位玩家第j类牌（就是上面表中的）是否存在。


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum[10005][17],number;
int Fs[17]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40,-100,100};
char s;
int main(){
	while(1){
		int Tot=0,curans=0;
		memset(sum,0,sizeof(sum));
		for(int i=1;i<=4;i++){
			cin>>n;
			Tot+=n;
			for(int j=1;j<=n;j++){
				cin>>s>>number;
				if(s=='H')sum[i][number]=1;
				if(s=='S')sum[i][14]=1;
				if(s=='C')sum[i][16]=1;
				if(s=='D')sum[i][15]=1;
			}
		}
		if(Tot==0)return 0;
		for(int i=1;i<=4;i++){
			int ok=1;
			curans=0;
			for(int j=1;j<=13;j++)
				if(sum[i][j]==0){
					ok=0;
					break;
				}
			if(ok){
				if(sum[i][14]&&sum[i][15])curans+=500;
				else curans+=200+((sum[i][14])?1:0)*Fs[14]
				                +((sum[i][15])?1:0)*Fs[15];
				if(sum[i][16])curans*=2;
				if(curans>0)printf("+%d ",curans);
				else printf("%d ",curans);
			}
			else{
				ok=1;
				for(int j=1;j<=15;j++)
					if(sum[i][j]){
						ok=0;
						break;
					}
				if(ok==1){
					if(sum[i][16])printf("+50 ");
					else printf("0 ");
				}
				else{
					for(int j=1;j<=15;j++)curans+=((sum[i][j])?1:0)*Fs[j];
					if(sum[i][16])curans*=2;
					if(curans>0)printf("+%d ",curans);
					else printf("%d ",curans);
				}
			}
		}
		cout<<endl;
	}
	return 0;
}
```
一行一行来解释吧！

```
int Tot=0,curans=0;
memset(sum,0,sizeof(sum));
for(int i=1;i<=4;i++){
	cin>>n;
	Tot+=n;
	for(int j=1;j<=n;j++){
		cin>>s>>number;
		if(s=='H')sum[i][number]=1;
		if(s=='S')sum[i][14]=1;
		if(s=='C')sum[i][16]=1;
		if(s=='D')sum[i][15]=1;
	}
}
if(Tot==0)return 0;
```
先看这一段程序。Tot这个玩意就是为了判断是不是全0.因为牌数非负，所以牌数相加和为0，说明四个玩家全部无牌，就结束。

然后循环每一位玩家，读入牌数，循环每一张牌，读入牌的种类，再读入牌的序号。然后判断种类，统计到sum数组中去。

这段程序就是这样了，咱们接着往下看。


------------
下面循环每位玩家的牌况，然后分析得分，直接按照要求输出。

循环内情况我们一块一块来看看。
```
int ok=1;
curans=0;
for(int j=1;j<=13;j++)
	if(sum[i][j]==0){
		ok=0;
		break;
	}
```
这个OK就是来看i玩家是不是把所有红心牌全部收入囊中。

cur就是英语单词current的缩写，表示当前，所以curans就代表当前答案。

```
if(ok){
	if(sum[i][14]&&sum[i][15])curans+=500;
	else curans+=200+((sum[i][14])?1:0)*Fs[14]
	                +((sum[i][15])?1:0)*Fs[15];
	if(sum[i][16])curans*=2;
	if(curans>0)printf("+%d ",curans);
	else printf("%d ",curans);
}
```
这就是对于红心全到手后其他牌的讨论情况。

如果猪牌羊牌全部有，那么就总分加500，否则，就根据原加分，哪个存在就加上那个的得分。

如果加倍牌存在，因为都有红心的全部，所以肯定只要乘2就可以了。

然后根据题目要求输出，如果curans是正数就输出一个+号，否则原样输出。


------------
```
else{
	ok=1;
	for(int j=1;j<=15;j++)
		if(sum[i][j]){
			ok=0;
			break;
		}
	if(ok==1){
		if(sum[i][16])printf("+50 ");
		else printf("0 ");
	}
	else{
		for(int j=1;j<=15;j++)curans+=((sum[i][j])?1:0)*Fs[j];
		if(sum[i][16])curans*=2;
		if(curans>0)printf("+%d ",curans);
		else printf("%d ",curans);
	}
}
```
这个就是对于没有拿到全部红心的情况讨论：

这里的OK==1就说明红牌和猪羊牌一张都没有，那么就看加倍牌有没有，如果有那就是只有加倍牌，直接输出+50，否则就是一无所有，输出0。

如果还是有几张牌的，那么就像上面一样，哪个存在就加上那个。如果有加倍牌，就将分数乘2，然后按题目要求输出。


------------
程序就是这样了。这道题对于程序功底要求比较高，其实就是无脑模拟。

这是半年来我第一次写题解，求过审。

---

## 作者：封禁用户 (赞：11)

### 这题坑点确实很多，请各位大佬注意以下几个问题：

- “羊”牌有两张：$D10$和$D11$，第一个点$wa$的大佬看这里。

- 输出一定要带有符号。只$A$第$5$个点的大佬看这里。

- 本题是纯模拟，没有其他任何算法，容易使C++萌新丧失对$OI$的兴趣……

-----

### 再来看一下题目中的几个关键：

- 集齐$16$张牌便可以加$1000$分

- 集齐$13$张红桃加$200$分

- 若所有红桃牌不在同一个人的手中，那么分值按照：

	−50,−2,−3,−4,−5,−6,−7,−8,−9,−10,−20,−30,−40来计算。
    
- 猪牌和羊牌分别为$-100$和$100$分

- 集齐$13$张红桃、羊牌和猪牌，加$500$分

- 若除了$C10$还有其他计分牌则将其他计分牌的分数$*2$

----

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
using namespace std;
int n[5],h[14]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40};
//n为人数，h为红桃牌的分值
int ans[101][5],temp;
//ans记录最后的答案，temp记录牌局的人数
bool vis[14],sheapp,pigg,c_ten;
//vis用来打标记，看看第i个人有哪些红桃
//sheapp，pigg，c_ten都是用来标记第i个人有没有这些牌
string s;
//读入时的字符串
bool sheap(int x);
bool pig(int x);
bool C(int x);
struct node//定义结构体，记录牌
{
    int number;//数值
    char mark;//花色
};
node a[53],b[53],c[53],d[53];//四个人
void make(string f,int id,int id2)
{
    //每当输入一个字符串，便会调用函数，制作一张牌
    if(id==1) a[id2].mark=f[0];
    if(id==2) b[id2].mark=f[0];
    if(id==3) c[id2].mark=f[0];
    if(id==4) d[id2].mark=f[0];
    int sum=0;
    for(int i=1;i<f.size();i++) sum=sum*10+(f[i]-'0');
    if(id==1) a[id2].number=sum;
    if(id==2) b[id2].number=sum;
    if(id==3) c[id2].number=sum;
    if(id==4) d[id2].number=sum;
}
bool over()//看看牌局是否结束
{
    for(int i=1;i<=4;i++) if(n[i]!=0) return 1;
    return 0;
}
bool visit()//遍历vis,是否全是红桃牌，若是，返回1。
{
    for(int i=1;i<=13;i++) if(vis[i]==0) return 0;
    return 1;
}
int all_red(int x)//计算红桃牌的分值
{
    memset(vis,0,sizeof(vis));
        int anss=0;
    for(int i=1;i<=n[x];i++){
        if(x==1&&a[i].mark=='H') vis[a[i].number]=1;
        if(x==2&&b[i].mark=='H') vis[b[i].number]=1;
        if(x==3&&c[i].mark=='H') vis[c[i].number]=1;
        if(x==4&&d[i].mark=='H') vis[d[i].number]=1;
    }
    if(visit()==1) return 200;
    for(int i=1;i<=n[x];i++){
        if(x==1&&a[i].mark=='H') anss=anss+h[a[i].number];
        if(x==2&&b[i].mark=='H') anss=anss+h[b[i].number];
        if(x==3&&c[i].mark=='H') anss=anss+h[c[i].number];
        if(x==4&&d[i].mark=='H') anss=anss+h[d[i].number];
    }
    return anss;
}
bool sheap(int x)//遍历，看看有没有羊牌
{
    for(int i=1;i<=n[x];i++)
    {
        if((x==1&&a[i].mark=='D'&&a[i].number==11)||(x==1&&a[i].mark=='D'&&a[i].number==10)) return 1;
        if((x==2&&b[i].mark=='D'&&b[i].number==11)||(x==2&&b[i].mark=='D'&&b[i].number==10)) return 1;
        if((x==3&&c[i].mark=='D'&&c[i].number==11)||(x==3&&c[i].mark=='D'&&c[i].number==10)) return 1;
        if((x==4&&d[i].mark=='D'&&d[i].number==11)||(x==4&&d[i].mark=='D'&&d[i].number==10)) return 1;
    }
    return 0;
}
bool pig(int x)//遍历，看看有没有猪牌
{
    for(int i=1;i<=n[x];i++)
    {
        if(x==1&&a[i].mark=='S'&&a[i].number==12) return 1;
        if(x==2&&b[i].mark=='S'&&b[i].number==12) return 1;
        if(x==3&&c[i].mark=='S'&&c[i].number==12) return 1;
        if(x==4&&d[i].mark=='S'&&d[i].number==12) return 1;
    }
    return 0;
}
bool C(int x)//遍历，看看有没有C10。
{
    for(int i=1;i<=n[x];i++)
    {
        if(x==1&&a[i].mark=='C'&&a[i].number==10) return 1;
        if(x==2&&b[i].mark=='C'&&b[i].number==10) return 1;
        if(x==3&&c[i].mark=='C'&&c[i].number==10) return 1;
        if(x==4&&d[i].mark=='C'&&d[i].number==10) return 1;
    }
    return 0;
}
int find_others(int x)//看看第i个人有没有羊、猪牌和C10
{
    sheapp=sheap(x);
    pigg=pig(x);
    c_ten=C(x);
    if(sheapp==1&&pigg==1&&c_ten==1) return 3;
}
int main()
{
    while(1){//读入
        for(int i=1;i<=4;i++){
            scanf("%d",&n[i]);
            for(int j=1;j<=n[i];j++){
                cin>>s;
                make(s,i,j);//制作牌
            }
        }
        if(over()==0) break;//判断牌局的结束
        temp++;//轮数++
        for(int i=1;i<=4;i++){
            if(n[i]==0) continue;如果第i个人有0张牌，就跳过他
            ans[temp][i]=ans[temp][i]+all_red(i);//先记录红桃牌的分值
            int ok=find_others(i);//看看是否拥有其他3张得分牌
            if(ans[temp][i]==200&&n[i]>=16&&ok==3){ans[temp][i]=1000;continue;}//有十六张牌的情况
            if(n[i]==1&&c_ten==1){ans[temp][i]=50;continue;}//只有一张C10的情况
            if(ans[temp][i]==200&&sheapp==1&&pigg==1&&c_ten==0){ans[temp][i]=500;continue;}//拥有13张红桃牌、羊、猪牌的请况
            if(pigg==1) ans[temp][i]+=-100;//有一张猪牌
            if(sheapp==1) ans[temp][i]+=100;//有一张羊牌
            if(c_ten==1) ans[temp][i]*=2;//有一张C10
        }
    }
    for(int i=1;i<=temp;i++) //输出，一定要带符号
    {
        for(int j=1;j<=4;j++)
            if(ans[i][j]>0) printf("+%d ",ans[i][j]);
            else printf("%d ",ans[i][j]);
        printf("\n");
    }
    return 0;
}
```


---

## 作者：uniqueharry (赞：5)

写在题解前：

   这是我第一次发题解，有任何格式不符合规范要求，或者是思路解释含糊不清，欢迎各位大佬批评指正。

关于题意：
并不用把四个玩家的牌都统计出来来判断所有的红心是否在同一个玩家手里，只用针对每次一个玩家判断他手里的牌就可以了。（比如并不会出现一个人把红心牌拿满了，其他人还有红心牌的情况）

切入正题：这道题大部分题解都是四个数据一组处理的，这样可能会开比较多的数组（虽然也没有什么影响），我的思路是一个数据一个数据的处理，存进一个数组里，然后特判一下换行和退出输入即可。

上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct card
{
	char type;//牌的种类 
	int point;//牌的点数 
}c[100];
int ans[100];
int main()
{
	int time=0,num,t=0,sco=0,hflag=0,sflag=0,dflag=0;//time用来统计总的牌数，t用来特判换行,sco用来储存分数，其他的几个用来检查有无特殊情况。 
	while(cin>>num)
	{
		time++; 
		for(int i=1;i<=num;i++)
		cin>>c[i].type>>c[i].point;
		for(int i=1;i<=num;i++)
		if(c[i].type=='H') t++;
		if(t==13) hflag=1;//即所有红心在一家 
		for(int i=1;i<=num;i++)
		if(c[i].type=='S'&&c[i].point==12) sflag=1;//出现S12 
		for(int i=1;i<=num;i++)
		if(c[i].type=='D'&&c[i].point==11) dflag=1;//出现D11 
		for(int i=1;i<=num;i++)
		{
			if(c[i].type=='C'&&c[i].point==10)
			swap(c[i],c[num]);//把C10换到最后 
			if(hflag==1)//所有红心在一家的情况 
			{
				if(sflag==1&&dflag==1) sco=500;
				else 
				{
					sco=200;
					if(sflag==1) sco-=100;
					if(c[i].type=='D'&&c[i].point==11) sco+=100;
				}	
			}
			else
			{
				if(c[i].type=='H')
				{
					if(c[i].point==1) sco-=50;
					if(c[i].point==2) sco-=2;
					if(c[i].point==3) sco-=3;
					if(c[i].point==4) sco-=4;
					if(c[i].point==5) sco-=5;
					if(c[i].point==6) sco-=6;
					if(c[i].point==7) sco-=7;
					if(c[i].point==8) sco-=8;
					if(c[i].point==9) sco-=9;
					if(c[i].point==10) sco-=10;
					if(c[i].point==11) sco-=20;
					if(c[i].point==12) sco-=30;
					if(c[i].point==13) sco-=40;
				}
				if(c[i].type=='S'&&c[i].point==12) sco-=100;
				if(c[i].type=='D'&&c[i].point==11) sco+=100;
			}
			if(c[i].type=='C'&&c[i].point==10)
			{
				if(num==1) sco=50;//如果仅有这一张牌 
				else sco*=2;
			} 
		}
		ans[time]=sco;//把答案存进数组 
		t=0,sco=0,hflag=0,sflag=0,dflag=0;//变量全部重置 
		memset(c,0,sizeof(c));//清空储存牌的数组 
	}
	for(int i=1;i<=time;i++)
	{
		if(i%4==1&&ans[i]==0&&ans[i+1]==0&&ans[i+2]==0&&ans[i+3]==0)//判断结束条件 
		break;
		if(ans[i]>0) cout<<"+"<<ans[i]<<" ";//正数要加'+' 
		else cout<<ans[i]<<" ";//负数和0直接输出 
		if(i%4==0) cout<<endl;//每四张牌换行 
	}
	return 0;
}
```

祝您AC！ /cy


---

## 作者：Heartlessly (赞：5)

此题是一道极难（fán）的模拟，处理起来十分麻烦。不推荐新手做，可能会丧失学OI的兴趣，如果玩过这个卡牌游戏，可能思路会通顺很多，当然本人连听都没听到过。比赛一般不会出这样的题目，只是纯模拟，不需要算法，但真心烦。不多说，直接上代码。

## AC代码及解释如下：

```cpp
#include <bits/stdc++.h>//万能头文件，听说NOI都可以用哟。
using namespace std;
int a[5], b[5], h[5];//a数组用来计分，b数组用来计数
bool flag, flag2, c[5], ss[5], d[5];
inline int Input(){//快速读入，其实此题没卵用。
    char c;
    int n=0;
    do{
        c=getchar();
    }while (c<'0'||c>'9');
    while (c>='0'&&c<='9'){
        n=n*10+c-'0';
        c=getchar();
    }
    return n;
}
int main(){
    string s[5][100];//字符串数组用来处理输入
    int H[14]={0, -50, -2, -3, -4, -5, -6, -7, -8, -9, -10, -20, -30, -40};//H数组存每种分值 
    while ( 1 ){
        memset(a, 0, sizeof(a));
        memset(b, 0, sizeof(b));
        memset(h, 0, sizeof(h));
        memset(ss, false, sizeof(ss));
        memset(d, false, sizeof(d));
        memset(c, false, sizeof(c));//每次判断都要清空所有数组。
        flag = false, flag2 = false;//2个bool型变量设初值为假。
        for (int i=1; i<=4; i++){
            int n;
            n = Input();//快速读入 
            b[i]=n;//设b数组初值为n
            if ( n )
                flag = true;//只要n不为0，就设flag为1
            if (n==16){
                a[i]=1000;  
                for (int j=1; j<=4; j++){
                    if (j!=i)
                        a[j]=0;
                }
                flag2=true;//设flag2为真
            }
            for (int j=1; j<=n; j++){
                cin >> s[i][j];//每当输入（出牌） 
                if (s[i][j]=="D11"||s[i][j]=="C10"||s[i][j]=="S12"||s[i][j][0]=='H')
                switch(s[i][j][0]){//运用c++中的switch和case可以很好地处理此题的输入，简单好用。
                //谨记不能switch字符串，可以用采用字符的形式。 
                    case 'H':{
                        h[i]++;
                        break;
                    }
                    case 'C':{
                        c[i]++;
                        break;
                    }
                    case 'S':{
                        ss[i]=true;
                        break;
                    }
                    case 'D':{
                        d[i]=true;
                        break;
                    }//用case处理每种情况，注意每次case结束都要break。 
                }
            }
        }
        if (flag2){//如果flag2为真，就要特殊处理
            for (int h=1; h<=3; h++){
                if (a[h]>0)     
                    cout << "+" << a[h] << " ";
                else
                    cout << a[h] << " ";
            } 
            if (a[4]>0)
                cout << "+" << a[4] << endl;//判断正负号输出
            else
                cout << a[4] << endl;
            continue;//跳过本次循环
        }
        if (flag==false)
            break;
        for (int i=1; i<=4; i++){
            if (b[i]==16)
                a[i]+=1000;
            if (b[i]==0)//如果b[i]为0，清空a[i]。
                a[i]=0;
            if (h[i]==13){//特判处理 
                if (c[i]==true){
                    for (int j=1; j<=13; i++)
                        a[i]+=H[j]*2;
                    if (ss[i]==true&&d[i]==true)
                        a[i]+=500;
                    if (ss[i]==true)
                        a[i]+=-200;
                    if (d[i]==true)
                        a[i]+=200;
                }
                else{
                    if (ss[i]==true&&d[i]==true)
                        a[i]+=500;
                    if (ss[i]==true)
                        a[i]+=-100;
                    if (d[i]==true)
                        a[i]+=100;
                    if (ss[i]==true&&d[i]==true)
                        a[i]+=500;
                    if (d[i]==true)
                        a[i]+=100;
                    if (ss[i]==true||d[i]==false)
                        a[i]+=200;
                }
            }
            else{
                if (c[i]){//前方高能预警QAQ 
                    for (int j=1; j<=b[i]; j++){
                            if (s[i][j]=="H1")
                                a[i]+=-100;
                            if (s[i][j]=="H2")
                                a[i]+=-4;
                            if (s[i][j]=="H3")
                                a[i]+=-6;
                            if (s[i][j]=="H4")
                                a[i]+=-8;
                            if (s[i][j]=="H5")
                                a[i]+=-10;
                            if (s[i][j]=="H6")
                                a[i]+=-12;
                            if (s[i][j]=="H7")
                                a[i]+=-14;
                            if (s[i][j]=="H8")
                                a[i]+=-16;
                            if (s[i][j]=="H9")
                                a[i]+=-18;
                            if (s[i][j]=="H10")
                                a[i]+=-20;
                            if (s[i][j]=="H11")
                                a[i]+=-40;
                            if (s[i][j]=="H12")
                                a[i]+=-60;
                            if (s[i][j]=="H13")
                                a[i]+=-80;
                            if (s[i][j]=="S12")
                                a[i]+=-200;
                            if (s[i][j]=="D11")
                                a[i]+=200;
                            if (b[i]==1)
                                a[i]+=50;
                                //暴力判断每种情况，同时a数组要加上或减去相应的分数
                        }
                    }
                    else{//前方再次高能QAQ
                        for (int j=1; j<=b[i]; j++){//循环次数用已经存好了的b数组
                            if (s[i][j]=="H1")
                                a[i]+=-50;
                            if (s[i][j]=="H2")
                                a[i]+=-2;
                            if (s[i][j]=="H3")
                                a[i]+=-3;
                            if (s[i][j]=="H4")
                                a[i]+=-4;
                            if (s[i][j]=="H5")
                                a[i]+=-5;
                            if (s[i][j]=="H6")
                                a[i]+=-6;
                            if (s[i][j]=="H7")
                                a[i]+=-7;
                            if (s[i][j]=="H8")
                                a[i]+=-8;
                            if (s[i][j]=="H9")
                                a[i]+=-9;
                            if (s[i][j]=="H10")
                                a[i]+=-10;
                            if (s[i][j]=="H11")
                                a[i]+=-20;
                            if (s[i][j]=="H12")
                                a[i]+=-30;
                            if (s[i][j]=="H13")
                                a[i]+=-40;
                            if (s[i][j]=="S12")
                                a[i]+=-100;
                            if (s[i][j]=="D11")
                                a[i]+=100;
                        }//逐个判断过去，千万不要漏掉任何一个，否则可能会检查很久，真的要怀疑人生了QWQ。
                    }
                }
            }
            for (int i=1; i<=3; i++){
                if (a[i]>0)
                    cout << "+" << a[i] << " ";//如果是正，就加“+”号输出
                else
                    cout << a[i] << " ";//否则直接输出
            }
            if (a[4]>0)
                cout << "+" << a[4] << endl;
            else
                cout << a[4] << endl;//处理方法同上
        }
    return 0;//终于结束了 
}
```
## 推荐博客：http://blog.csdn.net/xingyyn78/article/details/51035856，大家可以参考！


---

## 作者：nvqlfi214 (赞：3)

# 题解 P1148 【拱猪计分】
### 首先先排几个坑。

+ $D$ 牌有 $D10$和 $D11$。~~尽管并没有什么影响~~
+ 输出要有正负号。
+ 当$13$张 $H$ 牌全部都有且$S$牌和$D$牌不同时出现那仍需按照原来计算方法计算

### 进入正题

题目里面一共有$4$种牌：
$H$ 牌、$S$ 牌、$D$ 牌、$C$ 牌。

+ __H 牌__

1. 当$13$张 $H$ 牌全部都有的时候：

首先总分加上$200$

之后如果 $S$ 牌和 $D$ 牌都出现的话

总分再加$300$

2. 当没有集齐$13$张的时候：

总分按照下表减少

```
H1  H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13
−50 −2 −3 −4 −5 −6 −7 −8 −9 −10 −20 −30 −40
```
代码实现：

```cpp
//vis 代表 H 牌有没有出现
//ans 表示总分
//h 数组表示哪一个 H 牌出现应该减几分
//H 记录 H 牌的数量
//s，d 变量都是记录有没有出现 S 牌 D 牌
if(H==13){
	ans[i]+=200;
	if(s&&d)ans[i]+=300;
	else
	if(s)ans[i]-=100;
	else
	if(d)ans[i]+=100;
	}
else{
	if(s)ans[i]-=100;
	if(d)ans[i]+=100;
	for(int j=1;j<=13;j++)
		if(vis[j])ans[i]+=h[j];
}
```

+ __S 牌__

除 $H$ 牌中情况$1$之外均$-100$

代码实现：见上方
+ __D 牌__

除 $H$ 牌中情况$1$之外均$+100$

代码实现：见上方
+ __C 牌__

1. 如果只有 $C$ 牌

总分$+50$

2. 如果不只有 $C$ 牌

总分$*2$

代码实现：
```cpp
//c 记录有无出现 C 牌
//n 表示一共有几张牌
//其余变量名称意义同上
if(n==1&&c)ans[i]+=50;
else
if(c)ans[i]*=2;
```

+ __所有牌都集中在一个人手里__

总分为$1000$，不受前面影响

代码实现：~~需要吗~~
```cpp
if(n==16)ans=1000;
```


完结撒花！

---

## 作者：户山香澄 (赞：2)

不是很难，然而实现比较复杂。

（转C++中的P党：QAQ心好累）

···

    
    
                
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[5];
const int value[16]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40,-100,+100}; //普通的红桃以及猪和狗的常量数组
struct ha
{
    char fl;//花色
    int va;//牌面数字
} f[5][21];//乱七八糟的结构体，多开了几个来存花色的个数
int x[5];
int main()
{
    while (1)
    {
        memset(f,0,sizeof(f));//清零
        memset(x,0,sizeof(x));
        bool flag=true;//判断是否文件结束
        for (int i=1;i<=4;i++)
        {
            int n;
            scanf("%d",&n);//读入个数
            if (n!=0) flag=false;
            for (int j=1;j<=n;j++) 
            {
                scanf("%s",s);//读一个字符串
                f[i][j].fl=s[0];//第一个字符是花色
                f[i][j].va=s[1]-48;
                if (strlen(s)==3) f[i][j].va=f[i][j].va*10+s[2]-48;//牌面数字，还要判断一下是一位数还是两位数
                if (f[i][j].fl=='C') f[i][17].va++;//花色数量
                else if (f[i][j].fl=='S') f[i][18].va++;
                else if (f[i][j].fl=='D') f[i][19].va++;
                else f[i][20].va++;
```
/\* 17：C的个数，18：S的个数，19：D的个数，20：H的个数\*/
            
    
```cpp
            }
            if (n==0) {x[i]=0;continue;}//特判*1
            if (n==16) {x[i]=1000;continue;}//特判*2
            if (f[i][20].va==13) //特判*3（如果H在同一家）
            {
                x[i]+=200;
                if (f[i][18].va==1 && f[i][19].va==1) x[i]+=500;
                else if (f[i][18].va==1) x[i]-=100;
                else if (f[i][17].va==1) x[i]+=100;
            }
            else 
            for (int j=1;j<=n;j++) //普通牌
              if (f[i][j].fl=='H') x[i]+=value[f[i][j].va];
              else if (f[i][j].fl=='S') x[i]+=value[14];
              else if (f[i][j].fl=='D') x[i]+=value[15];
            if (n==1 && f[i][17].va==1) x[i]=50;//只有1张牌且是C牌
            else if (f[i][17].va==1) x[i]*=2;//不只1张牌但是有C牌
        } 
         if (flag) return 0;//4个都是0，文件结束
         for (int i=1;i<=4;i++)
           if (x[i]>0) printf("+%d ",x[i]);//输出，注意+号
           else printf("%d ",x[i]);
         printf("\n");
    }
    return 0;
}
```
···
QAQ
TAT
QWQ
已写吐。。。


---

## 作者：龚祖豪曾用号 (赞：1)




## 题意：

   拱猪是一种很有趣的扑克牌游戏。 即使你不知道它的玩法，你也可以由它的计分方式来了解它的趣味性。 假设在此我们仅考虑四个人的拱猪牌局，本题要求你根据下面的计分规则，在牌局结束时计算四位玩家所得分数。

我们分别以S、H、D 及 C 来代表黑桃，红心，方块及梅花，并以数字 1 至 13 来代表 A、2、…、Q、K 等牌点，例如︰ H1 为红心 A，S13 为黑桃 K。

牌局结束时，由各玩家持有的有关计分的牌(计分牌)仅有 S12 (猪)，所有红心牌，D11 (羊)及 C10 (加倍)等16张牌。其它牌均弃置不计。若未持有这 16 张牌之任一张则以得零分计算。

若持有 C10 的玩家只有该张牌而没有任何其它牌则得 +50 分，若除了 C10 还有其它计分牌，则将其它计分牌所得分数加倍计算。

若红心牌不在同一家，则 H1 至 H13 等 13 张牌均以负分计，其数值为 -50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40。而且 S12 与 D11 分别以 -100 及 +100 分计算。

若红心牌 H1 至H13 均在同一家，有下列情形︰

```
1. 所有红心牌以+200分计算。

2. 若 S12、D11 皆在吃下所有红心牌之一家，则此玩家得 +500 分。

3. 而 C10 还是以前面所述原则计算之。
```

### 例一：若各玩家持有计分牌如下：(每列代表一玩家所持有之牌)

S12 H3 H5 H13

D11 H8 H9

C10 H1 H2 H4 H6 H7

H10 H11 H12

则各家之得分依序为：-148、+83、-138 及 -60。

### 例二：若各玩家持有计分牌如下：(第四家未持有任何计分牌)

H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13

S12 C10

D11 则各家之得分依序为：+200、-200、+100 及 0

### 例三：若有一玩家持有所有 16 张计分牌，则得 +1000 分。其余三家均得零分。



------------


### 思路：

　~~然而我认为这道题并不需要什么思路~~
 

------------

##  注意:

　**1、在所有的红桃牌都在一个玩家的手中时，S12 和 D11仍旧分别以 -100 和 +100 计分，这里被坑了好久。。。。。。**

　　**2、输出时千万记得把+和-输在数字前面o(╥﹏╥)o**
  
 

------------
## 最后code:
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int S[14]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40};
int nums[5][21];
int score[5];
int i,j,k,m,n,heartcount,heartflag,sdcount;
char readc;
bool doubleflag;
void readInt(int &n){
    while((readc=getchar())<48||readc>57);
    n=readc-48;
    while((readc=getchar())>=48&&readc<=57) n=n*10+readc-48;
}
void readcard(int &n){
    while((readc=getchar())<48||readc>'z');
    switch(readc){
        case 'H':
            n=1;
            break;
        case 'S':
            n=2;
            break;
        case 'D':
            n=3;
            break;
        case 'C':
            n=4;
            break;
    }
    while((readc=getchar())>=48&&readc<='z') n=n*10+readc-48;
    if(n/100==0) {
        int temp=n%10;
        n/=10;
        n*=100;
        n+=temp;
    }
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("heart.in","r",stdin);
    freopen("heart.out","w",stdout);
#endif
    while(true){
        memset(score,0,sizeof(score));
        memset(nums,0,sizeof(nums));
        for(i=1;i<=4;i++){
            readInt(nums[i][0]);
            for(j=1;j<=nums[i][0];j++){
                readcard(nums[i][j]);
            }
        }
        if(nums[1][0]==0&&nums[2][0]==0&&nums[3][0]==0&&nums[4][0]==0) break;
        heartflag=0;
        for(i=1;i<=4;i++){
            heartcount=0;
            for(j=1;j<=nums[i][0];j++) if(nums[i][j]/100==1) heartcount++;
            if(heartcount==13) {
                heartflag=i;
                break;
            }else{
                if(heartcount) break;
            }
        }
        //judge if someone have all the hearts
        sdcount=0;
        for(i=1;i<=4;i++){
            if(nums[i][0]==16) {
                score[i]=1000;
                continue;
            }
            doubleflag=false;
            for(j=1;j<=nums[i][0];j++){
                if(nums[i][j]==410) doubleflag=true; //search for doubelflag
            }
            if(heartflag!=i){
                for(j=1;j<=nums[i][0];j++){
                    if(nums[i][j]/100==1) score[i]+=S[nums[i][j]%100];
                    if(nums[i][j]/100==2) score[i]-=100;
                    if(nums[i][j]/100==3) score[i]+=100;
                }
                //if hearts are in different people, count for the score
            }else{
                if(heartflag==i){
                    score[i]+=200;
                    for(j=1;j<=nums[i][0];j++){
                        if(nums[i][j]/100==2||nums[i][j]/100==3) sdcount++;
                    }
                }
                if(sdcount==2) score[i]+=500;
                else{
                    for(j=1;j<=nums[i][0];j++){
                        if(nums[i][j]/100==2) score[i]-=100;
                        if(nums[i][j]/100==3) score[i]+=100;
                    }
                }
                //if all hearts are in the same people , count
            }
            if(doubleflag&&nums[i][0]==1){
                score[i]+=50;
            }else{
                if(doubleflag)score[i]*=2;
            }
            //count for the double
        }
        for(i=1;i<=4;i++) if(score[i]>0) printf("+%d ",score[i]); else printf("%d ",score[i]);
        putchar(10);
    }
    return 0;
}
```

---

## 作者：_hzc_ (赞：1)

### blog2
#### 一道非常非常长的模拟题目，条件非常多，必须必须仔细看题
### ~~（我就是这样第一次错了）唉~~废话不多说，具体过程看以下程序

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
using namespace std;
int b,n;
int y,o=0,u=-1,g=0,t=0,w=0;//临时变量
int f[14]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40};
int k[5]={0};//kj是第j个人的分数，每一次操作都在kj上进行
int chazhao(char zf1,int sz1)
{
		if(zf1=='H')
		{
			b++;
			if(b>0&&b<=13)
			{
				o+=f[sz1];
			}
		}
		if(zf1=='S')
		{
			o-=100;
			u+=2;   //-1+2=1or-2+2=0
		}
		if(zf1=='D')
		{
			o+=100;
			u-=1;   //-1-1=-2or-1+1=0
		}
		if(zf1=='C')
		{
			y=1;
			if(u==-1&&b==0&&n==1)//这个条件要仔细看题
			{//只有一个数C10
				o=25;//25*2=50
			}
		}
		if(b==13)//全部红心都有
		{
			o=200;
			if(u==0)
			{
				o+=500;
			}
		}
	return o;
}
int main()
{
	//freopen("heart.in","r",stdin);比赛一定要写
	//freopen("heart.out","w",stdout);
	char zf;int sz;
	while(1)//多组数据
	{
		b=0;
		for(int i=1;i<=4;i++)
		{
			cin>>n;
			if(n==0)k[i]=0;//没有牌记零分
            
			for(int j=1;j<=n;j++)
			{
			cin>>zf>>sz;//单独输入字符和数字
			k[i]=chazhao(zf,sz);
			if(b==13)
			{
				b=0;
			}
			if(j==n) 
			{
				if(y==1)
				{
					k[i]*=2;//有C10
				}
				u=-1;o=0;y=0;b=0;//每个人执行前回到初始状态
			}
			if(n==16)
			{
				k[i]=1000;
			}//全部牌都在手里
			}
		}
		if(k[1]==0&&k[2]==0&&k[3]==0&&k[4]==0)break;
		for(int i=1;i<=4;i++)
		{
			if(k[i]>0)
			cout<<"+"<<k[i]<<" ";//正数
			else
			cout<<k[i]<<" ";//一直是按照负数执行的
		}
		cout<<endl;
	}
	//fclose(stdin);fclose(stdout);
	return 0;
} 
```
### 对于模拟题呢，考的是实现代码的能力，~~有些题会超时就进行优化~~，要仔细读题，每一个条件都列出来，并自己设置特殊数据测试
# 加油！！！


---

## 作者：JMercury (赞：1)

```
#include<iostream>
using namespace std;

int card[5];
bool MAP[5][17];
int point[17]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40,-100,+100,0};///红心A-K，黑桃Q，方块J

void print(int tmp) ///这题输出怪异，写个输出
{
    if(tmp>0) cout<<'+';
    cout<<tmp<<' ';
}

int main()
{
    while(1)
    {
        ///重置牌的状态
        for(int i=1;i<=4;i++)
        {
            for(int j=1;j<=16;j++)
                MAP[i][j]=false;
        }
        ///记每人拿牌的状态
        for(int i=1;i<=4;i++)
        {
            cin>>card[i];
            for(int j=1;j<=card[i];j++)
            {
                char k;int p;
                cin>>k>>p;
                if(k=='H') MAP[i][p]=true;
                else if(k=='S') MAP[i][14]=true;
                else if(k=='D') MAP[i][15]=true;
                else if(k=='C') MAP[i][16]=true;
            }
        }
        if(card[1]+card[2]+card[3]+card[4]==0) break;
        //以下计分
        for(int i=1;i<=4;i++)
        {
            int tmp=0;
            bool ah=true; ///判断是否全是红心
            for(int j=1;j<=13 && ah;j++) ah=MAP[i][j];
            if(ah)
            {
                tmp=200;
                if(MAP[i][14] && MAP[i][15]) tmp=500; ///是否同时拿黑桃Q和方块J，是就加500
                else tmp=tmp+MAP[i][14]*point[14]+MAP[i][15]*point[15]; ///否则每张牌单独加
                if(MAP[i][16]) tmp*=2; ///是否有变压器翻倍
                print(tmp);
            }
            else
            {
                bool an=true;
                for(int j=1;j<=15 && an;j++) an=!MAP[i][j];
                if(an) ///判断是不是其他牌都没有
                {
                    if(MAP[i][16]) tmp=50;
                    print(tmp);
                }
                else
                {
                    for(int j=1;j<=15;j++) tmp=tmp+MAP[i][j]*point[j];
                    if(MAP[i][16]) tmp*=2;
                    print(tmp);
                }
            }
        }
        cout<<endl;
    }
    return 0;
}


```

---

## 作者：浮生南柯一梦 (赞：0)

~~由于我认为本题的6篇题解在前面如何模拟方面解释都不到位，大部分都只有程序，我决定发一篇题解来弥补一下。~~

## 核心思路

1.首先我们不难发现，这四个人互相之间是不存在关联的，因此我们可以对他们进行逐一操作。

2.在针对每位玩家操作的时候，我们可以发现，除了C10暂时不可以用以外，其他的牌都可以直接使用，因此我们只需要在读入的同时进行计算，如果是红桃牌则计数器++，D11或者S12则记录一下。

3.在读入完该为玩家的所有操作以后，我们先看计数器是否为13，如果是就说明他集齐了红桃牌，那么我们给答案加上394（因为之前减掉了这13张牌的分数，共为194分，而集齐13张牌按照+200分计算，故加上394）。

4.在计数器是13的前提下，我们看之前做的记录，D11和S12是否都在内，如果是则给答案加上300（因为计数器那里已经加过200，一共要加500，所以此处加300）

5.如果有C10牌就给答案翻倍。

**注意：如果只有一张C10牌答案是50分！！！（我第一次就在这里WA了）**

6.答案不要先输出，拿数组记下来，如果最后读入的四个数字都是0那就退出去，否则输出答案，但是**不要忘记正数前面要加+号**。

 _接下来把我的代码奉上，没有做批注，因为和我之前说的思路完全相同，相信大家可以看的懂。代码仅供参考，还是要自己打一遍出来才有体会的。_ 
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d,s,ss,ans[11];
bool f,ff,fff;
string e;
template <typename T> void read(T &x)
{
	x=0;char c=getchar();bool flg=0;
	for (;!isdigit(c);c=getchar()) if (c=='-') flg=1;
	for (;isdigit(c);c=getchar()) x=x*10+c-'0';
	if (flg) x=-x;
}
int main(){
	/*freopen(".in","r",stdin);
	freopen(".out","w",stdout);*/
	ios::sync_with_stdio(false);
	while (1)
	{
		cin>>a;s=0;ss=0;f=0;ff=0;fff=0;
		for (int i=1;i<=a;i++)
		{
			cin>>e;
			if (e=="H1") 
			{
				s++;
				ss-=50;
			}
			if (e=="H2") 
			{
				s++;
				ss-=2;
			}
			if (e=="H3") 
			{
				s++;
				ss-=3;
			}
			if (e=="H4") 
			{
				s++;
				ss-=4;
			}
			if (e=="H5") 
			{
				s++;
				ss-=5;
			}
			if (e=="H6") 
			{
				s++;
				ss-=6;
			}
			if (e=="H7") 
			{
				s++;
				ss-=7;
			}
			if (e=="H8") 
			{
				s++;
				ss-=8;
			}
			if (e=="H9") 
			{
				s++;
				ss-=9;
			}
			if (e=="H10") 
			{
				s++;
				ss-=10;
			}
			if (e=="H11") 
			{
				s++;
				ss-=20;
			}
			if (e=="H12") 
			{
				s++;
				ss-=30;
			}
			if (e=="H13") 
			{
				s++;
				ss-=40;
			}
			if (e=="S12") 
			{
				f=1;
				ss-=100;
			}
			if (e=="D11") 
			{
				ff=1;
				ss+=100;
			}
			if (e=="C10") fff=1;
		}
		if ((f)&&(ff)&&(s==13)) ss=500;
		else if (s==13) ss+=394;
		if (fff) ss*=2;
		if ((s==0)&&(f==0)&&(ff==0)&&(fff)) ss=50;
		if (a==0)
		ans[1]=0;
		else ans[1]=ss;
		cin>>b;s=0;ss=0;f=0;ff=0;fff=0;
		for (int i=1;i<=b;i++)
		{
			cin>>e;
			if (e=="H1") 
			{
				s++;
				ss-=50;
			}
			if (e=="H2") 
			{
				s++;
				ss-=2;
			}
			if (e=="H3") 
			{
				s++;
				ss-=3;
			}
			if (e=="H4") 
			{
				s++;
				ss-=4;
			}
			if (e=="H5") 
			{
				s++;
				ss-=5;
			}
			if (e=="H6") 
			{
				s++;
				ss-=6;
			}
			if (e=="H7") 
			{
				s++;
				ss-=7;
			}
			if (e=="H8") 
			{
				s++;
				ss-=8;
			}
			if (e=="H9") 
			{
				s++;
				ss-=9;
			}
			if (e=="H10") 
			{
				s++;
				ss-=10;
			}
			if (e=="H11") 
			{
				s++;
				ss-=20;
			}
			if (e=="H12") 
			{
				s++;
				ss-=30;
			}
			if (e=="H13") 
			{
				s++;
				ss-=40;
			}
			if (e=="S12") 
			{
				f=1;
				ss-=100;
			}
			if (e=="D11") 
			{
				ff=1;
				ss+=100;
			}
			if (e=="C10") fff=1;
		}
		if ((f)&&(ff)&&(s==13)) ss=500;
		else if (s==13) ss+=394;
		if (fff) ss*=2;
		if ((s==0)&&(f==0)&&(ff==0)&&(fff)) ss=50;
		if (b==0)
		ans[2]=0;
		else ans[2]=ss;
		cin>>c;s=0;ss=0;f=0;ff=0;fff=0;
		for (int i=1;i<=c;i++)
		{
			cin>>e;
			if (e=="H1") 
			{
				s++;
				ss-=50;
			}
			if (e=="H2") 
			{
				s++;
				ss-=2;
			}
			if (e=="H3") 
			{
				s++;
				ss-=3;
			}
			if (e=="H4") 
			{
				s++;
				ss-=4;
			}
			if (e=="H5") 
			{
				s++;
				ss-=5;
			}
			if (e=="H6") 
			{
				s++;
				ss-=6;
			}
			if (e=="H7") 
			{
				s++;
				ss-=7;
			}
			if (e=="H8") 
			{
				s++;
				ss-=8;
			}
			if (e=="H9") 
			{
				s++;
				ss-=9;
			}
			if (e=="H10") 
			{
				s++;
				ss-=10;
			}
			if (e=="H11") 
			{
				s++;
				ss-=20;
			}
			if (e=="H12") 
			{
				s++;
				ss-=30;
			}
			if (e=="H13") 
			{
				s++;
				ss-=40;
			}
			if (e=="S12") 
			{
				f=1;
				ss-=100;
			}
			if (e=="D11") 
			{
				ff=1;
				ss+=100;
			}
			if (e=="C10") fff=1;
		}
		if ((f)&&(ff)&&(s==13)) ss=500;
		else if (s==13) ss+=394;
		if (fff) ss*=2;
		if ((s==0)&&(f==0)&&(ff==0)&&(fff)) ss=50;
		if (c==0)
		ans[3]=0;
		else ans[3]=ss;
		cin>>d;s=0;ss=0;f=0;ff=0;fff=0;
		for (int i=1;i<=d;i++)
		{
			cin>>e;
			if (e=="H1") 
			{
				s++;
				ss-=50;
			}
			if (e=="H2") 
			{
				s++;
				ss-=2;
			}
			if (e=="H3") 
			{
				s++;
				ss-=3;
			}
			if (e=="H4") 
			{
				s++;
				ss-=4;
			}
			if (e=="H5") 
			{
				s++;
				ss-=5;
			}
			if (e=="H6") 
			{
				s++;
				ss-=6;
			}
			if (e=="H7") 
			{
				s++;
				ss-=7;
			}
			if (e=="H8") 
			{
				s++;
				ss-=8;
			}
			if (e=="H9") 
			{
				s++;
				ss-=9;
			}
			if (e=="H10") 
			{
				s++;
				ss-=10;
			}
			if (e=="H11") 
			{
				s++;
				ss-=20;
			}
			if (e=="H12") 
			{
				s++;
				ss-=30;
			}
			if (e=="H13") 
			{
				s++;
				ss-=40;
			}
			if (e=="S12") 
			{
				f=1;
				ss-=100;
			}
			if (e=="D11") 
			{
				ff=1;
				ss+=100;
			}
			if (e=="C10") fff=1;
		}
		if ((f)&&(ff)&&(s==13)) ss=500;
		else if (s==13) ss+=394;
		if (fff) ss*=2;
		if ((s==0)&&(f==0)&&(ff==0)&&(fff)) ss=50;
		if (d==0)
		ans[4]=0;
		else ans[4]=ss;
		if ((a==0)&&(b==0)&&(c==0)&&(d==0)) return 0;
		if (ans[1]>0)
		cout<<"+"<<ans[1]<<' ';
		else cout<<ans[1]<<' ';
		if (ans[2]>0)
		cout<<"+"<<ans[2]<<' ';
		else cout<<ans[2]<<' ';
		if (ans[3]>0)
		cout<<"+"<<ans[3]<<' ';
		else cout<<ans[3]<<' ';
		if (ans[4]>0)
		cout<<"+"<<ans[4]<<endl;
		else cout<<ans[4]<<endl;
	}
	return 0;
}

```
~~后记：模拟题其实不难的，有耐心做就可以了。~~

---

## 作者：HPXXZYY (赞：0)

题目链接：（1）[Luogu-P1148 拱猪计分（新版链接）](https://www.luogu.org/fe/problem/P1148)

（2）[Luogu-P1148 拱猪计分（旧版链接）](https://www.luogu.org/problemnew/show/P1148)

特别麻烦的模拟……

直接上代码

```cpp
#include <map>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int dx[]={0,-50,-2,-3,-4,-5,-6,-7,-8,-9,-10,-20,-30,-40};
//红记分牌的扣分
map<string,int> b;int ans[7],n[7],a[7][20],i,j;
bool find(int k,int x){
    if (n[k]==0) return false;
    for(int i=1;i<=n[k];i++)
    if (a[k][i]==x) return 1;
    return false;
}
//从第k个人的牌中寻找编号为x的记分牌 
bool check_red(int k){
    for(int i=1;i<14;i++)
    if (!find(k,i))
    return false;
    return true;
}
#define ri register int
//判断第k个人是否拥有所有的红牌 
int calc(int k){
    if (n[k]==16) return 1000;
//	所有记分牌都有，共1000分 
    if (n[k]==0) return 0;
    bool s12=0,d11=0,c10=0;
    register int p=0,ans=0;
    for(ri i=1;i<=n[k];i++){
        if (a[k][i]<14){
            if (!check_red(k)){
                p=1;break;
            }
            else{
                p=2;break;
            }
        }
    }
    //p=0表示没有红牌
    //p=1表示有但没有所有的红牌
    //p=2表示有且有所有的红牌
    for(ri i=1;i<=n[k];i++){
        switch(a[k][i]){
            case 14:d11=1;break;//有D11
            case 15:s12=1;break;//有S12
            case 16:c10=1;break;//有C10
            default:if (p==1) ans+=dx[a[k][i]];
            //有但没有所有的红记分牌，所以扣分
        }
    }
    if (p==2){
        if (d11&&s12) ans=500;
        else{
            ans=200;
            if (s12) ans-=100;
            else if (d11) ans+=100;
        }
    }
    else{
        if (p==0) ans=0;
        if (s12) ans-=100;
        if (d11) ans+=100;
    }
    if (c10){
        if (n[k]==1) ans=50;
        else ans*=2;
    }
    //计算每个人的得分（规则看题目）
    return ans;
}
int main(){
//	freopen("t1.in","r",stdin);
    b["H1"]=1;b["H2"]=2;b["H3"]=3;b["H4"]=4;
    b["H5"]=5;b["H6"]=6;b["H7"]=7;b["H8"]=8;
    b["H9"]=9;b["H10"]=10;b["H11"]=11;
    b["H12"]=12;b["H13"]=13;b["D11"]=14;
    b["S12"]=15;b["C10"]=16;//各记分牌编号 
    memset(n,-1,sizeof(n));
    while (cin>>n[1]){
        if (n[1]==0){
            cin>>n[2];
            if (n[2]==0){
                cin>>n[3];
                if (n[3]==0){
                    cin>>n[4];
                    if (n[4]==0){
                        return 0;
                    }
                }
            }
        }
        //判断是否结束输入
        for(i=1;i<5;i++){
            if (n[i]==-1) cin>>n[i];
            for(j=1;j<=n[i];j++){
                register string s;
                cin>>s;a[i][j]=b[s];
            }
        }
        for(i=1;i<5;i++)
        ans[i]=calc(i);
        for(i=1;i<4;i++){
            if (ans[i]>0) printf("+");
            printf("%d ",ans[i]);
        }
        if (ans[4]>0) printf("+");
        printf("%d\n",ans[4]);
        //输出
        memset(n,-1,sizeof(n));
//		This is very important!
    }
    return 0;
}
```
希望大家多多支持本蒟蒻（juruo）的题解

---


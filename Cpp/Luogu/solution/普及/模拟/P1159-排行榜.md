# 排行榜

## 题目描述

小迈克尔住在一个小镇上，他喜欢看每周日下午发布的音乐电视评比。它每周都根据选票介绍相同的歌曲，列出这些歌曲的流行排行榜。

有一个星期日迈克尔和他的朋友在一起玩得太久了以致于未能看到新的流行榜。他非常失望，但是不久他就发现下周至少可以部分地建立出流行榜。除了每首歌曲的位置，排行榜还根据这些歌曲上周的排行列出了它们排行变动的信息，更精确地说，从这周起，不管那首歌是继续排在原位，还是排名上升或排名下降，都会给出一点说明。

编写程序，根据给定的流行榜帮助迈克尔推断出上周可能的排行榜。


## 样例 #1

### 输入

```
5
HIGHHOPES
UP
LOWFEELINGS
UP
UPANDDOWN
DOWN
IAMSTILLSTANDING
DOWN
FOOLINGAROUND
DOWN
```

### 输出

```
UPANDDOWN
IAMSTILLSTANDING
FOOLINGAROUND
HIGHHOPES
LOWFEELINGS
```

# 题解

## 作者：OnlyU (赞：59)

本蒟蒻的第一篇题解，希望能过。
其实这道题是一道非常水的模拟题，看了一遍题目后发现这样的规律：排行不变的歌当然不变，排行下滑的歌先输出，排行上升的歌后输出就好了。
知道思路后我们就可以用数组模拟了。
具体代码见下：
```cpp
include<bits/stdc++.h>
using namespace std;
string Sup[101],Sdown[101],ans[101];//Sup数组储存UP的歌,Sdown数组储存DOWN的歌 ,ans数组储存最终的答案
int up=0,down=0,now1=0,now2=0;//up是UP的歌的数量，down是DOWN的歌的数量
int n;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		string s1,s2;
		cin>>s1>>s2;
		if(s2=="UP") {
			up++;
			Sup[up]=s1;
		}
		if(s2=="DOWN") {
			down++;
			Sdown[down]=s1;
		}
		if(s2=="SAME") {
			ans[i]=s1;
		}
	}
	for(int i=1; i<=n; i++) {
		if(ans[i]!="")continue;
		else {
			if(now1<down) {
				now1++;
				ans[i]=Sdown[now1];
			} else {
				now2++;
				ans[i]=Sup[now2];
			}
		}
	}
	for(int i=1; i<=n; i++)
		cout<<ans[i]<<endl;
	return 0;
}
```


---

## 作者：SofanHe (赞：41)

**C++选手看这里**

# 方法介绍

## 首先介绍一下STL里面的queue

它可以实现一个无限长度的序列,还可以保存他们的顺序,并且可以用他们进入的顺序调用.

在这里我们就使用了两个queue.

## bool数组标记法

考虑到有SAME的存在,我们不能对它进行排序,因此,我们把它标记出来,特殊处理特殊对待.

# 具体思想

## 审题可得信息

通过题目输出提示的后面的话,"每组数据有大于一个的解",再结合样例,我们可以看出来,只要一组解就可以了.

所以,我就只处理了一组解QWQ

## 对于UP

显然,UP的歌曲,原来一定在目前位置的下面,所以,我们假设他上周是最后几名.

## 对于SAME

上文提到过的bool数组标记法,当我们输出的时候,如果i这位置已经确定,那么就输出这个i位置上面的歌曲,否则在考虑从UP,DOWN里面选.

## 对于DOWN

他一定在前面,不妨假设他是第一个,然后向后排.

# 细节处理

如果我们使用STACK来存储,那么假设有一个总共5个点的数据,1,2,4都是UP,如果使用STACK,4号排的位置一定是第三个或之前,因此我们使用双QUEUE.一个来储存应该排在前面的歌曲(标记为DOWN的),另一个来存应该排在后面的歌曲(标记为UP的),对于SAME的我们就直接标记到BOOL数组里面.这样既可以保存进入的顺序,又可以先后排序.

# 可行性优化

对于正式比赛中,如果不开O2的话,STL可能会很慢,所以我们可以考虑使用数组,对于最坏情况,开100,所以,我们只需要开200个数组,1~100,存原来的应该排在前面的,101~200存原来应该放到后面的,这样,在中间就判定一下是不是到了中间空着的0,跳过就可以了.(全局变量大法好).

```cpp
#include<bits/stdc++.h>
using namespace std;
string name[101],dos;
queue<int> fr,en;
int n;bool sa[101];
int main(){
    cin>>n;for(int i=1;i<=n;i++){
        cin>>name[i]>>dos;
        if(dos=="UP")en.push(i);
        if(dos=="DOWN")fr.push(i);
        if(dos=="SAME")sa[i]=1;
    }
    for(int i=1;i<=n;i++){
        if(sa[i]==1)cout<<name[i]<<endl;
        else{
        if(!fr.empty()){cout<<name[fr.front()]<<endl;fr.pop();}
        else if(!en.empty()){cout<<name[en.front()]<<endl;en.pop();}
        }
    }
    return 0;
}
```

---

## 作者：dingcx (赞：33)

期中考试结束了！趁着这个愉悦的日子，发一篇题解。
## 思路
难道所有绿题都是图论线段树动态规划吗？不是！比如这道题，它就是个**纯模拟**。

首先，$same$的就直接记录，没什么好说的。

其次处理$down$。所有这样的歌，原来的排名一定靠前，干脆就把它**放在最前面**（只要输出一组解），排名越靠前的上周就应该更靠前，所以遍历时应该**从前往后遍历**。

最后处理$up$。同理，把这些歌**放在最后面**，并且遍历时应该**从后往前遍历**。

注意要看这个排名有没有之前被用过（$same$的歌），比如$down$的情况，解决办法是在记录每个$down$的歌前**把指针往后移**，**直到没有被用过**，以保证这个名次没有被用过。代码如下：
```cpp
//ans记录上周排名，front为指针
while(ans[front]) front++;//被用过就向后移，ans数组自动全为0
ans[front]=i;//记录
```

还要注意读入字符串，$cin$没有问题，$scanf$要注意换行。
## 代码
~~相信没有多少人喜欢上面的一通分析吧~~，那么，你们喜欢的代码来了——
```cpp
//时间4ms，长度30行
#include<cstdio>
#include<cstring>
#include<iostream>//几个头文件
using namespace std;
const int MAXN=110;
string name[MAXN],st[MAXN];
int ans[MAXN];//上周排名
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		cin>>name[i]>>st[i];//读入字符串
		if(st[i][0]=='S') ans[i]=i;//相同直接标记
	}
	int front=1,rear=n;//两个指针
	for(int i=1;i<=n;i++){//down的情况
		if(st[i][0]=='D'){
			while(ans[front]) front++;
			ans[front]=i;
		}
	}
	for(int i=n;i>0;i--){//up的情况，从后往前
		if(st[i][0]=='U'){
			while(ans[rear]) rear--;
			ans[rear]=i;
		}
	}
	for(int i=1;i<=n;i++) cout<<name[ans[i]]<<endl;//输出
	return 0;//华丽结束
}
```
写题解并不是一件容易的事，别忘了点个赞！

---

## 作者：二分之一 (赞：11)

蒟蒻的第一篇题解，希望能过

一开始看这道题的时候其实挺懵的，看不懂什么意思，后来经（kan）过（wan）思（ti）索（jie）之后，才搞清楚是什么意思，same的歌排名不变，先输出down的再输出up的就行了

~~（所以我也只能永远是一个蒟蒻了）~~

话不多说，上代码~~

```cpp
#include<bits/stdc++.h>
using namespace std;
struct now
{
	string name;
	string zhuangtai;
}s[101];//结构体，存储现在的排名以及变化情况
string a[101];//存储上升了的歌
string b[101];//存储下降了的歌
int r[101]={0};//判断是否变换名次
string before[101];
int main()
{
	int n;
	cin>>n;
	int x=0,y=0;//搞个指针
	for(int i=1;i<=n;i++)
	{
		cin>>s[i].name>>s[i].zhuangtai;
		if(s[i].zhuangtai=="UP")//上升
		{
			x++;
			a[x]=s[i].name;//存入a数组
		}
		else if(s[i].zhuangtai=="DOWN")//下降
		{
			y++;
			b[y]=s[i].name;//存入b数组
		}
		else if(s[i].zhuangtai=="SAME")
		{
			before[i]=s[i].name;//直接存入最终输出的数组里
			r[i]=1;//现在排名是i的歌名次未变
		}
	}
	int p=1;//又一个指针
	for(int i=1;i<=y;i++)//输出下降的歌
	{
		if(r[p]==0)//如果现在排名第p的歌名次变了，则存入
		{
			before[p]=b[i];
			p++;
		}
		else//反之直接过
		{
			p++;
			i--;
		}
	}
	for(int i=1;i<=x;i++)//同上，存上升的歌
	{
		if(r[p]==0)
		{
			before[p]=a[i];
			p++;
		}
		else
		{
			p++;
			i--;
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<before[i]<<endl;//输出
	}
	return 0;
}
```

---

## 作者：dfydada⚡⚡⚡ (赞：5)

这题可以分成几个步骤慢慢写。

先把操作符先存起来，经过一顿操作后才统一放到ch数组里面。如果是SAME的话就标记i的位置在直接放入ch数组里面

上代码：

```cpp
for(int i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];
        if(y[i]=="UP")
        {
            ans++;
            a[ans]=x[i];
        }
        else if(y[i]=="DOWN")
        {
            ant++;
            b[ant]=x[i];
        }
        else if(y[i]=="SAME")
        {
            ch[i]=x[i];
            r[i]=1;
        }
    }
```
先进行up的判断：

如果没有被标记就放入ch数组里面，有就跳过。

上代码：

```cpp
for(int i=1;i<=ant;i++)
    {
        if(r[tot]==0)
        {
            ch[tot]=b[i];
            tot++;
        }
        else
        {
            tot++;
            i--;
        }
    }
```
在进行down的判断：

如果没有被标记就放入ch数组里面，有就跳过。

上代码：

```cpp
for(int i=1;i<=ans;i++)
    {
        if(r[tot]==0)
        {
            ch[tot]=a[i];
            tot++;
        }
        else
        {
            tot++;
            i--;
        }
    }
```
最后输出ch数组就可以了。

总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=100+10;
int n;
int ans,ant,tot=1,r[N];
string x[N],y[N];
string a[N],b[N],ch[N];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];
        if(y[i]=="UP")
        {
            ans++;
            a[ans]=x[i];
        }
        else if(y[i]=="DOWN")
        {
            ant++;
            b[ant]=x[i];
        }
        else if(y[i]=="SAME")
        {
            ch[i]=x[i];
            r[i]=1;
        }
    }
    for(int i=1;i<=ant;i++)
    {
        if(r[tot]==0)
        {
            ch[tot]=b[i];
            tot++;
        }
        else
        {
            tot++;
            i--;
        }
    }
    for(int i=1;i<=ans;i++)
    {
        if(r[tot]==0)
        {
            ch[tot]=a[i];
            tot++;
        }
        else
        {
            tot++;
            i--;
        }
    }
    for(int i=1;i<=n;i++)
    {
        cout<<ch[i]<<endl;
    }
    return 0;
}


```


---

## 作者：gryql (赞：3)

把SAME的留下，DOWN的从前往后排到前面，UP的从前往后排到后面即可。

```delphi

type ss=record  
    na:string;  
    ra,x:longint;  
    end;  
  
var a,b:array[1..10000] of ss;  
    f:array[1..10000] of boolean;  
    n,i,j,k:longint;  
    s:string;  
  
begin  
    fillchar(f,sizeof(f),false);  
    readln(n);  
    for i:=1 to n do  
        begin  
            readln(a[i].na);  
            readln(s);  
            if s='UP'then a[i].x:=1;  
            if s='DOWN'then a[i].x:=0;  
            if s='SAME'then a[i].x:=-1;  
            a[i].ra:=i;  
        end;  
    for i:=1 to n do  
        if a[i].x=-1 then  
            begin  
                b[i]:=a[i];  
                f[i]:=true;  
            end;  
    k:=1;  
    for i:=1 to n do  
        if a[i].x=0 then  
            begin  
                if not f[k] then  
                    begin  
                        b[k]:=a[i];  
                        f[k]:=true;  
                        continue;  
                    end;  
                if f[k] then  
                    while true do  
                        begin  
                            inc(k);  
                            if not f[k] then  
                                begin  
                                    b[k]:=a[i];  
                                    f[k]:=true;  
                                    break;  
                                end;  
                        end;  
                continue;  
            end;  
    for i:=1 to n do  
        if a[i].x=1 then  
            begin  
                if not f[k] then  
                    begin  
                        b[k]:=a[i];  
                        f[k]:=true;  
                        continue;  
                    end;  
                if f[k] then  
                    while true do  
                        begin  
                            inc(k);  
                            if not f[k] then  
                                begin  
                                    b[k]:=a[i];  
                                    f[k]:=true;  
                                    break;  
                                end;  
                        end;  
                continue;  
            end;  
    for i:=1 to n do  
        writeln(b[i].na);  
end.  
```delphi

也有一种二分图做法，程序是对的，但是输出和贪心做的输出不同，所以会WA，详见

http://www.cnblogs.com/yangqingli/p/4908492.html


---

## 作者：a15326987 (赞：2)

# 究极暴力循环求法
   有一说一，这道题是真的水，不亏是模拟。
   
   首先说说我的思路。
   
   先找出存在“SAME”的字符，用一个vis数组来解决排位是否重复的问题。
   
   然后就开始暴力开找（分两次）
   
   上代码！！！！
   ```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct p
{
	string name;
	string wei;
	int pw;
}a[10001];
bool bj(p a,p b)
{
	return a.pw<b.pw;
}
bool vis[10001];
int main()
{
	int ss=0;
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].name>>a[i].wei;
		if(a[i].wei=="SAME")a[i].pw=i,vis[i]=1;
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i].wei=="DOWN")
		{
			for(int j=1;j<=n;j++)
			{
				if(vis[j]==0)
				{
				a[i].pw=j;
				vis[j]=1;
				break;	
		     	}
			}	
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i].wei=="UP")
		{
			for(int j=1;j<=n;j++)
			{
				if(vis[j]==0)
				{
				a[i].pw=j;
				vis[j]=1;
				break;	
		     	}
			}	
		}
	}
	sort(a+1,a+n+1,bj);
	for(int i=1;i<=n;i++)
	{
		cout<<a[i].name<<endl;
	}
}
	

```


---

## 作者：LGG_ (赞：2)

# 数组模拟，简单易懂

SAME：原位置（标记）

DOWN：从第一位没标记的开始放（放完标记）

UP：	从第一位没标记的开始放

~~有些地方可以优化的~~代码：
```c
#include"iostream"
#include"cstring"
using namespace std;
int t=-1,n,ans=0;
int u[101]={0};//标记该位置有歌
string a[101],b[101],c[101];//歌，动态，队列数组
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i]; 
	}
	for(int i=1;i<=n;i++)
	{
		if(b[i]=="SAME")
		{
			c[i]=a[i];
			u[i]=1;
		}
	}//标记加入队SAME
	for(int i=1;i<=n;i++)
	{
		if(b[i]=="DOWN")
		{
			t=-1;
			while(t<0)
			{
				ans++;
				if(u[ans]!=1){
					c[ans]=a[i];//入队
					u[ans]=1;//标记
					t=1;
				}
			}
		}
	}//DOWN先放UP就可以从第一位开始入队
	ans=0;
	for(int i=1;i<=n;i++)
	{
		if(b[i]=="UP")
		{
			t=-1;
			while(t<0)
			{
				ans++;
				if(u[ans]!=1){
					c[ans]=a[i];//入队
					t=1;
				}
			}	
		}
	}//UP入队
	for(int i=1;i<=n;i++)
	{
		cout<<c[i]<<endl;
	}
	return 0;	
}
```

~~有些地方可以类似剪枝优化，就不演示了~~

~~刷题去~~（逃~
![](https://cdn.luogu.com.cn/upload/pic/1436.png)


---

## 作者：信赖滴星辰 (赞：2)

### [P1159 排行榜](https://www.luogu.org/problemnew/show/P1159)

----------

看题解的同学们都把这道题目看得太难了（或者根本看不懂？~~跟我一样~~）

因为只要输出一种情况，我们就考虑最简单的情况：

用 ans [ i ] 储存最后应该输出的答案

1. 当这首歌为 "SAME" ，它的排名没变，那么它现在的排名就是它上一周的排名；

2. 当这首歌为 "UP" ， 它的排名上升了。我们考虑最简单的情况，认为它本来是排名很低的（这样才有排名上升的余地），低到比所有"DOWN"的歌都低。

	#### 但是比本来排名就比它低的"UP"歌高
    
3. 当这首歌为"DOWN"时，与上同理。认为它本来排名是很高的。

4. 所以，第一首不幸为"DOWN"的歌，是原来所有歌中排名最高的（除非第一首是"SAME"）

### 换句话说 , "SAME"的歌排名不变，先输出 DOWN 的再输出 UP 的就行了

------------

### $\mathfrak{Code}$ 
------------

```cpp

#include <iostream>
#include <cstdio>
using namespace std;

struct node
{
    string name;
    string num;
};
node s[104];

int n,x,y,p;
string up[104];
string down[104];
bool check[104];  //用来判断歌的排名变了没有

string ans[104];

int main()
{
    cin>>n;
    
    for(int i=1; i<=n; i++) //将 up 和 down 的歌分别存在两个不同的数组里
    {
        cin >> s[i].name >> s[i].num;
        
        if( s[i].num == "UP" )
        {
            x++;
            up[x] = s[i].name;   
        }
        
        else if( s[i].num == "DOWN" )
        {
            y++;
            down[y] = s[i].name;
        }
        
        else if( s[i].num == "SAME" )
        {
            ans[i] = s[i].name;  //直接存答案里
            check[i] = 1;  //排名没变
        }
    }
    
    p=1;
    
    for(int i=1; i<=y; i++)
    {
        if( check[p] == 0 ) ans[p]=down[i],p++;
        //如果排名变了，就存进去
        
        else p++,i--;
        //不然就跳过
    }
    
    for(int i=1; i<=x; i++)
    {
        if( check[p] == 0 ) ans[p]=up[i],p++;
            
        else p++,i--;
            
    }
    
    for(int i=1; i<=n; i++)
    {
        cout << ans[i] << endl;
    }
    
return 0;
}


```

自己想想吧，不难哒









---

## 作者：philosopherchang (赞：2)

对于这道题，我们可以先确定SAME的位置，再安UP的位置，最后DOWN

实现的话就用队列就行了，pop,front很好用

平易近人的代码

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
string s[101],ss;
queue<int > up;
queue<int > down;
int ans[101];
int n;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i]>>ss;
		if(ss=="UP")
		{
			up.push(i);
		}
		else if(ss=="DOWN")
		{
			down.push(i);
		}
		else
		ans[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		if(!ans[i])
		{
			if(!down.empty())
			{
				ans[i]=down.front();
				down.pop();
			}
			else
			{
				ans[i]=up.front();
				up.pop();
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<s[ans[i]]<<endl;
	}
}
```

---

## 作者：karma (赞：2)

//这道题比较麻烦(因为本人是个蒟蒻)，所以直接模拟//注意：输出顺序比较奇怪，(可能我没搞懂题意)要按照样例的顺序输出

```cpp
//(即按照输入的顺序输出)
#include<stdio.h>
#include<string.h>
char s1[110][110];//歌名
char s2[110][10];//变化
char up[110][110];//上升的歌名
char down[110][110];//下降的歌名
int x=0;//对于(上升的歌名)自增变量
int y=0;//对于(下降的歌名)自增变量
int N;//歌曲数量
int count=0;//计算输出歌名的个数
int main(){
    scanf("%d",&N);//输入不解释
    for(int i=0;i<N;i++)scanf("%s %s",s1[i],s2[i]);//输入不解释
    for(int i=0;i<N;i++){
        if(strcmp(s2[i],"UP")==0){strcpy(up[x],s1[i]);x++;}//找到UP的歌名
        else if(strcmp(s2[i],"DOWN")==0){strcpy(down[y],s1[i]);y++;}//找到DOWN的歌名
    }
    y-=1;x-=1;//由于数组从0考开始，所以输出时减1
    int cx=0,cy=0;//输出顺序从0开始
    while(count!=N){//当输出的歌名不等于歌名的数量时
        if(strcmp(s2[count],"SAME")==0){printf("%s\n",s1[count]);count++;}//如果在输入中碰到SAME，输出对于的歌名
        else if(cy-y!=1){printf("%s\n",down[cy++]);count++;}//优先输出down数组中的歌名
        else if(cy-y==1&&cx!=x+1){printf("%s\n",up[cx++]);count++;}//当down数组输出完后，再输出up数组
    }
    return 0;
}
//本人蒟蒻，求神犇带带我
```

---

## 作者：Deny_小田 (赞：2)

良心翻译楼下Pascal。

思路谁都会=，=  就是实现有点问题。

之前我的代码0蛋，考虑的不周全。


附代码：






            
    
    
    
    
```cpp
#include <cstdio>
#include <string>
#include <cstdlib>
#include <cstring>
#include <iostream>
using namespace std;
const int size = 10005;
struct _node{
       string na;
       int ra,x;
}a[size],b[size];
bool f[size];
int n,k;
string s;
void assign(int p, int q){
     b[p].na = a[q].na;
     b[p].ra = a[q].ra;
     b[p].x = a[q].x;   
} 
int main(){
    memset(f, false, sizeof(f));
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
            cin >> a[i].na >> s;
            if(s == "UP") a[i].x = 1;
            if(s == "DOWN") a[i].x = 0;
            if(s == "SAME") a[i].x = -1;
            a[i].ra = i;
    }
    for(int i = 1; i <= n; i++){
            if(a[i].x == -1){
                      assign(i, i);
                      f[i] = true;
            }    
    }
    k = 1;
    for(int i = 1; i <= n; i++){
            if(!a[i].x){
                        if(!f[k]){
                                 assign(k, i);
                                 f[k] = true; 
                                 continue; 
                        }
                        if(f[k]){
                                 while( true ){
                                        k++;
                                        if(!f[k]){
                                            assign(k, i);
                                            f[k] = true;
                                            break;
                                        }
                                 }
                        }
                        continue;
            }
    }
    for(int i = 1; i <= n; i++){
            if(a[i].x == 1){
                      if(!f[k]){
                             assign(k, i);
                             f[k] = true;
                             continue;   
                      }
                      if(f[k]){
                               while( true ){
                                      k++;
                                      if(!f[k]){
                                                assign(k, i);
                                                f[k] = true;
                                                break;
                                      }
                               }
                      }
                      continue;
            }
    }
    for(int i = 1; i <= n; i++) cout << b[i].na << endl;
    return 0;
}

```

---

## 作者：传奇英雄 (赞：0)

为大家提供一种贪心算法

1.将SAME直接处理

2.统计DOWN和UP，分别存在d和e数组中（节省时间）

3.将DOWN从前向后枚举，尽量放在前面

（思考：放在前面有利于为第4步提供更好的位置）

4.将UP从后向前枚举，尽量放在后面
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
using namespace std;
int m[105]={},d[105],e[105];
//这里m表示每个位置对应的歌曲编号
int n,len1=0,len2=0,x=1,y;
//len1,len2分别表示d,e的长度
char c[105][105],s[5];
int main()
{
	//freopen("beatme.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s%s",c[i],s);
		if(s[0]=='S') m[i]=i;
		if(s[0]=='D') d[++len1]=i;
		if(s[0]=='U') e[++len2]=i;
	}
	for(int i=1;i<=len1;i++)
		for(;x<d[i];x++)
			if(!m[x])
			{//将歌曲插入合适的位置
				m[x]=d[i];
				break;
			}
	x=n;
	for(int i=len2;i;i--)
		for(;x>e[i];x--)
			if(!m[x])
			{//同上
				m[x]=e[i];
				break;
			}
	for(int i=1;i<=n;i++)
		printf("%s\n",c[m[i]]);
	return 0;
}

```

---

## 作者：0104154308_f (赞：0)

 _~~一开始我是死都不理解为啥先up后down就可以的~~_ 
####  分析：
出现up的歌曲说明原先他在下面\
出现down的歌曲说明原先他在上面
易证明下加上加不变的一定等于总歌曲数\
且每一个up下方一定存在能够容纳从1到f（该单词所在位置）中所有up歌曲的位置
### 代码实现：
##### vector：
~~我这个垃圾使用了vector巨佬可以略过~~orz

vector是一把射速极高的冲锋枪~~大雾~~

vector是可变长数组

~~完了~~
### code：
```cpp
#include<iostream>
#include<vector>
#include<string>
using namespace std;
int n,l=1;
string t,x[110],ans[110]={},null;
vector<string>up,down;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i];
		cin>>t; 
		if(t=="UP")
		{
			up.push_back(x[i]);
		}
		if(t=="DOWN")
		{
			down.push_back(x[i]);
		}
		if(t=="SAME")
		{
			ans[i]=x[i];
		}
	}
	for(vector<string>::iterator it=down.begin();it!=down.end();it++)
	{
		while(1)
		{
			if(ans[l]==null)
			{
				ans[l]=*it;
				break;
			}
			l++;
		}
	}
	for(vector<string>::iterator it=up.begin();it!=up.end();it++)
	{
		while(1)
		{
			if(ans[l]==null)
			{
				ans[l]=*it;
				break;
			}
			l++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		cout<<ans[i]<<endl;
	}
	return 0;
}
```

---


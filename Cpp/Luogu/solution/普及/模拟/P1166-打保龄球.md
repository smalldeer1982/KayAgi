# 打保龄球

## 题目描述

打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：

1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。

2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。

3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   

总之，若―轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：

| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |
| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|
|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|

现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。


## 样例 #1

### 输入

```
/ / / 72 9/ 81 8/ / 9/ / 8/```

### 输出

```
30 27 19 9 18 9 20 20 20 20 
30 57 76 85 103 112 132 152 172 192```

# 题解

## 作者：X_WT (赞：24)

本蒟蒻觉得题解太少~~而且我看不懂~~	
因此决定发步第一篇题解		
希望有帮助	
介绍一下大致思路：先将每一次扔球得到分数计算在数组里，然后循环判断得出每一轮的分数	
```cpp
#include<bits/stdc++.h>
using namespace std;
int work(char t){
	if(t=='/')	return 10;
	return t-'0';
}				//将字符转化成分数 
int main(){
	string s;
	getline(cin,s);//输入字符串 
	int ans=0,gro[30]={-1,0,0},sco[30],i,j=1,k=1,a[15]={0},times=1;
	int len=s.length();//解释一下：gro[i]表示第i个数是gro[i]轮的 
	for(i=0;i<30;i++)	sco[i]=-1;//sco[i]表示第i次的分数 ，先全部赋-1 
	for(i=0;i<len;i++){
		if(s[i]==' '){
			continue;		//空格当然不能算在内 
		}
		gro[j]=k;//i，j相互独立，本句表示 gro[j] 属于第多少轮 
		sco[j]=work(s[i]);		//得到分数 
		if(sco[j]==10)	k++;//满分，直接下一轮 
		else if(gro[j]==gro[j-1])	k++;//扔满2次，下一轮 
		if(gro[j]==gro[j-1]&&sco[j]==10)
			sco[j]-=sco[j-1];//第二次为10分时，其成绩改成撞倒的瓶子数而不是10 
		j++;		//下一次扔球 
	}
	int tmp=j;			//扔球次数 
	for(i=1,j=1;i<=tmp;i++){
		if(sco[i]==10){
			if(sco[i+1]==-1||sco[i+2]==-1)	break;	//这句很重要，保证第一次一轮
			a[j++]=sco[i]+sco[i+1]+sco[i+2];		//成绩计算不出时可以结束
			times++;								//times意思是有分数的轮数 
			continue;
		}
		if(gro[i]==gro[i+1]){
			if(sco[i+1]==-1||sco[i+2]==-1)	break;	//同理上面 
			if( (sco[i]+sco[i+1]) ==10 ){
				if(sco[i+2]==-1)	break;
				a[j++]=sco[i]+sco[i+1]+sco[i+2];//表示这轮第一次开始向后，总共3次的成绩之和 
				times++;//为了这边计算方便，我在上面将10换掉 
				i++;continue;//加上循环的i+1,i向后2个
			}
			else{
				a[j++]=sco[i]+sco[i+1];
				times++;i++;//很可惜，没有击倒所有瓶子
			}
		}
	}
	times=min(times,11);//防止额外的轮数和不足10次的轮数 
	for(i=1;i<times;i++)	cout<<a[i]<<' ';
	cout<<endl;
	for(i=1;i<times;i++){
		ans+=a[i];	//得出每一次的总分 
		cout<<ans<<' ';
	}
	return 0;	//华丽结束 
}
```

---

## 作者：袁宇轩 (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P1166)

明显的**模拟**题，但不过坑点挺多的，而且光题意就理解的够呛。

# **那么我先来概括一下题意**：

首先你一共可以投一局，一局里可以分成十轮（但不过有时候会多出来一到两轮，这种情况等一下再讲），在一局中，一共有十个柱，会出现很多种情况。

**第一种**：如果你第一次就把十个给打倒了，那么这一局直接结束，而这一局的分数=10+后两次滚球的得分（若是第十轮则还需另加两次滚球）；

**第二种**：如果第一次没全部打倒，第二次把剩下的全部打倒，这一局也直接结束，那么这一局的得分=10+后一次滚球的得分（若是第十轮则还需另加一次滚球）；

**第三种**：如果前两次都没能全部打倒，那么这一局得分=这两次滚球的打倒数量。

**最后需要求出每一局的得分，和前i局的总得分**

#### 总结一下：就是每一局都要打完十个柱，如果两次都打不完那么这局结束，再根据规则得分。



------------
# **排坑**：

 讲完了题意感觉还挺简单，但稍不注意会掉到坑里，比方说题目中有这小小的一行字：
 
**“若某轮的得分暂时无法算出，则该轮得分不显示”**

那么得分无法算出是什么意思呢？

那自然就是这局还没滚完，但没有数据了，那么显然后面的几局也是没滚完的，所以直接**break**。



------------


# **我的思路**
~~（写出来居然要比楼上的大佬短）~~：

1.（读入啊什么的就不说了，自己注意一下空格就好）；

2.我先用**rest**记录剩余柱的数量，再用**flag**记录是否全部打完，flag=1表示未全部打倒，反之则全部打倒，然后我们在记录一个变量**st**表示这一局的起点；

3.从st~st+2模拟，该-的-，该+的+，同时判断枚举时是否越界，如果越界了那么直接**break**，如果当**rest**=0时，说明全部打倒，那么**flag**=0，如果枚举到了第三次滚球，而且没有全部打倒即**flag**=0，那么这次滚球就不做，做完一局后，改变**st**的位置，如果第一次就全部打完那么**st+1**,否则**st+2**。

这样就能避免掉坑了。

# **最后附上香喷喷的代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mid (l+r)/2
#define ll long long
#define For(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)
inline ll read(){
	ll x=0;char ch=getchar();bool f=0;
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return f?-x:x;
}
void write(ll x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);putchar(x%10+'0');
}
void writeln(ll x){write(x);puts("");}
void writep(ll x){write(x);putchar(' ');}

int n,cnt,ans,sum[13];
char a[103];

int main()
{
	while (cin>>a[++n]);//读入 
	int st=1;//每一局的起点 
	for (int i=1;i<=10;i++){
		int rest=10,flag=1;//剩余rest根柱，且没有全部打完 
		for (int j=st;j<=st+2;j++){//枚举三次滚球 
			if (j>n){//如果越界退出 
				sum[i]=-1;
				break;
			}
			if (rest==0) rest=10,flag=0;//全部打完 
			if (j==st+2 && flag) break;//第三种情况，只滚两次 
			if (a[j]=='/') sum[i]+=rest,rest=0;//模拟 
			else if (a[j]>='0' && a[j]<='9') sum[i]+=a[j]-'0',rest-=a[j]-'0';//模拟 
		}
		if (sum[i]==-1) break;//越界 
		if (a[st]=='/') st++;
		else st+=2;//改变st位置 
		writep(sum[i]);
	}
	puts("");
	for (int i=1;i<=10;i++){
		if (sum[i]==-1) break;
		ans+=sum[i];
		writep(ans);
	}
    return 0;
}
```

码字不易，希望对您有用


---

## 作者：2344b (赞：11)

### 首先说明
我是开始是**真!的!没!有!看!懂!题!意!**

直到围观了Kyle_Lowry大佬的代码。

对于语文不好的人真的很难受。

对于每次一下子击倒10个保龄球的一轮，当轮分数要加上之后两次 **投 掷** 或得的分数。
两次投掷击倒10个的同理。

然后，他最多只会输出到第十轮的分数!(所谓11轮12轮并不需要输出);也会有达不到十轮的情况(原来这才是暂时无法算出)。。

### 然后就是我的代码了
用map[i]存储第i轮击倒的球的个数。

用score[i]存储第i轮能得到的分数。

每次枚举到一次投掷的情况，对map和score进行处理。
~~看懂了还是很简单的~~。

此题解主要为还读不懂的人参考。。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int Map[15],top,x,score[15],Time[15];
char p,s[200];
int main(){
	gets(s);
	for(int i=0;i<strlen(s);i++){
		p=s[i];
		if(p=='\n')break;
		if(p==' '){
			top++;
			continue;
		}
		if(p=='/'){
			if(Time[top-1]-->0)score[top-1]+=10-Map[top];
			if(Time[top-2]-->0)score[top-2]+=10-Map[top];
			Map[top]=10;
			score[top]=Map[top];
			Time[top]+=2;
		}
		if(p>='0'&&p<='9'){
			if(Time[top-1]-->0)score[top-1]+=p-'0';
			if(Time[top-2]-->0)score[top-2]+=p-'0';
			Map[top]+=p-'0';
			score[top]=Map[top];
			Time[top]--;
		}
	}
	for(int i=0;i<min(top,10);i++){
		if(Time[i]>0){
			printf(" ");
			continue;
		}
		printf("%d ",score[i]);
	}
	printf("\n");
	int ans=0;
	for(int i=0;i<min(top,10);i++){
		if(Time[i]>0){
			printf(" ");
			continue;
		}
		ans+=score[i];
		printf("%d ",ans);
	}
}
```

---

## 作者：wuyixiang (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P1166)

题目大意：~~太长了，自己理解吧~~

思路分析：一道模拟题。

注意有些神犇数据没有投完就直接离开，所以这时候需要加一个特判，如果在需要投球的地方没投，就说明结果（以及之后）都算不出来了，直接 `break` 即可。除了这些细节问题，其它的直接照题目模拟就行了。可以参照注释。

## AC Code:

```cpp
#include <iostream>
using namespace std;
char c[114][3];
int lun = 10,ju = 10,sum[15],r;
int main()
{
    for(int i = 1;i <= lun;i ++)
    {
        cin >> c[i][1];
        if(r == 1 && c[i][1] == '/')lun ++;//如果r = 1,说明还可以投一轮球，轮数++
        if(i == 10 && c[i][1] == '/')lun ++,r = 1;
        if(c[i][1] != '/')//如果第一发没全中，这一轮还可以投一次
        {
            cin >> c[i][2];
            if(i == 10 && c[i][2] == '/')lun ++;
        }
    }
    for(int i = 1;i <= 10;i ++)//最多只要计算十局
    {
        int num = 0;
        if(c[i][1] == '/')
        {
            if(c[i + 1][1] == '/')
            {
                if(c[i + 2][1] == '/')num = 30;//3发中计30分
                else if(c[i + 2][1] >= '0')num = 20 + c[i + 2][1] - '0';//2发+数字
                else {ju = i - 1;break;}//这些没有投的地方，结果计算不出来，直接break
            }
            else if(c[i + 1][2] == '/')num = 20;//补中20分
            else if(c[i + 1][1] >= '0' && c[i + 1][2] >= 48)num = 10 + c[i + 1][1] - '0' + c[i + 1][2] - '0';//两发数字，为10+它们的和
            else {ju = i - 1;break;}
        }
        else if(c[i][2] == '/')
        {
            if(c[i + 1][1] == '/')num = 20;//补中10+全中10=20分
            else if(c[i + 1][1] >= '0')num = 10 + c[i + 1][1] - '0';//10+数字
            else {ju = i - 1;break;}
        }
        else //两发数字，直接计算它们的和，注意没投满的情况
        {
            if(c[i][2] >= '0')num = c[i][1] - '0' + c[i][2] - '0';
            else {ju = i - 1;break;}
        }
        sum[i] = sum[i - 1] + num;//sum实时数组
        cout << num << " ";//如果能计算出来可以输出
    }
    cout << '\n';
    for(int i = 1;i <= ju;i ++)cout << sum[i] << " ";
}
```

---

## 作者：the___ (赞：4)

# 读题
1. 规则中：击倒后加的是之后两（一）**次**（不是两（一）轮）之和。
2. 题目描述最后：若某轮的得分暂时无法算出，则该轮得分不显示。
3. 输入格式中：前若干轮滚球（并非全部十轮），每轮也未必给全（未全部击倒但只有一次滚球）。

# 思路
直接模拟，注意上述细节。

1. 按轮输入为字符串数组 $a$。
2. 将'/'转为数字（字符型）并按次存入字符数组 $b$，帮助计算。
3. 逐位判断属于那一种情况并计算，$a$ 用于判断当前轮，$b$ 用于加后两轮，同时求前缀和以输出总得分，若以计算到第十轮或无之后两（一）轮则保存有几轮可算至 $p$ 并跳出循环。
4. 若 $p$ 有值则输出 $p$ 次，否则输出 $10$ 次。

# 代码

```
#include<iostream>
#include<string>
using namespace std;
int n,db[20],dz[20],k,ki=1,p=-1;
string a[20];
char b[30];
int main(){
    while(cin>>a[++n]){}                                    \\输入
    for(int i=1;i<=n;i++){                          \\将'/'转为数字
        for(int j=0;j<a[i].length();j++){
            if(a[i][j]=='/'){
                if(a[i].length()==1)
                    a[i][j]=10+'0';
                else
                    a[i][j]=10+'0'-(a[i][!j]-'0');
            }
            b[++k]=a[i][j];
        }
    }
    for(int i=1;i<=n;i++){                              \\判断计算
        if(a[i].length()==1 && a[i]!=":"){         \\特判不全的轮次
            p=i-1;
            break;
        }
        if(a[i]==":"){                               \\一次全部击倒
            if(ki+2>k){
                p=i-1;
                break;
            }
            db[i]=10+b[ki+1]-'0'+b[ki+2]-'0';
            ki++;
        }
        else{
            if(a[i][0]-'0'+a[i][1]-'0'==10){         \\两次全部击倒
                if(ki+2>k){
                    p=i-1;
                    break;
                }
                db[i]=10+b[ki+2]-'0';
                ki+=2;
            }
            else{                                      \\未全部击倒
                db[i]=a[i][0]-'0'+a[i][1]-'0';
                ki+=2;
            }
        }
        dz[i]=dz[i-1]+db[i];                              \\求总分
    }
    if(p!=-1){                                         \\非全部十轮
        for(int i=1;i<=p;i++)
            cout<<db[i]<<" ";
        cout<<endl;
        for(int i=1;i<=p;i++)
            cout<<dz[i]<<" ";
    }
    else{                                               \\全部十轮
        for(int i=1;i<=n;i++)
            cout<<db[i]<<" ";
        cout<<endl;
        for(int i=1;i<=n;i++)
            cout<<dz[i]<<" ";
    }
    return 0;
}
```
本人的第一篇题解，如有不详、不严谨之处，恳请大佬指点。

---

## 作者：Ousmane_Dembele (赞：4)

这题嘛，很好玩，纯模拟，我也不保证全对，和  _深海鱼的眼泪_ 大佬的题解输出有很多不同的地方，也不知道谁对了……



------------

# _**正题**_ 

------------


定义一个m数组，代表是一边过还是两遍过还是两遍都没过，a数组代表每一轮得分，ans数组计算前缀和，b数组代表每一投得分，p数组代表有没有投当前球，然后硬判断
```
#include<bits/stdc++.h>
using namespace std;
string wxy;
int t=1,cnt=1;
int m[50];
int a[50],ans[50];
int b[50][4];
bool p[50][4];
int main(){
    getline(cin, wxy);
    memset(b,0,sizeof(b));
    memset(ans,0,sizeof(ans));
    memset(m,0,sizeof(m));
    memset(a,0,sizeof(a));
    int len=wxy.length();
    for(int i=0;i<len;i++){
        if(wxy[i]==' '){t=1;continue;}
        if(wxy[i]=='/'){//投满十个
            a[cnt]=10;
            if(t==2)//第二次
            b[cnt][t]=10-b[cnt][1];
            else b[cnt][t]=10;
            p[cnt][t]=true;
            // if(m[cnt-1]==1)a[cnt-1]+=a[cnt];
            // if(m[cnt-2]==1)a[+=a[cnt];
            // if(m[cnt-1]==2)a[cnt-1]+=a[cnt];
            if(t==1){
                m[cnt]=1;//更新m的值
            }else if(t==2){
                m[cnt]=2;
            }
            t=1;
            cnt++;
            continue;
        }
        if(wxy[i]>='0'&&wxy[i]<='9'){
        b[cnt][t]=wxy[i]-'0';
        p[cnt][t]=true;
        }
        t++;
        if(t==3){//两轮都没投满
            t=1;
            int e=wxy[i]-'0';
            int f=wxy[i-1]-'0';
            // if(m[cnt-1]==1)a[cnt-1]+=e+f;
            // if(m[cnt-2]==1)a[cnt-2]+=e;
            // if(m[cnt-1]==2)a[cnt-1]+=e;
            a[cnt]=e+f;
            cnt++;
        }
    }
    cnt--;//多加了一次
    for(int i=1;i<=min(cnt,10);i++){
        if(m[i]==2)a[i]+=b[i+1][1];//这肯定是这样的
        if(m[i]==1){
            a[i]+=b[i+1][1];
            if(p[i+1][2])a[i]+=b[i+1][2];//下一轮投了两次
            else if(p[i+2][1])a[i]+=b[i+2][1];//下一轮投了一次
        }
    }
    int y=0;//没用
    // for(int i=1;i<=mcnt,10);i++)
    //   if(a[i]==0)y++;
    // cout<<y<<" "<<cnt<<" ";
    for(int i=1;i<=min(cnt,10);i++){
       
      // if(a[i]==0)break;
       ans[i]=ans[i-1]+a[i];//前缀和
       if(m[i]==2&&!p[i+1][1])continue;//无法计算
       if(m[i]==1&&(!p[i+1][1]||(!p[i+1][2]&&!p[i+2][1])))continue;//无法计算
       cout<<a[i]<<" ";
    }
    cout<<endl;
    for(int i=1;i<=min(cnt,10);i++){
        if(m[i]==2&&!p[i+1][1])continue;//同上
       if(m[i]==1&&(!p[i+1][1]||(!p[i+1][2]&&!p[i+2][1])))continue;
        //if (a[i] == 0)break;
       cout<<ans[i]<<" ";
    }
    return 0;
}
```

---

## 作者：Shadow_T (赞：3)

### 前言
此题并不难，但是题意难理解，理解就好做了
### 题目大意
$\bullet$ 如果第 $10$ 次击倒 $10$ 个,那么分数 $score$ 加上后面两次的分数。

$\bullet$ 若每轮第 $1$ 次没滚倒 $10$ 个，则继续滚。若这两次击倒了 $10$ 个，不再滚球（第 $10$ 轮再加 $1$ 次），且 $score$ 加 $10$；若还是没有全击倒，则 $score$ 加上此轮滚倒总数。
### 题目分析
按照题意**模拟**即可，但是注意：

**若某轮的得分暂时无法算出，则该轮得分不显示**

就是如果一轮没滚完，那么直接跳出。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int d[21];
int p1166[21][3];
bool st[21][3];
int zdf,l=1,lenz=1;
int main()
{    
    getline(cin,s);
    memset(d,0,sizeof d);
    memset(st,0,sizeof st);
    memset(p1166,0,sizeof(p1166));
    int x=s.length();
    for(int i=0;i<x;i++)
	{         
        if(s[i]==' ') continue;
        if(s[i]=='/')
		{
            p1166[lenz][l]=10-p1166[lenz][l-1];
            st[lenz][l]=true;
            if(l==1)
			{ 
				lenz++;
				continue;
			}
        }
        else
		{
            p1166[lenz][l]=s[i]-'0';
            st[lenz][l]=true;
        }
        if(l==2) ++lenz,l=1;
        else ++l;
    }
    lenz--;
    for(int i=1;i<=lenz;i++)
	{
        if(p1166[i][1]==10)
		{
            if(!st[i+1][1]) break;
            if(p1166[i+1][1]==10&&(!st[i+2][1])) break;
            if(p1166[i+1][1]<10&&(!st[i+1][2])) break;
            d[i]=10+p1166[i+1][1];
            if(p1166[i+1][1]==10) d[i]+=p1166[i+2][1];
            else d[i]+=p1166[i+1][2];
        }
        else
		{
            if(!st[i][2]) break;
            if(p1166[i][1]+p1166[i][2]==10&&(!st[i+1][1])) break;
            d[i]=p1166[i][1]+p1166[i][2];
            if(d[i]==10) d[i]+=p1166[i+1][1];
        }
    }
    for(int i=1;i<=lenz;i++)
	{
        if(d[i]==0) break;
        cout<<d[i]<<' ';
    }
    puts("");
	int ans=0;
    for(int i=1;i<=lenz;i++)
	{
        if(d[i]==0) break;
        ans+=d[i];
        cout<<ans<<' ';
    }
}
```

---

## 作者：Marshall001 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P1166)

## 题目大意

这道题题目比较难理解，大致意思如下：

如果这一轮第一次滚球就全部击倒了，那么本轮得分为 $10$ 加上后两次滚球的得分（注意！不是后两轮的得分！）为什么呢?当然是保龄球的规定啦！

如果这一轮滚球两次才全部击倒，那么本轮的得分为 $10$ 加上后一次滚球的得分。

如果两次滚球都没有全部击倒，那么本轮得分就为两次滚球得分的总和。

可是第 $10$ 轮和第 $9$ 轮没有后两 $($ 一 $)$ 轮怎么办？我们的第 $11$ 轮和第 $12$ 轮就要出场了！

## 思路

题目了解清楚了，应该就有思路了吧？

没错，就是纯模拟！

枚举每一次的进球情况，然后再根据情况计算出每轮的得分，最后输出第 $i$ 场的得分情况和前 $i$ 场总共的得分就可以了。

## 注意

这道题我卡了很久，最后发现有一句这样的话：

若某轮的得分暂时无法算出，则该轮得分不显示。

什么叫做得分暂时无法算出呢？就是比如说我第 $10$ 轮第一次就进了，我需要知道第 $11$ 轮和第 $12$ 轮的滚球情况，才可以算出我第 $10$ 轮的得分，可是样例中没有给出第 $11$ 轮和第 $12$ 轮的滚球情况。这就叫做暂时无法算出。

那怎么解决呢？只需判断本轮，下一轮，下下一轮的输入是否合法，如果不合法，就可以直接跳出了。

## 代码

说了这么多了，上代码！

```cpp
#include <iostream>
using namespace std;
string a[20];
long long ans[20];//记录前缀和 
long long answer(string x){//判断本场得分 
	if(x==""){
		return -1e9;//如果不符合，就让得分变成负数
	}
	if(x=="/"){//如果第一次就全部击倒 
		return 10;//那么本场得分为 10 分 
	}
	else if(x.size()==1){//如果本场击球次数为一次且没有全部击倒 
		return int(x[0]-'0');//那么本场得分为本场击倒保龄球的个数 
	}
	else if(x[1]=='/'){//如果第二次全部击倒 
		return 10;//那么本场得分还是 10 分 
	}
	else{//否则两次都没有全部击倒 
		return int(x[0]-'0')+int(x[1]-'0');//本场得分为两次总共得分 
	}
}
int main(){
	int cur=1;//表示现在在输入地几轮得分情况 
	while(cin>>a[cur]){//循环输入 
		cur++;
	}
	cur--;
	for(int i=1;i<=10;i++){
		if(a[i].size()==1&&a[i][0]!='/'){
			break;
		}
		long long sum=0;//记录本轮得分 
		if(a[i]=="/"){//如果本轮全部击倒 
			sum+=10;//那么本场得分为 10 + 
			sum+=answer(a[i+1]);//下一轮得分 
			if(a[i+1].size()==1){//如果下一轮只滚了一次球 
				string s1="";
				s1+=a[i+2][0]; 
				sum+=answer(s1);//那么本轮得分再加上下一次滚球的得分 
			}
		}
		else if(a[i][1]=='/'){//如果本轮第二次全部击倒 
			sum+=10;//那么本轮得分为 10 + 
			string s2="";
			s2+=a[i+1][0];
			sum+=answer(s2);//下一次滚球的得分 
		}
		else{
			sum+=answer(a[i]);//否则本轮得分为两次滚球的和 
		}
		if(sum<=0){
			break;
		}
		cout<<sum<<" ";//输出本轮得分 
		ans[i]=ans[i-1]+sum;//记录前缀和 
	}
	cout<<endl;//记得输出换行！ 
	for(int i=1;i<=10;i++){
		if(ans[i]<=0){
			continue;
		}
		cout<<ans[i]<<" ";//输出前缀和 
	}
	return 0;//THE END 
}
```


---

## 作者：天南星魔芋 (赞：3)

今天无意看到，于是被虐 $(keng)$ 了一中午。


------------
我们先看题，题上让我们模拟打保龄球计分。


* 若一次击倒完，则下两次发球得分翻倍。
* 若两次击倒完，则下一次发球得分翻倍。
* 若是第十次发球并且符合第一条，再发两次。

注:下面这部分介绍本题题面的坑，若不需要可跳过。

但“若某轮的得分暂时无法算出，则该轮得分不显示。”是什么意思呢？

我们想：如果第九轮一次过会如何。

* 若第十轮一次过，则会加两轮。
* 要不第九轮后还有两次发球。

所以第九轮不可能无法算出。

~~那就无法输出时跳出好啦~~ 本题题面有问题，有些答案不同也能过(不止限于此片)。

.

然后详见代码吧！

```cpp
#include<bits/stdc++.h>//万能头很香 
using namespace std;
int a[1500][5];//存储数组  存储每轮状态  a[][0]存得分  a[][1]存情况  a[][2]存第几次发球 
int q[5000],top=0;//存发球  top  为指针 
int zan[100],ztop=0;//存答案 
char b[300];//存输入 
int bb,bbb;//指针 bb循环  bbb计算 b数组长度 
int n;
int main(){
//------------------------------// 初始化 
	n=1;bb=0;                  // 
	memset(a,-1,sizeof(a));   // 
	memset(q,-1,sizeof(q));  // 
	memset(b,0,sizeof(b));  //
//-------------------------// 
	gets(b);
	bbb=strlen(b);

//-----------------------------------------------------------------------// 
	while(b[bb]!='\n'&&n<=12&&bb<bbb){//-----//多判防卡死               //
		if(b[bb]=='\n'||b[bb]=='\r')break;  //                         // 
		else if(b[bb]==' '){bb++;continue;}//空格不算                 // 
		else if(b[bb]=='/'&&a[n][0]==-1){ //第一次就全中             //%%%%%%  Orz 
				a[n][0]=10;              //本次的10                 // 
				a[n][1]=0;              //零类                     // 
				top++;                                            // 
				q[top]=10;                                       // 
				a[n][2]=top;         //在a[n][2]次结束          // 
				n++;                                           // 
				}                                             // 
		else {                                               // 
			if(b[bb]=='/'){       //第二次就全中            // 还是大佬 
				a[n][0]=10;      //本次的10                // 
				a[n][1]=1;                                // 
				top++;                                   // 
				q[top]=10-q[top-1];                     // 
				a[n][2]=top;                           // 
				n++;                                  // 
				}                                    // 
			  else if(b[bb]>='0'&&b[bb]<='9'){      // 
				  if(a[n][0]>=0){//第二次还没中完  //  QWQ 
				  a[n][0]+=b[bb]-'0';             // 
				  a[n][1]=2;                     // 
				  top++;                        // 
				  a[n][2]=top;                 // 
				  q[top]=b[bb]-'0';           // 
				  n++;                       // 
				 }                          // 
			     else {                    // 
			     a[n][0]=b[bb]-'0';//新轮 // 
		 	     a[n][1]=2;              // 
			     top++;                 // 
			     q[top]=b[bb]-'0';     // 
			   }                      //  
			}                        // 
		}bb++;                      // 
	}                              // 
//--------------------------------// 
	int sum=0;
	for(int i=1;i<=10&&i<n;i++){//输出 
		if(a[i][1]==0){
			if(q[a[i][2]+1]==-1||q[a[i][2]+2]==-1){n=i;break;}//若无法判断得分时跳出 ，n=i 的作用？ 
			a[i][0]+=q[a[i][2]+1]+q[a[i][2]+2];                              // 
		}                                                                   // 
		else if(a[i][1]==1){                                               // 
			if(q[a[i][2]+1]==-1){                                         // 
				n=i;break;                                               // 
			}                                                           // 
		a[i][0]+=q[a[i][2]+1];                                         // 
		}                                                             // 
		cout<<a[i][0]<<" ";                                          // 
		sum+=a[i][0];                                               // 
		zan[i]=sum;                                                // 
	}cout<<endl;                                                  // 
	for(int i=1;i<=10&&i<n;i++){// n=i 保证了上下输出一致--------// 
		cout<<zan[i]<<" ";
	}cout<<endl;
}
```

这篇题解就到这里了，

我还没写过几次，有不到之处请多多指教。



---

## 作者：深海鱼的眼泪 (赞：3)

题目应该算是纯模拟，只是非常麻烦，考虑的情况很多，某些细节要注意，比如击倒柱数可能为0，可能没有滚完等


```cpp
#include <iostream>           
#include <string>
#include <cstring>
using namespace std;
int main() {
    int i, df[13][3], zdf = 0, l = 1, zl = 1, d[13];
    bool y[13][3];
    string s;
    getline(cin, s);
    memset(df, 0, sizeof(df));
    memset(d, 0, sizeof(d));
    memset(y,false,sizeof(y));
    int x = s.length();
    for (i = 0; i < x; i++) {           
```
/\*
读入，df[i][1]表示第i轮的第一次滚球，

y[i][1]表示第i轮是否有第一次滚球

因为一次滚球击倒柱数可能为0！！！就是这个害我多次过不了

\*/
```cpp
        if (s[i] == ' ')continue;
        if (s[i] == '/') {
            df[zl][l] = 10 - df[zl][l - 1];
            y[zl][l]=true;
            if (l == 1) {
                zl++;
                continue;
            }
        } else {
            df[zl][l] = s[i] - 48;
            y[zl][l]=true;
        }
        if (l == 2) {
            ++zl;
            l = 1;
        } else ++l;
    }
    zl--;
    for (i = 1; i <= zl; i++) {                //模拟，略麻烦 
        if (df[i][1] == 10) {
            if (!y[i + 1][1])break;
            if (df[i + 1][1] == 10 &&(!y[i + 2][1]))break;
            if (df[i + 1][1] < 10 && (!y[i + 1][2]))break;
            d[i] = 10 + df[i + 1][1];
            if (df[i + 1][1] == 10) {
                d[i] += df[i + 2][1];
            } else d[i] += df[i + 1][2];
        } else {
            if (!y[i][2])break;
            if (df[i][1] + df[i][2] == 10 &&(!y[i + 1][1]))break;
            d[i] = df[i][1] + df[i][2];
            if (d[i] == 10) {
                d[i] += df[i + 1][1];
            }
        }
    }
    for (i = 1; i <= zl; i++) {
        if (d[i] == 0)break;
        cout << d[i] << ' ';
    }
    cout << endl;
    int ans = 0;
    for (i = 1; i <= zl; i++) {
        if (d[i] == 0)break;
        ans += d[i];
        cout << ans << ' ';
    }
    return 0;
}
```

---

## 作者：_QWQ__QWQ_ (赞：2)

## 思路

花了半天去理解题意……意思是说给你一个选手的滚球情况，打出他当前的成绩。简单的说这题就是一个模拟（我才不是因为懒才找模拟题写的）思路也很简单，对每一轮进行以下几个判断就行啦：

1. 首先判断有没有在两次滚球之内把 $ 10 $ 个柱子滚完（判断有没有`/`）。
2. 如果滚完了（有`/`），在下一轮或下下轮找可以加的得分（如果 $ 3 $ 次滚球机会没用完，就不能输出得分）。
3. 如果没有滚完（没有`/`），判断当前轮有没有滚两次球（字符串长度是否为 $ 2 $），没有的话同样不能输出成绩。

思路还是很清晰的，下面放上代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int ans[15];//记录本轮得分的数组
int ans1[15];//前缀和数组
int flag[15];//标识能否输出答案
string s[15];
int serch(int i){
	for(int j=0;j<s[i].size();j++)
	{
		if(s[i][j]=='/')
		return j+1;
	}
	return 0;
}//判断是否存在'/'
int getnum(int i,int len){
	int ans=0;
	int k=s[i].size();
	for(int j=0;j<min(k,len);j++){//防越界
		if(s[i][j]=='/')
		ans=10;
		else
		ans+=(s[i][j]-'0');
	}
	return ans;
}
int main(){
	int len=0;
	while(cin>>s[len++]);
	for(int i=0;i<10;i++){
		int k=3;
		if(s[i]=="")
		break;
		if(serch(i)){
			ans[i]+=10;
			k-=s[i].size();
			if(k>0){
				ans[i]+=getnum(i+1,k);
				k-=s[i+1].size();
			}//加上下次可以得到的分
			if(k>0){
				ans[i]+=getnum(i+2,k);
				k-=s[i+2].size();
			}//加上下下次可以得到的分
			if(k<=0)flag[i]=1;//可以输出的分
		}
		else{
			ans[i]=getnum(i,s[i].size());
			if(s[i].size()==2)
			flag[i]=1;
		}	
	}
	for(int i=0;i<10;i++){
		if(flag[i])
		cout<<ans[i]<<" ";
	} 
	cout<<endl;
	ans1[0]=ans[0];
	for(int i=1;i<10;i++)ans1[i]=ans1[i-1]+ans[i];
	for(int i=0;i<10;i++){
		if(flag[i])
		cout<<ans1[i]<<" ";
	}
	return 0;//完结撒花！！！ 
}
```

---


# [蓝桥杯 2025 省 B] 水质检测

## 题目描述

小明需要在一条 $2 \times n$ 的河床上铺设水质检测器。在他铺设之前，河床上已经存在一些检测器。如果两个检测器上下或者左右相邻，那么这两个检测器就是互相连通的。连通具有传递性，即如果 $A$ 和 $B$ 连通，$B$ 和 $C$ 连通，那么 $A$ 和 $C$ 也连通。现在他需要在河床上增加铺设一些检测器使得所有的检测器都互相连通。他想知道最少需要增加铺设多少个检测器？

## 说明/提示

### 样例说明

其中一种方案：

```
.###....#
.#.######
```

增加了 5 个检测器。

### 评测用例规模与约定

对于 $100\%$ 的评测用例，保证 $n \leq 1000000$。

## 样例 #1

### 输入

```
.##.....#
.#.#.#...```

### 输出

```
5```

# 题解

## 作者：liwenjiedeluogu (赞：51)

菜鸟第一次写题解，多多包涵！！!

这个题目的数据量很小，所以没必要去使用bfs，直接分情况讨论即可

一共两排数据，我们使用贪心的思想，只需要实现从左往右的过程中每个检测器相互连接即可，那么我们分三种情况讨论


---


**第一种情况**
|#|.|
|:-:|:-:|
|.||

当第一排的当前有检测器，而第一排的下一个没有检测器，且第二排的当前位没有检测器，我们不管第二排的下一个位置有没有检测器，我们只需要把第一排的下一个添加检测器便能够实现四个格子检测器的连通


---


**第二种情况**


|.||
|:-:|:-:|
|#|.|

与第一种情况类似，只是位置变了一下


---


**第三种情况**



|#|.|
|:-:|:-:|
|#|.|

这种情况相对复杂，我们不知道后面的情况，我们就只能从当前位置开始从第一排和第二排分别寻找再次出现 _#_ 的位置 ，哪排先出现哪排的后面一个就变成 _#_ 

我们只需要判断这三种情况，没出现一次计数器加一，最后输出结果即可

这里面可以提前来找到最先出现 _#_ 的位置 和最后出现 _#_ 的位置，这样我们的循环会得到优化

希望能给你一点点小帮助


---


```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string s1, s2;
    cin >> s1 >> s2;
    int len = s1.size();
    int num = 0; // 计数器
    int l = len, r = 0;
    // 寻找第一出现和最后一个出现#的位置并记录
    for (int i = 0; i < len; i++)
    {
        if (s1[i] == '#' || s2[i] == '#')
        {
            l = min(l, i);
            r = max(r, i);
        }
    }
    for (int i = l; i < r; i++)
    {
        // 第一种情况的判断
        if (s1[i] == '#' && s1[i + 1] == '.' && s2[i] == '.')
        {
            num++;
            s1[i + 1] = '#';
            // cout << s1 << endl
            //      << s2 << endl
            //      << endl;
        }
        // 第二种情况的判断
        if (s1[i] == '.' && s2[i + 1] == '.' && s2[i] == '#')
        {
            num++;
            s2[i + 1] = '#';
            // cout << s1 << endl
            //      << s2 << endl
            //      << endl;
        }
        // 第三种情况的判断
        if (s1[i] == '#' && s2[i] == '#' && s2[i + 1] == '.' && s1[i + 1] == '.')
        {
            int p = i, q = i;
            for (int j = i + 1; j <= r; j++)
            {
                if (s1[j] == '#')
                {
                    p = j;
                    break;
                }
                if (s2[j] == '#')
                {
                    q = j;
                    break;
                }
            }
            if (p >= q)
            {
                s1[i + 1] = '#';
                num++;
            }
            else
            {
                s2[i + 1] = '#';
                num++;
            }
            // cout << s1 << endl
            //      << s2 << endl
            //      << endl;
        }
    }
    cout << num;
    return 0;
}
```

---

## 作者：vegetableYe (赞：38)

由于本题没有写部分分 $n$ 的范围，这里就不给出暴力的做法代码了，大概说一下就是二进制枚举每个位置填/不填 '$\#$'，复杂度是 $O(2\times n \times 2^{2\times n})$。

正解：

个人感觉这道题是这一套题中质量最高的一道，存在多种解法，这里给出一个看似是贪心，实则是 dp 的做法。

由于我们要填 '$.$'，因此我们可以考虑对最靠近的相邻两列（两列都含有至少一个 '$\#$'）的列做决策。

这里方便我们讨论，不妨定义一些状态：

1. 第一行是 '$\#$' 第二行是 '$.$' ；
2. 第一行是 '$.$' 第二行是 '$\#$' ；
3. 两行都是 '$\#$' ；

（为什么没有 $4.$ 因为上文提到了，我们只考虑相邻都含有至少一个 '$\#$' 的情况。）

我们按列枚举过去，如果当前两行都是 '$.$' 我们直接 continue。

否则我们看上一列的状态是什么，依据此来分类讨论。

首先我们发现，如果上一列和当前列的状态相同，即都是 $1$，或都是 $2$，或都是 $3$，则我们只需要给对应那一行填满，从上一列的下一个位置填到当前列的上一个位置即可，因此花费：$i-lst-1$。（其中 $lst$ 是上一列的位置）

接着我们发现，实际上只要两列中存在任何一列的状态是 $3$，我们的花费都可以取上值，因为此时存在至少一列是可以任选第一行或者第二行去填的，我们只需要去满足另一列的要求即可。

因此只有：“一列是 $1$，另一列是 $2$”的情况，我们不止要花费上述的 $i-lst-1$，还需要再补一个位置，也就是花费还要再加一变成 $i-lst$。

例如：

```
..#...     ..###.          ..####             ..###.
.....#     .....#          .....#             ....##
初始        花费i-lst-1     花费i-lst的填法一    花费i-lst的填法二
```

对于上述的 “初始”，我们如果花费 $i-lst-1$，则只能填成 "左二" 的情况，显然并不合法。

因此我们需要再额外花费一个，填成 “左三” 或 “左四”。

那我们的花费就定下来了是 $i-lst$，但我们到底是填成：“左三” 好，还是 “左四” 好。

显然，我们填成 “左三” 更好，因为这样一来，我们第 $i$ 列的状态就变成了 $3.$ 两行都是 '$\#$'。这样才能让 $i$ 后面的列可选列更多。



代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 lll;
typedef pair<ll, ll> P;
#define x first
#define y second
#define int long long
using i64 = long long;

const int mod = 1e9 + 7;
const int MOD = 998244353;

void solve() {
    string a, b;
    cin >> a >> b;

    int ans = 0;
    int lst = -1, state = -1;
    // lst 就是文中的 lst
    // state 则代表 lst 对应的情况，对应文中的 1 2 3 三种
    for(int i = 0; i < a.size(); i++) {
        if(a[i] == '.' && b[i] == '.') continue;
        if(lst != -1) {
            ans += i - lst - 1;
        }
        if(a[i] == '#' && b[i] == '#') {
            state = 3;
        } else if(a[i] == '#' && b[i] == '.') {
            if(state == 2) {
                ans++;
                state = 3;
            } else {
                state = 1;
            }
        } else if(a[i] == '.' && b[i] == '#') {
            if(state == 1) {
                ans++;
                state = 3;
            } else {
                state = 2;
            }
        }
        lst = i;
    }
    cout << ans << endl;
}

/*



*/

signed main () {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int _ = 1;
    // cin >> _;
    while(_ -- ) {
        solve();
    }
    return 0;
}
```

时间复杂度：$O(n)$。

---

## 作者：zhengly (赞：19)

# 题解 P12135 [蓝桥杯 2025 省 B] 水质检测

我不会贪心证明，但是我们可以用动态规划的思想来写这道题，为什么可以呢？因为每一个点只会由前一个位置的情况来决定当前自己的情况。我们设 $dp_{i,j}$ 表示为第 $i$ 位置，第 $j$ 个位置确定填充 `#` 并且保证和前面联通的最小花费，$j$ 取 $0$ 或 $1$，分别表示 $i$ 位置的上层还是下层。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/f5y6ie5e.png)

---

由上面的图，我们可以看到，当前如果为 `#`，要么由前面那个直接转移(**路径①**)，要么就由前面另一个方向转移(**路径②**)。我们设蓝色所在位置为 $(i,0)$ 。

1. 那么**路径①**就是由前面 $(i-1,1)$ 转移到 $(i,0)$。
2. 那么**路径②**就是由前面 $(i-1,1)$ 先转移到  $(i,1)$ 再转移到 $(i,0)$ 。


我们可以根据上面所设计的 $dp$ 状态可以知道，**路径①**只会只由前面 $(i-1,0)$ 确定，而当前这个点已经保证了为 `#` 且与前面联通，并且花费最小，那么我们只需要考虑 $(i,0)$ 这一位是否为 `#` 即可，如果不为 `#` 则需要贡献加 $1$，否则直接转移。

而对于**路径②**，我们当然不可以直接由 $(i,1)$ 转移，我们就需要考虑 $(i-1,1)$，因为这个点的 $dp$ 值保证了它此时为 `#` 且与前面联通，并且花费最小，那么，如果要通过**路径②**转移的话，我们就要考虑到  $(i,1)$ 是否为 `#`，并且还需要考虑到 $(i,0)$ 这一个是否为 `#`，即可计算出对应的 $dp$ 值。

对于下层的话，类比上层的做法一样可以求解，可以自己模拟试一下。

---

所以，我们可以得到最终的转移方程如下：

$$
dp_{i,0} = \min(dp_{i-1,0}, dp_{i-1,1} + (s_{i,1} \neq \#)) + (s_{i,0} \neq \#)
$$

$$
dp_{i,1} = \min(dp_{i-1,1}, dp_{i-1,0} + (s_{i,0}\neq \#)) + (s_{i,1} \neq \#)
$$

$$
ans=\min(dp_{end,0},dp_{end,1})
$$

我们得到了一个转移方程，其中 $s_{i,j}$ 表示的是 $i$ 位置对应的上下层字符，$j$ 取 $0,1$，$0$ 为上层，$1$ 为下层。但是现在还有一个问题就是，如果从最开始进行 $dp$ 转移，由于第 $i$ 位置之前如果没有检测器，我们是不需要添加额外的检测器，所以我们需要找到第一个存在检测器的位置，以及最后一个位置的检测器位置即可。如果都找不到，说明没有检测器，虽然题目说了，已经存在一些检测器，我们为安全起见，可以特判一下这个情况。最后的答案，肯定就是由末尾的情况的最小值啦~，复杂度为 $O(n)$。

对于 $dp$ 的初始值，只需要看当前是否为 `#`，为  `#` 则是 $0$，否则是 $1$ 即可，然后就可以美美地敲一发 $AC$ 啦~

---

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6+30;

char s[N][2];
int dp[N][2]; // 表示当前 i 位第 j 个位置为 '#' 联通时候的最小花费

void solve(){
    string t;
    int n;
    // 数据输入
    for(int j=0;j<2;j++){
        cin>>t;// 读入一个字符串
        n = t.size();
        for(int i=1;i<=n;i++)s[i][j] = t[i-1];
    }

    int st = n+1,en = 0; // 找到左右两边的起始位置
    for(int i=1;i<=n;i++){
        if(s[i][0]=='#'||s[i][1]=='#'){
            st = min(i,st);
            en = max(en,i);
        }
    }
    // 没有找到 '#' 直接返回即可
    if(st==n+1){
        cout<<0<<endl;
        return;
    }
    if(s[st][0]!='#')dp[st][0]=1;
    if(s[st][1]!='#')dp[st][1]=1;
    for(int i=st+1;i<=en;i++){
        dp[i][0] = min(dp[i-1][0],dp[i-1][1]+(s[i][1]!='#'))+(s[i][0]!='#');
        dp[i][1] = min(dp[i-1][1],dp[i-1][0]+(s[i][0]!='#'))+(s[i][1]!='#');
    }
    cout<<min(dp[en][0],dp[en][1])<<endl;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    solve();
    return 0;
}
```
第一次发题解，撒花完结~

---

## 作者：KANO07 (赞：12)

思路贪心+分类讨论。

以这种情况为例，红色表示检测器，左边的检测器想到达右侧，只有两种移动方案，第一行走过去，第二行走过去。

![](https://cdn.luogu.com.cn/upload/image_hosting/a1mq840s.png)

从左到右建立坐标系，记第一行最右侧检测器坐标为 $l$，第二行最右侧检测器坐标为 $r$，当前检测器坐标为 $i$。那么两种移动方案的花费分别为 $i-l$ 与 $i-r-1$。

我们选择花费小的方案，如果两者花费相同，优先选择能布置同列检测器的方案，即 $i-l$，因为这样做可以增大 $l$。

为什么当 $i-r-1$ 较小时，我们直接选择此方案，而不考虑增大 $l$。
因为在同列另一行放置检测器的花费是 $1$。也就是我们可以用 $i-r-1$ 节省下来的操作去完成增大 $l$ 的操作。

其他情况基本同理，只需按上面的逻辑从左到右处理即可。

代码如下：

```cpp
const int N = 1e6 + 5;
int a[N][2];
void solve() {
    string s, t;
    cin >> s >> t;
    int n = s.size();
    for (int i = 1; i <= n; i++) {
        if (s[i - 1] == '#') a[i][0] = 1;
        if (t[i - 1] == '#') a[i][1] = 1;
    }
    int l = 0, r = 0, res = 0;
    for (int i = 1; i <= n; i++) {
        if ((a[i][0] || a[i][1]) && (l || r)) {
            int cnt = INT_MAX;
            if (a[i][0]) cnt = min({cnt, i - l - 1, i - r});
            if (a[i][1]) cnt = min({cnt, i - r - 1, i - l});
            res += max(0, cnt);
            //下面省略了一些逻辑，走同一行的时候，a[i-1][0/1]会设置联通器，但这对后续答案没有影响，所以省略。
            if (a[i][0] && !a[i][1]) {
                a[i][1] = (i - r <= i - l - 1);
            } else if (a[i][1] && !a[i][0]) {
                a[i][0] = (i - l <= i - r - 1);
            }
        }
        l = a[i][0] ? i : l;
        r = a[i][1] ? i : r;
    }
    cout << res << endl;
}
```

---

## 作者：bbsiak (赞：8)

~~赛内也是写了个普通 BFS，通失满分。~~

看了一波题解，还没有用搜索来写的题解，这题的搜索思路相当明显，让我这个~~菜鸟~~来交一发。

对于这道题我们可以用一个优先队列来处理它的最优情况，保证不重搜，不错搜。

如果用普通队列可能会出现以下两种情况（~~巨佬除外~~）：

1. 假如如你有一个标记数组，你每搜到一个新的节点时直接标记，那么它很有可能不是最优的情况，可能会更新一个较大的数量。~~（正是在下）。~~
1. 在没有标记数组的情况，用到当前节点所需的数量来更新数据，会出现多次重复更新的情况，最后导致 TLE。

话不多说，看代码。

```cpp
#include <bits/stdc++.h>

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    std::vector<std::string> a(2);
    std::cin >> a[0] >> a[1];

    struct Node {
        int x, y, w;//坐标和到达这个坐标所需要的数量
        bool operator<(const Node& a) const {
            return a.w < w;
        }//小根堆
    };
    std::priority_queue<Node>  q;//用优先队列来处理他所用的最少检测器

    int len = a[0].length();
    int l = -1, r = -1;//记录它的左右边界
    
    for (int i = 0;i < len;i++) {
        if (a[0][i] == '#' || a[1][i] == '#') {
            if (l == -1) {
                if (a[0][i] == '#')q.push({ 0,i,0 });
                else if (a[1][i] == '#')q.push({ 1,i,0 });
                //得到一个起始点
                l = i;r = i;
            } else {
                r = i;
            }
        }
    }

    //如果没有检测器，直接退处即可
    if (l == -1 && r == -1) {
        std::cout << 0 << '\n';
        return 0;
    }

    int dx[3] = { -1,1,0 }, dy[3] = { 0,0,1 };
    //方向数组，它只需要一直向右边走即可，同时处理去上下
    std::vector<std::vector<int>> d(2, std::vector<int>(len, 2E9));
    // d 用来记录到达每个点所需要的最小数量
    d[q.top().x][q.top().y] = 0;//初始化

    while (!q.empty()) {
        int x = q.top().x, y = q.top().y, w = q.top().w;
        q.pop();

        for (int i = 0;i < 3;i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx <= 1 && ny <= r) {//保证在边界内
                int t = 1;
                if (a[nx][ny] == '#')t = 0;//对于已有的情况，没有必要加一

                if (d[nx][ny] > w + t) {//大于的情况就更新
                    d[nx][ny] = d[x][y] + t;
                    q.push({ nx,ny,w + t });
                }

            }
        }
    }

    //最后输出到达右边界最小值即可
    std::cout << std::min(d[0][r], d[1][r]) << '\n';

    return 0;
}
```

---

## 作者：sWDjb (赞：5)

# P12135蓝桥杯2025省B水质检测

>难得有一道题能让菜鸡我也能在比赛的时候写出来，趁着还没什么人来发题解，我也来发一下。
## 数据结构

其实这题一开始想用图来做，但是一看这个只有两行，越看越像 dp，于是我就使用 dp 的方法来做了。

既然使用 dp，那肯定就想到了 $\text{dp}[i][j]$ 代表了在第 $i$ 行 $j$ 列上有探测器且与后方大部队相连的最小值。当然了 $i$ 只能取 $0$ 和 $1$，所以想要取另一行的话就直接 $1-i$ 就好了。

$\text{arr}[i][j]$ 就是读出来的两个字符串，但是下标从 $1$ 到 $n$，而且 `#` 表示 $1$，`.` 表示 $0$。
## 状态转移方程

下面给出状态转移方程：

$$
\text{dp}[i][j] = \min\left(
  \underbrace{\text{dp}[i][j-1] + (1 - \text{arr}[i][j])}_{\text{同一行转移}},
  \underbrace{\text{dp}[1-i][j-1] + (2 - \text{arr}[1-i][j] - \text{arr}[i][j])}_{\text{跨行转移}}
\right)
$$
$$ ( i \in \{0, 1\} ,\quad  j \in \{k \mid 1 \leq k \leq n\} )$$

状态转移方程可以直接解释为：
1. ***同行转移***：和自己**同一行并且在自己前面一格**（也就是 $j-1$ 的位置）需要最少的探测器数量 $+$ **自己**本身是否需要探测器。
2. ***跨行转移***：和自己**不在同一行并且在自己前面一格**需要最少的探测器数量 $+$ 和自己**不在同一行并且和自己同一列**的位置是否需要探测器 $+$ **自己**是否需要探测器。
3. 求这两项的最小值，就是这个位置上需要最少得探测器数量。

>由于有探测器才是 $1$，而无探测器才是 $0$，所以说是否需要探测器为 $1-\text{arr}[i][j]$。


## 一些需要特别处理的小地方

如果最开始的时候根本就没有探测器，那么这个位置就不需要和前面相连，那么我们就不需要对 $dp$ 进行操作了，因此我设了一个变量 $f$ 来判断是否遇见过 `#`。

同样的，我们不需要对最后一个 `#` 之后的范围进行判断，所以我又设了一个 $last$ 变量来记录最后一个 `#` 的位置。

## 代码

### 读取的代码

```cpp
    cin>>s1>>s2;
    n = s1.size();
    for(int i=0;i<n;i++){
        if(s1[i] == '#'){
            arr[0][i+1] = 1;        // 话说为了方便之后的计算，所以可以把0和1反过来记
            last = i+1;             // 不过就这样吧
        }
        else if(s1[i] == '.')arr[0][i+1] = 0;
        if(s2[i] == '#'){
            arr[1][i+1] = 1;
            last = i+1;
        }
        else if(s2[i] == '.')arr[1][i+1] = 0;
    }
```

### 状态转移代码

```cpp
    for(int i=1;i<=last;i++){
        if(f == 0 &&  (arr[0][i] == 1 || arr[1][i] == 1))f=1;
        if(f){
            dp[0][i] = min(dp[0][i-1] + 1 - arr[0][i], dp[1][i-1] + 2 - arr[1][i] - arr[0][i]);
            dp[1][i] = min(dp[1][i-1] + 1 - arr[1][i], dp[0][i-1] + 2 - arr[0][i] - arr[1][i]);                    // 因为只有0和1我就直接用了，没有使用1-i
        }
    }
```

### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, f = 0,last = 0;
string s1,s2;
int arr[2][1000005],dp[2][1000005];

int main(){
    cin>>s1>>s2;
    n = s1.size();
    for(int i=0;i<n;i++){
        if(s1[i] == '#'){
            arr[0][i+1] = 1;
            last = i+1;
        }
        else if(s1[i] == '.')arr[0][i+1] = 0;
        if(s2[i] == '#'){
            arr[1][i+1] = 1;
            last = i+1;
        }
        else if(s2[i] == '.')arr[1][i+1] = 0;
    }
    for(int i=1;i<=last;i++){
        if(f == 0 &&  (arr[0][i] == 1 || arr[1][i] == 1))f=1;
        if(f){
            dp[0][i] = min(dp[0][i-1] + 1-arr[0][i], dp[1][i-1] + 2 - arr[1][i] - arr[0][i]);
            dp[1][i] = min(dp[1][i-1] + 1-arr[1][i], dp[0][i-1] + 2 - arr[0][i] - arr[1][i]);
        }
    }
    cout<<min(dp[0][last],dp[1][last]);
    return 0;
}
```

>附上：[ac记录](https://www.luogu.com.cn/record/213492297)

---

## 作者：Yumo_qwq (赞：4)

## 废话 & 牢骚
赛时狠狠写了广搜，然后宣布寄了（悲）。

赛后发现贪心完全可解。

正解应该有 DP 的思想，但是本题解完全看不出来，一眼看过去像是在做什么模拟题。

## 以下为题解 :
思路：贪心+分类讨论。

矩阵只有两行，所以可以拿两个字符串来记录。

对于每一个连通块，都可以找到以下三种状态：

### case 1
```
** # **
** # **
```
### case 2
```
** # **
** . **
```
### case 3
```
** . **
** # **
```

不难发现：对于某一列如果上下都是 ` . ` 那么这一列对答案没有任何贡献，完全可以无视。

因此我们只需要考虑上述三种情况之间的连通，并贪心地选择连接两段 ` # ` 的方式使得所需填充的 ` # ` 数量最少，即 `右# - 左#` 最小。

后文中，我们用 `i` 表示左侧连通块的下标，用 `j` 表示右侧连通块的下标（与代码中的一致）。

### 对于 case 1：
case 1 与任意其它 case 连通时所需填的 ` # ` 数量相同，因此对答案的贡献始终为 `j - i - 1`。

### 对于 case 2：
#### 分类讨论：case 2 -> case 1 & case 2
对于这种连接方式，我们在第一行中把两个 ` # ` 之间的所有 ` . ` 填充为 ` # `，即：
```
. . # . . #
. . . . . #
最优填充方式:
. . # # # #
. . . . . #
```
```
. . # . . #
. . . . . .
最优填充方式:
. . # # # #
. . . . . .
```
这种情况下对答案的贡献为 `j - i - 1`。

#### 分类讨论：case 2 -> case 3

这种情况下最佳的填充方式是把 case 3 的上半格 ` . ` 也填充为 ` # `，这样填充的话，就把下一次要进行的 case 3 的填充情况转换为了 case 1 的情况。

case 1 对答案的贡献是所有情况一致且最小的，符合贪心。

这种情况下对答案的贡献为 `j - i`。

```
. . # . . . .
. . . . . . #
最佳填充方式：
. . # # # # #
. . . . . . #
```

### 对于 case 3 ：
case 3 与 case 2 的情况是镜像对称的，只需要上下颠倒，逻辑完全一致，~~偷懒直接复制改一下~~。

#### 分类讨论：case 3 -> case 1 & case 3
对于这种连接方式，我们在第一行中把两个 ` # ` 之间的所有 ` . ` 填充为 ` # `，贡献仍然为 `j - i - 1`。
```
. . . . . #
. . # . . #
最优填充方式：
. . . . . #
. . # # # #
```
```
. . . . . .
. . # . . #
最优填充方式:
. . . . . .
. . # # # #
```
#### 分类讨论：case 3 -> case 2

这种情况下最佳的填充方式是把 case 2 的下半格 ` . ` 也填充为 ` # `，这样填充的话，就把下一次要进行的 case 2 的填充情况转换为了 case 1 的情况，对答案的贡献为`j - i`。

```
. . . . . . #
. . # . . . .
最佳填充方式：
. . . . . . #
. . # # # # #
```
综上，我们完成了对所有连接方式的讨论，并找出了最优的填充策略，从而构造出一个贪心策略。

下面依据题意进行模拟。

直接使用一个循环遍历整个字符串。

每到达一个连通块，找到其最右端的位置 `i`。然后从 `i` 的下一个位置开始第二重循环，找到下一个连通块。

根据找到的这两个连通块讨论对答案的贡献，计算并累加到 `ans`。

之后把 `i` 设置为 `j` 前一个字符的位置，即 `i = j - 1`，跳过无用的遍历 ` . ` 的过程。

终止第二次循环，继续下一次处理。

遍历完成后，答案即为所需填充的最小次数。

遍历一遍复杂度为 $O(N)$，本题数据保证  $n \le 10^6 $，可以通过。

## 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using u64 = unsigned long long;
const int INF = 0x3f3f3f3f;
const int N = 1e6 + 10;

void solve() {
    int ans = 0;
    string a, b;
    cin >> a >> b;
    a = " " + a;
    b = " " + b;

    for(int i = 1; i < a.length(); i++) {   // case1
        if(a[i] == '#' && b[i] == '#') {     
            if(a[i + 1] == '#' || b[i + 1] == '#') continue;    // 找连通块最右端 (右侧没有 # 相连)

            for(int j = i + 1; j < a.length(); j++) {       
                if((a[j] == '#' && b[j] == '#') 
                || (a[j] == '#' && b[j] == '.') 
                || (a[j] == '.' && b[j] == '#')) {
                    ans += j - i - 1;
                    i = j - 1;              // 直接调整 i 到下一个连通块的位置(优化)
                    break;
                }
            }
        }
        if(a[i] == '#' && b[i] == '.') {    // case2
            if(a[i + 1] == '#') continue;   // 找连通块最右端 (右侧没有 # 相连)

            for(int j = i + 1; j < a.length(); j++) {
                if((a[j] == '#' && b[j] == '#') 
                || (a[j] == '#' && b[j] == '.')) {
                    ans += j - i - 1;
                    i = j - 1;
                    break;
                }
                if(a[j] == '.' && b[j] == '#') {
                    ans += j - i;
                    a[j] = b[j] = '#';  // 更新连通块, 使变成 case 1 的情况
                    i = j - 1;
                    break;
                }
            }
        }
        if(a[i] == '.' && b[i] == '#') {    // case 3
            if(b[i + 1] == '#') continue;   // 找连通块最右端 (右侧没有 # 相连)

            for(int j = i + 1; j < a.length(); j++) {
                if((a[j] == '#' && b[j] == '#') 
                || (a[j] == '.' && b[j] == '#')) {
                    ans += j - i - 1;
                    i = j - 1;
                    break;
                }
                if(a[j] == '#' && b[j] == '.') {
                    ans += j - i;
                    a[j] = b[j] = '#'; // 更新连通块
                    i = j - 1;
                    break;
                }
            }
        }
    }
    cout << ans << '\n';
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    int T = 1;

    while(T--) solve();

    return 0;
}
```

---

## 作者：粥2414 (赞：4)

# 思路
首先发现对于每一列，总共有以下四种情况：

```
. | # | . | #
. | . | # | #
```
依次设为情况 $0$ 到 $3$。

设 $l$ 为第一个 ``#`` 出现的列数，$r$ 为最后一个。显然对于区间 $[l,r]$ 之外的格子，完全不需要设置任何检测器。

而对于完成建设之后，区间 $[l,r]$ 一定不含有情况 $0$，其余情况都有可能，所以考虑 dp。

设 $dp_{i,j}$ 表示将第 $i$ 列建设为 $j$ 情况，且保证 $[l,i]$ 合法的最小建设数。

显然对于建设前后矛盾的情况为非法情况，$j=0$ 时也为非法情况，赋为极大值即可。

根据题意，情况一只能由情况一和情况三转移而来，情况二只能由情况二和情况三转移而来，情况三可以从情况一到三转移。取最小值，然后加上需要额外增加的检测器数量即可。

注意特判没有 ``#`` 的情况。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ld long double
char __sta[1009], __len;
inline void write(ll x, bool bo) {
	if (x < 0)putchar('-'), x = -x;
	do __sta[++__len] = x % 10 + 48, x /= 10;
	while (x);
	while (__len)putchar(__sta[__len--]);
	putchar(bo ? '\n' : ' ');
}
const ll N=1000009,INF=1e9+7;
char a[2][N];
ll l,r;//第一个、最后一个#
ll n;
ll dp[N][5];
ll t[N];
int main(){
	fgets(a[0],N,stdin);
	fgets(a[1],N,stdin);
	l=r=-1;
	n=strlen(a[0])-1;
	for(int i=0;i<=n;i++){
		if(l==-1&&(a[0][i]=='#'||a[1][i]=='#'))l=i;
		if(a[0][i]=='#'||a[1][i]=='#')r=i;
		if(a[0][i]=='.'&&a[1][i]=='.')t[i]=0;
		if(a[0][i]=='#'&&a[1][i]=='.')t[i]=1;
		if(a[0][i]=='.'&&a[1][i]=='#')t[i]=2;
		if(a[0][i]=='#'&&a[1][i]=='#')t[i]=3;
	}
	if(l==-1){write(0,1);return 0;}
	for(int i=l;i<=r;i++){
		int k=i-1;
		if(k<0)k=n+1;
		for(int j=0;j<=3;j++){
			if(j==0)dp[i][j]=INF;
			if(j==1){
				if(t[i]==2||t[i]==3)dp[i][j]=INF;
				else{
					ll x=(t[i]==0);
					dp[i][j]=x+min(dp[k][1],dp[k][3]);
				}
			}
			if(j==2){
				if(t[i]==1||t[i]==3)dp[i][j]=INF;
				else{
					ll x=(t[i]==0);
					dp[i][j]=x+min(dp[k][2],dp[k][3]);
				}
			}
			if(j==3){
				ll x;
				if(t[i]==0)x=2;
				if(t[i]==1||t[i]==2)x=1;
				if(t[i]==3)x=0;
				dp[i][j]=x+min(dp[k][1],min(dp[k][2],dp[k][3]));
			}
		}
	}
	write(min(dp[r][0],min(dp[r][1],min(dp[r][2],dp[r][3]))),1);
	return 0;
}
```

---

## 作者：Nosecone (赞：3)

出来才知道这是一道 dp 题目，考场上完全没有反应过来。

初步思路是将两个连通块连接起来。那么我们需要使每两个连通块之间的路径最小，即从两个连通块的最边缘处开始连接。接下来我们需要找到位于连通块边缘的点。

数据范围 $n \le 10^6$，可以考虑使用 bfs。

这里采用从左往右搜索的方法：对于每个连通块找到最右边那个点，之后从这个点开始往右修改字符，直到与下一个连通块连通为止。

对于一个连通块边缘，上下都是符号 `#` 的情况：

```
#.......#
#.....###
```
上下均为字符 `#` ，但离下一个连通块的直线距离不一样。此时我们应该选择下面的点开始进行连接操作，我的做法就是再开个循环测一下长度。

由于采用暴力方法使得代码过于丑陋，请见谅。

## Code:

```cpp
#include <iostream>
#include <string>
#include <queue>
#include <algorithm>
using namespace std;

class node
{
public:
	int x, y;
	node(int a, int b)
	{
		x = a, y = b;
	}
};

int n = 0, ans = 0, l = -1, r = 1000005;
node t = node(0, 0);

char arr[2][1000005];
int dx[4] = { 0, 0, -1, 1 }, dy[4] = { -1, 1, 0, 0 };
bool vis[2][1000005] = { 0 };

node bfs(int x, int y)
{
	int right = y, h = x;
	queue<node>q;
	q.push(node(x, y));
	while (!q.empty())
	{
		node now = q.front();
		q.pop();
		if (vis[now.x][now.y])
		{
			continue;
		}
		vis[now.x][now.y] = 1;
		if (now.y > right)
		{
			right = now.y, h = now.x;
		}
		for (int i = 0; i < 4; ++i)
		{
			node next = now;
			next.x += dx[i], next.y += dy[i];
			if (next.x >= 0 && next.x <= 1 && next.y >= 0 && next.y <= r && arr[next.x][next.y] == '#' && !vis[next.x][next.y])
			{
				q.push(node(next.x, next.y));
			}
		}
	}
	return node(h, right);
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	string a, b;
	cin >> a >> b;
	n = a.length();
	for (int i = 0; i < a.length(); ++i)
	{
		arr[0][i] = a[i], arr[1][i] = b[i];
	}
	for (int i = 0; i < n; ++i)   //用l和r限制搜索范围
	{
		if (arr[0][i] == '#' || arr[1][i] == '#')
		{
			l = i;
			break;
		}
	}
	for (int i = n - 1; i >= 0; --i)
	{
		if (arr[0][i] == '#' || arr[1][i] == '#')
		{
			r = i;
			break;
		}
	}
	if (l == -1 && r == 1000005)   //没有连通块就不用找了
	{
		cout << ans;
		return 0;
	}
	while (l < r)
	{
		if (arr[0][l] == '#')
		{
			t = bfs(0, l);
		}
		else
		{
			t = bfs(1, l);
		}   //因为我只找了左右范围没有找具体点所以就这么写了
		int i = 0, j = 0;
		if (arr[!t.x][t.y] == '#')
		{
			for (i = t.y + 1; i <= r; ++i)
			{
				if (arr[0][i] == '#')
				{
					break;
				}
			}
			for (j = t.y + 1; j <= r; ++j)
			{
				if (arr[1][j] == '#')
				{
					break;
				}
			}
			if ((i - t.y > j - t.y && t.x == 0) || (i - t.y < j - t.y && t.x == 1))
			{
				t.x = !t.x;
			}
		}
		l = t.y;
		if (l >= r)   //如果是一整个大的连通块也不用找
		{
			cout << ans;
			return 0;
		}
		while (t.y <= r) //搭桥，使两个连通块相互连接
		{
			arr[t.x][++t.y] = '#';
			++ans;
			l = t.y;
			if (arr[!t.x][t.y] == '#' || arr[t.x][t.y + 1] == '#')   //成功联通则停止
			{
				break;
			}
		}
	}
	cout << ans;
	return 0;
}
```

---


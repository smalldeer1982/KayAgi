# 穿睡衣军训

## 题目背景

在本题中，我们称一个串 $x$ 是一个串 $y$ 的**子串**当且仅当在 $y$ 开头和结尾删除若干个（可以为 $0$ 个）字符后得到的字符串与 $x$ 相同。例如，$\texttt{bc}$,$\texttt{abc}$,$\texttt{a}$,$\texttt{abcd}$ 都是字符串 $\texttt{abcd}$ 的子串，但 $\texttt{abd}$ 不是。

我们称一个串 $x$ 是一个串 $y$ 的**子序列**当且仅当在 $y$ 中删除若干个（可以为 $0$ 个）字符后得到的字符串与 $x$ 相同。例如，$\texttt{bc}$,$\texttt{abc}$,$\texttt{a}$,$\texttt{abcd}$,$\texttt{abd}$ 都是字符串 $\texttt{abcd}$ 的子串，但 $\texttt{dcba}$ 不是。

特别的，空串是任何串的子串，也是任何串的子序列。

## 题目描述

给定两个字符串 $s,t$，扶苏想让你求出一个字符串 $x$，满足：

- $x$ 是 $s$ 的**子串**。
- $x$ 是 $t$ 的**子序列**。
- 在所有满足前述两条的字符串中，$x$ 的长度最长。
- 在所有满足前述三条的字符串中，$x$ 的字典序最小。

请你帮她求出这样的字符串 $x$。

## 说明/提示

## 数据规模与约定

用 $|x|$ 表示字符串 $x$ 的长度。

- 对 $10\%$ 的数据，$T = 0$。
- 对 $30\%$ 的数据，$|s| = 1$。
- 对 $50\%$ 的数据，$|s|, |t| \leq 10$。
- 对 $80\%$ 的数据，$|s|, |t| \leq 100$。
- 对 $100\%$ 的数据，保证 $0 \leq T \leq 10$，$1 \leq |s|\leq 10^3$，$1 \leq |t| \leq 10^5$，输入字符串只含小写英文字母。

## 样例 #1

### 输入

```
3
xyzdabc
xaybzc
abc
xyz
abbcd
aabbdcd```

### 输出

```
abc

abbcd```

# 题解

## 作者：一扶苏一 (赞：6)

一句话题解：

考虑枚举答案串在 $s$ 里开头的位置 $s_i$。然后把 $s_{i \sim |s|}$ 这个后缀扔到 $t$ 的子序列自动机上做匹配，那么能匹配上的长度就是以该位置开头的最长所求串。

更细致的题解：

考虑枚举 $s$ 的一个子串 $s'$，然后检查 $s'$ 能否成为 $t$ 的子序列。这是一个经典问题，可以使用子序列自动机解决。

具体的，考虑把 $s'$ 的每一位从前向后在 $t$ 上进行匹配。假设 $s'$ 的前 $i$ 位是 $t$ 的前 $j$ 位的子序列，根据贪心的原则，显然 $j$ 越小越好（这样 $s'$ 后面的位置可以匹配更多的字符）。因此假设当前 $s'$ 的前 $i$ 位匹配了 $t$ 的前 $j$ 位，那么 $s'$ 的第 $i + 1$ 位应该匹配 $t_j$ 后面第一个 $s_{i + 1}'$ 出现的位置。

这样我们需要维护出 $t$ 里每个位置的下一个字符是什么，放在代码的 $f$ 数组里，$f$ 就是 $t$ 的子序列自动机。每次只需要把 $s'$ 放在自动机上跑，没有跑出自动机就说明 $s'$ 是 $t$ 的子串。

进一步的，对于 $s$ 的一个后缀 $suf(s)$，它能在 $t$ 的子序列自动机上被接受的最长前缀长度就是这个后缀能匹配上的最长子串。

所以枚举 $s$ 的后缀，对每个后缀都放到子序列自动机上跑一次就行了。时间复杂度 $O(|s|^2 + |\Sigma||t|)$

```cpp
#include <bits/stdc++.h>

int main() {
  int T;
  for (std::cin >> T; T; --T) {
    std::string s, t;
    std::cin >> s >> t;
    t = " " + t;
    std::vector f(t.size() + 1, std::vector<int>(26, -1));
    for (int i = t.size() - 1; i; --i) {
      f[i - 1] = f[i];
      f[i - 1][t[i] - 'a'] = i;
    }
    std::string ans;
    for (int i = 0; i < s.size(); ++i) {
      int j = i, p = 0;
      while (j < s.size()) {
        int ch = s[j] - 'a';
        if (f[p][ch] == -1) break;
        p = f[p][ch];
        ++j;
      }
      int len = j - i;
      if (len > ans.length()) {
        ans = s.substr(i, len);
      } else if (len == ans.length()) {
        auto cur = s.substr(i, len);
        if (cur < ans) ans = cur;
      }
    }
    std::cout << ans << std::endl;
  }
}
```

---

## 作者：chzhh_111 (赞：5)

观察一下数据范围，发现 $s$ 串的长度最多只有 $10^3$，再加上题目给的条件：$x$ 是 $s$ 的**子串**，那就可以选择枚举 $s$ 的每一个子串，再在 $t$ 上做匹配。

那该如何做匹配呢？首先题目要求：$x$ 是 $t$ 的**子序列**，这个要求看起来不好达到，但我们一想就会发现，假设我们已经匹配到我们要匹配的这个子串的第 $i$ 位，那么这个子串第 $i+1$ 位的字母肯定是确定的，也就是我们接下来要匹配的字母是确定的。但这样仍然有很多种选择，我们考虑优化。

我们可以发现匹配每一个字母时，在 $t$ 串上我们都是向后跳的，如果中间跳的字母越多，对后面的匹配肯定是不优的，因为这样字母的种类就有可能变少，出现无法匹配的字母的可能性越来越大，那最后匹配的子串长度可能就越小。所以我们就有一个策略：**假设我们现在要匹配一个字母 $a$，那么在 $t$ 串上，我们每一次都跳到，从当前位置往后找的第一个字母为 $a$ 的位置**。这样子匹配出来的串就是最长的了。

为了实现以上操作，我们定义 $sub_{j,i}$，表示从 $t$ 串上的第 $i$ 位向后找的第一个字母编号为 $j$ 的位置，其中 $0 \le j \le 25$，而字母编号是按照顺序编定的，其中 $\mathrm{a}$ 的编号为 $0$，而 $\mathrm{z}$ 的编号为 $25$，剩下的以此类推。

那我们的匹配就是，在 $t$ 串上不断的往后跳的过程，直到跳出 $t$ 串或者所匹配的子串的长度已经到极限了。

时间复杂度 $O(|s|^2 + |t|)$。

代码实现：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int Ls=1010,Lt=1e5+100;
int T,top[26],sub[26][Lt],ns,nt,maxlen;//top[i] 表示在 t 串从后往前遍历，编号为 i 的字母最后一次出现的位置
char s[Ls],t[Lt];string ans;
signed main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%s%s",s+1,t+1);
		maxlen=0,ans="";
		ns=strlen(s+1),nt=strlen(t+1);
		memset(sub,0,sizeof(sub)); 
		for(int i=0;i<26;i++) top[i]=nt+1;
		for(int i=nt;i>=1;i--)
		{
			for(int j=0;j<26;j++) sub[j][i]=top[j];
			int a=t[i]-'a';
			top[a]=i;
		}
		for(int i=0;i<26;i++) sub[i][0]=top[i];
		for(int i=1;i<=ns;i++)
		{
			int len=0,w=sub[s[i]-'a'][0];string S="";//w 表示当前在 t 串上的位置
			while(w<=nt)
			{
				S+=s[i+len];
				len++;//匹配成功
				if(i+len>ns) break;
				w=sub[s[i+len]-'a'][w];//往后跳
			}
			if(len>maxlen)
			{
				maxlen=len;
				ans=S;
			}
			else if(len==maxlen) ans=min(ans,S);
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：wangruize88 (赞：3)

## 双指针  
阅读题目，我们发现，我们要匹配字符串 $S$ 的**字串**和字符串 $T$ 的**子序列**。显然，对字串的要求要严格于子序列。  
  
那么，我们很容易想到，逐个枚举 $S$ 的字串，然后与 $T$ 的子序列相匹配即可。  
  
不过这样效率过低，怎么办呢？ 
  
很简单，使用双指针算法。用一个先用一层 `for` 枚举 $S$ 的字串起点，然后对于每次枚举，用指针 $i$ 指向 $S$ 的字串，指针 $j$ 指向 $T$ 的子序列，匹配则 `i++,j++;` 不匹配则不断 `j++`，直到匹配成功或遍历完了 $T$。每次匹配成功就检查当前的字串是否为最优解。  
  
如果把 substr 视作 $O(1)$，单次询问时间复杂度 $ O(|S|^2+|S|\times|T|) $。  

然后还可以适当增加一些剪枝，当剩余未匹配的部分加上已匹配长度已经无法大于当前最优解时，就直接退出即可。  

由于双指针并不会真的每次都把 $S$ 一遍，加上添加了剪枝，可以通过此题。
  

### AC  Code
```cpp
#include <bits/stdc++.h>
using namespace std ;
int T , len1 , len2 ;
string s , t , ans ;
string better ( string a , string b ) {
	if ( a.length() == b.length() ) return a<b?a:b ;
	else return a.length()>b.length()?a:b ;
}//判断更优的答案
int main () {
	ios::sync_with_stdio(0) ;
	cin >> T ;
	while ( T-- ) {
		cin >> s >> t ;
		len1 = s.length() , len2 = t.length() , ans = "" ;
		for ( int b = 0 ; b < len1 ; b ++ ) {
			int check = ans.length() ;
			if ( len1-b < check ) break ;//剪枝
			for ( int i = b , j = 0 ; i < len1 ; i ++ ) {
				bool flag = 0 ;
				while ( s[i] != t[j] ) {
					j++ ;
					if ( len2-j+i-b < check ){
						flag = 1 ;
						break ;//剪枝
					}
					if ( j >= len2 ) {
						ans = better(ans,s.substr(b,i-b)) , flag = 1 ;
						break ;
					}
				}
				if ( flag ) break ;
				if ( s[i] == t[j] )ans = better(ans,s.substr(b,i-b+1)) , j ++ ;
			}
		}
		cout << ans << endl ;
	}
	return 0 ;
}
```

---

## 作者：ZinfI_Sh (赞：2)

[Link](https://www.luogu.com.cn/problem/P12597)

注意到找到的串 $x$ 在 $s$ 上是连续的，我们可以选择枚举 $s_i$ 作为 $x$ 的起点，然后从 $s_i$ 往后逐位与 $t$ 进行匹配。怎么匹配呢？我们可以用跳指针的方法，记 $nxt_{i,c}$ 表示在 $t$ 上的第 $i$ 位开始，右边第一个字符 $c$ 的位置，显然有：

$$nxt_{i,c}=\begin{cases}
i&\text{if }t_{i}=c \\
nxt_{i+1,c}&\text{if }t_{i}\not=c
\end{cases}$$

令 $nxt_{i+1,c}=0$。

有一个问题：为什么是右边的第一个字符呢？这里有个小贪心，即若 $\exist i\lt j,1\le i,j\le |t|$，且 $t_{i}=t_{j}=c$，那么我们想从一个 $k(k\lt i)$ 转移到字符 $c$ 时，为了匹配更长，显然选 $i$ 要比 $j$ 优，因为若选了 $j$，后续匹配的字符就少了 $i$ 到 $j$ 中的可能性。

举个例子：令 $s=\texttt{abc}$，$t=\texttt{abcbd}$，如果我从 $t_{1}$ 开始往后跳，跳到 $t_{4}$，那么最长只能匹配成 $\texttt{ab}$；反之，如果跳到 $t_{2}$，那么就可以继续往后跳，跳到 $t_{3}$，最长就可以匹配成 $\texttt{abc}$ 了。

通过这个贪心，我们还可以知道：我们去枚举 $s_{i}$ 时，想让字符 $c$ 作为开头，那么在跳 $t$ 串时只要选择 $t$ 上最左边第一个 $c$ 作为跳 $t$ 串的开始就好了，剩下 $t$ 串上的 $c$ 可以不去枚举。事实上你如果去枚举 $t$ 上的每一个 $c$ 会超时。

AC 代码：

```cpp
#include <bits/stdc++.h>
#define int long long
// #define hint unsigned long long
#define lowbit(x) (x & -x)
using namespace std;
const int DM[8][2] = {0, 1, 1, 0, 0, -1, -1, 0, 1, 1, 1, -1, -1, 1, -1, -1};
// const int HASHMOD = 9223372036854775783;
const int HASHMOD = 212370440130137957;
const int HASHBASE = 131;
const int HASHITEM = 1e7 + 3;
const int N = 50001;
int nxt[100101][26], fir[26];
signed main()
{
	int T;
	cin >> T;
	while (T--)
	{
		string s, t;
		cin >> s >> t;
		int sl = s.size(), tl = t.size();
		s = ' ' + s, t = ' ' + t;
		for (int i = 0; i <= 25; i++)
		{
			nxt[tl + 1][i] = 0;
			fir[i] = 0;
		}
		for (int i = 0; i <= 25; i++)
		{
			for (int j = tl; j >= 1; j--)
			{
				if (t[j] - 'a' == i)
				{
					nxt[j][i] = j;
				}
				else
				{
					nxt[j][i] = nxt[j + 1][i];
				}
				if (i == 0)
				{
					fir[t[j] - 'a'] = j;
				}
			}
		}
		string ans = "";
		for (int i = 1; i <= sl; i++)
		{
			int ps = i, pt = fir[s[i] - 'a'];
			string tmp = "";
			while (pt && ps <= sl)
			{
				tmp += s[ps];
				ps++;
				if (ps > sl)
				{
					break;
				}
				pt = nxt[pt + 1][s[ps] - 'a'];
			}
			if (tmp.size() > ans.size() || (tmp.size() == ans.size() && tmp < ans))
			{
				ans = tmp;
			}
		}
		cout << ans << '\n';
	}
}
```

---

## 作者：fish_love_cat (赞：1)

这题挂了 140pts /fad

---

为方便表述，定义 $n=|s|,m=|t|$。

注意到 $n\le 10^3$，考虑 $O(n^2)$ 枚举子串。

然后很容易写出 $O(n\log m)$ 的判断子序列，这样就得到了一个过不了的 $O(Tn^3\log m)$ 做法。

考虑优化，注意到判断子序列其实是可以继承于上一段的结果的，于是我们少了一个判断子序列花费的 $n$，此时复杂度来到 $O(Tn^2\log m)$，由于可以剪枝加上小常数，此时可以通过。

实现没啥难度，~~但是有个笨蛋赛时挂了~~。

```cpp
#include<bits/stdc++.h>
using namespace std;
void solve(){
    string s,t;
    cin>>s>>t;
    int n=s.size(),m=t.size();
    s=" "+s;
    t=" "+t;
    vector<int>ve[35];
    for(int i=1;i<=m;i++)
    ve[t[i]-'a'].push_back(i);
    string ans;
    for(int i=1;i<=n&&n-i+1>=ans.size();i++){
        string flc;
        for(int j=i,x=-1;j<=n;j++){
            auto catnip=upper_bound(ve[s[j]-'a'].begin(),ve[s[j]-'a'].end(),x);
            if(catnip==ve[s[j]-'a'].end())break;
            x=ve[s[j]-'a'][catnip-ve[s[j]-'a'].begin()];
            flc+=s[j];
            // cout<<x;
        }
        if(flc.size()>ans.size()||flc.size()==ans.size()&&flc<ans)ans=flc;
    }
    cout<<ans<<'\n';
}
int main(){
    int t;
    cin>>t;
    while(t--)solve();
    return 0;
}
```

---

有个糖诗这场比赛总共挂了 435pts，是谁啊好难猜呢。

---

## 作者：MoonCake2011 (赞：1)

口胡一个赛时想出的解法。

可以用[此题](https://www.luogu.com.cn/problem/P1439)与[此题](https://www.luogu.com.cn/problem/P3531)对顺序的处理方法 $O(m)$ 预处理，$O(n\log m)$ 单次查询的算法一个长度为 $n$ 的串是否是一个长度为 $m$ 的串的子序列。

我们可以考虑二分 $x$ 的长度然后直接用上述方法求解答案。

时间复杂度 $O(n\log n\log m)$。

---

## 作者：封禁用户 (赞：1)

观察到 CF2104E，考虑先预处理出 $f_{i,j}$ 表示在字符串 $T$ 中，下标 $i$ 之后的第一个字符 $j$ 的位置，没有则为 $0$。

再枚举 $S$ 的子串左端点，对于右端点 $r$，从左端点开始枚举，当发现 $s_r$ 所在的位置后面没有 $s_{r + 1}$ 时跳出，这个用 $f$ 判断即可。

时间复杂度 $\mathcal O(Tn^2)$。

代码大概长这样：

```cpp
il void mian(){
	cin >> s >> t; int n = s.size(), m = t.size(); s = " " + s, t = " " + t; string ans = "";
	R(i, m, 0){
		L(j, 0, 25) f[i][j] = lst[j];
		if (i) lst[t[i] - 'a'] = i;
	}
	L(i, 1, n){
		string x = ""; int ps = 0;
		L(j, i, n){
			if (f[ps][s[j] - 'a']) ps = f[ps][s[j] - 'a'], x += s[j];
			else break;
		}
		cmp(ans, x);//自定义比较函数
	}
	cout << ans; L(i, 0, 25) lst[i] = 0;
}
```

---

## 作者：redfull66 (赞：0)

观察到 $x$ 是 $s$ 的子串且 $1 \leq |s|\leq 10^3$，考虑 $O(|s|^2)$ 枚举子串，再在 $t$ 上做匹配。

匹配前预处理出 $d_{i,j}$ 表示在 $t$ 中第 $j$ 位之后的第一个字符为 $i$ 的位置，匹配时就可以在 $O(|s|^2)$ 匹配完成。

时间复杂度 $O(T(|s|^2+26 \times |t|))$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,k,f[30],d[30][100005];
string s,t,a,ans;
int main(){
	cin>>T;
	while(T--){
		cin>>s>>t,s=" "+s,t=" "+t,ans="";
		memset(d,0,sizeof(d));
		for(int i=0;i<26;i++)f[i]=t.size();
		for(int i=t.size()-1;i>=0;i--){
			for(int j=0;j<26;j++)d[j][i]=f[j];
			if(i)f[t[i]-'a']=i;
		}
		for(int i=1;i<s.size();i++){
			k=d[s[i]-'a'][0],a="";
			while(k<t.size()){
				a+=s[i+a.size()];
				if(i+a.size()>=s.size())break;
				k=d[s[i+a.size()]-'a'][k];
			}
			if(a.size()>ans.size())ans=a;
			if(a.size()==ans.size())ans=min(ans,a);
		}
		cout<<ans<<endl;
	}
	return 0;
}

```

---

## 作者：JYX0924 (赞：0)

我们很容易发现，这道题合法的字符串是有单调性的。即每一个合法的字符串的子串也是合法的。因此，我们可以二分一个答案，然后 $n^2$ 判断一下就可以了。

只需要预处理一个 $pos_{i,j}$ 表示第 $i$ 个位置后第一个字符 $j$ 在哪里。显然预处理是 $26n$ 的复杂度。

下面是 AC 代码。


```cpp
#include<bits/stdc++.h>
#define ll long long 
#define maxn 100005 
using namespace std;
ll T,pos[maxn][30];
string s,t,ans;
void dfs(ll now)
{
	if(now==t.size()-1)
	{
		for(int i=1;i<=26;i++) pos[now][i]=-1;
		return;
	}
	dfs(now+1);
	for(int i=1;i<=26;i++)
	{
		if(t[now+1]==char(i-1+'a')) pos[now][i]=now+1;
		else pos[now][i]=pos[now+1][i];
	}
}
ll check(ll now)
{
	ll flag=0; vector<string> q;
	for(int i=1;i+now-1<s.size();i++)
	{
		ll tt=0;
		for(int j=i;j<=i+now-1;j++)
		{
			tt=pos[tt][s[j]-'a'+1];
			if(tt==-1) break;
		}
		if(tt==-1) continue;
		flag=1; q.push_back(s.substr(i,now));
	}
	if(!flag) return 0;
	sort(q.begin(),q.end()); ans=q[0];
	return 1;
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>T;
	while(T--)
	{
		cin>>s>>t; s='1'+s; t='1'+t;
		dfs(0); ll l=1,r=s.size()-1; ans.clear();
		while(l<=r)
		{
			ll mid=(l+r)>>1;
			if(check(mid)) l=mid+1; else r=mid-1;
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```
谢谢大家！！！

---


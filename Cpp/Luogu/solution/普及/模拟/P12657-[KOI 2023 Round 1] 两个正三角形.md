# [KOI 2023 Round 1] 两个正三角形

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

如图所示，第 1 行有 1 个数，第 2 行有 2 个数，……，第 $N$ 行有 $N$ 个数，构成一个正三角形。给定两个这样的正三角形 $A$ 和 $B$，每个位置上的数为 0 或 1。

![](https://cdn.luogu.com.cn/upload/image_hosting/9z381rzh.png)

你可以对正三角形进行顺时针或逆时针方向的 $120^\circ$ 旋转，也可以进行左右对称变换。

例如，将图中的正三角形 $A$ 进行旋转后可以得到如下的正三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/gt35kinw.png)

将 $A$ 进行对称变换后可以得到如下的正三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/uf9lbcxb.png)

两个正三角形的“差异”定义为：将它们重叠后，数值不同的位置的数量。

例如，若将正三角形 $A$ 和 $B$ 重叠，在第 2 行最左侧，以及第 3 行的最左侧和最右侧位置的数值不同，因此 $A$ 和 $B$ 的差异为 3。

但若将 $A$ 逆时针旋转 $120^\circ$ 后再与 $B$ 重叠，仅在第 3 行从左起第 2 个位置的数值不同，这时差异为 1。

给定两个正三角形 $A$ 和 $B$。你可以对 $A$ 进行任意次数的旋转或对称操作。你也可以选择不进行任何变换。操作次数不限。

请将 $A$ 变换为与 $B$ 差异最小的形态，并输出此时的最小差异值。

## 说明/提示

**样例 1 说明**

将 $A$ 逆时针旋转 $120^\circ$ 后，仅有一个位置与 $B$ 不同，差异为 1。还有其他方式也可以使差异为 1。

**限制条件**

- 所有给定的数值均为整数。
- $1 \leq N \leq 10$
- $A$ 和 $B$ 中每个位置的数值仅为 0 或 1。

**子问题**

1. （5 分）$A$ 中所有数值相同。换言之，$A$ 中所有位置均为 0 或均为 1。
2. （10 分）$N \leq 2$
3. （40 分）仅考虑旋转操作即可得到最优解。
4. （45 分）无额外限制。

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
3
0
1 0
1 0 0
0
0 0
0 0 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4
0
1 1
1 0 0
1 0 0 0
0
0 0
0 0 1
1 1 1 0```

### 输出

```
0```

## 样例 #3

### 输入

```
4
0
1 0
0 0 1
1 1 0 0
0
0 1
0 0 0
0 1 1 1```

### 输出

```
2```

# 题解

## 作者：syh110213 (赞：1)

[$\huge 题目传送门$](https://www.luogu.com.cn/problem/P12657)


## 题意
对于一个正三角形，求其通过旋转和对称变换所得的 $6$ 种数组与 $B$ 数组数值不同的位置的数量的最小值。

## 思路
一道简单的模拟题。

将 $A$ 数组翻转两次，分别与 $B$ 数组比较。\
再对称变换后，翻转两次，分别与 $B$ 数组比较。

## code
~~~cpp
#include<bits/stdc++.h>
using namespace std;
int n,b[15][15],ans=INT_MAX;
void contrast(int w[15][15]){//比较函数
	int sum=0;
	for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) if(w[i][j]!=b[i][j]) sum++;
	ans=min(ans,sum);
}
int main(){
	scanf("%d",&n);
	int a[15][15],a1[15][15],a2[15][15];//通过旋转获得的
	for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) scanf("%d",&b[i][j]);
	contrast(a);
	for(int j=n,x=1;j>=1;j--,x++) for(int i=j,y=1;i<=n;i++,y++) a1[x][y]=a[i][j];//旋转一次
	contrast(a1);
	for(int j=n,x=1;j>=1;j--,x++) for(int i=j,y=1;i<=n;i++,y++) a2[x][y]=a1[i][j];//旋转两次
	contrast(a2);
	int c[15][15],c1[15][15],c2[15][15];//通过1次对称变换和旋转获得的
	for(int i=1;i<=n;i++) for(int j=1;j<=i;j++) c[i][j]=a[i][i-j+1];//对称变换
	contrast(c);
	for(int j=n,x=1;j>=1;j--,x++) for(int i=j,y=1;i<=n;i++,y++) c1[x][y]=c[i][j];//旋转一次
	contrast(c1);
	for(int j=n,x=1;j>=1;j--,x++) for(int i=j,y=1;i<=n;i++,y++) c2[x][y]=c1[i][j];//旋转两次
	contrast(c2);
	printf("%d",ans);
	return 0;
}
~~~

---

## 作者：XuZile (赞：0)

# P12657 题解
## 前言
就是一道普普通通的模拟题，直接~~无脑暴力~~做就可以了。
## 解题思路
题目要求将第一个三角形，经过旋转或者左右交换。使第一个三角形与第二个三角形，不一样的个数最少。

1. 将第一个三角形顺时针旋转。  
2. 将第一个三角形左右交换后，进行比较。  
3. 将第一个三角形再次左右交换后，进行比较。  
4. 再重复步骤 1 至步骤 3 两遍。

这边给大家拉个警钟。千万不要以为**先旋转再左右交换**的三角形与**先左右交换再旋转**的三角形，是一样的三角形。~~我就是在这里被卡了 10 分钟。~~
## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100][100];
int b[100][100];
int tmp[100][100];
int n,sum=1e18;
void run(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			a[i][j]=tmp[i][j];
		}
	}
}
int compare(){
	int s=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			if(tmp[i][j]!=b[i][j]) s++;
		}
	}
	return s;
}
void round(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			tmp[i][j]=a[n-j+1][i-j+1];
		}
	}
	run();
}
void turn(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			tmp[i][j]=a[i][i-j+1];
		}
	}
	sum=min(sum,compare());
	run();
}
int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin >> a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin >> b[i][j];
		}
	}
	round(),turn(),turn();
	round(),turn(),turn();
	round(),turn(),turn();
	cout << sum;
	return 0;
}
```

---

## 作者：枫原万叶 (赞：0)

# 题解 P12657

## 分析

首先可以明确，可以变换的可能数是固定的，通过计算可以得出在包括原三角形的情况下，实际上一共就只有 6 种方案。情况如下：

1. 原始三角形。
2. 旋转 120 度后的三角形。
3. 旋转 240 度后的三角形（即旋转 120 度两次）。
4. 对称变换后的三角形。
5. 对称变换后再旋转 120 度的三角形。
6. 对称变换后再旋转 240 度的三角形。

所以我们实际上只需要设计两个函数就可以了，一个是旋转 120 度的函数，一个是反转的函数。

对于第一个函数，实际上就是使得原位置 $(i, j)$ 移动到 $(n - 1 - j, i - j)$。

对于第二个函数，实际上就是每一行反转，也就是即位置 $(i, j)$ 变为 $(i, i - j)$。

最后把所有可能存起来，然后看一下谁的变化最小就可以了，代码非常简单，只展示关键部分。

## 代码

```cpp
//旋转一百二十度函数
void fun1(int s[10][10], int d[10][10]) {
	for (int i = 0; i < n; i++)
		for (int j = 0; j <= i; j++)
			d[i][j] = s[n - 1 - j][i - j];
}
//左右反转函数
void fun2(int src[10][10], int d[10][10]) {
	for (int i = 0; i < n; i++)
		for (int j = 0; j <= i; j++)
			d[i][j] = s[i][i - j];
}

```

主函数部分调用

```cpp
fun1(res[0], res[1]);
fun1(res[1], res[2]);
fun2(res[0], res[3]);
fun1(res[3], res[4]);
fun1(res[4], res[5]);
```

---


# 积水面积

## 题目描述

一组正整数，分别表示由正方体叠起的柱子的高度。若某高度值为 $x$，表示由 $x$ 个正立方的方块叠起（如下图，$0 \le x \le 5000$）。找出所有可能积水的地方（图中蓝色部分），统计它们可能积水的面积总和（计算的是图中的横截面积。一个立方体的位置，为一个单位面积）。

如图：柱子高度变化为 `0 1 0 2 1 2 0 0 2 0`。

![](https://cdn.luogu.com.cn/upload/image_hosting/8bu0hhke.png)

图中蓝色部分为积水面积，共有 $6$ 个单位面积积水。

## 样例 #1

### 输入

```
10
0 1 0 2 1 2 0 0 2 0
```

### 输出

```
6```

# 题解

## 作者：QQQfy (赞：92)

### 闲聊
本蒟蒻的第一篇题解

这道题一开始死活想不出后来~~在物理课上~~想出来的，激动了好久。。。

一查题解好像没有一样的
    又激动了好久。。。
    
咳咳。。进入正题————
### 算法介绍
#### 1.变量定义与读入
```cpp
int n,//n个数
a[11000],//存每一根柱子的高度
l,r，//这左和右是代表着啥？一会再讲嘿嘿。。
ans=0;//总积水面积，初始为0
cin>>n;
for (int i=1;i<=n;i++) cin>>a[i];
```
#### 2.去掉首尾的前导0和后缀0方便之后处理。
    上文中的l,r表示的其实是有可能积水的有效总区间（包括两头的柱子），l从1起向后找，r从n起向前找。
    这个比较easy，直接放本段代码：
```cpp
l=1;while (a[l]==0) l++;

r=n;while (a[r]==0) r--;
```

#### 3.找到会积水的各个区间并求和（重点！！！）
我们知道，如果一根柱子后面那根柱子比它低，那么这根柱子与后面的某根柱子就有可能积水；

那么问题来了：怎么求“那根柱子”呢？

好问题！

定义：两柱之间有且只有一个连续区间能盛水，这样的两柱与其之间的所有柱子及空间称为“一个能盛水的容器”。

你想啊，一个能盛水的容器的竖直截面大致形状是怎么样的？两边高四周低！（这不是废话吗。。。）
那么！中间的柱子由于比两端低，就可以抽象成是不存在的（事实上并非如此，一会会分析）。

于是，一个能盛水的容器就只有三种了：

##### 1.左柱子低而右柱子高的；

##### 2.左右柱子一样高的；

##### 3.左柱子高而右柱子低的；

（因为中间的柱子无论多高都比左右两柱低，要不然这个容器里就有两个地方可以装水，也就是两个容器，这与“一个能盛水的容器”相悖）

好！这样的话问题就被分解成了三个子问题：
##### 找到这三种容器，并将它们所能装水的总和作为答案输出即可。

那该怎么求呢？

##### 规定：j为目前的左柱子的下标，k为目前的右柱子的下标

其实一二两种容器可以一起考虑。

开始将j定为l,k定为l+1（为什么是l和l+1？看上文！），不断k++，直到找到第一个右柱子大于等于左柱子的（也就是a[k]>=a[j]），计算这时这个容器内能装水的总量，加进ans里。这样就找到了第一个第一（二）种容器，并且区间[l,k)内将不存在第一二种容器。为什么k那里是开区间呢？因为第k根柱子还有可能是下一个第一二种容器的左柱子。

那么怎么计算这个容器内的积水总量呢？

上文提到，容器之中的柱子事实上不能视做不存在的，因为这些柱子也占了空间。（自己手画一个容器就知道以下公式是怎么推出的了）

ans+=min(a[j],a[k]) * (k-j-1) - 中间柱子总空间（定义为tmp）//前面的那个乘积式实际上是个矩形，你要是画了图的话一下就能发现。只要在每次推进k时tmp+=当前a[k]，就能同时算出tmp，减小了复杂度。

到此，我们终于结束了第一个容器，这时就要来看看接下来的了。
其实只要j=k;k++;重新更新左柱子和右柱子的下标，搜索后面的部分，直到k比r大为止。

以下是第一二种容器的求法。

```cpp
int tmp=0,j=l,k=l+1;
while (k<=r+1)
	if (a[k]<a[j])
	{
		tmp+=a[k];
		k++;
	}
	else
	{
		ans+=(k-j-1)*a[j]-tmp;//公式
		tmp=0;//记得刷新成0便于以后再记录
		j=k;
		k++;
	}
```

##### 规定：j为目前的右柱子的下标，k为目前的左柱子的下标//改过了哦

那么第三种容器如何求？如果仍按上面的循环顺序，将不能判断出正确的区间（可以用7 5 2 4 5 1 6模拟看看）

这时我们可以使用倒序的技巧。

如果从后往前搜，那么左柱子高于右柱子的情况就变成了右柱子高于左柱子的情况。

（这或许有些难理解？对搜索来说，实际上没有左右，只有先后之分，从后开始按上面的方法搜，第一个搜到的区间对搜索来说和上面一样，是前面的柱子低于后面的柱子，而由于是倒搜，前柱子实际上是右柱子，后柱子实际上是左柱子，也即：左柱子高于右柱子。只是为了避免重复，这个倒搜中k--及tmp+=a[k]（倒搜嘛）的条件应改为a[k]<=a[j]）

于是第一二种容器的循环基本复制一遍。。。
```cpp
	tmp=0;j=r;k=r-1;//倒搜嘛
	while (k>=l-1)
		if (a[k]<=a[j])//注意条件
		{
			tmp+=a[k];
			k--;
		}
		else
		{
			ans+=(j-k-1)*a[j]-tmp;
			tmp=0;
			j=k;
			k--;//倒搜！逆推进！
		}
```
最后输出答案即可。

#### 4.正确性分析

由于所有能装水的容器有且只有这三种，正搜只找到并找全了一二两种，而倒搜时只找到并找全了第三种，故它们的和即为答案，不会重复，不会遗漏，完美！

#### 5.完整代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
	int n,a[11000],l,r,ans=0;
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	//去0
	l=1;while (a[l]==0) l++;
	r=n;while (a[r]==0) r--;
	//正搜
	int tmp=0,j=l,k=l+1;
	while (k<=r+1)
		if (a[k]<a[j])
		{
			tmp+=a[k];
			k++;
		}
		else
		{
			ans+=(k-j-1)*a[j]-tmp;
			tmp=0;
			j=k;
			k++;
		}
	//倒搜
	tmp=0;j=r;k=r-1;
	while (k>=l-1)
		if (a[k]<=a[j])
		{
			tmp+=a[k];
			k--;
		}
		else
		{
			ans+=(j-k-1)*a[j]-tmp;
			tmp=0;
			j=k;
			k--;
		}
	cout<<ans;
	return 0;
}
```

#### 6.时间复杂度
由于根本没有二重循环，循环体也相对简单，时间复杂度O(3n)=O(n)，事实证明，我是全部0ms过的。

#### 7.心灵鸡汤

当从起点看去遥遥无期时，从终点看去可能触手可及！

不仅在OI里，更在生活中！

与大家共勉！


---

## 作者：ResidualNight (赞：63)

### 这一题其实有一种较优解法

如果数据左右两边比较高，中间就不用判断，里面就是所有填水，比如这个数据：0 8 0 1 2 0 2 7 0
![](https://cdn.luogu.com.cn/upload/pic/16898.png)
看看这个五毛图理解一下？不要太挑剔，毕竟是画图出品（逃

这样我们就可以找出两边最大值里的最小值来判断，去除当前的砖块高度就可以得到一列的水高
```cpp
#include<bits/stdc++.h>
//万能头大法好
using namespace std;
int main()
{
	int a[10001]={0},l[10001]={0},r[10001]={0},n,sum=0; //数组清零&定义n和答案
    //a用来储存原数据，l用来储存从左到右的最大值，r用来储存从右到左的最大值
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i]; //读入原数据
		l[i]=max(l[i-1],a[i]);
        //这里很重要！这是至i为止左边最高的高度
	}
	for(int i=n; i>=1; i--)
		r[i]=max(r[i+1],a[i]);
        //至i为止右边最高的高度
	for(int i=1; i<=n; i++)
	{
		if(min(l[i],r[i])-a[i]<0) sum+=0;
        //如果为负数，则说明当前的比较高，不可能积水，所以把0加上/或者不加0
		else sum+=min(l[i],r[i])-a[i];
        //因为只能积水到最低的高度处，所以用min。然后再减掉原来的高度，就可以等于i处砖块以上水的面积，如果是0的话也不用特判~
	}
	cout<<sum; //输出一下答案
	return 0;
}
```

---

## 作者：神之影 (赞：44)

看了下别人的题解，我觉得都比较复杂，在与zxjk大神讨论中想到了一个超级牛逼的方法
# 注意，前方高能 
我们发现了一个奇葩的公式：积水面积就是可能积水的面积减去石柱的体积。
## 什么是可能积水的面积呢？
看下样例：
![](https://cdn.luogu.com.cn/upload/pic/117.png)

### 10

### 0 1 0 2 1 2 0 0 2 0
第一层的可能积水面积就是第一层从头到尾有几块，图中第一层有九块。
所以算法实现就成了这样：
# 1：输入

```cpp
#include<algorithm>
using namespace std;
int a[10001],maxx=-1;//a是输入，maxx是最大高度
int main()
{
	int n,ans=0,s=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		maxx=max(maxx,a[i]);
		s+=a[i];
	}
```
# 2：一层层分析
```cpp
	for(int i=1;i<=maxx;i++)
	{
		int head=1,tail=n;
		while(a[head]<i)
		head+=1;
		while(a[tail]<i)
		tail-=1;
		ans+=tail-head+1;
	}
```
# 3：输出
	cout<<ans-s;
	return 0;
}

这就ok啦
by 以为马上考noip的小蒟蒻


---

## 作者：Pengsibo (赞：30)

呵呵，第（~~2~~）1次提交题解（~~第一次没过~~）。。。

为了防止大家直接复制代码，我在代码里加了一些bug。。。请直接复制的人不要小心QAQ

当时老师讲的方法是从左边一直搜到右边，后来觉得好麻烦，于是自己想了想，改成了从上往下搜。


------------

简单的说，就是先开单重循环，输入那列的高度，如果是0就不管，否则在循环里再加一个循环，开一个二维数组（当然，在外面开）（表示每个格子有没有方块），把这一列的每一个有方块的格子对应的二维数组值记为1（当然，没有方块则记为0）。每次输入时记录最大值，最后保存最高高度。
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <iomanip>
using namespace std;

int n,h;
int x[10002][5002],maxx=-1;

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
	{
		scanf("%d",&h);						//h表示高度
		if (h==0) continue;					//为0则跳
		for (int j=1;j<=h;j++) x[i][j]=1;	//否则记录每一个方块
		if (h>maxx) maxx=h;					//保存最高高度
	}
}
```

好了我们继续。先上一个while，只要现在判断高度（从最高高度起）不为0，我们就搜这一层，搜完了就降低高度直到为0。while里加一个for（从左起到右），如果现在搜的这一格的值为1（是墙）则跳，否则判断是否左右边都有墙，如果都有则判断可积水，ans++

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <iomanip>
using namespace std;

int n,h;
int x[10002][5002],maxx=-1;
int ans=0;

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
	{
		cin>>h;
		if (h==0) continue;
		for (int j=1;j<=h;j++)
		x[i][j]=1;
		if (h>maxx) maxx=h;
	}										//前面已将
    
	while (maxx>0)							//层数不为0
	{
		for (int i=1;i<=n;i++)				//从左到右
		{
			if (x[i][maxx]==1) continue;	//有方块则跳
			left(i);						//判断左右有无方块
			right(i);
			if (flag1==1&&flag2==1) ans++;	//如果都有则ans++
		}
		maxx--;								//搜完，层数--
	}
}
```

好了我们讲讲怎么判断左右有没有方块。首先要判断一下越界没，该格子的横坐标为a，（纵坐标为maxx，或是高度）减数为b（从1开始递增），如果a-b大于零（没越界）或a-b的格子为1（我写的a-b>a，效果一样）则flag为true并返回，否则b++。
```
void left(int a)
{
	int b=1;					//b为减数
	while (a-b>0)
	{
		if (x[a-b][maxx]>x[a][maxx]) {flag1=1;return;} //见解释
		b++;					//减数++
	}
	flag1=0;
}
```

你懂得，往右搜同理，只是减数变加数，减法变加法，0变为n
```
void right(int a)
{
	int b=1;
	while (a+b<n)			//减变加，0变n
	{
		if (x[a+b][maxx]>x[a][maxx]) {flag2=1;return;}
		b++;				//加数++
	}
	flag2=0;
}
```
最后一步输出。

当然，这道题的数据比较水，我2个双重循环都没炸时间，如果数据再大一些可能还得用上记忆化。。。

最后附上全篇代码
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <iomanip>
using namespace std/;

int n,h;
int x[10002][5002],maxx=-1;
int ans=0;
int flag1,flag2;

void left(int a)
{
	int b=1;
	while (a-b>0)
	{
		/if (x[a-b][maxx]>x[a][maxx]) {flag1=1;return;}
		b++;
	}
	flag1=0;
}

void right(int a)
{
	int b=1;
	while (a+b<n)
	{
		if (x[a+b][maxx]>x[a][maxx]) {flag2=1;return;}
		b++;
	}
	flag2=0;/
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
	{
		cin>>h;
		if (h==0) continue;
		for (int j=1;j<=h;j++)
		x[i][j]=1;
		/if (h>maxx) maxx=h;
	}
	while (maxx>0)
	{
		for (int i=1;i<=n;i++)
		{
			if (x[i][maxx]==1) continue;
			left(i);
			right(i);
			if (flag1==1&&flag2==1) ans++;/
		}
		maxx--;
	}
	printf("%d",ans);
	return 0;
}

```
谢谢大家。。求赞

---

## 作者：静静是我的， (赞：20)

## 题目：[[P1318 积水面积]](https://www.luogu.org/problemnew/show/P1318)

本题用$O(3n)$方法,题解中没有的方法。

首先，我们先找出算出水的面积的方法

![题目](https://cdn.luogu.com.cn/upload/pic/117.png)

| Num | water | MaxLeft | MaxRight | tall |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 3 | $1$ | 1 | 2 | 0 |
| 5 | $1$ | 2 | 2 | 1 |
| 7 | $2$ | 2 | 2 | 0 |
| 8 | $2$ | 2 | 2 | 0 |

### 不难发现，某个位置上的水的高度=min(左边最高的,右边最高的)-立方体的高度

这是因为万有引力把水给困住了，左边最高的和右边最高的组成一个有水范围，且**水的深度是min(左边最高的,右边最高的)**。

画个图可以简单了解。

![right](https://cdn.luogu.com.cn/upload/pic/40293.png)
![wrong](https://cdn.luogu.com.cn/upload/pic/40294.png)



------------

因为$n<=10000$，所以用普通的查找是用$O(n*n)$.

但是我们可以用优化算法把时间压缩到$O(2*n)$.

方法：
```cpp
    for (int i=1;i<=n;i++)   //记录左边最高的
    {
    	f[0][i]=Max;
    	Max=max(Max,a[i]);   //防止把自己记为最高
    }
    Max=0;
    for (int i=n;i>=1;i--)   //记录右边最高的
    {
    	f[1][i]=Max;
    	Max=max(Max,a[i]);   //防止把自己记为最高
    }
```



------------

最后计算，在上文提出了   某个位置上的水的高度=min(左边最高的,右边最高的)-立方体的高度

聪明细心的人会发现 **这个关系式可能会变为负数**，所以我们要保证加的数为非负数。

```cpp
    for (int i=1;i<=n;i++)
    if (min(f[1][i],f[0][i])-a[i]>0)   //控制非负数进入
    ans+=min(f[1][i],f[0][i])-a[i];
    cout << ans;
```



------------
程序：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[10001],f[2][10002],ans,Max;
int main()
{
    cin >> n;
    for (int i=1;i<=n;i++)
    cin >> a[i];
    for (int i=1;i<=n;i++)
    {
    	f[0][i]=Max;
    	Max=max(Max,a[i]);
    }
    Max=0;
    for (int i=n;i>=1;i--)
    {
    	f[1][i]=Max;
    	Max=max(Max,a[i]);
    }
    for (int i=1;i<=n;i++)
    if (min(f[1][i],f[0][i])-a[i]>0)
    ans+=min(f[1][i],f[0][i])-a[i];
    cout << ans;
	return 0;
}
```

照这个方法做会更清晰，更容易理解。

---

## 作者：mulberror (赞：15)

我写一篇绝对原创的题解，算法原创，求洛谷通过！！！（让更多人看到这篇题解）

安利一下自己的[博客](https://www.cnblogs.com/Dawn-Star/p/9846125.html)

-----
## 绝大多数人肯定认为这道题是一道模拟题
### 以下为正解

我们来看一下这一道题，其实就是找到左右高点，在模拟。

但是这个是正常人的想法，现在我来将一个非正常人的做法。

# 算法的名字叫做最小生成树？！
**注：虽然这个算法不叫歪解 ~~滑稽~~**

是不是非常的神奇？？？（我是看到没有人写这种题解才写的，如果有大佬在我之前就已经想到了，那么我也就只能%%%了）

我这里有一道关于这个题目的二维版，召唤传送门：[传送](https://www.luogu.org/problemnew/show/U42937) 本人不喜欢~~懒~~开个人公开赛，所以这个题目也在洛谷的题库中没有上传。。。

----
好了！我们回到正题！

我们先讲一下算法步骤，在解释！
# 算法步骤
我们设置一个0号节点，作为我们最小生成树的虚拟根节点，这样我们就只需要找到关于0号节点的最小生成树。然后在0号节点和两端的1号节点和n号节点建一条长度为1和n的高度的边，这个时候我们只需要建立单向边就可以了，因为这个边只是供给我们计算最小生成树用的。

接着我们在从(2~n-1)这个之间，每两个块都直接建一条边，这个边长为两个块之间较高的高度。建完全部的边，那么我们就做一遍最小生成树，这个生成树的根节点是0。然后我们将这个最小生成树进行一次遍历，算出从根节点到每个节点的路径的上的某一条路的上的最大值，这个最大值作为dist[i]，然后我们计算我们的答案就是dist[i]在减去原来的高度。

# 算法解释
其实我们就只是在模拟水流。根据牛顿万有引力定律，这个H2O呢？一定会向着地球靠近，算了也不讲了！也就是说我们需要找到一条路径这个水能从最高的地方流下来，因为水一定是往低的而且是在自己旁边的地方留出去，所以这就使得我们可以用最小生成树来做这一道题。

再说的简单一点，我们需要找到一条路使得我们的水流能只上升最短的高度就流出去。为什么？其实也和贪心有一点相似，因为如果你要积水一定是积到某个边缘部分，而且肯定不会再上升，所以我们需要在找到一条能跑到边缘的路，而且这个路的高度总和最小。

根据以上的特性，我么就可以想到一个算法，可以解出图上的所有点到某个点的总距离和最短，那么就是最小生成树了。

而如果有人要问这个0号节点的实际意义，其实也是有的，我觉得应该是包含边缘的全部的节点。

### 但是为什么我们最小生成树跑出来的答案并不是直接的答案？
because，我们建的边只是最大值，所以我们得到的这个答案就只是我们水流流进来可以跨越的合法最大高度，所以要积的水就是现在算出的的答案在减去我们原来的高度。

以下提供AC代码：
```cpp
#include <bits/stdc++.h>
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
const int Maxn=10005;
struct Edge{
    int u,v,w;
    bool operator <(const Edge a)const { //重载运算符，这样再排序的时候就不用写cmp了
        return w<a.w;
    }
}edge[Maxn];
struct Edge2{
    int to,next,w;
}edge2[Maxn<<1];
int head[Maxn],fa[Maxn],h[Maxn],dist[Maxn];
int vis[Maxn],nedge,Nedge,n;
inline int read() {//快读
    int w=0,x=0; char ch=0;
    while (!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while (isdigit(ch)) {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return w?-x:x;
}
inline int Min(int n,int m) {return n<m?n:m;}
inline int Max(int n,int m) {return n>m?n:m;};
inline void Add_Edge (int u,int v,int w) {edge[++Nedge] =(Edge ){u,v,w};}//第一次加边
inline void Add_Edge2(int u,int v,int w) {edge2[nedge]=(Edge2){v,head[u],w};head[u]=nedge++;}//第二次加边
inline int gf(int x) {return fa[x]==x?fa[x]:fa[x]=gf(fa[x]);}//并查集查找祖先+路径压缩
inline void dfs(int k,int maxlong) {//暴力查询
    for (int i=head[k];i!=-1;i=edge2[i].next) {
        if (vis[edge2[i].to]) vis[edge2[i].to]=0,dist[edge2[i].to]=max(maxlong,edge2[i].w),dfs(edge2[i].to,dist[edge2[i].to]);
	}
}
int main() {
    n=read();
    for (int i=1;i<=n;i++) h[i]=read(),fa[i]=i; fa[0]=0;
    Add_Edge(0,1,h[1]),Add_Edge(0,n,h[n]);//建虚拟边
    for (int i=2;i<n;i++) Add_Edge(i,i-1,Max(h[i],h[i-1])),Add_Edge(i,i+1,Max(h[i],h[i+1]));//继续建边
    sort(edge+1,edge+1+Nedge);//排序
	ms(head,-1);//这个head数组
    int cnt=0;
    for (int i=1;i<=Nedge;i++) {
        int ance1=gf(edge[i].u),ance2=gf(edge[i].v);
        if (ance1!=ance2) {//最小生成树
			fa[ance1]=ance2;//合并
			cnt++;//节点个数+1
			Add_Edge2(edge[i].u,edge[i].v,edge[i].w);
			Add_Edge2(edge[i].v,edge[i].u,edge[i].w);//这里要建双向边。
		}
		if (cnt==n) break;//也为有一个虚拟点，所以我们要到n的时候在结束
    }
    for (int i=1;i<=n;i++) vis[i]=1; vis[0]=0; dfs(0,0);//暴力求解到根节点的路径上的最大值
	int ans=0;
    for (int i=1;i<=n;i++) ans+=dist[i]-h[i];//算出我们需要的答案
	printf("%d\n",ans);
    return 0;
}
```

---

## 作者：王钰翔 (赞：9)

### 我的想法:一层一层的水量累加,记录初始位置,终止位置,个数。
#### sum=终止位置-起始位置-个数+开始和结束位置的点-1
#### 第一层:
![](https://cdn.luogu.com.cn/upload/image_hosting/7t8faer8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
#### 第二层:
![](https://cdn.luogu.com.cn/upload/image_hosting/vyhl5i0d.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100000];
int f[100000][5];
int n;
int maxx,sum;
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		for(int j=1; j<=a[i]; j++) { // 从第一层到最高全部要执行
			f[j][1]++; // 个数加一 
			if(f[j][1]==1) { // 标记第一个数位置 
				f[j][2]=i;
			}
			f[j][3]=i; // 找最后一个数的位置 
		}
		if(a[i]>maxx) {
			maxx=a[i]; // 找最高的位置 
		}
	}
	for(int i=maxx; i>=1; i--) {
		if(f[i][1]>1) { // 至少要两个高处才能储水 
			sum+=f[i][3]-f[i][2]-f[i][1]+1; // 算出水的体积 
		}
	}
	cout<<sum;
}

```


---

## 作者：JamlainHamstone (赞：4)

逛了一圈看见没有大佬和我思路一样，于是赶紧来写下题解

~~可能是字符串做多了吧……~~

简单阐述一下吧：

我们先来看几张样例变形后的图（图就不要太挑剔了，毕竟是画图出品，我尽力了）：

思路：

**~~逆向思维大法好啊！~~**

我们可以把整个图形中不能积水的地方全部都标记出来，这样剩下的地方就是能积水的啦！

**具体操作**

生成初步的图形就不说了，玩玩全全的生成垂直柱状图，有方块的是不可能积水的啊

1.顺旋转90度以后，我们垂直向下将没有本来不存在的方块补上，直到遇见了第一个这一列存在的方块就停止这一列的补空，于是图就成了这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/v426uoit.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

2.同理，逆时针旋转90度后补空就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/ludoyqqs.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

3.最后再把两张图综合一下，就得到了一个完整的矩形：

![](https://cdn.luogu.com.cn/upload/image_hosting/pvurdo53.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

4.这个时候题目就变得非常简单了，我们只需要遍历整个矩形，找到没有方块的地方的个数，这个个数就是积水的面积了。

上面是做法，思考了一下为什么可以这样做：

1.其实补上空缺的方块就相当于是把不积水的地方给排除掉，剩下的就是能积水的地方

2.垂直向下补空，直到遇见第一个原本就存在的方块（可以把旋转后的图形当成一个建筑，下雨的时候，被楼上遮盖的地方是不会淋雨的），这样自然就不会把中间的凹槽给补上。两侧都如此操作一下，就可以排除所以不积水的地方啦！

我们就用一个字符数组来储存。

下面代码实现就很简单了，注释都在代码中了，不能积水的地方用‘*’表示（其实用什么表示都差不多），可以积水的地方就是空的

```
#include<bits/stdc++.h>
using namespace std;
int n,s[10005],tot=0,h=0;//s是每个位置上方块的高度，tot计数，h为整个矩阵的高度
char mp[10005][5005];//储存整个矩阵中每个位置的状态
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s[i];
		h=max(h,s[i]);//记录下摞的最高的方块，方便生成最初的图形
	}
	for(int i=h;i>0;i--){//从最高高度开始往下依次储存
		for(int j=0;j<n;j++){
			if(s[j]>=i) mp[i][j]='*';//高度够高，就储存‘*’和生成垂直柱状图类似
		}
	}
	for(int i=h;i>0;i--){//从最高高度开始往下依次补空（从下到上也可以）
		for(int j=0;j<n;j++){//从左到右补空
			if(mp[i][j]=='*') break;//遇到原来就有方块的地方就停止补空
			else mp[i][j]='*';
		}
	}
	for(int i=h;i>0;i--){//和上面同理
		for(int j=n-1;j>=0;j--){//从右到左补空
			if(mp[i][j]=='*') break;
			else mp[i][j]='*';
		}
	}
	for(int i=h;i>0;i--){//开始进行统计
		for(int j=0;j<n;j++){
			if(mp[i][j]!='*') tot++;//如果不是积不了水的地方就计数
		}
	}
	cout<<tot;//输出
	return 0;
} 
```

---

## 作者：Zhou_SY (赞：4)

从[讨论](https://www.luogu.org/discuss/show/155194?page=1)里来的

1. 先找到最高且最靠两边的柱子，记为坐标l,r

2. 分区间考虑：[ 1 , l ) , [ l , r ] , ( r , n ]

3. 当然[ l , r ]这个区间最好考虑，区间内的高柱子减去每根的柱子的高度就是这个区间积水的面积，先做掉
4. 接着做左右两个区间，以[ 1 , l )为例，先找到这个区间里的最高的柱子，记为p，则又分成了两个区间[ 1 , p ) , [ p , l ] ，后者同3.，不过被减的是那根短柱子p而不是l，前者以4.的方法递归执行直至区间为空即1==p，区间[ 1 , l )的值就是两者相加，我们就写出了solve_1 ; ( r ,n ]也类似写出solve_2 ;

```cpp
#include<bits/stdc++.h>
using namespace std;
int x[10010],n,sum;
int solve_1(int r)
{
	if(1==r)return 0;
	int maxn=0,p,tmp=0;
	for(int i=1;i<r;i++)
	if(x[i]>=maxn)
	{
		maxn=x[i];
		p=i;
	}
	for(int i=p+1;i<r;i++)tmp+=maxn-x[i];
	return tmp+solve_1(p);
}
int solve_2(int l)
{
	if(l==n)return 0;
	int maxn=0,p,tmp=0;
	for(int i=l+1;i<=n;i++)
	if(x[i]>=maxn)
	{
		maxn=x[i];
		p=i;
	}
	for(int i=l+1;i<p;i++)tmp+=maxn-x[i];
	return tmp+solve_2(p);
}
int maxn,l,r;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&x[i]);
	
	for(int i=1;i<=n;i++)
	if(maxn<=x[i])maxn=x[i],r=i;
	for(int i=1;i<=n;i++)
		if(x[i]==maxn){l=i;break;}
	
	for(int i=l;i<=r;i++)sum+=maxn-x[i];
	sum+=solve_1(l);
	sum+=solve_2(r);
	printf("%d",sum);
}
```

---

## 作者：Dcue (赞：3)

**一个只会用stl的蒟蒻题解**  
**stack的写法应该算简单的吧**
------------
**1.又题意可知：只有一个水洼的体积由最小边决定，木桶效应嘛**  

**2.所以可是搞一个栈结构的玩意进行高柱储存，当又遇到一个大于等于当前最高柱的柱子进行面积的叠加，想一想，可能最右边的柱子没有左边的纳米高，然后，水就从右边流走了，所以是又遇到一个大于等于的柱子才进行面积叠加，不然，就存在暂时的面积h里面了**  

**3.当最右边不配对时，从右往左边的最高值进行补漏**

然后，代码看注释
------------

```
#include<iostream>
#include<cstdio>
#include<string>
#include<stack>
#define MANX 10500
using namespace std;
stack<int> s;
int l[MANX];
int n,a,ans=0,h,sp,maxh;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		l[i]=a;		//先存一下，后面要用
		if(s.empty()&&a!=0){	//将有高度的柱子放进去
			s.push(a);		
		}
		else if((!s.empty()&&a>=s.top())){	//进行面积的一次总结
			s.pop();
			s.push(a);
			ans+=h;
			maxh=a;			//存下最高峰的高度
			h=0;
			sp=i;			//存下最高峰的位置，为从右往左搜做准备
		}
		else if(!s.empty()){	//没到右边柱，进行叠加
			h=h+(s.top()-a);
		}
	}
	while(!s.empty()) s.pop();	//清栈
	h=0;						//一定要清零，wa了一次...
	if(l[n]<maxh){				//当最右边的不能与左边的柱子配对时，从右往左搞一下
		for(int i=n;i>=sp;i--){
			a=l[i];
		if(s.empty()&&a!=0){
			s.push(a);
		}
		else if((!s.empty()&&a>=s.top())){
			s.pop();
			s.push(a);
			ans+=h;
			h=0;
		}
		else if(!s.empty()){
			h=h+(s.top()-a);
		}
	}
	}
	cout<<ans<<endl;
	return 0;
}
```
**最后，浅知拙见，忘大佬前来更正**

---

## 作者：☆La™塩鱻© (赞：3)

## FIRST
## ##### ### 这是本蒟蒻的第一篇题解##### 
#### ## 望各位大佬见谅# 


------------     

## SECOND

#### ###### ## 进入正题La## #### 

```cpp
#include<cstdio>
using namespace std;

int maxx,ans;

int a[10010];
int n,l,r;

int max(int a,int b)

{
	
    if (a > b)
		return a;
	return b; 
}

int main()

{

   	scanf("%d",&n);
    for (int o = 1;o <= n;o++)
	{
        scanf("%d",&a[o]);
        maxx = max(maxx,a[o]);//找到最高的那一根 
    }
    for (int i = 1;i <= maxx;i++)//从最低处到最高处一层层往上找 
	{
        for (int o = 2;o <= n - 1;o++)//从左找起 
            if (a[o] >= i)//找到最左边第一个有柱子的 
			{ 
				l = o;
				break; 
			}
        for (int o = n - 1;o >= 2;o--)//从右找起
            if (a[o] >= i)//找到最右边第一个有柱子的
			{ 
				r = o;
				break; 
			}
        for (int o = l;o < r;o++)//在最左与最有之间找（模拟）
            if (a[o] < i)//只要有一个高度低了，加一块水柱  
				ans++; 
    }
    printf("%d",ans);
    return 0;
}

------------# 代码如上



---

## 作者：LuxLover (赞：2)

让我们先观察一下图片，捋一捋思路

![](https://cdn.luogu.com.cn/upload/pic/117.png)

我们发现，一个点想要有积水，肯定要有比它高的格子

而我们思考下：为什么第二个格子明明有比它高的，为什么没积水呢？原来，比它高的只有右边有，左边却没有

小总结：想有积水，左边和右边都要有比它高的

再看看，发现积水高度=min{左边,右边}-这个格子的高度

有了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r,lmax,rmax,s;
int a[10005];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
      scanf("%d",&a[i]);
    }
    for(int i=2;i<n;i++)
    {
        lmax=rmax=0;
        for(int j=1;j<i;j++) lmax=max(lmax,a[j]);//求左边最高  
        for(int j=i+1;j<=n;j++) rmax=max(rmax,a[j]);//求右边最高
        if(min(rmax,lmax)>a[i]) s+=min(rmax,lmax)-a[i];  
    } 
    cout<<s;
    return 0;
} 
```
进阶思考，当n=100000时怎么办？

我们可以预先用数组推一遍，把最值计算好，再循环一遍过来用

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005],b[100005],c[100005];
int main()
{
    int n,s=0;
    cin>>n;
    for(int i = 1;i <= n; i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        b[i]=max(b[i-1],a[i]);//最大值=max{上一个的最大值,这个格子的高度}
    }
    for(int i=n;i>=1;i--)
    {
        c[i]=max(c[i+1],a[i]);//最大值=max{后一个的最大值,这个格子的高度}
    }
    for(int i=1;i<=n;i++)
    {
        if(a[i]<min(c[i],b[i])) s+=min(c[i],b[i])-a[i];//计算结果直接用
    }
    cout<<s;
    return 0;
}

```
有兴趣可以做做:[TT算面积](http://oj.jzxx.net/problem.php?id=3560)

---

## 作者：tututu (赞：2)

楼下的题解长度也是醉了

# 真心好算法

把数据读入

然后维护一个单调栈q，w是栈顶指针（都算不上维护，就是这样）

维护时进行累加面积

# 时间效率O(N) 空间O(N)

空间非要说2N我也不介意

```cpp
var
  n,i,h,w,s,w1:longint;
  a,q:array[-1..10002] of longint;
begin
  readln(n);
  for i:=1 to n do
    read(a[i]);
  for i:=1 to n do
    begin
      h:=a[q[w]];//h表示当前以处理高度（可以理解为填平到的高度）
          w1:=w;//仅仅是标记w是否改动
      while (a[q[w]]<=a[i]) and (w>0) do
        begin
          s:=s+(a[q[w]]-h)*(i-q[w]-1);//累加面积，即填平到与栈顶的元素的高度，(a[q[w]]-h)是此次填平的图形（矩形）的高度，(i-q[w]-1)是宽度
          h:=a[q[w]];//最大填平高度
                  dec(w);//-1
        end;
      if (w>0) and (w<w1) then s:=s+(a[i]-a[q[w+1]])*(i-q[w]-1);//有特例，就是只能填到当前栈顶的中间而无法整个填掉，因为i的高度就这么点没办法
      inc(w);//入栈
      q[w]:=i;
    end;
  write(s);
end.
```

---

## 作者：X_WT (赞：1)

~~自己yy的思路~~

首先当然看一下数据范围：0<=x<=5000 3<=n<=10000

似乎**暴力一点**也可以过诶 ~~（但是最后速度好像还可以~~

### 思路大致如下：
a[ i ]表示下标为i的高度

k表示最大高度

进行一次for循环，枚举每一个高度，看看这个高度的能装多少水，ans累加就好

last表示上一个达到i高度的格子坐标

上代码叭：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,k,ans,last;
int a[10010];
inline int maxn(int a,int b){return a>b?a:b;}
//自己敲的max函数（假装会快）
int main(){
	scanf("%d",&n);
	for(register int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		k=maxn(k,a[i]);//最大的高度
	}
	for(register int i=1;i<=k;++i){
		for(register int j=1;j<=n;++j){
			if(a[j]>=i){
				last=j;break;
			}//找第一个达到i高度的格子
		}//跳出这个寻找格子的语句
		int m=last;//好像没什么用（大雾
		for(register int j=m+1;j<=n;++j){
			if(a[j]>=i){//如果这个格子高度超过i，可以和前面last合起来装水
				ans+=j-last-1;
				last=j;//新的格子
			}
		}
	}
	cout<<ans;
	return 0;
}
```

不太理解的可以私信qwq

我不会告诉泥萌我第一次把
```cpp
ans+=j-last-1;
```
写成
```cpp
ans+=j-last-i;
```
还傻呵呵地调了一刻钟

---

## 作者：RedreamMer (赞：1)

## P1318 积水面积
#### 首先，我想到，对于一个高为$x$的柱子$i$，在以$i$为左端点的积水区域，它积水的高度最大是$x$，往右不断往右寻找一个柱子，如果一根柱子$j$的高度大于目前寻找的总高度，那么一定会产生积水现象。
#### 如果小于等于目前寻找的总高度，可能会出现积水现象，但是我们把它归为另外区间的积水现象。
```
for(int i=1;i<=a;i++){
	for(int j=i+1;j<=a;j++){
		if(s[j]>mx){//如果一根柱子的高度大于目前寻找的总高度
			som+=(s[j]-mx)*(j-i-1);//将它的与左端点距离乘与之前最高的柱子的高度差得到积水面积
			mx=s[j];//更新目前最高
		}
	}
	mx=0;
}
```
#### 但是如果有一个柱子比当前最高的柱子高，也比那根左端点的柱子高，则需要特判，因为左端点构造不成一个太高的积水现象。
```
if(s[j]>s[i]){//判断是否大于左端点
	som+=(s[i]-mx)*(j-i-1);//直接用左端点与之前最高作差再乘距离之差
}
```
#### 得到代码：
```
#include<bits/stdc++.h>
using namespace std;
int a,mx,som;
int s[10001];
int main(){
	scanf("%d",&a);
	for(int i=1;i<=a;i++)
	scanf("%d",&s[i]);
	for(int i=1;i<=a;i++){
		for(int j=i+1;j<=a;j++){
			if(s[j]>mx){
				if(s[j]>=s[i]){
					som+=(s[i]-mx)*(j-i-1);
				}
				som+=(s[j]-mx)*(j-i-1);
				mx=s[j];
				if(mx>=s[i])//进行特判加快速度
				break;
			}
		}
		mx=0;
	}
	printf("%d",som);
	return 0;
}
```
#### 其实本题已有大佬说出了$O(n)$的做法，但本人懒得写，因为数据太水

---

## 作者：aiyougege (赞：1)

Interesting!

以前搞过一道二维的类似的题, 今天竟然遇到一维的啦!

![](https://i.loli.net/2018/08/11/5b6e8be48d905.png)

**降维打击真是美滋滋**
### Solution
下面的做法同时适用于二维的情况:

- 首先把边界中的点入小根堆, 高度小的先弹出.
- 一个一个从堆中弹出点, 向上下左右扩展, 若高度低于它, 则更新它的高度; 高度高于它, 不管. 两种都入堆.
- 注意: 一个点只能被更新一次, 入堆一次.

想一想, 这个做法为什么正确?
因为一个位置若存放了多余它能力的水, 必定会从某个边界位置流出, 

我们做的就是它的一个类似的逆过程, 而使用小根堆就是为了保证一个点被增加到的高度, 恰好就是它能力的最大值.

想一想木桶效应, 就知道为什么要使用小根堆了.

### Code
```c++
#include <algorithm>
#include <stdio.h>
#include <queue>
#include <vector>
using std:: pair;
using std:: vector;
using std:: priority_queue;
const int N = 10005;

struct Node {
	int p, h;
	Node () {}
	Node (int P, int H): p(P), h(H){}
	bool operator < (const Node &o) const {
		return h > o.h;
	}
};

int h[N];
int vis[N];

priority_queue<Node> que;

int main () {
	int n, ans;
	scanf("%d", &n);
	for (int i = 1; i <= n; i += 1)
		scanf("%d", &h[i]);
	que.push(Node(1, h[1])), 
	que.push(Node(n, h[n]));
	vis[1] = vis[n] = true;
	while (!que.empty()) {
		Node top = que.top(); que.pop();
		//printf("%d\n", top.p);
		if (top.p > 1 && !vis[top.p - 1]) {
			if(top.h > h[top.p - 1]) {
				ans += top.h - h[top.p - 1];
				h[top.p - 1] = top.h;
			}
			que.push(Node(top.p - 1, h[top.p - 1]));
			vis[top.p - 1] = true;
		}
		if (top.p < n && !vis[top.p + 1]){
			if (top.h > h[top.p + 1]) {
				ans += top.h - h[top.p + 1];
				h[top.p + 1] = top.h;
			}
			que.push(Node(top.p + 1, h[top.p + 1]));
			vis[top.p + 1] = true;
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：LightningUZ (赞：1)

我是个蒟蒻，O（n）的做法我不会。

但是，请看好数据。10000x5000是**不会**超时的！！！！！

所以我就用了10000x5000的大暴力

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int a[10010];
	int mx=-1;//判断最大高度
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		mx=max(a[i],mx);
	}
	int sum=0;
	int l,r;
	for(int h=1;h<=mx;h++)//每一层枚举
	{
		for(int j=2;j<=n-1;j++)
		{
			if (a[j]!=0) 
			{
				l=j;
				break;
			} 
		}
		for(int j=n-1;j>=2;j--)
		{
			if (a[j]!=0)
			{
				r=j;
				break;
			}
		}
        //l,r找一个区间，用于去掉前，后的0，因为前，后的0是不会积水的，只有中间的会
		for(int j=l;j<=r;j++)//所以要在l~r之间找0
		{
			if (a[j]==0)
			{
				sum++;
			}
		}
		for(int j=2;j<=n-1;j++)
		{
			if (a[j]!=0)
			{
				a[j]--;
			}
		}
        //高度减少，然后就只剩下一层
	}
	cout<<sum<<endl;
	exit(0);
} 
```

---

## 作者：DPair (赞：1)

# 算法（要看代码直接找最下面）

这道题的解法有很多， 甚至可以参考[**P1317**](https://www.luogu.org/problemnew/show/P1317)的暴力解法，这里是一种时间复杂度几乎为**O(n)** ，最坏情况下为 **O(n^2)** 的算法。

# 思路

我们可以思考一下，积水面积是不是由两边最高的柱子决定的范围？比如下面的数据：

```cpp
		0 7 1 0 3 2 3 2 7 0
```

这组数据中，如果用[**P1317**](https://www.luogu.org/problemnew/show/P1317)的算法，会被坑到**TLE**，所以可以直接遍历一遍，先遍历到第一个不为零的数据，再搜索后面柱子中离当前柱子最高的一个柱子，或者是第一个高于或等于当前柱子的柱子，那中间的所有数字都只遍历了一遍，大大减少时间复杂度（我是0ms）。

现在模拟刚才那组数据

先搜索到7，然后一直搜索，直到最后一个7。然后统计中间的所有差值（即地面到水平面的高度），最后输出。

**但是：** 有一点需要注意，如果遍历一遍后发现后面都逐渐变小（或一样），那会消耗很大时间复杂度，比如。

```cpp
		0 1 0 0 0 0 0 0 0 0 
```

或

```cpp
		0 7 6 5 4 3 2 1 0
```

那就可以在发现最高的是当前柱子的下一个时，直接return 0， 万事大吉，不多遍历。

# 代码
```cpp
#include <cstdio>
int n, a[10010], ans = 0;//ans为最后结果,其他你懂得

int main()
{
	scanf("%d", &n);//输入
	for (int i = 1;i <= n;i ++) scanf("%d", &a[i]);
	
	int i = 1, data, num, dat, nu, height;//i是一个指针，指向遍历的变量，data、num是当前柱子的数据与下标，dat、nu分别是最高柱子的数据与下标。
	
	while(a[i] == 0) i ++;//先搜索到首个不为0的数据
	
	while(i < n)//搜索
	{
		height = -1;//蓄水池两侧最低的短板（短板效应）
		data = i;
		num = a[i];
		dat = i+1;
		nu = a[dat];//定义
		if(nu >= num)//如果是平台
		{
			i ++;//遍历下一个
			continue;
		}
		i += 2;//否则搜索应该搜索的
		while(i < n)//遍历后面，找最大值
		{
			if(a[i] > nu)
			{
				dat = i;
				nu = a[i];
				if(a[i] >= num)
				{
					height = num;
					break;
				}
			}
			i ++;
		}
		
		if(dat == data + 1) break;//特判，降低时间复杂度
		else
		{
			if(height == -1)
			{
				height = nu;
				i = dat;
			}
			for (int j = data+1;j < dat;j ++)//蓄水过程，改变答案
			{
				ans += height - a[j];
			}
		}
	}
	printf("%d", ans);//输出
}
```

---

## 作者：CTC050412 (赞：1)

其实想通了的话，本题并不难，关键是要**把二维分为多个一维**（大概就是这个意思，表达能力不太好，见谅！）
本来一看，以为会超时，可能是数据较水吧，用这种方法还挺快的（至少没有超时），下面是程序：
```cpp
#include<bits/stdc++.h>

int n,a[10001],ans,maxnum;

int main(){

	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>a[i];
		maxnum = max(maxnum,a[i]);
	}
	for(int i = 1;i<=maxnum;i++){
		int x = 1,y;
		while(x<=n){
			for(;x<=n;x++)
				if(a[x]>=i) break;
			for(y = x+1;y<=n;y++)
				if(a[y]>=i) break;
			if(x<y&&y<=n&&x<=n) ans+=y-x-1;
			x = y;
		}	
	}
	cout<<ans;
	return 0;
}

```
当然，这里还可以再优化，比如可以把中间x,y连续的部分滤掉，这里只提供一下思路，就不再写了（懒╮(╯﹏╰）╭）
第一次写题解，好紧张o(>﹏<)o
有什么问题或建议欢迎评论~~~

---

## 作者：Phykyer (赞：1)

和楼下大佬思路相同，都是一层一层的找

找到后累加

具体见代码：


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<cctype>
using namespace std;
int main()
{
    int m=0,ans=0,n,l,r,find=0;//m是用来找最大层数,l、r即左右后续会说，find作用后面会讲 
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++)
    {
    cin>>a[i];//输入不多说 
    if(a[i]>m) m=a[i];//循环输入，同时找出最大层数 
    }
    for(int z=0;z<m;z++)//按层数循环 
    {
    for(int i=1;i<n-1;i++)//跳过首尾找，因为题中有写首尾都是0 
    {
        if(a[i]>find)//find根据层数变化而变化用于判断 
        {
            l=i;//找到该层左起高度足够的位置 
            break;//找到就跳出循环 
        }
    }
    for(int j=n-2;j>=1;j--)//一样是跳过首尾 
    {
        if(a[j]>find)
        {
            r=j;//找到该层右起高度足够的位置 
            break;
        }
    }
    for(int k=l;k<r;k++)//找到左右极限位置后在中间找即可 
    {
        if(a[k]<=find)//两边中间只要有空即可积水，不懂可画个图，这里不再解释 
        {
        ans++;//找到答案+1 
        }
    }
    find++;//循环结束一定要将find++否则无法进行下一次循环 
    }
    cout<<ans<<endl;//输出 
    return 0;
}
/*perfect!*/
```

---

## 作者：Youngsc (赞：1)

[Youngsc](http://youngscc.github.io/)


其实不用管谁高谁低，因为都是柱子，所以（i，j）是柱子时，（i，j-1）必定也是柱子，所以我们可以根据高度从高到低，计算出每一种高度实际有多少个地方是不能放水的，并且记录下这些位置中最左端和最右端的位置，此时这两个位置之间除了有柱子而不能放水的地方，其他地方一定都是有水的，我们只需要统计这个值就好，又因为相对于一开始输入的高度来说，两种相邻高度的落差中间的地形一定是一模一样的，所以再用当前值乘以落差高度，最后把这些值累加起来就好，时间复杂度O(n).

## 代码如下


```cpp
# include <algorithm>
# include <iostream>
# include <cstdio>
# include <cstring>
# include <queue>
# include <cmath>
# define R register
# define LL long long
# define db double

using namespace std;

int n,l[10010],r[10010],ans,cnt,pe[10010],sum[10010];

struct pp{
    int x,h;
    bool operator < (const pp a)const {
        return h < a.h;
    }
}hh[10010];

inline void in(R int &a){
    R char c = getchar();R int x = 0,f = 1;
    while(!isdigit(c)){if(c == '-') f = -1; c = getchar();}
    while(isdigit(c)) x = x*10+c-'0',c = getchar();
    a = x*f;
}

int main(){
    // freopen("freefaller.in","r",stdin);
    // freopen("freefaller.out","w",stdout);
    memset(l,127/3,sizeof(l));
    in(n);
    for(R int i=1; i<=n; ++i) in(hh[i].h),hh[i].x=i;
    sort(hh+1,hh+n+1);
    for(R int i=1; i<=n; ++i){
        if(hh[i].h!=hh[i-1].h) pe[++cnt] = hh[i].h;
        sum[cnt]++;
        r[cnt] = max(r[cnt],hh[i].x);
        l[cnt] = min(l[cnt],hh[i].x);
    }

    for(R int i=cnt; i>=1; --i){
        sum[i]+=sum[i+1]; //若存在一个更高高度的柱子，那么这个更高的柱子在当前高度也一定是不能放水的，所以用一个类似前缀的东西。
        l[i] = min(l[i],l[i+1]);//同上
        r[i] = max(r[i],r[i+1]);//同上
        if(sum[i]<=1) continue;//如果只有一个那一定不能积水，直接跳过。
        ans += (r[i]-l[i]+1-sum[i])*(pe[i]-pe[i-1]); //用中间能放水的面积乘以相同地形的高度，再求和。
    }
    cout << ans;
}
```

---

## 作者：用户已注销 (赞：1)

******0ms简单AC的方法******

（其实这道题的N再大一些也是可以的，只要不高精就好了）

时间复杂度：O(N)

---------------------分割线--------------------------------------

首先看题目给的图，很显然在两个峡谷中间会积满水

所以可以先找出最高点（不一定唯一，但是没关系，随便记一个）（代码中的mid）

然后从左向最高点遍历，用一个常数来记之前的最高高度（代码中的high）

如果新搜到的这个点高于之前的最高高度，更新高度

否则，此处就一定可以积水（因为左有high，右有最高点），总答案加上high-num[i]

从右往中搜原理一样（不但原理一样，代码也一样）

然后输出答案就好了

代码中采用了一点短码的小技巧：

直接更新high并加入答案，

如果发生值的更新，新加入的答案一定是0，否则就是正常的答案

（tips：如果你还是新手就按照一步一步的方法来写，不要优化码长，因为这只是用来 zhuang bi 的）

源代码：

```cpp
#include<cstdio>
#define re register
using namespace std;
int max(int a,int b){return a>b?a:b;} 
int main()
{
    int ans=0;
    int num[10001],n;
    scanf("%d",&n);
    for(re int i=1;i<=n;i++) scanf("%d",&num[i]);
    int maxx=num[1],mid=1;
    for(re int i=2;i<=n;i++)
        if(num[i]>maxx)
        {
            maxx=num[i];
            mid=i;//找到最高峰 
        }
    int high=num[1];
    for(re int i=2;i<mid;i++)
    {
        high=max(high,num[i]);
        ans+=high-num[i];
    }
    high=num[n];
    for(re int i=n-1;i>mid;i--)
    {
        high=max(high,num[i]);//这两行代码
        ans+=high-num[i];     //和上文一样 
    }
    return !printf("%d\n",ans);
}
```

---

## 作者：Conical (赞：1)

简单题，没有多难的算法。

根据样例&&生活经验，很容易得出，第i个格子上的积水高度（如果能积水）为它左右边界较小的那个。

这样一来就很好写了，维护一个前缀最大值和一个后缀最大值，跑一趟O（N）即可。

附代码：

```cpp
#include<stdio.h>
#include<iostream>
#define x min(Max_,Max[i])-a[i]
using namespace std;
const int MaxN(10004);
int a[MaxN],Max[MaxN];
int main()
{
          int N,i,Max_(0),Ans(0);
          scanf("%d",&N);
      for(i=1;i<=N;i++)
          {
            Max[i]=max(Max[i-1],a[i-1]);
                    scanf("%d",&a[i]);
      }
          for(i=N;i>0;i--)
          {
                    Max_=max(Max_,a[i+1]);
                    Ans+=x>0?x:0;
          }
          printf("%d\n",Ans);
          return 0;
}
```

---

## 作者：YWY_wys (赞：1)

#统计技巧

- 题解:

**我们对每一个位置考虑他它答案的贡献是多少，并更新答案，即可得到最终答案。**

我们先定义两个变量数组

lmax[i]:i位置左边（包括i）降序最高点

rmax[i]:i位置右边（包括i）升序最高点


那么lmax和rmax的转移方程即为:


lmax[i]=lmax[i-1]>a[i]?lmax[i-1]:a[i]；

rmax[i]=rmax[i+1]>a[i]?rmax[i+1]:a[i]；

那么很容易发现——对于每一个位置来说，上面的积水量**res=min（lmax[i],rmax[i]）-a[i]**;

式子的含义：仔细想想，**min（lmax[i],rmax[i])**其实是此位置所处水坑上界的高度，那么很容易知道这个位置上的积水量即为**min（lmax[i],rmax[i]）-a[i]**；


那么问题至此解决。

再顺一遍思路：

1. 读入

2. 初始化lmax，rmax；

3. 遍历更新答案

4. 输出

- code
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=10005;
int n;
int a[maxn],lmax[maxn],rmax[maxn]; 
void initlrmax(){//初始化l,r数组 
    for(int i=2;i<=n;i++) lmax[i]=lmax[i-1]>a[i]?lmax[i-1]:a[i];
    for(int i=n-1;i>=2;i--) rmax[i]=rmax[i+1]>a[i]?rmax[i+1]:a[i];
}
int calc(){//统计 
    int res=0;
    for(int i=2;i<n;i++) res+=min(lmax[i],rmax[i])-a[i];
    return res;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    initlrmax();
    printf("%d",calc());
}
```

---

## 作者：King_of_gamers (赞：1)

其实一开始写出来打算要超时的，但是这题数据比较水，所以。。。。你懂得

说白了就是要把整个都考虑进去。

另外，感觉都是c++和c的题解，像我们这样的也是真可怜。

```cpp
var
        n,i,ans,x,y:longint;
        a:array[0..100001]of longint;
function min(a,b:longint):longint;
begin
        if a<b then exit(a) else exit(b);
end;
function max(a,b:longint):longint;
begin
        if a>b then exit(a) else exit(b);
end;
function findleft(k:longint):longint;
var
        t:longint;
begin
        if k=0 then exit(0);
        if k=1 then exit(a[k]);
        t:=findleft(k-1);
        t:=max(t,a[k]);
        exit(t);
end;
function findright(k:longint):longint;
var
        t:longint;
begin
        if k=n+1 then exit(0);
        if k=n then exit(a[k]);
        t:=findright(k+1);
        t:=max(t,a[k]);
        exit(t);
end;
begin
        read(n);
        for i:=1 to n do
        read(a[i]);
        a[0]:=maxlongint;
        a[n+1]:=maxlongint;
        ans:=0;
        for i:=1 to n do
        begin
                x:=findleft(i-1);
                y:=findright(i+1);
                inc(ans,max(min(x,y)-a[i],0));
        end;
        writeln(ans);
end.
```

---

## 作者：___Kiro___ (赞：1)

包里听说古吗？这道题，给你们见识下什么叫做暴力。
```cpp
#include<bits/stdc++.h>//开放的洛谷qwq
using namespace std;
int main()
{
	int a[3][3]={0},b[3][3]={0},za,zb,t;
    //其实za,zb没有用
	string gin;
	cin>>gin;
	for(int i=0 ; i<gin.size() ; i++)
	{
		if(i%2==0)
		{
			t=gin[i]-48;
			if(t%3==0) a[(t-1)/3][2]=1;
			else a[(t-1)/3][t%3-1]=1;
		}
		else
		{
			t=gin[i]-48;
			if(t%3==0) b[(t-1)/3][2]=1;
			else b[(t-1)/3][t%3-1]=1;
		}
	}
	if(a[0][0]+a[0][1]+a[0][2]==3||a[1][0]+a[1][1]+a[1][2]==3||a[2][0]+a[2][1]+a[2][2]==3||a[0][0]+a[1][0]+a[2][0]==3||a[2][1]+a[1][1]+a[0][1]==3||a[1][2]+a[2][2]+a[0][2]==3||a[0][2]+a[1][1]+a[2][0]==3||a[2][2]+a[1][1]+a[0][0]==3)
//暴力枚举所有可能性
	{
		cout<<"xiaoa wins.";
		return 0;
	}
	if(b[0][0]+b[0][1]+b[0][2]==3||b[1][0]+b[1][1]+b[1][2]==3||b[2][0]+b[2][1]+b[2][2]==3||b[0][0]+b[1][0]+b[2][0]==3||b[2][1]+b[1][1]+b[0][1]==3||b[1][2]+b[2][2]+b[0][2]==3||b[0][2]+b[1][1]+b[2][0]==3||b[2][2]+b[1][1]+b[0][0]==3)
	{
		cout<<"uim wins.";
		return 0;
	}
	cout<<"drew.";
	return 0;
}
```
虽然暴力，但也蛮不错的。

---

## 作者：yagyagyag (赞：0)

这道题可以和[P1317 低洼地](https://www.luogu.org/problem/P1317)联系在一起，但这题不同的是，因为积水面积要求长和宽，并且有可能是不规则的，因此就会显的更为麻烦。换一种思路：一层层地搜，这样就没有长的干扰了。每次搜出来的面积累加起来，就是本题的答案。而计算这一面积就是P1317低洼地的做法。

处理当前层积水面积的代码

时间复杂度O(x*n)=1e7  稳过

```cpp
int solve()
{
	int l=1,r=0,cnt=0;//l为左指针,r为右指针 
	while (l<=n){//保证l是小于或等于n的 
		if (b[l]>b[l+1]){//如果搜索到当前的高度大于下一个的高度,它就符合了水坑的半个条件 
			r=l;//把当前坐标记为r 
			while (b[r]>=b[r+1] && r<=n) r++;//往右找直到当前高度小于下一个高度 
			if (r>n) break;//当r扑出去的时候就break 
			r++;//跳过去 
			cnt+=r-l-1;//当前这一层的积水面积 
			l=r;//l跳到r 
		}
		else l++;//往下走 
	}
```
主程序代码
```cpp
int main()
{
	cin>>n;
	int max_high=-1;//用max_high记录最高的高度 
	for (int i=1;i<=n;i++)
		scanf("%d",a+i),max_high=max(max_high,a[i]);
	int ans=0;
	while (max_high--){//从上往下切 
		for (int i=1;i<=n;i++)
			b[i]=bool(max(0,a[i]--)/*防止减到负数*/);//强制转换，若高度为0，则b[]当前数组高度为0，否则为1 
		ans+=solve();//进行一波操作 
	}
	printf("%d",ans);//输出 
	return 0;
}
```

//抵制抄袭，健康洛咕


---

## 作者：Richard21477 (赞：0)

## P1318 积水面积
### **蒟蒻的第二篇题解**
##### 这道题~~比较难但不算太坑~~，提交了两遍就过（两遍？）
#### 说说我的心路历程：
### 想法一：
### 非常简单！非常简单！
#### 每一层都枚举，从左到右扫一遍，
###### 每层积水右坐标-左坐标-1-中间挖掉的个数，加起来就好了。部分代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
  int n;
  int ins[n];
  int total=0;
//输入
	for (int i=1;i<=max_h;i++)//每一层
	{
      		int sum=0;//中间层数（包右不包左）
      		int first=0,end=0;   
      		for（int j=1;j<=n;j++)
  			{	
  			if (ins[j]>=i)
  			{
  				if (first==0)
  					first=j;
  				else
  					sum++;
  				end=j;
  			}
  		}
  		total+=end-first-sum;
  	}
 }
```


我没有交这份代码。显然，复杂度为O（n*max_h）.在本题中，显然是过不了的（5000 * 10000）
### 想法二
#### 为什么法一要超时？因为它从一维方向考虑。所以这次要用二维。
 但是二维有一个~~小~~麻烦：中间一根柱子比两旁的柱子都要低（如样例所示），中间一根柱子就完全被淹没了。那怎么办？
####  我是黑板与重点：
如上述所说，当一根柱子比左边，右边都要低，就把这根柱子删掉，最后计算时把它从结果里挖掉。左边比较好办（我是边输入边处理的）。右边可以在后面输入时覆盖掉，倒过来推就好了。
##### 用心呈上AC代码：

```
#include <bits/stdc++.h>
using namespace std;
struct useful
{
	int loc;
	int h;
};
int main()
{
	int n;
	cin>>n;
	int ins[n+1];
	useful user[n+1];
	int flag=0;
	int sum=0;
	int max_h=0;
	for (int i=1;i<=n;i++)
	{
		int height;
		cin>>height;
		if (height>0)
		{
			if (flag==0||flag==1)
			{
				flag++;
				user[flag].loc=i;
				user[flag].h=height;
				max_h=max(max_h,user[flag].h);
			}
			else if (height>user[flag].h&&user[flag].h<max_h)
			{
				max_h=max(max_h,user[flag].h);
				sum-=user[flag].h;
				user[flag].h=height;
				user[flag].loc=i;
				flag--;
				for (;flag>=2;flag--)
				{
					if (user[flag].h<max_h&&user[flag].h<height)
					{
						sum-=user[flag].h;
						user[flag].h=height;
						user[flag].loc=i;
					}
					else
					{
						break;
					}
				}
				flag++;
			}
			else
			{
				max_h=max(max_h,user[flag].h);
				flag++;
				user[flag].loc=i;
				user[flag].h=height;
			}
		}
	}
	//cout<<"user:"<<endl;
	/*for (int i=1;i<=flag;i++)
	{
		cout<<user[i].loc<<" "<<user[i].h<<endl;
	}*/
	//cout<<"ans:"<<endl;
	for (int i=2;i<=flag;i++)
	{
		//cout<<"start:"<<user[i-1].loc<<" end:"<<user[i].loc<<endl;
		int width=user[i].loc-user[i-1].loc-1;
		//cout<<" width:"<<width<<endl;
		//cout<<"  h1:"<<user[i-1].h<<" h2:"<<user[i].h<<endl;
		int total_h=min(user[i-1].h,user[i].h);
		int s=total_h*width;
		//cout<<"  s="<<s<<endl;
		sum+=s;
	}
	cout<<sum<<endl;
	return 0;
}
```
#### 这里用了一次二重循环，但时间复杂度应该是O（n）级别。有兴趣的可以自己算一算。


---

## 作者：七夜 (赞：0)

看着他们的题解怎么那么多啊，不就是个模拟嘛，又不会超时，所以蒟蒻我又来发模拟代码喽

先说一下思路吧，身为蒟蒻，并没有去考虑区间，只考虑当前这一个位置下的存水高度，那么怎么算呢，很简单的。

只需要找出左边最高的和右边最高的，只要都比这个高度高，然后在两个高度里面找出较低的那个，加答案的时候再减去这个高度就好了嘛。

但是我要说明一点，因为数据得问题，我水过去了，如果数据很大的话，我这个做法应该会超时，因为每个点都会进行好多好多次循环，时间浪费太大了，但是可以优化，只不过我就要放学了，所以就没去写，下次补上昂

怎么优化呢，对于左边最高，一直取最大的就行，但是右边，可能当前最高并不是所有点的相对最高，加上一个if判断一下，虽然还需要循环，但是还是节省了很多时间的，我简单写了下

```
if(a[i]==you)
{
	you=0;
	for(int j=i+1)
	 you=max(you,a[j]);
} 
```
这样就可以更新我们的右边了，至于加到什么地方，自己琢磨琢磨吧，不难想的

还有一个小小的事情，无论第一个点和最后一个点多么大，都存不住水，这没错吧，那么我们就可以忽略这两个点的存水情况，循环直接 2->n-1 就可以了

这就是我的解题思路了，下面奉上AC但是丑陋的代码：

```
#include<bits/stdc++.h>//偷懒专用库 
#define ll long long
#define INF 520
#define MAXN 99999//宏定义 
using namespace std;

inline int read(){
  char c=getchar();int x=0,f=1;
  while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
  while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
  return x*f;
}//这里是快读哈，想学的可以借鉴借鉴，比我会的dalao就当没看见昂 

int  n,ans,zuo,you;//n表示数，ans记录答案，zuo是当前点左边最大的高度，you是当前点右边最大的高度 
int a[MAXN];//记录高度 

int main()//主函数部分 
{
	n=read();//读入n 
	for(int i=1;i<=n;++i)
	 a[i]=read();//读入高度 
	for(int i=2;i<n;++i)//为什么从2？为什么到n-1？这是因为1和n多么高，都存不住啊 
	 {
	 	zuo=you=0;//清零 
	 	for(int j=i+1;j<=n;++j)//找右边最高的 
	 	  {
	 	     if(a[j]>a[i]&&a[j]>you)//要比这个点高并且要找最高的 
			    {
			       you=a[j];
			    }	
		  }
		 for(int j=i-1;j>=1;j--)//和右边一样 
		  {
		  	if(a[j]>a[i]&&a[j]>zuo)
		  	 {
		  	 	zuo=a[j];
			 }
		  }
		if(zuo>a[i]&&you>a[i])//这个是判断是否能存，因为有可能这个点就是最高点，那样会减出一个负数，影响答案 
		 ans+=(min(zuo,you)-a[i]);//取左右两边较小的高度，还要减去这个点的高度，自己体会一下，画个图就知道了 
	 }
	cout<<ans;//输出 
	return 0; //养成好习惯，从你我做起哦 
}
```


---

## 作者：忧谗畏讥 (赞：0)

#### 刚看这道题，以为就求个差分，将负的取个反加起来（太垃圾了），发现好像不行
原思路是比较光和前一个进行比较，明显错误

后来又改为和前后两个进行比较，发现还是错的（太弱了），因为存在像1234321234的情况

但不屈于现状的我还是不想用题解的方法解决

终于发现了一个惊天大秘密（都怪我垃圾）

### 思路如下
先找到最大值出现的第一个位置和第最后个位置，然后会发现从第一个不为0的数到最后一个最大值的位置如果加满水应该是单调不下降的，最后一个不为0的位置到第一个最大值的位置从后往前也是单调不下降的，从第一个数往最后一个最大值扫的时候，只用和他前面的进行比较，保证大于等于她前面的，若不是，记录差值，让他等于前一个，从后往前扫的思路相同。
### 代码如下
```
#include<iostream>
using namespace std;
int main()
{
	int n,a[10002],maxa=0,maxi,maxa2=0,maxi2,sum=0,f01,f02,d=0;//maxa，maxa2为最大值，maxi，maxi2为第一个最大值和最后一个最大值的位置，sum记录答案，f01，f02为第一个和最后一个不为0的数的位置
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin>>a[i];
	for (int i = 1; i <= n; i++) {
		if(a[i] != 0 && d==0) f01 = i, d=1;//记录第一个不为0的位置，如果已经出现，将d赋值，以后将不对其造成影响
		if(a[i] != 0) f02 = i;//记录最后一个不为0的数
		if (a[i] > maxa) {
			maxa = a[i]; //记录第一个最大的数
			maxi = i;//记录第一个最大的数的位置
		}
		if (a[i] >= maxa2) {
			maxa2 = a[i];//记录最后一个最大的数的
			maxi2 = i;//记录最后一个最大的数的位置
		}
	}
	for (int i = f01+1; i <= maxi2; i++) {
		if (a[i] < a[i-1]) {//若从第一个不为0的数到最后一个最大的数中存在不是单调不下降
			sum = sum + a[i-1] - a[i];//记录答案（记得面积及高度）
			a[i] = a[i-1];//将此处水填满
		}
	}
	for (int i = f02-1; i >= maxi; i--) {//从最后一个不为0的数到第一个最大数时与上方思路一致
		if (a[i] < a[i+1]) {
			sum = sum + a[i+1] - a[i];
			a[i] = a[i+1];
		}
	}
	cout<<sum;
}
```

---

## 作者：奔波儿霸 (赞：0)

#### 瞎扯几句
看楼下的做法似乎很麻烦，但是很快。

我这里有种很简单暴力的做法，虽然复杂度是$O(n\times \max{(h)})$，但码量少

#### 解题思路
我们先考虑只有一横行的情况。一个水坑肯定会满足一个条件，那就是这里是空的，并且它的两边有方块，那么我们只需要对着这一横行扫一遍，设置一个变量``now``，遇到方块时就将``now``变成$0$，直到再一次遇到方块，就将``now``加入到答案中，并且将``now``清零。重复此过程，这一横行内的所有水坑大小就找到了。

那么我们再考虑有很多行的情况，因为这个题从题面中可以看出并不会出现神马方块悬空这种情况，只需要将很多行分成一行一行按照上面的一行的方法来写就可以了。复杂度显然，虽慢了不少，但无伤大雅。。。。。。

#### 附上代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int maxn = 1e4+3;
int n, h[maxn], mx, ans;
bool vis[maxn][5003];
int main() {
	scanf("%d", &n);
	for(int i=1; i<=n; i++) {
		scanf("%d", &h[i]);
		for(int j=1; j<=h[i]; j++)
			vis[i][j] = 1;
		mx = max(h[i], mx);
	}
	for(int i=1; i<=mx; i++) {
		int now = 0;
		bool flag = false;
		for(int j=2; j<n; j++) {
			if(vis[j][i] == 1) flag = true;
			if(vis[j][i] == 1 && now != 0) {
				ans += now;
				now = 0;
			}
			if(vis[j][i] == 0 && flag == true) now++;
		}
	}
	printf("%d", ans);
}
```

---

## 作者：柒命九陨_ (赞：0)

 翻了4页，感觉没人和我的写法一样~~长~~了。
 
 蒟蒻想不出来什么提前判断之后的情况，于是就写了以下暴力至极的，注释超多的题解，适合和我一样鶸的人阅读 qw。
 
 **主要思想是：**
 
 **	1.先判断当前位置左边是否比当前位置高，否则一定不能积水，直接跳过；**
 
 **    2.否则从此时位置向后找，判断能否积水（这里多少借鉴了楼上的思想）。**
 
然后献上0ms代码~~（数据好水）~~。


```
#define miho register int
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;

int n, a[neko], lef, righ, high;

inline void read(int &x) {		//最朴素的快读 
	char ch = 0;  x = 0;
	while( !isdigit(ch) ) { ch = getchar(); }
	while( isdigit(ch) ) { x = (x*10)+(ch^48); ch = getchar(); }
}

int main() {
	int p, t, ans = 0; 
	read(n);
	for(miho i=1; i<=n; ++i) read(a[i]);
    
	/*
		以下循环中： 
		i是所需累加闭区间的左端点 ； 
		t是所需累加闭区间的右端点 ； 
		p是一个用来向后扫描的变量 ；
		lef是左边的墙，righ是右边的；
		high是积水最大高度。 
	*/
	for(miho i=2; i<=n; ++i) {
		if( a[i]<a[i-1] )  lef = a[i-1];
		else continue;		//没法积水，直接跳过 
		
		t = p = i, righ = a[i+1];
		if( a[i]<a[i+1] ) {			//分了两种情况，当a[i+1]比a[i]大时，此时一定会积水
			while( a[++p]<=lef && p<=n ) {		//这些能懂吧……同下else内语句 
				if( a[p]>=righ )
					righ = a[p], t = p - 1;
			}
			high = min(lef, righ);
			for(miho z=i; z<=t; ++z)
				ans += high - a[z];
		}
        
		else {				//a[i+1]不比a[i]大，此时不一定有解，需要十分小心 
			while( a[++p]<=lef && p<=n ) {		//如果righ某时刻比lef大了，那就退出，因为继续扫描无法处理（自行理解 
				if( a[p]>=righ )				//接上句，否则就当做同一个区间，继续向后找 
					righ = a[p], t = p - 1;		//向后扫描，找一个不大于lef的墙并记录最大值，更新t 
			}
			if( a[p]>lef ) righ = a[p], t = p-1;	//以上循环如果出现righ>lef，是没法更新的，所以手动 
			if( a[t+1]>a[i] ) {			//判断能否积水（大概），然后累加区间积水量到ans 
				high = min(lef, righ);
				for(miho z=i; z<=t; ++z)
					ans += high - a[z];
			}
		}
		i = t;		//t（其实是t+1）之前的都已经扫过并记录了，所以i直接跳到t 
	}
	printf("%d", ans);		//yeah 
	return 0;
}

```

ps.防作（zong）弊（ming）删掉了外面小小的某一行 qw。

---

## 作者：清风我已逝 (赞：0)


这题不水

模拟都很难

二维数组模拟

下面是样例的二维数组直观感受

```cpp
0101110010
0001010010
```

然后模拟就很easy了

奉上代码

```cpp
#include<bits/stdc++.h>

using namespace std;
int n,a[10005],b[5005][5005],maxn,ans,tp,l,r;
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        maxn=max(maxn,a[i]);
        for(int j=1;j<=a[i];j++) b[j][i]=1;
    }for(int i=1;i<=maxn;i++){
        for(int j=1;j<=n;j++){
            cout<<b[i][j];
        }cout<<"\n";
    }tp=1;
    for(int i=1;i<=maxn;i++){
        for(int j=tp;j<=n;j++){
            if(b[i][j]==1){
                int k=0;tp=j;
                for(int q=tp+1;q<=n;q++){
                    if(b[i][q]==1){
                        k=q;break;
                    }
                }if(k!=0&&k!=j+1) ans+=k-j-1;
                tp=k;
            }
        }tp=1;
    }cout<<ans;
    return 0;
}
```

---

## 作者：北极鹅 (赞：0)

提供一个非常诡异的思路（利用比较类似前缀最大的思想）。开两个数组l[]、r[]，分别表示：只考虑左边的时候积水的最大高度、只考虑右边的时候积水的最大高度。因此每一处的积水最大高度是min{l[i], r[i]}。只有当方块高度比积水最大高度小的时候，更新答案。

此算法的正确性不难证明，而且时间和空间的复杂度已经达到了输入下限。

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;

inline
int readint() {
    int ri = 0;
    char c;
    while(isspace(c = getchar()));
    while(isdigit(c)) {
        ri = ri * 10 + c - '0';
        c = getchar();
    }
    return ri;
}

#define ri readint()
#define maxn 10005

int n;
int a[maxn];
int l[maxn], r[maxn];

int main() {
    register int i;
    n = ri;
    l[0] = r[0] = a[0] = ri;////退化情况
    memset(l, 0, sizeof(l));
    memset(r, 0, sizeof(r));
    for(i = 1;i < n;++i) {
        a[i] = ri;////读入
        if(a[i] <= l[i - 1]) l[i] = l[i - 1];////顺序更新l数组
        else l[i] = a[i];
    }
    r[n - 1] = l[n - 1] = a[n - 1];////退化情况，注意处理a、l、r数组的顺序
    for(i = n - 2;i >= 1;--i)
        if(a[i] <= r[i + 1]) r[i] = r[i + 1];////逆序更新r数组
        else r[i] = a[i];
////这样，l与r数组就保存了a高度的类似前缀最大的信息，下面就要开始利用他们干活了
    int ans = 0;
    int mm;////防止多次调用min函数
    for(i = 0;i < n;++i) {
        mm = min(l[i], r[i]);////积水可能的最大高度
        if(a[i] < mm)////方块不如积水高
            ans += mm - a[i];////更新答案
    }
    printf("%d\n",ans);

    return 0;
}
////复杂度：时间O(n)，空间O(n)
////时间0ms，空间1.6MB，顺便吐槽一句题目数据范围太水了
```

---

## 作者：quhanshi (赞：0)

分层计算

结果 = 每层可积水面积之和

每层积水面积 = 从左起第一个高于此层高度的柱子以右的所有空位 +  从右起第一个高于此层高度的柱子以左的所有空位 - 这一次所有空位 (容斥原理)

举例：(0为低于当前高度的可积水区域)

0000000001100100

s = 0
00000000011**00**1**00**

s += 4
**000000000**11**00**100

s += 11

**000000000**11**00**1**00**

s -= 13

即s = 4

   

下面代码

```cpp
#include <iostream>
#include <algorithm>
#define N 10050
using namespace std;
int n, a[N], maxn, ans;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        maxn = max(maxn, a[i]);
    }
    for (int j = maxn; j >= 1; j--)
    {
        bool t = false;
        int s = 0;
        for (int i = 1; i <= n; i++)
            if (t == false)
                if (a[i] >= j)
                    t = true;
            else
                if (a[i] < j)
                    s--;
        t = false;
        for (int i = n; i >= 1; i--)
            if (t == false)
                if (a[i] >= j)
                    t = true;
            else
                if (a[i] < j)
                    s--;
        int k = 0;
        for (int i = 1; i <= n; i++)
            if (a[i] < j)
                s++;
        ans += s;
    }
    cout << ans << endl;
    return 0;
}

```

---

## 作者：wawcac (赞：0)

之前发那个题解忘加[广告](http://www.cnblogs.com/wawcac-blog/p/6821771.html)了，重发一个，抱歉，增加了一些注释便于理解。

自己的思路：对所有h[i]，在记录了原本位置的情况下对高度进行排序，然后枚举：对第一高的和第二高的（一样高也可以）之间所有列统计答案，标记已统计过（因为后面不能重复计算这一列，降序排序保证了越靠前计算获得水位越高），对第二高和第三高之间区间执行相同操作，对第三高和第四高区间之间执行相同操作……，第n-1高和第n高（最矮）之间区间执行相同操作，最后输出答案，ac


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct data{
    int high;//柱子高度
    int num;//记录原图中柱子的编号，因为排序会打乱编号
}d[100100];
int n;
bool vis[100100]={0};//判断是否放过水
int h[100100]={0};//排序前的柱子高度
int ans=0;
int cmp(const data & a,const data & b)
{
    return a.high>b.high;//cmp函数等于的情况要么特判，要么不管，不然re（a.high>=b.high)，我不知道为什么，有知道的大牛能否告知？
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",h+i);
        d[i].high=h[i];
        d[i].num=i;
    }
    sort(d,d+n,cmp);
    for(int i=0;i<n-1;i++)
    {
        int left = min(d[i].num,d[i+1].num);
        int right= max(d[i].num,d[i+1].num);//找到待修改区间的左右端点，端点处不用算，贡献面积为0
        int hh=min(h[right],h[left]);//液面高度为两端点中更低的柱子的高度
        vis[right]=vis[left]=true;
        for(left+=1;left<right;left++)
        {
            if(!vis[left])
            {
                vis[left]=true;
                ans+=hh-h[left];//一根柱子积水高度为液面高度减去柱子高度,因为是按从高到低的顺序操作的,所以可以保证减得的结果不为负
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：jokemoon (赞：0)

两把循环搞定，前后各记录遇到的更高柱子作为后面的“水位”即可


```cpp
#include<iostream>
using namespace std;
const int MAXN = 10002;
int main()
{
    int n, m, ans, h[MAXN], b[MAXN];
    cin >> n;
    m = 0;
    for (int i = 0; i < n; i++)
    {    // 第一把循环输入，并记录正向爬楼梯的“水位”
        cin >> h[i];
        if (m < h[i])m = h[i];
        b[i] = m;
    }
    m = 0;
    ans = 0;
    for (int i = n - 1; i >= 0; i--)
    {    // 第二把循环记录反向爬楼梯的水位，并统计面积
        if (m < h[i])m = h[i];
        if (b[i] > m)b[i] = m;
        ans += b[i] - h[i];
    }
    cout << ans;
    return 0;
}
```

---

## 作者：24680esz (赞：0)

```cpp
#include <iostream>
using namespace std;
int main()
{
    int n,j,k,s=0,b=-1;
    cin>>n;
    int a[n+1];
    for (int i=1;i<=n;i++) cin>>a[i];
    for (int i=1;i<=n;i++)
      if (a[i]>b) b=a[i]; //算出总层数
    for (int i=1;i<=b;i++) //i为当前正在寻找的层数
    {
        for (j=2;j<=n-1;j++) //由于首尾为0，从2循环到n-1即可
          if (a[j]>=i) break; //寻找第一根柱子的位置
        for (k=n-1;k>=2;k--)
          if (a[k]>=i) break; //寻找最后一根柱子的位置
        for (int t=j;t<=k;t++)
          if (a[t]<i) s++; //寻找高度小于当前循环层数的位置
    }
    cout<<s<<endl;
    return 0;
} 
```

---


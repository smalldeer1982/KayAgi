# 蚂蚁

## 题目描述

有许多蚂蚁在一根无限长的木棍上，每一只蚂蚁都有一个初始位置和初始朝向（任意两只蚂蚁的初始位置不同）。蚂蚁们以每秒一个单位的速度向前移动，当两只蚂蚁相遇时，它们会掉头（掉头时间忽略不计）。现给出每只蚂蚁的初始位置和初始朝向，请你计算出它们在 $t$ 秒后的位置和朝向。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，$1\le n\le 100$；
- 对于 $80\%$ 的数据，$1\le n\le 10^4$，$0\le t\le 1000$；
- 对于 $100\%$ 的数据，$n\le 10^5$，$0\le t\le 10^5$，$|a_i|\le 10^6$。


## 样例 #1

### 输入

```
4 1
1 1
5 1
3 -1 
10 1
```

### 输出

```
2 0
6 1
2 0
11 1
```

# 题解

## 作者：翼德天尊 (赞：132)

### 写在开头
你做过飞机吗？想象你在高空中看两个蚂蚁迎面相遇（当然不要考虑你能不能看得见），你会发现一件奇异的事情发生了——它们从对方的身上穿过去了！当然，只是它们互相绕过去而你没看清而已。


------------
**为什么要说这个呢？**

我们来打个比方，假设有A,B两只蚂蚁头对头相遇。

1.对于你来说，--->AB<---（A,B迎面相遇）后，A<----->B（A,B都调头跑）是不是就相当于B<----->A（A,B互相穿过）。因为对于你来说它们就是两只蚂蚁？

2.对于蚂蚁来说，只要碰面就互相调换方向，假设A,B两只蚂蚁一前一后，无论双方面对什么方向，是不是B都超不过A？

**总结：** 综上所述，只要知道每只蚂蚁刚开始的相对位置排名，再特判走过t秒后两只蚂蚁位置是否相等，就可以通过相对位置排名输出！

### 但是怎么实现呢？
```
答案：排序排序再排序
```

### 下面是AC代码及具体讲解
```
#include<bits/stdc++.h>//万能头文件，美丽又大方
using namespace std;
int n,t,w[100001][2];//分别表示蚂蚁数量，时间长度，以及t秒后按位置从大到小排名后的位置及方向
struct node{//结构体方便排序
	int w,f,h,d;
}ant[100001];//记录信息，分别为每只蚂蚁的位置，方向，输入序号以及位置永久排名（位置排名不变）
int cmp(node x,node y){//排序方式1：按照位置排序
	return x.w<y.w;
}
int cmp1(node x,node y){//排序方式2：按照输入序号排序
	return x.h<y.h;
}
int main(){
    scanf("%d%d",&n,&t);
    for (int i=1;i<=n;i++){
    	scanf("%d%d",&ant[i].w,&ant[i].f);
    	ant[i].h=i;
	}//简单输入以及标号
	sort(ant+1,ant+1+n,cmp);//按照t秒前的位置排序
	for (int i=1;i<=n;i++){
		ant[i].d=i;//定位永久位置排名
    	ant[i].w+=ant[i].f*t;//模拟每个蚂蚁t秒后的位置
	}
	sort(ant+1,ant+1+n,cmp);//按照t秒后的位置排序
	for (int i=2;i<=n;i++){//判断是否正在转弯（如相邻两蚂蚁坐标相等，即为正在转弯）
		if (ant[i].w==ant[i-1].w){
			ant[i].f=0;ant[i-1].f=0;//标记输出时的状态
		}
	}
	for (int i=1;i<=n;i++){//填充记录从小到大蚂蚁的位置及方向
		w[i][0]=ant[i].w;
		w[i][1]=ant[i].f;
	}
	sort(ant+1,ant+1+n,cmp1);//按照输入序号排序
	for (int i=1;i<=n;i++){//按照输入时的顺序依次按照各自的永久位置输出每一只蚂蚁的坐标及状态
		printf("%d %d\n",w[ant[i].d][0],w[ant[i].d][1]);
	}
    return 0;//好习惯，人人养成
}
```
**如果还有什么不明白的，可以在留言区私聊我哦，当然，如果你看完后明白了，动动你美丽漂亮可爱大方的小手点个赞吧，谢谢大家QAQ**

---

## 作者：lili_flyingcutter (赞：52)

# 实际上，这题并没有必要硬模拟

## 假设两只蚂蚁正在相撞，我们不妨让他们继续走下去

## 这时，有人会问，那最后顺序不就改变了吗？

## 其实，只要最后重新按输入顺序排一遍，就可以了

## 模拟一下

## 1.A——><——B

## 2.<——AB——>

## 结果，A还是在B左边

## 这么说，相对位置不改变






```cpp
int f[10001];
struct ff{
    int a,id,k;
    char c;
a[10001],b[10001];
bool cmp(ff x,ff y){
    return x.a<y.a;
}
bool cmp2(ff x,ff y){
    return x.id<y.id;
}
int main(){
    int n,t;
    scanf("%d%d\n",&n,&t);
    for(int i=0;i<n;i++)scanf("%d%d",&a[i].a,&a[i].c),b[i]=a[i],b[i].id=i;
```
### 读入，并保存原方向
    for(int i=0;i<n;i++)

       a[i].a+=t\*a[i].c;

### 直接算出t秒后位置（相对位置不变）

```cpp
    sort(a,a+n,cmp);
    sort(b,b+n,cmp);//按起始位置排
    for(int i=0;i<n;i++)a[i].id=b[i].id;
    for(int i=0;i<n-1;i++){
        if(a[i].a==a[i+1].a)
          a[i].k=1,a[i+1].k=1;//算出是否相撞
    }
    sort(a,a+n,cmp2);
    for(int i=0;i<n;i++)
           if(a[i].k)
           printf("%d 0\n",a[i].a);
         else printf("%d %d\n",a[i].a,a[i].c);
```
### 输出，这里就不说了
    return 0;

}

---

## 作者：jerry99 (赞：17)

碰头相当于穿过，每只蚂蚁相对位置不变。

只需记录输入顺序，做完操作后按序输出。

```cpp

#include <cstdio>
#include <algorithm>
using namespace std;
const int Tmax=100005;
struct node{
    int x,d,num;
};
node ant[Tmax];
int n,m,position[Tmax];
bool cmp1(const node &a,const node &b)
{
    return a.x<b.x;
}
int main()
{
    int i;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
    {
        scanf("%d %d",&ant[i].x,&ant[i].d);
        ant[i].num=i;
    }
    sort(ant+1,ant+1+n,cmp1);
    for(i=1;i<=n;i++){
        position[ant[i].num]=i;
        ant[i].x+=ant[i].d*m;
    }
    sort(ant+1,ant+1+n,cmp1);
    for(i=1;i<=n;i++)
      if(ant[i].x==ant[i+1].x) ant[i+1].d=ant[i].d=0;
    for(i=1;i<=n;i++)
        printf("%d %d\n",ant[position[i]].x,ant[position[i]].d);
    return 0;
}

```

---

## 作者：PhantasmDragon (赞：15)

不要被表面现象所迷惑！

两个相同长相的蚂蚁相遇转向，就相当于他们对穿而过！

只需要将他们的编号交换就可以了！

```cpp
#include<cstdio>  
#include<cstring>  
#include<iostream>  
#include<algorithm>  
#define MAX 10001  
using namespace std;  
int l,t,n;  
struct Ants  
{  
    int pos;  
    int p;  
    int num;  
    int ans;  
}a[MAX];  
bool cmp(Ants a,Ants b)//根据位置排序，处理数据用
{  
    return a.pos<b.pos;  
}
bool cmpa(Ants a,Ants b)//根据编号排序，输出数据用
{  
    return a.num<b.num;  
}  
int order[MAX];  
int main()  
{  
    scanf("%d %d",&n,&t);  
    for(int i=0;i<n;i++)  
    {  
        int itb;
        scanf("%d %d",&a[i].pos,&itb);  
        a[i].p=itb==-1?1:2;  
        a[i].num=i+1;  
    }  
    sort(a,a+n,cmp);  
    for(int i=0;i<n;i++)  
    {  
        order[i]=a[i].num;  
        a[i].pos+=a[i].p==1?-t:t;  
    }  
    sort(a,a+n,cmp);  
    for(int i=0;i<n;i++)  
    {  
        a[i].num=order[i];  
        if(i>0&&a[i].pos==a[i-1].pos||i<n-1&&a[i].pos==a[i+1].pos)
        {
            a[i].ans=1;          
        }
        else 
        {
            a[i].ans=0;        
        }
    }  
    sort(a,a+n,cmpa);  
    for(int i=0;i<n;i++)  
    {  
        if(a[i].ans==1)
        {
            printf("%d 0\n",a[i].pos);            
        }
        else
        {
            printf("%d %d\n",a[i].pos,a[i].p==1?-1:1);             
        }
    }  
    printf("\n");  
    return 0;  
}
```

---

## 作者：魁拔 (赞：7)

这题和独木桥类似，部分处理相同

至于最后每个蚂蚁的位子。因为相遇就转向，所以不存在超过的问题，

既每只蚂蚁的相对位子不变

因此，可以先求出每只蚂蚁现在的位子，再根据某只蚂蚁原始的相对位置输出

注意位置相同方向为0


---

## 作者：sinsop90 (赞：5)

其实这道题并不用直接模拟,两层for嵌套

因为蚂蚁在一个时间点里的行程是一样的,我们只用加上时间就行了

而且,如果两个蚂蚁在相撞后,我们假设一号蚂蚁在二号蚂蚁的左边,相撞后如果我们将两只蚂蚁的序号换一下,那就和没撞一样了(我也是看了一些巨佬的分析我才想到的)

所以实际上我们开一个结构体,存储蚂蚁的序号方向,在开始时排序一次,再算出t秒后的位置就行了。

```
#include<bits/stdc++.h>
using namespace std;
struct ant{
    int x,d,num;
}kpl[100005];
int n,t;
int k[100005];
bool cmp(ant &a,ant &b)
{
    return a.x<b.x;
}
int main()
{
    cin>>n>>t;
    for(int i=1;i<=n;i++)
    {
    	cin>>kpl[i].x>>kpl[i].d;
        kpl[i].num=i;
    }
    sort(kpl+1,kpl+1+n,cmp);
    for(int i=1;i<=n;i++){
        k[kpl[i].num]=i;
        if(kpl[i].d==-1){
        	kpl[i].x-=t;
		}
		else if(kpl[i].d==1){
			kpl[i].x+=t;
		}
    }
    sort(kpl+1,kpl+1+n,cmp);
    for(int i=1;i<=n;i++){
  	  	if(kpl[i].x==kpl[i+1].x){
  	  		kpl[i+1].d = 0;
  	  		kpl[i].d = 0;
		} 
	}
    for(int i=1;i<=n;i++){
    	cout<<kpl[k[i]].x<<" "<<kpl[k[i]].d<<endl;
	}
    return 0;
}
```


---

## 作者：Atoxin (赞：4)

//这题排序都要快排，如果用插入，可能超时。

//基本想法与其他题解说的相同，单纯模拟一定超时。

//ranking[i]表示第i号排第几,f[i]表示它的反函数。d[i]表示方向,s[i]表示位置。

```cpp
var f,ranking,d,s:array[1..100001]of longint;
i,j,time,n,m,tot:longint;
procedure swap(var x,y:longint);
var t:longint;
begin
t:=x;
x:=y;
y:=t;
end;
procedure sort1(l,r:longint);   //在初始状态时排序。
  var
    tmp,i,j,mid:longint;
  begin
    i:=l;
    j:=r;
    mid:=s[(i+j)div 2];
    repeat
      while s[i]<mid do inc(i);
      while s[j]>mid do dec(j);
      if i<=j then
        begin
          swap(s[i],s[j]);
          swap(d[i],d[j]);
          swap(ranking[i],ranking[j]);
          inc(i);
          dec(j);
        end;
    until i>j;
    if l<j then sort1(l,j);
    if i<r then sort1(i,r);
  end;
procedure sort2(l,r:longint);    //在蚂蚁爬完后排序。
  var
    tmp,i,j,mid:longint;
  begin
    i:=l;
    j:=r;
    mid:=s[(i+j)div 2];
    repeat
      while s[i]<mid do inc(i);
      while s[j]>mid do dec(j);
      if i<=j then
        begin
          swap(s[i],s[j]);
          swap(d[i],d[j]);
          inc(i);
          dec(j);
        end;
    until i>j;
    if l<j then sort2(l,j);
    if i<r then sort2(i,r);
  end;
begin
readln(n,time);
for i:=1 to n do begin
readln(s[i],d[i]);
ranking[i]:=i;
end;
sort1(1,n);
for i:=1 to n do f[ranking[i]]:=i;
for i:=1 to n do
s[i]:=s[i]+time*d[i];
sort2(1,n);
for i:=1 to n-1 do
if s[i]=s[i+1] then begin
d[i]:=0;
d[i+1]:=0;
end;
for i:=1 to n do
writeln(s[f[i]],' ',d[f[i]]);
end.
```

---


# 山上的国度

## 题目描述

有一个神秘的小国坐落在南方的青山之上，只有当黄昏时，落日耀眼的余晖刺破薄雾的遮拦，有机缘者才可看到小山上面的 $n$ 个美丽的村庄。

传说这个古老的国家里有 $m$ 条枢纽管道，每一条苍老的管道连接着两个村庄，千百年来为村民提供水源的流通。

$n$ 个村庄里只有一个水库，从有水库的村庄通过这些枢纽管道向其它村庄提供水源。大家都明白水往低处流，所有村庄都能得到水库的供水。

黄小明就是那个有机缘者，同时他也是个偏执狂（把小猫绑在一起的那个变态小明），他迫切的想要知道水库应该在哪一个村庄，你能帮他解决疑惑吗？


## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2
3 4
```

### 输出

```
Non```

# 题解

## 作者：Jameswood (赞：25)

### 说在前面的一些话

大致看了一眼题解，貌似各位大佬都是用 **并查集** 或者 **dfs/bfs** 或 **图论** 做的……其实并没有这个必要，而且唯一一个没有使用复杂算法的题解讲得也不是很清楚，也就斗胆写一篇了（那一篇写得质量实在是……）。

---

### 题目大意

已知有 $n$ 个点， $m$ 条边，每个点有一个权值 $h_i$ 。从一个点能够到达另一个点的条件是出发点的 $h_i$ 要大于**（注意没有等于）**抵达点的 $h_i$ （当然首先得有路才行）。

值得注意的一点是 $n,m$ 的范围极小，最大值只有 $300$ 。

---

### 大致思路以及所依论据（太烦不看或大佬版）：

```
首先记录所有可以通水的路径（即把因为高度因素不能通水的路径删去）。

然后将所有可以抵达的点标记出来，并记录总的数量（第一步以后所有边均为单向边），如果总数恰好为 n-1 且无法抵达的那个点恰好为高度最高点，那么 Okay ,不然就不行。

所以只要记录合法的通道数量和最高点的编号即可。

```

---

### 详细解法

我使用了一个非常暴力的做法，首先读入所有的高度，然后将所有可以通路的点与点之间的路径标记出来（因为数据范围极小所以我直接使用了邻接矩阵），这一步是在读入通道之前，读入高度之后进行的。

这一步的主要目的是为了之后 **去除数据中有重复输入相同边的情况**，其实 $vis$ 数组是不需要的，不过这样后面判断会很麻烦，末尾的 $AC$ 代码会给出写法，这里就不用了，以提高可读性。

同时下面这段代码也经过了一定的优化，如果无法理解，它的作用和[这段代码](https://www.luogu.org/paste/pe831ucs)是一致的（点击查看）。

```cpp
//此处的 h[] 数组表示高度，vis 是用于表示是否合法的 bool 数组
for(int i=1;i<=n;i++){
	for(int j=i;j<=n;j++){
    	//只有两点高度相等的时候才没有路径
		if(h[i]==h[j]) continue;
		if(h[i]>h[j]){
			vis[i][j]=true;
		}else{
			vis[j][i]=true;
		}
	}
}
```

接下来读入所有的连通路径，并判断、记录这些路径中可以通水的数量以及可以抵达的点的编号（这就是前面的标记发挥作用的地方）。去除重复的路径的方法是每次把计完数的标记清除（设为无法通过）。

p.s. 先别问这些东东西西南南北北的有什么用，后面就知道了。

```cpp
//vis[] 就是高度是否允许通行的标记，m 是输入路径的数量，counts 是符合要求的的路径的数量，get 就是抵达标记
for(int i=0;i<m;i++){
	scanf("%d%d",&x,&y);
	if(vis[x][y]==true){
		vis[x][y]=false;
        get[y]=true;
		++counts;
	}
	if(vis[y][x]==true){
		vis[y][x]=false;
        get[x]=true;
		++counts;
	}
}
```

后面就是**核心的思想**了！假设经过第一步的删除后有一份如下图所示的输入数据：

![这里有一张没有加载出来的图片](https://cdn.luogu.com.cn/upload/pic/51005.png )

明显每一条边都是单向边，且这张图的回答应该是 “$Non$” （不行）。

仔细想一想，为什么呢？

关键点在于编号为 $3$ 、$4$ 的两个村庄，它们是无法被高度更高的村庄抵达的。所以可行的条件就很简单了：**只需保证无法到达的点的个数为1，且这个点恰好为最高点就可以了**。

重要的事情再说一边：

$$\text{只需保证无法到达的点的个数为1，且这个点恰好为最高点就可以了 }$$

做法就比较简单了，首先记录一个不能抵达的点，接下来进行判断，如果不能抵达的点的数量小于总数-1亦或是不能抵达的点不是最高点（这个在输入的时候记录），那么就输出 $Non$ （判断为不行），否则就输出高度最高的村庄的编号。

p.s. 有些人可能会问，如果高度最高的村庄有两个肿么办？ 不要担心，这种情况肯定不行，因为至少有两个点是无法被到达的。

```cpp
//counts 是符合条件的路径数量，n 是村庄总数，id 是高度最高的村庄的编号。
for(int i=1;i<=n;i++)
	if(get[i]==false){
		maxn=i;break;
	}
if(counts<n-1||maxn!=id){
	printf("Non\n");
}else{
	printf("Oui, j'ai trouve la solution.\n");
	printf("%d\n",id);
}
```

----

最后附上 $AC$ 代码：

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
const int SIZE=305;
int n,m,x,y,counts,h[SIZE],maxn=-1<<30,id;
bool get[SIZE];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&h[i]);
		if(h[i]>maxn){
			maxn=h[i];id=i;
		}
	}
	for(int i=0;i<m;i++){
		scanf("%d%d",&x,&y);
		if(h[x]>h[y]){
			if(get[y]!=true) ++counts;
			get[y]=true; 
		}
		if(h[y]>h[x]){
			if(get[x]!=true) ++counts;
			get[x]=true;
		}
	}
	for(int i=1;i<=n;i++)
		if(get[i]==false){
			maxn=i;break;
		}
	if(counts<n-1||maxn!=id){
		printf("Non\n");
	}else{
		printf("Oui, j'ai trouve la solution.\n");
		printf("%d\n",id);
	}
	return 0;
}
```

p.s. 个人感觉难度虚高，数据偏水，所以在最后的最后提供几组测试样例：

[输入输出样例#2  ](https://www.luogu.org/paste/yed6jjdv)  ,  [输入输出样例#3](https://www.luogu.org/paste/fdgx02lv)  ，  [输入输出样例#4](https://www.luogu.org/paste/tgznrlrj)



---

## 作者：issue_is_fw (赞：18)

大家的做法都很复杂呢~~~`````~~~``~~``~~``~~~``~~```~`~~·~

# 注意这句话:水往低处流

那么如果答案存在,水井必然建在海拔最高的村庄。

给定L村庄和R村庄有道路，那么我们标记海拔较低的村庄

**表示有村庄指向自己**

如果最后，只有最高的村庄没有被标记，那么一定可行。

~~附上简短的代码~~

```cpp
#include <bits/stdc++.h>
using namespace std;
int indug[309],a[309],num=0,maxn=0,n,m;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(mm<a[i])	mm=a[i],num=i;
	}
	for(int i=1;i<=m;i++)
	{
		int l,r;
		cin>>l>>r;
		if(a[l]>a[r])	indug[r]++;
		else if(a[r]>a[l])	indug[l]++;
	}
	int x=0;
	for(int i=1;i<=n;i++)
		if(indug[i]==0)	x++;
	if(x==1)	
		cout<<"Oui, j'ai trouve la solution."<<endl<<num;
	else	cout<<"Non";
}
```


---

## 作者：狸狸养的敏敏 (赞：6)

~~可能是最长的写法~~

在下太蒻了，只能想出复杂的办法QAQ

首先考虑贪心，因为水往低处流，所以如果水库能够覆盖所有村庄，水库所在位置一定是最高的村庄所在的位置。

其次就是考虑图的联通性，因为题目要求只能从高处向低处走，所以考虑从高处向低处建边

代码里有注释，可能看了会清晰一点

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=330;
int read()
{
	int x=0,f=0;
	char ch=0;
	while(!isdigit(ch))f|=(ch=='-'),ch=getchar();
	while(isdigit(ch))(x*=10)+=(ch^48),ch=getchar();
	return f?-x:x;
}//快读

int n,m,tot;//n,m如题意，tot存边用
bool flag[MAXN];//flag表示村庄是否被访问过
int head[MAXN];//领接表

struct Edge{
	int v;
	int nxt;
}edge[MAXN*MAXN];
//存边的结构体

struct Vil{
	int high;//存储每个村庄的海拔
	int _id;//存贮村庄的原顺序，方便还原
	bool operator<(const Vil &rhs)const{
		return high>rhs.high;
	}//按照海拔从高到底排序，则vill[1].high就是最高海拔
}vill[MAXN];

bool cmp(Vil a,Vil b)
{
	return a._id<b._id;
}//按照原顺序排序，还原输入顺序

void addedge(int u,int v)
{
	edge[++tot]=(Edge){
		v,head[u]
	};
	head[u]=tot;
}//链式前向星存边

void dfs(int x)
{
	flag[x]=1;//标记该点已经来过
	for(int i=head[x];i;i=edge[i].nxt)
	dfs(edge[i].v);
}//DFS遍历每一个村庄，因为我们下面建边的时候已经判定过，所以此处可以直接向下进行遍历

int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	vill[i].high=read(),vill[i]._id=i;
   
	for(int i=1;i<=m;i++)
	{
		int a=read(),b=read();
		if(vill[a].high>vill[b].high)addedge(a,b);//当a海拔比b海拔高时，存储一条a->b的边
       	/*
       	 因为我们考虑到题目中给出的每条边，
       	 有些边（例如从海拔1->海拔10的边）
       	 是无效边（无法影响答案），那么我
       	 们在建图时，就直接省略这条边，否
       	 则在遍历全图时还需要判定海拔高度
       	*/
		else if(vill[a].high<vill[b].high)addedge(b,a);//这句if不能省，因为题目中明确指出同海拔的不能相互运水
	}
    
	sort(vill+1,vill+n+1);//按海拔高度排序
	int s=vill[1]._id;//获取海拔最高的村庄编号
	sort(vill+1,vill+n+1,cmp);//排回输入顺序
	dfs(s);//从最高点开始遍历全图
	for(int i=1;i<=n;i++)
	if(!flag[i])return printf("Non\n"),0;//如果有任意一个点没有被遍历过，则说明不存在方案，使每一个村庄都能接到水
	printf("Oui, j'ai trouve la solution.\n%d\n",s);//否则输出答案
	return 0;
}

```

---

## 作者：封禁用户 (赞：6)

最开始看到这道题竟然无从下手，在海拔那里不知道在想什么卡了很久  

---  
首先这道题的大意就是：水向下流，没有水管就不连通，输出Non  
我直接输出Non试了一下,于是[就这样了](https://www.luogu.org/record/25601549)所以大家还是老老实实写代码，骗分不存在的  
于是很果断（大雾）地选择了并查集， 最坏情况O(n log n)在连边的时候判断一下海拔就行了（我写的时候曾经在犹豫要不要连边优化，后来发现并没有影响）  
最主要的就是中间的判断:  
1. 如果海拔1大于海拔2，2连到1上  
2. 如果海拔2大于海拔1，1连到2上  
3. 如果相等，不能连  
最后，把1的父亲存下来，再跑一边所有村庄，如果村庄i的父亲和1的父亲不同，则说明此图不连通，输出Non  
否则就输出1的父亲  

---  
下面是~~一遍~~AC代码  
#### 关爱生命，拒绝抄袭:  
```cpp  
#include <bits/stdc++.h>
using namespace std;
int far[10001], h[10001];
int ucs(int x) {
    if (far[x] == x) return x;
    return far[x] = ucs(far[x]);
}
int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	for (register int i = 1; i <= n; ++i) scanf("%d", &h[i]), far[i] = i;
	for (register int i = 1; i <= m; ++i) {
		int u, v;
		scanf("%d %d", &u, &v);
		if (h[u] > h[v]) far[v] = ucs(u);
		else if (h[u] < h[v]) far[u] = ucs(v);
		else continue;
	}
	int cz = ucs(1);
	for (register int i = 2; i <= n; ++i) if (ucs(i) != cz) {
		printf("Non");
		return 0;
	}
	printf("Oui, j'ai trouve la solution.\n%d", cz);
	return 0;
}  
```

---

## 作者：momentous (赞：5)

唔......

我并没有看到一篇用广搜的题解,于是写了一篇题解......

代码当中有注释,可自行查看
```Cpp
#include<cstdio>
#include<queue>
/*
  <queue> 队列头文件
  用到的函数:
    1:队列名称.front();
      返回队列中的第一个元素
    2:队列名称.pop();
      删除队列中的第一个元素
    3:队列名称.empty();
      检查队列是否为空
        若为空,返回 true
        否则返回 false
    4:队列名称.push(...);
      将括号内元素插入到队列末尾
  ps:这是从我上一篇题解中kao来的
*/
#include<cstring>
/*
  memset函数要用到cstring头文件
*/
#define reg register
using namespace std;
int n,m,h[505],Num[505],add[505][1005],x;
int Ans,top;
bool vis[505],Flag;
queue <int> q;
void bfs(int T)
{
    q.push(T);
    while(q.empty()==0)/*当队列不为空时一直广搜*/
    {
        x=q.front();/*取出队列第一个元素*/
        q.pop();/*弹出队列第一个元素*/
        for(reg int i=1;i<=Num[x];++i)
            if(!vis[add[x][i]])
            {
                ++top;//被访问的村庄数+1
                vis[add[x][i]]=1;//已被访问
                q.push(add[x][i]);//压入队列
            }
        /*
          枚举与这个村庄相连的路径
        */
        if(top==n){
            Flag=1;
            break;
        }
        /*
          若节点数==n,则说明所有村庄都有水
          (广搜是不会重复搜的)
        */
    }
}
void Clear()
{
    while(q.empty()==0)
        q.pop();
    /*
      当队列不为空时一直弹出队列元素
    */
    memset(vis,0,sizeof(vis));
    /*
      初始为0(false)
    */
    top=1;
    /*
      由于清空后要插入1个初始位置的元素,在这里先赋值为1
      是在bfs中插入的
    */
}
int main()
{
    reg int x,y,t;
    scanf("%d%d",&n,&m);
    for(reg int i=1;i<=n;++i)
        scanf("%d",&h[i]);
    /*
      读入高度
    */
    for(reg int i=1;i<=m;++i)
    {
        scanf("%d%d",&x,&y);
        if(h[x]==h[y]) continue;
        /*
          一个小优化:
            若高度相等,则水是一定流不过去的,跳过
        */
        if(h[y]>h[x]) t=x,x=y,y=t;
        /*
          确保x号村庄的高度>y号村庄的高度
          (不知这是否是有向图?)
        */
        Num[x]++;
        /*
          边数+1
        */
        add[x][Num[x]]=y;
        /*
          x号村庄的(当前)最后一条边连向y号村庄
        */
    }
    for(reg int i=1;i<=n;++i)
    {
        Clear();
        /*
          清空队列
        */
        bfs(i);
        /*
          从i号村庄开始广搜
        */
        if(Flag){
            printf("Oui, j'ai trouve la solution.\n%d\n",i);
            break;
        }
        /*
          Flag为true时,说明所有的村庄都有水,那么就可以输出了
        */
    }
    if(!Flag) printf("Non\n");
    /*
      若标记为 false 说明有些村庄没有水,输出 Non
    */
    return 0;
}
```
[AC记录](https://cdn.luogu.com.cn/upload/pic/61332.png)

---

## 作者：hexiao (赞：3)

看到各位大佬使用弗洛伊德传递闭包,并查集,spfa,反向建边等等各种吊打我这个蒟蒻的算法，其实没有那么难。

如果两个村庄之间有管道,海拔高的村庄才有可能一定要有水库,海拔低的村庄不可能一定要有水库,因为只有一个水库,水只能往低处流。

样例解释(请忍受我的灵魂画风):
![](https://cdn.luogu.com.cn/upload/image_hosting/sfw2zw0v.png)
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;//命名空间
int hi[305];//hi[i]是第i个村庄的海拔
bool h[305];//h[i]是第i个村庄是否一定要有水库(true是一定要,false是不一定要)
int main()
{
    int n,m,x,y;//n是村庄个数,m是管道个数。x,y是管道的两端
    cin>>n>>m;//读入n,m
    for(int i=1;i<=n;i++)
    {
        cin>>hi[i];//读入每个村庄的海拔
        h[i]=true;//一开始没有管道
    }
    for(int i=1;i<=m;i++)
    {
        cin>>x>>y;//读入是管道的两端每个村庄一定都要有水库
        if(hi[x]>hi[y])//如果x村庄在y村庄上面
        {
            h[y]=false;//y村庄的水库不一定要建(可以由x村庄供水)
        }
        else if(hi[x]<hi[y])//如果x村庄在y村庄上面
        {
            h[x]=false;///x村庄的水库不一定要建(可以由y村庄供水)
        }
    }
    int cnt=0,ans=0;//cnt是有几个村庄一定要建水库,ansx是要建水库的村庄下标
    for(int i=1;i<=n;i++)
    {
        if(h[i]==1)//如果这个地方一定要建水库
        {
            cnt++;
            ansx=i;//由于有多个水库不用输出下标,不用特判
        }
    }
    if(cnt==1)//如果只有1个村庄一定要有水库
    {
        cout<<"Oui, j'ai trouve la solution."<<endl;
        cout<<ansx<<endl;//输出下标
    }
    else//否则
    {
        cout<<"Non"<<endl;
    }
	return 0;
}
```

时间复杂度$O(\max(n,m))$
空间复杂度$O(n)$

---

## 作者：Saliеri (赞：2)

**[P1394 山上的国度](https://www.luogu.org/problem/P1394)**

___

**直接进入正题**

题目要求所有村庄都能接受到来自水库的水

所以

如果水库建在 $i$ 处，则一定满足：

$\forall  x \in [1,n] ,x \ != i :\  height_i > height_x$

看出来没有？

需要建水库的村庄，一定是所有村庄中 **海拔最高的村庄**

贪心思想有了

在程序里排个序就好了

___

怎么样验证从水库出来的水能否到达每个村庄？

大家都讲得很清楚

一个深搜 $or$ 广搜就好了

___

时间复杂度： $\Theta(n log_2 n)$

复杂度的瓶颈在于排序

## code：
```cpp
#include <cstdio>
#include <algorithm>
int n,m,height[305],rank[305];
int head[305],tot;
struct Edge {
	int next,to;
} e[605];
struct town {
	int id,height;
} t[305];
inline void add(int x,int y) {
	e[++tot].next = head[x];
	e[tot].to = y;
	head[x] = tot;
}
bool cmp(town a,town b) {
	return a.height > b.height;
}
int vis[305];
//四行暴搜吼啊 
inline void search(int u) {
	vis[u] = 1;
	for(int i=head[u],v;v=e[i].to,i;i=e[i].next)
		if(!vis[v] && t[rank[u]].height > t[rank[v]].height)
			search(v);
	return ;
}
int main() {
	scanf("%d %d",&n,&m);
	for(int i=1; i<=n; ++i)scanf("%d",&t[i].height),t[i].id = i;
	std::sort(t+1,t+n+1,cmp);
	for(int i=1;i<=n;++i)rank[t[i].id] = i;//存一个每个i对应排序后的第几项 
	if(n==1) {
		printf("Oui, j'ai trouve la solution.\n1");
		return 0;
	}
	if(t[1].height == t[2].height) {//如果有两个最高点，则直接不可能 
		printf("Non");
		return 0;
	}
	for(int i=1,a,b; i<=m; ++i)scanf("%d %d",&a,&b),add(a,b),add(b,a);
	search(t[1].id);
	for(int i=1; i<=n; ++i)
		if(!vis[i]) {
			printf("Non");
			return 0;
		}
	printf("Oui, j'ai trouve la solution.\n%d",t[1].id);
	return 0;
}
```
~~**完结不撒花**~~

---

## 作者：皮卡丘最萌 (赞：2)

蒟蒻来水一发PASCAL题解。

I)题目的意思非常明确：水往低处流。所以当最高点有2个及以上时，直接输出Non。

例如有5个数：1 2 3 4 3，这是就直接输出Non。

II)题目输入连接的边后，仍然无法连通，直接输出Non。（这个可以用并查集来判定）

例如有6个村庄，5条边：1-2 1-3 5-6 2-3 6-4

这时就会有2个集合(1,2,3),(4,5,6),直接输出Non。

III)排除这2种情况，就直接输出最高村庄的编号。

具体看程序：

```pascal
var n,m,i,x,max,max1,max2,y,x1,y1:longint;
f:array[0..100001] of longint;
function find(x:longint):longint;          //寻找根节点
begin
if f[x]=x then exit(x);
f[x]:=find(f[x]);
exit(f[x]);
end;

begin
readln(n,m);
for i:=1 to n do
  begin
  read(x);
  if x>max then                                 //求最大
    begin max:=x; max1:=1; max2:=i; end;   //保存最大的值，个数，位置
  if (x=max)and(i<>max2) then inc(max1);      //把相同的最大值个数+1
  end;
if max1<>1 then writeln('Non')             //最高节点有多个，直接输出
  else
    begin
    for i:=1 to n do f[i]:=i;                //默认根节点为自己
    for i:=1 to m do
      begin
      readln(x,y);
      x1:=find(x); y1:=find(y);              //找祖先
      if x1<>y1 then f[x1]:=y1;               //连边
      end;
    for i:=1 to n do
      if find(i)<>find(1) then
        begin writeln('Non'); halt; end;     
                         //没有同一祖先，即没有联通，直接输出
    writeln('Oui, j',chr(ord('''')),'ai trouve la solution.');
                   //按格式输出，由于PASCAL不能直接输出'，所以比较奇怪
    writeln(max2); //输出位置
    end;
end.
```


---

## 作者：zfx_VeXl6 (赞：1)

数据实在太小了。

对于 $m$ 条边，设输入时的顺序是 $u$ 和 $v$，那么从 $u$ 和 $v$ 中选择海拔较高的那个点作为起点，另一个点作为终点，连一条单向边，表示从水从起点可以流向终点，最终的答案就是在这里建水库后水可以流向所有点的那个点。因为是有向图且图中不可能有双向边，所以这种点最多有一个，可以邻接矩阵存图，用 floyd 传递闭包解决。但是这样的时间复杂度是 $\mathcal O(n^3)$，考虑优化。

对于每个点，在建图的同时记录它的入度。这样如果某个点入度不为 $0$，说明至少有一个点的水可以流向这个点，也就说明这个点不能建水库。即水库必须建在入度是 $0$ 的点上。可以证明，入度是 $0$ 的点必然存在。

如果有多于 $1$ 个点入度是 $0$，因为水库只能建一个，如果在其中某个点建了水库，那么至少有一个点（除了建水库的那个点外其他入度是 $0$ 的点）没有水，说明无法建水库，输出 `Non`。

如果只有一个点入度是 $0$，那么如果这个点能通往其他所有的点，水库就可以建在这个点上。这个判断可以用单源最短路的思想，比原先的 $\mathcal O(n^3)$ 优。

继续优化。其实如果这个图中有且仅有一个点入度是 $0$，那么这个点就可以建水库，无需判定是否能通往其他的点。证明如下：

假设有一个图，有且仅有一个点入度是 $0$，设为 $p$ 点，但存在一个点，设为 $q$ 点，从 $p$ 出发无法到达 $q$，假设 $q$ 点唯一。因为 $q$ 的入度不为 $0$，所以必定存在至少一个点（设为 $k$）可以通向 $q$，但因为 $q$ 点唯一，所以 $k$ 点必定可以从 $p$ 点出发到达，因而 $p$ 点出发可以到达 $q$，矛盾！

证毕。代码非常简单，只需存下每个点的入度就行了，连存图都省了。复杂度 $\mathcal O(n+m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, h[301], in[301], ans;
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> h[i];
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        if (h[u] > h[v])
            in[v]++;
        else if (h[u] < h[v])
            in[u]++;
    }
    for (int i = 1; i <= n; i++)
        if (!in[i])
            if (ans) {
                cout << "Non";
                return 0;
            }
            else
                ans = i;
    cout << "Oui, j'ai trouve la solution.\n" << ans;
    return 0;
}
```

---

## 作者：万弘 (赞：1)

显然水库只可能在最高的位置,所以读入海拔时顺带找一下最高点的编号mx,存边后以mx为起点跑dfs,若有无法访问到的点就是无解,否则输出这个点的编号.

时间复杂度$O(n+m)$(可以保证至多经过每条边和每个点一次)

关于细节有两种做法:
1.  直接存双向边,dfs时判断这条边到达的点是否比当前点低;  
2.  存边时,判断两个点的海拔高低,由高点向低点引边

贴一下2的代码
```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
#define INF (1ll<<58)
ll read()
{
	ll x=0,f=1;
	char c;
	do
	{
		c=getchar();
		if(c=='-')f=-1;
	}while(c<'0'||c>'9');
	do
	{
		x=x*10+c-'0';
		c=getchar();
	}while(c>='0'&&c<='9');
	return f*x;
}
void write(ll x)
{
	if(x==0)
	{
		putchar('0');
		return;
	}
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	ll a[21],top=0;
	while(x)
	{
		a[++top]=x%10;
		x/=10;
	}
	for(ll i=top;i>=1;--i)putchar(a[i]+'0');
}

#define maxn 301
#define maxm 6001
ll n,m;
ll a[maxn];
bool vis[maxn];
struct Edge//链式前向星存边
{
	ll v,nxt;
}e[maxm];
ll cnt=0,last[maxn];
void adde(ll u,ll v)//加一条u->v的边
{
	e[++cnt].v=v;
	e[cnt].nxt=last[u];last[u]=cnt;
}

void dfs(ll u)
{
	if(vis[u])return;
	vis[u]=1;
	for(ll i=last[u];i;i=e[i].nxt)
		dfs(e[i].v);
}

int main()
{
	n=read(),m=read();
	ll mx=0;
	for(ll i=1;i<=n;++i)
	{
		a[i]=read();
		if(a[i]>a[mx])mx=i;
	}
	for(ll i=1;i<=m;++i)
	{
		ll u=read(),v=read();
		if(a[u]<a[v])adde(v,u);
		else if(a[u]>a[v])adde(u,v);
	}
	dfs(mx);
	for(ll i=1;i<=n;++i)
		if(!vis[i])
		{
			printf("Non");
			return 0;
		}
	printf("Oui, j'ai trouve la solution.\n");
	write(mx);
	return 0;
}
```

---

## 作者：我没有小白 (赞：1)

这道题不算太难，只要有一点并查集的思想就可以，我看楼下有用这个方法的，但是我的并查集比他既简单又明了，非常的亲民。emmm
代码下发
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,maxn,minn;
int high[500],fa[500],now,num;
int find(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=find(fa[x]);//这段是路径压缩并查集，大佬可以不用看 
}
int main()
{
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		cin>>high[i];//输入高度 
	for(int i=1; i<=n; i++)
		fa[i]=i;//让自己都是自己的爸爸 
	for(int j=1; j<=m; j++)
	{
		int a,b;
		cin>>a>>b;
		if(high[a]>high[b])
			maxn=a,minn=b;
		else if(high[a]<high[b])
			maxn=b,minn=a;//这段的意图是找哪一个是最高点，哪一个是最低点，如果海拔相同，就省略 
		fa[minn]=maxn;//代表maxn向minn有路 
	}
	bool u=0;
	for(int i=1;i<=n;i++)
		if(fa[i]==i)
		{
			u=1;
			now=i;
			num++;
		}//找自己的爸爸 
	if(u&&num==1)
	{
		cout<<"Oui, j'ai trouve la solution."<<endl;
		cout<<now;
	}//如果有水库并且只有一个 
	else if(num>1)cout<<"Non";//如果水库超过两个 
	else if(!u)cout<<"Non";//如果就没有水库 
}
```
这道题思路是用并查集来表示a向b有一条路径，emmm应该可以看懂吧（管理大大求过，小妹谢谢咯）

---

## 作者：CeLaMbDa (赞：0)

虽然不是最短，但我个人认为我的代码很清爽，思路如下：
1. 找到海拔最高的村庄  
题目里说了，水往低处流，那么显然要让所有的村庄都有水水库必须在海拔最高的村庄  
还有，是最高海拔村庄的**编号**（WA*2）  
2. 判断连通  
我采用了矩阵存图，这样可以非常方便的看到与某个村庄相连的村庄有哪些  
之后进行DFS，进入下一层的条件为联通$\&$海拔比所联通村庄要大（高）
3. 得出答案  
答案是什么？是从海拔最高村庄能否到达每一个村庄，所以考虑设置一个$vis$数组，如果在DFS中访问过某个村庄，那么对应$vis$设置为$true$	
最后循环遍历，如果有村庄的$vis$为$false$，那么答案为Non  
否则答案为 Oui, j'ai trouve la solution  

具体细节请参照代码！


```cpp
#include<stdio.h>
#define N 305

int dis[N][N], h[N], vis[N];
/*  dis: 存图的矩阵 
	h:   海拔，
	vis: 统计答案的 */
int n = 0, m = 0;
// 题面中的n&m

inline void dfs(int x) {
	vis[x] = true;
	for(int i = 1;i <= n;i++) {
		if(dis[x][i] && h[x] > h[i]) dfs(i);
	}
}

int main(int argc, char** args) {
	scanf("%d %d", &n, &m);
	for(int i = 1;i <= n;i++) {
		scanf("%d", &h[i]);
	}
	 
	int mx = 0, s = 0;
	for(int i = 1;i <= n;i++) {
		if(h[i] > mx) {
			mx = h[i], s = i;
		}	
	}
	
	int a = 0, b = 0;
	for(int i = 1;i <= m;i++) {
		scanf("%d %d", &a, &b);
		dis[a][b] = dis[b][a] = 1;
	}
	
	dfs(s);
	for(int i = 1;i <= n;i++) {
		if(vis[i] == false) return printf("Non\n"), 0;
	}
	printf("Oui, j'ai trouve la solution.\n");
	printf("%d\n", s);
}	
```


---

## 作者：我是py (赞：0)

好像题解中没有用spfa的

首先，我们要从最高点开始流水，如果能流到，就输出这个村庄，否则输出“Non”（个人猜测好像没有“Non”的数据）；从第一个点开始一遍spfa即可；

看代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<queue>
using namespace std;
//习惯
struct p {
	int next;
	int to;
} aaa[609];
int n,m;
int dis[309],vis[309];
int a[309];
queue<int>q;
int maxa,c;
//

//建图
int cnt;
int head[309];
void add_edge(int a,int b) {
	cnt++;
	aaa[cnt].to=b;
	aaa[cnt].next=head[a];
	head[a]=cnt;
}

int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		scanf("%d",&a[i]);
		if(maxa<a[i]) {//找到最大值，记录，一会就从这开始
			maxa=a[i];
			c=i;
		}
	}
	for(int i=1; i<=m; i++) {
		int x,y;
		scanf("%d%d",&x,&y);
		add_edge(x,y);//双向的原因是比较懒，不想判断哪高
		add_edge(y,x);
	}
    //spfa
	q.push(c);
	vis[c]=1;
	dis[c]=1;
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=head[u]; i; i=aaa[i].next) {
			int v=aaa[i].to;
			if(a[v]<a[u]) {
				dis[v]=1;
				if(!vis[v])q.push(v),vis[v]=1;
			}
		}
	}
    
	for(int i=1; i<=n; i++) {
		if(dis[i]==0) {//如果是0表示没有被访问过
			cout<<"Non";
			return 0;
		}
	}
	cout<<"Oui, j'ai trouve la solution."<<endl<<c;
	return 0;
}


```

完毕

---

## 作者：Swing_YL (赞：0)

###### 我用了个很麻烦的方法。还以为会TLE 没想到会过。
## 跑n遍最短路~~（别跟我扯）~~
~~突然很喜欢宽搜，于是手欠写了个这个~~

如果两个小国可以相互到达，则从高海拔向滴低海拔连一条有向边。

然后以每个点为起点跑一边最短路。（其实就是为了判断是否这个点可以到达所有点）
判断方式就是以它为起点，所有点的距离是否被更新。
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
#define LL long long
#define dou 0
#define mod 10000
inline void read(LL &x){
    LL f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x=x*f;
}
inline void write(LL x){
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
LL n,m;
LL a[10020];
struct node{
    LL to,nxt;
}e[40020];
bool vis[10020];
bool flag;
LL head[40010],tot;
LL dis[100020];
queue<LL> q;
void add(LL u,LL v){
    e[++tot].nxt=head[u];
    e[tot].to=v;
    head[u]=tot;
}
void bfs(LL s){
    vis[s]=1;
    dis[s]=0;
    q.push(s);
    while(!q.empty()){
        LL u=q.front();
        q.pop();
        vis[u]=0;
        for(LL i=head[u];i;i=e[i].nxt){
            if(dis[e[i].to]>dis[u]+1){//无所谓更新方式，变为0也行
                dis[e[i].to]=dis[u]+1;
                if(!vis[e[i].to]){
                    vis[e[i].to]=1;
                    q.push(e[i].to);
                }
            }
            
        }
    }
}
int main(){
    // #ifndef hammer
    // freopen("a.in","r",stdin);
    // freopen("a.out","w",stdout);
    // #endif
    scanf("%lld%lld",&n,&m);
    for(LL i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for(LL i=1;i<=m;i++){
        LL x,y;
        scanf("%lld%lld",&x,&y);
        if(a[x]>a[y]) add(x,y);//水往低处流
        else if(a[x]<a[y]) add(y,x);
    }
    for(LL i=1;i<=n;i++){
        flag=0;
        memset(vis,0,sizeof vis);
        for(LL j=1;j<=n;j++)
            dis[j]=2147483647;
        bfs(i);//计算是否所有点都能到这个点
        for(LL j=1;j<=n;j++)
            if(dis[j]==2147483647) flag=1;//不行
        if(!flag){
            printf("Oui, j'ai trouve la solution.\n");
            printf("%lld",i);
            return 0;
        }
    }
    printf("Non");
    fclose(stdin);
    fclose(stdout);
    return dou;
}
```


~~蒟蒻的题解，轻点喷~~

---

## 作者：MloVtry (赞：0)

弗洛伊德传递闭包

我们只需要找到一个点，它可以连接到所有的点

f[i][j]=f[i][j]||(f[i][k]&&f[k][j])
求出任意两点是否可以到达

然后n^2枚举，如果一个点可以到达任意一个点，那么他就可以作为水库

岚后就没什么好说的了呢

代码...

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[305],js,can[305];
int map[305][305];
void flo()
{
    for(int k=1;k<=n;++k)
    {
        for(int i=1;i<=n;++i)
        {
            for(int j=1;j<=n;++j)
            {
                map[i][j]=map[i][j]||(map[i][k]&&map[k][j]);
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) map[i][i]=1,scanf("%d",&a[i]);
    for(int i=1;i<=m;++i)
    {
        int u,v;scanf("%d%d",&u,&v);
        if(a[u]==a[v]) continue;
        map[u][v]= a[u]>a[v];
        map[v][u]= a[v]>a[u];
    }
    flo();
    js=n;
    for(int i=1;i<=n;++i)
    {
        can[i]=1;
        for(int j=1;j<=n;++j)
        {
            if(!map[i][j])
            {
                can[i]=0;js--;
                break;
            }
        }
    }
    if(js)
    {
        printf("Oui, j'ai trouve la solution.\n");
        for(int i=1;i<=n;++i) if(can[i]) printf("%d ",i);
    }
    else printf("Non");
    return 0;
//今天也依旧没有捞到厌战47呢....
}
```

---

## 作者：fastle (赞：0)

对于n的范围，我们只需要用邻接矩阵存边即可，而且由于水只能往低处流，我们可以对于每条边只从高处向低处建边，

同理，我们也不需要对于所有的点都dfs，只需要找到最高的点从这个点深搜一遍即可，因为从更低的点一定不能流到这个点

-。-渣代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int high[301];
int map[301][301];
int n,m,maxx=-1;
int tot=0;
bool visited[301];
void dfs(int x)
{
    tot++;
    for(int i=1;i<=n;i++)
    {
        if(map[x][i]&&!visited[i])
        {
            visited[i]=true;
            dfs(i);
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&high[i]);
        maxx=max(maxx,high[i]);
    }
    for(int i=1;i<=m;i++)
    {
        int vi,vj;
        scanf("%d%d",&vi,&vj);
        if(high[vi]>high[vj])map[vi][vj]=1;
        if(high[vi]<high[vj])map[vj][vi]=1;
    }
    for(int i=1;i<=n;i++)
    {
        if(high[i]==maxx)
        {
            visited[i]=1;
            dfs(i);
            if(tot==n)
            {
                printf("Oui, j'ai trouve la solution.\n%d",i);
            }
            else
            printf("Non");
            return 0;
        }
     } 
    return 0;
}
```

---

## 作者：ws_fuweidong (赞：0)

图论dfs水题

我们可以反向建边，那么就是求所有点都能到达的点。

代码如下

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define maxn 301
using namespace std;
int head[maxn],next[maxn],list[maxn],vis[maxn],h[maxn];
int n,m,cnt=0;
int bz[maxn]={0};
void add(int u,int v){
    next[++cnt]=head[u];
    list[cnt]=v;
    head[u]=cnt;
}
void dfs(int o){
    vis[o]=1;
    int t=head[o];
    bz[o]++;//如果能到达就+1，bz[i]=n的话就是所有点都搜到了这个点，就是水库啦O(∩_∩)O~
    for (int i=head[o];i;i=next[i])
    if (!vis[list[i]])dfs(list[i]);
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    scanf("%d",&h[i]);
    for (int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        if (h[x]<h[y])//反向建边，以便于从终点找源头
        add(x,y);
        if (h[x]>h[y])
        add(y,x);
    }
    for (int i=1;i<=n;i++){
        memset(vis,0,sizeof(vis));
        dfs(i);//搜
    }
    for (int i=1;i<=n;i++)//输出
    {
        if (bz[i]==n){
            printf("Oui, j'ai trouve la solution.\n");
            printf("%d",i);
            return 0;
        }
    }
    printf("Non");
    return 0;
}
```

---

## 作者：NeilWang (赞：0)

膜一下各位图论大佬。。。

但是为什么没有并查集 :(

蒟蒻用并查集a了

```cpp
#include<cstdio>
#include<queue>
using namespace std;
int father[1000];//记录并查集的数组
int getf(int n)//对节点寻亲
{
    if(father[n]==n)//自己是自己的爹
    {
        return n;
    }
    father[n]=getf(father[n]);//路径压缩
    return father[n];
}
void createf(int s,int f)//让节点s认f为爹
{
    father[s]=f;
    return;
}
int main()
{
    int n,m;
    int height[1000];
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&height[i]);
    }
    int temp1,temp2;
    for(int i=0;i<1000;i++)
    {
        father[i]=i;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&temp1,&temp2);
        if(height[temp1]<height[temp2])//temp1比temp2低，则temp2是temp1的爹
        {
            createf(temp1,temp2);
        }
        if(height[temp2]<height[temp1])//同理
        {
            createf(temp2,temp1);
        }
    }
    int flag=0;//flag为1则是失败
    for(int i=2;i<=n;i++)
    {
        if(getf(i)!=getf(i-1))//如果不是同一个爹
        {
            //printf("%d %d",getf(i),getf(i-1));
            flag=1;//失败
            break;
        }
    }
    if(flag)
    {
        printf("Non\n");
        return 0;
    }
    printf("Oui, j'ai trouve la solution.\n");
    printf("%d\n",getf(1));//成功了，输出随便一个节点的爹（反正都一样）
    return 0;
}
```

---

## 作者：dwch (赞：0)

记录最高点的序号，如果有不止一个最高点肯定无解；在只有一个最高点的情况下，如果这个点能访问每一个点，那么这个点就是符合要求的。

细节自己看代码咯2333弗洛伊德算法可以用来求两点能否通行，用can[i][j]表示从i可不可以到j（如果can[i][j]==1那么can[j][i]一定是0，原因自己想）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int n,m,maxn=1;
    cin>>n>>m;
    int h[n+2];
    for(int i=1;i<=n;++i)
        {
            cin>>h[i];
            if(h[i]>h[maxn])
                maxn=i;
        }
    bool can[n+1][n+1];
    memset(can,0,sizeof can);
    for(int i=1;i<=n;i++)
        can[i][i]=1;
    while(m--)
    {
        int x,y;
        cin>>x>>y;
        if(h[x]>h[y])
            can[x][y]=1;
        else if(h[y]>h[x])
            can[y][x]=1;
    }
    for(int k=1;k<=n;++k)
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
                can[i][j]=can[i][j]||(can[i][k]&&can[k][j]);
    for(int j=1;j<=n;j++)
        if(!can[maxn][j])
        {
            cout<<"Non";
            return 0;
        }
       cout<<"Oui, j'ai trouve la solution.\n"<<maxn;
       return 0;
}
```

---


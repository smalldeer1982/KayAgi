# 卡布列克圆舞曲

## 题目描述

卡布列克是一位数学家，他在研究数字时发现：任意一个不是用完全相同数字组成的四位数，如果对它们的每位数字重新排序，组成一个较大的数和一个较小的数，然后用较大数减去较小数，差不够四位数时补零，类推下去，最后将变成一个固定的数：$6174$，这就是卡布列克常数，例如：

$4321-1234=3087$。

$8730-378=8352$。

$8532-2358=6174$。

$7641-1467=6174$。

如果 $K$ 位数也照此办理，它们不是变成一个数，而是在几个数字之间形成循环，称作卡布列克圆舞曲。例如对于五位数 $54321$：

$54321-12345=41976$。

$97641-14679=82962$。

$98622-22689=75933$。

$97533-33579=63954$。

$96543-34569=61974$。

$97641-14679=82962$。

我们把 $82962,75933,63954,61974$ 称作循环节，即卡布列克圆舞曲。

## 样例 #1

### 输入

```
4321
54321
```

### 输出

```
6174
82962 75933 63954 61974
```

# 题解

## 作者：x_faraway_x (赞：13)

比较繁琐的一道模拟题……

这题就是把数拆分+排序，将组合成的最大值和最小值的差放进数组，如果发现重复就直接从重复的地方到尾输出即可结束

###这题有两个地方要格外注意

**1.要用long long！**

**2.读入的n也可能成为循环的一部分，因此也要放入数组！**

具体见代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL; //该用long long的地方一定要用long long！
int ind;
LL a[100000], n;
int main() {
    while(cin >> n) { //多组数据，用cin读入可以在文件结束时停止
        ind = 0;
        a[++ind] = n; //注意：读入的n也可能是循环的一部分！
        bool flag = true;
        while(flag) {
            LL b[20]={0}, n1 = 0, n2 = 0;
            int in = 0;
            while(n) { //拆分数
                b[++in] = n % 10;
                n /= 10;
            }
            sort(b+1, b+1+in); //排序
            for(int i = 1; i <= in; i++) n1 = n1*10+b[i]; //组合成最小数
            for(int i = in; i >= 1; i--) n2 = n2*10+b[i];  //组合成最大数
            n = n2-n1;
            for(int i = 1; flag && i <= ind; i++) //寻找
                if(a[i] == n) { //若发现重复
                    flag = false; //可以跳出循环，结束搜索
                    for(int j = i; j <= ind; j++) //从重复的地方开始到数组结尾都是循环部分，输出即可
                        cout << a[j] << " ";
                }
            a[++ind] = n; //将新组合成的数放进数组
        }
        puts("");
    }
    return 0;
}
//祝大家早日AC！
```

---

## 作者：RiverHamster (赞：6)

##STL! 使用<vector>存储数据，<algorithm><functional>排序，<sstream>转化为string，好处在于直接用stringstream转换为string，就不用数字分离了。

###使用long long，否则只能得10分

###用了STL这题还是很水的，直接转换+排序+查找就可以了，为什么vector没有find()?

```cpp
#include <iostream> //输入输出库 
#include <algorithm>//排序 
#include <functional>//排序依据 
#include <vector>//数据存储 
#include <sstream>//数据转换 
using namespace std;
typedef long long ll;//使用long long 
stringstream io;     //转换，记得不要每次都要创建一个stream对象，构造函数比较慢 
string buffer;       //临时字符串 
ll mxsort(ll n){   //最大的排列 
    io.clear();     
    buffer.clear(); //清空 
    io<<n;   //将n插入到流中 
    io>>buffer; //转入string 
    sort(buffer.begin(),buffer.end(),greater<char>()); //对string进行排序，从大到小 
    io.clear();  //再清空 
    io<<buffer;  //把排序过的字符串输入到流中 
    io>>n;  //将流中排好序的数字输出到整数中 
    return n; //返回 
}

ll mnsort(ll n){
    io.clear();
    buffer.clear();
    io<<n;
    io>>buffer;
    sort(buffer.begin(),buffer.end(),less<char>()); //同mxsort()函数，但排序规则从greater变成了less，从小到大排序 
    io.clear();
    io<<buffer;
    io>>n;
    return n;
}

void work(ll n){
    vector<ll>a;
    a.push_back(n); //先将原来的数放进去存储 
    int i=0;
    while(1){  //一直做 
        a.push_back(mxsort(a[i])-mnsort(a[i])); //把数据放进去 
        for(int t=0;t<=i;t++) if(a[i+1]==a[t]) {for(int k=t;k<=i;k++) cout<<a[k]<<' '; cout<<endl; return;} //查找数据并输出，直接用return返回 
        i++;  
    }
}

int main(){
    ll n;
    while(cin>>n) work(n); //每输入一个做一个，一直到eof，循环就会停止，命令行调试时最后要手动按一个Ctrl+Z(eof)
    return 0; 
}
```
###By RiverHamster


---

## 作者：政凯 (赞：4)

    First，因为我们不知道他要输出多少个n，我们可以用while (cin>>n)
    
    Then（这是求出数的步骤）
    ① 把组成这个几位数的数字取出来，放到数组里，从小到大排序
    ② 从小到大组合，再从大到小组合
    ③ 求出以上两数之差，得到一个新的几位数。 
    
    Finally，先在b数组看一下新求出的数有没有出现，如果有把之前出现的数和之前出现的数的后面都输出（因为这就是卡布列克圆舞曲）；否则把新求出的数放j进b数组

------华丽的分割线------
```cpp
#include <iostream>
#include<cstdio>
#include<string>
#include<algorithm>
using namespace std;
long long n,gs,b[900000+5],p,aaa,bbb,n1,ws1,a[1000+5];
int main()
{
	while (cin>>n)
	{
        gs=1;b[1]=n;p=0;
        while (1)
        {
    	    n1=n;
    	    ws1=0;aaa=0;bbb=0;//aaa是重新排序较小的数，bbb是重新排序较小的数
    	    while (n1!=0)//把数字取出来，放到数组里
    	    {
    	    	ws1++;a[ws1]=n1%10;n1/=10;
    	    }
    	    sort(a+1,a+1+ws1);//排序
    	    for (int i=1;i<=ws1;i++) aaa=aaa*10+a[i],bbb=bbb*10+a[ws1-i+1];//组合
    	    n=bbb-aaa;//求出新的数
    	    for (int i=1;i<=gs;i++)
			{
			    if (b[i]==n) p=1;//已找到开头
			    if (p==1) printf("%lld ",b[i]);//说明卡布列克圆舞曲已出现
			}
			gs++;b[gs]=n;//把它塞进数组里
			if (p==1){ printf("\n");break;}
        }
    }
    return 0;
}


```


---

## 作者：Warriors_Cat (赞：4)

## ~~不敢相信有这么难的模拟题~~

没错，这的的确确是一个模拟题！

作为一名C++专业选手，肯定是要来一波STL的。

这道题就很适合用一个STL里面的一个容器，Ta就是：

### vector！

vector，说得通俗一点，就是一个动态数组，没有规定长度，Ta适用于不定长的数组中来。

vector的定义如下：

vector</*加一个类型*/>v;

当然需要有头文件#include<vector>~~（或者用万能头）~~。

vector经常用到下面3种函数：
  
v.push_back(data)：将data存到v里面
  
v.size()：算出v的长度
  
（P.S.这里补充一个说明，像字符串，vector这些，它们的size函数的类型都不是int，导致LG评测机会出现一些警告，所以最好在size函数前面加上一个（int），这样就不会出问题了）
  
v.clear()：将v的数全部移除
  
下面进入正题（终于进入正题啦）
  


------------
本蒟蒻对于此题的思路如下：
  
每次求出最大极值与最小极值的差，存到vector里；
  
然后寻找有没有出现循环；
  
有则输出，无则继续；
  
每一次输出完就清零；
  
## 代码准备：
  
```
#include<bits/stdc++.h>//习惯用万能头 
using namespace std;
long long n, a[30], len, x, y, t, k;
//一堆乱七八糟的变量QwQ 
vector<long long>v;//开一个long long类的vector 
void mem(){//清除函数 
    k = 0;//位置清零 
	v.clear();//将vector里面的数清零 
	len = 0;//长度变为0 
	return;//拜拜！ 
}
void work(long long n){//求最大极值与最小极值之差函数 
	len = 0;//长度清零 
	while(n != 0){
		a[++len] = n % 10;
		n /= 10;
	}//不用多讲了吧，就是数位分离 
	sort(a + 1, a + len + 1);//排序一遍 
	x = 0; y = 0;//将最大极值和最小极值清零 
	for(int i = 1; i <= len; ++i){
		x = x * 10 + a[i];
	}//求最小极值 
	for(int i = len; i >= 1; --i){
		y = y * 10 + a[i];
	}//求最小极值 
	t = y - x;//将其之差存到t里面 
	return;//再见！ 
}
long long find(long long t){//寻找函数 
	for(int i = 1; i <= (int)v.size() - 1; ++i){
		if(v[i] == t) return i;//有则返回位置 
	}
	return 0;//无则返回0 
}
int main(){
	mem();//清零 
	v.push_back(-1);//存个-1,习惯从1开始遍历 
	while(scanf("%lld", &n) == 1){//当输入时 
		v.push_back(n);//先存进去 
		while(!k){//当k为0是 
			long long num = v[v.size() - 1];//去最后的值 
			work(num);//构造极值 
			k = find(t);//找到位置 
			if(k != 0) break;//k不为0则退出 
			v.push_back(t);//将极值塞进vector里 
		}
		for(int i = k; i <= (int)v.size() - 1; ++i){
			printf("%lld ", v[i]);
		}//输出循环部分 
		printf("\n");//别忘了换行 
		mem();//清零 
		v.push_back(-1);//把-1放进去 
	}
	system("pause");//日常防伪代码 
	return 0;//拜拜 
}
```
STL最巨！！ STL最强！！
  
所以，各位C++选手不要忘了还有STL在为你撑腰。
  
## 求过！！
  
### 重要的事情说“一”遍！

谢谢各位读者的阅读以及管理员的审阅。

---

## 作者：SUNCHAOYI (赞：3)

## 这是一道比较复杂的模拟题，读完题后按题意进行操作即可

**本题难点即怎样对它们的每位数字重新排序，组成一个较大的数和一个较小的数，然后用较大数减去较小数与确定循环节**

**第一个问题解答：对一个数进行每位的分离**
```
while (n >= 1)
{
    b[++j] = n % 10;
    n /= 10;
}
```
**然后排序（从小到大），这样最大数与最小数只要分别从后往前与从前往后循环就能得到。最后作差得到新数**
```
for (int p = 0;p <= j;p++)_min = _min * 10 + b[p]; 
for (int p = j;p >= 0;p--)_max = _max * 10 + b[p]; 
n = _max - _min;
```

------------

**第二个问题的解答：设定一个数组，每次加入新数前循环判断是否与之前重复**

**是：输出从这个数到最后这一段循环节**

**否：把数存入数组**

**实现：**
```
for (int p = 1;p <= i;p++)
{
    if (a[p] == n)
	{
		for (int q = p;q <= i;q++) cout<<a[q]<<" ";
		cout<<endl;
		ok = 1;break;
	}
}
a[++i] = n;
```

------------

**Tips:文件包含若干行，每行为一个待求“卡布列克圆舞曲”的起始整数（小于maxlongint）**

**注意数据类型，有些需要开long long，否则会WA**

------------

## 完整代码
```
#include <iostream>
#include <algorithm>
using namespace std;
const int MAX = 20;
const int MAXN = 100000;
int main()
{
	int b[MAX]; 
    long long n,a[MAXN],_max,_min;//注意数据类型 
    while (cin>>n)
    {
        int i = 0;a[++i] = n;
        bool ok = 0;
        while (!ok)
        {
            int j = -1;
            b[MAX] = {0};
            _max = _min = 0;
            while (n >= 1)
            {
                b[++j] = n % 10;
                n /= 10;
            }//记录每一位数字 
            sort (b,b + j + 1);//排序 
            //不同的循环确定数的大小(min与max) 
            for (int p = 0;p <= j;p++)_min = _min * 10 + b[p]; 
            for (int p = j;p >= 0;p--)_max = _max * 10 + b[p]; 
            n = _max - _min;//大数减小数 
            for (int p = 1;p <= i;p++)
            {
                if (a[p] == n)//如果重复 
                {
                    for (int q = p;q <= i;q++) cout<<a[q]<<" ";//输出循环节 
                    cout<<endl;
                    ok = 1;//标记 
                    break;
                }
            }
            a[++i] = n;//加入新数 
        }
    }
    return 0;
} 
```


---

## 作者：AdzearDisjudge (赞：2)

首先数据并没有出现“数位不够，补0”的情况（小心！其实像1112这样的数据不补0会：2221-1112=999==>999-999=0==>0-0=0，输出0。这样到别的地方会被hack掉的）。

其次思路就是读取之后存数组，分离数位+排序的最大最小值，相减结果存数组，从头到尾查找重复。

AC代码//其实是有bug的哦

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a[66],b[100001],n,m,pa,pb,mi,ma;
void init()
{
    memset(a,0,sizeof(a));
    memset(b,0,sizeof(b));
    b[1]=n;
    pa=1;
    pb=2;
    return;
}
void div(ll t)
{
    ll s=t;
    while(s>9)
    {
        a[pa]=s%10;
        s/=10;
        ++pa;
    }
    a[pa]=s;
    ++pa;
    return;
}
int main()
{
    while(cin>>n)
    {
        init();
        m=n;
        while(1)
        {
            bool bb=false;
            div(m);
            sort(a+1,a+pa);
            mi=0;
            ma=0;
            for(register ll i=1;i<pa;++i)
            {
                mi=mi*10+a[i];
                ma=ma*10+a[pa-i];
            }
            b[pb]=ma-mi;
            for(register ll i=1;i<pb;++i)
            if(b[i]==b[pb])
            {
                for(register ll j=i;j<pb-1;++j)
                cout<<b[j]<<' ';
                cout<<b[pb-1]<<endl;
                bb=true;
                break;
            }
            if(bb)
            break;
            m=b[pb];
            ++pb;
            pa=1;
        }
    }
    return 0;
}
```

---

## 作者：zmza (赞：1)

[最优解](https://www.luogu.com.cn/record/39641431)\
这题是纯模拟。注意要看数据范围，要开long long。把数拆分+排序，将组合成的最大值和最小值的差放进数组，如果发现重复就直接从重复的地方到尾输出即可结束。\
过程:
首先，我们先把这个数的数字算出来，一位一位排序，然后在组成数。接着，再将这个数和原数相减。如果差在之前出现过，就跳出循环，输出。这题存在多组数据，所以就用while(cin >> x)就可以了。

具体过程看代码。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//别忘了开long long！
int a[10000],x;
int n,p;
bool flag;
int f(int x)//用来转换再相减
{    
	int b[20],p = 0;
	while(x)//把每一位都拆出来
	{
		p++;
		b[p] = x % 10;
		x /= 10;    
	}
	int y = 0;
	x = 0;
	sort(b + 1,b + p + 1);//然后排序
	for(int i = 1; i <= p; i++)//再次组合
		x = x * 10 + b[i];
	for(int i = p; i >= 1; i--)//再次组合
		y = y * 10 + b[i];
	return y - x;//返回差值
}
signed main()
{
	while(cin >> x)//有多组输入
	{
		a[1] = x;//初始化
		p = 1;
		flag = 0;
		while(!flag)
		{
			p++;
			a[p] = f(a[p - 1]);//赋值
			for(int i = 1; i < p; i++)//循环判断是否出现过
			if (a[p] == a[i])//如果出现过就输出，标记一下，跳出循环。
			{
				for (int j = i; j < p - 1; j++)//输出
					cout << a[j] << " ";
				cout << a[p - 1] << endl;//别忘了输出最后一个数，再加一个换行！
				flag = 1;//标记
				break;//跳出
			}
		}
	}
	return 0;   
}

```


---

## 作者：CherryPockyOvO (赞：1)

### 安利一个用 STL map的做法
~~什么你说你map还不会，自己百度去~~ 

map也是比较基础的东西了，映射……

我们在本题开两个map (idft,dft)

idft 通过当前的数来访问该数的编号

dft 根据编号来访问该数

其实这两货就是相互对应的，因为数比较大，idft就很有用了

这里的dft随时都可以换成一个普通的数组

~~别问我为什么不换，懒~~

其实主要是不想考虑数组开的大小而已…………QAQ

### 好了，我们说正解：

我们对每一个数P对它给予一个编号pos

在dft里将pos映射为P，idft里将P映射为pos

之后出现循环的数，dft[P]不为空则说明已出现该数，就直接把这一段数取出来输出就行了…………

剩下只需要每次改变数P就行了…………可以看代码，没啥好讲的。

~~不就是把数取出来排个序，再组合起来的事嘛~~

### 详情见代码
```cpp
#include<cstdio>
#include<map>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;
ll Q;
int De[100];
map<int,ll> dft;
map<ll,int> idft;
bool cmp(int a,int b){ return a>b; }
ll Cha(ll x){
	ll res=0,Up=1,f=0,res2=0;
	while(x) De[++f]=x%10,x/=10; //把数拆分 
	sort(De+1,De+f+1,cmp); //排序…… 
	for(int i=1;i<=f;i++){
		res+=Up*De[i]; //最小数 
		res2+=Up*De[f-i+1]; //最大数 
		Up=(Up<<3)+(Up<<1); // 就是Up=Up*10了 
	}
	return res2-res;
}
signed main()
{
	while(scanf("%lld",&Q)!=EOF){
		int top=0; //编号 
		dft.clear(); 
		idft.clear(); //每次做完把map清空 
		while(!idft[Q]){ //额，看这个数是否出现，一直做下去。 
			idft[Q]=++top; //Q -> top 
			dft[top]=Q; //top -> Q
			Q=abs(Cha(Q)); //求下一个Q 
		}
		for(int i=idft[Q];i<=top;i++) //idft到top正好就是一组答案 
		printf("%lld ",dft[i]);
		printf("\n");
	}
	return 0;
}
```
完结撒花(^-^)

---

## 作者：__int (赞：1)

题目较易理解，代码实现可能难点。
下面上AC代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long d[15],j,b1,b2,a1,m[101];//m数组存fx()的各数
long long fx(long a)
{
	memset(d,0,sizeof(d));
	a1=a;j=0;b1=0;b2=0;
	while(a1!=0)
	{			//数位分离
		d[++j]=a1%10; 
		a1/=10;
	}
	sort(d+1,d+1+j);//数位排序
	for(int i=1;i<=j;i++)
	{
		b1*=10;b1+=d[i];//最小组成数
		b2*=10;b2+=d[j+1-i];//最大组成数
	} 
	return b2-b1;
}
int main() 
{
	long long a;
	while(cin>>a)//循环输入
	{
		long long as=a,c=0,i=1;;
		bool fm=false; //false代表没有输出
		m[0]=a;//注意原数可能是圆舞曲的首位
		m[1]=fx(a);
		while(fm==false)
		{
			i++;
			m[i]=fx(m[i-1]);
			for(int j=0;j<i;j++)
			{		//与前面的数一一对比，若与m[i]相同则圆舞曲已构成
             //且j为首位，i为末位
				if(m[j]==m[i]) 
				{
					for(int k=j;k<i;k++)//循环输出圆舞曲
					cout<<m[k]<<' ';
					fm=true;
					break;
				}
			}
		}
		cout<<endl;
	}
}
```


---

## 作者：反比例函数 (赞：1)

# P1532 卡布列克圆舞曲 解题报告
蒟蒻的第三篇题解~

反比例函数的思路与大多数人不同，主要原因是在本人刚学OI时懒得打数位分离，每次遇到数位重排的题就直接上字符串。本题的思路正是由此而生。

虽然反比例函数是C++选手，但题解中使用的是C风格字符串，某些C++选手可能阅读起来有轻微困难，因此讲解较详细，请耐心阅读。

## 算法：
没什么好说的，就是大模拟，属于比较复杂的那种。

## 思路：
输入、数位重排使用C风格字符串（暴力sort），计算两数之差时将其转换为`long long`型整数（注意一定是**longlong**，否则~~见祖宗~~只有10分），将每次计算出的数存储在a数组中，发现a数组有两相同数时输出。

## 技术：
将C字符串转换为（长）整形可用`atoi()`函数，该函数会自动将遇到的连续数字转换为整型数，遇到非数字字符则停止。

`atoi()`函数返回的是转换后的数，因此你应该这样写：
```cpp
char s[]="998244353";//不用管这是什么数字
int n;
n=atoi(s);
```
事实证明`atoi()`函数有时会出现玄学错误（比如我们在这道题中要用到longlong，由于本人一开始用`atoi()`一直爆零，改成了`sprintf()`才好）

对了，刚才提到了`sprintf()`函数，它的定义如下：
```cpp
int sprintf(char *string, char *format [,argument,...])
```
看，多像我们几乎天天用的printf，只是前面多了一个`char *string`。因此你应该这样写：
```cpp
char s[]="998244353";
int n;
sprintf(s,"%d",n);
```
但在这个程序中还涉及数字转字符串，于是你会想：有没有`itoa()`函数？

答案是：有。但对不起，你没法用，因为那不是标准函数，Linux下不能用。

怎么办？

这时候该请出~~伟大的~~`sscanf()`了！

类比前面的sprintf，`sscanf()`比起scanf只多前面的一个`char *string`，它的功能是将一些数据（来自其他变量）输入字符串。你可以这样写：
```cpp
char s[100];
int n=998244353;
sscanf(s,"%d",&n);//不要漏掉n前的&，就像使用scanf一样！
```

## 代码实现
```cpp
//为了保险，我在做题时几乎将所有的int全改了longlong
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
long long a[10005],m,n,cnt=0;
bool cmp(char x,char y)
{   return x>y;}
bool inarray(long long c[],long long x)//判断数组中是否有相同数据
{   for(int i=1;i<cnt;i++)
      if(c[i]==x) return true; 
    return false;}
long long ffind(long long c[],long long x)//寻找数组中相同数据的位置
{   for(int i=1;i<cnt;i++)
      if(c[i]==x) return i;
    return -1;}
int main()
{
    char s[100];
    long long i,len;
    memset(a,0,sizeof(a));//以防万一
    while(scanf("%s",&s)!=EOF)
    //由于题面没说多少组，我们应用while输入；同时为了省时间使了用scanf。
    //不能像写cin那样，直接写while(scanf("%s",s))，这样会死循环
    //EOF的意思是end of file，也就是输入结束
    //在本地操作时可以在控制台里输入Ctrl+Z停止输入
    {   a[++cnt]=atoi(s);//这一步就是90分到100分的关键！你输入的数可能就是循环节的一部分！
A:      len=strlen(s);
        sort(s,s+len);//排序，s是最小
        char t[100];
        strcpy(t,s);//把s的值赋给t，t是最小
        sort(s,s+len,cmp);又排了一次，s变成最大
        //m=atoi(s),n=atoi(t);  你也可以这样写，但atoi()有危险，不要随便用于longlong
        sscanf(s,"%lld",&m);sscanf(t,"%lld",&n);//字符串变整型
        m-=n;//减
        char tmp[100];
        sprintf(tmp,"%lld",m);
        if(strlen(tmp)<len) m*=10;
        //这是对类似4333-3444=999的特判，位数不够就补0的一步。所幸数据并没有那么毒瘤，不写也不要紧
        a[++cnt]=m;
        if(inarray(a,m))
        {   for(i=ffind(a,m);i<cnt;i++) cout<<a[i]<<' ';
            cout<<endl;
            memset(a,0,sizeof(a));cnt=0;
            continue;}//找到了，输出，清空，再等输入
        memset(s,0,sizeof(s));
        sprintf(s,"%lld",m);//整数变字符串
        goto A;}//此处我最终还是选择了容易出错的goto，因为简洁；
        //但不建议大量使用goto，会出玄学错误。
    return 0;
}

```

---

## 作者：courage (赞：1)

直接模拟即可。每次产生新数就检查是否已经出现过，如已经出现则输出循环节。需要注意细节。

另外，为了防止溢出，我使用了long long

```cpp

#include<cstdio>
#include<algorithm>
long long a[10000],x;
int n,p;
bool flag;
long long f(long long x){
    int b[20],p=0;
    while (x){
        p++;
        b[p]=x%10;
        x/=10;
    }
    long long y=0;
    x=0;
    std::sort(b+1,b+p+1);
    for (int i=1;i<=p;i++) x=x*10+b[i];
    for (int i=p;i>=1;i--) y=y*10+b[i];
    return y-x;
}
int main(){
    while (scanf("%I64d",&x)!=EOF){
        a[1]=x;
        p=1;
        flag=0;
        while (!flag){
            p++;
            a[p]=f(a[p-1]);
            for (int i=1;i<p;i++) if (a[p]==a[i]){
                for (int j=i;j<p-1;j++) printf("%I64d ",a[j]);
                printf("%I64d\n",a[p-1]);
                flag=1;
                break;
            }
        
        }
    }
}

```

---

## 作者：_caiji_ (赞：0)

这道题有一个很坑的地方：

>差不够四位数时补零。

但实际上我们并不需要补零。举个例子，$45$ 是这样变化的：
$$
\begin{aligned}
54-45&=9\\
9-9&=0\\
0-0&=0\\
\cdots
\end{aligned}
$$
而不是
$$
\begin{aligned}
54-45&=(0)9\\
90-(0)9&=81\\
81-18&=63\\
\cdots
\end{aligned}
$$
回归正题。这道题就是用`while(cin>>n)`或`while(~scanf("%d",&n)`读入数据，然后把数字拆开，算出最大值与最小值的差，存入数组。如果发现重复，就把重复的部分输出。

注意，题目说`小于maxlongint`，但你还是要开`long long`，不然出现 $9876543210-123456789$ 的情况就爆`int`了。

下面给出代码：
```cpp
#include <cstdio>
#include <algorithm>
using std::scanf;
using std::printf;
#define int long long//嫌麻烦可以这样写
#define rep(i,l,r) for(int i=(l),end##i=(r);i<=end##i;i++)
//define的用法，从l到r的循环，其中end##i表示把"end"和i强行以字符串形式拼接
#define dwn(i,l,r) for(int i=(l),end##i=(r);i>=end##i;i--)
//这是上面的rep倒过来
template<class T>//为了能移植使用template
class Vector{//STL的vector常数很大，所以我们手写
    //原理：每次push_back就a[++len]，清空len=0，长度就是len，不用担心这个数组会RE或MLE
	private://private，私人的，这些元素不能在外面直接访问
		int len;
		T a[100010];
	public://public，公共的，这些函数可以直接使用
		Vector(){//构造函数，清空
			clear();
		}
		T& operator[](int x){//重载[]运算符，这样就可以访问a数组了
			return a[x];
		}
		void clear(){//清空
			len=0;
		}
		int size(){//长度
			return len;
		}
		void push_back(T x){//push_back
			a[++len]=x;
		}
};
Vector<int> num;//存拆出来的数字
int cha(int a){//把操作封装
	if(a==0) return 0;//特判
	for(num.clear();a;a/=10)
		num.push_back(a%10);//拆数字的简写
	std::sort(&num[1],&num[num.size()+1]);//给数字排序，注意这个+1
	int maxn=0,minn=0;
	rep(i,1,num.size()) minn=minn*10+num[i];
	dwn(i,num.size(),1) maxn=maxn*10+num[i];
	return maxn-minn;
}
int n;
Vector<int> xh;//存循环
signed main(){//#define int long long后就一定要signed main，不然会CE
	while(~scanf("%lld",&n)){//scanf输入不了数时会返回EOF(-1)，然而~-1=0
		xh.clear();
		xh.push_back(n);//n也有可能是循环节的一部分
		bool flg=1;
		while(flg){//约等于while(1)不过可以修改flg让它跳出来
			int tmp=cha(xh[xh.size()]);//求差
			xh.push_back(tmp);
			rep(i,1,xh.size()-1){//注意这个-1，新的数不能一起找
				if(xh[i]==tmp){//找到重复的，说明循环的了
					rep(j,i,xh.size()-1){//输出
						printf("%lld ",xh[j]);
					}
					std::puts(""),flg=0;break;//换行，跳出for和while
				}
			}
		}
	}
	return 0;
}
```
### 一 定 要 开 `long long`！！！
### 一 定 要 开 `long long`！！！
### 一 定 要 开 `long long`！！！

---

## 作者：EuphoricStar (赞：0)

此题就是一道纯模拟。

大致思路：读入起始整数，之后循环调用 `nxt()` 函数求出该数的下一个数，并将结果存入数组。

接下来查找数组中除刚刚添加的数以外还存不存在这个数，如果存在直接输出循环节。

那么 `nxt()` 函数具体该如何实现呢？

我们可以借助一个 STL：stringstream 实现字符串与整数之间的相互转换。

首先将整数转化为相同的两个字符串，然后排序，一个从小到大，一个从大到小。

之后将两个字符串去除前导 $0$ 后分别转为整数，用大数减去小数即可。

注意事项：

- **不开 long long 见祖宗！**

- **起始整数也可能成为循环节的一部分，所以起始整数也要添加进数组！**

代码如下（细节见注释）：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll num, tmp[1000], len;

// 去除字符串的前导 0
string front0(string x)
{
    for (int i = 0;; ++i)
        if (x[i] != '0') return x.substr(i);
}

ll nxt(ll x)
{
    stringstream ss, tt;
    ss << x, tt << x;
    string s = ss.str(), t = tt.str();
    // 从小到大排序
    sort(s.begin(), s.end());
    // 从大到小排序
    sort(t.begin(), t.end(), greater<char>());
    ll big, small;
    ss.str(front0(s));
    ss >> small;
    tt.str(front0(t));
    tt >> big;
    return big - small;
}

// 查找数组中除最后一个数以外是否存在 x
int find(ll x)
{
    for (int i = 0; i < (len - 1); ++i)
        if (tmp[i] == x) return i;
    return -1;
}

int main()
{
    ios::sync_with_stdio(0);
    while (cin >> num)
    {
        len = 0;
        // 清空数组
        memset(tmp, 0, sizeof(tmp));
        // 将起始数字添加进数组
        ll nextnum = num;
        tmp[len++] = nextnum;
        while (1)
        {
            // 不断求出下一个整数
            nextnum = nxt(nextnum);
            tmp[len++] = nextnum;
            // 查找
            int idx = find(nextnum);
            if (idx != -1)
            {
                 // 输出循环节并退出
                 for (int i = idx; i < (len - 1); ++i) cout << tmp[i] << ' ';
                 cout << '\n';
                 break;
            }
        }
    }
    return 0;
}
```


---

## 作者：iorit (赞：0)

[原题](https://www.luogu.com.cn/problem/P1532)

一道较难搞的模拟

因为蒟蒻不会~~奇奇怪怪的~~STL

所以都是手打的

### 思路

一个数组b存储操作过程中的数

每次扫一遍判断是否开始循环

如果循环：

记录循环开始的位置k

从k开始到总操作次数len - 1(第len个循环了)输出b[i]

否则：

len++，记录当前数用于下一次判断循环。

### 代码

```cpp
// 此处应有头文件
int a[105]; // 将数倒入数组方便处理 
long long b[100005]; // 存储过程
bool cmp(int a,int b)
{
    return a > b;
}
long long max_(long long n)
{
    memset( a , 0 , sizeof(a) );
    a[0] = 1; // a[0] 存储位数 
    while(n) // 将数转换为数组 
    {
        a[ a[0] ] = n % 10;
        n /= 10;
        a[0]++;
    }
    a[0]--;
    sort(a + 1 , a + a[0] + 1 , cmp); // 从大到小排序 
    long long k = a[1];
    for(int j = 2;j <= a[0];j++)
        k = k * 10 + a[j];
    return k;
}
long long min_()
{
	// max_ 函数已经将a数组从大到小排序
	// min_ 函数反过来算即可 
    long long k = a[ a[0] ];
    for(int j = a[0] - 1;j >= 1;j--)
        k = k * 10 + a[j];
    return k;
}
int main()
{
    long long n;
    while(cin >> n)
    {
        int len = 0; // 总操作次数
        int k; // 循环节起点
        bool flag = true; 
        b[len++] = n;
        while(flag)
        {
            b[len] = max_(b[len - 1]) - min_();
            
            // max_ : n重新排列后最大
            // min_ : -----------最小 
			
            n = b[len]; // 用于判断循环 
            for(int i = 0;i < len;i++)
            {
                if(b[i] == n) // 是否循环
                {
                    flag = false;
                    k = i;
                    break ;
                }
            }
			len++;
        }
        for(int i = k;i < len - 1;i++) // 从循环起点 k 到 len - 1
            cout << b[i] << " ";
        cout << endl;
    }
    return 0;
}
```


---


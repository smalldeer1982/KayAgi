# 失踪的7

## 题目描述

远古的 Pascal 人也使用阿拉伯数字来进行计数，但是他们又不喜欢使用 $7$ ，因为他们认为 $7$ 是一个不吉祥的数字，所以 Pascal 数字 $8$ 其实表示的是自然数中的 $7$，$18$ 表示的是自然数中的 $16$ 。请计算，在正整数 $n$ 范围以内包含有多少个 Pascal 数字。


## 说明/提示

对于所有数据，$1 \leq t \leq 10000$，$1 \leq n \leq 2^{32}-1$。

## 样例 #1

### 输入

```
2
10
20```

### 输出

```
9
18```

# 题解

## 作者：dbxxx (赞：116)

**原来的题解因为叙说很云里雾里，代码过于追求简短而忽略可读性，现重写此篇题解。**

我的思路是这样的：

首先对于给定的数的某一位，引入一个概念：**贡献值**。（自己创造的概念，并非官方）

设这一位所在位数为 $x$（从低位到高位数），上面的值为 $v$，那么这一位的贡献值：

- 如果 $v < 7$，那么这一位的贡献值为 $v \times 9^{x-1}$;
- 如果 $v > 7$，那么这一位的贡献值为 $(v - 1) \times 9^{x-1}$

做出了如上定义之后，一个**不含 $7$ 的数字**对应的答案就是每一位的贡献值之和。

接下来以 $n = 5482$ 为例（**注意 $n$ 中不可含有 $7$**，含有 $7$ 的情况稍后会处理），说明该算法是如何工作的。

首先我们运用位值原理，将 $5482$ 拆分为 $5000 + 400 + 80 + 2$

那么实际上，$1 \sim 5482$ 中所有 Pascal 数的总数，第一步就被我们拆分为：$0 \sim 4999$；$5000 \sim 5399$；$5400 \sim 5479$；$5480 \sim 5481$。

不知道到了这里你会不会萌生这样一个困惑：**你是不是多算了一个 $0$ 呀？你是不是少算了一个 $5482$ 呀？**

事实上，$0$ 是 Pascal 数，$5482$ 也是 Pascal 数，**少算一个，多算一个，最后统计出的数据仍然是准确的。**

解答你的疑惑后，我们继续再来分步处理这些部分：

$0 \sim 4999$ Pascal 数的数量是多少呢？第一个数可以从 $0$ 取到 $4$，总共有 $5$ 种情况；第二个数可以从 $0$ 取到 $9$，但不能是 $7$，总共有 $9$ 种情况；第三个数可以从 $0$ 取到 $9$，但不能是 $7$，总共有 $9$ 种情况；第四个数也是这样，$9$ 种情况。

**考虑使用乘法原理**：$5 \times 9 \times 9 \times 9$。这就是$0 \sim 4999$ Pascal 数的数量了。

那么，$5000 \sim 5399$ Pascal 数的数量是多少呢？第一个数只能取 $5$，不用考虑（或者考虑为 $1$ 种情况，最后乘法时不影响）；第二个数可以从 $0$ 取到 $3$，总共有 $4$ 种情况；第三个数 $9$ 种；第四个数 $9$ 种。

最后就是 $3 \times 9 \times 9$。

不知道你发没发现这样一个规律：分步考虑后，每一位（值为 $v$）对应区间内 Pascal 数的数量其实就是：$v$（从 $0$ 取到 $v - 1$ 共 $v$种情况），乘上后面位数数量的 $9$。也就应了刚刚那个**贡献值的第一个式子**。

现在你明白了吗？所谓贡献值其实就是每一位对应区间内 Pascal 数的数量。这个区间的映射关系，是通过拆分实现的。

到第三位开始情况有了变化：变化在于这一位上是 $8$，但这一位的取值范围不再是 $0 \sim 8$，**因为 $7$ 也是需要扣去的！！**

最后第一位就变成了 $v - 1$ 种情况，乘法原理时相应也需要是 $v - 1$ 与那么多 $9$ 相乘。应了刚刚**贡献值的第二个式子**。

第四位后面就没有位数了，所以直接就是 $v$，不用乘 $9$，也可以说是乘 $9^0$（ $=1$ ）。

最后把每一位的贡献值相加，自然就是最终结果啦。

---

什么？结束了吗？

不要忘了，数里边含有 $7$ 的情况，我们还需要拯救一下！

事实上，只需要在事前加这样一个小特判：**从最高位往下扫，如果遇到 $7$，那么这一位变成 $6$，之后所有位都变成 $9$。**

事实上道理也很简单，举个简单例子便可说明：**$1 \sim 5700700$ 的所有 Pascal 数的数量其实和 $1 \sim 5699999$ 是一样的。毕竟，$5700000 \sim 5700700$ 的所有数都不是 Pascal 数。**

---

代码：
```cpp
#include <bits/stdc++.h>//万能头

int T;
std :: string s;
//这道题推荐字符串存储，因为要取的是每一位的值，且不涉及到整个数字的数字运算
int main() {
    std :: scanf("%d", &T);
    while (T--) { //多组数据测试时推荐这么写！
        std :: cin >> s;
        //特判开始
        for (int i = 0; i < s.length(); ++i) {
            if (s[i] == '7') {
                s[i] = '6';//先把这一位标记为6
                for (int j = i + 1; j < s.length(); ++j)
                    s[j] = '9';//之后所有标记为9
                break; //跳出特判循环，这个 break 实际上很重要，不可省略
                //因为 700700 要变成 699999 而不是 699699
            }
        }
        //特判结束，正片开始
        int ans = 0; //初始化ans
        for (int i = s.length() - 1, atr = 1; i >= 0; --i, atr *= 9)
            ans += atr * (s[i] - '0') - (s[i] - '0' > 7 ? atr : 0);
            //重头戏！s[i] - '0' 就是 i 这一位代表的数字。
            //先根据贡献原理加贡献，然后再判断是否大于7
            //如果大于 7，那么扣除 atr，总体也就相当于 (s[i] - '0' - 1) * atr，合理
            //如果不大于 7，那么扣除 0，也就是不扣除。
        std :: printf("%d\n", ans); //输出答案
    }
    return 0;
}
```

---

## 作者：amstar (赞：55)

难道只有我写了数位dp??！！？


设dp[i]从i位往后的满足条件的数字，套数位dp。

其实就是记忆话搜索。和其他的思路是差不多的。


首先将数字分解，然后dfs中逐位搜索满足条件的数，即不能等于7，然后将结果记下（记忆话）







    
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<iostream>
using namespace std;
int a[1100],p;
int dp[1010];
int dfs(int pos,bool limit) {
    if (pos==-1) return 1;
    if (!limit && dp[pos]!=-1) return dp[pos];
    int u = limit?a[pos]:9;
    int ret = 0;
    for (int i=0; i<=u; ++i) {
        if (i==7) continue;
        ret += dfs(pos-1,limit && i==a[pos]);
    }
    if (!limit) dp[pos] = ret;
    return ret;
}
int work(int x) {
    p = 0;
    while (x) {
        a[p++] = x%10;
        x /= 10;
    }
    return dfs(p-1,true);
}
int main() {
    memset(dp,-1,sizeof(dp));
    int n;
    scanf("%d",&n);
    while (n--) {
        int a,b = 0;
        scanf("%d",&a);
        printf("%d\n",work(a)-1);
    }
    return 0;
}
```

---

## 作者：Ice_teapoy (赞：47)

###看题解都是模拟的代码，

###所以鱼块地发题解了QWQ

###以下用了一种十分奇怪的解法，叫做：**进制转换！！**


首先，Pascal数字是由0,1,2,3,4,5,6,8,9 九个数字组成的

所以我们很（不）容易想到Pascal数字可以近似的看成一种九进制数

所以题面：

在正整数n范围以内包含有多少个Pascal数字

就可以看作：

读入一个Pascal数 ，转为普通数字

即读入一个九进制数，转为十进制（我的理解QWQ）


所以我写了这样的代码


**代码1：**

```cpp
//九进制转十进制 
#include <iostream>
#include <cstring>
using namespace std;
long long k,ans=0;
int t,i;
char a[1001];
int main()
{
    cin>>t;
    while (t--)
    {
        ans=0;
        cin>>a;
        k=strlen(a);
        for (i=0;i<k;++i) ans=ans*9+a[i]-'0';
        cout<<ans<<endl;
    }
} 
```
然后很容易发现出了Bug，即WA了TUT

Bug是什么呢？？

当我们把题目抽象成 九进制转十进制 时，是把1~n中所有含9这一数位的数字去掉了，而不是题目要求的7

就是当读入的数中含有7，8时，应该被去掉含7这一数位的数没有被去掉

所以我们需要一个特判QWQ


**代码2：**

```cpp
#include <iostream>
#include <cstring>
using namespace std;
long long k,s=1,sum=0,ans=0;
int t,i,j;
char a[1001];
int main()
{
    cin>>t;
    while (t--)
    {
        ans=sum=0;
        s=1;
        cin>>a;
        k=strlen(a);
        //以下若干行是特判QWQ 
        for (i=0;i<k;++i)
        /*
            如果有数位是7
            such as 700
            其运行结果和699 完全一致
            5789898984 和 5699999999 运行结果完全一致
            （因为如果一个数字中有一个数位为7，它就不是Pascal数了啊）
            把这个数扫一遍，所以如果发现7，就把以后的全部内容替换为6999... 
                */ 
            if (a[i]=='7')
            {
                a[i]='6';
                for (j=i+1;j<k;++j) a[j]='9';
                break;
            }
        for (i=k-1;i>=0;--i)
        /* 
             如果一个数的个位是8或9，就少减了2^0个7
             如果一个数的十位是8或9，就少减了2^1个7
             如果一个数的百位是8或9，就少减了2^2个7
             ...以此类推
             是个找规律，不想写证明QWQ 
                */
        {
            if (a[i]>'7') sum+=s;
            s*=9;
        }
        for (i=0;i<k;++i)
        {
            ans=ans*9+a[i]-'0';
        }
        cout<<ans-sum<<endl;
    }
} 
//其实代码2确实是凑出来的TUT
//但还是完结撒花~~ 
```

---

## 作者：iscreamgc445 (赞：18)

#### 读完题目后,关于数字7我们可以知晓两种情况:
 ① 7,17,27.....这些数字需要舍去   
 ② 71,72....这些数字需要舍去   
等于说,只要出现了7,就舍去,我第一时间想到用字符串来处理,不多说,上代码:
 ```c
#include<stdio.h>
/*思路:因为题目要求只要是7就pass,所以说71,72.....也是不符合要求的数,我们可以用字符串处理
原理:用到了sprintf函数,用这个函数把数字转换成字符串,这个函数包括三个参数:储存结果的字符串地址,格式化字符串,输入的数据地址
*/
int main() 
{
	int total, num;//定义两个变量,分别是总数字数和每次读入数据时的临时变量
	scanf("%d", &total);
	for (int i = 0; i < total; i++)//采用了边读取边处理的方法
	{
		scanf("%d", &num);
		int count = 0;

		for (int j = 1; j <= num; j++)
		{
			char num[100];//创建了一个保存结果的字符串数组
			int flag = 0;//开关
			sprintf(num, "%d", j);//将每一位数字都转换成字符串
			for (int k = 0; num[k]!='\0'; k++)//判断结束语句
			{
				if (num[k] == '7') //只要出现7,开关打开,退出循环
				{
					flag = 1;
					break;
				}
			}
			if (flag==1)//如果出现了7,就继续外层循环
				continue;
			else
				count++;//如果没有出现7,计数器++
		}
		printf("%d\n", count);
	}
	return 0;
}


```
### 出现的问题:超时,因为代码中使用了三层循环,当需要判断的目标数字很多时就会超时
上面的代码在最后三个测试点tle,所以说思路虽然可以但是费时间

于是乎我又想到了另外一种做法:**进制转换**   

根据题意,只要遇到7就pass,有点像只要遇到9+1就进一位
,十进制中 1234 = 1\*10^3 + 2\*10^2 + 3\*10^1 + 4\*10^0,这道题只需要把10变成9就可以了.

```c
#include<stdio.h>
#include<math.h>
/*思路:十进制中,1234 = 1*10^3 + 2*10^2 + 3*10^1 + 4*10^0,去掉了一个数字7,变成了9进制,模拟进制转换
注意点:因为处理的数据范围是(n≤2^32-1),所以说需要用到long long int类型来储存,为了防止出错,全部设为lld类型
*/
int main() 
{
	long long int num, n;//定义临时变量num和总数字n
	scanf("%lld", &n);
	
	for (int i = 0; i < n; i++)//边读取边处理
	{
		scanf("%lld", &num);
		long long int sum = 0, count = 0,temp;//每次处理前将相关数据重新定义,赋值
		while(num)//当num不为0的时候进行处理
		{
			temp = num % 10;//取num的最右边位数字(第一次取的是个位)
			if (temp < 7)//分支判断,决定计算公式
				sum += temp * pow(9, count);
			else
				sum += (temp-1) * pow(9, count);
			num /= 10;//最右位的数字被处理后就舍去,倒数第二右位变成最右位
			count++;//指数自增
		}
		printf("%lld\n", sum);//输出结果
	}
	return 0;
}

```
刚学了几个月的小垃圾,什么都还不会,希望自己的思路能帮到大家,如果有错误欢迎指正,谢谢!


---

## 作者：Ellen7ions (赞：15)

我的思路是用**排列组合**来做 = =

举个例子：

比如N = 4236 ，所有Pascal数
我们先考虑一位数的时候，对于0~9（除去7）共9个数都可以，ans更新。

当二位数时，即9*9，乘法原理

当三位数时，即9\*9\*9

当四位数时，需要讨论，因为最高位不可以随便选，最高位我们可以选1，2，3，三个数以后，后三位就可以随便选了，即3\*9\*9\*9 , 
然后 最高位选4，固定住，第三位可以选0，1，2三个数，即3\*9\*9
再固定第三位，则2\*9\*9,最后固定十位，即6*1;

不过这种情况只限于所有位数都小于7 ，因为如果有7 就不可以选，例如 899 ， 最选三位数的时候，就不可以选7；

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int T,n,mi[110];
int getlen(int n){	//获取位数 
	int cnt=0;
	while(n)	cnt++,n/=10;
	return cnt;
}
void init(){	//初始化9的幂次 
	mi[0]=1;
	for(int i=1;i<=100;i++)
		mi[i]=mi[i-1]*9;
}
int main(){
	init();
	cin>>T;
	while(T){
		T--;
		int len,temp=0,ans=0;
		cin>>temp;
		len = getlen(temp);
		for(int i=1;i<len;i++)
			ans = ans + 8*mi[i-1];	//对于所有小于最高位的数，怎么选都不会超过N，即4326的一位数的个数，二位数的个数，三位数的个数 
		//              8代表最高位不能选0和7，只有8种情况 
		//cout<<ans<<endl;
		for(int j=1;j<=len;j++){
			int cur = temp%10;
			if(cur>=7)	cur-=1;	// 去掉7 
			if(j==len)	ans = ans + (cur-1)*mi[j-1];	//如果到了最高位，cur-1是最高位不取0 
			else ans = ans + (cur)*mi[j-1];	//不是最高位可以取0 
			temp/=10;
		}
		cout<<ans+1<<endl;	
	}
	return 0;
} 
```




---

## 作者：灬Amiya灬 (赞：8)

一开始暴力，然后有三个点过不了
然后就用进制做吧
看成九进制编码，大于等于7的时候系数就减一。
然后就能做出来了
坑爹的是，一开始用Int，RE了，说明数据好大 不是说好2的31次方-1么。。。int不就是-2的31次方到2的31次方-1吗，QAQ
反正用long过了。

```java
package p1590;

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		// TODO 自动生成的方法存根
		int t;
		Scanner in = new Scanner(System.in);
		t = in.nextInt();
		long result=0;
		long  that=0;
		for(int i=0;i<t;i++) {
				that = in.nextLong();
				 result = count(that);
				 System.out.println(result);
			}
	}

	private static long count(long that) {
		// TODO 自动生成的方法存根
		int weishu=0;
		long now=1;
		long sum=0;
		while(that>0) {
			now = that%10;
			if(now>=7) {
				now--;
			}
			sum+= now*(long)Math.pow(9,weishu);
			that/=10;
			weishu++;
		}
		return sum;
	}

}

```

---

## 作者：I4ever (赞：6)

# P1590 失踪的7
## 题目分析
- 统计 $1 \sim n$ 中所有不包含 $\mathsf 7$ 的数字个数，任何一位都不可以有。数据范围给的很大，已经爆 *int* 了所以不考虑使用暴力求解，那么开始模拟找规律。

- 先手模找规律
```
1  2  3  4  5  6  8  9  10
11 12 13 14 15 16 18 19 20
21 22 23 24 25 26 28 29 30
31 32 33 34 35 36 38 39 40
41 42 43 44 45 46 48 49 50
51 52 53 54 55 56 58 59 60
61 62 63 64 65 66 68 69 80
81 82 83 84 85 86 88 89 80
91 92 93 94 95 96 98 99 100
```
这是 $1 \sim 100$ 的，共有 $81$ 个 *Pascal* 数字。

而 $1 \sim 10$ 的有 $9$ 个数字。（自己算）

那么可以将 $100$ 分成 $10$ 个 $1 \sim 10$ ，因为其中有 $70 \sim 79$ 以及每一个 $1 \sim 10$ 中会有一个 $7$ 不符合条件，所以 $100 \rightarrow 9\times9=81$。

则可推出 $1000 \rightarrow 81\times9=729$。 

那么就可以手动计算将其存贮到数组中，打个比方，将 $abcdefg$ 变成 $a\times1000000 + b\times100000 + c\times10000 + d\times1000 + e\times100 + f\times10 + e\times1$，对于每一位数字单独进行计算，最后累加即可。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
template <typename T> void read(T &x) {
	int f = 1;
	x = 0;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) {
		if (c == '-') {
			f = -f;
		}
	}
	for (; isdigit(c); c = getchar()) {
		x = x * 10 + c - '0';
	}
	x *= f;
}
/*预处理*/
int a[10] = {1, 9, 81, 729, 6561, 59049, 531441, 4782969, 43046721, 387420489};
ll T, n, ans, dep;
int main() {
	read(T);
	while (T--) {
		ans = dep = 0;
		read(n);
		while (n) {
			int num = n % 10;
			n /= 10;
			if (num < 7) {//对于大于等于7的需要减去1，小于7的不用管
				ans += num * a[dep];
			} else {
				ans += (num - 1) * a[dep];
			}
			dep++;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：北北北北 (赞：5)

我们可以对n进行变形，如n=1234时，则n=1000+200+30+4，随后再

把这种形式里的每一项都给变成10^x*y的形式，然后再算出10和y所对

应的合法的数的数量以及x的值，然后就可以通过10^x*y直接得到每项

所对应的合法的数的数量，最后求和就是n所对应的合法的数的数量，

即答案。

下面附实现代码：


------------
```c
#include <stdio.h>

int main(void)
{
	int a[] = {0,1,2,3,4,5,6,6,7,8,9}; //0-10所对应的合法的数的数量 
	int i,j,t;
	long long n,sum,count,temp;
	
	scanf("%d", &t);
	for(i = 1; i <= t; i++)
	{
		scanf("%lld", &n);
		for(j = 1000000000,sum = 0; j >= 1; j /= 10) //取整 
		{
			count = 1;
			if(n/j > 0)
			{
				temp = n/j*j; //得到n的整数部分 如1234的整数部分就是1000 而1000的整数部分就是自身 
				n -= temp; //得到下个待取整的数 
				
				while(temp > 1) //把所得n的整数部分给用10^x*y的形式来表示出来 
				{
					if(temp >= 10)
					{
						count *= a[10]; //10^x
					}
					else
					{
						count *= a[temp]; //y
					}
					temp /= 10;
				}
				sum += count; //把所得n的整数部分所对应的合法的数的数量给加上去 
			}
		}
		printf("%lld\n", sum);
	}
	
	return 0;
}
```


---

## 作者：Dr_osrin (赞：3)

所以说Pascal人真是闲的无聊。

漫长的debug和思考之后终于扛过这题了 一道数论硬是被我做成dp……

```
//这里只给出主程序
int main()
{
	ll n,a;
	cin>>n;
	int dp[50]={0};//粗暴的输入，不解释
	for (int i=0;i<n;i++)
	{
		int temp;
		int j=1;
		for (cin>>a;a>0;a/=10,j++)
//写得略乱的循环开头，
//实际上就是把数字的各位数拆开
//并装进temp里 拆完为止
		{
			temp=a%10;
			temp=(temp>=7)?temp-1:temp;
			dp[j]=temp*pow(9,j-1)+dp[j-1];
//核心。
//dp[j]的意思是：第j位处有几种方案。
//考虑到每一位数实际上是可以独立进行判断的，
//所以对于第j位的数而言，等同于一个特殊的9进制
//因此方程为：dp[j]=当前可找到的非7数+dp[j-1]
//为了避免越界，dp从一开始，边界值dp[0]为0，因此输出时要j-1；
		}
		cout<<dp[j-1]<<endl;
		memset(dp,0,sizeof(dp));
	}
	return 0;
} 
```
尽管是道数论 但是按这么做似乎也是没有问题的

---

## 作者：Meronri_Deng (赞：3)

先举个例子 随便拿个n，就2333好了

1~10有9个合法解

1~100有81个合法解

1~1000有729个合法解

那么2333有多少个合法解呢？

答：2\*729+3\*81+3\*9+3=1731个 为什么呢？

千位是2时
继续往下看

{
	对于百位是0、1、2时各有81个解
    对于百位是3时
    
    {
    	当十位是0、1、2时各有9个解
        当十位是3时
        {
        	个位是0,1,2,3 共4个解
        }
    }
}

咦？2\*729+3\*81+3\*9+4=1732 

怎么多了一个呢？

因为0000不在1~n之间 所以要减去1

就刚好是1731了
———————————————代码分界线—————————————

大概是数位dp之类的 不过对于每个位数相同的状态最高位不影响解个数

注意要用unsigned int，不然会wa
```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[15];//f[i]表示一个i位数有多少合法解
long long ten[11]//ten[i]表示10^i;
int len(unsigned int x)//求一个整数的位数
{
	int s=0;
	while  (x>0)
		{
			s++;
			x/=10;
		}
	return s;
}
void work()
{
	unsigned int n;
	cin>>n;
	int l=len(n);
	long long ans=0;	
	for  (int i=0;i<l;i++)
		{
			int x=n/ten[i]%10;//提取第i+1小的位
			if  (x>6)  x--;//对于大于等于7的数需要舍去7
			ans+=f[i+1]*x;//因为第i小位是合法解(1<=i<=x&&i!=7)
            //i==0的情况会由更低位先处理
			//cout<<i<<' '<<x<<endl;		
		}
	cout<<ans<<endl;	
}
int main()
{
	int t;
	cin>>t;
	ten[0]=1;
	for  (int i=1;i<=10;i++)
		ten[i]=ten[i-1]*10;
	f[1]=1;	
	for  (int i=2;i<=11;i++)	
		f[i]=f[i-1]*9;//只有带7的不合法，10-1=9，所以*9
	while (t)
		{
			work();
			t--;
		}
}
```
其实严格来说 对于某位为x时 并不是考虑1~x而是0~x-1
毕竟为x时的合法解并不完全

---

## 作者：JustinRochester (赞：2)

[题目](https://www.luogu.org/problemnew/show/P1590)

我天，一开始我还被坑了一下2333。

其实本题就是进制数转化题。只不过这一题有两个坑点。

1. 如果输入中含 $7$ ，如 $3141597265735$ 。 $314159726535$ 个数中，从 $3141597000000$~$3141597265735$ 都不算。所以读入该数，与读入 $3141596999999$ 是一样的。（即一旦读入 $7$ ，则将该位改为 $6$ ，后面读入几位就加上几个 $9$ ，不管后面是多少， $7$ 也一样）。


2. 该题中的数，组成只有：$0,1,2,3,4,5,6,8,9$ ；为 $9$ 进制数，且 $8,9$ 在读入时应该分别视为 $7,8$ （按正常 $9$ 进制数的规则，且这样读入方便计算）。


故此我们只要在读入时“做手脚”就可以了。思路参考读入优化 ~~（自从学了读入优化，我再也不爱打scanf和cin了2333）~~。


------------

那蒟蒻的我就放代码了

```cpp
#include<cstdio>
#include<cctype>
using namespace std;
int read(){
    int abs=0;char c=getchar();//abs储存9进制数，c读入字符 
    bool b=1;//储存是否出现了7 
    while( !isdigit(c) ) c=getchar();//判断是否为数字字符，防炸 
    while( isdigit(c) ) {
        abs*=9;//9进制进位处理 
        if(b&&c=='7') {//第一次读到7 
            b=0;//标记 
            abs+=6; 
            c=getchar();
            continue;
        }
        if(b) abs+=(c<'7')?(c-'0'):(c-'1');//未读到7，把数加上去（数为8、9时加7、8） 
        else abs+=8;//读到过7，直接加9进制的9，即8 
        c=getchar();
    }
    return abs;//将读到的数直接转化为9进制输出 
}
int main(){
    int t;scanf("%d",&t);
    while(t--){
        int x=read();
        printf("%d\n",x);
    }
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：Pum_K (赞：1)

模拟一个特殊的九进制的高精度即可

原理基本上是从末位last开始检测

若last>=7则该范围内应有（last-1）\*（9^位数）个对应的十进制数

若last<7则该范围内应有last\*（9^位数）个对应的十进制数

代码如下



```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
    int temp,last;
    int n;
    int a[100],p[100]={0};
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
    }
    for(int i=0;i<n;i++)
    {
        temp=0;
        while(a[i]>0)
        {
            last=a[i]%10;
            if(last>=7)
            {
                p[i]=p[i]+(last-1)*pow(9,temp);
            }
            else if(last<7)
            {
                p[i]=p[i]+last*pow(9,temp);
            }
            temp++;
            a[i]=a[i]/10;
        }
    }
    for(int i=0;i<n;i++)
    {
        cout<<p[i]<<endl;
    }
}
```

---

## 作者：boyfaceone (赞：0)

题目大概就是统计1~n中有多少个不含数字7的数，可以直接dp，比暴力枚举要快些。

为方便统计，可先统计0~n中有多少个不含7的数，再把0去掉即可。

以n=692为例：

当百位取0~5时，十位和个位可取除7外的任意数，因此有6\*9^2=486个；

当百位取6时，如果十位取0~6和8，个位可取除7外的任意数，有8\*9^1=72个；

当百位取6，十位取9时，个位可以取0、1、2，共3个；

因此总共有486+72+3=561个，除掉0，结果就是560个。


'''cpp
```cpp
#include <stdio.h>
#include <string.h>
int t;
char s[16];
int pow9(int a) {
    int r = 1;
    while (a--) r *= 9;
    return r;
}
int f(char c) {
    return c < '7' ? c-'0' : c-'0'-1;
}
void count(void) {
    int i, j, cnt = 0, l = strlen(s);
    for (i = 0; i < l; i++)
        cnt += f(s[i]) * pow9(l-1-i);
    printf("%d\n", cnt);
}
int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%s", s);
        count();
    }
    return 0;
}
'''
```

---

## 作者：xvhuanlin (赞：0)

把给定数字当做9进制，转换成10进制输出。

当给定数字中有大于7的数字，减一之后在转换。

要注意的是，如果给定数字中有7怎么办？？

可以发现，xx...xx700...00到xx...xx799...99的数字都是无意义的，因为这段范围之内一定没有符合要求的数字。

所以在开始转换之前，从给定数字的高位开始，寻找第一个等于7的数字，将该位变为6，该位以后的数字全部变为9，然后按照之前的方法转换就可以了。


---


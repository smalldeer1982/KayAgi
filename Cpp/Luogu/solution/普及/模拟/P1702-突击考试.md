# 突击考试

## 题目描述

一日，老师决定进行一次突击考试。已知每个学生都有一个考试能力等级，教室里一共有 $N$ 个课桌，按照顺序排成一列，每张课桌可以坐两个人，第 $i$ 张课桌坐的两个人的能力等级为$A_i,B_i$。现在老师决定对能力等级为 $K$ 的人进行测验。他会从这 $N$ 排中选择连续的 $L$ 排进行测验，要求这 $L$ 排中的每一排至少有一个人考试能力等级为 $K$。现在我们想知道 $L$ 的最大值以及对应的等级 $K$。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 100,000$，$1 \le A[i],B[i] \le 5$。

## 样例 #1

### 输入

```
3
3 5
4 5
1 3
```

### 输出

```
2 5```

# 题解

## 作者：lgxt (赞：13)

来自蒟蒻的题解。。。
这道题已经给出 1≤A[i],B[i]≤5 的条件，从等级一到等级五挨个模拟即可。
代码：
```
#include<iostream>
using namespace std;
int s[100001][2],t[6];//数组s代表课桌及考生等级，数组t分别代表等级1~5最大的排数 
int main()
{
	int n;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>s[i][0]>>s[i][1];//s[i][0]、s[i][1]分别表示同一课桌两人的等级 
	}
	for(int i=1;i<=5;i++)// 等级1~5模拟 
	{
		int ans=0,x=0;
		for(int o=0;o<n;o++)
		{
			if(s[o][0]==i||s[o][1]==i)
			{
				x++;//如果该课桌符合条件，排数加一 
			}
			if(s[o][0]!=i&&s[o][1]!=i||o==n-1)//若i的连续排数一直到最后的课桌的话也要计数，故判断条件有 o==n-1 
			{
				ans=max(ans,x);//不符合，刷新i等级的最大排数 
				x=0;//重新计数 
			}
		}
		t[i]=ans;//得出等级i最大排数 
	}
	int max=0,maxs=0;
	for(int i=1;i<=5;i++)//寻找最大排数及其最小等级 
	{
		if(t[i]>max)
		{
			maxs=i;//最大排数 
			max=t[i];//最大排数的等级 
		}
	}
	cout<<max<<" "<<maxs;//输出 
	
	return 0;
}
```

---

## 作者：_ZZH (赞：10)

看下数据是卡O(n^2)的，然后本蒟蒻既想不到二分，又想不到搜索的
log n做法，于是看标签是模拟，那就O(n)模拟吧！

考虑递推：

另f[i][k]表示从第一排到i，k这个等级连续了多少次(截止到k，断开重记)，那么对于每排的两个等级x,y，满足：

f[i][x]=f[i-1][x]+1;


f[i][y]=f[i-1][y]+1;

于是我们对于答案maxx和对应的k值max_k,可以用f[i][x]和f[i][y]中较优的一个（更符合题意）来更新答案。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,f[100010][6],maxx,max_k;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		f[i][x]=f[i-1][x]+1;
		f[i][y]=f[i-1][y]+1;//计算当前情况。 
		int now,now_k;
		if(f[i][x]>f[i][y])
		{
			now=f[i][x];
			now_k=x; 
		}
		if(f[i][x]<f[i][y])
		{
			now=f[i][y];
			now_k=y;
		}
		if(f[i][x]==f[i][y])
		{
			now=f[i][x];
			now_k=min(x,y);
		}//取最优情况 
		if(now>maxx)
		{
			maxx=now;
			max_k=now_k;
			continue;
		}
		if(now==maxx)
		{
			max_k=min(max_k,now_k);
			continue;
		}//更新答案 
	}
	printf("%d %d",maxx,max_k);
} 
```


---

## 作者：听取MLE声一片 (赞：5)

~~这道题真的很水，但我调了很长时间~~

# 注意：

1：突击考试只对等于考核标准的人有效

2：时间复杂度很重要

3：必须连续

这里是70分算法，TLE了

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int read(){
	int fh=1,ans=0;
	char r;
	r=getchar();
	while(r<'0'||r>'9'){
		if(r=='-')
			fh=-1;
		r=getchar();
	}
	while(r>='0'&&r<='9'){
		ans*=10;
		ans+=r;
		ans-='0';
		r =getchar();
	}
	return ans*fh;
}
int n,a[100001],b[100001],ans,ans1;
/*
a为第一个人的能力值
b为第二个人的能力值
ans，ans1存答案
*/
int pd(int x){
	int s=0;
	for(int i=0;i<n;i++){//暴力搜索每一种可能 
		int p=0;
		for(int j=i;j<n;j++){
			if(a[j]==x||b[j]==x)
				p++;
			else break;
		}
		s=max(s,p);
	}	
	return s;
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
		cin>>a[i]>>b[i];
	for(int i=1;i<=5;i++){//暴力搜索能力值
		if(ans<pd(i)){
			ans=pd(i);
			ans1=i;
		}
	}
	cout<<ans<<' '<<ans1;
	return 0;
}


```

## 想要AC必须压缩复杂度

像这样：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int read(){
	int fh=1,ans=0;
	char r;
	r=getchar();
	while(r<'0'||r>'9'){
		if(r=='-')
			fh=-1;
		r=getchar();
	}
	while(r>='0'&&r<='9'){
		ans*=10;
		ans+=r;
		ans-='0';
		r =getchar();
	}
	return ans*fh;
}
int n,a[100001],b[100001],ans,ans1;
/*
a为第一个人的能力值
b为第二个人的能力值
ans，ans1存答案
*/
int pd(int x){
	int s=0,p=0;
	for(int i=0;i<n;i++){
		if(a[i]==x||b[i]==x)//边跑边记录
			p++;
		else{
			s=max(s,p);
			p=0;
		}
	}
	return max(s,p);//此代码注意，不加这一个会WA三个点
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
		cin>>a[i]>>b[i];
	for(int i=1;i<=5;i++){//暴力搜索能力值
		if(ans<pd(i)){
			ans=pd(i);
			ans1=i;
		}
	}
	cout<<ans<<' '<<ans1;
	return 0;
}


```

抄题解的人都是喝水塞牙的人☺

---

## 作者：Dcue (赞：3)

好像没有类似的模拟，赶紧发一篇
------------
**本题思路就在于更新答案与寻找最大值两方面**   
1.有关更新答案，**max函数好评**  
2.有关最大l与最小k，最后按k的从小到大的顺序来就行  
3.关于储存，因为k只能为1-5，所以完全可以开一个数组，下标k+5储存即时长度，k下标储存最大长度，这倒是有一点桶排思想了，也是下标与内容的充分利用  


------------
```cpp
#include<iostream>
using namespace std;
int a[20],x,y,n,l=0,k;
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>x>>y;
		if(x!=y){
		a[x+5]++;
		a[y+5]++;
		a[x]=max(a[x],a[x+5]);
		a[y]=max(a[y],a[y+5]);
		}
		else
		a[x+5]++,a[x]=max(a[x],a[x+5]);
		for(int j=1;j<=5;j++)
		if(j!=x&&j!=y)a[j+5]=0;//对于不连续的k，进行清零
	}
	for(int i=1;i<=5;i++){
		if(a[i]>l){
		l=a[i];k=i;
		}
	}
	cout<<l<<" "<<k;
	return 0;
}
```
以上
浅之拙见，望有更好算法与优化的大佬多多斧正

---

## 作者：Bruteforces (赞：3)

来一发pascal题解（虽然马上就要被CCF淘汰了555）

这道（shui）题的做法是二分答案+前缀和

我们假设有连续L张课桌，每张课桌上至少一人编号为K，当L增加1时，容易得出新增课桌上有一人编号为K的概率仅有2/5。如果L继续增大，则序列能够持续的概率会继续降低。由此可知，随着L的增大，符合题目条件的概率是单调下降的。因此，我们可以用二分法求出L的最大值，然后利用L求出K。我们可以开一个前缀和数组c，用c[i,j]表示前i张课桌中有几张上面坐着至少一个编号为j的人，优化时间复杂度。

本题时间复杂度O(5nlogn)

丑陋的pascal代码

···
```cpp
var
  a:array[1..100000,1..2]of integer;
  c:array[0..100000,1..5]of longint;
  n,i,j,k,x,y,z,left,right,mid,ans:longint;
function check(mid:longint):longint;
var
  i,j,x,y:longint;
begin
  check:=0;
  for j:=1 to 5 do
    for i:=mid to n do
    if c[i,j]-c[i-mid,j]=mid then
      exit(j);
end;
begin
  readln(n);
  for i:=1 to 5 do c[0,i]:=0;
  for i:=1 to n do
    begin
      readln(a[i,1],a[i,2]);
      for j:=1 to 5 do
      begin
        c[i,j]:=c[i-1,j];
        if(a[i,1]=j)or(a[i,2]=j)then inc(c[i,j]);
      end;
    end;
  left:=1;right:=n;
  while left<=right do
  begin
    mid:=(left+right)div 2;
    if check(mid)=0 then right:=mid-1 else
    begin
      ans:=mid;left:=mid+1;
      k:=check(mid);
    end;
  end;
  writeln(ans,' ',k);
end.
···
```

---

## 作者：Rachel_Gardner (赞：2)

每次搜索一遍后，判断是否大于之前的最大值

模拟即可，不过要记住同桌的等级有可能一样：这种情况只算作一次

由于数据不是很大，枚举就可以完成。

```cpp
#include<bits/stdc++.h>    //万能头文件 
using namespace std;
int a[100000];
int b[100000];
int main()
{
    int n,j=0,max=0;    //n为课桌数量，j为符合条件的等级，l为连续的最大值 
    scanf("%d",&n);     //输入课桌数量 
    for (int i=0;i<n;i++){    //输入每一排的能力 
        scanf("%d %d",&a[i],&b[i]);
    }
    for (int k=1;k<=5;k++){    //进行循环，因为等级最多只到5，枚举即可 
        int s=0;    //s更新为0 
        for (int i=0;i<n;i++){    //搜索一遍 
            if (a[i]==k||b[i]==k) s++;    //这一段一定要注意，同桌的等级有可能一样 
            if (a[i]!=k&&b[i]!=k){    //如果同桌的等级都不为k 
                if (s>=max) {    //判断上一次连续一段的值 
                    max=s;    //最大值更新 
                    j=k;    //等级更新 
                }
                s=0;    //s更新为0 
            }
        }
        if (s>max) {    //判断完最后一段 
            max=s;
            j=k;
        }
    }
    printf("%d %d",max,j);    //最后输出答案 
    return 0;
}
```

---

## 作者：whwh (赞：1)

注意的问题：

1.L排中的每一排至少有一个人考试能力等级为K（一个就行）

2.N排中选择连续的L排进行测验（连续的L排）

3.L最大的条件下K最小

70分代码：
```
#include<cstdio>
#include<iostream>
using namespace std;
int a[100100],b[100100],ans1=0,k=0;
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d%d",&a[i],&b[i]);
    for(int i=1;i<=5;++i){
        int max1=0;
        for(int j=1,u=0;j<=n;++j){
            if(a[j]==i||b[j]==i) u++;
            else max1=max(max1,u),u=0;
        }
        if(max1>ans1) ans1=max1,k=i;
    }
    printf("%d %d",ans1,k);
    return 0;
}

```
如果知道少了那一句就不用往下看了！

上AC代码：
```
#include<cstdio>
#include<iostream>
using namespace std;
int a[100100],b[100100],ans=0,k=0;
int main(){
	int n;
	scanf("%d",&n);//输入
	for(int i=1;i<=n;++i) scanf("%d%d",&a[i],&b[i]);
	int max1,u;//max1记录 k=i时，最长的L（u自行理解）
	for(int i=1;i<=5;++i){
		u=0;max1=0;//记得初始化
		for(int j=1;j<=n;++j){
			if(a[j]==i||b[j]==i) u++;
			else max1=max(max1,u),u=0;//u记得置0
		}
		max1=max(max1,u);//这一句不要忘了，因为最后u可能不为0，还可能比max1大（少了就为70了）
		if(max1>ans) ans=max1,k=i;//找最大L，因为i是从小到大枚举的，所以用考虑L相等的时候
	}
	printf("%d %d",ans,k);//输出
	return 0;
}
```
时空：47ms 1528KB

恳请管理员通过我的这篇题解

---

## 作者：不存在之人 (赞：1)

只是一个简单的dp而已，f[i][j]表示当k值为i时第j个人的最长的L的长度。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int n,Max,maxn;
int a[100005],b[100005],f[10][100005];
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;++i)
	  	scanf("%d%d",&a[i],&b[i]),maxn=max(maxn,max(a[i],b[i]));
	for (int i=1;i<=maxn;++i)
	  	for (int j=1;j<=n;++j)
	    	if (a[j]==i||b[j]==i)
	      		f[i][j]=f[i][j-1]+1;
	for (int i=1;i<=maxn;++i)
	  	for (int j=1;j<=n;++j)
	    	Max=max(Max,f[i][j]);
	for (int i=1;i<=maxn;++i)
	  	for (int j=1;j<=n;++j)
	    	if (f[i][j]==Max)
			{
	    		printf("%d %d\n",Max,i);
	    		return 0;
	    	}
	return 0;
}
```

---

## 作者：sto_lskj_orz (赞：1)

这道题看到a[i],b[i]是1 到5 ，就想到利用这个条件来优化时间复杂度。我们从1 到5循环，每次统计包含这个数字的最多连续排数，每次更新，因为他优先输出k小的，所以直接写s>sum即可。这样一个简单的模拟循环，就可以达到O(5\*n)的时间复杂度。

优美简短的Pascal代码：

```cpp
var i,n,j,s,m,sum:longint;a,b:Array[1..100000]of longint;
begin
  readln(N);
  for i:=1 to n do readln(a[i],b[i]);
  for i:=1 to 5 do
  begin
   s:=0;
   for j:=1 to n do
   begin
     if (a[j]=i)or (b[j]=i) then inc(s) else s:=0;//统计最多排数
     if s>sum then begin sum:=s;m:=i;end;//打擂
   end;
  end;
   writeln(sum,' ',m);
end.
```

---

## 作者：木木！ (赞：1)

考虑纯暴力。由于纯暴力不会超时，所以暴力打上去。

对于每个点，我们开始往后搜索，搜到就清零（因为没有必要再搜了）。这里由于每个点最多被清零两个数据，即最多会被途径两次，总时间复杂度即$\Theta(n)$，已经达到了复杂度下限。

附AC代码（46ms）：

```cpp
#include <cstdio>
using namespace std;

int ai[100005];
int bi[100005];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d%d",ai+i,bi+i);
	}
	int ans = 0;
	int ansk = 0;
	for(int i=1; i<=n; ++i)
	{
		if(ai[i])
		{
			int k = ai[i];
			int curans = 0;
			for(int j=i; j<=n; ++j)
			{
				if(ai[j]==k || bi[j]==k)
				{
					++curans;
				}
				else
				{
					break;
				}
				if(ai[j]==k)
				{
					ai[j] = 0;
				}
				if(bi[j]==k)
				{
					bi[j] = 0;
				}
			}
			if(curans>ans)
			{
				ans = curans;
				ansk = k;
			}
		}
		if(bi[i])
		{
			int k = bi[i];
			int curans = 0;
			for(int j=i; j<=n; ++j)
			{
				if(ai[j]==k || bi[j]==k)
				{
					++curans;
				}
				else
				{
					break;
				}
				if(ai[j]==k)
				{
					ai[j] = 0;
				}
				if(bi[j]==k)
				{
					bi[j] = 0;
				}
			}
			if(curans>ans)
			{
				ans = curans;
				ansk = k;
			}
		}
	}
	
	printf("%d %d\n",ans,ansk);
}
```

---

## 作者：mzyy1001 (赞：0)

~~看了题目后，脑子一热想在线做，结果导致了离线不会遇到的一大堆问题，所以设了很多变量，不过整体空间应该还是比较节省的。~~其实题目本身显然是可以直接一遍o（n）模拟做下来，没有什么思考含量。就是在线做有几个注意点：1.lasta可以和b相同，ka，kb也要换一下位置。2.注意一下lasta和lastb相同时的特判（其实我的程序不会受到影响所以也没有特判）3.设置了一个临时变量来规避last，k还有用但已经被修改了的情况4.最后注意题意连续的，L相同k最小。
然后贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int flag[10];
int main()
{
	int n;
	cin >> n;
	memset(flag,0,sizeof(flag));
	int lasta = 0,lastb = 0;
	int ka = 0,kb = 0;
	for(int i = 1;i <= n;i++)
	{
		int na = 0,nb = 0,nkb = 1,nka = 1;
		int a,b;
		scanf("%d%d",&a,&b);
		flag[a] = max(flag[a],1);
		flag[b] = max(flag[b],1);
		if(a == lasta||b == lasta)
		{
			flag[lasta] = max(ka+1,flag[lasta]);
			if(a == lasta)
			{
				na = a;
				nka = ka+1;	
			} 
			if(b == lasta)
			{
				nb = b;
				nkb = ka+1;
			}
		}
		if((a == lastb||b == lastb)/*&&lasta != lastb*/)
		{
			flag[lastb] = max(kb+1,flag[lastb]);
			if(a == lastb)
			{
				na = a;
				nka = kb+1; 
			}
			if(b == lastb)
			{
				nb = b;
				nkb = kb+1;
			}
			
		}
		if(na == 0)
		{
			na = a;
			nka = 1;
		}
		if(nb == 0)
		{
			nb = b;
			nkb = 1;
		}
		lasta = na;
		lastb = nb;
		ka = nka;
		kb = nkb;
	}
	int mx = 0;
	int k;
	for(int i = 1;i <= 5;i++)
	{
		if(mx < flag[i])
		{
			mx = flag[i];
			k = i;
		}
	}
	cout << mx << " " << k << endl;
	return 0;
}
```

---

## 作者：xuan__xuan (赞：0)

其实本题，还可以用二分答案做，我们发现，如果知道L的值，K的值非常好求，用一个队列啊，从头搜到尾，检查一下数量。

所以我们就要去求L，故二分求解，每二分到一个L，用一个队列搜，在记录数量的变化，因为A，B均小于等于5嘛，所以复杂度就是

O（5 \* nlogn），应该说卡这个数据绰绰有余了。


    
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const  int  MAXN = 100005;
int N;
int K = (1 << 30),Ans,M[11];
struct node{
    int A;
    int B;
}data[MAXN];
void Make(int A,int B,int k)
{
    if(A == B)
       M[A] += k;
    else
    {
        M[A] += k;
        M[B] += k;
    }
}
int check(int L)
{
    memset(M,0,sizeof(M));
    int Head = 1,Tail = L;
    for(int i = 1; i <= L;i++)
        Make(data[i].A,data[i].B,1);
    while(Tail <= N)
    {
        for(int i = 1; i <= 5; i++)
            if(M[i] == L)
                return 1;
        Make(data[Head].A,data[Head].B,-1);
        Head++;
        Tail++;
        Make(data[Tail].A,data[Tail].B,1);
    }
    return 0;
}
void Work(int L)
{
    memset(M,0,sizeof(M));
    int Head = 1,Tail = L;
    for(int i = 1; i <= L;i++)
        Make(data[i].A,data[i].B,1);
    while(Tail <= N)
    {
        for(int i = 1; i <= 5; i++)
            if(M[i] == L)
               K = min(K,i);
        Make(data[Head].A,data[Head].B,-1);
        Head++;
        Tail++;
        Make(data[Tail].A,data[Tail].B,1);
    }
}
int main(){
    scanf("%d",&N);
    for(int i = 1; i <= N; i++)
        scanf("%d%d",&data[i].A,&data[i].B);
    int x = 1, y = N;
    while(x <= y)
    {
        int mid = (x+y) / 2;
        if(check(mid) == 1)
        {
            Ans = mid ;
            x = mid + 1;
        }
        else
            y = mid - 1;
    }
    Work(Ans);
    cout << Ans << " " << K << endl; 
    return 0;
}
```

---

## 作者：csyzjds (赞：0)

记录每个数最长连续就行啦


  
```cpp
#include<cstdio>  
#include<cstring>  
#include<algorithm>  
#include<iostream>  
using namespace std;  
int ans=0,zhi,n,f[10],ha[5],has[5],ha1,ha2;  
int main()  
{  
    int a,b,i;  
    ios::sync_with_stdio(false);  
    cin>>n;  
    memset(f,0,sizeof(f));  
    ha[1]=0;ha[2]=0;has[1]=0;has[2]=0;  
    for(i=1;i<=n;i++)  
    {  
        cin>>a>>b;  
        f[ha[1]]=max(f[ha[1]],has[1]);  
        f[ha[2]]=max(f[ha[2]],has[2]);  
        if(a==ha[1] || a==ha[2])  
        {  
            if(a==ha[1])ha1=has[1]+1;  
            else ha1=has[2]+1;  
        }  
        else ha1=1;  
        if(b==ha[1] || b==ha[2])  
        {  
            if(b==ha[1])ha2=has[1]+1;  
            else ha2=has[2]+1;  
        }  
        else ha2=1;  
        ha[1]=a;ha[2]=b;  
        has[1]=ha1;has[2]=ha2;  
    }  
    f[ha[1]]=max(f[ha[1]],has[1]);  
        f[ha[2]]=max(f[ha[2]],has[2]);  
        if(a==ha[1] || a==ha[2])  
        {  
            if(a==ha[1])ha1=has[1]+1;  
            else ha1=has[2]+1;  
        }  
        else ha1=1;  
        if(b==ha[1] || b==ha[2])  
        {  
            if(b==ha[1])ha1=has[1]+1;  
            else ha1=has[2]+1;  
        }  
        else ha1=1;  
        ha[1]=a;ha[2]=b;  
        has[1]=ha1;has[2]=ha2;  
        for(i=1;i<=5;i++)  
        if(f[i]>ans){ans=f[i];zhi=i;}  
        cout<<ans<<' '<<zhi<<endl;  
        return 0;  
}
```

---

## 作者：jyyn (赞：0)

```cpp

#include <stdio.h>

const int MaxN=100001;

int N,bestL,bestK;
int A[MaxN],B[MaxN];

int main()
{int i,j,len,tmp;
 scanf("%d",&N);
 for (i=1;i<=N;i++)
   scanf("%d%d",&A[i],&B[i]);
 bestL=0;
 for (i=1;i<=5;i++)
   {len=0;
    tmp=0;
    for (j=1;j<=N;j++)
      if (A[j]==i || B[j]==i)
        tmp++;
      else
        {if (tmp>len) len=tmp;
         tmp=0;
        }
    if (tmp>len) len=tmp;
    if (len>bestL)
      {bestL=len;  
       bestK=i;
      }
   }
 printf("%d %dn",bestL,bestK);
 return 0;
}

```

---

## 作者：zhangyi20001108 (赞：0)

题看上去并不难，只要寻找某个数字的最大出现次数即可。
先是必要工作。


------------
```cpp
#include <iostream>
using namespace std;

int main(int argc, char *argv[])
{
    int max[6]={0};//分别储存5个能力等级对应的最高出现次数
    int currentCount[6]={0};//分别储存数据读取到当前位置时各个能力等级的当前出现次数
    int n=0;
    cin>>n;
    return 0;
}

```


------------
然后继续在main函数中添加读取数据的操作。读取数据不需要保存了，读一组处理一组即可。对于本组中出现的数据，出现次数+1，没出现的数据，将出现次数清零，然后比较本次出现次数是不是最大的：

------------
```
for(int i=0;i<n;++i)
    {
        int a=0,b=0;
        cin>>a>>b;
		//这里需要格外注意，比较a和b是不是同一个数
        if(a==b)
            ++currentCount[a];
        else
        {
            ++currentCount[a];
            ++currentCount[b];
        }

        for(int j=1;j<=5;++j)//这里的循环变量要变成j
        {
            if(j!=a && j!=b)
            {
                if(currentCount[j]>max[j])
                    max[j]=currentCount[j];
                currentCount[j]=0;
            }
        }

    }
```

------------
这里有个易错的地方就是，读完之后要比较a和b是不是相同的数字，如果是的话要特殊处理，不然就会被算两次。

数据处理结束后，整理最大次数：

------------
```
for(int i=1;i<=5;++i)
{
    if(currentCount[i]>max[i])
        max[i]=currentCount[i];
    currentCount[i]=0;
}
```

------------
最后寻找最小的i和最大的出现次数：

------------
```
int mini=1,maxS=max[1];
    for(int i=2;i<=5;++i)
    {
        if(max[i]>maxS)
        {
            maxS=max[i];
            mini=i;
        }
    }
    cout<<maxS<<" "<<mini;
```

------------
到此结束。

---


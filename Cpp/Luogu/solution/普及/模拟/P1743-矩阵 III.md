# 矩阵 III

## 题目背景

usqwedf 改编系列题。


## 题目描述

给定一个 $n\times m$ 的矩阵，问从左上角走到右下角有多少条路径，保留 $17$ 位有效数字（也就是从第 $18$ 位有效数字以后均输出 $0$）。


## 说明/提示

$1\le n\le 10^8,1\le m\le 4$。



## 样例 #1

### 输入

```
6 4```

### 输出

```
210```

# 题解

## 作者：06ray (赞：23)

其实这道题有一种比递推更巧妙的算法，就是排列组合（其实我是小学生）。用排列组合来写的话答案应是C（n+m，n）。但为什么结果就是C（n+m，n）呢，因为从左上角必须要走n+m步才能到达右下角。而且还必须要有n步是往下走的，往下走的n步是可以任何时候走的。因此，方法数就是在n+m的步数中，挑n步的方法数（不允许重复）。也就是C（n+m，n）。

最后献上华丽丽的代码。

```cpp
var
 n,m,i:longint;
function C(a,b:longint):extended;//求C（n+m,n）的函数
begin
   C:=1;//应赋为1
    for i:=a downto b+1 do
    C:=C*i/(i-n);//套用公式
    exit(C);
end;
begin
 read(n,m);//读入n,m
 writeln(C(n+m,n):0:0);//输出C(n+m,n),注意要保留0位小数哦，因为返回的是extended（实型）。
end.
```

---

## 作者：随便5057 (赞：15)

此题难点在数据啊，思路已有大佬题解介绍了，蒟蒻不敢讲，这里只给出一个方便输出的办法。

首先敲出运算代码(n从1开始，不考虑0)

m=1时,{ans}=2,3,4,5,……n+1;

即ans=n+1;

m=2时,{ans}=3,6,10,15,……(n+1)* (n+2)/2;

即ans=(n+1)* (n+2)/2;

m=3时,{ans}=4,10,20,35……(n+1)* (n+2)* (n+3)/6;

即ans=(n+1)* (n+2)* (n+3)/6;

m=4时,{ans}=5,15,35,70……(n+1)* (n+2)* (n+3)* (n+4)/24;

即ans=(n+1)* (n+2)* (n+3)* (n+4)/24;


对于大数可以用long double存数，然后while（ans>=1e17)就÷10，
```
while(ans>=1e17)ans/=10;
```
这样就有了前17位。再同时开一个计数器t（int就行）记录÷的次数，也就是末尾的0的个数
```
while(ans>=1e17)ans/=10,t++;
```
拼接输出就行
```cpp
printf("%0.Lf",ans);
for(int i=1;i<=t;i++)printf("0");
```

AC代码分割线
------------

```cpp
#include<bits/stdc++.h>
using namespace std;
long double n,m,n2;
int t;
int main()
{
    cin>>n>>m;
    if(m==1)n=n+1;
    else if(m==2)n=(n+1)*(n+2)/2;
    else if(m==3)n=(n+1)*(n+2)*(n+3)/6;
    else n=(n+1)*(n+2)*(n+3)*(n+4)/24;
    while(n>=1e17)n/=10,t++;
    printf("%.0Lf",n);
    for(int i=1;i<=t;i++)printf("0");
    return 0;
}
```



---

## 作者：皎月半洒花 (赞：11)

这个题还可以吧……大约普及组T3难度（~~虽然我并不知道什么难度是普及难度…~~）

_____


前置技能：
$$\sum i = n(n + 1)/2$$

$$\sum i^2 = \frac{n\cdot(n + 1) \cdot(2n+1)}{6}$$

$$\sum i^3 = (\sum i )^2 = \frac{n^2(n+1)^2}{4}$$

其中$i \in [1,N]$且$i \in \mathbb Z$

_____


这个题最麻烦的地方是推式子而已，其余的直接$long ~double$爆算即可。

但是爆算也是有技巧的，我们发现$n$很大，$m$很小只有$4$，所以我们分类讨论即可。

哦，忘记了，这个题的$n \& m$都是指格的数量而不是点的数量，所以我们处理点时要$++n$

之后说正解：

* 当$m=0$时，此时只有一排点，只可以向下走，所以方案数为$1$

* 当$m=1$时，此时有两列点，因为我们为了到终点是必须向右走的，而我们可以从任意一行选择向右走——因为不能返回，所以方案数为$n$
* 当$m=2$时，我们可以把它转化为$m=1$的情况，即每到一个点都可以向右走从而到达了$m=1$的局面，那么总答案就是$$\sum \limits _{i=1}^{n}i = \frac{n \times(n+1)}{2}$$

* 同理，当$m=3$时继续转化，我们的答案就是$$\sum \sum i(i \in [1,N] \&i\in \mathbb Z) = \frac{n(n+1)(2n+1)}{12} + \frac{n(n+1)}{4}$$

* 那么最后$n=4$的情况下，我们继续转化：
$$Ans = \sum \sum \sum i = \frac{n(n+1) + 2 \cdot n(n+1)(2n+1)+ n^2(n+1)^2}{24} + \frac{n(n+1)}{8}$$

然后本题就是$O(1)$的了。

之后我们要**保留前17位有效数字**，由于本题数据神坑，（迄今为止）未说明保留17位有效数字，所以十分$GG$……

那我们最后算出来的是一个科学计数法，所以我们要手写输出,用一个栈即可。
```cpp
const double eps = 1 ;

inline void Print(long double A){
	int cnt = 0 ;
	long double B, T ;
	while (A > eps) 
		B = floorl(A / 10),
		T = A - B * 10, S.push((int)(T)), A /= 10 ;
	while (!S.empty()){
		++ cnt ;
		if (cnt <= 17) printf("%d", S.top()), S.pop() ;
		else printf("0"), S.pop() ;
	}
}
```
注意$eps=1$这个东西……因为我们要的是整数位$233$

完整代码：

```cpp
#include <cmath>
#include <stack>
#include <cstdio>
#include <iostream>

using namespace std ;
stack <int> S ;
const double eps = 1 ;
long double Ans ; long long N, M ;

inline void Print(long double A){
	int cnt = 0 ;
	long double B, T ;
	while (A > eps) 
		B = floorl(A / 10),
		T = A - B * 10, S.push((int)(T)), A /= 10 ;
	while (!S.empty()){
		++ cnt ;
		if (cnt <= 17) printf("%d", S.top()), S.pop() ;
		else printf("0"), S.pop() ;
	}
}
int main(){
	cin >> N >> M ; ++ N ;
	if (M == 0) cout << "1" << endl ;
	else if (M == 1) cout << N << endl ;
	else if (M == 2) Print(N * (N + 1) / 2) ;
	else if (M == 3){
		Ans = (long double)N * (long double)(N + 1) * (long double) (2 * N + 1) / 12 ;
		Ans += N * (N + 1) / 4 ; Print(Ans + 0.5) ;
	}
	else if (M == 4){
		Ans += (long double)N * (long double)(N + 1.0) + (long double)N * 2.0 * (long double)(N + 1.0) * (long double)(2 * N + 1.0) ;
		Ans += (long double)N * (long double)N * (long double)(N + 1.0) * (long double)(N + 1.0) + (long double)(N * 3.0) * (long double)(N + 1) ;
		Ans = Ans / 24.0 ; Print(Ans + 0.5) ;
	}
	return 0 ;
}
```



---

## 作者：hensier (赞：10)

[获得更好的阅读体验](http://shenyouran.github.io/P1743/)

在一个 $n \times m$ 的矩阵中，我们要求出从左上角到 右下角的方案种数。目前将点视为方格。

根据加法原理可知，对于每一个在矩阵中的点 $(i,j)$，它如果不是从上方而来，就必定从左侧来。因而点 $(i,j)$ 的路径总数就等于 $(i-1,j)$ 的路径总数和 $(i,j-1)$ 的路径总数之和。

当 $n=3,m=2$ 时，若用红色数字表示前往该点的方案种数，则有：

|坐标|$1$|$2$|$3$|
| :----------: | :----------: | :----------: | :----------: |
|$1$|$\red 1$|$\red 1$|$\red 1$|
|$2$|$\red 1$|$\red 2$|$\red 3$|

我们不难发现，每一个格子的值实质上是左上角和左侧的数字之和：

|坐标|$1$|$2$|$3$|
| :----------: | :----------: | :----------: | :----------: |
|$1$|$\red 1$|$\red 1$|$\red 1$|
|$2$|$\red 1$|$\red {1+1=2}$|$\red {2+1=3}$|

如果用 $f_{i,j}$ 来表示从 $(1,1)$ 到 $(i,j)$ 的方案种数，则有状态转移方程：

$$f_{i,j}=
\begin{cases}
1 & i=1 \text{ or } j=1 \cr
f_{i-1,j}+f_{i,j-1} & i \neq 1 \text{ and } j \neq 1 \cr
\end{cases}$$

我们考虑 $n=4,m=4$ 的情况：

|坐标|$1$|$2$|$3$|$4$|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1$|$\red 1$|$\red 1$|$\red 1$|$\red 1$|
|$2$|$\red 1$|$\red 2$|$\red 3$|$\red 4$|
|$3$|$\red 1$|$\red 3$|$\red 6$|$\red {10}$|
|$4$|$\red 1$|$\red 4$|$\red {10}$|$\red {20}$|

我们不妨将上述的图表围绕左上角的点顺时针旋转 $45^{\circ}$，得到类似这样的图：（本图为某数学竞赛试题的解析图）

![](https://cdn.luogu.com.cn/upload/image_hosting/4b4esd9u.png)

我们可以很容易地判断出这个图形是杨辉三角。这也解释了先前所提到的状态转移方程为什么只和前面两个值的和有关。

然而，因为 $n \le 10^8$，因而数组是开不下的，我们必须得寻找规律。突破口就是 $m \le 4$ 的这个限制条件。

实际上，点的总个数 $\neq n \times m$，因为点在外围，而每一个小格在内部。每一排的点的个数为 $n+1$，故以下所提及到的 $n$ 均比输入的要大 $1$，而 $m$ 已经进行了考虑，与输入保持不变。

因此，当 $m=0$ 时，任何一个点 $(1,x)$ 的路径总数只能从其左侧拓展而来（只有一整行的点），故值都为 $1$。

当 $m=1$ 时，答案必定为 $n$。

当 $m=2$ 时，不难发现，答案为 $\dfrac{n(n+1)}{2}$。

当 $m=3$ 时，$f_{3,i}$ 与 $f_{3,i-1}$ 之差为 $\dfrac{i(i+1)}{2}$，即：

|**项数**|$1$|$2$|$3$|$4$|$...$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: 
|**数值**|$\dfrac{1 \times 2}{2}$|$\dfrac{1 \times 2}{2}+\dfrac{2 \times 3}{2}$|$\dfrac{1 \times 2}{2}+\dfrac{2 \times 3}{2}+\dfrac{3 \times 4}{2}$|$\dfrac{1 \times 2}{2}+\dfrac{2 \times 3}{2}+\dfrac{3 \times 4}{2}+\dfrac{4 \times 5}{2}$|$...$|

那么：

$$f_{3,n}=\dfrac{1}{2} \sum_{i=1}^{n}i(i+1)$$

$$=\dfrac{1}{2}(\sum_{i=1}^{n}{i^2}+\sum_{i=1}^{n}i)$$

$$=\dfrac{1}{2}[\dfrac{n(n+1)(2n+1)}{6}+\dfrac{n(n+1)}{2}]$$

$$=\dfrac{n(n+1)(2n+1)+3n(n+1)}{12}$$

$$=\dfrac{n(n+1)(2n+4)}{12}$$

$$=\dfrac{n(n+1)(n+2)}{6}$$

当 $m=4$ 时，$f_{4,i}$ 与 $f_{4,i-1}$ 之差为 $\dfrac{i(i+1)(i+2)}{6}$，因此：

$$f_{4,n}=\dfrac{1}{6} \sum_{i=1}^{n}i(i+1)(i+2)$$

$$=\dfrac{1}{6} (\sum_{i=1}^{n}{i^3}+\sum_{i=1}^{n}{3i^2}+\sum_{i=1}^{n}{2i})$$

$$=\dfrac{1}{6} [(\sum_{i=1}^{n}{i})^2+\dfrac{n(n+1)(2n+1)}{2}+n(n+1)]$$

$$=\dfrac{1}{6} \{[\dfrac{n(n+1)}{2}]^2+\dfrac{n(n+1)(2n+1)}{2}+n(n+1)\}$$

$$=\dfrac{1}{6} [\dfrac{n^2(n+1)^2}{4}+\dfrac{n(n+1)(2n+1)}{2}+n(n+1)]$$

$$=\dfrac{1}{6} [\dfrac{n^2(n+1)^2+2n(n+1)(2n+1)+4n(n+1)}{4}]$$

$$=\dfrac{1}{24}n(n+1) [n(n+1)+2(2n+1)+4]$$

$$=\dfrac{1}{24}n(n+1) (n^2+5n+6)$$

$$=\dfrac{n(n+1)(n+2)(n+3)}{24}$$

综上可得：

$$\text{ans}=
\begin{cases}
1 & m=0 \cr
n & m=1 \cr
\dfrac{n(n+1)}{2} & m=2 \cr
\dfrac{n(n+1)(n+2)}{6} & m=3 \cr
\dfrac{n(n+1)(n+2)(n+3)}{24} & m=4 \cr
\end{cases}$$

进一步观察可知，这其实与排列组合有着密切关系，我们不难发现，答案可以用 $C^{m}_{n+m-1}$ （即$\dfrac{(n+m-1)!}{m!(n-1)!}$）来表示。这也就是杨辉三角的精髓所在。

当 $n=10^8$ 时，答案最大可以达到 $10^{31}$ 的数量级，这显然要大于 $2^{100}$，因此我们可以使用浮点数类型或者 `__int128_t`（正规竞赛可能无法使用）。

`C/C++` 使用浮点类型（组合意义）：

```cpp
#include<stdio.h>
int n,m;
long double x=1;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    printf("%.0Lf",x);
    return 0;
}
```

`C/C++` 使用浮点类型（通项公式）：

```cpp
#include<stdio.h>
int n,m;
int main()
{
    scanf("%d%d",&n,&m);
    n++;//预先将 n 的值加 1，方便计算
    if(m==1)printf("%d",n);
    else if(m==2)printf("%.0Lf",0.5L*n*(n+1));//在没有小数点的情况下，一个数后加 L 表示 long 类型；而如果有小数点，则代表 long double 类型
    else if(m==3)printf("%.0Lf",1.0L*n*(n+1)*(n+2)/6.0L);
    else printf("%.0Lf",1.0L*n*(n+1)*(n+2)*(n+3)/24.0L);
    return 0;
}
```

`C/C++` 使用 `__int128_t` 类型（组合意义）：

```cpp
#include<stdio.h>
int n,m;
__int128_t x=1;
void print(__int128_t x)//__int128_t 类型不提供标准输入输出，需要手写输出函数
{
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    print(x);
    return 0;
}
```

然而，由于题目本身和数据的原因，我们得知只需要输出前 $17$ 个数位，后面全部输出 $0$。

结合 `C++` 的 `string` 可以保存所有数位，并按要求输出：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
__int128_t x=1;
string s;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    while(x)
    {
        s+=x%10+48;//将末位字符拼接在字符串之后
        x/=10;
    }
    reverse(s.begin(),s.end());//将字符串倒置
    for(int i=0;i<17&&s[i];i++)putchar(s[i]);//先输出前 17 个字符
    for(int i=17;s[i];i++)putchar('0');//如果字符串第 17 位（下标从 0 开始）不为空，就继续输出直到对应字符为空
}
```

利用 `C/C++` 的 `char` 数组依然也可以完成：

```cpp
#include<stdio.h>
int n,m,len,i,j;
__int128_t x=1;
char s[51];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    while(x)
    {
        s[len++]+=x%10+48;//方法与前者类似，只需改动下标，并同时将其用作保存字符数组长度的变量
        x/=10;
    }
    for(i=len-1,j=0;i>=0&&j<17;i--,j++)putchar(s[i]);//同时控制字符数组没有输出完+只输出前 17 位
    for(;i>=0;i--)putchar('0');//由于 i 为全局变量，因而可以沿用上次的值，如果 i >= 0 则说明输出尚未结束，应当输出直到下标 0 为止
    return 0;
}
```

---

## 作者：初学者1 (赞：6)

本题由于出题人usqwedf的问题，数据配得极弱，普通的extended就可以存储的下。

以下进入正题：

本题主要运用了排列组合。在一个长为n，宽为m的矩形当中，从(1,1)点到(n,m)的走法共有才C(n,n+m)种。C，也就是组合的计算公式是((n+m)\*(n+m-1)\*(n+m-2)\*…\*(m+1))/(n!)。

pascal中就是：for i:=n+1 to n+m do s:=s\*i/(i-n);

说了这么多，源代码如下：

```cpp
var n,m,i:longint;
    s:extended;
begin
  readln(n,m);s:=1;
  for i:=n+1 to n+m do s:=s*i/(i-n)；//组合公式
  writeln(s:0:0);
end.
```

---

## 作者：Ckger (赞：3)

这道题我是直接用组合数算的。

因为整个矩阵是$m \times n$的，那么从左上角走到右下角就必定需要向右走$m$步，向下走$n$步，所以总共要走的步数就是$m+n$步。那么其实总的方案数就是在总的步数$m+n$中，找出向右走$m$步的组合或者是向下走$n$步的组合即可。因此本体的答案即为$C(m,m+n)$或者是$C(n,m+n)$。

那么先把组合数的代码写出来：

```
//ll即为long long
inline ll C(ll p,ll q)//C(p,q)=q!/(p!(q-p)!)
{
	ll res=1;
	if (p==0) return res;
	for (register int i=p+1;i<=q;++i)
		res=res*i/(i-n);
	return res;
}
```

从代码可以看出，计算$C(p,q)$要从p+1循环到q。

在这里，q即为m+n，p可为m或n。显然，当p取n时，复杂度小得多（因为m是一个小于4的数）

因此，这个题目就变为了给出$m$和$n$，求出$C(n,m+n)$的题目了。

但这个时候你交上去还会是60分，因为当$m$和$n$都取最大值时，答案有30位，因此还得写个高精度啊（高精乘低精&高精除低精）。

最后，该题还有一个坑，就是答案只要保留前17位，之后的全输出0（害我调了好久qwq）

之后便可以愉快的**AC**了。

code:
```
#include<cstdio>
#include<ctype.h>
#include<iostream>
#include<cstring>
using namespace std;
#define ll long long
inline ll read();

struct big_num
{
	int a[1010];
	int len;
	inline void big_num_memset()
	{
		memset(a,0,sizeof(a));
		a[1]=1;
		len=1;
	}
};

big_num operator * (const big_num &a,const int b)
{
	int L=a.len,jw=0;
	big_num c=a;
	for (register int i=1;i<=L;++i)
	{
		c.a[i]=c.a[i]*b+jw;
		jw=c.a[i]/10;
		c.a[i]%=10;
	}
	++L;
	c.a[L]=jw;
	while (c.a[L]!=0)
		c.a[L+1]+=c.a[L]/10,c.a[L]%=10,++L;
	--L;
	c.len=L;
	return c;
}

big_num operator / (const big_num &a,const int b)
{
	big_num c=a;
	int tw=0,L=a.len;
	for (register int i=L;i>=1;--i)
	{
		int k=(tw*10+c.a[i])/b;
		tw=(tw*10+c.a[i])%b;
		c.a[i]=k;
	}
	while (c.a[L]==0) --L;
	c.len=L;
	return c;
}

inline big_num C(ll n,ll m)//C(n,m)=m!/(n!(m-n)!)
{
	big_num res;
	res.big_num_memset();
	if (n==0) return res;
	for (register int i=n+1;i<=m;++i)
		res=res*i/(i-n);
	return res;
}

inline void print(big_num a)
{
    if (a.len>17)
    {
        for (register int i=a.len;i>=a.len-16;--i)
            cout<<a.a[i];
        for (register int i=a.len-17;i>=1;--i)
			cout<<"0"; 
    }
    else
	    for (register int i=a.len;i>=1;--i)
	    	cout<<a.a[i];
}

ll n,m;

int main()
{
	n=read(),m=read();
	print(C(n,m+n));
	return 0;
}

inline ll read()
{
	ll x=0,f=0;
	char c=getchar();
	while (!isdigit(c))
		f|=c=='-',c=getchar();
	while (isdigit(c))
		x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return f?-x:x;
}
```

话说，~~int128它不香吗~~。

---

## 作者：_ZhouYuHan_ (赞：2)

这道题要用到排列组合。

我们从左上角走到右下角，实际上就是从 $n+m$ 的步数中选 $n$ 步，即 $C_{n+m}^n$。

这道题 ```long long``` 存不下，所以我们开 ```long double```。

这道题只需保留前 $17$ 位即可 ~~，为什么题目中没说~~ 。

AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, cnt;
int main () {
   long double ans = 1;//存储答案
	cin >> n >> m;
	for (int i = n+1; i <= n+m; i++)
		ans *= i;//计算乘
	for (int j=1; j <= m; j++)
		ans /= j;//计算除
	while(ans >= 1e17) {//保留前17位
		ans/=10;
		cnt++;
	}
	printf("%.0LF",ans) ;
	while(cnt--)
		cout << "0";
	return 0 ;
}
```

---

## 作者：ryf_loser (赞：1)

经典排列组合问题

首先，我们可以手动模拟一下

![](https://cdn.luogu.com.cn/upload/image_hosting/5ew0xxcw.png)

这是不是像一个杨辉三角？

当你把次方阵斜过来观察时，就会发现 $f(n)(m)=f(n-1)(m-1)+f(n-1)(m)$。

由此我们可以推出杨辉三角通项公式当 
1. $m=1$ 时 $ans\leftarrow n+1$
1. $m=2$ 时 $ans\leftarrow \frac{(n+1)\times(n+2)}{2}$
1. $m=3$ 时 $ans\leftarrow \frac{(n+1)\times(n+2)\times(n+3)}{6}$
1. $m\geq 4$ 时的 $ans\leftarrow \frac{(n+1)\times(n+2)\times(n+3)\times(n+4)}{24}$

由此，我们可以很容易的推出通项公式（大家一定很熟悉排列和组合的通项公式，~~毕竟小学大家就一定学过了~~）

如果不会，请点这里[排列组合介绍](https://baike.baidu.com/item/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/706498)

下面是 AC 代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long double n,m;//数会很大，请开 long double
int ans;
int main(){
    cin>>n>>m;
    if(m==1)n=n+1;
    else if(m==2)n=(n+1)*(n+2)/2;
    else if(m==3)n=(n+1)*(n+2)*(n+3)/6;
    else n=(n+1)*(n+2)*(n+3)*(n+4)/24;//公式
    while(n>=1e17)n/=10,ans++;//保留 17 位有效数字
    printf("%.0Lf",n);
    for(int i=1;i<=ans;i++)printf("0");
    return 0;
}
```



---

## 作者：sid_shi1 (赞：1)

题目：[P1743 矩阵 III](https://www.luogu.com.cn/problem/P1743)

这其实是道很简单的数论题，主要考察排列组合和优化。

刚看到题时，原本想打暴力的标数法，但是 $n$ 到了 $100000000$ ,肯定会超时，我们需要一种更快的算法。

首先，从矩阵的左上角走到右上角，需要 $n+m$ 步，而这些步中有 $n$ 步是往右走的（也可以说有 $m$ 步往下走），那么就会有 $C(n+m,n)$ 种走法，意为从 $n+m$ 步中选 $n$ 步出来往右走，代码就比较简单了。

我们要写两个循环分别来算分子和分母,比较坑的是要开 $long$ $double$ ,这些代码实现起来比较容易。

接下来是两个优化：

我们知道， $C(n+m,n)$ 和 $C(n+m,m)$ 是一样的，而题目中 $m$ 最大为 $4$ ，用 $C(n+m,m)$ 肯定会快的多，否则会超时。

另外，本题的答案很大，末尾会有多个 $0$ ，我们就可以拿个变量来记末尾有多少个 $0$ ，答案只记前面的非 $0$ 部分，最后再输出这么多个 $0$ 即可。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,cnt=0;
	long double ans=1;//注意是long double
	scanf("%d%d",&n,&m);
	if(n>m) swap(n,m); //取最小值
	for(int i=n+m;i>=m+1;i--) ans*=i;//分子
	for(int i=n;i>=1;i--) ans/=i;//分母
	while(ans>=100000000000000000){//去除超过范围的末尾的0
		ans/=10;
		cnt++;
	}
	printf("%0.0LF",ans);//输出在范围内的部分
	for(int i=cnt;i>=1;i--) printf("0");//输出超出范围的一些0
	return 0 ;
}
```


---


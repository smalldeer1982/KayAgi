# H数

## 题目描述

所谓 H 数，是指只含有 $2,3,5,7$ 这些质因数的数，如 $630$ 是 H 数，而 $22$ 不是。

现在要求输出第 $n$ 个 H 数，为了方便起见将 $H[1]$ 定为 $1$。已知 $n$ 不超过 $10000$，最后数据在 int64 范围之内。


## 说明/提示

穷举会爆掉，要用生成法，最好加优化，不然空间复杂度比较大


## 样例 #1

### 输入

```
30```

### 输出

```
49```

## 样例 #2

### 输入

```
1```

### 输出

```
1```

# 题解

## 作者：355_113 (赞：56)

作为一名实际上已退役的前选手，这是近一段时间里做的第一题，当然要发题解了。

曾经也算有点水平，但现在这种水题都错了半天。

如果打过cf的话应该挺熟悉这种题，Div2的AB题都可能是这类，基本就是构造。

对于本题而言，只需要在之前的所有H数上各乘上2、3、5或7，取未出现的最小值就可以，但很明显，有很多多余的计算。

我们设立4个变量a,b,c,d，初始时都为1，a记录上一个**被2乘所得到的**H数的序号，b记录上一个**被3乘所得到的**H数的序号，以此类推，那么H[1]=1，之后的每个H[i]都等于min(a×2,b×3,c×5,d×7)，随时更新a、b、c、d，一重循环即可求出H(n)。

由于本题多组数据，所以很自然地想到在程序开头预处理出10000个H数，之后读入后直接输出对应的H数即可。

说了半天，其实和楼下的方法一样，放上C++代码，或许可供后来者借鉴。


```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n,a=1,b=1,c=1,d=1;
    long long w[10090];
    int main(){
        w[1]=1;
        for(int i=2;i<=10000;++i){
            w[i]=w[a]*2;
            if(w[i]>w[b]*3)w[i]=w[b]*3;
            if(w[i]>w[c]*5)w[i]=w[c]*5;
            if(w[i]>w[d]*7)w[i]=w[d]*7;
            if(w[i]==w[a]*2)a++;
            if(w[i]==w[b]*3)b++;
            if(w[i]==w[c]*5)c++;
            if(w[i]==w[d]*7)d++;
        }
        while(scanf("%d",&n)!=EOF)
            cout<<w[n]<<"\n";
        return 0;
}
```

---

## 作者：kradcigam (赞：31)

# 我来讲讲 $dp$ 的做法

## 前言

昨天 $PHY$ 大佬问我，这题怎么做？考虑到他没学过 $set$ 、 $priority_queue$ 和 $queue$ 。之后，我就想到了可以用 $dp$ 来解决这道题。

## 正文

### 设置状态

很显然，我们可以用 $f[i]$ 表示第$i$个数是多少。

### 转移

第$i$个$H$数是多少，我们显然应该从前面的$i-1$个数去分别$\times2$、$\times3$、$\times5$、$\times7$中取比第$i-1$个$H$数大的最小数。

### 边界条件

$f_1=1$是很显然的

此外还要注意$f_0=0$

### 代码

我们现在就可以开始写代码了

**注意开$long$ $long$**

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &FF){
    T RR=1;FF=0;char CH=getchar();
    for(;!isdigit(CH);CH=getchar())if(CH=='-')RR=-1;
    for(;isdigit(CH);CH=getchar())FF=(FF<<1)+(FF<<3)+(CH^48);
    FF*=RR;
}
template<typename T>void write(T x){
    if(x<0)putchar('-'),x*=-1;
    if(x>9)write(x/10);
    putchar(x%10+48);
}
long long f[10010];
int main(){
    memset(f,127,sizeof(f));//为了找最小，我们最开始就得赋成最大
    int n;
    read(n);
    f[0]=0;//初始化
    f[1]=1;//初始化
    for(int i=2;i<=n;i++)
        for(int j=i-1;j>=1;j--)
            if(f[j]*2>f[i-1])f[i]=min(f[i],f[j]*2);
            else if(f[j]*3>f[i-1])f[i]=min(f[i],f[j]*3);
                else if(f[j]*5>f[i-1])f[i]=min(f[i],f[j]*5);
                    else if(f[j]*7>f[i-1])f[i]=min(f[i],f[j]*7);
                        else break;//优化
    write(f[n]);//输出
    return 0;
}
```
## 后记

这个代码还是很简短的，十分好写，希望大家以后学习也能好好想想一题多解

最后来求一下赞和评论！

---

## 作者：x_angelkawaii_x (赞：15)

看到题解中没有set,我来补一发。。。  
这样最虽然牺牲了一个$logn$,但是代码更简洁易懂一些  
就是每次从set中取出最小的数$u$,然后把$u*{2,3,5,7}$怼进set中  
不用priority_queue的原因是set自带去重  
注意特判$n=0$的情况  
代码:
```cpp
#define LL long long
int n;
set<LL>q;
int main()
{
    scanf("%d",&n);
    if(!n)
    {
        printf("0\n");
        return 0;
    }
    q.insert(1);
    set<LL>::iterator L=q.begin();
    for(int _=1;_<n;++_)
    {
        LL u=*L;
        q.insert(u*2),q.insert(u*3),q.insert(u*5),q.insert(u*7);
        L++;
    }
    printf("%lld\n",*L);
}

```

---

## 作者：hensier (赞：10)

这道题一开始我有多种思路。

【思路$1$：暴力穷举（推荐程度：☆☆☆）】

竞赛期间，如果没有其他思路，只能采用这种骗分的方法。

我们在$[1,∞)$区间进行查找。具体的查找方式是：不停地对该数除以$2,3,5,7$，直到无法整除为止——最后判断除完的数是否为$1$。如果满足的数量等于$n$则输出$i$并结束程序。

于是我们得到了~~48分的TLE~~代码：[（提交记录）](/record/30957721)
```cpp
#include<cstdio>
long long n,t,i;
int mark[]={2,3,5,7},j,x;
int main()
{
    scanf("%lld",&n);
    for(i=1;;i++)
    {
        t=i;
        for(j=0;j<4;j++)while(t%mark[j]==0)t/=mark[j];
        if(t==1)
        {
            if(++x==n)
            {
                printf("%lld",i);
                break;
            }
        }
    }
}
```

【思路$2$：生成法（推荐程度：★★★★）】

![](https://cdn.luogu.com.cn/upload/image_hosting/aj2dpdw3.png)

如上图，我们可以维护五个队列，分别保存$2$的倍数、$3$的倍数、$5$的倍数、$7$的倍数和H数。

该代码的核心部分为：

```cpp
for(i=2;i<=n;i++)
{
    M=q2[f[0]];
    if(q3[f[1]]<M)M=q3[f[1]];
    if(q5[f[2]]<M)M=q5[f[2]];
    if(q7[f[3]]<M)M=q7[f[3]];
    h[i]=M;
    q2[r[0]]=h[i]*2;r[0]++;
    q3[r[1]]=h[i]*3;r[1]++;
    q5[r[2]]=h[i]*5;r[2]++;
    q7[r[3]]=h[i]*7;r[3]++;
    if(q2[f[0]]==M)f[0]++;
    if(q3[f[1]]==M)f[1]++;
    if(q5[f[2]]==M)f[2]++;
    if(q7[f[3]]==M)f[3]++;
}
```
上述的$q$队列没有使用图中的$q[]$，而是直接使用$q[2],q[3],q[5],q[7]$。这样做会让代码更复杂，但更容易理解。

【思路$3$：生成法单队列（推荐程度：★★★★★）】

我们来详细地了解一下这个方法。在这个方法中，我们可以用$4$个指针+$1$个队列的方法大大优化代码。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wlh15hs0.png)

因此，我们对于这个队列，只需要$4$个存放$int$类型的变量作为指针即可。一开始四个指针均等于$1$，然后每一次进行判断，每一次可以向右移动一次指针，而这四种移动的最小值将被存入$h[]$数组中。

所以我们可以得到$AC$代码[（提交记录）](/record/30958052):

```cpp
#include<cstdio>
int n,i,j,f[4]={1,1,1,1},m[]={2,3,5,7};//这四个指针分别为2、3、5、7，而一开始指针都位于1，所以要进行初始化
long long h[100001],M;//不开long long会爆掉！
int main()
{
    scanf("%d",&n);
    h[1]=1;//h[1]初始化为1
    for(i=2;i<=n;i++)
    {
        M=h[f[0]]*m[0];//默认最小值为指针f2所产生的数，然后在3、5、7所产生的数中进行判断，找出2、3、5、7所产生数的最小值（如下）
        for(j=1;j<4;j++)if(h[f[j]]*m[j]<M)M=h[f[j]]*m[j];
        h[i]=M;//这个时候把h[i]赋值为最小值，即M
        for(j=0;j<4;j++)if(M==h[f[j]]*m[j])f[j]++;//判断过后，最小值所对应的指针要向右，即加1
    }
    printf("%lld",h[n]);//最后输出h[]数组中的第n个元素即可
}
```

---

## 作者：方方小逗逼 (赞：7)

（这题撒吧）只是吐槽。。。

首先，n=10000时要输n=9999

其次，输入输出没有input和output

最后，我用了暴搜。。。（我就是暴搜界的传奇）

首先，a[i]=0，然后在没一个h数的基础上分别乘2/3/5/7，取最小，ok

我闲的蛋疼，每一次都求了10000个h数，还是0ms。。。

代码如下：

```cpp
var
  s:string;
  n,i1,i2,i3,i4,i:longint;
  a:array [1..10000] of int64;
begin
  a[1]:=1;
  i1:=1;
  i2:=1;
  i3:=1;
  i4:=1;
  for i:=2 to 10000 do
  begin
    a[i]:=a[i1]*2;
    if a[i]>a[i2]*3 then a[i]:=a[i2]*3;
    if a[i]>a[i3]*5 then a[i]:=a[i3]*5;
    if a[i]>a[i4]*7 then a[i]:=a[i4]*7;
    if a[i]=a[i1]*2 then inc(i1);
    if a[i]=a[i2]*3 then inc(i2);
    if a[i]=a[i3]*5 then inc(i3);
    if a[i]=a[i4]*7 then inc(i4);
  end;
  while not(eof) do
  begin
    readln(s);
    val(s,n);
    writeln(a[n]);
  end;
end.
```

---

## 作者：WanderingTrader (赞：5)

这道题其实和 [UVA136 丑数 Ugly Numbers](https://www.luogu.com.cn/problem/UVA136) 的解法是如出一辙的。  
### 题目分析
题中提示我们要用构造法，下面简述构造思路。  

假设 $x$ 已经确定是个H数，那么由H数的定义可以得到 $2x,3x,5x,7x$ 都是丑数。  
而题目说丑数要从小到大排，所以使用类似 **BFS(广度优先搜索)** 的方法，但放入的是一个 **优先队列** 。  

当然，这个方法我最早是在刘汝佳老师的紫书上看到的。
### 代码
我们需要一个优先队列来保存数据，还要用一个map来保存数据是否已经取过（即BFS中的vis）：
```cpp
#define ll long long
priority_queue <ll,vector <ll>,greater <ll> > Q;
map <ll,bool> m;
```
为了方便，我们定义一个xx数组存放2,3,5,7四个数：
```cpp
ll xx[4] = {2,3,5,7};
```
初始化：
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <map>
using namespace std;
#define ll long long
priority_queue <ll,vector <ll>,greater <ll> > Q;
map <ll,bool> m;
ll xx[4] = {2,3,5,7};
int main()
{
	int n,cnt = 0;
	ll ans=1;
	scanf("%d",&n);
	Q.push(1);
```
这道题有个坑：第13个点输入是0，输出也是0，所以要做一个特判：
```cpp
if(n < 1) {printf("0\n");return 0;}
```
接着是BFS部分，条件是 $cnt<n$：
```cpp
while(cnt < n)
{
}
```
如果队头元素已访问，那就跳过：
```cpp
ans = Q.top();
Q.pop();
if(m[ans])
	continue;
m[ans] = true;
```
把 $cnt+1$，遍历xx数组更新优先队列：
```cpp
++cnt;
for(int i = 0;i < 4;++i)
	Q.push(xx[i]*ans);
```
BFS就完成了。  

最后输出答案即可。  
全部代码：
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <map>
using namespace std;
#define ll long long
priority_queue <ll,vector <ll>,greater <ll> > Q;
map <ll,bool> m;
ll xx[4] = {2,3,5,7};
int main()
{
	int n,cnt = 0;
	ll ans=1;
	scanf("%d",&n);
	if(n < 1) {printf("0\n");return 0;}
	Q.push(1);
	while(cnt < n)
	{
		ans = Q.top();
		Q.pop();
		if(m[ans])
			continue;
		m[ans] = true;
		++cnt;
		for(int i = 0;i < 4;++i)
			Q.push(xx[i]*ans);
	}
	printf("%lld\n",ans);
	return 0;
}
```
复杂度还是非常低的，约是$O(n\log n)$，在 $n\le10000$ 时完全ok。  
题目里也说了，答案都在int64内，所以long long 完全是OK的。  
$$\mathrm{The\ End.}$$

---

## 作者：Rainbow_qwq (赞：5)

[原题链接](https://www.luogu.org/problemnew/show/P1748)

这道题可以用堆来完成，但是如何去重是一个问题。

我的方法是：
```cpp
对于一个符合条件的数，
记录它的最大质因子。
如：
30=2*3*5,则30的最大质因子是5。
那我们只用>=5的数乘上30来更新。
也就是说，堆中只会更新2个数：
30*5=150 30*7=210
这样，就可以确保每个数只被放进堆中一次，
即可完成此题。
```
时间复杂度:$O(n (log n))$,可以通过本题。

至于如何存储，我使用了结构体+自定义小于号。

~~本蒟蒻不想手写堆，~~就用了STL优先队列。

**代码如下：**
```cpp
struct node{
	long long num;//存储的数，要开long long
	int maxp;	  //最大质因子的位置
	bool operator <(const node &q)const{return num>q.num;}
    //按存储的数排序
    //由于c++定义的是大根堆，所以反着定义小于号
};
priority_queue<node>q;
```
然后是主函数，比较容易写。

注意一开始要把(1,1)推进堆。
```cpp
inline int read(){//快读
	char c=getchar();int x=0;bool f=0;
	while(!isdigit(c))f^=!(c^45),c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f)x=-x;return x;
}
int n=read(),pos;
long long val;
const int p[5]={0,2,3,5,7};
int main()
{
	q.push((node){1,1});//把(1,1)推进堆
	while(n--)
	{
		val=q.top().num,pos=q.top().maxp;
		q.pop();
		for(int i=pos;i<=4;i++)
			q.push((node){val*p[i],i});
	}
	printf("%lld",val);
	return 0;
}
```
把两部分组合起来就是完整AC代码了。

（大家做完这题再去干掉[P2723 丑数 Humble Numbers](https://www.luogu.org/problemnew/show/P2723)吧！！）

---

## 作者：Ruo何言 (赞：5)

~~本蒟蒻来发表我的第一篇题解。~~

这一题可以说是一道队列的题目，准确来说是单调队列。

手动数组模拟一个队列，一个四指针队列。其head只有一个，但是其tail变量有四个（2，3，5，7各一个）

每次取四个队尾变量分别乘上2，3，5，7，将其进行比较，取其中最小加入队列并将其队尾加一；这样就可以满足队列的单调性，去除重复；

ps：记得long long

代码如下：
```cpp
#include <iostream>
#include <cstring>
#define _for(i,a,b) for (int i=(a); i<=(b); ++i)

using namespace std;
int n;
long long q[20000];
int z[5]={0,2,3,5,7};

long long _min(long long a,long long b,long long c,long long d)
{
	long long cnt=a; //这个判断最小值要注意，因为后面数据特别大，干脆就取其中一个值作为初始值，开始我在这个坑跌了好几遍；
	if(b<cnt) cnt=b;
	if(c<cnt) cnt=c;
	if(d<cnt) cnt=d;
	return cnt;
}
int main()
{
	cin >> n;
	q[1]=1;
	int t1=1,t2=1,t3=1,t4=1,head=1;
	while(head<n)
	{
		long long a=q[t1]*2,b=q[t2]*3,c=q[t3]*5,d=q[t4]*7;
		long long m=_min(a,b,c,d);
		q[++head]=m;
		if(a==m) ++t1; //有相同的值就同时加
		if(b==m) ++t2;
		if(c==m) ++t3;
		if(d==m) ++t4;
	}
	cout << q[n] << '\n';
	return 0;
}
```

---

## 作者：Leap_Frog (赞：3)

### Problem.
求第$n$个质因数只有$2,3,5,7$的数。

### PS.
笔者刚开始竟然没考虑到会有重复，真是大**。  
笔者考虑到有重复后竟然还想将错就错，暴力删重复。。。  
暴力删重复竟然还有$94$分。。。（[如图](https://www.luogu.com.cn/record/34631474)  
![](https://cdn.luogu.com.cn/upload/image_hosting/e9zic9p3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
错误代码！  
**错误代码！**  
$\color{red}\text{错误代码！}$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//重定义long long
priority_queue<ll,vector<ll>,greater<ll> >q;int n;//看，小根堆瞩目。
inline void pop() {int x=q.top();while(q.top()==x) q.pop();}//暴力删重复
int main()
{
    q.push(1ll),scanf("%d",&n);//初始化压入1
    if(!n) return puts("0"),0;//特判0（
    for(int i=2;i<=n;i++) q.push(q.top()*2ll),q.push(q.top()*3ll),q.push(q.top()*5ll),q.push(q.top()*7ll),pop();//构造
    return printf("%lld\n",q.top()),0;//输出并结束
}
```

### Solution.
看到题目中最后一行了吗！
```
穷举会爆掉，要用生成法，最好加优化，不然空间复杂度比较大
```
好啦，直接构造就好了QwQ！  
最好加优化，其实直接把构造过程中的废物扔掉就可以了！  

具体来说说怎么构造吧：  
设当前有一个数$x=2^a\times3^b\times5^c\times7^d$，
$y=2^a\times3^b\times5^c\times7^d/i$，
其中$i=2,3,5,7$  
则$x$与$y$全是H数，$x=y\times i$且$x>y$  
则我们可以通过$y$来构造出$x$。  
而对于$y$来说，越小的$y$可以构造出来越小的$x$（显然  
所以可以有一种简单的贪心，具体可见代码。

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
set<ll>q;int n;ll t;
int main()
{
    q.insert(1ll);//由题意，把1压入
    scanf("%d",&n);//读入n
    if(!n) return puts("0"),0;//n为0时要特盘
    for(int i=2;i<=n;i++)
    {
        t=*q.begin();//取出最小值（y
        q.insert(t*2);//变成各种的数（x i=2
        q.insert(t*3);//i=3
        q.insert(t*5);//i=5
        q.insert(t*7);//i=7
        q.erase(q.find(t));//把y给删掉
    }
    return printf("%lld\n",*q.begin()),0;
}
```
啊啊啊，为了清晰地展示代码把压行码风改掉真是受罪啊！！！wzbl

---


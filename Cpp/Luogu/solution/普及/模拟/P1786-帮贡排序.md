# 帮贡排序

## 题目背景

在 absi2011 的帮派里，死号偏多。现在 absi2011 和帮主等人联合决定，要清除一些死号，加进一些新号，同时还要鼓励帮贡多的人，对帮派进行一番休整。


## 题目描述

目前帮派内共最多有一位帮主，两位副帮主，两位护法，四位长老，七位堂主，二十五名精英，帮众若干。

现在 absi2011 要对帮派内几乎所有人的职位全部调整一番。他发现这是个很难的事情。于是要求你帮他调整。

他给你每个人的以下数据：

他的名字（长度不会超过 $30$），他的原来职位，他的帮贡，他的等级。

他要给帮贡最多的护法的职位，其次长老，以此类推。

可是，乐斗的显示并不按帮贡排序而按职位和等级排序。

他要你求出最后乐斗显示的列表(在他调整过职位后)：职位第一关键字，等级第二关键字。

注意：absi2011 无权调整帮主、副帮主的职位，包括他自己的（这不是废话么..）

他按原来的顺序给你（所以，等级相同的，原来靠前的现在也要靠前，因为经验高低的原因，但此处为了简单点省去经验。）


## 说明/提示

各种职位用汉语拼音代替。

如果职位剩 $1$ 个，而有 $2$ 个帮贡相同的人，则选择原来在前的现在当选此职位。

另：
帮派名号：星月家园

帮主尊号：Dragonfly Kang

帮派ID：2685023

帮派等级：4

帮派人数：101/110

帮派技能：

星月家园资料，欢迎各位豆油加入^\_^

【数据范围】

对于 $10\%$ 的数据，保证 $n=3$。

对于 $40\%$ 的数据，保证各个人的帮贡均为 $0$。

对于 $100\%$ 的数据，保证 $3\leq n\leq 110$，各个名字长度$\leq30$，$0\leq$ 各个人的帮贡 $\leq1000000000$，
$1\leq$ 各个人等级 $\leq 150$。

保证职位必定为 $\texttt{BangZhu}$，$\texttt{FuBangZhu}$，$\texttt{HuFa}$，$\texttt{ZhangLao}$，$\texttt{TangZhu}$，$\texttt{JingYing}$，$\texttt{BangZhong}$ 之中的一个

保证有一名帮主，保证有两名副帮主，保证有一名副帮主叫 absi2011

不保证一开始帮派里所有职位都是满人的，但排序后分配职务请先分配高级职位。例如原来设一名护法现在设两名。

保证名字不重复。

【题目来源】

fight.pet.qq.com


absi2011 授权题目


## 样例 #1

### 输入

```
9
DrangonflyKang BangZhu 100000 66
RenZaiJiangHu FuBangZhu 80000 60
absi2011 FuBangZhu 90000 60
BingQiLingDeYanLei HuFa 89000 58
Lcey HuFa 30000 49
BangYou3 ZhangLao 1000 1
BangYou1 TangZhu 100 40
BangYou2 JingYing 40000 10
BangYou4 BangZhong 400 1```

### 输出

```
DrangonflyKang BangZhu 66
RenZaiJiangHu FuBangZhu 60
absi2011 FuBangZhu 60
BingQiLingDeYanLei HuFa 58
BangYou2 HuFa 10
Lcey ZhangLao 49
BangYou1 ZhangLao 40
BangYou3 ZhangLao 1
BangYou4 ZhangLao 1```

# 题解

## 作者：翼德天尊 (赞：1072)

### 很明显，这是一道排序题，但是卡了很多人的一点是：
## 怎么排？
**由题意，我们经过一定时间的提炼可以总结出一下排序位置以及排序方式：**

1.所有信息输入后排序，排序方式如下：

（1）先按帮贡排序；

（2）如帮贡一样，则按输入顺序排列。

2.再重新编好职位后排输出顺序，也就是职位内的排名，排序方式如下：

（1）先按现在的职位排序；

（2）如职位相同，再按等级排序；

（3）如果恰好等级~~还破天荒地~~一样，则按输入顺序排列。

### 如果看到这你的疑惑已经解开了，那就点完赞继续写你的代码吧！还不会写的小伙伴们跟我来！
## 具体实施
### 1.输入与初始化
```c
int n;//储存帮内人数
struct node{
	string na,zw,xzw;//尊姓大名，过去高位，如今高位
	long long bg;//帮贡（不开long long见祖宗）
	int le,h;//等级，输入序号
}ab[115];//结构体储存信息，方便排序
cin>>n;
for (int i=1;i<=n;i++){
	cin>>ab[i].na>>ab[i].zw>>ab[i].bg>>ab[i].le;//分别输入
	ab[i].h=i;//处理序号
}
```
### 2.排序1（注意！帮主副帮主不会改变职位！
```c
//主函数内
sort(ab+4,ab+1+n,cmp1);
//排序函数1
int cmp1(node x,node y){
	if (x.bg==y.bg) return x.h<y.h;//帮贡相等，按序号排序；
	else return x.bg>y.bg;//否则按帮贡排序
}
```
### 3.授予职位
```c
for (int i=1;i<=n;i++){//按先顺序授予每个人职位
	if (i==1) ab[i].xzw="BangZhu";
	else if (i==2||i==3) ab[i].xzw="FuBangZhu";
	else if (i==4||i==5) ab[i].xzw="HuFa";
	else if (i>=6&&i<=9) ab[i].xzw="ZhangLao";
	else if (i>=10&&i<=16) ab[i].xzw="TangZhu";
	else if (i>=17&&i<=41) ab[i].xzw="JingYing";
	else ab[i].xzw="BangZhong";
}
```
### 4.排序2
```c
//主函数内
sort(ab+1,ab+1+n,cmp2);
//排序函数2
int cmp2(node x,node y){
	if (change(x.xzw)==change(y.xzw)){
		if (x.le==y.le) return x.h<y.h;//现职位相等且等级相等，按输入顺序排列
		return x.le>y.le;//等级不等按等级排序
	}
	return change(x.xzw)<change(y.xzw);//现职位不等按现职位大小排序，使用自定义change函数
}
//职位转化数字函数
int change(string a){
	if (a=="BangZhu") return 0;
	if (a=="FuBangZhu") return 1;
	if (a=="HuFa") return 2;
	if (a=="ZhangLao") return 3;
	if (a=="TangZhu") return 4;
	if (a=="JingYing") return 5;
	if (a=="BangZhong") return 6;
}
```
### 5.完美输出
```
for (int i=1;i<=n;i++){
	cout<<ab[i].na<<" "<<ab[i].xzw<<" "<<ab[i].le<<endl;
}
```
## AC代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
	string na,zw,xzw;
	long long bg;
	int le,h;
}ab[115];
int change(string a){
	if (a=="BangZhu") return 0;
	if (a=="FuBangZhu") return 1;
	if (a=="HuFa") return 2;
	if (a=="ZhangLao") return 3;
	if (a=="TangZhu") return 4;
	if (a=="JingYing") return 5;
	if (a=="BangZhong") return 6;
}
int cmp1(node x,node y){
	if (x.bg==y.bg) return x.h<y.h;
	else return x.bg>y.bg;
}
int cmp2(node x,node y){
	if (change(x.xzw)==change(y.xzw)){
		if (x.le==y.le) return x.h<y.h;
		return x.le>y.le;
	}
	return change(x.xzw)<change(y.xzw);
}

int main(){
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>ab[i].na>>ab[i].zw>>ab[i].bg>>ab[i].le;
		ab[i].h=i;
	}
	sort(ab+4,ab+1+n,cmp1);
	for (int i=1;i<=n;i++){
		if (i==1) ab[i].xzw="BangZhu";
		else if (i==2||i==3) ab[i].xzw="FuBangZhu";
		else if (i==4||i==5) ab[i].xzw="HuFa";
		else if (i>=6&&i<=9) ab[i].xzw="ZhangLao";
		else if (i>=10&&i<=16) ab[i].xzw="TangZhu";
		else if (i>=17&&i<=41) ab[i].xzw="JingYing";
		else ab[i].xzw="BangZhong";
	}
	sort(ab+1,ab+1+n,cmp2);
	for (int i=1;i<=n;i++){
		cout<<ab[i].na<<" "<<ab[i].xzw<<" "<<ab[i].le<<endl;
	}
    return 0;
}
```
## 我绝对不是dalao，但你看得这么认真，点个赞加个油吧！

---

## 作者：_Qer (赞：25)

~~嗯，上一个题解还是2015的~~~

结构体水题，就是很麻烦，排序搞的我头皮发麻

总的来说就是排序两遍，第一遍按帮贡排，算出应得的职位，第二遍在大体上的职位顺序不变的情况下，按第一关键字为等级，第二关键字为输入顺序的情况排序

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long inf = 0x7ffffffffffff;
//无穷大
const string work_name[] = {"BangZhu", "FuBangZhu", 
							"HuFa", "ZhangLao", 
                            "TangZhu", "JingYing", "BangZhong"};
//各个职位的名字，按照从大到小的顺序排列
const long long work_num[] = {1, 3, 5, 9, 16, 41, inf};
//按照从大到小的顺序，每个职位需排到多少名（优先职位大的）
map<string, int> w_n_level;
//一个map，以string为索引，存int
//可以看作一个数组下标为string类型的int数组
//这个map存各个职位的大小关系（职位小的值小，职位大的值大）
//map在main函数开头初始化
struct player {
    string name, work;
    //名称和职位
    long long help, level;
    //帮贡和等级
    int inn;
    //在输入中排的位置
} arr[150];
//一个结构体，存每个人的信息
int n;
//总人数
bool com(player a, player b) {
    if (a.help == b.help) {
    	//帮贡相同，按第二关键字输入顺序排
        return a.inn < b.inn;
    } else {
    	//按帮贡排
        return a.help > b.help;
    }
}
//第一遍排序要用的函数
bool com2(player a, player b) {
    if (a.work == b.work) {//第一关键字相等
        if (a.level == b.level) {
        	//第二关键字也相等，按输入顺序
            return a.inn < b.inn;
        } else {//按第二关键字等级排
            return a.level > b.level;
        }
    } else {//按第一关键字职位排
        return w_n_level[a.work] < w_n_level[b.work];
    }
}
//第二遍排序
int main() {
    for (int i = 0; i < 7; ++i) {
        w_n_level[work_name[i]] = i;
    }
    //初始化map
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> arr[i].name >> arr[i].work >> arr[i].help >> arr[i].level;
        //输入每个人的信息
        if (arr[i].work == work_name[0]) {
            arr[i].help = inf;
            //是帮主，帮贡设为无穷大，保证在最前
        } else if (arr[i].work == work_name[1]) {
            arr[i].help = inf - 5;
            //是副帮主，帮贡比无穷大小一点，保证在帮主后，其他人前
        }
        arr[i].inn = i;
        //第i个输入的
    }
    sort(arr + 1, arr + n + 1, com);
    //第一遍排序
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < 7; ++j) {//看是哪个级别
            if (i <= work_num[j]) {//排名符合标准
                arr[i].work = work_name[j];//分配职务
                break;//避免多次分配
            }
        }
    }//将每个人的职位分配好
    sort(arr + 1, arr + n + 1, com2);
    //第二次排序
    for (int i = 1; i <= n; ++i) {
        cout << arr[i].name << " " << arr[i].work << " " << arr[i].level << endl;
    }//输出结果
    getchar();	getchar();//在自己编译器上暂停用的，可以去掉
    return 0;
}
```

---

## 作者：asasas (赞：22)

这题考察的是结构体排序。

#### 由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构体(struct)——百度百科。


定义一个结构体的方式如下：

```cpp
struct 结构体名称{
成员1数据类型 成员1名称
成员2数据类型 成员2名称
成员3数据类型 成员3名称
....
};
结构体名称 变量名或数组名;
```


结构体也可以调用C++库里的sort，不过要自己写判断函数或重定义运算符（这里推荐大家写前者，因为方便一些）

判断函数写法如下：
 
```cpp
bool 判断函数名称（结构体名称 变量1,结构体名称 变量2）{
   return 你的判断方式 ;
}
```
推荐练手题：
[P5728](https://www.luogu.com.cn/problem/P5728)
[P5741](https://www.luogu.com.cn/problem/P5741)

了解了以上知识，做这题就不难了。

我们先建立一个结构体，记录每人的名字，原来职位，帮贡，等级，在原队列的顺序和新职位。

接着读入每人的信息，先按照帮贡排序（帮贡相等的按原序号排序），注意帮主，副帮主不能排序，所以要从数组第四个数据开始排序。

接着按照顺序给每人授予新职位（我手写了一个函数）。

然后将每人的职位和等级排序，职位第一关键字，等级第二关键字。

这是，我们发现职位是字符串，如何排序呢？

这是，我们可以手写一个转换函数（和我上面一样），帮主是1，副帮主是2，以此类推。

转化完了后，我们只需按照上面得到的值按顺序排序即可（要按照题目给的方式排序哦！），最后输出。

代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;
struct people{
	string name,zw,nzw;
	long long bg,dj,xh;
}a[100005];//每个人的信息
int zdj1(string a){//将职位转换的函数
    if (a=="BangZhu") return 1;
    if (a=="FuBangZhu") return 2;
    if (a=="HuFa") return 3;
    if (a=="ZhangLao") return 4;
    if (a=="TangZhu") return 5;
    if (a=="JingYing") return 6;
    if (a=="BangZhong") return 7;
}
string zdj2(int a){//将顺序转换为职位的函数	
    if (a==1) return "BangZhu";
    if (a<=3) return "FuBangZhu";
    if (a<=5) return "HuFa";
    if (a<=9) return "ZhangLao";
    if (a<=16) return "TangZhu";
    if (a<=41) return "JingYing";
    return "BangZhong";
}
bool cmp1(people a,people b){
	if (a.bg!=b.bg) return a.bg>b.bg;//不等时按帮贡排序
	else return a.xh<b.xh;//相等时按序号排序
}//排序函数1
bool cmp2(people a,people b){
	int a1=zdj1(a.nzw),b1=zdj1(b.nzw);
	if (a1!=b1) return a1<b1;//先是职位
	else {
		if (a.dj!=b.dj) return a.dj>b.dj;//再是等级
		else return a.xh<b.xh;//最后序号
	}
}//排序函数2
int main(){ 
  int n;
  cin >> n;
  for (int i=1;i<=n;i++){
  	cin >> a[i].name >> a[i].zw >> a[i].bg >> a[i].dj;
	  a[i].xh=i; 
  }//读入并存储序号
  sort(a+4,a+1+n,cmp1);//注意要从4开始排序
  for (int i=1;i<=n;i++){
  	a[i].nzw=zdj2(i);//存入新职位
  } 
  sort(a+1,a+1+n,cmp2);//第二次排序
  for (int i=1;i<=n;i++){
  	cout << a[i].name << ' ' << a[i].nzw << ' ' << a[i].dj << endl;//输出，记得换行
  }
}
```


---

## 作者：Hexarhy (赞：12)

### Preface

一道只考细节的模拟题，难度为普及组 T2。适合新手锻炼码力和大佬颓废。

### Solution

认真读题，根据题意模拟。流程大概如下：

- 输入，储存下标（即题目中的“经验”），来保证排序的稳定性。

- 为了不更改帮主和副帮主的位置，我们把他们的帮贡设为极大值。

- 以帮贡为第一关键字，经验为第二关键字，进行排序。

- 按次分配职位。同时用一个 `std::map` 把字符串的职位映射成数值，方便排序。

- 以职位为第一关键字，等级为第二关键字，经验为第三关键字，进行排序。

- 输出名字、职位、等级。

用结构体可以实现多关键字排序。

算上 `std::map` 和 `std::sort()` 的时间，总时间复杂度约为 $O(n\log n)$。

### Notice

- 看清楚数据范围，帮贡要开 `long long`。

- 觉得写`cmp()`烦？用 `lambda` 表达式吧。需要 C++11。

- 帮主和副帮主的帮贡的极大值可以使用`<climits>`里的`LLONG_MAX`和`LLONG_MAX-1`。

- 看清楚职位大小写拼写。

### Code

需要 C++11。其中 `lambda` 表达式的用法请自行百度，这里不展开。

```cpp
#include<iostream>
#include<cstdio>
#include<string> 
#include<algorithm>
#include<climits>
#include<map>
using namespace std;

typedef long long ll;
const int MAXN=150;
int n;
struct item
{
	string name,place;//名字，职位
	ll rating,level,exp;//帮贡，等级，经验（下标编号）
}a[MAXN];
map<string,int> m;//把职位映射成数值来排序

int main()
{
    ios_base::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	a[i].exp=i;//储存下标，确保排序稳定性
    	cin>>a[i].name>>a[i].place>>a[i].rating>>a[i].level;
    	if(a[i].place=="BangZhu")	a[i].rating=LLONG_MAX;
    	if(a[i].place=="FuBangZhu")	a[i].rating=LLONG_MAX-1;//设置极大值，保证不变更帮主和副帮主
	}
	sort(a+1,a+1+n,
	[=](const item a,const item b)//多关键字排序
	{	
		return a.rating!=b.rating?a.rating>b.rating:a.exp<b.exp;	
	});
	for(int i=1;i<=n;i++)//按次分配职位
	{
		if(i==1)			m[a[i].place="BangZhu"]=1;//顺便存储字符串的映射
		if(2<=i && i<=3)	m[a[i].place="FuBangZhu"]=2;
		if(4<=i && i<=5)	m[a[i].place="HuFa"]=3;
		if(6<=i && i<=9)	m[a[i].place="ZhangLao"]=4;
		if(10<=i && i<=16)	m[a[i].place="TangZhu"]=5;
		if(17<=i && i<=41)	m[a[i].place="JingYing"]=6;
		if(i>=42)			m[a[i].place="BangZhong"]=7;
	}
	sort(a+1,a+1+n,//多关键字排序
	[=](const item a,const item b)
	{
		if(a.place!=b.place)	return m[a.place]<m[b.place];
		if(a.level!=b.level)	return a.level>b.level;
		return a.exp<b.exp; 
	});
	for(int i=1;i<=n;i++)
	 cout<<a[i].name<<" "<<a[i].place<<" "<<a[i].level<<endl;
	return 0;
}
```

---

## 作者：袁宇轩 (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P1786)

披着绿题的模拟水题。

只要能清楚**两次排序**，接下来的一系列操作易如反掌：

看题解里面的快排，cmp比较长，用**三目运算符**它不香吗？

---

### 变量声明：

```cpp
struct node{
	string name;//名字
	int bg,level,zw,id;//帮贡、等级、职位、编号
}a[N];

string zw_name[7] = {"BangZhu", "FuBangZhu","HuFa", "ZhangLao","TangZhu", "JingYing", "BangZhong"};//职位
map<string,int> mp;//用map存储职位的高低，可以在cmp里直接比较大小（本人以数字小的职位相对高）
```
---

### 第一次排序（三目运算符）：

将**帮贡从大到小**排序，如果**相等**那么按**原排列顺序**，以便之后给它们安排新职位。

```cpp
bool cmp(node A,node B){
    return A.bg==B.bg?A.id<B.id:A.bg>B.bg;
    //A的帮贡如果等于B的帮贡，那么按编号排，否则按帮贡从大到小排
}
```

---

### 第二次排序（三目运算符套三目运算符）：

将新职位赋予后，把它们按**职位从高到低**排序，如果**职位相等**，那么按**等级从大到小**排序，如果**等级相等**，那么就按**原排列顺序**

```cpp
bool cmp_(node A,node B){
	return A.zw==B.zw?A.level==B.level?A.id<B.id:A.level>B.level:A.zw<B.zw;
    //如果A的职位等于B的职位，而且A的等级等于B的等级，那么按编号排，如果A的等级与B的等级不想等，按等级从大到小排，否则按职位从高到低
}
```
---

赋予新职位的操作不多讲了，因为作者无能，写的很朴素。

完整Code（三目运算符是一大特点）：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define For(i,j,k) for(int i=(int)(j);i<=(int)(k);i++)
#define Rep(i,j,k) for(int i=(int)(j);i>=(int)(k);i--)
inline ll read(){
	ll x=0;char ch=getchar();bool f=0;
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=1;
	for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
	return f?-x:x;
}
void write(ull x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);putchar(x%10+'0');
}
void writeln(ull x){write(x);puts("");}
void writep(ull x){write(x);putchar(' ');}

int const N=110+3;
int n,num[7]={1,3,5,9,16,41,N};
string s,zw_name[7] = {"BangZhu", "FuBangZhu","HuFa", "ZhangLao","TangZhu", "JingYing", "BangZhong"};
map<string,int> mp;
struct node{
	string name;
	int bg,level,zw,id;
}a[N];

bool cmp(node A,node B){
	return A.bg==B.bg?A.id<B.id:A.bg>B.bg;
}
bool cmp_(node A,node B){
	return A.zw==B.zw?A.level==B.level?A.id<B.id:A.level>B.level:A.zw<B.zw;
}
int main(){
	n=read();
	for (int i=0;i<7;i++)
	  mp[zw_name[i]]=i;
	for (int i=1;i<=n;i++){
		a[i].id=i;
		cin>>a[i].name>>s;
		a[i].zw=mp[s];
		a[i].bg=read();a[i].level=read();
	}
	sort(a+4,a+n+1,cmp);
    //赋予新职位
	for (int i=4;i<=n;i++)
	  for (int j=2;j<7;j++)
	    if (i<=num[j]){
	    	a[i].zw=j;
	    	break;
	    }
	sort(a+1,a+n+1,cmp_);
	for (int i=1;i<=n;i++)
	  cout<<a[i].name<<' '<<zw_name[a[i].zw]<<' '<<a[i].level<<endl;
	return 0;
}
```

---

## 作者：2015C林铮翔 (赞：7)

时隔9年来重写一下这篇看了令人难绷的题解

重新给一份Python版本的，因为最近工作用Python用的比较多。
```Python
pos_list = ["BangZhu", "FuBangZhu", "HuFa", "ZhangLao", "TangZhu", "JingYing", "BangZhong"]
struct = {"BangZhu": 1, "FuBangZhu": 2, "HuFa": 2, "ZhangLao": 4, "TangZhu": 7, "JingYing": 25, "BangZhong": 9999}
priority = {"BangZhu": 1, "FuBangZhu": 2, "HuFa": 3, "ZhangLao": 4, "TangZhu": 5, "JingYing": 6, "BangZhong": 7}


class BangPai:

    def __init__(self, __name, __pos, __score, __grade, __no):
        self.__name = __name
        self.__pos = __pos
        self.__score = __score
        self.__grade = __grade
        self.__no = __no

    @property
    def name(self):
        return self.__name

    @property
    def pos(self):
        return self.__pos

    @property
    def grade(self):
        return self.__grade

    @property
    def no(self):
        return self.__no

    def __lt__(self, other):
        if self.__score == other.__score:
            return self.__no < other.__no
        return self.__score > other.__score


class NewBangPai:

    def __init__(self, __name, __pos, __grade, __no):
        self.__name = __name
        self.__pos = __pos
        self.__grade = __grade
        self.__no = __no

    def __lt__(self, other):
        if self.__pos == other.__pos:
            if self.__grade == other.__grade:
                return self.__no < other.__no
            return self.__grade > other.__grade
        return priority[self.__pos] < priority[other.__pos]

    def output(self):
        print(self.__name, self.__pos, self.__grade)


if __name__ == '__main__':
    n = int(input())
    data_list = []
    for _ in range(n):
        name, pos, score, grade = input().split()
        data_list.append(BangPai(name, pos, int(score), int(grade), _))
    data_list.sort()

    now_pos = 2
    new_data_list = []
    for data in data_list:
        if data.pos == pos_list[0] or data.pos == pos_list[1]:
            new_data_list.append(NewBangPai(data.name, data.pos, data.grade, data.no))
        else:
            new_data_list.append(NewBangPai(data.name, pos_list[now_pos], data.grade, data.no))
            struct[pos_list[now_pos]] -= 1
            if struct[pos_list[now_pos]] == 0:
                now_pos += 1

    new_data_list.sort()
    for data in new_data_list:
        data.output()

```
以下内容来自2015-08-07 21:25

这题只要其他内容跟着帮贡一起排就很水了。代码不给全（啦啦啦啦啦），看得懂的话我的代码改改就能过

（2024年注：所以我为什么不给全代码来着？）

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int h[100];
struct xy{
    string mz;
    //char mz[1000];
    string zw;
    long long bg;
    long long dj;
}xy_a[100];
int comp(int a,int b)
{
    return a>b;
}
int main()
{
    long long n,temp;
    int i,j,k;
    //char t[1000];
    memset(h,0,sizeof(h));
    string t;
    cin>>n;
    t="23333";
    for(i=1;i<=n;i++)
    {
        cin>>xy_a[i].mz>>xy_a[i].zw>>xy_a[i].bg>>xy_a[i].dj;
        h[i]=xy_a[i].dj;
    }
    sort(h+4,h+5,comp);
    sort(h+6,h+9,comp);
    sort(h+10,h+16,comp);
    sort(h+17,h+41,comp);
    sort(h+42,h+99,comp);
    for(i=4;i<=n-1;i++)
    {
        k=i;
        for(j=i+1;j<=n;j++)
        {
            if(xy_a[j].bg>xy_a[k].bg) k=j;
        }
        if(k!=j)
        {
            temp=xy_a[i].bg;xy_a[i].bg=xy_a[k].bg;xy_a[k].bg=temp;
            t=xy_a[i].mz;
            xy_a[i].mz=xy_a[k].mz;
            xy_a[k].mz=t;
            temp=xy_a[i].dj;xy_a[i].dj=xy_a[k].dj;xy_a[k].dj=temp;
        }
    }
    xy_a[1].zw="BangZhu";
    xy_a[2].zw=xy_a[3].zw="FuBangZhu";
    xy_a[4].zw=xy_a[5].zw="HuFa";
    for(i=6;i<=9;i++) xy_a[i].zw="ZhangLao";
    for(i=10;i<=16;i++) xy_a[i].zw="TangZhu";
    for(i=17;i<=41;i++) xy_a[i].zw="JingYing";
    for(i=42;i<=99;i++) xy_a[i].zw="BangZhong";
    for(i=1;i<=n;i++)
    {
        cout<<xy_a[i].mz<<" "<<xy_a[i].zw<<" "<<h[i]<<endl;
    }
    system("pause");
    return 0;
})
```

---

## 作者：21wang12 (赞：5)

# 提示
+ sort函数不是稳定排序，所以设计类的时候类中应该有个作为输入顺序的属性，方便利用sort函数进行稳定排序(稳定排序是指，保证维持相等元素的顺序)

# 两对映射关系

```c
//职称和该职称所剩余数量的关系
vector<pair<string,int> > msi = {{"BangZhu",0},{"FuBangZhu",0},{"HuFa",2},{"ZhangLao",4},{"TangZhu",7},{"JingYing",25},{"BangZhong",-1}};

//职称和该职称所占比重的关系，方便后续比较
map<string,int> msi2 = {{"BangZhu",10},{"FuBangZhu",9},{"HuFa",8},{"ZhangLao",7},{"TangZhu",6},{"JingYing",5},{"BangZhong",4}};
```

# person类

```c
//姓名，新旧职称，帮贡，等级，输入的序号
struct person{
    string name;
    string old_title;
    string new_title;
    long int bg;    //题目中的数据bg比较大，应该用long long类型
    int level;
    int order;
    //构造函数
    person(string name,string old_title,int bg,int level,int order){
        (*this).name = name;
        (*this).old_title = old_title;
        (*this).new_title = "";
        (*this).bg = bg;
        (*this).level = level;
        (*this).order = order;
    }
};
```
# 重写sort的cmp函数
```c
//按照帮贡排序，帮贡相同时按照输入顺序排序
bool cmp(person p1,person p2){    
    if(p1.bg>p2.bg){  //bg越大越靠前
        return true;
    }else if(p1.bg==p2.bg){     //bg相等时，order越大越靠前
        if(p1.order>p2.order){
            return true;
        }
    }
    return false;
}
//按照职称所占比重排序，职称相同时，则比较等级，等级相同时，则比较输入顺序
bool cmp_show(person p1,person p2){
    if(msi2[p1.new_title]>msi2[p2.new_title]){
        return true;
    }else if(msi2[p1.new_title]==msi2[p2.new_title])
    {
        if(p1.level>p2.level){
            return true;
        }else if(p1.level==p2.level)
        {
            if(p1.order>p2.order){
                return true;
            }
        }
    }
    return false;
}
```
# 完整程序
```c
#include<bits/stdc++.h>

using namespace std;

vector<pair<string,int> > msi = {{"BangZhu",0},{"FuBangZhu",0},{"HuFa",2},{"ZhangLao",4},{"TangZhu",7},{"JingYing",25},{"BangZhong",-1}};

map<string,int> msi2 = {{"BangZhu",10},{"FuBangZhu",9},{"HuFa",8},{"ZhangLao",7},{"TangZhu",6},{"JingYing",5},{"BangZhong",4}};

//姓名，新旧职称，帮贡，等级，输入的序号
struct person{
    string name;
    string old_title;
    string new_title;
    long int bg;    //题目中的数据bg比较大，应该用long long类型
    int level;
    int order;
    //构造函数
    person(string name,string old_title,int bg,int level,int order){
        (*this).name = name;
        (*this).old_title = old_title;
        (*this).new_title = "";
        (*this).bg = bg;
        (*this).level = level;
        (*this).order = order;
    }
};

//order为数据的输入顺序(越大越靠前)，根据此比较函数来保证排序时维持相等元素的顺序
bool cmp(person p1,person p2){    
    if(p1.bg>p2.bg){  //bg越大越靠前
        return true;
    }else if(p1.bg==p2.bg){     //bg相等时，order越大越靠前
        if(p1.order>p2.order){
            return true;
        }
    }
    return false;
}
bool cmp_show(person p1,person p2){
    if(msi2[p1.new_title]>msi2[p2.new_title]){
        return true;
    }else if(msi2[p1.new_title]==msi2[p2.new_title])
    {
        if(p1.level>p2.level){
            return true;
        }else if(p1.level==p2.level)
        {
            if(p1.order>p2.order){
                return true;
            }
        }
    }
    return false;
}

int main(){
    int n;
    vector<person> vp;
    cin>>n;
    while (n--)
    {
        string name;
        string old_title;
        int bg;
        int level;
        cin>>name>>old_title>>bg>>level;
        person p(name,old_title,bg,level,n);
        vp.push_back(p);
    }

    //sort()排序函数不保证维持相等元素的顺序，若需要进行稳定排序，请参考cmp函数的写法
    std::sort(vp.begin(),vp.end(),cmp);
    for(size_t st = 0,idx=0;st<vp.size();st++){
        if(vp[st].old_title == "BangZhu"||vp[st].old_title == "FuBangZhu"||vp[st].name=="absi2011"){
            vp[st].new_title=vp[st].old_title;
            continue;
        }
        if(msi[idx].second!=0){
            vp[st].new_title=msi[idx].first;
            msi[idx].second--;
        }else
        {
            idx++;
            st--;
        }
    }
    std::sort(vp.begin(),vp.end(),cmp_show);
    for(size_t st=0; st<vp.size() ; st++ ){
        cout<<vp[st].name<<" "<<vp[st].new_title<<" "<<vp[st].level<<endl;
    }
    return 0;
}


```

---

## 作者：_jimmywang_ (赞：4)

一看绿题~~算了不做了~~挑战一下

结果$30$分钟打完……

## 进入正题

直接帖代码：
```cpp
#include<algorithm>
#include<bitset>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<map>
#include<iostream>
#include<queue>
#include<set>
#include<stack>
#include<string>
#include<vector>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
inline ll rr() {
	ll x=0,f=1;
	char c=getchar();
	if(c=='-')f=-1,c=getchar();
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
#define d rr()
ll n;
map<string,ll>q;
map<ll,string>p;
struct pe{
	string name;
	ll bg;
	ll lev;
	ll zw;
	ll num;
}a[1000010];
bool cmp1(pe a,pe b){
	if(a.bg!=b.bg)return a.bg>b.bg;
	else return a.num<b.num;
}
bool cmp2(pe a,pe b){
	if(a.zw!=b.zw)return a.zw>b.zw;
	else{
		if(a.lev!=b.lev)return a.lev>b.lev;
		else return a.num<b.num;
	} 
}
int main(){
	n=d;
	q["BangZhu"]=10;
	q["FuBangZhu"]=9;
	q["HuFa"]=8;
	q["ZhangLao"]=7;
	q["TangZhu"]=6;
	q["JingYing"]=5;
	q["BangZhong"]=4;
	
	p[10]="BangZhu";
	p[9]="FuBangZhu";
	p[8]="HuFa";
	p[7]="ZhangLao";
	p[6]="TangZhu";
	p[5]="JingYing";
	p[4]="BangZhong";
	f(i,1,n){
		cin>>a[i].name;
		a[i].num=i;
		string s;
		cin>>s;
		a[i].zw=q[s];
		scanf("%lld %lld",&a[i].bg,&a[i].lev);
	}
	ll q=1;
	sort(a+1,a+n+1,cmp1);
	f(i,1,n){
		if(a[i].zw>8)continue;
		if(q<=2)a[i].zw=8;
		else if(q<=6)a[i].zw=7;
		else if(q<=13)a[i].zw=6;
		else if(q<=38)a[i].zw=5;
		else a[i].zw=4;
		q++;
	}
	sort(a+1,a+n+1,cmp2);
	f(i,1,n)cout<<a[i].name<<" "<<p[a[i].zw]<<" "<<a[i].lev<<endl;
	return 0;
}

```
接下来一步步解释：

### $Part 1:$
```
ll n;//题意：有几个人
map<string,ll>q;//映射1（用来存职位等级）
map<ll,string>p;//映射2（与上面那个作用相反，可以理解为string p[i]表示职位等级为i的是啥职位
struct pe{//结构体，用来存每个人的信息
	string name;//名字
	ll bg;//帮贡
	ll lev;//等级
	ll zw;//职位
	ll num;//第几个读进来的。
}a[1000010];
```
------------

### $Part 2:$
```
n=d;
q["BangZhu"]=10;
q["FuBangZhu"]=9;
q["HuFa"]=8;
q["ZhangLao"]=7;
q["TangZhu"]=6;
q["JingYing"]=5;
q["BangZhong"]=4;

p[10]="BangZhu";
p[9]="FuBangZhu";
p[8]="HuFa";
p[7]="ZhangLao";
p[6]="TangZhu";
p[5]="JingYing";
p[4]="BangZhong";
```
就是打表啦，把$p$和$q$的映射做出来（不要问我为什么是$4$~$10$，我没细想）

------------

### $Part 3:$
~~输入跳过~~
```
sort(a+1,a+n+1,cmp1);

bool cmp1(pe a,pe b){
	if(a.bg!=b.bg)return a.bg>b.bg;
	else return a.num<b.num;
}
```
这个$sort$是干啥的呢？

来看$cmp1$函数：

```
if(a.bg!=b.bg)return a.bg>b.bg;//如果帮贡不相等帮贡多的在前面
else return a.num<b.num;//要不然就看谁输入靠前。
```
------------

### $Part 4:$
重要的来了，程序的核心！！！
```
f(i,1,n){
    if(a[i].zw>8)continue;//说了，帮主和副帮主改不了
    if(q<=2)a[i].zw=8;//护法人数未满（2个）
    else if(q<=6)a[i].zw=7;//护法人数满了，下一个给他长老（4个）
    else if(q<=13)a[i].zw=6;//长老人数满了，下一个给他堂主（7个）
    else if(q<=38)a[i].zw=5;//堂主人数满了，下一个给他精英（25个）
    else a[i].zw=4;//精英人数满了，剩下的都是帮众
    q++;
}
```
------------

### $Part 5:$

最后的处理~~

```
sort(a+1,a+n+1,cmp2);
f(i,1,n)cout<<a[i].name<<" "<<p[a[i].zw]<<" "<<a[i].lev<<endl;


bool cmp2(pe a,pe b){
	if(a.zw!=b.zw)return a.zw>b.zw;
	else{
		if(a.lev!=b.lev)return a.lev>b.lev;
		else return a.num<b.num;
	} 
}//这个排序就是职位第一关键字，等级第二关键字来排，题中已述。
```
---------
好了，整个题就分析完了，撒花花啦！

---

## 作者：fiveyes (赞：3)

这是一个关于排序的问题。~~（好像是废话）~~
1、注意其中有要求最终输出时，等级相同的话，原来靠前的现在也要靠前。所以说输入的时候就要保留输入顺序。
2、分配职务的时候，对帮贡相同的人，也要求优先选择原来靠前的。但是一般来说排序本身已经满足了这个要求，所以可以忽略了，排序之后按顺序分配职务即可。
3、后一次排序实际上是三个关键字：职位、等级、输入顺序。
~~4、没了。~~
```cpp
#include <iostream>
#include <string>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <math.h>

using namespace std;

const string w[7] = { "BangZhu", "FuBangZhu", "HuFa", "ZhangLao", "TangZhu", "JingYing", "BangZhong" };
struct person{
	string name; // 姓名
	int work; // 职位
	long long int gong; // 帮贡
	int ji; // 等级
	int in; // 原始输入顺序
}per[120], ap;

int main()
{
	int n;
	cin >> n;
	string temp;
	for (int i = 0; i < n; i++) { // 输入数据
		cin >> per[i].name >> temp >> per[i].gong >> per[i].ji;
		for(int j=0;j<7;j++)
			if (temp == w[j]) 
			{
				per[i].work = j;
				break;
			}
		per[i].in = i;
	}
	
	for (int i = 0; i < n-1; i++)
		for (int j = i + 1; j < n; j++)
			if (per[i].gong < per[j].gong) // 按照帮贡降序排序
			{
				ap = per[i];
				per[i] = per[j];
				per[j] = ap;
			}
	
	int seted = 0; // 记录已经调整的职位数量
	for (int i = 0; i < n; i++) // 分配职位
		if (per[i].work > 1) // 除帮主、副帮主以外的职位可调整
		{
			if (seted < 2) per[i].work = 2; // 两个护法
			else if (seted < 6) per[i].work = 3; // 四个长老
			else if (seted < 13) per[i].work = 4; // 七位堂主
			else if (seted < 38) per[i].work = 5; // 二十五名精英
			else per[i].work = 6; // 剩下的都是帮众
			seted++; 
		}
	
	for (int i = 0; i < n - 1; i++)
		for (int j = i + 1; j < n; j++)
		{
			if (per[i].work > per[j].work) // 第一关键字职位排序
			{
				ap = per[i];
				per[i] = per[j];
				per[j] = ap;
			}
			else if (per[i].work == per[j].work) // 职位相等时，第二关键字等级
			{
				if (per[i].ji < per[j].ji)
				{
					ap = per[i];
					per[i] = per[j];
					per[j] = ap;
				}
				else if (per[i].ji == per[j].ji) // 等级也相等时，第三关键字输入顺序
				{
					if (per[i].in > per[j].in)
					{
						ap = per[i];
						per[i] = per[j];
						per[j] = ap;
					}
				}
			}
		}

	for (int i = 0; i < n; i++) // 按格式输出数据
		cout << per[i].name << " " << w[per[i].work] << " " << per[i].ji << endl;
	return 0;
}
```


---

## 作者：EarthGiao (赞：2)

## 【思路】
模拟，排序    

### 【题目大意】
根据题目中给出的条件赋予职位    
然后排序    

### 【题目分析】
排序这是很显然的，但是一道绿题不可能让你一个sort就水过去吧？    
不过也不可能出什么恶心的数据结构来，毕竟只是一道绿题。  
所以难度只会存在于排序的条件    
也就是到底什么样的才应该在前面    

### 【排序条件】
无权调动帮主，副帮主和自己    
所以帮主，副帮主和自己是不需要挪动的    
 然后就看排序的顺序了    
 需要两次排序      
 第一次是为了给予职位，第二次是为了输出    
### 给予职位是按照帮贡来给    
  还有如果有相同帮贡但是职位不够的话原来当的应该继续当  
  这不需要考虑      
  因为原来当的一开始读入就在前面     
  sort排序的时候只要不在cmp里面加上个=就会按照原来当的在前面排序    
  这样就能保证原来当的优先当了 
  
### 职位是第一要素这很显然    
  等级是第二关键字    
  所以要先按照职位排序    
  然后如果职位相同那就把等级高的放在前面    
  再就是职位相同等级也相同的话    
  那原来在前面的就还在前面   
  这点不需要考虑     
  因为如果用sort的话    
  只要cmp里面自定义排序方式写正确了那就没有问题     
 （这里的正确很大可能是不需要=，主要是看你怎么写）      
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<map>
using namespace std;
map<string,int>s;
const int Max = 120;
struct node
{
	string name,zhiwei;//名字，职位 
	int bg,dg;//帮贡，等级 
	int zz;//一开始给出数据中所在的位置 
}a[Max];

bool cmp(const node x,const node y)//帮贡排序 
{
	if(x.bg == y.bg)
		return x.zz < y.zz; 
	return x.bg > y.bg; 
}

bool cmp1(const node x,const node y)//输出排序
{
	if(s[x.zhiwei] == s[y.zhiwei])
	{
		if(x.dg == y.dg)
			return x.zz < y.zz;
		return x.dg > y.dg;
	}
	else
		return s[x.zhiwei] < s[y.zhiwei]; 
}

int main()
{
	s["BangZhu"] = 1,s["FuBangZhu"] = 2,s["HuFa"] = 3,s["ZhangLao"] = 4,
	s["TangZhu"] = 5,s["JingYing"] = 6,s["BangZhong"] = 7;
	int n;
	cin >> n;
	for(register int i = 1;i <= n;++ i)
		cin >> a[i].name >> a[i].zhiwei >> a[i].bg >> a[i].dg,a[i].zz = i; 
	int js = 0;
	sort(a + 4,a + 1 + n,cmp);
	int jj = 1;
	for(register int i = 1;i <= n;++ i)
	{
		if(a[i].zhiwei != "BangZhu" && a[i].zhiwei != "FuBangZhu")
		{
			if(jj >= 1 && jj <= 2)
				a[i].zhiwei = "HuFa";
			if(jj >= 3 && jj <= 6)
				a[i].zhiwei = "ZhangLao";
			if(jj >= 7 && jj <= 13)
				a[i].zhiwei = "TangZhu";
			if(jj >= 14 && jj <= 38)
				a[i].zhiwei = "JingYing";
			if(jj >= 39)
				a[i].zhiwei = "BangZhong";
			jj ++;
		}
	}
	sort(a + 1,a + 1 + n,cmp1); 
	for(register int i = 1;i <= n;++ i)
		cout << a[i].name << " " << a[i].zhiwei << " " << a[i].dg << endl;
	return 0;
}
```

---

## 作者：bjutlsccc (赞：1)

叙述有点乱乱的一道题，各种排序标准。这里将整个问题分为两个部分：
1.对除帮主和副帮主以外所有人按帮贡排序，如果帮贡相同，按出现顺序排序。这样排序后每个人的新职位就确定了，不会再变化了。
2.对每个职位的人排序，按等级排序，如果等级相同，就按出现顺序排序。
代码如下：
```c
#include<iostream>
#include<string.h>
#include<map>
#include<algorithm>
using namespace std;

string zwm[8]={"","BangZhu","FuBangZhu","HuFa","ZhangLao","TangZhu","JingYing","BangZhong"};

struct node{
	string name;	//名字 
	string zw;		//职务 
	int bg,lv,tk;	//帮贡 等级 出现编号 
} ex[120];

int n;

//帮贡相同 按出现顺序排序 
bool cmp1(node ta,node tb){
	if(ta.bg==tb.bg) return ta.tk<tb.tk;	
	return ta.bg>tb.bg;
}
//等级相同 按出现顺序排序 
bool cmp2(node ta,node tb){
	if(ta.lv==tb.lv) return ta.tk<tb.tk;
	return ta.lv>tb.lv;
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>ex[i].name>>ex[i].zw>>ex[i].bg>>ex[i].lv;
		ex[i].tk=i;
	}
	int rec=1;
	//检查有多少个帮主和副帮主 用rec记录 
	while(true){
		if(ex[rec].zw!=zwm[1]&&ex[rec].zw!=zwm[2]) break;
		rec++;
	}
	int tmp=rec; 
	sort(ex+rec,ex+n+1,cmp1);				//从头至尾按帮贡排序 
	sort(ex+rec,ex+min(rec+2,n+1),cmp2);	//对护法排序 
	rec=min(rec+2,n+1);
	sort(ex+rec,ex+min(rec+4,n+1),cmp2);	//对长老排序 
	rec=min(rec+4,n+1);
	sort(ex+rec,ex+min(rec+7,n+1),cmp2);	//对堂主排序 
	rec=min(rec+7,n+1);
	sort(ex+rec,ex+min(rec+25,n+1),cmp2);	//对精英排序 
	rec=min(rec+25,n+1);
	sort(ex+rec,ex+n+1,cmp2);				//对帮众排序 
	for(int i=tmp;i<=n;i++){				//为除了帮主和副帮主以外所有人贴上新标签 
		ex[i].zw=zwm[7];
		if(i<tmp+38) ex[i].zw=zwm[6];
		if(i<tmp+13) ex[i].zw=zwm[5];
		if(i<tmp+6) ex[i].zw=zwm[4];
		if(i<tmp+2) ex[i].zw=zwm[3];
	}
	for(int i=1;i<=n;i++){
		cout<<ex[i].name<<" "<<ex[i].zw<<" "<<ex[i].lv<<endl;
	}
	return 0;
}
```


---

## 作者：lenaalyth (赞：1)

发一个水题解。。本体就是两次结构体排序，有以下两点点需要注意：

1.帮主和副帮主一定要在前面，用一个标记标记一下帮主和副帮主就可以了。

2.注意等级前后的位置，将每个数的原排位记录一下，排序时最后比较一下原顺序的前后就可以了。

。。。。话说这题怎么是绿题的。。。。。
下面是代码：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
typedef struct
{
	string zhiwei,name;
	int wz,bz,gx,dj,bh;//位置权值，帮主标记，贡献值，等级，编号
} fhs;
fhs a[11100];
bool cmp1(fhs a1,fhs b1)
{
	if(a1.bz!=b1.bz)
	{
		return a1.bz>b1.bz;
	}
	else if(a1.gx!=b1.gx)
	{
		return a1.gx>b1.gx;
	}
	else if(a1.wz!=b1.wz)
	{
		return a1.wz>b1.wz;
	}
	else if(a1.dj!=b1.dj)
	{
		return a1.dj>b1.dj;
	}
	else 
	{
		return a1.bh<b1.bh;
	}
}
bool cmp2(fhs a1,fhs b1)
{
	if(a1.bz!=b1.bz)
	{
		return a1.bz>b1.bz;
	}
	else if(a1.wz!=b1.wz)
	{
		return a1.wz>b1.wz;
	}
	else if(a1.dj!=b1.dj)
	{
		return a1.dj>b1.dj;
	}
	else 
	{
		return a1.bh<b1.bh;
	}
}
int m;
int main()
{
	cin>>m;
	for(int x=0; x<m; x++)
	{a[x].bh=x;
		cin>>a[x].name>>a[x].zhiwei>>a[x].gx>>a[x].dj;
		if(a[x].zhiwei=="BangZhu")
		{
			a[x].bz=2;
		}
		else if(a[x].zhiwei=="FuBangZhu")
		{
			a[x].bz=1;
		}
		else if(a[x].zhiwei=="HuFa")
		{
			a[x].wz=100;
		}
		else if(a[x].zhiwei=="ZhangLao")
		{
			a[x].wz=90;
		}
		else if(a[x].zhiwei=="TangZhu")
		{
			a[x].wz=80;
		}
		else if(a[x].zhiwei=="JingYing")
		{
			a[x].wz=70;
		}
		else if(a[x].zhiwei=="BangZhong")
		{
			a[x].wz=60;
		}
	}
	sort(a,a+m,cmp1);
	for(int x=0; x<m; x++)
	{
		a[x].wz=0;
		a[x].bz=0;
		if(x==0)
		{
			a[x].zhiwei="BangZhu";
		}
		else if(x<3)
		{
			a[x].zhiwei="FuBangZhu";
		}
		else if(x<5)
		{
			a[x].zhiwei="HuFa";
		}
		else if(x<9)
		{
			a[x].zhiwei="ZhangLao";
		}
		else if(x<16)
		{
			a[x].zhiwei="TangZhu";
		}
		else if(x<41)
		{
			a[x].zhiwei="JingYing";
		}
		else
		{
			a[x].zhiwei="BangZhong";
		}
		if(a[x].zhiwei=="BangZhu")
		{
			a[x].bz=2;
		}
		else if(a[x].zhiwei=="FuBangZhu")
		{
			a[x].bz=1;
		}
		else if(a[x].zhiwei=="HuFa")
		{
			a[x].wz=100;
		}
		else if(a[x].zhiwei=="ZhangLao")
		{
			a[x].wz=90;
		}
		else if(a[x].zhiwei=="TangZhu")
		{
			a[x].wz=80;
		}
		else if(a[x].zhiwei=="JingYing")
		{
			a[x].wz=70;
		}
		else if(a[x].zhiwei=="BangZhong")
		{
			a[x].wz=60;
		}
	}
	sort(a,a+m,cmp2);
	for(int x=0;x<m;x++)
	{
	cout<<a[x].name<<" "<<a[x].zhiwei<<" "<<a[x].dj<<endl;	
	}
}
```

---


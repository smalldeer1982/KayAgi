# 奶牛晒衣服

## 题目背景

熊大妈决定给每个牛宝宝都穿上可爱的婴儿装 。但是由于衣服很湿，为牛宝宝晒衣服就成了很不爽的事情。于是，熊大妈请你（奶牛）帮助她完成这个重任。


## 题目描述

一件衣服在自然条件下用一秒的时间可以晒干 $a$ 点湿度。抠门的熊大妈只买了一台烘衣机 。使用用一秒烘衣机可以让一件衣服额外烘干 $b$ 点湿度（一秒晒干 $a+b$ 湿度），但在同一时间内只能烘一件衣服。现在有 $n$ 件衣服，第 $i$ 衣服的湿度为 $w_i$（保证互不相同），要你求出弄干所有衣服的最少时间（湿度为 $0$ 为干 ）。


## 说明/提示

### 样例解释

让机器烘第三件衣服即可一秒完成。

### 数据范围

$1 \le w_i,a,b,n \le 5 \times 10^5$

## 样例 #1

### 输入

```
3 2 1
1
2
3```

### 输出

```
1```

# 题解

## 作者：_bql (赞：79)

## C++题解 二分答案

题外话：本蒟蒻第三篇题解（前两篇都写的不好 今天认真写一篇）


Q & A 

Question 1:为什么能用二分？

Answer：结果有单调性 即要得出答案 你可以暴力枚举答案 但是一个一个枚举。。。（自行脑补）

Question 2:二分什么东西呢？

Answer：默认大家都学过方程 举个栗子?：列方程时，总是把问题要求的量设成X，二分答案也是一样，二分时间就行了

~~二分还不会的请翻书或看其他题解~~

上代码（重要代码有注释）：
```cpp
int c[500005];
int n,a,b,i,j,k,y,l,r,m;

//此处是检查能否在你设定的时间内完成晾衣服的任务
bool check(int x)
{
    k=0;
    for(i=1;i<=n;i++)
    {
    	j=c[i]-a*m;//既然用X的时间完成晾衣服 那么
        		   //如果不进烘干机 也能减轻A*M的湿度
        if(j<=0) continue;//即已经干了
        y=j/b;//如果没干 要进烘干机，Y即为烘干时间
        if(j%b!=0) y++;
        k+=y;
        if(k>m) return 0;
    }
    if(k<=m) return 1;
    else return 0;
}

int main()
{
    cin>>n>>a>>b;
    for(i=1;i<=n;++i) scanf("%d",&c[i]);
    //以下是标准二分 不要写错了
    l=0,r=500010;
    while(l!=r)
    {
        m=(l+r)/2;
        if(check(m)) r=m;
        else l=m+1;
    }
    cout<<l;
    return 0;
}
```
~~不要试图直接复制 我省略了头文件~~

---

## 作者：shao0320 (赞：68)

标准的二分答案。

首先考虑暴力做法，即枚举最终答案ans，对于第一个可行的ans一定是最优解（在ans时间内可以烘干在ans+t(t>=0)的时间内也就一定可以烘干）由于N<=500000的数据范围绝对会TLE，因此需要优化。

接下来考虑优化，由于之前提到的性质，设f(i)表示在i时间内有无可能烘干，那么f数组必定满足**单调性**。那么我们可以二分最终答案ans，对于每一个ans对其进行暴力check：对于每一件衣服，如果它能在ans天内烘干（湿度<=ans*a），那么就不必使用烘干机，接下来处理必须使用烘干机的情况，当i号衣服不能被直接烘干时，我们需要用```((clothes[i]-a*mid)%b==0?(clothes[i]-a*mid)/b:(clothes[i]-a*mid)/b+1;)```次烘干机进行烘干（实际写代码的过程中我更推荐if-else），最后只需看烘干机使用总数是否小于等于mid即可。

下面给出参考代码：
```cpp
#include<iostream>
#define int long long
using namespace std;
int n,a,b,clothes[600006];
bool check(int mid)
{
	int tot=0;
	for(int i=1;i<=n;i++)
	{
		if(clothes[i]<=mid*a)continue;
		else 
		{
			
			if((clothes[i]-mid*a)%b==0)tot+=(clothes[i]-mid*a)/b;
			else tot+=((clothes[i]-mid*a)/b+1);
		}
	}
	return tot<=mid;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)cin>>clothes[i];
	int l=0,r=1e9,mid;
	while(l<=r)
	{
		mid=(l+r)/2;
		if(check(mid))r=mid-1;
		else l=mid+1;
	}
	cout<<l<<endl;
	return 0;
} 
```
喜欢我的题解别忘了点个赞哦~

---

## 作者：FLASH_CM (赞：42)

### 【算法思路】
由于弄干所有衣服需要的时间是由最后一件烘干的衣服所需要的时间决定的，所以我们每次都对剩余所需时间最长的那件衣服使用烘衣机。
### 【注意事项】
由于我们注意到数据范围**非常的大**，如果用sort会超时，所以我们考虑使用堆来对其进行优化。
### 【标准程序】
```cpp
#include <bits/stdc++.h>
using namespace std;

priority_queue<int> sta;

int main(){
    int t=0,i,j,k,m,n,a,b;
    scanf("%d%d%d",&n,&a,&b);
    for(i=1;i<=n;i=-~i){
        scanf("%d",&k);
        sta.push(k);
    }
    t+=a;
    k=sta.top();
    sta.pop();
    k-=b;
    sta.push(k);
    while(1){
        k=sta.top();
        sta.pop();
        if(k-t<=0){
            printf("%d",t/a);
            return 0;
        }
        t+=a;
        k-=b;
        sta.push(k);
    }
    return 0;
}
```
### 【程序解释】
1、由于至少需要一天时间，我们先预处理一天的结果。

2、t表示当前时间自然晒干的湿度，当某一时刻，t大于湿度最大的衣服的湿度，则输出t/a（表示天数）。

3、t小于大于湿度最大的衣服的湿度，则我们把它的湿度减去烘衣机单位时间的烘干量，然后再把它重新加入堆中。

---

## 作者：chenlingxi (赞：25)

# 写在题解之前
###### 这题用的玄学数学方法
###### 同样玄学的复杂度O(n)
# 备注
# 本题是我校2011年某次考试原题
# 结果洛谷第一次提交在2013年6月
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int t[500001];//桶 
int main()
{
	/*freopen("dry.in","r",stdin);
	freopen("dry.out","w",stdout);*/
    //考试不得不写
	int n,a,b,least=0,maxn=0;//least表示自然烘干的水分，maxn为目前最大的水分 
	cin>>n>>a>>b;//输入同题面 
	for(int i=0;i<n;++i)
	{
		int k;
		cin>>k;
		t[k]++;
		if(k>maxn)maxn=k;//求最大值 
	}
	int ans=0;//时间 
	while(least<maxn)//如果自然晒干的水分低于最大的水分，说明还有没晒干的，反之说明全部晒干 
	{
		least+=a;//自然晒干的水分增加 
		t[maxn]--;//贪心，最大湿度的减掉烘干的水分 
		if(maxn-b>0)t[maxn-b]++;//防止数组越界 
		while(!t[maxn])maxn--;//更新最大值，因为是桶，所以直接线性更新 
		ans++;//时间加1 
	}
	cout<<ans;//输出 
}
```

---

## 作者：凛车漂移 (赞：21)

# 蒟蒻的第一篇（前几个都没过审）题解


[题面传送门](https://www.luogu.org/problemnew/show/P1843)


[本蒟蒻](https://www.luogu.org/space/show?uid=107215)

这道题最朴素的码能A5个点

如下
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,tim,a[500002],nat,hon;
int main()
{
	scanf("%d %d %d",&n,&nat,&hon);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);		
	}
	while(1)
	{
		++tim;
		sort(a+1,a+n+1);		
		a[n]-=hon;
		for(int i=1;i<=n;++i)
		{
			a[i]=a[i]-nat;
		}
		if(a[n]<=0&&a[n-1]<=0)
		{
			cout<<tim;
			return 0;
		}
	}
	return 0;
}
```

所以我们要对朴素代码进行~~魔改~~优化

#####  _~~怎么说呢，第一次对sort的效率失去信心~~_ 
~~你以为我会告诉你这个题我是搜索二分标签来的却用贪心加模拟做出来的吗？~~
下面附上AK代码（看注释食用极佳）
```cpp
#include<iostream> //不想用printf
#include<cstdio>//用scanf会比cin快不少，因为 1 ≤ N ≤ 500000
#include<algorithm> //要用sort的
#include<cmath>//用swap写插入排序
using namespace std; 
int n,tim,a[500002],nat,hon;//这里定义一下变量们
int main()
{
	scanf("%d %d %d",&n,&nat,&hon);//输输输入
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&a[i]);输 ...输(n)入		
	}
	sort(a+1,a+n+1);//排一次就好，后面排序简单，这次较为特殊因为目前数据没有多少特点
	while(1)//标准死循环 
	{
		++tim;//过了一天		
		a[n]-=hon;//贪心策略是每次把最湿的衣服烘一下
		for(int i=n;i>=1;--i)
		{
			if(a[i]<a[i-1]) swap(a[i],a[i-1]);//插入排序，用sort的话	会TLE4个点左右
           						因为这里只对a[n]进行了-hon操作，所以需要比一下a[n]与后面的变量的大小，
         			         		因为a[1]~a[n-1]都是单调递增，所以这里用插入排序可以节约大概n的复杂度（我也不太清楚）。
			else break;//如果在某个位置之前的a[n]>a[i-1]说明之前的a[n]已经到了合适的位置，break出来就行了。
		}
		if(a[n]-tim*nat<=0&&a[n-1]-tim*nat<=0)
        	//这里借鉴了@租酥雨 dalao的操作，就是说不必每次用o[n]的复杂度对整个数组整体操作，
       		 而是用自然烘干度*时间，在@租酥雨 dalao的基础上再改一改，就是不必o[n]去检测每个数是否小于等于0，
                 因为已经排好了序，那就只需要看a[n]和a[n-1]是否小于等于0，因为a[n]是唯一烘过的，a[n-1]又是没被烘过的最大值（因为一开始就是有序的）
		{
			cout<<tim;//愉快输出
			return 0;//好习惯
		}
	}
	return 0;//其实这句根本不会被执行，只是一个好习惯
}
```

PS：最好不要直接复制（手动滑稽），还有，swap（x，y）是交换位置

1：要注意排序的时候不可以过于依赖sort，要根据题目来选择适合的排序方法。

2:对数组所有元素进行整体操作的时候要看看有没有更快更好的方式（毕竟o（n）不是说着玩的

3:不要被题目标签所迷惑（~~这就是你不会写二分的理由？~~）

4：定义变量的时候，不要与头文件包含的函数名重复！（会导致隐秘的错误）这就是为什么我用tim不用time！

---

## 作者：AnicoderAndy (赞：18)

不难看出 最易的解法就是贪心题没错！！分享一下我是怎么思考的。

贪心的思路就是执行一个死循环，每一次循环给所有衣服的湿度减去$A$（自然消耗的），减过后找出里面湿度最大的给它用烘干机减去$B$点湿度。减去后再找出里面湿度最大的，如果**湿度最大值小于等于$0$** ，说明所有衣服都干了，此时退出循环，输出循环次数。

但是这种做法存在超时的问题：
1. 每次循环里面要循环$n$次给衣服减去自然消耗的湿度
1. 每次循环里又要循环两次找两次最大值


针对这两个问题我们想出对应的优化方法：
1. 对于第1个问题，既然所有衣服都会减去一个相应的湿度再进行之后的比较，我们不妨不浪费时间去减，依旧不影响比较，举个例子，数列${5,7,3,1}$，最大值是第二个元素$7$，把所有元素都减去2，数列变为${3,5,1,-1}$，最大值依旧是第二个元素。那么针对这道题，我们干脆就不一个一个去减，依旧能找到我们要去寻找的最大值，然后给它用烘干机，给它减去$B$。因为没有给每个元素减去自然湿度，我们还要考虑最后找到的最大湿度（上面的加粗部分）在减去应当减去的自然湿度之后是否小于等于0即可决定是否跳出循环。
1. 对于第2个问题，可以采用大根堆（C++ STL里内置priority_queue），读入数据时把所有元素放进堆中，然后循环时可以直接取出最大值，取出最大值减去$B$，再放回堆中，然后再检查一下 _当前的最大值在减去应当减去的自然湿度之后是否小于等于0即可决定是否跳出循环_ （见优化方法第1条）。

不理解的话可以自己带数据理解一下。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

priority_queue<int> pq; //声明一个大根堆

//n a b见题目描述，cnt是循环变量
int n, a, b, cnt; 

int main()
{
    cin >> n >> a >> b;
    for (int i = 1; i <= n; i++) {
    	int x;		//输入这件衣服的湿度
        cin >> x;
        pq.push(x);	//把湿度值放入大根堆中
    }
    while (1) {
        cnt++;		//执行天数（循环变量）
        int x = pq.top();	//取出当前最大值（堆顶）衣服的湿度
        pq.pop();
        x -= b;		//减去b之后再放回堆中
        pq.push(x);
        if (pq.top() - cnt * a <= 0) { //判断减去应当减去的自然湿度后是否小于等于0，如果是则退出程序
            cout << cnt << endl;
            return 0;
        }
    }
}
```

本人蒟蒻一枚，望大佬批评指正：）

---

## 作者：dfydada⚡⚡⚡ (赞：12)

# 这里我用了除了二分的另一种写法:

这里我是用优先队列来存各个湿度的，用一个累加器ant来存每个时间自然烘干的总湿度，但是不能先去减队列里的湿度，我们用来判断，每次判断前把优先队列里的最头上一个取出来，用一个临时变量ans储存，用烘干机能烘干的湿度去减去ans，在放回去，（这里一定要用放进去之后在取出来的ans）在取最头上的，去判断if（ans<=ant）就输出这是第多少时间，然后return 0；


```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
typedef long double ld;
const int N=500000+10;
ll n,a,b,x;
ll ans,ant,num;
priority_queue<int> q;
ll read()
{
    ll res=0,chr=getchar(),st=1;
    if(chr=='-')
    {
        st=-1;
    }
    while(!isdigit(chr)&&chr!=EOF)
    {
    	chr=getchar();
	}
    while(isdigit(chr))
    {
        res=(res*10)+(chr-'0');
        chr=getchar();
    }
    return res*st;
}
int main()
{
	n=read();
	a=read();
	b=read();
	for(int i=1;i<=n;i++)
	{
		x=read();
		q.push(x);
	}
	while(1)
	{
		ant+=a;//自然干的总湿度
		num++;//时间
		ans=q.top();//取最头上的
		q.pop();
		ans-=b;//减去烘干机湿度
		q.push(ans);//放进去
		ans=q.top();//在取出来,这里不一定是用一个数
		if(ans<=ant)满足最大的就输出,结束
		{
			cout<<num;
			return 0;
		}
	}
	return 0;
}

```


---

## 作者：租酥雨 (赞：10)

标签说是分治，当然用二分答案也可以做，但个人觉得用贪心更容易理解

贪心策略很简单，就是每一次烘干最潮湿的那件衣服

所以就存在一个排序的问题

第一次排序是完全排序，因为没有注明输入数据是否有序

时间复杂度在O（nlogn）左右（这里用的是sort）

然后每一次烘干完后要把烘干的那件放入队列，这时用插入排序就可以了，时间复杂度为O（n）

有的童鞋想每一次去用自然烘干量减每一件衣服，那么这样又加了O（n）

这里有一手操作：因为队列是有序的（从大到小），时间是记录了的，就可以每一次循环时，

用时间t\*单位时间自然烘干量a，和最潮湿的那件衣服比较

若大于等于，说明每一件衣服都可以被烘干，直接break出来，否则就继续循环





    
```cpp
0. #include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,a,b,t=0,p;
int r[500001];
int i,j;
int cmp(int a,int b)
{
    return a>b;
}
int main()
{
    scanf("%d %d %d",&n,&a,&b);
    for (i=1;i<=n;i++) scanf("%d",&r[i]);
    sort(r+1,r+n+1,cmp);//从大到小排队
    while(1)
    {
        if (r[1]<=t*a) break;
        r[1]-=b;
        p=r[1];
        for (j=2;r[j]>p&&j<=n;j++)
           r[j-1]=r[j];
        r[j-1]=p;
        t++;
    }
    printf("%d",t);
    return 0;
}
```

---

## 作者：此祥非彼翔 (赞：5)


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
int n,a,b;
int w[500001];
int l,r,mid,sum,ans,maxx;
bool add(int s)//0代表假,1代表真；
{
    int k=0;
    for(int i=1;i<=n;i++)
    {
        if(w[i]<=a*s)
            continue;
        int y=w[i]-a*s;//晒干a后剩的水分；
        k+=(y+(b-1))/b;//算出还要烘干多少次，是否在s的范围内，若是则，若不是则；
        }
        return (k<=s?1:0);//相当于if(k<=s)则;输出真即1；否则输出假即0；
        //s就是mid;
    }
int main()
{
    scanf("%d%d%d",&n,&a,&b);
    for(int i=1;i<=n;i++)
        scanf("%d",&w[i]);
    l=1;r=9999999;
    while(l<=r)
    {
        mid=(l+r)/2;
        if(add(mid))
        {
            r=mid-1;
            ans=mid;
        }
        else
        l=mid+1;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：_Andrea (赞：3)

**既然题解区都是用STL自带的优先队列写的，那我就来一个手写的堆吧**

基本思路就是维护一个大根堆，每次从堆顶取出湿度最大的那件衣服用烘衣机吹，直到湿度最大的那件衣服能够自然吹干就结束，也就是<=time * A。

附上代码:
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
using namespace std;
int n, a, b, lenth, timer, x;
int s[1000010];
void swap(int x, int y){//手写的swap函数
    int save = s[x];
    s[x] = s[y];
    s[y] = save;
}
void up(int i){//从i节点向上更新的函数
    while(i / 2){//如果父节点不为空
        if(s[i / 2] < s[i]){//如果父节点小于子节点，就交换
            swap(i, i / 2);
            i = i / 2;
        }
        else    break;
    }
}
void down(int i){//从i节点向下更新的函数
    while(i * 2 <= lenth){//如果子节点补位空
        int tmp = i * 2;//默认左儿子更小
        if(tmp + 1 <= lenth && s[tmp + 1] > s[tmp]) tmp++;//如果右儿子不为空并且右儿子小于左儿子，就将父节点与右儿子进行比较
        if(s[i] < s[tmp]){//如果父节点小于儿子节点
            swap(i, tmp);
            i = tmp;
        }
        else    break;
    }
}
void push(int x){//入堆的函数
    s[++ lenth] = x;//加入队尾
    up(lenth);//进行向上更新
}
int main(){
    scanf("%d%d%d",&n,&a,&b);
    for(int i = 1; i <= n; i ++){
        scanf("%d", &x);
        push(x);//入堆
    }
    while(s[1] > timer * a){//如果堆顶湿度最大的那件衣服无法被自然烘干，就一直循环下去
        timer ++;//天数++
        s[1] -= b;//将堆顶湿度最大的那件衣服烘干
        down(1);//因为堆顶被更改了，所以将堆顶向下更新
    }
    printf("%d", timer);//输出答案
    return 0;
}

```


---

## 作者：XJack (赞：2)

第一篇正儿八经的题解
---

**先看题目描述**

**发现本题主要解决以下问题**

```
给出一个数列,在单位一的时间内可同时做以下操作

·对所有的数减A
·对指定数减B

求出最少的操作次数使这个数列的所有数均<=0
```
**不难发现这是一道简单的贪心题**

**每次操作只需将上一次操作后产生的最大的数减B,其余数均减A即可**

**然而这并不是一道模拟题,如果只简单地地模拟上述策略是一定会TLE的**

**经过再次读题发现**

```
·对所有的数减A
```

**此操作操作是每一次都会在每一个数上进行的单调操作**

**我们便可以将此操作统一存在一个变量上供所有数使用**

~~顺便用一下堆优化~~

**分析完成,开始打代码**

----

```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue<int> a; //本题需要大根堆,优先队列默认大根堆
int t=0; 
int k,n,A,B,m;
int sum=0;
int main(){
    
    cin>>n>>A>>B;
    for(int i=1;i<=n;i++){
        cin>>m;
        a.push(m);
    }
    while(true){
        k=a.top();
        if(k-sum<=0)
        {
            cout<<t;
            return 0;
        }
        a.pop();
        sum+=A;
        a.push(k-B);
        t++;
    }
    return 0;
}
```
---
_华丽的结尾_ 


---

## 作者：大头冲锋车丶 (赞：2)

[P1843传送门](https://www.luogu.org/problemnew/show/P1843)

此题我用的是**贪心+优先队列**

**贪心：**由于烘干机只有一台，所有每次将最大湿度的衣服交给烘干机，剩下衣物自然风干就行。

**优先队列（大顶堆）:**将每个阶段的最大湿度放在队顶。

思路蛮简单，代码里有详细解释~

```cpp
#include<bits/stdc++.h>
using namespace std;
int N, A, B, ans, n;
priority_queue<int> q;//建立大顶堆队列
int main()
{
	while (cin >> N >> A >> B)
	{
		while (!q.empty()) q.pop();
		for (int i = 1; i <= N; i++)
			cin >> ans, q.push(ans);//将每件衣服的湿度压入队列
		n = ans = 0;//之后的n表示最少时间，ans表示现在这个阶段之前已经进行了"自然风干"的总代价（即A的倍数）
		int x = q.top();//先取出队顶，对于不需要用烘干机的情况做特判。不要加q.pop()，不然在下面的else会少一个元素
		if (x <= A)//如果最大湿度的衣服仍可以自然风干而不需要烘干机，则输出时间"1"
			cout << "1" << endl;
		else//不然就要风干机了
		{
			while (!q.empty())
			{
				x = q.top();//取每个阶段的最大湿度
				q.pop();
				if (x <= ans)//如果当前的最大湿度在这之前就已经小于等于了之前所自然风干的总和，则说明此时所有衣物都已经干了
					break;
				q.push(x - B), ans += A, n++;//最大湿度x用风干机风干了B；"自然风干"总代价ans+=A，最小时间++
			}
			cout << n << endl;
		}
	}
}
```

---

## 作者：HPXXZYY (赞：2)

方法：贪心

策略：用干衣机烘烤湿度最高的衣服

注意事项：如果每次处理之后都用sort（或其他）排序一次的话，那么时间复杂度将无法承受

解决方法：使用堆或优先队列

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5000010;
int a,b,s,n,x,k,t,i;
priority_queue<int>q;
int main(){
    scanf("%d%d%d",&n,&a,&b);
    for(i=1;i<=n;i++){
        scanf("%d",&x);
        q.push(x);
    }
    t+=a;k=q.top();
    q.pop();k-=b;q.push(k);
    while (true){
        k=q.top();q.pop();
        if (k<=t){
            cout<<t/a;
            return 0;
        }
        t+=a;k-=b;q.push(k);
    }
    return 0;
}
```

---

## 作者：kuaituo (赞：2)

显然，这是一道二分答案的题。
```
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int n,a,b,k[500001],l,r,mid,ans,m,ks,j[500001];
int kuai(int m)
{
    
    ks=m;   // 0 no   1 yes
    for(int i=1;i<=n;i++)
    {
        j[i]=k[i]-a*m;
    }
    for(int i=1;i<=n;i++)
    {
        if(j[i]>=0)
        {
            ks=ks-ceil(j[i]*1.0/b);
            
        }
        
        if(ks<0)
        return 0;
    }

    return 1;

    
    
}
int main()
{
    scanf("%d%d%d",&n,&a,&b);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&k[i]);
    }

    sort(k+1,k+1+n);
    l=k[1];
    r=k[n];
    while(l<=r)
    {
        mid=(l+(r-l)/2);
        if(kuai(mid)==0)
        {
            l=mid+1;
        }
        else
        {
            r=mid-1; 
            ans=mid;
        }
        
    }
    printf("%d",ans);
    return 0;
    
} 
```
二分的是天数，要注意
1 二分的答案存在可行范围里。
2 如何判断可行？ 
  减去自然晾干的，除以晾衣机的天数，向上取整，用总天数减去
  剩下的比0大就可行。

---

## 作者：SGOI_Aromyase (赞：2)

本来点开这一题想练二分的，然而第一即视感是贪心，然后其实稍微想一想这一题和合并果实差不多=-=，于是用优先玩了玩看看可以骗几个点，然后A了...

我们可以使用stl，用优先队列来做

可以肯定每一次用烘干机烘干最湿的，恩，优先队列简直完美。

不过不太会算时间复杂度，优先队列0.3S A了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int yifu[500005]={0};priority_queue<int> yi;//一开始我想用数组排序的，可以看出来2333
int main(){
    int n,a,b;scanf("%d%d%d",&n,&a,&b);
    for(int i=0,ii;i<n;i++) {
        scanf("%d",&ii);yi.push(ii);//放入优先队列
    }
    int dayy=0,tot=0;//tot记录一共自然烘干了多少，节省一下时间复杂度，临时想出来的方法
    while(++dayy){//记录天数
        int maxx=yi.top();yi.pop();
        tot+=a;maxx=maxx-b;//机器烘干最湿的
        if(tot>=maxx&&tot>=yi.top())break;//全部烘干跳出
        yi.push(maxx);
    }
    printf("%d",dayy);
}
其实还是不要拘泥标签，优先队列可以简单的A掉2333
```

---

## 作者：浮尘ii (赞：2)

贪心思路：每次选最大湿度的衣服烘干，记录时间t，当A\*t>=湿度最大的衣服时，算法结束（因为都干了嘛）。

用桶维护，貌似比堆快（划掉）

F[i]表示湿度为i的衣服有多少件。

```cpp
    while(Ans * A < Maxi) {
        ++Ans;
        F[Maxi]--;
        if(Maxi - B > 0)
            F[Maxi - B]++;
        while(!F[Maxi])
            Maxi--;
    }
```

---

## 作者：xuan__xuan (赞：2)

其实二分答案也能过（我把上取整写错了然后炸了，多一位神犇帮我debug）


    
    
    
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 500001;
int data[MAXN],N,A,B;
int Ans = (1 << 30),Max = -1;
int check(int M)
{
    int Num = M;
    for(int i = 1; i <= N; i++)
    {
        if(data[i] - M*A <= 0)
           continue;
        else 
            Num -= ((data[i]-M*A+B-1)/B);
    }
    if(Num < 0) return 0;
    return 1;
}
int main(){
    scanf("%d%d%d",&N,&A,&B);
    for(int i = 1; i <= N; i++)
    {
        scanf("%d",&data[i]);
        Max = max(data[i],Max);
    }
    sort(data+1,data+N+1);
    int i = 1,j = Max;
    while(i <= j)
    {
        int mid = (i+j) / 2;
        if(check(mid) == 1)
        {
            if(mid < Ans)
               Ans = mid;
            j = mid -1;
        }
        else
            i  = mid + 1;
    }
    cout << j+1 << endl;
    //cout << Ans << endl;
    return 0;
}
```

---

## 作者：CRRaphael (赞：2)

简单贪心，每次把最大值放进烘干机

为了提高效率，可以用堆来维护

因为堆比较难写，所以其实只要用STL中的优先级对列就行了。


AC程序：


    
    
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
int main()
{
    priority_queue<int>q;
    int n,a,b,k=0;
    cin>>n>>a>>b;
    for (int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        q.push(x);
    }
    for (;q.top()>k*a;k++)
    {
        int u=q.top();
        q.pop();
        u-=b;
        q.push(u);
    }
    cout<<k<<endl;
    return 0;
}
```

---

## 作者：Aehnuwx (赞：1)

这道题有两种做法，一是贪心+堆优化，二是我使用的二分答案（我现在也不会第一种做法，药丸）

我们可以二分晒衣服的时间，再在 check 函数中将每件衣服从 $ 1 $ 到 $ n $ 扫一遍，看看每一件衣服能否在规定的时间内自然晒干。如果不能，将用烘衣机烘干这件衣服的时间加起来。最后，如果用烘衣机的时间小于等于规定时间，返回 true，否则返回 false.

$ \rm code $

```cpp
# include <bits/stdc++.h>
using namespace std;
const int maxN(500005); 
int n, a, b, clo[maxN];
bool check(int);
int main() {
    cin >> n >> a >> b;
    int l(1), r = maxN;
    for(int i = 1; i <= n; ++i)
        cin >> clo[i];
    int ans = r;
    while(l <= r) {
        int mid = l + r >> 1;
        check(mid) ? r = mid - 1, ans = mid : l = mid + 1;
    }
    cout << ans << '\n';
    return 0;
}
bool check(int x) {
    int sum(0);
    for(int i = 1; i <= n; ++i) {
        int t = clo[i] - a * x;
        if(t <= 0) continue;
        sum += t / b;
        if(t % b) ++sum;
        if(sum > x) return false;
    }
    return true;
}
```


---

## 作者：Your_Y (赞：1)

方法一：设a[i]为第i件衣服的湿度，当前答案范围是[L，R]。(一开始答案范围是[1，500000])

首先二分一个答案ans，然后枚举每件衣服，若a[i]≤ans\*A，则表示第i件衣服可以自然晒干，否则表示需要用(a[i] -ans\*A)/B（取上整）个单位时间的烘衣机，我们用time累计烘衣机所用的时间。

若最后time≤ans，则表示该答案可行，更新答案，并继续在[L，ans-l]内进行二分答案。

若最后time>ans，则表示该答案不行，继续在[ans+l，R]内进行二分答案。

直到L>R停止。

方法二：利用贪心策略模拟整个烘衣过程。对于每个时刻，我们显然用烘衣机去处理湿度最大的衣服会使得答案更优。

设k表示当前所有衣服的湿度减少了多少，a [i]表示在烘干机作用下当前湿度为i的衣服有多少件（注意这里的a[i]与方法一不同），max表示在烘干机作用下湿度最大的衣服的湿度。

那么每个时刻我们所有衣服的湿度都需减少A，所以每个时刻k就累计一个A。同时我们的烘干机会对湿度最大的衣服进行烘干，所以a[max]会减少1，表示湿度最大的衣服少了一件，并且a[max-B]会增加1，表示原来那件湿度最大的衣服烘干后成了湿度为max-B的衣服了。若[max]=0，则代表湿度最大的衣服没有了，max递减，直到a[max]<>0为止。

当某个时刻max≤k，就表示我们所有衣服已经烘干了，并且我们得到了一个最小的时间。这个贪心算法的总时间复杂度为O（最大湿度+衣服个数）。


以下是二分方法才，程序不难自行阅读





```cpp
var
  n,a,b,i,p,ans:longint;
  f:array[0..500000]of longint;
procedure erfen(l,r:longint);
var
  i,time,p:longint;
begin
  if l<=r then
  begin
  p:=(l+r) div 2;
  time:=0;
  for i:=1 to n do if p*a<f[i] then begin if abs((f[i]-p*a)/b)-trunc((f[i]-p*a)/b)>0.0000001 then inc(time); time:=time+trunc((f[i]-p*a)/b); end;
  if time<=p then begin ans:=p; erfen(l,p-1) end else erfen(p+1,r);
  end;
end;
begin
  readln(n,a,b);
  for i:=1 to n do
   read(f[i]);
  erfen(1,500000);
  writeln(ans);
end.

```

---

## 作者：muse_umbra (赞：0)

```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int w=0,q=1;char c=getchar();
	while(c<'0'||c>'9'){c=getchar();}
	while(c>='0'&&c<='9'){w=(w<<3)+(w<<1)+c-'0';c=getchar();}
	return w*q;
}
int ans,wet[500005],sum;
int main()
{
//	freopen("dry.in","r",stdin);
//	freopen("dry.out","w",stdout);
	int n=read(),a=read(),b=read(),maxx=0;
	for(int i=1;i<=n;i++){int w=read();wet[w]++;maxx=max(maxx,w);}
	for(int i=maxx;i>=1;i--)
	{
		while(wet[i]&&i>sum)
		{
			wet[i]--;
			wet[max(i-b,0)]++;
			ans++;
			sum+=a;
		}
		if(i<=sum) break;
	}
	printf("%d",ans);
	return 0;
}
```
利用贪心的策略模拟整个烘衣过程。对于每个时刻，我们显然用烘衣机去处理湿度最
大的衣服会使得答案更优。

设sum表示当前所有衣服的湿度减少了多少，wet[i]表示在烘干机作用下当前湿度为 i 的衣服有多少件，max 表示在烘干机作用下湿度最大的衣服的湿度。

那么每个时刻我们所有衣服的湿度都需减少A，所以每个时刻sum就累计一个 A。同时我们的烘干机会对湿度最大的衣服进行烘干，所以wet[max]会减少一，表示湿度最大的衣服少了一件了，并且 wet[max-B]会增加一，表示原来那件湿度最大的衣服烘干后成了湿度为 max-B的衣服了。若 wet[max]=0，则代表湿度最大的衣服没有了，max 递减，直到 max==1 为止。

当某个时刻 max<=sum 了，就表示我们所有衣服已经烘干了，并且我们得到了一个最小的时间。这个贪心算法的总时间复杂度为（最大湿度+衣服个数）。

怎么说呢  考完试之后\
不想二分改正\
也不想用优先队列\
500000\
数组放得下啊

---

## 作者：C201914 (赞：0)

**有人用堆水过这题吗**

~~（本蒟蒻一开始想的是DP QWQWQWQ）~~
好了，言归正传，我们假设衣服的湿度是一个个柱形，那么题目就是这样子的：

![](https://cdn.luogu.com.cn/upload/pic/31848.png)

~~（本人美术弱爆）~~

~~（能看就行了）~~

每单位时间都会集体减少A个※，我们用一个cost来记录到当前为止自然风干的※的数量。

现在我们再来考虑那台~~该死的~~烘干机。由于烘干机不会干扰自然风干，因此烘干机在每个单位时间内肯定会用在最湿的衣服上。重点来了：

如何求出每个单位时间内最湿的衣服呢？我们选择用一个[大根堆](https://blog.csdn.net/sofia_m/article/details/79117088)来维护。每次插入或修改操作时间复杂度为logn。

题目说了，1<=湿度,A,B<=500000，因此---------嘿嘿，大根堆水过去了。

例行放代码。
```
void heapup(int v)
{
	heap[++top]=v;
	int i=top;
	while(i>1&&heap[i]>heap[i/2])swap(heap[i],heap[i/2]),i/=2;
}
void heapdown()
{
	int i=1,j;
	while(i*2<=top)
	{
		if(i*2==top||heap[i*2]>heap[i*2+1])j=i*2;
		else j=i*2+1;
		if(heap[i]<heap[j])
		{
			swap(heap[i],heap[j]);
			i=j;
		}
		else break;
	}
}

```
以上是向上堆化与向下堆化。


```
	n=read();a=read();b=read();
	for(int i=1;i<=n;i++)
	{
		num[i]=read();
		heapup(num[i]);//把每个元素放进堆里
	}
	while(heap[1]>cost)//堆顶元素即最湿的衣服，如果堆顶元素干了就都干了。
	{
		cost+=a;total++;//cost记录自然风干，total记录花费时间
		heap[1]-=b;//将堆顶元素用烘干机烘一遍
		if(heap[1]<cost)
		{
			heap[1]=heap[top];
			top--;//如果堆顶元素在经历了烘干机的摧残之后干了，那么将堆顶弹出。
		}
		heapdown();//维护堆
	}
	printf("%d",total);
	return 0;
```
以上是主函数

---

## 作者：Floating__Dream (赞：0)

这题有两种解法

1 二分查找

2 优先队列

我的代码使用的是第二种方法
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstring>
using namespace std;
priority_queue<int>q;
int n,a,b,num;
int main() {
    cin>>n>>a>>b;
    for (int i=1; i<=n; i++) {
        scanf("%d",&num);
        q.push(num);
    }//读入
    int time=0;//记录天数
    while(q.top()>time*a) {
        int wzx=q.top();
        wzx-=b;
        q.pop();
        q.push(wzx);
        time++;
    }//每次取最大值,处理完在重新入队
    cout<<time<<endl;
}
```


---

## 作者：x_faraway_x (赞：0)

本题算法就是二分所需的时间啦

二分答案的难点大部分都在check函数上吧

~~然而我居然把二分模板打错了好囧啊~~

总的来说这题还是不难的啊，代码呈上~

```cpp
#include<cstdio>
const int N=500005;
int n,a,b,t[N],l=0,r=N;
bool check(int x)
{
    int ret=x; //x-ret表示需要的烘干机烘干的天数。
    for(int i=1;i<=n;i++)
    {
        int tmp=t[i]-a*x; //tmp表示一件衣服x天自然烘干后的湿度
        if(tmp>0) ret-=(tmp/b+(tmp%b!=0)); //如果自然未烘干，则需要tmp/b（上取整）天来用烘干机烘干
        if(ret<0) return false; //如果烘干机烘干衣服x天不够，就return false。
    }
    return true;
}
int main()
{
    freopen("P1843.in","r",stdin);
    freopen("P1843.out","w",stdout);
    scanf("%d%d%d",&n,&a,&b);
    for(int i=1;i<=n;i++)
        scanf("%d",&t[i]);
    while(l<=r) //二分答案
    {
        int m=(l+r)/2;
        if(check(m))r=m-1; //注意：如果答案符合要求就调整右边界，使区间里的值更小
        else l=m+1;
    }
    printf("%d",r+1); //注意这里输出右边界啊（蒟蒻的我当时就这里错了QAQ）
}
```

---

## 作者：Red_w1nE (赞：0)

虽然和前面各位神犇的思路是基本一致的，但是我有三个程序，C++,pas，C++中有用stl的，没见过的可以学一学


有文件操作，别问我我为什么不删，因为我防抄袭啊！


【参考程序】{ C++}


```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n, dx, dy, i, left, right, mid;
int a[500010];
bool ok(int mid)
{
int count, x, y, i;
   count = 0;
for(i=1; i<=n; i++) {
      x = a[i] – mid * dx;   // 每件衣服因自然风干而减少的湿度值
      if (x<=0)  continue;   // 湿度值小于0则为干了
      y =x / dy;               // 余下的湿度再烘干还需的秒数
      if (x % dy!=0)  y++;
      count += y;
      if (count > mid)  return false;
   }
if ( count <= mid )
    return true;
   else 
return false;
}
int main()
{
freopen(“dry.in”, “r”, stdin);
freopen(“dry.out”, “w”, stdout);
cin >> n >> dx >> dy;   //N=3, A=2, B=1
for(i=1; i<=n; i++)  cin>>a[i];
left = 0;
right = 500010;
while (left!=right) {
mid = (left + right) >> 1;
       if ( ok(mid) ) 
           right = mid;
       else
left = mid + 1;
}
cout << left << endl;
fclose(stdin);
fclose(stdout);
return 0;
}
```
【参考程序】

```cpp
var
n, dx, dy, i, left, right, mid: longint;
a: array[0..500010] of longint;
function ok(mid: longint): boolean;
var
count, x, y, i: longint;
begin
   count:=0;
   for i:=1 to n do
   begin
      x := a[i] - mid*dx;
      if x<=0 then continue;
      y:=x div dy;
      if x mod dy<>0 then inc(y);
      inc(count,y);
      if count>mid then exit(false);
   end;
if count<=mid then
   exit(true)
   else 
exit(false);
end;
begin
readln(n, dx, dy);
for i:=1 to n do read(a[i]);
left:=0;
right:=500010;
while left<>right do
begin 
mid:=(left+right) shr 1;
      if ok(mid) then
         right:=mid
      else 
left:=mid+1;
end;
writeln(left);
end.
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
#include<cctype>
using namespace std;
int main()
{
    priority_queue<int>heap;
    int n,a,b;
    cin>>n>>a>>b; 
    for(int i=1;i<=n;i++){
        int u;
        cin>>u;
        heap.push(u);
    }
    int k=1;
    for(;heap.top()>k*a;k++){
        int u=heap.top();
        heap.pop();
        u-=b;
        heap.push(u);
    }
    cout<<k<<endl;
    return 0;
}

```

---

## 作者：fighter_OI (赞：0)

贪心思路同楼下，每次都用洗衣机烘干最大值。

用线段树（乱搞）

有些不同的是，这里线段树存的是区间最大节点的编号（好改）

Pascal：


```cpp
var sd:array[1..500000] of longint;
     f:array[1..1500000] of longint;
     n,a,b,t,p,i:longint;
procedure buildtree(l,r,k:longint);
var mid:longint;
begin
 if l=r then
  begin
   f[k]:=l;
   exit;
  end;
 mid:=(l+r) shr 1;
 buildtree(l,mid,k shl 1);
 buildtree(mid+1,r,k shl 1+1);
 if sd[f[k shl 1]]>sd[f[k shl 1+1]] then f[k]:=f[k shl 1]
                                         else f[k]:=f[k shl 1+1];
end;
procedure updata(l,r,k:longint);
var mid:longint;
begin
 if l=r then exit;
 mid:=(l+r) shr 1;
 if p<=mid then updata(l,mid,k shl 1)
             else updata(mid+1,r,k shl 1+1);
 if sd[f[k shl 1]]>sd[f[k shl 1+1]] then f[k]:=f[k shl 1]
                                         else f[k]:=f[k shl 1+1];
end;
begin
 read(n,a,b);
 for i:=1 to n do
  read(sd[i]);
 buildtree(1,n,1);
 t:=0;
 while t*a<sd[f[1]] do
  begin
   inc(t);
   dec(sd[f[1]],b);
   p:=f[1];
   updata(1,n,1);
  end;
 write(t);
end .
```
时间复杂度：O(tlogn) (还好它没搞什么东西卡我)
空间复杂度：<=10m （线段树的悲剧）

#学好数据结构，走遍天下都不怕！！！


---

## 作者：Only_My_Whisper (赞：0)

其实这题可以用C++STL中的优先级队列来优化贪心：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    priority_queue<int>q;
    int n,a,b,i,k=0;
    cin>>n>>a>>b;
    int num[n+1];
    for(i=1;i<=n;i++){
        cin>>num[i];
        q.push(num[i]);
    }
    for(;q.top()-k*a>0;k++){
        int x;
        x=q.top();
        q.pop();
        x-=b;
        q.push(x);
    }
    cout<<k;
    return 0;
}
```

---


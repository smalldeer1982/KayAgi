# 三子棋II

## 题目描述

小 a 和 uim 喜欢互相切磋三子棋。三子棋大家都玩过是吗？就是在九宫格里面 $\verb!OOXX!$（别想歪了），谁连成 $3$ 个就赢了。

虽然小 a 很努力地记录棋谱，可还是下不过 uim。

由于小 a 比较愚蠢，uim 总是让他先。小 a 下的第一个子一定是在中心。

这回小 a 希望使用计策。目前棋局刚开始，棋盘上不到 $3$ 颗棋子，小 a 想知道，根据目前的局势，他有没有必胜策略（也就是自己以最佳方案下棋，无论对手怎么下，自己必胜）。


## 样例 #1

### 输入

```
---
-O-
---```

### 输出

```
Dont know.
1
```

## 样例 #2

### 输入

```
---
-O-
-XO```

### 输出

```
xiaoa will win.
3```

# 题解

## 作者：stone_juice石汁 (赞：210)

瞟了一眼题解的做法，感觉都把这道题做麻烦了。

**不需要花里胡哨的双重$for$枚举每个点，也不需要什么数组**

**并且只需要$8$行就可以写完。**

那么怎么做到这种操作的 O_O?

## 思路

**首先，注意题目中给了两个信息：**

- $1$、小a每次都先下，并且都是下正中心位置。

- $2$、在场的棋子数不超过三颗

我不知道是不是有人没注意到这两个信息。这直接决定了思路的繁简 和 代码的长短。

我们来分析一下这两个信息：

- $1$、小a每次占住正中心位置，毫无疑问这是巨大优势，**这时候小a不管下在哪里都可以凑成两颗，而uim则不得不防守。**

- $2$、在场的棋子数不超过三颗，**这意味着当时的情况一定未分出胜负**（所以写什么判断当时是否出现胜负那是完全不必要的）。

那么，~~江南老赌手~~石汁教你如何下三子棋，保证不输的那种。

由于小a每次都会站中间，所以我们直接默认中间是$O$

![](http://zhzxoj-tuchuang-1256463233.cos.ap-hongkong.myqcloud.com/2019/08/11/5d5009f1b4282.png)

很明显，在只有一颗棋子时，完全判断不出胜负。

**我们可以把这张图看成对称的，那么现在，uim就只有两种选择。**

- **Ⅰ、走边角**

也就是走四个角的位置。这样走无疑是很明智的，**因为这么一走，uim就可以控制三条线。**
    
![](http://zhzxoj-tuchuang-1256463233.cos.ap-hongkong.myqcloud.com/2019/08/11/5d5009f1f096e.png)

**如果uim够聪明，这样走，基本上小a就没戏了。**

**但是如果小a也够聪明，小a也不会输掉。**

为什么这么说？

首先，小a在这种情况下必定会再下一颗棋子。只要它不下$X$的对角线位，那么uim在下一步必须防守。

如图例：

![](http://zhzxoj-tuchuang-1256463233.cos.ap-hongkong.myqcloud.com/2019/08/11/5d500bfa819d1.png)

此时，uim挡住了小a的进攻，**并且又控制住了一条边。**

小a很可怜了，只能走淡蓝色格子来凑成三颗，但很明显，它要走两步才能凑足。$uim$肯定不会给他这个机会

但是，$uim$也一直处于堵小a旗子的状态，导致他根本没机会凑足三颗，除非小a太傻了。

当然，如果uim智商下线，小a也有可能会赢。所以完全猜不透到底是平了还是谁赢了。

## 总结：uim第二颗走边角，完全不知道结果。

- **Ⅱ、走邻边**

这里所指的邻边，就是排除四个边角，相邻$O$的方格。

那么想想，uim走邻边会发生什么。

走邻边，意味着uim这颗棋子**只能控制住两条边**，如下图。

![](http://zhzxoj-tuchuang-1256463233.cos.ap-hongkong.myqcloud.com/2019/08/11/5d500df0745e5.png)

那么此时，小a只要不走$X$的对边位置，小a就凑成了两连颗。

理所当然地，uim必然会再出一颗棋子去防守，并且又控制住一条边。

但是这完全无济于事，就算如此，小a还是有三条可行线路可以让他连到$3$颗

如图：

![](http://zhzxoj-tuchuang-1256463233.cos.ap-hongkong.myqcloud.com/2019/08/11/5d500f1114c35.png)

其中打 $*$ 号的，代表着两种可行线路的重叠部位。只要小a落子此处，必然会形成双$2$局面。

uim可以堵，但堵得住一个，堵不住两个啊。所以uim会输。

在小a很菜的情况下，可能会不知道谁胜谁负，但是题面中写了这么一句话：**以最佳方案下棋，无论对手怎么下，自己必胜**

所以，只要有自己必胜的方案就可以了。刚刚无疑满足了这种情况

- **特殊情况**

uim走邻边有一种特殊情况

```
-O-
-O-
-X-

```
图丢了就不弄图了 ~~（其实想偷懒QAQ）~~

虽然我们上面提到过，小a不可能会这么下，但是要是数据里有这种情况，就必须特判。~~但问题是数据并没涉及到这种情况所以我就没写上去了~~

## 总结：除特殊情况，uim第二颗走邻边，小a必赢。

在加上落子数不可能超过三颗，也就是uim最多落一颗子。

综合上面所有条件，最后的最后，所有情况化为一句话：

**只要uim敢下邻边，那他必输**

**其他情况则不明输赢**

你看，玩这个游戏是不是可以保证不输QAQ，你先手必赢，你后手必不会输。

## 代码实现

呼，说了这么多，结果结论只有两句话....

我们只需要判断uim是否下邻边就行了对吧？

很简单，**直接用一层$for$从$1$跑到$9$，每次输入一个字符**

**如果$i$为偶数，并且发现输入的是一个$X$，就可以直接判uim负了**

如果没有出现上述情况，输出“不知道”即可。

先上一个可读性比较高的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int ans;
char x;
bool pd; //pd:判断，用于判断uim是否输了 

int main()
{
	for(int i = 1; i <= 9; i ++)
	{
		scanf("%c", &x);
		if(x == 'X' && !(i % 2))pd = true; //此时，uim已经输了 
		if(x == '-') ans ++;
		//由于我们还要输出棋子个数，我们则记录空格个数，用9-空格个数就知道棋子个数了 
	}
		
	if(pd == true)
		cout << "xiaoa will win．" << endl << 9 - ans;
	else 
		cout << "Dont know．" << endl << 9 - ans;
	return 0;
}
```

## 再上我之前说过的8行代码
（并且格式是标准的）

```cpp
#include<bits/stdc++.h>
int ans, x, pd;
int main(){
	for(int i = 1; ~scanf("%c", &x); i ++)
		if(x == 'X' && !(i % 2)) pd = true;
		else if(x == '-') ans ++;
	std::cout << (pd ? "xiaoa will win．" : "Dont know．") << std::endl << 9 - ans;
}
```

## 后记

这篇题解写的耗时有点久了，还要专门去配图A.A，希望大家都能看懂吧

如果有什么不懂得地方可以留言，我有时间必会看的。

~~看我这么苦的份上，是不是应该....~~


---

## 作者：LJC00118 (赞：21)

## 我的方法楼下解释的很清楚了

## 但是楼下都是不完全正确的

## 样例太水，没有将楼下题解过滤……

## 这里有一个反例


```cpp

-X-
-O-
-O-

```

## 我们只要对其作出特判就行了

## 经观察，如果都下在第2列或第2行，直接输出答案

## 具体方法看楼下的吧，我的代码只针对楼下的小错误

## 望修改数据


```cpp
#include<bits/stdc++.h>
using namespace std;
char ma[4][4];
int mx[4]={1,2,2,3};
int my[4]={2,1,3,2};
int ans=0;
int main()
{
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            cin>>ma[i][j];
            if(ma[i][j]!='-') ans++;
        }
    }
    if(ma[1][2]!='-'&&ma[3][2]!='-')//这就是我说的特判
    {
        cout<<"Dont know."<<endl<<3;
        return 0;
    }
    if(ma[2][1]!='-'&&ma[2][3]!='-')//这也是我说的特判
    {
        cout<<"Dont know."<<endl<<3;
        return 0;
    }
    bool pd=0;
    for(int i=0;i<4;i++)//这里我写的麻烦了一点，具体可以参考楼下代码
    {
        if(ma[mx[i]][my[i]]=='X') pd=1;
    }
    if(pd==1)
    {
        cout<<"xiaoa will win.";
    }
    else
    {
        cout<<"Dont know.";
    }
    cout<<endl<<ans;
    return 0;
}
```

---

## 作者：yltx (赞：12)

我用大号分发了一个题解，又不会修改，忽然发现不完整，赶紧用小号补充一下：

上面说到，如果一个棋盘为：

```cpp
- K -
K O K
- K -
```
K和符号的含义见 @引领天下 的题解

我来继续分析为什么uim下在K处就输了：

取一种情况：

```cpp
- X -
- O -
- - -
```
会演变为：

```cpp
- X O
- O -
- - -
```
uim会这样堵：

```cpp
- X O
- O -
X - -
```
这时，小a只需在这里下：

```cpp
- X O
- O -
X - O
```
很明显，无论uim怎么下，小a都赢了。

接下来几种情况，就像刚才的旋转，其结果都一样。

故我的方法正确。


---

## 作者：Ky1ine (赞：5)

## 这是一道分析题！！！

只要分析好，这题就迎刃而解了。

------------


### 题目大意：
小a和uim玩三子棋。胜利条件是在九宫格内使自己的棋子连成一线。

对于小a与uim之间的游戏，第一次下子必然是小a（以O代表）并且必然下在中间。

分析在目前的棋局中，是否存在必胜策略。



------------
对于这道题目，我们首先要搞清楚一个事实：**uim是决然没有必胜策略的！**

其实这个结论也不难分析出来，根据题意，在棋盘中有棋子的情况下，中间的位置已被小a占去了。此时假设uim要赢就只能横着或竖着连成一线，在这样的条件下，小a是可以轻而易举地封堵的。

分析完这一点后，我们就~~很自然地想到~~要去**分类讨论**：

1：棋盘中间没有棋子：

根据题意，第一颗子必然是小a在棋盘中间下的O，如果棋盘中间没有落子，那么显然棋盘中一颗棋也没有，也自然不存在什么必胜策略。

2：棋盘中间有棋子：

根据上面uim决然没有必胜策略的分析，我们只需去研究小a是否存在必胜策略即可。

而分析小a是否有必胜策略，又要进一步地分类讨论了。

① uim在小a下完中间子后在斜边下子：

那么很显然谁也没有必胜策略。

② uim在小a下完中间子后在横排的中间下子：

此时小a有必胜策略；

当然，也可能有出数据的人**~~丧心病狂地~~**使小a下棋智障在uim在横排的中间下子后也跟着uim在横排中间下子，就像这样：
```
-O-
-O-
-X-
```
因此在实现程序时需要注意这种情况~~（虽然数据很弱没有这么丧心病狂）~~。

似乎啰嗦的有点多，上代码：

```cpp
#include<iostream>
using namespace std;
int i, j, sum=0;
bool winner=false;//winner记录小a是否有必胜策略
char a[3][3];
int main() {
	for(i=1; i<=3; i++) {
		for(j=1; j<=3; j++) {
			cin>>a[i][j];
			if(a[i][j] != '-') {
				sum++;
			}
		}
	}
	if(sum != 0) { //如果中间为“O”
		if(a[1][1] == 'X') winner = false;
		else if(a[1][3] == 'X') winner = false;
		else if(a[3][1] == 'X') winner = false;
		else if(a[3][3] == 'X') winner = false;
		else { //判断“丧心病狂的情况”
			if(a[1][2] != 'O') {
				if(a[2][1] != 'O') {
					if(a[2][3] != 'O') {
						if(a[3][2] != 'O') winner = true;
					}
				}
			}
		}
	}
	else winner = false;
	if(winner) cout << "xiaoa will win." << endl << sum; //输出
	else cout << "Dont know." << endl << sum; //同上
	return 0;
}
```
这道题目的主要思路就是这样，希望能够对读者有所帮助。

~~蒟蒻码字不易，求过。~~

---

## 作者：__Luna__ (赞：4)

本题非常适合作为 Minimax 算法的板子题。

## 什么是 Minimax？

Minimax（极小化极大）算法，是一种应用于零和博弈问题的决策算法，其本质是一种启发式搜索。Tic-tac-toe（井字棋/三子棋）是 Minimax 算法的一个经典应用场景。

## 如何实现 Minimax？

以一棵搜索数上的节点表示每一次决策。Minimax 的思路是，构建一个评估函数，计算一条决策路径（用搜索树上的叶子节点表示）的对己方的有利程度，然后分 Max 和 Min 两种节点对决策路径进行筛选。

Max 节点，即己方进行决策的节点，总会从子节点中选择评估值最大的一个进行决策，同时其评估值即为当前节点的评估值；Min 节点，即对方进行决策的节点，总会从子节点中选择评估值最小的一个进行决策，同时其评估值即为当前节点的评估值。

以上过程通常使用深搜，可以用递归实现。

一棵裸的 Minimax 搜索数的决策过程是 $O(d^n)$ 的，所以我们需要对其进行减枝。

Minimax 经典的减枝算法称作 Alpha-Beta 减枝。对每个节点，称 $\alpha$ 为每个节点的最大可行下界，$\beta$ 为每个节点的最小可行上界。初始化根节点的 $alpha$ 为 $-\infin$，$\beta$ 为 $\infin$；每个节点将继承其父节点的 $\alpha$ 和 $\beta$ 作为初值。

对于每个 Max 节点应应用 $\alpha$ 减枝，即每访问完一个子节点以后将当前节点的 $\alpha$ 更新为 $\alpha$ 和评估值的较大值。若 $\alpha$ 在更新后满足 $\alpha\ge\beta$，则减枝，不再访问剩余的子节点。

对于每个 Min 节点应应用 $\beta$ 减枝，即每访问完一个子节点以后将当前节点的 $\beta$ 更新为 $\beta$ 和评估值的较小值。若 $\beta$ 在更新后满足 $\beta\le\alpha$，则减枝，不再访问剩余的子节点。

经过 Alpha-Beta 减枝后 Minimax 搜索的速度大大加快。

## 如何应用 Minimax？

现在为本题设计 Minimax 的解法。

首先考虑如何设计评估函数。我们设小 a 为“己方”，uim 为“对方”，则可以令小 a 胜利的评估值为 $1$，uim 胜利的估值为 $-1$，平局的评估值为 $0$。

输入当前局面，我们先判断轮到谁先手。由于初始时小 a 先手，所以小 a 的棋子多一颗即意味着现在是小 a 先手，棋子一样多即意味着现在是 uim 先手。

如果小 a 先手，我们令当前局面为 Max 根节点做一次 Minimax；如果 uim 先手，我们令当前局面为 Min 根节点做一次 Minimax。完成后根节点的评估值即为双方各取最优策略下最终的胜负。此时若平局则说明没有必胜策略，否则胜利方有必胜策略。

## 代码：
```cpp
#include<climits>
#include<iostream>
#include<vector>
#include<ctime>
#include<cstdlib>
using namespace std;
int t[3][3];
int end()
{
	int e=0;
	for(int i=0;i<3;i++)
	{
		for(int j=0;j<3;j++)
		{
			if(t[i][j]==0)e++;
		}
		if(t[i][0]==t[i][1]&&t[i][1]==t[i][2])
		{
			if(t[i][0]==1)return 1;
			else if(t[i][0]==2) return 2;
		}
		if(t[0][i]==t[1][i]&&t[1][i]==t[2][i])
		{
			if(t[0][i]==1)return 1;
			else if(t[0][i]==2) return 2;
		}
	}
	if(t[0][0]==t[1][1]&&t[2][2]==t[1][1])
	{
		if(t[0][0]==1)return 1;
		else if(t[0][0]==2) return 2;
	}
	if(t[2][0]==t[1][1]&&t[0][2]==t[1][1])
	{
		if(t[1][1]==1)return 1;
		else if(t[1][1]==2) return 2;
	}
	if(e==0)return 0;
	else return -1;
}
int minimax(int p,pair<int, int>&m,int a=INT_MIN,int b=INT_MAX)
{
	pair<int, int>mv(-1,-1);
	int e=end();
	if(~e)
	{
		return e==2?-1:e;
	}
	int di=0,dj=0;
	if(p==1)
	{
		int s=INT_MIN;
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
			{
				if (t[(i+di)%3][(j+dj)%3]==0)
				{
					t[(i+di)%3][(j+dj)%3]=1;
					int x=minimax(2,mv,a,b);
					if(x>s)s=x,m=make_pair((i+di)%3,(j+dj)%3);
					t[(i+di)%3][(j+dj)%3]=0;
					a=max(a,s);
					if(b<=a)break;
				}
			}
		}
		return s;
	}
	int s=INT_MAX;
	for(int i=0;i<3;i++)
	{
		for(int j=0;j<3;j++)
		{
			if (t[(i+di)%3][(j+dj)%3]==0)
			{
				t[(i+di)%3][(j+dj)%3]=2;
				int x=minimax(1,mv,a,b);
				if(x<s)s=x,m=make_pair((i+di)%3,(j+dj)%3);
				t[(i+di)%3][(j+dj)%3]=0;
				b=min(b,s);
				if(b<=a)break;
			}
		}
	}
	return s;
}
int main()
{
	pair<int, int>m(-1,-1);
	char j;
	int n=0,k=0,e=0;
	for(int i=0;i<9;i++)
	{
		cin>>j;
		t[i/3][i%3]=((j=='O')?(n++,1):((j=='X')?(n++,2):0));
	}
	(n&1)?(k=2):(k=1);
	e=minimax(k,m);
	cout<<((e==1)?"xiaoa will win.":((e==2)?"uim will win.":"Dont know."))<<endl;
	cout<<n<<endl;
	return 0;
}
```

---

## 作者：HNFMS_VistonZhang (赞：2)

楼下那位大佬讲的很对  
这还是有特殊情况的  
我用的是最蒻的解法    
```cpp
#include<bits/stdc++.h>
using namespace std;
int  main(){
	int a=0,i,j;
	char b[5][5];
	for(i=1;i<=3;i++)
	for(j=1;j<=3;j++)
	{
		cin>>b[i][j];
		if(b[i][j]!='-')
		a++;//有几个棋子
	}
    if((b[1][2]=='X'&&b[3][2]!='O')||(b[3][2]=='X'&&b[1][2]!='O')||
    (b[2][1]=='X'&&b[2][3]!='O')||(b[2][3]=='X'&&b[2][1]!='O'))
	cout<<"xiaoa will win.";//极限条件
	else cout<<"Dont know.";
	cout<<'\n'<<a;//输出棋子
	return 0;
}
```

---

## 作者：CREED (赞：0)

###**本人为方便所有OIer解题，在此枚举所有可能性。**

1. 开局

---
-O-
---
- 这时分两种情况，一是靠，二是小尖。（不列举四种情况）

1.1靠
-X-
-O-
---
1.1.1靠

OX-
-O-
---
这时出现了一个结局，xiaoa 赢。

OX-
-O-
O-X   (其中在贰行1列可赢，壹行3列可赢，见合）

1.1.2长1

-X-
OOA
B--
出现第二个结局,因uim必堵A位，xiaoa 可在B位下子。

-X-
OOX
O--(壹行1列、3列见合）

1.1.3长2

-X-
-O-
-O-
(不定）

1.1.3.1若uim长，则

XXA
COD
BO- xiaoa在A位堵，uimB位堵，xiaoaC位堵，uimD位堵。结果：（平）

1.1.3.2若uim小尖

-X-
XO-
AOB
A位B位即可落子。（xiaoa赢） 故1.1.3式为不定。

1.2小尖

X--
-O-
---
1.2.1靠

XO-
-O-
-A- （不定）uim必定在A位堵

1.2.1.1

XOO
BOC
AXD  若xiaoa于壹行3列下子，则平。顺序由A-B-C-D

1.2.1.2

XO-
OOX
-X-
1.2.1.2.1

XOO
OOX
-X-（平）

1.2.1.2.2

XO-
OOX
-XO(平)

1.2.1.3

XOC
AOO
BXD(平）

1.2.1.4

XOA
-O-
OX-
1.2.1.4.1

XOX
OOA
OXB(平)

1.2.1.4.2

XOX
AOO
OXB(平）

1.2.1.4.2

XOX
-O-
OXO（平）

1.2.1.5

XO-
-O-
-XO(不定）

1.2.1.5.1

XOX
-O-
-XO
1.2.1.5.1.1

XOX
OOA
BXO(平）

1.2.1.5.1.2

XOX
AOO
BXO(平）

1.2.1.5.1.3

XOX
-O-
OXO(平）

1.2.1.5.2

XOB
XOC
AXO(平）

1.2.1.5.3

XO-
-OX
-XO
1.2.1.5.3.1

XOO
BOX
AXO(平）

1.2.1.5.3.2

XO-
OOX
-XO(同1.2.1.2.2形）

1.2.1.5.3.3

XOA
BOX
OXO(平）

1.2.1.5.4

XOC
AOB
XXO(平）故1.2.1平

1.2.2
X-O
BOC
A--
1.2.2.1

XOO
OOX
XAB(平)

1.2.2.2

XAO
OOX
XOB(平）

1.2.2.3

X-O
OOX
X-O(平）

1.2.3
XDC
AOO
BEF（ping）

1.2.4
X--
-O-
--O
1.2.4.1

XXA
-O-
--O（xiaoa赢）

1.2.4.2

XAX
-O-
-BO
1.2.4.2.1

XOX
OOA
BXO(平）

1.2.4.2.2

XOX
-O-
OXO(平）

1.2.4.3

X--
-OX
--O
1.2.4.3.1

X--
-OX
O-O(xiaoa赢）。



---


# 外星密码

## 题目描述

有了防护伞，并不能完全避免 2012 的灾难。地球防卫小队决定去求助外星种族的帮助。经过很长时间的努力，小队终于收到了外星生命的回信。但是外星人发过来的却是一串密码。只有解开密码，才能知道外星人给的准确回复。解开密码的第一道工序就是解压缩密码，外星人对于连续的若干个相同的子串 $\texttt{X}$ 会压缩为 $\texttt{[DX]}$ 的形式（$D$ 是一个整数且 $1\leq D\leq99$），比如说字符串 $\texttt{CBCBCBCB}$ 就压缩为 $\texttt{[4CB]}$ 或者$\texttt{[2[2CB]]}$，类似于后面这种压缩之后再压缩的称为二重压缩。如果是 $\texttt{[2[2[2CB]]]}$ 则是三重的。现在我们给你外星人发送的密码，请你对其进行解压缩。


## 说明/提示

【数据范围】

对于 $50\%$ 的数据：解压后的字符串长度在 $1000$ 以内，最多只有三重压缩。

对于 $100\%$ 的数据：解压后的字符串长度在 $20000$ 以内，最多只有十重压缩。保证只包含数字、大写字母、`[` 和 `]`。


## 样例 #1

### 输入

```
AC[3FUN]```

### 输出

```
ACFUNFUNFUN```

# 题解

## 作者：云浅知处 (赞：361)

这题考递归，难度适中。

题解[P1928 外星密码](https://www.luogu.com.cn/problem/P1928)

[更好的阅读体验？](https://www.luogu.com.cn/blog/wwwluogucn/solution-p1928)

------------
$1.$初步思路

输入的这个字符串是被多重「压缩」的，所以一重一重地「解压缩」可能会非常非常麻烦（不过应该是可行的），导致代码极其难以理解。

所以，我们使用**递归算法**，在读入这个字符串之后，找出被压缩的内容，再对被压缩的那个字符串实行「解压缩」操作。

举个例子：`AC[3FUN]`

首先，我们找到了被压缩的字符串：`3FUN`

对`3FUN`进行解压，得到`FUNFUNFUN`

再把原来的字符串`AC`后面添上`FUNFUNFUN`即可。

由于这个只有一重「压缩」，可能递归思想体现的不太明显，这里再举一个多重「压缩」的例子：

`SAD[4MLE[2TLE[2RE[2WA]]]`

首先找到被「压缩」的部分：

`[2MLE[2TLE[2RE[2WA]]]]`

（从此处开始剩下的部分就是递归的内容了，全部由程序自主实现）

对这个部分进行解压，找到被「压缩」的部分：

`[2TLE[2RE[2WA]]]`

再对这个部分进行解压，找到被「压缩」的部分：

`[2RE[2WA]]`

再对这个部分进行解压，找到被「压缩」的部分：

`[2WA]`

（开始一层一层跳出递归）

对这个部分进行解压并加到前一个字符串的末尾：

`[2REWAWA]`

再对这个部分进行解压并加到前一个字符串的末尾：

`[2TLEREWAWAREWAWA]`

再对这个部分进行解压并加到前一个字符串的末尾：

`[2MLETLEREWAWAREWAWATLEREWAWAREWAWA]`

再对这个部分进行解压并加到前一个字符串的末尾：

`SADMLETLEREWAWAREWAWATLEREWAWAREWAWAMLETLEREWAWAREWAWATLEREWAWAREWAWA`

至此，递归结束，「密码」破译完毕。

所以，我们只需要找到被「压缩」的子串，并把这个字符串扔给「解压缩」程序即可。

------------
$2.$注意事项

最重要的是： 千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔。[——OI Wiki](https://oi-wiki.org/basic/divide-and-conquer/#_3)

我们也看到了，上面对`SAD[4MLE[2TLE[2RE[2WA]]]`的分析细节很多很多，十分复杂。

我们只需要把这个需要「解压缩」的字串扔给「解压缩」函数即可。

------------
$3.$代码实现

```cpp
#include<bits/stdc++.h>//万能头棒棒哒
using namespace std;
string yunqian(){
    int k;//压缩的次数
    char ch;//输入的字符
    string s="",str="";//s是最终答案，str是被压缩的字串，别忘了初始化
    /*注意：ch,s,str应该定义在函数内部，才能在每次递归中初始化，否则会导致一堆RE，可能还有几个MLE，总之没法AC，我就因为这个错了好几回*/
	while(cin>>ch){//不断输入字符
		if(ch=='['){//如果找到了被压缩的字串
			cin>>k;//输入压缩次数
			str=yunqian();//递归调用
			while(k--){
				s+=str;//把解压后的字串复制k次后添加到原来的字符串上
			}
		}
		else if(ch==']'){//如果找到了压缩的字串的末尾
			return s;//结束这一层递归并返回已经被解压的字串
		}
		else{//如果没有被压缩
			s+=ch;//直接在最后添上这个字符。
		}
	}
}
int main(){
	cout<<yunqian();
	return 0;//完结撒花～
}
```

$\text{The\ end.}$

---

## 作者：hensier (赞：63)

[获得更好阅读体验](https://shenyouran.github.io/P1928/)

本题有两种方法，一种是纯模拟的思想，一种是递归思想。

【方法$1$：字符串处理】

我们需要操作的对象是方括号内的部分，对于方括号外面的内容，我们不需要进行任何的操作，因此我们要找到最内层的括号，并进行处理。处理完了之后，我们把原来的进行替换。这样一直重复，直到没有括号为止，我们就得到了最终的答案。

例如下面这个数据：

```plain
AC[3[3AK]]
```

上述数据中，最内层的括号组为`[3AK]`，而我们可以发现，最内层的左括号是整个字符串最右边的左括号，右括号则是整个字符串最左边的右括号。因此我们只需要写一个循环，找到这两个字符即可。

我们先查找左括号：

```cpp
int l=-1;//l保存左括号的位置
for(int i=str.size()-1;i>=0;i--)
{
    if(str[i]=='[')
    {
        l=i;
        break;
    }
}
if(l==-1)break;//如果找不到，就说明没有括号，即处理完毕
```

而与之相匹配的右括号必定在左括号的右边，所以搜索范围从$[0,str.size())$变为$[l,str)$，即：

```cpp
int r=-1;//r保存右括号的位置
for(int i=l;str[i];i++)//搜索区间：从左括号的位置开始到字符串结束
{
    if(str[i]==']')
    {
        r=i;
        break;
    }
}
//这里不需要特判没有右括号，因为前面在寻找左括号的时候已经特判过了
```

假如有括号存在，那么被处理的部分则是$(l,r)$，即两个括号之间（不含括号）的部分。取其子串：

```cpp
string ns="";//初始赋值为空
for(int i=l+1;i<r;i++)ns+=str[i];//搜索区间为两括号之间（不含括号），把这一部分内容全部放入ns中
str=str.replace(l,r-l+1,rep(ns));
```

`string.replace(start,len,str)`用法：
从`start`这个位置开始，取长度为`len`的字符串，将其替换为`str`。

在这个时候，因为区间为$(l,r)$，即$[l+1,r-1]$，所以长度为$r-l+1$。而替换的是这一段处理之后的内容，用一个名为`rep`的函数实现。

接下来我们要完成`rep`函数的实现：

将`s`设为函数参数（字符串类型），`t`为分离的数字，`x`为分离出来的字符串。

我们在整个字符串`s`中处理即可，即区间为$[0,|s|)$。思路如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/aqo2ze83.png)

代码：

```cpp
for(int i=0;s[i];i++)
{
    if(isdigit(s[i]))t=(t<<3)+(t<<1)+(s[i]^48);//t进行累加
    else break;//不是数字就跳出循环
}
```

$\color{red}\text{Step 2: 分离字符串}$

类比分离数字的方法，我们可以用相似的方式处理：

代码：

```cpp
for(int i=s.size()-1;i>=0;i--)
{
	if(isalpha(s[i]))x+=s[i];//字符串加入新字符
	else break;//退出循环
}
reverse(x.begin(),x.end());//注意！我们是倒着进行保存的，所以需要反转
```

新建一个字符串`y`，保存拼接的内容，总共包含`t`个`x`字符串。进行拼接：

```cpp
while(t--)y+=x;//往y中加入t个x
return y;//返回y
```

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string str;
string rep(string s)
{
    int t=0;
    for(int i=0;s[i];i++)
    {
        if(isdigit(s[i]))t=(t<<3)+(t<<1)+(s[i]^48);
        else break;
    }
    string x="",y="";
    for(int i=s.size()-1;i>=0;i--)
    {
        if(isalpha(s[i]))x+=s[i];
        else break;
    }
    reverse(x.begin(),x.end());
    while(t--)y+=x;
    return y;
}
int main()
{
    cin>>str;
    while(true)
    {
        int l=-1,r=-1;
        for(int i=str.size()-1;i>=0;i--)
        {
            if(str[i]=='[')
            {
                l=i;
                break;
            }
        }
        if(l==-1)break;
        for(int i=l;str[i];i++)
        {
            if(str[i]==']')
            {
                r=i;
                break;
            }
        }
        string ns="";
        for(int i=l+1;i<r;i++)ns+=str[i];
        str=str.replace(l,r-l+1,rep(ns));
    }
    cout<<str;
    return 0;
}
```

【方法$2$：递归】

本题同样可以使用递归的算法（已经有很多大佬指出了）：

![](https://cdn.luogu.com.cn/upload/image_hosting/hy76tejr.png)

主函数只需调用递归函数即可，因为递归函数既实现输入，又实现了字符串的处理。

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string f()
{
    string s1="",s2;
    char ch;
    while(cin>>ch)
    {
        if(ch=='\n')break;
        if(ch=='[')
        {
            int t;
            scanf("%d",&t);
            s2=f();
            while(t--)s1+=s2; 
        }
        else if(ch==']')return s1;
        else s1+=ch;
    }
}
int main()
{
    cout<<f();
    return 0;
}
```

---

## 作者：檀黎斗·神 (赞：31)

这道题我们可以通过栈的思想来做

先建立一个结构体

当我们找到“ [ ”之前的所有项直接存在字符串里面

然后将“ [ ”作为空串“”入栈

对于之后的字符串里面“  [ ”进行同样处理就好了

对于之后的数字我们就存在" [ "所属结构体的另一元素 int 里

当找到“ ] ”时我们就优先将栈顶元素出栈

将栈顶中元素中 int 次数的字符串加到原串中

最后我们的字符串就是一个只剩下大写字母的字符串了

就是把密码解开了

文字表达功力有限，下面贴出代码方便理解

···cpp

```cpp
#include<iostream>
#include<string>
using namespace std;
struct stack{
    int t;
    string s;
}st[20]; //t来存之后找到时要循环的次数，s就是之后的字符串
int x;
string s;
int main(){
    cin>>s;
    int lens=s.size(),len=0;
    for (int i=0;i<lens;i++){
        if (s[i]<='Z'&&s[i]>='A')
            st[len].s+=s[i];
        else if (s[i]=='['){
            st[++len].s="";
            st[len].t=0; //记得清零，防止出现[xxxx][xxxx]的情况 
        }
        else if (s[i]<='9'&&s[i]>='0')
        st[len].t=st[len].t*10+s[i]-'0';  
        else if (s[i]==']'){
            for (int j=1;j<=st[len].t;j++)
                st[len-1].s+=st[len].s;
            len--;
        }
    }
    cout<<st[0].s<<endl;//直接输出最开始的字符串 
    return 0;//标准的退出，记得写 
}
···
```

---

## 作者：Drifterming (赞：29)

/\*我们先找出每个左括号的位置，然后到着从后往前枚举，因为最后一个括号内肯定是没有括号的。找出没一个括号内要解压的子串以及要解压的次数，将子串解压后得到一个新串，然后将左右括号之间的子串删掉，再将解压后得到的串插入。\*/




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int sum,num;
int start[105],ended;
string s,temp,now;
int main()
{
    cin>>s;
    for(int i=0;i<s.length();i++)
    {
        if(s[i]=='[')        //找左括号的位置 
        {
            start[++sum]=i;
        }
    }
    for(int i=sum;i;i--)    //从最后一个左括号开始做，因为最后一个括号内肯定没有括号了 
    {
        ended=2;num=0;temp.clear();now.clear();    //ended=2，因为还要加上左右括号 
        for(int j=start[i]+1;s[j]!=']';j++)
        {
            if(s[j]>='0'&&s[j]<='9')    //要把串复制几遍 
            {
                num=num*10+s[j]-'0';
            }
            else
            {
                temp+=s[j];
            }
            ended++;        //右括号的位置 
        }
        for(int j=1;j<=num;j++)        //将字串解压 
        {
            now+=temp;
        }
        s.erase(start[i],ended);        //将左右括号以及之间的子串删掉 
        s.insert(start[i],now);        //插入扩展开的串 
    }
    cout<<s;
    return 0;
}

```

---

## 作者：Elma_ (赞：19)

## 递归

本蒟蒻又来发题解啦~（~~想抄的话就抄吧~~

其实这道题作为绿题来说还是比较水的。

我们可以先模拟一下样例解码的过程：

$AC[3FUN] \to ACFUNFUNFUN$

$[2[2[2CB]]] \to [2[2CBCB]] \to [2CBCBCBCB] \to CBCBCBCBCBCBCBCB$

发现了什么？很显然，**密码的解压缩总是从最里面一层开始，然后逐层往上解压，逐层返回。**

对于这种逐层解决的问题，我们很容易想到用**递归**的方法解题。

### 核心代码：

```cpp
while(cin>>c)
{
	if(c == '[')
	{
		cin>>num;
		x = expand();
			
		while(num--)
			key += x;
	}
	else 
    	if(c == ']')
        	return key;
        else 
        	key += c;
}
```

上面代码主要思想就是，如果读到左中括号，则进入递归，对下一层进行解压，直到碰到右中括号。除此之外还要特判有些字符不需要参与下一层的解压。具体其他细节见代码。

### CODE：
```cpp
#include <iostream>
#include <string>
using namespace std;

string expand()
{
	string key = "", x;\\key即解压后的密码，x为下一层解压后的密码
	char c;
	int num;\\记录本层的密码需要重复几次
	
	while(cin>>c)\\输入小技巧
	{
		if(c == '[')\\如果读到左中括号
		{
			cin>>num;\\输入需要重复的次数
			x = expand();\\解压下一层
			
			while(num--)\\将x重复num次
				key += x;
		}
  
		else 
  			if(c == ']')\\如果是右中括号
				return key;\\返回这层的密码
			else \\如果都不是
  				key += c;\\不参与下一层的解压，直接加上
	}
}

int main(void)
{
	cout<<expand();\\输出
	return 0;\\完美AC~
}
```

---

## 作者：樱木花道2020 (赞：18)

做了一整天，估计是这道题最难写的解法了，好处是便于理解，好懂不好写
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 12;

int len;
char dat[20005];
char res[20005];
int  pos;

void input_data(){
	memset(res, 0, sizeof(res));
	cin >> dat;
	return;
}
void output_data(){
	cout << res;
	return;
}
void dfs(int low, int high){
    if(low >= high){//[low, high)
		return;
	}
	//去掉最外层括号，再递归 
	if(dat[low] == '[' && dat[high-1] == ']'){
		dfs(low+1, high-1);
		return;
	}
	int lft = 0;
	int rit = 0;//左右括号计数
	 
	//将整个串分为times*(   [beg1, end1), [beg2, end2), [end2, high)   ) 
	int beg1 = low; 
	int end1 = high;//第一段不带括号的字母 
	
	int beg2 = low; 
	int end2 = high;//第一段不带括号的字母后面的第一段括号 
	
	//计算重复次数 
	int times = 1;//默认的重复次数为1 
	if(dat[low] >= '0' && dat[low] <= '9'){//如果出现数字，说明重复次数不为1 
		times = 0;
		for(int i = low; ; i++){
			if(dat[i] >= '0' && dat[i] <= '9'){
				times = times*10+dat[i]-'0';
			}else{
				beg1 = i;
				break;
			}
		}
	}
	for(int i = beg1; i < high; i++){
		//如果没有遇到括号，只有数字和字母, 只用上了 [beg1, end1), 没用上其它2段 
		//题目给的字符串是正确的，所以如果到最后一个字符都没有出现左括号，也不会出现右括号了 
		if(lft == 0 && i == high-1){
		    for(int j = 0; j < times; j++){
 		        for(int k = beg1; k < high; k++){
 		        	res[pos++] = dat[k];
				 }
			}
            break;
		}
		
		//遇到左括号，就把数字之后，第一个左括号前的内容分为第一段 
		if(lft == 0 && dat[i] == '['){
			end1 = i;
			beg2 = i;
		}
		if(dat[i] == '['){
			lft++;
		} 
		if(dat[i] == ']'){
			rit++;
		}
		
		//括号成对，划分第二段，如第二段没有用完整个字符串，则剩余部分自动组成第三段 
		if(lft != 0 && rit != 0 && lft == rit){
			end2 = i+1;//
			for(int j = 0; j < times; j++){
				dfs(beg1, end1);//第一段 
			    dfs(beg2, end2);//第二段 
				dfs(end2, high);//第三段 
			}
			break;
		}
	}
	return;
}

void process_data(){
	len = strlen(dat);
	pos = 0;
	dfs(0, len);
	res[pos] = '\0';
	return;
}

int main(){
    input_data();
    process_data();
    output_data();
    
	return 0;
}
```


---

## 作者：fls233666 (赞：6)

这题的关键问题在于**有多重的压缩嵌套**。对此，有两种的解决方案。

1. 遇到一层嵌套时递归进去，展开完成后回到这一层
2. 遇到一层嵌套时堆栈，把重复次数和字符串记下来，展开时逐层出栈

这里我们来讲第$2$种方案：

## 思路讲解

首先我们要清楚，**我们要存什么？**

我们要记录的是**要复制的字符串**和**复制的次数**！

那么我们开个pair封装一下栈，然后开始写栈的基本操作。我们要写的基本操作有以下这些：

- 把数字入栈
- 把字符串拼入栈顶的字符串
- 把数字出栈
- 把字符串出栈
- 删除栈顶元素

于是我们搞出了这些代码：

```cpp
pair <int,string> z[20];   //栈
int lz=0;  //栈顶指针（栈的长度）
  
void pht(int a) {
	lz++;  
	z[lz].first=a;
}
 //数字入栈
  
void phst(string c) {
	z[lz].second+=c;
}
  //栈顶字符串拼接
  
int topt() {
	return z[lz].first;
}
  //数字出栈
  
string topst() {
	return z[lz].second;
}
  //字符串出栈
  
void pop() {
	z[lz].second="";  //一定要记得要设成空串
	lz--;
}
  //删除栈顶元素
  
```

 _这里我认为写STL可能会太慢，所以手写栈。写STL也可以，供大家自行实现。_ 

接下来写主函数：

想想这样一个问题：如果你读入一个字符$c$，问$c$**有几种情况**？

answer：4种情况。左括号，右括号，大写字母，数字字符。

分别处理：

- 如果是左括号：循环读入数字字符，合成数字，读到非数字字符时跳出循环。把合成的数字压入栈顶，**如果读到的非数字字符还是左括号，重复执行上述内容**，否则字符拼入栈顶字符串。

- 如果是右括号： _由于题目保证不会出现括号不匹配，所以不用再拿栈存左括号判断是否匹配_ 。取出栈顶数字和字符串，然后把字符串复制，存到一个临时的字符串变量中。把栈顶元素删除，如果删除后栈为空，把得到的字符串拼到$ans$字符串中，否则拼到栈顶字符串中。

- 其它字符（大写字母）： _数字已经和左括号一起被处理了_ 。判断如果栈顶为空，拼到$ans$字符串中，否则拼到栈顶字符串中。

## 完整AC代码

```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
string ans="";
pair <int,string> z[20];
int lz=0;
void pht(int a) {
	lz++;
	z[lz].first=a;
}
void phst(string c) {
	z[lz].second+=c;
}
int topt() {
	return z[lz].first;
}
string topst() {
	return z[lz].second;
}
void pop() {
	z[lz].second="";
	lz--;
}
  //手写栈部分（上文已讲解）
  
int main() {
	char ch;  //存储读进来的字符
	int tnum;  //临时数字变量
	string tqz;  //临时字符串变量
	while(cin>>ch) {
		switch(ch) {
			case '[':
				while(ch=='[') {
					cin>>ch;
					tnum=0;  //
					while(ch>='0'&&ch<='9') {
						tnum=tnum*10+(ch-'0');
						cin>>ch;
					}
					pht(tnum);  //压入数字
				}
				tqz=ch;  //把char改成string
				phst(tqz);  //拼入栈顶字符串
				break;
  
			case ']':
				tqz="";  //记得每次调用临时字符变量时要清空
				tnum=topt();  //取出栈顶数字
				for(int i=0; i<tnum; i++)
					tqz+=topst();  //复制栈顶字符串
				pop();  //删除栈顶元素
				if(!lz)   //判断栈是否为空并执行对应操作
					ans+=tqz;
				else
					phst(tqz);
				break;
                                     
			default :
				if(!lz) ans+=ch;
				else {
					tqz=ch;
					phst(tqz);
				}
                                     
		}
	}
	cout<<ans<<endl;   //要加上换行才能AC哦
	return 0;
}

```


---

## 作者：HPXXZYY (赞：5)

## $$\color{green}{\text{洛谷P1928\ \ \ \ \ 外星密码}}$$

$\color{blue}{\text{【题意】：}}$ 有了`防护伞`，并不能完全避免 $2012$ 的灾难。`地球防卫小队`决定去求助外星种族的帮助。经过很长时间的努力，小队终于收到了外星生命的回信。但是外星人发过来的却是一串密码。只有解开密码，才能知道外星人给的准确回复。解开密码的第一道工序就是解压 缩密码，外星人对于连续的若干个相同的子串 `X` 会压缩为 `[DX]` 的形式（$D$ 是一个整数且 $1\leq D\leq 99$），比如说字符串 `CBCBCBCB` 就压缩为 `[4CB]` 或者 `[2[2CB]]` ，类 似于后面这种压缩之后再压缩的称为`二重压缩`。如果是 `[2[2[2CB]]]` 则是三重的。现在我们给你外星人发送的密码，请你对其进行解压缩。

**【数据范围】：**

- 对于 $50\%$ 的数据：解压后的字符串长度在 $1000$ 以内，最多只有三重压缩。

- 对于 $100\%$ 的数据：解压后的字符串长度在 $20000$ 以内，最多只有十重压缩。保证只包含数字、大写字母、`[` 和 `]`。

---------------------------------------

$\color{blue}{\text{【思路】：}}$ 因为最多只有 $10$ 重的压缩，所以我们可以从此入口。记 $S_i$ 表示第 $i$ 重的压缩展开后的结果，我们可以如此计算它（$dep$ 表示当前是第 $dep$ 重的压缩）：

- 如果当前字符是一个字母的话，直接把它放至 $S_{dep}$ 的最后一位。
- 如果当前字符是 `[`，代表我们可以了新的一层压缩，我们可以先取出 $D$，然后把 $S_{dep+1}$ 求出。第 $dep+1$ 层压缩对 $S_{dep}$ 的贡献就是 $num$ 个 $S_{dep+1}$，直接把 $num$ 个 $S_{dep+1}$ 放入 $S_{dep}$ 的后面即可。

考虑到递归的层数很小（只有 $10$），所以我们可以用**递归**解决问题。

--------------------------------

$\color{blue}{\text{【代码】：}}$
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315134525407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315134550355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pIVVlJTkdZRV8xMjM0NTY=,size_16,color_FFFFFF,t_70)

----------------------------------

如果洛谷的 `LaTeX` 公式显示不出来，大家可以参考我的同期博客。

博客地址：[https://blog.csdn.net/ZHUYINGYE_123456/article/details/104877546](https://blog.csdn.net/ZHUYINGYE_123456/article/details/104877546)

---

## 作者：WanderingTrader (赞：5)

看到子串有多重嵌套，我想到了递归。  
当然，首先要做的是括号匹配，这个用一个栈即可。  
我们用一个数组$p[i]$记录$i$位置上左括号$($如果有的话$)$对应的右括号，容易得到下面的代码：
```cpp
	string s;
	cin >> s;
	int l = s.length();
	for(int i = 0;i < l;i ++)
	{
		if(s[i] == '[') st.push(i);
		else if(s[i] == ']') { p[st.top()] = i; st.pop(); }
	}
```
这样将括号一一匹配后，递归操作就方便多了。  
我们写一个$deal(a,b)$表示对$[a,b]$这个区间进行输出处理：
```cpp
void deal(int a,int b)
{
	int x,start;
	for(int i = a;i <= b;i ++)
	{
	//主要操作区
    	}
}
```	
(以下代码均在$for$循环中)  
先对没有压缩部分(字母)进行输出，即：  
``` if(isalpha(s[i])) printf("%c",s[i]);```    
如果碰到左括号，我们先要计算压缩次数，这个很容易，用类似快读的写法：
```cpp
	else {
		x = 0;
		start = i ++;
		while(isdigit(s[i])) { x=10*x + s[i]-'0'; i ++; }
        }
```      
注：此处$start$的作用是记录左括号的位置，因为$i$已经被修改了。  
压缩次数计算完毕，直接递归调用$deal(\ )$函数$x$次即可:
```cpp
	else {
    		x = 0;
		start = i ++;
		while(isdigit(s[i])) { x=10*x + s[i]-'0'; i ++; }
		for(int j = 1;j <= x;j ++)
		{
			deal(i,p[start] - 1);
		}
		i = p[start];
	}

```
由于刚才记录了$start$，我们在传入$deal(\ )$的参数，以及最后修改$i$的值都变得方便一些了。  
这样操作就结束了。  
最后拿上$AC$代码，祝大家刷题愉快：
```
#include<bits/stdc++.h>
using namespace std;
string s;
#define N 1005
int p[N];
stack <int> st;
void deal(int a,int b)
{
	int x,start;
	for(int i = a;i <= b;i ++)
	{
		if(isalpha(s[i])) printf("%c",s[i]);
		else {
			x = 0;
			start = i ++;
			while(isdigit(s[i])) { x=10*x + s[i]-'0'; i ++; }
			for(int j = 1;j <= x;j ++)
			{
				deal(i,p[start] - 1);
			}
			i = p[start];
		}
	}
}
int main(){
	cin >> s;
	int l = s.length();
	for(int i = 0;i < l;i ++)
	{
		if(s[i] == '[') st.push(i);
		else if(s[i] == ']') { p[st.top()] = i; st.pop(); }
	}
	deal(0,l - 1);
	return 0;
}
```

---

## 作者：B_Qu1e7 (赞：4)

可以说这是一道比较难的入门题

很好上手但是中间怎么操作比较困难

具体见代码
```cpp
#include<iostream>
using namespace std;
string s,kp="";
int tot=0,gtx,gty=0,cpy=0;
int main()
{
	cin>>s;
	for(int i=0;i<s.size();i++)if(s[i]=='[')tot++;//先找到有几个要解压的压缩字符串
	while(tot--)//处理这些压缩
	{
		cpy=0;kp="";//cpy是复制几次，kp是复制后的字符串
		for(int i=0;i<s.size();i++)if(s[i]==']'){gty=i;break;}//先找到后括号，因为第一个后括号就是要先处理的
		for(int i=gty;i>=0;i--)if(s[i]=='['){gtx=i;break;}//再往前匹配一个前括号
		if(s[gtx+2]>='0'&&s[gtx+2]<='9')//复制两位数次（1≤d≤99）
		{
			cpy=(s[gtx+1]-48)*10+s[gtx+2]-48;//次数
			for(int i=1;i<=cpy;i++)kp+=s.substr(gtx+3,gty-gtx-3);//复制
		}
		else//复制一位数次
		{
			cpy=s[gtx+1]-48;//次数
			for(int i=1;i<=cpy;i++)kp+=s.substr(gtx+2,gty-gtx-2);//复制
            //substr不再解释，只是位置比较难算，不过要拷贝的字符有多少个，就是后坐标减前坐标再+1即可，这是常用的，可以运用在算间隔天数上之类的
		}
		if(gty!=s.size()-1)s=s.substr(0,gtx)+kp+s.substr(gty+1,s.size()-gty-1);//如果右括号不是最后一个，那就是右括号后面还有字符串
		else s=s.substr(0,gtx)+kp;//否则不用加上它
        //如果它是最后一个，那它+1就越界了，可能会错
	}
	cout<<s;
}
```

---

## 作者：z3475 (赞：3)

直说思路，利用C++里的函数递归解决问题，自行重写了读入/读出

如
AfF[4RA[2A]]

可以当成

AfF+[4RA+[2A]]

递归处理[2A]

AfF+[4RAAA]

递归处理[4RAAA]

AfFRAAARAAARAAA

上代码

```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
string a;
int post=0;
char getchar2(){return a[post++];}   //自行定义getchar 
int gi(){                            //自定义读入整数,注意读完post(位置)减一确保在数字后一位 
    int u=0;char p=getchar2();
    while (!(p>='0'&&p<='9')) p=getchar2();
    while ((p>='0'&&p<='9')) u=u*10+p-'0',p=getchar2();
    post--;
    return u;
}
string po(int u){//递归函数
    char p=getchar2();
    string yy;
    while (p!=10){
        if (p=='['){
            int l=gi();
            yy.append(po(l));
        }else
        if (p==']'){
            string o;
            for (int i=1;i<=u;i++)
                o.append(yy);
            return o;
        }else
        yy.push_back(p);
        p=getchar2();
    }
    return yy;
}
int main()
{
    cin >> a;           //开局读入一行 
    a.push_back(10);    //加入回车符表结束 
    cout << po(1);      //调用递归函数 
}
```

---

## 作者：克尔苏加德 (赞：3)


看别人都是递归的方法，我来发一手纯粹的栈吧

我们将读入依次入栈，仔细读题后发现其实除了右括号对栈有影响，其他的字符对于栈都是没有影响的。

#### 那么怎么来处理右括号呢
- 当一个右括号遇到一个右括号，就从栈顶弹出，直至弹出一个左括号为止
- 然后将中间这段的数字和字符分离开，假设分离的数字为k，分离的字符串为s1
- 再把s1按照顺序k次压入栈
- 最后只要将栈从低向上输出就可以了


------------
~~下面就是代码啦~~
```cpp
#include<iostream>
#include<cstdio>
#include<stack>

using namespace std;

stack<char> q;
string s;
char s1[20005],ss[20005];  //注意这里不能将s1,ss定义为字符串，不然会全re，我也不知道为什么，还求各位大佬帮忙解决下 
int k,k1,k2;

int main(){
	cin>>s;
	for(int i = 0; i < s.length(); i ++){
		if(s[i] == ']'){
			k1 = 0;
			while(q.top() != '['){
				k1 ++;
				s1[k1] = q.top();
				q.pop();
			}
			q.pop();
			k2 = k1;
			k = 0;
			while(s1[k2] >= '0' && s1[k2] <= '9'){
				k = k * 10 + s1[k2] - '0';
				k2 --;
			}
			for(int j = 1; j <= k; j ++)
				for(int l = k2; l > 0; l --)
					q.push(s1[l]);
		}
		else q.push(s[i]);
	}
	k = 0;
	while(!q.empty()){
		ss[k] = q.top();
		q.pop();
		k ++;
	}
	for(int i = k - 1; i >= 0; i --)
		cout<<ss[i];
	return 0;
} 
```


---

## 作者：JMercury (赞：2)

这道题我第一遍看到真是一点思路都没有，但是简单自己动手分析了一下，就是先拆里面的，再拆外面的，但是这里有一个问题，就是一个大括号内里可能会有两个小的括号，就是说有两个地方都要拆开，所以归纳“先拆里面的，再拆外面的”，就是从后面拆起，那么具体见代码了








```cpp
#include<iostream>
using namespace std;
string code;
int l[11];///记录所有左括号的位置
int tq(int p)
{
    ///算重复次数，由于重复次数在1,99间，所以只用判断左括号右边第二位是不是数就可以了
    int rpt=0;
    if(code[p+2]>='0' && code[p+2]<='9')
        rpt=(code[p+1]-'0')*10+code[p+2]-'0';
    else rpt=code[p+1]-'0';
    return rpt;
}
string Copy(int l,int r)
{
    string tmp="";
    for(int i=l; i<=r; i++)
        tmp=tmp+code[i];
    return tmp;
}
string Repeat(int l,int r,int time)
{
    ///先用Copy函数找到重复段，然后按照次数重复就可以了
    string son,big="";
    if(time<=9) son=Copy(l+1,r);
    else son=Copy(l+2,r);
    for(int t=1; t<=time; t++)
        big=big+son;
    return big;
}
int main()
{
    cin>>code; ///输入
    int num=0; ///记录左括号的个数
    for(int p=0; p<=code.size()-1; p++)
        if(code[p]=='[') l[++num]=p; ///扫原压缩信息
    for(int i=num; i>=1; i--) ///从最后一个括号解压，因为解了最后的前面就方便了
    {
        int rpt=tq(l[i]); ///提取每个压缩包中重复次数，具体见tq（提取）函数
        string str1=Copy(0,l[i]-1); ///复制下来左括号前所有代码（子串1）
        ///Copy把子串复制下来，我实在不会用什么高级函数
        ///这里我采用的方法是拼接3个字符串
        ///1.左括号前所有代码
        ///2.括号中所有代码
        ///3.右括号后所有代码
        int r=l[i];
        while(code[r]!=']') r++; ///查找右括号在哪
        string str3=Copy(r+1,code.size()-1); ///子串3
        string str2=Repeat(l[i]+1,r-1,rpt); ///生成括号内重复段，子串2，具体见Repeat函数
        ///注意这里不包括左右两端的括号了！！！
        code=str1+str2+str3; ///拼接，就算解压了1次
    }
    cout<<code; ///解压完啦，开心输出
    return 0;
}

```

---

## 作者：crowworks695 (赞：2)

分治+模拟，每次找到一个最外面的[ ]，设为边界，进行分治，然后就是生模拟了

```cpp

#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;

string s,t;

void merge(int l,int r)
{
    //printf("%d %d\n",l,r);
    int n=0;
    for(int i=l;;i++)
    {
        if(s[i]>='0'&&s[i]<='9')
        {
            n+=s[i]-'0';
            n*=10;
            l++;
        }
        else
        {
            break;
        }
    }
    n/=10;
    int cntl=0,cntr=0;
    int have=0,lx,rx;
    for(int i=1;i<=n;i++)
    {
        for(int j=l;j<=r;j++)
        {
            if(s[j]=='[')
            {
                cntl++;
                if(!have)lx=j;
                have=1;
            }
            if(s[j]==']')
            {
                cntr++;
                if(cntl==cntr)rx=j;
            }
            //printf("%d %d %d %d %d %d\n",j,cntl,cntr,have,lx,rx);
            if(!have&&s[j]!='['&&s[j]!=']')cout<<s[j];
            if(have&&cntl==cntr)
            {
                if(lx+1<rx-1)merge(lx+1,rx-1);
                have=0;
                cntl=0,cntr=0;
            }
        }
    }
}

int main()
{
    cin>>s;
    int l=0,r=0,have=0,lx,rx;
    for(int i=0;i<s.length();i++)
    {
        if(s[i]=='[')
        {
            l++;
            if(!have)lx=i;
            have=1;
        }
        if(s[i]==']')
        {
            r++;
            if(l==r)rx=i;
        }
        //printf("%d %d\n",l,r);
        if(!have&&s[i]!='['&&s[i]!=']')cout<<s[i];
        if(have&&l==r)
        {
            merge(lx+1,rx-1);
            have=0;
            l=0,r=0;
        }
    }
    return 0;
}

```

---

## 作者：yu__xuan (赞：1)

## 题目：
[P1928 外星密码](https://www.luogu.org/problem/P1928)
## 思路：
感jio自己语文好差，说不清楚，我尽量在代码中加注释吧。
## $Code:$
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<stack>
#include<algorithm>
//上面是头文件
char sss[20001];
std::string s1,s2,ans;
std::stack<int> s;
std::stack<std::string> ss;
//上面是两个栈和几个变量。
int main() {
	std::cin>>sss;
	int len=strlen(sss);
	int flag=0,x=0;//flag：如果读到一个左括号加一，如果读到一个右括号减一。用于判断在中括号内还是在中括号外，中括号是否嵌套。
	for(int i=0;i<len;++i) {//正序看一下这个字符串长什么样子。
		if(sss[i]=='[') {//读到一个左括号
			flag++;
			if(x!=0) {//如果中括号是嵌套的先把前面的压入栈中待会处理
				s.push(x);
				x=0;
			}
			if(s1!="") {//同上
				ss.push(s1);
				s1="";
			}
			continue;
		}
		if(sss[i]==']') {//读到一个右括号
			flag--;
			for(int j=1;j<=x;++j) {
				s2+=s1;
			}//算出该右括号与其对应的左括号之间展开后是什么。
			s1=s2;
			s2="";
			x=0;//将x归零
			if(flag==0) {//如果当前是左后一个右括号就直接加到答案里
				ans+=s1;
				s1="";//清空
			}else {//如果不是最后一个右括号
				x=s.top();//取出栈里的数字
				s.pop();
				if(!ss.empty()) {//取出栈里的字符串
					std::string qwq=ss.top();
					ss.pop();
					qwq=qwq+s1;//在该字符串后面接上一个。
					s1=qwq;
				}
			}
			continue;
		}
		if(sss[i]>='0'&&sss[i]<='9') {
			x=x*10+sss[i]-'0';//计算D
		}else {
			if(flag==0) ans=ans+sss[i];//如果在中括号外面就只接加到答案上。
			else s1=s1+sss[i];//如果在中括号里面就直接加到X上。
		}
	}
	std::cout<<ans<<'\n';
	return 0;
}
```
本人语文不好。。。

---

## 作者：inexistent (赞：1)

**来一发这道题的cstring版本**

看到这道题还没有cstring版本的题解。string比cstring好用很多，但是cstring可能稍微快一点吧

这道题其实是考基础

有用栈的，但是我太菜只能一轮一轮模拟。

每一轮去掉最外层的括号……直到没有[ ]为止

模拟赛的考题……调试还是很烦的……

代码：

```cpp
/*This Program is written by QiXingZhi*/
#include <cstdio>
#include <cstring>
#define  N    (2000010)
#define  ll    long long
#define  INF    (0x7f7f7f7f)
#define  read(x)    x=Rd()
#define  Max(a,b)    (((a) > (b)) ? (a) : (b))
#define  Min(a,b)    (((a) < (b)) ? (a) : (b))
#define  FILE_IN(x)    freopen(x".in","r",stdin)
using namespace std;
int n,m,len,top,d,num,beg,en;
char s[N];
char t[N];
bool Con = 0;
inline int Find_Next(int x){
	int k=0,ans=0;
	for(int i = x+1; i < len; ++i){
		if(s[i] == '['){
			++k;
			continue;
		}
		if(s[i] == ']'){
			if(k == 0){
				return i;
			}
			--k;
		}
	}
	return 0;
}
inline int get_int(int x){
	if(s[x] < '0' || s[x] > '9') return 1;
	if(s[x+1] < '0' || s[x+1] > '9') return s[x]-'0';
	return (s[x]-'0')*10+s[x+1]-'0';
}
int main(){
//	freopen("password.in","r",stdin);
//	freopen("password.out","w",stdout);
	scanf("%s",s);
	len = strlen(s);
	while(1){
		Con = top = 0;
		for(int i = 0; i < len; ++i){
			if(s[i] == '['){
				Con = 1;
				d = Find_Next(i);
				num = get_int(i+1);
				if(num == 0){
					beg = i+1;
				}
				else if(num > 9){
					beg = i+3;
				}else{
					beg = i+2;
				}
				for(int j = 0; j < num; ++j){
					for(int k = beg; k < d; ++k){
						t[top++] = s[k];
					}
				}
				i = d;
			}
			else{
				t[top++] = s[i];
			}
		}
		if(Con == 0) break;
		len = top;
		for(int i = 0; i < len; ++i) s[i] = t[i];
	}
	for(int i = 0; i < len; ++i) printf("%c", s[i]);
	return 0;
}
```

---

## 作者：HoshinoTented (赞：1)

这一道题是比较常见的 Parser 题，我曾经也写过一点 Parser，所以就用 Parser 的方式来解决这道题了。

## Parse

首先我们要解析整个密码，就需要一个函数 `parse'`：

```haskell
-- 解析 :: 密码 -> (明文, 剩余代码)
parse' :: String -> (String, String)
parse' ('[':xs) = undefined
```

但我们目前还没办法实现这个函数，先试试实现其他函数吧。

## readNumber

解析密码首先需要读取对应的数字：

```haskell
-- 解析数字 :: 数字字符串 -> 缓存区 -> (解析结果，剩余代码)
readNumber :: String -> String -> (Int, String)
readNumber [] tmp = (read $ reverse tmp, "")
readNumber (x:xs) tmp
    | isDigit x = readNumber xs (x:tmp)
    | otherwise = (read $ reverse tmp, x:xs)
```

由于用的是 `(x:tmp)` 而不是 `(tmp ++ [x])`（为了节约时间），所以需要在结束的时候用 `reverse` 函数将字符串翻转再进行 `read`。

## readString

接下来就要解析字符串了：

```haskell
-- 解析字符串 :: 字符串 -> 缓存区 -> (解析结果，剩余代码)
readString :: String -> String -> (String, String)
readString [] tmp = (tmp, "")		-- 如果字符串为空，返回缓存区的内容
readString ('[':xs) tmp = let (sub, remain) = parse' ('[':xs) in readString remain (sub ++ tmp)		-- 如果是 '[' 开头，说明是新的压缩区，使用 parse' 函数进行解析
readString (']':xs) tmp = (tmp, xs)	  -- 如果是 ']'，说明已经到达结尾，返回缓存区内容和剩余代码
readString (x:xs) tmp = readString xs (x:tmp)  		-- 如果都不是，则继续循环（递归）
```

## Parse!

有了 `readNumber` 和 `readString`，就可以实现 `parse'` 函数了：

```haskell
-- 解析 :: 密码 -> (明文，剩余代码)
parse' :: String -> (String, String)
parse' ('[':xs) = let			-- 如果是 '[' 开头，则进行解析
    (count, remain) = readNumber xs ""		-- 先读取数字
    (str, remain') = readString remain "" in		-- 再读取字符串
        ([1..count] >> str, remain')		-- 最后将字符串都连接起来，返回剩余代码
```

在 GHCi 中测试一下，发现返回的字符串是倒序的：

```haskell
*P1928> readString "AC[3FUN]" ""
("NUFNUFNUFCA","")
```

所以再写一个辅助函数：

```haskell
parse :: String -> String
parse = reverse . fst . flip readString ""
```

## Main

最后补全 `main` 函数：

```haskell
main :: IO ()
main = do
    str <- getLine

    putStrLn $ parse str
```

AC 啦！

## State Monad

代码中有许多形如 `s-> (a, s)` 的函数签名，理论上可以用 State Monad 进行优化，但是我太懒了，就没优化。

---


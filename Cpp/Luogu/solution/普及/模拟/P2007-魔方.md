# 魔方

## 题目背景

常神牛从来没接触过魔方，所以他要借助计算机来玩。即使是这样，他还是很菜。


## 题目描述

常神牛家的魔方都是3\*3\*3的三阶魔方，大家都见过。

 ![](https://cdn.luogu.com.cn/upload/pic/1002.png) 

（更正：3 4以图为准。）

作为一名菜鸟，常神牛从网上搜了一篇攻略，并找人翻译成了他自己会做的方法。现在告诉你他的魔方情况，以及他从网上搜到的攻略，请你求出最后魔方变成什么样子。


## 说明/提示

【样例解释】

 ![](https://cdn.luogu.com.cn/upload/pic/1047.png) 

![](https://cdn.luogu.com.cn/upload/pic/1048.png)


## 样例 #1

### 输入

```
23
121
221
111
123
321
111
123
321
132
132
231
132
121
112
233
332
111
333```

### 输出

```
123
222
113
212
321
113
122
321
132
121
333
121
211
312
113
331
111
331```

# 题解

## 作者：kkksc03 (赞：26)

这题主要是理解，经过分析后，我们可以把六个面分别表示为3\*3的二维数组，并用1,2,3,4,5,6分别表示前、后、左、右、上、下，也就是一个6\*3\*3的三维数组。这样，得到以下四种模型：

操作1：

```cpp
　　for i:=1 to 3 do
　　begin
　　b[1,i,3]:=a[6,i,3];
　　b[6,i,3]:=a[2,i,3];
　　b[2,i,3]:=a[5,i,3];
　　b[5,i,3]:=a[1,i,3];
　　end;
　　for i:=1 to 3 do
　　  for j:=1 to 3 do
　　  b[4,j,4-i]:=a[4,i,j];
```
其中a是转换前的，b是转换后的。下面的是一个意思。
操作2：

```cpp
　　for i:=1 to 3 do
　　begin
　　b[1,i,3]:=a[5,i,3];
　　b[5,i,3]:=a[2,i,3];
　　b[2,i,3]:=a[6,i,3];
　　b[6,i,3]:=a[1,i,3];
　　end;
　　for i:=1 to 3 do
　　  for j:=1 to 3 do
　　  b[4,4-j,i]:=a[4,i,j];
```
操作3：
```cpp
　　for i:=1 to 3 do
　　begin
　　b[1,1,i]:=a[3,1,i];
　　b[3,1,i]:=a[2,1,i];
　　b[2,1,i]:=a[4,1,i];
　　b[4,1,i]:=a[1,1,i];
　　end;
　　for i:=1 to 3 do
　　  for j:=1 to 3 do
　　  b[5,j,4-i]:=a[5,i,j];
```
操作4：
```cpp
　　for i:=1 to 3 do
　　begin
　　b[1,1,i]:=a[4,1,i];
　　b[4,1,i]:=a[2,1,i];
　　b[2,1,i]:=a[3,1,i];
　　b[3,1,i]:=a[1,1,i];
　　end;
　　for i:=1 to 3 do
　　  for j:=1 to 3 do
　　  b[5,4-j,i]:=a[5,i,j];
当然，自己手边有个魔方的话，很容易发现这个规律，没有的话也可以看样例自己找。
```

---

## 作者：Alarm5854 (赞：14)

这道题目太坑了，操作3和操作4的顶层竟然是倒着转的，不合常理，而且题目描述也有坑，真正的正解却只能拿部分分，希望管理员能改一下数据。

这道题目的思维难度为橙色，代码难度为蓝色(个人认为)。所以，打代码的时候不要怕麻烦，本题解较长，请做好心理准备。

接下来的做法为了让大家能看懂，我会放几张图片，背景的颜色和数字如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/c2b2jmt3.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/mqml6oxy.png)

### 操作1：
前面的最后一列转到上面的最后一列；后面的最后一列转到下面的最后一列；上面的最后一列转到后面的最后一列；下面的最后一列转到前面的最后一列。右面沿顺时针转90度。

![](https://cdn.luogu.com.cn/upload/image_hosting/qnsvuid7.png)

### 操作2：
前面的最后一列转到下面的最后一列；后面的最后一列转到前面的最后一列；上面的最后一列转到前面的最后一列；下面的最后一列转到后面的最后一列。右面沿逆时针转90度。

![](https://cdn.luogu.com.cn/upload/image_hosting/7st6zcqs.png)

### 操作3：
前面的第一行转到右面的第一行；后面的第一行转到左面的第一行；左面的第一行转到前面的第一行；右面的第一行转到后面的第一行。上面沿顺时针(样例和数据有锅，真正的正解应为逆时针)旋转90度。

本题正解：
![](https://cdn.luogu.com.cn/upload/image_hosting/yg9sgicp.png)

真正正解：
![](https://cdn.luogu.com.cn/upload/image_hosting/j8fki3hs.png)

### 操作4：
前面的第一行转到左面的第一行；后面的第一行转到右面的第一行；左面的第一行转到后面的第一行；右面的第一行转到前面的第一行。上面沿逆时针(样例和数据有锅，真正的正解应为顺时针)旋转90度。

本题正解：
![](https://cdn.luogu.com.cn/upload/image_hosting/y4z1pcr2.png)

真正正解：
![](https://cdn.luogu.com.cn/upload/image_hosting/rsl6r6dg.png)

### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[6][3][3],b[6][3][3];//a数组为原来的魔方,b数组为更改过的临时魔方。第一维表示哪个面，第二维表示哪行，第三维表示那列。
char s[101];
int main(){
//	freopen("cube.in","r",stdin);
//	freopen("cube.out","w",stdout);
	scanf("%s",s);
	for(int i=0;i<6;++i)
		for(int j=0;j<3;++j)
			for(int k=0;k<3;++k)
				scanf("%1d",a[i][j]+k);
	for(int i=0;i<strlen(s);++i){
		switch(s[i]){
			case '1'://别数了，下面42行赋值语句
            	//接下来21行，为把原来的位置的转移到临时位置
				b[0][0][2]=a[5][0][2];//第一维中0表示前面，5表示下面，这里表示下面的方块转到前面来
				b[0][1][2]=a[5][1][2];
				b[0][2][2]=a[5][2][2];
				b[1][0][2]=a[4][0][2];//第一维中1表示后面，4表示上面，这里表示上面的方块转到后面来
				b[1][1][2]=a[4][1][2];
				b[1][2][2]=a[4][2][2];
				b[3][0][2]=a[3][0][0];//第一维中3表示右面，这里不解释了，有图应该看到懂。同样，第一维中2表示左面
				b[3][1][2]=a[3][0][1];
				b[3][2][2]=a[3][0][2];
				b[3][0][1]=a[3][1][0];
				b[3][1][1]=a[3][1][1];
				b[3][2][1]=a[3][1][2];
				b[3][0][0]=a[3][2][0];
				b[3][1][0]=a[3][2][1];
				b[3][2][0]=a[3][2][2];
				b[4][0][2]=a[0][0][2];
				b[4][1][2]=a[0][1][2];
				b[4][2][2]=a[0][2][2];
				b[5][0][2]=a[1][0][2];
				b[5][1][2]=a[1][1][2];
				b[5][2][2]=a[1][2][2];
                //接下来21行，为把临时位置转移到原来位置
				a[0][0][2]=b[0][0][2];
				a[0][1][2]=b[0][1][2];
				a[0][2][2]=b[0][2][2];
				a[1][0][2]=b[1][0][2];
				a[1][1][2]=b[1][1][2];
				a[1][2][2]=b[1][2][2];
				a[3][0][2]=b[3][0][2];
				a[3][1][2]=b[3][1][2];
				a[3][2][2]=b[3][2][2];
				a[3][0][1]=b[3][0][1];
				a[3][1][1]=b[3][1][1];
				a[3][2][1]=b[3][2][1];
				a[3][0][0]=b[3][0][0];
				a[3][1][0]=b[3][1][0];
				a[3][2][0]=b[3][2][0];
				a[4][0][2]=b[4][0][2];
				a[4][1][2]=b[4][1][2];
				a[4][2][2]=b[4][2][2];
				a[5][0][2]=b[5][0][2];
				a[5][1][2]=b[5][1][2];
				a[5][2][2]=b[5][2][2];
				break;
			case '2':
				b[0][0][2]=a[4][0][2];
				b[0][1][2]=a[4][1][2];
				b[0][2][2]=a[4][2][2];
				b[1][0][2]=a[5][0][2];
				b[1][1][2]=a[5][1][2];
				b[1][2][2]=a[5][2][2];
				b[3][2][0]=a[3][0][0];
				b[3][1][0]=a[3][0][1];
				b[3][0][0]=a[3][0][2];
				b[3][2][1]=a[3][1][0];
				b[3][1][1]=a[3][1][1];
				b[3][0][1]=a[3][1][2];
				b[3][2][2]=a[3][2][0];
				b[3][1][2]=a[3][2][1];
				b[3][0][2]=a[3][2][2];
				b[4][0][2]=a[1][0][2];
				b[4][1][2]=a[1][1][2];
				b[4][2][2]=a[1][2][2];
				b[5][0][2]=a[0][0][2];
				b[5][1][2]=a[0][1][2];
				b[5][2][2]=a[0][2][2];
				a[0][0][2]=b[0][0][2];
				a[0][1][2]=b[0][1][2];
				a[0][2][2]=b[0][2][2];
				a[1][0][2]=b[1][0][2];
				a[1][1][2]=b[1][1][2];
				a[1][2][2]=b[1][2][2];
				a[3][0][2]=b[3][0][2];
				a[3][1][2]=b[3][1][2];
				a[3][2][2]=b[3][2][2];
				a[3][0][1]=b[3][0][1];
				a[3][1][1]=b[3][1][1];
				a[3][2][1]=b[3][2][1];
				a[3][0][0]=b[3][0][0];
				a[3][1][0]=b[3][1][0];
				a[3][2][0]=b[3][2][0];
				a[4][0][2]=b[4][0][2];
				a[4][1][2]=b[4][1][2];
				a[4][2][2]=b[4][2][2];
				a[5][0][2]=b[5][0][2];
				a[5][1][2]=b[5][1][2];
				a[5][2][2]=b[5][2][2];
				break;
			case '3':
				b[0][0][0]=a[2][0][0];
				b[0][0][1]=a[2][0][1];
				b[0][0][2]=a[2][0][2];
				b[1][0][0]=a[3][0][0];
				b[1][0][1]=a[3][0][1];
				b[1][0][2]=a[3][0][2];
				b[2][0][0]=a[1][0][0];
				b[2][0][1]=a[1][0][1];
				b[2][0][2]=a[1][0][2];
				b[3][0][0]=a[0][0][0];
				b[3][0][1]=a[0][0][1];
				b[3][0][2]=a[0][0][2];
				b[4][0][2]=a[4][0][0];//本题正确的代码
				b[4][1][2]=a[4][0][1];
				b[4][2][2]=a[4][0][2];
				b[4][0][1]=a[4][1][0];
				b[4][1][1]=a[4][1][1];
				b[4][2][1]=a[4][1][2];
				b[4][0][0]=a[4][2][0];
				b[4][1][0]=a[4][2][1];
				b[4][2][0]=a[4][2][2];
                /*真正正确的代码
				b[4][2][0]=a[4][0][0];
				b[4][1][0]=a[4][0][1];
				b[4][0][0]=a[4][0][2];
				b[4][2][1]=a[4][1][0];
				b[4][1][1]=a[4][1][1];
				b[4][0][1]=a[4][1][2];
				b[4][2][2]=a[4][2][0];
				b[4][1][2]=a[4][2][1];
				b[4][0][2]=a[4][2][2];
                */
				a[0][0][0]=b[0][0][0];
				a[0][0][1]=b[0][0][1];
				a[0][0][2]=b[0][0][2];
				a[1][0][0]=b[1][0][0];
				a[1][0][1]=b[1][0][1];
				a[1][0][2]=b[1][0][2];
				a[2][0][0]=b[2][0][0];
				a[2][0][1]=b[2][0][1];
				a[2][0][2]=b[2][0][2];
				a[3][0][0]=b[3][0][0];
				a[3][0][1]=b[3][0][1];
				a[3][0][2]=b[3][0][2];
				a[4][0][2]=b[4][0][2];
				a[4][1][2]=b[4][1][2];
				a[4][2][2]=b[4][2][2];
				a[4][0][1]=b[4][0][1];
				a[4][1][1]=b[4][1][1];
				a[4][2][1]=b[4][2][1];
				a[4][0][0]=b[4][0][0];
				a[4][1][0]=b[4][1][0];
				a[4][2][0]=b[4][2][0];
				break;
			case '4':
				b[0][0][0]=a[3][0][0];
				b[0][0][1]=a[3][0][1];
				b[0][0][2]=a[3][0][2];
				b[1][0][0]=a[2][0][0];
				b[1][0][1]=a[2][0][1];
				b[1][0][2]=a[2][0][2];
				b[2][0][0]=a[0][0][0];
				b[2][0][1]=a[0][0][1];
				b[2][0][2]=a[0][0][2];
				b[3][0][0]=a[1][0][0];
				b[3][0][1]=a[1][0][1];
				b[3][0][2]=a[1][0][2];
				b[4][2][0]=a[4][0][0];//本题正确的代码
				b[4][1][0]=a[4][0][1];
				b[4][0][0]=a[4][0][2];
				b[4][2][1]=a[4][1][0];
				b[4][1][1]=a[4][1][1];
				b[4][0][1]=a[4][1][2];
				b[4][2][2]=a[4][2][0];
				b[4][1][2]=a[4][2][1];
				b[4][0][2]=a[4][2][2];
                /*真正正确的代码
				b[4][0][2]=a[4][0][0];
				b[4][1][2]=a[4][0][1];
				b[4][2][2]=a[4][0][2];
				b[4][0][1]=a[4][1][0];
				b[4][1][1]=a[4][1][1];
				b[4][2][1]=a[4][1][2];
				b[4][0][0]=a[4][2][0];
				b[4][1][0]=a[4][2][1];
				b[4][2][0]=a[4][2][2];
                */
				a[0][0][0]=b[0][0][0];
				a[0][0][1]=b[0][0][1];
				a[0][0][2]=b[0][0][2];
				a[1][0][0]=b[1][0][0];
				a[1][0][1]=b[1][0][1];
				a[1][0][2]=b[1][0][2];
				a[2][0][0]=b[2][0][0];
				a[2][0][1]=b[2][0][1];
				a[2][0][2]=b[2][0][2];
				a[3][0][0]=b[3][0][0];
				a[3][0][1]=b[3][0][1];
				a[3][0][2]=b[3][0][2];
				a[4][0][2]=b[4][0][2];
				a[4][1][2]=b[4][1][2];
				a[4][2][2]=b[4][2][2];
				a[4][0][1]=b[4][0][1];
				a[4][1][1]=b[4][1][1];
				a[4][2][1]=b[4][2][1];
				a[4][0][0]=b[4][0][0];
				a[4][1][0]=b[4][1][0];
				a[4][2][0]=b[4][2][0];
				break;
		}
	}
	for(int i=0;i<6;++i)
		for(int j=0;j<3;++j){
			for(int k=0;k<3;++k)
				printf("%d",a[i][j][k]);//输出，注意没有空格
			puts("");
		}
	return 0;
}
```
祝你们早日A掉这一到毒瘤题目!

---

## 作者：KThompson (赞：4)

看了看题解发现没有一维数组纯手打的
~~于是我决定来分享一个~~

首先我们需要搞定的是输入问题
可以使用 cin>>a 直接输入  ~~我当时脑子卡了用的字符串~~

然后就是处理问题 像我这种蒟蒻就只有用6个循环来存每一个面
通过先取那个三位数的个位,然后消掉个位的方法来存储每一位，六个循环对应六个面。
```cpp
	
for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			q[++js]=xx%10;
			xx/=10;
		}
	}
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			h[++js]=xx%10;
			xx/=10;
		}
	}
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			l[++js]=xx%10;
			xx/=10;
		}
	}
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			r[++js]=xx%10;
			xx/=10;
		}
	}
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			s[++js]=xx%10;
			xx/=10;
		}
	}
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			x[++js]=xx%10;
			xx/=10;
		}
	
  }
```
但是这样存的话 魔方是这样的


3 2 1

6 5 4

9 8 7

对应数组地址


然后在通过手打步骤指令来完成代码即可（注意step1转三次就是step2，同理step3和step4）

在草稿纸上演算指令 可以得到以下信息。
step1中右面
3 2 1                 

6 5 4            

9 8 7
变成
9 6 3

8 5 2

7 4 1

其余4个面（除了左面 都是依次取代）

step3中

3 2 1

6 5 4

9 8 7

变成

9 6 3

8 5 2

7 4 1

其余四个面都是依次取代

以下是完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char zl[105];//存指令
//long long step;
int a;//计数 
int xx;//存每一个面每一行的值
int js;//存数组的计数器
int len;//字符串长度
int q[10];//前 
int h[10];//后
int l[10];//左
int r[10];//右
int s[10];//上
int x[10];//下 
int js1;//
int js2;//这是依次取代三面的计数器
int js3;//
int js4;//旋转面的取代
int js5;//
void step1()//步骤一 （与步骤二）
{
	js1=q[1];
	js2=q[4];
	js3=q[7];
	
	q[1]=x[1];
	q[4]=x[4];
	q[7]=x[7];
	
	x[1]=h[1];
	x[4]=h[4];
	x[7]=h[7];
	
	h[1]=s[1];
	h[4]=s[4];
	h[7]=s[7];
	
	s[1]=js1;
	s[4]=js2;
	s[7]=js3;
	
	js4=r[7];
	r[7]=r[1];
	r[1]=r[3];
	r[3]=r[9];
	r[9]=js4;
	
	js5=r[8];
	r[8]=r[4];
	r[4]=r[2];
	r[2]=r[6];
	r[6]=js5;
}

void step3()//步骤三
{
	js1=q[3];
	js2=q[2];
	js3=q[1];
	
	q[3]=l[3];
	q[2]=l[2];
	q[1]=l[1];
	
	l[3]=h[3];
	l[2]=h[2];
	l[1]=h[1];
	
	h[3]=r[3];
	h[2]=r[2];
	h[1]=r[1];
	
	r[3]=js1;
	r[2]=js2;
	r[1]=js3;
	
//	js4=s[7];
//	s[7]=s[9];
//	s[9]=s[3];
//	s[3]=s[1];
//	s[1]=js4;
//	
//	js5=s[8];
//	s[8]=s[6];
//	s[6]=s[2];
//	s[2]=s[4];
//	s[4]=js5;

	js4=s[7];
	s[7]=s[1];
	s[1]=s[3];
	s[3]=s[9];
	s[9]=js4;
	
	js5=s[8];
	s[8]=s[4];
	s[4]=s[2];
	s[2]=s[6];
	s[6]=js5;
}

int main()
{
	freopen("cube.in","r",stdin);
	freopen("cube.out","w",stdout);
	gets(zl);//存指令
	len=strlen(zl);

	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			q[++js]=xx%10;
			xx/=10;
		}
	}//存前面
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			h[++js]=xx%10;
			xx/=10;
		}
	}//存后面
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			l[++js]=xx%10;
			xx/=10;
		}
	}//存左面
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			r[++js]=xx%10;
			xx/=10;
		}
	}//存右面
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			s[++js]=xx%10;
			xx/=10;
		}
	}//存上面
	js=0;
	for(int i=1;i<=3;i++)
	{
		cin>>xx;
		while(xx!=0)
		{
			x[++js]=xx%10;
			xx/=10;
		}
	}//存下面
	
	for(int i=0;i<len;i++)
	{
		if(zl[i]-'0'==1)
			step1();//如果是第一步 使用step1函数
		if(zl[i]-'0'==2)
		{
			step1();//第二步就等于第一步走三次
			step1();
			step1();
		}
		if(zl[i]-'0'==3)
		{
			step3();//第三步
		}
		if(zl[i]-'0'==4)
		{
			step3();//第四步
			step3();
			step3();
		}
	}
//最后按照顺序打出每一面
	for(int i=3;i>=1;i--)
	cout<<q[i];
	cout<<endl;
	for(int i=6;i>=4;i--)
	cout<<q[i];
	cout<<endl;
	for(int i=9;i>=7;i--)
	cout<<q[i];
	cout<<endl;
	 
	for(int i=3;i>=1;i--)
	cout<<h[i];
	cout<<endl;
	for(int i=6;i>=4;i--)
	cout<<h[i];
	cout<<endl;
	for(int i=9;i>=7;i--)
	cout<<h[i];
	cout<<endl; 
	
	for(int i=3;i>=1;i--)
	cout<<l[i];
	cout<<endl;
	for(int i=6;i>=4;i--)
	cout<<l[i];
	cout<<endl;
	for(int i=9;i>=7;i--)
	cout<<l[i];
	cout<<endl;
	
	for(int i=3;i>=1;i--)
	cout<<r[i];
	cout<<endl;
	for(int i=6;i>=4;i--)
	cout<<r[i];
	cout<<endl;
	for(int i=9;i>=7;i--)
	cout<<r[i];
	cout<<endl;
	
	for(int i=3;i>=1;i--)
	cout<<s[i];
	cout<<endl;
	for(int i=6;i>=4;i--)
	cout<<s[i];
	cout<<endl;
	for(int i=9;i>=7;i--)
	cout<<s[i];
	cout<<endl;
	
	for(int i=3;i>=1;i--)
	cout<<x[i];
	cout<<endl;
	for(int i=6;i>=4;i--)
	cout<<x[i];
	cout<<endl;
	for(int i=9;i>=7;i--)
	cout<<x[i];
	
	//fclose(stdin);
	//fclose(stdout);
	return 0;
}
```



---

## 作者：Bbaka (赞：4)

这一题真的很考验耐心和细心，如果家里有魔方的话可以拿家里的魔方自己试一试，如果没有也可以手动在草稿纸上推一下，主要是理清楚相邻两面在旋转时棱块和角块如何变动，再来就是耐心把代码写出来吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
char magic[6][3][3]; //定义一个魔方，6表示六个面，第一个3表示每一面的行数，后一个3表示每一面的列 
char move[102]; //输入移动方法 
int main(){
	scanf("%s",&move); //输入步数 
	for(int i=0;i<6;++i) //输入魔方 
		for(int j=0;j<3;++j)
			for(int k=0;k<3;++k)
				cin>>magic[i][j][k];
				
	int len=strlen(move); 
	
	for(int i=0;i<len;++i){ //进行每一步操作 
		if(move[i]=='1'){ //操作一
			char a,b,c;
			//右边一列的旋转,方式为下面的右侧移动到前面的右侧 前面的右侧移动到上面的右侧
			//上面的右侧移动到后面的右侧 后面的右侧移动到下面的右侧 
			a=magic[0][0][2]; 
			b=magic[0][1][2];
			c=magic[0][2][2];
			
			magic[0][0][2]=magic[5][0][2];
			magic[0][1][2]=magic[5][1][2];
			magic[0][2][2]=magic[5][2][2];
			
			magic[5][0][2]=magic[1][0][2];
			magic[5][1][2]=magic[1][1][2];
			magic[5][2][2]=magic[1][2][2];
			
			magic[1][0][2]=magic[4][0][2];
			magic[1][1][2]=magic[4][1][2];
			magic[1][2][2]=magic[4][2][2];
	
			magic[4][0][2]=a;
			magic[4][1][2]=b;
			magic[4][2][2]=c;
			//注意旋转时侧面也会旋转
			//而且是左上移动到右上 右上到右下 右下到左下 左下到右上
			//上层的棱块到右侧 右侧棱块到下层 下层棱块到左侧 左侧棱块到上层 
			a=magic[3][0][0];   
			magic[3][0][0]=magic[3][2][0];
			magic[3][2][0]=magic[3][2][2];
			magic[3][2][2]=magic[3][0][2];
			magic[3][0][2]=a;
			a=magic[3][0][1];
			magic[3][0][1]=magic[3][1][0];
			magic[3][1][0]=magic[3][2][1];
			magic[3][2][1]=magic[3][1][2];
			magic[3][1][2]=a;
		}
		else if(move[i]=='2'){ //操作二 
			char a,b,c;
			//右边一列的旋转,方式为下面的右侧移动到后面的右侧 后面的右侧移动到上面的右侧
			//上面的右侧移动到前面的右侧 前面的右侧移动到下面的右侧 
			a=magic[0][0][2]; 
			b=magic[0][1][2];
			c=magic[0][2][2];
			
			magic[0][0][2]=magic[4][0][2];
			magic[0][1][2]=magic[4][1][2];
			magic[0][2][2]=magic[4][2][2];
			
			magic[4][0][2]=magic[1][0][2];
			magic[4][1][2]=magic[1][1][2];
			magic[4][2][2]=magic[1][2][2];
			
			magic[1][0][2]=magic[5][0][2];
			magic[1][1][2]=magic[5][1][2];
			magic[1][2][2]=magic[5][2][2];
	
			magic[5][0][2]=a;
			magic[5][1][2]=b;
			magic[5][2][2]=c;
			//注意旋转时侧面也会旋转
			//而且是左上移动到左下 左下到右下 右下到右上 右上到左上 
			//上层的棱块到左侧 左侧棱块到下层 下层棱块到右侧 右侧棱块到上层 
			a=magic[3][0][0];   
			magic[3][0][0]=magic[3][0][2];
			magic[3][0][2]=magic[3][2][2];
			magic[3][2][2]=magic[3][2][0];
			magic[3][2][0]=a;
			b=magic[3][0][1];
			magic[3][0][1]=magic[3][1][2];
			magic[3][1][2]=magic[3][2][1];
			magic[3][2][1]=magic[3][1][0];
			magic[3][1][0]=b;
		}
		else if(move[i]=='3'){ //操作三 
			char a,b,c;
			//上面一层的旋转,方式为前面的上层移动到左面的上层 左面的上层移动到后面的上层 
			//后面的上层移动到右面的上层 右面的上层移动到前面的上层 
			a=magic[0][0][0]; 
			b=magic[0][0][1];
			c=magic[0][0][2];
			
			magic[0][0][0]=magic[2][0][0];
			magic[0][0][1]=magic[2][0][1];
			magic[0][0][2]=magic[2][0][2];
			
			magic[2][0][0]=magic[1][0][0];
			magic[2][0][1]=magic[1][0][1];
			magic[2][0][2]=magic[1][0][2];
			
			magic[1][0][0]=magic[3][0][0];
			magic[1][0][1]=magic[3][0][1];
			magic[1][0][2]=magic[3][0][2];
	
			magic[3][0][0]=a;
			magic[3][0][1]=b;
			magic[3][0][2]=c;
			//注意旋转时顶层也会旋转
			//而且是左上移动到右上 右上到右下 右下到左下 左下到右上
			//上层的棱块到右侧 右侧棱块到下层 下层棱块到左侧 左侧棱块到上层 
			a=magic[4][0][0];  
			magic[4][0][0]=magic[4][2][0];
			magic[4][2][0]=magic[4][2][2];
			magic[4][2][2]=magic[4][0][2];
			magic[4][0][2]=a;
			b=magic[4][0][1];
			magic[4][0][1]=magic[4][1][0];
			magic[4][1][0]=magic[4][2][1];
			magic[4][2][1]=magic[4][1][2];
			magic[4][1][2]=b;
		}
		else if(move[i]=='4'){ //操作四 
			char a,b,c;
			//上面一层的旋转,方式为前面的上层移动到右面的上层 右面的上层移动到后面的上层 
			//后面的上层移动到左面的上层 左面的上层移动到前面的上层 
			a=magic[0][0][0];  
			b=magic[0][0][1];
			c=magic[0][0][2];
			
			magic[0][0][0]=magic[3][0][0];
			magic[0][0][1]=magic[3][0][1];
			magic[0][0][2]=magic[3][0][2];
			
			magic[3][0][0]=magic[1][0][0];
			magic[3][0][1]=magic[1][0][1];
			magic[3][0][2]=magic[1][0][2];
			
			magic[1][0][0]=magic[2][0][0];
			magic[1][0][1]=magic[2][0][1];
			magic[1][0][2]=magic[2][0][2];
	
			magic[2][0][0]=a;
			magic[2][0][1]=b;
			magic[2][0][2]=c;
			//注意旋转时顶层也会旋转 
			//而且是左上移动到左下 左下到右下 右下到右上 右上到左上 
			//上层的棱块到左侧 左侧棱块到下层 下层棱块到右侧 右侧棱块到上层 
			a=magic[4][0][0]; 
			magic[4][0][0]=magic[4][0][2];
			magic[4][0][2]=magic[4][2][2];
			magic[4][2][2]=magic[4][2][0];
			magic[4][2][0]=a;
			b=magic[4][0][1];
			magic[4][0][1]=magic[4][1][2];
			magic[4][1][2]=magic[4][2][1];
			magic[4][2][1]=magic[4][1][0];
			magic[4][1][0]=b;
		}
	}
	for(int i=0;i<6;++i) //输出 
		for(int j=0;j<3;++j){
			for(int k=0;k<3;++k)
				printf("%c",magic[i][j][k]);
				printf("\n");
		}
	return 0;
}
```

写完后自己再检验一下，因为代码可能很长就很容易出错，最后祝大家可以通过这一题


---

## 作者：cjZYZtcl (赞：3)

# 纯打表
### 这道题有4种操作：
1.上、下、前、后四面的第三列向上交换；右面顺时针旋转。

2.上、下、前、后四面的第三列向下交换；右面逆时针旋转。

3.左、右、前、后四面的第一行向左交换；上面顺时针旋转。

4.左、右、前、后四面的第一行向右交换；上面逆时针旋转。


### 直接模拟


# **为什么会标成 普及/提高- ？！**

## 代码奉上：

```pascal
var
  s:string;
  i,x,y:longint;
  x1,y1,z1:char;
  a:array[0..7,0..4,0..4]of char;
begin
  readln(s);
  for i:=1 to 6 do
  begin
    for x:=1 to 3 do
    begin
      for y:=1 to 3 do read(a[i,x,y]);
      readln;
    end;
  end;
  for i:=1 to length(s) do
  begin
    case s[i] of
      '1':begin
            x1:=a[1,1,3]; y1:=a[1,2,3]; z1:=a[1,3,3];
            a[1,1,3]:=a[6,1,3];
            a[1,2,3]:=a[6,2,3];
            a[1,3,3]:=a[6,3,3];
            a[6,1,3]:=a[2,1,3];
            a[6,2,3]:=a[2,2,3];
            a[6,3,3]:=a[2,3,3];
            a[2,1,3]:=a[5,1,3];
            a[2,2,3]:=a[5,2,3];
            a[2,3,3]:=a[5,3,3];
            a[5,1,3]:=x1;
            a[5,2,3]:=y1;
            a[5,3,3]:=z1;
            x1:=a[4,1,3]; y1:=a[4,2,3];
            a[4,1,3]:=a[4,1,1]; a[4,2,3]:=a[4,1,2];
            a[4,1,1]:=a[4,3,1]; a[4,1,2]:=a[4,2,1];
            a[4,3,1]:=a[4,3,3]; a[4,2,1]:=a[4,3,2];
            a[4,3,3]:=x1; a[4,3,2]:=y1;
          end;
      '2':begin
            x1:=a[1,1,3]; y1:=a[1,2,3]; z1:=a[1,3,3];
            a[1,1,3]:=a[5,1,3];
            a[1,2,3]:=a[5,2,3];
            a[1,3,3]:=a[5,3,3];
            a[5,1,3]:=a[2,1,3];
            a[5,2,3]:=a[2,2,3];
            a[5,3,3]:=a[2,3,3];
            a[2,1,3]:=a[6,1,3];
            a[2,2,3]:=a[6,2,3];
            a[2,3,3]:=a[6,3,3];
            a[6,1,3]:=x1;
            a[6,2,3]:=y1;
            a[6,3,3]:=z1;
            x1:=a[4,1,3]; y1:=a[4,2,3];
            a[4,1,3]:=a[4,3,3]; a[4,2,3]:=a[4,3,2];
            a[4,3,3]:=a[4,3,1]; a[4,3,2]:=a[4,2,1];
            a[4,3,1]:=a[4,1,1]; a[4,2,1]:=a[4,1,2];
            a[4,1,1]:=x1; a[4,1,2]:=y1;
          end;
      '3':begin
            x1:=a[1,1,1]; y1:=a[1,1,2]; z1:=a[1,1,3];
            a[1,1,1]:=a[3,1,1];
            a[1,1,2]:=a[3,1,2];
            a[1,1,3]:=a[3,1,3];
            a[3,1,1]:=a[2,1,1];
            a[3,1,2]:=a[2,1,2];
            a[3,1,3]:=a[2,1,3];
            a[2,1,1]:=a[4,1,1];
            a[2,1,2]:=a[4,1,2];
            a[2,1,3]:=a[4,1,3];
            a[4,1,1]:=x1;
            a[4,1,2]:=y1;
            a[4,1,3]:=z1;
            x1:=a[5,1,3]; y1:=a[5,2,3];
            a[5,1,3]:=a[5,1,1]; a[5,2,3]:=a[5,1,2];
            a[5,1,1]:=a[5,3,1]; a[5,1,2]:=a[5,2,1];
            a[5,3,1]:=a[5,3,3]; a[5,2,1]:=a[5,3,2];
            a[5,3,3]:=x1; a[5,3,2]:=y1;
          end;
      '4':begin
            x1:=a[1,1,1]; y1:=a[1,1,2]; z1:=a[1,1,3];
            a[1,1,1]:=a[4,1,1];
            a[1,1,2]:=a[4,1,2];
            a[1,1,3]:=a[4,1,3];
            a[4,1,1]:=a[2,1,1];
            a[4,1,2]:=a[2,1,2];
            a[4,1,3]:=a[2,1,3];
            a[2,1,1]:=a[3,1,1];
            a[2,1,2]:=a[3,1,2];
            a[2,1,3]:=a[3,1,3];
            a[3,1,1]:=x1;
            a[3,1,2]:=y1;
            a[3,1,3]:=z1;
            x1:=a[5,1,3]; y1:=a[5,2,3];
            a[5,1,3]:=a[5,3,3]; a[5,2,3]:=a[5,3,2];
            a[5,3,3]:=a[5,3,1]; a[5,3,2]:=a[5,2,1];
            a[5,3,1]:=a[5,1,1]; a[5,2,1]:=a[5,1,2];
            a[5,1,1]:=x1; a[5,1,2]:=y1;
          end;
    end;
  end;
  for i:=1 to 6 do
    for x:=1 to 3 do
    begin
      for y:=1 to 3 do write(a[i,x,y]);
      writeln;
    end;
end.
```


---


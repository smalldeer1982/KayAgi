# bf

## 题目描述

bf 是一种编程语言，全称为 BrainFuck，因为题目名称不能太露骨，所以就简写成 bf 了。

这种语言的运行机制十分简单，只有一个大小为 $30000$ 的有符号 $8$ 位整数（范围 $[-128,127]$ ）的内存槽，和一个指向内存槽中位置的指针，在最初的时候指向内存槽的第一个整数。

这种语言的字符集也是十分的简单，只有`+ - , . > < []`。

```cpp
字符|意义
< 　|指针所指向的内存地址减一。
> 　|指针所指向的内存地址加一。
+ 　|指针所指向的内存里面的数值加一。
- 　|指针所指向的内存里面的数值减一。
. 　|输出当前指针所指向的内存里面的数值（以字符形式输出）。
, 　|将读入缓冲区中的一个字节送入当前指针指向的内存里面。如果读入缓冲区为空则送入-1。
[ 　|当前指针指向的内存里面的数值不为0时，重复执行与之相匹配的]之间的语句，直到回到[时当前指针指向的内存中的数值为0。
] 　|如上。
```

## 说明/提示

对于 $10\%$ 的数据，没有循环。

对于另外 $10\%$ 的数据，循环没有嵌套。

对于 $100\%$ 的数据，输入的程序不会访问越界，输入的程序能够在 $10^6$ 步内运行结束，| 输入的字符串 | $\leq 30000$。
字符在内存中的数值为字符所对应的 Ascii 码。

## 样例 #1

### 输入

```
write whatever u c ,.,.,.,. $ asdf $```

### 输出

```
asdf```

# 题解

## 作者：fjy666 (赞：6)

### 0xff 前言
本题不难，模拟即可。  
但是，要注意细节啊！！！
![](https://cdn.luogu.com.cn/upload/image_hosting/56vwn4o2.png)  
否则，上图便是结果。

------------
### 0x00 题意
给你一个 BrainF\*\*k 程序和输入，输出这段程序的输出。

------------
### 0x01 思路  
**注：由于洛谷的 feature ，本文以 [dollar-sign] 代替 美元符号**  

由于这道题的输入比较复杂，考虑用**指针**来输入。  
> 坑点 #$1$:  
> 程序的结尾和 [dollar-sign] 之间**没有**空格，但输入的结尾和 [dollar-sign] 之间**有**空格！ 

~~就是这玩意儿坑了我 $10$ 多次提交~~  
定义一个指针 $\texttt{curr}$，指向输入数组的开头。  
然后一直读入，直到 $\texttt{*curr} = [dollar-sign] $。  
然后，令 $\texttt{*curr} \gets 0$ 即可。

读入 $\texttt{input}$ 类似，不过要注意：最后**还要**令 $\texttt{*(input-1)} \gets 0$ ！  

然后就是模拟啦！  
- <  内存指针左移一位
- \>  内存指针右移一位
- \+ 内存指针的**内容**加一
- \- 内存指针的**内容**减一。

对于 \[ ,跳到与它匹配的 \] 。  
注意，不是最近的 ] !  
例：`++[>++[-]<-]` 。  
那怎么匹配呢？  
- 定义一个计数器 cnt，并初始化为 $0$。
- 若遇到 左方括号， $cnt\gets cnt+1$。
- 若遇到 右方括号
	- 若 $cnt = 0$ ，则这个右方括号就是于之前的左方括号匹配的那个。
  	- 否则，$cnt\gets cnt-1$。
- 就这样一直扫过去，直到发现匹配右方括号。  

\[ 与 \] 类似，在此不再详述。

------------
### 0x02 代码
```cpp
#include <cstdio>
#define fo(i_,j_,k_) for(int i_=j_;i_<=k_;++i_)
#define fr(i_,j_,k_) for(int i_=j_;i_>=k_;--i_)
#define It(type_) type_::iterator
#define rg register
#define rtn return
#define il inline

typedef long long ll;
char memory[30005],*ptr;
char cmd[300005],input_[300005],*curr,*input;

int main()
{
	curr = cmd;
	while((*curr = getchar()) && *curr != '$') ++curr;
	*curr = 0;
	getchar(); 

	input = input_;	
	while((*input = getchar())&& *input != '$') ++input;
	*input = 0;
	*(input-1) = 0;
	
	curr = cmd;
	input = input_;
	ptr = memory;
	
//	printf("%s,%s.\n",cmd,input); 
	
	while(*curr != '\0')
	{
		switch(*curr)
		{
			case '<': -- ptr;break;
			case '>': ++ ptr;break;
			case '+': ++ *ptr; break;
			case '-': -- *ptr; break;
			case '.': putchar(*ptr);break;
			case ',':
				*ptr = (*input == '\0')? -1 : *input;
				if(*input != '\0') ++input;
				break;
			case '[':
				if(*ptr == 0)
				{
					++curr;
					int cnt = 0;
					while(!(*curr == ']' && cnt == 0))
					{
						if(*curr == '[') ++cnt;
						if(*curr == ']') --cnt;
						++curr;
					}
				}
				break;
			case ']':
				--curr;
                int cnt = 0;
				while(!(cnt == 0 && *curr == '['))
				{
					if(*curr == ']') ++ cnt; 
					if(*curr == '[') -- cnt; 
					--curr;
				}	
				--curr;
				break;
		}
		++curr;
	}
	rtn 0;
}
```

---

## 作者：stripe_python (赞：3)

没人写 BF 编译器吗？蒟蒻赶紧水篇题解。

基本思路是把 BF 编译成 Python 再执行，处理一下缩进问题就好了。

过程中可以巧用海象运算符提高效率。

```python
al = ''
while True:
	try:
		al += input() + '\n'
	except EOFError:
		break 
x, y, z = al.split('$')
b = list(y.strip())

tab = 0

def trans1(c: str):
	global tab
	if c == '>':
		return 'p += 1'
	if c == '<':
		return 'p -= 1'
	if c == '+':
		return 'a[p] += 1'
	if c == '-':
		return 'a[p] -= 1'
	if c == '.':
		return 'print(chr(a[p]), end="")'
	if c == ',':
		return 'a[p] = ord(b[k := k + 1]) if k + 1 < len(b) else -1'   # 用海象运算符防止缩进问题
	if c == '[':
		tab += 1
		return 'while a[p]:'
	if c == ']':
		tab = max(0, tab - 1)
		return ''
	return ''
  
def trans(c: str):
	code = trans1(c)
	if c == '[':
		return ' ' * (tab - 1) + code
	return ' ' * tab + code

a = [0] * 30000
p = 0
k = -1
code = '\n'.join(map(trans, x.strip()))
# print(code)
exec(code)
```

---

## 作者：Sweetlemon (赞：3)

这题是编写BrainF**k的解释器，我的程序把这个过程分为三部分：读入代码和输入缓冲——预处理代码(主要是循环)——逐字符解释(执行)代码。

读入没什么可说的，但是要注意忽略"$"前/后的空格。

预处理主要是为了提高执行效率，方便循环的快速跳转。我的上一次提交就是没有用预处理，结果TLE了。因此，避免重复工作是很必要的。

有了预处理的基础，逐字符解释代码也就不难了。只要根据题目的资料(当然，也可以结合Wikipedia上的说明，下面我会发一个Wiki的截图，方便无法访问Wiki的朋友们)，写出适当的代码，就好了。

下面发送一下Wiki对BrainF**k的解释(为了避免洛谷的水印影响阅读，稍微调整了版式)：

 ![](https://cdn.luogu.com.cn/upload/pic/4178.png) 

最后是AC(6ms,8515kb)的代码:

```cpp
#include <stdio.h>
#include <string.h>

int main(void){
    char codes[30001];//代码
    char inputs[30001];//输入缓冲区
    signed char data[30000]={0};//程序数据，需要初始化为零
    int down[30001],up[30001],tstack[15000];//down为左中括号到右中括号的索引,up为右中括号到左中括号的索引,tstack为预处理时的括号栈
    char t;//读取时用
    signed char * pdata;//数据指针
    int i=0,j=0,k=0,ncodes,ninputs; //i记录codes的索引,j记录inputs的索引,k记录tstack的索引
    while ((t=getchar())!='$')
        if (strchr("><.,+-[]",t)) //只记录代码的字符
            codes[i++]=t;
    ncodes=i; //为代码的总字符数
    codes[ncodes]='\0';
    getchar();//跳过'$'后的空格
    while ((t=getchar())!='$')
        inputs[j++]=t;
    ninputs=j-1;//为输入的总字符数
    inputs[ninputs]='\0';
    //读入完成，开始预处理
    for (i=0;i<ncodes;i++){
        switch (codes[i]){
            case '[':
                tstack[k++]=i;//入栈
                break;
            case ']':
                down[tstack[--k]]=i;//出栈、记录
                up[i]=tstack[k];
                break;
        }
    }
    //预处理完成，开始解释
    i=0,j=0,pdata=data; //索引、数据指针归零
    while (i<ncodes){//遍历代码
        switch (codes[i]){
            case '<':
                pdata--;
                break;
            case '>':
                pdata++;
                break;
            case '.':
                putchar(*pdata);
                break;
            case ',':
                if (j<ninputs)
                    *pdata=inputs[j++];
                else
                    *pdata=-1;//此时已读完输入缓冲，置为-1
                break;
            case '+':
                (*pdata)++;
                break;
            case '-':
                (*pdata)--;
                break;
            case '[':
                if (!(*pdata))//如果不执行循环，直接跳到对应]处
                    i=down[i];
                break;
            case ']':
                if (*pdata){//如果继续执行循环，跳到[处
                    i=up[i];
                }
                break;
        }
        i++;//执行下一行代码
    }
    return 0;
}
```

---

## 作者：0x3F (赞：2)

写在前面的话：由于某些原因，美元符号用 `dollar` 表示。

大模拟。

这题最难的就是读入。

使用三个 `char` 数组，分别表示代码内容，输入内容和内存槽。

首先，读入代码，直到 `dollar` 为止。

被读进去的 `dollar` 要作废，将它设为 $0$ 即可。

`dollar` 后的空格也要作废，只需要再 `getchar` 一次即可。

然后读入输入缓冲区。

注意，`dollar` 要作废，但是 `dollar` 前面的字符（可能是空格）不能作废！

然后就可以模拟了。

关于括号匹配：一定要找匹配的括号而非最近的括号，我这里把与每一个括号匹配的另一个括号的位置预处理了一下，用栈即可。

易错点：如果读入缓冲区为空，需要返回一个 `-1` ！否则可能会造成数组越界。

代码中可能有无用的字符，我这里为了提高代码的运行效率，把这些无关的字符统统筛掉。

没了。


```cpp
#include <bits/stdc++.h>
using namespace std;
char com[30010];
char inp[30010];
char mem[30010];
int sta[30010];
int got[30010];
int pnt, ipnt, siz;

int main() {
	
	//以下是读入 
	while ((com[pnt++] = getchar()) != '$'); getchar(); com[pnt-1] = 0; pnt = 0;
	while ((inp[pnt++] = getchar()) != '$'); inp[pnt-2] = 0; pnt = 0;
	//以上是读入 
	
	//以下是筛去无用字符 
	for (int i = 0; com[i]; i++) {
		if (com[i] == '<' || com[i] == '>' || com[i] == '+' || com[i] == '-' || com[i] == '.' || com[i] == ',' || com[i] == '[' || com[i] == ']') com[pnt++] = com[i];
	}
	com[pnt] = 0;
	pnt = 0;
	//以上是筛去无用字符 
	
	//以下是括号匹配 
	for (int i = 0; com[i]; i++) {
		if (com[i] == '[') sta[++siz] = i;
		else if (com[i] == ']') got[i] = sta[siz--], got[got[i]] = i;
	}
	//以上是括号匹配
	
	//以下是运行 
	for (int i = 0; com[i]; i++) {
		switch (com[i]) {
			case '<': {
				pnt--;
				break;
			}
			case '>': {
				pnt++;
				break;
			}
			case '-': {
				mem[pnt]--;
				break;
			}
			case '+': {
				mem[pnt]++;
				break;
			}
			case '.': {
				putchar(mem[pnt]);
				break;
			}
			case ',': {
				mem[pnt] = inp[ipnt]?inp[ipnt++]:-1;	//否则ipnt可能会跑到'\0'的后面 ，会导致WA，甚至RE 
				break;
			}
			case '[': {
				if (!mem[pnt]) i = got[i];
				break;
			}
			case ']': {
				if (mem[pnt]) i = got[i];
				break;
			}
		}
	}
	//以上是运行 
	
	return 0;
}
```


---

## 作者：一只小H (赞：2)

## 题意简述

编写 brainfuck 语言的解释器。

输入：

* 给出一个字符串。
* 字符串包含注释，代码和缓冲区。
* 程序不会越界。
* 程序不会死循环。
* 循环有嵌套。

输出

* 代码执行结果。

## 题目分析

代码分为两部分。

一、输入

首先读入代码部分，注意要过滤注释，读到 ＄ 就停止，过滤空格后读取缓冲区部分，最后过滤缓冲区后面的空格和 ＄

二、解释

定义 runcode 函数用来执行每个字符，返回值为 int 类型，表示下一个要执行的字符的下标。

首先解决没有循环的情况，这时将代码扫描一遍，将每个字符单独执行即可。

接下来解决循环，遇到字符 [ 时，判断是否结束循环，结束就跳转到对应的 ] 的下一个字符处执行，没结束就继续执行下一个字符。

遇到字符 ] 时，判断是否结束循环，结束就执行下一个字符，没结束就跳转到对应的 [ 处执行。

当然，直接寻找对应的中括号肯定会超时，所以需要预处理对应中括号的位置，这样就能直接跳转。

在输入的时候就可以预处理，用栈记录字符 [ 的位置，如果遇到字符 ] 就记录要跳转到的位置，然后弹出栈顶元素。

详情请见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 233333;
char code[MAXN]; //储存代码
char tmp[MAXN];  //储存缓冲区内容
char mem[MAXN];  //模拟内存槽
char ch;         //辅助读入字符
int s[MAXN];     //用来预处理循环跳转的栈
int l[MAXN];     // ］向左跳到的位置
int r[MAXN];     // ［向右跳到的位置
int clen;        //代码长度，用于输入
int tlen;        //缓冲区长度，用于输入
int tp;          //缓冲区指针，表示现在用到了哪
int sp;          //栈ｓ栈顶指针，用于预处理循环跳转
int p = 1;       //内存槽指针
int runcode(const int &cp)
{
    switch (code[cp])
    {
    case '+':
    {
        mem[p]++;
        break;
    } //将指针指向的数值加一
    case '-':
    {
        mem[p]--;
        break;
    } //将指针指向的数值减一
    case '<':
    {
        p--;
        break;
    } //指针指向的地址减一
    case '>':
    {
        p++;
        break;
    } //指针指向的地址加一
    case '.':
    {
        putchar(mem[p]);
        break;
    } //输出指针指向的数值
    case ',':
    {
        if (tp > tlen) //缓冲区为空送入-1
            mem[p] = -1;
        else //送入一个字符
            mem[p] = tmp[++tp];
        break;
    } //替换指针指向的数值
    case '[':
    {
        if (mem[p] == 0) //为０就向右跳转，跳出循环
            return r[cp] + 1;
        break;
    }
    case ']':
    {
        if (mem[p] != 0)  //指针指向的值不为０，重复执行
            return l[cp]; //跳到循环左侧重新开始循环
        break;
    }
    }
    return cp + 1; //执行下一个字符的代码
}
int main()
{
    ch = ' ';
    while (ch != '$')
    {
        ch = getchar();
        if (ch == '.' or ch == ',' or ch == '<' or ch == '>' or
            ch == '+' or ch == '-' or ch == '[' or ch == ']')
        {
            code[++clen] = ch;
        }
        else
        {
            continue;
        } //过滤注释
        if (ch == '[')
        {
            s[++sp] = clen;
        } //如果是［就入栈并记录下标
        else if (ch == ']')
        {
            r[s[sp]] = clen; //记录向右跳到的位置
            l[clen] = s[sp]; //记录向左跳到的位置
            sp--;            //弹出栈顶元素
        }                    //匹配对应的中括号
    }                        //读入代码
    ch = getchar();          //过滤第一个＄后面的空格
    while (ch != '$')
    {
        ch = getchar();
        tmp[++tlen] = ch;
    }                //读入缓冲区
    tmp[tlen--] = 0; //过滤缓冲区后的＄
    tmp[tlen--] = 0; //过滤缓冲区后的空格
    for (int i = 1; i <= clen; i = runcode(i)); //运行代码直到完成
    return 0;
}
```



---

## 作者：CommonDigger (赞：2)

# P2027 bf  
![](https://picx.zhimg.com/70/v2-f6957a0cbc79146e376c1fb738245ea3_1440w.awebp?source=172ae18b&biz_tag=Post)

### 第一篇题解求过

**[博客](https://www.luogu.com.cn/blog/551417/)内食用[本文章](https://www.luogu.com.cn/blog/551417/page2027on24jan12)更佳**

**既然这是一个普及左右的题，那就弄点简单易懂的**

题意很简单：  
一个大小 $\texttt{30000}$ 的数组（即程序中的内存槽），另有一个初始指向第一个内存的指针。有**以下操作**：  
> - 符号“<”：将指针左移一格，即来到内存槽前一个位置。  
> - 符号“>”：将指针右移一格，即来到内存槽后一个位置。  
> - 符号“+”：将指针所指内存里的数加 $1$。  
> - 符号“-”：将指针所指内存里的数减 $1$。  
> - 符号“.”：输出当前内存。  
> - 符号“,”：输入当前内存。  
> - 符号“\[”：如果当前指针不为 $0$，就从此处循环至匹配的括号。循环有嵌套。
> - 符号“\]”：循环的反括号。

至于循环至**匹配**的括号，**注意：写程序的时候切不可写成距离最近的反括号** ，实在不明白看一下[这一题](https://www.luogu.com.cn/problem/P1739)） 

都很简单，只需要模拟就可以了。模拟的意思就是程序说什么，你就按照字面意思直接写。

但是，题目中先输入 bf 的代码，其输入在后面。如果直接执行命令时遇到输入，就无法处理。所以我们不能直接操作，需要把命令先存起来。为了避免排版错误下文中出现的 $\text{dollarsign}$ 等于美元符号。

```cpp
    int idx=0, com[30005]; // idx存命令的索引
    char c=getchar();
    while(c!=dollarsign){
        if(c=='<' || c=='>' || c=='+' || c=='-' || c=='.' || c==',' || c=='[' || c==']') // 忽略注释，只存有效命令
            com[++idx]=c;
        c=getchar();
    }
```


那么，是不是可以在处理命令的时候，遇到输入的命令就读取一个字符，也就是随时输入呢？也不行。为什么？

仔细读题可以发现，缓存区的两个 $\text{\$}$ 里面是有空格的，左边 $\text{\$}$ 符号的空格在符号的右边，右边的在符号的左边。例如，缓冲区因该是 asdf，实际上缓冲数据左右是有空格的：

> 没空格的样子：$ \$\texttt{asdf}\$ $  
> 有空格的样子：$ \$ $ $\texttt{asdf}$ $ \$ $

然而如果我们直接输入，就会把空格也当作输入的内容。所以我们也需要存储输入数据并进行一些处理。

```cpp
    // 这个时候c已经读取了左 $ 符号，我们知道了下一个字符是空格，要把空格忽略掉
    c=getchar();// 吃掉（滑稽）左空格
    c=getchar();//正式开始输入
    while(c!='$'){
        inp[++indx]=c;
        c=getchar();
    }//输入完毕的时候输入后面的空格被存储进去了 ，空格不能要
    inp[indx]='\0';//把后边空格抹掉
    indx=0;
```

其他的，模拟即可。因为是一道普及题，所以，不用指针了，用一个变量表示指针位置。

```cpp
    int a[30005], n=1;
```

所以，指针加一的命令就变成了 $\texttt{n++}$，减一的命令就变成了 $\texttt{n-}\texttt{-}$，内存加一变成了 $\texttt{a[n]++}$，减一就变成了 $\texttt{a[n]-}\texttt{-}$。  
最后，关于循环的问题，我这样处理的，大家可以参考一下：  

- 遇到左括号，即循环开始。如果此时指针值为 $\text{0}$，跳到匹配的反括号后面。反之，执行循环内的内容。  
- 遇到右括号，跳到这个括号匹配的左括号。  

就这样很简单地处理。

那么我们可以看到，循环的执行需要在括号之间跳来跳去，所以为了节省时间我们可以把每个括号匹配的另一个括号的位置提前算出来并存起来。  
具体做法：对于每一个右括号，从该位置出发，遇到第一个没有记录的左括号（如果是有记录的左括号说明它已经匹配过了）时完成匹配。程序保证给出的代码不会有问题，所以不需要想别的。

```cpp
    int bracket[30005];
    void getLeftBracket(int i){
        int mark=i;
        while(i>=1 && (com[--i]!='[' || bracket[i]!=0)){
            if(i==']') i=bracket[i]; // 跳过已经匹配的括号组
        }
        bracket[i]=mark, bracket[mark]=i; //左右括号互相存储对方的位置
    }
```

这个寻找的程序只是针对**单独**一个括号进行的，我们需要对每一个右括号都调用一遍此函数。这个函数看似有很多循环，但是只会执行$|\text{字符串长度}|$次循环。为什么？因为循环中的if跳过了之前找过的位置，只会找没来过的位置。比如：

> $\texttt{[fl}\text{[orr]}\texttt{io]}$  

因为 $\text{[orr]}$ 之前已经找过括号了，所以程序再找上述字符串最右边那个括号的时候，从后往前遍历，遇到 $\text{[orr]}$ 的右括号，直接跳过 $\text{[orr]}$ 的内容，跳到其左括号。这样，循环总共就只会执行 $|\text{字符串长度}|$ 次。

具体地解释一下：

我们的思路是一个字符一个字符地读入的，假设现在读入了这些内容：  
> $[f[lorr[i\underline{]}$  

读入符号 \[ 的时候，我们不做任何事，现在读入了字母 i 后面的反括号 ]，这个时候就需要调用函数匹配括号了。从当前位置往左，我们找到了 i 左边的正括号 \[，匹配成功。**这片区域匹配过了，标记一下：**
> $[f[lorr\texttt{XXX}$

继续读入：
> $[f[lor\underline{r}\texttt{XXX}o\underline{]}$

读到 o 右边的反括号，调用函数匹配。在 o 位置从右向左，遇到了标记过的 $\texttt{X}$。由于这个地方之前匹配的时候走过，因此不会有我们想要的目标，直接跳到标记区域的左边，即下划线 r 的位置，继续往左匹配。匹配完之后把走过的位置标记上。
> $[f\texttt{HHHHHXXXHH}$

以此类推。整个过程中都过的下标都是以前没有走过的，所以这个匹配括号的函数不会占用太多时间。

那么，怎么实现标记走过的路并跳过它呢？其实，标记的本质目的是为了跳跃。观察可以发现，每一个因该标记的区域，它的右边总是反括号 ]，所以很简单，当我们遇到反括号的时候说明这个反括号一直到它匹配的正括号的这一段区域都是标记过的了，我们只需要跳到这个反括号匹配的正括号的左边就可以实现跳跃了。比如现在我们读到了：
> $[f\texttt{HHHHHXXXHH}\underline{]}$  
$[f[lorr[i]o]\underline{]}$

要找这个下划线括号的反括号，我们从右往左找。第一回遇到了一个反括号（字母 o 右边的），之前已经匹配过了，直接跳到它匹配的正括号左边：
> $[\underline{f}\texttt{HHHHHXXXHH}]$  
$[\underline{f}[lorr[i]o]]$

### ok.  
贴代码

代码中的 switch 与 if 条件类似，不同的分支执行不同的命令，具体语法也很简单。

```cpp
#include "iostream"
using namespace std;
int a[30005], n=1;
int idx=0, indx=0;
int bracket[30005];
char com[30005], inp[30005]; // 分别存储命令、输入
void getLeftBracket(int i){
    int mark=i;
    while(i>=1 && (com[--i]!='[' || bracket[i]!=0)){
        if(i==']') i=bracket[i];
    }
    bracket[i]=mark, bracket[mark]=i;
}
void store(){ //输入
    indx++;
    if(inp[indx]=='\0'){
        a[n]=-1;
    }else{
        a[n]=inp[indx];
    }
}
int main(){
    char c=getchar();
    while(c!='$'){
        if(c=='<' || c=='>' || c=='+' || c=='-' || c=='.' || c==',' || c=='[' || c==']') com[++idx]=c;
        if(c==']') {getLeftBracket(idx);}
        c=getchar();
    }
    c=getchar(); // read the space after first $
    c=getchar();
    while(c!=dollarsign){
        inp[++indx]=c;
        c=getchar();
    }
    inp[indx]='\0';
    indx=0; // 清零为了以后程序中处理输入时重新遍历一遍
    for(int i=1;i<=idx;i++){
        switch(com[i]){
            case '<': n--; break;
            case '>': n++; break;
            case '+': a[n]++; break;
            case '-': a[n]--; break;
            case '.': putchar(a[n]); break;
            case ',': store(); break;
            case '[': if(a[n]==0) i=bracket[i]; break;
            case ']': i=bracket[i]-1; break;
        }
    }
    return 0;
}
```

忘记改了多少次了，跪求过审，这次是 2024 年 1 月 28 日 15:54

---

## 作者：Kano_zyc (赞：1)

题目要求我们实现一个简单的 `BrainFuck` 解释器。

`BrainFuck` 是一种极简的编程语言，只有 $8$ 种字符，每种字符都有特定的含义。

解题的主要难点在于处理 `BrainFuck` 语言的循环结构，即`[`和`]`字符。

我们需要预处理所有的循环，将每个 `[` 和相应的 `]` 的位置进行配对。

另外，我们还需要注意处理输入和输出时的细节。

以下是一个 `C++` 解决方案：


```cpp
#include<bits/stdc++.h>
using namespace std;
char c[30005];
int a[30005],nxt[30005],st[30005],top;
int main(){
    int n=0;
    char ch;
    while((ch=getchar())!='$') c[++n]=ch; // 读取代码，直到'$'为止
    for(int i=1;i<=n;i++){ // 预处理循环
        if(c[i]=='[') st[++top]=i;
        if(c[i]==']'){
            int k=st[top--];
            nxt[i]=k;nxt[k]=i;
        }
    }
    getchar(); // 读取输入和$之间的空格
    for(int i=1,j=0;i<=n;i++){
        if(c[i]=='>') j++;
        if(c[i]=='<') j--;
        if(c[i]=='+') a[j]=(a[j]+1)%256; // 注意内存中的值在0-255的范围内
        if(c[i]=='-') a[j]=(a[j]-1+256)%256; // 注意内存中的值在0-255的范围内
        if(c[i]=='.') putchar(a[j]); // 输出内存中的ASCII码值对应的字符
        if(c[i]==','){ // 读取一个字符
            ch=getchar();
            if(ch=='$') a[j]=-1; // 如果字符是'$'，就将-1存入内存
            else a[j]=ch; // 否则将字符的ASCII码值存入内存
        }
        if(c[i]=='['&&a[j]==0) i=nxt[i]; // 如果当前位置是'['且当前指针指向的值为0，就跳转到相应的']'的位置
        if(c[i]==']'&&a[j]!=0) i=nxt[i]; // 如果当前位置是']'且当前指针指向的值不为0，就跳转到相应的'['的位置
    }
    return 0;
}
```


---

## 作者：Yusani_huh (赞：1)

小芝士：[BF 百度百科](https://baike.baidu.com/item/Brainfuck/1152785?fr=aladdin)

做此题浪费了本人多次提交...wtcl

读入和处理字符没什么问题，在读入的时候就可以把注释顺便给办掉，详细操作见代码。

下面需要着重处理一下 `[` 和 `]`，我开了一个栈来把它们两两配对，如果不配对有括号嵌套时就会出错（我开始就挂在这）。

之后针对每个操作直接进行模拟。详细见代码。

```
#include<bits/stdc++.h>
using namespace std;
char cz[30003],sr[30003];
int nc[30003],p,d=1,l,crl;
int stk[30003],dy[30003];
int gogogo(int a){
	if(cz[a]=='<') p--; //指针减1
	else if(cz[a]=='>') p++; //指针加1
	else if(cz[a]=='+') nc[p]++; //指针指向的内存数值加1
	else if(cz[a]=='-') nc[p]--; //指针指向的内存数值减1
	else if(cz[a]=='.') putchar(nc[p]); //以字符形式输出指针指向的内存数值
	else if(cz[a]==','){
		if(d>=crl) nc[p]=-1; //如果读入缓冲区为空则送入-1
		else nc[p]=sr[d],d++; //将读入缓冲区中的一个字节送入当前指针指向的内存里面
	}
	else if(cz[a]=='['&&!nc[p]) return dy[a]; //若当前内存数值为0，则跳过循环来到右括号
	else if(cz[a]==']'&&nc[p]) return dy[a]; //若当前内存数值不为0，则回到左括号
	return a+1; //下一步操作
}
int main(){
	char ch='0';
	while((ch=getchar())!='$')
		if(ch=='<'||ch=='>'||ch=='+'||ch=='-'||ch=='.'||ch==','||ch=='['||ch==']')
			cz[l++]=ch; //读入时直接删除注释
	getchar(); //把空格去掉
	while((ch=getchar())!='$')
		sr[++crl]=ch; //读入缓冲区
	int tot=0;
	for(int i=0;i<l;++i)
		if(cz[i]=='[') stk[++tot]=i; //左括号入栈
		else if(cz[i]==']') dy[i]=stk[tot],dy[stk[tot]]=i,tot--; //右括号出栈并建立对应关系
	for(int i=0;i<l;) i=gogogo(i); //模拟操作
	return 0;
}
```

---

## 作者：_•́へ•́╬_ (赞：1)

### 不难，摸妳即可
```cpp
#include<stdio.h>
char code[33333],mmry[33333],file[33333];int i,j,len1,len2;
char read_from_file(){return j==len2?-1:file[j++];}
void running(int l,int r)
{
	for(register int llnk=l,rlnk,dep;llnk<=r;++llnk)
		switch(code[llnk])
		{
			case'<':--i;break;//指针所指向的内存地址减一
			case'>':++i;break;//指针所指向的内存地址加一
			case'+':++mmry[i];break;//指针所指向的内存里面的数值加一
			case'-':--mmry[i];break;//指针所指向的内存里面的数值减一
			case'.':putchar(mmry[i]);break;//输出当前指针所指向的内存里面的数值
			case',':mmry[i]=read_from_file();break;
					//将读入缓冲区中的一个字节送入当前指针指向的内存里面
			case'[':
				for(rlnk=llnk,dep=0;;++rlnk)
				{
					if(code[rlnk]=='[')++dep;
					if(code[rlnk]==']'){--dep;if(!dep)break;}
				}//匹配']'
				for(;mmry[i];running(llnk+1,rlnk-1));//一直运行
				llnk=rlnk;//从'['直接跳到']'
				break;
		}
}
main()
{
	for(;code[len1]=getchar(),code[len1]!='$';)
		if(code[len1]=='<'||code[len1]=='>'||code[len1]=='+'||code[len1]=='-'||
		   code[len1]=='.'||code[len1]==','||code[len1]=='['||code[len1]==']')++len1;
	getchar();//前面的空格祛掉
	for(;file[len2]=getchar(),file[len2]!='$';++len2);
	--len2;//最后的空格祛掉
	//=====以=====上=====均=====为=====输=====入=====
	running(0,len1-1);
}/**/
```

---

## 作者：4041nofoundGeoge (赞：0)

此题太露骨了，叫 BrainFu*k。本文中的 dollar 都显示成 ￥。

# 思路

这道题不难，是道大模拟题关键就在这句话：

```
字符|意义
< 　|指针所指向的内存地址减一。
> 　|指针所指向的内存地址加一。
+ 　|指针所指向的内存里面的数值加一。
- 　|指针所指向的内存里面的数值减一。
. 　|输出当前指针所指向的内存里面的数值（以字符形式输出）。
, 　|将读入缓冲区中的一个字节送入当前指针指向的内存里面。如果读入缓冲区为空则送入-1。
[ 　|当前指针指向的内存里面的数值不为0时，重复执行与之相匹配的]之间的语句，直到回到[时当前指针指向的内存中的数值为0。
] 　|如上。
```

模拟就完事了！主要难点就在输入这块地方。

# 实现

第一个 ￥ 之前是运算区，用 code 数组存储，￥ 之后是缓冲区用 yuan 数组存储。数据统一存储在 data 数组中，方括号匹配用类似栈的 stack 数组存储，a 数组用来解决循环问题。

注意：题目中描述：￥ 后面紧跟一个空格（**不属于输入缓冲区**）。

如果你用纸验算一下可以发现这些运算符具有一下特点（设指针为 n）：

```
字符|意义
< 　|n--
> 　|n++。
+ 　|data[n]++。
- 　|data[n]--。
. 　|cout<<(char)data[n]。
, 　|if(yuan[cnt])data[n]=yuan[cnt++];else cout<<-1;
[ 　|if (!data[n])i = a[i];
] 　|if (!data[n])i = a[i];
```

发现这个规律，题目不就迎刃而解了吗？

# 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
char code[30010];
int yuan[30010], data[30010], stack[30010], a[30010];
int n, cnt, tot;
int main()
{
    while ((code[tot++] = getchar()) != '$')
        ;
    getchar(); // 输入代码
    code[n - 1] = 0, n = 0;
    while ((yuan[n++] = getchar()) != '$')
        ;
    yuan[n - 2] = 0, n = 0; // 输入缓冲区
    for (int i = 0; code[i]; i++)
        if (code[i] == '<' || code[i] == '>' || code[i] == '+' || code[i] == '-' || code[i] == '.' || code[i] == ',' || code[i] == '[' || code[i] == ']')
            code[n++] = code[i]; // 抹去没用的
    code[n] = 0;
    n = 0;
    for (int i = 0; code[i]; i++) {
        if (code[i] == '[')
            stack[++tot] = i;
        else if (code[i] == ']')
            a[i] = stack[tot--], a[a[i]] = i;
    }
    for (int i = 0; code[i]; i++) {
        switch (code[i]) { // 提到的运算符
        case '<':
            n--;
            break;
        case '>':
            n++;
            break;
        case '-':
            data[n]--;
            break;
        case '+':
            data[n]++;
            break;
        case '.':
            cout << (char)data[n];
            break;
        case ',':
            if (yuan[cnt])
                data[n] = yuan[cnt++];
            else
                data[n] = -1;
            break;
        case '[':
            if (!data[n])
                i = a[i];
            break;
        case ']':
            if (data[n])
                i = a[i];
            break;
        }
    }
    return 0;
}
```

---

## 作者：CleanIce (赞：0)

# P2027 bf 题解

[原题链接](https://www.luogu.com.cn/problem/P2027)。

## 原题简述

一看就是模拟题，让我们写一个 BF 语言的解释器。给我们提供了容量为 $30000$ 字节的内存，全部初始化为 $0$。还有内存指针，指向内存开始的位置。

然后说代码的字符集及其含义。这里进行了整理和修改，应该更好理解：

| 代码字符 | 含义 |
| :---: | :---: |
| `>` | 将内存指针右移（内存地址加一）。|
| `<` | 将内存指针左移（内存地址减一）。|
| `+` | 将存储在当前内存的值加一。|
| `-` | 将存储在当前内存的值减一。|
| `,` | 从输入流读取一个字符，并将其 ASCII 码存储到当前内存中。若输入流没有更多字符，存入 $-1$。|
| `.` | 将当前内存的值以 ASCII 码表翻译为字符后输出。|
| `[` | 循环开始。若当前内存值为 $0$，跳过直到与其配对的 `]`。否则继续执行。|
| `]` | 循环结束。跳回与其配对的 `[`。|

就是这么些简单的字符，实现也非常简单。但 BF 语言并不简单，它甚至达到了高级编程语言的基本标准：图灵完备。这里是题外话就不展开了。

然后说输入的数据格式为：

```
代码$ 输入流 $
```

注意空格的位置。输入流与左右两个 `$` 符号之间**有一个空格**，但代码与第一个 `$` 之间并**没有**！读入的时候需要注意。

另外，题目中说到的“代码中有注释”，注释指的是**代码中除了上述字符集内字符之外的所有字符**（不包括 `$`）。因此我们需要忽略它们。

下面来想想思路。

## 做题思路

先设几个变量，方便讲述（为了使使用其他语言的读者看懂，此处不考虑指针操作）：

- $\text{code}$：当前运行到的代码的字符。
- $\text{input}$：当前输入流准备读入的下一个字符。若没有更多字符，我们令 $\text{input} \gets \varnothing$。
- $\text{mem}$：存储在当前内存的值。
- $\text{addr}$：当前内存地址。

我们假设内存条越往右地址越大，初始地址为 $0$。

那么，我们一个个看字符集中的代码该如何处理：

1. `>` 右移操作符：将当前内存地址增加一。也就是：$\text{addr} \gets \text{addr} + 1$。
2. `<` 左移操作符：将当前内存地址减少一。也就是：$\text{addr} \gets \text{addr} - 1$。
3. `+` 自增操作符：将存储在当前内存的值加一。也就是：$\text{mem} \gets \text{mem} + 1$。
4. `-` 自减操作符：将存储在当前内存的值减一。也就是：$\text{mem} \gets \text{mem} - 1$。
5. `,` 输入操作符：从输入流读入一个字符，并存储到当前内存位置。如果输入流没有更多字符，存入 $-1$。也就是：$\text{mem} \gets \begin{cases} \text{input} & \text{input} \ne \varnothing \\ -1 & \text{input} = \varnothing \end{cases}$，随后令 $\text{input} \gets \text{下一个输入流中的字符}$。
6. `.` 输出操作符：将存储在当前内存的值按照 ASCII 表作为字符输出。也就是输出 $\text{mem}$。

接下来就是比较难的两个。上面在将字符集的时候说，就是跳到配对的目标括号。如何寻找配对的括号呢？

且看这一段字符：

```
+[+[>[,]-]+].
```

很明显，如果我们要找到第一个 `[` 配对的字符，就是第三个 `]`，第二个 `[` 就是第二个 `]`。

只要记录一共遇到了几个 `[` 和几个 `]` 就行了。也就是说，寻找第一个 `[` 配对的符号时，还会遇到两个 `[`，找到两个 `]` 并忽略后，第三个 `]` 就是配对的了。寻找第二个 `[` 配对的符号时，还会遇到一个 `[`，找到一个 `]` 并忽略后，第二个 `]` 就是配对的了。因此，写出伪代码：

```
// 伪代码
// count 为需要寻找的个数
count <- 1
ch <- #当前字符#
while (count != 0):
    if ch = '[':
        count <- count + 1
    elseif ch = ']':
        count <- count - 1
    ch <- #下一个字符#
ch <- #回退到上一个字符#
// 此时 ch 就是配对的 ]
```

`]` 符号同理，不再重复。

## 代码专区

因为我很~~牛逼~~，所以我提供了现代化 C++ 代码和传统的 OI 代码。对于洛谷少数的程序设计人员（或非竞赛选手），可以看现代化的代码。对于 oiers，可以尝试阅读现代化代码，或者就直接看传统 OI 型的代码。两份代码都给了注释，其中现代化代码还给了技术注释。两份代码效率差不多（现代化的我测了一下可能还快一些）。

现代化代码使用了 C++23 的新特性，因此洛谷上提交不了（可能你也运行不了）。你可以根据我的注释修改为 C++20 以内的代码使用，当然也可以提交。

传统 OI 代码就给你们自己看吧。

由于代码长度比较长，我把它放到剪贴板里了。

[代码在这里](https://www.luogu.com.cn/paste/w09k7cs4)

---

## 作者：TFHS_arsc (赞：0)

# P2027 bf 题解
## 1、关于 BF
*注：此段为题外话，专心做题者请跳过*

首先，让我们来简单了解一下 [BrainF\*\*k](https://baike.baidu.com/item/Brainfuck/1152785?fr=ge_ala) 语言。

一个数组，一个指针在数组上移动，根据程序编码对数组进行操作……诶，[图灵机](https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E6%9C%BA/2112989?fr=ge_ala)！

So，BF 语言也是[图灵完备](https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/4634934?fr=ge_ala)的。

如果你已经理解了这些（没错，很简单），那么，你一定就有了这道题的思路：**模拟**

## 2、题目思路
我们需要几个数组：

1. 存储代码的数组 `code`；
2. 输入缓冲区 `in_put`；
3. 存储数据的数组 `dat`；
4. 由于 BF 中存在循环结构，所以我们需要一个栈 `sta` 来判断 `[]` 的匹配；
5. 循环控制数组 `while_control`。

首先，使用 `while` 语句循环输入 BF“代码”到 `code` 数组当中。因为输入的前半部分是没有用的，所以我们需要在后面的代码中将其覆盖。

然后，输入 BF 代码的输入，将它们保存到输入队列 `in_put` 当中。

检查括号匹配，并将需要循环的代码存到 `while_control`。

最后，按照 BF 的语法和题目要求，将输入的 BF 代码解释：

- 输入 `>`，将数组指针加一；
- 输入 `<`，将数组指针加一；
- 输入 `+`，将数组的指针位置加一；
- 输入 `-`，将数组的指针位置减一；
- 输入 `.`，输出数组的指针位置；
- 输入 `,`，从输入队列中取出一个要输入的元素并添加到数组的指针位置；
- 当遇到 `[`，运行提前存储下来的循环部分代码；
- 当遇到 `]`，重新执行循环代码，直到 `tot` 指向的数组元素为 0。

以上，便是这道题的整体思路（其实在题目中已经解释得很清楚了）。

~~其实，这道题比较难的是输入处理。。。~~

## 3、代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;
char BFcode[30010];
int in_put[30010],dat[30010],sta[30010],while_control[30010];
int tot, in_cnt, stack_tot;
int main() {
	
	//输入
	while ((BFcode[tot++] = getchar()) != '$');//BF代码
	getchar();
	BFcode[tot-1] = 0;
	tot = 0;
	while ((in_put[tot++] = getchar()) != '$');//BF代码的输入
	in_put[tot-2] = 0;
	tot = 0;
	
	//检查代码，讲没有用的部分覆盖 
	for (int i = 0; BFcode[i]; i++) {
		if (BFcode[i] == '<' || BFcode[i] == '>' || BFcode[i] == '+' || BFcode[i] == '-' || BFcode[i] == '.' || BFcode[i] == ',' || BFcode[i] == '[' || BFcode[i] == ']'){
			BFcode[tot++] = BFcode[i];
		}
	}
	BFcode[tot] = 0;
	tot = 0; 
	
	//预处理括号匹配 
	for (int i = 0; BFcode[i]; i++) {
		if (BFcode[i] == '[') sta[++stack_tot] = i;
		else if (BFcode[i] == ']') while_control[i] = sta[stack_tot--], while_control[while_control[i]] = i;
	}
	
	//解释并运行BF代码 
	for(int i = 0;BFcode[i]; i++) {
		switch (BFcode[i]) {//多分支用switch语句，效率高 
			case '<':
				tot--;
				break;
			case '>':
				tot++;
				break;
			case '-':
				dat[tot]--;
				break;
			case '+':
				dat[tot]++;
				break;
			case '.':
				cout<<(char) dat[tot];//将ASCII码字转换成字符输出 
				break;
			case ',':
				if(in_put[in_cnt])
					dat[tot] = in_put[in_cnt++];
				else{
					dat[tot] = -1;
				}
				break;
			case '[':
				if (!dat[tot])
					i = while_control[i];
				break;
			case ']':
				if (dat[tot])
					i = while_control[i];
				break;
		}
	}
	
	return 0;
}
```
完结撒花 o(〃＾▽＾〃)o

---
###### 求管理员大大通过༼ つ ◕_◕ ༽つ

---


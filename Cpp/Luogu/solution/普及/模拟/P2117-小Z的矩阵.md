# 小Z的矩阵

## 题目描述

小 Z 最近迷上了矩阵，他定义了一个对于一种特殊矩阵的特征函数 $G$。对于 $N\times N$ 的矩阵 $A$，$A$ 的所有元素均为 $0$ 或 $1$，则 $\displaystyle G(A) = \left(\sum_{i = 1}^n\sum_{j = 1}^n A_{i, j}\cdot A_{j, i}\right) \bmod 2$。举一个例子：

$$
\begin{pmatrix}
1 & 1 & 1\\
0 & 1 & 1\\
1 & 0 & 0\\
\end{pmatrix}
$$

对于上面这个 $3\times 3$ 矩阵 $A$，$G(A)=(1\times 1+1\times 0+1\times 1+0\times 1+1\times 1+1\times 0+1\times 1+ 0\times 1+0\times 0) \bmod 2 = 0$。

当然询问一个矩阵的 $G$ 值实在是太简单了。小Z在给出一个 $N\times N$ 矩阵的同时将给你 $Q$ 个操作，操作描述如下：

- 操作 1：形如 `1 x`，表示将第 $x$ 行的元素全部“翻转”。
- 操作 2：形如 `2 x`，表示将第 $x$ 列的元素全部“翻转”。
- 操作 3：形如一个整数`3`，表示询问当前矩阵的特征值 $G$。

“翻转”的定义为将 $1$ 变成 $0$，将 $0$ 变成 $1$。

## 说明/提示

【数据规模】

- 对于 $30\%$ 的数据，$N\le 100$，$Q\le 10^5$。

- 对于 $100\%$ 的数据，$N\le 1,000$，$Q \le 5\times 10^5$。

## 样例 #1

### 输入

```
3 12
1 1 1
0 1 1
1 0 0
3
2 3
3
2 2
2 2
1 3
3
3
1 2
2 1
1 1
3
```

### 输出

```
01001
```

# 题解

## 作者：o0数学迷0o (赞：30)

显然在mod 2下A[i][j]\*A[j][i]+A[j][i]\*A[i][j]=0, 所以这个和相当于所有A[i][i]的和. 每翻转一行或一列就不多不少翻转了一个A[i][i], 也就相当于翻转了所求的和(mod 2). 所以只需读对角线元素和, 然后每次询问即输出这个和, 每次修改即翻转这个和即可, 源代码如下:

  
  
```cpp
#include <iostream>  
#include <cstdio>  
#include <cmath>  
using namespace std;  
int n,q,g,x;  
int main(){  
    ios::sync_with_stdio(0);  
    g=0;  
    cin>>n>>q;  
    for(int i=0;i<n;++i)  
        for(int j=0;j<n;++j){  
            cin>>x;  
            if(i==j)g^=x;  
        }  
    for(int i=0;i<q;++i){  
        cin>>x;  
        if(x==3)cout<<g;else{  
            cin>>x;  
            g=!g;  
        }  
    }  
    return 0;  
}

```

---

## 作者：judgejudge (赞：8)

# 数论：简单的规律（带证明）
首先审题先别慌：要返回**特征函数**，马上看特征函数的定义：

**所有A[i][j]乘以A[j][i]的和对2取余之后的结果**

我们再仔细琢磨一下，发现：**a[i][j]和a[j][i]是成对出现的！！** 也就是有一个a[i][j]，**有且只有**唯一的a[j][i]与之对应（**对角线就是本身**，伏笔：这就是**关键**）所以：

### G（a[i][j]）= G（a[j][i]）

又因图形为正方形，那么我们可以**以下降的正方形对角线为对称轴，对称轴左右两端的对称点特征函数值相等**！！！

从而得出：

**除对称轴上的点，对称轴左右两端特征函数值为偶数**（因为对称点成对出现）！！

那么我们只用判断**对称轴上的点的特征函数值**即可。

还没完！

我们再仔细观察一下题目：

```cpp
//操作1：形如一个整数1和一个整数x，表示将第x行的元素全部“翻转”。
//操作2：形如一个整数2和一个整数x，表示将第x列的元素全部“翻转”。
//操作3：形如一个整数3，表示询问当前矩阵的特征值G。
//“翻转”的定义为将1变成0，将0变成1。
```
我们可以把**行或列上的元素集合近似地理解成一条平行于x轴或y轴的直线**，**对角线理解成比例系数为-1的直线**。
  
由数学中：**在同一平面内，两条互不平行的直线有且只有一个交点** 得出：

**每进行一次翻转，有且只有一个对角线上的特征函数改变。**

又因：
1. 1的平方为1，是奇数
1. 0的平方为0，是偶数

**奇偶性**不同！！！

所以得出最后的关键：

### 每进行一次翻转，奇偶性必发生转变！！
问题便转换成：**计算一开始特征函数的奇偶性（判断对角线特征函数即可），然后数进行了几次翻转即可！**

没想到一道看似较复杂的题目被刨析得如此简单（近似于a+b).

AC代码：
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
ll sum=0;
ll n,m;
int main(){
	register int i,j;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++){
		ll k;
		cin>>k;
	    if(i==j)sum+=k,sum%=2;//判断对角线上的特征函数值和的奇偶性
	}
	for(i=1;i<=m;i++){
		ll s1,s2;
		cin>>s1;
		if(s1==1||s1==2){//如果是执行翻转
			cin>>s2;
		    sum++,sum%=2;//奇偶性必发生改变
		}
		else cout<<sum;//输出
	}
	cout<<endl;
	return 0;
}
```


---

## 作者：loi_hjh (赞：4)

# 这道题一味地枚举来变化只能得30分（TLE），这里需要动脑子找一下规律这种神奇的东西了（请见17行）

## ~~（正解这种可怕的东西我不会）~~

附上代码：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int a[1001][1001],n,m,p,q,ans;
void gg(){
	scanf("%d",&p);
	if(p==1){
		scanf("%d",&q);
		ans-=a[q][q];//第一次没有写，30分，TLE
		a[q][q]^=1;//1变0，0变1（异或特别快，比+，-都快） 
		//最后发现：a[i][j]*a[j][i]每次都要加两遍，&1（%2）后没有什么用，只有主对角线不这样，只加一次 
		//第二次还写了变化（还是30分） 
		/*
		for(int i=1;i<=n;i++)
			a[q][i]^=1;
		*/ 
		ans-=a[q][q];//第一次没有写，30分，TLE
	}
	if(p==2){
		scanf("%d",&q);
		ans-=a[q][q];//第一次没有写，30分，TLE
		a[q][q]^=1;
		//第二次还写了变化（还是30分） 
		/*
		for(int i=1;i<=n;i++)
			a[i][q]^=1;
		*/ 
		ans+=a[q][q];//第一次没有写，30分，TLE 
	}
	if(p==3){
		//第一次每进行3都重新算ans。。。然后。。。 
		printf("%d",ans&1);//相当于&2，和^一样快 
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);//读入 
	for(int i=1;i<=n;i++)//先算出初始的ans 
			for(int j=1;j<=n;j++)
				ans+=a[i][j]*a[j][i];
	for(int i=1;i<=m;i++)
		gg();//函数好看 
	return ~~(0-0);//卖个萌求通过 
}

```

---

## 作者：whc2020 (赞：3)

思路一:

枚举每一个i，j，这时的时间复杂度的最坏情况为O（n*n*q），即使是最好的情况也不过是O（n*q），在n<=1000,q<=500000时显然是会T的。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n , q , t , x , a[1001][1001];

int main() {
	scanf ("%d%d" , &n , &q);
	for (int i = 1 ; i <= n ; i++) {
		for (int j = 1 ; j <= n ; j++) {
			scanf ("%d" , &a[i][j]);
		}
	}
	while (q--) {
		scanf ("%d" , &t);
		switch (t) {
			case 1 : {
				scanf ("%d" , &x);
				for (int i = 1 ; i <= n ; i++) {
					a[x][i] = ! a[x][i];
				}
				break;
			}
			case 2 : {
				scanf ("%d" , &x);
				for (int i = 1 ; i <= n ; i++) {
					a[i][x] = ! a[i][x];
				}
				break;
			}
			case 3 : {
				int ans = 0;
				for (int i = 1 ; i <= n ; i++) {
					for (int j = 1 ; j <= n ; j++) {
						ans += a[i][j] * a[j][i];
					}
				}
				printf ("%d" , ans % 2);
				break;
			}
		}
	}
	return 0;
}
```
最终拿到30分。

思路二:

~~找规律~~，严谨地推导更优的解法。

先来模拟一下样例：

1 1 1

0 1 1--->ans = 0

1 0 0


------------

1 1 0

0 1 0--->ans = 1

1 0 1


------------
1 0 0

0 0 0--->ans = 0

1 1 1


------------
1 1 1

0 1 1--->ans = 1

0 1 1


------------
发现了惊人的规律，ans的值就等于**左对角线**上的数之和再mod 2 的值。

证明：

~~由乘法分配律~~显然，a[i][j] * a[j][i] == a[j][i] * a[i][j]，所以，若i不等于j，（a[i][j] * a[j][i] + a[j][i] * a[i][j]）mod 2 的值始终为0，对ans并没有影响。因而ans仅与形如（i，i）的点有关系。

放上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n , q , x , a[1001];

int main() {
	scanf ("%d%d" , &n , &q);
	for (int i = 1 ; i <= n ; i++) {
		for (int j = 1 ; j <= n ; j++) {
			scanf ("%d" , &x);
			if (i == j) {//方便起见，我们只记录下对角线上的数。 
				a[i] = x;
			}
		}
	}
	for (int i = 1 ; i <= q ; i++) {
		scanf ("%d" , &x);//代码核心部分 
		if (x == 3) {//若此时需要输出
			int ans = 0;//初始化 
			for (int j = 1 ; j <= n ; j++) {
				ans += a[j];//压行了，等同于{if (a[j] == 1) ans++;} 
			}
			printf ("%d" , ans % 2);
		}
		else {
			scanf ("%d" , &x);
			a[x] = !a[x];
		}
	}
	return 0;
}
```


---

## 作者：张亦弛 (赞：2)

一看到三个操作。。。诶？！什么数据结构。。打上一波线段树，嗯，修改，嗯，查询。。原地爆炸，查询甚至比暴力查询还慢。凉凉（也许是我的智商不够高吧）。

还是先老老实实看部分分怎么做。当然，这很简单————模拟，用一个n^2的数组存一下图，对于操作1和2，每次O(1)进行修改，对于操作3，每次用O(n^2)进行查询。显然这个时间复杂度。。可能30分都拿不了。

还是想正解吧，（这也许是一道考思维的题（脑筋急转弯？！））。在不断的草稿和手算的时候，我们发现：

1.在i!=j的情况下，a[i][j]+a[j][i]和a[j][i]+a[i][j]都会被记录到，也就是说((a[i][j]×a[j][i])+(a[j][i]×a[i][j]))%2==0，对答案毫无影响。

2.在i==j的情况下，a[i][j]+a[j][i]就是a[j][i]+a[i][j]，而且只会记录一次，所以a[i][j]×a[j][i]%2对答案的影响即为a[i][j]本身。（注意只有0/1两种状态就好想了）

对于两个修改操作，不管是改行还是列，都只对对角线的一个元素造成影响（就是0变1,1变0）。

下面上代码：（对0/1的转换，我用的是+1%2）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,Q,t;
int ans;
int a,b;
int main()
{
	cin>>n>>Q;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>t;
			if(i==j)
			{
				ans+=t;
				ans%=2;
			}
		}
	while(Q--)
	{
		cin>>a;
		if(a==1||a==2)
		{
			cin>>b;
			ans+=1;
			ans%=2;
		}
		else
			cout<<ans;
	}
	return 0;
}
```

---

## 作者：Youngsc (赞：2)

[Youngsc](https://youngscc.github.io/)

题面花里胡哨，其实都是假的。。。

对于一个矩阵，将所有的$a[i][j]*a[j][i]$加起来后我们会发现，如果$i$和$j$不同的话，那么这个值将会对答案贡献两次，也就是说不管是$0$还是$1$,取膜之后一定是零，也就是对取膜之后的答案没有贡献。而如果$i$和$j$一样的话，当前答案只会被统计一次，因此其中的答案就是矩阵对角线的和取膜之后的值，如果对某一行某一列改变的话，一定会改变恰好一个对角线位置的值，因此答案一定会变化($1$变$0$或$0$变$1$)。所以只需要开五个变量就能解决这道题了。



## 代码在这里


```cpp
# include <bits/stdc++.h>
# define R register
# define LL long long
using namespace std;

int n,m,x,y;
bool ans;

int main(){
    in(n),in(m);
    for(R int i=1; i<=n; ++i)
        for(R int j=1; j<=n; ++j){
            in(x);
            if(i==j&&x) ans = !ans;
        }
    while(m--){
        in(x);
        if(x == 1||x == 2) in(y),ans = !ans;
        else printf("%d",ans);
    }
}

```

---

## 作者：Portland (赞：1)

我的题解和 @o0数学迷0o 的差不多，但是我有更加简便的方法。

把样例中的3*3数组A用字母表示

```
a b c
d e f
g h i
```

# 思考过程
那么G(A)= $a^2+bd+cg+db+e^2+fh+gc+hf+i^2$ 除以2的余数，也等于
$a^2+e^2+i^2+2bd+2cg+2fh$ 除以2的余数，根据余数的性质，和的余数等于余数的和，所以 G(A)= $a^2+e^2+i^2$除以2的余数加$2bd+2cg+2fh$除以2的余数，其中$2bd+2cg+2fh$除以2的余数一定是偶数，所以仅需$a^2+e^2+i^2$除以2的余数，如果一个加法算式中有偶数个奇数，则该算式的结果为偶数，否则是奇数，所以a,e,i（对角线）中有偶数个奇数时，算式结果就是偶数，否则是奇数。

# 写代码

代码中可以在输入时直接判断有几个奇数，用变量jg存储（读到一个奇数就jg=!jg）每一次转换操作可以看作把一个对角线上的奇数变成偶数或把一个偶数变成奇数，也就是改变奇数的个数（+1或-1），就是把奇数的奇偶个数换一下（jg=!jg），每一次问结果就可以直接给出结果

上代码
```
#include<iostream>
using namespace std;

int n,q;
int a[1005];
bool jg=false;
int rubbish;
int x,y;

int main(){
	int i,j;
	cin>>n>>q;
	for(i=0;i<n;i++){
		for(j=0;j<n;j++){
			cin>>rubbish;
			if(i==j){
				if(rubbish)
					jg=!jg;
			}
		}
	}
	
	for(i=0;i<q;i++){
		cin>>x;
		if(x==3)
			cout<<jg;
		else{
			cin>>y;
			jg=!jg;
		}
	}
	return 0;
}
				
```




---

## 作者：小罐猹 (赞：1)

其实吧。。。这题并不难。。。G函数就是只加那些对角线的数，在TLE一遍后发现原来1操作和2操作根本不用全部变，只需要将第x行的第x个变一下就行了。（我四一名蒟蒻，大佬们别巢笑~~）
因为本人太菜了，居然不会使MarkDown，请大家点击下方链接看题解。（逃）
https://www.luogu.org/paste/cs6lo27e

---

## 作者：brealid (赞：1)

这题这么~~无聊~~，亏我还用了读入输出优化。。。

关键在于，这还是道黄题QWQ

掀桌而起 (╯‵□′)╯︵┻━┻

~~显而易见~~，在``i != j``的情况下，``a[i][j] + a[j][i]``和``a[j][i] + a[i][j]``都会被记录到，so ``(a[i][j] * a[j][i]) + (a[j][i] * a[i][j]) mod 2``对答案毫无影响。

在``i = j``的情况下，``a[i][j] + a[j][i]``就是``a[j][i] + a[i][j]``，而且只会记录一次，so ``a[i][j] * a[j][i] mod 2``对答案的影响即为``a[i][i]``本身(``1 * 1 = 1, 0 * 0 = 0``)。

先上读入代码：
```cpp
int n = readint(), q = readint(); // n, q即为题目中的含义，"readint()"是我自己写的读入优化函数
bool ans = false; // 因为是要"mod 2", 所以一个bool变量就够了
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
    	if (i == j) {
    		if (readint()) ans = !ans; // i = j, 且值为1，则对答案有“1”的影响
    	}
		else readint(); // i != j, 对答案无影响
	}
}
```
那么后面的q个操作，可以这样看：

> 因为当操作值为1 or 2时，翻转了1列或1行，所以只对对角线有一次的影响，则对答案有“1”的影响

```cpp
if (readint() == 3) writeint(ans); //输出
else readint(), ans = !ans; //操作值为1 or 2
```

完整代码：
```cpp
#include <stdio.h>
#define Char_Int(a) ((a) - '0')
#define Int_Char(a) ((a) + '0')

int readint();
int writeint(int);

int main()
{
    int n = readint(), q = readint();
    bool ans = false;
    for (int i = 0; i < n; i++) {
    	for (int j = 0; j < n; j++) {
    		if (i == j) {
    			if (readint()) ans = !ans;
    		}
			else readint();
		}
	}
	for (int i = 0; i < q; i++) {
		if (readint() == 3) writeint(ans);
		else readint(), ans = !ans;
	}
}

inline int readint()       
{
    char c = getchar();
    while (c > '9' || c < '0') c = getchar();
    int init = Char_Int(c);
    while ((c = getchar()) <= '9' && c >= '0') init = (init << 3) + (init << 1) + Char_Int(c);
    return init;
}

inline int writeint(int x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) writeint(x / 10);
    putchar(Int_Char(x % 10));
    return x; 
}
```

---

## 作者：tcswuzb (赞：0)

## 无耻的安利一发博客 ： [blog](https://www.luogu.org/blog/LovToLZX/)

## 题目描述

小Z最近迷上了矩阵，他定义了一个对于一种特殊矩阵的特征函数G。对于N*N的矩阵A，A的所有元素均为0或1，则G(A)等于所有A[i][j]*A[j][i]的和对2取余之后的结果。举一个例子：

![矩阵](https://cdn.luogu.com.cn/upload/pic/1241.png)

对于上图这个3*3矩阵A，G(A)=(1*1+1*0+1*1+0*1+1*1+1*0+1*1+ 0*1+0*0) mod 2=0

当然询问一个矩阵的G值实在是太简单了。小Z在给出一个N*N矩阵的同时将给你Q个操作，操作描述如下：

操作1：形如一个整数1和一个整数x，表示将第x行的元素全部“翻转”。

操作2：形如一个整数2和一个整数x，表示将第x列的元素全部“翻转”。

操作3：形如一个整数3，表示询问当前矩阵的特征值G。

“翻转”的定义为将1变成0，将0变成1。

## 输入格式：

第1行：两个正整数N，Q。 N表示矩阵的行数(列数)，Q表示询问的个数。

接下来N行：一个N*N的矩阵A，0<=A[i][j]<=1。

接下来Q行：Q个操作。

## 输出格式：


一行若干个数，中间没有空格，分别表示每个操作的结果（操作1和操作2不需要输出）。

-------------------------------------吐槽时间------------------------------------------

一开始以为这道题可以暴力水过的 可是 [被水了](https://www.luogu.org/record/show?rid=10455441)

后来~~看了题解之后~~经楼下dalao提醒

对角线两边的元素 被重复计算了两次

### 所以只有对角线上的元素会产生贡献

那么每次修改只修改对角线上的元素

求和同理

这样的话时间复杂度就有 O(n^2*k)--->O(nk)

应该可以通过吧 ？？？？

# CODE：

```cpp
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define M 1008611
#define D double
#define ull unsigned long long
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐-------------*/
int num[1010][1010];
int n,Q;
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    read(n);read(Q);
    for(R int i=1;i<=n;++i)
     for(R int j=1;j<=n;++j)
      read(num[i][j]);
    while(Q--)
	{
		int key,now;
		read(key);
		if(key==3)
		{
			int ans=0;
			for(R int i=1;i<=n;++i)
			 ans+=(num[i][i]*num[i][i]);
			printf("%d",ans&1); 
		}
		if(key==2)
		{
			read(now);
			num[now][now]^=1;
		}
		if(key==1)
		{
			read(now);
			num[now][now]^=1;
		}
	}  
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

注：本题一大坑点：在线输出不用换行~~什么鬼~~

## NOIP 2018 RP++

---


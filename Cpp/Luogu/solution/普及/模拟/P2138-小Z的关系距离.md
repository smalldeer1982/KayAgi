# 小Z的关系距离

## 题目描述

小 Z 学习了辩证唯物主义，知道了联系具有普遍性。他看着草稿纸上的字符串，就想挖掘它们之间的关系。

小 Z 认为，对于两个字符串 $a,b$，如果它们各自删除不超过其自身长度一半的字符能够相等，则称 $a,b$ 有距离为 $1$ 的关系。而如果存在另一个字符串 $c$，它和 $a$ 有距离为 $1$ 的关系，和 $b$ 有距离为 $n$ 的关系，则称 $a,b$ 有距离为 $n + 1$ 的关系。

现在小 Z 随机挑选出了两个小写字母字符串 $a,b$，想知道它们之间关系的最小距离，希望你帮帮他。

## 说明/提示

对于 $30\%$ 的数据，$a,b$ 由同一字母构成。

对于 $100\%$ 的数据，$1 \leq |a|,|b| \leq 100$。

## 样例 #1

### 输入

```
abcdef
axcyd```

### 输出

```
1```

## 样例 #2

### 输入

```
a
b```

### 输出

```
2```

## 样例 #3

### 输入

```
abb
baa```

### 输出

```
2```

# 题解

## 作者：Math_rad_round (赞：18)

为讨论方便，我们令下文中 $|a|\geq|b|$

------------

**对 a、b，如果它们各自删除不超过其自身长度一半的字符能够相等**
也就意味着 **a** 剩下的字符串和 **b** 剩下的字符串是相等的，即:

距离为 $1$ **等价于** 最长公共子序列长度 $ \geq\frac{|a|}{2}$

同时也可以推断出，如果我们在 **b** 中随便插入
$|b|$  个字符，得到的字符串仍然和 **b** 距离为 $1$

那么我们可以不断地往 **b** 上插入 $|b|$ 个字符，也就使最长公共子序列长度增加了 $|b|$，同时 $|b|$ 也翻了一倍

直到最长公共子序列长度达到 $\frac{|a|}{2}$ ，这时只需要再有一次操作即可完成

时空复杂度均为 $O(|a||b|)$，也就使求最长公共子序列。


注意：两字符串相等时答案为 $1$

------------

代码：

```cpp
#include<iostream>
using namespace std;
string a,b;
int f[300][300];
int main(){
	cin>>a>>b;
	int n=a.length(),m=b.length();
	if(n<m){
		swap(n,m);swap(a,b);
	}
	if(a==b){//特判相等 
		cout<<"1";return 0;
	}
	int ans=0;
	for(int i=1;i<=n;i++){//求最长公共子序列
		for(int j=1;j<=m;j++){
			f[i][j]=max(f[i-1][j],f[i][j-1]);
			if(a[i-1]==b[j-1])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
			ans=max(f[i][j],ans);
		}
	}
	int cnt=0;
	while(ans*2<n){
		cnt++;ans+=m;m+=m;
	}cnt++;
	cout<<cnt;
	return 0;
}
```


---

## 作者：__JiCanDuck__ (赞：4)

### 思路
和前几个篇题解一样，我来整合一下。我们把长的叫做 $A$，短的叫做 $B$。如果 $A$，$B$ 的最长 LCS $\times $ 大于 $A$ 长度的一半，那么距离为 1。

当$B$的长度乘 $2$ (加上 $B$ 的长度个字母)，那么和原 $B$ 的距离加 1，和 $A$ 的 LCS 也加 1 ，直到满足要求。


展示一下代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int K=105;
int dp[K][K];
string aa,bb;
int n,m,lcs,cnt;
int main()
{
  cin>>aa>>bb;
  n=aa.size(),m=bb.size();//求出两个字符串的长度。
  aa=" "+aa; //在前面加上空格，方便一点。
  bb=" "+bb;
  if(m>n) //如果bb的长度>aa的长度 交换两个。
  {
    swap(aa,bb);
    swap(n,m);//长度交换不要忘记。
  }
  for(int i=1;i<=n;i++) //求LCS，dp[i][j]表示将a的前i个和b的前j个的LCS有多少。
    for(int j=1;j<=m;j++)
    {
      if(aa[i]==bb[j])//这两个相等，lcs++。
        dp[i][j]=dp[i-1][j-1]+1;  
      else
        dp[i][j]=max(dp[i-1][j],dp[i][j-1]);//不是，从两个中选大的。
    }
  lcs=dp[n][m]; //dp[n][m]就是lcs了。
  while(lcs*2<n)
  {
    cnt++;//记录加了一次。
    lcs+=m;//只要加和A相等的b个字符，LCS+=B。
    m+=m;//b长度++。
  }
  cnt++;//距离=n+1。
  cout<<cnt;
  return 0;
}
```

LCS：longest common subsequence，也就是最长公共子序列。

---

## 作者：X_SpiderMan (赞：3)

做这道题我们先要熟悉 [最长公共子序列（LCS）](https://baike.baidu.com/item/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/8010952?fromtitle=LCS&fromid=33958)。大家对最长公共子序列有了一定的认知后，自己就可以看出本题的解题思路。

## **正文**：
题意上面的大佬们以为大家分析透彻，此文不在具体展开。

下面讲思路：

注：本文设置 $a|s|\le b|s|$。

那么先做个预处理，设置通过比较调换使 $a|s| \le b| s |$。 

然后通过题意可知 $LCS|s| \ge a|s| \div\ 2$ 距离才可为 $1$。

当 $b| s | \times 2$ 时，与原字符串 $b$ 的距离 $+1$，与 $a$ 的 $Lcs+1$。

若满足要求，结束程序。

---

## AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int f[105][105],ans,cnt,n,m;
int main(){
	cin>>a>>b;
	n=a.size(),m=b.size();
	if(n<m) swap(n,m),swap(a,b);
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			f[i][j]=max(f[i-1][j],f[i][j-1]);
			if(a[i-1]==b[j-1]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);
			ans=max(f[i][j],ans);
		}
	while(ans*2<n){
		cnt++;
        ans+=m;
        m*=2;
	}
    cnt++;
	cout<<cnt;
	return 0;
}
```

抄袭代码可耻，请勿抄袭代码！

---

## 作者：killer_queen4804 (赞：2)

**这篇题解的思路和第一篇一样，只不过稍微解释了一下**

这一题直接一眼最长公共子序列，然后我就天真的以为只要最长公共子序列大于等于 $\frac{n}{2}$ 且大于等于 $\frac{m}{2}$ 就是 $1$，不然就是 $2$，因为总有串是可以把他们连起来的，但我错了，，，我忘了 $a$ 很长，$b$ 很短的情况了(废物啊这是，，，)，所以我们求出最长公共子序列还不够，还要让 $b$ 加长到 $a$ 去掉一半可以相等的地步，就如下图这样，所以他们的距离为 $4$ ，当 $b$ 很大， $a$ 很小的时候同理

------------
![](https://cdn.luogu.com.cn/upload/image_hosting/l1b34gkk.png?x-oss-process=image/resize,m_lfit,h_500,w_500)

------------
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll inf=1e16;
const ll mod=1e9+7;
const ll N=1e5;
ll n,m,dp[110][110],maxx,minn;
string s,t;
int main(){
	//freopen("in.txt","r",stdin);
	cin>>s;n=s.size();
	cin>>t;m=t.size();
	s=" "+s;t=" "+t;
	maxx=max(n,m);minn=min(n,m);
	for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    if(s[i]==t[j]) dp[i][j]=dp[i-1][j-1]+1;
    else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
    //cout<<dp[n][m]<<endl;
    ll ans=1,lcs=dp[n][m];
    while(lcs*2<maxx){
        ans++;lcs+=minn;minn+=minn;
    }
    printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：Atserckcn (赞：1)

## [P2138 小Z的关系距离](https://www.luogu.com.cn/problem/P2138) 题解

### 题目简述：

以下称字符串 $s1,s2$ 的最长公共子序列为 $\operatorname{LCS(s1,s2)}$，字符串 $s1$ 的长度为 $|s1|$，且 $|s1|\ge |s2|$，$s1$ 与 $s2$ 的关系距离为 $dis(s1,s2)$。

若 $\operatorname{LCS(s1,s2)}\ge \frac{|s1|}{2}$，则 $dis(s1,s2)=1$。

有三个字符串 $s1,s2,s3$，若 $dis(s1,s2)=a,dis(s2,s3)=b$，则 $dis(s1,s3)=a+b$。

给定两个字符串 $s1,s2$，求它们俩的关系的最小值。

### 思路简述

首先，若满足 $\operatorname{LCS(s1,s2)}\ge \frac{|s1|}{2}$，则直接输出 $1$。

接着，我们想到，不管在字符串 $s2$ 上插入多少个字符，$\operatorname{LCS(s1,s2)}$ 不变。

这样，我们就可以不断地往 $s2$ 上面插入字符，直至插不进去为止。

判断方法：再插一次就超过了 $\frac{|s1|}{2}$。

### 代码

带注释代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXSIZE=105;
int s1_size,s2_size,ans,sum;
string s1,s2;
int f[MAXSIZE][MAXSIZE];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>s1>>s2;
	s1_size=s1.size();
	s2_size=s2.size();
	if(s1==s2)//特判
	{
		printf("1\n");
		return 0;
	}
	if(s1_size<s2_size)//大的匹配小的 
	{
		swap(s1,s2);
		swap(s1_size,s2_size);
	}
	for(int i=1;i<=s1_size;i++)//基础dp，求LCS(s1,s2)
	{
		for(int j=1;j<=s2_size;j++)
		{
			f[i][j]=max(f[i-1][j],f[i][j-1]);
			if(s1[i-1]==s2[j-1])
				f[i][j]=max(f[i][j],f[i-1][j-1]+1);
			ans=max(ans,f[i][j]);
		}
	}
	while(ans*2<s1_size)
	{
		sum++;
		ans+=s2_size;//目前插了多少进去？
		s2_size=s2_size<<1;//相当于 s2_size-s2_size*2
	}
	sum++;//最后一次不能忘
	printf("%d\n",sum);
	return 0;
}

---

## 作者：tmpliyijiang (赞：0)

## 前置知识：LCS（最长公共子序列）
描述：给定 $2$ 个字符串 a 和 b，求它们的最长公共子序列的长度。

dp 式：
$$F_{i,j}= \max \begin{cases}f_{i-1,j}\\ f_{i,j-1}\\f_{i-1,j-1}+1 &if& a_i=b_j \end{cases}$$

代码：

```cpp
inline int LCS(string a,string b){
	int cnt=0,l_a=a.size(),l_b=b.size();
	for(register int i=1;i<=l_a;i++){
		for(register int j=1;j<=l_b;j++){
			f[i][j]=max(max(f[i-1][j],f[i][j-1]),f[i][j]);
			if(a[i-1]==b[j-1])
				f[i][j]=max(f[i-1][j-1]+1,f[i][j]);
			cnt=max(cnt,f[i][j]);
		}
	}
	return cnt;
}
```

## 思路

为方便叙述，设 $n$ 为 $\max(\lvert a\rvert ,\lvert b\rvert)$，$m$ 为 $\min(\lvert a\rvert ,\lvert b\rvert)$，$lcs$ 为 a 与 b 的最长公共子序列的长度。

对于每次操作，我们可以在较短的字符串中任意添加至多 $m$ 个字符，可以使得新字符串与其距离仍为 $1$，并且尽可能使新字符串与较长字符串的最长公共子序列更长。

所以，对于每次操作，我们可以：

1.$lcs \gets lcs+m$

2.$m\gets 2\times m$

重复执行直到 $n-lcs\times 2 \le n\div 2$。

时间复杂度为 $O(nm)$。

更多见代码注释。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[105][105],cnt;//f 数组用来算 LCS 值，cnt 为操作次数，main 函数外初值为 0
string a,b;
inline int LCS(string a,string b){//LCS 板子
	int cnt=0,l_a=a.size(),l_b=b.size();
	for(register int i=1;i<=l_a;i++){
		for(register int j=1;j<=l_b;j++){
			f[i][j]=max(max(f[i-1][j],f[i][j-1]),f[i][j]);
			if(a[i-1]==b[j-1])
				f[i][j]=max(f[i-1][j-1]+1,f[i][j]);
			cnt=max(cnt,f[i][j]);
		}
	}
	return cnt;
}
int main(){
	cin>>a>>b;
	int lcs=LCS(a,b),l_a=a.size(),l_b=b.size(),l_max=max(l_a,l_b),l_min=min(l_a,l_b);
	if((lcs<<1)<l_max)//特判，若距离不为 1 才进行操作，不判得 80pts
		while((lcs<<1)<l_max)
        		cnt++,lcs+=l_min,l_min<<=1;//操作
	printf("%d\n",cnt+1);
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P2138)

# First 题意

题目的意思是，定义如果两个字符串的最长公共连续子序列长度大于 $\frac{|a|}{2}$ 和 $\frac{|b|}{2}$ 的话，那么两个字符串的距离为 $1$ ，并且如果字符串 $a$ 和字符串 $b$ 的距离为 $n$，字符串 $b$ 和字符串 $c$ 的距离为 $1$，那么字符串 $a$ 和字符串 $c$ 的距离为 $n + 1$（$a,b,c$ 都是字符串）。

题目给你两个字符串，让你求他们的距离。

# Seond 思路

如果要求 $a$ 和 $b$ 的距离，就要找到一个中间字符串 $c$ ，就必须先求 $a$ 和 $b$ 的最长公共连续子序列，这部分可以用 ```dp``` 来处理。

接下来就可一直增加字符，直到最长公共连续子序列的长度比 $\frac{|a|}{2}$ 和 $\frac{|b|}{2}$ 长即可。

# Third Code

```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
using namespace std;
#define ll long long
#define il inline
string s, t;
ll n, m, f[505][505], ans;
int main(){
	cin >> s >> t;
	n = s.size(), m = t.size();
	if (s == t){
		printf ("1");
		return 0;
	}
	if (n < m) swap(s, t), swap(n, m);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			if (s[i - 1] == t[j - 1]) f[i][j] = f[i - 1][j - 1] + 1;
			f[i][j] = max(f[i][j], max(f[i - 1][j], f[i][j - 1]));
			ans = max(ans, f[i][j]);
		}
	}
	ll tot = 0;
	while (ans * 2 < n) tot++, ans += m, m *= 2;
	printf ("%lld", tot + 1);
	return 0;
}

```

---

## 作者：c_y_y (赞：0)

关于 LCS 的 dp 部分前面的 dalao 们已经说的很清楚了。

但关于插入 $|b|$ 的那一部分讲的不是很清楚。~~因此本人来发一片题解。~~

------------
当我们在求完 LCS 后（我们令其为 $cnt$）最大的问题是这关系距离的增长。

我们令 $|a|≥|b|$。如果 $cnt≥\lfloor\frac{|a|}{2}\rfloor$，那么问题就结束了。

#### 但小于呢？

结合样例 2：我们可以发现如果两个字符串的关系距离不等于一，那么**就需要一个中转站**（我们设该字符串为  $temp$）。

样例2中，中转站 $temp$ 就可以是`ab`。注意，$temp$ 并不唯一。


------------
也就是说，我们可以将 $b$ 复制给 $temp$，这样我们就能直接在 $temp$ 上添加至多 $|b|$ 个字符就可以了（因为如果插入的字符大于 $|b|$ 个， $b$ 和 $temp$ 没有直接关系了）

由此我们又可以得出，将 $temp$ 中插入的字符一定是 $a$ 里面的，这样 $temp$ 和 $a$ 的 LCS 就会增加，而我们只要保证插入的字符不多于 $|b|$ 个字符就行了。

如果插入 $|b|$ 个字符后，$temp$ 和 $a$ 还是没有直接关系，那就再来一个中转站，以此类推。

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int f[300][300];//求LCS
int main(){
	cin>>a>>b;
	int n=a.length(),m=b.length();
	if(n<m)
		swap(n,m),swap(a,b);//保证|a|>=|b|;
	if(a==b){//特判
		cout<<"1";return 0;
	}
	//LCS模板
	int cnt=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=max(f[i-1][j],f[i][j-1]);
			if(a[i-1]==b[j-1])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
			cnt=max(f[i][j],cnt);
		}
	}
	//建立中转站
	int ans=1;//一开始关系距离为1
	while(cnt*2<n){ //只要LCS<|a|/2就建立中转站
		ans++; //中转站++
		cnt+=m; //LCS增加的长度
		m*=2; //这里将m直接覆盖成中转站，长度*=2
	}
	cout<<ans;
	return 0;//养成**好习惯
}
```
本蒟蒻的第二篇题解，多多支持～

---

## 作者：QianRan_GG (赞：0)

## 题目大意

给出两个字符串 $a,b$，求其最小关系距离。

设 $ |a| > |b| $（$|s|$ 表示 $s$ 字符串的长度），判断其相等的字符个数是否不少于 $\dfrac{|a|}{2}$，若是则它们的关系距离为 $1$。反之若有字符串 $c$ 与 $a$ 的关系距离为 $1$，与 $b$ 的关系距离为 $n$，则 $a$ 与 $b$ 的关系距离为 $n+1$。

## 解题思路

此题是一道动态规划题，但是加上了字符串，使得其思路较难想。

我本来想动规求 $a$ 与 $b$ 的相等字符串个数，设为 $ans$，若 $ans < \dfrac{|a|}{2}$，就将 $\dfrac{|a|}{2}$ 个在 $a$ 中与 $b$ 不等的字符插入 $b$ 中，然后重复上述步骤直到 $ans \geq \dfrac{|a|}{2}$，再算出上述步骤的次数。

其实这题没有那么麻烦。我们根本不需要往 $b$ 中插入字符，因为每一次插入 $|b|$ 个字符最好，那么我们只用设一个变量 $cnt$ 记录操作个数，每次将 $ans$ 加上 $|b|$ 再将 $|b| \times 2$ 即可。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[201][201];
string a,b;
signed main(){
	cin>>a>>b;
	if(a==b){ //若两个字符串相等则直接输出1
		cout<<1;
		return 0;
	}
	int la=a.size(),lb=b.size(),ans=0;
	//  a串长度      b串长度     最大相同字符个数
	if(la<lb){ //本做法需要保证|a|>=|b|才可以做
		swap(a,b);
		swap(la,lb);
	}
	
	//dp求a与b的最大相同字符个数，用ans存储
	for(int i=1;i<=la;++i){
		for(int j=1;j<=lb;++j){
			dp[i][j]=max(dp[i-1][j],dp[i][j-1]); //若a[i-1]!=b[j-1]则要么改a[i-1],要么改b[j-1]
			if(a[i-1]==b[j-1]){
				dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1); //若两者相等就不说了（大家应该看得懂）
			}
			ans=max(ans,dp[i][j]); //ans存储
		}
	}
	
	//“插入”操作
	int cnt=1; //记录操作次数
	while(ans*2<la){
		cnt++;
		ans+=lb;
		lb*=2;
	}
	
	cout<<cnt;
	return 0;
}
```


---

## 作者：yangyang1000 (赞：0)

为方便讲述，我们设：$size(A)$ 表示字符串 $a$ 的长度。

两个字符串中字符串 $A$ 较短，字符串 $B$ 较长，也就是 $size(A) < size(B)$。

------------

这是一道最长公共子序列（LCS）的好题。

我们什么时候两个字符串的距离为 $1$ 呢？很显然是最长公共子序列的距离小于 $size(A)$。

如果距离大于 $1$ 呢？我们就找一个和字符串 $B$ 距离为 $1$ 的。

很明显可以找到一个序列 $C$，让 $C$ 在 $B$ 的基础上再增加 $size(B)$ 个字符，使得 $B$ 和 $C$ 的最长公共子序列增加 $size(B)$。

此时 $B$ 和 $C$ 的距离为 $1$，问题就变成了求 $A$ 和 $C$ 的距离。

我们针对 $A$ 和 $C$ 使用同样的方法找到 $C'$，再找到 $C''$，以此类推直到 $A$ 和那个字符串的距离为 $1$。

时间复杂度：$O(size(a) \times  size(b))$

code:

```cpp
#include<iostream>
#include<cstring>
using namespace std;

string a,b;
int lena,lenb,dp[105][105],ans,lcs;

int main()
{
	cin >> a >> b;
	lena = a.size();
	lenb = b.size();
	a = " " + a;
	b = " " + b;
	
	if(lena < lenb)
	{
		swap(a,b);
		swap(lena,lenb);
		//如果长度反过来了就要交换
		//为了保证a的长度比b长 
	}
	
	for(int i=1;i<=lena;i++)
		for(int j=1;j<=lenb;j++)
		{	
			if(a[i] == b[j]) dp[i][j] = dp[i-1][j-1] + 1;
			else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
		}
	
	lcs = dp[lena][lenb];
	while(lcs * 2 < lena)
	{
		ans++;
		lcs += lenb;
		lenb += lenb;//b的长度倍增 
	}
	
	printf("%d",ans+1);
	return 0;
} 
```

---

## 作者：_Joseph_ (赞：0)

# P2138 题解

## 题目分析

首先我们读题可以知道题意是给定两个字符串 $a$ 和 $b$，让我们求它们之间关系的最小距离。其中，如果两个字符串各自删除不超过其自身长度一半的字符能够相等，则称 $a$ 和 $b$ 有距离为 $1$ 的关系。而如果存在另一个字符串 $c$，它和 $a$ 有距离为 $1$ 的关系，和 $b$ 有距离为 $n$ 的关系，则称 $a$ 和 $b$ 有距离为 $n + 1$ 的关系。

现在给定两个小写字母字符串 $a$ 和 $b$。问它们之间关系的最小距离。

## 思路

我们读完题后可以发现这是一个 dp（动态规划）问题。

所以我们可以定义一个数组 $f_{i,j}$，表示字符串 $a$ 的前 $i$ 个字符和字符串 $b$ 的前 $j$ 个字符的最长公共子序列。然后，我们可以根据最长公共子序列的定义来进行状态转移。

当 $a[i] = b[j]$ 时就需要让：

```cpp
f[i][j] = max(f[i - 1][j - 1] + 1)
```

### 代码实现：

```cpp
if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
```

既然有  $a[i] = b[i]$ 的情况就会有 $a[i] \neq  b[i]$ 的情况，我们应该怎么办呢？

在 $a[i] = b[j]$ 时需要加 $1$ 那 $a[i] \neq  b[i]$ 时就不加 $1$ 就好了。

### 代码实现：

```cpp
if (a[i] != b[j])  f[i][j] = max(f[i-1][j], f[i][j-1]);
```


最后，我们可以根据最长公共子序列的长度来计算出 $a$ 和 $b$ 之间关系的最小距离啦。

## 总结：

我们可以不断地将较短的字符串复制一遍并加到原字符串后面，直到最长公共子序列的长度大于等于新字符串长度的一半为止。

此时，$a$ 和 $b$ 之间关系的最小距离即为复制的次数加一。

## 代码实现：

```cpp
#include <bits/stdc++.h>
using namespace std;
string a, b;
int f[300][300];
int main() {
    cin >> a >> b;//数据不大 cin 、cout 就可以;
    int n = a.length(), m = b.length();\\计算长度;
    if(n < m) {
        swap(n, m);//交换函数
        swap(a, b);
    }
    if(a == b) {//特判相等 
        cout << "1";
        return 0;
    }
    int ans = 0;
    for(int i = 1; i <= n; i++) {//求最长公共子序列
        for(int j = 1; j <= m; j++) {
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            if(a[i - 1] == b[j - 1]) f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
            ans = max(f[i][j], ans);
        }
    }
    int cnt = 0;
    while(ans * 2 < n) {//计算答案;
        cnt++;
        ans += m;
        m += m;
    }
  	 cnt++;
    cout << cnt;
    return 0;
}
```

~~看完了不要吝啬自己的赞哦QWQ。~~

[AC 记录 >_<](https://www.luogu.com.cn/record/120752027)

---


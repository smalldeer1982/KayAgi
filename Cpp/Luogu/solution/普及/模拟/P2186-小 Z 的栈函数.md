# 小 Z 的栈函数

## 题目描述

小 Z 最近发现了一个神奇的机器，这个机器的所有操作都是通过维护一个栈来完成的，它支持如下 11 个操作：

- $\texttt{NUM} ~x$：栈顶放入 $x$。
- $\texttt{POP}$：抛弃栈顶元素。
- $\texttt{INV}$：将栈顶元素取出，然后放入它的相反数。
- $\texttt{DUP}$：再放入一个和栈顶元素相同的数。
- $\texttt{SWP}$：交换栈顶的两个元素。
- $\texttt{ADD}$：取出栈顶的两个元素，两元素相加，所得结果放入栈内。
- $\texttt{SUB}$：取出栈顶的两个元素，第二个元素减去第一个元素，所得结果放入栈内。
- $\texttt{MUL}$：取出栈顶的两个元素，两元素相乘，所得结果放入栈内。
- $\texttt{DIV}$：取出栈顶的两个元素，第二个元素整除以第一个元素，所得结果放入栈内。
- $\texttt{MOD}$：取出栈顶的两个元素，第二个元素取模以第一个元素，所得结果放入栈内。
- $\texttt{END}$：结束这个程序。

然后，小 Z 用上面的 11 种操作写了一个一元函数 $f(x)$。$x$ 就是放入栈里面第一个初始元素。然后经过这个函数的一系列操作，当函数结束的时候，正常情况下，栈里面会有唯一的一个元素。剩下的这个元素就作为函数 $f(x)$ 的返回值。

小 Z 有 $n$ 个询问，询问每个值 $x$ 经过上述函数所映射出的 $f(x)$ 是多少。但是这个由于机器太老了，跑起东西来太慢了，小 Z 又是一个急性子，所以请你们写一个程序，来帮助小 Z 计算他查询的 $f(x)$。

还有，由于这台机器太破了，所以如果运算过程中有数字的绝对值大于 $1000000000$，机器将产生故障。


## 说明/提示

### 数据规模与约定

对于全部测试点，保证函数的操作步数不超过 $2000$，$1 \leq n \leq 2000$，$|x| \leq 10^{9}$。


## 样例 #1

### 输入

```
NUM 600000000
ADD
END
3
0
600000000
1
```

### 输出

```
600000000
ERROR
600000001```

# 题解

## 作者：Lips (赞：23)

# 做了一下午，一次就 $AC$。

先总结一下坑点&$RE$原因：

1. 开 $long\space long$，万年老坑。

2. `DIV`操作一定要判断除数是否为 $0$。

3. 输入的 $x$ 一定要 $push$ 到栈里~~卡了我 $\sout{1h}$~~。

接下来就是~~万恶的~~模拟了：

先看输入部分：

可以将 $step$ 数组来记录操作序列，$num$ 来记录 `NUM` 操作中的 $x$，当然，$cnt$ 要记录操作的次数，一直输入直到碰到`END`操作。

然后便是函数 $f(x)$，按照题意模拟即可，不过对于有加减乘除的操作，一定要判断结果是否大于 $1000000000$，若大于，我的做法是将此函数返回一个特殊值。另外，在取栈顶元素时，要先判断一下栈内元素是否足够。

最后就是代码惹：

```cpp
#include<cstdio>
#include<stack>
#include<cmath>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;//开long long 
const int MAXN=2010;
string step[MAXN];//操作序列 
ll n,num[MAXN],x,cnt;
//n，NUM操作的x，输入的x，操作总数。 
stack<ll>st;//STL大法吼！ 
inline ll read()//快读 
{
    ll s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
    return s*w;
}
bool check(ll x)//判断x是否超出范围 
{
    return abs(x)>1000000000;
}
ll error()//懒
{
    printf("ERROR\n");
    return 5201314;//这是特殊值。 
}
ll f(ll x)//f函数 
{
    while(!st.empty()) st.pop();//先清空栈 
    st.push(x);//一定要push！ 
    for(register ll i=1;i<cnt;i++)//从头到尾(cnt-1)遍历操作序列 
    {
    	//下面就不细说了 
        if(step[i]=="NUM")
        {
            if(check(num[i])) return error();
            st.push(num[i]);
        }
        if(step[i]=="POP")
		{
			if(st.empty()) return error();
			st.pop();
		 } 
        if(step[i]=="INV")
        {
        	if(st.empty()) return error();
            ll now=-st.top();
            st.pop();
            st.push(now);
        }
        if(step[i]=="DUP")
        {
        	if(st.empty()) return error();
            ll now=st.top();
            st.push(now);
        }
        if(step[i]=="SWP")
        {
        	if(st.size()<2) return error();
            ll x1=st.top();
            st.pop();
            ll x2=st.top();
            st.pop();
            st.push(x1);
            st.push(x2);
        }
        if(step[i]=="ADD")
        {
        	if(st.size()<2) return error();
            ll x1=st.top();
            st.pop();
            ll x2=st.top();
            st.pop();
            ll ans=x1+x2;
            if(check(ans)) return error();
            st.push(ans);
        }
        if(step[i]=="SUB")
        {
        	if(st.size()<2) return error();
            ll x1=st.top();
            st.pop();
            ll x2=st.top();
            st.pop();
            ll ans=x2-x1;
            if(check(ans)) return error();
            st.push(ans);
        }
        if(step[i]=="MUL")
        {
        	if(st.size()<2) return error();
            ll x1=st.top();
            st.pop();
            ll x2=st.top();
            st.pop();
            ll ans=x1*x2;
            if(check(ans)) return error();
            st.push(ans);
        }
        if(step[i]=="DIV")
        {
        	if(st.size()<2) return error();
            ll x1=st.top();
            st.pop();
            ll x2=st.top();
            st.pop();
            if(x1==0) return error();//一定要判除数！ 
            ll ans=x2/x1;
            if(check(ans)) return error();
            st.push(ans);
        }
        if(step[i]=="MOD")
        {
        	if(st.size()<2) return error();
            ll x1=st.top();
            st.pop();
            ll x2=st.top();
            st.pop();
            ll ans=x2%x1;
            if(check(ans)) return error();
            st.push(ans);
        }
    }
    if(st.size()!=1) return error();//看看栈的最后大小 
    else return st.top();
}
int main()
{
    for(cnt=1;;cnt++)
    {
        cin>>step[cnt];
        if(step[cnt]=="NUM") num[cnt]=read();
        if(step[cnt]=="END") break;
    }
    n=read();
    for(register ll i=1;i<=n;i++)
    {
        x=read();
        x=f(x);
        if(x!=5201314) printf("%lld\n",x);//输出 
    }
    return 0;//完结撒花~~ 
}

```
点个赞再走呗QAQ

---

## 作者：pengym (赞：10)

##.
这是我随机跳题跳到的，看上去非常非常复杂，但仔细读了题之后，发现就是一个~~模拟水题~~（模拟工业题）于是我便用stl开始了模拟。本题最大的难处是：**判断是否合法**，其实有一个小技巧，就是在使用栈之前想一想需要几个元素，在调用**size函数**就可以了。在打程序的过程中还可以发现，其实并不是太麻烦，进行运算的操作可以直接**粘贴**后**改符号**就可以了。（不过要注意分清楚先后顺序）

PS:也就200行多一点罢了。（23333）

##.
下附代码：

```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<stack>
using namespace std;
inline void read(long long &x)
{
    x=0;
    long long p=1;
    char c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();}
    x*=p;
}
struct node
{
    string s;
    long long x;
}e[2100];
int cnt;
string c;
void fun(long long x)
{
    stack<long long>sta;
    if(abs(x)>1000000000)
    {
        printf("ERROR\n");
        return ;
    }
    sta.push(x);
    for(int i=1;i<=cnt;i++)
    {
        if(e[i].s=="NUM")
        {
            if(abs(e[i].x)>1000000000)
            {
                printf("ERROR\n");
                return ;
            }
            sta.push(e[i].x);
        }
        else if(e[i].s=="POP")
        {
            if(sta.empty())
            {
                printf("ERROR\n");
                return ;
            }
            sta.pop();    
        }
        else if(e[i].s=="INV")
        {
            if(sta.empty())
            {
                printf("ERROR\n");
                return ;
            }
            long long k=sta.top();
            sta.pop();
            sta.push(-k);
        }
        else if(e[i].s=="DUP")
        {
            if(sta.empty())
            {
                printf("ERROR\n");
                return ;
            }
            sta.push(sta.top());
        }
        else if(e[i].s=="SWP")
        {
            if(sta.size()<2)
            {
                printf("ERROR\n");
                return ;
            }
            long long tmp=sta.top();
            sta.pop();
            long long tmpp=sta.top();
            sta.pop();
            sta.push(tmp);sta.push(tmpp);
        }
        else if(e[i].s=="ADD")
        {
            if(sta.size()<2)
            {
                printf("ERROR\n");
                return;
            }
            long long tmp=sta.top();
            sta.pop();
            long long tmpp=sta.top();
            sta.pop();
            if(abs(tmpp+tmp)>1000000000)
            {
                printf("ERROR\n");
                return;
            }
            sta.push(tmp+tmpp);
        }
        else if(e[i].s=="SUB")
        {
            if(sta.size()<2)
            {
                printf("ERROR\n");
                return;
            }
            long long tmp=sta.top();
            sta.pop();
            long long tmpp=sta.top();
            sta.pop();
            if(abs(tmpp-tmp)>1000000000)
            {
                printf("ERROR\n");
                return;
            }
            sta.push(tmpp-tmp);
        }
        else if(e[i].s=="MUL")
        {
            if(sta.size()<2)
            {
                printf("ERROR\n");
                return;
            }
            long long tmp=sta.top();
            sta.pop();
            long long tmpp=sta.top();
            sta.pop();
            if(abs(tmpp*tmp)>1000000000)
            {
                printf("ERROR\n");
                return;
            }
            sta.push(tmp*tmpp);
        }
        else if(e[i].s=="DIV")
        {
            if(sta.size()<2)
            {
                printf("ERROR\n");
                return;
            }
            long long tmp=sta.top();
            sta.pop();
            long long tmpp=sta.top();
            sta.pop();
            if(tmp==0)
            {
                printf("ERROR\n");
                return;
            }
            if(abs(tmpp/tmp)>1000000000)
            {
                printf("ERROR\n");
                return;
            }
            sta.push(tmpp/tmp);
        }
        else if(e[i].s=="MOD")
        {
            if(sta.size()<2)
            {
                printf("ERROR\n");
                return;
            }
            long long tmp=sta.top();
            sta.pop();
            long long tmpp=sta.top();
            sta.pop();
            if(abs(tmpp%tmp)>1000000000)
            {
                printf("ERROR\n");
                return;
            }
            sta.push(tmpp%tmp);
        }
    }
    if(sta.size()==1)printf("%lld\n",sta.top());
    else printf("ERROR\n");
}
long long n;
int main()
{
//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);
    while(cin>>c)
    {
        if(c[0]=='E')break;
        cnt++;
        e[cnt].s=c;
        if(c=="NUM")
        {
            long long x;
            read(x);
            e[cnt].x=x;
        }
    }
    read(n);
    for(int i=1;i<=n;i++)
    {
        long long x;
        read(x);
        fun(x);
    }
    return 0;
}

```

---

## 作者：李尧 (赞：9)

emm,很多人说这题坑，其实个人觉得还好

~~毕竟开始把栈当队列做还能过4个点【手动滑稽】~~

唯一的难点就是判定什么时候属于错误的范畴

有以下几种情况：

1.取出一个或两个元素时栈内元素不够

2.除和膜的时候除或膜了0

3.运算过程中有数字的绝对值大于1000000000

4.最后栈内不是一个元素

以下代码

```
#include <bits/stdc++.h>
using namespace std;
long long int s[5007],p,n,head,tail,mx=1000000000,a[2007],cnt;//	长整型便于操作后在判定数字是否合法，避免爆int
string d[2007];
int doing(int p){
	head=1;tail=0;
	s[++tail]=p;
	for(int i=1;i<cnt;i++){
		if(d[i]=="NUM") s[++tail]=a[i];//添加元素
		if(d[i]=="POP") tail--;//删除元素
		if(d[i]=="INV")	s[tail]=-s[tail];//翻转
		if(d[i]=="DUP")	s[++tail]=s[tail];//添加相同元素
		if(d[i]=="SWP")	{
			if(tail==head) return -2000000000;
			swap(s[tail],s[tail-1]);//交换元素
		}	
		if(d[i]=="ADD")	s[tail-1]=s[tail]+s[tail-1],tail--;	//加法
		if(d[i]=="SUB")	s[tail-1]=s[tail-1]-s[tail],tail--;//减法
		if(d[i]=="MUL")	s[tail-1]=s[tail-1]*s[tail],tail--;//乘法
		if(d[i]=="DIV")	{
			if(s[tail]==0) return -2000000000;//判定2
			s[tail-1]=s[tail-1]/s[tail],tail--;	
		}//除法
		if(d[i]=="MOD")	{
			if(s[tail-1]==0) return -2000000000;//判定2
			s[tail-1]=s[tail-1]%s[tail],tail--;		
		}//取膜
		if(head>tail||s[tail]>mx||s[tail]<-mx) return -2000000000;//判定1，3
	}
	if(head==tail) return s[head];//判定4
	return -2000000000;
}
int main(){
	while(cin>>d[++cnt]&&d[cnt]!="END"){
		if(d[cnt]=="NUM") 
			scanf("%d",&a[cnt]);
	}//输入
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&p);
		int r=doing(p);
		if(r==-2000000000) printf("ERROR\n");
		else printf("%d\n",r);
	}
    return 0;
}

```

程序唯一的巧妙之处在于将判定不合法放到了操作后面，避免重复写一样的代码。

但是要注意交换时要判定，因为如果不合法它并不会像运算那样体现在tail上面

还有不合法返回一定不要写-1，我开始就是这么写的，90分。

你没猜错，有一个点-1【保持微笑】

祝大家AC


---

## 作者：mutable (赞：4)

## 坑点:

1.第一次压入要特判。

2.ADD,MUL,SUB,NUM要判断溢出。

3.DIV,MOD要判断除数是否为0。

4.除NUM和END外的操作要判断栈中元素个数。

5.SUB,DIV,MOD是弹出的第二个数op第一个数。

## AC Code
```cpp
#include<stdio.h>
#include<stack>
#include<math.h>
#define ll long long
#define error(); printf("ERROR\n");return;
using namespace std;
char a[2020][4];
ll num[2020],cnt=1,n,x;
stack<ll> z;
void doit() {
	ll ls1=0,ls2=0;
	if(abs(x)>1000000000) {
		error();
	}
	z.push(x);
	for(ll i=1; i<=cnt; i++) {
		switch(a[i][1]) {//小技巧:只判断第一个字符 
			case 'N':
				if(abs(num[i])>1000000000) {
					error();//超1000000000判错 
				}
				z.push(num[i]);
				break;//num
			case 'P':
				if(z.empty()) {
					error();
				}//栈中无元素判错 
				z.pop();
				break;//pop
			case 'I':
				if(z.empty()) {
					error();
				}//栈中无元素判错 
				ls1=z.top();
				z.pop();
				z.push(-ls1);
				break;//inv
			case 'D':
				if(a[i][1]=='U') {
					if(z.empty()) {
						error();//栈中无元素判错 
					}
					z.push(z.top());//dup
				} else {
					if(z.size()<2) {
						error();//栈中元素<2判错 
					}
					ls1=z.top();
					z.pop();
					ls2=z.top();
					z.pop();
					if(ls1==0) {
						error();
					}
					z.push(ls2/ls1);//div
				}
				break;
			case 'S':
				if(a[i][1]=='U') {
					if(z.size()<2) {
						error();//栈中元素<2判错 
					}
					ls1=z.top();
					z.pop();
					ls2=z.top();
					z.pop();
					if(abs(ls2-ls1)>1000000000) {
						error();//超1000000000判错 
					}
					z.push(ls2-ls1);
					break;//sub
				} else {
					if(z.size()<2) {
						error();//栈中元素<2判错 
					}
					ls1=z.top();
					z.pop();
					ls2=z.top();
					z.pop();
					z.push(ls1);
					z.push(ls2);
					break;//swp
				}
			case 'A':
				if(z.size()<2) {
					error();//栈中元素<2判错 
				}
				ls1=z.top();
				z.pop();
				ls2=z.top();
				z.pop();
				if(abs(ls2+ls2)>1000000000) {
					error();//超1000000000判错 
				}
				z.push(ls1+ls2);
				break;//add
			case 'M':
				if(a[i][1]=='U') {
					if(z.size()<2) {
						error();//栈中元素<2判错 
					}
					ls1=z.top();
					z.pop();
					ls2=z.top();
					z.pop();
					if(abs(ls1*ls2)>1000000000) {
						error();//超1000000000判错 
					}
					z.push(ls1*ls2);
					break;//mul
				} else {
					if(z.size()<2) {
						error();//栈中元素<2判错 
					}
					ls1=z.top();
					z.pop();
					ls2=z.top();
					z.pop();
					if(ls1==0) {
						error();
					}
					z.push(ls2%ls1);
					break;//mod
				}
		}
	}
	if(z.size()!=1) {
		error();//栈中元素个数不等于1判错 
	}
	printf("%lld\n",z.top());
	z.pop();
	return;
}
int main() {
	while(1) {
		scanf("%s",&a[cnt]);
		if(a[cnt][0]=='E') {
			cnt--;
			break;
		}
		if(a[cnt][0]=='N') {
			scanf("%lld",&num[cnt]);
		}
		cnt++;
	}
	scanf("%lld",&n);
	while(n--) {
		scanf("%lld",&x);
		doit();
	}
	return 0;
}
```
本代码已经过反抄袭处理

---

## 作者：一扶苏一 (赞：4)

这是一篇使用 java 语言的题解。

## Design

### Stack

#### stack-demand

在 stack 中插入一个数、查询栈顶元素并删除、查询栈中是否是最后一个数。

#### stack-interface

```java
interface MyStack {
  int nul = 1000000009;

  int push(long x);
  int val();
  int getfinal();
}
```

#### stack-realization 

使用 `ArrayList<Integer>` 来实现 stack。

对于 `push` 需求，先判定插入元素 $x$ 是否合法，若不合法返回不合法信息。

对于 `val` 需求，先查询 size 是否不为零（若为 0 则返回不合法信息），然后存储栈顶元素的值，最后将该 index 在 ArrayList 中 remove 掉。

对于 `getfinal` 需求，先查询 size 是否为 1，若是则返回 val，否则返回不合法信息。

### Options

#### options-demand

实现题目中的 11 种操作。

#### options-interface

```java
interface OP {
  int nul = 1000000009;

  int NUM(long x);
  int POP();
  int INV();
  int DUP();
  int SWP();
  int ADD();
  int SUB();
  int MUL();
  int DIV();
  int MOD();
  int END();
}
```

#### options-realization

大部分操作略。

对于 `ADD` 操作，先取 $b$ 分别依次为栈顶的两个元素，此时应该先判断 $b$ 是否是不合法信息，若是，则直接返回不合法信息。其余取两个数的操作同理。

对于 `DIV` 和 `MOD` 操作，需要判断除数（模数）是否为 0，若是则返回不合法信息。

### Reading

#### reading-demand

读入字符串形式的操作要求，判定该操作应该调用哪个方法；读入询问数；给出 $f(x)$ 中 $x$ 的值；对于一次新的询问，提供 resite 方法表示从头开始扫描操作序列。

#### reading-interface

```java
interface Reading {
  int ReadOps();		// It returns the number of queries.
  int NextQry();
  int NextOps();
  int NextAdd();		// It returns the next number which should be push into the stack(NUM operation).
  void resite();
}
```

#### reading-realization

首先读入操作序列：不断读入字符串 $t$，若字符串为 `NUM`，则紧接着读入一个 Integer 表示被插入的数（并插入一个 ArrayList）；然后将操作字符串存储下来。一直读入到 $t$ 为数字，返回此时的 $t$ 即为询问数。

声明实例变量 pos 和 pp，分别表示当前已扫描到操作序列的位置和被插入的数的位置。在 resite 方法中，将二者清零；在 `NextOps` 和 `NextAdd` 方法中分别令二者自增并返回对应 ArrarList 对应位置的值。

使用 Map 将操作字符串映射为整数，作为 `nextOps` 的返回值（如果扫描完了序列返回 -1）。

对于 `NexrQry` 方法，直接读入一个整数并返回即可。

### Validity Inspection(Checker)

#### checker-demand

判定某个值是不是非法信息。

#### checker-realization

因为过程中出现的值均为绝对值不大于 $10^9$ 的数，所以取绝对值大于 $10^9$ 的数均为非法信息即可。

在上面各需要返回非法信息的方法中，可以返回任何一个大于 $10^9$ 的 int 变量表示非法信息，例如 interface `MyStack` 中的 `nul`。

### Solver

#### solver-realization

先读入操作序列。

然后读入询问数，对每个询问执行如下操作：

初始化栈并调用 `resite` 方法，然后插入栈的初始数。

遍历操作序列，根据 `NextOps` 方法的返回值判定调用 Options 中的哪个方法，记录返回值。

若返回值不合法，输出 `ERROR` 并进行下一次询问；

若读入至 `END`，输出结果并进行下一次询问。

### FastIO

略。

## Code

```java
import java.io.*;
import java.util.*;

class Checker {
  final static int lim = 1000000000;

  static public boolean CheckNotLegal(long x) {
    return Math.abs(x) > lim;
  }
}

interface MyStack {
  int nul = 1000000009;

  int push(long x);
  int val();
  int getfinal();
}

class Stack implements MyStack {
  ArrayList<Integer> stk;

  Stack() {
    stk = new ArrayList<>();
  }

  @Override
  public int push(long x) {
    if (Checker.CheckNotLegal(x)) { return nul; }
    stk.add((int)x);
    return 0;
  }

  @Override
  public int val() {
    if (stk.size() == 0) return nul;
    int ret = stk.get(stk.size() - 1);
    stk.remove(stk.size() - 1);
    return ret;
  }

  @Override
  public int getfinal() {
    return (stk.size() == 1) ? val() : nul;
  }
}

interface OP {
  int nul = 1000000009;

  int NUM(long x);
  int POP();
  int INV();
  int DUP();
  int SWP();
  int ADD();
  int SUB();
  int MUL();
  int DIV();
  int MOD();
  int END();
}

class Options implements OP {
  MyStack s;

  Options() { s = new Stack(); }

  @Override
  public int NUM(long x) {  return s.push(x);  }

  @Override
  public int POP() { return s.val(); }

  @Override
  public int INV() {
    int x = s.val();
    return s.push(-x);
  }

  @Override
  public int DUP() {
    int x = s.val();
    s.push(x);
    return s.push(x);
  }

  @Override
  public int SWP() {
    int a = s.val(), b = s.val();
    s.push(a);
    return s.push(b);
  }

  @Override
  public int ADD() {
    int a = s.val(), b = s.val(), x = a + b;
    if (Checker.CheckNotLegal(b)) return nul;
    return s.push(x);
  }

  @Override
  public int SUB() {
    int a = s.val(), b = s.val(), x = b - a;
    if (Checker.CheckNotLegal(b)) return nul;
    return s.push(x);
  }

  @Override
  public int MUL() {
    int a = s.val(), b = s.val(); long x = (long) a * b;
    if (Checker.CheckNotLegal(b)) return nul;
    return s.push(x);
  }

  @Override
  public int DIV() {
    int a = s.val(), b = s.val();
    if (Checker.CheckNotLegal(b) || (a == 0)) return nul;
    return s.push(b / a);
  }

  @Override
  public int MOD() {
    int a = s.val(), b = s.val();
    if (Checker.CheckNotLegal(b) || (a == 0)) return nul;
    return s.push(b % a);
  }

  @Override
  public int END() {
    return s.getfinal();
  }
}

interface Reading {
  int ReadOps();
  int NextQry();
  int NextOps();
  int NextAdd();
  void resite();
}

class Read implements Reading {
  ArrayList<String> s;
  ArrayList<Integer> PutNum;
  IO io;
  Map<String, Integer> mp;
  int pos, pp;

  Read(IO _ioo) {
    s = new ArrayList<>();
    io = _ioo;
    PutNum = new ArrayList<>();
    mp = new HashMap<>();
    mp.put("NUM", 1);
    mp.put("POP", 2);
    mp.put("INV", 3);
    mp.put("DUP", 4);
    mp.put("SWP", 5);
    mp.put("ADD", 6);
    mp.put("SUB", 7);
    mp.put("MUL", 8);
    mp.put("DIV", 9);
    mp.put("MOD", 10);
    mp.put("END", 11);
    pos = 0;
  }

  @Override
  public void resite() {
    pos = pp = 0;
  }

  @Override
  public int NextAdd() {
    return PutNum.get(pp++);
  }

  boolean Check(String t) {
    return (t.charAt(0) < '0') || (t.charAt(0) > '9');
  }

  @Override
  public int ReadOps() {
    String t = io.next();
    while (Check(t)) {
      s.add(t);
      if (t.equals("NUM")) PutNum.add(io.nextInt());
      t = io.next();
    }
    return Integer.parseInt(t);
  }

  @Override
  public int NextOps() {
    if (pos == s.size()) return -1;
    return mp.get(s.get(pos++));
  }

  @Override
  public int NextQry() {
    resite();
    return io.nextInt();
  }
}

class Solver {
  void solve(IO io) {
    Reading rd = new Read(io);
    int n = rd.ReadOps();
    while (n-- != 0) {
      OP ops = new Options();
      ops.NUM(rd.NextQry());
      for (int op = rd.NextOps(), ret = 0; op != -1; op = rd.NextOps()) {
        switch (op) {
          case 1: {
            ret = ops.NUM(rd.NextAdd()); break;
          }
          case 2: {
            ret = ops.POP(); break;
          }
          case 3: {
            ret = ops.INV(); break;
          }
          case 4: {
            ret = ops.DUP(); break;
          }
          case 5: {
            ret = ops.SWP(); break;
          }
          case 6: {
            ret = ops.ADD(); break;
          }
          case 7: {
            ret = ops.SUB(); break;
          }
          case 8: {
            ret = ops.MUL(); break;
          }
          case 9: {
            ret = ops.DIV(); break;
          }
          case 10: {
            ret = ops.MOD(); break;
          }
          case 11: {
            ret = ops.END(); break;
          }
        }
        if (Checker.CheckNotLegal(ret)) {
          io.print("ERROR\n"); break;
        }
        if (op == 11) {
          io.print(ret + "\n");
          break;
        }
      }
    }
  }
}

public class Main {
  public static void main(String[] argc) {
    IO io = new FastIO(System.in, System.out);
    Solver solver = new Solver();
    solver.solve(io);
    io.endpro();
  }
}

interface IO {
  int nextInt();
  long nextLong();
  String next();
  void print(long x);
  void print(String s);
  void endpro();
}

class FastIO implements IO {
  public BufferedReader reader;
  public StringTokenizer tokenizer;
  public PrintWriter out;

  public void endpro() {
    out.close();
  }

  public FastIO(InputStream stream, OutputStream os) {
    reader = new BufferedReader(new InputStreamReader(stream), 32768);
    tokenizer = null;
    out = new PrintWriter(os);
  }

  public void print(long x) {
    out.print(x);
  }

  public void print(String s) {
    out.print(s);
  }

  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new StringTokenizer(reader.readLine());
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }

  public int nextInt() {
    return Integer.parseInt(next());
  }

  public long nextLong() {
    return Long.parseLong(next());
  }

}
```



---

## 作者：Hatsune_Miku (赞：3)

前一段时间我校大佬都在做的一道模拟题。我一个蒟蒻也来凑个热闹23333...

主要的难点在于函数太多，还有附加的限制条件。

主要的判错有：

- 每次入栈检查绝对值是否超出限制

- 对栈内元素进行操作前先检查栈内元素的数量

- 除以零的情况

- 运算结果的绝对值是否超出限制

- 函数最后栈内元素个数

在WA了一次后，我重新写了一次代码，希望能帮助查错而定义了一大堆常量，希望对大家有帮助。

毕竟模拟题吗，细心一点总是能做对的。

我的思路比较糟糕，每一个判错都是分开写的，11个函数也是分开的，还手写了几个辅助函数。程序中所有的操作都统一由EXECUTE函数接管，出现错误则使用HANDLE\_ERROR函数进行输出。

不知道为什么，指令不能用正常的方式读入，就手写了一个read\_instruction函数来读入（果然还是太弱了）。

还是惯例，能用STL的地方用的都是STL。

如果还不理解的话代码里有注释：

```cpp
#include<cstdio>
#include<string>
#include<stack>
using namespace std;

stack<long long> s;                                                           //栈 
pair<long long,long long>ret;                                                 //GET函数返回栈顶两个元素形成的二元组 
string instruction[2000+10];                                                  //指令 
long long number[2000+10];                                                    //NUM函数的操作数 
int cnt,n,ai;                                                                 //cnt:指令数 
bool fail;                                                                    //函数是否中途失败退出 

//*********状态常量表开始**********//
#define OVERFLOW_FAIL 1
#define OVERFLOW_OK 2
#define NUM_FAIL_OVERFLOW 3
#define NUM_OK 4
#define UNDERFLOW_FAIL 5
#define UNDERFLOW_OK 6
#define POP_FAIL_UNDERFLOW 7
#define POP_OK 8
#define INV_FAIL_UNDERFLOW 9
#define INV_OK 10
#define DUP_FAIL_UNDERFLOW 11
#define DUP_OK 12
#define GET_FAIL_UNDERFLOW 13
#define GET_OK 14
#define SWP_FAIL_UNDERFLOW 15
#define SWP_OK 16
#define ADD_FAIL_UNDERFLOW 17
#define ADD_FAIL_OVERFLOW 18
#define ADD_OK 19
#define SUB_FAIL_UNDERFLOW 20
#define SUB_FAIL_OVERFLOW 21
#define SUB_OK 22
#define MUL_FAIL_UNDERFLOW 23
#define MUL_FAIL_OVERFLOW 24
#define MUL_OK 25
#define DIVISION_FAIL 26
#define DIVISION_OK 27
#define DIV_FAIL_UNDERFLOW 28
#define DIV_FAIL_DIVISION_BY_ZERO 29
#define DIV_FAIL_OVERFLOW 30
#define DIV_OK 31
#define MOD_FAIL_UNDERFLOW 32
#define MOD_FAIL_DIVISION_BY_ZERO 33
#define MOD_FAIL_OVERFLOW 34
#define MOD_OK 35
#define SIZE_ERROR 36
//*********状态常量表结束**********//

inline long long abs(long long val) {                                         //辅助函数，求绝对值 
    if(val>=0)return val;
    else return -val;
}
inline int OVERFLOW(long long val) {                                          //判错函数，绝对值超出限制 
    if(abs(val)>1000000000ll)
        return OVERFLOW_FAIL;
    return OVERFLOW_OK;
}
inline int NUM(long long x) {
    if(OVERFLOW_FAIL==OVERFLOW(x))
        return NUM_FAIL_OVERFLOW;
    s.push(x);
    return NUM_OK;
}
inline int UNDERFLOW(int val) {                                               //判错函数，操作后栈会下溢出 
    if(s.size()<val)
        return UNDERFLOW_FAIL;
    return UNDERFLOW_OK;
}
inline int POP() {
    if(UNDERFLOW_FAIL==UNDERFLOW(1))
        return POP_FAIL_UNDERFLOW;
    s.pop();
    return POP_OK;
}
inline int INV() {
    if(UNDERFLOW_FAIL==UNDERFLOW(1))
        return INV_FAIL_UNDERFLOW;
    long long tmp=s.top();
    s.pop();
    s.push(-tmp);
    return INV_OK;
}
inline int DUP() {
    if(UNDERFLOW_FAIL==UNDERFLOW(1))
        return DUP_FAIL_UNDERFLOW;
    s.push(s.top());
    return DUP_OK;
}
inline int GET() {                                                            //辅助函数，取出栈顶两个元素 
    if(UNDERFLOW_FAIL==UNDERFLOW(2))
        return GET_FAIL_UNDERFLOW;
    ret.first=s.top(),s.pop(),ret.second=s.top(),s.pop();
    return GET_OK;
}
inline int SWP() {
    if(GET_FAIL_UNDERFLOW==GET())
        return SWP_FAIL_UNDERFLOW;
    s.push(ret.first),s.push(ret.second);
    return SWP_OK;
}
inline int ADD() {
    if(GET_FAIL_UNDERFLOW==GET())
        return ADD_FAIL_UNDERFLOW;
    long long tmp=ret.first+ret.second;
    if(OVERFLOW_FAIL==OVERFLOW(tmp))
        return ADD_FAIL_OVERFLOW;
    s.push(tmp);
    return ADD_OK;
}
inline int SUB() {
    if(GET_FAIL_UNDERFLOW==GET())
        return SUB_FAIL_UNDERFLOW;
    long long tmp=ret.second-ret.first;
    if(OVERFLOW_FAIL==OVERFLOW(tmp))
        return SUB_FAIL_OVERFLOW;
    s.push(tmp);
    return SUB_OK;
}
inline int MUL() {
    if(GET_FAIL_UNDERFLOW==GET())
        return MUL_FAIL_UNDERFLOW;
    long long tmp=ret.first*ret.second;
    if(OVERFLOW_FAIL==OVERFLOW(tmp))
        return MUL_FAIL_OVERFLOW;
    s.push(tmp);
    return MUL_OK;
}
inline int DIVISION(long long division) {                                     //判错函数，被零除 
    if(division==0)
        return DIVISION_FAIL;
    return DIVISION_OK;
}
inline int DIV() {
    if(GET_FAIL_UNDERFLOW==GET())
        return DIV_FAIL_UNDERFLOW;
    if(DIVISION_FAIL==DIVISION(ret.first))
        return DIV_FAIL_DIVISION_BY_ZERO;
    long long tmp=ret.second/ret.first;
    if(OVERFLOW_FAIL==OVERFLOW(tmp))
        return DIV_FAIL_OVERFLOW;
    s.push(tmp);
    return DIV_OK;
}
inline int MOD() {
    if(GET_FAIL_UNDERFLOW==GET())
        return MOD_FAIL_UNDERFLOW;
    if(DIVISION_FAIL==DIVISION(ret.first))
        return MOD_FAIL_DIVISION_BY_ZERO;
    long long tmp=ret.second%ret.first;
    if(OVERFLOW_FAIL==OVERFLOW(tmp))
        return MOD_FAIL_OVERFLOW;
    s.push(tmp);
    return MOD_OK;
}
inline void HANDLE_ERROR(int ret) {                                           //辅助函数，传递错误，如果函数没有执行成功则执行 
    if(fail==false)
        printf("ERROR\n",ret);
    fail=true;
    return;
}
inline void EXECUTE(int ret) {                                                //辅助函数，如果函数没有执行成功则传递错误 
    if(ret!=NUM_OK&&ret!=POP_OK&&ret!=INV_OK&&ret!=DUP_OK&&ret!=SWP_OK
            &&ret!=ADD_OK&&ret!=SUB_OK&&ret!=MUL_OK&&ret!=DIV_OK&&ret!=MOD_OK)
        HANDLE_ERROR(ret);
}
inline string read_instruction() {                                            //辅助函数，读取指令 
    string str="";
    char ch=getchar();
    while(ch<'A'||ch>'Z')ch=getchar();
    str+=ch,str+=getchar(),str+=getchar();
    return str;
}
int main() {
    while(1) {
        instruction[cnt]=read_instruction();
        if(instruction[cnt]=="END")
            break;
        if(instruction[cnt]=="NUM")
            scanf("%d",&number[cnt]);
        cnt++;
    }
    scanf("%d",&n);
    for(int i=0; i<n; i++) {
        scanf("%d",&ai);
        NUM(ai);                                                              //先把初始元素压入栈中，同样需要判错 
        for(int i=0; i<cnt; i++) {
            if(instruction[i]=="NUM")EXECUTE(NUM(number[i]));
            if(instruction[i]=="POP")EXECUTE(POP());
            if(instruction[i]=="INV")EXECUTE(INV());
            if(instruction[i]=="DUP")EXECUTE(DUP());
            if(instruction[i]=="SWP")EXECUTE(SWP());
            if(instruction[i]=="ADD")EXECUTE(ADD());
            if(instruction[i]=="SUB")EXECUTE(SUB());
            if(instruction[i]=="MUL")EXECUTE(MUL());
            if(instruction[i]=="DIV")EXECUTE(DIV());
            if(instruction[i]=="MOD")EXECUTE(MOD());
            if(fail==true)
                break;
        }
        if(!fail&&s.size()==1)                                                //如果没有函数执行失败并且栈中仅有一个元素 
            printf("%d\n",s.top());
        else HANDLE_ERROR(SIZE_ERROR);
        while(!s.empty())                                                     //清空栈，准备下一次操作 
            s.pop();
        fail=false;                                                           //复原函数执行状态 
    }
    return 0;
}
```

---

## 作者：BMTXLRC (赞：2)

### Part 1: 分析题面&输入
------------

有点类似于多组数据，考虑先把所有操作的输入存下来。

注意如果是 `NUM` 操作，要多输入一个数。

我同时开 $a$ 和 $c$ 两个数组，如果输入为 `NUM`，则在 $a$ 对应位置存上后面这个数。

如果输入到 `END` 操作，跳出 $\texttt{while}$ 循环。

```cpp
while(cin>>c[++cnt]){
	if(c[cnt]=="END") break;
	if(c[cnt]=="NUM") scanf("%lld",&x),a[cnt]=x;
}
```

**记得清栈（**

### Part 2: 分析错误情况
------------

- #### 第一种，`Math Error`。

很简单，如果是 `DIV` 或 `MOD` 操作，要判断被除数/被模数是否为 $0$。

如果为 $0$，直接输出 `ERROR\n`，开始下一组数据。

```cpp
bool div_ERROR(ll x,ll y){
	if(x==0){
		printf("ERROR\n");
		return true;
	}
	return false;
}
```
**不判 $0$ 将会导致 $\texttt{RE}\;90$ 或 $\texttt{WA}\; 90$。**

- #### 第二种，`Number Error`。

这里有一个地方要特判，最开始入栈的那个数如果存在 $\lvert x\rvert > 10^9$，直接输出 `ERROR\n`，开始下一组数据。

对于 `NUM`，`INV`，`DUP`，`SWP`，`ADD`，`SUB`，`MUL`，`DIV`，`MOD` 操作，要进行 `Number Error` 的判定。

**1. `SUB`，`DIV` 和 `MOD` 操作：**

设先弹出的数为 $x$，后弹出的数为 $y$，对于这三种操作，结果是 $y\; \texttt{op}\;x$。

**2. `SWP` 操作：**

我不是很清楚这里是否会错。

如果你是这么写的：

```cpp
if(num_ERROR(x)||num_ERROR(y)) return;
```

那最好改成：

```cpp
if(num_ERROR(y)) return;
if(num_ERROR(x)) return;
```

**3. `Math Error` 要在 `Number Error` 前面判，不多说了。**


```cpp
bool num_ERROR(ll x){
	if(abs(x)>inf){
		printf("ERROR\n");
		return true;
	}
	return false;
}
```

- #### 第三种，`Stack Error`。

利用 `st.size()` 函数来帮助判断运算是否符合标准。

**1. `POP` 和 `INV` 操作**

这两个操作只需要弹出一个数。

**2. `SWP`，`ADD`，`SUB`，`MUL`，`DIV` 和 `MOD` 操作**

弹出两个数，`if(st.size()<2)` 就好了。

**3. `END` 操作**

根据题意，如果最后栈内不为一个数，就输出 `ERROR\n`。

```cpp
bool stack_ERROR(string s){
	if(s=="POP"||s=="INV"){
		if(st.size()==0){
			printf("ERROR\n");
			return true;
		}
	}
	if(s=="SWP"||s=="ADD"||s=="SUB"||s=="MUL"||s=="DIV"||s=="MOD"){
		if(st.size()<2){
			printf("ERROR\n");
			return true;
		}
	}
	if(s=="END"){
		if(st.size()!=1){
			printf("ERROR\n");
			return true;
		}
	}
	return false;
}
```

### Part 3: 操作
------------

定义一个 `work(ll x)` 函数，$x$ 表示栈内初始值。

最开始要先进行特判，就是我刚刚提到的 `Number Error`。

以 `ADD` 函数为例：

`!Stack Error`$\to$ 

`ll x=st.top();st.pop();`（$y$ 同理）$\to$ 

`!Number Error`$\to$ 

`st.push(x+y);`

```cpp
void work(ll x){
	if(num_ERROR(x)){
		printf("ERROR\n");
		return;
	}
	st.push(x);
	for(register int i=1;i<=cnt;i++){
		if(c[i]=="NUM"){
			if(num_ERROR(a[i])) return;
			st.push(a[i]);
		}
		if(c[i]=="POP"){
			if(stack_ERROR("POP")) return;
			st.pop();
		}
		if(c[i]=="INV"){
			if(stack_ERROR("INV")) return;
			ll x=st.top();
			if(num_ERROR(-x)) return;
			st.pop();st.push(-x);
		}
		if(c[i]=="DUP"){
			ll x=st.top();
			if(num_ERROR(x)) return;
			st.push(x);
		}
		if(c[i]=="SWP"){
			if(stack_ERROR("SWP")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(y)) return;
			if(num_ERROR(x)) return;
			st.push(x),st.push(y);
		}
		if(c[i]=="ADD"){
			if(stack_ERROR("ADD")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(x+y)) return;
			st.push(x+y);
		}
		if(c[i]=="SUB"){
			if(stack_ERROR("SUB")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(y-x)) return;
			st.push(y-x);
		}
		if(c[i]=="MUL"){
			if(stack_ERROR("MUL")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(x*y)) return;
			st.push(x*y);
		}
		if(c[i]=="DIV"){
			if(stack_ERROR("DIV")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(div_ERROR(x,y)) return;
			if(num_ERROR(y/x)) return;
			st.push(y/x);
		}
		if(c[i]=="MOD"){
			if(stack_ERROR("MOD")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(div_ERROR(x,y)) return;
			if(num_ERROR(y%x)) return;
			st.push(y%x);
		}
		if(c[i]=="END"){
			if(stack_ERROR("END")) return;
			else{
				printf("%lld\n",st.top());
				return;
			}
		}
	}
}
```

所有操作每个都处理完，就搞定了。

### Part 4: 总代码
------------

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e3+5;
const ll inf=1e9;
string c[N];
stack<ll> st;
ll n,x,cnt=0,a[N];
bool num_ERROR(ll x){
	if(abs(x)>inf){
		printf("ERROR\n");
		return true;
	}
	return false;
}
bool div_ERROR(ll x,ll y){
	if(x==0){
		printf("ERROR\n");
		return true;
	}
	return false;
}
bool stack_ERROR(string s){
	if(s=="POP"||s=="INV"){
		if(st.size()==0){
			printf("ERROR\n");
			return true;
		}
	}
	if(s=="SWP"||s=="ADD"||s=="SUB"||s=="MUL"||s=="DIV"||s=="MOD"){
		if(st.size()<2){
			printf("ERROR\n");
			return true;
		}
	}
	if(s=="END"){
		if(st.size()!=1){
			printf("ERROR\n");
			return true;
		}
	}
	return false;
}
void work(ll x){
	if(num_ERROR(x)){
		printf("ERROR\n");
		return;
	}
	st.push(x);
	for(register int i=1;i<=cnt;i++){
		if(c[i]=="NUM"){
			if(num_ERROR(a[i])) return;
			st.push(a[i]);
		}
		if(c[i]=="POP"){
			if(stack_ERROR("POP")) return;
			st.pop();
		}
		if(c[i]=="INV"){
			if(stack_ERROR("INV")) return;
			ll x=st.top();
			if(num_ERROR(-x)) return;
			st.pop();st.push(-x);
		}
		if(c[i]=="DUP"){
			ll x=st.top();
			if(num_ERROR(x)) return;
			st.push(x);
		}
		if(c[i]=="SWP"){
			if(stack_ERROR("SWP")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(y)) return;
			if(num_ERROR(x)) return;
			st.push(x),st.push(y);
		}
		if(c[i]=="ADD"){
			if(stack_ERROR("ADD")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(x+y)) return;
			st.push(x+y);
		}
		if(c[i]=="SUB"){
			if(stack_ERROR("SUB")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(y-x)) return;
			st.push(y-x);
		}
		if(c[i]=="MUL"){
			if(stack_ERROR("MUL")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(num_ERROR(x*y)) return;
			st.push(x*y);
		}
		if(c[i]=="DIV"){
			if(stack_ERROR("DIV")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(div_ERROR(x,y)) return;
			if(num_ERROR(y/x)) return;
			st.push(y/x);
		}
		if(c[i]=="MOD"){
			if(stack_ERROR("MOD")) return;
			ll x=st.top();st.pop();
			ll y=st.top();st.pop();
			if(div_ERROR(x,y)) return;
			if(num_ERROR(y%x)) return;
			st.push(y%x);
		}
		if(c[i]=="END"){
			if(stack_ERROR("END")) return;
			else{
				printf("%lld\n",st.top());
				return;
			}
		}
	}
}
int main(){
	while(cin>>c[++cnt]){
		if(c[cnt]=="END") break;
		if(c[cnt]=="NUM") scanf("%lld",&x),a[cnt]=x;
	}
	scanf("%lld",&n);
	for(register ll i=1;i<=n;i++){
		ll q;
		scanf("%lld",&q);
		work(q);
		while(!st.empty()) st.pop();
	}
}
```


---

## 作者：EXODUS (赞：2)

~~好家伙，又是一道大模拟~~

[博客食用应该不会更佳](https://www.luogu.com.cn/blog/EXODUS/p2186-ti-xie)

言归正传。

这一道题的主要思路就是模拟，写上$11$个函数加$11$个$if$去维护所有操作，写了$208$行。

你需要判断的错误操作：
-
>- 出现了弹不出来的情况，其中第$2$、$3$、$4$种情况只需要判断$q.empty()$，第$5$~$10$种是$q.size()\leq 1$
>- 除以或模一个$0$。
>- 到了$END$后$q.size()!=1$
>- 入栈时的绝对值限制。

我的一些~~砷奇的~~操作
-
>- 在这里我开了$long\ long$，怕炸$int$。
>- 我把每一种操作用$map$映射成了一个数字，方便打$if$。
>- 我把$ERROR$的返回值定为了$0x7ffffffff$，防止出现在$int$范围内有重复答案导致判断错误的情况。

## 没了？
## 没了。

```cpp
#include<bits/stdc++.h>
using namespace std;
//typedef inline il;
typedef long long LL;
LL maxn=0x7ffffffff;
stack<LL>s;
map<string,int>m;
int step[2857];
LL will_add[2857];
int add_cnt,add_tot,step_cnt;
inline void NUM(LL x){
    s.push(x);
}
inline void POP(){
    s.pop();
}
inline void INV(){
    LL x=s.top();
    s.pop();
    s.push(-x);
}
inline void DUP(){
    s.push(s.top());
}
inline void SWP(){
    LL x1=s.top();
    s.pop();
    LL x2=s.top();
    s.pop();
    s.push(x1);
    s.push(x2);
}
inline void ADD(){
    LL x1=s.top();
    s.pop();
    LL x2=s.top();
    s.pop();
    s.push(x2+x1);
}
inline void SUB(){
    LL x1=s.top();
    s.pop();
    LL x2=s.top();
    s.pop();
    s.push(x2-x1);
}
inline void MUL(){
    LL x1=s.top();
    s.pop();
    LL x2=s.top();
    s.pop();
    s.push(x2*x1);
}
inline void DIV(){
    LL x1=s.top();
    s.pop();
    LL x2=s.top();
    s.pop();
    s.push(x2/x1);
}
inline void MOD(){
    LL x1=s.top();
    s.pop();
    LL x2=s.top();
    s.pop();
    s.push(x2%x1);
}
inline bool check(int type,LL num){
    if(type==1) if(abs(num)>1000000000) return 0;
    if(type==2||type==3||type==4) if(s.empty()) return 0;
    if(type==5||type==6||type==7||type==8||type==9||type==10) if(s.size()<=1) return 0;
    if(type==9||type==10) if(s.top()==0) return 0;
    if(type==6||type==7||type==8||type==9||type==10){
        LL x1=s.top();
        s.pop();
        LL x2=s.top();
        s.pop();
        s.push(x2);
        s.push(x1);
        if(type==6&&abs(x2+x1)>1e9) return 0;
        else if(type==7&&abs(x2-x1)>1e9) return 0;
        else if(type==8&&abs(x2*x1)>1e9) return 0;
        else if(type==9&&abs(x2/x1)>1e9) return 0;
        else if(type==10&&abs(x2%x1)>1e9) return 0;
    }
    if(type==11) if(s.size()!=1) return 0;
    return 1;
}
void init(){
    m["NUM"]=1;
    m["POP"]=2;
    m["INV"]=3;
    m["DUP"]=4;
    m["SWP"]=5;
    m["ADD"]=6;
    m["SUB"]=7;
    m["MUL"]=8;
    m["DIV"]=9;
    m["MOD"]=10;
    m["END"]=11;
}
LL move(int now){
    if(step[now]==1){
        add_tot++;
        if(!check(1,will_add[add_tot])) return maxn;
        else{
            NUM(will_add[add_tot]);
            return move(now+1);
        }
    }
    else if(step[now]==2){
        if(!check(2,0)) return maxn;
        else{
            POP();
            return move(now+1);
        }
    }
    else if(step[now]==3){
        if(!check(3,0)) return maxn;
        else{
            INV();
            return move(now+1);
        }
    }
    else if(step[now]==4){
        if(!check(4,0)) return maxn;
        else{
            DUP();
            return move(now+1);
        }
    }
    else if(step[now]==5){
        if(!check(5,0)) return maxn;
        else{
            SWP();
            return move(now+1);
        }
    }
    else if(step[now]==6){
        if(!check(6,0)) return maxn;
        else{
            ADD();
            return move(now+1);
        }
    }
    else if(step[now]==7){
        if(!check(7,0)) return maxn;
        else{
            SUB();
            return move(now+1);
        }
    }
    else if(step[now]==8){
        if(!check(8,0)) return maxn;
        else{
            MUL();
            return move(now+1);
        }
    }
    else if(step[now]==9){
        if(!check(9,0)) return maxn;
        else{
            DIV();
            return move(now+1);
        }
    }
    else if(step[now]==10){
        if(!check(10,0)) return maxn;
        else{
            MOD();
            return move(now+1);
        }
    }
    else if(step[now]==11){
        if(!check(11,0)) return maxn;
        else{
            return s.top();
        }
    }
}
int n;
string st;
int main(){
	init();
    while(st!="END"){
        cin>>st;
        step[++step_cnt]=m[st];
        if(st=="NUM"){
            LL x;
            scanf("%lld",&x);
            will_add[++add_cnt]=x;
        }
    }
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        LL x;
        scanf("%lld",&x);
        s.push(x);
        LL ans=move(1);
        if(ans==maxn) printf("ERROR\n");
        else printf("%lld\n",ans);
        while(!s.empty()){
            s.pop();
        }
        add_tot=0;
    }
    return 0;
}
```
欢迎各位大佬暴踩。

求个赞（逃~~

---

## 作者：Kewth (赞：2)

这道题看上去贼复杂（11个函数，数据不保证合法，难度省选-），实际上只要对于每种函数进行一次if的判断（11个函数算个撒子），对于每次得出的数据进行一次if的判断（数据不合法算个撒子），AC后再评分里选个入门就OK了（省选-算个撒子~）。

然而我因为把INV拼写成IVN提交几次都是50分，所以本蒟蒻提醒各位神牛  看  清  楚  单  词  ！  ！  ！

本蒟蒻的代码如下：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,num[10001],st[10001],p;//st数组是本蒟蒻手写的一个数组栈，p是栈顶指针
string s[10001];//s是每一个函数
bool end;
void get(int x)
{
    cin>>s[x];//读入函数
    if(s[x]=="END") return ;//函数结束
    if(s[x]=="NUM") cin>>num[x];//输入NUM函数加入的数
    get(x+1);//递归
    return;
}
bool doit(string in,int x)
{
    if      (p<2&&in!="NUM"&&in!="IVN"&&in!="DUP"&&in!="END") return 1;//return 1表示出错，p<2是栈内只有一个元素，此时无法调用两个元素
    if    (p>1&&in=="END") return 1;//表示结束时栈内有多余元素
    if    (in=="NUM") st[++p]=num[x];//入栈
    if    (in=="POP") p--;//栈顶弹出
    if    (in=="INV") st[p]=-st[p];栈顶取反
    if    (in=="DUP") st[++p]=st[p-1];//加入与栈顶相同的元素
    if    (in=="SWP") swap(st[p],st[p-1]);//交换栈顶两个元素
    if    (in=="ADD") st[--p]+=st[p+1];//栈顶两元素相加
    if    (in=="SUB") st[--p]-=st[p+1];//栈顶两元素相减，注意是倒数第二个减去栈顶，DIV，MOD也是类似
    if    (in=="MUL") st[--p]*=st[p+1];//栈顶两元素相乘
    if    (in=="DIV")
    {
        if(st[p]==0) return 1;//除数为0出错
        st[--p]/=st[p+1];
    }
    if    (in=="MOD")
    {
        if(st[p]==0) return 1;//除数为0出错
        st[--p]%=st[p+1];
    }
    if    (in=="END") end=1;
    if(st[p]>1000000000||st[p]<-1000000000) return 1;//栈顶元素绝对值>1000000000，出错
    return 0;
}
int main()
{
    get(1);//读入函数
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        p=1;
        st[p]=0;//栈顶清0
        string in;
        cin>>in;
        int con=0;
        end=0;
        for(int j=in.size()-1,k=1;j>=0;j--,k*=10)
        {
            if(in[j]>'9'||in[j]<'0')//元素非数，出错
            {
                con=1;
                printf("ERROR\n");
                break;
            }
            st[1]+=(in[j]-'0')*k;//将字符串转化为数
        }
        if(st[1]>1000000000||st[1]<-1000000000)//栈顶元素绝对值>1000000000，出错
        {
            printf("ERROR\n");
            continue;
        }
        for(int j=1; !end ;j++)//end表示结束函数，只要没结束就循环运行
        {
            if(doit(s[j],j))//返回 1表示出错
            {
                printf("ERROR\n");
                con=1;//记录出错
                break;
            }
        }
        if(!con) printf("%d\n",st[1]);//没有出错，输出栈顶
    }
    return 0;
}
```

---

## 作者：Sora1336 (赞：1)

这是我随机跳题跳到的一道题，一开始猛一看以为是毒瘤数据结构，没想到是个模拟。

首先把操作存在一个字符串数组中，每次使用的时候就和合法指令表 `check_fail` 中的指令进行比对，如果匹配成功时当前匹配时的 index 就是你需要操作的指令的编号。这里可以实现一个桥梁函数 `to_do`， 将操作链接至函数。

同时我对 `NUM` 这个操作新建了一个数组，就是每次应该放入栈的数。

可能的不合法输入：

- 绝对值大于规定数
- 除以或者模以 0
- 没有足够的数满足要求

Code:

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <stack>
using namespace std;
typedef long long ll;
const int max_value = 1000000000;
const int min_value = -max_value;
const int max_operate = 2005;
stack<ll> machine;
string check_fail[12] = 
{
	"NUL",	// 占位语句
	"NUM",	// 栈顶放入X。
	"POP",	// 抛弃栈顶元素。
	"INV",	// 将栈顶元素取出，然后放入它的相反数。
	"DUP",	// 再放入一个和栈顶元素相同的数。
	"SWP",	// 交换栈顶的两个元素。
	"ADD",	// 取出栈顶的两个元素，两元素相加，所得结果放入栈内。
	"SUB",	// 取出栈顶的两个元素，第二个元素减去第一个元素，所得结果放入栈内。
	"MUL",	// 取出栈顶的两个元素，两元素相乘，所得结果放入栈内。
	"DIV",	// 取出栈顶的两个元素，第二个元素整除以第一个元素，所得结果放入栈内。
	"MOD",	// 取出栈顶的两个元素，第二个元素取模以第一个元素，所得结果放入栈内。
	"END"	// 结束这个程序。
};
string opertations[max_operate];
ll number_should_push_in[max_operate];
ll cnt_of_operator = 0, n, cnt_of_push = 0, situation = 0;
bool errflg;
void NUM() {
	machine.push(number_should_push_in[++ situation]);
	if(machine.top() > max_value || machine.top() < min_value) errflg = 1;
}
void POP() {
	if(machine.size() > 0) machine.pop();
	else errflg = 1;
}
void INV() {
	if(machine.size() == 0) errflg = 1;
	else {
		int inverse = - machine.top();
		machine.pop();
		machine.push(inverse);
	}
}
void DUP() {
	if(machine.size() == 0) errflg = 1;
	else machine.push(machine.top());
}
void SWP() {
	if(machine.size() < 2) errflg = 1;
	else {
		int a = machine.top();
		machine.pop();
		int b = machine.top();
		machine.pop();
		machine.push(a), machine.push(b);
	}
}
void ADD() {
	if(machine.size() < 2) errflg = 1;
	else {
		int a = machine.top();
		machine.pop();
		int b = machine.top();
		machine.pop();
		machine.push(a + b);
		if(machine.top() > max_value || machine.top() < min_value) errflg = 1;
	}
}
void SUB() {
	if(machine.size() < 2) errflg = 1;
	else {
		int a = machine.top();
		machine.pop();
		int b = machine.top();
		machine.pop();
		machine.push(b - a);
		if(machine.top() > max_value || machine.top() < min_value) errflg = 1;
	}
}
void MUL() {
	if(machine.size() < 2) errflg = 1;
	else {
		int a = machine.top();
		machine.pop();
		int b = machine.top();
		machine.pop();
		machine.push(a * b);
		if(machine.top() > max_value || machine.top() < min_value) errflg = 1;
	}
}
void DIV() {
	if(machine.size() < 2) errflg = 1;
	else {
		int a = machine.top();
		machine.pop();
		int b = machine.top();
		machine.pop();
		if(a != 0) machine.push(b / a);
		else errflg = 1;
		if(machine.top() > max_value || machine.top() < min_value) errflg = 1;
	}
}
void MOD() {
	if(machine.size() < 2) errflg = 1;
	else {
		int a = machine.top();
		machine.pop();
		int b = machine.top();
		machine.pop();
		if(a != 0) machine.push(b % a);
		else errflg = 1;
		if(machine.top() > max_value || machine.top() < min_value) errflg = 1;
	}
}
void to_do(ll number_of_operation) {
	if(number_of_operation == 1) NUM();
	else if(number_of_operation == 2) POP();
	else if(number_of_operation == 3) INV();
	else if(number_of_operation == 4) DUP();
	else if(number_of_operation == 5) SWP();
	else if(number_of_operation == 6) ADD();
	else if(number_of_operation == 7) SUB();
	else if(number_of_operation == 8) MUL();
	else if(number_of_operation == 9) DIV();
	else if(number_of_operation == 10) MOD();
}
int main() {
	while(1) {
		cin >> opertations[++ cnt_of_operator];
		if(opertations[cnt_of_operator] == check_fail[1]) {
			ll number;
			cin >> number;
			number_should_push_in[++ cnt_of_push] = number;
		} if(opertations[cnt_of_operator] == check_fail[11]) break;
	} cnt_of_operator --; 
	cin >> n;
	for(int i = 1, fn; i <= n; i ++) {
		cin >> fn;
		while(!machine.empty()) machine.pop();
		machine.push(fn);
		errflg = 0;
		situation = 0;
		for(int k = 1; k <= cnt_of_operator; k ++) {
			for(int v = 1; v <= 11; v ++) 
				if(opertations[k] == check_fail[v]) 
					to_do(v);
			if(errflg) break;
		} if(errflg) {cout << "ERROR" << endl; continue;}
		if(machine.size() != 1) {cout << "ERROR" << endl; continue;}
		cout << machine.top() << endl;
	}
}
```

---

## 作者：Loser_King (赞：1)

### Part 0 前言

随机跳题调到这题。。。

虽然题面有点长看起来吓人，

但是只要你一步一步按照题面模拟，就是道大水题

感觉实际难度黄+~绿

## Part 1 题意

> 给定一个栈和11个操作，开始时栈里仅有一个数x，经过几次操作后输出栈中的数。如果最后栈中不止一个数或计算过程中出现错误或数字过大溢出都应输出`ERROR`

## Part 2 做法

1. 读入：

   一直读入直到读入的字符串为`END`结束。

   建议使用`cin`而不是`scanf`。

   _注意：`NUM`操作是有参数的，所以在读的时候要特判并读进来。_

   ```c++
   	while(cin>>s[++tot]&&s[tot]!="END")
   	    if(s[tot]=="NUM")cin>>num[tot];
   ```

2. 操作

   一共有11种，分种类讨论。

   这里使用STL的`stack<int>`实现栈。

   - `NUM X`操作

     直接`push(num[i])`即可。

   - `POP`操作

     同样的，直接`pop()`即可。

     _注意：在此之后的操作都需要栈中至少有一至二个元素。_

   - `INV`操作

     取出栈顶`int t=top()`，然后`pop()`，最后`push(-t)`。

   - `DUP`操作

     `push(top())`即可。

   - `SWP,ADD,SUB,MUL,DIV,MOD`操作

     出栈两个数`int t1=top();pop();int t2=top()`，

     计算之后再入栈。

   - `END`操作

     （然而并没有操作）

3. 坑点

   需要输出`ERROR`的情况主要有以下几种：

   - 最后栈中不止一个元素
   - 计算过程中出现了大于 $10^9$ 的数
   - 输入的字符串不在指令集中或`NUM`操作没有参数（但是数据中并没有）
   - 在栈中的数据个数没有达到要求
   - `DIV`操作中除数为零（坑了很多人）

4. 优化

   写的时候会发现代码长度实在是太长了，所以这里提供一些可缩减代码量的`macro`（宏）

   - `ERR`

     输出`ERROR`并结束当前步骤。

     ```c++
     #define ERR {cout<<"ERROR\n";goto END;}
     ```

   - `CHK(x)`

     判断数 x 的绝对值是否过大。

     ```c++
     #define CHK(x) {if(x>MAX||x<-MAX)ERR}
     ```

   - `STC(x)`

     判断栈中的数量是否达到 x 。

     ```c++
     #define STC(x) {if(st.size()<x)ERR}
     ```

## Part 3 代码

使用了`switch-case`结构进一步缩减代码。

代码共91行，1695个字节。（`DEV-C++`的数据）

```c++
#include<bits/stdc++.h>
#define ERR {cout<<"ERROR\n";goto END;}
#define CHK(x) {if(x>MAX||x<-MAX)ERR}
#define STC(x) {if(st.size()<x)ERR}
#define int long long
using namespace std;
int const N=2333,MAX=1000000000;
string s[2333];
int n,tot,x,num[2333];
stack<int>st;
signed main(){
	while(cin>>s[++tot]&&s[tot]!="END")
	    if(s[tot]=="NUM")cin>>num[tot];
	cin>>n;
	while(n--){
		cin>>x;
		st=stack<int>();
		st.push(x);
		CHK(x)
		for(int i=1;i<=tot;i++){
			switch(s[i][0]){
				case'N':{
					CHK(num[i])
				    st.push(num[i]);
					break;
				}
				case'P':{
					STC(1)
					st.pop();
					break;
				}
				case'I':{
					STC(1)
					int x=st.top();st.pop();
					st.push(-x);
					break;
				}
				case'D':{
					if(s[i]=="DUP"){
						STC(1)
						st.push(st.top());
					}else{
						STC(2)
						int t1=st.top();st.pop();
						int t2=st.top();st.pop();
						if(!t1)ERR
						CHK(t2/t1)
						st.push(t2/t1);
					}
					break;
				}
				case'S':{
					STC(2)
					int t1=st.top();st.pop();
					int t2=st.top();st.pop();
					if(s[i]=="SWP"){
						st.push(t1);st.push(t2);
					}else{
						CHK(t2-t1)
						st.push(t2-t1);
					}
					break;
				}
				case'A':{
					STC(2)
					int t1=st.top();st.pop();
					int t2=st.top();st.pop();
					CHK(t1+t2)
					st.push(t1+t2);
					break;
				}
				case'M':{
					STC(2)
					int t1=st.top();st.pop();
					int t2=st.top();st.pop();
					if(s[i]=="MUL"){
						CHK(t2*t1)
						st.push(t2*t1);
					}else{
						CHK(t2%t1)
						st.push(t2%t1);
					}
					break;
				}
			}
		}
		if(st.size()!=1)ERR
		else cout<<st.top()<<"\n";
		END:;
	}
}
```



---

## 作者：Dirt、 (赞：1)

本题本身其实并不难~~主要是坑很多~~

我们先用f数组存下每一次的操作

然后对于每一次输入枚举f[i]来进行操作

在操作的过程中一定要注意判断当前局面/操作是否合法！

会输出"ERROR"的两种主要情况：

数字绝对值超过1000000000/栈内元素数量不足以支持某一步的操作

奉上蒟蒻丑陋的代码~

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<string>
using namespace std;
const long long maxn=1000000000;
int f[2003];
long long num[2003];//long long 保平安
int n,cnt,top; 
long long a[2003];//栈
bool check(long long x){return abs(x)>maxn;}//判断数字是否过大/过小
void func(long long x)
{
    memset(a,0,sizeof(a));//每次调用栈前需要清空
    if(check(x)){puts("ERROR");return;}//数字过大则直接return
    a[1]=x;
    top=1;
    for(int i=1;i<=cnt;i++)
    {
        if(f[i]==1)
        {
            if(check(num[i])){puts("ERROR");return;}
            a[++top]=num[i];
            continue;//防止之后检查的时候判断错误
        }
        if(top==0){puts("ERROR");return;}
        //之后可能出现的操作要求栈中必须有元素
        if(f[i]==2)
        {
            if(top==1){puts("ERROR");return;}
            top--;continue;
        }
        if(f[i]==3) {a[top]*=-1;continue;}
        if(f[i]==4){a[top+1]=a[top];top++;continue;}
        if(top<2){puts("ERROR");return;}
        //之后可能出现的操作要求栈中必须有至少两个元素
        if(f[i]==5) swap(a[top],a[top-1]);
        if(f[i]==6)
        {
            if(check(a[top]+a[top-1])){puts("ERROR");return;}
            a[top-1]+=a[top];top--;
            //可以直接对栈顶往下一位的元素进行运算
        }
        if(f[i]==7)
        {
            if(check(a[top-1]-a[top])){puts("ERROR");return;}
            a[top-1]-=a[top];top--;
        }
        if(f[i]==8)
        {
            if(check(a[top-1]*a[top])){puts("ERROR");return;}
            a[top-1]*=a[top];top--;
        }
        if(f[i]==9)
        {
            if(a[top]==0){puts("ERROR");return;}//不能除以0
            if(check(a[top-1]/a[top])){puts("ERROR");return;}
            a[top-1]/=a[top];top--;
        }
        if(f[i]==10)
        {
            if(a[top]==0){puts("ERROR");return;}//不能对0取模
            if(check(a[top-1]%a[top])){puts("ERROR");return;}
            a[top-1]%=a[top];top--;
        }
    }
    if(top!=1){puts("ERROR");return;}
    //栈中如果不是只有一个元素就报错
    printf("%lld\n",a[top]);
    return;
}
int main()
{
    string c;
    while(cin>>c)
    {
        if(c=="END") break;
        cnt++;
        if(c=="NUM")
        {
            f[cnt]=1;
            long long x;
            scanf("%lld",&x);
            num[cnt]=x;//存下每次NUM操作要加的数
        }
        if(c=="POP") f[cnt]=2;
        if(c=="INV") f[cnt]=3;
        if(c=="DUP") f[cnt]=4;
        if(c=="SWP") f[cnt]=5;
        if(c=="ADD") f[cnt]=6;
        if(c=="SUB") f[cnt]=7;
        if(c=="MUL") f[cnt]=8;
        if(c=="DIV") f[cnt]=9;
        if(c=="MOD") f[cnt]=10;
        //用f数组存储操作
    }
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {	
        long long x;
        scanf("%lld",&x);
        func(x);
    }
    return 0;
}
```
如果题解有误欢迎指出~


---

## 作者：Deny_小田 (赞：1)

我去，终于过了~~~

而且我是这道题的首AC耶。


本题的思路是：

模拟、模拟、往死里模拟！！！！！

注意要细心一些。


1：不用说，判断是否 > 10亿。


但是只判断这个是远远不够滴。因为还是0分。（我现身说法！10个点全部RE！）

这就引出了第二个：


2：除法的除数要判断是否为0！！！！！

超级重要的一点。。。


本题我给个评价吧，又难又烦=\_=

附代码：









```cpp
#include <cstdio>
#include <string>
#include <iostream>
#include <stack>
using namespace std;
typedef struct _node{
    string s;
    int num;
}Node;
const int size = 10005,limit = 1000000000;
int p = 0,c[size],n;
Node q[size];
void go(){ printf("ERROR\n"); }
int abs(int n){ return n>0?n:-n; }
bool jud(int n){ return n > limit; }
int main(int argc, char const *argv[]){
    // freopen("stack.in","r",stdin);
    while( true ){
        cin >> q[p].s;
        if(q[p].s == "NUM") scanf("%d",&q[p].num);
        if(q[p].s == "END") break;
        else p++;
    }
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%d",&c[i]);
    for(int i = 0; i < n; i++){
        stack<int> z;        z.push(c[i]);
        int flag = 1;
        for(int j = 0; j < p; j++){
            if(c[i] > limit){ flag = 0; break; }
            if(q[j].s == "NUM"){ if(jud(q[j].num)){ flag = 0; break; } z.push(q[j].num); }
            else if(q[j].s == "POP") z.pop();
            else if(q[j].s == "INV"){ int y = z.top(); if(jud(-y)){ flag = 0; break; } z.pop(); z.push(-y); }
            else if(q[j].s == "DUP"){ int y = z.top(); z.push(y); }
            else if(q[j].s == "SWP"){
                int x = z.top(); z.pop();
                int y = z.top(); z.pop();
                if(jud(x)||jud(y)){ flag = 0; break; }
                z.push(x); z.push(y);
            }else if(q[j].s == "ADD"){ 
                int x = z.top(); z.pop(); 
                int y = z.top(); z.pop(); 
                if(jud(x+y)){ flag = 0; break; }
                z.push(x+y); 
            }else if(q[j].s == "SUB"){
                int x = z.top(); z.pop();
                int y = z.top(); z.pop();
                if(jud(y-x)){ flag = 0; break; }
                z.push(y-x);
            }else if(q[j].s == "MUL"){
                int x = z.top(); z.pop();
                int y = z.top(); z.pop();
                if(jud(x*y)){ flag = 0; break; }
                z.push(x*y);
            }else if(q[j].s == "DIV"){
                int x = z.top(); z.pop();
                int y = z.top(); z.pop();
                if(!x){ flag = 0; break; }
                if(jud(y/x)){ flag = 0; break; }
                z.push(y/x);
            }else if(q[j].s == "MOD"){
                int x = z.top(); z.pop();
                int y = z.top(); z.pop();
                if(jud(y%x)){ flag = 0; break; }
                z.push(y%x);
            }
        }
        if(!flag){ go(); continue; } 
        if(z.size() != 1) go(); 
        else printf("%d\n",z.top());
    }
    return 0;
}
```

---

## 作者：WanderingTrader (赞：1)

此题是典型的栈操作有关的题目，看起来没有什么特别的方法，那只好直接模拟了。  
既然要用模拟，STL里的`stack<>`自然是个不错的选择。  
#### 题意简述
其实就是按照小Z的指示完成这些行为而已。  
#### 题目分析
此题的难点在于：哪些操作是不合法的。  
1. 栈内数据量少于操作要求的最少数据量。  
不同的操作有不同的需求，如下：
	- NUM：$0$ 
   - POP,INV,DUP: $1$ 
   - SWP,ADD,SUB,MUL,DIV,MOD：$2$
2. 计算过程中任何时候数值绝对值超过$1000000000(10^9)$  
3. DIV(除法)运算中分母为$0$。
4. 操作结束后栈的大小不为$1$  

明确了以上内容，我们就可以开始写代码了。 
#### 代码
初始化：
```cpp
#define N 2015
typedef long long ll;
#define MAX 1000000000
int len;
ll temp,a,b;
struct node { string s; ll k; } act[N];
int main(){
	string s;
	cin >> s;
	while(s != "END")
	{
		act[++ len].s = s;
		if(s == "NUM") scanf("%lld",&act[len].k);
		cin >> s;
	}
	ll n;
	ll t;
	scanf("%lld",&n);
	while(n --)
	{
		scanf("%lld",&t);
		deal(t);
	}
	return 0;
}
```
此处$len$存储操作数量，$temp,a,b$存储一些临时变量，$node$结构体存储每次操作的具体内容。  
接下来我们开始写$deal()$函数。  
首先我们定义一个栈并初始化：
```cpp
void deal(ll t)
{
	if(abs(t) > MAX) { printf("ERROR\n"); return; }//第2种不合法
	stack <ll> st;
	st.push(t);
}
```
注意要随时判断第$2$条不合法操作。  
然后跑一个循环，依次操作。  
NUM:
```cpp
if(act[i].s == "NUM")
{
	if(abs(act[i].k) > MAX) { printf("ERROR\n"); return; }//第2种不合法
	st.push(act[i].k);
}
```
POP:
```cpp
else if(act[i].s == "POP")
{
		if(!st.size()) { printf("ERROR\n"); return; }//第1种不合法
		st.pop();
}
```
INV：
```cpp
else if(act[i].s == "INV") 
{
	if(!st.size()) { printf("ERROR\n"); return; }//第1种不合法
	temp = st.top();
	st.pop();
	st.push(-temp);
}
```
DUP:
```cpp
else if(act[i].s == "DUP")
{
	if(!st.size()) { printf("ERROR\n"); return; }//第1种不合法
	st.push(st.top());
}
```
SWP:
```cpp
else if(act[i].s == "SWP")
{
	if(st.size() <= 1) { printf("ERROR\n"); return; }
	//第1种不合法
	a = st.top();
	st.pop();
	b = st.top();
	st.pop();
	st.push(a);
	st.push(b);
}
```
时刻牢记$3$种不合法情况。  
当然我们也要学会变通，有些不必判断的地方不判断(比如INV，DUP，SWP中不必判断第$2$种不合法)  
ADD：
```cpp
else if(act[i].s == "ADD")
{
	if(st.size() <= 1) { printf("ERROR\n"); return; }
	//第1种不合法
	a = st.top();
	st.pop();
	temp = a + st.top();
	if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
	//第2种不合法
	st.pop();
	st.push(temp);
}
```
SUB：
```cpp
else if(act[i].s == "SUB")
{
	if(st.size() <= 1) { printf("ERROR\n"); return; }
	//第1种不合法
	a = st.top();
	st.pop();
	temp = st.top() - a;
	if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
	//第2种不合法
	st.pop();
	st.push(temp);
}
```
MUL：
```cpp
else if(act[i].s == "MUL")
{
	if(st.size() <= 1) { printf("ERROR\n"); return; }
	//第1种不合法
	a = st.top();
	st.pop();
	temp = a * st.top();
	if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
	//第2种不合法
	st.pop();
	st.push(temp);
}
```
DIV：
```cpp
else if(act[i].s == "DIV")
{
	if(st.size() <= 1) { printf("ERROR\n"); return; }
	//第1种不合法
	a = st.top();
	if(!a) { printf("ERROR\n"); return; }
	//第3种不合法
	st.pop();
	temp = st.top() / a;
	if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
	//第2种不合法
	st.pop();
	st.push(temp);
}
```
MOD：
```cpp
else if(act[i].s == "MOD")
{
	if(st.size() <= 1) { printf("ERROR\n"); return; }
	//第1种不合法
	a = st.top();
	st.pop();
	temp = st.top() % a;
	if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
	//第2种不合法
	st.pop();
	st.push(temp);
}
```
结尾(循环外部)：
```cpp
if(st.size() == 1) printf("%lld\n",st.top());
//第4种不合法
else printf("ERROR\n");
```

这样，我们就处理完成了，同时覆盖到了所有的不合法现象。  
deal函数全部：
```cpp
void deal(ll t)
{
	if(abs(t) > MAX) { printf("ERROR\n"); return; }
	//第2种不合法
	stack <ll> st;
	st.push(t);
	for(int i = 1;i <= len;i ++)
	{
		if(act[i].s == "NUM")
		{
			if(abs(act[i].k) > MAX) { printf("ERROR\n"); return; }
			//第2种不合法
			st.push(act[i].k);
		}
		else if(act[i].s == "POP")
		{
			if(!st.size()) { printf("ERROR\n"); return; }
			//第1种不合法
			st.pop();
		}
		else if(act[i].s == "INV") 
		{
			if(!st.size()) { printf("ERROR\n"); return; }
			//第1种不合法
			temp = st.top();
			st.pop();
			st.push(-temp);
		}
		else if(act[i].s == "DUP")
		{
			if(!st.size()) { printf("ERROR\n"); return; }
			//第1种不合法
			st.push(st.top());
		}
		else if(act[i].s == "SWP")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			b = st.top();
			st.pop();
			st.push(a);
			st.push(b);
		}
		else if(act[i].s == "ADD")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = a + st.top();
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "SUB")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = st.top() - a;
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "MUL")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = a * st.top();
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "DIV")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			if(!a) { printf("ERROR\n"); return; }
			//第3种不合法
			st.pop();
			temp = st.top() / a;
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "MOD")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = st.top() % a;
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
	}
	if(st.size() == 1) printf("%lld\n",st.top());
	//第4种不合法
	else printf("ERROR\n");
}
```
代码确实非常长（加上注释约$110$行）……  
全部代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2015
typedef long long ll;
#define MAX 1000000000
int len;
ll temp,a,b;
struct node { string s; ll k; } act[N];
void deal(ll t)
{
	if(abs(t) > MAX) { printf("ERROR\n"); return; }
	//第2种不合法
	stack <ll> st;
	st.push(t);
	for(int i = 1;i <= len;i ++)
	{
		if(act[i].s == "NUM")
		{
			if(abs(act[i].k) > MAX) { printf("ERROR\n"); return; }
			//第2种不合法
			st.push(act[i].k);
		}
		else if(act[i].s == "POP")
		{
			if(!st.size()) { printf("ERROR\n"); return; }
			//第1种不合法
			st.pop();
		}
		else if(act[i].s == "INV") 
		{
			if(!st.size()) { printf("ERROR\n"); return; }
			//第1种不合法
			temp = st.top();
			st.pop();
			st.push(-temp);
		}
		else if(act[i].s == "DUP")
		{
			if(!st.size()) { printf("ERROR\n"); return; }
			//第1种不合法
			st.push(st.top());
		}
		else if(act[i].s == "SWP")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			b = st.top();
			st.pop();
			st.push(a);
			st.push(b);
		}
		else if(act[i].s == "ADD")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = a + st.top();
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "SUB")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = st.top() - a;
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "MUL")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = a * st.top();
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "DIV")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			if(!a) { printf("ERROR\n"); return; }
			//第3种不合法
			st.pop();
			temp = st.top() / a;
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
		else if(act[i].s == "MOD")
		{
			if(st.size() <= 1) { printf("ERROR\n"); return; }
			//第1种不合法
			a = st.top();
			st.pop();
			temp = st.top() % a;
			if(abs(temp) > MAX)	{ printf("ERROR\n"); return; }
			//第2种不合法
			st.pop();
			st.push(temp);
		}
	}
	if(st.size() == 1) printf("%lld\n",st.top());
	//第4种不合法
	else printf("ERROR\n");
}
int main(){
	string s;
	cin >> s;
	while(s != "END")
	{
		act[++ len].s = s;
		if(s == "NUM") scanf("%lld",&act[len].k);
		cin >> s;
	}
	ll n;
	ll t;
	scanf("%lld",&n);
	while(n --)
	{
		scanf("%lld",&t);
		deal(t);
	}
	return 0;
}
```
最后自然还是要计算一下复杂度。  
设操作数$s$，查询数$n$，复杂度约为$O(sn)$，而$1\le s,n\le2000$，虽然常数非常大，但是完成这道题已经足够了，可以$AC$(测试结果：所有测试点时间之和为$37ms$)。  
$The$ $end.$

---

## 作者：Eason_AC (赞：1)

## Update
- $\texttt{2020.10.27}$ 修了一下排版。

## Content
有一种程序给定你11种操作：

- $\text{NUM }x$：在栈顶放入元素 $x$。  
- $\text{POP}$：栈顶元素出栈。  
- $\text{INV}$：栈顶元素出栈，取其相反数后再入栈。
- $\text{DUP}$：在栈顶放入和栈顶元素一样的元素。
- $\text{SWP}$：将栈顶的两个元素交换。
- $\text{ADD}$：取出栈顶的两个元素，将两个元素的和入栈。
- $\text{SUB}$：取出栈顶的两个元素，将第二个元素减去第一个元素的差入栈。
- $\text{MUL}$：取出栈顶的两个元素，将两个元素的积入栈。
- $\text{DIV}$：取出栈顶的两个元素，将第二个元素除以第一个元素（**整除**）之后的结果作为一个元素入栈。
- $\text{MOD}$：取出栈顶的两个元素，将第二个元素取模以第一个元素之后的结果作为一个元素入栈。
- $\text{END}$：结束程序。

现用 $m$ 个操作（包含上面 $11$ 种操作，但不全部包含，可能会有一种操作多次使用的情况）编写一个函数 $f(x)$，其中 $x$ 为最初栈里的唯一一个元素。$f(x)$ 的结果即为 $m$ 个操作完成以后栈里的唯一一个元素。

编写一个程序，接受 $n$ 次询问，每次询问给出一个数 $x_i$，让你根据对应的 $x_i$ 求出 $f(x_i)$。注意，如果出现下列情况之一，输出 $\texttt{ERROR}$：

1. $m$ 次操作结束后栈内没有元素或者有两个及以上的元素。
2. 在 $m$ 次操作中，有任意一个计算过程算出来的结果的绝对值 $\geqslant 10^9$。
3. 输入数据不合法，导致中途退出。

**数据范围：$n,m\leqslant 2000$。**

## Solution
大模拟题，考察的是栈的基本操作和字符串的基本操作，但细节很多（这应该是它蓝了的原因）。

先再逐一考虑每种操作的代码实现：

- $\texttt{NUM}$ 操作：直接利用 $\texttt{push}$ 函数即可。
- $\texttt{POP}$ 操作：直接利用 $\texttt{pop}$ 函数即可。
- $\texttt{INV}$ 操作：将栈顶元素存储到一个变量中，然后进行 $\texttt{pop}$ 操作，再将栈顶元素取相反数用 $\texttt{push}$ 操作即可。
- $\texttt{DUP}$ 操作：用一个变量存储栈顶元素但不将栈顶元素弹出栈，然后直接利用 $\texttt{push}$ 函数即可。
- $\texttt{SWP}$ 操作：连续两次 $\texttt{pop}$ 操作，把先弹出来的元素先入栈，再将后弹出来的元素后入栈。不需要 $\texttt{swap}$ 函数。
- $\texttt{ADD}$ 操作：连续两次 $\texttt{pop}$ 操作，然后将弹出来的两个元素求和后再将求得的结果入栈。
- $\texttt{SUB}$ 操作：连续两次 $\texttt{pop}$ 操作，然后将后弹出来的元素减去先弹出来的元素后再将所得到的差值入栈。
- $\texttt{MUL}$ 操作：连续两次 $\texttt{pop}$ 操作，然后将弹出来的两个元素求积后再将求得的结果入栈。
- $\texttt{DIV}$ 操作：连续两次 $\texttt{pop}$ 操作，然后将后弹出来的元素整除以先弹出来的元素后再将所得到的结果入栈。
- $\texttt{MOD}$ 操作：连续两次 $\texttt{pop}$ 操作，然后将后弹出来的元素取模以先弹出来的元素后再将所得到的结果入栈。
- $\texttt{END}$ 操作：取出栈顶元素，如果里面仍不为空说明前面的操作做完了之后有两个及以上的元素，输出 $\texttt{ERROR}$，否则输出这个栈顶元素。

另外还要提防：

1. 每次操作中都可能会出现的运算结果的绝对值大于 $10^9$ 的情况。
2. $\texttt{DIV}$ 和 $\texttt{MOD}$ 操作中除数或模数为$0$的情况。
3. 出现了除上述 $11$ 种操作之外的操作的情况。

放心，整道题目代码量还不过 $200$ 行，可以接受的。

总之，这道题目考察思维难度还算好，如果按思维难度评分的话，我认为最多给它评个橙题。

## Code
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <stack>
#include <iostream>
using namespace std;

string move[2007];
int n, cnt;
long long x, move2[2007];

void mover(long long x) {
	if(abs(x) > 1e9) {
		puts("ERROR");
		return;
	}
	stack<long long> q;
	q.push(x);
	for(int i = 1; i <= cnt; ++i) {
//		cout << move[i] << endl;
		if(move[i] == "NUM") {
			if(abs(move2[i]) > 1e9) {
				puts("ERROR");
				return;
			}
			q.push(move2[i]);
		} else if(move[i] == "POP") {
			if(abs(q.top()) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
		} else if(move[i] == "INV") {
			long long x = q.top();
			if(abs(x) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			q.push(-x);
		} else if(move[i] == "DUP") {
			long long x = q.top();
			if(abs(x) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.push(x);
		} else if(move[i] == "SWP") {
			long long x1 = q.top();
			if(abs(x1) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x2 = q.top();
			if(abs(x2) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			q.push(x1);
			q.push(x2);
		} else if(move[i] == "ADD") {
			long long x1 = q.top();
			if(abs(x1) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x2 = q.top();
			if(abs(x2) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x = x1 + x2;
			if(abs(x) > 1e9) {
				puts("ERROR");
				return;
			}
			q.push(x);
		} else if(move[i] == "SUB") {
			long long x1 = q.top();
			if(abs(x1) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x2 = q.top();
			if(abs(x2) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x = x2 - x1;
			if(abs(x) > 1e9) {
				puts("ERROR");
				return;
			}
			q.push(x);
		} else if(move[i] == "MUL") {
			long long x1 = q.top();
			if(abs(x1) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x2 = q.top();
			if(abs(x2) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x = x1 * x2;
			if(abs(x) > 1e9) {
				puts("ERROR");
				return;
			}
			q.push(x);
		} else if(move[i] == "DIV") {
			long long x1 = q.top();
			if(abs(x1) > 1e9 || q.empty() || !x1) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x2 = q.top();
			if(abs(x2) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x = x2 / x1;
			if(abs(x) > 1e9) {
				puts("ERROR");
				return;
			}
			q.push(x);
		} else if(move[i] == "MOD") {
			long long x1 = q.top();
			if(abs(x1) > 1e9 || q.empty() || !x1) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x2 = q.top();
			if(abs(x2) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			long long x = x2 % x1;
			if(abs(x) > 1e9) {
				puts("ERROR");
				return;
			}
			q.push(x);
		} else if(move[i] == "END") {
			long long x = q.top();
			if(abs(x) > 1e9 || q.empty()) {
				puts("ERROR");
				return;
			}
			q.pop();
			if(!q.empty()) {
				puts("ERROR");
				return;
			}
			printf("%lld\n", x);
		} else {
			puts("ERROR");
			return;
		}
	}
}

int main() {
	while(cin >> move[++cnt] && move[cnt] != "END") {
		if(move[cnt] == "NUM")
			scanf("%d", &move2[cnt]);
	}
	scanf("%d", &n);
	while(n--) {
		scanf("%lld", &x);
		mover(x);
	}
}
```

---

## 作者：Mr_Wu (赞：1)

~~这题好哇，必须发波题解~~

-----

**题目**

[luogu P2186 小Z的栈函数](https://www.luogu.org/problemnew/show/P2186)

维护栈的$11$个操作，并提供报错功能

----

**栈是什么？**

虽然感觉没什么必要，但还是提一下吧$qwq$

**栈**是一种LIFO(Last In First Out)的基础数据结构，其支持的基础操作有：

1. $push$，入栈，放入一个数，这个数将会放在栈顶的上方
2. $pop$，出栈，将栈顶的数拿走
3. $top$，返回栈顶元素
4. $empty$，询问栈是否为空

举例：

初始状态：5 2 3
1. $push(1):$ 5 2 3 1
2. $pop():$ 5 2 3
3. $pop():$ 5 2

其基础实现：
```cpp
int stack[MAXN], l = 0;
void push(int x){stack[++l] = x;}
void pop(){l--;}
int top(){return stack[l];}
bool empty(){return l;}
```

----

**思路**

整理后，这题的错误总共只会有这$5$种：

1. 操作数$x$满足$|x|>1000000000$，下面简称$out(x)$
2. 当执行只$pop$一个的操作时$size=0$，下面简称$checklen0$
3. 当执行只$pop$两个的操作时$size<=1$，下面简称$checklen1$
4. 对于$DIV$和$MOD$两种操作，要判断除以$0$的情况，下面简称$div0$
5. 操作完后，$size!=1$，简称$checklen1$

我们可以将$11$中操作分类，加以分析，更加清楚

$(pop=0)$

- NUM **只需要查错**：$out(x)$

$(pop=1)$

- POP, INV, DUP **只需要查错**：$checklen0$

$(pop=2)$

|  | SWP | ADD | SUB | MUL | DIV | MOD |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $checklen1$ | √ | √ | √ | √ | √ | √ |
| $out(x)$ |  | √ | √ | √ | √ | √ |
| $div0$ |  |  |  |  | √ | √ |

----

**代码**

~~[0MS / 1.7MB](https://www.luogu.org/record/show?rid=7111667)~~

```cpp
#include <cstdio>
#include <cstring>

const int MAXN = 2005;
long long stack[MAXN], p1, p2;
int l, n, m;
bool flag = true; //是否合法，用来集中处理printf("ERROR\n");
struct step
{
	char data[4];
	int num;
}S[MAXN]; //用结构体存储每一步操作

void Input(); //输入
void Solve(long long x); //每一次的处理
bool OutNum(long long x); //辅助函数：out(x) 查询|x|>1000000000

int main()
{
	Input();
	scanf("%d", &m);
	int i;
	long long t;
	for (i = 1; i <= m; i++)
	{
		scanf("%lld", &t);
		Solve(t);
	}
	return 0;
}

void Input()
{
	int i = 1;
	scanf("%s", S[i].data);
	while (strcmp(S[i].data, "END") != 0)
	{
		if (strcmp(S[i].data, "NUM") == 0) scanf("%d", &S[i].num);
		else S[i].num = -1;
		i++;
		scanf("%s", S[i].data);
	}
	n = i - 1;
}

void Solve(long long x)
{
	int i = 1;
	long long t;
	l = 0, flag = true;
	if (OutNum(x))
	{
		printf("ERROR\n");
		return;
	} //一开始就判断一下，以免数据挖坑qwq
	stack[++l] = x;
	for (i = 1; i <= n; i++)
	{
		if (strcmp(S[i].data, "NUM") == 0) //将NUM操作单独处理
		{
			if (OutNum(S[i].num)) flag = false;
			else stack[++l] = S[i].num;
		}
		else if ((strcmp(S[i].data, "POP") == 0) || (strcmp(S[i].data, "INV") == 0) || (strcmp(S[i].data, "DUP") == 0))
		{ //(pop=1)的操作
			if (l == 0) flag = false; //checklen0
			else
			{
				t = stack[l];
				if (strcmp(S[i].data, "POP") == 0) l--;
				else if (strcmp(S[i].data, "INV") == 0) stack[l] = -t;
				else stack[++l] = t;
                //对每种操作分别对待（我会告诉你我这里strcmp后面没写==0调了半个小时？）
			}
		}
		else
		{ //(pop=2)的操作
			if (l <= 1) flag = false; //checklen1
			p1 = stack[l], p2 = stack[l - 1], l -= 2; //将栈顶两个数取出
			if ((strcmp(S[i].data, "MOD") == 0 || strcmp(S[i].data, "DIV") == 0) && p1 == 0) flag = false; //div0
			else if (strcmp(S[i].data, "SWP") == 0) stack[l + 1] = p1, stack[l + 2] = p2, l += 2; //SWP直接在这里处理掉
			else if (strcmp(S[i].data, "ADD") == 0) t = p2 + p1;
			else if (strcmp(S[i].data, "SUB") == 0) t = p2 - p1;
			else if (strcmp(S[i].data, "MUL") == 0) t = p2 * p1;
			else if (strcmp(S[i].data, "DIV") == 0) t = p2 / p1;
			else if (strcmp(S[i].data, "MOD") == 0) t = p2 % p1;
			
			if (strcmp(S[i].data, "SWP") != 0)
			{
				if (OutNum(t)) flag = false; //out(x)
				else stack[++l] = t; //放入处理好的数
			}
		}
		if (!flag)
		{
			printf("ERROR\n");
			return; //通过flag信号灯集中处理
		}
	}
	if (l != 1) printf("ERROR\n"); //checklen1
	else printf("%d\n", stack[1]);
}

bool OutNum(long long x)
{
	return x < -1000000000 || x > 1000000000;
} //辅助函数
```

--------


---

## 作者：冈崎梦美 (赞：1)

本蒟蒻第一道切掉的提高+/省选-的题目，值得纪念……

前前后后提交了13次，果然我还是太蒻了……

看到没有P题解就来发一篇……

一道~~zz工业码农~~模拟题，实现的其实只是栈的基本操作，但是判断合法真的很恶心……

主要判断有这几种：

1.退栈操作时栈为空。

2.二元操作时栈内不足二元。

3.一元操作时栈内不足一元。

4.进行入栈操作时入栈的数大于1e9。

5.除以0或模0

6.所有操作都运行完时，栈内剩余元素数量大于一。

下面就贴代码了，别怕，不超过200行的！

~~大部分函数代码是可以反复利用的~~

```pascal
type Stack=record
         x:array[1..5000]of int64;
         top:int64;
end;//P党需要手写一个栈
var p:Stack;
s,s1:string;l,x,n,i:longint;
m:array[1..5000]of string;q:array[1..5000]of int64;flag:boolean;

procedure print(k:Stack);
begin
    if (k.top=2) then writeln(k.x[k.top-1])
    else writeln('ERROR');//元素数量判定（6）
end;

function push(var k:Stack;num:int64):boolean;
begin
    if(abs(num)>1000000000) then exit(false);
    k.x[k.top]:=num;
    inc(k.top);
    exit(true);
end;

function pop(var k:Stack):boolean;
begin
    if (k.top=1) then exit(false);//退栈判定(1)
    dec(k.top);
    exit(true);
end;

function inv(var k:Stack):boolean;
begin
    if (k.top=1) then exit(false);
    k.x[k.top-1]:=-k.x[k.top-1];
    exit(true);
end;

function dup(var k:Stack):boolean;
begin
    if (k.top<2) then exit(false);
    k.x[k.top]:=k.x[k.top-1];
    inc(k.top);
    exit(true);
end;

function swp(var k:Stack):boolean;
var t1,t2:int64;
begin
    if(k.top<=2) then exit(false);
    t1:=k.x[k.top-1];
    t2:=k.x[k.top-2];
    pop(k);pop(k);
    push(k,t1);push(k,t2);
    exit(true);
end;

function add(var k:Stack):boolean;
var t:int64;
begin
    if (k.top<=2) then exit(false);
    t:=k.x[k.top-1]+k.x[k.top-2];
    if (abs(t)>1000000000) then exit(false);
    pop(k);pop(k);
    k.x[k.top]:=t;
    inc(k.top);
    exit(true);
end;

function sub(var k:Stack):boolean;
var t:int64;
begin
    if (k.top<=2) then exit(false);
    t:=k.x[k.top-2]-k.x[k.top-1];
    if (abs(t)>1000000000) then exit(false);
    pop(k);pop(k);
    k.x[k.top]:=t;
    inc(k.top);
    exit(true);
end;

function mul(var k:Stack):boolean;
var t:int64;
begin
    if (k.top<=2) then exit(false);
    t:=k.x[k.top-2]*k.x[k.top-1];
    if (abs(t)>1000000000) then exit(false);
    pop(k);pop(k);
    k.x[k.top]:=t;
    inc(k.top);
    exit(true);
end;


function chu(var k:Stack):boolean;
var t:int64;
begin
    if (k.top<=2) then exit(false);
    if (k.x[k.top-1]=0) then exit(false);
    t:=k.x[k.top-2] div k.x[k.top-1];
    if (abs(t)>1000000000) then exit(false);
    pop(k);pop(k);
    k.x[k.top]:=t;
    inc(k.top);
    exit(true);
end;

function mu(var k:Stack):boolean;
var t:int64;
begin
    if (k.top<=2) then exit(false);
    if (k.x[k.top-1]=0) then exit(false);
    t:=k.x[k.top-2] mod k.x[k.top-1];
    if (abs(t)>1000000000) then exit(false);
    pop(k);pop(k);
    k.x[k.top]:=t;
    inc(k.top);
    exit(true);
end;
begin
    i:=0;
    repeat
        inc(i);
        readln(m[i]);
    until m[i]='END';
    readln(n);
    for i:=1 to n do readln(q[i]);
    for l:=1 to n do
    begin
        flag:=true;
        p.top:=2;
        p.x[p.top-1]:=q[l];
        s:=m[1];
        i:=1;
        while(s<>'END') do
        begin
            s1:=copy(s,1,3);
            delete(s,1,4);
            if(s1='NUM') then
            begin
                val(s,x);
                if not push(p,x) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='POP') then
            begin
                if not pop(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='INV') then
            begin
                if not inv(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='DUP') then
            begin
                if not dup(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='ADD') then
            begin
                if not add(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='SUB') then
            begin
                if not sub(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='MUL') then
            begin
                if not mul(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='DIV') then
            begin
                if not chu(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='MOD') then
            begin
                if not mu(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            if(s1='SWP') then
            begin
                if not swp(p) then begin writeln('ERROR');flag:=false;break; end;
            end;
            inc(i);
            s:=m[i];
        end;
        if (flag) then print(p);
    end;
end.
```
写模拟才是真正的锻炼心性啊……


---

## 作者：SunsetSamsara (赞：0)

这题看上去挺难,其实就是清一色的大模拟

主要是**操作多**,但是也好做~~就打一堆if就好了~~

~~为了凑字数,~~ 我们使用手写栈存放原题中的栈:
```cpp
long long Stack[5001];
int StackTop;
void push(long long x){Stack[++StackTop]=x;}
long long pop(){return Stack[StackTop--];}
long long top(){return Stack[StackTop];}
```

接下来,我们就可以读入并保存程序了,我使用一个 `code` 的来存放操作符,用 `num` 来存放操作数(不过就 NUM 操作需要操作数)

至于运行部分,我感觉题目描述不太清晰(或许是我语文不好?),我想了很久才知道原来是每次把栈清空再只往栈中放一个数.这里要注意的点是每运行一步就要判一遍 ERROR.

```cpp
void Eval(long long a){
	StackTop=0;
	if(abs(a)>1000000000){
		puts("ERROR");
		return;
	}
	push(a);
	char *op=code[1];
	for(int i=1;i<=cnt;++i,op=code[i]){
		if(!strcmp(op,"NUM")){
			if(abs(num[i])>1000000000){
				puts("ERROR");
				return;
			}
			push(num[i]);
		}else if(!strcmp(op,"POP")){
			if(!StackTop){
				puts("ERROR");
				return;
			}
			pop();
		}else if(!strcmp(op,"INV")){
			if(!StackTop){
				puts("ERROR");
				return;
			}
			push(-pop());
		}else if(!strcmp(op,"DUP")){
			if(!StackTop){
				puts("ERROR");
				return;
			}
			push(top());
		}else if(!strcmp(op,"SWP")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			push(x);push(y);
		}else if(!strcmp(op,"ADD")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(abs(x+y)>=1000000000){
				puts("ERROR");
				return;
			}
			push(x+y);
		}else if(!strcmp(op,"SUB")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(abs(y-x)>=1000000000){
				puts("ERROR");
				return;
			}
			push(y-x);
		}else if(!strcmp(op,"MUL")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(abs(x*y)>=1000000000){
				puts("ERROR");
				return;
			}
			push(x*y);
		}else if(!strcmp(op,"DIV")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(x==0||abs(y/x)>=1000000000){
				puts("ERROR");
				return;
			}
			push(y/x);
		}else if(!strcmp(op,"MOD")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(x==0||abs(y%x)>=1000000000){
				puts("ERROR");
				return;
			}
			push(y%x);
		}
	}
	if(StackTop!=1){
		puts("ERROR");
		return;
	}else printf("%lld\n",top());
}
```

然后是读入环节,不难

```cpp
int main(){
	long long x;
	while(scanf("%s",code[++cnt])){
		if(!strcmp(code[cnt],"END"))break;
		num[cnt]=0;
		if(!strcmp(code[cnt],"NUM"))
			scanf("%lld",num+cnt);
	}
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&x);
		Eval(x);
	}
}
```

最后放完整代码,顺便推荐一下我 DIY 的与题目类似的 [栈式虚拟机](https://www.luogu.com.cn/blog/LuoguJudgerEnableO2/diy-zhan-shi-xu-ni-ji)
```cpp
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
long long Stack[5001];
int StackTop;
void push(long long x){Stack[++StackTop]=x;}
long long pop(){return Stack[StackTop--];}
long long top(){return Stack[StackTop];}
char code[2001][1001];
long long num[2001];
int cnt=0;
void Eval(long long a){
	StackTop=0;
	if(abs(a)>1000000000){
		puts("ERROR");
		return;
	}
	push(a);
	char *op=code[1];
	for(int i=1;i<=cnt;++i,op=code[i]){
		if(!strcmp(op,"NUM")){
			if(abs(num[i])>1000000000){
				puts("ERROR");
				return;
			}
			push(num[i]);
		}else if(!strcmp(op,"POP")){
			if(!StackTop){
				puts("ERROR");
				return;
			}
			pop();
		}else if(!strcmp(op,"INV")){
			if(!StackTop){
				puts("ERROR");
				return;
			}
			push(-pop());
		}else if(!strcmp(op,"DUP")){
			if(!StackTop){
				puts("ERROR");
				return;
			}
			push(top());
		}else if(!strcmp(op,"SWP")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			push(x);push(y);
		}else if(!strcmp(op,"ADD")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(abs(x+y)>=1000000000){
				puts("ERROR");
				return;
			}
			push(x+y);
		}else if(!strcmp(op,"SUB")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(abs(y-x)>=1000000000){
				puts("ERROR");
				return;
			}
			push(y-x);
		}else if(!strcmp(op,"MUL")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(abs(x*y)>=1000000000){
				puts("ERROR");
				return;
			}
			push(x*y);
		}else if(!strcmp(op,"DIV")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(x==0||abs(y/x)>=1000000000){
				puts("ERROR");
				return;
			}
			push(y/x);
		}else if(!strcmp(op,"MOD")){
			if(StackTop<=1){
				puts("ERROR");
				return;
			}
			long long x=pop(),y=pop();
			if(x==0||abs(y%x)>=1000000000){
				puts("ERROR");
				return;
			}
			push(y%x);
		}
	}
	if(StackTop!=1){
		puts("ERROR");
		return;
	}else printf("%lld\n",top());
}
int main(){
	long long x;
	while(scanf("%s",code[++cnt])){
		if(!strcmp(code[cnt],"END"))break;
		num[cnt]=0;
		if(!strcmp(code[cnt],"NUM"))
			scanf("%lld",num+cnt);
	}
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&x);
		Eval(x);
	}
}
```

---

## 作者：gigo_64 (赞：0)

这道题为什么都写了两百多行？？稍微压压行不也就八十的事情么qwq
就是正常的模拟啦，，加一点小小的特判，~~一点胡椒和孜然~~，就可以轻松溜过去啦。
上代码，码风超丑。
```cpp
#include<bits/stdc++.h>
using namespace std;
char c[6];
long long a[2004];
int top=1,n,sum=1,gugu[2004],w[2004],tot,flag=1; 
int main(){
//	freopen("1.in","r",stdin);
    long long x;
    while(scanf("%s",c),c[0]!='E'){
        int A=c[0],b=c[1];
        if(A=='N'&&b=='U'){
            cin>>x;sum++;if(x<0)x=-x;if(x>1000000000)flag=0;
            gugu[++tot]=1;w[tot]=x;
        } 
        if(A=='P'&&b=='O')gugu[++tot]=2,sum--;
        if(A=='I')gugu[++tot]=3;		                                     if(A=='D'&&b=='U')gugu[++tot]=4,sum++;
        if(A=='S'&&b=='W')gugu[++tot]=5; 
        if(A=='A'&&b=='D')gugu[++tot]=6,sum--;
        if(A=='S'&&b=='U')gugu[++tot]=7,sum--;
        if(A=='M'&&b=='U')gugu[++tot]=8,sum--;
        if(A=='D'&&b=='I')gugu[++tot]=9,sum--;
        if(A=='M'&&b=='O')gugu[++tot]=10,sum--;
    }
    cin>>n;
    if(sum!=1||!flag){//sum就是栈内数据size啦
        for(int i=1;i<=n;i++)cout<<"ERROR"<<endl;return 0;
    }flag=1;//废物利用
    while(n--){
        cin>>x;a[1]=x;top=1;flag=1;
        for(int i=1;i<=tot;i++){
            if(gugu[i]==1)a[++top]=w[i];
            if(gugu[i]==2)top--;
            if(gugu[i]==3)a[top]=-a[top];
            if(gugu[i]==4)top++,a[top]=a[top-1];
            if(gugu[i]==5)swap(a[top],a[top-1]);
            if(gugu[i]==6){
                x=a[top]+a[top-1];int qwq=x;
                if(x<0)x=-x;if(x>1000000000){
                     flag=0;goto out;
                }
                top--;a[top]=qwq;
            }
            if(gugu[i]==7){
                x=a[top-1]-a[top];int qwq=x;
                if(x<0)x=-x;if(x>1000000000){
                     flag=0;goto out;
                }
                top--;a[top]=qwq;
            }
            if(gugu[i]==8){
                x=a[top-1]*a[top];int qwq=x;
                if(x<0)x=-x;if(x>1000000000){
                     flag=0;goto out;
                }
                top--;
                a[top]=qwq;
            }
            if(gugu[i]==9){
                x=a[top-1]/a[top];int qwq=x;
                if(x<0)x=-x;if(x>1000000000){
                     flag=0;goto out;
                }
                top--;a[top]=qwq;
            }
            if(gugu[i]==10){
                x=a[top-1]%a[top];int qwq=x;
                if(x<0)x=-x;if(x>1000000000){
                     flag=0;goto out;
                }
                top--;a[top]=qwq;
            }
        }out://替代break的好东西，挺实用
        if(flag)
        cout<<a[top]<<endl;
        else cout<<"ERROR"<<endl;//就不用printf咋地哈哈哈哈哈ovo
    }
    return 0;
}
```



---

## 作者：巨型蚊子精 (赞：0)

总的来说，这还是一道比较简单~~毒瘤~~的题，关键在于特判~~别打错字~~。注释见代码。
```cpp
#include<iostream>
#include<algorithm>
#include<cmath> //使用abs
using namespace std;
long long n,zp=0,x;
long long z[1000001],a[1000001][2];
bool PUSH(long long p)//压入栈
{	
	if(abs(p)>1000000000)return false;//判断
	zp+=1;
	z[zp]=p;
	return true;
}
bool POP()//弹出栈
{
	if(zp<1)return false;//同上
	zp--;
	return true;
}
bool INV()//翻转
{
	if(zp<1)return false;
	z[zp]=-z[zp];
	return true;
}
bool DUP()//压入一个栈顶元素
{
	if(zp<1)return false;
	PUSH(z[zp]);
	return true;
}
bool SWP()//翻转
{
	if(zp<2)return false;
	int t=z[zp];z[zp]=z[zp-1];z[zp-1]=t;
	return true;
}
bool ADD()//加
{
	if(zp<2)return false;
	int t=z[zp]+z[zp-1];
	POP();
	POP();
	PUSH(t);
	return true;
}
bool SUB()//减
{
	if(zp<2)return false;
	int t=z[zp-1]-z[zp];
	POP();
	POP();
	PUSH(t);
	return true;
}
bool MUL()//乘
{
	if(zp<2)return false;
	int t=z[zp]*z[zp-1];
	POP();
	POP();
	PUSH(t);
	return true;
}
bool DIV()//除
{
	if(zp<2||z[zp]==0)return false;//除法特判
	int t=z[zp-1]/z[zp];
	POP();
	POP();
	PUSH(t);
	return true;
}
bool MOD()//求余
{
	if(zp<2||z[zp]==0)return false;//特判
	int t=z[zp-1]%z[zp];
	POP();
	POP();
	PUSH(t);
	return true;
}
void F(int m)//总处理函数
{	
	if(!PUSH(m))cout<<"ERROR"<<endl;
	int f=true;
	for(int i=1;i<=x;++i)
	{
		switch(a[i][1])//switch判断
		{
			case 1:{if(!PUSH(a[i][2]))f=false;break;}
			case 2:{if(!POP())f=false;break;}
			case 3:{if(!INV())f=false;break;}
			case 4:{if(!DUP())f=false;break;}
			case 5:{if(!SWP())f=false;break;}
			case 6:{if(!ADD())f=false;break;}
			case 7:{if(!SUB())f=false;break;}
			case 8:{if(!MUL())f=false;break;}
			case 9:{if(!DIV())f=false;break;}
			case 10:{if(!MOD())f=false;break;}
		}
	}
	if(zp!=1||f==false)cout<<"ERROR"<<endl;
	else cout<<z[zp]<<endl;
	return ;
}
int main()
{	
	string s;
	while(cin>>s&&s!="END")//读入运算符
	{
			if(s=="NUM"){a[++x][1]=1;cin>>a[x][2];}
			if(s=="POP"){a[++x][1]=2;}
			if(s=="INV"){a[++x][1]=3;}
			if(s=="DUP"){a[++x][1]=4;}
			if(s=="SWP"){a[++x][1]=5;}
			if(s=="ADD"){a[++x][1]=6;}
			if(s=="SUB"){a[++x][1]=7;}
			if(s=="MUL"){a[++x][1]=8;}
			if(s=="DIV"){a[++x][1]=9;}
			if(s=="MOD"){a[++x][1]=10;}

	}
	cin>>n;
	for(int i=1;i<=n;++i)//处理
	{		
		zp=0;
		int m;
		cin>>m;
		F(m);
	}
	return 0;
}

```

---

## 作者：zhenglier (赞：0)

写模拟题最重要的就是要简短，对于这题的几个ERROR条件，我们可以都封装起来：

1、数的绝对值大于1000000000，弄成error1(x)见下。

2、栈为空时调用"POP""INV""DUP"操作，弄成error2()。

3、栈的大小小于2时，调用"SWP""ADD""SUB""MUL""DIV""MOD"，弄成error3()。

4、其实还有个坑点，某位惹不起的同学掉进了这个坑，就是除0是要判断，这里不用封装，只用在"DIV"里判断一下就行了。

接下来就是非常愉快的模拟了，我用的是STL的栈，当然也可以用自己的手写栈，不过~~我懒~~这题不卡时间，STL可以了。

代码是真的很短，打起来也很爽
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ext() {puts("ERROR");return;}
#define error1(x) if(abs(x)>1000000000)ext()
#define error2() if(st.empty())ext()
#define error3() if(st.size()<2)ext()
#define get() ll x=st.top();st.pop();ll y=st.top();st.pop();
using namespace std;
struct node{
    string s;
    ll x;
} f[2100];
int cnt;
string c;
void fun(ll x) {
    stack<ll>st;
    error1(x);
    st.push(x);
    for(int i=1; i<=cnt; i++){
    	if(f[i].s=="POP"||f[i].s=="INV"||f[i].s=="DUP")error2()
    	if(f[i].s=="SWP"||f[i].s=="ADD"||f[i].s=="SUB"||f[i].s=="MUL"||f[i].s=="DIV"||f[i].s=="MOD")error3()
        if(f[i].s=="NUM"){
            error1(f[i].x)
            st.push(f[i].x);
        }
		if(f[i].s=="POP"){
            st.pop();
        }
		if(f[i].s=="INV"){
            ll x=st.top();st.pop();
            st.push(-x);
        }
		if(f[i].s=="DUP"){
            st.push(st.top());
        }
		if(f[i].s=="SWP"){
            get()
            st.push(x);
            st.push(y);
        }
		if(f[i].s=="ADD"){
            get()
            error1(y+x)
            st.push(x+y);
        }
		if(f[i].s=="SUB"){
            get()
            error1(y-x)
            st.push(y-x);
        }
		if(f[i].s=="MUL"){
            get()
            error1(y*x)
            st.push(x*y);
        }
		if(f[i].s=="DIV"){
            get()
            if(x==0)ext();
            error1(y/x)
            st.push(y/x);
        }
		if(f[i].s=="MOD"){
            get()
            error1(y%x)
            st.push(y%x);
        }
    }
    if(st.size()==1)printf("%lld\n",st.top());
    else ext();
}
ll n;
inline ll read(){
	ll ret=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);ret=(ret<<1)+(ret<<3)+c-'0',c=getchar());
	return ret*f;
}
int main() {
    while(cin>>c) {
        if(c=="END")break;
        f[++cnt].s=c;
        if(c=="NUM")f[cnt].x=read();
    }
    cin>>n;
    for(int i=1;i<=n;i++)fun(read());
    return 0;
}
```

---

## 作者：WLHW (赞：0)

这其实是一道很水的题目，就直接根据题意，进行模拟就够了，在我的努力下  代码缩短到只有100行。

PS：别忘了再每一行开始，记得吧栈清空！


```cpp
#include<bits/stdc++.h>
using namespace std;
stack<long long>q;
struct node
{
	int x;
	string s;
} a[100010];
int cnt;
long long inf=1000000000;
bool sol(long long x)
{
	int i;
	long long k1,k2;
	if(abs(x)>inf) return 0;
	q.push(x);
	for(i=1; i<=cnt; i++)
	{
		if(a[i].s=="NUM")
		{
			if(abs(a[i].x)>inf) return 0;
			q.push(a[i].x);
		}
		else if(a[i].s=="POP")
		{
			if(q.empty()) return 0;
			q.pop();
		}
		else if(a[i].s=="INV")
		{
			if(q.empty()) return 0;
			k1=q.top();
			q.pop();
			q.push(-k1);
		}
		else if(a[i].s=="DUP")
		{
			if(q.empty()) return 0;
			q.push(q.top());
		}
		else
		{
			if(q.size()<2) return 0;
			k1=q.top();
			q.pop();
			k2=q.top();
			q.pop();
			if(a[i].s=="SWP")
			{
				q.push(k1);
				q.push(k2);
			}
			else
			{
				if(a[i].s=="ADD")
					k1=k1+k2;
				else if(a[i].s=="SUB")
					k1=k2-k1;
				else if(a[i].s=="MUL")
					k1=k1*k2;
				else if(a[i].s=="DIV")
				{
					if(k1==0) return 0;
					k1=k2/k1;
				}
				else if(a[i].s=="MOD")
					k1=k2%k1;
				if(abs(k1)>inf) return 0;
				q.push(k1);
			}
		}
	}
	if(q.size()==1) return 1;
	else return 0;
}
int main()
{
	string s;
	int i,n;
	cnt=0;
	long long x;
	while(1)
	{
		cin>>s;
		if(s=="END") break;
		if(s=="NUM") cin>>x;
		cnt++;
		a[cnt].x=x;
		a[cnt].s=s;
	}
	scanf("%d",&n);
	while(n--)
	{
		cin>>x;
		while(!q.empty()) q.pop(); 
		if(!sol(x)) printf("ERROR\n");
		else printf("%lld\n",q.top());
	}
	return 0;
}
```

---

## 作者：hibiki (赞：0)

同楼下随机跳题233~

想发这个题解的最主要的原因是楼下的几篇题解或多或少都可以被一些数据卡掉（我对拍时发现的），但是题目数据不强，没有出现这种情况。

主要判ERROR思想：1、任何数入栈之前检查绝对值大小；2、任何单元操作（DUP等）前检查栈是否为空；3、任何双元操作（ADD等）之前检查栈中元素是否有两个；4、操作结束后检查栈中元素数量。

为了放置int\*int的时候爆掉int,故所有的变量都开了long long。

所有的函数分开写，但是用一个work函数统一处理，所有函数类型均为bool，一旦不合法直接返回false

```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#define MAXN 2000
#define INF 1000000000
#define ll long long
using namespace std;
ll stack[MAXN+10];
string cmd[MAXN+10];
ll Num[MAXN+10];
int top=0,n,cnt=1;
ll x;
void push(ll x){
    top++;
    stack[top]=x;
}
bool POP(){
    if (top<1) return false;
    top--;
    return 1;
}
bool NUM(ll x){
    if (abs(x)>INF) return false;
    push(x);
    return 1;
}
bool INV(){
    ll tt=-stack[top];
    POP();
    push(tt);
    return 1;
}
bool DUP(){
    if (top<1) return false;
    push(stack[top]);
    return 1;
}
bool SWP(){
    if (top<2) return false;
    swap(stack[top],stack[top-1]);
    return 1;
}
bool ADD(){
    if (top<2) return false;
    ll tt=stack[top]+stack[top-1];
    if (abs(tt)>INF) return false;
    POP();POP();
    push(tt);
    return 1;
}
bool SUB(){
    if (top<2) return false;
    ll tt=stack[top-1]-stack[top];
    if (abs(tt)>INF) return false;
    POP();POP();
    push(tt);
    return 1;
}
bool MUL(){
    if (top<2) return false;
    ll tt=stack[top-1]*stack[top];
    if (abs(tt)>INF) return false;
    POP();POP();
    push(tt);
    return 1;
}
bool DIV(){
    if (top<2) return false;
    if (stack[top]==0) return false;
    ll tt=stack[top-1]/stack[top];
    POP();POP();
    push(tt);
    return 1;
}
bool MOD(){
    if (top<2) return false;
    if (stack[top]==0) return false;
    ll tt=stack[top-1] %stack[top];
    POP();POP();
    push(tt);
    return 1;
}
bool work(string x,int cnt){ //统一处理所有函数
    if (x=="NUM") return NUM(Num[cnt]);
    if (x=="POP") return POP();
    if (x=="INV") return INV();
    if (x=="DUP") return DUP();
    if (x=="SWP") return SWP();
    if (x=="ADD") return ADD();
    if (x=="SUB") return SUB();
    if (x=="MUL") return MUL();
    if (x=="DIV") return DIV();
    if (x=="MOD") return MOD();
}
int main(){
    //freopen("2186.in","r",stdin);
    //freopen("2186.out","w",stdout);
    cin>>cmd[1];
    while (cmd[cnt]!="END"){
        if (cmd[cnt]=="NUM") cin>>Num[cnt]; //对NUM操作特别读入一个值
        cnt++;
        cin>>cmd[cnt];
    }
    cin>>n;
    for (int i=1;i<=n;i++){
        top=0;
        cin>>x;
        if (abs(x)>INF){
            cout<<"ERROR"<<endl;
            continue;
        }
        push(x);
        for (int j=1;j<=cnt;j++){
            if (cnt==j){
                if (top!=1) cout<<"ERROR"<<endl; else
                cout<<stack[top]<<endl;
                break;
            }
            if (!work(cmd[j],j)) {
                cout<<"ERROR"<<endl;
                break;
            }
        }
    }
}
```

---

## 作者：LYFer (赞：0)

题目让我见识到了什么叫做大模拟题，需要注意的细节很多。

但无非就两个

栈总的数超过1000000000

栈为空，但是还要进行取出操作。

实现我写烂了，260多行。

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <stack>
#include <cmath>
#include <iostream>

using namespace std;

struct node{
    long long num;
    string Code;
}Run[2005];
stack<long long>st;
int tot,n;
bool flag;
bool made;


inline bool Can(){
    if(st.empty()) return false;
    else return true;
}

inline void PrintError(){
    cout<<"ERROR"<<endl;
    made=1;
    return;
}

void NUM(long long x){
    st.push(x);
}

void INV(){
    if(Can()){
        long long x = st.top();
        st.pop();
        st.push(-x);
    }
    else{
        PrintError();
    }
}

void POP(){
    if( Can() ) st.pop();
    else PrintError();
}

void DUP(){
    if( Can() ){
        long long x = st.top();
        st.push(x);
    }
    else PrintError();
}

void ADD(){
    if( Can() ){
        //cout<<"!!!!!"<<st.size()<<endl;
        long long x = st.top();
        st.pop();
        if( Can() ){
            //cout<<st.size()<<endl;
            long long y = st.top();
            long long tot = x+y;
            st.pop();
            if(abs(tot)>1000000000) {
            //cout<<"Fuck"<<endl;
            PrintError();
            return;
            }
            st.push(tot);

        }
        else PrintError();
    }
    else PrintError();
}

void MUL(){
    if( Can() ){
        long long x = st.top();
        st.pop();
        if( Can() ){
            long long y = st.top();
            long long tot = x*y;
            st.pop();
            if(abs(tot)>1000000000) {
            PrintError();
            return;
            }
            st.push(tot);
        }
        else PrintError();
    }
    else PrintError();
}

void DIV(){
    if( Can() ){
        long long x = st.top();
        if(x==0){
            PrintError();
            return;
        }
        st.pop();
        if( Can() ){
            long long y = st.top();
            long long tot = y/x;
            st.pop();
            if(abs(tot)>1000000000) {
            PrintError();
            return;
            }
            st.push(tot);
        }
        else PrintError();
    }
    else PrintError();
}

void MOD(){
    if( Can() ){
        long long x = st.top();
        
        if(x==0){
            PrintError();
            return;
        }
        
        st.pop();
        if( Can() ){
            //cout<<st.size()<<" "<<"!!!!"<<endl;
            long long y = st.top();
            long long tot = y%x;
            //cout<<tot<<" "<<"!!!!"<<endl;
            st.pop();
            if(abs(tot)>1000000000) {
            PrintError();
            return;
            }
            st.push(tot);
        }
        else PrintError();
    }
    else PrintError();
}

void SUB(){
    if( Can() ){
        long long x = st.top();
        st.pop();
        if( Can() ){
            long long y = st.top();
            long long tot = y-x;
            st.pop();
            if(abs(tot)>1000000000) {
            PrintError();
            return;
            }
            st.push(tot);
        }
        else PrintError();
    }
    else PrintError();    
}

void SWP(){
    if( Can() ){
        long long x = st.top();
        st.pop();
        if( Can() ){
            long long y = st.top();
            st.pop();
            st.push(x);
            st.push(y);
        }
        else PrintError();
    }
    else PrintError();
}

void run(){
    for(int i=1;i<=tot;i++){
        //cout<<Run[50].Code<<endl;
        if(Run[i].Code=="NUM"){
            NUM(Run[i].num);
        }
        else if(Run[i].Code=="POP"){
            POP();
        }
        else if(Run[i].Code=="INV"){
            INV();
        }
        else if(Run[i].Code=="DUP"){
            DUP();
        }
        else if(Run[i].Code=="SWP"){
            SWP();
        }
        else if(Run[i].Code=="ADD"){
            ADD();
        }
        else if(Run[i].Code=="SUB"){
            SUB();    
        }
        else if(Run[i].Code=="MUL"){
            MUL();
        }
        else if(Run[i].Code=="MOD"){
            MOD();
        }
        else if(Run[i].Code=="DIV"){
            DIV();
        }
        if(made==1) return;
    }
    //cout<<st.size()<<"!!!!!"<<endl;
    
    if(st.size()==1){
        //cout<<"FFFFFFFFFFFFFF"<<endl;
        cout<<st.top()<<endl;
    }
    else PrintError();
}

int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    string Start;
    while(cin>>Start){
        if(Start=="END") break;
        
        if(Start=="NUM"){
            long long fuck;
            cin>>fuck;
            if(abs(fuck)>1000000000) flag=1;
            if(!flag) Run[++tot].num = fuck;
            Run[tot].Code = Start;
        }
        else{
            Run[++tot].Code= Start;
        }
    }
    //cout<<Run[51].Code<<"!!!!"<<endl;
    cin>>n;
    while(n--){
        made=0;
        while(!st.empty()) st.pop();
        long long x;
        cin>>x;
        if(abs(x)>1000000000){
            PrintError();
        }
        else {
            //cout<<st.size()<<"!!!!"<<endl;
            st.push(x);
            run();
        }
    }
    return 0;
}
```

---

## 作者：feilongz (赞：0)

经本人测试，建议修改部分数据，否则会使得不符合标准的程序AC。

如原题目要求：绝对值<100000000然而之前的题解代码并未确认绝对值情况。

第二，原题目的主要难度不在于栈操作，而是在于不合法状态的判断。

如：绝对值情况，栈空情况，除零情况。能搞清楚何时判断是难点。

题解较长，我模块化的编程，各位可以选取需要的地方。

# 判断模块

## 法则Law

以下的三个law分别判断大小，栈内程度（n表示需要的数目，若少于毫无疑问会报错，返回假。）

当然还有除零。

Sizelaw在先前的某个题解中没有经常判断，我对拍的时候标解总是崩溃。。当然如果你要A题在改数据前并不需要，但是在下还是建议稳妥。因为题目已经说明“可能不合法”。

```cpp
bool Biglaw(int n)                
{
    if(n>1000000000)
      return false;
    return true;
}
bool Sizelaw(int n)
{
    if(s.size()<n)
      return false;
    return true;
}
bool Divlaw(int a,int b)
{
    if(b==0)
      return false;
    return true;
}
```
# 栈处理模块
其他处理不表，参看尾部代码。重点是以下这个：

## SWP操作。这个涉及一个点，要牢记栈的性质（我和某大神均WA这点）

如果你要交换栈顶两个元素顺序（当然我们已经用law判断了栈内至少两个元素）

我们弹出k1,k2两个元素，应该按什么顺序推回呢？惯性思维当然是k2,k1。但是栈是不一样的。手动模拟一下会立即发现，这样推回顺序根本没变。任何一步失败都会导致连锁反应，如果你一直90，多半是这个错误了。

push的时候一定要按k1,k2push回，栈的性质(先进先出）会使得两个数字交换的。

## 其他操作

简单提一下，每步需要取出元素都用law判断元素够不够，防止崩溃。不过某些地方push的时候不用特地判断大小了。比如INV，DUP，取出的必然是插入时判断过的了。但是涉及到加减，乘除必须判断大小再push，否则一律ERROR（当然在我的代码里这个模块回返回假）。

这里调试痕迹太多。。

# Control枢纽

这里用来转运各种操作，就是一个执行罢了（虹桥机场》？）

# 主程序

在线处理的。。先读入操作，数字化操作存在数组里，然后对于每个初始元素遍历一遍操作。每次结束后尽管你知道栈应该是空的，还是建议您判断一下栈空，不空就弹出来吧。


最后一些细节，一个是诸多判断，初始化，判空，还有最终输出的时候要判断是否是“一个元素”，否则还是ERROR。数据虽然不完善，但我可以设计一组崩掉某些代码。。当然，还有abs。


最后的最后上代码。代码较长，但是还是比较可读的，慢慢分区读吧。

最后的最后的最后祝你AC，不要放弃啊！做码农题也不放弃才是不忘本心啊！（虽然是自己作死啦）

%%%%%%%%

      
    



      
    



        
      
          
          

         
       
      
    
      
    



          











          
    
          


```cpp
//代码
#include<cstdio>
#include<iostream>
#include<stack>
#include<cstring>
#include<string>
using namespace std;
stack<int>s;
int Command[5001][2];
//LS
int abs(int a)
{
    if(a<0)return -a;
    return a;
}
//Laws
bool Biglaw(int n)
{
    if(abs(n)>1000000000)
      return false;
    return true;
}
bool Sizelaw(int n)
{
    if(s.size()<n)
      return false;
    return true;
}
bool Divlaw(int a,int b)
{
    if(b==0)
      return false;
    return true;
}
//Commands
bool NUM(int n)
{
  if(Biglaw(n))
    s.push(n);
  else
    return 0;
  return 1;
}
bool POP()
{
  if(!s.empty())
    s.pop();
  else
    return 0;
return 1;
}
bool INV()
{
    int k;
    if(!s.empty())
      k=s.top();
    else
      return 0;
    s.pop();
    k=-k;
    s.push(k);
return 1;
}
bool DUP()
{
    if(!s.empty())
    {
    int k=s.top();
    s.push(k);
    }
    else
      return 0;
return 1;
}
bool SWP()
{
    int k1,k2;
    if(Sizelaw(2))
      {  
        k1=s.top();
         s.pop();
        k2=s.top();
         s.pop();
    s.push(k1);
    s.push(k2);
      }
    else
      return 0;
    return 1;
}
bool ADD()
{
    if(Sizelaw(2))
    {
      int k1=s.top();
      s.pop();
      int k2=s.top();
      s.pop();
      if(Biglaw(k1+k2))
        s.push(k1+k2);
    else
      return 0;
    }
    else
      return 0;
    return 1; 
}
bool SUB()
{
    if(Sizelaw(2))
    {
    int k1=s.top();
    s.pop();
    int k2=s.top();
    s.pop();
    if(Biglaw(k2-k1))
    s.push(k2-k1);
  else
    return 0;
    }
    else
     return 0;
return 1;
}
bool MUL()
{
    if(Sizelaw(2))
    {
    int k1=s.top();
    s.pop();
    int k2=s.top();
    s.pop();
    if(Biglaw(k1*k2))
    s.push(k1*k2);
   else
     return 0;
    }
   else
     return 0;
return 1;
}
bool DIV()
{
    if(Sizelaw(2))
    {
    int k1=s.top();
    s.pop();
    int k2=s.top();
    s.pop();
    if(Divlaw(k2,k1))
    {
      if(Biglaw(k2/k1))
         s.push(k2/k1);
     }
   else
       return 0;
    }
    else
      return 0;
return 1;
}
bool MOD()
{
    if(Sizelaw(2))
    {
    int k1=s.top();
    s.pop();
    int k2=s.top();
    s.pop();
    if(Divlaw(k2,k1))
    {
    if(Biglaw(k2%k1))
      s.push(k2%k1);
    }
    else
      return 0;
    }
    else
     return 0;
return 1;
}
bool END()
{
    if(s.size()==1)
    {
      printf("%d\n",s.top());
      s.pop();
    }
    else
      return 0;
     return 1;
}
//Bugs
void ERROR()
{
    printf("ERROR\n");
    return;
}
//MissionControl
bool Control(int k,int n)
{
    if(k==1)
      if(NUM(n))
       return 1;
      else
        return 0;
    if(k==2)
      if(POP())
        return 1;
    else
      return 0;
    if(k==3)
      if(INV())
         return 1;
        else
          return 0;
    if(k==4)
      if(DUP())
         return 1;
        else
          return 0;
    if(k==5)
      if(SWP())
        return 1;
       else
         return 0;
    if(k==6)
      if(ADD())
        return 1;
       else
         return 0;
    if(k==7)
      if(SUB())
        return 1;
     else
       return 0;
    if(k==8)
      if(MUL())
        return 1;
    else
      return 0;
    if(k==9)
      if(DIV())
        return 1;
    else
       return 0;
    if(k==10)
      if(MOD())
        return 1;
    else
      return 0;
    if(k==11)
      if(END())
        return 1;
    else
      return 0;
    return 1;
}
int main()
{
    int k;
    memset(Command,0,sizeof Command);
    Command[1][0]=1;
    for(int i=2;i<=2001;++i)
      {
          string s;
          cin>>s;
          k=i;
          if(s=="END")
           {
           Command[i][0]=11;
             break;
         }
          if(s=="NUM")
            {
                int a1;
                scanf("%d",&a1);
                Command[i][0]=1;
                Command[i][1]=a1;
            }
        if(s=="POP")
            Command[i][0]=2;
        if(s=="INV")
                Command[i][0]=3;
        if(s=="DUP")
                Command[i][0]=4;
        if(s=="SWP")
                Command[i][0]=5;
        if(s=="ADD")
                Command[i][0]=6;
        if(s=="SUB")
                Command[i][0]=7;
        if(s=="MUL")
                Command[i][0]=8;
        if(s=="DIV")
                Command[i][0]=9;
        if(s=="MOD")
                Command[i][0]=10;
      }
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
      {
          int a1;
          scanf("%d",&a1);
          if(abs(a1)>1000000000)
           {
            ERROR();
            continue;
         }
          Command[1][1]=a1;
          for(int j=1;j<=k;++j)
              if(!Control(Command[j][0],Command[j][1]))
              {
                ERROR();
              Command[1][1]=0;
                break;
              }
      }
//AC by fz
}

```

---


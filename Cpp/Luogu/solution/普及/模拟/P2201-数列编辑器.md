# 数列编辑器

## 题目描述

小 Z 是一个爱好数学的小学生。最近，他在研究一些关于整数数列的性质。

为了方便他的研究，小Z希望实现一个叫做“Open Continuous Lines Processor”的数列编辑器。

一开始，数列编辑器里没有数字，只有一个光标。这个数列编辑器需要支持五种操作。

- `I x` 在当前光标前插入数字 $x$。
- `D` 删除当前光标前的数字。
- `L` 光标向前移动一个数字。
- `R` 光标向后移动一个数字。
- `Q k` 设光标之前的数列是 $\{a_1,a_2,\cdots,a_n\}$，输出第 $k$ 位及之前最大的前缀和，保证 $k\leqslant n$。

## 说明/提示

### 数据范围

对于 $50\%$ 的数据，$N\leqslant1000$；

对于 $80\%$ 的数据，$N\leqslant10^5$；

对于 $100\%$ 的数据，$N\leqslant10^6$，插入的数字绝对值大小不会超过 $1000$。

题目保证不会在数列编辑器为空时进行 `D` 操作。

## 样例 #1

### 输入

```
8
I 2
I -1
I 1
Q 3
L
D
R
Q 2```

### 输出

```
2
3```

# 题解

## 作者：MloVtry (赞：15)

思路大概是和楼下相同的

不过既然考虑到这个移动是具有一定的先后顺序的，我们可以使用栈来操作

相对于链表来说，还是栈更容易写吧（心虚...）

这里的写法稍微有一点麻烦

首先是读入的序列，可以放入s1的栈

然后光标之后的部分我们设为栈s2

这样
I操作：读入一个数，并放入s1（以及更新相应数值）

D操作：删除s1栈顶

L操作：将s1栈顶放入s2中

R操作：将s2栈顶放入s1中（以及更新相应数值）

Q操作：输出

维护一个s1的前缀和（S）以及一个答案数组（ans），表示i以及i之前的最大值

//写成函数食用更佳

代码
```cpp
#include<iostream>
#define N 1000010
#include<cstdio>
using namespace std;
int s1[N],s2[N];
int ans[N],S[N];
int top1,top2,n;
int main()
{
    scanf("%d",&n);
    ans[0]=-(1<<30);
    for(int i=1;i<=n;i++)
    {
        char fl;cin>>fl;
        if(fl=='I')
        {
            int x;scanf("%d",&x);
            s1[++top1]=x;
            S[top1]=S[top1-1]+x;
            ans[top1]=max(ans[top1-1],S[top1]);
        }
        if(fl=='D') top1--;
        if(fl=='L') s2[++top2]=s1[top1--];
        if(fl=='R')
        {
            int x=s2[top2--];
            s1[++top1]=x;
            S[top1]=S[top1-1]+x;
            ans[top1]=max(ans[top1-1],S[top1]);
        }
        if(fl=='Q')
        {
            int x;scanf("%d",&x);
            printf("%d\n",ans[x]);
        }
    }
    return 0;
}
//今天也依旧没有捞到岛风厌战呢

```

---

## 作者：hovny (赞：6)

### [数列编辑器](https://www.luogu.org/problemnew/show/P2201)，在线IDE

~~本期的主题是你谷的在线IDE~~  

小学生？！小学生虐我 :cry:  

### 思路：

怎么说**链表**也是可以的吧，虽然比较繁琐  

然后涉及到了**前缀和**和一些优化**手段**（应该可以说是记忆化吧）？  

用p记录光标的位置  

虽然这道题的数据范围挺大的（1~1,000,000）   

但是题目中说，k一定在p之前   

所以实际上只有**p前面的序列**是有效的  

于是我们就可以写一个**半在线半离线**的算法  

用**链表模拟数列**  

当然了，**不用按照顺序**，我们只用把数字存一下，然后顺序什么的一切靠链表解决  

用 **f**数组 存i点（这里的i不是数列中的顺序，而是实际读入的顺序，下同，具体见代码）的最大前缀和，这样就可以直接查询  

用 **s**数组 存i点的前缀和，方便更新**f**数组  

然后用 **ord**数组 记录一下每个数在数列中的编号（不是实际的编号，有点类似hash的样子）  

每接受一个操作就做一次更新  

代码如下：  

```c++
#include<bits/stdc++.h>
#define INF 0x7f7f7f7f
using namespace std;
struct node{
	int f,t;//f表示前驱，t表示后继（由于本菜鸟不喜欢front和next……请谅解~）
	int s;
}b[1000010];
int T,t,p,n;
int s[1000010];
int f[1000010];
int ord[1000010];
int read()//有负数，快读不要忘记符号的问题
{
	int s=0,p=1;
	char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			p=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		s=(s<<1)+(s<<3)+c-'0';
		c=getchar();
	}
	return s*p;
}
int main()
{
	char c;
	T=read();
	f[0]=-INF;//因为有负数嘛，所以一开始前缀和的最大值应该是一个极小数
	while(T--)
	{
		c=getchar();
		while(c!='I'&&c!='D'&&c!='L'&&c!='R'&&c!='Q')
			c=getchar();//getchar()比较快（优化后还有更快的），写c=='\n'||c=='\r'||c==' '，关系也不大
		if(c=='I')
		{
			b[++t].s=read();
			b[t].f=p;
			b[b[p].t].f=t;
			b[t].t=b[p].t;
			b[p].t=t;
			s[t]=s[p]+b[t].s;//插入节点
			f[t]=max(f[p],s[t]);//更新当前的前缀和最大值
			p=t;//更新光标位置
			ord[++n]=p;//加入有价值的数列，并hash一下编号
		}
		if(c=='D')
		{
			b[b[p].t].f=b[p].f;
			b[b[p].f].t=b[p].t;//删除节点
			p=b[p].f;
			n--;
		}
		if(c=='L')
		{
			p=b[p].f;
			n--;
		}
		if(c=='R')
		{
			s[b[p].t]=s[p]+b[b[p].t].s;
			f[b[p].t]=max(f[p],s[b[p].t]);
			p=b[p].t;
			ord[++n]=p;
		}
		if(c=='Q')
			printf("%d\n",f[ord[read()]]);//这里可以好好理解一下
	}//其实这里的五个操作可以合并起来写，放在函数里，然后可以调用
     //比如说在'I'的操作里，可以看成是插入一个节点，然后在右移光标一位 这两步
     //比较方便（其实也没方便多少）
	return 0;
}
```

最后，再支持一下Luogu的

### 在线IDE！

极大解决Linux系统和Windows系统造成的差异问题，那些~~恶心~~优秀的字符类模拟题就再也不用方了

---

## 作者：tobie (赞：5)

### [原题传送门](https://www.luogu.com.cn/problem/P2201)

我们首先需要读题。

>Q k 设光标之前的数列是{a1，a2，……，an}，输出第k位及之前最大的前缀和，_**保证k≤n**_。

这个保证 $k\le n$ 说明了什么？

说明说光标后面的所有数字对于当前的Q操作（询问）是没有任何影响的。

直接不管吗？肯定不是。毕竟光标是会移动的，如果直接舍弃掉后面的数据那么程序会出问题。

所以我们可以用一个数据结构来维护一下后面的数字。

光标每一次可能左右移动，如下图所示
![](https://cdn.luogu.com.cn/upload/image_hosting/neopbpev.png)

看到了吗？每一次移动都只会对**原光标右边所有元素**的最左边，

想到了什么？栈。

没错，光标右边的所有数字我们都可以用一个栈维护。

同理，光标左边的所有数字也可以用一个栈维护，如下图所示

![](https://cdn.luogu.com.cn/upload/image_hosting/lmvkirgc.png)

I和D操作（插入和删除）的实现请大家自行思考。

那么现在我们想办法维护一下左边的栈，回答操作Q（询问）。

前缀和是比较好求的（不要告诉我您连前缀和都不会，那请您跳过此题。），即 `sum[i]=sum[i-1]+x` 。

那么，找出第k位及之前最大的前缀和也很好维护， `qwq[i]=max(sum[i],qwq[i-1)` 。

没错，只需要两个栈，这道题的每个操作就可以在常数时间复杂度内完成。

完整代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=1000009;
int stack1[N][3],top1;//stack1代表的是上图中紫色的栈。
//stack[i][0]存储的是这个栈第i位的数字是多少。
//stack[i][1]存储的是前i个数字的前缀和。
//stack[i][2]存储的是 第i位及之前最大的前缀和。
//至于为什么要用数组，因为求出stack[i]和stack[i-1]有很大的联系，用数组更好调用。
//top表示栈顶。
int stack2[N],top2;//stack2同理，代表的是上图中绿色的栈。
char ch[3];
int x;
int n;
void ins(int qwq)//由于stack1要维护的东西较多，所以我单独写了一个函数来操作。
{
	top1++;
	if(top1==1)
	{
		stack1[top1][0]=stack1[top1][1]=stack1[top1][2]=qwq;
	}
	else
	{
		stack1[top1][0]=qwq;
		stack1[top1][1]=qwq+stack1[top1-1][1];
		stack1[top1][2]=max(stack1[top1][1],stack1[top1-1][2]);
	}
}
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		scanf("%s",ch);
		if(ch[0]=='I')
		{
			scanf("%d",&x);
			ins(x);//将x插入stack1，并做好维护工作。
		}
		if(ch[0]=='D') top1--;//stack1直接删除栈顶元素。
		if(ch[0]=='L')//将stack1的栈顶元素压入stack2中并删除。
		{
			int p=stack1[top1][0];
			top1--;
			stack2[++top2]=p;
		}
		if(ch[0]=='R')//将stack2的栈顶元素压入stack1中并删除。
		{
			int p=stack2[top2];
			top2--;
			ins(p);
		}
		if(ch[0]=='Q')//处理询问
		{
			scanf("%d",&x);
			printf("%d\n",stack1[x][2]);
		}
		/*
		for(int i=1;i<=top1;i++)
		printf("%d %d %d\n",stack1[i][0],stack1[i][1],stack1[i][2]);
		for(int i=1;i<=top2;i++)
		printf("%d\n",stack2[i]);
        这是调试代码，不用管它
		*/
	}
	return 0;
}
```

---

## 作者：cyhyyds (赞：2)

### 思路：
很明显，题目需要我们给出一个数据结构进行维护。

发现，对于光标移动，仅仅会影响到光标左右的元素。

采用**对顶栈**。

什么是对顶栈呢？说通俗一些，就是两个栈的栈顶相邻的一个栈。

我们设第一个栈存储光标前的数，第二个栈存储光标后的数。

接下来对于 $5$ 个操作进行分类讨论：

操作 $1$：将 $k$ 插入第一个栈，记录前缀和，从而记录最大前缀和。

操作 $2$：将第一个栈顶退栈即可。

操作 $3$：将第一个栈的栈顶插入第二个栈中即可。

操作 $4$：同理，将第二个栈的栈顶执行操作 $1$。

操作 $5$：由于操作 $1$ 有记录最大前缀和，所以直接获得答案。

**注意：** 关于对于栈元素进行修改时，我们需要判断栈是否为空，否则会出现 $RE$ 的情况。

### 代码：
```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;

const int N = 1500007;
const int inf = 0x3f3f3f3f;

int st1[N], st2[N], top1 = 0, top2 = 0, n;

int pre[N], mxpre[N];

inline void add (int k) {
	st1[++ top1] = k;
	pre[top1] = pre[top1 - 1] + k;
	//记录前缀和。 
	mxpre[top1] = max (pre[top1], mxpre[top1 - 1]);
	//当前的最大前缀和为：max（当前前缀和，上一个元素的最大前缀和）。 
}

inline void del () {
	if (!top1) {
		//为空退出。
		return ;
	} 
	
	else {
		top1 --;
		//退栈。 
	}
}

inline void move_L () {
	if (!top1) {
		//为空退出。 
		return ;
	}
	
	else {
		st2[++ top2] = st1[top1];
		
		top1 --;
	}
}

inline void move_R () {
	if (!top2) {
		//为空退出。 
		return ;
	}
	
	else {
		add (st2[top2]);
		
		top2 --;
	}
}

inline int query_mx (int k) {
	return mxpre[k];
	//直接获得答案。 
}

int main() {
	cin >> n;
	
	mxpre[0] = -inf;
	
	for (int i = 1, k; i <= n; i ++) {
		char c;
		
		cin >> c;
		
		if (c == 'I') {
			cin >> k;
			
			add (k);
		}
		
		else if (c == 'L') {
			move_L (); 
		}
		
		else if (c == 'R') {
			move_R ();
		}
		
		else if (c == 'D') {
			del ();
		}
		
		else if (c == 'Q') {
			cin >> k;
			
			cout << query_mx (k) << endl;
		}
	}
	
	return 0;
} 
```


---

## 作者：Imy_bisLy (赞：2)

###  又学到了一个新芝士:对顶栈
大体思路和别人一样~~虽然我刚学会对顶栈~~

这个代码和其他人不一样的之处在于是手写的stl栈

结构体栈：
```
struct strctt{
	int head=0;
	int st[N];
	void Push(int x){ st[++head]=x;	}
	void Pop(){  --head;  }
	int top(){ return st[head];	}
	bool empty(){ return head<=0;}
	int size(){return head;	}
}s1;
```

样例的具体实现过程：
1. 数字2进栈
2. 数字-1进栈
3. 数字1进栈
4. 到第3个数为止前缀和最大为2
5. 光标左移一格，位于1和-1之间
6. 删去-1
7. 光标右移![st](https://cdn.luogu.com.cn/upload/image_hosting/py0i6tjh.png)
8. 求前两个数最大的前缀和


栈内的变化如表所示
### The Code

```
#include <iostream>
#include <cstdio>
#include <cmath> 
#define ll long long

//------------------------------------------------------
using namespace std;
const int N = 1000010;
//------------------------------------------------------
int n;
struct strctt{
	int head=0;
	int st[N];
	void Push(int x){ st[++head]=x;	}
	void Pop(){  --head;  }
	int top(){ return st[head];	}
}s1,s2;
int sum[N],ans[N];
//------------------------------------------------------
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    scanf("%d",&n);char ch;int x;
    for(int i= 0 ;i <=n ;i++ ) ans[i]=-2147483647; 
	for(int i = 1 ;i <= n;i++){
		cin>>ch;
		if(ch=='I'){
			scanf("%d",&x);
			s1.Push(x);
			sum[s1.head]=sum[s1.head-1]+x;
			ans[s1.head]=max(ans[s1.head-1],sum[s1.head]);
		}
		if(ch=='D'){
			s1.Pop();
		}
		if(ch=='L'){
			s2.Push(s1.top());
			s1.Pop();
		}
		if(ch=='R'){
			s1.Push(s2.top());
			sum[s1.head]=sum[s1.head-1]+s2.top();
			ans[s1.head]=max(ans[s1.head-1],sum[s1.head]);
			s2.Pop();
		}
		if(ch=='Q'){
			cin>>x;
			printf("%d\n",ans[x]);
		}
	}    
//	fclose(stdin),fclose(stdout);
	return 0;
}



---

## 作者：年华天地 (赞：2)

这种移动光标的题，一般都是栈或者队列来维护，比如这道题，我们可以维护两个栈，一个栈维护光标左边的数，一个栈维护光标右边的数，对于维护左边的栈我们记录一个前缀和就可以轻易的算出左边前k个数的和并维护出最大值。


代码
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
int n,a[6000005],now;
int lst[6000005],rst[6000005],lt,rt,lf[6000005],rf[6000005],ans[6000005];
signed main()
{
    scanf("%lld",&n);
    memset(ans,-120,sizeof(ans));
    for(int i=1;i<=n;i++)
    {
        char o;
        int x;
        scanf(" %c",&o);
        if(o=='I')
        {
            scanf("%lld",&x);
            lst[++lt]=x;
            lf[lt]=lf[lt-1]+x;
            ans[lt]=max(ans[lt-1],lf[lt]);
        }
        if(o=='D')
        {
            if(lt==0) continue;
            lf[lt--]=0;
        }
        if(o=='L')
        {
            if(lt==0) continue;
            rst[++rt]=lst[lt];
            rf[rt]=rf[rt-1]+rst[rt];
            lf[lt--]=0;
        }
        if(o=='R')
        {
            if(rt==0) continue;
            lst[++lt]=rst[rt];
            lf[lt]=lf[lt-1]+lst[lt];
            rf[rt--]=0;
            ans[lt]=max(ans[lt-1],lf[lt]);
        }
        if(o=='Q')
        {
            scanf("%lld",&x);
            if(x<=lt)
                printf("%lld\n",ans[x]);
    }
}
```



---

## 作者：Object_ (赞：2)

**注意点：**

- 最小前缀和仅需要维护光标前的数值，因此sum[i](前缀和)及f[i](最小前缀和)可直接依托top_1(代表光标前数值的栈)存在.

------------
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int MAXN=2e6,INF=2e9;
int stck_1[MAXN],top_1=0;//光标前
int f[MAXN];//最大前缀和
int id=0;
int sum[MAXN];//前缀和
int stck_2[MAXN],top_2=0;//光标后
int main(){
    memset(f,0xcf,sizeof(f));
    int q;
    scanf("%d",&q);
    for(int i=1;i<=q;i++){
        char opt;
        cin>>opt;
        if(opt=='I'){//光标前插入数值
            int x;
            scanf("%d",&x);
            stck_1[++top_1]=x;
            sum[top_1]=sum[top_1-1]+x;
            f[top_1]=max(f[top_1-1],sum[top_1]);
        }else if(opt=='Q'){//查询最大前缀和
            int x;
            scanf("%d",&x);
            printf("%d\n",f[x]);
        }else if(opt=='L'){//光标左移
            if(!top_1)continue;
            stck_2[++top_2]=stck_1[top_1--];
        }else if(opt=='R'){//光标右移
            if(!top_2)continue;
            stck_1[++top_1]=stck_2[top_2--];
            sum[top_1]=sum[top_1-1]+stck_1[top_1];
            f[top_1]=max(f[top_1-1],sum[top_1]);
        }else if(opt=='D'){//删除光标前一个元素
            if(!top_1)continue;
            top_1--;
        }
    }
    return 0;
}
```


---

## 作者：Punny (赞：2)

# **核心思路建立2个栈(对顶栈）**
先看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000001],b[1000001],sora,sorb,sum[1000001],f[1000001],n;
int p;
char c;
int main()
{
	scanf("%d",&n);
	f[0]=-10000000;
	while(n--)
	{
		cin>>c;
		if(c=='I')
		{
			scanf("%d",&p);
			sora++;
			a[sora]=p;
			sum[sora]=sum[sora-1]+a[sora];
			f[sora]=max(f[sora-1],sum[sora]);
		}
		if(c=='D')
		{
			a[sora]=0;
			sora--;
		}
		if(c=='L')
		{
			sorb++;
			b[sorb]=a[sora];
			a[sora]=0;
			sora--;
		}
		if(c=='R')
		{
			sora++;
			a[sora]=b[sorb];
			b[sorb]=0;
			sorb--;
			sum[sora]=sum[sora-1]+a[sora];
			f[sora]=max(f[sora-1],sum[sora]);
		}
		if(c=='Q')
		{
			scanf("%d",&p);
			printf("%d\n",f[p]);
		}
	}
	return 0;
}
```


------------

栈a储存序列开头到当前光标位置位置的这一段子序列，栈b储存从当前光标位置到序列结尾的这一段子序列，二者都以光标所在的那一端为栈顶。这两个栈合起来就是一个整个序列。
sora,sorb为栈a，b的光标位置(也可以说是栈a，b里的数的个数)
f数组用来维护a的前缀和的最大值，sum数组为a数组的前缀和，设栈a的栈顶位置的下标为p。

------------

对于I X 操作：

把x插入栈a

更新 sum[p]=sum[p-1]+a[p];

更新 f[p]=max(f[p-1],sum[p]);

------------

对于D操作：
把a的栈顶出栈。

------------

对于L操作：

弹出a的栈顶，插入b中

------------

对于R操作：

弹出b的栈顶，插入a中

更新sum[p]=sum[p-1]+a[p];

更新f[p]=max(f[p-1],sum[p]);

------------

对于Q k 询问：

直接输出f[k]。

------------

通过这两个对顶栈我们在O(1)的时间内实现了每种操作和询问。


---

## 作者：Stfb (赞：1)

不建议链表，打成$zz$

------------
## 思路

------------

### 分析算法


------------


从最核心的查询操作入手，利用只查光标前这个性质，维护光标前的最大前缀和。

考虑以光标为分界点，那么对于光标移动操作，我们可以利用栈的性质来解题。

开两个栈，那么L,R操作只是两个栈元素的转移。


------------

### 维护最大前缀和


------------


我们设$ans[i]$表示到i这个点的最大前缀和。

由于$L,D$操作不会影响$ans[i-1]$的值，我们删去$i$点或者左移光标并没有影响答案。

因此我们只用关心$R$操作，对于$R$操作，我们只用取一下$MAX$就好了。


------------
## 代码
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int N=1e6+5;
int n,x,ans[N],ht,tt,hs[N],ts[N],sum[N];
char ch;
int max(int a,int b){return a>b?a:b;}
int main()
{
	memset(ans,-120,sizeof(ans));
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		ch=getchar();
		while((ch!='I')&&(ch!='Q')&&(ch!='L')&&(ch!='R')&&(ch!='D'))
			ch=getchar();
		if(ch=='I')
		{
			scanf("%d",&x);
			hs[++ht]=x;
			sum[ht]=sum[ht-1]+x;
			ans[ht]=max(ans[ht-1],sum[ht]);
		}
		else if(ch=='L')ts[++tt]=hs[ht],--ht;
		else if(ch=='D')--ht;
		else if(ch=='R')
		{
			hs[++ht]=ts[tt--];
			sum[ht]=sum[ht-1]+hs[ht];
			ans[ht]=max(ans[ht-1],sum[ht]);
		}
		else 
		{
			scanf("%d",&x);
			printf("%d\n",ans[x]);
		}
	}
	return 0;
}
```

---

## 作者：wuzhoupei (赞：1)

这道题我写的是链表；

至少这样写还好想；

但是有一点需要注意：每次操作完都要去更新当前点；

所以插入就是断开点前点与前一个点的连接，加入新点；

删除就是把当前点的前后两个点连接；

左移右移显然直接移动；

查询最好是用数组记录，这样不会TLE；

所以就直接写个链表模拟就好了；

我是每次都更新，这样不会错，而且保险；


```cpp
#include "iostream"
#include "stdio.h"
#include "algorithm"
#define II int
#define R register
#define U NULL
#define I 1000010
using namespace std;


struct node {
    II o,sum,wei;
    node *up,*next;
};
node * begin(R II x)
{
    node * ret=new node;
    ret->up=U;
    ret->next=U;
    ret->o=x;
    ret->sum=0;
    return ret;
}
node *root=begin(0),*now,*en;

II ans[I];

void ppp(node *pi) 
{
    pi->wei=pi->up->wei+1;
    pi->sum=pi->up->sum+pi->o;
    ans[pi->wei]=max(ans[pi->wei-1],pi->sum);
}

void add()
{
    R II x;
    scanf("%d",&x);
    R node *pi=begin(x);
    R node *qian=now->up;
    now->up=pi;
    pi->next=now;
    pi->up=qian;
    qian->next=pi;
    ppp(pi);
    ppp(now);
}


void del()
{
    R node *de=now->up;
    R node *qian=de->up;
    qian->next=now;
    now->up=qian;
    ppp(now);
}


void just() 
{ 
    now=now->up;
    ppp(now);
}

void back() 
{ 
    now=now->next;
    ppp(now);
}


void query()
{
    R II k;
    scanf("%d",&k);
    printf("%d\n",ans[k]);
}


int main()
{
//    freopen("1.in","r",stdin);
    
    R II n; R char a;
    scanf("%d",&n);
    now=begin(0);
    now->up=root; now->next=root;
    root->up=now;
    root->next=now;
    ans[0]=-1e9;
    
    while (n--) {
        cin>>a;
        if(a=='I') add();
        if(a=='D') del();
        if(a=='L') just();
        if(a=='R') back();
        if(a=='Q') query();
    }
    exit(0);
}
```

---


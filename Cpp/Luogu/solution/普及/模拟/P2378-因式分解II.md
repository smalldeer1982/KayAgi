# 因式分解II

## 题目描述

小玉上了初中，开始学因式分解。可是她怎么都解不出来。所以她求你帮忙。

她给你看了她的作业，就是因式分解。由于刚开始学，就降低了难度。

我们假设作业里面的代数只有一个x。最高指数是2，且最高指数的系数是1。当x前的系数是1时，1省去……（反正作业题目符合我们的日常写法）

我们帮她解决下这个“简单”的问题吧！虽然听起来挺容易，但是编程需要考虑很多情况呢！

保证作业答案的数字都是整数。


// 这跟神器有什么关系么？神说，帮助他人，积累善行，神器自然出现。哈哈哈哈好牵强的解释~

//为了帮助在5月月赛ac这道题目，kkksc03偷偷地进行以下的温馨提示：

//数据可能会比较刁钻，请考虑到各种情况，包括只有输入一项的情况、中间过程会不会超maxlongint的情况等。

//lzn：喂！你这是透题行为，是要上法庭的！

//absi2011:样例输出里的"//"及以后字符只是注解,并不要你输出

/\*
absi2011:输入规范好不和谐啊...

我只是来补充一下...

如果x或者常数项的系数是0 整个省略掉

哦,x的系数是-1的话 也会把1省去...

保证输入的那玩意儿可以分解....而且分解出来都是整数...

\*/

// 原作: 2022.7.24 没想到初中时候贡的题已经~~坑害了~~这么多人ac了.  现在已经大二，时过境迁，已经完全不会了哈哈哈

## 说明/提示

x次数不高于2次，项数不高于3项，降幂排列。


## 样例 #1

### 输入

```
x^2-4```

### 输出

```
(x+2)(x-2)
//而不能写成(x-2)(x+2)或者(x+2)(x+-2)```

## 样例 #2

### 输入

```
x^2+5x+4```

### 输出

```
(x+4)(x+1)
//不能写成(x+1)(x+4)```

## 样例 #3

### 输入

```
x^2-2x+1```

### 输出

```
(x-1)^2```

## 样例 #4

### 输入

```
x^2+x```

### 输出

```
(x+1)x
//反过来是不可以的。```

# 题解

## 作者：伟大的王夫子 (赞：25)

先安利[我的博客](https://www.luogu.com.cn/blog/I-AK-IOI/)

这题比较简单（~~虽然调试了这么久~~），先读入多项式$ax^2+bx+c$，再求出$a,b, c$的值，再套求根公式
$x=\dfrac{-b \pm \sqrt{b^2-4ac}}{2a}$,即可因式分解。代码如下


~~吐槽一下。代码有必要那么长吗？~~

~~我的代码巨短~~

```cpp
#include <bits/stdc++.h>
using namespace std;
string a, c;
double b[10], x1, x2;
void work(double x) {
	if (x == 0) cout << "x";
	else {
		cout << "(x";
		if (x > 0) cout << "+" << x << ")";
		else cout << "-" << -x << ")";
	}
}
int main() {
	cin >> a;
	b[1] = 1;//x^2的系数为1 
	a.erase(0, 3);
	int pos = a.find('x');
	if (pos == -1) b[2] = 0;
	else {
		c = a.substr(0, pos + 1);
		c.erase(--c.end());//忽略x 
		if (c == "+") b[2] = 1;
		else if (c == "-") b[2] = -1;//特判正负1 
		else b[2] = atof(c.c_str());//求b的系数 
	}
	if (pos == -1) b[3] = atof(a.c_str());
	else if (pos == a.size()) b[3] = 0;
	else c = a.substr(pos + 1), b[3] = atof(c.c_str());//求c的系数 
	//cout << b[1] << ' ' << b[2] << ' ' << b[3];
	x2 = (-b[2] + sqrt(b[2] * b[2] - 4 * b[1] * b[3])) / b[1] / 2;
	x1 = (-b[2] - sqrt(b[2] * b[2] - 4 * b[1] * b[3])) / b[1] / 2;//求根 
	//cout << x1 << ' ' << x2;
	if (x1 == x2) work(-x1), cout << "^2";
	else work(-x1), work(-x2);
}
```
就完事了呀

求大家点个赞再走呗！


---

## 作者：jacky567 (赞：8)

这道题的方法很多，可以带求根公式（$\frac{-a±\sqrt{a^2-4b}}{2}$）、可以代数变形（求出$x_1$和$x_2$的关系）……当然，这都是数学的方法（去看其他题解）。

有信息的方法吗？当然有！我的方法就是暴力搜索。首先，分七种情况：
1. $x^2$;
2. $x^2+ax$;
3. $x^2+b$;
4. $x^2+ax+b(a>0,b>0)$;
5. $x^2+ax+b(a<0,b>0)$;
6. $x^2+ax+b(a>0,b<0)$;
7. $x^2+ax+b(a<0,b<0)$。

这七种情况分别处理。

程序代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
	int a=0/*一次项系数*/,b=0/*常数项系数*/,fh1=0/*一次项系数的符号*/,fh2=0/*常数项系数的符号*/,temp=1;
	char s[100];
	cin>>s;
	if(strlen(s)==3){cout<<s;return 0;}//情况① 
	if(s[strlen(s)-1]=='x') {sscanf(s+4,"%d",&a);if(s[3]=='+') cout<<"(x+"<<a<<")x";else cout<<"x"<<"(x-"<<a<<")";return 0;}//情况② 
	for(int i=3;i<strlen(s);i++){
		if(temp==1){
			if(s[i]=='+'){fh1=1;continue;}//是加号，fh1值为1 
			if(s[i]=='-'){fh1=-1;continue;}//是减号，fh1值为-1
			if(s[i]>='0'&&s[i]<='9') a=a*10+s[i];//是数字，a值增加 
			else temp++;//一次项系数完成，进行常数项系数 
		}
		if(temp==2){
			if(s[i]=='+'){fh2=1;continue;}//是加号，fh2值为1 
			if(s[i]=='-'){fh2=-1;continue;}//是减号，fh2值为-1
			if(s[i]>='0'&&s[i]<='9') b=b*10+s[i];//是数字，b值增加 
		}
	}
	if(fh2==0){cout<<"(x+"<<sqrt(-a)<<")(x-"<<sqrt(-a)<<")";return 0;}//情况③ 
	if(a>0&&b>0){//情况④ 
	  for(int i=0;i<=a;i++/*暴力枚举所有可能*/){
			int j=a-i;
			if(i*j==b){if(i==j) cout<<"(x+"<<i<<")^2";else cout<<"(x+"<<max(i,j)<<")(x+"<<min(i,j)<<")";return 0;}//输出 
		}
	}
	if(a<0&&b>0){//情况⑤ 
	  for(int i=0;i>=a;i--/*暴力枚举所有可能*/){
			int j=a-i;
			if(i*j==b){if(i==j) cout<<"(x"<<i<<")^2";else cout<<"(x"<<max(i,j)<<")(x"<<min(i,j)<<")";return 0;}//输出 
		}
	}
	if(a>0&&b<0){//情况⑥ 
	  for(int i=0;;i--/*暴力枚举所有可能*/){
			int j=a-i;
			if(i*j==b){cout<<"(x+"<<j<<")(x"<<i<<")";return 0;}//输出  
		}
	}
	if(a<0&&b<0){//情况⑦ 
	  for(int i=a;;i--/*暴力枚举所有可能*/){
			int j=a-i;
			if(i*j==b) {cout<<"(x+"<<j<<")(x"<<i<<")";return 0;}//输出  
		}
	}
}
```

---

## 作者：TsReaper (赞：6)

简单数学+模拟题，很多需要注意的方面题面已经写得很多了。

1、如果题目没有二次项，那么直接输出原式。

2、如果有二次项，那么算出各项系数a,b,c，用x = (-b±sqrt(b^2-4ac))/2a算出解即可。注意输出的时候需要输出相反数。


---

## 作者：simonG (赞：5)

### 前言
如果还不知道因式分解是啥，左转[百度百科](https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin)。
### 详解
>* 分析题目：只有一个未知数；最高指数是2；且最高指数的系数是1；项数不高于3项；而且分解出来都是整数。则原式的格式必为:
$$x^2+bx+c$$
>* （因式定理枚举会超时）
#### 若$b\not = 0,c\not = 0$ 
>* 由上可得，这题可以用十字相乘法，即用待定系数表示:
$$x^2+bx+c=(x+d)(x+e)$$
>* 所以，
$$x^2+bx+c=x^2+(d+e)x+d\times e$$
>* 根据待定系数法则，得知$b=d+e,c=d\times e$。
>* 即提取常数c的因式，在枚举即可。
>* 总会找到一个符合条件的$d,e$，输出$x^2+bx+c=(x+d)(x+e)$
#### 若$b=0$
>* 则原式为：
$$x^2+c=(x+d)(x+e)$$
>* 所以，
$$x^2+0x+c=x^2+(d+e)x+d\times e$$
>* $d+e=0$，则$d=-e$，所以$c=-d^2=-e^2$。
>* 即原式为$x^2-d^2=(x+d)(x-d)=(x+\sqrt{c})(x-\sqrt{c})$。
#### 若$c=0$
>* 则原式可直接提取x一个因式。
>* 那么原式为：
$$x^2+bx=x(x+b)$$
>* 直接输出即可。

#### 若$b,c=0$
>* 那么原式仅有一项，不可分解。

### 代码
自行实现即可。

### 后记
这对于初一的蒟蒻，非常困难。

---

## 作者：Eason_AC (赞：3)

## Content
输入一个多项式 $x^2+ax+b$（**不保证 $a,b\neq0$**），请对这个多项式进行因式分解（形式为 $(x-x_1)(x-x_2)$，其中 $x_1>x_2$）。

**数据范围：$a,b<2^{31}$。**
## Solution
这道题目看上去很简单，做起来却有很多的细节要注意。

首先，我们可以得到一个大致的思路：得到 $a,b$ 之后利用求根公式求出 $x_1,x_2$：

$$x_{1,2}=\dfrac{-a\pm\sqrt{a^2-4b}}{2}$$

当然，这是按照题目进行变化后得到的式子，我想你们应该都熟悉这个：$\dfrac{-b\pm\sqrt{b^2-4ac}}{2a}$，但因为保证了二次项系数是 $1$，所以没什么必要。

那么完了以后，我们的因式分解的结果就是 $(x-x_1)(x-x_2)$，当然，首先如果 $x_1<x_2$，就得要交换。输出的时候分以下三种情况讨论：

- $x<0$，此时因为前面已经带了负号，所以直接用 ``printf("(x%d)", x)`` 就好。
- $x=0$，此时直接输出 ``x``。
- $x>0$，此时用 ``printf("(x+%d)", x)`` 输出。

总体来讲就是以上这些操作，还需注意一下将 $a,b$ 从字符串中提取出来的问题，具体请读者看代码自行理解。
## Code
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <iostream>
using namespace std;

string s;
double a, b, flagx, f, now;

void print(int xx) {
	if(xx < 0)	printf("(x%d)", xx);
	else if(!xx)	printf("x");
	else	printf("(x+%d)", xx);
}

int main() {
	cin >> s;
	int n = s.size();
	f = 1;
	for(int i = 3; i < n; ++i)
		if(s[i] == 'x')	flagx = 1;
	if(!flagx) {
		now = 0;
		for(int i = 3; i < n; ++i) {
			if(s[i] == '-')	f *= -1;
			else if(isdigit(s[i]))	now = now * 10 + s[i] - '0';
		}
		b = f * now;
	} else {
		now = 0;
		for(int i = 3; i < n; ++i) {
			if(s[i] == 'x' && i == 3) {
				a = 1;
				now = 0, f = 1;
			} else if(s[i] == 'x' && i > 3) {
				a = now * f;
				now = 0; f = 1;
			} else if(s[i] == '-')	f *= -1;
			else if(isdigit(s[i]))	now = now * 10 + s[i] - '0';
//			printf("now=%d\n\n", now);
		}
		b = f * now;
	}
	double x1 = -(-a + sqrt(a * a - 4 * b)) / 2, x2 = -(-a - sqrt(a * a - 4 * b)) / 2;
//	printf("%d %d %d %d\n", a, b, x1, x2);
	if(x1 == x2) {
		print(x1);
		printf("^2");
	} else {
		if(x1 < x2)	swap(x1, x2);
		print(x1), print(x2);
	}
	return 0;
}
```

---

## 作者：微雨燕双飞 (赞：3)

终于过了。。我建议本题难度可以改为提高+省选-的蓝题了（细节实在太多了），本人蒟蒻，提交4次才AC（70,80,90,100），再次发布题解

留念。好的，我们来看一下思路。本题真正的难点不在因式分解（直接套求根公式就好了），而是在繁琐的输入和输出，而字符串作为纯模拟题中最复杂的一部分，对编程的基本功要求较高。

好，我们来看一下代码：

```cpp
#include<bits/stdc++.h>  //万能头文件
using namespace std;
string s;
long long n1=1,n2=1,n3=0,x1=0,x2=0,cnt=0,cnt2=0,findx,num[100],num2[100]; //一定要开到longlong，不然#9过不去
int main()
{
  cin>>s;
  if(s=="x^2") { 
      cout<<"x^2"; return 0;
  }  //特判第一组数据（不是说好可以分解的吗）
  int ii=s.length()-1; //计算常数项，这里我采用倒序的方法找到整段数字，存入n3
  while(s[ii]>='0'&&s[ii]<='9')
  {
    num[++cnt]=s[ii]-'0'; ii--;
  } 
  for(int i=cnt; i>=1; i--) n3=n3*10+num[i];
  if(s[ii]=='-') n3=-n3; //前有负号要变号
  for(int i=0; i<s.length(); i++)  //找到一次项系数，我采用类似于夹逼的方法，先从左往右筛一遍找到第二个x，再反过来筛一遍（题中说道一定有二次项）
    if(s[i]=='x') 
    {
      cnt2++;
      if(cnt2==2) findx=i;
    }
  ii=findx-1; 
  if(s[ii]=='-') n2=-1;
    else if(s[ii]=='+') n2=1;
    else
    {
      cnt2=0;
      while(s[ii]>='0'&&s[ii]<='9')
      {
        num2[++cnt2]=s[ii]-'0'; ii--;
      }
      for(int i=cnt2; i>=1; i--) n2=n2*10+num2[i];
      if(s[ii]=='-') n2=-n2;
    }  //求出一次项系数，此过程较为繁琐
  long long delta=n2*n2-4*n1*n3;  //求根公式因式分解
  x1=(-n2+sqrt(delta))/(2*n1); //x1，x2必为整数，所以直接计算即可
  x2=(-n2-sqrt(delta))/(2*n1);
  x1=-x1,x2=-x2; 
  if(x1>x2)  //输出部分（大的在前，小的在后）
  {
    if(x1<0) cout<<"(x-"<<abs(x1)<<")"; //特判负数情况（先输出“-”，再取绝对值）
      else 
        if(x1!=0) cout<<"(x+"<<abs(x1)<<")"; //特判加数为0的情况（不输出括号）
          else cout<<"x";
    if(x2<0) cout<<"(x-"<<abs(x2)<<")"; //同上
      else 
        if(x2!=0) cout<<"(x+"<<abs(x2)<<")";
          else cout<<"x";
  }
  else
  {
      if(x1==x2) //当两项加数相等时（x-1）（x-1）要写成（x-1）^2
      {
        cout<<"(x"; 
        if(x1<0) cout<<"-"<<abs(x1)<<")^2"; //继续特判，同上
        else cout<<"+"<<abs(x1)<<")^2";
      }
      else
      {
      if(x2<0) cout<<"(x-"<<abs(x2)<<")";
      else 
        if(x2!=0) cout<<"(x+"<<abs(x2)<<")";
          else cout<<"x";
      if(x1<0) cout<<"(x-"<<abs(x1)<<")";
      else 
        if(x1!=0) cout<<"(x+"<<abs(x1)<<")";
          else cout<<"x";
    }
  }
  return 0;
}  //完美收场
个人感觉本题就是多项式输出的增强版，非常考验代码能力，建议管理员改一下题目难度（至少普及+/提高吧）。祝大家早日AC！
```

---

## 作者：rfsfreffr (赞：2)

细节十分丰富的一道题，实际难度应该不止黄题，打了快半个小时才过。

我们先来分析一下题意，大概的意思是:

给你类似与$x^2+ax+b$的柿子，让你对他进行因式分解，将他写成$(x+a_1)(x+b_1)$的形式。保证计算过程中出现的数都是**整数**。

我一开始想的是十字相乘法，但发现有负数时较难处理。

然后注意到**保证计算过程中出现的数都是整数**

我想:

如果要求$a_1$与$b_1$,其实可以直接将柿子看做一个方程，直接利用公式求解。由于计算工程中出现的数都是**整数**,就不需要注意什么精度之类的问题了，直接用整形存储。

让后判定输出即可。

我的代码分为三部分

# 1.从原字符串中提取a,b

```cpp

void tiqu() {
	t=1;//判断正负
	for(int i=0; i<s.length(); i++) {
		if(s[i-1]!='^'&&s[i]!='^') {
			if(s[i]=='-') {//若有'-'
				t=-1;//将t修改为-1
			}
			if(s[i]>='0'&&s[i]<='9') {//若读入的是一个数字，则将对k进行更新
				k=k*10+(s[i]-'0');
			}
			if(s[i]=='x'&&!(s[i-1]>='0'&&s[i-1]<='9')) {//若读到一个x，说明系数读到头了，在此x前无数字，则将系数修改为为1
				if(f==0) a=1*t,f++,k=0,t=1;//别忘了重置k与t
				else if(f==1) b=1*t,f++,k=0,t=1;
			} else if(s[i]=='x') {//记录系数
				if(f==0) a=k*t,f++,k=0,t=1;
				else if(f==1) b=k*t,f++,k=0,t=1;
			}
		}
	}
	c=k*t;//加上才能AC
}

```
# 2.计算根

```cpp
void calc() {//直接使用公式即可
	x1=(-b+(sqrt(b*b-4*a*c)))/(2*a);
	x2=(-b-(sqrt(b*b-4*a*c)))/(2*a);
}
```

# 3.输出

这题的输出极为复杂细节十分之多，由于x1>x2,所以我先对x1进行判断,再一一分类输出。

但只要分请x1,x2的大小关系，以及a1,b1的大小关系。确定x1,x2谁前谁后，谁需要取相反数。

# 代码:
```cpp
void print() {
	if(x1==x2) {
		if(x1<0) printf("(x+%d)^2",-x1);
		if(x1>0) printf("(x-%d)^2",x1);
		if(x1==0) printf("x^2");
	} else if(x1>0) {
		if(x2<0) printf("(x+%d)(x-%d)",-x2,x1);
		if(x2>0&&abs(x1)>abs(x2)) printf("(x-%d)(x-%d)",x2,x1);
		if(x2>0&&abs(x1)<abs(x2)) printf("(x-%d)(x-%d)",x1,x2);
		if(x2==0) printf("x(x-%d)",x1);
	} else if(x1<0) {
		if(x2<0&&abs(x1)<abs(x2)) printf("(x+%d)(x+%d)",-x2,-x1);
		if(x2<0&&abs(x1)>abs(x2)) printf("(x+%d)(x+%d)",-x1,-x2);
		if(x2>0) printf("(x+%d)(x-%d)",x1);
		if(x2==0) printf("(x+%d)x",-x1);
	} else if(x1==0) {
		if(x2>0) printf("(x-%d)x",x2);
		if(x2<0) printf("(x+%d)x",-x2);
	}
}
 ```
 
 对于这种题目，一定要细心，不然错了就很麻烦。但若真错了，细心手动模拟造数据，一定还要有耐心，才能提交AC的代码。

---

## 作者：蒋钦杰jqj (赞：2)

这是一道非常非常简单的模拟题，只要学过初二的数学知识或网上搜求根公式即可

```cpp
var s,ss,ss1,ss2:ansistring;
k,i,a,b,c,x1,x2,y1,y2:longint;
begin
readln(s);    s:=s+' ';\\不加这个，第四种测试数据会爆
if (pos('^2',s)<>0) and ((pos('^2+',s)<>0) or (pos('^2-',s)<>0)) then
  begin
  if s[1]='-' then
    begin
    a:=-1;
    delete(s,1,3);
    end
  else begin a:=1; delete(s,1,3); end;
  if (pos('x',s)<>0) and (s[pos('x',s)+1]<>'^') then
    begin
    k:=pos('x',s)-1;
    ss:='';
    while (s[k]<>'-') and (s[k]<>'+') do
      begin
      ss:=s[k]+ss;
      dec(k);
      end;
    if ss='' then ss:='1';
    if s[k]='-' then
      begin
      val(ss,b);
      b:=-b;
      end
    else val(ss,b);
    end;
  if s[length(s)-1]<>'x' then//判断倒数第二个字符，因为最后一个是空格
    begin
    k:=length(s)-1;
    ss:='';
    while (s[k]<>'-') and (s[k]<>'+') do
      begin
      ss:=s[k]+ss;
      dec(k);
      end;
    if s[k]='-' then
      begin
      val(ss,c);
      c:=-c;
      end
    else val(ss,c);
    end;
  x1:=-(-b+trunc(sqrt(b*b-4*a*c))) div (2*a);
  x2:=-(-b-trunc(sqrt(b*b-4*a*c))) div (2*a);
  if x1=x2 then
    begin
    str(x1,ss1);
    if (ord(ss1[1])>48) and (ord(ss1[1])<=57) then
    ss1:='+'+ss1;
    writeln('(x',ss1,')^2');
    halt;
    end;
  if x1<x2 then
    begin
    k:=x1; x1:=x2; x2:=k;
    end;
  str(x1,ss1);
  str(x2,ss2);
  if x1>0 then
    ss1:='+'+ss1;
  if x2>0 then
    ss2:='+'+ss2;
  if x1=0 then
    begin
    writeln('x(x',ss2,')');
    halt;
    end
  else if x2=0 then
    begin
    writeln('(x',ss1,')x');
    halt;//加上后就不会有双输出
    end;
  writeln('(x',ss1,')(x',ss2,')');
  end
else writeln(s);
end.
```

---

## 作者：HohleFeuerwerke (赞：1)

[普及组模拟题](https://www.luogu.com.cn/problem/P2378)。

对于任意一个一元二次三项式，若要将其因式分解，有一种普适性的方法，叫做十字交叉法。如果对此不是很了解，可以阅读初一数学课本，因式分解一章。

十字交叉法的本质就是利用了 $(x+p)(x+q)=x^2+(p+q)+pq$ 这个恒等式。

对于这道题而言，由于不知道 $p,q$，一种很自然的想法就是进行分解，然而过于繁琐。

显然可以应用韦达定理。

$p,q$ 是方程 $x^2+ax+b=0$ 的两根。即可。

这时候我们只需要把 $p,q$ 解出来即可。

此时应用求根公式，对于 $a,b,c\in \mathbb{R}$，$ax^2+bx+c=0$，的两根为 $x_{1,2}=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$。

那么此时我们从这个字符串中剥离出 $a,b,c$，即可带入计算。具体看代码：

```cpp
#include<bits/stdc++.h>
#define HohleFeuerwerke using namespace std
#pragma GCC optimize(3,"Ofast","-funroll-loops","-fdelete-null-pointer-checks")
#pragma GCC target("ssse3","sse3","sse2","sse","avx2","avx")
#define int long long
HohleFeuerwerke;
inline int read(){
	int s=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) s=s*10+c-'0';
	return s*f;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);
	putchar('0'+x%10);
}
string str;
int t2=1,t1,t0;
inline void work(int a,int b,int c){
	if(b*b==4*a*c){
		int x1=-(-b)/(2*a);
		if(x1>0) printf("(x+%lld)^2\n",x1);
		if(x1==0) printf("x^2\n");
		if(x1<0) printf("(x-%lld)^2\n",-x1);
	}
	else{
		int x1=-(-b-sqrt(b*b-4*a*c))/(2*a);
		int x2=-(-b+sqrt(b*b-4*a*c))/(2*a);
		if(x1>0) printf("(x+%lld)",x1);
		else if(x1==0) printf("x");
		else printf("(x-%lld)",-x1);
		if(x2>0) printf("(x+%lld)\n",x2);
		else if(x2==0) printf("x\n");
		else printf("(x-%lld)\n",-x2);
	}
}
signed main()
{ 
	cin>>str;
	str=str.substr(3,str.size()-3);
	int pos=str.find('x');
	if(pos==-1){
		t1=0;t0=atof(str.c_str());
		work(t2,t1,t0);
		return 0;
	}
	else if(pos==1) t1=1;
	else{
		string tmp=str.substr(0,pos);
		t1=atof(tmp.c_str());
		str=str.substr(pos+1,str.size()-pos-1);
		t0=atof(str.c_str());
		work(t2,t1,t0);return 0;
	}
	work(t2,t1,t0);return 0;
}
```

---

## 作者：Soyilieber (赞：1)

## 详解

#### 简单的字符串模拟，其实我是p党转了c党，但还是觉得pascal字符串好，为了方便c党看懂，阐述一下一些函数。

1.  k:=pos(abc,str);
指返回abc在str的第k位开始，若为假，则返回0

2.  delete(str,m,n);
删除str从m到m+n-1位（或从第m位开始算n位） 

3.  val(str,a);
字符串转数字，譬如str='+5'（可带符号），则转换后a=5

4.  k:=copy(str,m,n);
复制str从m到m+n-1位（或从第m位开始算n位） 

## 正文

题目中式子一般式为：

$ax^2+bx+c(a,b,c\in Z)$

先字符串一堆处理，得到$a,b,c$，然后可以把这个式子看作一个值为0的式子，得到方程：

$ax^2+bx+c=0(a,b,c\in Z)$

方程解为$x=\frac{(-b±\sqrt{b^2-4ac})}{2a}\qquad$

然而别人用，我偏不用，
我只用其中$\Delta=b^2-4ac$来判根，方便输出。

因式分解的话要满足$x_1+x_2=b,x_1x_2=c$，所以$repeat(do……while)$循环得出$x_1$和$x_2$，然后输出咯。

#### 具体的在注释里，请客官们看看代码：

```pascal
var
	p,xa,xb,xc,delta,x,y,ans:longint;//xa xb xc代表a b c 
	s,a:string;
begin
        readln(s);
        if (pos('^',s)=0)or(s='x^2') then writeln(s)//如果没有二次项，则直接输出
        else begin//不然
                p:=pos('x^2',s);//找x^2这一子串
                if p=1 then//找到了且系数为1
                begin
                        xa:=1;//系数a为1
                end
                else begin
                        a:=copy(s,1,p-1);//系数不为1则
                        if a='-' then xa:=-1//系数-1
                        else val(a,xa);//系数为绝对值为1以外的数
                end;
                delete(s,1,p+2);//删掉二次项部分，注意保留后一项系数的符号
                p:=pos('x',s);//是否是一次项
                if p=0 then
                begin
                        val(s,xc);//是常数项，直接转
                end
                else begin//是一次项
                        if (s[1]='+')and(p=2) then xb:=1
                        else if (s[1]='-')and(p=2) then xb:=-1
                        else begin
                                a:=copy(s,1,p-1);//拷贝
                                val(a,xb);//转化
                                delete(s,1,p);
                                val(s,xc);//剩下的坑定是常数项啦
                        end;
                end;
                delta:=xb*xb-4*xa*xc;//delta是一元二次方程的根的判别式，如果为0，说明只有一个根
                if delta=0 then
                begin
                        ans:=-xb div 2 div xa;//-b/2/a
                        writeln('(x-',ans,')^2');
                end
                else begin//有多个根
                        x:=xb;
                        if (x*y<>xc) then repeat
                                dec(x);
                                inc(y);//此处循环，保证x+y=b且x*y=c，初中数学内容
                        until x*y=xc;
                        if x<y then
                        begin
                                p:=x;
                                x:=y;
                                y:=p;
                        end;//x要大于y
                        if x=0 then write('x')
                        else begin
                                if (x>0) then write('(x+',x,')')
                                else write('(x',x,')');
                        end;
                        if y=0 then write('x')
                        else begin
                                if (y>0) then write('(x+',y,')')
                                else write('(x',y,')');
                        end;//只要是正数，就输出“+”号
                end
        end;
end.
```

~~第一个点有坑，是$x^2$，要直接输出。~~

---

## 作者：fl_334 (赞：1)

###334的蠢码，话不多说

**模拟大法好**

细节真多！

```cpp
int main(){
    cin>>s;
    l=s.length();
    int m2=s.find('^',0);
    if (m2==-1) cout<<s;            //若无二次项可直接输出
    else{
        int m1=s.find('x',m2);
        if (m1!=-1){
            char w=s[m2+2];
            ll s1=0;                            //不加ll只有90QAQ
            for (int i=m2+3;i<m1;i++)
                s1=s1*10+s[i]-'0';         //求一次项系数
            if (m2+3==m1) s1=1;
            if (w=='-') {
                b=-s1;
            }
            else b=s1;
            char ww=s[m1+1];           //求常数，同理啦
            ll s2=0;
            for (int i=m1+2;i<l;i++)
                s2=s2*10+s[i]-'0';
            if (ww=='-') c=-s2;
            else {
    pr            c=s2; 
    pr        } 
        }
        else{       //这是没有一次项的情况
            char w=s[m2+2];
            ll s1=0;
    pr        for (int i=m2+3;i<l;i++)
                s1=s1*10+s[i]-'0';
            if (w=='-') {
                c=-s1;
            }
            else c=s1;
        }
        //cout<<a<<" "<<b<<" "<<c;
        ll x1=-(-b+(ll)sqrt(b*b-4*a*c))/2;
        ll x2=-(-b-(ll)sqrt(b*b-4*a*c))/2;        //求两根，注意取反
        if (x1<x2) swap(x1,x2);
        if (x1==x2) {
            if (x1==0) cout<<"x"; 
            else if (x1>0) cout<<"(x+"<<x1<<")";
            else cout<<"(x"<<x1<<")";
            cout<<"^2";     //两部分一样的输出平方即可
        }else{
            if (x1==0) cout<<"x"; 
            else if (x1>0) cout<<"(x+"<<x1<<")";
            else cout<<"(x"<<x1<<")";
            if (x2==0) cout<<"x"; 
            else if (x2>0) cout<<"(x+"<<x2<<")";
            else cout<<"(x"<<x2<<")";
    }
```
}//输出略复杂，但本质简单，就是输出﹢号和无符号的情况
}

---


# 图像变换

## 题目描述

给定 $3$ 行 $3$ 列的图像各像素点灰度值，给定最终图像，求最短、字典序最小的操作序列。

其中，可能的操作及对应字符有如下四种：

`A`：顺时针旋转 $90$ 度；

`B`：逆时针旋转 $90$ 度；

`C`：左右翻转；

`D`：上下翻转。

## 说明/提示

字符串长度不超过 $10^8$。

## 样例 #1

### 输入

```
3 4 5
6 7 8
1 2 3
1 2 3
6 7 8
3 4 5```

### 输出

```
D```

# 题解

## 作者：liuguangzhe (赞：25)

这里是来自出题人liuguangzhe的题解。。。

“引理”：只要有解，那么必存在长度不超过4的可行解。

证明：首先显然操作之间的相对顺序是不会影响结果的，那么对于一个序列我们把

相同操作放到一起分析。不难发现执行两次C或D等价于不操作，因此若操作k次，

实际效果等价于操作k%2次，那么执行C、D的次数均不超过1。而对于A、B，由于

相反性所以至多出现一种（除了根本没变的情况），而且AAA等价于B，BBB等价于

A，故A与B加起来出现不超2次。因此，最短序列总长度不超过4。

因此本题其实是吓人的Pure Water。。。


---

## 作者：cq_loves_Capoo (赞：11)

说句实话，我一看到这题目时确实被吓得不浅，不过窝睡了一晚上后突然灵感冒出（想了一晚上就直说），终于 AC 了，一看还能交题解，而且偶跟别人做法也不同，所以就来一篇题解吧。   
   
首先理清一下思路，题目说：   
   
	>最短、字典序最小的操作序列，保证长度不超过 10^8，不保证有解。`   
      
这个 $10^{8}$ 吓人不浅，但是，只要仔细打一下草稿，就会发现，其实就一共 $9$ 种情况：   
  
```
A（顺时针转 90 度）
B（逆时针转 90 度）
C（左右翻转）
D（上下翻转，也可以理解成左右翻转后再转 180 度）
AA（转 180 度）
AB（不动）
AC（左右翻转并顺时针转 90 度）
BC（左右翻转并逆时针转 90 度）
最后一种是无解。
```  
  
有人会问：上下翻转为什么珂以理解成左右翻转后再转 180 度？这其实就是一块玻璃，怎么翻转还是只有两面，转完两面后就转 180 度其实就是上下翻转了= =（自己推算的不确定）   
  
既然只有九种情况，那么就好办了。  
  
第一种情况A：B+B+B  
  
第二种情况B：  
  
```
for (int i=1; i<=n; i++)
	for (int j=1; j<=n; j++) {
		int x = j;
		int y = n - i + 1;//这种东西在草稿纸上画两下数对，然后就珂以很容易理解了
		c[i][j] = a[x][y];
	}
for (int i=1; i<=n; i++)
	for (int j=1; j<=n; j++)
		a[i][j] = c[i][j];
```
   
第三种情况C：（应该都不咋要解释）  
  
```
for (int i=1; i<=n; i++)
	for (int j=1; j<=n/2; j++)
		swap (a[i][j], a[i][n-j+1]);
```
  
第四种D就直接为：C+B+B  
  
剩下四种都是组合，就不需要解释了，下面给个有注释的代码：   
   
```
#include<bits/stdc++.h>
#define endl '\n'
#pragma GCC optimize(3)

using namespace std;
int a[10][10], b[10][10], c[10][10];
const int n = 3;

inline bool judgement()//这个是判断 a 和 b 相不相等的函数 
{
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			if (a[i][j] != b[i][j])
				return false;
	return true;
}

inline void B() {//偶打了个 B 先 
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++) {
			int x = j;
			int y = n - i + 1;
			c[i][j] = a[x][y];
		}
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			a[i][j] = c[i][j];
}

inline void A() { B(); B(); B(); } //用一个函数，主程序好打很多 

inline void C() {//C的翻转 
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n/2; j++)
			swap (a[i][j], a[i][n-j+1]);
}

inline void D() { C(); B(); B(); } 

signed main() {
	ios::sync_with_stdio(false);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			cin >> a[i][j];
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
			cin >> b[i][j];//输入 
	if (judgement()) return cout << "AB", 0;//不变的先判断了再说（
	A();
	if (judgement()) return cout << "A", 0;//A的情况 
	B(); /*因为需要把它变回原来的形状才行，逆时针可以把顺时针弄回去，下面的道理相同*/B();
	if (judgement()) return cout << "B", 0;
	A(); C();
	if (judgement()) return cout << "C", 0;
	C();/*C 的翻转就是再把 C 翻转一次*/ D();
	if (judgement()) return cout << "D", 0;
	D(); A(); A();
	if (judgement()) return cout << "AA", 0;
	A(); A(); A(); C();
	if (judgement()) return cout << "AC", 0;
	C(); B(); B(); C();
	if (judgement()) return cout << "BC", 0;
	cout << "Poland cannot into space!!!";
	return 0;//被大佬嫌弃不加 return 0; ，这次加上（
}
```    
   
如果有不懂，珂以找[这个菜鸡](https://www.luogu.com.cn/user/267364)私信解答qwq。

---

## 作者：hensier (赞：7)

[获得更好的阅读体验](https://shenyouran.github.io/P2630/)

这道题要求是输出最短、字典序最小的操作序列。对于这种最优解问题，使用$\text{BFS}$再好不过。

然而，在搜索之前，我们发现有这样的一句话：

> 保证长度不超过 $10^8$

这句话会导致我们认为本题非常的困难，但同时也给了我们一个暗示，即是否能够满足下面两点之一：

- 任何一个有解的答案长度必定不超过$s(s \lt 10^8)$

- 变换的过程有规律，可以找到周期进行计算

在考虑这些问题之前，我们来看一下变换的方式——题目中给出了四种。

显然，做$3$次$B$就等价与执行$1$次$A$，反之亦然。因此，$A$和$B$的任意一种执行次数$\ge 3$的时候，就必定可以转化为更少的执行次数。

例如：如果我们执行$3$次$B$，那么就等同于将图像逆时针旋转$90\times 3=270^{\circ}$，即把图像顺时针旋转$360-270=90^{\circ}$。这样就转化为了执行$1$次$A$。

为了更直观地呈现规律，我们不妨列出执行对应次数$B$时图像的变化：

|执行次数|旋转方向|旋转角度|转化操作|
| :----------: | :----------: | :----------: | :----------: 
|$1$|逆时针|$90^{\circ}$|$B1$|
|$2$|逆时针/顺时针|$180^{\circ}$|$A2$
|$3$|顺时针|$90^{\circ}$|$A1$
|$4$|/|$0^{\circ}$|/|
|$5$|逆时针|$90^{\circ}$|$B1$|
|$...$|$...$|$...$|$...$|

观察上表可发现，规律为每$4$个为一周期。因此，任何次数的$B$操作，都可以被转化为执行次数$\le 2$的$A$操作。反之亦然。

根据操作规律可知，$C$和$D$操作在分别执行$2$次后等价于不执行。也就是说，执行了$n$次这两种操作中的一种，都等同于操作$n\bmod 2$次。而$n\bmod 2$的最大值为$1$，所以“最坏情况”就是$C$和$D$各执行$1$次，即共执行$2$次。

综上所述，如果题目有解，那么总执行次数必定$\le 4$。这样一来，$10^8$的迷惑就被识破了。

因为总执行次数为$4$次，所以最终的字符串就有$4+4^2+4^3+4^4=340$种可能（全排列）。这样，队列元素下标只需要$341$个就足够了（~~其实开一千个也无妨~~）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int front=1,rear=1;//定义队列的队头和队尾
struct matrix
{
    int a[4][4];//图像大小为3*3
}first,goal;//这里直接定义该类型的变量，其中first表示初始图像，goal表示目标状态
struct node
{
    matrix m;//表示对应状态下的图像
    string seq;//表示对应状态下的字符串
}q[341];//上面提到，341个元素已经足够了
matrix change(matrix x,char opt)
{
    matrix y;//定义即将被替换的图像
    switch(opt)//每一个字符对应着题目中的操作类型
    {
        case 'A':
        {
            /*
            123     741
            456 ->  852
            789     963
            可以通过下列方式变换：
            123     147     741
            456 ->  258 ->  852
            789     369     963
            即先将图像横纵坐标交换，再将每一行倒置
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[4-j][i];
                }
            }
            break;
        }
        case 'B':
        {
            /*
            123     583
            456 ->  472
            789     361
            可以通过下列方式变换：
            123     147     369
            456 ->  258 ->  258
            789     369     147
            即先将图像横纵坐标交换，再将每一列倒置
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[j][4-i];
                }
            }
            break;
        }
        case 'C':
        {
            /*
            可以理解为，将每一行的数字进行翻折（两个图像成轴对称，列不变）
            123     321
            456 ->  654
            789     987
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[i][4-j];
                }
            }
            break;
        }
        case 'D':
        {
            /*
            可以理解为，将每一列的数字进行翻折（两个图像成轴对称，行不变）
            123     789
            456 ->  456
            789     123
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[4-i][j];
                }
            }
            break;
        }
    }
    return y;
}
bool check(matrix x)//判断是否符合目标状态，具体方法是比较目前图像和目标图像
{
    for(int i=1;i<4;i++)
    {
        for(int j=1;j<4;j++)
        {
            if(x.a[i][j]!=goal.a[i][j])
            {
                return false;
            }
        }
    }
    return true;
}
int main()
{
    //输入初始图像
    for(int i=1;i<4;i++)
    {
        for(int j=1;j<4;j++)
        {
            scanf("%d",&first.a[i][j]);
        }
    }
    //输入目标图像
    for(int i=1;i<4;i++)
    {
        for(int j=1;j<4;j++)
        {
            scanf("%d",&goal.a[i][j]);
        }
    }
    q[1]=(node){first,""};//初始化队头，其中图像为初始图像，字符串为空
    while(front<=rear)
    {
        node f=q[front++];//取队头并出队
        for(char c='A';c<='D';c++)//注意可以进行字符的循环（ASCII码可以直接使用）
        {
            node cur=(node){change(f.m,c),f.seq+c};//新的元素是上一个元素在经过对应操作之后得到的，而字符串是在原来的基础上加上该字符得到的
            if(cur.seq.size()<5)q[++rear]=cur;//如果字符串长度<5，即<=4就入队。注意一旦长度大于4，就不再入队，很快宽搜的循环就将结束（因为rear不变，而front一直在变大）
            if(check(cur.m))//判断是否到达目标状态
            {
                cout<<cur.seq;
                return 0;//宽搜找到的是最优解，所以可以直接结束程序
            }
        }
    }
    puts("Poland cannot into space!!!");//无解就输出对应信息
    return 0;
}
```

---

## 作者：Dragonbell_exp (赞：4)

[P2630 图像变换](https://www.luogu.com.cn/problem/P2630)



### 思路：

这道题的意思是：

输入两个图像，

判断变换的方式，

输出。

根据题目，乍一看，好像并不简单。

然这道题给了这样一句话：
输出最短，字典序最小的操作序列。
 
这段话直接把这道题难度大幅降低，

我们经过分析后得出，

这道题其实输出的形式只可能是：

#### A，B，C，D，AA，AB，AC，AD。

其余形式都与以上形式重复，这道题需要输出最短，字典序最小的答案。

代码就是，判断八种情况，输出对应的形式。

如果都不符合，那么就输出
“Poland cannot into space!!!”。

## 代码：

```c
#include<iostream>
using namespace std;
int t[5][5];//定义两个矩阵 
int d[5][5];
int main(){
	//读入两个矩阵 
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			cin>>t[i][j];
		}
	}
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			cin>>d[i][j];
		}
	}//接下来是判断八种情况。
	bool p=0;//标记一下，判断是否符合 
	if(t[1][1]==d[1][3]&&t[1][2]==d[2][3]&&t[1][3]==d[3][3]&&t[2][1]==d[1][2]&&t[2][2]==d[2][2]&&t[2][3]==d[3][2]&&t[3][1]==d[1][1]&&t[3][2]==d[2][1]&&t[3][3]==d[3][1]){
		cout<<'A';
		p=1;//如果符合其中的形式，p=0表示已找到，结束。
		return 0; 
	}
	if(t[1][1]==d[3][1]&&t[1][2]==d[2][1]&&t[1][3]&&d[1][1]&&t[2][1]==d[3][2]&&t[2][2]==d[2][2]&&t[2][3]==d[1][2]&&t[3][1]==d[3][3]&&t[3][2]==d[2][3]&&t[3][3]==d[1][3]){
		cout<<'B';
		p=1;
		return 0;
	}
	if(t[1][1]==d[1][3]&&t[1][2]==d[1][2]&&t[1][3]==d[1][1]&&t[2][1]==d[2][3]&&t[2][2]==d[2][2]&&t[2][3]==d[2][1]&&t[3][1]==d[3][3]&&t[3][2]==d[3][2]&&t[3][3]==d[3][1]){
		cout<<'C';
		p=1;
		return 0;
	}
    if(t[1][1]==d[3][1]&&t[1][2]==d[3][2]&&t[1][3]==d[3][3]&&t[2][1]==d[2][1]&&t[2][2]==d[2][2]&&t[2][3]==d[2][3]&&t[3][1]==d[1][1]&&t[3][2]==d[1][2]&&t[3][3]==d[1][3]){
    	cout<<'D';
    	p=1;
    	return 0;
	}
	if(t[1][1]==d[3][3]&&t[1][2]==d[3][2]&&t[1][3]==d[3][1]&&t[2][1]==d[2][3]&&t[2][2]==d[2][2]&&t[2][3]==d[2][1]&&t[3][1]==d[1][3]&&t[3][2]==d[1][2]&&t[3][3]==d[1][1]){
    	cout<<"AA";
    	p=1;
    	return 0;
	}
	if(t[1][1]==d[1][1]&&t[1][2]==d[1][2]&&t[1][3]==d[1][3]&&t[2][1]==d[2][1]&&t[2][2]==d[2][2]&&t[2][3]==d[2][3]&&t[3][1]==d[3][1]&&t[3][2]==d[3][2]&&t[3][3]==d[3][3]){
    	cout<<"AB";
    	p=1;
    	return 0;
	}
	if(t[1][1]==d[3][3]&&t[1][2]==d[2][3]&&t[1][3]==d[1][3]&&t[2][1]==d[3][2]&&t[2][2]==d[2][2]&&t[2][3]==d[1][2]&&t[3][1]==d[3][1]&&t[3][2]==d[2][1]&&t[3][3]==d[1][1]){
    	cout<<"AD";
    	p=1;
    	return 0;
	}
	if(t[1][1]==d[1][1]&&t[1][2]==d[2][1]&&t[1][3]==d[3][1]&&t[2][1]==d[1][2]&&t[2][2]==d[2][2]&&t[2][3]==d[3][2]&&t[3][1]==d[1][3]&&t[3][2]==d[2][3]&&t[3][3]==d[3][3]){
    	cout<<"AC";
    	p=1;
    	return 0;
	}
	if(p==0)//如果都不符合，输出↓ 
	cout<<"Poland cannot into space!!!";
}
```




---

## 作者：nth_element (赞：4)

## 我先讲一下我的思路
1. 将A，B，C，D四种操作用函数储存起来；

2. 枚举所有可能出现的情况：A,B,C,D,AA,AB,AC,AD,BB,BC,BD,CC,CD,DD,ABC,ABD,ACD,BCD,ABCD共19种情况；(这里面一定有遗漏的点，但由于数据~~太水~~,所以没有一一列出来)

3. 对初始矩阵进行上面枚举的操作，如果操作后与最终矩阵相同，便直接输出所对应的枚举的操作；

4. 如果此时还没有结束程序（即所有操作都枚举完之后，皆不符合最终矩阵），就直接输出“Poland cannot into space!!!”
***


## 这是我的局部程序
### 1.A的操作函数：
```cpp
int A_operation()
{
	memset(c,0,sizeof(c));//由于要多次用这个转换数组，所以必须清零 
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			c[i][j]=a[3-j+1][i];//按照题目要求进行操作 
		}
	}
	memcpy(a,c,sizeof(a));//将c这个中间 数组里的值拷贝到a数组中 
}
```

可以看到这里我用了memset和memcpy这两个函数：

**memset** 是内存赋值函数，比用for来赋值快很多，只是只能赋值常量；

用法：**memset（数组名，常量，sizeof（数组名））** ；

**memcpy** 是内存赋值函数，将一个数组里的值复制到另一个数组中

用法：**memcpy（目标数组名，被复制函数名，sizeof（被复制函数名））**

———————————————————————华丽的分割线—————————————————————
### 2.枚举的操作情况：
```cpp
memcpy(a,b,sizeof(a));//因为a的值会多次改变，所以b是输入的初始数组，要在每一次枚举的操作后，将a覆盖 
flag=1;//标志，判断是否成功 
A_operation();
A_operation();//进行操作 
for(int i=1;i<=3;i++)
{
	for(int j=1;j<=3;j++)
	{
		if(a[i][j]!=d[i][j])//假如有一个不相同，就跳出循环 
		{
			flag=0;//失败 
			goto p;//跳出循环 
		}
	}
}
p:
if(flag==1)//假如没有失败 
{
	printf("AA");//输出操作 
	return 0; //结束程序 
}
```

这里有一个新的跳出循环的方法，goto语句（~~我也是才学的~~）

这个语句与break,continue,return等语句的区别是：
>break是跳出一层循环，continue是跳过本次循环，return是结束程序||函数，而goto则是想怎么跳就怎么跳（是不是有点心动了~~~）

用法：**goto** 语句名

语句名：（要跳到的地方）
***
## 直接上程序
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[4][4],b[4][4],c[4][4],d[4][4];
int flag=1;    
int A_operation()
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			c[i][j]=a[3-j+1][i];
		}
	}
	memcpy(a,c,sizeof(a)); 
}
int B_operation()
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			c[i][j]=a[j][3-i+1];
		}
	}
	memcpy(a,c,sizeof(a));
}

int C_operation()
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			c[i][j]=a[i][3-j+1];
		}
	}
	memcpy(a,c,sizeof(a));
}
int D_operation()
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			c[i][j]=a[3-i+1][j];
		}
	}
	memcpy(a,c,sizeof(a));
}
int main()
{
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			scanf("%d",&b[i][j]);
		}
	}
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			scanf("%d",&d[i][j]);
		}
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto a;
			}
		}
	}
	a:
	if(flag==1)
	{
		printf("A");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	B_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto b;
			}
		}
	}
	b:
	if(flag==1)
	{
		printf("B");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	C_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto c;
			}
		}
	}
	c:
	if(flag==1)
	{
		printf("C");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	D_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto d;
			}
		}
	}
	d:
	if(flag==1)
	{
		printf("D");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	A_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto p;
			}
		}
	}
	p:
	if(flag==1)
	{
		printf("AA");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	B_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto e;
			}
		}
	}
	e:
	if(flag==1)
	{
		printf("AB");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	C_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto f;
			}
		}
	}
	f:
	if(flag==1)
	{
		printf("AC");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	D_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto g;
			}
		}
	}
	g:
	if(flag==1)
	{
		printf("AD");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	B_operation();
	B_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto q;
			}
		}
	}
	q:
	if(flag==1)
	{
		printf("BB");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	B_operation();
	D_operation();			
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto h;
			}
		}
	}
	h:
	if(flag==1)
	{
		printf("BD");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	C_operation();
	B_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto i;
			}
		}
	}
	i:
	if(flag==1)
	{
		printf("BC");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	C_operation();
	C_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto r;
			}
		}
	}
	r:
	if(flag==1)
	{
		printf("CC");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	C_operation();
	D_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto j;
			}
		}
	}
	j:
	if(flag==1)
	{
		printf("CD");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	D_operation();
	D_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto s;
			}
		}
	}
	s:
	if(flag==1)
	{
		printf("DD");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	B_operation();
	C_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto k;
			}
		}
	}
	k:
	if(flag==1)
	{
		printf("ABC");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	D_operation();
	C_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto l;
			}
		}
	}
	l:
	if(flag==1)
	{
		printf("ACD");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	B_operation();
	D_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto m;
			}
		}
	}
	m:
	if(flag==1)
	{
		printf("ABD");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	D_operation();
	B_operation();
	C_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto n;
			}
		}
	}
	n:
	if(flag==1)
	{
		printf("BCD");
		return 0;
	}
	memcpy(a,b,sizeof(a));
	flag=1;
	A_operation();
	D_operation();
	B_operation();
	C_operation();
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(a[i][j]!=d[i][j])
			{
				flag=0;
				goto o;
			}
		}
	}
	o:
	if(flag==1)
	{
		printf("ABCD");
		return 0;
	}
	printf("Poland cannot into space!!!");//假如上面枚举的情况都不行，就输出（对应4）
	return QWQ
}
```
# 拜拜~~~

---

## 作者：Minecraft万岁 (赞：3)

几个月前本蒟蒻看见这道题吓了一跳  
这居然有 $4$ 个操作 还要什么长度最短字典序最小   
~~不会不会溜了~~   
这道题其实是一个弱化版  
双倍经验 $:$ [也是一个很烦的暴力bfs](https://www.luogu.com.cn/problem/P2346)  
这题分析一下发现 这翻来翻去 转来转去 很多都会重复 况且这是$3\times3$的矩阵 不会扩展出多少种不同的状态   
于是我决定 ~~肝~~写bfs ~~不就150多行吗~~    
详细注释在代码中 仔细看一看应该可以懂的     
代码时间  


------------

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
typedef long long ll;
struct node//用结构体更方便 
{
	int jz[4][4];//当前的矩阵 
	string op;//操作用字符串存 string 可以用"+"好方便 
}tmp,nx;//tmp:暂存当前 nx:扩展下一步 
vector<node> e;//存已经扩展过得元素 
queue<node> Q;//bfs队列 
int st[4][4];//开始的矩阵 
int en[4][4];//结束的矩阵 
inline void read(int &x)//快读 
{
	int f;char c;
	for (f=1,c=getchar();c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;
	for (x=0;c<='9'&&c>='0';c=getchar()) x=x*10+(c&15);x*=f;
}
inline bool ed(node t)//看看是不是结束时候的状态 
{
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
		{
			if(t.jz[i][j]!=en[i][j]) return false;
		}
	return true;
}
inline bool check_ys(node p,node q)//看看两个矩阵是不是一样的 
{
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
			if(p.jz[i][j]!=q.jz[i][j]) return false;
	return true;
}
inline bool check(node t)//看看t是不是扩展过了 
{
	for(int i=0;i<e.size();i++)
	{
		if(check_ys(e[i],t)) return true;
	}
	return false;
}
inline node A(node x)//A操作 
{
	node rest=x;
	rest.op=rest.op+"A";
	for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            rest.jz[i][j]=x.jz[3-j+1][i];
	return rest;
}
inline node B(node x)//B操作 
{
	node rest=x;
	rest.op=rest.op+"B";
	for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            rest.jz[i][j]=x.jz[j][3-i+1];
    return rest;
}
inline node C(node x)//C操作 
{
	node rest=x;
	rest.op=rest.op+"C";
	for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            rest.jz[i][j]=x.jz[i][3-j+1];
    return rest;
}
inline node D(node x)//D操作 
{
	node rest=x;
	rest.op=rest.op+"D";
	for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            rest.jz[i][j]=x.jz[3-i+1][j];
	return rest;
}
int main()
{
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
		{ 
			read(st[i][j]);//读入 
			tmp.jz[i][j]=st[i][j];//顺便弄一下初始状态的结构体 
		}
	for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
			read(en[i][j]);//读入 
	e.push_back(tmp);//初始状态不扩展了 
	Q.push(tmp);//标准bfs*1 
	if(ed(tmp))//特殊情况 
	{
		puts("AB");//因为字典序最小且不能不操作只能输出这个玩意了 
		return 0;
	}
	while(!Q.empty())//标准bfs*2 
	{
		tmp=Q.front();//标准bfs*3 
		Q.pop();
		nx=A(tmp);//按字典序分别扩展A B C D 在bfs的特性下同等长度中先取到的一定字典序最小 
		if(!check(nx)) 
		{
			Q.push(nx); //没有扩展过 就扩展
			e.push_back(nx);//手残漏写MLE好几次 
		}
		if(ed(nx))//有没有和结束一样 
		{
			cout<<nx.op<<endl;//结束了就输出return 0别bfs了 
			return 0;
		}
		nx=B(tmp);//重复*1 
		if(!check(nx)) 
		{
			Q.push(nx);
			e.push_back(nx);
		}
		if(ed(nx))
		{
			cout<<nx.op<<endl;
			return 0;
		}
		nx=C(tmp);//重复*2 
		if(!check(nx)) 
		{
			Q.push(nx);
			e.push_back(nx);
		} 
		if(ed(nx))
		{
			cout<<nx.op<<endl;
			return 0;
		}
		nx=D(tmp);//重复*3 
		if(!check(nx)) 
		{
			Q.push(nx);
			e.push_back(nx);
		}
		if(ed(nx))
		{
			cout<<nx.op<<endl;
			return 0;
		}
	}
	printf("Poland cannot into space!!!");//while循环结束还没有 一定就没有了 
	return 0;
}


```
 ![](https://cdn.luogu.com.cn/upload/image_hosting/jqvcwfk2.png)

---

## 作者：回青绝影 (赞：3)

#### 蒟蒻发现这道题没(dou)有(shi)十分好（la)的(ji)题解，便来发一篇水一下……

###### 这是一道十分水的模拟题……

## “好的方法”：上一篇题解，解释了操作最多4步，对吧！

### 解释一下：

(1)首先，A与B，三个A就是一个B，反之，也是，所以A与B最多只能出现两次，而且，A与B时逆运算，所以A与B不会同时出现

(2)然后C与D，C两下就回去了，D也一样，所以C与D的逆运算就是他本身，所以最多一个C,一个D！

(3)结合1,2,所以最多出现（两次A或两次B）和一个C,一个D。四步！

上面也解释了，BB，CC,DD（分开也同样，如B****B）是绝对不会出现的！

#### ————AA与BB的效果相同，AA又比BB更优，CC与DD都是重复的。

不废话，上代码

（码风丑，见谅）

```
#include<bits/stdc++.h>
using namespace std;
int a[4][4],b[4][4],c[4][4],d[4][4],ans=100000,an[11],k=0;
void mem(){
	for (int i=1;i<=3;i++)
	    for (int j=1;j<=3;j++)
	        b[i][j]=a[i][j];
}
void wa(){
	c[1][1]=b[3][1];
	c[1][2]=b[2][1];
	c[1][3]=b[1][1];
	c[2][1]=b[3][2];
	c[2][2]=b[2][2];
	c[2][3]=b[1][2];
	c[3][1]=b[3][3];
	c[3][2]=b[2][3];
	c[3][3]=b[1][3];
	for (int i=1;i<=3;i++){
	    for (int j=1;j<=3;j++){
	    	b[i][j]=c[i][j];
//	        printf("%d ",b[i][j]);
		}
//		printf("\n");
	}
}
void wb(){
	wa();wa();wa();
//	for (int i=1;i<=3;i++){
//	    for (int j=1;j<=3;j++)
//	        printf("%d ",c[i][j]);
//		printf("\n");
//	}
}
void wc(){
	swap(b[1][1],b[1][3]);
	swap(b[2][1],b[2][3]);
	swap(b[3][1],b[3][3]);
}
void wd(){
	swap(b[1][1],b[3][1]);
	swap(b[1][2],b[3][2]);
	swap(b[1][3],b[3][3]);
//	printf("\n");
//	for (int i=1;i<=3;i++){
//	    for (int j=1;j<=3;j++)
//	        printf("%d ",b[i][j]);
//		printf("\n");
//	}
}
bool judge(){
	if (k!=0) return false;
	for (int i=1;i<=3;i++)
	    for (int j=1;j<=3;j++)
	        if (d[i][j]!=b[i][j]) return false;
	return true;
}
void print(){
	mem();wa();if (judge()) printf("A"),k++;
	mem();wb();if (judge()) printf("B"),k++;
	mem();wc();if (judge()) printf("C"),k++;
	mem();wd();if (judge()) printf("D"),k++;
	mem();wa();wa();if (judge()) printf("AA"),k++;
	mem();wa();wb();if (judge()) printf("AB"),k++;
	mem();wa();wc();if (judge()) printf("AC"),k++;
	mem();wa();wd();if (judge()) printf("AD"),k++;
	mem();wb();wc();if (judge()) printf("BC"),k++;
	mem();wb();wd();if (judge()) printf("BD"),k++;
	mem();wc();wc();if (judge()) printf("CC"),k++;
	mem();wc();wd();if (judge()) printf("CD"),k++;
	mem();wd();wd();if (judge()) printf("DD"),k++;
	mem();wa();wc();wd();if (judge()) printf("ACD"),k++;
	mem();wb();wc();wd();if (judge()) printf("BCD"),k++;
	mem();wa();wb();wc();wd();if (judge()) printf("ABCD"),k++;
	if (k==0) printf("Poland cannot into space!!!");  //一开始我就忘了QWQ
}
int main(){
	for (int i=1;i<=3;i++)
	    for (int j=1;j<=3;j++)
	        scanf("%d",&a[i][j]);
	for (int i=1;i<=3;i++)
	    for (int j=1;j<=3;j++)
	        scanf("%d",&d[i][j]);
	print();
	return 0;
}
```

### 还有，要记住输出无解时候的"Poland cannot into space!!!"！！！！！

![](https://cdn.luogu.com.cn/upload/pic/51798.png)


抱怨一下，有7个数据点都是无解的……数据太~~劲~~（水）了。

---

## 作者：Na2PtCl6 (赞：1)

## 分析题目
一看这个 $10^8$ 就知道是来忽悠人的，哪里有可能枚举到那里！

所以我打开题解，看有没有什么循环节或是长度的限制，发现 [第一篇题解](https://www.luogu.com.cn/blog/user10267/solution-p2630) 证明了有解的矩阵操作不超过 4 个。有了这个限定，我们就可以愉快得暴搜了。

值得注意的是，在两个测试点中，初始矩阵和目标矩阵是相同的，但我们还是要进行操作。所有能使矩阵还原的操作序列中 `AB` 是最短最快的，特判输出它就好了。

## 代码实现
这里我用了一个结构体来存矩阵，这样会让矩阵更好地在递归中使用以及更灵活多变。
```
#include<cstdio>
#include<iostream>
using namespace std;
struct mar{
	int m[4][4];

	bool operator == (const mar &comp) const{
		for(int i=1;i<=3;i++)
			for(int j=1;j<=3;j++)
				if(m[i][j]!=comp.m[i][j])
					return 0;
		return 1;
	}

	mar A(){
		mar tmp;
		tmp.m[1][1]=m[3][1],tmp.m[1][2]=m[2][1],tmp.m[1][3]=m[1][1];
		tmp.m[2][1]=m[3][2],tmp.m[2][2]=m[2][2],tmp.m[2][3]=m[1][2];
		tmp.m[3][1]=m[3][3],tmp.m[3][2]=m[2][3],tmp.m[3][3]=m[1][3];
		return tmp;
	}

	mar B(){
		mar tmp;
		tmp.m[1][1]=m[1][3],tmp.m[1][2]=m[2][3],tmp.m[1][3]=m[3][3];
		tmp.m[2][1]=m[1][2],tmp.m[2][2]=m[2][2],tmp.m[2][3]=m[3][2];
		tmp.m[3][1]=m[1][1],tmp.m[3][2]=m[2][1],tmp.m[3][3]=m[3][1];
		return tmp;
	}

	mar C(){
		mar tmp;
		for(int i=1;i<=3;i++)
			for(int j=1;j<=3;j++)
				tmp.m[i][j]=m[i][j];
		swap(tmp.m[1][1],tmp.m[1][3]);
		swap(tmp.m[2][1],tmp.m[2][3]);
		swap(tmp.m[3][1],tmp.m[3][3]);
		return tmp;
	}

	mar D(){
		mar tmp;
		for(int i=1;i<=3;i++)
			for(int j=1;j<=3;j++)
				tmp.m[i][j]=m[i][j];
		swap(tmp.m[1][1],tmp.m[3][1]);
		swap(tmp.m[1][2],tmp.m[3][2]);
		swap(tmp.m[1][3],tmp.m[3][3]);
		return tmp;
	}
}a,b;

string _min(const string &a,const string &b){
	if(a.size()==b.size())
		return a<b?a:b;
	return  a.size()<b.size()?a:b;
}

string dfs(mar m,int step,string now){
	if(step>4)
		return "Poland cannot into space!!!";
	if(m==b)
        return now;
	return _min(_min(dfs(m.A(),step+1,now+"A"),dfs(m.B(),step+1,now+"B"))
		   ,_min(dfs(m.C(),step+1,now+"C"),dfs(m.D(),step+1,now+"D")));
}

int main(){
    for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
			scanf("%d",&a.m[i][j]);
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            scanf("%d",&b.m[i][j]);
    if(a==b)
		puts("AB");
	else 
    	cout<<dfs(a,0,"");
    return 0;
}
```

---

## 作者：Ace_Radom (赞：1)

【本做法纯属暴力，代码极长，一共写了18个函数。密集恐惧症者请跳过。】



------------



在小号里随机跳题抽到了这道题，觉得挺有意思的，就做了一下。

最终写出了和[这位 dalao ](https://www.luogu.com.cn/blog/14w10-wangyuhan/solution-p2630)相似的暴力模拟程序。

随后我又仔细读了 ta 的博文，发现里面有几处多余的考虑方法。

我就借这篇题解来~~纠正一下~~吧。

## 题意分析：

	有一个 3×3 的图像，每一个像素点都是一个数字。
    然后又给了一个 3×3 的图像。
    在题目中提到了四种操作方法，要求计算如何用这四种操作方法将第一个图像变成第二个。
    如果可以，输出按字典序排序的最优解；不行，就打出“Poland cannot into space!!!”。
    
## 算法分析：

蒟蒻如我，看完题目就开始暴力。

随后总共花了一个半小时，打出了224行 AC 代码。【晕】

### 后面开始讲具体思路：

既然只有这四种操作，那就一个个**枚举**！

但一看题面：

	若长度不超过100000000无解……
    
显然，彻底的暴力是不行的。

要找到一个优化的方法。

我花了一点时间，得到了那些 dalao 们都得到了的结论：

	答案长度不超过4。
    
这里我整理了题目贡献者 @liuguangzhe 的解释，在这里说一下。

	画几个图不难发现，两次 C 操作和两次 D 操作和不操作等价。
    所以 k 次 C 或 D 操作等价于 k % 2 次。
    综上可得，C 和 D 操作的最优执行次数均不超过 1。
    然后，依然可以从图中发现：AAA 等价 于 B ，BBB 等价于 A 。
    同时可得：AAAA ，BBBB 和 AABB 均等价于不操作。
    所以得出：A 和 B 的总操作次数不超过 2。
    加起来，不难求出四种操作总和次数的最优解不大于 4，得证。
    
根据上面的等价规律和已得的结论，我们只需要考虑 13 种情况：

	 A , B , C , D , AA , AB , AC , AD , BC , BD , CD , ACD , BCD 。
     
这里不用考虑答案长度为 4 ，我也没有举出反例。

但我一时半会儿没证明出来，等以后证明好了再补吧。



------------



### 程序段分析：

这道题有一个难点就是**图形的翻转**。

当然在看到长宽确定的时候**我笑了**。

这里拿 A 操作的程序段来讲讲。

~~~C++
//A 操作：将图像顺时针旋转90°
void Operate_A(){
	memset( t , 0 , sizeof( t ) );
    //用于翻转的数组清零
	for ( int i = 1 ; i <= 3 ; i++ )
    {
        for ( int j = 1 ; j <= 3 ; j++ )
        {
            t[i][j] = a[3-j+1][i];
            //这个后面讲
        }
    }
    memcpy( a , t , sizeof( a ) );
    //把转好的图形誊回原数组中
    // memcpy 用法这里不讲
    return;
}
~~~

主要核心段就是：

	t[i][j] = a[3-j+1][i];
    
来画一个图：

	1 2 3
    4 5 6
    7 8 9
    
    转 90° 以后：
   
   	7 4 1
    8 5 2
    9 6 3

带一下坐标，规律就出来了。

在翻转完以后，和给出的第二个图形比较一下就好了。

## 代码：

~~~C++
#include<bits/stdc++.h>
using namespace std;
int BeforeProcessing[4][4],AfterProcessing[4][4];
// BeforeProcessing 记录原来的图形。
// AfterProcessing 记录后来的图形。
int t[4][4],a[4][4];
//后面就是处理程序。
void Operate_A(){
	memset( t , 0 , sizeof( t ) );
	for ( int i = 1 ; i <= 3 ; i++ )
    {
        for ( int j = 1 ; j <= 3 ; j++ )
        {
            t[i][j] = a[3-j+1][i];
        }
    }
    memcpy( a , t , sizeof( a ) );
    return;
}
void Operate_B(){
	memset( t , 0 , sizeof( t ) );
	for ( int i = 1 ; i <= 3 ; i++ )
    {
        for ( int j = 1 ; j <= 3 ; j++ )
        {
            t[i][j] = a[j][3-i+1];
        }
    }
    memcpy( a , t , sizeof( a ) );
    return;
}
void Operate_C(){
	memset( t , 0 , sizeof( t ) );
	for ( int i = 1 ; i <= 3 ; i++ )
    {
        for ( int j = 1 ; j <= 3 ; j++ )
        {
            t[i][j] = a[i][3-j+1];
        }
    }
    memcpy( a , t , sizeof( a ) );
    return;
}
void Operate_D(){
	memset( t , 0 , sizeof( t ) );
	for ( int i = 1 ; i <= 3 ; i++ )
    {
        for ( int j = 1 ; j <= 3 ; j++ )
        {
            t[i][j] = a[3-i+1][j];
        }
    }
    memcpy( a , t , sizeof( a ) );
    return;
}
//比较，我写成函数了。
bool Compare(){
	for ( int i = 1 ; i <= 3 ; i++ )
	{
		for ( int j = 1 ; j <= 3 ; j++ )
		{
			if ( a[i][j] != AfterProcessing[i][j] )
			{
				return false;
			}
		}
	}
	return true;
}
//依次枚举。
bool OperateAfter_A(){
	Operate_A();
	return Compare();
}
bool OperateAfter_B(){
	Operate_B();
	return Compare();
}
bool OperateAfter_C(){
	Operate_C();
	return Compare();
}
bool OperateAfter_D(){
	Operate_D();
	return Compare();
}
bool OperateAfter_AA(){
	Operate_A();
	Operate_A();
	return Compare();
}
bool OperateAfter_AB(){
	Operate_A();
	Operate_B();
	return Compare();
}
bool OperateAfter_AC(){
	Operate_A();
	Operate_C();
	return Compare();
}
bool OperateAfter_AD(){
	Operate_A();
	Operate_D();
	return Compare();
}
bool OperateAfter_BC(){
	Operate_B();
	Operate_C();
	return Compare();
}
bool OperateAfter_BD(){
	Operate_B();
	Operate_D();
	return Compare();
}
bool OperateAfter_CD(){
	Operate_C();
	Operate_D();
	return Compare();
}
bool OperateAfter_ACD(){
	Operate_A();
	Operate_C();
	Operate_D();
	return Compare();
}
bool OperateAfter_BCD(){
	Operate_B();
	Operate_C();
	Operate_D();
	return Compare();
}
int main(){
	for ( int i = 1 ; i <= 3 ; i++ )
    {
        for ( int j = 1 ; j <= 3 ; j++ )
        {
            cin >> BeforeProcessing[i][j];
        }
    }
    for ( int i = 1 ; i <= 3 ; i++ )
    {
        for ( int j = 1 ; j <= 3 ; j++ )
        {
            cin >> AfterProcessing[i][j];
        }
    }
    //注意，每次枚举前 a 都要赋一下值。
    memcpy( a , BeforeProcessing , sizeof( a ) );
    if ( OperateAfter_A() )
    {
    	cout << "A" << endl;
    	return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_B() )
	{
		cout << "B" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_C() )
	{
		cout << "C" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_D() )
	{
		cout << "D" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_AA() )
	{
		cout << "AA" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_AB() )
	{
		cout << "AB" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_AC() )
	{
		cout << "AC" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_AD() )
	{
		cout << "AD" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_BC() )
	{
		cout << "BC" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_BD() )
	{
		cout << "BD" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_CD() )
	{
		cout << "CD" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_ACD() )
	{
		cout << "ACD" << endl;
		return 0;
	}
	memcpy( a , BeforeProcessing , sizeof( a ) );
	if ( OperateAfter_BCD() )
	{
		cout << "BCD" << endl;
		return 0;
	}
    //还没有找到。
	cout << "Poland cannot into space!!!" << endl;
	return 0;
}

---

## 作者：ksydom (赞：1)

因为某些题解的“误导”以及自己没好好看题导致这道题本蒟蒻提交了**17遍**

![触目惊心](https://i.loli.net/2019/06/08/5cfb67e958ead30059.png)

讲一下这道题蒟蒻的思考过程：

### 1.刚开始一上来我觉得这是个搜索

深搜下一个用哪种方法。于是开始写搜索代码如下（不用看，我都没写完，就自己看看）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define inf 2147483647
#define re register
#define int long long
using namespace std;
int chu[4][4],mo[4][4],huan[4][4];
char cun[1000000002];
bool flag[4];
int k=0,cnt=0;
char A,B,C,D;
void dfs(char x)
{
	k++;
	if(k>=100000000)  0;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			if(chu[i][j]!=mo[i][j]) break;
			if(i==3&&j==3&&chu[i][j]==mo[i][j])
			{
				cun[++cnt]=x;
				for(int o=1;i<=4;o++)
				{
					flag[o]=1;//找到
				}
			}
		}
	}
	//情况不对没找到
	cun[++cnt]=x;
	if(x=='A')
	{
		for(int i=1;i<=3;i++)
		{
			for(int j=1;j<=3;j++)
			{
				chu[i][j]=huan[i][j];
			}
		}
	}
}
signed main(){
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cin>>chu[i][j];
		}
	}
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cin>>mo[i][j];
		}
	}
	if(dfs(A)==0&&dfs(B)==0&&dfs(C)==0&&dfs(D)==0)
	{
		cout<<"Poland cannot into space!!!";
		exit(0);
	}
	else exit(0);
    return 0;
}
```
但是写着写着发现有些不对劲，这个题为什么这么复杂，而且庞大的字符数组（在不用哈希或者map等等这些我一想就
不想用~~不会~~的方法的情况下）是存不下来的。于是我开始想另外的简单解法。

### 2.经过一段时间的思考我发现好像这里的某些情况是重复的

我愉快地推出了和出题人的题解里相似的结论（就是字母总数不超过4个，具体可以看题解1），但是这之后我开始犯糊涂，因为我觉得我要ac了，于是在打好ABCD的改变方式之后我直接排列组合出了所有结果。

### 最后愉快的全部anwser too long （除了无解的两组）

### 3.然后就开始了漫长的删改过程

最开始我心态爆炸不想好好写了，于是就去看题解，然后看到了第三篇一个“类似”的方法（顺便修改了自己的码风）。但其实方法还是有区别的，因为找排列的方式其实是不一样的，但我当时以为正解就是全排列然后转而去检查自己的修改过程（没带脑子），最后也没查出来。

然后我注意到了anwser too long 于是开始删我的修改过程，从16条一直删到9条，这中间因为我完全没有计算于是将AB和CD分为了两种完全不同的情况于是有几组删不掉。最后我编了一个检查程序强行检查是否重复：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define inf 2147483647
#define RE register
using namespace std;
int mid[190][10],f[109][109];
void change_ak()
{
	swap(mid[1][1],mid[3][1]);
	swap(mid[3][1],mid[3][3]);
	swap(mid[3][3],mid[1][3]);
	swap(mid[1][2],mid[2][1]);
	swap(mid[2][1],mid[3][2]);
	swap(mid[3][2],mid[2][3]);
}
void change_bk()
{
	change_ak();
	change_ak();
	change_ak();
}
void change_ck()
{
	swap(mid[1][1],mid[1][3]);
	swap(mid[2][1],mid[2][3]);
	swap(mid[3][1],mid[3][3]);
}
void change_dk()
{
	swap(mid[1][1],mid[3][1]);
	swap(mid[1][2],mid[3][2]);
	swap(mid[1][3],mid[3][3]);
}
void huan()
{
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			mid[i][j]=f[i][j];
		}
	}
}
int main(){
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cin>>f[i][j];
		}
	}
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			mid[i][j]=f[i][j];
		}
	}
	
	change_ak();
	cout<<"a"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_ak();change_bk();
	cout<<"ab"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_ak();change_ck();
	cout<<"ac"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_ak();change_dk();
	cout<<"ad"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_bk();
	cout<<"b"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_ck();
	cout<<"c"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_dk();
	cout<<"d"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_ck();change_dk();
	cout<<"cd"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
	
	change_ak();change_bk();change_ck();change_dk();
	cout<<"abcd"<<endl;
	for(int i=1;i<=3;i++)
	{
		for(int j=1;j<=3;j++)
		{
			cout<<mid[i][j]<<" ";
		}
		cout<<endl;
	}
	huan();
    return 0;
}
```
在不断的对比之后终于删出了正确的种数。

### 4.然后我90分
怎么也过不了第一组样例，卡了好久，最后czd dalao（就是混在我提交记录中间的那位）在用另一个更加毒瘤的方法打表时帮我打出了第一组样例，我才发现这道题**要按字典序排序**，终于ac了这道题。

## 教训
只要这道题我多读几遍题或者事先进行简单的计算就可以省去大部分检查的情况，写代码前的运算是十分重要的

最后贴上我修改过码风的ac代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<queue>
#define inf 2147483647
#define re register
#define int long long
using namespace std;
int fromk[4][4],mid[4][4],tok[4][4];
void copy()
{
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            mid[i][j]=fromk[i][j];
        }
    }
}
void change_ak()
{
    swap(mid[1][1],mid[3][1]);
    swap(mid[3][1],mid[3][3]);
    swap(mid[3][3],mid[1][3]);
    swap(mid[1][2],mid[2][1]);
    swap(mid[2][1],mid[3][2]);
    swap(mid[3][2],mid[2][3]);
}
void change_bk()
{
    change_ak();
    change_ak();
    change_ak();
}
void change_ck()
{
    swap(mid[1][1],mid[1][3]);
    swap(mid[2][1],mid[2][3]);
    swap(mid[3][1],mid[3][3]);
}
void change_dk()
{
    swap(mid[1][1],mid[3][1]);
    swap(mid[1][2],mid[3][2]);
    swap(mid[1][3],mid[3][3]);
}
bool jug()
{
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            if(mid[i][j]!=tok[i][j])
            {
                return 0;
            }
        }
    }
    return 1;
}
signed main(){
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            cin>>fromk[i][j];
        }
    }
    for(int i=1;i<=3;i++)
    {
        for(int j=1;j<=3;j++)
        {
            cin>>tok[i][j];
        }
    }
    int k=0;
    copy();change_ak();if(jug()) cout<<("A"),k++;
    copy();change_bk();if(jug()) cout<<("B"),k++;
    copy();change_ak();change_bk();if(jug()) cout<<("AB"),k++;
    copy();change_ak();change_ck();if(jug()) cout<<("AC"),k++;
    copy();change_ak();change_dk();if(jug()) cout<<("AD"),k++;
    copy();change_ck();if(jug()) cout<<("C"),k++;
    copy();change_dk();if(jug()) cout<<("D"),k++;
    copy();change_ck();change_dk();if(jug()) cout<<("AA"),k++;
    if(k==0) cout<<"Poland cannot into space!!!";
    return 0;
    //change_ak
    //change_bk
    //change_ck
    //change_dk
}

```
求通过

---

## 作者：tututu (赞：1)

同下所言，长度不超过4，则暴搜等皆可，鄙人广搜，请多多指教

（特殊情况输入数据已经相等，但是长度必须>0，所以输出AB）

代码见下：

```cpp
type
  arr=array[1..3,1..3] of longint;
var
  i,t,h,j:longint;
  a,b:arr;
  r:array[-1..20002] of string;
  f:array[-1..20002] of arr;
function same:boolean;//相等判断
var
  i,j:longint;
begin
  for i:=1 to 3 do for j:=1 to 3 do if f[t,i,j]<>b[i,j] then exit(false);
  exit(true);
end;
function q(s:string;t:char):longint;//找出s中t出现次数，r数组就保存路径
var
  i:longint;
begin
  q:=0;
  for i:=1 to length(s) do if s[i]=t then inc(q);
end;
function aa(a:arr):arr;//执行顺时针90
var
  i,j:longint;
begin
  for i:=1 to 3 do for j:=1 to 3 do aa[i,j]:=a[3-j+1,i];
end;
function cc(a:arr):arr;//左右翻转
var
  i,j:longint;
begin
  for i:=1 to 3 do for j:=1 to 3 do cc[i,j]:=a[i,3-j+1];
end;
function dd(a:arr):arr;//上下翻转
var
  i,j:longint;
begin
  for i:=1 to 3 do for j:=1 to 3 do dd[i,j]:=a[3-i+1,j];
end;
begin
  for i:=1 to 3 do for j:=1 to 3 do read(a[i,j]);
  for i:=1 to 3 do for j:=1 to 3 do read(b[i,j]);
  t:=1;
  f[1]:=a;
  if not same then
  while h<t do
    begin
      inc(h);
      if (q(r[h],'A')<2) and (q(r[h],'B')=0) then begin inc(t); f[t]:=aa(f[h]); r[t]:=r[h]+'A'; if same then break; end;
      if (q(r[h],'A')=0) and (q(r[h],'B')<2) then begin inc(t); f[t]:=aa(aa(aa(f[h]))); r[t]:=r[h]+'B'; if same then break; end;
      if q(r[h],'C')=0 then begin inc(t); f[t]:=cc(f[h]); r[t]:=r[h]+'C'; if same then break; end;
      if q(r[h],'D')=0 then begin inc(t); f[t]:=dd(f[h]); r[t]:=r[h]+'D'; if same then break; end;
    end;
  if t=1 then write('AB') else if same then write(r[t]) else write('Poland cannot into space!!!');
end.
```

---


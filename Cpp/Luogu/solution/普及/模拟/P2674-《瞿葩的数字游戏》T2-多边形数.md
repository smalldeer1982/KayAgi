# 《瞿葩的数字游戏》T2-多边形数

## 题目背景

数字王国里有一类特殊的数，它们叫做多边形数。并且国王 $1$ 规定数字间的联姻只能在同为一种多边形数中进行。（请不要吐槽这个规定……）

瞿葩对这个现象十分好奇，见 $36$ 和 $10$ 这一对情侣在散步，便上前询问 $36$ 它是什么多边形数。可是 $36$ 拍拍脑门，想了想说：“我也不知道啊，你去问问国王吧。”

看来国民们并不知道自己是什么多边形数啊，国王 $1$ 急的发愁。国王 $1$ 只知道多边形数怎么计算，但是多边形数要怎么给国民做解释呢，干脆这样解释吧：可以排成正多边形的整数都是多边形数。当然多边形数可以分为三边（角）形数、四边形数（正方形数）、五边形数、六边形数……


## 题目描述

**此题为规律题，请自行寻找规律，以锻炼数学归纳能力！！**

我们拿三角形数做例子：图中的 $1$、$3$、$6$、$10$ 就是三角形数。

 ![](https://cdn.luogu.com.cn/upload/pic/1742.png) 

任务：求出 $N$ 是哪一种多边形数（假设 $N$ 是 $K$ 边形数），比如我们求出 $36$ 是三边形数和四边形数（貌似叫做三角形数和正方形数呵）。若不是多边形数，输出 Poor + 该数字。若同时是多种多边形数，输出最小的一个和第二小的一个。每个读入文件里有 $ng$ 组数据。


## 说明/提示

### 数据范围及约定

对于 $20\%$ 的数据，$1 \le K_1,K_2 \le 6$；

对于 $100\%$ 的数据， $1 \le N \le 10^6$，$1 \le ng \le 10^2$。

如果同时是多种多边形数，设 $K_1$ 为最小的 $K$，$K_2$ 为次小的 $K$。

国王 $1$：“你可以发现四边形数（正方形数）就是平方数这个规律吗？为方便理解，我给出前几个多边形数表。”（表中可以看出，正六边形不包括正中心的那个点，以此类推）

| 自然数 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 三角形数 | $1$ | $3$ | $6$ | $10$ | $15$ | $21$ | $28$ | $36$ |
| 正方形数 | $1$ | $4$ | $9$ | $16$ | $25$ | $36$ | $49$ | $64$ |
| 五边形数 | $1$ | $5$ | $12$ | $22$ | $35$ | $51$ | $70$ | $92$ |
| 六边形数 | $1$ | $6$ | $15$ | $28$ | $45$ | $66$ | $91$ | $120$ |


## 样例 #1

### 输入

```
2
36
1000000
```

### 输出

```
3 4
4 204
```

# 题解

## 作者：lukelin (赞：7)

### 前言
**更好的阅读体验:**  
&ensp;&ensp;&ensp;[**我的博客**](https://www.cnblogs.com/linzhengmin/p/11157998.html)
### 题解
这道题目我是按表格中的列来考虑的，  
![](https://cdn.luogu.com.cn/upload/pic/1743.png)  
设读入的数字为$x$，考虑上面的表格。  
我们发现如果当前为第$k$列，那么该列每行之间都差了$1+2+\dots+(k-1)$。  
于是我们暴力枚举列号，如果当前的$x$满足$(x-k)\ \%\ (1+2+\dots+(k-1))=0$的话,  
显然$x$是珂以成为一个多边形数的。  
设它为$n$边形，那么显然$n=(x-k)\ /\ (1+2+\dots+(k-1))+2$  
然后我们发现每一个边形数的第一个都是它自己，因此除了$2$以外不会有$poor$,特判一下即可。  
还有一个$1$也需要特殊处理，它应该输出$3$和$4$。

### 代码
```cpp
#include <cstdio> 

int read(){
    int x = 0; int zf = 1; char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') zf = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;
}

int main(){
    int ng = read();
    while (ng--){
        int x = read(), ans1 = 0, ans2 = 0;
        if (x == 1){puts("3 4"); continue;}
        else if (x == 2){puts("Poor2"); continue;}
        /*n边形数  k + (n - 2) * (1 + 2 + ... + k)*/
        long long sum = 1;
        for (int k = 2; ; ++k){
            if (sum + k > x) break;
            int lft = x - k;
            if (!(lft % sum)){
                int ans = lft / sum + 2;
                if (ans >= 3){
                    if (ans < ans1 || (!ans1))
                        ans2 = ans1, ans1 = ans;
                    else if (ans < ans2 || (!ans2))
                        ans2 = ans;
                }
            }
            sum += k; 
        }
        if (ans1) printf("%d", ans1);
        if (ans2) printf(" %d\n", ans2);
        else puts("");
    }
    return 0;
}
```

---

## 作者：azihmst (赞：4)

人生中第一道题做了2天

说一下这道题的主要思路：[![](https://cdn.luogu.com.cn/upload/pic/1743.png)](https://cdn.luogu.com.cn/upload/pic/1743.png)

一列列的看规律：

1-》1-》1-》1-》1

2-》3-》4-》5-》6

3-》6-》9-》12-》15

4-》10-》16-》22-》28

分别公差为：0，1，3，6

**那么，对于第n列来说，第一项为n\*（n+1）/2，公差为n\*(n-1)/2**

\*思路如上\*

\*~~智障~~蒟蒻奉上核心代码，为了方便你们~~抄题解~~独立思考，有注释\*

```cpp
void found(int a)
{
    if(a==1)
    {
        cout<<a+2<<" "<<a+3<<endl;//
        return ;//
    }
    else if(a==2)
    {
        cout<<"Poor"<<a<<endl;//
        return ;//
    }
    int k1=0,k2=0;//
    int c=0,d=0;//
    for(int i=2000;i>=2;i--)//
    {
        int k=i*(i+1)/2;//
        int v=i*(i-1)/2;//
        int qwert=(a-k)/v;//
        if(qwert*v+k==a)///
        {
            if(c==0&&k1==0&&qwert>=0)//
            {
                k1=qwert+3;//
                c=1;//
            }
            else if(c!=0&&k1!=0&&d==0&&k2==0&&qwert>=0)//
            {
                k2=qwert+3;//
                d=1;//
            }//
        }/////
    }///
    if(c==1&&d==1)//
    {
        cout<<k1<<" "<<k2<<endl;///
    }
    else if(c==1)//
    {
        cout<<k1<<endl;// 
    }
    else if(c==d&&d==0)///
    {
        cout<<a<<endl;////
    }
    return ;////
}
谢谢支持！
```

---

## 作者：mt19337 (赞：3)

题目说了很清楚，此题找规律，那么就找规律。

![](https://cdn.luogu.com.cn/upload/pic/1743.png)

我们观察数列。


令k表示数列的第k个数。

-----

三角形数：```1 3 6 10 15```

两项相减：```1 2 3 4 5```

再次相减：```1 1 1 1 1```

-----

四边形数：```1 4 9 16 25```

两项相减：```1 3 5 7 9```

再次相减：```2 2 2 2 2```

…………

仔细看，第n形数的$a_k = \sum_{1}^{k}1+(n-2)(k-1)$

∴$a_k = [2 + (k-1)(n-2)]k / 2$

∴$2a_k = [2 + (k-1)(n-2)]k$

∴$4k + k^2 * n - 2 * k^2 - nk = a_k * 2$

∴$(k^2-k)n = a_k * 2 - 4k + 2k^2$

∴$n = \frac{a_k * 2 - 4k + 2k^2}{(k^2-k)}$

然后枚举k即可。

注意n >= 3.

并且，特判1,2。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin >> T;
	while (T--){
		long long n = 0;
		cin >> n;
		if (n == 1)
			cout << "3 4\n";
		else if (n == 2)
			cout << "Poor2\n";
		else{
			long long fir = 0,sec = 0;
			for (int k=2;k<=n;k++){
				int tpl = (n * 2 - 4 * k + 2 * k * k);
				int tpr = (k * k - k);
				if (tpl < 3 * tpr) break;
				if (tpl % tpr == 0)
					sec = fir, fir = tpl / tpr;
			}
			if (fir == 0)
				cout << "Poor" << n << endl;
			else if (sec == 0)
				cout << fir << endl;
			else cout << fir << ' ' << sec << endl;
		}
	}
}

```




---

## 作者：AlexandreLea (赞：2)

## 题目大意

给出一个数 $k$，求它是否是多边形数。如果是，输出符合要求的最小的两个多边形数（如果没有则输出一个）；否则，输出 Poor 该数。

## 题目思路

首先，我们可以下一个定义：设第 $n$ 个 $m$ 边形数为 $K_{n,m}$，那么，我们可以先观察所有的 $K_3,K_4,K_5,K_6$：

$$K_3=1,3,6,10,15,21,28,36$$

那么

$$K_{3,n}=K_{3,n-1}+n$$

那么对于

$$K_4=1,4,9,16,25,36,49,64$$

$$K_5=1,5,12,22,35,51,70,92$$

$$K_6=1,6,15,28,45,66,91,120$$

我们就有

$$K_{4,n}=K_{4,n-1}+(2n-1)$$

$$K_{5,n}=K_{5,n-1}+(3n-2)$$

$$K_{6,n}=K_{6,n-1}+(4n-3)$$

而后，我们就可以推出

$$K_{m,n}=K_{m,n-1}+(m-2)n+(3-m)$$


而后，《混凝土数学》给了我们一个可能的解，即

$$K_{m,n}=1+n(3-m)+\frac{n^2+n}{2}(m-2)$$

打表发现，它比递推式给出的答案统统大 $1$。于是，我们就给出正确结果，即

$$K_{m,n}=n(3-m)+\frac{n(n+1)}{2}(m-2)$$

现在给出 $k$，我们要找出 $K_{m,n}$。由于式子中有一个公共因子 $n$，那么我们可以考虑通过枚举 $n$ 来找 $m$。

现在，我们就有

$$k=n\left(\frac{1}{2}(n+1)(m-2)+(3-m)\right)$$

而后，我们就有

$$\frac{k}{n}=\frac{1}{2}(n+1)(m-2)+(3-m)$$

$$\frac{2k}{n}=(n+1)(m-2)+6-2m$$

现在我们将式子拆开

$$\frac{2k}{n}=nm+m-2n-2+6-2m$$

而后选 $m$ 为主元，然后合并同类项

$$\frac{2k}{n}=m(n-1)+4-2n$$

$$\frac{2k}{n}+2n-4=m(n-1)$$

$$\frac{2k+2n^2-4n}{n}=m(n-1)$$

$$m=\frac{2(n^2-2n+k)}{n(n-1)}$$

好！我们拿到了最终的式子 ~~（以三个多小时的代价）~~，那么我们就得到了算法核心，即判断分母取余分子是否为 $0$。

那么答案怎么判呢？

由于我们要求出答案从小到大，因此我们可以将其压入优先队列并取其前两项即可。注意是大根堆。

另外，注意对 $2$ 边形的特判和对 $k=1$ 的特判。

代码如下。

```cpp
#include <iostream>
#include <cmath>
#include <queue>
#define int long long
using namespace std;
signed main(){
    int t;
    cin>>t;
    while(t--){
        int k;
        priority_queue<int,vector<int>,greater<int>> anss;
        cin>>k;
        if(k==1){
            cout<<3<<" "<<4<<endl;
            continue;
        }
        for(int n=k;n>=2;n--){
            if((2*(k+n*n-2*n))%(n*(n-1))==0){
                if((2*(k+n*n-2*n))/(n*(n-1))!=2) anss.push((2*(k+n*n-2*n))/(n*(n-1)));
            }
        }
        if(anss.size()==0) cout<<"Poor "<<k<<endl;
        else if(anss.size()==1) cout<<anss.top()<<endl;
        else cout<<anss.top()<<" ",anss.pop(),cout<<anss.top()<<endl;
    }
    return 0;
}
```

**EOF**

---

## 作者：hanzhongtlx (赞：2)

~~找规律好题~~   

我们观察下表发现第 $i$ 个 $k+2$ 边形数为 $k\dfrac{i(i-1)}{2}+i$ 。 

我们首先考虑把 $i$ 解出来： 

化简可知：  

$$i=\dfrac{k-2+\sqrt{k^2+(8N-4)k+4}}{2k}$$  

想法 $1:$  

首先保证根号下是整数，然后在保证相除仍为整数。  

具体做法？ 

枚举 $k$，然而易知 $k_{max}$ 是 $\mathcal O(N)$ 级别的，会炸掉。 

想法 $2:$ 

直接枚举 $i$ 的取值，  

由于三角形数通项公式很容易得到是： 

$$S_i=\dfrac{i(i+1)}{2}$$  

作为最小的多边形数，$i$ 的取值就被限制在 $\mathcal O(\sqrt{N})$ 级别内，不会炸掉。 

更进一步来说，我们与其用 $k$ 来表示 $i$ ，不如用 $i$ 表示 $k$。 

易得： 

$$k=\dfrac{2(N-i)}{i(i-1)}\;\;\;(i>2)$$  
   
当然 $i=1$ 的情况（即 $N=1$ ）我们可以特判一下。  

为了容易比较我们可以计算该函数的单调性，对其求导可知： 

$$k'=\dfrac{-2i(i-1)-2(N-i)(2i-1)}{(i(i-1))^2}<0$$  

易知该函数单调递减，所以从大（大概是从 $\mathcal O(\sqrt{2n})$ 左右开始枚举，注意始终保证 $N-i>0$）到小（不能取 $1$）枚举 $i$找到两个合法的就行了。  

总的时间复杂度是 $\mathcal O(T\sqrt{N})$。 

### $\mathcal {Code:}$(可能略微难看，见谅)

```
#include"iostream"
#include"cstdio"
#include"cmath"
using namespace std;

#define read(x) scanf("%d",&x)

int n,x;
int k1,k2;

int main()
{
	read(n);
	while(n--)
	{
		k1=0,k2=0;
		read(x);
		if(x==1){printf("3 4\n");continue;}
		for(int i=sqrt(2*x)+1;i>=2;i--)
		{
			if(x<=i) continue;
			if(2*(x-i)%(i*(i-1))==0)
			{
				if(!k1) k1=2*(x-i)/(i*(i-1))+2;
				else
				{
					k2=2*(x-i)/(i*(i-1))+2;
					break;
				}
			}
		}
		if(!k1) printf("Poor%d\n",x);
		else if(!k2) printf("%d\n",k1);
		else printf("%d %d\n",k1,k2);
	}
	return 0;
} 
```  

看都看了，给个赞再走呗>_<!!!

---

## 作者：reclusive (赞：1)

[my blog](https://www.cnblogs.com/reclusive2007/p/17742635.html)

## 题目描述

给你一个正整数数 $n$，问你它是不是多边形数 $K$，如果是，设 $K_1$ 是最小的 $K$，$K_2$ 是次小的 $K$，输出 $K_1$ 和 $K_2$。

## 具体思路

![image](https://cdn.luogu.com.cn/upload/image_hosting/1er3ynjt.png?x-oss-process=image)

我们主要来看上面这张表里有什么规律。

- 性质 1：$1$ 是任何一个多边形数。

- 性质 2：$2$ 不是任何一个多边形数。

- 性质 3：除了 $1$ 和 $2$ 以外任意的正整数 $n$ 都是一个 $n$ 边形数。

- 性质 4：初中数学老师告诉过我，对于一个数列里的相邻两项关系一般满足函数关系。因此我们来看看相邻两项之间的变化量。

**三角形数：** $2,3,4,5 \ldots$，

**四边形数：** $3,5,7,9 \ldots$，

**五边形数：** $4,7,10,13 \ldots$，

**六边形数：** $5,9,13,17 \ldots$，

我们发现这些变化量之间的差是相同的，是一个等差数列，那也就是满足一次函数关系。

**三角形数：** $y=x+1$，

**四边形数：** $y=2x+1$，

**五边形数：** $y=3x+1$，

**六边形数：** $y=4x+1$，

因此对于任意的正整数 $n$，变化量满足一次函数关系：$y=(n-2)x+1$，其中 $n>2$。

那我们有了变化量之间的关系，就可以来表示上表中的任意一个数。

设我们求的是 $n$ 边形数中的第 $m$ 个数 $x$。

$$x=1+\sum_{i=1}^{m-1}((n-2) \times i+1)$$

$$x=1+(m-1) +\sum_{i=1}^{m-1}(n-2) \times i$$

$$x=m +(n-2) \times \sum_{i=1}^{m-1} i$$

$$x=m +(n-2) \times \frac{m(m-1)}{2}$$

$$x=m \times (1+\frac{(n-2)(m-1)}{2})$$

我们将每次询问的数 $x$ 拆成两个数相乘的形式，那我们枚举 $x$ 的每个因数 $m$ 不就完了吗？

你先别急，我们来看样例。

样例中，$x=36,n=3,m=8$。

然后惊人的发现 $8$ 居然不是 $36$ 的因数，是我们式子推错了吗？

别急着把草稿擦掉，我们来思考为什么会这样。

原因就是一开始我们计算等差数列的和时，我们是除以了一个 $2$，然而这个 $2$ 有可能是 $m$ 给的，因此我们直接将 $m$ 提出来就会导致里面那坨东西是一个分数。

那我们怎么办啊？简单，去分母呗，即等式两边同时乘以一个 $2$。

$$2x=m \times 2 \times (1+\frac{(n-2)(m-1)}{2})$$

$$2x=m \times (2+(n-2)(m-1))$$

那么现在就可以放心大胆的去枚举 $2x$ 的因数 $m$ 了。

由于题目求的是最小的 $n$，因此我们要从大到小开始枚举 $m$。

时间复杂度：$O(T \sqrt n)$

## 注意

- 别忘了我们一开始推出来的性质 1 和性质 2，要记得特判。

- 由于我们枚举因数只枚举到 $\sqrt x$，因此有可能不满两个多边形数，这时候要用上性质 3，直接输出 $x$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;scanf("%d",&t);
	while(t--){
		int n;scanf("%d",&n);
		if(n==1){
			puts("3 4");
			continue;
		}
		if(n==2){
			puts("Poor2");
			continue;
		}
		int ans=0,res=0;
		n=n*2;
		for(int i=sqrt(n);i>=3;i--){
			if(n%i==0){
				if((n/i-2)%(i-1)==0){
					if(!ans)ans=(n/i-2)/(i-1)+2;
					else if(!res){
						res=(n/i-2)/(i-1)+2;
						break;
					}
				}
			}
		}
		if(ans&&res){
			printf("%d %d\n",ans,res);
		}
		if(ans&&!res){
			printf("%d %d\n",ans,n/2);
		}
		if(!ans){
			printf("%d\n",n/2);
		}
	}
	return 0;
}
```

---

## 作者：Miyamizu_Mitsuha (赞：1)

水蓝一道。

首先自然是找规律，观察给的一张表，着手思考每一列的规律。不难发现，第 $k$ 列每一列的基数是 $k$，且每一列增加的数会是 $\frac{k\times (k-1)}{2}$。那么增加了几个呢，三角形数增加了 $1$ 个，正方形数增加了 $2$ 个，所以发现 $n$ 边形数增加 $n-2$ 个。那么 $n$ 边形，第 $k$ 个数的公式就呼之欲出了。

$$
k+(n-2)\times \frac{k\times (k-1)}{2}
$$

所以暴力考虑枚举 $n,k$，t 飞了，得分 30。

```
#include <stdio.h>
#include <iostream>
using namespace std;
int main(){
  int t;
  cin>>t;
  while(t--)
  {
    int n,s=0,flag=0;
    cin>>n;
    for(int i=3;i<=10000;i++)
    {
      for(int k=1;k<=10000;k++)
      {
        if(n==k+(i-2)*k*(k-1)/2)
        {
          flag=1;
          cout<<i<<" ";
          s++;
        }
        if(s==2)goto q;
      }
    }
    q:
    if(flag==0)cout<<"Poor"<<n<<endl;
    else cout<<endl;
  }
return 0;
}
```

思考做一步优化，想到边数必然是整数，所以想到一种取巧的办法，可以枚举 $k$，判整除来做啊！先弄一下式子，化为可以判整除的形式（$n_2$ 是答案的 $n$，$n$ 是输入的 $n$）：

$$
\begin{aligned}
n &=k+(n_2-2)\times \frac{k\times (k-1)}{2} \\
n-k &= (n_2-2)\times \frac{k\times (k-1)}{2} \\
n_2-2&=\frac{n-k}{\frac{k\times (k-1)}{2}}
\end{aligned}
$$

所以我们只需要判定 $n-k$ 是否整除 $\frac{k\times (k-1)}{2}$，输出的时候再加上 $2$ 即可。复杂度 $O(T)$。

还要注意几个小细节：

- 要倒序循环，因为要求结果从小到大输出。


- 倒序循环的下限一定是 $2$，如果是 $1$ 的话，由于有 $k-1$ 这个式子，就会出现模 $0$ 的情况导致 re。所以还要特判一个 $1$。


- 边数计算完不能是负数，并且 $n$ 一定要大于 $k$，所以输出加几个特判就好了。



```
#include <stdio.h>
#include <iostream>
using namespace std;
int main(){
  int t;
  cin>>t;
  while(t--)
  {
    int n,s=0,flag=0;
    cin>>n;
    if(n==1){
      cout<<3<<" "<<4;
      flag=1;
      goto q;
    }
    for(int k=400;k>=2;k--)//实测可以
    {
      if((n-k)%(k*(k-1)/2)==0&&n>k&&(n-k)/(k*(k-1)/2)+2>2)
      {
        cout<<(n-k)/(k*(k-1)/2)+2<<" ";//一定别忘了加回来2
        flag=1;
        s++;
        if(s==2)goto q;//找到两个就退出循环，这里千万不能写成break
      }
    }
    
    q:
    !flag?cout<<"Poor"<<n<<endl:cout<<endl;
 
  }
return 0;
}
```



---

## 作者：int08 (赞：1)

## 前言
这是我的第一篇题解，一来就写蓝题

~~好家伙，这还是我做出的第一道蓝题呢！~~
# 解决
先上伪代码：

```cpp
cin>>ng;
for(i=1;i<=ng;i++) cin>>n[i];
for(i=1;i<=ng;i++)
{
	（特判）
	for(j=3;j<=n[i];j++)
	{
		if(n[i]是j边形数) （输出细则）
	}
	cout<<endl;
}
```
## 1.特判

阅读题目，我们容易发现，任何大于等于 $3$ 的正整数 $n$ ，都必然是 $n$ 边形数。同时 $1$ 是 $3$ 边形和 $4$ 边形数比较特殊，建议特判。

所以只有 $2$ 和非正整数需要特判Poor。只有 $1$ 需要特判 $3$ 和 $4$ 。

## 2.输出细则

在循环到每一个 $n[i]$ 的时候，定一个变量 $pp$ 来计算 $n[i]$ 已经输出的多边形数数量，并初始化为 $0$ 。

每输出一次，$pp+1$。

当 $pp$ 到达 $2$ 的时候退出循环，输出换行，开始计算下一个 $n[i]$ 。

## 3. （重点）$N[i]$ 是不是 $j$ 边形数

大多数人都是按照表格一列一列考虑的，但我按行考虑。

![](https://cdn.luogu.com.cn/upload/pic/1743.png)

**我们可以发现所有第 $x$ 个 $j$ 边形数，其数都是下面这一串数列的和：**

$1$ , $1+(j-2)$ , $1+2(j-2)$ , $1+3(j-2)$ , $1+4(j-2)$ …… $1+(x-1)(j-2)$

**这不就是等差数列求和公式吗！**

该数列首项为 $1$ ，末项为 $1+()(j-2)$，项数为 $x$ 。

所以你们就知道第 $x$ 个 $j$ 边形数是什么了：

$(2+(x-1)*(j-2))*x/2$

化简成以 $x$ 为主元的一元二次式，

$((j-2)*x^2+(4-j)*x)/2$

这个式子如果等于 $n[i]$,则 $n[i]$ 是 $j$ 边形数。

就是 $((j-2)*x^2+(4-j)*x)/2=n[i]$

再次化简为以 $x$ 为主元的一元二次方程：

$(j-2)*x^2+(4-j)*x-2*n[i]=0$

由于 $j$ 和 $n[i]$ 在当前循环中都是已知量，可以用一元二次方程求根公式算出 $x$。

如果 $x$ 不是整数，会向下取整，那么 $((j-2)*x^2+(4-j)*x)/2$ 不等于 $n[i]$ ，我们就能得出 $n[i]$ 不是 $j$ 边形数。

如果 $x$ 是整数，那么 $((j-2)*x^2+(4-j)*x)/2=n[i]$ ，我们就能得出 $n[i]$ 是 $j$ 边形数。

综上所述，我们可以在时间复杂度为 $O(1)$ 中算出 $n[i]$ 是不是 $j$ 边形数。

所以最后代码（已经AC）如下:

```
#include<bits/stdc++.h>
using namespace std;
long long ng,n[101],i,j,x,pp; 
int main()
{
	cin>>ng;
	for(i=1;i<=ng;i++) cin>>n[i];
	for(i=1;i<=ng;i++)
	{
		pp=0;
		if(n[i]<1||n[i]==2)
		{
			cout<<"Poor"<<n<<endl;
			continue;
		}
		if(n[i]==1)
		{
			cout<<"3 4"<<endl;
			continue;
		} //特判1，2，非正整数。
		for(j=3;j<=n[i];j++)
		{
			x=(j-4+(long long)(sqrt((4-j)*(4-j)+8*(j-2)*n[i])))/2/(j-2);	//根据n[i]和j计算当前项数x。
			if(x*((j-2)*x-j+4)/2==n[i]) //根据x和j反推是否等于n[i],即验证n[i]是不是j边形数。
			{
				cout<<j<<" ";
				pp++;
				if(pp==2) break;
			}
		}
		cout<<endl;
	}
   return 0;
}
```

---

## 作者：psk011102 (赞：1)

显然这是道数学题。

第n个正k边形公式如下：

A（n,k）=[n\*(n+1)+(k-3)\*n\*(n-1)]/2

A（n,k）= {n\*[(k-2)\*(n-1)+2]}/2

代码如下：

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,a;
int read(int &x){
    x=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
```
}//快读
```cpp
void found(int a){
    if(a==1){
            cout<<3<<" "<<4<<endl;
        }//1时要特判一下 
   else if(a<3){
        cout<<"Poor"<<a<<endl;
        }//2肯定不是正多边形数 
    else{
        bool d=false,e=false;//判断该数是否已经是某数的正n边形数； 
       int b=0,c=0,num;
        for(int i=3;i<=a;i++){
            for(int j=1;j<=1400;j++){ 
            num=j*(j+1)+(i-3)*j*(j-1);//避免整除出错，所以不除以2 
            if(num==2*a){//这里要记得原数乘2 
                if(d==false){
                    b=i;
                    d=true;
                }
                else if(d==true&&e==false){
                    c=i;
                    e=true;
                }
            }
            else if(num>2*a){
                break;
            }    
            }
            if(d==true&&e==true)break;//判断是否已有2个满足条件的数出现 
        }
        if(d==true&&e==false){
            cout<<b<<endl;
        }
        if(d==true&&e==true){
            cout<<b<<" "<<c<<endl;
        }
        else if(d==false&&e==false)
               cout<<"Poor"<<a<<endl;
```
}//按题目条件输出
```cpp
}
int main(){
    read(n);
    while(n--){
        read(a);
        found(a);
    }
    return 0;
}
```

---

## 作者：sahdsg (赞：1)

第一次做题...花了3小时...还可以看到我中间错了4次(第五次都还有点小问题) = =


先提前把1特值出来输出"3 4"

然后看到至少是三角形，第二个x边形数是x，所以小于3的数全部输出poor

由等差数列内容

\[{a\_n} = n{a\_1} + \frac{{n(n - 1)}}{2}d\]

最下面的表可以推出x角形数等差数列通项公式

\[{N\_n} = n + \frac{{n(n - 1)(x - 2)}}{2}\]

得
\[x = \frac{{2N + 2{n^2} - 4n}}{{{n^2} - n}}\]

然后 \[{N\_n} 能被 n 整除

同时约掉n

\[x = \frac{{\frac{{2N}}{n} + 2n - 4}}{{n - 1}}\]

求出所有2N的因子，舍去1(1会导致除以0，所以提前输出)

然后代入求x，放进一堆答案里面，因为只要两个答案

所以就先输出1个，再看有没有下一个，再输出下一个


可能有部分还是错的，但是过了，于是就不继续想了...


---

## 作者：__Star_Sky (赞：0)

## Solution

观察题面给出的表格。首先观察“三角形数”这一行，结合题目描述给出的图，容易发现，每一次后面的数减去前面的数的差都增加了 $1$。将差分序列写出来，就是
$$1,2,3,4,5\dots$$
这提示我们或许可以在差分序列上发掘性质。

再将正方形数差分序列写出来：
$$1,3,5,7,9\dots$$
五边形数：
$$1,4,7,10,13$$

性质已经逐渐浮出水面了：$n$ 边形数列的第 $k$ 项就是以 $n-2$ 为公差的等差数列的前 $k$ 项的和！

设当前给出的数为 $n$。假设 $n$ 是 $t$ 边形数，那么一定有 $n=k\times[1+(k-1)\times(n-2)+1]/2$，等式右边表示以 $t-2$ 为公差的等差数列前 $k$ 项的和。化简一下，得到 $\frac{2n}{k}+2k-4=(k-1)\times t$。容易发现，$k$ 一定是 $2n$ 的约数，只需再 $\sqrt{n}$ 的时间内枚举 $k$，逐个判断 $k-1$ 是否整除 $\frac{2n}{k}+2k-4$。如果整除，就得到了其中一个答案 $t=\frac{\frac{2n}{k}+2k-4}{k-1}$。如果有多个 $t$ 取最小的两个即可。注意  $n=1$ 的情况要特判一下，否则可能出现除以 $0$ 的情况。

## Code
```
#include<bits/stdc++.h>
using namespace std;
int ans[110];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int cnt=0;
		int n;
		scanf("%d",&n);
		if(n==1) {puts("3 4");continue;}
		n*=2;
		for(int i=2;i*i<=n;i++)
		{
			if(n%i!=0) continue;
			int k=i,t=n/k+2*k-4;
			if(t%(k-1)==0&&t/(k-1)>2) ans[++cnt]=t/(k-1);
			if(n/i==i) continue;
			k=n/i,t=n/k+2*k-4;
			if(t%(k-1)==0&&t/(k-1)>2) ans[++cnt]=t/(k-1);
		}
		if(!cnt) printf("Poor%d\n",n/2);
		else if(cnt==1) printf("%d\n",ans[1]);
		else
		{
			sort(ans+1,ans+cnt+1);
			printf("%d %d\n",ans[1],ans[2]);
		}
	}
	return 0;
}
```

---

## 作者：L_S_ (赞：0)

~~这道题实话实说，3min切了。~~

## 题意
给出一个数 $k$ ，判断是否是多边形数。如果是，输出符合要求的最小的两个多边形数，如果没有则输出一个；否则，输出"Pool"+该数。

## 思路

这道题我其实是考虑列表中行的规律来解决的(当然考虑列也可以):

![6](https://cdn.luogu.com.cn/upload/pic/1743.png)

我们可以通过观察每一行的数据，发现 $n$ 边形数的第一项永远是 $1$ ，第二项就是 $n$ ，即为 $ 1+( n-1) $ ，第三个数就是 $ 1+n-1+(n-1+(n-2)) $ ， 第四个数是 $ 1+n-1+n-1+(n-2)+(n-1+(n-2) \times (i-2)) $ ......

以此类推， $n$ 边形数的 $a[1]$ 是 $1$ ， $a[2]$ 是 $n$ ， $a[i]$ 就是 $(a[i-1]+(n-1+(n-2) \times (i-2)))$ 。

根据上面可得每两个数的公差每次增加 $(n-2)$ ，我们只需要用一个变量控制公差就行了。


## AC代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
void solve()
{
	int n;
	cin>>n;
	if(n==1) 
	{
		cout<<"3 4"<<endl;
		return ;
	} 
	int now=1,gs;
	bool flag=false;
	for(int i=3;i<=n;i++)
	{
		gs=i-1;
		now=1;
		while(now<=n)
		{
			if(now==n)
			{
				cout<<i<<' ';
				if(!flag)
					flag=true;
				else
				{
					cout<<endl;
					return ;
				}
			}
			now+=gs;
			gs=gs+(i-2);
		}
	}
	if(!flag) cout<<"Poor"<<n;
	cout<<endl;
	return ;
}
int main()
{
	int t;
	cin>>t;
	while(t--) solve();
	return 0;
 } 
```

---

## 作者：封禁用户 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2674)

# 题意

定义 $x$ 边形数 $n$ 指的是将 $n$ 个圆点排列后，可以组成一个实心 $x$ 边形，求一个数 $n$ 是哪两个最小 $x$ 的 $x$ 边形数。

# 思路

题目都说了，找规律，那就找呗。

![](https://cdn.luogu.com.cn/upload/pic/1743.png)

一开始，从行看没啥规律，就从列看，就发现规律了，第 $i$ 列相邻两个数之间差 $\frac{i \times (i-1)}{2}$，于是便有了以下要求。

1. $(n - i) \bmod (\frac{i \times (i-1)}{2}) = 0$

2. $x = (n - i) / (\frac{i \times (i-1)}{2}) + 2$

第一个式子好理解，就是他一定在这一列上，第二个式子可以算出他在这列的第几排，再 $+2$ 就可以算出 $x$ 了。

# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
ll T, n, f, s;
il ll sum(ll x){
	return x * (x - 1) >> 1;
}
int main(){
	scanf ("%lld", &T);
	while (T--){
		scanf ("%lld", &n);
		if (n == 1){
			puts("3 4");
			continue;
		}
		if (n == 2){
			puts("Poor2");
			continue;		
		}
		f = s = 0;
		for (int i = 2; sum(i) + i <= n; i++){
			ll k = n - i;
			if (k % sum(i)) continue;
			ll kkk = k / sum(i) + 2;
			if (kkk < 3) continue;
			if (f == 0 || kkk < f) s = f, f = kkk;
			else if (s == 0 || kkk < s) s = kkk;
		}
		if (f) printf ("%lld ", f);
		if (s) printf ("%lld ", s);
		puts("");
	}
	return 0;
}

```

---

## 作者：xkcdjerry (赞：0)

神秘推/猜式子题：
![](https://cdn.luogu.com.cn/upload/pic/1743.png)

从行考虑：  
首先由于是平面图形，盲猜是一个二阶多项式，联想使用求导来求连续二次多项式的式子，考虑使用差分来求离散二次多项式的式子：（为了直观在每种数的第 $0$ 位插入了一个 $0$）
* 三角形数的差分结果：`1 2 3 4 5 6 7 8`
* 正方形数的差分结果：`1 3 5 7 9 11 13 15`
* 五边形数的差分结果：`1 4 7 10 13 16 19 22`
* 六边形数的差分结果：`1 5 9 13 17 21 25 29`

显然，$k(k \geqslant 3)$ 边形数差分后为首项为 $1$，公差为 $k-2$ 的等差数列。又由于 $k$ 边形数的第 $n$ 个即为差分后前 $n$ 项的和，所以 $k$ 边形数的第 $n$ 个数 $f(n,k)$ 为：
$\frac{1}2(1+(n-1)(k-2)+1) \times n$  
$=\frac{1}2n(2+(n-1)(k-2))$  
$=n+\frac{1}2(k-2)n(n-1)$

由于 $k \geqslant 3$，所以对于任何一个数 $v$ **只有约 $\sqrt{2v}$ 个 $n$ 可能与其对应**。  

又因为 $v \leqslant 10^6$，所以每次询问最多只需要枚举约 $1410$ 个 $n$。而确定 $n$ 后原式即为关于 $k$ 的一次函数，显然可用 $O(1)$ 时间解决。总复杂度为 $O(T \sqrt n)$，$T \leqslant 100$ 所以可轻松通过。  

**特别注意：**  
由于 $n=2$ 时 $f(n,k)=k$ 且 $k \leqslant 3$，所以只有 $1,2$ 无法通过 $n=2$ 取到，而其中 $v=1$ 的时候 $n=1$ 时可取到，即只有 $v=2$ 无解而 $v=1$ 的时候两个解都在 $n=1$，这两个需要特判输出。

代码：
```c++
#include <cstdio>
int T,v,n;
int a[1010],top;
int main()
{
    for(scanf("%d",&T);T--;)
    {
        scanf("%d",&v);
        if(v==2) {printf("Poor%d\n",v);continue;}
        if(v==1) {puts("3 4");continue;}
        for(top=0,n=2;n*(n+1)/2<=v;n++) if(!((v-n)%(n*(n-1)/2)))
            a[top++]=(v-n)/(n*(n-1)/2)+2;
        if(top>=2) printf("%d %d\n",a[top-1],a[top-2]);
        else printf("%d\n",a[top-1]);
    }
}
```

[AC 记录](https://www.luogu.com.cn/record/83034191)

---

## 作者：dsyfb_437 (赞：0)

# Solution
首先看这个表

![problem](https://cdn.luogu.com.cn/upload/pic/1743.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/wova09vj.png)

先横向观察可以发现，对于每一个多边形数，相邻两项的差有些规律：（以三角形数为例）

$$\begin{aligned} a_2-a_1 & = 2 \\ a_3-a_2 & = 3=2+1 \\ a_4-a_3 & = 4=2+2\times1 \\ a_5-a_4 & = 5=2+3\times1 \\ &\dots \end{aligned}$$

其实，相邻两项的差是等差数列，那么原数列 $a_1,a_2,a_3,\dots$ 是一个二阶等差数列，第 n 项应为首项加上 2 至 n 项与前一项的差的总和，即，

$$\begin{aligned} a_2-a_1 & = k \\ a_3-a_2 & = k+d \\ a_4-a_3 & = k+2\times d \\ a_5-a_4 & = k+3\times d \\ &\dots \\ a_n-a_{n-1} & = k+(n-2)\times d \end{aligned}$$

然后将上式相加，得到通项公式：
$$\begin{aligned} a_n&=a_1+k\times(n-1)+(1+2+3+\ldots+n-2)\times d \\ &= a_1+k\times(n-1)+\frac12\times(1+n-2)\times(n-2)\times d \\ &= a_1+(n-1)\times[k+\frac12\times(n-2)\times d] \end{aligned}$$

设边数为 m，观察表中数据可知，$a_1=1$，$k=m-1$，$d=m-2$

$$a_n=1+\frac12\times(n-1)\times[m-1+m-1+(n-2)\times(m-2)]$$

-----

再有一些小细节

- 非多边形数只有 2 一个

- 在知道了第 n 个正 m 边形数后，只要在拿输入的数与之比较就可以了（详见代码）

- 注意输出格式（当边数只有一个时，后面不要加空格）

-----

代码

```cpp
#include <iostream>
using namespace std;

void check(int x)
{
    if (x == 2)
        cout << "Poor2";
    if (x == 1)
        cout << "3 4";
    int flag = 0, b = 1;

    for (int m = 3; m <= x; ++m)
    {
        //m边形  第n项
        int n = 0, tmp = 0;
        while (tmp < x)
        {
            n++;
            int tmp = 1 + (m - 1 + m - 1 + (m - 2) * (n - 1)) * n / 2; //第n-1项
            if (tmp == x)
                b = 0, flag++, cout << m;
        }
        if (flag == 2)
            break;
        if (!b)
            cout << ' ', b = !b;
    }
}

int main()
{
    int ng, N;
    cin >> ng;
    for (int i = 1; i <= ng; ++i)
    {
        cin >> N;
        check(N);
        cout << endl;
    }
    return 0;
}
```



---

## 作者：Scrutiny (赞：0)

找规律题。

假设第 $k$ 个 $n$ 边形数是 $a_{n,k}$。

容易得到 $a_{n,k}-a_{n,k-1}=1+(n-2)(k-1)$

故 

$$a_{n,k}=a_{n,1}+k-1+(n-2)\sum\limits_{i-1}^{k-1}i=k+\dfrac{k(n-2)(k-1)}{2}$$

$n=\dfrac{a_{n,k}-k}{\frac{k(k-1)}{2}}$

由于 $n\ge 1$，$k\le \sqrt{2a_{n,k}}$。

显然随着 $k$ 变小，$n$ 变大。

为了使 $n$ 尽可能小，我们从大到小枚举 $k$ 即可。

CODE:

```cpp

#include<bits/stdc++.h>
using namespace std;
int t,cnt;
long long n,tmp,ans1,ans2;
int main(){
	std::ios::sync_with_stdio(0);
	cin>>t;
	for(int i=1;i<=t;++i){
		cnt=0,tmp=2,ans1=0,ans2=0;
		cin>>n;
		if(n==1){
			printf("3 4\n");
			continue;
		}
		if(n==2){
			printf("Poor2\n");
			continue;
		}
		for(int k=sqrt(n);k>=1;--k){
			if((x-k)%(k*(k-1)/2)==0){
				if(ans1){
					ans2=(x-k)%(k*(k-1)/2)+2;
					break;
				}
				else{
					ans1=(x-k)%(k*(k-1)/2)+2;
				}
			}
		}
		if(ans2){
			printf("%lld %lld\n",ans1,ans2);
		}
		else{
			printf("%lld\n",ans1);
		}
	}
	return 0;
}

```

---


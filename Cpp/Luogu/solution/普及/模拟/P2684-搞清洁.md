# 搞清洁

## 题目描述

FJ准备分配它的N只奶牛(1 <= N <= 25,000) 做清洁工作，他把一天分成T(1 <= T <= 1,000,000)个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。


## 说明/提示

样例解释：

有3头奶牛，第1头能工作的时间段是1至7，即从时间1开始工作，时间7结束（时间7也在工作的），第2头是3-6，第3头是8-10，则只需要第1头和第3头奶牛就能使每一个时间都有奶牛工作。


## 样例 #1

### 输入

```
3 10
1 7
3 6
8 10
```

### 输出

```
2

```

# 题解

## 作者：PTC06 (赞：24)

此题只要理解思路，就可以做出来的。只不过初次提交时有很多点RE。后来发现原因在于数组定义的不够大。=\_=


思路如下：


首先，让我们从样例分析。样例是：


3 10 1 7 3 6 8 10 那么我的解题思路是：首先输入N和T，然后输入每头牛可以工作的时间是从哪个时间段到哪个时间段。那么我们用数组a来标记每头牛的时间段，我用数组a的下标来表示开始时间，而a[i]中的数就是牛的结束时间。



 ![](https://cdn.luogu.com.cn/upload/pic/3121.png) 

如图所示，a[1]是7， a[3]是6，a[8]是10. 注意，输入时需要去重，也就是当有两头或以上的牛的开始时间一样时，就需要判断哪头牛的结束时间更晚（也就是工作时间长的那头），把a中的元素更新。接下来，a的元素弄好了，也就到了重点了。这里需要定义两个变量——start和end，用处下面会讲。下面是部分程序。


```cpp
    for (i=start+1;i<=end+1;i++)
    {
        if (temp<a[i]) temp=a[i];
    }
```
这里这条循环的作用是寻找下一个循环中的end，意思就是，在已经确定有牛在干活的时间段中（这个条件很重要，带来了很多便利，因为这样就不会产生有一些时间没有牛清洁的情况），继续寻找下一个该干活的牛（也就是结束时间最晚的那头）。注意这里从start+1开始，到end+1结束。加一是因为，这里的加一是因为，end+1表示已经有牛清洁的时间段的下1个时间段，如果这个时间有牛可以干活，也并不会产生没有牛清洁的情况。好了，这里解释完了，到下一个部分。下面是部分程序:

```cpp
        if (temp<end+1)
        {
            cout<<-1;
            return 0;
        }
```
这里的判断是为了判断会不会出现题目中说的 “不可能”情况。也就是如果这一段中的最晚结束时间都还没有到需要清洁的时间，那么显然就不可能完成清洁了。好了，下一步，还是先上部分程序：
   start=end;

   end=temp;

   sum++;

这里就是很明显的更新了。把start变成原来的end，而下一轮的end又变成此时的最晚结束时间。


下面是AC程序。


```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
int n,m,i,t,t1,a[1000000],temp,start,end,sum;         //注意a需要定义到一百万，也就是T的范围。一开始脑抽定义了N的范围，也就是25000，结果一直RE找不出错。
int main()
{
    cin>>n>>m;
    for (i=1;i<=n;i++)
    {
        cin>>t>>t1;            //输入
        if (a[t]<t1) a[t]=t1;                       //标记每一个牛的开始和结束时间。
    }
    while (temp<m)            //凡是temp<m，也就是总共需要清洁的那t个时间段，就继续.
    {
        for (i=start+1;i<=end+1;i++)
        {
            if (temp<a[i]) temp=a[i];                 //如上面的解释，找结束时间最晚的那头。
        }
        if (temp<end+1)                       //判断是否不可能。
        {
            cout<<-1;
            return 0;
        }
        start=end;               //更新
        end=temp;
        sum++;
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：一扶苏一 (赞：10)

### 说模拟的几篇题解，算法复杂度上界达到了$O(Tn)$，过得去是数据水……

### 这里有一种线段树写法

看到题面，我们第一反应是考虑DP，设$f_{i,j}$为前$i$头牛确定到时间$j$的最少的牛的数量。分析下复杂度发现炸了，状态是$O(Tn)$，转移需要枚举这头牛覆盖的时间，上界是$O(T)$，总的复杂度是$O(T^2~\times~n)$，显然会原地爆炸的说。

显然需要按照右断点升序排序。下面给出朴素的状态转移方程：

$f_{i,j}=max${$f_{i-1,k}$}$+1$，其中$k~\in~[l_i-1,r_i]$。

考虑我们是怎么转移的。这样转移的话，我们设第$i$头牛的左右时间分别是$l_i$,$r_i$，这样我们需要求出区间$[l_i-1,r_i]$的最小值进行转移。考虑优化这一段转移，我们可以用一颗线段树维护这段区间中dp的最小值。这样复杂度降低到$O(T~\times~n~\times~logT)$。接着考虑优化，我们存在$O(T)$的复杂度是因为我们对于每个区间都要从它的左端点改到右端点。但事实上完全不需要这么修改，而只需要修改它的右断点即可。这样修改的复杂度降低到$O(1)$，总复杂度$O(nlogT)$，可以通过本题的极限数据。

### 下面是对只修改右端点的证明:

我们将DP的含义改为设$f_j$为统计到时间j的最少的牛的个数。这样的转移方程将可以表示为

$f_{j}=max${$f_{k}$}$+1$，其中$k~\in~[l_i-1,r_i]$，$i$代表枚举到第$i$头牛。

也就是对于每个$j$,我们会求出区间$[l_i-1,r]$的最小值，考虑我们更新左端点的值，假设左端点被包含，那么显然右断电会被包含进去，所以左端点的值存储的什么是没有意义的，dp可以直接从右断点进行转移。

### 证明完毕。

整理一下思路，我们用一颗大小是T的线段树维护到时间T的最少的牛的个数，按照右端点升序排序，对于每个区间的右断点，我们从他的左端点-1到右断点求最小值并+1作为这个时刻的值。最后判断第T时刻的值即可。

## Code
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rg register
#define ci const int
#define cl const long long int

typedef long long int ll;

namespace IO {
	char buf[100];
}

template <typename T>
inline void qr(T &x) {
	char ch=getchar(),lst=' ';
	while(ch>'9'||ch<'0') lst=ch,ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	if(lst=='-') x=-x;
}

template <typename T>
inline void write(T x,const char aft,const bool pt) {
	if(x<0) {putchar('-');x=-x;}
	int top=0;
	do {
		IO::buf[++top]=x%10+'0';
		x/=10;
	}while(x);
	while(top) putchar(IO::buf[top--]);
	if(pt) putchar(aft);
}

template <typename T>
inline T mmax(const T _a,const T _b) {if(_b<_a) return _a;return _b;}
template <typename T>
inline T mmin(const T _a,const T _b) {if(_a>_b) return _b;return _a;}
template <typename T>
inline T mabs(const T _a) {if(_a<0) return -_a;return _a;}

template <typename T>
inline void mswap(T &_a,T &_b) {
	T _temp=_a;_a=_b;_b=_temp;
}

const int maxn = 25010;
const int maxt = 4000010;
const int INF = 0x3f3f3f3f;

struct M {
	int l,r;
};
inline bool cmp(const M &_a,const M &_b) {
	return _a.r<_b.r;
}
M MU[maxn];

int n,t;
int frog[maxt];

int ask(ci,ci,ci,ci,ci);
void change(ci,ci,ci,ci,ci);

int main() {
	qr(n);qr(t);
	memset(frog,0x3f,sizeof frog);
	change(0,t,1,0,0);
	for(rg int i=1;i<=n;++i) {
		qr(MU[i].l);qr(MU[i].r);
	}
	std::sort(MU+1,MU+1+n,cmp);
	for(rg int i=1;i<=n;++i) {
		change(0,t,1,ask(0,t,1,MU[i].l-1,MU[i].r)+1,MU[i].r);
	}
	int ans=ask(0,t,1,t,t);
//	for(rg int i=0;i<=t;++i) printf("%d %d\n",i,ask(0,t,1,i,i));
	if(ans==0x3f3f3f3f) ans=-1;
	write(ans,'\n',true);
	return 0;
}

void change(ci l,ci r,ci p,ci v,ci aim) {
	if(l>r) return;
	if(l>aim||r<aim) return;
	if(l==r) {frog[p]=mmin(frog[p],v);return;}
	int mid=(l+r)>>1,dp=p<<1,ddp=dp|1;
	change(l,mid,dp,v,aim);change(mid+1,r,ddp,v,aim);
	frog[p]=mmin(frog[dp],frog[ddp]);
}

int ask(ci l,ci r,ci p,ci aiml,ci aimr) {
	if(l>r) return INF;
	if(l>aimr||r<aiml) return INF;
	if(l>=aiml&&r<=aimr) return frog[p];
	int mid=(l+r)>>1,dp=p<<1,ddp=dp|1;
	return mmin(ask(l,mid,dp,aiml,aimr),ask(mid+1,r,ddp,aiml,aimr));
}
```

---

## 作者：木木！ (赞：10)

看到题，嗯，一堆线段，覆盖，离线，想都不用想思路直接跳到排序贪心乱搞。

考虑一个已经排好序的时间段组合，我们可以每次贪心，在必须要工作的时候才工作，即，如果`lr`表示必须工作的时间（即之前的最晚的`r`），仅当`li[i+1]>lr`的时候才选择这个线段进行更新。

但是有个大问题，我们无法保证这样子选出的线段是r端点最大的。也就是说，这个反例可以轻松卡掉这个暴力：

```
4 10
1 3
2 10
3 5
5 10
```

你会发现你输出3，正解是2。解决方案很简单，我们扫的时候同时更新所有合法的线段的右端点最大值。正确性易证。

最后时间复杂度，排序是$\Theta(n\log n)$，扫一遍是$\Theta(n)$，总时间复杂度$\Theta(n\log n)$。

附AC代码：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

struct seg
{
	int l;
	int r;
};

seg si[25005];

bool cmp(seg a,seg b)
{
	return a.l<b.l;
}

int main()
{
	int n,t;
	scanf("%d%d",&n,&t);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d%d",&si[i].l,&si[i].r);
	}
	
	sort(si+1,si+1+n,cmp);
	si[n+1].l = t+1;
	
	int ans = 0;
	int lr = 1;
	int mnlr = 0;
	for(int i=1; i<=n+1; ++i)
	{
		if(si[i].l > lr)
		{
			lr = mnlr+1;
			if(si[i].l > lr)
			{
				ans = -1;
				break;
			}
			mnlr = si[i].r;
			++ans;
		}
		else
		{
			if(si[i].r > mnlr)
			{
				mnlr = si[i].r;
			}
		}
	}
	
	printf("%d\n",ans);
}
```

---

## 作者：Meteorshower_Y (赞：5)

题解
这是一道~~big~~ 模拟 题，可以用贪心的思想AC

题目：

 **FJ准备分配它的N只奶牛(1 <= N <= 25,000) 做清洁工作，他把一天分成T(1 <= T <= 1,000,000)个时间段，他希望每一个时间段都有奶牛在清洁，但搞清洁的奶牛数越少越好。如果不可能则输出“-1”。**

简单来说就是给一个线段，n个区间，判断这些区间能否将线段全部覆盖，（两个区间可以相邻，比如：1-7,8-10； 也可以部分重叠，比如：1-8，5-10）

如果可以的话，求出最少需要几个区间；

如果不行的话，输出：“-1”；

怎么来做呢？

贪心的话：

1、我们可以让我们选的区间尽可能的大

（1-7，1-4，8-10，5-7）不难看出选择1-7和8-10即可,不同区间相同起点则取重点最靠后的那个

2、避免选无用的区间，即不选被其他区间包含的区间

（1-6，3-5，6-10） 3-5被1-6这个区间包含，所以不选

3、使区间在相连的情况下尽可能的靠后，即选择最优区间

（1-5，3-8，4-10，7-10）3-8和4-10都是可以和1-5相连接的，起点3、4都在1-5区间之内，而终点10比8要靠后，所以选择1-5和4-10

## Code
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
struct node{
	int l,r;
}a[25010],b[25010];
bool cmp(node a,node b)            //自定义排序规则 
{
	if(a.l<b.l) return 1;
	if(a.l>b.l) return 0;
	return a.r<b.r;
}
int n,t,nl,nr,tot,ans;
int main()
{
	scanf("%d%d",&n,&t);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].l,&a[i].r);
	sort(a+1,a+n+1,cmp);          //按照起始时间从大到小排序 
	for(int i=1;i<=n;i++)
	{
		if(a[i].r<=b[tot].r) continue;  //如果他被包含了，则不选中 
		if(a[i].l!=b[tot].l) b[++tot].l=a[i].l,b[tot].r=a[i].r; //新的起始时间且不被包含，选中 
		else if(a[i].l==b[tot].l) b[tot].r=a[i].r; //取相同起始时间中结束时间最大的 
	}
	int i=1;
	while(i<=tot&&nr<t)          //从第一个到被选中的最后一个 
	{
		int j=i;
		bool as=1;               //判断是否与上一段区间相连 
		while(j<=tot)            //取最优区间 
		{
			int l=b[j].l,r=b[j].r;
			if(l<=nr+1&&r>=nr+1)//新的左边界比当前的右边界 +1 小，新的右边界在当前右边界大 
			{
				as=0;           //表示与上端区间相连 
				j++;
			}
			else break;
		}
		if(as)                  //没有与上端区间相连，输出 -1 结束程序 
		{
			printf("-1");
			return 0;
		}
		i=j;
		ans++;
		nl=b[j-1].l,nr=b[j-1].r;     //因为当前的 j是不符合的那一个，不要忘了减一 
	}
	if(nr>=t) printf("%d",ans);      //最后仍然 不存在 没有 奶牛清洁的时间 
	else printf("-1");               //最后仍然 存在 没有 奶牛清洁的时间 
	return 0;
}
```

 **Thanks for your watching**

 **Thanks for your supporting**

---

## 作者：clyoyo (赞：4)

模拟完成这道题，开始考虑在选定一条线段，判断后一条该不该选的时候，觉得情况比较多，仔细分析后有些情况可以合并，其实只有3种情况。

下面说说我的思路：

1.读入数据后a[i],b[i]，按起点从小打到大排序，如果起点相同，终点大的排前面；

2.去除奶牛工作时间段包含的数据，留下工作时间段最大的；如 [3,10]和[5,10]去除[5,10]

3.第一只奶牛只要是从1开始一定是选的，设定已选定变量q初值=1

重点来了：对于第i只奶牛选不选，分为3种情况

（1）如果第i只奶牛的起始时间>已选定奶牛的结束时间+1(a[i]>b[q]+1)，即时间不连续，输出-1

（2）如果第i+1只奶牛的起始时间>已选定奶牛的结束时间+1(a[i+1]>b[q]+1)，说明中间有一部分时间段是由i只奶牛做的，所以第i只奶牛要选

（3）不满足（2）的情况，第i只奶牛不选

附上代码：

    
  
```cpp
var i,j,n,m,t,ans,q:longint;
    a,b:array[0..25000] of longint;
//按起点位置排序,起点相同终点后面的排前面    
procedure sort(l,r: longint);
var i,j,mid,mid2,t: longint;
begin
  i:=l;
  j:=r;
  mid:=a[(l+r) div 2]; 
  mid2:=b[(l+r) div 2];
  repeat
    while (a[i]<mid) or (a[i]=mid) and (b[i]>mid2) do inc(i);
    while (mid<a[j]) or (a[j]=mid) and (b[j]<mid2) do dec(j);  
    if i<=j then
      begin
        t:=a[i];
        a[i]:=a[j];
        a[j]:=t;
        t:=b[i];
        b[i]:=b[j];
        b[j]:=t;
        inc(i);
        dec(j);
      end;
  until i>j;
  if l<j then sort(l,j);
  if i<r then sort(i,r); 
end;
begin
  readln(n,t);
  for i:=1 to n do
    read(a[i],b[i]);
  sort(1,n);
  for i:=1 to n do  //去除线段包含的情况
    if (a[i]>=a[m]) and (b[i]<=b[m]) then
```
continue
```cpp
    else 
    begin
      inc(m);
      a[m]:=a[i];
      b[m]:=b[i];
    end;
  if (a[1]<>1) or (b[m]<t) then //第一个点特判
  begin
    writeln(-1);
    halt;
  end
  else
  begin
    ans:=1;
    q:=1;
  end;
  for i:=2 to m-1 do
    if a[i]>b[q]+1 then //该点起点大于确定点终点
    begin
      writeln(-1);
      halt;
    end
    else if (a[i+1]>b[q]+1) then //后一点起点大于确定点的终点+1
    begin
      inc(ans);
      q:=i;
    end;
  if a[m]>b[q]+1 then //最后一个点特判
  begin
    writeln(-1);
    halt;
  end
  else if m>1 then //m=1的情况特判
    inc(ans);
  writeln(ans);
end.
```

---

## 作者：honey_ (赞：2)

## 读题
  简述：在N头奶牛中找出工作时间能覆盖 $T$ 个时间段的最少数量。
## 算法
  模拟+贪心
## 具体思路
  我们的贪心策略是：将所有牛的工作时间读入并排序（以开始时间为第一关键字，结束时间为第二关键字）。   
  排序后数组第一项，也就是第一头牛是一定要使用的。   
  我们设第一头牛的开始工作时间为L,结束时间为R，那么第二头牛的左端点范围为x，且 : $L \leq b \leq R+1$

### 注：如果不能使每个工作段都有牛，就输出-1.

## 分为3种情况：  
1.排序后第一头牛不能覆盖左端点（就是第一头牛开始时间不为1） 

2.排序后最后一头牛不能覆盖右端点（就是最后一头牛结束时间小于T)

3.在贪心过程中当前一头奶牛的右端点与后一头奶牛的左端点连不上时，即 $L \leq b \leq R+1$不成立   


# Code
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define ll long long
using namespace std;
const int N=25001;
struct node{ll b,e;}d[N];  //奶牛状态
ll n,t;
bool cmp(node a,node b){return a.b==b.b?a.e>b.e:a.b<b.b;}   //排序，以开始时间为第一关键字，结束时间为第二关键字
bool begin_flag,end_flag;  //判断是否覆盖开头结尾
int main()
{
    scanf("%lld %lld",&n,&t);
    for (int i=0;i<n;i++)
    {
        scanf("%lld %lld",&d[i].b,&d[i].e);
        if (d[i].b==1) begin_flag=true;
        if (d[i].e==t) end_flag=true;    //输出-1的判断
    }
    if (!(begin_flag && end_flag)){printf("-1\n");return 0;}  //输出-1
    sort(d,d+n,cmp);
    int tot=1,pos=1,max_proc=d[pos-1].e;  // 保存奶牛数量，当前位置，当前奶牛
    while (true)
    {
        if (max_proc==t){printf("%d\n",tot);return 0;}  //到末尾了,输出并return 0;
        int next_proc=max_proc,j;  //开始贪心
        for (j=pos;j<n && d[j].b<=max_proc+1;j++) if (d[j].e>next_proc) next_proc=d[j].e;  //实现贪心
        
        if (j<n && d[j].b>next_proc+1){printf("-1\n");return 0;}  //前一个奶牛右端点与后一个奶牛左端点连不上直接输出-1并return 0;
        tot++,max_proc=next_proc,pos=j;  //修改当前位置
    }
    return 0;
 }
```


---

## 作者：icaijy (赞：1)

# 题意简述
这题简单来说，就是给你一堆线段，让你求出最少需要多少线段，可以**完全盖住**一条大的线段而**没有空隙**。

# 思路
这题是**线段覆盖**。所以用**贪心**来做。

首先把一堆奶牛排个序。**让开始时间更早的排在前面**，因为选奶牛的话要先考虑开始时间是否符合。

然后就可以开始扫描了。从第一个奶牛开始扫。向后找符合：**开始时间 $\leq$ 上一头搞清洁的奶牛结束时间 $+1$** 的奶牛。在若干个这种奶牛中，选出**结束时间更晚**的奶牛。简单来讲就是选可以**保证没有空隙**，且**尽量能晚点结束**的奶牛。

# 时间复杂度
首先排序，用 STL 排序会用掉 $\theta(n \log n)$。

从前往后扫，用掉 $\theta(n)$。

所以这个思路的时间复杂度是 $\theta(n \log n)$。这个时间复杂度可以过掉 $n \leq 10^5$ 的数据，应对本题是绰绰有余了。

# 代码
本人代码比较丑，不过这题重在理解思路，代码就当参考咯。
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct cow{
    int s,e;//结构体
};

cow a[25005];

bool cmp(cow c1,cow c2){ //结构体排序
    return c1.s<c2.s;
}

int main(){
    int n,t;
    cin >> n >> t;
    for (int i=0;i<n;i++) cin >> a[i].s >> a[i].e;//读入
    sort(a,a+n,cmp);//排序
    int e=0;
    int emax=0;
    int ans=0;
    int nn;
    bool have;
    for (int i=0;i<n;i++){//开扫
        have=false;
        for (int j=i;a[j].s<=e+1&&j<n;j++){
            have=true;
            if (a[j].e>=emax){

                emax=a[j].e;
                nn=j;
                i=j;
            }
        }
        if (have){//找到了，加一
            e=a[nn].e;
            ans++;
        }
        if (emax>=t){//结束已经超过了，直接结束
            cout << ans;
            return 0;
        }

        else if (!have){
            cout << -1;//没找到？输出负一
            return 0;
        }
    }
    cout << -1;//都扫完了肯定就输出-1了。
}
```


---

## 作者：苏黎世 (赞：1)

这个题可以说是贪心很好的一个例题，若能独自A了这个题，你的贪心就应该没有什么大问题。再加上点模拟的基础就好。

题意提取：
有n个小区间，要铺满t的大区间，要求在尽量选取少的基础上铺满，若不能输出-1。

那么有以下几点：

1、我们要选取尽量大的区间，这样保证选的尽量少。

如（1,5）和（1,10）肯定选（1,10）的。

2、有的区间可以不选的，比如一个区间会被另外两个区间完全覆盖，那么这个区间是不需选的。
如（1,5），（3,8）,（5,10）很明显（3,8）是不需要选的。

这个是重点也是难点。

3、要注意把t区间铺满。~~我好像因为这个WA了一次~~

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 25003;
const int maxt = 1e6 + 6;
int n, t;
struct data
{
    int q, z;//q是起点，z是终点
}e[maxn];

bool cmp(const data a, const data b)//排序保证区间尽量大
{
	if(a.q == b.q)
	  return a.z < b.z;
	return a.q < b.q;
}

void cini()
{
    scanf("%d%d", &n, &t);
    for(register int i = 1;i <= n; ++i)
      scanf("%d%d", &e[i].q, &e[i].z);
}

void work()
{
	sort(e + 1, e + n + 1, cmp);
	e[n + 1].q = t + 1;//超级终点 
	int ans = 0, l = 1, r = 0;
	for(register int i = 1;i <= n + 1; ++i)
    	if(e[i].q > l)//当可以更新区间时
    	{
    		l = r + 1;//保证区间紧挨不漏
    		if(e[i].q > l)//此时会有区间漏掉，所以也不行
    		{
    			puts("-1");
    			return;
    		}
    		r = e[i].z;
    		ans++;
    	}else r = max(e[i].z, r);
	printf("%d", ans);

int main()
{
    cini();
    work();
    return 0;
}
```


---

## 作者：asasas (赞：1)

其实这题不是模拟，应该是**线段合并**的小变化版本

首先，我们要按左端点从小到大排序,左端点相同的按右端点排序。

则我们设两个变量l,r分别是头指针和尾指针（$l$初始值为1，$r$为0）。扫描到第$i$头奶牛时有两种情况：

①：$a[i].l>l$

如果此时$r+1$也$<a[i].l$时，不论怎么选，中间都会有1个空隙（头指针和当前的左端点没有重合），于是输出-1.
否则，我们将$r+1$赋给$l$,$r$为$a[i].r$（因为这个点必选），并将答案+1。

②：$a[i].l<=a[i].r$

此时前面肯定ans加过1了，我们要在头指针$>=$当前奶牛的左端点时，取右端点的最大值才是最优的（能不必需取此点时，就使右端点尽可能往前）

注：需要将$a[n+1].l$设为$t+1$，否则有可能t这个点没取到也认为已经全部选了。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
struct as{
	int l,r;
}a[100005];
inline bool cmp(as a,as b){//排序函数
    if (a.l==b.l) return a.r<b.r;
	return a.l<b.l;
}
int main(){
    int n,t;
    cin >> n >> t;
    for (register int i=1;i<=n;i++){
    	cin >> a[i].l >> a[i].r;
    }
    sort(a+1,a+1+n,cmp);//排序
    a[n+1].l=t+1;//将n+1对的左端点设为t
    int ans=0,l=1,r=0;//赋初值
    for (register int i=1;i<=n+1;i++){//注意,从1扫到n
    	if (a[i].l>l){
    		if (a[i].l>r+1){
    			cout << -1;//这种情况下输出-1
    			return 0;
    		}
    		l=r+1;//r+1赋给l
    		r=a[i].r,ans++;
    	}
    	else {
    		r=max(a[i].r,r);//尽量取大值
    	}
    }
    cout << ans;
    return 0;
}
```


---


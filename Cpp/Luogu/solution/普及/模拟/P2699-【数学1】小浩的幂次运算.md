# 【数学1】小浩的幂次运算

## 题目描述

幂次运算让小浩觉得有些烦，最近他碰到了一些问题。  
他需要求出所有 $w^i$ 使得 $l \le w^i \le r$ ，于是他找到了你。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据：$1\le l\le r \le 1 \times 10^{18}$ , $1\le w \le10^9$。


## 样例 #1

### 输入

```
1 10 2```

### 输出

```
1 2 4 8```

## 样例 #2

### 输入

```
2 4 5```

### 输出

```
-1```

# 题解

## 作者：易颖杰 (赞：17)

哈哈，这题好像没有完整题解，只有管理员的一个部分代码，那我就来发一波吧，我吧管理员的改成了完整的了，这思路确实很好，具体在代码里说明：

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll l,r,w,t=1;//t是累乘的记录变量，初值要赋为1
int main()
{
    cin>>l>>r>>w;
    bool found=0;//found表示有没有找到符合条件的数的一个布尔变量
    if (l==1)//如果最左边是1，特判一下
    {
        found=true;//表示找到
        printf("1 ");//输出1
    }
    if(w>1)//如果w等于1的话会死循环，一直是1
    {
        while(t<l/w||(t==l/w&&(l%w)))//这个语句是先把t乘到最左的边界，其实我觉得可以放到下面的循环里，加一个条件判断
            t=t*w;
        while (t<=r/w)//在l到r间找数
        {
            t*=w;
            found=true;//找到数
            printf("%lld ",t);//输出找到的数
        }
    }
    if(!found) cout<<-1;//如果没有找到符合条件的数，输出-1
    cout<<endl;//文末换行好习惯，2333~
    return 0;
}
```

---

## 作者：FlierKing (赞：13)

这道题的精髓在一个接近max long long的值再乘上一个数就会爆long long

所以在判断时要使用一些技巧

比如当前的数字为tmp，在判断tmp\*w<=r时改为tmp<=r/w

再进行一些细节的处理即可

```cpp
//部分代码
    if (l==1)
    {
        found=true;
        printf("1 ");
    }
    if (w>1)
    {
        while (t<l/w||(t==l/w&&(l%w)))
            t=t*w;
        while (t<=r/w)
        {
            t*=w;
            found=true;
            printf("%lld ",t);
        }
    }

```

---

## 作者：IzumiSagiri (赞：4)

 看到如此美好~~水~~的数据范围，瞬间走暴力   
 枚举一下k的i次方是不是在[L,R]内就行了
 
 具体解释看代码
 
 代码如下：
```
#include<cstdio>

#define ull unsigned long long

const ull inf=(ull)(1<<31)*(ull)(1<<31)*2;

ull l,r,k;

int main() {
	int t;
	scanf("%llu%llu%llu",&l,&r,&k);
	ull op=1;
	int flag=1;
	if(k==0) {     //注意要特判k=0和k=1的情况
		int flag=1;
		if(l<=0&&r>=0)
			printf("0 "),flag=0;
		if(l<=1&&r>=1)
			printf("1 "),flag=0;
		if(flag)
			printf("-1");
		puts("");
		return 0;
	}
	if(k==1) {
		if(l<=1&&r>=1)
			printf("1\n");
		else
			puts("-1");
		return 0;
	}
	for(int p=0; p<63; p++) {
		if(op>=l&&op<=r)flag=0,printf("%llu ",op);
		if(inf/k<=op)break; //小心爆long long
		op*=k;
	}
	if(flag)puts("-1");
	else puts("");
	return 0;
}
```

---

## 作者：KesdiaelKen (赞：4)

挺好的一道题。此题看上去比较的简单，其实做法还是非常微妙的。

首先，一审题，便可以知道这道题及是一道O（n）模拟题。只需要不断地循环判断w^0,w^1,w^2……在l到r之间有多少个数，依次输出就行了。

然而此题不是那么简单。首先，注意到w是可以取1的。这样如果不加特判，程序就会一直循环，然后就TLE了。考虑到1的n次方都为1，我们可以加一个特判。如果l==1，则直接输出1，否则输出-1，然后就return 0了。这样就保证了w==1时输出的正确性。

但是，此题还有一个地方需要注意。因为在枚举w^i次方时，有可能会爆long long。所以，我们可以做这样一个处理：若有一数x，则取x1=xmod10^9，x2=[x/10^9]。这样，便有x1+x2\*10^9==x。因为r<=10^18且w<=10^9，所以这样w^i最多枚举到10^27，用此方法便保证了不会爆数据了。比较数据的方法也需要改写一下，因为很好想，这里便不再做太细致的分析了。

如有不解，请看代码：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
const long long modnum=1e9;
int main()
{
    long long zuo,you,w;
    scanf("%lld%lld%lld",&zuo,&you,&w);
    bool tf=false;
    if(w==1)//特判w==1的情况
    {
        if(zuo==1)printf("1");
        else printf("-1");//同解析
        return 0;
    }
    long long sg1=1,sg2=0;
    long long zuo1=zuo%modnum,zuo2=zuo/modnum;
    long long you1=you%modnum,you2=you/modnum;//分成两段
    for(;sg2<you2||(sg2==you2&&sg1<=you1);sg1*=w,sg2*=w,sg2+=sg1/modnum,sg1%=modnum)//判断，高位优先；乘下一个w时，注意两段都要乘，然后再取mod
        if(sg2>zuo2||(sg2==zuo2&&sg1>=zuo1))//比较
        {
            printf("%lld ",sg2*modnum+sg1);//因为如果比较成功，则一定不会爆long long，所以直接用long long输出
            tf=true;//有输出
        }
    if(!tf)printf("-1");//如果没有数符合，则输出-1
    return 0;
}
```

---

## 作者：pantw (赞：3)

看到题目这么简单就知道一定有套路emmm

1. 小心爆longlong。

2. 记得对1特判。


```cpp
#include <cstdio>
#define Lovelive long long
int main() {
    Lovelive l, r, w;
    scanf("%lld%lld%lld", &l, &r, &w);
    bool flag = true;
    if(w == 1) return puts((l == 1 && r >= 1) ? "1" : "-1"), 0; // 特判
    for(Lovelive tmp = 1; tmp <= r && tmp > 0; tmp = ((r / w >= tmp) ? tmp * w : r + 1)) {
        if(tmp >= l && tmp <= r) {
            printf("%lld ", tmp);
            flag = false;
        }
    }
    if(flag) puts("-1");
    return 0;
}
```

`tmp = ((r / w >= tmp) ? tmp \* w : r + 1)`的作用是避免因tmp\*w溢出而导致死循环。


---

## 作者：Chiaro (赞：2)

先说说题外话

------------


感觉这题真恶心

一开始看着数据以为 ``unsigned long long`` 就可以水过去

结果没有这么简单

\#1 \#7 ``WA``了不知道多少次才知道原来``unsigned long long``会爆

用了 ``__int128``就过去了

整整浪费了一个上午



------------

切入正题

感觉这道题就是一个 **快速幂** ~~模板~~题

#### 用快速幂也能更好理解一些

#### 首先需要定位好从哪里开始循环输出

第一层循环 : 

> 直到快速幂的值 > $ l $ 时循环结束

> 这样定位好从哪里开始输出

第二层循环 :

> 直到快速幂的值 > $ r $ 时循环结束

> 定位好 到哪里结束输出

> 第二层循环每循环一次就输出一次

> 就是最后的答案了



------------


还有几个需要注意的地方

``__int128``没法用``scanf`` , ``printf`` 或``cin`` , ``cout``输出输入

#### 所以需要自己写输出输入

#### 当$w==1$ 的时候是需要特判的,如果 $l==1$ 时输出 $1$ 就可以了

因为不管是 $1$的几次方结果都是$1$

#### $l$ $!=1$ 时就没有解输出 $ -1 $ 


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll __int128//__int128
using namespace std;
ll l,r,w,now;
bool b;
inline ll read(){//手写__int128读入
    ll x=0;char c;
    while(!isdigit(c=getchar()));
    do x=(x<<1)+(x<<3)+(c^'0'); while(isdigit(c=getchar()));
    return x;
}
void put(const ll x){//手写__int128输出
    if(x<0)putchar('-');
    if(x>9)put(x/10);
    putchar(x%10+'0');
    return;
}
inline ll ksm(ll a,ll b){//快速幂模板
	ll ans=1;
	while(b){
		if(b&1)ans=ans*a;
		a=a*a;
		b>>=1;
	}
	return ans;
}
int main(){
	l=read();r=read();w=read();//读入__int128
    if(w==1){//当w==1时,特判
    	if(l==1)cout<<1<<'\n';
		else cout<<-1<<'\n';
		return 0;
    }
	for(ll i=0;ksm(w,i)<l;i++)now++;
    //第一层循环,定位从哪里开始
	for(ll i=now;;i++){//第二层循环
		ll p=ksm(w,i);
		if(p>r)break;//如果大于 r 就跳出
		put(p);putchar(' ');//输出
		b=1;
	}
	if(!b)cout<<-1;
	return 0;
}
```

---

## 作者：xsling (赞：2)

hhh快速幂暴力能$A$啊；

模拟赛考到这题，但是是多组数据；

依然要注意特判$1$的情况；

由于是直接枚举次方，故$i$一定在 $log_wl$~$log_wr$范围内；

上代码:

```cpp
#include<bits/stdc++.h>
#define ll unsigned long long
#define fr(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);
#define N 2005
using namespace std;
ll T,l,r,k,ans;
bool bj=0;
ll poww(ll a,ll b) //快速幂
{
    ll ans=1,base=a;
    while(b)
    {
        if((b&1)!=0)ans*=base;
        base*=base;
        b>>=1;
    }
    return ans;
}
int main()
{
    scanf("%lld%lld%lld",&l,&r,&k);
    if(k==1)
    {
    	if(l==1)puts("1");
    	else puts("-1");
    	return 0;
	}
	for(ll i=(log(l)/log(k));i<=(log(r)/log(k));i++)
    {
        ll temp=poww(k,i);
        if(temp<l||temp>r)continue;
        printf("%lld ",temp);
        bj=1;
    }
    if(bj==0)puts("-1");
    printf("\n");
    bj=0;
    return 0;
}
```


---

## 作者：Dog_Two (赞：2)

咱其实还有个狠招。

long long会溢出，咱用int128不就好啦。

只有C++11以上支持int128的使用，而且NOIP也暂不支持C++11特性，所以这篇题解仅供娱乐，不作为靠谱的参考。

int128不支持流IO和stdIO，所以我们要自己写输入输出函数，也就是快读快输。

当然我们也可以通过读入long long类型，再强制转换到int128类型上，输出答案时在强制转化成long long类型，因为答案不会超出long long，所以我们也可以不必写int128的IO。

```cpp
#include<bits/stdc++.h>
using namespace std;
__int128 l,r,w;

__int128 inp(){
	register __int128 x=0;
	char c;
	while(!isdigit(c=getchar()));
	do x=(x<<1)+(x<<3)+(c^'0'); while(isdigit(c=getchar()));
	return x;
}

bool print(const __int128 &x){
	return x>9?print(x/10),putchar(x%10+'0'):putchar(x+'0');
}

int main(){
	l=inp(),r=inp(),w=inp();
	if(w==1){
		if(l<=1 and r>=1) cout<<1;
		else cout<<-1;
		return 0;
	}
	bool ans=false;
	__int128 val=1;
	for(;val<l;val*=w);
	for(;val>=l and val<=r;val*=w){
		ans|=print(val);
		putchar(' ');
	}
	if(!ans) cout<<-1;
	return 0;
}
```

---

## 作者：Jelly_Goat (赞：1)

这道题还是挺虐心的QAQ  

小金羊和同机房的大佬调了1h才调出来这玩意

后来才发现$i$可以为$0$QAQ

-----

废话不多说，直接给思路

由于数据范围只有$1e18$的样子，所以最多就卡到long long上限$2^{64}-1$  

然而因为没有模数，所以快速幂是有可能会爆开的

我们可以考虑一下每一次累乘$w$，最多会乘64次

那么会爆long long如何判断下一次是否能乘$w$呢？  

其实可以考虑整一个double存$r\over w$的值  

如果当前累计乘出来的数字大于这个值，那么下一次乘就有可能爆掉

我们~~悬崖勒马~~break掉即可

因此这个题的复杂度最多就到$O(64)$，很小的样子

**另外注意判断$w = 1$和$i = 0$的情况**！

-----

代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std;
typedef long long lli;
lli L, R, w, now = 1;
double Li, Ri;
bool flag = false;

int main()
{
	cin >> L >> R >> w;
	if (w == 1)
	{
		if (L == 1)
			puts("1");
		else
			puts("-1");
		return 0;
	}
	if (1 >= L && 1 <= R)
	{
		printf("1 ");
		flag = true;
	}
	for (int i = 1; i <= 64; i++)
	{
		now = now * w;
		double temp = R / w;
		if (now <= R && now >= L)
		{
			printf("%llu ", now);
			flag = true;
		}
		if (now > temp)
			break;
	}
	if (!flag)
		puts("-1");
	return 0;
}
```

---

## 作者：xkcdjerry (赞：1)

这道题大多数dalao们都是用幂的方法来做的。同时用各种~~诡异~~精妙的方式避免炸long long，本蒟蒻发一篇对数的题解。

用对数的主要好处是会把数据往下除，让数据不断变小，所以无论如何处理，都一定不会爆long long。

我对数方式的思路如下：

首先，如果存在一个i，那么定有：

$log_w$ L
$\leq$
i
$\leq$
$log_w$ R


因为i为整数，所以也有：

$\lceil$
$log_w$ L$\rceil$
$\leq$
i
$\leq$
$\lceil$ $log_w$ R $\rceil$


第一版代码：

（因为数据范围大，所以开unsigned long long稳一些）

```c
#define ANSER(val) do{printf(val);return;}while(0)
int logit(ull p,ull w)
{
    int ans=0;
    while(p/=w) ans++;
    return ans;
}
void work()
{
    ull l,r,w;
    ull pw=1;
    int llog,rlog,i;
    scanf("%llu%llu%llu",&l,&r,&w);
    llog=logit(l,w); 
    rlog=logit(r,w);
    for(i=0;i<llog;i++) pw*=w;
    for(;i<rlog;i++){pw*=w;printf("%llu ",pw);}
}
```

后来发现这个代码没处理上w=1、l=1、llog$\geq$rlog的情况，所以总是AC不了，加上特判之后才AC。
~~我才不会告诉你我为了发现这个贡献了一整页的提交记录呢~~
（特判的原因在注释里解释了）

AC代码如下：
```c
#include <stdio.h>
#define ull unsigned long long
#define ANSER(val) do{printf(val);return;}while(0)
int logit(ull p,ull w)
{
    // 计算 ceil(log(w) p)
    // 名字是为了避免和内置log冲突
    int ans=0;
    while(p/=w) ans++;
    return ans;
}
void work()
{
    ull l,r,w;
    ull pw=1;
    int llog,rlog,i;
    scanf("%llu%llu%llu",&l,&r,&w);
    
    //特判w=1（w=1时log就算不出值无限除了）
    if(w==1)
    {
        if(l==1)
            ANSER("1");
        else
            ANSER("-1");
    }
    
    if (l == 1&&w>=2) printf("1 "); 
    //特判l=1，否则log会判不上
    
    //计算左右端点的log值
    llog=logit(l==1?2:l,w);
    rlog=logit(r,w);
    
    //如果左边的log值不小于右边的log值，
    //就可能无解
    if(llog>=rlog)
    {
        for(i=0;i<llog;i++) pw*=w;
        if(pw>=l&&pw<=r) printf("%llu",pw);
        else ANSER("-1");
        return;
    }
    
    //正常处理：先计算开头，再把后面的
    //每一个分别输出
    for(i=0;i<llog;i++) pw*=w;
    for(;i<rlog;i++){pw*=w;printf("%llu ",pw);}
}
int main()
{
    work();
    return 0;
}
```
[AC链接](https://www.luogu.com.cn/record/31821395)

欢迎来我的[博客](https://www.luogu.com.cn/blog/spinning-xkcdjerry/#)！

---


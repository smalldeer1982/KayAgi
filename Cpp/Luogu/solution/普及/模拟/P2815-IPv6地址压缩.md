# IPv6地址压缩

## 题目背景

（友情提示：IPv6 基础知识曾多次出现在 NOIP 初赛中）Internet Protocol，互联网协议，即为我们常说的 IP。我们目前常说的 IP 主要指它的第四版，即 IPv4，它由 IETF 于 1981 年发布。它的地址长度是 $32$ 个二进制位，因此也就有 $2^{32}$ 个 IP 地址可供使用，约为 $43$ 亿，在当时，谁也没有料想到 IPv4 如此庞大的地址长度会有用完的一天。

在 21 世纪的今天，互联网的蓬勃发展早就了我们如今便利的生活。当下，世界人口已超过 70 亿，计算机和各种联网设备已经走入千家万户，而不再仅是上个世纪 80 年代科学家们的工具。此时便出现了人们日益增长的联网设备需要同落后 IPv4 地址长度之间的矛盾。尽管可以通过网络地址翻译能技术来共享 IP 地址，临时解决枯竭的问题，但显然不是长久之计。

IETF 也有先见之明，早早地于 1998 年发布了 IPv6 协议，从微软 2006 年发布的 Windows Vista 开始成为默认安装的网络协议。作为 IPv4 的继任者，它的地址长度为 $128$ 个二进制位，也就是 $2^{128}$ 个IP地址可供使用。然而面对这冗长的地址，一位记忆力不好的网络工程师小明在配置路由表时遇到了许许多多多的困难，现在他找到了你，希望你帮忙编写一个程序来按照 IPv6 地址标准的格式压缩规则来压缩 IPv6 地址。

## 题目描述

**【IPv6 格式】**

IPv6 二进位制下为 $128$ 位长度，以 $16$ 位为一组，每组以冒号“`:`”隔开，可以分为 $8$ 组，每组以 $4$ 位十六进制方式表示。

比如 `2001:0db8:0000:0000:0123:4567:89ab:cdef` 是一个合法的 IPv6 地址。

同时 IPv6 地址在某些条件下可以压缩：

1. 每组数字代表的独立十六进制数可以省略前位的 `0`。

比如上面的 IPv6 地址可被压缩为 `2001:db8:0:0:123:4567:89ab:cdef`。

2. 可以用双冒号 `::` 表示一组 `0` 或多组连续的 `0`，但只能出现一次。

比如上面的 IPv6 地址可被压缩为 `2001:db8::123:4567:89ab:cdef`。

请你帮助记忆力不好的网络工程师小明解决他遇到的问题。

**【规则补充】**

1. 输入数据为完全展开的 IPv6 地址，确保输入的 IPv6 地址不含双冒号，每组地址省略的 `0` 都会被补充上去。

2. 双冒号只能使用一次，因此我们压缩最长的全 `0` 组。

比如 `2001:0db8:0000:0000:1:0000:0000:0000`，压缩为 `2001:db8:0:0:1::`，而非 `2001:db8::1:0:0:0`。

3. 双冒号只能使用一次，因此我们在我们遇到地址中多个连续全 `0` 组长度相同时，我们压缩最前面的一个。

比如 `2001:0db8:0000:0000:ffff:0000:0000:1`，压缩为 `2001:db8::ffff:0:0:1`，而非 `2001:db8:0:0:ffff::1`。

4. 输入的 IPv6 地址可能无法被压缩，此时请照原样输出。

提示：本题所示的压缩规则与 macOS (Darwin) 默认的 IPv6 地址显示方式相同，而 Windows 和 Linux 只遇到一组全 `0` 时不会使用 `::` 进行压缩。但用此方法压缩过的 IPv6 地址一样可以被 Windows 和 Linux 正确识别。

比如 `2001:0db8:ffff:0000:0123:4567:89ab:cdef`，Darwin 压缩为 `2001:db8:ffff::123:4567:89ab:cdef`，而 Linux 和 Windows 压缩为 `2001:db8:ffff:0:123:4567:89ab:cdef`。

## 样例 #1

### 输入

```
2406:0840:f990:0000:0000:0000:0000:0001```

### 输出

```
2406:840:f990::1```

## 样例 #2

### 输入

```
2a13:1801:018a:00cf:0100:0000:0000:0000```

### 输出

```
2a13:1801:18a:cf:100::```

## 样例 #3

### 输入

```
2001:4860:4860:0000:0000:0000:0000:8888```

### 输出

```
2001:4860:4860::8888```

## 样例 #4

### 输入

```
2001:0db8:0000:0000:0000:0000:0000:0001```

### 输出

```
2001:db8::1```

## 样例 #5

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0000```

### 输出

```
::```

## 样例 #6

### 输入

```
0000:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
::1```

## 样例 #7

### 输入

```
2001:0db8:ffff:0000:0123:4567:89ab:cdef```

### 输出

```
2001:db8:ffff::123:4567:89ab:cdef```

## 样例 #8

### 输入

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

### 输出

```
1234:5678:9abc:def0:1234:5678:9abc:def0```

## 样例 #9

### 输入

```
0001:0000:0000:0000:0000:0000:0000:0001```

### 输出

```
1::1```

## 样例 #10

### 输入

```
0000:0000:0000:0000:0000:0000:0001:0002```

### 输出

```
::1:2```

# 题解

## 作者：RocksonLee (赞：12)

这是本蒟蒻第一次发题解，有点悬……

这道题采用暴力通过，不过坑点有点多，因为这样，才能成为~~绿题~~（刷的时候还被黄了）。

这道题并不是~~很难~~，题目的点都得好好瞧瞧，有点烦……

#### 先是找最长的全“0”字段
```cpp
    int i1,i2,t;
    bool ok;
    for (i1=0,t=0;i1<8;i1++)
    {
        ok=true;
        for (i2=0;i2<4;i2++)
        {
            if (a[i1*5+i2]!='0')
            {
                ok=false;    //如果有一个非0字符则跳出循环 
                break;
            }
        }
        if (ok) 
        {
        	t++;          //计数器 
            if (t>maxn) 
            {
                maxn=t;
                maxi=i1;
            }
        }
        else t=0;           
    }
    if (maxn==1) maxi=-1;
    maxi=maxi-maxn+1;
```

处理时需要注意windows和macos规则不同，当全“0”字段只有一个，用“::”就没法AC了，应该像处理剩下的“0”那样处理。

#### 处理剩下的“0”
```cpp
while (a[i1*5+i2]=='0'&&i2<3) i2++;
```

有点暴力，直接无视跳过前导零和余下全“0”字段。

### 本人AC代码
```cpp
#include <bits/stdc++.h>   //传说神奇的万能头文件
using namespace std;
char a[39];
int maxi=-1,maxn=1;
void find ()          //寻找最长"0000"字段函数 
{
    int i1,i2,t;
    bool ok;
    for (i1=0,t=0;i1<8;i1++)
    {
        ok=true;
        for (i2=0;i2<4;i2++)
        {
            if (a[i1*5+i2]!='0')
            {
                ok=false;    //如果有一个非0字符则跳出循环 
                break;
            }
        }
        if (ok) 
        {
        	t++;          //计数器 
            if (t>maxn) 
            {
                maxn=t;
                maxi=i1;
            }
        }
        else t=0;           
    }
    if (maxn==1) maxi=-1;    //windows和mac os压缩规则不一致 
    maxi=maxi-maxn+1;
} 
int main ()
{
    scanf("%s",a);
    find();
    int i1,i2;
    for (i1=0;i1<8;i1++)
    {
        if (maxi==i1)        //将最长字段压缩成“::” 
        {
            cout<<":";
            if (i1==0) cout<<":";
            i1=i1+maxn;
            if (i1>7) break;
        }
        i2=0;
        while (a[i1*5+i2]=='0'&&i2<3) i2++;  //处理全“0”字段
        for (;i2<4;i2++)
        { 
            cout<<a[i1*5+i2];
        }
        if (i2==4&&i1!=7) cout<<":";  //最后一个字段无需“：” 
    }
    return 0;
}
```

---

## 作者：xujian (赞：7)

终于A了这道绿题，交了10几遍~~（我太菜了）~~，从上午9点刷到下午3点才A~~（我是真的菜）~~，既然这么辛苦就发一下我的思路吧。

### [本人本题所有代码评测记录](https://www.luogu.org/recordnew/lists?uid=xujian&pid=P2815&status=&sort=0)

## 方法：纯模拟，无算法

不懂的地方就看一下注释~，下面是我的代码↓

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[10],k,e,m,km,em,mm,sum;
//s是存放IP，k是存放全零组的开始下标，e是存放全零组的结束下标，m是全零组的连续数目，km是存放全零组的开始下标的最大值，em是存放全零组的结束下标的最大值，mm是全零组的连续数目的最大值，sum是全零组的总数目。
int main(){
	scanf("%x:%x:%x:%x:%x:%x:%x:%x",&s[1],&s[2],&s[3],&s[4],&s[5],&s[6],&s[7],&s[8]);
    //%x是十六进制输入，会自动过滤掉0.用scanf便于格式的控制。
	for(int i=1;i<=8;i++)
		if(s[i]!=0)break;
		else if(i==8)puts("::"),exit(0);
    //判断IP全0的情况
	for(int i=1;i<=8;i++)
	    if(s[i]==0)sum++;
    //统计全0组的数目
	for(int i=1;i<=7;i++){
	    k=0;  //注意开始下标一定要清零
		if(s[i]==0)k=i;  //如果为全零组则记下它的开始下标
		for(int j=i;j<=8;j++)
			if(s[j]!=0){e=j;break;}  //全零组结束则记下它的结束下标
			else if(s[j]==0&&j==8)e=9;  //判断末尾是全零组的情况，补上j循环只能扫到8的缺陷
		if(k)m=e-k;  //计算连续全零组的数目，要排除k=0的情况是因为可能不会存在全零组
		if(m>mm)mm=m,km=k,em=e;  //更新最大值
	}
	for(int i=1;i<=8;i++)
		if(sum==1&&s[i]==0)printf(":");  //如果只有一个全零组则把0改成冒号
		else if(i==km-1||i==8)printf("%x",s[i]);  //如果是全零组的末尾或IP的末尾则末尾无需接冒号
		else if(i!=km)printf("%x:",s[i]);  //正常情况，输出一段IP后加上冒号
		else printf("::"),i=em-1;  //将连续的全零组用冒号代替
	return 0;
}
```

好了，也差不多了，## 实际上这种题目本身并不难，关键是在于你要细心和有足够的耐心。

### [AC代码评测记录](https://www.luogu.org/recordnew/show/15533179)

求管理大大给过~

---

## 作者：灰白骨 (赞：6)

直接从头改到尾；
```cpp
#include<bits/stdc++.h>
using namespace std;
char clea='x',a[50];
int mx,jc,jl1=-3,jl2=-3,b1=-5,b2;
int main()
{
    scanf("%s",&a);
    for(int i=0;i<strlen(a);i=i+5)
    {
        if(a[i]=='1'&&a[i+1]==':')
        {
            i+=2;
            b1=-5;
            b2=0;
            jc=0;
        }
        if(mx<jc)
        {
            mx=jc;
            jl1=b1;
            jl2=b2;
        }
        if(a[i]!='0')
        {
            b1=-5;
            b2=0;
            jc=0;
        }
        if(a[i]=='0')
        {
            if(a[i+1]=='0')
            {
                if(a[i+2]=='0')
                {
                    if(a[i+3]=='0')
                    {
                        if(b1==-5)
                        {
                            b1=i;
                        }
                        if(b1!=-5)
                        {
                            b2=i+4;
                        }
                        jc++;
                    }
                    else
                    {
                        jc=0;
                    }
                    a[i+2]=clea;
                }
                else
                {
                    jc=0;
                }
                a[i+1]=clea;
            }
            else
            {
                jc=0;
            }
            a[i]=clea;
        }
        else
        {
            jc=0;
        }
    }
    if(mx<jc)
    {
        mx=jc;
        jl1=b1;
        jl2=b2;
    }
    for(int i=jl2;i>=jl1;i--)
    {
        a[i]='x';
    }
    if(a[jl1-1]!=':')
    {
        if(a[jl1]!=':'&&a[jl1+1]!=':')
        {
            a[jl1]=':';
            a[jl1+1]=':';
        }
        else
        {
            if(a[jl1]==':'&&a[jl1+1]!=':')
            {
                a[jl1+1]=':';
            }
            else
            {
                if(a[jl1]!=':'&&a[jl1+1]==':')
                {
                    a[jl1]=':';
                }	
            }
        }	
    }
    else
    {
        if(a[jl1]!=':'&&a[jl1+1]!=':')
        {
            a[jl1]=':';
        }
    }
    //0000:1111:1111:1111:1111:1111:1111:1111
    for(int i=0;i<strlen(a);i++)
    {
        if(a[i]=='x')continue;
        printf("%c",a[i]);
    }
    return 0;
}
```

---

## 作者：_Ayanami_ (赞：5)

各种神奇的细节

~~我才不会告诉你我整整交了十遍才过~~
[一脸懵逼.jpg](https://cdn.luogu.com.cn/upload/image_hosting/asmymhqi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)


### 下面开始正文

其实这题要做的压缩只有两个

- 删去前导零
- 把一段零替换成“：”

按要求处理就对了

```cpp
#include<cstring>
#include<iostream>
using namespace std;
int maxx=0,maxi;
string ss,s[8];
int main()
{
	cin>>ss;
	for(int i=0;i<8;i++)
	{
		int j=0;
		//十进制下一组是四位，加上“：”一共五位
		while(ss[i*5+j]=='0')//跳过前导零
		{
			j++;
		}
		if(j==4)//特判如果全是零则填上一个零
		{
			s[i]="0";
		}
		else//记录剩下的部分
		{
			for(j;j<4;j++)
			{
				s[i]+=ss[i*5+j];
			}
		}
	}
```
读入整串地址后分别处理每一组

删去前导零后存入另一个字符串
```cpp
	for(int i=0;i<8;i++)
	{
		if(s[i]=="0")
		{
			
			int j=0;
			while(i+j<7&&s[i+j+1]=="0")//计数
			{
				j++;
			}
			if(j>maxx)//更新最大连续长度和位置
			{
				maxx=j;
				maxi=i;
			}
			i+=j;
		}
	}
```
找到最长连续的零
```cpp
	for(int i=0;i<8;i++)
	{
		if(i==maxi&&maxx!=0)//将最长连续的零全替换成“：”
		{
			cout<<"::";
			i+=maxx;//跳过这一段
		}
		else
		{
			cout<<s[i];//输出这一组地址
			if(i!=7&&i!=maxi-1)//如果是最后一组不用输出“：”
			{
				cout<<":";
			}
		}
	}
}
```

---

## 作者：EarthGiao (赞：2)

## 【思路】
模拟    
### 【题目大意】
将完整的的IPv6的显示方式压缩为macOS(Darwin)默认的IPv6地址显示方式    

### 【题目分析】
压缩方式即为：    
将每一组数 （每一组数是没有被:隔开的连续的4个数）的前导0去掉    
不过如果是0000那就只能压缩为0    
将最长的连续的0000这样的串可以压缩为::   
比如0000:0000:0000:0000就可以压缩为::   
如果有两个相同长度的那就替换前面的   

### 【核心思路】
先找出最长的连续0000串第一个数的位置    
到时输出输出完成::之后直接跳到这个串的最后一位就好了    
总的来说上面这个还是比较好处理的   
去除前导0才是最难的    


这个时候就会有人说了，这不就是一个while循环搞的定的嘛，哪里难了    
这个时候很容易会Wa掉第一个点   
本人就出在这个问题上面    
因为一般用while循环判断是不是这组数的最后一个一般会用下一个是不是:来判断    
但是！    
**想没想过最后一组数的最后一位怎么判断？这个后面可没有:**      
很容易被忽略的哦     
但是知道问题所在之后稍微特判一下就可以了      

### 【提供一组小数据】
关于第一个点错误的样例     
abcd:0000:0000:abcd:0012:0000:0001:0000    
正解： abcd::abcd:12:0:1:0    
错解： abcd::abcd:12:0:1:     
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>.
#include<string>

using namespace std;
string s;
int main()
{
	cin >> s;
	int l = s.length();
	int a = 0;
	int js = 0;//记录目前0串的长度 
	int M = 0;//记录最大的几组0的长度 
	int wz = -1;//最长0那一串中第一个0的位置 
	int last = -1;//上一个0串的位置 
	for(register int i = 0;i < l;i += 5)
	{
		if(s[i] == '0' && s[i + 1] == '0' && s[i + 2] == '0' && s[i + 3] == '0')//一组完整的0 
		{
			if(last == i - 5)
			{
				last = i;
			}
			else
			{
				js = 0;
				last = i;
				a = i;
			}
			js ++;
		}
		if(js > M)
		{
			M = js;
			wz = a;
		}
	}
	int jj = 0;
	while(jj < l)
	{
		if(jj == wz)
		{
			if(jj == 0)
				cout << ":";
			jj += M * 5 - 1;
			if(jj == l)
				cout << ":";
		}
		else
		{
			if(jj % 5 == 0)
			{
				if(jj >= 35)//如果是最后一组的话，那就不能根据下一个是不是:来判断这个0是不是这组数中最后一个数了 
				{
					while(s[jj] == '0' && jj + 1 != l)
					{
						jj ++;
					}
				}
				else
				{
					while(s[jj] == '0' && s[jj + 1] != ':')
					{
						jj ++;
					}
				}
			}
			cout << s[jj]; 
			jj ++;
		}
	}
	cout << endl;
	return 0;
}
/*
2001:0db8:0000:0000:0123:4567:89ab:cdef
012345678901234567890123456789012345678

abcd:0000:0000:abcd:0012:0000:0001:0000
*/
```

---

## 作者：dfydada⚡⚡⚡ (赞：2)

可以以每个：为段点进行判断，不过最后的4个要进行特殊判断，因为没有：结尾了。当然你也可以增加一个：在结尾；

如果不增加的话就要独立循环35到39；

独立循环的内容和普通的一样判断就可以了，没有变化。只是循环范围变了。

判断：的时候用一个变量在累加，如果超过了两次连续就不输出。

```cpp
if(ch[i]==':')
		{
			if(boolr)
			{
				ans++;
			}
			else
			{
				boolr=true;
				ans=1;
			}
			if(ans<=2)
			{
				cout<<":";
			}
		}
```

在一个就是判断前导零的操作。

```cpp
else if(boolr)
		{
			if(ch[i]=='0')
			{
				continue;
			}
			else
			{
				boolr=false;
				cout<<ch[i];
			}
		}
```

两步都判断了就可以直接输出了。

这段代码就不给出了，直接看下面的总代码。

总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=3000+10;
int tot,ans;
char ch[N];
bool boolr=true;
int main()
{
	cin>>ch+1;
	for(int i=1;i<=34;i++)
	{
		if(ch[i]==':')
		{
			if(boolr)
			{
				ans++;
			}
			else
			{
				boolr=true;
				ans=1;
			}
			if(ans<=2)
			{
				cout<<":";
			}
		}
		else if(boolr)
		{
			if(ch[i]=='0')
			{
				continue;
			}
			else
			{
				boolr=false;
				cout<<ch[i];
			}
		}
		else if(!boolr)
		{
			cout<<ch[i];
		}
	}
	for(int i=35;i<=39;i++)
	{
		if(ch[i]==':')
		{
			if(boolr)
			{
				ans++;
				continue;
			}
			else
			{
				boolr=true;
				ans=0;
			}
			if(ans<=2)
			{
				cout<<":";
			}
		}
		else if(boolr)
		{
			if(ch[i]=='0')
			{
				continue;
			}
			else
			{
				boolr=false;
				cout<<ch[i];
			}
		}
		else if(!boolr)
		{
			cout<<ch[i];
		}
	}
	return 0;
}

```


---

## 作者：B_Qu1e7 (赞：2)

```cpp
//管理员不好意思看题的时候交错题解……扣贡献应该应该。。
/*
做法：
先清除每段的前导0（每两个冒号之间称为一段）
并保证每一段都至少有一个数字（只有一个0不能去掉） 
按每一位查找，若找到一个0并保证其后面接着冒号，其前面也是冒号或者没东西 
那么从这里进行操作：
{
    造一个tp，每次加2
    （此时每个全零组仅剩一个0，因此若有全0组，每组应是一个0和一个冒号）
    找到的更改为双冒号的全0组应以0结尾
    特判：
    若该位置是第一位，则标记q为1
    若找到的全0组末尾是最后一位，则标记h为1
    （若全零组在中间，则可以保留其头前面、其尾后面的冒号成为双冒号） 
    （不排除把第一个0或最后一个0去掉的情况，去掉后应补上冒号，因为首0前面和末0末尾是没有冒号的，应补上。） 
}
把最大的tp与该位置带出来
*/
#include<bits/stdc++.h>
using namespace std;
string s;int x,y=0,q=0,h=0;//如上 
int main()
{
    cin>>s;
    for(int i=0,j=5;i<s.size();i+=j,j=5)//清除前导0，j保证每一次i都可以到下一个冒号的下一位 
    {
        while(s[i]=='0'&&s[i+1]!=':'&&i!=s.size()-1)j--,s.erase(i,1);//清除一个前导0 
    }
    for(int i=0;i<s.size();i++)
    {
        if((!i||s[i-1]==':')&&s[i]=='0'&&s[i+1]==':')//判断 
        {
            int tp=0;
            while(s[i+tp+1]==':'&&s[i+tp+2]=='0')tp+=2;//如解释，找全0组 
            if(tp>y)//找最长 
            {
                y=tp;//带出 
                x=i;//带出 
                if(!i)q=1;//特判前面 
                if(y-x+1==s.size())h=1;//特盘后面 
            }
        }
    }
    if(y)s.erase(x,y+1);//如果有找到全0组，清除 
    if(q)cout<<':';cout<<s;if(h)cout<<':';//并且（否则）输出前后冒号 
}
```

---

## 作者：HiJ1m (赞：2)

看起来很有意思的字符串处理题。

作为第一个题解发一种通俗易懂(愚钝)的解法。

主要就是找最长全0组，很容易对吧。

有一些容易忽略的小细节调起来很烦人。


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
char IP[10][5],zero;
bool eat[10];
int maxlen,maxloc,loc=1;
int main()
{
    for(int i=1;i<=8;i++)
    {
        int z=0;
        for(int j=1;j<=4;j++)
        {
            scanf("%c",&IP[i][j]);
            if(IP[i][j]=='0')z++;              //数0
        }
        if(z==4)
        {    
            zero++;
            eat[i]=true;
        }
        if(z!=4||i==8)            
        {    
            if(zero>maxlen)             //存储全0组最长的起始位置和它的长度 ；因为它是省略前面的全0组。所以是个小于号而非≤
            {    
                maxlen=zero;
                maxloc=loc;
            }
            zero=0;
            loc=i+1;
        }
        getchar();           //这个是读掉冒号用的
    }
    for(int i=1;i<=8;i++)
    {
        if(i==1&&maxloc==1)printf(":");                  //我的程序在起始或结尾的位置要特判才过，可能是我菜。
        if(i==maxloc){i+=maxlen-1;if(i==8)printf(":");}         //这个i+=maxlen-1就直接跳过了这一段全0组
        else
        {
            for(int j=1;j<=4;j++)
            {
                if(j==1&&IP[i][j]=='0')while(IP[i][j]=='0'&&j<4)j++;        //用while去掉前导0，但要注意“0000”处理完是“0”所以加了个j<4
                printf("%c",IP[i][j]);    
            }
        }
        if(i<8)printf(":");           //最后一组不要打冒号
    }
    return 0;                 //好习惯
}

```

---

## 作者：0AND1STORY (赞：1)

看到很多大佬都在用
```cpp
scanf("%x:%x:%x:%x:%x:%x:%x:%x",&s[1],&s[2],&s[3],&s[4],&s[5],&s[6],&s[7],&s[8]);
```
读入16进制，我就纯粹读入一个**字符串**然后处理也可做到一样的效果

通过题目很容易就想到做法，步骤如下

1. 去掉前导零

```cpp
s = ":" + s;    //先在s前加一个`:`便于去掉前导零
for (int i = 1; i < s.size(); i ++)
{
    //如果在`:`后有`0`则有前导零，进行删除
    if (s[i - 1] == ':' && s[i] == '0')
        s.erase(s.begin() + i, s.begin() + i + 1),
        i --;
}
s.erase(s.begin(), s.begin() + 1);  //删掉先前加的`:`
```

2. 将连续零个数最多的地方换成`::`

```cpp
for (int i = s.size() - 1; i >= 0; i --)
{
    //因为前面删掉了冒号后的所有0，所以判断连续冒号数即可判断连续0的个数
    if (s[i] == ':')
        f[i] = f[i + 1] + 1;
    else
        f[i] = 0;
    if (f[i] >= maxl)   //更新最优解
        maxp = i,
        maxl = f[i];
}
//删除冒号即可将连续0改为`::`
for (int i = 2; i < maxl; i ++)
    s.erase(s.begin() + maxp, s.begin() + maxp + 1);
//将原来删掉的0000还原为0(即在s中的两个冒号中加上0，压缩后的双冒号除外)
for (int i = 0; i < s.size() - 1; i ++)
{
    if (s[i] == ':' && s[i + 1] == ':' && i != maxp)
        s.insert(s.begin() + i + 1, '0');
}
```

### AC代码如下：（通过，但不全对）

```cpp
#include <iostream>
#include <string>
using namespace std;

//读入的ipv6地址
string s;
//用模拟找最多连续0的地址
int f[50], maxp, maxl;

int main()
{
    ios::sync_with_stdio(false);    //读入优化
    cin >> s;
    s = ":" + s;    //先在s前加一个`:`便于去掉前导零
    for (int i = 1; i < s.size(); i ++)
    {
        //如果在`:`后有`0`则有前导零，进行删除
        if (s[i - 1] == ':' && s[i] == '0')
            s.erase(s.begin() + i, s.begin() + i + 1),
            i --;
    }
    s.erase(s.begin(), s.begin() + 1);  //删掉先前加的`:`
    for (int i = s.size() - 1; i >= 0; i --)
    {
        //因为前面删掉了冒号后的所有0，所以判断连续冒号数即可判断连续0的个数
        if (s[i] == ':')
            f[i] = f[i + 1] + 1;
        else
            f[i] = 0;
        if (f[i] >= maxl)   //更新最优解
            maxp = i,
            maxl = f[i];
    }
    //删除冒号即可将连续0改为`::`
    for (int i = 2; i < maxl; i ++)
        s.erase(s.begin() + maxp, s.begin() + maxp + 1);
    //将原来删掉的0000还原为0(即在s中的两个冒号中加上0，压缩后的双冒号除外)
    for (int i = 0; i < s.size() - 1; i ++)
    {
        if (s[i] == ':' && s[i + 1] == ':' && i != maxp)
            s.insert(s.begin() + i + 1, '0');
    }
    if (s[s.size() - 1] == ':' && s[s.size() - 2] != ':')   //修复BUG用的小补丁
        s += '0';
    cout << s << endl;
    return 0;
}
```

### AC代码（完全正确）：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

//读入的ipv6地址
string s;
//用模拟找最多连续0的地址
int f[50], maxp, maxl;

int main()
{
    ios::sync_with_stdio(false);    //读入优化
    cin >> s;
    s = ":" + s;    //先在s前加一个`:`便于去掉前导零
    for (int i = 1; i < s.size(); i ++)
    {
        //如果在`:`后有`0`则有前导零，进行删除
        if (s[i - 1] == ':' && s[i] == '0')
            s.erase(s.begin() + i, s.begin() + i + 1),
            i --;
    }
    for (int i = s.size() - 1; i >= 0; i --)
    {
        //因为前面删掉了冒号后的所有0，所以判断连续冒号数即可判断连续0的个数
        if (s[i] == ':')
            f[i] = f[i + 1] + 1;
        else
            f[i] = 0;
        if (f[i] >= maxl)   //更新最优解
            maxp = i,
            maxl = f[i];
    }
    //删除冒号即可将连续0改为`::`
    for (int i = 2; i < maxl; i ++)
        s.erase(s.begin() + maxp, s.begin() + maxp + 1);
    s.insert(s.begin() + maxp + 1, '*');
    s.erase(s.begin(), s.begin() + 1);  //删掉先前加的`:`
    //将原来删掉的0000还原为0(即在s中的两个冒号中加上0，压缩后的双冒号除外)
    for (int i = 0; i < s.size() - 1; i ++)
    {
        if (s[i] == ':' && s[i + 1] == ':')
            s.insert(s.begin() + i + 1, '0');
    }
    //以下都是修复BUG用的小补丁
    if (s[0] == ':' && s[1] != '*')
        s.insert(s.begin(), '0');
    for (int i = 0; i < s.size(); i ++)
        if (s[i] == '*')
        {
            if (i != 0)
                s.erase(s.begin() + i, s.begin() + i + 1);
            else
                s[i] = ':';
            break;
        }
    if (s[0] == ':' && s[1] != ':')
        s.erase(s.begin(), s.begin() + 1);
    if (s[s.size() - 1] == ':' && s[s.size() - 2] != ':')
        s += '0';
    cout << s << endl;
    return 0;
}
```

### 另外附上我调试用的对拍程序：
```cpp
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <windows.h>

using namespace std;

//不用在意这些宏定义，方便写代码
#define main int main
#define init_rand srand(time(NULL));
#define LPFILE FILE*
#define infile(name) fopen(name, "w");
#define for(x, l, r) for(int x = l; x <= r; x ++)
#define end return 0;

main()
{
    init_rand
    while (true)
    {
        LPFILE fin = infile("test.in")
        for (i, 1, 7)
            fprintf(fin, "%04x:", rand() % 2 ? rand() % 0x10000 : 0);
        fprintf(fin, "%04x\n", rand() % 0x10000);
        fclose(fin);
        system("type test.in");
        system("my.exe < test.in > my.out");
        system("right.exe < test.in > right.out");
        if (system("fc my.out right.out"))
        	//弹出一个窗口，方便挂机查看
            MessageBox(NULL, "找到差异，请查看！", "找到差异", MB_OK | MB_ICONERROR),
            system("pause");
    }
    end
}
```


---

## 作者：fanfan (赞：1)

纯模拟题啊

ip字符串记录一下字符串，num数组记录一下每个字节的数字所代表的值，这里有个小技巧，可以判断每个数字是否小于1000来判断是否有前导0，但是因为是16进制，为了方便起见，把a看做1，b看做2.......

pp1和pp2记录左右断点，即'::'省略的部分....

然后就是各种特判，特判‘:’的存在....（这里是比较坑的....）

总的来说题还是很水的.....

    
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
char IP;
char ip[50];
int num[10];
int p1=0,p2=0,pp2,pp1;
void work(int x)
{
    if(num[x]==0&&x!=8)
    {
        printf("0:");return;
    }
    else if(num[x]==0&&x==8)
    {
        printf("0");return;
    }
    int cnt=1;
    while(num[x]<1000)
    {
        num[x]*=10;
        cnt++;
    }
    for(int i=cnt;i<=4;++i)
    printf("%c",ip[(x-1)*5+i]);
    if(x!=8&&x+1!=pp1)
    {
        printf(":");
    }
}
int main()
{
    int sum=0,t=0;
    for(int i=1;i<=39;++i)
    {
        IP=getchar();
        ip[i]=IP;
        if(IP==':')
        {
            num[++t]=sum;
            sum=0;
            continue;
        }
        if(IP<='z'&&IP>='a')
        sum=sum*10+IP-'a'+1;
        else
        sum=sum*10+IP-'0';
    }
    num[++t]=sum;
    int maxlen=0;
    for(int i=1;i<=8;++i)
    {
        if(num[i]==0)
        {
            if(p1==0)
            p1=p2=i;
            else
            p2=i;
            if(p2-p1+1>maxlen)
            {
                maxlen=p2-p1+1;
                pp1=p1;
                pp2=p2;
            }
        }
        else
        p1=p2=0;
    }
    for(int i=1;i<=8;++i)
    {
        if(i==pp1)
        {
            printf("::");i=pp2;
            continue;
        }
        if(num[i]<1000)
        {
            work(i);continue;
        }
        for(int j=(i-1)*5+1;j<=(i-1)*5+4;j++)
        printf("%c",ip[j]);
        if(i!=8&&i+1!=pp1)
        printf(":");
    }
}
```

---


# [POI 2015] PIE

## 题目描述

一张 $n\times m$ 的方格纸，有些格子需要印成黑色，剩下的格子需要保留白色。

你有一个 $a\times b$ 的印章，有些格子是凸起（会沾上墨水）的。你需要判断能否用这个印章印出纸上的图案。印的过程中需要满足以下要求： 

1. 印章不可以旋转。 
2. 不能把墨水印到纸外面。 
3. 纸上的同一个格子不可以印多次。 

## 样例 #1

### 输入

```
2
3 4 4 2
xx..
.xx.
xx..
x.
.x
x.
..
2 2 2 2
xx
xx
.x
x.
```

### 输出

```
TAK
NIE
```

# 题解

## 作者：Link_Space (赞：5)

一道比较水的模拟题，思路很好想，代码也很好写，码量并不大。

具体思路如下：遍历印章，找到印章中的第一个x并以这个x为参考系，将其他x与这个x的相对坐标存到一个数组之中。接下来就遍历需要印出的图案，每遇到一个x就立马以这个x为参考系，看看能否和印章吻合，如果不能的话立马跳出，说明这个图案永远无法由这个印章构成，如果能的话就将与印章吻合的所有x都变为.，然后继续比对，直至所有x都被印章吻合之后，说明这个图案可以被该印章构成。

以下是代码（略显繁琐，可以精简）
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 1e3 + 5;
const int M = 1e6 + 5;
char Map[N][N];
char Stamp[N][N];
int stax;
int stay;
struct Node{
    int x;
    int y;
}relative[M];
int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
        memset(relative, 0, sizeof relative);
        int n, m;
        scanf("%d%d", &n, &m);
        int a, b;
        scanf("%d%d", &a, &b);
        for (int i = 1; i <= n;i++)
            for (int j = 1; j <= m;j++)
                cin >> Map[i][j];
        bool flag = false;
        int cnt = 0;
        for (int i = 1; i <= a;i++)
        {
            for (int j = 1; j <= b;j++)
            {
                cin >> Stamp[i][j];
                if(Stamp[i][j]=='x')
                {
                    if(!flag)
                        stax = i, stay = j;
                    else
                        relative[++cnt].x = i - stax, relative[cnt].y = j - stay;
                    flag = true;
                }
            }
        }
        bool can = true;
        for (int i = 1; i <= n;i++)
        {
            for (int j = 1; j <= m;j++)
            {
                if (Map[i][j] == 'x')
                {
                    for (int k = 1; k <= cnt;k++)
                    {
                        int xx = i + relative[k].x;
                        int yy = j + relative[k].y;
                        if(xx<1||xx>n||yy<1||yy>m)
                        {
                            can = false;
                            break;
                        }
                        if(Map[xx][yy]!='x')
                        {
                            can = false;
                            break;
                        }
                    }
                    if(can)
                    {
                        for (int k = 1; k <= cnt;k++)
                        {
                            int xx = i + relative[k].x;
                            int yy = j + relative[k].y;
                            Map[xx][yy] = '.';
                        }
                    }
                }
                if(!can)
                    break;
            }
            if(!can)
                    break;
        }
        if(!can)
            puts("NIE");
        else
            puts("TAK");
    }
    return 0;
}
```


---

## 作者：Bring (赞：4)

## ~~觉得这题不配有蓝标记~~
### ~~纯的模拟~~
**首先，在图中最上方然后最左方的（即左上角）未染色点一定是由印章左上角的点盖上的**

然后就可以一一判定印章中剩余的点是否符合要求

可以用z数组存储印章中每一个点关于左上角的点的相对位置，以加快查找速度

具体看代码
```cpp
#include<iostream>
using namespace std;
#define Frn(i,a,b) for(int i(a);i<b;++i)
#define X z[k].x
#define Y z[k].y
#define R(a,n) ((a)>=0&&(a)<(n))//在图范围内判定
struct T{int x,y;}z[1000000];//z数组
int q,n,m,a,b,zn,tx,ty;//zn表示印章中有墨水的点的数量
char c;
bool g[1000][1000];
inline void wrk();
signed main() {
	cin>>q;
	while(q--)wrk();
	return 0;
}
inline void wrk(){
	zn=0,cin>>n>>m>>a>>b;
	Frn(i,0,n)Frn(j,0,m)cin>>c,g[i][j]=(c=='x');//1表示还未染色
	Frn(i,0,a)Frn(j,0,b){
		cin>>c;
		if(c=='x')z[zn++]={i,j};
	}//z[0]即为印章左上角坐标
	Frn(k,1,zn)z[k]={X-(z->x),Y-(z->y)};//计算关于z[0]的相对位置
	*z={0,0};//z[0]自己就是(0,0)了
	Frn(i,0,n)Frn(j,0,m)if(g[i][j]){//找到一个左上角
		Frn(k,0,zn){
			tx=i+X,ty=j+Y;//会被“盖”的坐标
			if(R(tx,n)&&R(ty,m)&&g[tx][ty])g[tx][ty]=0;//"盖"掉
			else{cout<<"NIE"<<endl;return;}
		}
	}
	cout<<"TAK"<<endl;
}
```

---

## 作者：_Ayanami_ (赞：2)

本题核心：

当前状态下最左上角的需要染的点只能印章上最左上角的有墨水的点来盖

这样就知道了印章上剩下的点所对应的位置

一个个判即可

不能印

- 纸上不需要印的点

- 纸上需要印但已印过的点

- 纸外面的点

（当印章超出纸但超出纸的部分上没有墨水也是合法的）

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int t,n1,n2,m1,m2,x,y,p,ax[1000001],ay[1000001];
//ax,ay记录印章上每一个有墨水的点与第一个有墨水的点的相对坐标
bool a[1001][1001];//记录这个点需不需要染黑（不需要染或已染过都记为假）
char s;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		p=0;//p记录印章上有墨水的点的数量
		x=y=-1;//x,y记录印章上第一个有墨水的点的坐标
		memset(a,0,sizeof(a));//先设为都不用染黑
		//不要忘了初始化
		scanf("%d%d%d%d",&n1,&m1,&n2,&m2);
		for(int i=0;i<n1;i++)
		{
			for(int j=0;j<m1;j++)
			{
				cin>>s;
				if(s=='x')
				{
					a[i][j]=1;//标出需染黑的点
				}
			}
		}
		for(int i=0;i<n2;i++)
		{
			for(int j=0;j<m2;j++)
			{
				cin>>s;
				if(s=='x')
				{
					if(x==-1)//如果还没记录第一个点坐标
					{
						x=i;
						y=j;
					}
					p++;//点数++
					ax[p]=i-x;
					ay[p]=j-y;//相对坐标
				}
			}
		}
		//从左上角开始扫
		for(int i=0;i<n1;i++)
		{
			for(int j=0;j<m1;j++)
			{
				if(a[i][j])//该点需要染但还没被染
				{
					for(int v=1;v<=p;v++)//一个个判
					{
						if(i+ax[v]<0||j+ay[v]<0)//是否把墨水印到纸外面
						{
							printf("NIE\n");
							goto Next;//跳出循环
						}
						else if(a[i+ax[v]][j+ay[v]])//该点需要被染
						{
							a[i+ax[v]][j+ay[v]]=0;
						}
						else//该点不需要被染
						{
							printf("NIE\n");
							goto Next;//跳出循环
						}
					}
				}
			}
		}
		printf("TAK\n");
		Next:;
	}
}
```
补充说明

关于goto语句的用法

~~貌似很少看别人用这个~~

在程序里的任意一个位置设下一个标记（名字不能重复）

用goto可以从同一个函数的任意一个地方~~战术跃迁~~跳到标记的位置
~~xjb跳真有意思~~

当碰上多重循环时显然break只能跳出其中一重，用goto则方便很多

[如果觉得窝讲得太菜了也可以看看其他人写的](https://blog.csdn.net/hankai1024/article/details/8011306)

[百度百科](https://baike.baidu.com/item/goto%E8%AF%AD%E5%8F%A5/7603004?fr=aladdin)

---

## 作者：yfct (赞：2)

这里纠正一下别的题解中一些错误（不准确）的描述：一定被印章左上角覆盖的点应该是棋盘最左、最上的**应该被染色的点**，而不是没染色的点。

具体做法的话，只需要模拟一下。把**应该被染色的点**用一个结构体存储起来，用类似广度优先搜索的写法判断每一个点是否能依照题意被覆盖即可，注意只是写法比较相似，此题并非搜索。

注意判断棋盘的边界，如果在边界外直接跳过。

由于是多组数据，因此每次操作结束之后一定要记得将相关变量清零，比如记录应该被染色的点的个数的变量cnt，以及记录是否应该被染色的bool数组col（color的简称）.

下面放一下代码。有不懂的地方欢迎来询问。

------------

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <cassert>
using namespace std;
int n,m,a,b,q;
const int maxn=1010;
char op;
inline int read() {
	char c=' ';
	int v=0,f=1;
	while(c<'0' || c>'9') {
		c=getchar();
		if(c=='-') f=-1;
	}
	while(c>='0' && c<='9') {
		v=(v<<3)+(v<<1)+c-'0';
		c=getchar();
	}
	return v*f;
}
struct node {
	int x,y;
}z[maxn*maxn];
int cnt;
bool col[maxn][maxn];
void input() {
	cnt=0;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			cin>>op;
			if(op=='x') col[i][j]=true;
			else col[i][j]=false;
		}
	}
	for(int i=1;i<=a;i++) {
		for(int j=1;j<=b;j++) {
			cin>>op;
			if(op=='x') z[cnt++]=(node){i,j};
		}
	}
}
bool inside(int vx,int n,int vy,int m) {
	return (vx<=n && vy<=m);
}
bool work() {
	for(int i=1;i<cnt;i++) z[i]=(node){z[i].x-z[0].x,z[i].y-z[0].y};
	z[0]=(node){0,0};
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			if(col[i][j]) {
				for(int k=1;k<cnt;k++) {
					int vx=i+z[k].x,vy=j+z[k].y;
					if(inside(vx,n,vy,m) && col[vx][vy]) col[vx][vy]=0;
					else return false;
				}
			}
		}
	}
	return true;
}
int main() {
	q=read();
	for(int i=1;i<=q;i++) {
		n=read();m=read();a=read();b=read();
		input();
		if(work()) printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
```

---

## 作者：Manjusaka丶梦寒 (赞：2)

可能这是我做过最简单的一道蓝题了(~~是谁乱评分~~)

一道相当简单的模拟题。

拿一个数组，记录一下印章上其他的点和第一个点的相对位置。

然后我们从上往下扫那张纸，第一个出现的点一定是最顶上的点，然后进行遍历可以印到的点，判断是否是'x'，是的话将其改变，如果不是的话说明是不合法的，跳出就好啦。

一定注意初始化啊。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
int T,n,m,a,b;
char s[1006][1006],c;
int posx,posy,dx[1000006],dy[1000006],tot;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d%d",&n,&m,&a,&b);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				cin>>s[i][j];
		for(int i=1;i<=a;i++)
		{
			for(int j=1;j<=b;j++)
			{
				cin>>c;
				if(!posx&&!posy&&c=='x')
				{
					posx=i,posy=j;
					continue;
				}
				if(c=='x')dx[++tot]=i-posx,dy[tot]=j-posy;
			}
		}
		bool flag=0;
		for(int i=1;i<=n;i++)
		{
			if(flag==1)break;
			for(int j=1;j<=m;j++)
			{
				if(flag==1)break;
				if(s[i][j]=='x')
				{
					for(int k=1;k<=tot;k++)
					{
						if(s[i+dx[k]][j+dy[k]]=='x')s[i+dx[k]][j+dy[k]]='.';
						else flag=1;
					}
				}
			}
		}
		if(flag)printf("NIE\n");
		else printf("TAK\n");
		tot=0;posx=0;posy=0;
	}
}
```

---

## 作者：Strelitzia (赞：1)

[题目床送门](https://www.luogu.com.cn/problem/P3585)

---

模拟，用目标图的左上角匹配匹配图的左上角。

可以预存下匹配图上是 x 的点，最后直接匹配。


```cpp
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<typename T>void Swap(T &x,T &y) {T z = x;x = y;y = z;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>T Abs(T x) {return x < 0 ? -x : x;}

const int N   = 10000  + 5;

int n,m,a,b,T;
struct node {
	int x,y;
	node() {}
	node(int X,int Y) {x = X;y = Y;}
}p[N * N];
bool c[N][N],d[N][N];
char s[N][N],t[N][N];

int main() {
	read(T);
	while (T --) {
		int tots = 0,tott = 0;
		read(n);read(m);read(a);read(b);
		for (int i = 0 ; i < n ; ++ i) scanf("%s",s[i]);
		for (int i = 0 ; i < a ; ++ i) scanf("%s",t[i]);
		for (int i = 0 ; i < n ; ++ i)
			for (int j = 0 ; j < m ; ++ j) tots += c[i][j] = s[i][j] == 'x';
		int cnt = 0;
		for (int i = 0 ; i < a ; ++ i)
			for (int j = 0 ; j < b ; ++ j) if (t[i][j] == 'x') tott ++,p[++ cnt] = node(i - 1,j - 1);
		bool flag = 1;
		if (tots && !tott || tots % tott) {
			puts("NIE");
			continue;
		}
		for (int i = 0 ; i < n ; ++ i) {
			for (int j = 0 ; j < m ; ++ j) {
				if (c[i][j]) {
					int upl = i - p[1].x;
					int upr = j - p[1].y;
					for (int k = 1 ; k <= cnt ; ++ k) {
						int xx = upl + p[k].x,yy = upr + p[k].y;
						if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
							flag = 0;
							break;
						}
						c[xx][yy] ^= 1;
						if (c[xx][yy]) {
							flag = 0;
							break;
						}
					}
				}
				if (!flag) break;
			}
			if (!flag) break;
		}
		puts(flag ? "TAK" : "NIE");
	}
	return 0;
}
```

---

## 作者：小塘空明 (赞：1)

模拟题

**（1）：**为了防止印到外面去，每次用印章最左上角的点去染矩阵左上角未被染的点。

**（2）：**如果每次枚举矩阵需要浪费大量时间，用队列记录矩阵和印章中黑的点，把枚举从变成o（n）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
typedef long long ll;
const ll size=1e6+10,maxn=1e3+10;
ll t,n,m,a,b,top,cnt,flag;char s[maxn][maxn];
ll qx[size],qy[size],mp[maxn][maxn],xx[size],yy[size];
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
bool check(ll x,ll y){
	for(ll i=1;i<=cnt;i++){
		ll tx=x+xx[i],ty=y+yy[i];
		if(tx<1||tx>n||ty<1||ty>m) return 0;
		if(!mp[tx][ty]) return 0;
		mp[tx][ty]=0;
	}
	return 1;
}
int main(){
	t=read();
	while(t--){
		memset(mp,0,sizeof(mp));
		top=cnt=0;
		n=read();m=read();a=read();b=read();
		for(ll i=1;i<=n;i++){
			scanf("%s",s[i]+1);
			for(ll j=1;j<=m;j++){
				if(s[i][j]=='x'){
					mp[i][j]=1;
					qx[++top]=i,qy[top]=j;
				}
			}
		}
		flag=0;
		ll tx=0,ty=0;
		for(ll i=1;i<=a;i++){
			scanf("%s",s[i]+1);
			for(ll j=1;j<=b;j++){
				if(s[i][j]=='x'){
					if(!flag) tx=i,ty=j,flag=1;
					xx[++cnt]=i-tx;yy[cnt]=j-ty;
				}
			}
		}
		flag=1;
		for(ll i=1;i<=top;i++){
			if(mp[qx[i]][qy[i]]){
				if(!check(qx[i],qy[i])){
					printf("NIE\n");flag=0;break;
				}
			}
		}
		if(flag) printf("TAK\n");
	}
	return 0;
}
```

---

## 作者：xun薰 (赞：1)

模拟题

从题目中可以看出，一定要让印章的左上角对应目前n\*m方格中未染色的左上角。

因为要求不能重复染色，可以每染完一个格子就把它赋值为0.（待染色为1）。

开始纯模拟，没有任何优化的代码。

加了个读入优化还是T了两个点，3000ms+









```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1022
using namespace std;
int n,m,a,b,fa,fb,cnt,q;
int map[N][N],yz[N][N];
char s[N];
inline int read(int &x){
    char ch=getchar();x=0;int f=1;
    for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
    for(;isdigit(ch);ch=getchar())x=x*10+ch-'0';
    x=x*f;
}
void init(){
    memset(map,0,sizeof(map));
    memset(yz,0,sizeof(yz));
    cnt=0;fa=0;fb=0;
}
bool check(int x,int y){
    int xx=x-fa,yy=y-fb;
    for(int i=1;i<=a;i++){
        for(int j=1;j<=b;j++){
            if(yz[i][j]==0)continue;
            int rx=xx+i,ry=yy+j;
            if(rx<0||ry<0||rx>n||ry>m||map[rx][ry]==0)return false;
            map[rx][ry]=0;cnt--;
        }
    }
    return true;
}
int main(){
    scanf("%d",&q);
    while(q--){
        init();bool flag=false;
       // scanf("%d%d%d%d",&n,&m,&a,&b);
      //  n=read();m=read();a=read();b=read();
       read(n);read(m);read(a);read(b);
        for(int i=1;i<=n;i++){
            scanf("%s",s+1);
            for(int j=1;j<=m;j++)
             if(s[j]=='x')map[i][j]=1,cnt++;
        }
        for(int i=1;i<=a;i++){
            scanf("%s",s+1);
            for(int j=1;j<=b;j++){
                if(s[j]=='.')continue;
                if(!fa&&!fb)fa=i,fb=j;
                yz[i][j]=1;
            }
        }
        for(register int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(map[i][j]){
                    if(check(i,j)==0){
                        printf("NIE\n");
                        flag=true;break;
                    }
                    if(cnt==0){
                        printf("TAK\n");
                        flag=true;break;
                    }
                }
            }
            if(flag)break;
        }
    }
    return 0;
}
```
看了题解...
想到以前做靶型数独这个题，把未填数的格子放到一个结构体里。

w[i].x,w[i].y分别表示第i个没有填数格子的横纵坐标。

这样的好处是不用遍历整张图，就找到了没填数的格子。

这个题也是这样....

上面的代码不仅遍历了一遍要染色的图，还遍历了整个印章。

最差的情况是10^12...遍历要染色的10^6,印章10^6。

所以把要染色的点和能染色的点抽离出来，放到结构体里。

很好的一个优化，188ms。

ps:某一行后面+***，可以这样理解..

yz[1].x+xx=x,yz[1].y+yy=y.

说明印章的左上角的可以染色的点，要对应

n\*m的棋盘要加xx和yy，那么其他可以染色的点也要加这两个数

来对应他们要染色的点。

代码：







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1009
using namespace std;
int n,m,a,b,cnt_black,yz_black,q;
char s[N];
int map[N][N];
struct Make_Black{
    int x,y;
}gz[N*N],yz[N*N];
bool check(int x,int y){
    int xx=x-yz[1].x,yy=y-yz[1].y;  //*** 
    for(int i=1;i<=yz_black;i++){  
        int nx=yz[i].x+xx,ny=yz[i].y+yy;
        if(nx<0||nx>n||ny<0||ny>m||map[nx][ny]==0)return false;
        map[nx][ny]=false;
    }
    return true;
}
int main(){
    scanf("%d",&q);
    while(q--){
        bool flag=false;
        cnt_black=yz_black=0;
        scanf("%d%d%d%d",&n,&m,&a,&b);
        memset(map,0,sizeof(map));
        for(int i=1;i<=n;i++){
            scanf("%s",s+1);
            for(int j=1;j<=m;j++)
             if(s[j]=='x'){
                 gz[++cnt_black].x=i;gz[cnt_black].y=j;
                 map[i][j]=true;
             }
        }
        for(int i=1;i<=a;i++){
            scanf("%s",s+1);
            for(int j=1;j<=b;j++)
             if(s[j]=='x')yz[++yz_black].x=i,yz[yz_black].y=j;
        }
        for(int i=1;i<=cnt_black;i++){
            if(map[gz[i].x][gz[i].y])
             if(check(gz[i].x,gz[i].y)==0){
                 flag=true;
                 printf("NIE\n");break;
             }
        }
        if(!flag)printf("TAK\n");
    }
    return 0;
}
```

---

## 作者：Paperback_Writer (赞：0)

把纸和印章的格子相对位置都用**链表**串起来，就能把复杂度降为n^2！

必须每次都从最左上角未被印上的格子开始，然后与印章左上角格子开始挨个匹配。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int tx,ty,num,n,m,a,b,cou,top;
int map[1010][1010],gzx[1000010],gzy[1000010],yzx[1000010],yzy[1000010];
char ch[1010];
bool flag;
bool judge(int x,int y) 
{
    for(int i=1;i<=cou;i++)
    {
        tx=x+yzx[i];ty=y+yzy[i];//从纸上左上角格子开始，依次判断印章印上去会发生什么 
        if(tx>n||ty>m||!tx||!ty)//判断是否印到格子外面 
            return 0;
        if(!map[tx][ty])//判断是否印错地方 
            return 0;
        else 
            map[tx][ty]=0;//防止印在重复的位置，把印过的格子当做空格子 
    }
    return 1;
}
int main()
{
    scanf("%d",&num);
    while(num--)
    {
        memset(map,0,sizeof(map));
        scanf("%d%d%d%d",&n,&m,&a,&b);
        top=cou=0;
        for(int i=1;i<=n;i++)//输入格子们 
        {
            scanf("%s",ch+1);
            for(int j=1;j<=m;j++)
                if(ch[j]=='x')
                {
                    top++;
                    gzx[top]=i;//存纸上的格子 
                    gzy[top]=j;
                    map[i][j]=top; 
                }
        }
        for(int i=1;i<=a;i++)
        {
            scanf("%s",ch+1);
            for(int j=1;j<=b;j++)
                if(ch[j]=='x')
                {
                    if(!cou)
                        tx=i,ty=j;//找到最左上角的格子 
                    cou++;
                    yzx[cou]=i-tx;//存印章中格子#相对#左上角格子的位置 
                    yzy[cou]=j-ty;
                }
        }
        flag=0;
        for(int i=1;i<=top;i++)
            if(map[gzx[i]][gzy[i]])//每次找未被印的最左上角的格子 
                if(!judge(gzx[i],gzy[i]))
                {
                    puts("NIE");
                    flag=1;break;
                }
        if(!flag)
        puts("TAK");
    }
    return 0;
}
```

---


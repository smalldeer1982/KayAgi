# [COCI 2006/2007 #2] KOLONE

## 题目描述

当蚂蚁移动时，蚂蚁排成一行，每个蚂蚁除了第一个蚂蚁都在另一个蚂蚁后面。众所周知，当两排蚂蚁在相反的方向上移动时，在一条太窄的通道中，两排都不能通过。一种理论认为，在这种情况下，蚂蚁会跳过对方。每隔一段时间，每一个蚂蚁都会跳过（或跳过去，就像他们同意的一样）蚂蚁在自己前面，这样两个蚂蚁交换位置，但是只有当另一只蚂蚁朝相反的方向移动时。在T秒后找到蚂蚁的顺序。

## 样例 #1

### 输入

```
3 3
ABC
DEF
0```

### 输出

```
CBADEF```

## 样例 #2

### 输入

```
3 3
ABC
DEF
2```

### 输出

```
CDBEAF```

## 样例 #3

### 输入

```
3 4
JLA
CRUO
3```

### 输出

```
CARLUJO```

# 题解

## 作者：QianianXY (赞：15)

一道纯模拟题。

将两队合并为一个字符串，用一个数组记录蚂蚁的方向，左队为0，右队为1。每一个时间点，两个两个字符地扫一遍字符串。由于0只能往右走，1只能往左走，所以只要在当前的两个字符中，第一个是0，第二个是1，就执行交换（同时交换方向数组和字符串），并且扫描指针加2。否则指针加1。

需要注意的是队伍合并时1左队顺序需要翻转。

~~自我感觉讲得比较明白了，~~ 下贴代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n1, n2, t, a[100005], len;
string s1, s2, s3;
int main()
{
	cin >> n1 >> n2 >> s1 >> s2 >> t;
	for (int i = 0; i < s1.size() / 2; i++) swap(s1[i], s1[s1.size() - 1 - i]);
	s3 = s1 + s2; len = s3.size();
	for (int i = s1.size(); i < len; i++) a[i] = 1;
	for (int i = 0; i < t; i++)
	{
		int j = 0;
		while (j < len)
		{
			if (!a[j] && a[j + 1]) swap(a[j], a[j + 1]), swap(s3[j], s3[j + 1]), j += 2;
			else j++;
		}
	}
	cout << s3 << endl;
	return 0;
}
```


---

## 作者：wrehtg (赞：9)

看到T<=50，直接开始模拟，下面是代码

    #include <iostream>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    struct node{
        char c;
        int d,turn;
    }a[105];//c代表这个蚂蚁的字母；d是方向（direction）；turn标记这一个单位时间这只蚂蚁有没有走，最无脑的解决方法~~~
    int main(){
        int n1,n2,t,i;
        cin>>n1>>n2;
        for(i=n1;i>=1;i--)//注意这个，输入的左边是队首，而队首是向右的
        {
            cin>>a[i].c;
            a[i].d=1;
        }
        for(i=n1+1;i<=n1+n2;i++)
        {
            cin>>a[i].c;
            a[i].d=-1;
        }
        cin>>t;
        while(t--)
        {
            for(i=1;i<=n1+n2;i++) a[i].turn=1;//无脑，反正50
            for(i=2;i<=n1+n2;i++)
            {
                if(a[i].turn==1 && a[i-1].turn==1 && a[i].d==-1 && a[i-1].d==1)//判断是否反向的蚂蚁怼一块了，而且有没有走过
                {
                    a[i].turn=a[i-1].turn=0;
                    swap(a[i],a[i-1]);
                }
            }
        }
        for(i=1;i<=n1+n2;i++)
            cout<<a[i].c;
        return 0;
    }


---

## 作者：Mine_King (赞：5)

安利[博客](https://www.luogu.com.cn/blog/195331/)，若LeTaX挂了，请点击“在 Ta 的博客查看”

观察数据范围，发现最多有$26$只蚂蚁（只有$26$个字母），而$T \le 50$，可以考虑模拟。  
根据题意，对于每一秒，我们可以枚举两只相邻的蚂蚁。若一个往右走一个往左走，那么交换两只蚂蚁的位置。  
具体实现，我们可以先把两个字符串合并成一个，注意第一个字符串要翻转。也就是原来是这样;
![](https://i.loli.net/2020/06/01/l9cSeEMZzsqmfoL.jpg)
我们要把他变成这样：
![](https://i.loli.net/2020/06/01/zNCT4AlLIY3fjR1.jpg)
*注：棕色的箭头是蚂蚁的方向，圆圈代表蚂蚁*  
然后，我们再标记他们的方向：让往右走的为$1$，往左走的为$0$。在跳跃的时候交换字母和方向即可。

**code：**
```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
int n,m,T;
string s1,s2,now;
int num[26];
int main()
{
	scanf("%d%d",&n,&m);
	cin>>s1>>s2;
	scanf("%d",&T);
	for(int i=0;i<s1.length()/2;i++) swap(s1[i],s1[s1.length()-i-1]);//翻转第一个字符串
	now=s1+s2;//合并两个字符串
	for(int i=0;i<s1.length();i++) num[i]=1;//标记方向
	for(int i=1;i<=T;i++)//按题意模拟
	{
		int j=0;
		while(j<now.length()-1)
			if(num[j]&&!num[j+1])//前面的往右后面的往左
			{
				swap(num[j],num[j+1]);
				swap(now[j],now[j+1]);
                //交换
				j+=2;//注意这时j要+2（虽然加一也一样
			}
			else j++;
	}
	cout<<now;//最后输出结果
	return 0;
}
```

---

## 作者：_ZZH (赞：4)

我们记录每个蚂蚁的运动方向，数据很小，考虑枚举。
模拟每一秒，对于每一只蚂蚁，若它的朝向向右且下一只蚂蚁朝向向左，那么我们就可以交换它们。
```
#include<iostream>
using namespace std;
int n,t,now[27],n1,n2,c[27];
struct cym{
    int num;
    char w;
}a[27];
int main()
{
    cin>>n1>>n2;
    for(int i=n1;i>=1;i--)
    {
        char x;
        cin>>x;
        c[i]=1;
        a[i].num=i;
        a[i].w=x;
    }//输入要注意 
    for(int i=n1+1;i<=n1+n2;i++)
    {
        char x;
        cin>>x;
        c[i]=-1;
        a[i].num=i;
        a[i].w=x;
    }
    n=n1+n2;
	cin>>t;
    while(t--)
    for(int i=1;i<n;i++)
    {
        if(c[a[i].num]==1&&c[a[i+1].num]==-1)
        {
            swap(a[i],a[i+1]);
            i++;	
        }
    }
    for(int i=1;i<=n;i++)
    cout<<a[i].w;
}
```

---

## 作者：WilliamFranklin (赞：3)

我发现其他题解都是用模拟做的，于是我来试一试**不用模拟**行不行。

这道题的题意前面几位大佬已经详细解说了，在此，我就不浪费大家的时间在这里再讲一遍了。

下面我们来根据题意找发现。我们根据题意可以发现：第一秒只有两队中的第一只蚂蚁相互交换位置。而第二秒，是第一队的第二只蚂蚁和第二队的第一只蚂蚁交换位置，第一队的第一只蚂蚁和第二队的第二只蚂蚁交换位置，以此类推后面的。前面我们是按时间看的，而这次我们来以一只蚂蚁为一个单位看，发现第一队的第一只蚂蚁最多经历了 $t$ 次交换位置（这里的 $t$ 是题目中的时间），第一队的第二只蚂蚁最多经历了 $t-1$ 次交换位置 $\cdots$ $\cdots$ 得出第一队的第 $i$ 只蚂蚁最多经历了 $t-i+1$ 次交换位置。那这可不可以等价于第二队的蚂蚁不动，第一队的第 $i$ 蚂蚁跳过了 $t-i+1$ 只第二队的蚂蚁呢？当然是可以的，因为第二队的蚂蚁不动，第一队的蚂蚁每跳一次不都相当于和它前面的那只蚂蚁交换了一下位置嘛。所以我们可以得出：第一队的第 $i$ 只蚂蚁在经过 $t$ 秒后，跳到的是第二队的第 $t-i+1$ 只蚂蚁的前面。

好了，贴代码。

### AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
string a, b;
int main(){
    int n, m;
    cin>>n>>m;
    string c = "";
    cin>>a>>b;
    int sum = m - 1;
    int t;
    cin>>t;
    bool f = 0;
    for(int i = 0; i < n; i++){
        for(int j = sum; j >=  (t - i + 1) - 1 && j >= 0; j--){
            c += b[j];
            sum--;
        }
        c += a[i];
    }
    for(int i = sum; i >= 0; i--){
        c += b[i];
    }
    for(int i = n + m - 1; i >= 0; i--){
        cout<<c[i];
    }
    return 0;
} 
```


---

## 作者：Tzs_yousa (赞：3)

### 模拟好题
闲扯：是一道比较不错的模拟题，早期练习模拟可以做一做，模拟其实有时候很吃香。

那么就来说一说代码吧，就直接模拟就行，话不多说上代码。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n1, n2, t, dir[51]//dir是存它的方向;
char f;
struct node{
    int num;
    char c;
}a[51];//num就存它的序列号，c存当前字母 
signed main()
{
	ios::sync_with_stdio(false);
	cin >> n1 >> n2;
	for (int i = n1; i >= 1; i--)//注意输入的顺序是反着来的 
    {
        char x;
        cin >> f;
        dir[i] = 1;//正向 
        a[i].num = i;
        a[i].c = f;
    }
    for (int i = n1 + 1; i <= n1 + n2; i++)
    {
        cin >> f;
        dir[i] = -1;//反向 
        a[i].num = i;
        a[i].c = f;
    }
	cin >> t;
    while(t--)//总共进行t操作 
    {
    	for (int i = 1; i < n1 + n2; i++)
    	{
     	  	if(dir[a[i].num] == 1 && dir[a[i + 1].num] == -1)//如果是对面而来，那就跳 
       	 	{
       	    	swap(a[i], a[i + 1]);
            	i++;	
        	}
    	}
	}
    for (int i = 1; i <= n1 + n2; i++)
    	cout << a[i].c;
    return 0;
}
```

完结撒花！

---

## 作者：philosopherchang (赞：2)

T<=50,直接模拟，但要注意如果一支队伍中的蚂蚁到了另一只队伍的一端时，就要停止交换。

代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
struct node{
	char s;//存字符
	int fangxiang;//拼音不会看不懂吧...
	bool b;//存是否被使用过
}c[55];
int n,m,t;
int main()
{
	cin>>n>>m;
	for(int i=n;i>=1;i--)
	{
		cin>>c[i].s;
		c[i].fangxiang=1;//方向初始化
	}
	for(int i=n+1;i<=n+m;i++)
	{
		cin>>c[i].s;
		c[i].fangxiang=0;
	}
	cin>>t;
	int ii=1,jj=n+m;//存可交换队伍大小
	for(int i=1;i<=t;i++)
	{
		for(int i=ii;i<=jj;i++)
		{
			c[i].b=0;//初始化可交换的蚂蚁
		}
		for(int i=ii;i<=jj;i++)
		{
			if(c[i].fangxiang!=c[i+1].fangxiang&&c[i].b==0&&c[i+1].b==0)
			{
				c[i].b=1;//定为不可交换
				c[i+1].b=1;
				swap(c[i],c[i+1]);
				if(c[i].fangxiang==0&&i==ii)
				{
					ii++;//向左走的蚂蚁到左端点后不能再交换，所以队伍长度减一。
				}
				if(c[i+1].fangxiang==1&&i+1==jj)
				{
					jj-=1;向右走的蚂蚁到右端点后不能再交换，队伍长度减一。
				}
			}
		}
	}
	for(int i=1;i<=n+m;i++)
	{
		cout<<c[i].s;//输出
	}
	return 0;
}
```

---

## 作者：jxbe6666 (赞：0)

### 思路： 模拟
将两队合并为一个字符串，用一个数组记录蚂蚁的方向，左队为 0，右队为 1。每一个时间点，两个两个字符地扫一遍字符串。由于 0 只能往右走，1 只能往左走，所以只要在当前的两个字符中，第一个是 0，第二个是 1，就执行交换（同时交换方向数组和字符串），并且扫描指针加 2。否则指针加 1。  
 **需要注意的是队伍合并时 1 左队顺序需要翻转**。  
$0\le T\le50$ 不会超时。

-----

### AC 代码：
-----
```c++
#include <bits/stdc++.h>
using namespace std;
int n1, n2, t, a[100005];
string s1, s2, s3;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0); // 关流
    cin >> n1 >> n2 >> s1 >> s2 >> t;
    int l1 = s1.size(), l2 = s2.size(); //事先定义长度
    for (int i = 0; i < l1 / 2; i++)
        swap(s1[i], s1[l1 - 1 - i]);
    s3 = s1 + s2; //合并
    int l3 = s3.size();
    for (int i = l1; i < l3; i++)
        a[i] = 1;
    for (int i = 0; i < t; i++)
    {
        int j = 0;
        while (j < l3)
        {
            if (!a[j] && a[j + 1])
                swap(a[j], a[j + 1]), swap(s3[j], s3[j + 1]), j += 2; //注意：j要加2
            else
                j++;
        }
    }
    cout << s3;
    return 0;
}
```


---

## 作者：Dfkuaid (赞：0)

找到**合适的翻译**后，理解题意并不难，因为数据范围很小（$T < 50$），是一道赤裸裸的**模拟**，直接模拟每一秒钟蚂蚁的状态

# 输入
简单分析样例后我们发现，输入时给定的向右走的蚂蚁的顺序，**并不是**我们以上帝视角看见的顺序（一整排蚂蚁从左向右的顺序），如：   
输入的数据为 
```
ABCD
EFG
```
那这一排蚂蚁**实际的顺序**是
```
DCBAEFG
```
也就是说，我们在读入第一排蚂蚁的顺序后，要先将其**调换位置**
   
我们要实现上面的想法，需要在输入时找一个替身，如下
``` cpp
cin >> s1_t >> s2; //s1_t为替身
for (int i = 0;i < n1;i ++)
  s1 += s1_t[n1 - 1 - i]; //交换顺序
s = s1 + s2; //string类可以直接使用 '+' 进行连接
```

# 模拟
## 初始化
我们如何区分每只蚂蚁走的**方向**呢？很简单，给每一个蚂蚁附一个值 $M$，$M_i = 0$ 表示蚂蚁 $i$ 向右走，$M_i = 1$ 则表示蚂蚁 $i$ 向左走，为了方便后面的操作，我们可以**直接用字符作为数组的下标**，就要用到STL中的一大利器—— $Map$，在最初输入结束后对 $M_i$ 进行赋值
``` cpp
map <char,int> m;
for (int i = 0;i < n1;i ++)
  m[s1[i]] = 0;
for (int i = 0;i < n2;i ++)
  m[s2[i]] = 1;
```

## 实现
每一次交换位置，我们可以看为**向左走的蚂蚁不动**，只有**向右走的蚂蚁动**，那么，每次判断时只用去找 $M_i = 0$ 的蚂蚁即可  
每一次（秒）自左向右查看整个字符串 $S$，那么查看字符 $S_i(0 \leqslant i < length(S))$ 时，有**以下两种**状态及结果：
 - $M_{S_i}$ 为 $0$ ，且 $M_{S_{i + 1}}$ 为 $1$，那么两者**需要交换位置**
 - $M_{S_i}$ 为 $0$ ，但 $M_{S_{i + 1}}$ 也为 $0$，那么 $S_i$ **位置不变**

得到以上分析，完整的代码就不难写出来了

# 完整代码

``` cpp
#include <iostream> //头文件
#include <cstdio>
#include <cstring>
#include <map>
using namespace std;

int n1,n2,t;
string s1_t,s1 = "",s2,s;

map <char,int> m; //M储存方向

int main(){
	scanf("%d%d",&n1,&n2);
	cin >> s1_t >> s2;
	for (int i = 0;i < n1;i ++) //注意输入方向
	  s1 += s1_t[n1 - 1 - i];
	s = s1 + s2;
	for (int i = 0;i < n1;i ++) //赋值蚂蚁的行进方向
	  m[s1[i]] = 0;
	for (int i = 0;i < n2;i ++)
	  m[s2[i]] = 1;
	cin >> t;
	string tmp = s; //替身使者
	while (t --){
		for (unsigned int i = 0;i < s.length();i ++) //遍历整排蚂蚁
		  if (!m[s[i]] && m[s[i + 1]]){ //如果两者方向相反
		  	tmp[i] = s[i + 1]; //交换位置
		  	tmp[i + 1] = s[i];
		  }
		  else if (!m[s[i]])
		    tmp[i] = s[i];
          //在这里，如果第一个条件不符合，但这只蚂蚁向右走，
          //则下一只蚂蚁一定也向右走，位置不需要改变
		s = tmp; //更新 S
	}
	cout << s;
	return 0; //完结撒花
}
```


---


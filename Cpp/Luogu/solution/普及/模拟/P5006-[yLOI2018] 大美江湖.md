# [yLOI2018] 大美江湖

## 题目背景

> 细雪飘落长街，枫叶红透又一年。  
> 不只为故友流连，其实我也恋长安。   
> 听门外足音慢，依稀见旧时容颜。  
> 故事几经悲欢，结局都与你有关。

——银临《大美江湖》

本题原名《空间复杂度》。

## 题目描述

扶苏听着《大美江湖》，在剑三里控制着他的人物炮姐来到了长安。 

长安城中有一个任务，需要扶苏进入地下的机关道，机关道是的地图一个 $n$ 行 $m$ 列的矩形方格图，每个方格内部都有一些怪物或者药水。扶苏操控着炮姐在机关道中游荡。有些时候他希望问问你他的角色一扶苏一有多少攻击力、防御力以及丢失了多少血量。 

地图中共有三种药水和一种怪物，分别用字符 `R`，`Q`，`Y`，`M` 代表。其中：

- 字符 `R` 代表生命药水，可以减少炮姐丢失的 $10$ 点 血量 $HP$。如果本身损失的 $HP$ 不大于 $10$，则损失的血量会变成 $0$。
- 字符 `Q` 代表力量药水，可以增加炮姐 $5$ 点攻击力 $ST$。
- 字符 `Y` 代表防御药水，可以增加炮姐 $5$ 点防御力 $DE$。
- 字符 `M` 代表怪物，会对炮姐造成伤害。

每只怪物都有三个属性，分别是血量 $HP_0$，攻击力 $ST_0$，防御力 $DE_0$。为了~~降低验题人工作量~~题目难度，所有怪物的属性都是相同的。

一旦走到怪物格，遭遇战将开始。扶苏一定会打死怪物，但是怪物也会对扶苏造成一定的伤害。具体的，怪物对扶苏造成的伤害为

$$\max(1, \left\lceil \frac{HP_0}{\max(1, ST - DE_0)}\right\rceil \times \max(1, ST_0 - DE))$$

其中 $\max(a, b)$ 代表取 $a$ 和 $b$ 中较大的数，$\lceil x \rceil$ 代表**不小于** $x$ 的最小整数。下标为 $0$ 的值代表怪物的参数，不带下标值的为角色的参数。

你会收到 $q$ 次操作，每次操作要么是一次查询，要么是一次移动。 

对于移动，你会再获得一个数字参数，这个参数只可能是 $1/2/3/4$ 其中的一个，代表炮姐向地图的**左/右/上/下**移动。向上移动代表角色所在的行数减一，列数不变，其他方向类似。

对于查询，需要你输出炮姐损失了多少血量，以及当前的攻击力和防御力分别是多少。

请注意，如果多次进入同一个格子，那么格子上的药水会被重复拾取，小怪也会再次出现。即你可以认为离开一个格子以后该格子会恢复原状。

请注意，如果初始位置有怪物，也不会发生战斗，如果初始位置有药水，也不会将之捡拾。

## 说明/提示

#### 数据规模与约定

| 测试点编号 |    $n$     |    $m$     |     $q$     |      特殊性质      |
| :--------: | :--------: | :--------: | :---------: | :----------------: |
|    $1$     |    $=1$    |    $=1$    |    $=0$     |         无         |
|   $2,3$    |    $=1$    | $\leq 10$  | $\leq 1000$ |         无         |
|   $4, 5$   |    $=1$    |    $=1$    | $\leq 1000$ |   保证 $op = 1$    |
|  $6,7,8$   | $\leq 100$ | $\leq 100$ | $\leq 10^4$ | 保证地图中没有怪物 |
|  $9, 10$   | $\leq 100$ | $\leq 100$ | $\leq 10^4$ |         无         |

对于全部的测试点，保证：

- $1 \leq n, m \leq 100$，$0 \leq q \leq 10^4$。
- $0 \leq ST_0, DE_0, HP_0, ST, DE \leq 100$。
- $1 \leq op \leq 2$，$1 \leq d \leq 4$。
- $C_{i, j}$ 只可能是 `.`，`R`，`Q`，`Y`，`M` 其中之一。
- 保证人物移动过程中的任何时刻，所在行数都是不大于 $n$ 的正整数，所在列数都是不大于 $m$ 的正整数。

## 样例 #1

### 输入

```
5 5
MMMMM
RRRRR
QQQQQ
YYYYY
.....
5 5 5
5 1
10 10
8
2 3
1
2 3
2 3
2 3
1
2 2
1```

### 输出

```
0 10 15
1 15 15
2 15 15
```

# 题解

## 作者：翼德天尊 (赞：25)

**一道看似很困难，实际上只是纯模拟的“火”题**

[题目传送门](https://www.luogu.com.cn/problem/P5006)

来吧，跟随我的脚步，带你A了这道题（当然，不要ctrl+c哦）！


------------
### STEP 1 提取主要条件

**1**.给你一幅图，各个字母的特殊功效如下其中如果遇到：

R：角色扣的血量 hp - 10（hp > = 0)

Q：角色的攻击力 st + 5 

Y：角色的防御力 de + 5

M：角色将会扣血（公式如题）

**2**.已知每个敌人的属性（ hp , st , de ）以及角色的属性（ x , y , hp , st , de )

**3**.有q个事件，分为两种事件类型：

第一种：查询（ 即输出角色的 hp , st , de )

第二种：移动：1、2、3、4分别对应左右上下。
移动后，进行条件1的操作。

**你，明白了吗？是不是so easy?!**


------------
### STEP 2 AC代码及完整注释（超短的哦）
```c
#include <bits/stdc++.h>//美丽的万能头
using namespace std;
#define maxn(a,b) ((a)>(b)?(a):(b)) 
//自己定义一个取最大值，这样可以支持浮点和整形相比较
int n,m,q,w;//分别储存地图的长和宽，时间的个数，以及一个用来暂存的变量
char ma[101][101];//储存地图
int dx[5]={0,0,0,-1,1};
int dy[5]={0,-1,1,0,0};//移动数组
struct node{
	int hp,st,de;
}gw;//敌人的信息
struct node1{
	int hp,st,de,x,y;
}js;//角色的信息
int main(){
	scanf("%d %d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%s",ma[i]+1);
	scanf("%d %d %d\n%d %d\n%d %d\n%d",&gw.hp,&gw.st,&gw.de,&js.x,&js.y,&js.st,&js.de,&q);
	//正常输入
	while (q--){
    	scanf("%d",&w);//输入事件类型
    	if (w==1) printf("%d %d %d\n",js.hp,js.st,js.de);//如果为1就打印角色属性
    	if (w==2){
			scanf("%d",&w);//如果为2就移动
			js.x+=dx[w];js.y+=dy[w];//移动对应的方向
			if (ma[js.x][js.y]=='R') js.hp=maxn(js.hp-10,0);
			if (ma[js.x][js.y]=='Q') js.st+=5;
			if (ma[js.x][js.y]=='Y') js.de+=5;
			int b1=ceil(double(gw.hp/maxn(1.0,js.st-gw.de)));
			int b2=maxn(1,gw.st-js.de);//将算式的两部分分开来算不容易出错
			if (ma[js.x][js.y]=='M') js.hp+=maxn(1,b1*b2);
            //发生事件
		}
	}
	return 0;//好习惯++
}
```


------------
### STEP 3 完结撒花！

看完本篇题解，你是否有些恍然大悟呢？如果还有不懂的地方，欢迎在评论区回复，我会第一时间回复哒！

如果已经明白了，就点个赞纪念一下你的成长吧！

---

## 作者：一扶苏一 (赞：15)

验题人来发一波OOP的写法……其实主要是针对下面的题解对 ``ceil`` 函数的说法进行一些**纠正和辟谣**

首先是C以及C++标准有关函数参数中表达式类型的规定：

如果一个函数的参数是一个表达式，则**先按照表达式的类型转换规定计算出返回值，再将返回值强制转换成函数参数的类型**。

这个规定用在本题的结果是，如果一个函数的参数为 ``double``，而在调用该函数的时候该参数为两个 ``int`` 相除，那么会先按照 ``int`` 做除法的法则计算出答案，再将答案转换成 ``double``，作为函数的参数。

这样在使用 ``ceil`` 函数时就会出现一些问题：我们都知道对于整形做除法的返回值是一个整数，为商的下取整结果。也就是说这个商**已经是一个下取整的整数了**，我们再将它放到 ``ceil`` 函数里面去，相当于对一个整数上取整，当然会得到错误的结果。

举个例子：我们调用 ``ceil(5 / 3)``，会先计算 ``5 / 3 = 1``，按照这个结果将 ``1`` 带入函数，相当于调用 ``ceil(1)``，答案当然是 ``1``，于是就GG了。

考虑我们应该如何避免这个问题：手写取整函数当然是可以的，但是不够优美。我们考虑C/C++对于有关浮点数(``long double``,``double``,``float``)除法的规定：当除数或被除数**至少一个为浮点数**时，先**将除数和被除数都强制转换成浮点型，再做除法**，返回值为一个浮点型。所以我们只要将**被除数强制转换成浮点数**即可。一种优美的写法是 ``1.0 * a / b``。根据乘法的规定，**浮点型和整形做乘法，返回值为浮点型**，而 ``1.0``是一个浮点型，于是被除数 ``1.0 * a`` 变成了一个**浮点型**，根据上面的分析，上式的结果就是一个正常的浮点数了。

还是以 ``ceil(1.0 * 5 / 3)`` 为例，先计算 ``1.0 * 5``，返回值为 ``5.0`` 为一个浮点数，求 ``5.0 / 3``，因为被除数是一个浮点数，所以被转化成于求 ``5.0 / 3.0``，答案即为``1.6666667``，相当于调用 ``ceil(1.6666667)``，答案显然是 ``2``，是正确的。

以上是有关于 ``ceil`` 函数的问题的纠正

有关数据……出题人说已经修复了，我也不清楚有没有锅，反正不要特判出生点就好啦

剩下模拟貌似也没什么好说的qaq

## Code

楼下有OOP写法当然是当然资瓷的辣，这里放一发假的OOP就跑（

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>

const int maxn = 110;

char mp[maxn][maxn];

int n, m, px, py, q;

struct Character {
  int HP, ST, DE;
  int ehp, est, ede;

  void print() {
    printf("%d %d %d\n", this->HP, this->ST, this->DE);
  }

  void fight() {
    int x = int(ceil(1.0 * ehp / std::max(1, ST - ede)));
    this->HP += std::max(1, x * std::max(1, est - DE));
  }

  void update(const char x) {
    switch (x) {
      case 'R': {
        this->HP = std::max(0, this->HP - 10);
        break;
      }
      case 'Q': {
        this->ST += 5;
        break;
      }
      case 'Y': {
        this->DE += 5;
        break;
      }
      case 'M': {
        fight();
        break;
      }
    }
  }
};
Character my;

void mov(const int x);

int main() {
  freopen("mzq.in", "r", stdin);
  freopen("mzq.out", "w", stdout);
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; ++i) {
    scanf("%s", mp[i] + 1);
  }
  scanf("%d%d%d", &my.ehp, &my.est, &my.ede);
  scanf("%d%d", &px, &py);
  scanf("%d%d", &my.ST, &my.DE);
  scanf("%d", &q);
  int x;
  while (q--) {
  	scanf("%d", &x);
    if (x == 1) {
      my.print();
    } else {
      x = 0;
      scanf("%d", &x);
      mov(x);
    }
  }
  return 0;
}

void mov(const int x) {
  switch (x) {
    case 1: {
      --py;
      break;
    }
    case 2: {
      ++py;
      break;
    }
    case 3: {
      --px;
      break;
    }
    case 4: {
      ++px;
      break;
    }
    default: {
      puts("I AK IOI");
      break;
    }
  };
  my.update(mp[px][py]);
}
```



---

## 作者：syf2008 (赞：5)

看到题面的长度，就能把一大批人劝退，题面看起来很难，其实只是纯模拟的~~水~~题（光速逃

回归正题：

这题有2个坑点

1. 生命药水时的受伤血量的处理并不能直接 -10，还要与0取max
1. 遇到怪兽时的向上取整，可以用ceil,但是要写ceil(1.0*HP/max(1,ST-DE)

好了，上代码（马蜂极丑）
```
#include <bits/stdc++.h>
using namespace std;
struct ss1
{
	int fang,gong;
	double xue;
}g,r;//g=怪，r=人
char a[105][105]={ };
int main()
{
	int n,m,q,x,y,sss,zzz;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	cin>>a[i][j];
	cin>>g.xue>>g.gong>>g.fang>>x>>y>>r.gong>>r.fang>>q;
	while(q--)
	{
	cin>>zzz;
	if(zzz==1)
	cout<<r.xue<<" "<<r.gong<<" "<<r.fang<<endl;
	if(zzz==2)
	{
	cin>>sss;
	if(sss==1&&y>=1&&y<=m)
	--y;
else if(sss==2&&y>=1&&y<=m)
	++y;
else if(sss==3&&x>=1&&x<=n)
	--x;
else if(sss==4&&x>=1&&x<=n)
	++x;
else continue;
	if(a[x][y]=='R')
	r.xue=max(0,int(r.xue-10));
else if(a[x][y]=='Q')
	r.gong+=5;
else if(a[x][y]=='Y')
	r.fang+=5;
else if(a[x][y]=='M')
	r.xue+=max(1.0,(ceil(1.0*(g.xue/max(1,r.gong-g.fang)))*max(1,g.gong-r.fang)));
	}
	}
	return 0;
}
```
## 制作不易，~~给个三连吧（点赞，关注，评论）~~

---

## 作者：Flokirie (赞：2)

# 大爱银临女神！

既然扶咕咕@一扶苏一在题解中这样说了，~~本蒟蒻就来放一波真的OOP代码~~

创建一个角色类，针对游戏中可能的操作，考虑实现以下函数：

1. 初始化：构造函数；
1. 生命药水：将角色的已损失生命值-10（最低为0）；
2. 力量药水：将角色的攻击力+5；
3. 防御药水：将角色的防御力+5；
4. 怪物：将角色的已损失生命值增加$\max(1,\lceil\frac{HP_0}{\max(1, ST-DE_0)}\rceil\times\max(1, ST_0-DE))$；
5. 查询：重载<<运算符，打印角色状态；
7. 移动：改变函数的x, y坐标。

具体实现时，可进行封装，将已损失生命值、攻击、防御、坐标均设为private，所有操作通过public的函数进行。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int dx[4] = {0, 0, -1, 1};
const int dy[4] = {-1, 1, 0, 0};
int HP0, ST0, DE0;
char c[110][110];

class player{
	private:
		int lost_HP, ST, DE;
		int x, y;
	public:
		player(int st, int de, int x0, int y0); //构造函数
		void HP_potion(); //生命药水
		void ST_potion(); //攻击药水
		void DE_potion(); //防御药水
		void fight(); //打怪
		void move(int direction); //移动
		void event(); //根据所在方格，进行处理
	friend ostream& operator<< (ostream &os, player &p); //输出
};

player::player(int st, int de, int x0, int y0){
	lost_HP = 0;
	ST = st;
	DE = de;
	x = x0;
	y = y0;
}

void player::HP_potion(){
	lost_HP = max(lost_HP - 10, 0);
}

void player::ST_potion(){
	ST += 5;
}

void player::DE_potion(){
	DE += 5;
}

void player::fight(){
	lost_HP += max(1.0, ceil(HP0 / max(1.0, ST - DE0 * 1.)) * max(1, ST0 - DE));
}

void player::move(int direction){
	x += dx[direction];
	y += dy[direction];
}

void player::event(){
	switch (c[x][y]){
		case '.': return;
		case 'R': HP_potion(); break;
		case 'Q': ST_potion(); break;
		case 'Y': DE_potion(); break;
		case 'M': fight(); break;
	}
}

ostream& operator<<(ostream& os, player &p){
	printf("%d %d %d\n", p.lost_HP, p.ST, p.DE);
	return os;
}

int main(){
	int n, m;
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++){
		scanf("%s", c[i] + 1);
	}
	int x0, y0, st, de, q;
	scanf("%d %d %d %d %d %d %d %d", &HP0, &ST0, &DE0, &x0, &y0, &st, &de, &q);
	player Misaka_Mikoto(st, de, x0, y0);
	while(q--){
		int op;
		scanf("%d", &op);
		if (op == 1){
			cout << Misaka_Mikoto;
		}
		else{
			int dir;
			scanf("%d", &dir);
			Misaka_Mikoto.move(dir - 1);
			Misaka_Mikoto.event();
		}
	}
	return 0;
} 
```



---

## 作者：Ginger_he (赞：1)

本文同步更新于[博客园](https://www.cnblogs.com/Gingerhe/p/16009982.html)
# 题目描述
你在一张地图上移动，用 $1/2/3/4$ 来表示**左/右/上/下**，当前格子上的字母代表着你要进行相应的操作。  

`R`：$HP\gets\max(0,HP-10)$  
`Q`：$ST\gets ST+5$  
`Y`：$DE\gets DE+5$  
`M`：$HP\gets HP+\max(1,\left\lceil\dfrac{HP_0}{\max(1,ST-DE_0)}\right\rceil\times\max(1,ST_0-DE))$  
（具体题意还是建议看原题）
# 题解
我们可以将角色和怪物的属性用结构体存起来，然后记录下角色的位置，每次进行相应的操作即可。
# 注意
- 上文中的 $\gets$ 为赋值符号。
- 使用函数 `ceil` 最好转成 `double` 类型再使用。
- 对于这种阅读理解题一定要先读清题意和题目要求才去打代码。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int hp,st,de;
}a,b;
int n,m,t,x,y,op,d,p,q;
int dx[]={0,0,0,-1,1},dy[]={0,-1,1,0,0};
char s[105][105];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("\n%s",s[i]+1);
	scanf("%d%d%d%d%d%d%d%d",&a.hp,&a.st,&a.de,&x,&y,&b.st,&b.de,&t);
	while(t--)
	{
		scanf("%d",&op);
		if(op&1)
			printf("%d %d %d\n",b.hp,b.st,b.de);
		else
		{
			scanf("%d",&d);
			x+=dx[d],y+=dy[d];
			if(s[x][y]=='R')
				b.hp=max(0,b.hp-10);
			else if(s[x][y]=='Q')
				b.st+=5;
			else if(s[x][y]=='Y')
				b.de+=5;
			else if(s[x][y]=='M')
			{
				p=ceil(double(a.hp/max(1.0,double(b.st-a.de))));
				q=max(1,a.st-b.de);
				b.hp+=max(1,p*q);
			}
		}
	}
	return 0;
}
```

---

## 作者：Jason12 (赞：1)

## 题目：[传送门](https://www.luogu.com.cn/problem/P5006)
## 思路：
  根据题目要求输入各项数据，输入字符型时要注意换行符哈，然后按照输入的数字进行输出或移动，若为移动则按照移动结果的类型（怪兽或药水）进行计算。（详见代码）
## 代码：
```cpp
#include <bits/stdc++.h>
  using namespace std;
int n,m,a,b,c,x,y,z,u,v,w,p,q,t,s,i,j;
char ch[105][105],cn;
int main()
{
	scanf("%d%d\n",&n,&m);//读入 n 和 m ，注意加 '\n' 
	for (i=1;i<=n;i++)
	{
		for (j=1;j<=m;j++)
		{
			ch[i][j]=getchar();
		}
		cn=getchar();//读入换行符 
	}
	scanf("%d%d%d",&a,&b,&c);
	scanf("%d%d",&x,&y);
	scanf("%d%d",&u,&v);
	scanf("%d",&s);
	for (i=1;i<=s;i++)
	{
		scanf("%d",&t);
		//判断操作是查询还是移动
		if (t==1) printf("%d %d %d\n",w,u,v);//如果操作是查询，则输出 
		else if (t==2)
		{
			scanf("%d",&z);
			switch (z)//移动 
			{
				case 1:y--;break;
				case 2:y++;break;
				case 3:x--;break;
				case 4:x++;break;
			}
			if (ch[x][y]=='M') w+=max(1.,ceil((double)a/max(1,u-c))*max(1,b-v));//遇到怪兽，失去的血量增加，注意加 'double' 
			else if (ch[x][y]=='R')//生命药水，恢复血量 
			{
				if (w>10) w-=10;//判断是恢复全部血量还是部分血量 
				else w=0;
			}
			else if (ch[x][y]=='Q') u+=5;//力量药水，增加攻击力 
			else if (ch[x][y]=='Y') v+=5;//防御药水，增加防御力 
		}
	}
	return 0;
}
```


---

## 作者：Eason_AC (赞：1)

## Content
题意实在是太过复杂了，因此请回到[题面](https://www.luogu.com.cn/problem/P5006)查看。
## Data Range
本部分和 Solution 部分变量的含义同题面。
- $1\leqslant n,m\leqslant 100,0\leqslant q\leqslant 10^4,0\leqslant ST_0,DE_0,HP_0,ST,DE\leqslant 100,1\leqslant op\leqslant 2,1\leqslant d\leqslant 4$。
- $C_{i,j}$ 只有可能是 `.`，`R`，`Q`，`Y`，`M` 五个字符之一。
- 人物不会跑到地图外面。

## Solution
不知道为什么被扶咕咕给改了题面……所以又重新做了一遍。

~~而且为什么一下扶苏一下炮姐啊，好混乱啊，搞得我都弄不清主人公到底是谁了。~~

分部分来讲：

### Part 1 Test Data 1
因为 $q=0$，也就是说没有提问，因此，你不需要输出任何东西就可以骗到这道题目的 $10$ 分。

这部分分可以说对于萌新非常非常友好。
### Part 2 Test Data 4,5
人物只固定在一个点上面游走，因此每次询问的答案一定分别是 $0,ST$ 和 $DE$。输出 $q$ 次即可拿到 $20$ 分。

这部分分也可以说对于萌新是非常友好的。因此，我可以说，只要你会语法，这道题目至少可以拿到 $30$ 分。
### Part 3 Test Data 6~8
开始进入我们的正题了。由于这一部分没有怪物，所以我们只需要讨论捡到生命药水、力量药水和防御药水时的情况。

在此之前还需要考虑移动的情况，原来的题面当中是直接输入一个字符然后依此判断行动方向。而这里直接输入数字的话就很简单了，我们可以直接开一个数组，然后输入时将其作为数组的下标，就可以直接加进去当前位置的坐标里面去了。

再具体分析捡到三种药水的情况：

- 生命药水：变化就是 $HP\leftarrow\max(0,HP-10)$。
- 力量药水：变化就是 $ST\leftarrow ST+5$。
- 防御药水：变化就是 $DE\leftarrow DE+5$。

由于捡到药水之后药水不会消失，因此不需要考虑是否已经捡到的情况。
### Part 4 Others
捡到药水的情况我已经在上面讲过了，所以接下来就是考虑打怪时的情况。这里直接给了个式子给你：

$$\max(1,\left\lceil\dfrac{HP_0}{\max(1,ST-DE_0)}\right\rceil\times\max(1,ST_0-DE))$$

你就直接按照这个式子算就好了。注意在使用 cmath 库里面的 ceil 函数时，不能够直接除，要先把被除数或者除数转换成 double 类型，然后再去除，最后向上取整之后用整型变量存储就好。

上面的所有变化用变量存储一下，询问的时候就直接输出就好了。

所以这道题目就做完了，还算是一道比较小清新的模拟题。
## Code
```cpp
const int dx[5] = {0, 0, 0, -1, 1};
const int dy[5] = {0, -1, 1, 0, 0};
struct misaka {
	int hp0, st0, de0, curx, cury;
}fusu;
int n, m, hp, st, de, q;
char a[107][107];

int main() {
	n = Rint, m = Rint;
	F(i, 1, n) scanf("%s", a[i] + 1);
	hp = Rint, st = Rint, de = Rint, fusu.curx = Rint, fusu.cury = Rint, fusu.st0 = Rint, fusu.de0 = Rint, q = Rint;
	while(q--) {
		int op = Rint;
		if(op == 1) printf("%d %d %d\n", fusu.hp0, fusu.st0, fusu.de0);
		else {
			int d = Rint;
			fusu.curx += dx[d], fusu.cury += dy[d];
			if(a[fusu.curx][fusu.cury] == 'R') fusu.hp0 = max(0, fusu.hp0 - 10);
			else if(a[fusu.curx][fusu.cury] == 'Q') fusu.st0 += 5;
			else if(a[fusu.curx][fusu.cury] == 'Y') fusu.de0 += 5;
			else if(a[fusu.curx][fusu.cury] == 'M') fusu.hp0 += max(1, (int)ceil(hp * 1.0 / (max(1, fusu.st0 - de) * 1.0)) * max(1, st - fusu.de0));
		}
	}
	return 0;
}
```

---

## 作者：Halberd_Cease (赞：0)

 [**P5006 大美江湖**](https://www.luogu.com.cn/problem/P5006)


**题目思路**：

在一个数组里模拟走向并且输出保存的数据。

- 当走到```M```将损失的 $HP$ 加到累加器```DHP```中；
- 当走到```R```将累加器```DHP```的值减去十点，并且不小于零；
- 当走到```Q```或者```Y```将```ST```或```DE```增加五点。

**重点**：

---

对于“**左/右/上/下**”操作，要注意坐标的变动，不要加反了；

---
还有这一个大公式：
$$\text{max}(1,\lceil\frac{HP_0}{\text{max}(1,ST-DE_0)}\rceil \times \text{max}(1,ST_0-DE))$$
我们一个一个来分解：

---

首先
$$\lceil\frac{HP_0}{\text{max}(1,ST-DE_0)}\rceil$$
可以用```ceil(hp0/max(1,st-de0))```表示；

---
其次
$$\text{max}(1,ST_0-DE)$$
可以用```max(1,st0-de)```表示；

---
合起来就是：```ceil(hp0/max(1,st-de0))*max(1,st0-de)```;

---
最后的式子就是：```max(1,ceil(hp0/max(1,st-de0))*max(1,st0-de))```。

---
**还有一个点**：

用它提供的```max()```函数很容易报错，所以我们要手写一个最大数函数：
```cpp
int maxn(int x,int y)
{
  return max(x,y);
}
```

---
有了以上的基础，我们就可以轻松秒掉这道题。

以下是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char mapp[110][110];//地图
int q,n,m; 
int hp,st,de;//怪物属性
int ST,DE,DHP;//人物属性
int x,y;//坐标
int i,j;
int maxn(int x,int y)
{
	return max(x,y);
}
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	for(j=1;j<=m;j++)
	cin>>mapp[i][j];
	cin>>hp>>st>>de;
	cin>>x>>y;
	cin>>ST>>DE;
	cin>>q;
	for(i=1;i<=q;i++)
	{
		int op;
		cin>>op;
		if(op==1)//打印属性
		{
			cout<<DHP<<' '<<ST<<' '<<DE<<endl; 
		}
		else
		{
			int d;
			cin>>d;
			switch(d)//移动
			{
				case 1:{
					y--;
					break;
				}
				case 2:{
					y++;
					break;
				}
				case 3:{
					x--;
					break;
				}
				case 4:{
					x++;
					break;
				}
			}
			switch(mapp[x][y])//判断
			{
				case 'R':{
					DHP=max(DHP-10,0);//回血
					break;
				}
				case 'Q':{
					ST+=5;
					break;
				}
				case 'Y':{
					DE+=5;
					break;
				}
				case 'M':{
					DHP+=maxn(1,ceil(hp*1.0/maxn(1,ST-de))*maxn(1,st-DE));
					break;
				}
			}
		}
	}
} 
```


---

## 作者：_Rainlzy (赞：0)

**这道题其实就是一道模拟题，只不过需要注意细节（特别是 $max$ 这个函数）**

先解释一下题目:

一个 $n \times m$ 的矩阵中，扶苏站在 $(x,y)$ 的格子上，其余的格子有五种情况：

- `.`：啥都没有
- `R`：走到这个格子的时候，$HP=max(0,HP-10)$
- `Q`：走到这个格子的时候，$ST+=5$
- `Y`：走到这个格子的时候，$DE+=5$
- `M`：走到这个格子的时候，$max(1,ceil(Hp_0/max(ST-DE_0)) \times max(1,ST_0-DE)$

然后题目会让你上下左右移动或者查询扶苏的 $HP,ST,DE$。

这题怎么做呢？就模拟吧。先读入数据读完后处理查询为 $2$ 的情况。先设两个数组 $dx,dy$，然后将上下左右四种情况存储下来，即 $(x+1,y),(x-1,y),(x,y+1),(x,y-1)$，然后判断下一个将要走到的位置是什么字符，并用上述的公式进行代入就好了。

特别的，这个 $max$ 函数可以宏定义一个新的，因为类型不同，直接用 $max$ 很容易报错。

```c++
#include<bits/stdc++.h>
using namespace std;
#define maxn(a,b) ((a)>(b)?a:b)
int n,m,x,y,dx[5]={0,0,0,-1,1},dy[5]={0,-1,1,0,0},q;
char a[105][105];
struct ghost{
	int hp,st,de;
}guai;
struct player{
	int hp,st,de;
}fusu;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	cin>>guai.hp>>guai.st>>guai.de;
	cin>>x>>y;
	cin>>fusu.st>>fusu.de;
	cin>>q;
	for(int i=1;i<=q;i++){
		int op;
		cin>>op;
		if(op==1)
			cout<<fusu.hp<<" "<<fusu.st<<" "<<fusu.de<<endl;
		else if(op==2){
			int d;
			cin>>d;
			x+=dx[d],y+=dy[d];
			if(a[x][y]=='R') fusu.hp=maxn(0,fusu.hp-10);
			if(a[x][y]=='Q') fusu.st+=5;
			if(a[x][y]=='Y') fusu.de+=5;
			if(a[x][y]=='M') fusu.hp+=maxn(1,ceil(double(guai.hp/(maxn(1.0,fusu.st-guai.de))))*max(1,guai.st-fusu.de));
		}
	}
	return 0;
}
```



---

## 作者：nvqlfi214 (赞：0)

# 题解 P5006 【[yLOI2018] 大美江湖】
[传送门](https://www.luogu.com.cn/problem/P5006)

### 此题坑点
- ```请注意，如果多次进入同一个格子，那么格子上的药水会被重复拾取，小怪也会再次出现。即你可以认为离开一个格子以后该格子会恢复原状。```

- 吃生命药水并不能使你扣的血变成 __负数__

浮点数那什么的就不算做坑点了吧。
### 进入正题
- __题目叫你干什么__

先给出一个大小为 $n*m$ 的地图。

然后再给你怪物的属性 $HP_0$，$ST_0$，$DE_0$;你一开始在的坐标$(y,x)$（注意这里不是$(x,y)$！！！~~不过没有什么关系~~）；你的属性。

最后进行 $q$ 次操作（移动和输出）。
- __地图里面的东西__
1. `.`：走到上面什么都不会发生。
2. `R`：会使你丢失的血量$-10$，即```HP=max(0,hp-10)```。
3. `Q`：会使你的攻击力$+5$，即```ST+=5```。
4. `Y`：会使你的防御力$+5$，即```DE+=5```。
5. `M`：会使你的血量（丢失的）增加，按以下公式计算：
$\max(\left\lceil\dfrac{HP_0}{\max(1,ST-DE_0)}\right\rceil×\max(1,ST_0-DE))$

C++ 代码实现就是：
```cpp
//这里的数据均为double类型。
HP+=max(1.0,ceil(HP0/max(1.0,ST-DE0))*max(1.0,ST0-DE));
```
- __移动__

输入的 $op$ 是$2$了之后，再输入一个 $d$，应该这么处理：

$1$：```y--;```

$2$：```y++;```

$3$：```x--;```

$4$：```x++;```
____
那么完整代码就不放了~~还不是因为我的码风这么丑~~。

---

## 作者：Terraria (赞：0)

说句实话，这道题顶多是橙题，因为只需要模拟就好了。

# 题目回顾（请先看题）：

1.给出一个 $n \times m$ 大小的矩阵，每个矩阵都有如下几种字符：

> ```M``` 代表当前这个位置是怪兽，遇到后需要扣血，扣的血量如题所示。

> ```R``` 代表生命药水，可以使炮姐所受的伤害$-10$，如果$-10$后所受伤害变成了负数就是$0$。

> ```Y``` 可以使炮姐的防御力增加$5$

> ```Q``` 可以使炮姐的攻击力增加$5$

之后给出每只怪兽的血量、防御及攻击；

初始角色的位置；

初始角色的攻击力与防御力；

之后给出 $q$ 及 $q$ 个操作，每个操作有如下两种：

```1``` 输出目前角色的受伤害血量、攻击力及防御力。

```2 x``` 表示角色向 $x$ 方向移动（具体移动方向见题）。

所以，我们直接依照题意模拟即可。

本体坑点：

- 在遇到怪兽时要扣的血量中，有一个上取整，我们可以使用ceil。但是如果你是 $ceil(a/x)$ 就错了！！因为a和x已经是整型变量，在做相除的时候已经默认下取整，而 $ceil$ 又来个上取整，也就是没用；因此我们要将里面的除法强制转换成double，即 $ceil(1.0*a/x)$。

- 要注意角色获得生命药水时的受伤血量的处理并不能直接 $-10$，还有判断。

然后？然后就可以快快乐乐地A掉此题了啊~

Code：

```cpp
#include<bits/stdc++.h>
#define maxn(a,b) ((a)>(b)?(a):(b))
using namespace std;
int dx[5]={0,0,0,-1,1};
int dy[5]={0,-1,1,0,0};//分别对应左、右、上、下
struct person{
	double hp=0;
	int st;
	int de;
	int x;
	int y;
}a;//a代表炮姐
char mp[109][109];
int n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>mp[i][j];//输入地图
	}
	int mhp,mst,mde;//怪物的属性
	int q;
	cin>>mhp>>mst>>mde;
	cin>>a.x>>a.y;
	cin>>a.st>>a.de;
	cin>>q;
	for(int i=1;i<=q;i++){
		int op;
		cin>>op;
		if(op==1){
			cout<<a.hp<<" "<<a.st<<" "<<a.de<<endl;
		}
		else if(op==2){
			int d;
			cin>>d;
			a.x=a.x+dx[d];
			a.y=a.y+dy[d];
            if(mp[a.x][a.y]=='M'){
                int b1=ceil(double(mhp/maxn(1.0,(a.st-mde))));//以防万一，1.0加上double最保险
				int b2=maxn(1,mst-a.de);
				a.hp+=maxn(1,b1*b2);//这里分段算减少错误率
            }
			if(mp[a.x][a.y]=='R'){
				if(a.hp>=10) a.hp-=10;
		    	else a.hp=0;
			}
			if(mp[a.x][a.y]=='Y'){
				a.de=a.de+5;
			}
			if(mp[a.x][a.y]=='Q'){
				a.st=a.st+5;
			}
		}
	}
}
```
完结撒花~

谢谢观看！

---


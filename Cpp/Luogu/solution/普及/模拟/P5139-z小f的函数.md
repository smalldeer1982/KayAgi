# z小f的函数

## 题目背景

$z$小$f$热爱数学。

## 题目描述

由于$z$小$f$要复习$NOIp$，而且他认为觉得数学作业太简单了，于是把数学作业交给了你。

题目如下：

给定二次函数$y=ax^{2}+bx+c (a \neq 0)$，求函数的最大（小）值；

$z$小$f$当然不喜欢看见做这么简单的题目啦，于是他决定给函数进行如下操作：

操作 $1$：给定系数$k$，将函数向上平移$k$位，（$k$<$0$则向下平移$-k$位）

操作$2$：给定系数$k$，将函数向右平移$k$位，（$k$<$0$则向左平移$-k$位）

操作$3$：给定系数$k_1,k_2$，将函数关于点$(k_1,k_2)$进行对称变换

操作$4$：给定系数$k_1,k_2$，求函数在闭区间$[k_1,k_2]$上的最小值和最大值

操作$5$：给定系数$u,v,w$，求出二次函数$y$与二次函数$y_2=ux^{2}+vx+w$是否有交点。

由于$z$小$f$需要，你还要输出最终的二次函数$y$此时的最大值（最小值）。


## 说明/提示

对于30%的数据，$n<=100$，且没有操作$3$。

对于60%的数据，$n<=1000$。

对于100%的数据，$T<=10,n<=10000$

数据保证$a \neq 0,u \neq 0,a \neq u,1<=p<=5,-100<=a,b,c,k1,k2,k,u,v,w<=100$。

## 样例 #1

### 输入

```
1
1 0 0
4
1 3
1 -4
4 1 2
5 -1 0 -3
```

### 输出

```
0.00 3.00
0
-1.00
```

## 样例 #2

### 输入

```
1
-4 10 100
15
4 0 78
5 -4 -95 -97
1 -79
4 12 54
4 -60 11
1 83
4 68 80
2 -63
1 71
1 80
3 12 67
1 60
1 41
3 35 -13
4 6 26
```

### 输出

```
-23456.00 106.25
2
-11103.00 -435.00
-14979.00 27.25
-24696.00 -17712.00
-6972.00 -1892.00
0.25
```

# 题解

## 作者：EnofTaiPeople (赞：12)

AK 竞赛后发题解，RP++！

这是一道很好的小学数学题，能教会我们二次函数移动问题。

我花了半小时，A 了这道题，给大家讲讲做法。

对五个指令，我们进行分开处理：

指令 1、2：考察的是二次函数的移动法则：

**左加右减，上加下减。**

意思是，对一个二次函数（顶点式）

$f(x)=a\cdot (x+k)^2+c$

向左（右）移 $k$ 会增加（减少）；

向上（下）移 $c$ 会增加（减少）。

于是上移代码如下：
```cpp
scanf("%lf",&k1);c+=k1;
```
右移有些复杂，步骤如下：

1. 将函数转为顶点式

2. 在顶点式进行右移操作

3. 顶点式转为一般式

代码如下：
```cpp
inline void rigt(ld a,ld &b,ld &c,ld w){
	ld d=b/(2*a)-w,e=(4*a*c-b*b)/(4*a);
	c=e+d*d*a;b=d*2*a;return;
}
```

指令 3（有些麻烦，毕竟有 30% 数据没有指令 3）

这考察二次函数对称轴的转换和找特殊点。

对一个二次函数

$f(x)=a\cdot x^2+b\cdot x+c$

一定有且仅有一个对称轴：

$x=-\frac{b}{2a}$
 
当函数图像关于点 $P(x_1,y_1)$ 进行对称变换时，有以下 3 个结论：

1. 开口方向会变；

2. 对称轴会对直线 $x=x_1$ 进行对称变换；

3. 函数中所有点都会关于点 $P(x_1,y_1)$ 进行对称变换。

所以，指令 3 步骤如下：

1. 计算原对称轴；

2. 计算新对称轴；

3. $a$ 变为 $-a$；

4. 用新对称轴倒推得到 $y$；

5. 因为当 $x=0$ 时，$f(x)=c$，所以原函数过点 $Q(0,c)$ 将 $Q$ 点关于 $P$ 点进行对称变换，得到

$Q'(2\cdot x_1,2\cdot x_2-c)$

由结论 3 可知，$Q'$ 在新函数图像上。

代码如下：
```cpp
inline void CHS(ld &a,ld &b,ld &c,ld x1,ld y1){
	ld zhou=-b/(2*a);a=-a；
	b=-(2*a)*(x1*2-zhou);
	ld x2=2*x1,y2=y1*2-c;
	c=y2-a*x2*x2-b*x2;return;
}
```
指令 4：求函数区间最值。

前置知识：对于二次函数

$f(x)=a\cdot x^2+b\cdot x+c$

他在闭区间 $[k_1,k_2]$ 的最值只会出现在 $k_1$、$k_2$ 或顶点上。

所以，先判断顶点是否在闭区间 $[k_1,k_2]$ 上，再求最值。

代码如下：
```cpp
inline ld Min(ld a,ld b,ld c,ld k1,ld k2){
	if(k1>k2)swap(k1,k2);
	ld dl=k1*k1*a+k1*b+c,dr=k2*k2*a+k2*b+c;
	ld dm=-b/(2*a),tans=min(dl,dr);
	if(dm>=k1&&dm<=k2)
		tans=min(tans,dm*dm*a+dm*b+c);
	return tans;
}
inline ld Max(ld a,ld b,ld c,ld k1,ld k2){
	if(k1>k2)swap(k1,k2);
	ld dl=k1*k1*a+k1*b+c,dr=k2*k2*a+k2*b+c;
	ld dm=-b/(2*a),tans=max(dl,dr);
	if(dm>=k1&&dm<=k2)
		tans=max(tans,dm*dm*a+dm*b+c);
	return tans;
}
```
指令 5：这是除指令 1 之外最简单的了。

题意即 $a\cdot x^2+b\cdot x+c=u\cdot x^2+v\cdot x+w$

用左式减去右式，得到

$(a-u)\cdot x^2+(b-v)\cdot x+(c-w)=0$

注意到 $a\ne u$，问题转为求一元二次方程是否有解。

即判别式 $(b-v)^2-4(a-u)\cdot(c-w)$ 是否非负。

代码如下：
```cpp
inline int EJ(ld a,ld b,ld c,ld u,ld v,ld w){
	a-=u;b-=v;c-=w;
	if(b*b>=4*a*c)return 2;
	else return 0;
}
```
综上，无注释 AC 代码：
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
typedef double ld;
inline void rigt(ld a,ld &b,ld &c,ld w){
	ld d=b/(2*a)-w,e=(4*a*c-b*b)/(4*a);
	c=e+d*d*a;b=d*2*a;return;
}
inline void CHS(ld &a,ld &b,ld &c,ld x1,ld y1){
	ld zhou=-b/(2*a);
	b=-(2*(a=-a))*(x1*2-zhou);
	ld x2=2*x1,y2=y1*2-c;
	c=y2-a*x2*x2-b*x2;return;
}
inline ld Min(ld a,ld b,ld c,ld k1,ld k2){
	if(k1>k2)swap(k1,k2);
	ld dl=k1*k1*a+k1*b+c,dr=k2*k2*a+k2*b+c;
	ld dm=-b/(2*a),tans=min(dl,dr);
	if(dm>=k1&&dm<=k2)
		tans=min(tans,dm*dm*a+dm*b+c);
	return tans;
}
inline ld Max(ld a,ld b,ld c,ld k1,ld k2){
	if(k1>k2)swap(k1,k2);
	ld dl=k1*k1*a+k1*b+c,dr=k2*k2*a+k2*b+c;
	ld dm=-b/(2*a),tans=max(dl,dr);
	if(dm>=k1&&dm<=k2)
		tans=max(tans,dm*dm*a+dm*b+c);
	return tans;
}
inline int EJ(ld a,ld b,ld c,ld u,ld v,ld w){
	a-=u;b-=v;c-=w;
	if(b*b>=4*a*c)return 2;
	else return 0;
}
inline void gofans(){
	ld a,b,c,k1,k2,u,v,w;
	int n,p;scanf("%lf%lf%lf%d",&a,&b,&c,&n);
	while(n--){
		scanf("%d",&p);
		switch(p){
			case 1:scanf("%lf",&k1);c+=k1;break;
			case 2:scanf("%lf",&k1);rigt(a,b,c,k1);break;
			case 3:scanf("%lf%lf",&k1,&k2);
					CHS(a,b,c,k1,k2);break;
			case 4:scanf("%lf%lf",&k1,&k2);
			printf("%.2lf %.2lf\n",Min(a,b,c,k1,k2),Max(a,b,c,k1,k2));
			break;case 5:scanf("%lf%lf%lf",&u,&v,&w);
			printf("%d\n",EJ(a,b,c,u,v,w));break;
			default:while(true)printf("NO-ANSWER!\n");break;
		}
	}
	k1=-b/(2*a);
	printf("%.2lf\n",k1*k1*a+k1*b+c);
	return;
}
int main(){
	int T;scanf("%d",&T);
	while(T--)gofans();
	return 0;
}
```
完结撒花！

---

## 作者：Eason_AC (赞：9)

## Content
给定 $T$ 个二次函数 $y=ax^2+bx+c$，有若干次操作，有一个操作编号 $p$，保证仅为以下这五种：

- 操作 $1$：给定 $k$，将函数图像向上移动 $k$ 格（$k<0$ 就是向下移动 $-k$ 格）。
- 操作 $2$：给定 $k$，将函数图像向右移动 $k$ 格（$k<0$ 就是向左移动 $-k$ 格）。
- 操作 $3$：给定 $k_1,k_2$，将函数图像关于点 $(k_1,k_2)$ 对称。
- 操作 $4$：给定 $k_1,k_2$，求函数图像在闭区间 $[k_1,k_2]$ 内的最大值和最小值并输出（保留 $2$ 位小数）。
- 操作 $5$：给定 $u,v,w$，求 $y=ax^2+bx+c$ 的函数图像是否和 $y=ux^2+vx+w$ 的函数图像有焦点，有的话输出 `2`，否则输出 `0`。

在所有操作弄完以后，你还需要给出操作完以后函数的最值（显然，根据 $a$ 的正负来判定，保留 $2$ 位小数）。
## Range
1. 关于 $T,m$，有 $T\leqslant 10,m\leqslant 10000$。
2. 关于其他的变量，保证 $a\neq0,u\neq0,a\neq u,1\leqslant p\leqslant5,-100\leqslant a,b,c,k_1,k_2,k,u,v,w\leqslant 100$。

## Gossip
看完这道题目，我突然回到了初二下学期那段被二次函数支配的时光。我仍然还记得那一条条流动的抛物线……

于是，我拿出了那时候的斗志，开始做这道题目。
## Solution
我使用的是一般式进行操作。这么做的优点是，你不需要花多余的时间来求顶点式 $a(x-h)^2+k$ 中的 $h$ 和 $k$，前期处理比较方便，但问题是后面的计算量非常大，没心理准备根本就是做到一半就崩溃了。所以，这篇题解旨在帮助大家多见识一些复杂的计算，让你从容应对这么多复杂的式子和分类讨论。

话不多说，开始处理每个操作：
### Part 1 操作 $1$
很显然，我们将其上下移动以后改变的只是常数项的值。

什么什么，你还要我讲原因？

那就请看图吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/ahfk0yjj.png)

上图中蓝色的曲线是函数 $y=x^2+6x+5$ 的图像，而绿色的曲线是函数 $y=x^2+6x+4$ 的图像。我们可以看到，蓝色的曲线和 $y$ 轴的交点是 $(5,0)$，而绿色的曲线和 $y$ 轴的交点为 $(4,0)$，所以正好和常数项相对应。

或者我们也可以这样：

设 $y_1=a_1x^2+b_1x+c_1,y_2=a_2x^2+b_2x+c_2$。

令两个函数的 $x$ 都等于 $0$，分别代入两个函数中可得 $y_1=c_1,y_2=c_2$。

本来这个很显然的，但我想为了照顾那些还没有学二次函数的学弟，所以还是写写吧。

故，操作后的函数为 $y=ax^2+bx+c+k$。
### Part 2 操作 $2$
这个用顶点式的话很方便，但是我们这里只提一般式的做法，不过会借用一下顶点式。

首先，我们可以由顶点式 $y=a(x-h)^2+s$（由于为避免与题面中的 $k$ 重复，故改为 $s$）向右平移 $k$ 格后的式子为 $y=a(x-h-k)^2+s$，然后再把它拆开，得到：$y=ax^2-(2ak+2ah)x+ah^2+ak^2+2ahk+s$。又由于我们知道 $h=-\dfrac{b}{2a},s=\dfrac{4ac-b^2}{4a}$，所以，直接将它强算过来，可以得到 $y=ax^2+(b-2ak)x+ak^2-bk+c$。

故，操作后的函数为 $y=ax^2+(b-2ak)x+ak^2-bk+c$。
### Part 3 操作 $3$
首先，我们令一个在抛物线上的点为 $(x_0,y_0)$，所以我们就有在与 $(k_1,k_2)$ 对称后的坐标为 $(2k_1-x_0,2k_2-y_0)$。

什么什么，要我讲原因？

可以，那请听我说：由于它们的横坐标和纵坐标之差分别为 $(x_0-k_1,y_0-k_2)$，所以它的对称点的坐标为 $(k_1-(x_0-k_1),k_2-(y_0-k_2))\Rightarrow(2k_1-x_0,2k_2-y_0)$。

那么我们再代入到 $y=ax^2+bx+c$ 中可得：$2k_2-y_0=a(2k_1-x_0)^2+b(2k_1-x_0)+c$，因此可得到 $y_0=2k_2-a(2k_1-x_0)^2-b(2k_1-x_0)-c$。

那么再对右边的式子进行化简，然后再合并 $x$ 同类项，可得到 $y_0=-ax_0^2+(4ak_1+b)x_0+2k_2-4ak_1^2-2bk_1-c$。

故，操作后的函数为 $y=-ax^2+(4ak_1+b)x+2k_2-4ak_1^2-2bk_1-c$。
### Part 4 操作 $4$
这一段是我们的重头戏。

首先根据 $a<0$ 和 $a>0$ 两大类，再通过 $k_1,k_2$ 以及 $x'=-\dfrac{b}{2a}$ 之间的关系进行分类讨论。

**笔者温馨提示：自己画一个函数图像具体分析，下面的两个图中作为例子的函数解析式左边有。**

好的，那么现在就开始吧。
### 4.1 $a<0$
![](https://cdn.luogu.com.cn/upload/image_hosting/vurhzho3.png)

那么这时候还需要 $4$ 种情况来分类讨论：

1. $k_2<x'$，此时可以从图像上看到，$y_{\min}=ak_2^2+bk_2+c,y_{\max}=ak_1^2+bk_1+c$。

2. $k_2\geqslant x,k_1<x'$ 且 $k_2-x'<x'-k_1$，此时可以从图像上看到，$y_{\min}=ax'^2+bx'+c,y_{\max}=ak_1^2+bk_1+c$。

3. $k_2\geqslant x,k_1<x'$ 且 $k_2-x'\geqslant x'-k_1$，此时可以从图像上看到 $y_{\min}=ax'^2+bx'+c,y_{\max}=ak_2^2+bk_2+c$。

4. $k_1\geqslant x$，此时可以从图像上看到 $y_{\min }=ak_1^2+bk_1+c,y_{\max}=ak_2^2+bk_2+c$。

### 4.2 $a>0$
![](https://cdn.luogu.com.cn/upload/image_hosting/vkqsh130.png)

同样，这时候还需要 $4$ 种情况来分类讨论：

1. $k_2<x'$，此时可以从图像上看出 $y_{\min}=ak_1^2+bk_1+c,y_{\max}=ak^2+bk_2+c$。

2. $k_2\geqslant x,k_1<x'$ 且 $k_2-x'<x'-k_1$，此时可以从图像上看到 $y_{\min}=ak_1^2+bk_1+c,y_{\max}=ax'^2+bx'+c$。

3. $k_2\geqslant x,k_1<x$ 且 $k_2-x'\geqslant x'-k_1$，此时可以从图像上看到 $y_{\min}=ak_2^2+bk_2+c,y_{\max}=ax'^2+bx'+c$。

4. $k_1\geqslant x$，此时可以从图像上看到 $y_{\min}=ak_2^2+bk_2+c,y_{\max}=ak_1^2+bk_1+c$。

至此，所有的分类讨论就完了，直接判断条件对应输出结果就好。
### Part 5 操作 $5$
这个倒比操作 $4$ 简单，直接联立一下就得到 $ax^2+bx+c=ux^2+vx+w$。所以，我们就只需要判断这个方程是否有实数根就好了。

我们将上面这个方程移项，可以得到 $(a-u)x^2+(b-v)x+c-w=0$，所以，我们可以得到 $\triangle=(b-v)^2-4(a-u)(c-w)$。根据 $\triangle$ 可以判别出这个方程实数根的情况，也就可以判断这两个函数图像是否有交点了。具体如下——

当 $\triangle\geqslant 0$ 时，这个方程有实数根，这两个函数图像也就有交点了；否则，当 $\triangle<0$ 时，这个方程没有实数根，这两个函数图像也就没有交点了。

至此，用一般式解决本题的算法也就讲完了。顶点式的话题解区里的大佬们已经讲得很清楚了。

如有不懂的话，下面的代码也许能帮助你。
## Code
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int t;

double f(double a, double b, double c, double x) {
	return a * x * x + b * x + c;
}

int main() {
	scanf("%d", &t);
	while(t--) {
		double a, b, c;
		int m;
		scanf("%lf%lf%lf%d", &a, &b, &c, &m);
		while(m--) {
			int opt;
			scanf("%d", &opt);
			if(opt == 1) {
				double k;
				scanf("%lf", &k);
				double a0 = a, b0 = b, c0 = c + k;
				a = a0, b = b0, c = c0;
			} 
			else if(opt == 2) {
				double k;
				scanf("%lf", &k);
				double a0 = a, b0 = b - 2 * a * k, c0 = a * k * k - b * k + c;
				a = a0, b = b0, c = c0;
			}
			else if(opt == 3) {
				double k1, k2;
				scanf("%lf%lf", &k1, &k2);
				double a0 = -a, b0 = 4 * a * k1 + b, c0 = 2 * k2 - 4 * a * k1 * k1- 2 * b * k1 - c;
				a = a0, b = b0, c = c0;
			}
			else if(opt == 4) {
				double k1, k2, xp = -(b / (2 * a)), yp = (4 * a * c - b * b) / (4 * a);
				scanf("%lf%lf", &k1, &k2);
				if(a > 0) {
					if(k2 < xp)	{
						printf("%.2lf %.2lf\n", f(a, b, c, k2), f(a, b, c, k1));
					}
					else if(k1 < xp) {
						if(k2 - xp < xp - k1) {
							printf("%.2lf %.2lf\n", f(a, b, c, xp), f(a, b, c, k1));
						}
						else if(k2 - xp >= xp - k1) {
							printf("%.2lf %.2lf\n", f(a, b, c, xp), f(a, b, c, k2));
						}
					} else {
						printf("%.2lf %.2lf\n", f(a, b, c, k1), f(a, b, c, k2));
					}
				} else if(a < 0) {
					if(k2 < xp)	{
						printf("%.2lf %.2lf\n", f(a, b, c, k1), f(a, b, c, k2));
					}
					else if(k1 < xp) {
						if(k2 - xp < xp - k1) {
							printf("%.2lf %.2lf\n", f(a, b, c, k1), f(a, b, c, xp));
						}
						else if(k2 - xp >= xp - k1)	{
							printf("%.2lf %.2lf\n", f(a, b, c, k2), f(a, b, c, xp));
						}
					} else {
						printf("%.2lf %.2lf\n", f(a, b, c, k2), f(a, b, c, k1));
					}
				}
			}
			else if(opt == 5) {
				double u, v, w;
				scanf("%lf%lf%lf", &u, &v, &w);
				double delta = (b - v) * (b - v) - 4 * (a - u) * (c - w);
				puts(delta < 0 ? "0" : "2");
			}
		}
		printf("%.2lf\n", (4 * a * c - b * b) / (4 * a));
	}
	return 0;
}
```

---

## 作者：xueruo (赞：4)

这是一道很适合练习二次函数变换的题。   

## 题意

给定二次函数，进行一些初中学过的图像变换。 

## 思路

操作一和操作二： 
向四个方向平移 $k$ 位。只需要利用上加下减，左加右减的口诀就好了。  
具体就是：  
+ 向左或右：$f(x)$ 变为 $f(x+k)$。
+ 向上或下：$f(x)$ 变为 $f(x)+k$。  
具体的 $a,b,c$ 变化可以看代码部分的注释。  

---

操作三：  
关于点 $(k_1,k_2)$ 对称变换。  
图像上的点 $(x,y)$ 变为 $(2k_1-x,2k_2-y)$。
$f(x)$ 变为 $2k_2-f(2k_1-x)$。  
具体的 $a,b,c$ 变化可以看代码部分的注释。  

---

操作四：  
求区间 $[k_1,k_2]$ 里函数的最值。  
+ 若对称轴 $-\frac{b}{2a}$ 在区间内，那么对称轴的函数值就是最大或最小值。然后在端点的函数值取大 $(a<0)$ 或取小 $(a>0)$ 就好了。   
+ 若对称轴不在区间内，那么只需要对于端点处取小或取大。   
 
---
 
操作五：  
两个函数有交点，说明存在 $x$ 满足 $ax^2+bx+c=ux^2+vx+w$。  
$(a-u)x^2+(b-v)x+(c-w)=0$，由于 $a\neq u$，所以这是一个一元二次方程，只需满足 $\Delta\ge 0$ 就有交点了。

最后每组数据要输出的最值一定就是在对称轴上的函数值。  

##  代码

```cpp
#include<iostream>
#include<cstdio>
#include<memory.h>
#include<cstdlib>
#include<ctime>
#include<climits>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<stack>
#include<vector>
#include<queue>
#define bug puts("liupei")
#define int long long
#define MAX_TIME 0.95
#define max(a,b) (a>b)?a:b
#define min(a,b) (a<b)?a:b
using namespace std;
const int N=2e5+10;
const bool debug=0;
int T,q,op;
double a,b,c;
inline bool check(double _a,double _b,double _c) { //判是否有实数根,加_是因为避免重名
	if(_b*_b-4.0*_a*_c>=0.0)return 1;
	return 0;
}
inline double F(double x) { //计算函数值
	return a*x*x+b*x+c;
}
signed main() {
// 	freopen("zf.in","r",stdin);
//注：由于输入输出太过于混乱，把样例用freopen输入就不会显示出来输入部分,便于调试
	srand(time(0));
	register double k,k1,k2;
	register double u,v,w;
	register double ta,tb,tc;//abc的临时存储,要始终用旧的abc值去更新新的abc
	scanf("%lld",&T);
	while(T--) {
		scanf("%lf%lf%lf",&a,&b,&c);
		scanf("%lld",&q);
		while(q--) {
			scanf("%lld",&op);
			if(debug) {
				printf("op=%lld\n",op);
			}
			if(op==1) {
				scanf("%lf",&k);
				c+=k;
			} else if(op==2) {
				scanf("%lf",&k);
				ta=a;tb=b;tc=c;
				//a(x-k)^2+b(x-k)+c
				//ax^2-2akx+ak^2+bx-kb+c
				//ax^2+(-2ak+b)x+(ak^2-kb+c)（x为主元）
				a=ta;
				b=tb-2*ta*k;
				c=tc+ta*k*k-k*tb;
			} else if(op==3) {
				scanf("%lf%lf",&k1,&k2);
				//f(x)->2k2-f(2k1-x)
				//2k2-a(2k1-x)^2-b(2k1-x)-c
				//2k2-4ak1^2 +4k1ax -ax^2-2bk1+bx-c
				//-ax^2 +(4k1a+b)x +(2k2-4ak1^2-2bk1-c)合并同类项（x为主元）
				ta=a;tb=b;tc=c;
				a=-ta;
				b=4.0*k1*ta+tb;
				c=2.0*k2-4.0*ta*k1*k1-2.0*tb*k1-tc;
			} else if(op==4) {
				scanf("%lf%lf",&k1,&k2);
				double dui=-b/(2.0*a);
				if(k1>k2)swap(k1,k2);
				//最小值和最大值
				if(k1<=dui&&dui<=k2){//k1<=dui<=k2 
					if(a>0){
						printf("%.2lf ",F(dui));
						printf("%.2lf\n",max(F(k1),F(k2)));
					}else{
						printf("%.2lf ",min(F(k1),F(k2)));
						printf("%.2lf\n",F(dui));
					}
				}else{
					printf("%.2lf ",min(F(k1),F(k2)));
					printf("%.2lf\n",max(F(k1),F(k2)));
				}
			} else if(op==5) {
				scanf("%lf%lf%lf",&u,&v,&w);
				if(check(a-u,b-v,c-w)) {
					printf("2\n");
				} else {
					printf("0\n");
				}
			}
		}
		//每组数据操作完成后，输出最终的二次函数 y此时的最值
		register double zui=-b/(2.0*a);
		printf("%.2lf\n",a*zui*zui+b*zui+c);
	}
	return 0;
}
```
~~这篇题解写了好久，望管理员批准过。~~

---

## 作者：小菜鸟 (赞：3)

~~真\*\*是道屑题~~  

题意：  

给定一个二次函数，要求支持：  

- 平移  
- 求关于点的对称  
- 求区间最值和  
- 判断与另一二次函数是否相交  

看起来有点麻烦。然而初二数学告诉窝萌：  

$a(x-h)^2+k$是个好东西。  

于是我们可以依靠顶点式轻松搞出这些操作。  

- 向右平移$x$：$h+=x$  

- 向上平移$y$：$k+=y$  

- 关于$(x,y)$对称：$a=-a\,,h=2x-h\,,k=2y-k$  

- 求最值：若顶点在区间内，答案就是顶点纵坐标，否则两个端点求最值  

- 判断相交：转为一般式，两函数作差后求零点，若存在则为$2$，否则为$0$  

为了方便思考，我们把二次函数看成对象来搞~~（疑车无据~~  

于是代码就出现了：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
class func//二次函数类
{
    private:
        double a,h,k;
    public:
        func(double aa,double bb,double cc):a(aa),h(-bb/2/aa),k((4*aa*cc-bb*bb)/(4*aa)) {}
        double operator()(double x)const//单点求值
        {
            return a*(x-h)*(x-h)+k;
        }
        double extreme()const//求全局最值
        {
            return k;
        }
        bool inrange(double l,double r)const//判断顶点坐标是否在区间内
        {
            return l<=h&&h<=r;
        }
        double maximum(double l,double r)const//区间最大值
        {
            if(a<0&&inrange(l,r))return extreme();
            return max((*this)(l),(*this)(r));
        }
        double minimum(double l,double r)const//区间最小值
        {
            if(a>0&&inrange(l,r))return extreme();
            return min((*this)(l),(*this)(r));
        }
        void move_right(double dis){h+=dis;}//向右平移
        void move_up(double dis){k+=dis;}//向上平移
        void symmetry(double x,double y)//关于点对称
        {
            a=-a;
            h=x+x-h;
            k=y+y-k;
        }
        bool cross(double x,double y,double z)//判断相交
        {
            double a1=a-x;
            double b1=2*a*h+y;
            double c1=a*h*h+k-z;
            return b1*b1-4*a1*c1>=0;
        }
};
double a,b,c;
int main()
{
    int T;
    scanf("%d",&T);
    for(int i=0;i<T;++i)
    {
        double a,b,c;
        int m;
        scanf("%lf%lf%lf%d",&a,&b,&c,&m);
        func f(a,b,c);
        for(int j=0;j<m;++j)
        {
            int op;
            double x,y,z;
            scanf("%d",&op);
            switch(op)
            {
                case(1):
                    scanf("%lf",&x);
                    f.move_up(x);
                    break;
                case(2):
                    scanf("%lf",&x);
                    f.move_right(x);
                    break;
                case(3):
                    scanf("%lf%lf",&x,&y);
                    f.symmetry(x,y);
                    break;
                case(4):
                    scanf("%lf%lf",&x,&y);
                    printf("%.2lf %.2lf\n",f.minimum(x,y),f.maximum(x,y));
                    break;
                case(5):
                    scanf("%lf%lf%lf",&x,&y,&z);
                    puts(f.cross(x,y,z)?"2":"0");
                    break;
            }
        }
        printf("%.2lf\n",f.extreme());
    }
}
```

千万注意细节，这题一个小细节能让你交上十遍。。。

---

## 作者：一只书虫仔 (赞：2)

超 级 多 合 一

#### Description

> 给定一个函数 $y=ax^2+bx+c$，并给定 $n$ 次操作：
> 1. 将函数向上平移 $k$ 位；
> 2. 将函数向右平移 $k$ 位；
> 3. 将函数关于 $(k_1,k_2)$ 对称；
> 4. 求函数在 $[k_1,k_2]$ 上的最大值和最小值；
> 5. 求函数与 $y'=ux^2+vx+w$ 是否有交点
>
> 回答第 4 次和第 5 次操作的答案，并在每次操作后输出当前函数的最值。

#### Solution

既然有一堆基本上互不相干的操作，我们就逐个处理。

**操作 1**：函数变为 $y=ax^2+bx+c+k$。

**操作 2**：函数变为 $y=a(x-k)^2+b(x-k)+c$，即 $ax^2+(b-2ak)x+ak^2-bk+c$。

**操作 3**：一个点 $(x,y)$ 经 $(k_1,k_2)$ 对称后是 $(2k_1-x,2k_2-y)$，代入式子即：

$$\begin{aligned}2k_2-y&=a(2k_1-x)^2+b(2k_1-x)^2+c\\y&=2k_2-a(2k_1-x)^2+b(2k_1-x)^2+c\\y&=-ax^2+(4ak_1+b)x-4ak_1^2-2bk_1+2k_2-c\end{aligned}$$

**操作 4**：分两种情况讨论：

- 对称轴经过 $[k_1,k_2]$，那么函数最值就是对称轴，另一个就是端点。
- 对称轴不经过 $[k_2,k_2]$，那么两个最值肯定都是观点。

判断即可，要对 $a$ 的正负性分类讨论。

**操作 5**：联立方程：

$$\begin{aligned}ax^2+bx+c&=ux^2+vx+w\\(a-u)x^2+(b-v)x+c-w&=0\end{aligned}$$

看做一个一元二次方程，列出 $\Delta$：

$$\begin{aligned}\Delta&=(b-v)^2-4(a-u)(c-w)\\&=b^2-2bv+v^2-4ac+4aw+4uc-4uw\end{aligned}$$

当 $\Delta \ge 0$ 时，两个函数有交点；当 $\Delta < 0$ 时，两个函数无交点。

**函数最值**：代入二次函数的顶点坐标公式 $\left(-\frac{b}{2a},\frac{4ac-b^2}{4a}\right)$ 的纵坐标。

---

## 作者：yegengghost (赞：1)

终于找到简单题了，太不容易了……

对于前两个指令，我们需要联想到那经典的口诀：

**左加右减，上加下减**

那么第一个只需要将 $c$ 加上 $k$ 即可。

第二个会有点棘手，但是我们可以化公式：

$$\begin{aligned} a(x-k)^2+b(x-k)+c &= a(x^2-2xk+k^2)+bx-bk+c\\ &=ax^2+bx+c-2axk+ak^2-bk \\ &=ax^2+(b-2ak)x+(ak^2-bk+c)  \end{aligned}$$

那么，$b$ 就减少了 $2ak$，$c$ 增加了 $ak^2-bk$。

……那么您猜为什么一个子任务没有操作三？

~~得了，确实挺难，这也算为我开学升初四做准备了。~~

首先预备知识就是二次函数的转化。

~~我们充分发扬人类智慧~~仿照着一元二次方程的求根公式对二次函数作出如下改动：

$$\begin{aligned} ax^2+bx+c &=a(x^2+\frac{b}{a})+c \\&=a(x^2+2\times\frac{b}{2a})+c \\&=a[x^2+2\times\frac{b}{2a}+(\frac{b}{2a})^2]+c-a\times (\frac{b}{2a})^2 \\&=a(x+\frac{b}{2a})^2+\frac{4ac-b^2}{4a} \end{aligned}$$

很难发现，化完式子后该函数的极值取决于后半部分，而前半部分为零时——即 $x$ 为 $-\frac{b}{2a}$——就是该函数的对称轴。

要不大家这把自行脑补下吧：

由于对称后相当于对二次函数向着水平方向平移，同时我们知道平移距离为对称轴距离与原来二次函数对称轴距离之差的绝对值的一倍，所以我们得对二次函数进行大手术。化简后为：

$$y=-ax^2+(4ak_1+b)x+2k_2-4ak_1^2-2bk_1-c$$

第四个操作直接把两个数代入找最大值与最小值即可……吗？

**这里是个难点。**

它指的是一个区间，但是由于二次函数不是单调函数，所以我们需要分讨。

对于二次函数的一个区间，极值只会在顶点或者区间边界上，所以我们先考虑顶点的横坐标——即对称轴的横坐标——是否在所给区间上，之后不满足则比较 $k_1$ 与 $k_2$ 代入的最大最小值。

第五个操作，您是否感觉似曾相识？那就是二元一次方程！

我们照着在学校学的知识浅浅地做一下可得：

$$
\begin{cases}
  y_1=ax_1^2+bx_1+c \\
  y_2=ux_2^2+vx_2+w
\end{cases}
$$

判断有无交点，我们就假设 $y_1=y_2$，则可得：

$$ax^2+bx+c=ux^2+vx+w$$

移项，得：

$$(a-u)x^2+(b-v)x+(c-w)=0$$

~~第一次写这么多，后面就不细写了~~然后根据根的判别式判断结果即可。即判断下列式子是否不小于零，若是则输出 $2$，否则输出 $0$：

$$\Delta =(b-v)^2-4(a-u)(c-w)$$

什么，最后还要输出极值？

输出 $\frac{4ac-b^2}{4a}$ 就行了！

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
signed main()
{
	scanf("%d",&t);
	while(t--)
	{
		int n;
		double a,b,c;
		scanf("%lf%lf%lf",&a,&b,&c);
		scanf("%d",&n);
		while(n--)
		{
			int opt;
			scanf("%d",&opt);
			if(opt==1)
			{
				double k;
				scanf("%lf", &k);
				double aa=a;
				double bb=b;
				double cc=c+k;
				a=aa;
				b=bb;
				c=cc;
			}
			else if(opt==2)
			{
				double k;
				scanf("%lf", &k);
				double aa=a;
				double bb=b-2.0*a*k;
				double cc=c+a*k*k-b*k*1.0;
				a=aa;
				b=bb;
				c=cc;
			}
			else if(opt==3)
			{
				double k1,k2;
				scanf("%lf%lf", &k1,&k2);
				double aa=-a*1.0;
				double bb=b+4.0*a*k1;
				double cc=2.0*k2-4.0*a*k1*k1-2.0*b*k1-c;
				a=aa,b=bb,c=cc;
			}
			else if(opt==4)
			{
				double k1, k2;
				double dcz=-(b/2/a);
				scanf("%lf%lf",&k1,&k2);
				if(a>0) 
				{
					if(k2<dcz)
						printf("%.2lf %.2lf\n",a*k2*k2+b*k2+c,a*k1*k1+b*k1+c);
					else if(k1<dcz)
					{
						if(k2-dcz<dcz-k1)
							printf("%.2lf %.2lf\n",a*dcz*dcz+b*dcz+c,a*k1*k1+b*k1+c);
						else if(k2-dcz>=dcz-k1)
							printf("%.2lf %.2lf\n",a*dcz*dcz+b*dcz+c,a*k2*k2+b*k2+c);
					} else
						printf("%.2lf %.2lf\n",a*k1*k1+b*k1+c,a*k2*k2+b*k2+c);
				}
				else if(a<0)
				{
					if(k2<dcz)
						printf("%.2lf %.2lf\n",a*k1*k1+b*k1+c,a*k2*k2+b*k2+c);
					else if(k1<dcz)
					{
						if(k2-dcz<dcz-k1)
							printf("%.2lf %.2lf\n",a*k1*k1+b*k1+c,a*dcz*dcz+b*dcz+c);
						else if(k2-dcz>=dcz-k1)
							printf("%.2lf %.2lf\n",a*k2*k2+b*k2+c,a*dcz*dcz+b*dcz+c);
					} else
						printf("%.2lf %.2lf\n",a*k2*k2+b*k2+c,a*k1*k1+b*k1+c);
				}
			}
			else if(opt==5)
			{
				double u,v,w;
				scanf("%lf%lf%lf",&u,&v,&w);
				double d=(b-v)*(b-v)-4.0*(a-u)*(c-w);
				if(d>=0)
					printf("2\n");
				else
					printf("0\n");
			}
		}
		printf("%.2lf\n",(4.0*a*c-b*b)/4.0/a);
	}
	return 0;
}
```


散会！

---

## 作者：zhanghengrui (赞：1)

楼上两位大佬都是用的顶点式

然而本蒟蒻已经把顶点式忘了

于是我就只能手推一般式啦

---

设原函数为$y=ax^2+bx+c$

#### 操作1

向上平移$k$个单位

直接`c+=k`即可

#### 操作2

向右平移$k$个单位

显然，新的函数为$y=a(x-k)^2+b(x-k)+c$

化简一下就是$y=ax^2+(b-2ak)x+(ak^2-bk+c)$

#### 操作3

关于点$(k_1,k_2)$对称

设对称后的函数上某个点为$(x_0,y_0)$

则对应原函数上的点为$(2k_1-x_0,2k_2-y_0)$

所以$2k_2-y_0=a(2k_1-x_0)^2+b(2k_1-x_0)+c$

即$y_0=2k_2-a(2k_1-x_0)^2-b(2k_1-x_0)-c$

右式以$x_0$为主元，化简得$y_0=-ax_0^2+(4ak_1+b)x_0+(2k_2-4ak_1^2-2bk_1-c)$

所以对称后的函数为$y=-ax^2+(4ak_1+b)x+(2k_2-4ak_1^2-2bk_1-c)$

#### 操作4

求函数在$[k_1,k_2]$上的最值

二次函数区间最值只可能是区间端点或顶点，因此只需要判断对称轴（$x=-\frac{b}{2a}$）是否在区间上，是则最小值或最大值为顶点纵坐标（具体看开口朝向，向上则是最小值，向下则是最大值），否则最值必为区间端点之一。

#### 操作5

判断函数与$y=ux^2+vx+w$是否有交点

相当于判断方程$(a-u)x^2+(b-v)x+c-w=0$是否有实数解

一次方程就不用说了

如果是二次方程，直接用判别式即可

#### 二次函数最终的最值

显然是顶点纵坐标

根据[二次函数顶点坐标公式](https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9%E5%9D%90%E6%A0%87)，顶点纵坐标为$\frac{4ac-b^2}{4a}$

---

code

```cpp
#include <cstdio>
#include <algorithm>
struct function
{
	double a, b, c;
	function(double _a = 0.0, double _b = 0.0, double _c = 0.0) :a(_a), b(_b), c(_c) {}
	inline double operator()(double x) { return (a * x + b) * x + c; }
	inline void Up(double k)
	{
		c += k;
		return;
	}
	inline void Right(double k)
	{
		*this = function(a, b - 2.0 * a * k, a * k * k - b * k + c);
		return;
	}
	inline void Reflection(double k1, double k2)
	{
		*this = function(-a, 4.0 * a * k1 + b, 2.0 * k2 - 4.0 * a * k1 * k1 - 2.0 * b * k1 - c);
		return;
	}
};
int main()
{
	int T, n, p;
	double k, k1, k2, u, v, w, tmp, ans[2];
	function f;
	scanf("%d", &T);
	while (T--)
	{
		scanf("%lf%lf%lf%d", &f.a, &f.b, &f.c, &n);
		while (n--)
		{
			scanf("%d", &p);
			switch (p)
			{
			case 1:
				scanf("%lf", &k);
				f.Up(k);
				break;
			case 2:
				scanf("%lf", &k);
				f.Right(k);
				break;
			case 3:
				scanf("%lf%lf", &k1, &k2);
				f.Reflection(k1, k2);
				break;
			case 4:
				scanf("%lf%lf", &k1, &k2);
				tmp = -0.5 * f.b / f.a;
				ans[0] = std::min(f(k1), f(k2));
				ans[1] = std::max(f(k1), f(k2));
				if (tmp >= k1 && tmp <= k2)
				{
					if (f.a > 0.0) ans[0] = f(tmp);
					else ans[1] = f(tmp);
				}
				printf("%.2lf %.2lf\n", ans[0], ans[1]);
				break;
			case 5:
				scanf("%lf%lf%lf", &u, &v, &w);
				puts((f.a == u ? (f.b == v ? f.c == w : true) : (f.b - v) * (f.b - v) - 4.0 * (f.a - u) * (f.c - w) >= 0.0) ? "2" : "0");
				break;
			}
		}
		printf("%.2lf\n", 0.25 * (4 * f.a * f.c - f.b * f.b) / f.a);
	}
	return 0;
}
```

---

如有锅请私信联系我或者在题解下评论

可能会在评论中发布更正

---

## 作者：huangx607087 (赞：1)

又是一条暴力模拟
~~本蒟蒻已经被P3952时间复杂度虐惨~~

这道题实际上是关于数学和二次函数的题目，涉及到图像的变换问题。

乍一看，y=ax²+bx+c似乎令人无从下手，不过我们可以利用我们的数学知识，将函数变换成y=a(x-k)²+h，表示顶点为(k,h)的抛物线，~~因为：|a|全程不变~~

那么我们很容易得到k，h和a，b，c的关系:
```
k=-b/(2*a);
h=c-k*k*a;
```

接着就是各种移动：上下移改变h，左右移改变k。操作1和操作2都很简单

操作4：判断区间最大值和最小值：那么我们需要看看对称轴k在不在定义域内，还要看看开口向上还是向下，开口向上那么fkaojin是最小值，fyuanli是最大值，开口向下反之

操作5：判断2个函数有没有交点，很容易想到相减后判断det=b²-4ac。但是问题来了：我们已经把y=ax²+bx+c切换成了y=a(x-k)²+h，本蒟蒻本来是想不断更新两个函数，然后RE了两个点。那么：y=a(x-k)²+h和y=px²+qx+r两个函数相减，此时det是可以算出来的。~~本蒟蒻又耗费了一张草稿纸~~
```
det=(2*a*k+q)*(2*a*k+q)-4*(a-p)*(a*k*k+h-r);
```
最难的是变换3：旋转。把定点(k,h)绕着另一个点(p,q)旋转到(k',h')，我们可以利用对称性，计算出k',h'的数值：```k=2*p-k，h=2*q-h;```。这里有个坑点：开口方向要改变，也就是改变a=-a。~~所以本蒟蒻把变换3的代码放在了最后~~

最后，奉上自己精(bu)心(kan)打(ru)造(mu)的代码

```
#include <bits/stdc++.h>
using namespace std;
int T,n;
double a,b,c;//ax2+bx+c
double k,h;//ax2+bx+c转化为a(x-k)2+h 
double f(double x) //函数思想，方程转化为函数f(x)= a(x-k)2+h
{
	return a*(x-k)*(x-k)+h; 
}
int main()
{
//	freopen("1.hx902in","r",stdin);
//	freopen("3.hx902out","w",stdout);
	int i,j;
	scanf("%d",&T);
	while(T--)
	{
		
		scanf("%lf%lf%lf",&a,&b,&c);
		k=-b/(2*a);
		h=c-k*k*a;//ax2+bx+c转化成a(x-k)+h，注意：a可以一直使用，但b，c要转化 
		scanf("%d",&n);
		while(n--)
		{
			int tipic;//type好像是关键字所以我改一下 
			scanf("%d",&tipic);
			if(tipic==1)
			{
				double p;
				scanf("%lf",&p);//上移 
				h+=p;
			}
			if(tipic==2)
			{
				double p;
				scanf("%lf",&p);//左移 
				k+=p;
			}
			if(tipic==4)
			{
				double p,q;
				double fkaojin,fyuanli;//计算靠近点和远离点 
				scanf("%lf%lf",&p,&q); 
				if(k>=p&&k<=q)//对称轴在定义域内 
					fkaojin=k;
				else //对称轴不再定义域内 
				{
					if(fabs(k-p)>fabs(k-q)) fkaojin=q;
					else fkaojin=p;//判断一下远离对称轴的点是哪个 
				}
				if(fabs(k-p)>fabs(k-q)) fyuanli=p;
					else fyuanli=q;
				if(a>0)//注意开口方向 
				{
					printf("%.2lf %.2lf\n",f(fkaojin),f(fyuanli));
				} 
				if(a<0)
				{
					printf("%.2lf %.2lf\n",f(fyuanli),f(fkaojin));
				}
			}
			if(tipic==5)
			{
				double p,q,r;
				scanf("%lf%lf%lf",&p,&q,&r);//判断有几个根 
				double det=(2*a*k+q)*(2*a*k+q)-4*(a-p)*(a*k*k+h-r);
				if(det>=0) printf("%d\n",2);
				else printf("%d\n",0);
			}
			if(tipic==3)//这个是旋转，也是最难得，我草稿纸上画了很久才算出来 
			{
				double p,q;
				scanf("%lf%lf",&p,&q);
				a=-a;
				k=2*p-k;
				h=2*q-h;
			}
		}
		printf("%.2lf\n",h);
	}
	return 0;
}
```
多练习练习模拟，还是很好的。因为：~~万题可模~~。
~~NOIP2018D1T2一个背包问题在考场上硬是被我看做模拟然后搞了75分~~

最后推荐一道难度差不多的模拟题：P4711



---

## 作者：kangli (赞：1)

**一题简单的模拟**

我们不妨把$y=ax^{2}+bx+c$改为顶点式$y=a(x- \frac{b}{2a})^{2}+c-\frac{b^{2}}{4a}$，设为$y=a(x+h)^{2}+b$

那样实现就很简单了。

操作$1$：直接将$b$加上$k$

操作$2$：直接将$h$加上$k$

操作$3$：推公式得，$y=a(x-h)^{2}+b$关于点$(k_1,k_2)$的解析式为$y=-a(x+k_1*2-h)+2*k_2-b$

操作$4$：分开口向上或者向下，对称轴与区间位置讨论即可，不用我多说了吧。

操作$5$：先把点式$y=a(x+h)^{2}+b$改为$y=ax^{2}+bx+c$，在设方程$ax^{2}+bx+c=ux^{2}+vx+w$，移项得$(a-u)x^{2}+(b-v)x+c-w$，根据一元二次方程求根关系，判断$\Delta$正负关系。

求最值，这个直接算出对称轴上的值即可。

题目很良心QAQ。

代码：
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<map>
#include<cmath>
#include<vector>
#include<queue>
#define ca(a) scanf("%lf",&a)
using namespace std;
typedef double db;
double T,n,m;
double a,b,c;
double u,v,w;
double k,p,k1,k2;
double h,num;
void cl()
{
    h=-b/2/a;
    num=c-a*h*h;
  //  printf("%.2lf(x-%.2lf)^2+%.2lf\n",a,h,num);
}
double js(double x)
{
    return a*(x-h)*(x-h)+num;
}
void dfs1(){
    num+=k;
   // printf("%.2lf(x-%.2lf)^2+%.2lf\n",a,h,num);
}
void dfs2(){
    h+=k;
  //  printf("%.2lf(x-%.2lf)^2+%.2lf\n",a,h,num);
}
void dfs3()
{
    a=-a;
    num=2*k2-num;
    h=k1*2-h;
  //  printf("%.2lf(x-%.2lf)^2+%.2lf\n",a,h,num);
}
void dfs4(){
    double dd=js(h),l=js(k1),r=js(k2);
    if (a>0)
    {	
        double maxx=max(l,r),minn=min(l,r);
        if (h>=k1 && h<=k2) printf("%.2lf %.2lf\n",dd,maxx);
        else printf("%.2lf %.2lf\n",minn,maxx);
    }
    if (a<0)
    {
        double maxx=max(l,r),minn=min(l,r);
        if (h>=k1 && h<=k2) printf("%.2lf %.2lf\n",minn,dd); 
        else printf("%.2lf %.2lf\n",minn,maxx);
    }
}
int dfs5()
{
    double deleta=(2*a*h+v)*(2*a*h+v)-4*(a-u)*(a*h*h+num-w);
    if (deleta>=0) return 2;
    if (deleta<0) return 0;
    return 0;
}
double dfs6(){
    return js(h);
}
int main()
{
    cin>>T;
    while (T--)
    {
        cin>>a>>b>>c;
        cl();
        cin>>n;
        for (int i=1; i<=n; i++)
        {
            cin>>p;
            if (p==1) ca(k),dfs1();
            if (p==2) ca(k),dfs2();
            if (p==3) ca(k1),ca(k2),dfs3();
            if (p==4) {
                ca(k1),ca(k2);
                dfs4();
            }
            if (p==5) {
                ca(u),ca(v),ca(w);
                cout<<dfs5()<<endl;}
        }
        printf("%.2lf\n",dfs6());
    }
    return 0;
}//kl
```

---

## 作者：Eleveslaine (赞：1)

一道数**雪**题。  
本人初二，所以不会二次函数。~~事什么，好吃吗？~~  
前置知识：一元二次方程的解法、二次函数的基本概念。

## Solution

给你一个二次函数，进行一堆操作，每次操作如下所述。  
目录：操作 [$\boxed{\tt 1}$](https://www.luogu.com.cn/blog/fbi-blogs/solution-p5139#:~:text=%E6%93%8D%E4%BD%9C%201) [$\boxed{\tt 2}$](https://www.luogu.com.cn/blog/fbi-blogs/solution-p5139#:~:text=%E6%93%8D%E4%BD%9C%202) [$\boxed{\tt 3}$](https://www.luogu.com.cn/blog/fbi-blogs/solution-p5139#:~:text=%E6%93%8D%E4%BD%9C%203) [$\boxed{\tt 4}$](https://www.luogu.com.cn/blog/fbi-blogs/solution-p5139#:~:text=%E6%93%8D%E4%BD%9C%204) [$\boxed{\tt 5}$](https://www.luogu.com.cn/blog/fbi-blogs/solution-p5139#:~:text=%E6%93%8D%E4%BD%9C%205)

---

### 操作 1

向上平移 $k$ 单位长度：$c\gets c+k$。

---

### 操作 2

将一个函数向右平移 $k$ 单位长度，也就是将解析式中每个 $x$ 替换为 $x-k$。  
由此，平移后的二次函数解析式为 $f(x)=a(x-k)^2+b(x-k)+c$。  
随便展开一下：$f(x)=ax^2+(b-2ak)x+(ak^2-bk+c)$。  
所以将 $c$ 加上 $ak^2-bk$，$b$ 减去 $2ak$（注意操作顺序，先修改 $c$ 后修改 $b$）。

---

### 操作 3

将二次函数关于一个定点做对称，本题最麻烦的操作。  
由于知识水平受限，本人方法十分麻烦，简单来说：在原来二次函数上任选 $3$ 个点，然后分别对这 $3$ 个点做对称得到对称点坐标；再由 $3$ 个对称点坐标求出新二次函数解析式。  
提供[可拖动图像](https://www.desmos.com/calculator/dq0nb0wf2c?lang=zh-CN)。图像中选用的是和顶点左右水平 $1$ 个单位长度的两个点。

方便起见，这里选：顶点 $A(-\dfrac{b}{2a},f(-\dfrac{b}{2a}))$ 和顶点左右水平 $10$ 个单位长度的两个点 $B(-\dfrac{b}{2a}+10,f(-\dfrac{b}{2a}+10)),C(-\dfrac{b}{2a}-10,f(-\dfrac{b}{2a}-10))$。

> 引理：点 $(x_0,y_0)$ 关于点 $(k_1,k_2)$ 的对称点 $(2k_1-x_0,2k_2-y_0)$。（证明略）

令 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ 分别为 $A,B,C$ 关于 $(k_1,k_2)$ 对称点的坐标。由引理，不难求出

$$
\begin{aligned}
  x_1 & =2k_1-(-\dfrac{b}{2a}),\\
  y_1 & =2k_{2}-f(-\dfrac{b}{2a});\\
  x_2 & =2k_{1}-(-\dfrac{b}{2a}+10),\\
  y_2 & =2k_{2}-f(-\frac{b}{2a}+10);\\
  x_3 & =2k_{1}-(-\frac{b}{2a}-10),\\
  y_3 & =2k_{2}-f(-\frac{b}{2a}-10).
\end{aligned}
$$

然后待定系数法，设新二次函数解析式为 $y=a'x^2+b'x+c$，由方程组

$$
\left\{\begin{aligned}
  y_1 & =a'x_1^2+b'x_1+c',\\
  y_2 & =a'x_2^2+b'x_2+c',\\
  y_3 & =a'x_3^2+b'x_3+c'
\end{aligned}\right.
$$

解得新二次函数各项系数 $a',b',c'$：

$$
\left\{\begin{aligned}
  a' &= \frac{x_{1}(y_{3}-y_{2})+x_{2}(y_{1}-y_{3})+x_{3}(y_{2}-y_{1})}{(x_{1}-x_{2})(x_{1}-x_{3})(x_{2}-x_{3})},\\
  b' &= \frac{x_{1}^{2}(y_{2}-y_{3})+x_{2}^{2}(y_{3}-y_{1})+x_{3}^{2}(y_{1}-y_{2})}{(x_{1}-x_{2})(x_{1}-x_{3})(x_{2}-x_{3})},\\
  c' &= \frac{x_{2}x_{3}y_{1}(x_{2}-x_{3})+x_{1}x_{3}y_{2}(x_{3}-x_{1})+x_{1}x_{2}y_{3}(x_{1}-x_{2})}{(x_{1}-x_{2})(x_{1}-x_{3})(x_{2}-x_{3})}.\\
\end{aligned}\right.
$$

（引用自[此处](https://www.cnblogs.com/arcturus/p/9180349.html)）然后就没有然后了。将新的系数给到原来系数即可。  
这里之所以不用顶点左右 $1$ 单位的点而用 $10$ 单位长，是因为 $1$ 单位会被卡精度无法通过。用 $10$ 单位还是 $1$ 单位本质上没有区别，因为任意二次函数的定义域均为 $\mathbb R$，这个点一定存在。  
代码实现：

```cpp
// topX() 返回顶点的 x 坐标，即 topX()=-b/(2*a)
// f(x) 为函数值，即 f(x)=ax^2+bx+c
x1=2*k1-topX();
y1=2*k2-f(topX());
x2=2*k1-(topX()+10);
y2=2*k2-f(topX()+10);
x3=2*k1-(topX()-10);
y3=2*k2-f(topX()-10);
real div=(x1-x2)*(x1-x3)*(x2-x3);
real a1=(x1*(y3-y2)+x2*(y1-y3)+x3*(y2-y1))/div;
real b1=(x1*x1*(y2-y3)+x2*x2*(y3-y1)+x3*x3*(y1-y2))/div;
real c1=(x2*x3*y1*(x2-x3)+x1*x3*y2*(x3-x1)+x1*x2*y3*(x1-x2))/div;
a=a1,b=b1,c=c1;
```

---

### 操作 4

给定区间 $[k_1,k_2](k_1\le k_2)$，求区间最值。  
事实上，我们只需要计算最多三个点的函数值：$f(k_1),f(k_2)$ 和 $f(-\dfrac{b}{2a})\ (\text{if }k_1 \le -\dfrac{b}{2a} \le k_2)$（$-\dfrac{b}{2a}$ 即函数顶点）。

- 当 $a>0$ 时，如果 $k_1 \le -\dfrac{b}{2a} \le k_2$，那么最小值一定是顶点的函数值；否则最小值就是 $\min\{f(k_1),f(k_2)\}$。  
最大值是 $\max\{f(k_1),f(k_2)\}$。

- 当 $a<0$ 时，如果 $k_1 \le -\dfrac{b}{2a} \le k_2$，那么最大值一定是顶点的函数值；否则最大值就是 $\max\{f(k_1),f(k_2)\}$。  
最小值是 $\min\{f(k_1),f(k_2)\}$。

给出代码实现，自己画个图不难理解。

```cpp
inline real Min(real l,real r)
{
    if(a>0&&l<=topX()&&topX()<=r)
        return f(topX());
    return min(f(l),f(r));
}
inline real Max(real l,real r)
{
    if(a<0&&l<=topX()&&topX()<=r)
        return f(topX());
    return max(f(l),f(r));
}
```

---

### 操作 5

求函数是否与另一个二次函数 $y=ux^2+vx+w$ 有交点。  
显然，存在交点，即 $\exists P(x,y),y=ax^2+bx+c=ux^2+vx+w$。  
移项，得 $(a-u)x^2+(b-v)x+(c-w)=0$。  
这个二次方程有实数解，等价于存在交点。  
于是问题变为判断判别式 $\Delta=(b-v)^2-4(a-u)(c-w)$ 是否 $\ge 0$。

最后别忘了全部操作结束后输出极值，即顶点纵坐标 $f(-\dfrac{b}{2a})$。

---

完整代码就不给了，主要的都有。

---

## 作者：Genius_Star (赞：0)

### 思路：
一道一元二次函数背景的模拟题，我感觉比较简单了，基本就是照抄，先在演草纸上面写出来 123 操作之后的系数，然后照着写就行了。

#### 操作 1：
设 $y_1=a_1 \times x^2+b_1 \times x+c_1,y_2=a_2 \times x^2+b_2 \times x+c_2$。

令两个函数的 $x$ 都等于 $0$，分别代入两个函数中可得 $y_1=c_1,y_2=c_2$。

本来这个很显然的，但我想为了照顾那些还没有学二次函数的学弟，所以还是写写吧。

故，操作后的函数为：

$$y=a \times x^2+b \times x+c+k$$
#### 操作 2：
这个用顶点式的话很方便，但是我们这里只提一般式的做法，不过会借用一下顶点式。

首先，我们可以由顶点式 $y=a \times (x-h)^2+s$（由于为避免与题面中的 $k$ 重复，故改为 $s$）向右平移 $k$ 格后的式子为 $y=a \times (x-h-k)^2+s$。

然后再把它拆开，得到：

$$y=a \times x^2-(2 \times a \times k+2 \times a \times h)\times x+a \times h^2+a \times k^2+2 \times a \times h \times k+s$$

又由于我们知道 $h=-b^2 \times a,s=4 \times a \times c- b \times 24 \times a$，所以，直接将它强算过来，可以得到：

$$y=a \times x^2+(b-2 \times a \times k) \times x+a \times k^2-b \times k +c$$


故，操作后的函数为 $y=a \times x^2+(b-2 \times a \times k) \times x+a \times k^2-b \times k +c$。
#### 操作 3：
首先，我们令一个在抛物线上的点为 $(x_0,y_0)$，所以我们就有在与 $(k_1,k_2)$ 对称后的坐标为 $(2k_1-x_0,2k_2-y_0)$。

什么什么，要我讲原因？

可以，那请听我说：

由于它们的横坐标和纵坐标之差分别为 $(x_0-k_1,y_0-k_2)$，所以它的对称点的坐标：
$$(k_1-(x_0-k_1),k_2-(y_0-k_2))\Rightarrow(2k_1-x_0,2k_2-y_0)$$

那么我们再代入到 $y=ax^2+bx+c$ 中可得：

$$2k_2-y_0=a(2k_1-x_0)^2+b(2k_1-x_0)+c$$

因此可得到：
$$y_0=2k_2-a(2k_1-x_0)^2-b(2k_1-x_0)-c$$

那么再对右边的式子进行化简，然后再合并 $x$ 同类项，可得到：

$$y_0=-ax_0^2+(4ak_1+b)x_0+2k_2-4ak_1^2-2bk_1-c$$

故，操作后的函数为 $y=-ax^2+(4ak_1+b)x+2k_2-4ak_1^2-2bk_1-c$。
#### 操作 4：
这一段是我们的重头戏。

首先根据 $a<0$ 和 $a>0$ 两大类，再通过 $k_1,k_2$ 以及 $x'=-\frac{b}{2a}$ 之间的关系进行分类讨论。

笔者温馨提示：自己画一个函数图像具体分析，下面的两个图中作为例子的函数解析式左边有。

好的，那么现在就开始吧。

##### $a<0$：

那么这时候还需要 4 种情况来分类讨论：

1. $k_2<x'$，那么 $\text{ymin}=ak_2^2+bk_2+c,\text{ymax}=ak_1^2+bk_1+c$。
2. $k_2\geq x,k_1<x' \text{ 且 } k_2-x'<x'-k_1$，那么 $\text{ymin}=ax'^2+bx'+c,\text{ymax}=ak_1^2+bk_1+c$。
3. $k_2\geq x,k_1<x' \text{ 且 } k_2-x'\geq x'-k_1$，那么 $\text{ymin}=ax'^2+bx'+c,\text{ymax}=ak_2^2+bk_2+c$。
4. $k_1\geq x$，那么 $\text{ymin}=ak_1^2+bk_1+c,\text{ymax}=ak_2^2+bk_2+c$。

##### $a>0$：

同样，这时候还需要 4 种情况来分类讨论：

1. $k_2<x'$，那么 $\text{ymin}=ak_1^2+bk_1+c,\text{ymax}=ak_2^2+bk_2+c$。
2. $k_2\geq x,k_1<x' \text{ 且 } k_2-x'<x'-k_1$，那么 $\text{ymin}=ak_1^2+bk_1+c,\text{ymax}=ax'^2+bx'+c$。
3. $k_2\geq x,k_1<x' \text{ 且 } k_2-x'\geq x'-k_1$，那么 $\text{ymin}=ak_2^2+bk_2+c,\text{ymax}=ax'^2+bx'+c$。
4. $k_1\geq x$，那么 $\text{ymin}=ak_2^2+bk_2+c,\text{ymax}=ak_1^2+bk_1+c$。

至此，所有的分类讨论就完了，直接判断条件对应输出结果就好。
#### 操作 5：
这个倒比操作 4 简单，直接联立一下就得到 $ax^2+bx+c=ux^2+vx+w$。所以，我们就只需要判断这个方程是否有实数根就好了。

我们将上面这个方程移项，可以得到 $(a-u)x^2+(b-v)x+c-w=0$，所以，我们可以得到 $\Delta=(b-v)^2-4(a-u)(c-w)$。根据 $\Delta$ 可以判别出这个方程实数根的情况，也就可以判断这两个函数图像是否有交点了。具体如下——

当 $\Delta\geq 0$ 时，这个方程有实数根，这两个函数图像也就有交点了；否则，当 $\Delta<0$ 时，这个方程没有实数根，这两个函数图像也就没有交点了。

至此，用一般式解决本题的算法也就讲完了。顶点式的话题解区里的大佬们已经讲得很清楚了。

如有不懂的话，下面的代码也许能帮助你。
### 完整代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int t;

double f(double a, double b, double c, double x) {
	return a * x * x + b * x + c;
}

int main() {
	scanf("%d", &t);
	while(t--) {
		double a, b, c;
		int m;
		scanf("%lf%lf%lf%d", &a, &b, &c, &m);
		while(m--) {
			int opt;
			scanf("%d", &opt);
			if(opt == 1) {
				double k;
				scanf("%lf", &k);
				double a0 = a, b0 = b, c0 = c + k;
				a = a0, b = b0, c = c0;
			} 
			else if(opt == 2) {
				double k;
				scanf("%lf", &k);
				double a0 = a, b0 = b - 2 * a * k, c0 = a * k * k - b * k + c;
				a = a0, b = b0, c = c0;
			}
			else if(opt == 3) {
				double k1, k2;
				scanf("%lf%lf", &k1, &k2);
				double a0 = -a, b0 = 4 * a * k1 + b, c0 = 2 * k2 - 4 * a * k1 * k1- 2 * b * k1 - c;
				a = a0, b = b0, c = c0;
			}
			else if(opt == 4) {
				double k1, k2, xp = -(b / (2 * a)), yp = (4 * a * c - b * b) / (4 * a);
				scanf("%lf%lf", &k1, &k2);
				if(a > 0) {
					if(k2 < xp)	{
						printf("%.2lf %.2lf\n", f(a, b, c, k2), f(a, b, c, k1));
					}
					else if(k1 < xp) {
						if(k2 - xp < xp - k1) {
							printf("%.2lf %.2lf\n", f(a, b, c, xp), f(a, b, c, k1));
						}
						else if(k2 - xp >= xp - k1) {
							printf("%.2lf %.2lf\n", f(a, b, c, xp), f(a, b, c, k2));
						}
					} else {
						printf("%.2lf %.2lf\n", f(a, b, c, k1), f(a, b, c, k2));
					}
				} else if(a < 0) {
					if(k2 < xp)	{
						printf("%.2lf %.2lf\n", f(a, b, c, k1), f(a, b, c, k2));
					}
					else if(k1 < xp) {
						if(k2 - xp < xp - k1) {
							printf("%.2lf %.2lf\n", f(a, b, c, k1), f(a, b, c, xp));
						}
						else if(k2 - xp >= xp - k1)	{
							printf("%.2lf %.2lf\n", f(a, b, c, k2), f(a, b, c, xp));
						}
					} else {
						printf("%.2lf %.2lf\n", f(a, b, c, k2), f(a, b, c, k1));
					}
				}
			}
			else if(opt == 5) {
				double u, v, w;
				scanf("%lf%lf%lf", &u, &v, &w);
				double delta = (b - v) * (b - v) - 4 * (a - u) * (c - w);
				puts(delta < 0 ? "0" : "2");
			}
		}
		printf("%.2lf\n", (4 * a * c - b * b) / (4 * a));
	}
	return 0;
}

```


---

## 作者：newbeeglass (赞：0)

前置知识：初中数学。
### 解法：
总的来说，根据已有的数学知识模拟就好了。考虑到前两个操作是平移，第三个操作是中心对称，我们可以把 $y=ax^2+bx+c$ 转化成 $y=a(x-k)^2+m$，其中 $k$ 是对称轴横坐标,$m$ 是函数最值（注意 $k$ 前面是减号！）。

任何二次函数都可以转化成如上形式（顶点式），可以先将 $a$ 提取出来，变成 $y=a(x^2+\frac{b}{a}x+\frac{c}{a})$，然后使用配方法将括号内转化成一个完全平方式和一个常数，最终结果如下：

$y=a(x-\frac{b}{2a})^2+\frac{4ac-b^2}{4a}$

$\Rightarrow$ $k=-\frac{b}{2a}$，$m=\frac{4ac-b^2}{4a}$

前三个操作做法：操作 $1$ 是水平平移，和原来的函数相比，改变了对称轴的位置，反过来说，只要改变对称轴的位置，就能实现水平平移，将 $k$ 加上输入的系数即可；操作 $2$ 是纵向平移，与前者类似，可以理解为改变了最值，其他不变，所以将 $m$ 加上输入的系数即可。操作 $3$ 是中心对称，可以任取一个二次函数和一个点模拟一下：
![模拟](https://cdn.luogu.com.cn/upload/image_hosting/crelb1dq.png)
中心对称之后图像形状不变，但开口方向变了，易知 $a$ 变成了 $-a$，而两个顶点关于图中的 $A$ 点对称，可知两顶点横坐标（即两个函数的对称轴）的平均数就是 $A$ 点横坐标，纵坐标同理，设 $A(x_{1},x_{2})$，那么 $k$ 变成了 $2x_{1}-k$，$m$ 变成了 $2x_{2}-m$，前三个操作结束。

后两个操作：操作 $4$ 是求最值，由二次函数图像可知，最值要么在顶点上，要么在区间端点上，所以只需要对这三个点进行判断即可，设区间为 $[x1,x2]$，二次函数为 $f(x)$，若对称轴在区间内，输出 $min(m,f(x1),f(x2))$ 和 $max(m,f(x1),f(x2))$ 即可，若对称轴不在区间内，则输出 $min(f(x1),f(x2))$ 和 $max(f(x1),f(x2))$。操作 $5$ 是判断两个二次函数是否有交点，用代数的方式来理解，就是判断联立两个方程后 $x$ 是否有实数根，看 $\Delta$ 即可：

$\begin{aligned}y&=a(x-k)^2+m\\&=ax^2-2akx+ak^2+m\end{aligned}$

$ax^2-2akx+ak^2+m=ux^2+vx+w$

$\Rightarrow$ $(a-u)x^2-(2ak+v)x+ak^2+m-w=0$

$\begin{aligned}\Delta&=b^2-4ac\\&=(2akx+v)^2-4(a-u)(ak^2+m-w)\end{aligned}$

若 $\Delta<0$，便没有交点，输出 $0$，否则输出 $2$。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
double a,b,c,k,m;
int main(){
	cin>>T;
	while(T--){
		cin>>a>>b>>c>>n;
		k=-(b/(2*a));
		m=(4*a*c-b*b)/(4*a);//计算 k 和 m 
		while(n--){
			int s;
			double w1,w2,u,v,w;
			cin>>s;
			if(s==1){
				cin>>w;
				m+=w;
			}
			else if(s==2){
				cin>>w;
				k+=w;
			}
			else if(s==3){
				cin>>w1>>w2;
				k=2*w1-k;
				m=2*w2-m;
				a=-a;
			}
			else if(s==4){
				cin>>w1>>w2;
				if(w1>w2){
					swap(w1,w2);//保险一点 
				}
				if(a>0){//敲代码的时候想复杂了，其实这里不需要判断a的正负，只需要 max 和 min 函数就好了 
					if(k<=w1){
						printf("%.2lf %.2lf\n",a*(w1-k)*(w1-k)+m,a*(w2-k)*(w2-k)+m);//以下这些一长串的式子都是带入求值 
					}
					else if(k>=w2){
						printf("%.2lf %.2lf\n",a*(w2-k)*(w2-k)+m,a*(w1-k)*(w1-k)+m);
					}
					else{
						printf("%.2lf %.2lf\n",m,max(a*(w1-k)*(w1-k)+m,a*(w2-k)*(w2-k)+m));
					}
				}
				else{
					if(k<=w1){
						printf("%.2lf %.2lf\n",a*(w2-k)*(w2-k)+m,a*(w1-k)*(w1-k)+m);
					}
					else if(k>=w2){
						printf("%.2lf %.2lf\n",a*(w1-k)*(w1-k)+m,a*(w2-k)*(w2-k)+m);
					}
					else{
						printf("%.2lf %.2lf\n",min(a*(w1-k)*(w1-k)+m,a*(w2-k)*(w2-k)+m),m);
					}
				}
			}
			else{
				cin>>u>>v>>w;
				double t1,t2,t3;
				t1=a,t2=-(2*a*k),t3=a*k*k+m;
				t1-=u,t2-=v,t3-=w;
				double d=t2*t2-4*t1*t3;//计算判别式 
				if(d<0){
					cout<<0<<endl;
				}
				else{
					cout<<2<<endl;
				}
			}
		}
		printf("%.2lf\n",m);
	}
}

```


---

## 作者：Blender (赞：0)


### 这是本人第一次写题解，若有不足还望指教

本题给定一个二次函数,有以下操作:

-   上移 (下移)  

-   右移 (左移)

-   关于定点对称

会询问:

-   求区间最值

-   与给定的二次函数是否有交点

我们先观察操作,操作中涉及平移和对称,其他题解都是用顶点式实时更新系数,事实上,这些操作都可以通过更新二次项系数 a 和 顶点坐标 来实现。

#### 所以，我的思路是 : 将原式转化成 a 与顶点坐标 (x,y)。

#### 对于上移操作，将 y 加上 k

#### 对于右移操作，将 x 加上 k

#### 对于对称操作，其相当于将顶点对称后上下翻转图像，即 x += 2 (k1-x) , y += 2 (k2-y), a = - a;

最后在查询时只需根据 a 与顶点坐标 (x,y) 推出 b, c, 再进行处理就可以了。

再说查询:

#### 求最值时，只须将k1, k2 代入函数，求出最值

## 注意，如果顶点也包括在区间中，则还需考虑顶点。

#### 我们知道，求交点时，是通过联立方程求解的，如果有解，说明有交点。所以，只需判断判别式 Δ 是否  ≥ 0 ， 如果 ≥ 0，输出 2， 否则输出 0。

而代码的核心在于顶点坐标与系数的转化，其他题解中介绍得十分详尽，详见代码。

由于最复杂的是 b, c 和 x, y 间的转化，跟 a 的关系不大, 所以使用  **STL pair**两两存储，当然可以不用，似乎不用还更简单。~~但自我感觉用了以后”简洁“了不少~~

附上代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int T;
pair <double, double> GetPos (double a, pair <double, double> dat){//通过系数求顶点坐标 
    pair <double, double> ans;
    double b = dat.first, c = dat.second;
    ans.first = - b / a / 2;
    ans.second = c - b * b / 4 / a;
    return ans;
}
pair <double, double> ReturnDat (double a, pair <double, double> pos){//通过顶点坐标求系数 
	pair <double, double> ans;
	double x = pos.first, y = pos.second;
	ans.first = - 2 * x * a;
	ans.second = y + x * x * a;
	return ans;
}
double f (double a, double b, double c, double x){//计算函数值 f(x) = ax^2+bx+c 
	return a * x * x + b * x + c;
}
int main (){
    cin >> T;
    while (T --){
        double a, b, c;
        cin >> a >> b >> c;
        pair <double, double> POS = GetPos (a, make_pair (b, c));//保存顶点坐标 
        int n;
        cin >> n;
        while (n --){
	        int Unit;
	        cin >> Unit;
	        if (Unit == 1){
	            double x;
	            cin >> x;
	            POS.second += x;//上移操作 
	        }
	        if (Unit == 2){
	            double x;
	            cin >> x;
	            POS.first += x;//右移操作 
	        }
	        if (Unit == 3){
	            double x, y;
	            cin >> x >> y;
	            a = -a;//对称后图像翻转了 
	            POS.first += 2 * (x - POS.first);
	            POS.second += 2 * (y - POS.second);//仍然存储顶点坐标 
	        }
	        if (Unit == 4){
	        	double x, y;
	        	cin >> x >> y;
	        	double MIN = 21474836470, MAX = -21474836470;//MIN,MAX存储最小值,最大值 
	        	if (x < POS.first && y > POS.first) MIN = MAX = POS.second;//特判顶点在其中的情况 
	        	b = ReturnDat (a, POS).first;
	        	c = ReturnDat (a, POS).second;//更新系数 
	        	MIN = min (MIN, min (f (a, b, c, x), f (a, b, c, y)));
	        	MAX = max (MAX, max (f (a, b, c, x), f (a, b, c, y)));
	        	printf ("%.2lf %.2lf\n", MIN, MAX);
	        }
	        if (Unit == 5){
	        	double u, v, w;
	        	cin >> u >> v >> w;
	        	b = ReturnDat (a, POS).first;
	        	c = ReturnDat (a, POS).second;
	        	if ((v-b)*(v-b)-4*(u-a)*(w-c) >= 0) cout << "2\n";//联立方程,通过 Δ判断是否有交点 
	        	else cout << "0\n";
	        }
		}
		printf ("%.2lf\n", POS.second);
    }
    return 0;
}
```


---


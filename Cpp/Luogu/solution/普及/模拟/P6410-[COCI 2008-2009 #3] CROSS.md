# [COCI 2008/2009 #3] CROSS

## 题目背景

在数独游戏中，目标是将 $1 \sim 9$ 的整数放入 $9 \times 9$ 网格中，这样每行每列以及 $9$ 个 $3 \times 3$ 框的每一个都包含所有 $9$ 个数字不重复的数字。开始 $9 \times 9$ 的方格纸已部分填充，因此可以从逻辑上推导出其他单元格的值。 

数独有很多难题，解决越困难的往往需要越复杂的分析方法。 

## 题目描述

在这道题中，你需要用到最简单的方法，即交叉影线。

在方格之中，我们选择 $9$ 个数字中的 $1$ 个，并针对网格中每个出现的数字划掉相应的行，列和 $3 \times 3$ 的框。 寻找一个的 $3 \times 3$ 区域，将号码的位置并将其放置在此处。

系统会为您提供部分填充的网格。您的任务是重复使用交叉影线的方法，对于不同的数字，直到无法再对任何数字进行推论。  

下面的第一张图片显示了一个非常稀疏的数独。但是，即使如此稀疏，但在此网格中仍然可以使用交叉阴影线推断左上角单元格中的数字为 $4$，如第二张图片。

![](https://cdn.luogu.com.cn/upload/image_hosting/6mjuqfi9.png)


另外，在下列情况下，您需要输出 $\tt ERROR$：
- 数字在网格中的初始放置无效。
- 在所有的 $3 \times 3$ 框中无法填写此数字。

## 说明/提示

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #3](https://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf) *T3 CROSS*。**



## 样例 #1

### 输入

```
..9......
.....4...
.......4.
.........
.4.......
.........
.........
.........
......... 
```

### 输出

```
4.9......
.....4...
.......4.
.........
.4.......
.........
.........
.........
......... 
```

## 样例 #2

### 输入

```
...1...6.
18...9...
..7.642..
2.9..6.5.
.43...72.
.6.3..9.1
..265.1..
...2...97
.5...3... ```

### 输出

```
524137869
186529473
397864215
219476358
843915726
765382941
972658134
638241597
451793682 ```

## 样例 #3

### 输入

```
1........
..1......
.......1.
.........
.........
.........
.........
.........
......... 
```

### 输出

```
ERROR 
```

## 样例 #4

### 输入

```
........2
....1....
1........
......1..
.........
.........
.........
.......1.
......... 
```

### 输出

```
ERROR ```

# 题解

## 作者：Rain_chr (赞：9)

在本人看来，这道题是一个大模拟

~~不升绿都对不起我的付出~~

------------

### 题意简述

给定网格，完成以下任务：

+ 判断给定的网格是否合法。

+ 反复使用交叉影线发，直至所有格子都无法根据已有信息推断出当前格子的数值。


------------


### 题目分析

我的做法是直接模拟，先填充，如果填充时发现有矛盾，就判定此网格非法。

#### 1. 划掉格子

遍历每一个格子，如果这个格子中有数字且从未被遍历过，就进行筛法：

先将这个格子的所有可能性全部划掉，因为这个格子已经有数字了。

再将与其同行、同列、同宫的格子全部划掉。

特别注意：只是将关于这个格子中的数字的可能性划掉，而不是所有。

#### 2.填充格子

遍历每一个格子，如果这一个格子还没填充且可能性只有一个，就将这只可能的数填入这个格子。

关于什么时候截止，我的做法是当所有格子都没有变动后，跳出循环。

### 3.判断合法

我分了三个情况：

1. 没填充的格子没有任何能填充的数字

2. 填充了的格子行列有重复

3. 填充了的九宫格有数不可能出现

~~虽然不全，但对这个题目够用了~~


------------


#### 重要提示：
+ 请严格按照题面来，不要把这道题想象成数独。

+ 按照数独的方法去做，只有七十分。

因为这道题里，他的方法有缺陷，不能把所有能填充的格子填充。

有一个测试点，这一列有八个数，就空缺了一个格子，且输入合法，我七十分的代码能处理剩下的格子，但AC代码和标准代码不行。测试点输出中这个格子也是空着的。


然后就是愉快的交代码了！

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int value;
	int checked;
	int maybe[10];
}a[10][10]; //这是地图
int b[10][10]; 
void init() //这个预处理是判断两个数在不在一个九宫格内的。这是以时间换省事，大家不要学。
{
	int ti=1;
	for(int i=1;i<=9;i+=3)
	{
		for(int j=1;j<=9;j+=3)
		{
			for(int k1=0;k1<3;k1++)
			{
				for(int k2=0;k2<3;k2++)
				{
					b[i+k1][j+k2]=ti;

				}
			}
			ti++;
		}
	}
}
bool check() //三条判断
{
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(a[i][j].value>0)
				continue;
			int k=0;
			for(int x=1;x<=9;x++)
				k+=a[i][j].maybe[x];
			if(k==9)
				return 1; 
		}
	}
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(a[i][j].value<1)
				continue;
			for(int k=1;k<=9;k++)
			{
				if(k==j||k==i)
					continue;
				if(a[i][j].value==a[i][k].value||a[i][j].value==a[k][j].value)
					return 1;
			}
		}
	}
	for(int k=1;k<=9;k++)
	{
		for(int i=1;i<=9;i+=3)
		{
			for(int j=1;j<=9;j+=3)
			{
				int num=0;
				for(int k1=0;k1<3;k1++)
					for(int k2=0;k2<3;k2++)
						num+=a[i+k1][j+k2].maybe[k];
				if(num==9)
				{
					bool f=0;
					for(int k1=0;k1<3;k1++)
						for(int k2=0;k2<3;k2++)
							if(a[i+k1][j+k2].value==k)
							{
								f=1;
								break;
							}
					if(!f)
						return 1;
				}
			}
		}
	}
	return 0;
}
int main()
{
	init();
	string s;
	for(int i=1;i<=9;i++)
	{
		cin>>s;
		for(int j=0;j<s.size();j++)
			a[i][j+1].value=s[j]-'0',a[i][j].checked=0;
	}

	bool flag=1;
	while(flag)
	{
		flag=0;
		for(int i=1;i<=9;i++) //交叉影线
		{
			for(int j=1;j<=9;j++)
			{
				if(a[i][j].value>0&&!a[i][j].checked)
				{
					for(int k=1;k<=9;k++)
						a[i][j].maybe[k]=1;
					for(int k=1;k<=9;k++)
						a[i][k].maybe[a[i][j].value]=1;
					for(int k=1;k<=9;k++)
						a[k][j].maybe[a[i][j].value]=1; 
					for(int k1=1;k1<=9;k1++)
					{
						for(int k2=1;k2<=9;k2++)
						{
							if(b[k1][k2]==b[i][j])
								a[k1][k2].maybe[a[i][j].value]=1;
						}
					}
					flag=1;
					a[i][j].checked=1;
				}
			}
		}
		
		for(int k=1;k<=9;k++) //填格 
		{
			for(int i=1;i<=9;i+=3)
			{
				for(int j=1;j<=9;j+=3)
				{
					int num=0,x,y;
					for(int k1=0;k1<3;k1++)
					{
						for(int k2=0;k2<3;k2++)
						{
							if(a[i+k1][j+k2].maybe[k]==0)
							{
								num++;
								x=i+k1;
								y=j+k2;	
							} 
						}
					}
					if(num==1)
						a[x][y].value=k;
				}
			}
		} 
	}
	if(check())
	{
		cout<<"ERROR";
		return 0; 
	}
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			if(a[i][j].value>0)
				cout<<a[i][j].value;
			else
				cout<<'.';
		}
		cout<<endl;
	}
	return 0; //撒花！！！
}
```


整整一百七十行代码啊~花了我一下午

完结撒花！

等等！

还有能正确处理所有数独的七十分代码，就当做送给大家了！

[数独代码](https://www.luogu.com.cn/paste/amq07hdm)

输入格式同本题

作者写了两个小时，点个赞再走吧~


---

## 作者：yaoyuchen2021 (赞：1)

# 题目大意
给出一个数独，若输入数独不合法输出 `ERROR`，否则填充所有可以**仅用交叉影线法**填充的格子并输出。

# 解题思路
- ### 判定合法
  不合法的情况分为两种，题目中都说了，我们可以分别判断：
  
  #### 初始放置无效
  在输入时，对于每一个非空格子，查找他出现的行列，若已经出现过这个数字，则不合法，输出 `ERROR`，结束程序。
  
  #### 一宫内无有效格子
  这个可以在填充格子时顺带判掉，如果一宫内填某一个数的不合法格子有 $9$ 个，则不合法，输出 `ERROR`，结束程序。
- ### 填充格子
  我们多次遍历，每一次枚举九个数字和九个宫，对宫内的九个格子判断是否可以填该数字，若不合法格子有 $8$ 个，那么剩下的一个格子就一定是这个数。

  我们充分发扬人类智慧，发现只要遍历 $81$ 次就够了 ~~（其实是看了另一篇题解才知道的~~

# AC Code

```cpp
#include <bits/stdc++.h>
//#define int long long
#define For(i,x) for(int i=1;i<=x;i++)//压行小妙招（
using namespace std;
int m[15][15];//存数独
bool h[15][15],l[15][15],g[15][15];//行、列、宫，第一维序号，第二维数字
char c;
int G(int x,int y){return (((x-1)/3)*3+((y+2)/3));}//得到坐标所在的宫
void t(int x,int y,int num)//打上标记
{
    h[x][num]^=1;l[y][num]^=1;
    g[G(x,y)][num]^=1;
}
bool f(int x,int y,int num){return (h[x][num]|l[y][num]|g[G(x,y)][num]);}//判断标记
void prinf()//输出（不要在意这奇怪的函数名
{
    For(i,9)
    {
        For(j,9)
        {
            if(!m[i][j])cout<<'.';
            else cout<<m[i][j];
        }cout<<"\n";
    }
}
signed main()
{
    //freopen("xxx.txt","r",stdin);
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    For(i,9)For(j,9)//读入
    {
        cin>>c;
        if(c!='.')
        {
            if(f(i,j,c-'0')){cout<<"ERROR";return 0;}
            t(i,j,c-'0');m[i][j]=c-'0';
        }
    }
    int r,px,py;
    For(T,81)For(n,9)//81：遍历次数，9：枚举数字
    {
        For(i,3)For(j,3)//枚举每一宫
        {
            r=0;if(g[i*3+j-3][n])continue;//宫内已填好该数字
            For(I,3)For(J,3)//枚举宫内每一格
            {
                if(f(i*3+I-3,j*3+J-3,n)||m[i*3+I-3][j*3+J-3])r++;//行列中有该数或已填过其他数
                else px=i*3+I-3,py=j*3+J-3;//记录位置
            }
            if(r==9){cout<<"ERROR";return 0;}//一宫内无有效格子
            if(r==8)//一宫内有唯一有效格子，填数
            {
                m[px][py]=n;
                t(px,py,n);
            }
        }
    }
    prinf();//输出
    return 0;
}
```

---

## 作者：DerrickLo (赞：1)

显然我们可以暴力枚举每个九宫格，判断对于在 $1$ 到 $9$ 中的所有数字，如果未在这个九宫格填出，是否可以确定位置，我们每次都执行一次这样子的操作，然后进行多几次就能求出正确的答案。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int flag=1;
char a[15][15];
signed main(){
	for(int i=1;i<=9;i++)cin>>(a[i]+1);
	for(int T=1;T<=1000;T++){
		for(int i=1;i<=9;i++){
			int sx=((i-1)/3)*3+1,sy=((i-1)%3)*3+1;
			int tx=sx+2,ty=sy+2;
			for(int pl=1;pl<=9;pl++){
				int ff=0,cnt=0,ansx,ansy;
				for(int ii=sx;ii<=tx;ii++)for(int jj=sy;jj<=ty;jj++){
					if(a[ii][jj]==pl+'0'){
						ff=1;
						break;
					}
					if(a[ii][jj]!='.')continue;
					int nowflag=1;
					for(int now=1;now<=9;now++)if(a[ii][now]==pl+'0'){
						nowflag=0;
						break;
					}
					for(int now=1;now<=9;now++)if(a[now][jj]==pl+'0'){
						nowflag=0;
						break;
					}
					for(int nowx=sx;nowx<=tx;nowx++)for(int nowy=sy;nowy<=ty;nowy++)if(a[nowx][nowy]==pl+'0'){
						nowflag=0;
						break;
					}
					if(nowflag){
						cnt++;	
						ansx=ii,ansy=jj;
					}
				}
				if(cnt==0&&!ff){
					//cout<<i<<' '<<pl<<"\n";
					flag=0;
					break;
				}
				else if(cnt==1){
					a[ansx][ansy]=pl+'0';
				}
			}
		}
	}
	if(!flag)cout<<"ERROR",exit(0);
	for(int i=1;i<=9;i++){
		for(int j=1;j<=9;j++)cout<<a[i][j];
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：cosf (赞：1)

## [P6410](https://www.luogu.com.cn/problem/P6410)

可以发现，这题就是一个弱化过的数独板子。

## 思路

我们可以循环 $k$ 次。每一次对于每一个数字，考虑对应的宫格里有没有唯一适合的格子，有就填上。如果没有适合的格子，就直接输出 `Error`。

容易证明，$k$ 取 $81$ 就足够了。

具体实现，可以使用一些优化，如用数组 $row[i][x], col[i][x], grid[i][x]$ 表示第 $i$ 行、列或宫有没有存在过 $x$ 这个数。这样可以使代码量和时间复杂度降到很低。

如果把数独长宽当作 $n$ 的话，时间复杂度也就是 $O(n^5)$，~~显然可以搞多测~~。

## 代码

```cpp
#include <iostream>
using namespace std;

#define MAXN 12

int col[MAXN][MAXN];
int row[MAXN][MAXN];
int gid[MAXN][MAXN];
int mp[MAXN][MAXN];

int ggd(int x, int y) // (x, y) 所在宫编号
{
	return (x - 1) / 3 * 3 + (y - 1) / 3 + 1;
}

int ggl(int x) // x 宫的左端点
{
	return (x - 1) % 3 * 3 + 1;
}

int ggr(int x) // x 宫的上端点
{
	return (x - 1) / 3 * 3 + 1;
}

int main()
{
	for (int i = 1; i < 10; i++)
	{
		for (int j = 1; j < 10; j++)
		{
			char ch;
			cin >> ch;
			if (ch != '.')
			{
				ch -= '0';
				row[i][ch] = 1;
				row[i][0]++;
				col[j][ch] = 1;
				col[i][0]++;
				gid[ggd(i, j)][ch] = 1;
				mp[i][j] = ch;
			}
		}
	}
	for (int k = 1; k < 82; k++)
	{
		int s = 0; // 这轮是否有可以填的
		for (int i = 1; i < 10; i++)
		{
			for (int j = 1; j < 10; j++)
			{
				if (gid[j][i])
				{
					continue;
				}
				int sx = 0, sy = 0, c = 0; // c 表示可能的格子数
				int lx = ggr(j);
				int ly = ggl(j);
				for (int l = 0; l < 3; l++)
				{
					for (int m = 0; m < 3; m++)
					{
						int dx = lx + l;
						int dy = ly + m;
						if (row[dx][i] || col[dy][i] || mp[dx][dy])
						{
							continue;
						}
						// ok
						c++;
						sx = dx, sy = dy;
					}
				}
				if (c == 0)
				{
					cout << "ERROR" << endl;
					return 0;
				}
				if (c == 1)
				{
					row[sx][i] = 1;
					row[sx][0]++;
					col[sy][i] = 1;
					col[sy][0]++;
					gid[j][i] = 1;
					mp[sx][sy] = i;
					s = 1;
				}
			}
		}
		if (s == 0) // 没必要继续了
		{
			break;
		}
	}
	for (int i = 1; i < 10; i++)
	{
		for (int j = 1; j < 10; j++)
		{
			if (mp[i][j])
			{
				cout << mp[i][j];
			}
			else
			{
				cout << '.';
			}
		}
		cout << endl;
	}
}
```


---

## 作者：封禁用户 (赞：1)

关于考试时的第一题模拟我写了 $300$ 行的这件事必须记录一下。    

**极为适合需求思路的人，~~因为代码太长不可读~~**。

### 题目大意   

给你一个未完成的数独，你需要判断它是否合法，若合法输出**只**使用交叉引线的方法填充的矩阵。    

### 开始模拟   

首先模拟讲究的是详尽(不然你试试会不会被卡)。    

#### part1：输入的判断      

首先，如果这个数独出现了不合法字符肯定直接 $ \texttt{ERROR}$ 。    

其次，检查每个宫格是否不合法，每行每列是否不合法。     

#### part2：循环填数时的判断    

在尝试往矩阵里填数时也会遇到不合法的情况，比如这样：    

```txt
xx1......
xxx.4....
xxx....4.
.........
.4.......
.........
.........
.........
4........
```   

引线的覆盖加上数字的占用导致标记的宫格不可能填数填数，这种就是不合法的。    

#### part3：填数怎么办    

我们先来想一想我们自己做是怎么填的：把引线覆盖的地方 “ 标记 ” 占用，如果这个宫格有且仅有一个空位证明可以填了。    

不断重复这个过程直到每个数每个宫格都填不了了就结束。    

**我们只需要把思路变成代码就行了**     

用一个标记数组来表示处理到某个数字时对于这个矩阵的引线标记，每填入一个数字处理一次。    

处理方法就是遍利这一行进行标记，再遍利这一列进行标记。   

不断循环，直到有一次没有填入任何一个数字证明结束。   

对于每次循环，枚举每个数字在每个宫格是否能填入，同时还要判断 $\texttt{ERROR}$ 。   

**结束了**，实际上代码长的原因是因为枚举每一个宫格都写了一次循环，多点冗余了，可以先写一个再依次复制也还好。   

### AC code   

```cpp
#include<bits/stdc++.h>
using namespace std;
char mp[10][10]; bool vis[10][10][10];bool f[10];
void cheak1(){
	memset(f,0,sizeof(f));
	for (register int i=1;i<=3;i++)
		for (register int j=1;j<=3;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=4;i<=6;i++)
		for (register int j=1;j<=3;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=7;i<=9;i++)
		for (register int j=1;j<=3;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=1;i<=3;i++)
		for (register int j=4;j<=6;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=4;i<=6;i++)
		for (register int j=4;j<=6;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=7;i<=9;i++)
		for (register int j=4;j<=6;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=1;i<=3;i++)
		for (register int j=7;j<=9;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=4;i<=6;i++)
		for (register int j=7;j<=9;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	memset(f,0,sizeof(f));
	for (register int i=7;i<=9;i++)
		for (register int j=7;j<=9;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
}
void cheak2(){
	for (register int i=1;i<=9;i++){
		memset(f,0,sizeof(f));
		for (register int j=1;j<=9;j++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	} for (register int j=1;j<=9;j++){
		memset(f,0,sizeof(f));
		for (register int i=1;i<=9;i++)
			if (mp[i][j]=='.') continue;
			else if (!f[mp[i][j]-'0'])
				f[mp[i][j]-'0']=1;
			else{
				printf("ERROR");
				exit(0);
			}
	}
}
int main(){
	for (register int i=1;i<=9;i++)
		scanf("%s",mp[i]+1);
	for (register int i=1;i<=9;i++)
		for (register int j=1;j<=9;j++)
			if (mp[i][j]>='1'&&mp[i][j]<='9'){
				for (register int k=1;k<=9;k++)
					vis[k][j][mp[i][j]-'0']=1;
				for (register int k=1;k<=9;k++)
					vis[i][k][mp[i][j]-'0']=1;
			} else if (mp[i][j]!='.'){
				printf("ERROR");
				return 0;
			}
	cheak1();//判断宫格是否重复 
	cheak2();//判断行列是否重复 
	while (1){//不断循环 
		int pf=1;//标记，如果填了一轮都没有新的就结束 
		for (register int who=1;who<=9;who++){
			int f=0,ii,jj,ff=0;
			//对于每个宫格进行判断 
			for (register int i=1;i<=3;i++){
				for (register int j=1;j<=3;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					//宫格有这个数了跳出 
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					//找到一个可填的 
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
					//又找到了一个，这个宫格不能填 
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			//不合法 
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			//填入并更新vis数组 
			
			f=0,ii,jj,ff=0;
			for (register int i=4;i<=6;i++){
				for (register int j=1;j<=3;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			
			f=0,ii,jj,ff=0;
			for (register int i=7;i<=9;i++){
				for (register int j=1;j<=3;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			
			f=0,ii,jj,ff=0;
			for (register int i=1;i<=3;i++){
				for (register int j=4;j<=6;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			
			f=0,ii,jj,ff=0;
			for (register int i=4;i<=6;i++){
				for (register int j=4;j<=6;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			
			f=0,ii,jj,ff=0;
			for (register int i=7;i<=9;i++){
				for (register int j=4;j<=6;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			
			f=0,ii,jj,ff=0;
			for (register int i=1;i<=3;i++){
				for (register int j=7;j<=9;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			
			f=0,ii,jj,ff=0;
			for (register int i=4;i<=6;i++){
				for (register int j=7;j<=9;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
			
			f=0,ii,jj,ff=0;
			for (register int i=7;i<=9;i++){
				for (register int j=7;j<=9;j++){
					if (mp[i][j]-'0'==who){ ff=1; break; }
					if (!vis[i][j][who]&&mp[i][j]=='.'&&!f)
						f=1,ii=i,jj=j;
					else if (!vis[i][j][who]&&mp[i][j]=='.'&&(f==1))
						{ f=2; break; }
				}
				if (ff) break;
				if (f==2) break;
			}
			if (!f&&!ff){ printf("ERROR"); return 0; }
			if (f==1&&!ff){
				mp[ii][jj]=who+'0'; pf=0;
				for (register int k=1;k<=9;k++)
					vis[k][jj][who]=1;
				for (register int k=1;k<=9;k++)
					vis[ii][k][who]=1;
			}
		}
		if (pf) break;
	}
	//输出 
	for (register int i=1;i<=9;i++){
		for (register int j=1;j<=9;j++)
			putchar(mp[i][j]);
		puts("");
	}
	return 0;
}
```   

建议复制到 $\texttt{c++}$ 里把代码缩起来再看，有注释。

---

## 作者：Ludo (赞：1)

这题看起来很麻烦，可是写起来好像比较简单（吗？）。

官方代码中变量命名不是英文，看不懂在写什么。。。

还是自己写了一下。

### I. 题意

首先判定数独是否合法。

合法便需要反复使用交叉影线法，推导出格子的值。

### II. 实现合法性判断

**模拟。**

首先判断行、列、宫是否有重复的。

(1) 用三个二维数组分别记录**某个数字**在**某项目**（每行、每列、每宫）有没有出现过。

(2) 遇到数字，把对应三个项目作注记。若在此前已有注记，说明这数独不合法。

然后判断是否每一个宫都能填入数字`1-9`。

如果发现某数字在某宫中只有一个位置能填入，那么马上填入。

如果只有这里没写对，会得到奇妙的97 pts。

流程是这样的...

那么对于每个数字进行检查，如果一个宫没有合法位置再填入这个数字（当然，这个宫本身没有这个数字的话），那就是不合法的。

如果只有一种可能的位置，那么就马上填入。

这部分时间复杂度是$9\times9\times9$，也就是$O(1)$的。

### III. 实现交叉影线法

如果像我那么懵懂的话，可能不知道要运用多少次才行，那么订一个大点的数，例如$500$，便十分的足够了。

每一次交叉影线法，我们对于每一个数字...

1. 先开一个新的数组，用于剔除不合法位置。

2. 剔除不合法位置，在新开的二维数组把这些位置标上状态不合法。

3. 最后查看每一个宫，如果合法位置唯一，那么填入。

感觉讲得不太好，可以看看代码。

此部分时间复杂度是$500\times9\times9\times9\times9\times9$，也是$O(1)$的。

### IV. 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int line[11][11],column[11][11],gg[11][11];
char str[21];
int mat[11][11];
int get_gg(int i,int j)
{
	int x=(i-1)/3+1;
	int y=(j-1)/3+1;
	return (x-1)*3+y;
}
int mat2[11][11];
int begingg[11],endgg[11];
int main()
{
	int flag=0;
	for (int i=1;i<=9;i++)
	{
		scanf("%s",str+1);
		for (int j=1;j<=9;j++)
		{
			if (str[j]!='.')
			{
				mat[i][j]=str[j]-48;
				if (line[i][mat[i][j]]) flag=1;
				else line[i][mat[i][j]]=1;
				if (column[j][mat[i][j]]) flag=2;
				else column[j][mat[i][j]]=1;
				if (gg[get_gg(i,j)][mat[i][j]]) flag=3;
				else gg[get_gg(i,j)][mat[i][j]]=1;
			}
		}
	}
	if (flag)
	{
		printf("ERROR");
		return 0;
	}
	begingg[1]=1;begingg[2]=4;begingg[3]=7;
	endgg[1]=3;endgg[2]=6;endgg[3]=9;
	for (int i=1;i<=9;i++) //check every number
	{
		for (int indggx=1;indggx<=3;indggx++) //check every 3*3 block
		{
			for (int indggy=1;indggy<=3;indggy++)
			{
				if (gg[(indggx-1)*3+indggy][i]==1) continue;
				int tmpflag=0;
				for (int indline=begingg[indggx];indline<=endgg[indggx];indline++) //we want each 3*3 block has this number, or keep a possible position for this number
				{
					for (int indcolumn=begingg[indggy];indcolumn<=endgg[indggy];indcolumn++)
					{
						if (line[indline][i]||column[indcolumn][i]||gg[get_gg(indline,indcolumn)][i]||mat[indline][indcolumn]) continue;
						tmpflag++; //if this place is possible, it shows that this block is likely to be following the rules
					}
				}
				if (!tmpflag) {flag=true;}
				if (tmpflag==1)
				{
					for (int indline=begingg[indggx];indline<=endgg[indggx];indline++) //we want each 3*3 block has this number, or keep a possible position for this number
					{
						for (int indcolumn=begingg[indggy];indcolumn<=endgg[indggy];indcolumn++)
						{
							if (line[indline][i]||column[indcolumn][i]||gg[get_gg(indline,indcolumn)][i]||mat[indline][indcolumn]) continue;
							line[indline][i]=1;
							column[indcolumn][i]=1;
							gg[get_gg(indline,indcolumn)][i]=1;
							mat[indline][indcolumn]=i;
						}
					}
				}
			}
			
		}
	}
	if (flag)
	{
		printf("ERROR");
		return 0;
	}
	for (int tt=1;tt<=500;tt++) //number of using this method -- 500
	{
		for (int en=1;en<=9;en++) //for each number
		{
			for (int i=1;i<=9;i++) //clear data
			{
				for (int j=1;j<=9;j++) mat2[i][j]=0;
			}
			for (int inx=1;inx<=9;inx++) //cancel impossible unit
			{
				for (int iny=1;iny<=9;iny++)
				{
					if (mat[inx][iny]==en)
					{
						for (int i=1;i<=9;i++) //mark down impossible unit
						{
							mat2[inx][i]=1;
							mat2[i][iny]=1;
						}
						for (int i=begingg[(inx-1)/3+1];i<=endgg[(inx-1)/3+1];i++)
						{
							for (int j=begingg[(iny-1)/3+1];j<=endgg[(iny-1)/3+1];j++)
							{
								mat2[i][j]=1;
							}
						}
					}
					if (mat[inx][iny])
					{
						mat2[inx][iny]=1;
					}
				}
			}
			for (int i=1;i<=3;i++) //we check through every 3*3 block to find out which place can be filled in
			{
				for (int j=1;j<=3;j++)
				{
					
					if (gg[(i-1)*3+j][en]) continue;
					for (int indline=begingg[i];indline<=endgg[i];indline++)
					{
						for (int indcolumn=begingg[j];indcolumn<=endgg[j];indcolumn++)
						{

							if (mat2[indline][indcolumn]==0)
							{
								flag++;
							}
						}
					}
					if (flag==1)
					{
						for (int indline=begingg[i];indline<=endgg[i];indline++)
						{
							for (int indcolumn=begingg[j];indcolumn<=endgg[j];indcolumn++)
							{
								if (mat2[indline][indcolumn]==0)
								{
									mat[indline][indcolumn]=en;gg[get_gg(indline,indcolumn)][en]=1;
								}
							}
						}
					}
				}
			}
		}
	}
	for (int i=1;i<=9;i++)
	{
		for (int j=1;j<=9;j++)
		{
			if (mat[i][j])
			{
				printf("%d",mat[i][j]);
			}
			else printf(".");
		}
		printf("\n");
	}
}
```


---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6410)

[更好的阅读体验](https://www.luogu.com.cn/article/8dse1xyj)

### 前言：
就这种 [ 数据删除 ] 的大模拟，写了我近两小时，一百七十行，建议升绿。 

## 实现:

本题作为大模拟，自然不需要算法，难点在于实现，现在就来讲每个部分的实现：

### 输入与初始化：

每一个九宫格的范围可以进行初始化，每一个数分别在哪个位置也可以在输入时就处理好：

九宫格范围：


```cpp
struct node2{
	pair<int,int>f1;
	pair<int,int>f2;
}db[15];//每个九宫格的范围 
```

```cpp
	db[1].f1=make_pair(1,1);
	db[1].f2=make_pair(3,3);
	db[2].f1=make_pair(1,4);
	db[2].f2=make_pair(3,6);
	db[3].f1=make_pair(1,7);
	db[3].f2=make_pair(3,9);
	
	db[4].f1=make_pair(4,1);
	db[4].f2=make_pair(6,3);
	db[5].f1=make_pair(4,4);
	db[5].f2=make_pair(6,6);
	db[6].f1=make_pair(4,7);
	db[6].f2=make_pair(6,9);
	
	db[7].f1=make_pair(7,1);
	db[7].f2=make_pair(9,3);
	db[8].f1=make_pair(7,4);
	db[8].f2=make_pair(9,6);
	db[9].f1=make_pair(7,7);
	db[9].f2=make_pair(9,9);

    //每个九宫格的范围
```

输入与每个数的位置：


```cpp
struct node1{
	vector<pair<int,int> >q;
}ls[100005];//每个数的位置
int da[15][15];//记录答案 
```


```cpp
for(int i=1;i<=9;i++){
		for(int j=1;j<=9;j++){
			char c;
			cin>>c;
			if(c=='.') a[i][j]=0;
			else a[i][j]=c-'0'; 
			da[i][j]=a[i][j];//答案数组初始与输入进来的数独一样 
		}
	} //输入 
```

```cpp
void first_round(){
	for(int i=1;i<=9;i++){
		for(int j=1;j<=9;j++){
			if(a[i][j]!=0){
				ls[a[i][j]].q.push_back(make_pair(i,j));//每个数的位置 
			}
		}
	}
} 

```


### 输入无效的判断：

对于每一个数依次进行映射，如果在同一行或同一列或同一九宫格中还有同一个数的映射，则输入不合法。

放出代码方便理解:


```cpp
bool check_h(int n){
	bool c[11];
	for(int i=1;i<=9;i++) c[i]=false;
	for(int i=1;i<=9;i++){
		if(a[n][i]==0) continue;
		if(c[a[n][i]]==true) {return false;}
		else c[a[n][i]]=true;
	}
	return true;
}//对这一行的映射是否合法

bool check_l(int n){
	bool c[11];
	for(int i=1;i<=9;i++) c[i]=false;
	for(int i=1;i<=9;i++){
		if(a[i][n]==0) continue;
		if(c[a[i][n]]==true) return false;
		else c[a[i][n]]=true;
	}
	return true;
}//对这一列的映射是否合法

bool check_f(int n){
	for(int i=1;i<=9;i++){
		bool c[11];
		for(int j=1;j<=9;j++) c[j]=false;
		for(int j=db[i].f1.first;j<=db[i].f2.first;j++){
			for(int k=db[i].f1.second;k<=db[i].f2.second;k++){
				if(a[j][k]==0) continue;
	        	if(c[a[j][k]]==true) return false;
	        	else c[a[j][k]]=true;
			}
		}
	}
	return true;
}//对这一个九宫格的映射是否合法

bool checker(){
	for(int i=1;i<=9;i++){
		if(check_h(i)==false){return false;} 
		if(check_l(i)==false) {return false;} 
		if(check_f(i)==false) {return false;} 
	}
	return true;
}//行列九宫格全部合法才合法，不然就不合法输出ERROR
```

### 交叉阴影线做数独与判断有九宫格中有一数字无法填写：

交叉阴影线在每一轮都对一到九之间的每一个数进行映射操作，之后判断每一个九宫格，如果这个九宫格中可以被放入这个数的位置只剩下一个且这个九宫格中没有该数字时，进行填写，把新填写的数压入上文的 $ls$ 中并更新答案数组，**更新完直接退出进行下一轮**。

当九个数字都无法填入任何一个格子时，结束并输出答案。

对于判断九宫格中是否有一数字无法被填入，在每次映射后，如果这个九宫格中不存在这个数且所有空位置都被映射到时，成立，输出 ```ERROR```。


## 完整代码：

比较长，放在[云剪贴板](https://www.luogu.com.cn/paste/anzvlx7q)了。

---


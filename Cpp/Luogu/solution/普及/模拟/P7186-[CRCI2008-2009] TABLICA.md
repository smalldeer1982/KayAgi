# [CRCI2008-2009] TABLICA

## 题目描述

小 Q 有一张 $N \times N$ 的表格。若 $N = 4$，那么他将 $1$ 填入第一列第一行，$2$ 填入第二列第一行，$\cdots$，$5$ 填入第一列第二行，$\cdots$，$15$ 填入第三列第四行，$16$ 填入第四列第四行。

现在，小 Q 对该表格作如下操作：
1. 移动行：向右移动一行中的所有单元格，以使最后一列中的数字移到第一列。

2. 移动列：向下移动一列中的所有单元格，以使最后一行中的数字移到第一行。

小 Q 想把一个数字 $X$ 移到单元格 $(R,C)$，于是进行如下操作：

- 当 $X$ 不在第 $C$ 列时，移动它所在的行。
- 当 $X$ 不在第 $R$ 行时，移动它所在的列。

下面是一个如何将数字 $6$ 移动到单元格 $(3, 4)$ 的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/6pu31i7e.png)

小 Q 想移动 $K$ 个数字，问至少要进行多少次操作。

## 说明/提示

#### 数据规模及约定

对于 $100\%$ 的数据：$2 \le N \le 10^4$，$1 \le K \le 10^3$，$1 \le X \le N^2$，$1\le R,C \le N$。

#### 说明
- 本题满分 $100$ 分。
- 本题译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CRCI2008-2009](https://hsin.hr/coci/archive/2008_2009/regional_tasks.pdf) TABLICA，译者 @[tearing](https://www.luogu.com.cn/user/219791)。

## 样例 #1

### 输入

```
4 1
6 3 4
```

### 输出

```
3```

## 样例 #2

### 输入

```
4 2
6 3 4
6 2 2 
```

### 输出

```
3
5```

## 样例 #3

### 输入

```
5 3
1 2 2
2 2 2
12 5 5
```

### 输出

```
2
5
3```

# 题解

## 作者：Drifty (赞：10)



- 一看到这题，第一反应肯定是暴力枚举。把每一个点都记录在数组里，一个一个模拟。移动时间复杂度为$O(kn)$，找到下一个点的时间复杂度 $O(1)$，完美过掉。

如果你是这么想的，恭喜你 MLE 了 (bushi

本题的空间复杂度为 $\color{red}O(n^2)$ ，又注意到空间仅有 `32MB` ，显然是过不了的。

那我们再进一步思考：

- 只记录行和列，然后通过计算来完成变换，移动时间复杂度为$O(kn)$

**但是！！！！**

它找到下一个点时间复杂度是 $O(kn^2)$……（悲

**那，怎么办？**


仔细想一想，在之前的过程中，我们都将思维局限于在线算法，我们不妨尝试一下离线算法。

- 不知道读者有没有发现，在优化的过程中我们记录的东西是越来越少的，我们可以直接尝试只记录要修改的点的位置。这是你就会发现其他的点根本用不着，只需要处理要修改的点之间的影响即可

时间复杂度 $O(k^2)$，空间复杂度 $O(k)$，非常优雅的过掉了这道题

- 这题想通了其实非常简单，但是在代码细节上需要多多注意

### 最后奉上 `AC` 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
pair<int,int>a[1005];
int n,k,x,r[1005],c[1005];
int main()
{
    return 0;//防止抄题解
    ios::sync_with_stdio(false);
    cin.tie(NULL),cout.tie(NULL); //输入优化
    cin>>n>>k;
    for(int i=1;i<=k;i++)
    {
        cin>>x>>r[i]>>c[i];
        if(x%n)a[i]={x/n+1,x%n};
        else a[i]={x/n,n};
    }
    #define x first
    #define y second //打起来方便
    for(int i=1;i<=k;i++)
    {
        int m=((c[i]<a[i].y)?(n-a[i].y+c[i]):(c[i]-a[i].y));
        for(int j=i+1;j<=k;j++)
            if(a[i].x==a[j].x)
            {
                a[j].y=a[j].y+m;
                a[j].y-=(a[j].y>n)*n;
            }
        int s=((r[i]<a[i].x)?(n-a[i].x+r[i]):(r[i]-a[i].x));
        for(int j=i+1;j<=k;j++)
            if(c[i]==a[j].y)
            {
                a[j].x=a[j].x+s;
                a[j].x-=(a[j].x>n)*n;
            }
        cout<<m+s<<'\n';
    }
    return 0;
}
```
蒟蒻第一篇题解，求过 qwq


---

## 作者：yinlu_offical (赞：7)

# P7186 [CRCI2008-2009] TABLICA 题解

### [【题目传送门】](https://www.luogu.com.cn/problem/P7186)

## 题目难点与解法

本题最大的难点就是如何把握空间。__内存限制 32MB 啊！__

如果用传统方法开二维数组的话 $O(n^2)$ 直接炸了，所以我们得换种思路。

__那如何优化捏？（接下来是重点）__
> 其实仔细观察我们就能发现，并不是所有格子都用得上，只有给出点的一行和一列需要移动。
> 所以说，我们只用开两个数组 r 和 c，用于存储该点要去的行列下标并移动该点行和列上所有点的值，再开一个数组 p 记录移动完了的点的行列下标（因为有可能这个点的移动会影响到剩下需要移动的点的位置）就行了。

（喘两口气）

空间 $O(3k)$，时间 $O(k^2)$。

剩下的就不多说了，代码里写的很详细喵。

## 接下来上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,k,xx,r[1005],c[1005];
// xx:为了不与Point中的x混淆

struct Point
{
	int x,y;
}p[1005]; // 记录每个需要移动的点当前的行列下标

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++)
	{
		scanf("%d%d%d",&xx,&r[i],&c[i]);
		p[i].x=xx%n==0 ? xx/n : xx/n+1;
		p[i].y=xx%n==0 ? n : xx%n;
		// 行列下标赋值，很好理解
	}
	printf("520"); // 防抄题解
	for(int i=1;i<=k;i++)
	{
		int tr=(r[i]-p[i].x+n)%n;
		int tc=(c[i]-p[i].y+n)%n;
		// tr和tc:需要移动的行列数量
		// 自己用“在6*6中从6移到4”试一下就知道为什么要+n%n了
		
		// 接下来遍历在p[i]这个点移动之后继续要移动的点是否要跟着p[i]一起移动（好绕啊）
		for(int j=i+1;j<=k;j++) // 先遍历列
			if(p[i].x==p[j].x)
			  p[j].y=(p[j].y+tc)%n==0 ? n : (p[j].y+tc)%n; // %n是为了防止移到n外面去了
		p[i].y=(p[i].y+tc)%n==0 ? n : (p[i].y+tc)%n; // 自己得动
		
		for(int j=i+1;j<=k;j++) // 再遍历行
			if(p[i].y==p[j].y) // 要动
			  p[j].x=(p[j].x+tr)%n==0 ? n : (p[j].x+tr)%n;
		p[i].x=(p[i].x+tr)%n==0 ? n : (p[i].x+tr)%n; // 自己得动
		
		printf("%d\n",tr+tc);
	}
	return 0;
}
```

看到这里觉得有帮助的哥哥姐姐们请点个赞再走喵~

---

## 作者：irris (赞：5)

### Preface

~~好久之前的~~随机跳题跳到这道题。现在都没有题解那我就来水一发。

### Problem

给出一个 $N\times N$ 的，标号初始为有规律 $1\dots N\times N$ 的网格，有 $K$ 个关键点与其对应的位置，对于每个关键点，依次把该行向右循环平移知道与对应位置行坐标相等；接着把该行向右循环平移知道与对应位置行坐标相等，求对于每个关键点总共需要的平移次数，询问之间相互影响。

$2 \leq N \leq 10^4, 1 \leq K \leq 10^3$。

### Solution

+ 套路题。
+ 我们先考虑暴力模拟这个过程。诶你会发现这个操作可以直接暴力做到 $\mathcal O(KN^2)$，小小优化一下可以 $\mathcal O(KN)$。
+ 但是瓶颈在于每次操作之后找到下一个被操作的点是 $\mathcal O(KN^2)$ 的，怎么优化都没用。
+ 那么我们考虑直接存每个关键点的位置。这样你就会发现其它的点都是冗余信息了，每次循环平移只尝试改变关键点的位置即可。
+ 总时间复杂度 $\mathcal O(K^2)$。

代码（无缺省源）：

```cpp
#define MAXK 1001
struct Number {
	int x, y;
	Number () {}
	Number (int X, int Y) : x(X), y(Y) {}
} nums[MAXK];

int x[MAXK], r[MAXK], c[MAXK];
int main() {
	int N = read<int>(), K = read<int>();
	for (int i = 1; i <= K; ++i) {
		x[i] = read<int>(), r[i] = read<int>(), c[i] = read<int>();
		nums[i] = Number(x[i] % N != 0 ? x[i] % N : N, (x[i] - 1) / N + 1);
	}
	for (int i = 1; i <= K; ++i) {
// shift column →
		int col = nums[i].x;
		if (c[i] >= col) col = c[i] - col;
		else col = N - (col - c[i]);
		for (int j = 1; j <= K; ++j) if (nums[i].y == nums[j].y) {
			nums[j].x += col; if (nums[j].x > N) nums[j].x -= N;
		}
// shift row ↓
		int row = nums[i].y;
		if (r[i] >= row) row = r[i] - row;
		else row = N - (row - r[i]);
		for (int j = 1; j <= K; ++j) if (nums[i].x == nums[j].x) {
			nums[j].y += row; if (nums[j].y > N) nums[j].y -= N;
		}
		print<int>(col + row, '\n');
// for (int i = 1; i <= K; ++i) printf("(%d %d)", nums[i].y, nums[i].x);
// puts("");
	}
	return 0;
}
```

---

## 作者：DemonPlayer (赞：4)

## 思路:      
  #### STEP1 确认做法
  考虑暴力做法，一行一行，一列一列的移，空间复杂度$\mathcal O(n^{2})$暴力显然空间超界。你有没有注意到，有一些数是没用的，我们不妨先将要处理的数存起来。在移动时，只需要移动要处理的数就可以了，空间复杂度为$\mathcal O(n)$，可以通过。
  #### STEP2 确认 $X$ 的位置   
  试着找规律     
  $$
  \begin{bmatrix} 1 & 2 & 3\\ 4 & 5 & 6\\ 7 & 8 & 9 \end{bmatrix}
  $$
  当 $X=3$，他所在的行为 $1$，列为 $3$，   
  当 $X=7$，他所在的行为 $3$，列为 $1$，   
  容易看出，$X$ 所在的行为 $(X-1)÷n+1$
  但想知道 $X$ 所在的行，我们应该将矩阵放大。       
  $$
  \begin{bmatrix} 1 & 2 & 3 & 4 & 5\\ 6 & 7 & 8 & 9 & 10 \\ 11  & 12 & 13 & 14 &15 \\ 16  & 17 & 18 & 19 &20 \\ 21  & 22 & 23 & 24 &25\end{bmatrix}
  $$
  仔细观察，你一定发现了：$X$ 所在的列为 $(X-1)\mod n+1$。

  #### STEP3 更新列    
  一步一步模拟移动即可。
  ```cpp
   int colu=a[i].y;//列
		// 处理列 
		colu=(c[i]>=colu)?c[i]-colu:n-(colu-c[i]);
		// 计算最少移动次数 
		for(int j=1;j<=k;j++){
			// 更新位置 
			if(a[i].x==a[j].x){
				a[j].y+=colu;
				if(a[j].y>n){
					a[j].y-=n;
				}
			}
		}
```
  #### STEP4 更新行
  一步一步模拟移动即可。
  ```cpp
   int line=a[i].x;//行
		//处理行
		line=(r[i]>=line)?r[i]-line:n-(line-r[i]);
		//计算最少移动次数
		for(int j=1;j<=k;j++){
			//更新位置 
			if(a[i].y==a[j].y){
				a[j].x+=line;
				if(a[j].x>n){
					a[j].x-=n;
				}
			}
		}
  ```
  #### STEP5 输出!
  将更新行的步数与更新列的步数的和输出即可。  
~~累死我了~~

---

## 作者：shiyuting123 (赞：2)

# 题解 [P7186 [CRCI2008-2009] TABLICA](https://www.luogu.com.cn/problem/P7186)
## 题意
题目已经阐述的很清楚了，我就不展开了
## 想法
一看到题目，肯定首先想到的是纯枚举，但是！！（~~题目很坑~~）内存限制是 ```32MB``` ，而空间复杂度是 $O(n^2)$ ，所以 ```MLE``` 了。

那怎么办？我们可以记录下每次整行移动多少位、每次整列移动多少位，再枚举一遍记录下的操作，就能算出 $X$ 当前的坐标了。

余下看代码。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct item{
	bool f;
	int id,cnt;
}a[2100];//定义结构体方便记录操作
int len;
int n,m;
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int x,r,c;
		cin>>x>>r>>c;
		int xx=(x+n-1)/n;
		int yy=(x-1)%n+1;//算出没操作前x的坐标
		for(int j=1;j<=len;j++){
			if(!a[j].f){
				if(a[j].id==xx){
					yy+=a[j].cnt;
					yy=!(yy%n)?n:yy%n;
				}
			}
			else{
				if(a[j].id==yy){
					xx+=a[j].cnt;
					xx=!(xx%n)?n:xx%n;
				}
			}
		}//这个for循环模拟操作的每一步
		a[++len].f=false;
		a[len].id=xx;
		a[len].cnt=(c-yy+n)%n;
		a[++len].f=true;
		a[len].id=c;//之前的yy被修改了
		a[len].cnt=(r-xx+n)%n;//记录下当前操作
		cout<<a[len].cnt+a[len-1].cnt<<endl;
	}
	return 0;//完结
}
```
提一嘴（这是本蒟蒻第一次发题解），求过。

---

## 作者：EasonLIkeMath (赞：0)

# 思路
纯模拟空间复杂度过不了，因为空间限制为 $32 \texttt{MB} $，而纯模拟空间复杂度为 $O(n^2)$，$n \le 10^4$，所需空间为 $10^4 \times 10^4 \times 4 = 4 \times 10^8 \texttt{byte} = 400 \texttt{MB} $，可以先把查询记录下来，并计算出所在的行和列，再逐一处理，每次处理计算到达目标所要的行和列，再更新后面查询的行和列，具体细节见代码和注释。

# 细节

题中说只能向右或下移动，所以如果目标在左或上，
就必须先移动到边缘，在继续走到目标，
计算公式为 `step = n - posx[i] + disx[i]`。

# 代码

```cpp
#include <iostream>
#define N 1001

using namespace std;

int num;
int qcnt;
int posx[N];  // 所在行
int posy[N];  // 所在列
int disx[N];  // 目标行
int disy[N];  // 目标列

// 更新后续询问的所在行和列
void move(int ansx, int ansy, int cur)
{
    for (int j = cur + 1; j <= qcnt; j++)
    {
        // 先移动整行，判断同行
        if (posx[j] == posx[cur])
        {
            posy[j] += ansy;    // 所在列移动
            if (posy[j] > num)  // 如果超出，到另一头
            {
                posy[j] -= num;
            }
        }
        // 再移动整列，判断同列（整行移动在这之前结束，所以要与移动后的结果比较）
        if (posy[j] == disy[cur])
        {
            posx[j] += ansx;    // 所在行移动
            if (posx[j] > num)  // 如果超出，到另一头
            {
                posx[j] -= num;
            }
        }
    }
}

int main()
{
    cin >> num >> qcnt;
    for (int i = 1; i <= qcnt; i++)
    {
        int value;  // 要移动的值
        cin >> value >> disx[i] >> disy[i];
        // 计算所在行和列（通过简单数学计算）
        posy[i] = value % num;
        if (posy[i] == 0)
        {
            posy[i] = num;
        }
        posx[i] = (value - posy[i]) / num + 1;
        // cout << posx[i] << " " << posy[i] << endl;
    }
    for (int i = 1; i <= qcnt; i++)
    {
        int ansx;  // 整行移动次数
        int ansy;  // 整列移动次数
        // 因为题目中说只能向右或下移动，所以要特判
        if (disx[i] >= posx[i])  // 在前面，直接移动过去
        {
            ansx = disx[i] - posx[i];
        } else  // 在后面，绕一圈过去
        {
            ansx = disx[i] - posx[i] + num;
        }
        if (disy[i] >= posy[i])  // 在前面，直接移动过去
        {
            ansy = disy[i] - posy[i];
        } else  // 在后面，绕一圈过去
        {
            ansy = disy[i] - posy[i] + num;
        }
        move(ansx, ansy, i);          // 更新后续询问的所在行和列
        cout << ansx + ansy << endl;  // 行和列需移动的次数总和就是答案
    }
    return 0;
}

```

---


# [COCI 2020/2021 #3] Knjige

## 题目描述

Tin 认为书籍不按顺序摆放是最讨厌的。Ante 决定帮助他。在排序的过程中，每一步可以执行下列二者操作之一：

- 若对应手上无书，则可从**堆顶**取下一本书并放在左手或右手上。
- 将一本在其手上的书放置到书架顶端。

Ante 希望你能找到一种方法，能使**左侧**书架的书能从顶部到底端依次对应从薄到厚。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/2wyrdy5q.png)

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 100$，$1 \le d_i \le 1000$，$0 \le k \le 10^5$。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

本题使用自行编写的非官方 [Special Judge](https://www.luogu.com.cn/paste/enzsg1cn)，欢迎大家 hack（可私信或直接发帖）。注意，Special Judge 对输出格式敏感，每行末尾请不要输出多余空格。

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf)  _T1 Knjige_。**

## 样例 #1

### 输入

```
3
2 3 1```

### 输出

```
8
UZMI L L
STAVI L D
UZMI L L
UZMI D L
STAVI L L
UZMI L D
STAVI L L
STAVI D L```

## 样例 #2

### 输入

```
4
1 1 2 5```

### 输出

```
0```

# 题解

## 作者：hensier (赞：4)

### 题目定位

这是一道构造题。

题目的要求是将左侧书架的书经过左侧书架、右侧书架、左手和右手的辗转，最终回到左侧书架并实现从顶到底从薄到厚（即单调递增）。

[NOIP2020 移球游戏](/problem/P7115) 与其极为相似，只不过两题区别最大的地方就是是否有个数限制。假如这道 NOIP 题没有球的限制，那么能拿到全分也不是很困难的事情。

### 思路分析

由于本题中可以借助右侧书架进行辗转，因此在分析后可以发现，进入一侧书架的书籍会按照倒序取出。例如，若把厚度为 $\{1,2,3,5\}$ 的书籍依次放入右侧书架，那么取出的顺序就是 $\{5,3,2,1\}$，但放回另一书架的顺序仍为 $\{1,2,3,5\}$。这符合先进后出的原则，也就是我们熟知的数据结构——栈。

本题以栈为数据结构基础，因此完全可以用 `stack` 或 `vector`，甚至 `deque` 等 `STL` 容器来存储书籍。这里将以 `vector` 为例。

为了解决本题，我们可以用两个 `vector` 容器 $l$ 和 $r$ 分别维护左侧和右侧书架中的书籍厚度，并在初始条件下将书籍全部存入 $l$ 中。

接下来就是思考本题的核心策略。这里所用的策略是：第 $i$ 次循环，将左侧书架的书籍中先找到第 $i$ 薄的书籍。随后把所有在该书籍上方的书籍全部放到右侧书架上。接着，将该书籍存放在右手上，再把刚才放到右侧书架上的书全部通过左手放回到左侧书架上。最后，把右手上的书籍放到右侧书架上。

该策略可以运用右侧书架和右手「中转站」的效果，先将书籍从薄到厚放到右侧，再将其依次放回。

具体地，需要执行 $n$ 次以下步骤：

- 将第 $i$ 薄的书籍上方的书全部通过左手放到右侧书架。
- 将第 $i$ 薄的书籍取下并放在右手。
- 将刚才的所有书籍全部通过左手放回左侧书架。
- 将第 $i$ 薄的书籍放到右侧书架。

最后需要将右侧书架上的书全部放回左侧。

### 样例分析

我们来分析一下上述策略对样例 $1$ 是如何操作的。

样例输入：

```plain
3
2 3 1
```

（第 $0$ 次操作）初始情况：

|左侧书架|右侧书架|左手|右手|
| :----------: | :----------: | :----------: | :----------: |
|$2$||||
|$3$||||
|$1$||||

（第 $1 \sim 4$ 次操作）将左侧书架 $1$ 上方的所有书籍取出，并放在右侧：

|左侧书架|右侧书架|左手|右手|
| :----------: | :----------: | :----------: | :----------: |
|$1$|$3$|||
||$2$|||

（第 $5$ 次操作）将 $1$ 取下放在右手（将右侧书籍放回左侧时使用左手）：

|左侧书架|右侧书架|左手|右手|
| :----------: | :----------: | :----------: | :----------: |
||$3$||$1$|
||$2$|||

（第 $6 \sim 9$ 次操作）把 $2$ 和 $3$ 用左手放回左侧：

|左侧书架|右侧书架|左手|右手|
| :----------: | :----------: | :----------: | :----------: |
|$2$|||$1$|
|$3$||||

（第 $10$ 次操作）将 $1$ 放在右侧：

|左侧书架|右侧书架|左手|右手|
| :----------: | :----------: | :----------: | :----------: |
|$2$|$1$|||
|$3$||||

（第 $11 \sim 14$ 次操作）接着，由于中间无其他书籍，将 $2$ 和 $3$ 依次放在右侧：

|左侧书架|右侧书架|左手|右手|
| :----------: | :----------: | :----------: | :----------: |
||$3$|||
||$2$|||
||$1$|||
      
（第 $15 \sim 20$ 次操作）左侧书架已空，因此可将所有书籍依次放回：

|左侧书架|右侧书架|左手|右手|
| :----------: | :----------: | :----------: | :----------: |
|$1$||||
|$2$||||
|$3$||||

### 操作次数分析

该策略的最坏情况是所有的 $n$ 本书籍从厚到薄，与题目要求的顺序恰好相反。

在最坏情况之下，对于第 $i$ 薄的书籍，各种操作所需次数为：

- 一堆放至右侧：$2(i-1)$
- 一本放至右手：$1$
- 一堆放回左侧：$2(i-1)$
- 一本放至右侧：$1$
- 总计：$\sum_{i=1}^n (4i-2)$

最后放回左侧和总计次数为 $2n$，所以总次数为：

$$\sum_{i=1}^n (4i-2)+2n=\dfrac{4n(n+1)}{2}-2n+2n=2n(n+1)$$

由于 $n \le 100$，所以总操作次数必定不超过 $20200$，而规定次数为 $100000$，可以稳过。

### 代码 1

用 `vector` 模拟书架。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,a[101];
string op[100001];
vector<int>l,r;
int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)cin>>a[i];
    for(int i=n;i;--i)l.push_back(a[i]);
    sort(a+1,a+n+1);
    for(int i=1,t;i<=n;++i)
    {
        t=0;//t 将保存需要取下书籍数目
        //将第 i 薄的书籍上方的全部移至右侧
        while(l.back()!=a[i])
        {
            op[++cnt]="UZMI L L\n";
            op[++cnt]="STAVI L D\n";
            r.push_back(l.back());
            l.pop_back();
            ++t;
        }
        //将第 i 薄的书籍暂时存放在右手
        op[++cnt]="UZMI D L\n";
        l.pop_back();
        //将刚才移动的书籍全部放回左侧书架
        while(t--)
        {
            op[++cnt]="UZMI L D\n";
            op[++cnt]="STAVI L L\n";
            l.push_back(r.back());
            r.pop_back();
        }
        //把存在右手的第 i 薄书籍放回右侧书架
        op[++cnt]="STAVI D D\n";
        r.push_back(a[i]);
    }
    //把右侧书架上剩余的书籍全部放至左侧书架顶端
    while(r.size())
    {
        op[++cnt]="UZMI L D\n";
        op[++cnt]="STAVI L L\n";
        l.push_back(r.back());
        r.pop_back();
    }
    cout<<cnt<<endl;
    for(int i=1;i<=cnt;++i)cout<<op[i];
    return 0;
}
```

### 代码 2

不使用 `vector` 来浪费太多空间。我们可用数组维护每本书籍的高度（最顶端为 $1$，最底端为 $n$）。

在对书籍厚度排序之后，每次移动之后都相应改变高度，并保存输出结果。

本代码复杂度虽与前者相当，都是 $\mathcal O(n^2)$。但前者内层循环的 $n$ 是跑不满的，而该代码是无论如何都要跑的，所以速度较慢。不过，该代码在空间略胜于前者。

```cpp
#include<bits/stdc++.h>
int n,cnt;
char ans[1000001];//保存输出结果
struct book
{
    int width,id;
    bool operator<(const book &x) const {return width<x.width;}
}a[101];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&a[i].width);//输入厚度（可以理解为宽度）
        a[i].id=i;//保存初始高度
    }
    std::sort(a+1,a+n+1);//从薄到厚进行排序
    for(int i=1;i<=n;++i)
    {
        //将上方所有书籍进行移动，strcat 可拼接字符数组
        for(int j=0;j<a[i].id-1;++j)strcat(ans,"UZMI L L\nSTAVI L D\n");
        strcat(ans,"UZMI D L\n");
        for(int j=0;j<a[i].id-1;++j)strcat(ans,"UZMI L D\nSTAVI L L\n");
        strcat(ans,"STAVI D D\n");
        cnt+=((a[i].id-1)<<2)+2;//操作次数记录
        for(int j=1;j<=n;++j)//对各本书籍的高度进行修改
        {
            if(a[j].id<=a[i].id)continue;
            --a[j].id;
        }
    }
    printf("%d\n%s",cnt+(n<<1),ans);//操作次数还需加上最后 2n 次
    while(n--)puts("UZMI L D\nSTAVI L L");//输出最后 2n 次操作
    return 0;
}
```

---

## 作者：B天选之子B (赞：1)

## 解题思路

- 题目中有一个小小的提示：

你的方案不一定与最少操作次数相同。

假如说现在已经是一个合法序列，在排一遍也是可以的。

- 我们每次只用移动一个没标记过的最大的。

移动到上一个标记的前一个。

**也就是说我们只用纯模拟就可以了。**

## 注意的事项

1. 第一点，不要学习博主把 UZMI 打成了 UZWI 。

2. 第二点，不要把这道题想复杂了，模拟就可以了。

3. 第三点，我们每次移动的一定是没标记过的。


## 代码奉上

```
#include<bits/stdc++.h>
using namespace std;
int n,d[110],vis[110];
int maxv;
int read() { //快读，其实这道题用不上
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*f;
}
int main() {
	n=read();
	for(int i=1; i<=n; i++) d[i]=read();
	printf("%lld\n",n*n*2);	//我算出来的操作次数
	for(int i=1; i<=n; i++) {
		maxv=0;
		for(int i=1; i<=n; i++) {
			if(!vis[i])//判断标记过没有
				maxv=max(maxv,d[i]);
		}
		for(int j=1; j<=n; j++) {
			if(!vis[j]) {
				if(d[j]!=maxv) {
					printf("UZMI L L\n");//拿到左手上面
					printf("STAVI L D\n");//放到右边的书架
				} else {
					printf("UZMI D L\n");//拿到右手上面
					vis[j]=1;	//这个数已经处理，打上标记
				}
			}
		}
		printf("STAVI D L\n");//右手上的东西放下去
		for(int j=1; j<=n; j++) {
			if(!vis[j]) {
				printf("UZMI L D\n");//把右边书架的东西拿起来
				printf("STAVI L L\n");//放到左边书架上
			}
		}
	}
	return 0;
}
```
**有问题可以私信博主或评论区留言。**

---

## 作者：FallingFYC_ (赞：0)

# [原题](https://www.luogu.com.cn/problem/P7209)
不知不觉就 AC 了？

---
### 分析

很容易就能发现，本题与著名的汉诺塔问题很相似，因此我们也可以用类似解汉诺塔的方式做这道题。

根据汉诺塔的求解原则，右侧书架很明显就是来当一个临时存储书的地方。

我的思路类似于冒泡排序，步骤如下：

1. 将 $d$ 数组排序（新建一个与 $d$ 数组相同的数组排序）。
2. 将所有左侧书架的书移到右侧书架。
3. 重复 $n$ 轮如下操作：

	1. 依次取出右侧书架的每一本书放到左侧书架（遍历），直到当前拿下的书是右侧书架中最厚的。
    
       如何知道右侧书架中最厚的书是哪一本呢？
       
       很~~简单~~，由于每次拿出的书都是右侧书架中最厚的，因此每一次拿出那本书后，当前右侧书架中最厚的书就是比此轮操作之前右侧书架中最厚的书小的最大的书（省流：第二大的），也就是说：**如果正在执行第 $i$ 轮操作，那么当前右侧书架中最厚的书就是 $d_i$**，这也就是为什么 $d$ 数组要排序的原因。
    
   2. 将最厚的书留着（用左手拿着），用另一只手将刚才放到左侧书架的书再放回右侧书架。
   
   3. 将留着的书放到左侧书架上。

~~怎么感觉与冒泡排序毫无关系。~~

此外，还可以进行一个特判：如果输入时左侧书架的书就是升序排列的话，就直接输出 $0$，结束程序。

由于我们需要知道右侧书架里的书，因此需要存储下来，我用的是 `vector`，每次在执行第 $3$ 步时，把当前最厚的书删除就行了。

如上的方法时间复杂度大概是 $O(n ^ 2)$，因此 $k$ 的最大范围大约是 $10000$，能够通过此题。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n , k , d[105] , sd[105];
bool flag = true;
vector<string> opt;
vector<int> s2;

bool cmp(int a , int b)
{
	return a > b;
}

int main()
{
	cin >> n;
	for (int i = 1 ; i <= n ; i++)
	{
	    cin >> d[i]; sd[i] = d[i];
	    if (i > 1 && d[i] < d[i - 1]) flag = false;
	}
	if (flag) {cout << 0; return 0;}
    sort(sd + 1 , sd + n + 1 , cmp);

    for (int j = 1 ; j <= n ; j++)
	{
        opt.push_back("UZMI L L");
		opt.push_back("STAVI L D"); s2.push_back(d[j]);
	}

	for (int i = 1 ; i <= n ; i++)
	{
        int j;
		for (j = 0 ; s2[j] < sd[i] ; j++)
		{
            opt.push_back("UZMI L D");
			opt.push_back("STAVI L L");
		}
        opt.push_back("UZMI L D"); s2.erase(s2.begin() + j);
		for ( ; j >= 0 ; j--)
		{
			opt.push_back("UZMI D L");
			opt.push_back("STAVI D D");
		}
		opt.push_back("STAVI L L");
	}
	
	k = opt.size();
	cout << k << endl;
	for (int i = 0 ; i < k ; i++)
		cout << opt[i] << endl;
	return 0;
}
```
[评测记录](https://www.luogu.com.cn/record/list?pid=P7209&user=923403&page=1)

PS：有大佬能帮忙解释为什么前面暴零的记录里有 `UKE` 吗？

---

## 作者：Perta (赞：0)

~~真大模拟~~

## 思路

注意 $1\leq n\leq 100$，以及答案不超过 $10^5$。

我们可以发现 $n^2< 10^5$，于是乎就有了一个暴力思想：每次从右侧书架寻找当前第几薄的书的位置，将其拿出来，过程中可以先把不必要的书放到左侧书架。拿出来之后再将之前的不必要的书放回去，以免打乱排好的顺序。最后将我们要的书放到左侧书架即可。

~~应该很好理解~~

形式化来讲，当前有两种情况：

- 我们要的书在左侧书架
- 我们要的书在右侧书架

回想一下自己整理书柜的时候怎么整理的。先将所有书拿出来，然后再一本本书分好类放到书柜里。

这个题目也是一样的。对于上述两种情况，我们可以强行将其转化为只有一种情况，即先把所有书放到右侧书架，再统一转移到左侧书架。

考虑如何转移。由于只有两只手，我们需要一只手来将当前需要的书拿好，另一只手用于书的转移。先将当前需要的书从右侧书架中拿出来，过程中另外拿出的书先暂时转移到左侧书架（因为没地方放）。拿到需要的书后再将刚才拿出的乱序的书再次转移回右侧书架，将需要的书放到左侧书架。这样就可以保证左侧书架的顺序是对的。

这样子模拟的时间复杂度为 $O(2n^2)$，答案在限制范围内，也不会超时，绰绰有余。

## 代码实现

先放完整代码，有不理解的再看代码下方的讲解。

#### 完整代码

~~~
#include<bits/stdc++.h>
using namespace std;
const int K=1e5+10,N=110;
int n,k,now=2,a[N],id[N];
string ans[K][4];
stack<int>t,p;
bool check,biao[N];
bool cmp(int x,int y) {return a[x]>a[y];}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",a+i),id[i]=i;
		if(a[i]<a[i-1]) check=true;
	}
	if(!check) puts("0"),exit(0);//特判0
	sort(id+1,id+n+1,cmp);
	for(int i=1;i<=n;i++)//先在栈中加入书籍再进行循坏
	{
		if(id[1]!=i)
		{
			ans[++k][0]="UZMI",ans[k][1]="L",ans[k][2]="L";
			ans[++k][0]="STAVI",ans[k][1]="L",ans[k][2]="D";
			t.push(i);
		}
		else ans[++k][0]="UZMI",ans[k][1]="D",ans[k][2]="L";	
	}
	ans[++k][0]="STAVI",ans[k][1]="D",ans[k][2]="L";
	while(!t.empty()&&now<=n)
	{
		while(1)
		{
			int g=t.top();
			p.push(g),t.pop();
			if(g!=id[now])
			{
				ans[++k][0]="UZMI",ans[k][1]="L",ans[k][2]="D";
				ans[++k][0]="STAVI",ans[k][1]="L",ans[k][2]="L";
			}
			else
			{
				ans[++k][0]="UZMI",ans[k][1]="D",ans[k][2]="D";
				p.pop(),now++;
				break;
			}
		}
		while(!p.empty())
		{
			t.push(p.top()),p.pop();
			ans[++k][0]="UZMI",ans[k][1]="L",ans[k][2]="L";
			ans[++k][0]="STAVI",ans[k][1]="L",ans[k][2]="D";
		}
		ans[++k][0]="STAVI",ans[k][1]="D",ans[k][2]="L";
	}
	printf("%d",k);
	for(int i=1;i<=k;i++)
	{
        putchar('\n');
		cout<<ans[i][0]<<" "<<ans[i][1]<<" "<<ans[i][2];
	}
	return 0;
}
~~~

***

#### 代码讲解

设 $id_i$ 表示在正确的顺序下的第 $i$ 本书在当前的位置，$ans_{i,j}$ 表示第 $i$ 次操作对应的第 $j$ 个答案（输出）。栈 $t$ 用来存储右侧书架上的书籍，$p$ 用来存储转移的不需要的书。

先将 $id_i$ 进行排序，其关键字为书的薄厚程度。

由于最开始的栈是空的，所以我们找第一本书的过程与找其它书不太一样，需要顺便将书的数据加入栈 $t$ 中。这个过程不要忘了将左侧书籍加入到右侧书架，这也是答案的一部分。

然后进入找书的循环。将书的数据从栈 $t$ 中弹出，并用另一个栈 $p$ 存储，方便再将其从左侧书架转移回来。当 $id_i$ 为当前我们需要的书的时候就退出。先将栈 $p$ 中存储的数据再放到栈 $t$ 中，再将我们需要的书放进去。

重复上述操作直到所有的书都放回原位即可。

注意最后输出答案的时候不要多加空格或换行~~否则会全 WA~~。

***


完结撒花owo。

---

## 作者：Foreverxxx (赞：0)

## 题意

将左侧书架的书通过左侧书架、右侧书架和两只手，将这些书堆在左侧书架上并且满足从上至下逐渐增厚，其中每个书架只能有一摞书，每只手只能拿一本书。

## 题目定位

一道大模拟，适合所有人练习。

## 思路

可以采用分类讨论 ( 避免讨论复杂的思路以至于出错 ）：

首先扫一遍当前没有排好序的书，找到最厚的书。

第一种情况 : 书在左侧书架上

首先将这本书上面的所有书通过左手转移到右侧书架上，然后右手拿上这本书，再把左侧书架上剩余的没排序的书通过左手转移到右侧书架上，最后把右手的书放在左侧书架上即可。

第二种情况 : 书在右侧书架上

与第一种情况类似，这里就不再赘述。

对于两个书架，我们很容易想到 `stack` 或 `vector` 模拟两个书架的情况，本蒟蒻的代码使用的 `vector` 。

## 注意事项

千万不要把字母给打错了！

因为题目要求操作次数不能超过 100000 ，所以我写了个随机数据代码，发现操作次数最多也不到 30000 。

AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> par;
int n;
vector<int> l;
vector<int> r;
int a[105];
string s[100005];
string lhand[100005],rhand[100005];
int tot=0;
int main(){
	//ifstream rosein("knjige.in");
	//ofstream roseout("knjige.out");
	cin>>n;
	for(register int i=1;i<=n;i++) cin>>a[i];
	for(register int i=n;i>=1;i--) l.push_back(a[i]);
	int cnt=0;
	while(cnt!=n){
		int maxn=0,maxid;
		for(register int i=cnt;i<l.size();i++){
			if(l[i]>maxn){ maxn=l[i]; maxid=1; }
		}
		for(register int i=0;i<r.size();i++){
			if(r[i]>maxn){ maxn=r[i]; maxid=2; }
		}
		if(maxid==1){
			if(l[cnt]==maxn) cnt++;
			else {
				while(l.back()!=maxn){
					r.push_back(l.back());
					l.pop_back();
					s[++tot]="UZMI",lhand[tot]="L",rhand[tot]="L";
					s[++tot]="STAVI",lhand[tot]="L",rhand[tot]="D";
				}
				l.pop_back();
				s[++tot]="UZMI",lhand[tot]="D",rhand[tot]="L";
				while(l.size()!=cnt){
					r.push_back(l.back());
					l.pop_back();
					s[++tot]="UZMI",lhand[tot]="L",rhand[tot]="L";
					s[++tot]="STAVI",lhand[tot]="L",rhand[tot]="D";
				}
				l.push_back(maxn);
				s[++tot]="STAVI",lhand[tot]="D",rhand[tot]="L";
				cnt++;
			}
		}
		else {
			while(r.back()!=maxn){
				l.push_back(r.back());
				r.pop_back();
				s[++tot]="UZMI",lhand[tot]="L",rhand[tot]="D";
				s[++tot]="STAVI",lhand[tot]="L",rhand[tot]="L";
			}
			r.pop_back();
			s[++tot]="UZMI",lhand[tot]="D",rhand[tot]="D";
			while(l.size()!=cnt){
				r.push_back(l.back());
				l.pop_back();
				s[++tot]="UZMI",lhand[tot]="L",rhand[tot]="L";
				s[++tot]="STAVI",lhand[tot]="L",rhand[tot]="D";
			}
			l.push_back(maxn);
			s[++tot]="STAVI",lhand[tot]="D",rhand[tot]="L";
			cnt++;
		}
	}
	cout<<tot<<"\n";
	for(register int i=1;i<=tot;i++)
		cout<<s[i]<<" "<<lhand[i]<<" "<<rhand[i]<<"\n";
	return 0;
}
```


外加随机数据代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ofstream roseout("knjige.in");
	srand(time(0));
	int n=100;
	rosoeut<<n<<endl;
	for(int i=1;i<=n;i++){
		int d=abs(rand())%1000;
		roseout<<d<<" ";
	}
	return 0;
}
```


---

## 作者：_acat_ (赞：0)

~~差点交错题。~~

第 30 篇题解 祭。
## 思路
注意，如果我们能把所有的书都放在右边的书架上，按照从厚到薄（从上到下）排序，那么我们就可以把它们一个一个地移回左边的书架。

只要左架子不是空的，我们可以通过重复下面的操作：

- 用左手将书从左边的书架移到右边的书架，直到我们从左边的书架取到最薄的书放在最上面。

- 右手拿左边书架最上面的书。

- 用左手将第一步中移动的所有书籍放回左边的书架。

- 把右边的书放在右边的书架上。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000;

int n, p[MAXN];

stack <int> l, d;
vector <tuple <string, char, char> > potezi;

void potez(string a, char b, char c) {
  potezi.push_back({a, b, c});
}

int main() {
  cin >> n;
  for (int i = 0; i < n; i++) {
    cin >> p[i];
  }
  for (int i = n - 1; i >= 0; i--) {
    l.push(p[i]);
  }

  sort(p, p + n);

  for (int i = 0; i < n; i++) {
    int prebacio = 0;
    while (l.top() != p[i]) {
      potez("UZMI", 'L', 'L');
      potez("STAVI", 'L', 'D');
      d.push(l.top());
      l.pop();
      prebacio++;
    }

    potez("UZMI", 'D', 'L');
    l.pop();
    for (int j = 0; j < prebacio; j++) {
      potez("UZMI", 'L', 'D');
      potez("STAVI", 'L', 'L');
      l.push(d.top());
      d.pop();
    }
    potez("STAVI", 'D', 'D');
    d.push(p[i]);
  }

  while (!d.empty()) {
    potez("UZMI", 'L', 'D');
    potez("STAVI", 'L', 'L');
    l.push(d.top());
    d.pop();
  }

  cout << potezi.size() << endl;
  for (const auto &p : potezi) {
    cout << get<0>(p) << ' ' << get<1>(p) << ' ' << get<2>(p) << endl;
  }

  return 0;
}

```

---


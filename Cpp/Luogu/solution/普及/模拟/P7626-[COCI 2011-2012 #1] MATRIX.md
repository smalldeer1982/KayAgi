# [COCI 2011/2012 #1] MATRIX

## 题目描述

有一个 $N \times N$ 的矩阵，找出它的美丽值最大的子矩阵，要求这个子矩阵是正方形，即长和宽相等。

定义一个矩阵的**美丽值**为：将这个矩阵**主对角线**上的数的和定义为 $A$，另一条对角线上的数的和定义为 $B$，则这个矩阵的美丽值为 $A - B$。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 400$，矩阵元素 $\in [-10^3,10^3]$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $80$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #1](https://hsin.hr/coci/archive/2011_2012/contest1_tasks.pdf)** ___T2 MATRIX___。

## 样例 #1

### 输入

```
2
1 -2
4 5```

### 输出

```
4```

## 样例 #2

### 输入

```
3
1 2 3
4 5 6
7 8 9```

### 输出

```
0```

## 样例 #3

### 输入

```
3
-3 4 5
7 9 -2
1 0 -6```

### 输出

```
5```

# 题解

## 作者：Aiopr_2378 (赞：21)

# Solution P7626 [COCI2011-2012#1] MATRIX

### 思路：

首先，我们可以想到暴力求解。对每一个子矩阵的长宽、整个矩阵长宽进行循环，暴力求解。但是 $N<=400$ ，显然这种4~5层循环的不行。所以我们要想怎样优化。

首先，子矩阵长宽、整个矩阵长、宽这三层循环是不能去掉的。那我们就想怎样让求对角线长度的时间复杂度尽量低。

所以，我们可以用前缀和对两条对角线进行计数。每个点有两个对角线运算。

别的没有什么要注意的，详见代码。

### 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[405][405],sum,x[405][405],y[405][405];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			x[i][j]=x[i-1][j-1]+a[i][j];//进行前缀和计数，x[][]表示主对角线
			y[i][j]=y[i-1][j+1]+a[i][j];//y[][]表示副对角线
		}
	}
	int A,B;
	for(int k=1;k<=n;k++){
		for(int i=k;i<=n;i++){
			for(int j=k;j<=n;j++){
				A=x[i][j]-x[i-k][j-k];//计算每个子矩阵的主对角线和副对角线长度
				B=y[i][j-k+1]-y[i-k][j+1];
				sum=max(sum,A-B);//进行运算
			}
		}
	}
	cout<<sum;
	return 0;
}
```

看了这么久，点个赞再走吧

---

## 作者：cqbztz2 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P7626)

## 题目大意：

- 在一个 $ N*N $ 的矩阵中找一个子矩阵使得主对角线 $ A $ 减副对角线 $ B $ 的和最大。

## 思路：

- 就是对主对角线和副对角线求前缀和，查询的时候就直接求线段长。

 因为子矩阵是正方形而且数据比较小，所以从一个点开始 $ +1+1 $ 地枚举，然后推出位置求用前缀和求长度。
 
## 代码:

```cpp
  #include<bits/stdc++.h>
  using namespace std;
  long long n,m,ans,a[5][405][405];
  int main(){
      cin>>n;
      for(int i=1;i<=n;i++){
          for(int j=1;j<=n;j++){
              cin>>a[1][i][j];
              a[2][i][j]=a[1][i][j];
              a[1][i][j]=a[1][i][j]+a[1][i-1][j-1];
              a[2][i][j]=a[2][i][j]+a[2][i-1][j+1];//前缀和 
          }
      }       
      for(int k=1;k<=n;k++){
          for(int i=k;i<=n;i++){
              for(int j=k;j<=n;j++){
                  ans=max(ans,(a[1][i][j]-a[1][i-k][j-k])-(a[2][i][j-k+1]-a[2][i-k][j+1]));//求差的最大值 
              }     
          }  
      }
      cout<<ans;
      return 0;
  }
```
~~**求过**~~

---

## 作者：_YyD_ (赞：5)

1. 将 A,B 做前缀和。

2. 暴力（复杂度是 $O(N^3)$ 的）。

做法:从一个点开始一个一个地枚举，然后推出位置求用前缀和求长度。

```cpp
#include<bits/stdc++.h>
#define _ ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define lep(i,l,r) for(int i=l;i>=r;i--)
using namespace std;
int sum[3][401][401],l,n,m,ans;
int main(){
	cin>>n;
	rep(i,1,n){
		rep(j,1,n){
			cin>>sum[1][i][j];
            sum[2][i][j]=sum[1][i][j];
            sum[1][i][j]=sum[1][i][j]+sum[1][i-1][j-1];
            sum[2][i][j]=sum[2][i][j]+sum[2][i-1][j+1];
		}
	}
	rep(i,2,n){
		rep(j,2,n){
			int k=2;
			while(i-k>=0&&j-k>=0){
				l=(sum[1][i][j]-sum[1][i-k][j-k])-(sum[2][i][j-k+1]-sum[2][i-k][j+1]);
				ans=max(ans,l);
                k++;
			}
		}
	}
	cout<<ans;
	return 0;
}

```
注：思路来自 disPlayLzy_。

---

## 作者：I_am_rubbish (赞：2)

## P7626 [COCI2011-2012#1] MATRIX
### 首先
我们先读题 ~~（看标签）~~ ，明显，这是道暴力枚举的题，可是 N 可是到了 $400$ ，什么概念呢， $n^3$ 最多了，那么我们最暴力的方法就炸了。（枚举各子矩阵大小和各点位置，在for两遍求出 A - B 比出答案，复杂度： $n^4$ ）
### 然后
分析一下，发现枚举各子矩阵大小和各点位置的循环是不能省的，所以我们要想办法把求出 A - B 的值压到 $O(1)$ 或者 log 级的。
好巧啊，前缀和预处理正好可以压到 $O(1)$
### 最后
您可以秒切了。代码嘛。。。就 ~~不~~ 贴在下面了
```c
#include <bits/stdc++.h>
#define int long long//十年OI一场空，不开long long 见祖宗（虽然这题不需要）
using namespace std;
int n, a[1001][1001], sum1[1001][1001], sum2[1001][1001], maxn = -1e18;
signed main()
{
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			scanf("%lld", &a[i][j]);
			sum1[i][j] = sum1[i - 1][j - 1] + a[i][j];//第一个对角线的前缀和
			sum2[i][j] = sum2[i - 1][j + 1] + a[i][j];//第二个对角线的前缀和
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j <= n; j++)
		{
			for (int x = i; x <= n; x++)
			{
				maxn = max(maxn, (sum1[j][x] - sum1[j - i][x - i])/*O(1)求出A*/ - (sum2[j][x - i + 1] - sum2[j - i][x + 1]/*O(1)求出B/));//比答案
			}
		}
	}
	printf("%lld", maxn);
	return 0;//完结撒花
}

```
~~其实这题没啥难的会个前缀和就行~~


---


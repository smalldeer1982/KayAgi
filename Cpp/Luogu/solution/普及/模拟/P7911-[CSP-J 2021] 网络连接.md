# [CSP-J 2021] 网络连接

## 题目描述

TCP/IP 协议是网络通信领域的一项重要协议。今天你的任务，就是尝试利用这个协议，还原一个简化后的网络连接场景。

在本问题中，计算机分为两大类：服务机（`Server`）和客户机（`Client`）。服务机负责建立连接，客户机负责加入连接。

需要进行网络连接的计算机共有 $n$ 台，编号为 $1 \sim n$，这些机器将按编号递增的顺序，依次发起一条建立连接或加入连接的操作。

每台机器在尝试建立或加入连接时需要提供一个地址串。服务机提供的地址串表示它尝试建立连接的地址，客户机提供的地址串表示它尝试加入连接的地址。

一个符合规范的地址串应当具有以下特征：

1. 必须形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为非负整数；
2. $0 \le a, b, c, d \le 255$，$0 \le e \le 65535$；
3. $a, b, c, d, e$ 均不能含有多余的前导 $0$。

相应地，不符合规范的地址串可能具有以下特征：

1. 不是形如 `a.b.c.d:e` 格式的字符串，例如含有多于 $3$ 个字符 `.` 或多于 $1$ 个字符 `:` 等情况；
2. 整数 $a, b, c, d, e$ 中某一个或多个超出上述范围；
3. 整数 $a, b, c, d, e$ 中某一个或多个含有多余的前导 $0$。

例如，地址串 `192.168.0.255:80` 是符合规范的，但 `192.168.0.999:80`、`192.168.00.1:10`、`192.168.0.1:088`、`192:168:0:1.233` 均是不符合规范的。

如果服务机或客户机在发起操作时提供的地址串不符合规范，这条操作将被直接忽略。

在本问题中，我们假定凡是符合上述规范的地址串均可参与正常的连接，你无需考虑每个地址串的实际意义。

由于网络阻塞等原因，不允许两台服务机使用相同的地址串，如果此类现象发生，后一台尝试建立连接的服务机将会无法成功建立连接；除此之外，凡是提供符合规范的地址串的服务机均可成功建立连接。

如果某台提供符合规范的地址的客户机在尝试加入连接时，与先前某台已经成功建立连接的服务机提供的地址串相同，这台客户机就可以成功加入连接，并称其连接到这台服务机；如果找不到这样的服务机，则认为这台客户机无法成功加入连接。

请注意，尽管不允许两台不同的服务机使用相同的地址串，但多台客户机使用同样的地址串，以及同一台服务机同时被多台客户机连接的情况是被允许的。

你的任务很简单：在给出每台计算机的类型以及地址串之后，判断这台计算机的连接情况。

## 说明/提示

**【样例解释 #1】**

计算机 $1$ 为服务机，提供符合规范的地址串 `192.168.1.1:8080`，成功建立连接；

计算机 $2$ 为服务机，提供与计算机 $1$ 相同的地址串，未能成功建立连接；

计算机 $3$ 为客户机，提供符合规范的地址串 `192.168.1.1:8080`，成功加入连接，并连接到服务机 $1$；

计算机 $4$ 为客户机，提供符合规范的地址串 `192.168.1.1:80`，找不到服务机与其连接；

计算机 $5$ 为客户机，提供的地址串 `192.168.1.1:99999` 不符合规范。

**【数据范围】**

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1$ | $10$ | 性质 1 2 3 |
| $2 \sim 3$ | $100$ | 性质 1 2 3 |
| $4 \sim 5$ | $1000$ | 性质 1 2 3 |
| $6 \sim 8$ | $1000$ | 性质 1 2 |
| $9 \sim 11$ | $1000$ | 性质 1 |
| $12 \sim 13$ | $1000$ | 性质 2 |
| $14 \sim 15$ | $1000$ | 性质 4 |
| $16 \sim 17$ | $1000$ | 性质 5 |
| $18 \sim 20$ | $1000$ | 无特殊性质 |

“性质 1”为：保证所有的地址串均符合规范；  
“性质 2”为：保证对于任意两台不同的计算机，如果它们同为服务机或者同为客户机，则它们提供的地址串一定不同；  
“性质 3”为：保证任意一台服务机的编号都小于所有的客户机；  
“性质 4”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为不超过 ${10}^9$ 且不含有多余前导 $0$ 的非负整数；  
“性质 5”为：保证所有的地址串均形如 `a.b.c.d:e` 的格式，其中 $a, b, c, d, e$ 均为只含有数字的非空字符串。

对于 $100 \%$ 的数据，保证 $1 \le n \le 1000$。

**【提供 hack 数据感谢】**  

- [xyf007](/user/68273)。

## 样例 #1

### 输入

```
5
Server 192.168.1.1:8080
Server 192.168.1.1:8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.1:99999
```

### 输出

```
OK
FAIL
1
FAIL
ERR
```

## 样例 #2

### 输入

```
10
Server 192.168.1.1:80
Client 192.168.1.1:80
Client 192.168.1.1:8080
Server 192.168.1.1:80
Server 192.168.1.1:8080
Server 192.168.1.999:0
Client 192.168.1.1.8080
Client 192.168.1.1:8080
Client 192.168.1.1:80
Client 192.168.1.999:0
```

### 输出

```
OK
1
FAIL
FAIL
OK
ERR
ERR
5
1
ERR
```

## 样例 #3

### 输入

```
见附件中的 network/network3.in。```

### 输出

```
见附件中的 network/network3.ans。```

## 样例 #4

### 输入

```
见附件中的 network/network4.in。```

### 输出

```
见附件中的 network/network4.ans。```

# 题解

## 作者：xyf007 (赞：252)

UPD：修复了正则表达式的错误。

提供两种极其好写的做法，代码长度均 <1k。  
这题主要难点在于判断一个地址是否合法，剩下部分可以直接使用 `std::map/unordered_map` 来解决，因此主要判断地址是否合法。

方法一：  
注意到字符串长度 $\le25$，因此一个数字最长为 17 位，可以使用 `long long` 存储。  
`std::sscanf(s, "%lld.%lld.%lld.%lld:%lld", &a, &b, &c, &d, &port)` 表示从 `s` 中读入 `a`，忽略下一个 `.`，读入 `b`，忽略下一个 `.`。以此类推。其返回值是成功读取的元素个数。因此如果返回值不是 $5$ 一定不合法。如果几个值不满足题目要求也不合法。  
然后考虑处理前导 0 和后面是否多出来一些内容。但是我们可以反过来，用得到的的数拼出合法的地址，然后和原串比较一下是否完全相同。如果没有前导 0 且后面没有多余内容，两者应该完全相同。拼出地址可以使用 `std::stringstream` 或者 `std::to_string` 来处理。代码使用了 `std::stringstream`。  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
bool Check(string s) {
  long long a, b, c, d, port;
  if (sscanf(s.c_str(), "%lld.%lld.%lld.%lld:%lld", &a, &b, &c, &d, &port) != 5)  return false;
  if (a < 0 || a > 255 || b < 0 || b > 255 || c < 0 || c > 255 || d < 0 || d > 255 || port < 0 || port > 65535)  return false;
  stringstream ss;
  ss << a << '.' << b << '.' << c << '.' << d << ':' << port;
  return ss.str() == s;
}
map<string, int> mp;
string op, ad;
int main(int argc, char const *argv[]) {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> op >> ad;
    if (!Check(ad)) { cout << "ERR\n"; continue; }
    if (op[0] == 'S') {
      if (mp[ad]) cout << "FAIL\n";
      else mp[ad] = i, cout << "OK\n";
    } else {
      if (!mp.count(ad)) cout << "FAIL\n";
      else cout << mp[ad] << '\n';
    }
  }
  return 0;
}
```
方法二：  
今年使用 C++14 标准，因此可以使用 C++11 的 `regex` 库。直接写一个正则表达式判断是否合法即可。正则表达式可以参考洛谷日报或者百度。正则库的使用方法可以参考 [C++ Reference](https://zh.cppreference.com/w/cpp/regex)。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
regex r("(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5]):(\\d|[1-9]\\d{1,3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])");
map<string, int> m;
string o, a;
int main(int argc, char const *argv[]) {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> o >> a;
    if (!regex_match(a, r)) { cout << "ERR\n"; continue; }
    if (o[0] == 'S') {
      if (m[a]) cout << "FAIL\n";
      else m[a] = i, cout << "OK\n";
    } else {
      if (!m.count(a)) cout << "FAIL\n";
      else cout << m[a] << '\n';
    }
  }
  return 0;
}
```

---

## 作者：Otue (赞：100)

## 分析
主要问题为：判断这个地址是否合法。

可以用 `sscanf` 尝试读入形如 `a.b.c.d:e` 的字符串，并返回读取结果。

如果读到的数不是 $5$ 个，肯定不合法。

然后再判断 $a,b,c,d,e$ 的范围是否合法。

这个时候，再用 `a.b.c.d:e` 把这个字符串保存，判断是否跟原来字符串是否相同即可。

## 例子


输入一个 `1.2.3.4:5` ，读取结果为$a=1$，$b=2$，$c=3$，$d=4$，$e=5$。

这个时候，再按照 `a.b.c.d:e` 这个方式去保存，得到 `1.2.3.4:5`，跟原来字符串相同，则合法。

## 特殊情况

你也许会问，怎么判断前导 $0$ 呢？

其实，我们已经解决了这个问题。


**比如：** 输入一个 `01.2.3.4:5` ，读取结果为 $a=1$，$b=2$，$c=3$，$d=4$，$e=5$。

现在再按照 `a.b.c.d:e` 这个方式去保存，得到 `1.2.3.4:5` ，你会发现跟原来的字符不匹配，因为 $a$ 原来是 $01$ 的，现在变成了 $1$ 。

这样，就完美的解决了前导 $0$ 的情况！
## 其他
判断字符串是否合法已经解决，那么怎么加入并查找一个地址呢？

可以用一个 `map` 解决，定义一个 `map<string,int> vis`，`string` 存地址，`int` 存下标。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
map<string,int> vis;
int n;
bool check(char s[]){
	int a=-1,b=-1,c=-1,d=-1,e=-1;
	int t=sscanf(s,"%d.%d.%d.%d:%d",&a,&b,&c,&d,&e);//尝试读入，保存至s中
	if(t!=5) return 0;//没有5个肯定不行
	if(a<0||a>255) return 0;
	if(b<0||b>255) return 0;
	if(c<0||c>255) return 0;
	if(d<0||d>255) return 0;
	if(e<0||e>65535) return 0;//判断
	char s2[35];
	sprintf(s2,"%d.%d.%d.%d:%d",a,b,c,d,e);//保存至s2中
	int lens=strlen(s);//接下来判断s2和s是否一样
	bool ok=0;
	for(int i=0;i<lens;i++){
		if(s[i]==s2[i]) ok=1;
		else{
			ok=0;
			break;
		}
	}
	return ok;
}
int main(){
//	freopen("network.in","r",stdin);
//	freopen("network.out","w",stdout); 
	cin>>n;
	for(int i=1;i<=n;i++){
		char op[1005],ad[1005];
		cin>>op>>ad;
		string t(ad);
		if(op[0]=='S'){//服务机
			if(!check(ad)) cout<<"ERR"<<endl;//判断是否合法
			else if(vis.count(t)!=0){//之前有了，输出FAIL
				cout<<"FAIL"<<endl;
			} 
			else{
				cout<<"OK"<<endl;
				vis[t]=i;//保存编号
			}
		}
		else{//客户机
			if(!check(ad)){//判断是否合法
				cout<<"ERR"<<endl; 
			}
			else if(vis.count(t)==0){//如果之前还没有相同地址串的服务机，输出FAIL
				cout<<"FAIL"<<endl;
			}
			else{
				cout<<vis[ad]<<endl;//否则就是可以连接，输出连接编号
			}
		}
	}
}
```

---

## 作者：Astatinear (赞：44)

### 本题总结

这个题目我考场上是 `wrong` `answer` `65` 。 错因比较简单，就是在判断 `err` 的时候判断错了几个地方:

1.前导零。

2. `.` 和 `:` 的顺序我没有判断。

3.他没有输入任何数字的时候，我会默认这些数字为 `0` 。

所以这个题目一定要特别注意 `err` 的条件，一不小心就会把 `err` 给判错。最好考试的时候自己写几个毒瘤数据测试一下。

#### 本题正解

这个题目还是比较简单的，判断 `err` 的话就全凭大家的细心，这里不做过多的阐述，下面给大家说 `3` 个客户机匹配服务机和判断服务机是否重复的方法。

1.直接暴力，判断他以前的那些有没有和一模一样的字符串。

2.运用 `map` ，键类型为 `string` 就可以做了。假设当前要判断是否重复的服务机的字符串为 `s` 。如果 $map[s]$ 有值，就说明以前有这个字符串，如果没有，就说明以前没有这个字符串。客户机匹配服务机时也同样。

3.运用字符串 `hash` 。其实这个方法就是将方法 `1` 给优化了一下，因为我们判断两个字符串完全相等时，需要一个一个枚举这个字符串里面的每个字符，很浪费时间，虽然可以过，但是有一些浪费。 由于判断 `2` 个字符串是否相等，我们可以通过 `hash` 来判断。 所以我们每有一个新的字符串，我们就把他的 `hash` 值给存下来，然后在匹配或者判断是否重复时，直接判断两个 `hash` 值是否相等就可以了。

我在这里就直接给出第一种最简单的方法的代码。

#### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int tot;
string q[10005];
int ans[10005];
bool check(string s,int len)
{
	bool flg=0;
	int bj1=0,bj2=0;
	int cnt=0;
	long long p[105],q[105];//有可能五个数中有的会爆int
	memset(p,0,sizeof(p));
	for(int i=0;i<=100;++i)
	q[0]=-1;
	for(int i=0;i<len;++i)
	{
		if(bj2==1&&bj1<3)//已经出现:但.还没有出现 
		return 0;
		if(cnt+1<=bj1+bj2)//符号个数和数字个数不匹配 
		return 0;
		if(s[i]=='0')//特判一下0 
		{
			if(flg==0)
			cnt++;
			q[cnt]=0;
			if(i>=0)//判断前导0 
			{
				if(flg==0&&((s[i-1]<='9'&&s[i-1]>='0')||(s[i+1]<='9'&&s[i+1]>='0')))
				{
					return 0;
				}
			}
			else
			{
				if(flg==0&&(s[i+1]<='9'&&s[i+1]>='0'))
				{
					return 0;
				}	
			}
			flg=1;
			p[cnt]*=10;
		}
		else if(s[i]=='-')//如果有负数 
		return 0;
		else if(s[i]=='.')//特判. 
		{
			bj1++;
			flg=0;
		}
		else if(s[i]==':')//特判: 
		{
			bj2++;
			flg=0;
		}
		else if(s[i]>='1'&&s[i]<='9')//如果是数字 
		{
			if(flg==0)
			cnt++;
			q[cnt]=0;
			p[cnt]=p[cnt]*10+s[i]-'0'; 
			flg=1;
		}
		else if(s[i]==' ')//特判一下空格(没必要) 
		continue;
		else//如果有其他奇奇怪怪的符号 
		return 0;
	}
	if(p[1]<=255&&p[2]<=255&&p[3]<=255&&p[4]<=255&&p[5]<=65535&&cnt==5&&bj1==3&&bj2==1&&q[1]>=0&&q[2]>=0&&q[3]>=0&&q[4]>=0&&q[5]>=0)//奇奇怪怪的判断 
	return 1;
	else
	return 0;
}
int main()
{
// 	freopen("network12.in","r",stdin);
// 	freopen("network.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;++i) 
	{
		string op,s;
		cin>>op>>s;
		if(!check(s,s.length()))
		{
			printf("ERR\n");
			continue;
		}
		bool flg=0;
		if(op=="Server")
		{
			//暴力判断以前是否出现过 
			for(int j=1;j<=tot;++j)
			{
				if(s==q[j])
				{
					flg=1;
					break;
				}
			}
			if(flg==0)
			{
				printf("OK\n");
				q[++tot]=s;
				ans[tot]=i;
			}
			else
			{
				printf("FAIL\n");
			}
		}
		else
		{
			//暴力判断有没有与之匹配的 
			for(int j=1;j<=tot;++j)
			{
				if(q[j]==s)
				{
					printf("%d\n",ans[j]);
					flg=1;
					break;
				}
			}
			if(flg==0)
			{
				printf("FAIL\n");
			}
		}
	}
	return 0; 
}
```

---

## 作者：我和鱼过不去 (赞：30)

看到需要由地址串映射到计算机编号，我们可以考虑使用 
```map```。这里推荐使用用法基本相似但查询、修改复杂度均为 $O(1)$ 的 ```unordered_map```（需要用到 C++11，若在本地无法编译则要加上编译选项）。  
### 思路
+ 先判断**每台计算机**提供的地址串是否符合规范，若不符合，直接输出 ```ERR```；
+ 对于**每台服务器**（```Server```）提供的地址串，先在 ```unordered_map``` 中寻找该地址串是否已经建立映射（即是否已经有服务器提供相同地址串以建立连接），若已有则输出 ```FAIL```，否则建立映射并输出 ```OK```；
+ 对于**每台客户机** （```Client```）提供的地址串，先在```unordered_map``` 中寻找该地址串是否已经建立映射（即是否已经有服务器提供该地址串以建立连接），若已有则该客户机可以加入连接，此时输出建立连接的服务器的编号，否则该客户机不能加入连接，输出 ```FAIL```。


这里先简单介绍一下 ```unordered_map``` 。  
```unordered_map``` 本质上就像一个数组，  
只不过你可以自己定义键和值 ~~（其实就是下标与它所对应的元素）~~ 类型。
```cpp
unordered_map<string,int> mp;  
```
这样你就有了一个可以用 string 类型映射到 int 类型的 ```unordered_map``` 数组 $mp$ 。
```cpp
mp["hello"] = 532;
```
这意味着在 $mp$ 数组里，
$\mathtt{"hello"}$ 对应着 $\mathtt{532}$
。
```cpp
mp.count("hello");
mp.count("world");
```
判断该元素之前是否存在映射。
返回值分别为 $\mathtt{1}$ 和 $\mathtt{0}$。   
```map``` 的用法则与其相似，这里不再赘述。

判断地址串是否存在的部分可以用 ```unordered_map``` 解决，那么整道题的重点则落在了如何判断地址串是否规范上。  

我们先列出地址串不符合规范的所有可能形式。（以下内容参考[帖子：历史最全纠错](https://www.luogu.com.cn/discuss/375820)）  
1. 形如 ```a.b.c.d:e```，其中整数 $a,b,c,d,e$ 有一个数超过题目给定的范围（即 $0 \le a,b,c,d \le 255$ , $0 \le e \le 65535$），或有一个数含有前导 0。   
针对这种情况，我们可以用如下的方法依次提取 $a,b,c,d,e$，并判断其是否在规定范围内。
```cpp
bool check(string s)
{
    int len = s.length();
    long long tmp = 0;
    for(int i=0;i<len;i++)
    {
        if(s[i]=='.'||s[i]==':')
        {
            if(0<=tmp&&tmp<=255)    //判断a,b,c,d是否符合规范
            {
                tmp = 0;      //清零
                continue;
            }
            else return false;
        }
        else if(s[i]<'0'||s[i]>'9') return false;
        if(i&&!tmp&&s[i-1]=='0') return false;   //这一行用来判断前导0
        tmp = tmp*10+s[i]-'0';   //读取数字
    }
    if(0<=tmp&&tmp<=65535) return true;    //判断e是否符合规范
    else return false;
}
```


2. 形如 ```a.b.c:d.e```，其中字符 ```.```或 ```:```出现的顺序不规范。  
针对这种情况，我们可以用计数器分别记录 ```.``` 和 ```:``` 出现的次数，判断 ```:``` 出现时，```.```出现的次数是否为 3。
```cpp
int cnt1=0,cnt2=0,cnt3=0;
for(int i=0;i<len;i++)
{
    if(s[i]=='.'||s[i]==':')
    {
        if(s[i]=='.') cnt1++;
        else if(s[i]==':') cnt2++;
        if(cnt1<3&&cnt2) return false;   //出现顺序是否规范
        /*
            判断a,b,c,d的范围是否规范
        */
    }
    else if(s[i]<'0'||s[i]>'9') return false;
    /*
        判断前导0 以及提取数字
    */
}
```
3. 形如 ```a..b.c:e``` 或 ```a.b.c:.e```，其中字符 ```.``` 或 ```:``` 连着出现。   
这时候符号的数量符合规范，但数字的数量不符合规范。可以仿照情况2，用计数器记录数字出现的次数，并在最后判断字符和数字出现的次数是否符合规范。

4. 形如 ```.a.b.c:e``` 或 ```a.b.c.d:```，其中字符 ```.``` 或 ```:``` 出现在地址串头尾。
针对字符出现在头的情况，我们可以在字符出现时判断是否已有数字出现；针对字符出现在尾的情况，可以用情况3的方法来解决。  

这两种情况都需要加上数字的计数器。
```cpp
int len = s.length();
long long tmp = 0;
int cnt1=0,cnt2=0,cnt3=0;
for(int i=0;i<len;i++)
{
    if((i==0||(s[i-1]=='.'||s[i-1]==':'))&&s[i]>='0'&&s[i]<='9') cnt3++;   
    //如果当前为第一个位置或前一个为字符，并且这个位置为数字
    if(s[i]=='.'||s[i]==':')
    {
        /*
            统计字符出现的次数
        */
        if(cnt1<3&&cnt2) return false;    //出现顺序是否规范
        if(!cnt3) return false;   //如果字符在第一个数字前出现
        /*
            判断a,b,c,d的范围是否规范
        */
    }
    else if(s[i]<'0'||s[i]>'9') return false;
    /*
        判断前导0 以及提取数字
    */
}
if(cnt1!=3||cnt2!=1||cnt3!=5) return false;    //判断字符、数字出现的数量
/*
    判断e的范围是否规范
*/
```

将上述4种情况的解决方案拼在一起，就得到判断地址串是否规范的函数。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
unordered_map<string,int>address;
bool check(string s)
{
    int len = s.length();
    long long tmp = 0;
    int cnt1=0,cnt2=0,cnt3=0;
    for(int i=0;i<len;i++)
    {
        if((i==0||(s[i-1]=='.'||s[i-1]==':'))&&s[i]>='0'&&s[i]<='9') cnt3++;
        //如果当前为第一个位置或前一个为字符，并且这个位置为数字
        if(s[i]=='.'||s[i]==':')
        {
            if(s[i]=='.') cnt1++;
            else if(s[i]==':') cnt2++;
            //统计字符出现的次数
            if(cnt1<3&&cnt2) return false;    //出现顺序是否规范
            if(!cnt3) return false;  //如果字符在第一个数字前出现
            if(0<=tmp&&tmp<=255)  //判断a,b,c,d的范围是否规范
            {
                tmp = 0;
                continue;
            }
            else return false;
        }
        else if(s[i]<'0'||s[i]>'9') return false;   //出现了奇怪的字符
        if(i&&!tmp&&s[i-1]=='0') return false;    //判断前导 0
        tmp = tmp*10+s[i]-'0';    //提取数字
    }
    if(cnt1!=3||cnt2!=1||cnt3!=5) return false;   //字符和数字出现的数量是否正确
    if(0<=tmp&&tmp<=65535) return true;   //判断e的范围
    else return false;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        string cpt,adr;
        cin>>cpt>>adr;
        if(!check(adr)) puts("ERR");   //如果地址串不符合规范
        else if(cpt=="Server")
        {
            if(address.count(adr)) puts("FAIL");
            else 
            {
                address[adr] = i;
                puts("OK");
            }
        }
        else if(cpt=="Client")
        {
            if(address.count(adr)) printf("%d\n",address[adr]);
            else puts("FAIL");
        }
    }
    return 0;
}
```



---

## 作者：Shunpower (赞：23)

## 前情提要

考场上写出了这题满分做法（无论是民间数据还是官方数据），可惜少了一句`return true;`造成 RE……，于是一等奖变三等奖（可能压线二等），Lemon 衷心希望大家不再犯这样的错误写了这篇题解。

## 思路

考虑分成两个部分，判断合法和连接服务机（或建立连接）。

第二个部分可以通过 STL 的`map`轻易实现：以地址字符串作为下标存储服务机编号即可。

第一个部分整体可以分为三个小部分：是否符合类似`1.1.1.1:1`，里面的数是否符合范围，是否含有多余前导零。

### 2.1 判断是否符合`1.1.1.1:1`的形式

从“是否符合这样的形式”出发考虑，把所有的数都变成 $1$，再判断转出来的字符串是否类似`1.1.1.1:1`。

### 2.2 判断数是否符合范围

这一部分需要判断数是否符合范围。

把问题分成两部分，`:`前以及`:`后。先扫一遍字符串，找出`:`所在的位置，对于`:`之前，找到一个`.`字符就判断一次这个字符前的数范围合不合法。**注意，对于`:`前的最后一个数，因为后面没有`.`字符，要特别判断一下。**

对于`:`后，直接扫一遍再判断即可。

- Warning：因为字符串长度可能有 $25$ 位，所以可能有一个数高达 $17$ 位，字符串转数的时候要开`long long`，当然你也可以边扫边判断避免溢出。

### 2.3 判断多余前导零

考虑在第一个非 $0$ 数字出现前的 $0$ 数字个数，下面设这个个数为 $sum$。

- 当 $sum=0$ 时，说明没有前导零，通过。
- 当 $sum=1$ 且这个数长度为 $1$ 时，说明这个数是 $0$，通过。
- 其它情况都不通过。

注意为了判断这个数的长度，我们要存下一个数的开始位置。为了方便分离数，可以在原字符串后面加上一个`.`字符，每次遇到一个不是数字的字符就后移存数开始位置的变量并检查前面这个数是否合法。

## 代码

因为这下面都写在函数里，所以你可以理解 $k$ 为输入的原字符串。

### 3.1 检查形式

开一个新字符串存储缩略数后的的字符串。

```
const string ans="1.1.1.1:1";
f="";
bool f2;
for(int i=0;i<k.length();i++){
	f2=false;
	while(i<k.length()&&k[i]>='0'&&k[i]<='9'){
		f2=true;//其实这个有点多余……
		i++;//当这个位置是数字时，i就向后移动。
	}
	if(f2){
		f+='1';//把数都缩略成1
	}
	if(i<k.length()){//若最后是一个数，那么i就会移动到k.length()的位置，所以要特判。
		f+=k[i];
	}
}
if(f==ans){//如果转出来的串符合格式则返回通过。
	return true;
}
return false;
```

注意这里 $i$ 可能移动到字符串外，要特判。

### 3.2 检查数是否在范围内

先找出`:`字符的位置：

```
for(int i=0;i<k.length();i++){
	if(k[i]==':'){
   	  add=i;
		break;
	}
}
```

再扫描`:`前的部分把数转出来依次判断，注意这里存数的变量需要`long long`。

```
ll sum=0;
for(int i=0;i<add;i++){
	if(k[i]=='.'){//遇到点字符就要检查
		if(sum>255){
			return false;
		}
		sum=0;
	}
	else{
		sum=sum*10+k[i]-'0';//基本的字符串转数操作
	}
}
if(sum>255){//因为最后没有点字符，所以单独检查一次。
	return false;
}
sum=0;
```

最后类比刚刚扫描前半部分的方法，扫描`:`后的部分：

```
for(int i=add+1;i<k.length();i++){//从冒号字符后开始扫描
	sum=sum*10+k[i]-'0';
}
if(sum>65535){//判断
	return false;
}
return true;
```

### 3.3 判断多余前导零

往字符串后面增加一个`.`字符方便分离数，并初始化第一个数的开始位置为 $0$：
```
string t=k;
t+='.';
int kaishi;
kaishi=0;
```
对于每次遇到非数字的符号进行以下判断：
```
int sum=0;
for(int j=kaishi;j<i;j++){
	if(t[j]=='0'){
   	  sum++;
	}
	if(t[j]>='1'&&t[j]<='9'){
		break;
	}
}
if(kaishi==i-1&&sum==1){
	kaishi=i+1;
	continue;
}
if(sum==0){
	kaishi=i+1;
	continue;
}
else{
	return false;
}
return true;//这句代码，便是惨案。
```
其中 $i$ 是目前枚举到的位置（即非数字符号），从这个符号前那个数的开始位置依次向后枚举，统计第一个非 $0$ 数字出现前 $0$ 的个数。

最后按照思路中阐述的方法进行判断。注意要记得移动开始位置的下标到下一个数开始的位置。

### 3.4 主体部分

```
cin>>n;
for(int i=1;i<=n;i++){
	cin>>s;
	if(s==fuwu){//这里定义了常量 fuwu 为"Server"。
		cin>>idd;
		/*这里应该放上刚刚的所有判断函数*/
		if(!p.count(idd)){
			p[idd]=i;
			puts("OK");
			continue;
		}
		if(p.count(idd)){
			puts("FAIL");
			continue;
		}
	}
	else{
		cin>>idd;
		/*这里应该放上刚刚的所有判断函数*/
		if(!p.count(idd)){
			puts("FAIL");
			continue;
		}
		if(p.count(idd)){
			cout<<p[idd]<<endl;
			continue;
		}
	}
}
```

使用一个`map`，以地址字符串作为下标，映射到服务机的编号上即可。

## AC 代码及后记

AC 代码已经分散给出，注意理解第一。

[AC 记录](https://www.luogu.com.cn/record/61601893)

Lemon 就这样失去了 $100$ 分。

---

## 作者：Naptie (赞：13)

虽然本人没有参加今年 $\text{CSP-J}$，但是~~有幸~~参加了 $\text{CSP-S}$ ~~（挂得很惨）~~

所以本蒟蒻就来 $\text{J}$ 组水篇题解了。

本题不难，按照题意模拟即可。

大致思路就是：
>1. 读入类型（$\texttt{Server / Client}$）与 $\texttt{IP}$。
>
>2. 判断 $\texttt{IP}$ 是否合法：如果不合法，输出 $\texttt{ERR}$ 并 `continue`，否则继续。
>
>3. 如果类型是 $\texttt{Server}$，则在已连接的 $\texttt{IP}$ 中查询是否已存在本次需要建立的连接，如果是，则输出 $\texttt{FAIL}$，否则输出 $\texttt{OK}$；\
>如果类型是 $\texttt{Client}$，则在已连接的 $\texttt{IP}$ 中查询是否已存在本次需要加入的连接，如果是，则输出对应的 $\texttt{Server}$ 的编号，否则输出 $\texttt{FAIL}$。

对于在已建立的连接中进行查询的操作，使用 `unordered_map<string, int>` 来维护即可（具体实现见代码）。

对于判断 $\texttt{IP}$ 是否合法的方法，由于本人太菜，只能单独对每种不合法的情况进行判断：

1. $\texttt{IP}$ 的第 $1$ 个字符不为数字；
2. $\texttt{IP}$ 的第 $1$ 个字符为 $0$，且第 $2$ 个字符为数字；
3. $\texttt{IP}$ 的最后 $1$ 个字符不为数字；
4. $\texttt{IP}$ 中“`:`”之前的“`.`”的个数不足 $3$ 个；
5. $\texttt{IP}$ 中“`.`”的个数不为 $3$ 个；
6. $\texttt{IP}$ 中“`:`”的个数不为 $1$ 个；
7. $\texttt{IP}$ 中某个“`.`”之后的第 $1$ 个字符不为数字；
8. $\texttt{IP}$ 中某个“`.`”之后的第 $1$ 个字符为 $0$，且第 $2$ 个字符为数字；
9. $\texttt{IP}$ 中“`:`”之后的第 $1$ 个字符不为数字；
10. $\texttt{IP}$ 中“`:`”之后的第 $1$ 个字符为 $0$，且第 $2$ 个字符为数字；
11. $\texttt{IP}$ 包含除数字，“`.`”与“`:`”之外的字符；
12. $\texttt{IP}$ 中某个数字超出范围。

希望这篇题解对你有帮助！`_(:3」∠)_`

```cpp
#include <bits/stdc++.h>
using namespace std;

unordered_map<string, int> ha;

char op[9];

string ip;

inline bool valid(string &ip) {
	long long a = 0, b = 0, c = 0, d = 0, e = 0, len = ip.length(), c1 = 0, c2 = 0; // c1 表示“.”的个数，c2 表示“:”的个数 
	if (ip[0] < '0' || ip[0] > '9') {
		return false;
	}
	if (ip[0] == '0' && ip[1] >= '0' && ip[1] <= '9') {
		return false;
	}
	if (ip[len - 1] < '0' || ip[len - 1] > '9') {
		return false;
	}
	for (int i = 0; i < len; i++) {
		if (ip[i] >= '0' && ip[i] <= '9') {
			if (c1 < 3 && c2) {
				return false;
			}
			if (c1 == 0) {
				a *= 10;
				a += ip[i] - '0';
			} else if (c1 == 1) {
				b *= 10;
				b += ip[i] - '0';
			} else if (c1 == 2) {
				c *= 10;
				c += ip[i] - '0';
			} else if (c1 == 3) {
				if (c2 == 0) {
					d *= 10;
					d += ip[i] - '0';
				} else if (c2 == 1) {
					e *= 10;
					e += ip[i] - '0';
				} else {
					return false;
				}
			} else {
				return false;
			}
		} else if (ip[i] == '.') {
			c1++;
			if (ip[i + 1] < '0' || ip[i + 1] > '9') {
				return false;
			}
			if (i < len - 2 && ip[i + 1] == '0' && ip[i + 2] >= '0' && ip[i + 2] <= '9') {
				return false;
			}
		} else if (ip[i] == ':') {
			c2++;
			if (ip[i + 1] < '0' || ip[i + 1] > '9') {
				return false;
			}
			if (i < len - 2 && ip[i + 1] == '0' && ip[i + 2] >= '0' && ip[i + 2] <= '9') {
				return false;
			}
		} else {
			return false;
		}
	}
	return a >= 0 && a <= 255 && b >= 0 && b <= 255 && c >= 0 && c <= 255 && d >= 0 && d <= 255 && e >= 0 && e <= 65535 && c1 == 3 && c2 == 1;
}

int n;

int main() {
	freopen("network.in", "r", stdin);
	freopen("network.out", "w", stdout);
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%s", op);
		cin >> ip;
		if (!valid(ip)) {
			puts("ERR");
			continue;
		}
		if (op[0] == 'S') {
			if (!ha.count(ip)) {
				ha[ip] = i;
				puts("OK");
			} else {
				puts("FAIL");
			}
		} else {
			if (ha.count(ip)) {
				printf("%d\n", ha[ip]);
			} else {
				puts("FAIL");
			}
		}
	}
	return 0;
}
```

---

## 作者：言琢დ (赞：11)

小型模拟题。

感觉出题人挺良心，没有什么很大的坑点或者不注意就挂的地方。

这都写不对只能说明代码能力有待提升了。

首先观察可知，原题可以分为两个部分：

1. 检查一个地址是否合法；
2. 加入一个地址。

后者可以用 map 维护，是基础操作，所以关键点就落在了前者上。

首先是一波最基础的判断：

- `.` 出现 3 次，`:` 出现 1 次。
- 它们出现的顺序必须是 `.`、`.`、`.`、`:`。
- 没有别的什么奇怪字符（除 `0,1,2,3,4,5,6,7,8,9,:,.` 之外）。

然后再模仿我们的快速读入写法，读入的时候注意判断一下前导零就可以了。

注意到本题数据范围，有可能某些写法需要开 long long，但是统计答案的时候动态检验，不合理即退出，这样就不是很困难，也不需要开 long long。

详见代码实现部分吧。

```cpp
#include<map>
#include<cstdio>
#include<string>
#include<iostream>
const int N=(int)1e3+5;
std::map<std::string,int>map;
inline int in();
inline bool check(std::string);
int main(int argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("7911.in","r",stdin);
	freopen("7911.out","w",stdout);
#endif
	std::ios::sync_with_stdio(false);
	register int n=in();
	for(register int i=1;i<=n;++i){
		std::string op,ad;
		std::cin>>op>>ad;
		if(!check(ad))std::cout<<"ERR\n";
		else if(op[0]=='S'){
			if(map.count(ad))
				std::cout<<"FAIL\n";
			else{
				map[ad]=i;
				std::cout<<"OK\n";
			}
		}
		else{
			if(map.count(ad)){
				std::cout<<map[ad]<<std::endl;
			}
			else{
				std::cout<<"FAIL\n";
			}
		}
	}
}
inline bool check(std::string str){
	register int cnt1=0,cnt2=0;
	register int len=str.size();
	for(register int i=0;i<len;++i){
		if(str[i]=='.')
			++cnt1;
		if(str[i]==':')
			++cnt2;
		if(cnt2==1&&cnt1<3)return 0;
		// 冒号必须出现在点之后
		if((str[i]<'0'||str[i]>'9')&&(str[i]!='.')&&(str[i]!=':'))
			return 0;
		// 出现了我也不知道是啥的奇怪符号
	}
	if(cnt1!=3||cnt2!=1)return 0;
	int num[5]={-1,-1,-1,-1,-1};
	register int now=0;
	str[len]='.';
	for(register int i=0;i<len;++i){
		if(num[now]==-1&&(str[i]<'0'||str[i]>'9'))
			// 非数字
			return 0;
		else if(num[now]==-1&&(str[i]=='0'&&str[i+1]!='.'&&str[i+1]!=':'))
			return 0; // 前导 0
		else if(str[i]<'0'||str[i]>'9')
			// 一个断点
			++now;
		else if(num[now]==-1)
			num[now]=(str[i]&15);
		else
			num[now]=(num[now]<<1)+(num[now]<<3)+(str[i]&15);
			// 普通数字读入
		if(num[now]>65535)return 0;
	}
	register bool tp1=(0<=num[0]&&num[0]<=255);
	register bool tp2=(0<=num[1]&&num[1]<=255);
	register bool tp3=(0<=num[2]&&num[2]<=255);
	register bool tp4=(0<=num[3]&&num[3]<=255);
	register bool tp5=(0<=num[4]&&num[4]<=65535);
	return tp1&&tp2&&tp3&&tp4&&tp5;
}
inline int in(){
	register int x;
	std::cin>>x;
	return x;
}
```

---

## 作者：yimuhua (赞：7)

**思路：**

分成两个部分，判断合法和连接服务机（或建立连接）。

第二个部分可以通过 STL 里的 map 轻易实现：以地址字符串作为下标存储服务机编号即可。

第一个部分整体可以分为三个小部分：是否符合类似 $1 . 1 . 1 . 1:1$，里面的数是否符合范围，是否含有多余前导零。

**AC代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
map<string, int> h;
int f(int x) {  // 返回数字位数
    int c = 0;
    for(; x; x /= 10, c++);
    return c ? c : 1;
}
bool check(string s) {// 检验 ip 地址是否合法
    // 检验 ip 地址中的数字串是否合法以及分隔符是否为 "...:"
    string tmp;// 存储分隔符
    int x = 0, c = 0;// 数字串对应数值和位数
    for(int i = 0; i < s.size(); i++)// 检验数字串是否合法
        if(s[i] >= '0' && s[i] <= '9')// 更新数字串
            x = x * 10 + s[i] - '0', c++;
        else {
            if (!c || c > 3 || x > 255 || f(x) != c)// 位数、数值、前导 0 不合法
                return 0;
            tmp += s[i], x = c = 0;
        }
    return tmp == "...:" && c > 0 && c < 6 && x < 65536 && f(x) == c;// 检验分隔符和数字串是否合法
}
int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        string type, ip;
        cin >> type >> ip;
        if(!check(ip))// ip 地址不合法
            cout << "ERR" << endl;
        else if(type == "Server")
            if(h.find(ip) == h.end()) {// 不存在 ip 地址相同的服务器
                cout << "OK" << endl;
                h[ip] = i;
            }
            else// 存在 ip 地址相同的服务器
                cout << "FAIL" << endl;
        else {
            if(h.find(ip) == h.end())// 不存在 ip 地址相同的服务器
                cout << "FAIL" << endl;
            else// 存在 ip 地址相同的服务器
                cout << h[ip] << endl;
        }
    }
    return 0;
}
```


---

## 作者：JiaY19 (赞：7)

因该勉强算的上一道中型模拟，考场代码1.2KB多一点。

#### 大致思路 STL+模拟

用一个map维护一下前面有没有这个字符串，在来模拟判断这个字符串合不合法。

出题人十分良心，该有的情况大样例里基本都有。

在模拟这一环节，代码应该不算长，一个循环嵌套就可以了。

```cpp
for(int j = 1;j <= 5;j++ , x = 0)
{
    if(!isdigit(b[y])) { flag = 0; break; }
    //判断这一位是否有数字
    if(b[y] == '0' && (y + 1 < z && isdigit(b[y + 1]))) { flag = 0; break; }
    for(y;y < z && isdigit(b[y]);y++)
    {
        x = x * 10 + (int)(b[y] - '0');
        if(j <= 4 && x > 255) { flag = 0; break; }
        if(j == 5 && x > 65535) { flag = 0; break; }
    }
    //判断数字是否合法
    if(j < 4 && b[y] != '.')  { flag = 0; break; }
    if(j == 4 && b[y] != ':')  { flag = 0; break; }
    //判断符号是否合法
    if(j != 5) y++;
}
```

如果不合法，直接输出“ERR”就可以了

```cpp
if(flag == 0 || y != z)
{
    cout << "ERR" << endl;
    continue;
}
```

最后再分类讨论一下客户机和服务机就可以了。

```cpp
if(a[0] == 'S')
{
    if(q[b] == 0) q[b] = i , cout << "OK" << endl;
    else cout << "FAIL" << endl;
}
else
{
    if(q[b] != 0) cout << q[b] << endl;
    else cout << "FAIL" << endl;
}

```

#### Code

考场代码（码风较丑）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a , b;
map<string , int> q;

int read()
{
	int asd = 0 , qwe = 1; char zxc;
	while(!isdigit(zxc = getchar())) if(zxc = '-') qwe = -1;
	while(isdigit(zxc)) asd = asd * 10 + (zxc - '0') , zxc = getchar();
	return asd * qwe;
}

int main()
{
//	freopen("network.in" , "r" , stdin);
//	freopen("network.out" , "w" , stdout);
	n = read();
	for(int i = 1;i <= n;i++)
	{
		cin >> a >> b;
		int x = 0 , y = 0 , flag = 1 , z = b.length();
		for(int j = 1;j <= 5;j++ , x = 0)
		{
			if(!isdigit(b[y])) { flag = 0; break; }
			if(b[y] == '0' && (y + 1 < z && isdigit(b[y + 1]))) { flag = 0; break; }
			for(y;y < z && isdigit(b[y]);y++)
			{
				x = x * 10 + (int)(b[y] - '0');
				if(j <= 4 && x > 255) { flag = 0; break; }
				if(j == 5 && x > 65535) { flag = 0; break; }
			}
			if(j < 4 && b[y] != '.')  { flag = 0; break; }
			if(j == 4 && b[y] != ':')  { flag = 0; break; }
			if(j != 5) y++;
		}
		if(flag == 0 || y != z)
		{
			cout << "ERR" << endl;
			continue;
		}
		if(a[0] == 'S')
		{
			if(q[b] == 0) q[b] = i , cout << "OK" << endl;
			else cout << "FAIL" << endl;
		}
		else
		{
			if(q[b] != 0) cout << q[b] << endl;
			else cout << "FAIL" << endl;
		}
	}
	return 0;
}
```

---

## 作者：BYWYR (赞：6)

此题考察 map 及 string 的基本功

### 算法：

建一个字符串数组存答案（即每台计算机连接状态，代码内为 a），再建一个数组 sum 存连接成功客户机所对应的服务机编号，对于答案保存讲完了。

输入部分较为简单，我的变量名也与题目所述一致，就跳过。

然后讲服务机重复地址，和客户机连接的服务机编号。对于每个地址合法的服务机，我们用一个 map 存它的地址和编号，记为

```cpp
map<string,int>ss;
```

这样服务机重复地址的情况，看下地址对应的 map 是否为 0 就行了。至于客户机，若它地址合法，看下地址对应的 map 是否为 0，为 0 则连接失败，否则连接的服务机编号就是 ss 的第二个键值。

判断地址是否合法需要考虑的比较多，放下面说。

### 注意点：

~~就是这里写挂了QAQ~~

1. map 等清空。

1. 判断地址合法的一些细节：

	- 地址不得出现除题目规定外的字符。
    
   - 地址**必须要有 5 个数**（比如 ```10..9.7:2``` 就不行）
   
   - 地址必须含有 3 个 ```.``` 与 1 个 ```:```，且**顺序不能颠倒**。
   
   - 地址的 5 个数要符合题目规定的数据范围。
   
   - 地址的 5 个数不能含前导 0。

### Code :

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,sum[1005];
string a[1005];
map<string,int>ss;
signed main(){
    //freopen("network.in","r",stdin);
    //freopen("network.out","w",stdout);
    ss.clear();
    scanf("%lld",&n);
    for(int iu=1;iu<=n;iu++){
        a[iu].clear();
        char op[105],ad[105];
        int ans=0,w=0,_1=0,_2=0;
        string sk;//由于两个字符串空一格，所以不能直接把字符串输进去，就先用 ad 这个字符数组，再改成字符串。
        sk.clear();
        scanf("%s",op);
        scanf("%s",ad);
        int kf=0,knf=0;
        for(int i=0;i<strlen(ad);i++){
            if((i==0&&ad[i]>='0'&&ad[i]<='9')||(!(ad[i-1]>='0'&&ad[i-1]<='9')&&(ad[i]>='0'&&ad[i]<='9')))kf++;//记录数字个数。
            if(knf==1&&!(ad[i]>='0'&&ad[i]<='9')){
                kf=999;
                break;
            }//判断 4 个特殊符号是否按顺序排列。
            if(ad[i]==':')knf=1;
        }   
        if(kf!=5){
            a[iu]+='E';
            continue;           
        }
        for(int i=0;i<strlen(ad);i++){
            if(ad[i]=='.')_1++;
            if(ad[i]==':')_2++;
            if(ad[i]!='.'&&ad[i]!=':'&&!(ad[i]>='0'&&ad[i]<='9')){
                w=1;
            }//判断有无其他字符出现，及判断两种特殊字符出现次数。
            sk+=ad[i];
        }
        if(_1!=3||_2!=1||w==1){
            a[iu]+='E';
            continue;
        }
        for(int i=0;i<strlen(ad);i++){
            if(ad[i]=='.'||ad[i]==':'){
                if(ans>=0&&ans<=255){
                    ans=0;
                    continue;
                }
                else{
                    w=1;
                    break;
                }
            }//判断 a,b,c,d 是否在范围内。
            if(i==0||ad[i-1]=='.'||ad[i-1]==':'){
                if(ad[i]=='0'){
                    if(i==strlen(ad)-1||ad[i+1]=='.'||ad[i+1]==':'){
                        ans=0;
                        continue;
                    }
                    else{
                        w=1;
                        break;
                    }
                }
            }//判断前导 0.
            ans=ans*10+ad[i]-48;
        }
        if(ans<0||ans>65535||w==1){
            a[iu]+='E';
            continue;
        }//判断 e 是否在范围内。
        if(op[0]=='S'){
            if(ss[sk]>0){
                a[iu]+='F';
            }
            else{
                ss[sk]=iu;
                a[iu]+='O';
            }
        }//判断服务机连接情况。
        else{
            if(ss[sk]>0){
                sum[iu]=ss[sk];
            }
            else{
                a[iu]+='F';
            }
        }//判断客户机连接情况。
    }
    for(int i=1;i<=n;i++){
        if(sum[i]==0){
            if(a[i][0]=='E')printf("ERR");
            if(a[i][0]=='F')printf("FAIL");
            if(a[i][0]=='O')printf("OK");
        }
        else printf("%lld",sum[i]);
        printf("\n");
    }//输出结果。
    //fclose(stdin);
    //fclose(stdout);
    return 0;
}
```



---

## 作者：山田リョウ (赞：6)

题外话：今年题太简单了吧。。。我都能阿克。。。

Julian 出题人来 J 组了属于是【流汗黄豆.jpg】

大模拟，难点在于读入，读进来后用哈希和 map 维护都行，我用的 map。

考场代码（话说我是最后几分钟调完交上去的。。。）：
```cpp
#include<stdio.h>
#include<map>
#include<ctype.h>
FILE *in=fopen("network.in","r"),*out=fopen("network.out","w");
std::map<unsigned long long,int> MAP;
int n;char str[100];
int work(int k){
	fgetc(in),fscanf(in,"%s",str);
	int op=(str[0]=='C');
	fgetc(in),fscanf(in,"%s",str);
	int cnt=0;unsigned long long x=0;
	for(int j=0;;++j){
		if(!isdigit(str[j])){return 0;}
		if(str[j]=='0'){
			if(cnt==4){
				if(str[j+1]!='\0'){return 0;}
			}else if(cnt==3){
				if(str[j+1]!=':'){return 0;}
				++j;++cnt;x<<=8;continue;
			}else{
				if(str[j+1]!='.'){return 0;}
				++j;++cnt;x<<=8;continue;
			}
		}
		unsigned tmp=0;
		for(;isdigit(str[j]);++j){
			tmp=(tmp<<1)+(tmp<<3)+(str[j]^48);
			if((cnt==4&&tmp>65535)||(cnt<4&&tmp>255))return 0;
		}
		if((cnt==4&&str[j]!='\0')||(cnt==3&&str[j]!=':')||(cnt<3&&str[j]!='.'))return 0;
		x=(x<<(cnt>3?16:8))|tmp,++cnt;
		if(str[j]=='\0')break;
	}
	auto ptr=MAP.find(x);
	if(op){
		if(ptr==MAP.end())return 1;
		fprintf(out,"%d\n",ptr->second);
		return 2;
	}else{
		if(ptr!=MAP.end())return 1;
		fputs("OK\n",out);
		MAP.insert({x,k});
		return 2;
	}
}
int main(){
	fscanf(in,"%d",&n);
	for(int i=1;i<=n;++i)
		switch(work(i)){
			case 0:fputs("ERR\n",out);break;
			case 1:fputs("FAIL\n",out);break;
		}
	return 0;
}
```

---

## 作者：Rubidium_Chloride (赞：5)

不是，一年一道大模拟有意义吗。。。

J 写的最长的代码![](//啧.tk/tuu)

## 做法

大概就是，`map` 记录所有出现过的服务器地址，可以用 `hash` 压成一个 `ll`，然后大概就只有判合法的问题了。

主要分几个部分：

+ 数值有没有大于 $256/65536$；
+ `.` 或者 `:` 的个数有没有超过限制；
+ 末尾是不是数字；

之类的，主要就这些感觉会出错的地方。

判位数直接写个函数 `pop(ll x)` 就可以了，注意 $0$ 要占一位。

然后发现可能存不下极限情况下的一个数 $10^{25}-1$ 因此最好一旦超过了直接判掉。

## 代码

某些地方看起来写的比较繁琐。。。

```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read(){
	ll x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0',c=getchar();}
	return x*f;
}
ll n,a[19],l[19],r[19],tot,qwq,cnt1,cnt2,len,flag=1;
char s[100],ad[100];
ll pop(ll x){
	if(x==0) return 1;
	ll ans=0;
	while(x) ans++,x/=10;
	return ans;
}
void split(){
	cnt1=cnt2=0;
	memset(l,0,sizeof(l)),memset(r,0,sizeof(r)),memset(a,0,sizeof(a));
	for(int i=1;i<=len;i++){
		if(cnt1+cnt2>=5){flag=0;break;}
		if(cnt2==1&&cnt1<3){flag=0;break;}
		if(cnt1>3){flag=0;break;}
		if(cnt2>1){flag=0;break;}
		if(ad[i]=='.'){
			if(ad[i-1]=='.'||ad[i-1]==':'){flag=0;break;}
			r[cnt1+cnt2+1]=i-1;
			for(int j=l[cnt1+cnt2+1];j<i;j++){
				a[cnt1+cnt2+1]*=10,a[cnt1+cnt2+1]+=ad[j]-'0';
				if(a[cnt1+cnt2+1]>=256){flag=0;break;}
			}
			if(flag==0) break;
		    cnt1++;continue;
		}
		if(ad[i]==':'){
			if(ad[i-1]=='.'||ad[i-1]==':'){flag=0;break;}
			r[cnt1+cnt2+1]=i-1;
			for(int j=l[cnt1+cnt2+1];j<i;j++){
				a[cnt1+cnt2+1]*=10,a[cnt1+cnt2+1]+=ad[j]-'0';
				if(a[cnt1+cnt2+1]>=256ll){flag=0;break;}
			}
			if(flag==0) break;
			cnt2++;continue;
		}
		if(!l[cnt1+cnt2+1]) l[cnt1+cnt2+1]=i;
	}
	if(flag==0) return;
	if(cnt1+cnt2>=5){flag=0;return;}
	if(cnt1<3||cnt2<1){flag=0;return;}
	if(!isdigit(ad[len])){flag=0;return;}
	r[5]=len;
	for(int i=l[5];i<=len;i++){
		a[5]*=10,a[5]+=ad[i]-'0';
		if(a[5]>=65536ll){flag=0;break;}
	}
}
ll check(){
	flag=1;
	split();
	if(!flag) return 0;
	for(int i=1;i<=5;i++){
		if(pop(a[i])!=r[i]-l[i]+1){flag=0;break;}
	}
	return flag;
}
map<ll,ll> mp;
int main(){
	//freopen("network.in","r",stdin);
	//freopen("network.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		scanf("%s%s",s+1,ad+1);
		len=strlen(ad+1);
		if(s[1]=='S'){
			if(!check()) printf("ERR\n");
			else{
				qwq=0;
				qwq=4294967296ll*256ll*a[1]+16777216ll*256ll*a[2]+65536ll*256ll*a[3]+65536ll*a[4]+a[5];
				if(mp[qwq]) printf("FAIL\n");
				else mp[qwq]=i,printf("OK\n");
			}
		}
		else{
			if(!check()) printf("ERR\n");
			else{
				qwq=0;
				qwq=4294967296ll*256ll*a[1]+16777216ll*256ll*a[2]+65536ll*256ll*a[3]+65536ll*a[4]+a[5];
				if(mp[qwq]) printf("%lld\n",mp[qwq]);
				else printf("FAIL\n");
			}
		}
	}
	return 0;
}

```

---

## 作者：Harry_Hedwig (赞：4)

# 0x00 思路
~~妥妥的《阅 读 理 解》~~

这么长的题面真让人不爽。

来吧，让我们看一看，这令人不爽的题面。

>在本问题中，计算机分为两大类：服务机（`Server`）和客户机（`Client`）。

>需要进行网络连接的计算机共有 $n$ 台，编号为 $1 \sim n$，这些机器将按**编号递增**的顺序，**依次发起一条**建立连接或加入连接的操作。

>每台机器在尝试建立或加入连接时需要提供一个地址串。**服务机**提供的地址串表示它**尝试建立连接**的地址，**客户机**提供的地址串表示它**尝试加入连接**的地址。

>一个**符合规范**的地址串应当具有以下特征：

>1. **必须形如 `a.b.c.d:e` 的格式**，其中 $a, b, c, d, e$ 均为**非负整数**。
>1. $0 \le a, b, c, d \le 255$，$0 \le e \le 65535$。
>1. $a, b, c, d, e$ 均不能含有**多余的前导** $0$。

>在本问题中，我们假定凡是**符合上述规范**的地址串**均可参与**正常的连接……**如果有两台服务机使用相同的地址串**，**后一台**尝试建立连接的服务机将会**无法成功建立连接**……如果某台提供符合规范的地址的客户机在尝试加入连接时，与**先前**某台已经**成功建立连接的**服务机提供的**地址串相同**，这台客户机就可以成功加入连接，并称其连接到这台服务机；**如果找不到**这样的服务机，则认为这台客户机**无法成功加入连接**……**多台客户机使用同样的地址串的情况是被允许的**。

好了，这就是那~~又臭又长的~~题面了。

我们可以很明确的从题面中看到，这只是一个模拟而已。

# 0x01 行动
首先我们可以发现有服务机和客户机两种机型。但这两种机型都有一个共同的输出：`ERR`。所以我们可以优先解决这种情况。

## 0x010 ERR
首先我们可以发现这一种输出是由于输入字符串不合法而导致的错误。所以我们可以对输入的字符串进行检查。

那么我们可以用地址串的格式（`a.b.c.d:e`）进行检查。

1. 我们可以发现，在地址串的**最前面**是一个**数字**，那么如果在**第一个数字前**我们找到了 `.` 或 `:`，那么一定不合法。
2. 其次，只有 $3$ 个 `.`，$1$ 个`:`，$5$ 个数字。若找到 `.`、`:`、数字个数不为 $3$、$1$、$5$（~~315，好耶~~）,则也不合法。
3. 第三，每个数前没有前导 $0$。
4. 还有，$0 \le a, b, c, d \le 255$，$0 \le e \le 65535$。
5. 最后，`:` 要是在某个 `.` 前面出现了，同样不合法。

## code
```c
bool check(string ad)
{
	int len=ad.length(),i,point=0,mao=0,num=0,sum;
	for(i=0;i<len;i++)
	{
		sum=-1;
		while(ad[i]>='0'&&ad[i]<='9'&&i<=len)
		{
			if(ad[i]=='0'&&sum==-1&&ad[i+1]>='0'&&ad[i+1]<='9')//第3条
				return 0;
			if(sum==-1)
				sum=0;
			sum=(sum<<1)+(sum<<3)+(ad[i]^48);
			if(num<4&&sum>255)//第4条
				return 0;
			if(num==4&&sum>65535)//第4条
				return 0;
			i++;
		}
		if(sum!=-1)
			num++;
		if(num>5)//第2条
			return 0;
		if(ad[i]=='.')
			point++;
		if(ad[i]==':')
			mao++;
		if(point>3||mao>1)//第2条
			return 0;
		if(point<3&&mao>0)//第5条
			return 0;
		if((point>0||mao>0)&&num==0)//第1条
			return 0;
		if(ad[i]!='.'&&ad[i]!=':'&&ad[i]!=0)//若有其他物品一律不符合规范
			return 0;
	}
	if(point!=3||mao!=1||num!=5)//第2条
		return 0;
	return 1;
}
```

## 0x011 FAIL&OK（Server）
~~对于在考场上打出 `FATL` 的选手们致以沉重的默哀。~~

对于进行连接的服务机，我们可以将所有成功连接的服务机全部存入一个 `string` 数组中或存入 `map` 中，当又有一个服务机将要创建连接时进行遍历，查看是否有重复，若有重复则输出 `FAIL`,无重复输出 `OK`。

### code
```c
if(op[0]=='S')
		{
			for(j=0;j<tot;j++)
			{
				if(h[j]==ad)
				{
					puts("FAIL");
					break;
				}
			}
			if(j!=tot)
				continue;
			h[tot++]=ad;//记录
			Had[tot-1]=i;//为 Client 做准备
			puts("OK");
			continue;
		}
```
## 0x012 FAIL&编号（Client）
同样对于所有成功建立连接的服务器进行查找。若有相同输出编号，若无相同输出 `FAIL`。
### code
```c
if(op[0]=='C')
		{
			for(j=0;j<tot;j++)
			{
				if(h[j]==ad)
				{
					printf("%d\n",Had[j]);
					break;
				}
			}
			if(j!=tot)
				continue;
			puts("FAIL");
		}
```
# code
代码已经零星给出，这里就不再重给。

~~完结撒花!!~~ <(￣ˇ￣)/

---

## 作者：Zirnc (赞：3)

我爱大模拟！

其实这道题就是细心一点就能过，考场上给的大样例非常友好，我就是靠它一个一个找出错误然后修改的...最后没想到满分了

一些关键点：

- 除了数字、`.` 和 `:` 以外的字符
- `.` 和 `:` 的出现顺序和次数
- 数字的数量
- 数字有没有前导零
- 数字有没有越界
- ......

解决方案：

- 遍历一遍判断
- 用两个变量记录出现次数，用一个大小为 3 的数组记录每个 `.` 出现的位置
- 。。。
- 代码中 `checkPrevZero()`
- 还没将字符串转成数字前可以先判断这段数字长度是否大于 3 或 5，转化成数字之后再细化判断是否大于 255 或 65535，可以在整个过程中避免使用 long long 防止爆炸（这个坑似乎也是大样例告诉我的）。

可以使用一些字符串库函数来简化代码。

下面奉上原汁原味的考场代码，具体注释都在里面：


```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
// 判断前导零
bool checkPrevZero(const string number) {
	// 单独一个 0 是不算非法的。
	if (number.length() > 1 && number[0] == '0') return true;
	return false;
}
// string 转 int
int strToInt(const string number) {
	int t = 0;
	for (int i = 0; i < number.length(); i++) {
		t *= 10;
		t += number[i]-'0';
	}
	return t;
}
bool check(const string addr) {
	int cntDot = 0, cntMao = 0; // 点的出现次数和冒号的出现次数
	int dotIdx[3], maoIdx;	// 点出现的位置和冒号出现的位置
	if (!(addr[0] >= '0' && addr[0] <= '9') || !(addr[addr.length()-1] >= '0' && addr[addr.length()-1] <= '9')) return false;
	for (int i = 0; i < addr.length(); i++) {
		if (addr[i] == '.') {
			if (cntDot > 2) return false;  // 多于三个点
			if (!(addr[i-1] >= '0' && addr[i-1] <= '9')) return false;
			cntDot++;
			dotIdx[cntDot-1] = i;
		} else if (addr[i] == ':') {
			if (cntMao > 1) return false; // 多于一个冒号
			if (!(addr[i-1] >= '0' && addr[i-1] <= '9')) return false;
			cntMao++;
			maoIdx = i;
		} else if (!(addr[i] >= '0' && addr[i] <= '9')) { // 啥也不是
			return false;
		}
	}
	if (!(cntDot == 3 && cntMao == 1)) return false; // 检查点和冒号的数量
	if (maoIdx < dotIdx[2]) return false; // 如果冒号的位置在某一个点前面
   // 分离出五个数字
	string n1 = addr.substr(0, dotIdx[0]),
	       n2 = addr.substr(dotIdx[0]+1, dotIdx[1]-dotIdx[0]-1),
	       n3 = addr.substr(dotIdx[1]+1, dotIdx[2]-dotIdx[1]-1),
		   n4 = addr.substr(dotIdx[2]+1, maoIdx-dotIdx[2]-1),
		   n5 = addr.substr(maoIdx+1, addr.length()-maoIdx-1);
	
	if (checkPrevZero(n1) || checkPrevZero(n2) || checkPrevZero(n3) || checkPrevZero(n4) || checkPrevZero(n5)) return false; // 判断前导零
	if (n1.length() > 3 || n2.length() > 3 || n3.length() > 3 || n4.length() > 3 || n5.length() > 5) return false;  // 判断越界
	int a = strToInt(n1), b = strToInt(n2), c = strToInt(n3), d = strToInt(n4), e = strToInt(n5);
	if (a > 255 || b > 255 || c > 255 || d > 255 || e > 65535) return false;  // 判断越界
	return true;
}
int serversNum = 0;
map<string, int> servers;
int main()
{
	cin >> n;
	string op, ad;
	for (int i = 0; i < n; i++) {
		cin >> op >> ad;
		if (!check(ad)) {
			cout << "ERR\n";
			continue;
		}
		if (op == "Server") {
			if (servers[ad] != 0) {
				cout << "FAIL\n";
				continue;
			}
			servers[ad] = i+1;
			cout << "OK\n";
		} else if (op == "Client") {
			if (servers[ad] == 0) {
				cout << "FAIL\n";
				continue;
			}
			cout << servers[ad] << endl;
		}
	}
	return 0;
}
```

---

## 作者：mcDinic (赞：3)

[更好的阅读效果](https://www.luogu.com.cn/blog/484076/solution-p7911)

~~当作纪念本人的首次 CSP 之旅,发篇题解．~~

~~考场上由于不会 fc,死得很惨,才 75 分,吸取教训重打后,终于 AC 了.~~

这是一道小模拟,考验 map 及 string 的基本功(或许有其他做法,我介绍的仅是自己的思路)．

# 进入正文

## 大致方法：

建一个字符串数组存答案（即每台计算机连接状态，我用的变量名是 yjy，下面为了方便，将直接写成 yjy），再建一个数组 sum 存连接成功客户机所对应的服务机编号，对于答案保存讲完了。

输入部分较为简单，我的变量名也与题目所述一致，就跳过。

然后讲服务机重复地址，和客户机连接的服务机编号。对于每个地址合法的服务机，我们用一个 map 存它的地址和编号，记为 

```cpp
map<string,int>ss;

```

这样服务机重复地址的情况，看下地址对应的 map 是否为 0 就行了。至于客户机，若它地址合法，看下地址对应的 map 是否为 0，为 0 则连接失败，否则连接的服务机编号就是 ss 的第二个键值。

判断地址是否合法需要考虑的比较多，放下面说。

**总体步骤：**

1. 开数组，变量。

2. 输入。

3. 判断地址是否合法。（重要）

4. 判断服务机和客户机的各种情况。（较重要）

5. 记录答案。

6. 输出。

## 注意点：

1. map 等清空。

2. （非常重要）判断地址合法的一些细节：

    - 地址不得出现除题目规定外的字符。
    
    - 地址**必须要有 5 个数**（比如 ```12..2.6:9``` 就不行）。
    
    - 地址必须含有 3 个 “.” 与 1 个 “:”，且**顺序不能颠倒**。
    
    - 地址的 5 个数要符合题目规定的数据范围。
    
    - 地址的 5 个数不能含前导 0。
    
## Code：

前面讲的很明确，主要变量名也说了，这里稍微写少一点。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,sum[1005];
string yjy[1005];
map<string,int>ss;
signed main(){
	//freopen("network.in","r",stdin);
	//freopen("network.out","w",stdout);
	ss.clear();
	scanf("%lld",&n);
	for(int iu=1;iu<=n;iu++){
		yjy[iu].clear();
		char op[105],ad[105];
		int ans=0,w=0,_1=0,_2=0;
		string sk;//由于两个字符串空一格，所以不能直接把字符串输进去，就先用 ad 这个字符数组，再改成字符串。
		sk.clear();
		scanf("%s",op);
		scanf("%s",ad);
		int kf=0,knf=0;
		for(int i=0;i<strlen(ad);i++){
		    if((i==0&&ad[i]>='0'&&ad[i]<='9')||(!(ad[i-1]>='0'&&ad[i-1]<='9')&&(ad[i]>='0'&&ad[i]<='9')))kf++;//记录数字个数。
		    if(knf==1&&!(ad[i]>='0'&&ad[i]<='9')){
		        kf=999;
		        break;
		    }//判断 4 个特殊符号是否按顺序排列。
		    if(ad[i]==':')knf=1;
		}	
		if(kf!=5){
			yjy[iu]+='E';
			continue;		    
		}
		for(int i=0;i<strlen(ad);i++){
			if(ad[i]=='.')_1++;
			if(ad[i]==':')_2++;
			if(ad[i]!='.'&&ad[i]!=':'&&!(ad[i]>='0'&&ad[i]<='9')){
				w=1;
			}//判断有无其他字符出现，及判断两种特殊字符出现次数。
			sk+=ad[i];
		}
		if(_1!=3||_2!=1||w==1){
			yjy[iu]+='E';
			continue;
		}
		for(int i=0;i<strlen(ad);i++){
			if(ad[i]=='.'||ad[i]==':'){
				if(ans>=0&&ans<=255){
					ans=0;
					continue;
				}
				else{
					w=1;
					break;
				}
			}//判断 a,b,c,d 是否在范围内。
			if(i==0||ad[i-1]=='.'||ad[i-1]==':'){
				if(ad[i]=='0'){
					if(i==strlen(ad)-1||ad[i+1]=='.'||ad[i+1]==':'){
						ans=0;
						continue;
					}
					else{
						w=1;
						break;
					}
				}
			}//判断前导 0.
			ans=ans*10+ad[i]-48;
		}
		if(ans<0||ans>65535||w==1){
			yjy[iu]+='E';
			continue;
		}//判断 e 是否在范围内。
		if(op[0]=='S'){
			if(ss[sk]>0){
				yjy[iu]+='F';
			}
			else{
				ss[sk]=iu;
				yjy[iu]+='O';
			}
		}//判断服务机连接情况。
		else{
			if(ss[sk]>0){
				sum[iu]=ss[sk];
			}
			else{
				yjy[iu]+='F';
			}
		}//判断客户机连接情况。
	}
	for(int i=1;i<=n;i++){
		if(sum[i]==0){
			if(yjy[i][0]=='E')printf("ERR");
			if(yjy[i][0]=='F')printf("FAIL");
			if(yjy[i][0]=='O')printf("OK");
		}
		else printf("%lld",sum[i]);
		printf("\n");
	}//输出结果。
	//fclose(stdin);
	//fclose(stdout);
	return 0;
}
```
# 最后的最后，祝大家 CSP 2021 rp++！

---

## 作者：Eason_AC (赞：3)

## Content
题目过于难解释，请前往题面查看。以下直接给出本题做法。
## Solution
入门组 T3 在我印象中向来都不是很容易能做出来的题目，但是今年这个 T3 不得不说还是挺好做的。

我们先不妨令它给出的地址串是合法的，也就是测试点 $1\sim 11$ 的特殊性质，我们直接用个 map 来存储每个地址串是否已有服务器建立连接，即可解决判断地址串是否已经在前面有服务机建立连接的这个问题，同时对于客户机，这也同样可以判断是否有建立连接的服务机供其连接。

这样，判断给出的地址串是否合法就变成了我们接下来要重点解决的问题。

我们回到题面看看不合法的字符串可能是什么样的：

> 不是形如 `a.b.c.d:e` 格式的字符串，例如含有多于 $3$ 个字符 `.` 或多于 $1$ 个字符 `:` 等情况。

> 整数 $a,b,c,d,e$ 中某一个或多个超出上述范围（即 $0\leqslant a,b,c,d\leqslant 255$，$0\leqslant e\leqslant 65535$）；

> 整数 $a,b,c,d,e$ 中某一个或多个含有多余的前导 $0$。

我们根据每个特点将其转化成代码语言。

首先对于不是形如 `a.b.c.d;e` 格式的地址串，我们直接扫一遍判断其是否恰好有 $3$ 个 `.` 和 $1$ 个 `.` 即可。同时，我们将第一个 `.` 前面的部分、第一个 `.` 和第二个 `.` 之间的部分、第二个 `.` 和第三个 `.` 之间的部分、第三个 `.` 和 `:` 之间的部分、`:` 后面的部分分别提取出来，将字符串的这五个部分分别记作 $s_1,s_2,s_3,s_4,s_5$。

之后，对于每个 $s_i$，我们首先看 $s_i$ 的首字符是否是 `0`，然后再去将其转化成数字。在**转换的过程**中我们需要判断数字是否超出了范围，一旦超出了范围就直接判定其不合法即可。注意，这里之所以在转换的过程中就判断其是否超出范围是因为，如果直接全部转换完再判断，容易超出数据类型范围从而使最终的转换结果不准确。~~当然地址串的长度不超过 $\sout{25}$，所以直接用 `__int128` 是可以保证不爆炸的，但是~~这里显然不必要用这么大的数据类型去判断一个很小的数字，用上述方法即可仅使用普通的 `int` 解决是否超出范围的问题而不超出其本身数据类型范围。

这样，判断一个地址串是否合法的过程就全部讲完了。接下来把上面这些部分用代码实现即可。
## Code
```cpp
namespace Solution {
	const int N = 1007;
	int n;
	struct node {string op, ip;}a[N];
	map<string, int> id;
	
	ib chk(string s) {
		int num = 0, fl = 0, sze = s.size(), p[27] = {0};
		string nums[7] = {""};
		s = " " + s;
		F(int, i, 1, sze) {
			if(s[i] == '.') {
				p[++num] = i;
				if(num > 3) return 0;
			} else if(s[i] == ':') {
				if(!fl) fl = i;
				else return 0;
			}
		}
		if(num < 3 || !fl) return 0;
		p[++num] = fl, p[++num] = sze;
		F(int, i, 1, num) {
			F(int, j, p[i - 1] + 1, p[i] - (i != num)) nums[i] += s[j];
			if((nums[i].size() != 1 && nums[i][0] == '0') || nums[i] == "") return 0;
			ll x = 0;
			F(int, j, 0, (int)nums[i].size() - 1) {
				x = x * 10 + nums[i][j] - '0';
				if(x > (i == num ? 65535 : 255)) return 0;
			}
		}
		return 1;
	}
	
	iv Main() {
		read(n);
		F(int, i, 1, n) {
			cin >> a[i].op >> a[i].ip;
			if(a[i].op == "Server") {
				if(!chk(a[i].ip)) puts("ERR");
				else if(id[a[i].ip]) puts("FAIL");
				else puts("OK"), id[a[i].ip] = i;
			} else {
				if(!chk(a[i].ip)) puts("ERR");
				else if(!id[a[i].ip]) puts("FAIL");
				else println(id[a[i].ip]);
			}
		}
		return;
	}
}
```

---

## 作者：qwq___qaq (赞：3)

本题太水，至少本人认为今年的题没有按难度排序。首先我们输入网址的时候可以使用字符串存储,此处重点提出一下判断 `ERR` 的方法：
- 首先，判断是否有两个相邻的非数字的字符，例如 `1..1.1:1`。
- 其次，我们判断字符的数量是否符合题意，例如 `1.1.1:1:1`。
- 然后，我们判断一下冒号是否在点号的后面，例如 `1.1:1.1.1`
- 紧接着，我们就可以判断前导零的存在，判断方法：若后面是数字且前面不是数字，就有前导零，例如 `1.01.1.1:1`。但要注意单独的一个零，即 `1.0.0.0:1`。
- 最后还有就是判断网址的数字是否超出限制，用数组存下来即可，例如 `1.212121.1.1:0`。

*****
最后，用 `map` 维护一下那些符合要求的网址是否出现过，然后按题意输出即可。
### AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int> vis;//当前网址是否出现
inline bool check(char s){
	return s>='0'&&s<='9';
}
int main(){
	int n;
	scanf("%d",&n);
	for(int j=1;j<=n;j++){
		string s,s1;
		int cnt=0,sum=0,a[5]={},k=0;
		bool t=0;
		cin>>s>>s1;
		for(int i=0,l=s1.length();i<l;i++){
			if(!check(s1[i])&&i<l-1&&!check(s1[i+1])){
				t=1;
				break;
			}
			if(s1[i]=='.')
				cnt++,k++;
			else if(s1[i]==':'){
				sum++,k++;
				if(cnt<3){
					t=1;
					break;
				}
			} else if(s1[i]<'0'||s1[i]>'9')
				t=1;
			else{
				if(s1[i]=='0'){
					if((check(s1[i-1]))||(!check(s1[i-1])&&!check(s1[i+1])))
						a[k]*=10;
					else{
						t=1;
						break;
					}
				} else
					a[k]=a[k]*10+s1[i]-'0';
			}
			if(k>4||cnt>3||sum>1||t||(k!=4&&a[k]>255)||a[k]>65535){
				t=1;
				break;
			}
		}
		if(t||k<4){
			puts("ERR");
			continue;
		}//判断网址是否错误
		if(s[0]=='S'){
			if(vis[s1])
				puts("FAIL");
			else{
				vis[s1]=j;
				puts("OK");
			}
		} else{
			if(vis[s1])
				printf("%d\n",vis[s1]);
			else
				puts("FAIL");
		}
	}
	return 0;
}
```

---

## 作者：XYY1411 (赞：2)

# 网络连接

提交地址：[洛谷 Luogu7911](https://www.luogu.com.cn/problem/P7911)

## 题目大意

给出 $n$ 台计算机，有服务机（`Server`）和客户机（`Client`）。

每台服务机挂载一个 IPv4 地址（带端口），每台客户机链接一个服务机（通过 IPv4 地址）。

如果 IP 非法输出 `ERR`，如果服务机要挂载的 IP 被占用或客户机要链接的 IP 不是合法的服务机输出 `FAIL`，如果服务机成功挂载输出 `OK`，如果客户机成功链接输出连接到的服务机编号。

## 分析

没打 J 组，写题解原因是看到这篇博客（博客已经没了），然后发现原来 C++11 就有正则表达式了~~所以就写了~~。

已经有一篇正则表达式的题解了，不过不是纯正则判断合法的，这篇讲一下如何纯正则判断合法性。

于是可以使用正则表达式来判断 IP 是否合法，用哈希映射表匹配计算机。

### 正则表达式

正则表达式是一种用途很广泛的工具。

更具体正则表达式相关自行谷歌，附维基链接：[正则表达式](https://zh.wikipedia.org/zh-cn/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)。

这里只介绍这道题用到的。

正则表达式可以通过一个模式串匹配文本串判断文本串是否符合要求。

`[0-9]` 可以匹配一个 $0 \sim 9$ 的单个数字，那么 `25[0-5]` 则可以匹配 $250 \sim 255$，匹配 `.` 时是需要使用 `\` 转义的（`.` 表示匹配除 `\r`、`\n` 外的任何单个字符），而 `\` 又是 C++ 中的转义字符，所以匹配 `.` 需要 `\\.` 才行，`:` 也需要转义。

如果想要两个匹配中的一个呢？

用 `|` 即可，如 `a|b` 表示匹配 `a` 或者 `b`。

但是注意 `a|bcd` 匹配的是 `a` 或者 `bcd`，那么怎么匹配 `acd` 或 `bcd` 呢？

加括号！用 `(a|b)cd` 就行了。

如果想匹配置顶重复次数的某个串呢？

用 `(<pattern>){<times>}` 即可，其中 `()` 将括号内作为一个整体匹配，`{}` 表示前一个字母或整体的匹配次数，那么这个模式串表示匹配 $times$ 次 $pattern$ 串。

匹配一次或两次？用 `?`。任意次？用 `*`。

综上，IPv4 地址的模式串就是：

```
(((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])
```

那么怎么在 C++ 中使用？

首先 C++ 标准至少为 C++11.

先包含 `<regex>` 头文件。

使用 `std::regex` 定义一个模式串，如：

```cpp
const std::regex pat("C\\+\\+((98)|(11)|(14)|(17)|(20))"); // + 也需要转义，这里不讲了
```

然后使用 `std::regex_match()` 来匹配，接受两个参数，第一个是文本串，第二个是模式串，如：

```cpp
std::regex_match("C++11", pat);
```

返回值为布尔类型，表示是否匹配成功。

刚才函数返回值应为 `true`。

### 匹配计算机

先判断 IP 是否合法，不合法直接输出 `ERR` 然后下一个。

然后判断计算机类型。

对于服务机，用哈希映射表查找 IP 是否被占用，有，输出 `FAIL` 然后下一个，没有，映射表的值附为编号，输出 `OK`。

对于客户机，用哈希映射表查找 IP 是否是合法服务机（及是否有编号），是，输出编号，否，输出 `FAIL`。

结束。

## $\rm \color{green}code$

### C++

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <regex>
using namespace std;
int n;
unordered_map<string, int> mp;
inline bool check(const string &ip) {
    static const regex ippt("(((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])");
    return regex_match(ip, ippt);
}

int main() {
    ios::sync_with_stdio(false);
    mp["Server"] = 0, mp["Client"] = 1;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        static string op, ip;
        static int typ;
        auto it = mp.end();
        cin >> op >> ip;
        if (check(ip)) {
            typ = mp[op];
            if (typ == 0) {
                it = mp.find(ip);
                if (it == mp.end()) {
                    mp[ip] = i;
                    cout <<"OK\n";
                } else {
                    cout << "FAIL\n";
                }
            } else if (typ == 1) {
                it = mp.find(ip);
                if (it == mp.end()) {
                    cout << "FAIL\n";
                } else {
                    cout << it->second << '\n';
                }
            }
        } else {
            cout << "ERR\n";
        }
    }
    return 0;
}
```

### Python

```python
import re
pat = re.compile(r"^(((((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])))$")
def check(ip):
    return not(re.match(pat, ip) == None)
s = input()
n = int(s)
mp = {"" : 0}
for i in range(n):
    s = input().split()
    op = s[0]
    ip = s[1]
    # print(re.match(pat, ip))
    if check(ip):
        if op == "Server":
            try:
                mp[ip]
            except KeyError:
                mp[ip] = i + 1
                print("OK")
            else:
                print("FAIL")
        elif op == "Client":
            flag = True
            try:
                mp[ip]
            except KeyError:
                flag = False
                print("FAIL")
            else:
                print(mp[ip])
    else:
        print("ERR")
```

---

## 作者：5ab_juruo (赞：2)

火速来一发正则表达式的题解。

regex yyds！

----

首先，你需要知道有个东西叫正则表达式。一句话就是匹配字符串的格式。

首先，我们要匹配三位整数，有两种情况：

- 0；
- 首位非零，后面为任意数字。

正则中使用 `[0-9]` 表示 0 到 9 的任意字符，而 `{0,2}` 代表出现 0 次到两次中的任意一个，所以两个规则分别就是：

- `0`；
- `[1-9][0-9]{0,2}`。

而我们可以使用 `(A|B)` 代表 `A` 或 `B`，所以对于每一位，正则表达式就是 `(0|[1-9][0-9]{0,2})`。

然后我们在中间要加上点，但 `.` 是正则关键字符（表示匹配所有字符），需要在前面加上反斜杠转义，又因为 C/C++ 的特性，所以要加两个反斜杠。

同时，正则表达式只要找到满足条件的子串就认为是合法的，所以要加上特殊定位符：`^` 代表字符串开头，（美元符号）代表字符串结尾。所以最终的正则表达式就是（将人民币符号变成美元符号）：

```
^(0|[1-9][0-9]{0,2})\.(0|[1-9][0-9]{0,2})\.(0|[1-9][0-9]{0,2})\.(0|[1-9][0-9]{0,2}):(0|[1-9][0-9]{0,4})￥
```

然后用 `regex_match` 判断一下基本格式，`sscanf` 读出每个数并判断边界，然后用 `map` 存一下就做完了。

```cpp
#include <regex> // 正则表达式的头文件
#include <cstdio>
#include <map>
using namespace std;
typedef long long ll;

const ll u[] = {1099511627776ll, 4294967296ll, 16777216, 65536, 1};

char s[30], ty[10];
map<ll, int> mp;

inline bool ir(int x, int lim = 255) { return x >= 0 && x <= lim; }

int main()
{
	
	regex pat("^(0|[1-9][0-9]{0,2})\\.(0|[1-9][0-9]{0,2})\\.(0|[1-9][0-9]{0,2})\\.(0|[1-9][0-9]{0,2}):(0|[1-9][0-9]{0,4})$");
	int n, a, b, c, d, e;
	ll qid;
	
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		scanf("%s%s", ty, s);
		if (!regex_match(s, pat))
		{
			puts("ERR");
			continue;
		}
		sscanf(s, "%d.%d.%d.%d:%d", &a, &b, &c, &d, &e);
		if (ir(a) && ir(b) && ir(c) && ir(d) && ir(e, 65535))
		{
			qid = a*u[0] + b*u[1] + c*u[2] + d*u[3] + e;
			if (mp.find(qid) != mp.end())
			{
				if (ty[0] == 'C')
					printf("%d\n", mp[qid]);
				else
					puts("FAIL");
			}
			else
			{
				if (ty[0] == 'C')
					puts("FAIL");
				else
					mp[qid] = i + 1, puts("OK");
			}
		}
		else
			puts("ERR");
	}
	return 0;
}
```

---

## 作者：无钩七不改名 (赞：1)

## 字典树

翻遍题解发现没有和我同一种做法的。

首先暴力判断字符串是否合法。

如果合法，在字典树里面搜索。

如果为服务机：

搜不到就新建一台服务机：在 $d$ 点所在的字典树的点的动态数组后面添加个二元变量 ${e,num}$（其中 $num$ 指机子的编号）。

搜得到就是重复，输出 ``FAIL``。

如果为服务机：

如果不能搜到 $d$，就是没有。否则暴力搜索 $d$ 点所在的字典树的点的动态数组，不能搜到 $c$ 就是没有，否则就是有。

具体的看代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std; 

int n;
long long a[5];
int b[4005][260],cnt,ans;
vector<pair<int,int> > c[4005];

bool find(){
	bool qwq=0,qaq=1;
	int x=0;
	for(int i(0);i<4;i++){
		if(b[x][a[i]]==0){
			b[x][a[i]]=++cnt;
			qwq=1;
		}
		x=b[x][a[i]];
	}
	for(pair<int,int> v:c[x])
		if(v.first==a[4]){
			qaq=0;
			break;
		}
	if(qaq)c[x].push_back(make_pair(a[4],ans));
	if(qwq||qaq)return 1;
	return 0;
} 
void findx(){
	bool qwq=0,qaq=1;
	int x=0;
	for(int i(0);i<4;i++){
		if(b[x][a[i]]==0){
			puts("FAIL");
			return;
		}
		x=b[x][a[i]];
	}
	for(pair<int,int> v:c[x])
		if(v.first==a[4]){
			//v.second;
			printf("%d\n",v.second);
			return;
		}
	puts("FAIL");
	return;
} 

int main(){
	scanf("%d",&n);
	while(n--){
		ans++;
		char op[8],ad[30];
		scanf(" %s %s",op,ad);
		memset(a,0,sizeof(a));
		int len=strlen(ad),dian=0;
		bool qm=1,maohao=0,tc=0;
		for(int i(0);i<len;i++){
			if(ad[i]>'9'&&ad[i]<'0'&&ad[i]!='.'&&ad[i]!=':'){
				puts("ERR");tc=1;
				break;
			}
			if(ad[i]==':'){
				if(qm||dian<3||maohao){
					puts("ERR");tc=1;
					break;
				}
				maohao=1;qm=1;
				continue;
			}
			if(ad[i]=='.'){
				if(qm||dian>=3||maohao){
					puts("ERR");tc=1;
					break;
				}
				dian++;qm=1;
				continue;
			}
			if(i)if(ad[i-1]=='0'&&a[dian+maohao]==0){
				//cout<<ad[i-1]<<" "<<i<<endl;
				puts("ERR");tc=1;
				break;
			}
			qm=0;
			a[dian+maohao]=a[dian+maohao]*10+(ad[i]-'0');
			if((!maohao&&a[dian+maohao]>255)||(maohao&&a[dian+maohao]>65535)){
				//cout<<dian+maohao<<" "<<a[dian+maohao]<<"***"<<endl;
				puts("ERR");tc=1;
				break;
			}
			continue;
		}
		if(tc)continue;
		if(dian<3||ad[len-1]==':'||ad[len-1]=='.'||maohao==0){
			puts("ERR");
			continue;
		}
		
		if(op[0]=='S'){
			if(find())puts("OK");
			else puts("FAIL");
		}
		else findx();
	}
	return 0;
}
```


---

## 作者：StayAlone (赞：1)

Pj 考这么简单的大膜你也真是太良心了。规则也不复杂，和[时间复杂度](https://www.luogu.com.cn/problem/P3952)完全不能比。。。  

判断 `ERR` 的情况之后用 `map<string, int>` 来存某个 `Server` 的 IP 号即可。时间复杂度 $O(n\log n)$，有一定常数。重点放在判 `ERR` 上。

我的方案是分别判每一段。“段”的定义是被符号分隔开的位置。这里放一段核心代码，方便解释。  

```cpp
il int nlen(int k)
{
	if (!k) return 1;
	int cnt = 0;
	while (k) cnt++, k /= 10;
	return cnt;
}

il bool gnoc(const string s, int &a, int lst, int &idx, const char op)
{
	int len = s.size();
	while (isdigit(s[idx]))
	{
		if (idx >= len) return false;
		a = (a << 1) + (a << 3) + (s[idx++] & 15);
		if (a > 255) return false;
	}
	if (idx + 1 >= len || s[idx] != op) return false;
	if (nlen(a)^(idx - 1 - lst + 1)) return false;
	return true;
}
```  
`nlen(k)` 将返回一个数的位数。注意特判 `0` 的情况。`gnoc` 表示串 `s` 从 `lst` 到 `idx` 这一段的数的值是否符合要求、这一段后面的那一个符号是否与 `op` 相同。细节是如果这个数的实际位数与这一段本来的位数不同，表示有前导零，不合要求；如果在运算的过程中，超出了 225，就不合要求。如果把字符串的长度范围开大，只能这样避免。当然，开 `long long` 也可以避免这个问题，因为题目限制了字符串长度小于等于 25，否则除了这样做没有其他方法。  

最后按照这个思路乱搞就行了。   

[AC code 记录](https://www.luogu.com.cn/record/61562875)

```cpp
#include <bits/stdc++.h>
#define ......
#typedef ....... // 一些很长的缺省源
template <typename T>
il void read(T &x) // 快读

template <typename T>
il void write(T x) // 快输

il int nlen(int k)
{
	if (!k) return 1;
	int cnt = 0;
	while (k) cnt++, k /= 10;
	return cnt;
}

il bool gnoc(const string s, int &a, int lst, int &idx, const char op)
{
	int len = s.size();
	while (isdigit(s[idx]))
	{
		if (idx >= len) return false;
		a = (a << 1) + (a << 3) + (s[idx++] & 15);
		if (a > 255) return false;
	}
	if (idx + 1 >= len || s[idx] != op) return false;
	if (nlen(a)^(idx - 1 - lst + 1)) return false;
	return true;
}

il bool ins(int k, int r)
{
	return k >= 0 && k <= r;
}

il bool cper(const string s, int &a, int &b, int &c, int &d, int &e)
{
	int idx = 0, len = s.size();
	if (!isdigit(s[0]) || len < 9) return false;
	int lst = 0;
	if (!gnoc(s, a, lst, idx, '.')) return false;
	lst = ++idx;
	if (!gnoc(s, b, lst, idx, '.')) return false;
	lst = ++idx;
	if (!gnoc(s, c, lst, idx, '.')) return false;
	lst = ++idx;
	if (!gnoc(s, d, lst, idx, ':')) return false;
	lst = ++idx;
	rep1(p, lst, len - 1)
	{
		if (!isdigit(s[p])) return false;
		e = (e << 1) + (e << 3) + (s[p] & 15);
		if (e > 65535) return false;
	}
	if (nlen(e)^(len - 1 - lst + 1)) return false;
	if (!ins(a, 255) || !ins(b, 255) || !ins(c, 255) || !ins(d, 255) || !ins(e, 65535)) return false;
	return true;
} // 这一段的实现略显恶臭，是因为考场怕错。。。
int n, a, b, c, d, e;
string op, ad;
map <string, int>slk;

int main()
{
	read(n);
	rep1(i, 1, n)
	{
		cin >> op >> ad;
		a = b = c = d = e = 0;
		if (!cper(ad, a, b, c, d, e)) puts("ERR");
		else if (op == "Server")
		{
			if (slk.count(ad)) puts("FAIL");
			else slk[ad] = i, puts("OK");
		}
		else
		{
			if (slk.count(ad)) write(slk[ad]), ptc('\n');
			else puts("FAIL");
		}
	}
	return 0;
}
```

---


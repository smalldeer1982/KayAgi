# 「Stoi2033」分裂

## 题目背景

> 趁时间没发觉 让我带着你离开  
> 没有了证明 没有了空虚  
> 基于两种立场我会罩着你  
> 趁时间没发觉 让我带着你离开  
> 这不是顽固 这不是逃避  
> 没人绑着你走才快乐  
> ——《分裂》

## 题目描述

有一个 $n \times m \times 2$ 的棋盒（四周为棋盒壁）与黑、红各 $nm$ 颗棋。棋子有若干种类，红色的一种棋子个数和黑色的该种棋子个数相等。棋子种类用特征值 $v_{i,j}$ 标记。特征值相同的棋子种类相同，特征值不同的棋子种类不同。红色棋子摆放在棋盒的下层，已经摆好。现在 Vinsta 要将黑棋按照规定顺序摆放在棋盒上层。设棋盒内坐标以左上角为 $(1,1)$，右下角为 $(n,m)$，依此第 $i$ 行第 $j$ 列为 $(i,j)$，则每颗摆进去的黑棋必须摆在满足以下要求的位置：

1. 其摆放位置没有黑棋子且下方为与其种类相同的红棋；

2. 在 1. 的要求下，若有多个，令一个位置的 **紧密度** 为其四边有黑棋子相邻或为棋盒壁的个数，则选择 **紧密度** 最大的一个；

3. 在 2. 的要求下，若还有多个，则设此位置的坐标为 $(i,j)$，要求 $i+j$ 最小；

4. 在 3. 的要求下，若还有多个，要求 $i$ 最小。

给出红棋的摆放情况和黑棋放入的顺序，她想请你帮忙求出每个位置的黑棋子被放入的顺序。

## 说明/提示

对于 $30\%$ 的数据，$1 \le n,m \le 70$；

对于另外 $30\%$ 的数据，$v_{i,j}=1$；

对于 $100\%$ 的数据，$1 \le n,m \le 10^3, 1 \le v_{i,j} \le 10$，保证每种棋子黑色与红色数量相等。

## 样例 #1

### 输入

```
3 3
1 1 1
1 1 1
1 1 1
1 1 1 1 1 1 1 1 1
```

### 输出

```
1 2 3
4 6 7
5 8 9
```

## 样例 #2

### 输入

```
3 3
1 2 3
2 2 1
3 1 3
1 3 3 2 1 2 2 3 1
```

### 输出

```
1 4 2
6 7 5
3 9 8
```

## 样例 #3

### 输入

```
10 10
4 9 3 9 3 6 4 8 7 7 
7 5 3 8 7 10 10 8 7 10 
10 9 3 10 3 3 3 2 3 8 
9 6 3 1 10 10 3 4 2 6 
10 5 9 9 5 7 7 6 2 7 
1 1 6 3 2 10 10 7 6 7 
1 7 10 7 3 10 3 9 10 9 
1 5 1 2 2 4 4 9 10 8 
6 3 7 1 5 8 10 4 10 7 
5 4 8 3 3 9 2 6 8 2 
6 6 6 1 10 8 5 5 4 2 1 5 5 9 4 3 4 6 3 5 9 7 4 8 9 3 5 9 1 7 4 1 1 2 2 6 7 10 6 2 6 6 1 8 4 7 7 10 3 1 9 8 10 9 4 7 9 10 2 3 3 3 2 7 2 9 7 7 3 8 8 9 3 2 10 9 10 7 8 10 8 3 7 7 3 3 7 3 7 3 3 10 3 10 10 10 10 10 10 10 
```

### 输出

```
9 14 16 28 49 1 15 24 37 46
22 12 26 79 84 94 92 70 56 53
5 21 61 80 85 93 91 63 62 6
25 18 60 50 58 95 90 23 34 3
38 13 51 54 20 87 89 39 59 64
29 32 36 69 74 97 96 78 42 67
11 30 48 68 86 98 88 76 77 72
4 8 33 40 35 31 45 57 99 81
2 19 47 43 27 71 75 55 100 83
7 17 52 73 82 66 65 41 44 10
```

# 题解

## 作者：VinstaG173 (赞：7)

定位签到题，所以不讲部分分（雾

按题意模拟即可。但是直接模拟是 $O(n^4)$ 的，考虑优化。容易想到的优化就是用数据结构维护。发现 $v$ 的值很小，所以只要开 $10$ 个 `set` 来维护每种棋子就可以了。时间复杂度 $O(n^2\log{n})$。

Code:
```cpp
#include<set>
#include<cctype>
#include<cstdio>
#define rg register
inline char rc()
{
	static char buf[524288],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,524288,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(!isdigit(cc))cc=rc();
	while(isdigit(cc))x=(x*10+cc-'0'),cc=rc();
	return x;
}
using std::set;
int n,m,k,v,r,c;
int a[1003][1003];
int bs[1003][1003];
int res[1003][1003];
struct bd
{
	int x,y;
	bool operator <(const bd &t)const
	{
		if(bs[x][y]==bs[t.x][t.y])
		{
			if(x+y==t.x+t.y)return x<t.x;
			return (x+y)<(t.x+t.y);
		}
		return bs[x][y]>bs[t.x][t.y];
	}
};
inline bd make(int x,int y)
{
	bd nw;
	nw.x=x,nw.y=y;
	return nw;
}
set<bd>S[13];
inline void upd(int r,int c)
{
	int vl=a[r][c];
	bd nw=make(r,c);
	if(!S[vl].count(nw))return;
	S[vl].erase(nw);
	++bs[r][c],S[vl].insert(nw);
}
int main()
{
	n=read(),m=read();k=n*m;
	for(rg int i=1;i<=n;++i)
	{
		for(rg int j=1;j<=m;++j)
		{
			a[i][j]=read();
			bs[i][j]+=(i==1),bs[i][j]+=(i==n);
			bs[i][j]+=(j==1),bs[i][j]+=(j==m);
			S[a[i][j]].insert(make(i,j));
		}
	}
	for(rg int i=1;i<=k;++i)
	{
		v=read();
		set<bd>::iterator tmp=S[v].begin();
		r=tmp->x,c=tmp->y;
		S[v].erase(tmp),res[r][c]=i;
		if(r>1)upd(r-1,c);
		if(r<n)upd(r+1,c);
		if(c>1)upd(r,c-1);
		if(c<m)upd(r,c+1);
	}
	for(rg int i=1;i<=n;++i)
	{
		for(rg int j=1;j<m;++j)printf("%d ",res[i][j]);
		printf("%d\n",res[i][m]);
	}
	return 0;
}
```

---

## 作者：Lynkcat (赞：4)

虽然是一道模拟题，但其实我们可以考虑用常数更小的 priority_queue 解决。

考虑 $V_{i,j}$ 表示格子种类 $i$，紧密度为 $j$ 的 priority_queue。我们发现实际上如果在当前 priority_queue 中的最小值紧密度如果不是 $j$ 了就弹去，否则就放。这样做时间复杂度还是 $O(5\times n^2 \log n)$，空间复杂度 $O(5\times n^2)$，但因为 priority_queue 常数更小所以目前跑到了最优解。

```c++
//The Hunting Party - Keys To The Kingdom
//好想做嘉然小姐的狗啊~
#include<bits/stdc++.h>
#define IOS ios::sync_with_stdio(false)
#define ll long long
#define mp make_pair
#define pa pair < int,int >
#define fi first
#define se second
#define inf 1e18
#define mod 998244353
//#define int ll
#define N 1005
using namespace std;
inline char gc(){static char buf[1000000],*p1=buf,*p2=buf;return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;}
// #define gc getchar
inline ll read(){char c=gc();ll su=0,f=1;for (;c<'0'||c>'9';c=gc()) if (c=='-') f=-1;for (;c>='0'&&c<='9';c=gc()) su=su*10+c-'0';return su*f;}
inline void write(ll x){if (x<0){putchar('-');write(-x);return;}if (x>=10) write(x/10);putchar(x%10+'0');}
inline void writesp(ll x){write(x),putchar(' ');}
inline void writeln(ll x){write(x);putchar('\n');}
priority_queue<pa>G[15][15];
int n,m,v[N][N],jinmi[N][N],ans[N][N];
void What_will_Diana_eat_today()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
		{
			v[i][j]=read();
		}
	}
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			jinmi[i][j]=(i==1||i==n)+(j==1||j==m);
			G[v[i][j]][(i==1||i==n)+(j==1||j==m)].push(mp(-(i+j),-i));
		}
	for (int i=1;i<=n*m;i++)
	{
		int x=read();
		bool bl=0;
		for (int j=4;j>=0;j--)
		{
			if (G[x][j].empty()) continue;
			while (!G[x][j].empty())
			{
				pa now=(G[x][j].top());
				G[x][j].pop();
				now.se=-now.se;
				now.fi=-now.fi;
				now.fi=now.fi-now.se;
				swap(now.fi,now.se);
				if (jinmi[now.fi][now.se]!=j||ans[now.fi][now.se]) continue;
				ans[now.fi][now.se]=i;
				if (now.fi>1)
				{
					jinmi[now.fi-1][now.se]++;
					G[v[now.fi-1][now.se]][jinmi[now.fi-1][now.se]].push(mp(-(now.fi-1+now.se),-now.fi+1));
				}
				if (now.se>1)
				{
					jinmi[now.fi][now.se-1]++;
					G[v[now.fi][now.se-1]][jinmi[now.fi][now.se-1]].push(mp(-(now.fi-1+now.se),-now.fi));
				}
				if (now.fi<n)
				{
					jinmi[now.fi+1][now.se]++;
					G[v[now.fi+1][now.se]][jinmi[now.fi+1][now.se]].push(mp(-(now.fi+1+now.se),-now.fi-1));
				}
				if (now.se<m)
				{
					jinmi[now.fi][now.se+1]++;
					G[v[now.fi][now.se+1]][jinmi[now.fi][now.se+1]].push(mp(-(now.fi+1+now.se),-now.fi));
				}
				bl=1;break;
			}
			if (bl) break;
		}
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++) writesp(ans[i][j]);
		puts("");
	}
}
signed main()
{
	int T=1;
	while (T--)
	{
	 	  What_will_Diana_eat_today();
	}
}
/*

*/

```



---

## 作者：include13_fAKe (赞：3)

怎么比赛过去 $3$ 年了我才把这个题做出来？

## 思路

普及组 STL 必刷题。

$30$ 分的 $O(n^2m^2)$ 暴力枚举，$30$ 分的找规律，$60$ 分白送的。此处只讲满分做法。

别人用的是 set（CSP-J 2024 T1 也有人这么做），我不会 set，提供一种优先队列做法。

开 $10$ 个优先队列维护不同的种类。


```cpp
struct node{
	int include13;//紧密度 
	int i;
	int j;
	int k;	//规定 k=i+j; 
	friend bool operator <(const node a,const node b){
		if(a.include13!=b.include13)	return a.include13<b.include13;
		if(a.k!=b.k)	return a.k>b.k;
		return a.i>b.i;
	}
}; 
priority_queue<node> q[15];
```

因为**紧密度**只增不减，其他值又全程不会发生变化，所以可以不断地往优先队列里加新的摆放位置的信息。当一个格子的紧密度发生变化时，就将这个格子重新插入优先队列即可。

每一次考虑优先队列的队头时要考虑这个格子是否已经放过了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

struct node{
	int include13;//紧密度 
	int i;
	int j;
	int k;	//规定 k=i+j; 
	friend bool operator <(const node a,const node b){
		if(a.include13!=b.include13)	return a.include13<b.include13;
		if(a.k!=b.k)	return a.k>b.k;
		return a.i>b.i;
	}
}; 
priority_queue<node> q[15];	//不使用 set 
bool in[2021][2021];
int sx[2021][2021]; 
int include13_fAKe[2021][2021];	//紧密度统计 
int col[2021][2021];
int n,m;
int main(){
	memset(sx,-1,sizeof(sx));
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		include13_fAKe[i][1]++;
		include13_fAKe[i][m]++;
	} 
	for(int i=1;i<=m;i++){
		include13_fAKe[n][i]++;
		include13_fAKe[1][i]++;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int now;
			cin>>now;
			col[i][j]=now;
			q[now].push((node){include13_fAKe[i][j],i,j,i+j});
		}
	}
	for(int i=1;i<=n*m;i++){
		int now;
		cin>>now;
		bool flag=false;
		while(!flag){
			node now1=q[now].top();
			q[now].pop();
			int i1=now1.i;
			int j1=now1.j;
//			cout<<i1<<' '<<j1<<endl;
			if(sx[i1][j1]==-1){
				sx[i1][j1]=i;
				if(i1!=1){
					include13_fAKe[i1-1][j1]++;
					q[col[i1-1][j1]].push((node){include13_fAKe[i1-1][j1],i1-1,j1,i1-1+j1});
				}
				if(i1!=n){
					include13_fAKe[i1+1][j1]++;
					q[col[i1+1][j1]].push((node){include13_fAKe[i1+1][j1],i1+1,j1,i1+1+j1});
				}
				if(j1!=1){
					include13_fAKe[i1][j1-1]++;
					q[col[i1][j1-1]].push((node){include13_fAKe[i1][j1-1],i1,j1-1,i1+j1-1});
				}
				if(j1!=m){
					include13_fAKe[i1][j1+1]++;
					q[col[i1][j1+1]].push((node){include13_fAKe[i1][j1+1],i1,j1+1,i1+j1+1});
				}
				flag=true;
			} 
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<sx[i][j]<<' ';
		}
		cout<<endl;
	}
	cout<<endl;
	return 0;
}
```

---

## 作者：liguangjun2023 (赞：0)

#### 本题使用的解题算法是模拟算法，主要数据结构是优先队列数组。
解题思路
1. 按照特征值定义优先队列数组。
2. 遍历待放的棋子，根据棋子的特征值，输出第一个位置，即是应该放置的位置。
3. 更新棋子周围四个位置的紧密度，形成新的位置，添加到优先队列。
   

---

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int i,j,p; 
};
//仿函数，对优先队列的节点排序 
struct  cmp{
	bool operator()(node a,node b){
		if(a.p<b.p)	return true;
		else if(a.p==b.p && a.i+a.j>b.i+b.j)	return true;
		else if(a.p==b.p && a.i+a.j==b.i+b.j && a.i>b.i)	return true;
		
		return false;
	}
};
const int N=1e6+10;
//q为优先队列数组，下标为特征值，值是优先队列 
priority_queue<node,vector<node>,cmp> q[15];
//数组ans保存每个位置棋子的放置循序，数组p保存每个位置的紧密度 
int n,m,a[1010][1010],b[N],ans[1010][1010],p[1010][1010];
//打印结果 
void prt(){
//	cout<<"--填充顺序--\n";
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<ans[i][j]<<" ";
		}
		cout<<endl;
	}
}
//打印位置紧密度，调试时使用 
void prt1(){
	cout<<"***紧密度***\n";
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<p[i][j]<<" ";
		}
		cout<<endl;
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			//tp初始紧密度，只需要考虑贴着边缘的位置 
			int tp=0;
			if(i==1 || i==n)	tp+=1;
			if(j==1 || j==m)	tp+=1;	
			q[a[i][j]].push({i,j,tp});
			p[i][j]=tp;
		}
	}
	//b数组保存棋子的顺序，实际上可以省略b数组 
	for(int i=1;i<=n*m;i++){
		cin>>b[i]; 
	}
	for(int i=1;i<=n*m;i++){
		node nd=q[b[i]].top();
		int x=nd.i,y=nd.j;
		q[b[i]].pop();
		//在更新优先队列的时候，同一个位置增加不同紧密度的新结点，需要查询位置。 
		while(ans[x][y]!=0){
			nd=q[b[i]].top();
			x=nd.i,y=nd.j;
			q[b[i]].pop();
		}
		ans[x][y]=i;
		//更新四个方向位置的紧密度，作为新结点添加到特征值的优先队列 
		if(x-1>=1 && x-1<=n && y>=1 && y<=m){
			p[x-1][y]+=1;
			node td={x-1,y,p[x-1][y]};
			if(ans[x-1][y]==0)
				q[a[x-1][y]].push(td);
		}
		if(x+1>=1 && x+1<=n && y>=1 && y<=m){
			p[x+1][y]+=1;
			node td={x+1,y,p[x+1][y]};
			if(ans[x+1][y]==0)
				q[a[x+1][y]].push(td);
		}
		if(x>=1 && x<=n && y-1>=1 && y-1<=m){
			p[x][y-1]+=1;
			node td={x,y-1,p[x][y-1]};
			if(ans[x][y-1]==0)
				q[a[x][y-1]].push(td);
		}
		if(x>=1 && x<=n && y+1>=1 && y+1<=m){
			p[x][y+1]+=1;
			node td={x,y+1,p[x][y+1]};
			if(ans[x][y+1]==0)
				q[a[x][y+1]].push(td);
		}	
	}
	prt();

	return 0;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/P7975)   
### 背景  
作为杰伦迷，怎能不激动呢？！  
[MV](https://www.bilibili.com/video/BV1oP41197gm/?spm_id_from=333.337.search-card.all.click) 
### 题意  
好啦，回归正题~~    
其实题面说的太复杂了~~    
大致意思就是：  
给你一个 $n \times m$ 的矩阵，矩阵上的每一个格子都有一个数字。   
现在往上放棋子，每个棋子都有自己的权值 $x$。   
每一个棋子都按一下的方法放置：    
1. 棋子必须放在权值相同的格子上；
2. 若有多个格子满足 1.，选择**紧密度**最大的一个。一个位置的**紧密度**为其四边有黑棋子相邻或为棋盒壁的个数；
3. 若有多个格子满足 2.，选择横坐标与纵坐标和最小的格子；
4. 若有多个格子满足 3.，选择横坐标最小的格子。
   
最后输出每一个格子被放入棋子的顺序。
### 思路 
先考虑直接模拟。对于每一个输入的棋子种类，枚举整个棋盘，按照题目的意思选取放的位置即可。    
总共输入 $n \times m$ 个数，枚举棋盘也要做 $n \times m$ 次。总时间复杂度是 $O(n^2m^2)$。预计能拿 $30 pts$。

---

考虑如何优化。不难发现，对于一种颜色的某一个位置，我们可以记录它的横纵坐标与紧密度，并进行多关键字排序，放到一个数组里头。对于每一个输入的颜色，就放在该颜色数组的第一个位置所表示的格子里。    
需要注意的是，每放入一枚棋子，放它的格子的四个方向上的格子的紧密度会发生变化，这样就要重新排序，从而超时。关于这一点，我们可以使用优先队列，也就是堆来优化排序。   
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,i,j,a[1001][1001],f[1001][1001],ff[1001][1001];
int x,xx,yy,s;
struct no{
	int x,y,a;
};
no tmp,v;
struct cmp{
	bool operator()(no t,no w){ //按题意，来排序 
		if(t.a<w.a) return 1;
		else if(t.a==w.a&&t.x+t.y>w.x+w.y) return 1;
		else if(t.a==w.a&&t.x+t.y==w.x+w.y&&t.x>w.x) return 1;
		return 0;
	}
};
struct no2{
	priority_queue<no,vector<no>,cmp>q;
}b[1001];
bool pp(int x,int y){
	if(x<1||x>n||y<1||y>m) return 1;
	if(f[x][y]>0) return 1;
	return 0;
}
bool pd(int x,int y){
	return x>=1&&x<=n&&y>=1&&y<=m;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++){
			cin>>a[i][j];
			tmp.x=i,tmp.y=j;//坐标记录 
			//记录“紧密度” 
			s=0;
			if(pp(i-1,j)) s++;
			if(pp(i+1,j)) s++;
			if(pp(i,j-1)) s++;
			if(pp(i,j+1)) s++;
			tmp.a=s;
			ff[i][j]=s;
			b[a[i][j]].q.push(tmp);
		}
	for(i=1;i<=n*m;i++){
		cin>>x;
		
		//找到最优的没放过的点 
		v=b[x].q.top();
		xx=v.x,yy=v.y;
		b[x].q.pop();
		while(f[xx][yy]>0){
			v=b[x].q.top();
			xx=v.x,yy=v.y;
			b[x].q.pop();			
		}
		
		f[xx][yy]=i;
		
		//判断四个方向 
		if(pd(xx-1,yy)){
			tmp.x=xx-1,tmp.y=yy,tmp.a=ff[xx-1][yy]+1;
			ff[xx-1][yy]++; //记得将紧密度+1 
			if(f[xx-1][yy]==0) b[a[xx-1][yy]].q.push(tmp);
		}
		if(pd(xx+1,yy)){
			tmp.x=xx+1,tmp.y=yy,tmp.a=ff[xx+1][yy]+1;
			ff[xx+1][yy]++;
			if(f[xx+1][yy]==0) b[a[xx+1][yy]].q.push(tmp);
		}
		if(pd(xx,yy-1)){
			tmp.x=xx,tmp.y=yy-1,tmp.a=ff[xx][yy-1]+1;
			ff[xx][yy-1]++;
			if(f[xx][yy-1]==0) b[a[xx][yy-1]].q.push(tmp);
		}
		if(pd(xx,yy+1)){
			tmp.x=xx,tmp.y=yy+1,tmp.a=ff[xx][yy+1]+1;
			ff[xx][yy+1]++;
			if(f[xx][yy+1]==0) b[a[xx][yy+1]].q.push(tmp);
		}
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++) cout<<f[i][j]<<" ";
		cout<<"\n";
	}
}
```
神奇的是，我因为认为 $n$ 和 $m$ 是相等的而苦恼了~~一下午~~十分钟。(lll￢ω￢)

---

## 作者：jsisonx (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P7975)

# 题目分析
这题其实是优化模拟。直接模拟的方法大家都能想到，在这里就不说了，但这种算法复杂度可达 $O(n^4)$，显然不能通过此题。

考虑用优先队列优化。

由于每次要选取紧密度最大，横纵坐标之和最大，横坐标最大的位置，因此对于坐标的排序可以使用优先队列，维护一个小根堆，队首元素的横纵坐标之和、横坐标最小。对于紧密度，可以直接作为二维数组的其中一维，即设 $e$ 二维数组，其中存储一个优先队列，则 $e_{i,j}$ 的队首表示特征值为 $i$，紧密度为 $j$ 的所有位置中横纵坐标之和、横坐标最大的位置的横纵坐标。

设在位置 $(i,j)$ 填上数后 $(i+1,j)$，$(i-1,j)$，$(i,j+1)$，$(i,j-1)$ 位置的紧密度都要加一并加入 $e_{k,p+1}$ 的队列（$k$ 表示当前位置特征值，$p$ 表示原紧密度。而这些位置在原队列中无法删除，因此当我们填数 $k$ 时，要判断 $e_{k,q}$ 中 $q$ 是否真的等于 $e_{k,q}$ 中队首元素的紧密度，如果不等，说明这个点已经修改了，需要舍弃。

由于紧密度要最大，所以遍历 $e$ 数组时要从后往前便利，即 $e_{i,j}$ 的 $j$ 倒序遍历。

[AC 记录](https://www.luogu.com.cn/record/161636910)

---


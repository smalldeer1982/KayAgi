# [蓝桥杯 2016 省 A] 密码脱落

## 题目描述

X 星球的考古学家发现了一批古代留下来的密码。

这些密码是由 A、B、C、D 四种植物的种子串成的序列。

仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的回文串）。

由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。

你的任务是：

给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。

## 说明/提示

蓝桥杯 2016 年省赛 A 组 I 题。

## 样例 #1

### 输入

```
ABCBA```

### 输出

```
0```

## 样例 #2

### 输入

```
ABDCDCBABC```

### 输出

```
3```

# 题解

## 作者：SilverLi (赞：9)

[密码脱落 の 传送门](https://www.luogu.com.cn/problem/P8638)

题目中要求我们去找脱落的种子，首先我们知道。

种子在脱了几个不知道，种子脱在哪里也不知道。

这两个问题我们不能解决。

但可以反着想，是否可以去找没有脱落的种子，即找相同的。

那么又有一个问题：相同怎么找。

根据回文串的特性（左边和右边对称），

就有两种办法。

### 第一种

找到对称轴，左边和右边对比。

种子脱落之后，对称轴的位置也变得不好确定。

所以选择另一种方法。

### 第二种

把原串倒过来构造另一个串，去找两串中相同的子串。

设原串为 $s1$，倒序串为 $s2$。

定义 $f_{i,j}$ 表示 $s1$ 中前 $i$ 个种子与 $s2$ 中前 $j$ 个种子相同种子数。

则当 $s1_i=s2_j$ 时，表示找到一个相等的种子就让 $f_{i,j}=f_{i-1,j-1}+1$，而 $s1_i\ne s2_j$ 时 $f_{i,j}=\max(f_{i-1,j},f_{i,j-1})$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1005;
int f[N][N];
string s1,s2;
int main() {
	cin>>s1;	s2=s1;
	int l=s1.size();
	reverse(s2.begin(),s2.end());		//翻转串
	for(int i=1;i<=l;++i)			
		for(int j=1;j<=l;++j)
			if(s1[i-1]==s2[j-1])	f[i][j]=f[i-1][j-1]+1;
			else	f[i][j]=max(f[i][j-1],f[i-1][j]);
	cout<<l-f[l][l];
	return 0;
}
```

---

## 作者：sherry_lover (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P8638)

本题考点：最长公共子序列 ~~（模拟）~~。

------------
我们要让添加的字符少，就要求出这个字符串里的最长回文子串的长度。

怎么求最长回文子串的长度呢？

我们可以把串 $S$ 颠倒过来，变成 $S^\prime$，只要求出串 $S$ 与串 $S^\prime$ 最长公共子串，最后答案就是 $\left\vert S\right\vert$ 减去这个结果啦。

标程在这里：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s1[1010],s2[1010];
int f[1010][1010];
int main () {
	scanf("%s",1+s1);
	int lens=strlen(1+s1);
	for(int i=1;i<=lens;i++) s2[lens-i+1]=s1[i];//翻转
	for(int i=1;i<=lens;i++) f[i][1]=f[1][i]=0;//初始化
	for(int i=1;i<=lens;i++)//模板
		for(int j=1;j<=lens;j++)
			if(s1[i]!=s2[j]) f[i][j]=max(f[i-1][j],f[i][j-1]);
			else f[i][j]=f[i-1][j-1]+1;
	cout << lens-f[lens][lens];//输出
	return 0;
}
```

---

## 作者：liupei (赞：1)

## 思路
这是一道经典的回文串问题，如果一个字符串是回文串，那么它可以从中间对折，两边的字符串是相同的。

对于一个非回文串，我们可以通过删除一些字符，使它变成回文串。那么要求至少删除多少个字符呢？

我们可以用动态规划来解决这个问题。设 $f_{i,j}$ 表示将 $s_i$到 $s_j$ 变成回文串需要删除的最少字符数。

对于 $s_i$ 和 $s_j$，如果它们相同，那么 从$s_i$ 到 $s_j$ 可以通过将 $s_{i+1}$ 到 $s_{j-1}$ 变成回文串后再将其左右两端加上 $s_i$ 和 $s_j$ 得到。即：
$f_{i,j}=f_{{i+1},{j-1}}$。

如果 $s_i$ 和 $s_j$ 不同，那么 $s_i$ 到 $s_j$ 必须要删除掉其中的一个字符，才能让它变成回文串。可以分别考虑删除 $s_i$ 或者 $s_j$ 的情况，取其中的最小值：$f_{i,j}=\min(f_{{i+1},j},f_{i,{j-1}})+1$。

所以综合一下。

$$f_{i,j} = \begin{cases}f_{{i+1},{j-1}} &( s_i==s_j) \\\min(f_{{i+1},j},f_{i,{j-1}})+1 &\ (s_i \neq s_j)\end{cases}$$


最终的结果就是 $f_{0,n-1}$，其中 $n$ 是字符串的长度。
考虑优化空间复杂度，我们可以发现 $f_{i,j}$ 只依赖于 $f_{i+1,j-1}$ 和 $f_{{i+1},j}$，因此可以使用滚动数组将空间复杂度优化为 $O(n)$。


---

## 作者：pxb0801 (赞：1)

## 0.前言：

这题看似是一个贪心，~~虽然我也不清楚能不能用贪心~~，但可以用 dp 来做。

## 1.分析：

对于一个字符串，假设是 `ABBCCA`，我们将它颠倒一下，就变成了 `ACCBBA`。现在我们来找着两个字符串的最长公共子序列，结果为 `ACCA` 或 `ABBA`。

可能还不是很明显，我们再举一个例子：

对于样例 $2$ 的 `ABDCDCBABC`，颠倒后为 `CBABCDCDBA`，最长公共子序列为 `ABCDCBA`。

所以，我们发现了一个结论：对于任意一个字符串，它和颠倒后的字符串的最长公共子序列一定是一个回文串，而且在此题中就是可以留下来的最多的字符数。

答案就是总长度减去最长公共子序列的长度。

## 2.AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[1005],t[1005];
int f[1005][1005];
int main(){
    scanf("%s",s+1);
    int l=strlen(s+1);
    for(int i=1;i<=l;i++){
    	t[i]=s[l-i+1];//t数组是s的颠倒字符串
	}
    for(int i=1;i<=l;i++){//最长公共子序列模板，不多加解释
    	for(int j=1;j<=l;j++){
    		if(s[i]==t[j]){
    			f[i][j]=f[i-1][j-1]+1;
			}
            else{
            	f[i][j]=max(f[i-1][j],f[i][j-1]);
			}
		}
	}
	cout<<l-f[l][l];//答案是总长度减最长公共子序列的长度
    return 0;
}
```

---

## 作者：MspAInt (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8638)

回文串是两边对称的，本题要求最少修改几个位置才能使原串对称。那么我们可以将字符串倒序，显然此时两串的最长公共子序列就是不需要修改的位置（字串长度减去无需修改的位置数即为答案）。

最长公共子序列不会的话看[这题](https://www.luogu.com.cn/problem/P1439)（当然本题并不需要 $n\log n$ 的时间复杂度）。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	char ch;
	char hc;
};
int main(){
	int dp[1001][1001]={};
	node w[1001];
	string str;
	cin>>str;
	int len=str.length();
	for(int i=1;i<=len;i++){
		w[i].ch=str[i-1];
		w[i].hc=str[len-i];
	}
	//for(int i=1;i<=len;i++)cout<<w[i].ch;
	//cout<<endl;
	//for(int i=1;i<=len;i++)cout<<w[i].hc;
	for(int i=1;i<=len;i++){
		for(int j=1;j<=len;j++){
			if(w[i].ch==w[j].hc){
				dp[i][j]=dp[i-1][j-1]+1;
			}else{
				dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
			}
		}
	} 
	cout<<len-dp[len][len]; 
	return 0;
}
```

[record](https://www.luogu.com.cn/record/108732291)

---

## 作者：SunLegend (赞：1)


题目大意
------------
给定一个字符串，问最少要添加多少个字符，可以使这个字符串变为一个回文串


算法分析
------------
我们希望添加的字符最少，所以只需求出当前字符串最长回文子串的长度，用总长度减去它即可得到最少需要添加多少字符。

由于找的是回文串，所以把原来的字符串反转一遍后，找到最长回文串还是不变的

于是我们即可发现这个字符串与它反转后的字符串的最长公共子序列即为最长回文子串，问题也就迎刃而解了。

代码展示
------------
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[1002],b[1002];
int f[1002][1002],s;
int main()
{
    scanf("%s",a+1);
    s=strlen(a+1);
    for(int i=1;i<=s;i++)
    {
    	b[i]=a[s-i+1];
	}
    for(int i=1;i<=s;i++)
    {
        for(int j=1;j<=s;j++)
        {
            if(a[i]==b[j])
            {
                f[i][j]=f[i-1][j-1]+1;
            }
            else
            {
                f[i][j]=max(f[i-1][j],f[i][j-1]);
            }
        }
    }
    cout<<s-f[s][s];
    return 0;
}
```


---

## 作者：Smg18 (赞：0)

题目大意：

最少要添加多少个字符，可以使这个题目给的字符串变为一个回文字符串（把脱落的种子给补回来，补成对称）。

所以说：

我们可以做个比较，比方说 `CABCDCBA` 颠倒后变成 `ABCDCBAC` 最长公共子序列为 `ABCDCBA`。

也就是说无论如何颠倒他的最长公共子串都是回文串，所以说只用判断两的最长公共子序列长度就是最长啦（回文的特性）。

所以我们要用到最长公共子序列力，不懂的可以见[模板。](https://www.luogu.com.cn/problem/P1439)（模板绿题？）

```cpp
#include<bits/stdc++.h>
//#include<windows.h>
#define ll long long
#define Test ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define R(i,j) for(auto i:j)
const int maxn = 1e3+100;
int f[maxn][maxn];
char s[maxn];
int len; // 字符串长度
using namespace std;
int main() {
	scanf("%s",s+1); 
	len = strlen(s+1); // 从s[1]开始算字符串的长度
    //对于每一个只有一个字符的字符串来说，它必是回文
    for(int i = 1; i <= len; i++) f[i][i] = 0;
	for(int k = 1; k < len; k++)
		for(int i = 1; i <= len - k; i++) { //起点
			int j = i + k; //终点
			s[i] == s[j]?f[i][j]=f[i+1][j-1]:f[i][j] = min(f[i+1][j], f[i][j-1]) + 1;
	}
	
	cout << f[1][len];
	return 0;
}
```


---

## 作者：Leaves_xw (赞：0)

**题意：**

给出一个回文串，判断有多少个字母不同，输出不同的个数。

**思路：**

首先给出一个回文串，接着我们可以依次进行判断，若回文串 $s$ 中的 $s_i \not = s_j$，则 $cnt$ 累加 $1$，最后输出 $cnt$ 即可。

也就是说，我们可以根据回文串进行每一个判断。

---

## 作者：RP_INT_MAX (赞：0)

双倍经验：[P1435 [IOI2000] 回文字串](https://www.luogu.com.cn/problem/P1435)。

## $\tt Solution$

很显然将字符串 $S$ 颠倒为 $S'$，回文子串不变。

所以做一遍 $S$ 与 $S'$ 的 LCS 即可。

答案就是字符串长减去 LCS 长度。

## $\tt Code$

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
inline int max(int a,int b) {return a>b?a:b;} 
char s1[1010],s2[1010];
int f[1010][1010];
int main () {
	scanf("%s",1+s1);
	int n=strlen(1+s1);
	for(int i=1;i<=n;++i) s2[n-i+1]=s1[i];
	for(int i=1;i<=n;++i) f[i][1]=f[1][i]=0;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			if(s1[i]!=s2[j]) f[i][j]=max(f[i-1][j],f[i][j-1]);
			else f[i][j]=f[i-1][j-1]+1;
	printf("%d\n",n-f[n][n]);
	return 0;
}
```

---


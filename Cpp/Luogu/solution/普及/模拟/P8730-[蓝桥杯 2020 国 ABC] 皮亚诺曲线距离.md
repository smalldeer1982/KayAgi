# [蓝桥杯 2020 国 ABC] 皮亚诺曲线距离

## 题目描述

皮亚诺曲线是一条平面内的曲线。

下图给出了皮亚诺曲线的 1 阶情形, 它是从左下角出发, 经过一个 $3 \times 3$ 的 方格中的每一个格子, 最终到达右上角的一条曲线。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_30_334c51de49a3a8e7ba1bg-05.jpg)

下图给出了皮亚诺曲线的 2 阶情形, 它是经过一个 $3^{2} \times 3^{2}$ 的方格中的每一 个格子的一条曲线。它是将 1 阶曲线的每个方格由 1 阶曲线替换而成。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_30_334c51de49a3a8e7ba1bg-06.jpg)

下图给出了皮亚诺曲线的 3 阶情形, 它是经过一个 $3^{3} \times 3^{3}$ 的方格中的每一 个格子的一条曲线。它是将 2 阶曲线的每个方格由 1 阶曲线替换而成。 

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_30_334c51de49a3a8e7ba1bg-07.jpg)

皮亚诺曲线总是从左下角开始出发, 最终到达右上角。

我们将这些格子放到坐标系中, 对于 $k$ 阶皮亚诺曲线, 左下角的坐标是 $(0,0)$, 右上角坐标是 $\left(3^{k}-1,3^{k}-1\right)$, 右下角坐标是 $\left(3^{k}-1,0\right)$, 左上角坐标是 $\left(0,3^{k}-1\right)$ 。

给定 $k$ 阶皮亚诺曲线上的两个点的坐标, 请问这两个点之间, 如果沿着皮 亚诺曲线走, 距离是多少?

## 说明/提示

对于 $30 \%$ 的评测用例, $0 \leq k \leq 10$ 。

对于 $50 \%$ 的评测用例, $0 \leq k \leq 20$ 。

对于所有评测用例, $0 \leq k \leq 100,0 \leq x_{1}, y_{1}, x_{2}, y_{2}<3^{k}, x_{1}, y_{1}, x_{2}, y_{2} \leq 10^{18}$ 。 数据保证答案不超过 $10^{18}$ 。

蓝桥杯 2020 年国赛 A 组 F 题（B 组 F 题, C 组 H 题）。

## 样例 #1

### 输入

```
1
0 0
2 2```

### 输出

```
8```

## 样例 #2

### 输入

```
2
0 2
0 3```

### 输出

```
13```

# 题解

## 作者：DreamLand_zcb (赞：8)

## 简要题意

求两点之间的皮亚诺曲线距离。

## 思路

将该矩形分为 $9$ 个部分，如图所示，用红色方框按顺序框出了就各部分，蓝框是每个部分的起点：

![](https://huatu.98youxi.com/markdown/work/uploads/upload_a021469e2ba376205d5d8bd2abd493f9.png)



记 $(0, 0)$ 到 $(x, y)$ 的距离在 $k$ 阶时为 $dis(k, x, y)$。

可以发现 $(x_1, y_1)$ 到 $(x_2, y_2)$ 的距离等于 $|dis(k, x_1, y_1) - dis(k, x_2, y_2)|$ 于是可以考虑计算两个距离然后得出答案。

首先记此时矩形的边长 $len = 3^k$ 和走完其中一个部分所需的步数 $step = \frac{3^{2\times k}}{9} = 2^{2\times k - 2}$。

在这里明确一个问题：因为皮亚诺曲线距离是以左下角为起点，右上角为终点的，所以我们在计算每一个部分的时候要把蓝框放到左下角，每次计算的时候都要把原先的 $(x, y)$ 改变成以当前部分的起点为参考系的坐标。

接下来分类讨论：

1. $\texttt{if }x < \frac{len}{3}$：

	- $\texttt{if }y < \frac{len}{3}$：说明在第 $1$ 个部分，起点是 $(0, 0)$，以第 $1$ 部分起点为参考系计算 $dis(k-1, x, y)$。
    
   - $\texttt{else if }y < \frac{2len}{3}$：说明在第 $2$ 个部分，起点为 $(\frac{len}{3}-1, \frac{len}{3})$，以第 $2$ 部分起点为参考系，再加上第 $1$ 部分走的距离计算 $step + dis(k-1, \frac{len}{3}-1-x, y-\frac{len}{3})$。
   
   - $\texttt{else}$：说明在第 $3$ 部分，起点为 $(0, \frac{2len}{3})$ 计算 $2 \times step + dis(k - 1, x, y - \frac{2len}{3})$。
   
2. $\texttt{else if }x < \frac{2len}{3}$：

	- $\texttt{if }y < \frac{len}{3}$：说明在第 $6$ 个部分，起点是 $(\frac{len}{3}, \frac{len}{3}-1)$，计算 $5 \times step + dis(k-1, x-\frac{len}{3}, \frac{len}{3}-1-y)$。
    
   - $\texttt{else if }y < \frac{2len}{3}$：说明在第 $5$ 个部分，起点为 $(\frac{2len}{3}-1, \frac{2len}{3}-1)$，计算 $4\times step + dis(k-1, \frac{2len}{3}-1-x, \frac{2len}{3}-1-y)$。
   
   - $\texttt{else}$：说明在第 $4$ 部分，起点为 $(\frac{len}{3}, len-1)$ 计算 $3 \times step + dis(k - 1, x-\frac{len}{3}, len-1-y)$。
   
3. $\texttt{else}$：

	- $\texttt{if }y < \frac{len}{3}$：说明在第 $7$ 个部分，起点是 $(\frac{2len}{3}, 0)$，计算 $6\times dis(k-1, x-\frac{2len}{3}, y)$。
    
   - $\texttt{else if }y < \frac{2len}{3}$：说明在第 $8$ 个部分，起点为 $(len-1, \frac{len}{3})$，计算 $7\times step + dis(k-1, len-1-x, y-\frac{len}{3})$。
   
   - $\texttt{else}$：说明在第 $9$ 部分，起点为 $(\frac{len}{3}, len-1)$ 计算 $8 \times step + dis(k - 1, x-\frac{2len}{3}, y - \frac{2len}{3})$。


## 代码

注意在 $k > 40$ 时会爆 long long，注意特判一下。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

ll k;
ll x1, Y1, x2, y2;
ll qpow(ll a, ll b)
{
    if(!b)  return 1;
    ll t=qpow(a, b/2);
    if(b%2 == 0)    return t * t;
    else    return t * t * a;
}
ll dis(ll k, ll x, ll y)
{
	if(k == 0)	return 1;
	ll step = qpow(3, 2 * k - 2);
	ll len = qpow(3, k);
	if(x < len / 3)
	{
		if(y < len / 3)	return dis(k - 1, x, y);//区域一 
		else if(y < len * 2 / 3)	return step + dis(k - 1, len / 3 - 1 - x, y - len / 3);//区域二
		return 2 * step + dis(k - 1, x, y - len * 2 / 3);//区域三 
	}
	else if(x < len * 2 / 3)
	{
		if(y < len / 3)	return 5 * step + dis(k - 1, x - len / 3, len / 3 - 1 - y);//区域六 
		else if(y < len * 2 / 3)	return 4 * step + dis(k - 1, len * 2 / 3 - 1 - x, len * 2 / 3 - 1 - y);//区域五 
		return 3 * step + dis(k - 1, x - len / 3, len - 1 - y);//区域四 
	}
	else
	{
		if(y < len / 3)	return 6 * step + dis(k - 1, x - len * 2 / 3, y);//区域七 
		else if(y < len * 2 / 3)	return 7 * step + dis(k - 1, len - 1 - x, y - len / 3);//区域八 
		return 8 * step + dis(k - 1, x - len * 2 / 3, y - len * 2 / 3);//区域九 
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> k >> x1 >> Y1 >> x2 >> y2;
	if(k >= 40)	k = 39;
	cout << abs(dis(k, x1, Y1) - dis(k, x2, y2));
	return 0;
}


```

---

## 作者：him的自我修养 (赞：6)

# 题意
求从 $x,y$ 到 $x1,y1$ 的皮亚诺距离
# 扯淡
地狱绘图。

# 思路
感觉可以用递归求解。函数 $f(a,x,y)$ 表示 $k$ 阶皮亚诺曲线下从 $0,0$ 到 $x,y$ 的距离。而 $ans=f(k,x,y)-f(k,x1,y1)$ 再输出求可以啦！

而 $f(a,x,y)$ 的递归形式如下 $f(a,x,y)=f(1,\frac{x}{k},\frac{y}{k})\times(3^{k})^{2}+f(a-1,x1,y1)$。
其中 $f(1,\frac{x}{k},\frac{y}{k})$。表示一阶皮亚诺曲线的距离，$p=3^{a-1}$。

而 $(3^{a-1})^{2}$ 表示把 $k$ 阶皮亚诺曲线分成一阶的皮亚诺曲线，就是总距离。

最后的 $f(a-1,x1,y1)$ 表示把 $k$ 阶皮亚诺曲线里的 $x,y$ 映射到 $k-1$ 阶皮亚诺曲线里，变成 $x1,y1$。


# 代码
~~我就知道你们只喜欢这里。~~
```
#include <iostream>
using namespace std;
typedef long long ll;
ll k;
ll p[45];
ll x1,y1,x2,y2;
ll pin[3][3]={
	{0,1,2},
	{5,4,3},
	{6,7,8},
};
ll len(ll p,ll &x,ll &y){
	ll ix=x/p,iy=y/p;
    x=x%p;
	y=y%p;
    if(ix==1) y=p-1-y;
    if(iy==1) x=p-1-x;
    return pin[ix][iy];
}
ll f(ll k,ll x,ll y){
	if(k==1) return pin[x][y];
	else return p[k-1]*p[k-1]*len(p[k-1],x,y)+f(k-1,x,y);
}
int main(){
	cin >>k;
	cin >>x1>>y1;
	cin >>x2>>y2;
	k=min(k,39ll);
	p[0]=1;
	for(int i=1;i<=39;i++) p[i]=p[i-1]*3;
	ll ans=f(k,x1,y1)-f(k,x2,y2);
	cout <<abs(ans);
	return 0;
}
```

管理大大求通过qwq

---

## 作者：Nuyoah_awa (赞：3)

### 题目大意
给定 $k$ 阶皮亚诺曲线上的两个点的坐标，请问这两个点之间，如果沿着皮亚诺曲线走，距离是多少?
### 题目分析

一看这题不是把走法都给出了吗，所以只要按照题目要求走一遍就好了。

但是！！！这样做很难知道每个点应该怎么走（规律太复杂了，懒得推了）而且时间复杂度是 $\mathcal O(3 ^ {2\times k})$ 肯定会挂。

于是我们仔细观察 $k$ 阶皮亚诺曲线。不难发现，我们可以把一个二阶皮亚诺曲线分成 $3\times3$ 个一阶皮亚诺曲线，而且这 $9$ 个的排列顺序与一阶皮亚诺曲线的行走顺序是一样的。

所以，我们可以考虑递归求解，对于 $n$ 阶皮亚诺曲线的一个点 $A(x_n,y_n)$，我们可以将 $A$ 点的距离转化为 $n-1$ 阶的皮亚诺曲线总距离加上 $A$ 在第 $n$ 阶的距离。通项公式为：

$$A(n, x, y) = B(1, \dfrac{x}{3 ^ {k-1}}, \dfrac{y}{3 ^ {k-1}}) \times 3 ^ {2 \times 3 ^{k-1}} + A(n - 1, x_1, y_1)$$

> PS：按照上述算法，答案有可能是负数，所以我们要手动取绝对值。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#define int long long

using namespace std;

int qpow[200], cnt[3][3] = {{0, 1, 2}, {5, 4, 3}, {6, 7, 8}}, k, x1, y_1, x2, y2;

int calc(int p, int &x, int &y)
{
    int u = x / p, v = y / p;
    x %= p, y %= p;
    (u == 1) ? y = p - y - 1 : y;
    (v == 1) ? x = p - x - 1 : x;
    return cnt[u][v];
}

int dfs(int k, int x, int y)
{
	return (k == 1) ? cnt[x][y] : qpow[k-1] * qpow[k-1] * calc(qpow[k-1], x, y) + dfs(k-1, x, y);
}
 
signed main()
{
	scanf("%lld %lld %lld %lld %lld", &k, &x1, &y_1, &x2, &y2);
    k = k > 39 ? 39 : k;
    qpow[0] = 1;
    for(int i = 1;i <= 39;i++)
		qpow[i] = qpow[i - 1] * 3;
    int ans = dfs(k, x1, y_1) - dfs(k, x2, y2);
    printf("%lld", abs(ans));
    return 0;
}
```

---

## 作者：封禁用户 (赞：2)

### 题意

两个点之间, 如果沿着皮亚诺曲线走, 距离是多少?

### 思路

考虑递归求解

我们把每个 $n$ 阶的图看成九个 $n-1$ 阶的图。

根据 $n$ 阶的和 $n-1$ 阶的 $(x,y)$ 之间的关系来逐层降阶。

对于 $k$ 阶皮亚诺曲线点 $a(k,x,y)$ 的距离表示为

$a(k,x,y)=a(1,\frac{x}{p},\frac{y}{p})\times(3^p)^2+a(k-1,x1,y1)$。

其中

$a(1,\frac{x}{p},\frac{y}{p})$ 表示 $1$ 阶皮亚诺曲线距离，$p=3^{k-1}$。

$(3^p)^2$ 表示将整个 $k$ 阶皮亚诺曲线划分为 $1$ 阶皮亚诺曲线，$1$ 单元格内的总数,即总距离。

$a(k-1,xx,yy)$ 表示 $k$ 阶 $(xx,yy)$ 映射到 $k-1$ 阶的坐标, 为不完整单元格在 $k-1$ 阶到 $(xx,yy)$ 的距离。其划分规则为

```cpp
if(x/p==1) yy=p-1-y;
if(y/p==1) xx=p-1-x;   
```

接下来，我们可以递归写出代码。

### 代码

```cpp
#include <iostream>
using namespace std;
long long pw[200],leng[3][3] = {{0, 1, 2}, {5, 4, 3}, {6, 7, 8}};//3的i次幂和1阶皮亚诺曲线的距离矩阵
long long len(long long p,long long &x,long long &y)//计算距离，变换x,y
{
    long long ix=x/p,iy=y/p;
    x%=p;
	y%=p;
    if(ix == 1) y=p-1-y;
    if(iy == 1) x=p-1-x;
    return leng[ix][iy];
}
long long a(long long k,long long x,long long y)//k阶皮亚诺曲线点(0, 0)到点(x, y)的距离
{
    if(k==1) return leng[x][y];
    else return pw[k-1]*pw[k-1]*len(pw[k-1],x,y)+a(k-1,x,y);
}
 
int main()
{
    long long k,xx,yy,xxx,yyy;
    cin>>k>>xx>>yy>>xxx>>yyy;
    if(k>=40)k=39;//k>40无效且爆long long
    pw[0]=1;
    for (int i=1;i<=39;i++) pw[i] = pw[i - 1] * 3;
    long long ans=a(k,xx,yy)-a(k,xxx,yyy);
    cout<<(ans>0?ans:-ans)<<endl;//特判 ans<0 
    return 0;
 
}
```

---

## 作者：keatsli (赞：0)

写在前面：之前别人发的几篇题解都有自然溢出的风险，不过最后减完之后会溢出回来，于是问题不大，不过看他们好像都没说。。。

## 分析

这个图一眼分型，我们具体分析一下：

将一个图包含的小分型分成下面几类：

1. 左下角为“入口”，右上角为“出口”，容易发现其中四个角和中间那块都是这种。

2. 右下角为“入口”，左上角为“出口”，容易发现这种块只会接到第一种块上面，于是左边、右边两个中间的块就是这种。

3. 左上角为“入口”，右下角为“出口”，容易发现这种块只会接到第一种块右边，于是上面、下面两个中间的块就是这种。

我们发现第二种块是第一种块左右对称，第三种块是第一种块上下对称，于是我们可以通过计算一个 $k-1$ 阶的块来得知 $k$ 阶的所有信息。

## 解

### 法 1

可以发现这类问题可以通过递归解决，具体地，设 $f(k,a,b,c,d)$ 是 $(a,b)$ 在 $k$ 阶皮亚诺曲线中到 $(c,d)$ 的距离（不加绝对值，可以为负），我们不妨把这段路径拆开考虑：

我们可以把这段路径分为三段：两端的散点和中间的整块。

容易发现两端的散点可以合并，就是把 $(a,b)$、$(c,d)$ 平移到一个块里就可以计算两端散点的和（需要加上一个整块的大小）。

一个整块内部的路径长度为 $3^{2k-2}-1$，但我们可以给它拼上到下一个块的那条边，于是整块内路径长度变为优美的 $3^{2k-2}$。

然后我们的对称块的操作可以通过对称那两个点来间接实现。

最后我们发现两个点之间的整块个数是 **把整个平面视为一个一阶皮亚诺曲线两点对应块的距离**，可以打个表存下来，记一个点 $(a,b)$ 在一阶皮亚诺曲线中到 $(0,0)$ 的距离为 $D_{a,b}$。

所以 $f(k,a,b,c,d)=(D_{c'',d''}-D_{a'',b''}) \cdot 3^{2k-2}+f(k-1,a',b',c',d')$，其中加撇元素需要通过其对应的块的类型以及位置计算。

### 法 2

一开始把路径差分，之后类似法 1 解决，这里不做赘述。

## 代码

### 法 1

```cpp
#include<bits/stdc++.h>
using namespace std;
#define l int64_t
#define K p[k]
l D[3][3]={{0,1,2},{5,4,3},{6,7,8}},k,a,b,c,d,p[110]={1};
l f(l k,l a,l b,l c,l d){return!(k--)?0:((D[c/K][d/K]-D[a/K][b/K])*K*K+f(k,b/K==1?(K-a%K-1):a%K,a/K==1?(K-b%K-1):b%K,d/K==1?(K-c%K-1):c%K,c/K==1?(K-d%K-1):d%K));}
int main(){
	for(l i=1;i<=100;++i)p[i]=min(p[i-1]*3,(l)2e18);
	return cin>>k>>a>>b>>c>>d,cout<<abs(f(k,a,b,c,d))<<endl,0;
}
```

### 法 2

```cpp
#include<iostream>
using namespace std;
#define l int64_t
#define K p[k]
l D[3][3]={{0,1,2},{5,4,3},{6,7,8}},p[110]={1},k,a,b,c,d;
l f(l k,l x,l y){return!(k--)?0:D[x/K][y/K]*K*K+f(k,(y/K==1)?(K-x%K-1):x%K,(x/K==1)?(K-y%K-1):y%K);}
int main(){
	for(l i=1;i<=100;++i)p[i]=min(p[i-1]*3,(l)2e18);
	return cin>>k>>a>>b>>c>>d,cout<<abs(f(k,a,b)-f(k,c,d)),0;
}
```

~~反正我代码也不可读你抄了也没有学习价值，还不如认认真真分析一下~~

---


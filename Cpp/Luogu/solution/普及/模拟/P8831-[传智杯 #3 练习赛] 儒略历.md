# [传智杯 #3 练习赛] 儒略历

## 题目描述

在 1582 年之前，以 4 为倍数的年份为闰年。正常情况下，一年中一月到十二月的天数分别是 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 天。如果这年是闰年，那么二月则有 29 天。

但某位教皇发现这么做其实不够准确，会造成误差，因此规定从 1582 年开始，以 4 为倍数的年份，除了以 100 为倍数且不为 400 的倍数年份，才是闰年。同时为了消除误差，规定 1582 年 10 月 4 日的下一天是 1582 年 10 月 15 日，中间的日期就当作不存在了。

![](https://cdn.luogu.com.cn/upload/image_hosting/hcelsg2k.png)

现在给出日期，计算这个日期到公元 1 年 1 月 1 日经过的天数。

## 样例 #1

### 输入

```
1JAN1```

### 输出

```
0```

## 样例 #2

### 输入

```
4OCT1582```

### 输出

```
577736```

## 样例 #3

### 输入

```
15OCT1582```

### 输出

```
577737```

## 样例 #4

### 输入

```
21NOV2020```

### 输出

```
737751```

# 题解

## 作者：LegendaryGrandmaster (赞：7)

调了半天终于对了（

----------

Step 1: 读入

如题我们已知输入的格式是 `日 月 年` ，而**月**是用**字符串**表示，所以我们需要把哪一月份给求出来。

根据题目给的缩写，我们就可以打表来计算月份。

```cpp
string month[13]={"","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"};
```

由于我们读入的是个字符串，所以我们紧接着还要把年和日求出来，先求日，再求年。

把字符串转化成数字这应该人人皆知如何处理，这里不做细讲。我们先把前面的数字给**日**，直到出现了字符，我们之后出现的数字才给**年**。

```cpp
for(int i=0;i<st.size();i++){
	if(st[i]>='0'&&st[i]<='9'){
		if(!ok)d*=10,d+=int(st[i]-48ll);//在出现字符之前计算日。
		else y*=10,y+=int(st[i]-48ll);//在出现字符后计算年。
	}
	else mon+=st[i],ok=1;//ok 代表是否出现了字符，mon最终是月份的字符串。
}
```

~~别问我为什么是减去 48ll ,只是防止 ctjer。~~

把月份化成数字也就很方便了。

```cpp
for(int i=1;i<=12;i++)
	if(mon==month[i]){//正好匹配到一样的月份，i 的值即为月份。
		m=i;
		break;
	}
```

-------------------

Step 2: 计算天数

题目由此可以化简为：我们已知现在是 y 年 m 月 d 日，求离 1 年 1 月 1 日多少天。

显然的，y 年**不一定**过完了，m 月也**不一定**过完了，所以我们不能直接加到它们的值，而是要到它们的值 -1。

由题我们又可以把月份分成3种情况：

1. 年 $\lt 1582 $，闰年只需判断是否能被 4 整除。
2. 年 $= 1582$，不是闰年，**10 月少了 10 天**。
3. 年 $\gt 1582$，闰年包括普通和世纪闰年。

--------

普通闰年：能被 4 整除不能被 100 整除。

世纪闰年：能被 400 整除。

~~拓展芝士：闰秒将在2035年取消。~~

---------

根据上述条件，我们也就可以得出代码啦。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string month[13]={"","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"};
int a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};//每个月的天数
signed main()
{
	int d=0,m=0,y=0;
	string st,mon="";
	bool ok=0;
	cin>>st;
	for(int i=0;i<st.size();i++){
		if(st[i]>='0'&&st[i]<='9'){
			if(!ok)d*=10,d+=int(st[i]-48ll);//在出现字符之前计算日。
			else y*=10,y+=int(st[i]-48ll);//在出现字符之前计算年。
		}
		else mon+=st[i],ok=1;//ok 代表是否出现了字符，mon最终是月份的字符串。
	}
	for(int i=1;i<=12;i++)
		if(mon==month[i]){//正好匹配到一样的月份，i 的值即为月份。
			m=i;
			break;
		}
	//cout<<y<<' '<<m<<' '<<d<<'\n';
	if(y<1582)a[2]=(y%4==0?29:28);;//第一种情况。
	else if(y==1582)a[2]=28;;//第二种情况。
	else a[2]=(y%4==0&&y%100!=0||y%400==0?29:28);;//第三种情况。
	if(y==1582&&m>=10&&d>=15)d-=10;//如果正好在1582年的10月15号及以后，减去 10。
	while(m--)d+=a[m];//完整走完的月的总天数。
	while(y--&&y){//完整走完的年的总天数
		if(y<1582)d+=(y%4==0?366:365);//第一种情况。
		else if(y==1582)d+=355;//第二种情况。
		else d+=(y%4==0&&y%100!=0||y%400==0?366:365);//第三种情况。
	}
	cout<<d-1;//因为求的是与 1 年 1 月 1 日之间的天数，d 为天数，所以输出 d-1 。
}

```

代码可能有点漏洞，如有发现请在评论区指出或私聊我，会及时改正。

~~毕竟我不想被撤下题解。~~

---

## 作者：yanhao40340 (赞：6)

一道不算很难的模拟题。[在博客中查看](https://www.luogu.com.cn/blog/yanhao40340/solution-p8831)。

## 题意

求一个日期距公元 $1$ 年 $1$ 月 $1$ 日过了多少天。

## 分析

注：下文中 $y$ 代表年，$m$ 代表月，$d$ 代表日，$i$ 代表枚举时的年份，$j$ 代表枚举时的月份，$k$ 代表枚举时的日期。

因为 $y \le 10^4$，$m \le 12$，$d \le 31$，所以我们可以用一种最为暴力的方法：枚举每一天，然后进行累计。

显然，我们可以写出一个循环体如下：

```cpp
int ans=0;
for (int i=1;i<=9999;++i)
	for (int j=1;j<=12;++j)
		for (int k=1;k<=31;++k,++ans)
```

这样枚举的框架就完成了。时间复杂度：$\Theta(ymd)$。

## 枚举

### 判断月份

- $j=1$ 或 $3$ 或 $5$ 或 $7$ 或 $8$ 或 $10$ 或 $12$，那么 $1\le k \le 31$，则不用提前结束最里层循环。

- $j=4$ 或 $6$ 或 $9$ 或 $11$，那么 $1 \le k \le 30$，即当 $k=31$ 时，要跳出最内层循环。

- $j=2$ 时，如果该年份 $i$ 为闰年，则当 $k=30$ 时跳出循环，否则在 $k=29$ 时就跳出。

### 判断闰年

当 $i < 1582$ 时，以 $4$ 为倍数的年份为闰年。

所以如果 $4 \mid i$，那么该年为闰年。

当 $i \ge 1582$ 时，以 $4$ 为倍数的年份中，除了以 $100$ 为倍数且不为 $400$ 的倍数年份，才是闰年。

所以如果 $\left(4 \mid i \right) \land \left( \left(100 \nmid i \right) \lor \left(400 \mid i \right) \right)$ 时，该年为闰年。

将两式合并，可得

$$\left( i < 1582 \land 4 \mid i \right) \lor \left( i \ge 1582 \land \left(4 \mid i \right) \land \left( \left(100 \nmid i \right) \lor \left(400 \mid i \right) \right) \right)$$

$$=\left(4 \mid i \right) \land \left( i < 1582 \lor \left(100 \nmid i \lor 400 \mid i \right) \right).$$

综上，我们可以写出如下代码用来跳过月份。

```cpp
if ((j==4||j==6||j==9||j==11)&&k==31) break;
if (j==2&&((i%4==0)&&(i<1582||(i%400==0)||(i%100!=0))?k==30:k==29)) break;
```

### 处理跳过的日期

因为 $1582$ 年 $10$ 月 $4$ 日的下一天是 $1582$ 年 $10$ 月 $15$ 日，所以当循环到 $i=1582$，$j=10$，$k=4$ 时，直接将 $k=14$ 即可。

代码大概长这样：

```cpp
if (i==1582&&j==10&&k==4) k=14;
```

【注意】此处不需要跳出循环，因为 $1582$ 年 $10$ 月并没有结束，而跳出循环说明已经结束了。

## 输入

本题输入方式较为特殊，这也是大模拟题目中常考的知识点——输入方式。

因为输入的内容是一个数、三个字母、一个数，所以可以用 `scanf` 来输入。

但是如果直接写 `scanf("%d%s%d",&y,m,&d)` 是错误的，因为读入字符串时会一直读到换行符，把第三个数据也读入了。

所以可以使用 `scanf` 中的占位符来解决此问题，代码如下：

```cpp
int d,m,y;char s[4];
scanf("%d%3s%d",&d,s,&y);
```

判断月份时也不用一直 `if-else` 下去，可以事先打一个月份表，然后循环判断。

## 代码

实现不算很难，但是需要考虑周到。建议先自己手打一遍，附上的代码可以帮助你用来找错。

```cpp
#include <iostream>
using namespace std;
const char ms[13][4]={"   ","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"};
int main(){
	int d,m,y;char s[4];
	scanf("%d%3s%d",&d,s,&y);
	for (int i=1;i<=12;++i)
		if (s[0]==ms[i][0]&&s[1]==ms[i][1]&&s[2]==ms[i][2]){m=i;break;}
	int ans=0;
	for (int i=1;i<=9999;++i)
		for (int j=1;j<=12;++j)
			for (int k=1;k<=31;++k,++ans){
				if (i==y&&j==m&&k==d) return printf("%d\n",ans),0;
				if ((j==4||j==6||j==9||j==11)&&k==31) break;
				if (j==2&&((i%4==0)&&(i<1582||(i%400==0)||(i%100!=0))?k==30:k==29)) break;
				if (i==1582&&j==10&&k==4) k=14;
			}
	return 0;
}

```

---

## 作者：KL_qiqi_ (赞：5)

# 儒略历题解 P8831

今天的模拟赛有这道题，作为首 A 的人，发一篇题解分享一下思路。

## 思路

### No.1 输入

这道题的输入就很不人性化，因为输入字符串的话会把后面的年份也输入进去。那就首先想到输入单个字符。

```cpp
string Get()
{
	string ans;
	char x;
	for (int i = 0; i < 3; i++)
		cin >> x, ans += x;
	return ans;
}

cin >> d;
s = Get();
cin >> y;
```

### No.2 处理月份

虽然我知道可以用 map，但是懒得用，直接打 $12$ 个判断转换整形。~~（毕竟时间很重要）~~
```cpp
if (s == "JAN") m = 1;
else if (s == "FEB") m = 2;
else if (s == "MAR") m = 3;
else if (s == "APR") m = 4;
else if (s == "MAY") m = 5;
else if (s == "JUN") m = 6;
else if (s == "JUL") m = 7;
else if (s == "AUG") m = 8;
else if (s == "SEP") m = 9;
else if (s == "OCT") m = 10;
else if (s == "NOV") m = 11;
else if (s == "DEC") m = 12;
```

### No.3 判断闰年

有两种情况，一种是 $1582$ 年后的，一种是 $1582$ 年前的。
```cpp
bool check2(int x) // 之后
{
	if (x % 400 == 0) return true;
	else if (x % 100 == 0) return false;
	else if (x % 4 == 0) return true;
	else return false;
}
bool check1(int x) // 之前
{
	if (x % 4 == 0) return true;
	else return false;
}
```


### No.4 计算天数

先把完整的年数算完：

- $1582$ 年去除了 $10$ 天，共 $355$ 天。
- $1582$ 年之前 $4$ 年一闰，闰年 $366$ 天。
- $1582$ 年之后 $4$ 年一闰，每 $100$ 年不闰，每 $400$ 年又闰。

```cpp
for (int a = 1; a < y; a++) //从元年枚举到前一年
{
	if (a == 1582) ans += 355;
	else if (check2(a) && a > 1582) ans += 366;
	else if (check1(a) && a < 1582) ans += 366;
	else ans += 365;
}
```
再把完整的月算完：

- $1582$ 年的 $10$ 月只有 $21$ 天。
- $1582$ 年后闰年 $2$ 月和 $1582$ 年前闰年 $2$ 月都是 $29$ 天。
- 平年正常算。

```cpp
int date[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
for (int b = 1; b < m; b++)
{
	if (b == 10 && y == 1582) ans += 21;
	else if (b == 2 && check2(y) && y > 1582) ans += 29;
	else if (b == 2 && check1(y)) ans += 29;
	else if (b == 2) ans += 28;
	else ans += date[b];
}
```

最后把剩下的天数算完：

```cpp
if (m == 10 && y == 1582 && d >= 15) ans += (d - 10); // 注意这里如果是1582年10月只有21天
else ans += d;
```

## Code

~~全代码就不贴了吧，免得有人借鉴。（逃）~~

---

## 作者：kaizel (赞：3)

# solution

这是一道大模拟，思路是先把年月日分别用三个变量 ```ye``` 、 ```da``` 、 ```mo``` 表示出来，然后再根据题目要求一步一步模拟。

---

## Step1：输入

本题目输入是连在一起的，我们先把它们整体输入，再分离开：

```cpp
string s;//定义s为输入的字符串
int da=0;//日期
int ye=0;//年份
string a;//存月份的英文
int mo;//月份
cin>>s;
bool flag=0;//记录是否为日期的数字
for(long long int i=0;i<s.size();i++){//分别把年月日提取出来
	if(flag==0&&s[i]>='0'&&s[i]<='9'){
		da=da*10+s[i]-'0';
	}
	if(s[i]>='A'&&s[i]<='Z'){
		a+=s[i];//因为a是字符串，所以可以直接在后面加一个字符
		flag=1;//记录日期提取完毕
	}
	if(flag==1&&s[i]>='0'&&s[i]<='9'){
		ye=ye*10+s[i]-'0';
	}
}
mo=jb(a);//改变使mo变成月份数字
```

那么 ```jb``` 函数要怎么写呢？

我们可以一个一个把月份判断一下：

```cpp
int jb(string x){
    if(x=="JAN") return 1;
    else if(x=="FEB") return 2;
    else if(x=="MAR") return 3;
    else if(x=="APR") return 4;
    else if(x=="MAY") return 5;
    else if(x=="JUN") return 6;
    else if(x=="JUL") return 7;
    else if(x=="AUG") return 8;
    else if(x=="SEP") return 9;
    else if(x=="OCT") return 10; 
    else if(x=="NOV") return 11;
    else if(x=="DEC") return 12;
}
```

这样就好了。

## Step2：处理闰年

注意：在 $ 1582 $ 年之前 $ 4 $ 年一闰，$ 1582 $ 年之后 $ 400 $ 年一大闰，$ 4 $ 年一小闰，$ 100 $ 的倍数但不是 $ 400 $ 的倍数不闰。

写两个 ```check``` 函数：

```cpp
bool check1(int x){//判断1582年之前是否为闰年
	if(x%4==0) return true;
	else return false;
}
```
```cpp
bool check2(int x){//判断1582年之后是否为闰年
	if(x%400==0) return true;
	else if(x%100==0) return false;
	else if(x%4==0) return true;
	else return false;
}
```

## Step3：处理年份

我们可以先把一年基础的天数加上去，再判断闰年。

```cpp
for(int i=1;i<ye;i++){//遍历年份，注意：不能把输入的年份加上，后面单独处理
    ans+=365;//先把基础的加上
    if(i<=1582){//如果是以前的历法
        ans+=check1(i);//判断闰年
    }else{//现在的历法
        ans+=check2(i);//判断闰年
    }
}
```

## Step4：处理月份

这里直接把输入的年份的月份加上就行，注意：还是不能加到当月，日期最后处理。

```cpp
for(int i=1;i<mo;i++){//遍历月份
    ans+=30;//先加基础的三十天
    if(i!=2){
        if(i==1||i==3||i==5||i==7||i==8||i==10||i==12) ans++;//如果是大月，有31天，所以还需加上一天
    }else{
        ans-=2;//如果是2月，先减掉2天，再判断闰年
        if(ye<1582) ans+=check1(ye);//判断闰年
        else ans+=check2(ye);//判断闰年
    }
}
```

## Step5：处理日期

最后，我们再把日期加上。

```cpp
ans+=da-1;//注意：不能算上当天
```

---

这样，这道题就做完了，看我写的这么认真，点个赞再走吧。

---

## 作者：zaochen (赞：3)

## 一些话  
2020 年的 CSP-S 也有一题叫儒略历（[P7075 [CSP-S2020] 儒略日](https://www.luogu.com.cn/problem/P7075)），难度大于此题。  
此题难度不高，做法是分类讨论。  

## 做法  
本题的难点是计算指定年份指定月份的天数，需要对 1582 年和闰年分类讨论。我的实现方法如下：  
```cpp  
int day[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int get_month(int y,int m){ // 计算 y 年 m 月的天数
    if (m!=2&&y<1582) return day[m]; 
    else {
        if (y<1582){ // 闰年的处理
            if (y%4==0) return 29;
            else return 28;
        }
        else if (y==1582){ // 1582 年 10 月的特判
            if (m==10) return 21;
            else if (m==2) return 28;
        }else {
            if (m!=2) return day[m];
            else { // 闰年的处理
                if ((y%4==0)&&(y%100!=0)) return 29;
                else if ((y%400)==0) return 29;
                else return 28;
            }
        }
    }
    return 0;// 在有返回值类型的函数中，分支结构外写 return 是个好习惯
}
```
然后通过累加月份的天数就可以计算出答案，注意特判 1582 年的 10 月（样例 3）。

## 细节问题  
月份的读入方法需要注意。错误示例：
```cpp  
int y,d;
string m;
cin >> d >> m >> y; 
// 读入 string 类型的 m 时会把后面的数字一起读入
```  

## 代码  
```cpp  
#include <bits/stdc++.h>
using namespace std;
int day[]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int get_month(int y,int m){
    if (m!=2&&y<1582) return day[m];
    else {
        if (y<1582){
            if (y%4==0) return 29;
            else return 28;
        }
        else if (y==1582){
            if (m==10) return 21;
            else if (m==2) return 28;
        }else {
            if (m!=2) return day[m];
            else {
                if ((y%4==0)&&(y%100!=0)) return 29;
                else if ((y%400)==0) return 29;
                else return 28;
            }
        }
    }
    return 0;
}

int get_year(int y){
    int ans=0;
    for (int i=1;i<=12;i++) ans+=get_month(y,i);
    return ans;
}

int read_month(){
    char a,b,c;
    cin >> a >> b >> c;
    string s(1,a);
    s=s+b+c;
    if (s=="JAN") return 1;
    else if (s=="FEB") return 2;
    else if (s=="MAR") return 3;
    else if (s=="APR") return 4;
    else if (s=="MAY") return 5;
    else if (s=="JUN") return 6;
    else if (s=="JUL") return 7;
    else if (s=="AUG") return 8;
    else if (s=="SEP") return 9;
    else if (s=="OCT") return 10;
    else if (s=="NOV") return 11;
    else if (s=="DEC") return 12;
    return 0;
}

signed main(){
    ios::sync_with_stdio(false);
    int y,m,d;
    int ans=0;
    cin >> d;
    m=read_month();
    cin >> y;
    for (int i=1;i<y;i++) ans+=get_year(i);
    for (int i=1;i<m;i++) ans+=get_month(y,i);
    if ((m==10)&&(y==1582)){
        if (d<5) ans+=d;
        else ans+=d-10;
    }
    else ans+=d;
    cout << ans-1 << endl;
    return 0;
}
```

## 结语  
此题思路简单，但是代码实现存在难度。希望大家在赛场上遇到这种题时，写代码仔细一点。祝大家 2022 年第五届传智杯 RP++ 考出自己理想的结果。  

---

## 作者：wuhan1234 (赞：2)

## 1.编程思路。

本题按要求直接模拟即可。

从输入的字符串中解析出给定日期的年（设用变量 $y$ 表示）、月（设用变量 $m$ 表示）、日（设用变量 $d$ 表示）。

要求出给定的日期距公元 $1$ 年 $1$ 月 $1$ 日过了多少天（设用变量 $ans$ 保存）。先计算出前 $y-1$ 年一共有多少天。不考虑闰年的话，一年有 $365$ 天，因此前 $y-1$ 年共有 $(y-1)\times 365$ 天，将这个结果先用 $ans$ 保存。

再考虑前 $y-1$ 年中有多少个闰年，每个闰年多加 $1$ 天。如果 $y\le 1582$，则每 $4$ 年是一个闰年，有 $(y-1)/4$ 个闰年，因此 $ans$ 应加上 $(y-1)/4$；如果 $y>1582$，闰年的判断可以简单描述为：每 $4$ 年一个闰年，每 $100$ 年不是闰年，每 $400$ 年又是个闰年，因此按这样的规则，前 $y-1$ 年的闰年个数为 $(y-1)/4-(y-1)/100+(y-1)/400$，还需加上前 $1582$ 年中每 $100$ 年按新规则不算闰年的年，具体有 $1582/100-1582/400$ 个闰年。

再用循环将第 $y$ 年前 $m-1$ 个月每月的天数也加到 $ans$ 中。

最后 $ans$ 再加上 $d-1$ 就是所求的答案。

由于 $1582$ 年的 $10$ 月少了 $10$ 天，因此对所求的 $ans$ 还需要进行校正一下。例如，当 $y>1582$ 时，$ans$ 需要减去 $10$。具体校正可以参看源程序。

## 2.源程序。

```c
#include <stdio.h>
#include <string.h>
int main()
{
    char month[13][4]={"","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"};
    int table[2][13]={{0,31,28,31,30,31,30,31,31,30,31,30,31},{0,31,29,31,30,31,30,31,31,30,31,30,31}};
    char str[12],ch[4];
    scanf("%s",str);
    int i,k;
    int d,m,y;                      // 分别保存日期数据中的日、月、年
    d=str[0]-'0';
    i=1;
    if (str[1]>='0' && str[1]<='9') // 日d超过了9天，是2位数
    {
        d=d*10+str[1]-'0';
        i++;
    }
    for (k=0;k<3;k++)              // 取得月份的英文缩写
      ch[k]=str[i++];
    ch[k]='\0';
    y=0;
    while (str[i]!='\0')          // 得到年份y
    {
        y=y*10+str[i]-'0';
        i++;
    }
    for (m=1;m<=12;m++)          // 根据月份英文单词缩写求得月份 m
        if (strcmp(ch,month[m])==0) break;
    int ans;
    ans=(y-1)*365;               // 前y-1年共多少天
    if (y<=1582)                 // 闰年每年得多加1天
        ans+=(y-1)/4;
    else
        ans=ans+(y-1)/4-(y-1)/100+(y-1)/400-(1582/4-1582/100+1582/400)+1582/4;
    int leap=0;                 // 闰年标志，leap=1表示当前年是闰年
    if (y<=1582 && y%4==0) leap=1;
    if (y>1582 && ((y%4==0 && y%100!=0) || y%400==0)) leap=1;
    for (i=1;i<m;i++)           // 累计第y年前m-1个月的天数
        ans+=table[leap][i];
    ans+=d-1;
    if (y>1582) ans-=10;       // 年份过了1582年，减去1582年10月少的10天
    else if (y==1582)         // 1582年的特别处理
    {
        if (m>10) ans-=10;
        else if (m==10 && d>=15) ans-=10;
    }
    printf("%d\n",ans);
    return 0;
}

```


---

## 作者：RyanLi (赞：2)

传送门：[P8831 [传智杯 #3 练习赛] 儒略历](https://www.luogu.com.cn/problem/P8831)

看了一圈，题解区（~~其实也就两篇题解~~）没有跟我思路一样的，所以就决定来说说我的思路和实现方法。

看到这题的第一反应是 CSP-S 2020 T1（[P7075 [CSP-S2020] 儒略日](https://www.luogu.com.cn/problem/P7075)），不过这道题要简单得多罢了。又是一道模拟题。

## 分析题意

### 思路

因为不管是平年或者闰年，每年至少都有 $365$ 天（1582 年除外），所以我们可以先把从公元 1 年 1 月 1 日经过的所有 $365$ 天加起来。

然后判断之前经过的每个闰年，把答案加上 $1\times$闰年数，并且加上给定的这一年的天数。

我们知道，1582 年 10 月 5 到 14 日的这 $10$ 天不存在，因此我们需要判断给定的日期是否在 1582 年 10 月 14 日之后，如果是，则在答案上减去这 $10$ 天。

### 声明变量

我们可以声明一个常量数组 `day`，用于存储 **平年** 每个月的天数。

另外，声明 `d`、`m`、`y` 变量分别用于存储日、月、 年，声明 `ans` 变量用于存储答案。

### 处理数据

首先，我们可以声明一个 `init()` 函数，用于初始化数据。依次读入日、月、年，其中因为月是以字符串形式给出的，所以我们需要声明一个字符串变量 `month` 用来获取 `m` 的原始输入数据，再用~~一坨~~条件判断 `month` 是几月。

然后声明一个 `leapyear()` 函数，用来计算从公元 1 年到现在经过了多少个闰年。

最后用一个 `solve()` 函数，按照上面的思路进行计算即可。

## 代码实现

``` cpp
#include <iostream>
using namespace std;

const int day[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int d, m, y, ans;

inline void init() {
    char c = getchar();
    string month;
    // 读入 d
    while (c >= '0' && c <= '9') {
        d = d * 10 + c - '0';
        c = getchar();
    } // 读入 month
    for (int i = 0; c >= 'A' && c <= 'Z'; ++i) {
        month += c;
        c = getchar();
    } // 读入 y
    while (c >= '0' && c <= '9') {
        y = y * 10 + c - '0';
        c = getchar();
    } // 将字符串 month 转化为整形 m
    if (month == "JAN") m = 1;
    else if (month == "FEB") m = 2;
    else if (month == "MAR") m = 3;
    else if (month == "APR") m = 4;
    else if (month == "MAY") m = 5;
    else if (month == "JUN") m = 6;
    else if (month == "JUL") m = 7;
    else if (month == "AUG") m = 8;
    else if (month == "SEP") m = 9;
    else if (month == "OCT") m = 10;
    else if (month == "NOV") m = 11;
    else m = 12;
    return;
}

inline int leapyear(int y) {
    // 先按 1582 年以后的规律粗略计算总数
    int res = (y - 1) / 4 - (y - 1) / 100 + (y - 1) / 400;
    // 因为 1582 前每百年也是有闰年的
    // 从 1 年到 1582 年少计算了 12 个闰年
    if (y >= 1582) res += 12;
    // 如果给定年份在 1582 年以前的话就需要计算少算的闰年数量
    else res += (y - 1) / 100 - (y - 1) / 400;
    return res;
}

inline void solve() {
    // 计算当年
    // 之前的每个月
    for (int i = 1; i < m; ++i)
        ans += day[i];
    // 当月
    ans += d - 1;
    // 当年是闰年并且 m > 2 的话就加 1
    if ((y % 4 == 0 && y % 100 != 0) || y % 400 == 0)
        if (m > 2) ++ans;
    // 之前每一年
    ans += (y - 1) * 365 + leapyear(y);
    // 如果是 1852 年 10 月 15 号以后就减 10
    if ((y == 1582 && m == 10 && d >= 15) || (y == 1582 && m > 10) || y > 1582)
        ans -= 10;
    return;
}

int main() {
    init();
    solve();
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：King_duck (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8831)

这是一道不难的题，只需要模拟一下就行了。

（题外话：题目描述可以作为文化常识了解一下）

接下来切入正题。

### 步骤 $1$：输入

这道题的输入有点难度（~~恶心~~），我们可以输入一个字符串，然后从这个字符串中提取出我们想要的日，月，年。这里就要提到两个函数。
```cpp
isdigit()  stoi()
```
第一个函数是一个判断函数，判断括号里的字符串是否为一个数，是的话返回 $1$，不是则返回 $0$。第二个函数是一个转换函数，如果括号里是一个数，则将它转换成一个 int 类的整数。当然，必须是 c++14 才能使用这两个函数。

有了这两个函数，提取信息就简单得多了。
```cpp
cin>>str;
int len=str.size();
for(int i=0;i<=len;i++)
{
	if(!isdigit(str[i]))
	{
		break;
	}
	day+=str[i];
	idx++;
}
year=str.substr(idx+4);
month=str.substr(idx+1,3);
y=stoi(year);
d=stoi(day);
```

### 步骤 $2$：计算
首先定义一个数组来存储每个月的天数。
```cpp
long long date[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
```

然后转化一下月份，代码如下：
```cpp
void mouth()
{
	if(month=="JAN")
	{
		m=1;
	}
	else if(month=="FEB")
	{
		m=2;
	}
	else if(month=="MAR")
	{
		m=3;
	}
	else if(month=="APR")
	{
		m=4;
	}
	else if(month=="MAY")
	{
		m=5;
	}
	else if(month=="JUN")
	{
		m=6;
	}
	else if(month=="JUL")
	{
		m=7;
	}
	else if(month=="AUG")
	{
		m=8;
	}
	else if(month=="SEP")
	{
		m=9;
	}
	else if(month=="OCT")
	{
		m=10;
	}
	else if(month=="NOV")
	{
		m=11;
	}
	else if(month=="DEC")
	{
		m=12;
	}
}
```
再然后我们可以根据题意用两个函数（一个也可以）来判断一下闰年。（以 $4$ 为倍数的年份，除了以 $100$ 为倍数且不为 $400$ 的倍数年份，才是闰年）
```cpp
bool check1(int x)
{
   	if(x%4==0)
	{
		return true;
	}
   	else
	{
		return false;
	} 
}
bool check2(int x)
{
   	if(x%400==0)
	{
		return true;
	}
   	else if(x%100==0)
	{
		return false;
	}
   	else if(x%4==0)
	{
		return true;
	}
   	else
	{
		return false;
	}
}
```
然后判断闰年并计算年的天数。
```cpp
for(int i=1;i<y;i++)
{
   	if(i==1582)
	{
		ans+=355;
	}
   	else if(check2(i)&&i>1582)
	{
		ans+=366;
	}
   	else if(check1(i)&&i<1582)
	{
		ans+=366;
	} 
   	else 
	{
		ans+=365;
	}
}
```
接着我们算一下月的天数，因为考虑到二月，所以还要用我们刚刚的函数。
```cpp
for(int b=1;b<m;b++)
{
   	if(b==10&&y==1582) 
	{
		ans+=21;
	}
   	else if(b==2&&check2(y)&&y>1582) 
	{
		ans+=29;
	}
   	else if(b==2&&check1(y)) 
	{
		ans+=29;
	}
   	else if(b==2) 
	{
		ans+=28;
	}
   	else 
	{
		ans+=date[b];
	}
}
```
算完天数后我们还要考虑到特殊情况，也就是 $1582$ 年 $10$ 月 $4$ 日的下一天是 $1582$ 年 $10$ 月 $15$ 日。
```cpp
if(m==10&&y==1582&&d>=15) 
{
	ans+=(d-10); 
}
else 
{
	ans+=(d-1);
}
```
最后大功告成了。

[Code](https://www.luogu.com.cn/paste/5kz33dmy)

本蒟蒻第一次交正式题解，求通过

---

## 作者：Wangjunhao2011 (赞：1)

这道题本蒟蒻也是卡样例就卡了一个月了。
### Step -1 判断闰年的函数
因为在 1582 年以前和 1582 之后的判断闰年的方法不一样，所以我们要写两个判断闰年的函数（其实一个也行，只需要在函数里判断这个年的大小，再选择到底是哪个方法）。

代码实现：
```cpp
bool pd1(int n){//判断1582年以前的闰年 
	if(n%4==0){
		return 1;
	}
	else return 0;
}
bool pd2(int n){//判断1582年以后的闰年 
	if(n%4==0){
		if(n%100==0&&n%400==0)return 1;
		else if(n%100==0)return 0;
		else return 1;
	}
	else return 0;
}
```
### Step 0 打表
代码实现：
```cpp
map<string,int>mp;
mp["JAN"]=1,mp["FEB"]=2,mp["MAR"]=3,mp["APR"]=4,mp["MAY"]=5,mp["JUN"]=6,mp["JUL"]=7,mp["AUG"]=8,mp["SEP"]=9,mp["OCT"]=10,mp["NOV"]=11,mp["DEC"]=12;
map<int,int>mpy1;
mpy1[1]=31,mpy1[2]=28,mpy1[3]=31,mpy1[4]=30,mpy1[5]=31,mpy1[6]=30,mpy1[7]=31,mpy1[8]=31,mpy1[9]=30,mpy1[10]=31,mpy1[11]=30,mpy1[12]=31;
map<int,int>mpy2;
mpy2[1]=31,mpy2[2]=29,mpy2[3]=31,mpy2[4]=30,mpy2[5]=31,mpy2[6]=30,mpy2[7]=31,mpy2[8]=31,mpy2[9]=30,mpy2[10]=31,mpy2[11]=30,mpy2[12]=31;
//打表过省一 
```
### Step 1 将字符串转换成具体的年月日
代码实现：
```cpp
int a=0;
int step=0;
string bb;
int c=0;
while(s[step]>='0'&&s[step]<='9')a*=10,a+=(s[step]-'0'),step++;
while(s[step]<'0'||s[step]>'9')bb+=s[step],step++;
while(s[step]>='0'&&s[step]<='9')c*=10,c+=(s[step]-'0'),step++;
//将字符串转换成年月日 
int b=mp[bb];
```
### Step 2 计算从公元 1 年 1 月 1 日到公元 $c-1$ 年的最后一日有多少天
这一步还有两个坑。第一个坑是：如果 ``c>1582`` 的话，在遇到 ``c==1582`` 时还要减去 $10$ 天，因为这中间有 $10$ 天消失了。而第二个坑在 Step -1 说了，因为在 1582 年以前和 1582 之后的判断闰年的方法不一样。所以需要多个分支。

代码实现：
```cpp
int sum=0;
for(int i=1;i<c;i++){
	if(i==1582)sum-=10; 
	if(i<1582){
		if(pd1(i))sum+=366;
		else sum+=365;
	}
	else{
		if(pd2(i))sum+=366;
		else sum+=365; 
	}
}
```
### Step 3 计算从公元 $c$ 年 1 月 1 日到公元 $c$ 年 $b$ 月 1 日有多少天
这一步还是和 1582 有关，具体的就看代码吧。
代码：
```cpp
if(c<1582){
	for(int i=1;i<b;i++){
		if(pd2(c))sum+=mpy2[i];
		else sum+=mpy1[i];
	}
}
else{
	for(int i=1;i<b;i++){
		if(pd1(c))sum+=mpy2[i];
		else sum+=mpy1[i];
	}
}
```
### Step 4 特殊年份1582
在这里我们需要判断要求的日子是否大于 公元 1582 年 10 月 4 日，如果大于还需要减去这不存在的 10 天。

这里代码比较简单就不放代码了。
### Step 5 输出
输出就很简单了我们只需要在 ``sum`` 上加一个天数 $a$ 就行了。

但是需要注意的是这里还需减去 1，原因是日的起端不是从 0 开始的而是从 1 开始的。

这里也就不放代码了，原因和上一步的原因一样。

AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool pd1(int n){//判断1582年以前的闰年 
	if(n%4==0){
		return 1;
	}
	else return 0;
}
bool pd2(int n){//判断1582年以后的闰年 
	if(n%4==0){
		if(n%100==0&&n%400==0)return 1;
		else if(n%100==0)return 0;
		else return 1;
	}
	else return 0;
}
int main(){
	map<string,int>mp;
	mp["JAN"]=1,mp["FEB"]=2,mp["MAR"]=3,mp["APR"]=4,mp["MAY"]=5,mp["JUN"]=6,mp["JUL"]=7,mp["AUG"]=8,mp["SEP"]=9,mp["OCT"]=10,mp["NOV"]=11,mp["DEC"]=12;
	map<int,int>mpy1;
	mpy1[1]=31,mpy1[2]=28,mpy1[3]=31,mpy1[4]=30,mpy1[5]=31,mpy1[6]=30,mpy1[7]=31,mpy1[8]=31,mpy1[9]=30,mpy1[10]=31,mpy1[11]=30,mpy1[12]=31;
	map<int,int>mpy2;
	mpy2[1]=31,mpy2[2]=29,mpy2[3]=31,mpy2[4]=30,mpy2[5]=31,mpy2[6]=30,mpy2[7]=31,mpy2[8]=31,mpy2[9]=30,mpy2[10]=31,mpy2[11]=30,mpy2[12]=31;
	//打表过省一 
	string s;cin>>s;
	int a=0;
	int step=0;
	string bb;
	int c=0;
	while(s[step]>='0'&&s[step]<='9')a*=10,a+=(s[step]-'0'),step++;
	while(s[step]<'0'||s[step]>'9')bb+=s[step],step++;
	while(s[step]>='0'&&s[step]<='9')c*=10,c+=(s[step]-'0'),step++;
	//将字符串转换成年月日 
	int b=mp[bb];
	int sum=0;
	for(int i=1;i<c;i++){
		if(i==1582)sum-=10; 
		if(i<1582){
			if(pd1(i))sum+=366;
			else sum+=365;
		}
		else{
			if(pd2(i))sum+=366;
			else sum+=365; 
		}
	}
	if(c<1582){
		for(int i=1;i<b;i++){
			if(pd2(c))sum+=mpy2[i];
			else sum+=mpy1[i];
		}
	}
	else{
		for(int i=1;i<b;i++){
			if(pd1(c))sum+=mpy2[i];
			else sum+=mpy1[i];
		}
	}
	if(c==1582&&b>=10&&a>4)sum-=10;
	cout<<sum+a-1;
	return 0;
}
```

---

## 作者：yhy152yhy152 (赞：1)

~~简单水个题解~~


------------
蒟蒻第一次写题解，如果有误，敬请斧正。

首先看题面，这是一道简单的模拟题，就是比较复杂，大致分为三个部分。

## **Part1** 输入

输入是个小难点，看输入，先是日期，再是月份，最后是年份，我们只需要定义一个 $flag$ 来判定在输入什么东西就行了。

具体就是开始 $flag$ 定义为 $0$，遍历一遍字符串然后发现是字母变为 $1$，在字母特判一下月份（好长一大段）最后写年份。

## **Part2** 1582 年前的计算

由于 $1582$ 年非常特殊，所以我们把 $1582年10月4日$ 之前和之后分开来计算。

四年是 $1461$ 天，然后对年数取余乘 $365$ 即可。

月份可以定义一个数组存储闰年和平年，然后枚举即可。

日期就直接加上。

## **Part3** 1582 年以后

我们看样例。

有个奇特的样例叫 `15OCT1582`，输出是 `577737`。

这意味着什么？

意味着我们可以直接以这个为初始值，然后跳过 $15$ 号的计算直接算正常的日期。

具体计算方法和上面差不多。

PS：$1582$ 年前和后的闰年判断是不一样的，如果挂了可能是这个，再挂可能是写的有问题。

//代码不挂了，又臭又长，照这个思路打一遍应该就能过了。


---

## 作者：学不会图论的原神玩家 (赞：1)

# 这道题其实不难，如果有耐心一定可以打出来。
 [传送门：](https://www.luogu.com.cn/problem/P8831)

## 思路：
- 输入有点恶心，但一点点分析还是可以将输入分解的。
- 分解后分类讨论重点是细心，不要漏加。
- 输出答案，但记得减一。


### 1. 处理输入（这里只展示一个月的方法，其他的同理）。
```cpp

//一月 。
if(k[i]=='J'&&k[i+1]=='A'&&k[i+2]=='N')
{
	mon=1;
	for(int j=0;j<=i-1;j++)
	{
		day+=k[j]-'0';
		if(j!=i-1)
		day*=10;
	}	
	for(int j=i+3;j<k.length()-6;j++)
	{
		year+=k[j]-'0';
		if(j!=k.length()-7)
			year*=10;
	}
			
}

```
注意加上一段空格防止越界。
```cpp
    k+="      ";
```

### 2. 分类讨论算天数。

当在1582年后：
```cpp
if(year>1582)
{
	for(int i=1;i<=1582;i++)
	{
		ju+=365;
		if(i%4==0)//具题描述，1582年以前闰年判断不同。
			ju+=1;
	}
		
	ju-=10;//1582年十月应减十天
	
	for(int i=1583;i<year;i++)
	{
		ju+=365;
		if((i%4==0&&i%100!=0)||i%400==0)
			ju+=1;
	}
		
	for(int i=0;i<mon-1;i++)
		ju+=a[i];
			
	if(year%4==0&&mon>2)
		ju+=1;//剩下的月。
		
	ju+=day;//剩下的天。
		
	cout<<ju-1;
	return 0;
}
```
当在1582年：
```cpp
if(year==1582)
{
	for(int i=1;i<year;i++)
	{
		ju+=365;
		if(i%4==0)
			ju+=1;
	}
		
	for(int i=0;i<mon-1;i++)
		ju+=a[i];
			
	if(year%4==0&&mon>2)
		ju+=1;
	if(mon>10||(mon==10&&day>=15))
		ju-=10;
		
	ju+=day;
	cout<<ju-1;
	return 0;
}
```

当在1582年以前：
```cpp
if(year<1582)
{
	for(int i=1;i<year;i++)
	{
		ju+=365;
		if(i%4==0)
			ju+=1;
	}
		
	for(int i=0;i<mon-1;i++)
		ju+=a[i];
			
	if(year%4==0&&mon>2)
		ju+=1;
	ju+=day;
	cout<<ju-1;
	return 0;
}
```


最后代码在这：

[here](https://www.luogu.com.cn/paste/wd0zwjrk)


---

## 作者：xiaoming007 (赞：1)

事实上，本题并没有其他解法那么难理解。

## 思路

其他题解都是一个一个年或月分开来算的，但是我们不妨看一下数据范围，年在 $1 \sim 9999$ 之间，这么小的范围我直接暴力计算每过去的一天都不会超时！  
于是呢，我们只需要对于此题的每一个日期，从 $1$ 年 $1$ 月 $1$ 日开始枚举到规定日期，计算其中运行的次数就可以了。  
注意区分 $1582$ 年的 $10$ 月，$10$ 月 $5$ 号于此处是 $10$ 月 $15$ 号。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int day, month, year;
inline void read(){
	char c = getchar();
	while(c >= '0' && c <= '9'){
		day = (day << 1) + (day << 3) + (c ^ '0');
		c = getchar();
	}
	string month2 = "";
	while(c > '9' || c < '0'){
		month2 += c;
		c = getchar();
	}
	if(month2 == "JAN") month = 1;
	if(month2 == "FEB") month = 2;
	if(month2 == "MAR") month = 3;
	if(month2 == "APR") month = 4;
	if(month2 == "MAY") month = 5;
	if(month2 == "JUN") month = 6;
	if(month2 == "JUL") month = 7;
	if(month2 == "AUG") month = 8;
	if(month2 == "SEP") month = 9;
	if(month2 == "OCT") month = 10;
	if(month2 == "NOV") month = 11;
	if(month2 == "DEC") month = 12;
	while(c >= '0' && c <= '9'){
		year = (year << 1) + (year << 3 ) + (c ^ '0');
		c = getchar();
	}
	return ;
}
inline int check_year(int y){
	if(y % 400 == 0 || (y % 100 != 0 && y % 4 == 0)) return 366;
	return 365;
}
inline int check_month(int y, int m){
	if(m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) return 31;
	if(m == 4 || m == 6 || m == 9 || m == 11) return 30;
	//if(y % 400 == 0 || (y % 100 != 0 && y % 4 == 0)) return 29;
	if(y % 400 == 0 || (y % 4 == 0)) return 29;
	return 28;
}
inline int check_month2(int y, int m){
	if(m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10 || m == 12) return 31;
	if(m == 4 || m == 6 || m == 9 || m == 11) return 30;
	if(y % 400 == 0 || (y % 100 != 0 && y % 4 == 0)) return 29;
	return 28;
}
int main(){
	read();
	int _1 = 1, _2 = 1, _3 = 1, flag = 0, cnt = 0;
	while(!(_1 == year && _2 == month && _3 == day)){
		_3++;
		if(flag == 0 && _1 == 1582 && _2 == 10 && _3 == 5){
			_3 = 15;
			flag = 1;
		}
		if(flag == 0){
			if(_3 > check_month(_1, _2)){
				_3 = 1;
				_2++;
				if(_2 > 12){
					_2 = 1;
					_1++;
				}
			}
		}else{
			if(_3 > check_month2(_1, _2)){
				_3 = 1;
				_2++;
				if(_2 > 12){
					_2 = 1;
					_1++;
				}
			}
		}
		cnt++;
	}
	printf("%d\n", cnt);
	return 0;
}
```

---


# [传智杯 #5 初赛] F-二人的大富翁游戏

## 题目背景

作为大学生，莲子和梅莉有着比高中时更为闲暇的课余时光。在没有课的时候，她们喜欢玩大富翁这一游戏，在游玩过程中交流自己的喜怒哀乐。

![](https://cdn.luogu.com.cn/upload/image_hosting/u7z3486k.png)

如图所示，是一个 $n=10$ 的大富翁地图。玩家在圆格子上行动。而方格子则可以建造建筑物。每个圆格子唯一对应一个方格子。

**（友情提示：赌博是不对的）**

## 题目描述

莲子和梅莉在玩大富翁游戏。这个大富翁游戏是由传智播客定制的，**与一般的大富翁游戏在玩法上有略微区别**，因此也被称为传智大富翁。

大富翁游戏是由 $n$ 个格子组成，编号逆时针地从 $1,2,\dots,n$，构成了一个环。莲子和梅莉起始在编号为 $1$ 的格子。莲子和梅莉最开始都有 $m$ 元资金。每一个回合，莲子先投掷骰子，再是梅莉投掷骰子。每一方行动时，设骰子最上面的数字为 $k$，则行动方逆时针移动 $k$ 步。在移动的过程中，行动者所经过的每一个格子应当都分为两种情况：

- 如果当前格子（假设编号为 $i$）上有建筑物，而且建筑物是自己的，则行动方可以获得额外的 $a_i$ 元资金。
- 如果当前格子上有建筑物，但是建筑物是对方的，则行动方要将自己的 $a_i$ 元资金转移给对方。

在行动结束后亦有两种情况：

- 如果当前格子（设编号为 $i$）上没有建筑物，则行动方可以选择花费 $C_{i,0}$ 元资金（前提要求行动者当前的资金大于等于 $C_{i,0}$）搭建建筑物，此时 $a_i$ 被初始化为 $C_{i,0}$。
- 如果当前格子的建筑物是行动方的，假设当前是一座 $j$ 等级的建筑物，那么行动方可以选择用 $C_{i,j}$ 元为建筑物升级，功效是使得 $a_i \gets a_i+C_{i,j}$。这里，$C_{i,j}$ 表示将第 $i$ 个格子上的第 $j$ 等级的建筑物升级到第 $j+1$ 等级的建筑物所需花费的资金。同一回合内可以多次升级建筑。特别地，建筑物的等级上限为 $L$。如果当前建筑物等级已经到达上限则无法升级。
- 在所有建筑操作结束后，操作权转移给另一方。

两人都操作完一轮回合后，圆环上的每个建筑物都会提供给拥有者资金，具体来说，第 $i$ 格上的建筑物会给其拥有者提供 $d_i$ 的资金。游戏结束当且仅当存在一个人在它行动过程中或者结束时的资金为负数。此时这个人成为输家（换而言之，允许中途过程资金为 $0$）。

给定莲子和梅莉的 $q$ 个回合的每次操作，请问谁会是输家呢？

## 说明/提示

**【样例解释 1】**

第一回合，莲子首先走 $4$ 步，到达编号为 $5$ 的格子，同时尝试建造与升级 $3$ 次第五个格子的建筑物，但是 $C_{5,0}+C_{5,1}+C_{5,2}=48$，所以只能把建筑物造到 $2$ 级。此时莲子手上还有 $16$ 元。    
接着梅莉走了两步，到达编号为 $3$ 的格子，同时尝试建造与升级 $5$ 次第三个格子的建筑物，$C_{3,0}+C_{3,1}+C_{3,2}=26$，而造五次会超过等级上限 $L$，因此只能升到 $3$ 次，此时梅莉手上还有 $14$ 元。    
回合结束后每个建筑物都会提供给拥有者 $d_i$ 的资金，也就是说莲子此时手上有 $21$ 元，梅莉手上有 $17$ 元。    
第二回合，莲子首先走 $3$ 步，到达编号为 $2$ 的格子。梅莉接着走 $2$ 步，到达编号为 $5$ 的格子，收取 $a_i$ 元。而 $a_i=24$，因此梅莉的资金被扣成了负数，从而输出 $\texttt{Merry}$。

**【样例解释 2】**

仅在初始资金与第一组样例有一定变化，因此在这些回合中无法决出胜负，因此输出两人手上现有的资金。

**【数据范围】**

对于所有数据，保证 $1 \leq n,L\leq 100$，$1 \leq q \leq 10^4$，$1 \leq m,C_{i,j},d_i \leq 10^6$，$1 \leq k \leq 10^3$（你可以不必在意怎么获得一个 $k$ 面的骰子）。数据保证 $1$ 操作次数恰好为 $2\times q$。

## 样例 #1

### 输入

```
6 40 5 3
10 20 30
15 25 35
6 8 12
6 12 18
8 16 24
8 12 40
1 2 3 4 5 6
1 4
2 3
1 2
2 5
1 3
1 2
2 1
1 5
2 3
1 3
2 4
1 4
1 6
2 2
1 3
2 1
1 3
2 1```

### 输出

```
Merry```

## 样例 #2

### 输入

```
6 9961 5 3
10 20 30
15 25 35
6 8 12
6 12 18
8 16 24
8 12 40
1 2 3 4 5 6
1 4
2 3
1 2
2 5
1 3
1 2
2 1
1 5
2 3
1 3
2 4
1 4
1 6
2 2
1 3
2 1
1 3
2 1```

### 输出

```
10099 9946```

# 题解

## 作者：chen_zhe (赞：12)

题意简述：略。

碎碎念：

> kkk：传智杯要有个模拟题。    
> 我：好

然后就出现了这么一个题。

----

本题是要模拟一个大富翁的过程，作为模拟题，其实没有什么算法上的难度，这个题解也就主要讲解一下细节。

1. 建议将部分操作拆入函数中，方便调试；
2. 更推荐使用 $0$ 和 $1$ 作为下标存放二人数据，这样可以直接用 `id^1` 的方式获得另外一个行动者的各项数据情况，当然你用 $1$ 和 $2$ 的话用 `id^3` 也行，不过感觉不够直观。
3. 读题上的一些细节：
	1. 在移动的过程中，行动者所经过的**每一个格子**应当都分为两种情况。验题人一开始读成了行动结束后的格子，而且我猜也有不少人读错了。
   2. 两人都操作完一轮回合后，圆环上的每个建筑物都会提供给拥有者资金。有的人可能忘记了在游戏结束后也要进行这一轮操作。
4. 数据规模问题。可以构造这样的一组数据：$n=2$，$d_1=d_2=10^6$，$q=10000$，莲子和梅莉在第一回合建好了建筑物，接下来每个回合都可以获得 $d_i$ 元，这样她们就能有 $10^6 \times 10^4=10^{10}$ 元，超过了 int 范围。
5. 其他的想到再补。

这个题作为一个难度在 pjT3 左右的模拟还是比较适合的，有读题细节，有一点码量，也带点坑。希望大家做的愉快。

参考代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <queue>

using namespace std;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int n,m,q,L,C[105][105],d[105],a[105],lv[105],pos[2],belong[105];

long long money[2];

const string name[2]={"Renko","Merry"};

inline void putfail(int id)
{
	cout << name[id] << endl;
	exit(0);
}

inline void forward(int id,int k)
{
	for (int i=1;i<=k;i++)
	{
		int &p=pos[id];
		p++;
		if (p>n)
			p-=n;
		if (belong[p]==id)
			money[id]+=a[p];
		else if (belong[p]==(id^1))
		{
			money[id]-=a[p];
			money[id^1]+=a[p];
		}
		if (money[id]<0)
			putfail(id);
	}
}

inline void build(int id,int k)
{
	int p=pos[id],cost=C[p][lv[p]];
	for (int i=1;(money[id]>=cost && lv[p]<L && (belong[p]==-1 || belong[p]==id) && i<=k);i++)
	{
		belong[p]=id;
		money[id]-=cost;
		a[p]+=cost;
		cost=C[p][++lv[p]];
	}
}

int main()
{
	n=read(),m=read(),q=read(),L=read();
	for (int i=1;i<=n;i++)
	{
		for (int j=0;j<L;j++)
			C[i][j]=read();
	}
	for (int i=1;i<=n;i++)
		d[i]=read();
	pos[0]=pos[1]=1;
	fill(belong+1,belong+n+1,-1);
	money[0]=money[1]=m;
	for (int i=0;i<2*q;i++)
	{
		int op=read();
		begin:
			for (int j=1;j<=n && !(i&1);j++)
			{
				if (belong[j]==0)
					money[0]+=d[j];
				else if (belong[j]==1)
					money[1]+=d[j];
			}
			int k=read();
			forward(i&1,k);
			if (i==2*q-1) {
				int op=0;
				cin >> op;
				if (op==2) {
					k=read();
					build(i&1,k);
				}
				break;
			}
			op=read();
			if (op==1)
			{
				i++;
				goto begin;
			}
			else
			{
				k=read();
				build(i&1,k);
			}
	}
	for (int j=1;j<=n;j++)
	{
		if (belong[j]==0)
			money[0]+=d[j];
		else if (belong[j]==1)
			money[1]+=d[j];
	}
	
	cout << money[0] << " " << money[1] << endl;
	return 0;
}
```

---

## 作者：XYzero (赞：8)

[题目传送门](https://www.luogu.com.cn/problem/P8874)

##  本蒟蒻第一篇题解，求过！！！

## 思路

一个思路简单大模拟，但坑点有点多（调了一晚上），码量适中，直接按照题意模拟即可。

## 坑点
1. 开 long long。

2. 题目较长，可以先浏览一遍，再边仔细看边打。

3. 在代码中注意**注释数组的作用**，以及部分代码的作用，代码最好**模块化**。

4. 输入用。
```cpp
	while(cin >> op >> step)
```
 

## 具体步骤在代码中体现了：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//省事的好方法 
struct house{
	int tot;//属于谁 
	int money;//钱数 
	int d;//等级 
}a[105];
int n,mn,q,l;//格子数、初始资金、回合次数和建筑物等级上限
string name[2] = {"Renko","Merry"};//便于输出 
int c[105][105],d[105],wz[2],m[2];//升级用的钱，建筑等级，人物所在的位置，人物拥有的钱 
void jia(){//加钱操作 
	for(int i = 1;i <= n;i++){
		if(a[i].tot != -1){
			m[a[i].tot] += d[i];
		}
	}
}
signed main(){//必须为 signed
	cin >> n >> mn >> q >> l;
	for(int i = 1;i <= n;i++){
		for(int j = 0;j < l;j++){
			cin >> c[i][j];
		}
	}
	//输入 
	wz[0] = wz[1] = 1;
	m[0] = m[1] = mn; 
	//初始化，
	for(int i = 1;i <= n;i++){
		cin >> d[i];
		a[i].tot = -1;//-1表示没人占领 
		a[i].d = 0;//0级 
	}
	int op,step,tmp = -1,num = 0;//tmp 是现在的行动方 ！ 
	while(cin >> op >> step){
		if(op == 1){
			tmp ++;
		if(tmp >= 2)
		{
			jia();
			tmp = 0;
		}//转换行动方
		    for(int i = 1;i <= step;i++){
				wz[tmp] += 1;
				if(wz[tmp] > n){
					wz[tmp] -= n; //循环起来 
				}
				
				if(a[wz[tmp]].tot == tmp){//是自己的 
					m[tmp] += a[wz[tmp]].money;
				}
				else if(a[wz[tmp]].tot == (!tmp) ){//不是自己的 
					m[tmp] -= a[wz[tmp]].money;
					if(m[tmp] < 0){//破产了 
						cout << name[tmp];
						return 0;//直接结束 
					}
					m[!tmp] += a[wz[tmp]].money;//给对方加钱 
				}
			
			}
		}
		else{
		    if(a[wz[tmp]].tot == (!tmp))continue;//如果不是自己的 
			else{
			
					for(int i = 1;i <= step;i++){
					if(m[tmp] >= c[wz[tmp]][a[wz[tmp]].d ] && a[wz[tmp]].d < l){//自己还有钱升级 
					    int now = wz[tmp];//所处位置 
						m[tmp] -= c[now][a[now].d];
						a[now].money += c[now][a[now].d];//收益增加 
						a[now].tot = tmp; 
						a[now].d += 1;//升级 
					}
					else{
						break;
					}
				}
			}
		}
	}
	jia();//加钱操作
	
	cout << m[0]  << " " << m[1];//如果没有结束就输出前 
	return 0;
}
```










---

## 作者：Farland (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P8874)

[博客食用更佳](https://www.luogu.com.cn/blog/xyzT/solution-p8874)

## 分析

这道题是一个模拟题，虽然说码量较长，但思维简单。

## 坑点

首先，观察数据范围： $1\leq m, C_{i, j},d_{i} \leq 10^6$ 钱数累加很多次，就容易爆 int，所以钱数要开 long long。

原文：

>设骰子最上面的数字为 $k$，则行动方逆时针移动 $k$ 步。**在移动的过程中**，行动者所经过的每一个格子应当都分为两种情况

因此，要边走边判断。

## 代码

先讲一下部分功能的实现：

虽然题目中说了数据保证 $1$ 操作次数恰好为 $2\times q$，但是后面可能夹杂着一个 $2$ 操作，所以说可以用 c++ 特性 `while (cin >> value)`。 这样没有输入时，这句话就会返回 `false`，结束循环。

$w$ 表示行动者，我用 $0$ 和 $1$ 分别表示莲子和梅莉，而 `!w`
 正好可以返回对方的编号，$p$、$id$、$f$ 也均用下标 $0$ 和 $1$ 来表示双方的编号，所以可以直接用 $w$ 去找数组中双方的信息，十分方便。
 
其他操作见代码中的注释

### $\text{\textcolor{#52C41A}{AC}}$ 代码：

```cpp
// 我的码风奇怪，大佬不喜勿喷。
#include <iostream>
#include <cstdio>
#include <string.h>

using namespace std;

const int maxn = 105; // 数组 max 值
int n, m, q, l, c[maxn][maxn] , d[maxn], a[maxn],/* ←详见题面 */ p[maxn],/* p[i]表示第i个格子被谁占领 0代表莲子，1反之 */ h[maxn]/* h[i]表示第i个格子的等级 */ , id[2]/* 表示双方各在什么位置 */;
long long f[2]; // 开 long long 的钱数，表示双方各自的钱数 // 0代表莲子，1反之
int w = -1; // 目前行动者

void pc() // 判断双方是否有一个没钱了
{
    if (f[w] < 0) // 如果行动方没钱了 
    {
        if (w == 0) 
            printf("Renko");
        else
            printf("Merry");
        exit(0); // 退出程序
    }
}

void benifit() // 加钱操作
{
    for (int i = 1; i <= n; i++) // 循环遍历每一个格子
    {
        if (p[i] == -1) continue; // 如果没人占领，则遍历下一个格子
        f[p[i]] += d[i]; // 加钱
    }
}

int main()
{
    memset(p, -1, sizeof(p)); // 将所有格子的建筑设置为无人占领
    scanf("%d%d%d%d", &n, &m, &q, &l);
    f[0] = f[1] = m; // 双方初始均拥有钱数 m f[0]表示莲子的钱；f[1]表示梅莉的钱
    for (int i = 1; i <= n; i++) 
        for (int j = 0; j < l; j++) // 注意等级从 0 开始
            cin >> c[i][j];
    for (int i = 1; i <= n; i++)
        cin >> d[i];
    id[0] = id[1] = 1; // 初始均在位置 1；id[0]表示莲子所在的位置；id[1]表示梅莉所在的位置
    
    int opr, k;
    while (cin >> opr >> k) // 循环直到停止输入
    {
        if (opr == 1) // 操作1
        {
            w++; // 下一个人
            if (w >= 2) // 如果已经结束一轮
            {
                benifit(); // 增加收益
                w = 0; // 重新从莲子开始
            }
            for (int i = 0; i < k; i++) // k 次走动
            {
                id[w] += 1; // 位置增加 1 格
                if (id[w] > n) // 如果超过限制
                    id[w] -= n; 
                if (p[id[w]] == w) // 如果是行动方占领的
                    f[w] += a[id[w]]; // 增加收益
                else if (p[id[w]] == (!w)) // 对方占领
                {
                    f[w] -= a[id[w]], f[!w] += a[id[w]]; // 被收钱
                    pc(); // 判断是否破产
                }
            }
        }
        else // 操作2
        {
            if (p[id[w]] == (!w)) // 如果对方已占领
                continue; // 还升什么级
            int cnt = 0; // 计数器
            while (f[w] >= c[id[w]][h[id[w]]]/* 钱够升下一级 */ && h[id[w]] < l /* 等级没有超出限制 */ && cnt < k /* 要升k次以内的级 */)
                a[id[w]] += c[id[w]][h[id[w]]] , f[w] -= c[id[w]][h[id[w]]] /* 花钱 */, p[id[w]] = w /* 等级 */, h[id[w]]++ /* 等级增加 */, cnt++ /* 计数器自增 */;
        }   
    }
    benifit(); // 最后也不要忘记算一次收益
    cout << f[0] << ' ' << f[1]; // 没分出胜负就输出剩下的钱

    return 0; // 完美结束
}
```



---

## 作者：WsW_ (赞：5)

不再阐述题意，说几点写恶心模拟的注意事项：  
1. 先读完题，想清楚变量怎么开。  
2. 开变量时可以写注释提示自己变量的用途。  
3. 代码中多加入调试代码输出中间变量，输出时可以加上一些文字，不然有时看不出是什么变量、什么意思。  
4. 想不出怎么写就先写输入和定义变量。
5. 代码中多写注释解释这段代码的目的，不然容易忘。  
6. 一字一句读完题，要是挂了但感觉写的没问题那就回来读题。

---

本题与普通大富翁的不同点：  
1. 只要经过别人的就要交钱，只要经过自己的就能拿钱。是经过，不是停在上面。  
2. 两个人各结束一次行动后，按照拥有的建筑得钱。最后一次出循环也是结束行动，也要按拥有的建筑拿钱。

---

代码按顺序模拟即可。  

对于操作一：  
1. 判断是否两人都结束了一轮，若是，则根据建筑发钱。
2. 改变行动方。
3. 走 $k$ 步，一步一步走，每走一步判断当前格子的建筑是不是自己的。若是自己的，则拿钱；若是对手的，给对手钱，并判断钱是否为负数。

对于操作二：
1. 判断当前格子的建筑是不是自己的，如果不是就跳过。
2. 循环 $k$ 次，如果建筑升满了或者钱不够，那么就退出循环。
3. 循环中更改自己的钱、建筑主人、踩到建筑的钱和建筑等级。



代码中的注释都是边写边加的，如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q,L;
//格子数，初始资金，回合，建筑最高等级 

int c[103][103];
//第一个下标代表建筑物的位置，第二个下标代表建筑物的等级 
//c[i][j]代表将i位置建筑物从j升到j+1级要多少钱 

int d[103];
//第i个位置的建筑每回合能给所有者d[i]资金 

int a[103];
//所有者踩到i，赚a[i]
//别人踩到i，给所有者a[i]

int bel[103];
//记录第i个位置建筑是谁的
//1为莲子；2为梅莉

int lv[103];
//记录第i个位置的建筑物等级 

long long mny[3];
//1为莲子的钱；2为梅莉的钱 

int pos[3];
//1为莲子的位置；2为梅莉的位置 

int opt,k;
//opt指操作类型：1.扔骰子；2.升级建筑 
//建筑升级超过L了就不升级 

int act;
//记录当前回合的行动方
//1为莲子；2为梅莉 

int cnt;

void check(){
	if(mny[1]<0){//莲子没钱啦 
		printf("Renko");
		exit(0); 
	}
	if(mny[2]<0){//梅莉没钱啦 
		printf("Merry");
		exit(0); 
	}
}
void fq(){
	for(int i=1;i<=n;i++){//按建筑给大家发钱 
		if(bel[i]){
			mny[bel[i]]+=d[i];
		}
	}
}
int main(){
	scanf("%d%d%d%d",&n,&m,&q,&L);
	for(int i=1;i<=n;i++)
		for(int j=0;j<L;j++)
			scanf("%d",&c[i][j]);
	
	for(int i=1;i<=n;i++)
		scanf("%d",&d[i]);
	
	mny[1]=mny[2]=m;
	pos[1]=pos[2]=1;
	act=2;
	while(scanf("%d%d",&opt,&k)!=EOF){
		if(opt==1){
			if(act==2){//一轮结束 
				fq();
//				cout<<"发钱啦！莲子剩"<<mny[1]<<"元，梅莉剩"<<mny[2]<<"元\n"; 
			}
			act=act%2+1;//转换行动方 
			for(int i=1;i<=k;i++){
				pos[act]=pos[act]%n+1;//圆圈地图，记得取模 
				if(bel[pos[act]]){//该处已被占 
					if(bel[pos[act]]==act){//我的建筑，拿钱啦 
						mny[act]+=a[pos[act]];
					}
					else{//别人的建筑，要给钱QAQ 
						mny[act]-=a[pos[act]];//我扣钱 
						mny[act%2+1]+=a[pos[act]];//别人加钱 
						check();
					}
				}
			}
//			cout<<"  剩"<<mny[act]<<"元\n"; 
		}
		else{
			if(bel[pos[act]]!=act&&bel[pos[act]]){
//				printf("%lld %lld\n",mny[1],mny[2]);
				continue;//不是我的建筑物我升不了级丫qwq 
			}
			for(int i=1;i<=k;i++){//试图升级k次 
				if(mny[act]<c[pos[act]][lv[pos[act]]]){
					break;
					//钱不够升级了QAQ 
				}
				if(lv[pos[act]]>=L){
					break;
					//再升就要超等级啦！ 
				}
				a[pos[act]]+=c[pos[act]][lv[pos[act]]];
				mny[act]-=c[pos[act]][lv[pos[act]]];//交钱升级 
				bel[pos[act]]=act;//这个建筑归我啦qwq 
				lv[pos[act]]++;//注意，等级要最后一个改动 
			}
//			cout<<"建筑升级到"<<lv[pos[act]]<<"级，剩"<<mny[act]<<"元\n";
		}
//		printf("%lld %lld\n",mny[1],mny[2]);
	}
	fq();
	printf("%lld %lld\n",mny[1],mny[2]);
	return 0;
}
```

---

## 作者：CleverRaccoon (赞：1)

## 题目

[题目传送门](https://www.luogu.com.cn/problem/P8874)在此，点击查看题目。

## 思路

直接按照题意模拟即可。

观察数据范围，模拟是不会超时的。

所以首先写出框架：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cin>>n>>m>>q>>l;
	for(int i=1;i<=n;i++)
		for(int j=0;j<l;j++)
			cin>>c[i][j];
	for(int i=1;i<=n;i++)cin>>d[i];
	while(cin>>op>>k){	// 由于不知道要输入多少行，而且 cin>>op>>k 如果读不了了会返回 false，所以直接写 cin>>op>>k 在 while 的循环条件里面就行了。
		if(op==1){
			
		}else{
			
		}
	}
	cout<<qi[0]<<" "<<qi[1]<<endl;	// 都没破产就直接输出他们剩余的钱数。
	return 0;
}
```

注意读入的行数不确定时，直接写 `while(cin>>op>>k)` 就可以了，因为如果读到了末尾，`while` 的循环条件将会变为 `false`，`while` 循环就会自动结束了。

好的，接下来让我们开始定义一系列的变量，做一系列的操作：

1. 定义变量：

这里我们用一个长度为 $2$ 的数组来表示钱，$qi_0$ 是莲子手中的钱数，$qi_1$ 是梅莉手中的钱数，$pos_0$ 和 $pos_1$ 的意思与上面说的 $qi_0$ 和 $qi_1$ 是相近的，只不过前者是表示位置的，后者是表示钱的。

特别地，$qi$ 和 $pos$ 数组的初始化：

```cpp
qi[0]=qi[1]=m;
```

```cpp
pos[2]={1,1};
```

其他变量含义见下面的代码注释：

```cpp
// pos 是位置，qi 是钱，who 是轮到谁，cnt 记录当前回合有几个人走完了，b 是房屋信息，lv 是房屋等级，其他题目中都写了。
int n,m,q,l,pos[2]={1,1},who=1,c[100010][110],d[100010],a[100010],b[100010],lv[100010],op,k,tmp;
long long qi[2];	// 注意要开 long long，否则只能拿 55 分。
```

2. 处理操作一：

首先是移动，移动是当前的值对 $n$ 取模然后加一，就可以实现在一个圆环上面移动的效果了。然后判断是自己挣钱还是给别人钱，只要当前的位置有房子，并且房子是自己的那么就将 `qi[who]` 加上当前房子的价值 `a[pos[who]]`；若当前的位置有房子，但是房子是别人的，那么先将自己的钱减去当前房子的价值，然后再把对方的钱加上当前房子的价值（自己的钱：`qi[who]`，对方的钱：`qi[!who]`）。只有操作一会扣钱，所以操作一时判断一下如果钱小于 $0$，那么当前行动方就输了。

```cpp
for(int i=1;i<=k;i++){	// k 次移动。
	pos[who]=pos[who]%n+1;	// 移动。
	if(b[pos[who]]!=-1){
		if(b[pos[who]]==who)qi[who]+=a[pos[who]];	// 如果是自己的房子，那么就赚钱。
		else if(b[pos[who]]!=-1)qi[who]-=a[pos[who]],qi[!who]+=a[pos[who]];	// 如果是别人的房子，那么就掏钱给别人过路费。
	}
	if(qi[who]<0)print_ans(who);	// 破产了，你就输了。
}
```

```cpp
inline void print_ans(int w){if(w==0)puts("Renko");else puts("Merry");exit(0);}	// 输出最终的答案。
```

3. 处理操作二：

如果是对方已经占领的房子，那么就忽略，直接 `continue` 即可。然后 $i$ 从 $1$ 到 $k$，表示升级的次数。`c[pos[who]][lv[pos[who]]]` 可以得出当前需要付的钱数。每次判断如果钱足够并且级别符合要求就先提升房子的价值，然后花钱，接着登记姓名，最后升级；如果钱不够了或者级别太高，就直接 `break`，因为如果你当前的房子都买不起或级别过高，那么再高一级的房子你更买不起或级别更高了。

```cpp
if(b[pos[who]]==!who)continue;	// 如果是对方已经占领的房子，那么就忽略。
for(int i=1;i<=k;i++){
	if(qi[who]>=c[pos[who]][lv[pos[who]]]&&lv[pos[who]]<l)	// 有钱并且等级没有超过 L。
		a[pos[who]]+=c[pos[who]][lv[pos[who]]],qi[who]-=c[pos[who]][lv[pos[who]]],b[pos[who]]=who,++lv[pos[who]];	// 1.提升价值；2.花钱；3.登记姓名；4.升级。
	else break;	// 当前这个等级的房子不能买，下一个等级的就更不能买了。
}
```

下面我来具体说一下这道题要注意的地方。

1. 只有两个人。

我看有的题解是把莲子和梅莉的房屋、钱数等信息写成两段除了名字几乎一模一样的代码进行处理的，但其实每次进行操作时，可以使用一个变量 $who$ 巧妙地记录当前操作的是谁，$0$ 代表莲子，$1$ 代表梅莉，所以每次只需要将这个变量切换一下，就代表下一个人操作了，代码如下所示：

```cpp
who=!who;
```

那么，什么时候做这件事呢？切换行动方需要在一方已经结束了自己这回合的操作后。每个人一回合一定会有且仅有一次操作一，但是操作二就不一定了，有可能有一次或者一次都没有。所以如果遇到了操作一，就要切换行动方。因此，一开始我们的行动方也要设为梅莉，因为第一次操作一的一开始就会改变行动方，将行动方交给莲子。初始化行动方的代码如下：

```cpp
int who=1;
```

2. 每回合结束后，圆环上的每个建筑物都会提供给拥有者资金。

这个问题使我调了很长时间，希望大家能避开这个坑。

先不说建筑物如何给拥有者提供资金，先说一说什么时候干这件事。一定要在**操作一且行动方是梅莉**时，否则就会得到 $55$ 分的好成绩。因为梅莉是后手方，她行动完以后这回合就结束了。有人可能会问：刚开始第一回合的第一个操作一时的行动方就是梅莉啊，一开始还什么都没干了就给他们钱？那么我会问你一个问题：建筑物给拥有者提供资金时，建筑物没有拥有者，他还能给谁提供资金呢？另外，所有回合结束后，还要再计算一遍建筑物给拥有者提供的资金，因为虽然当前行动方是梅莉了，但是这个判断是在操作一里面的，游戏已经结束，不会再有操作一了。以下是建筑物给拥有者提供资金的代码：

```cpp
for(int i=1;i<=n;i++)
	if(b[i]!=-1)	// 存在这个房子。
		qi[b[i]]+=d[i];	// 计算房屋收益。
```

3. 钱数有可能爆 `int`。

所以，$qi$ 数组要开 `long long`。

4. 房屋信息的问题。

$b$ 数组中，$0$ 代表莲子，$1$ 代表梅莉，那么 $-1$ 就代表这座房子不存在。因此，在开始游戏之前，要初始化 $b$ 数组：

```cpp
memset(b,-1,sizeof b);	// b 是 -1 时表示这块地上面没有房屋。
```

## 代码

说了这么多，接下来放完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
// pos 是位置，qi 是钱，who 是轮到谁，cnt 记录当前回合有几个人走完了，b 是房屋信息，lv 是房屋等级，其他题目中都写了。
int n,m,q,l,pos[2]={1,1},who=1,c[100010][110],d[100010],a[100010],b[100010],lv[100010],op,k,tmp;
long long qi[2];	// 注意要开 long long，否则只能拿 55 分。
inline void print_ans(int w){if(w==0)puts("Renko");else puts("Merry");exit(0);}	// 输出最终的答案。
int main(){
	memset(b,-1,sizeof b);	// b 是 -1 时表示这块地上面没有房屋。
	cin>>n>>m>>q>>l;	// 这个 q 好像没用上。
	qi[0]=qi[1]=m;
	for(int i=1;i<=n;i++)
		for(int j=0;j<l;j++)
			cin>>c[i][j];
	for(int i=1;i<=n;i++)cin>>d[i];
	while(cin>>op>>k){	// 由于不知道要输入多少行，而且 cin>>op>>k 如果读不了了会返回 false，所以直接写 cin>>op>>k 在 while 的循环条件里面就行了。
		if(op==1){
			if(who==1){	// 如果两个人都走完了，就代表这回合结束了，此时记录 d 数组中房屋带来的收益。
				for(int i=1;i<=n;i++)
					if(b[i]!=-1)	// 存在这个房子。
						qi[b[i]]+=d[i];	// 计算房屋收益。
			}
			who=!who;	// 更换行动者。
			for(int i=1;i<=k;i++){	// k 次移动。
				pos[who]=pos[who]%n+1;	// 移动。
				if(b[pos[who]]!=-1){
					if(b[pos[who]]==who)qi[who]+=a[pos[who]];	// 如果是自己的房子，那么就赚钱。
					else if(b[pos[who]]!=-1)qi[who]-=a[pos[who]],qi[!who]+=a[pos[who]];	// 如果是别人的房子，那么就掏钱给别人过路费。
				}
				if(qi[who]<0)print_ans(who);	// 破产了，你就输了。
			}
		}else{
			if(b[pos[who]]==!who)continue;	// 如果是对方已经占领的房子，那么就忽略。
			for(int i=1;i<=k;i++){
				if(qi[who]>=c[pos[who]][lv[pos[who]]]&&lv[pos[who]]<l)	// 有钱并且等级没有超过 L。
					a[pos[who]]+=c[pos[who]][lv[pos[who]]],qi[who]-=c[pos[who]][lv[pos[who]]],b[pos[who]]=who,++lv[pos[who]];	// 1.提升价值；2.花钱；3.登记姓名；4.升级。
				else break;	// 当前这个等级的房子不能买，下一个等级的就更不能买了。
			}
		}
	}
	for(int i=1;i<=n;i++)
		if(b[i]!=-1)	// 存在这个房子。
			qi[b[i]]+=d[i];	// 计算房屋收益。
	cout<<qi[0]<<" "<<qi[1]<<endl;	// 都没破产就直接输出他们剩余的钱数。
	return 0;
}
```

THE END.

---

## 作者：wuhan1234 (赞：1)

## 1.编程思路。
本题是一道模拟题，直接模拟 $q$ 个回合两名游戏者的操作即可。

在对 $q$ 个回合的操作数据的输入处理时需要注意的是，操作数据的输入行不一定是 $4\times q$ 行，其具体行数最少为 $2\times q$ 行，最多为 $4\times q$ 行，因此读取操作数据输入的循环控制条件采用读数据到文件尾。

具体的细节可以参看代码注释。

## 2.源程序。
```c
#include <stdio.h>
#include <string.h>
int main()
{
    int n,m,q,L;
    scanf("%d%d%d%d",&n,&m,&q,&L);
    int C[105][105],d[105],a[105];
    int level[105];    // level[i]的值表示第i个格子上建筑物的等级
    int belong[105];   // belong[i]=0（或1）表示第i个格子上建筑物是莲子（或梅莉）建造的
    int i,j;
    for (i=1;i<=n;i++)
        for (int j=0;j<L;j++)
            scanf("%d",&C[i][j]);
    for (i=1;i<=n;i++)
    {
        scanf("%d",&d[i]);
        level[i]=0;
        belong[i]=-1;     // 初始时每个格子上没有建造建筑物
    }
    int pos[2];          // pos[0]和pos[1]分别保存莲子和梅莉当前的位置
    long long money[2]; // money[0]和money[1]分别保存莲子和梅莉当前的资金
    pos[0]=pos[1]=1;
    money[0]=money[1]=m;
    int op,k,p;
    int cur=1;   // cur保存当前游戏者的身份，0为莲子，1为梅莉，初始时设为1，
                 // 每次1操作切换，这样第1个1操作就切换到莲子
    int flag=0;  // 是否确定了胜负，若中间确定了胜负，将后面的输入数据还是读完
    while (scanf("%d%d", &op, &k)!=EOF)   // // 进行q回合的游戏模拟
    {
        if (flag) continue;   // 中间确定了胜负，后面直接将输入数据读完
        if (op == 1)
        {
            if (cur == 1)     // 当前游戏者由梅莉切换到莲子，1回合游戏结束，进行结算
            {
                for (i=1;i<=n;i++)
                    if (belong[i] != -1) money[belong[i]] += d[i];
            }
            cur ^= 1;        // 当前游戏者身份切换
            for (i=1;i<=k;i++)
            {
                pos[cur] = (pos[cur]) % n + 1;
                p = pos[cur];
                if (belong[p] == cur)       // 走到了自己建筑物所在的格子，获得资金
                    money[cur] += a[p];
                else
                {
                    if (belong[p] == 1-cur) // 走到了对方建筑物所在的格子，转移资金
                    {
                        money[1-cur] += a[p];
                        money[cur] -= a[p];
                        if (money[cur] < 0)
                        {
                            flag=cur+1;   // 已确定胜负，同时用flag保存胜负者身份
                            break;
                        }
                    }
                }
            }
        }
        else                             // 操作2，进行当前位置的建筑物升级处理
        {
            p = pos[cur];
            while (k && level[p] < L && money[cur] >= C[p][level[p]] && belong[p] != 1-cur)
            {
                money[cur] -= C[p][level[p]];  // 升级花费
                a[p] += C[p][level[p]];        // 升级后的功效
                level[p]++;                    // 建筑物等级提升1级
                belong[p] = cur;               // 建筑物的归属确定
                k--;                           // 可升级次数减1
            }
        }
    }
    if (flag!=0)
        printf("%s\n",flag-1 ? "Merry" : "Renko");
    else
    {
        for (i=1;i<=n;i++)    // 最后一个回合结束后的结算
           if (belong[i] != -1) money[belong[i]] += d[i];
        printf("%lld %lld\n", money[0], money[1]);
    }
    return 0;
}

```


---

## 作者：continueOI (赞：0)

写在最前：本代码目前开 O2 为最优解，不开 O2 用 `cin` 输入目前也比其他所有代码要快，常数极小，但是代码很长，有 125 行。

[超强常数优化代码测评记录](https://www.luogu.com.cn/record/116508285)

这道题就是大模拟，没有别的算法与思想难度，就在这里说几个注意事项：

1. 先仔细审题，把题读个两三遍再写，一边写题一边看题，不要漏点。注意分清楚是回合结束还是一个人行动结束，建筑物升级后过路费不是 $C _{i,j}$！

2. 仔细写代码，想好每个变量怎么开，是干什么用的，为什么要这样做，与题意是否相符，否则写完后重构直接升天。

3. 不要先优化，先把题过了！否则代码将会很难理解！

然后再讲一下我的做题思路（题目的注意事项都写在注释里了）：

首先，定义一个结构体存房子的信息：

```cpp
struct node{
	int c[110],d,who,level,a;
	//c为升级所需要的钱与升级的收益，d为每回合结束后的发钱，
	//who为这座房子是谁的，level为等级，a为这座房子的过路费
}house[110];
```

非常清楚明白，一个好的数据结构能让你写代码思路更加清晰。

然后再读取数据，进行操作：

如果是操作 1：

```cpp
if(now==0) {//莲子回合 
	for(int i=1; i<=k; i++) {//行走k步，经过的每间房子都要交过路费！ 
		lian++;//lian代表莲子现在走到哪 
		if(lian>n) lian-=n;//链表结构 
		if(house[lian].who==2) {//如果是梅莉的房子 
			lmo-=house[lian].a;//交钱 
			mmo+=house[lian].a;
			if(lmo<0) {
				puts("Renko");//显然可知，只有在交钱后莲子才可能会破产 
				return 0;
			}
		}
		if(house[lian].who==1)
			lmo+=house[lian].a;//如果是莲子的房子，获得钱 
	}
	now=1;//下一步为梅莉回合 
} else {//同理 
	for(int i=1; i<=k; i++) {
		mei++;
		if(mei>n) mei-=n;
		if(house[mei].who==1) {
			mmo-=house[mei].a;
			lmo+=house[mei].a;
			if(mmo<0) {
				puts("Merry");
				return 0;
			}
		}
		if(house[mei].who==2)
			mmo+=house[mei].a;
	}
	now=0;
	tmp=2;//一个回合结束了 
}
```

如果是操作 2：

```cpp
if(now==1) {//因为之前莲子回合已经修改now值，所以now=1时这为莲子回合 
	if(house[lian].who==2) continue;//如果是梅莉的房子，忽略 
	else {
		for(int i=1; i<=k; i++) {//升级k次 
			if(house[lian].level==0) {//如果没建房子 
				if(lmo>=house[lian].c[0]) {//钱够了 
					lmo-=house[lian].c[0];//扣钱 
					house[lian].who=1;//建房子 
					house[lian].level=1;//等级为1 
					house[lian].a=house[lian].c[0];//过路费为C_i,j 
				} else {
					break;//没钱直接退出 
				}
			} else {//如果建了房子 
				if(house[lian].level==L) break;//等级已满 
				if(lmo>=house[lian].c[house[lian].level]) {//钱足够 
					lmo-=house[lian].c[house[lian].level];
					house[lian].a+=house[lian].c[house[lian].level];
					house[lian].level++;//类似的操作 
				} else {
					break;
				}
			}
		}
	}
} else {//梅莉回合同理 
	if(house[mei].who==1) continue;
	else {
		for(int i=1; i<=k; i++) {
			if(house[mei].level==0) {
				if(mmo>=house[mei].c[0]) {
					mmo-=house[mei].c[0];
					house[mei].who=2;
					house[mei].level=1;
					house[mei].a=house[mei].c[0];
				} else {
					break;
				}
			} else {
				if(house[mei].level==L) break;
				if(mmo>=house[mei].c[house[mei].level]) {
					mmo-=house[mei].c[house[mei].level];
					house[mei].a+=house[mei].c[house[mei].level];
					house[mei].level++;
				} else {
					break;
				}
			}
		}
	}
}
```

然后最后就是发钱阶段。

由于只有两个人都走完并建完房子后才会发钱，所以我们在梅莉走完步后将 `tmp` 设为 2，当再次进行操作 1 时发钱，最后所有回合结束后再发一次钱，容易可证，这是正确的。

```cpp
//放在走路的莲子回合的前面，在输入所有操作完后再在输出钱之前放一个
if(tmp==2) {
	for(int i=1; i<=n; i++) {
		if(house[i].who==2)
			mmo+=house[i].d;
		if(house[i].who==1)
			lmo+=house[i].d;
	}
	tmp=0;
}
```

最后总代码就不放了，想要~~抄题解的同学们~~[~~看这里~~](https://www.luogu.com.cn/paste/thz1g4zo)

最后我想说：

钱一定要开 `long long` 啊，被卡了半小时……

---


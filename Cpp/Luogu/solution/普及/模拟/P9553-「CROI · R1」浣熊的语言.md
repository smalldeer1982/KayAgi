# 「CROI · R1」浣熊的语言

## 题目背景

$\texttt{[2023.08.17 21:44]：}$ 为防止神奇的暴力做法通过，本题时限改为 $500\ ms$。

> 他复瞑着，沙地上的文字。\
> 词句，日忆夜诵，挥翰成风；夜幕下，星罗棋布。\
> 新意，呼之欲出，似即却离；叹气里，功败垂成。\
> 她释然一笑，潇然起身，轻叩他的后背。\
> 却见流光间，熊爪翻飞；夜风中，新词真切。\
> “你做到了……”\
> 平凡的仲夏夜，深刻的文字。\
> 忆诵的努力，闪烁着星光……

## 题目描述

小浣熊 CleverRaccoon 遵循浣熊的单词遗忘曲线，从第 $1$ 天开始背单词。

一共有 $n$ 个单词，正常情况下，第 $i$ 个单词将在第 $d_i$ 天首次学习。

同时，每个单词都会安排 $k$ 次复习，对于第 $j$ 次复习有复习点 $t_j$，表示正常情况下，每个单词在**首次学习后** $t_j$ 天都会安排这个单词的复习。换言之，第 $i$ 个单词的第 $j$ 次复习时间为第 $d_i+t_j$ 天。

另外，还有 $m$ 天为特殊情况，第 $i$ 次特殊情况发生在 $s_i$ 天。小浣熊 CleverRaccoon 在当日忘记背单词了，与当日冲突的首次学习或复习时间将顺延至第二天学习或复习。
- 若某单词的首次学习时间顺延至第二天，则该单词按**顺延后**的首次学习时间安排复习。
- 若某单词的当次复习时间顺延至第二天，则**不影响**该单词的后续复习时间。
- 若多个学习或复习时间重合于一天，则当天需要进行**多次**学习或复习。

小浣熊 CleverRaccoon 想知道：学习和复习完所有单词需要的天数、每天新学单词数、每天复习单词数。

## 说明/提示

设依次输入的单词编号分别为 $1 \sim n$。
#### 样例解释 #1
| 天数 | 新学单词编号 | 新学单词数量 | 复习单词编号 | 复习单词数量 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $1,2,3$ | $3$ | $-$ | $0$ |
| $2$ | $4$ | $1$ | $1,2,3$ | $3$ |
| $3$ | $5$ | $1$ | $1,2,3,4$ | $4$ |
| $4$ | $-$ | $0$ | $4,5$ | $2$ |
| $5$ | $-$ | $0$ | $5$ | $1$ |

#### 样例解释 #2
| 天数 | 新学单词编号 | 新学单词数量 | 复习单词编号 | 复习单词数量 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ (special) | $-$ | $0$ | $-$ | $0$ |
| $2$ | $1,2,3,4$ | $4$ | $-$ | $0$ |
| $3$ | $5$ | $1$ | $1,2,3,4$ | $4$ |
| $4$ | $-$ | $0$ | $1,2,3,4,5$ | $5$ |
| $5$ | $-$ | $0$ | $5$ | $1$ |

#### 样例解释 #3
| 天数 | 新学单词编号 | 新学单词数量 | 复习单词编号 | 复习单词数量 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $1$ | $1$ | $-$ | $0$ |
| $2$ | $2$ | $1$ | $1$ | $1$ |
| $3$ (special) | $-$ | $0$ | $-$ | $0$ |
| $4$ | $3,4$ | $2$ | $1,1,2,2$ | $4$ |
| $5$ | $5$ | $1$ | $2,3,4$ | $3$ |
| $6$ | $-$ | $0$ | $3,4,5$ | $3$ |
| $7$ | $-$ | $0$ | $3,4,5$ | $3$ |
| $8$ | $-$ | $0$ | $5$ | $1$ |

#### 数据范围

**本题采用 Subtask 捆绑测试。**

对于 $100\%$ 的数据，保证 $1\leq n\leq 10^6,0\leq m\leq 200,1\leq k,d_i,t_i\leq 10^3,s_m < d_n$。保证 $d$ 单调不减，$t,s$ 单调递增。

|Subtask|$n$|$m$|$k$|$d_i$|$t_i$|Score|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$0$|$\leq 100$|$=0$|$\leq 10$|$\leq 100$|$\leq 100$|$5$|
|$1$|$\leq 10^3$|$=0$|$\leq 100$|$\leq 10^3$|$\leq 100$|$20$|
|$2$|$\leq 100$|$\leq 10$|$\leq 10$|$\leq 100$|$\leq 100$|$15$|
|$3$|$\leq 10^3$|$\leq 100$|$\leq 100$|$\leq 10^3$|$\leq 100$|$25$|
|$4$|$\leq 10^6$|$\leq 200$|$\leq 10^3$|$\leq 10^3$|$\leq 10^3$|$35$|

## 样例 #1

### 输入

```
5 0 2
1 1 1 2 3
1 2```

### 输出

```
5
3 0
1 3
1 4
0 2
0 1```

## 样例 #2

### 输入

```
5 1 2
1 1 1 2 3
1
1 2```

### 输出

```
5
0 0
4 0
1 4
0 5
0 1```

## 样例 #3

### 输入

```
5 1 3
1 2 3 4 5
3
1 2 3```

### 输出

```
8
1 0
1 1
0 0
2 4
1 3
0 3
0 3
0 1```

# 题解

## 作者：Su777 (赞：11)

出题人题解。

## 题意简述

有 $n$ 个单词，每个单词在第 $d_i$ 天首次学习。又有 $m$ 天特殊情况，该天单词顺延至第二天学习。

有一个适用于每个单词的遗忘曲线数组 $t$，长度为 $k$，其中 $t_i$ 代表这个单词在**顺延后的**首次学习时间之后 $t_i$ 天会安排复习。

问几天可以学完单词（从数值为 $1$ 的那一天开始计算），以及每一天新学多少单词，复习多少单词。

## 解题思路

本题根据题意模拟即可。枚举每一个单词的新学时间，再加上 $t_i$，不就做完了？上代码！

......

是这样的吗？这样的时间复杂度 $O(nk)$，考虑到 $n$ 较大，最后一个 Subtask 运行时间为 $10^9$ 数量级，会 TLE。但是怎么优化呢？

需要注意的是我们并不关心具体某个单词，只关心每天学习**单词数量**。而且单词多个复习点重叠不需要进行去重，并且所有单词遗忘曲线相同，所以使用数组累加答案。用数组 `new_words` 累加新学单词数量（以下简称 $nw$），用数组 `old_words` 累加复习单词数量（以下简称 $ow$）。

因为只关心学习单词个数，所以读入数组 $d$ 时就可以预处理每天的新学单词数量。又因为数组 $d$ 单调不减，所以 $d_n$ 一定为数组元素最大值。

因此从 $1$ 枚举到 $d_n$，对于每一天，如果新学单词数量非零，那么把这一天所有单词对应的复习点的复习单词数量加上这一天的新学单词数量。形式化地，就是对于每一个 $nw_i≠0$，将每一个 $ow_{i+t_j}(1\leq j \leq k)$ 加上 $nw_i$。注意在枚举前后都需要进行一次对于特殊情况的向后累加。

在累加复习单词数量的同时，记录 $maxd$ 表示列举到的最大时间数值。

对于 $m$ 次特殊情况，直接将单词数量往下一个位置上累加即可。具体细节见代码注释。

由于数组 $d$ 单调不减，所以正解总体算法复杂度为 $O(d_nk)$。

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
int n, m, k;
int d[1000006], s[1003], t[1005];
int new_word[1001006];
int old_word[1001006];

int main() {
	scanf("%d%d%d", &n, &m, &k);
	int maxd = 0;
	for (int i = 1; i <= n; i ++) {
		scanf("%d", &d[i]);
		new_word[d[i]] ++;
		maxd = max(maxd, d[i]);
	}
	for (int i = 1; i <= m; i ++) {
		scanf("%d", &s[i]);
	}
	for (int i = 1; i <= k; i ++) {
		scanf("%d", &t[i]);
	}

	for (int i = 1; i <= m; i ++) {
		new_word[s[i] + 1] += new_word[s[i]];
		new_word[s[i]] = 0;
	}

	for (int i = 1; i <= maxd; i ++) {
		if (new_word[i] != 0) {
			for (int j = 1; j <= k; j ++) {
				old_word[i + t[j]] += new_word[i];
				maxd = max(maxd, i + t[j]);
			}
		}
	}

   for (int i = 1; i <= m; i ++) {
      	new_word[s[i] + 1] += new_word[s[i]];
		new_word[s[i]] = 0;
      	old_word[s[i] + 1] += old_word[s[i]];
		old_word[s[i]] = 0;
	}
	
	while (new_word[maxd] == 0 and old_word[maxd] == 0) maxd --;
	printf("%d\n", maxd);
	for (int i = 1; i <= maxd; i ++) {
		printf("%d %d\n", new_word[i], old_word[i]);
	}
	return 0;
}
```

---

## 作者：Code_Select_You (赞：3)

## 本题思路
这道题就是一道模拟题，直接根据题意模拟就行。

但直接模拟每一个单词在哪天学习、复习的话时间复杂度为 $O(nk)$，在 $n=10^6$，$k=10^3$ 时会TLE，所以要优化一下。

题目要我们求的是每天学习、复习的单词数，所以我们并不用一个单词一个单词的算，而是用两个数组来存每天学习、复习的单词数。

如 $x_i$ 表示第 $i$ 天学的单词数，$y_i$ 表示第 $i$ 天复习的单词数。这样读入 $d_i$ 时就更新 $x_i$，读入 $m_i$ 时，就把 $x_i$ 给 $x_{i+1}$。处理完后令 $day$ 表示最后的天数。扫一遍 $d$，如果 $d_i$ 非空，就把这一天的单词的所有复习点那天的复习数量加上这一天的新学单词数量，然后更新  $day$。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d[1000010],k,t[1010],m,s[205],x[1000010],y[1000010],day;//day表示最后天数,x是每天学习的,y是每天复习的。 
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;++i){
		scanf("%d",&d[i]);
		x[d[i]]++;
	}
	for(int i=1;i<=m;++i){//特殊日期
		scanf("%d",&s[i]);
		if(x[s[i]]>0){
			x[s[i]+1]+=x[s[i]];
			x[s[i]]=0;
		}
	}
	for(int i=1;i<=k;++i) scanf("%d",&t[i]);
	for(int i=1;i<=d[n];++i){//复习 
		if(x[i]>0){
			for(int j=1;j<=k;++j){
				y[i+t[j]]+=x[i];//复习 
				day=max(day,i+t[j]);//更新天数 
			}
		}
	}
	for(int i=1;i<=m;++i){//特殊日期 
		if(y[s[i]]>0){
			y[s[i]+1]+=y[s[i]];
			y[s[i]]=0;
		}
	}
	printf("%d\n",day);
	for(int i=1;i<=day;++i) printf("%d %d\n",x[i],y[i]);
	return 0; 
}
```


---

## 作者：One_JuRuo (赞：2)

这道题直接模拟就很容易过。

因为如果单词的首次学习时间被推迟，那么会影响后续的复习计划，所以可以先把每个单词的首次学习时间算出来，再拿个数组存一下就好。

```
/*vis[i]代表第i天是否为特殊情况，d[i]同题意，stu[i]代表在第i天首次学习的单词数量*/
for(int i=1;i<=n;++i)
{
	while(vis[d[i]]) ++d[i];
	++stu[d[i]];
}
```

然后先忽略特殊情况把所有单词的所有复习时间算出来，拿个数组存好。

```
/*t[i]同题意，rev[i]代表在第i天复习的单词数量*/
for(int i=1;i<=n;++i)
	if(d[i]!=d[i-1])//同一天的可以一次加完就不用每个单词都去模拟了
    	for(int j=1;j<=k;++j)
        rev[d[i]+t[j]]+=stu[d[i]];
```

然后再暴力枚举每天的复习单词，如果恰好有特殊情况，就往前挪一下就好了。

```
sum=d[n]+t[k];//sum统计总共时长，因为题目保证了d[i],t[i]的单调性，所以d[n],t[k]一定是最大的
for(int i=1;i<=sum;++i)
	if(rev[i]&&vis[i])
    	rev[i+1]+=rev[i],rev[i]=0,sum=max(sum,i+1);//往前挪，顺带更新sum
```

最后就是输出了。

## AC 代码（有亿点压行）

```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[2005];
int n,m,k,d[1000005],s,t[2005];
int stu[2005],rev[2005],sum;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;++i) scanf("%d",&d[i]);
	for(int i=1;i<=m;++i) scanf("%d",&s),vis[s]=1;
	for(int i=1;i<=k;++i) scanf("%d",&t[i]);
	for(int i=1;i<=n;++i){while(vis[d[i]]) ++d[i];++stu[d[i]];}
	sum=d[n]+t[k];
	for(int i=1;i<=n;++i) if(d[i]!=d[i-1]) for(int j=1;j<=k;++j) rev[d[i]+t[j]]+=stu[d[i]]; 
	for(int i=1;i<=sum;++i) if(rev[i]&&vis[i]) rev[i+1]+=rev[i],rev[i]=0,sum=max(sum,i+1);
	printf("%d\n",sum);
	for(int i=1;i<=sum;++i) printf("%d %d\n",stu[i],rev[i]);
	return 0;
}

```

---

## 作者：Special_Tony (赞：1)

[题目传送门](/problem/P9553)
# 思路
这题直接照着题目说的做就可以了。

我们可以定义一个 $f1$ 数组和 $f2$ 数组，表示当日的学习单词数量和复习单词数量，并定义 $max1$ 表示学习完所有单词需要的天数，$max2$ 表示学习和复习完所有单词需要的天数。

在输入 $d_i$ 的同时，我们可以直接统计入 $f1$ 数组，即 $f1_{d_i}+1$，并同时更新 $max1$。

在输入 $s_i$ 的同时，我们可以把这一天的新学直接延续到下一天，并清空这一天的新学数量，即 $f1_{s_i+1}+f1_{s_i}\to f1_{s_i+1},0\to f1_{s_i}$。

后来读入了 $t_i$，我们直接把 $j$ 从 $1$ 枚举到 $max1$，把这天的新学量 $f1_j$ 直接累加到这个复习时间的复习量 $f2_{j+t_i}$ 里即可。

最后，我们可以把这一特殊日子的复习直接延续到下一天，并清空这一天的复习数量，即 $f2_{s_i+1}+f2_{s_i}\to f2_{s_i+1},f2_{s_i}=0$，然后输出每个 $f1_i$ 和 $f2_i$ 即可。
# 代码
```cpp
# include <bits/stdc++.h>
using namespace std;
int n, m, k, a[1000005], b[205], x, f1[2205], f2[2205], max1, max2;
int main () {
	cin >> n >> m >> k;
	for (int i = 0; i < n; ++ i)
		cin >> a[i], ++ f1[a[i]], max1 = max (max1, a[i]);
	for (int i = 0; i < m; ++ i)
		cin >> b[i], f1[b[i] + 1] += f1[b[i]], f1[b[i]] = 0, max1 = max (max1, b[i] + 1);
	while (k --) {
		cin >> x;
		for (int i = 1; i <= max1; ++ i)
			f2[i + x] += f1[i];
	}
	for (int i = 0; i < m; ++ i)
		f2[b[i] + 1] += f2[b[i]], f2[b[i]] = 0;
	max2 = max1 + x;
	cout << max2 << '\n';
	for (int i = 1; i <= max2; ++ i)
		cout << f1[i] << ' ' << f2[i] << '\n';
	return 0;
}
```

---

## 作者：sbno333 (赞：1)

这道题是一个典型的模拟优化，我们发现，首次学习直接影响到复习，因此先考虑首次学习时间，之后由于总共只有约 $10^3$ 天，考虑 $k\le10^3$，因此考虑完学习时间后可以枚举每一天，然后第二重循环枚举每次复习。

然而题目中说有特殊情况，因此我们需要进行转移。

为了加快速度，我们可以通过指针来实现，定义一个数组 $f$ 表示第 $i$ 天的任务转移到哪一天。

再输入前，$f_i$ 初始化为 $i$，即毫无特殊情况，输入后，我们可以转移，如果第 $i$ 天有情况，则 $f_i=f_{i+1}$，即转移到第二天，进行处理，由于每一个 $f_i$ 都需要用 $f_{i+1}$，因此应当倒序处理。
```cpp
for(int i=0;i<1000009;i++){
	f[i]=i;
}
for(int i=1;i<=n;i++){
	cin>>a[i];//学习时间
}
for(int i=1;i<=m;i++){
	cin>>b[i];//特殊情况
}
for(int i=1;i<=k;i++){
	cin>>c[i];//复习时间
}
if(m>0)
	f[b[m]]=b[m]+1;//预处理
for(int i=m-1;i>=1;i--){
	f[b[i]]=f[b[i]+1];//转移
}
```

接下来对于每个学习时间，通过指针进行转移。
```cpp
for(int i=1;i<=n;i++){
	int kk;
	kk=f[a[i]];//转移后学习时间
	an[kk][0]++;//答案
}
```

接下来计算复习时间。

```cpp
x=1000;
for(int i=1;i<=x*10;i++){//多开一点，以防万一
	for(int j=1;j<=k;j++){
		an[f[i+c[j]]][1]+=an[i][0];//c[j]天后试图复习，通过f得到真正的答案。
	}
}
```
最后求几天，最朴素的办法就是从末尾到开头进行枚举，如果有复习或学习，天数就确定了。
```cpp
int z;
z=x*10;
while(z--){
	if(an[z][0]||an[z][1]){
		break;
	}
}
x=z;
cout<<x<<endl;
for(int i=1;i<=x;i++){
	cout<<an[i][0]<<" "<<an[i][1]<<endl;
}
```
最终代码就是这样：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000009];
int b[1000009];
int c[1000009];
int f[1000009];
int an[1000009][2];
int x;
int main(){
	std::ios::sync_with_stdio(0);
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=0;i<1000009;i++){
		f[i]=i;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	for(int i=1;i<=k;i++){
		cin>>c[i];
	}
	if(m>0)
		f[b[m]]=b[m]+1;
	for(int i=m-1;i>=1;i--){
		f[b[i]]=f[b[i]+1];
	}
	for(int i=1;i<=n;i++){
		int kk;
		kk=f[a[i]];
		an[kk][0]++;
	}
	x=1000;
	for(int i=1;i<=x*10;i++){
		for(int j=1;j<=k;j++){
			an[f[i+c[j]]][1]+=an[i][0];
		}
	}
	int z;
	z=x*10;
	while(z--){
		if(an[z][0]||an[z][1]){
			break;
		}
	}
	x=z;
	cout<<x<<endl;
	for(int i=1;i<=x;i++){
		cout<<an[i][0]<<" "<<an[i][1]<<endl;
	}
	return 0;
}
```


---

## 作者：Genius_Star (赞：1)

### 题意：

有 $n$ 个单词，第 $i$ 个单词在第 $d_i$ 天学习。

每一个单词都要复习 $k$ 次，如果对于第 $i$ 个单词，第 $j$ 次复习的时间是 $d_i+t_j$ 天。

有着 $m$ 次休假，第 $i$ 次休假在第 $s_i$ 天，每次休假不用学习单词，也不用复习单词，但是当天的学习和复习要推到明天去做。

需要求学习和复习完所有单词需要的天数、每天新学单词数、每天复习单词数（要考虑重复）。

### 思路：

一个比较暴力的做法，先计算当前不用休假需要学习完的天数 $l=d_n+t_k$，我们可以暴力枚举每一天计算答案，对于第 $i$ 天的新学单词数为 $X_i$，第 $i$ 天复习单词数为 $Y_i$。

那我们怎么求 $X_i$ 和 $Y_i$ 呢？

我们可以在输入的时候预处理一下，第 $i$ 天有多少个单词要学习，用 $f_{1,i}$ 表示，然后还要预处理一下第 $i$ 天是不是休假，用 $f_{2,i}$ 表示。

对于我们枚举的每一天，如果不是休假的话，求学习单词数的话直接就是 $f_{1,i}$，那么我们怎么计算当天有多少个单词复习呢？

其实很简单，我们倒退一下，对于第 $j$ 次复习时间 $a_i+t_j$，倒推下来就是 $i-t_j$（$i$ 为我们枚举的时间），也就是说，我们只需要遍历一下 $t$ 数组，查看 $i-t_j$ 那天有多少个单词在学习，即 $f_{1,i-t_j}$，累加起来即可。

如果是休假呢？我们将 $f_{1,i+1} \to f_{1,i+1}+f_{1,i}$，然后将 $f_{1,i} \to 0$，这样我们实现了延迟学习的单词数。

延迟复习单词数的话也是将 $Y_{i+1} \to Y_{i+1}+Y_i$，这是先继承一下之前延迟传来的复习单词数，然后再用之前计算当天有多少个单词复习的方法计算一下，设其为 $t$，将 $Y_{i+1} \to Y_{i+1}+t$。

这样我们就将延迟的标记传出去了，那我们怎么知道复习完所有单词需要的天数呢？我们按照最坏的情况考虑一下，每次休假都要多一天时间学习，则至多有 $l+m$ 天，我们计算这些天的学习数量即可。

最后倒序遍历一遍，将 $X_i=0$ 并且 $Y_i=0$ 的一天给删掉，知道碰到了有学习过单词或复习过单词的就结束。

时间复杂度：$O(n \times k)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=2020000;
const ll K=1010; 
inline ll read(){ 
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll X[N],Y[N];
ll n,m,k,l;
ll a[N],b[K],c[K];
ll f1[N],f2[N];
int main(){
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		f1[a[i]]++;
	}
	for(int i=1;i<=m;i++){
		b[i]=read();
		f2[b[i]]=1;
	}
	for(int i=1;i<=k;i++)
	  c[i]=read();
	l=a[n]+c[k];
	for(int i=1;i<=l;i++){
		if(f2[i]){
			f1[i+1]+=f1[i];
			f1[i]=0;
			Y[i+1]+=Y[i];
			Y[i]=0;			
			l++;
			for(int j=1;j<=k;j++){
				if((i-c[j])<1)
				  break;
				Y[i+1]+=f1[i-c[j]];
			}
		}
		else{
			if(f1[i])
			  X[i]=f1[i];
			for(int j=1;j<=k;j++){
				if((i-c[j])<1)
				  break;
				Y[i]+=f1[i-c[j]];
			}
		}
	}
	while(X[l]==0&&Y[l]==0)
	  l--;
	write(l);
	putchar('\n');
	for(int i=1;i<=l;i++){
		write(X[i]);
		putchar(' ');
		write(Y[i]);
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：yzm0325 (赞：0)

一道需要优化的模拟。

### 思路

首先想到的做法是枚举每一个单词的新学时间，再将每次学习的后 $t_i$ 天的复习数量增加即可。但这样复杂度是 $O(nk)$，对于 $n=10^6,k=10^3$ 的数据会超时。考虑优化。

需要注意的是，我们只关心每天学习**单词的数量**，所以考虑开两个桶 $nw,ow$，分别表示每天新学单词数量和复习单词数量。

很明显，在读入数组 $d$ 时就可以处理出每天的新学单词数量。对于每天的复习单词数量，从 $1$ 枚举到 $d_n$，如果这一天的新学单词数量非零，就将这一天的新学单词对应的每个复习点的复习单词数量加上这一天的新学单词数量。形式化地，就是对于每个 $nw_i \ne 0$，将每一个 $ow_{i+t_j}$ 加上 $nw_i$。最后在两次处理后面分别加一次对应的特殊日期处理（后推一天做学习或复习）即可。

在累加预习和复习数量的同时，用一个变量 $day$ 来记录枚举到的最大天数，即复习和预习完所有单词需要的天数。

因为 $d$ 数组单调不减，即 $d_n$ 一定是 $d$ 数组的最大值，所以这个算法的复杂度为 $O(d_nk)$，足以通过此题。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, d[1000010], s[210], t[1010];
int nw[1000010], ow[1000010], day;
int main() {
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i++) {
        cin >> d[i];
        nw[d[i]]++;
    }
    day = d[n]; // 因为 d[n] 一定是 d 数组的最大值，所以可以这样做
    for(int i = 1; i <= m; i++) cin >> s[i];
    for(int i = 1; i <= k; i++) cin >> t[i];
    for(int i = 1; i <= m; i++) { // 特殊日期处理
        nw[s[i] + 1] += nw[s[i]];
        nw[s[i]] = 0;
    }
    for(int i = 1; i <= d[n]; i++)
        if(nw[i])
            for(int j = 1; j <= k; j++) {
                ow[i + t[j]] += nw[i];
                day = max(day, i + t[j]);
            }
    for(int i = 1; i <= m; i++) {
        ow[s[i] + 1] += ow[s[i]];
        ow[s[i]] = 0;
    }
    cout << day << '\n';
    for(int i = 1; i <= day; i++) cout << nw[i] << ' ' << ow[i] << '\n';
    return 0; // 完结撒花！！
}
```

---

## 作者：SWAP__ (赞：0)

一道较常规的模拟题。

如果没有特殊情况，可以存储每一天学习单词数量之和，对于复习的数量，将每次学习的后 $t_i$ 天加一即可，但此时复杂度达到了 $O(nk)$，500ms 的时限显然是不够的。

# 优化思路
考虑到所有单词不做区分，因此只需要知道第 $i$ 天由多少次首次学习推过来就行了，而天数 $d_i$ 的限制只有 $10^3$，遍历一遍完全是没问题的，最后由于每个单词还需要复习，不能仅仅开 $d_i$ 最大值的空间，还应加上 $t_i$ 的最大值。

在遇到特殊情况时，因为其它复习不会受影响，往后推一位就行

别忘了输出总天数 $x$，由于输入的单调性则答案一定是 $d_n+t_m$，如果是特殊情况则再加一。

# AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while (ch<'0'||ch>'9'){
        if (ch=='-'){
            w=-1;
        }
        ch=getchar();
    }
    while (ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*w;
}
int n,m,k,d[1000001],s,ans[2010],ans1[2010],maxn,t;
bool b[2010];
int main(){
    n=read();
    m=read();
    k=read();
    for(int i=1;i<=n;i++){
        d[i]=read();
        ans[d[i]]++;//统计这一天学习的总数
    }
    for(int i=1;i<=m;i++){
        s=read();
        b[s]=1;
        ans[s+1]+=ans[s];//特殊情况将这一天所有的学习移到明天
        ans[s]=0;
    }
    for(int i=1;i<=k;i++){
        t=read();
        for(int i=d[1];i<=d[n];i++){//根据每次学习去推它的复习时间
            int u=i+t;
            while(b[u])u++;
            ans1[u]+=ans[i];
        }
    }
    maxn=d[n]+t;//需要的天数
    if(b[d[n]])maxn++;
    printf("%d\n",maxn);
    for(int i=1;i<=maxn;i++){
        printf("%d %d\n",ans[i],ans1[i]);
    }
}
```

---

## 作者：Sirkey (赞：0)

我们注意到一个神奇的地方。

数组 $d$ 有 $n$ 个元素。

但是这些元素中最大的才 $10^3$，$n$ 却开到了 $10^6$。

所以，我们可以开一个桶，把重复的装在一起。

然后，就是处理不学习的天数，先暴力初始化，把这些不学习的时候会延迟到什么时候记下来。

然后，如果今天不学习，就把所有今天的任务，移到下一次学习的时候。

代码时间复杂度就降到了 $k \times 1000$。

解决了!

下面是核心代码。

```cpp
		FOR(i,1,n) {
			if(d[i]==d[i-1] && i!=1) continue;
			int j=d[i];
			j=work[j];
			if(j!=d[i]) de[j]+=de[d[i]];
			else {
				have[j]+=de[d[i]];
				int p=j;
				FOR(s,1,k) {
					int j=p+t[s];
					j=work[j];
					fx[j]+=de[p];
					ans=j;
				}
			}
```

——end——


---

## 作者：xiaoqian02 (赞：0)

### 一：闲话

赛时先开了 T1，然后看榜上一堆人过 T3，把 T3 做了，结果调了 30 min（后来发现快速幂写挂了）。最后一看 T2，发现是道模拟题……

### 二：思路

#### 弱化版

考虑弱化的情况：小浣熊不会忘记背单词。

我们可以读入所有的第一次学习时间，然后对于每个学习时间加一个复习的时间间隔，然后存起来。最后我们需要开一个桶来存每天学习或复习的数量。看起来没有问题。

实际上对于这可贵的 $25$ 分来说，确实没有什么问题。但是我们需要计算一下这两个桶该开多大。

我们注意到 $d_i \le 10^3$，$t_i \le 100$，考虑最差的情况，因为没有拖延，我们在第 $10^3$ 天学习之后又在 $100$ 天后复习，总共 $1100$ 天，开个 $1500$ 肯定够了。

接下来扫过去就可以了，对于在何时结束，我们可以用 cnt 存一下当前学习和复习的总数。显然如果全部结束了，这个总数应当是 $n+nk$（即学习总数加上复习总数）。当 cnt 达到这个值时退出即可。

#### 正常版

可惜小浣熊的记忆力不是那么好，所以我们要算上它忘记背单词的时间。

注意此时的**数据范围有些不同**，所以一些弱化版的算法需要优化。

例如弱化版的第一步，我们显然没有时间将所有数量全部扫一遍（否则 $10^6 \times 10^3$ 就炸了）。但是我们观察到 $d_i$ 的最大值只有 $10^3$ 次，所以我们还是考虑开桶，存下来每天学习的数量，在统计复习的时候直接加上这个值即可。

但是我们还不能直接统计复习，不然会非常麻烦，因为学习时间会影响复习时间。

所以我们在扫的时候统计。如果这一天小浣熊忘记了，那就将当天的任务加到第二天上。对于新学习的内容，再往后求每个复习的日期。由于复习肯定比学习要晚，所以这样做是可行的。

结束的判断与弱化版相同。但是要注意一点，这里的桶需要开大一些。还是考虑最差的情况，在最后一天学习，最后一天复习，再拖延几天。这个桶应该开到 $1000+1000+200=2200$。实际可以开 $2500$ 保险一些。

### 三：代码

```cpp
#include<bits/stdc++.h>
using namespace std;
void IOS()//读入优化，cin 写习惯了
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return;
}
const int sz=2500;//天数上限
int n,m,k,cnt,sm,st;
int d[1000005],t[2005],dl;//dl 为忘记的时间
bool dls[sz+5];//用一个 bool 数组存每天是否忘记
int xx[sz+5],fx[sz+5];//学习和复习
int ans[sz+5][2];//答案
int main()
{
    IOS();
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++) cin>>d[i];
    for(int i=1;i<=m;i++)
	{
		cin>>dl;
		dls[dl]=1;
	}
    for(int i=1;i<=k;i++) cin>>t[i];
    for(int i=1;i<=n;i++) xx[d[i]]++;
    sm=n*(k+1);//学习和复习的总数
    while(st<sm)
    {
    	cnt++;
    	if(dls[cnt])//这天忘记了
    	{
    		fx[cnt+1]+=fx[cnt];
    		xx[cnt+1]+=xx[cnt];//任务全部拖到第二天
    		continue;
		}
		ans[cnt][0]=xx[cnt];
		ans[cnt][1]=fx[cnt];
		st+=xx[cnt]+fx[cnt];
		for(int i=1;i<=k;i++) fx[cnt+t[i]]+=xx[cnt];//将学习内容对应的复习时间求出来
	}
	cout<<cnt<<endl;
	for(int i=1;i<=cnt;i++) cout<<ans[i][0]<<" "<<ans[i][1]<<endl;//输出即可
    return 0;
}
```

---

## 作者：Eason_cyx (赞：0)

感觉难度 $\le$ T1。

$\texttt{Part 1:25 pts}$

这 $25$ 分是 $m=0$ 的特殊情况。

$m=0$，代表每一天都可以按计划学习，那么对于每一个单词直接模拟即可。如果你对数据范围不太敏感，建议数组都开大一点。

时间复杂度 $O(nk)$。

```cpp
//pre表示当日学习单词数，re表示当日复习单词数
//maxday用来统计最后学习/复习单词的一天
int maxday = 0;
for(int i = 1;i <= n;i++) {
    //对于每一个单词
    pre[d[i]]++;
    maxday = max(maxday,d[i]);
    for(int j = 1;j <= k;j++) {
        int reday = d[i] + t[j];
        re[reday]++;
        maxday = max(maxday,reday);
    }
}
```

[$25$ 分提交记录](https://www.luogu.com.cn/record/121410141)

$\texttt{Part 2:65 pts}$

这 $65$ 分是虽然有 $m$，但是可以直接通过暴力模拟。

把特殊的日子用一个 bool 数组存下来，如果哪一天学习单词/复习单词时，有特殊情况，就不断与后面交换，直到哪一天能学习为止。因为我们是将特殊情况在输入时直接处理，所以对后面的程序没有影响。

时间复杂度仍然是 $O(nk)$。

学习单词的特殊处理：
```cpp
for(int i = 1;i <= m;i++) {
    cin >> s[i];
    spe[s[i]] = true;
}
for(int i = 1;i <= n;i++) {
    if(spe[d[i]] == true) {
        while(spe[d[i]] == true) d[i]++;
    }
}
```

复习单词的特殊处理：
```cpp
for(int i = 1;i <= n;i++) {
    pre[d[i]]++;
    maxday = max(maxday,d[i]);
    for(int j = 1;j <= k;j++) {
        int reday = d[i] + t[j];
        if(spe[reday]) {
            while(spe[reday]) reday++;
        }
        re[reday]++;
        maxday = max(maxday,reday);
    }
}
```

[$65$ 分提交记录](https://www.luogu.com.cn/record/121412861)

$\texttt{Part 3:100 pts}$ 

我们会发现，上一个程序中，最坏的运算次数会达到 $10^6 \times 10^3=10^9$ 次，所以最后一个 Subtask 有两个点超时了。

（注：赛时的时限是 $1.00$s，把这两个点大力卡卡常，也许还能过；赛后为了卡掉错解，时限放到了 $500$ms，就完全不能过了。）

看看数据范围，我们从哪里入手呢？

仔细观察可以发现，$d_i$ 和 $t_i$ 都是 $\le 10^3$ 的，也就是说，总天数一定不会超过 $2000$。那么我们就可以按天记录答案，就可以将 $10^6$ 的数量级降低至 $2000$。

由于 $d_i$ 单调不减，所以总时间复杂度为 $O(d_nk)$。

```cpp
//isd[i]表示第i天要学几个词
for(int i = 1;i <= maxd;i++) {
    if(isd[i] && spe[i]) {
        int x = i;
        while(spe[x]) {
            isd[x+1] += isd[x];
            isd[x] -= isd[x];
            x++;
            //这是交换操作
        }
    }
}
for(int i = 1;i <= maxd;i++) {
    if(isd[i] > 0) {
        pre[i] += isd[i];
        for(int j = 1;j <= k;j++) {
            int reday = i + t[j];
            if(spe[reday]) {
                while(spe[reday]) reday++;
            }
            re[reday] += isd[i];
            maxday = max(maxday,reday);
        }
    }
}
```

运算次数最坏情况下为 $10^3\times10^3=10^6$。

$\texttt{Part 4}$

总结：这一题并没有太大的思维难度，比较考察代码实现能力，建议评橙或者黄。

---

## 作者：Moon_Wind (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9553)



------------

**题意简述**：

小浣熊有 $n$ 个单词需要学习，其中，第 $i$ 个单词会在第 $d_i$ 天学习。而每一个单词都会进行 $k$ 次复习，其中第 $i$ 个单词的第 $j$ 次复习会在第 $a_i+t_j$ 天进行。但是在这些天中，会有 $m$ 天，小浣熊不会去记单词。其中，如果是当天学习某个单词，那么这个单词的整体学习进度会变慢一天，也就是 $a_i$ 会加 $1$，而复习只会将当次学习推后一天，不会影响后面的学习。要求输出在多少天后，单词的学习与复习才会全部结束，再输出每天学习的单词数量和复习的单词数量。

**做题思路**：

对于每一天学习和复习的单词数，我们可以进行一个预处理，使得之后进行修改时可以轻松地调用。

在每一个特殊的日子，我们可以将这一天所复习的单词加到后一天，而原计划在今天学习的单词也需要向后推迟一天，所以在原本需要复习这些单词的那几天，我们也需要进行操作，推迟到后一天。而求天数则找到最后复习单词数不为 $0$ 的那一天即可。

进行修改操作时有一个从 $1$ 到 $m$ 的循环套了一个从 $1$ 到 $k$ 的循环，所以时间复杂度是 $O(mk)$，可以通过本题。


**代码部分**：


------------

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,a[1000111],s[10001],d[10001],sum[100011],sum1[100011],op,o;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0); 
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>a[i],sum[a[i]]++;
    	//记录在当天要学习的单词数。
	for(int i=1;i<=m;i++) cin>>s[i];
	for(int i=1;i<=k;i++) cin>>d[i];
	for(int i=1;i<=a[n];i++)
		for(int j=1;j<=k;j++)
			sum1[i+d[j]]+=sum[i]; 
            //求出每一天要复习的单词数。
	op=a[n];
	for(int i=1;i<=m;i++){
		sum[s[i]+1]+=sum[s[i]];
		sum1[s[i]+1]+=sum1[s[i]];
		for(int j=1;j<=k;j++){
			sum1[s[i]+d[j]]-=sum[s[i]];
			sum1[s[i]+d[j]+1]+=sum[s[i]];//修改操作。
		}
		sum[s[i]]=0;
		sum1[s[i]]=0;
	}
	for(int i=op-1;i<op+m+1;i++)
		if(sum[i]>0) o=i;//求出天数。
        o+=d[k];
	cout<<o<<endl;
	for(int i=1;i<=o;i++)
		cout<<sum[i]<<' '<<sum1[i]<<endl;
	return 0;
}
```


------------


---


# 线性变换

## 题目描述

你有三个非负整数 $x,a,b$。在 $x \ge 0$ 的前提下，你可以对 $x$ 进行任意次（包括 $0$ 次）如下操作：

* 将 $x$ 变为 $ax - b$。

你需要求出你通过操作能得到的 $x$ 的最小值。

## 说明/提示

样例解释：对于第一组数据，有 $x=6 \rightarrow 8 \rightarrow 12 \rightarrow \cdots$，很明显 $x=6$ 就是最小值。

对于第二组数据，有 $x=5\rightarrow -1$，$x=-1$ 为最小值。

----

对于 $30\%$ 的数据，$T \le 5$，$x,a,b \le 100$。

对于另 $20\%$ 的数据，$a \gt b$。

对于另 $20\%$ 的数据，$b=0$。

对于 $100\%$ 的数据，$1 \le T \le 1000$，$0 \le x,a,b \le 10^{9}$。

## 样例 #1

### 输入

```
2
6 2 4
5 3 16```

### 输出

```
6
-1```

# 题解

## 作者：Mortidesperatslav (赞：12)

不懂为什么都写那么长。

若 $a > 1$，则 $ax-b$ 的值为 $x + (a-1)x-b$，如果把 $x$ 换成更大的数，增量更大，反之亦然。

于是特判 $a=1$，否则因为要做乘法，是指数爆炸，直接模拟。单次复杂度 $\log x$。

具体见代码。

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
int t, x, a, b;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> t;
	while (t--){
		cin >> x >> a >> b;
		if (a == 1){
			if (b == 0){//这时变换多少次都是 x
				cout << x << "\n";
				continue;
			}
			cout << x % b - b << "\n";//因为 x 每次 -b，减到负数就停了
			continue;
		}
		while (a * x - b < x && x >= 0)
			x = a * x - b; //模拟
		cout << x << "\n";
	}
}
```

---

## 作者：superballll (赞：10)

# 题目分析

非负数 $x$ 仅有一种操作方式，即变成 $ax-b$，那通过对比 $x$ 和 $ax-b$ 的值就可以判断值不值得进行这次操作。

- 如果 $ax-b<0$ 这自然是一个令人兴奋的情况，因为题目中明确地说明**在 $x \ge 0$ 的前提下**， $ax-b$ 变成了负数了，也就意味着这是最后一次的操作了，直接输出 $ax-b$ 即可。
- 如果 $ax-b \ge x$ 说明这个操作不太给力，没有起到让 $x$ 变小的作用，自然我们也就不用多想什么了，直接输出 $x$ 就可以了。
- 如果 $ax-b<x$ 但是 $ax-b \ge 0$ 说明这个操作是有效的，那可以通过多次重复这个操作来实现让 $x$ 不断变小，直到得到我们想要的结果。

但是！本题是一个多次询问的问题，询问次数最多是 $1000$ 次，而且 $x,a,b$ 三个非负数的最大值都达到了 $10^9$，这除了提醒我们要开 `long long` 外，还要考虑 **TLE** 的风险。比如： $x$ 的值为 $10^9$，$a$ 和 $b$ 的值都为 $1$，这样每次操作只会让 $x$ 的值减少 $1$，仿佛一点点的给一个大土豆子削去薄薄的一层一样，注定要收获一个 **TLE** 了！

那怎么办呢？我们既然发现了这个特殊情况，那就去解决它就好了！经过思考（尝试）发现，仅有当 $a$ 的值为 $1$，而且 $b>0$ 时才会出现这种情况，那此时问题就变成了： $x$ 不停的减 $b$，减到最终的结果为负数。其实就是一道数学问题了。

# 代码
```
#include<bits/stdc++.h>
using namespace std;
long long q,x,a,b,s; 
int main(){
	cin>>q;
	while(q--){
		cin>>x>>a>>b;
		if(a==1&&b>0){
			x -= x/b*b; //把能够整除的部分先减掉 
			if(x==0) cout<<-b<<endl; //能整除 再减掉一个b 
			else cout<<x-b<<endl; // 有剩余 再减掉一个b
			continue; 
		} 
		while(1){
			s=a*x-b;
			if(s<0){ //负了 喝到位了 
				cout<<s<<endl;
				break;
			} 
			if(s>=x){ //喝假酒 不喝了 
				cout<<x<<endl;
				break;
			}
			x=s;  //有用就继续吧！ 
		} 
	}
	return 0; //据说这叫好习惯
}
```

---

## 作者：Programming_Konjac (赞：7)

# 赛时思路
这题是一个思维题。

判断思路（这里感谢 [qidaimuhuoying](https://www.luogu.com.cn/user/1039740) 提出本题解的一处小细节的错误）：

- 如果 $a>b$：
  - 如果 $x\ne 0$，那么输出 $x$。
    - 证明：我们设极端情况 $a=2,b=1$，那么进行操作完之后就变成了 $2x-1$，一定是比 $x$ 大的，所以直接输出 $x$。
  - 如果 $x=0$，那么输出 $-b$。
    - 证明：$x=0$ 那么 $x\times a$ 也等于 $0$，但是乘上之后 $x$ 不仅没有变，还可以减去一个 $b$，也就是 $x=-b$，所以输出 $-b$。
  
- 如果 $b=0$，那么输出 $x\times \min(1,a)$。
  - 证明：如果 $a=0$，那么 $0x=0$，所以是输出 $0$，否则就不乘，直接输出 $x$。
  
- 如果 $a=b$：
  - 如果 $x=1$，那么输出 $-b$。
    - 证明：因为 $a=b$，所以 $x=ax-b=0$，然后 $x=ax-b=-b$，然后就没法进行了，所以输出 $-b$。
   - 如果 $a=1$，那么输出 $-1$。
     - 证明：因为 $b=1$，那么 $x$ 可以无限的减 $1$，但因为只能是一个负数，所以输出 $-1$。
   - 否则输出 $x$，这个不需要证明。
- 如果 $a=1$，那么输出 $x-(\lfloor\frac{x}{b}\rfloor+1)\times b$，这个没什么好说的。

- 否则就是模拟啦！我们先模拟一次，如果变大了，就直接输出原来的 $x$，否则就一直循环到 $x$ 为负数，然后输出现在的 $x$，这个也不需要证明。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	int n;
	cin>>n;
	for(int i=1; i<=n; i++){
		int x,a,b;
		cin>>x>>a>>b;
		if(a>b){
            if(x==0){
                cout<<-b<<"\n";
                continue;
            }
			cout<<x<<"\n";
		}
		else if(b==0){
			cout<<x*min(a,1ll)<<"\n";
		}
		else if(a==b){
			if(x==1){
				cout<<-b<<"\n";
			}
			else if(a==1){
				cout<<"-1\n";
			}
			else{
				cout<<x<<"\n";
			}
		}
		else if(a==1){
			cout<<x-((x/b)+1)*b<<"\n";
		}
		else{
			int j=x;
			x=a*x-b;
			if(x>=j){
				cout<<j<<"\n";
				continue;
			}
			while(x>=0){
				x=a*x-b;
			}
			cout<<x<<"\n";
		}
	}
	return 0;
}
```

---

## 作者：PR_CYJ (赞：6)

# [题目传送门](https://www.luogu.com.cn/problem/P10252)
# 思路
这道题我们可以先判断特殊情况。若 $a\times n-b\ge n$，则当前的 $n$ 就是最小值，直接输出。若 $n=0$ 或 $a=0$，则直接输出 $-b$。若 $a=1$，则输出 $n- \lceil (n+1)/b\rceil \times b$。

接下来就考虑一般情况。我们设第一次操作时减掉了 $m$，则第 $i$ 次操作时就减掉了 $m\times a^{i-1}$。将每次减掉的值提取公因数后可以发现，前 $i$ 次操作共减掉了 $m\times (a^0+a^1+a^2+\cdots +a^{i-1})$，而这个式子可化简为 $m\times (a^i-1)/(a-1)$。所以我们只需要二分查找第一个使 $m\times (a^i-1)/(a-1)>n$ 的 $i$。
# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll pw(ll a,ll b)
{
	ll s=1;
	while(b)
	{
		if (b&1)
		{
			s*=a;
		}
		a*=a;
		b/=2;
	}
	return s;
}
inline ll lgk(ll a,ll n)
{
	ll s=0;
	while(n>=a)
	{
		n/=a;
		s++;
	}
	return s;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		ll n,a,b,m,l=0,r,s;
		scanf("%lld%lld%lld",&n,&a,&b);
		if (a*n-b>=n)
		{
			printf("%lld\n",n);
			continue;
		}
		m=n-(a*n-b);
		if (a==0||n==0)
		{
			printf("%lld\n",-b);
			continue;
		}
		if (a==1)
			s=ceil((n+1)*1.0/b)*b;
		else
		{
			r=lgk(a,n);//计算右边界 
			while(l<=r)
			{
				ll mid=(l+r)/2;
				if ((pw(a,mid+1)-1)/(a-1)*m<=n)
					l=mid+1;
				else
					r=mid-1;
			}
			s=(pw(a,l+1)-1)/(a-1)*m;
		}
		printf("%lld\n",n-s);
	}
}
```

---

## 作者：Xssion37_XY (赞：4)

### 前情提要

[题目链接](https://www.luogu.com.cn/problem/P10252)

[更好的阅读体验](https://www.luogu.com.cn/article/y3kw7ayh)

### 实际分析

其实没必要写那么长。

我分为 $3$ 个部分。

1. 当 $a=0$ 时：$x=ax-b=-b$，$x$ 要么减去 $b$，要么不减，那么输出它们两个的最小值。

2. 当 $a=1$ 时：$x=ax-b=x-b$，$x$ 只能减去 $b$ 求得最小值，这里建议用取模来实现 $x$ 每次都减去 $b$，最后在 $x>0$ 时输出最小值。

3. 当 $a=1,b=0$ 时：$x=ax-b=x$，等于没变化，直接输出 $x$。

其他情况直接模拟就完了。

比如，当 $a>1$ 时，$x$ 只会无限增大，那么就在循环时设置一个计数器来保证不超时。

注意控制循环次数，然后每次比较更新前的 $x$ 和 更新后的 $x$ 的大小，然后再覆盖 $x$ 继续循环直到 $x>0$ 或次数上限。 

### 代码部分

- 赛时代码

```
#include <iostream>
#define int long long
using namespace std;
const int MAXX = 1e7;
int sum;
signed main() {
	int T;
	cin >> T;
	while (T --) {
		int a,b;
		int x;
		cin >> x >> a >> b;
		if (a == 0) {
			cout << min(x,-b) << '\n';
			continue;
		}
		if (b == 0) {
			cout << x << endl;
			continue;
		}
		if (a == b) {
			cout << -b << '\n';
			continue;
		}
		if (x == 1 and a == 3 and b == 2) {
			cout << 1 << '\n';
		}
		sum = x;
		int tmpx = 0;
		int ans = 0;
		while (ans <= 50 and tmpx >= 0) {
			tmpx = a * x - b;
			ans ++;
			if (tmpx >= x) {
				sum = min(sum,x);
				break;
			}
			x = tmpx;
			sum = min(sum,tmpx);
		}
		cout << sum << '\n';
	}
	return 0;
}
```

忘了特判 $a=1$ 的时候，然后就寄了 $20$ 分。

- 赛后代码

```
#include <iostream>
#define int long long
using namespace std;
const int MAXX = 1e7;
int sum, ans = 50;
signed main() {
	int T;
	cin >> T;
	while (T --) {
		int a, b;
		int x;
		cin >> x >> a >> b;
		if (a == 0) {
			cout << min(x, -b) << '\n';// a = 0 时只有 x 和 b，比较最小值就完了
			continue;
		}
		if (b == 0 and a == 1) {
			cout << x << '\n';// 变换等于没变换
			continue;
		}
		if (a == 1) {
			cout << x % b - b << '\n';// x 每次都减去 b，最后在 x > 0 时输出最小值
			continue;
		}
		sum = x;
		int tmpx = 0;
		int ans = 0;
		while (ans <= 50 and tmpx >= 0) {// 模拟
			tmpx = a * x - b;
			ans ++;
			if (tmpx >= x) {
				sum = min(sum, x);
				break;
			}
			x = tmpx;
			sum = min(sum, tmpx);
		}
		cout << sum << '\n';
	}
	return 0;
}
```

完结撒花！

---

## 作者：HasNoName (赞：4)

### 思路
按题意模拟即可。

1. 若 $a=0$，$b=0$,答案一定为 $0$。
2. 若 $a\times x-b\ge x$ 因为 $a \ge 0$ 所以 $a$ 越大时 $a\times x-b$ 越大。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long INF=1e18;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	long long T,x,a,b;
	cin>>T;
	while(T--)
	{
		cin>>x>>a>>b;
		if(a*x-b>=x)cout<<x<<'\n';
		else
		{
			if(a==0&&b==0)//均为0时答案一定为0
			{
				cout<<0<<'\n';
				continue;
			}
			while(x>=0)x=a*x-b;
			cout<<x<<'\n';
		}
	}
	return 0;
}
```

只有 $70$ 分。

考虑对 $a=1$ 做优化，因为 $a=1$ 可能操作 $10^9$ 次，由于每次减少定制值，用除法做优化。若 $a\times x-b\le x-1$ 那么 $b\ge x+1$，每次减少的数翻倍增加。

### AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long INF=1e18;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	long long T,x,a,b;
	cin>>T;
	while(T--)
	{
		cin>>x>>a>>b;
		if(a*x-b>=x)cout<<x<<'\n';
		else
		{
			if(a==0&&b==0)
			{
				cout<<0<<'\n';
				continue;
			}
			if(a==1)//a=1时
			{
				x-=x/b*b;
				x-=b;
				cout<<x<<'\n';
				continue;
			}
			while(x>=0)x=a*x-b;
			cout<<x<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：System32 (赞：3)

可以看到，当 $a\cdot x-b \geq x$ 时，就没有必要继续往下算了。

当 $a \geq b$ 时，要使得 $x$ 在进行操作后不变大，必须使 $x = 0$，所以答案便是 $-b$。

当 $a = 0$ 时，直接输出 $-1$。

当 $a = 1$ 时，直接计算 $x \bmod b - b$。

剩余情况直接枚举。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        long long x, a, b;
        cin >> x >> a >> b;
        if (1LL * a * x - b >= x) {
            printf("%lld\n", x);
            continue;
        }
        if (a == 0 || a >= b) {
            printf("%lld\n", -b);
            continue;
        }
        if (a == 1) {
            printf("%lld\n", x % b - b);
            continue;
        }
        while (x >= 0) {
            x = a * x - b;
        }
        printf("%lld\n", x);
    }
    return 0;
}
```

---

## 作者：_buzhidao_ (赞：2)

[题面传送门](/problem/P10252)
# 题目分析
由题意，不难发现：

- 当 $a=0$，$ax-b=-b$。

因为 $-b\le0$，$x\ge0$，所以 $-b\le x$。

即 $-b$ 为最小值，直接输出 $-b$ 即可。

- 当 $b=0$ 且 $a\ne0$，$ax-b=ax$。

因为 $ax\ge x$，所以 $ax-b\ge x$，最小值为 $x$。

综上，直接输出 $x$ 即可。

- 当 $a=1$ 且 $b\ne 0$，$ax-b=x-b<x$。

此时无论 $x$ 为何值，再进行一次操作，得到的值都会 $<x$。

因为仅当 $x\ge0$ 才可进行操作，所以不断将 $x$ 减少 $b$ 直到 $x<0$ 即可。

易得最小值为 $x\bmod b-b$。

- 若上述情况皆不满足，我们需要模拟寻找的过程。

为了让 $x$ 取更小的值，我们需要在 $ax-b<x$（即 $x<\frac{b}{a-1}$）且 $x\ge0$（题目限制）时操作。

易证这个条件一但不满足，我们就无法找到比这更小的值了（详见下文"详细证明"）。

所以我们需要在 $ax-b<x$ 且 $x>0$ 时循环，找出最小值。

## 详细证明
设本次操作前的 $x$ 为 $x_0$，本次操作后的为 $x_1$，下次操作后的为 $x_2$。

易知 $x_0=\frac{x_1-b}{a}$、$x_2=ax_1-b$。

前置条件：$x_1\ge\frac{b}{a-1}$（若进行操作**在目前看来**并不是最优解，则必满足此条件）、$a\ge2$、$b\ge1$。

因为 $x_1\ge\frac{b}{a-1}$，又因为 $a-1>0$，所以 $(a-1)x_1\ge b$。

又因为 $a+1>0$，所以 $(a+1)(a-1)x_1\ge (a+1)b$ 即 $(a^2-1)x_1\ge ab+b$。

所以 $a^2·x_1-x_1\ge ab+b$ 即 $ab+b\le a^2·x_1-x_1$。

所以 $x_1+b\le a^2·x_1-ab$。

又因为 $a>0$，所以 $\frac{x_1+b}{a}\le\frac{a^2·x_1-ab}{a}$ 即 $\frac{x_1-b}{a}\le ax_1-b$。

所以 $x_0\le x_2$。

所以 $ax_0\le ax_2$，$ax_0-b\le ax_2-b$ 即 $x_1\le ax_2-b$。

所以只要 $x$ 不再满足 $x<\frac{b}{a-1}$，无论怎样继续操作，都不会达到更小的值。

所以得证。

# AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &x){//快读
	x=0;int f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	x*=f;
}
ll t,x,a,b;
ll f(){//处理
	if(a==0) return -b;
	if(b==0) return x;
	if(a==1) return x%b-b;
	for(;x>=0;){//循环模拟
		if((a-1)*x<b) x=a*x-b;//寻找最小值
		else break;
	}return x;
}
int main(){
	read(t);
	for(int i=0;i<t;++i){
		read(x);read(a);read(b);
		printf("%lld\n",f());
	}
	return 0;
}
```

---

## 作者：saixingzhe (赞：2)

# 分析
简单题，一眼秒了，为啥很多人要用复杂做法。

首先我们进行一次变换，如果变换的结果大于 $n$，那么 $n$ 就是最小值，这个很好证明。

然后对于一次变换后变小的数，我们进行循环模拟其变换，这里要进行判断：

我们发现如果 $a=0$ 且 $b=0$ 那么 $x$ 会一直停止在 $0$ 变换，会死循环，输出 $0$ 即可。

然后还会超时，我们思考什么情况会被卡掉，很容易想到是一个大数每次 $\times 1$，减去一个很小的数。我们判断 $a=1$ 的情况，输出 $x \pmod{b} - b$。

剩下情况正常模拟即可。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
long long x,a,b;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%lld%lld%lld",&x,&a,&b);
		if(a==0&&b==0){
			printf("0\n");
			continue;
		}
		if(x*a-b>=x)	printf("%lld\n",x);
		else{
			if(a==1&&b!=0)	printf("%lld\n",x%b-b);
			else{
				while(x>=0)	x=x*a-b;
				printf("%lld\n",x);
			}	
		}
	}    
	return 0;
}
```

---

## 作者：水星湖 (赞：2)

直接模拟是会超时的，~~不然出这个题干嘛。~~

分析一下为什么会超时。

记每次操作 $x$ 的增量 $\Delta x = x - (ax - b)$，化简得 $\Delta x = (1-a)x+b$。发现绝大部分情况下很快就会 $x\lt0$。但是当 $a = 1$ 时 $x$ 每次操作只会减少 $b$。所以如果 $b=1$ 的话就会循环非常多次，但是可以发现 $x$ 每次减少 $b$ 直到 $x\lt 0$ 时的 $x$ 其实就是 $x \bmod b - b$，由于有取模，所以还要特判 $b\neq0$。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
void solve()
{
    int x,a,b;
    cin>>x>>a>>b;
    if(a == 1 && b != 0)
    {
        cout << (x % b - b) << endl;
        return;
    }
    while(x >= 0)
    {
        int t = a * x - b;
        if(t >= x)
            break;
        x = t;
    }
    cout << x << endl;
}
signed main()
{
    int t;cin>>t;
    while(t--)solve();
    return 0;
}
```

---

## 作者：lbmzxhb (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P10252)

本题可以通过**分类讨论**的方法去写。

- 当 $ax-b \ge x$ 时，  
显然 $x$ 只会越变换越大，~~怎么证我不会~~  
因此最小为输入时的 $x$。

- 当 $b=0$ 且 $a=0$ 时，  
显然 $x$ 在经过任意多次变换后都为 $0$，  
又因为数据范围中 $0 \le x \le 10^9$，  
因此最小一定为 $0$。

- 当 $b=0$ 但 $a>0$（即 $a \ge 1$）时，  
显然 $x$ 在经过 $n$ 次变换后为 $a^{n} \cdot x$，  
因为 $a \ge 0$ 且 $n \ge 0$，  
所以 $a^{n} \ge 0$，  
因此最小为输入时的 $x$。

- 当 $a=1$ 且 $b>0$（即 $b \ge 1$）时，  
显然 $x$ 进行 $n$ 次变换后为 $x-kb$，（$k \le \min(n,\lfloor\frac{x}{b}\rfloor+1)$）  
因此当 $k$ 取最大时 $x$ 最小，  
因此最小为 $x-(\lfloor\frac{x}{b}\rfloor+1)b=x\bmod b-b$。

- 其他情况下，  
直接暴力推出第一个 $<0$ 的 $x$ 即可。

时间复杂度 $\mathcal{O}(\log x)$。~~时间复杂度不会证~~

# Code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main() {
	int t;
	cin >> t;
	while (t--) {
		int x, a, b;
		cin >> x >> a >> b;
		if (x * a - b >= x) cout << x;
		else if (b == 0 && a == 0) cout << 0;
		else if (b == 0) cout << x; //b=0且a>=1的情况
		else if (a == 1) cout << x % b - b; //由于前面b=0的讨论完了，所以b>=1恒成立
		else { //其他情况
			while (x >= 0) x = x * a - b;
			cout << x;
		}
		cout << '\n';
	}
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/151443010)  记录里的注释不要在意（因为是赛时代码

~~点个赞再走罢~~

# Update:
[2024/3/23] 经@sbno333 dalao建议，修改了LaTeX。  
[2024/3/23] 修改了分类讨论中的实质性错误。

---

## 作者：dlzlj_2010 (赞：1)

题意很好理解，这里就不过多赘述。

# 解法：

1. 当初始的 $x \le ax+b$  时，当前的$x$即为最小值。

1. 当 $x >ax+b$ 时，如果   $a=1$ ，那么 $x$ 就相当于一直减 $b$ 。我们记 $k= \lceil \frac{x}{b} \rceil$ ，如果 $x-k\times b=0$ ，那么还可以再变换一次，否则即为最小值。
1. 如果 $a=0$ ，直接输出 $-b$ 即可。
1. 其他情况按题意模拟即可。


## code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int main(){
	int T;
	cin>>T;
	while(T--){
		ll x,a,b;
		cin>>x>>a>>b;
		if(a*x-b>=x)cout<<x<<'\n';//情况1
		else{	
			if(a==1){//情况2
				ll k=(x-1)/b+1;//x除以b向上取整
				if(x-k*b)cout<<x-k*b<<'\n';
				else cout<<x-k*b-b<<'\n';//如果为0还能再减一次
			}
			else if(a==0) cout<<-b<<'\n';//情况3
			else {//情况4
				while(x>=0){
					x=a*x-b;
				}cout<<x<<'\n';
			}
		}
	}
	return 0;
}

```
~~我永远不会告诉你我在赛时想到了一个更弱智的解法。~~
[click here（如果你想看）](https://www.luogu.com.cn/article/jq1post0)。

---

## 作者：Lycd0719 (赞：1)

## 思路
四种情况：

1. $a=0$ 且 $b=0$，直接输出 $0$；

2. 如果 $a \times x-b>x$，输出 $x$，等于也一样；

3. 如果 $a=1$，输出 $x \bmod b-b$；

4. 否则一直把 $x$ 减到小于 $0$。

## 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
	int n;
	cin >> n; int i, j, k;
	while (n--) {
		int x, a, b;
		cin >> x >> a >> b;
		if (a == 0 && b == 0) {
			cout << 0 << endl;
			continue;
		}
		if (a*x - b >= x) {
			cout << x << endl;
			continue;
		}
		if (a == 1) {
			cout << x % b - b << endl;
			continue;
		}
		while (x >= 0) {
			x = a * x - b;
		}
		cout << x << endl;
		continue;
	}
}
```

---

## 作者：FlyPancake (赞：1)

## [P10252 线性变换 题解](https://www.luogu.com.cn/problem/P10252)

数学题。

## Subtask 1

发现 $a>b$ 时，$ax-b$ 单调递增，所以最小值即为 $x$。

## Subtask 2

发现 $b=0$ 时，计算得出的值只和 $a$ 的正负有关。

- $a>0$ 时，$ax-b$ 单调递增，所以最小值即为 $x$。
- $a \le 0$ 时，因为 $x>0$，所以最小值即为 $ax$。

## Subtask 3
发现 $ax-b$ 的性质只会单调递增或者单调递减或者不变。

记 $cha$ 为 $x$ 与第一次进行 $ax-b$ 后的差值。
- $cha>0$ 时，$ax-b$ 单调递增，最小值即为 $x$。
- $cha=0$ 时，$x$ 的值不变，输出 $x$ 的值即可。
- $cha<0$ 时，$ax-b$ 单调递减，每次计算所得的差为前一次计算所得的差的 $a$ 倍。第 $i$ 次计算时的总差值即为 $cha \times \sum_{t=0}^{i}a^t$，根据等比公式可化为 $cha \times \frac{1-a^{i+1}}{1-a}$。注意 $a=1$ 时要特判。此部分代码如下。

```
for(int i=0; ; i++){
    ll s = (1-pow(a, i+1))/(1-a);
    if(x-s*cha<0){
        cout<<x-s*cha<<"\n";
        break;
    }
}
```

完结撒花~~

---

## 作者：MoonCake2011 (赞：1)

特判几种死循环与会被卡的就行了。

最开始的时候。

如 $b=0$ 或者 $x \le a \times x-b$ 或者 $a=0$ 可以直接 $O(1)$ 计算。

注意 $a=b=0$ 时，是按 $a=0$ 的方法计算。

因为 $0 \le a$ 且 $b$ 不变。

所以 $x$ 必定单调递增或者单调递减。

又发现 $a^x$ 差不多比 $bx$ 大。

所以 $a>1$ 时，暴力 `while` 差不多不会 TLE。

$a=1$ 时，也可以特判直接 $O(1)$ 计算。

就用了一个 $O(能过)$ 的复杂度给场切了。

---

## 作者：ykzzldz (赞：1)

这题的部分分具有较强的提示性，我们很容易得知，当改变一次后的数大于原数，则之后的改变肯定只会使其更大，这时我们只需要输出原数。当 $b=0$ 时，只需输出原数与 $a\times x$ 的较小值。当 $a=1$ 时，先将 $x$ 变为 $x \bmod b$，再跑暴力，剩下的情况直接暴力即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,x,a,b,ans;
signed main(){
	cin>>T;
	while(T--){
		cin>>x>>a>>b;
		if(a*x-b>=x)cout<<x<<'\n';
		else if(b==0){
			cout<<min(a*x,x)<<'\n';
		}
		else if(a==1){
			x=x%b;
			ans=x;
			while(x>=0){
				x=a*x-b;
				ans=min(ans,x);
			}
			cout<<ans<<'\n';
		}
		else{
			ans=x;
			while(x>=0){
				x=a*x-b;
				ans=min(ans,x);
			}
			cout<<ans<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：1)

发现当 $a > b$ 时，最多进行一次操作就可以得到答案。结果为 $\min(x, f(x))$。

对于 $a < b$，$x$ 要么是一直单调递增的，要么是一直单调递减的。对于单调递增是容易判断的。

从直觉上说，单调递减的速度会很快。但是发现当 $a = 1, b = 1$ 的时候下降速度很慢。所以把 $a = 1$ 的情况判掉即可。

```cpp
int f(int x) { return a * x - b; }
signed main() {
	read(T);
	while (T -- ) {
		read(x, a, b);
		if (a > b or b == 0)
			printf("%lld\n", min(x, f(x)));
		else {
			if (a == 1) {
				printf("%lld\n", x % b - b);
				continue;
			}
			while (f(x) < x and x >= 0) x = f(x);
			cout << x << endl;
		}
	} return 0; 
}
```

---

## 作者：WaterSky (赞：1)

# [P10252 线性变换](https://www.luogu.com.cn/problem/P10252)
~~做这题的时候矛盾了很久。~~

---
## 审题：
给出三个非负整数 $x,a,b$。在 $x \ge 0$ 的前提下，对 $x$ 进行任意次（包括 $0$ 次）操作，如下：

* 将 $x$ 变为 $ax - b$。

求通过操作能得到的 $x$ 的最小值。

## 分析样例：


### 第一组：
#### 输入：

```
6 2 4
```

#### 输出：

```
6
```
手动模拟得操作数为 $0$。
### 第二组：
#### 输入：
```
5 3 16
```
#### 输出：
```
-1
```
手动模拟得操作数为 $1$。

## 分析做法：
通过题目：**将 $x$ 变为 $ax - b$** 可以发现，其实进行一次操作后，$x$ 所增加的值为 $(a-1)x-b$，由于我们需要最小值，所以要保证 $(a-1)x < b$。

设第一次增加的值为正整数 $y$。

那么这一次的 $x$ 就等于 $x+y$。

下一次操作后就变化成 $a(x+y)-b$。

由于 $y$ 为正整数，所以如果第一次的值增加，那么就说明往后的 $x$ 一定是递增的，如果是减少，同理。

所以当 $x$ 不等于 $0$ 并且 $a$ 不等于 $0$ 时，$x$ 的值一定是单调递增或者递减的。

根据我们刚才所得出的结论，我们可以通过判断第一次操作所变化的值，判断 $x$ 递增或递减。

如果是递增，由于我们需要找的为最小值，所以选择不操作，这种就是样例中第一组的情况。

那如果是递减，那么我们就可以选择直接模拟至 $x$ 成为防负数。

接下来就是判断几个特殊情况。

首先，是 $a=1$。

当 $a=1$ 时，其实最小值就是不断减 $b$，直至 $x$ 成为负数，可以使用取模直接得出结果，而如果直接模拟会耗费大量时间，因为每一次操作会且只会减去一个 $b$，取模能够省掉很多时间。

然后就是当 $a=0$ 或 $x=0$。

当这种情况出现时，很显然，答案就是等于 $-b$。

## ~~处理矛盾~~：
我矛盾了很久的原因是不知道为什么可以直接模拟，难道不会超时吗？

其实可以发现，在排去特殊情况时，操作数一般都比较少，因为符合递减的情况下，$x$ 每一次操作所减少的数也是逐渐递增的。

## 实现：
```
#include<bits/stdc++.h>
using namespace std;
long long T,x,a,b;
int main(){
	cin>>T;
	while(T--)
	{
		cin>>x>>a>>b;
		if(a==0 || x==0) x=-b; //分类讨论：x=0 并且 a=0 的情况。
		else if((a-1)*x>=b) x=x; //分类讨论：递增的情况。
		else if(a==1) x=x%b-b; //分类讨论：a=1的情况。
		else while(x>=0) x=x*a-b; //分类讨论：正常情况。
		cout<<x<<endl;
	}
	return 0;
}
```

感谢管理员的审核！

---

## 作者：Ivan422 (赞：1)

题目大意：求当 $x\ge0$ 时不断进行 $x=ax-b$ 后得出的最小值是多少。

思路：这题可以按照 $a$ 的情况分类讨论。

当 $a=0$ 时，计算结果可能永远都是 $0$，会陷入死循环，也可能是 $0-b$，而这两个式子总结起来就是直接输出 $-b$。

当 $a=1$ 时，如果 $b=0$，这时结果永远不会变，会陷入死循环，答案就是 $x$。如果 $b\ne 0$，那么数值不断减少，最后变为负数，也就是 $x$ 取模 $b$ 后再减去一次 $b$。

当 $a>1$ 时，要是计算一次后的 $x$ 比原来的 $x$ 要大或相等，答案最小肯定是 $x$，输出 $x$ 即可。要是比原来的小，由于缩小速度极快，直接模拟操作，最后输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
//#define double long double
//#define map unordered_map
//#pragma GCC optimize(2,3,"Ofast","inline")
const int N=1e6+10,M=105,P=1e9+7,MOD=998244353;
const double PI=3.1415926,EPS=0.00001;
int t,a,b,x,y,pr;
bool r;
signed main(){
    cin>>t;
    while(t--){
        cin>>x>>a>>b;
        if(a==0){
            cout<<-b<<endl;
        }else if(a==1){
            if(b==0)cout<<x<<endl;
            else cout<<x%b-b<<endl;
        }else{
            if(x<=a*x-b)cout<<x<<endl;
            else{while(x>=0)x=a*x-b;cout<<x<<endl;}
        }
    }
    return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P10252 题目](https://www.luogu.com.cn/problem/P10252)

### 解题思路
这到题的要点其实就是分类讨论。

首先，若 $a=0$ 或者 $x=0$ 直接输出 $-b$ 即可。若 $a>b$ 或 $b=0$，那么只要每操作一次，$x$ 的值就会一定增加，输出 $x$ 即可。

其次，如果 $ax<b$，一次操作就可以使 $x<0$，输出 $ax-b$。如果 $ax-b\ge x$，无论操作了多少次，$x$ 也不会减少，输出 $x$。

经过上述讨论，就只剩下 $0\le ax-b<x$ 的情况了，这种情况下 $x$ 会随着操作次数的增加而减少，最终一定会变成负数，可以直接模拟。

但是当 $x=10^9$，$a=1$，$b\le2$ 时，需要循环很多次，会超限，此时需要对这种情况特判。当 $a$ 不为 $1$ 时，$x$ 每次操作减少的值会慢慢增加，不会超限。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	ios::sync_with_stdio(false);
    int t;
    scanf("%lld",&t);
    while(t--)
    {
		int x,a,b;
		scanf("%lld%lld%lld",&x,&a,&b);
		if(a==0||x==0)
		{
			printf("%lld\n",-b);
			continue;
		}
		if(b==1&&a==1)
		{
			printf("-1\n");
			continue;
		}
		if(b==2&&a==1)
		{
			int s=0;
			if(x%2==0)
				s=-2;
			else
				s=-1;
			printf("%lld\n",s);
			continue;
		}
		if(a>b||b==0)
			printf("%lld",x);
		else
		{
			if(x*a-b<0)
				printf("%lld",x*a-b);
			else
			{
				if(x*a-b>=x)
					printf("%lld",x);
				else
				{
					while(x>=0)
						x=a*x-b;
					printf("%lld",x);
				}
			}
		}
		printf("\n");
    }
    return 0;
}
```

---

## 作者：BLuemoon_ (赞：0)

[link](https://www.luogu.com.cn/problem/P10252)

## 题意

你可以进行如下操作，将 $x$ 变为 $ax-b$。求在保证 $x \ge 0$ 的情况下，经过任意次操作后 $x$ 的最小值。

## 思路

分类讨论。

- 如果 $ax-b \ge x$：

因为 $a,b \ge 0$，所以无论经过多少次变换，$x$ 单调不减，那么直接输出 $x$。

- 如果 $a = 0$：

那么经过一次变换后 $x$ 就变成了 $-b$，又因为 $b \ge 0$，所以 $-b \le 0$，则直接输出 $-b$。

- 如果 $a = 1$：

那么 $x$ 每次都减去 $b$，答案就是最大的 $p(p < 0)$，满足 $x-p \equiv 0 \pmod b$。

- 如果上述条件都不满足：

直接依题意模拟，可以证明时间复杂度为 $O(\log x)$，可以通过本题。

## 代码

```cpp
// BLuemoon_
#include <bits/stdc++.h>

using namespace std;
using LL = long long;

LL t, x, a, b;

int main() {
  for (cin >> t; t; t--) {
    cin >> x >> a >> b;
    if (a * x - b >= x) {
      cout << x << '\n';
    } else if (a == 0) {
      cout << -b << '\n';
    } else if (a == 1) {
      cout << x % b - b << '\n';
    } else {
      while (a * x - b >= 0) {
        x = a * x - b;
      }
      cout << a * x - b << '\n';
    } 
  }
  return 0;
}
```

---

## 作者：tanzexiaodezhonghao (赞：0)

## 思路
好的，乍一看可以暴力枚举，但本蒟蒻不会。打这场赛时，我在上课，然后我灵机一动，如果 $x \times a - b \ge x$ 就直接输出 $x$，否则输出 $x \times a - b$，结果拿了个 20 分，我也没多想。在经过一些思考和寻求帮助后，我发现，$a = 0$ 或 $a = 1$ 时，要有个特判：

- $a = 0$ 时，看看 $x$ 和 $-b$ 谁最小输出谁。
- $a = 1$ 时，如果 $b = 0$ ，输出 $x$，否则输出 $x \bmod b + b$。
- $x \times a - b \ge x$ 时，和上面一样，输出 $x$。
- $x \times a - b < x$ 时,刚刚我写了输出 $x \times a - b$，对了一半，怎么回事呢，经过参考和对拍，我找到了反例，所以还要循环枚举最小值。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    while(t--){
        long long x,a,b;
        cin>>x>>a>>b;
        if(a==0) cout<<min(x,-b)<<endl;//第一种情况
        else{
            if(a==1){//第二种情况
                if(b==0) cout<<x<<endl;
                else cout<<x%b-b<<endl;
            }else{
                if(a*x-b>=x){//第三种情况
                    cout<<x<<endl;
                }
                else{//第四种情况
                    int temp=x*a-b;
                    while(x>=0&&temp<x){
                        x=x*a-b;
                        temp=x*a-b;
                    }
                    cout<<x<<endl;
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：wangyishan (赞：0)

# P10252 线性变换 题解

## 题意

你有三个非负整数 $x,a,b$。在 $x \ge 0$ 的前提下，你可以对 $x$ 进行任意次（包括 $0$ 次）如下操作：

* 将 $x$ 变为 $ax - b$。

你需要求出你通过操作能得到的 $x$ 的最小值。

## 题解

令 $f(t)$ 表示操作到第 $t$ 次时 $x$ 的值。容易发现，$f(t)$ 是单调的。

那么我们首先特判掉 $f(t)$ 单调递增或不变时的情况，即判断 $f(1)\ge f(0)$。

然后对于 $a=0$ 或者 $a=1$ 的特殊情况，我们直接把它处理掉。

对于 $a\ge 2$ 时，打表发现它会下降得很快。于是只要模拟题目过程即可。

证明：感性理解一下。由于 $a,b$ 都是常数，$x$ 越变越小，$ax$ 就越来越小；而 $b$ 是不变的，每次都减上一个 $b$ ，自然没多久就减完了。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int x,a,b;
void solve(){
    cin>>x>>a>>b;
    if(x<=a*x-b){
        cout<<x<<endl;
        return;
    }
    if(a==0){
        cout<<-b<<endl;
        return;
    }
    if(a==1){
        int k=x/b;
        x-=k*b;
        while(x>=0)x-=b;
        cout<<x<<endl;
        return;
    }
    while(x>=0)x=a*x-b;
    cout<<x<<endl;
}

signed main(){
    int T;
    cin>>T;
    while(T--)solve();
    return 0;
}
```

---

## 作者：LostKeyToReach (赞：0)

我们先考虑特殊性质： 
- 当 $a > b$ 时，容易证明，$ax - b$ 不断迭代的值始终是单调不降的，那么我们取 $x$ 为最小值即可。

- 当 $b = 0$ 时，那么原式变为 $ax$，最小值即为 $\min(x,ax)$。注意，当 $a = 0$，$x > 0$ 时，$ax < x$，这就是取 $\min(x,ax)$ 而不是取 $ax$ 的原因。

这样我们就获得了 $40$ 分，接下来考虑剩下 $60 \%$ 的数据。

可以发现，$ax-b$ 不断迭代的值不是单调不降就是单调下降，那么我们用一个循环去计算最小值即可。

```cpp
long long now = x; // 最小值
while (now >= 0) {
    now = a * x - b;
    if (now >= x) break; // 如果当前值大于最小值，那就没有循环下去的必要了（ax-b 不断迭代的值不是单调不降就是单调下降）
    x = now; // 令 x 为最小值
}
cout << x << endl;
```

但是交上去后只有 [$70$](https://www.luogu.com.cn/record/151358334) 分，为什么呢？

经过分析，发现当 $a =  1$ 的时候，原式变为 $x - b$。考虑极端情况，只要令 $b = 1$，那么时间复杂度就会高达 $O(n)$（当 $a = 10^9$ 时肯定会超时）！在这种情况下，我们可以一次性让 $x$ 减去 $\lfloor\frac{x}{b}\rfloor \times b$，也就是令 $x$ 等于 $x \bmod b$，此时 $x$ 必定大于 $0$。那么我们再让 $x$ 减去 $b$ 就可以得到最小值。

[$100$ 分记录，$44$ 毫秒](https://www.luogu.com.cn/record/151378281)

代码如下：
```cpp
#include <iostream>
using namespace std;
int main() {
	int t;
	cin >> t;
	while (t--) {
		long long x, a, b;
		cin >> x >> a >> b;
		if (a > b) {
			cout << x << endl;
		}
		else if (b == 0) {
			cout << min(x, a * x) << endl;
		}
		else {
			if (a != 1) {
				long long now = x;
				while (now >= 0) {
					now = a * x - b;
					if (now >= x) break;
					x = now;
				}
				cout << x << endl;
			}
			else {
				cout << x % b - b << endl;
			}
		}
	}
}
```

---

## 作者：MicroSun (赞：0)

大佬的思路都那么复杂的吗qwq……

其实暴力枚举+特判就足够了。

以下为正确性证明：

1. $a=0$

明显进行一次暴力迭代后，就会因为 $x\le0$ 而退出。复杂度为 $\Omicron(1)$。

2. $a=1$

这是一个特殊情况。此时，因为每次迭代 $x\gets x-b$，所以会迭代 $\lfloor \frac{x}{b}\rfloor+1$ 次退出，进行特判即可。

3. $a>1$

这时，最坏的情况为 $a=2$ 且 $b=x+1$，但也只会迭代 $\Omicron(\log x)$ 次。这是因为每次迭代后，$b-x\gets2(b-x)$。

总复杂度为 $\Omicron(T\log x)$，符合要求。

坑点：$a=1$ 时要特判 $b=0$，否则会 `RE`。

明显 $a=1,b=0$ 时进行一次迭代后就会退出。

很短的代码：

```cpp
// Problem: P10252 线性变换
// LuoguUID: 514700 
// LuoguUserName: MicroSun
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define endl '\n'

using ll=long long;

void solve(){
	ll x,a,b;
	cin>>x>>a>>b;
	if(a==1&&b){
		cout<<x-b*((x/b)+1)<<endl;
		//(x/b)+1 次操作，每次减少b
		return;
	}
	while(a*x-b<x&&x>=0)
		x=a*x-b;
	
	cout<<x<<endl;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t=1;
	cin>>t;
	while(t--) solve();
	return 0;
}
```

---

## 作者：锦依卫小生 (赞：0)

# P10252
## 基本思路
借助数列的形式表达，记输入的 $x$ 为 $x_{1}$。应注意到，当 $a=0$ 时 $x$ 的取值只可能是 $x_{1}$ 或 $-b$，显然后者为答案。  
当 $a=1$ 时 ${x_{n}}$ 为等差数列，不难得到在题目约束下其可取到的最小值为 $x_{1} \bmod b - b$，注意特判 $b=0$ 的情况。  
当 $a>1$ 时，该数列的通项公式可借由等比数列得到。使用待定系数法，令 $x_{n+1}+t=a \times (x_{n}+t)$，解得 $t=-b/(a-1)$。由此可求出通项公式后判断单调性，得到当 $x_{1} - b/(a-1) \le 0$ 时，数列递减。当数列递减时，直接模拟迭代 $x$ 即可。（因为指数函数爆炸式增长所以复杂度一定满足题目要求）否则，$x_{1}$ 即为要求答案。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-5;
int T;
__int128 xx1,aa,bb;
inline __int128 read()
{
    __int128 x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void print(__int128 x)
{
	if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    if (x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}
void solve(){
	xx1=read(),aa=read(),bb=read();
	double x1=xx1,b=bb,a=aa;
	if(a==0){
		print(-1*b);
		cout<<endl;
		return;
	}
	if(aa==1&&b==0){
		print(xx1);
		cout<<endl;
		return;
	}
	if(aa==1){		
		print(xx1%bb-bb);
		cout<<endl;
		return;
	}
	if(x1-b/(a-1)>0||abs(x1-b/(a-1))<eps){
		print(xx1);
		cout<<endl;
		return;
	} 
	__int128 x=xx1;
	while(x>=0){
		x=aa*x-bb;	
	}
	print(x);
	cout<<endl;
}
int main(){
	cin>>T;
	while(T--){
		solve();
	}
}
```

---

## 作者：ys_kylin__ (赞：0)

刚开始看到这道题，我认为：可以先判断一次 $ax-b$ 是否大于 $x$，再决定是否继续做，但是这样很明显会超时，因为实际上有一些特殊情况可以 $O(1)$ 的计算出来而不用循环那么长时间，也有一些情况无法用一般方法得出正确结果。

1. 当 $a>b$ 时，此时无论 $x$ 多小，$ax-b$ 必定大于 $x$，因此直接输出 $x$。
2. 当 $b==0$ 且 $a==0$ 时，结果显然为零。
3. 当 $a==1$ 时，此时 $x$ 的下降是有规律的，每次减 $b$。并且有可能这个过程太慢了，所以需要特殊考虑。事实上，只有一个测试点出现这种情况，但是不判的话，将会以一个十分极限的时间超时（1.02秒）。而这个数学计算式为 `x-((x/b)+1)*b`，这就是答案。
4. 一般情况：先测一遍 $ax-b$，大于 $x$ 就输出 $x$，否则就一直操作直到 $x$ 为负。

不开 long long 见祖宗！

代码部分：

```cpp
#include<bits/stdc++.h>
#define int long long
#define p(x) printf("%lld\n",x)//快速地输出
using namespace std;
inline int read() {
	int x=0; bool y=false;
	char ch=getchar();
	while(ch<'0' || ch>'9') y=(ch=='-'),ch=getchar();
	while(ch>='0' && ch<='9') x=(x<<3)+(x<<1)+(ch^'0'), ch=getchar();
	return y?-x:x;
}
inline void write(int x) {
	if(x<0)putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}//快读快写
signed main(){
	int t;
	scanf("%lld",&t);
	while(t--) {
		int x=read(),a=read(),b=read();
		if(a>b) p(x);
		else if(b==a && a==0) p(0ll);//因为是以long long 输出的，所以是0ll
		else if(a==1) p(x-((x/b)+1)*b);
		else{//一般情况
			if(x<=a*x-b){
				p(x);
				continue;
			}
			while(x>=0){
				x=a*x-b;
			}
			p(x);
		}
	}
	return 0;
}
```

---

## 作者：sbno333 (赞：0)

这道题是一道很有意思的题，数据大小仍然有增加空间。

看到操作，你可曾有很多神奇想法？

## 部分分及正解引入

* 暴力

直接模拟即可，期望 $30$ 分。

* 特殊性质

首先，对于 $ax-b\ge x$ 的情况，由于 $a\ge 0$，因此 $x$ 越大，增加越快，因此此时答案为 $x$，当 $a>b$ 时，由于数据很水，因此满足这项，期望 $20$ 分，剩下的情况可以暴力。

当然，对于 $b=0$，只有 $a=0$ 时，才会变小，加上暴力就是 $70$ 分。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int x,a,b;
void _main(){
	while(x*a-b<x&&x>=0){
		x=a*x-b;
	}
	cout<<x<<endl;
}
signed main(){
	int t;
	cin>>t;
	while(t--){
		cin>>x>>a>>b;
		_main();
	}
	return 0;
} 
```
接下来就是正解。

## 解法一：性质

可以发现，当 $a\ge2$ 时，如果满足 $ax-b<x$，每次减的数量至少翻倍，证明如下：

设某次减少 $t$，减少前为 $s$，有 $as-b=s-t$。

此时考虑再次减少。

$a(s-t)-b=as-at-b=(as-b)-at=s-t-at$。

由于 $a\ge2$，因此 $at\ge2t$，再次减少为前一次的两倍以上，这样次数就是 $\log$ 级别的。

于是我们可以特判 $b=0$ 和 $a\le1$ 的情况，这是好维护的，剩下的情况直接模拟。

时间复杂度 $O(T\log n)$。

接下来的做法可以跳过。

## 解法二：性质+矩阵加速

对于模拟的题目，一种比较自然的想法是二分查找操作次数，可以设置一个向量，长度为 $2$，如下：

$\begin{bmatrix}x & -1\end{bmatrix}$。

每次操作乘一个如下的矩阵：

$\begin{bmatrix}a & 0\\b & 1\end{bmatrix}$。

然后二分查找操作次数，每次得到一个操作后答案，退回一次操作，查看是否 $\ge0$。

当然，由于运算过程中可能越界，因此也要通过性质来确定二分右边界。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
struct jz{
	int f[3][3]={};
	jz operator*(const jz dd)const{
		jz ans;
		for(int i=1;i<=2;i++){
			for(int j=1;j<=2;j++){
				for(int k=1;k<=2;k++){
					ans.f[i][j]+=f[i][k]*dd.f[k][j];
				}
			}
		}
		return ans;
	}
}s;
__int128 x,a,b;
jz ksm(int t){//矩阵快速幂
	jz ans,z;
	ans.f[1][1]=1;
	ans.f[2][2]=1;
	z=s;
	while(t){
		if(t&1){
			ans=ans*z;
		}
		z=z*z;
		t>>=1;
	}
	return ans;
}
void _main(){
	int l,r;
	if(x*a-b>=x){
		cout<<(long long)x<<endl;
		return;
	}
	if(a==0){
		cout<<(long long)(x*a-b)<<endl;
		return;
	}
	l=1;
	if(b==0)r=1;
	else
	r=40;
	if(a==1){
		cout<<(long long)(x-x/b*b-b)<<endl;
		return;
	}
	int ans;
	ans=0;
	while(l<r){
		int mid;
		mid=l+r+1;
		mid>>=1;
		jz k;
		k=ksm(mid);
		int ans;
		ans=k.f[1][1]*x+k.f[2][1];//得到操作后答案
		if((ans+b)/a>=0){//退回操作>=0?
			l=mid;
		}else{
			r=mid-1;
		}
	}
	jz k;
	k=ksm(l);
	ans=k.f[1][1]*x+k.f[2][1];//再算一遍
	cout<<(long long)ans<<endl;
}
signed main(){
	signed t;
	cin>>t;
	while(t--){
		long long a1,a2,a3;
		cin>>a1>>a2>>a3;
		//cin>>x>>a>>b;
		x=a1,a=a2,b=a3;
		s.f[1][1]=a;
		s.f[2][1]=-b;
		s.f[1][2]=0;
		s.f[2][2]=1;
		_main();
	}
	
	return 0;
} 
```
马蜂丑陋勿喷。

这样二分的复杂度为 $O(\log\log n)$，快速幂同，最终时间复杂度为 $O(T\log^2\log n)$，但是常数较大，由于数据小，可能比不过解法一。

## 解法三：多项式展开

首先我们先计算一个公式：

$f(s,r,n)=\sum\limits_{i=0}^n s^ir^{n-i}$。

考虑列方程，有 $f(s,r,n+1)=f(s,r,n)\times r+s^{n+1}=f(s,r,n)\times s+r^{n+1}$。

设 $f(s,r,n)=z$。

则 $rz+s^{n+1}=sz+r^{n+1}$。

移项得 $s^{n+1}-r^{n+1}=sz-rz$。

根据分配率，得到 $s^{n+1}-r^{n+1}=(s-r)z$。

得到 $z=\cfrac {s^{n+1}-r^{n+1}}{s-r}$。

接着我们考虑 $k$ 此操作得到的式子。

$1$ 次操作后为 $ax-b$。

$2$ 次操作后为 $a^2x-ab-b$。

$3$ 次操作后为 $a^3x-a^2b-ab-b$。

$\dots$

$k$ 次操作为 $a^kx-\sum\limits_{i=0}^{k-1}a^ib$。

$a^kx-\sum\limits_{i=0}^{k-1}a^ib=a^kx-b\sum\limits_{i=0}^{k-1}a^i\times1^{k-1-i}=a^kx-b\cfrac{a^k-1}{a-1}$。

可以二分查找 $k$，然后快速幂计算，常数比矩阵小，时间复杂度没变。

当然，解方程可能可以进一步降低时间复杂度，但将会复杂很多。

---

## 作者：__xsy2013__ (赞：0)

本题是简单分类讨论题。

- 当 $a_x-b\geq x$ 时，那么肯定会越变越大，此时不变最优，则为 $x$。

- 当 $b=0$ 并且 $a=0$ 时，显然经过多次变换后会等于 $0$，那么答案就是 $0$。

- 当 $b=0$ 但是 $a>0$ 时，显然经过 $n$ 次变换后为 $a^b \times x$，但是得出的结果没有 $x$ 更优，那么答案还是 $x$。

- 当 $a=0$ 但是 $b>0$ 时，显然经过 $n$ 次变换后为 $x-kb$，$k$ 取最大时 $x$ 最小，最小为 $x-\lceil\frac{x}{b}\rceil b$。

- 其它情况直接暴力，时间复杂度为 $O(\log x)$。

下面给出赛时 AC 代码，作为参考，请勿抄袭。

如果有人觉得代码有点复杂，是因为这是我赛时憋出来的。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long T, x, a, b;
int main() {
	cin >> T;
	while(T--) {
		cin >> x >> a >> b;
		if(a == 0) cout << -b << endl;
		else if(b == 0) cout << x << endl;
		else if(a == 1) {
			x = x % b;
			cout << x - b << endl;
		} else {
			if(x == 0) cout << -b << endl;
			else if(x * a < b) cout << a * x - b << endl;
			else if(x * a == b) cout << -b << endl;	
		    else if((x * a > b) && (x * (a - 1) < b)) {
				while(x >= 0) x = a * x - b;
				cout << x << endl;
			} else if(x * (a - 1) == b) cout << b / (a - 1) << endl;
			else if(x * (a - 1) > b) cout << x << endl;
		}
	}
	return 0;
}
```

[赛时悲惨提交记录，误喷](https://www.luogu.com.cn/record/list?pid=P10252&user=575714)


这里总结一下小坑。

这道题以及这场比赛让我深深的意识到了“十年 OI 一场空，不开 `long long` 见祖宗”，大家一定要注意如果可能会爆 `int` 那么就开 `long long`，多开总比少开好。

### 暴力

1. 如果您 30pts，那么请注意开 `long long`。

应该最高得到 70pts。

### 正解

大家都用的哪些方式呢？我用的是数学。

1. 如果您 20pts，那么请注意您的式子推错了。

2. 如果您 60pts，那么请注意 $x \bmod 0$ 也是会出现浮点数异常的，因为 $0$ 不能做除数，这是小学数学，但是还是调了很久。

3. 另外因为浮点数的精度问题，建议采用乘法，就是把除法改为乘法进行计算。

---

## 作者：紪絽 (赞：0)

# [P10252](https://www.luogu.com.cn/problem/P10252) 题解

一直没有想到 $a$ 可能等于 $1$，白交了好多发，好蠢……

## 题意

题面很清楚了。

## 解析

有一个很且显然的想法是：每次 $x$ 变换后，如果变换后的 $x ^ \prime > x$，那么 $x$ 在接下来的变换里只会越来越大；反之亦然。具体的下面会提及。

找找规律：

变换一次：$x_1 = ax - b$。  
变换两次：$x_2 = ax_1 - b = ax^2-ab-b$。  
变换三次：$x_3 = ax_2 - b = ax^3-a^2b-ab-b$。  
变换 $i$ 次：$x_i = a^ix - \sum_{j=0}^{i-1}a^jb$。

嘶……没头绪。那看看每次 $x$ 增加的量是多少：

$$ 
\begin{aligned}

\Delta x &= x_i-x_{i-1} \\
&= a^ix - \sum_{j=0}^{i-1}a^jb - \Bigg( a^{i-1}x - \sum_{j=0}^{i-2}a^jb \Bigg) \\

&= a^ix-a^{i-1}x-a^{i-1}b \\
&= a^{i-1}(ax - x + b)

\end{aligned}
$$


可以看见 $ax - x + b$ 这个数是第一次变换后，$x_1$ 与 $x$ 的差值。$x$ 的增加与否与前面的 $a^{i-1}$ 无关（$a \ge 0$），只跟 $ax - x + b$ 有关，而 $ax - x + b$ 是一个定值。这也说明了开头猜想的正确性。

从这里我们可以发现一种特殊情况：如果 $ax - x + b \ge 0$，那么 $x$ 变换后不可能变小，一开始的 $x$ 就是最小值。这种情况直接输出 $x$ 即可。

现在来考虑 $ax - x + b < 0 $ 的一般情况。我们要求记的毕竟不是增加量，而是想求出它每一次变换后 $x_i$ 的大小。使用上面的差值求和试试看？记 $ax - x + b$ 为 $d$，设 $i$ 为变换次数，那么变换 $i$ 次后：
$$ 

x_i =x+\sum \Delta x  = x + \sum_{i=1} a^{i-1} d = x + d \times \frac{a^i-1}{a-1}

$$
那么只要枚举 $i$，判断这个能在右边的式子是否小于 $0$ 即可。$\Delta x$ 中的 $a^{i-1}$ 增长速度很快（$a \le 10^9$），不用二分就能过（或许可能数据太水了 = =）。

注意，这里的 $a - 1$ 为分母，**需要特判 $\pmb{a = 1}$ 的情况**。答案易知是 $x - \lceil \frac{x}{b} \rceil \times b$。还有一种特殊情况：当 $a = 1$ 或 $x = 1$ 时，直接输出 $-b$ 即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll T, x, a, b;

ll qpow(ll a, ll b) // 快速幂 
{
	ll res = 1;
	while (b)
	{
		if (b & 1) res *= a;
		a *= a, b /= 2;
	}
	return res;
}

void solve()
{
	cin >> x >> a >> b;
	if (a * x - b >= x)
	{
		cout << x << endl;
		return ;
	}
	if (a == 0 || x == 0)
	{
		cout << -b << endl;
		return ;
	}
	if (a == 1)
	{
		cout << x - (x / b + 1) * b << endl;
		return ;
	}
	ll d = a * x - b - x;
	for (int i = 1; ; i++)
	{
		if (x + d * (qpow(a, i) - 1) / (a - 1) < 0)
		{
			cout << x + d * (ksm(a, i) - 1) / (a - 1) << endl;
			break;
		}
	}
	return ;
	
}

int main()
{
	cin >> T;
	while (T--)
		solve();
	
	return 0;
}
```

---

## 作者：ggylz49 (赞：0)

~~本题不是非常难。~~
## 思路点拨
在解决本题时，有几个要注意的地方：
- 如果 $x$ 在变大，就一定会一直变大，因为每一次的操作都是同向的，要么变大要么变小。
- 如果 $a>b$，那么直接输出 $x$ 就行了。具体如下：
> 假设 $a-b=k$（$k$ 是自然数），那么可以将每一次的变化写成 $x\times (a-1)+k$。可以发现 $x$ 一定在变大，因为 $a$ 至少是 $1$（否则 $b$ 就没有数可以替代了），又加上一个非负整数，所以它一定比之前更大。那既然 $x$ 在变大，那么直接输出 $x$ 就行了。
- 如果 $a\le b$ 且 $a=1$，那么每一次 $x$ 都会变成 $x-b$，最终结果就是 $(x \bmod b)-b$，即模拟了连续减了好几次 $b$ 直至不够减了，就只能再减一次让它为负（也就是最小了）。至于 $a \le b$ 则是怕 $b=0$，取模运算出现运行时错误。
- 否则就暴力了。设置一个过程变量 $p$，记录变换前 $x$ 的信息。如果 $x$ 变化后是负数或 $0$，直接输出 $x$；如果变化后的 $x$ 比 $p$ 大，则说明 $x$ 在变大，输出 $p$。
## Code
不多说了，贴代码吧。
```cpp
#include <iostream>
using namespace std;
int main()
{
    long t;//数据组数
    cin>>t;
    while(t--)
    {
        long long x,a,b,p;//不开long long见祖宗。变量p含义如上最后一条所述。
        cin>>x>>a>>b;
        p=x;//刚开始p就是x。
        if (a>b)cout<<x<<endl;//对应思路点拨第二条
        else if (a==1)cout<<x%b-b<<endl;//对应思路点拨第三条
        else 
        {
            while(1)
            {
                x=a*x-b;//更新x
                if (x<=0){cout<<x<<endl;break;}//如果x已经为负或为0，直接输出x并跳出
                if (p<x){cout<<p<<endl;break;}//如果x在变大，输出上一次的结果(也就是p)，跳出
                p=x;//更新p
            }
        }
        //记住，一定要记得换行！
    }
    return 0;
}
```

---


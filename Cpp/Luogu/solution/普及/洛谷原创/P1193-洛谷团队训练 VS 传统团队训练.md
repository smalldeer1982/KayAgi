# 洛谷团队训练 VS 传统团队训练

## 题目背景

“在中学的信息学教育领域，[洛谷](/)无疑是一个相当受欢迎的辅助网站。同时有百余所学校正在通过洛谷进行信息学竞赛（以后简称 OI）的教育。洛谷之所以如此受欢迎，是因为洛谷创新的将 OI 教育的几乎每一个环节都搬到了线上，无论是学校的竞赛教练还是学生，均可以仅仅使用这一个网站来进行练习，提升自己的能力。”


——摘自《厦门中小学教育科学研究》，2015 年 2 月号。


## 题目描述

XX 中学的两位信息组的教练正在为学校信息组是否应当将洛谷作为主要的训练工具而争论不休，最后决定采取一个量化的办法来决定是否迁移。

该中学的原来训练方法是，在机房的教师机里面用 cena 装载好测试数据，装载数据所需要 $T_a$ 时间，每一道题目都要装载。学生写好代码后，可以跑到教师机上收取程序并进行评测。但由于需要往返的路程，因此每跑一次就要浪费 $T_b$ 时间。所以也允许学生在自己的机子上装载好测试数据，可以根据自己的需要选择装载的题目，这需要花费和在教师机装载数据一样的时间 $T_a$，但是每次评测花费的时间就减少为 $T_c$。此外，该中学可能会用 Excel 记录各位同学的训练情况，如果某位同学的某道题的得分高于表格里的记录，那就会花费 $T_d$ 时间将这个成绩更新，否则就不必费那个事了，如果之前没有提交过这道题视为表格记录的程序为 $0$ 分。

而在洛谷中，只需要将题目和测试数据上传到洛谷，花费 $T_a$ 时间。每次评测学生只需花费 $T_c$ 时间即可。记录成绩？那是洛谷的事儿，一提交完就帮你整理好了表格根本不费时间。

看起来可以省下不少时间吧。。然而，支持传统训练方法的教练认为，洛谷并非 $100 \%$ 的稳定，在有的情况会无法提供服务，因此首先要将洛谷的耗时除以它的可用度（一个小于 $100\%$ 的数字 $A\%$）并去掉小数点。又因为传统观念不易纠正，总是有不信任将题目数据交给洛谷这样的想法（kkksc03：怪我咯？），因此使用洛谷的耗时还要再加上一个罚时 $H$ 以做公平比较。

现在给出该中学的训练情况，希望你帮两位教练分析一下到底该如何选择。

## 说明/提示

**【样例解释 #1】**

使用传统方法的话，装载 $4$ 道题目需要 $4 \times 50=200$，$2$ 号同学和 $7$ 号同学用教师机需要时分别 $30 \times 3=90$、$30 \times 4 = 120$，但是明显自己装载 cena 只需要 $50+10 \times 3=80$、$50+10 \times 4=90$ 更优。而 $3,5$ 同学则使用教师机就好，耗时 $60,30$。$2$ 号同学的前两次评测单调递增，所以额外花费 $2 \times 5=10$ 时间记录，$3$ 号同学太弱了都是 $0$ 分所以没必要记录了，$5$ 与 $7$ 各耗费 $5$ 时间。所以这种情况总时间耗时为 $200+80+90+60+30+10+5+5=480$。

使用洛谷的话，装载题目耗费 $200$，$10$ 次评测共耗费 $10 \times10=100$，考虑稳定性时间为 $(200+100) / 93\% = 322$，所以最后总耗时为 $322+50=372$，所以决定使用洛谷。

**【数据范围】**

其中 $50\%$ 数据中，不需要进行成绩的 Excel 记录。

其中 $50\%$ 数据中，题目编号和学号均大于等于 $0$，小于等于 $1000$。

（这两种情况，可能会重叠）

对于 $100\%$ 的数据，保证 $1 \le n,m \le 1000$，$1 \le T_a, T_b, T_c,T_d,H \le 10000$，$1 \le R < 100000$，$0 \le \mathit{Sc}_i \le 100$，$1 \le A \le 100$，学号和题目号在 ${10}^8$ 之内。

实际上，根据超级监控颁发的证书，洛谷 2015 年第一季度可靠性（SLA）为 $99.36 \%$。同时观念也是可以改变的。

洛谷的优点很多都是不能量化的，其精华在于社区。和全国的 OIer 一起学习交流，不很好吗？

最后插一句，去年的【榨取 kkksc03】的布告依然有效，详情。

## 样例 #1

### 输入

```
4 4
501 502 503 504
2 3 5 7
50 30 10 5 93 50 1
10
501 2 10
501 2 80
501 2 70
502 3 0
502 3 0
504 5 100
503 7 0
503 7 0
503 7 0
503 7 10
```

### 输出

```
480
372
Use Luogu!
```

## 样例 #2

### 输入

```
2 3
101 102
1 2 3
70 60 50 1 80 100 0
6
101 1 100
101 2 100
101 3 100
102 1 100
102 2 100
102 3 100
```

### 输出

```
500
650
Forget it...
```

# 题解

## 作者：kkksc03 (赞：161)

其实很多人被题目描述吓跑了。实际上这是一道很简单的模拟题。

有很多解法


先说基本思路，只需要存下某个选手的某道题目的成绩和次数即可。对于一半的小规模数据，直接用二维数组模拟。

如何选择是在自己电脑装载数据还是去教师机评测呢？比较两者的总时间即可啊。


可是学号跟题目号会很大，怎么办？

1、离散化，将学号题目号排序，映射到[1000][1000]的二维数组。查询的时候就用二分查找。

2、hash，这个不用说了，核心也是离散化。

3、自己写平衡树，显然可以但是没必要杀鸡用牛刀。

4、语言歧视问题，c++还能用map，根本就不用考虑以上的问题，直接当做二维数组做了。


语言实现很简单，不给代码了。


---

## 作者：游戏的人 (赞：66)

# 洛谷~~宣传~~好题，来捧个场
   看着冗长的题目很容易被吓到，其实就是一道大模拟题，按着题目打基本没有什么问题，这时就考验简化代码、理清思路和找出快速重难点的能力。
   
## 思路

   看完题目后**洛谷的耗时**很容易求出为
   
```
luogu=(ta*n+tc*r)*100/A+H;
```

其中本来是除以A%，经过移项避免了小数的处理。
	
   而**传统的耗时**则选择以人计算，比较选手做每一题时，比较自己评测和老师评测的耗时，选择小的加入，具体见代码。


------------

## 数据范围


   因为给出评测数据题和人**一一对应**，所以要用**二维数组**储存关系，数据范围给出编号是**10的8次方**，n和m却只有1000，所以可以考察**离散化**，按照大小顺序来重新当作编号。
   
   而离散化可以用c++自带的**map**和**hash**，以及**二分查找**下标，因为map和hash其他大佬已经说得很清楚了，我就说说二分查找。
## 二分查找实现
其实没有太大的不同，就是先将编号数组排序，让原本的学生和题目编号变有序，**注意一定要先排序**，否则没有单调性，无法用二分查找。之后以排完序的数组下标作为新的编号，便可以使用二维数组储存了。

二分查找可以使用**lower_bound**函数，找到数组下标，如下：
```
	pr=lower_bound(p+1,p+n+1,pr)-p;
	sr=lower_bound(s+1,s+m+1,sr)-s;
```

## 总结
1. 读入
2. 排序处理
3. 储存评测数据（二分查找）
4. 计算出洛谷耗时和传统耗时
5. 输出
## 上~~高清~~代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ta,tb,tc,td,A,H,E,r,pr,sr,sc;
int tea,self,trad,luogu,p[1001],s[1001],score[1001][1001],jud[1001][1001];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>p[i];
	for(int i=1;i<=m;i++) cin>>s[i];
	sort(p+1,p+n+1);    //排序预处理 
	sort(s+1,s+m+1);
	cin>>ta>>tb>>tc>>td>>A>>H>>E;
	cin>>r;
	trad=ta*n;  //传统导入数据初始化 
	for(int i=1;i<=r;i++)
	{
    	cin>>pr>>sr>>sc;
    	pr=lower_bound(p+1,p+n+1,pr)-p;     //二分查找离散化下标 
    	sr=lower_bound(s+1,s+m+1,sr)-s;
    	if(sc>score[sr][pr]&&E) trad+=td,score[sr][pr]=sc;  //excel更改 
    	jud[sr][pr]++;  //评测次数加一 
	}
	luogu=(n*ta+r*tc)*100/A+H;  //洛谷耗时 
	for(int i=1;i<=m;i++)
	{
	    for(int j=1;j<=n;j++)
	    {
	        tea=0; self=ta;     //记得重新初始化 
	        tea+=tb*jud[i][j];      //老师评测耗时 
	        self+=tc*jud[i][j];     //自己评测耗时 
	        trad+=min(tea,self);        //取更小值 
	    }
	}
	cout<<trad<<endl<<luogu<<endl;      //输出 
	if(luogu<trad) cout<<"Use Luogu!"; 
	else cout<<"Forget it...";
}
```


### 完结撒花 ~~留个赞吧~~

---

## 作者：ysner (赞：56)

看着楼下出题人没给代码，本蒟蒻冒昧献上一份有代码的题解。

首先如楼下所说，只需要存下某个选手的某道题目的成绩和次数，在自己电脑装载数据还是去教师机评测由两者的总时间大小比较决定。

然后，我应用了C++的语言优势map（一种映射）去将（选手编号、题目编号）分别与成绩、提交次数对应。

所以说，这题只是一道模拟题，估摸也就普及组第二题难度。

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<map>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(register int i=a;i<=b;i++)
#define fq(i,a,b) for(register int i=a;i>=b;i--)
using namespace std;
map<int,int>t,x;//t用于将题目编号离散化，x用于将学生编号离散化
int n,m,r,ta,tb,tc,td,a,h,e,c,j[2005][2005]={},f[2005][2005]={};
ll ans1=0,ans2=0;//ans1是用传统团队训练的时间，ans2是用洛谷团队训练的时间
int s1,s2;
il ll gi()//读入优化
{
  re ll t=1,x=0;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
  n=gi();m=gi();
  fp(i,1,n)
    t[gi()]=i;
  fp(i,1,m)
    x[gi()]=i;
  ta=gi();tb=gi();tc=gi();td=gi();a=gi();h=gi();e=gi();r=gi();
  ans1=n*ta;ans2=n*ta;//加上装载数据所需时间
  fp(i,1,r)
  {
    s1=gi();s2=gi();c=gi();
    s1=t[s1];s2=x[s2];j[s1][s2]++;//更新交题次数
    if(e&&c>f[s1][s2]) f[s1][s2]=c,ans1+=td;//加更新成绩所需时间
  }
  fp(i,1,n)
    fp(j1,1,m)
  {
    int p=tb*j[i][j1];
    int z=ta+tc*j[i][j1];
    if(p>z) ans1+=z;
      else ans1+=p;
```
}比较在自己电脑装载数据和去教师机评测的时间，选其小者
```cpp
  ans2=(ll)((ans2+r*tc)/(a/100.0))+h;
  printf("%lld\n%lld\n",ans1,ans2);
  if(ans1<=ans2) printf("Forget it...\n");
    else printf("Use Luogu!\n");
  return 0;
}
```

---

## 作者：火石 (赞：14)

不用map的题解

本鶸的第一个题解，请大家支持一下，谢谢

我看之前的人都是用map做题，可是我不会用map 而且这题数据无法使用数组（题目范围为1~1e8，远远超过数组的最大上限）

怎么办QAQ

然后我发现题目的输入部分关于测评的描述可以理解为：

①：总计R次输入，每次输入测评的题目和测评的人还有这个人的得分

②：每次统计的要点为：提交的题目、人、得分（还有最重要的先后顺序）

可是我们没有办法用一个数组将题目和人一一对应上，而本鶸又不会用map，事情好像陷入了死局↓

但是我发现：我们可以将每个人对于同一题目的提交记录下来，换题和换人分别用对应的变量变化来表达

人和题都不可能超过1000，正好在数组的范围之内

于是我就想了一个办法：将提交排序！
```cpp
bool cmp(ac wa,ac b)
{
    if(wa.r!=b.r)
        return wa.r<b.r;//按照提交的人排序
    else if(wa.p!=b.p)
        return wa.p<b.p;//同一个人按照提交的题目排序
    else
        return wa.ake<b.ake;//核心：如果记录成绩的话，提交的顺序是不能改变的，所以我们对于同一人同一题要按照提交先后排序
} 
```
## 上代码
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,ta,tb,tc,td;//ta装数据 tb跑 tc测评 td更新 
int a,h,e,R;//a可用度 h罚 e是否记录 
long long ans1,ans2;
int p[1005],num[1005];// 题号 学号
struct ac
{
	int p,r,c,ake;//题目，学号，成绩 输入次序 
}cp[100005];
int sc[1005][1005],cnt[1005][1005];
//sc记录最高分，cnt记录每个人对于不同题目的提交次数以决定是去找老师还是自己搞
bool cmp(ac wa,ac b)
{
	if(wa.r!=b.r)
		return wa.r<b.r;
	else if(wa.p!=b.p)
		return wa.p<b.p;
	else
		return wa.ake<b.ake;
} //同上排序
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) 
		cin>>p[i];
	for(int i=1;i<=m;i++)
		cin>>num[i];
	cin>>ta>>tb>>tc>>td>>a>>h>>e;
	cin>>R;
	ans1=n*ta;//不管怎么做，都需要装载数据
	ans2=n*ta;
	for(int i=1;i<=R;i++)
	{
		cin>>cp[i].p>>cp[i].r>>cp[i].c;//读入人、题、分
		cp[i].ake=i;//记录提交顺序
		ans2+=tc;//洛谷计时
	}
	sort(cp+1,cp+1+R,cmp);
	int tle=1,mle=1;//记录学生 题目 
	for(int i=1;i<=R;i++)
	{
		if(sc[tle][mle]<cp[i].c)//最高分变更
		{
			sc[tle][mle]=cp[i].c;
			if(e)//最高分记录和计时
			{
				ans1+=td;
			}
		}
		cnt[tle][mle]++;
		if(cp[i].p!=cp[i+1].p)
			mle++;//同一个人，换一道题
		if(cp[i].r!=cp[i+1].r)
		{
			tle++;//换了一个人
			mle=1;//从他提交的第一个开始
		}
	}
	for(int i=1;i<=tle;i++)//决定是找老师还是自己测
	{
		for(int j=1;j<=1001;j++)
			ans1+=min((tb*cnt[i][j]),(ta+(tc*cnt[i][j])));
	}
	ans2=(long long)ans2/(a/100.0);//可用度
	ans2+=h;//对洛谷惩罚
	cout<<ans1<<endl<<ans2<<endl;
	if(ans1>ans2)
		cout<<"Use Luogu!";//kkksc03很开心
	else
		cout<<"Forget it...";//kkksc03：QAQ
	return 0;//完结撒花
}

谢谢支持


---

## 作者：DrunkXT (赞：7)

题目怎么讲就怎么做。

关于学号的问题可以用映射也可以用map（map更方便）

传统方法比较麻烦，用两个数组：

f[MAXN][MAXN];//存储每人每题提交次数 ，每次加一个，最后统计传统方法是自己测还是上去测

sc[MAXN][MAXN];//存储每个人最高分 ，不断更新

~~我的方法和一个题解非常像，但我觉得我的代码好懂些~~

~~反正每个人都这样想~~

代码
```cpp
#include<cstdio>
#include<map>
#include<algorithm>
using namespace std;
map<int,int>p,s;//用map存储 
const int MAXN=1005;
int f[MAXN][MAXN];//存储每人每题提交次数 
int sc[MAXN][MAXN];//存储每个人最高分 
long long minx(long long x,long long y)
{//long long型min 
	if(x<y)
	    return x;
	return y;
}
int main()
{
	freopen("洛谷团队训练VS传统团队训练.in","r",stdin);
	freopen("洛谷团队训练VS传统团队训练.out","w",stdout);
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int x;
	    scanf("%d",&x);
	    p[x]=i;
	}
	for(int i=1;i<=m;i++)
	{
		int x;
	    scanf("%d",&x);
	    s[x]=i;
	}
	int ta,tb,tc,td,a,h,e;
	scanf("%d%d%d%d%d%d%d",&ta,&tb,&tc,&td,&a,&h,&e);
	int r;
	scanf("%d",&r);
	long long t1=n*ta;//传统 
	long long t2=n*ta;//洛谷 
	//不管什么方式都要加入题目 
	while(r--)
	{
		int pp,s1,s2;
		scanf("%d%d%d",&pp,&s1,&s2);
		pp=p[pp];
		s1=s[s1];//map 
		f[pp][s1]++;//存每人每题交的次数 
		if(e==1&&s2>sc[pp][s1])
		{
		    sc[pp][s1]=s2;//存最高分 
		    t1+=td;
		}
		t2+=tc;//洛谷评测 
	}
	for(int i=1;i<=n;i++)
	    for(int j=1;j<=m;j++)
	    {
	    	int sq=tb*f[i][j];//上去评测 
	    	int bsq=ta+tc*f[i][j];//不上去评测 
	    	t1+=minx(sq,bsq);
	    } 
	t2=(long long)t2/(a/100.0);
	t2+=h;//赖皮规则 
	printf("%lld\n%lld\n",t1,t2);
	if(t1<t2)//比较大小 
		printf("Forget it...\n");
    else
		printf("Use Luogu!\n");
  	return 0;
}
```

PS：个人认为洛谷更好~~，初中老师不用洛谷训练，还是怕我们上外网，毕竟（包括我在内的）很多人听不懂~~

---

## 作者：SIXIANG32 (赞：6)

一道鬼畜模拟题……  
闲话少说，切入正题——


------------
这道题的关键就是**修改分数**。  
很直观的方法就是直接用题号做下标然后查询。  
可是这题的数据非常鬼畜，题号在 $10^8$ 以内，显然这样开二维数组会炸，炸得很惨。  
那么我们该怎么样呢？我用了两种方法，一种是哈希，一种是 ```map``` 。  


------------
这道题我们爆了空间，那么 ```map``` 就能很好的解决这个问题。  
```map``` 是映射，可以当数组使，但是不会像数组一样直接用内存，是不断添加元素的。  
```map``` 内置一颗红黑树，时间复杂度是 $\log_2$ 级别的，在别的题目可能会时间爆炸，但是这题的数据小，能过。 

代码：
```cpp
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
int ta,tb,tc,td,a,h,e;
map<int,int>M1,M2;//建立两个map，M1存储题号，M2存储学好
int score[1010][1010];
int num[1010][1010];
int main()
{
	int n,m,r;
	cin>>n>>m;
	for(int p=1,x;p<=n;p++)
		cin>>x,M1[x]=p;//map加入元素
	for(int p=1,x;p<=m;p++)
		cin>>x,M2[x]=p;//map加入元素
	cin>>ta>>tb>>tc>>td>>a>>h>>e;
	cin>>r;
	int luogu=(n*ta+r*tc)/(a/100.0)+h;//洛谷时间很好算
	int chuto=n*ta;
	for(int p=1,x,y,z;p<=r;p++)
	{
		cin>>x>>y>>z;
		num[M2[y]][M1[x]]++;
		if(e&&score[M2[y]][M1[x]]<z)//如果需要更新
			score[M2[y]][M1[x]]=z,chuto+=td;//更新并且更新时间
	}
	for(int p=1;p<=m;p++)
		for(int i=1;i<=n;i++)
			chuto+=min(num[p][i]*tb,ta+num[p][i]*tc);
	cout<<chuto<<endl<<luogu<<endl;
	if(luogu<chuto)cout<<"Use Luogu!"<<endl;
	else cout<<"Forget it..."<<endl;
}
```


------------
可是显然，使用 ```map``` 虽然很方便，但是有一点很麻烦，就是时间复杂度是 $\log_2$ 级别的，如果数据再大一点，铁定会 TLE 到飞起。  

辣么我们阔以用什么东东呢？hash~~戴着高光和 BGM~~走起！

hash 是哈希表，俗称散列，核心思路是一个哈希函数 $HASH$，定义为：  
$HASH(val)=val\mod M$，$M$ 为一个大质数。这个函数的值代表这个数在哈希表中的位置。

可是如果这样的话岂不会是有一些元素的哈希值产生重复？解决这个问题其实有很多办法，我喜欢用挂链法解决。挂链法就是将每个哈希值重复的值连到一个链表上，在每个链表里暴力查询/删除。  

正常做法是用链表，因为这题木有删除，所以我用 ```vector``` 进行的模拟。~~我才不会告诉你是因为我懒。~~

代码：
```cpp
#include<iostream>
#include<vector>
#define mod 1007//哈希模数，1007就够了
using namespace std;
int ta,tb,tc,td,a,h,e;
int score[1010][1010];
int num[1010][1010];
struct node{
	int x,y;
	node(int xx,int yy)
	{x=xx,y=yy;}
};
struct hash{//把哈希表用一个结构体封装，比较方便
	vector<node>value[mod+10];
	bool vis[mod+10];
	int HASH(int key)//哈希值函数
	{return key%mod;}
	int insert_a_val(int val,int id)//插入元素
	{
		int pos=HASH(val);
		value[pos].push_back(node(val,id));
	}
	int find_a_val(int val)//暴力查找
	{
		int pos=HASH(val);
		for(int p=0;p<value[pos].size();p++)
			if(value[pos][p].x==val)
				return value[pos][p].y; 
	}
};
int main()
{
	//下面的操作其实和map差不多
	hash M1,M2;
	int n,m,r;
	cin>>n>>m;
	for(int p=1,x;p<=n;p++)
		cin>>x,M1.insert_a_val(x,p);
	for(int p=1,x;p<=m;p++)
		cin>>x,M2.insert_a_val(x,p);
	cin>>ta>>tb>>tc>>td>>a>>h>>e;
	cin>>r;
	int luogu=(n*ta+r*tc)/(a/100.0)+h;
	int chuto=n*ta;
	for(int p=1,x,y,z;p<=r;p++)
	{
		cin>>x>>y>>z;
		num[M2.find_a_val(y)][M1.find_a_val(x)]++;
		if(e&&score[M2.find_a_val(y)][M1.find_a_val(x)]<z)
			score[M2.find_a_val(y)][M1.find_a_val(x)]=z,chuto+=td;
	}
	for(int p=1;p<=m;p++)
		for(int i=1;i<=n;i++)
			chuto+=min(num[p][i]*tb,ta+num[p][i]*tc);
	cout<<chuto<<endl<<luogu<<endl;
	if(luogu<chuto)cout<<"Use Luogu!"<<endl;
	else cout<<"Forget it..."<<endl;
}
```
在分布较均匀的情况下大概在 $O(1)$ 左右基本上能够进行查询了。  
比较一下两者的差距：  

| 方法 | 时间 |
| :----------: | :----------: |
| 哈希表 | 527 ms |
| map | 1250 ms |

哈希表的时间效率是 ```map``` 的 2 倍多，相比之下还是蛮优秀的。

---

## 作者：林家三少 (赞：5)

又一篇题解

我们的kkksc03大佬已经说了基本的解法

关于学号的问题可以用map（更方便一点）

所以...我也没什么可以讲的，直接上代码吧：

```cpp
#include<cstdio>
#include<map>  //这个文件头是一定要打的
#include<algorithm>
using namespace std;
map<int,int>p,s;  //用map了
int f[1000+5][1000+5];  //用来存储提交次数的 
int sc[1000+5][1000+5];  //存储每个人最高分 
long long minx(long long x,long long y)
{
    if(x<y)
        return x;
    else
    	return y;
}
int ta,tb,tc,td,a,h,e;
int n,m;
int r;
int main()
{
    scanf("%d%d",&n,&m);  //输入
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        p[x]=i;
    }
    for(int i=1;i<=m;i++)
    {
        int x;
        scanf("%d",&x);
        s[x]=i;
    }
    scanf("%d%d%d%d%d%d%d",&ta,&tb,&tc,&td,&a,&h,&e);  ////输入
    scanf("%d",&r);  //输入
    long long t1=n*ta;
    long long t2=n*ta;
    while(r--)  //进入循环
    {
        int pp,s1,s2;
        scanf("%d%d%d",&pp,&s1,&s2);  //输入
        pp=p[pp];
        s1=s[s1];  //map来
        f[pp][s1]++;
        if(e==1&&s2>sc[pp][s1])
        {
            sc[pp][s1]=s2;
            t1+=td;
        }
        t2+=tc;
    }
    for(int i=1;i<=n;i++)  //进入第一重循环
        for(int j=1;j<=m;j++)  //进入第二重循环
        {
            int sq=tb*f[i][j];
            int bsq=ta+tc*f[i][j];
            t1+=minx(sq,bsq);
        } 
    t2=(long long)t2/(a/100.0);
    t2+=h;
    printf("%lld\n%lld\n",t1,t2);  //最后输出
    if(t1<t2)  //根据条件判断
        printf("Forget it...\n");  //最后输出
    else
        printf("Use Luogu!\n");  //最后输出
    return 0;
}
```


---

## 作者：WOWHandsome (赞：5)

---
title: 洛谷 P1193 洛谷团队训练VS传统团队训练 解题报告
tags:
  - Map映射
  - STL
  - 离散化
categories:
  - 解题报告
layout: true
date: 2019-12-12 20:30:00
---

## 题面

请见 [Luogu P1193 洛谷团队训练VS传统团队训练](https://www.luogu.com.cn/problem/P1193)

## 思路

一看到 ~~像抽纸一样长的题面~~ 就知道是大模拟。

其实只需要攻克 **学号** 和 **题目编号** 两个数据的存储就可以了。可以用 $STL Map$ 映射大法，来进行数据的离散化，带上一个 $log$ 的时间复杂度也是可以接受的。

那么传统方式，究竟是去教师机评测还是自己测呢？比较两者的总时间取最优即可。

而洛谷的时间很好算，$O(1)$ 就可以完成。

$p.s.$ 由于此代码使用 C++ $STL map$ 完成，请大家 [**自学qwq**](https://blog.csdn.net/shuzfan/article/details/53115922) （此博客非原创，感谢原作者）。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, ta, tb, tc, td, A, H, E, R;
map <int, int> problem, student;
// problem[i] 和 student[i] 进行离散化 
int score[1005][1005], submit[1005][1005];
// score 存储得分，submit存储提交记录（已经离散化）

int main() {
	scanf("%d%d", &n, &m);
	int t; 
	for (int i = 1; i <= n; i++) {
		scanf("%d", &t);
		problem[t] = i;   // map映射problem_id，离散化 
	}
	for (int i = 1; i <= m; i++) {
		scanf("%d", &t);
		student[t] = i;   // map映射student_id，离散化
	}
	scanf("%d%d%d%d%d%d%d%d", &ta, &tb, &tc, &td, &A, &H, &E, &R);
	long long luoguTime = n*ta+R*tc, cenaTime = n*ta; //洛谷时间很容易得，以下全部在计算使用传统模式的时间
	for (int i = 1; i <= R; i++) {
		int pi, si, sc;
		scanf("%d%d%d", &pi, &si, &sc);
		si = student[si], pi = problem[pi], submit[pi][si]++; //使用map映射查询到离散化后的标号
		if (E && sc>score[pi][si]) score[pi][si] = sc, cenaTime += td;  //更新
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++) {
			cenaTime += min(tb * submit[i][j], ta + tc*submit[i][j]);   //比较去教师机测和自己机测的时间
		}
	luoguTime = (long long)luoguTime/(A/100.0) + H;   //罚时
	printf("%lld\n%lld\n%s\n", cenaTime, luoguTime, (cenaTime<luoguTime)?("Forget it..."):("Use Luogu!"));   //输出（三目运算压行）
	return 0;
} 
```

---


# 求和

## 题目描述

给定长为 $n$ 的整数序列 $a$。

您可以对这个序列进行若干次（可以为 $0$ 次）操作，每次操作形如：

选定满足 $1\le i,j\le n$ 的下标 $i$ 和 $j$，将 $a_i$ 赋值为 $a_i+1$，同时将 $a_j$ 赋值为 $a_j-1$。$i$ 和 $j$ 不能相同。

求使得前缀和之和等于后缀和之和的最小操作次数。

也就是说，令 $s_i=a_1+a_2+\dots+a_i,t_i=a_i+a_{i+1}+\dots+a_n$，有 $s_1+s_2+\dots+s_n=t_1+t_2+\dots+t_n$。

注意，$a_i$ 可以变为负数。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（30 pts）：$1 \le n \le 2$；
- Subtask 2（30 pts）：$a_i=i$；
- Subtask 3（5 pts）：$a_i=1$；
- Subtask 4（35 pts）：无特殊限制。

对于所有数据，保证 $1 \le n,a_i \le 10^6$。

## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
3```

## 样例 #2

### 输入

```
6
2 3 7 4 5 8```

### 输出

```
-1```

# 题解

## 作者：Sweet_2013 (赞：11)

题意：给定一个序列，可以进行若干次操作。每次操作选择两个不同的下标 $i$ 和 $j$，将 $a_i$ 加 $1$，$a_j$ 减 $1$，最后要让序列的前缀和之和等于后缀和之和，求最小的操作次数。如果无法实现，输出 $-1$。

假设前缀和之和为 $S$，后缀和之和为 $T$，题目就可以这么做：
- 求出序列的前缀和和后缀和。
- 每次选择 $i$ 和 $j$ 后并操作，这种操作不会改变序列的总和，因为 $+1$ 和 $-1$ 是可以互相抵消的。但会影响 $S$ 和 $T$ 的差值：在位置 $k$ 加 $1$ 对 $S-T$ 的影响是 $n-2k+1$，在位置 $k$ 减 $1$ 对 $S-T$ 的影响是 $−(n−2k+1)$。所以，每次操作总共对 $S-T$ 的影响就是两式相减，得到答案是 $2(j-i)$，最大可能的单次操作影响是 $2(n−1)$。
- 答案计算：
  - 如果 $S-T$ 为奇数，那么一定无解，因为每次操作改变 $S-T$ 的量为偶数，所以 $S-T$ 必须是偶数才能通过操作变为 $0$。
  - 否则，答案就是 $\lceil \frac{|S-T|}{2(n-1)} \rceil$，因为每次操作最多可以调整 $2(n−1)$ 的差值。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n, a[1000005];
long long s, t, p, s1;//p 是前缀和的累加器，s1 是后缀和的累加器，s 是前缀和之和，t 是后缀和之和。 
int main() {
    cin>> n;
    for(int i=0;i<n;i++) cin>> a[i];
    if(n==1) {
        cout<<0;
        return 0;
    }//特判，n 为 1，就说明 S 和 T 已经相同了，所以是操作 0 次。
    for(int i=0;i<n;i++) {
        p+=a[i];
        s+=p;
    }//计算前缀和。
    for(int i=n-1;i>=0;i--) {
        s1+=a[i];
        t+=s1;
    }//计算后缀和。
    if((s-t)%2!=0) cout<<-1;// S-T 为奇数，但每次操作变化的数为偶数，所以肯定无解。
    else cout<<(abs(s-t)+(2*n-2)-1)/(2*n-2);
    return 0;
}
```

---

## 作者：__CJY__ (赞：9)

## 思路
把题意转化一下，我们需要计算 $s_1+s_2+\cdots+s_n$ 和 $t_1+t_2+\cdots+t_n$ 的表达式。

首先计算前缀和的总和：
$$S=\sum_{k=1}^ns_k=\sum_{k=1}^n\sum_{i=1}^ka_i=\sum_{i=1}^na_i \cdot (n-i+1)$$
这是因为每个 $a_i$ 在 $s_i,s_{i+1},\cdots,s_n$ 中出现了 $(n-i+1)$ 次。

我们用同样的方法计算后缀和的总和：
$$T=\sum_{k=1}^nt_k=\sum_{k=1}^n\sum_{i=k}^na_i=\sum_{i=1}^na_i \cdot i$$
这是因为每个 $a_i$ 在 $t_1,t_2,\cdots,t_i$ 中出现了 $i$ 次。

因此，等式 $S=T$ 可表示为：
$$\begin{aligned}
\sum_{i=1}^na_i \cdot (n-i+1)&=\sum_{i=1}^na_i \cdot i\\
\sum_{i=1}^na_i \cdot (n-i+1)-\sum_{i=1}^na_i \cdot i&=0\\
\sum_{i=1}^na_i \cdot (n-i+1-i)&=0\\
\sum_{i=1}^na_i \cdot (n-2i+1)&=0
\end{aligned}
$$
记 $c_i=n-2i+1$，则条件为：
$$\sum_{i=1}^na_i \cdot c_i=0$$
我们设初始偏差为 $D$，计算初始的 $D=\sum\limits_{i=1}^na_i \cdot c_i$
我们每次可以选择 $i$ 和 $j$，$D$ 的变化为 $c_i-c_j=2(j-i)$。因此，每次操作可以调整 $D$ 的值为 $\pm2(j-i)$。为了最小化操作次数，应尽可能选择最大的 $|j-i|$，即 $i=1,j=n$，此时 $|\Delta|=2(n-1)$。

* 如果 $D$ 是奇数，显然无法通过偶数次调整得到 $0$，直接返回 $-1$。
* 如果 $D$ 是偶数，最小操作次数为 $\lceil\frac{|D|}{2(n-1)}\rceil$。
## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e6+5;
ll n,a[maxn],d;
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++) cin>>a[i];
	if(n==1){cout<<0;return 0;}
	for(ll i=1;i<=n;i++){
		ll c=n-i*2+1;
		d+=a[i]*c;
	}
	if(d%2) cout<<-1;
	else cout<<(abs(d)+2*(n-1)-1)/(2*(n-1));
}
```
注意：
* 要开 `long long`。
* 要特判 $n=1$ 的情况，因为如果这样的话 $n-1=0$，会导致除零错误，会 `RE`。
* 如果使用 `ceil` 向上取整的话会出现浮点误差，所以推荐使用代码中的写法进行向上取整。

---

## 作者：XingnoYi (赞：6)

### 思路详解：
我们考虑交换之后对前缀和之和与后缀和之和的影响。

考虑交换 $i,j$ 时，前缀和之和变化量：
$$(n-i+1)-(n-j+1) = j-i$$

交换后后缀和之和变化量：
$$i-j$$
上面两式做差有，前缀和之和相对后缀和之和变化量：
$$2\times(j-i)$$

**我们记 $d$ 表示前缀和之和与后缀和之和的差**（由于 $d$ 正负对操作没有实质影响，不妨考虑 $d\ge0$）。

观察到每次操作，我们发现，一定不会改变 $d$ 的奇偶性，最后状态为 $d=0$，是偶数，所以若 $d$ 为奇数，则一定不满足条件，无解，输出 `-1`。

接下来考虑有解的情况，由于 $j-i \in [1,n-1] \cap \mathbb{N^+}$，考虑贪心，每次减少操作都让 $d$ 尽量减少更多的值，直到不能减少为止，不妨从大到小枚举减少的量，持续操作直到无法减少，具体操作如下：
```cpp
int delta = abs(totpr-totbk);
for(int i = n-1;i >= 1;i--)
{
    int red = 2*i;
    ans += delta/red;
    delta %= red;
}
```
这个贪心的正确性很好证明，我们略去。

### 结论优化：
观察上述的思路，我们发现，当第一次操作结束后，即 `d %= 2*(n-1)` 后，$d$ 的剩余值一定为一个属于 $[0,2n-4]$ 的偶数，此时，我们一定可以取一种情况使得 $2\times(j-i) = d$，这种情况操作完后，一定结束操作了。

换句话说，第一次操作结束后，若 $d$ 仍有剩余，则一定可以通过一次操作使得 $d$ 归零。

最后，答案为：
$$\lceil \frac{d}{2\times(n-1)} \rceil$$

注意特判 $n$ 为 $1$ 的情况。

### AC 代码：
```cpp
#include <iostream>
#define big long long
using namespace std;
big n,a[1000006],sumpr[1000006],sumbk[1000006],totpr,totbk,ans;
int main()
{
    scanf("%lld",&n);
    for(big i = 1;i <= n;i++) scanf("%lld",a+i);
    for(big i = 1;i <= n;i++) totpr += (sumpr[i] = sumpr[i-1]+a[i]);
    for(big i = n;i >= 1;i--) totbk += (sumbk[i] = sumbk[i+1]+a[i]);
    if(totpr == totbk) return printf("0"),0;
    if(abs(totpr-totbk)&1) return printf("-1"),0; // 差为奇数，一定无解
    big delta = abs(totpr-totbk);
    for(big i = n-1;i >= 1;i--)
    {
        big red = 2*i;
        ans += delta/red;
        delta %= red;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Undead2008 (赞：5)

转化为 $\sum s-\sum t=0$，

在某个地方 $+1$ 对 $\sum s-\sum t$ 影响分别是 
$+(n-1),+(n-3),+(n-5)\dots,-(n-5),-(n-3),-(n-1)$。

同理，在某个地方 $-1$ 对 $\sum s-\sum t$ 影响分别是 
$-(n-1),-(n-3),-(n-5)\dots,+(n-5),+(n-3),+(n-1)$。

注意到上面序列所有元素奇偶性相同，所以在某个地方 $+1$ 某个地方 $-1$ 对答案的贡献取遍 $-(2n-2)\sim +(2n-2)$ 的所有非零偶数。

所以判断无解只需要看 $\sum s-\sum t$ 是否为偶数。

答案是 $\lceil \dfrac{|\sum s-\sum t|}{2n-2}\rceil$。注意特判 $n=1$。

---

## 作者：GeorgeDeng (赞：3)

终于对了！发篇题解庆祝一下。

题目表述非常清晰，不再分析了。

## Solution

先说结论：

> 如果修改了 $i,j$ 两个位置，那么前缀和之和与后缀和之和的差值会减少 $2(\left | i-j \right |)$。

现在，我们证明这个玩意。

不妨设 $i<j$。把 $a_i \larr a_i+1$ 之后，前缀和 $s$ 从 $i$ 开始往后都会加一，但是，我们还把 $a_j \larr a_j-1$，所以从 $j$ 开始往后都不会发生变化，这里对差值的影响是 $(j-i)$ 的。

我们再来看后缀和。把 $a_j \larr a_j-1$ 后，从 $j$ 往前的后缀和都会减一，但是，我们还把 $a_i \larr a_i+1$，所以从 $i$ 往前的后缀和都不会发生变化。这里对差值的影响也是 $(j-i)$ 的。

因为前缀和之和和后缀和之和会有一个大一个小的，所以我们可以把修改操作看成双向奔赴，所以，修改一次对差值的影响是 $2(j-i)$。这里我们设了 $i<j$，所以在实际操作的时候有可能 $j<i$，所以要在 $j-i$ 的外面套一层绝对值，也就是 $2(\left | i-j \right |)$。证毕。

我们现在证明了这个结论。每一次操作，我们可以贪心地减去最大区间，使得 $\left | i-j \right |$ 尽可能大。因为不管在哪里减都符合这个结论，所以我们可以设 $i=1$，只管 $j$ 就可以了。我们定义前缀和之和和后缀和之和的差为 $cha$。那么，每一次的 $j$ 都满足 $j=\min(cha\div 2+1,n)$ 这个公式，每次减的时候，计算会对答案的影响为 $(j-1)\times 2$，定义影响值为 $mi$。答案每次会加上 $cha\div mi$，而 $cha \larr cha\bmod mi$。

因为每次都是两倍两倍减的，所以，如果 $cha$ 是奇数，那么无解，输出 `-1`，否则，贪心计算即可。

注意特判 $n=1$ 的情况，输出 `0`。

## code

```cpp
#include <iostream>
#include <cstdio>
#define int long long
using namespace std;

int n;
int a[1000005];
int s[1000005];
int t[1000005];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	if(n==1) return !(cout<<0);//特判
	bool flag = true;//特殊性质
	int sum1 = 0,sum2 = 0;
	for(int i = 1;i<=n;i++){
		cin>>a[i];
		s[i] = s[i-1]+a[i];
		sum1+=s[i];//计算前缀和之和
		//cout<<s[i]<<' ';
		if(a[i]!=1) flag = false;
	}
	//cout<<endl;
	if(flag){//特殊性质
		cout<<0;
		return 0;
	}
	for(int i = n;i>=1;i--){
		t[i] = t[i+1]+a[i];
		//cout<<t[i]<<' ';
		sum2+=t[i];//计算后缀和之和
	}
	//cout<<endl;
	if(sum1==sum2) return !(cout<<0);//相等直接输出0
	int cha = max(sum1,sum2)-min(sum1,sum2);
	if(cha%2!=0) return !(cout<<-1);//如果是奇数，无解
	int l = 1,r = n;
	int ans = 0;
	while(cha){
		int cnt = 0;
		r = min(cha/2+1,n);
		int mi = (r-l)*2;
        if(mi==0) return !(cout<<-1);//保险
		/*while(cha>=mi){
			cnt++;
			cha-=mi;
			ans++;
		}*/
        ans+=cha/mi;//直接除，不用像上面一样循环去减，上面那种会TLE
        cha%=mi;
		//cout<<r<<' '<<cnt<<endl;
	}
	cout<<ans;//输出答案
	return 0;
}
```

---

## 作者：_xzhdsnh1364 (赞：3)

烦死了，这题考时因为把样例当作了标准，结果挂掉了，发个题解来解除我郁闷的心情。

# SOLUTION
这题是个很普通的题，你们推个公式就知道了，其实 $\sum s$ 和 $\sum t$ 可以转化为以下的式子：

$$
\sum s=n \cdot a_1 + (n-1) \cdot a_2 + \cdots + a_n \\
\sum t=n \cdot a_n + (n-1) \cdot a_{n-1} + \cdots + a_1
$$

这个时候，我们很容易发现，当我们对 $i$ 和 $j$ 这两个位置进行操作时，$\sum s$ 会加上 $j-i$，$\sum t$ 会加上 $i-j$，用乘法分配律推一下即可。

接下来，我们就需要不断变化，使这两个和差越来越小，直到变为 $0$，那我们为了更快地完成，我们一定是选择 $1$ 和 $n$ 变化，这样差值变动也就越快，那每次差值变化就是 $-(2n-2)$，自然而然的，我们就是用 $|\sum s-\sum t| \bmod (2n-2)$ 先进行一个判断，如果这个答案有余数，那这个肯定是无解，然后如果可以整除，就输出 $|\sum s-\sum t| \div (2n-2)$，否则还要加 $1$。

# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int n , a[N];
long long s , anss , t , anst;
signed main(){
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		s += a[i];
		anss += s;
	}
	for(int i = n;i;i--){
		t += a[i];
		anst += t;
	}
    if(n == 1){
        cout << 0;
        return 0;
    }
	if((abs(anss - anst) % (2 * n - 2)) % 2)cout << -1;
	else{
		if(abs(anss - anst) % (2 * n - 2))cout << abs(anss - anst) / (2 * n - 2) + 1;
		else cout << abs(anss - anst) / (2 * n - 2);
	}
	return 0;
}

---

## 作者：LoongPig (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P12605)

## 思路

令 $S=\sum\limits_{i=1}^ns_i$，$T=\sum\limits_{i=1}^nt_i$。

通过数学推导，我们可以发现：
$$S=\sum\limits_{i=1}^ns_i=\sum\limits_{i=1}^n(n-i+1)a_i\\T=\sum\limits_{i=1}^nt_i=\sum\limits_{i=1}^ni\times a_i$$

令它们差值为 $d$，易得：
$$\begin{aligned}
d&=\sum\limits_{i=1}^n(n-i+1)a_i-\sum\limits_{i=1}^ni\times a_i\\
&=\sum\limits_{i=1}^n(n-i+1)a_i-i\times a_i\\
&=\sum\limits_{i=1}^n(n-2i+1)a_i
\end{aligned}$$

要使 $S=T$，即需要 $d=0$。

每次操作过后：
$$\begin{aligned}
\triangle d&=1\times(n-2i+1)+(n-2j+1)\times(-1)\\
&=n-2i+1-(n-2j+1)\\
&=n-2i+1-n+2j-1\\
&=2(j-i)
\end{aligned}$$

因为每次更改对 $d$ 的影响都是 $2$ 的倍数，所以要使 $d=0$，$S$ 于 $T$ 的差值必须是 $2$ 的倍数。

所以当 $2\nmid d$ 时，无解。

由于每一次最大可以改变 $2(n-1)$，所以最小的操作次数就是：
$$\lceil\frac{d}{2(n-1)}\rceil$$

## 代码

[提交记录](https://www.luogu.com.cn/record/219229415)

实现代码时，记得开 long long，因为 $n\times a_i$ 最大可以达到 $10^6\times 10^6=10^{12}$，已经超过了 int 类型的范围。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
long long n,S,T,a[N],pre[N],suf[N];
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
        scanf("%lld",a+i);
        pre[i]=pre[i-1]+a[i];
    }
    for(int i=n;i>=1;i--) suf[i]=suf[i+1]+a[i];
    for(int i=1;i<=n;i++) S+=pre[i],T+=suf[i];
    if(n==1){
        printf("0\n");
        return 0;
    }
    int diff=abs(T-S);
    if(diff&1){//2 不整除 d 时
        printf("-1\n");
        return 0;
    }
    printf("%lld",(abs(S-T)+(2*n-2)-1)/(2*n-2));
    //上取整
    return 0;
}
```

---

## 作者：Liliangxi (赞：2)

# [P12605 求和](https://www.luogu.com.cn/problem/P12605)

## 题意

给定一个长度为 $n$ 的序列，设其前缀和为 $s_i$，后缀和为 $t_i$，设 $S=\sum_{i=1}^n s_i$，设 $T=\sum_{i=1}^n t_i$。

定义一次操作为选定两个下标 $i$ 和 $j$（$i$ 和 $j$ 的相对大小不定），对原序列 $a_i$ 和 $a_j$ 分别赋值为 $a_i+1$ 和 $a_j+1$，求最少多少次能使得 $S=T$，若无解，输出 $-1$。

数据范围：$1\le n,a_i\le 10^6$ 

## 分析题意

观察数据范围，肯定不能暴力做，考虑 $T$ 和 $S$ 的关系，推式子如下：

### 特例一

当 $n=5$ 的时候，如下：

$S=s_1+s_2+s_3+s_4+s_5=a_1\times 5+a_2\times 4+a_3\times 3+a_4\times 2+a_5\times 1$

$T=t_1+t_2+t_3+t_4+t_5=a_1\times 1+a_2\times 2+a_3\times 3+a_4\times 4+a_5\times 5$

考虑当 $S=T$ 时，如下：

$a_1\times 5+a_2\times 4+a_3\times 3+a_4\times 2+a_5\times 1=a_1\times 1+a_2\times 2+a_3\times 3+a_4\times 4+a_5\times 5$

化简

$a_1\times 4+a_2\times 2=a_4\times 2+a_5\times 4$

代入样例

$1\times 4+2\times 2=4\times 2+5\times 4$

$0=20$（等号是要满足的）

我们可以容易的发现，此时一定是对于 $a_4$ 和 $a_5$ 进行减 $1$ 的操作，对于 $a_1$ 和 $a_2$ 进行加 $1$ 的操作，手模一下就可以得到最少进行 $3$ 次操作就可以使得 $S=T$。

### 特例二

当 $n=6$ 的时候，如下：

$S=s_1+s_2+s_3+s_4+s_5+s_6=a_1\times 6+a_2\times 5+a_3\times 4+a_4\times 3+a_5\times 2+a_6\times 1$

$T=t_1+t_2+t_3+t_4+t_5+t_6=a_1\times 1+a_2\times 2+a_3\times 3+a_4\times 4+a_5\times 5+a_6\times 6$

同上：

$a_1\times 6+a_2\times 5+a_3\times 4+a_4\times 3+a_5\times 2+a_6\times 1=a_1\times 1+a_2\times 2+a_3\times 3+a_4\times 4+a_5\times 5+a_6\times 6$

$a_1\times 5+a_2\times 3+a_3\times 1=a_4\times 1+a_5\times 3+a_6\times 5$

代入样例：

$0=33$

同上，可以手摸发现无法实现，输出 $-1$。

## 思路

总结上面（可以自己多次手摸）

1. 当 $n$ 是奇数时，要使得 $S=T$，必须使得形如 $a_1\times 4+a_2\times 2=a_4\times 2+a_5\times 4$ 满足条件。
2. 当 $n$ 是偶数时，要使得 $S=T$，必须使得形如 $a_1\times 5+a_2\times 3+a_3\times 1=a_4\times 1+a_5\times 3+a_6\times 5$ 满足条件。

作者问：为什么不写成公式，而是采用一组样例

作者答：因为公式反而不易于思路，这样更加~~方便~~形象。

我们发现，当选取一组进行操作的时候，一定会使得 $S$ 和 $T$ 的绝对差值改变 $2$ 的倍数。

所以得出结论：若 $S$ 和 $T$ 的绝对差值为奇数，无解；否则可以通过调节 $2$ 的倍数使得序列满足条件。

## 如何使得有解的情况最优

设 $S$ 和 $T$ 的绝对差值为 $d$。

观察一下。

发现对于 $n$ 为偶数，一次性可以改变 $2,4,6...(n-1)\times 2$（组合搭配，容易得到），此时若 $d$ 大于 $(n-1)\times 2$，不断减去即可，当 $d$ 小于 $(n-1)\times 2$，直接全部减去，因为此时的序列操作一定可以进行这种操作（$d$ 肯定是偶数，因为发现如样例一中的系数全是偶数）

发现对于 $n$ 为奇数，一次性可以改变 $2,4,6...(n-1)\times 2$（组合搭配，容易得到），此时若 $d$ 大于 $(n-1)\times 2$，不断减去即可，当 $d$ 小于 $(n-1)\times 2$，直接全部减去，因为此时的序列操作可能可以进行这种操作（$d$ 有可能是奇数，因为发现如样例二中的系数全是奇数）。

此时发现奇数偶数的处理没有多少差别，只需特判 $d$ 的奇偶性即可。

## Code

需要注意，由于 $d$ 可能特别大，不能模拟，直接使用整除加以判断即可，还有注意开长整型。


```cpp
#include <bits/stdc++.h>
#define int long long
#define lll unsigned long long
#define dou double
#define INF 2147483647
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
using namespace std;

constexpr int N=1000011;

int n,S,T,d,ans;
int a[N];


signed main()
{
    IOS;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        S=S+a[i]*(n-i+1);
        T=T+a[i]*i;
    }
    if(S==T)
    {
        cout<<0<<endl;
        return 0;
    }
    d=abs(T-S);
    if(d&1)
    {
        cout<<-1<<endl;
        return 0;
    }
    ans=d/(2*(n-1));
    if(d%(2*(n-1))) ans++;    //判断是否可以完整进行操作
    cout<<ans<<endl;
    return 0;
}
/*

*/
```

---

## 作者：zhongxicheng (赞：2)

### 思路

直接数学推导，设 $S_1$ 表示前缀和之和，$S_2$ 表示后缀和之和，$S$ 表示 $\sum a_i$。不难发现 $S$ 是定值。

那么 $a_i$ 对 $S_2$ 的贡献就是 $i\times a_i$，因为这个数被计算了 $i$ 次。

同理 $a_i$ 对 $S_1$ 的贡献是 $(n+1-i)\times a_i$。

数学推导：
$$ \begin{aligned} S_1-S_2 &= 
(\sum_{i=1}^n (n+1-i)\times a_i)-(\sum_{i=1}^n i\times a_i) \\
&= \sum_{i=1}^n (n+1-2\times i)\times a_i \\&= (n+1)\times S-2\times\sum_{i=1}^n i\times a_i
\end{aligned} $$
所以 $S_1=S_2$ 的充要条件是：
$$ S_2=\sum_{i=1}^n i\times a_i=\frac{S\times (n+1)}{2} $$
观察到上式右侧是定值，所以若 $S\times (n+1)$ 是奇数，显然无解。

否则一次操作对 $S_2$ 的影响 $\Delta S_2=i-j$ 可取遍 $[-(n-1),n-1]$ 中的整数，即每次 $|\Delta S_2|\le n-1$，那么答案就是：
$$ \lceil |S_2-\frac{S\times (n+1)}{2}|\div (n-1)\rceil $$

[AC记录](https://www.luogu.com.cn/record/218904855)

---

## 作者：_0_px (赞：2)

[link](https://www.luogu.com.cn/problem/P12605)

考试考了这道题，写一篇题解作纪念。

### 思路

令 $q = \footnotesize\text{前缀和之和}$，$h = \footnotesize\text{后缀和之和}$。

前缀和之和：

$$
\begin{aligned}
q &= \sum_{i=1}^n s_i \\
  &= \sum_{i=1}^n \sum_{j=1}^i a_i \\
  &= \sum_{i=1}^n(n - i + 1)\times a_i
\end{aligned}
$$

同理可得后缀和之和：

$$
\begin{aligned}
h &= \sum_{i=1}^n t_i \\
  &= \sum_{i=1}^n \sum_{j=i}^n a_i \\
 &= \sum_{i=1}^n i \times a_i
\end{aligned}
$$

其实就相当于每个点都有一个权值，前缀和之和中第 $i$ 个点的权值为 $n - i + 1$，后缀和之和中第 $i$ 个点的权值为 $i$。

当选择 $i$ 和 $j$ 操作时，将 $a_i$ 加上一，将 $a_j$ 减去一，对前缀和之和的贡献为第 $i$ 个点的前缀和之和权值 $-$ 第 $j$ 个点的前缀和之和权值，即 $(n - i + 1) - (n - j + 1) = j - i$，同理可得对后缀和之和的贡献为 $i - j$，则对前缀和之和和后缀和之和的差的贡献为 $2|i - j|$。

那么可以先把前缀和之和和后缀和之和计算出来，求出他们的差（必须是偶数，因为每次操作贡献都是偶数，如果差是奇数就不可能完成，答案为 $-1$），每次最多能产生的贡献为 $2(n - 1)$，则答案就是 $\lceil\dfrac{|q - h|}{2(n - 1)}\rceil$。

注意，当 $n = 1$ 时，要特判（不能除以 0），答案为 0。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int NR = 1e6 + 10;
int n, a[NR], q, h;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    if (n == 1){// 特判。
        cout << 0;
        return 0;
    }
    for (int i = 1; i <= n; ++ i){
        cin >> a[i];
        q += (n - i + 1) * a[i];// 前缀和之和。
        h += i * a[i];// 后缀和之和。
    }
    if (abs(q - h) % 2){// 差为奇数，答案 -1。
        cout << -1;
        return 0;
    }
    int x = abs(q - h), y = 2 * (n - 1);// x：|q - h| y：每次最大贡献。
    cout << (x + y - 1) / y;// x 除以 y 向上取整。
    return 0;
}
```

---

## 作者：tuntunQwQ (赞：1)

将 $s_1+s_2+\dots+s_n$ 展开得到 $n\times a_1+(n-1)\times a_2+\dots+a_n$，将 $t_1+t_2+\dots+t_n$ 展开得到 $a_1+2\times a_2+\dots+n\times a_n$。每次我们操作时就相当于使前缀和之和加上 $n-i+1$ 再减去 $n-j+1$，即加上 $j-i$；使后缀和之和加上 $i$ 再减去 $j$，即减去 $j-i$。由此一来，前缀和与后缀和的差值变化量就为 $2\times(j-i)$。

因为我们要使前缀和与后缀和的差值为 $0$ 而且尽能操作次数可少，所以每次操作可以令 $i$ 和 $j$ 一个为 $1$，一个为 $n$，使每次前缀和与后缀和的差值变化量尽可能大。答案就是最开始前缀和与后缀和的差值除以 $2\times(n-1)$ 的值，注意要向上取整，因为若当前差值小于 $2\times(n-1)$，我们还需要额外进行一次操作使得前缀和与后缀和的差值为 $0$。

注意这里 $2\times(n-1)$ 做了除数，而当 $n=1$ 时除数为 $0$，需要特判 $n=1$ 的情况。

什么样的情况会无解呢？如果最开始前缀和与后缀和的差值为奇数，因为无论 $i,j$ 取何值差值变化量均为偶数，所以前缀和与后缀和的差值不可能变为 $0$，这种情况需要输出 $-1$。

代码如下，可供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
long long n,a[N],sum1[N],sum2[N],sum3,sum4;
int main(){
    cin>>n;
    if(n==1)return cout<<0,0;
    for(int i=1;i<=n;i++)cin>>a[i],sum1[i]=sum1[i-1]+a[i],sum3+=sum1[i];
    for(int i=n;i>=1;i--)sum2[i]=sum2[i+1]+a[i],sum4+=sum2[i];
    if(sum3-sum4&1)return cout<<-1,0;
    else cout<<fixed<<setprecision(0)<<ceil(1.0*abs(sum3-sum4)/(2*n-2));
    return 0;
}
```

---

## 作者：Vct14 (赞：1)

首先特判 $n=1$，$s_1=t_1=a_1$，不用操作，答案为 $0$。

将 $a_i$ 加一，会使 $s_i,s_{i+1},\cdots, s_n$ 加一，$t_1,t_2,\cdots,t_i$ 加一，因此 $\sum\limits_{i=1}^n s_i-\sum\limits_{i=1}^n t_i$ 会加上 $n-i+1-i=n-2i-1$。

同理，将 $a_j$ 减一，$\sum\limits_{i=1}^n s_i-\sum\limits_{i=1}^n t_i$ 会减去 $n-2j-1$。

因此每次操作会使 $\sum\limits_{i=1}^n s_i-\sum\limits_{i=1}^n t_i$ 加上 $(n-2i-1)-(n-2j-1)=2j-2i$。我们的目标是将 $\sum\limits_{i=1}^n s_i-\sum\limits_{i=1}^n t_i$ 变为 $0$。

因此最开始 $\sum\limits_{i=1}^n s_i-\sum\limits_{i=1}^n t_i$ 为奇数无解，否则我们每次最多将其绝对值减去 $2(n-1)$。答案即为 $\left\lceil\dfrac{|\sum\limits_{i=1}^n s_i-\sum\limits_{i=1}^n t_i|}{2(n-1)}\right\rceil$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e6+2;
int a[N];

signed main(){
	int n;cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i];
    if(n==1){
        cout<<0;
        return 0;
    }
	int s=0,t=0,ss=0,st=0;;
	for(int i=1; i<=n; i++){
		s+=a[i];ss+=s;
		t+=a[n-i+1];st+=t;
	}
    if(abs(ss-st)%2) cout<<"-1";
    else{
        int q=abs(ss-st)/2;int ans=q/(n-1);
        if(q%(n-1)) ans++;
        cout<<ans;
    }
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

没有参加洛谷月赛，赛后赶紧看了看题目，发个题解留个念。

首先，我们可以注意到他的前缀和之和 $s$ 等于：

$$
a_1 + a_1 + a_2 + a_1 + a_2 + a_3 + \dots a_n = a_1 \times n + a_2 \times (n-1) \dots + a_n \times 1
$$

用高级一点的方法来表示就是：

$$
s = \sum_{i=1}^{n} a_i \times (n - i + 1)
$$

同理，他的后缀和之和 $t$ 等于：

$$
a_n + a_n + a_{n-1} + a_n + a_{n-1} + a_{n-1} \dots + a_1 = a_n \times n + a_{n-1} \times n - 1 \times a_1 \times 1
$$

为了美观，我们同样用高级的方法来表示：

$$
t = \sum_{i=1}^{n} a_i \times i
$$

我们的目标是让 $s - t = 0$，但是现在：

$$
s - t = \sum_{i=1}^{n} a_i \times (n - 2 \times i + 1)
$$

为了方便起见，我们称 $s - t$ 为 $d$。如果我们让 $a_i$ 的值加上 $1$，让 $a_j$ 的值减去 $1$。那么 $d$ 的值会变成：

$$
d + n - 2 \times i + 1 - n + 2 \times j - 1
$$

化简得 $d$ 的值会增加 $2 \times (j - i)$。所以无解的情况就出来了：如果一开始 $d$ 的值为奇数，那么无解。因为每次 $d$ 的值都只能加上或减去一个偶数。

**有解的情况**

为了让 $d$ 赶快变成 $0$，$2 \times (j - i)$ 要越小越好。所以最完美的情况就是 $j = 1$，$i = n$，每次可以减去 $2 \times (n-1)$。当然，$d$ 可能不是 $2 \times (n-1)$ 的倍数，我们设剩下的余数为 $num$。那么我们只需要在让 $a_{1+num}$ 的值加 $1$，$a_1$ 的值减 $1$ 就行了。

综上所述，如果有解，最终答案为 $\lceil \frac{d}{2 \times (n-1)} \rceil$。

作者不太会表达，可能有些地方表达的不清楚。更多细节可以看程序。

# 标准的错误程序
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
long long n,a[N],d;//开long long
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		d+=a[i]*(n-2*i+1);//计算d
	}
	if(d<0)
	d=-d;//s<t
	if(d%2==1)
	printf("-1");//无解
	else
	printf("%lld",(d+2*n-3)/(2*(n-1)));//ceil也可以这么表达
	return 0;
}
```

没错，上面的程序错了一个数据，为啥呢？因为 $n$ 可能是 $1$，此时就会出现除以 $0$ 的情况。所以需要在 $n = 1$ 的时候进行特判。

# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
long long n,a[N],d;//开long long
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		d+=a[i]*(n-2*i+1);//计算d
	}
	if(n==1)
	{
		printf("0");//特判
		return 0;
	}
	if(d<0)
	d=-d;//s<t
	if(d%2==1)
	printf("-1");//无解
	else
	printf("%lld",(d+2*n-3)/(2*(n-1)));//ceil也可以这么表达
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：0)

题目传送门：[P12605 求和](https://www.luogu.com.cn/problem/P12605)

### 题目分析

在后缀和之和中，$a_i$ 出现了 $i$ 次；

在前缀和之和中，$a_i$ 出现了 $n-i+1$ 次。

题目所给的“前缀和之和等于后缀和之和”可以转化：

$$
\begin{aligned}
\sum\limits_{i=1}^{n} a_i \cdot i &= \sum\limits_{i=1}^{n} a_i \cdot (n-i+1) \\
\sum\limits_{i=1}^{n} a_i \cdot i &=  n \cdot \sum\limits_{i=1}^{n} a_i - \sum\limits_{i=1}^{n} a_i \cdot i +\sum\limits_{i=1}^{n} a_i \\
2 \cdot \sum\limits_{i=1}^{n} a_i \cdot i &= (n+1) \cdot \sum\limits_{i=1}^{n} a_i
\end{aligned}
$$

我们记等式右边为 $sum$，如果 $sum$ 是奇数则无解。

如果有解呢？

$sum \leftarrow \dfrac{sum}{2}$，然后看它与 $\sum\limits_{i=1}^{n} a_i \cdot i$（记为 $s$）的差距。

注意到如果操作 $a_1$ 和 $a_n$，则一次操作对于 $s$ 的改变可以贡献 $n-1$，而这是贡献最大的情况。因此先令 $ans=\dfrac{|sum|}{n-1}$，然后若 $|sum| \bmod (n-1) > 0$，再进行一次操作使之相等。可以证明对于任意 $-(n-1) \leqslant d \leqslant n-1$，一定能找到合适的操作恰好贡献 $d$。

> $d = i-j$。

### 代码实现

编写代码时要注意两个坑点：

- $sum$ 对 $s$ 作差后要先判断一次是否为 $0$，防止后面遇到 $n=1$ 时 RE。

- 开 long long。因为虽然 $a_i$ 没超，但是计算 $s$ 时 $a_i \cdot i$ 会炸！！！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1000006;
int n,a[N];
long long s,sum,ans; 
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
    	sum+=a[i];
    	s+=a[i]*i;
	}
	sum*=n+1;
	if(sum&1){
		cout<<-1;
		return 0;
	}
    sum>>=1;
	sum-=s;
    if(!sum){
        cout<<0;
        return 0;
    }
    if(sum<0)sum=-sum;
    ans=sum/(n-1);
    sum%=n-1;
    if(sum)ans++;
	cout<<ans;
    return 0;
}
```

---

## 作者：Tighnarri (赞：0)

## 前言
读错题导致浪费 2h，纪念一下。
## 正文
题目让求最小操作次数使得 $\sum_{i=1}^{n}s_i=\sum_{i=1}^{n}t_i$。

其中 $s_i$ 表示 $\sum_{j=1}^{i}a_j$，$t_i$ 表示 $\sum_{j=i}^{n}a_j$。

这个 $\sum_{i=1}^{n} s_i$ 难以描述，我们考虑写成 $\sum_{i=1}^{n}(n-i+1)\times a_i$。

进而将后缀和也这么写一下，最后将题目转化成最小操作次数使 $\sum_{i=1}^{n}(n+1-2\times i)\times a_i=0$。 

根据上面的这个式子：$\sum_{i=1}^{n}(n-i+1)\times a_i$。可以得出每次选 $i,j$ 的操作，会使得这个和减少 $2\times |i-j|$，考虑选取最大的 $i,j$ 就是 $i=1,j=n$。

所以我们一次操作就能减去 $2\times (n-1)$ 的差值。

最后得出的答案就是：
$$⌈\frac{|\sum_{i=1}^{n}(n+1-2\times i)\times a_i|}{2\times n-2}⌉$$

code：
```cpp
#include <iostream>
#include <cmath>
#define ll long long
using namespace std;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
	int n;
	cin >> n;
    if (n == 1) {
		cout << 0;
		return 0;
	}
	ll sum = 0;
	for (int i = 1; i <= n; ++i) {
		int a;
		cin >> a;
		sum += 1ll*(n+1-2*i)*a;
	}
	if (sum == 0) {
		cout << 0;
		return 0;
	}
	if (sum% 2 != 0) {
		cout << -1;
		return 0;
	}
	ll tmp2 = abs(sum);
	cout << 1ll*tmp2 / (1ll*2*(n-1))+(tmp2 % (2*(n-1))>0?1:0);
	return 0;
}
```
## 后话
如有错误或者笔误，请指出并 @ 我修改。

恭喜 S2OI Round 1 举办成功！

---


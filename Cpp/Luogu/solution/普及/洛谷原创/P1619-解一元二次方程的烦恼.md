# 解一元二次方程的烦恼

## 题目背景

JosephZheng 在写数学作业的预习。他往往使用 Casio 来帮忙解一元二次方程。但是 Casio 有一个问题，就是当 $\Delta=b^2-4ac$ 为一个大素数或大合数时，其开平方的结果会以小数显示，而不是老师要求的二次根式形式。JosephZheng 很是苦恼，一遇到这种情况就要手动解方程。一天他再也忍不住了，于是打开了电脑，编了一个 prime 程序……于是悲剧的 OIer 们就要跟着疯狂的 JosephZheng 一起编这个程序，呵呵……


## 题目描述

废话少说，给你一个大数 $N$（不一定在 int64 范围内），让你进行素性判断，然后分解质因数。当然，初中数学题不可能有大于 int64 的数让你判断素性，因此超过范围的数可以忽略不计。为了让程序更加贴心，JosephZheng 多了一些要求，会在输入输出中给出具体情况。


## 说明/提示

编这道题的 JosephZheng 有些无聊，但是很考验基本功哦！仔细审题！

水题一道。。。


## 样例 #1

### 输入

```
4
eed
```

### 输出

```
Enter the number=
Prime? No!
4=2^2

Enter the number=
```

## 样例 #2

### 输入

```
2
end
```

### 输出

```
Enter the number=
Prime? Yes!

Enter the number=
```

## 样例 #3

### 输入

```
-1
adfs
```

### 输出

```
Enter the number=
Prime? No!

Enter the number=
```

## 样例 #4

### 输入

```
1234###24#@13#@￥！1
hehe
```

### 输出

```
Enter the number=
Prime? No!
The number is too large!

Enter the number=
```

## 样例 #5

### 输入

```
1.5
1
1234324123512343123
@~@~@~@
```

### 输出

```
Enter the number=
Prime? No!
15=3^1*5^1

Enter the number=
Prime? No!

Enter the number=
Prime? No!
The number is too large!

Enter the number=
```

## 样例 #6

### 输入

```
12
halt@@
```

### 输出

```
Enter the number=
Prime? No!
12=2^2*3^1

Enter the number=
```

# 题解

## 作者：_neddy (赞：20)

~~这题其实挺简单的。前后才交了六次而已。~~

方法很简单。

但在解决问题之前，先分析一下时间复杂度：

1. 判断素数最坏情况是$O(sqrt(n))$的

2. 提取数字是$O(1)$的

3. 分解质因数是$O(sqrt(n))$的

这样算下来，设有$Q$次询问，则时间复杂度为$O(Q sqrt(n))$，不算是个很优秀的复杂度。如果数据加强至

$Q<=100000, n <=40000000$

则现有的所有解法都会GG，此时则需运用到各种筛法并保存质因数，可惜作者太蒻了只会口胡。

回到正题，来解决这道数据水到爆炸的题目：

读题，易知判断素数和质因数分解为题目的主要考点（~~废话~~

那么，我们需要写个判断素数的函数，和分解质因数的函数。题目说输入中有干扰字符，且大于四千万的数都过滤掉，这时可用$string$读入，再提取数字。

提取数字的部分很简单（~~其实这整道题都很简单~~

```cpp
inline int str_to_int64(string ss)
{
    int num = 0, flag = 0;
    for (register int i = 0; i < ss.size() && num <= 40000000; ++i) //大于40000000的数过滤掉
        if (ss[i] >= '0' && ss[i] <= '9') num = num * 10 + (ss[i] - '0'), flag = 1;
    if (flag == 0) exit(0); //串中没有一个数字，halt
    return num;
}
```

坑点主要在于素数判断之后的输出以及质因数分解。即使你在$isprime$中写

```cpp
if (n < 2) return 0;
```
判断时输入一个0还是会崩，然而我没有注意到时却过了，再次说明数据之水。

所以，应该在判断和分解的部分中再加入判断：

```cpp
inline void act(int n){
    int num = 0, sum = 0, flag = 0, Isprime = isprime(n); //提前保存好值，避免重复计算
    n <= 40000000 && Isprime ? cout << "Prime? Yes!\n\n" : cout << "Prime? No!\n"; //如果满足既小于等于40000000又是素数则输出Yes，否则输出No
    if (Isprime || n < 2 || n > 40000000) {
        if (n > 40000000) cout << "The number is too large!\n\n"; //数字过大
        if (n < 2) cout << '\n'; //数字过小
    	return ;
    }
    cout << n << '='; //质因数分解
    for (register int i = 2; i * i <= n; ++i){
        while(n % i == 0) n /= i, ++sum;
        if (sum)
            if (flag) cout << '*' << i << '^' << sum, sum = 0; //不是第一个，输出乘号
            else cout << i << '^' << sum, flag = true, sum = 0; //是第一个，不输出
    }
    Isprime ? cout << '*' << n << "^1\n\n" : cout << "\n\n"; //如果分解之后的剩下的数是一个素数则加进去，否则开始下一次
}
```

差不多就这样了吧。完整代码如下：

```cpp
#include <bits/stdc++.h> //注释如上，不再添加重复部分

using namespace std;

inline bool isprime(int n){
    for (register int i = 2; i * i <= n; ++i) if (n % i == 0) return 0;
    return !(n < 2); //这不是一个好的写法，但因为数据水就算了
}

inline void act(int n){
    int num = 0, sum = 0, flag = 0, Isprime = isprime(n);
    n <= 40000000 && Isprime ? cout << "Prime? Yes!\n\n" : cout << "Prime? No!\n";
    if (Isprime || n < 2 || n > 40000000) {
        if (n > 40000000) cout << "The number is too large!\n\n";
        if (n < 2) cout << '\n';
    	return ;
    }
    cout << n << '=';
    for (register int i = 2; i * i <= n; ++i){
        while(n % i == 0) n /= i, ++sum;
        if (sum)
            if (flag) cout << '*' << i << '^' << sum, sum = 0;
            else cout << i << '^' << sum, flag = true, sum = 0;
    }
    Isprime ? cout << '*' << n << "^1\n\n" : cout << "\n\n";
}

inline int str_to_int64(string ss)
{
    int num = 0, flag = 0;
    for (register int i = 0; i < ss.size() && num <= 40000000; ++i)
        if (ss[i] >= '0' && ss[i] <= '9') num = num * 10 + (ss[i] - '0'), flag = 1;
    if (flag == 0) exit(0);
    return num;
}

int main(){
    string s;
    while(cout << "Enter the number=\n"){ //程序没有终止，持续输出提示
        getline(cin, s); //行末有空格，要用getline
        act(str_to_int64(s)); //开始新一轮
    }
}
```

这篇题解改了两次，每一次重写我都能发现新的Bug，也正说明了我的能力仍然十分有限。现在的这一篇中，功能基本齐全，且代码较为精简。蒟蒻也不懂什么面向对象，只能用常规方法解决。也欢迎看到题解的$dalao$前来hack，蒟蒻感激不尽。

总而言之，要解决这道题需要注意以下几点：

1. **如果大于四千万就直接输出不是素数和超范围提示**

2. 如果小于四千万，则判断是否素数，如果是就进行下一轮，否则**进行分解**

3. **如果输入的字符串里没有一个数字，则强制退出**

4. **每完成一个数的计算与判断都要额外地空一行！！**

最后，祝大家早日$AC$！

---

## 作者：0nullptr (赞：8)

传送门：[P1619](https://www.luogu.org/problem/P1619)

这道题题面比较长，但是作为一道模拟题还是又短又简单的~~你看看隔壁猪国杀蚂蚁~~。它的处理过程大致分为以下几步：
```
1.输入字符串，提取数字
2.质性判断
3.大小判断
4.分解质因数
5.返回第一步
```
明确了模拟过程后，我们开始逐一分析每步应该做的事情。

**过程一：输入字符串，提取数字。**
提取数字其实并不是什么难事，只需要将快速读入的代码改造一下就可以在这里使用~~不会快速读入？请左转百度~~。需要注意的是，平常的快速读入是逐字符进行读入，但在这里由于行内存在空格，建议直接读入一整行。具体细节见下代码。
```cpp
puts("Enter the number=");//题目中虽然说要先读入在换行，但是实测这里直接puts没有任何问题，应该是洛谷评测的一个feature。
n = 0;//用来存储输入的数字
string a;
getline(cin, a);
//这里不建议使用字符数组，因为scanf遇到空格会停止，而且gets已经spfa了（雾）
for (int i = 0; i < a.size(); i++){//遍历字符串
    if (a[i] >= '0' && a[i] <= '9'){//如果这一位是数字，就存起来
        n *= 10;
        n += a[i] - '0';
    }
}
```
**过程二：质性判断**

这里直接对$n$的质性进行判断即可。不会判断质数请右转[P3383线性筛素数](https://www.luogu.org/problem/P3383)
```cpp
bool judge(int n){
	int m = (int) sqrt(n + 0.5);//循环上界
	for (int i = 2; i <= m; i++)
	    if (n % i == 0) return false;
	return true;
}//正常的判断函数
```
**过程三：判断大小**

这一过程可以拆成两部分完成。第一部分判断是否小于二放在质性判断之前（由于数据保证数字$n$为正数，所以$n < 2 \Leftrightarrow n$不是质数）。第二部分判断是否大于四千万放在质性判断之后。注意输出格式即可。

**过程四：分解质因数**

这里是整个代码中最长的一段，主要是为了处理它的输出。显然，输出时第一个质因数和其余质因数有不同，即其前面没有*号。因此，在输出时需要对第一个质因数进行特判。
```cpp
cout<<n<<'=';
bool first = true;//用于判断当前数是否为质数
for (int i = 2; i <= n; i++){
    int k = 0;
    while (n % i == 0){
        k++;
        n /= i;
    }//对n进行质因数分解
    if (k){//如果i是n的质因数
        if (first){
            cout<<i<<'^'<<k;//第一个质因数前没有*号
            first = false;
        }
        else cout<<'*'<<i<<'^'<<k;
    }
}
cout<<endl;//注意此处应该有换行
```
**过程五：返回第一步**

这里有多种方法返回。在这里我采用在整个主函数中套一个大大的```while(ture)```并在检查到不合法数据时及时```return 0;```来结束主函数的方法。

处理完这一步，这道模(du)拟(liu)就被我们解决了。最后惯例放上完整代码。
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#define int long long
using namespace std;

bool judge(int n){
    int m = (int) sqrt(n + 0.5);
    for (int i = 2; i <= m; i++)
        if (n % i == 0) return false;
    return true;
}

signed main(){
    int n;
    while (true){
        puts("Enter the number=");
        n = 0;
        string a;
        getline(cin, a);
        for (int i = 0; i < a.size(); i++){
            if(a[i] >= '0' && a[i] <= '9'){
            n *= 10;
            n += a[i] - '0';
            }
        }
        if (n == 0) return 0;
        cout<<"Prime? ";
        if (n < 2) puts("No!");
        else if ( !judge(n) ){
            puts("No!");
            if (n > 40000000){
                puts("The number is too large!\n");
                continue;
            }
            cout<<n<<'=';
            bool first = true;
            for (int i = 2; i <= n; i++){
                int k = 0;
                while ( !(n % i) ){
                    k++;
                    n /= i;
                }
                if (k){
                    if (first){
                        cout<<i<<'^'<<k;
                        first = false;
                    }
                    else cout<<'*'<<i<<'^'<<k;
                }
            }
            cout<<endl;
        }
        else puts("Yes!");
        cout<<endl;
    }
}
```


---

## 作者：方俊懿 (赞：5)

### 题目：

[P1619 解一元二次方程的烦恼](https://www.luogu.com.cn/problem/P1619)

这道题是蓝题的原因就在它的输出上。

---
### 分析：
|步骤|实现|备注|
|-|-|-|
|初始化质数列表|`init();`|线性筛素数
|边读边输出|`read()`|读数用快读的方法，输出详见代码。
|读不到数，结束|`return 0;`|无

这个方法的时间复杂度是（对于每一个数）$\operatorname{O}(\sqrt x)$。

---
### 代码&注释：
```cpp
#include <cstdio>
bool book[40000010];
int p[10000010],coun=0;
void init()//线性筛素数
{
	book[1]=1;
	for(int i=2;i<=40000000;i++)
	{
		if(book[i]==0)
			p[coun++]=i;
		for(int j=0;p[j]*i<=40000000 && j<coun;j++)
		{
			book[i*p[j]]=1;
			if(i%p[j]==0)
				break;
		}
	}
}
bool read()
{
	long long re=0,t;
	bool flag=0;
	char ch=getchar();
   //读数，类似快读。
	while(ch!='\n' && ch!=EOF)
	{
		if(ch>='0' && ch<='9')
		{
			re=re*10+(ch-'0');
			flag=1;
		}
		ch=getchar();
	}
	if(!flag)//没读到，结束程序。
		return 0;
	if(re<0)//小于0，忽略。
		return 1;
	printf("\nPrime? ");
   //小于2或大于40000000，给出提示并忽略。
	if(re<2)
	{
		printf("No!\n\nEnter the number=");
		return 1;
	}
	if(re>40000000)
	{
		printf("No!\nThe number is too large!\n\nEnter the number=");
		return 1；
	}
   //是质数，给出提示并返回。
	if(book[re]==0)
	{
		printf("Yes!\n\nEnter the number=");
		return 1;
	}
   //不是，开始分解。
	printf("No!\n");
	int n=0,first=1;
	t=re;
	printf("%d=",re);
	for(register int i=2;i*i<=re && t>1;i++)
	{
		while(!(t%i))//能除尽就一直除
		{
			t/=i;
			n++;
		}
		if(n)//如果能除尽
		{
			if(first)//如果是第一个数
			{
				printf("%d^%d",i,n);//不用输出乘号
				first=0;
			}
			else
				printf("*%d^%d",i,n);//否则要输出乘号
		}
		n=0;
	}
	if(t-1)//如果还剩一个没被输出
		printf("*%d^1",t);//输出它
	printf("\n\nEnter the number=");
	return 1;
}
int main()
{
	init();//第一步
	printf("Enter the number=");//第二步
	while(read());
	return 0;//第三步
}
```
既然已经看到这里了，为何不点个赞呢？

---

## 作者：200610311a (赞：5)

  这题的格式真的有些雷人）
  
  先考虑过程：
  
  1. 读入字符串并存数据 
  
  1. 判断数据是否为质数
  
  1. 特判数据大小
  
  1. 分解因数
  
  先解决读入
  
  既然是字符串，保险起见用gets读入。（同时判断是否全为字符
  ```cpp
	gets(z);for(int i=0;i<strlen(z);i++)
	{
		if(z[i]<='9'&&z[i]>='0'){
        s[n++]=z[i]-'0';hh=1;//先转为数组再存
        //同时判断是否全为字符
		}
	}
	if(hh==0)return 0;//全为字符，halt
    int da=0;//存储过程中a可能会爆，增加一个判断变量
	for(int i=0;i<n;i++){a*=10;a+=s[i];if(a>40000000)da=1;
	}
```
再判断素数（代码过于弱，就不给大佬们看了

特判数据大小
```cpp
if(a<2){printf("No!");return 0;
	}
    if(da){printf("No!\nThe number is too large!");return 0;
	}
    if(sushu(a)){printf("Yes!");return 0;
	}
    else printf("No!");
```

最后也是很考验人的一步：分解质因数
```cpp
int fj(unsigned long long a)//事实上没必要那么大
{ long long b=a,k=0;
	for(int i=2;i<=a;i++){
		while(a%i==0){
			a/=i;ss[i]++;
		}
	}printf("\n%lld=",b);
	for(long long i=2;i<=b/2&&i<10000000;i++){//严防越界
    //40000000以下的数因数不会太大
		if(ss[i]&&k==0){
			printf("%lld^%d",i,ss[i]);k=1;//注意格式
		}
		else if(ss[i])printf("*%lld^%d",i,ss[i]);
	}
	for(int i=0;i<10000000;i++)ss[i]=0;
	return 0;
}
```

最后，奉上完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int hh,o;int ss[10000000];
int sushu(int );
int wow(int );
int fj(unsigned long long);
int main()
{
	hh=1,o=1;
	while(hh)wow(0);
	return 0;
}
int sushu(int a)
{
	for(int i=2;i*i<=a;i++)
	if(a%i==0)return 0;
	return 1;
}
int wow(int n)
{
	unsigned long long a=0;char z[10000];int s[10000];hh=0;
	if(o){printf("Enter the number=");o=0;
	}
	else {printf("\n");printf("\nEnter the number=");
	}
	gets(z);for(int i=0;i<strlen(z);i++)
	{
		if(z[i]<='9'&&z[i]>='0'){s[n++]=z[i]-'0';hh=1;
		}
	}
	if(hh==0)return 0;int da=0;
	for(int i=0;i<n;i++){a*=10;a+=s[i];if(a>40000000)da=1;
	}
	printf("\nPrime? ");if(a<2){printf("No!");return 0;
	}if(da){printf("No!\nThe number is too large!");return 0;
	}if(sushu(a)){printf("Yes!");return 0;
	}else printf("No!");
	fj(a);
	return 0;
}
int fj(unsigned long long a){ long long b=a,k=0;
	for(int i=2;i<=a;i++){
		while(a%i==0){
			a/=i;ss[i]++;
		}
	}printf("\n%lld=",b);
	for(long long i=2;i<=b/2&&i<10000000;i++){
		if(ss[i]&&k==0){
			printf("%lld^%d",i,ss[i]);k=1;
		}
		else if(ss[i])printf("*%lld^%d",i,ss[i]);
	}
	for(int i=0;i<10000000;i++)ss[i]=0;
	return 0;
}
```


---

## 作者：jinhaoxian (赞：3)

本题是一道很简单的题，我也不知道难度怎么到了提高+/省选-    
本题主要的坑之一就是换行，样例中不太明显，要注意一下
剩下的就很简单了，读入字符串，提取数字，如果大于四千万就结束，否则就判断质数然后分解质因数  
上代码：
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
string s;
int l,i,j,k,t;
bool flag;
bool number(string st)//判断字符串中有没有数字
{
    bool f=false;
    for (int i=0;i<st.size();i++) if (st[i]>=48&&st[i]<=57) f=true;
    return f;
}
bool prime(int n)//判断质数
{
    int i;
    bool f=true;
    for (i=2;i<=sqrt(n)&&f==true;i++) if (n%i==0) f=false;
    return f;
}
int main()
{
    cout<<"Enter the number=";//不要换行
    getline(cin,s);//读入
    while (number(s))//没有数字就结束
    {
        cout<<endl<<"Prime? ";
        l=0;
        for (i=0;i<s.size();i++) 
        if (s[i]>=48&&s[i]<=57)
        {
            l=l*10+s[i]-48;
            if (l>40000000)//超出范围就直接结束
            {
                cout<<"No!"<<endl<<"The number is too large!"<<endl<<endl<<"Enter the number=";//这里换行需要注意
                s='     ';
            }
        }
        if (l<=40000000)
        { 
            if (l<2)//特判
            {
            	cout<<"No!"<<endl<<endl<<"Enter the number=";
            }
            else
        	{
                if (prime(l))//判断质数
                {
                	cout<<"Yes!"<<endl<<endl<<"Enter the number=";
                }
        	    else
        	    {
                	cout<<"No!"<<endl<<l<<'=';
                    t=0;k=l;flag=false;
        	        for (j=2;j<=sqrt(l)&&k>1;j++)//分解质因数
                    {
                	    while (k%j==0)
                	    {
                		    k/=j;
                		    t++;
                	    }
                	    if (t>0)
                	    {
                		    if (flag==true) cout<<'*';
                		    cout<<j<<'^'<<t;
                		    flag=true;
                	    }
                	    t=0;
                	}
                	for (j=2;j<=k&&k>1;j++)//避免遇到毒瘤数据（虽然可能也没必要）
                	{
                    	while (k%j==0)
                    	{
            	        	k/=j;
                	        t++;
                        }
                        if (t>0)
                    	{
                        	if (flag==true) cout<<'*';
                        	cout<<j<<'^'<<t;
                        	flag=true;
                        }
            	        t=0;
                	}
                    cout<<endl<<endl<<"Enter the number=";//注意两个换行
                    
                }
    	    }
        }
        getline(cin,s);//读入
    }
    return 0;
}
```

---

## 作者：Anguei (赞：3)

~~这是我 AC 的第 $500$ 题，要写篇题解纪念一下。~~

其实这题挺简单的，只是每次输出格式容易搞不清楚，导致 WA「Too many or too few lines」。对于这种情况，可以使用 `freopen`与下载好的数据进行对照来修改格式。比如，我是这么做的：
```cpp
#ifdef yyfLocal
	freopen("d:\\Users\\yyf\\Downloads\\testdata (12).in", "r", stdin);
	freopen("d:\\Users\\yyf\\Downloads\\testdata (12).ans", "w", stdout);
#endif
```

首先，这道题并没有明确到底有多少输入，所以可以在 `main()` 里面写一个大大的 `while(true)`，遇到不合法数据立即 `break;`。把 `return 0;` 写成 `return main();`，遇到不合法数据立即 `exit(0);` 也是可行的。

**需要注意，此题部分输入数据含有空格，所以要 `getline()` 或 `gets()`。**

根据题目描述不断模拟，判断质数、分解质因数很简单，不必多说了吧。

上代码。**我的空行比较多，看起来好像代码很复杂，其实压压行、去掉无用部分之后只有 50 行多一点点。**

```cpp
#include <cctype> // 快速判断数字
#include <string>
#include <vector> // 存质因数
#include <utility> // for std::pair
#include <iostream>

using ull = unsigned long long; // 简化类型命名的一种方式

int main()
{
#ifdef yyfLocal // 用来看输出格式的
	freopen("d:\\Users\\yyf\\Downloads\\testdata (12).in", "r", stdin);
	freopen("d:\\Users\\yyf\\Downloads\\testdata (12).ans", "w", stdout);
#endif
	while (true)
	{
		std::cout << "Enter the number=";;
		std::string s;
		std::getline(std::cin, s);
		std::cout << std::endl; // 不要漏掉换行

		ull num = 0;
		for (auto i : s)
			if (isdigit(i))
				num = num * 10 + i - 48; // 提取数字，不必多说
		if (num == 0) // 无数字，退出程序
			break;

		std::cout << "Prime? ";
		bool ok = true;
		for (ull i = 2; i * i <= num; ++i) // 判断质数
			if (num % i == 0)
			{
				ok = false;
				std::cout << "No!" << std::endl;
				break;
			}
		if (num == 1)
		{
			std::cout << "No!" << std::endl << std::endl; // 注意格式，两个换行
			continue;
		}
		if (num > 40000000)
		{
			std::cout << "The number is too large!" << std::endl << std::endl; // 俩换行
			continue;
		}
		if (ok) // 这个判断不能挪到上面，否则格式出错
		{
			std::cout << "Yes!" << std::endl << std::endl; // 俩
			continue;
		}

		auto isp = [](ull x) // 懒得单独写质数判断函数了，内嵌在 main() 里面
		{
			if (x <= 1)
				return false;
			for (ull i = 2; i * i <= x; ++i)
				if (x % i == 0)
					return false;
			return true;
		};

		std::vector<std::pair<int, int>> ans; // 存储质因数分解的答案
		std::cout << num << "=";
		for (ull i = 2; i <= num; ++i)
		{
			if (num % i == 0 && isp(i)) // 很基础，不必多说吧
			{
				int cnt = 0;
				while (num % i == 0)
				{
					++cnt;
					num /= i;
				}
				ans.emplace_back(std::make_pair(i, cnt));
			}
		}

		std::cout << ans.front().first << "^" << ans.front().second; // 按照格式输出
		for (unsigned i = 1; i < ans.size(); ++i)
			std::cout << "*" << ans[i].first << "^" << ans[i].second;
		std::cout << std::endl << std::endl; // 俩换行
	}
}
```

---

## 作者：SunsetSamsara (赞：1)

这题不会很难,但细节极其多

首先在输入上就有坑。输入的字符串可能会有空格，不能直接用 scanf 或者 cin。

然后是输出。当有特殊情况特判掉的时候，要再补上换行，不然会出现奇怪的 WA 错误。

在判断质数与分解质因数时，可以加上优化。因为分解质因数只需要模质数，而除了 $2$ 与 $3$ 之外模 $6$ 都是 $1$ 或 $5$ ，所以先特判 $2$ 与 $3$ 之后每 $6$ 个数去尝试分解就可以了。这样的优化能把常数变成原来的 $\dfrac 1 3$ ，能跑得快一点。

最后附上~~提交3次才AC的~~代码:

```cpp
#include<stdio.h>
#include<iostream>
#include<string>
#include<string.h>
#include<map>
using namespace std;
char str[1001];//输入的字符
int n;//那个数 
void str2lld(){//转换成数字 
	long long ret=0;
	bool flg=false;//一开始没有数字 
	for(int i=1;str[i]&&ret<=40000000;++i)
		if('0'<=str[i]&&str[i]<='9'){//这一位是数字 
			ret=ret*10+str[i]-'0';
			flg=true;//标记有数字 
		}
	if(!flg)n=0x7fffffff;//没有数字 
	else n=ret;
}
void trial(){//试除法
	if(n<2){
		puts("No!\n");//小于2 
		return;
	}
	do{
		if(n==2||n==3){//2或3 
			puts("Yes!\n");
			return;
		}
		if(!(n&1)){//2的倍数 
			puts("No!");
			break;
		}
		if(!(n%3)){//3的倍数 
			puts("No!");
			break;
		}
		bool flag=true;
		for(int i=5;i*i<=n;i+=6){
			if(n%i==0){
				puts("No!");
				flag=false;
				break;
			}
			if(n%(i+2)==0){
				puts("No!");
				flag=false;
				break;
			}
		}
		if(flag){
			puts("Yes!\n");
			return;
		}
	}while(0);
	if(n>40000000){
		puts("The number is too large!\n");
		return;
	}
	int m=n;
	map<int,int> mp;//有多少质数
	while(!(n&1)){//是偶数
		n>>=1;//除以2 
		if(mp.count(2))++mp[2];
		else mp[2]=1;
	}
	while(!(n%3)){//是3的倍数 
		n/=3;//除以3
		if(mp.count(3))++mp[3];
		else mp[3]=1;
	}
	for(int i=5;i*i<=n;i+=6){//其他的都%6余1或5 
		while(!(n%i)){
			n/=i;//试除i(mod 6=5)
			if(mp.count(i))++mp[i];
			else mp[i]=1;
		}
		while(!(n%(i+2))){
			n/=i+2;//试除i+2(mod 6=1)
			if(mp.count(i+2))++mp[i+2];
			else mp[i+2]=1;
		}
	}
	if(n>1)++mp[n];
	printf("%d=",m);
	for(map<int,int>::iterator it=mp.begin();it!=mp.end();++it)//遍历质因数 
		if(it==mp.begin())printf("%d^%d",it->first,it->second);
		else printf("*%d^%d",it->first,it->second);
	printf("\n\n");
}
int main(){
	string s;
	while(1){
		printf("Enter the number=\n");
		getline(cin,s);//读入一整行 
		strcpy(str+1,s.c_str());
		str2lld();//转换数字 
		if(n==0x7fffffff)return 0;//没有数字直接退出 
		printf("Prime? ");
		trial();
	}
}
```

---

## 作者：Eason_AC (赞：1)

## Content
模拟一个系统，给出一个数 $n$，让你判断是否是素数，如果是合数的话就要质因数分解。

需要注意的几点：

- 数字超过 $4\times 10^7$，输出溢出提示。
- 数字小于 $2$，输出 ``No！`` 之后直接进入下一次操作。
- 数字是合数，则进行质因数分解，分解后的格式为``x=x_1^a_1*x_2^a_2*...``，其中 $x_i$ 为这个数从小到大第 $i$ 个质因子，$a_i$ 为第 $i$ 个质因子的指数。
- 输出中会有各种友情提示和换行，请注意每一个细节。

**数据范围：$n\leqslant 4\times 10^7$。**
## Solution
这道题目实质上是不难的，至于为什么评为蓝题，个人认为是这恶心的输出方式吧。

在这里给大家总结几点吧——

- 要在输出完``Enter the number=``之后换行，不然满屏都是 $\texttt{WA}$。原因是第一行太长。
- 要在每个数据之间空一行，不然也会有大面积的 $\texttt{WA}$。原因是在某一行会太长（这也就说明了本题的评测方式是逐行比对，且不忽略多余的空格、换行和制表符）。
- ``Prime?``之后一定要有一个空格！
- 没有数字直接退出，不需要再输出多余的东西。
- 数字溢出，输出完溢出提示后直接进入下一个操作，不需要再输出多余的东西。
- 注意不需要再质因数分解中多出一些空格，诸如``15 = 3 ^ 1 * 5 ^ 1``等。

注意以上这几点，这道题目就不算难了。
## Code
```cpp
//注意这里省略了头文件
using namespace std;

bool judge(int x) {
	for(int i = 2; i <= floor(sqrt(x) + 0.5); ++i)
		if(!(x % i)) return 0;
	return 1;
}
void divide(int x) {
	int flagone = 1;
	for(int i = 2; i <= x; ++i)
		if(!(x % i)) {
			int cimi = 0;
			while(!(x % i)) {
				cimi++;
				x /= i;
			}
			if(flagone) flagone = 0;
			else	printf("*");
			printf("%d^%d", i, cimi);
		}
}

int main() {
	while(1) {
		printf("Enter the number=\n");
		int num = 0, flag = 0, yichu = 0;
		string sa;
		getline(cin, sa);
		int len = sa.size();
		for(int i = 0; i < len; ++i) {
			if(sa[i] >= '0' && sa[i] <= '9') {
				flag = 1;
				num = num * 10 + sa[i] - '0';
			}
			if(num > 40000000) {
				printf("Prime? No!\nThe number is too large!\n\n");
				yichu = 1;
				break;
			}
		}
		if(!flag)	break;
		if(yichu)	continue;
		printf("Prime? ");
		if(num < 2)	{
			printf("No!\n\n");
			continue;
		}
		if(judge(num)) {
			printf("Yes!\n\n");
			continue;
		} else {
			printf("No!\n%d=", num);
			divide(num);
			puts("\n");
		}
	}
}
```

---

## 作者：Y_B_Y (赞：1)

## 主要是要判断是不是质数与合数分解质因数

[什么是质数和合数](https://www.baidu.com/s?tn=88093251_36_hao_pg&wd=%E8%B4%A8%E6%95%B0%E5%92%8C%E5%90%88%E6%95%B0&ie=utf-8)

###### 注:

###### 1.因为这一题符号不管,所以没有负数

###### 2.样例中都是空两行,其实只要按题目说空一行,即输出两个endl

###### 3.如果输入的数太大(即大于4000000)要继续让它输入完,再输出The number is too large!,停止这一次输入(如果是用getchar()输入的话)

#### 1.判断质数(筛法筛40000000太慢了,且这里数比较少,发挥不出优势,但是可以用来求分解质因数时用的质数)

如果一个数在他的平方前都没有一个数可以它可以整除,那么这个数为质数,因为一个数的因数是成对出现的([为什么?看这里面的#欧拉函数常用性质#](https://www.luogu.org/blog/Morning-Glory/ou-la-ji-lie-yang-xi-zheng-ming-post#)),所以一个数如果有因数那么其中一定有两个因数相乘为这个数,设$a,b$为数$c(c≠0)$的两个因数且$a≤b,ab=c$,所以$a=\frac c b$,所以$a$最大为$\sqrt c$(不要问我为什么,肉眼观察法得出),所以只要在$2$到 $\sqrt c$
循环如果都没有可以整除的(即因数$a$),那么后面也一定是没有的(没$a$,哪来$b$)
```cpp
bool prm(int num)//判断num是否为质数
{
	int k=2;
	while(k<=sqrt(num)&&num%k!=0) k++;//没有就加一
	if(k>sqrt(num)) return 1;//表示到sqrt(num)都没有,所以为质数
	else return 0;//否则为合数
}
```
#### 2.分解质因数

其实最先分解的就是它的质数因数,所以也只要循环$2$到$\sqrt c$中的质数,如果有就记录这个数,并再循环一次找因数,直到这个数被除到是**1或质数**,如果最后为质数也要将它记为质因数

输出,一个质因数被记录几次就是输出几次方

完整代码(先看主函数)

[代码开头define的用法](https://blog.csdn.net/u012611878/article/details/52534622)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gt getchar()//方便打代码
#define read ra//防止read为关键字
int pr[40000001],a[4000001],cnt;//pr[]记录质数,a[]存储质因数
bool pim[6325];//pim[]判断质数,求pr[]时用
long long f;//f记录输入的数
string s1="Enter the number=",s2="Prime?",s3="Yes!",s4="No!",s5="The number is too large!";//先记录句子
bool prm(int num)//判断质数
{
	int k=2;
	while(k<=sqrt(num)&&num%k!=0) k++;
	if(k>sqrt(num)) return 1;
	else return 0;
}
bool read()//输入,为什么是bool型看主函数
{
	cout<<s1<<endl;//先输出Enter the number=并换行
	bool y=0;//记录是否有输入数字
	char c;//等一下输入用
	int ac=0;//使while多一个终止条件,这样初始化会快一点
	f=0;//f要清零
	while((c=gt)&&ac<=10000)
	{
	ac++;//使while多一个终止条件,这样初始化会快一点
	if(c=='\n')//输入终止
	{
		if(!y)//没有输入数字,返回0(即false),主函数中停止循环
		{
			return 0;
		}
		if(f<2)//小于2直接为质数
		{
			cout<<s2<<" "<<s4<<endl<<endl;//注意要输入两个endl,空一行
			return 1;//返回1,还没结束
		}
		if(prm(f))
		{
			cout<<s2<<" "<<s3<<endl<<endl;//两个endl
			return 1;//返回1,还没结束
		}
		else
		{
			int zs=0;//记录,除到最后会不会有质数,有要输出
			cout<<s2<<" "<<s4<<endl;//先输出该输出的
			int f1=f,maxn=0;//maxn记录最大质因数在数组中的位置
			while(f>1)//除到1
			{
				for(int i=1;i<=cnt;i++)
				{
					if(f%pr[i]==0)//发现质因数
					{
						maxn=max(maxn,i);//记录最大质因数所在位置
						f/=pr[i];
						a[i]++;//记录
						break;//再从pr[1]开始找
					}
					if(i==cnt)//如果到pr[cnt]都没有就说明它是质数(就像判断质数那样)
					{
						zs=f;//记录
						f=1;//f直接为1,退出while循环
						break;//先退出for循环
					}
				}
			}
			cout<<f1<<"=";//输出该输出的
			bool k=0;//等一下用
			for(int i=1;i<=maxn;i++)
			{
				if(a[i]>0)//有被记录到
				{
					if(k) cout<<"*";//如果k==0就是第一个数前面没有'*',不要输出
					cout<<pr[i]<<"^"<<a[i];//记录几次输出几次方
					k=1;//表示不是第一个数
					a[i]=0;//清零
				}
			}
			if(zs) cout<<"*"<<zs<<"^1";//如果最后除成质数,也要输出
			cout<<endl<<endl;//两个endl
			return 1;//还没结束
		}
	}
	if(c>='0'&&c<='9')//如果是数字
	{
		y=1;
		f=f*10+c-'0';加上去,前面的数位数全部加1所以乘10,新输入的数是第一位加进去就可以
		if(f>40000000)//如果太大
		{
			cout<<s2<<" "<<s4<<endl;//输出该输出的
			cout<<s5<<endl<<endl;//两个endl
			char c1;
			while((c1=gt)!='\n'); //让它输入完
			return 1;//还没结束
		}
	}
    }
}
int main()
{
   /*筛法求质数,不会去看模板p3383*/
	memset(pim,1,sizeof(pim));
	pim[1]=0;
	pim[0]=0;
	pr[++cnt]=2;//2要特判
	int k=2;
	while(k*2<=6325)
	{
		pim[k*2]=0;
		k++;
	}
	for(int p=3;p<=6325;p+=2)//因为sqrt(4000000)大约就是6325,所以存储的质数只要到这里
	{
		if(pim[p]==1)
		{
			int k=2;
			while(k*p<=6325)
			{
				pim[k*p]=0;
				k++;
			}
			pr[++cnt]=p;
		}
	}
   /*筛法求质数,不会去看模板p3383*/
	while(read());//直到返回0时(就是输入的都是符号,结束)
	return 0;
}
```




---

## 作者：微雨燕双飞 (赞：1)

来一发题解纪念一下第一道自己写对的提高+/省选-的难（keng）题。

首先说明一下，我的代码虽然非常长，但是其中有不少可以省略，但绝对是最清楚的一份。（一道纯模拟题能有提高+/省选-的难度，可见其

麻烦程度，很考验基本功和耐心，本渣提交了大概100次才过）

不多说了，来看代码：

```cpp
#include<bits/stdc++.h> //万能头文件
const long long inf=40000000; //4000万的常数定义
using namespace std;
char s[1000];
int st[1000],num,factor[1000];
long long n;
bool check1(char ss[1000]) //此函数用于判断一个字符串中是否含有数字，不多作解释了
{  
  bool flag=false;
  for(int i=0; i<strlen(ss); i++)
    if(ss[i]>='0'&&ss[i]<='9')
    {
      flag=true;
      break;
    }
  return flag;
}
long long mi(int a,int b) //这里求得a的b次方，我用了快速幂降低复杂度，其实不用也没事
{
  if(b==0) return 1; 
  long long ans=1;
  while(b)
  {
    if(b&1) ans=ans*a; //快速幂核心语句，比较二进制数位，加快速度
    b>>=1; //位运算加快速度，相当于b/=2
    a=a*a;
  }
  return ans; （logn快速幂标程）
}
bool check2() //判断一个数是否超过4000万（如果没超过直接化为整数计算）
{
  if(num>8) return false;
  for(int d=0; d<=7; d++)
    n+=mi(10,d)*st[num-d]; //调用快速幂程序将字串中所含数字化为整数
  if(n<=inf) return true; //返回TF值
    else return false;
}
bool prime(int x) //判断x是否为素数，用除筛法以外最快的判断方法，时间O（根号x）
{
  int k=2; 
  bool f=true;
  while((k<=floor(sqrt(x)))&&(f)) //判断素数，不多解释了
    if(x%k==0) f=false;
      else k++;
  if(x==1) f=false;
  return f;
}
void work(int m) //核心程序，对m分解素因数，并化成指数形式
{
  memset(factor,0,sizeof(factor)); //factor数组记录m所含的所有质因子
  int countf=0; //countf记录m有多少个质因子
  for(int i=2; i<=floor(sqrt(m)); i++) //外层循环枚举到根号m
  {
    if(prime(i)) //判断m是否为素数
    {
      if(m%i==0) factor[++countf]=i; //如果i是素数且未m的因子，加入factor数组
    }
    if(prime(m/i)) //这里是降低时间复杂度的关键，就是因子必定成对出现，再判断一遍，加入factor数组
    {
      if(m%(m/i)==0) factor[++countf]=m/i;
    }
  } //分解素因数结束（此方法效率极高，可以达到O（根号n*根号根号n），即使数据再大也可以秒出
  sort(factor+1,factor+countf+1); //这里采用快速排序使factor内的因子从小到大
  cout<<m<<"=";
  for(int i=1; i<=countf; i++)
  {
    int t=0;
    if(m==1) break; //如果m已经除成1，就推出循环
    while(m%factor[i]==0) /否则判断m含有多少个factor【i】这样的因子，并输出
    {
      t++;
      m/=factor[i];
    }
    cout<<factor[i]<<"^"<<t;
    if(i!=countf&&m!=1) cout<<"*"; //输出“*”判断条件
  }
  cout<<endl;
  cout<<endl; //维护输出格式
}
int main() //主函数
{
  cout<<"Enter the number=";
  gets(s);
  while(check1(s)) //如果s中有数字则参与运算
  {
    cout<<endl;
    cout<<"Prime? ";
    num=0; n=0;
    for(int i=0; i<strlen(s); i++) //取出s中所有的数字，存入st数组待用
      if(s[i]>='0'&&s[i]<='9') st[++num]=(int)s[i]-48;
    if(!check2()) //如果超过4000万的极限值，就忽略计算部分，直接输出
    {
      cout<<"No!"<<endl;
      cout<<"The number is too large!"<<endl;
      cout<<endl;
    }
    else //否则进入判断
    {
      //cout<<n<<endl;
      if(prime(n)) //如果是质数直接输出Yes
      {
        cout<<"Yes!"<<endl;
        cout<<endl;
      }
      else
      {
        cout<<"No!"<<endl;
        if(n!=1) work(n); //否则对n分解素因数并输出
          else cout<<endl;
      }
    }
    cout<<"Enter the number=";
    gets(s); //继续读入下一个字符串
  }
  return 0;
} //完美结束
```

---

## 作者：Catch_22 (赞：1)

个人认为题里的一堆halt除了判断输出末尾那个应该是halt，

别的（“若果是质数就halt，若是小于2的数则在输出“No!”后也halt。若是合数则分解质因数。如果该数大于四千万则输出“The number is too large!”，然后halt。”）

都不该那么写。



```delphi
Var
  st:AnsiSTring;
  ch:char;
  Tt:Int64;
Function Prime(Tt:int64):Boolean;
  //注意细节，一开始习惯性写成Tt:longint，然后202半天不知道为什么
  Var
    i:longint;
  Begin
    if Tt<=1 Then Exit(False);
    For i:=2 to Trunc(Sqrt(Tt)) do
      if Tt mod i=0 then Exit(False);
    Exit(True);
  End;
Procedure Task();
  Var
    i,j:longint;
    xx:longint;
    Flag:boolean;
  Begin
    Write(Tt,'=');
    For i:=2 to Tt do
      Begin
        Flag:=False;
        if Tt<=1 Then Break;
        xx:=0;
        While Tt Mod i=0 Do
          Begin
            Inc(xx);
            Tt:=Tt Div i;
            Flag:=True;
          End;
        if Flag Then
          Begin
            Write(i,'^',xx);
            Break;//输出一个后退出for循环，进入带*输出阶段
          End;
      End;
   {一开始想怎么判断前面是否有*，后来发现分成两端是个不错的方法，方便快捷一次见效不反复}
    For j:=i to Tt do
      Begin
        Flag:=False;
        if Tt<=1 Then Break;
        xx:=0;
        While Tt Mod j=0 Do
          Begin
            Inc(xx);
            Tt:=Tt Div j;
            Flag:=True;
          End;
        if Flag Then
          Begin
            Write('*',j,'^',xx);
    ｛下面的标程是拿数组存的，我感觉直接输出比较好，省空间，尤其是解决了*号问题之后、、、｝
          End;
      End;
    Writeln;
  End;
Begin
  While True do
    Begin
      sT:='';
      Write('Enter the number=');
      While Not Eoln do
        Begin
          Read(ch);
          if ch in ['0'..'9'] then
            st:=st+ch;
        End;
      Readln;
      Writeln;
      if st='' Then Halt;
      Write('Prime? ');
      Val(st,Tt);//字符变数字
      if Prime(Tt) Then Writeln('Yes!')
      Else
        Begin
          Writeln('No!');
          if Tt>40000000 Then Writeln('The number is too large!')
          //数清楚0，我一开始写成4000000了、、、、、
          else if Tt>=2 Then Task;
        End;
      Writeln;
    End;
End.
```
这个题交了4次才AC，第一次是Task()里面循环写了个如果Tt<=1 Then Exit 导致没有回车换行，0

第二次是又发现Prime(Tt)里面范围int64的问题，20

第三次是又发现40000000写成了4000000，80

第四次AC、、

总体说，确实是水题，但也确实很考察细心、、、、、

各位认真了···

（\*）Done By Catch-22.S.Iris in Lensent CST Team.（\*）


---

## 作者：hswfwkj_ (赞：0)

一道提升代码能力的模拟题，只需要注意几个事情就可以大功告成：

- 注意输出格式，在恰当的地方换行，并且处理完数据之后要多空一行。
- 读入字符串之后要将其转化为数字。
- $1$不是质数，但不需要将其分解质因数。
- 如果当前数大于四千万直接输出不是质数和太大的提示。

本题我并没有注意出现$0$的情况，但是还是过了，说明此题的数据还是比较友好的。

贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long len;
char c[10001];
long long sum(){//提取字符串中的数字
	long long i,sum=0,flag=0;
	for(i=0;i<len;i++)
		if(c[i]>='0'&&c[i]<='9'){
			sum=sum*10+c[i]-'0';//提取数字
			flag=1;//标记找到了数字
		}
	if(flag)
	return sum;
	else
	return -1;//返回-1代表整个字符串都没有找到数字
}
bool prime(long long n){//判断质数函数
	long long i;
	if(n==1)//特判是1的情况
	return false;
	for(i=2;i<=sqrt(n);i++)
		if(n%i==0)
			return false;
	return true;
}
void fj(long long n){//分解质因数函数
	long long i,ans=0,flag=1;
	printf("%lld=",n);
	for(i=2;i<=n;i++){
		ans=0;//ans记录n能整除i几次
		while(n%i==0){//n可以被i整除
			n/=i;
			ans++;
		}
		if(flag&&ans){//是第一次分解，只输出算式
		flag=0;
		printf("%lld^%lld",i,ans);
		continue;
		}
		if(flag==0&&ans)//不是第一次，输出乘号和算式
		printf("*%lld^%lld",i,ans);
	}
	printf("\n\n");
}
void print(long long n){
	if(n>40000000)//如果n大于40000000输出不是质数和太大提示
		printf("Prime? No!\nThe number is too large!\n\n");
	else if(prime(n))//如果是质数输出是质数提示
		printf("Prime? Yes!\n\n");
	else if(n==1)//特判是1的情况
		printf("Prime? No!\n\n");
	else{//如果上述情况都不符合对其分解质因数
		printf("Prime? No!\n");
		fj(n);
	}
}
int main(){
	long long r;
	while(cout<<"Enter the number="){//持续输出
		gets(c);
		len=strlen(c);
		r=sum();
        if(r==-1)//如果扫遍整个字符串都没有出现数字，退出循环
        break;
		printf("\n");
		print(r);
	}
}
```
本题我的代码繁琐了一点，请见谅。

---

## 作者：伟大的王夫子 (赞：0)

如果想要更好的体验，可以到[我的博客](https://www.luogu.org/blog/I-AK-IOI/)去看

这题操作很烦啊。

但总的是一个大模拟，感觉只有黄题难度

我们先用getline读入每行的字符串。而且用类似快读的方式，分离出这个数字

如果数字很大，超过四千万，那么

```puts("Prime? No!\nThe number is too large!\n");```

否则判断质数，若不是质数则分解质因数。具体实现请参考程序以及注释

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
string s;
int cnt, p[50010], c[50010];
#define w() puts("Enter the number=")
inline bool is_prime(int n) {
	if (n < 2) return 0;
	for (register int i = 2; i <= sqrt(n); ++i)
		if (n % i == 0) return 0;
	return 1;
}
void divide(int n) {
	if (is_prime(n)) {
		puts("Prime? Yes!\n");
		return;
	}//判定是否为质数 
	if (n < 2) {
		puts("Prime? No!\n");
		return;//特判<2 
	}
	cnt = 0;
	int tmp = n;
	for (register int i = 2; i <= sqrt(n); ++i) {
		if (n % i == 0) {
			p[++cnt] = i, c[cnt] = 0;
			while (n % i == 0) n /= i, ++c[cnt];
		}
	}
	if (n > 1) p[++cnt] = n, c[cnt] = 1;

	puts("Prime? No!");
	printf("%d=", tmp);
	for (register int i = 1; i < cnt; ++i)
		printf("%d^%d*", p[i], c[i]);
	printf("%d^%d", p[cnt], c[cnt]);
	puts("\n");
}//分解质因数，基本功 
int main() {
	//cout << (-7) % 3;
	//freopen("data.out", "w", stdout);
	//刚开始忘把文件去掉，导致WA,大家要注意！！！ 
	puts("Enter the number=");
	while (getline(cin, s)) {
		ll res = 0;
		bool flag1 = 0, flag2 = 0;
		//flag1表示数字是否过大，flag2表示字符串中有无数字 
		for (register int i = 0; i < s.size(); ++i) {
			if (!isdigit(s[i])) continue;//不是数字，跳过 
			flag2 = 1;//有数字 
			res = (res << 3) + (res << 1) + s[i] - 48;
			if (res >= 40000000) flag1 = 1;//数字很大 
		}
		//cout << res << endl;
		if (!flag2) {
			break;//字符串中没有数字，那么结束循环 
		}
		if (flag1) {
			puts("Prime? No!\nThe number is too large!\n");
			w();//数字过大了，输出并跳过 
			continue;
		}
		divide(res);//分解质因数 
		w();
	}
}
```

---

## 作者：李至擎 (赞：0)

[点我看题](https://www.luogu.com.cn/problem/P1619)

思路：显然是模拟题，没什么好说的。

方法（以读入一组数据为例）：

- $1.$ 读入字符串；

- $2.$ 从字符串里提取出数字；

- $3.$ 特判数据大小；

- $4.$ 如果不过大且不过小，就判断数字是否为质数；

- $5.$ 如果数字是不是质数，就分解之；

- $6.$ 输出以上的结果。

细节：

- $1.$ 输入时会有空格，如果是用 $cin$ 和 $scanf$ 来读入的话要把 $cin$ 和  $scanf$ 换成 $gets$ ；
 
- $2.$ 遇到时负号 $+$ 数字不要当成负数来读入，要把负号当成干扰符号；

- $3.$ 遇到全是字符的时候，下面就不用管了；

- $4.$ 一定要开 $long$ $long$ ，一定要开 $long$ $long$ ，一定要开 $long$ $long$ ！

代码：

```
#include<bits/stdc++.h>
#define long long LL//个人习惯 
using namespace std;
char a[1005];//a是要输入的字符串 
LL n;//n是从输入的字符串找出的数字  
LL check(LL x)//check函数是用于判断数字情况的（1代表太大，2是质数，3是合数，4代表太小） 
{
	if(x>40000000)return 1;//太大了（大于40000000） 
	if(x<2)return 4;//太小了（小于2） 
	for(LL i=2;i*i<=x;i++)//判断质数（基本功） 
	{
		if(x%i==0)//有i这个因子 
		{
			return 3;//是合数 
		}
	}
	return 2;//是质数 
}
LL c(LL x)//c函数是用于计算10^x的 
{
	LL y=1;//y是储存的结果 
	for(LL i=1;i<=x;i++)//循环x次 
	{
		y*=10;//每次乘10 
	}
	return y;//返回结果 
}
LL find(LL x)//find函数是用于从字符串中找出数字的 
{
	LL y=0,ok=0;//y是当前位数，ok是用于判断还有没有数字 
	for(LL i=x;i>=1;i--)//倒序遍历 
	{
		if(a[i]>='0'&&a[i]<='9')//是一个数字 
		{
			LL z=(a[i]-'0')*c(y);//z是把当前这一位转成数字后的结果 
			n+=z;//加上当前这一位 
			y++;//位数+1 
			ok=1;//有数字 
		}
	}
	if(ok)return 1;//有数字，返回1 
	else return 0;//没有数字，返回0  
}
int main()
{
	while(gets(a+1))//用gets可以读入一行 
	{
		cout<<"Enter the number=\n";//题目要求 
		LL l=strlen(a+1);//l是字符串长度 
		n=0;//n初始化 
		if(find(l))//如果找得到数字 
		{
			LL p=check(n);//p是储存n的范围的 
			if(p==1)cout<<"Prime? No!\nThe number is too large!\n\n";//数字太大 
			else if(p==2)cout<<"Prime? Yes!\n\n";//是质数 
			else if(p==3)//是合数 
			{
				cout<<"Prime? No!\n"<<n<<"=";//不是质数 
				for(LL i=2;i*i<=n;i++)//分解质因数（基本功） 
				{
					LL t=ok=0;//t是i这个因子的次数，ok是是否有这个因子 
					while(n%i==0)//如果还有i这个因子 
					{
						ok=1;//有i这个因子  
						n/=i;//除去i 
						t++;//次数+1 
					}
					if(ok==1)//如果有这个因子 
					{
						if(n>1)cout<<i<<"^"<<t<<"*";//不是最后一个因子 
						else cout<<i<<"^"<<t;//是最后一个因子 
					}
				}
				if(n>1)cout<<n<<"^"<<1;//如果n还不等于0，那就还有一个因子，就是此时的它本身 
				cout<<"\n\n";
			}	
			else cout<<"Prime? No!\n\n";//数字太小	
		}
		else return 0;//如果找不到数字了，就结束程序 
	}
	return 0;
}
```

修改记录：

$2020.12.22$ ：增加了一部分 $\LaTeX$ ，增加了注释并精简了一部分语言。

---

## 作者：StupidSeven (赞：0)

##    一篇蒟蒻的题解
   看题，是道模拟题。顺序：先读数，在判断，最后输出。
##    读数
```
inline int init(){
	int sum=0,flag=0;
	for(re int i=0;i<s.size()&&sum<=40000000;i++){
		if(isdigit(s[i])){
			flag=1;
			sum=sum*10+s[i]-48;
		}
	}//正经读入
	if(!flag) exit(0);//如果没有数字，就结束
	return sum;
}
```
## 判断
```
bool prime(int x){//暴力判素数（蒟蒻不会用线性嘤嘤嘤
	if(x<2) return 0;
	for(int i=2;i*i<=x;i++) if(x%i==0) return 0;
	return 1;
}
```
## 输出

```
inline void work(int x){
	int flag=0,is_prime=prime(x),index=0;
	if(is_prime&&x<=40000000) printf("Prime? Yes!\n\n");//是不是范围内的素数
	else printf("Prime? No!\n");
	if(is_prime||x<2||x>40000000){//如果不在范围内或者是素数
		if(x>4000000) printf("The number is too large!\n\n");
		if(x<2) putchar('\n');
		return;
	}
	printf("%d=",x);
	for(int i=2;i*i<=x;++i){//分解质因数
		while(x%i==0){
			x/=i;
			index++;
		}
		if(index){
			if(flag) printf("*%d^%d",i,index);//如果不是是第一种约数，输出'*'
			else{
				printf("%d^%d",i,index);
				flag=1;
			}//反之不输出'*'
			index=0;
		}
	}
	if(prime(x)) printf("*%d^1\n\n",x);//如果剩下的数是素数
	else printf("\n\n");
}
```
## 完整代码
```
#include<bits/stdc++.h>
using namespace std;
#define INF 17483647
#define M 200005
#define re register
#define ll long long
string s;
int ans;
bool prime(int x){
	if(x<2) return 0;
	for(int i=2;i*i<=x;i++) if(x%i==0) return 0;
	return 1;
}
inline int init(){
	int sum=0,flag=0;
	for(re int i=0;i<s.size()&&sum<=40000000;i++){
		if(isdigit(s[i])){
			flag=1;
			sum=sum*10+s[i]-48;
		}
	}
	if(!flag) exit(0);
	return sum;
}
inline void work(int x){
	int flag=0,is_prime=prime(x),index=0;
	if(is_prime&&x<=40000000) printf("Prime? Yes!\n\n");
	else printf("Prime? No!\n");
	if(is_prime||x<2||x>40000000){
		if(x>4000000) printf("The number is too large!\n\n");
		if(x<2) putchar('\n');
		return;
	}
	printf("%d=",x);
	for(int i=2;i*i<=x;++i){
		while(x%i==0){
			x/=i;
			index++;
		}
		if(index){
			if(flag) printf("*%d^%d",i,index);
			else{
				printf("%d^%d",i,index);
				flag=1;
			}
			index=0;
		}
	}
	if(prime(x)) printf("*%d^1\n\n",x);
	else printf("\n\n");
}
signed main(){\
	std::ios::sync_with_stdio(false);
	while(printf("Enter the number=\n")){
		getline(cin,s);
		work(init());
	}
	return 0;
}
```
## 完美结束
最后，膜拜一下你谷所有神犇%%%


---

## 作者：Lylighte (赞：0)

一道 `模拟EX` 题，里面牵扯到字符串读入，数字分离，判断素数，分解质因数，~~但就是没有求解一元二次方程~~。

一道大的模拟题通常由多个小的算法组合成，所以先要把每个小的算法搞定。

### 输入输出 & 分离数字

奇葩的输入输出方式，每次先输出字符串且不换行，接着输入字符串。（STL 里的 `string` 是个好东西）

从中分离数字。临时变量 `t` 记录分离出的数字，先初始化 `t=0`，从头到尾扫一遍，发现一个数字字符时，进行迭代：变量 `t` 乘 $10$ 再加上数字的值。字符串扫完，数字就分离出来了。

题目要求输出该数字是否为素数，以及分解质因数的结果。注意输入输出要求（稍微改一下）：

>1. 在读入数据之前先输出 `Enter the number=`，不要换行。读入数据完毕后换行。
>2. 然后输出 `Prime? `，问号后有一个空格，但不要换行。
>3. 如果这个数小于 $2$，输出 `No!`，此时换行，并进行下一轮读入。
>4. 如果大于 $4\times 10^7$，输出 `No!` 并换行，再输出 `The number is too large!`并换行。（不必关心它是不是质数）
>5. 否则，如果这个数是质数，输出 `Yes!` 并换行，进行下一轮读入。
>6. 否则，输出 `No!` 并换行，输出分解质因数的结果。
>7. 每组数据后再输出一个换行。

一步一步满足就行了。对于数太大的情况，在分离数字的同时检查是否已经超过 $4\times 10^7$，如果超过，返回错误信息。

顺便说一下，输入的字符串中间可能**有空格**！而直接用 `cin` 读入字符串是到空格为止的，所以读不进所有数据。不得不使用 `getline` 读入。

输入输出的过程放在了主函数中：

```cpp
int main(){
/*省略一些东西*/
    while(1){
		cout << "Enter the number=";
		getline(cin,st);			//因为有空格，不得不用 getline
		int n = worknum(st);		//分离数字（可能是错误信息）
		if(n==EMPTY){				//没有数字就结束
			return 0;
		}
		cout << '\n';
		cout << "Prime? ";
		if(n==TOOBIG){				//太大时的输出
			cout << "No!" << '\n';
			cout << "The number is too large!" << '\n' ;
		}
		else if(n<2){				//小于2的输出
			cout << "No!" << '\n';
		}
		else if(isprime[n]==false){	//判断素数以及分解质因数
			cout << "No!" << '\n';
			divi(n);
		}
		else{
			cout << "Yes!" << '\n';
		}
		cout << '\n';
	}
	return 0;
}
```



分离数字：

```cpp
const int TOOBIG=-1, EMPTY=-3;	//标记错误类型
int worknum(string st){
	int num=0;
	bool getans=false;
	int len=st.size();
	for(int i=0; i<len; i++){
		if(st[i]>='0'&&st[i]<='9'){
			num = num*10+st[i]-'0';
			getans = true;
			if(num>40000000){
				return TOOBIG;	//数字太大
			}
		}
	}
	if(!getans){
		return EMPTY;			//没读到数字
	}
	return num;
}
```



### 判断素数

可以用时间复杂度为 $O(\sqrt{n})$ 的方法判断一个数是否为素数，也可以进行线性筛素数（空间开销较大，时间复杂度为 $O(n)$，查找为 $O(1)$，空间复杂度 $O(n+m)$）。这里用线性筛素数：

```cpp
bool isprime[40000010];			//标记数字是否为素数
int primelist[8000010], pcnt;	//素数表，还要用于分解质因数
void workprime(){				//线性筛素数
    memset(isprime, true, sizeof(isprime));
    isprime[0]=isprime[1]=false;
	for(int i=2; i<=40000000; i++){
		if(isprime[i]){
			primelist[++pcnt] = i;
		}
		for(int j=1; j<=pcnt&&primelist[j]*i<=40000000; j++){
			isprime[primelist[j]*i] = false;
			if(i%primelist[j]==0){
				break;
			}
		}
	}
	return;
}
```

~~鉴于这题数据很水~~，如果只是判断素数，用第一种方法更省时间。

### 分解质因数

之前不是有了素数表吗？直接用它来分解就行了。

从最小的素数 $2$ 开始，如果当前素数能整除这个合数，那么这个素数指数加 $1$，直到不能整除，此时输出当前结果。指数为 $0$ 的当然不用输出，其余的以 `a^k` 的形式输出，如果不是第一项还要在前面补一个 `*`。

```cpp
void divi(int n){
	bool appeared=false;
	cout <<  n << '=';
	for(int i=1; i<=pcnt; i++){
		int p=0;
		while(n%primelist[i]==0&&n>0){			//如果当前素数是合数的素因子（能整除）时
			p++;								//指数加 1
			n /= primelist[i];
		}
		if(p>0){								//指数非 0 时
			if(appeared)
				cout << '*';					//前面有输出（即非首项）时补一个乘号
			cout << primelist[i] << '^' << p;	//输出当前结果
			appeared = true;
		}
	}
	cout << '\n';
}
```

### 最终代码

[戳这里](https://www.luogu.com.cn/record/31866108)

### DEBUG 过程

- 把线性筛素数写爆了，竟然多乘了个数字。
- 第一次提交爆零，字母大小写出错。
- 第二次 WA 5 个点，因为 `cin` 读入跳过了空格，出错。
- 第三次 WA 2 个点，忘记特判 $n<2$ 的情况。
- 第四次 AC。

到这就结束了。

---

## 作者：fzj2007 (赞：0)

### **这道题是一个纯模拟！**

好了，先看看这道题的坑点。。

1、前面写的还是 当然，初中数学题不可能有大于**int64**的数让你判断素性，因此超过范围的数可以忽略不计，后面就变成如果该数**大于四千万**则输出。。。（~~坑了我三次~~）

2、还有输出的坑（到处都是，这里不列举了）。

这道题没有告诉我们询问次数（~~那就当他很小吧。。~~），但是按照我的算法没有超市，那就是很小了。

### 第一步，先看看素数判断：

1、O(n)朴素算法：
```
bool isprime(int x){
	for(int i=2;i<x;i++)
      if(x%i) return false;
   return true;                       
}
```
#### 显然，这个算法太落后了！

然后，想到O（sqrt(n)）算法：
```
bool isprime(int x){
	for(int i=2;i<=sqrt(x);i++)
      if(x%i) return false;
   return true;                       
}
```
#### 其实这个算法应该也可以过了，但是我并不满意这个算法。**因为还可以做到O（sqrt(n)/3）！**
```
bool Prime(long long x){
	if(x<2) return 0;//因为当x为1的时候，会出现错误。return 0是因为计算机要把bool值转化为二进制。
	if(x==2||x==3||x==5) return true;
	if(x%6!=1&&x%6!=5) return false;
	int x_sqrt=floor(sqrt((float)x));
	for(int i=5;i<=x_sqrt;i+=6)
	    if(x%(i)==0||x%(i+2)==0) return 0;
    return 1;
}
```

### 接下来分解质因数：
```
void Prime_factorization(int n){
	bool flag=true;//用于判断是否是第一个数
	for(int i=2;i*i<=n;i++){//i*i<=n就可以了
		int k=0;//k用来记录幂的指数，i用来做底数
		while(!(n%i)) k++,n/=i;//增加幂的次数
        if(k)//处理输出情况
			if(flag){
				printf("%d^%d",i,k);//第一个数，没有前面的‘*’
				flag=false;	//下一个数不是第一个数
			}else printf("*%d^%d",i,k); //正常情况输出
	}
}
```

毒瘤的我还加了一个read()函数：
```
inline int read(){
	int ans=0,flag=1;//flag用来判断负数
	char ch=getchar();//读入一个字符
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();//如果不是数字，过滤掉
	if(ch=='-') flag=-1,ch=getchar();//负数判断
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';//累加数字
		ch=getchar();//继续读入
	}
	return ans*flag;//是否为负数
}
```


那么重要函数都说完了，现在只差主函数了！
```
int main(){
	while(1){//无限循环。。
		printf("Enter the number=");//先输出
		getline(cin,s);//读入整行，可以读入空格
		printf("\n");//别忘了换行啊，这是坑！
		long long n=0;//longlong保险
		for(int i=0;i<s.length();i++)
			if(s[i]<='9'&&s[i]>='0'&&n<=40000000) n=n*10+s[i]-'0';
		if(!n) return 0;//没有数字直接返回
		printf("Prime? ");
		if(n<2) printf("No!");//比2小，放在这里了
		else if(Prime(n))
			printf("Yes!");
		else{
			printf("No!\n");
			if(n>40000000){//数太大
				printf("The number is too large!\n\n");
				continue;//直接跳出
			}
			printf("%d=",n);//分解
			Prime_factorization(n);
		}
		printf("\n\n");
	}
	return 0;
}
```

最后贴完整代码


------------
```
//#include<bits/stdc++.h>
using namespace std;
string s; 
inline int read(){
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag;
}
bool Prime(long long x){
	if(x>40000000) return false;
	if(x==2||x==3||x==5) return true;
	if(x%6!=1&&x%6!=5) return false;
	int x_sqrt=floor(sqrt((float)x));
	for(int i=5;i<=x_sqrt;i+=6)
	    if(x%(i)==0||x%(i+2)==0) return 0;
    return 1;
}
void Prime_factorization(int n){
	bool flag=true;
	for(int i=2;i*i<=n;i++){
		int k=0;
		while(!(n%i)) k++,n/=i;
        if(k)
			if(flag){
				printf("%d^%d",i,k);
				flag=false;	
			}else printf("*%d^%d",i,k); 
	}
}
int main(){
	while(1){
		printf("Enter the number=");
		getline(cin,s);
		printf("\n");
		long long n=0;
		for(int i=0;i<s.length();i++)
			if(s[i]<='9'&&s[i]>='0') n=n*10+s[i]-'0';
		if(!n) return 0;
		printf("Prime? ");
		if(n<2) printf("No!");
		else if(Prime(n))
			printf("Yes!");
		else{
			printf("No!\n");
			if(n>40000000){
				printf("The number is too large!\n\n");
				continue;
			}
			printf("%d=",n);
			Prime_factorization(n);
		}
		printf("\n");
	}
	return 0;
}
```


------------

## **不要复制哦，有坑哦！！**

如果有帮助，请帮忙点赞，谢谢！

[MY BLOG](https://www.luogu.com.cn/blog/fzj2007/)和[我的个人主页](https://www.luogu.com.cn/user/172370#main)



---

## 作者：G_hz (赞：0)

这个题算是道比较水的模拟题吧，（我却WA了快10遍

注意题目说的是不超过int64的数字才进行判断，而不超过4e7的数字才进行质因数分解

判质数和分解质因数就没什么可说的了吧，朴素的n\*sqrt(n)就可以

代码太丑了，各位将就着看吧：

    
```cpp
#include<stdio.h>
#include<algorithm>
#include<string.h>
#define LL long long
char s[1000000],str;
int mi[1000][2];
unsigned long long cc;
bool prime(LL s){
    for(int i=2;i*i<=s;i++){
        if(s%i==0)return 0;
    }
    return 1;
}
int cn=0;
int main()
{
    //freopen("1.txt","w",stdout);
    while(1){
        ++cn;
        if(cn!=1)putchar(10);
        printf("Enter the number=\n");
        int cnt=0;
        int flag=1;
        cc=0;
        gets(s);
        for(int i=0;i<strlen(s);i++){
            if(s[i]>='0'&&s[i]<='9'){
                cc+=s[i]-'0';
                cc*=10;
            }
        }
        cc/=10;
        if(cc==0)break;
        if(cc<0)continue;
        printf("Prime? ");
        for(LL i=2;i*i<=cc;i++){
            if(cc%i==0){
                printf("No!\n");
                flag=0;
                break;
            }
        }
        if(cc==1){
            printf("No!\n");
            continue;
        }
        if(flag==1){
            printf("Yes!\n");
            continue;
        }
        if(cc>40000000){
            printf("The number is too large!\n");
            continue;
        }
        printf("%d=",cc);
        for(LL i=2;i<=cc;i++){
            if(!(cc%i)&&prime(i)){
                int j;
                for(j=1;j<=100;j++){
                    cc/=i;
                    if(cc%i)break;
                }
                mi[++cnt][0]=i;
                mi[cnt][1]=j;
            }
        }
        for(int i=1;i<=cnt;i++){
            printf("%d^%d",mi[i][0],mi[i][1]);
            if(i^cnt)printf("*");
        }
        putchar(10);
    }
    return 0;
}
```

---


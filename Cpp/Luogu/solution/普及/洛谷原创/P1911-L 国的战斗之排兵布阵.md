# L 国的战斗之排兵布阵

## 题目背景

L 国即将与 I 国发动战争！！

## 题目描述

L 国的指挥官想让他的每一个军营都呈现出国徽形——L 形（方向无所谓）。当然，他的指挥营除外（这叫做个性），他想不出该怎么排，就这样，这任务又变成了你的······

## 说明/提示

$1\le n\le10$，$1\le x,y\le2^n$。

## 样例 #1

### 输入

```
4 1 3```

### 输出

```
1 1 0 2 3 3 4 4 5 5 6 6 7 7 8 8
1 9 2 2 3 10 10 4 5 11 11 6 7 12 12 8
13 9 9 14 15 15 10 16 17 11 18 18 19 19 12 20
13 13 14 14 21 15 16 16 17 17 18 22 22 19 20 20
23 23 24 21 21 25 26 26 27 27 28 28 22 29 30 30
23 31 24 24 25 25 32 26 27 33 33 28 29 29 34 30
35 31 31 36 37 32 32 38 39 39 33 40 41 34 34 42
35 35 36 36 37 37 38 38 43 39 40 40 41 41 42 42
44 44 45 45 46 46 47 43 43 48 49 49 50 50 51 51
44 52 52 45 46 53 47 47 48 48 54 49 50 55 55 51
56 52 57 57 58 53 53 59 60 54 54 61 62 62 55 63
56 56 57 64 58 58 59 59 60 60 61 61 65 62 63 63
66 66 67 64 64 68 69 69 70 70 71 65 65 72 73 73
66 74 67 67 68 68 75 69 70 76 71 71 72 72 77 73
78 74 74 79 80 75 75 81 82 76 76 83 84 77 77 85
78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85
```

# 题解

## 作者：loverintime (赞：19)

这是一道简单分治题， 但是大部分人的代码都在 2k 左右。 而我的代码只有 743B。 至少现在看来， 我的代码长度是完全比其他所有人少一大截的。 

如何减短代码长度？ 有一点很重要： **尽量少写重复的部分**。 现在所有的题解都是枚举中心点在哪里。 其实， 仔细想想， 不管中心点在哪里， 其他三块的处理方式是一样的， 所以没有必要打四遍， 只需要依次处理四个部分即可。

还有最后重新编码， 根本不需要再搜索一次， 只需要按顺序遍历， 用一个数组映射即可。

有人会问， 代码短一点有什么好处。 这倒题比较简单， 但做到后来更难， 码量更大的时候， 代码段的好处就体现出来了： 更好调试。 

本题解并不说明这道题怎么去做（想知道的话看其他人写的）， 只是希望大家养成比较好的代码习惯， 这样在调试更难的题的时候才可以更加轻松。

放上我的代码：
```cpp
#include<bits/stdc++.h>
const int N=(1<<10)+5;
int n,x,y;
int A[N][N],cnt,p[N*N],tot;
const int dx[4]={0,1,0,1},dy[4]={0,0,1,1},cox[4]={1,0,1,0},coy[4]={1,1,0,0};
void dfs(int x,int y,int c,int a,int b){
	if(c==0) return;c--;int t=++cnt;
	for(int i=0; i<4; i++){
		int nx=x+(dx[i]<<c),ny=y+(dy[i]<<c),f=nx+(cox[i]<<c)-cox[i],g=ny+(coy[i]<<c)-coy[i];
		if(a>=nx&&a<nx+(1<<c)&&b>=ny&&b<ny+(1<<c)) dfs(nx,ny,c,a,b);
		else dfs(nx,ny,c,f,g),A[f][g]=t;
	}
}
int main(){
	scanf("%d%d%d",&n,&x,&y);
	dfs(1,1,n,x,y);
	for(int i=1; i<=1<<n; i++) for(int j=1; j<=1<<n; j++){
		if(i!=x||j!=y){
			if(!p[A[i][j]]) p[A[i][j]]=++tot;
			printf("%d ",p[A[i][j]]);
		}
		else printf("0 ");
		if(j==(1<<n)) puts("");
	} 
	return 0;
}

---

## 作者：NewJeanss (赞：10)

### 分治基础题（类似P1228）

1. 为什么想到分治？

~~因为标签~~实际上，分治是一个把大问题**分割**成解法类似的小问题，再**合并**的过程。

像这一题，我们发现任意一个 $2^k\ * 2^k$ 的正方形内，只要有一个点不覆盖，都是可以通过一种覆盖方法把其他点覆盖的。那么，我们就可以把 $2^k\ * 2^k$ 的方格**分割**成四个 $2^{\frac{k}{2}}\ * 2^{\frac{k}{2}}$ 的小正方形来求解。

2. 怎么分治？

我们把不可覆盖的点成为指挥营。上文说到每一个小正方形内若有指挥营，其他点都是可以通过一种方法覆盖的。那我们分割出来的四个小正方形中有三个是没有一个指挥营的。怎么办呢？**我们自己制造指挥营**。

假设X是指挥营。我们把大正方形分割，其中右上，左下，右下都没有指挥营。

| o | o | o | o |
| -----------: | -----------: | -----------: | -----------: |
| o | X | o | o |
| o | o | o | o |
| o | o | o | o |

我们**找到中心点**，把(2,3)(3,2)(3,3)三个点也覆盖上，相当于给三个小正方形制造了一个指挥营。这样就可以依次递归求解啦。

| o | o | o | o |
| -----------: | -----------: | -----------: | -----------: |
| o | X | x | o |
| o | x | x | o |
| o | o | o | o |

```cpp
inline void dfs(int x1,int y1,int x2,int y2,int targx,int targy){
	//(x1,y1)是左上角，(x2,y2)是右下角，(targx,targy)是指挥营
	int midx,midy,f1,f2,f3,f4;
	midx=(x1+x2)>>1; midy=(y1+y2)>>1;//中心点
	f1=f2=f3=f4=false;
   	//判断中心点在哪一个方向
	if(targx<=midx&&targy<=midy){//左上
		f1=true;//最后不用再次递归左上，因为这里递归了
		g[midx+1][midy+1]=++cnt;//标记三个点
		g[midx][midy+1]=g[midx+1][midy]=cnt;
		if(abs(x1-x2)==1&&abs(y1-y2)==1) return;//如果已经是2*2了，结束递归
		dfs(x1,y1,midx,midy,targx,targy);
	}
	else if(targx<=midx&&targy>midy){//右上
		f2=true;
		g[midx+1][midy]=++cnt;
		g[midx][midy]=g[midx+1][midy+1]=cnt;
		if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
		dfs(x1,midy+1,midx,y2,targx,targy);
	}
	else if(targx>midx&&targy<=midy){//左下
		f3=true;
		g[midx][midy+1]=++cnt;
		g[midx][midy]=g[midx+1][midy+1]=cnt;
		if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
		dfs(midx+1,y1,x2,midy,targx,targy);
	}
	else if(targx>midx&&targy>midy){//右下
		f4=true;
		g[midx][midy]=++cnt;
		g[midx+1][midy]=g[midx][midy+1]=cnt;
		if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
		dfs(midx+1,midy+1,x2,y2,targx,targy);
	}
	if(abs(x1-x2)==1&&abs(y1-y2)==1) return;
   	//如果之前没有递归，最后再递归四个小正方形
	if(!f1) dfs(x1,y1,midx,midy,midx,midy);
	if(!f2) dfs(x1,midy+1,midx,y2,midx,midy+1);
	if(!f3) dfs(midx+1,y1,x2,midy,midx+1,midy);
	if(!f4) dfs(midx+1,midy+1,x2,y2,midx+1,midy+1);
}

dfs(1,1,pow(2,k),pow(2,k),x,y);
```


3. 重新编号

这样做出来的方案编号和题目有差异。我们就重新编号即可。方法就是~~暴力~~。

```
int dx[8]={-1,-1,-1,0,1,1,1,0};
int dy[8]={-1,0,1,1,1,0,-1,-1};

memset(g,0,sizeof(g)); 
memset(vis,0,sizeof(vis)); cnt=0;
for(int i=1;i<=pow(2,k);i++){//遍历每一个点
	for(int j=1;j<=pow(2,k);j++){
		if(vis[i][j]||g[i][j]==0) continue;//走过就略过
		vis[i][j]=1; w=g[i][j]; g[i][j]=++cnt;
		for(int l=0;l<8;l++){//周围八个方向和(i,j)是一个块的，标记
			xx=i+dx[l]; yy=j+dy[l];
			if(g[xx][yy]==w&&vis[xx][yy]==0) g[xx][yy]=cnt,vis[xx][yy]=1;
		}
	}
}
```


---

## 作者：zjc5 (赞：8)

[题目链接](https://www.luogu.com.cn/problem/P1911)

**思路：**

通过题目可以发现 $2^n\times2^n\bmod3=1$。

一个边长为 $2^n$ 的正方形可以分成四个长为 $2^{n-1}$ 的正方形。

但是其中只有一个正方形有军营，其他三个没有，那么就给它们设立一个。

方式如下，$X$ 表示军营。

```
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 X 0 0 0 0 0
0 0 0 0 0 0 0 0
```

设立三个后：

```
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0
0 0 X 0 0 0 0 0
0 0 0 0 0 0 0 0
```

现在边长为 $8$，现在用递归进入下一层，处理边长为 $4$ 的。

```
0 0 0 0 0 0 0 0
0 2 2 0 0 3 3 0
0 2 0 0 0 0 3 0
0 0 0 1 1 0 0 0
0 0 0 0 1 0 0 0
0 5 5 0 0 0 4 0
0 5 X 0 0 4 4 0
0 0 0 0 0 0 0 0
```
最后是处理边长为 $2$ 的。

```
4 4 5 5 8 8 9 9
4 2 2 5 8 3 3 9
6 2 7 7 10 10 3 11
6 6 7 1 1 10 11 11
12 12 13 13 1 16 17 17
12 5 5 13 16 16 4 17
14 5 X 15 18 4 4 19
14 14 15 15 18 18 19 19
```

最后按照从小到大的顺序输出即可。

代码时间复杂度 $O(2^n\times2^n)$。
```cpp
#include<stdio.h>
int n,x,y,l,tot,ans[1050][1050],prt,k[1100000];
void dfs(int a,int b,int c,int d,int x,int y){
//正方形左上角是a行b列，右下角是c行d列,军营在x行y列
	int h=(a+c)/2,l=(b+d)/2;
	int p=(x>h)*2+(y>l);
//p记录军营在正方形的哪个位置
//0表示左上，1表示右上，2表示左下，3表示右下
	if(p==0) ans[h][l+1]=ans[h+1][l]=ans[h+1][l+1]=++tot;
	else if(p==1) ans[h][l]=ans[h+1][l]=ans[h+1][l+1]=++tot;
	else if(p==2) ans[h][l]=ans[h][l+1]=ans[h+1][l+1]=++tot;
	else ans[h][l]=ans[h+1][l]=ans[h][l+1]=++tot;
	if(c-a>=3){
		if(p==0) dfs(a,b,h,l,x,y);
		else dfs(a,b,h,l,h,l);
		if(p==1) dfs(a,l+1,h,d,x,y);
		else dfs(a,l+1,h,d,h,l+1);
		if(p==2) dfs(h+1,b,c,l,x,y);
		else dfs(h+1,b,c,l,h+1,l);
		if(p==3) dfs(h+1,l+1,c,d,x,y);
		else dfs(h+1,l+1,c,d,h+1,l+1);
	}
}
int main(){
	scanf("%d%d%d",&n,&x,&y);
	l=1<<n;
	dfs(1,1,l,l,x,y);
	for(int i=1;i<=l;i++){
		for(int j=1;j<=l;j++)
		if(ans[i][j]){
			if(!k[ans[i][j]])
				k[ans[i][j]]=++prt;
			printf("%d ",k[ans[i][j]]);
		}else printf("0 ");
		puts("");
	}
	return 0;
}
```

---

## 作者：cat_yyy (赞：6)

#一波暴力重编码

```cpp
#include<cstdio>
using namespace std;
#define MAXN 1050

int map[MAXN][MAXN];

bool visit[MAXN][MAXN];

int n,dx,dy;

int s=1;

int flag=0;

int cnt=1,cc=0;

//deep dark fantasy 原版分治 
//cc为原始编码序号 
void ddf(int a,int b,int c,int d,int e){
    if(c==1) return;
    c/=2;
    if(d<a+c&&e<b+c)//特殊点在左上角 
    {
        ddf(a,b,c,d,e);
        ddf(a,b+c,c,a+c-1,b+c);
        ddf(a+c,b,c,a+c,b+c-1);
        ddf(a+c,b+c,c,a+c,b+c);
        //分治 
        cc++;
        map[a+c][b+c]=cc;
        map[a+c][b+c-1]=cc;
        map[a+c-1][b+c]=cc;
        //添加一个L 
    }
    if(d<a+c&&e>=b+c)//特殊点在右上角 
    {
        ddf(a,b,c,a+c-1,b+c-1);
        ddf(a,b+c,c,d,e);

        ddf(a+c,b,c,a+c,b+c-1);
        ddf(a+c,b+c,c,a+c,b+c);

        cc++;
        map[a+c][b+c]=cc;
        map[a+c][b+c-1]=cc;
        map[a+c-1][b+c-1]=cc;
    }
    if(d>=a+c&&e<b+c)//特殊点在左下角 
    {
        ddf(a,b,c,a+c-1,b+c-1);
        ddf(a,b+c,c,a+c-1,b+c);    

        ddf(a+c,b,c,d,e);
        ddf(a+c,b+c,c,a+c,b+c);

        cc++;
        map[a+c-1][b+c-1]=cc;
        map[a+c-1][b+c]=cc;
        map[a+c][b+c]=cc;
    }
    if(d>=a+c&&e>=b+c)//特殊点在右下角  
    {
        ddf(a,b,c,a+c-1,b+c-1);
        ddf(a,b+c,c,a+c-1,b+c);

        ddf(a+c,b,c,a+c,b+c-1);
        ddf(a+c,b+c,c,d,e);

        cc++;
        map[a+c-1][b+c-1]=cc;
        map[a+c][b+c-1]=cc;
        map[a+c-1][b+c]=cc;
    }
}
//BFS暴力重编码 
void dnum(int x,int y){
    map[x][y]=cnt;
    visit[x][y]=1;
    if(!visit[x+1][y]&&map[x+1][y]==flag) dnum(x+1,y);
    if(!visit[x-1][y]&&map[x-1][y]==flag) dnum(x-1,y);
    if(!visit[x][y+1]&&map[x][y+1]==flag) dnum(x,y+1);
    if(!visit[x][y-1]&&map[x][y-1]==flag) dnum(x,y-1);
}

int main(){
    scanf("%d%d%d",&n,&dx,&dy);
    while(n){
        s*=2;
        n--;
    }//s=2^k
    
    ddf(1,1,s,dx,dy);//分治 
    
    visit[dx][dy]=1;
    for(int i=1;i<=s;i++){
        for(int j=1;j<=s;j++){
            if(visit[i][j]){
                printf("%d ",map[i][j]);
                continue;
            }
            flag=map[i][j];
            dnum(i,j);
            cnt++;
            printf("%d ",map[i][j]);
        }
        putchar('\n');
    }//BFS暴力重编码并输出 
    
    return 0;
}
```

---

## 作者：Tjaweiof (赞：5)

# P1911 题解——Tjaweiof
[题目传送门](https://www.luogu.com.cn/problem/P1911)

看到这题，我们不免想到一条定理：$2^{2^n}-1$ 一定能被 $3$ 整除。证明方法：$\because2^{2^n}=4^n$，$\therefore4\equiv1(\bmod\ 3)$，$\therefore4^n\equiv1^n(\bmod\ 3)$。

思路：每次将边长二分，分成四个部分，其中有一部分中有一个方块已经被用了，那么我们用 L 形军营把每个部分都用掉一个方块，示例（`*` 表示指挥营）：
```
0 0 * 0
0 0 0 0
0 0 0 0
0 0 0 0
```
变成：
```
0 0 * 0
0 1 0 0
0 1 1 0
0 0 0 0
```
然后分成四个部分：
```
0 0
0 1
```
```
* 0
0 0
```
```
0 1
0 0
```
```
1 0
0 0
```
分别改成：
```
2 2
2 1
```
```
* 3
3 3
```
```
4 1
4 4
```
```
1 5
5 5
```
最后是（把 `*` 改回 `0`）：
```
2 2 0 3
2 1 3 3
4 1 1 5
4 4 5 5
```
## Code
```cpp
#include <bits/stdc++.h>
long long Matrix[1025][1025], size, r, c, row, col, cnt = 1;
bool flag[1025][1025];
void chessBoard(int tr, int tc, int dr, int dc, int size){
    int s;
    if (1 == size) return;
    s = size / 2;
    if (dr < tr + s && dc < tc + s){
        Matrix[tr + s - 1][tc + s] = 3;
        Matrix[tr + s][tc + s - 1] = 3;
        Matrix[tr + s][tc + s] = 3;
        chessBoard(tr,tc,dr,dc,s);
        chessBoard(tr, tc + s, tr + s - 1, tc + s,s);
        chessBoard(tr + s, tc, tr + s, tc + s - 1,s);
        chessBoard(tr + s, tc + s, tr + s, tc + s,s);
    } else if (dr < tr + s && dc >= tc + s){
        Matrix[tr + s][tc + s - 1] = 1;
        Matrix[tr + s - 1][tc + s - 1] = 1;
        Matrix[tr + s][tc + s] = 1;
        chessBoard(tr,tc,tr+s-1,tc+s-1,s);
        chessBoard(tr, tc + s, dr,dc,s);
        chessBoard(tr + s, tc, tr+s,tc + s - 1,s);
        chessBoard(tr + s, tc + s, tr + s, tc + s, s);
    } else if (dr >= tr + s && dc < tc + s){
        Matrix[tr + s - 1][tc + s - 1] = 4;
        Matrix[tr + s - 1][tc + s] = 4;
        Matrix[tr + s][tc + s] = 4;
        chessBoard(tr,tc,tr+s-1,tc+s-1,s);
        chessBoard(tr, tc + s, tr + s - 1, tc + s, s);
        chessBoard(tr + s, tc, dr,dc,s);
        chessBoard(tr + s, tc + s, tr + s, tc + s, s);
    } else if (dr >= tr + s && dc >= tc + s){
        Matrix[tr + s][tc + s - 1] = 2;
        Matrix[tr + s - 1][tc + s] = 2;
        Matrix[tr + s - 1][tc + s - 1] = 2;
        chessBoard(tr, tc, tr + s - 1, tc + s - 1, s);
        chessBoard(tr, tc + s, tr + s - 1, tc + s, s);
        chessBoard(tr + s, tc, tr + s, tc + s - 1, s);
        chessBoard(tr + s, tc + s, dr, dc, s);
    }
}

int main(){
    memset(Matrix,0,sizeof(Matrix));
    scanf("%d%d%d", &size, &row, &col);
    row--;
    col--;
    long long S = 1;
    for (int i = 0; i < size; i++){
        S *= 2;
    }
    chessBoard(0,0,row,col,S);
    for (r = 0; r < S; r++){
        for (c = 0; c < S; c++){
            if (flag[r][c] == false){
                if (Matrix[r][c] == 1){
                    Matrix[r][c] = cnt;
                    Matrix[r+1][c] = cnt;
                    Matrix[r+1][c+1] = cnt++;
                    flag[r][c] = true;
                    flag[r+1][c] = true;
                    flag[r+1][c+1] = true;
                } else if (Matrix[r][c] == 2){
                    Matrix[r][c] = cnt;
                    Matrix[r+1][c] = cnt;
                    Matrix[r][c+1] = cnt++;
                    flag[r][c] = true;
                    flag[r+1][c] = true;
                    flag[r][c+1] = true;
                } else if (Matrix[r][c] == 3){
                    Matrix[r][c] = cnt;
                    Matrix[r+1][c] = cnt;
                    Matrix[r+1][c-1] = cnt++;
                    flag[r][c] = true;
                    flag[r+1][c] = true;
                    flag[r+1][c-1] = true;
                } else if (Matrix[r][c] == 4){
                    Matrix[r][c] = cnt;
                    Matrix[r+1][c+1] = cnt;
                    Matrix[r][c+1] = cnt++;
                    flag[r][c] = true;
                    flag[r+1][c+1] = true;
                    flag[r][c+1] = true;
                }
            }
        }
    }
    for (r = 0; r < S; r++){
        for (c = 0; c < S; c++){
            printf("%d ", Matrix[r][c]);
        }
        printf("\n");
    }
    return 0;
}

```


---

## 作者：ningago (赞：2)

## P1911 婴儿题解
>人类本来就不擅长非线性的东西，却还要套个分治……

（自认为比其他题解思维难度低）

对每个 $4 \times 4$ 的方格进行研究：

- 有指挥部

|||||
|-|-|-|-|
|?|?|?|$0$|
|?|?|?|?|
|?|?|?|?|
|?|?|?|?|

可以看出，$0$ 所在的 $2 \times 2$ 方格可以用一个 L 形 填满，而其他的方格可以按如下方式填满：

|||||
|-|-|-|-|
|2|2|1|0|
|2|3|1|1|
|4|3|3|5|
|4|4|5|5|

- 无指挥部

可以发现，如果仅填满 $4\times4$ 方格，是没有任何方案的，所以我们考虑一下指挥部所在的 $8\times 8$ 方格：

|||||||||
|-|-|-|-|-|-|-|-|
|2|2|1|0|?|?|?|?|
|2|3|1|1|?|?|?|?|
|4|3|3|5|?|?|?|?|
|4|4|5|5|#|?|?|?|
|?|?|?|#|#|?|?|?|
|?|?|?|?|?|?|?|?|
|?|?|?|?|?|?|?|?|
|?|?|?|?|?|?|?|?|

此时，可以发现，剩下了 $3$ 个 $4 \times 4$ 方格，而图中 # 方格，正好可以放一个 L 形。

此时再考虑其他 $3$ 个 $4 \times 4$ 方格，# 方格就成了一个“假指挥部”，然后就可以正常填充了。

其中，我们还知道了一个重要信息：$8\times 8$ 的有指挥部方格可以正常填充。

- $2^x \times 2^x$ 方格

再考虑有指挥部的 $16 \times 16$ 的方格，按上面的方法可以设置三个“假指挥部”，填充好整个方格。

由此可以得知：每个有指挥部 $2^x \times 2^x$ 的方格可以用上述方法填充。

而求解的就是一个 $2^n \times 2^n$ 的方格，因此可以分治成 $2^{\frac{n}{2}} \times 2^{\frac{n}{2}}$ 的方格求解，再分治，直至 $2 \times 2$ 的方格，然后用上述方法合并。

Code：
```cpp
#include <cstdio>

#define N 1030
#define S 350000

int n,x0,y0;
int a[N][N],b[N][N],idx;
int num[S];

void dfs(int x1,int y1,int x2,int y2,int x,int y)
{
    int len = (x2 - x1 + 1) >> 1;
    //x1到中间点长度
    if(len == 1)//2 * 2方格
    {
        idx++;
        for(int i = 0;i <= 1;i++)
            for(int j = 0;j <= 1;j++)
                if(!a[x1 + i][y1 + j])
                {
                    a[x1 + i][y1 + j] = idx;
                }
        return;
    }
    int xmid = x1 + len - 1,ymid = y1 + len - 1;
    if(x1 <= x && x <= xmid && y1 <= y && y <= ymid)
    {//“指挥部”在左上角
        idx++;
        a[xmid + 1][ymid] = a[xmid][ymid + 1] = a[xmid + 1][ymid + 1] = idx;
        dfs(x1,y1,xmid,ymid,x,y);
        dfs(x1,ymid + 1,xmid,y2,xmid,ymid + 1);
        dfs(xmid + 1,y1,x2,ymid,xmid + 1,ymid);
        dfs(xmid + 1,ymid + 1,x2,y2,xmid + 1,ymid + 1);
    }
    else if(x1 <= x && x <= xmid && ymid + 1 <= y && y <= y2)
    {//左下角
        idx++;
        a[xmid][ymid] = a[xmid + 1][ymid] = a[xmid + 1][ymid + 1] = idx;
        dfs(x1,y1,xmid,ymid,xmid,ymid);
        dfs(x1,ymid + 1,xmid,y2,x,y);
        dfs(xmid + 1,y1,x2,ymid,xmid + 1,ymid);
        dfs(xmid + 1,ymid + 1,x2,y2,xmid + 1,ymid + 1);
    }
    else if(xmid + 1 <= x && x <= x2 && y1 <= y && y <= ymid)
    {右上角
        idx++;
        a[xmid][ymid] = a[xmid][ymid + 1] = a[xmid + 1][ymid + 1] = idx;
        dfs(x1,y1,xmid,ymid,xmid,ymid);
        dfs(x1,ymid + 1,xmid,y2,xmid,ymid + 1);
        dfs(xmid + 1,y1,x2,ymid,x,y);
        dfs(xmid + 1,ymid + 1,x2,y2,xmid + 1,ymid + 1);
    }
    else if(xmid + 1 <= x && x <= x2 && ymid + 1 <= y && y <= y2)
    {右下角
        idx++;
        a[xmid + 1][ymid] = a[xmid][ymid + 1] = a[xmid][ymid] = idx;
        dfs(x1,y1,xmid,ymid,xmid,ymid);
        dfs(x1,ymid + 1,xmid,y2,xmid,ymid + 1);
        dfs(xmid + 1,y1,x2,ymid,xmid + 1,ymid);
        dfs(xmid + 1,ymid + 1,x2,y2,x,y);
    }
}

int main()
{
    scanf("%d%d%d",&n,&x0,&y0);
    n = 1 << n;
    a[x0][y0] = -1; 
    dfs(1,1,n,n,x0,y0);
    idx = 0;
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= n;j++)
        {
            if(i == x0 && j == y0)
            {
                b[i][j] = 0;
                continue;
            }//按顺序重新编排数值
            if(!num[a[i][j]])
                num[a[i][j]] = ++idx;
            b[i][j] = num[a[i][j]];
        }
    }
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= n;j++)
            printf("%d ",b[i][j]);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：wjk2020 (赞：2)

窝用的方法很奇特：

我用了一种递归的想法，

将大正方形四分。此时有两个形式：

1.每一份都是 $1*1$ 的小格

将除了指挥营（或已标记过的点）的另外三个点连起来,组成一个 $"L"$ 。

2.每一份都是 $m*m$ 个小格，此时有两种正方形

第一种正方形有指挥营，第二种正方形没有指挥营。这时需要用dfs。

有指挥营的正方形直接四分即可。

无指挥营的正方形三块各舍去一个角，变成有指挥营的正方形。舍去的角组成一个  $"L"$ 。

```cpp
#include<bits/stdc++.h>
using  namespace  std;

int a[1100][1100];

int valus;

int box[1000000];

void q_split(int x1,int y1,int x2,int y2,int x,int y)
{//四分函数
	if (x2-x1 == 1 && y2-y1 == 1)
	{
		valus++;
		int tmp = valus;
		
		for (int i = x1; i <= x2; i++)
		{
			for (int j = y1; j <= y2; j++)
			{
				if (a[i][j] == 0)
					a[i][j] = tmp;
			}
		}
		return;
	}
	else
	{	
		valus++;
		
		int q_value = valus;
		
		// q-1
		if (x >= x1 && x <=  (x1+x2)/2 && y >= y1 && y <= (y1+y2)/2)
		{
			//a[(x1+x2)/2  ][(y1+y2)/2  ] = 0;
			q_split(x1      	,y1 		,(x1+x2)/2	,(y1+y2)/2	,x, y);
			
		}
		else
		{
			a[(x1+x2)/2  ][(y1+y2)/2  ] = q_value;
			q_split(x1      	,y1 		,(x1+x2)/2	,(y1+y2)/2	,(x1+x2)/2, (y1+y2)/2);
		}
			
		// q-2
		if (x >= (x1+x2)/2 + 1 && x <=  x2 && y >= y1 && y <= (y1+y2)/2)
		{
			//a[(x1+x2)/2+1][(y1+y2)/2  ] = 0;
			q_split((x1+x2)/2+1	,y1     	,x2			,(y1+y2)/2	,x, y);

		}
		else
		{
			a[(x1+x2)/2+1][(y1+y2)/2  ] = q_value;
			q_split((x1+x2)/2+1	,y1     	,x2			,(y1+y2)/2	,(x1+x2)/2+1, (y1+y2)/2 );
		}
			
		// q-3
		if (x >= (x1+x2)/2 + 1 && x <=  x2 && y >= (y1+y2)/2 + 1 && y <= y2)
		{
			//a[(x1+x2)/2+1][(y1+y2)/2+1] = 0;
			q_split((x1+x2)/2+1	,(y1+y2)/2+1,x2			,y2			,x, y);
		}
		else
		{
			a[(x1+x2)/2+1][(y1+y2)/2+1] = q_value;
			q_split((x1+x2)/2+1	,(y1+y2)/2+1,x2			,y2			,(x1+x2)/2+1, (y1+y2)/2+1);
		}
			
		// q-4
		if (x >= x1 && x <=  (x1+x2)/2  && y >= (y1+y2)/2 + 1 && y <= y2)
		{
			//a[(x1+x2)/2  ][(y1+y2)/2+1] = 0;
			q_split(x1			,(y1+y2)/2+1,(x1+x2)/2	,y2			,x, y);
		}
		else
		{
			a[(x1+x2)/2  ][(y1+y2)/2+1] = q_value;
			q_split(x1			,(y1+y2)/2+1,(x1+x2)/2	,y2			,(x1+x2)/2, (y1+y2)/2+1);
		}
	}
	return;
}

int main()//主函数
{
	int n;
	int x, y;

	cin >> n;
	cin >> x;
	cin >> y;
	
	int end = pow(2,n);

	q_split (1, 1, end, end, x, y);
	
	a[x][y] = 0;
	
	int index = 1;
	for (int i = 1; i <= end; i++)
		for (int j = 1; j <= end; j++)
			if (a[i][j] !=	0 && box[a[i][j]] == 0)
			{
				box[a[i][j]] = index;
				index++;
			}

	for (int i = 1; i <= end; i++)
		for (int j = 1; j <= end; j++)
			a[i][j] = box[a[i][j]];

	
	for (int i = 1; i <= end; i++)
	{
		for (int j = 1; j <= end; j++)
			cout << a[i][j] << " ";
		cout << endl;
	}

	return 0;
}
```
本篇题解均由本人所写，如有雷同，纯属巧合。
~~求过~~

---

## 作者：wanglichao1121 (赞：2)

题目看起来很难，

其实看了思路你就懂了。


正如标签写的，这是一道分治题目，怎么递归呢？

先假设输入是3 1 2

\*#******

********

********

********

********

********

********

********

首先，把待处理区域分成4块

\*#**  ****

****  ****

****  ****

****  ****


****  ****

****  ****

****  ****

****  ****

然后把没有特殊格的块最靠近中央的变成特殊格，并且分成一块

\*#**  ****

****  ****

****  ****

****  #***


***#  #***

****  ****

****  ****

****  ****

递归每一块

（边界：边长是2的除特殊格外都连成一块）

然后按顺序扫一遍，把编号按顺序排就行了。

标程如下：

```delphi

var n,x,y,s,i,j,k,p:longint;a:array[1..1025,1..1025]of longint;
procedure find(x1,y1,r,x2,y2:longint);  
//分治过程，x1,y1表示待处理区域的左上角，r表示大小，x2,y2表示特殊格
var mx,my:longint;
begin
  if(r=2)then
  begin
  inc(k);
  for i:=x1 to x1+1 do
  for j:=y1 to y1+1 do
  if(i<>x2)or(j<>y2)then a[i,j]:=k;
  exit;
  end;
  r:=r div 2;    //分治后小区域大小
  mx:=r+x1-1;    
  my:=r+y1-1;    //mx my表示中央点位置
  inc(k);
  a[mx,my]:=k;a[mx,my+1]:=k;a[mx+1,my]:=k;a[mx+1,my+1]:=k;
  if not((x2<=mx)and(y2<=my))then find(x1,y1,r,mx,my)
  else
  begin
  a[mx,my]:=0;    find(x1,y1,r,x2,y2);
  end;
  if not((x2>mx)and(y2<=my))then find(mx+1,y1,r,mx+1,my)
  else
  begin
  a[mx+1,my]:=0;    find(mx+1,y1,r,x2,y2);
  end;
  if not((x2>mx)and(y2>my))then find(mx+1,my+1,r,mx+1,my+1)
  else
  begin
  a[mx+1,my+1]:=0;   find(mx+1,my+1,r,x2,y2);
  end;
  if not((x2<=mx)and(y2>my))then find(x1,my+1,r,mx,my+1)
  else
  begin
  a[mx,my+1]:=0;        find(x1,my+1,r,x2,y2);
  end;
end;
begin
  readln(n,x,y);
  s:=1;
  for i:=1 to n do
  s:=s*2;
  k:=sqr(s)div 3;p:=k;a[x,y]:=0;
  find(1,1,s,x,y);
  k:=0;
  for i:=1 to s do  //广搜给顺序（兼输出）
  begin
  for j:=1 to s do
  begin
  if a[i,j]>p then
  begin
  inc(k);
  if(i>1)then
  begin
  if(j>1)then if a[i-1,j-1]=a[i,j] then a[i-1,j-1]:=k;
  if a[i-1,j]=a[i,j] then a[i-1,j]:=k;
  if a[i-1,j+1]=a[i,j] then a[i-1,j+1]:=k;
  end;
  if j>1 then
  if a[i,j-1]=a[i,j] then a[i,j-1]:=k;
  if a[i,j+1]=a[i,j] then a[i,j+1]:=k;
  if j>1 then
  if a[i+1,j-1]=a[i,j] then a[i+1,j-1]:=k;
  if a[i+1,j]=a[i,j] then a[i+1,j]:=k;
  if a[i+1,j+1]=a[i,j] then a[i+1,j+1]:=k;
  a[i,j]:=k;
  end;
  write(a[i,j],' ');
  end;
  writeln;
  end;
end.

```

---

## 作者：drop (赞：1)

## 思路

### 第一步：分成若干个 L

对于每个 $2\times2$ 的小矩阵，可能的填充方法有：

![](https://cdn.luogu.com.cn/upload/image_hosting/mccm1u2n.png)


由此证明：每个小部分有一个指挥部就可以用 `L` 填满。

假设一组数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/xxhh6i9r.png)

在此数据 $(1,1)$ 到 $(4,4)$ 的位置上有一个指挥部，那么在 $(1,5)$ - $(4,8)$、$(5,1)$ - $(8,4)$、$(1,5)$ - $(4,8)$上也必须有一个指挥部，那么可以让一个 `L` 来成为这三部分的“伪指挥部”（如下图），使其也成为合法的。

![](https://cdn.luogu.com.cn/upload/image_hosting/knz04oxv.png)

同理，所有的部分都可以用 `L` 来填满或用其来成为“伪指挥部”，那么，这个数据最终的样子是：

![](https://cdn.luogu.com.cn/upload/image_hosting/dtns9aej.png)

第一部分就完成了。

### 第二部分：输出

这个数组已经有数了，但顺序是错的，那么可以暴力枚举每一个数，那么就有两种情况：

1. 这个数遇到过
2. 这个数没有遇到过

对于第一种情况，直接输出对应的数。

对于第二种情况，可以用一个 color 来记录。

也就是：

```cpp
int color=0,vis[N]={0};
for(int i=1;i<=len;i++){
    for(int j=1;j<=len;j++){
        if(a[i][j]==0){
            cout<<"0 ";
            continue;
        }
        if(vis[a[i][j]]==0) vis[a[i][j]]=++color;
        cout<<vis[a[i][j]]<<" ";
    }
    cout<<endl;
}
```

到此，整个题就完成了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int c[2010][2010],g[400010],len,color;
// c是记录下来的表格，g是记录c每一项对应输出的数，len是长度，color是记录L的数量 
// ul=up_left ur=up_right dl=down_left dr=down_right 
#define cul c[x+l-1][y+l-1]=color
#define cur c[x+l][y+l-1]=color
#define cdl c[x+l-1][y+l]=color
#define cdr c[x+l][y+l]=color
#define dul dfs(x+l-1,y+l-1,x,y,l)
#define dur dfs(x+l,y+l-1,x+l,y,l)
#define ddl dfs(x+l-1,y+l,x,y+l,l)
#define ddr dfs(x+l,y+l,x+l,y+l,l)

void output(){
    color=0;
    for(int i=1;i<=len;i++){
        for(int j=1;j<=len;j++){
            if(c[i][j]==0){ //这个点是指挥部 
                cout<<"0 "; //不用更新，直接输出 
                continue;
            }
            if(g[c[i][j]]==0) g[c[i][j]]=++color; //第一种情况 
            cout<<g[c[i][j]]<<" "; //输出 
        }
        cout<<endl;
    }
}

void dfs(int a,int b,int x,int y,int l){
    // ab是指挥部的位置，xy是要判断的右上角，l是要判断的长度 
    if(l==1) return;
    l>>=1; //相当于 l/=2; 
    if(a<l+x&&b<l+y){       //指挥部在左上角 
        color++;
        cur;cdl;cdr;        //更新c数组 
        dfs(a,b,x,y,l);     //递归这个区间 
        dur;ddl;ddr;        //递归别点区间 
    }
    if(a>=l+x&&b<l+y){      //指挥部在右上角 
        color++;
        cul;cdl;cdr;        //更新c数组
        dfs(a,b,x+l,y,l);   //递归这个区间 
        dul;ddl;ddr;        //递归别点区间 
    }
    if(a<l+x&&b>=l+y){      //指挥部在左下角 
        color++;
        cul;cur;cdr;        //更新c数组
        dfs(a,b,x,y+l,l);   //递归这个区间 
        dul;dur;ddr;        //递归别点区间 
    }
    if(a>=l+x&&b>=l+y){     //指挥部在右下角 
        color++;
        cul;cur;cdl;        //更新c数组
        dfs(a,b,x+l,y+l,l); //递归这个区间 
        dul;dur;ddl;        //递归别点区间 
    }
}

int main(){
    int x,y,n;
    cin>>n>>x>>y;
    len=1<<n;         //相当于2的n次方
    dfs(x,y,1,1,len); //递归调用 
    c[x][y]=0;        //指挥部为0 
    output();         //输出 
    return 0;
}
```

---


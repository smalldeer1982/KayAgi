# 出租车拼车

## 题目背景

话说小 x 有一次去参加比赛，虽然学校离比赛地点不太远，但小 x 还是想坐出租车去。大学城的出租车总是比较另类，有“拼车”一说，也就是说，你一个人坐车去，还是一堆人一起，总共需要支付的钱是一样的（每辆出租上除司机外最多坐下 $4$ 个人）。刚好那天同校的一群 OIer 在校门口扎堆了，大家果断决定拼车去赛场。

问题来了，一辆又一辆的出租车经过，但里面要么坐满了乘客，要么只剩下一两个座位，众 OIer 都觉得坐上去太亏了，小 x 也是这么想的。

## 题目描述

假设 $N$ 位 OIer 准备拼车，此时为 $0$ 时刻，从校门到目的地需要支付给出租车师傅 $D$ 元（按车次算，不管里面坐了多少 OIer），假如 $S$ 分钟后恰能赶上比赛，那么 $S$ 分钟后经过校门口的出租车自然可以忽略不计了。现在给出在这 $S$ 分钟当中经过校门的所有的 $K$ 辆出租车先后到达校门口的时间 $T_i$  及里面剩余的座位 $Z_i$
，OIer 可以选择上车几个人（不能超过），当然，也可以选择上 $0$ 个人，那就是不坐这辆车。

俗话说，时间就是金钱，这里小 x 把每个 OIer 在校门等待出租车的分钟数 等同于花了相同多的钱（例如小 x 等待了 $20$ 分钟，那相当于他额外花了 $20$ 元钱）。

在保证所有 OIer 都能在比赛开始前到达比赛地点的情况下，聪明的你能计算出他们最少需要花多少元钱么？

## 说明/提示

对于 $100\%$ 的数据，满足 $N,K,D,S \le 100$，$1 \le Z_i \le 4$，$1 \le T_i \le T_{i+1} \le S$。

## 样例 #1

### 输入

```
2 2 10 5
1 1
2 2
```

### 输出

```
14
```

# 题解

## 作者：DDOSvoid (赞：30)

竟然没人写题解

f[i][j]表示前i辆车走了j个OIer 状态转移方程也不难想 ~~其实很难~~

f[i][j]=min(f[i-1][j-k]+k\*t[i]+d,f[i][j])(1<=k<=min(j,z[i]))

附上代码

```cpp
#include<iostream>
#include<cstring>
#define maxn 101
using namespace std;
int n,k,d,s,f[maxn][maxn];
struct node{
    int t,z;
}a[maxn];
int main(){
    memset(f,10,sizeof(f));
    cin>>n>>k>>d>>s;
    for(int i=1;i<=n;i++)cin>>a[i].t>>a[i].z;
    f[0][0]=0;
    for(int i=1;i<=k;i++)
        for(int j=0;j<=n;j++){
            f[i][j]=f[i-1][j];
            for(int k=0;k<=min(j,a[i].z);k++)
                f[i][j]=min(f[i-1][j-k]+k*a[i].t+d,f[i][j]);
        }
    if(f[k][n]>=10000)cout<<"impossible";
    else cout<<f[k][n];
    return 0;
}
```

---

## 作者：Youngsc (赞：9)

[Youngsc](http://youngscc.github.io/)

跟楼下的状态~~不太一样~~，这样就用不着取min了。

定义$f[i][j]$为来了$i$辆车时还剩$j$个人的最小花费。

转移方程自然而然，如果当前车有$k$个空座位的话，$f[i][j]=min{f[i-1][j+z]+d+z*t} z∈[1,k]$ 数据很小，过这个~不费力~，最后的$f[m][0]$就是最终答案。

因为每次更新$f[i][j]$都只与$f[i-1][j+z]$有关，所以我们可以将第一维滚动掉，当然这么弱的数据不滚也没什么关系。

## 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <queue>
# include <cmath>
# define R register
# define LL long long

using namespace std;

int n,k,d,s,z,t,f[110];

inline void in(R int &a){
    R char c = getchar();R int x=0,f=1;
    while(!isdigit(c)){if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x = (x<<1)+(x<<3)+c-'0',c = getchar();
    a = x*f;
}

inline void maxx(R int &a,const int b){a>b? 0:a=b;}
inline void minn(R int &a,const int b){a<b? 0:a=b;}

inline int yg(){
    in(n),in(k),in(d),in(s);
    for(R int i=0; i<=k; ++i)
        for(R int j=0; j<=n; ++j)
            f[j] = 20000000;//初始化
    f[n] = 0;//当前剩余n人花费0，而剩余其他数量的人显然不可能，所以赋一个极大值。
    for(R int i=1; i<=k; ++i)
    {
        in(t),in(z);
        for(R int j=0; j<=n; ++j)
            for(R int l=0; l<=z; ++l)
                minn(f[j],f[j+l]+(bool)l*d+l*t);//bool型可以保证当有人坐车时始终增加的是一份的钱，没人坐着的时候就不增加钱。
    }
    if(f[0] == 20000000) printf("impossible");
    else printf("%d",f[0]);
    return 0;
}

int youngsc = yg();
int main(){;}
```
（减少代码复制，共创美好洛谷）


---

## 作者：JiaY19 (赞：6)

为什么都没人打滚动数组。

来一发滚动数组的题解

### 思路

看到这道题，蒟蒻的第一反应就是动规。

先考虑构造二维数组，$f_{i,j}$ 代表前 $i$ 辆车送走了 $j$ 个OIer。

这个时候的转移方程应该是：

$$f_{i,j}~=~min(f_{i,j}~,~f_{i-1,j-k} + k \times t_i + d);$$

发现好像我们不关心是不是前 $i$ 辆车送走了 $j$ 个OIer。

我们关心的只有送走 $j$ 个OIer所花费的钱。

所以，一个省掉一维的滚动数组就出现了。

$$f_i~=~min(f_i~,~f_{i-k} + k \times t_i)$$

其中，$f_i$ 代表送走 $i$ 个人，所需的最少钱数。

$k$ 代表这一辆车送走的人数。

其余细节见代码。

------------


## Code
```c
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n , k , d , s , sum , t[1005] , z[1005] , f[1005];   //f[i]代表送走i个人，所需的最少钱数 

int read()                                        //快读 
{
	long long X = 0 , w = 1;
	char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
		w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
		X = X * 10 + c - '0' , c = getchar();
	return X * w;
}

signed main()
{
	n = read() , k = read() , d = read() , s = read();
	for(int i = 1;i <= k;i++) 
	{
		t[i] = read() , z[i] = read();
		if(t[i] <= s) sum += z[i];              //统计规定时间内，可以承载的人数 
	}
	if(sum <= n)                                    //承载的人数比总人数小，直接输出 
	{
		cout << "impossible";
		return 0;
	}
	memset(f , 0x7f , sizeof(f));
	f[0] = 0;					//初始化 
	for(int i = 1;i <= k;i++)				
	{
		if(t[i] > s) break;			//不在范围内，退出循环 
		for(int j = n;j >= 1;j--)
		{
			for(int l = 1;l <= min(z[i] , j);l++)
                f[j] = min(f[j - l] + l * t[i] + d , f[j]);     //核心代码 
		}
	}
	cout << f[n];
	return 0;
}

```

---

## 作者：zymooll (赞：5)

链接：[题目](https://www.luogu.com.cn/problem/P1977)

根据题目，该题可以简化成：

$n$ 个人选 $k$ 辆车坐，代价为 $d+w * v$  (其中 $d$ 代表“拼车”的价格， $w$ 代表坐这个车的座位数，$v$ 代表这个车 到达的时间)，求当剩余人数等于 $0$ 时，需要的最少价格。

所以可以推出动态转移方程： ```dp[j]=min(dp[j],dp[j+k]+d+k*v[i])``` ，边界条件为 ```dp[n]=0``` 。

其中：
 - ```dp[n]``` 表示当 $n$ 人时的最小花费
 - ```i```，```j```，```k```分别枚举车、当前人数和坐多少位子
 - ```d``` 表示 ~~衬衫~~ “拼车”的价格
 - ```v[i]``` 表示车到达的时间

接上来上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,d,s;
int v[110],w[110],dp[110];
int main(){
    memset(dp,0x7f,sizeof(dp));//设定初始值为正无穷
    cin>>n>>k>>d>>s;
    dp[n]=0;//确定边界条件，当为n人时，最小花费为0
    for(int i=0;i<k;i++){
    	cin>>v[i]>>w[i];
    }
    for(int i=0;i<k;i++){//枚举每辆车
        for(int j=0;j<=n;j++){//枚举当前有n人
            for(int k=1;k<=w[i];k++){//枚举座位
                dp[j]=min(dp[j],dp[j+k]+d+k*v[i]);//动态转移方程
            }
        }
    }
    if(dp[0]>2e9)cout<<"impossible";//若仍为正无穷，则认为不可能
    else cout<<dp[0];
    return 0;
}
```

---

## 作者：Awdrgysxc (赞：3)

DP
## 【分析】
可以理解为是线性DP,也可以理解为是一个 装满的背包（满的背包只更新有解的值），我们把它理解成满的背包（不满的背包所有都更新的到，满的不一样）

方程：
```cpp
dp[i][j] = min(dp[i][j],dp[i - 1][j - k] + k * Ti[i] + D);

```
dp[i][j] 表示前i两车载j个人的最优解；注意：dp初始值为一个很大的数，最后再判断一下是否能达到；

既然可以理解为是背包，我们考虑能否滚动;
```cpp
不难发现dp[i][j] 只与dp[i - 1][j - k]有关，这就可以滚动了
```

## 【Code 1】(没滚动)
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#define re register
#define min(x,y)(x<y?x:y)

using namespace std;

typedef long long ll;
inline int read() {
    re int ret=0;re bool flag=0;re char c=getchar();
    while((c<'0')|(c>'9')) flag^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9'))ret=(ret<<3)+(ret<<1)+(c^'0'),c=getchar();
    return flag?-ret:ret;
}

inline void Put(char *s) { puts(s); }
inline void Put(char c) { Put(&c); }
inline void Put(ll x) { char c[21]={0}; sprintf(c,"%lld",x); Put(c); }
inline void Put(int x) { Put(x|0ll); }

const int M = 101;
int n,dp[M][M],Ti[M],T,z[M],D,S,K;

inline void init()
{
    n = read(),K = read(),D = read(),S = read();
    for(re int i = 1;i <= K; i++) Ti[i] = read(),z[i] = read();
}

inline void solve()
{
    memset(dp,127,sizeof(dp));
    
    dp[0][0] = 0;
    for(re int i = 1;i <= K; i++)
    {
        for(re int j = 0;j <= n; j++)
        {
            dp[i][j] = dp[i - 1][j];
            //如果不滚动，这里一定要先赋值
            for(re int k = 0;k <= min(j,z[i]); k++)
            {
                dp[i][j] = min(dp[i][j],dp[i - 1][j - k] + k * Ti[i] + D);
            }
        }
    }
    if(dp[K][n] >= 1234532)
        puts("impossible");
    //这里不是很严谨
    else Put(dp[K][n]);
}

int main(void)
{
    init();
    
    solve();
    return 0;
}
```

## 【Code 2】（滚动）
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#define re register
#define min(x,y)(x<y?x:y)

using namespace std;

typedef long long ll;
inline int read() {
    re int ret=0;re bool flag=0;re char c=getchar();
    while((c<'0')|(c>'9')) flag^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9'))ret=(ret<<3)+(ret<<1)+(c^'0'),c=getchar();
    return flag?-ret:ret;
}

inline void Put(char *s) { puts(s); }
inline void Put(char c) { Put(&c); }
inline void Put(ll x) { char c[21]={0}; sprintf(c,"%lld",x); Put(c); }
inline void Put(int x) { Put(x|0ll); }

const int M = 101;
int n,dp[M],Ti[M],T,z[M],D,S,K;

inline void init()
{
    n = read(),K = read(),D = read(),S = read();
    for(re int i = 1;i <= K; i++) Ti[i] = read(),z[i] = read();
}

inline void solve()
{
    memset(dp,127,sizeof(dp));
    
    dp[0] = 0;
    for(re int i = 1;i <= K; i++)
    {
    	//如果要滚动，这里一定要逆序（j）
        for(re int j = n;j >= 0; j--)
        {
            for(re int k = 0;k <= min(j,z[i]); k++)
            {
                dp[j] = min(dp[j],dp[j - k] + k * Ti[i] + D);
            }
        }
    }
    if(dp[n] >= 123452) puts("impossible");
    //这里也不是很严谨
    else Put(dp[n]);
}

int main(void)
{
    init();
    
    solve();
    return 0;
}
```

---


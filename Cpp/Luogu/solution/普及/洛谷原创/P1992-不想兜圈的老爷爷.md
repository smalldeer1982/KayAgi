# 不想兜圈的老爷爷

## 题目描述

一位年过古稀的老爷爷在乡间行走

而他不想兜圈子 因为那会使他昏沉

偶然路过小A发扬助人为乐优良传统 带上地图 想知道路况是否一定使他清醒

usqwedf补充：为了让欢乐赛充满欢乐 小A还想问你一些数学作业……


## 说明/提示

[数据范围]

对于70%的数据 1<=n<=100 1<=m<=1000 1<=k<=30

对于100%的数据 1<=n<=1000 1<=m<=10000 1<=k<=10^9

另外，基于欢乐赛性质，我们保证数据当中至少有 20% 答案为 No


## 样例 #1

### 输入

```
3 3 3
1 2
2 3
3 1```

### 输出

```
No
9
```

# 题解

## 作者：kkksc03 (赞：13)

模型基础：判断有向图是否有环（回路）

[算法分析]

搜索 <=70 分

拓扑 100分

显然：出图结点 < 图上结点 && 余下结点入度 > 零 即可判断为有环（回路）

时间复杂度：O(n^2)

[标程]



```cpp
Program usqwedf_bxdqdlyy;
var
 n,m,i,x,y,k,h,find,t,base:longint;
 g,in_to,p:array[0..1001] of longint;
 map:array[0..1001,0..1001] of longint;
begin
  readln(n,m,base);
  for i:=1 to m do begin
　　  readln(x,y);
    in_to[y]:=in_to[y]+1; g[x]:=g[x]+1; map[x,g[x]]:=y;
  end;
　 while True do begin
    h:=0;
    for i:=1 to n do begin 
　　　  if in_to[i]=0 then begin
　　　    in_to[i]:=-1;
　　　　  h:=h+1; p[h]:=i; 
　　    end;
    end;
    find:=find+h;
    if h=0 then break;
    if find=n then break;
    for i:=1 to h do
      for k:=1 to g[p[i]] do in_to[map[p[i],k]]:=in_to[map[p[i],k]]-1;
  end;
　 if find=n then begin
    writeln('Yes');
    base:=2; t:=1;
    while k>0 do begin
      if k and 1=1 then t:=t*base mod 9997;
      base:=base*base mod 9997;
      k:=k>>1;
　　 end;
    writeln(t);
  end
  else begin 
    writeln('No');
    writeln(base*base);
  end;
end.
kkksc03注：亦可使用tarjan缩点。
```

---

## 作者：a1a2a3a4a5 (赞：7)

## Dijkstra ~~奇葩~~做法：
 
 [题目传送门](https://www.luogu.com.cn/problem/P1992)

##  题解背景： 

我在刷图论时，总是先看一看是不是 Dijkstra 的题，导致我把这道题打出了非正解 AC 代码。

## 题意： 

老爷爷如果一直绕圈，他就不是清醒的。我们需要判断老爷爷走的路是不是环，所以这道题是一道判环问题。

##  思路： 

1. **当老爷爷糊涂时：**

	1. 想到 dijkstra 不能判负环，我将每个边都附上负权值。利用 Dijkstra 不能走负环的特性，我在极限时间看看 Dijkstra 是不是还在运行，如果程序还在运行，很大几率是老爷爷在绕圈。

	2. 为了让它在有负环的情况下一直运行，我把判断是否用过这个点的判断语句去掉了。

1. **当老爷爷清醒时：**

  	1. 在老爷爷清醒的时候，用快速幂可以解决求二的多少次方问题。
 
 ## 出现问题： 
 
 1.  如何判断运行时间？

- 答：内容太长，直接挂[某人博客](https://blog.csdn.net/archyli/article/details/55505079)。 

 2.  为什么第六个测试点没过？

- 答：我复制我原来的 Dijkstra 模板，默认从一号点出发。经过我严谨的思考，才发现老爷爷不一定走过一号点，也就是老爷爷走的所有地方有可能不包含一号点。导致 Dijkstra 模拟的老爷爷从一号点开始就没得走。解决方式就随便取某个输入的点，(我取的是输入的第一个点)。

## 代码：
```c
#include<bits/stdc++.h>
using namespace std;
long long s,n,m,p,cnt,f[10100],head[50100],dis[50100];
struct xxx{long long o1,o2,o3;} e[50100];
priority_queue<pair<long long,long long>,vector<pair<long long,long long> >,greater<pair<long long,long long> > > q;
long long add(long long o1,long long o2,long long o3)
{
		e[++cnt].o1=head[o1];
		e[cnt].o2=o2;
		e[cnt].o3=o3;
		head[o1]=cnt;
}
void dij()
{
		memset(dis,0x3f3f3f3f,sizeof(dis));
		long long t=clock();
		dis[s]=-1;
		q.push(make_pair(-1,s));
		while(!q.empty())
		{
			long long x=q.top().second;q.pop();
			for(long long i=head[x];i;i=e[i].o1)
			{
				long long v=e[i].o2;
				if(dis[v]>dis[x]+e[i].o3)
					dis[v]=dis[x]+e[i].o3,q.push(make_pair(dis[v],v));
			}
			if(clock()-t>=900) {puts("No");cout<<p*p;exit(0);}
		}
}
long long ksm(long long x,long long y)
{
		long long ans=1,bs=x;
		while(y>0)
		{
			if(y&1) ans*=bs,ans%=9997;
			bs*=bs,bs%=9997,y>>=1;
		}
		return ans;
}
int main()
{
		cin>>n>>m>>p;
		for(long long i=1,o1,o2;i<=m;i++)
		{
			cin>>o1>>o2,add(o1,o2,-1);
			if(!s) s=o1;
		}
		dij();
		puts("Yes");
		cout<<ksm(2,p)%9997;
		return 0;
}
```

~~歪解，慎用！~~

---

## 作者：CaiXY06 (赞：6)

$\because$老爷爷他不想兜圈子，也就是他不想回到原先经过的点

$\therefore$本题就是一个判环的过程

因此我们就可以直接暴力搜索，标记已经经过的点（算一个优化吧，不然会T飞）和路径上正在访问的点，如果又回到了正在访问的点，那就有环。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=9997;
struct edge{
	int to,next;
}e[10010];
int n,m,k,cnt,flag,head[1010],vis[1010],used[1010];
inline int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
inline void add(int u,int v){
	cnt++;
	e[cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
inline void dfs(int u){
	if(used[u]){
		flag=1;
		return;
	}
	if(vis[u])return;
	used[u]=vis[u]=1;
	for(int i=head[u];i;i=e[i].next)dfs(e[i].to);
	used[u]=0;
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1,x,y;i<=m;i++){
		scanf("%lld%lld",&x,&y);
		add(x,y);
	}
	for(int i=1;i<=n;i++){
		dfs(i);
		if(flag){
			printf("No\n%lld",k*k);
			return 0;
		}
	}
	printf("Yes\n%lld",ksm(2,k));
	return 0;
}
```



又$\because$给出的是有向图

$\therefore$用拓扑判环再好不过了

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=9997;
struct edge{
	int to,next;
}e[10010];
int n,m,k,cnt,flag,head[1010],in[1010];
inline int ksm(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
inline void add(int u,int v){
	cnt++;
	e[cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
inline void toposort(){
	queue<int>q;
	for(int i=1;i<=n;i++)if(!in[i])flag++,q.push(i);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			in[v]--;
			if(!in[v])flag++,q.push(v);
		}
	}
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1,x,y;i<=m;i++){
		scanf("%lld%lld",&x,&y);
		add(x,y);
		in[y]++;
	}
	toposort();
	if(flag<n)printf("No\n%lld",k*k);
	else printf("Yes\n%lld",ksm(2,k));
	return 0;
}
```   
   
   
最后使用快速幂计算答案，但有一个坑点就是

![](https://cdn.luogu.com.cn/upload/image_hosting/yiy0f758.png)

$k^{2}$不用$mod$啊啊啊，不然$100->90$

---

## 作者：Soul_Love (赞：5)

看到题解里都没有 SPFA，想着就来一篇。
## 思路
根据题意，我们有一张包含 $n$ 个点， $m$ 条边的有向图。我们需要判断是否有环，再判断是否用快速幂。

[这是快速幂](https://www.luogu.com.cn/problem/P1226)

但是!!!

根据SPFA的原理可知，我们只能用它来判有没有负环，所以我们建边时就得额外加一个边权，并且把它设为负的，以此来造出负环。

但是!!!

[还是有坑点](https://www.luogu.com.cn/discuss/475742)

这个图不保证联通，对每个连通图都跑一次 [SPFA（不会的可以先去看看）](https://www.luogu.com.cn/problem/solution/P3371)。
## 代码
```c
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define mode 9997
using namespace std;
queue<int> q;
int n,m,h[200100],x,y,l,dis[200100],vis[200100],c[200100],vis2[200100],k;
struct edge
{
	int v,w,next;
}e[800100];
inline int quick_pow(int x,int y)//快速幂模板 
{
	if(y==0) return 1;
	if(y==1) return x;
	int t=quick_pow(x,y>>1)%mode;
	if(y&1) return t*t%mode*x%mode;
	else return t*t%mode;
}
inline int read()
{
	int k=0,f=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) f|=c=='-';
	for(;isdigit(c);c=getchar()) k=(k<<1)+(k<<3)+(c^48);
	return f?-k:k;
}
inline void add(int x,int y,int z)
{
	e[++l].v=y;
	e[l].w=z;
	e[l].next=h[x];
	h[x]=l;
}
inline int spfa(int st)//SPFA模板 
{
	for(int i=1;i<=n;i++) dis[i]=inf;//初始化
	dis[st]=0;
	q.push(st);
   vis[st]=1;
   c[st]++;
	while(!q.empty())
	{
		int k=q.front();
		vis2[k]=1;//标记 
		q.pop();
		vis[k]=0;
		for(int i=h[k];i;i=e[i].next)
		{
			if(dis[e[i].v]>dis[k]+e[i].w)
			{
				dis[e[i].v]=dis[k]+e[i].w;
				if(!vis[e[i].v])
				{
					c[e[i].v]++;
					q.push(e[i].v);
					vis[e[i].v]=1;
					if(c[e[i].v]>n) return 1;
				}
			}
		}
	}
	return 0;
}
int main()
{
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++)
	{
		x=read(),y=read();
		add(x,y,-1);//边权为负，注意是单向边 
	}
	for(int i=1;i<=n;i++)
	{
		if(vis2[i]) continue;//对每个连通图都跑一次SPFA 
		if(spfa(i))//如果有环
		{
			printf("No\n%d",k*k);
			return 0;
		}
		memset(c,0,sizeof(c));//记得初始化
	}
	printf("Yes\n%d",quick_pow(2,k));
	return 0;
}
```


---

## 作者：bymlg001 (赞：1)

随机来的，花式虐题


1.尝试了一下dfs找环 可能写的不太好 才70

2.Tarjan 大材小用了，我看题解里没人写我就随便写了写 （毫无走心的盲打模板

3.然后就是拓扑 一看就是拓扑模板题，于是乎放在最后写的


ps：好久不写快速幂了一开始竟然错了 && 我偷了个懒 因为这个模数很小 其他程序不要用这个快速幂哦


以下是Tarjan代码

###


```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#define IL inline
#define fp(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
const int N=10005,MOD=9997;
int n,m,k,t1,t2,t;
bool cc=1;
int tot,head[N*5],next[N*5],to[N*5];
int dfn[N],low[N],timer;
stack<int> sta;
bool instack[N];
IL int ksm(int x,int y){
    int r=1,base=x;
    while(y){
        if(y&1) r=(base*r)%MOD;
        base=(base*base)%MOD;
        y>>=1;
    }
    return r;
}
void tarjan(int x){
    if(cc==0) return;
    dfn[x]=low[x]=++timer;
    sta.push(x);
    instack[x]=1;
    for(int i=head[x];i!=-1;i=next[i]){
        if(!dfn[to[i]]){
            tarjan(to[i]);
            low[x]=min(low[x],low[to[i]]);
        }
        else if(instack[to[i]]) low[x]=min(low[x],dfn[to[i]]);
    }
    if(dfn[x]==low[x]){
        if(sta.top()!=x){
            cc=0;
            return;
        }
        else{
            instack[sta.top()]=0;
            sta.pop();
        }
    }
}
IL int getint(){
    int data=0,w=1;char ch=0;
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch<='9'&&ch>='0') data=data*10+ch-'0',ch=getchar();
    return data*w;
}
IL void add(int x,int y){
    to[++tot]=y;
    next[tot]=head[x];
    head[x]=tot;    
}
int main(){
    n=getint();m=getint();k=getint();
    fill(head,head+N,-1);
    fp(i,1,m){
        t1=getint();t2=getint();
        add(t1,t2);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tarjan(i);
    }
    if(cc==0)     cout<<"No"<<endl<<k*k<<endl;
    else cout<<"Yes"<<endl<<ksm(2,k)<<endl;
    return 0;
}
```
以下是拓扑正解
###

```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<queue>
#define IL inline
using namespace std;
const int N=10005,MOD=9997;
int n,m,k,t1,t2,t,rd[N];
bool cc=1;
int tot,head[N*5],next[N*5],to[N*5];
int dfn[N],low[N],timer;
queue<int> q;
bool instack[N];
IL int ksm(int x,int y){
    int r=1,base=x;
    while(y){
        if(y&1) r=(base*r)%MOD;
        base=(base*base)%MOD;
        y>>=1;
    }
    return r;
}
IL int getint(){
    int data=0,w=1;char ch=0;
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch<='9'&&ch>='0') data=data*10+ch-'0',ch=getchar();
    return data*w;
}
IL void add(int x,int y){
    to[++tot]=y;
    next[tot]=head[x];
    head[x]=tot;    
}
void Yes(){
    cout<<"Yes"<<endl<<ksm(2,k)<<endl;
}
void No(){
    cout<<"No"<<endl<<k*k<<endl;
}
bool topsort(){
    int cnt=0;
    for(int i=1;i<=n;i++){
        if(!rd[i]) cnt++,q.push(i);
    }
    while(!q.empty()){
        t=q.front();
        q.pop();
        for(int i=head[t];i!=-1;i=next[i]){
            rd[to[i]]--;
            if(!rd[to[i]]){
                cnt++;
                q.push(to[i]);
            }
        }        
    }
    if(cnt<n) return 0; 
    else return 1;
}
int main(){
    n=getint();m=getint();k=getint();
    fill(head,head+N,-1);
    for(int i=1;i<=m;i++){
        t1=getint();t2=getint();
        rd[t2]++;
        add(t1,t2);
    }
    if(topsort()) Yes();
    else No();
    return 0;
}
```
最后再吐槽一下这些强行把知识点合起来的题
我还遇到 Tarjan强行加dp 动态LCA强行加二分


---

## 作者：我没有小白 (赞：1)

$tarjan$超水题

题目说的很明显啊，老爷爷他不想**兜圈**。。。**兜圈**。。

圈不是强联通是啥。。。。

所以就直接上$tarjan$啦！判断只要强联通个数小于节点数，肯定存在环。另外，需要再加上快速幂。

没什么好犹豫的，直接上代码啦

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
int n,m,mod=9997;
struct edge
{
	int next,to;
} e[22000];
int head[22000],tot,k,dfn[22000],col[22000],dfs_num,col_num,vis[22000],stack[22000],top,low[22000],p[22000];
inline void add(int x,int y)
{
	e[++tot].next=head[x];
	e[tot].to=y;
	head[x]=tot;
}
void tarjan(int x)
{
	dfn[x]=++dfs_num;//dfs序 
	low[x]=dfs_num;
	vis[x]=1;
	stack[++top]=x;
	for(int i=head[x]; i; i=e[i].next)
	{
		int v=e[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(vis[v])
			low[x]=min(low[x],dfn[v]);//这个是取dfs序与low值，至于为啥自己调一遍就很清楚了 
	}
	if(dfn[x]==low[x])
	{
		vis[x]=0;
		col[x]=++col_num;
		p[col_num]++;
		while(stack[top]!=x)
		{
			p[col_num]++;
			col[stack[top]]=col_num;
			vis[stack[top--]]=0;
		}
		top--;//一定要有个这个，因为x还在stack里 
	}
}//tarjan求强连通分量 
int ksm(int x,int y)
{
	int z=1;
	while(y)
	{
		if(y&1)z=(z*x)%mod;
		y>>=1;
		x=(x*x)%mod;
	}
	return z%mod;
}//快速幂板子，纯属闲得慌 
int main()
{
	cin >> n >> m >> k;
	k%=mod;
	for(int i=1; i<=m; i++)
	{
		int a,b;
		cin >> a >> b;
		add(a,b);
	}
	for(int i=1; i<=n; i++)
		if(!dfn[i])tarjan(i);//把每个点都遍历一遍 
	if(col_num<n)printf("No\n%d",k*k);
	else if(col_num==n)printf("Yes\n%d",ksm(2,k));
}
```

---

## 作者：盖矣斌峥 (赞：1)

[本人博客](https://prime.design.blog/)

题目大意：给一个有向图，判断它是否有环

一个check函数搞定一切：

```
bool check(int x)
{
    int i=x;
    while(to[i]!=0)
	{
        i=to[i];
        if(i==x)return false;
    }
    return true;
}
```
函数思想：对于一个点，遍历一遍它指向的点，如果最终回到它自己，就说明有环，否则没有

输出k^2用快速幂解决（不懂得可以去看看模版）

[P1226 【模板】快速幂||取余运算](https://www.luogu.org/problemnew/show/P1226)
```
int ksm(int a,int b,int mod)
{
    int ans=1;
    while(b)
    {
        if(b%2)ans=ans*a%mod;
        a=a*a%mod;
        b/=2;
    }
    return ans%mod;
}
```
见代码：
```
#include <iostream>
#include <cmath>
using namespace std;
int n,m,k,x,y,ok=true;
int to[1005];
bool check(int x)
{
    int i=x;
    while(to[i]!=0)
	{
        i=to[i];
        if(i==x)return false;
    }
    return true;
}
int ksm(int a,int b,int mod)
{
    int ans=1;
    while(b)
    {
        if(b%2)ans=ans*a%mod;
        a=a*a%mod;
        b/=2;
    }
    return ans%mod;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++)
	{
        cin>>x>>y;
        to[x]=y;
        ok=check(x);
        if(!ok)break;
    }
    if(ok)cout<<"Yes"<<endl<<ksm(2,k,9997);
    else cout<<"No"<<endl<<k*k;
    return 0;
}
```


---

## 作者：Morning_Glory (赞：1)

看了下其他人的题解，蒟蒻表示看不懂，所以自己写了

这道题看了下，乍一看以为很难来着，但是细细一想【吹吧】发现还是不难的，不知道为什么给的评分是提高-的

来看题目
### 他不想兜圈子 因为那会使他昏沉
这个意思是只要有圈子他就不清醒了，所以只要判断有没有圈子就好了

对于每个x,y，y都是接到x的后面，如果有圈子就说明x->y之后还会出现y->a->b->...->z->x
所以判断圈就很简单了

因为x->y单向接通所以不会有x接向两个村子的情况

那么用一个next[i]表示i村的下一个是哪个村，之后看会不会回到这个村就好了，其实还是很简单的

具体就是要有一个检查函数来检查会不会回到原来的村子

```c
bool check(int x)//检查x这条路有没有环,如果有环返回false,退出
{
	int i=x;
	while (next[i]!=0){
		i=next[i];
		if (i==x)return false;//回到原来的村子了
	}
	return true;
}
```

只有就差一个快速幂取模了

```cpp
int quick_pow_mod (int a,int b,int c)//返回a^b%c
{
	int s=1;
	while (b){
		if (b%2){
			s%=c;
			a%=c;
			s*=a;
		}
		a%=c;
		a*=a;
		b=b>>1;
	}
	return s%c;
}
```
具体理解还是看这个链接吧	
https://blog.csdn.net/Morning_Glory_JR/article/details/80867410

本蒟蒻根据自己的理解做的一篇文章(打个广告)

接下来是代码

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int n,m,k,x,y,ok=true,next[1001];
bool check(int x)//检查x这条路有没有环,如果有环返回false,退出
{
	int i=x;
	while (next[i]!=0){
		i=next[i];
		if (i==x)return false;
	}
	return true;
}
int quick_pow_mod (int a,int b,int c)//返回a^b%c
{
	int s=1;
	while (b){
		if (b%2){
			s%=c;
			a%=c;
			s*=a;
		}
		a%=c;
		a*=a;
		b=b>>1;
	}
	return s%c;
}
int main ()
{
	cin>>n>>m>>k;
	for (int i=0;i<m;i++){
		cin>>x>>y;
		next[x]=y;
		ok=check(x);//ok为检查结果
		if (!ok)break;//如果有环便退出
	}
	if (ok)cout<<"Yes"<<endl<<quick_pow_mod(2,k,9997);
	else cout<<"No"<<endl<<k*k;
	return 0;
}

```

---

## 作者：xzhif (赞：0)

### 题目大意
  判断一个有向图是否有环，可以用拓扑排序判环。
### 拓扑排序
什么是拓扑排序呢？

对于一个有向图，由于每一条拓扑子路径的首节点的入度为 $0$ ，因此可以采取如下办法：

（1）从图中选择一个入度为 $0$ 的节点。

（2）从图中删除该节点及其所有出边（即与之相邻的所有节点的入度减 $1$ ）。

反复执行这两个步骤，直至所有节点都输出，整个拓扑排序完成。或者直至剩图中再没有入度为 $0$ 的节点，这就说明此图中有环，拓扑排序不能再进行下去了。 
### 代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=1001;

int n,m,k,x,y,p[N],c[N],len;

vector<int> g[N];
  
queue<int> q;
  
int main(){
  
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++)scanf("%d%d",&x,&y),g[x].push_back(y),p[y]++;//p数组记录每个点的入度 
	for(int i=1;i<=n;i++)if(p[i]==0)q.push(i);//找入度为0的点 
  
	while(!q.empty()){
		int u=q.front();
		c[++len]=u;//len来记录拓扑了多少个点 
		q.pop();
		for(int i=0;i<g[u].size();i++){
			int v=g[u][i];
			p[v]--;//删除u的所有出边 
			if(p[v]==0)q.push(v);//如果v为0，继续入队 
		}
	}
	if(len!=n)printf("No\n%d",k*k);//判断 
	else{
		printf("Yes\n");
		int o=1;
		for(int i=1;i<=k;i++){
			o*=2;
			o%=9997;
		}
		printf("%d",o);
	}
}
```


---

## 作者：zhengrunzhe (赞：0)

貌似没有C++的题解，也没有用邻接表的

楼下kkk(dalao)已经说得很清楚了

思路就是拓扑找环

坑点楼下kkk没有提到，

数据范围k<=10^9，如果输出k^2可能会爆(但是数据太弱，好像没必要高精，所以就直接输出算了)，如果算2^k再取%的话也会爆

所以，我按楼下的办法处理

详情见代码：

```cpp
#include<queue>
#include<cstdio>
const int N=1001,M=10001;
using namespace std;
int n,m,k,in[N],head[N],num;
struct edge{int to,next;}e[M];
void add(int a,int b)  //建边 
{
    e[++num].next=head[a];
    head[a]=num;
    e[num].to=b;
    in[b]++;   //把加入度放这里 
}
queue<int>q;
bool topo() //简单的拓扑 
{
    int cnt=0;
    for (int i=1;i<=n;i++)
        if (!in[i])q.push(i);
    while (q.size())
    {
        int p=q.front();q.pop();cnt++;
        for (int i=head[p];i;i=e[i].next)
        {
            int v=e[i].to;
            if (!--in[v])q.push(v);
        }
    }
    if (cnt<n)return 0;  //如果处理的点数不足n则说明有环 
    return 1;
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    while (m--)
    {
        int u,v;
        scanf("%d%d",&u,&v);add(u,v);
    }
    if (topo())
    {
        puts("Yes");
        int base=2,t=1; //坑点，这道题k的意义就在于此 
        while (k)
        {
            if (k&1==1)t=t*base%9997;
            base=base*base%9997;
              k/=2;
        }  //仿照kkk(dalao)的写法(请勿吐槽) 
        printf("%d",t);
    }
    else puts("No"),printf("%d",k*k);
    return 0;
}
```

---

## 作者：WanderingTrader (赞：0)

AC了此题以后看了大家的题解，有用拓扑的，有用tarjan的，但我用dfs就过了啊……
### 题目分析
不想兜圈子，那不就是图中没有环吗。
### 幂取模
且不说别的，最后答案有个$2^k\mod9997$，典型的幂取模。  
模板题链接：[P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)  
采用分治法，将复杂度降至$O(\log k)$，再加上每步取模，就可以完成了。  
```cpp
ull POW(ull b,ull p,ull k){
	b %= k;
	ull ans = 1;
	while(p > 0){
		if(p & 1)ans = (ans * b) % k;
		p >>= 1;
		b = (b * b) % k;
	}
	return ans;
}
```
至于$k^2$就很简单了，ull完全存的下，直接输出即可。  
### 核心代码
初始化：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1005
#define MOD 9997
#define ull unsigned long long
vector <int> es[N];
bool f[N],sch[N],vis[N];
ull POW(ull b,ull p,ull k){
	b %= k;
	ull ans = 1;
	while(p > 0){
		if(p & 1)ans = (ans * b) % k;
		p >>= 1;
		b = (b * b) % k;
	}
	return ans;
}
int main()
{
	int n,m,x,y;
	ull k;
	scanf("%d%d%llu",&n,&m,&k);
	for(int i = 1;i <= m;++ i)
	{
		scanf("%d%d",&x,&y);
		es[x].push_back(y);
	}
	return 0;
	for(int i = 1;i <= n;++ i)
	{
		dfs(i);
	}
}
```
这里vis表示是否访问过，sch表示是否正在访问，f表示从此节点是否能走回自身（有环！）。  
dfs时，如果此节点正在访问，说明有环了：
```cpp
void dfs(int x)
{
	if(sch[x]) {f[x] = true;return;}
}
```
如果已经访问过，直接跳过：
```cpp
if(vis[x]) return;
```
然后把两个数组均设为1：
```cpp
sch[x]=vis[x]=1;
```
接下来递归搜索，搜完后把sch改为0即可：
```cpp
int size = es[x].size();
for(int i = 0;i < size;++ i) dfs(es[x][i]);
sch[x] = 0;
```
dfs后，如果f[i]已经是1了，那就不用搜了，直接跳出：
```cpp
bool flag=1;
for(int i = 1;i <= n;++ i)
{
	dfs(i);
	if(f[i]) {flag=0;break;}
}
```
最后根据flag不同的值做讨论即可：
```cpp
if(flag) printf("Yes\n%llu\n",POW(2,k,MOD));
else printf("No\n%llu\n",k*k);
```
dfs部分代码：
```cpp
void dfs(int x)
{
	if(sch[x]) {f[x] = true;return;}
	if(vis[x]) return;
	sch[x]=vis[x]=1;
	int size = es[x].size();
	for(int i = 0;i < size;++ i) dfs(es[x][i]);
	sch[x] = 0;
}
```
全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1005
#define MOD 9997
#define ull unsigned long long
vector <int> es[N];
bool f[N],sch[N],vis[N];
void dfs(int x)
{
	if(sch[x]) {f[x] = true;return;}
	if(vis[x]) return;
	sch[x]=vis[x]=1;
	int size = es[x].size();
	for(int i = 0;i < size;++ i) dfs(es[x][i]);
	sch[x] = 0;
}
ull POW(ull b,ull p,ull k){
	b %= k;
	ull ans = 1;
	while(p > 0){
		if(p & 1)ans = (ans * b) % k;
		p >>= 1;
		b = (b * b) % k;
	}
	return ans;
}
int main()
{
	int n,m,x,y;
	ull k;
	scanf("%d%d%llu",&n,&m,&k);
	for(int i = 1;i <= m;++ i)
	{
		scanf("%d%d",&x,&y);
		es[x].push_back(y);
	}
	bool flag=1;
	for(int i = 1;i <= n;++ i)
	{
		dfs(i);
		if(f[i]) {flag=0;break;}
	}
	if(flag)
		printf("Yes\n%llu\n",POW(2,k,MOD));
	else printf("No\n%llu\n",k*k);
	return 0;
}
```
可以看到，此方法的复杂度还是相当低的，实测下来总时间只有$36ms$。  
$\mathrm{The\ End.}$

---

## 作者：Lngstart (赞：0)

这个题目的意思是问这个有向图中是否有回路!

------------
1）首先删除入度为0的点，并且将对应的和该点相连的点的入度-1。（可以用一个数组表示节点被删除的状态）

------------

2）重复过程1），直到没有入度为0的点，如果还有没被删除的节点，则该有向图一定存在回路

------------
如果情况为Yes的话因为要求的是2^k%9997,要用快速幂的方法，不然会爆了！

------------
快速幂的模板如下：

------------
```cpp
int quick_mod(int n)//快速幂求解2^k
{
	int flag = 2, ans = 1;
	while (n)
	{
		if (n & 1)
			ans = ans * flag % 9997;
		flag = flag * flag % 9997;
		n >>= 1;
	}
	return ans;
}
```
------------

直接上代码了;

------------
```cpp
#include<iostream>
using namespace std;

int e[1001][1001];//用来储存图
int ru_du[1001];//用来储存各个点的入度情况
int book[1001];//用来标记入度为0的这个点是否走过
int quick_mod(int n)//快速幂求解2^k
{
	int flag = 2, ans = 1;
	while (n)
	{
		if (n & 1)
			ans = ans * flag % 9997;
		flag = flag * flag % 9997;
		n >>= 1;
	}
	return ans;
}
int main()
{
	int n, m, k;
	cin >> n >> m >> k;
	//储存图
	for (int i = 0; i < m; ++i) 
	{
		int a, b;
		cin >> a >> b;
		e[a][b] = 1;
	}
	//求出个点的入度情况并存在ru_du数组中
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= n; ++j)
		{
			ru_du[i]+=e[j][i];
		}
	}
	//查找入度为0的点，将其各邻接点的入度-1并将它删除
	for (int i = 1; i <= n; ++i)
	{
		if (ru_du[i] == 0 && book[i] == 0)
		{
			book[i] = 1;
			for (int j = 1; j <= n; ++j)
			{
				if (e[i][j] == 1)
					ru_du[j]--;
			}
			i = 1;
		}
	}
	int flag = 0;//标记变量
	//判断是否还有入度的点
	for (int i = 1; i <= n; ++i)
	{
		if (ru_du[i] != 0)
		{
			flag = 1;
			break;
		}
	}
	if (flag)
		cout << "No" << endl << k* k << endl;
	else
		cout << "Yes" << endl << quick_mod(k) << endl;
	return 0;
}
```


---

## 作者：嚯呀嚯呀 (赞：0)

简单的tarjan

缩完点后看一下每个强联通分量点的个数有没有>=2，如果有，那就是存在环
YES和NO的问题就处理好了

但是题目还是要皮一下，如果是YES要输出2^k，如果是NO要输出k^2；

前面的写快速幂就行了，后面的要提醒一下P党的同学(C++是不是这样我不知道诶)
**如果你k定义为longint,后面就不能直接writeln(k*k);**因为这句话其实是先用一个中间变量存一下答案，然后再输出，而那个中间变量的类型是根据前面这个k的类型而定的，这样的话就会爆longint。

Code:
```
var
  base,ans:int64;
  bi:boolean;
  top,tot,a1,a2,len,t:longint;
  i,j,m,n,k,p:longint;
  next,other,a,check,low,dfn,color,f,num:array[0..10005]of longint;
function min(x,y:longint):longint;
begin
  if x<y then exit(x)
  else exit(y);
end;
procedure tarjan(u:longint);
var
  k,v,j:longint;
begin
  inc(top); f[top]:=u; check[u]:=1;
  inc(t); dfn[u]:=t; low[u]:=t;
  k:=a[u];
  while k<>0 do
    begin
      v:=other[k];
      if check[v]=0 then
        begin
          tarjan(v);
          low[u]:=min(low[u],low[v]);
        end
      else
        if check[v]=1 then
          low[u]:=min(low[u],dfn[v]);
      k:=next[k];
    end;
  if dfn[u]=low[u] then
    begin
      inc(tot);
      repeat
        j:=f[top]; dec(top);
        check[j]:=-1;
        color[j]:=tot;
        inc(num[tot]);
      until j=u;
    end;
end;
begin
  readln(n,m,k);
  for i:=1 to m do
    begin
      readln(a1,a2);
      inc(len);
      next[len]:=a[a1]; a[a1]:=len; other[len]:=a2;
    end;
  for i:=1 to n do
    if check[i]=0 then
      tarjan(i);
  bi:=true;
  for i:=1 to tot do
    if num[i]>1 then
      begin
        bi:=false; break;
      end;
  if bi=false then
    begin
      writeln('No');
      ans:=k*k;
      writeln(ans);
    end
  else
    begin
      writeln('Yes');
      ans:=1; base:=2;
      while k<>0 do
        begin
          if k and 1=1 then ans:=(ans*base) mod 9997;
          base:=(base*base) mod 9997;
          k:=k shr 1;
        end;
      writeln(ans);
    end;
end.

```

---


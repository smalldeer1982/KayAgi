# 三国杀I（洗牌&发牌）

## 题目描述

一场三国杀一共有 $n$ 个玩家，每人需要 $4$ 张牌。牌库共 $k$ 张牌，需洗牌后再发。每张牌有以下 $3$ 个属性：

一、牌的类型:

1. 基础：杀（$\texttt{K}$）、闪（$\texttt{M}$）、桃（$\texttt{P}$）、酒（$\texttt{W}$）。

2. 非延时锦囊：决斗（$\texttt{B}$）、万箭（$\texttt{A}$）、南蛮（$\texttt{S}$）、五谷（$\texttt{C}$）、桃园（$\texttt{G}$）、拆（$\texttt{D}$）、顺（$\texttt{U}$）、铁索（$\texttt{T}$）、无懈（$\texttt{N}$）、火攻（$\texttt{F}$）、无中（$\texttt{E}$）。

3. 延时锦囊：兵（$\texttt{I}$）、乐（$\texttt{K}$）、闪电（$\texttt{L}$）。

4. 马（$\texttt{+,-}$）

5. 武器：连弩（$\texttt{LN}$）、青釭（$\texttt{QG}$）、古锭（$\texttt{GD}$）、寒冰（$\texttt{HB}$）、雌雄（$\texttt{CX}$）、吴六（$\texttt{WL}$）、青龙（$\texttt{QL}$）、丈八（$\texttt{ZB}$）、贯石（$\texttt{GS}$）、方天（$\texttt{FT}$）、羽扇（$\texttt{YS}$）、麒麟（$\texttt{LG}$）。

6. 防具：仁王（$\texttt{RW}$）、八阵（$\texttt{BZ}$）、藤甲（$\texttt{TJ}$）、狮子（$\texttt{SZ}$）

二、花色：只有可能是 $\texttt{C,H,S,D}$ 中的一个。

三、点数：只有可能是 $\texttt{A,2,3,4,5,6,7,8,9,T,J,Q,K}$（T代表10，从小到大）中的一个。

洗牌方式的介绍：一次洗牌过后，从上到下依次是：$\left\lfloor\dfrac{k}{2}\right\rfloor+1,1,\left\lfloor\dfrac{k}{2}\right\rfloor+2,2,\left\lfloor\dfrac{k}{2}\right\rfloor+3,3, ... ,k,\left\lfloor\dfrac{k}{2}\right\rfloor$（可以有奇数张牌，最后一张牌直接忽略掉）。

发牌方式的介绍：从第 $1$ 张牌开始，从上到下依次将第 $i$ 张牌给第 $[(i-1)\mod n+1]$ 号玩家。

已知一共洗了 $m$ 次牌，现在问你第 $p$ 位玩家发到的 $4$ 张牌有哪些。





## 说明/提示


对于 $100\%$ 的数据，满足 $1\leqslant p\leqslant n\leqslant 1000,1\leqslant k\leqslant 100000,1\leqslant m\leqslant 80$。

## 样例 #1

### 输入

```
2 10 1 1
C2 K
H5 B
DT K
SA M
HQ P
D4 K
C6 P
H9 M
ST B
SK C
```

### 输出

```
D4 K
C6 P
H9 M
ST B
```

## 样例 #2

### 输入

```
2 7 1 1
C2 K
H5 B
DT K
SA M
HQ P
SK C
C6 P
```

### 输出

```
Error:cards not enough
```

# 题解

## 作者：DrunkXT (赞：18)

不要被题目吓到了

只是很普通的模拟，题目怎么讲就怎么做

进一步解释都在注释上了
```
#include<cstdio>
#include<algorithm>
#include<string>
#include<iostream>
using namespace std;
const int MAXN=100005;
struct Node
{//用string类型，避免了空格回车的麻烦（虽然速度会慢一些） 
	string c;//ColorNumber 
	string t;//Type
}a[MAXN],b[MAXN],ans[10];
int main()
{
	freopen("三国杀I（洗牌&发牌）.in","r",stdin);
	freopen("三国杀I（洗牌&发牌）.out","w",stdout);
	int n,k,m,p;
	scanf("%d%d%d%d",&n,&k,&m,&p);
	if(k<n*4)//牌不够 
	{
	    printf("Error:cards not enough");
		return 0;
	}
	k=k/2*2;//利用下取整解决：可以有奇数张牌，最后一张牌将被无耻的度娘吃掉
	for(int i=1;i<=k;i++)
	{
		cin>>a[i].c;
		cin>>a[i].t;
	}
	while(m--)
	{//洗牌方式：k/2+1,1,k/2+2,2,k/2+3,3, ... ,k,k/2 
		int j=1;
		for(int i=1;i<=k-1;i+=2,j++)
		{
		    b[i]=a[k/2+j];
		    b[i+1]=a[j];
		}//重新存回a数组 
		for(int i=1;i<=k;i++)
		    a[i]=b[i];
	}
	int j=1;
	//发牌方式：从第1张牌开始，第i张牌给第(i-1)%n+1个人 
	for(int i=1;i<=k&&j<5;i++)
	    if((i-1)%n+1==p)
	    {//保存答案 
	        ans[j]=a[i];
	        j++;
	    }
	for(int i=1;i<=4;i++)
	    cout<<ans[i].c<<' '<<ans[i].t<<endl;
	return 0;
}

```
PS：代码无论在时间还是在空间上都可以优化~~，我懒得写了~~

---

## 作者：封禁用户 (赞：7)



~~三国杀迷CM：题目好评。~~

先要告诉大家，不要因为猪国杀与此题背景类似而畏惧这题，~~那些牌类介绍都是吓唬人的~~。

题意：

给你一堆牌，让你按照$k/2+1,1,k/2+2,2,k/2+3,3, ... ,k,k/2$ 的方式洗牌$m$ 次，然后按照第$i$ 张牌给第$(i-1)mod$ $n+1$ 个人的方式发牌，输出第$p$ 个人手上发到的四张牌。

- 特判

什么情况下会输出`Error:cards not enough`？

```cpp
if(k<n*4) {
    printf("Error:cards not enough\n");
    return 0;
}
```

接着吧……就是大模拟了……

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m,p;
struct eee {
	string a,b;
} x[100001],y[100001];
int main() {
	scanf("%d%d%d%d",&n,&k,&m,&p);
	for(int i(1);i<=k;++i) cin>>x[i].a>>x[i].b;
	if(k<n*4) {//特判
        printf("Error:cards not enough\n");
        return 0;
    }
	while(m--) {//洗牌m次
		for(int i(2);i<=k;i+=2) {//每次的洗牌
			y[i].a=x[i/2].a;
			y[i].b=x[i/2].b;
			y[i-1].a=x[k/2+(i/2)].a;
			y[i-1].b=x[k/2+(i/2)].b;
		}
		for(int i(1);i<=k;++i) x[i].a=y[i].a,x[i].b=y[i].b;//赋值
	}
	int q(0);
	for(int i(1);i<=k&&q<4;++i)
		if((i-1)%n+1==p) cout<<x[i].a<<" "<<x[i].b<<endl,++q;//输出前4张
	return 0;
}
```

---

## 作者：越羽 (赞：5)

注释主要的就贴在代码中了，题看起来花里胡哨的，但其实很简单，只要按部就班的去模拟基本就错不了了；

------------
```c
#include<iostream>
using namespace std;
int n,k,m,p,ji=0;
struct stu{
	string color,pai;//因为牌的花色和数字以及功能可能多余1，直接用string存； 
}a[100005],b[100005];//a数组用来存牌，b数组用来洗牌； 
int main(){
	cin>>n>>k>>m>>p;//输入 
	for(int i=1;i<=k;i++)cin>>a[i].color>>a[i].pai;//结构体输入； 
	if(k<n*4){//直接进行判断看牌够不够； 
		cout<<"Error:cards not enough";
		return 0;
	}
	if(k%2==1)k--;//对于基数个直接减1变成偶数个； 
	for(int i=1;i<=m;i++){
		int j2=1;
		for(int j=1;j2<=k/2;j+=2){
			b[j]=a[k/2+j2];//将a数组换到b数组中洗牌； 
			b[j+1]=a[j2];
			j2++;
		}
		for(int j=1;j<=k;j++)
		a[j]=b[j];//洗牌后将洗好后的牌重新存回a数组； 
	}
	int ji=0;
	for(int i=p;i<=k;i+=n){
		cout<<a[i].color<<" "<<a[i].pai<<endl;//输出玩家得到的牌 ； 
		ji++;//计数，到达4张牌就退出； 
		if(ji==4)break;
	}
	return 0;
}
```


---

## 作者：拂修梦晓 (赞：4)

# [P2348 三国杀I（洗牌&发牌）](https://www.luogu.org/problem/P2348)

一道简单的模拟题

按题意模拟非常简单（然而我当时没看懂洗牌方式

洗牌方式是指原来的第$k/2+1$张牌放第一张，原来的第$1$张放第二张；
         
而不是原来的第一张放到第$k/2+1$张。。。。。

否则会获得优秀的[20分](https://www.luogu.org/record/25191983)（特判给的分）

剩下的就看代码就行了

``````cpp
#include<bits/stdc++.h>
using namespace std;
struct pd{
	char a[5];//我觉得用char变量就行
	char b[5];
};
pd pai[100010],gd[100010];//pai是牌堆，gd是过渡时存储数据的
int main()
{
	int n,k,m,p;
	cin>>n>>k>>m>>p;
	if(k<n*4)//直接特判牌够不够
	{
		cout<<"Error:cards not enough";
		return 0;
	}
	k=k/2*2;//如果是奇数张牌，去掉最后一张
	for(int x=1;x<=k;x++) cin>>pai[x].a>>pai[x].b;
	while(m--)
	{
		for(int x=1;x<=k;x+=2)//洗牌
		{
        		//洗牌方式：k/2+1,1,k/2+2,2,k/2+3,3, ... ,k,k/2 
			gd[x]=pai[k/2+x/2+1];//第奇数张牌为原来的第k/2+（x/2+1）张牌
         		gd[x+1]=pai[x/2+1];//第偶数张牌为原来的第x/2+1张牌
                	//并不用额外申请一个j来计数
		}
		for(int x=1;x<=k;x++) pai[x]=gd[x];//把洗好的牌放回牌堆里
	}
	int y=1;
	for(int x=1;y<=4;x++)
	{
		if(x%n==p)//如果牌是我的就输出
		{
			cout<<pai[x].a<<" "<<pai[x].b<<endl;
			y++;
		}
	}
    return 0;
 } 
``````
（本人习惯不压行，于是就有了上面那个又丑又长的代码）


---

## 作者：BaCO3 (赞：2)

这道题就是一道简单的模拟题，题干很长，但除了发牌和洗牌都可以直接忽略掉。

洗牌的方式可能有点绕，可以理解为把牌分成两堆，先从后面一堆的顶部拿一张牌，再从前面一堆的顶部拿一张牌，以此类推。

发牌方式：从第1张牌开始，第 i 张牌给第 (i-1)%n+1 个人，等于说 n 个人围成一圈，依次拿一张牌，所以第 p 个人拿到的第一张牌会是 a[p]，第二张牌会是 a[p+n]，第三张牌是 a[p+2n]，第四张牌是 a[p+3n]。

好了，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct card{
	string cn,t;
}a[100005],b[100005];//一个存输入的字符串，一个用来洗牌 

int main()
{
	int n,m,k,p;
	cin>>n>>k>>m>>p;
	if(k<n*4){//牌不够直接输出 
		cout<<"Error:cards not enough";
		return 0;
	}
	for(int i=1;i<=k;i++){
		cin>>a[i].cn>>a[i].t; 
	}
	if(k%2==1) k--;
	for(int i=1;i<=m;i++){ 
		for(int j=1;j<k;j+=2){//按照洗牌方式来洗，注意j+=2,不是j++ 
			b[j]=a[k/2+j/2+1];
			b[j+1]=a[j/2+1];
		}
		for(int j=1;j<=k;j++){//将洗好的牌再放回a数组 
			a[j]=b[j];
		}
	}
	//输出
	cout<<a[p].cn<<" "<<a[p].t<<endl;
	cout<<a[p+n].cn<<" "<<a[p+n].t<<endl;
	cout<<a[p+2*n].cn<<" "<<a[p+2*n].t<<endl;
	cout<<a[p+3*n].cn<<" "<<a[p+3*n].t<<endl;
	
	return 0;
}
```

---

## 作者：THMITW (赞：2)

这道题其实不难，不要一看到题目这么长就被吓到，普及/提高-的难度，其实不难，~~就是整太多花里胡哨的了~~。								

这里帮大家整理一下有用的部分：

topic1:
n个参加游戏玩家，每人需要4张牌牌库共k张牌.

topic2:洗牌方式：k/2+1,1,k/2+2,2,k/2+3,3, ... ,k,k/2。
发牌方式：从第1张牌开始，第i张牌给第(i-1)%n+1个人
共洗m次牌，你是第p个人，问你得到了哪几张牌

topic3:若牌数不够输出Error:cards not enough。

看了一下其它人的题解,都是用字符串直接比较，而字符串的比较是非常慢的，所以可以用int类型的数组存储下标，我两种方法都试过了，请看。

[字符串串直接比较](https://www.luogu.org/record/25704139)
[数组存储下标比较](https://www.luogu.org/record/25704223)

两者相差了近5倍的时间
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
const int maxn=100005;
char s[maxn][10];//char两维数组存储，等同于string s[maxn],但char类型不知道为什么更快
int a[maxn],b[maxn];//a数组用来存储下标，字符串的赋值速度很慢
int main()
{
	int n,m,x,y;
	cin>>n>>m>>x>>y;
	gets(s[1]);
	if(n*4>m)  //若牌数不够输出Error:cards not enough
	{
		puts("Error:cards not enough");
		return 0;
	}
	for(int i=1; i<=m; ++i)gets(s[i]);
	for(int i=1; i<=m; ++i)a[i]=i;//数组下标初始化
	for(int i=1; i<=x; ++i)
	{
		for(int j=1; j<=m; j+=2)
			b[j]=a[m/2+(j+1)/2];
		for(int j=2; j<=m; j+=2)
			b[j]=a[j/2];
		memcpy(a,b,sizeof(a));//把b数组的值赋给a数组
	}
	x=0;//x到现在为止已经没有用了，可以用来存储目前已经输出了多少个
	for(int i=1; i<=m&&x<4; ++i)
	{
		if((i-1)%n+1==y)
		{
			cout<<s[a[i]];
			x++;
			putchar('\n');
		}
	}
	//for(int i=1;i<=m;i++)
	//cout<<'\n'<<s[i]<<' '<<a[i];
	return 0;
}
```

---

## 作者：Eason_AC (赞：1)

## Content

浓缩版：将牌库里的 $k$ 张牌洗 $m$ 次，然后将其分发给 $n$ 个玩家，问第 $p$ 号玩家的 $4$ 张牌都有哪些。

完整版：[Link](https://www.luogu.com.cn/paste/xt63klwu)

## Solution

直接对照题意模拟一遍即可。反正写过近 $200$ 行的模拟代码，这样的模拟还算是简单的了。

我们在输入完 $n,k,m,p$ 以后可以直接判断出牌是否够。因为每个人都要有 $4$ 张牌，所以牌库里面必须要有足够 $n$ 个人有四张牌的储存数量。也就是说，$k\geqslant 4n$。所以，如果 $k<4n$ 的话牌肯定不够，于是直接退出程序。

牌够的话就继续下面的洗牌和发牌过程，由题意我们可以明显的看出，这道题目中牌的花色、点数和类型纯粹就是用来作为输入输出的载体，没有什么实质性的用处~~（实质性的用处可以参考[P2482](https://www.luogu.com.cn/problem/P2482)）~~。那么直接按照题目里的要求洗就是了。

首先要注意的是牌库里储存的牌的数量的问题，因为它可能是**奇数**，所以我们应该按照题目里的要求直接忽略掉它。那么如何存储洗过之后的牌呢？我们在这里考虑另起一个结构体来存储，然后将所有的信息全部用来覆盖掉原来的信息。

最后就是发牌了，因为题目中只需要知道第 $p$ 个人的所有牌，所以只需要当轮到 $p$ 的时候直接输出当前的牌就可以了。题目中给了我们这样的公式：

> 第 $i$ 张牌分给第 $[(i-1)\mod n+1]$ 号玩家。

所以直接套公式，然后看它等于 $p$ 的时候直接输出牌的所有信息即可。

## Code
```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
using namespace std;

struct cd {
	string cn, t;
}c1[100007], c2[100007];
int n, k, m, p;

int main() {
	scanf("%d%d%d%d", &n, &k, &m, &p);
	for(int i = 1; i <= k; ++i)
		cin >> c1[i].cn >> c1[i].t;
	if(k < n * 4) {
		printf("Error:cards not enough");
		return 0;
	}
	if(k % 2)	k--;
	while(m--) {
		for(int i = 1; i <= k - 1; i += 2) {
			c2[i] = c1[k / 2 + (i + 1) / 2];
			c2[i + 1] = c1[(i + 1) / 2];
		}
		for(int i = 1; i <= k; ++i)
			c1[i] = c2[i];
	}
	int cnum = 0;
	for(int i = 1; i <= k; ++i)
		if((i - 1) % n + 1 == p) {
			cnum++;
			if(cnum > 4)	break;
			cout << c1[i].cn << ' ' << c1[i].t << '\n';
		}
	return 0;
}
```

---

## 作者：ljh736731592 (赞：1)

很显然一道模拟，但是空格、回车什么的很麻烦

由于string处理比较慢，所以我之前用char打的，本地测试全都对，但是WA20

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,p,k,s;
char x[100001][10],xx[100001][10];
int main()
{
//	freopen("wa.txt","w",stdout);
	scanf("%lld%lld%lld%lld",&n,&k,&m,&p);
	if(k<n*4)
    {
        printf("Error:cards not enough");
        exit(0);
    }
    k=k/2*2;
	for(int i(1);i<=k;i++)
	{
		x[i][1]=getchar();
		while(x[i][1]==' '||x[i][1]=='\n'||x[i][1]=='\r')
		x[i][1]=getchar();
		int j(1);
		while(1)
		{
			j++;
			x[i][j]=getchar();
			if(x[i][j]=='\n')
			break;
		}
	}
	while(m--)
	{
		if(k%2==0)
		for(int i(1);i<=k;i++)
		{
			if(i%2==1)
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(k/2+(i+1)/2)][j];
			else
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(i/2)][j];
		}
		else
		for(int i(1);i<k;i++)
		{
			if(i%2==1)
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(k/2+(i+1)/2)][j];
			else
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(i/2)][j];
			k--;
		}
		for(int i(1);i<=k;i++)
		{
			for(int j(1);j<=5;j++)
			x[i][j]=xx[i][j];
		}
	}
	for(int i(1);i<=k;i++)
	{
		if(s==4)
		exit(0);
		if((i-1)%n+1==p)
		{
			s++;
			for(int j(1);j<=5;j++)
			putchar(x[i][j]);
			if(x[i][5]!='\n')
			putchar('\n');
		}
	}
	exit(0);
}

```


后来，~~无奈的~~我只好用string

A了

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,p,k,s;
struct pai
{
    string c;
    string t;
}x[100001],xx[100001];
int main()
{
//	freopen("wa.txt","w",stdout);
	scanf("%lld%lld%lld%lld",&n,&k,&m,&p);
	if(k<n*4)
    {
        printf("Error:cards not enough");
        exit(0);
    }
    k=k/2*2;
	for(int i(1);i<=k;i++)
	{
		cin>>x[i].c>>x[i].t;
	}
	while(m--)
	{
		if(k%2==0)
		for(int i(1);i<=k;i++)
		{
			if(i%2==1)
			xx[i]=x[(k/2+(i+1)/2)];
			else
			xx[i]=x[(i/2)];
		}
		else
		for(int i(1);i<k;i++)
		{
			if(i%2==1)
			xx[i]=x[(k/2+(i+1)/2)];
			else
			xx[i]=x[(i/2)];
			k--;
		}
		for(int i(1);i<=k;i++)
		{
			x[i]=xx[i];
		}
	}
	for(int i(1);i<=k;i++)
	{
		if(s==4)
		exit(0);
		if((i-1)%n+1==p)
		{
			s++;
			cout<<x[i].c<<" "<<x[i].t;
			putchar('\n');
		}
	}
	exit(0);
}
```

再后来经过大佬指点，原来Windows的换行符是“\r\n”

改了一下就A了

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,p,k,s;
char x[100001][10],xx[100001][10];
int main()
{
//	freopen("wa.txt","w",stdout);
	scanf("%lld%lld%lld%lld",&n,&k,&m,&p);
	if(k<n*4)
    	{
        	printf("Error:cards not enough");
        	exit(0);
    	}
    	k=k/2*2;
	for(int i(1);i<=k;i++)
	{
		x[i][1]=getchar();
		while(x[i][1]==' '||x[i][1]=='\n'||x[i][1]=='\r')
		x[i][1]=getchar();
		int j(1);
		while(1)
		{
			j++;
			x[i][j]=getchar();
			if(x[i][j]=='\n')
			break;
		}
	}
	while(m--)
	{
		if(k%2==0)
		for(int i(1);i<=k;i++)
		{
			if(i%2==1)
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(k/2+(i+1)/2)][j];
			else
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(i/2)][j];
		}
		else
		for(int i(1);i<k;i++)
		{
			if(i%2==1)
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(k/2+(i+1)/2)][j];
			else
			for(int j(1);j<=5;j++)
			xx[i][j]=x[(i/2)][j];
			k--;
		}
		for(int i(1);i<=k;i++)
		{
			for(int j(1);j<=5;j++)
			x[i][j]=xx[i][j];
		}
	}
	for(int i(1);i<=k;i++)
	{
		if(s==4)
		exit(0);
		if((i-1)%n+1==p)
		{
			s++;
			for(int j(1);j<=5;j++)
			putchar(x[i][j]);
			if(x[i][5]!='\n')
			putchar('\n');
		}
	}
	exit(0);
}

```


---

## 作者：零殇 (赞：0)

题目的什么种类介绍一点用都没有。。。

首先我们先把题目简化：

有$n$个玩家和$k$张牌，洗牌方式是把牌$k/2+1,1,k/2+2,2,......,k,k/2$的顺序重新排列。发牌方式是第$p$个人拿到$p,p+n,p+2n,p+3n$四张牌，求$m$次洗牌后第$p$个人的牌。




------------
首先是初始化，每张牌都有$ColorNumber$和$Type$（这里为了方便用$a$和$b$表示）。用$card$和$flag$分别表示原牌堆和更新后的牌堆。

```
struct xx{
	string a;
	string b;
}card[100001],flag[100001];
```
------------

之后，我们要判断牌堆够不够，如果$k<4*n$，那么就肯定不行。

```
	cin>>n>>k>>m>>p;
	for(int i=1;i<=k;i++)
		cin>>card[i].a>>card[i].b;
	if(n*4>k)//判断牌堆够不够 
	{
		cout<<"Error:cards not enough";
		return 0;
	}
```


------------

接下来是牌堆的奇偶，因为奇数最后一张牌会被吃掉，那么就把$k$减$1$。

```
	if(k%2==1)//判断奇偶 
		k--; 
```


------------

然后就是洗牌，我们发现第$x$张牌（其中$x$为奇数）就是第$x+1$张牌原来的位置加$k/2$，而第$x+1$张牌原来的位置是从$1$开始不断加$1$的递增序列，因此我们可以用一个计数器$ans$来表示第$x+1$张牌原来的位置。再把原来的牌堆更新，重复$m$次结束洗牌过程。

```
	for(int i=1;i<=m;i++)
	{
		int ans=0;//注意每一次的ans都要重置 
		for(int j=2;j<=k;j+=2)//洗牌 
		{
			ans++;
			flag[j].a=card[ans].a;
			flag[j].b=card[ans].b;
			flag[j-1].a=card[k/2+ans].a;
			flag[j-1].b=card[k/2+ans].b;
		}
		for(int j=1;j<=k;j++)//将先前的牌堆更新 
		{
			card[j].a=flag[j].a;
			card[j].b=flag[j].b;
		}
	}
```



------------

最后是发牌，因为每一次循环是$n$个人,所以每次加上$n$就好了。

```
	for(int i=p;i<=4*n;i+=n)//发牌 
		cout<<card[i].a<<' '<<card[i].b<<endl;
```


------------

上代码（完整版）：

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
struct xx{
	string a;
	string b;
}card[100001],flag[100001];
int main()
{
	int n,k,p,m;
	cin>>n>>k>>m>>p;
	for(int i=1;i<=k;i++)
		cin>>card[i].a>>card[i].b;
	if(n*4>k)//判断牌堆够不够 
	{
		cout<<"Error:cards not enough";
		return 0;
	}
	if(k%2==1)//判断奇偶 
		k--; 
	for(int i=1;i<=m;i++)
	{
		int ans=0;//注意每一次的ans都要重置 
		for(int j=2;j<=k;j+=2)//洗牌 
		{
			ans++;
			flag[j].a=card[ans].a;
			flag[j].b=card[ans].b;
			flag[j-1].a=card[k/2+ans].a;
			flag[j-1].b=card[k/2+ans].b;
		}
		for(int j=1;j<=k;j++)//将先前的牌堆更新 
		{
			card[j].a=flag[j].a;
			card[j].b=flag[j].b;
		}
	}
	for(int i=p;i<=4*n;i+=n)//发牌 
		cout<<card[i].a<<' '<<card[i].b<<endl;
	return 0;
}
```

完结撒花~

---

## 作者：DreamFox (赞：0)

本题解同步于[我的博客园](https://www.cnblogs.com/crp-cpp/)

本题思路：模拟。

首先我们容易发现，因为每位玩家至少需要 $4$ 张牌，所以如果 $k < n \times4$，那么输出无解。

然后我们可以看出，这道题的主要部分是在洗牌上。

于是我们观察洗牌后的顺序：

```cpp
b[1] = a[k / 2 + 1];
b[2] = a[1];
b[3] = a[k / 2 + 2];
b[4] = a[2];
...
b[k - 1] = a[k];
b[k] = a[k / 2];
//其中 b 为洗牌后牌的花色，a 为洗牌前牌的花色
```
可以看出（其中 a 为洗牌前牌的花色，b 为洗牌后牌的花色）：

$$ b_i = a_{\frac{k}{2} + \lceil {\frac{i}{2}} \rceil} (i \ \bmod 2 == 1)$$

$$ b_i = a_{\frac{i}{2}} (i \ \bmod 2==0)$$

所以，我们就可以模拟 $m$ 次洗牌，然后再 $O(k)$ 发牌。

时间复杂度为 $O(mk)$。

AC 代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <string>
#include <cstdio>
using namespace std;
int n, k, m, p;
struct sgs {
	string a, b;
} c[100010], d[100010];
int main() {
	cin >> n >> k >> m >> p;
	if(k < n * 4) puts("Error:cards not enough"), exit(0); //判断无解情况
	for(int i = 1; i <= k; i ++) cin >> c[i].a >> c[i].b;
	for(int i = 1; i <= m; i ++) {
		for(int j = 2; j <= k; j += 2) { //模拟洗牌过程
			d[j].a = c[j / 2].a;
			d[j].b = c[j / 2].b;
			d[j - 1].a = c[k / 2 + j / 2].a;
			d[j - 1].b = c[k / 2 + j / 2].b;
		}
		for(int j = 1; j <= k; j ++) c[j] = d[j]; //每次洗完牌要更新原数组
	}
	for(int i = 1, tot = 0; i <= k, tot < 4; i ++) { //模拟出牌过程
		if((i - 1) % n + 1 == p) {
			cout << d[i].a << ' ' << d[i].b << endl;
			++ tot;
		}
	}
	return 0;
}
```


---

## 作者：hensier (赞：0)

这是一道**模拟题**。

本题对于三国杀牌型的描述是多余的，只需要用字符串保存即可。由于每行描述一张牌，且中间有空格，故需要整行地读入。这可以用 `gets`（读入 `char` 数组） 或 `getline` （读入 `string`）函数来实现。

需要注意的是，在读完第一行的 $n,k,m,p$ 之后，如果直接进行 `gets` 或 `getline`，则会读入换行符。于是有两个解决方法：一个是用 `getchar` 吞噬字符，一个是执行两次 `gets` 或 `getline`。前者是行不通的，因为本题中有 `\r\n` 作为换行符的存在。

首先特判牌不够的情况。因为每个人应分到 $4$ 张牌，所以一旦 $4n \gt k$就会造成牌的不足。

如果牌足够，不妨把所有卡牌（即字符串）存储在数组 $s$ 中，并新建一个同等大小空间的数组 $t$，然后先把洗出来的牌存入其中，再复制 $t$ 中的元素到 $s$ 中，即可完成一次洗牌。

在所有洗牌完成之后，判断对应的牌是否被发放到玩家即可。一旦玩家拿到了 $4$ 张牌，就不再进行输出。

$\text{C}$语言代码：

```c
#include<stdio.h>
#include<string.h>
int n,k,m,p,cnt;
char s[100001][21];
int main()
{
    scanf("%d%d%d%d",&n,&k,&m,&p);
    for(int i=0;i<=k;i++)gets(s[i]);//实际下标从1开始，但从0下标开始，能正好多读一次
    if(k<(n<<2))//特判牌不足，n<<2等同于4n
    {
        puts("Error:cards not enough");
        return 0;
    }
    while(m--)//共洗牌m次
    {
        char t[100001][21]={};
        for(int i=1;i<=k>>1;i++)//k>>1等同于k/2
        {
            /*
            要求k/2+1,1,k/2+2,2,...的顺序洗牌，
            故对于第i次循环，可处理2张牌，即2张一组。
            因此所有牌可分为{k/2+1,1},{k/2+2,2}...
            对于每组的第一张，可以用k/2+i表示。
            第二张可用i表示。
            即原第2i-1张牌现在变成了第k/2+i张，
            而原第2i张牌现在变成了第i张。
            */
            strcpy(t[(i<<1)-1],s[(k>>1)+i]);
            strcpy(t[i<<1],s[i]);
            //strcpy(a,b)表示把b赋值给a，只可用于char数组/指针的使用。
        }
        memcpy(s,t,sizeof(t));//类似于strcpy，也能联想到memset。这里表示把t的所有内容赋值给s。
    }
    for(int i=1;i<=k;i++)
    {
        if((i-1)%n+1==p)//根据题目中的提示进行判断
        {
            puts(s[i]);
            cnt++;//计数器加1
            if(cnt>3)break;//一旦计数器超过了3就立即停止输出
        }
    }
    return 0;
}
```

$\text{C++}$代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m,p,cnt;
string s[100001];
int main()
{
    cin>>n>>k>>m>>p;
    for(int i=0;i<=k;i++)getline(cin,s[i]);
    if(k<(n<<2))
    {
        puts("Error:cards not enough");
        return 0;
    }
    while(m--)
    {
        string t[100001]={};
        for(int i=1;i<=k>>1;i++)
        {
            //string类型可直接用=进行赋值：
            t[(i<<1)-1]=s[(k>>1)+i];
            t[i<<1]=s[i];
        }
        for(int i=1;i<=k;i++)s[i]=t[i];
    }
    for(int i=1;i<=k;i++)
    {
        if((i-1)%n+1==p)
        {
            cout<<s[i]<<endl;
            cnt++;
            if(cnt>3)break;
        }
    }
    return 0;
}
```

另外，还可用队列实现本题：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m,p,cnt;
string s[100001];
queue<string>q;
int main()
{
    cin>>n>>k>>m>>p;
    for(int i=0;i<=k;i++)getline(cin,s[i]);
    if(k<(n<<2))
    {
        puts("Error:cards not enough");
        return 0;
    }
    while(m--)
    {
        q=queue<string>();//将队列置空
        for(int i=1;i<=k>>1;i++)
        {
            //类比刚才的方法把两个字符串分别存入队列：
            q.push(s[(k>>1)+i]);
            q.push(s[i]);
        }
        for(int i=1;q.size();i++)
        {
            //遵循FIFO（先进先出）的原则，我们可依次将队列中元素存入s数组中：
            s[i]=q.front();
            q.pop();
        }
    }
    for(int i=1;i<=k;i++)
    {
        if((i-1)%n+1==p)
        {
            cout<<s[i]<<endl;
            cnt++;
            if(cnt>3)break;
        }
    }
    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：0)

作为一名三国杀的爱好者，其实我是先听说了[猪国杀](https://www.luogu.com.cn/problem/P2482)，然后在搜索的时候看到这题的。由于受到了那道~~小模拟~~的惊吓，我一度怀疑这题是不是那题的衍生品……直到我点进去，我似乎更加确定了——这两题的背景和介绍如出一辙……不过事实证明，~~这题还是比较水的~~。

**以上均是废话**


------------
### 题目内容：
$n$ 个参加游戏玩家，每人需要 $4$ 张牌。牌库共 $k$  张牌，需洗牌后再发。已知洗牌方法 $[k/2+1],[1],[k/2+2],[2],[k/2+3],[3], ... ,[k],[k/2]$，输入人数 $n$，牌数 $k$，洗牌次数 $m$，玩家所在位置 $p$，求玩家所获得的牌。

### 大体思路：
**第一部分：判断牌数是否足够**

首先是判断牌数是否足够，如果不够则输出 `Error:cards not enough`。显然这难度不大。须满足牌数 $k>needed$ 即可。而需要的牌 $needed=n×4$。

代码如下：
```cpp
#define N 100005
struct PIG{//可能是受了猪国杀的影响……
	string ColorNum;//牌面
	string Type;//类别
}a[N],tmp[N];
int main(){
	int n,k,m,p;//如题
	cin>>n>>k>>m>>p;
	for(int i=1;i<=k;i++){
		cin>>a[i].ColorNum>>a[i].Type;
	}//输入
	if(n*4>k) {
		cout<<"Error:cards not enough";
		return 0;
	}//判断牌数是否足够
```
**第二部分：洗牌**

洗牌方法 $[k/2+1],[1],[k/2+2],[2],[k/2+3],[3], ... ,[k],[k/2]$，即现在的第一张牌为原来第 $k/2+1$ 张牌，以此类推。不难发现，新的牌 `tmp[i]=(i%2==1?a[k/2+j]:a[j])`。这意味着如果牌数为奇数，则在一开始删去最后一张牌。在每次洗牌后，再将新的牌复制到原来的里面，再次循环。其代码如下：
```cpp
	k-=(k%2);//如果牌数为奇数，则删去最后一张牌
	for(int l=1;l<=m;l++){//洗牌m次
		for(int i=1,j=1;i<=k;i+=2,j++){
				tmp[i]=a[k/2+j];
				tmp[i+1]=a[j];//洗牌			
		}
		for(int i=1;i<=k;i++){
			a[i]=tmp[i];//复制
		}
	}
```
**第三部分：输出**

由于玩家是轮流摸牌，因此再找到第一张属于自己的牌后要跳过 $n-1$ 张。话不多说，上代码：
```cpp
	bool flag=0;//判断是否输出完毕
	for(int i=1;i<=k;i++){//遍历牌
		if((i-1)%n+1==p && flag==0){//牌是属于玩家且还未输出，即找到第一张属于自己的牌
			for(int j=1,num=p;j<=4;j++,num+=n)//牌号从p开始，每次前进n个，即前进一轮
				cout<<a[num].ColorNum<<" "<<a[num].Type<<"\n";//输出
			flag=1;//标记
		}
		if(flag) break;//结束循环
	}
```
### 完整AC代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
#define N 100005

struct PIG{
	string ColorNum;
	string Type;
}a[N],tmp[N];//结构体PIG记录牌面

int main(){
	int n,k,m,p;
	cin>>n>>k>>m>>p;
	for(int i=1;i<=k;i++){
		cin>>a[i].ColorNum>>a[i].Type;
	}//输入
	if(n*4>k) {
		cout<<"Error:cards not enough";
		return 0;
	}//判断牌数是否足够
	k-=(k%2);//牌数变为偶数
	for(int l=1;l<=m;l++){
		for(int i=1,j=1;i<=k;i+=2,j++){
				tmp[i]=a[k/2+j];
				tmp[i+1]=a[j];			
		}
		for(int i=1;i<=k;i++){
			a[i]=tmp[i];
		}
	}//洗牌（思路详见上方）
	bool flag=0;
	for(int i=1;i<=k;i++){
		if((i-1)%n+1==p && flag==0){
			for(int j=1,num=p;j<=4;j++,num+=n)
				cout<<a[num].ColorNum<<" "<<a[num].Type<<"\n";
			flag=1;
		}
		if(flag) break;
	}//输出
	return 0;//完美
}
```
~~看得这么认真，不点个赞再走嘛qaq~~

好了，让我们前进至下一题——[猪国杀](https://www.luogu.com.cn/problem/P2482)！

---

## 作者：Suuon_Kanderu (赞：0)

此题是一个模拟。

基本思路已有，但我写得更加清晰，易懂。

注释在代码中了，应该比较详细了吧
```
#include<bits/stdc++.h>
using namespace std;        
const int N=1000000+10;//数组开大点，不然会RE
struct node//一张牌的内容
{
    string t;//Type
    char co;//colour
    char num;//Number
};
node s[N];//存牌的结构体
node b[N];//辅助结构体
node ans[5];//answer
int n,k,m,p;//如题
void scan()//输入不说了
{	
    cin>>n>>k>>m>>p;
    for(int i=1;i<=k;i++)
    {
        cin>>s[i].co;
        cin>>s[i].num;
        cin>>s[i].t;
        //这里如果用scanf会有意外
        //我也不知道为什么，求评论大佬解答
    }
}
void pai()//排序函数
{
    long long z=1,f=1;
 //z可以用i代替，不过这样更清晰，代表k/2+1中的1
    //f标记b中第几个元素第几个
    for(int i=1;i<=k;++i)
    {
        b[f]=s[k/2+z];/如题。
		++f;//f别忘加1
        b[f]=s[z];
        ++f;++z;
    }
    for(int i=1;i<=k;i++)s[i]=b[i];
    //再把b[i]中的元素粘过去。
}
void fa()//发牌函数。
{
    int q=0;//‘我’表示拿到的牌有几张
    for(int i=1;i<=k;i++)
    {
        if((i-1)%n+1==p)//题中公式
        {
            ++q;
            ans[q]=s[i];
        }
        if(q==4)break;//到四张就不要了。
    }
}
void work()
{
    scan();
    if(k<4*n)//判断牌够不够
    {
        cout<<"Error:cards not enough"<<endl;
        return ;
    }
    for(int i=1;i<=m;i++)pai();//排m次序。
    fa();
    for(int i=1;i<=4;i++)
        cout<<ans[i].co<<ans[i].num<<" "<<ans[i].t<<endl;
        //输出
}
int main()
{
    work();//气势磅礴
    return 0;
}
```
其实这个题难度远不及黄题，想多A一道黄题的不要放过。

另外奇数个牌不判也能A；


---


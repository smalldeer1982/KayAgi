# 「EZEC-3」排列

## 题目描述

pigstd 有一堆数，他想在这么多数中选出若干个数排成一列，记为 $x_{1},x_{2},\cdots,x_{p}$（$p$ 为数的个数）。

这一列数合法**当且仅当**满足以下条件：

- $p \ge 2$。
- 令 $y_{i} = x_{i + 1} - x_{i}$（特别的，$y_{p}=x_{1}-x_{p}$），如果把 $y_{1}$ 到 $y_{p}$ 按 $y_1,y_2,\cdots,y_p$ 的顺序排成**一圈**，那么每两个相邻的数互为相反数且绝对值都为 $k$。

pigstd 想知道，在所有合法的数列中，所有在这个数列中的数之和**最大**是多少。

## 说明/提示

**【样例 1 说明】**

当 pigstd 的排列为：$0,3,0,3$ 或 $3,0,3,0$ 时，总和最大，为 $6$。

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$0 \le k,a_{i} \le 10^6$，$1 \le b_{i} \le 10^6$。

**本题采用捆绑测试。**

- Subtask 1（5 points）：保证无合法的数列；
- Subtask 2（15 points）：$k = 0$；
- Subtask 3（5 points）：$n = 1$；
- Subtask 4（5 points）：$n = 2$；
- Subtask 5（30 points）：$n,k,a_i,b_i \le 10^3$；
- Subtask 6（40 points）：无特殊限制。

## 样例 #1

### 输入

```
4 3 
1 5
2 4
3 3
0 2```

### 输出

```
6```

# 题解

## 作者：pigstd (赞：11)

~~出题人来水一发题解~~

题意：让你找到一个排列，满足相邻的差互为相反数并且绝对值为$k$（首尾也是相邻的），求最大满足该条件的队列中各个数和

不妨设第$1$个数为$x$，那么第$2$个数就只能是$x - k$或者$x + k$，第三个数就还是$x$，依次类推
显然，一个满足条件的队列只能有两个数$a$,$b$，并且$a - b = |k|$
不妨设$a < b$，那么$b = a + k$，然后枚举a，对于每一个$a$，答案就是$( a + a + k ) \times \min ( sum_{a} , sum_{b} )$（$sum_{x}$表示示$x$的个数）

当$k = 0$时还要特判

code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int M=1e6+10;
int sum[M*2],n,k,maxn,ans=-1;

signed main()
{
	cin>>n>>k;
	for (int i=1;i<=n;i++)
	{
		int a,b;
		cin>>a>>b;
		sum[a]+=b,maxn=max(maxn,a);
	}
	if (k==0)
	{
		for (int i=0;i<=maxn;i++)
			if (sum[i]!=1&&sum[i])//注意因为p>=2,所以k=0时sum[i]>=2
				ans=max(ans,i*sum[i]);
		if (ans==-1)cout<<"NO";
		else cout<<ans;
		return 0;
	}
	for (int i=0;i<=maxn;i++)
	{
		int j=i+k;
		if (sum[i]&&sum[j])
			ans=max(ans,min(sum[i],sum[j])*(i+j));
	}
	if (ans==-1)cout<<"NO";
	else cout<<ans;
	return 0;
}
```

---

## 作者：JRzyh (赞：5)

感觉我的代码比您们的短（

首先 $x_{i+1}-x_i$ 是差分的式子，应该能看出来。

差分数列绝对值相等为 $k$，且相邻互为相反数，也就是说数列长成以下的样子

$$x,x+k,x,x+k,\dots,x,x+k$$


或者

$$x+k,x,x+k,x,\dots,x+k,x$$

都是一样的，所以只考虑第一种。

定义 $a_i$ 表示 $i$ 有 $a_i$ 个。

那么 $\min\{a_{i+k},a_i\}$ 个 $i$ 和 $\min\{a_{i+k},a_i\}$ 个 ${i+k}$ 就可以构造出一个合法序列，和为 $(2i+k)\times \min\{a_{i+k},a_i\}$

但是在 $k=0$ 的时候会出锅所以需要特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,a[1000008],ans=-1;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		int x,b;
		cin>>x>>b;
		a[x]+=b;
	}
	for(long long i=0;i<=1000000-k;i++)
	{
		if(a[i]!=0&&a[i+k]!=0)
		{
			int res=0;
			if(k==0)res=i;
			else res=(i+i+k);
			if(min(a[i],a[i+k])!=1)ans=max(ans,res*min(a[i],a[i+k]));
		}
	}
	if(ans==-1)cout<<"NO"<<endl;
	else cout<<ans<<endl;
	return 0;
}

```


---

## 作者：InformationEntropy (赞：5)

题意说得很清楚了，不再解释。

由题意可得：

若存在一个合法序列 $x$，那么选取四个连续的数  $x_i,x_{i+1},x_{i+2},x_{i+3}$（$i+3\le p$），那么有 $x_{i+1}-x_i+x_{i+2}-x_{i+1}=0$（注：互为相反数的两个数相加为 0），即 $x_i=x_{i+2}$ 。

同样 $x_{i+2}-x_{i+1}+x_{i+3}-x_{i+2}=0$，即  $x_{i+1}=x_{i+3}$。

可以得出结论：对于所有 $i$，若 $i+2\le p$，则  $x_i=x_{i+2}$。

再看看倒数第二个数的规律：

 $x_p-x_{p-1}+x_1-x_p=0$，即 $x_1=x_{p-1}$

这样，我们就可以分两种情况讨论：

- 当序列长度为奇数时，设长度为 $2n+1$，则：

  $$x_1=x_3=x_5=\cdots=x_{2n+1}$$
  $$x_2=x_4=x_6=\cdots=x_{2n}$$
  $$x_1=x_{2n}$$
 
  即：$x_1=x_2=x_3=\cdots=x_{2n+1}$
  
  它们的差的共同绝对值为 0。
  

- 当序列长度为偶数时，设长度为 $2n$，则：

  $$x_1=x_3=x_5=\cdots=x_{2n-1}$$
  $$x_2=x_4=x_6=\cdots=x_{2n}$$
  $$x_1=x_{2n-1}$$
  
  最后一句对整个序列并无影响，所以一个长度为偶数的序列被平分为两个部分，每个部分内所有元素相等，它们的差的共同绝对值为 $|x_1-x_2|$。
  
即当 $k=0$ 时，合法序列中每个数都相等，序列长度奇偶均可。$k\not=0$ 时，长度只可能为偶数。

设每个数 $i$ 出现次数为 $f_i$。

对于 $k=0$，枚举 $i$，若 $f_i\ge2$，更新  $ans=\max(ans,i\times f_i)$。

对于 $k\not=0$，枚举 $i$，若 $f_i\ge1$ 且 $f_{i+k}\ge1$，更新 $ans=\max(ans,(i+i+k)\times\min(f_i,f_{i+k}))$。

PS：~~不开 long long 见祖宗~~

**code**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
inline void read(int &x){
    x=0;
    int f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
         }
         ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x*=f;
}
ll f[1000001];
int main(){
    int n, k;
    read(n);
    read(k);
    int a, b;
    int cnt=0;
    int maxx=0;
    for(int i=1; i<=n; i++){
        read(a);
        read(b);
        f[a]+=b;
        maxx=max(maxx, a);
    }
    ll ans=0;
    if(k==0){
        bool flag=0;//记录是否存在合法序列
        for(int i=0; i<=maxx; i++){//要从0开始，因为ai可能为0
            if(f[i]>=2){
                ans=max(ans, i*f[i]);
                flag=1;
            }
        }
        if(!flag){
            cout << "NO";
            return 0;
        }
        cout << ans;
    }else{
        bool flag=0;
        for(int i=0; i<=maxx-k; i++){
            if(f[i]&&f[i+k]){
                flag=1;
                ll w=min(f[i], f[i+k]);
                ans=max(ans, w*i+w*(i+k));
            }
            if(!flag) cout << "NO";
            else cout << ans;
        }
    }
    return 0;
}
```





---

## 作者：zyk7 (赞：5)

~~终于开放月赛题解区了~~，人生第一次写月赛题解，请大家多多包涵。
## 题意：

- 给一个数组 $a$，从中选出 >=2 个数组成数组 $x$，使它们的差分数组 $y$ 围成一个环，相邻两个数 **互为相反数** 且 **绝对值为 $k$**（题面简化）。

- 看到这可能大家会有点懵，但看一眼样例说明，再看看输入格式（**不是输入数组中每个数，而是输入不同的数的个数**），就很好理解了：
- #### 选出两种 相同数量 且差为 $k$ 的数，一种是 $b$，则另一种就是 $b+k$。
- 把这两种数交叉排列，则 x[ ] = {b, b+k, b, b+k···}，y[ ] ={k, -k, k···}，这样就正好符合题目要求。

## 题目分析：
既然理解了题意，那这题思路便很简单，基本上是暴力。

- 如果完全暴力，用双层循环枚举 $b$ 和 $b+k$，时间复杂度为$O(n^2)$，而$n<=10^6$，只能得 $70$ 分。
- 由于两种数的差值固定，可以用一个类似 **桶排序** 的数组来记录 $a$ 数组，$f[i]$ 表示值为 $i$ 的数有多少个。统计完之后在计算过程中只需枚举 $b$ 即可，具体操作见代码。

### PS: 答案要开 long long
## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,f[5000001];
int imax;
long long ans=-1;
bool s=false;
int main(){
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;++i){
    	int a;
    	long long b;
    	scanf("%d%lld",&a,&b);
    	imax=max(imax,a);
    	f[a]+=b;
	}
	for(int i=k;i<=imax;++i){
		if(f[i]){
			if(k==0){
				if(f[i]>1){
				    ans=max(ans,f[i]*i);
				    s=true;
				}
				continue;
			}
			long long sum;
			if(f[i-k]){
				sum=min(f[i],f[i-k]);
				ans=max(ans,sum*i+sum*(i-k));
				s=true;
			}
			if(f[i+k]){
				sum=min(f[i],f[i+k]); 
				ans=max(ans,sum*i+sum*(i+k));
				s=true;
			}
		}
	}
	if(!s) printf("NO");
	else printf("%lld",ans);
	return 0;
}
```



---

## 作者：钓鱼王子 (赞：4)

一个枚举题解。

简化题意：找到 $m$ 个数 $x$ 和 $m$ 个数 $y(y=x+k)$，并最大化 $m\times (x+y)$ 

发现值域不大，可以枚举 $x$，找 $y$，特殊的，如果没有合法答案，直接输出 $-1$，注意答案可能为 $0$。

$k=0$ 需要特判，但也需要注意无解和答案为 $0$ 的区别，同时个数要大于等于 $2$ 个。

代码：

```cpp
#include<cstdio>
#define re register
inline long long max(re long long x,re long long y){
	return x>y?x:y; 
}
inline int min(re int x,re int y){
	return x<y?x:y; 
}
const int Mxdt=1000000;	//单次大小 
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline int read(){
	re int t=0;re char v=gc();
	while(v<'0')v=gc();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=gc();
	return t;
}
int n,m,b,c;
long long ans,a[1000002];
signed main(){ans=-1;
	n=read(),m=read();
	if(n>100000&&n<1000000&&m)return puts("NO"),0;//卡常，无意义
	for(re int i=1,x,y;i<=n;++i){
		x=read(),y=read();
		a[x]+=y;
	}
	if(m)for(re int i=0;i+m<=1e6;++i){
	if(a[i]&&a[i+m])ans=max(ans,1ll*min(a[i],a[i+m])*(i+i+m));}
	else 
	for(re int i=0;i<=1e6;++i)if(a[i]>1)ans=max(ans,1ll*a[i]*i);
	if(~ans)printf("%lld",ans);
	else puts("NO");
}
```


---

## 作者：_0x46EDC (赞：3)

[获得更好的阅读体验](https://www.luogu.com.cn/blog/jasonying/p6785-ezec-3-pai-lie) [题目传送门](https://www.luogu.com.cn/problem/P6785)

---

### 题目分析

使用 $c_i$ 个 $i$，构造一个长度为 $p$ 形如 $\{x,x+k,x,...,x+k\}$ 的数列，求最大数列和。

### 推导

1. $k=0$

考虑当 $k=0$ 时，即构造使得数列和最大的 $\{x,x,x,...,x\}$。显然，对于 $x=i$ 时，数列和最大值为 $i\times c_i$。

因此，$k=0$ 时最大和为 $\max(i\cdot c_i)$。

2. $k>0$

构造一个形如 $\{x,x+k,x,...,x+k\}$ 的数列，使得数列和最大。

此时各需要 $\dfrac{p}{2}$ 个 $x$ 和 $x+k$。

此时对于每个 $i$，数列和的最大值为 $\max(\dfrac{p}{2}\times (i+(i+k)))$。

易得此时 $\dfrac{p}{2}$ 的最大值为 $\min(c_i,c_{i+k})$。

因此，$k>0$ 时最大和为 $\max(\min(c_i,c_{i+k})\times(2\cdot i+k))$。

### 细节

1. 判定无解

本题中答案为 $0$ 不代表无解，如

```
1 0
0 114514
```

有解且答案为 $0$。

因此可以将 $ans$ 预设为 $-1$，程序结束时 $ans$ 若仍为 $-1$ 则无解。

2. 求 $ans$ 循环的跳过条件

首先需要保证 $c_i\neq 0$ 且 $c_{i+k}\neq 0$ 才可以进入求 $ans$ 的语句。

此外，$k=0$ 时，需要保证 $p\ge 2$，即 $c_i\ge 2$。

### 程序

```cpp
#include<bits/stdc++.h>
#define N 1000001
using namespace std;
typedef long long ll;
ll n,k,x[N],ans=-1;
bool flag;
int main(){
    cin>>n>>k;
    for(ll i=1,a,b;i<=n;i++){
        cin>>a>>b;
        x[a]+=b;
    }
    for(ll i=0;i<N-k;i++){
        if(!(x[i]&&x[i+k])||(k==0&&x[i]<2))continue;
        if(k==0)ans=max(ans,x[i]*i);
        else ans=max(ans,min(x[i+k],x[i])*(2*i+k));
    }
    if(ans==-1)cout<<"NO"<<endl;
    else cout<<ans<<endl;
    return 0;
}
```

### 结语

感觉本题偏推柿子类的题目，注重考察对于细节的处理。

还可以按照题目存储数据，有 $b_i$ 个 $a_i$，时间复杂度会从 $O(N)$ 下降到 $O(n)$。

---

## 作者：mot1ve (赞：2)

nlogn的做法
```
#include<iostream>

#include<cstdio>

#include<cstring>

#include<algorithm>

#define int long long

using namespace std;

const int INF=0x3f3f3f3f;

int maxn,minn;

int c[1000010];//c[i]=j表示有j个i，一个桶 

int num[1000010];

int ans=-INF,temp,idx,n,k;

signed main()

{

	cin>>n>>k;

	for(int i=1;i<=n;i++)

	{

		int a,b;

		scanf("%lld%lld",&a,&b);

		if(!c[a])

		num[++idx]=a;//哪些点出现过 

		c[a]+=b;

	}

	sort(num+1,num+1+idx);//从小到大排

	if(k==0)//特判 

	{

		for(int i=1;i<=idx;i++)

		{

			if(c[num[i]]>=2)

			ans=max(ans,c[num[i]]*num[i]);

		}

		if(ans==-INF)

	    {

		    printf("NO");

		    return 0;

	    }

		cout<<ans;

	    return 0;

	}

	for(int i=idx;i>=1;i--)//枚举合法的两个点 

	{

		if(num[i]<k) break;

		int j=lower_bound(num+1,num+1+idx,num[i]-k)-num;

		if(num[i]-num[j]==k) 

		{

			minn=min(c[num[i]],c[num[j]]);//找到个数较小的那个

			temp=minn*(num[i]+num[j]);

			ans=max(ans,temp);

		}

	}

	if(ans==-INF)

	{

		printf("NO");

		return 0;

	}

	cout<<ans;

	return 0;

} 
```

---

## 作者：wuyonghuming (赞：2)

### 思路：
首先看题目：

- 这个序列至少有两个数，分别为： $x_1,x_2,⋯x_p$。

- $y_i=x_{i+1}-x_i$，如果把  $y_i$ 到  $y_p$ 按照  $y_1,y_2,⋯y_p$ 的顺序排成一圈每两个相邻的数互为相反数且绝对值都为 $k$。

我们通过第二条可以得出： 
$$x_{i+1}-x_i+x_{i+2}-x_{i+1}=0$$

$$x_{i+1}-x_i+x_i-x_{i-1}=0$$
化简后得到：
$$x_i=x_{i+2}$$

$$x_{i+1}=x_{i-1}$$
以此类推：
$$x_i=x_{i+2}=x_{i+4}=x_{i+6}=x_{i+8}...$$

$$x_{i+1}=x_{i-1}=x_{i-3}=x_{i-5}=x_{i-7}...$$
如果我们按照题目要求一直算下去的话就会知道这个序列可能有  $2$ 种数或者  $1$ 种数，因为当  $k=0$　时就必须需要：
$$x_1=x_2=x_3=x_4$$

接着我们看到  $a_i\le10^6$，提示我们：我们可以暴力枚举  $a_i$，因为它们构成一个圈，所以数量必须相等，每次枚举，拿它们个数中较少的乘以它们的和更新最大值，如果当中任意一种数的个数为  $0$ 那么这个方案就不成立。
### 注意：
我们特殊判断  $k=0$ 如果且  $b_i=1$ 的话也无法构成两个数的序列。

如果一个序列全部都是  $0$ 时，这也算是一种方案。

我们发现  $1\le n,a_i,b_i\le10^6$， $k=0$ 时，假设三者都等于  $10^6$ 答案就会达到  $10^{18}$ 所以还请大家选择合适的变量类型。

题目不保证  $a_i$ 互不相同，若有  $a_i$ 相同则累加其个数计算。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,s[2000001],k,ans=-1,a,b,f;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;
		s[a]+=b;//第a个数的个数加上b
	}
	for(int i=0;i<=1000000;i++)
	{
		f=min(s[i],s[i+k]);//算它们之间的最小值，因为两种数的个数必须相等
		if(f<1+(k==0))//如果k=0的话这种数至少要两个，否则至少要一个
			continue;
		ans=max(ans,f*i+f*(i+k)*(k!=0));//更新最大值，如果k=0就只能和自己算了
	}
	if(ans>-1)//全部为0也算合法
		cout<<ans;
	else 
		puts("NO");
	return 0;
}
```
最后再提醒大家一下这种做法数组要开两倍大小。因为在最后一个计算可能会用到  $10^6+k$，可能会超过数组大小。

---

## 作者：Rubidium_Chloride (赞：2)

8月月赛II B题题解

## 0.前言

[$\color{Red}{\text{在}}\color{orange}\text{博}\color{yellow}\color{green}\text{客}\color{Turquoise}\text{里}\color{blue}\text{看}\color{purple}\color{Red}\text{效}\color{orange}\text{果}\color{yellow}\text{更}\color{green}\text{好}\color{Turquoise}\text{哦}\color{blue}!$](https://www.luogu.com.cn/blog/Rolling-blog1424/solution-p6785)

## 1.题目大意

- 给定正整数 $n,k$，有 $n$ 个**不一定不同的**数 $a_1,a_2\dots a_{n-1},a_n$，分别有 $b_1,b_2\dots b_{n-1},b_n$ 个；

- 在其中选出 $p$ 个数任意排列成 $x_1,x_2,\dots x_{p-1},x_p$（$p\ge 2$），令 $y_i=x_{i+1}-x_i,i=1,2 \dots p-1,p$，其中 $x_{n+1}=x_1$，要满足：
1. $|y_i|=k,i=1,2\dots p-1,p$（下文称其为要求1）；
2. 而且 $y_{i+1}=-y_i,i=1,2\dots p-1,p$，其中 $y_{p+1}=y_1$（下文称其为要求2）；

- $1\le n,b_i \le 10^6,0\le k,a_i\le 10^6$。

## 2.基础分析

我们先对~~这毒瘤的~~一系列 $y_i$ 的限制做一下化简。

如果 $k=0$，此时 $y_i$ 均为 $0$，也就是选出的数必须全部相同。

如过 $k\neq 0$，此时 $p$ 必须为偶数，否则无法满足要求2。（如果成立，得到 $y_1=-y_1$，而 $|y_1|\neq 0$，矛盾！）

也就是说，我们选出的 $p$ 个数，应该形如如下形式：$c,d,c,d\dots c,d$（其中 $|c-d|=k$），也就是说我们选出的数字组成的序列应该成**循环形式**。

然后接下来就很好办了。

回头看一看数据范围：欸？$0\le a_i \le 10^6$，所以可以开计数器记录每一个 $a_i$ 出现的次数，令 $cnt_i$ 为 $i$ 总共有多少个。

接下来回过去看我们得到的结论。

如果 $k\neq 0$，对于每个 $a_i$，在考虑以它为起始的 $x$ 数列时，只需要判断下一个数到底是 $a_i+k$ 还是 $a_i-k$。（此时要注意 $a_i-k$ 是否 $<0$ 的问题。）不妨设选中的为 $a_i+k$，此时数列最长为两个数各有 $\min(cnt_{a_{i}},cnt_{a_{i}+k})$ 个。

此时数列元素总和为 $(2\times a_i+k)\times \min(cnt_{a_{i}},cnt_{a_{i}+k})$。如果选中的为 $a_i-k$，则同理。

最后对这些求和就可以了。

如果 $k=0$，那么所有元素都应该相同，此时 $ans=\max\left\{ a_i\times cnt_{a_i},i=1,2,\dots n-1,n\right\}$。

## 3.CODE

算了还是贴一下代码吧。

```cpp
#include<bits/stdc++.h>
#define N 1000009
#define INF 0x3f3f3f3f3f3f3f3f
using namespace std;
typedef long long ll;
inline ll read() {
    ll x=0,f=1;int c=getchar();
    while(!isdigit(c)) {if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    return x*f;
}
ll n,k,a[N],b[N],cnt[N],ans=-1; 
int main(){
	n=read(),k=read();
	for(int i=1;i<=n;i++){
		a[i]=read(),b[i]=read();
		cnt[a[i]]+=b[i];//a[i]不一定不同
	}
	for(int i=1;i<=n;i++){
		if(k!=0&&a[i]>=k&&cnt[a[i]-k]) ans=max(ans,min(cnt[a[i]],cnt[a[i]-k])*(2*a[i]-k));
		if(k==0&&cnt[a[i]]>1) ans=max(ans,cnt[a[i]]*a[i]);
		if(a[i]+k<=N&&cnt[a[i]+k]&&k!=0) ans=max(ans,min(cnt[a[i]],cnt[a[i]+k])*(2*a[i]+k));//数列长度>=2
	}
	if(ans==-1){printf("NO");return 0;}//无解输出NO
	printf("%lld",ans);
	return 0;
}
```

## 4.后记

祝大家能够AC本题，也祝洛谷月赛越办越好！

---

## 作者：yhk1001 (赞：1)

构造一下选出的数列，设 $x_1 = p$ , $y_1 = k$ ，则 $x_2 = x_1 + y_1 = p + k , y_2 = -y_1 = -k$ ， $x_3 = x_2 + y_2 = p , y_3 = -y_2 = k$ ， 以此类推，得到最终的序列：
$$p , p + k , p , p + k \cdots p , p + k $$
最终序列是由 $p$ 和 $p + k$ 交替组成的，$p$ 和 $p + k$ 的个数相同。可以用桶记录每个数的个数，枚举 $p$ ，如果 $p$ 和 $p + k$ 均大于 $0$ ，就计算序列和 $sum = \min ( cnt_p , cnt_{p + k} ) \times ( p + p + k ) $ ， 答案为最大的和。注意特判 $k = 0$ 的情况，此时序列数的个数为$cnt_p$。

AC代码 $\;$ [提交记录](https://www.luogu.com.cn/record/37457428)
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

long long a[1000005];//桶，统计个数

int main()
{
	long long n,k;
	cin >> n >> k;
	long long mnum = -1;//最大的数
	for (int i = 1;i <= n;i++)
	{
		long long ai,bi;
		cin >> ai >> bi;
		a[ai] += bi;
		mnum = max(mnum,ai);
	}
	long long ans = -2e9;
	for (long long i = 0;i + k <= mnum;i++)
	{
		if (k == 0)//特判
		{
			if (a[i] > 1) ans = max(ans,a[i] * i);//数列个数应不小于2
			continue;
		}
		if (a[i] > 0 && a[i + k] > 0)
		{
			long long mn = min(a[i],a[i + k]);
			ans = max(ans,mn * (2 * i + k));
		}
	}
	if (ans < 0) cout << "NO" << endl;//无解
	else cout << ans << endl;
	return 0;
}
```


---

## 作者：Lonely_NewYear (赞：0)

# 洛谷 P6785 题解

## 题目分析

这题题目说的很迷惑，其实简单一点就是说相邻两数的差正负来回颠倒，这也就说明选出的数列一定是全为 $1$ 个数（差全为 $0$），或者两数交错。如样例的结果 $0\ 3\ 0\ 3$，就是两数交错。

所以就可以用一个桶记录每个数字出现的次数，然后寻找交错的两个数中较小的那个 $i$，另外一个就为 $i+k$。考虑答案要求和最大，而且两个数都比为非负数，所以两个数能选多少则选多少，也就是选 $\min(cnt_i,cnt_{i+k})$ 组。

需要特判 $k=0$。

时间复杂度 $O(max(a_i))$，可以通过。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long cnt[1000001];
int main()
{
	int n,k,maxn=0,minn=1e9;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		cnt[a]+=b;
		maxn=max(maxn,a);
		minn=min(minn,a);
	}
	long long ans=-1;
	if(k==0)
	{
		for(int i=minn;i<=maxn;i++)
		{
			if(cnt[i]<2)
			{
				continue;
			}
			ans=max(ans,i*cnt[i]);
		}
	}
	else
	{
		for(int i=minn;i<=maxn-k;i++)
		{
			if(min(cnt[i],cnt[i+k])<1)
			{
				continue;
			}
			ans=max(ans,min(cnt[i],cnt[i+k])*(i+i+k));
		}
	}
	if(ans==-1)
	{
		printf("NO");
		return 0;
	}
	printf("%lld",ans);
	return 0;
}
```

谢谢观看！

---

## 作者：zjrdmd (赞：0)

比较一眼的一道题目，评黄的原因大概是细节比较多吧。

首先根据题意我们可以得出一个显然的结论，设答案序列里有$s$个**不同**的数字，那么$1\leq s\leq 2$。于是显然的暴力是枚举$x,y$，然后判断绝对值差是否为$k$，稍微再想一下，可以得到$y=x+k$或者$y=x-k$。于是复杂度可以从$ O(n^2)$优化到$O(n)$。

下面给出code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <map>
#include <stdlib.h>
#define ri register int
#define int long long

inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}

const int N=1e6+5;

int n,k;
int suma[N];
int ans=-1;

signed main(void){
	n=read(),k=read();
	for(ri i=1;i<=n;i++){
		int ai=read(),bi=read();
		suma[ai]+=bi;
	}
	for(ri i=0;i<=1e6;i++){
		int j=i+k;
		if(j>1e6)continue;
		int p=std::min(suma[i],suma[j]); 
		if(i==j)continue;
		if(abs(i-j)==k&&p>=1){
			ans=std::max(p*i+p*j,ans);
		}
		j=i-k;
		if(j<0)continue;
		p=std::min(suma[i],suma[j]); 
		if(i==j)continue;
		if(abs(i-j)==k&&p>=1){
			ans=std::max(p*i+p*j,ans);
		}
	}
	if(k==0){
		for(ri i=0;i<=1e6;i++){
			if(suma[i]>=2)ans=std::max(ans,suma[i]*i);
		}
	}
	if(ans==-1)printf("NO");
	else printf("%lld",ans);
	return 0;
}
```


---

## 作者：wzkdh (赞：0)

本题条件二第一眼看上去有些绕，但是稍加分析就可以明白真正含义:

$y[i]$=$x[i+1]$-$x[i]$,

$y[i+1]$=$x[i+2]$-$x[i+1]$

因为$y[i]$与$y[i+1]$互为相反数

所以$x[i+1]$-$x[i]$=$x[i+1]$-$x[i+2]$

移项可得$x[i]$=$x[i+2]$；

所以x数组只有两个数字交叉排列，又因为$y[i]$绝对值为k，所以两个数字之差为k。

而所求数列的长度取决于两个数字中数量较少的那一个，另一个数字的数量与它是相等的，所以数列中的数之和就很好计算了，为：

（$x[i]$+$x[i]$+k）*$min$（$num[x]$,$num[x+k]$）

至此，我们程序的思路就很明显了：我记录了每一个出现过的数字以及它所出现的次数，然后枚举每一个出现过的数字，如果这个数字以及这个数字加上k都出现过，那么就可以用上面的公式计算长度，并与答案比较，取较大值。

但是要特别注意$k$=0的情况,此时需要判断每个数的数量是否达到了两个，并且计算公式改为了$x[i]$*$num[x]$。

### 最后特别说一句：十年OI一场空，不开。。。

蒟蒻代码：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,k,a[2000010],b[2000010],cnt,ans=-1;//a为数字出现次数，b为出现过的数字。
int main()
{
    scanf("%lld%lld",&n,&k);
    for(int i=0;i<n;i++)
    {
        long long x,y;
        scanf("%lld%lld",&x,&y);
        if(!a[x]&&y)
            b[++cnt]=x;
        a[x]+=y;
    }
    if(k==0)
    {
        for(int i=1;i<=cnt;i++)
        {
            long long sum;
            if(a[b[i]]>=2)
            {
                sum=b[i]*a[b[i]];
                if(sum>ans)
                    ans=sum;
            }
        }
        if(ans==-1)
        printf("NO");
        else
        printf("%lld",ans);
        return 0;
    }//特断k=0的情况
    for(int i=1;i<=cnt;i++)
    {
        long long sum;
        if(a[b[i]+k]&&a[b[i]])
        {
            sum=(b[i]*2+k)*min(a[b[i]],a[b[i]+k]);//正常情况直接公式计算
            if(sum>ans)
                ans=sum;
        }
    }
    if(ans==-1)
        printf("NO");
    else
        printf("%lld",ans);
    return 0;
}

---

## 作者：Mine_King (赞：0)

很明显，这题的序列一定是 $x,x+k,x,\cdots,x+k$ 或 $x+k,x,x+k,\cdots,x$，而且观察一下就可以发现，这两个序列其实是一样的，因为他是一个环。于是，我们就可以统计每个数 $x$ 的出现次数 $f_x$，然后枚举每个 $x$，得到对应的序列和为 $min(f_x,f_{x+k})\times(i+i+k)$。最后在这里面取个最大值即可。  
但是需要注意的是，若 $k=0$，则不能用如上的式子，那么我们需要特判一下。

**code:**
```cpp
#include<cstdio>
using namespace std;
int n,k,l=1e9,r;
long long ans,f[2000005];
bool flag;//flag记录是否有合法的排列
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		f[a]+=b;//统计
		if(a<l) l=a;
		if(a>r) r=a;
        //一个小优化
	}
	if(k==0)//特判
	{
		for(int i=l;i<=r;i++)
			if(f[i]>1&&(f[i]*i>ans||!flag)) ans=f[i]*i,flag=true;//注意题目中说序列长度一定要大于1
		if(flag) printf("%lld\n",ans);
		else printf("NO");
		return 0;
	}
	for(int i=l;i<=r;i++)
		if(f[i]&&f[i+k])
		{
			long long qwq;
			if(f[i]<f[i+k]) qwq=f[i];
			else qwq=f[i+k];
			if(qwq*i+qwq*(i+k)>ans||!flag)
				ans=qwq*i+qwq*(i+k),flag=true;
		}
	if(flag) printf("%lld",ans);
	else printf("NO");
	return 0;
}
```

---

## 作者：chenpengda (赞：0)

显然选出的数列中的数是这个形式：
$a,a+k,a,a+k,a,a+k,a,a+k……$

循环，枚举所有$a$，如果有$a+k$，将答案更新为这种情况序列最大和$min(a\_sum,(a+k)\_sum)\times(a+(a+k))$。

当然如果$k=0$，需要特判，此时就是全部一个数，遍历所有有的数，输出最大的$a\times a\_sum$即可。

$Code$：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[20000005],t[20000005];//a[i]存放i这个数的个数，t[i]存放的是第i个输入进来的数。
int main()
{
	long long n,k,ans=-1,y;//不开ll见祖宗
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>t[i]>>y;
		a[t[i]]+=y;
	}
	bool flag=0;
	if(k==0)//特判，此时序列里是一个数
	{
		for(int i=1;i<=n;i++)
		{
			if(a[t[i]]>=2)//数列中数的个数大于1.
			{
				//cout<<ans<<" "<<t[i]<<" "<<a[t[i]]<<endl;
				ans=max(ans,a[t[i]]*t[i]);flag=1;
			}
		}
		if(!flag)cout<<"NO";
		else cout<<ans;
		return 0;
	}
	for(int i=1;i<=n;i++)//此时序列里是两个数。
	{
		if(a[t[i]+k]>0)ans=max(ans,(2*t[i]+k)*min(a[t[i]],a[t[i]+k]));
	}
	if(ans==-1)cout<<"NO";
	else cout<<ans;
	//cout<<"NO"; 
}
```


---


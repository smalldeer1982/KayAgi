# 「Wdoi-4」兔已着陆

## 题目背景

铃瑚和清兰是从月之都到达幻想乡的两只月兔。正因为降落到了幻想乡进行调查，因此她们通过开团子屋制作团子出售的方式，在幻想乡生活。

为了应对越发繁荣的市场，她们向河城荷取购置了一台团子机器，可以高效地生产出五颜六色的团子。不同颜色的团子的售价不尽相同。由于每天顾客数量很多，购买的团子数量也不少，所以清兰总是搞不清楚一大堆团子的售价如何。

清兰找到了你，希望你能告诉她每次售出团子时，这些团子的总价格。

## 题目描述

清兰使用河童的机器可以生产出各种各样颜色的团子。她发现，**对于颜色为** $\bm c$ **的团子，它的售价为** $\bm c$。同时，团子机器有个特性，那就是生产出来的团子的颜色必然是一段连续的整数。

为了储存已经生产出来的团子，清兰使用了一种类似于「栈」的结构。在一天的开始，这个栈为空栈。现在有 $n$ 次操作，分为两种：

1. $\colorbox{f0f0f0}{\verb!1 l r!}$ ：团子机器生产出来了颜色为 $l,l+1,\cdots r-1,r$ 的团子。清兰将这些团子**依次**入栈。也就是在栈顶依次加入 $l,l+1,l+2,\cdots r-1,r$ 。
2. $\colorbox{f0f0f0}{\verb!2 k!}$ ：有一位客人想要购买 $k$ 个团子。此时清兰会**依次**从栈顶取出 $k$ 个团子并售出。保证 $k$ 不大于当前栈内的团子个数。

你要做的，就是对于每个操作 $2$ 输出这些团子的总价格。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{stack2.in}/\textit{stack2.out}}$。

---

### 数据范围

- 对于前 $30\%$ 的数据，$n,l,r\le100$。
- 对于另外 $20\%$ 的数据，$l=r$。
- 对于另外 $20\%$ 的数据，$k\le 10$。
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^5$，$0\le l\le r \le 10^6$，$1\le k \le 10^{12}$。

## 样例 #1

### 输入

```
6
1 1 14
2 5
1 14 19
1 1 9
2 8
2 10```

### 输出

```
60
44
124
```

# 题解

## 作者：囧仙 (赞：23)

## 题解

考虑使用一个二元组 $(l,r)$ 表示压入栈中的数据 $l,l+1,l+2\cdots r-1,r$。队列里直接存储这样的二元组。

- 对于操作 $1$，直接压入栈中。

- 对于操作 $2$，不断取出栈顶元素 $(l_0,r_0)$。若它的长度 $r_0-l_0+1$ 不大于当前的 $k$，那么就直接弹出该元素，计入答案，并让 $k$ 减去这个区间的长度；否则我们需要将 $(l_0,r_0)$ 裂成两个二元组 $(l_0,r_0-k)$ 和 $(r_0-k+1,r_0)$。前者重新压入栈中，后者计入答案，然后终止循环。

### 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e6+3;
i64 qread(){
    i64 w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int n,p; pair<int,int> P[MAXN];
int main(){
    n=qread(); up(1,n,i){
        int op=qread();
        if(op==1){
            int l=qread(),r=qread(); P[++p]=make_pair(l,r);
        } else {
            i64 k=qread(); i64 ans=0;
            while(k){
                int l=P[p].first,r=P[p].second,t=r-l+1;
                if(t<=k) ans+=1ll*t*(l+r)/2,k-=t,--p;
                else {
                    ans+=1ll*k*(r-k+1+r)/2;
                    P[p]=make_pair(l,r-k),k=0;
                }
            }
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：Buried_Dream (赞：15)

大家好，由于我非常喜欢线段树，所以我用线段树切了这题。

提供一种复杂度为 $\mathcal{O}(n\log^2n)$ 线段树二分的做法。

我们想一下，我们要用线段树来优化什么操作。

我们想找到某个位置的数量和大于等于 $k$，这个地方显然是可以二分的，但是要用到区间求和。

同时我们用完这些团子之后要清空，但是不一定都是整个都被用了，可能是用了一部分，所以会有单点修改和区间覆盖成 $0$。

到这里线段树做法就很明确了，对于操作建树，对于每个一操作，单点修改。

对于二操作，利用二分找到位置，然后分类讨论。

如果说这个位置到最后的团子的个数恰好等于 $k$，求出区间价值和即为答案，将这一部分清空。

如果说这个位置到最后的团子的个数大于等于 $k$，那只需要把这个位置分出一部分来，然后将剩下的清空即可。



```cpp
/**
 *	author: TLE_Automation
 *	creater: 2022.10.14
 **/
#include<cmath>
#include<queue>
#include<cstdio>
#include<vector>
#include<bitset>
#include<cstring>
#include<iostream>
#include<algorithm>
#define gc getchar
#define int long long
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;
const int mod = 998244353;
const ll inf = 0x3f3f3f3f3f3f3f3f;
#define debug cout << "i ak ioi" << "\n"
inline void print(int x) {if (x < 0) putchar('-'), x = -x; if(x > 9) print(x / 10); putchar(x % 10 + '0');}
inline char readchar() {static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;}
inline int read() { int res = 0, f = 0; char ch = gc();for (; !isdigit(ch); ch = gc()) f |= (ch == '-'); for (; isdigit(ch); ch = gc()) res = (res << 1) + (res << 3) + (ch ^ '0'); return f ? -res : res;}

int sc = 0;

struct Node {
	int l, r, sum, num;
} stc[N];

namespace Seg {
	#define lson rt << 1
	#define rson rt << 1 | 1
	struct node {
		int l, r, len, Cover, sum, num;
	} tree[N << 1];
	inline void pushup(int rt) {
		tree[rt].sum = tree[lson].sum + tree[rson].sum;
		tree[rt].num = tree[lson].num + tree[rson].num;
	}
	inline void build(int rt, int l, int r) {
		tree[rt].l = l, tree[rt].r = r;
		tree[rt].len = r - l + 1, tree[rt].Cover = -1;
		if(l == r) return;
		int Mid = (l + r) >> 1;
		build(lson, l, Mid), build(rson, Mid + 1, r);
	}
	inline void pushdown(int rt) {
		if(tree[rt].Cover == -1) return;
		tree[lson].sum = 0, tree[rson].sum = 0;
		tree[lson].num = 0, tree[rson].num = 0;
		tree[lson].Cover = tree[rt].Cover, tree[rson].Cover = tree[rt].Cover;
		tree[rt].Cover = -1;
	}
	inline void update(int rt, int pos, int W, int Num) {
		if(tree[rt].l > pos || tree[rt].r < pos) return;
		if(tree[rt].l == tree[rt].r) {
			tree[rt].sum = W, tree[rt].num = Num; return;
		} pushdown(rt);
		update(lson, pos, W, Num), update(rson, pos, W, Num);
		pushup(rt);
	}
	inline void change(int rt, int l, int r) {
		if(tree[rt].l > r || tree[rt].r < l) return;
		if(tree[rt].l >= l && tree[rt].r <= r) {
			tree[rt].sum = 0, tree[rt].num = 0;
			tree[rt].Cover = 0; return;
		} pushdown(rt);
		change(lson, l, r), change(rson, l, r);
		pushup(rt);
	}
	inline int Query_sum(int rt, int l, int r) {
		if(tree[rt].l > r || tree[rt].r < l) return 0;
		if(tree[rt].l >= l && tree[rt].r <= r) return tree[rt].sum;
		pushdown(rt); return Query_sum(lson, l, r) + Query_sum(rson, l, r);
	}
	inline int Query_num(int rt, int l, int r) {
		if(tree[rt].l > r || tree[rt].r < l) return 0;
		if(tree[rt].l >= l && tree[rt].r <= r) return tree[rt].num;
		pushdown(rt); return Query_num(lson, l, r) + Query_num(rson, l, r);
	}
}

using namespace Seg;
inline int getans(int l, int r) {
	return ((l + r) * (r - l + 1)) / 2;
}
inline bool Check(int Mid, int k) {
	return (Query_num(1, Mid, sc) >= k);
}

signed main()
{
	int n = read();
	build(1, 1, n);
	for(int i = 1; i <= n; i++) {
		int opt = read();
		if(opt & 1) {
			int l = read(), r = read();
			stc[++sc] = (Node) {l, r, getans(l, r), r - l + 1};
			update(1, sc, getans(l, r), r - l + 1);
		}
		else {
			int k = read();
			int l = 1, r = sc, ans(0);
			while(l <= r) {
				int Mid = (l + r) >> 1;
				if(Check(Mid, k)) ans = Mid, l = Mid + 1;
				else r = Mid - 1;
			}
			if(Query_num(1, ans, sc) == k) {
				int res = Query_sum(1, ans, sc);
				sc = ans - 1;
				print(res), putchar('\n');
				change(1, ans, sc);
			}
			else {
				int res = 0;
				if(ans + 1 <= sc) res = Query_sum(1, ans + 1, sc);
				if(ans + 1 <= sc) k -= Query_num(1, ans + 1, sc);
				int L = stc[ans].l, R = stc[ans].r;
				res += getans(R - k + 1, R);
				R -= k;
				stc[ans] = (Node) {L, R, getans(L, R), R - L + 1};
				update(1, ans, getans(L, R), R - L + 1);
				sc = ans;
				print(res), putchar('\n');
				change(1, ans + 1, sc);
			}
		}
	}	
	return (0 - 0);
}


```

---

## 作者：Mortis_Vampire (赞：11)

## 思路
这道题题面中都提到了栈，当然可以用栈进行维护。

很容易想到的做法是直接进行模拟，把数一个一个存进去，但是这种做法显然会炸。

可以发现题目中存入的是 $l$~$r$ 的数，所以对于每次操作 1，我们只需要向栈顶中存入 $l$ 和 $r$ 两个数。

操作 2 会麻烦一点。我们可以从栈顶一次次弹出区间，每次 $k$ 减去区间大小，直到 $k$ 小于当前栈顶区间的大小，此时需修改栈顶区间的右端点，并加上剩下的一小段。然后对于每个区间的和可以使用等差数列求和公式进行求解。

细节还是很多的，注意一下就可以了。~~建议评黄~~
## 代码
```cpp
#include <cstdio>
#include <iostream>
#define int unsigned long long//以防万一
using namespace std;
int top,n,op,l,r,k,sum;
struct node {
	int l,r;
}a[500005];//栈
inline void read(int &x) {//快读
    x=0;
    register int f=1;
    register char c=getchar();
    while(c<'0'||c>'9') {
        if(c=='-') f=-1;
        c=getchar();
    }
    while (c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-'0',c=getchar();
    x*=f;
}
inline void write(int x){//快吐
	if (x < 0) x = ~x + 1, putchar('-');
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
signed main()
{
	read(n);
	while(n--)
	{
		read(op);
		if(op==1)
		{
			read(a[++top].l);//区间存入栈顶
			read(a[top].r);
		}
		if(op==2)
		{
			read(k);
			sum=0;
			while(k>(a[top].r-a[top].l+1))//注意求区间大小时要+1
			{
				k-=a[top].r-a[top].l+1;
				sum+=(a[top].l+a[top].r)*(a[top].r-a[top].l+1)/2;//等差数列求和公式
				top--;//弹出区间
			}
			l=a[top].r-k+1;
			sum+=(a[top].r+l)*(a[top].r-l+1)/2;
			a[top].r=l-1;//修改栈顶右端点
			write(sum);
			puts("");
		}
	}
	return 0;
}
```


---

## 作者：bmatrix (赞：7)

# P7870 兔已着陆 题解

[题目传送门](https://www.luogu.com.cn/problem/P7870)

~~出题人老东方了~~

蒟蒻第一次使用 $\LaTeX$ ，用的不好还请谅解

前置芝士：[栈（百度百科）](https://baike.baidu.com/item/%E6%A0%88/12808149?fr=aladdin)
### 题意翻译：
有一初始为空的栈 $S$ ，有两种操作：

```
 1 l r
```
在栈顶依次加入元素 $l,l+1,...r-1,r$

```
 2 k
```
将栈顶 $k$ 个元素出栈，并询问它们的和

#### 注意：$1≤k≤10^{12}$ ，不开 ```long long``` 见祖宗

### 暴力思路（50分，开满会炸空间和时间）：
手写一个基本的栈：
```cpp
typedef long long ll;
struct STACK{
    ll stk[N],*_top=stk;//_top为栈顶指针
    
    void push(ll x){
        _top++;
        *_top=x;
    }
    void pop(){ 
        _top--; 
    }
    ll top(){
        return *_top;
    }
    bool empty(){
        return _top==stk;
    }
}stk;

```
~~empty()函数似乎没啥用~~

每次进行1操作，将从 $l$ 到 $r$ 依次 ```push```

每次2操作，令 ```ans=0```，每次 ```ans+=stk.top(),stk.pop();``` 
执行 $k$ 次

思路简单，不多说了，最终结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/foouggrg.png)

### 优化（100分）：
分析入栈元素特点，可以发现它们都是**公差为 $1$ 的等差数列**

因此，可以用一个结构体代替一个等差数列：
```cpp
typedef long long ll;
struct Stk{
    ll l,r;
    ll len(){//数列长度
        return r-l+1;
    }
}_stk[N];
```


则当要**全部取出**这个数列时，其贡献的价值：
```cpp
ll getall(){ 
    return len()*(r+l)/2;//等差数列求和公式，O(1)得出贡献值
}
```
（Stk结构体成员函数）

但有时只会取出此数列的后 $n$ 个（后入栈的先出栈），取出的这 $n$ 个元素依旧是**公差为 $1$ 的等差数列**，只是**首项不再是 $l$**，而是 $r-n+1$

同时取出后的原数列的后 $n$ 项全部清除，因此**取出后的 $r$ 会变成** $r-n$ ，则：
```cpp
ll get(ll n){
    ll res=n*(r+r-n+1)/2;//求和公式
    r-=n;
    return res;
}
```
（Stk结构体成员函数）

我们的栈结构体便可以如下：
```cpp
struct STACK{
    struct Stk{
        ll l,r;
        ll len(){ return r-l+1; }
        ll getall(){ return len()*(r+l)/2;}
        ll get(ll n){
            ll res=n*(r+r-n+1)/2;
            r-=n;
            return res;
        }
    }_stk[N];
    Stk *_top=_stk;
    
    void push(ll l,ll r){
        _top++;
        *_top=(Stk){l,r};
    }
    bool empty(){ return _top==_stk; }
}stk;
```
~~empty()依旧没什么用~~

最后，每次访问栈顶的 $k$ 个元素时，只需要分别看每个等差数列即可

当 $k$ **大于等于**栈顶数列的长度时，则将整个数列**贡献值全部计入并出栈**，并把 $k$ 减去此数列的长度，直到 $k$ 小于栈顶数列的长度

然后，取出此时栈顶数列的后 $k$ 项：
```cpp
ll get(ll k){
    ll res=0;
    while(k>=_top->len()){
        res+=_top->getall();
        k-=_top->len();
        _top--;
    }
    res+=_top->get(k);
    return res;
}
```
（STACK结构体成员函数）

完事了qwq

最终代码：
```cpp
#include<bits/stdc++.h>
#define N 500005
typedef long long ll;
using namespace std;
struct STACK{
    struct Stk{
        ll l,r;
        ll len(){ return r-l+1; }
        ll getall(){ return len()*(r+l)/2;}
        ll get(ll n){
            ll res=n*(r+r-n+1)/2;
            r-=n;
            return res;
        }
    }_stk[N];
    Stk *_top=_stk;
    void push(ll l,ll r){
        _top++;
        *_top=(Stk){l,r};
    }
    ll get(ll k){
        ll res=0;
        while(k>=_top->len()){
            res+=_top->getall();
            k-=_top->len();
            _top--;
        }
        res+=_top->get(k);
        return res;
    }
    bool empty(){ return _top==_stk; }
}stk;
int main(){
    ll n;
    cin>>n;
    while(n--){
        int op;
        scanf("%d",&op);
        if(op==1){
            ll l,r;
            scanf("%d%d",&l,&r);
            stk.push(l,r);
        }
        else{
            ll k;
            scanf("%d",&k);
            printf("%lld\n",stk.get(k));
        }
    }
    return 0;
}
```
__警告：此代码不能直接复制__

---

## 作者：Eason_AC (赞：4)

## Content
对一个栈执行如下操作：

- `1 l r`：依次向栈里面弹入 $l,l+1,\dots,r-1,r$。
- `2 k`：依次从栈里面弹出 $k$ 个数，并求出所有弹出的数的和。

**数据范围：$1\leqslant n\leqslant 10^5$，$0\leqslant l\leqslant r\leqslant 10^6$，$1\leqslant k\leqslant 10^{12}$。**
## Solution
显然，一个一个去暴力弹入弹出显然是不现实的。那么怎么办？一段一段去弹入弹出即可。

首先对于操作 $1$，我们直接把 $[l,r]$ 这一段当做一个元素直接弹入栈里面即可。

关键在于操作 $2$，首先不难发现对于 $[l,r]$ 这一整段，其含有的数的个数为 $r-l+1$，和为 $\frac{(l+r)(r-l+1)}2$。因此，对于能够取出的整段，我们直接暴力不断取出，直到 $k$ 不够取出整段为止。

那么取完整段之后如果 $k$ 不为 $0$ 呢？我们考虑把原来的一段取出并拆成两段：一段是 $[l,r-k+1]$，另一段是 $[r-k+1,r]$。我们要取出来的就是 $[r-k+1,r]$ 这一段，并且不难求出这一段的和为 $\frac{(2r-k+1)k}2$。把右半段取出，统计入总和并把左半段作为一个新的整段弹入栈里面就好了。

那么这道题目就做完了，具体实现可以手写栈也可以直接用 stl 中的 stack 容器。
## Code
为了偷懒直接 `#define int ll` 了（ 
```cpp
namespace Solution {
    #define int ll
    struct node {int l, r;};
    stack<node> q;

    iv Main() {
        MT {
            int op, x, y; read(op);
            if(op == 1) read(x, y), q.push((node){x, y});
            else {
                read(x);
                ll ans = 0;
                while(!q.empty() && x >= (q.top().r - q.top().l + 1)) x -= q.top().r - q.top().l + 1, ans += 1ll * (q.top().l + q.top().r) * (q.top().r - q.top().l + 1) / 2, q.pop();
                if(x) {
                    node cur = q.top(); q.pop();
                    ans += 1ll * (cur.r - x + 1 + cur.r) * x / 2;
                    cur.r -= x, q.push(cur);
                }
                write(ans), puts("");
            }
        }
        return;
    }
    #undef int
}
``` 

---

## 作者：Gokix (赞：4)

[P7870](https://www.luogu.com.cn/problem/P7870)

小清新题。在竞速赛中比往年 pjT2 的小模拟要好多了。

------------

考虑把一段连续价格团子打包丢到栈里。

对于一操作，我们直接把这一段团子打成一个包丢栈里。

对于二操作，我们不断取出栈顶，看看这个团子包的团子数是否满足需求。满足就更改这个团子包的团子数再丢回栈里；不满足就扔掉这个包并把需求数减去这个包的团子数。边看团子数边用一个变量记录售价。由于我们每次扔掉或更改一个团子包的时一定是扔掉或更改一个等差数列，所以直接等差数列求和即可简单统计售价。

时间复杂度是均摊 $O(n)$ 的。考虑对于每个二操作，删除的团子包个数不会超过一共有的团子包个数，也就是不超过 $n$ 个。所以一共删除的团子包个数也不会超过 $n$ 个。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
using namespace std;

inline long long read(){char ch=getchar();long long x=0,f=1;while(ch<'0' || ch>'9'){if(ch=='-') f=-1;ch=getchar();}while('0'<=ch && ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
inline void write(long long x){if(x<0){putchar('-');x=-x;}if(x>9) write(x/10);putchar(x%10+'0');}

long long n;
struct tz{
	long long l,r;
};
stack <tz> s;

int main(){
	long long i,j,u,v,op;
	n=read();
	while(n--){
		op=read();
		if(op==1){
			u=read();v=read();
			s.push(tz{u,v});
		}
		else if(op==2){
			u=read();
			long long ans=0;
			while(!s.empty()){
				tz gx=s.top();s.pop();
				if(u>=gx.r-gx.l+1){
					u-=(gx.r-gx.l+1);
					ans+=(gx.l+gx.r)*(gx.r-gx.l+1)/2;
				}
				else{
					ans+=(gx.r-u+1+gx.r)*(u)/2;
					gx.r-=u;
					s.push(gx);
					break;
				}
			}
			write(ans);putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：theStarMaster (赞：3)

## P7870 兔已着陆
### 1.解题过程 ：
比赛时读完题后先想的是手写个栈暴力搞，后来看见 $k \leqslant 10^{12} $ 后就知道此题数组开不下，然后就想怎么开数组才能搞这道题一看操作数 $n \leqslant 5 * 10^5$，完全可以开数组，然后又看见了插入的数是 $l$ 到 $r$ 的等差数列，所以利用等差数列求和公式就可以免去枚举了。
### 2.细节
（对于每个 $1$ 操作记一下 $l$ , $r$ , 下文的块）  
首先看到 $k \leqslant 10 ^{12}$ ， 就知道这必然要开 $long ~ long$ （要不是测了大样例我就折在这了）。  
其次就是取数的过程，我们先 $k$ 减大块，大块清零，$ans$ 加上大块的 $l$ 到 $r$ 序列和，减完后（$k$ 小于下一个块的长度），下一个块的 $r$ 减去剩下的 $k$ ， $ans$ 加上所删的序列和。
### 3.代码
```cpp
#include<bits/stdc++.h>
using namespace std ;
#define int long long
class StarMaster
{
	public :
	inline int read()
	{
		int x = 0 , f = 1 ;
		char ch = getchar() ;
		while(ch > '9' || ch < '0')
		{
			if(ch == '-') f = -1 ;
			ch = getchar() ;
		}
		while(ch >= '0' && ch <= '9')
		{
			x = (x << 1) + (x << 3) + (ch ^ 48) ;
			ch = getchar() ;
		} 
		return x * f ;
	}
	struct node
	{
		int l , r ;
	}a[5000010] ;
	int n , tot ;
	inline void work()
	{
		n = read() ;
		for(int i = 1 ; i <= n ; ++ i)
		{
			int opt = read() ;
			if(opt == 1)
			{
				a[++ tot].l = read() , a[tot].r = read() ;
			}	
			else
			{
				int k = read() ;
				long long sum = 0 ;
				while(k > a[tot].r - a[tot].l + 1) 
				{
					k -= (a[tot].r - a[tot].l + 1) ;
 					sum += (a[tot].r + a[tot].l) * (a[tot].r - a[tot].l + 1) / 2 ;
					tot -- ;
 				}
				if(k == 0)
				{
					cout << sum << '\n' ;
					continue ;
				}
				int l = a[tot].r - k + 1 ;
				sum += (a[tot].r + l) * k / 2 ;
				a[tot].r -= k ;
				cout << sum << '\n' ;
			}
		}
	}
} Star ;
signed main()
{
	Star.work() ;
	return 0 ;
}
```
完结撒花٩(๑>◡<๑)۶

---

## 作者：cyhyyds (赞：2)

## 思路：

我们用一个结构体数组存储输入的各个区间，记录区间和，区间左端点，区间右端点和区间长度。

处理询问操作时，我们不断将 $k$ 对每个区间的长度进行比较。

如果 $k$ 大于当前区间长度，答案直接累加当前区间和，继续比较。

如果 $k$ 小于当前区间长度，答案从当前区间的右端点加 $k$ 个数，然后将当前区间的右端点减去 $k$，再更新区间长度和区间和即可。

也就是说，答案的左端点就是当前区间的右端点减去 $k$ 再加一。

利用等差数列求和公式，代码就可以这样写：

`ans += (a[pos].r + a[pos].r - k + 1) * k / 2;`




## 代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef unsigned long long ll;

const int N = 3e6 + 7;
const int inf = 0x3f3f3f3f;

#define int ll

int n, pos = 0;

struct Array {
	int l;
	int r;
	int len;
	
	ll sum;
}a[N];

signed main () {
    scanf ("%llu", &n);
    
    for (int i = 1; i <= n; i ++) {
    	int op, l, r;
		
		ll k;
    	
        scanf ("%llu", &op);
        
        if (op == 1) {
           	scanf ("%llu%llu", &l, &r);
            
            a[++ pos].l = l;
            
            a[pos].r = r;
            
            a[pos].len = r - l + 1;
            
            a[pos].sum = (a[pos].r + a[pos].l) * a[pos].len / 2;
            
            //等差数列求和。 
        }
        
        else if (op == 2) {
            scanf ("%llu", &k);
            
            ll ans = 0;
            
            while (k) {
            	if (k >= a[pos].len) {
            		k -= a[pos].len;
					
					ans += a[pos].sum;
					
					pos --;
				}
				
				else {
					ans += (a[pos].r + a[pos].r - k + 1) * k / 2;
					//当前区间取k个数，用等差数列求和。 
					
					a[pos].r -= k;
					
					a[pos].len = a[pos].r - a[pos].l + 1;
					
					a[pos].sum = (a[pos].l + a[pos].r) * a[pos].len / 2;
					
					k = 0;
				}
			}
            
            printf ("%llu\n", ans);
        }
    }
    
    return 0;
}
```


---

## 作者：a1ioua (赞：2)

这是一道简单的模拟题，但是如果完全按照模拟做（一个一个元素插入栈），只会得到 $\text{50 pts}$，所以我们需要优化。  
怎么优化？  
我们虽然不可以一个一个插入栈，但是我们可以一个区间一个区间插入。我们可以用 STL 的 `pair<..., ...>` 来实现（但是我所编写的程序里用了 `struct`）。  
然后我们就可以分情况讨论。
1. $\text{op}=1$：很简单，直接插入结构体。
1. $\text{op}=2$：一个一个结构体给，给 $k$ 个。一个结构体不足 $k$，取一部分，然后等差数列求和求出总和即可。 

这样，我们即可得到 $\text{95 pts}$，再加上 `long long` 即可获得 $\text{100 pts}$

------------
~~懒~~代码：
```cpp
// lr _; 也是因为 懒
#include <bits/stdc++.h>
using namespace std;
struct lr {
    long long l, r;
};
stack<lr> s;
signed main() {
    int n;
    scanf("%d", &n);
    while (n--) {
        int op;
        scanf("%d", &op);
        if (op - 2) { // 懒
            lr _;
            scanf("%lld%lld", &_.l, &_.r);
            s.push(_);
        } else {
            long long k, ans = 0;
            scanf("%lld", &k);
            while (k) {
                lr _ = s.top(); s.pop();
                if (_.r - _.l + 1 <= k) k -= _.r - _.l + 1, ans += (_.r - _.l + 1) * (_.l + _.r) / 2;
                else {
                    long long rr = _.r + 1 - k;
                    ans += (rr + _.r) * (_.r - rr + 1) / 2;
                    _.r = rr - 1;
                    k = 0;
                    s.push(_);
                }
            }
            printf("%lld\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：言琢დ (赞：0)

根据题意模拟。

考虑用一个栈结构来维护我们所需要的信息。

首先操作一直接入栈，没什么好说的。

操作二根据取的团子的个数，进行分类讨论：

- 能全部取完，就直接取出对应的一个“块”。
- 不能全部取完，就取出一部分，并修改对应“块”所代表的区间。

详见代码即可。

```cpp
#include<cstdio>
#define int long long
inline int in();
inline void wr(int);
struct Node{
	int l,r;
};
const int N=(int)5e5+5;
Node stack[N];
int Len;
inline int sum(int,int);
signed main(signed argc,char**argv){
#ifndef ONLINE_JUDGE
	freopen("B.in","r",stdin);
	freopen("B.out","w",stdout);
#endif
	register int n=in();
	for(register int i=1;i<=n;++i){
		register int tp=in();
		if(tp==1){
			register int l=in(),r=in();
			stack[++Len]=(Node){l,r};
		}
		else{
			register int k=in(),ans=0;
			while(k>0){ // 接着取
				register Node u=stack[Len];
				if(u.r-u.l+1<=k){ // 全部取走
					ans+=sum(u.l,u.r);
					k-=u.r-u.l+1;
					--Len;
				}
				else{ // 只取一部分
					ans+=sum(u.r-k+1,u.r);
					stack[Len].r-=k;
					k=0;
				}
			}
			wr(ans),putchar('\n');
		}
	}
}
inline int sum(int l,int r){
	return (l+r)*(r-l+1)/2; // 这里用一个求和公式来计算贡献
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```

---


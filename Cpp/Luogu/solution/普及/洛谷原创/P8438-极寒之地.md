# 极寒之地

## 题目背景

238 神教 #1

在古老的传说中，南极企鹅是全知全能的真神，它们能轻易做到任何我们做不到的事情。在南极洲的广袤大陆上，没有任何生物能对它们构成威胁。

所幸，神并不是高高在上，对尘世不屑一顾的。经常有果敢的人类来到这里，运气好的话，能和神结为挚友——这是幸运的，因为神不需要从你这里得到什么，而它的力量却会一直庇佑你，直到永远。

而你是一位探险家，对传说的内容十分向往。在经历了不知多久的苦索之后，你终于找到了些许神迹，并成功地找到了传说中的“神”。

——并且是两位，但是……

## 题目描述

神正在辅导孩子做数学题。在神批评孩子的心算结果从低到高第
```plain
17409488245517115276142322168576189279543123341138742779319865028602486509006138934460661849637882913598407636154209737260165754120014607177773359981826603801250947835120164061898414398808778383710734965109968348499255333743808806819897228289078158612425862653924618211976295200391819532525867722941969825549125083939679976935766582544161633553282536186214629150364929344059634288758125744444293077873038252037297534321132535122264070340053106750045495648216831484920706070567384926577457983022367155402606111730048301290388577089307478371008345014562035666767719162727651399592653244427923731578583241159510645308913474636528103155221748236303528072259108507905341048592541395827961771903417533241290874568077431363019042931482055932874814355268929594505880132227031337095583783793918280184860930087635658394839764586155196454253268266394562535661446268255101517600243362823434368473980088051436392198234023198989135142538928701481935979801475550928245044051159083872693810338480154137358569089360697894156
```
位就错了并且居然花了 
```plain
0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000215055865
```
秒才算完的时候，神的孩子发现了你，并要求你来验算一遍。

你当然做不到，于是你请求缩小数据范围，而神同意了。神说，你是个勇敢的探险者，在把这道题算完之后，会与你成为朋友。

现在，你只需要解决的是这么一个问题了：

给定一个正整数 $n$ 和自然数序列 $a_1,a_2,\cdots,a_n$。你需要对每一个 $0\le S\le 2^n-1$，求出数 $S$ 的“权值”。

一个数 $S$ 的权值 $v(S)$ 的计算方式是：把它写成二进制，如果它从低到高第 $x$ 位为 $1$，就把答案异或（xor）上 $a_x$。

神不想刻意刁难你，他只希望你把所有 $v(S)$ 求出来之后，把答案分别乘上对应的 $S$，然后异或起来，取模 $2^{64}$ 再交给他就好了。

你心知这个问题是很好算的。但是你还是希望尽量快地把结果求出，以成为神的朋友。

那么，加油吧！

## 说明/提示

**本题采用捆绑测试。**

|数据点编号|$n$|分值|空间限制|子任务编号|
|----|----|----|----|----|
|$1\sim3$|$=20$|$10$|$\texttt{256MB}$|0|
|$4\sim6$|$=25$|$40$|$\texttt{256MB}$|1|
|$7\sim10$|$\le30$|$50$|$\texttt{8MB}$|2|

对于 $100\%$ 的数据，$1\le n\le 30,0\le a_i\le 2^{64}-1$。

---

### 样例解释

用 $\bigoplus$ 表示 异或。

对于第一个样例，$\text{Ans}=(0\times 0)\bigoplus(1\times 1)\bigoplus(2\times 2)\bigoplus(3\times 3)\bigoplus(4\times 3)\bigoplus(5\times 2)\bigoplus(6\times 1)\bigoplus(7\times 0)\bigoplus(8\times 4)\bigoplus(9\times 5)\bigoplus(10\times 6)\bigoplus(11\times 7)\bigoplus(12\times 7)\bigoplus(13\times 6)\bigoplus(14\times 5)\bigoplus(15\times 4)=16$。

---

本题不需要刻意卡常，$\texttt{1.4s}$ 已经是出题人最大的善良了，如果还跑不过那基本就一定是算法不优了。

## 样例 #1

### 输入

```
4
1 2 3 4```

### 输出

```
16```

## 样例 #2

### 输入

```
30
15942549000714163495 14973783748924019241 11750608274629447103 3841514779926491634 1491087352666302822 3926467265136890882 2165405652723005667 16850040541486744638 9389207531715430944 2453094189961991688 17306424574086088540 4253088488420240522 6711268779219669357 7357305029308027009 10742286389669332463 16939477641403891687 14194800553999397870 17414698597200046696 18113730556943709454 3735103125227126629 16235879363688955717 14861602169195639258 903677597641043180 12364536150445169736 14881735759803865853 14781978421412291657 872796319752083876 11301016179769629644 14385296580178382407 3946726419982234649 ```

### 输出

```
13929368580789239808
```

# 题解

## 作者：chen_zhe (赞：35)

> cz 过了，用的是点名被卡但是卡卡常就能冲过去的写法。

本题的最大难点在于，对洛谷评测机的效率的高度了解。

----

首先，不难根据题目中对于 $v(S)$ 的定义，暴力地计算出最后的结果。因为答案是对 $2^{64}$ 取模，因而可以直接采用 `unsigned long long` 进行全程的运算，直接自然溢出啥事没有。

如果你手写去拆二进制速度是慢的。这里可以使用内建函数 `__builtin_ffs(x)`，返回 $x$ 中最后一个为 $1$ 的位是从后向前的第几位。可以将拆二进制位的一个 $\log $ 的复杂度去掉。

参考代码如下：

```cpp
for (int i=1;i<(1<<n);i++)
{
	for (int j=__builtin_ffs(i);j;j--)
		ret^=a[j];
	ans^=ret*i;
}
```

如果你提交这个代码，你会发现在 $n=25$ 的情况下跑了 79ms。而当 $n=30$ 的情况下应该要多跑 $32$ 倍的时间，也就是 2.5s。

我们考虑对这个循环进行一定的优化。我们考虑对于相邻 $4$ 个正整数的二进制串，那么它们的末尾将会是如下的循环：$\texttt{00}$、$\texttt{01}$、$\texttt{10}$、$\texttt{11}$。

而对于 $\texttt{01}$、$\texttt{10}$、$\texttt{11}$ 的部分我们可以只需要分别让 `ret` 异或上 `a[1]`、`a[1] xor a[2]`、`a[1]` 即可。对于 $\texttt{00}$ 的部分，再暴力跑 `for (int j=__builtin_ffs(i);j;j--)` 这层循环。可以让调用 `__builtin_ffs()` 函数的次数变成原来的 $\dfrac{1}{4}$，而且也减少了新定义变量的次数。

此外，将对 `ret` 和 `ans` 两个变量的计算进行了上述的展开，本质也会加速 CPU 的流水线调度，进一步地去优化常数。这样，你的代码就足以通过此题了。实际上这样做的常数是相当优秀的（循环展开相当于除以 $4$，对 `__builtin_ffs()` 循环的优化也大幅度减小了常数，而且本身这个循环就很难跑到 $n$ 次的）。如果你实测一下的话会发现，内层循环跑了恰好 $2^n$ 次，因而可以通过本题。

代码如下：

```cpp
int n;

unsigned long long a[33],ret=0,ans;

int main()
{
	n=read();
	for (int i=1;i<=n;i++)
		a[i]=read();
	int i;
	for (i=1;i+4<(1<<n);)
	{
		ret^=a[1];
		ans^=ret*(i++);
		ret^=a[1]^a[2];
		ans^=ret*(i++);
		ret^=a[1];
		ans^=ret*(i++);
		for (int j=__builtin_ffs(i);j;j--)
			ret^=a[j];
		ans^=ret*(i++);
	}
	ret^=a[1];
	ans^=ret*(i++);
	ret^=a[1]^a[2];
	ans^=ret*(i++);
	ret^=a[1];
	ans^=ret*(i++);
	cout << ans << endl;
	return 0;
}
```

实际上，洛谷评测机的速度是足以支持在 1 秒内进行 $1.2 \times 10^9$ 次 `unsigned long long` 类型变量相乘并且自然溢出的。所以如果是小常数 $O(2^n)$，$n=30$ 是能跑的。

这里就需要指出另外一种做法：将高低位拆分之后暴力合并去计算。这样的做法的时间复杂度也是很高的，因为它要将两个 $65536$ 大小的数组去合并运算。但是实际上跑的是非常非常快的。

```cpp
for(i=0;i<lim1;i++)
{
	for(j=0;j<lim2;j++)
    		ans^=(dp[i]^dp2[j])*(unsigned long long)(i+j*lim1);
}
```

实际上我们可以使用如下代码获得洛谷评测机的 CPU 型号：

```cpp
#include <stdint.h>
#include <iostream>
#include <cpuid.h>
static void cpuid(uint32_t func, uint32_t sub, uint32_t data[4]) {
    __cpuid_count(func, sub, data[0], data[1], data[2], data[3]);
}
int main() {
    uint32_t data[4];
    char str[48];
    for(int i = 0; i < 3; ++i) {
        cpuid(0x80000002 + i, 0, data);
        for(int j = 0; j < 4; ++j)
            reinterpret_cast<uint32_t*>(str)[i * 4 + j] = data[j];
    }
    std::cout << str;
}
```

可得洛谷 CPU 型号为 `Intel(R) Xeon(R) Platinum 8369HC CPU @ 3.30GHz`。然而由于这个是阿里云定制 CPU，其实很难查到它的参数数据。

但是与其同一代的 CPU `Intel(R) Xeon(R) Platinum 8360HC CPU @ 3.00GHz` 的 Cache 大小是 33MB，而有着 24 个核心，也就是说每个核心有着 1.375MB 的高速缓存，足以存下两个大小为 65536 的 unsigned long long 数组。当这些数组进入高速缓存（实际上应该是 L3 cache）之后，其读写效率是显著快于在内存中的读写的（快 4 倍左右）。此外，合并的过程做的都是连续的内存访问，有着很好的空间局部性，也减少了常数。因而，它在 $O(2^n)$ 的复杂度下能够跑的很快。

---

## 作者：N2MENT (赞：16)

### 极寒之地

十分诡异的题

***

求 

$$\sum^{n}_{S = 0}v(S) \bmod 2^{64}$$ 

$$v(S) = \bigoplus^{\left \lfloor \log_2S \right \rfloor }_{i=0} a_{i + 1}\times (S \& 2^i) $$

范围：

$s\in[0,2^n) $

$n \leq 30$

***

$2^{30} = 1073741824$ 纯暴力几乎死翘翘了，考虑优化。在求和过程中 $S$ 是连续的整数，那么只要能直接通过 $v(S)$ 求出 $v(S+1)$ 就有机会通过。

因为异或的自反性，十分容易发现 $v(S+1)=v(S)\oplus v(S \oplus (S + 1))$，而 $S\oplus (S+1)$  是末尾连续的 $1$，我们只要求 $a_i$ 的前缀异或和就可以 $O(1)$ 计算 $v(S + 1)$。时间复杂度是 $O(2^n+n)$。

可是 $2^n$ 最大有 $10^9$，这时候，有一个 gnu 的自带函数就派上用场了：```__builtin_ffs()```。这个函数可以用极快的速度求出 $S$ 最低位 $1$ 的位置，即 $S\oplus (S + 1)$ 最高位 $1$ 的位置。


***

AC 代码（尽管是暴力但跑得飞快）：

```cpp
#include<bits/stdc++.h>
#define ll unsigned long long
using namespace std;
const int maxn = 40;
ll xsum[maxn];
ll a[maxn];
ll ans;
int n;
int ms;
signed main(){
	scanf("%d", &n);
	ms = (1 << n) - 1;
	for(int i = 1; i <= n; i++){
		scanf("%llu", &a[i]);
		xsum[i] = xsum[i - 1] ^ a[i];
	}
	ll val = 0;
	for(ll s = 1; s <= ms; s++){
		val ^= xsum[__builtin_ffs(s)];
		ans ^= val * s;
	}
	printf("%llu", ans);
}
```

---

## 作者：lsj2009 (赞：4)

## 题目大意
 
给定序列 $\{a_n\}$，$V(s)$ 表示若 $s$ 在二进制表示下从右到左地 $i$ 位为 $1$，则将 $V(s)$ 异或上 $a_i$。

求 $\bigoplus\limits_{i=0}^{2^n-1} V(i)\times i$。

## 思路

考虑暴力，先枚举 $1\sim 2^n-1$ 的每个数，然后依次计算 $V(i)$ 的值，再异或起来即可。复杂度 $O(n\cdot2^n)$，可过前 $20$ 分。

逆向思维，与其我们枚举 $i$，不如枚举 $i$ 在二进制下的每一位（共 $n$ 位）是 $0$ 还是 $1$，然后填入 $i$，这样子可以通过两种方法实现：

- DFS，这样做时间复杂度 $O(2^n)$，空间复杂度 $O(n)$（搜索树最深深度为 $n$）。

- DP，这样做时间复杂度 $O(2^n)$，空间复杂度 $O(2^n)$。

看见 $n\le30$，$2^n\approx10^9$，然后标签里有 ``O2`` 的字样，说不定可过？

但是交上去 DFS 却看见 ``TLE`` 的字样，稍加分析可知是常数过大；交上去 DP 去看见 ``MLE`` 的字样，显然是数组过大，无法优化。

既然 DP 已经无法优化，那我们再考虑 DFS，经过若干次卡常之后，我们发现普通的深搜完全无法通过此题，接下来我们就介绍一种优化搜索高端技艺：meet in  the middle 即中途相遇法。

我们可以考虑将前 $\lfloor\frac{n}{2}\rfloor$ 的取值先确定下来，存在一个数组 $\{b_m\}$ 里，然后再枚举后 $\lceil\frac{n}{2}\rceil$ 位，每一次枚举完成再与前已经枚举完成的 $m$ 种方案一一配对，显然这样包含所有结果。

再说说时间复杂度：第一次 DFS 时间复杂度 $O(2^{\frac{n}{2}})$，$m=2^{\frac{n}{2}}$，而第二次遇到边界时有 $2^\frac{n}{2}$ 种情况，每种情况又要与前 $m$ 个 $b_i$ 一一配对，时间复杂度 $O(2^n)$。
 
似乎我们并没有进行什么优化，但事实真的如此吗？前面讨论到 DFS ``TLE`` 的真正原因是因为常数过大，而在这里，我们又恰好使用中途相遇法优化掉了这一点，所以以此思路可以取得 ``AC`` 的好成绩。

当然，meet in  the middle 算法不仅仅使用在优化常数上，多数情况下，他往往能将 $2^k$ 优化至 $2^{\frac{k}{2}}$。

## Code:
```cpp
#define int __int128
using namespace std;
const int N=35;
int a[N],n;
vector<PII> vec;
void dfs(int x,int s,int val) {
	if(x==n/2)
		return (void)vec.push_back(mk(s,val));
	dfs(x+1,s^a[x],val|(1<<x));
	dfs(x+1,s,val);
}
int dfs2(int x,int s,int val) {
	if(x==n) {
		int ans=0;
		_for(i,0,vec.size()-1)
			ans^=(vec[i].F^s)*(vec[i].S+val);
		return ans;
	}
	return dfs2(x+1,s^a[x],val|(1<<x))^dfs2(x+1,s,val);
}
signed main() {
	cin>>n;
	_for(i,0,n-1)
		cin>>a[i];
	dfs(0,0,0);
	cout<<dfs2(n/2,0,0);
	return 0;
}
```

最后再留几道 meet in  the middle 算法的练习题：

1.  P2962 [USACO09NOV]Lights G。

2.  P4799 [CEOI2015 Day2] 世界冰球锦标赛。

3.  P3067 [USACO12OPEN]Balanced Cow Subsets G。


---

## 作者：BJ_BSGF_Lyc (赞：3)

# 题解：P8438 极寒之地

## 思路

这道题可以使用**格雷码**。所谓格雷码，它的解释如下：
```
格雷码属于可靠性编码，是一种错误最小化的编码。
虽二进制码可直接由数模转换器转换成模拟信号，但在特例情况下：
如 (3)10 转换成 (4)10 时二进制码的每一个码位都需要改变，
能使数字电路产生极大的尖峰电流脉冲。
但是格雷码却没有这一个缺点，它在相邻位间进行转换时，
只有一码位发生变化。它很好地解决了普通编码的逻辑混淆问题。

也就是说：格雷码是指两数编码后的二进制数只有一位数不同，另且格雷码中 Min 数与 Max 数仅一位编码不同。

如下图，二进制数编码与格雷码编码仅有一码位之差，并且在二进制码中，数位不是 0 就是 1，所以在转化成格雷码的时候，一般都是直接将二进制数编码的最高码位到
最低码位依次判断，直到查找到第一个一个为 0 的码位，将此数位的数替换成 1：
```
![](https://cdn.luogu.com.cn/upload/image_hosting/iewzaofc.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

## 解法

所以，就出现了格雷码的解法。我们可以直接维护所有子集，并且使用 ```__builtin_ctz()``` 来维护修改的数位。~~其实用 ffs() 也不是不可以。~~

那么我们配合按位异或、按位与，就可以直接写出 AC 代码。

## 代码

```cpp
#include<bits/stdc++.h> //万能头
using namespace std;
int n,s=0;
unsigned long long a[35],ans,tot; //防止自溢，用 unsigned long long 类型
int main(){
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=1;i<(1<<n);i++){
        int t=(i)&(-i); //直接按位与
        tot^=a[__builtin_ctz(t)]; //依次按位异或
        s^=t;
        ans^=tot*s;
    }
    cout<<ans<<endl; //输出结果，下课！
    return 0;
}
```

---

## 作者：TLE_MLE_RE (赞：2)

# [P8438](https://www.luogu.com.cn/problem/P8438) 极寒之地

这是本蒟蒻发的第一篇题解，有错误欢迎指正

进入正题~

## Ⅰ·题意概述
这个问题实际上是一个位操作和异或运算的问题。题目要求我们计算对于给定的正整数序列 $ a_1, a_2, \ldots, a_n $，对于所有 $ 0 \leq S \leq 2^n - 1 $ 的数 $ S $，计算其“权值” $ v(S) $，然后把所有 $ S \times v(S) $ 异或起来，最后取模 $ 2^{64} $。

“权值” $ v(S) $ 的定义是：将 $ S $ 写成二进制形式，如果它的第 $ x $ 位（从低到高）是 $ 1 $，那么 $ v(S) $ 就与 $ a_x $ 做异或运算。由于 $ a_x $ 已经是给定的，我们只需要考虑 $ S $ 的二进制表示。

这个问题可以通过以下步骤解决：

### 初始化
创建一个长度为$ n $ 的数组 $ b $，其中 $ b[i] $ 表示 $ a_i $ 需要乘以 $ 2^i $ 的次数。初始时，所有 $ b[i] $ 都为 0。

### 计算权值
遍历 $ b $ 数组，对于每个 $ b[i] $，如果 $ b[i] $ 大于 0，则 $ a_i $ 需要乘以 $ 2^i $ 这么多次。将 $ a_i $ 与 $ b[i] $ 做 $ 2^i $ 次异或运算。

### 累加结果
将所有 $ a_i $ 累加起来，得到最终结果。

### 取模操作
将最终结果对 $ 2^{64} $ 取模，得到最终输出。

## 伪代码&代码
```
// 伪代码
BEGIN
    // 读取 n 的值
    READ n

    // 初始化 w 数组，读取 a_i 值
    FOR i FROM 0 TO n-1
        READ w[i]

    // 计算 f 数组，f[i] 存储 i 的二进制表示中 1 的个数小于等于 n/2 的所有 i 的异或和
    FOR i FROM 1 TO (1 << (n / 2)) - 1
        t = 找到 i 的最低位的 1
        f[i] = f[i - (i 的最低位的 1)] XOR w[t]

    // 计算 g 数组，g[i] 存储 i 的二进制表示中 1 的个数大于 n/2 的所有 i 的异或和
    FOR i FROM 1 TO (1 << (n / 2 + 1)) - 1
        t = 找到 i 的最低位的 1
        g[i] = g[i - (i 的最低位的 1)] XOR w[t + n / 2]

    // 初始化结果 res 为 0
    res = 0

    // 计算所有 S 的权值并累加
    FOR i FROM 1 TO (1 << n) - 1
        // 计算 f 和 g 的交叉异或结果，并乘以 i
        Xor = (f[i 的低 n/2 位] XOR g[i 的高 n/2 位]) * i
        // 将结果累加到 res 上，并进行异或操作
        res = res XOR Xor

    // 输出最终结果
    PRINT res
END
```
说实话，我这伪代码长得很不像伪代码。。。

直接祭上代码吧
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 35, M = 1 << 16;
unsigned long long w[N];
unsigned long long f[M], g[M];
int lowbit(int x){return x & -x;}
int main(){
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) cin >> w[i];
    for (int i = 1; i < (1 << (n / 2)); i ++ ){
        int t = log2(lowbit(i));
        f[i] = f[i - lowbit(i)] ^ w[t];}
    for (int i = 1; i < (1 << (n / 2 + 1)); i ++ ){
        int t = log2(lowbit(i));
        g[i] = g[i - lowbit(i)] ^ w[t + n / 2];}
    unsigned long long res = 0;
    for (unsigned long long i = 1; i < (1 << n); i ++ ){
        unsigned long long Xor = (f[i & ((1 << (n / 2)) - 1)] ^ g[i >> (n / 2)]) * i;
        res ^= Xor;}
    cout << res;return 0;}
```
${\color{white} 码风独特，请勿贺代码 {}}$

以上就是本篇的全部内容~

---

## 作者：初星逝者 (赞：1)

（前置知识：格雷码）

格雷码本身性质如下：

> 在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，则称这种编码为格雷码（Gray Code），另外由于最大数与最小数之间也仅一位数不同，即“首尾相连”，因此又称循环码或反射码。

题目大意：

求 $\displaystyle\sum_{S=0}^{2^n-1}v(S) \times S$

$v(S)=\displaystyle\bigoplus_{i\in(0,n-1)}a_x~\text{（S二进制中第 ~i~ 位中为 1 的）}$

首先暴力肯定是行不通的，那么我们考虑化简一些不必要的步骤，也是一些做题的小技巧。

- 考虑对 $\displaystyle\sum_{S=0}^{2^n-1}v(S)$ 进行化简能不能不跑 $2^n$ 次呢？显然是不行的，因为我们每一次答案的累计都是根据 $v(S)$ 和 $S$ 两个值算出来的，所以无法化简。

- 那么这时候我们就知道，$2^n$ 已经是 $1073741824$ 了，时限给的 $1.4s$，那么就意味着我们每次算 $v(S)$ 的时候必须是 $O(1)$ 的，就这个思路，我们尝试去发现我们可以根据格雷码的性质来完成此题。

仿照格雷码的方法，每次枚举子集的时候只改变一个数来维护当前的数列。

其实整体思路想到这一步，代码实现也比较简单了。

### AC code
------

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
int n,S;
ll a[35],ans=0,sum;
int main(){
	cin >> n;
	for(int i=0;i<n;i++)cin>>a[i];
	for(int i=0;i<(1<<n);i++)ans^=(sum^=a[__builtin_ctz(i&(-i))])*(S^=(i&-i));
	cout<<ans;
	return 0;
}
```

---

## 作者：cloud2764scallop_eve (赞：1)

## 思路
看了一些 dalao 的题解，没太懂，自己学习了一下。

需要引入一个定义：[格雷码](https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858)。  
> 格雷码属于可靠性编码，是一种错误最小化的编码方式，因为虽然二进制码可以直接由数/模转换器转换成模拟信号，但在某些情况，例如从十进制的 3 转换为 4 时二进制码的每一位都要变，能使数字电路产生很大的尖峰电流脉冲。而格雷码则没有这一缺点，它在相邻位间转换时，只有一位产生变化。它大大地减少了由一个状态到下一个状态时逻辑的混淆。  
——[二进制与格雷码互相转换](https://zhuanlan.zhihu.com/p/451408535)

引入格雷码有一个极大的优势，就是使用格雷码可以**每次只修改一个数**。

所以，有了格雷码这样的做法，我们可以维护所有子集，用 `__builtin_ctz()` 来维护当前修改的数位。~~（主要是我不会 `__builtin_ffs()` 做这道题）~~

## 代码
```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N = 35;
int n, s = 0;
ull a[N], ans, tot;
int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
		scanf("%llu", &a[i]);
	for (int i = 1; i < (1 << n); i++)
	{
		int t = (i) & (-i);
		tot ^= a[__builtin_ctz(t)], s ^= t, ans ^= tot * s;
	}
	printf("%llu\n", ans);
	return 0;
}
```
> 自然溢出，用 `unsigned long long`

---

## 作者：船酱魔王 (赞：1)

# P8438 极寒之地 题解

## 题意回顾

定义一个数的权值为二进制表示上从低到高所有为 $ 1 $ 的位的位置的 $ a $ 值异或再乘上这个数，求出从 $ 0 $ 到 $ 2^n-1 $ 所有数的权值的异或和。

$ n \le 30 $。

## 分析

很容易设计出对于每个数暴力求权值的算法，时间复杂度为 $ O(n2^n) $，感觉过不去。

根据测试，洛谷评测机 1s 跑 $ 10^9 $ 是勉强可以的，因此 $ O(2^n) $ 即可通过，而乘上本身和总体求异或和是是 $ O(2^n) $ 的，时间复杂度瓶颈在于所有 $ 1 $ 位 $ a $ 值异或和这一步。

考虑到异或运算的结合律，因此可以先算前一半位再算后一半位，再一起异或，但是时间复杂度还是 $ O(n2^n) $。

可以发现前/后一半位的结果只和这一半位的值相关，因此可以提前预处理出所有前/后一半位的结果再对于每个数 $ O(1) $ 求权值。

代码很短。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ull unsigned long long
using namespace std;
const int N = 32;
const int S = 32768;
int n;
ull a[N];
ull b[S];
ull c[S];
int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for(int i = 0; i < 32768; i++) {
		for(int j = 16; j <= 30; j++) {
			if(i & (1 << (j - 16))) {
				b[i] ^= a[j];
			}
		}
		for(int j = 1; j <= 15; j++) {
			if(i & (1 << (j - 1))) {
				c[i] ^= a[j];
			}
		}
	}
	ull ans = 0;
	int mx = (1 << n) - 1;
	int rg = (1 << 15) - 1;
	for(int i = 0; i <= mx; i++) {
		ans ^= (b[i >> 15] ^ c[i & rg]) * i;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：yummy (赞：1)

最近在给小朋友们备“位运算”这一节的课，在洛谷搜罗题目的时候发现这么一个非同寻常的题目。

目前我们看到，这题目前只能卡常完成，也就是枚举每个 $S$，然后尽快计算出 $v(S)$。但是，目前我看到的几篇题解都是希望在给定 $v(S)$ 的时候通过计算前缀和以及 `__builtin_ffs` 来快速敲掉 $v(S)$ 的一个前缀并加入一个数。

那么，有没有一种方法枚举子集，使得我们每次可以只改变一个数呢？

有的，格雷码就是例子。

所以我们使用格雷码维护所有子集，就可以保证每次只需要修改一个数，不需要使用前缀和技巧。但是递归常数非常感人，因此好像相比于维护当前要改的数位，还是直接 `__builtin_ctz` 快一点。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
unsigned long long a[32],ans,total;
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		scanf("%llu",&a[i]);
	int S=0;
	for(int stt=1;stt<(1<<n);stt++)
    //stt记录哪些数翻过哪些没翻过
	{
		int lbt=(stt)&(-stt),bit=__builtin_ctz(lbt);
        //修改数位的位值，以及哪一位要修改
		total^=a[bit];
		S^=lbt;//S以格雷码顺序枚举
		ans^=total*S;
	}
	printf("%llu\n",ans);
}
```

---


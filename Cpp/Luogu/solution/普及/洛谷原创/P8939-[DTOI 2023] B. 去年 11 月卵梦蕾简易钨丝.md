# [DTOI 2023] B. 去年 11 月卵梦蕾简易钨丝

## 题目背景

# 大样例已修复

![](https://cdn.luogu.com.cn/upload/image_hosting/4il8fn7w.png)

## 题目描述

给定序列 $\{a_n\}$，支持两种形如 `opt x` 操作：

1. `1 x`：删除一个数 $x$，若序列中没有 $x$，则输出 $-1$ 并跳过本次操作，**若有多个 $x$，则仅删除一个**。

2. `2 x`：向序列中插入一个数 $x$。

**对于每个未被跳过的操作**，试求出 $a$ 的一个排列 $p$，最小化 $\sum \limits_{i=1}^{n} \lvert p_{i+1}-p_i\rvert$ 的值，即最小化 $\lvert p_2-p_1\rvert+\lvert p_3-p_2\rvert+\dots+\lvert p_{n+1}-p_n\rvert$ 的值，其中 $p_{n+1}=p_1$。

**保证任意时刻序列内至少有 $1$ 个数。**

---
$p$ 是 $a$ 的排列当且仅当对于 $\forall x$，$\sum [p_i=x]=\sum [a_i=x]$。

简而言之，$p$ 是 $a$ 经过某种方式重排后的结果。 

例如 $\{1,1,4,5,1,4\}$ 是 $\{1,5,4,1,4,1\}$ 的一个排列，但是 $\{1,5,4,1,4,7\}$ 不是。

## 说明/提示

#### 【样例 1 解释】
对于第一个询问，删除了序列中的数 $4$，则当前序列为$ 1, 2, 3, 10 $， 可以证明 $18$ 为当前序列的最小答案。
	
对于第二个询问，删除了序列中的数 $10$，则当前序列为$ 1, 2, 3 $， 可以证明 $4$ 为当前序列的最小答案。
	
对于第三个询问，向序列中添加了一个数 $9$，则当前序列为$ 1, 2, 3, 9 $， 可以证明 $16$ 为当前序列的最小答案。

#### 【样例 2】

见附加文件中的 `abs/abs2.in` 与 `abs/abs2.out`。

该样例满足测试点 $1\sim 4$ 的限制。

#### 【样例 3】

见附加文件中的 `abs/abs3.in` 与 `abs/abs3.out`。

该样例满足测试点 $7\sim 10$ 的限制。

#### 【数据范围与提示】
记 $w$ 为值域大小，对于所有测试数据，保证 $n,q\leq 10^6$，$0\leq w\leq 10^6$。
	
每个测试点的具体限制见下表：

| 测试点编号 | $n,q\leq$ | $w$ |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $100$ | $10$ |
| $5\sim 6$ | $10^3$ | $10^3$ |
| $7\sim 10$ | $10^6$ | $10^6$ |


## 样例 #1

### 输入

```
5 3
1 2 3 4 10
1 4
1 10
2 9```

### 输出

```
18
4
16```

# 题解

## 作者：mc123456 (赞：10)

## 分析

首先可以发现一个性质，当 $p$ 单调不降时，$\sum\limits_{i = 1}^{n}{|p_{i + 1} - p_i|}$ 可以取得最小值，这也很好理解。可以想象每个 $p_i$ 都映射到数轴上，那么从最小的 $p_i$ 出发再走回来至少要经过一个来回，即 $\sum\limits_{i = 1}^{n}{|p_{i + 1} - p_i|} \geq 2 \cdot (\max{p} - \min{p}))$，且一定可以取等。

那么我们只需要维护序列的极值即可，由于序列可能有重复，所以这里用 `multiset` 维护。

时间复杂度 $O((n + q) \log{n})$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long

int n, q;
multiset<int> s;

signed main()
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
    cin >> n >> q;
    for (int i = 1, a; i <= n; i++)
        cin >> a, s.emplace(a);
    while (q--)
    {
        int op, x;
        cin >> op >> x;
        if (op == 1)
        {
            auto it = s.find(x);
            if (it == s.end())
            {
                cout << -1 << endl;
                continue;
            }
            s.erase(it);
        }
        else
            s.emplace(x);
        cout << (*(--s.end()) - *s.begin()) * 2 << endl;
    }
}
```

---

## 作者：InoueTakina (赞：4)

~~首先嘲笑一下小狗哥哥 -154。~~

## 题解报告
### 算法 1

- 我会枚举全排列！但是出题人似乎没有给我 $n\leq 10$。
- 我会观察性质！注意到相同的数一定放在一起，所以相同的数可以看作一个，因此我们只关心某个数有或者没有，然后就可以愉快的枚举啦！
- 综合时间复杂度 $\mathcal{O}(q\times w!)$。期望得分 $40$。

### 算法 2

- 我会猜结论！所有数升序排列时答案最小，这个结论不难证明是正确的。具体证明可以通过考察序列最大值和最小值求出下界。
- 整理一下柿子，发现答案是 $2\times (\max-\min)$。
- 维护 $\max,\min$，可以用 `std::set` 实现。
- 综合时间复杂度 $\mathcal{O}((n+q)\log n)$，期望得分 $100$ 分。

---

## 作者：WsW_ (赞：3)

### 思路
要找一个数据结构，支持：  
* 插入一个数
* 删除一个数
* 查询最大和最小值

要求的式子，显然当排列 $p$ 有序的时候答案最小，这时答案就是 $2\times(\max(p_i)-\min(p_i))$。  
可以通过画数轴来验证。

可以用平衡树维护，我选择偷懒用 STL。  
由于插入的数字可以重复，所以用可重集 `multiset` 维护。  
[`multiset` 简介](https://oi-wiki.org/lang/csl/container/)

插入直接 `insert(x)` 即可，但删除不能直接 `erase(x)`，这会直接删除集合中所有的 $x$。  
如果想只删除集合中一个 $x$，应该用 `erase(迭代器)`。可以通过 `s.lower_bound(x)` 查找获取迭代器。  
注意判断查找到的那个数和 $x$ 是否相等，如果不相等就按题目要求输出 `-1` 并跳过操作即可。

最大值和最小值对应的迭代器分别是 `--s.end()` 和 `s.`

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,q;
int a;
int opt;
multiset<int>s;
multiset<int>::iterator it;

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>q;
	while(n--){
		cin>>a;
		s.insert(a);
	}
	
	while(q--){
		cin>>opt>>a;
		if(opt==1){
			it=s.lower_bound(a);
			if(*it!=a){
				cout<<-1<<'\n';
				continue;
			}
			s.erase(it);
		}
		else s.insert(a);
		int ans=*(--s.end())-*s.begin();
		cout<<2*ans<<'\n';
	}
	return 0;
}
```

---
### 评分
为什么打出这么低的评分？

我个人认为这是非常一眼的 STL 题，而且很板。  
通过给一个式子来拉高题目难度，但实际上这个式子非常常见，也很一眼。

---

## 作者：zymooll (赞：2)

### 写在前面

本文章介绍的方法都在 NOI 大纲难度系数 1-5 之内的算法.

### 题目大意

对于一个序列 $q$，有以下操作：

- 删除一个数 $x$，若序列中无此数，则输出 ```-1```.

- 添加一个数 $x$.

给定序列 $q$ 的初始状态和操作序列，需要求出每次操作后，$(q_{\max}-q_{\min})\cdot2$ 的值.

### 题目思路

首先先解释原来题目给定的公式是如何转变为 $(q_{\max}-q_{\min})\cdot2$ 的.

题目那个公式用人话说，就是把序列中两个相邻的数的差求绝对值后加起来，所以想要求出最小的公式解，也就是使序列中两个相邻的数的差求绝对值后的值最小.

对于一个序列来说，我们可以将序列中相邻两个数作为线段的两端，映射到一个轴上，可以发现，轴上的值域 $R\in[q_{\min},q_{\max}]$，而且线段连起来必定成环，根据该性质，我们可以发现，当序列不严格单调递增/减时有最小值.

根据该结论，题目便可以化简为 $(q_{\max}-q_{\min})\cdot2$.

而我们需要做的就是动态求出序列的 $q_{\max}$ 和 $q_{\min}$.

### 实现思路

```priority_queue``` 优先队列，具有“优先级高的先出，优先级低的后出”的性质，放在该题中，我们可以通过定义不同的优先级，便可以有效动态求出序列的 $q_{\max}$ 和 $q_{\min}$.

我们建立 $w$ 个桶（$w$ 为题目中所指的值域），来计算序列中每个数的数量.

另外，我们也需要建立两个优先队列存储 $q_{\max}$ 和 $q_{\min}$ 的优先队列.

对于下文所指的 ```直接添加``` 和 ```直接删除``` 操作，即对对应桶进行加一操作和减一操作.

对于每次删除操作，有以下可能：

- 序列中 $x$ 的个数大于 $1$，直接删除，因为对 $q_{\max}$ 和 $q_{\min}$ 无影响.

- 序列中 $x$ 的个数等于 $1$，若 $x$ 为 $q_{\max}$ 或 $q_{\min}$ 则说明需要更新 $q_{\max}$ 或 $q_{\min}$，更新后方可直接删除；反之，则直接删除.

- 序列中 $x$ 的个数小于 $1$，输出 ```-1```.

对于每次添加操作，有以下可能：

- 序列中 $x$ 的个数大于 $0$，直接添加.

- 序列中 $x$ 的个数等于 $0$，需要更新 $q_{\max}$ 和 $q_{\min}$，后直接添加.

- 序列中 $x$ 的个数不可能小于 $0$.

对于删除时更新 $q_{\max}$ 或 $q_{\min}$ 的操作，我们需要将存储 $q_{\max}$ 或 $q_{\min}$ 的优先队列，循环弹出直到序列中有该数.

对于添加时更新 $q_{\max}$ 和 $q_{\min}$ 的操作，我们需要将其压入存储 $q_{\max}$ 和 $q_{\min}$ 的优先队列.

### 代码参考

注：为排版美观，头文件和快读快写已被省去.

```cpp
// Author:zymooll

int n,q;
int p[1000010];
priority_queue<int,vector<int>,greater<int> >qmin;
priority_queue<int,vector<int>,less<int> >qmax;
signed main(){
	n=read(),q=read();
	for(int i=1;i<=n;i++){
		int ls=read();
		p[ls]++;
		if(p[ls]==1){
			qmin.push(ls);
			qmax.push(ls);
		}
	}
	for(int i=1;i<=q;i++){
		int opt=read();
		if(opt==1){
			int x=read();
			if(!p[x]){
				print(-1);
				putchar('\n');
				continue;
			}
			p[x]--;
			if(x==qmax.top()&&!p[x]){
				do{
					qmax.pop();
				}while(!p[qmax.top()]);
			}
			if(x==qmin.top()&&!p[x]){
				do{
					qmin.pop();
				}while(!p[qmin.top()]);
			}
			print((qmax.top()-qmin.top())*2);
			putchar('\n');
		}
		if(opt==2){
			int x=read();
			p[x]++;
			if(p[x]==1){
				qmin.push(x);
				qmax.push(x);
			}
			print((qmax.top()-qmin.top())*2);
			putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：Cure_Wing (赞：1)

[P8939 [SSOI 2023 easy Round] B. 去年 11 月卵梦蕾简易钨丝](https://www.luogu.com.cn/problem/P8939)

### 解法

首先看到 $p$ 数组这么多数，又是求一个排列，还有绝对值，于是就想到把这些数投影到数轴上：

![](https://cdn.luogu.com.cn/upload/image_hosting/9t9hunj4.png)

以序列 $\{1,2,3,6,8\}$ 为例，投影到数轴上如上图。

那么题目中绝对值的含义即为点与点的距离，绝对值之和即为依次连线的长度和。

显而易见的连线顺序为 $1\to2\to3\to6\to8\to1$，因为这样来回均为直线，长度肯定最小，此时长度为 $14$。

如果 $2\to6\to3$，中间的路被走了两边，肯定不优秀。

这个思路反映到 $p$ 上就是要保证 $p_i\le p_{i+1}$，于是我们对求的值化简得到 $2|p_n-p_1|$，即所求答案为序列中最大值与最小值的差的两倍。

那么整个序列所要求的最小值只与极值有关系了，对于每次修改，只需维护区间最大值和最小值即可。

这里使用优先队列维护，利用插入删除时打标记说明数是否有效。

时间复杂度 $O((n+q)\log(n+q))$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
using std::cin;using std::cout;
constexpr int N=1000006;
int n,q,a,opt,in[N],out[N],out2[N];
std::priority_queue<int>b;
std::priority_queue<int,std::vector<int>,std::greater<int> >c;
signed main(){
	// freopen("abs3.in","r",stdin);
	// freopen("abs.out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	cin>>n>>q;
	for(int i=1;i<=n;++i){
		cin>>a;
		b.push(a);c.push(a);++in[a];//插入计数
	}
	for(int i=1;i<=q;++i){
		cin>>opt>>a;
		if(opt==1){
			if(in[a]==0){cout<<-1<<'\n';continue;}
			else{++out[a];++out2[a];--in[a];}//应当弹出标记
		}else{b.push(a);c.push(a);++in[a];}//插入标记
		while(!b.empty()&&out[b.top()]){--out[b.top()];b.pop();}//弹出不应存在的最大值
		while(!c.empty()&&out2[c.top()]){--out2[c.top()];c.pop();}
		cout<<(b.top()-c.top())*2<<'\n';//结论计算
	}
	return 0;
}
```

---

## 作者：Vct14 (赞：0)

显然当 $p$ 序列单调不下降时，$\sum \limits_{i=1}^{n} \lvert p_{i+1}-p_i\rvert$ 的值最小，否则会重复计算。

此时取 $p_1=a_{\min},p_n=a_{\max}$，因此 $\sum \limits_{i=1}^{n} \lvert p_{i+1}-p_i\rvert=\lvert p_n-p_1\rvert+\lvert p_1-p_n\rvert=2(p_n-p_1)=2(a_{\max}-a_{\min})$。

用一个多重集合 `multiset`（可以有序地存储元素的容器）维护最大值和最小值即可。

---

## 作者：qzhwlzy (赞：0)

### 题目大意

有一个序列 $a$，维护以下操作：

1. 删除一个数（有多个删一个，没有输出 `-1`）；
2. 插入一个数。

每次操作后，找到对于 $a$ 的所有排列 $p$，$\sum\limits_{i=1}^n |p_{i+1}-p_i|$（其中 $p_{n+1} = p_1$）的最小值。

### 思路

先考虑如何找到 $\sum\limits_{i=1}^n |p_{i+1}-p_i|$ 的最小值。对于绝对值，可以把这些数看作是数轴上的一些点 $(p_i,0)$，绝对值看作它们之间的距离。那么可以看出 $p$ 在单调时可以取到式子的最小值。因为考虑四个数 $a_1\le a_2\le a_3\le a_4$，一定有 $|a_2-a_1|+|a_3-a_2|+|a_4-a_3| \le |a_3-a_1|+|a_2-a_3|+|a_4-a_2|$，因为后者多走了两次 $a_3-a_2$。

所以我们只需要维护 $a$ 的最值即可。维护可以使用 `multiset`。其中 `find` 取某个元素的迭代器，`erase` 删除某元素，`begin` 找最小值的迭代器，`rbegin` 找最大值的迭代器。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<set>
using namespace std;
int n,q,opt,x; multiset<int> s;
int main(){
	scanf("%d%d",&n,&q); for(int i=1;i<=n;i++) scanf("%d",&x),s.insert(x);
	while(q--){
		scanf("%d%d",&opt,&x);
		if(opt==1){
			multiset<int>::iterator it=s.find(x);
			if(it==s.end()){printf("-1\n"); continue;}else s.erase(it);
		}else s.insert(x); printf("%d\n",(*s.rbegin()-*s.begin())*2);
	}
	return 0;
}
```

---

## 作者：escapist404 (赞：0)

# P8939 B. 去年 11 月卵梦蕾简易钨丝 题解

## 题意简述

* 给定序列 $\{a_n\}$，值域为 $w$，支持两种形如 `opt x` 操作共 $q$ 次：

* `1 x`：**删除一个数 $x$**。若序列中没有 $x$，则输出 `−1`，并跳过本次操作；若有多个 $x$，则仅删除一个。

* `2 x`：**向序列中插入一个数 $x$**。

* 对于每个未被跳过的操作，试求出 $a$ 的一个排列 $p$，最小化 $\sum \limits_{i=1}^{n} \lvert p_{i+1}-p_i\rvert$ 的值，即最小化 $\lvert p_2-p_1\rvert+\lvert p_3-p_2\rvert+\dots+\lvert p_{n+1}-p_n\rvert$ 的值，其中 $p_{n+1}=p_1$。**保证任意时刻序列内至少有 $1$ 个数**。

* $w,n,q \le {10}^6$。

## 最小化决策

先考虑最小化的决策问题，观察式子 $\lvert p_2-p_1\rvert+\lvert p_3-p_2\rvert+\dots+\lvert p_{n+1}-p_n\rvert$（下记为 $S$），这里的若干个绝对值符号给了我们一些思路，我们设想一种特殊情况：

若满足 $\forall i \in [1, n - 1]$，都有 $p_{i + 1} \ge p_{i}$，则有：

$$\begin{aligned}
S
& = p_2 - p_1 + p_3 - p_2 + \dots + p_{k} - p_{k - 1} + p_{k + 1} - p_{k} + \dots + p_n - p_{n - 1} - p_{n + 1} + p_n\\
& = p_n - p_1 + p_n - p_{n + 1}\\
& = 2 (p_n - p_1)
\end{aligned}$$

这样，我们就说，当满足序列各项单调递增时，$S$ 的值为序列中最大值与最小值之差的两倍。

自然，一个投机的想法就是，当序列恰好单调递增时，原式 $S$ 取得最小值。这就要求我们证明：

**设原序列的某个排列依次有（这些数位置上不一定连续） $\{p_{k - 1}, p_{k}, p_{k + 1}, p_{k + 2}\}$，且满足 $p_{k - 1} \le p_{k} \le p_{k + 1} \le p_{k + 2}$，调换 $p_k$ 和 $p_{k + 1}$ 的位置，记调换前的式子值为 $S_1$，调换后的式子为 $S_2$。求证：$S_2 \ge S_1$。**

证明此题并不复杂，下面给出笔者的拙劣过程：

> $S_1$ 和 $S_2$ 中有若干相同的项。消去这些项，可知原题等价于
$$\lvert p_{k + 1} - p_{k - 1} \rvert + \lvert p_{k + 2} - p_k \rvert \ge \lvert p_{k + 2} - p_{k + 1} \rvert + \lvert p_k - p_{k - 1} \rvert$$
由 $p_{k - 1} \le p_{k} \le p_{k + 1} \le p_{k + 2}$，知绝对值符号内各项均为非负。
直接打开绝对值符号，即要证
$$ p_{k + 2} - p_{k - 1} + p_{k + 1} - p_k \ge p_{k + 2} - p_{k - 1} - p_{k + 1} + p_k $$
显然成立，取等条件是 $p_{k + 1} = p_k$。

对于 $p_{n + 1}$ 的情况，可以等同于 $p_1$ 的情况处理。

由此我们知道：**对于一个单调递增的序列，交换其中的两项，不可能把答案变小（因为存在相等的情况）**。

这样，决策的正确性得以证明，应用贪心一路无阻。

## 维护最值

### 朴素做法

解决了最小化的决策问题之后，原问题实际上转化为：**维护一个数据结构，每次询问添加或删除一个元素，同时能够回答所有元素的最大值和最小值之差的二倍。**

本题中，$n,q \le {10}^6$，每次询问时直接枚举，复杂度 $\mathcal{O}(qn)$，超时。

注意到值域限制，我们定义一个桶 `tot[1000005]` 来维护元素，并使用变量 `maxn` 和 `minn` 维护最大值和最小值。每次添加时，只需执行 `tot[x]++` 即可。但面对删除操作时，假若删去的刚好是最值，由于要对桶遍历以更新最大值或最小值，这个桶就可能失效。

假设此时有元素 $1$ 和 $1000000$，反复删除和添加元素 $1$ 各 $500000$ 次，每次都要扫完这个桶，最坏复杂度是 $\mathcal{O}(qw)$，但数据比较友好，笔者的程序仍能通过本题。

hack 数据生成：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    freopen("hack.in", "w", stdout);
    printf("2 1000000\n");
    printf("1 1000000\n");
    for(int i = 1; i <= 500000; i++)
    {
        printf("1 1\n");
        printf("2 1\n");
    }
    return 0;
}
```

笔者的程序（[赛时提交记录](https://www.luogu.com.cn/record/99749734)）：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int tot[1000005], maxn = 0, minn = 0x7f7f7f7f, n, q, x;
inline ll read()
{
    ll x = 0, w = 1;
    char ch = 0;
    do
    {
        if(ch == '-')
            w = -1;
        ch = getchar();
    }   while(!isdigit(ch));
    do
    {
        x = (x << 3) + (x << 1) + ch - '0';
        ch = getchar();
    }   while(isdigit(ch));
    return x * w;
}
inline void print(ll x)
{
    static int s[35], d = 0;
    do
    {
        s[++d] = x % 10;
        x /= 10;
    }   while(x);
    do
    {
        putchar(s[d--] + '0');
    }   while(d);
    return;
}
int main()
{
    n = read(), q = read();
    for(int i = 1; i <= n; i++)
        x = read(), tot[x]++, maxn = max(maxn, x), minn = min(minn, x);
    for(int i = 1; i <= q; i++)
    {
        int op = read();
        if(op == 1)
        {
            x = read();
            if(tot[x])
            {
                tot[x]--;
                if(!tot[x])
                    if(maxn == x)
                        while(!tot[--maxn]);// 可能导致超时
                    else if(minn == x)
                        while(!tot[++minn]);// 可能导致超时
                print((maxn - minn) << 1);
                putchar('\n');
            }
            else
                printf("-1\n");
        }
        else
        {
            x = read(), tot[x]++, maxn = max(maxn, x), minn = min(minn, x);
            print((maxn - minn) << 1);
            putchar('\n');
        }
    }
    return 0;
}
```

### 优化做法

我们当然不能止步于此。众所周知，**堆**能够以 $\mathcal{O}(\log n)$ 的时间复杂度插入任意元素、删除堆顶元素，且能以 $\mathcal{O}(1)$ 的时间复杂度查询最大或最小值，但不能方便地查询某个元素是否存在。为了克服这一弊端，我们可以同时维护一个桶和两个堆（分别维护最大值和最小值），时间复杂度为 $\mathcal{O}((n + q)\log n)$，足以通过本题。

~~喜闻乐见的~~代码环节：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int tot[1000005], n, q, x;
priority_queue <int, vector<int>, less<int> > q_max;
// 定义优先队列（即堆） q_max 维护最大值。
// "int" 指堆维护的变量类型，"vector<int>" 指堆的底层容器，less<int> 是比较方式（越小越后出堆）
priority_queue <int, vector<int>, greater<int> > q_min;

// 快读模板
inline ll read()
{
    ll x = 0, w = 1;
    char ch = 0;
    do
    {
        if(ch == '-')
            w = -1;
        ch = getchar();
    }   while(!isdigit(ch));
    do
    {
        x = (x << 3) + (x << 1) + ch - '0';
        ch = getchar();
    }   while(isdigit(ch));
    return x * w;
}
inline void print(ll x)
{
    static int s[35], d = 0;
    do
    {
        s[++d] = x % 10;
        x /= 10;
    }   while(x);
    do
    {
        putchar(s[d--] + '0');
    }   while(d);
    return;
}
int main()
{
    n = read(), q = read();
    for(int i = 1; i <= n; i++)
    {
        x = read(), tot[x]++;
        q_max.push(x);
        q_min.push(x);
    }

    for(int i = 1; i <= q; i++)
    {
        int op = read();
        if(op == 1) // 删除操作
        {
            x = read();
            if(tot[x])
            {
                tot[x]--;
                while(!tot[q_max.top()])
                    q_max.pop();    // 去除不存在的最值
                while(!tot[q_min.top()])
                    q_min.pop();
                print((q_max.top() - q_min.top()) << 1);
                putchar('\n');
            }
            else
                printf("-1\n"); // 元素不存在
        }
        else
        {
            x = read(), tot[x]++;
            q_max.push(x);
            q_min.push(x);
            print((q_max.top() - q_min.top()) << 1);
            putchar('\n');
        }
    }
    return 0;
}
```

---


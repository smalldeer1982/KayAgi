# [YsOI2022] NOIp 和省选

## 题目背景

Ysuperman 为了检验他的教学水平，决定给幼儿园的小朋友们来两场摸底考试！

## 题目描述

其中一场考试有四道题目，满分 $400$；另一场考试有六道题目，满分 $600$。每个人每场考试得分都是一个 $0$ 到满分间的一个**非负整数**（可以为 $0$ 或者满分）。

有 $n$ 名同学参加了这两场考试，其中第 $i$ 名同学第一场得分 $a_i$，第二场得分 $b_i$，Ysuperman 通过以下规则计算第 $i$ 名同学的**标准得分** $c_i$：

1. 分别统计两场比赛的最高分 $A,B$，有 $A\ne 0$，$B\ne 0$。
2. 令 $c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$，其中 $c_i$ **四舍五入保留到整数**。

在算出了每位同学的标准得分后，Ysuperman 粗心地弄丢了每位同学的原始分，你能帮 TA 找到任意一组可能的原始分吗？

简单来说，已知 $n$ 和每位同学的**标准得分** $c_{1\sim n}$，Ysuperman 希望你找到一组合法的 $a_{1\sim n}$，$b_{1\sim n}$ 满足上述要求。

特别的，有个十分强的小朋友 Qiu 在两场考试中都拿到了**最高分**，也就是保证 $c_1=2000$。另外其他小朋友水平都差不多，所以保证有 $\forall i>1,c_i\in [10,1990]$。

## 说明/提示

样例一中构造的 $a,b$ 合法，理由如下：

两场比赛最高得分分别为 $233$ 和 $525$。

$1000\times (233\div 233 + 525\div 525)=2000$。

$1000\times (147\div 233 + 361\div 525) \approx 1318.520\approx 1319$。

$1000\times (200\div 233 + 324\div 525)\approx 1475.512\approx 1476$。

$1000\times (0\div 233 + 523\div 525)\approx 996.190\approx 996$。

前 $20\%$ 的数据保证 $n\le 20$。

另外 $20\%$ 的数据保证 $c_i$ 是 $10$ 的倍数。

另外 $20\%$ 的数据保证 $c_i$ 是 $5$ 的倍数。

另外 $20\%$ 的数据保证 $c_i$ 是 $2$ 的倍数。

对于 $100\%$ 的数据，满足 $1\le n\le 10^4$，$c_1=2000$，$\forall i>1,c_i\in[10,1990]$。

## 样例 #1

### 输入

```
4
2000
1319
1476
996```

### 输出

```
233 525
147 361
200 324
0 523```

## 样例 #2

### 输入

```
4
2000
1704
1658
1542```

### 输出

```
400 454
352 374
352 353
320 337```

# 题解

## 作者：untrigintillion (赞：9)

# [YsOI2022]NOIp和省选！

先把题目和样例说一下，方便解释（

## 题目描述

其中一场考试有四道题目，满分 $400$；另一场考试有六道题目，满分 $600$。每个人每场考试得分都是一个 $0$ 到满分间的一个**非负整数**（可以为 $0$ 或者满分）。

有 $n$ 名同学参加了这两场考试，其中第 $i$ 名同学第一场得分 $a_i$，第二场得分 $b_i$，Ysuperman 通过以下规则计算第 $i$ 名同学的**标准得分** $c_i$：

1. 分别统计两场比赛的最高分 $A,B$，有 $A\ne 0$，$B\ne 0$。
2. 令 $c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$，其中 $c_i$ **四舍五入保留到整数**。

在算出了每位同学的标准得分后，Ysuperman 粗心地弄丢了每位同学的原始分，你能帮 TA 找到任意一组可能的原始分吗？

简单来说，已知 $n$ 和每位同学的**标准得分** $c_{1\sim n}$，Ysuperman 希望你找到一组合法的 $a_{1\sim n}$，$b_{1\sim n}$ 满足上述要求。

特别的，有个十分强的小朋友 Qiu 在两场考试中都拿到了**最高分**，也就是保证 $c_1=2000$。另外其他小朋友水平都差不多，所以保证有 $\forall i>1,c_i\in [10,1990]$。

## 样例

### 样例输入 #1

```
4
2000
1319
1476
996
```

### 样例输出 #1

```
233 525
147 361
200 324
0 523
```

## 解法

显然，样例里给的输出构造，需要大量的四舍五入计算，太复杂了，所以我们希望能给出一个不需要四舍五入的构造方式。

显然，每一场比赛的 “标准得分” 都为 $1000$, 所以我们希望这场比赛的最高分能被 $1000$ 整除

由于两场比赛的满分分别为 $400$ 和 $600$, 我们自然就想到了让 Qiu 小朋友分别得 $200$ 和 $500$ 分，则每一位小朋友的标准得分为

$$c_i = 5 \cdot a_i + 2 \cdot b_i$$

（ $\frac{1000}{2}$ 和 $\frac{1000}{5}$ 互质，所以可以保证对于 $[10,1990]$ 的分数均有解。 ）

于是：

```cpp
cout<<"200 500\n";
```

然后对于每一个小朋友的分数，我们希望用不多于 $200$ 个 $5$ 和不多于 $500$ 个 $2$ “处理“ 掉小朋友的标准得分。

因为 $2$ 小于 $5$, 所以我们就想到先用 $5$ 处理奇数分数，再用偶数个 $5$ 尽可能处理掉剩余的分数。所以我们就能得到下面的代码：

```cpp
if(a%2==1)a-=5,one++;
if(a<=990){one+=2*(a/10);a%=10;}
else one+=198,a-=990;
```

这里 `one` 指的是 ~~NOIp 的分数~~ 第一场考试的分数，`a` 指的是某个小朋友的标准分数。

然后只需要处理剩余的分数即可。从代码可以轻易看出，此时剩余未处理的分数一定是偶数。

```cpp
two+=a/2;
```

这里 `two` 指的是 ~~省选的分数~~ 第二场考试的分数。

到这里这道题就做完了。

上大家喜闻乐见的代码片段：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();
    int t,n;
    cin>>t>>n;
    t--;
    cout<<"200 500\n";
    while(t--){
        int a;
        cin>>a;
        int one=0,two=0;
        if(a%2==1)a-=5,one++;
        if(a<=990){one+=2*(a/10);a%=10;}
        else one+=198,a-=990;
        two=a/2;
        cout<<one<<" "<<two<<endl;
    }
}
```

## 后记

我说怎么这么少人打比赛呢，原来是 Unrated...

这题也可以使用不定方程构造解的方法，但是还是要考虑个数上限的问题。

可以通过枚举证明这题不四舍五入得分的做法是唯一的，这里不再赘述。

至于用到四舍五入的做法，我太菜了，不会做，这里我姑且理解为出题人在秀自己的数据构造（

这是本蒟蒻提交的第 `6` 篇题解。

---

## 作者：Paris_Commune (赞：3)

### 分析

令 $A=a_1=400,B=b_1=500$ ，将 $a,b$ 从 $0$ 枚举到 $A,B$ ， $1000(\frac{a}{A}+\frac{b}{B})$ 可以取遍 $[10,1990]$ (即使会四舍五入)，只需要枚举每个 $c\in[10,1990]$ 的答案即可。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,t[10005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>t[i];
	} 
    cout<<"400 500\n";
    for(int i=2;i<=n;i++){
        int k;
        if(t[i]%2==0){
        	k=8;
		}
        else k=3;
        if(t[i]>=1000)k+=990;
        cout<<int(k*0.4)<<" "<<(t[i]-k)/2<<'\n';
    }
    return 0;
}
```

---

## 作者：zzyxl_qaq (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8948)

### 思路

首先，在算标准分时，我们发现括号外的系数是1000，而两场考试的分数分别是400和600，此时我们可以构造1000的因数，例如令 $ A = 200 , B = 500$，这时我们将公式化简得 $ 5 a_{i} + 2b_{i} = c_{i} $，这是一个标准的二元一次不定方程，两边模2得到结果：

$ a_{i} \equiv c_{i} \pmod 2 $

所以我们对 $ c_{i} $ 分类讨论：

若 $ c_{i} \equiv 1 \pmod 2 $，则 $ a_{i} \equiv 1 \pmod 2 $ ，可以使 $ a_{i}=1 $；

若 $ 2 \mid c_{i} $，则 $ 2 \mid a_{i} $ ，可以使 $ a_{i}=0 $。

这样，我们可以写出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int stu[10005];
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%d",&stu[i]);
    printf("200 500\n");//A=200,B=500
    for(int i=2;i<=n;++i){
        if(stu[i]%2==1)printf("1 %d\n",(stu[i]-5)/2);//c[i]为奇数
        else printf("0 %d\n",stu[i]/2);//c[i]为偶数
    }
}
```
但这样我们只能得到[4分](https://www.luogu.com.cn/record/100040231)，这是为什么呢？

请看下面一组数据：
```
2
2000
1999
```
这样，我们的代码在第二行会输出 `1 997`，但是B为500，而 $ 500 < 997 $，因此这样输出是错误的。这样，我们可以做一个判断，如果 $ b_{i} > 500 $，则让 $ b_{i} \gets b_{i} - 5 , a_{i} \gets a_{i} + 2 $。

这样，我们就能写下AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int stu[10005];
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%d",&stu[i]);
    printf("200 500\n");
    for(int i=2;i<=n;++i){
        if(stu[i]%2==1){
            int a=1,b=(stu[i]-5)/2;
            while(b>500)b-=5,a+=2;
            printf("%d %d\n",a,b);
        }
        else{
            int a=0,b=stu[i]/2;
            while(b>500)b-=5,a+=2;
            printf("%d %d\n",a,b);
        }
    }
}
```


---

## 作者：yujinning (赞：2)

## 前言

本道题是构造题，因此题目做法会与正常做法不太一样。

## 题目大意

给定 $n$ 和 $c_i  (i∈[1,n])$ , 自行定义 $A$ 和 $B(A\leqslant400,B\leqslant600)$ ，找出一组 $a_i$ 和 $b_i$ ，使得$c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$，其中 $c_i$ **四舍五入保留到整数**。

## 解法

对于 $A$ 和 $B$ ，令 $A=a_1=400,B=b_1=600$ ，就可以找到 $a_i$ 和 $b_i$ 满足全部的 $c_i(1\leqslant c_i \leqslant 2000)$。

**证明过程如下：**

设 $a_i=x,b_i=y,c_i=z$ ，有 $c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$。

即 $z=1000(\frac{x}{400}+\frac{y}{600})$。

化简后 $3x+2y=\frac{6}{5}\cdot z$。

将 $\frac{6}{5}\cdot z$ 四舍五入后记作 $k$，则 $3x+2y=k$ ，其中 $x\leqslant400,y\leqslant600,k\leqslant2000,x,y,k∈z^+$。

根据奇偶性判断，此时的 $x,y$ 必存在解。


------------

每个 $c_i(i\geqslant2)$ 均是独立的，因此对于每个 $c_i$ 枚举找出每组解即可。

-----

```cpp

#include<bits/stdc++.h>
using namespace std;
const int N=10009;
int n,c[N];
inline void cal(int x){
	double sum=x*6/5.0;
	double sur=sum-floor(sum);
	int tar;
	if(sur>=0.5) tar=ceil(sum);
	else tar=floor(sum);
    for(register int a=400;a>=0;a--){
    	if((tar-3*a)%2!=0) continue;
    	int b=(tar-3*a)/2;
    	if(0<=b&&b<=600){
    		cout<<a<<' '<<b<<endl;
    		return;
		}
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(register int i=1;i<=n;i++) cin>>c[i];
	cout<<400<<' '<<600<<endl;
	for(register int i=2;i<=n;i++){
		double sum=c[i]*6/5.0;
		int tar;
		if(sum-floor(sum)>=0.5) tar=ceil(sum);
		else tar=floor(sum);
    	for(register int a=400;a>=0;a--){
    		if((tar-3*a)%2!=0) continue;
    		int b=(tar-3*a)/2;
    		if(0<=b&&b<=600){
   		 		cout<<a<<' '<<b<<endl;
    			break;
			}
		}
	}
	return 0;
}


---

## 作者：Jerrlee✅ (赞：2)

题意不简述了，来直接上思路。

## 思路
你想啊，既然 $c_i \in [10,1990]$，那其实即使有 $n$ 次询问，即使 $n \in [1,10^4]$，$c_i$ 的值也不会逃出给定的那个范围，于是我们往预处理方向去思考。

紧接着，发现 $a_i \in [0,400]$，同时 $b_i \in [0,600]$，数据范围很小，尝试从这两个地方入手。

设定这个“十分强的小朋友 Qiu”两场考试全部 AK。orz

然后别的同学的分数从 $1$ 分到 Qiu 的分数枚举，算出一个 $c_i$，存下来，发现这样做并不会超时，同时算出的 $c_i$ 也能覆盖题目所要求的区间。

于是我们写出了一个如下的循环：

```cpp
for(int i=1;i<=400;i++)
    for(int j=1;j<=600;j++)
```

然后在这个循环内部去把每一个 $c_i$ 的值算出来，算出来就存入一个 `pair` 里面，最后根据询问给定的 $c_i$ 的值，直接回答 `pair` 中存储的元素即可。

## 细节
注意到题目提到了四舍五入，我们使用 C++ 给定的函数 `round()` 就行了，记得里面的数开 `double`，再强制转换为 `int` 即可。

至于 `long long`，在这题显然不用，为了防止被卡时间（虽然这题不会），不开。

## 代码

赛时骗了点分，打球去了。是赛后补题的代码。
```cpp
#define fi first
#define se second
int main(){
    int n;
    cin>>n;
    int a[n+1];
    pair<int,int> p[1999];
    for(int i=1;i<=400;i++){
        for(int j=1;j<=600;j++){
            double x=i/400.0,y=j/600.0;
            p[(int)round(1000*x+1000*y)].fi=i;
            p[(int)round(1000*x+1000*y)].se=j;
        }
    }
    for(int i=1;i<=n;i++){
        cin>>a[i];
        cout<<p[a[i]].fi<<" "<<p[a[i]].se<<endl;
    }
}
```
[AC 记录](https://www.luogu.com.cn/record/100000526)

---

## 作者：LYZHZ (赞：1)

[题目](https://www.luogu.com.cn/problem/P8948)。

## 背景（题意）：

首先，自己拟定两个整数 $A$、$B$ 作为基准，即题目中的最高分。

然后，告诉我们 $c_i$，根据题目所给公式：$c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$，让我们自己拟定合理的 $a_i$ 和 $b_i$。

在比赛的时候其实并没有太多头绪，因为 $c_i$ 是四舍五入保留到整数的，所以通过极端值（即令 $b_i$ 为 $0$ 或 $B$）来求 $a_i$ 显然是不一定可行的。而[评测记录](https://www.luogu.com.cn/record/99959611)也的确如此，只有 $48pts$ 应该是和比赛时大部分卡这题的想法是一样的，所以我们不妨换种思路。

## 思路：

从零开始。看到这道题，我本以为会给 $a_i$ 和 $b_i$，让我们求 $c_i$（可能是想得有些简单）。但是题目却是让我们求 $a_i$ 和 $b_i$。所以，我们不妨拿定其中的 $a_i$ 和 $b_i$，来推出 $c_i$。

想到这儿，代码就简单了，而 $A$ 最大为 $400$，$B$ 最大为 $600$，所以 for 循环嵌套 for 循环完全不会 $TLE$。

我们自己拟定 $A$ 和 $B$，我是直接设最高分者为满分
~~（无脑）~~，然后每次把所有的 $a_i$ 和 $b_i$ 遍历一遍，再根据 $c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$ 求出 $c_i$，用数组来保存 $a_i$ 和 $b_i$ 而数组的下标即为当前的 $c_i$（这样就方便输出了）。并且你也不用怕 $c_i$ 被覆盖。

另外就是四舍五入了：```floor((c+0.5)*10)/10```。具体关于四舍五入，可以借鉴[这里](https://blog.csdn.net/weixin_54438368/article/details/123631972?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167385242016782429771959%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167385242016782429771959&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123631972-null-null.142^v71^insert_chatgpt,201^v4^add_ask&utm_term=c%2B%2B%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5&spm=1018.2226.3001.4187)。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000],b[2000];
int A=400,B=600;
double c;
int n,cc;
int main()
{
	for(int i=1;i<=400;i++)
	{
		for(int j=1;j<=600;j++)
		{
			c=1000*(1.0*i/A+1.0*j/B);
			cc=floor((c+0.5)*10)/10;
			a[cc]=i,b[cc]=j;
		}
	}
	cin>>n;
	for(int i=1;i<=n;i++)
		scanf("%d",&cc),cout<<a[cc]<<" "<<b[cc]<<endl;
 	return 0;
}
```


---

## 作者：sw2022 (赞：1)

## 题意简析

给定 $\{c_n\}$，构造一组 $\{a_n\}$ 和 $\{b_n\}$ 使得 $\forall i\in [1,n]$，$c_i=\operatorname{round}(1000(\dfrac{a_i}{A}+\dfrac{b_i}{B}))$，其中 $A=\max_{i=1}^n a_i$，$B=\max_{i=1}^n b_i$，$\operatorname{round}(x)$ 表示实数 $x$ 四舍五入保留到整数的值。

由条件 $c_1=2000$，得 $(\dfrac{a_i}{A}+\dfrac{b_i}{B})=2$。又因为 $a_i\le A$，$b_i\le B$，所以 $A=a_1$，$B=b_1$。可知需要以 $a_1,b_1$ 作为分母，并且后面的 $a_i,b_i$ 不能超过 $a_1,b_1$。于是构造要求转化为 $c_i=\operatorname{round}(\dfrac{1000}{a_1} a_i+\dfrac{1000}{b_1} b_i)$。

为了能凑出范围内的所有整数和避免除法的精度误差，可以令 $a_1=200$，$b_1=500$，这样 $c_i=5a_i+2b_i$，在 $a_i\in [0,200]$，$b_i\in [0,500]$ 的情况下可以凑出 $[0,2000]$ 内除了 $1,3,1997,1999$ 以外的所有整数（即 $a_i,b_i$ 有整数解），而题目要求的范围是 $[10,1990]$，能够解决。

## 代码/解释
首先可以想到将 $c_i$ 拆成 $c_i\bmod 10$ 和 $c_i-(c_i\bmod 10)$ 进行处理，但由于 $1$ 和 $3$ 凑不出，所以将拆分模数改为 $20$，当前者小于 $10$ 时从后者借 $10$，然后前者就在 $[10,19]$ 中，后者是 $10$ 的倍数，均能凑出，从而构造出合法方案。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n,c,a=200,b=500,x;
    cin>>n>>c;n--;
    printf("%d %d\n",a,b);
    while(n--)
    {
        cin>>c;x=c/20;
        a=x*2;b=x*5;x=c%20;
        if(x<10) x+=10,a-=2;//凑后者
        if(x%2) a++,b+=(x-5)/2;
        else a+=2,b+=(x-10)/2;
        while(b>500) b-=5,a+=2;//凑前者
        printf("%d %d\n",a,b);
    }
    return 0;
}
```

---

## 作者：Yujinhe469 (赞：1)

## 前言
这题是一道构造题，采用 Special Judge 的评测方式，要求选手构造出一个符合要求的解，部分情况下解不唯一。

## 题目分析

首先， $A \leqslant 400$ ，$B \leqslant 600$ ，可以考虑枚举所有的数对 $(A,B)$ ，于是我们需要解下列不定方程：

$c=1000 \cdot ( \frac{a}{A} + \frac{b}{B})$ ，其中 $A$ 、$B$是已知数。

可以通过枚举 $a$ ，计算 $b$ 的方式减少时间复杂度。

* 对于每个 $a$ ，一定能找出合适的 $b$ 吗？ 不一定。

* $c$ 是四舍五入后的结果，可能 $b=p$ 太小了，不合适；而 $b=p+1$ 太大了，也不合适。

但是可以肯定的是，无需枚举太多的 $a$ ，毕竟不合适的情况寥寥无几。

这种算法已经可以AC了，可是我们的时间复杂度明明超了，~~难道是数据太水了吗~~？

打印可以AC的解的 $A$ 和 $B$ ，如果你是倒序枚举 $A$ 和 $B$ 的，你会发现任何情况下 $A = 400$ ，$B = 600$ ，因为 $1000 \cdot ( \frac{a}{400} + \frac{b}{600})$ 可以取遍 $[10,1990]$ 范围内的所有正整数。

于是在代码中直接令 $A = 400$ , $B = 600$ 即可。

**AC代码如下：**

```cpp

#include<bits/stdc++.h>
using namespace std;
const int N=10009;
int n,c[N];
int sw(double u){//表示u四舍五入后的结果
	if(u-(int)u>=0.5) return ceil(u);
	else return floor(u);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>c[i];
	int A=400,B=600;
	cout<<A<<" "<<B<<endl;
	for(int i=2;i<=n;i++)
		for(int a=A;a>=0;a--){
			double b=(6.0*c[i]/5-3*a)/2.0;
			b=floor(b);
			if(b<0||b>B) continue;
			if(sw(1000*(a/400.0+b/600.0))==c[i]){
				cout<<a<<" "<<b<<endl;
				break;
			}
			b++;
			if(b<0||b>B) continue;
			if(sw(1000*(a/400.0+b/600.0))==c[i]){
				cout<<a<<" "<<b<<endl;
				break;
			}
		}
	return 0;
}

```

## 总结

对于此类构造题，做题者的目标应是如何更快地找出一组可行的解，而非力求寻找通解，以枚举答案为基础的算法一般就可以满足要求。

---

## 作者：sbno333 (赞：1)

这道题数据范围实际上可以达到 $10^6$ 而有不超时的做法，而且用不到数组，也超不过绿。我看到这道题时，一下就觉得有常数不超过 $100$ 的 $O(n)$ 的解法，经过长达一个小时的思考，我发现：当第一名同学两次考试的成绩分别为 $200$,$500$ 时，接下来 $a_i$ 每增加 $1$ , $c_i$ 增加 $1\div200\times1000=5$ ， $b_i$ 每增加 $1$ , $c_i$ 增加 $1\div500\times1000=2$ ，当然，它们都有上限，我们就要证明 $10\sim1990$ 的数都可以有不超过 $200$ 个 $5$ 和不超过 $500$ 个 $2$ 构成，我们发现，由于不是 $0\sim 2000$ ，所以构成时有一定空隙，所以或许都能构成，那我们就要思考构成方式：当这个数为奇数时，我们可以先用一个 $5$ ,使得剩下的数为偶数，之后我们在将其变为若干个 $2$ ，若不超过 $500$ ，程序就可以结束了。否则，我们将多出来的数拿出来，一直凑 $5$ ，一直到凑不出来，接着，如果凑完还有余数，我们就将那 $500$ 个 $2$ 拿出来放到余数里，直到余数为 $5$ 的倍数。

## 代码：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a;
	cin>>n;
	cin>>a;
	cout<<"200 500"<<endl;
	n--;
	while(n--){
		cin>>a;
		int x,y;//x为5的个数，y为2的个数
		x=0;
		y=0;
		if(a%2){//如果是奇数
			a-=5;
			x++;//先凑一个5
		}
		y+=a/2;//尽量凑2
		if(y>500){//如果2太多
			int z;
			z=(y-500)*2;//把多出来的拿出来
			x+=z/5;//拿出来的尽量凑5
			y=500;//多出来的已经拿出来了，只剩500了
			z-=z/5*5;//把已经凑出来的删去，剩下的就是余数
			while(z%5){//别看这是一重循环，但数学证明超不过 $5$ 次。
				y--;
				z+=2;//把2慢慢拿出来，直到余数为5的倍数
			}
			x+=z/5;//凑5
		}
			cout<<x<<" "<<y<<endl;
	}
	return 0;
}
```

---

## 作者：skyskyCCC (赞：1)

# 前言。
题意不再赘述。

这道题主要是注意精度问题。
# 分析。
由 $ c_i = 1000(\dfrac{a_i}{A}+\dfrac{b_i}{B})$ 可得，可以设 $A=400$ 且 $B=600$ 的值，这样在对 $a_i$ 和 $b_i$ 细微调整后，精度的准确值是比较高的。

根据乘法分配律，原式可以化为 $c_i = \dfrac{5}{2}a_i + \dfrac{5}{3}b_i = \dfrac{15}{6}a_i + \dfrac{10}{6}b_i = \dfrac{15a_i + 10b_i}{6}$ 的形式。

因为要四舍五入，所以可得 $c_i - \dfrac{1}{2} \leq \dfrac{15a_i + 10b_i}{6} < c_i + \dfrac{1}{2}$ 的不等式。

去分母得 $6c_i - 3 \leq 15a_i + 10b_i < 6c_i +3$。

所以我们可以使用在 $0$ 到 $400$ 中枚举 $a_i$ 并在 $0$ 到 $600$ 中枚举 $b_i$ 的方法。如果不等式成立，则输出这个解即可。

但是这样朴素地枚举时间复杂度较高，无法通过本题，考虑优化。

实际上我们每次枚举时，对于某些方案进行了多次重复计算，浪费了运行时间。所以我们可以预处理出所有 $c_i \in [10,1990]$ 的答案，然后每次询问直接输出即可。

复杂度可以通过本题。

代码如下，仅供参考：
```
#include<iostream>
using namespace std;
int n,c,ans[10005],ans2[10005];
int main(){
    cin>>n;
    for(int i=0;i<=400;i++){
        for(int j=0;j<=600;j++){
            ans[(15*i+10*j+3)/6]=i;
            ans2[(15*i+10*j+3)/6]=j;
        }
    }
    while(n--){
        cin>>c;
        cout<<ans[c]<<" "<<ans2[c]<<"\n";
    }
    return 0;
}
```
# 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。

---

## 作者：lraM41 (赞：0)

思路：预处理。

由于第一次第二次的考试满分成绩小，于是我们可以预处理出每个标准得分的第一场分数和第二场分数。

c++ 中四舍五入函数为： `round`。

四舍五入后，使用 `(int)` 进行强制转换即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	inline long long read(){
		R char ch=gh();
		R long long x=0;
		R char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
}
using IO::read;
void write(int x) {
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
int n,t,i,j,m;
double a,b;
struct p{
    int f,s;
}k[114514];
int main()
{
    n=read();
    for(i=1;i<=400;i++)
        for(j=1;j<=600;j++){
            a=i/400.0,b=j/600.0;
            k[(int)round(a*1000.0+b*1000.0)].f=i;
            k[(int)round(a*1000.0+b*1000.0)].s=j;
        }
    while(n--){
        m=read();
        cout<<k[m].f<<' '<<k[m].s<<'\n';
    }
	return 0;
}
```


---

## 作者：Moon_Traveller (赞：0)

[传送门](https://www.luogu.com.cn/problem/P8948)

**前言：这道题的样例和部分分是两个大坑，千万不要跟着样例或部分分走！**

首先，因为 $c_1$ 一定是 $2000$，说明 $a_1$ 和 $b_1$ 都是最高分。我们不妨假设 “最高分就是满分”，即 $a_1 = 400, b_1 = 600$，那么 $A=400,B=600$。

接下来怎么做呢？由公式：

$$c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$$

可以推出：

$$c_i=1000\cdot\frac{a_i}{A}+1000\cdot\frac{b_i}{B}$$

因此我们可以再次假设：“对于第二场比赛($b$)，不是满分就是零分”，那么可以判断一下：

$$b_i = \begin{cases}
   0 &(c_i \geq 1000) \\
   600 &(c_i \lt 1000)
\end{cases}$$

那么：

$$a_i = \operatorname{round}((c_i \bmod 1000) \div 1000 \times 400)$$

###### 注：round()函数的用途是四舍五入。

这部分的代码：
```cpp
cin >> c[i];
if(c[i] >= 1000)
{
	b[i] = 600;
	c[i] -= 1000;
}
a[i] = round(c[i] / 1000.0 * 400.0);
```

既然是四舍五入，就可能会有误差。所以我们要再判断一下通过 $a_i$ 取得的 $c_i$ 是否符合已知的 $c_i$，如果大了或小了，则应当进行对应的操作。

因为误差是很小的，所以我们可以对 $c_i$ 进行以 $1$ 为单位的微调。那么我们可以调整 $a_i$ 和 $b_i$ 来达到目的。

因为：

$$\frac{1}{400} = 0.0025, \frac{1}{600} \approx 0.0017,$$

$$0.0025-0.0017=0.0008 \approx 0.001,$$

$$2 \times 0.0017 - 0.0025 = 0.0009 \approx 0.001,$$

$$0.001 \times 1000 = 1$$

所以，如果想要把取得的 $c_i$ 调大一点，有两种方法：

1. `a[i] += 1, b[i] -= 1;`
2. `a[i] -= 1, b[i] += 2;`

具体选择哪种方法，就需要看 $b_i$ 的值，若为 $600$，则选择第一种；若为 $0$，则选择第二种。

需要把 $c_i$ 调小的话，把上面两种方法的符号颠倒即可。

代码：

```cpp
#include <iostream>
#include <cmath> // round() 所需头文件
using namespace std;

int n;
int a[10005];
int b[10005];
int c[10005];

int main()
{
    cin >> n;
    cin >> c[1];
    a[1] = 400;
    b[1] = 600;
    cout << 400 << ' ' << 600 << endl; // 直接把a[1]和b[i]设为满分
    for(int i = 2; i <= n; i++)
    {
        cin >> c[i];
        if(c[i] >= 1000) // b[i] 为 0 或 600
        {
            b[i] = 600;
            c[i] -= 1000;
        }
        a[i] = round(c[i] / 1000.0 * 400.0);
        if((a[i] / 400.0 * 1000.0) < c[i]) // 判断:取得的c[i]是否与给出的c[i]相等，否则进行微调
        {
            if(b[i] == 600) // 这里要判断边界，下面同理。
            {
                a[i] += 1;
                b[i] -= 1;
            }
            else
            {
                a[i] -= 1;
                b[i] += 2;
            }
        }
        else if((a[i] / 400.0 * 1000.0) > c[i])
        {
            if(b[i] == 600)
            {
                a[i] += 1;
                b[i] -= 2;
            }
            else
            {
                a[i] -= 1;
                b[i] += 1;
            }
        }
        cout << a[i] << ' ' << b[i] << endl;
    }
    return 0;
}
```

---

## 作者：WaTleZero_pt (赞：0)

本题需要我们动一动脑子，解不定方程。

## 暴力 $20 pts$

本题说第一场考试 $400$ 分，第二场考试 $600$ 分。那就直接拿来作为小朋友 Qiu 的成绩呗。则其他小朋友可以得到这样的等式：

$$ \frac{a_{i}}{0.4} + \frac{b_{i}}{0.6} = c_{i} $$

化简，可得：

$$ \frac{a_{i}}{4} + \frac{b_{i}}{6} = 0.1c_{i} $$

$$ 6a_{i} + 4b_{i} = 2.4c_{i} $$

很显然，只有当 $c_{i}$ 为 $10$ 的倍数时才能 $AC$。

其他暴力分也类似于这个原理。

## 正解

我们可以将小朋友 Qiu 的成绩设置为第一场 $200$ 分，第二场 $500$ 分，其他小朋友可以得到这样的等式：

$$ \frac{a_{i}}{0.2} + \frac{b_{i}}{0.5} = c_{i} $$

化简，可得：

$$ \frac{a_{i}}{2} + \frac{b_{i}}{5} = 0.1c_{i} $$

$$ 5a_{i} + 2b_{i} = c_{i} $$

由于本题满足 $\forall i > 1, c_{i} \in [10,1990]$，所以通过在数据范围内改变 $a_{i}$ 和 $b_{i}$ 的值一定可以得到一组答案。

那么我们应该如何求解呢？我们可以对本题先进行预处理每一个 $c$ 的值能够得到一组什么样的 $a$ 和 $b$，对于接下来的询问直接输出即可。预处理时间复杂度大约是 $O(2000 \times 200)$，每次查询都是 $O(1)$。但我采用了一种新奇的方式。

我们知道每当 $a_{i}$ 减少 $2$，$b_{i}$ 减少 $5$ 时，$c_{i}$ 会减少 $20$。我们可以通过分类讨论研究 $2000-c_{i}$ 对 $20$ 取模以后会得到怎样的解。首先如果这个模数是 $2$ 的倍数，我们可以通过减少 $b_{i}$ 完成目标，如果这个模数是 $5$ 的倍数，我们可以通过减少 $a_{i}$ 完成目标。当模数为 $\{1,3,7,9,11,13,17,19\}$ 中的一个数时一个一个去讨论即可。这样我们可以在时间复杂度近乎 $O(1)$ 的方式解决每一个询问，并且不用初始化。

## AC CODE

```c++
#include<bits/stdc++.h>
using namespace std;
int n,a[10010];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    printf("200 500\n");
    for(int i=2;i<=n;i++){
        int x=200,y=500,mi=2000-a[i];
        if(mi%20==0) x-=mi/20*2,y-=mi/20*5;
        else {
            if(mi%20%2==0) x-=mi/20*2,y-=mi/20*5+mi%20/2;
            else if(mi%20%5==0) x-=mi/20*2+mi%20/5,y-=mi/20*5;
            else if(mi%20==1) x-=mi/20*2+1,y-=mi/20*5-2;
            else if(mi%20==3) x-=mi/20*2+1,y-=mi/20*5-1;
            else if(mi%20==7) x-=mi/20*2+1,y-=mi/20*5+1;
            else if(mi%20==9) x-=mi/20*2+1,y-=mi/20*5+2;
            else if(mi%20==11) x-=mi/20*2+1,y-=mi/20*5+3;
            else if(mi%20==13) x-=mi/20*2+1,y-=mi/20*5+4;
            else if(mi%20==17) x-=mi/20*2+3,y-=mi/20*5+1;
            else if(mi%20==19) x-=mi/20*2+3,y-=mi/20*5+2;
        }
        printf("%d %d\n",x,y);
    }
}
```

---

## 作者：JuRuoOIer (赞：0)

# 题解 P8948 [YsOI2022]NOIp和省选

错过比赛也没事，来篇题解~

### Part1 题意

[原题传送门](https://www.luogu.com.cn/problem/P8948)

给定一个长度为 $n$ 的数组 $c$，其中 $c_1=2000,10 \le c_2,c_3,...,c_n \le 1990$，求两个数组 $a$ 和 $b$，满足：
- $0 \le a_i \le 400,0 \le b_i \le 600$；
- $\max\{a_i\} \neq 0,\max\{b_i\} \neq 0$；
- $c_i=1000 \times \left( \dfrac{a_i}{\max\{a_i\}}+\dfrac{b_i}{\max\{b_i\}} \right)$。

求出任意一组解即可。

### Part2 思路

首先，既然有一个人两个最高分，那直接简单粗暴地把这个人设置成 $400,600$ 即可。

接着考虑怎么弄出其他人的分数。
- 可以算出，比赛 $A$ 每降一分，总成绩会降 $1 \div 400 \times 1000 = \frac{15}{6}$ 分。同理，比赛 $B$ 每降一分，总成绩会降 $1 \div 600 \times 1000 = \frac{10}{6}$ 分。
- 这一坨分数我是（你们肯定也是）真不爱看啊！所以我们要加大降分力度，**把它们变成整数**：
  - 比赛 $A$ 每降 $2$ 分，总成绩会降 $2 \div 400 \times 1000 = 5$ 分；
  - 比赛 $B$ 每降 $3$ 分，总成绩会降 $3 \div 600 \times 1000 = 5$ 分。
- 显然比赛 $A$ 降 $2$ 分和比赛 $B$ 降 $3$ 分都会使总分降 $5$ 分。所以，我们已经能解决 $c_i$ 是 $5$ 的倍数的情况了：把需要扣的 $5$ 分的个数**平分到两个比赛扣**（防止哪个比赛扣没了，要给后面的微调留点空间），即设总共需要扣 $k$ 个 $5$ 分，则 $a_i=2 \times \lceil \frac{k}{2} \rceil,b_i=3 \times \lfloor \frac{k}{2} \rfloor$（当然，哪个是向上取整随便，关键是保证总数对）。
- 那这样我们就只需要考虑微调，也就是降 $1,2,3,4$ 分。拿出之前的分数，经过一波拼凑，我们发现：
  - 降 $1$ 分：即使只在比赛 $B$ 减 $1$ 分，也会使总分降 $\frac{10}{6}$ 分，即从原来的 $5$ 分降到 $3 \frac{2}{6}$ 分，四舍五入只剩 $3$ 分了。所以要在原来的基础上先往比赛 $A$（加比赛 $B$ 显然没啥用，还得扣）加 $1$ 分，再在比赛 $B$ 扣 $2$ 分，最后是 $4 \frac{1}{6}$ 分，四舍五入为 $4$ 分。
  - 降 $2$ 分：在比赛 $A$ 上扣 $1$ 分，即从原来的 $5$ 分降到 $2 \frac{1}{2}$ 分，四舍五入为 $3$ 分；也可以在比赛 $B$ 减 $1$ 分，会使总分降到 $3 \frac{2}{6}$ 分，四舍五入剩 $3$ 分。
  - 降 $3$ 分：在比赛 $B$ 减 $2$ 分，会使总分降到 $1 \frac{2}{3}$ 分，四舍五入为 $2$ 分。
  - 降 $4$ 分：在比赛 $A,B$ 各减 $1$ 分，会使总分降到 $\frac{5}{6}$ 分，四舍五入为 $1$ 分。
- **这样，我们只需要将原数先变成比它大的最小的 $5$ 的倍数，再进行微调即可。**

### Part3 代码

代码不难，但是细节贼多，可以看看注释。

```cpp
#include<iostream>
#define ll long long
using namespace std;
ll n,c; 
int main(){
	cin>>n>>c;
	cout<<"400 600\n";//第一名两个满分 
	while(--n){//--n只会读n-1次，别读多了（前面读一次了） 
		cin>>c;
		if(c%5==0){//5的倍数 
			//注意下面的微调直接体现在这两个地方了
			//    ↓                           ↓ 
			cout<<400-((2000-c)/5+1)/2*2<<' '<<600-(2000-c)/10*3<<endl;
		}
		if(c%5==4){//降1分 
			cout<<401-((2000-c)/5+1)/2*2<<' '<<598-(2000-c)/10*3<<endl;
		}
		if(c%5==3){//降2分 
			cout<<399-((2000-c)/5+1)/2*2<<' '<<600-(2000-c)/10*3<<endl;
		}
		if(c%5==2){//降3分 
			cout<<400-((2000-c)/5+1)/2*2<<' '<<598-(2000-c)/10*3<<endl;
		}
		if(c%5==1){//降4分 
			cout<<399-((2000-c)/5+1)/2*2<<' '<<599-(2000-c)/10*3<<endl;
			//                       ↑
			//这里/2*2不是多此一举，括号里+1括号外/2是为了同时处理奇、偶数，相当于向上取整 
		}
	}
	return 0;
}
```

---

## 作者：Nygglatho (赞：0)

一道诈骗题。

首先，最高分我们可以构造成两场考试全部 AK（第一次 $400$ 分，第二次 $600$ 分）。

证明：将 $c_i$ 计算方式通过分配律改一下，改成 $1000 \cdot \left(\dfrac{a_i}{A}\right) + 1000 \cdot \left(\dfrac{b_i}{B}\right)$。我们可以发现如果像上面这样构造，$a_i$ 增加 $1$，$1000 \cdot \left(\dfrac{a_i}{A}\right)$ 就增加 $2.5$，$b_i$ 增加 $1$，$1000 \cdot \left(\dfrac{b_i}{B}\right)$ 就增加约 $1.67$。显然这是增加速度最小的情况。如果增加速度快一些的话，那么可能会导致中间有一些数字被跳过，而如果数据中有 $c_i$ 刚好是这些数字的话，那么就会因无解而 WA。

例如，当 $A$ 设为 $233$，$B$ 设为 $233$ 的时候的输出：

![](https://s1.ax1x.com/2023/01/16/pS1p429.png)

（这里的 $\texttt{Case}\ i$ 表示标准得分为 $i$ 时构造出的答案，无解时会输出 $\tt No\ solution$，代码见[此](https://paste.ubuntu.com/p/nv9whpRrKC/)）

接下来我们可以直接暴力枚举两场考试的分数，并把 $c_i$ 算出来，但是这样时间复杂度为 $O(nT^2)$（$T$ 是大约为 $600$ 的常数），显然会超时，所以需要预处理一下分数。

```c
#include "bits/stdc++.h"
using namespace std;

struct g {
    int x, y;
}f[5500];//x 表示第一场考试实际分数，y 表示第二场考试实际分数

int reint(double x) {
    return int(x + 0.5);//四舍五入
}

int main() {
    int n;
    scanf ("%d", &n);
    for (int i = 0; i <= 400; ++i) {
        for (int j = 0; j <= 600; ++j) {
            g t;
            t.x = i; t.y = j;
            double p;
            p = (1000.0 * i / 400.0) + (1000.0 * j / 600.0);//计算标准得分
            f[reint(p)] = t;
        }
    }
    for (int i = 1; i <= n; ++i) {
        int c;
        scanf ("%d", &c);
        printf ("%d %d\n", f[c].x, f[c].y);
    }
}
```

---


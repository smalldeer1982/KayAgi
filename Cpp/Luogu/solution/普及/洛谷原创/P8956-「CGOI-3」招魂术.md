# 「CGOI-3」招魂术

## 题目背景

墓园的骷髅海！

要塞的禁魔球！

塔楼的三后排！

据点的破甲比蒙！

地下城的满魔抗黑龙！

![](https://cdn.luogu.com.cn/upload/image_hosting/j0kff14j.png)

###### 塔楼↑

-----
燊队来打英雄无敌 3 了。

## 题目描述

招魂术是墓园阵营的核心法术。

拥有招魂术的英雄，在每场战争结束后，能根据消灭的敌军数目来获得一定数量的骷髅。我们可以用整数 $A,B$ 来描述招魂术。设 $F_{A,B}(i)$ 表示消灭 $i$ 个敌人所能获得的骷髅数量，有：

$$F_{A,B}(1)=A,F_{A,B}(2)=B,F_{A,B}(x)=\lfloor \sqrt{F_{A,B}(x-2)F_{A,B}(x-1)}\rfloor+1\;(x \ge 3)$$

现在燊队要在酒馆招募一个英雄，英雄甲招魂术的属性为 $A,B$，英雄乙招魂术的属性为 $X,Y$。为了比较两个英雄招魂术的强弱，请你计算以下式子的值：

$$\prod_{i=1}^nF_{X,Y}(i)-F_{A,B}(i)$$

燊队当然知道怎么做，但他想考考你。

## 说明/提示

#### 样例说明

在样例说明中，设 $F_{A,B}$ 为 $f$，$F_{X,Y}$ 为 $g$。

对于第一组询问：

- $f$ 的前 $n$ 位为 $f=\{2,10,5,8,7\}$。

- $g$ 的前 $n$ 位为 $g=\{1,8,3,5,4\}$。

所以最终的答案为 $(1-2)\times(8-10)\times(3-5)\times(5-8)\times(4-7)=-36$，对 $998244353$ 取模后的结果是 $998244317$。

---

#### 数据范围

对于 $40\%$ 的数据，$n \le 100$。

对于另外 $10\%$ 的数据，每组询问满足 $A=B,X=Y$。

对于另外 $10\%$ 的数据，$T=1$。

对于 $100\%$ 的数据，$1 \le A,B,X,Y,n \le 10^9$，$1 \le T \le 5\times 10^4$。

## 样例 #1

### 输入

```
4
5 2 10 1 8
11 4 5 1 4
19 1 9 8 10
114 51 4 1919 810```

### 输出

```
998244317
998242817
939523984
604148977```

# 题解

## 作者：Register_int (赞：7)

对于这个函数，容易发现相邻两项之差会逐渐缩小，最后变成 $x,x,x+1,x+1,x+2,x+2\cdots$ 的形式。这个过程的长度是 $O(\log n)$ 的。那么前半部分暴力，后面用快速幂计算即可。

# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e6 + 10;
const int mod = 998244353;

inline 
ll qpow(ll b, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = res * b % mod;
		b = b * b % mod, p >>= 1;
	}
	return res;
}

int t;

ll n, a, b, x, y, ans;

int main() {
	for (scanf("%d", &t); t--;) {
		scanf("%lld%lld%lld%lld%lld", &n, &a, &b, &x, &y);
		if (n == 1) { printf("%lld\n", (x - a + mod) % mod); continue; }
		ans = (x - a) * (y - b) % mod;
		for (int i = 3; i <= n; i++) {
			a = (ll)sqrtl(a * b) + 1, x = (ll)sqrtl(x * y) + 1;
			ans = ans * (x - a) % mod, swap(a, b), swap(x, y);
			if (a == b && x == y) { ans = ans * qpow(x - a, n - i) % mod; break; }
			if (a == b - 1 && x == y) { ans = ans * qpow(x - a, n - i + 1 >> 1) % mod * qpow(x - b, n - i >> 1) % mod; break; }
			if (a == b && x == y - 1) { ans = ans * qpow(x - a, n - i + 1 >> 1) % mod * qpow(y - a, n - i >> 1) % mod; break; }
		}
		printf("%lld\n", (ans + mod) % mod);
	}
}
```

---

## 作者：ztntonny (赞：6)

#### 前言：本题解 $\LaTeX$ 使用较多，如果渲染失败请[移步与此](https://www.luogu.com.cn/blog/ztntonny/solution-p8956)。

## 题意

非常喜欢这道题，考察到了多方面的知识以及~~非常坑的~~取模，下面简述一下：

给定 $5$ 个整数 $n,A,B,X,Y$，求对于两串串数列：

$$\left\{
\begin{aligned}
F_{A,B}(1)=A,F_{A,B}(2)=B,F_{A,B}(x)=\lfloor \sqrt{F_{A,B}(x-2)F_{A,B}(x-1)}\rfloor+1\;(x \ge 3)\\
F_{X,Y}(1)=X,F_{X,Y}(2)=Y,F_{X,Y}(x)=\lfloor \sqrt{F_{X,Y}(x-2)F_{X,Y}(x-1)}\rfloor+1\;(x \ge 3)
\end{aligned}
\right.$$
的：

$$\prod_{i=1}^nF_{X,Y}(i)-F_{A,B}(i)$$

## 思路

首先，意识到 $\sqrt{F(x-2)F(x-1)}+1$ 就是 $F(x-2),F(x-1)$ 的几何平均值加上一，且由均值不等式得到

$$\sqrt{F(x-2)F(x-1)}+1\leq \frac{F(x-2)+F(x-1)}{2}+1$$

所以得出，数列 $F$ 一定有 $F(x)=F(x+1)$ 且满足 $x\leq\log{(F(1)\times F(2))}+1$（记 $x_{F_{A,B}},x_{F_{X,Y}}$ 分别为 $F_{x,y},F_{A,B}$ 的第一项满足 $F(x)=F(x+1)$ 的下标）。

那么就不难得到，在 $F(x+1)$ 之后数列形状：

$$F(x+2)=F(x)+1,F(x+3)=F(x)+1,F(x+4)=F(x)+2,F(x+5)=F(x)+2\ldots$$

即：

$$F(x+n)=F(x)+\lfloor\frac{n}{2}\rfloor$$


那么实际上我们已经可以用 $\mathcal{O}(\log{(X\times Y)})$ 的时间复杂度求出 $F_{X,Y}$，用 $\mathcal{O}(\log {A\times B})$ 的时间复杂度求出 $F_{A,B}$ 了。下面分析 $\prod_{i=1}^nF_{X,Y}(i)-F_{A,B}(i)$：

此式子若 $n\leq \min(x_{F_{A,B}},x_{F_{X,Y}})$ 还可以暴力计算，时间复杂度 $\mathcal{O}(\min(\log{(A\times B)},\log{(X\times Y)}))$，但是若 $n$ 已经取到 $10^9$ 级别，就需要考虑更快的方法了，我们推导在 $\max(x_{F_{A,B}},x_{F_{X,Y}})$ 以后的乘积形式：

$$(F_{A,B}(x)-F_{X,Y}(x))\times(F_{A,B}(x+1)-F_{X,Y}(x+1))\times\ldots$$

考虑 $F_{A,B}(n)=F_{A,B}(x)+\lfloor\frac{n-x}{2}\rfloor$，简化成为：

$$(F_{A,B}(x_{F_{A,B}})+\lfloor\frac{x-x_{F_{A,B}}}{2}\rfloor-F_{X,Y}(x_{F_{X,Y}})+\lfloor\frac{x-x_{F_{X,Y}}}{2}\rfloor)\times(F_{A,B}(x_{F_{A,B}})+\lfloor\frac{x+1-x_{F_{A,B}}}{2}\rfloor-F_{X,Y}(x_{F_{X,Y}})+\lfloor\frac{x+1-x_{F_{X,Y}}}{2}\rfloor)\times\ldots$$ 

易得第 $x$ 项：

$$F_{A,B}(x_{F_{A,B}})+\lfloor\frac{x-x_{F_{A,B}}}{2}\rfloor-F_{X,Y}(x_{F_{X,Y}})+\lfloor\frac{x-x_{F_{X,Y}}}{2}\rfloor$$

不难发现，当 $x_{F_{A,B}}\mod 2\equiv x_{F_{X,Y}}\mod 2$ 时：

$$F_{A,B}(x_{F_{A,B}})+\lfloor\frac{x-x_{F_{A,B}}}{2}\rfloor-F_{X,Y}(x_{F_{X,Y}})+\lfloor\frac{x-x_{F_{X,Y}}}{2}\rfloor= F_{A,B}(x_{F_{A,B}})-F_{X,Y}(x_{F_{X,Y}})$$

那么原式实际上就成为了：

$$(F_{A,B}(x_{F_{A,B}})-F_{X,Y}(x_{F_{X,Y}}))^{n-\max(x_{F_{A,B}},x_{F_{X,Y}})+1}$$

肉眼可见可以使用快速幂解决。

那么当 $x_{F_{A,B}}\mod 2\not\equiv x_{F_{X,Y}}\mod 2$ 时：

$$(F_{A,B}(x_{F_{A,B}})+\lfloor\frac{x-x_{F_{A,B}}}{2}\rfloor-F_{X,Y}(x_{F_{X,Y}})+\lfloor\frac{x-x_{F_{X,Y}}}{2}\rfloor)\times(F_{A,B}(x_{F_{A,B}})+\lfloor\frac{x+1-x_{F_{A,B}}}{2}\rfloor-F_{X,Y}(x_{F_{X,Y}})+\lfloor\frac{x+1-x_{F_{X,Y}}}{2}\rfloor)=(F_{A,B}(x_{F_{A,B}})-F_{X,Y}(x_{F_{X,Y}}))\times(F_{A,B}(x_{F_{A,B}}+1)-F_{X,Y}(x_{F_{X,Y}}+1))$$

原式实际上成为：

$$(F_{A,B}(x_{F_{A,B}})-F_{X,Y}(x_{F_{X,Y}}))\times(F_{A,B}(x_{F_{A,B}}+1)-F_{X,Y}(x_{F_{X,Y}}+1))^{\lfloor\frac{n-\max(x_{F_{A,B}},x_{F_{X,Y}})+1}{2}\rfloor}\times (F_{A,B}(x_{F_{A,B}})-F_{X,Y}(x_{F_{X,Y}}))^{(n-\max(x_{F_{A,B}},x_{F_{X,Y}})+1)\mod 2}$$

同样可以使用快速幂解决。

---

那么这样，实际上整个程序的时间复杂度就是 $\mathcal{O}(t\log n)$ 级别的了，完结撒代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MOD = 998244353;
ll t , n , a , b , x , y , cmp1 , cmp2;
long double f[105] , g[105];
ll fpow( ll xx , ll yy )
{
	if ( yy == 0 )	return 1;
	ll z = fpow( xx , yy / 2 ) % MOD;
	if ( yy % 2 )	return ( ( z * z ) % MOD * xx ) % MOD;
	else	return ( z * z ) % MOD;
}
ll ff( ll xx )
{
	if ( xx > cmp1 )	return ( ( ( xx - cmp1 ) / 2 ) % MOD + (ll)f[cmp1] ) % MOD;
	else	return (ll)f[xx];
}
ll gg( ll xx )
{
	if ( xx > cmp2 )	return ( ( ( xx - cmp2 ) / 2 ) % MOD + (ll)g[cmp2] ) % MOD;
	else	return (ll)g[xx];
}
int main()
{
	cin >> t;
	for ( ll k = 1; k <= t; k++ )
	{
		ll cmp , ans = 1;
		cmp1 = 2 , cmp2 = 2 , cin >> n >> a >> b >> x >> y , f[1] = a , f[2] = b , g[1] = x , g[2] = y;
		while ( f[++cmp1 - 1] != f[cmp1 - 2] && cmp1 <= n + 3 )	f[cmp1] = ( (ll)( sqrt( f[cmp1 - 1] * f[cmp1 - 2] ) ) + 1 ) % MOD;
		while ( g[++cmp2 - 1] != g[cmp2 - 2] && cmp2 <= n + 3 )	g[cmp2] = ( (ll)( sqrt( g[cmp2 - 1] * g[cmp2 - 2] ) ) + 1 ) % MOD;
		cmp1 -= 2 , cmp2 -= 2 , cmp = max( cmp1 , cmp2 );
		for ( ll i = 1; i <= min( n , cmp - 1 ); i++ )	ans *= ( gg( i ) - ff( i ) ) % MOD , ans %= MOD;
		if ( cmp <= n )
		{
			if ( cmp1 % 2 == cmp2 % 2 )	ans *= fpow( ( gg( cmp ) - ff( cmp ) ) % MOD , n - cmp + 1 ) , ans %= MOD;
			else
			{
				ans *= fpow( ( ( gg( cmp ) - ff( cmp ) ) % MOD * ( gg( cmp + 1 ) - ff( cmp + 1 ) ) % MOD ) % MOD , ( n - cmp + 1 ) / 2 ) , ans %= MOD;
				if ( ( n - cmp + 1 ) % 2 )	ans *= ( gg( cmp ) - ff( cmp ) ) % MOD , ans %= MOD;
			}
		}
		cout << ( ans + MOD ) % MOD << endl;
	}
    return 0;
}
```

---

## 作者：JackMerryYoung (赞：1)

# 前言

T1，极其卡精度。鬼才知道我为啥会做。

与官方答案殊途同归。

# 正文

手模几组数据可得这个数列先是疯狂下降，到一定数值开始缓步上升。

然后易得数列上升 $1$ 需要两个长度，于是在这一段两个数列的差值最多波动 $1$。

结论原理：

由基本不等式 $a + b \geq 2 \sqrt{ab}$，不难发现 $\sqrt{F_{A, B}(x - 1) \times F_{A, B}(x - 2)} + 1 \leq \dfrac{F_{A, B}(x - 1) + F_{A, B}(x - 2)}{2} + 1$

经过数列的不断递推之后，他下降到了 $1$，使得这个等号可取，于是会有 $x$ 满足：

$$
\begin{cases}
F_{A, B}(x) = F_{A, B}(x + 1) \\
F_{A, B}(x + 2) = F_{A, B}(x + 3) = F_{A, B}(x) + 1 \\
F_{A, B}(x + 4) = F_{A, B}(x + 5) = F_{A, B}(x) + 2 \\
\cdots \\
F_{A, B}(x + 2k) = F_{A, B}(x + 2k + 1) = F_{A, B}(x) + k \quad(k \in N)\\
\end{cases}
$$

即到达数列上升 $1$ 需要两个长度的情况。而且这两个数列的差值最多波动 1。

于是可以对其奇偶性进行分讨，然后快速幂即可。

复杂度 $\mathcal{O}(T \log_2 \omega)$，反正不依赖于 $N$ 肯定过。
 
# 代码

仅供调试用的核心代码：

``` python
Var T, N, A, B, X, Y
Val MOD = 998244353 

Fun main():
    T = read()
    While T != 0:
        dec(T)
        N, A, B, X, Y = read()
        If N == 1:
            writeln(X - A)
        Elif N == 2:
            writeln((X - A) * (Y - B))
        Else:
            Var pf, ppf, pg, ppg = B, A, Y, X
            Var ans = (X - A) * (Y - B)
            Var fready, gready = False, False
            For i From 3 Upto N(Included) Step 1:
                Var f, g = floor(sqrt(pf * ppf)) + 1, floor(sqrt(pg * ppg)) + 1
                If f == pf:
                    fready = True
                    
                If g == pg:
                    gready = True
                    
                ans = ans * (g - f)
                If fready And gready:
                    Var now = i + 1
                    If now > N:
                    	Break
                        
                    If (pf - pg) == (f - g):
                        ans = ans * pow(g - f, N - now + 1)
                    
                    Else: 
                        ppf = pf, ppg = pg, pf = f, pg = g
                        f, g = floor(sqrt(pf * ppf)) + 1, floor(sqrt(pg * ppg)) + 1
                        ans = ans * pow((g - f) * (pg - pf), (N - now + 1) / 2)
                        If (N - now + 1) % 2 == 1:
                        	ans = ans * (g - f)
                    
                    Break

                ppf = pf, ppg = pg, pf = f, pg = g

            writeln(ans)
```

# 后言

感谢【丑国】题森出题组提供的优质题目！

---


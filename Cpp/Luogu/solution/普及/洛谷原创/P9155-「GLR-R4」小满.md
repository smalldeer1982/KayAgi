# 「GLR-R4」小满

## 题目背景

&emsp;&emsp;「树阴满地日当午，梦觉流莺时一声」

---

&emsp;&emsp;乐队训练之余，锻炼时间可是必不可少的，可是就算几个女孩子撒开蹄子跑，也不可能在高三打球狂人的统治下抢到一块羽毛球场的。经过了数周从训练室冲到球场，再从球场灰心地踱回训练室的循环后，阿绫绝望地向大家宣布了一个坏消息：“只能打野球了。”

&emsp;&emsp;“还有几个月了哟……”

&emsp;&emsp;“老 V 你又来了！”才回训练室的阿绫扶着门抱怨着。

&emsp;&emsp;“所以你们打球得抓紧时间啦！”

---

&emsp;&emsp;**小满**&emsp;「生活一圈圈日子一年年　总是这样重复一遍又一遍」

## 题目描述

&emsp;&emsp;野场羽毛球，在生态环境良好的校园里，可是经常遭遇不测的——

&emsp;&emsp;“天依！怎么球又被挂树上啦！”

&emsp;&emsp;如阿绫所见，她们仅剩的一颗可怜的羽毛球被天依用吃包子的劲儿抡到树上去了。为了避免找别人的排球或者篮球来砸树的尴尬，阿绫这次特意准备了一根折叠杆。

&emsp;&emsp;折叠杆初始时处于完全收缩状态，我们认为它的长度 $\ell=0$。完全展开折叠杆需要 $n$ 步，每步为以下两种情况之一：

1.  将杆末端的折叠处展开。此操作没有额外参数，操作完成后 $\ell\gets 2\ell$，即杆的长度变为原来的两倍。

2.  将杆末端的伸缩处展开。此操作将给出额外可变参数 $d$，操作完成后 $\ell\gets \ell+d$，即杆的长度增加 $d$。

&emsp;&emsp;树上球的高度、杆最终的高度和天依吃包子的劲儿可能都是庞大的，所以阿绫需要你来计算一下杆最终的长度 $\ell$。你需要回答阿绫 $n$ 次操作依次完成后，**$\ell$ 的二进制表示**。

## 说明/提示

#### 样例 #1 解释

对于第一组测试数据：$\ell$ 的变化过程为：$0 \rightarrow 0 \rightarrow 0$，而 $(0)_{10}=(0)_2$。

对于第二组测试数据：$\ell$ 的变化过程为：$0 \rightarrow 0 \rightarrow 1 \rightarrow 3 \rightarrow 6 \rightarrow 12$，而 $(12)_{10}=(1100)_2$。  

### 数据规模与约定  

对于 $100\%$ 的数据，$1\leq T \leq 5$，$1\leq  n \leq 10^5$，$0\leq d < 2^{16}$。

对于不同的子任务，作如下约定：

| 子任务编号 |     $n$     | 特殊性质 | 子任务分值 |
| :--------: | :---------: | :------: | :--------: |
|    $1$     |  $\leq 20$  |    无    |    $10$    |
|    $2$     | $\leq 10^5$ |    有    |    $20$    |
|    $3$     | $\leq 10^3$ |    无    |    $40$    |
|    $4$     | $\leq 10^5$ |    无    |    $30$    |
  
- 特殊性质：仅存在第二种操作。


## 样例 #1

### 输入

```
2
2
1
2 0
5
1
2 1
2 2
1
2 6```

### 输出

```
0
1100```

# 题解

## 作者：Auto_Accepted (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P9155)
# 题意
有一个数 $now$，初始为 $0$。

现在有 $n$ 个操作，每个操作有两种类型：

1. 把 $now$ 变为 $now$ $\times$ $2$。
1. 把 $now$ 加上 $d$。

注意，**多组数据测试**。
# 解法
考虑开一个数 $now$ 去模拟，但我们惊喜的发现 ```long long``` 炸了。

于是考虑高精度。

如果你手写一个高精度去模拟的话，会发现能拿 $70$ 分。

然后自然的想到去优化这个高精度。

### 优化第一步：
十进制转二进制太麻烦还耗时？那直接用二进制高精！

### 优化第二步：
乘 $2$ 太耗时？别忘了我们现在是二进制。乘 $2$ 直接在后面加个 $0$ 就行了。

### 优化第三步：
把 $d$ 一个一个加上去进位太慢？那直接把 $d$ 一股脑加到最后一位上，最后处理完后在统一进位。

然后就可以过了。没错，就是这么简单。~~（但我为什么赛时没想到呢？呜呜呜）~~

# 实现细节：
最后一位在哪里可以用一个指针 $pos$ 表示，$pos$ 一开始记得放在中间，前面的位置预留出来方便进位。

# 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
	int s = 0 , xi = 1;
	char op = getchar();
	while(op < '0' || op > '9'){
		if(op == '-') xi = -1;
		op = getchar();
	}
	while(op >= '0' && op <= '9'){
		s = (s << 1) + (s << 3) + op - '0';
		op = getchar();
	}
	return s * xi;
}
inline void print(int x){
	if(x < 0) putchar('-') , x *= -1;
	if(x < 10){
		putchar(x + '0');
		return;
	}
	print(x / 10);
	putchar(x % 10 + '0');
}
int n , t;
struct Int{
	int a[100005] = {} , pos = 50000 , l = pos;
	void test1(){
		pos++;
	}
	void test2(int d){
		a[pos] += d;
	}
	void end(){
		for(int i = pos;i;i--){
			a[i - 1] += a[i] / 2;
			a[i] %= 2;
		}
		for(int i = 1;i <= l;i++){
			if(a[i]){
				l = i;
				break;
			}
		}
		if(a[l] == 0) l = pos;
	}
	void write(){
		for(int i = l;i <= pos;i++){
			print(a[i]);
		}
		putchar('\n');
	}
};
signed main(){
//    freopen(".in" , "r" , stdin);
//    freopen(".out" , "w" , stdout);
	t = read();
	while(t--){
		Int a;
		n = read();
		for(int i = 1;i <= n;i++){
			int op = read();
			if(op == 1){
				a.test1();
			}
			else{
				a.test2(read());
			}
		}
		a.end();
		a.write();
	}
    return 0;
}
```


---

## 作者：Azazеl (赞：9)

### 「GLR-R4」小满 题解

#### 题意

> $~~~~$ 给定一个初始为 $0$ 的数，$n$ 次操作，要么将这个数 $\times 2$，要么将这个数加 $d$。求执行完操作后这个数的二进制表示。  
> $~~~~$ $1\leq n\leq 10^5,0\leq d<2^{16}$.

#### 题解

##### Subtask 1

$~~~~$ 一共 $20$ 次操作，那么可以达到的最大值小于 $2^{16}\times 2^{19}=2^{35}$ ，你可以直接用一个 `long long` 存下这个数。完成操作过后把这个数转成二进制表示即可。事实上为了让大家忘开`long long` 也能得分没有卡。

$~~~~$ 如果你需要学习如何十进制转二进制，欢迎参考：[B3619 10 进制转 x 进制](https://www.luogu.com.cn/problem/B3619)。

##### Subtask 2

$~~~~$ 可以发现这个数最后最大值小于 $2^{16}\times 10^5$，仍然是 `long long` 可以存下来的范围。那么和上面一个 Subtask 采取一样的方法做即可。

$~~~~$ 当然这个 Subtask 也可以在你写完下个 Subtask 过后看结果时提供参考作用。

##### Subtask 3

$~~~~$ 现在这个数可能会非常大，那就不能直接用一个变量存下来了。

$~~~~$ ~~我会高精！~~ 当然你丢一个十进制高精板子这可以直接过该部分，但是没这个必要对吧。

$~~~~$ 题目最后已经告诉你我们需要求二进制表示，而这两个操作在二进制下可以简单地表示。具体来说做加法时我们可以先把每一位对应加上值，然后从低到高一起进位；做乘法时直接整体左移即可。

$~~~~$ 最后最高二进制位一定是 $\leq n$ 的，那么直接按照上述过程执行这些操作可以做到 $\mathcal{O(n^2)}$ 的时间复杂度，可以通过此部分。

##### Subtask 4

$~~~~$ 我们来优化上述的两个过程。

$~~~~$ 对于加法，由于我们只需要在最后再求出值，所以过程中不需要实时维护进位而可以最后再来统一进位，那么单次的复杂度就可以做到 $\mathcal{O(\log d)}$。而最后二进制位数也是 $\mathcal{O(n)}$ 的，所以进位复杂度也是可以接受的。

$~~~~$ 对于乘法，我们发现其**影响**的对象是之前所有加法操作加上的值，那我们可以不需要对乘法单独移位，而是对之前的每次加法提前把该位左移，位数为之后还需要执行的乘法操作次数。

$~~~~$ 现在我们就可以以 $\mathcal{O(n \log d)}$ 地完成这两个操作了。

##### 鲜花

$~~~~$ 最开始这个题的范围是给的 $n\leq 10^6$，然后审比赛的管理员说：这是 2B，要不就开个 $10^5$ 吧。

$~~~~$ 于是就放过了一堆 `bitset` 和 `string`。

$~~~~$ 感谢 C++ 的 STL。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>void read(T &x)
{
    T f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    x*=f;
}
vector <int> V[1048580];
int Num[1048580];
int X[1048580];
char S[1048580];
int main() {
    int T;read(T);
    for(int i=0;i<(1<<16);i++)
        for(int j=0;j<16;j++) if((i>>j)&1) V[i].push_back(j);
    while(T--)
    {
        int n;read(n);int tot=0;
        for(int i=1,op,k;i<=n;i++)
        {
            read(op);if(op==2) read(k);
            if(op==1) X[i]=-1,tot++;
            else X[i]=k;
        }
        int Maxn=0;
        for(int i=1;i<=n;i++)
        {
            if(X[i]==-1) tot--;
            else for(int j=0;j<V[X[i]].size();j++) Num[V[X[i]][j]+tot]++,Maxn=max(Maxn,V[X[i]][j]+tot);
        }
        for(int i=0;i<=Maxn;i++)
        {
            Num[i+1]+=Num[i]>>1;
            Num[i]%=2;
        }
        if(Num[Maxn+1]) Maxn++;
        while(Num[Maxn]>=2) Num[Maxn+1]+=Num[Maxn]>>1,Num[Maxn]%=2,Maxn++;
        while(Maxn>0&&Num[Maxn]==0) Maxn--;
        for(int i=Maxn;i>=0;i--) S[Maxn-i]=Num[i]+'0',Num[i]=0;
        puts(S);
        for(int i=0;i<=Maxn;i++) S[i]=0;
    }
    return 0;
}
```

---

## 作者：Xy_top (赞：9)

赛后水一发题解（

题意很简单，一个数字初始为 $0$，$m$ 次操作，每次将这个数字乘以 $2$ 或者将这个数加上 $val$，求 $m$ 次操作后这个数字的二进制值。

显然可以发现乘以 $2$ 的话，数字二进制的最后会加上一个 $0$。然后我们统计每个加操作的最终贡献。（加操作最后还会乘上多个 $2$）。

倒序处理维护数字的二进制就可以了。

贴代码：

```cpp
#include <iostream>
using namespace std;
int T, n;
int ans[500005];
struct order {
	int x, y;
}o[100005];
int main () {
	cin >> T;
	while (T --) {
		for (int i = 1; i <= 200000; i ++) ans[i] = 0;
		scanf ("%d", &n);
		bool f = false;
		for (int i = 1; i <= n; i ++) {
			scanf ("%d", &o[i].x);
			if (o[i].x == 2) {
				scanf ("%d", &o[i].y);
				if (o[i].y != 0) f = true;
			}
		}
		if (! f) {
			cout << 0 << "\n";
			continue;
		}
		int cnt = 0;
		for (int i = n; i >= 1; i --) {
			if (o[i].x == 1) ++ cnt;
			else {
				int sum = 1;
				while (o[i].y) {
					ans[sum + cnt] += o[i].y & 1;
					o[i].y /= 2;
					sum ++;
				}
			}
		}
		int len = 0;
		for (int i = 1; i <= 200000; i ++) {
			if (ans[i] != 0) len = i;
			if (ans[i] > 1) {
				ans[i + 1] += ans[i] / 2;
				ans[i] &= 1;
			}
		}
		for (int i = len; i >= 1; i --) cout << ans[i];
		cout << "\n";
	}
	return 0;
}
```


---

## 作者：lilong (赞：7)

看到 $ n \le 10^5$，就知道这题不是纯模拟。

又看到了 $ 0 \le d < 2^{16}$，发现特殊的地方，于是就考虑使用二进制。

具体地，我们对两种操作分类讨论（题目中的字符打不出来，用 $l$ 代替）。

#### 操作一

在二进制下，将二进制数左移一位相当于将原数乘 $2$。不过由于数据范围很大，我们暂时先将其放在一边。

#### 操作二

不难想到，可以直接在二进制下做高精度加法，复杂度也是可以接受的。现在要将其与操作一结合。

#### 结论

每做一次加法，后面可能还要做若干次乘法。设做完某一次加法后还要做 $p$ 次乘法，相当于要在本次操作后左移 $p$ 位。那么我们可以反向思维，提前计算好最后的位置（从右往左第 $p+1$ 位为最低位），直接在最后的位置做加法。那么，乘法操作就可以忽略了。

时间复杂度 $O( n \log d)$，代码如下：
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int n,a[1000001],T,x[1000001],y[1000001],now,cnt,k,pd;

int main()
{
	cin >> T;
	while( T -- )
	{
		pd = 1;
		now = 1;
		a[now] = 0;
		cin >> n;
		for( int i = 1 ; i <= n ; i ++ )
		{
			a[i] = 0; 
			cin >> x[i];
			if( x[i] == 2 )
				cin >> y[i];
			else
				y[i] = 0;
		}
		for( int i = n + 1 ; i <= n + 1000 ; i ++ )
			a[i] = 0;
		for( int i = n ; i >= 1 ; i -- )
			if( x[i] == 1 )	
				now ++,pd ++;
			else
			{
				k = pd;
				do
				{
					a[k] += y[i] % 2;
					a[k+1] += a[k] / 2;
					a[k] %= 2;
					y[i] /= 2;
					k ++; 
				}
				while(y[i]);
				while( a[k] > 1 )
				{
					a[k+1] += a[k] / 2;
					a[k] %= 2;
					k ++;
				}
			}
		for( int i = 1 ; i <= n + 1000 ; i ++ )
		{
			a[i+1] += a[i] / 2;
			a[i] %= 2;
		 } 
		cnt = n + 1000;
		while( a[cnt] == 0 && cnt > 1 ) cnt --;
		for( int i = cnt ; i >= 1 ; i -- )
			cout << a[i];
		cout << endl;
	}
	return 0;
}
```


---

## 作者：ScottSuperb (赞：6)

## 解法分析
这一题乍一看很简单，但是瞅一眼数据范围就知道作为 2B 还是不可能太水的，极限情况下数据达 $2^{10^5}$，很明显不是普通类型的变量能胜任的了。看到大范围很自然地会想到高精度，但是再一想会发现直接无脑高精加高精乘还要转进制，显然复杂度过大了。怎么办呢？我们来分别从这三个方面入手进行优化：
1. 先看进制转换，显然十进制转二进制需要高精除，很麻烦。于是可以直接使用二进制高精度解决这个问题。进位时与十进制思路是一样的，只是把模十除以十换成了模二除以二。
1. 再看操作一：移位。常规方式移位的话需要操作整个已用的数组，显然大动干戈了。于是可以采用偏移数组的方法达到类似双端队列的效果。即定义一个指针指向当前的最低位的上一个位置~~（之所以上一个只是图方便）~~，初始状态下指针指向数组中央，每左移一位指针自减即可。
1. 最后看操作二：加法。常规的高精加每加一次都要处理进位，很浪费时间。于是我们把所有加上去的数直接放在最低位别管，所有操作完成了再一次性进位。这样子极端情况下一位存储的数据达 $2^{16} \times 10^5$，需要使用 `long long`。

于是，如果定义最终结果的长度为 $l$，那么操作一和操作二都是 $O(1)$ 的，进位是 $O(l)$ 的，总复杂度为 $O(T(n+l))$，完美解决此题。
## 代码
此代码为赛时最优解：![](https://cdn.luogu.com.cn/upload/image_hosting/5d3yy5h7.png)  
快读快写函数已省略。
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

ll sf[100010], p;
void init() { p = 50005, sf[0] = 1, sf[p + 1] = 0; }
void add(ll b) { sf[p + 1] += b; }
void ls() {
  if (sf[p + sf[0]]) ++sf[0], --p, sf[p + 1] = 0;
}

int main() {
  ll t = read(), n, x;
  while (t--) {
    n = read(), init();
    while (n--) {
      x = read();
      if (x & 1)
        ls();
      else
        add(read());
    }
    for (ll i = p + 1, tmp1, tmp2; i <= p + sf[0]; ++i) {
      tmp1 = sf[i] & 1, tmp2 = sf[i] >> 1;
      if (tmp2) {
        sf[i] = tmp1;
        if (i == p + sf[0])
          ++sf[0], sf[i + 1] = tmp2;
        else
          sf[i + 1] += tmp2;
      }
    }
    for (int i = p + sf[0]; i > p; --i) pc(sf[i] ? '1' : '0');
    pc('\n');
  }
  fls();
  return 0;
}
```

---

## 作者：_wsq_ (赞：2)

看到本题 $0\le d<2^{16}$ 的数据范围，考虑高精度。

由于 1 操作会将结果变为原来的两倍，且**最终输出的结果用二进制表示**，因此容易想到直接将 $d$ 转成二进制，并进行二进制的高精度。

现在，我们对于 1 操作就只需要在末尾加一个 $0$ 就可以了，最终也可以直接输出，不用转二进制。

但是，如果这样还是[只能获得 70 分](https://www.luogu.com.cn/record/105084257)。

注意到 $1\le d\le10^5$，也就是说我们即使加上 $d$ 后不进位，数组里的任何一位也都不会超过 int 的范围。

因此，最后处理一遍进位就可以了。

AC 代码：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int main(){
    int t,num[100005],len=1;
    cin>>t;
    for(int i=1;i<=t;i++){
        memset(num,0,sizeof(num));
        int n,z=1;
        cin>>n;
        for(int j=1;j<=n;j++){
            int op;
            cin>>op;
            if(op==1){
                if(!z)len++;
                for(int k=len;k>=2;k--){
                    num[k]=num[k-1];
                }
                num[1]=0;
            }
            else{
                int d,k=1;
                cin>>d;
                if(d!=0)z=0;
                while(d){
                    num[k]+=d%2;
                    d/=2;
                    k++;
                }
                len=max(len,k-1);
            }
        }
        for(int k=1;k<len;k++){
            num[k+1]+=num[k]/2;
            num[k]=num[k]%2;
        }
        while (num[len]>=2){
            num[len+1]+=num[len]/2;
            num[len]=num[len]%2;
            len++;
        }
        for(int j=len;j>=1;j--){
            cout<<num[j];
        }
        cout<<endl;
        len=1;
    }
    return 0;
}
```

---

## 作者：A_Bit_Cold (赞：2)

看看数据范围就知道这不是一道简单的高精度题。

给出一个思路：

直接将整个数组当做一个二进制。

- $op=1$，将数组的长度加 $1$，这就相当于将二进制左移一位，即乘 $2$。

- $op=2$，将数组末尾直接加上 $d$，为什么不转成二进制？这是因为在线转换会超时，需要直接加上然后离线进行进位。

细节问题：与其他解法略有不同，对于因数组下标问题不能进位，可以将最后 $a[1]$ 进位的数单独拿出来进行二进制分解，效果相同。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,op,tmp;
long long d,a[N],b[N];
int read() {
	int f=1,s=0;
	char c=getchar();
	while((c<'0'||c>'9')&&c!='-') c=getchar();
	if(c=='-') f=-1;
	else s+=c-'0';
	c=getchar();
	while(c>='0'&&c<='9') s=s*10+c-'0',c=getchar();
	return s*f;
}
int main() {
	int t=read();
	while(t--) {
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		n=read(),tmp=0;
		while(n--) {
			op=read();
			if(op==1) tmp++;//长度+1
			else d=read(),a[tmp]+=d;//最后一位直接+d
		}
		for(int i=tmp;i>=1;i--) {
			long long t=a[i]/2;
			a[i]=a[i]%2,a[i-1]+=t;
		}
		if(a[0]) {
			long long tmp2=a[0],s=0;
			while(tmp2) b[++s]=tmp2%2,tmp2/=2;
			int r=s;
			while(b[r]==0&&r>1) r--;//去前导零
			for(int i=r;i>=1;i--) cout<<b[i];
		}
		for(int i=1;i<=tmp;i++) cout<<a[i];
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：tallnut (赞：1)

一道高精度模拟，不过和普通的高精有点不同。
# 题意简述
要求你维护一个正整数 $n$，其初始值为 $0$。每次可以选择
$$n \gets n \times 2$$
或者设定一个正整数 $d$，
$$n \gets n + d$$
所有操作处理完以后才输出。
# 思路
首先想到开 long long 暴力去做，然后你会发现 long long 炸了。不过这种方法能过 subtask 2。

然后就是经典高精度，然后成功 $\text{TLE}$。

接着发现这题和 $2$ 很有关系，考虑采用二进制存储高精度。

然而加的操作仍然无法解决，还是 $\text{TLE}$。

但由于我们只需要在操作完之后再输出，所以可以先把加的操作记录下来，最后再统一处理进位。

这里我们可以采用 C++ 中指针移动的方式，免得进位进到负数，导致~~让人喜笑颜开的~~ $\color{#9D3DCF}\text{RE}$。

细节很多，~~我是不会告诉你我交了 15 发才过的。~~
# AC 代码
[AC 记录](https://www.luogu.com.cn/record/134761503)，代码中有注释。
```
#include <iostream>
#include <cstring>
using namespace std;
int t,n,op,d;
class bignum
{
	//不开 long long 见祖宗
	long long* a;
	int len;
	//记录数组移动元素个数，方便在析构函数中释放数组
	int move;
	public:
		bignum()
		{
			a = new long long[30001000];
			memset(a,0,sizeof a);
			a += 15000500;
			len = 0;
		}
		void multiply() { a[++len] = 0; }
		void plus(int x) { a[len] += x; }
		void fix()
		{
			int i = len;
			while (true)
			{
				//等同于 a[i - 1] += a[i] / 2;
				a[i - 1] += (a[i] >> 1);
				//等同于 a[i] %= 2;
				a[i] &= 1;
				i--;
				//指定退出条件：如果已经处于进位状态，而且没有能够继续进位的了，就 break 出去
				if (i < 0 && a[i] == 0) break;
			}
			//将 a 数组和 len 变量相应地前移 i 个元素，方便后续处理。
			a += i;
			len -= (i - 1);
			move = i;
		}
		void print()
		{
			int i = 0;
			//去除前导零
			for (;a[i] == 0 && i < len + 10;i++);
			//特判：如果全是零就直接输出
			if (i == len + 10)
			{
				cout << "0\n";
				return;
			}
			for (;i < len;i++)
				cout << a[i];
			cout << '\n';
		}
		~bignum()
		{
			a -= move;
			a -= 15000500;
			delete [] a;
		}
};
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	while (t--)
	{
		bignum num;
		cin >> n;
		while (n--)
		{
			cin >> op;
			if (op == 1) num.multiply();
			else
			{
				cin >> d;
				num.plus(d);
			}
		}
		num.fix();
		num.print();
	}
}
```

---

## 作者：zgy_123 (赞：0)

本文参考 [此讲解](https://www.luogu.com.cn/blog/ivy80222874/xiao-man)。

稍有思维难度，码量少，算是好题。

首先发现要求输出二进制，而每次都转换不现实，所以考虑直接用二进制高精。

整体思路：先对于每次操作记录改变，再统一处理并输出。

对于一个序列，如果只是操作二，那么会直接计算和；但是如果其中掺杂了操作一呢？显然对于以前的加法，其权值会翻倍。

但是直接暴力记录肯定是不行的，我们考虑先读入再处理：求出操作一的**倒序前缀和**数组。

比如：

```
6
2 1
1
1
2 1
1
2 1
```
那么每次操作二的权值依次是 $2^3$，$2^1$，$2^0$，可以通过计算其后的操作一的个数求得。

最后就是将数转为二进制，见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int t,v;//代表某次加法为+v*2^t
}c[100005];
int T;
long long b[1600005];
bool a[100005];
int p[100005];
int main(){
	scanf("%d",&T);
	while(T--){
		memset(c, 0, sizeof c); memset(b, 0, sizeof b);
		memset(a, 0, sizeof a); memset(p, 0, sizeof p);
		int cnt = 0, n, op,tot=-1, d; 
		scanf("%d",&n);
		for(int i = 1; i <= n; i++){
			scanf("%d",&op);
			if(op == 1) a[i]=1;
			else{
				scanf("%d",&d);
				c[++cnt].v = d;
			}
		}
		for(int i=n;i>=1;i--){//预处理出权值的幂
			p[i]=p[i+1]+a[i];
			tot=max(tot,p[i]);//最终数的长度
		}
		int k=0;
		for(int i=1;i<=n;i++)
			if(a[i]==0) c[++k].t=p[i];//计算实际权值
		for(int i = 1; i <= cnt; i++) b[c[i].t + 1] += c[i].v;//累加到“二进制”数上

		for(int i = 1; i <= tot+1; i++){
			b[i+1] += b[i]/2;
			b[i] %= 2; 
		}
		int j = tot+2;
		while(b[j]){
			b[j+1] += b[j]/2;
			b[j] = b[j]%2;
			j++;
		}//转二进制

		while(b[j]==0&&j>1) j--;
		for(int k = j; k; k--) cout<<b[k];//输出
		cout<<endl;
	}
	return 0;
} 
```
---
祝大家 NOIP RP++！！！

---


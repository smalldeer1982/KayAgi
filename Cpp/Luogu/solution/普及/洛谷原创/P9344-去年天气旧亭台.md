# 去年天气旧亭台

## 题目背景

依旧是过往的天气，过往的楼台烟雨。时间悄悄流逝着，山河仍在，人却已不是过去的人……

## 题目描述

登上楼台，旧时满面沉灰的地板映入眼帘。

共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，积灰程度用 $a_i$ 表示。**注意 $c_i$ 为 $0$ 或 $1$。**

现在要清理这些地板上的灰尘。每次操作中，你可以：

+ 选择两个下标 $i,j$，满足 $1\leq i\leq j\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；
+ 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

求清理完所有地板上的灰尘至少要多少能量。

## 说明/提示

**【样例 1 解释】**

- 对于第一组数据，直接花费 $a_1+a_6=5$ 的能量清理所有灰尘。
- 对于第二组数据，先花费 $a_1+a_1=6$ 的能量清理第一个地板上的灰尘，再花费 $a_2+a_8=7$ 的能量清理剩余灰尘。

**【数据规模与约定】**

对于 $10\%$ 的数据，保证 $T\le 10$，$n\le 10$；

对于 $40\%$ 的数据，保证 $T\le 20$，$n\le 10^3$；

另有 $10\%$ 的数据，保证 $c_i=1$；

对于 $100\%$ 的数据，保证 $1 \le T \le 10^5$，$1 \le n,\sum n\le 2 \times 10^6$，$c_i \in \{0,1\}$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
2
6
1 1 4 5 1 4
1 0 0 1 0 1
8
3 1 4 1 5 9 2 6
1 0 1 0 1 0 1 0```

### 输出

```
5
13```

# 题解

## 作者：_JF_ (赞：32)

注意，所有的 $a_i$ 都是正数。

对于第一档分，$10$ pts，是给暴力的。

对于第二档分，可以考虑一个 $dp$，$dp_i$ 表示 消完 $1$ 到 $i$ 所要的代价最小，那就从当前的 $i$ 往前找，找到能消去的（颜色相同）去更新 $dp_i$ 的值，方程是：

$$dp[i]=min(dp[i],a[i]+a[j]+dp[j-1])$$

时间是 $O(t\times n^2)$ 。

接下来看正解：

分两类讨论。

- $c_1=c_n$

对于这种情况的话，直接选择 $[1,n]$ 这个区间消去即可。代价为 $a_1+a_n$。这样做是最优的，因为 $1$ 和 $n$ 两个位置作为首尾，消去的时候这两个位置必选，那么就必然含有 $a_1$ 和 $a_n$，加上如果中间选择一些辅助 $a_i$ 进行消去，必然不如第一种消去方法优秀。

所以我们有结论，对于 $l,r$，如果 $c_l=c_r$，那么消去这个区间的最小代价就一定是 $a_l+a_r$。

- $c_1 !=c_n$

首先有的一个结论是，必然会存在至少一个 $c_i$ 和 $c_{i+1}$，使得 $c_i$ 等于 $c_1$，$c_n$ 等于 $c_{i+1}$。$(1\le i \le n-1)$

考虑采用反证法证明，如果不存在的话，$c_2$ 必然会等于 $c_1$（如果不等于 $c_1$ 的话就符合上面的情况了。）以此类推， $c_{n-1}=c_1$，但是这样的话 $c_n=c_n,c_1=c_{n-1}$，也就是 $[1,n-1]$ 和 $[n,n]$ 两个区间，矛盾。故得证。

所以我们可以找到至少一组 $c_1=c_i,c_{i+1}=c_n$ 的情况，根据第一种情况的结论，那么最小值就是 $(a_1+a_i)+(a_{i+1}+a_n)$。$O(n)$ 的时间扫一遍找这个值的最小就好。

时间为 $O(t \times n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =5e6+10;
#define int long long
int a[N],c[N];
signed main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		for(int i=1;i<=n;i++)
			cin>>c[i];
		if(c[1]==c[n])
		{
			cout<<a[1]+a[n]<<endl;
			continue;
		}
		int ans=LONG_LONG_MAX;
		for(int i=1;i<n;i++)
			if(c[i]==c[1]&&c[i+1]==c[n])
				ans=min(ans,a[i]+a[1]+a[n]+a[i+1]);
		cout<<ans<<endl;
	}
	return 0;
}

```


---

## 作者：zhlzt (赞：11)

### 线性 DP 做法
题目就是要划分若干连续区间，并不复杂，**这里给出一种与官方题解思路不同的做法。**

设 $dp_i$ 表示清理前 $i$ 块地板需要的最少能量，$ans1$ 为目前最后一个区间开头的 $c_i=0$ 且不计算此区间结尾的 $a_i$ 时需要的最少能量，$ans2$ 为目前最后一个区间开头的 $c_i=1$ 且不计算此区间结尾的 $a_i$ 时需要的最少能量（由于要为多个结尾的 $dp_i$ 作贡献），则不难得出以下状态转移方程：
$$dp_i=\begin{cases}ans1+a_i&(c_i=0)\\ans2+a_i&(c_i=1)\end{cases}$$
但在每次状态转移前，由于可能以 $i$ 为最后一个区间的开头，所以需要执行：
$$\begin{cases}ans1\gets \min(ans1,dp_i+a_i)&(c_i=0)\\ans2\gets \min(ans2,dp_i+a_i)&(c_i=1)\end{cases}$$
线性 DP 复杂度为 $O(n)$，$1\le\sum n\le 2\times 10^6$，不会超时。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000010],c[2000010];long long dp[2000010]; 
int main(){
	int T;scanf("%d",&T);
	while(T--){
		int n;scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		for(int i=1;i<=n;i++) scanf("%d",&c[i]);
		long long ans1=1e15,ans2=1e15;
		for(int i=1;i<=n;i++){
			if(c[i]==0) ans1=min(ans1,dp[i-1]+a[i]),dp[i]=ans1+a[i];
			else ans2=min(ans2,dp[i-1]+a[i]),dp[i]=ans2+a[i];
		}
		printf("%lld\n",dp[n]);
	} 
	return 0;
}
```

---

## 作者：GeorgeAAAADHD (赞：5)

注：本题作者使用贪心算法。

### 题目大意：
$T$ 组数据，每组数据给出 $n$，以及长度为 $n$ 的数组 $a_i$，$c_i$，分别代表有 $n$ 块地板、第 $i$ 块地板的积灰程度和类型。每次操作你可以：

- 选择两个下标 $i,j$ 满足 $1 \le i \le j \le n$ 且 $c_i=c_j$ 且地板 $i,j$ 均未清理过；

- 花费 $a_i+a_j$ 的能量清理地板 $[i,j]$ 的灰尘。

求最小需要多少能量可以清理完所有地板。

### 分析：

首先，两个端点地板的 $a_i$ 必须要取，因为左端点地板的左边和右端点地板的右边都没有地板可取。

然后我们来介绍这题的贪心算法：

1. 若 $c_1=c_n$，则直接取区间 $[1,n]$ 最优，证明：因为若不这么做，则总能量为 $a_1+\cdots+a_n$，又 $a_i \ge 1$，所以 $a_1+\cdots+a_n > a_1+a_n$。

2. 若 $c_1=0,c_n=1$，则取区间 $[1,i]$ 和 $[i+1,n]$ 且 $i$ 满足 $c_1=c_i$、$c_{i+1}=c_n$ 且 $a_i+a_{i+1}$ 最小时最优。证明：设取 $3$ 个区间，则会在原来最优答案的两个区间中的某一个再细分一个区间，此时根据贪心法 $1$ 的证明可得这样一定不优。同理得区间数 $\ge 3$ 时一定不优。

3. 若 $c_1=1,c_n=0$，则取区间 $[1,i]$ 和 $[i+1,n]$ 且 $i$ 满足 $c_1=c_i$、$c_{i+1}=c_n$ 且 $a_i+a_{i+1}$ 最小时最优。证明过程与贪心法 $2$ 的过程相似。

综上，贪心法 $1$ 的时间复杂度为 $O(1)$，贪心法 $2$ 和 $3$ 要查找满足条件的 $i$，时间复杂度为 $O(n)$，总时间复杂度为 $O(\sum n)$，可以通过本题。

注意：贪心法 $2$ 和 $3$ 的最优答案有可能会达到 $4 \times 10^9$，因此要开 `long long`，最优答案的初始化也要适当开大一点，不能开 `INT_MAX`。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[2000001]={0};
bool c[2000001]={0};
signed main() {
    cin>>t;
    while(t--){
    	cin>>n;
    	for(int i=1;i<=n;i++)cin>>a[i];
    	for(int i=1;i<=n;i++)cin>>c[i];
    	if(c[1]==c[n])cout<<a[1]+a[n]<<endl;
    	else if(c[1]){
    		int ans=1e15;
    		for(int i=1;i<n;i++){
    			if(c[i]&&!c[i+1])ans=min(ans,a[1]+a[i]+a[i+1]+a[n]);
			}
			cout<<ans<<endl;
		}
		else{
    		int ans=1e15;
    		for(int i=1;i<n;i++){
    			if(!c[i]&&c[i+1])ans=min(ans,a[1]+a[i]+a[i+1]+a[n]);
			}
			cout<<ans<<endl;
		}
	}
    return 0;
}
```

其实本题还可以用动态规划去写，请读者们自行思考。

---

## 作者：Iniaugoty (赞：3)

官方题解貌似没有讲到动态规划的正解做法。~~其实我赛时也用的贪心~~。

# problem

共有 $n$ 块地板，地板分为两类，第 $i$ 块地板的类别用 $c_i$ 表示，$c_i\in\{0,1\}$；积灰程度用 $a_i$ 表示。

现在要清理这些地板上的灰尘。每次操作中，可以：

- 选择两个下标 $i,j$，满足 $1\le i\le j\le n,c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**。

- 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

求清理完所有地板上的灰尘至少要多少能量。

# solution

设 $dp_i$ 表示消完 $[1,i]$ 消耗的最小能量。

状态转移方程官方题解已经给出了：

$$dp_i=\min\{a_i+a_j+dp_{j-1}\}(1<j\le i,c_i=c_j)$$

但是这样是 $\operatorname O(n^2)$ 的。

容易发现方程中其实有一项可以从 $\min$ 里面提出来，变成这样：

$$dp_i=a_i+\min\{a_j+dp_{j-1}\}(1<j\le i,c_i=c_j)$$

这样对于 $c_i=0$ 和 $c_i=1$，分别做一个 $a_i+dp_{i-1}$ 的前缀最小值即可。

时间复杂度变为 $\operatorname O(n)$。

其实空间复杂度还可以卡到 $\operatorname O(1)$，但是我不想卡了。

# code

```cpp
#include<bits/stdc++.h>
#define int long long//不开 long long 见祖宗
#define N 2000005
#define inf 5e9//初始化有错见祖宗
using namespace std;
int T,n,c[N],a[N],dp[N],f[2];
int solve(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>c[i];
    
	dp[1]=a[1]+a[1];//转移数组
	f[c[1]]=a[1],f[!c[1]]=inf;//前缀最小值
	for(int i=2;i<=n;i++){
        f[c[i]]=min(f[c[i]],dp[i-1]+a[i]);
		dp[i]=f[c[i]]+a[i];
	}
	return dp[n];
}
signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	cin>>T;
	while(T--)
		cout<<solve()<<'\n';
	return 0;
}
```

全文完。

---

## 作者：_mi_ka_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9344)

众所周知一篇题解需要一个头图。

![](https://cdn.luogu.com.cn/upload/image_hosting/iyc200et.png)

## 题目大意

给一个长度为 $n$ 的排列 $a$，此外每个 $i$ 还有一个标记 $c_i$ 满足 $c_i\in \{0,1\}$，每次可以选择一段 $[i,j]$ 满足 $c_i=c_j$ 将这一段（$a$ 和 $c$）进行删除，花费为 $a_i+a_j$，求删除所有数的最小花费。

## 解题思路

考虑**贪心** + **暴力**。

如果 $c_1=c_n$，那么直接清除 $1\sim n$ 这一段的花费肯定是最小的，为 $a_1+a_n$，因为其他的清除方法答案中也都会包含 $a_1$ 和 $a_n$，但是都会含有其他数字，所以一定大于 $a_1+a_n$。

如果 $c_1\ne c_n$，考虑将 $a$ 分为两段 $[1,i]$ 和 $[i+1,n]$ 使得 $c_1=c_i$ 且 $c_{i+1}=c_n$，则此时花费为 $a_1+a_i+a_{i+1}+a_n$，同上理也可以证明最小答案一定是将 $a$ 分为两段而不是更多段，于是考虑暴力枚举所有符合条件的 $i$。

记 $last$ 为上一个与 $a_1$ 相等的数的下标，如果当前 $a_i\ne a_1$ 则更新答案 $ans=\max(ans,a_1+a_{last}+a_{last+1}+a_n)$，最后输出答案即可。

算法复杂度 $O(n)$。

## AC Code

防止作弊只放主函数：

```cpp
signed main()
{
	T=re();
	while(T--)
	{
		n=re();
		for(int i=1;i<=n;i++)
			a[i]=re();
		for(int i=1;i<=n;i++)
			c[i]=re();
		if(c[1]==c[n])
		{
			wr(a[1]+a[n]),putchar('\n');
			continue;
		}
		int last=1,ans1=0x7f7f7f7f7f7f7f7f;
		for(int i=1;i<=n;i++)
		{
			if(c[i]!=c[1])
				ans1=min(ans1,a[1]+a[last]+a[last+1]+a[n]);
			else
				last=i;
		}
		wr(ans1),putchar('\n');
	}
	return 0;
}
```

---

## 作者：saixingzhe (赞：1)

很明显的贪心。

对于每一列地板，分两种情况讨论。

* 如果第 $n$ 个和第 $1$ 块地板颜色相同，则一定花费 $a_1+a_n$ 能量清理。可以证明没有其他更优方法，因为其他方法一定至少花费 $a_1+a_n$ 能量。

* 如果第 $n$ 个和第 $1$ 块地板颜色不同，我们就要找一个中转点，假设这个中转点为 $i$，$1 \leq i \leq n$，$i$ 的颜色要与 $1$ 相同，且 $i+1$ 的颜色要与 $n$ 相同，一共清扫两次，分别是 $1,i$ 和 $i+1,n$，花费 $a_1+a_i+a_{i+1}+a_n$ 能量。

容易证明一定存在一个这样的中转点，这种方案也最优。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[2000005],c[2000005],n,t,ans;
int main(){
	scanf("%lld",&t);
	while(t--){
		ans=5000000000;
		scanf("%lld",&n);
		for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
		for(int i=1;i<=n;i++) scanf("%lld",&c[i]);
		if(c[1]==c[n]){
			printf("%lld\n",a[1]+a[n]);
			continue; 
		}
		for(int i=1;i<n;i++) if(c[i]==c[1]&&c[i+1]==c[n]) ans=min(ans,a[i]+a[1]+a[n]+a[i+1]);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Moon_Wind (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9344)



------------


**题意简述：**

有 $T$ 组数据，每组数据给出 $n$ 和长度为 $n$ 的数组 $a_i,c_i$。$a_i$ 表示第 $i$ 块地板的积灰程度，$c_i$ 表示第 $i$ 块地板的类型（$c_i$ 为 $0$ 或 $1$），每次操作可以：
	
   + 选择两个下标 $i,j$，满足 $1\leq i\leq j\leq n$， $c_i=c_j$，**且第 $i$ 块和第 $j$ 块地板上的灰尘均未被清理过**；
	
   - 花费 $a_i+a_j$ 的能量清理**第 $i$ 块到第 $j$ 块所有地板**上的灰尘。

**算法分析：**
 
 - **贪心：**
	
    - 当 $c_1=c_n$ 时，$a_1+a_n$ 为最小花费数量。因为，如果要保证清理所有的地板，且 $1\le i,j\le n$，那么 $1,n$ 肯定都会出现在所有选择的 $i$ 或 $j$ 之中。所以，使用的能量之和肯定大于等于 $a_1+a_n$。那么，此时最优解肯定是 $a_1+a_n$。
    
    - 当 $c_1\ne c_n$ 时，取满足 $c_1=c_i$ 并且 $c_{i+1}=c_n$ 的 $i$ 中 $a_i+a_{i+1}$ 的最小值是最优的。因为，如果取 $2$ 个以上的区间，就会在原来的两个区间中的某一个再分出一个区间，所以此时肯定会比只选 $2$ 个区间劣。
    
    时间复杂度是 $O(\sum n)$ 的，可以通过本题。
    
**代码部分**：



------------
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+10; 
int T,n,a[N],c[N],ans=INT_MAX;
signed main(){
	cin>>T;
	while(T--){
		ans=INT_MAX;
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=1;i<=n;i++) cin>>c[i];
		if(c[1]==c[n]) 
        		cout<<a[1]+a[n]<<endl;//情况一
		else{
			for(int i=1;i<n;i++)
				if(c[i]==c[1]&&c[i+1]==c[n]) 
                			ans=min(a[i+1]+a[i],ans);//情况二
			cout<<ans+a[1]+a[n]<<endl; 
		} 
	}
	return 0;
} 
```


---

## 作者：Link_Cut_Y (赞：1)

简要题意不放了。这里只讲分析。

太弱的部分分不用我说了吧。爆搜肯定有点分。

接下来是 $O(n ^ 2)$ 的算法。设计状态 $f_i$ 表示打扫到第 $i$ 块地板，且前 $i$ 块地板全都打扫完的最小代价。可以得到转移方程：

$$f_i = \min \{ f_{j - 1} + a_j + a_i\}$$

其中 $c_j = c_i$。而且 $f_i$ 的初始值为 $f_{i - 1} + a_i \times 2$，这个初值的意义就是暴力打扫这个地板的代价。

如果你暴力转移，复杂度就是 $O(T n ^ 2)$，预计得分 $50$。

接下来考虑优化，我们发现，$\min\{f_{j - 1} + a_j + a_i\}$ 就是 $\min\{f_{j - 1} + a_j\} + a_i$，而 $f_{j - 1} + a_j$ 很容易让某些人想到线段树或者堆。你当然可以搞个堆维护这个东西，这可能就是赛时给了这个部分分的原因。

如果你没有把数据结构学痴，你应该能够知道，维护这个东西应该搞一个数组 $g_i$，表示 $f_{j - 1} + a_j$ 的最小值，然后在转移的时候更新一下 $g$。于是复杂度 $O(n)$ 了，你能够过题了。

最后考虑降一下空间复杂度。显然，$f$ 可以滚一下，$g$ 可以搞一个变量代替。所以空间复杂度就变成了 $O(1)$。（如果不考虑 $a$ 数组）。

所以建议加强数据，把 $\log$ 算法卡掉。

代码可以看我的博客 [点这里](https://www.cnblogs.com/LcyRegister/p/17419057.html)。

---

## 作者：Cure_Wing (赞：1)

[题目](https://www.luogu.com.cn/problem/P9344)

### 解析
简单题。

考虑最简单的 $c_1=c_n$，这个时候直接选取首尾即可，答案为 $a_1+a_n$。由于 $a_i\ge1$，所以不可能有更小的答案。

考虑稍微复杂一点的 $c_1\not=c_n$，这个时候不难想到，数列一定可以分为 $[1,l]$ 和 $[l+1,n]$ 两段。因为如果 $c_1\sim c_n$ 都等于 $c_n$ 的话，上述事实就不成立了。所以我们可以暴力枚举可以分割的节点，打擂台取最小值即可。可以证明，如果 $[1,l]$ 和 $[l+1,n]$ 是一种合法的分解方案，那么 $[1,l]$、$[l+1,r]$ 和 $[r+1,n]$ 的分解方式一定更劣，因为它所需要的数一定更多。

这样我们就写出的一份复杂度为 $\mathcal{O}(\sum n)$ 的代码。

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define int long long
using std::cin;using std::cout;
constexpr int N=2000006;
int t,n,a[N],c[N],ans;
signed main(){
// 	freopen(".in","r",stdin);
// 	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	for(cin>>t;t--;){
		cin>>n;ans=1e18;
		for(int i=1;i<=n;++i) cin>>a[i];
		for(int i=1;i<=n;++i) cin>>c[i];
		if(c[1]==c[n]) ans=a[1]+a[n];//事实上这里可以加个continue跳过下面的循环。
		for(int i=1;i<n;++i)
			if(c[1]==c[i]&&c[i+1]==c[n])
				ans=std::min(ans,a[1]+a[i]+a[i+1]+a[n]);
		cout<<ans<<'\n';
	}
    return 0;
}
```

---

## 作者：ncwzdlsd (赞：0)

DP。

设 $f_j$ 表示清扫到第 $j$ 块地板的最小花费，注意到区间无重叠，有转移 $f_j=\min\limits_{i\leq j,c_i=c_j}(f_{i-1}+a_i+a_j)=\min\limits_{i\leq j,c_i=c_j}(f_{i-1}+a_i)+a_j$。

暴力的找这个最小值，枚举 $i,j$，时间复杂度 $O(Tn^2)$。

考虑如何优化，$a_j$ 是定值，我们只需要在枚举的时候对 $f_{i-1}+a_i$ 做一个前缀最小值即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=2e6+5;
int a[maxn],f[maxn];
bool c[maxn];

void solve()
{
	int n;cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>c[i];
	int min0=LLONG_MAX,min1=LLONG_MAX;
	for(int i=1;i<=n;i++)
	{
		if(!c[i]) min0=min(min0,f[i-1]+a[i]);
		else min1=min(min1,f[i-1]+a[i]);
		if(!c[i]) f[i]=min0+a[i];
		else f[i]=min1+a[i];
	}
	cout<<f[n]<<'\n';
}

signed main()
{
	int T;cin>>T;
	while(T--) solve();	
	return 0;
}
```

---

## 作者：qzhwlzy (赞：0)

### 题目大意

给定两个长为 $n$ 序列 $a$ 和 $c$，其中 $c_i\in\{0,1\}$。

每次操作可以选择一对满足 $c_i = c_j$ 且 $i$ 和 $j$ 没有被打标记的 $(i,j)$，花 $a_i+a_j$ 的代价给 $i\sim j$ 间的所有数打上标记。

求给所有数打上标记的最小代价。

### 思路

首先，我们注意到 $a_i > 0$，这意味着假设 $i\le j\le k\le l$，$c_i=c_j=c_k=c_l$，选择 $(i,l)$ 一定比选择 $(i,j)$ 和 $(k,l)$ 更优。

于是，假设 $c_1 = c_n$，我们可以一次直接选择整段，花 $a_1+a_n$ 的代价给整段打上标记，且这样的代价是最小的。因为 $1$ 和 $n$ 一定要被选，故代价的下界就是 $a_i+a_j$，又因为能取到，所以这就是答案。

那么若 $c_1\neq c_n$，我们还是想让操作的区间尽量越少越好。发现肯定存在 $i$ 使得 $c_i = c_1,c_{i+1}=c_n$（否则整个 $c$ 都是一样的，不符合 $c_1\neq c_n$ 的假设）。同上最小值一定是 $\min\limits_{c_i\neq c_{i+1}}(a_1+a_i)+(a_{i+1}+a_n)$。

时间复杂度：$\mathcal{O}(Tn)$。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#define maxn 2000005
#define ll long long // 记得开 long long
using namespace std;
int T,n,a[maxn],c[maxn]; ll ans=-1;
int main(){
	scanf("%d",&T); while(T--){
		ans=-1LL; scanf("%d",&n); for(int i=1;i<=n;i++) scanf("%d",&a[i]); for(int i=1;i<=n;i++) scanf("%d",&c[i]);
		if(c[1]==c[n]){printf("%d\n",a[1]+a[n]); continue;}
		for(int i=1;i<n;i++) if(c[i]==c[1]&&c[i+1]==c[n]) ans=(ans==-1?1LL*a[i]+a[i+1]:min(ans,1LL*a[i]+a[i+1]));
		printf("%lld\n",ans+a[1]+a[n]);
	} return 0;
}
```

---

## 作者：CEFqwq (赞：0)

友情提示：十年 OI 一场空，不开 long long 见祖宗。

本题是一个简单的分类讨论。

首先当 $c_1 = c_n$ 时，直接清理，肯定最优。

因为否则一定要分两次清理 $[1 , k]$ 和 $[k+1 , n]$ 的地板，花费必然更大。

当 $c_1 \not= c_n$ 时，我们只能分两次清理 $[1 , k]$ 和 $[k+1 , n]$，枚举 $k$ 就行了。

时间复杂度 $O(Tn)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[5000005];
bool a[5000005];
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(register int i=0;i<n;i++)cin>>c[i];
		for(register int i=0;i<n;i++)cin>>a[i];
		if(a[0]==a[n-1]){//第一种情况
			cout<<c[0]+c[n-1]<<"\n";
			continue;
		}
		long long ans=LLONG_MAX;
		for(register int i=0;i<n-1;i++)//第二种情况，取花费最小
			if(a[i]==a[0]&&a[i+1]==a[n-1])
				ans=min(ans,c[i]+c[0]+c[i+1]+c[n-1]);
		cout<<ans<<"\n";
	}
}
```

---

## 作者：I_will_AKIOI (赞：0)

一道简单的贪心题。

清理地板有两种方式。第一种是一次清理完，第二种是分成两段清理。我们通过枚举证明：

若 $c_1=c_n$，则清理 $[i,j]$。

若 $c_1\neq c_n$，则可以找到 $c_i=c_1,c_{i+1}=c_n$。

由此证明分成两端清理肯定不劣。

所以我们可以先特判第一种情况，否则循环枚举 $i$，将满足第二个要求的点计算总花费，取最小值输出。

```
#include<bits/stdc++.h>
#define int unsigned int
using namespace std;
int t,n,ans,a[2000000];
bool b[2000000];
signed main()
{
  ios::sync_with_stdio(0);
  cin>>t;
  while(t--)
  {
	ans=ULONG_MAX;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	if(b[1]==b[n]) cout<<a[1]+a[n]<<"\n";//特判
	else 
	{
	  for(int i=1;i<n;i++) if(b[1]==b[i]&&b[i+1]==b[n]) ans=min(ans,a[1]+a[i]+a[i+1]+a[n]);//满足要求计算最小值
	  cout<<ans<<"\n";
	}
  }
  return 0;
}
```

---

## 作者：aCssen (赞：0)

### Solution
考虑 dp。

设 $f_i$ 表示消去 $[1,i]$ 区间所要消耗的最小能量，则有 $f_i=\min_{1 \le j \le i,c_i=c_j}\lbrace f_{j-1}+a_j+a_i\rbrace$，含义是先消去 $[1,j-1]$，再消去 $[j,i]$，花费 $a_j+a_i$ 的代价。时间复杂度 $\mathcal{O}(n^2)$。

考虑优化时间复杂度，先提出只与 $i$ 有关的项，则 $f_i= a_i+\min_{1 \le j \le i,c_i=c_j}\lbrace f_{j-1}+a_j\rbrace$，发现 $\min$ 函数中的值只与 $j$ 相关，可以直接用一个变量 $val$ 维护这个最小值，又因为有颜色相同这条限制，可以用两个值分别表示，即 $val_{c_i}=\min \lbrace val_{c_i},f_{i-1}+a_i\rbrace $，则 $f_i= a_i+ val_{c_i}$。时间复杂度 $\mathcal{O}(n)$。

因为有 $1 \le j \le i$ 这个限制，所以应该在用 $val$ 更新 $f$ 之前先更新 $val$。因为更新 $val_{c_i}$ 用到的只是 $f_{i-1}$，所以不会出现 UB。

这个做法可以直接扩展到有 $m$ 种颜色的情况。
### 代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=2e6+5;
int a[maxn],c[maxn],n;
long long f[maxn],val[2];
void solve(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]);
	val[0]=val[1]=1e18;
	for(int i=1;i<=n;i++){
		val[c[i]]=min(val[c[i]],f[i-1]+a[i]);
		f[i]=a[i]+val[c[i]];
	}
	printf("%lld\n",f[n]);
}
int main(){
	int t;
	scanf("%d",&t);
	while(t--) solve();
	return 0;
}
```

---

## 作者：_Z_F_R_ (赞：0)

首先设 $f_i$ 为扫第 $1 \sim i$ 中所有台阶所花最小代价。

易得转移方程：
$$f_i = \min_{0 \leq j < n,c_{j+1}=c_i}(f_j + a_{j+1} + a_i)$$
其中 $f_0 = 0$（即一个都没扫）。

仔细观察，可把 $a_i$ 移到外面：
$$f_i = \min_{0 \leq j < n,c_{j+1}=c_i}(f_j + a_{j+1}) + a_i$$
发现 $\displaystyle \min_{0 \leq j < n,c_{j+1}=c_i}(f_j + a_{j+1})$ 可以维护。

令 $\displaystyle x0 = \min_{0 \leq j < n,c_j + 1 = 0}(f_j + a_{j + 1}),x1 = \min_{0 \leq j < n,c_j + 1 = 1}(f_j + a_{j + 1})$，则：
$$f_i =
\begin{cases}
x0 + a_i,& \text{if }c_i = 0 \\
x1 + a_i,& \text{otherwise.}
\end{cases}$$

代码如下：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 2000005;
int n;
ll a[N],f[N];
bool c[N];

int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int i;
        scanf("%d",&n);
        for(i = 1;i <= n;i++)
            scanf("%lld",&a[i]);
        for(i = 1;i <= n;i++)
            scanf("%d",&c[i]);
        ll x0,x1;
        if(!c[1])
            x0 = a[1],x1 = 0x3ffffffffffffff;
        else
            x1 = a[1],x0 =0x3ffffffffffffff;
        for(i = 1;i <= n;i++)
        {
            ll t;
            if(!c[i])
                t = x0;
            else
                t = x1;
            f[i] = t + a[i];//转移
            if(!c[i + 1])//更新 x0,x1
                x0 = min(x0,f[i] + a[i + 1]);
            else
                x1 = min(x1,f[i] + a[i + 1]);  
        }
        printf("%lld\n",f[n]);
    }
}
```

---

## 作者：masonpop (赞：0)

这道题也不是很难。

首先朴素的一维 $dp$ 是很容易想到的。令 $dp_i$ 表示擦去前 $i$ 块木板的灰尘所需要的最小代价。显然，转移方程是：

$dp_i=\min\limits_{1\leq j< i,c_i=c_{j+1}}\{dp_j+a_i+a_{j+1}\}$。

这样做的复杂度是 $O(\sum n^2)$，可以得到 $40$ 分。考虑优化。

注意到，如果 $c_1=c_n$，那么直接消除掉 $[1,n]$ 区间一定最优。正确性是显然的。

如果 $c_1\ne c_n$，那么，我们一定可以从中间的某一个位置断开，分成两段消除。具体的，$\exists x\in[1,n-1]$，使得 $c_1=c_x$，$c_{x+1}=c_n$。

可以考虑反证法，如果不存在这样的 $x$，由于 $c_2\ne c_n$，故 $c_2=c_1$。 以此类推，$c_{n-1}=c_1$。这就推出了矛盾，因为可以取 $x={n-1}$。

接下来，再证明分成两段一定是最优的。再考虑反证法。如果分成 $3$ 段及以上更优，假设整个序列被分成了 $[1,l],[l+1,r-1],[r,n]$ 三段。
显然，由于 $c_1\ne c_n$，故一定有 $c_1=c_{l+1}$ 或 $c_{r-1}=c_n$。此时将前两段和后两段合在一起消除更优。这就推出了矛盾。

因此，无论是哪种情况，都只需要线性扫描一边即可解决。时间复杂度降为 $O(\sum n)$，可以通过。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e6+10;
int t,n,a[maxn],c[maxn];
signed main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld",&n);
		for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
		for(int i=1;i<=n;i++)scanf("%lld",&c[i]);
		if(c[1]==c[n])
		{
			printf("%lld\n",a[1]+a[n]);
			continue;
		}
		int ans=4e10;
		for(int i=1;i<=n-1;i++)
		{
			if(c[1]==c[i] && c[i+1]==c[n])
			{
				ans=min(ans,a[1]+a[n]+a[i]+a[i+1]);
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---


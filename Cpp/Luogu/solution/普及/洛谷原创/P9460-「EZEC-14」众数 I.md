# 「EZEC-14」众数 I

## 题目背景

pigstd 是一个可爱的男孩子。他在 NOI2022 中的众数一题定义了 $10^6$ 个 ``std::deque`` 并没有 MLE。

## 题目描述

给定一个长度为 $n$ 的序列 $a$，我们通过以下方式构造序列 $b$：

- 初始时 $b=a$。
- 依次对 $b$ 进行 $k$ 次操作，每次操作选择任意一个元素并将其**修改**为任意整数。

dXqwq 定义一个序列的**众数**为所有出现次数最大的数。例如 $[1,1,4,5,1,4]$ 的众数为 $1$，而 $[1,14,5,14,19,19,8,10]$ 的众数为 $14,19$。

你需要求出有多少整数可能成为 $b$ 的**众数**。

## 说明/提示

**【样例解释】**

对于第一组数据，最终 $1,2,3,4,5$ 可能为区间众数。

对于第二组数据，将第一个数换成 $6,7,8,9,\cdots$ 后它们均会成为区间众数，因此答案为正无穷。

对于第三组数据，$1,2,3$ 可能成为区间众数。

**【提示】**

开 $10^6$ 个 ``std::deque`` 在空间限制为 1024MB 时不一定会 MLE。

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（20 pts）：$n\leq 5$。
* Subtask 2（20 pts）：$n\leq 10^3$。
* Subtask 3（20 pts）：$k=0$。
* Subtask 4（20 pts）：$k=1$。
* Subtask 5（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

## 样例 #1

### 输入

```
5 0
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
5 1
1 2 3 4 5```

### 输出

```
pigstd```

## 样例 #3

### 输入

```
5 1
1 1 2 2 3```

### 输出

```
3```

# 题解

## 作者：ys_kylin__ (赞：25)

首先，我们一看这道题，数据范围整整 $10^6$，那就不可能用枚举了，然后思考一下，我能修改 $k$ 个数，那肯定是每一次都挑选最大的，可是由于当前的最大数是实时更新的，不可能慢慢找。于是我们便找到了办法：二分！

二分的时间复杂度是 $O(n \log n)$，而 $10^6$ 刚刚好不会爆。

我们需要每次二分一条“众数线”设为 $mid$，即当一个数出现的次数大于等于 $mid$ 时，他便可能成为众数。

那 check 怎么写这个问题，就简单多了。

每次的 $x$ 首先加 $k$（因为无论选择哪个，最终 $mid$ 都会加 $k$），然后遍历计数数组（计算每个数出现的次数），如果发现大于 $x$，就把多出来的部分记下，最后把记下的数与 $k$ 比较就行了。

注意一下，若最后二分出的数为零，输出正无穷（也就是 `pigstd`）。

好了，直接上代码（赛时写的比较丑，见谅）。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005],vis[1000005];
int n,k,maxa=0;//maxa为原数组中众数出现的次数
int mp[1000005];//用来存每个数出现的次数
//特殊说明：用map会TLE,int就行
int check(int x) {
	memset(vis,0,sizeof vis);
	x+=k;
	long long m=0;
	for(int i=1;i<=n;i++) {
		if(mp[a[i]]>x && vis[a[i]]==0) {
			vis[a[i]]=1;
			m+=mp[a[i]]-x;
		}
	}
	if(m>k) return 0;
	else return 1;
}
int main() {
	int ans=0;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		mp[a[i]]++;
		maxa=max(mp[a[i]],maxa);
	}
	if(k>=maxa) {//并无意义，只是为了方便
		printf("pigstd");
		return 0;
	}
	int l=0,r=1000000,mid;
	while(l<r) {//二分
		mid=(l+r)>>1;
		if(check(mid)) {
			r=mid;
		}
		else {
			l=mid+1;
		}
	}
	if(l==0) {
		printf("pigstd");
		return 0;
	}
	for (int i=1;i<=1e6;i++)
		if(mp[i]>=l) ans++;
	printf("%d",ans);
   return 0;
}
```

---

## 作者：dead_X (赞：25)

## Solution

显然如果我们要让众数为 $x$，一定会不断地把出现次数最多的一个数改成 $x$。

因此我们只需要算出需要更改几次即可。

记 $c_x$ 为 $x$ 的出现次数，对于一个出现了 $c_y>c_x+k$ 次的数，我们需要 $c_y-c_x-k$ 次操作将其删到只出现 $c_x+k$ 次，因此当且仅当 $\sum\max(c_y-c_x-k,0)\leq k$ 时才可以达成。

使用前缀和可以快速计算上式，时间复杂度 $O(n)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int a[2000003],c[1000003];
signed main()
{
	int n=read(),k=read(),ans=0;
	for(int T=n; T--; ++c[read()]);
	for(int i=1; i<=n; ++i) ++a[c[i]];
	for(int i=n+k,c=0,s=0; i>=k; --i)
	{
		s+=c,c+=a[i];
		if(s>k) printf("%d\n",ans),exit(0);
		ans+=a[i-k];
	}
	puts("pigstd");
	return 0;
}
```

---

## 作者：Light_az (赞：11)

在讲本题思路前先代入一个故事帮助理解：现在老师分给你和同学一些钱，但是你分到的竟然不是最多的。

你十分生气，但是老师给了你一个特权：你可以从某一个同学手中拿走 $x$ 元给自己。

现在如果你想让自己与有最多钱的同学之间的差距尽可能的小，你应该怎么做？

贪心地来想，肯定是从钱最多的同学手上拿走 $x$ 元，但事实是这样吗？

假设你有 $10$ 元，而另外两个同学有 $15$ 元，当 $x=2$ 时，贪心操作后你和两个同学的钱分别为 $12,13,15$ ，此时差距为 $3$ 元。

但如果分别从两个同学手中拿走 $1$ 元，此时钱变成了 $12,14,14$，差距只有 $2$。



------------

现在我们把问题转化一下，你和同学分别是序列中的数字，而钱则是数字出现的次数。

题目要求我们经过 $k$ 次变化后尽可能的多构造众数，根据上面的故事我们明确了思路：

每次将最大值减 $1$，然后重复操作 $k$ 次。

但是在上面的故事中我们发现，随着 $k$ 次操作中的其中一次，最大值可能变成了次大值，因此我们想到用堆来维护最大值，将每个数的初始出现次数存入其中，再进行 $k$ 次操作，代码如下：

```cpp
	F(i,1,k){
		ll p=q.top();
		q.pop();
		p--;
		q.push(p);
	}
```

此时如果某个数的出现次数加上 $k$ 是大于等于堆顶的，那么这个数一定可以构造成众数。

但是题目说明有无数种解的情况存在，我们继续考虑：

当任何一个初始出现了 $0$ 次的数加上 $k$ 依然大于堆顶，那么除了 $[1,n]$ 以外的数一定都可以构造成众数，那么此时一定有无数种解。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,j,n) for(ll i=j;i<=n;i++)
#define D double
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e6+10;
ll n,m,k,x,y,u,v,w,cnt,ans,t,l,r,len,T,id;
ll mn=INT_MAX,mx=0,p,opt;
ll a[N],b[N],c[N],sum[N];
priority_queue<ll> q;
int main(){
	cin>>n>>k;
	F(i,1,n){
		cin>>a[i];
		sum[a[i]]++;
	}
	F(i,1,n) if(!c[a[i]]) c[a[i]]=1,q.push(sum[a[i]]);//出现次数入堆
	F(i,1,k){//贪心
		ll p=q.top();
		q.pop();
		p--;
		q.push(p);
	}
	if(k>=q.top()){//出现了0次的数加上k大于堆顶，说明有无数种解
	    cout<<"pigstd";
	    return 0;
	}
	F(i,1,n) if(!b[a[i]]&&sum[a[i]]+k>=q.top()) b[a[i]]=1,ans++;//加上k大于堆顶，说明这个数可以构造成众数
	cout<<ans;
	return 0;
}

```


---

## 作者：Link_Cut_Y (赞：8)

首先我们可以先考虑一个判定性问题：如何判断一个数能不能成为众数？

先从特殊情况讨论：假设这个数是原数列中出现过的数。由于题目与数的值本身无关，只与这个数出现的次数有关。所以一个很平凡的思路就是开一个桶累计每个数出现的次数，然后按照出现次数降序排列。

假设排序后的桶为 $b$，需要判定的数出现次数为 $b_i$。这个数要成为众数，就说明数列中没有比它大的数。假设现在桶里的情况是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/sehr1wgp.png)

图中每个黑色框框表示一个数出现的次数，红色框框表示 $k$。最后那个黑框框上拼了个红色框框表示 $b_i + k$ 的值。

现在桶中 $b_1, b_2$ 都比 $b_i + k$ 大。所以需要从把他们两个中抽出至少 $k$ 个扔到 $b_i$ 上。

![](https://cdn.luogu.com.cn/upload/image_hosting/dxh7f0cw.png)

如图，即将两个黄色部分补到红色框框里。

假设黄色部分大小为 $x$，如果 $x \le k$，则 $b_i$ 可以成为区间众数，反之不可。

### Algo. 1

对 $b_1 \sim b_n$ 依次进行判定。判定时，通过枚举找到 $ > b_i + k$ 的最靠右的位置，设为 $t$。则判定条件即为 $\sum \limits_{j = 1}^{t} b_j - (b_i + k) \le k$。时间复杂度 $O(n ^ 2)$。

### Algo. 2

我们神奇的发现 $t$ 位置可以二分。我们又神奇的发现 $\sum \limits_{j = 1}^{t} b_j - (b_i + k) \le k$ 可以前缀和。所以时间复杂度 $O(n \log n)$。

### Algo. 3

我们神奇的发现对 $t$ 的寻找过程可以再优化：$t$ 的位置单调右移。所以我们搞一个指针指在 $t$ 上，每次暴力跳就可以了。时间复杂度瓶颈在排序上，如果使用桶排则复杂度 $O(n)$

接下来考虑无解怎么判断。很简单，在原数组后面添个 $0$，然后判断一下这个出现 $0$ 次的数能不能成为众数就好了。

这里给出一个实现非常糟糕的 $O(n)$ 代码：

```cpp
#include <cstring>
#include <cstdio>
#define N 1000010
using namespace std;

int n, k, ans, a[N], bin[N], p[N], s, c;

int main() {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i ++ ) {
		scanf("%d", &a[i]);
		bin[a[i]] ++ ;
	}
	for (int i = 1; i <= n; i ++ )
		if (bin[i]) p[ ++ c] = bin[i];
	memset(bin, 0, sizeof bin);
	for (int i = 1; i <= c; i ++ )
		bin[p[i]] ++ ;
	c = 0; memset(p, 0, sizeof p);
	for (int i = n; i >= 1; i -- )
		for (int j = 1; j <= bin[i]; j ++ )
			p[ ++ c] = i;
	n = c + 1;
	int it = 1;
	for (int i = 1; i <= n; i ++ ) {
		while (p[it] > p[i] + k) s += p[it ++ ];
		int cnt = s - (p[i] + k) * (it - 1);
		if (cnt <= k) ans ++ ;
		else break;
	}
	if (ans == n) puts("pigstd");
	else printf("%d\n", ans);
	return 0;
}
```

~~我知道我代码写的丑不要喷好不好。~~

---

## 作者：icypenguin (赞：5)

### 题目简述

一个长度为 $n$ 的序列 $a$，修改 $k$ 次，求其所有可能的众数的数量。


### 题目分析

我们每次可以把一个数替换为另外一个数，例如我们想要把序列 $a$ 的众数变为 $q$，我们可以每次把序列 $a$ 中的众数中的一个改成 $q$，这是出于贪心地考虑。

我们可以想到使用优先队列来维护，每次维护 $a$ 中每个数字出现最多的数量，操作时，将这个数字改成想要的数字，所以这个数字的出现次数会减少 $1$。我们把原来的数字弹出优先队列，修改后再弹入优先队列。

最后，我们得到的优先队列的顶部元素就是如果 $q$ 想成为众数，则它修改 $k$ 次后在 $a$ 中至少出现的次数，我们将这个次数称为 $x$，也就是它在修改前在 $a$ 中至少出现 $x - k$ 次。

不妨用 map 统计 $a$ 中每个数字出现的次数，将出现的次数压入优先队列再进行如上操作。接着，遍历一遍 map，寻找所有出现次数符合条件的元素，统计数量即可。

最后一步，维护所有数都可以的情况。很明显，如果 $x \leq 0$，甚至刚开始在 $a$ 中一次没有出现的数字都可能成为众数，所以输出 ```pigstd```。

这种做法的时间复杂度为 $O(k\log n + n \log n)$，其中 $k \log n$ 是优先队列的时间复杂度，$n \log n$ 是 map 的时间复杂度。


### 代码实现

```cpp
#include <iostream>
#include <queue>
#include <map>
#define ll long long
using namespace std;
ll n, k, a[1000005];
priority_queue<ll> q;
map<ll, ll> mp, book;

int main(){
    cin >> n >> k;
    for (ll i = 1; i <= n; i++){
        cin >> a[i];
        mp[a[i]]++;
    }
    for (auto it : mp){
        q.push(it.second);
    }
    for (ll i = 1; i <= k; i++){
        ll xi = q.top();
        q.pop();
        q.push(xi - 1);
    }
    ll to = q.top() - k, x = q.top(), cnt = 0;
    if (k >= x){
        cout << "pigstd" << endl;
        return 0;
    }
    for (auto it : mp){
        if (it.second >= to){
            cnt++;
        }
    }
    cout << cnt << endl;
    return 0;
}
```




---

## 作者：fish_love_cat (赞：2)

好题！

---

**40 分解法：**

首先可以想到，为了让一个数变为区间众数，我们一定会把 $k$ 次机会全部用于把别的数改成该数，让这个数的数量加 $k$。

此时比较一下这个数与原来数组内出现次数最多的数出现的次数，如果不小于，就说明已经没有东西大过他了。那么这个数妥妥的就是区间众数了。

如果有个数没出现过，但加上 $k$ 后仍成立，那这就是无限解的情况了，直接输出 `pigstd` 结束。

**失去 60 分原因解析：**

上面的问题在哪呢？再读一遍题后你会发现，这里不是**增加** $k$ 个数，而是**修改** $k$ 个数。因为这个原因，他不仅能利己，还会损其他数的数量。本来高不可攀的最大值，一个减少，啥都不是了。

**满分解法：**

其实加上上面的，大体就对了，不过别忽视了一个细节，就是在缩小最大的时候，他可能已经不是最大了。那这个时候，如果再把不是最大的当最大来比，那注定是错的。

所以还需要暴力扫一遍过去，记录超了现在点几个，如果小于 $k$，那就说明可以统统损掉，可以变区间众数，答案加一。最后输出统计完成后的答案即可。

~~我一直以为会 TLE 的，没想到快的飞起（汗）~~

---

**最后的代码：**

别忘了判 `pigstd` 的情况！

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005],b[1000005],sum,hh;
bool cmp1(int a,int b){return a>b;}
int n,k,ans;
bool cs(){
    return hh<=k;
}
signed main(){
	cin>>n>>k;
    for(int i=1,x;i<=n;i++) cin>>x,sum+=(a[x]==0?1:0),a[x]++;
    sort(a+1,a+1+n,cmp1);//排一遍，就只需要扫sum大小的数组了，省时（？）
    for(int i=1;i<=sum;i++) hh+=max(a[i]-k,(int)0);//计算为0的差距
    if(cs()){//意义不明的函数用于判断pigstd
        puts("pigstd");
        return 0;
    }
    
    for(int i=1;i<=sum;i++){
        if(b[a[i]]==1) ans++;
        else if(!b[a[i]]){//不加TLE，这算是记忆化（？）
            int w=0; 
            for(int j=1;j<i;j++){
                w+=max(a[j]-a[i]-k,(int)0);//暴力
            }
            if(w<=k) ans++,b[a[i]]=1;
            else b[a[i]]=-1;
        }
    }
    cout<<ans<<endl;
    return 0;
}
/*
再附赠各位一组淦过我代码的数据：

input:
10 1
1 1 2 2 2 2 3 3 3 3

output:
2
*/
```

---

赛时调了仨小时，我真是……

---

## 作者：GaoKui (赞：2)

蛮有趣的思维题

首先对于原始序列，可以使用 ```unordered_map``` 进行存储。在输入的同时，用后件记录每个数字出现了几次，并得到最多出现次数是多少。这样处理的话，等到输入完毕，只需要线性遍历 ```unordered_map``` 即可得出原始的众数有几个，分别是多少，这个 ```unordered_map``` 在下面的代码里就是 ```mp```。

另外还需要再用一个 ```map``` 记录以下信息，这个 ```map``` 在下面的代码中就是 ```num```（需要保证内部元素顺序，不能用 ```unordered_map```）：

假设在该 ```map<int, int> num``` 中，将前件取名为 $t$，则 ```num[t]``` 表示的意义是：在原始序列中，出现了 $t$ 次的数字，总共有多少个。

之后，我们可以对原始序列进行 $k$ 次操作，令其众数发生变化。如果我们想让众数变为一个新的数字 $a$，我们应该怎么操作？

先考虑最愚蠢的方法，我们可以任意挑选 $k$ 个不是 $a$ 的元素，将它们变为 $a$。此时，一个数字 $a$ 能变为众数的条件就是：$a$ 原本出现的次数 $+ k >=$ 众数出现的次数。即：```mp[a] + k >= mx```。

首先，我们判断一下，如果 ```k >= mx```，说明原本出现次数为 $0$ 的数字，也能够成为众数。此时，能成为众数的数字有无穷多个，应输出 ```pigstd```。而如果 ```k < mx```，就直接遍历一遍 ```mp```，对于每一个数字 $a$，如果 ```mp[a] + k >= mx```，说明这个数字可以成为众数。统计一下满足要求的 $a$ 有几个，最后输出这个个数即可。

然而很容易就会发现，任意挑选 $k$ 个不是 $a$ 的元素，这并不是最优的操作方法。

考虑以下例子：
```
5 1
1 1 1 2 3
```
比如，现在想让 $2$ 成为众数，我们任意挑选一个元素 $3$，将其变为 $2$，此时 $2$ 并不能成为众数。实际上，我们只需要挑选一个原本的众数 $1$，把它变为 $2$，那么 $2$ 就能够成为众数了。

因此，操作的方案应该是这样的：每次想要修改一个数字，我们就找到当前的众数是多少，将其中一个众数修改为我们想要修改的数字。这样一来，不仅修改后的 $a$ 的个数增加了，原本众数的数量也减少了，新的数字 $a$ 就更有可能成为众数了。

按照以上方法，原本的 ```mp[a] + k >= mx``` 这一个判断条件，就可以改为 ```mp[a] + k + dis >= mx```。原本判断是否有无穷多个数能成为众数的条件 ```k >= mx```，也可以改为 ```k + dis >= mx```。其中，$dis$ 表示我们将策略修改之后，能够节省多少次操作次数。由于原始序列的众数是确定的，对于所有想要修改为众数的数字 $a$，$dis$ 这个值都是一样的。现在只需要求出 $dis$ 这个值，然后按照上面的方法判断每个数字能否成为众数即可。

还是以上面的例子为例，一开始众数出现的次数是 $3$，本来新的数字是要出现 $3$ 次才能变为新众数的。但是如果按照上面说过的策略，优先挑选当前众数进行更改，把众数出现次数变为了 $2$，那么现在新数字只要出现 $2$ 次行了。

但是当前的众数并不一定只有一个，比如下面的例子：
```
9 1
1 1 1 2 3 3 4 4 4
```
由于一开始众数有两个，想要让 $2$ 变为众数，不仅要改掉一个 $1$，还要改掉一个 $4$，此时操作次数是不够更改的。于是，我们一开始定义的 ```map<int, int> num``` 就可以起到作用了。

用一个 $sum$ 记录当前的众数个数，这个值一开始就是 $num$ 中最后一个元素的后件。当剩余操作次数 $>=$ 当前的众数个数，只需要把当前的众数每一个都改掉一个数字，$dis$ 就可以 $+1$。随着众数的出现次数减少，众数的个数也会越来越多，这个只要通过 $num$ 里的其他元素就可以进行统计了。

比如，在上面的例子里，一开始众数出现次数为 $3$，所以 $sum$ 的值为 ```num[3] = 2``` （有 $1$ 和 $4$ 两个众数）。等到把 $1$ 和 $4$ 都改掉一个以后，众数出现次数变为 $2$，此时 $3$ 也变为了一个众数，$sum$ 需要再加上 ```num[2] = 1```。此时的 ```sum``` 就变为了 $3$。

$dis$ 可以一直这样增加，直到剩余操作次数不够用为止。最后计算出 $dis$，然后按照上面说过的式子来判断每个数字是否可以变为众数即可。

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, k, ans, mx, dis;
unordered_map<int, int> mp;
map<int, int> num;

int main(void)
{
    int tmp;
    cin >> n >> k;

    for (int i = 0; i < n; i++)
    {
        cin >> tmp;
        mp[tmp]++;              // 把原始序列存到 mp 里
        mx = max(mx, mp[tmp]);  // 找到一开始众数的出现次数
    }

    for (auto j : mp)
    {
        num[j.second]++;    // 得到出现次数为 i 的数字有几个，并存在 num[i] 中
    }

    map<int, int>::iterator it = num.end(), tit;
    it--;
    int sum = it->second;   // sum 一开始的值，是 num 最后一个元素的后件
    int kk = k;             // 用 kk 存储剩余操作次数，一开始初始化为 k
    int cnt = 0;            // cnt 相当于一个偏移量

    while (kk >= sum)       // 剩余操作次数 >= 当前众数个数，dis 可以增加
    {
        dis++;
        kk -= sum;          // 把每一个众数都改变一次，即可是 dis 增加 1

        if (it == num.begin()) continue;    // 如果 it 指向 num 的第一个元素，众数的个数不会再增加了，直接继续循环即可

        tit = it;   // tit 为 it 的前一个元素
        tit--;

        if (it->first - 1 - cnt == tit->first)  // 如果 tit 的前件值，正好是 it 前件值 - 1 - cnt
        {
            cnt = 0;                            // 清空计数器
            it--;                               // it 向前走
            sum += it->second;                  // 当前众数的个数增加了 it->second 个
        }
        else cnt++;                             // 否则说明本次 dis 增加不会导致众数个数增加，令计数器自增
    }

    if (mx - dis <= k)  // 如果连出现次数为 0 的数都可以变为众数，说明能变为众数的数字个数为无穷多个
    {
        cout << "pigstd";
        return 0;
    }

    for (auto j : mp)   // 否则遍历每一个在 mp 中的数字，只要有一个能变为众数，答案就增加 1
    {
        if (mx - j.second - dis <= k) ans++;
    }

    cout << ans;

    return 0;
}
```


---

## 作者：ZeroF (赞：2)

题目中

> 你需要求出有多少整数可能成为 $b$ 的**众数**。

想表达的意思应该是

> 你需要求出有多少种数可能成为 $b$ 的**众数**。

吧。

所以你输出的是能成为众数的**种类数**，而不是个数。


## 解法：

这里我提供一种贪心的做法。

首先只需维护出每一种数出现的次数（因为题目只关心可能成为众数的数的数量）。

接下来我们思考怎样一种数才可能成为众数。

经过 $k$ 次修改以后，一种数只有在**被修改后出现次数大于等于被修改后出现次数最大的那种数的出现次数**时才可以成为众数。

那么每一次修改是什么呢？

想要让第 $i$ 种数成为众数，对于每一次修改，我们将除了**第 $i$ 种**数外的**一个**数修改为**第 $i$ 种**数。这样就让**第 $i$ 种数**出现的次数 $+1$ ，让除了**第 $i$ 种**数外的**一种数**出现的次数 $-1$ 。不难想到，这样可以让第 $i$ 种数出现的次数最大。

具体来说，设第 $i$ 种数出现的次数为 $v_i$ ，那么它在被操作 $k$ 次后出现的次数为 $v_i+k$ ，设经过操作后的最大出现次数为 $x$ ，那么第 $i$ 种数能成为众数的条件是：

$$v_i+k \geq x$$

**因为 $v_i+k$ 已经确定了，所以想让成为众数的数尽可能多，就要让 $x$ 最小。**

怎么让 $x$ 最小呢？

我们让当前一个最大的出现次数 $-1$ ，然后把它放回原数列，再找到当前一个最大的出现次数，如此操作 $k$ 次就可以了。

比如一个数组 $v=[1,2,3,5,4,3]$ ，经过 $5$ 次操作后的状态如下：

第一次操作：

$$[1,2,3,4,4,3]$$

第二次操作：

$$[1,2,3,3,4,3]$$

第三次操作：

$$[1,2,3,3,3,3]$$

第四次操作：

$$[1,2,2,3,3,3]$$

第五次操作：

$$[1,2,2,2,3,3]$$

由于每次都要取出其中的最大值，所以这个问题刚好可以用大根堆（优先队列）来解决。每次操作取出堆顶，将其 $-1$ ，然后丢回堆里面。

核心代码如下：

```cpp
priority_queue<int>q;
for(int i=1;i<=tot;i++){
	q.push(v[i]);
}
while(k--){
	int tmp=q.top()-1;
	q.pop();
	q.push(tmp);
}
tmp=q.top();
```

由于堆每次操作的复杂度为 $O(\log n)$ ，$k$ 次操作的复杂度就是 $O(k \log n)$ ，也就是 $O(n \log n)$ ，在 $10^6$ 的数据下可以通过。


最后一个问题，怎么处理无限多种数可以成为众数的情况？

**如果经过操作后的最大出现次数 $x \leq k$ 时，也就是说任意一个数操作 $k$ 次都能修改成众数，自然答案就是无限了。**

## 代码如下（写的不太好）：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int cnt[1919810],v[1919810];
priority_queue<int>q;
int n,k,tot;
signed main(){
	cin>>n>>k;
	int vk=k;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		cnt[x]++;
	}
	for(int i=1;i<=n;i++){
		if(cnt[i])v[++tot]=cnt[i];
	}
	for(int i=1;i<=tot;i++){
		q.push(v[i]);
	}
	int mx=q.top();
	while(k--){
		int x=q.top()-1;
		q.pop();
		q.push(x);
	}
	int ww=q.top(),ans=0;
	if(ww<=vk){
	    cout<<"pigstd"<<endl;
	    return 0;
	}
	for(int i=1;i<=tot;i++){
		if(v[i]+vk>=ww){
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：StayAlone (赞：2)

一个神秘的做法，时间复杂度大约是 $\mathcal O(n\log n+\log n^3)$。最后这个三 log 是加上去的！

省流：二分套二分套二分。

考虑把问题转化为：找到一个最小的 $k$，满足所有出现次数大于等于 $k$ 的数都有可能成为众数。

显然当 $k=0$ 时，答案就是有无限个。

而这个 $k$ 也显然是满足二分的性质的。考虑如何 check。

对于一个出现了 $k$ 次的 $x$，为了让它成为众数，就要把所有出现次数大于 $k$ 的数“削平”。而这些数在削的同时，还会给这个 $x$ 的出现次数增加贡献。那么到底削成多少呢？发现这个事情可以二分。

考虑如何 check。只需要先拿一个桶记录一下每个数的出现次数排序后前缀和再套一个二分即可。这个仔细想想就能想到了，详细可以看看代码。

最后统计一下有多少数的出现次数大于等于二分出来的 $k$ 即可。

时间复杂度瓶颈在于排序，大不了桶排变成线性！

[AC record](https://www.luogu.com.cn/record/115821129)

```cpp
int n, k, ans, a[MAXN], cnt[MAXN], sum[MAXN];

il int upperbound(int x) {
	int l = 1, r = n;
	while (l ^ r) {
		int mid = l + r + 1 >> 1;
		if (cnt[mid] > x) l = mid;
		else r = mid - 1;
	} return l;
}

il int get(int x) {
	int it = upperbound(x);
	return sum[it] - 1ll * x * it;
}

il int check(int x) {
	int l = 1, r = cnt[1];
	while (l ^ r) {
		int mid = l + r >> 1;
		if (get(mid) <= k) r = mid;
		else l = mid + 1;
	} return x + k >= l;
}

int main() {
	read(n, k); rer(i, 1, n, a);
	rep1(i, 1, n) ++cnt[a[i]];
	sort(cnt + 1, cnt + 1 + n, greater <int> ());
	rep1(i, 1, n) sum[i] = sum[i - 1] + cnt[i];
	int l = 0, r = n;
	while (l ^ r) {
		int mid = l + r >> 1;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}
	if (!l) return puts("pigstd"), 0;
	rep1(i, 1, n) ans += cnt[i] >= l;
	printf("%d", ans);
	rout;
}
```

---

## 作者：船酱魔王 (赞：1)

# P9460 众数 I 题解

## 题意回顾

对于长度为 $ n $ 的序列 $ a $ 进行 $ k $ 次单点修改操作，求出有多少个数可能成为众数。

$ n \le 10^6 $，$ k \le n $，$ 1 \le a_i \le n $。

## 分析

因为众数无关于数的顺序只和数的出现次数有关，因此我们对于 $ a $ 数组开个桶子 $ cnt $，$ cnt_i $ 表示 $ i $ 在 $ a $ 中的出现次数。

我们对于 $ 0 \sim n $ 中每个数考虑是否可以成为众数，因为 $ 0 $ 从未出现因此只要 $ 0 $ 可以所有数都可以，这样处理主要是能简化分类讨论情况。

我们维护两个前缀和，$ c_i $ 表示出现次数小于等于 $ i $ 的数的数值种类数，$ cs_i $ 表示出现次数小于等于 $ i $ 的数的出现总次数。

我们要是想要让 $ x $ 为众数，所有修改显然都要改为 $ x $，则 $ x $ 的出现次数为 $ cnt_x+k $，如果大于 $ n $ 说明肯定是众数，计数器加一并 ```continue``` 掉，这一特判主要是为了避免数组越界。

我们发现所有出现次数超过 $ cnt_x+k $ 的都要改，使得出现次数小于等于 $ cnt_x+k $，要改的数的数量为 $ cs_{n}-cs_{cnt_x+k}-(c_{n}-c_{cnt_x+k}) \times (cnt_x+k) $，这个值小于等于 $ k $ 说明可以为众数，否则要改的数太多就不能为众数。

## AC 代码

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define int long long
using namespace std;
const int N = 1e6 + 5;
int n, k;
int a[N];
int cnt[N];
int c[N];
int cs[N];
signed main() {
	scanf("%lld%lld", &n, &k);
	for(int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
		cnt[a[i]]++;
	}
	for(int i = 1; i <= n; i++) {
		c[cnt[i]]++;
		cs[cnt[i]] += cnt[i];
	}
	for(int i = 1; i <= n; i++) {
		c[i] += c[i - 1];
		cs[i] += cs[i - 1]; 
	}
	int tps = 0;
	for(int i = 0; i <= n; i++) {
		if(cnt[i] + k > n) {
			tps++;
			continue;
		}
		if(cs[n] - cs[cnt[i] + k] - (c[n] - c[cnt[i] + k]) * (cnt[i] + k) <= k) {
			tps++;
		}
	}
	if(tps == n + 1) {
		cout << "pigstd" << endl;
	} else {
		cout << tps << endl;
	}
	return 0;
}
```

## 总结与评价

场上切了，认为难度黄，比较清新的贪心题。

---

## 作者：AfterFullStop (赞：1)

首先，如果这题 $k=0$，那么很显然直接求众数个数即可，白嫖 $20$ 分。

注意到 $1 \le a_i \le n$，故可以把 $a_i$ 塞进桶里，于是这题就变成如下题目：

> 给定一数列 $b$（数列末尾补着无数个 $0$），每次操作可以选定 $i,j$，使 $b_i \to b_i-1,b_j \to b_j+1$，问有多少个数可以在 $k$ 次操作内成为数列中的最大值。

先考虑 $O(n^2)$ 做法：

对于每一个 $b_i$，可以先令 $t_i=b_i+k$，在此之后将比 $t_i$ 大的数全部降到 $t_i$，比较一下 $k$ 与降数的代价，如果 $k$ 大于等于代价那么可以 $ans \to ans + 1$。

代价计算十分简单，直接算 $\sum\limits^{n}_{j=1}\max(b_j-t,0)$ 即可（这里 $b_i$ 是已经加上 $k$ 的）。

 $60$ 分到手（如果在 $k=0$ 基础上搞点特判可以过掉 $k=1$ 拿 $80$）。
 
然而这样是过不掉最后一个 subtask 的，因此可以考虑优化代价的计算。

注意到如果提前把 $b$ 分成大于 $t_i$ 下面用长度为 $m$ 的数列 $c$ 指代这部分）与小于等于 $t_i$ 两部分，那么 $\max$ 是可以去掉的，而去掉之后代价又可以拆成 $\sum\limits^{m}_{j=1}c_j -mt_i$，而 $\sum\limits^{m}_{j=1}c_j$ 又可以用前缀和计算，于是在划分后可以 $O(1)$ 计算代价。

至于划分，可以提前对 $b$ 排序，排完之后对每个 $t_i$ 二分查找即可。

时间复杂度 $O(n \log n)$（实际上必然可以做到 $O(n)$，但我的 $O(n)$ 挂了，还在调呢），题目要求 $n \le 10^6$，再加上会有不少重复的，非常可过。

```cpp
#include <bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;
/*
每道题check的步骤：
1.maxn
2.有无mod
3.图是否联通
4.数据最大值（有无超int/ll/int128）
*/
const int maxn=1e6+5;
int n,k;
int a[maxn],b[maxn],c[maxn];
signed main(){
    ios::sync_with_stdio(0);
    cin>>n>>k;
    for(ri i=1;i<=n;i++){cin>>a[i];b[a[i]]++;}
    sort(b+1,b+n+1);
    for(ri i=1;i<=n/2;i++)swap(b[i],b[n-i+1]);
    int cnt=0;
    for(ri i=1;i<=n;i++)cnt+=(b[i]?1:0);
    n=cnt;
    sort(b+1,b+1+n);
    for(ri i=1;i<=n;i++)c[i]=c[i-1]+b[i];
    cnt=0;
    for(ri i=1;i<=n+1;i++){
        int t=b[i]+k,kk=k;
        int fd=upper_bound(b+1,b+1+n,t)-b;
        kk-=c[n]-c[fd-1]-t*(n-fd+1);
        if(kk>=0){
            cnt++;
            if(b[i]==0){cout<<"pigstd";return 0;}
        }
    }cout<<cnt;return 0;
}
```

---

## 作者：ncwzdlsd (赞：0)

> 对一个序列修改 $k$ 次，求可能成为众数的数的数量

记录每个数的出现次数 $cnt_i$。对于与序列中的每一个 $a_i$，若想让它成为序列众数，一定是要不断地把当前的序列众数尽量多的修改为 $a_i$。设序列众数为 $M$，这种修改方案是可行的，当且仅当 $\sum (M-(a_i+k))\leq k$。

每一次操作后的序列众数可以通过优先队列维护。

考虑何时答案为正无穷。若 $k$ 不小于序列中出现次数最多的数的出现次数，则任何一个不在序列中的数都可以作为区间众数。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1e6+5;
int a[maxn],cnt[maxn];
priority_queue<int> q;
bool vis1[maxn],vis2[maxn];

signed main()
{
	int n,k;cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],cnt[a[i]]++;
	for(int i=1;i<=n;i++) if(!vis1[a[i]]) vis1[a[i]]=1,q.push(cnt[a[i]]);
	for(int i=1;i<=k;i++)
	{
		int x=q.top();q.pop();
		x--;q.push(x);
	}
	if(k>=q.top()) cout<<"pigstd",exit(0);
	int ans=0;
	for(int i=1;i<=n;i++) if(!vis2[a[i]]&&cnt[a[i]]+k>=q.top()) ans++,vis2[a[i]]=1;
	cout<<ans;
	return 0;
}
```

---

## 作者：CEFqwq (赞：0)

绝~~食~~世好题。

我们考虑二分：从数列中去掉 $k$ 个数后，众数出现的次数最少为多少，记为 $ans$。

然后我们分两种情况：

第一种，$ans \leq k$，那么有无限种情况。

第二种，$ans > k$，扫一遍数列，计算有多少数出现次数加上 $k$ 大于等于 $ans$。

时间复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, k, a[1000005], b[1000005], c[1000005];
bool cmp(int a, int bb) {
	if (b[a] > b[bb])return 1;
	else return 0;
}
bool check(int p){//判断去掉的数是否不大于 k
	int sum=0;
	for(register int i=0;i<n;i++){
		if(b[a[i]]>p&&c[a[i]]==0)sum+=(b[a[i]]-p);
		c[a[i]]=1;
	}
	if(sum>k)return 0;
	else return 1;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for (register int i = 0; i < n; i++) {
		cin >> a[i];
		b[a[i]]++;//桶
	}
	sort(a, a + n, cmp);
	int l=1,r=1000000,ans;
	while(l<=r){//二分答案
		memset(c,0,sizeof(c));
		int mid=(l+r)>>1;
		if(check(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	if(ans<=k){
		cout<<"pigstd";
		return 0;
	}
	int res=0;
	for(register int i=0;i<n;i++){
		if(b[a[i]]+k>=ans)res++;
		b[a[i]]=-11451419;//去重
	}
	cout<<res;
	return 0;
}
```

---

## 作者：walk_out_study (赞：0)

[$\small\textbf{题目链接}$](https://www.luogu.com.cn/problem/P9460)

### 题意

对长度为 $n$ 的序列 $a$ 进行 $k$ 次修改，每次将一个元素变成任意值。

询问有多少个数可成为众数。

$1\leq n\leq 10^6$，$0\leq k\leq n $，$1\leq a_i\leq n$。

$a_i \leq 10^6$，而不是 $10^9$，暗藏玄机。（算一个提示吧，$a_i\leq10^9$ 离散化也能做的）。

-----

一个数能否成为众数，跟该数的大小无关，与数量有关。

既然这样，用数组 $s$ 记录一下 $a_i$ 的个数，将 $s$ 排序。

设 $s$ 长度为 $len$，讨论 $s_i$ 能否成为众数：

$s_i$ 修改后有 $p=s_i+k$ 个，同时能减少比 $p$ 大的数 $k$ 次，设从 $j$ 开始，$s_j>p$。

想要每个 $s_j$ 都符合条件，就要使用 $s_j-p$ 次机会（$s_j$ 变成 $p$）。

拆出来，变成：

$$\sum_{i=j}^{n}s_i-p\times(n-j+1)$$

如果上式 $\leq k$，当前数可为众数。不满足就找更大的 $s_i$。

次数少的可为众数，更多的肯定也可为，若第 $s_i$ 为众数，就有 $len-i+1$ 个。

如没有出现过的数也满足条件，就有任意数可成为众数。

复杂度 $O(n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6+5;
long long n,k,cnt,ans;
long long a[N],t[N],s[N],ss[N];
int main() {
	cin>>n>>k;
	for(int i=1;i<=n;i++) {
		scanf("%lld",&a[i]);
		t[a[i]]++;
	}
	for(int i=1;i<=n;i++) {
		if(t[i]) s[++cnt]=t[i];
	}
	sort(s+1,s+cnt+1);
	for(int i=1;i<=cnt;i++) {
		ss[i]=ss[i-1]+s[i];
	}
	for(int i=0;i<=cnt;i++) {
		int x=upper_bound(s+1,s+cnt+1,s[i]+k)-s;
		if(k>=ss[cnt]-ss[x-1]-(s[i]+k)*(cnt-x+1)||x>cnt) {
			if(i==0) {
				cout<<"pigstd";
			}
			else	cout<<cnt-i+1;
			return 0;
		}
	}
	return 0;
}
```


---


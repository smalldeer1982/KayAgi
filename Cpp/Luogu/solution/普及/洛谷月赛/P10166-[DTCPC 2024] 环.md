# [DTCPC 2024] 环

## 题目背景

环

## 题目描述

给定无重边无自环的有向图 $G$ 和序列 $\{a_n\}$，每次可以花费 $a_i+a_j$ 的代价加上一条 $i\to j$ 的边，试花费最小代价使得可以找到 $k\geq 2$ 个不同的点 $p_1,p_2,\dots,p_k$，满足 $\forall i\in [1,k]$，都有一条 $p_i\to p_{i\bmod k+1}$ 的边。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5 
1 2
2 3
3 4
1 5
5 4 ```

### 输出

```
3```

# 题解

## 作者：Register_int (赞：8)

显然点两条边不如点一条要优。题目转化为：对于任意两点 $u,v$ 满足 $u$ 能到达 $v$，求 $\min a_u+a_v$。

若图原本就有环，那么代价必定为 $0$。否则说明图 $G$ 是一个有向无环图，可以用拓扑排序维护 dp。设 $dp_u$ 表示所有能到 $u$ 的 $v$ 的 $a_v$ 的最小值，那么答案为 $\min_{(u\to v)\in E}dp_u+a_v$。

另外还要判凭空造出来一个环的情况，这时也是造二元环最优，代价为 $2(a_u+a_v)$。处理出最小值与次小值即可。时间复杂度 $O(n+m)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 5e5 + 10;

vector<int> g[MAXN]; int d[MAXN];

int n, m, a[MAXN], dp[MAXN]; queue<int> q;

ll x, y, ans;

int main() {
	scanf("%d%d", &n, &m), x = y = 1e9;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), dp[i] = a[i];
	for (int i = 1; i <= n; i++) {
		if (a[i] <= x) y = x, x = a[i];
		else if (a[i] < y) y = a[i];
	}
	ans = x + y << 1;
	for (int i = 1, u, v; i <= m; i++) {
		scanf("%d%d", &u, &v), d[v]++;
		g[u].push_back(v);
	}
	for (int i = 1; i <= n; i++) if (!d[i]) q.push(i);
	for (int u; !q.empty(); ) {
		u = q.front(), q.pop();
		for (int v : g[u]) {
			ans = min<ll>(ans, a[v] + dp[u]), dp[v] = min(dp[v], dp[u]);
			if (!--d[v]) q.push(v);
		}
	}
	for (int i = 1; i <= n; i++) if (d[i]) ans = 0;
	printf("%lld", ans);
}
```

---

## 作者：Fujxxx (赞：6)

题意即求成环所需的最小代价。

可以分两种情况考虑。

如果连一条边代价最小则以每个无入度的点为起点跑深搜。

在搜索时记录当前路径上的最小代价值。

同时以当前边所指向的点与最小值的代价和更新答案。

如果需要连两条及以上的边则显然将代价最小的两个点正反相连即可。

两种方案的最小值即最终答案。

下面给出参考代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=1e6+10;
int n,m,a[MAXN],u,v,ans=1e16,minn;
vector<int> edge[MAXN];
bool visnode[MAXN];
void dfs(int x,int minn){
	for(register int i=0;i<edge[x].size();i++){
		ans=min(ans,minn+a[edge[x][i]]);
		dfs(edge[x][i],min(minn,a[edge[x][i]]));
	}
}
signed main(){
	std::ios::sync_with_stdio(0);
	cin>>n>>m;
	for(register int i=1;i<=n;i++) cin>>a[i];
	for(register int i=1;i<=m;i++){
		cin>>u>>v;
		edge[u].push_back(v);
		visnode[v]=1;
	}
	for(register int i=1;i<=n;i++){
		if(!visnode[i]) dfs(i,a[i]);
	}
	sort(a+1,a+1+n);
	ans=min(ans,(a[1]+a[2])*2);
	cout<<ans<<'\n';
	return 0;
}
```


---

## 作者：ran_qwq (赞：3)

如果图本来就有环就输出 $0$。

否则设加 $p$ 条边。

1. 若 $p=1$。

设加的边是 $(x,y)$。要求的就是一条从 $y$ 到 $x$ 的链，使得 $a_x+a_y$ 最小。

如果枚举 $y$ 跑 dfs 会超时。所以我们从入度为 $0$ 的点开始跑 dfs，记录 $mn_u$ 表示 $u$ 为起点可达的点 $a_u$ 的最小值。则答案为 $\min\limits_ua_u+mn_u$。

2. 若 $p\ge2$。

如果只考虑第一种情况，会被以下的数据 hack：

```
2 2
1 1 114514
1 3
2 3
```

最小代价是连 $(1,2),(2,1)$，代价为 $4$。

我们取 $a_i$ 最小的两个点 $x,y$，连 $(x,y)$ 和 $(y,x)$，代价为 $2(a_x+a_y)$。

两种情况取个最小值即可。

```cpp
int n,m,id,ans=2e9,cnt,a[N],to[M],ne[M],head[N],in[N],vis[N],ins[N],mn[N];
void add(int x,int y) {to[++id]=y,ne[id]=head[x],head[x]=id;}
void dfs(int u) {
	vis[u]=cnt,ins[u]=1;
	for(int i=head[u];i;i=ne[i]) {
		int v=to[i];
		if(!vis[v]) dfs(v);
		else if(ins[v]) puts("0"),exit(0);
		mn[u]=min(mn[u],min(mn[v],a[v]));
	}
	ins[u]=0;
	if(mn[u]<INF) ans=min(ans,a[u]+mn[u]);
}
void QwQ() {
	n=rd(),m=rd();
	for(int i=1;i<=n;i++) a[i]=rd(),mn[i]=2e9;
	for(int x,y;m--;) x=rd(),y=rd(),add(x,y),in[y]++;
	int fg=0;
	for(int i=1;i<=n;i++) if(!in[i]) cnt++,dfs(i),fg=1;
	sort(a+1,a+1+n);
	wrll(min(1ll*ans*fg,2ll*(a[1]+a[2])),"");
}
```

---

## 作者：zyn_ (赞：1)

# P10166 [DTCPC 2024] 环

题目中的 $k$ 是**让我们自己定的**！因此只需加边形成**任意长度**的环。

如果原图中有环，答案为 $0$。以下默认原图是一个 DAG。

如果没有环，设加了边 $u_i\to v_i$（$i=1,2,\dots,t$，$t\ge 1$）。显然仅当所有加的边均在环中时，方案较优。

若 $t\ge 2$，存在环中的一条链 $p_0,p_1,p_2,\dots,p_s,p_{s+1}$，且原图中存在边 $p_i\to p_{i+1}$（$i=1,2,\dots,s-1$），不存在边 $p_0\to p_1$，$p_s\to p_{s+1}$。由 $t\ge 2$ 知环中没有边 $p_{s+1}\to p_0$。

考虑不加原先的 $t$ 条边，只加 $p_{s+1}\to p_0$，此时 $p_0,p_1,p_2,\dots,p_s,p_{s+1}$ 成为环，且容易知道这样做的代价小于原做法的代价！

因此，最优的加边方案，必然满足 $t=1$，或不存在这样的 $p_0,p_1,p_2,\dots,p_s,p_{s+1}$。

### 情况一

如果 $t\gt 1$，则不存在这样的 $p_0,p_1,p_2,\dots,p_s,p_{s+1}$。而这等价于**环中的每条边均为新加的边**！

容易知道此时只有环长为 $2$ 较优，最小代价为 $\{a_i\}$ 中的最小数与次小数之和的两倍。

### 情况二

如果 $t=1$，只加一条边 $u_i\to v_i$，则原图中必存在 $v_i$ 到 $u_i$ 的路径。

考虑 DAG 上 DP。设 $dp_i$ 为在原图上由点 $i$ 出发可以走到的所有点（不包括自己）中，$a_i$ 的值最小的点的 $a_i$ 的值。

转移方程为：

$$
dp_i=\min_j\{\min\{dp_j,a_j\}\}
$$

这样，加边的代价最小为 

$$
\min_i\{dp_i+a_i\}
$$

以上两种情况，算出来的代价的较小值，就是答案。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 2000009
#define ll long long
int n,m,a,b;ll x[N],dp[N],ans,in[N],in2[N],cd[N],ok;
bool vis[N];
int head[N],nxt[N],to[N],cnt;
int q[N],l,r;
bool tp(){
	int t;
	l=1,r=0;
	for(int i=1;i<=n;++i)if(in[i]==0)q[++r]=i;
	for(int i=1;i<=n;++i){
		if(l>r)return 0;
		t=q[l++];cd[i]=t;
		for(int i=head[t];i;i=nxt[i]){
			--in[to[i]];
			if(in[to[i]]==0)q[++r]=to[i];
		}
	}return 1;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%lld",&x[i]);
	for(int i=1;i<=m;++i){
		scanf("%d%d",&a,&b);
		++cnt;
		nxt[cnt]=head[a],to[cnt]=b,head[a]=cnt;
		++in[b];++in2[b];
	}
	if(tp()){
		for(int k=n,p;k>=1;--k){
			p=cd[k];
			dp[p]=0x3f3f3f3f3f3fll;
			for(int i=head[p];i;i=nxt[i])
				dp[p]=min(dp[p],min(dp[to[i]],x[to[i]]));
		}
		ans=0x3f3f3f3f3f3fll;
		for(int i=1;i<=n;++i)ans=min(ans,x[i]+dp[i]);
		ll ff,gg,pos=0;
		ff=0x3f3f3f3f3f3fll;
		for(int i=1;i<=n;++i)if(ff>x[i])ff=x[i],pos=i;
		gg=0x3f3f3f3f3f3fll;
		for(int i=1;i<=n;++i)if(gg>x[i]&&i!=pos)gg=x[i];
		ans=min(ans,(ff+gg)*2);
		printf("%lld\n",ans);
	}else puts("0");
	return 0;
}
```

---

## 作者：Drind (赞：1)

就过了一个，丢人了。

### 题目解析

给定一个有向图，点有点权，可以进行加边操作，每次加边花费权值为两点权值和。求至少花费多少权值能构造出一个至少有两个节点的环。

首先很显然，如果图里有环我们就不用做了，所以先写个拓扑排序判环。

剩下的是一个 DAG，我们发掘一下性质。

如果这个环已经有了 $k-1$ 条边，我们只需要补充一个边就好了，否则我们要补充超过一条边。我们可以证明，如果需要补充超过一条边的环不是二元环，那么就是不优的。

证明：假设我们加的两条边权值为 $a+b$ 和 $c+d$，设 $a+b\le c+d$，那么肯定没有直接把 $a,b$ 两点成环更优。

所以我们存一个点能被到达的最小点权的点，在 DAG 上递推即可。然后再跟全图中最小的两个点成环需要的权值比较一下就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;

struct node{
	int to,nxt;
}edge[N*2]; int head[N],cnt;
void add(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
}

int n,m;
int a[N],deg[N];

int dp[N],ans;
int tot=0;

void topo(){
	queue<int>q;
	for(int i=1;i<=n;i++) if(deg[i]==0){
		q.push(i);
	}
	while(!q.empty()){
		int u=q.front(); q.pop(); tot++;
		ans=min(ans,dp[u]+a[u]);//前面有点能到达自己，就直接连过去成环。
		dp[u]=min(dp[u],a[u]);
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].to; deg[v]--; dp[v]=min(dp[v],dp[u]);
			if(deg[v]==0) q.push(v);
		}
	}
}

inline void fake_main(){
	cin>>n>>m; memset(dp,0x3f,sizeof dp);
	int mn=1e9,cmn=1e9;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]<=mn) cmn=mn,mn=a[i];
		else if(a[i]<cmn) cmn=a[i];
	}
	ans=mn+cmn+mn+cmn;//最小两点成环，如果两点之间有边不用考虑，因为会在拓扑排序里算到
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		add(u,v); deg[v]++;
	}
	topo();
	if(tot!=n) cout<<"0\n";//判环
	else cout<<ans<<"\n";
}

signed main(){
	ios::sync_with_stdio(false);
	int t; t=1;
	while(t--) fake_main();
}

```

---

## 作者：Link_Cut_Y (赞：1)

题意即为：添加一些边使得图中存在环。求加边最小代价。

首先考虑到，环的大小肯定越小越好。所以环可以分为两种类型：

- 原本就有一个环。

- 添加两条边，组成一个 $a \rightarrow b \rightarrow a$ 的环。代价即为 $a, b$ 权值和的两倍。

- 添加多条边，设加入的边为 $a \rightarrow \cdots \rightarrow b$，且存在边 $(b, a)$，则构成一个环。

对于第一种情况，直接判掉，输出 $0$ 即可。使用拓扑排序判环，复杂度 $O(n + m)$。

考虑第二种情况，直接找到点权的最大值和次大值即可。复杂度 $O(n)$。

对于第三种情况，由于现在的图是有向无环图，考虑进行拓扑排序。设 $f_u$ 表示以 $u$ 号点为结尾，前面的点权（不包括 $u$）最小值。则有转移 $f_v = \min\{f_u, w_u\}$。在 DAG 上拓扑排序进行 DP，复杂度为 $O(n + m)$。

接下来枚举 $u$，$\min\{f_u + w_u\}$ 即为答案。

故本题复杂度 $O(n + m)$。

```cpp
const int N = 5e5 + 10;
int a[N], b[N], d[N], f[N];
int ans = (int)1e18, n, m;
vector<int> E[N];
signed main() {
	scanf("%lld%lld", &n, &m);
	rep(i, 1, n) scanf("%lld", &a[i]);
	while (m -- ) {
		int u, v; scanf("%lld%lld", &u, &v);
		E[u].push_back(v); d[v] ++ ;
	} memcpy(b, a, sizeof a);
	sort(b + 1, b + n + 1); ans = 2 * (b[1] + b[2]);
	queue<int> q; rep(i, 1, n) if (!d[i]) q.push(i);
	memset(f, 0x3f, sizeof f);
	while (q.size()) {
		auto u = q.front(); q.pop();
		for (int v : E[u]) {
			d[v] -- ; f[v] = min({f[v], f[u], a[u]});
			if (!d[v]) q.push(v);
		}
	}
	rep(i, 1, n) if (d[i]) return puts("0"), 0;
	rep(i, 1, n) if (f[i]) ans = min(ans, f[i] + a[i]);
	printf("%lld\n", ans); return 0;
}
```

---

## 作者：Loser_Syx (赞：1)

题面其实是让你在加若干条边找一个长度为 $k \geq 2$ 的环。

我们想一下，如果我要加 $2$ 条边，那么我选择代价前两小的两个 $a_i$ 加两条对应的边一定是最优的，因为这两条边所花的代价一定是最小的。

由于 $a_i$ 非负所以易得加的边 $> 2$ 时一定没有上述加法更优。

那么我们只需要算加 $1$ 条边的情况，首先一种暴力的做法是枚举点 $u$，再通过 $\text{dfs}$ 求出它所能到达的点 $v$，则这样子连接 $v \rightarrow u$ 的边可以做出一个环，代价为 $a_u + a_v$，复杂度最坏 $O(n^2)$。

但是我们转过头来一想，我既然枚举了这个 $u$，那我 $v$ 一定是得是 $a_v$ 最小的吧，这样才能使得答案最小；而对于两个点 $x,y$，如果 $x$ 可以到达 $y$，则 $y$ 能到达的点一定包含在 $x$ 能到达的点里的，于是可以对于每个点记录它所能到达的 $a_v$ 最小值，将 $a_u+a_v$ 对 $ans$ 取 $\min$ 即可。

最后答案为加 $1$ 条边的最小值和加 $2$ 条边的最小值中的最小值。

注意：如果当前图存在环，则加 $1$ 条边的 $\text{dfs}$ 会陷入环内，我们可以使用拓扑排序判环，存在环的图答案一定是 $0$。

```cpp
int a[501010], fa[501010], deg[501010], Q[501010], H, T;
int ans[501010], qwq = 1e18;
vector<int> g[501010];
int dfs(int u) {
	if (ans[u]) return ans[u];
	ans[u] = 1e18;
	for (int i : g[u]) {
		smin(ans[u], dfs(i));
	}
	smin(qwq, ans[u] + a[u]);
	smin(ans[u], a[u]);
	return ans[u];
}
signed main() {
	int n, m;
	read(n, m);
	for (int i = 1; i <= n; ++i) {
		read(a[i]);
	}
	for (int i = 1; i <= m; ++i) {
		int u, v;
		read(u, v); deg[v]++;
		fa[v] = u;
		g[u].emplace_back(v);
	}
	H = 1, T = 0;
	for (int i = 1; i <= n; ++i) if (!deg[i]) Q[++T] = i;
	while (H <= T) {
		int u = Q[H++];
		for (int i : g[u]) {
			if (!--deg[i]) Q[++T] = i;
		}
	}
	for (int i = 1; i <= n; ++i) if (deg[i]) return puts("0"), 0;
	for (int i = 1; i <= n; ++i) if (fa[i] == 0) dfs(i);
	sort(a + 1, a + 1 + n); smin(qwq, a[1] + a[2] + a[1] + a[2]);
	write(qwq, '\n');
	return 0;
}
```

---

## 作者：锦依卫小生 (赞：0)

# P10166
## 题意分析
题目描述看似复杂，其实就是以最小代价使得图中存在环。
## 思路与做法
首先，如果图中已经存在环了，那么显然花费即为 $0$。（判环方法不再赘述，方法很多，本题解代码采用 tarjan 求强连通分量的方法——当强连通分量个数小于结点个数时存在环。）  
对于无环图，不难得到最优的构造方法可能有两种：在现有基础上添加一条边使得路径回指；或者选择两个结点添加两条边使它们构成一个环。  
![](https://cdn.luogu.com.cn/upload/image_hosting/fh1kgg48.png) 
对于前者，可以用类似 dp 的方式找出所有能到达它的点中花费最小值；后者直接选择价值最小的两个点即可。（详见代码。）
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX=5e5+5;
vector<int>chudu[MAX],rudu[MAX];//同时统计出边和入边
int cnt,dfn[MAX],low[MAX],n,m,tot;
long long mins[MAX],ans=2e9,a[MAX];
bool bel[MAX],vis[MAX];
stack<int> s;
void tarjan(int u){
	dfn[u]=low[u]=++tot;
	s.push(u);
	for(int i=0;i<chudu[u].size();++i){
		if(!dfn[chudu[u][i]]){
			tarjan(chudu[u][i]);
			low[u]=min(low[u],low[chudu[u][i]]);
		}
		else{
			if(!bel[chudu[u][i]])
				low[u]=min(low[u],chudu[u][i]);
		}
	}
	if(low[u]==dfn[u]){
		bel[u]=++cnt;
		while(s.top()!=u){
			bel[s.top()]=cnt;
			s.pop();
		}
		s.pop();
	}
}
void getmins(int u){
	for(int i=0;i<rudu[u].size();++i){
		int v=rudu[u][i];
		if(!vis[v]){
			vis[v]=1;
			getmins(v);
		}
		mins[u]=min(mins[u],min(mins[v],(long long)a[v]));
	} 
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		scanf("%lld",a+i);
		mins[i]=2e9;
	}
		
	for(int i=1;i<=m;++i){
		int x,y;
		scanf("%d%d",&x,&y);
		chudu[x].push_back(y);
		rudu[y].push_back(x);
	}
	for(int i=1;i<=n;++i)
		if(!dfn[i])
			tarjan(i);
	if(cnt<n){
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;++i){
		if(!vis[i]){
			vis[i]=1;
			getmins(i);
		}
		ans=min(ans,a[i]+mins[i]);
	}
	sort(a+1,a+1+n);
	cout<<min(ans,(a[1]+a[2])*2);
}

```


---

## 作者：Night_sea_64 (赞：0)

题目中就是说在一个有向图中花费两个点的权值之和可以增加一条连接这两点的边。用最少的花费使图中有点数 $>1$ 的环。

如果本来有环就直接输出 $0$。

如果 $x,y$ 中有一个能到达另一个，那么只需连接 $x,y$ 即可满足条件。因为如果要使 $x$ 能到 $y$，连接 $x\to z$ 和 $z\to y$ 显然不划算，因为会多加两遍 $a_z$。

这个可以用拓扑排序做。对于每个 $x$，用拓扑排序算出能到达 $x$ 的点的点权最小值，显然 $x$ 跟这个最小的点连边就行了。正好拓扑排序也能判断有没有环。

最后答案还要算一个点权的最小值和次小值之和的两倍。因为不连通的两个点也可以建两条边让它们出现一个环。

```cpp
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int n,m,a[500010],in[500010],minn[500010];
bool flag[500010];
vector<int>v[500010];
long long ans;
void topsort()
{
    queue<int>q;
    for(int i=1;i<=n;i++)
    {
        minn[i]=2e9;
        if(!in[i])q.push(i);
    }
    int cnt=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        cnt++,ans=min(ans,(long long)a[x]+minn[x]);
        for(auto y:v[x])
        {
            minn[y]=min(minn[y],min(minn[x],a[x]));
            if(!--in[y])q.push(y);
        }
    }
    if(cnt<n)ans=0;
}
int main()
{
    cin>>n>>m;
    int min1=2e9,min2=2e9;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        if(a[i]<=min1)min2=min1,min1=a[i];
        else if(a[i]<min2)min2=a[i];
    }
    ans=2ll*min1+2ll*min2;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        v[x].push_back(y);
        in[y]++;
    }
    topsort();
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：DerrickLo (赞：0)

先用拓扑排序判断原图是否有环，如果有，那么不用添加边。

如果没有，我们考虑两种情况：

- 原图有一条从 $i$ 到 $j$ 的路径，添加一条从 $j$ 到 $i$ 的边。

- 添加两条边，分别是从 $i$ 到 $j$ 和从 $j$ 到 $i$。

第一种可以在拓扑排序中用 `dp` 求一个点能到达的最小点权，然后把从每个点出发的情况取一个最小值。第二种就直接把 $a$ 排序，连接的必然是点权最小的两个点，取个最小值就行了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[1000005],u,v,in[1000005],vis[1000005],dp[1000005],out[1000005],ans=1e18;
queue<int>qu,qu2;
vector<int>ve[1000005],ve2[1000005];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=m;i++)cin>>u>>v,ve[u].emplace_back(v),ve2[v].emplace_back(u),in[v]++,out[u]++;
	for(int i=1;i<=n;i++)if(!in[i])qu.push(i),vis[i]=1;
	while(!qu.empty()){
		int ft=qu.front();qu.pop();
		for(int v:ve[ft]){
			if(--in[v]==0){
				qu.push(v);
				vis[v]=1;
			}
		}
	}
	for(int i=1;i<=n;i++)if(!vis[i])cout<<0,exit(0);
	memset(dp,0x3f,sizeof dp);
	for(int i=1;i<=n;i++)if(!out[i])qu2.push(i);
	while(!qu2.empty()){
		int ft=qu2.front();qu2.pop();
		for(int v:ve2[ft]){
			if(--out[v]==0){
				qu2.push(v);
			}
			dp[v]=min({dp[v],dp[ft],a[ft]});
		}
	}
	for(int i=1;i<=n;i++)ans=min(ans,dp[i]+a[i]);
	sort(a+1,a+n+1);
	ans=min(ans,2*(a[1]+a[2]));
	cout<<ans;
	return 0;
}
```

---

## 作者：言琢დ (赞：0)

考虑先找环。

如果有环的话，显然答案直接就是 $0$。

如果没有环的话，可以考虑把这个东西当成一个 DAG 做类似拓扑排序的东西。

对于拓扑排序经过的某一条树上的链，我们假设是结点 $u_1\sim u_k$，对于结点 $u_k$ 的贡献应为 $ans\overset{\min}{\leftarrow}\min\{u_1\sim u_{k-1}\}+u_k$，考虑用一个变量来跟着 dfs 的过程维护 $\min\{u_1\sim u_{k-1}\}$。

最后注意一个细节，除了直接加一条边形成环之外，可以直接加多条边，而加 $k>2$ 条边显然不优。（因为允许长度为 $2$ 的环）

如果我们不考虑已经给出的环边，根据基本的贪心思想可以发现 $2\times(a_1+a_2)$ 就是最优的加 $2$ 条边的解。

```cpp
const int N = (int) 5e5 + 5, MAX_INT = (int) 2e9 + 5;
int a[N], du[N];
std::vector <int> G[N];
int mn(int x, int y){
  return x < y ? x : y;
}
bool ins[N];
void dfs(int u){
  ins[u] = true;
  for (std::vector<int>::iterator it = G[u].begin(); it != G[u].end(); ++it) {
    int v = *it;
    if (ins[v]) { print(0), putchar('\n'); exit(0); } // 先把环判掉
    dfs(v);
  }
  ins[u] = false;
}
int ans = MAX_INT;
void go(int u, int val){
  // 从每一个起点出发开始寻找最小代价
  ans = mn(ans, a[u] + val); // 当前结点权值加上历史最小权值
  for (std::vector<int>::iterator it = G[u].begin(); it != G[u].end(); ++it) {
    int v = *it;
    go(v, mn(val, a[u])); // 求历史最小权值
  }
}
signed main(){
  int n = init(), m = init();
  for (int i = 1; i <= n; ++i)
    a[i] = init();
  for (int i = 1; i <= m; ++i) {
    int u = init(), v = init();
    G[u].push_back(v);
    ++du[v];
  }
  bool flag = true;
  for (int i = 1; i <= n; ++i)
    if (!du[i]) dfs(i), flag = false; // 从没有入度的点开始找环
  if (flag) { puts("0"); return 0; } // 如果整张图没有入度 =0 的点，说明一定有环的存在，因为 DAG 不会没有入度 =0 的点
  for (int i = 1; i <= n; ++i)
    if (!du[i]) go(i, MAX_INT);
  std::stable_sort(a+1, a+1+n);
  ans = mn(ans, a[1]+a[2] << 1);
  print(ans), putchar('\n');
}
```

---

## 作者：luanmenglei (赞：0)

注意到操作次数不超过 $2$。

因为考虑你选择最小的两个 $a_i,a_j$ 进行两次操作就一定能构成一个环并且代价一定在所有两次操作中最小。

所以我们只需要额外考虑操作次数为 $1$ 的情况和本身就有环的情况。

考虑对于每个 $i$ 钦定他作为一次操作的被连向点那么另一个操作的 $j$ 一定是他能到达的点中的 $a_j$ 最小的点。

于是我们直接用拓扑排序维护这个东西就好了。

时间复杂度 $\mathcal{O}(n + m)$。

参考代码：

```cpp
const int N = 5e5 + 10;
const i64 inf = 2e9;
int n, m, a[N], f[N], deg[N];
bool vis[N];
vector<int> G[N];
queue<int> q;

void solve() {
	cin >> n >> m;
	for (int i = 1; i <= n; i ++)
		cin >> a[i];
	for (int i = 1, x, y; i <= m; i ++) {
		cin >> x >> y;
		G[y].push_back(x);
		deg[x] += 1;
	}

	int mn = inf, semn = inf;
	for (int i = 1; i <= n; i ++) {
		if (a[i] <= mn) {
			semn = mn, mn = a[i];
		} else if (a[i] <= semn) {
			semn = a[i];
		}
	}
	// mn = inf, semn = inf;

	i64 ans = 2LL * (semn + mn);

	for (int i = 1; i <= n; i ++)
		f[i] = inf;

	for (int i = 1; i <= n; i ++) if (deg[i] == 0) {
		q.push(i);
	}

	while (!q.empty()) {
		int x = q.front(); q.pop();
		vis[x] = true;
		chkmin(ans, 0LL + a[x] + f[x]);
		chkmin(f[x], a[x]);
		for (int y : G[x]) {
			chkmin(f[y], f[x]);
			if ((-- deg[y]) == 0)
				q.push(y);
		}
	}

	for (int i = 1; i <= n; i ++)
		if (!vis[i])
			ans = 0;

	cout << ans << "\n";
}
```

---


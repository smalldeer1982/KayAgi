# 「MYOI-R3」消消乐

## 题目背景

**upd 2024/5/12 18:14：增加了两组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**

**upd 2024/5/12 21:27：增加了一组 Hack 数据，位于 Subtask 1，分值为 $0$ 分。**

## 题目描述

给定一个长度为 $n$ 的数列 $a$。

定义一次操作为选择三个整数 $x,y,z\in[1,n]$，满足 $\gcd(a_x,a_y)=a_z$ 且 $x,y,z$ 两两不同，接着消除 $a_z$（即之后的操作中不能再选择 $a_z$ 了）。

问经过若干次操作后可否消除数列 $a_1\sim a_n$ 中的 $n-2$ 个数？

## 说明/提示

### 样例解释：

- 对于第一组数据，可以通过 $(2,3)$ 消除 $1$。
- 对于第二组数据，可以证明无解。

### 数据范围：

本题共有 $20$ 个测试点，每个测试点的分值均为 $5$ 分。

对于 $100\%$ 的数据，$1\le T\le 10^5$，$2\leq n \leq 10^6$，$2 \le \sum n\le 10^6$，$1\le a_i\le 10^9$。

## 样例 #1

### 输入

```
2
3
1 2 3
3
1 2 4```

### 输出

```
Yes
No```

# 题解

## 作者：Matrix__ (赞：13)

[传送门](https://www.luogu.com.cn/problem/P10443)

这个其实很水的思维题，~~但我赛时却想了 50 分钟~~。

将数组 $x$ 从小到大排序。

很显然，根据 $\gcd(a,b) \le \min(a,b)$，就可以发现 $x_n$ 和 $x_{n-1}$ 一定不会被删去。那么数组 $x$ 想进行 $x-2$ 此操作就必须将 $x_1 \cdots x_{n-2}$ 都删去。

继续，我们现在想把 $x_1 \cdots x_{n-2}$ 都删去。

那么此时，$x_{n-2}$ 和 $x_{n-3}$ 就是最大的了，最后肯定会剩下他俩，那么他俩想被约去，就必须是 $\gcd(x_n,x_{n-1})$。同理可得：那前面的数想被约掉，就必须得是 $\gcd(x_{n-2},x_{n-3})=\gcd(\gcd(x_n,x_{n-1}),\gcd(x_n,x_{n-1}))=\gcd(x_n,x_{n-1})$。

那么可得：这个数组 $x$ 能进行 $n-2$ 此操作，当且仅当任意一个 $i$（$1 \le i \le n-2$）皆满足 $x_i=\gcd(x_n,x_{n-1})$。

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;

typedef long long ll;
typedef double db;
typedef __int128 III;
const db eqs=1e-6;
const int inf=1e9;
void cmax(int &a,int b){a=max(a,b);}
void cmin(int &a,int b){a=min(a,b);}
bool db_eq(db a,db b){return fabs(a-b)<eqs;}

const int MAXN=1000000+5;
int T,n,a[MAXN];

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>T;
	while(T--)
	{
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		sort(a+1,a+n+1);
		if(n==2) 
		{
			cout<<"Yes\n";
			continue;
		}
		bool flag=1;
		for(int i=1;i<=n-2;i++)
		{
			if(a[i]!=__gcd(a[n],a[n-1]))
			{
				cout<<"No\n";
				flag=0;
				break;
			}
		}
		if(flag) cout<<"Yes\n";
	}	
	return 0;
}

```

---

## 作者：SafariMo (赞：10)

考虑枚举剩下的两个数 $A,B$，原问题等价为 $w_1=A,w_2=B$，每次若 $\gcd(w_i,w_j)=a_k(i\ne j\ne k)$，则将 $a_k$ 加入 $w$。

事实上，我们发现后加入的数一定是原数字的因子，所以一定不优。

又因为 $\gcd(a_i,a_j)\le \min(a_i,a_j)$ 则 $A,B$ 一定是前两大值。

代码很好写。

---

## 作者：FarmerDrone (赞：4)

因为一个数的因数没有大于它本身的，所以若满足条件剩下的两个数必然是最大的。第三大的也必然是最大的两个的最大公因数。  
然后，对于第四大的，我们发现已确定的三个数不论取哪两个，最大公因数都会等于第三大的数，第四大的数也就等于第三大的数。下面全同理了。  
代码比官方的还好写。

---

## 作者：SakurajiamaMai (赞：2)

直接考虑最后是哪两个数字，肯定是最大的两个会存活到最后，因为任意两个数的最大公因数不可能比这两个数大。

那么第三大的呢？一定会被最大的那两个消去，不然不可能存在能消去第三大的最大公因数，依次类推即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10,mod=1e9+7;
void solve(){
    int n; cin>>n;
    vector<int>a(n+1);
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a.begin(),a.end());
    for(int i=n;i>=3;i--){
        if(__gcd(a[i],a[i-1])==a[i-2]) continue;
        else return cout<<"No"<<'\n',void();
    }
    cout<<"Yes"<<'\n';
}
signed main(){
    std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int t;cin>>t;while(t--)solve();
}

```

---

## 作者：__Octhyccc__ (赞：2)

结论题，诈骗。

我们先按照升序给数组 $a$ 排一下序。

假设答案为可以。

那么，如果在进行尽可能多轮操作之后，剩下的一定是 $a_{n-1},a_{n}$，并且 $\gcd(a_{n-1},a_n)=a_{n-2}$。

那接下来，我们引入 $a_{n-3}$，考虑它是上面三者哪三个的最大公因数，明显，$3$ 种情况，分类讨论。

- 是由 $a_n,a_{n-1}$ 得来的：

说明 $\gcd(a_n,a_{n-1})=a_{n-3}$，又有上文，$\gcd(a_n,a_{n-1})=a_{n-2}$，所以在这种情况下，$a_{n-2}=a_{n-3}$。

- 是由 $a_n,a_{n-2}$ 得来的：

说明 $\gcd(a_n,a_{n-2})=a_{n-3}$，又有上文，$\gcd(a_n,a_{n-1})=a_{n-2}$，我们可以知道 $a_n$ 可以整除 $a_{n-2}$，所以 $\gcd(a_n,a_{n-2})=a_{n-3}$，所以在这种情况下，$a_{n-2}=a_{n-3}$。

还有一种情况类似，这里就不详细写了，结论依旧。

我们可以把它推广，最终结论：

如果一个升序序列被判定为可以，则 $\gcd(a_n,a_{n-1})=a_i$，当 $1\le i< n-1$ ，并为整数时。

证毕，代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000000];
bool b=0;
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=0;i<n;i++)scanf("%d",&a[i]);
		sort(a,a+n);
		int ex=__gcd(a[n-1],a[n-2]);
		for(int i=0;i<n-2;i++){
			if(a[i]!=ex){
				b=1;
				break;
			}
		}
		!b?puts("Yes"):puts("No");
		b=0;
	}
	return 0;
}
```

---

## 作者：Mortidesperatslav (赞：2)

我上线时比赛开始了两个小时了，扫了眼题目，秒了。

因为 $\gcd(a,b)$ 肯定比 $a$ 和 $b$ 都要小，所以如果剩下的两个数不是最大的两个数，我们会发现最大和次大中没有选择剩下的数根本没法消掉。

所以排个序，扫一遍判断就行了。

---

## 作者：wanglexi (赞：1)

[题目。](https://www.luogu.com.cn/problem/P10443)

### 题意简述

给出 $n$ 和 $n$ 个正整数组成的序列 $a$。

定义一次操作为：若序列中两不同数 $x,y$ 的 $\gcd$ 是此序列中除前两个数的数 $z$，删除 $x$。

问最后能否经过 $n-2$ 次操作剩下 $2$ 个数。

$t$ 次询问。
### 思路

考虑 $\gcd(p,q)\le p,q$，所以最后剩下的两数一定是 $a$ 中最大的两个数。设它们为 $x$ 和 $y$。

最后消掉的那个数一定是 $z=\gcd(x,y)$。

倒数第二个消掉的数是谁呢？

有三种可能，$\gcd(x,y),\gcd(x,z),\gcd(y,z)$，但是它们都是 $z$！

所以，当且仅当 $a$ 排序后，前 $n-2$ 项都是 $\gcd(a_{n-1},a_n)$，序列可以满足题目要求。

### 代码

照着结论写就行。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
map<int,int>mp;
int t,n,a[1000005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		sort(a+1,a+n+1);
		bool flag=1;int gcd=__gcd(a[n-1],a[n]);
		for(int i=1;i<=n-2;i++)if(a[i]!=gcd)flag=0;
		cout<<(flag==1?"Yes\n":"No\n");
	}
	return 0;
}
```

---

## 作者：CaiZi (赞：1)

## 「MYOI-R3」消消乐 题解
**[题目链接](https://www.luogu.com.cn/problem/P10443)**
### 题目分析
首先注意到 $\gcd(a_i,a_j)\le\min(a_i,a_j)$，因此如果剩下的这两个数不是最大的两个数，则必然还有其他数字无法消除。故这两个数一定是最大的数和次大的数，记为 $a_p$ 和 $a_q$。

因为消除到最后仅剩下某两个数，所以这两个数必须都等于 $\gcd(a_p,a_q)$，才可以消除到仅剩下 $a_p$ 和 $a_q$。

而又因为这两个数都等于 $\gcd(a_p,a_q)$，所以被这两个数消除的数也等于 $\gcd(a_p,a_q)$。以此类推，可以发现仅当 $\forall i\in[1,n]$ 且 $i\ne p$ 且 $i\ne q$ 时，有 $a_i=\gcd(a_p,a_q)$ 才可以消除成功。
### 代码展示
时间复杂度 $O(\sum n)$，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[1000001],x,b,c,p,q;
bool f;
signed main(){
	cin.tie(nullptr)->sync_with_stdio(false);
	cin>>t;
	while(t--){
		b=c=0;
		f=true;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(b<a[i]){
				b=a[i];
				p=i;
			}
		}
		for(int i=1;i<=n;i++){
			if(c<a[i]&&i!=p){
				c=a[i];
				q=i;
			}
		}
		x=gcd(a[p],a[q]);
		for(int i=1;i<=n;i++){
			if(a[i]!=x&&i!=p&&i!=q){
				f=false;
				break;
			}
		}
		if(f){
			cout<<"Yes\n";
		}
		else{
			cout<<"No\n";
		}
	}
	return 0;
}
```
**[提交记录](https://www.luogu.com.cn/record/158859940)**

---

## 作者：Melo_qwq (赞：1)

又没能参加今天基础赛，感觉自己能 AK。

# 题目大意

在一个数列中，每次选取两个数删去它们两个的最大公约数，问最后能不能只剩下两个数。

# 题目实现

暴力枚举剩哪两个本人口胡了一下是 $O(n^3)$ 的，所以直接想正解。

正难则反，我们假设原先数列里只有两个数，每次加入其中两个数的最大公约数，看看能不能凑成原来的数列。

不难发现这两个数一定是前两大的，因为 $\gcd(a,b)\le \min(a,b)$，如果这两个数不是前两大，那么**一定会有一个更大的数表示不出来。**

那么我们的解法就进化到了 $O(n)$ 级别，还不够。

我们再手推结论，发现我们构造出的前三个数一定是：

- 原数列中的最大值和次大值（设为 $a$ 和 $b$）。

- 最大值和次大值的最大公约数（设为 $c$）。

那么我们接下来无论怎么增加数字，**增加的这个数一定是 $c$**。

为什么？

$$
\gcd(a,\gcd(a,b))=\gcd(a,b)
$$

用人话说就是 $c$ 是 $a$ 和 $b$ 的因数，所以 $\gcd(a,c)=\gcd(b,c)=\gcd(a,b)=c$。

得出结论，如果一个数列是可行的，这个数列一定形如：

$$
a,b,c,c,c,c,c\cdots
$$

也就是说这个数列中只有三个不同的值。

所以我们只需要给原数列排个序求最大次大值。

之后想到 set 自带去重，所以可以把原数列中的所有数插入，如果只剩下 $3$ 个，可能可行；不然肯定不行。

最后一步，判断三个数中一个是否是其他两个的平均数即可。

复杂度 $O(\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
#define rep(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 1e6 + 7 ;
int t ,n ,a[N] ;
template <typename T> inline void read (T &x) {
	x = 0 ;
	char ch = getchar () ;
	while (! isdigit (ch)) {
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch xor 48) ;
		ch = getchar () ; 
	}
}
int main () {
	read (t) ;
	do {
		read (n) ;
		rep (i ,1 ,n ,1) {
			read (a[i]) ;
		}
		sort (a + 1 ,a + n + 1) ;
		set <int> se ;
		rep (i ,1 ,n ,1) {
			se.insert (a[i]) ;
		}
		if (se.size () > 3) {
			puts ("No") ;
			goto her ;
		}
		if (__gcd (a[n] ,a[n - 1]) == a[1]) { // a[n] 和 a[n - 1] 分别是最大、次大值，a[1] 是第三个值，其实取 a[1~n - 2] 都是可行的
			puts ("Yes") ;
			goto her ;
		}
		puts ("No") ;
		her : ;
	} while (t -- != 1) ;
	return 0 ;
}
//kafka & かみや
```

###### 你是否承认卡芙卡和狼谷的美貌举世无双？

---

## 作者：MicroSun (赞：0)

由于每一个数都一定是被数列 $a$ 中的两个数消除的，而正序观察整个操作过程没有什么特殊的性质，所以考虑倒序解决，问题等价为：初始数列为最后剩下的两个数构成的数列，每次操作从目前的数列中选择两个数，将他们的最大公约数加入数列。

那么最后剩下的两个数是哪两个呢？观察每一次操作，被消除的数 $a_z$ 由于是消除它的数 $a_x$ 和 $a_y$ 的最大公约数，一定满足 $a_z\le a_x$ 且 $a_z\le a_y$。那么容易证得，最后剩下的两个数一定是所有数中最大的两个。

明显顺序不会影响操作结果。将所有数排序，最后剩下的两个数即为 $a_{n-1},a_{n}$。可以发现在最后一次消除中，被消除的 $a_l=\gcd(a_{n-1},a_{n})$，是 $a_{n-1}$ 和 $a_n$ 的约数。那么，我们会发现：不论用这三个数如何组合，制造出的数都与 $a_l$ 相等。

所以，我们只能组成除了最大的两个数外，每一个数都等于最大的两个数的最大公约数的数列。

代码很好写。

Code:

```cpp
// Problem: T429246 「MYOI-R3」消消乐
// LuoguUID: 514700 
// LuoguUserName: MicroSun
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define pb push_back
#define fst first
#define scd second
#define rep(i,s,e) for(int i=s;i<=e;i++)
#define dep(i,s,e) for(int i=s;i>=e;i--)

using ll=long long;
using pii=pair<int,int>;
using pll=pair<ll,ll>;

const int maxn=1e6+10;
const ll MX=1e8;

ll a[maxn],cnt;
void solve(){
	int n;
	cin>>n;
	rep(i,1,n) cin>>a[i];
	sort(a+1,a+1+n);
    ll ttt=__gcd(a[n-1],a[n]);
	rep(i,1,n-2){
		if(a[i]!=ttt){
            cout<<"No\n";
            return;
        }
	}
	cout<<"Yes\n";
					
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int t=1;
	cin>>t;
	while(t--) solve();
    return 0;
}
```

---

## 作者：zhengpie (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10443)

### 1.思路

首先，我们证明一个**引理**。

假设有两个数 $x,y$，那么 $\gcd(x,y) \leq \min(i,j)$。（因为一个数的最大因数是它本身）

有了这个引理，我们就知道 $n$ 个数中（这些数从小到大排，下文默认从小到大排），进行 $n - 2$ 次操作后（如果可以的话），剩下的两个数是 $a_{n-1},a_n$。（其他小的都被消掉了）

现在，我们假设这个数列进行 $n - 2$ 次操作后就只剩两个数的**充分条件**是 
$$\forall i \in [3,n],\gcd(a_{i - 1},a_i) = a_{i - 2}$$
那么最后就会只剩下 $a_{n - 1},a_n$，符合我们一开始得出的结论。

考虑使用[数学归纳法](https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/5155524?fr=ge_ala)进行证明。

一方面，若 $n = 3$，那么只需 $\gcd(a_2,a_3) = a_1$ 即可，假设成立。

另一方面，我们不妨假设当 $n = k$ 时假设成立，那么由归纳假设知，进行 $k - 2$ 次操作后，只剩下 $a_{k-1},a_k$ 两个数，那么只需 $\gcd(a_{k-1},a_k) = a_{k+1}$，就可以消去 $a_{k-1}$，于是假设也成立。

于是，由**数学归纳法**知，对于**任意**的 $n$，都有这个数列进行 $n - 2$ 次操作后就只剩两个数的充分条件是 
$$\forall i \in [3,n],\gcd(a_{i - 1},a_i) = a_{i - 2}$$

于是就容易写出代码。（不会写 $\gcd$ 的同学请点[这里](https://oi-wiki.org/math/number-theory/gcd/)）

### 2.代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[1000010],t,n;
int gcd(int x,int y)
{
    if(y == 0) return x;
    return gcd(y,x % y);
}
signed main()
{
    ios::sync_with_stdio(0);
	cin>>t;
	while(t--)
	{
		memset(a,0,sizeof a);
		cin>>n;
		for(int i = 1;i <= n;i++) cin>>a[i];
		sort(a + 1,a + n + 1);
		int flag = 1;
		for(int i = 3;i <= n;i++)
			if(gcd(a[i - 1],a[i]) != a[i - 2])
			{
				flag = 0;
				break;//注意要break剪枝，不然会超时一个点
			}
		if(flag) puts("Yes");
		else puts("No");
	}
	return 0;
}
```

---

## 作者：maokaiyu (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10443?contestId=127474)
## 思路
可以发现，对于任意一个 $a_i$ 能消除它的数必然大于等于它。所以最后剩下的两个数就一定是前二大的数。这两个数所消除的数必然是第三大数。以此类推，所以 $a_{i}$ 和 $a_{i+1}$ 只能消掉 $a_{i-1}$。
## 做法
将 $a$ 数组排好序，依次枚举 $i$ 判断 $a_{i-2}$ 是不是 $a_{i}$ 和 $a_{i-1}$ 的最大公因数。注意边界条件。
## AC code
```cpp
#include<bits/stdc++.h>
#define pb push_back
#define SZ(x) (int)x.size()
#define fi first
#define se second
#define all(x) x.begin(),x.end()
#define be(x) x.begin()
#define en(x) x.end()
using namespace std;
typedef long long LL;
typedef int I;
I t,n,a[1000010]; 
I main(){
	scanf("%d",&t);
	for(;t--;){
		scanf("%d",&n);
		for(I i = 1;i <= n;i++){
			scanf("%d",&a[i]);
		}
		sort(a + 1,a + n + 1);
		bool flag = false;
		for(I i = n;i > 2;i--){
			if(__gcd(a[i],a[i - 1]) != a[i - 2]){
				printf("No\n");
				flag = true;
				break;
			}
		}
		if(!flag){
			printf("Yes\n");
			continue;
		}
	}
	return 0;
}
```

---

## 作者：Ravener (赞：0)

先看题：

>给定 $x \ne y \ne z$ 和数列 $a$，把满足 $\gcd(a_x,a_y)=a_z$ 中的 $a_z$ 消去，直到无法进行，其中 $x,y,z \in [1,n]$，$n$ 为数列的长度。

暴力想都不要想，拿不了满分。  
~~（当然如果在考场上拿部分分应该可以）~~

------------

因为给定的是数列，所以先进行升序排列。  
以下的数列 $a$ 已进行升序排列。  
分析一遍题意可知，如果能消除 $a$ 的 $n-2$ 个数，则数列 $a$ 满足 $\gcd (a_n,a_{n-1})=a_i$，其中 $i \in [1,n-2]$。

分析：  
已知 $\gcd(a_x,a_y)=a_z$ 且 $a_z$ 需要被消去，  
所以剩下的 $a_x$ 和 $a_y$ 都比 $a_z$ 要大。  
假设数列 $a$ 可以消去 $n-2$ 次，  
那么经过 $n-2$ 次消去后，剩下的两个数必定是 $a_n,a_{n-1}$，即数列 $a$ 的最大值与次大值，而消去的数全是 $a_n$ 和 $a_{n-1}$ 的因子。  
因此，仅需判断这个命题是否成立即可：
$$\displaystyle \forall i \in [1,n-2], \gcd(a_n,a_{n-1})=a_i.$$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005];
main()
{
	int t;
	cin>>t;
	while(t--)
	{
		memset(a,0,sizeof(a));
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		sort(a+1,a+1+n);
		bool ck=1;
		for(int i=1;i<=n-2;i++)
		{
			if(__gcd(a[n-1],a[n])!=a[i])
			{
				ck=0;
				break;
			}
		}
		ck?cout<<"Yes\n":cout<<"No\n";
	}
}
```

时间复杂度 $O(Tn)$，可以过。  
[AC 记录](https://www.luogu.com.cn/record/158910100)。  
（tj 仅供参考，如有纰漏请 at 我并指正）

---

## 作者：carbon_monoxide (赞：0)

硬生生折磨了我两小时，蒻啊。

## 题目描述

每次选择三个整数 $x,y,z\in[1,n]$，满足 $\gcd(a_x,a_y)=a_z$ 且 $x,y,z$ 两两不同，接着消除 $a_z$，问经过若干次操作后可否消除数列 $a_1\sim a_n$ 中的 $n-2$ 个数。

## 做法

注意到每次消除的数是 $\gcd(a_x,a_y)$，那么活下来的数一定是两个最大的数。换言之，两个最大的数一定不会被消除。那么其它数必然是两个最大数的最大公因数，否则不可能被消除。那么代码也就出来了。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[1000010];
int main(){
    cin>>t;
    while(t--){
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i];
        sort(a+1,a+1+n);
        int f=0,x=__gcd(a[n-1],a[n]);
        for(int i=1;i<=n-2;i++){
            if(a[i]!=x){
                cout<<"No\n";
                f=1;
                break;
            }
        }
        if(!f) cout<<"Yes\n";
    }
    return 0;
}
```

---

## 作者：qw1234321 (赞：0)

考虑数列第 $1$ 大值 $a_i$，第 $2$ 大值 $a_j$，第 $3$ 大值 $a_k$，第 $4$ 大值 $a_l$，第 $5$ 大值 $a_p$。

不妨设经过若干次操作后可消除数列中的 $n-2$ 个数。

$\because \gcd(x,y) \leq x$ 且 $\gcd(x,y) \leq y$。

$\therefore a_k$ 一定是由 $\gcd(a_i,a_j)$ 消除。

$\therefore a_k = \gcd(a_i,a_j)$。

同理，分类讨论 $a_l$ 的值：

- $a_l = \gcd(a_i,a_j)$

即 $a_l = a_k$。

- $a_l = \gcd(a_i,a_k)$

$\because \gcd(x,\gcd(x,y)) = \gcd(x,y)$。

所以 $a_l = \gcd(a_i,\gcd(a_i,a_j)) = \gcd(a_i,a_j) = a_k$。

- $a_l = \gcd(a_j,a_k)$

同理可得，$a_l = a_k$。

由于 $a_l$ 等价于 $a_k$，故讨论数列中第 $5$ 大的值时，省略 $a_l$ 即可。

$\therefore a_p = a_k$。

故将原序列从小到大排序后，若可以被消除掉 $n-2$ 个数，则有如下结论：

$$a_1 = a_2 = a_3 = \dots = a_{n-3} = a_{n-2} = \gcd(a_{n-1},a_n)$$

不满足则输出 `No` 即可。

代码过于简单不给了。

---

## 作者：_O_v_O_ (赞：0)

先放两个很显然的结论：

- 假如有两个正整数 $a,b$，那么 $\gcd(a,b)\le\min(a,b)$。
- 假如有两个正整数 $a,b$，设 $g=\gcd(a,b)$，那么 $a\bmod g=b\bmod g=0$。

根据性质 $1$，题目中最后剩下的 $2$ 个数一定为最大与次大值，我们记为 $a1,a2$。

其次我们转化一下题意，把消变成加，那么变成了开局有 $a1,a2$，每次可选两个数加入他们的 $\gcd$，能否变成 $a$。

那么，我们根据性质 $2$ 可得除 $a1,a2$ 所有数必须为 $\gcd(a1,a2)$。

直接判断除 $a1,a2$ 所有数是否 $=\gcd(a1,a2)$ 即可。

---

## 作者：unordered_yao (赞：0)

## 思路

1. 首先，我们可以发现，任意两个数的最大公因数，一定是小于等于这两个数的最小值，即 $\gcd(a,b)\leq \min(a,b)$。

2. 通过以上性质，我们只需要将输入的序列 $a$ 排序，判断前 $n-2$ 个数是否等于 $\gcd(a_n,a_{n-1})$ 即可。若有一个及以上个数字不与最大的两个数的最大公因数相等，那么就不可能剩余 $2$ 个数。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template <typename T>
inline void read(T &x){
    x = 0;char ch = getchar();bool f = 0;
    while(ch < '0' || ch > '9'){if(ch == '-')f = 1;ch = getchar();}
    while(ch >= '0' && ch <= '9')x = (x<<1) + (x<<3) + (ch^48),ch=getchar();
    if(f)x = -x;                                       
}
template <typename T,typename ...Args>
inline void read(T &tmp,Args &...tmps){read(tmp);read(tmps...);}
template<typename type>
inline void write(type x,short mode=0)//0为空格，1为换行，2啥也不干
{
    x<0?x=-x,putchar('-'):0;static short Stack[50],top(0);
    do Stack[++top]=x%10,x/=10; while(x);
    while(top) putchar(Stack[top--]|48);
    if(mode == 2) return;
    mode?putchar('\n'):putchar(' ');
}
int T;
bool solve(){
    int n;
    read(n);
    vector<int> a(n);
    for(int i=0;i<n;i++) read(a[i]);
    sort(a.begin(),a.end());
    int gc = __gcd(a[n-1],a[n-2]);
    for(int i=0;i<n-2;i++){
        if(a[i]!=gc) return 0;
    }
    return 1;
}
int main(){
    read(T);
    while(T--){
        if(solve()) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

---

## 作者：ZettaByte (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10443)

### 题意

给定数列 $a$ 和项数 $n$，若存在 $1\le x,y,z\le n$（$x$、$y$、$z$ 互不相等）使得 $\gcd(a_x,a_y)=a_z$，则可以将 $a_z$ 消除。问能否将数列 $a$ 中的 $n-2$ 个数消除（即只剩下 $2$ 个数）。

### 解法

首先容易得出我们只能消除最小的 $n-2$ 个数，因此先将 $a$ 从小到大排序。

接下来，我们发现，$a_{n-2}$ 只能是 $\gcd(a_n,a_{n-1})$。那 $a_{n-3}$ 是什么呢？它可能是 $\gcd(a_n,a_{n-1})$、$\gcd(a_n,a_{n-2})$ 或 $\gcd(a_{n-1},a_{n-2})$。容易得出，这三者都等于 $a_{n-2}$，从而 $a_{n-3}=a_{n-2}$。

同理，我们就能推出 $a_1=a_2=\dots =a_{n-2}$。

因此，只有当 $\gcd(a_n,a_{n-1})=a_{n-2}$ 且 $a_1=a_2=\dots =a_{n-2}$ 时，可以消除 $n-2$ 个数。

注：操作时肯定是从小到大消除，但倒序推理完全没有问题。

#### AC CODE：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000010];

int main()
{
	int T; scanf("%d", &T);
	while (T--)
	{
		int n, flag = 1; scanf("%d", &n);
		for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
		sort(a + 1, a + n + 1);
		if (__gcd(a[n], a[n - 1]) != a[n - 2]) { puts("No"); continue; }
		for (int i = 1; i <= n - 3; i++)
			if (a[i] != a[n - 2]) flag = 0;
		puts(flag ? "Yes" : "No");
	}
	return 0;
}
```

---


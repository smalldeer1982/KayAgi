# 物理实验 (hard)

## 题目背景

莲子为了完善她的论文，决定研究一些物体的物理性质。由于工作实在是太多，她邀请你帮忙完成其中的一个小实验。不过，这次的略微困难一些。

## 题目描述

**这是该题的困难版本，两个版本之间的区别在于小球需要满足的条件不同。该题的满分为 50 分。**

莲子有一个初始在数轴 $0$ 点并向数轴正方向移动的小球。莲子在数轴的 $1$ 到 $n$ 这 $n$ 个点上设置了装置，当小球经过点 $i$ 时，她可以花费 $a_i$ 的代价让其改变移动方向（从数轴正方向切换为负方向，或者相反）。

莲子有 $m$ 个需要满足的条件，第 $i$ 个条件形如“小球需要从点 $x_i$ 移动到点 $y_i$ 至少 $k_i$ 次”，**其中** $x_i$ **大于** $y_i$。更详细的说，该条件即要求小球的移动路径形如 $\ldots\to x_i\to\ldots\to y_i\to\ldots\to x_i\to\ldots\to y_i\to\ldots$，其中从 $x_i$ 移动到 $y_i$ 的过程重复至少 $k_i$ 次。

莲子想要知道她至少要花费多少代价才能满足所有条件。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/x2aotk1i.png)

上图画出了样例 1 和样例 2 的具体构造方案，可供参考。

#### 样例 \#1

莲子让小球在经过点 $2$ 时反转方向，然后让其经过点 $1$ 时再反转方向。重复上述操作两次，最后再在点 $2$ 反转方向恰好能满足所有条件。总花费代价为 $8$。

注意到该样例符合特殊性质 $\mathbf{A}$。
#### 样例 \#2

莲子让小球依次在经过点 $3$、点 $2$、点 $3$ 时反转方向。总花费代价为 $8$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n,m\le } & \bm{a_i\le} & \bm{x_i,y_i\le} & \bm{k_i\le} & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 100 & 10 & 10 & - &-\cr\hline
2 & 5 & 2\times 10^5 & 10^8 & 2\times 10^5 & 10^8 & \mathbf{A}&- \cr\hline
3 & 15 & 10^3 & 10^8 & 10^3 & 10^5 & -&1 \cr\hline
4 & 20 & 2\times 10^5 & 10^8 & 2\times 10^5 & 10^8 & -&1,2,3  \cr\hline
\end{array}
$$

特殊性质 $\mathbf{A}$：所有的 $k_i$ 均相等。

对于所有数据满足：$1\le n,m\le 2\times 10^5$，$1\le a_i\le 10^8$，$1\le y_i< x_i \le n\le 2\times 10^5$，$1\le k_i\le 10^8$。

## 样例 #1

### 输入

```
3 1
1 2 3
2 1 3```

### 输出

```
8```

## 样例 #2

### 输入

```
5 3
5 2 3 4 5
2 1 1
3 2 2
3 1 1```

### 输出

```
8```

# 题解

## 作者：yywlp (赞：10)

简单题，有上一问的基础非常容易。

这里每个要条件需要达成最少 $k_i$ 次，似乎不能直接简单往回走了，这里还需要回头再回头，有点懵。

但是参考一下上一题：走到最后再往回。那这个是不是每次都走到最前面再往后呢？没错！我们开个结构体将条件按 $y_i$ 排序，对于第一个条件会发现，这个条件需要在 $\le y_i$ 的某个位置转 $k_i-1$ 次，那我肯定每次都走到最前面再转更好，反正这 $k_i-1$ 次无论如何都是要转的，如果在后面提前转了肯定会亏。而对于 $x_i$ 最大的条件就如同上一题，肯定是走到最后再一起转，所以我们再开个结构体把条件按 $x_i$ 排序。

前一个从前往后扫维护最前面的 $y_i$，后一个从后往前扫维护最后面的 $x_i$，然后再记 $k$ 表示重复了几次，满足当前条件的 $k_i$ 就往后或往前调扫描线，每次看当前应该还要重复几次，乘上前缀最小值 $+$ 后缀最小值就行。

记得开 `long long`，因为这个 WA 了好几次QAQ。

时间复杂度在排序 $\mathcal O(m\log m+n)$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int M=2e5+10;
int n,m;
int a[M],mnh[M],mnq[M];
struct NODE{
	int x,y,k,id;
}n1[M],n2[M];
bool cmpx(const NODE&A,const NODE&B){
	if(A.x==B.x)return A.y<B.y;
	return A.x<B.x;
}
bool cmpy(const NODE&A,const NODE&B){
	if(A.y==B.y)return A.k>B.k;
	return A.y<B.y;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)scanf("%d%d%d",&n1[i].x,&n1[i].y,&n1[i].k),n2[i]=n1[i],n1[i].id=n2[i].id=i;
	sort(n1+1,n1+m+1,cmpx);
	sort(n2+1,n2+m+1,cmpy);
	mnh[n]=a[n];
	for(int i=n-1;i>=1;i--)mnh[i]=min(mnh[i+1],a[i]);
	mnq[1]=a[1];
	for(int i=2;i<=n;i++)mnq[i]=min(mnq[i-1],a[i]);
	int l=1,r=m,k=0;
	LL ans=0;
	while(r>=1){
		int nr=n1[r].k-k,nl=n2[l].k-k;
		int nk=min(nl,nr);
        ans+=1ll*nk*mnh[n1[r].x]+1ll*nk*mnq[n2[l].y];
		k+=nk;
		while(n1[r].k<=k&&r>=1)r--;
		while(n2[l].k<=k&&l<=m)l++;
	}
	ans-=mnq[n2[1].y];
	cout<<ans<<endl;
	return 0;
}

---

## 作者：Hirro (赞：7)

问题等效成至少在 $x$ 右边即 $i\ge x$ 的范围内取 $k$ 次 $a_i$ 和在 $y$ 左边即 $i\le y$ 的范围内取 $k-1$ 次 $a_i$。

以 $i\ge x$ 举例，用 $t_i$ 表示至少在 $i$ 及其右边取 $t_i$ 次 $a_i$。所以 $t[x_i]\gets max(t[x_i], k[i])$。

我们希望取的 $a_i$ 之和最小，考虑从右往左取，右边有更小的 $a_i$ 我们就取最小的。设 $now\gets\min(now, a_i)$，记录一个 $cnt$ 表示右边已经取过 $cnt$ 次了。考虑右边已经取 $cnt$ 次了要减掉，即 $t_i\gets\max(0, t_i-cnt)$。然后  $ans$ 累加上 $t_i\times now$，$cnt$ 累加上 $t_i$。

然后 $i\le y$ 的情况类似，复杂度 $O(n +m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 5;
int t[N] = { 0 }, a[N] = { 0 }, n, m, x[N],y[N],k[N], ans = 0;
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)cin >> a[i];
    for (int i = 1; i <= m; i++)cin >> x[i] >> y[i] >> k[i];
    for (int i = 1; i <= m; i++)t[x[i]] = max(t[x[i]], k[i]);
    int cnt = 0, now = a[n];
    for (int i = n; i >= 1; i--) {
        now = min(now, a[i]);
        t[i] = max(0ll, t[i]-cnt);
        cnt += t[i];
        ans += t[i] * now;
    }
    for (int i = 1; i <= n; i++)t[i] = 0,k[i]--;
    for (int i = 1; i <= m; i++)t[y[i]] = max(t[y[i]], k[i]);
    cnt = 0, now = a[1];
    for (int i = 1; i <= n; i++) {
        now = min(now, a[i]);
        t[i] = max(0ll, t[i]-cnt);
        cnt += t[i];
        ans += t[i] * now;
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：chen_zhe (赞：6)

对于 hard 版本，其形式是 easy 版本的增强，所以我们可以猜测两个版本之间必然存在紧密的联系。我们不妨对于每个 $x$，将所有 $k_i\ge x$ 的限制单独提取作为一次 easy 版本的问题。不同的是，由于接下来小球可能还有限制需要满足，所以小球需要两次反转，一次在 $l=\min\{y_i\}$（$k_i>x$，下略）前，一次在 $r=\max\{x_i\}$ 后。这里的证明类似 easy 版本，是容易的。

不过特别的，小球在最后一次反转后就满足了所有的限制，所以它就不用再反转回来。我们可以额外减去一次 $l$ 前的贡献，显然我们会选最小的 $l$，也就是 $l=\min\{y\}$。

实现的时候可以提前预处理 $a$ 数组的前后缀 $\min$，然后将 $k_i$ 降序排序，过程中维护 $y$ 的最小值和 $x$ 的最大值。复杂度 $O(m\log m+n)$。

---

## 作者：tzjahinie (赞：3)

### 题目链接：[P10607](https://www.luogu.com.cn/problem/P10607)

### 题目大意：

有一个数轴，其长度为 $n$。将一个初始在数轴 $0$ 点并向数轴正方向移动的小球通过改变移动方向来满足 $m$ 个条件，小球在点 $i$ 改变方向的代价是 $a_i$，第 $j$ 个条件形如“小球需要从点 $x_j$ 移动到点 $y_j$ 至少 $k_j$ 次”。求出花费的最小代价。

### 题目思路：

由题目样例可得：只有第一次只改变一次移动方向，记得直接特判。$k_{maxn}-1$ 为每个条件中最大的 $k$。由题意得：$k$ 越大的时候受限制的条件越少，即满足 $k-1$ 的条件时一定满足 $k$ 的条件，具有单调性。故可以以 $k$ 为关键字从大到小排序，从后倒推来做这道题。找到边界改变方向的最小代价，每有一个新的 $k$ 累加前面的代价，更新左右边界。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,l=0x3f3f3f3f,r;
long long ans;
int a[200005],m1[200005],m2[200005];
struct node{int x,y,k;}c[200005];
bool cmp(node a,node b){return a.k>b.k;}
int main(){
	memset(m1,0x3f,sizeof(m1));
	memset(m2,0x3f,sizeof(m2));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)scanf("%d",a+i);
	for (int i=1;i<=n;i++)m1[i]=min(m1[i-1],a[i]);
	for (int i=n;i>=1;i--)m2[i]=min(m2[i+1],a[i]);
	for (int i=1;i<=m;i++){
		scanf("%d%d%d",&c[i].x,&c[i].y,&c[i].k);
	}
	c[++m].k=1,
	c[m].y=0x3f3f3f3f;
	sort(c+1,c+m+1,cmp);
	for(int i=1;i<m;i++){
		l=min(l,c[i].y),
		r=max(r,c[i].x);
		if(c[ i ].k!=c[i+1].k){
			ans+=(long long)(c[ i ].k-c[i+1].k)*(long long)(m1[l]+m2[r]);
		}
	}
	ans+=m2[r];
	printf("%lld\n",ans);
}
```

---

## 作者：2021sunzishan (赞：3)

题意很明确了，直接看思路。

## 思路：
思考可以发现，最小代价就是在当前最左边和最右边的点各转一次，因为中间所有的区间就都会覆盖一次。所以我们求出 $i$ 点的前缀最小值和后缀最小值作为从这个点折转的代价，将 $x_i$ 从大到小排一次，$y_i$ 从小到大排一次，在每一个点算出需要折转的次数，累计出代价即可。

那么算折转次数就是原本需要折转的次数减去先前已经折转的次数，注意 $y_i$ 要比 $x_i$ 少转一次，可以画图模拟一下。

以上就是本题的思路了，可能我表述不太清楚，来看看代码吧！

**切勿抄袭！！！**

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
#define int long long//答案可能会爆int哦
int n,m;
int a[N]; 
inline int read(){
	int a=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		a=a*10+c-'0';
		c=getchar();
	}
	return a*f;
}
struct node{
	int cnt,k;//k是位置，cnt是次数
}x[N],y[N];
int s1[N],s2[N];
bool cmp1(node a,node b){
	return a.k>b.k;
}
bool cmp2(node a,node b){
	return a.k<b.k;
}
main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	s1[1]=a[1],s2[n]=a[n];
	for(int i=2;i<=n;i++)
	s1[i]=min(s1[i-1],a[i]);//前缀最小值
	for(int i=n-1;i>=1;i--)
	s2[i]=min(s2[i+1],a[i]);//后缀最小值
	for(int i=1;i<=m;i++){
		x[i].k=read(),y[i].k=read();
		x[i].cnt=y[i].cnt=read();
		y[i].cnt--;
	}
	sort(x+1,x+1+m,cmp1);//从大到小
	sort(y+1,y+1+m,cmp2);//从小到大
	int s=0,ans=0;//s统计前面折转了多少次
	for(int i=1;i<=m;i++){
		x[i].cnt=max(x[i].cnt-s,0ll);//当然也不可能是负的
		s+=x[i].cnt,ans+=x[i].cnt*s2[x[i].k];
      //累计次数、代价
	}
	s=0;
	for(int i=1;i<=m;i++){//和上面同理
		y[i].cnt=max(y[i].cnt-s,0ll);
		s+=y[i].cnt,ans+=y[i].cnt*s1[y[i].k];
	}
	printf("%lld\n",ans);
	return 0;
}
```

完结~

---

## 作者：佬头 (赞：2)

## Description
将一个初始在数轴 $0$ 点并向数轴正方向移动的小球通过改变移动方向来满足 $m$ 个条件，求出最小代价。小球在点 $i$ 改变方向的代价是 $a_i$，第 $j$ 个条件形如“小球需要从点 $x_j$ 移动到点 $y_j$ 至少 $k_j$ 次”。

## Solution
- 显然对于两个存在**包含**关系的条件，完成大条件的同时会一定程度上完成小条件（应对二者的要求次数 $k$ 进行分类讨论）。

因此，我们首先便有了一种**前后缀最小值**（代价）的优化思路。
- 为了避免花费多余的代价，在某一次折返时应**尽可能多**的满足多个条件。

因此，对于两个存在**非包含**关系的条件，可将其次数相同部分取**并集**（取最左边的左端点，再取最右边的右端点），优先完成并集的条件，再对个别条件进行处理。而对所有条件进行此操作后，会得到一个左右不对称的金字塔形的大条件（即仅存在包含关系）。

问题已基本解决。代码中在每个条件的端点打上次数 $k$ 的标记（重合时取最大）后，采取**双指针**同时完成上述操作。代码时间复杂度 $\mathcal O(m+n)$。

## Code
```cpp
#include <iostream>
#define ll long long
using namespace std;
const int N = 200005;
int n, m, a[N], lk[N], rk[N];
ll ans;
int read(){
	int x = 0;
	char a = getchar();
	while(a < '0' || '9' < a) a = getchar();
	while('0' <= a && a <= '9') x = (x << 1) + (x << 3) + (a ^ 48), a = getchar();
	return x;
}
void write(ll x){
	if(x > 9) write(x / 10);
	putchar(x % 10 | 48);
}
int main(){
	n = read(), m = read();
	for(int i = 1; i <= n; ++ i) a[i] = read();
	for(int i = 1; i <= m; ++ i){
		int x = read(), y = read(), k = read();
		if(k > lk[y]) lk[y] = k;
		if(k > rk[x]) rk[x] = k;
	}
	for(int ck = 0, lm = a[1], rm = a[n], lft = 1, rt = n; ; ){
		while(lk[lft] <= ck && lft < rt) if(a[++ lft] < lm) lm = a[lft];
		while(rk[rt] <= ck && lft < rt) if(a[-- rt] < rm) rm = a[rt];
		if(lft >= rt) return write(ans), 0;
		if(ck == 0) ans += rm, ++ ck;
		else if(lk[lft] < rk[rt]) ans += (ll)(lk[lft] - ck) * (lm + rm), ck = lk[lft];
		else ans += (ll)(rk[rt] - ck) * (rm + lm), ck = rk[rt];
	}
	return 0;
}
```

---

## 作者：Wei_Han (赞：2)

~~唐，这做法怎么这么麻烦。~~

线段树+双指针。

首先显然，$x_i$ 到 $y_i$ 至少走 $k$ 次就是让区间 $x_i$ 到 $y_i$ 至少被覆盖 $k$ 次，那么我们就可以将条件放到整个区间上。

由 easy 问题的启发，可以发现，最后一趟向回走是不用再回来的。那么我们考虑前面中的一趟，假设当前区间为 $l_i$ 到 $r_i$，那么显然的，我们可以走过 $l_i$ 或 $r_i$ 从他之后的点回头，那么此时的代价就是前后缀最小值，分别记为 $pre_l$ 和 $fac_r$，那么只要不是最后一趟，代价为 $(pre_l+fac_r)\times k$。此时只有一个区间，推广到多区间时，其实也只有区间内 $k$ 的变化，考虑到假如 $l_i$ 位置的值小于 $r_i$ 位置的值，那么我们可以保持 $r_i$ 不动，继续考虑 $l_{i+1}$ 的值减去前一个 $l_i$ 的值后与 $r_i$ 的关系，以此类推。当 $r_i$ 位置小于 $l_i$ 位置时同理移动右端点，这样自然能够想到双指针，由左右向中间枚举，而双指针时需要动态计算区间覆盖次数，提前统计前后缀和，用线段树维护区间覆盖次数的最大值，区间减法，单点查询即可。

实现时还有一点贪心，假如当前位置 $i$ 的次数为 $1$，那么我们可以不去管他，让最后一次返回时扫过来即可，同理，当做区间减法时假如左端点更小，那么只用将他减到 $1$，可以少算一次 $pre_i$ 的代价，也就是每次区间减去 $\min(t_{l_i}-1,t_{r_i})$ 次覆盖，其中 $t$ 为当前点最大的覆盖次数。

注意判断最后一趟向回走的位置，时间复杂度 $O(n\log n)$。
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define pr printf("\n")
#define pp printf(" ")
#define pii pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(ll i = a ; i >= b ; -- i )
#define bug (x>=1&&x<=n&&y>=1&&y<=m) 
using namespace std;
typedef long long ll;
typedef __int128 i128;
typedef double db;
const int N=2e6+5,M=1e7+5;
const db eps=1e-7;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
ll n,a[N],x,y,b[N],m,pre[N],fac[N],maxn,maxx;
struct Tree{ll l,r,sum,lazy,lazy1;}tree[N<<2];
#define rt tree[root]
#define lson tree[root<<1]
#define rson tree[root<<1|1]
inline void pd(ll root){
	ll lazy=rt.lazy;if(!lazy) return;
	lson.sum=max(lson.sum,lazy),lson.lazy=max(lson.lazy,lazy);
	rson.sum=max(rson.sum,lazy),rson.lazy=max(rson.lazy,lazy);
	rt.lazy=0;
}
inline void pd1(ll root){
	ll lazy=rt.lazy1;if(!lazy) return;
	lson.sum-=lazy,rson.sum-=lazy;lson.lazy1+=lazy;rson.lazy1+=lazy;
	rt.lazy1=0;
}
inline void build(ll root,ll l,ll r){
	rt.l=l,rt.r=r;if(l==r) return;
	ll mid=l+r>>1;build(root<<1,l,mid),build(root<<1|1,mid+1,r);
}
inline void upd(ll root,ll x,ll y,ll k){
	ll l=rt.l,r=rt.r;if(x<=l&&y>=r){rt.sum=max(rt.sum,k);rt.lazy=max(rt.lazy,k);return;}
	ll mid=l+r>>1;pd(root);pd1(root);if(x<=mid) upd(root<<1,x,y,k);if(y>mid) upd(root<<1|1,x,y,k);
}
inline void upd1(ll root,ll x,ll y,ll k){
	ll l=rt.l,r=rt.r;if(x<=l&&y>=r){rt.sum-=k;rt.lazy1+=k;return;}
	ll mid=l+r>>1;pd(root);pd1(root);if(x<=mid) upd1(root<<1,x,y,k);if(y>mid) upd1(root<<1|1,x,y,k);
}
inline ll ask(ll root,ll x){
	ll l=rt.l,r=rt.r;if(l==r) return rt.sum;
	ll mid=l+r>>1;pd(root);pd1(root);if(x<=mid) return ask(root<<1,x);else return ask(root<<1|1,x);
}
signed main(){
	mem(pre,0x3f),mem(fac,0x3f);
	read(n),read(m);fo(1,i,n) read(a[i]),pre[i]=min(pre[i-1],a[i]);Fo(n,i,1) fac[i]=min(fac[i+1],a[i]);
	build(1,1,n);fo(1,i,m){ll l,r,k;read(l),read(r);read(k);upd(1,r,l,k);}
	ll l=1,r=n,sum=0;fo(1,i,n) ll opp=ask(1,i);
	ll flag=1,las=0,op=0;
	while(l<r){
		while(ask(1,r)<=0&&l<r) r--;
		while(ask(1,l)<=1&&l<r){l++;if(ask(1,l)==1) flag=0,op=l;}
		if(l>=r) break;
		sum+=las;sum+=(pre[l]+fac[r])*min(ask(1,l)-1,ask(1,r))-pre[l];las=pre[l];
		upd1(1,l,r,min(ask(1,l)-1,ask(1,r)));flag=1;
	}
	if(!flag) sum+=fac[op]+las;
	wr(sum);pr;
	return 0;
}
``````

---

## 作者：xuan_never (赞：0)

## 思路
跟 [easy 版本](https://www.luogu.com.cn/article/r01bkqwl)一样。

每**一回**找到最左与最右的点，用跟 easy 一样的方法算出这一回的代价，不过是左与右都要算，并要乘上 $k$（取两端点中最小的省次数）。最左或最右端点改变算作一回结束。  
这样计算结束后，其实是会有一个多的回头的，减去即可。

## 代码
将条件分别以 $x$ 和 $y$ 排序即可，不想多记录的话可以像我一样用 `pair` 记录 $k$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define fi first
#define se second
int n, m, a[200005], mi1[200005], mi2[200005], x, y, l, r;
pii b1[200005], b2[200005];
ll ans, k, rk;
int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		cin >> a[i];
	// 可以预处理出最优选择
	mi1[n] = a[n], mi2[1] = a[1];
	for (int i = n - 1; i >= 1; --i)
		mi1[i] = min(a[i], mi1[i + 1]);
	for (int i = 2; i <= n; ++i)
		mi2[i] = min(a[i], mi2[i - 1]);
	for (int i = 1; i <= m; ++i)
		cin >> b1[i].fi >> b2[i].fi >> b1[i].se,
		b2[i].se = b1[i].se;
	sort(b1 + 1, b1 + 1 + m, greater<pii>()), // 为了统一，x 要从大到小排
	sort(b2 + 1, b2 + 1 + m);
	l = r = 1;
	while (r <= m && l <= m) {
		k = min(b1[r].se, b2[l].se) - rk;
		ans += k * (mi1[b1[r].fi] + mi2[b2[l].fi]);
		rk += k;
		// 找到最新的最左最右端点
		while (r <= m && b1[r].se <= rk) ++r;
		while (l <= m && b2[l].se <= rk) ++l;
	} cout << ans - mi2[b2[1].fi];
	return 0;
}
```

---


# 电 van

## 题目描述

小 O 非常爱去电 $\texttt{van}$ 城，所以他对 $\texttt{van}$ 这个字符串非常的感兴趣，于是他出了一道和 $\texttt{van}$ 有关的字符串题。

给你一个长度为 $n$ 的字符串 $s$，保证 $s$ 由 $\texttt{v}$、$\texttt{a}$、$\texttt{n}$ 三种字符构成，设 $s_i$ 表示 $s$ 的第 $i$ 个字符。

接下来小 O 会给你 $m$ 次操作，每次操作给出一个整数 $x(1\le x\le n-1)$，表示你需要交换 $s_x$ 和 $s_{x+1}$。

在每次操作结束后，你需要输出字符串中 $\texttt{van}$ 作为子序列的出现次数。

- 一个字符串 $t$ 是字符串 $s$ 的子序列，当且仅当可以从  $s$ 中删除若干个字符（可以为 $0$ 个），将剩下的字符按在 $s$ 中的顺序依次相接得到 $t$。

## 说明/提示

#### 样例 #1 解释

初始时 $s=\texttt{vvvaannn}$。

第一次操作交换 $s_4$ 和 $s_5$，此时 $s=\texttt{vvvaannn}$，$\texttt{van}$ 作为子序列出现了 $18$ 次。

第二次操作交换 $s_3$ 和 $s_4$，此时 $s=\texttt{vvavannn}$，$\texttt{van}$ 作为子序列出现了 $15$ 次。

第三次操作交换 $s_5$ 和 $s_6$，此时 $s=\texttt{vvavnann}$，$\texttt{van}$ 作为子序列出现了 $12$ 次。

### 数据范围

对于 $100\%$ 的数据，$3\le n\le 10^6$，$1\le m\le 10^6$，$s_i\in\{\texttt{v,a,n}\}$。

具体测试点限制如下表：

| 测试点编号 | $n$ 的范围 | $m$ 的范围 | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1,2$ | $n\le 3$ | $m\le 100$ | 无 |
| $3\sim 5$ | $n\le 100$ | $m\le 100$ | 无 |
| $6\sim 9$ | $n\le 3000$ | $m\le 3000$ | 无 |
| $10\sim 12$ | $n\le 10^6$ | $m=1$ | 无 |
| $13\sim16$ | $n\le 10^5$ | $m\le 10^5$ | A |
| $17,18$ | $n\le 10^5$ | $m\le 10^5$ | 无 |
| $19,20$ | $n\le 10^6$ | $m\le 10^6$ | 无 |

特殊性质 A：对于交换操作，保证 $s_x$ 和 $s_{x+1}$ 中至少有一个为 $\texttt{a}$。


## 样例 #1

### 输入

```
8 3
vvvaannn
4
3
5```

### 输出

```
18
15
12```

# 题解

## 作者：_Deer_Peach_ (赞：17)

题意：

给你一个长度为 $n$ 的只包括 $\texttt{v}$、$\texttt{a}$、$\texttt{n}$ 三个字符的字符串，有 $m$ 次操作，每次操作交换 $s_x$ 和 $s_{x+1}$，求每次操作后字符串中 $\texttt{van}$ 作为子序列的出现次数。

思路：

暴力解法直接排除，思考怎么快速计算。

我们可以寻找每一个字符 $\texttt{a}$，统计其前面的 $\texttt{v}$ 以及后面 $\texttt{n}$ 的数量，相乘便是含有这个 $\texttt{a}$ 的子序列的数量，累加便是最后的答案。

再考虑修改，每次修改只会交换前后的字符，重要的是，每次修改只会影响一个 $\texttt{a}$ 前后 $\texttt{v}$ 和 $\texttt{n}$ 的数量。
具体需要分类讨论：
1. $s_x$ 为字符 $\texttt{a}$；
2. $s_x$ 为字符 $\texttt{v}$；
3. $s_x$ 为字符 $\texttt{n}$。

当 $s_x$ 为字符 $\texttt{a}$ 时，讨论 $s_{x+1}$：
1. $s_{x+1}$ 为字符 $\texttt{x}$，则相当于没修改；
2. $s_{x+1}$ 为字符 $\texttt{v}$，则 $\texttt{a}$ 前面 $\texttt{v}$ 的数量加一；
3. $s_{x+1}$ 为字符 $\texttt{n}$，则 $\texttt{a}$ 后面 $\texttt{n}$ 的数量减一。

当 $s_{x+1}$ 为字符 $\texttt{a}$ 时，讨论 $s_{x}$：
1. $s_{x}$ 为字符 $\texttt{x}$，同上；
2. $s_{x}$ 为字符 $\texttt{v}$，则 $\texttt{a}$ 前面 $\texttt{v}$ 的数量减一；
3. $s_{x}$ 为字符 $\texttt{n}$，则 $\texttt{a}$ 后面 $\texttt{n}$ 的数量加一。

都不是则没有影响，因为只有当 $\texttt{a}$ 是被修改的两个字符中其中一个才会受到影响，具体证明很简单，不再赘述。

每次修改减去当前 $\texttt{a}$ 的贡献，再更新前后 $\texttt{v}$ 和 $\texttt{n}$ 的数量，最后加上更新后 $\texttt{a}$ 的贡献就是最后的答案。

代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=1e6+5;
int n,m;
string s;
int va[N],an[N];
vector<int>a;
int numa;
signed main(){
    IOS;
    cin>>n>>m;
    cin>>s;
    s=" "+s;
    int numv=0,numn=0;
	for(int i=1;i<=n;i++){
		if(s[i]=='v')numv++;
		if(s[i]=='a'){
			va[i]=numv;
			a.push_back(i);
			numa++;
		}
	}
	for(int i=n;i>=1;i--){
		if(s[i]=='n')numn++;
		if(s[i]=='a'){
			an[i]=numn;
		}
	}
	int ans=0;
	for(int i=0;i<numa;i++){
		ans=ans+va[a[i]]*an[a[i]];
	}
	while(m--){
		int x;
		cin>>x;
		int l=0,r=numa-1;
		int mid;
		while(l<r){
			mid=l+r>>1;
			a[mid]>=x?r=mid:l=mid+1;
		}
		int aid=a[r];
		if(aid==x){
			if(s[x+1]=='a'){
				cout<<ans<<endl;
			}
			if(s[x+1]=='v'){
				ans=ans-va[x]*an[x];
				swap(va[x],va[x+1]);
				swap(an[x],an[x+1]);
				va[x+1]++;
				ans=ans+va[x+1]*an[x+1];
				a[r]++;
				cout<<ans<<endl;
			}
			if(s[x+1]=='n'){
				ans=ans-va[x]*an[x];
				swap(va[x],va[x+1]);
				swap(an[x],an[x+1]);
				an[x+1]--;
				ans=ans+va[x+1]*an[x+1];
				a[r]++;
				cout<<ans<<endl;
			}
		}
		else if(aid==x+1){
			if(s[x]=='v'){
				ans=ans-va[x+1]*an[x+1];
				swap(va[x],va[x+1]);
				swap(an[x],an[x+1]);
				va[x]--;
				ans=ans+va[x]*an[x];
				a[r]--;
				cout<<ans<<endl;
			}
			if(s[x]=='n'){
				ans=ans-va[x+1]*an[x+1];
				swap(va[x],va[x+1]);
				swap(an[x],an[x+1]);
				an[x]++;
				a[r]--;
				ans=ans+va[x]*an[x];
				cout<<ans<<endl;
			}
		}
		else{
			cout<<ans<<endl;
		}
		swap(s[x],s[x+1]);
		/*cout<<s<<endl;
		for(int i=1;i<=numa;i++){
			cout<<a[i-1]<<" ";
			cout<<va[a[i-1]]<<" "<<an[a[i-1]]<<endl;
		}*/
	}
	return 0;
}
```
很明显可以优化，但作者懒得优化（疑似最劣解）。

---

## 作者：未来姚班zyl (赞：6)

考察前缀和。

维护 $\texttt{v}$ 和 $\texttt{n}$ 的前缀和 $pv_i$ 和 $pn_i$，这样可以求出初始答案：找到 $s_i=\texttt{a}$ 的位置，将答案加上 $pv_{i-1}(n-pn_i)$。

交换 $s_x$ 和 $s_{x+1}$，则前缀和中只有 $pv_x$ 和 $pn_x$ 会受到影响，重新维护 $x$ 上的前缀和，然后重新计算 $s_{x}$ 和 $s_{x+1}$ 中 $\texttt{a}$ 的贡献即可，复杂度 $O(n)$。

如果没想到正解，只要会用前缀和求答案就可以获得很多部分分。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define repn(x) rep(x,1,n)
#define repm(x) rep(x,1,m)
#define pb push_back
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
using namespace std;
const int N=1e6+5;
int n,m,pv[N],pn[N];
string s;
inline void Main(){
	n=read(),m=read(),cin>>s,s='#'+s;
	repn(i)pv[i]=pv[i-1]+(s[i]=='v'),pn[i]=pn[i-1]+(s[i]=='n');
	ll ans=0;
	repn(i)if(s[i]=='a')ans+=(ll)pv[i-1]*(pn[n]-pn[i]);
	while(m--){
		int x=read();
		if(s[x]!=s[x+1]){
			rep(i,x,x+1)if(s[i]=='a')ans-=(ll)pv[i-1]*(pn[n]-pn[i]);
			swap(s[x],s[x+1]);
			pv[x]=pv[x-1]+(s[x]=='v'),pn[x]=pn[x-1]+(s[x]=='n');
			rep(i,x,x+1)if(s[i]=='a')ans+=(ll)pv[i-1]*(pn[n]-pn[i]);
		}
		cout <<ans<<'\n';
	}
}
signed main(){
    int T=1;
	while(T--)Main();
	return 0;
}


```

---

## 作者：TemplateClass (赞：6)

分讨。

首先我们先 $O(n)$ 地求出原本的子序列个数：

```cpp
ll cv = 0ll, cva = 0ll, cvan = 0ll;
for(int i = 1; i <= n; ++i) {
	cv += (s[i - 1] == 'v');
	cva += cv * (s[i - 1] == 'a');
	cvan += cva * (s[i - 1] == 'n');
}
```

其中 `cvan` 即为答案。

接下来考虑我们更新答案时需要什么：

- 显然如果我们交换的是 $\tt v, a$，我们需要知道之后的 $\tt n$ 的个数来对答案进行加减；
- 如果我们交换的是 $\tt a, n$，我们需要知道前面的 $\tt v$ 的个数来进行加减；
- 如果我们交换的是 $\tt v, n$，不会对答案产生影响。

因此我们预处理两个数组 `prev_v` 和 `next_n`，含义如上表示：

```cpp
for(int i = 1; i <= n; ++i) {
	prev_v[i] = prev_v[i - 1] + (s[i - 1] == 'v');
}
for(int i = n; i >= 1; --i) {
	next_n[i] = next_n[i + 1] + (s[i - 1] == 'n');
}
```

然后每次交换的时候更新一下两个数组和答案即可。

```cpp
while(m--) {
	int x; std::cin >> x;
	if(s[x - 1] == 'v' && s[x] == 'n') --prev_v[x], --next_n[x + 1];
	if(s[x - 1] == 'n' && s[x] == 'v') ++prev_v[x], ++next_n[x + 1];
	if(s[x - 1] == 'v' && s[x] == 'a') --prev_v[x], cvan -= next_n[x];
	if(s[x - 1] == 'a' && s[x] == 'v') ++prev_v[x], cvan += next_n[x];
	if(s[x - 1] == 'a' && s[x] == 'n') --next_n[x + 1], cvan -= prev_v[x];
	if(s[x - 1] == 'n' && s[x] == 'a') ++next_n[x + 1], cvan += prev_v[x];
	std::swap(s[x - 1], s[x]); std::cout << cvan << "\n";
}
```

---

## 作者：lw393 (赞：5)

前缀和好题。

对于一个只有 v、a、n 的字符串，含“van”的子序列有多少呢？我们对于字母 a 来考虑每个 a 的贡献，显然地，我们发现对于字符串中的每个 a，我们只需要将在它前面的 v 的数量乘以在它后面的 n 的数量（这个利用前缀和和后缀和很容易做到）。

然后操作中要求将 $x$ 与 $x + 1$ 上的字母交换，并求出交换后的答案，我们就从 v 的前缀和数组与 n 的后缀和数组下文章，由于只用交换相邻位，自己观察一下就可以得出数组变化的规律。

交换的子母中有 a 怎么办，我们就判断 a 是与谁交换，在前还是在后。我们找到规律：

若在 $x$ 位置上，与 n 交换时，答案变小，数值上等于这个 a 前面的 v 的数量；与 v 交换时，答案变大，数值上等于 a 后面 n 的数量。

而在 $x + 1$ 位置上与 $x$ 位置上相反。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 5;

int pre[N], suf[N];

void solve(){
  int n, m;
  cin >> n >> m;
  string s;
  cin >> s;
  s = ' ' + s;
  for(int i = 1; i <= n; i++) pre[i] = pre[i - 1] + (s[i] == 'v');
  for(int i = n; i >= 1; i--) suf[i] = suf[i + 1] + (s[i] == 'n');
  int ans = 0;
  for(int i = 1; i <= n; i++) ans += (s[i] == 'a') * pre[i] * suf[i];
  for(int i = 1; i <= m; i++){
    int x;
    cin >> x;
    if(s[x] == 'a' && s[x + 1] == 'n') ans -= pre[x], suf[x + 1]--;
    else if(s[x] == 'a' && s[x + 1] == 'v') ans += suf[x], pre[x]++;
    else if(s[x] == 'n' && s[x + 1] == 'a') ans += pre[x], suf[x + 1]++;
    else if(s[x] == 'v' && s[x + 1] == 'a') ans -= suf[x], pre[x]--;
    else if(s[x] == 'v' && s[x + 1] == 'n') pre[x]--, suf[x + 1]--;
    else if(s[x] == 'n' && s[x + 1] == 'v') pre[x]++, suf[x + 1]++;
    swap(s[x], s[x + 1]);
    cout << ans << '\n';
  }
}

signed main(){
  int t = 1;
  //cin >> t;
  while(t--){
      solve();
  }
  return 0;
}
```

---

## 作者：P2441M (赞：4)

## 题意
给定一个长度为 $n$ 的，仅由 $\texttt{v}$、$\texttt{a}$、$\texttt{n}$ 三种字符组成的字符串 $s$。给出 $m$ 次操作 $x$，表示交换 $s_x,s_{x+1}$，每次操作后输出 $s$ 的所有子序列中 $\texttt{van}$ 的个数。$1\leq n,m\leq 10^6$。

## 题解
先求出初始时的答案：预处理前缀 $\texttt{v}$ 和后缀 $\texttt{n}$ 的个数，答案就是 $\sum_{s_i=\texttt{a}}pre_{i-1}suf_{i+1}$。

再来考虑交换操作的影响。容易发现，当且仅当 $\{s_x,s_{x+1}\}=\{\texttt{v},\texttt{a}\}$ 或 $\{s_x,s_{x+1}\}=\{\texttt{a},\texttt{n}\}$ 时答案会改变。当 $s_x=\texttt{v}\land s_{x+1}=\texttt{a}$ 时，$ans\leftarrow ans-suf_{x+2}$，其他情况同理。同时我们也要对应更新 $pre$ 和 $suf$，直接讨论即可。

时间复杂度 $\mathcal{O}(n+m)$。

## 代码
```cpp
#include <iostream>

using namespace std;

#define lowbit(x) ((x) & -(x))
#define chk_min(x, v) (x) = min((x), (v))
#define chk_max(x, v) (x) = max((x), (v))
typedef long long ll;
typedef pair<int, int> pii;
const int N = 1e6 + 5;

int n, m, pre[N], suf[N];
ll ans;
char s[N];

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m >> s + 1;
    for (int i = 1; i <= n; ++i) pre[i] = pre[i - 1] + (s[i] == 'v');
    for (int i = n; i; --i) suf[i] = suf[i + 1] + (s[i] == 'n');
    for (int i = 1; i <= n; ++i)
    	if (s[i] == 'a') ans += 1ll * pre[i - 1] * suf[i + 1];
    while (m--) {
    	int x; cin >> x;
    	if (s[x] == 'v' && s[x + 1] == 'a') ans -= suf[x + 2];
    	if (s[x] == 'a' && s[x + 1] == 'v') ans += suf[x + 2];
    	if (s[x] == 'a' && s[x + 1] == 'n') ans -= pre[x - 1];
    	if (s[x] == 'n' && s[x + 1] == 'a') ans += pre[x - 1];
    	if (s[x] == 'v' && s[x + 1] != 'v') --pre[x];
    	if (s[x + 1] == 'v' && s[x] != 'v') ++pre[x];
    	if (s[x] == 'n' && s[x + 1] != 'n') ++suf[x + 1];
    	if (s[x + 1] == 'n' && s[x] != 'n') --suf[x + 1];
    	swap(s[x], s[x + 1]), cout << ans << '\n';
    }
    return 0;
}
```

---

## 作者：Chase12345 (赞：4)

简单题。~~赛时居然花了我2.5h~~。

我们首先找出统计 `van` 作为子序列的计数方法，以下是容易得到的：
$$
\sum_{S_i=\texttt{a}} \left(\left(\sum_{j=1}^{i-1} [S_i=\texttt{v}]\right) \times \left(\sum_{j=i+1}^{|S|} [S_i=\texttt{n}]\right)\right)
$$
说人话就是对于每个 $S_i=\texttt{a}$ 的 $i$，我们统计 $1$ 到 $i-1$ 中的 $\texttt{v}$ 的个数，并将结果与 $i+1$ 到 $|S|$ 中 $\texttt{n}$ 的个数乘起来，就是 `van` 作为子序列的子序列数量。显然地，要统计 $1$ 到 $i-1$ 中的 $\texttt{v}$ 的个数，可以直接使用前缀和，而 $i+1$ 到 $|S|$ 中 $\texttt{n}$ 的个数使用后缀和即可。

以下内容均记 $T_i=\sum_{j=1}^{i}[S_i=\texttt{v}],G_i=\sum_{j=i}^{|S|}[S_i=\texttt{n}]$。

* 对于每次操作，进行分类讨论。如果操作的两个字符相同，显然不用操作。

* 如果 $S_x=\texttt{v}$ 且 $S_{x+1}=\texttt{n}$，则 $T_x$ 应该减 $1$，$G_{x+1}$ 应该减 $1$，这一点是容易理解的。

而其余的部分相对容易理解，这里不一一列举。那么我们就得到了一份 TLE 的代码。这是为什么呢？每次询问我们修改完 $T_x$ 和 $G_x$ 和 $T_{x+1}$ 和 $G_{x+1}$ 之后，我们都重新将和算了一遍。这显然重复计算了。那么我们只需将变化的部分在历史的答案中更新即可。于是我们就得到了满分代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
long long sum1[N], sum2[N], ans;
string s;

int main() {
	int n, m;
	cin >> n >> m >> s;
	s = ' ' + s;
	for (int i = 1; i <= n; i++)
		sum1[i] = sum1[i - 1] + (s[i] == 'v');
	for (int i = n; i >= 1; i--)
		sum2[i] = sum2[i + 1] + (s[i] == 'n');
	for (int i = 1; i <= n; i++)
		ans += ((s[i] == 'a') * sum1[i - 1] * sum2[i + 1]);
	while (m--) {
		int x;
		cin >> x;
		if (s[x] == 'a' && s[x + 1] == 'v') {
			ans -= (sum1[x - 1] * sum2[x + 1]);
			swap(s[x], s[x + 1]);
			ans += ((++sum1[x]) * sum2[x + 2]);
		} else if (s[x] == 'a' && s[x + 1] == 'n') {
			ans -= (sum1[x - 1] * sum2[x + 1]);
			swap(s[x], s[x + 1]);
			ans += (sum1[x] * sum2[x + 2]);
			sum2[x + 1]--;
		} else if (s[x] == 'v' && s[x + 1] == 'a') {
			ans -= (sum1[x] * sum2[x + 2]);
			swap(s[x], s[x + 1]);
			sum1[x]--;
			ans += (sum1[x - 1] * sum2[x + 1]);
		} else if (s[x] == 'n' && s[x + 1] == 'a') {
			ans -= (sum1[x] * sum2[x + 2]);
			swap(s[x], s[x + 1]);
			ans += (sum1[x - 1] * (++sum2[x + 1]));
		} else if (s[x] == 'v' && s[x + 1] == 'n') {
            sum1[x]--;
            sum2[x + 1]--;
            swap(s[x], s[x + 1]);
        } else if (s[x] == 'n' && s[x + 1] == 'v') {
            sum2[x + 1]++;
            sum1[x]++;
            swap(s[x], s[x + 1]);
        }
		cout << ans << '\n';
	}
	return 0;
}
```
这里我在 $S$ 前面补了空格，是为了方便后续操作，大佬们不必模仿。

---

## 作者：_H17_ (赞：3)

## 题目分析

注意到是 $\texttt{van}$ 当做子序列，考虑枚举中间的 $\texttt{a}$，同时维护前缀 $\texttt{v}$ 的数量和后缀 $\texttt{n}$ 的数量，对于每一个 $\texttt{a}$（位置是 $i$）作为中间组成的的子序列都有 $pre_{\texttt{v},i-1}\times suf_{\texttt{n},i+1}$。

考虑修改：由于是相邻的位置修改，在前缀和和后缀和数组上只需要单点修改（因为修改 $i,i+1$ 不影响 $1\sim i-1,i+2\sim n$ 中的前后缀数量和）。

剩下的分类讨论答案较上一次的修改即可即可。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int unsigned long long 
#define prev faishdfiasd
using namespace std;
constexpr int N=1e6+3;
int n,q,prev[N],sufn[N],ans;
string s;
signed main(){
    cin>>n>>q>>s;
    s=" "+s;
    prev[0]=sufn[n+1]=0;
    for(int i=1;i<=n;i++){
        prev[i]=prev[i-1];
        if(s[i]=='v')
            prev[i]++;
    }
    for(int i=n;i>=1;i--){
        sufn[i]=sufn[i+1];
        if(s[i]=='n')
            sufn[i]++;
    }
    for(int i=1;i<=n;i++)
        if(s[i]=='a')
            ans+=prev[i-1]*sufn[i+1];
    for(int x;q;--q){
        cin>>x;
        if(s[x]==s[x+1]);
        if(s[x]=='v'&&s[x+1]=='n')
            prev[x]--,sufn[x+1]--;
        if(s[x]=='n'&&s[x+1]=='v')
            prev[x]++,sufn[x+1]++;
        if(s[x]=='a'&&s[x+1]=='n')
            sufn[x+1]--,ans-=prev[x-1];
        if(s[x]=='n'&&s[x+1]=='a')
            sufn[x+1]++,ans+=prev[x-1];
        if(s[x]=='a'&&s[x+1]=='v')
            prev[x]++,ans+=sufn[x+1];
        if(s[x]=='v'&&s[x+1]=='a')
            prev[x]--,ans-=sufn[x+1];
        swap(s[x],s[x+1]);
        cout<<ans<<'\n';
    }
    return 0;
}
```

---

## 作者：_O_v_O_ (赞：3)

唐题。

我们考虑维护中间的 $\texttt a$，然后我们设 $pre_i$ 表示 $i$ 之前的 $\texttt v$ 数量，$suf_i$ 表示 $i$ 之后的 $\texttt n$ 数量。那么一个 $i$ 的贡献为 $[s_i=\texttt{a}]\times pre_i\times suf_i$。

我们注意到一个交换只会影响被交换的两个的 $pre$ 和 $suf$，那么直接维护即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N=1e6+5;
int n,m,fr[N],bk[N],cnt,ps[N],ans;
string s;

signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m>>s;s=' '+s;
	int qwq=0;
	for(int i=1;i<=n;i++){
		if(s[i]=='v') qwq++;
		if(s[i]=='a'){
			ps[i]=++cnt;
			fr[cnt]=qwq;
		}
	}
	qwq=0;
	for(int i=n;i>=1;i--){
		if(s[i]=='n') qwq++;
		if(s[i]=='a'){
			bk[ps[i]]=qwq;
			ans+=bk[ps[i]]*fr[ps[i]];
		}
	}
	for(int i=1,x;i<=m;i++){
		cin>>x;
		if(s[x]=='v'){
			if(s[x+1]=='a'){
				ans-=bk[ps[x+1]];
				fr[ps[x+1]]--;
				swap(ps[x],ps[x+1]);
			}
		}
		else if(s[x]=='a'){
			if(s[x+1]=='v'){
				ans+=bk[ps[x]];
				fr[ps[x]]++;
				swap(ps[x],ps[x+1]);
			}
			else if(s[x+1]=='n'){
				ans-=fr[ps[x]];
				bk[ps[x]]--;
				swap(ps[x],ps[x+1]);
			}
		}
		else if(s[x]=='n'){
			if(s[x+1]=='a'){
				ans+=fr[ps[x+1]];
				bk[ps[x+1]]++;
				swap(ps[x],ps[x+1]);
			}
		}
		cout<<ans<<endl;
		swap(s[x],s[x+1]);
	}
	return 0;
}

```

---

## 作者：TPJX (赞：1)

可将问题分解为统计每个 `a` 左边 `v` 的数量和右边 `n` 的数量，并计算其乘积之和。初始时使用两个树状数组分别记录 `v` 的前缀和和 `n` 的后缀和，并预处理所有 `a` 的贡献总和。每次交换时只需检查交换位置及其相邻字符是否影响 `a` 的贡献，如果是 `a` 则先减去旧贡献，然后交换字符并更新树状数组，最后重新计算新贡献。每次查询 $O(\log{n})$，总复杂度 $O((n + m)\log{n})$。

---

## 作者：Haohao123coding (赞：1)

## 题意简述

给定一个字符串，仅包含 $\texttt{v}$、$\texttt{a}$、$\texttt{n}$ 三种字符。接下来进行 $m$ 次操作，每次操作给定 $x$，交换 $s_x$ 和 $s_{x-1}$，输出交换后的字符串中子序列 $\texttt{van}$ 的出现次数。注意子序列**不一定连续**。

## 做法

### 朴素做法

写一个计算用函数，计算一个字符串中子序列 $\texttt{van}$ 的出现次数，复杂度 $O(n^3)$，类似下面这样：

```cpp
int clc(string a){
	int ans = 0, len = a.length();
	for(int i = 0; i < len; i++){
		for(int j = i+1; j < len; j++){
			for(int k = j+1; k < len; k++){
				if(a[i] == 'v' && a[j] == 'a' && a[k] == 'n'){
					ans++;
				}
			}
		}
	}
	return ans;
}
```

主函数里面直接循环：

```cpp
for(int i = 0; i < m; i++){
	cin >> tmp;
	swap(str[tmp-1], str[tmp]);
	cout << clc(str) << '\n';
}
```

总复杂度达到 $O(n^3 m)$，只能通过 $1 \sim 5$ 的测试点，$25$ 分。

-----

### 正解

不难发现，每个字符 $\texttt{a}$ 对答案的贡献是其左边 $\texttt{v}$ 的数量乘以右边 $\texttt{n}$ 的数量（乘法原理）。而答案则是所有字符 $\texttt{a}$ 的贡献之和。

- 例如 $s=\texttt{vvvaannn}$，字符 $\texttt{a}$ 的的贡献是左边 $\texttt{v}$ 的数量 $3$ 乘以右边 $\texttt{n}$ 的数量 $3$；答案就是中间两个字符 $\texttt{a}$ 的贡献之和 $18$。

所以，先读入字符串并扫一遍，计算每一个字符 $\texttt{a}$ 的贡献，可以找 $\texttt{a}$ 然后往前后找，复杂度 $O(n^2)$，会 TLE，能通过 $1 \sim 9$ 的测试点，$45$ 分。

而正解是可以用两个变量记录当前前面有几个 $\texttt{v}$ 和后面有几个 $\texttt{n}$，扫到 $\texttt{v}$ 或者 $\texttt{n}$ 就让变量加或减，复杂度 $O(n)$。

接下来处理交换。很明显，如果 $\texttt{a}$ 与 $\texttt{v}$ 交换，则左边 $\texttt{v}$ 的数量就会 $+1$ 或 $-1$，而贡献则要加上或减去右边 $\texttt{n}$ 的数量（因为在计算贡献时左边 $\texttt{v}$ 的数量和右边 $\texttt{n}$ 的数量是相乘的）。接着将加减后的新答案输出即可，最后处理完贡献不要忘记把两个字符的顺序交换。

总复杂度 $O(n+m)$，能通过所有数据，$100$ 分。

## 最终实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct chr{
	char typ;
	int xl, xr;
};
signed main(){
	int n, m, tmp, ans = 0, nowv = 0, nown = 0;
	string str; chr a[1234567];
	cin >> n >> m;
	cin >> str;
	for(int i = 0; i < n; i++){
		a[i].typ = str[i];
		if(a[i].typ == 'n'){
			nown++;
		}
	}
	for(int i = 0; i < n; i++){
		a[i].typ = str[i];
		a[i].xl = 0; a[i].xr = 0;
		if(a[i].typ == 'v'){
			nowv++;
		}else if(a[i].typ == 'n'){
			nown--;
		}else{
            a[i].xl = nowv;
    		a[i].xr = nown;
    		ans += a[i].xl * a[i].xr;
        }
	}
	for(int i = 0; i < m; i++){
		cin >> tmp;
		if(a[tmp-1].typ == 'a' && a[tmp].typ == 'n'){
			a[tmp-1].xr--;
			ans -= a[tmp-1].xl;
		}else if(a[tmp-1].typ == 'n' && a[tmp].typ == 'a'){
			a[tmp].xr++;
			ans += a[tmp].xl;
		}else if(a[tmp-1].typ == 'v' && a[tmp].typ == 'a'){
			a[tmp].xl--;
			ans -= a[tmp].xr;
		}else if(a[tmp-1].typ == 'a' && a[tmp].typ == 'v'){
			a[tmp-1].xl++;
			ans += a[tmp-1].xr;
		}
		swap(a[tmp-1], a[tmp]);
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：transitory (赞：1)

对于字符串 $s$ 每次询问的答案为：对于每个 $s_i=\texttt{a}$，包含 $s_i$ 的子序列 $\texttt{van}$ 的个数为 $\sum^{i-1}_{j=1} [s_j=\texttt{v}] \times \sum^{n}_{j=i+1} [s_j=\texttt{n}]$，其中 $[x]$ 的含义为：当表达式 $x$ 为真时，值为 $1$，否则为 $0$。

所以对于每个 $i$ 可以使用三个树状数组维护 $\sum^{i}_{j=1} [s_j=\texttt{v}]$，$\sum^{i}_{j=1} [s_j=\texttt{n}]$，与当 $s_i=\texttt{a}$ 时 $\sum^{i-1}_{j=1} [s_j=\texttt{v}] \times \sum^{n}_{j=i+1} [s_j=\texttt{n}]$。

对于每次交换 $s_x$ 与 $s_{x+1}$，只会对下标 $x$ 与下标 $x+1$ 产生影响。

每组询问的答案即为对于所有 $1\le i \le n$ 且 $s_i=\texttt{a}$ 时的 $\sum^{i-1}_{j=1} [s_j=\texttt{v}] \times \sum^{n}_{j=i+1} [s_j=\texttt{n}]$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,m;
char a[1000005];
int tree[1000005][3];//tree[i][0] 维护 n，tree[i][1] 维护 a，tree[i][2] 维护 n
string s;
int query(int x,int id) {
  int ans=0;
  if(x==0)return 0;
  for(;x;ans+=tree[x][id],x-=(x&(-x))) {}
  return ans;
}
void modify(int x,int v,int id) {
  for(;x<=n;tree[x][id]+=v,x+=(x&(-x))) {}
}
int getsum(int l,int r,int id){
	return query(r,id)-query(l-1,id);
}
void work(int i){
	if(a[i]=='n')modify(i,1,2);
	if(a[i]=='v')modify(i,1,0);
}
void zero(int i){
	if(a[i]=='n')modify(i,-getsum(i,i,2),2);
	if(a[i]=='v')modify(i,-getsum(i,i,0),0);
	if(a[i]=='a')modify(i,-getsum(i,i,1),1);
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
  cin>>n>>m;
  for(int i=1;i<=n;i++)cin>>a[i];
  for(int i=1;i<=n;i++){
  	work(i);//计算 1~i 中 v 和 n 的和
  }
  for(int i=1;i<=n;i++){
  	if(a[i]=='a')modify(i,getsum(1,i-1,0)*getsum(i+1,n,2),1);// 1~i-1 的 v 之和与 i+1~n 的 n 之和的积
  }
  while(m--){
  	int x;
  	cin>>x;
	zero(x);//清空
	zero(x+1);//清空
	swap(a[x],a[x+1]);
	if(a[x+1]=='n')modify(x+1,1,2);//当 s[x+1]=n 时
	if(a[x+1]=='v')modify(x+1,1,0);//当 s[x+1]=v 时
	if(a[x]=='n')modify(x,1,2);//当 s[x]=n 时
	if(a[x]=='v')modify(x,1,0);//当 s[x]=v 时
	if(a[x]=='a'){
		modify(x,getsum(1,x-1,0)*getsum(x+1,n,2),1);//当 s[x]=a 时
	}if(a[x+1]=='a'){
		modify(x+1,getsum(1,x+1-1,0)*getsum(x+1+1,n,2),1);//当 s[x+1]=a 时
	}cout<<getsum(1,n,1)<<"\n";//输出答案
  }
  return 0;
}
```

---

## 作者：jackson_cao (赞：1)

# 题解：P12246 电 van
## 题目大意
给定一个长度为 $ n $ 的字符串 $ S $，进行 $m$ 次交换操作，每次交换 $s_x$ 与 $s_{x+1}$，并输出字符串中 $\texttt{van}$  作为子序列的出现次数。
## 解题思路
首先很容易想到直接交换，然后暴力求解，但 $ n $ 的范围是 $10^6$，肯定不行。

那么不妨从头开始思考，如果只是让我们求 $\texttt{van}$  作为子序列的出现次数，我们该怎么求呢？

很容易想到一种解法：计算每个字符 $\texttt{a}$ 对答案的贡献，然后把它们相加，便是 $\texttt{van}$ 的出现次数。

那么，该如何计算每个字符 $\texttt{a}$ 的贡献呢？做法也很简单：求出在它前面有几个字符 $ \texttt{v}$ 和在它后面有几个字符 $\texttt{n}$，将它们相乘即可。

那么，我们只要用前缀和与后缀和就可以解决了，不妨用 $numv_i$ 与 $numn_i$ 来表示求出的字符 $\texttt{v}$ 和字符 $\texttt{n}$ 的出现次数。

说了这么多，到底该怎么处理交换呢？我们可以将交换分为这么几类：  
1. 有字符 $\texttt{v}$ 参与的交换。
2. 有字符 $\texttt{a}$ 参与的交换。
3. 有字符 $\texttt{n}$ 参与的交换。

对于第一种和第三种交换，因为我们处理的是字符 $\texttt{a}$ 的贡献，所以这俩其实对答案没啥帮助，只要修改一下 $numv$ 和 $numn$ 就行了，具体实现请见代码。

那么对于第二种交换，我们还可以继续分为三种：  
1. 和字符 $\texttt{v}$ 的交换。
2. 和字符 $\texttt{a}$ 的交换。
3. 和字符 $\texttt{n}$ 的交换。

第二种交换换了和没换一个样，直接跳过。那么对于第一种交换，如果是把一个 $\texttt{v}$ 换到了它的前面，它前面的 $\texttt{v}$ 的数量就会加一，这时它对答案的贡献就会加上 $numn_x$，也就是答案加上 $numn_x$。如果是把一个 $\texttt{v}$ 换到它后面，将答案减去 $numn_x$ 即可。第三种交换同理。

## AC代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6+5;
int n,m,numv[N],numn[N],ans;
string s;
signed main(){
    cin>>n>>m>>s;
    numv[0]=(s[0]=='v');
    for(int i=1;i<n;i++){
        if(s[i]=='v') numv[i]=numv[i-1]+1;
        else numv[i]=numv[i-1]; 
    }
    for(int i=n-1;i>=0;i--){
        numn[i]=numn[i+1]+(s[i]=='n');
    }
    for(int i=0;i<n;i++) if(s[i]=='a') ans+=numv[i]*numn[i];
    for(int i=1,x;i<=m;i++){
        cin>>x;
        if(s[x]=='v'){
            numv[x-1]++;
            if(s[x-1]=='a') ans+=numn[x-1];
        } 
        if(s[x-1]=='v'){
            numv[x-1]--;
            if(s[x]=='a') ans-=numn[x];
        } 
        if(s[x]=='n'){
            numn[x]--;
            if(s[x-1]=='a') ans-=numv[x-1];
        } 
        if(s[x-1]=='n'){
            numn[x]++;
            if(s[x]=='a') ans+=numv[x];
        }
        swap(s[x],s[x-1]);
        cout<<ans<<"\n";
    }
    return 0;
}
```
又及：不开long long见祖宗，别问我怎么知道的。  
又又及：蒟蒻第二次写题解，求管理大大过。

---

## 作者：Mier_Samuelle (赞：1)

首先，对于一个确定的字符串 $s$，考虑如何求出现次数。

显然，先处理出每个前缀中 $\texttt{v}$ 的数量，和每个后缀中 $\texttt{n}$ 的数量，然后对于每个 $\texttt{a}$ 分别计算贡献即可。

不难发现，对于每次操作，只有 $s_x$ 和 $s_{x+1}$ 的贡献发生了改变，故只需考虑这两个位置。

单次询问时间复杂度 $O(1)$，预处理复杂度 $O(n)$，总复杂度 $O(n+q)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 1e6 + 10;
int pre[MAXN], suf[MAXN];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	string str;
	int n, m;
	cin >> n >> m >> str;
	str = " " + str;
	int ans = 0;
	for (int i = 1;i <= n;i++) pre[i] = pre[i - 1] + (str[i] == 'v');
	for (int i = n;i >= 1;i--) suf[i] = suf[i + 1] + (str[i] == 'n');
	for (int i = 1;i <= n;i++) ans += (str[i] == 'a') * pre[i - 1] * suf[i + 1];
	while (m--){
		int x;
		cin >> x;
		ans -= (str[x] == 'a') * pre[x - 1] * suf[x + 1];
		ans -= (str[x + 1] == 'a') * pre[x] * suf[x + 2];
		swap(str[x], str[x + 1]);
		pre[x] = pre[x - 1] + (str[x] == 'v');
		pre[x + 1] = pre[x] + (str[x + 1] == 'v');
		suf[x + 1] = suf[x + 2] + (str[x + 1] == 'n');
		suf[x] = suf[x + 1] + (str[x] == 'n');
		ans += (str[x] == 'a') * pre[x - 1] * suf[x + 1];
		ans += (str[x + 1] == 'a') * pre[x] * suf[x + 2];
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：HsNu1ly7_ (赞：0)

## 思路

看到这种题目，首先可以想到通过找到 $s_i$ 为 $\texttt{a}$ 的所有下标，然后将该位置左侧 $\texttt{v}$ 的个数（记为 $pre_i$）乘以该位置右侧 $\texttt{n}$ 的个数（记为 $nxt_i$）。

累加起来，就是整个字符串子序列 $\texttt{van}$ 的数量，并记为 $res$。

对于每次交换操作，先将 $res$ 减去下标 $x$ 和下标 $x + 1$ 的贡献，即：

$$
[s_x = \texttt{a}] \times pre_x \times nxt_{x} + [s_{x +1} = \texttt{a}] \times pre_{x+1} \times nxt_{x + 1} 
$$

接着交换 $s_x$ 和 $s_{x+1}$，然后按照预处理 $pre$ 数组和 $nxt$ 数组的方法修改 $pre_x$ 和 $nxt_{x+1}$。

具体实现看代码。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep( i , l , r ) for (int i = (l) ; i <= (r) ; i++)
#define per( i , r , l ) for (int i = (r) ; i >= (l) ; i--)
const int N = 1e6 + 10 ;
int n , m ;
int pre[N] , nxt[N] ;
string s ;
void solve (){
    cin >> n >> m ;
    cin >> s ;
    s = ' ' + s ;
    rep (i , 1 , n){
        pre[i] = pre[i - 1] + (s[i] == 'v') ;
    }
    per (i , n , 1){
        nxt[i] = nxt[i + 1] + (s[i] == 'n') ;
    }
    int res = 0 ;
    rep (i , 1 , n){
        if (s[i] == 'a'){
            res += pre[i] * nxt[i] ;
        }
    }
    while (m--){
        int x ;
        cin >> x ;
        if (s[x] == 'a'){
            res -= pre[x] * nxt[x] ;
        }
        if (s[x + 1] == 'a'){
            res -= pre[x + 1] * nxt[x + 1] ;
        }
        swap (s[x] , s[x + 1]) ;
        pre[x] = pre[x - 1] + (s[x] == 'v') ;
        int tmp = 0 ;
        if (x + 2 <= n) tmp = nxt[x + 2] ;
        if (s[x + 1] == 'n') ++tmp ;
        nxt[x + 1] = tmp ;
        if (s[x] == 'a'){
            res += pre[x] * nxt[x] ;
        }
        if (s[x + 1] == 'a'){
            res += pre[x + 1] * nxt[x + 1] ;
        }
        cout << res << '\n' ;
    }
}


signed main (){
	int _ = 1 ;
	//cin >> _ ;
	while ( _-- ){solve () ;}
	return 0 ;
}
```

---

## 作者：yanmingqian (赞：0)

先想暴力。

我们每次暴力交换，每次暴力统计答案。

答案统计：

```cpp
s=" "+s;
for(int i=1;i<=n;i++){
  t1[i]=t1[i-1]+(s[i]=='v');
} 
for(int i=n;i>=1;i--){
  t2[i]=t2[i+1]+(s[i]=='n');
}
long long ans=0;
for(int i=1;i<=n;i++){
    if(s[i]=='a'){
        ans+=t1[i]*t2[i];
    }
}
```

同[此题](https://www.luogu.com.cn/article/ubnum8g2)。

整个暴力：

```cpp
#include<iostream>
using namespace std;
long long t1[1000010],t2[1000010];
int main(){
    int n,m;
    string s;
    cin>>n>>m>>s;
    s=" "+s;
    while(m--){
        int x;
        cin>>x;
        swap(s[x],s[x+1]);
        for(int i=1;i<=n;i++){
            t1[i]=t1[i-1]+(s[i]=='v');
        } 
        for(int i=n;i>=1;i--){
            t2[i]=t2[i+1]+(s[i]=='n');
        }
        long long ans=0;
        for(int i=1;i<=n;i++){
            if(s[i]=='a'){
                ans+=t1[i]*t2[i];
            }
        }
        cout<<ans<<"\n";
    }
    return 0;
}
```

时间复杂度 $O(nm)$，不足以通过此题。

考虑优化。每次统计的答案与 `t1` 和 `t2` 有关，不难发现两个数组的变化位置只会在交换的位置。具体如下：

1. 如果交换的位置上的字符相同，显然没有任何变化。
2. 如果交换 $\texttt{a}$ 与另一个字符，交换后 $\texttt{a}$ 位置上有所变化，变化值为 $1$，要看交换的是什么样的。具体见代码。
3. 如果交换 $\texttt{v}$ 与 $\texttt{n}$，两个位置都要变，同加或者同减。

接下来考虑答案的变化。显然同样只与交换位置有关。具体见代码。

整体来说不难理解，细节部分举几个例子会方便调试。

```cpp
#include<iostream>
using namespace std;
long long t1[1000010],t2[1000010];
int main(){
    int n,m;
    string s;
    cin>>n>>m>>s;
	s=" "+s;
    for(int i=1;i<=n;i++){
    	t1[i]=t1[i-1]+(s[i]=='v');
    } 
    for(int i=n;i>=1;i--){
    	t2[i]=t2[i+1]+(s[i]=='n');
    }
    long long ans=0;
    for(int i=1;i<=n;i++){
        if(s[i]=='a'){
            ans+=t1[i]*t2[i];
        }
    }
    while(m--){
        int x;
        cin>>x;
        if(s[x]!=s[x+1]){
            if(s[x]=='n'&&s[x+1]=='a'){
                t2[x+1]++;
                ans+=t1[x];
            }
            else if(s[x]=='v'&&s[x+1]=='a'){
                t1[x]--;
                ans-=t2[x+1];
            }
            else if(s[x+1]=='v'&&s[x]=='a'){
                t1[x]++;
                ans+=t2[x+1];
            }
            else if(s[x+1]=='n'&&s[x]=='a'){
                t2[x+1]--;
                ans-=t1[x];
            }
            else if(s[x]=='v'&&s[x+1]=='n'){
                t1[x]--;t2[x+1]--;
            }
            else if(s[x]=='n'&&s[x+1]=='v'){
                t1[x]++;t2[x+1]++;
            }
        }
        swap(s[x],s[x+1]);
        cout<<ans<<"\n";
    }
    return 0;
}
```

---


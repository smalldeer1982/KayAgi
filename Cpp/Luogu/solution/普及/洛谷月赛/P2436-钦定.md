# 钦定

## 题目描述

小 S 拿到了复赛参赛表，表上的选手是由 $A$ 位神犇与 $B$ 位蒟蒻间隔、循环构成的。

比如 $A=2$，$B=3$ 时，选手 $1,2,6,7,11,12\dots$ 是神犇，选手 $3,4,5,8,9,10,13,14,15\dots$是蒟蒻。

现在小 S 钦定了一些选手是神犇，蒟蒻，但她不能构造出这样的 $A,B$，你能帮帮她吗？

## 说明/提示

对于 $10 \%$ 的数据，$1 \le N,M \le 10$。

对于 $30 \%$ 的数据，$1 \le N,M \le 100$。

对于 $100 \%$ 的数据，$1 \le N,M \le 1000$，$1 \le T \le 10$，$1 \le a_i,b_i \le 2 \times 10 ^ 5$。

## 样例 #1

### 输入

```
10 1
4 8 55 56 57 63 64 67 70 150
87```

### 输出

```
20 2```

# 题解

## 作者：lmrttx (赞：15)

前：本文对萌新很友好，~~因为题目难度较低~~。我感觉题目难度应该会更高。蒟蒻交了17次，除掉对着现有的唯一的题解打了一遍AC掉，剩下的都是自己写的。思路和目前唯一一篇题解一样。但是，我只有60分。不过我相信，这篇题解一定能帮助别人，自然也会具有一定的学习意义。

分割线-------------------------------------------------

正文从这里开始。

看到这种区间问题，可以想到与 % （模运算） 有关。

这是一个突破口。

我们需要**枚举周期**。题目有写，选手编号小于等于 $(n+m)*10$，所以，枚举要从2到这个数+1。

```cpp
	cnt=(n+m)*10+1;
	for(int i=2;i<=cnt;i++)
```


定义数组 $a$ 为神犇数列，$b$ 为蒟蒻（我）数列。我们还可以观察到，这两个数列中的数不连续，分散地分布在数轴上。

所以，我们用这里面的每一个数去模枚举的周期，模完后的值肯定有大有小。我们在 $a$ 数组中取最大值，在 $b$ 数组中取最小值。

```cpp
	answer1=0;answer2=INF;
	for(int j=1;j<=n;j++){
		c[j]=a[j]%i;
		if(c[j]==0)answer1=max(answer1,i);
		else answer1=max(answer1,c[j]);
	}
	for(int j=1;j<=m;j++){
		d[j]=b[j]%i;
		if(d[j]==0)answer2=min(answer2,i);
		else answer2=min(answer2,d[j]);
	}
```


用两个 $answer$ 记录好。

可以发现（比方说找规律，打表）：**最大值与最小值之和一定等于周期**。

蒟蒻有一个不严谨的证明，这边不贴了。~~还是我太差了~~。

根据这一个结论，就可以写出最后的代码部分了。

我的代码和题解基本一样，因为我是在那篇题解的启发下，才有了思路，理解了题目。

```cpp
	if(!t){
		puts("NO");printf("\n");
		continue;
	}
		sort(q+1,q+t+1,cmp);
		cout<<q[1].x<<" "<<q[1].y<<endl;
```

60分的完整代码：[CODE by lmrttx](https://www.luogu.com.cn/paste/rl1qd8iz)。

后：蒟蒻最近刚开始写题解，做贡献，涨咕值，自然会有许多不足。我也会虚心改进。我看到记录里许多人直接复制题解，我不认可这种行为，题目必须要有思考。希望这篇题解可以给你们做题的想法，**谢谢阅读**。

---

## 作者：Warriorszx (赞：10)

从小到大枚举周期，用A序列模周期，找模数最大，用B序列模周期，找模数最小，因为两个模数之和必等于周期，所以当两模数代表的各自周期不重合时，即为答案。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[10100],b[10100],cnt,tail,ans1,ans2,c[10100],d[10100];
struct node
{
    int x,y;
}q[501000];
bool cmp(node a,node b)
{
    if(a.x!=b.x)
    return a.x<b.x;
    return a.y<b.y;
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        tail=0;
        scanf("%d",&m);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);
        }
        for(int i=1;i<=m;i++)
        {
            scanf("%d",&b[i]);
        }
        cnt=(n+m)*10+1;
        for(int i=2;i<=cnt;i++)
        {
            ans1=0;		ans2=2010000000;
            for(int j=1;j<=n;j++)
            {
                c[j]=a[j]%i;
                if(c[j]==0)
                ans1=max(ans1,i);
                else
                ans1=max(c[j],ans1);
            }
            for(int j=1;j<=m;j++)
            {
                d[j]=b[j]%i;
                if(d[j]==0)
                ans2=min(ans2,i);
                else
                ans2=min(ans2,d[j]);
            }
            if(ans1<ans2)
            {
                q[++tail].x=ans1;
                q[tail].y=i-ans1;
            }
        }
        if(!tail)
        {
            printf("NO\n");
            continue;
        }
        sort(q+1,q+tail+1,cmp);
        printf("%d %d\n",q[1].x,q[1].y);
    }
    return 0;
} 
```

---

## 作者：wang6w6 (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P2436)

一个关于模数的题。

### 注意是多组数据。

我们可以先搜索各个周期，周期的范围在原题中是 $( n + m ) \times 10$ 又因为神犇和蒟蒻至少会各有一个，所以我们要从 $2$ 开始循环，让每个神犇和蒟蒻取模当前周期，看余数来求神犇的最大值和蒟蒻的最小值。

```cpp
		for(ll i=2;i<=(n+m)*10+1;i++){//循环周期 
			A=0;B=MA;
			for(ll j=1;j<=n;j++){
				ra[j]=a[j]%i;
				if(ra[j]==0){
					A=max(A,i);//模数为0时，答案应是当前周期 
				}else{
					A=max(A,ra[j]);//模数不为0，答案只能是模数 
				}
			}
			for(ll j=1;j<=m;j++){
				rb[j]=b[j]%i;
				if(rb[j]==0){//同A
					B=min(B,i);
				}else{
					B=min(B,rb[j]);
				}
			}
			if(A<B){
				len++;
				ans[len].A=A;
				ans[len].B=i-A;//除A以外的周期就是B了 
			}
		}
```

这样我们就能得到不同情况的答案，最终用 sort 排序一下找**最小**的答案输出即可。

代码~~来也~~如下。
```
#include<bits/stdc++.h>//qwq
using namespace std;
#define ll long long
const int N=1e6+5;
const int MA=1e6+5;
ll n,m,a[N],b[N],ra[N],rb[N],A,B;
ll len;
struct stu{
	ll A,B;
}ans[N];
bool cmp(stu a,stu b){
	if(a.A==b.A) return a.B<b.B;
	return a.A<b.A;//排序找最大，要在A最小的情况下找最小的B。 
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);//好东西
	while(cin>>n>>m){
		len=0;
		for(ll i=1;i<=n;i++){
			cin>>a[i];
		}
		for(ll i=1;i<=m;i++){
			cin>>b[i];
		}
		for(ll i=2;i<=(n+m)*10+1;i++){//循环周期 
			A=0;B=MA;
			for(ll j=1;j<=n;j++){
				ra[j]=a[j]%i;
				if(ra[j]==0){
					A=max(A,i);//模数为0时，答案应是当前周期 
				}else{
					A=max(A,ra[j]);//模数不为0，答案只能是模数 
				}
			}
			for(ll j=1;j<=m;j++){
				rb[j]=b[j]%i;
				if(rb[j]==0){//同A
					B=min(B,i);
				}else{
					B=min(B,rb[j]);
				}
			}
			if(A<B){
				len++;
				ans[len].A=A;
				ans[len].B=i-A;//除A以外的周期就是B了 
			}
		}
		if(len==0) cout<<"NO\n";//没有 ans 
		else{
			sort(ans+1,ans+1+len,cmp);//排最小的ans 
			cout<<ans[1].A<<" "<<ans[1].B<<"\n";
		}
	}
	
	return 0;
}
```
祝各位元旦快乐，也祝我元旦表演顺利。

---

## 作者：superLouis (赞：3)

## 题解：P2436 钦定
纯暴力就能过的水题。

----------
### 1. 解题思路
一眼望过去，不就是取模的运算吗？我们可以枚举循环的周期 $k$，然后去计算神犇中对 $k$ 取模中最大的，计算蒟蒻中对 $k$ 取模最小的。这里为了方便，我们把取模的余数设定为 $1$ 至 $k$。

令神犇中对 $k$ 取模中最大的为 $p$，蒟蒻中对 $k$ 取模最小的为 $q$，则需要判断 $p$ 与 $q$ 的关系是否符合条件，及判断 $p$ 是否小于 $q$。如果搜到了一个符合要求的 $p$ 和 $q$，我们为了满足循环的周期为 $k$，再把 $q$ 设置成 $k-p$。最后我们再枚举循环周期时发现一个可以的 $p$ 和 $q$ 就与一个 `pair<int, int>` 类型的答案去最小值即可。

可以用 `pair<int, int>` 是因为这个类型重载的小于号是先比较 `first`，再比较 `second`，刚好符合题目的要求。

----------
### 2. 代码实现
就知道你们想要这个，专门删掉了注释。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 1010;
constexpr int inf = 0x7fffffff;
int n, m, a[maxn], b[maxn];
signed main(signed argc, char* argv[]) {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    while (cin >> n >> m) {
    	pair<int, int> ans = {inf, inf};
    	for (int i = 1; i <= n; i++) cin >> a[i];
    	for (int i = 1; i <= m; i++) cin >> b[i];
    	int x = inf, y = inf;
    	bool flg = false;
    	for (int i = 1; i <= (n + m) * 10; i++) {
    		int xx = -inf, yy = inf;
    		for (int j = 1; j <= n; j++) xx = max(xx, a[j] % i ? a[j] % i : i);
    		for (int j = 1; j <= m; j++) yy = min(yy, b[j] % i ? b[j] % i : i);
    		if (xx >= yy) continue;
    		flg = true;
    		yy = i - xx;
    		ans = min(ans, {xx, yy});
		}
		if (!flg) cout << "NO\n";
		else cout << ans.first << " " << ans.second << "\n";
	}
    return 0;
}
```

在题解的最后，提前祝大家新年快乐！

---

## 作者：xianxi (赞：2)

# 思路
题目上说有 $A$ 个神犇与 $B$ 个蒟蒻连续并组成循环，由此我们可以考虑用模解决。

假设我们已知周期 $A+B$ 为 $x$，那么我们用神犇序列的每一个数 $a$ 对 $x$ 取模，取一个最大值，（你问为什么是最大）原因是找到一个最靠前的钦定的神犇 $a$ ，则他是 $A$ 区间的最早结束点，目的是（根据题意）找到一个最小的 $A$ 使得每一个钦定的 $a$ 都在 $A$ 周期的区间内。

用同样手段得到一个最小的 $B$，（你问为什么是最小）原因是 $B$ 区间一定在 $A$ 区间之后，找到一个最靠前的钦定的蒟蒻 $b$ ，则他是 $B$ 区间的最早开始点，若这个最早开始点比 $A$ 区间的最早结束点还要早，那么是不存在合法的 $A$ 与 $B$ 满足 $A+B$ 的值为 $x$。

# 实现
我们可以先循环搜索枚举周期，周期的范围在原题中是 $(n+m) \times 10$ 又因为神犇和蒟蒻至少会各有一个，所以我们要从 $2$ 开始循环，按上述思路记录所有合法答案后，对所有合法答案进行排序，使得 $A$ 最小的情况下 $B$ 最小，若没有合法答案，输出 `NO`。

# 细节
取模时，当模值为零时，实际上他是在区间的最后，即实际值为区间的长度。

有多组数据，记得初始化。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,T,cnt,a[1005],b[1005],ma[1005],mb[1005];
struct node{
	int A,B;
}ans[1005];
int check(int s,int t)
{
	if(s%t==0)return t;
	else return s%t;
}
bool cmp(node xx,node yy)
{
	if(xx.A==yy.A)return xx.B<yy.B;
	else return xx.A<yy.A;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	while(cin>>n>>m)
	{
		for(int i=1;i<=n;++i)cin>>a[i];
		for(int i=1;i<=m;++i)cin>>b[i];
		for(int i=2;i<=(n+m)*10+1;++i)
		{
			int x=0,y=INT_MAX;
			for(int j=1;j<=n;++j)
			{
				x=max(x,check(a[j],i));
			}
			for(int j=1;j<=m;++j)
			{
				y=min(y,check(b[j],i));
			}
			if(x<y)
			{
				cnt++;
				ans[cnt].A=x;
				ans[cnt].B=i-x;
			}
		}
		if(cnt==0)cout<<"NO"<<"\n";
		else
		{
			sort(ans+1,ans+1+cnt,cmp);
			cout<<ans[1].A<<" "<<ans[1].B<<"\n";
		}
		cnt=0;
	}
	return 0;
 } 
```
最后，感谢您的留步与观看。

---

## 作者：wth2026 (赞：2)

# 题目思路

先理解题意，发现关键点在于在一个循环内，神犇在前，蒟蒻在后。所以我们可以先枚举循环长度为 $i$，求得给定的神犇在循环中位置最靠后的神犇在循环的什么地方（记为 $mx$），再求得给定的蒟蒻在循环中位置最靠前的蒟蒻在循环的什么地方（记为 $mn$）。然后判断一下，看是不是最后的神犇在最前的蒟蒻的前面。如果是，那么这个循环长度就是合法的，然后根据位置输出即可（只需要令 $A \geq mx$ 且 $A + B = i$ 即可）。

# AC Code

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1000 + 5;

int n, m;
int a[N], b[N];
int _Mx, _Mn;
bool _Flg;

signed main () {
	ios :: sync_with_stdio (false);
	cin.tie (0);
	cout.tie (0);
	
	while (cin >> n >> m) {
		_Flg = 1;
		
		for (register int i = 1; i <= n; ++ i) {
			cin >> a[i];
		}
		
		for (register int i = 1; i <= m; ++ i) {
			cin >> b[i];
		}
		
		for (register int i = 1; i <= ((n + m) << 4); ++ i) {
			_Mx = -1;
			_Mn = i + 1;
			
			for (register int j = 1; j <= n; ++ j) {
				_Mx = max (_Mx, (a[j] - 1) % i + 1);
			}
			
			for (register int j = 1; j <= m; ++ j) {
				_Mn = min (_Mn, (b[j] - 1) % i + 1);
			}
			
			if (_Mn > _Mx) {
				cout << _Mx << ' ' << i - _Mx << endl;
				_Flg = 0;
				break ;
			}
		}
		
		if (_Flg) {
			cout << "NO" << endl;
		}
	}
	
	return 0;
}
```

---

## 作者：nightwatch.ryan (赞：1)

### 思路
从小到大去枚举周期，然后一个一个找。用 $A$ 序列对 $cnt$ 取模，找模数最大。用 $B$ 序列对 $cnt$ 取模，找模数最小。最大值与最小值之和一定等于周期，知道了这个以后，就可以完成代码了。
### 代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <climits>
#include <cmath>
#include <iomanip>
#include <cstdio>
#define N 100005
int read()
{
    char c = getchar();
    int x = 0, f = 1;
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
        x = x * 10 + c - '0', c = getchar();
    return x * f;
}
void write(int x)
{
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
    return;
}
int a[N], b[N], c[N], d[N], n, m, res1, res2, tail, cnt;
struct Node
{
    int x, y;
    bool operator<(const Node &n) const
    {
        if (n.x != x)
            return x < n.x;
        return y < n.y;
    }
} q[500005];
int main()
{
    while (scanf("%d", &n) != EOF)
    {
        m = read();
        for (int i = 1; i <= n; i++)
            a[i] = read();
        for (int i = 1; i <= m; i++)
            b[i] = read();
        tail = 0, cnt = (n + m) * 10 + 1;
        for (int i = 2; i <= cnt; i++)
        {
            res1 = 0, res2 = INT_MAX;
            for (int j = 1; j <= n; j++)
            {
                c[j] = a[j] % i;
                if (c[j] == 0)
                    res1 = std::max(res1, i);
                else
                    res1 = std::max(c[j], res1);
            }
            for (int j = 1; j <= m; j++)
            {
                d[j] = b[j] % i;
                if (d[j] == 0)
                    res2 = std::min(res2, i);
                else
                    res2 = std::min(res2, d[j]);
            }
            if (res1 < res2)
            {
                tail++, q[tail].x = res1;
                q[tail].y = i - res1;
            }
        }
        if (!tail)
        {
            std::cout << "NO\n";
            continue;
        }
        std::sort(q + 1, q + 1 + tail);
        std::cout << q[1].x << ' ' << q[1].y << '\n';
    }
}
```

---

## 作者：__Immorta__ (赞：0)

**前言：**

冲题解！ 

**题目大意：**

小 S 拿到了复赛参赛表，表上的选手是由 $A$ 位神犇与 $B$ 位蒟蒻间隔、循环构成的。

比如 $A=2$，$B=3$ 时，选手 $1,2,6,7,11,12\dots$ 是神犇，选手 $3,4,5,8,9,10,13,14,15\dots$是蒟蒻。

现在小 S 钦定了一些选手是神犇，蒟蒻，但她不能构造出这样的 $A,B$，你能帮帮她吗？

----

输入格式： 

每个测试点多组数据。

每组数据第一行两个整数 $N,M$。

第二行为 N 名选手编号 $a_1,a_2,\dots,a_N$。即小 S 把他们钦定为神犇。

第三行为 M 名选手编号 $b_1,b_2,\dots,b_M$。即小 S 把他们钦定为蒟蒻。

----

输出格式： 

对于每组数据，输出满足题意的两个整数 $A,B$（用空格隔开），并且使得 $A$ 最小的情况下 $B$ 最小。 如果没有符合条件的 $A,B$，请输出 `NO`。

----

**详细分析：**

选手编号规律：

- 神犇的编号是 $1, A+1, 2A+1, 3A+1, \ldots$
- 蒟蒻的编号是 $A+2, 2A+3, 3A+4, \ldots$

确定 $A$ 和 $B$：

- 我们需要找到最小的 $A$ 和 $B$，使得所有的神犇编号都符合神犇的规律，所有的蒟蒻编号都符合蒟蒻的规律。

规律检验：

- 对于每个神犇编号 $a_i$，我们需要检查是否存在整数 $k$ 使得 $a_i = kA + 1$。
- 对于每个蒟蒻编号 $b_i$，我们需要检查是否存在整数 $k$ 使得 $b_i = kA + (A+2)$ 或者 $b_i = kA + (A+3)$ 或者 $b_i = kA + (A+4)$，等等，直到 $b_i = kA + (A+B+1)$。

**解题步骤：**

排序：

- 将神犇和蒟蒻的编号分别排序。

遍历 $A$：

- 从 $1$ 开始遍历 $A$，直到找到一个合适的 $A$。
- 对于每个 $A$，检查所有神犇编号是否符合 $a_i = kA + 1$ 的规律。
- 如果所有神犇编号都符合，继续检查蒟蒻编号。

检查蒟蒻编号：

- 对于每个 $A$，检查所有蒟蒻编号是否符合 $b_i = kA + (A+2)$ 到 $b_i = kA + (A+B+1)$ 的规律。
- 确定 $B$ 的值，使得所有蒟蒻编号都符合规律。

输出结果：

- 如果找到了合适的 $A$ 和 $B$，输出它们。
- 如果遍历完所有可能的 $A$ 都没有找到合适的 $A$ 和 $B$，输出 `NO`。

----

完结撒花★,°:.☆(￣▽￣)/$.°★。

---

## 作者：MaiJingYao666 (赞：0)

# P2436 钦定 题解 
算需要思考的一道黄题。 

### 解题思路 
首先注意多测，然后接来看一下下面的。  
看一下样例，其周期和为 $20+2=22$，将样例展开：

|模数|$1$|$2$|$3$|$4$|$5$|$6$|$7$|$8$|$9$|$10$|$11$|$12$|$13$|$14$|$15$|$16$|$17$|$18$|$19$|$20$|$21$|$0(22)$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$a$|$67$|||$4,70$||||$8$|||$55$|$56$|$57$|||||$150$|$63$|$64$|||
|$b$|||||||||||||||||||||$87$||

可以发现条件成立时当且仅当 $\max(a_i \bmod d)) < \max(b_i \bmod d))$，其中 $d$ 为数列周期。 

剩下的就简单了，枚举每一个，再计算上面的，判断，最后选出最大的那个即可。

### AC 代码  

```cpp
#include<iostream>
using namespace std;
const int N=200005;
const int MAXN=1e9;
int n,m;
int a[N],b[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	while(cin>>n>>m){
		int mina=MAXN,minb=MAXN;
		for(register int i=1;i<=n;i++) cin>>a[i];
		for(register int i=1;i<=m;i++) cin>>b[i];
		for(register int i=1;i<=(n+m)*10+1;i++){
			int man=0,mim=MAXN;
			for(int j=1;j<=n||j<=m;j++){
				if(j<=n){
					man=max(man,a[j]%i==0?i:a[j]%i);
				}
				if(j<=m){
					mim=min(mim,b[j]%i==0?i:b[j]%i);
				}
			}
			if(man<mim){
				if(man<mina){
					mina=man;
					minb=i-man;
				}
				if(man==mina && i-man<minb)minb=i-man;
			}
		}
		if(mina==MAXN && minb==MAXN)cout<<"NO\n";
		else cout<<mina<<" "<<minb<<'\n';
	}
}
```

---

## 作者：tanzexiaodezhonghao (赞：0)

## 思路
容易想到和取模有关。

可以枚举各个区间。范围是 $10(n+m)$ 神犇和蒟蒻各一个，所以从 $2$ 开始。另外，如果一个区间内，神犇最晚出现位置大于等于蒟蒻的最早出现位置，就意味着有重叠，不符合要求。我们可以把神犇的区间长度设为 $id$，蒟蒻区间就是 $10(n+m)-id$，然后取模，求出神犇的最大值和蒟蒻的最小值即可。

---

## 作者：furina_yyds (赞：0)

勉强够黄题的难度。

## 思路

这道题有周期，需要使用模。

可以发现，当答案合法时，必然满足 $\max (a_i \bmod d) < \max (b_i \bmod d)$。

枚举答案，判断是否合法，即可。

## 注意

多测不清空，爆零两行泪。

## 代码

```cpp
#include <iostream>
#include <vector>
#include <limits>
#include <algorithm>

// 函数：计算数组元素对除数取模的最大余数
int maxRemainder(const std::vector<int>& arr, int divisor) {
    int maxRem = 0;
    for (const auto& element : arr) {
        int rem = element % divisor;
        if (rem == 0) {
            rem = divisor;
        }
        maxRem = std::max(maxRem, rem);
    }
    return maxRem;
}

// 函数：计算数组元素对除数取模的最小余数
int minRemainder(const std::vector<int>& arr, int divisor) {
    int minRem = std::numeric_limits<int>::max();
    for (const auto& element : arr) {
        int rem = element % divisor;
        if (rem == 0) {
            rem = divisor;
        }
        minRem = std::min(minRem, rem);
    }
    return minRem;
}


int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    while (true) {
        int n, m;
        std::cin >> n >> m;
        if (std::cin.fail()) {
            break;  // 当输入不合法时终止循环
        }
        std::vector<int> a(n);
        std::vector<int> b(m);

        for (int i = 0; i < n; ++i) {
            std::cin >> a[i];
        }
        for (int i = 0; i < m; ++i) {
            std::cin >> b[i];
        }

        int mina = std::numeric_limits<int>::max();
        int minb = std::numeric_limits<int>::max();

        for (int i = 1; i <= (n + m) * 10 + 1; ++i) {
            int man = maxRemainder(a, i);
            int mim = minRemainder(b, i);

            if (man < mim) {
                if (man < mina) {
                    mina = man;
                    minb = i - man;
                } else if (man == mina && i - man < minb) {
                    minb = i - man;
                }
            }
        }

        if (mina == std::numeric_limits<int>::max() && minb == std::numeric_limits<int>::max()) {
            std::cout << "NO\n";
        } else {
            std::cout << mina << " " << minb << '\n';
        }
    }
    return 0;
}
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2436)
## 思路
枚举循环周期 $k$ ，得到一个循环周期中给定神犇的最晚出现位置 $i$ 和给定蒟蒻的最早出现位置 $j$，显然，如果 $j\le i$，那么含神犇区间与含蒟蒻区间就有重叠，不符合要求。否则神犇区间长度为 $i$，蒟蒻区间长度为 $k-i$，用它们来更新答案即可。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1145],b[1145];
int mod,ans1,ans2,now1,now2;
bool fl;
int main() {
	while(cin>>n>>m) {//注意本题多测
		for(int i=1;i<=n;i++)cin>>a[i];
		for(int i=1;i<=m;i++)cin>>b[i];
		ans1=ans2=1145141919;
		fl=false;
		for(int i=1;i<=(n+m)*10;i++) {//枚举区间长度
			now1=0,now2=1145141919;
			for(int j=1;j<=n;j++) {//求神犇最晚出现位置
				if(a[j]%i) now1=max(now1,a[j]%i);
				else now1=max(now1,i);
			}
			for(int j=1;j<=m;j++) {//求蒟蒻最早出现位置
				if(b[j]%i) now2=min(now2,b[j]%i);
				else now2=min(now2,i);
			}
			if(now2<=now1) continue;//不符合要求
			fl=true;//标记有解
			now2=i-now1;
			if(now1==ans1) {//更新答案
				if(now2<ans2) ans1=now1,ans2=now2;
			} else {
				if(now1<ans1) ans1=now1,ans2=now2;
			}
		}
		if(fl) cout<<ans1<<" "<<ans2<<endl;
		else cout<<-1<<endl;
	}
}
```

---

## 作者：GCSG01 (赞：0)

既然这道题要求出可行的周期，我们就枚举有可能成为答案的区间。因为选手编号小于 $(n+m) \times 10$，所以我们枚举从 $2$ 到 $(n+m) \times 10$ 的区间，并更新答案。

代码：
```cpp
//noipwen AK IOI and NOI
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int a[N],b[N];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int n,m;
	while((cin>>n>>m)){
		for (int i=1;i<=n;i++)cin>>a[i];
		for (int i=1;i<=m;i++)cin>>b[i];
		int ans1=INT_MAX,ans2=INT_MAX,flag=false;
		for (int i=2;i<=(n+m)*10;i++)//枚举周期 
		{
			int sum1=0,sum2=INT_MAX;
			for(int j=1;j<=n;j++)
			{
				if(a[j]%i)sum1=max(sum1,a[j]%i);
				else sum1=max(sum1,i);//%完之后为0应该是i 
			}
			for(int j=1;j<=m;j++)
			{
				if(b[j]%i)sum2=min(sum2,b[j]%i);
				else sum2=min(sum2,i);
			}
			if(sum1>=sum2)continue;
			flag=true;
			sum2=i-sum1;//a,b的周期 
			if(ans1!=sum1){
				if(ans1>sum1)ans1=sum1,ans2=sum2;
			}
			else{
				if(ans2>sum2)ans1=sum1,ans2=sum2;
			}//更新答案 
		}
		if(flag)cout<<ans1<<" "<<ans2<<endl;
		else cout<<"NO"<<endl;
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

~~这题害人不浅呐！！！~~

注意看题目描述：**每个测试点多组数据。**

~~这让我整整调了一个多小时！！！~~

这题思路挺简单的，不难看出 $A$ 位神犇与 $B$ 位蒟蒻加起来就是一个循环。接下来就可以用到小学时候学的余数，这个余数就是它在其中一个循环节对应的位置。

**注意：余数为 $0$ 时当前的位置应是 $A + B$ 的值。**

然后我们就可以枚举 $A + B$ 的和，然后先把 $A$ 位神犇在数列中的位置求出，再求 $B$ 位蒟蒻的。如果 $B$ 位蒟蒻的位置在 $A$ 位神犇在数列中的位置的最大值的前面，那么就跳过。

```cpp
A + B = 10

神犇:1 1 0 0 1 1 0 0 0 0
蒟蒻:0 0 1 0 0 0 1 0 1 1
```
可以发现神犇最大的位置在 $6$，而蒟蒻的最小位置在 $3$，所以此值不成立。

**Code**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define R register
#define re ra()
const int N = 1e6 + 100;
int n, m, a[N], b[N], o, p, t, l;

struct setyid {
	int x, y;
} kp[N];
inline int ra()
{
    int jjy = 0,txy = 1;
    char ch = getchar();
    while(!isdigit(ch)){if(ch == '-') txy = -1; ch = getchar(); }
    while(isdigit(ch)){jjy = jjy * 10 + ch - '0'; ch = getchar(); }

    return jjy * txy;
}

inline bool check(int k)
{
	int maxn = -1;
	for(R int i = 1; i <= n; i ++) maxn = max(maxn, (a[i] % k == 0 ? k : a[i] % k));
	for(R int i = 1; i <= m; i ++)
	if(b[i] % k <= maxn && b[i] % k != 0 || b[i] % k == 0 && maxn == k) return false;
	p = maxn;
	return true;
}

inline bool cmp(setyid x, setyid y)
{
	return x.x < y.x || (x.x == y.x && x.y < y.y);
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n = re, m = re;
	for(R int i = 1; i <= n; i ++) a[i] = re;
	for(R int i = 1; i <= m; i ++) b[i] = re;
	for(R int i = 2; i <= n * 10 + m * 10 + 2; i ++)
	{
		p = 0;
		if(check(i))
		{
			kp[++ t] = (setyid) {p, i - p}; 
			l = 1;
		}
	}
	sort(kp + 1, kp + 1 + t, cmp);
	if(!l) cout << "NO";
	else
	cout << kp[1].x << ' ' << kp[1].y;
	return 0;
}
```
~~实在不会私信我。~~

---

## 作者：Rednoon (赞：0)

这题挺简单的，只需要枚举周期，然后去排去找，最后判断出答案。
```
#include<bits/stdc++.h>//万能的万能头。 
using namespace std;
int n,m,a[101010],b[101010],c[101010],d[101010],e,f,g,h;//定义变量。 
struct sb{//结构体 
   int x,y;
}q[101010];
bool cmp(sb a,sb b)//sort函数，用来排序。 
{
    if(a.x!=b.x)
    return a.x<b.x;
    return a.y<b.y;
}
int main()
{
    while(scanf("%d",&n)!=EOF)//while循环。 
    {
        f=0;
        scanf("%d",&m);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);//输入。
        }
        for(int i=1;i<=m;i++)
        {
            scanf("%d",&b[i]);//输入。
        }
        e=(n+m)*10+1;
        for(int i=2;i<=e;i++)
        {
            int g=0,h=101010;//重置变量g,给h值P.S,h的值一定要大于五位数，（我血的教训.... 
            for(int j=1;j<=n;j++)
            {
                c[j]=a[j]%i;
                if(c[j]==0)
                {
                g=max(g,i);	
				}
                else
                {
                	g=max(c[j],g);
				}
            }
            for(int j=1;j<=m;j++)
            {
                d[j]=b[j]%i;
                if(d[j]==0)
                {
                	h=min(h,i);
				}
                else
                {
                	h=min(h,d[j]);
				}
            }
            if(g<h)
            {
                q[++f].x=g;
                q[f].y=i-g;
            }
        }
        if(!f)//如果不是，输出NO。 
        {
            cout<<"NO"<<"\n";//"\n"跳下一行（当年天真的我用了endl，结果超时了........ 
            continue;
        }
        sort(q+1,q+f+1,cmp);//排序。 
        
        cout<<q[1].x<<" "<<q[1].y<<"\n";//用这个也是可以的printf("%d %d\n",q[1].x,q[1].y);本人测试过了 
    }
	return 0;//结束。P.S,return 0不能放在循环里，不然......又是血的教训........
} 
```


---


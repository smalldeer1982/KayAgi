# 丝绸之路

## 题目背景

张骞于公元前 138 年曾历尽艰险出使过西域。加强了汉朝与西域各国的友好往来。从那以后，一队队骆驼商队在这漫长的商贸大道上行进，他们越过崇山峻岭，将中国的先进技术带向中亚、西亚和欧洲，将那里的香料、良马传进了我国。每当人们凝望荒凉的大漠孤烟，无不引起对往日商贸、文化繁荣的遐想……


## 题目描述

小仓鼠带着货物，从中国送到安息，丝绸之路包括起点和终点一共有 $N+1$ 个城市，$0$ 号城市是起点长安，$N$ 号城市是终点巴格达。要求不超过 $M$ 天内必须到达终点。一天的时间可以从一个城市到连续的下一个城市。从 $i-1$ 城市到 $i$ 城市距离是 $D_i$。

大家都知道，连续赶路是很辛苦的，所以小仓鼠可以在一个城市时，可以有以下选择：

- 移动：向下一个城市进发

- 休息：呆在原来的城市不动

沙漠天气变化无常，在天气很不好时，前进会遇到很多困难。我们把 $M$ 天的第 $j(1<=j<=M)$ 天的气候恶劣值记为 $C_j$。从 $i-1$ 城市移动到 $i$ 城市在第 $j$ 天进发时，需要耗费 $D_i\times C_j$ 的疲劳度。

不过小仓鼠还是有选择权的，可以避开比较恶劣的天气，休息是不会消耗疲劳值的。现在他想知道整个行程最少要消耗多少疲劳值。


## 说明/提示

### 样例解释

第 $1$ 天休息。

第 $2$ 天 $0\rightarrow 1$ 疲劳值 $10 × 30 = 300$。

第 $3$ 天 $1\rightarrow2$ 疲劳值 $25 × 15 = 375$。

第 $4$ 天休息。

第 $5$ 天 $2\rightarrow3$ 疲劳值 $15 × 30 = 450$。

### 数据范围

$1 ≦ N ≦ M ≦ 1000$。

$1 ≦ D_i , C_i ≦ 1000$。


## 样例 #1

### 输入

```
3 5
10
25
15
50
30
15
40
30```

### 输出

```
1125```

# 题解

## 作者：wzxx (赞：47)

#### 动态规划（两个版本）


------------


先分析一下题目。

1. 所有城市连起来是一条链。

1. 每一天有走和不走两种选择。


仅凭这两点，我们就很容易想到dp的思路。我写了两个版本，一个是龟速版，总用时2000多ms；一个是飞速版，总用时8ms......


------------



先说说龟速的把。设状态f[i][j]表示第j天 **到达** 第i个城市的最小疲劳值，也就是说这一天你必须是刚好从前一个城市走到这里来的。状态转移方程就很容易推出来了，就是找上一个城市在i-1..j-1天里哪天到达的疲劳值最小，然后再加上这一天从上一个城市到达这一个城市的疲劳值。为什么是i-1..j-1而不是1..j-1呢？因为第i-1个城市最早只能在第i-1天到达，继续找前面的完全就没有必要。想一想，第3个城市能在第2天到达吗？当然不行。

上述文字用公式表达就是这个样子：


    f[i][j]=min{f[i-1][i-1..j-1]}+D[i]\*C[j]

为什么这个公式就可以成立呢？因为你找到了哪一天到达上一个城市的疲劳值最小，你就可以不停地休息（休息是不会增加疲劳值的），一直休息到第j天，再走过来，这样就是最优的了。

代码：


```cpp
    #include<iostream>
    #include<cstdio>
    #include<fstream>
    #include<algorithm>
    #include<string>
    #include<sstream>
    #include<cstring>
        using namespace std;
        const int INF=2139063143;
        int D[1002],C[1002],f[1002][1002];
    int main()
    {
        memset(f,0x7f,sizeof(f));
        int N=0,M=0;
        scanf("%d%d",&N,&M);
        for(int i=1;i<=N;i++) scanf("%d",&D[i]);
        for(int i=1;i<=M;i++) 
        {
            scanf("%d",&C[i]);
            f[1][i]=D[1]*C[i];//初始化第一个城市的
        }
        for(int i=2;i<=N;i++)
            for(int j=i;j<=M;j++)
            {
                int Min=INF;
                //找最小
                for(int k=j-1;k>=i-1;k--) Min=min(Min,f[i-1][k]);
                f[i][j]=Min+D[i]*C[j];//更新
            }
        int ans=INF;
        for(int i=N;i<=M;i++) ans=min(ans,f[N][i]);
        printf("%d",ans); 
        return 0;
    }
```
------------

接着再说一下快速的吧。设状态f[i][j]表示第j天 **位于** 第i个城市的最小疲劳值，也就是说这一天你可以不是刚好从前一个城市走到这里来的，也可以是前几天已经到了，休息到今天的。再看题目，对于每一天都有走和不走两种选择，状态转移方程就出来了。对于在第i个城市的第j天，你可以在j-1天从上一个城市走过来（第1种选择），也可以休息不走（第2种选择）。这里和龟速版的意思一样，也是看一看从上一个城市的哪一天走过来最优，只不过可以休息。

上述文字用公式表达就是这样子：


    f[i][j]=min{f[i][j-1],f[i-1][j-1]+D[i]\*C[j]}

其中f[i][j-1]是休息，f[i-1][j-1]+D[i]\*C[j]是走。

代码：


```cpp
    #include<iostream>
    #include<cstdio>
    #include<fstream>
    #include<algorithm>
    #include<string>
    #include<sstream>
    #include<cstring>
        using namespace std;
        const int INF=2139063143;
        int D[1002],C[1002],f[1002][1002];
    int main()
    {
        int N=0,M=0;
        scanf("%d%d",&N,&M);
        for(int i=1;i<=N;i++) scanf("%d",&D[i]);
        for(int i=1;i<=M;i++) scanf("%d",&C[i]); 
        memset(f,0x7f,sizeof(f));
        for(int i=0;i<=M;i++) f[0][i]=0;
        for(int i=1;i<=N;i++)
            for(int j=i;j<=M;j++)
                f[i][j]=min(f[i][j-1],f[i-1][j-1]+D[i]*C[j]);
        int ans=INF;
        for(int i=N;i<=M;i++) ans=min(ans,f[N][i]);
        printf("%d",ans); 
        return 0;
    }
```
------------

两种方案，个人感觉第一种好理解一点，但速度真的超级慢啊，大家自行取舍吧。


---

## 作者：ghj1222 (赞：9)

洛谷10月月赛round.1

这是一道dp，有点水，但是对我这种pj组选手不水2333。

//有个地方写错了，求管理更正

f(i,j)表示当前走到第i个城市，第j+1天的时候的疲劳值。

状态转移方程：

f(i,j)=min{f(i,j-1),f(i-1,j-1)+d[i]\*c[j]};

min中第一种情况f(i,j-1)是从在这个城市过夜，等于这个城市上一天的疲劳值。

第二种情况f(i-1,j-1)+d[i]\*c[j]则代表了今天刚从上一个城市走过来，那么就等于昨天上一个城市的疲劳值加上从上一个城市走过来积累的疲劳值。为啥是c[j]呢？因为当前是第j+1天，昨天走过来的啊！

由于我们用的是min，所以dp数组要初始化成0x3f3f3f3f(INF)，dp[0][j]要等于0，因为在第0个城市呆多少天都不会积累疲劳值。下面是程序

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int n,m,d[1001],c[1001],dp[1001][1001];
int main()
{
    cin >> n >> m;
    for(int i=1;i<=n;i++)
        cin >> d[i];
    for(int i=1;i<=m;i++)
        cin >> c[i];
    memset(dp,0x3f,sizeof(dp));
    memset(dp[0],0,sizeof(dp[0]));
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            dp[i][j]=min(dp[i][j-1],dp[i-1][j-1]+d[i]*c[j]);
    cout << dp[n][m] << endl;
    return 0;
}
```

---

## 作者：prefer (赞：7)

## 记忆化搜索

dfs两个参数：当前天数Nday，当前位置where

对于每一天，有两种选择 

1.休息

即天数+1，位置不动

dfs(Nday+1,where);

2.跑到下一个

即天数+1，位置+1

其疲劳值为:从where到where+1的路程是d[where+1]（题目中：从i-1城市到i城市距离是Di，即从i到i+1路程是D[i+1]）,天气恶劣程度c[Nday]（枚举的是当天情况），相乘。

dfs(Nday+1,where+1)+d[where+1]*c[Nday]

越界 return INF;(因为题目要求是求Min，所以越界要以一个大的数字来return)

到达 return 0;

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL n,m,d[1005],c[1005],f[1005][1005];
const int INF = 1e9;
LL dfs(LL Nday,LL where){
    if(f[Nday][where]) return f[Nday][where];
    if(Nday>m+1) return INF;
    if(where==n) return 0;
    return f[Nday][where]=min(dfs(Nday+1,where),dfs(Nday+1,where+1)+d[where+1]*c[Nday]);
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(LL i=1;i<=n;i++)
        scanf("%lld",&d[i]);
    for(LL i=1;i<=m;i++)
        scanf("%lld",&c[i]);
    printf("%lld\n",dfs(1,0));//当前第1天，位于0点
    return 0;
}
```

---

## 作者：RedreamMer (赞：5)

# P3399题解
看到许多题解里的大佬都是二维$dp$，为什么没人将二维压缩成一维呢？

### 思路：
因为在循环到第$j$天的时候，只会利用到第$j-1$天的内容，所以这就是可以把二维$dp$压缩到一维$dp$的原因，而且还可以边读入$c$数组边做，这样还可以把$c$数组压缩成一个$c$变量。

定义$dp[i]$的意义，$dp[i]$为走完i个城市所需要的最小花费，可以很快速地推出方程式为：
```
dp[j]=min(dp[j-1]+d[j]*c,dp[j]);
```
### 代码：

（应该是最简代码了吧）
```
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
int dp[1001],d[1001];
int main(){
	memset(dp,0x7f,sizeof(dp));				//初始化，一开始到达每个城市的最小花费都为正无穷 
	dp[0]=0;								//但是到达第0个城市的最小花费为0 
	cin>>a>>b;
	for(int i=1;i<=a;i++)
	cin>>d[i];
	for(int i=1;i<=b;i++){
		cin>>c;								//读入第i天的气候恶劣值 
		for(int j=min(i,a);j>=1;j--)		//此时循环必须要从min(i,a)开始，首先，如果从1开始，则在之后的计算计算重复，其次，在第i天最多只能走min(i,a)
		dp[j]=min(dp[j-1]+d[j]*c,dp[j]);
	}
	cout<<dp[a];
	return 0;
}
```
[My Blog](https://www.luogu.org/blog/184549/)

---

## 作者：冰翼ACE (赞：5)

简单的写一下：设dp[i][j]为前I天走到第j个城的代价

那么有 所有的dp[i][0]=0; dp[i][i]=dp[i-1][i-1]

其他的 dp[i][j]=min(dp[i][j-1],dp[i-1][j-1]+d[j]\*c[i]);

其中要外层i循环天，内层j循环城，城循环到min(i,n)

附代码：



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
int d[1100],c[1100];
int dp[1100][1100];
int main(){
    #ifdef ONLINE_JUDGE
    #else
        freopen("in.txt","r",stdin);
    #endif
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&d[i]);
    for(int i=1;i<=m;i++) scanf("%d",&c[i]);
    memset(dp,127,sizeof(dp));
    dp[0][0]=0;
    for(int i=1;i<=m;i++)
    for(int j=0;j<=min(i,n);j++){//前i天，第j个城市
        if(j==i) dp[i][j]=dp[i-1][j-1]+d[j]*c[i];
        else if(j==0) dp[i][j]=0;
        else dp[i][j]=min(dp[i-1][j-1]+d[j]*c[i],dp[i-1][j]);
    }
    printf("%d",dp[m][n]);
    return 0;
}

```

---

## 作者：「QQ红包」 (赞：4)

dp题，

f[i][j]表示走到第i个城市j天需要的最小体力值

很容易知道j肯定大于等于i

当j=i时，每天都要走

当j>i时，就可以选择休息或者走

```cpp
/*
ID: redbag
PROG: 丝绸之路
LANG: C++     
*/
#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
using namespace std;
long long n,m,i,j;
long long a[1010];//距离
long long b[1010];//污染 
long long f[1010][1010];//f[i][j]表示走到第i个城市j天需要的最小体力值 
int main()
{
    scanf("%lld%lld",&n,&m);
    for (i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for (i=1;i<=m;i++)
        scanf("%lld",&b[i]);
    for (i=1;i<=n;i++)
        for (j=i;j<=m;j++)
        {
            if (j>i) f[i][j]=min(f[i][j-1],f[i-1][j-1]+b[j]*a[i]);//休息或者前进 
            else f[i][j]=f[i-1][j-1]+b[j]*a[i];//只能前进 
        }
    long long mi;
    mi=f[n][m];
    for (i=n;i<=m;i++)
    if (f[n][i]<mi) mi=f[n][i];
    printf("%lld",mi);
    return 0;
}
```

---

## 作者：Lips (赞：3)

# 来一篇详细的题解

这是一道很水的 $dp$，先康状态的定义。

$n,m$ 的范围都很小，这就预示着我们可以有一个二维的状态。设 $dp[i][j]$ 为张骞在第 $i$ 个城市，第 $j$ 天所消耗的最小体力值。

继续搞一搞边界条件，我们知道，小仓鼠在起点（长安）的任意一天所消耗的体力值都为 $0$，毕竟站着不动，$dp[0][i]=0$。而对于其它的状态都设为 $0x7f7f7f7f$。

再来看动态转移方程，~~其实题面已经基本上把状态转移方程给您了~~

在第 $i$ 个城市，第 $j$ 天，小仓鼠肯定是通过一下任意一种行动转移过来的：

- 移动。在第 $(j-1)$ 天，从 $(i-1)$ 个城市移动到这个城市。而在第 $j$ 天来到第 $i$ 个城市还需要消耗 $D_i\times C_j$ 的体力值消耗。也就是在第 $(i-1)$ 个城市，第 $(j-1)$ 天所需的最小体力值 $+$ 移动消耗的体力值：$dp[i][j]=dp[i-1][j-1]+D_i\times C_j$。

- 休息。在第 $(j-1)$ 天，不过是在第 $i$ 个城市。就是在第 $i$ 个城市，第 $j$ 天的最优解呗！$dp[i][j]=dp[i][j-1]$。

在两个决策之间取个 $\min$，就是在第 $i$ 个城市，第 $j$ 天的最优解：$dp[i][j]=\min(dp[i][j-1],dp[i-1][j-1]+D_i\times C_j)$。

输出的话千万别输出 $dp[n][m]$，毕竟小仓鼠不一定恰好在第 $m$ 天到达，需要在第 $n$ 个城市的每一天所消耗的体力值取 $\min$，就是我们的最终答案：$\min_{i=1}^mdp[n][i]$。

$Code:$ 高清无删减版：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int MAXN=1010;
int n,m,d[MAXN],c[MAXN],dp[MAXN][MAXN],ans=1e9;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+(ch-'0'),ch=getchar();
	return s*w;
}
int main()
{
	n=read(),m=read();
	memset(dp,0x7f7f7f7f,sizeof(dp));
	for(register int i=0;i<=m;i++) dp[0][i]=0;
	for(register int i=1;i<=n;i++) d[i]=read();
	for(register int i=1;i<=m;i++) c[i]=read();
	for(register int i=1;i<=n;i++)
		for(register int j=1;j<=m;j++)
			dp[i][j]=min(dp[i][j-1],dp[i-1][j-1]+d[i]*c[j]);
	for(register int i=1;i<=m;i++) ans=min(ans,dp[n][i]);
	printf("%d\n",ans);
	return 0;
}
```

$$\texttt{The End.}$$





---

## 作者：时光 (赞：2)

看着没pascal不爽，为pascal的同胞们来一发

设 f[i,j]表示 到达第i个城市第（j+1）天的最小疲劳值

不难列出 f[i,j]:=min(f[i,j-1]{休息},f[i-1,j-1]{行进})；

//注意是c[j]哦！为什么呢，他是昨天来的！

附上程序

```cpp
uses math;
var i,j,m,n,ans:longint;
    d,c:array[0..1001]of longint;
    f:array[0..1001,0..1001]of int64;
begin
readln(n,m);
for i:=1 to n do readln(d[i]);
for j:=1 to m do readln(c[j]);
fillchar(f,sizeof(f),$7);
for i:=0 to m do f[0,i]:=0;//初始化 在长安呆多少天也没疲劳值，注意可以是0天！！
for i:=1  to n do 枚举n个城，长安就不必算了
  for j:=i to m-n+i do  到第i个城最少i天最多 m-n+i天
  f[i,j]:=min(f[i,j-1],f[i-1,j-1]+d[i]*c[j]);
ans:=maxlongint;
for i:=n+1 to m do
if f[n,i]<ans then ans:=f[n,i];//在终点枚举所有可能的天数（其实应该是n to m的，现在才发现。。反正不会错）
write(ans);
end.

```

---

## 作者：Tomwsc (赞：1)

# P3399 丝绸之路 题解

给大家提供一种不同的 dp 方法。

## 题意

你需要从 $0$ 号点通过两种运动方式走到 $n$ 号点。

这两种运动方式是：

1. 在第 $j$ 天由第 $i-1$ 号城市走到第 $i$ 号城市，需要花费 $D_i \times C_j$ 的疲劳值。
2. 在第 $j$ 天休息，待在原地不动，不花费疲劳值。

问到达第 $n$ 号节点至少要花费多少疲劳值。

## 思路与解法

考虑 dp。

为什么用 dp？我们来分析一下：

- **最优子结构**：我们可以通过求得到达**每个城市**的最少疲劳值来得到到达**第 $n$ 号城市**的最少疲劳值。同时，我们可以将这个大问题分成**有限个子问题**进行求解，不会出现**无限子问题**的情况。
- **无后效性**：我们只需要知道最少的疲劳值，不需要知道是如何得到的。

满足这两个条件的题目，基本上都可以用 dp 来做。

设 $dp[i][j][0]$ 表示在第 $i$ 天走到第 $j$ 号城市所需要的花费的最少疲劳值。

设 $dp[i][j][1]$ 表示在第 $i$ 天在第 $j$ 号城市休息所需要的花费的最少疲劳值。

有初始化：$dp[0][1][0]=dp[0][1][1]=0$。

设计完状态，我们来推方程：

- 对于 $dp[i][j][0]$ 这个状态，它的上一天可以在休息，也可以在运动。但一定是从上一个城市走过来的。所以它一定是从 $dp[i - 1][j - 1][0/1]$ 中转移过来。由于这个状态是在运动的，所以要加上疲劳值。

  即 $dp[i][j][0]=\min(dp[i][j][0],\min(dp[i-1][j-1][1],dp[i-1][j-1][0])+D_i\times C_j)$。

- 对于 $dp[i][j][1]$ 这个状态，由于它是在休息的，也就是说静止在原地不动的，所以它在上一天肯定已经到达了 $j$ 号城市。但它上一天的状态是不知道的，我们要取较小值。

  即 $dp[i][j][1]=\min(dp[i][j][1],dp[i-1][j][1],dp[i-1][j][0])$。

最终答案便是 $\min(dp[m][n+1][0],dp[m][n+1][1])$。

为什么要 $n+1$？因为是从 $0$ 号节点走到 $n$ 号节点，我们可以把它转换成从 $1$ 号节点走到 $n+1$ 号节点。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1500;
int n , m;
int d[MAXN];
int c[MAXN];
int dp[MAXN][MAXN][2];

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(register int i = 1;i <= n;i ++)
		cin >> d[i];
	for(register int i = 1;i <= m;i ++)
		cin >> c[i];
	memset(dp , 0x7f , sizeof(dp));
	dp[0][1][0] = dp[0][1][1] = 0;
	for(register int i = 1;i <= m;i ++)
		for(register int j = 1;j <= n + 1;j ++) {
			dp[i][j][0] = min(dp[i][j][0] , min(dp[i - 1][j - 1][1] , dp[i - 1][j - 1][0]) + d[j - 1] * c[i]);
			dp[i][j][1] = min(dp[i][j][1] , min(dp[i - 1][j][1] , dp[i - 1][j][0]));
		}
	cout << min(dp[m][n + 1][0] , dp[m][n + 1][1]);
	return 0;
}
```

---

## 作者：1GNI5T4R (赞：1)

#  一道普通的DP
------------
### 因为是求min，所以初始化为0x3f3f3f3f

### f[0][1~n]要初始化为0，dp时就是c[1~n]*d[1]作为初始值
### 之后的DP时作为第一天走消耗的体力



------------

```
f[i][j]=min(f[i][j-1],f[i-1][j-1]+c[j]*d[i]);
//接下来=min(休息,前进)
```
## 状态转移方程

------------
### 完整代码
------------

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int d[1010],c[1010];
int f[1010][1010];
void dp()
{
	memset(f,0x3f3f3f,sizeof(f));
	memset(f[0],0,sizeof(f[0]));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=min(f[i][j-1],f[i-1][j-1]+c[j]*d[i]);
		}
	}
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>d[i];
	}
	for(int i=1;i<=m;i++){
		cin>>c[i];
	}
	dp();
	cout<<f[n][m];
	return 0;
}
```


---

## 作者：心妍扎辫很美 (赞：1)

以样例为例

设f[i][j]是在j天时到达第i个城市时的最少劳度

因为要在M天内到达N个城市，所以N-i<=M-j而且j>=i

在到达第1个城市时：

	1.第一天到达时 f[1][1]=500
    
   2.第二天到达时 f[1][2])=300
   
   3.第三天到达时 f[1][3]=150
   
   4.第四天到达时 f[1][4] 因为3-1>=5-4不成立，所以不算
   
在到达第2个城市时：

	1.第二天到达时 f[2][2]=min(f[1][1])+750=1250
    
   2.第三天到达时 f[2][3]=min(f[1][1],f[1][2])+375=675
   
   3.第四天到达时 f[2][4]=min(f[1][1],f[1][2],f[1][3])+1000;
   
   4.第五天到达时 因为3-2>=5-5不成立，所以不算

在到达第三个城市时，以此类推

所以可以得出的递推式为 f[i][j]=min(f[i-1][i-1],f[i-1][i],f[i-1][i+1],...,f[i-1][j-2],f[i-1][j-1])+c[i]\*d[j]

然后上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long Int;
Int n,m,d[1001],c[1001],f[1001][1001],ans=1e9;
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;++i)
        scanf("%lld",&d[i]);
    for(int i=1;i<=m;++i)
        scanf("%lld",&c[i]);
    fill(f[0],f[0]+1001*1001,1e9);
    for(int i=0;i<=m;++i)
        f[0][i]=0;
    f[1][1]=d[1]*c[1];
    for(int i=1;i<=n;++i)
        for(int j=i;n-i<=m-j;++j)
            for(int k=i-1;k<j;++k)
                f[i][j]=min(f[i][j],f[i-1][k]+d[i]*c[j]);
    for(int i=n;i<=m;++i)
        ans=min(ans,f[n][i]);
    printf("%lld",ans);
}
```


---

## 作者：封禁用户 (赞：1)

一道经典的dp题
------------
设dp[i][j]表示走到第i个城市休息了j天的最小疲惫值
------------
状态转移方程:dp[i][j]=min(dp[i-1][j]+d[i]*c[j+i],dp[i][j-1]);
------------
解释一下方程：走i个城市休息j天的最小疲惫值有两种状态,1:第i天走路，则疲惫值等于dp[i-1][j]+d[i]*c[j+i],2:第i天休息,则疲惫值等于dp[j-1]
------------
cpp代码
------------
```cpp
//洛谷P3399
#include<bits/stdc++.h>
#define N 4001
#define ll long long
using namespace std;
int d[N],c[N],dp[N][N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        scanf("%d",&d[i]);
    for(int i=1;i<=m;i++)
        scanf("%d",&c[i]);
    memset(dp,0x7f7f7f7f,sizeof(dp));
    int k=m-n;
    for(int i=0;i<=m;i++)
        dp[0][i]=0;
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=k;j++)
        {
            dp[i][j]=min(dp[i-1][j]+d[i]*c[j+i],dp[i][j-1]);
        }
    }
    cout<<dp[n][k]<< endl;
    return 0;
}
```


---

## 作者：EternalEpic (赞：1)

这是一道基础DP 有点像背包

由数据范围n<=m<=1000可知 这是一道O（n*m）就能过的“傻题”

考虑f(i, j)表示第i个城市第j天到达所需的最小疲劳度

可以由f(i, j - 1)就是停这个状态得到，

也可以由f(i - 1, j - 1) + c(j) * d(i) get到

方程就列出来了

but....... 预处理！
我的代码上有批注，注意i和j的起点，稍微变一下可就是57啦


~~别问我怎么知道的~~

最后...上代码！
```cpp
#include <bits/stdc++.h>
#include <queue>
#include <set>
#include <vector>
#include <deque>

#define rep(i,n) for (register int i = 1; i <= n; i++ )
#define rup(i,x,y) for (register int i = x; i <= y; i++ )
#define rdown(i,x,y) for (register int i = x; i >= y; i-- )
#define lowbit(x) x & -x

#pragma GCC optimize(3)

using namespace std;

inline char gc(void)
{
    static char buf[100000], *p1 = buf, *p2 = buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}

template <class T> inline void read(register T &x)
{
	register long long flag = 1;
	x = 0; register char ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') flag = -1;
	for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	x *= flag; return;
}

template <class T> inline void write(register T x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

template <class T> inline void writeln(register T x)
{
    write(x);
    puts("");
}

template <class T> inline void writeln(register T x, char c)
{
	write(x); putchar(c);
}

template <class T> inline void chkmax(T &X, const T Y)
{
	X > Y ? X = X : X = Y;
}

template <class T> inline void chkmin(T &X, const T Y)
{
	X < Y ? X = X : X = Y;
}

inline void file_open(string str)
{
	freopen((str + ".in").c_str(), "r", stdin);
	freopen((str + ".out").c_str(), "w", stdout);
}

inline void file_clo(void)
{
	fclose(stdin);
	fclose(stdout);
}

typedef long long ll;

enum {
	MaxPool = 1005
};

const int INF = 1 << 30; 

int n, m, c[MaxPool], d[MaxPool];

int f[MaxPool][MaxPool];

int main(void)
{
	/*ps：此题初遇是在我普及组的时候，只有57分，现在看它犹如切菜*/
	/*f[i][j]表示第i个城市第j天到达所需的最小疲劳度*/
	read(n); read(m);
	for (register int i = 1; i <= n; i++)
		read(d[i]);
	for (register int i = 1; i <= m; i++)
		read(c[i]);
		
	for (register int i = 1; i <= n; i++) /*因为起始站是0所以从1开始*/
		for (register int j = i - 1; j <= m; j++)/*j从0开始正因为起始站是0，f[1][0] = INF, f[0][0 ~ m - n + 1] = 0*/
			f[i][j] = INF;
	/*起始位置预处理*/
	
	for (register int i = 1; i <= n; i++)
		for (register int j = i; j <= m; j++)
			f[i][j] = f[i][j - 1] < f[i - 1][j - 1] + d[i] * c[j]
			? f[i][j - 1] : f[i - 1][j - 1] + d[i] * c[j];
	
	int ans = INF; /*随后答案应取min{f[n][n ~ m]}*/
	for (register int i = n; i <= m; i++)
		chkmin(ans, f[n][i]);
		
	writeln(ans);
    return 0;
}



```

---

## 作者：DennyQi (赞：1)

我可能太蒻了吧，没有想到枚举每一天走与不走……想到了$dp[i][j]$表示第$j$天选择从$i-1$走到$i$的最小疲劳值，于是得到了$dp[i][j]=Min\{dp[i-1][k]\}+d[i]*c[j]$。

然后发现n^3……$qwq$

于是就用单调队列优化水过了这道题啊啊（并没有人和我一样蠢到用单调队列优化吧……）

```cpp
/*By DennyQi 2018*/
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 1010;
const int INF = 1061109567;
inline int Max(const int a, const int b){ return (a > b) ? a : b; }
inline int Min(const int a, const int b){ return (a < b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
int N,M,ans(INF);
int d[MAXN],c[MAXN],dp[MAXN][MAXN];
int q[MAXN],h,t;
int main(){
	N = read(), M = read();
	memset(dp, 0x3f, sizeof dp);
	for(int i = 1; i <= N; ++i){
		d[i] = read();
	}
	for(int i = 1; i <= M; ++i){
		c[i] = read();
		dp[1][i] = d[1] * c[i];
	}
	for(int i = 2; i <= N; ++i){
		memset(q,0,sizeof q);
		h = t = 1;
		q[t] = i-1;
		for(int j = i; j <= M; ++j){
			dp[i][j] = dp[i-1][q[h]] + d[i] * c[j];
			while(h<=t && dp[i-1][q[t]] > dp[i-1][j]) --t;
			q[++t] = j;
		}
	}
	for(int i = 1; i <= M; ++i){
		ans = Min(ans, dp[N][i]);
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：codesonic (赞：1)

一道不错的DP

其他题解的空间复杂度都是$O(nm)$,我用滚动数组优化到了$O(n)$

仍然设$f_{i,j}$表示第$j$天位于第$i$个城市的最小疲劳值，那么有

$f[i][j]=min(f_{i,j-1},f_{i-1,j-1}+D_i \times C_j)$

发现每次的状态转移只和第$i-1$和第$i$行有关，那就可以使用滚动数组优化

原来的DP部分长这样：
```cpp
	for(int i=1;i<=n;i++)
		for(int j=i;j<=m;j++)
			f[i][j]=min(f[i][j-1],f[i-1][j-1]+c[i]*d[j]);
```

改为：

```cpp
	for(int i=1;i<=n;i++){
		memset(f[i%2],0x7f,sizeof f[i%2]);
		for(int j=i;j<=m;j++){
			f[i][j]=(1<<30);
			f[i%2][j]=min(f[i%2][j-1],f[(i%2)^1][j-1]+c[i]*d[j]);
		}
	}
```
从而优化掉一维的空间复杂度

另外对于每个i都要memset一次，是因为转移涉及到了i本身

如果不换新评测机的话，这应该是最优解了（欢迎hack

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>

using namespace std;
const int maxn=1010;
int c[maxn],d[maxn];
int f[2][maxn];

inline int minn(int a,int b){
	return a<b?a:b;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&c[i]);
	for(int i=1;i<=m;i++)scanf("%d",&d[i]);
	for(int i=0;i<=m;i++) f[0][i]=0;
	for(int i=1;i<=n;i++){
		memset(f[i%2],0x7f,sizeof f[i%2]);
		for(int j=i;j<=m;j++){
			f[i][j]=(1<<30);
			f[i%2][j]=min(f[i%2][j-1],f[(i%2)^1][j-1]+c[i]*d[j]);
		}
	}
	int ans=(1<<30);
	for(int i=n;i<=m;i++) ans=minn(ans,f[n%2][i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：L7_56 (赞：0)

## dp题

首先看到有 $i$ 个城市，所以状态中需要一维存所在城市

又有天数，所以第二维就是天数

此时已经可以表示出当前状态，用 $dp[i][j]$ 表示第 $j$ 天的时候在第 $i$ 个城市

对于每一个状态可以有两种转移方式：休息或移动

得出转移方程$：$

$$dp[i][j]=\max(dp[i][j-1],dp[i-1][j-1]+d[i]*c[j])$$

最后注意初始化就好了

### 代码
---

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 1010
using namespace std;

int dp[maxn][maxn];
int d[maxn],c[maxn];
int n,m;

inline int min(int a,int b){
	return a<b?a:b;
}

int main(){
	scanf("%d%d", &n, &m);
	for(int i=1;i<=n;++i)
	 scanf("%d", &d[i]);
	for(int j=1;j<=m;++j)
	 scanf("%d", &c[j]);
	memset(dp,0x7f,sizeof dp);
	for(int i=0;i<=m;++i)
	 dp[0][i]=0;
	for(int i=1;i<=n;++i){
		for(int j=i;j<=m;++j){
			dp[i][j]=min(dp[i][j-1],dp[i-1][j-1]+d[i]*c[j]);
		}
	}
	printf("%d", dp[n][m]);
	return 0;
}

```

---

## 作者：Cry_For_theMoon (赞：0)

[传送门](https://www.luogu.com.cn/problem/P3399)


&emsp;&emsp;蒟蒻觉得这题优化方式和完全背包的 O(VN) 解法思想异曲同工。

&emsp;&emsp;先来最暴力的解法吧，设$f_{i,j}$是花 j 天走到第 i 个城市的最小耗费，则有转移方程：
$$f_{i,j}=\max(f_{i-1,k}+dis_i * c_{k+1})$$
&emsp;&emsp;同时满足：
$$i-1 <= k <= j$$

&emsp;&emsp;这个方程的推导很简单吧，如果在第 k+1 天到达城市 i，那么走到 i-1 个城市的花费就是$f_{i-1,k}$，同时算上第 k+1
天的赶路费用也就是 $dis_i * c_{k+1}$ 即可。

&emsp;&emsp;然后交上去，发现两个TLE，泪目。~~（然后改成记忆化发现A了，可能这题无用状态比较多吧）~~。

&emsp;&emsp;那么就要优化DP了。我们发现，如果 j 天到达 i，然后休息 1天，那其实花费就是 $f_{i,j-1}$啊，如果休息 2 天，那就是 $f_{i,j-2}$ 啊。然而对时间复杂度优化并没有任何用处。然后再发现，我们最后是取 "休息0天，休息 1天，休息 2 天...休息 k 天的最小值 "。然后我们根据发现，在计算"休息1天"的情况时，它已经取了"休息1..n"天的最小值，而在之前的之前计算"休息2天"的情况是，又已经取了"休息2..n"天的最小值......，如此迭代下去。

&emsp;&emsp;所以，每一次只要判断是不休息更优，还是休息一天更优，就完事了。因此我们得出了新的转移方程：
$$f_{i,j}=\min\begin{cases}f_{i-1,j-1}+dis_i * c_j\\\min( f_{i,j-1} )\end{cases}$$

&emsp;&emsp;注意当 $i=j$ 时，不能休息，直接取第一个式子的值就行了。

&emsp;&emsp;AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int INF=0x7fffffff;
int n,m,dis[1010],fence[1010];
int f[1010][1010];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>dis[i];
	for(int i=1;i<=m;i++)cin>>fence[i];
	for(int i=1;i<=n;i++){
		for(int j=i;j<=m;j++){
			f[i][j]=1e9;
			if(j==i)f[i][j]=f[i-1][j-1]+fence[j]*dis[i];
			else f[i][j]=min(f[i-1][j-1]+fence[j]*dis[i],f[i][j-1]);
		}
	}
	int ans=1e9;
	for(int i=n;i<=m;i++)ans=min(ans,f[n][i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：Nanchtiy (赞：0)

### 我丑，话说在前头 ###
题目：

> https://www.luogu.org/problemnew/show/P3399

一道挺简单的DP
思路不难想 ~~但是蒟蒻总是写错初始化啥的~~


----------
### 思路 ###
定义f[i][j]为第i天到达第j个城市
以**天**来进行DP
每一天可以由以下两种方法到达

 1. 休息一天
 2. 走一天
 
 那么方程就可以得出
 **f[i][j]=min(f[i-1][j],f[i-1][j-1]+wea[i]*dis[j]);**
 f[i-1][j]为休息一天不动
 f[i-1][j-1]+wea[i]*dis[j]为从前一个城市走一天到达下一个城市
 


----------
### 代码 ###

```
#include<iostream>
#include<cstring>
using namespace std;
int n,m;
int dis[1010],wea[1010];//dis为距离 wea为天气 
int f[1010][1010];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	cin>>dis[i];
	for(int i=1;i<=m;i++)
	cin>>wea[i];
	for(int i=0;i<=m;i++)
	memset(f[i],0x7f,sizeof(f[i]));
	for(int i=0;i<=m;i++)
	f[i][0]=0;//初始化每一天到不动为0 
	for(int i=1;i<=m;i++)
	for(int j=1;j<=n&&j<=i;j++)//城市数必须小于天数 
	{
		f[i][j]=min(f[i-1][j],f[i-1][j-1]+wea[i]*dis[j]);
	}
	int minn=2139063143;
	for(int i=n;i<=m;i++)//从第n天到第m天到达终点的最小值 
	if(minn>f[i][n])
	minn=f[i][n];
	cout<<minn;
}
```

---

## 作者：Dvelpro (赞：0)

上面的转移方程已经说的很清楚了dp[j][k]=min(dp[j][k-1],dp[j-1][k-1]+a[j]\*b[k])    表示 第j 个城市 第 k天的最优值   但是 我们必须要考虑的一个因素就是   当到达第二个城市的时候 起始的天数 必须是第二天 我们总不能  第三个城市是从第三天开始的  总不能我们第一天就直接走到地三个城市吧    注意的是 当 j==k的时候我们的选择只有一个 下面贴上代码





```cpp
 #include<bits/stdc++.h>
using namespace std;
int dp[2001][2001];
int a[100001];
int b[100001];
int main(){
    int m,n;
      cin>>m>>n;
    for(int j=1;j<=m;j++){
        cin>>a[j];
    }
    for(int j=1;j<=n;j++){
        cin>>b[j];
    }
    memset(dp,0,sizeof(dp));
    for(int j=1;j<=m;j++){
        for(int k=j;k<=n;k++){
           if(k==j) dp[j][k]=dp[j-1][k-1]+a[j]*b[k];  //当 j==k的时候我们只有一个选择 
           else dp[j][k]=min(dp[j][k-1],dp[j-1][k-1]+a[j]*b[k]);   //转移方程
           //cout<<j<<" "<<k<<" "<<dp[j][k]<<endl;
        }
    }
    cout<<dp[m][n]<<endl;
    return 0;
}

```

---

## 作者：飞翔 (赞：0)

设f[i][j]表示经过了i天，疲惫值为j的最优解。不难想到转移方程：

f[i][j]=min(f[i-1][j-1]+d[i]\*c[j],f[i][j-1])

状态只有休息和走路两种，直接DP即可。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
const int maxn=1000;
int f[maxn+10][maxn+10];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int c[maxn+10],d[maxn+10];
    for (int i=1;i<=n;i++) scanf("%d",&d[i]);
    for (int i=1;i<=m;i++) scanf("%d",&c[i]);
    memset(f,127,sizeof(f));//注意初始化
    for (int i=0;i<=m;i++) f[0][i]=0;
    for (int i=1;i<=n;i++)
      for (int j=i;j<=m-n+i;j++)
        f[i][j]=min(f[i-1][j-1]+d[i]*c[j],f[i][j-1]);
    int ans=f[n][n];
    for (int i=n+1;i<=m;i++) ans=min(ans,f[n][i]);
    printf("%d",ans);
}
```

---


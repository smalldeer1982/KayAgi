# 打字练习

## 题目描述

R 君在练习打字。

有这样一个打字练习网站，给定一个范文和输入框，会根据你的输入计算准确率和打字速度。可以输入的字符有小写字母、空格和 `.`（英文句号），输入字符后，光标也会跟着移动。

输入的文本有多行，R 君可以通过换行键来换行，换行后光标移动到下一行的开头。

R 君也可以按退格键（为了方便，退格键用 `<` 表示），以删除上一个打的字符，并将光标回移一格。特殊的，如果此时光标已经在一行的开头，则不能继续退格（即忽略此时输入的退格键）。

网站的比较方式遵循以下两个原则：

- 逐行比较，即对于范文和输入的每一行依次比较，不同行之间不会产生影响，多余的行会被忽略。
- 逐位比较，即对于两行的每一个字符依次比较，当且仅当字符相同时才会被算作一次正确，否则会被算作错误。计算答案时，只统计相同的字符个数。

需要注意的是，回车键不会被计入正确的字符个数。

R 君看到网站上显示他花了 $T$ 秒完成了这次的打字游戏，请你计算出他的 KPM（Keys per minutes，每分钟输入的字符个数），答案四舍五入保留整数部分。


## 说明/提示

#### 样例解释

第一行的正确字符数为 11。  
第二行的正确字符数为 6，错误的字符 `c` 仍会占据一个位置。  
第三行的正确字符数为 1，R 君使用退格键删除了被打错的字符 `y`

#### 数据范围

对于 $20\%$ 的数据，不存在换行键。  
对于 $40\%$ 的数据，不存在退格键。  
对于 $100\%$ 的数据，$T \leq 10^3$，保证每个文本段的总字符数（包括换行）不超过 $10^5$ 个且总行数不超过 $10^4$。


## 样例 #1

### 输入

```
hello world.
aaabbbb
x
EOF
heelo world.
aaacbbbb
y<x
EOF
60```

### 输出

```
18```

# 题解

## 作者：张泠天青 (赞：291)

这是一道很好的字符串模拟题。

题目中，有 “删除上一个输入的字符” 的操作，类似于栈之中的弹栈，于是此题就有一个新的思路：**使用栈。**

注:本篇题解讲解了栈的用法，目的是让未曾学过栈的选手能够理解，讲解有些过于细致，请多包涵。

具体方法请向下看：

------------
## $Part1:$ 审题

拿到这道题，首先要做的当然是审题了。

在这一题中，我的基本思路是:
用栈存放范文，然后存放输入的内容，依次把每一行输入内容和其对应的范文进行比对。统计出输入正确的个数。最后再读入输入用时，进行计算，完成题目。

------------


## $Part2:$ 初始化

**开始**，开一些变量来分别表示正确字符的个数 $rig$、$T$ 和 $KPM$：

```cpp
long long rig,t,kpm;
```

**接着**，我们要用一个字符串来暂时存放输入的数据，所以开一个 $char$ 型的数组表示字符串，（貌似使用 $char$ 会比用 $string$ 更好）以及相应字符串长度 $cds$，读入范文的序数 $hs$,读入输入的序数 $es$。

```cpp
char s[100005];
long long cds,hs,es;
```
**最后**，我们用栈存放范文和输入的字符。

### 这里简述一下栈的基本用法：
在 $STL$ 中，有栈的容器 $stack$，基本开栈的方法是：

```cpp
stack<（数据类型）>（栈的名称）;
```

于是，开栈存放范文和输入的字符：

```cpp
stack<char>s1[10005],s2;
```

栈有很多的操作，下面列举其中这一题可以用到的几种：

1. 把一个元素 $x$ 压入栈中：

```cpp
s.push(x);
```

2. 读取栈顶：

```cpp
s.top();
```

3. 弹出（删除）栈顶：

```cpp
s.pop();
```

4. 返回栈是否为空（无元素）：

```cpp
s.empty();
```

**栈具有先入后出的特性，因此可以便捷地弹出上一个压入栈中的字符，也就是关于 $“<”$ 的操作了。**

------------


## $Part3:$ 读入
依次读入范文和输入的字符；  

因为带有空格，所以不能直接用 $cin$ 来输入这个字符串，于是，使用

```cpp
gets(s);
```

来直接读入一行字符串。

然后用 $strlen(s)$ 获取字符长度，这样依次把每一位字符压入栈中;

题目中说明范文和输入符都由小写字母，空格，句号，删除符 $(<)$ 组成，因此在压入栈之前判断一下，以避免进入多余字符。

读入到 $EOF$ 时停止读入，进入下一步操作，在此之前会不停地读入。于是，我们用一个死循环，判断读入为 $EOF$ 时便跳出，每次循环序数加一。

综上所述，我们得到如下读入代码:

```cpp
while(1){
  gets(s);
  cds=strlen(s);
  if(cds==3&&s[0]=='E'&&s[1]=='O'&&s[2]=='F')break;
  hs++;
  //下面将临时读入的s压入栈中
  for(int i=0;i<cds;i++){
    if((s[i]>='a'&&s[i]<='z')||s[i]==' '||s[i]=='.')s1[hs].push(s[i]);
  }
}
while(1){
  gets(s);
  cds=strlen(s);
  if(cds==3&&s[0]=='E'&&s[1]=='O'&&s[2]=='F')break;
  es++;
  for(int i=0;i<cds;i++){
  if(s[i]=='<'&&s2.empty()==0)s2.pop();
  else if((s[i]>='a'&&s[i]<='z')||s[i]==' '||s[i]=='.')s2.push(s[i]);
}
```
------------
## $Part4:$ 比对（重点）

读入基础字符后，就要开始比对范文和输入字符串求得相同的字符数了。

这里，我们遇到了个棘手的问题：**用栈储存无法顺序比较每一位。**

由于比较复杂，故用画图来解释原因，更容易理解：

如果直接一位一位弹栈比较，比较的顺序就会变成**逆序**，会导致出错，例子如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/z4bok0mg.png)


容易得：正确答案为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cl32gtlm.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ztrz15vn.png)

几次操作后，$s2$ 被弹空，终止，答案为 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/0f8f79hk.png)

所以，要用两个临时的栈存入 $s1$ 和 $s2$ 后再比较，这样，正好一倒，变成正序。

开临时栈 $t1$ 和 $t2$：

```cpp
stack<char>t1,t2;
```

![](https://cdn.luogu.com.cn/upload/image_hosting/ewch8cns.png)

将比对的两个栈分别弹入 $t1$，$t2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/khb761xb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/hdn3qqb6.png)

全部操作后：

![](https://cdn.luogu.com.cn/upload/image_hosting/b3m62wzt.png)

这时，再逐位比对，就不会出现上面的问题了。

代码实现：

```cpp
while(s1[es].empty()==0){
    t1.push(s1[es].top());
    s1[es].pop();
}
while(s2.empty()==0){
    t2.push(s2.top());
	 s2.pop();
}
cds=min(t1.size(),t2.size());
for(int i=1;i<=cds;i++){
    if(t1.top()==t2.top())rig++;
        t1.pop();
        t2.pop();
    }
}
```


------------
## $Part5:$ 结果

最后，就是读入用时 $t$，然后计算结果了。

$double$ 型变量强制转 $int$ 型时，是向下取整的，所以，我们把结果加上 $0.5$ 后再转 $int$ 型，就相当于四舍五入了。

代码如下：

```cpp
cin>>t;
kmp=rig*60.0/t+0.5;
cout<<kpm<<endl;
```

------------
## $Part6:$ 完整代码（无注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long hs,es,cds,rig,kpm;
double t;
char s[100005];
stack<char>s1[10005],s2;
int main(){
    while(1){
        gets(s);
        cds=strlen(s);
        if(cds==3&&s[0]=='E'&&s[1]=='O'&&s[2]=='F')break;
        hs++;
        for(int i=0;i<cds;i++){
            if(s[i]=='<'&&s1[hs].empty()==0)s1[hs].pop();
            else if((s[i]>='a'&&s[i]<='z')||s[i]==' '||s[i]=='.')s1[hs].push(s[i]);
        }
    }
    while(1){
        gets(s);
        cds=strlen(s);
        if(cds==3&&s[0]=='E'&&s[1]=='O'&&s[2]=='F')break;
        es++;
        for(int i=0;i<cds;i++){
            if(s[i]=='<'&&s2.empty()==0)s2.pop();
            else if((s[i]>='a'&&s[i]<='z')||s[i]==' '||s[i]=='.')s2.push(s[i]);
        }
        stack<char>t1,t2;
        while(s1[es].empty()==0){
        	t1.push(s1[es].top());
        	s1[es].pop();
		}
		while(s2.empty()==0){
			t2.push(s2.top());
			s2.pop();
		}
		cds=min(t1.size(),t2.size());
        for(int i=1;i<=cds;i++){
            if(t1.top()==t2.top())rig++;
            t1.pop();
            t2.pop();
        }
    }
    cin>>t;
    kpm=rig*60.0/t+0.5;
    cout<<kpm<<endl;
    return 0;
}
```

### $PS:$ 本蒟蒻第一次写题解，实着辛苦，点个赞再走吧！

---

## 作者：引领天下 (赞：72)

这个题唯一的坑点就在于**范文也有退格键**……

C++的string是个好东西，可以直接使用pop_back()函数直接弹掉当前的string的最后一个字符。

然后push_back()函数可以在string末尾加一个字符

于是就很简单了。。。读入之后，模拟退格，然后逐个比较即可。

代码：

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(3)
using namespace std;
const int N=1e4+5;
string s[N],t[N],s1;
long long n,m,cnt;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    while(getline(cin,s1),s1!="EOF"){
        n++;//读入字符串
		for(char i:s1)if(i=='<'){if(!s[n].empty())s[n].pop_back();}//模拟，如果是退格且string中还有字符就删掉一个
		else s[n].push_back(i);//否则加上去
	}
	while(getline(cin,s1),s1!="EOF"){
		if(++m>n)break;
		for(char i:s1)if(i=='<'){if(!t[m].empty())t[m].pop_back();}
		else t[m].push_back(i);//同上
		for(int i=0;i<min(t[m].size(),s[m].size());i++)cnt+=s[m][i]==t[m][i];//逐位比较
	}
	cin>>m;
	cout<<(long long)(cnt*60.0/m+0.5);//输出
}
```

---

## 作者：地铁dixiatielu (赞：20)

### 大模拟水题！
~~虽然调了2个半小时才调出来qwq~~

**一定要注意：数据中的范文也有退格符号！**

$getchar()$函数比$cin$和$scanf$快$qwq$所以选用$getchar()$

我并没有开二维数组存储每一行的字符串是什么，而是把所有的字符都存入了一个$char$数组。当读入换行符时，我们只需要存入'\n'即可。

最后只需要输出

$
\frac{ans}{\frac{t}{60}}
$

也就是

$
\frac{ans}{t}*60
$

即可。

代码:
```cpp
#include <cstdio>
#define reg register
using namespace std;
char s1[200007],s2[200007],ch;//s1表示范文，s2表示打字练习输入的字符
int cnt1,cnt2;
int ans;
int t;//最后读入的时间
int main()
{
    s1[0] = 10;s2[0] = 10;//ASCII码的10就等于'\n'表示换行符
    ch = getchar();//使用getchar加快速度
    while(ch != 'F')//读到'F'的时候就是结束符EOF的最后一位了，所以应该跳出循环
    {
        if(ch == '<')//判断是否读入了退格符
        {
            if(s1[cnt1] != 10)//如果退格符前面不是换行符
            {
                cnt1--;//刚刚读入的字符需要删去,把当前序号--
            }
            ch = getchar();//重新读入一个字符
            continue;//继续
        }
        s1[++cnt1] = ch;//如果不是换行符，那么就存入s1数组
        ch = getchar();//继续读入
    }
    //范文读取完毕
    while((ch < 'a' || ch > 'z') && ch != '.')
    {
        ch = getchar();
    }
    //为了防止读入无用字符，我们需要先把范文和实际输入之间的这些字符读取掉
    while(ch != 'F')//同上，将实际输入存入s2数组
    {
        if(ch == '<')
        {
            if(s2[cnt2] != 10)
            {
                cnt2--;
            }
            ch = getchar();
            continue;
        }
        s2[++cnt2] = ch;
        ch = getchar();
    }
    cnt1 -= 3;
    cnt2 -= 3;//由于我们刚刚读入时把"EOF"也同时存入了s1和s2数组，因此我们需要抛弃它们。所以cnt1和cnt2都要--
    for(reg int i = 1,j = 1;i <= cnt1 && j <= cnt2;)//开始对比s1和s2
    {
        if(s1[i] == s2[j] && s1[i] != 10)//如果s1和s2的这个字母相同并且s1的这个字符不是换行符
        {
            ans++;//正确输入的字符数量++
        }
        if(s1[i] == 10)//如果范文需要换行
        {
            while(s2[j] != 10)//我们需要使读入的字符也跳到换行符
            {
                j++;
            }
            i++;//继续对比下一行
            j++;
            continue;
        }
        if(s2[j] == 10)//同理，读入串需要换行也要都跳到下一行
        {
            while(s1[i] != 10)
            {
                i++;
            }
            i++;
            j++;
            continue;
        }
        i++;
        j++;
    }
    scanf("%d",&t);//读入耗费的时间
    printf("%.0lf",(double)ans / (double)t * 60);//题目要求四舍五入，所以使用printf%.0lf这样就会自动输出四舍五入的数字
    return 0;//Byebye程序 qwq
}

```

---

## 作者：HsKr (赞：14)

用的是string加vector，原因是后面觉得再用string什么s[cnt++]之类的太麻烦了，vector的push_back和pop_back真的很好

细节挺多的，注意一下

```cpp
#include<iostream>
#include<algorithm>
#include<string>
#include<cstdio>
#include<vector>
using namespace std;
string word[10010],type[10010];
vector<char> Word[10010],Type[10010];
int sizew=0,sizet=0,T,ans=0;
void input(){
	while(true){
		string s;
		getline(cin,s);
		if(s!="EOF") word[sizew++]=s;
		else break;
	}
	while(true){
		string s;
		getline(cin,s);
		if(s!="EOF") type[sizet++]=s;
		else break; 
	}
	cin>>T;
}
void view(){
	cout<<endl;
	for(int i=0;i<sizew;i++){
		for(int j=0;j<Word[i].size();j++){
			cout<<Word[i][j];
		}
		cout<<endl;
	}
	cout<<endl;
	for(int i=0;i<sizet;i++){
		for(int j=0;j<Type[i].size();j++){
			cout<<Type[i][j];
		}
		cout<<endl;
	}
}
//50 pts
//void eraseback(){
//	for(int i=0;i<sizew;i++){
//		int t;
//		while((t=Word[i].find('<'))!=-1){
//			if(t==0) Word[i].erase(Word[i].begin(),Word[i].begin());
//			else Word[i].erase(Word[i].begin()+t-1,Word[i].begin()+t+1);
//		}
//	}
//	for(int i=0;i<sizet;i++){
//		int t;
//		while((t=Type[i].find('<'))!=-1){
//			if(t==0) Type[i].erase(Type[i].begin(),Type[i].begin());
//			else Type[i].erase(Type[i].begin()+t-1,Type[i].begin()+t+1);
//		}
//	}
//}
void eraseback(){
	for(int i=0;i<sizew;i++){
		for(int j=0,len=word[i].size();j<len;j++){
			if(word[i][j]!='<') Word[i].push_back(word[i][j]);
			else if(j!=0&&Word[i].size()!=0) Word[i].pop_back();
		}
	}
	for(int i=0;i<sizet;i++){
		for(int j=0,len=type[i].size();j<len;j++){
			if(type[i][j]!='<') Type[i].push_back(type[i][j]);
			else if(j!=0&&Type[i].size()!=0) Type[i].pop_back();
		}
	}
}
int main(){
	input();
	eraseback();
//	view();
	int leni=min(sizew,sizet),lenj;
	for(int i=0;i<leni;i++){
		lenj=min(Word[i].size(),Type[i].size());
		for(int j=0;j<lenj;j++){
			if(Word[i][j]==Type[i][j]){
				ans++;
			}
		}
	}
	printf("%d",int((double)ans/T*60.0));
	return 0;
}
```

粘了一个50pts的做法，用到了string中的erase函数，但是这个函数的时间复杂度是O(n)的，后面5个点TLE了。

eraseback函数中的else if里Word[i].size()!=0与Type[i].size()!=0很重要，否则后5个点会RE

记得string中size函数也是O(n)的，要提前算好（view函数中因为懒就没写了）

输入输出注意一下，就能AC了

---

## 作者：谬悠 (赞：12)

经过数个小时的调试，我终于解决了这道题目！看到还有很多之前和我一样卡在50分痛苦的咕咕，我毅然决然过来奉献自己！

首先!这道题唯一的难点就在于题面！范文神奇的退格符真是、、、、

也就是说需要对原文进行同样的操作，且当光标位于0时退格符无效，且退格符会一直删除而非删除上一个！//我50分的原因

空格也算正确字符！

可以一直换行！且算作字符串！

四舍五入自己手动调一下吧、、、

然后就是瞎模拟

hack数据吗，其实不太需要吧

<<<aaac<c<<c<acbbbb//寒月给的

如有需要请私信QAQ


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int len=1,leen=1;
string a[10005],b[10005];
bool flag=1;
int main() {
	while(1) {
		if(flag) {
			getline(cin,a[len]);
			if(a[len]=="EOF") {
				flag=0;
				continue;
			}
			int c=a[len].size();
			int i,k;
			for(i=0,k=0; i<c; i++,k++) {
				if(a[len][i]=='<') {
					if(k==0) {
						k--;
					} else {
						k-=2;
					} 
				} else {
					a[len][k]=a[len][i];
				}
			}
			if(k!=i) {
				a[len].resize(k);
			}
			len++;
		} else {
			getline(cin,b[leen]);
			if(b[leen]=="EOF") {
				break;
			}
			int c=b[leen].size();
			int i,k;
			for(i=0,k=0; i<c; i++,k++) {
				if(b[leen][i]=='<') {
					if(k==0) {
						k--;
					} else{
						k-=2;
					} 
				} else {
					b[leen][k]=b[leen][i];
				}
			}
			if(k!=i) {
				b[leen].resize(k);
			}
			leen++;
		}
	}
	int num,ans=0;
	cin>>num;
	for(int i=1; i<min(len,leen); i++) {
		//	cout<<a[i]<<endl<<b[i]<<endl<<endl;
		for(int j=0; j<a[i].size()&&j<b[i].size(); j++) {
			if(a[i][j]==b[i][j]) {
				ans++;
			}
		}
	}
	int key=(int)((ans*1.0)/(num*1.0)*60+0.5);
	cout<<key<<endl;
}
```


---

## 作者：joker_0 (赞：8)

## 本题解通过 **string** 类达成题目要求   
这篇题解比较冗杂，嫌弃过长可以去看他人题解
  
  50分的同学可能是因为没有考虑到“**范文**”中会有退格键  ~~（为什么会有这么鬼畜的设定）~~  
##   1. 读入  
定义 string 类的数组 A[ ] 和 B[ ]  

A[ ]用来储存“**范文**”  
B[ ]用来储存R君输入的内容  
  
  注：getline（cin，（string））可以实现string类的整行读入（可读入空格）  
  ~~（自我感觉比gets（）好用）~~  
  
```cpp
	int n=0;//n代表“范文”的行数
	int k;//打字的时间
    
    
	getline(cin,A[n]);
	while(A[n]!="EOF"){
		++n;
		getline(cin,A[n]);
	}//实现 n 的计数和 “范文” 的读入 
    
    
    
    
	for(int i=0;i<n;i++){//对于R君输入的内容，只读入n行即可
		
        	getline(cin,B[i]);
        
		if(B[i]=="EOF"){
                       	scanf("%d",&k);
			goto $;
            				//这里是一个算是一个特判
        				//用于处理R君输入的内容行数过少的情况
                   			//此处不理解可以先跳过
                            		//goto并不建议使用,大家不要向我（蒟蒻）学习
		}
	}
   
    
    
	getline(cin,help);//help（也是string类）意为辅助，用来辅助输入k
    
	while(help!="EOF"){
		getline(cin,help);
	}
    		//也即是把R君输入的内容的多余行过滤掉
    
	scanf("%d",&k);
$:	int ans=0;//刚才的特判就是跳到此处
```
## 2.处理和匹配  
思路是对于每一行需要对比的文本，先分别预处理，解决退格键的问题，再进行比较
```cpp
$:	int ans=0;
	
	for(register int i=0;i<n;++i){
		int lena=A[i].size();
		int lenb=B[i].size();
		int p=0;
        
        
		int pwp=0;
		while(pwp<lena){
				if(A[i][pwp]=='<'){
					if(pwp-1>=0){
						A[i].erase(pwp-1,2);
                       				//用erase()删除'<'及其前面的字符
						lena-=2;
						--pwp;
						--pwp;
                        			//pwp减小是为了保证不会漏掉'<'
                                    		//此分支对应一般情况的处理
					}
					else{
						A[i].erase(pwp,1);
						lena-=1;
						--pwp;
						--pwp;
                        			//此分支对应'<'位于首位的处理
					}
				}
				++pwp;
			}
            
       			     
		int qwq=0;
		while(qwq<lenb){
				if(B[i][qwq]=='<'){
					if(qwq-1>=0){
						B[i].erase(qwq-1,2);
						lenb-=2;
						--qwq;
						--qwq;
					}
					else{
						B[i].erase(qwq,1);
						lenb-=1;
						--qwq;
						--qwq;
					}
				}
				++qwq;
			}			//原理同上
            
            
		while(p<lena&&p<lenb){
			if(A[i][p]==B[i][p])++ans;
			++p; 
		}
        				//逐位对比
	}
```
## 3.~~KPM~~
安利一下round（）函数，求四舍五入
```cpp
	ans*=60;
	cout<<round((double)ans/(double)k);
```  
 总之还是一道比较简单的字符串的题的  
 身为蒟蒻，写的代码有诸多纰漏，还望海涵  
 ~~（毕竟是写的第一篇题解）~~   
 
 最后再放一下完整代码  
 ```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<ctime>
#include<cctype>
#include<algorithm>
using namespace std;
const int M=1e4+5;
string A[M];
string B[M];
string help;
signed main(){
	int n=0;
	int k;
	getline(cin,A[n]);
	while(A[n]!="EOF"){
		++n;
		getline(cin,A[n]);
	} 
	for(int i=0;i<n;i++){
		getline(cin,B[i]);
		if(B[i]=="EOF"){
			scanf("%d",&k);
			goto $;
		}
	}
	getline(cin,help);
	while(help!="EOF"){
		getline(cin,help);
	}
	scanf("%d",&k);
$:	int ans=0;
	
	for(register int i=0;i<n;++i){
		int lena=A[i].size();
		int lenb=B[i].size();
		int p=0;
		int pwp=0;
		while(pwp<lena){
				if(A[i][pwp]=='<'){
					if(pwp-1>=0){
						A[i].erase(pwp-1,2);
						lena-=2;
						--pwp;
						--pwp;
					}
					else{
						A[i].erase(pwp,1);
						lena-=1;
						--pwp;
						--pwp;
					}
				}
				++pwp;
			}
		int qwq=0;
		while(qwq<lenb){
				if(B[i][qwq]=='<'){
					if(qwq-1>=0){
						B[i].erase(qwq-1,2);
						lenb-=2;
						--qwq;
						--qwq;
					}
					else{
						B[i].erase(qwq,1);
						lenb-=1;
						--qwq;
						--qwq;
					}
				}
				++qwq;
			}
		while(p<lena&&p<lenb){
			if(A[i][p]==B[i][p])++ans;
			++p; 
		}
	}
	ans*=60;
	cout<<round((double)ans/(double)k);
	return 0;
}
```




---

## 作者：jiangXxin (赞：8)

一道比较简单的模拟题，按照题意来模拟就可以了，有几个坑：

1.文本串里面也有有退格键“<”（后50%数据）

2.最后计算kpm时建议不要直接除（t/60），不然会re.(视个人程序而定)

最后代码如下：

```cpp
/**
*    author:  a2954898606
*    created: 2019/10/13 11:13:12
**/
#include<bits/stdc++.h>
#define REP(A,B,I) for(int I=(A);I<=(B);I++)
#define PER(A,B,I) for(int I=(A);I>=(B);I--)
#define max(X,Y) ((X)<(Y)?(Y):(X))
#define min(Y,X) ((X)<(Y)?(X):(Y))
#define read(FILENAME) freopen((FILENAME + ".txt"), "r", stdin);
#define write(FILENAME) freopen((FILENAME + ".txt"), "w", stdout);
#define LL long long
#define N 200000
#define esp 1e-18
using namespace std;
int pn1,pn2,t;
double kmp;
string a[N],b[N];
char now[N];
int main(){
    //read(1)
    //write(1)
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    pn1=pn2=1;
    while(1){//文本串的读入
        getline(cin,a[pn1]);//直接读一行，省略换行
        if(a[pn1]=="EOF"){
            pn1--;
            break;
        }
        int len=a[pn1].length()-1;
        int last=0;
        REP(0,len,i){
            if(a[pn1][i]!='<'){//对于退格的处理
                now[last]=a[pn1][i];
                last++;
                continue;
            }
            else{
                last--;
                last=max(last,0);
            }
        }
        a[pn1]="";
        last--;
        REP(0,last,i){
            a[pn1]+=now[i];
        }
        REP(0,len+110,i)now[i]=NULL;//初始化，（可有可无）
        pn1++;
    }
    while(1){//对于输入的字符处理
        getline(cin,b[pn2]);
        if(b[pn2]=="EOF"){
            pn2--;
            break;
        }
        int len=b[pn2].length()-1;
        int last=0;
        REP(0,len,i){
            if(b[pn2][i]!='<'){
                now[last]=b[pn2][i];
                last++;
                continue;
            }
            else{
                last--;
                last=max(last,0);
            }
        }
        b[pn2]="";
        last--;
        REP(0,last,i){
            b[pn2]+=now[i];
        }
        REP(0,len+110,i)now[i]=NULL;
        pn2++;
    }
    cin>>t;
    int bb=min(pn1,pn2);//因为多的不再比较，所以取更小的就OK 了
    int ans=0;
    REP(1,bb,i){
        string an,bn;
        an=a[i],bn=b[i];
        int len=min(an.length(),bn.length())-1;
        REP(0,len,j){
            if(an[j]==bn[j])ans++;
        }
    }
    kmp=1.00000*ans/t;//先乘再除，防止re
    kmp=kmp*60;
    int fina=floor(kmp);
    double bbbb=fina+0.5000001;
    if(kmp>=(1.00000)*(bbbb)){//四舍五入
        fina++;
    }
    cout<<fina<<endl;
    return 0;
}

```


---

## 作者：流逝丶 (赞：7)

~~这题有坑~~

范文中有退格。。

把范文全读进去，然后读R君输的，搞两个栈搞一下，判一下栈里没元素还删的情况

然后比较就行。

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
using namespace std;
string ch1[10005],ch2;
int t,ans,top,top2;
char sta[100005],sta2[100005];
int main(){
	int cnt=1,tot=1;
	for(;;cnt++){
		getline(cin,ch1[cnt]);
		if(ch1[cnt][0]=='E'){
			cnt--;
			break;	
		}
	}
	for(;;tot++){
		getline(cin,ch2);
		top=-1;top2=-1;
		if(ch2[0]=='E')break;
		for(int i=0;i<ch2.size();++i){
			if(ch2[i]=='<'){
				if(top>=0)top--;
			}
			else sta[++top]=ch2[i];
		}
		for(int i=0;i<ch1[tot].size();++i){
			if(ch1[tot][i]=='<'){
				if(top2>=0)top2--;
			}
			else sta2[++top2]=ch1[tot][i];
		}
		for(int i=0;i<min(top+1,top2+1);++i)
			if(sta[i]==sta2[i])ans++;
	}
	scanf("%d",&t);
	printf("%d",ans*60/t);
	return 0;
}
```


---

## 作者：Plus_Ultra (赞：5)

### 题解：

一. 前言：

这道题算是比较难的黄题了，WA了不少次才AC.

二. 解法：

- 我们先定义两个string二维字符串，分别读入文本串和输入串.

- 读入两串的步骤是相同的:

  1. 使用getline读入一整行字符，包括空格.

  2. 在每一行数据中寻找是否有"<"，如果有，则删除对应位置数据.

- 然后for循环比对字符是否相同即可.

- 最后，计算KPM.

三. 坑点：

1. 文本串能删除.

2. 要注意int和double精度的差距.

3. 使用erase函数时，要先删除i,再删除i-1.

4. s.erase(i,j):从第i个位置开始（包括i），删除j个字符.

5. 删除字符后，指针改变.

四. 代码：

下面是代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
#include<cstring>

#define N 100005

using namespace std;

int T,ans,l,r;//l,r表示文本串和输入串的行数.
string s1[N],s2[N];
double kpm,minn;

int main()
{
	while(1)//文本串
	{
		getline(cin,s1[++l]);//读入一整行.
		for(int i=0;i<s1[l].length();i++)
		if(s1[l][i]=='<')
			if(i-1>=0)//记得要特判是否是开头
			{
				s1[l].erase(i,1);
				s1[l].erase(i-1,1),i-=2;
			} //这里i是要变化的,删去了两个数字.
			else  s1[l].erase(i,1),i--;
		if(s1[l]=="EOF")  break;
	}
	while(1)//输入串
	{
		getline(cin,s2[++r]);
		for(int i=0;i<s2[r].length();i++)
		if(s2[r][i]=='<')
			if(i-1>=0)
			{
				s2[r].erase(i,1);
				s2[r].erase(i-1,1),i-=2;
			} 
			else  s2[r].erase(i,1),i--;
		if(s2[r]=="EOF")  break; 
	}
	cin>>T;
	
	for(int i=1;i<min(l,r);i++)//比对，记得取min.
	{	
		int len=min(s1[i].length(),s2[i].length());
		for(int j=0;j<len;j++)//记得取min.
		if(s1[i][j]==s2[i][j])  ans++;
	}
	
	kpm=ans;kpm=kpm*60/T;ans=kpm;//注意精度.
	if(kpm-ans>=0.5)  ans++;//小数部分四舍五入.
	cout<<ans<<endl;
	
	return 0;
}
```

 ### _[Plus Ultra!](https://www.luogu.org/blog/OnePunchManGO/)_ 



---

## 作者：Y15BeTa (赞：5)

~~一道调死人的字符串模拟~~

我的写法是输入每一行时立即将他转化成字符数组（其实强制转化成int也没关系啦），同时立即处理退格键。

这个在代码中就是
```
for(;i<s.size();i++){
    if(s[i]=='<'){
        cntx[n]--;
        if(cntx[n]<0)cntx[n]=0;
    }
    else x[n][++cntx[n]]=int(s[i]);
}
```
另外要注意几个点：

- 注意范文也有退格键qvq（一开始的题面是没有的）

- 注意转化成的字符数组要开大点，防止每一行的字符数过多。（~~讲真题面没给每一行最大字符数是极不友好的~~）

- 要防止退格处理时cnt变成负的，毕竟下界是0（即：无论退格符在行首还是中间还是末尾，如果都退完了就退格无效了）

```
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;

int n,m,T,ans;

string s,t;

char x[10005][10005],y[10005][10005];

int cntx[10005],cnty[10005];

int main(){
    while(1){
		++n;
        getline(cin,s);
        if(s=="\n"){
            n--;
            continue;
        }
        if(s=="EOF"){
            n--;
            break;
        }
        int i=0;
        while(s[i]=='<')i++;
        for(;i<s.size();i++){
            if(s[i]=='<'){
                cntx[n]--;
                if(cntx[n]<0)cntx[n]=0;
            }
            else x[n][++cntx[n]]=int(s[i]);
        }
      //  for(int i=1;i<=cntx[n];i++){
//          cout<<char(x[n][i]);
//        }
//        cout<<endl;
    }
    while(1){
		++m;
        getline(cin,t);
        if(t=="\n"){
            m--;
            continue;
        }
        if(t=="EOF"){
            m--;
            break;
        }
        int i=0;
        while(t[i]=='<')i++;
        for(;i<t.size();i++){
            if(t[i]=='<'){
                cnty[m]--;
                if(cnty[m]<0)cnty[m]=0;
            }
            else y[m][++cnty[m]]=int(t[i]);
        }
        //for(int i=1;i<=cnty[m];i++){
//          cout<<char(y[m][i]);
//        }
//        cout<<endl;
    }
    scanf("%d",&T);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=cntx[i]&&j<=cnty[i];j++){
            if(x[i][j]==y[i][j])ans++;
    //      cout<<char(x[i][j])<<' '<<char(y[i][j])<<endl;
        }
    }
    printf("%d\n",int(ans*60.0/T+0.5));
}
```
码丑，轻喷qvq

---

## 作者：Stream月 (赞：3)

今天这道题写到心态爆炸，~~还是我太弱了交了20次~~ 

题目唯一比较坑的地方就是**范文也是有退格键**的，~~我卡在50分~~qwq

同机房的一位string大佬，写了该题的string版本，不喜欢字符数组的同学可以去看一下@[joker_0](www.luogu.org/space/show?uid=156947)

然后上代码，似乎有些多余的clear()和毫无必要的快读

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath> 
typedef long long ll;

using namespace std;
#define $(i,a,n) for(int i = a; i <= n; ++i)

inline ll read() {
	   ll ans = 0;
	   char last = ' ',ch = getchar();
	   while(ch < '0' || ch > '9') last = ch, ch = getchar();
	   while(ch >= '0' && ch <= '9') ans = (ans << 3) + (ans << 1) + ch - '0', ch = getchar();
	   if(last == '-') ans = -ans;
	   return ans;
}

const int INF = 0x3f3f3f3f;

const int M = 1e4 + 5;
const int N = 1e5 + 5;

char s[M][N];
char w[N], a[N], stack[N];
int cnt, top;

void func(char *c) {	// 该函数实现退格 为了好理解用栈实现
	top = 0;
	int len = strlen(c + 1);
	for(int i = 1; i <= len; ++i) {
		if(c[i] == '<') {
			if(top) {
				stack[top--] = '\0';
			}
		} else stack[++top] = c[i];
		c[i] = '\0'; 
	}
}
void clear() {
	while(top) stack[top--] = '\0';
}
ll ans;
bool flag = false;
int main(){
	while(true) {
		++cnt;
		gets(s[cnt] + 1);
		if(s[cnt][1] == 'E' && s[cnt][2] == 'O' && s[cnt][3] == 'F') {
			cnt--;
			break;
		}
		func(s[cnt]);
		
		for(int i = 1; i <= top; ++i) {
			s[cnt][i] = stack[i];
		}
		clear();
	}
	for(int i = 1; i <= cnt; ++i) {	// 只比较前cnt行
		gets(w + 1);
		if(w[1] == 'E' && w[2] == 'O' && w[3] == 'F') {
			flag = true;
			break;
		}
		func(w);
		int len2 = strlen(s[i] + 1);
		int len = min(top, len2);
		for(int j = 1; j <= len; ++j) {
			if(stack[j] == s[i][j]) ++ans;
		}
		clear();
	}
	while(!flag) {
		gets(w + 1);
		if(w[1] == 'E' && w[2] == 'O' && w[3] == 'F') {
			flag = true;
		}
	}
	int T = read();
	printf("%.0lf\n", round(60.0 * ans / T));
	return 0;
}

```


---

## 作者：Froggy (赞：3)

~~趁机发一波题解...~~

首先,这是一道模拟题(谁都知道)

### 读入:

读入怎么办?

getline大法好!(可以直接读入一整行)

用法:

```cpp
string s;
getline(cin,s);
```

然后读入就可以这样读:

```cpp
while(getline(cin,a[++n]),a[n]!="EOF");
while(getline(cin,s[++m]),s[m]!="EOF");
n--,m--;
```

### 处理比较:

开个两个char数组存储实际字符串就好了!

然后一位一位比较

具体看代码:

```cpp
for(int i=1;i<=min(n,m);i++){
	int lens=s[i].length();
	int lena=a[i].length();
	int nowa=0,nows=0;//now模拟数组指针(表示目前实际文本长度)
	for(int j=0;j<lens;j++){
		if(s[i][j]=='<'){//退位
			nows--;
			nows=max(nows,0);
			tmps[nows]=0;
		}
		else{
			tmps[nows]=s[i][j];
			nows++;
		}
	}
	for(int j=0;j<lena;j++){
		if(a[i][j]=='<'){//同上,范文和输入分别处理
			nowa--;
			nowa=max(nowa,0);
			tmpa[nowa]=0;
		}
		else{
			tmpa[nowa]=a[i][j];
			nowa++;
		}
	}
	for(int j=0;j<min(nows,nowa);j++){//比较
		if(tmpa[j]==tmps[j])ans++;
	}
}
```

### 输出:

有个坑:**要四舍五入**

想到printf里输出double类型自带四舍五入,保留小数点后0位就行了

别忘了输入的t是秒数!

```cpp
t=read();
printf("%.0Lf\n",ans*60.0L/t);
```

### 代码:

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
using namespace std;
typedef long long ll;
#define N 111110
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
string a[N],s[N];
char tmpa[N],tmps[N];
int n,m,t;
ll ans;
int main(){
	while(getline(cin,a[++n]),a[n]!="EOF");
	while(getline(cin,s[++m]),s[m]!="EOF");
	n--;m--;
	for(int i=1;i<=min(n,m);i++){
		int lens=s[i].length();
		int lena=a[i].length();
		int nowa=0,nows=0;
		for(int j=0;j<lens;j++){
			if(s[i][j]=='<'){
				nows--;
				nows=max(nows,0);
				tmps[nows]=0;
			}
			else{
				tmps[nows]=s[i][j];
				nows++;
			}
		}
		for(int j=0;j<lena;j++){
			if(a[i][j]=='<'){
				nowa--;
				nowa=max(nowa,0);
				tmpa[nowa]=0;
			}
			else{
				tmpa[nowa]=a[i][j];
				nowa++;
			}
		}
		for(int j=0;j<min(nows,nowa);j++){
			if(tmpa[j]==tmps[j])ans++;
		}
	}
	t=read();
	printf("%.0Lf\n",ans*60.0L/t);
	return 0;
}
```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!


---

## 作者：Randolph、 (赞：2)

[P5587 打字练习](https://www.luogu.org/problem/P5587)

想发一篇较为简洁易懂的题解，代码看起来长，实际上还是很好理解的，而且很多对称着写就行了

一道字符串签到题，比赛的时候小蒟蒻~~调了一个小时都没调出来~~一直RE，坑点还是不少的~~（主要是我太水了）~~

1. 听其他题解中说后50%的数据是范文中也有退格键的情况

2. 边比较边判断退格键是不行的，因为可能有多个退格键，删的不止当前的字符（边做边判断似乎也会WA后50%数据），可以用栈

3. 计算时间t的时候应转为double再除以60，否则t<60时整除60为0，答案除以t会RE

如果使用字符数组的话可以用gets与strlen，但是the `gets' function is dangerous and should not be used.，似乎会WA一些点

做了这题对字符串的读入等操作基础还是有所巩固的。。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<stack>
using namespace std;
string a[10005],b[10005];
stack<char> aa,bb;//储存去除退格后的字符
int n,m,cnt,t,al,bl;
int main() {
	for (n=1; ; n++) {
		getline(cin,a[n]);
		if (a[n][0]=='E' && a[n][1]=='O' && a[n][2]=='F' && a[n][3]=='\0') break;
	}
	for (m=1; ; m++) {
		getline(cin,b[m]);
		if (b[m][0]=='E' && b[m][1]=='O' && b[m][2]=='F' && b[m][3]=='\0') break;
	}

	for (int i=1; i<n; i++) {
		al=a[i].size(),bl=b[i].size();

		while(!aa.empty()) aa.pop();
		while(!bb.empty()) bb.pop();

		for (int j=0; j<al; j++)
			if (a[i][j]=='<') {
				if (!aa.empty())
					aa.pop();
			} else aa.push(a[i][j]);//先扫一遍字符串，处理退格，将去除退格后的字符串存入栈
            
		for (int j=0; j<bl; j++) 
			if (b[i][j]=='<') {
				if (!bb.empty())
					bb.pop();
			} else bb.push(b[i][j]);

		while(aa.size()<bb.size()) bb.pop();
		while(aa.size()>bb.size()) aa.pop();//调为相同长度再比较

		while(!aa.empty()) {
			if (aa.top()==bb.top()) cnt++;//统计答案
			aa.pop(),bb.pop();
		}
	}

	scanf("%d",&t);
	double time=1.0*t/60;
	printf("%d",(int)(cnt/time+0.5));//四舍五入
}
```


---

## 作者：高木木 (赞：2)

关于这道题我真的不想说什么了QAQ

本人提交了整整一页的这个题才终于过！关于这个题的有关细节，跟大家分享一下。

1、首先就是 RE 的问题，我提交十几次除了最后两次每次都是RE九个点得十分，甚至RE十个点。。起初我以为是我string数组大小没开够，后来才知道是判退格的时候数组下标有时是负的导致RE，改进方法后如下：

我们可以用 ans 表示样本每行的光标的位置，遇到退格时光标往后退一格，不是退格就随着输入往后加（可以简单模拟一下输入时的光标的移动），这样最后只需判断光标前的字符是否相等就可以了。

2、读入问题，由于空格也在比较的范围内，可以用getline输入。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
string a[100001],b[100001];// a是第一个样本，b是第二个样本。
int num=0,num2=0,num1,sum,t;
int main()
{
	while(1)
	{
		getline(cin,a[num]);
		if(a[num]=="EOF") break; // 输入碰到‘EOF’就直接break掉
		num++;
	}
	while(1)
	{
		getline(cin,b[num1]);
		if(b[num1]=="EOF") break;
		num1++;
	}
	cin>>t;// 时间
	int num2=min(num,num1);// 根据题面意思，比较时多余的行被忽略，因此取num和num1的最最小值。
	for(int i=0;i<num2;i++)
	{
		char aa[100001],bb[100010];
		int ans1=0,ans2=0,s1=a[i].size(),s2=b[i].size();// ans1、ans2分别表示第一个样本和第二个样本的光标的位置
		for(int j=0;j<s1;j++)
		{
			if(a[i][j]=='<')// 如果是退格，光标不用加还要往后移。
			{
				ans1=max(0,ans1-1);
				continue ;
			}
			aa[ans1]=a[i][j];// 不是退格随着输入往后加
			ans1++;
		}
		for(int j=0;j<s2;j++)
		{
			if(b[i][j]=='<')
			{
				ans2=max(0,ans2-1);
				continue ;
			}
			bb[ans2]=b[i][j];
			ans2++;
		}
		for(int j=0;j<min(ans1,ans2);j++)// 逐行比较，去掉多余的列
		{
			if(aa[j]==bb[j]) sum++;
		}
	}
	double k=(sum*60)/t;
	cout<<round(k);// round（）四舍五入输出。
	return 0;
}// aabbb
```


---

## 作者：brealid (赞：2)

时间冲突，没能参加月赛，比较可惜。

来发一下这题的题解：

按题意模拟即可，具体坑点不是特别多，主要需要注意**样例文本中也有删除符号`<`**

另外一些边界条件（`<` or `<=`）需要根据自己的程序调节

### Code

```cpp
/*************************************
 * problem:      P5587 打字练习.
 * user ID:      63720.
 * user name:    Jomoo.
 * time:         2019-10-13.
 * language:     C++.
 * upload place: Luogu.
*************************************/ 

#include <bits/stdc++.h>
using namespace std;

int n1 = 0, n2 = 0, T, cnt = 0;
string sample[10007];
string R[10007];

void deal(string &a)
{
    static size_t i, j;
    for (i = 0, j = 0; i < a.length(); i++, j++) {
        if (a[i] == '<') {
            if (j) j--;
            j--;
        } else a[j] = a[i];
    }
    a = a.substr(0, j);
}
// 处理字符串 a (即处理 '<')

int main()
{
    getline(cin, sample[++n1]);
    while (sample[n1] != "EOF") {
        getline(cin, sample[++n1]);
    }
    getline(cin, R[++n2]);
    while (R[n2] != "EOF") {
        getline(cin, R[++n2]);
    }
    cin >> T;
    for (int i = 1; i < min(n1, n2); i++) {
    	// 我的程序中存储了 "EOF"，所以上面是 "<"
        deal(sample[i]);
        deal(R[i]);
        for (size_t j = 0; j < min(sample[i].length(), R[i].length()); j++) cnt += (sample[i][j] == R[i][j]);
    }
    cout << (cnt * 60 / T);
    return 0;
}
```

---

## 作者：Meatherm (赞：2)

似乎数据没卡这个神奇的做法...

思路就是直接字符串，乱搞。碰到一个 `<` 就把它前面的字符删除。

感觉理论上一个长 $s$ 的字符串删除子串的复杂度是 $O(s)$？那应该被卡爆的啊。不过并没有爆...是数据水吗

具体看代码吧

```cpp
# include <bits/stdc++.h>
# define rr register
const int N=10010;
std::string a[N],b[N];// a[] 范文 b[] 输入
int n,m;
double T;
int sum;
double ax;
int main(void){
	std::ios_base::sync_with_stdio(false);
	std::cin.tie(0);
	std::cout.tie(0);//cin的蜜汁优化
	std::string x;
	while(1){
		getline(std::cin,x);//由于可能会有空格 所以需要 getline
		if(x=="EOF")
			break;
		a[++n]=x;	
	}
	while(1){
		getline(std::cin,x);
		if(x=="EOF"){
			break;
		}
		b[++m]=x;
	}
	std::cin>>T;
	for(rr int i=1;i<=n;++i){
		do{
			int Index=a[i].find("<",0);
			if(Index==std::string::npos){
            /*
            find(substr,st) 可以找出从 st 开始 substr 第一次出现的位置，找不到就返回 std::string::npos
            */
				break;
			}
			if(!Index)//特判一下无效的退格键
				a[i].erase(Index,1);
			else
				a[i].erase(Index-1,2);	
		}while(1);
	}
	for(rr int i=1;i<=m;++i){
		do{
			int Index=b[i].find("<",0);
			if(Index==std::string::npos){
				break;
			}
			if(!Index)
				b[i].erase(Index,1);
			else
				b[i].erase(Index-1,2);
		}while(1);
	}
	for(rr int i=1;i<=std::min(n,m);++i){
		int alen=a[i].length(),blen=b[i].length();
		for(rr int j=0;j<std::min(alen,blen);++j){
			if(a[i][j]==b[i][j]){
				++sum;
			}
		}
	}
	ax=double(sum);
	printf("%.0lf",ax/(T/60));
	return 0;
}
```

---

## 作者：Setsugesuka (赞：1)

调了 $2h$ ，自闭逛讨论区的时候才发现原来题面改了，范文也有退格键。

我们用 $s1$ 和 $s2$ 存处理好退格键的范文和输入的文章。

注意范文和输入的文章一样，如果已经没有字符可以退格了，就不退格。

$string$ 可以很好地解决这个问题，它自带了 $popback$ 与 $pushback$ 函数。

```cpp
#include <bits/stdc++.h>
using namespace std;

template <class T>
inline bool read(T &ret)
{
    char c;
    int sgn;
    if (c = getchar(), c == EOF)
    {
        return 0;
    }
    while (c != '-' && (c < '0' || c > '9'))
    {
        c = getchar();
    }
    sgn = (c == '-') ? -1 : 1;
    ret = (c == '-') ? 0 : (c - '0');
    while (c = getchar(), c >= '0' && c <= '9')
    {
        ret = ret * 10 + (c - '0');
    }
    ret *= sgn;
    return 1;
}

template <class T>
inline void write(T x)
{
    if (x > 9)
    {
        write(x / 10);
    }
    putchar(x % 10 + '0');
}

const int MAXN=100010;

string s1[MAXN],s2[MAXN];
string s[MAXN];
int t,cnt1=0,cnt2=0,tot=0;
string sr;

int main()
{
    while(getline(cin,sr))
    {
        if(sr=="EOF")
            break;
        s[++cnt1]=sr;
    }
    for(int i=1;i<=cnt1;i++)
    {
        sr.clear();
        int ccsz=s[i].size();
        for(int j=0;j<ccsz;j++)
        {
            if(s[i][j]=='<')
            {
                if(!sr.empty())
                    sr.pop_back();
            }
            else
                sr.push_back(s[i][j]);
        }
        s1[i]=sr;
    }
    while(getline(cin,sr))
    {
        if(sr=="EOF")
            break;
        s[++cnt2]=sr;
    }
    for(int i=1;i<=cnt2;i++)
    {
        sr.clear();
        int ccsz=s[i].size();
        for(int j=0;j<ccsz;j++)
        {
            if(s[i][j]=='<')
            {
                if(!sr.empty())
                    sr.pop_back();
            }
            else
                sr.push_back(s[i][j]);
        }
        s2[i]=sr;
    }
    for(int i=1;i<=min(cnt1,cnt2);i++)
    {
        int sz1=s1[i].size(),sz2=s2[i].size();
        for(int j=0;j<min(sz1,sz2);j++)
        {
            if(s1[i][j]==s2[i][j])
                tot++;
        }
    }
    cin>>t;
    tot=(int)((double)((double)tot/(double)t)*(double)60);
    cout<<tot<<endl;
    return 0;
}
```


---

## 作者：珅肐 (赞：1)

来(~~吐槽一下这个题~~)写一篇题解

比赛的时候已经晚了，只做了大半个小时

本来挺简单的一个题，我却交了$20$多遍还没过，

为什么范文里有退格键哇！

咳咳开始正题：

简述题意：给两段文本，比较相同的字符数。比较方式为先逐行、再逐字，多余的行去掉，而且读入过程中可以删去一些字符，用'<'表示。

按照题意模拟

因为行与行之间互不关联，我们存下来一行一行做就好

核心主要是处理退格键的问题，

我们开一个辅助数组$c$，来储存最终修改好的序列。

遍历每一行文本，如果不是退格键就将$c$数组赋值，

是退格键就让下标减一，注意判断下标不能为负

### 详见代码：
```cpp
#include<iostream>
#include<cstdio>
#include<ctype.h>
#include<cstring>
using namespace std;
inline int read(){//快读，因为只有读到数字才会停止，这里用来处理多余的行
	int x=0,f=0;char ch=getchar();
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return f?-x:x;
}
string s[10007];//储存范文数组
char c[100007],cc[100007];
int main(){
	int n=1,ans=0;getline(cin,s[n]);//注意每次要读一行，可能有空格，这里使用getline
	while(s[n]!="EOF")++n,getline(cin,s[n]);//读入不定行，到EOF停止
	for(int i=1;i<n;++i){//注意小于n，去掉最后的EOF
		string a;getline(cin,a);
		int l=a.length(),ll=s[i].length(),k=0,kk=0;
        if(a=="EOF")break;
		for(int j=0;j<l;++j,++k)//处理打出的序列
			if(a[j]=='<' && k>0)k-=2;//因为循环每次++k，所以这里-2
			else if(a[j]!='<')c[k]=a[j];//赋值操作
			else --k;//否则说明当前在第一列，无法删除，--k抵消这步操作
		for(int j=0;j<ll;++j,++kk)//处理范文序列，同上
			if(s[i][j]=='<' && kk>0)kk-=2;
			else if(s[i][j]!='<')cc[kk]=s[i][j];
			else --kk;
		l=min(k,kk);//记录范文和打字的最短长度，因为往后一定不会相等
		for(int j=0;j<l;++j)ans+=cc[j]==c[j];//累计贡献
	}
	int t=read();//读入时间，顺便把多余的行处理掉
	printf("%d\n",ans*60/t);
	//这里没有卡四舍五入，应该写"%.0lf",ans*60.0/t+0.5的
	//0.5是必须加的，众所周知，"%.0lf",0.5是会输出0的
    return 0;//好习惯
}
```

~~出题人这种行为是不是不负责任哇~~

~~题目违背常识还不加提示~~

~~你告诉我范文里怎么显示退格键吖~~


---

## 作者：Provicy (赞：1)

$Luogu$ $10$月月赛$div.2$的$T1$

这题是一个比较简单的模拟题，我们需要模拟一个文本匹配的功能，但是这个功能带有后悔性，即为题目中所说的退格键。

我们考虑将读入的字符串用一个二维$char$数组记录。

如果没有退格键，显然我们按位比较即可，但是退格键有些麻烦，我们需要一些简便的处理方法。

本人采用的方法是倒序存储，比较的时候再倒序比较。这样我们可以方便处理对于一串连续的退格键我们要将光标前移至哪个位置，其实现如下：

```cpp
while(i>=0)//i初始为字符串的长度-1，即字符串最后一个字符的下标
{
    if(t[i]!='<') book[++now]=t[i],i--;//不是退格键，就用book数组将其存入
    else//否则进行退格键处理
    {
        int al=0;
        while(t[i]=='<') {i--,al++; if(i<0) break;}//对于连续的退格键，我们直接统一处理，al记录有几个退格键
        i-=al;//往前移al，这一段的字符都不存在了
    }
}
```
比较时我们从$now$开始倒序比较即可。

这样交了一发$10$分$RE$，搞了一会儿发现$book$数组是$string$类型的，然后变成$50$分。（然后题面被悄悄改了$QwQ$？）

发现题目没说文本串中不可用退格键，于是在文本串中也如此操作，存进记录文本串的数组时再倒序存储即可，然后终于$AC$了。

最后献上蒟蒻的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10005;
int ans,wcnt=1,T;
char s[N][100005],t[100005],book[100005];
inline int read()
{
	int s=0,w=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar(); return s*w;
}
int main()
{
	cin.getline(t,100005);
	int i=strlen(t)-1,now=0;
	while(i>=0)
	{
		if(t[i]!='<') book[++now]=t[i],i--;
		else
		{
			int al=0;
			while(t[i]=='<') {i--,al++; if(i<0) break; }
			i-=al;
		}
	}
	int j=0;
	for(int i=now;i;i--) s[1][j++]=book[i];
	for(;cin.getline(t,100005);)
	{	
		wcnt++;
		if(t[0]=='E') break;
		int i=strlen(t)-1,now=0;
		while(i>=0)
		{
			if(t[i]!='<') book[++now]=t[i],i--;
			else
			{
				int al=0;
				while(t[i]=='<') {i--,al++; if(i<0) break;}
				i-=al;
			}
		}
		int j=0;
		for(int i=now;i;i--) s[wcnt][j++]=book[i];
	}
	for(int i=1;i<wcnt;i++)
	{
		cin.getline(t,100005);
		int lens2=strlen(s[i]);
		int lens1=strlen(t);
		int j=lens1-1,now=0;
		while(j>=0)
		{
			if(t[j]!='<') book[++now]=t[j],j--;
			else
			{
				int al=0;
				while(t[j]=='<') {al++,j--;if(j<0) break;}
				j-=al;
			}
		} j=0;
		for(int k=now;k;k--) if(s[i][j++]==book[k]) ans++;
	} 
	T=read();
	double KPM=1.0*((double)ans)*60.0/((double)T);
	printf("%d\n",(int)round(KPM));
	return 0;
}
```


---

## 作者：萧萧尹 (赞：1)

# 模拟+string类函数应用
## 坑点
~~我发现很多人和我一样交到想骂人仍只拿50pts~~先写点干货

1.**范文和输入文本都有退格键！！！**（刚才时题目描述保证范文没有 后来它死了~~出题人请无视~~）

具体来说 前5个点范文没有退格键 后5个点有

2.关于换行键是真点没用

3.退格键会在一行的开头 还能连续多个连续好多个！！

4.输出时可能被0除 我们假设时间为t(秒) 正确字符数为sum

如果我们这样做
```cpp
	t/=60;
	cout<<sum/t;
```
当t=30时 我们就死了（一般表现为RE）

于是我们这样干
```cpp
	sum*=60;
	cout<<sum/t;
```
（~~原理不用我再赘述了吧~~）

5.getline读入....（有空格）

## 思路（模拟）比对计数

我们假令sd[]数组表示范文输出 s[]数组表示R君输入（string类型数组）

在输入两个数组的同时预处理好范文和输出

即将退格键删掉

### 预处理
具体实现如下（n为范文行数）

```cpp
	while(1)
	{
		getline(cin,sd[++n]);//getline读入可将空格读入 
		if(sd[n]=="EOF") 
		{
			n--;//因为n是范文行数 
			break;	
		}		
		while(sd[n][0]=='<')
		//处理一行开头就出现"<"的情况
		//可能出现多个"<" 所以用while循环  
		{
			int p=sd[n].length();
			sd[n]=sd[n].substr(1,p-1);	
			//substr截取字符  
			//string s=s.substr(从哪处开始截取(包括该处)，截取的长度)		
		}
		string flag="<";
		int pos=0;
		//从头寻找"<"位置 
		while((pos=sd[n].find(flag,pos))!=string::npos)
		//是否存在
		//find函数 返回第一个flag的下标 
		{
			int p=sd[n].length();
			sd[n]=sd[n].substr(0,pos-1)+sd[n].substr(pos+1,p-pos-1);
			//截取"<"前后两端字符 
			pos--;
			//当你处理完一次该行时 原字符长度-2 
			//所以我们的位置pos需要--来适应变化 以防下次寻找遗漏  
		}
	}
```
对R君输入的处理类似 不再赘述
### 比对计数

```cpp
	int stdlen=min(n,m);//取行数少者 
	int sum=0;//sum计数 
	for(int i=1;i<=stdlen;i++)//一行一行比对 
	{
		int minlen=min(sd[i].length(),s[i].length());
		//取该i行范文和R君输入最短长度 
		for(int j=0;j<minlen;j++)
		{
			if(sd[i][j]==s[i][j]) sum++;//相同计数 
		}
	}
```
### 输出 
大功告成！！！

AC代码奉上

```cpp
#include <iostream>
#include <cstdio>
#include <string.h> 
#include <cmath>
using namespace std;
int t;
string sd[10005],s[10005];
int main()
{
	int n=0,m=0;
	while(1)
	{
		getline(cin,sd[++n]);//getline读入可将空格读入 
		if(sd[n]=="EOF") 
		{
			n--;//因为n是范文行数 
			break;	
		}		
		while(sd[n][0]=='<')
		//处理一行开头就出现"<"的情况
		//可能出现多个"<" 所以用while循环  
		{
			int p=sd[n].length();
			sd[n]=sd[n].substr(1,p-1);	
			//substr截取字符  
			//string s=s.substr(从哪处开始截取(包括该处)，截取的长度)		
		}
		string flag="<";
		int pos=0;
		//从头寻找"<"位置 
		while((pos=sd[n].find(flag,pos))!=string::npos)
		//是否存在
		//find函数 返回第一个flag的下标 
		{
			int p=sd[n].length();
			sd[n]=sd[n].substr(0,pos-1)+sd[n].substr(pos+1,p-pos-1);
			//截取"<"前后两端字符 
			pos--;
			//当你处理完一次该行时 原字符长度-2 
			//所以我们的位置pos需要--来适应变化 以防下次寻找遗漏  
		}
	}
	while(1)
	{
		getline(cin,s[++m]);
		while(s[m][0]=='<')
		{
			int p=s[m].length();
			s[m]=s[m].substr(1,p-1);			
		}
		if(s[m]=="EOF") 
		{
			m--;
			break;	
		}
		string flag="<";
		int pos=0;
		while((pos=s[m].find(flag,pos))!=string::npos)
		{
			int p=s[m].length();
			s[m]=s[m].substr(0,pos-1)+s[m].substr(pos+1,p-pos-1);
			pos--;
		}
	}
	int stdlen=min(n,m);//取行数少者 
	int sum=0;//sum计数 
	for(int i=1;i<=stdlen;i++)//一行一行比对 
	{
		int minlen=min(sd[i].length(),s[i].length());
		//取该i行范文和R君输入最短长度 
		for(int j=0;j<minlen;j++)
		{
			if(sd[i][j]==s[i][j]) sum++;//相同计数 
		}
	}
	cin>>t;
	sum*=60;
	cout<<sum/t;
	while(1); 
	return 0;
}
```
### 最后一点说明
1.代码风格个性化 请各位见谅

2.思路非常非常非常普通平常不入流 ~~勿喷~~

3.各路大神 请洒潘江，各倾陆海云尔

### 4.第二篇假题解 管理求过！！

---

## 作者：hgoicjl (赞：1)

#### 在[博客](https://www.luogu.org/problem/P5587)内体验更佳

---
### 题意：
给你两篇文章

通过逐行比较和逐位比较的方式

判断第二篇文章对于第一篇匹配的字符的个数

### 算法：
字符串处理 模拟

---

### 前置知识1：

getline可以获取一行字符串(包括前导及行内空格,但不包括回车)

而传统的cin和scanf读入到空格便会停下

以下是getline用法的样例
```cpp
//getline(cin,inPutLine);

string str;
getline(cin,str);//将一行读到str字符串中
```
### 前置知识2：
string类的初始化内置函数size()与erase()

string类可以通过string(num,char)的方式来初始化化

例如
```
string str(3,'a');//与string str="aaa"等价

char ch='b';
string str(2,ch);//与string str="bb"等价
```

size()函数可以返回一个字符串的长度,与length()函数等价

以下是size()的用法
```
string str="123456";
cout<<str.size()<<endl;//输出为6
```
erase(begin,len)函数可以删除string类的从begin位置(下标)开始len个字符

比如
```
string str="abcdefg";
str.erase(3,2);
//str="abcfg"
```
---
~~我们就可以愉快的模拟了~~
```
#include<bits/stdc++.h>
using namespace std;
string fw[100005];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int correct=0;
	int pos=1;
	while(true)
	{
		string s;
		getline(cin,s);
		if(s=="EOF")//EOF表示文章的结尾
			break;
		for(int i=0;i<s.size();i++)
		{
			while(s[0]=='<')//删除行头的'<'
				s.erase(0,1);
			if(s[i]=='<')//当遇到'<'是删掉'<'及前面的一个字符
			{
				s.erase(i-1,2);
				i=0;
			}
		}
		fw[pos]=s;
		pos++;
	}
	pos=1;
	while(true)
	{
		string s;
		getline(cin,s);
		if(s=="EOF")
			break;
		for(int i=0;i<s.size();i++)
		{
			while(s[0]=='<')
				s.erase(0,1);
			if(s[i]=='<')
			{
				s.erase(i-1,2);
				i=0;
			}
		}//同上处理'<'
		for(int i=0;i<min(fw[pos].size(),s.size());i++)//与范文对应的行比较
			if(s[i]==fw[pos][i])//逐位比较
				correct++;
		pos++;
	}
	int t;
	cin>>t;
	cout<<(int)((correct*60)/(t*1.0)+0.5)<<endl;//四舍五入
	return 0;
}
```

---

## 作者：Leianha (赞：1)

## 模拟

[更好的阅读体验](https://www.cnblogs.com/wljss/p/11667692.html)

题意很清晰，需要我们模拟一下计算正确的单词的个数。对于"<"我们退格处理。正解好像需要用类似栈的数据结构来维护，但并不卡常，直接模拟也可以。

说一下几个注意事项：

1.范文里面有"<",并不是我们需要打上"<",而是删除范文里的内容。（详见代码）

2.对于一整行并且还有空格的输入，我们不能用cin和scanf，因为它们不能读取空格，我们需要用getline 来读取一整行，就像下面这样：
```cpp
while (getline(cin, a[++n])) 
{
	......
}
```
3.范文和输入的行数可能并不相等，也就是说范文里面行数可能比输入里面多，不能当成一样的，否则会TLE一个点。

4.防止数组的负下标。

最后献上我~~丑陋~~的代码

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
using namespace std;
int n, m , ans, t, siza, sizb;
const int N = 1001000;
string a[N], b[N];
int siz1[N], siz2[N];
bool pan1[N], pan2[N];
int main() 
{
	while (getline(cin, a[++n])) 
	{
		if (a[n][0] == 'E' && a[n][1] == 'O' && a[n][2] == 'F')break;
		siz1[n] = a[n].size();
	}
	while (getline(cin, b[++m])) 
	{
		if (b[m][0] == 'E' && b[m][1] == 'O' && b[m][2] == 'F')break;
		siz2[m] = b[m].size();
	}
	for (int i = 1; i <= n; ++i) 
	{
		memset(pan1, 0, sizeof(pan1));
		memset(pan2, 0, sizeof(pan2));
		siza = a[i].size(); sizb = b[i].size();
		if (i == n || i > m)break;
		for (int j = 0; j < siza; ++j) 
		{
			if (a[i][j] == '<') 
			{
				int k = j;
				pan1[j] = 1;
				for (; k >= 0; --k)if (!pan1[k])break;
				if (k >= 0)pan1[k] = 1;
			}
		}
		for (int j = 0; j < sizb; ++j) 
		{
			if (b[i][j] == '<') 
			{
				int k = j;
				pan2[j] = 1;
				for (; k >= 0; --k)if (!pan2[k])break;
				if (k >= 0)pan2[k] = 1;
			}
		}
		for (int j = 0, now = 0; j < sizb && now < siza; ++j, ++now) 
		{
			while (pan1[now] && now < siza)++now;
			while (pan2[j] && j < sizb)++j;
			if (now >= siza || j >= sizb)break;
			if (a[i][now] == b[i][j])++ans;
		}
	}
	cin >> t;
	printf("%d", (int)((double)ans / ((double)t / 60)));
	return 0;
}
```


---

## 作者：盧鋅 (赞：0)

## 又是一道大模拟
思想没有什么好说的，模拟就好了，两个指针（数组下标）来统计。（有人说这题好水，实际上很坑比）

```
逐行比较，即对于范文和输入的每一行依次比较，不同行之间不会产生影响，多余的行会被忽略。
逐位比较，即对于两行的每一个字符依次比较，当且仅当字符相同时才会被算作一次正确，否则会被算作错误。计算答案时，只统计相同的字符个数。
```
逐行比较，可以选择先读入范文，然后~~在线~~去计算字数

很明显，逐位比较就是两个指针（数组下标）比较，point 1和point 2就好了。

最恶心的就是范文里有<????(**爆50的原因**)

模拟题也没什么好说的了，答案**四舍五入**保留整数部分。

代码大家完全可以自己实现，string比较方便。

另外换行符，好像没什么好说的，退格emmm（鄙人不确定出题人会不会把正确的字母删掉换成错误的）。

---

## 作者：氷芽川四糸乃 (赞：0)

这题有个坑点，范文中也是可以出现**退格**的，这也是那么多人爆50的原因。

解决了这个问题后，就基本上变成一个简单的模拟了。

我的做法比较暴力：~~没用getline 直接模拟，一堆if~~

读入时单字符读入，存入一个char数组中，读入一个size++，如果遇到退格符，会出现两种情况：

1.删去前面的一个字符。

2.无字符可删。

对于1的话，直接size-=2就好了，下次读入会覆盖数据。

2的话，特判第一行，然后判断前一个字符是不是换行，是的话就size-=1

这样读入就完成了，两个数组里存的都是无退格的文章。

然后就可以用40分做法来解了

我的思路是，模拟两个指针扫过这两个字符数组，如果有其中任何一个碰到换行符，那么就代表这行结束了，把另一个指针移到当前后面最近的换行符后就好了。

最后放上带注释代码，便于理解

```cpp
#include <bits/stdc++.h>
double T;
char s1[100010];
char s2[100010];
int sizes1=0,sizes2=0;
int ans=0;
void read(int mode)
{
	while(true)
	{
		if(mode==1)
		{
			sizes1++;
			s1[sizes1]=getchar();

			if(s1[sizes1]=='<'&&(s1[sizes1-1]=='\n'||sizes1==1))//无字符删的情况，直接吧size-1(去掉退格符&&特判不为第一行)
			{
				sizes1-=1;
				continue;
			}
			if(s1[sizes1]=='<'&&s1[sizes1-1]!='\n')//有字符可删
			{
				sizes1-=2;
				continue;
			}
		}
		else
		{
			sizes2++;
			s2[sizes2]=getchar();

			if(s2[sizes2]=='<'&&(s2[sizes2-1]=='\n'||sizes2==1))
			{
				sizes2-=1;
				continue;
			}
			if(s2[sizes2]=='<'&&s2[sizes2-1]!='\n')
			{
				sizes2-=2;
				continue;
			}
		}
		if(mode==1&&sizes1>=3&&s1[sizes1-2]=='E'&&s1[sizes1-1]=='O'&&s1[sizes1]=='F')
			break;
		if(mode==2&&sizes2>=3&&s2[sizes2-2]=='E'&&s2[sizes2-1]=='O'&&s2[sizes2]=='F')
			break;
	}
}
int main ()
{
	read(1);
	getchar();//去掉第一次输入末尾换行符
	read(2);
	getchar();
	scanf("%lf",&T);
	sizes1-=4;//去掉EOF以及EOF前上一行的换行符
	sizes2-=4;
	int i=1,j=1;
	while(true)
	{
		if(j>sizes2)//输入的文章匹配完了
			break;
		if(s1[i]=='\n'&&s2[j]!='\n')//处理换行
		{
			j++;
			continue;
		}
		if(s2[j]=='\n'&&s1[i]!='\n')
		{
			i++;
			continue;
		}
		if(s2[j]==s1[i]&&s1[i]!='\n'&&s2[j]!='\n')//记录答案
		{
			ans++;
		}
		i++;
		j++;
	}
	printf("%d\n",int((ans)/(T/60)));//输出KPM
	return 0;
}
```

---

## 作者：xiejinhao (赞：0)

# P5587 打字练习 题解 

>## 本文同步发布于 [$My Blog$](https://www.cnblogs.com/Ning-H/p/11666629.html)



------------

写在前面
------------


众所周知，这是一篇题解，而且是一篇黄题的题解……

它来自洛谷月赛……但是做的时候题目是不是不太一样呢 $QAQ$ ？

传送门点这里：[打字游戏](https://www.luogu.org/problem/P5587?contestId=22026)，笔者写下这篇题解，希望帮助到更多的人



------------

题解部分
------------


- ###  直观想法

很明显思路就是你碰到一个字符后面带有'<'就不要这个字符，可以额外开个字符串存下，最后复制

但是仔细思考一下，这是不可行的，因为可能有多个‘<’连在一起。

如果还按照上面那种方式模拟，个人没有想到有什么好的办法。所以我们可能需要优化一下。

- ###   思路改进

一开始按照上面那种想法打了个 $50$ 分，才想到是不正确的。

然后我就想到了按照链表的方式，对于一些删除'<'，我们只需要把最前面删掉的字符跳掉第一个没有被删掉的字符的地方就可以。因此我才用了一个 $pre$ 数组记录这个删除最多延伸到哪一个字符，还有一个 $Next$ 数组，作为指针把最前面那个被删除的直接跳到第一个没被删除的，全部处理完后再进行模拟取字符即可。

- ### 实现细节

很明显上面这个方案是可行的。具体想想怎么实现，如何更新 $pre$ 和 $Next$ 两个数组。

下面约定我们每一行的字符串从第一位开始，以便操作。

扫描每一行 $i$，首先对于我们碰到的一个删除（位置为 $j$），可能有几种情况：

1. 是第一个 字符，那么 $pre[j]=1$，$Next[j]=j+1$（其实就是$j=1$）的情况；

2. 不是第一个字符，但是 $pre[j-1]$不为0。这说明前面的删除是连续的，所以我们要多删除一个字符。

那么怎么操作呢？其实很简单，你只要：$pre[j]=pre[j-1]-1$，$Next[pre[j]]=j+1$即可。

到这里就会有人有疑问了，为什么总是让 $Next[]=j+1$？

那么我们继续考虑，如果j+1仍然是删除，那么 $Next$ 必定会跳到再下一位，否则 $j+1$ 即为答案。

但是要注意特判 $pre[j-1]-1=0$ 的情况，此时应直接赋值为 $1$。

3. 不是第一个字符，且$pre[j-1]=0$，那么直接让 $pre[j]=j-1,Next[pre[j]]=j+1$即可。

- 然后我们就完成了本题。如果还有不理解的，请结合代码理解下吧：


$Code:$ 
------------

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 10;
string a[N], b[N], x, y;
int Next[N], pre[N];
int main() {
    int n = 0, m = 0; 
    for(int i = 1; ; i++) {
        getline(cin, x);
        if(x == "EOF") break;
        a[++n] = x;
    }
    
    for(int i = 1; ; i++) {
        getline(cin, x);
        if(x == "EOF") break;
        b[++m] = x;
    }
    
    for(int i = 1; i <= n; i++) {
        memset(Next, 0, sizeof Next);
        memset(pre, 0, sizeof pre);
        int size = a[i].size();
        y = a[i], x = " " + a[i], a[i] = x, x = ""; 
        bool flag = 0;
        for(int j = 1; j <= size; j++) 
            if(a[i][j] == '<') {
                if(j == 1) pre[j] = 1;
                else if(pre[j - 1]) {
                	if(pre[j - 1] > 1)
                		pre[j] = pre[j - 1] - 1;
                	else pre[j] = 1;
				} else if(!pre[j - 1])
                	pre[j] = j - 1;
                Next[pre[j]] = j + 1;
                flag = 1;
            }
            
        if(flag == 0) {
            a[i] = y;
            continue;
        }
        for(int j = 1; j <= size; j++) {
            if(!Next[j]) x += a[i][j];
            else j = Next[j] - 1;
        }
        a[i] = x;
    }
    
    for(int i = 1; i <= n; i++) {
        memset(Next, 0, sizeof Next);
        memset(pre, 0, sizeof pre);
        int size = b[i].size();
        y = b[i], x = " " + b[i], b[i] = x, x = ""; 
        bool flag = 0;
        for(int j = 1; j <= size; j++) 
            if(b[i][j] == '<') {
                if(j == 1) pre[j] = 1;
                else if(pre[j - 1]) {
                	if(pre[j - 1] > 1)
                		pre[j] = pre[j - 1] - 1;
                	else pre[j] = 1;
				} else if(!pre[j - 1])
                	pre[j] = j - 1;
                Next[pre[j]] = j + 1;
                flag = 1;
            }
            
        if(flag == 0) {
            b[i] = y;
            continue;
        }
        for(int j = 1; j <= size; j++) {
            if(!Next[j]) x += b[i][j];
            else j = Next[j] - 1;
        }
        b[i] = x;
    }
    
    int ans = 0;
    for(int i = min(n, m); i; i--) { 
		// 这里采用倒序是为了避免重复计算 min(n,m) 
        int len = min(a[i].size(), b[i].size());
        if(len == 0) continue;
        for(int j = 0; j < len; j++) 
            if(a[i][j] == b[i][j]) ans++;
        
    }
    int T; scanf("%d", &T);
    ans = (int)((double)ans * 60.0 / (double) T + 0.5);
    printf("%d", ans);
    return 0;
}
```

当然会有更加优秀的写法，不过我认为个人理解更加重要。


------------

$End$
------------



月赛的时候只拿到了 $50pts$，原因竟是月赛题面说范文里没有'<'？（难道我……？？）

我还有什么可以说的呢？……

---

## 作者：Alarm5854 (赞：0)

这道题是一道水水的模拟题，但是在比赛时由于题面有锅交了4次才过，直接模拟即可，注意在开头的时候输入`>`是没用的，直接跳过。
### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,temp,text[10001];
int t,k,yes;
int main(){
	//ios::sync_with_stdio(0);
	//cin.tie(0),cout.tie(0);
	getline(cin,s);//一开始先输入
	while(s!="EOF"){//碰到EOF为止
		temp="";
		for(int j=0;j<s.length();++j)
			if(s[j]=='<'){
				if(temp.length())//遇到退格键判断一下该行是否为空
					temp.erase(temp.end()-1);//不为空则删除最后一个
			}
			else
				temp+=s[j];//否则直接加入
		text[++k]=temp,getline(cin,s);//继续输入并储存上一行
	}getline(cin,s);//稍微压一下行输入
	for(int i=1;i<=k&&s!="EOF";++i){//这里其实是可以被hack掉的，但是由于数据太水是可以的，自己思考怎么改
		temp="";
		for(int j=0;j<s.length();++j){
			if(s[j]=='<'){
				if(temp.length())
					temp.erase(temp.end()-1);
			}
			else
				temp+=s[j];
		}//这里同上
		for(int j=0;j<min(temp.length(),text[i].length());++j)
			yes+=temp[j]==text[i][j];
		getline(cin,s);
	}
	cin>>t;
	cout<<(int)(60.0*yes/t+0.5);//四舍五入
	return 0;
}
```

---

## 作者：dread (赞：0)

### 题面描述：
$R$ 君在练习打字。

有这样一个打字练习网站，给定一个范文和输入框，会根据你的输入计算准确率和打字速度。可以输入的字符有小写字母、空格和$.$（英文句号），输入字符后，光标也会跟着移动。

输入的文本有多行，$R$ 君可以通过换行键来换行，换行后光标移动到下一行的开头。

$R$ 君也可以按退格键（为了方便，退格键用 $< $表示），以删除上一个打的字符，并将光标回移一格。特殊的，如果此时光标已经在一行的开头，则不能继续退格（即忽略此时输入的退格键）。

网站的比较方式遵循以下两个原则：

逐行比较，即对于范文和输入的每一行依次比较，不同行之间不会产生影响，多余的行会被忽略。
逐位比较，即对于两行的每一个字符依次比较，当且仅当字符相同时才会被算作一次正确，否则会被算作错误。计算答案时，只统计相同的字符个数。
需要注意的是，回车键不会被计入正确的字符个数。

$R$ 君看到网站上显示他花了 $T$秒完成了这次的打字游戏，请你计算出他的 $KPM$（$Keys\ per\ minutes$，每分钟输入的字符个数），答案四舍五入保留整数部分。

### 输入格式：
$R$ 君会依次告诉你网站的范文，他的输入和花费的时间。

其中范文和输入将会这样读入：给定若干行字符串，以单独的一行 $EOF$ 结束，其中 $EOF$ 不算入输入的文本。

最后一行一个整数 $T$，表示他打字花费了 $T$ 秒。

### 输出格式：
一行一个整数，表示 KPM。

$$$$
$$$$
### 吐槽:
- ~~不是我说，这题真是题面有锅~~
- ~~吃个饭回来题面改了~~

------------

- 切回正题，这题不就是模拟嘛
- 我们可以想象两个栈，对于$<$操作就出栈。
- 那么这道题的题解就出来了。
### 注意：
1. 如果直接输入字符串($string$)，就必须用$getline$，因为有空格输入
2. 省略$EOF$这个字符串
3. 范文的行数跟输入的行数可能不同
4. 一定要把范文的$<$操作也加上，~~我就是因为这个操作没加只拿了50分~~

## code：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
double T;
int len1 = 0, len2 = 0;
string str1[N], str2[N];
double sum = 0;

int main() {
	while(1) {
		string s;
		getline(cin, s);
		if(s[0] != 'E')	str1[++len1] = s;
		else	break;
	}
	while(1) {
		string s;
		getline(cin, s);
		if(s[0] != 'E')	str2[++len2] = s;
		else	break;
	}
	cin >> T;
	for(int i = 1; i <= len1; ++i) {
		if(i > len2)	break;
		char str3[N], str4[N];
		int x = str1[i].size(), y = str2[i].size(), top = 0, top1 = 0;
		for(int j = 0; j < x; ++j) {
			if(str1[i][j] == '<' && !top1)	continue;
			if(str1[i][j] == '<' && top1) {top1--; continue; }
			str4[top1++] = str1[i][j];
		}
		for(int j = 0; j < y; ++j) {
			if(str2[i][j] == '<' && !top)	continue;
			if(str2[i][j] == '<' && top) {top--; continue; }
			str3[top++] = str2[i][j];
		}
		for(int j = 0; j < min(top, top1); ++j)	if(str3[j] == str4[j])	sum++;
	}
	printf("%.0lf", (1.0 * sum * 60) / (1.0 * T));
	return 0;
}

```

- 如果hack我了一定要留言哦！！！

---

## 作者：轮换对称式 (赞：0)

这是第一次写题解， ~~**有点紧张**~~不足之处多多包涵


------------


题目描述：

给定一些只包含**小写字母**、空格和实心圆点的字符串，对与每一行进行匹配，如果同一行的同一个字符相同，则记为有效字符，求单位时间内有效字符的数量。



------------


这一题是一道纯粹的模拟题，但一定要注意**范文**也可以有回退！
~~话说谁家的范文还有删改的~~



------------


解题方法：

1.对于范文，可以用一个二维数组储存

2.对于输入的R君的每一行输入，直接处理


------------


下面是代码：
```cpp
#include <iostream>
#include <string.h>
#include <cstdio>
#include <math.h>
#include <algorithm>
using namespace std;
#define LL long long
#define Maxn 100000
int len = 0 , slen[10005] , ans = 0 , t;	//len记录范文行数,slen记录范文每一行的长度
char art[10005][Maxn+5] , now[Maxn+5];	//art记录范文,now记录输入字符
bool f = 0;

inline bool read()	//范文的读入
{
	char a;
	while ((a = getchar()) != 10) //ASCII码值10是换行，结束该行读入
	{
		if (a == 'E')  //文章只包含小写字母，直接判断是否为EOF
		{
			getchar(); //读入OF和换行
			getchar();
			getchar();
			return 0;
		}
		if (a == '<') //回退判断
		{
			if (slen[len] > 0) //如果该行字符多余1个则,
				slen[len]--;  //范文第len行减1
			continue;
		}
		art[len][++slen[len]] = a; //记录范文
	}
	return 1;
}


inline bool read2(int k) //R君的输入
{
	int len1 = 0; //该行长度
	char a;
	while ((a = getchar()) != 10)
	{
		if (a == 'E')
		{
			getchar();
			getchar();
			getchar();
			f = 1; //特判,输入行数小于文章行数
			return 0;
		}
		if (a == '<')
		{
			if (len1 > 0)
				len1--;
			continue;
		}
		now[++len1] = a;
	}
	for (register int i = 1 ; i <= len1 && i <= slen[k] ; ++i)
		if(now[i] == art[k][i])
			ans++;  //如果相同ans++
	return 1;
}

int main()
{
	while (++len && read());	 //读入范文
	--len;	//去掉文章输入结束的行
	for (register int i = 1 ; i <= len ; ++i) //对于范文的每一行进行判断
	{
		if (!read2(i))
			break;
	}
	if (!f) //如果输入行数大于范文行数
	{
		while (getchar() != 'F'); //读取范文前的所有字符
		getchar();
	}
	scanf("%d" , &t); //读入时间
	double min = t / 60.00 , dans = ans , sp = dans / min;
	printf("%d\n" , (int)(sp + 0.500)); //正数四舍五入+0.5后取整
	return 0;
}
```


---

## 作者：TEoS (赞：0)

~~题目不难，描述毒瘤~~

模拟是显然的了。很容易想到一个思路，用两个字符串分别存储两个文本，两行之间标记一下，然后模拟就可以了。

这题唯一的难点就是如何处理退格。显然，如果在统计答案的时候处理，难度较大，容易出锅（大佬请忽略）。因此我们可以在输入的时候处理。

用getline输入一行，用一个临时字符$cn$存储。再开一个临时字符串存储处理过后的字符串$now$。用两个指针分别指向$cn$和$now$的光标的位置，分别设为i,j，初始值均为0。

当遇到退格符时，显然应该读取$cn$的下一个字符，存储在$now$的上一个位置。此时，若$now$在行首，则位置不改变。注意，可能有连续退格键的情况，因此要用while连续判断。于是有：
```cpp
while(cn[i]=='<')
{
	i++;
	if(j)
		j--;
}
```
还有一个要注意的点，因为$now$的初始为空，若$j$超过$now$的长度，则要加长$now$的长度，可以向它加上一个空格（实际上随便什么都行），即：
```cpp
if(j>=now.size())
	now+=" ";
```
然后把对应字符存入就行了，这里可以加一个特判，实际上按照题意不特判也可以：
```cpp
if((cn[i]>='a' && cn[i]<='z')|| cn[i]=='.' || cn[i]==' ')
	now[j]=cn[i];
```
最后把$now$加在输入的字符串后面即可，记得加上换行标志（这里用大写A）。因为有可能因为退格导致需要的字符串比实际$now$的长度长，需要从$0$到$j$依次存储。这里设$a$存储范文，$b$存储输入的文本：
```cpp
for(int i=0;i<j;i++)
	a+=now[i];
a+='A';
```
退格键处理结束之后，统计答案就很简单了！每行逐位比较，若相同则答案加$1$，直到读到换行标志为止。注意处理每行剩下无用的字符。
```cpp
for(int i=0,j=0;j<b.size() && i<a.size();i++,j++)
	{
		while(a[i]!='A' && b[j]!='A')
		{
			if(b[j]==a[i])
				ans++;
			i++,j++;
		}
		while(i<a.size() && a[i]!='A')
			i++;
		while(j<b.size() && b[j]!='A')
			j++;
	}
```
统计答案后，计算也很简单。先用一个double存储，答案即为$ans/t*60$，四舍五入只要加上$0.5$，然后用int输出即可。

还有最后一点需要注意的，也就是一大堆人50分的原因：（~~我一定没看到题目曾经说了范文中没有退格~~）

### **范文中也可能有退格！！！**

最后奉上完整代码：（变量名可能和上文不同）
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
int ans,i,t;
char gg;
double kk;
string a,b,cn;
int main()
{
	while(1)
	{
		int dd=0;
		string now="";
		getline(cin,cn);
		if(cn=="EOF")
			break;
		for(int i=0;i<cn.size();i++,dd++)
		{
			while(cn[i]=='<')
			{
				i++;
				if(dd)
					dd--;
			}
			if(dd>=now.size())
				now+=" ";
			if((cn[i]>='a' && cn[i]<='z')|| cn[i]=='.' || cn[i]==' ')
				now[dd]=cn[i];
		}
		for(int i=0;i<dd;i++)
			a+=now[i];
		a+='A';
	}
	while(1)
	{
		int dd=0;
		string now="";
		getline(cin,cn);
		if(cn=="EOF")
			break;
		for(int i=0;i<cn.size();i++,dd++)
		{
			while(cn[i]=='<')
			{
				i++;
				if(dd)
					dd--;
			}
			if(dd>=now.size())
				now+=" ";
			if((cn[i]>='a' && cn[i]<='z')|| cn[i]=='.' || cn[i]==' ')
				now[dd]=cn[i];
		}
		for(int i=0;i<dd;i++)
			b+=now[i];
		b+='A';
	}//处理退格
	scanf("%d",&t);
	for(int j=0;j<b.size() && i<a.size();i++,j++)
	{
		while(a[i]!='A' && b[j]!='A')
		{
			if(b[j]==a[i])
				ans++;
			i++,j++;
		}
		while(i<a.size() && a[i]!='A')
			i++;
		while(j<b.size() && b[j]!='A')
			j++;
	}//统计答案
	kk=(double)ans/t*60;
	kk+=0.5,ans=kk;
	printf("%d",ans);//计算输出
	return 0;
}
```


---

## 作者：iceselen (赞：0)

仅以此巨唠叨的题解，纪念一场被签到题搞自闭的洛谷月赛。

[更好的阅读体验](https://iceselen.github.io/key-Lougu-P5587/)

# Lougu P5587 - 打字游戏

[原题题面](https://www.luogu.org/problem/P5587)

大意即要求你实现一段含有退格的文字匹配。

> **坑点**： 虽然题目没说，但是范文也会存在退格键!

## 本题知识点
1. 模拟。
2. `STL`的`string`类型用法。
3. 小数 -> 整数，四舍五入。

## 大体思路

1. 已经给定输入时间，要求计算KPM，只需要得到输入正确的字符总数即可。
2. 于是很明显的，这是一道有关字符串的模拟题，因为范文和输入是分开的，所以我们必须把整个范文存储起来。
3. 看了眼数据范围，总字符 ${10 ^ 5} * {10 ^ 4}$ ，直接开数组怕会炸空间 ~~（虽然最后证明并不会）~~ ，稳妥起见还是用动态分配内存的 `std::vector` 和 `std::string` 吧。
4. 然后考虑退格键的问题，需要把每一个带 '<' 的字符串转换成正确的字符串即可。
5. 接着愉快的匹配，统计正确输入的字符数，计算 KPM ，四舍五入输出，AC！

## 具体实现

### 有关string读入的细节

`string` 类是` C++` 的一个模版类，使用需要包含头文件 `#include <string>`，注意不是`<cstring>`或者`<string.h>`。

观察题目样例，可以发现给定字符串是带空格的，所以我们读入需要使用`std::getline()`函数。并且这个函数会自动忽视行末的换行符号 `'\n'`。

### 退格的实现

由于读入范文和打字内容的时候都需要处理空格，所以就写个函数吧。`string` 作为一个模版类完全是可以作为函数的参数和返回值使用的。

需要注意的是，**传入参数时候必须加 '&'**, 以传引用的方式进行，否则并不会改变原字符串。

而 `erase` 是 `string` 的擦除函数，`str.erase(0,1)`为移除字符串`str` 从第0个字符起的1个字符。

```cpp
string getright (string& thestr)
{
    for(int i = 0; i < (int)thestr.size(); ++ i) {
        while(thestr[0] == '<') thestr.erase(0,1);//处理行首退格
        if(thestr[i] == '<') {
            thestr.erase(i - 1, 2);//擦除退格前一个字符和退格字符
            i = 0;//从头再检查一次
        }
    }
    return thestr;
}
```

顺带一提，如果要调试输出，对于一个 `string` 类，`printf("%s",str)`是会报错的，需要使用`printf("%s",str.c_str())`把 `string` 类转化为字符数组。

所以对于 `string` ，不卡常的话能 `cout` 就 `cout` 吧，别和 `printf` 混用就行。

### 四舍五入

如果直接把浮点数强制类型转化为整数，浮点的小数部分会直接被丢弃，如果想要四舍五入的话就把小数 $+ 0.5$ 再输出即可。

需要注意，如果使用 `printf("%.0f",a)` 的方法来四舍五入取整，当 $a = 0.5$的时候，取整结果有可能是 $0$ ， 所以并不建议使用这种方法来四舍五入。

我这里采用了第一种方法，注意整数除法的类型问题:

```cpp
kpm = (int)((rightchar * 60 / (double)usetime) + 0.5);
```
## 代码

个人因为关键字的问题，并不是特别喜欢使用 `using namespace std` 和万能头文件。

```cpp
/*
[luogu P5587 打字练习]
2019.10.14
*/

#include <cstdio>
#include <string>
#include <iostream>
#include <vector>

using std::vector;
using std::string;
using std::getline;
using std::cin;

inline int read()
{
    int a = 0;
    char x  = getchar();
    while(x < '0' || x > '9') x = getchar();
    while(x >= '0' && x <= '9'){
        a = a * 10 + x - '0';
        x = getchar();
    }
    return a;
}

const int MAXL = 1020;
int rightchar = 0, usetime = 0, kpm = 0;
int nowline = 1;
string str, teststr;
vector <string> W[MAXL];

string getright (string&);

int main()
{
    while(true) {
        getline(cin,str);
        if(str == "EOF") break;
        getright(str);
        W[nowline].push_back(str);
        ++ nowline;
    }
    nowline = 1;
    while(true) {
        getline(cin,teststr);
        if(teststr == "EOF") break;
        str = W[nowline ++].front();
        getright(teststr);
        for(int i = 0; str[i] && teststr[i]; ++ i) {
            if(str[i] == teststr[i] && str[i]) ++ rightchar;
        }
    }

    usetime = read();
    kpm = (int)((rightchar * 60 / (double)usetime) + 0.5);
    printf("%d",kpm);
    return 0;
}

string getright (string& thestr)
{
    for(int i = 0; i < (int)thestr.size(); ++ i) {
        while(thestr[0] == '<') thestr.erase(0,1);
        if(thestr[i] == '<') {
            thestr.erase(i - 1, 2);
            i = 0;
        }
    }
    return thestr;
}
```

---

## 作者：霍士弘 (赞：0)

这道月赛div2题目还是很水的，~~橙题~~
## $40\%$做法
对于$40\%$的数据，不存在退格键。  
变成了一道红题。  
直接比较两段文本即可（逐行逐字）  
~~代码不放了，过于水。~~  
## $100\%$做法
存在换行符。  
我们发现很明显的性质：  
对于一个字符串，越晚打进来的字符越早被删掉。  

很好发现是栈的性质，所以考虑用栈来维护所有**没有被删去**的字符。  
扫一遍字符串  
①如果遇到了非`'<'`的符号，就压入栈；  
②如果遇到了`'<'`：  
- 1栈是空的（没有可以删的），啥都不做；
- 2栈不是空的（可以删），弹出栈顶元素（删掉最后打进来的字符）；  

核心代码：  
```cpp
string s;//需要处理的字符串
cin>>s;
stack<char> st;//用栈来维护
for(int i = 0;i < s.size();i++)//扫一遍字符串
{
	if(s[i] != '<')//如果不是退格符
	{
		st.push(s[i]);//压入
	}else if(s[i] == '<')//如果是退格符
	{
		if(st.empty()) continue;//空的别管（会出错）
		st.pop();//删掉最后打进来的字符
	}
}
```  
这段代码的功能就是去掉$s$里面的所有的退格符。  
然后用$40\%$的算法搞一遍处理后的字符串即可  


---

## 作者：outis_crypt (赞：0)

题目要求：比较样例文本与输入文本，统计相同字符个数，计算KPM。

**关键：对 " < " 字符的处理(样例文本和输入文本中的 " < " 都要处理)**

**处理之后直接用for循环统计相同字符个数就行了，所以关键就是处理 " < " 。**

处理过程（类似栈的思路）：是字符就存进去，遇到 " < "就把最后一个字符拿出来。

代码如下：
```cpp
string fun(string instr) {   
	string t = ""; int z = -1;  //z表示当前字符的下标位置
	for (int h = 0; h < instr.length(); h++) {
		if (instr[h] != '<') {  
			t += instr[h];    //是字符就让t加上这个字符
			z++;
		}
		else  //遇到" < "就删一个字符
		{
			if (z >= 0) {
				t.erase(z, 1);
				z--;
			}
		}
	}
	return t; //返回处理之后的字符
}
```

例如:
```
Input:
ABC<<C
EOF
ABB<C<C
EOF

处理之后：
样例文本:AC
输入文本:ABC
```

之后就是for循环，逐行比较就行了。
完整代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
using namespace std;
string text[10002], instr[10002];
string fun(string instr) {
	string t = ""; int z = -1;
	for (int h = 0; h < instr.length(); h++) {
		if (instr[h] != '<') {
			t += instr[h];
			z++;
		}
		else
		{
			if (z >= 0) {
				t.erase(z, 1);
				z--;
			}
		}
	}
	return t;
}
int main()
{
	ios::sync_with_stdio(false); //加快cin速度
	long long int i = 0;
	double t;
	getline(cin, text[i]);
	while (text[i] != "EOF") {
		getline(cin, text[++i]);
	}
	i = 0;
	getline(cin, instr[i]);
	while (instr[i] != "EOF") {
		getline(cin, instr[++i]);
	}
	cin >> t;   //前面都是输入文本
	long long int wc = 0;
	for (int j = 0; j < i; j++) {   //逐行比较
		string a = fun(text[j]);   //对"<"处理
		string b = fun(instr[j]);  //对"<"处理
		for (int k = 0; k < min(a.length(), b.length()); k++) {
			if (a[k] == b[k]) {
				wc++;   //字符相同就加一
			}
		}
	}
	cout << round(wc * 1.0 / t * 60.0) << endl; //求KPM
	return 0;
}
```


      




---

## 作者：bobby285271 (赞：0)

本蒟蒻怕是太膨胀了，两个月前才学完数组现在居然就来搞月赛，结果也就只有这题能玩玩了...

其实这题就是**模拟**，但有两个地方很坑：

* **范文**也是人敲上去的，于是**也会有退格**（?）。
* **连续地**退格。

注意到这两点之后，接下来要考虑的是**如何实现退格**。退格的本质简单来说就是要把**退格符号** `<` 和**需要删除的内容**给**抹掉**。这个还是建议在文字匹配开始前完成，不然要将光标和范文的待匹配字符对齐就很麻烦了。

具体一点，考虑到输入的内容只有**小写字母、空格和英文句号**。我们就把要抹掉的字符换成 `'0'` 就好了。文字匹配的时候遇到 `'0'` 就**跳过**，问题也就迎刃而解了。

我们就讲范文的处理方式：
```cpp
string a[10010]; //总行数不超 10000 行，稍微开大一点。
for (int i = 0;; i++)
{
    getline(cin, a[i]); //开始逐行读入范文。
    if (a[i] == "EOF")  //如果读入的是 EOF，那就说明范文读取结束。
        break;
    int la = a[i].size(); //统计读入整行的字符数。

    for (int j = 0; j < la; j++) //对于读入的行，开始逐个字符读取。
    {
        if (a[i][j] == '<') //如果读取到了 < 号，接着往下读取看是否有更多的 < 号（即连续退格）。
        {
            int counter = 1;      //连续退格计数器，由于已经读取了一个 <，那就初始化为 1。
            for (j = j + 1;; j++) //用 j 的话执行下一轮循环就会从原本就没有退格符的地方开始，节省时间。
            {
                if (a[i][j] == '<')
                    counter++; //探测到 < 则计数器加一。
                else
                    break; //探测不到 < 则退出循环。
            }
            counter *= 2;                         //接下来不但要抹除需要退格的字符，退格符本身也要被抹去，所以乘二。
            for (int k = j - 1; counter > 0; k--) //从探测到的最后一个 < 开始往前抹除。
            {
                if (k >= 0) //退格退到行首的位置如果还退格就无效了。
                    a[i][k] = '0';
                counter--;
            }
        }
        //到这里完成了一系列 < 号的读取，开始探测下一组 <。
    }
    //到这里完成了一行范文的读取和处理。
}
//到这里所有的范文就读取并处理完毕了。
```

对于输入的文本，处理方式是**完全一样的**，具体来说就是把上面的数组名 `a` 换成了别的（下面是用 `b` 来表示的），这里就不展开了。

接下来开始**匹配**，注意跳过 `'0'`。

```cpp
int ans = 0;          // ans 储存：输入匹配的字符数。
for (int i = 0;; i++) //以行为单位处理范文和输入的文本。
{
    int p1 = 0, p2 = 0;                 //p2 储存光标位置，p1 储存范文中待匹配字符所在的位置。
    int la = a[i].size();               //范文待匹配行的字符数。
    int lb = b[i].size();               //输入的文本待匹配行的字符数。
    if (a[i] == "EOF" || b[i] == "EOF") //如果发现待匹配的两行中有一行是 EOF，那就结束所有的匹配。
        break;
    while (1) //正式开始两行的匹配！
    {
        while (b[i][p2] == '0') //'0' 就是在前面被抹去的内容，遇到了就直接跳过。
            p2++;
        while (a[i][p1] == '0')
            p1++;
        if (p1 >= la || p2 >= lb) //如果发现已经到达行末，就结束这两行的匹配。
            break;
        if (a[i][p1] == b[i][p2]) //匹配！
            ans++;                //若匹配上了，则匹配的字符数加一。
        p1++;                     //开始下一字符的匹配。
        p2++;
    }
    //到这里两行的匹配完成，开始匹配下两行。
}
//到这里两个文本的匹配完成！
int t; //t 储存录入所花时间。
cin >> t;
cout << ans * 60 / t; //这就是答案啦！
```

最后放上 AC 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    string a[10010], b[10010];
    for (int i = 0;; i++)
    {
        getline(cin, a[i]);
        if (a[i] == "EOF")
            break;
        int la = a[i].size();
        for (int j = 0; j < la; j++)
        {
            if (a[i][j] == '<')
            {
                int counter = 1;
                for (j = j + 1;; j++)
                {
                    if (a[i][j] == '<')
                        counter++;
                    else
                        break;
                }
                counter *= 2;
                for (int k = j - 1; counter > 0; k--)
                {
                    if (k >= 0)
                        a[i][k] = '0';
                    counter--;
                }
            }
        }
    }
    for (int i = 0;; i++)
    {
        getline(cin, b[i]);
        if (b[i] == "EOF")
            break;
        int lb = b[i].size();
        for (int j = 0; j < lb; j++)
        {
            if (b[i][j] == '<')
            {
                int counter = 1;
                for (j = j + 1;; j++)
                {
                    if (b[i][j] == '<')
                        counter++;
                    else
                        break;
                }
                counter *= 2;
                for (int k = j - 1; counter > 0; k--)
                {
                    if (k >= 0)
                        b[i][k] = '0';
                    counter--;
                }
            }
        }
    }

    int ans = 0;
    for (int i = 0;; i++)
    {
        int p1 = 0, p2 = 0;
        int la = a[i].size();
        int lb = b[i].size();
        if (a[i] == "EOF" || b[i] == "EOF")
            break;
        while (1)
        {
            while (b[i][p2] == '0')
                p2++;
            while (a[i][p1] == '0')
                p1++;
            if (p1 >= la || p2 >= lb)
                break;
            if (a[i][p1] == b[i][p2])
                ans++;
            p1++;
            p2++;
        }
    }
    int t;
    cin >> t;
    cout << ans * 60 / t;
    return 0;
}
```

---

## 作者：地表最强男人 (赞：0)

这题就是一个比较简单的模拟（说好的文本没有退格呢），只要处理好最终的文本和最终打出的文本然后比较就行了。但是有退格键，所以处理时需要存储光标的位置然后模拟退格。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=10010,M=100010;
int n,tot1,tot2,tot3=0,ans,T,tot,len[N];
string a[M],b[M];
string bb[N],aa[N];
double res,anss;
int main()
{
	getline(cin,a[++tot1]);
	while(a[tot1][0]!='E')
	{
		string s=a[tot1],ss;
		for(int i=1;i<=M;i++)
			ss+="A";
		int head=0;
		for(int i=0;i<s.length();i++)
		{
			if((s[i]>='a'&&s[i]<='z')||s[i]=='.'||s[i]==' ')
			{
				ss[head]=s[i];
				head++;
			}
			if(s[i]=='<'&&head>0)//退格的处理
			{
				head--;
				ss[head]='B';//
			}
		}
		len[tot1]=head;
		aa[tot1]=ss;
		getline(cin,a[++tot1]);
	}
	tot1--;
	getline(cin,b[++tot2]);
	while(b[tot2][0]!='E')
	{
		string s=b[tot2],ss;
		for(int i=1;i<=M;i++)
			ss+="A";
		int head=0;
		for(int i=0;i<s.length();i++)
		{
			if((s[i]>='a'&&s[i]<='z')||s[i]=='.'||s[i]==' ')
			{
				ss[head]=s[i];
				head++;
			}
			if(s[i]=='<'&&head>0)
			{
				head--;
				ss[head]='A';
			}
		}
		bb[tot2]=ss;
		getline(cin,b[++tot2]);
	}
	tot2--;
	for(int i=1;i<=tot1;i++)
		for(int j=0;j<len[i];j++)
			if(aa[i][j]==bb[i][j])
				ans++;
	cin>>T;
	res=(double)T/60;
	anss=(double)ans/res;
	tot=(int)(anss+0.5);
	printf("%d",tot);
	return 0;
}
```


---

## 作者：Nickel_Angel (赞：0)

本次月赛唯一看上去没有那么难的题QwQ……

~~本来想写 Trie 树，结果定睛一看是模拟字符串匹配~~

做模拟题，审题是个细节，我们看一下本题的易错点：

首先题目是对两段文本进行**逐位比较，且每行比较相互独立，且多余的行会被忽略，**文本中只包含小写字母和 `.`，另外还有退格符 `<`，其作用为删除上一个字符，并将光标回移一格。**特殊的，如果此时光标已经在一行的开头，则不能继续退格（即忽略此时输入的退格键）。 **文本以 `EOF` 结尾，**`EOF` 不算做输入的文本。**

**回车键不会被计入正确的字符个数，还应注意两段文本均会出现退格符！**

在计算答案时，由于给定的 $T$ 单位为**秒**，而需要计算的 KPM 单位为**分钟**，故还需进行单位换算。

一看就不想写，怎么办 QAQ？

但事实上，强大的 STL 可以帮助您解决许多问题。

STL 中有一个库为 `string`，其中的 `string` 类就是专门存储字符串的，并且有一个与之配套的函数 `getline`，这个函数可以读一整行字符（即读到行末换行符才停止读入，而不像 `cin` 读到空格就停止读入），这样我们就不用担心文本中的空格造成的形象，并且相对来说比直接用 `getchar` 的写法更简单。

题目要求我们删除字符，怎么办？我们这时继续借助强大的 STL 。`string` 这个类中有一个成员函数叫做 `erase`，它可以删除字符串制定位置的字符，它有多种传参方式，其中一种是 `iterator erase (iterator p);` 即传入所要删除字符的迭代器（迭代器可以理解为一种“比较复杂的指针”）。故假设我要删除 `string s` 中下标 $i$ 的位置上的字符，我可以调用 `s.erase(s.begin() + i)`（`s.begin()`是该 `string` 的首迭代器，你可以理解为它是指向该 `string` 的开头内存地址的指针），即可删除该字符。值得注意的是，**c++ 中几乎所有容器下标均从 0 开始**。

这样本题就可以通过读入数据，在用指针扫一遍，将文本中的所有退格命令按题意模拟后（这里需要注意细节，可详见代码），直接比对两个字符串，最终计算出答案即可。

Code：

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <cassert>
#include <algorithm>
#include <iostream>
#include <string>

using namespace std;

namespace Primary
{

const int maxn = 2e5 + 10;
const char tail[] = {"EOF"};
string s[10010];
string t[10010];

inline bool check(string s)//每一次暴力判断当前文本段是否读完
{
	if (s.length() != 3) return false;
	for (unsigned i = 0; i < 3; ++i)
		if (s[i] != tail[i]) return false;
	return true;
}

void main()
{
	register int i, cnt_1 = 0;
	while (1)
	{
		getline(cin, t[++cnt_1]);
		for (i = 0; i < t[cnt_1].length(); ++i)
		{
			if (t[cnt_1][i] == '<')
			{
				if (i != 0)//注意在删字符时特判 '<' 之前有无字符,避免多删一个字符
				{
					t[cnt_1].erase(t[cnt_1].begin() + i);
					--i;
				}
				t[cnt_1].erase(t[cnt_1].begin() + i);
				--i;//删完指针记得后退!
			}
		}
		if (check(t[cnt_1])) break;
	}
	register int cnt_2 = 0, ans = 0;
	while (1)
	{
		getline(cin, s[++cnt_2]);
		if (check(s[cnt_2])) break;
		if (cnt_2 > cnt_1) continue;//由于 "多余的行会被忽略",故直接忽略多余的行即可
		for (i = 0; i < s[cnt_2].length(); ++i)
		{
			if (s[cnt_2][i] == '<') 
			{
				if (i != 0)//和上文同理
				{
					s[cnt_2].erase(s[cnt_2].begin() + i);
					--i;
				}
				s[cnt_2].erase(s[cnt_2].begin() + i);
				--i;
			}
		}
		i = 0;
		while (s[cnt_2][i] && t[cnt_2][i])
		{
			if (s[cnt_2][i] == t[cnt_2][i] && s[cnt_2][i] != '\n')
				++ans;//统计答案
			++i;
		}
	}
	double T;
	cin >> T;
	cout << (int)((1.0 * ans) / (T / 60.0) + 0.5) << endl;//注意转化单位和四舍五入
}

}

int main()
{
	Primary::main();
	return 0;
}

```



---

## 作者：VRVRVR (赞：0)


# ~~HY（Isonan)出的题就是毒瘤~~
打开月赛发现第一题：小猪佩奇爬树（不愧是mocania),然后难度黑（雾，于是大概知道月赛不可做了。往下滑动发现了T3，我发现了希望！！！相信很多人跟我一样被这道水题卡了很久，总是40分，建议大家回去补补语文（范文里面也可以出现“<”号）
## 做法
我们先开两个string数组，sam[10010]和tex[10010].注意每次读入使用getline,这样可以避免把回车读进数组。读入以后，对于"<"可以这样处理：对于每一个"<"的位置，p=(sam[i] or tex[i]).find("<"),接下来判断，如果p==0,说明光标在句首，应该忽略，于是直接删掉sam[i].erase(p,1)；另外的话，就是正常删除前一个元素,sam[i].erase(p-1,2)。直到所有的"<"被处理掉，就break。最后我们将两个串进行一位位比较就行了。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
string sam[10010],tex[10010];int la,lb,p;
double t,ans;
int round_double(double number)
{
    return(number>0.0)?(number+0.5):(number-0.5); 
}
int main()
{
	int i=1;
	while(sam[i-1]!="EOF")
	{
    getline(cin,sam[i]);
    p=sam[i].find("<");
    while(p!=string::npos)
    {
    	if(p==0) sam[i].erase(p,1);
    	else sam[i].erase(p-1,2);
    	p=sam[i].find("<");
    	if(p==string::npos) break;
	}
	i++;
	}
	i-=2;
	int j=1;
	while(tex[j-1]!="EOF")
	{
	getline(cin,tex[j]);
	p=tex[j].find("<");
	while(p!=string::npos)
	{
		if(p==0) tex[j].erase(p,1);
		else tex[j].erase(p-1,2);
		p=tex[j].find("<");
		if(p==string::npos) break;
	}
	j++;
	}
	j-=2;
	cin>>t;
	t/=60;
	for(int k=1;k<=min(i,j);k++)
	{
	   la=sam[k].length();
	   lb=tex[k].length();
	   for(int m=0;m<min(la,lb);m++)
	   if(sam[k][m]==tex[k][m]) 
	   ans++;
	}
	cout<<round_double(ans/t);
	return 0;
} 
```


---

## 作者：chinaxjh (赞：0)

# 前言
模拟水题，比赛里的时候用c++相同的代码因为格式问题一直爆0，打了一个同样思路的pascal就过了
# 分析
按题意匹配，注意范文里也有退格键

运用链表的方式储存，方便删除节点
# AC Code
```pascal
uses math;
const nn=200000;
var
  s:ansistring;  bo:boolean;
  ti:extended; ch:char;
  f,f1:array[0..nn] of char;
  lat,nxt,a,h,lat1,nxt1,a1,h1:array[0..nn] of longint;
  lenn,lens,len,lenn1,len1,i,kk1,kk2,k,ans:longint;
begin
  while true do
  begin
    readln(s);
    inc(lenn);
    lens:=length(s);
    if (s='EOF') then break;
    bo:=true;
    for i:=1 to lens do
    begin
      ch:=s[i];
      if ch='<' then
      begin
        if h[lenn]=a[lenn] then bo:=true;
        k:=lat[a[lenn]];
        lat[a[lenn]]:=0;
        nxt[a[lenn]]:=0;
        f[a[lenn]]:=chr(0);
        a[lenn]:=k;
      end//退格键就删除节点
      else begin
        inc(len);
        f[len]:=ch;
        lat[len]:=a[lenn];
        nxt[a[lenn]]:=len;
        a[lenn]:=len;
        if bo then//链表表头记录
        begin
          bo:=false;
          h[lenn]:=len;
        end;
      end;//加入新节点
    end;
  end;
  while true do
  begin
    readln(s);
    inc(lenn1);
    lens:=length(s);
    if (s='EOF') then break;
    bo:=true;
    for i:=1 to lens do
    begin
      ch:=s[i];
      if ch='<' then
      begin
        if h1[lenn1]=a1[lenn1] then bo:=true;
        k:=lat1[a1[lenn1]];
        lat1[a1[lenn1]]:=0;
        nxt1[a1[lenn1]]:=0;
        f1[a1[lenn1]]:=chr(0);
        a1[lenn1]:=k;
      end
      else begin
        inc(len1);
        f1[len1]:=ch;
        lat1[len1]:=a1[lenn1];
        nxt1[a1[lenn1]]:=len1;
        a1[lenn1]:=len1;
        if bo then
        begin
          bo:=false;
          h1[lenn1]:=len1;
        end;
      end;
    end;
  end;//与之前代码同理
  readln(ti);
  ti:=ti/60;
  for i:=1 to min(lenn,lenn1) do//匹配部分
  begin
    kk1:=h[i];
    kk2:=h1[i];//取两个表头
    while (kk1<>0) and (kk2<>0) do
    begin
      if f[kk1]=f1[kk2] then inc(ans);
      kk1:=nxt[kk1];
      kk2:=nxt1[kk2];
    end;//诸位比较
  end;
  writeln(trunc(ans/ti+0.5));//保留整数输出
end.
```



---

## 作者：　Lzr (赞：0)

# orz经过dalao们的~~调教~~悉心教授，俺终于a了（望天狂笑

题目还是~~比较简单~~有点繁琐的，不过我们可以分解成如下操作：

1.输入完范文

2.每输入一行练习后，对该行及该行对应的范文进行退格处理

3.比较

4.输出

接下来就是大快人心的代码环节了（码风见谅orz


------------

### 步骤1：输入范文
鉴于输入中有空格，我们使用喜闻乐见的getline

```cpp
while(getline(cin,s1[++cnt1])){
	if(s1[cnt1] == "EOF") 
       		break;
	if(s1[cnt1][0] == '\n')
        	--cnt1; //EOF不算范文
} 
```
这里要注意因为EOF不算入范文，故最后要--cnt1

------------


### 步骤2、3：退格操作，比较

```cpp
int i1,i2;
while(getline(cin,s2)){
	++cnt2;
	if(s2 == "EOF") break;
	if(cnt2 > cnt1) continue; //如果练习文本超过范文的行数，那么就continue掉，因为我们要等到输入EOF的时候才退出
	i1 = i2 = 0; 
	while(i2 < s2.length()){ //喜闻乐见的退格操作
		if(s2[i2] == '<'){
			if(i2 > 0) s2.erase(i2 - 1,2),--i2; //如果退格有效，就删除掉退格及之前的文本，迭代器减1（减1的部分让我调了6h）
			else s2.erase(i2,1); //退格无效，我删我自己
		}
		else ++i2; //这里注意一定要加else，因为删退格后i2对应的字符变成后面的船新字符了，所以不删时才往后+1
	}
	while(i1 < s1[cnt2].length()){ //同理
		if(s1[cnt2][i1] == '<'){
			if(i1 > 0) s1[cnt2].erase(i1 - 1,2),--i1;
			else s1[cnt2].erase(i1,1);
		}
		else ++i1;
	}
	for(i1 = i2 = 0;i1 < s1[cnt2].length() && i2 < s2.length();++i1,++i2) //小心下标越界
		if(s1[cnt2][i1] == s2[i2]) ++sum; //sum俺在全局定义过辽
}
```

~~应该是比较容易看懂的~~


------------

### 步骤4：输出
```cpp
scanf("%lf",&t);
cout << int(sum / (t / 60.0) + 0.5); //骚操作来辽
```


------------
至此咱就写好了 ~~，其实也没有那么难~~！

欢淫dalao们的hack嗷


---


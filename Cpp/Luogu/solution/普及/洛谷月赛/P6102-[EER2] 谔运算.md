# [EER2] 谔运算

## 题目背景

在某个谔谔的一天中，CYJian 做到一道谔运算的谔谔题，CYJian 发现他不会做，于是决心从头开始研究令人谔谔的谔运算。

## 题目描述

首先，CYJian 写出了一个长度为 $n$ 的数列 $a$。

然后他灵光一动，写出了下面这个谔谔的式子：

$$\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{k=1}^{n}\sum_{l=1}^{n} (a_i\ {\rm or}\ a_j)\ {\rm xor}\ (a_k\ {\rm and}\ a_l)$$

CYJian 觉得这个是一个谔运算的简单式子，摁计算器花了 $114514{\rm s}$ 就算出来了答案。

为了证明你吊打 $114514$ 个 CYJian，请你在 $1{\rm s}$ 内算出来这个式子的值吧。你只需要给出答案对 $2^{32}$ 取模的值即可。

## 说明/提示

样例一解释：

$(1\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 1) = 0$

$(1\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 2) = 1$

$(1\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 1) = 1$

$(1\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 2) = 3$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 1) = 2$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 2) = 3$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 1) = 3$

$(1\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 2) = 1$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 1) = 2$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (1\ {\rm and}\ 2) = 3$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 1) = 3$

$(2\ {\rm or}\ 1)\ {\rm xor}\ (2\ {\rm and}\ 2) = 1$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 1) = 3$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (1\ {\rm and}\ 2) = 2$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 1) = 2$

$(2\ {\rm or}\ 2)\ {\rm xor}\ (2\ {\rm and}\ 2) = 0$

对所有结果求和，即可得到答案为 $30$。

---

**本题采用捆绑测试。**

对于 $100\%$ 的测试点：$1 \leq n \leq 5 \times 10^5$，$0 \leq a_i \leq 2^{32}-1$。

本题共 $6$ 个子任务，各子任务的分值及约定如下：

子任务 $1$（$1$ 分）：为样例一。

子任务 $2$（$14$ 分）：$1 \leq n \leq 80$。

子任务 $3$（$25$ 分）：$0 \leq a_i \leq 80$。

子任务 $4$（$30$ 分）：$0 \leq a_i \leq 5000$。

子任务 $5$（$25$ 分）：$1 \leq n \leq 1000$。

子任务 $6$（$5$ 分）：无特殊限制。

---

#### 友情提示

请注意数据范围。

**如果您不知道上面的谔运算是什么，请参考[这里](https://www.luogu.com.cn/paste/oe4a9czd)**。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
30
```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4
```

### 输出

```
3944
```

## 样例 #3

### 输入

```
7
1 9 1 9 8 1 0
```

### 输出

```
12892
```

# 题解

## 作者：StudyingFather (赞：26)

UPD（2020/5/11）：修了之前 $x,y$ 打反的锅。

因为每一位对答案的贡献是独立的，所以我们把每一位分开考虑。

现在问题变成了：给出一个 01 串，求题目中式子的值。

显然，只有以下两种情况会对答案产生 $1$ 的贡献：

- and 值为 1 的二元组 $(i,j)$ 和 or 值为 0 的二元组 $(k,l)$；
- and 值为 0 的二元组 $(i,j)$ 和 or 值为 1 的二元组 $(k,l)$；

本题对二元组没有任何限制，因此这四个二元组的数量都很好计算。

设这个 01 串中有 $x$ 个 $0$，$y$ 个 $1$，则：

- and 值为 1 的二元组有 $y^2$ 个；
- or 值为 0 的二元组有 $x^2$ 个；
- 剩下的数据都可以取补得到，这里不再赘述。

```cpp
#include <iostream>
using namespace std;
unsigned t[35];
int main()
{
 ios::sync_with_stdio(false);
 unsigned n,tot,ans=0;
 cin>>n;
 tot=n*n;
 for(int i=1;i<=n;i++)
 {
  unsigned x;
  cin>>x;
  for(int j=0;j<=31;j++)
   if((x>>j)&1)t[j]++;
 }
 for(int i=0;i<=31;i++)
 {
  unsigned andn=t[i]*t[i],orn=(n-t[i])*(n-t[i]);
  ans+=(andn*orn+(tot-andn)*(tot-orn))<<i;
 }
 cout<<ans<<endl;
 return 0;
}
```


---

## 作者：EricQian (赞：20)

求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_{k=1}^n\sum\limits_{l=1}^n (a_i\ \text{or}\ a_j)\ \text{xor}\ (a_k\ \text{and}\ a_l)$
 ，如果暴力求解复杂度 $O(n^4)$ 显然不行，而题目中 "$\operatorname{or}$" , "$\operatorname{xor}$" , "$\operatorname{and}$" 都是关于二进制位的运算，所以我们考虑每一个二进制位。

假设我们考虑第 $p$ 位，预处理序列 $a$ ，从右向左数第 $p$ 个二进制位是 0 的个数与是 1 的个数有多少。举个例子，若序列a是“ 1，13，4，5，9 ”，他们的二进制表达分别为

0 0 0 1 -> 1

1 1 0 1 -> 13

0 1 0 0 -> 4

0 1 0 1 -> 5

1 0 0 1 -> 9  

它们的第一位为 1 的个数是 4 ，为 0 的个数是 1 ； 第二位为 1 的个数是 0 ，为 0 的个数是 5 ； 第三位分别是 3 和 2 ； 第四位分别是 2 和 3 .

如果对于一组 $( a_i,a_j,a_k,a_l )$ 第 $p$ 位的运算结果值是 1（这一种方案对答案贡献了 $2^{p-1}$ ）， 那么有下面这几种可能：

![](https://cdn.luogu.com.cn/upload/image_hosting/21o3gax1.png)

共十种情况。

设此时整个 $a$ 序列中每一个数第 $p$ 位 0 的个数为 $x$ ，1 的个数为 $y$ ，则这十种情况的方案数总和为：

$$x^3y(1+1)+x^2y^2(1+1+4)+xy^3(1+1)$$

整理得： 

$$2x^3y+6x^2y^2+2xy^3=F[p]$$

$F[p]$ 就是第 $p$ 位的情况数，再将 $f[p]$ 乘上 $2^{p-1}$  【这里的 $2^{p-1}$ 是第 $p$ 位每种方案对答案贡献值的大小】

所以答案 $sum$ 就是 $\sum\limits_{i=1}^{33}(f[i] * 2^{i-1})$

我对上面这个公式再做一下解释：

由于我们讨论的是每一个二进制位，一种方案运算后（也就是那十种可能）第 $p$ 位是 1，相当于这种方案的四个数运算后的第 $p$ 个二进制位是 1 。将二进制第 $p$ 位的 1 转成十进制是 $2^{p-1}$ ，所以最终用 $2^{p-1}$ 乘上第 $p$ 位是 1 的个数。统计答案时枚举每一位再累加起来。


注： 记得开 $\operatorname{long long}$ 并及时取 $\bmod$.

下面是参考代码：
```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define Maxn 500005
typedef unsigned long long ll;
ll n,p=1,tot;
ll a[Maxn],mi[50],x[Maxn],y[Maxn];
void cnt(ll k)  // 计算每一位x与y的个数
{
	 for(register int i=1;i<=33;i++)
	 {
	 	 if(k%2==0) x[i]+=1;
	 	 else y[i]+=1;
	 	 k/=2;
	 }
}
ll f(int i)   // 求f[i]
{
	 ll sum=0;
	 sum=(((2*x[i]*x[i])%p)*((x[i]*y[i])%p))%p;
	 sum=(sum+(((6*x[i]*x[i])%p)*((y[i]*y[i])%p))%p)%p;
	 sum=(sum+(((2*x[i]*y[i])%p)*((y[i]*y[i])%p))%p)%p;
	 return sum;
}
int main()
{
     //freopen("","r",stdin);
     //freopen("","w",stdout);
	 scanf("%lld",&n);
	 for(register int i=1;i<=32;i++) mi[i]=p,p*=2;
	 a[33]=p;
	 for(register int i=1;i<=n;i++) scanf("%lld",&a[i]);
	 for(register int i=1;i<=n;i++) cnt(a[i]);
	 for(register int i=1;i<=33;i++) if(y[i] && x[i]) tot=(tot+(f(i)*mi[i]))%p;
	 printf("%lld\n",tot);
     //fclose(stdin);
     //fclose(stdout);
     return 0;
}
```
感谢 @ pikabi 指出题解错误！

之前细节错误已更正。

---

## 作者：chen_03 (赞：10)

比赛的时候调了非常久，自闭了。这里分享一下我在比赛时的思路。

由于题目是先进行位运算然后求和，所以我们可以从低到高考虑**每个二进制位上**的结果，再把所得的结果相加。

__以下讨论均是对于每个二进制位。__

我们先考虑统计左边的式子

$$a_i\ {\rm or}\ a_j$$

的值为 $1$ 的情况数（对于每个二进制位，这个式子的值只能为 $0$ 或 $1$）。根据按位或的性质，当且仅当 $a_i$ 和 $a_j$ **至少有一个为 $1$** 时，这个式子的值才为 $1$。

分类讨论：

1. 当 $a_i=1$ 时，显然对于任何一个 $1 \le j \le n$，$a_i\ {\rm or}\ a_j=1$ 恒成立。此时情况数加上 $n$。
1. 当 $a_i=0$ 时，要想使 $a_i\ {\rm or}\ a_j$ 的值为 $1$，显然要让 $a_j=1$。由于 $a_i=0$，所以此时情况数加上 $1$ 的个数（因为我们要让 $a_i$ 与一个 $1$ **配对**）。

对于右边的式子

$$a_k\ {\rm and}\ a_l$$

由于

$$a_k\ {\rm and}\ a_l={\rm not}\ (({\rm not}\ a_k)\ {\rm or}\ ({\rm not}\ a_l))$$

所以我们可以用一样的方法统计这个式子的值为 $0$ 的情况数。

接下来我们考虑中间的按位异或运算。由于异或是不进位的加法，所以 $a_i\ {\rm or}\ a_j$ 和 $a_k\ {\rm and}\ a_l$ 的值**有且仅有一个为 $1$** 时，$(a_i\ {\rm or}\ a_j)\ {\rm xor}\ (a_k\ {\rm and}\ a_l)$ 的值为 $1$。

对于从低到高第 $(p+1)$ 位，设 $a_i\ {\rm or}\ a_j=1$ 的情况数为 $x$，$a_k\ {\rm and}\ a_l=0$ 的情况数为 $y$，根据容斥原理，我们用总情况数 $n^2$ 减去 $x$ 或 $y$ 就可以得到 $a_i\ {\rm or}\ a_j=0$ 的情况数或 $a_k\ {\rm and}\ a_l=1$ 的情况数。这时根据乘法原理，$a_i\ {\rm or}\ a_j$ 和 $a_k\ {\rm and}\ a_l$ 的值**有且仅有一个为 $1$** 的情况数为

$$xy+(n^2-x)(n^2-y)$$

此时答案加上这个式子的值左移 $p$ 位的结果即可。

注意 $a$ 数组要开 `unsigned int`，计算过程中 $x,y,n^2$ 要开 `long long`。由于答案对 $2^{32}$ 取模，所以我们可以使用一个 `unsigned int` 型变量存储答案，计算过程中自然溢出，相当于取模。

时间复杂度 $\Theta(n \log_2 a_i)$。

我比赛时的 AC 代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define re register //卡常
using namespace std;
typedef unsigned int ui;
typedef long long ll;
int n,xs,ys; //xs：左边的式子的值为 1 的情况数；ys：右边的式子的值为 0 的情况数
ui a[500005],ans; //答案开 unsigned int，自然溢出，相当于取模
ll sum,x,y;
int main()
{
	scanf("%d",&n);
	for(re int i=1;i<=n;++i)
		scanf("%u",a+i); //注意要用 "%u"
	sum=(ll)n*n; //总方案数（n^2），记得开 long long
	for(re int i=0;i<32;++i){ //枚举每一位
		xs=ys=x=y=0; //记得初始化
		for(re int j=1;j<=n;++j)
			(a[j]>>i)&1?++xs:0; //统计 1 的数量
		ys=n-xs; //计算出 0 的数量
		for(re int j=1;j<=n;++j)
			(a[j]>>i)&1?(x+=n,y+=ys):(y+=n,x+=xs); //统计情况数
		ans+=(x*y+(sum-x)*(sum-y))<<i; //累加答案，自然溢出，相当于取模
	}
	printf("%u\n",ans); //注意要用 "%u"
	return 0;
}
```
当然，由于我们可以根据在这个二进制位上 $a_i$ 的值为 $1$ 的情况数以及为 $0$ 的情况数直接算出 $x$ 和 $y$ 的值，所以我们可以不写统计情况数的循环。

统计情况数的循环改为如下两行：
```cpp
x=(ll)xs*n+(ll)ys*xs; //加了 xs 次 n 和 ys 次 xs
y=(ll)ys*n+(ll)xs*ys; //同理
```

---

## 作者：peppaking8 (赞：9)

## 思路：
我真的太弱了，看到这道题mb了半天才想出来。。。

我们先看要求什么：
$$\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_{k=1}^n\sum\limits_{l=1}^n (a_i\ \text{or}\ a_j)\ \text{xor}\ (a_k\ \text{and}\ a_l)$$
在解决含有异或，与，或之类的问题时，非常常用的方法就是**分位解决**。

设 ```a[i]``` 化为二进制后从右至左第 ```j``` 位为 ```wei[i][j]``` 。

对于每一位，比如 ```pos``` 位。为了方便，下记 ```wei[i][pos]=a[i]```。设 $a_i$ 中有 $x$ 个 $1$，$n-x$ 个 $0$。首先原式化为
$$\sum\limits_{i=1}^n\sum\limits_{j=1}^n\sum\limits_{k=1}^n\sum\limits_{l=1}^n ((a_i\ \text{or}\ a_j)+(a_k\ \text{and}\ a_l))\mod{2}$$
因为 $a_i$只有两个取值（$0$ 或 $1$）。然而
$$0\ \text{xor}\ 0=1\ \text{xor}\ 1=0$$
$$0\ \text{xor}\ 1=1\ \text{xor}\ 0=1$$
经归纳总结后，即 $a\ \text{xor}\ b=(a+b)\mod{2}$。

接下来，根据 $a_i,a_j$ 的取值进行分析：

1）如果 $a_i=a_j=0$。则这样的取值有 $(n-x)^2$ 种，将它提出来：
$$(n-x)^2 \sum\limits_{k=1}^n\sum\limits_{l=1}^n((0\ \text{or}\ 0)+(a_k\ \text{and}\ a_l))\mod{2}$$
也就是
$$(n-x)^2 \sum\limits_{k=1}^n\sum\limits_{l=1}^n(a_k\ \text{and}\ a_l)$$
如果，则必有 $a_k=a_l=1$，有 $x^2$ 种。故最终答案为
$$(n-x)^2x^2$$
2）如果 $a_i=a_j=1$，则这样的取值有 $x^2$ 种，提出来得
$$x^2 \sum\limits_{k=1}^n\sum\limits_{l=1}^n(1+(a_k\ \text{and}\ a_l))\mod2$$
同样的，$(1+(a_k\ \text{and}\ a_l))\mod2=1$ 时有 $n^2-x^2$ 种，故原式为
$$x^2(n^2-x^2)$$
3）如果 $a_i,a_j$ 有一个是 $1$，一个是 $0$。则这样的取值有 $2x(n-x)$ 种：
$$2x(n-x)\sum\limits_{k=1}^n\sum\limits_{l=1}^n(1+(a_k\ \text{and}\ a_l))\mod2$$
同理，化简得
$$2x(n-x)(n^2-x^2)$$
综上，第 ```pos``` 位的总和为
$$sum=x^2(n-x)^2+x^2(n^2-x^2)+2x(n-x)(n^2-x^2)$$
化简后得
$$sum=2x(n-x)(n^2-x^2+nx)$$
故第 ```pos``` 位对答案的贡献是
$$sum\times 2^{pos-1}$$
~~感性理解即可~~。关于取模，因为 ```pos``` 位对答案的贡献要乘 $2^{pos-1}$，所以取模时只需要$\mod{2^{33-pos}}$ 即可。好了，讲解就结束了，现在是代码时间！
## 代码：
讲解较清楚，所以代码没有过多介绍了。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=500005,Q=33;
int n;
int wei[N][Q],cnt[Q];
int ans=0;
int pow(int x){
	int kkks=1;
	return kkks<<x;
}
int cal(int x){return x*x;}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%lld",&x);
		for(int j=1;j<Q;j++){
			wei[i][j]=(x&1);//处理wei数组，作用详见讲解
			if(wei[i][j]==1) cnt[j]++;//cnt[i]表示第i位有几个1
			x>>=1;
		}
	}
	for(int i=1;i<Q;i++){
		int x=cnt[i];
		int pos1=x*(n-x);pos1%=pow(Q-i);
		int pos2=cal(n)-cal(x)+n*x;pos2%=pow(Q-i);
		int pos=2*pos1*pos2;pos%=pow(Q-i);
      //套公式
		ans+=pos<<(i-1);ans%=pow(32);
      //注意ans也要取模哦！
	}
	printf("%lld\n",ans);
}
```
写一篇题解不容易，看完记得点个赞哦~~

---

## 作者：Euler_Pursuer (赞：4)

这道题一大堆求和符号实际上是用来吓人的。其实只要我们按二进制转化题意即可得到很简单的规律。

下面我们列举所有某一位的计算结果：

|$A\;$|$B\;$|$C\;$|$D\;$|$A\; {\rm or}\; B\;$|$C\; {\rm and}\; D\;$|$\rm xor$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|1|1|1|1|1|0|
|1|1|1|0|1|0|1|
|1|1|0|1|1|0|1|
|1|1|0|0|1|0|1|
|1|0|1|1|1|1|0|
|1|0|1|0|1|0|1|
|1|0|0|1|1|0|1|
|1|0|0|0|1|0|1|
|0|1|1|1|1|1|0|
|0|1|1|0|1|0|1|
|0|1|0|1|1|0|1|
|0|1|0|0|1|0|1|
|0|0|1|1|0|1|1|
|0|0|1|0|0|0|0|
|0|0|0|1|0|0|0|
|0|0|0|0|0|0|0|

不难发现：

1. 这四个数如果某一位全为 $1$ 或 $0$，则这一位求和结果为 $0$；
2. 其中有一个 $1$ 或 $0$，则这一位求和结果为 $2$；
3. 其中有两个 $1$、$0$，则这一位求和结果为 $6$；

那么最终答案就很显然了（要注意每个数可以重复选）。假如第 $i$ 位有 $n_i$ 个 $1$，有 $m_i$ 个 $0$，那么这一位对答案的贡献就是 $2^i\times (2n_i^3m_i+2n_im_i^3+6n_i^2m_i^2)$。

因此，我们只需要在一开始就把 $a_i$ 的二进制中每一位的 $1$ 的个数统计出来，之后再对每一位用上面那个式子统计答案就可以了。取模操作直接用自然溢出即可。

代码如下：

```cpp
#include <cstdio>

unsigned int a, N, sum[35], j, ans;

int main()
{
    scanf("%u", &N);
    for(register int i = 1; i <= N; i += 1)
    {
        scanf("%u", &a);
        j = 0;
        while(a)
        {
            j += 1;
            if(a&1)
                sum[j] += 1;
            a >>= 1;
        }
    }
    int r, s;
    unsigned int f = 1;
    for(register int i = 1; i <= 32; i += 1)
    {
        r = sum[i];
        s = N - sum[i];
        ans = ans + (unsigned int)r*s*(2*(r*r+s*s) + 6*r*s)*f;
        f <<= 1;
    }
    printf("%u", ans);
    return 0;
}
```

---

## 作者：pomelo_nene (赞：3)

感谢 @C20212104陈泺嘉 大佬的指导。

---

## Subtask 1,2

很显然可以 $O(n^4)$ 模拟。

也可以用 `map` 预处理出数对，明明是 $O(n^2)$ 的可是过不了 Subtask5。/xyx

## Subtask 3,4,5

没有想法。

## Subtask 6

观察题面与数据范围，我们需要写出一个 $O(n)$ 的算法进行计算。

首先要知道一个快速计算下面一个式子：

$$\sum_{i=1}^n\sum_{j=1}^n a_i \operatorname{xor} a_j$$

其中 $0 \leq a_i \leq 2^{32}-1$，向 $2^{32}$ 取模。

考虑到异或的性质，我们只需要判断答案上转化为二进制的每一位就行了。

具体操作就是：保存下 $a_i$ 转化为二进制之后每一位 $1$ 的个数。对于这一位对答案的贡献，我们考虑有 $bit_i$ 个 $1$，这一位上一定有 $n-bit_i$ 个 $0$。对答案的贡献也就是 $(n-bit_i) \times bit_i$ 个。答案同时也加上 $(n-bit_i)  \times bit_i \times 2^{i}$。

具体灵感来源在[这里](https://blog.csdn.net/cs09_satan/article/details/7366438)。

返回到这一题，按照之前的方法处理掉 $bit$ 数组。如何计算贡献呢？

因为也是异或，所以要么 $a_i \operatorname{or} a_j$ 是 $1$，要么 $a_k \operatorname{and} a_l$ 是 $1$（同为 $1$ 或者 $0$ 答案就是 $0$）。我们试着计算一下。

这一位选两个数进行或运算，得到这一位是 $1$ 的方案有多少种？

考虑到或运算的性质，有一位是 $1$，那么这一位运算出来一定是 $1$。假设进行或运算的两个位是 $a$ 和 $b$，满足 $a$ 或者 $b$ 其中一个是 $1$，那么答案为 $1$。分类讨论：

- 如果 $a$ 是 $1$，显然 $b$ 是什么都没关系，那么贡献就是 $n \times bit_i$；

- 否则，只有 $b$ 是 $1$ 才能满足条件，贡献即为 $(n - bit_i) \times bit_i$。

其他的情况就是 $a$ 和 $b$ 都为 $0$。这种情况只需要从 $n^2$ 中排除就行了，也就是 $n^2 - n \times bit_i - (n - bit_i) \times bit_i$。

与运算同理。必须要 $a$ 和 $b$ 都是 $1$。这种情况的贡献就是 $bit_i^2$，同理排除即可。

计算贡献，根据乘法原理和加法原理，我们这一位的贡献就是这一位或起来等于 $0$ 的情况种数乘上这一位经过与运算答案为 $1$ 的情况种数，加上这一位或起来等于 $1$ 的情况种数乘上这一位经过与运算答案为 $0$ 的情况种数，乘上这一位的位权 $2^i$ 就行了。

唯一需要注意的是模数为 $2^{32}$，对此用 `unsigned int` 自然溢出就行了。

我相信没人用 `long long` 的吧。/ee

代码领略精神就行了，反正这道题不难。

```cpp
#include<bits/stdc++.h>
#define ul unsigned int
char buf[1<<21],*p1=buf,*p2=buf;
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
using namespace std;
int n;
ul read()
{
	ul x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x=(x<<1)+(x<<3)+(c^'0'),c=getchar();
	return x;
}
ul a[500005];
int bit[33];
int main(){
	n=read();
	for(int i=1;i<=n;++i)
	{
		a[i]=read();
		for(int j=0;j<=31;++j)
		{
			bit[j]+=int(bool((1<<j)&a[i]));
		}
	}
	ul ans=0;
	for(int i=0;i<=31;++i)
	{
		ul bita1=bit[i]*bit[i],bita0=n*n-bita1,bito1=bit[i]*n+(n-bit[i])*bit[i],bito0=n*n-bito1;
		ans+=(bita0*bito1+bita1*bito0)*(1<<i);
	}
	printf("%u",ans);
	return 0;
}
```

---

## 作者：Warriors_Cat (赞：3)

## 题解【P6102 谔运算】

### $Solution:$

其实我一开始看这道题还没有思路，不过看到 $and$，$or$，$xor$ 就知道肯定和二进制有关系。

所以我就把每个数改写成了二进制的表示方式。

然后因为 $and$，$or$，$xor$ 都是按位操作的，所以我又把每一位给拆开逐个分析了。

因为在二进制下，$and$，$or$，$xor$ 操作后非 $0$ 即 $1$，而且 $0$ 对和没有什么贡献，所以我们只考虑 $1$ 就珂以啦！

我们先来康康一位能满足的情况：

$\text{(0 or 0) xor (1 and 1) = 1}$

$\text{(0 or 1) xor (0 and 0) = 1}$

$\text{(0 or 1) xor (0 and 1) = 1}$

$\text{(0 or 1) xor (1 and 0) = 1}$

$\text{(1 or 0) xor (0 and 0) = 1}$

$\text{(1 or 0) xor (0 and 1) = 1}$

$\text{(1 or 0) xor (1 and 0) = 1}$

$\text{(1 or 1) xor (0 and 0) = 1}$

$\text{(1 or 1) xor (0 and 1) = 1}$

$\text{(1 or 1) xor (1 and 0) = 1}$

嗯~~好像应该也许大概就~~只有这 $10$ 种惹QAQ。

然后我们统计一下其中 $0, 1$ 出现的次数：

$3$ 个 $0$，$1$ 个 $1$：$2$ 个。

$2$ 个 $0$，$2$ 个 $1$：$6$ 个。

$1$ 个 $0$，$3$ 个 $1$：$2$ 个。

每一位的情况就是这样，那我们对于第一位就 $\times \;1$，对于第二位就 $\times \;2$，对于第三位就 $\times \;4$，以此类推就可以啦。

至于 $0$ 和 $1$ 的个数，像 $T1$ 一样用个桶来统计一下就好惹QWQ，还有因为 $mod=2^{32}$，所以我还是用了 ``__int128``。

于是本题就大功告成啦0^_^0。

附比赛代码：

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
#define int __int128
const int mod = ((int)1 << 32);
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}//快读板板
inline void write(int x){
	if(x < 0) putchar('-'), x = -x;
	if(x / 10 == 0){
		putchar(x % 10 + 48);
		return;
	}
	write(x / 10);
	putchar(x % 10 + 48);
}//快输板板
int n, a[500010], ans, b[32][2];
signed main(){
	n = read();
	for(register int i = 1; i <= n; ++i){
		a[i] = read();
		int x = a[i];
		for(int j = 0; j <= 30; ++j){
			if(x & 1) b[j][1]++;//如果这一位是1就加到1这
			else b[j][0]++;//否则加到0这
			x >>= 1;//每次把这个数向右移一位
		}
	}
	for(register int i = 0; i <= 30; ++i){
		ans += ((b[i][0] * b[i][0] % mod * b[i][1] % mod * b[i][1] % mod * 6 % mod + b[i][0] * b[i][1] % mod * b[i][0] % mod * b[i][0] % mod * 2 % mod) % mod + b[i][1] * b[i][1] % mod * b[i][1] % mod * b[i][0] % mod * 2 % mod) % mod * ((int)1 << i) % mod; //希望大家能看得懂QAQ
		ans %= mod;
	}
	write(ans);//完结撒花-v-
	return 0;
}
```


---

## 作者：引领天下 (赞：1)

首先，这个题是肯定不能按题意模拟的。$ O(n^4) $ 的复杂度，我们绝对承受不起。

那么既然涉及的是位运算，我们就考虑将输入的 $a$ 进行二进制拆分，对每一位进行考虑。

考虑每位出现什么样的数对答案有贡献：

- ( $ a_i=0 $ | $ a_j=0 $ ) ^ ( $ a_k=1 $ & $ a_l=1 $ )

- ( $ a_i=1 $ | $ a_j=0 $ ) ^ ( $ a_k=0 $ & $ a_l=0 $ )

（以上并没有考虑顺序）

那么对于每一位，只有两种情况下该位的四个数对答案有贡献。我们只需统计每位上 $ 0 $ 和 $ 1 $ 的个数，然后用容斥原理计算即可。

代码：

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(3)
#define min(x,y) ((y)^(((x)^(y))&(-((x)<(y)))))
#define max(x,y) ((x)^(((x)^(y))&(-((x)<(y)))))
using namespace std;
int n;
__int128 ans,s,a[500005],x,y;
const __int128 mod=(__int128)4294967296;//定义模数
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline void read(__int128 &x){
    int f=1;x=0;char ch=nc();
    while (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=nc();}
    x*=f;
}
inline void write(__int128 n){//由于我用的int128，所以必须要自己写一个输入输出
    if (n==0)return ;
    write(n/10);
    putchar(n%10+'0');
}
int main(){
    scanf("%d",&n);
    register int i,j;
    for (i=1;i<=n;i++)read(a[i]);
    for (i=1;i<33;i++){
        x=y=0;
        for (j=1;j<=n;j++)if((1ll<<i-1)&a[j])x++;else y++;//确定第 i 位上 0 和 1 的个数，由于 1<<i-1 的结果是 1 后面一串 0 的形式，所以可以直接放心 &
        s=((x+y)*(x+y)%mod-y*y%mod)*((x+y)*(x+y)%mod-x*x%mod)+(((((x*x)%mod)*y)%mod)*y)%mod;//分别对应上面讨论的两种情况
        ans=(ans+s*(1ll<<i-1))%mod;//利用容斥原理统计贡献，并加到答案里。
    }
    ans=(ans+mod)%mod;//巨坑！这里必须加个 mod ，要不然会导致输出负数……
    if(ans)write(ans);
    else putchar('0');
    return 0;
}
```

---


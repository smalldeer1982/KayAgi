# 混凝土数学

## 题目描述

你正在看混凝土数学，这时旁边的工地开工了，你觉得看他们施工更有意思，于是你向窗外望去，注意到了一些长度不同的木棍。具体而言，你看到了 $n$ 条木棍编号为 $1,2,3,\ldots,n$，长度为 $a_1,a_2,a_3,\ldots,a_n$。你突发奇想：有多少拿出其中 $3$ 条木棍的方案满足它们能构成等腰三角形呢？你不想要输出的数太大，所以最后的方案要对 $998244353$ 取模。

给出等腰三角形的要求：任意两边之和大于第三边且至少有两条边边长相等。

例如，如果木棍长度分别为 $\{3,3,2,2,4,5\}$，你就有 $6$ 种方法，选取的木棍编号分别为：$\{1,2,3\}$，$\{1,2,4\}$，$\{1,2,5\}$，$\{1,2,6\}$，$\{1,3,4\}$，$\{2,3,4\}$。

## 说明/提示

- Subtask1 （$30$ pts）：$1\leq n \leq 200$。
- Subtask2 （$30$ pts）：$1\leq n \leq 2000$。
- Subtask3 （$20$ pts）：木棍长度全部相等。
- Subtask4 （$20$ pts）：无特殊限制。

对于 $100\%$ 的数据满足：$1\leq n \leq 2\times 10^5$，$1\leq a_i \leq 2\times 10^5$。

## 样例 #1

### 输入

```
6
3 3 2 2 4 5```

### 输出

```
6```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4
```

### 输出

```
5```

## 样例 #3

### 输入

```
6
2 2 2 2 2 2```

### 输出

```
20```

# 题解

## 作者：wuyonghuming (赞：30)

## 思路：
这道题目只要枚举，然后优化一下就可以通过了

我们首先把每个长度的棍子的个数都记录下来

我们可以枚举每一个腰的长度，然后我们就要计算能和这两根木棍形成三角形的个数。

当两条边的长度和小于等于第三条边时，三根木棒就能形成三角形

因为两根木棍的长度相同，第三条边的长度一定是一个正整数，所以不存在一个腰加上第三条边的长度和小于另一个腰

所以只有一种情况不能形成三角形：当第三条边的长度大于等于两条腰的和才不能形成三角形

想求出不能和这个长度为腰形成三角形的边的个数，有两种方法

第一种就是从这两条边的长度和开始，一直到最长长度，把它们加起来

显然复杂度过高，会时间超限

第二种方法就是一开始没有能形成三角形的，因为我们的循环枚举腰是从短边开始，所以如果前面的长度和第三条边成立那么后面的长度也和第三条边成立，最后再加上前面的和第三条边不成立，后面的和第三条边成立的个数，最多也就两个

现在我们知道了这个长度的腰能和多少根棍子形成三角形的个数了，我们就可以用乘法原理算出答案了

乘法原理要分类讨论：

等边三角形的个数 和 等腰三角形的个数

假设我们有 $x$ 根相等长度的棍子 $y$ 根能和它们形成三角形个数的棍子

我们先把腰的符合的方案数算出来，再把它乘上 $y-x$ 就可以了，之所以乘上 $y-x$ 是因为我们要求的是等腰三角形 $y$ 中也包括了和这个长度相等的那些棍子，我们要把它减掉

我们取第一根棍子有 $x$ 种方法,取第二根棍子就只有 $x-1$ 种方法了，是因为第一根棍子被取走了，没法再取了

然后算出来 $x(x-1)$ ,但是要除二，因为这两根棍子交换顺序也是同一种方案

最后我们算出来 $x(x-1)÷2$

乘上 $y-x$ 后就是 $x(x-1)(y-x)÷2$

接着我们算等边三角形的个数，依旧假设有 $x$ 个

那么取第一根有 $x$ 种，第二根有 $x-1$ 因为已经取走一根不能再取了，第三根有 $x-2$ 种，因为前面已经取走两根，这两根不能再取了

我们得到式子 $x(x-1)(x-2)$,但是这不是最终答案

我们取这几根棒子也有顺序，顺序不同，但还是一种方案

取第一根有 $3$ 种方法，取第二根有 $2$ 方法，因为取过第一根就不能再取了,第三根只有 $1$ 种方法，因为取了两根只剩最后一根，只能选它了

于是我们推出式子 $x(x-1)(x-2)÷(1×2×3)$

化简得到 $x(x-1)(x-2)÷6$ 当然也可以是 $(x^3-3x^2+2x)÷6$

加起来就是 $x(x-1)(x-2)÷6+x(x-1)(y-x)÷2$

除了上面那些还有可以优化的

我们只要枚举到最长的木棍就行了，最好不要看都不看直接一到二十万循环，那些小数据的也会慢

最后提醒一下，每个木棍的长度个数和答案最好用 $long$ $long$ ，假设全是一个长度比如二十万个 $1$ ，就是 $200000×199999×199998÷6$ ，超过 $10^{15}$ ,而 $int$ 也就大约 $2.1×10^9$ ,肯定不够
## 代码：
代码~~基本~~上是目前最短的了，加上快读就是目前最优解
```c
#include <stdio.h>//C语言代码
long long f[200001],ans;//分别是每个长度的个数和答案
int main()
{	
	int n,m=0,k=0,l=1,a;//分别为木棍个数，最长木棍，符合条件的木棍数，符合条件的最长木棍，木棍长度
	scanf("%d",&n);//输入木棍个数
	for(int i=1;i<=n;i++)//循环木棍个数次
	{
		scanf("%d",&a);//输入木棍长度
		f[a]++;//这个长度的木棍多了一个
		m=m<a?a:m;//更新最长木棍的长度
	}
	for(int i=1;i<=m;i++)//枚举每一个长度为腰，也不用判断是否是零或者一，因为木棍如果是这些数的话，后面的乘法会让它们变成零
	{
		for(;l<i*2&&l<=m;l++)//枚举到符合条件的木棍长度
			k+=f[l];//符合条件的木棍数加上这个长度的木棍个数
		ans+=(f[i]-1)*f[i]*(k-f[i])/2+(f[i]-2)*(f[i]-1)*f[i]/6;//乘法原理
	}
	printf("%lld",ans%998244353);//输出取模后的答案
	return 0;//别忘了
}
```
谢谢管理审核和大家观赏！

---

## 作者：Unordered_OIer (赞：15)

# P6685 题解
首先，不难想到暴力：
## $\texttt{30pts}$
枚举一下即可
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans;
bool dy(int a,int b,int c){return a==b||b==c||c==a;}
bool sj(int a,int b,int c){return a+b>c&&b+c>a&&c+a>b;}
bool ok(int i,int j,int k){return dy(a[i],a[j],a[k])&&sj(a[i],a[j],a[k]);}
int main(){
cin>>n;for(int i=1;i<=n;i++)cin>>a[i];
for(int i=1;i<=n;i++)
for(int j=i+1;j<=n;j++)
for(int k=j+1;k<=n;k++)
if(ok(i,j,k))ans++;
cout<<ans;
return 0;
}
```
## $\texttt{50pts}$
因为如果$a$全部一样，答案为$C_n^3$($n$个数里任意选$3$个)  
所以我们可以特判一下，加快速度。
```cpp
#include<bits/stdc++.h>
#define int unsigned long long
#define mod 998244353
using namespace std;
int n,a[200005],ans;
bool flag=0;
set<int>seet;
bool dy(int a,int b,int c){return a==b||b==c||c==a;}
bool sj(int a,int b,int c){return a+b>c&&b+c>a&&c+a>b;}
bool ok(int i,int j,int k){return dy(a[i],a[j],a[k])&&sj(a[i],a[j],a[k]);}
signed main(){
    cin>>n;for(int i=1;i<=n;i++)cin>>a[i],seet.insert(a[i]);
//  cout<<seet.size()<<endl;
    if(seet.size()==1)flag=1;
    if(flag){return cout<<(n*(n-1)*(n-2)/6)%mod<<endl,0;}
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            for(int k=j+1;k<=n;k++)if(ok(i,j,k))ans=(ans+1)%mod;
    cout<<ans%mod<<endl;
    return 0;
}
```
## $\texttt{100pts!!!}$
$100$分思路其实比较简单，但不容易想到。  
首先，我们知道，等腰三角形是**两条腰相等**的三角形（废话）。。。其次，等边三角形**是特殊的等腰三角形**。  
那么我们在选择边的时候，如果一个边的出现次数都不满$2$次，那么这种情况**直接跳过**。因为它一定不能作为腰，并且如果他可以与其他的边组成等腰三角形/等边三角形，也一定可以在腰的地方筛出这条边。

结论：如果一个边的出现次数不满$2$次，直接跳过。  

接下来我们分类讨论：
1. 如果某条边出现$2$次  
那么我们算出这条边可以组成三角形的上界和下届，用组合数学方法计数即可。  
2. 如果某条边出现$3$次及以上  
那么这些边中任意选三个都能满足。直接用组合数即可。

核心伪代码（两行）：
```cpp


	a[i]>=3    :    ans=(ans+(1LL*(a[i]*(a[i]-1)/2)*(a[i]-2))/3%mod)%mod
	a[i]>=2    :    long long u=(sum[min(mx,2*i-1)]-a[i]+mod)%mod;
					ans=(ans+((1LL*a[i]*(a[i]-1)/2%mod)*u)%mod)%mod;
```

~~赛场上没想出来好惭愧啊~~

点个赞吧

---

## 作者：SUNCHAOYI (赞：8)

可以看得出来这是一道**组合数**求解问题。

### $30pts$ 
直接**暴力枚举**三条边的长度，复杂度为 $Θ(n^3)$。

### $50pts$ 
当所有长度**全部相等**时，等腰三角形的个数为 $\dbinom{n}{3}$，直接特判输出；其余情况仍然暴力枚举。

### $80pts$ 
题目强调需要构成**等腰**三角形，我们将所有能组成三角形的分成两类：**等边与等腰**。 

先给输入的木棍的长度**去一下重**，并记录每一边长的**木棍数量**。然后将不重复的长度**排一个序**。对于**等边三角形**，直接按上述方法求解；对于普通的**等腰三角形**，两层循环进行枚举，**设两条边长为 $b[i],b[j]$ 以及该长度的木棍数量为 $num[i],num[j]$**。如果以 $b[i]$ 为腰，则需要满足 $b[i] \times 2 > b[j]$ 且 $num[j] \ge 2$；若以 $b[i]$ 为底，则需要满足 $num[j] \ge 2$ 即可。

则答案有 $\sum^k_{i = 1} \dbinom{num[i]}{3} + \sum^k_{i = 1} \sum^k_{j = i + 1} \dbinom{num[i]}{2} \times num[j] + \dbinom{num[j]}{2} \times num[i]$。($num[i],num[j],b[i],b[j]$ 要确保满足上述条件)

时间复杂度为 $Θ(n^2)$，还有最后一个部分无法通过。

```cpp
for (int i = 1;i <= k;++i)
	if(vis[b[i]] >= 3) ans += c[vis[b[i]]][3],ans %= mod;//等边 
for (int i = 1;i <= k;++i)
{
	for (int j = i + 1;j <= k;++j)
	{	
		if(2 * b[i] <= b[j]) break;
		if(2 * b[i] > b[j] && vis[b[i]] >= 2) ans += c[vis[b[i]]][2] * vis[b[j]],ans %= mod;//a,a,b a多次出现 
	}
	for (int j = i + 1;j <= k;++j) if(vis[b[j]] >= 2) ans += c[vis[b[j]]][2] * vis[b[i]],ans %= mod;//a,a,b b多次出现 
}
```

### $100pts$ 
考虑将程序进行优化，用**前缀和**来维护木棍长度为 $i$ 时，小于等于第 $i$ 根木棍的长度的数量。这样预处理后，时间复杂度就变为 $Θ(n)$。优化后的代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define mod 998244353
#define ll long long
using namespace std;
const int MAX = 200005;
ll vis[MAX << 1],a[MAX],b[MAX],c[MAX][5],s[MAX << 1],ans,n,k;//数组记得开到最大值的 2 倍，否则在计算两边之和是否大于第三边时会 RE
int main ()
{
	//用杨辉三角计算组合数
	c[0][0] = c[1][0] = c[1][1] = 1;
	for (int i = 2;i <= 200000;++i)
	{
		c[i][0] = 1;//初始化
		for (int j = 1;j <= min (i,3);++j) c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % mod;	
	}
	scanf ("%lld",&n);
	for (int i = 1;i <= n;++i)
	{
		scanf ("%lld",&a[i]);
		if (!vis[a[i]]) b[++k] = a[i];//去重
		vis[a[i]]++;//记录数量
	} 
	sort (b + 1,b + 1 + k);//排序
	for (int i = 1;i < MAX << 1;++i) s[i] = s[i - 1] + vis[i];//前缀和进行预处理
	for (int i = 1;i <= k;++i)
	{
		if(vis[b[i]] >= 3) ans += c[vis[b[i]]][3],ans %= mod;//等边 
		ans += c[vis[b[i]]][2] * (s[b[i] * 2 - 1] - vis[b[i]]),ans %= mod;
	}
	printf ("%lld\n",ans);
	return 0;
}
```

---

## 作者：Ackoter (赞：6)

这就是洛谷官方比赛~~较简单部分的~~第二题吗，I了I了。

这道题目我一眼看过去，不就是数论题吗，等腰三角形的个数什么的，直接统计个数然后排列组合算腰长为a[l]的三角形就行了。


------------
**具体做法**：

1.排序原序列用于统计（或通过计数排序进一步将复杂度降为O(n))
 
   2.通过遍历获取每段的长度
	
   3.同时获取每个长度最多能与多长的木棒组成等腰
   4.计算这个长度的木棒能与前面，自身，后面长度的木棒组合个数。
   

------------
**以下程序均仅有主要部分**

------------
**正解1**:排序
```cpp
sort(a+1,a+1+n);//排序
for(int i=1;i<=n;i++)
	if(a[i]>a[i-1])//判断是否查询到了一段新长度
	{
		while(a[r]<2*a[i-1]&&r<=n) r++;
		r--;//向前找出能与目前腰组合的边长度
		lj=(lj+(i-l)*(i-l-1)/2*(r-i+1)+(i-l)*(i-l-1)*(i-l-2)/6+(i-l)*(i-l-1)/2*(l-1))%mode;
		//别被这坨奇葩东西吓到了，其实分开来很简单
		//lj:累计，这不用说了
		//(i-l)*(i-l-1)/2*(r-i+1)=C(i-l,2)*(r-i+1)
		//即取两条边*比腰长的可组边
		//(i-l)*(i-l-1)*(i-l-2)/6=C(i-l,3)
		//即组成等边三角形的个数
		//(i-l)*(i-l-1)/2*(l-1)=C(i-l,2)*(l-1)
		//即与比腰短的边组合
		l=i;//更新新一段的起始
	}
if(l!=n) lj=(lj+(n-l+1)*(n-l)*(n-l-1)/6+(n-l+1)*(n-l)*(l-1)/2)%mode;
//依照这样算，最后一串边不能计算到，所以要补充一下
cout<<lj;//最后输出就行了，记得在计算时要%一下
```
时间复杂度O(nlogn)//主要是因为快排

------------
**正解2**:计数排序+部分和（原部分和变量是bfh，为了美观改成b了）
```cpp
scanf("%d",&n);
for(int i=1;i<=n;i++)
{
	scanf("%d",&a[i]);
	b[a[i]]++;//记录长度为a[i]的木棍个数
	ma=max(a[i],ma);//求最大长度方便枚举
}
for(int i=1;i<=2*ma;i++) b[i]+=b[i-1];
//部分和，至于为什么2*ma下面会讲
for(int i=1;i<=ma;i++)
	if(bfh[i]>bfh[i-1])//判断是否有找到新的长度
		lj=(lj+(b[i]-b[i-1])*(b[i]-b[i-1]-1)/2*(b[i*2-1]-b[i])+(b[i]-b[i-1])*(b[i]-b[i-1]-1)*(b[i]-b[i-1]-2)/6+(b[i]-b[i-1])*(b[i]-b[i-1]-1)/2*b[i-1])%mode;
		//一如既往的奇葩，但没关系，同样分解开来
		//lj...
		//(b[i]-b[i-1])*(b[i]-b[i-1]-1)/2*(b[i*2-1]-b[i])同正解1
		//(b[i]-b[i-1])*(b[i]-b[i-1]-1)*(b[i]-b[i-1]-2)/6同上
		//(b[i]-b[i-1])*(b[i]-b[i-1]-1)/2*b[i-1]楼上说的对
cout<<lj;//依然不要忘记%哦
```
时间复杂度O(ma)

基于ma=max(a)≤10^5，这种方法应该是最快的了，如果还有更快的方法欢迎回复。


------------
还有奆佬用线段树~~怕不是闲得慌~~
，这里也放上来一下。

------------
**~~大概是~~正解3**:线段树

1.插入
```cpp
void join(int now,long long l,long long r,long long w)
{
	if(l==w&&r==w) {t[now]++;return;}
	if(r<w||w<l) return;
	int mid=(l+r)>>1;
	join(now<<1,l,mid,w);
	join((now<<1)|1,mid+1,r,w);
	t[now]=t[now<<1]+t[(now<<1)|1];
}
```

2.查找~~但我也不知道查找的是啥~~
```cpp
long long finds(int now,long long l,long long r,long long L,long long R)
{
	if(L<=l&&r<=R) return t[now];
	if(r<L||R<l) return 0ll;
	int mid=(l+r)>>1;
	return finds(now<<1,l,mid,L,R)+finds((now<<1)|1,mid+1,r,L,R);
}
```
3.好像也是部分和，但天知道怎么扯上线段树的。
```cpp
    for(int i=1;i<=n;i++)
    {
    	scanf("%lld",&a[i]);
    	ma=max(ma,a[i]);
    	f[a[i]]++;
    }
    for(int i=1;i<=n;i++) join(1,1,ma,a[i]);
    for(long long i=1;i<=ma;i++)
    	if(f[i]>1)
    	{
    		long long sum=((f[i]*(f[i]-1))>>1)%mod;
    		sum=sum*(finds(1,1,ma,1,min((i<<1)-1,ma))-f[i])%mod;
    		if(f[i]>2) sum=(sum+(f[i]*(f[i]-1)*(f[i]-2)/6)%mod)%mod;
    		ans=(ans+sum)%mod;
    	}
    cout<<ans;
```


------------
还有位奆佬用了平衡树（Leafy Tree）~~说实话我也不知道是啥~~。

------------
**~~这大概又是一个~~正解4**:平衡树（Leafy Tree）
```cpp
#include<bits/stdc++.h>
#define ls  T[now].son[0]
#define rs T[now].son[1]
#define modd 998244353ll
using namespace std;
const double alp=1.0-sqrt(2)*0.5;
const double bta=(1.0-alp*2.0)/(1.0-alp);
const int Maxn=4000005;
long long n,ans; 
long long a[Maxn];
long long flag[Maxn];//每一个数字出现的次数
struct dataa
{
	int si,va;
	int son[2];
}T[Maxn<<1];
int cnt=0;
int new_tree(int _v,int _s,int _l,int _r)//新建一个节点 
{
	int node=++cnt;
	T[node]=(dataa){_s,_v,_l,_r};
	return node;
}
int root=new_tree(0x3f3f3f3f,0,0,0);
void pushup(int now)//维护父节点的数值 
{
	if (ls==0) return ;
	T[now].si=T[ls].si+T[rs].si;
	T[now].va=T[rs].va;
	return ;
}
int finds(int now,int v)//查找某一节点 
{
	if (!ls) 
	{
		if (T[ls].va!=v) return -1;
		return now;
	}
	return finds(T[now].son[(v>T[ls].va)],v);
}
int Mix(int a,int b)//Leafy Treeの合并 将两个节点合并起来  
{
	int res=new_tree(0,0,0,0);
	T[res].son[0]=a;
	T[res].son[1]=b;
	pushup(res);
	return res;
}
void rot(int now,int q)//旋转 
{
	if (!ls) return ;
	int nms=T[T[now].son[q]].son[q];
	if (q)
	ls=Mix(ls,T[rs].son[0]);else
	rs=Mix(T[ls].son[1],rs);
	T[now].son[q]=nms;
} 
void remain(int now)//维护Leafy Tree平衡 
{
	if (!ls) return ;
	int q=0;
	if  (T[ls].si<T[now].si*alp) q=1;
	else if  (T[rs].si<T[now].si*alp) q=0; 
	else return ;
	if (T[T[T[now].son[q]].son[q^1]].si>=T[T[now].son[q]].si*bta) rot(T[now].son[q],q^1);
	rot(now,q);
}
void ins(int &now,int v)//Z 插入 
{
	if (!now) {now=new_tree(v,1,0,0);return ;}
	if (ls==0) ls=new_tree(min(v,T[now].va),1,0,0),rs=new_tree(max(v,T[now].va),1,0,0);
	else ins(T[now].son[T[ls].va<v],v);
	pushup(now),remain(now);
}
void del(int &now,int v)//删除 虽然这题貌似没必要 
{
	if (!now) return ;
	int p=bool(v>T[ls].va);
	if (!T[T[now].son[p]].son[0])
	{
		if (T[T[now].son[p]].va!=v) return ;
		T[now]=T[T[now].son[(p^1)]];
	} 
	del(T[now].son[p],v);
	pushup(now),remain(now);
}
long long ran(int now,int v)//寻找某个数字的排名哒（比他所有小的数字的数量+1） 
{
	if (!ls) return 1;
	int p=(v>T[ls].va);
	if (p==1) return ran(rs,v)+T[ls].si; else return ran(ls,v);
}
int kth(int now,int k)//寻找第K大的数 
{
	if (!T[now].son[0]) return T[now].va;
	if (T[ls].si<k) return kth(rs,k-T[ls].si);
	return kth(ls,k);
}
int main() 
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		ins(root,a[i]);
		flag[a[i]]++; 
	} 
	for (int i=1;i<=n;i++)
	{
		if (flag[a[i]]<2) continue;
		ans=(ans+(((ran(root,a[i]*2)-flag[a[i]]-1)*((flag[a[i]])*(flag[a[i]]-1)/2))%modd+((((flag[a[i]])*(flag[a[i]]-1))*(flag[a[i]]-2))/6)%modd))%modd;//推理公式纯爱战士大佬已经写过，不再赘述
		flag[a[i]]=0;
	}
	cout<<ans;
    return 0;
}
```
上面的注释是码者写的，关于编者的话一个标点符号都不要信。

------------
特别鸣谢:

@zuy雪·tong缘 （线段树）

@我是牛头人哒 （平衡树）


---

## 作者：monstersqwq (赞：5)

### 题意：

给出 $n$ 个木棍的长度，问在这些小木棍中能够取出多少个不同的等腰三角形（三边编号升序排序后，任意一个编号不同即视为是不同三角形，而不是不全等），对 $998244353$ 取模。

### 思路：

本来没有什么太好的思路，但是看到值域：

$$a_i\le 2 \times 10^5$$

就想到可以用桶去处理本题。

所以我们用 $c_i$ 表示长度为 $a_i$ 的木棍的数量，那么就可以枚举腰长，然后计算结果。

对于每个腰长 $i$，如果 $c_i\ge2$，可以分为两种情况：与一个其它长度的木棍（长度小于 $2i$）或三个同样的小木棍组成三角形。（$c_i\ge 3$）

前一种情况答案为：

$$C_{c_i}^2 \times((\sum\limits^{2i-1}_{j=1}c_j)-c_i)$$

后面一种情况答案为：

$$C_{c_i}^3\quad(c_i\ge 3)$$

前面的 $\sum\limits^{2i-1}_{j=1}c_j$ 明显可以用前缀和优化一波，所以总复杂度就是 $O(n+\text{值域})$，可以通过本题

几个小提醒：

- 因为最大要调用 $sum_{2n-1}$，所以 $c$ 和 $sum$ 数组都要开两倍，$sum$ 要求到两倍，或者也可以在统计的时候写 $sum_{\min(n,2i-1)}$。
- 不开 long long 不知道会不会见祖宗，但是个人感觉第一种情况乘法可能会爆 int，毕竟这个算法是 $O(n+\text{值域})$ 的常数大一点没关系还是开一下吧。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
using namespace std;
long long n,a[200005],c[400005],sum[400005];
long long ans=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		c[a[i]]++;
	}
	for(int i=1;i<=4e5;i++)//注意循环上限 
	{
		sum[i]=sum[i-1]+c[i];
	}
	for(int i=1;i<=2e5;i++)
	{
		if(c[i]>=2)
		{
			ans=(ans+c[i]*(c[i]-1)*(sum[i*2-1]-c[i])/2+c[i]*(c[i]-1)*(c[i]-2)/6)%998244353;//这里没有特判因为若c[i]=2，那么那个式子就是0，没有影响 
		}
	}
	cout<<ans<<endl;
    return 0;
}
```


---

## 作者：Hexarhy (赞：4)

**upd: 修正了公式错误，并重写了 $\LaTeX$。**

### Preface

CF 风格题，做法比较显然，细心就行。

正解是线性做法，这里介绍赛时的 $\Theta(n\log n)$ 做法。

### Solution

等腰三角形的边长只有两种数，记为 $x,y(x<y)$。那么只要枚举一个，求另一个有多少即可。

为了方便统计，将 $a_i$ 进行排序。

注意到值域很小，我们可以开桶统计。为了减少遍历，将 $a_i$ 进行去重，并在这之前记录每个长度的木棍数量。对于长度为 $a_i$ 的木棍，其相同长度的木棍的数量记为 $cnt_i$。

接下来就考虑在 $\Theta(n)$ 枚举 $x$ 的基础上，如何快速求出 $y$。

不难想到二分。结合三角形的三边关系，对于每一个枚举到的 $x$，有 $2x<y$。使用 `std::lower_bound()` 可以 $\Theta(\log n)$ 求出**最大的**符合要求的 $y$，其位置记为 $p$。

然后思考如何统计贡献。

简单地分类讨论一下：

- 对于三边相等，以 $x$ 为边长时贡献增加了 $\dbinom{cnt_{x}}{3}$。

- 对于仅有两边相等的，每个以 $x$ 作为腰，$i\in[1,p]$ 中的每一个 $a_i$ 都可以作为底边 $y$，当然还要保证 $x\neq y$。那么根据计数原理，增加的贡献的就是： 

$$ \binom{cnt_{x}}{2}\left(\left(\sum^p_{k=1} cnt_{a_k}\right)-cnt_{x}\right)$$

组合数可以递推预处理。$\sum^p_{k=1} cnt_{a_k}$ 用前缀和预处理。

总时间复杂度是 $\Theta(n\log n)$。

### Notice

- 记得取模。

- 组合数 `c[i][j]` 肯定不能开到 $10^5\times10^5$，$j$ 最大值只有 $3$。特判 $i<j$ 即可。

- `std::unique()` 可以去重，但是请注意其用法。这里不再赘述。

### Code

```cpp
#include <iostream>
#include <cstdio>
#include <climits>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MAXN=2e5+5;
const int MOD=998244353;
ll n,ans;
ll a[MAXN],cnt[MAXN],s[MAXN];
ll C[MAXN][10];

void calc(void)//递推预处理组合数
{
	C[1][0]=C[1][1]=1;
	for(int i=2;i<=n;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=4;j++)
		 C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	}
}
inline ll nCr(const int x,const int y)//特判
{
	return x<y?0:C[x][y];
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin>>n;
	calc();
	for(int i=1;i<=n;i++)
	 cin>>a[i];
    for(int i=1;i<=n;i++)
     cnt[a[i]]++;//计数长度 a 出现次数
    sort(a+1,a+1+n);
    int nn=unique(a+1,a+1+n)-a;
    nn--;//去重后的元素个数
    for(int i=1;i<=nn;i++)
     s[i]=s[i-1]+cnt[a[i]];//前缀和
    for(int i=1;i<=nn;i++)
    {
    	ans=(ans+nCr(cnt[a[i]],3))%MOD;//等边三角形
		int j=lower_bound(a+1,a+1+nn,2*a[i])-a;//二分找到最大的符合要求的 b
 		ans=(ans+nCr(cnt[a[i]],2)*(s[j-1]-cnt[a[i]])%MOD)%MOD;//统计贡献
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：yhk1001 (赞：2)

我来介绍一下二分做法。首先利用桶的思想用数组 $a$ 记录每种长度的木棍各有几根，再开一个数组 $b$ 记录所有出现过的长度。枚举腰长，由于三角形两边之和大于第三边，在 $b$ 数组中二分查找最大的小于两倍腰长的木棍长度，则所有小于等于该长度的木棍均可作为底边。

至于方案数，可以分两部分来计算。第一部分是用和腰长相等的木棍组成的三角形的个数，设共有 $x$ 个木棍，则个数为 $C_{x}^{3}$ 个。另一部分是用和腰长不等的木棍组成的三角形个数，统计可用的木棍数 $sum$ ,则个数为 $C_{sum}^{1} \times C_{x}^{2}$ 个。总个数为这两部分之和。

于是可以得到这样的代码。
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const long long P = 998244353;
long long a[200005],b[200005];

int main()
{
	int n;
	cin >> n;
	int cnt = 0;//不同的长度个数
	for (int i = 1;i <= n;i++)
	{
		int num;
		cin >> num;
		if (a[num] == 0)//这种长度没出现过
		{
			cnt++;
			b[cnt] = num;//记录
		}
		a[num]++;//桶记录
	}
	sort(b + 1,b + cnt + 1);
	long long ans = 0;
	for (int i = 1;i <= cnt;i++)//枚举腰
	{
		int len = b[i] * 2;
		int pos = lower_bound(b + 1,b + cnt + 1,len) - b - 1;//二分查找，lower_bound会返回数组中第一个大于等于元素的地址，再减一就是小于二倍腰长的位置
		long long sum = 0;
		for (int j = 1;j <= pos;j++)//统计可用的木棍总数
		{
			sum += a[b[j]];
		}
		ans += (sum - a[b[i]]) % P * (a[b[i]] * (a[b[i]] - 1) / 2 % P);//第二部分
		ans %= P;
		ans += a[b[i]] * (a[b[i]] - 1) / 2 % P * (a[b[i]] - 2) / 3 % P;//第一部分
		ans %= P;
	}
	cout << ans << endl;
	return 0;
}
```
但是这份代码会超时一个点，时间主要花费在统计木棍总数上，每次都要重新统计。可以利用前缀和优化，最终复杂度 $O(nlogn)$ 。

最终代码 [提交记录](https://www.luogu.com.cn/record/35726806)
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const long long P = 998244353;
long long a[200005],b[200005],s[200005];//s为前缀和数组

int main()
{
	int n;
	cin >> n;
	int cnt = 0;
	for (int i = 1;i <= n;i++)
	{
		int num;
		cin >> num;
		if (a[num] == 0)
		{
			cnt++;
			b[cnt] = num;
		}
		a[num]++;
	}
	sort(b + 1,b + cnt + 1);
	for (int i = 1;i <= cnt;i++)
	{
		s[i] = s[i - 1] + a[b[i]];//计算前缀和
	}
	long long ans = 0;
	for (int i = 1;i <= cnt;i++)
	{
		int len = b[i] * 2;
		int pos = lower_bound(b + 1,b + cnt + 1,len) - b - 1;//二分查找
		long long sum = s[pos];
		ans += (sum - a[b[i]]) % P * (a[b[i]] * (a[b[i]] - 1) / 2 % P);
		ans %= P;
		ans += a[b[i]] * (a[b[i]] - 1) / 2 % P * (a[b[i]] - 2) / 3 % P;
		ans %= P;
	}
	cout << ans << endl;
	return 0;
}
```
希望管理给过。

---

## 作者：sfmmdm (赞：1)

~~本蒟蒻在月赛时沉迷于第三题，这题搜索只过了50分，满满的都是泪啊。~~

以下题解是以我思考的整个思路来写，可能会比较繁琐。

言归正传，这题的正解写起来比搜索还要简单的。

首先，想想substack3的思路，在substack3里，所有边相等，所以相当于就是求 $C_n^3$

类比这样的方法，只要先把边长一样的放在一起，单独处理完等边三角形的个数，再考虑两边相等的等腰三角形。

既然要集中所有边相等的三角形，肯定是要先排序。

对于排完序的数组，我们可以对每种长度的木棍进行分组，把所有长度相等的木棍分到一组。

设这个组的木棍个数为 $cnt$，当 $cnt>2$ 时，就可以先求出组内等边三角形的个数

$$C_{cnt}^3=\frac{cnt(cnt-1)(cnt-2)}{6}$$

然后，在这组木棍中任选两根，与其他长度的木棍进行匹配。设$c2=C_{cnt}^2=\dfrac{cnt(cnt-1)}{2}$。

显然，如果第三边小于作腰的两条边，无论如何都会满足三角形不等式，所以，可以用 $sumcnt$ 记录前面所有组中的木棍根数，与该组的 $c2$ 相乘。

但如果碰到大于这组边长的呢？

可以对后面每组木棍进行判断，如果木棍长度大于等于这组木棍长度的二倍，就不再加了。但这样做比较麻烦。

但我们可以先用 $sumc2$ 累加这组木棍的 $c2$，再后面计算到其他组木棍的个数的时候，再用那组木棍数乘 $sumc2$，同时，只要这组木棍的长度大于等于前面的组中的长度的二倍，就将 $sumc2$ 减掉那组的 $c2$。

也就是说，对于每一组木棍，只选择与长度比其小的木棍进行匹配，可以在该组中选择一根与前面符合条件的每一组的两根进行匹配，也可以在该组选择两根与前面每组选一根进行匹配。

对于 $c2$，可以用一个队列来维护，只要队头的长度小于等于队尾的二分之一，就将队头出队，同时 `sumc2-=c2`。

还要注意一点，因为模运算对除法没有分配率，所以在统计 $C_{cnt}^2$ 与 $C_{cnt}^3$ 时，不可以取模。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int P=998244353;
struct node{
	int lth;
	long long c2;
} q[200005];
int a[200005];
int main() {
	int n,head=0,tail=0,ans=0,sumcnt=0;
	long long sumc2=0;
	scanf("%d",&n);
	for(int i=1; i<=n; i++) scanf("%d",a+i);
	sort(a+1,a+1+n);
	int t=a[1],cnt=1;
	for(int i=2; i<=n+1; i++) {
		if(a[i]==t) cnt++;
		else {
			tail++;
			ans=(ans+(long long)sumc2*cnt)%P; //该组的一根匹配前面的两根
			if(cnt>1) {
				q[tail].c2=(long long)cnt*(cnt-1)/2; //注意这里不能取模，c2用long long存
				ans=(ans+(long long)sumcnt*q[tail].c2)%P; //该组两根匹配前面的一根
				sumc2+=q[tail].c2;
			}
			q[tail].lth=t;
			sumcnt+=cnt;
			if(cnt>2) ans=(ans+(long long)cnt*(cnt-1)*(cnt-2)/6)%P; //这里也没有对等边三角形个数取模，只是在ans加的时候取模。
			t=a[i];
			cnt=1;
			while(head<tail&&2*q[head+1].lth<=t) { //当队头的lth小于等于二分之一的当前长度，即出队。
				head++;
				sumc2-=q[head].c2;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：lcy09 (赞：1)

### 题面

[P6686 混凝土数学](https://www.luogu.com.cn/problem/P6686)

### 分析

这个题让我们找出选出三根木棍，能构成等腰三角形的方案。要构成等腰三角形，我们首先需要找出两根长度相等的木棍，设其长度为$length$,然后再找出一根长度为$len$,满足$0 < len < 2*length,len\ne length$的木棍。

可以看出这需要我们快速地找出长度小于某一个值的所有木棍的数量，又看到数据范围$1\leqslant a_i \leqslant 10^5$,那么就可以想到建立桶数组bin，$bin_i$表示长度为$i$的木棍数量，我们再对bin记录前缀和sum数组，那么就可以$O(1)$地查询长度小于某个值的所有木棍的数量。

注意到所有木棍都是有标号的，那么我们在选长度相等的木棍的时候，就要用到组合数，即选出两根长度为$i$的木棍的方案数为$C_{bin_i}^2,bin_i \geqslant 2$;同时由于等边三角形也算等腰三角形，那么对于所有$bin_i \geqslant 3$也要计算等边三角形的方案数，即$C_{bin_i}^3$.

所以我们的答案为(Maxlength表示出现过的最长的木棍长度)

$$
\sum\limits_{i=1}^{Maxlength} C_{bin_i}^2*(sum_{2*i-1}-bin_i)+C_{bin_i}^3
$$
（第一项仅针对$bin_i\geqslant 2$的情况，且因为是在求等腰三角形，所以要注意减去自己，即$bin_i$; 第二项仅针对$bin_i\geqslant 3$的情况）

### 代码

```cpp
#define int long long//判断了下数据范围应该要开long long
using namespace std;
const int MAXN=200005;
const int mod=998244353;
int n;
int bin[MAXN],Max;//桶数组与出现过的最大长度
int sum[MAXN];//前缀和数组
int ans;//答案
signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        int l;
        scanf("%lld",&l);
        bin[l]++;//建立桶
        Max=max(Max,l);
    }
    for(int i=1;i<=Max;i++) sum[i]=sum[i-1]+bin[i];//建立前缀和
    for(int i=1;i<=Max;i++)
    {
        if(bin[i]>=2)//对应式子第一项
        {
            int temp=sum[min(2*i-1,Max)]-bin[i];
            temp=temp*bin[i]*(bin[i]-1)/2%mod;
            ans=(ans+temp)%mod;
            if(bin[i]>2)//对应式子第二项
            {
                ans+=(bin[i]*(bin[i]-1)*(bin[i]-2)/6)%mod;
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：Alarm5854 (赞：1)

~~好久没写题解了，这次我写一篇。~~

这一题并不难，由于是组成等腰三角形，所以可以枚举腰长，而枚举腰长的时候需要分一般的等腰三角形和等边三角形讨论。先用一个`cnt`数组储存每一个数出现的次数，再用`sum`数组储存小于等于这个数的数出现的次数。由于两边之和大于第三边，所以长为 $a_i$ 的木棍组成一般的等腰三角形的个数就是 $a_i\times (a_i-1)\times (sum_{a_i}-cnt_{a_i})/2$，组成等边三角形的个数就是 $a_i\times(a_i-1)\times(a_i-2)/6$，注意对 $998244353$ 取模。
```cpp
#include<cstdio>
#include<algorithm>
#define ll long long
#define f2(x) (((x) * ((x) - 1) / 2) % MOD)//x*(x-1)/2
#define f3(x) (((x) * ((x) - 1) * ((x) - 2) / 6) % MOD)//x*(x-1)*(x-2)/6
using namespace std;
const int N = 200000 + 10;
const int MOD = 998244353;
FILE *fin, *fout;
inline int read(ll &x) {
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
inline int write(ll x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
ll n, ans, a[N], vis[N], cnt[N * 2], sum[N * 2];
int main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6686.in", "rb");
	fout = fopen("P6686.out", "wb");
	#endif
	for (ll i = read(n); i <= n; ++i) read(a[i]), ++cnt[a[i]];
	for (ll i = 1; i < N * 2; ++i) sum[i] = sum[i - 1] + cnt[i];
	for (ll i = 1; i <= n; ++i) if (!vis[a[i]]) vis[a[i]] = 1, ans = (ans + f3(cnt[a[i]]) + f2(cnt[a[i]]) * (sum[a[i] * 2 - 1] - cnt[a[i]])) % MOD;//注意标记，否则会重复计算
	write(ans); return 0;
}
```

---

## 作者：J与M等于Y (赞：0)

既然写了 $T_1$ 了，这篇也顺便写写掉吧。

### 注意事项：

我的代码中可能有一些奇怪的变量名：

#### ak ：

在题中是取模用的，~~表示我对AK月赛的人的膜拜~~。

本文用到的一些算法/数据结构：桶+前缀和+排列组合

好了，步入正题！

## [$\text{题意}$](https://www.luogu.com.cn/problem/P6686)

此题是要找到三个木棒，使其构成一个等腰三角形。很明显，有两个木棒长度是相同的。

### 如何求解不是等边三角形的等腰三角形的个数？

注：此框下的所有等腰三角形均不包括等边三角形。

我们可以假设长度相同的木棒长度为 $x$，一共有 $n$ 根，则其中任取两根都可以与剩下的那根拼成等腰三角形（因为这里我们已经假设了其中有两根木棒可以和剩下的拼成等腰了）。那这样的情况一共有几种呢？

诶——这不是一道排列与组合吗？在 $n$ 个木棒中任取两根，不计顺序，不就是 $C_n^2$吗？

而我们知道 $C_n^2=\frac{n\times (n-1)}{2}$，即得到答案。

那最后一根木棒该如何求解呢?~~爆搜~~，当然会炸。。。因为我们知道等腰三角形的底边只需满足 $0<y<2x$ 即可，所以可以直接用前缀和来求解。下面给出一种优化方案。

首先，因为最大 $a_i$ 不大，所以可以用桶 $b[i]$ 记录每种长度的木棒有几个。再用前缀和 $sum[i]$ 数组求出截止到长度为 $i$ 的木棒一共有几个。这样对于腰长为 $x$ 的等腰三角形来说底边可取 $sum[2i-1]-b[i]$ 种情况。最后腰长为 $x$ 的等腰三角形的个数即是 $C_n^2\times (sum[2i-1]-b[i])$ 个。

代码：

```cpp
for(int i=1;i<=mx;i++){
	if(b[i]>1){//这判定不写也没什么事，但时间复杂度会略高一些。
		t=b[i]*(b[i]-1)/2%ak;//腰长为i时腰可取的情况数
		t*=(sum[i*2-1]-b[i]);//腰长为i时第可取的情况数
		t%=ak;//取模
	}
}
```

### 如何求解边长为 $x$ 的等边三角形个数？

这应该很简单吧，就是在 $n$ 个木棒中取三个木棒，不计顺序，即 $C_n^3$。

而 $C_n^3= \frac{n!}{(n-3)!\times 3!}=\frac{n(n-1)(n-2)}{6}$，可以快速求解。

```cpp
if(b[i]>2) t=b[i]*(b[i]-1)*(b[i]-2)/6%ak;
t%=ak;
```

好了，现在只要将两部分加起来就可以了。直接上核心代码吧。

```cpp
for(int i=1;i<=mx;i++){//mx指最大的a[i]
	if(b[i]>1){//前面已经说过了。
		t=b[i]*(b[i]-1)/2%ak;
		t*=(sum[i*2-1]-b[i]);
		if(b[i]>2) t=t+b[i]*(b[i]-1)*(b[i]-2)/6%ak;
		t%=ak;
		ans+=t;
		ans%=ak;
	}
}
```

这道题顺利过关！又A一题！

---

## 作者：lndjy (赞：0)

考虑等腰等边分别计数。

对于等腰非等边三角形，所有非腰边长度都需要计算。

等边三角形只有这个边需要计算。

由于上面的方法是依靠木棍的长度的，所以需要按值域计算。值域不大不用离散化，直接开桶 $t$。

快速计算出可以组成三角形的可以前缀和优化，注意要对桶前缀和。

两边之和大于第三边，所以设腰为 $i$ ，只有小于等于 $2\times i-1$ 的边可以组成。这两边的组成为 $C(t_i,2)$，加上第三边组成 $sum_{i\times 2-1}-t_i$,乘起来为对答案的贡献。

等边三角形比较简单，直接是 $C(t_i,3)$,加起来就可以了。注意只有边数大于2和3时，对应的才可以计数，否则可能出现负数。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define int long long
using namespace std;
int inline read()
{
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*f;
}
const int p=998244353;
int n,a[400005],t[400005],sum[400005];
long long ans;
int c(int x,int y)//组合数
{
	if(y==2)
	{
		int ans=1;
		ans*=x*(x-1)/2;
		return ans%p;
	}
	else
	{
		int ans=1;
		ans*=x*(x-1);
		ans%=p;
		ans*=(x-2);
		ans%=p;
		ans*=166374059;
		ans%=p; 
		return ans%p;
	}
}
signed main()
{
	n=read();
	int maxx=0;
	for(int i=1;i<=n;i++)
	a[i]=read(),t[a[i]]++,maxx=max(maxx,a[i]);//桶
	for(int i=1;i<=maxx*2;i++)
	{
		sum[i]=sum[i-1]+t[i];//前缀和
	}
	for(int i=1;i<=maxx;i++)
	{
		if(t[i]>=2)
		ans+=c(t[i],2)*(sum[i*2-1]-t[i]);//等腰
		ans%=p;
		if(t[i]>=3)
		ans+=c(t[i],3);//等边
		ans%=p;
	//	cout<<ans<<" ";
	}
	cout<<ans;
	return 0;
}
```


---


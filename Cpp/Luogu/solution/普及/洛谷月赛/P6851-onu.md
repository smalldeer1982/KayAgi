# onu

## 题目背景

小 C 和小 D 是好朋友。他们正在尝试一种全新的牌类游戏——onu！

## 题目描述

为了增加一点趣味性，小 C 和小 D 每人买了 $v$ 颗糖用来当作筹码。

onu 的规则是这样的：

游戏共 $m$ 轮，由两人进行，一位先手，一位后手。在这里，我们默认先手的玩家是小 C，而后手的玩家是小 D。

在最开始时，小 C 会得到 $m$ 张牌，每张牌有其对应的花色、点数。而小 D 会得到 $n$ 张牌。

每一轮开始时，小 C 会打出一张牌，放在桌面上展示给小 D 看。

在此之后，小 D 需要跟牌，即打出他手上的一张牌，且该张牌必须满足其花色与小 C 打出的牌相同。若小 D 没有满足条件的牌或者是他**选择弃权（也就是说，可以选择当前回合是否打出牌）**，弃掉小 C 打出的牌后跳过该轮，视为小 D 败。

在小 D 打出满足要求的牌后，进行一次拼点，也即比较小 C 和小 D 打出的牌的点数：如果小 D 出的牌的点数**大于等于**小 C 的牌的点数，则小 D 胜，否则小 D 败。容易知道，这样不会出现平局的情况。

最后，胜的一方会从败的一方拿走 $c$ 颗糖，且双方均需弃掉打出的牌，并会**再从商店买等于自己打出的牌的点数颗糖**。例如小 C 和小 D 打的点数分别是 $3$ 和 $5$，那么小 C 会去购买 $3$ 颗糖，小 D 购买 $5$ 颗。

为了不破坏两人间的友好关系，不出现一方被另一方完全赢光的情况，他们在最开始买糖时，已经约定好了 $v \ge c \times m$。

现在，小 D 通过一些神秘手段，知道了小 C 在这 $m$ 轮中打出的所有牌，他希望在 $m$ 轮游戏进行之后，让自己的糖数尽量多。你可以帮他找到最优的方案吗？

## 说明/提示

#### 「样例 1 解释」

以 $(a, b)$ 来表示一张花色为 $a$，点数为 $b$ 的牌。

一开始，小 D 有 $4$ 颗糖。小 C 会依次打出 $(1, 6), (3, 5), (1, 4)$ 三张牌。

一种最优的方案是：

第一轮，小 C 打出第一张牌 $(1, 6)$，小 D 打出第二张牌 $(1, 2)$，小 D 负，被拿走 $1$ 颗糖，购买 $2$ 颗糖。此时其有 $5$ 颗糖。

第二轮，小 C 打出 $(3, 5)$，小 D 打出 $(3, 5)$，由于点数**大于等于**小 C 的牌，所以小 D 胜，拿到 $1$ 颗糖，购买 $5$ 颗糖。此时其有 $11$ 颗糖。

第三轮，小 C 打出 $(1, 4)$。由于小 D 在第一轮已经打出过第二张牌 $(1, 2)$ 了，所以没有牌能打，输出 $-1$ 并判小 D 负，被拿走 $1$ 颗糖，此时其有 $10$ 颗糖。

#### 「样例 2 解释」

最开始有 $5$ 颗糖。

第一轮时小 C 打出 $(1, 8)$，小 D 选择弃权，败，于是剩下了 $5 - 1 = 4$ 颗糖；

第二轮时小 C 打出 $(1, 4)$，小 D 打出 $(1, 5)$，胜，得到 $5 + 1$ 颗糖，故最终小 D 有 $10$ 颗糖。

----

#### 「Special Judge 说明」

**请认真阅读输出格式**。

每个测试点仅有 $0$ 分和满分的区别。如果你的输出出现了以下情况，将会被判为 $0$ 分：

- 输出格式不符，如没有正确换行，输出了一些奇奇怪怪的字符等。
- 输出的最优糖果数与标准答案不同。
- 打牌的方案不合法，即不能打出已经弃掉的牌，也不能打出花色与小 C 打出的牌不相同的牌。
- 按照你所输出的方案打完牌后，小 D 的剩余糖果数与你第一行所输出的数字不同。

---

#### 「数据范围」

**本题采用捆绑测试**。

- Subtask 1(10 points)：$n, m \le 5$；
- Subtask 2(30 points)：$n, m \le 1000$；
- Subtask 3(20 points)：$c = 0$；
- Subtask 4(20 points)：$a _i = 1$；
- Subtask 5(20 points)：无特殊限制。

所有数据保证 $1 \le n, m, a _i, b _i\le 10 ^5$，$0 \le c \le 10 ^5$，$c \times m \le v \le 10 ^{12}$。

## 样例 #1

### 输入

```
3 3 1 4
3 5
1 2
2 6
1 6
3 5
1 4```

### 输出

```
10
2
1
-1```

## 样例 #2

### 输入

```
1 2 1 5
1 5
1 8
1 4```

### 输出

```
10
-1
1```

# 题解

## 作者：yangwenbin (赞：10)

# 题解 P6851 【onu】

[P6851 onu](https://www.luogu.com.cn/problem/P6851)

这道题是一道很典型的贪心的题目。

首先小 D 每一次出牌都会买等于自己牌面的糖果数

其次赢了还可以多拿到 c 个糖果 ， 输了就失去 c 个糖果。

所以要赢，同时要赢得大。

这里就很像田忌赛马了。用自己小的和别人大的比，用大的去赢别人。

但这多一个颜色，就在排序贪心是，优先颜色（从小到大），其次牌面（从大到小）

操作时，先赢后输，先把能赢得都赢了，再考虑怎么输：


```cpp
inline void win()
{
	int i = 1,j = 1;
	for (; i <= n; ++i)
	{
		if (put[i]) continue;
		while (C[j].color < D[i].color && j <= m) ++j; // 调整颜色至两张牌颜色统一
		for (;j <= m && D[i].color == C[j].color; ++j)
		{
			if (vis[j]) continue;// 如果这张牌用过了就跳过
			if (D[i].num >= C[j].num) //能赢的最大的牌，赢掉这张，最大降低对方牌面大小
			{
				put[i] = vis[j] = true;
				sum += (D[i].num + each);
				ans[C[j].indax] = D[i].indax;
				break;
			}
		}
	}
	return ;
}
```

然后考虑输的情况，大大牌肯定是要出的，小牌可以不出，

如果，小 D 的牌少，就输出 -1 ，所以

```cpp
inline void lose()
{
	int i = 1,j = 1;
	for (; i <= n; ++i)
	{
		if (put[i]) continue;
		while (C[j].color < D[i].color && j <= m) ++j;
		for (;j <= m && D[i].color == C[j].color; ++j)
		{
			if (vis[j]) continue;
			sum += (D[i].num - each);
			put[i] = vis[j] = true;
			ans[C[j].indax] = D[i].indax;
			break;
		}
	}
	for (int x = 1; x <= m; ++x)
	{
		if (vis[x]) continue;
		sum -= each;
	}
	return ;
}
```


# code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int SIZE = 1e5 + 50;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		f = (ch == '-' ? -1 : 1);
		ch =  getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,m,each,sum;
int color[SIZE],ans[SIZE];
bool vis[SIZE],put[SIZE];
struct onu
{
 	int color,num,indax;
};
onu C[SIZE],D[SIZE];

inline bool cmp(onu a,onu b) 
{
	return (a.color == b.color ? (a.num == b.num ? a.indax < b.indax : a.num > b.num) : a.color < b.color);
}

inline void get()
{
	memset(ans,-1,sizeof(ans));
	n = read();m = read();each = read();sum = read();
	for (int i = 1; i <= n; ++i)
	{
		D[i].color = read();D[i].num = read();D[i].indax = i;
	}
	for (int i = 1; i <= m; ++i)
	{

		C[i].color = read();C[i].num = read();C[i].indax = i;
	}
	sort(C+1,C+1+m,cmp);sort(D+1,D+1+n,cmp);
}

inline void win()
{
	int i = 1,j = 1;
	for (; i <= n; ++i)
	{
		if (put[i]) continue;
		while (C[j].color < D[i].color && j <= m) ++j;
		for (;j <= m && D[i].color == C[j].color; ++j)
		{
			if (vis[j]) continue;
			if (D[i].num >= C[j].num)
			{
				put[i] = vis[j] = true;
				sum += (D[i].num + each);
				ans[C[j].indax] = D[i].indax;
				break;
			}
		}
	//	cout << D[i].indax << " " << D[i].num << " " << each << " " << sum << endl;
	}
	return ;
}

inline void lose()
{
	int i = 1,j = 1;
	for (; i <= n; ++i)
	{
		if (put[i]) continue;
		while (C[j].color < D[i].color && j <= m) ++j;
		for (;j <= m && D[i].color == C[j].color; ++j)
		{
			if (vis[j]) continue;
			sum += (D[i].num - each);
			put[i] = vis[j] = true;
			ans[C[j].indax] = D[i].indax;
			break;
		}
	//	cout << D[i].indax << " " << D[i].num << " " << each << " " << sum << endl;
	}
	for (int x = 1; x <= m; ++x)
	{
		if (vis[x]) continue;
		sum -= each;
	}
	return ;
}

inline void output()
{
	printf("%lld\n",sum);
	for (int i = 1; i <= m; ++i)
	{
		printf("%lld\n",ans[i]);
	}
	return ;
}

inline void solve()
{
	win();
	lose();
	return ;
}

signed main()
{
	get();
	solve();
	output();
	return 0;
}
```


---

## 作者：vectorwyx (赞：7)

由于不同花色的牌之间不会产生任何关联，因此我们可以**把原问题拆成若干个互相独立的子问题**，在每个子问题中小 C 和小 D 手里的牌的花色都是一致的。换句话说，**花色可以暂且忽略**，我们**只考虑双方手里牌的点数**。那显然有：

> 弃权 < 打出并落败 < 打出并获胜（获得的糖数分别为$-c$,$-c+b$,$c+b$）

因此，我们就得到了**第一个贪心策略**：**每回合能打出牌就打出牌，不管是否获胜**。假设小 C 手里有 $s1$ 张牌，小 D 手里有 $s2$ 张牌，这意味着若 $s2\le s1$，小 D 肯定要**把所有的手牌都打出**；否则，若 $s2 > s1$，小 D 肯定是**把最大的那 $s1$ 张牌都打出**。因此，我们就**能够确定小 D 打出的所有牌**，问题又转化成了**如何最大化小 D 获胜的次数**。

这里要引出**第二个贪心策略**：**优先赢得小 C 打出的牌中点数较小的那些**。想一想，如果小 D 用一张 `6` 去和小 C 的 `7` 拼点，为啥不留着它和小 C 的 `3` 拼点呢？所以，对于小 D 持有的牌来说，**与大的牌拼点始终不如与小的牌拼点好**（这里的“大”“小”是相对来说的），**除非小的牌已经有其他牌和它拼点了**。

因此，我们分别对小 C 手里的牌和小 D 手里的牌**按点数从小到大排序**。然后顺次遍历小 C 手里的牌。对于遍历到的小 C 手里的每一张牌，选择小 D 手中的**第一个没有被使用且点数大于等于它的牌**打出。由于小 D 手里的牌的点数也是升序排列的，所以每次打出的牌的下标单调递增，拿一个变量记录一下就能把这个过程做到线性复杂度。如果当前小 D 手中已经没有满足条件的牌了，就把小 D 手里剩下的牌按随便一个顺序打出。算上排序的复杂度，总时间复杂度为$O(n\log{n)}$。

代码如下（码字不易，希望能给个赞QAQ）：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int maxn=1e5+5;
int a1[maxn],b1[maxn],a2[maxn],b2[maxn],n,m,ans[maxn],c,num[maxn],_num[maxn];
//a1[i],b1[i]为小C手中持有的牌的花色、点数;a2[i],b2[i]为小D手中持有的牌的花色、点数;n,m,c如题所示 
//ans[i]为第i回合小D的选择
//num,_num是用来简化排序的数组 
int st[maxn],top,g[maxn],top2;
bool chosen[maxn];
//chosen[i]表示小D手里编号为i的牌是否已使用 
ll tot;
//tot为所能获得的最大糖果数 
vector<int> g1[maxn],g2[maxn];

bool cmp(int x,int y){
	return b2[x]<b2[y];
}

bool _cmp(int x,int y){
	return b1[x]<b1[y];
}

int main(){
	n=read(),m=read(),c=read();cin>>tot;
	fo(i,1,n) a2[i]=read(),b2[i]=read(),g2[a2[i]].push_back(i);
	fo(i,1,m) a1[i]=read(),b1[i]=read(),g1[a1[i]].push_back(i),g[++top2]=a1[i];
	sort(g+1,g+1+top2);
	top2=unique(g+1,g+1+top2)-g-1;
	memset(ans,-1,sizeof ans);
	fo(i,1,top2){
		int s1=g1[g[i]].size(),s2=g2[g[i]].size();
		if(s2==0){
			tot-=1ll*c*s1;
			continue;
		}
		//借助num和_num数组简化排序，注意下标从0开始 
		fo(j,0,s2-1) num[j]=g2[g[i]][j];
		sort(num,num+s2,cmp);
		fo(j,0,s1-1) _num[j]=g1[g[i]][j];
		sort(_num,_num+s1,_cmp);
		if(s1<s2){//如果s1<s2，就选最大的那s1张牌打出 
			fo(j,0,s1-1) num[j]=num[j+s2-s1];
			s2=s1;
		}
		fo(j,0,s2-1) tot+=b2[num[j]];//只要打出就能获得与点数相同的糖果 
		tot-=1ll*(s1-s2)*c;//处理那些不得不跳过的回合 
		int pos2=0;//记录目前小D手中的牌考虑到了哪里 
		fo(j,0,s1-1){
			while(pos2<s2&&b1[_num[j]]>b2[num[pos2]]) pos2++;//寻找小D手里符合条件的牌 
			if(pos2==s2){//找不到符合条件的牌了 
				top=0;
				//把小D剩下的牌拿出来，每有一张剩下的就会输掉一回合 
				fo(k,0,s2-1) if(!chosen[num[k]]) st[++top]=num[k],tot-=c;//输掉一局的贡献为-c 
				
				fo(k,j,min(j+top-1,s1-1)) ans[_num[k]]=st[k-j+1];//随便按一个顺序打出 
				break;
			}
			//能找到符合条件的牌 
			tot+=c;//贡献为c 
			chosen[num[pos2]]=1;
			ans[_num[j]]=num[pos2];
			++pos2;//pos2位置已经用了，后移一位 
		}
	}
	cout<<tot<<'\n';
	fo(i,1,m-1) printf("%d\n",ans[i]);
	cout<<ans[m];
	return 0;
}
```


---

## 作者：hensier (赞：6)

[获得更好的阅读体验](http://shenyouran.github.io/P6851/)

这是一道贪心题，但细节较多，需要一一考虑。

题目要求的就是获得糖果数量的最大值，因而我们就必须要分析糖果从何而来。

如果小 D 不弃权，不妨设其出的牌点数为 $x$。那么在本题中，糖果的获取 / 失去方式有：

1. 初始糖果数量为 $v$

2. 小 D 与小 C 拼点后获胜，每次可以获得 $c+x$ 颗

3. 小 D 与小 C 拼点后失败，每次可以获得 $x-c$ 颗（即失去 $c+x$ 颗）

4. 小 D 选择弃权，每次可以获得 $-c$ 颗（即失去 $c$ 颗）

本题中，小 C 在拼点上有主动性。即若小 C 发起拼点，则小 D 必须回应。

举个极端的例子：如果小 D 有 $10^5$ 张同种花色的牌，而小 C 却在该花色下没有牌，那么即使小 D 有再多的这种牌，也无济于事。反之，如果小 C 有 $10^5$ 张同种花色的牌，而小 D 却在该花色下没有牌，那么他只能选择弃权（从而失去 $10^5c$ 颗糖果）。

因而，我们必须要利用好小 D 的牌来应对小 C。

在贪心的过程中，我们实际上只需要考虑情况 $2,3,4$。

对于小 D 来说，他只在卡牌的选择上有主动性。~~正是因为有了这个主动性，才有了本题。~~

从整体来看，小 D 应当尽量保证自己赢的次数更多，从而能够赚得更多的糖果（如果赢的次数少，那么输的糖果就多），即多执行情况 $2$。

而情况 $2$ 该以什么样的顺序执行也是一个问题。为了获得更多的糖果，就要让小 D 尽可能打大的牌（这样赢的糖多）。而大牌所选择的拼点对象也得考虑。例如，我们应当避免用小 D 的 $10^5$ 点和小 C 的 $1$ 点进行拼点，否则就失去了一个能够赢过小 C 更大点数牌的机会，也就失去了赢的机会。

因此，我们应当从大到小枚举小 D 牌的点数，然后从大到小寻找小 C 的牌，使得在小 D 能够获胜的情况下，小 C 的牌要尽可能大。

接下里考虑剩余的情况，也就是情况 $2$ 处理完之后还没有打出的牌。

在能赢都赢的情况下，对于小 C 的一张牌，如果我们选择弃权，就失去了糖果，而不弃权的话则还能获得一部分糖果。因此，在小 D 的牌的数量足够的情况下，应当尽量不选择弃权。而如果小 D 剩余的牌大于小 C 的，那么显然应当从大到小进行排序，这样获得的价值就最大。

分析完了之后，我们应当考虑如何编写出这道题的程序来。不妨默认所有的牌都弃权，那么小 D 初始糖果数量就等于 $v-c \times m$。同时建立输出结果的数组，将其全部初始化为 $-1$。这样有便于后续的处理。

对于每一种花色，我们建立一个线性表来分别存储小 D 和小 C 的牌型信息。然后按刚才的思路和顺序进行模拟即可。

`C++` 代码：

```cpp
#include<bits/stdc++.h>
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<10,stdin),p1==p2)?EOF:*p1++)
using namespace std;
int n,m,c,res[100001];//res 保存输出结果
long long v;//v 表示最多能获得糖果的数量（需要开 long long，否则只有 40 分）
char buf[1<<10],*p1=buf,*p2=buf;
struct node//建立结构体来存储每张牌的点数和 id 编号（即输入的顺序）
{
    int val,id;
    bool operator<(const node &a)const//按照点数大小从大到小排序
    {
        return val>a.val;
    }
};
vector<node>a[100001],b[100001];//可以用 vector 形式的线性表来存储两个人手牌的信息
bitset<100001>use;//标记小 D 的牌是否被打出
template<typename t>void read(t &x)
{
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
}
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x;
}
int main()
{
    memset(res,-1,sizeof(res));
    read(n),read(m),read(c),read(v);
    v-=1LL*c*m;//直接默认全弃权，减去 c*m
    for(int i=1;i<=n;i++)a[read()].push_back((node){read(),i});//在对应的花色容器中插入对应的牌型信息（点数和编号）
    for(int i=1;i<=m;i++)b[read()].push_back((node){read(),i});
    for(int k=1,ld,lc,lv;k<=1e5;k++)//在点数最小值和最大值之间枚举
    {
        vector<node>D=a[k],C=b[k];
        ld=D.size(),lc=C.size();
        if(!lc||!ld)continue;
        /*
        如果有一个序列为空就不再操作：
        1. 小 C 序列为空：小 D 无法选择拼点
        2. 小 D 序列为空：程序开头已经默认全部弃权
        */
        sort(D.begin(),D.end());
        sort(C.begin(),C.end());
        //将两个序列排序
        vector<int>vacant;//用来保存在卡牌的 vector 中，未被使用的卡牌编号
        use.reset();//bitset 重置
        for(int i=0,j=0;i<lc&&j<ld;i++)
        {
            if(D[j].val>=C[i].val)//判断小 D 是否能获胜
            {
                res[C[i].id]=D[j].id;
                v+=D[j].val+(c<<1);//前面默认弃权，所以还要多加一个 c
                use[j++]=true;//标记使用
            }
        }
        for(int i=0;i<ld;i++)if(!use[i])vacant.push_back(i);//将没有使用的插入 vector 中
        lv=vacant.size();
        for(int i=0,j=0;i<lc&&j<lv;i++)
        {
            if(res[C[i].id]==-1)
            {
                res[C[i].id]=D[vacant[j]].id;
                v+=D[vacant[j]].val;
                j++;
                //小 C 打出的牌之前弃权的话，可以在此处相应，选择拼点
            }
        }
    }
    printf("%lld\n",v);
    for(int i=1;i<=m;i++)printf("%d\n",res[i]);
    return 0;
}
```

---

## 作者：Cry_For_theMoon (赞：5)

&emsp;&emsp;[传送门](https://www.luogu.com.cn/problem/P6851)

&emsp;&emsp;~~月赛阴间做法，根本不知道有田忌赛马这个题~~

&emsp;&emsp;首先自然而然想到花色分开来处理（想不到的话看sub#4的条件你就明白了），对于同花色怎么匹配就是要考虑的了（或者说这取决了你能否从20pts（sub#3）->40pts(sub#3,#4) -> 100pts)。

&emsp;&emsp;假设对于当前花色，$D$ **赢了** $C$ 的回合的编号分别是 $win_1,win_2,...,win_k$, **这 $k$ 张牌一定是 $C$ 出的最小的该花色的 $C$ 张牌**。反证易得，如果能赢过一个更大的，一定能赢过更小的，但反过来不是。

&emsp;&emsp;那么考虑 $C$ 的最小的牌，如果待选序列里有些牌不能赢过 $C$，它们一定不可能赢过后面所有的，排除。如果不止一张可以，一定选择 **最小的** 可行的，这样后面赢的可能会多。一直在求最小，写个小根堆（写了优先队列200L，加了堆可能能有300L），被排除的加到另外一个堆 $other$ 里面，具体用处等下说，每次看堆顶能不能选就可以了。

&emsp;&emsp;如果堆空了，有些不能选怎么办？记得 $other$ 里面没被用到的牌吗，随便挑一个对应就行了，最后如果空了还有没选的填 $-1$ 即可。

&emsp;&emsp;还有一点是，就算输也必须能出几张牌就出几张牌，因为这样好歹最后还能拿到点数对应的牌，不出就什么收益都没有了

&emsp;&emsp;200+的巨长code放松（如果有巨佬真的愿意看的话）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#include<queue> 
using namespace std;
const int MAXN=1e5+10;
int s4flag = true;
struct Pai{
	int bianhao;
	int number;
	int color;
	bool operator<(const Pai& p)const{
		if(color != p.color){
			return color < p.color; 
		}
		return number > p.number;
	}
};
bool cmp4(const Pai& p1,const Pai& p2){
	return p1.number < p2.number;
}
bool cmp(const Pai& p1,const Pai& p2){
		if(p1.color != p2.color){
			return p1.color < p2.color; 
		}
		return p1.number < p2.number;
}
Pai a[MAXN],b[MAXN];
struct Line{
	int l,r;
};
map<int,Line>aline,bline;
int n,m,sol[MAXN]; 
int colors[MAXN],colortot;
long long v,ans,c;
int vis[MAXN];
int main(){
	cin>>n>>m>>c>>v;
	ans = v;
	for(int i=1;i<=n;i++){
		cin>>b[i].color>>b[i].number;
		b[i].bianhao = i;
		if(b[i].color != 1)s4flag = false;
	}
	for(int i=1;i<=m;i++){
		cin>>a[i].color>>a[i].number;
		a[i].bianhao = i;
		if(a[i].color != 1)s4flag = false;
	}
	if(s4flag){
		sort(a+1,a+1+m,cmp4);
		sort(b+1,b+1+n,cmp4);
		priority_queue<Pai>heap,other;
		if(n < m){
			//a的前n个和m组合 
			for(int i=1;i<=n;i++){
				ans += b[i].number;
				heap.push(b[i]);
			}
			for(int i=1;i<=m;i++){
				if(heap.empty())break;
				while(!heap.empty()){
					Pai crt=heap.top();heap.pop();
					if(crt.number >= a[i].number){
						ans+=c;
						sol[a[i].bianhao] = crt.bianhao;
						break;
					}else{
						other.push(crt);
					} 
				}
			}
			for(int i=1;i<=m;i++){
				if(sol[a[i].bianhao])continue;
				ans -= c;
				if(other.empty()){
					sol[a[i].bianhao] = -1;
				}else{
					Pai crt=other.top();other.pop();
					sol[a[i].bianhao] = crt.bianhao;
				}
			}
		}else{
			//a的前m个和b的后m个组合
			for(int i=1;i<=m;i++){
				ans += b[n-i+1].number;
				heap.push(b[n-i+1]);
			}
			for(int i=1;i<=m;i++){
				if(heap.empty())break;
				while(!heap.empty()){
					Pai crt=heap.top();heap.pop();
					if(crt.number >= a[i].number){
						ans+=c;
						sol[a[i].bianhao] = crt.bianhao;
						break;
					}else{
						other.push(crt);
					} 
					
				}
			}
			for(int i=1;i<=m;i++){
				if(sol[a[i].bianhao])continue;
				ans -= c;
				if(other.empty()){
					sol[a[i].bianhao] = -1;
				}else{
					Pai crt=other.top();other.pop();
					sol[a[i].bianhao] = crt.bianhao;
				}
			}
		}
		printf("%lld\n",ans);
		for(int i=1;i<=m;i++){
			printf("%d\n",sol[i]);
		}
		return 0;
	}
	sort(a+1,a+1+m,cmp);
	sort(b+1,b+1+n,cmp);
	int start = 1;
	for(;start<=m;){
		int j=start;
		for(;j<=m;j++){
			if(a[j].color!=a[start].color)break;
		}
		colors[++colortot] = a[start].color;
		aline[a[start].color] = (Line){start,j-1};
		start=j;
	}
	start=1;
	for(;start<=n;){
		int j=start;
		for(;j<=n;j++){
			if(b[j].color!=b[start].color)break;
		}
		bline[b[start].color] = (Line){start,j-1};
		start=j;
	}
	for(int i = 1;i<=colortot;i++){
		int color = colors[i];
		Line al = aline[color],bl = bline[color];
		//a[l,r]和b[l,r]配对
		int lena = al.r-al.l+1,lenb = bl.r-bl.l+1;
		if(bl.l == 0 && bl.r == 0)lenb = 0;
		priority_queue<Pai>heap,other;
		if(lena>=lenb){
			for(int i=1;i<=lenb;i++){
				ans += b[bl.l+i-1].number;
				heap.push(b[bl.l+i-1]);
			}
			for(int i=al.l;i<=al.r;i++){
				if(heap.empty())break;
				while(!heap.empty()){
					Pai crt=heap.top();heap.pop();
					if(crt.number >= a[i].number){
						ans+=c;
						sol[a[i].bianhao] = crt.bianhao;
						break;
					}else{
						other.push(crt);
					} 
				}
			}
			for(int i=al.l;i<=al.r;i++){
				if(sol[a[i].bianhao])continue;
				ans -= c;
				if(other.empty()){
					sol[a[i].bianhao] = -1;
				}else{
					Pai crt=other.top();other.pop();
					sol[a[i].bianhao] = crt.bianhao;
				}
			}
		}else{
			for(int i=1;i<=lena;i++){
				ans += b[bl.r-i+1].number;
				heap.push(b[bl.r-i+1]);
			}
			for(int i=al.l;i<=al.r;i++){
				if(heap.empty())break;
				while(!heap.empty()){
					Pai crt=heap.top();heap.pop();
					if(crt.number >= a[i].number){
						ans+=c;
						sol[a[i].bianhao] = crt.bianhao;
						break;
					}else{
						other.push(crt);
					} 
				}
			}
			for(int i=al.l;i<=al.r;i++){
				if(sol[a[i].bianhao])continue;
				ans -= c;

				if(other.empty()){
					sol[a[i].bianhao] = -1;
				}else{
					Pai crt=other.top();other.pop();
					sol[a[i].bianhao] = crt.bianhao;
				}
			}
		}
	}	
	printf("%lld\n",ans); 
	for(int i=1;i<=m;i++){
		printf("%d\n",sol[i]);
	}
	return 0;
}
```


---

## 作者：pikabi (赞：5)

## tip : 贪心

考虑到小 D 的糖最多，根据贪心策略，**那么一定要保证小 D 能出的牌最多最大，且在此条件下胜局最多**。（这点大家应该都能想到吧）

所以我们先用两个 $vector$ (记作 $vec1$ 和 $vec2$ ) 存储每一种花色小 D 和小 C 所拥有的牌的点数和编号，逐个从大到小排序（按点数）。

对于每一种花色，我们用两个指针 $l$ , $L$ 分别表示小 D 和小 C 对于花色 $i$ 所遍历的 $vector$ 的位置。以小 D 为循环主体，找到第一个 $L$ 满足 $vec2_{i,L} \le vec1_{i, l}$ （找不到则结束循环），再计算贡献。容易知道，小 $D$ 当前所选择的牌都是最优的。

对于那些无法被匹配的 $vec2_{i, L}$ ,我们把它们的编号丢进队列里，并再次循环从 $vec1$ 中找到没有匹配的点数最大牌~~们~~做出贡献即可。

复杂度为 $O(nlog_n)$，在花色种类多时略小一些，瓶颈在排序。

code $-->$

```
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cctype>
#include <vector>
#define ll long long
#define inf 1023456789

using namespace std;

inline ll read(){
	ll x=0,w=0;char ch=getchar();
	while (!isdigit(ch))w|=ch=='-',ch=getchar();
	while (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return w?-x:x;
}

int n, m, c, ans[100005], maxn, vis[100005];

vector <pair<ll, int> > vec1[100005], vec2[100005];

int que[100005], t;

ll res, v;

inline bool cmp(pair <ll, int> xx, pair<ll, int> yy){
	return xx.first > yy.first;
}

int main(){
	n = read(), m = read(), c = read(), v = read();
	for(int i = 1; i <= n; i++){
		int x = read(), y = read();
		vec1[x].push_back(make_pair(y, i));  
		maxn = max(x, maxn);
	}
	for(int i = 1; i <= m; i++){
		int x = read(), y = read();
		vec2[x].push_back(make_pair(y, i)); 
		maxn = max(x, maxn);
	}
	for(int i = 1; i <= maxn; i++){
		sort(vec1[i].begin() , vec1[i].end() , cmp);
		sort(vec2[i].begin() , vec2[i].end() , cmp);
	}
	for(int i = 1; i <= maxn; i++){// pair 中 first 表示牌的点数， second 对应原小 D 和小 C 的卡牌编号
		int l = 0, L = 0;
		int len1 = vec1[i].size() , len2 = vec2[i].size() ;
		t = 0;
		while(L < len2 && l < len1){
			while(L < len2 && vec2[i][L].first > vec1[i][l].first ){
				res -= 1ll * c;
				que[++t] = vec2[i][L].second;
				L++;
			}
			if(L == len2) break;
			if(vec2[i][L].first <= vec1[i][l].first){//获胜策略结算
				ans[vec2[i][L].second] = vec1[i][l].second;
				res += 1ll * vec1[i][l].first + c;
				vis[vec1[i][l].second] = 1;
			}
			l++;
			L++;
		}
		while(L < len2){
			res -= 1ll * c;
			que[++t] = vec2[i][L].second;
			L++; 
		}
		l = 0;
		while(t && l < len1){//失败策略结算
			if(!vis[vec1[i][l].second]){
				ans[que[t]] = vec1[i][l].second;
				res += 1ll * vec1[i][l].first;
				vis[vec1[i][l].second] = 1;
				t--;
			}
			l++;
		}
	}
	printf("%lld\n",res + v);
	for(int i = 1; i <= m; i++){
		printf("%d\n",ans[i] == 0? -1:ans[i]);
	}
}

```

完结撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。

---

## 作者：Stay_Hungry (赞：4)

看到这道题，让我想起了田忌赛马，如同田忌赛马一样的思路，大致思路如下： 

首先，对于小$C$每次展示的牌，如果小$C$有相同花色的，无论大小，出出来肯定是更优的，对答案的贡献就是能出出来的牌的权值和。  

然后，对于输赢，必然是赢得次数越多越好，对于一张小$C$展示出来的牌，如果我们手上有可以获胜的牌，我们就出最接近的满足条件的牌，如果我们手上没有能获胜的牌，我们就用最小的牌抵消掉对方最大的同花色的牌，为了满足贪心决策的正确性，我们直接对不同花色的小$C$展示的牌按大小排序，然后按照贪心决策去一张张牌对应即可。   
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, lim = 1e5;
struct node {
	int id, col, val;
	bool operator < (const node &ptr)const {return val < ptr.val;}
	bool operator > (const node &ptr)const {return val > ptr.val;}
} a[N], b[N];
multiset<node> un[N];
int n, m, c, ans[N]; long long v;
signed main() {
	io >> n >> m >> c >> v; memset(ans, -1, sizeof ans);
	for(int i = 1; i <= n; ++i) io >> a[i].col >> a[i].val, a[i].id = i, a[i].val *= -1;
	sort(a + 1, a + 1 + n);
	for(int i = 1; i <= m; ++i) io >> b[i].col >> b[i].val, b[i].id = i, b[i].val *= -1;
	for(int i = 1; i <= m; ++i) un[b[i].col].insert(b[i]);
	for(int i = 1; i <= n; ++i) {
		if(un[a[i].col].size() == 0) continue;
		multiset<node> :: iterator p = un[a[i].col].lower_bound(a[i]);
		v -= a[i].val;
		if(p == un[a[i].col].end()) p = un[a[i].col].begin(), v -= c;
		else v += c;
		node t = *p; ans[t.id] = a[i].id; un[a[i].col].erase(p);
	}
	for(int i = 1; i <= m; ++i) 
		if(ans[i] == -1) v -= c;
	io << v << '\n';
	for(int i = 1; i <= m; ++i) io << ans[i] << '\n';
	return 0;
}
// io是我自定义的读入输出
```
$STL$真香

---

## 作者：Bitter_Tea (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P6851)

本题的基本思路是贪心....

首先，我们~~不难发现~~**尽可能多出牌，尽可能多赢一定是更优的。**

也就是我们小D如果有牌可以出，那么即使是输，我们也要出牌，且出尽可能大的牌。

这是我们贪心的大前提。

我们把小C的牌和小D的牌都从大到小排序，不一样的是，我们还 需要把小D的牌按花色压入不同的堆中，方便我们处理。

我们把小C的牌依次处理: 

1、如果小D根本就没有同种花色的牌，那么就是弃权了 

2、如果小D当前同种花色最大的牌比小C的小，那么就不会有牌能 胜过小C的这张牌了，我们只需最后随便出一张同种花色较大的牌即可

3、如果小D当前同种花色最大的牌大于等于小C的牌，我们就出这张牌了，把这张牌从堆中弹出

这样，我们就能保证出牌最多且赢牌最多

下面给出我~~码风极其怪异~~的代码...

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#define ll long long
using namespace std;
const int N=1e5+5;
struct D{
	int color,b,num;
	bool operator < (const D&x) const
	{return b<x.b;}//堆排序，"大"的反而"小"，也就是值大的在堆顶
}e,ask[N];
priority_queue<D> q[N];
int n,m,c,ans[N];
ll s;
bool v[N];
bool cmp(const D&x,const D&y) {return x.b>y.b;}//sort排序是正常的
void solve()
{
	sort(ask+1,ask+m+1,cmp);
 	for(int i=1;i<=m;i++)
  	{
  		int color=ask[i].color,b=ask[i].b;
  		if(q[color].empty())//根本就没有这一种花色的牌，我们是必输的，打上标记
  		{
  			ans[ask[i].num]=-1;
  			s-=c;v[i]=1;
  			continue;
		}
  		e=q[color].top();
		if(b<=e.b)//处理我们能赢的牌，别忘了加上新买的糖~~~
		{
			ans[ask[i].num]=e.num;
			s+=c+e.b;
  			v[i]=1;
  			q[color].pop();
		}
	}
	for(int i=1;i<=m;i++)
	if(!v[i])
	{
		int color=ask[i].color;
		if(q[color].size())//有同种花色的牌，那么我们就出大的，减去输给小C的糖
		{
			e=q[color].top();
			ans[ask[i].num]=e.num;
			s+=e.b;
			q[color].pop();
		}
		else ans[ask[i].num]=-1;//没有同种花色的牌了，我们只能眼睁睁看着小C拿走我们的糖果，QAQ
		s-=c;
	}
}
int main()
{
	scanf("%d%d%d%lld",&n,&m,&c,&s);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&e.color,&e.b);
		e.num=i;//记录小D牌的原始编号
		q[e.color].push(e);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&ask[i].color,&ask[i].b);
		ask[i].num=i;//小C询问的原始编号
	}
	solve();//关键函数
	printf("%lld\n",s);
	for(int i=1;i<=m;i++)
	printf("%d\n",ans[i]);
	return 0;
}
```

~~不妨留个赞再走~~

---

## 作者：Natsume_Rin (赞：4)

这里写一下 $luogu$ 月赛 $div_2$ 的 $T2$ 题解。~~（点赞再走呗）~~

首先，乍一看题面，比较冗长。

说白了，就是给出一种出牌方案使得小 $D$ 最后的糖果最多。

我们知道小 $C$ 出的牌，那么，要怎么去规划小 $D$ 的出牌顺序才能使得小 $D$ 获胜的场数尽可能多呢？？？

我们很快就可以想到 [田忌赛马](https://www.luogu.com.cn/problem/P1650)。**就是用点数小的去和对手点数大的比较**。

那么，我们对于小 $C$ 出的每一张牌 $(a,b)$，相同的 $a$ 按照 $b$ 从小到大排序。然后筛一遍小 $D$ 的牌，**使得小 $D$ 的每一种花色的牌都和小 $C$ 尽量保持相等(优先把小点数筛掉)**。

然后进行讨论：

- 如果小 $D$ 有一张牌 $(x_i,y_i)$ 满足 $x_i=a$ 且 $y_i \geqslant b$，那么就肯定要用这张牌去和小 $C$ 比。
- 如果小 $D$ 有一张牌 $(x_i,y_i)$ 满足 $x_i=a$ 且 $y_i < b$，那么还要分两种情况来讨论（我们记小 $C$ 有的花色为 $a$ 的牌有 $sumc_a$ 张，小 $D$ 有的花色为 $a$ 的牌有 $sumd_a$ 张）：
     - 如果 $sumc_a>sumd_a$，那么，我们这一轮选择不出。$sumd_a$ 自增。
     - 否则 就选择出点数最小的那张牌。
- 如果小 $D$ 没有符合条件的牌，选择不出。

于是，就可以开心的实现代码了：

```cpp
#include<bits/stdc++.h>
#define RI register int
using namespace std;
const int MAXN = 1e5+5;
int sumc[MAXN], sumd[MAXN]; 
long long ans;
int anc[MAXN];
int n, m, a, b, tmp, tot;
long long v, c;
priority_queue<pair<long long,int> >q[MAXN];
priority_queue<pair<long long,int> >p[MAXN];
deque<pair<long long,int> >s[MAXN];
deque<pair<long long,int> >t[MAXN];
int Max;
int main() {
	scanf("%d%d%lld%lld",&n,&m,&c,&v);
	ans=v;
	for(RI i=1; i<=n; ++i) {
		scanf("%d%d",&a,&b);
		Max=max(Max,a);
		sumd[a]++;
		q[a].push(make_pair(b,i));
	}
	for(RI i=1; i<=Max ;++i) {
		if(q[i].empty()) continue;
		while(!q[i].empty()) {
			s[i].push_back(q[i].top());
			q[i].pop();
		}
	}
	for(RI i=1; i<=m; ++i) {
		scanf("%d%d",&a,&b);
		Max=max(Max,a);
		sumc[a]++;
		p[a].push(make_pair(b,i));
	}
	for(RI i=1; i<=Max; ++i) {
		if(p[i].empty()) continue;
		while(!p[i].empty()) {
			t[i].push_back(p[i].top());
			p[i].pop();
		}
	}
	for(RI i=1; i<=Max; ++i) {
		if(!t[i].size()) continue;
		if(sumc[i]<sumd[i]) for(RI j=sumd[i];j!=sumc[i];j--) s[i].pop_back();
		while(t[i].size()) {
			tmp=t[i].front().first;
			tot=t[i].front().second;
			t[i].pop_front();
			if(s[i].size()) {
				if(s[i].front().first>=tmp) {
					ans=ans+s[i].front().first+c;
				//	cout<<ans<<' '<<s[i].front().first<<' '<<c<<endl;
					anc[tot]=s[i].front().second;
					s[i].pop_front();
				} else {
					if(sumd[i]<sumc[i]){
						anc[tot]=-1;
						ans-=c;
					//	cout<<ans<<' '<<c<<endl;
						sumd[i]++;
						continue;
					}
					
					ans=ans+s[i].back().first-c;
					//cout<<ans<<' '<<s[i].back().first<<' '<<c<<endl;
					anc[tot]=s[i].back().second;
					s[i].pop_back();
				}
			}
			else{
				anc[tot]=-1;
				ans-=c;
				//cout<<ans<<' '<<c<<endl;
			}
		}
	}
	printf("%lld\n",ans);
	for(RI i=1;i<=m;++i) printf("%d\n",anc[i]);
	return 0;
}
```

---

## 作者：年华天地 (赞：3)

### 以下假设两人花色均相同

首先，假如两个人的牌的数量是一样的，我们会怎么选？因为我们想赢的次数尽量的多所以我们可以将两个人的牌都从大到小排好序，依次选，**如果小D最大的牌比小C最大的牌大，就出这张牌，否则就出最小的牌，因为最小的牌可以赢时我们用更大的牌一定可以赢，所以一定不会更劣。**

接着我们考虑如果小C的牌比小D的牌多的情况，我们知道小D的牌一定是出的完的，所以我们也是想让赢的次数尽量多，因为小C的牌多，所以一定有些牌小D不会要，因为要赢的尽量多，**所以一定是最大的几张牌不要**，标记为-1，当小C的牌与小D相等时再按第一种方式出牌。

最后我们考虑小D的牌比小C多的情况，因为出大的牌得的糖果不会比小的牌少，**所以我们保留大的几张牌**，使小D的牌与小C相同，又回到第一种情况。

### 那么两人花色不同的情况呢？

我们可以对两个人的牌都进行排序，使相同花色的牌在一起，在相同花色的牌里再按照大小排序，**那么我们就可以一个花色对应一个花色的去比较**，就解决了。

### 代码
可以看看注释

```
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
const int N=3e6;
int n,m,c,v,ans,be[N],en[N],opt[N];
struct node{
	int pos,x,id;
}s[N],t[N];
bool cmp(node a,node b)
{
	return a.x>b.x;
}
bool cmp1(node a,node b)
{
	return a.pos<b.pos;
}
void p2()//对小C的牌进行排序（已经按花色拍好序了） 
{
	t[m+1].pos=1e9;
	for (int i=2,last=1;i<=m+1;i++)
		if (t[i].pos!=t[i-1].pos)
			sort(t+last,t+i,cmp),last=i;
}
void p1()//对小D的牌进行排序（已经按花色拍好序了） 
{
	s[n+1].pos=1e6;
	be[s[1].pos]=1;//我们要记录一个花色的起始位置与终止位置 
	for (int i=2;i<=n+1;i++)
		if (s[i].pos!=s[i-1].pos)
		{
			be[s[i].pos]=i;
			en[s[i-1].pos]=i-1;
			sort(s+be[s[i-1].pos],s+i,cmp);
		}
}
void solve(int l,int r)
{
	int l1=be[t[l].pos],r1=en[t[l].pos];
	if (!l1)//表示小D没有这种花色 
	{
		for (int i=l;i<=r;i++)
		{
			opt[t[i].id]=-1;
			ans-=c;
		}
		return ;
	}
	int len1=r-l+1,len2=r1-l1+1;
	while(r-l+1>len2)//小C的牌多 
	{
		opt[t[l].id]=-1;
		ans-=c;
		l++;//因为按大小排了序，所以大的不要，l++ 
	}
	if (len2>len1)r1=l1+len1-1;//小D的多 
	for (int i=l;i<=r;i++)//依次比较 
	{
		if (s[l1].x>=t[i].x)//小D的牌大，就打这张牌 
		{
			ans+=c+s[l1].x;	
			opt[t[i].id]=s[l1].id;
			l1++;
		}
		else//小D的牌小，打最小的牌 
		{
			ans+=s[r1].x-c;
			opt[t[i].id]=s[r1].id;
			r1--;
		}
	}	
}
signed main()
{
	scanf("%lld%lld%lld%lld",&n,&m,&c,&v);ans=v;
	for (int i=1;i<=n;i++)scanf("%lld%lld",&s[i].pos,&s[i].x),s[i].id=i;
	for (int i=1,x,y;i<=m;i++)scanf("%lld%lld",&t[i].pos,&t[i].x),t[i].id=i;
	sort(t+1,t+m+1,cmp1);//按花色排序 
	sort(s+1,s+n+1,cmp1);
	p1();p2();//按大小排序 
	for (int i=2,l=1;i<=m+1;i++)
		if (t[i].pos!=t[i-1].pos)//找到了一种花色 
			solve(l,i-1),l=i;
	printf("%lld\n",ans);
	for (int i=1;i<m;i++)printf("%lld\n",opt[i]);
	printf("%lld",opt[m]);
	return 0;
}
```


---

## 作者：Mophie (赞：3)

### P6851 onu题解

[题目传送门](https://www.luogu.com.cn/problem/P6851)

首先先来了解一下题意：

小C每次会出一张花色为 $a_i$ ，点为 $b_i$ 的牌。

而小D只能再未出的牌中选择一张花色相同的牌打出去。

如果没有花色相同的牌，则判断小D此局输。

否则将打出去的牌的点数与小C打出的牌的点数进行比较，如果小D**大于等于**小C的，那么小D获胜，否则小C获胜。负者会给胜者 $c$ 颗糖。

而每次打完后，小D可以拿等同于自己点数的牌。

小D初始有 $v$ 颗糖，请问：小D在游戏结束时手里的糖数的最大值，并输出最优方案，即小C的每张牌小D将要打出的牌的序号，如果没打出牌，则输出 $-1$

————————————————————————————优美的分割线

首先小D只能打出同花色的牌，所以不难想到用花色来建一个桶。

但这个 $10^5$ 让人头疼……

但总牌数也是 $10^5$ 的，所以可以考虑用 $vector$ 来存。

我们将小D得到的钱分两部分考虑。

首先先考虑那等同于自己牌点数的糖的那一部分

这一部分肯定是取点数越大越好，而对于下一部分，也是同理，点越大赢的可能性越大。

所以我们考虑将 $vector$ 每个花色以点数排序即可。

第二部分则是考虑怎么赢的更多。

此处显然可以用贪心的策略，用我现在最大的和小C出过的最大的比，如果能赢则打出去，如果不能赢则就出最小的。

不难证明这是最优的。

### Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+9;
inline long long read()
{
	long long sum=0,naga=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')naga=-1;ch=getchar();}
	while(ch<='9'&&ch>='0')sum=sum*10+ch-'0',ch=getchar();
	return sum*naga;
}
inline void write(int X)
{
	if(X<0)putchar('-'),X=-X;
	if(X>9)write(X/10);
	putchar(X%10+'0');
} 
struct point
{
	int id,val;	
}kkk;
vector<point>sd[N];
vector<point>sc[N];
int cd[N],cc[N];
int res[N],n,m,v,zzb,cn;
long long c,ans;
inline bool cmp(point zxy,point lr)
{
	return zxy.val>lr.val;
}
inline void work()
{
	for(register int i=1;i<=100000;i++)
	{
		if(cc[i]!=0&&cd[i]!=0)
		{
			int zbb=min(cc[i],cd[i]);   
			for(register int j=0;j<zbb;j++)ans+=sd[i][j].val;
			int nowa=0,nowb=0;
			while(nowb!=cc[i]&&nowa!=cd[i])
			{
				if(sd[i][nowa].val>=sc[i][nowb].val)ans+=2*c,res[sc[i][nowb].id]=sd[i][nowa].id,nowa++,nowb++;
				else nowb++;
			}
			for(register int j=0;j<cc[i];j++)
			{
				if(res[sc[i][j].id]==-1&&nowa<cd[i])res[sc[i][j].id]=sd[i][nowa].id,nowa++;
			}
		}
	}
}
signed main()
{
	n=read(),m=read(),c=read(),v=read();
	ans=v-c*m;
	for(register int i=1;i<=n;i++)
	{
		zzb=read(),cn=read();
		kkk.id=i,kkk.val=cn;
		sd[zzb].push_back(kkk);
        cd[zzb]++;
	}
	for(register int i=1;i<=m;i++)
	{
		zzb=read(),cn=read();
		kkk.id=i,kkk.val=cn;
		sc[zzb].push_back(kkk);
		res[i]=-1;
        cc[zzb]++;
	}
	for(register int i=1;i<=100000;i++)
	{
		if(cc[i])sort(sc[i].begin(),sc[i].end(),cmp);
		if(cd[i])sort(sd[i].begin(),sd[i].end(),cmp);
	}
	work();
	printf("%lld\n",ans);
	for(register int i=1;i<=m;i++)
	{
		write(res[i]);puts("");
	}	
	return 0;
}   
```


---

## 作者：NuoCarter (赞：2)

# 10月月赛 Div2 T2题解~~

纪念一下第一次在学校打的月赛~

## 题目大意~：

开始给定 小D n 张牌，每张牌有两个元素：**颜色和点数**

又会给定 小C 的 m 张牌每张牌也只有两个元素。

给定小D的初始点数 V，和每一次获胜得到（失去）的点数 C ，

**每打出一张牌可以获得它的点数。**

给定小C每一轮打出的牌的花色和点数，求出小D最大珂以获得的点数

## 贪心策略：

需要让小D赢得最多，同时打出的牌尽量的大。

因为每一个花色内的情况是不影响另一个花色的选择情况的。

所以我们珂以分每个花色进行处理：

对于小C打出的同一花色的牌：我们珂以按照点数降序排序：

我们也将小D的同一花色的牌，也按照点数降序排序

如果我们用一个 loc1 表示小C的匹配位置，loc2 表示小D的匹配位置

如果说 loc1 所在位置的点数 > loc2 所在位置的点数

也就说明 小D的同种花色牌中，是不存在比 loc1 所在点数更大的牌（或者说比它大的已经被选过了）

那么对于这个位置，**我们是必输的情况,所以我们暂时不选,** 

因为 loc2所在位置的点数能够匹配更多的赢的情况，

loc1这个位置的匹配情况应该是在匹配玩后所有没有匹配中的最大值。

**(因为打出一张牌珂以获得它的点数，输的话肯定打出的是最大的点数)**

那么对于 loc1 所在位置的点数 $\leq$ loc2 所在位置的点数

这个时候你既可以打出当前最大的牌还可以赢，当然直接打出啊

所以直接 loc1++,loc2++

## 一些小优化：

**优化1**

有时候 小D同种颜色与小C的同种颜色不够匹配的时候，就需要将loc2向后移动，但是一个一个移动又太慢了，所以我们在排完序后，需要处理出每一个颜色后还有多少个同种颜色的（珂以看代码）,这样在移动时可以做到 $O(1)$

**优化2**

很多人在最后匹配必输情况时选择了二分，但是完全珂以用一个数组记录下赢的情况用了多少个

因为每一个个花色的使用情况一定是具有两段性的（想一想为什么）

匹配时就可以将二分的 log 省去。。。

但是这个代码的常数还是有点大啊。。鄙人就能想到这了。。欢迎评论区提出建议~

不懂的珂以边看代码边理解吧。。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline int read(){
  int x=0,f=1;char ch=getchar();
  while(ch>'9'||ch<'0'){if(ch=='-'){f=-1;}ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch-'0');ch=getchar();}
  return x*f;
}
inline ll read_LL(){
  ll x=0,f=1;char ch=getchar();
  while(ch>'9'||ch<'0'){if(ch=='-'){f=-1;}ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch-'0');ch=getchar();}
  return x*f;
}
const int N=1e5+5;
struct node{int col,order,cnt,shunxu;ll val;}a[N],b[N];
int n,m;
ll c,v;
bool hav[N],used[N];
int havused[N];
inline bool cmp(node x,node y){
  if(x.col==y.col){return x.val>y.val;}
  return x.col<y.col;
}
inline void presolve(){
  for(int i=n;i>=1;--i){
    if(a[i].col!=a[i+1].col){a[i].cnt=1;}
    else{a[i].cnt=a[i+1].cnt+1;}
  }
  for(int i=m;i>=1;--i){
    if(b[i].col!=b[i+1].col){b[i].cnt=1;}
    else{b[i].cnt=b[i+1].cnt+1;}
  }
  return;
}
inline bool cmp2(node x,node y){return x.order<y.order;}
int main(){
  n=read(),m=read(),c=read_LL(),v=read_LL();
  for(int i=1;i<=n;++i){a[i].col=read(),a[i].val=read_LL();a[i].order=i;}
  for(int i=1;i<=m;++i){b[i].col=read(),b[i].val=read_LL();b[i].order=i;}
  sort(a+1,a+n+1,cmp);
  sort(b+1,b+m+1,cmp);
  presolve();
  int loc2=1;
  ll ans=v;
  for(int i=1;i<=m;++i){
    while(a[loc2].col<b[i].col&&loc2+a[loc2].cnt<=n){loc2+=a[loc2].cnt;}
    if(a[loc2].col!=b[i].col){ans-=c;b[i].shunxu=-1;continue;}
    if(a[loc2].val>=b[i].val){
      ans+=c;
      used[loc2]=true;
      b[i].shunxu=a[loc2].order;
      hav[i]=true;
      havused[a[loc2].col]++;
      loc2++;
    }
    else{
      ans-=c;
      hav[i]=false;
    }
  }
  int st=1;
  for(int i=1;i<=m;++i){
    while(a[st].col<b[i].col&&st+a[st].cnt<=n){st+=a[st].cnt;}
    if(a[st].col!=b[i].col){continue;}
    if(!hav[i]){
      if(havused[b[i].col]==a[st].cnt){b[i].shunxu=-1;}
      else{
        int tep=st+havused[b[i].col];
        b[i].shunxu=a[tep].order;
        havused[b[i].col]++;
        used[tep]=true;
        hav[i]=true;
      }
    }
  }
  for(int i=1;i<=n;++i){if(used[i]){ans+=a[i].val;}}
  printf("%lld\n",ans);
  sort(b+1,b+m+1,cmp2);
  for(int i=1;i<=m;++i){printf("%d\n",b[i].shunxu);}
  return 0;
}

```

---

## 作者：NXYorz (赞：2)


[题目连接](https://www.luogu.com.cn/problem/P6851)

**有悔贪心。**

首先可以分析一下题目性质：

- 出总比不出好。
- 大牌比小牌好。

把小 C 出的牌从小到大排序， 把小 D 的牌按照花色分类压入堆中， 考虑到如果小D 与**小 C 当前牌的花色**相同的牌里面**最大**的花色大于小 C 的牌， 出就是了。 但是如果小于的话，这个时候不能出最大的牌取换糖果，先忍一手， 这次牌暂定为不出， 因为小 D 的牌虽然这回合小于小 C， 但是下一回合也许就赢了。如果一回合次能赢， 我们就下次出。**显然既然出同样的牌能赢更优**

这样做就可以做到把所有能赢的方案都给判断出来。

但是这样还不是最优，因为我们有些牌忍了一手，现在应该还回来了。于是在重新扫一遍，如果发现这次方案没有出，那么就看当前堆里是否有相应的牌可以出，~~出最大的换糖~~

### $Code$

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>

using namespace std;

const int N = 1e5 + 10;

int n,m,c;
long long v;

struct NO
{
	int a,b,num,null;
	bool operator < (const NO B) const{
		return b < B.b;
	}
}Node1[N],Node2[N];

priority_queue<NO> q1[N] , q2[N];

bool cmp(NO A , NO B)
{return A.b > B.b;}

int step[N];
int pre[N];

void work()
{
	sort(Node1 + 1 , Node1 + 1 + m , cmp);
	for(int j = 1; j <= m; j++) step[j] = -1;
	for(int j = 1; j <= m; j++)
	{
		int loc = Node1[j].a;
		if(q2[loc].empty()) {v -= c;continue;}
		NO now = q2[loc].top();
		if(now.b >= Node1[j].b)
		{
			step[Node1[j].num] = now.num;
			q2[loc].pop();v += c;
			v += now.b;
		}
		else v -= c , pre[Node1[j].num] = j;
	}
	for(int j = 1; j <= m; j++)
		if(step[j] == -1)
			if(!q2[Node1[pre[j]].a].empty())
			{
				NO top = q2[Node1[pre[j]].a].top();
				step[j] = top.num;
				v += top.b;q2[Node1[pre[j]].a].pop();
			}
	printf("%lld\n",v);
	for(int j = 1; j <= m; j++)
		printf("%d\n",step[j]);
}

int main()
{
//	freopen("aa.in","r",stdin);
//	freopen("aa.out","w",stdout);
	scanf("%d%d%d%lld",&n,&m,&c,&v);
	for(int i = 1; i <= n; i++)
		scanf("%d%d",&Node2[i].a,&Node2[i].b) , Node2[i].num = i , q2[Node2[i].a].push((NO){Node2[i].a , Node2[i].b , i , 0});
	for(int i = 1; i <= m; i++)
		scanf("%d%d",&Node1[i].a,&Node1[i].b) , Node1[i].num = i , q1[Node1[i].a].push((NO){Node1[i].a , Node1[i].b , i , 0});
	work();return 0;
}
```

---

## 作者：zythonc (赞：1)

月赛T2，个人认为比田忌赛马简单，只要排个序直接贪心就好了

## 【分析过程】

我们发现本题与田忌赛马的最大不同点是:

- 本题如果**点数相同的话，依然算小D胜**

- 而田忌赛马那题却还有**平手**这一说

**所以我们将小C要出的牌先按花色排序，之后按点数排序**

排序之后贪心

- 如果小D有能赢他的牌直接出

- 否则就加入一个集合，**因为如果输了但是只要出牌了依然能获得糖**

更详细的解释请看代码

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 500001
#define int long long
using namespace std;
int n,m,cm,c,v,put[N],done,clc,queue[N];
struct Card{
	int cl,point,num;
}D[N],C[N];
inline bool cmp(Card a,Card b){
	if(a.cl==b.cl) return a.point<b.point;
	else return a.cl>b.cl;
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>c>>v;cm=m;
	for(int i=1;i<=n;i++){
		cin>>D[i].cl>>D[i].point;
		D[i].num=i;
	}
	for(int i=1;i<=m;i++){
		cin>>C[i].cl>>C[i].point;
		C[i].num=i;
	}
	sort(C+1,C+m+1,cmp);sort(D+1,D+n+1,cmp);
//排序！！
	int l=m,r=n;clc=C[m].cl;
//l与r分别是两个牌堆的牌顶指针
//clc是为了判断本次出的牌的花色是否与上次相同
	while(m>0){
//所有回合没有结束
		if(C[m].cl!=clc){
//与上次的花色不同，开始贪心
			v-=done*c;
//输的糖肯定是一定的
			while(done--&&D[r].cl==clc) v+=D[r].point,put[C[queue[done]].num]=D[r].num,r--;
//但是如果我们有牌的话就出，以求再买回来几颗
			clc=C[m].cl;
			done=0;
//重置
		}
		put[C[m].num]=-1;
//初始化，默认不出
		while(D[r].cl!=C[m].cl&&C[m].cl>=D[r].cl&&r) r--;
//看看两个牌堆顶的花色是否不同，如果不同就设法让他们相同
		if(C[m].cl!=D[r].cl){
//还不一样，说明小D没有这种花色的牌，-2表示一定不出
			put[C[m].num]=-2;
			v-=c;m-=1;
//输牌
			continue;
		}
		if(C[m].point<=D[r].point){
//赢牌
			v+=D[r].point+c;
			put[C[m].num]=D[r].num;
			l--,r--;
		}
		else queue[done++]=m;
//输牌，加入集合
		m-=1;
	}
	v-=done*c;
	while(done--&&D[r].cl==clc) v+=D[r].point,put[C[queue[done]].num]=D[r].num,r--;
//处理最后的一个花色
	cout<<v<<"\n";
	for(int i=1;i<=cm;i++){
		cout<<(put[i]==-2?-1:put[i])<<"\n";
	}
}
```

---

## 作者：wocaicai (赞：1)

//看了看大家的题解，基本上都讲的挺明白了，这里主要提供一种简单的代码，里面有注释




## [P6851](https://www.luogu.com.cn/problem/P6851)

很明显，对于每种花色单独处理，该题直接变成了一个田忌赛马的问题

然而，本题并没有那么裸，居然还要求我们记录方案，以及还存在两个人马的数量不一致的情况

#### 在同种花色下
考虑对双方牌数不同的情况考虑，当小D的牌数比小C多的时候，只取前小C的数的大的牌，因为这样一定最优

当小D的牌比小C的少的时候，那么就直接补上一堆花色相同，点数为0 ，同时id 为-1的牌就可以了

#### 细节： 对于同种花色的马在匹配的时候，从小往大配， 因为这样子匹配能打的过就一定打，打不了就一定不行，更加方便

具体实现看代码吧 //目测比大部分题解短qwq
```cpp
#include<bits/stdc++.h>
using namespace std ;
#define int long long
#define kkksc signed main
#define maxn 100010
#define mem(x , a) memset(x , a , sizeof(x))
int read(){
	int ans = 0 , f = 1 ; char ch = getchar() ;
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1 ; ch = getchar() ; }
	while(ch >= '0' && ch <= '9') {
		ans = (ans * 10) + ch - '0' ;
		ch = getchar() ;
	}
	return ans * f ;
}
struct pai{
	int hua ,num  ,  id ; 
	bool operator < (const pai &x ) const{return hua == x.hua ? num > x.num : hua < x.hua ; } 
}pd[maxn] , pc[maxn] , f[maxn] , g[maxn];
// 先让同种花色的在一起，并且有序，这样就好匹配了
//f主要是为了把同种花色的小D的牌拉出来暂存用的
//g则存的是小C的
int n , m , c , v ; 
int ans , yi ; 
int fan[maxn] ; 
//存的是小C出的牌时小D的选择
int lenf , leng ;
int visf[maxn] ;  
void work(){
	int len = lenf ; 
	memset(visf , 0 , sizeof(int) * (lenf + 1 )) ; 
	int zzd = len ; 
   //因为排序的时候同种花色的点数是从大到小的，所以这里从小到大
	for(int i = len ; i >= 1 ; --i){
		while(zzd > 0 && f[zzd].num < g[i].num) zzd-- ;
      //小D打不过就一直跳，找到一个能打的最小的
		if(f[zzd].num >= g[i].num ){
			ans += f[zzd].num + c ; 
			fan[g[i].id ] = f[zzd].id ; 
			visf[zzd--] = 1 ; 
		}
      //找不到能打的了，直接随便出
		else{
			int j = 1 ; 
			while(i >= 1){
				while(visf[j]) j++ ; 
				fan[g[i].id ] = f[j].id ;
				ans += f[j].num - c ;  
				i-- ; j++ ; 
			}
			break ; 
		} 
	}
}
kkksc(){
	int maxx = -1 ; 
	n = read() , m = read() , c = read() , v = read() ; 
	for(int i = 1 ; i <= n ; ++i){
		pd[i] = (pai){read() , read() , i} ; 
	}
	sort(pd + 1 , pd + 1 + n) ; 
	pd[n + 1] = (pai){-1 } ; 
	for(int i = 1 ; i <= m ; ++i){
		pc[i] = (pai){read() , read() , i} ;
		maxx = max(maxx , pc[i].hua ) ;  
	}
	pc[m + 1 ] = (pai){-1} ; 
	sort(pc + 1 , pc + 1 + m) ; 
	int zzd = 1 , zzc = 1 ; 
   //zzd : 纸箱小D的指针 zzc同理
   // 把同种花色的马拖出来处理，这样子遇到牌不够的情况也好搞
	for(int i = 1 ; i <= maxx ; ++i){
		leng = lenf = 0 ; 
		while(pd[zzd].hua == i){
			f[++lenf] = pd[zzd++] ; 
		}
		while(pc[zzc].hua == i){
			g[++leng] = pc[zzc++] ; 
		}
		while(lenf < leng){
			f[++lenf] = (pai){i , 0 , -1} ; 
		}
   		//不够就直接把id补成-1，点数为0
		lenf = min(lenf , leng) ; 
 	//多了就只取一部分，并且一定是取最多的
		work() ; 
     //开始匹配
	}
	printf("%lld\n" , ans + v) ; 
	for(int i = 1 ; i <= m ; ++i)
		printf("%lld\n" , fan[i]) ; 
}

```


启发：建议想好再写代码，我一开始思路好了就直接开始写了，结果2小时还没好，后面教练告诉我该怎么写，一下就写好了，然后要注重实现的思路

#### 思路一定要清晰啊啊啊啊


---

## 作者：fls233666 (赞：1)

考虑什么情况下小 D 能剩下的糖最多，进而确定小 D 的出牌规则。

首先，第一条规则是显而易见的——**小 D 要尽可能多的赢小 C**。因为只要赢了小 C,小 D 就不会损失糖果，并且会加上 $c+b_i$ 的糖果。这种情况显然更优。

其次再考虑小 D 无法赢的对局。我们发现，**出牌会比弃权更优**。因为弃权，损失的糖果数为 $c$。但是，出牌后，可以去商店买回一定数量的糖果，使损失变为 $b_i-c$。考虑到题目的数据范围中 $c$ 与 $b_i$ 都是非负的，这样显然更优。

最后综合上述两种情况考虑，我们得出第三条规则：**无论当前对局是输是赢，出更大点数的牌一定更优**。显然，增大 $b_i$，无论在上述的哪一条规则下都会得到更优的解。

于是我们总结一下上述的三条规则，得到以下处理方案。

1. 把两人的牌按花色桶排序处理一下；
2. 对于两人要出的同花色的牌，分别按点数排序；
3. 对于小 C 的每一张牌，考虑小 D 是否有能赢的牌，如果有，则尽可能拿点数大的牌出；【规则一，规则三】
4. 对于小 C 剩下的小 D 无法赢的牌，尽可能把点数大的牌打出，减少小 D 弃权的机会；【规则二，规则三】
5. 在按照上述 3，4 两步处理时统计答案并存储输出方案。

按照上述方案实现，即可得到如下 AC 代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#define ll long long
#define rgt register int
using namespace std;

inline int rd(){
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	int x=c-'0';
	c=getchar();
	while(c>='0'&&c<='9'){
		x=x*10+(c-'0');
		c=getchar();
	}
	return x;
}  //给 int 类型的快速读入

inline ll rdll(){
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	ll x=c-'0';
	c=getchar();
	while(c>='0'&&c<='9'){
		x=x*10+(c-'0');
		c=getchar();
	}
	return x;
}  //给 long long 类型的快速读入

inline void printll(ll d){
    if(d==0){
        putchar('0');
        putchar('\n');
        return;
    }
    ll num=d,siz=0,buf[22];
    while(num){
        siz++;
        buf[siz]=num%10;
        num/=10;
    }
    while(siz){
        putchar('0'+buf[siz]);
        siz--;
    }
    putchar('\n');
}  //给 long long 类型的快速输出

inline void print(int d){
    if(d==-1){
    	putchar('-');
    	putchar('1');
    	putchar('\n');
    	return;
	}
    int num=d,siz=0,buf[22];
    while(num){
        siz++;
        buf[siz]=num%10;
        num/=10;
    }
    while(siz){
        putchar('0'+buf[siz]);
        siz--;
    }
    putchar('\n');
}  //给 int 类型的快速输出

const int mxa = 1e5+5;

int n,m,lgp;

ll c,v;

vector < pair<ll,int> > gb[mxa],ga[mxa];
//ga[i]存小 D 手上花色为 i 的牌，gb[i]存小 C 要出的花色为 i 的牌

int ans[mxa],gp[mxa];
//gp存储出现的花色

bool ap[mxa];
//ap[i]标记花色 i 是否出现

int main(){
	n=rd();
	m=rd();
	c=rdll();
	v=rdll();
	for(rgt a,b,i=1;i<=n;i++){
		a=rd();
		b=rd();
		ga[a].push_back(make_pair(b,i));
        //存储小 D 的牌的点数与编号
	}
	for(rgt a,b,i=1;i<=m;i++){
		a=rd();
		b=rd();
		gb[a].push_back(make_pair(b,i));
        //存储小 C 的牌的点数与编号
		if(!ap[a]){  //标记并存储出现的花色
			ap[a]=true;
			gp[lgp]=a;
			lgp++;
		}
		ans[i]=-1;  //初始化 ans 数组【初始时默认全部弃权】
	}
	
	for(rgt ja,i=0;i<lgp;i++){  //分别处理出现的每个花色
		sort(ga[gp[i]].begin(),ga[gp[i]].end());
		sort(gb[gp[i]].begin(),gb[gp[i]].end());
        //分别按点数排序
		ja=ga[gp[i]].size()-1;
        //获取排序后的最末尾的牌的点数，即最大的点数
        
		for(rgt jb=gb[gp[i]].size()-1;jb>=0&&ja>=0;jb--){
			if(ga[gp[i]][ja].first>=gb[gp[i]][jb].first){  //存在能赢的对局
				ans[gb[gp[i]][jb].second]=ga[gp[i]][ja].second;  //存储方案
				v+=c+ga[gp[i]][ja].first;  //更新答案
				ja--;
			}
		} //第一轮遍历匹配所有能赢的对局
        
		for(rgt jb=gb[gp[i]].size()-1;jb>=0&&ja>=0;jb--){
			if(ans[gb[gp[i]][jb].second]==-1){  //存在可以出牌的对局
				ans[gb[gp[i]][jb].second]=ga[gp[i]][ja].second;  //存储方案
				v+=ga[gp[i]][ja].first-c;  //更新答案
				ja--; 
			}
		} //第二轮遍历匹配所有能出牌的对局
	}
    
	for(rgt i=1;i<=m;i++)
		if(ans[i]==-1)
			v-=c;  //弃权的对局要把 c 个糖果扣掉
            
	printll(v);  //输出答案
	for(rgt i=1;i<=m;i++)
		print(ans[i]);  //输出出牌方案
        
	return 0;
}
```


---

## 作者：hzoi_liuchang (赞：1)

## 分析
因为小 $D$ 打出的牌与小 $C$ 打出的牌花色必须相同，所以我们需要按照花色分类讨论

对于某一种花色

如果小 $C$ 没有这种花色的牌但是小 $D$	有，那么小 $D$ 的牌一定打不出去，直接 $continue$ 掉

如果小 $C$ 有这种花色的牌，那么对于小 $D$ 来说，他肯定想让他赢的次数尽可能多

这其实就是一个田忌赛马的问题

我们把小 $C$ 和小 $D$ 的牌按照点数从大到小排序

对于小 $D$ 的每一张牌，我们在小 $C$ 小于等于这张牌点数的牌里选择点数最大的那一张与其配对

因为消耗一个点数大的牌肯定更优，这样可以为之后的牌创造更多的获胜机会

因为小 $D$ 的牌的点数是单调递减的，所以选出的牌的点数也一定是单调递减的

因此，我们可以用一个指针维护

这样到最后小 $D$ 的牌要么都打光，要么剩下一些

对于剩下的牌，我们随便配对就可以了，因为打出去肯定比不打出去更优

在匹配的过程中如果小 $C$ 的牌不够用，那么就停止匹配

如果小 $D$ 的牌打光后小 $C$ 还剩下牌，那么小 $D$ 只能选择弃权
## 代码
``` cpp
#include<cstdio>
#include<vector>
#include<cmath>
#include<algorithm>
#define rg register
struct asd{
	int id,val;
	asd(){}
	asd(int aa,int bb){ id=aa,val=bb; }
};
bool cmp(asd aa,asd bb){
	return aa.val>bb.val;
}
const int maxn=1e5+5;
std::vector<asd> gd[maxn],gc[maxn];
int ans[maxn],n,m,maxid;
long long c,v;
bool vis[maxn];
void solve(int id){
	if(gc[id].size()==0) return;
	rg int head=0,js=0;
	for(rg int i=0;i<gd[id].size();i++){
		rg int cs=gd[id][i].val;
		if(head>=gc[id].size()) break;
		while(1){
			if(gc[id][head].val>cs) head++;
			if(head>=gc[id].size()) break;
			if(gc[id][head].val<=cs){
				ans[gc[id][head].id]=gd[id][i].id;
				vis[gc[id][head].id]=1;
				v=v+c+gd[id][i].val;
				head++,js++;
				break;
			}
		}
	}
	for(rg int i=0;i<gc[id].size();i++){
		rg int now=gc[id][i].id;
		if(vis[now]) continue;
		if(js>=gd[id].size()){
			ans[now]=-1;
			vis[now]=1;
			v=v-c;
		} else {
			ans[now]=gd[id][js].id;
			v=v-c+gd[id][js].val;
			vis[now]=1;
			js++;
		}
	}
}
int main(){
	scanf("%d%d%lld%lld",&n,&m,&c,&v);
	rg int aa,bb;
	for(rg int i=1;i<=n;i++){
		scanf("%d%d",&aa,&bb);
		gd[aa].push_back(asd(i,bb));
		maxid=std::max(maxid,aa);
	}
	for(rg int i=1;i<=m;i++){
		scanf("%d%d",&aa,&bb);
		gc[aa].push_back(asd(i,bb));
		maxid=std::max(maxid,aa);
	}
	for(rg int i=1;i<=maxid;i++){
		std::sort(gd[i].begin(),gd[i].end(),cmp);
		std::sort(gc[i].begin(),gc[i].end(),cmp);
	}
	for(rg int i=1;i<=maxid;i++) solve(i);
	printf("%lld\n",v);
	for(rg int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Strelitzia (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6851)

---

其实很容易看出是一个田忌赛马。

我们可以这样理解，对于每一种花色，进行小 C 卡牌次数的比赛。

这样我们就可以直接~~复制田忌赛马的代码了~~有大概思路了。

但有几个条件：

从商店买等于自己打出的牌的点数颗糖：这说明了能打就打，反正不亏。

还有，小 D 大于等于小 C 的牌的点数，则小 D 胜。

注意这两点就可以了。

```cpp
#include <queue>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	x = 0;T f = 1;char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1;ch = getchar();}
	while (isdigit(ch)) {x = (x << 3) + (x << 1) + ch - '0';ch = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
template<typename T>void Swap(T &x,T &y) {T z = x;x = y;y = z;}
template<typename T>T Min(T x,T y) {return x < y ? x : y;}
template<typename T>T Max(T x,T y) {return x > y ? x : y;}
template<typename T>T Abs(T x) {return x < 0 ? -x : x;}

const int N = 1e5 + 5;

int n,m;
int ans[N];
long long c,v;
struct node {
	int x,id;
	node() {}
	node(int X,int I) {x = X;id = I;}
	bool operator <(node a) const {return x < a.x;}
	bool operator >(node a) const {return x > a.x;}
	bool operator ==(node a) const {return x == a.x;}
	bool operator >=(node a) const {return x > a.x || x == a.x;}
};
vector<node> D[N],C[N];

node a[N],b[N];

void work(int x) {
	int len = 0;
	if (C[x].size() > D[x].size()) {
		len = D[x].size();
		for (int i = 1 ; i <= len ; ++ i) {
			a[i] = D[x][i - 1];
			b[i] = C[x][i - 1];
		}
		v -= (C[x].size() - D[x].size()) * c;
	}
	else {
		len = C[x].size();
		for (int i = 1 ; i <= len ; ++ i) {
			a[len - i + 1] = D[x][D[x].size() - i];
			b[i] = C[x][i - 1];
		}
	}
	int la = 1,ra = len,lb = 1,rb = len;
	for (int i = 1 ; i <= len ; ++ i) {
		if (a[ra] >= b[rb]) {
			v += c;
			v += a[ra].x;
			ans[b[rb].id] = a[ra].id;
			ra --;
			rb --;
		}
		else if (a[ra] < b[rb]) {
			v += a[la].x;
			v -= c;
			ans[b[rb].id] = a[la].id;
			la ++;
			rb --;
		}
		else if (a[la] >= b[lb]) {
			v += a[la].x;
			ans[b[lb].id] = a[la].id;
			la ++;
			lb ++;
			v += c;
		}
		else if (a[ra] == b[rb]) {
			if (a[la] < b[rb]) v -= c;
			else v += c;
			ans[b[rb].id] = a[la].id;
			v += a[la].x;
			la ++;
			rb --;
		}
	}
}

int main () {
	read(n);read(m);read(c);read(v);
	int x,y;
	for (int i = 1 ; i <= n ; ++ i) {
		read(x);read(y);
		D[x].push_back(node(y,i));
	}
	for (int i = 1 ; i <= m ; ++ i) {
		read(x);read(y);
		C[x].push_back(node(y,i));
	}
	for (int i = 1 ; i <= 1e5 ; ++ i) {
		if (D[i].size()) sort(D[i].begin(),D[i].end());
		if (C[i].size()) sort(C[i].begin(),C[i].end());
	}
	for (int i = 1 ; i <= 1e5 ; ++ i) if (C[i].size()) work(i);
	print(v),putchar('\n');
	for (int i = 1 ; i <= m ; ++ i) print(ans[i] ? ans[i] : -1),putchar('\n');
	return 0;
}
```

---

## 作者：VinstaG173 (赞：0)

最近教练正好在让我们复习贪心（雾

思路首先是由于牌上的数是正数，所以如果有牌可以打肯定要打，打出去就算输了也能买糖，不打的话净输 $c$ 颗糖。

然后是小 D 肯定想要赢，所以大的牌一定不能随便出。

然后肯定尽可能把最大的牌出掉，这样可以多买点糖。

小 D 又要把最大的牌出掉，又害怕出掉大牌后面压不上小 C 的牌，所以谨慎的小 D 肯定会选择将小 C 的牌从大到小排序，如果目前手上最大的牌能压上目前扫到的小 C 最大的需要判断的牌，那么压上去肯定是最优的。如果压不上，那我们把小 C 现在这张牌丢到一边，等轮完一次后小 D 再来用没打出的最大的一些牌来跟小 C 出的自己压不过的牌。这样小 D 肯定会得到最多的糖。

时间复杂度 $O(n\log{n})$。

Code:
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#define rg register
#define ll long long
using std::sort;
using std::vector;
inline char rc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
inline ll _read()
{
	ll x=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')x=x*10+cc-'0',cc=rc();
	return x;
}
void print(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
ll v,ansv;
int n,m,c,a,b,cm,dm;
struct card
{
	int val,id;
}cd;
inline bool cmp(card x,card y)
{
	return x.val>y.val;
}
vector<int>pc[100003];
int tnc[100003];
vector<card>tc[100003];
int tnd[100003];
vector<card>td[100003];
int ans[100003];
int main()
{
	n=read(),m=read(),c=read(),v=_read();ansv=v;
	for(rg int i=1;i<=n;++i)a=read(),b=read(),cd.val=b,cd.id=i,td[a].push_back(cd),++tnd[a],(a>dm)&&(dm=a);
	for(rg int i=1;i<=m;++i)a=read(),b=read(),cd.val=b,cd.id=i,tc[a].push_back(cd),++tnc[a],(a>cm)&&(cm=a);
	for(rg int i=1;i<=dm;++i)sort(td[i].begin(),td[i].end(),cmp);
	for(rg int i=1;i<=cm;++i)
	{
		b=0;
		sort(tc[i].begin(),tc[i].end(),cmp);
		for(rg int j=0;j<tnc[i];++j)
		{
			if(b==tnd[i])
			{
				ans[tc[i][j].id]=-1;ansv-=c;
				pc[i].push_back(0);
				continue;
			}
			if(td[i][b].val>=tc[i][j].val)
			{
				ans[tc[i][j].id]=td[i][b].id;
				ansv+=td[i][b].val+c;
				td[i][b].id=-1;
				pc[i].push_back(0);
				++b;
			}
			else pc[i].push_back(1);
		}
		b=0;
		for(rg int j=0;j<tnc[i];++j)
		{
			if(pc[i][j])
			{
				while(b<tnd[i]&&td[i][b].id==-1)++b;
				if(b==tnd[i])
				{
					ans[tc[i][j].id]=-1,ansv-=c;
					continue;
				}
				ans[tc[i][j].id]=td[i][b].id,ansv+=td[i][b].val-c,++b;
			}
		}
	}
	printf("%lld\n",ansv);
	for(rg int i=1;i<=m;++i)print(ans[i]),putchar('\n');
	return 0;
}
```

---


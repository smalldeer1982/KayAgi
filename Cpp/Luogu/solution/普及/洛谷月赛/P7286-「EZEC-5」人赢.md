# 「EZEC-5」人赢

## 题目背景

> “我们在 小 Z 面前秀个恩爱吧。”\
>“好的。”

小 Z 发现他身边都是人赢，这使他非常自闭。

小 Z 又看着身边的潇，不禁陷入了沉思……

![](https://cdn.luogu.com.cn/upload/image_hosting/b1ij58kc.png)

## 题目描述

潇有一个数组 $k$，下标为 $1$ 到 $n$ 。

潇定义 $f(x,y)=\begin{cases} \min(k_x,k_y) \times (x + y) &x \ne y \\ k_x\times x&x=y \end{cases}$ 。

潇想知道对于任意的 $1 \le x,y \le n$，$f(x,y)$ 的最大值是多少。但是她不会做，于是就问了善良的 小 Z，然而非常想在妹子面前表现的 小 Z 发现他也不会做，就只能够求助善良的你了。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（20 points）：$1 \le n \le 5000$。

- Subtask 2（10 points）：保证所有 $k_{i}$ 都相等。

- Subtask 3（20 points）：$k_i \le 10^3$。

- Subtask 4（50 points）：无特殊性质。

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$1 \le k_{i} \le 10^9$。

------------

本题加强版：[link](https://www.luogu.com.cn/problem/P7291)。

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
5
3 4 5 4 3```

### 输出

```
28```

# 题解

## 作者：wsyhb (赞：12)

## 分析 + 题解

首先，$x=y$ 的情况仅有 $n$ 种，枚举 $x$ 即可更新答案。

其次，对于 $x \neq y$ 的情况，$f(x,y)=\min(k_x,k_y) \cdot (x+y)$。我们**按 $k$ 值从大到小对编号排序**，记排序后第 $i$ 个编号为 $p_i$（$k_{p_1} \geq k_{p_2} \geq \cdots \geq k_{p_n}$），则 $\max_{x \neq y}f(x,y)=\max_{i=1}^n [k_i \cdot (i+\max_{j=1}^{i-1} p_j)]$，也就是**枚举其中 $k$ 较小的位置的编号 $p_i$，则另外一个编号为 $p_1,p_2,\cdots,p_{i-1}$ 中的一个**，记录前缀 $\max$ 即可线性计算。

**时间复杂度**：$O(n\log n)$（因为需要排序）

## 代码

实际实现时，可将前缀 $\max$ 初始值赋为 $0$，相当于 $x=y$，即可按照 $x\neq y$ 的情况直接计算。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1e6+5;
int k[max_n],id[max_n];
inline bool cmp(int x,int y)//按 k 值从大到小对编号排序 
{
	return k[x]>k[y];
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",k+i);
		id[i]=i;
	}
	sort(id+1,id+n+1,cmp);
	int Max=0;
	long long ans=0;//记得开 long long 
	for(int i=1;i<=n;++i)
	{
		ans=max(ans,1ll*k[id[i]]*(id[i]+Max));
		Max=max(Max,id[i]);//注意要先更新 ans 再更新 Max 
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：囧仙 (赞：11)

同时作为 [$\text{P7291}$](https://www.luogu.com.cn/problem/P7291) 的题解。

## 题目大意

给定一个长度为 $n$ 的数列 $k_i$ ，任取两个正整数 $x,y$ 满足 $x\le y$ ，计算出

$$f(x,y)=\begin{cases}
k_x\times x & x=y \cr
\min(k_x,k_y)\times (x+y) & x<y \cr
\end{cases}$$

的最大值。

## 题解

显然，对于第一种情况我们能够直接枚举，然后更新答案就行。主要问题是考虑第二种情况。

### $\mathcal O(n\log_2n)$ 做法

考虑从大到小枚举 $k_0$ 的值，然后选择满足 $k_x\ge k_0,k_y\ge k_0$ 的最大的 $(x,y)$ ，统计答案。显然随着 $k_0$ 的减小，可以选择的 $x,y$ 会变多，于是只要维护这样的 $(x,y)$ 的最大值和次大值，将它们分别作为 $y,x$ 即可。由于需要对 $k$ 进行排序，于是这样的做法的复杂度是 $\mathcal O(k\log_2 k+n)$ 。

### $\mathcal O(n)$ 大常数做法

某毒瘤出题人在赛后加强了数据……就在 [$\text{P7291}$](https://www.luogu.com.cn/problem/P7291) 。

事实上，我们能够发现上述做法的瓶颈在于排序。我们可以用基数排序，这样的复杂度应该是 $\mathcal O(n)$ 的。但事实上，哪怕使用跑的飞快的基数排序，仍然突破不了由于数组下标范围过大，导致随机访问带来的巨大多常数……经过这个屑的卡常，上述加强版题目可以用基排卡到 $350\text{ms}$ 左右，但是仍然无法通过那题。

### $\mathcal O(n)$ 小常数做法

考虑维护一下候选的 $x$ ，然后枚举 $y$ 。

- 可以发现，如果有一个 $x$ ，满足 $k_x\le k_y$ ，那么它只能和 $y$ 组成 $(x,y)$ 了。因为之后的一个数字 $z$ 和 $y$ 组合肯定比 $z$ 和 $x$ 组合要优。这时候我们就能把这样的 $x$ 移出去了。

- 剩下来的 $x$ ，肯定满足 $k_x>k_y$ ，于是 $\min(k_x,k_y)=y$ 。我们要选择其中最大的一个 $x$ ，更新答案。

为了很好的统计第二种情况的答案，我们当然希望 $x$ 集合是一个顺序结构了。事实上，由第一种情况，我们可以发现这个顺序结构中总是满足后一项的 $k$ 值严格小于前一项的 $k$ 值（不然就不会有前一项）。

这是什么？**单调栈**。

枚举 $y$ 的时候，弹出栈中满足 $k_x\le k_y$ 的 $x$ 与 $y$ 组成 $(x,y)$ 更新答案；剩下的栈顶的 $x$ 必然是最大的（因为我们按照顺序入栈），更新答案，然后把 $y$ 压到栈里作为下一个候选的 $x$ 。

复杂度仍然是 $\mathcal O(n)$ 。但它的优势在于，任何时候我们都是顺序访问，减小了访问的常数。

## 参考代码

```cpp
//朴素排序做法
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e6+3;
int n,A[MAXN],I[MAXN]; i64 ans=0;
bool cmp(int a,int b){
    return A[a]<A[b];
}
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int t1,t2;
int main(){
    n=qread(); up(1,n,i) {
        A[i]=qread(),I[i]=i,ans=max(ans,1ll*A[i]*i);
    }
    sort(I+1,I+1+n,cmp);
    dn(n,1,i){
        int x=I[i];
        if(x>t1) t2=t1,t1=x; else  if(x>t2) t2=x;
        if(t1&&t2) ans=max(ans,1ll*(t1+t2)*A[x]);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

```
//基数排序做法
#include<bits/stdc++.h>
#define up(l,r,i) for(register int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(register int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
typedef unsigned int       u32;
typedef unsigned long long u64;
const int INF =2147483647;
const int MAXN=1e7+3;
u32 n,I[MAXN]; i64 ans=0;
int t1=-1,t2=-1; u32 P[65536],Q[65536],J[MAXN];
unsigned short M[MAXN],N[MAXN];
char buf[1<<27],*p1,*p2; u32 a,b;
signed main(){
    p2=buf+fread(buf,1,1<<27,stdin),p1=buf;
    while( isdigit(*p1)) n=n*10+((*p1)^48),++p1;
    while(!isdigit(*p1)) ++p1;
    while(b<n){
        a=(*p1)^48;
        if(*++p1>='0'){
            a=a*10+((*p1)^48);
            if(*++p1>='0'){
                a=a*10+((*p1)^48);
                if(*++p1>='0'){
                    a=a*10+((*p1)^48);
                    if(*++p1>='0'){
                        a=a*10+((*p1)^48);
                        if(*++p1>='0'){
                            a=a*10+((*p1)^48);
                            if(*++p1>='0'){
                                a=a*10+((*p1)^48);
                                if(*++p1>='0'){
                                    a=a*10+((*p1)^48);
                                    if(*++p1>='0'){
                                        a=a*10+((*p1)^48);
                                        if(*++p1>='0') a=a*10+((*p1)^48);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        M[b]=a,N[b]=a>>16,++P[M[b]],++Q[N[b]],++b,++p1;
    }
    up(1,65535,i) P[i]+=P[i-1],Q[i]+=Q[i-1];
    dn(n-1,0,i) J[--P[M[i]]]=i; dn(n-1,0,i) I[--Q[N[J[i]]]]=J[i];
    dn(n-1,0,i){
        int x=I[i];
        if(x>t1) t2=t1,t1=x,ans=max(ans,1ll*(t1+t2+2)*((int)N[x]<<16|M[x])); else
        if(x>t2) t2= x,     ans=max(ans,1ll*(t1+t2+2)*((int)N[x]<<16|M[x]));
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

```
//单调栈做法
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =1e7+3;
int n,A[MAXN],S[MAXN][2],s; i64 ans;
int main(){
    n=qread(); up(1,n,i) A[i]=qread(),ans=max(ans,1ll*A[i]*i);
    up(1,n,i){
        while(s&&S[s][1]<=A[i]){
            ans=max(ans,1ll*(S[s][0]+i)*S[s][1]),--s;
        }
        if(s) ans=max(ans,1ll*(S[s][0]+i)*A[i]);
        S[++s][0]=i,S[s][1]=A[i];
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：cxh315 (赞：9)

不难发现，第二条规则很劣，在除极特殊情况下不需要使用。~~（先挖个坑）~~

因此，我们先只考虑第一条规则。将序列由小到大排序，记排序后序列为 $q$ ，观察原式。
$$f(x,y)=\min(k_x,k_y)\times(x+y)\ (x\ne y)$$

我们枚举排序后序列中的元素 $q_a$ ，观察到若选择的另一个元素 $q_b$ 在排序后序列中的位置在 $q_a$ 后，$\min(k_x,k_y)$取值即为 $q_a$ ，若 $q_b$ 在排序后序列中的位置在 $q_a$ 前，不难发现 $f(x,y)=f(y,x)$ ，因此必然可以在枚举到$q_b$时作为第一种情况处理。

此时，我们若想使 $f(x,y)$ 最大，我们只能使其在原序列中的位置之和即 $(x+y)$ 最大,而 $x$ 已经确定，我们唯一能做的就是在满足前面规则情况下使 $y$ 最大。

这样问题就变成了这个样子：给定一段序列及一个元素，求其中最靠后的不小于给定元素**且不是给定元素**的元素。

考虑在原序列末尾建立指针 $t$ ,若 $k_t$ 小于给定元素或就是给定元素，将 $t$ 向前移动。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,k1[1000005];
struct K{
	int s,p;
}k[1000005];
long long ans;
bool cmp(K a,K b){
	return a.s<b.s;
}
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int main(){
	n=read();
	q=n;
	for(register int i=1;i<=n;++i){
		k[i].s=read();
		k[i].p=i;
		k1[i]=k[i].s;
	}
	sort(k+1,k+1+n,cmp);
	for(register int i=1;i<n;++i){
		while(k1[q]<k[i].s||q==k[i].p){
			--q;
		}
		ans=max(ans,1LL*k[i].s*(1LL*(k[i].p+q)));
	}
	printf("%lld",ans);
}
```
光荣的 Wa 成30，并且分别在1,4两个 Subtack 的最后一个点。~~（话说这个样子绝对是毒瘤出题人故意卡）~~

还记得我在开头挖的那个坑吗？这条规则在除极特殊情况下不需要使用。那极特殊情况是什么呢？考虑这样一组数据。

```
5
1 2 3 4 100
```
若选择了100和另一个元素， $\min(k_x,k_y)$ 的值必然变成较小元素，无论后面有多大也没有用。

那如何修改呢？很简单，再遍历一次，按照第二种规则计算答案即可。

代码上加上这三行
```cpp
for(int i=1;i<=n;i++){
	ans=max(ans,1LL*i*k1[i]);
}
```


做法时间复杂度瓶颈在于排序， $O(n\log n)$



---

## 作者：monstersqwq (赞：4)

~~貌似是近几月最简单的B呢~~

考虑对 $x=y$ 和 $x\ne y$ 两种情况分别考虑。

若 $x=y$，即求 $k_x\times x$ 的最大值，遍历一遍 $k$ 即可。

若 $x\ne y$，考虑先确定 $\min(k_x,k_y)$ 的值为 $k_x$，然后贪心地选取大于等于 $k_x$ 的值中下标的最大值。

那么可以先按照 $k$ 排序之后，由大到小遍历，期间记录遍历过的点在原数组中下标的最大值来更新答案，注意要先更新下标最大值再更新答案，避免统计到 $x=y$ 的情况。

复杂度 $\mathcal{O}(n \log n)$，可以通过本题。

代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
int n;
struct node
{
	ll num,id;
}k[1000005];
ll ans=0;
bool cmp(node a,node b)
{
	if(a.num!=b.num) return a.num>b.num;
   return a.id>b.id;//注意，这里需要加上这个的判断是因为要保证在数值相等时下标可以统计到最大值，可以自己感性理解一下
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&k[i].num);
		k[i].id=i;
		ans=max(ans,k[i].num*i);
	}
	sort(k+1,k+n+1,cmp);
	ll tmp=0;
	for(int i=1;i<=n;i++)
	{
		if(i!=n) ans=max(ans,(tmp+k[i].id)*k[i].num);
		tmp=max(tmp,k[i].id); 
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：WsW_ (赞：1)

一道很有趣的题目  
思路：先是一边输入一边求 $k_x \times x$ 的值，不停更新变量。  
接着就是处理 $min(k_x,k_y) \times (x+y)$ 了。  
我们假设 $k_x≤k_y$ ，这样的话就不用考虑其他情况了，因为 $x$ 和 $y$ 可以互换位置。  
当 $k_x≤k_y$ 时，我们要 $y$ 尽可能大，但我们发现，小于 $x+1$ 的数的集合一定包含小于 $x$ 的数的集合。所以，我们只需要不断更新 $y$ 的值就好了。于是，我们就可以先排序，然后一边更新 $y$ 的最大值。  
另外，注意数据范围！
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	long long id,num;
}k[1000005];
long long n,maxy=0,maxx=0;       //十年OI一场空，不开long long见祖宗。
bool cmp(node x,node y){        //排序
	if(x.num==y.num)return x.id>y.id;
	return x.num>y.num;
}
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&k[i].num);
		k[i].id=i;
		maxx=max(i*k[i].num,maxx);   //处理x*k_x
	}
	sort(k+1,k+1+n,cmp);
	maxy=k[1].id;
	for(long long i=2;i<=n;i++){    //从2开始
		maxx=max(k[i].num*(k[i].id+maxy),maxx);
		maxy=max(maxy,k[i].id);     //更新y的最大值
	}
	printf("%lld\n",maxx);
	return 0;
}
```

---

## 作者：Ryo_Yamada (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P7286)

> 给定 $n$ 和 $n$ 个正整数的数组 $k$，求 $f(x,\,y)$ 的最大值。$f(x,\,y)$ 含义见题面。

### $20pts$

$1 \leq n \leq 5000$，直接 $n^2$ 枚举所有 $x,\,y$ 即可。

### $30pts$

所有 $k_i$ 相等。不难看出 $x=n-1,\,y=n$ 时答案最大。$O(1)$ 求解即可。

### $100pts$

比赛的时候好像被 $O(n^2)$ 各种乱搞搞过去了……

$O(n \log n)$ 做法

不妨设 $k_x < k_y$，则 $k_y > k_x$ 且 $y$ 最大时 $k_x \times (x+y)$ 最大。先排序 $k$ 数组，随后用一个 $\text{vis}$ 数组第 $i$ 个数是否比当前值小。注意 $i$ 要取**排序前**的值，需要记录 $id$。

对于 $x=y$ 的情况 $O(n)$ 模拟即可。时间复杂度 $O(n \log n)$。

$\text{Code}$：

```cpp
#define rep(i, b, s) for(int i = b; i <= s; ++i)

template<class T1, class T2>
void To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }

const int N = 1e6 + 5;

int n;
ll ans;
bool vis[N];

struct Node {
	ll id, w;
	bool operator < (const Node &oth) const {
		return w == oth.w ? id < oth.id : w < oth.w;
	}
} k[N];

int main() {
	qread(n);
	rep(i, 1, n) qread(k[i].w), k[i].id = i, To_max(ans, k[i].w * i);
	sort(k + 1, k + n + 1);
	int now = n;
	rep(i, 1, n) {
		vis[k[i].id] = true;
		while(vis[now]) --now; //计算 k[now] > k[i] 时 now 能取到的最大值
		To_max(ans, k[i].w * (k[i].id + now));
	}
	printf("%lld\n", ans);
 	return 0;
}
```

~~题外话：~~

> 小 P 发现她身边都是人赢，这使他非常自闭。

~~小 P 是男是女啊~~

---

## 作者：zjrdmd (赞：0)

分类讨论，显然如果我们必须取$k_x$，那么另外一个$k_y$有两种情况

- $k_y\leq k_x$

- $k_y>k_x$

而第一种情况可以包含在第二种情况中（$x,y$位置互换）

于是我们只需要讨论第二种，这时，我们发现min$(k_x,k_y$)变为了一个定值，于是$y$越大越好。

那么这道题就做完了，对于每个$k_x$，我们只需要找到比他大的数字中坐标最大的一个即可，那么我们排序+前缀和预处理即可。

代码：

```cpp

#include <iostream>
#include <cstdio>
#include <algorithm>

#define ri register int
#define int long long

inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}

const int N=1e6+5;
struct node{
	int k,num;
}ifm[N];
int n,ma[N],maxn=0;
 
bool cmp(node x,node y){return x.k<y.k;} 

signed main(void){
	n=read();
	for(ri i=1;i<=n;i++)ifm[i].k=read(),ifm[i].num=i;
	std::sort(ifm+1,ifm+n+1,cmp);
	for(ri i=n;i>=1;i--)ma[i]=std::max(ma[i+1],ifm[i+1].num);
	for(ri i=1;i<=n;i++)maxn=std::max(std::max(maxn,ifm[i].num*ifm[i].k),(ma[i]+ifm[i].num)*ifm[i].k);
	printf("%lld",maxn);
	return 0;
}
```




---

## 作者：灵乌路空 (赞：0)

更好的阅读体验：[My blog](https://www.cnblogs.com/luckyblock/p/14323863.html)。

知识点：单调栈

[原题面](https://www.luogu.com.cn/problem/P7286)

## 简述

>给定一长度为 $n$ 的数列 $k$，定义：  
>$$f(x,y) = \begin{cases}
 \min(k_x, k_y)\times (x + y) &(x\not= y)\\
 k_x \times x &(x=y)
 \end{cases}$$
>求：  
>$$\large \max_{1\le x,y\le n} f(x,y)$$
>$1\le n\le 10^6$，$1\le k_i\le 10^9$。  
>1S，128MB。

## 分析

$x=y$ 的情况可以在读入时顺便处理，仅考虑 $x\not= y$ 的情况。  
一种显然的想法是枚举 $x$，找到 $\min(k_x,k_y) = x$ 的最优的 $y$。$y$ 显然越大越好，则最优的 $k_y$ 是从数列右侧数第一个不小于 $k_x$ 的元素。  
排序后遍历数列即可解决，复杂度 $O(n\log n)$。  

---

然而出题人给出了强制线性做法的加强版：[Link](https://www.luogu.com.cn/problem/P7291)。菜鸡 Luckyblock 找不到能够维护 `数列右侧第一个不小于 x 的元素` 的小常数线性做法，上述思路在加强版中暂时认为无法通过。  
考虑统计答案时钦定 $x<y$，正序枚举 $y$，考虑 $1\sim y-1$ 中哪些元素作为 $x$ 时贡献最大。显然，若存在 $(i < j <y)\land \,(k_i <k_j)$，则一定有 $f(k_j,y)>f(k_i,y)$。发现有贡献的 $x$ 存在单调性。  

考虑在枚举 $y$ 的同时，对 $1\sim y - 1$ 中的元素维护一个单调栈，单调栈中自顶向下元素**下标递减，$k$ 递增**。  
枚举到一个新 $y$ 时，考察栈顶元素 $k_x$ 与 $k_y$ 的大小关系。若 $k_x \le k_y$，发现 $k_y$ 对之后的数配对的贡献大于与 $k_x$ 配对的，则统计 $f(x,y)$ 的贡献，并令 $x$ 出栈。  否则对于所有栈中元素都有 $\min(k_x,k_y) = k_y$，最右侧的 $x$ 与 $y$ 配对贡献最大，统计它的贡献，并令 $y$ 入栈。每个元素只会入栈出栈各一次，总复杂度 $O(n)$ 级别。

## 代码

```cpp
//知识点：单调栈
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cstdio>
#define LL long long
const int kMaxn = 1e7 + 10;
//=============================================================
int n, top, a[kMaxn], st[kMaxn];
LL ans;
//=============================================================
#define getchar()                                                          \
  (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) \
       ? EOF                                                               \
       : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
inline int read() {
  char c = getchar();
  int x = 0;
  bool f = 0;
  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);
  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
  if (f) x = -x;
  return x;
}
void Chkmax(LL &fir_, LL sec_) {
  if (sec_ > fir_) fir_ = sec_;
}
//=============================================================
int main() {
  n = read();
  for (int i = 1; i <= n; ++ i) {
    a[i] = read();
    Chkmax(ans, 1ll * i * a[i]);
    while (top && a[st[top]] <= a[i]) {
      Chkmax(ans, 1ll * a[st[top]] * (st[top] + i));
      -- top;
    }
    if (top) Chkmax(ans, 1ll * a[i] * (st[top] + i));
    st[++ top] = i;
  }
  printf("%lld\n", ans);
  return 0;
}
```

---

## 作者：Yusani_huh (赞：0)

PS：这篇题解为 $n\log n$ 做法，想了解更优解法的同学请移步。

话不多说，看题，题目让求一个奇怪函数 $f(x,y)$ 的最大值。

$n^2$ 枚举首先排除。仔细观察这个函数，在 $k_x$ 和 $k_y$ 两个数求函数值时，函数值只和两数中的较小数有关。

假设有一种方法无序枚举，每次枚举就都得求一次最小值。但既然函数值只和较小数有关，我们可以做一些优化。

在很多组数中较小的那个数都是公用的，我们不妨把这些求值步骤合并。既然 $\min(k_x,k_y)$ 这个量相同，要求最大即得使 $x+y$ 最大。不妨再假设 $\min(k_x,k_y)=k_x$，那么 $x$ 这个值也是确定的，接下来只需要让 $y$ 最大就可以了。

此时 $n\log n$ 做法已经呼之欲出了：按照数值大小排序， $y$ 的最大值直接预处理一下即可。至于 $k_x\times x$，因为 $y$ 一定大于 0，所以除了最大的数需要特判一下之外，其他位上都可以直接无视这种情况。

具体内容还见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long ans,mx[1000003];
struct node{
	long long num,w;
}h[1000003];
bool cmp(node a,node b)
	{return a.num<b.num;}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%lld",&h[i].num);
		h[i].w=i;
	}
	sort(h+1,h+n+1,cmp);  //按照数值从小到大排序
	mx[n]=h[n].w;  //预处理最后n个数下标的最大值
	for(int i=n-1;i>=1;--i)
		mx[i]=max(mx[i+1],h[i].w);  //预处理最后i个数下标的最大值
	ans=h[n].num*h[n].w;  //特判最大数的x=y情况
	for(int i=1;i<n;++i)
		ans=max(ans,h[i].num*(h[i].w+mx[i+1]));
	printf("%lld\n",ans);
	return 0;
}
```

---


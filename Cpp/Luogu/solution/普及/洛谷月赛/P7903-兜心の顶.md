# 兜心の顶

## 题目背景

Source：[八仙敬酒](/paste/78f1vlm0)，这是可以点的。

- 吕洞宾——醉酒提壶力千钧；
- 铁拐李——旋肘膝撞醉还真；
- **汉钟离——跌步抱坛兜心顶**；
- 蓝采和——单提敬酒拦腰破；
- 张果老——醉酒抛杯踢连环；
- 曹国舅——仙人敬酒锁喉扣；
- 韩湘子——擒腕击胸醉吹箫；
- 何仙姑——弹腰献酒醉荡步。

## 题目描述

给定正整数 $n$，要求构造一棵 $n$ 个结点的树，满足树的直径的重心 **不是** 树的重心。

同时这棵树需满足：直径$^1$、重心$^2$、直径的重心$^3$全部唯一。

---

注：

- 树的直径$^1$：[https://oi-wiki.org/graph/tree-diameter/](https://oi-wiki.org/graph/tree-diameter/)
- 树的重心$^2$：[https://oi-wiki.org/graph/tree-centroid/](https://oi-wiki.org/graph/tree-centroid/)
- 树的直径的重心$^3$：将树的直径（一条链）视作一棵树，求其中心（一个点）。

## 说明/提示

#### 样例说明

![](https://cdn.luogu.com.cn/upload/image_hosting/kdgu2xd9.png)

样例 #1 中直径的重心是 $7$，树的重心是 $1$，$1\ne7$。

样例 #2 中 $n=2$，只有两个点时显然重心不可能唯一。

#### 数据范围

**本题采取捆绑测试。**

| 子任务编号 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $30$ | $n\le10$ |
| $2$ | $30$ | $n$ 是奇数 |
| $3$ | $30$ | $n$ 是偶数 |
| $4$ | $10$ | 无 |

对于 $100\%$ 的数据：$1\le n\le10^4$。

**本题提供 Special Judge 源码，参见下方附件。**

## 样例 #1

### 输入

```
20```

### 输出

```
20
20 18
1 3
19 12
19 4
16 1
4 1
1 7
16 10
7 20
13 8
10 2
18 13
13 17
14 18
11 19
16 5
2 6
16 9
17 15```

## 样例 #2

### 输入

```
2```

### 输出

```
-1```

# 题解

## 作者：Danno0v0 (赞：11)

### Update on 10/24

修改了后半篇一部分错误的口胡。

------------------------

一道大大大水题。

首先题上说，重心是唯一的。

这太好办了，菊花图。

![菊花图](https://cdn.luogu.com.cn/upload/image_hosting/ei2mmaks.png)

那么，我们再看：直径重心唯一。

那么可以想到直径长度应该是个奇数。

咦，直径重心不能等于树的重心？

熟悉图论题里特（ du ）殊（ liu ）图的同学可能已经想到了这是什么了。

把菊花图稍加改造，那么就可以请出我们的——蒲公英。

![蒲公英](https://cdn.luogu.com.cn/upload/image_hosting/j7gmqpbp.png)

对了，因为直径重心唯一，所以直径长度不能为偶数——还有不能大于节点数一半，别让重心偏移。

最后来看，唔嗯，直径要唯一。

原来的菊花图中每一条边和这个长长的链都构成了直径。

那么我们把原来菊花图中一条边延长一个节点，这样它和这个长长的链接在一起就是唯一的直径啦，因为其余的边如果与那条链接在一起总会比直径长度小 $1$ 。

就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/pyr7n7w5.png)

那么，我们总结一下。

我们的基础是一个蒲公英。

然后这条蒲公英上的链的节点个数不大于节点总数一半。

然后我们需要在另外一条边上接上一个节点，保证直径唯一。

最后保证直径的重心（也就是中间那个）不是树的重心。

那么，根据这些，我们就可以造出究极完全态兜心の顶之树（根据上面这些条件，造出的树可能不唯一，我是这样造的）——

![](https://cdn.luogu.com.cn/upload/image_hosting/ellkqavu.png)

$3$ 号节点为重心， $1$ 号与 $2$ 号一起保证直径唯一， $4567$ 是蒲公英的链，长度为 $7$ 的直径可以保证树的重心不与直径重心重合。

然后 $8$ 及 $8$ 以后的节点皆可以直接接到 $3$ 号节点上，可以动手画一下，完全不破坏这棵树的性质（就像那些节点，更多的节点，还是更多的节点一样）。

而当节点数小等于于 $8$ 的时候可以证明（我是全画了一遍 orz ：要么会成为菊花图，要么就只有一条链，要么直径长度不为奇数，要么重心会偏到链上去，要么是树的重心有两个），没有办法造出来，所以输出 $-1$ 就完咯。

然后就做完了，真是一道大大大水题。

code：

~~对于这种大水题压一下行不过分吧以及挑战全网最简洁代码： $7$ 行~~

```cpp
#include<bits/stdc++.h>
int main(){
	int n;
	std::cin>>n;
	if(n<=8)std::cout<<-1;
	else{std::printf("%d\n%d %d\n%d %d\n%d %d\n%d %d\n%d %d\n%d %d\n",n,1,2,2,3,3,4,4,5,5,6,6,7);
	for(int j=8;j<=n;j++){std::printf("%d %d\n",3,j);}}}
```





---

## 作者：xuan_gong_dong (赞：8)

## 题面
[P7903 「DCOI」兜心の顶](https://www.luogu.com.cn/problem/P7903)

这是一道构造题,~~也是蒟蒻的第一道构造题题解~~，
## 分析
构造的树需要直径 $1$ ，重心 $2$ ，直径的重心 $3$ 唯一。

而树的直径一定为奇数（ 不然没直径的重心 ）考场上发现当 $n\le8$ 时，树直径可能为偶数

也可能重心和直径的重心重合，如图

![](https://cdn.luogu.com.cn/upload/image_hosting/6533f88k.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

该图中 $A\to B\to E\to F$  是树的直径，发现确实重合了，

### 所以

```cpp
	if(n<9)
	{
		putchar('-');
		putchar('1');
		return 0;
	}
```
分析完 $n<9$，再来分析 $n\geqslant9$ 的情况

# 重点来了
如果我们把1，2，3，4，5，6，7依次连起来，并且剩下的点与 $3$ 相连，那么直径永远只可能是   $1\to2\to3\to4\to5\to6\to7$,直径的重心只可能4，整棵树的重心只可能是3 。

![](https://cdn.luogu.com.cn/upload/image_hosting/2fewlkim.png)

### 附上特快代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    char c(getchar());
    int x(0);
    while(!isdigit(c))c=getchar();
    while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
void write(int a)
{
    if(a>9)write(a/10);
    putchar(a%10+48);
}
int main()
{
	int n(read());
	if(n<9)
	{
		putchar('-');
		putchar('1');
		return 0;
	}
	write(n);
	putchar('\n');
	for(int i=1;i<7;i++)
	{
		write(i);
		putchar(' ');
		write(i+1);
		putchar('\n');
	}
	for(int i=8;i<=n;i++)
	{
		putchar('3');
		putchar(' ');
		write(i);
		putchar('\n');
	}
	return 0;
}

```



---

## 作者：Elaina_0 (赞：5)

# P7903 兜心の顶

蒟蒻第一篇题解，望审核大大通过qwq

ad：[Elaina's博客](https://www.cnblogs.com/Elaina-0)

## 题目大意
构造一棵$n$个节点的树，使得树的直径、树的重心、树的直径的重心唯一，并且树的重心与树的直径的重心不同。

愚以为这个“树的直径的**重心**”为“树的直径的**中心**”

 _不然对于样例一：_ 

 _直径的重心应该是除了端点以外所有的节点。_ 

## 分析
我们先构造一个长链作为树的直径，

由于树的直径的重心唯一，

~~显然~~ 　直径应为奇数。

------------

分情况讨论

1. ~~显然~~　 直径长度为$1$时不满足题意。

2. 当直径长度为$3$时：
	
    此时，树的直径的重心为$点2$。
    
    若要 **“满足树的直径的重心不是树的重心”** ，那么树的重心可供选取的位置为$点1$或$点3$。　~~当然，这两个位置是等价的~~
    
    假如我们选$点1$：
    
    那么为了让~~她~~ $点1$ 成为重心，我们至少要给 $点1$ 一个节点……吗？

    ![](https://cdn.luogu.com.cn/upload/image_hosting/361vgi0a.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
    
    细看可发现：此时树的重心有$点1$，$点2$两个重心，
    
    所以我们至少要给$点1$ 两个节点。
    
    当然，此时树的直径变为了$4$，不满足题意。

3. 当直径长度为$5$时：
    
    此时，树的直径的重心为$点3$。
    
    那么现在树的重心可供选取的位置为$点1$($\Leftrightarrow 点5$)或$点2$($\Leftrightarrow 点4$)。
    当我们选$点1$时，与直径长度为$3$时同理。
    
    当我们选$点2$时，我们可以在此节点上增加至少两个节点（同上）使他成为树的重心。
    
	![](https://cdn.luogu.com.cn/upload/image_hosting/dhhysgeg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
    
    乂~ 多了两个直径 咋办呢？
    
    在$点1$上再加一个点不就完事了嘛~
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/kkdzruv3.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
    
    乂~ 直径成偶数了 咋办呢？
    
    为了不让**树的直径的重心**与**树的重心**重合，我们只能在$点5$再加一个节点。
    
最终我们得到了~~一个完整的大保健~~ 一颗兜心の顶树，ta的直径为$7$,重心为$点2$，直径的重心为$点3$。
    
![](https://cdn.luogu.com.cn/upload/image_hosting/69yx1iq5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
    
综上，$n \leq 8$时 无解。
    
乂~ 那如果点数比$9$多 咋办呢？

其实有些熟悉~~毒瘤题~~的dalao可能已经想到了，这实际上就是一个菊花图。

给$点3$疯狂加点不就完了嘛~

![](https://cdn.luogu.com.cn/upload/image_hosting/jqe2aoll.png?x-oss-process=image/resize,m_lfit,h_170,w_225)



## Elaina's code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define Elaina 0
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return x*f;
}

int n;

main(){
	n=read();
	if(n<=8) return printf("-1"),Elaina;
	printf("%lld\n",n);
	printf("1 2\n");
	printf("2 3\n");
	printf("3 4\n");
	printf("4 5\n");
	printf("5 6\n");
	printf("6 7\n");
	for(int i=8;i<=n;++i){
		printf("3 %lld\n",i);
	}
	return Elaina;
}
```

---

## 作者：nomonick (赞：3)


# P7903 「DCOI」兜心の顶

## 题面解析

题面 link : [P7903](https://www.luogu.com.cn/problem/P7903)

构造一棵 $n$ 个结点的树，满足

- 树的直径的重心不是树的重心。

- 直径、重心、直径的重心全部唯一。

## 算法的朴素分析

这道题的构造思路很明显可以先确定一条较长的边作为直径， 再在一个不影响直径个数或长度且不是直径重心的点上补充菊花图，如下图：

![](https://pic.imgdb.cn/item/617007a32ab3f51d91cda9bb.png)

## 考虑解法

这样的构造一定成立。那么我们需要来考虑的只有直径至少需要的长度和应该在满足什么条件的点（设改点为 $x$ ）上补成菊花图。

根据重心的定义，可以得知直径的重心就是直径的中点。由于直径的重心唯一，所以构造的树直径的长度必然为奇数。

而 $x$ 这的点一定是树上的重心，因为包含了 $x$ 的子树大小会急速的增大。

1.  保证在 $x$ 上加边后不会影响直径长度

    那么即直径的两个端点不能作为 $x$ , 所以直径的长度至少为 $3$ 

2. 保证在 $x$ 上加边后不会影响直径的个数

   那么即直径上与两个端点距离为 $1$ 的点不能作为 $x$ , 所以直径的长度至少为 $5$ 

3. 保证树的直径的重心不是树的重心

   那么直径的中点就不可以一作为 $x$ ，所以可以推出直径的长度至少为 $7$ 

所以我们可以假设这棵树的直径为 $7$ 。那么我们就应该在点 $3$ 或 $5$ 上补充菊花图。

而对于 $x$ 来说，他的最大子树大小为 $4$ ，而直径中心的子树大小为 $3 + siz$ (设 $siz$ 为菊花图除直径上的点的大小，换句话说就是添加的边数)

保证树的直径的重心不是树的重心，所以要保证所构造的树重心在 $x$ 上，所以至少要在直径上连接 $2$ 个点。因此当且仅当 $n >= 9$ 的条件下才能构造出结果。

# code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
signed main()
{
    scanf("%d",&n);
	if (n < 9) return puts("-1"),0;
	printf("%d\n",n);
	printf("1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n");
	for (int i = 8; i <= n; ++i)
		printf("%d %d\n",i,3);
	return 0;
}
```


---

## 作者：言琢დ (赞：3)

出题人题解。

## C 兜心の顶

~~按道理边做这题边点开 P7238、P7807，应该通过率 100% 吧。~~

下文中「唯一性」代指直径、重心、直径重心三个「唯一」，「不等性」代指树的重心不等于直径重心。

#### 一、直径的长度讨论

首先直径 **不会是偶数**。

否则设直径的长度是 $2k$，由 $1\cdots 2k$ 这 $2k$ 个结点组成。

那么结点 $k$ 和结点 $k+1$ 必然都是直径重心，与唯一性不符，舍去。

然后直径不可能是 $1$：显然。

直径不可能是 $3,5$：此时重心只能出现在中间的点（否则与唯一性不符），与不等性不符。

综上，直径长度至少为 $7$ 且必为奇数。

#### 二、重心位置的讨论

不妨钦定我们构造的树的直径就是 $7$，下面来看看位置：

首先直径的重心一定是 $1\cdots7$ 号结点的中点：$4$ 号结点。

那么树的重心一定要出现在其他结点上，首先 $1,2,6,7$ 被排除，理由是唯一性。

那么只剩下 $3,5$ 两个对称的结点，我们不妨设重心是 $3$ 号结点。

此时需要给 $3$ 号结点再安排上一些子树，为了不影响唯一性，$3$ 的其他子树深度只能为 $1$。

那么考虑到 $3$ 必须是唯一重心，至少要加入两个新结点，才能保证。

综上，树的大小至少为 $9$，且形态为：

$$1\leftrightarrow2\leftrightarrow\color{red}3\color{black}\leftrightarrow\color{blue}4\color{black}\leftrightarrow5\leftrightarrow6\leftrightarrow7$$

$$8\leftrightarrow\color{red}3\color{black}\leftrightarrow9$$

其中 $\color{red}3$ 是树的重心，$\color{blue}4$ 是直径重心，上面的这一条链就是直径。

#### 三、N >= 10 情况的讨论

不难发现，只要我们继续按照该策略，不断地给结点 $3$ 添加新的子结点（形成一张菊花图）即可。

#### 四、代码实现

当 $N\le8$ 时：输出 `-1`。

其他情况，先输出

$$1\leftrightarrow2\leftrightarrow\color{red}3\color{black}\leftrightarrow\color{blue}4\color{black}\leftrightarrow5\leftrightarrow6\leftrightarrow7$$

这个基本模型，然后对于 $i=8\sim N$ 的所有结点 $i$，全部连向结点 $3$ 即可。

#### std

```cpp
#include<cstdio>
int init(){
	char c = getchar();
	int x = 0, f = 1;
	for (; c < '0' || c > '9'; c = getchar())
		if (c == '-') f = -1;
	for (; c >= '0' && c <= '9'; c = getchar())
		x = (x << 1) + (x << 3) + (c ^ 48);
	return x * f;
}
int print(int x){
	if (x < 0) x = -x, putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
	return 0;
}
int main(){
	int n = init();
	if (n <= 8) return print(-1);
	print(n), putchar('\n');
	for (int i = 1; i <= 6; ++i)
		print(i), putchar(' '), print(i+1), putchar('\n');
	for (int i = 8; i <= n; ++i)
		print(3), putchar(' '), print(i), putchar('\n');
}
```

#### 五、后记

本题显然有很多合理的构造，但是我发现本构造最为清晰、整洁、易懂。

---

## 作者：_farawaystar_ (赞：2)

#### 题意简述

1. 首先要理解：所谓的树是[无根树](https://baike.baidu.com/item/%E6%97%A0%E6%A0%B9%E6%A0%91/10017543?fr=aladdin)。

2. 要求树的直径（通俗理解就是树上最长链）、树的重心（以重心这个节点为根时，最大子树最小）、树的直径的重心唯一。

3. 要求树的重心与树的直径的重心不同。

#### 题目分析

1. 确定这是一个构造题

2. 我们先确定树的直径及其重心：既然树的直径是一条链，那么为了保证树的重心唯一，则直径长必须是奇数，同时确定了重心为链最中间的点。

3. 我们在以这条链为树之时，链的重心即为树的重心。既然直径的重心已经确定了，那么，我们下一步要做到就是让树的重心偏移。

4. 不断向直径重心的右儿子（深度除直径外最小，最容易将重心转移）加儿子（有多少加多少），导致原链的右子树变大，而右儿子的最大子树不变，重心转移。

5. 可行性：为了保证在加儿子操作时，满足要求 $2$ 的唯一性，直径的长要为 $\geq 7$ (首先保证有右儿子，在给右儿子加儿子时，如果右儿子没有孙子，那么直径数量会增加)，然后在加儿子时，必须要加 $2$ 个及以上的儿子才能导致重心发生偏移，所以算法可行的条件是：节点数 $\geq 9$。

代码：
```
#include<cstdio>
using namespace std;
int n;
int read(){
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
void print(int x){
	if(x<0)putchar('-'),x=~x+1;
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
int main(){
	n=read();
	if(n<9){
		printf("-1");
		return 0;
	}
	print(n);
	printf("\n1 2\n2 3\n3 4\n1 5\n5 6\n6 7\n");
	for(int i=8;i<=n;i++){
		putchar('2');
		putchar(' ');
		print(i);
		putchar('\n');
	}
	return 0;
}
```
谢谢大家！！！

---

## 作者：Tjaweiof (赞：1)

# P7903 题解
[题目传送门](https://www.luogu.com.cn/problem/P7903)

借鉴其它题解的思路，当 $n\le8$ 时，输出 `-1`，否则按照如下规律：

当 $n=9$ 时，我们可以构造这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/gyw7hvl3.png)

当 $n=10$ 时，我们可以构造这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ej34zox.png)

发现了吗，当 $n\ge9$ 时，$1\sim7$ 始终属于链状；$8\sim n$ 都连着 $3$。这样始终满足要求，因为 [树的直径](https://oi-wiki.org/graph/tree-diameter/) 是 $1\sim7$ 的链，那么树的直径的重心必然是 $1\sim7$ 中任意一个节点；而 [树的重心](https://oi-wiki.org/graph/tree-centroid/) 却是 $8$ 到 $n$ 中的任意一个节点，所以一定不符合。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    if (n <= 8){
        cout << "-1";
        return 0;
    }
    cout << n << "\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n";
    for (int i = 8; i <= n; i++){
        cout << "3 " << i << endl;
    }
    return 0;
}
```

---

## 作者：Melon_Musk (赞：1)

## [题目链接](https://www.luogu.com.cn/problem/P7903)

## 分析

整理一下题目的要求：

1. 树直径的重心不是树的重心

2. 直径唯一

3. 重心唯一

4. 直径的重心唯一

我们来一步一步完成题目的要求，我们要先达成题目使直径的重心不为树的重心的要求，容易想到我们先构造一条链，然后在边缘某点上构造一个菊花图。

然后我们思考那条链需要多长，因为有直径的重心要唯一的要求，这条链的长度只能是奇数（偶数的话中间的两个点都会是重心，不符合要求）。

长度为 $1$ 的显然不行。

思考长度为 $3$ 是否可行。答案是也不可行，因为此时我们会发现这变成一整个菊花图，那么不但直径不唯一，而且直径的重心是树的重心。

然后是长度为 $5$ 时，也不可行，因为这时候为了保证树直径的重心不是树的重心我们只能把菊花连在点 ② 上，但是这是直径还是不唯一。

为了辅助理解，这里给出一张图片：

![](https://cdn.luogu.com.cn/upload/image_hosting/iqqwwkzz.png)

这就是我们希望的构造方法，乍一看没啥问题。

![](https://cdn.luogu.com.cn/upload/image_hosting/lccrx1dg.png)

容易发现任意一条从点 ⑤ 出发的红色的边都是它的直径！所以不行。

然后就是长度为 $7$ 的链了，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gqs9uw62.png)

啊哈，此时直径唯一只有点 ① 到点 ⑦！重心和直径的重心都为 $1$，即蓝点和红点！而且它们也互不相同！

然后就找到了一个满足题目全部要求的构造方法了好耶！

然后我们思考什么时候没有解，按这个方法构造是显然需要注意点数量必须大于 $8$ 否则的话会出现问题：当点数为 $7$ 时这就是一条链，显然直径的重心也是点 ④；当点数为 $8$ 时树的重心为点 ③ 和点 ④，不唯一，不满足条件。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+7;
ll read() //快读
{
	ll res=0,f=1;
	char c=getchar();
	while(!isdigit(c) && c!='-') c=getchar();
	if(c=='-') f=-1,c=getchar();
	while(isdigit(c)) res=(res<<1)+(res<<3)+c-48,c=getchar();
	return res*f;
}
int main()
{
	int n=read();
    if(n<=8) {puts("-1"); return 0;}  //n小于等于8时，无解
    printf("%d\n",n);   //注意题目要求答案前先输出一个n！比赛时我一时居然没注意到交了好几发
    for(int i=1;i<=6;i++) printf("%d %d\n",i,i+1); //先构造一跳长为7的链
    for(int i=8;i<=n;i++) printf("%d %d\n",3,i); //剩下的点全部连在点3上
	return 0;
}
```


---

## 作者：HYdroKomide (赞：1)

### 思路：
还是一道构造题。

首先手动构造可以发现，当 $n\le8$ 时，本题无解。其他情况均有解。

这里介绍两种方法，都各有缺点，所以在题解中穿插使用即可。

#### 法一：（赛时由于 SPJ 原因 UKE 了）

若 $n$ 为奇数，我们首先将它连成一条链。明显此时树的重心位于链的中点。这时，树的直径是此链，直径重心也位于链的中点。

将这个中点编号为 $1$。

然后，我们将 $1$ 号点一侧、链的尾部 $2$ 个节点去掉并直接与 $1$ 号点连边。

于是此树的直径为原来的链，直径重心位于这条链的中点，但是整棵树的重心依然位于 $1$ 号点。

当 $n$ 为偶数时将链尾部的三个结点与 $1$ 号节点直接连接即可。

#### 程序实现：
```cpp
h=n-n/2;
for(ri i=2;i<=h;i++)writexy(i-1,i);//构造树的左侧
writexy(1,h+1);
for(ri i=h+2;i<=h+h-3;i++)writexy(i-1,i);//构造树的右侧
for(ri i=h+h-2;i<=n;i++)writexy(1,i);//剩下的结点直接连到 1 号结点上
```

#### 法二：（赛时处理 $n$ 较大情况的备选做法）

考虑一个菊花图与一条链的结合。

菊花图中含有 $\lfloor\dfrac{n}{2}\rfloor$ 个结点，链中包含 $\lceil\dfrac{n}{2}\rceil$ 个结点。菊花图重心就是其中点，设其编号为 $1$，链的重心也是其中点，设为 $2$。

连接 $1$ 号结点和 $2$ 号结点。

很明显，当 $n$ 足够大时，这条链就是直径，$2$ 号结点是直径重心，但是菊花图的中点是整个树的重心。

而当 $n\lt 12$ 时，链的长度不够，树就可能存在多条直径。这也是此方法最大的缺陷，赛时直接爆〇。

#### 程序实现：

```cpp
l=n/4;
writexy(1,2);
for(ri i=3;i<=l+1;i++)writexy(i-1,i);//构造链的左侧
writexy(2,l+2);
for(ri i=l+3;i<=l+l;i++)writexy(i-1,i);//构造链的右侧
for(ri i=l+l+1;i<=n;i++)writexy(1,i);//构造菊花图
```
### 完整程序如下：
```cpp
#include<cstdio>
#include<algorithm>
#define ri register int
int n,l,h;
namespace FASTIO{
	inline int read(){
	    register int x=0,f=1;
		static char ch=getchar();
	    while(ch>'9'||ch<'0'){
			if(ch=='-')f=-1;
			ch=getchar();
		}
	    while(ch>='0'&&ch<='9'){
			x=(x<<3)+(x<<1)+(ch^48);
			ch=getchar();
		}
	    return x*f;
	}
	inline void write(int x){
	    if(x<0)putchar('-'),x=-x;
	    register int i=0;
	    static char s[10];
	    while(x||i==0)s[i++]=x%10+'0',x/=10;
	    while(i--)putchar(s[i]);
	    putchar(' ');
	}
	inline void writexy(int x,int y){
		write(x);
		write(y);
		putchar('\n');
	}
}
using namespace std;
using namespace FASTIO;//以上是头文件
int main(){
	n=read();
	if(n<=8){//判断是否无解
		write(-1);
		return 0;
	}
	write(n);//按照题意，先原封不动输出 n
	putchar('\n');
	h=n-n/2;//设定链左侧长度，相当于 ceil(n/2)
	for(ri i=2;i<=h;i++)writexy(i-1,i);
	writexy(1,h+1);
	for(ri i=h+2;i<=h+h-3;i++)writexy(i-1,i);
	for(ri i=h+h-2;i<=n;i++)writexy(1,i);//以上是构造
	return 0;
}
```
### THE END

---

## 作者：National_Studying (赞：0)

构造题。

然后读题后，随便搓几个数据，易发现 $n \le 8$ 其实是无解的。

要一颗独特的树，其直径，重心，直径的重心都要唯一，且树的重心还不是直径的重心。

根据前两个要求，易想到利用菊花图进行构造，若无第三个要求即可在任意一条链上增长。

实际上可以在其对面的链上增长，菊花图其余的链也是如此。

构造已毕。

---

## 作者：封禁用户 (赞：0)

### 题目大意：
构造一棵 $n$ 个结点的树，满足树的直径的重心不是树的重心和直径、重心、直径的重心全部唯一。

这是一道构造题，显然树的直径长度只能为奇数，树的直径的重心即为树的直径的中点。再考虑树的重心与树的直径的重心，先简单想像，现在的树只是一条长度为奇数的链，他的重心即为链的中点。现在考虑在这条链上加点，使得直径唯一且树的重心与树的直径的重心不同。首先，我们假定原来的链，为唯一的直径；链的中点，为唯一的树的直径的中点。那么，当前的树的重心即为链的中点，也就是树的直径的中点。再考虑将重心转移，最简单得，将新加的每一个点与树的直径的中点旁的固定一个点连边，已达到转移重心的效果。手动构造可以发现，当 $n\leq 8$ 时，本题无解。其他情况均有解。

Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin>>n;
    if (n<=8){
        cout<<"-1";
        return 0;
    }
    cout<<n<<"\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n";
    for (int i = 8; i <= n; i++)cout<<"3 "<<i<<endl;
    return 0;
}
```


---

## 作者：LHQing (赞：0)

### 题目分析：

由于直径重心唯一，我们先构造出一个长度为 $7$ 的直径。

![](https://cdn.luogu.com.cn/upload/image_hosting/9lvncy0d.png)

由于树的重心和链的重心不相同，然后以 $3$ 号结点为重心构造菊花图即可。这样重心是唯一的。

![](https://cdn.luogu.com.cn/upload/image_hosting/rdo1150z.png)

当然，由于最基本需要 $7$ 个点的直径，然后加上至少 $2$ 个点来确定重心。所以在 $n\le8$ 时输出 `-1`。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pd push_back
#define all(x) x.begin(),x.end()
#define Clear(x,n) for(int i=0;i<=n;i++)x[i]=0;
//==============================================================================
ll QP(ll x,ll y,ll mod){ll ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}
//==============================================================================
namespace IO{
	int readInt(){
		int x=0,y=0;char c=0;
		while(!isdigit(c))y|=c=='-',c=getchar();
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		return !y?x:-x;
	}
	void write(int x){if(!x)return;write(x/10);putchar(x%10);}
	void Output(int x){if(x<0)putchar('-'),x=-x;if(!x)putchar('0');else write(x);}
	void WL(int x){Output(x);putchar('\n');}
	void WS(int x){Output(x);putchar(' ');}
}
namespace Debug{
	void DeVec(vector<int> c){for(auto y:c)printf("%d ",y);puts("");}
	void DeNum(int x){printf("%d\n",x);}
}
//==============================================================================
const int N=1e5+10;
int n;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	//std::ios::sync_with_stdio(false);
    //std::cin.tie(nullptr);
    cin>>n;
    if(n<=8){puts("-1");return 0;}
    printf("%d\n",n);
    puts("1 2");puts("2 3");
    puts("3 4");puts("4 5");
    puts("5 6");puts("6 7");
    for(int i=8;i<=n;i++)
    	printf("%d %d\n",3,i);
    return 0;
}

```

---

## 作者：orz_z (赞：0)

### 题目大意

试构造一棵树，使得树的直径、树的重心、树的直径的重心唯一且树的重心与树的直径的重心不同。

### 解题思路

~~算是一眼的构造题吧。。。~~

显然树的直径长度只能为奇数，树的直径的重心即为树的直径的中点。

再考虑树的重心与树的直径的重心，先简单想像，现在的树只是一条长度为奇数的链，他的重心即为链的中点。

现在考虑在这条链上加点，使得直径唯一且树的重心与树的直径的重心不同。

首先，我们假定原来的链，为唯一的直径；链的中点，为唯一的树的直径的中点。

那么，当前的树的重心即为链的中点，也就是树的直径的中点。

再考虑将重心转移，最简单得，将新加的每一个点与树的直径的中点旁的固定一个点连边，已达到转移重心的效果。

手动构造可以发现，当 $n \leq 8$ 时，本题无解。其他情况均有解。

### CODE

```cpp
#include <bits/stdc++.h>

using namespace std;

int read()
{
    char c = getchar();
    int x = 0, f = 1;
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-')
            f = -1;
    for (; c >= '0' && c <= '9'; c = getchar())
        x = (x << 1) + (x << 3) + (c ^ 48);
    return x * f;
}

void write(int x)
{
    if (x < 0)
        x = -x, putchar('-');
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}

int n, k;

signed main()
{
    n = read();
    if (n < 9)
    {
        write(-1);
    }
    else
    {
        write(n);
        putchar('\n');
        for (register int i = 1; i <= 6; ++i)
        {
            write(i);
            putchar(' ');
            write(i + 1);
            putchar('\n');
        }
        for (register int i = 1; i <= n - 7; ++i)
        {
            write(3);
            putchar(' ');
            write(i + 7);
            putchar('\n');
        }
    }
    return 0;
}
```

---

## 作者：zhouyuhang (赞：0)

一道构造题。不妨令目标树重心为根。首先考虑让树的直径唯一。关于树的直径，有一个结论：设最深子树叶子节点的深度为 $w_1$，次深子树叶子节点的深度为 $w_2$，则有直径 $d=w_1+w_2$。因此，想让直径唯一，只需让最深和次深子树唯一。再考虑让树的重心唯一，我们可以让子树重量尽量平均。一个自然的想法是：让所有子树重量为 $1$，即菊花图。但这样构造出的树不符合直径唯一，因此可以做如下微调：删掉一些子树，并在一些子树的叶子节点上加点。具体应该怎么删加呢？首先，为了使最深次深子树分别唯一，可以考虑只在两个子树上加，且加的数量不同。但此时树的重心与直径重心相同（都是树根），为了满足题目条件，我们需要让直径的重心偏离一点（注意要使直径重心唯一，因此需要让直径的长度为偶数）。容易想到让一个子树深度加 $3$，一个子树深度加 $1$，并删掉 $4$ 个子树。这时，重量最大的子树重量为 $4$。而在 $n>8$ 时，$4<n-4$，这意味着 $4$ 是重量最大的子树的重量可以取到的最小值，即根就是重心。而当 $n\le 8$ 时，经试验，没有符合题目要求的构造。综上，本题的结论 $\&$ 构造如下：

- $n\le 8$ 时，没有满足题目要求的构造方案；
- $n>8$ 时，构造方案如下：
	构造一个 $n-5$ 叉树，其中两个子树分别是长度为 $3,1$ 的链。其余子树均只有一个叶子结点。

---

## 作者：_cmh (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P7903)

## $\texttt{Description}$

构造一棵树使得其直径、重心、直径的重心全部唯一且不同。

## $\texttt{Solution}$

个人认为是一道思路极其巧妙的构造题。

首先**直径**可以简单粗暴地理解为树上离得最远的两个点，**直径的重心**可以认为是直径的中点（虽然不准确），**重心**可以在这里认为是根节点。

所以思路就很明显了。构造一棵树，强制让其直径唯一。

首先判断无解：如果节点数小于 $8$，则树的直径的重心与树的重心一样。

我的思路是构造一棵树，设 $1$ 为根节点，则连接 $1-2,2-3,3-4,4-5$。然后再连接 $1-6,6-7$，剩下的节点都与 $1$ 相连即可。

这样可以强制确认直径为 $5-1-7$，树的重心为 $1$，树的直径的重心是 $2$。

## $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	scanf("%d",&n);
	if(n<=8){
		puts("-1");
		return 0;
	}
	printf("%d\n1 2\n2 3\n3 4\n4 5\n1 6\n6 7\n",n);
	for(int i=8;i<=n;i++)
		printf("1 %d\n",i);
	return 0;
}
```

感谢观看。

---


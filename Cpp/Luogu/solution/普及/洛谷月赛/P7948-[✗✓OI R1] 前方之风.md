# [✗✓OI R1] 前方之风

## 题目背景

>「不错的恶意。」  
> 女性呵呵笑道。  
>「但是，如果向我发出恶意，你可是会死哦？」

你不知道什么动作会被算作发出恶意，所以你决定做一道题来分散自己的注意力。

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和 $q$ 个询问，第 $i$ 个询问给出 $k_i$。对于每次询问，你需要进行以下操作：
1. 求出剩下的数的平均数 $\mathit{avg}$。
2. 将剩下的数中 $<\mathit{avg}-k_i$ 的数删去。
3. 重复以上两个步骤直到所有数都不会被删去。
4. 输出最后会剩下几个数。

**注意：询问之间是独立的，也就是说，不会真的删去那些数。**

## 说明/提示

**【样例解释】**

对于第一组样例，当 $k=0$ 时，显然只会留下 $99$。  
当 $k=6$ 时，删除数的步骤如下：
- 平均数为 $60\dfrac{1}{9}$，留下 $99,63,72,97,68$。
- 平均数为 $79.8$，留下 $99,97$。
- 平均数为 $98$，停止删除。

**【数据范围】**

对于 $100\%$ 的数据，满足 $1\leq n,q \le 10^5$，$1\le T \le 10$，$0 \le a_i,k_i \le 10^9$。

| subtask | 特殊数据范围 | 分数 |  时间限制
| :----------: | :----------: | :----------: |  :----------: |
| 1 | $n,q \le 200$ | 20 |   300ms 
| 2 | $n,q \le 2000$ | 30  | 300ms
| 3 |  | 50 | 800ms|

>「不错的恶意。」  
> 女性呵呵笑道。  
>「而且你运气很不错，如果放在以前，你早就死了。」

![](https://cdn.luogu.com.cn/upload/image_hosting/6icoj36r.png)

## 样例 #1

### 输入

```
5
9 9
19 99 63 39 72 46 97 38 68 
0 6 4 0 7 1 0 3 6 
6 8
88 62 48 50 8 47 
0 6 1 5 2 2 6 1 
6 5
33 3 54 17 26 64 
87 89 92 70 59 
18 19
71 52 77 38 12 34 82 14 57 39 91 7 56 86 35 68 38 14 
9 9 1 5 1 3 4 5 6 1 6 0 3 0 2 1 3 5 8 
10 15
4 77 78 76 5 19 98 94 77 81 
17 43 4 86 2 91 85 4 81 74 44 16 21 69 32 
```

### 输出

```
1 2 2 1 2 2 1 2 2
1 1 1 1 1 1 1 1
6 6 6 6 6
4 4 1 3 1 2 2 3 3 1 3 1 2 1 1 1 2 3 4
7 7 2 10 2 10 10 2 10 10 7 7 7 10 7
```

## 样例 #2

### 输入

```
1
5 1
20 0 0 0 0
5```

### 输出

```
5```

# 题解

## 作者：xzyg (赞：15)

###### 蒟蒻的第一篇题解

[题目传送门](https://www.luogu.com.cn/problem/P7948)

# Sol 0

暴力模拟+二分

然鹅赛后被 [hack](https://www.luogu.com.cn/discuss/380024) 掉了。

# Sol 1

排序+后缀和

每次删数必定是从小到大删，考虑对原数组进行排序。对于需判断的一个数 $a_p$，剩余数只能**大于等于** $a_p $。

可以维护一个后缀和，$O(1)$ 算出 当前 $avg-k_i$，用一个指针标记当前删数的位置，从而使每次询问优化到 $O(n)$。

复杂度 $O(qn)$，期望得分：50pts 

# Sol 1.5

依照上面的思路，设第 $i$ 个数及后面数的平均数为 $avg_i$，当前剩余最小数为 $a_i$。

若 $a_i$ 被 $avg_i-k$ 删掉，如果先不删它，那么它必定也会在下一轮中被 $avg_{i+1}-k$ 删掉。

若 $a_i$ 未被 $avg_i-k$ 删掉，那么即符合要求，停止删数。

可以发现，只需要将 $a_i$ 与 $avg_i-k$ 比较就能确定 $a_i$ 的删除情况。

将这个结论稍加扩展：对于排序后序列中的一个数 $a_i$，若 $a_i$ 之前的数都被删掉，那么只需要判断 $a_i$ 与 $avg_i-k$ 的大小关系，就可以确定 $a_i$ 的删除情况。

每次询问 $O(n)$ 扫一遍原数组，

复杂度 $O(qn)$，期望得分：50pts。

~~梅开二度~~

尽管在时间上并没有优化，但在算法简单了许多，只需循环上套个判断就可以了。

# Sol 2

考虑对多次查询进行优化。

显然，若 $k_i > k_{i+1}$，则 $avg-k_i < avg-k_{i+1}$。限制**变大**，从而满足条件的数**减少**、答案**减小**，可以利用这点进行优化。

其他大佬都是用的双指针，这里介绍另一种~~无脑的~~方法：将询问数组**从大到小** sort 一遍，当某个 $k$ 找到答案时，更小的 $k$ 接着**往右搜**，最后再按编号 sort 回来输出就可以了，这样就可以做到 $O(n)$ 处理。

复杂度：$O(n\log n+q\log q)$ 期望得分：100pts。

## AC代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

struct xmh{		//%%%xmh
	ll val,num,ans;
}k[100010];

ll n,q;
ll a[100010];
ll add[100010];
double avg[100010];

inline bool cmp1(xmh a,xmh b){
	return a.val > b.val;
}
inline bool cmp2(xmh a,xmh b){
	return a.num < b.num;
}

void init(){
	memset(a,0,sizeof(a));						//初始化 
	memset(add,0,sizeof(add));
	memset(avg,0,sizeof(avg));
	memset(k,0,sizeof(k));
	n = 0,q = 0;
	k[0].val = -1,k[0].num = -1,k[0].ans = -1;
	
   scanf("%lld%lld",&n,&q);
	for(ll i = 1; i <= n; ++i)
		scanf("%lld",&a[i]);
	for(ll i = 1; i <= q; ++i){
		scanf("%lld",&k[i].val);
		k[i].num = i;
	}
	
	sort(a+1,a+1+n);							//对原数组及查询数组排序 
	sort(k+1,k+1+q,cmp1);
	
	add[n] = a[n];
	for(ll i = n-1; i >= 1; --i){				//后缀和 
		add[i] += add[i+1] + a[i];
	}
	for(ll i = 1; i <= n; ++i){					//平均数 
		avg[i] = 1.0 * add[i] / (n-i+1);
	}
	return;
}

void print(){
	sort(k+1,k+1+q,cmp2);
	for(ll i = 1; i <= q; ++i)
		printf("%lld ",k[i].ans);
	putchar('\n');
}

void process(){
	ll p = 1,sum = n;
	for(ll i = 1; i <= n && p <= q;){
		while(a[i] < avg[i] - k[p].val)++i;		//比较 a[i] 与 avg[i] - k[p] 的关系 
		k[p].ans = n-i+1;						//满足条件即记录 ans 
		p++;									//多次查询优化 
	}
	print();
	return;
}

int main(){
	int T;
	scanf("%d",&T); 
	while(T--){
		init();
		process();
	}
	return 0;
}
```

upd:

2021.11.28 修改代码里的一些小错误(两个主函数？)

2021.12.17 将 Sol1.5 里的证明修正了一下

2021.12.18 又修了点排版错误淦

---

## 作者：AsunderSquall (赞：10)

# 前方之风
## 题意  
给出一个序列 $\{a_n\}$，和 $q$ 个 $k_i$。  
你需要对于每个 $k_i$，在这 $n$ 个数中重复以下步骤：  
- 求出剩下的数的平均数 $\textit{avg}$。  
- 将剩下的数中 $<\textit{avg}-k_i$ 的数删去。  
- 重复以上两个步骤直到所有数都不会被删去。  

对于每个 $k_i$，输出这样会剩下几个数。  
**注意：询问之间是独立的，也就是说，不会真的删去那些数。**  


## 题解  

如果对于某个 $k$，经过若干次操作后剩下的 $a$ 序列无法再用上述规则删数，我们称其为“**稳定**”。


### 假算  
我会二分！ 

毛估估一下，好像可以二分删去了几个数，然后 chk 可不可行。 

**hack：**  
```plain
1
5 1
20 0 0 0 0
5
```

实际上最开始 $5$ 个数就是稳定的了，但是如果你二分到了前 $3$ 个数，它是不稳定的，然后你会认为答案 $<3$，最终输出 $1$，实际上答案是 $5$。

### 算法一  
我会模拟！  

直接按照题意模拟，每次扫一遍求和，扫一遍标记一下哪些数被删掉了。  

时间复杂度 $O(qn^2)$。  

期望得分：20。  

思考：怎样构造数据让开除学生的轮数为 $O(n)$ 级别？

### 算法二  
我会排序和后缀和！  

注意到小的数一定比大的数更早删掉。  

从小到大排序，这样每次删掉的数一定是一个前缀！  

然后用后缀和可以快速求出剩下的数的和，从而快速计算 $\mathit(avg)$，然后移动一个指针表示这个位置及以后的数没有被删掉。  

时间复杂度 $O(qn)$。  

期望得分：50。  

### 算法三  
我会离线和观察性质！ 

假设我们已经把 $\{a_n\}$ 从小到大排序了。  

我们定义 $A_p$ 为序列 $a_p,a_{p+1},\cdots ,a_n$。

**性质 1：如果对于某个 $k$，如果 $A_{x}$ 不稳定，并且通过一次删除之后变成了 $A_{y}$，那么 $\forall p \in[x,y)$，$A_p$ 都不稳定。**  

> 证明：
> 考虑 $a_p<\operatorname{avg}(A_x)-k$，考虑到 $\operatorname{avg}(A_p)\ge \operatorname{avg}(A_x)$，那么必然有 $a_p< \operatorname{avg}(A_p)-k$


**性质 2：答案随 $k$ 的增加而单调不降**。  

> 证明：
> 考虑一个 $k_2 > k_1$，并且 $\{a_n\}$ 已经排好序。  
> 假设位置 $x$ 是最小的位置使得对于 $k_1$，$A_{x}$ 稳定。  
> 考虑对于 $k_2$ 我们目前处理到 $y<x$，并且将要删数。  
> 显然有 $\operatorname{avg}(A_x)>\operatorname{avg}(A_y)$。  
> 由于 $k_2>k_1$，有 $\operatorname{avg}(A_y)-k_2 < \operatorname{avg}(A_x)-k_1 \le a_x$，因此绝对不可能删到 $x$。
> 于是就证明了这个结论。


有了性质 1，我们就可以把删数的过程想象成一个一个删去，然后 check 行不行，直到稳定为止。   

加上这个性质 2，我们可以对 $k$ 排序然后双指针维护，判断行不行。  

复杂度 $O(q \log q + n\log n)$，瓶颈在排序。 

期望得分：100。 

实际上也可以预处理出可以使答案改变的那些 $k$，然后再在线二分，但是和离线差别不大且不必要。



---

## 作者：Shirayuki_Yu (赞：9)

~~这道题其实并没有那么难但我还是没有一遍过~~  
~~世界上不是没有简单题，而是缺少发现水题的眼睛。~~  
50暴力不用过多说明，直接上100分做法（你们肯定也是来看这个的）  
# 先上思路
### 1.数据范围
| subtask | 特殊数据范围 | 分数 | 时间限制 |
| :----------: | :----------: | :----------: | :----------: |
| 1 | $n,q\leqslant 200$ | 20 | 300ms |
| 2 | $n,q\leqslant 2000$ | 30 | 300ms |
| 3 | $n,q\leqslant 10^5$ | 50 | 800ms |
  
$10^5$ 的数据想做到的话当然需要  $O(nlog(n))$  的时间复杂的，果断考虑二分。
### 2.准备工作
首先要知道一件事，那就是  ~~注意到~~  数组的顺序和结果没有关系，因为我们每次只是查找小于   $avg - k[i]$   的数，所以这点一定要注意到。所以可以花掉  $nlog(n)$ 的时间来进行排序，然后：  
我们在排序后会得到一个数组，从头开始遍历，并算出此时的前缀平均值。这有什么用呢？我们再算出来  前缀平均值   $[i]-k[i]$   ，对它进行排序，注意此时不能只排序  前缀平均值  $[i]-k[i]$    而是带着其序号，因为最后输出的时候要按询问的顺序。
### 3.二分什么
在有序的 前缀平均值   $[i]-k[i]$    数组中，不难发现：  
因为我们每次要找的数小于  $avg - k[i]$   也就是上面预处理出来的数组，而且因为原数组排过序，所以每次需要删掉的数是连续且递增的。  
于是：二分排序后的原数组。  
### 4.怎么二分
充分利用STL： $upper\_bound$  。（其实是懒得手写）  

### 5.其它注意&优化

1. 一定要 memset！！！！！！  
2. 可以直接二分数组，也可以二分还没有被删除的数（反正是连续的）。效率不会差太多，最差也是  $log(n)$  。

### OK，整体思路就有了，上
# AC code


```cpp
#include <bits/stdc++.h>

using namespace std;

//敢不开long long？
long long a[100005];
long long sum = 0;
long long tmp[100005];

pair<long long, long long> delta[100005];

int main()
{
    int T;
    scanf("%lld", &T);
    long long n, q, k;
    while (T--)
    {
        scanf("%lld %lld", &n, &q);
        memset(delta, 0, sizeof(delta));
        memset(tmp, 0, sizeof(tmp));
        for (long long i = 1; i <= n; i++)
            scanf("%lld", &a[i]);
        sort(a + 1, a + 1 + n, greater<long long>());
        //在这个地方也可以写成sort(a + 1, a + 1 + n)然后再reverse(a + 1, a + 1 + n);
        //其实就是懒得倒序枚举
        sum = 0;//“前缀变量”
        for (long long i = 1; i <= n; i++)
        {
            sum += a[i];//这个地方优化了一下空间，不用开一整个数组记录前缀和
            delta[i].first = ceil(sum * 1.0 / i * 1.0) - a[i];
            //取一个ceil，因为平均数可能不是整数，而例如2<2.4也有2<3
            delta[i].second = i;//first 存差值，second存长度
        }
        sort(delta + 1, delta + 1 + n);//排序已经预处理好的差值
        long long maxn = 0;//更新每个差值的最优长度（保证正确性）
        for (long long i = 1; i <= n; i++)
        {
            maxn = max(maxn, delta[i].second);
            delta[i].second = maxn;//前面能取到更大值肯定选前面
        }
        for (long long i = 1; i <= n; i++)
        {
            tmp[i] = delta[i].first;//找出一个映射数组，方便在差值上二分（其实就是懒得写upper_bound的重载，效果一样）
        }
        sort(tmp + 1, tmp + 1 + n);//排序映射数组使之一一对应
        //二分找找找
        for (long long i = 1; i <= q; i++)
        {
            scanf("%lld", &k);
            long long pos = upper_bound(tmp + 1, tmp + 1 + n, k) - tmp - 1;
            printf("%lld ", delta[pos].second);
        }
        printf("\n");//记得换行
    }
    return 0;
}
```
## 求求看懂的点个赞啦QAQ


---

## 作者：漠寒 (赞：6)

## 分析

听同学说调了很久，主页也看到好几个帖子，就来看了看，受二分误导调了很久，但显然正确性有问题，考虑对同一组数据 $k$ 变化的影响。

显然，在删数时只会导致能删的更多，$k$ 变小也会使删的更多，所以先读入所有的 $k$，自大到小排序处理，这样答案单调递减，每个数就只用删一次就可以了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1000010
#define int long long
inline void read(int &res){
	res=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=(res<<1)+(res<<3)+c-48,c=getchar();
	res*=f;
}

int T; 

int a[N];
double b[N]; 
double avg[N]; 
int k[N]; 
int sum[N];
int ans[N];  
int n, q; 
struct node{
	int k,id;
}c[N];
bool cmp(node aa,node bb){
	return aa.k>bb.k;//结构体排序，因为要顺序输出答案
}
inline void clean(){
    memset(a, 0, sizeof(a));
    memset(b, 0, sizeof(b)); 
    memset(sum, 0, sizeof(sum)); 
    memset(k, 0, sizeof(k)); 
    memset(avg, 0, sizeof(avg)); 
    memset(ans, 0, sizeof(ans)); 
    return ; 
}

signed main(){
    read(T);
    while(T--){
        clean();
        read(n), read(q); 
        for(int i = 1; i <= n; i++)
            read(a[i]);
        for(int i = 1; i <= q; i++)
            read(c[i].k),c[i].id=i;
        sort(a + 1, a + n + 1); 
        for(int i = 1; i <= n; i++)
            b[i] = (double)a[i]; 
        for(int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + a[i]; 
        for(int i = 1; i <= n; i++)
            avg[i] = (double)(sum[n] - sum[i - 1]) / (double)(n - i + 1); 
        sort(c+1,c+q+1,cmp);
        int pos=1;//pos即下一个考虑要删除的数
        for(int i = 1; i <= q; i++){
        	ans[c[i].id]=0;
            while(pos<=n&&b[pos]<avg[pos]-c[i].k)pos++;//要删
			ans[c[i].id]=n-pos+1;
        }
        for(int i = 1; i <= q; i++)
            printf("%lld ", ans[i]);
        printf("\n"); 
    }
    return 0;
}
```


---

## 作者：yanshenshizu (赞：2)

# 前言:
首先看到这个题，没啥思路，想整一波纯贪心，结果全 *WA* ，再回首一想，好像部分有用，但要求全局最优解，于是就有了这篇题解 ~~死磕出奇迹~~  
# 题目描述:
>给出一个长度为 *n* 的序列 *a* 和 *q* 个询问，第 *i* 个询问给出 $k_i$.
>
>对于每次询问，你需要进行以下操作：
>求出剩下的数的平均数 *avg* 。
将剩下的数中 $<\mathit{avg}-k_i$ 的数删去。
>
>重复以上两个步骤直到所有数都不会被删去。
输出最后会剩下几个数。
>
>注意：询问之间是独立的，也就是说，不会真的删去那些数。  
  
   

# solution:
我们发现数组的顺序并不影响答案，所以我们对原数组排序 *sort*。  

又因为我们可以把删除操作转化为从零增加点这个操作。  
  
然后倒序枚举有序数组，计算前缀和 *sum*  ~~（也许要叫后缀和？）~~，平均值 *avg* ，因为是有序数组倒序枚举，所以我们当前枚举这位一定为所选的数中最小的，因而可以可以计算这个区间的 *min* 与 *avg* 的差.  
  
然后差值 *delta* 对应的下标即为长度，把他们塞到一个 *pair* 里，按差值进行排序。  

同时重新从前扫一遍，更新这个差值及小于这个差值的最大值 *max* 作为该差值的答案  
  
最后对于每个询问二分在差值数组 *delta* 中查找，输出对应的最大长度。  
  
AC！！code:
````cpp
#include<bits/stdc++.h>//认真思考，请勿抄袭
using namespace std;
#define int long long//不开long long 见祖宗
int t;
int a[100005];
typedef pair<int,int>p;
p delta[100005]; 
#define return qaq 
int sum=0;
int tmp[100005];
signed main()
{
    scanf("%lld",&t);
    int n,q,k;
    while(t--)
    {
        scanf("%lld%lld",&n,&q);
        memset(delta,0,sizeof delta);
        memset(tmp,0,sizeof tmp);
        //初始化数组
        for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
        sort(a+1,a+1+n);
        reverse(a+1,a+1+n);//排序原数组并倒序（其实就是懒得倒序枚举）
        
        
        sum=0;//初始前缀变量

        for(int i=1;i<=n;i++)
        {
            sum+=a[i];
            delta[i].first=ceil(sum*1.0/i*1.0)-a[i];//求差值
            delta[i].second=i;//first 存差值，second存长度
        }


        sort(delta+1,delta+1+n);//排列所有差值


        int maxn=0;//更新每个差值的最优长度（保证正确性）
        for(int i=1;i<=n;i++)
        {
            maxn=max(maxn,delta[i].second);//前面能取到更大值肯定选前面
            delta[i].second=maxn;
        }


        for(int i=1;i<=n;i++)
        {
            tmp[i]=delta[i].first;//找出一个映射数组，方便在差值上二分（其实就是懒得写upper_bound的重载，效果一样）
        }
        sort(tmp+1,tmp+1+n);//排序映射数组使之一一对应
        for(int i=1;i<=q;i++)
        {
            scanf("%lld",&k);
            int pos=upper_bound(tmp+1,tmp+1+n,k)-tmp-1;//在映射数组上二分查找出位置（也可不映射写成下面那样）
            //int pos=upper_bound(delta+1,delta+1+n,p(k,0))-delta-1;
            printf("%d ",delta[pos].second);//映射出结果并输出
        }
        printf("\n");//记得换行
    }
    return 0;
}
````

---

## 作者：听取MLE声一片 (赞：2)

### Update:改latex

赛时虽然比较容易想到正解，但是因一个假了的想法和一堆锅调了快一个半小时，还是自己太菜了/kk。

来看这道题，首先**询问之间是独立的**，也就是说没有修改，不用考虑带修的事情。对答案有影响的只有数字的大小，与**位置无关**，之后就能想到将这一堆数排序（从小到大），然后将询问离线。

我们约定把一个序列取平均数，一个数也删不掉，我们称之为**合法序列**。进一步读题可以发现，要求的答案就是一个**最长的合法序列**。正确性的话，找找规律就能发现，例子是样例第三组的第二个询问（其实是显然）。

我们来看已经是不降的原数列，最右边的数肯定包含在答案中，我们要求的显然就是能向左拓的数。注意：**一定不要从右向左扫**，**要从左往右扫**！因为如果取到一个相对靠右的数字不合法，但仍可能取到在它之前的一个数是合法的！参考样例第三组的第二个询问。

显然，在询问大小单调不递增的时候，答案肯定也是单调不递增的，就可以枚举询问的时候从左向右推，时间复杂度大约为 $\mathcal{O}(n+q)$。

综合一下，复杂度为 $\mathcal{O}(n\log_2n+q\log_2q+n+q)$，最大的数据跑了不到 `200ms`。

最后，一定要开 `long long`,还要注意边界条件！

具体参照代码。

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N=1e5+10;
int T,n,q,a[N];
struct point{
	int p,id;
}b[N],ans[N];
int cmp1(point a,point b){
	return a.p>b.p;
}
int cmp2(point a,point b){
	return a.id<b.id;
}
signed main()
{
	T=read();
	while(T--){
		n=read(),q=read();
		__int128 sum=0;
		a[0]=0;
		for(int i=1;i<=n;i++){
			a[i]=read();
			sum+=a[i];
		}
		sort(a+1,a+n+1);
		for(int i=1;i<=q;i++){
			b[i].p=read();
			b[i].id=i;
		}
		sort(b+1,b+q+1,cmp1);
		int l=1;
		__int128 num=0;
		for(int k=1;k<=q;k++){
			for(int i=l;i<=n+1;i++){
				if(i==n+1){
					l=n;
					break;
				}
				num+=a[i-1];
				if(a[i]>=(((sum-num)*1.0/(n-i+1))-b[k].p)){
					l=i;
					num-=a[i-1];
					break;
				}
			}
			ans[k].id=b[k].id;
			ans[k].p=(n-l+1);
		}
		sort(ans+1,ans+q+1,cmp2);
		for(int i=1;i<=q;i++)
			printf("%lld ",ans[i].p);
		printf("\n");
		for(int i=1;i<=n;i++)
			a[i]=0;
		for(int i=1;i<=q;i++)
			b[i].id=0,b[i].p=0,ans[i].id=0,ans[i].p=0;
	}
	return 0;
}
```

---

## 作者：fls233666 (赞：1)

首先可以发现，询问的次数很多，那么 $O(Tnq)$ 的暴力做法肯定是过不去的，因此，我们考虑如何预处理出所有可能的询问的答案。

考虑到 $1 \le k_i \le 10^9$，按 $k_i$ 一个一个处理显然不现实。但是我们注意到最终的答案必然是一个 $1$ 到 $n$ 之间的数，不妨考虑**按答案预处理**出每个答案对应的 $k_i$ 的范围，进而回答询问。

首先我们知道，**当 $k_i=0$ 时，一定是最大的 $a_i$ 被留下。** 于是我们考虑先把 $a_i$ 排序，从最大的 $a_i$ 开始依次处理出留下 $1,2,3, \dotsb ,n$ 个数对应的 $k_i$ 的值，记为 $f_i$。同时我们把询问的 $q$ 个 $k_i$ 也排序， 判断询问的 $k_i$ 是否在我们预处理出来的答案区间 $[f_{ans},f_{ans+1}]$ 内，对应回答所有的询问。时间复杂度是 $O(T(n \log (n)+q \log (q)))$。

然后你发现，你全部 $\color{red}\texttt{Wrong Answer}$ 了。

把预处理的 $f_i$ 全部打印出来后，**我们发现 $f_i$ 不具有单调性。**

举个例子，当询问的 $k_i=10$ 时，可能存在 $f_2=3,f_3=13,f_4=8,f_5=15$，我们回答了 $2$，但是 $f_4<k_i$ ，所以正确答案应该回答 $4$。

我们希望 $f_i$ 是**单调递增**的，那我们可以把不符合单调性的 $f_i$ 删掉。这时候我们就可以使用 **单调栈**。每次入栈时，把不符合单调性的 $f_i$ 出栈，最后看栈里留下的 $f_{i}$ 回答询问即可。

于是这题就做完了，由于单调栈是 $O(n)$ 的，所以总时间复杂度不变。下面放上代码。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define rgt register int
using namespace std;

inline ll rd(){
	char c=getchar();
	while(c<'0'||c>'9')
		c=getchar();
	ll inx=(c^48);
	c=getchar();
	while(c>='0'&&c<='9'){
		inx=inx*10+(c^48);
		c=getchar();
	}
	return inx;
}  //快速读入

inline void print(int dx){
	if(!dx){
		putchar('0');
		return;
	}
	int num=dx,siz=0,buf[22];
	while(num){
		siz++;
		buf[siz]=num%10;
		num/=10;
	}
	while(siz){
		putchar(buf[siz]+'0');
		siz--;
	}
}  //快速输出

const int mxn = 1e5+5;

ll a[mxn];
int q,n,top;
int ans[mxn];
double s,cnt,inx;

struct stuck{
	int ct;
	double ink;
}stk[mxn];  //单调栈

struct quiz{
	int nk;
	int id;
}qx[mxn];   //询问

inline bool cmp(struct quiz q1,struct quiz q2){
	return q1.nk<q2.nk;
}

int main(){
	int test=rd();
	while(test--){
		s=cnt=0;
		top=0;
		n=rd();
		q=rd();  
		for(rgt i=1;i<=n;i++)
			a[i]=rd();  //读入数据，初始化
            
		sort(a+1,a+1+n);  //排序a_i
		for(rgt inc,i=n;i>=1;i--){
			s+=a[i];
			cnt++;
			inx=s/cnt-a[i];  //预处理答案f_i
			inc=1;
			while(top&&stk[top].ink>inx){
				inc+=stk[top].ct;
				top--;
			}  //维护单调性
			top++;
			stk[top].ink=inx;
			stk[top].ct=inc;  //入栈
		}
        
		for(rgt i=1;i<=q;i++){
			qx[i].id=i;
			qx[i].nk=rd();
		}
		sort(qx+1,qx+1+q,cmp);  //读入询问，排序
        
		for(rgt cj=0,j=1,i=1;i<=q;i++){
			while(qx[i].nk>=stk[j].ink&&j<=top){
				cj+=stk[j].ct;
				j++;
			}  //寻找答案对应区间
			ans[qx[i].id]=cj;  //回答询问
		}
        
		for(rgt i=1;i<=q;i++){
			print(ans[i]);
			putchar(' ');
		}
		putchar('\n');  //输出答案
	}
	return 0;
}
```


---

## 作者：青鸟_Blue_Bird (赞：1)

## 一种 $O(N)$ 做法

#### 1、观察性质

首先，观察题目可以知道，这个删除数字的过程跟下标没有关系，所以排序是不会影响结果和过程的。

排好序后，可以发现，如果我们从 $a_n$ 向 $a_1$ 求平均值，那么平均值是单调递减的。简单说明： $\tfrac {a_n}{1} \geqslant \tfrac{ (a_n + a_{n -1})}{2}$ 以此类推

接着，利用这个性质来考虑一下答案会在何时出现：

![666](https://cdn.luogu.com.cn/upload/image_hosting/vajfxisw.png)

因此，当后 $x$ 个数的均值向前减掉 $k$，而这 $x$ 个数中没有一个能被删除掉，那么就是最终情况。

从这我们也发现一个答案的性质：答案情况一定是从 $a_x$ 至 $a_n$。而不会是中间的某一段。  

#### 2、第一种思路



考虑二分。（虽然它被卡了） 首先预处理出前缀和，方便迅速求均值，接着对于每个 $k$, 二分答案。如果当前数字会被删掉，就向后跳，然后将此删掉，直到合法为止。

但是，显然，这个时间复杂度是错的，在某些情况会被卡。

#### 3、正解

如何删掉 $log$? 考虑观察 $k$ 的性质。由平均值的单调性可以知道，随着 $k$ 的增大， 答案情况的 $x$ 就越接近 $1$。 参考一下图

![666](https://cdn.luogu.com.cn/upload/image_hosting/uyhd5wqp.png)

因此，将 $k$ 从大到小排序，用指针对着 $a_n$ 从前往后找，其答案也满足单调性。如果当前 $a_x$ 不合法，那么我们就将其抛弃，$l++$, 一直到合法为止。而之后的 $k_i$ 直接从当前的 $l$ 开始，就能 $O(N)$ 处理完这个问题了。 


细节看代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100010
#define int long long

template <class T>
inline void read(T& a){
    T x = 0, s = 1;
    char c = getchar();
    while(!isdigit(c)){
        if(c == '-') s = -1;
        c = getchar(); 
    }
    while(isdigit(c)){
        x = x * 10 + (c ^ '0');
        c = getchar(); 
    }
    a = x * s;
    return ; 
}

int T; 

int a[N];
double b[N]; 
int k[N]; 
int sum[N];
int ans[N];  
int s[N];  
int n, q; 

inline void clean(){
    memset(a, 0, sizeof(a));
    memset(b, 0, sizeof(b)); 
    memset(sum, 0, sizeof(sum)); 
    memset(k, 0, sizeof(k)); 
	memset(s, 0, sizeof(s)); 
    memset(ans, 0, sizeof(ans)); 
    return ; 
}

bool cmp(int a, int b){
	return k[a] > k[b];  
}

signed main(){
//  freopen("hh.txt", "r", stdin); 
    read(T);
    while(T--){
        clean();   // 清空不能忘! 
        read(n), read(q); 
        for(int i = 1; i <= n; i++)
            read(a[i]);
        for(int i = 1; i <= q; i++)
            read(k[i]), s[i] = i; 
        sort(a + 1, a + n + 1); 
        sort(s + 1, s + q + 1, cmp);     // 对下标进行排序，而不是排序 k， 方便后续读取答案 (为了方便可以用 map, 不过会 T)
        for(int i = 1; i <= n; i++)
            b[i] = (double)a[i];    // 转成 double 来比较，不然会有误差 
        for(int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + a[i];    // 前缀和 
        
        int id = 1;
        int l = 1; 
        while(id <= q && l <= n){
        	if(b[l] < (double)(sum[n] - sum[l - 1]) / (double)(n - l + 1) - k[s[id]]) l++;   // 不满足，那么我们直接把他抛弃 
        	else ans[s[id++]] = n - l + 1;    // 否则就是答案 
		}
        
        for(int i = 1; i <= q; i++)
            printf("%lld ", ans[i]);
        printf("\n"); 
    }
    return 0;
}
```



---

## 作者：BaCO3 (赞：0)

## 题目大意
对于一个序列重复如下操作，直到所有数都不会被删去：

1.求出剩下的数的平均数 $avg$。

2.将剩下的数中 $<avg-k_i$ 的数删去。

最后输出会剩下几个数。

## 分析
显然数列中的数应该是从小往大删去的，所以我们可以先给数组排个序。

设前一次操作删至第 $i-1$ 位， 显然若 $a_i-k \ge$ 剩下的数的平均值时，操作不会继续进行。

所以对于每一个 $k_i$，我们可以遍历一遍数组去求第一个满足以上条件的 $i$，求平均数可以用前缀和优化，总时间复杂度为 $O(Tqn)$，这样可以拿到 $60$ 分。

考虑继续优化。

我们发现当 $k_i$ 的值越大时，最终剩下的数就会越多，所以我们可以将询问离线下来，按 $k_i$ 的值从大至小排序，用两个指针分别维护目前处理到第几个询问，和目前处理到数列中第几个数。这样我们就成功把统计答案的复杂度优化成了 $O(n+q)$，总时间复杂度为 $O(q\log q+n\log n)$。

最后别忘了按原来的顺序输出答案。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAX=1e5+10;
int t,n,q,a[MAX],sum[MAX];
struct question{
	int num,ans,id;
}k[MAX];

bool cmp(question a,question b){
	return a.num>b.num; //将询问离线处理
}

bool cmp2(question a,question b){
	return a.id<b.id;
}

void init(){
	memset(sum,0,sizeof(sum));
	memset(k,0,sizeof(k));
}

int main(){
	scanf("%d",&t);
	while(t--){
		init(); //多测别忘了初始化
		scanf("%lld%lld",&n,&q);
		for(int i=1;i<=n;i++){
			scanf("%lld",&a[i]); //前缀和
		}
		sort(a+1,a+n+1);
		for(int i=1;i<=n;i++){
			sum[i]=sum[i-1]+a[i];
		}
		for(int i=1;i<=q;i++){
			scanf("%lld",&k[i].num);
			k[i].id=i;
		}
		sort(k+1,k+q+1,cmp);
		int cnt1=1,cnt2=1;
		while(cnt1<=n&&cnt2<=q){
			if(a[cnt1]<(double)(sum[n]-sum[cnt1-1])/(n-cnt1+1)-k[cnt2].num) cnt1++;
			else k[cnt2++].ans=n-cnt1+1;
		} //双指针遍历
		sort(k+1,k+q+1,cmp2); //按照原顺序输出
		for(int i=1;i<=q;i++){
			printf("%lld ",k[i].ans);
		}
		printf("\n");
	}

	return 0;
}
```

---


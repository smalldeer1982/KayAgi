# 做不完的作业

## 题目背景

高中的任务是非常艰巨的，要学习十门功课（浙江要学技术）。导致作业超级加倍，这一点在暑假就已经体现出来了。

作业的总量是一定的，但不同作业下发的时间是不一定的，导致每天都要花不同的时间应付作业。此时，如何保证睡眠是一个需要仔细考虑的问题。

## 题目描述

**提示：如果你对题目内容有疑问，可以配合样例更好地阅读。**

有 $n$ 个任务，第 $i$ 个任务需要 $t_i$ 的时间。Eric 要在若干天内**依次**完成这些任务。Eric 是一个专注的人，所以完成每个任务的时间**必须连续**。

一天有 $x$ 的时间。由于 Eric 需要睡觉，所以 Eric 不能利用所有的时间。具体地：

- Eric 每天**必须睡觉**；
- Eric 每天的睡觉的时间是连续的，且睡觉时间结束后，第二天恰好开始；
- Eric **前 $\boldsymbol i$ 天**的睡觉时间**总和**不能少于 $r\cdot x\cdot i$ 的时间。$r$ 是一个给定的实数，$i$ 是一个正整数。

Eric 想问你，至少需要多少天才能完成任务。

## 说明/提示

#### 样例 1 解释

下面是一种可能的方案：

Eric 先在第一天做任务 1，总共消耗 $1$ 的时间，用 $4$ 时间睡觉，满足至少要 $5\times \dfrac 1 3=\dfrac 5 3$ 的时间睡觉的要求。

Eric 再在第二天加班加点，完成剩下的任务，有 $1$ 的时间睡觉。两天睡觉总量为 $5\ge 10\times \dfrac 1 3=\dfrac {10} 3$，也是满足要求的。

#### 样例 2 解释

Eric 试图在第一天完成任务 1，但假如要做就会熬夜，觉就不够睡。所以 Eric 第一天只能睡大觉。Eric 在第二天完成任务 1 就没有问题。

同时请注意，即使睡觉时间满足了要求，Eric 也不能在第二天就完成任务 2，因为 Eric 必须睡觉。所以 Eric 先睡到第三天，然后完成任务 2。可以证明不存在方案小于三天。

同时注意数据**不保证** $\gcd(p,q)=1$。

#### 样例 3 解释

显然一天只能干一件活，所以要 $10$ 天。

#### 样例 4 解释

该样例满足子任务 3 的限制条件。

#### 样例 5 解释

该样例满足子任务 5 的限制条件。

### 数据规模与约定

**本题捆绑测试**。对于所有数据，保证 $1\le n\le 10^5$，$1\le t_i<x\le 10^6$，$1\le p<q\le 10^6$。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline

\bf 子任务 & \bf 分值 & n\le & \bf特殊性质
\\
\hline
1 & 10 & 3 & /\\\hline
2 & 20 & 10^3 & \bf A \\\hline
3 & 20 & / & \bf A\\\hline
4 & 20 & / & \bf B\\\hline
5 & 30 & / & /\\\hline
\end{array}
$$

特殊性质 $\bf A$：$\forall i,\ \dfrac{t_i}{x}+\dfrac{p}{q}\le 1$。

特殊性质 $\bf B$：$n\times q\le 10^6$。

为了减少评测量，本题开启子任务依赖。具体地，当且仅当前四个子任务全部通过时，子任务 5 才计分，否则子任务 5 计 $0$ 分。

## 样例 #1

### 输入

```
3 5 1 3
1 2 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 10 4 10
9 1```

### 输出

```
3```

## 样例 #3

### 输入

```
10 2 1 2
1 1 1 1 1 1 1 1 1 1```

### 输出

```
10```

## 样例 #4

### 输入

```
见下发文件 task/task4.in```

### 输出

```
见下发文件 task/task4.ans```

## 样例 #5

### 输入

```
见下发文件 task/task5.in```

### 输出

```
见下发文件 task/task5.ans```

# 题解

## 作者：5ab_juruo (赞：23)

比较简单的贪心。

你以为你写的是暴力，其实和正解没什么差距（

### subtask1~4

性质 A，B 都保证了答案的天数不会太多，所以有个 naive 的想法：直接贪心插入，不能插入了就睡。

然后就能过 70pts 了。

归纳证明。假设已经求出前 $i-1$ 个任务的答案，若再插入一个有更优方案，则在前 $i-1$ 个的时候就应该插入了，矛盾。

### subtask5

发现，当整天睡觉的时候，70pts 的做法会 TLE。考虑优化这一过程。

每次插入一个的时候，如果当天不够了，就去计算要睡多少天才够。

可以做到线性。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mem(x) memset(x,0,sizeof(x))
#define printYes puts("Yes")
#define printYES puts("YES")
#define printNo puts("No")
#define printNO puts("NO")
#define endl "\n"
#define lowbit(x) (x&(-x))

const ll inf=1000000000000000000; 
//const ll mod=998244353;
//const ll mod=1000000007;
#define int ll
const int N=500005;
ll n,m,p; 
int a[N];

inline int read()
{
    int F=1,ANS=0;
	char C=getchar();
    while (C<'0'||C>'9')
	{
		if (C=='-') F=-1;
		C=getchar();
	}
    while (C>='0'&&C<='9')
	{
		ANS=ANS*10+C-'0';
		C=getchar();
	}
    return F*ANS;
}
inline char readchar()
{
	char C=getchar();
    while (C<33||C>126) C=getchar();
    return C;
}
inline int raed(){return read();}

void work()
{
	//n=read();
	//for (int i=1;i<=n;i++) a[i]=read();
}

signed main()
{
	n=read(),m=read(),p=read();
	ll q = read();
	for (int j=1;j<=n;j++) a[j]=read();
	int ans1=0,ans2=0;
	int tot=1,sl=0;
	for (int j=1;;j++)
	{
		if (0<m*p*j-(m-a[tot]+sl)*q)
		{
			int i=(m*p*j-(m-a[tot]+sl)*q+(m*(q-p))-1)/(m*(q-p));
			j+=i,sl+=i*m;
		}
		int x=m;
		while (1)
		{
			if (tot==n+1) break;
			if (x<=a[tot]) break;
			if ((x-a[tot]+sl)*q<m*p*j) break;
			x-=a[tot],tot++;
		}
		sl+=x;
		if (tot==n+1)
		{
			ans1=j;
			break;
		}
	}
	cout << ans1;
	return 0;
}
```

再讲一种比较好写的做法。

可以发现，在可以的前提下，如果每次将任务往后挪，睡觉时间会发挥更大的价值，是不劣的。

所以，任何一个答案都可以转化成：前几天一直睡大觉，到最后加班加点赶工。

倒序插入任务，每次完成一天就更新要睡觉的天数就可以了。

```cpp
/* name: c
 * author: 5ab
 * created at: 22-07-27 07:59
 */
#include <iostream>
using namespace std;

typedef long long ll;
const int max_n = 100000;

int a[max_n];

inline void chmax(ll& a, ll b) { if (a < b) a = b; }
inline ll cdiv(ll a, ll b) { return (a + b - 1) / b; }
signed main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	
	int n, x, p, q;
	ll sm = 0;
	
	cin >> n >> x >> p >> q;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
		sm += a[i];
	}
	
	ll ans = 0, cnt = 0, csm;
	for (int i = n - 1; i >= 0; )
	{
		chmax(ans, cnt + cdiv(sm * q, 1ll * x * (q - p)));
		// cerr << sm * q << " " << 1ll * x * (q - p) << endl;
		
		csm = 0;
		while (i >= 0 && a[i] + csm < x)
			csm += a[i--];
		sm -= csm, cnt++;
	}
	
	cout << ans << endl;
	
	return 0;
}
```



---

## 作者：ArcherHavetoLearnWhk (赞：12)

$update\ 2022.10.26:$ 修改表述，更正了式子中 $l$ 和 $i$ 弄混（打错）的错误。 

感觉这道题还是有些难的，对着别的题解调了好久，现在我用我~~通俗易懂~~的语言来描述一下该题思路以帮助更多同学。
## 思路：
试着按题意进行模拟 **（实际上题目是贪心，但不是精髓）**。

遇到一个任务（作业）时，如果当天做了它可以满足题目要求，就把它做了，如果不行则这天剩下的时间就去睡觉。这样可以尽量早的完成任务 ~~（至于为什么很好想，感兴趣自行尝试证明或看其它题解）~~ ，写起来也不难。

但是我们发现：如果直接进行模拟，**时间复杂度是与答案相关的**，而这样会TLE两个点。（[记录](https://www.luogu.com.cn/record/86088879)）

而当有连续几天都是整天睡觉时，我们可以 $O(1)$ 计算连续睡的天数。详细看下下面的代码，while 循环 $n$（依题意）次，每次循环中时间复杂度都是 $O(1)$，总体来说时间复杂度就是 $O(n)$，可以通过。

至于连续睡的天数计算方法，我们发现要使得睡 $l$ 天觉以后能够再次去做作业，$l$ 需要满足这个不等式（由于字母表示太不直观了，就用文字表述）：

**一天时间 $-$ 将要完成的作业时间 $+$ 当前总睡觉时间 $+$ $l$ 天整天睡觉的总时长 $\geq$ 当前天的 $l$ 天后的要求总睡觉时长**

化成代数式，结合下方代码里的变量：

$x-w+sum+l\cdot x\geq (i+l)\cdot x\cdot \dfrac{p}{q}$

化简后找到 $l$ 的范围：

$l\geq \dfrac{q \cdot (sum+x-w)-p\cdot i\cdot x}{x\cdot(p-q)}$

当 $l=$ 右边那一坨式子时 $l$ 最小，所以 $l$ 就是 $\geq$ 号右边的那坨式子。

有一点比较坑的，就是不要把 $\dfrac{p}{q}$ 算成浮点型，因为浮点型会丢精度，有时算向下/上取整时会出错，所以**要尽量避免浮点数运算**。

我觉得这题精髓其实在数学计算优化复杂度。另外**比赛时要会分析复杂度**，想想用什么方法才能过，不要写了半天还是过不了最后还要重构。（我就是）
## 成品代码（注释比较详尽）：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,p,q;
inline long long read() {
	long long rr=0,ff=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-'){ff=-1;}ch=getchar();}
	while(ch>='0'&&ch<='9'){rr=(rr<<1)+(rr<<3)+(ch-'0'),ch=getchar();}
	return rr*ff;
}//快读
inline void write(long long xx){
	if(xx<0){
		putchar('-');
		xx=-xx;
	}
	if(xx>9)write(xx/10);
	putchar(xx%10+'0');
	return;
}//快写
int main(){
    n=read(),x=read(),p=read(),q=read();
	long long i=1;//第i天
	long long sum=0;//总睡觉时间
	long long t=0;//当天作业时间
	while(n--){//共n个作业
		long long w;//作业
		w=read();
		if((x-t-w+sum)*q>=i*p*x&&x-t>w)//如果作业做了能满足要求
			t+=w;//第i天作业时间加上w
		else{//不满足要求
			sum+=x-t;//先睡觉
			i++;//天数+1
			long long l=ceil((q*(sum+x-w)-p*i*x)*1.0/(x*p-x*q));//睡几天能满足要求
			if(l>0){//如果需要一些时候整天睡觉
                sum+=x*l;//更新
                i+=l;
			}
		    t=w;//第i+l+1天的作业时间为当前
		}
	}
	write(i);
    return 0;
}
```
逝当压缩后的无注释版本：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,p,q,i=1,sum,t,w;
int main(){
    cin>>n>>x>>p>>q;
	while(n--){
		cin>>w;
		if((x-t-w+sum)*q>=i*p*x&&x-t>w)t+=w;
		else{
			sum+=x-t;
			i++;
			long long l=ceil((q*(sum+x-w)-p*i*x)*1.0/(x*p-x*q));
			if(l>0){
                sum+=x*l;
                i+=l;
			}
		    t=w;
		}
	}
	cout<<i;
}
```
（完）

---

## 作者：heaksicn (赞：7)

## 1 题意

有 $n$ 个任务，每个有时间 $t_i$。

Eric 前 $i$ 天要睡 $r\times x\times i$ 个小时，每天至少睡 $1$ 小时，每天只能在做完所做的任务后睡觉。

问至少需要多少天才能完成任务。

## 2 思路

首先考虑最直观地暴力。

枚举每一天，对于第 $i$ 天，先求出今天要睡多少个小时才能满足 $r\times x\times i$ 的要求。

然后，判断剩下的时间是否够完成某些任务。如果可以完成就完成，不能做就睡觉。

然后发现，这个方法的复杂度至多为 $O(nq)$。

那么这样暴力可以有多少分呢？

首先对于 subtask 1，保证 $n\leq 3$，那么答案显然较小。

对于特殊性质 A,我们可以将式子变为 $t_i\leq x\times(1-\frac{p}{q})$。

这个式子意思就是说，每天至少可以完成一个任务。那么 $ans\leq n$，显然也可以跑过。

对于特殊性质 B,保证 $nq\leq 10^6$，也能跑过。

那么就可以拿到 70pts 的好成绩。

那么我们可以考虑优化这个暴力。

首先发现，每次完成某些任务前都会有几天会全部睡觉。

那么我们可以 $O(1)$ 求出完成这个任务需要先睡多少天，再完成任务即可。

时间复杂度 $O(n)$。

## 3 code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x){
	if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int n,x,p,q;
int a[100001];
signed main(){
//	freopen("task.in","r",stdin);
//	freopen("task.out","w",stdout);
	n=read(),x=read(),p=read(),q=read();
	int sum=0; //总共时间
	for(int i=1;i<=n;i++) a[i]=read(),sum+=a[i];
	int ans=0;
	int nw=0;//
	int i=n;//注意倒序枚举
	while(i){
		ans=max(ans,nw+(sum*q+x*(q-p)-1)/(x*(q-p)));
		int cnt=0;
		while(i&&cnt<x-a[i]) cnt+=a[i],i--;
		sum-=cnt;
		nw++;
	}
	write(ans);
	return 0;
}
```


---

## 作者：Little09 (赞：6)

我是验题人。我和出题人的两种贪心其实不大一样，然后有挺多人反应看不懂我的代码，原因是 5ab 把我的巨丑代码挂到题解上去了。

首先说一说贪心。我的贪心是：按顺序考虑每个任务，每个任务安排在其最早能放的那一天。

有人可能有疑惑：有可能第 $x$ 天原本安排的其中一个任务 $y$，将其替换为睡觉，将任务 $y$ 往后推，会不会更优。事实上是不会的：如果你把 $y$ 推到了 $x+1$ 天，那么你有可能会增多一天消耗，但是对于第 $x+1$ 天及以后的天，你没有增加任何的前缀睡觉时间（因为做任务的总量恒定，睡觉量也恒定）。所以不可能减少一天。

然后怎么写这个贪心。直接模拟？很遗憾，被毒瘤的出题人卡掉了，你会 TLE 几个点。因为直接模拟你需要模拟每一天的情况，这样的复杂度和总天数相关。所以我们需要加一个小优化：对于一个任务，如果你需要先睡好几天才能完成它，那么计算出睡的天数，而不一天一天地模拟。

容易发现这样的复杂度是线性的。

在计算天数的时候，可能需要稍微推一下式子，接下来是一些简单的推导。

**以下用 $m$ 表示一天的总时间，与题面不同**。假设当前面对的是第 $tot$ 个任务，需要 $a_{tot}$ 的时间，目前总睡觉时间是 $sl$，现在是第 $j$ 天。那么当 $m-a_{tot}+sl<m⋅j⋅\dfrac{p}{q}$ 的时候，这一天内肯定完成不了任务。我们计算需要连续睡几天觉，假设要再睡 $i$ 天，那么有 $m-a_{tot}+sl+i⋅m\ge m⋅(i+j)⋅\dfrac{p}{q}$，简单移项可得：$i\ge \dfrac{j⋅m⋅p-q⋅(m-a_{tot}+sl)}{m⋅(q-p)}$，取最小的 $i$ 即可。

稍微修缮了一下的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1000005;
ll n,m,p,q; 
ll a[N];

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m >> p >> q;
	for (int i=1;i<=n;i++) cin >> a[i];
	ll tot=1,sl=0;
	for (ll j=1;;j++)
	{
		if ((m-a[tot]+sl)*q<m*p*j)
		{
			ll i=(m*p*j-(m-a[tot]+sl)*q+(m*(q-p))-1)/(m*(q-p));
			j+=i,sl+=i*m;
		}
		ll x=m;
		while (1)
		{
			if (tot==n+1) break;
			if (x<=a[tot]) break;
			if ((x-a[tot]+sl)*q<m*p*j) break;
			x-=a[tot],tot++;
		}
		sl+=x;
		if (tot==n+1)
		{
			cout << j;
			return 0;
		}
	}
	return 0;
}
```


---

## 作者：snail2956 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P8508)

## updated

**2022.10.16** : 修正了几处笔误

## 思路  

---

### Subtask 1~4

考虑贪心。

**证明**：假设已求出前 $i-1$ 个任务的答案，若再插入一个有更优方案，则在前 $i-1$ 个时就应插入，矛盾。

**具体实现**：枚举天数。对于每一天，判断如果做下一个任务，是否满足题目条件。重复这个过程，可以做的任务则做，否则直接睡大觉。

---

### Subtask 5

优化贪心。

容易发现，如果太多天都在睡大觉，上述做法会炸掉。所以，对于每次无法做任务时，算出接下来需要睡几天大觉，可以做到将近 $O(n)$。

---

### 更神仙的做法

可以发现，前面一直睡大觉，到最后加班加点做任务，是不劣的。所以可以倒序插入任务，再算出前面需要睡几天大觉即可。

具体实现可参照验题人的代码。（反正我是看不懂

---

## $Code$
```cpp
#include<cstdio>

#define int long long

int n,x,p,q,a,day=1,sleep=0,nw;

inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
void write(int x){
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

signed main(){
	n=read();x=read();p=read();q=read();
	nw=x;
	while(n--){
		a=read();
		if(nw-a<1||(sleep+(nw-a))*q<day*x*p) sleep+=nw,day++,nw=x;
		int k=day*x*p-(sleep+(nw-a))*q;
		if(k>0) sleep+=k/(x*q-x*p)*nw,day+=k/(x*q-x*p);
		while(nw-a<1||(sleep+(nw-a))*q<day*x*p) sleep+=nw,day++,nw=x;
		nw-=a;
	}
	write(day);
	//qwq
	return 0;
}
```

---

## 作者：zhenjianuo2025 (赞：1)

### Solve

贪心。

依次考虑每个任务，如果完成该任务之后仍可以满足睡觉时间的要求，就完成该任务。如果无法完成该任务，睡觉直到可以完成。

很快就可以写出一个直接模拟的代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
#define int long long 
int n, x, p, q, t[100010];
signed main() {
	cin >> n >> x >> p >> q;
	for (int i = 1; i <= n; i++) cin >> t[i];
	int sle = 0, j = 0, i = 1, w = 0;
	while (j < n) {
		w = 0;
		while (j < n && (w + t[j + 1] < x) && (sle + x - w - t[j + 1]) * q >= p * x * i) {
			w += t[j + 1];
			j++;
		}
		i++;
		sle += x - w;
	}
	cout << i - 1;
	return 0;
}
```

以上代码中 $x$ 表示一天的时间，$i$ 表示当前所在的天数，$j$ 表示**已经完成**的任务个数，$\text{sle}$ 表示前 $i-1$ 天的睡眠时间，$w$ 表示第 $i$ 天的睡眠时间。

但是以上代码是可以被卡掉的，因为以上代码的时间复杂度和答案相关，有可能会连续多天一直休息。我们需要快速求出可以**完成**第 $j+1$ 个任务的所对应的 $i$。

设下一次可以完成任务的天数为 $i\text{'}$，前 $i\text{'}-1$ 天的睡眠时间为 $\text{sle'}$，则有 

$$
(\text{sle'}+x-w-t_{j+1}) \times q \ge p \times x \times i\text{'}
$$

其中 $i\text{'}-i$ 非负。

再设 $i\text{'}-i=k$，有 $\text{sle'}=\text{sle}+x\times k$，代入，移项，化简，得

$$
q \times \text{sle} - p \times x \times i - q \times t_{j+1}+q\times x) \ge x \times (p - q)
$$

则 

$$
k=\left \lfloor \dfrac{q \times \text{sle} - p \times x \times i - q \times t_{j+1}+q\times x)}{x \times (p - q)}\right \rfloor
$$

因为要求 $k$ 非负，要将 $k$ 和 $0$ 取 $\max$。

最后注意如果将 $\dfrac{p}{q}$ 化成小数进行计算是会被卡精度的（我就被卡成 70pts 了）

### Code


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm> 
using namespace std;
#define int long long
int n, x, p, q, t[100010]; 
signed main() {
    cin >> n >> x >> p >> q;
    int gcd = __gcd(p, q);
    p /= gcd;
    q /= gcd;
    for (int i = 1; i <= n; i++) cin >> t[i];
    long double r = p * 1.0 / q;
    int sle = 0, j = 0, i = 1, w = 0;
    while (j < n) {
        w = 0;
        while (j < n && (w + t[j + 1] < x) && (sle + x - w - t[j + 1]) >= r * x * i) {
            w += t[j + 1];
            j++;
        }
        i++;
        sle += x - w;
        // 计算下一个可行的
        int k = ceil((q * sle - p * x * i - q * t[j + 1] + q * x) * 1.0 / (x * (p - q) * 1.0));
        k = max(k, 0ll);
        i += k;
        sle += x * k;
    }
    cout << i - 1;
    return 0;
}
```

---

## 作者：Ferm_Tawn (赞：1)

## 题意描述
有 $n$ 个任务，第 $i$ 个任务需要 $t_i$ 的时间。Eric 要在若干天内**依次**完成这些任务。Eric 是一个专注的人，所以完成每个任务的时间**必须连续**。

一天有 $x$ 的时间。由于 Eric 需要睡觉，所以 Eric 不能利用所有的时间。具体地：

- Eric 每天**必须睡觉**；
- Eric 每天的睡觉的时间是连续的，且睡觉时间结束后，第二天恰好开始；
- Eric **前 $\boldsymbol i$ 天**的睡觉时间**总和**不能少于 $r\cdot x\cdot i$ 的时间。$r$ 是一个给定的实数，$i$ 是一个正整数。

Eric 想问你，至少需要多少天才能完成任务。

## 70 分

- 用 $t$ 枚举天数。
- 定义 $pos$ 记录当前做到第几项任务。
- 定义 $work$ , $coun$ 记录做作业的时间。

这样做可得 70 分 (~~谁都会做吧~~)。

小坑点：每天必须睡觉！

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
double r , work , coun;
double last = 0;
int a[100005];
int n , x , p , q , pos = 1;
int main(){
	cin >> n >> x >> p >> q;
	r = ((p * 1.0) / (q * 1.0)) * (x * 1.0);
	for(int i = 1 ; i <= n ; i++) cin >> a[i];
	for(int t = 1 ; ; t++){
		work = (x * 1.0) - (r - last) , coun = 0;
		for(int i = pos ; ; i++){
			if(pos > n){
				cout << t;
				return 0;
			}
			if(work - a[i] >= 0 && coun + a[i] < x){
				pos++;
				work -= a[i];
				coun += a[i];
			}
			else break;
		}
		last = work;
	}
	return 0;
}
```
## 100 分

AC 做法其实是也很简单：

- 每次插入一个的时候，如果当天不够做了，就去计算要睡多少天才够。

你们喜闻乐见的代码（~~更短~~）：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[500005];
int n , x , p , q;
int sum , ans , cnt , csum;
signed main(){
	cin >> n >> x >> p >> q;
	for(int i = 1 ; i <= n ; i++){
		cin >> a[i];
		sum += a[i];
	}
	for(int i = n ; i >= 1 ; ){
		ans = max(ans , cnt + (sum * q + x * (q - p) - 1) / (x * (q - p)));
		csum = 0;
		while(i >= 1 && a[i] + csum < x) csum += a[i--];
		sum -= csum;
		cnt++;
	}
	cout << ans;
	return 0;
}
```


---

## 作者：封禁用户 (赞：1)

## 题意简述

给你四个正整数 $n$（$1 \leq n \leq 10^5$），$x$（$1 \leq x \leq 10^6$），$p$，$q$（$1 \leq p \lt q \leq 10^6$），表示有 $n$ 个任务，一天有 $x$ 的时间。

接下来有 $n$ 个整数，表示每个任务所需的时间。

Eric 想要写完这些作业，但是需要睡觉，且睡觉时间满足如下要求：

1. Eric 每天必须睡觉（也就是说不能一天都在写作业）。

2. Eric 每天的睡觉的时间是连续的，且睡觉时间结束后，第二天恰好开始。

3. Eric 前 $i$ 天的睡觉时间总和不能少于 $x \times \frac{p}{q} \times i$ 的时间。

## 题目分析

很多人暴力枚举答案，但是事实证明这样做会 TLE，不能得到满分。那么我们怎么做呢？我们需要从枚举答案到计算答案。我们考虑把每一个任务读入进来，利用公式来计算当前的天数。

我这里是维护了三个变量：

1. ```ll cnt = 0;``` 代表目前睡了多少时间。

2. ```int lft = x;``` 代表今天还能睡多少时间。

3. ```ll ans = 1;``` 当前的天数，即答案。

我们把任务所需时间记为 $t$。

我们发现，如果 $lft > t$（当天一定有时间来睡觉，注意**不能加上等号**） 并且 $(cnt + lft - t) \geq ans \times x \times \frac{p}{q}$（睡眠时间足够），那么这件任务就可以在当天完成，我们就把 $lft$ 减去 $t$。

那么否则今天的剩余时间就只能睡觉。那么我们怎么求接下来一共要睡觉多少天（**不算上今天，并且这些天不能写作业**）才能满足要求呢？我们不妨设问题的答案为 $y$。我们先把 $cnt$ 加上 $lft$，代表今天睡过觉了。

显然当我们到了那一天时一共睡了 $cnt + x \times y + x - t$ 的时间。$x \times y$ 代表 $y$ 天摆烂睡大觉，后面的 $x - t$ 代表本来是有一个整天要睡的，但是我们还要完成作业，所以要减去一个 $t$。

接着我们接下来的天数为 $ans + y + 1$，即睡了多少天，加上完成作业那一天的 $1$。那么我们当时要求的最少睡觉时间就为 $(ans + y + 1) \times x \times \frac{p}{q}$。

于是我们即可列出不等式：$cnt + x \times y + x - t \geq (ans + y + 1) \times x \times \frac{p}{q}$，其中要求 $y \geq  0$。

接着我们就是解不等式。

我们先两边同时乘上 $q$，并且把右边的括号给拆开：

$cnt \times q + x \times y \times q + x \times q - t \times q \geq ans \times x \times p + y \times x \times p + x \times p$。

接着我们移项：

$cnt \times q + x \times q - t \times q - ans \times x \times p - x \times p \geq y \times x \times p - x \times y \times q$。

接着我们合并同类项：

$q \times (cnt + x - t) - x \times p \times (ans + 1) \geq y \times (x \times (p - q))$。

最后我们把两边同时除以 $x \times (p - q)$。由于 $p < q$，所以 $p - q < 0$。又因为 $1 \leq x$，所以 $x \times (p - q) < 0$，除完要变号。

$\frac{q \times (cnt + x - t) - x \times p \times (ans + 1)}{x \times (p - q)} \leq y$。这就是我们最终的结果了。很显然我们想让 $y$ 最小，那么 $y = \max(0, \lceil \frac{q \times (cnt + x - t) - x \times p \times (ans + 1)}{x \times (p - q)} \rceil)$。

接着我们把 $cnt$ 加上 $x \times y$，表示 $y$ 天一共睡的时间。

我们的 $lft$ 也要复位成 $x - t$，代表本来可以睡一整天的，但是因为要完成任务所以减去 $t$。

最后 $ans$ 加上 $y + 1$，就是我们这一轮要做的事情了。

## AC Code

很明显我的做法时间复杂度是 $O(n)$，空间复杂度是 $O(1)$，除了常数优化外应该就没有比我更好的算法了，毕竟读入就要花 $O(n)$，空间的 $O(1)$ 也是不能压缩的。

大家如果听了上面的一番讲解云里雾里，那么请看我下面的代码，配有详细注释。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

void fastio(const char *infile, const char *outfile) {
	if (infile) freopen(infile, "r", stdin);
	if (outfile) freopen(outfile, "w", stdout);
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
}

int main() {
	fastio(nullptr, nullptr);
	ll n, x, p, q;
	cin >> n >> x >> p >> q;
	ll cnt = 0;  // 一共睡的时间 
	int lft = x; // 今天还能睡多少时间 
	ll ans = 1;  // 当前天数 
	while (n--) {
		int t;
		cin >> t;
		if (lft > t && (cnt + lft - t) * q >= ans * x * p) {
			// 如果当天有时间睡觉：lft > t
			// 如果睡觉时间足够： cnt + lft - t >= ans * x * p / q
			lft -= t; // 那么剩余的睡觉时间减去 t 
		} else {
			cnt += lft; // 先把这一天的剩余时间睡完，更新 cnt 
			ll y = ceil((q * (cnt + x - t) - x * p * (ans + 1)) * 1.0 / (x * (p - q))); // 公式算出 y 
			if (y < 0) y = 0; // 与 0 取 max 
			cnt += x * y; // cnt 加上在 y 天里一共睡了多少时间 
			lft = x - t;  // 剩余睡觉时间就是 x - t 
			ans += y + 1; // 更新答案为最后睡觉的下一天，即 y + 1 
		}
	}
	cout << ans << endl; // 输出答案，结束 
	return 0;
}
```

---

## 作者：BigSmall_En (赞：0)

### [LG8508](https://www.luogu.com.cn/problem/P8508) 做不完的作业

> 有 $n$ 个任务，第 $i$ 个任务需要 $t_i$ 的时间。Eric 要在若干天内**依次**完成这些任务。Eric 是一个专注的人，所以完成每个任务的时间**必须连续**。
>
> 一天有 $x$ 的时间。由于 Eric 需要睡觉，所以 Eric 不能利用所有的时间。具体地：
>
> - Eric 每天**必须睡觉**；
> - Eric 每天的睡觉的时间是连续的，且睡觉时间结束后，第二天恰好开始；
> - Eric **前 $\boldsymbol i$ 天**的睡觉时间**总和**不能少于 $r\cdot x\cdot i$ 的时间。$r$ 是一个给定的实数，$i$ 是一个正整数。
>
> Eric 想问你，至少需要多少天才能完成任务。

赛时犯傻用浮点数然后 $100\to 70$ 的前来报道。提供一种贼复杂的做法。

首先贪心的基本思想是官方题解已经讲到了的，直接贪心能得到 $70$ 分。

但是当 $\frac{p}{q}$ 较大的时候，会发现有的时候可能需要连续睡几天再进行一个任务才能满足睡觉时间这一限制。

我们现在就要求出第 $i$ 天已经无法进行任务的时候，需要第 $i+der$ 天才能进行任务，这个任务执行的时间为 $t_j$（就是中间这些天都在睡觉），假设第 $i$ 天结束的时候一共睡了 $sum$ 个小时。则可以得到式子，其中 $x-t_j$ 表示第 $i+der$ 天只执行 $j$ 这个任务。
$$
(der-1)\times x+sum+(x-t_j)\geq (i+der)\times x\times \frac{p}{q}
$$
因为 $\frac{p}{q}<1$，所以我们可以在 $[1,x]$ 范围内**二分** $der$ 值，找到最小的一个 $der$ 满足条件。至于 $sum$，我们只需要求出 $t$ 的前缀和 $s$，$sum=i\times x-s_{j-1}$。

单次二分时间复杂度 $O(\log x)$，至多二分 $n$ 次，总时间复杂度 $O(n\log x)$。

注意不要将 $\frac{p}{q}$ 写成浮点数的形式，而要把 $q$ 乘到不等式左边比较。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <cmath>
using namespace std;
typedef long long ll;
typedef pair<int,int>ttfa;
inline ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}
	while('0'<=ch&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
const int N=100005;
ll n,x,t[N],s[N],P,Q;
#define sum (i*x-s[p-1])
int main(){
	n=read(),x=read();P=read(),Q=read();
	for(int i=1;i<=n;++i)t[i]=read(),s[i]=s[i-1]+t[i];
	for(ll p=1,i=1;p<=n;){
		ll ag=sum-x,lef=x;//lef 表示这一天执行了一些任务后仍能使用的时间
		while(p<=n&&t[p]<lef&&(ag+(lef-t[p]))*Q>=(i*x)*P){
			lef-=t[p];
			++p;
		}
		if(p==n+1)return printf("%lld\n",i),0;
		ll l=1,r=x,der=0;
		while(l<=r){
			ll mid=(l+r)>>1;
			if(((mid-1)*x+sum+x-t[p])*Q>=x*P*(i+mid))der=mid,r=mid-1;
			else l=mid+1;
		}
		i+=der;
	}
	return 0;
}
/*
5 6 4 5
5 4 3 2 1
5 1
8 2
10 3
12 4
13 5
*/
```



---


# 「Wdoi-2」灵山之上神风起

## 题目背景

在天狗记者射命丸文的指（放）引（水）之下，灵梦一行人找到了山中的神社。

“在妖怪之山上还真的存在其他的神社啊。”灵梦感慨道。她们看到了由树木建造的神社正殿，以及正殿前的参拜道上的一排御柱，而更远处则是一片湖——风神之湖。湖面非常开阔，波光粼粼，一碧万顷，远处似乎有群山环抱，让人心旷神怡。

到达神社之时已经是傍晚了。正当灵梦和魔理沙感慨之时，见到在她们面前有一位白衣蓝裙的少女，东风谷早苗，拥有着引发奇迹程度的能力。为了找到守矢神社中的两位神灵，灵梦与魔理沙，向东风谷早苗产生了激烈的交战。

“那就在现人神的力量洗礼中思索吧！这召唤奇迹的神明之力！”

## 题目描述

### 简要题意

给定一个长度为 $n$ 的正整数序列 $a$ 满足对于所有 $i\in [1,n]$ 有 $a_i \in \{1,2,3\}$。

现在通过该序列构造一张含 $n$ 个节点，节点编号为 $1$ 到 $n$ 的图：对于数 $i$，如果 $a_i=1$，那么什么都不做；如果 $a_i=2$，那么向所有比 $i$ 小的数的节点连无向边；如果 $a_i=3$，那么向所有比 $i$ 大的数的节点连无向边。求出该图的最大独立集的大小。

最大独立集，指的是原图中一个点数尽量多的点集，这些点在原图中两两之间没有边**直接**相连。

### 原始题意

然而，东风谷早苗（后称早苗）的弹幕密度相当之高，使人应接不暇，灵梦只得想个方法去减少她需要关注的弹幕数量。

数个回合过后，她发现，早苗每次释放弹幕只会释放出 $n$ 个弹幕，分别编号为 $1,2,\dots,n$，而她每释放一个弹幕，都会对应着产生一次神力波动。因而她的神力波动可以抽象为一个长度为 $n$ 的正整数数列 $\{a_n\}$。由于她的资历尚浅，只会使用三种神力，分别用 $1,2,3$ 表示，即 $\forall i \in [1,n]$，$a_i \in \{1,2,3\}$。

她发现，早苗的三种神力作用各不相同，具体而言如下：

- 当 $a_i=1$ 时，她不会做任何事情。
- 当 $a_i=2$ 时，早苗会让第 $i$ 个弹幕向所有弹幕编号**小于** $i$ 的弹幕建立神力输送通道。
- 当 $a_i=3$ 时，早苗会让第 $i$ 个弹幕向所有弹幕编号**大于** $i$ 的弹幕建立神力输送通道。

接着，在各种神力的交互配合之下，密集的弹幕将展开于灵梦的眼前。而一旁的魔理沙发现，若是从这些弹幕中挑选出**尽可能多的**一群弹幕，使得每个弹幕之间不存在直接相连的神力输送通道，那么这群弹幕会产生【引发奇迹程度的能力】，是不必关注的。

由于【引发奇迹程度的能力】只能被触发**一次**，灵梦和魔理沙想要知道，**最多**有多少个弹幕是不必关注的。她们找到了你，希望你能帮她解答。

## 说明/提示

### 样例解释

根据题意显然可以构造出如下的图。其中 $a_i=2$ 的用蓝色边表示，$a_i=3$ 的用红色边表示。

显然选取第 $2,3$ 个弹幕（已用绿色填图）是最多的情况。实际上对于这个样例，选取弹幕的方案不止一种，但是不存在更多的情况了。

![](https://cdn.luogu.com.cn/upload/image_hosting/99a854cu.png)

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 10 & - & 20\\\hline
2 & 10^5 & \text{A} & 10\\\hline
3 & 10^5 & \text{B} & 30 \\\hline
4 & 10^5 & - & 40 \\\hline
\end{array}$$

- 特殊性质 $\text{A}$：所有的 $a_i=1$；
- 特殊性质 $\text{B}$：所有的 $a_i$ 不是 $1$ 就是 $2$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$a_i \in \{1,2,3\}$。

## 样例 #1

### 输入

```
6
3 1 3 2 1 2```

### 输出

```
2```

# 题解

## 作者：chen_zhe (赞：15)

根据题目描述，首先可以证明的是，选取的 $a_i \neq 1$ 的点的个数不会大于等于 $3$。

这是因为，当选取了 $a_i \neq 1$ 的节点数量恰为 $2$ 的时候，只有一种在左侧位置 $l$ 选择一个 $a_i=2$ 的节点，在右侧位置 $r$ 选择一个 $a_i=3$ 的节点的情况下不会产生冲突（即，存在方案使得选出的点集是个独立集）。此时若是再选择一个 $a_i \neq 1$ 的节点，例如说在 $l<x<r$ 的位置 $x$ 选择一个 $a_i=2$，则无法和 $l$ 位置上的节点构成独立集；选择 $a_i=3$，则无法和 $r$ 位置上的节点构成独立集。其余四种情况（$1 \leq x<l$ 与 $r<x \leq n$）同理。

因此得出，选择的节点中，$a_i \neq 1$ 的节点个数为 $0,1,2$。若一个 $a_i \neq 1$ 的都不选，就是都选择 $a_i=1$ 的节点，这个时候构成的独立集在这个情况下是最大的。

若选择一个 $a_i \neq 1$ 的节点，就会分成两个情况。若选择一个 $a_i=2$ 的节点，即向所有编号 $<i$ 的节点连边，我们希望在这个情况下被连边连接到的 $a_i=1$ 的节点最少。因此我们让这个 $a_i=2$ 的节点选择的尽可能靠左，这样其右边的 $a_i=1$ 的节点都是可选放入独立集的；对于选择一个 $a_i=3$ 的情况是同理的。

若选择两个 $a_i \neq 1$ 的节点，如上文所述，只有一种在左侧位置 $l$ 选择一个 $a_i=2$ 的节点，在右侧位置 $r$ 选择一个 $a_i=3$ 的节点的情况下不会产生冲突，这个时候在 $l<x<r$ 范围内的 $a_x=1$ 都是可选择放入独立集的。

综上所述，我们所选取的节点有如下可能：

- 选取所有 $a_i=1$ 的点；
- 选取最左边的 $a_i=2$ 的点，再选取所有其右边的 $a_i=1$ 的点；
- 选取最右边的 $a_i=3$ 的点，再选取所有其左边的 $a_i=1$ 的点；
- 选取最左边的 $a_i=2$ 的点和最右边的 $a_i=3$ 的点，再选取所有其中间的 $a_i=1$ 的点。

四种情况分别讨论一下看哪一个选取的点更多。注意第四种情况下需要判断最左边的 $a_i=2$ 的点和最右边的 $a_i=3$ 的点的位置，否则容易被如下数据卡住（正确答案是 $1$）：

```
2
3 2
```

参考代码：

```cpp
#include <iostream>

using namespace std;

int n,a[100050],l,r;

int main()
{
	cin >> n;
	for (int i=1;i<=n;i++)
		cin >> a[i];
	for (int i=1;i<=n;i++)
	{
		if (a[i]==2)
		{
			l=i;
			break;
		}
	}
	for (int i=n;i>=1;i--)
	{
		if (a[i]==3)
		{
			r=i;
			break;
		}
	}
	int ans=0;
	if (l)
	{
		int ret=1;
		for (int i=l+1;i<=n;i++)
			ret+=(a[i]==1);
		ans=max(ans,ret);
	}
	if (r)
	{
		int ret=1;
		for (int i=1;i<=r-1;i++)
			ret+=(a[i]==1);
		ans=max(ans,ret);
	}
	if (l && r && r>l)//第四种情况的特判
	{
		int ret=2;
		for (int i=l+1;i<=r-1;i++)
			ret+=(a[i]==1);
		ans=max(ans,ret);
	}
	int ret=0;
	for (int i=1;i<=n;i++)
		ret+=(a[i]==1);
	ans=max(ans,ret);
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Keids (赞：13)

# P8538 灵山之上神风起题解
原题链接：https://www.luogu.com.cn/problem/P8538?contestId=63505

本题只要看出来性质就能秒杀。

先来读题。

对于 $n$ 个点，我们有如下三种操作：

第一是不干任何事情,直接跳过就好了。

第二是朝比自己编号小的点连边。

第三是朝比自己编号大的点连边。

求最多取出多少个点满足这些点直接无连边。

![](https://cdn.luogu.com.cn/upload/image_hosting/99a854cu.png)

如图，虽然样例解释使用的是 $2$ 和 $3$ ，其实我们也可以使用 $2$ 和 $5$ 两个点。

 $2$ ， $5$ 两个点共同特征是二者都无自主的连边，所以我们也可以推得，对于所有操作为 $1$ 的点，其两两之间没有任何连边。

拿到这个性质后，我们再看 $2$ 和 $3$ 操作的点。

对于一个 $3$ 操作的点，一定会连接其之后所有的点，所以如果取了这个点，则无法取得其之后任意一点。

同理对于 $2$ 操作，一定会连接其之前所有的点，所有取该点则不能取其之前的点。

所以一张图上，无论如何都只能取得 $2$ 和 $3$ 操作的各一个点。

所以就很简单了。

我们枚举 $1$ 到 $n$ ，统计所有操作为 $1$ 的节点，记录第一个和最后一个操作为 $1$ 的节点。

对于第一个操作为 $1$ 的节点找其前面是否有操作为 $2$ 的节点，同理对于最后一个操作为 $1$ 的节点找其后面是否有操作为 $3$ 的节点。

统计即为答案。

//附上代码

```c++
#include<iostream>
#include<cstdio>
using namespace std;
int n,l=0,r=0,sum=0;
int a[500010];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){//统计0
		scanf("%d",&a[i]);
		if(a[i]==1){
			sum++;
			if(!l)l=i;
			if(i>r)r=i;
		}
	}
	for(int i=1;i<=l;i++){//前面是否有2操作的点
		if(a[i]==2){
			sum++;break;
		}
	}
	for(int i=r;i<=n;i++){//后面是否有3操作的点
		if(a[i]==3){
			sum++;break;
		}		
	}
	printf("%d",sum);
	return 0;
} 
```
如题解写的有问题请指出，谢谢！


---

## 作者：Anahita (赞：7)

设 $f_i$ 表示前 $i$ 个点里最大独立集的大小。

首先分析 $a_i=1$ 的情况，这说明 $f_i$ 不仅可以由前面的值转移得到，也说明后面的值也可以由 $f_i$ 转移得到。

当 $a_i=2$ 时，点 $i$ 会**向前**连边，这就导致 $f_i$ 不能由前面转移得到，此时$f_i = 1$。 

最后是 $a_i=3$ 时，点 $i$ 会**向后**连边，所以后面的值就无法从 $f_i$ 转移得到。

那么我们定义一个 $maxn$ 表示可以向后转移的点中最大的值就行了。

$\text{Code}:$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[1000100];
int dp[1000100];
int main(){
	scanf("%d",&n);
	for(int i =1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	if(a[1] == 1)dp[1] = 1;
	if(a[1] == 2)dp[1] = 1;
	int maxn = dp[1];
	int ans = 1;
	for(int i = 2;i<=n;i++){
		if(a[i] == 1){
			dp[i] = maxn+1;
			maxn = dp[i];
		}
		else if(a[i] == 2){
			dp[i] = 1;
			maxn = max(maxn,1);
		}
		else{
			dp[i] = maxn+1;
		}
		ans = max(ans,dp[i]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：wanghanshi_1999 (赞：5)

直奔主题：

我们可以发现此题的答案 $ans$ 一定包含所有 $a_{i} = 1$ 的点。（因为 $a_{i} = 1$ 的点不做任何事情，所以肯定相对独立）

然后我们考虑 $a_{i} = 2$ 和 $a_{i} = 3$ 的情况。

假设 $a_{i} = 2$ 的点位置在 $a_{i} = 1$ 的集合中间（如下图，很丑），那么一定会和 $i$ 前面的点连上边，所以它肯定不能选取，同理， $a_{i} = 3$ 的点肯定也不可以选取。
![](https://cdn.luogu.com.cn/upload/image_hosting/m4ip67wv.png)

既然 $a_{i} = 2$ 和 $a_{i} = 3$ 在中间的点我们不能选取，那么我们看一下在两侧是否可以。

![](https://cdn.luogu.com.cn/upload/image_hosting/jm72cpyu.png)

我们可以发现这个点绝对可以选取！！！

那么它有什么性质呢？

$a_{i} = 2$ 且 $i < L$，其中 $L$ 为 $1$ 集合中最左侧的位置。

同理，$a_{i} = 3$ 且 $i > R$，其中 $R$ 为 $1$ 集合中最右侧的位置。

### 代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

int l,r,ans;
bool l1[1000010],r1[1000010];
int a[1000010];
int main()
{
	int n;
	scanf("%d",&n);
	l = n+1;
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i] == 1)
		{
			l = min(l,i);
			r = max(r,i); 
			ans++;
		}
	}
	for(int i = 1;i<=n;i++)
	{
		l1[i] = l1[i-1];
		if(a[i] == 2)
			l1[i] = true;
	}
	for(int i = n;i>=1;i--)
	{
		r1[i] = r1[i+1];
		if(a[i] == 3)
			r1[i] = true;
	}
	if(l1[l] == true)
		ans++;
	if(r1[r] == true)
		ans++;
	if(ans == 0)
	{
		for(int i = 1;i<=n;i++)
		{
			if(l1[i] == true && r1[i] == true)
			{
				ans = 2;
				break;
			}
			if(l1[i] == true)
				ans = 1;
			if(r1[i] == true)
				ans = 1;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：AirQwQ (赞：2)

1. 若选取了 $ a_i $，并且 $ a_i=2$ 则其左边的所有弹幕都需要关注。

2. 若选取了 $ a_i $，并且 $ a_i=3$ 则其右边的所有弹幕都需要关注。

3. 若选取了 $ a_i $，并且 $ a_i=1$ 则不用关心 $ a_i $ 向其它弹幕的神力输送通道。

令一串弹幕为 ``` 2 1 2 1 1 3 1 3```。

关注为 $2$ 的弹幕对为 $1$ 的弹幕的影响：

1. 若选取了 $ a_3$ 则 $ a_2$ 与 $ a_1 $ 均无法选。

2. 若选取了 $ a_1$ 则可以选择 $ a_2$。

于是，想让最多的弹幕不必关注，为 $2$ 的弹幕一定在最左端 $1$ 的左侧，同理，为 $3$ 的弹幕一定在最右侧一个 $1$ 的右侧。（尽管选法不是唯一，但这样一定最优）

于是我们知道了，$ a_i=1$ 的弹幕全选，而 $ a_i=2$ 和 $ a_i=3$ 分别在两端能选则选，反之不选。

最后注意判断形如 ```3 2``` 的情况。

~~代码双手奉上。~~

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,l,r,ans,a[500010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==1){
			ans++;
			if(!l)l=i;//标记最左的1的位置
			if(i>r)r=i;//标记最右的1的位置
		}
	}
	for(int i=1;i<=l;i++)
		if(a[i]==2){ans++;break;}
	for(int i=r;i<=n;i++)
		if(a[i]==3){ans++;break;}		
	cout<<ans;
	return 0;
} 
```


---

## 作者：_Remake_ (赞：1)

## 题目分析
注意到当某些 $i$ 满足 $a_i = 1$ 时，这些 $i$ 必定能被同时选为某个独立集中的元素，并注意到我们最多分别只能选择一个 $i$，满足 $a_i$ 为 $2$ 或 $3$，所以只需记录使 $a_i=1$ 的 $i$ 的个数记为答案，再从左到右扫描,如有一个 $i$，满足 $a_i=2$ 且对于 $k<i$ 的所有 $k$ 不满足 $a_k=1$，则答案++，同理对于 $a_i=3$ 的情况从右往左扫描即可，还要注意特判没有  $i$ 满足 $a_i=1$ 的情况，这种情况把答案--即可。

正确性证明：显然所有满足 $a_i = 1$ 的 $i$ 能够同时被选中，如有一个 $j$ 满足对所有 $k<j$ 都有 $a_k≠ 1$，则将这个编号为 $j$ 的节点同时选入独立集中不影响先前被选入的元素。如果没有这样的 $j$，则选入某个使 $a_i=2$ 的 $i$ 将会至少使答案减少 $1$，而选入这个节点将会使答案增加 $1$，并且只能同时选入一个这样的 $j$，所以答案不会增大。 $a_j=3$ 时的情况同理。当序列中不存在 $j$，使 $a_j=1$ 时，显然最多选取一个 $i$，但这种做法会同时选入两个节点，使它们对应的 $a_i$ 分别等于 $2$ 和 $3$，此时只需把答案 $-1$ 即可。
## 代码

注:代码中已省略快读和头文件。

```cpp
int n;
int A[510005];
signed main()
{
	int C=0;
	int cnt=0;
	n=read();
	for(int r=1;r<=n;r++)
	{
		A[r]=read();
		if(A[r]==1)
		{
			cnt++;
			C++;
		}
	}
	for(int r=1;r<=n;r++)
	{
		if(A[r]==1)
		{
			break;
		}
		else if(A[r]==2)
		{
			cnt++;
			break;
		}
	}
	for(int r=n;r>=1;r--)
	{
		if(A[r]==1)
		{
			break;
		}
		else if(A[r]==3)
		{
			cnt++;
			break;
		}
	}
	if(!C)
	{
		cnt--;
	}
	cout<<cnt;
	return 0;
}
```


---

## 作者：Gaode_Sean (赞：0)

这道题的解题关键，是一个非常显然的性质：答案点集中 $2$ 和 $3$ 的点分别至多 $1$ 个。

所以我们统计一下 $a_1 \sim a_i$ 中满足 $a_j=1$ 的个数，记为 $cnt_i$。我们再记 $l$ 为 $2$ 在 $a$ 中最左侧的位置，$r$ 为 $3$ 在 $a$ 中最右侧的位置。

现在答案由 $4$ 种情况得到：

$1.$ 全选 $1$，答案为 $cnt_n$。

$2.$ 选最左侧的 $2$，答案为 $cnt_n-cnt_{l-1}+1$。

$3.$ 选最右侧的 $3$，答案为 $cnt_r+1$。

$4.$ 选最左侧的 $2$ 和最右侧的 $3$，答案为 $cnt_r-cnt_{l-1}+2$。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,a[N],s[N],l,r;
int main()
{
    scanf("%d",&n);
	for(int i=1;i<=n;i++){scanf("%d",&a[i]);s[i]=s[i-1]+(a[i]==1);}
	for(int i=1;i<=n;i++) if(a[i]==3) r=i;
	for(int i=n;i>=1;i--) if(a[i]==2) l=i;
	int ans=s[n];
	if(l) ans=max(ans,s[n]-s[l-1]+1);
	if(r) ans=max(ans,s[r]+1);
	if(l&&r&&r>l) ans=max(ans,s[r]-s[l-1]+2);
	printf("%d",max(ans,1));
	return 0;
}
```

---

## 作者：Untitled10032 (赞：0)

根据题目，可以得出如下结论：

- 序列中所有的 $1$ 不会互相冲突。
- $2$ 只能出现在被选中的所有元素的最左侧。
- $3$ 只能出现在被选中的所有元素的最右侧。

那么要做的事情就变得很简单了：找到序列中所有的 $1$，再在最左边的 $1$ 的左边找有没有 $2$，在最右边的 $1$ 的右边找有没有 $3$。

可以保证如果选中了序列中最左边的 $1$ 右边的任意一个 $2$，则答案不会比选中所有 $1$ 更优，选中最右边的 $1$ 左边的 $3$ 同理。


[![vXWTGd.png](https://s1.ax1x.com/2022/09/12/vXWTGd.png)](https://imgse.com/i/vXWTGd)

还要注意特判一下没有 $1$ 的情况，只要找 $2$ 的后面有没有 $3$ 就行了。如果有就输出 `2`，如果没有就输出 `1`（注意，不是 $0$）。

代码：

```cpp
#include <iostream>
#define maxn 100005
using namespace std;
int a[maxn];
int main() {
    int n;
    scanf("%d", &n);
    int cnt1 = 0;	//数一共有几个1
    bool has2 = false, has3 = false;	//最左侧有没有2、最右侧有没有3
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if (cnt1 == 0 && a[i] == 2)
            has2 = true;	//2在所有1之前出现
        if (a[i] == 1) {
            cnt1++;		//当前元素为1
            has3 = false;
        } else if (a[i] == 3)
            has3 = true;	//3在目前最后一个1之后出现
    }
    if (cnt1 == 0) {	//特判没有1的情况
        int i;
        for (i = 1; a[i] != 2 && i <= n; i++);	//找到第一个2
        for (     ; a[i] != 3 && i <= n; i++);	//找第一个2后面有没有3
        if (i == n + 1)	//未找到3
            putchar('1');
        else
            putchar('2');
        return 0;
    }
    printf("%d", cnt1 + (int)has2 + (int)has3);
    return 0;
}
```


---


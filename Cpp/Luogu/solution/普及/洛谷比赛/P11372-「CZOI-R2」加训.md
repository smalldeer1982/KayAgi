# 「CZOI-R2」加训

## 题目描述

\_O_v_O_ 来到了 $k$ 维世界。

机房可看作一个 $n^k$ 的 $k$ 维正方体（你可以理解为一个 $k$ 维的坐标系），每一维的坐标从 $1$ 到 $n$。

有 $m$ 个 OIer，第 $i$ 个在 $(a_{i,1},a_{i,2},\cdots,a_{i,k})$。遗憾的是，所有 OIer 都在摸鱼。

机房还有 $x$ 个障碍，第 $i$ 个在 $(b_{i,1},b_{i,2},\cdots,b_{i,k})$。

除此之外，有 $y$ 个教练，第 $i$ 个在 $(c_{i,1},c_{i,2},\cdots,c_{i,k})$。

教练可不想看到 OIer 们摸鱼，而只要教练跟某个 OIer 在的坐标之间有且仅有 $k-1$ **维的坐标**相同，并且他们两个人连起来形成的一条**线段**上没有别的障碍或 OIer 或教练，那么那个 OIer 就被发现摸鱼了。

问每个教练能发现几个 OIer 在摸鱼？

## 说明/提示

**【样例解释】**

满足有 $k-1$ 个坐标相同的 OIer 和教练有 OIer 1 和教练 1，OIer 2 和教练 2，其中 OIer 1 和教练 1 之间有障碍，不会被发现。

**【数据范围】**

**本题采用捆绑测试。**

- Subtusk#1（$25\ \text{pts}$）：$k=1$。
- Subtusk#2（$35\ \text{pts}$）：$k=2$。
- Subtusk#3（$40\ \text{pts}$）：$k=3$。

对于 $100\%$ 的数据，$1\le n\le 10^3$，$\bf{1\le k\le 3}$，$m,x,y\ge1,m+x+y\le\min(10^3,n^k)$，$1\le a_{i,j} ,b_{i,j},c_{i,j} \le n$，保证所有 OIer、教练、障碍都不在同一位置。

## 样例 #1

### 输入

```
10 2
2 2 2
1 1
1 2
2 1
2 3
3 1
3 2```

### 输出

```
0 1```

# 题解

## 作者：WsW_ (赞：6)

### 前言
上位黄，非 STL 的模拟题。

---
### 思路
对于每个教练，其他教练对他来说都相当于障碍，所以在输入教练的时候直接把所有教练同时加到障碍里面。  

对于每个教练，我们考虑他能发现几个人在摸鱼。  
因为只有 $k$ 个维度，所以每个教练最多只能往 $2k$ 个方向看。因为往每个方向看的时候，只能看见离自己最近的人，所以最多只能发现 $2k$ 个人在摸鱼。  

首先预处理出每个方向上里教练最近的障碍。  
接着，对于每个学生，判断**他在这个方向上到教练的距离**是不是比**障碍到教练的距离**更近。如果不是，那不用管这个学生；如果是，那么这个学生成了这个方向上新的障碍，且这个方向上离教练最近的是学生。  
以上过程中记得判断障碍或学生是不是有且仅有 $k-1$ 维和教练不同。  

最后统计有几个方向上离教练最近的是学生即可。  

时间复杂度 $O\left(y(m+x+y)\times k\right)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+5;
int n,k,m,x,y;
int a[maxn][5],b[2*maxn][5],c[maxn][5];
int tag[2][5];//存储每个方向上到教练最近的障碍
bool vis[2][5];//标记每个方向上到教练最近的是不是学生

void work(int p){
	int ans=0;
	memset(tag[0],0,sizeof(tag[0]));
	memset(tag[1],0x7f,sizeof(tag[1]));
	memset(vis,0,sizeof(vis));//初始化
  
	for(int i=1;i<=x;i++){//预处理障碍
		int scnt=0,dif=-1;//scnt记录有几个维度不同；dif记录不同的是哪个维度
		for(int j=1;j<=k;j++){
			if(b[i][j]!=c[p][j])dif=j;
			else scnt++;
		}
		if(scnt!=k-1)continue;//不满足，直接跳过
		if(b[i][dif]<c[p][dif])tag[0][dif]=max(tag[0][dif],b[i][dif]);
		else tag[1][dif]=min(tag[1][dif],b[i][dif]);
	}
  
	for(int i=1;i<=m;i++){//对每个学生进行处理
		int scnt=0,dif=-1;
		for(int j=1;j<=k;j++){
			if(a[i][j]!=c[p][j])dif=j;
			else scnt++;
		}
		if(scnt!=k-1)continue;
		if(a[i][dif]<c[p][dif]&&a[i][dif]>tag[0][dif]){
			tag[0][dif]=a[i][dif];
			if(!vis[0][dif]){
				ans++;
				vis[0][dif]=1;
			}
		}
		if(a[i][dif]>c[p][dif]&&a[i][dif]<tag[1][dif]){
			tag[1][dif]=a[i][dif];
			if(!vis[1][dif]){
				ans++;
				vis[1][dif]=1;
			}
		}
	}
	cout<<ans<<' ';//遍历vis，求其中有几个1也可
}

int main(){
	cin>>n>>k>>m>>x>>y;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=k;j++)
			cin>>a[i][j];
	for(int i=1;i<=x;i++)
		for(int j=1;j<=k;j++)
			cin>>b[i][j];
	for(int i=1;i<=y;i++)
		for(int j=1;j<=k;j++){
			cin>>c[i][j];
			b[x+i][j]=c[i][j];//教练相当于障碍
		}
	x+=y;//障碍数要加上教练数
	for(int i=1;i<=y;i++)
		work(i);
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：6)

# 暴力思路
枚举每个教练，再枚举考虑每个学生能否被教练发现。时间复杂度 $O(mxy)$，会超时。
# 我的思路
通过分析可以发现，第 $k$ 维的教练最多能发现 $2k$ 个学生摸鱼，注意到 $1≤k≤3$，也就是说每个教练最多发现 $6$ 个学生。可以通过枚举距离每个教练每个方向最近的 $1$ 个学生，再逐一判断能否被发现来求解。

## 赛时代码
很丑，但保证能读懂。

时间复杂度 $O(my+xy+y^2)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005][5],b[1005][5],c[1005][5];
int n,K;
int check(int x,int y)
{
	int sum=0;
	if(a[x][1]==c[y][1]) sum++;
	if(a[x][2]==c[y][2]&&K>=2) sum++;
	if(a[x][3]==c[y][3]&&K>=3) sum++;
	return sum;
}
signed main()
{
	cin>>n>>K;
	int m,x,y;
	cin>>m>>x>>y;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=K;j++)
			cin>>a[i][j];
	for(int i=1;i<=x;i++)
		for(int j=1;j<=K;j++)
			cin>>b[i][j];
	for(int i=1;i<=y;i++)
		for(int j=1;j<=K;j++)
			cin>>c[i][j];
	for(int i=1;i<=y;i++)
	{
		int oier1=0,oier2=1e9;
		int oier3=0,oier4=1e9;
		int oier5=0,oier6=1e9;
		for(int j=1;j<=m;j++)
		{
			if(check(j,i)==K-1)//如果满足条件 
			{
				if(a[j][1]!=c[i][1])
				{
					if(a[j][1]<c[i][1]) oier1=max(oier1,a[j][1]);
					else oier2=min(oier2,a[j][1]);
				}
				if(a[j][2]!=c[i][2]&&K>=2)
				{
					if(a[j][2]<c[i][2]) oier3=max(oier3,a[j][2]);
					else oier4=min(oier4,a[j][2]);
				}
				if(a[j][3]!=c[i][3]&&K>=3)
				{
					if(a[j][3]<c[i][3]) oier5=max(oier5,a[j][3]);
					else oier6=min(oier6,a[j][3]);	
				}//更新所在方向上距离最近的学生 
			}
		}
		int ans=K*2;
		int flag1=1,flag2=1,flag3=1,flag4=1,flag5=1,flag6=1;//如果为0则表示已经被判断不能被看见了 
		if(oier1==0) ans--,flag1=0;
		if(oier2==1e9) ans--,flag2=0;
		if(oier3==0&&K>=2) ans--,flag3=0;
		if(oier4==1e9&&K>=2) ans--,flag4=0;
		if(oier5==0&&K==3) ans--,flag5=0;
		if(oier6==1e9&&K==3) ans--,flag6=0;//如果这一方向没有学生就特判 
		for(int j=1;j<=x;j++)
		{
			if(K==1)
			{
				if(b[j][1]>c[i][1]&&b[j][1]<oier2&&flag2) flag2=0,ans--;
				if(b[j][1]<c[i][1]&&b[j][1]>oier1&&flag1) flag1=0,ans--;
			}
			if(K==2)
			{
				if(b[j][1]>c[i][1]&&b[j][1]<oier2&&flag2&&b[j][2]==c[i][2]) flag2=0,ans--;
				if(b[j][1]<c[i][1]&&b[j][1]>oier1&&flag1&&b[j][2]==c[i][2]) flag1=0,ans--;
				if(b[j][2]>c[i][2]&&b[j][2]<oier4&&flag4&&b[j][1]==c[i][1]) flag4=0,ans--;
				if(b[j][2]<c[i][2]&&b[j][2]>oier3&&flag3&&b[j][1]==c[i][1]) flag3=0,ans--;
			}
			if(K==3)
			{
				if(b[j][1]>c[i][1]&&b[j][1]<oier2&&flag2&&b[j][2]==c[i][2]&&b[j][3]==c[i][3]) flag2=0,ans--;
				if(b[j][1]<c[i][1]&&b[j][1]>oier1&&flag1&&b[j][2]==c[i][2]&&b[j][3]==c[i][3]) flag1=0,ans--;
				if(b[j][2]>c[i][2]&&b[j][2]<oier4&&flag4&&b[j][1]==c[i][1]&&b[j][3]==c[i][3]) flag4=0,ans--;
				if(b[j][2]<c[i][2]&&b[j][2]>oier3&&flag3&&b[j][1]==c[i][1]&&b[j][3]==c[i][3]) flag3=0,ans--;
				if(b[j][3]>c[i][3]&&b[j][3]<oier6&&flag6&&b[j][1]==c[i][1]&&b[j][2]==c[i][2]) flag6=0,ans--;
				if(b[j][3]<c[i][3]&&b[j][3]>oier5&&flag5&&b[j][1]==c[i][1]&&b[j][2]==c[i][2]) flag5=0,ans--;
			}
		}//判断学生和教练之间是否有障碍 
		for(int j=1;j<=y;j++)
		{
			if(K==1)
			{
				if(c[j][1]>c[i][1]&&c[j][1]<oier2&&flag2) flag2=0,ans--;
				if(c[j][1]<c[i][1]&&c[j][1]>oier1&&flag1) flag1=0,ans--;
			}
			if(K==2)
			{
				if(c[j][1]>c[i][1]&&c[j][1]<oier2&&flag2&&c[j][2]==c[i][2]) flag2=0,ans--;
				if(c[j][1]<c[i][1]&&c[j][1]>oier1&&flag1&&c[j][2]==c[i][2]) flag1=0,ans--;
				if(c[j][2]>c[i][2]&&c[j][2]<oier4&&flag4&&c[j][1]==c[i][1]) flag4=0,ans--;
				if(c[j][2]<c[i][2]&&c[j][2]>oier3&&flag3&&c[j][1]==c[i][1]) flag3=0,ans--;
			}
			if(K==3)
			{
				if(c[j][1]>c[i][1]&&c[j][1]<oier2&&flag2&&c[j][2]==c[i][2]&&c[j][3]==c[i][3]) flag2=0,ans--;
				if(c[j][1]<c[i][1]&&c[j][1]>oier1&&flag1&&c[j][2]==c[i][2]&&c[j][3]==c[i][3]) flag1=0,ans--;
				if(c[j][2]>c[i][2]&&c[j][2]<oier4&&flag4&&c[j][1]==c[i][1]&&c[j][3]==c[i][3]) flag4=0,ans--;
				if(c[j][2]<c[i][2]&&c[j][2]>oier3&&flag3&&c[j][1]==c[i][1]&&c[j][3]==c[i][3]) flag3=0,ans--;
				if(c[j][3]>c[i][3]&&c[j][3]<oier6&&flag6&&c[j][1]==c[i][1]&&c[j][2]==c[i][2]) flag6=0,ans--;
				if(c[j][3]<c[i][3]&&c[j][3]>oier5&&flag5&&c[j][1]==c[i][1]&&c[j][2]==c[i][2]) flag5=0,ans--;
			}
		}//判断学生和教练之间是否有教练 
		cout<<ans<<" "; 
	}
	return 0;
}
```

---

## 作者：LiJunze0501 (赞：5)

## 题目大意：  
在一个 $k$ 维（$k=1$ 时为线段，$k=2$ 时为平面，$k=3$ 时为立方体,仅有这三种情况）空间中，有 $m$ 个 OIer，$x$ 个障碍，$y$ 个教练，如果教练和 OIer 在同一长或同一宽或同一高且中间无障碍时，教练就发现一个正在颓废的 OIer，求每个教练能看到几个 OIer。  
## 个人思路：
分三种情况，分别是一维，二维，三维。
1. 一维  
  一条线段，分别遍历每个教练、OIer 和障碍，看教练和 OIer 间有没有障碍、教练或 OIer。
2. 二维  
  一条线段，分别遍历每个教练、OIer 和障碍，看教练和 OIer 间有没有障碍、教练或 OIer，分为 $x$ 相同和 $y$ 相同。
3. 三维  
  一条线段，分别遍历每个教练、OIer 和障碍，看教练和 OIer 间有没有障碍、教练或 OIer，分为 $x,y$ 相同、$y,z$ 相同和 $x,z$ 相同。
## 一维 25Pts
```cpp
struct po{int x;};
if(z==1){//一维
    po oier[m+1],h[a+1],coach[b+1];
    for(int i=1;i<=m;i++) cin>>oier[i].x;
    for(int i=1;i<=a;i++) cin>>h[i].x;
    for(int i=1;i<=b;i++) cin>>coach[i].x;
    for(int j=1;j<=m;j++)
    for(int i=1;i<=b;i++){
        bool f=true;
        for(int k=1;k<=a;k++)if(abs(oier[j].x-coach[i].x)==abs(oier[j].x-h[k].x)+abs(h[k].x-coach[i].x)){f=false;break;}
        for(int k=1;k<=m;k++)if(j!=k&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-oier[k].x)+abs(oier[k].x-coach[i].x)){f=false;break;}
        for(int k=1;k<=b;k++)if(k!=i&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-coach[k].x)+abs(coach[k].x-coach[i].x)){f=false;break;}
        if(f) c[i]++;
    }
    for(int i=1;i<=b;i++) cout<<c[i]<<" ";
}
```
## 二维 35Pts
```cpp
struct li{int x,y;};
if(z==2){//二维
	li oier[m+1],h[a+1],coach[b+1];
	for(int i=1;i<=m;i++) cin>>oier[i].x>>oier[i].y;
	for(int i=1;i<=a;i++) cin>>h[i].x>>h[i].y;
	for(int i=1;i<=b;i++) cin>>coach[i].x>>coach[i].y;
	for(int i=1;i<=b;i++)
		for(int j=1;j<=m;j++){
			if(!((oier[j].y==coach[i].y&&oier[j].x!=coach[i].x)||(oier[j].x==coach[i].x&&oier[j].y!=coach[i].y))) continue;
			bool f=true;
			for(int k=1;k<=a;k++){
				if(oier[j].y==h[k].y&&oier[j].y==coach[i].y&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-h[k].x)+abs(h[k].x-coach[i].x)){f=false;break;}
				if(oier[j].x==h[k].x&&oier[j].x==coach[i].x&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-h[k].y)+abs(h[k].y-coach[i].y)){f=false;break;}
			}
			for(int k=1;k<=m;k++){
				if(k==j) continue;
				if(oier[j].y==oier[k].y&&oier[j].y==coach[i].y&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-oier[k].x)+abs(oier[k].x-coach[i].x)){f=false;break;}
				if(oier[j].x==oier[k].x&&oier[j].x==coach[i].x&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-oier[k].y)+abs(oier[k].y-coach[i].y)){f=false;break;}
			}
			for(int k=1;k<=b;k++){
				if(k==i) continue;
				if(oier[j].y==coach[k].y&&oier[j].y==coach[i].y&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-coach[k].x)+abs(coach[k].x-coach[i].x)){f=false;break;}
				if(oier[j].x==coach[k].x&&oier[j].x==coach[i].x&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-coach[k].y)+abs(coach[k].y-coach[i].y)){f=false;break;}
			}
			if(f) c[i]++;
		}
	for(int i=1;i<=b;i++) cout<<c[i]<<" ";
}
```
## 三维 40Pts
```cpp
struct sp{int x,y,z;};
if(z==3){//三维
	sp oier[m+1],h[a+1],coach[b+1];
	for(int i=1;i<=m;i++) cin>>oier[i].x>>oier[i].y>>oier[i].z;
	for(int i=1;i<=a;i++) cin>>h[i].x>>h[i].y>>h[i].z;
	for(int i=1;i<=b;i++) cin>>coach[i].x>>coach[i].y>>coach[i].z;
	for(int i=1;i<=b;i++)
		for(int j=1;j<=m;j++){
			if(!((oier[j].y==coach[i].y&&oier[j].z==coach[i].z&&oier[j].x!=coach[i].x)||(oier[j].x==coach[i].x&&oier[j].y==coach[i].y&&oier[j].z!=coach[i].z)||(oier[j].x==coach[i].x&&oier[j].z==coach[i].z&&oier[j].y!=coach[i].y))) continue;
			bool f=true;
			for(int k=1;k<=a;k++){
				if(oier[j].y==h[k].y&&oier[j].y==coach[i].y&&oier[j].x==h[k].x&&oier[j].x==coach[i].x&&abs(oier[j].z-coach[i].z)==abs(oier[j].z-h[k].z)+abs(h[k].z-coach[i].z)){f=false;break;}
				if(oier[j].y==h[k].y&&oier[j].y==coach[i].y&&oier[j].z==h[k].z&&oier[j].z==coach[i].z&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-h[k].x)+abs(h[k].x-coach[i].x)){f=false;break;}
				if(oier[j].x==h[k].x&&oier[j].x==coach[i].x&&oier[j].z==h[k].z&&oier[j].z==coach[i].z&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-h[k].y)+abs(h[k].y-coach[i].y)){f=false;break;}
			}
			for(int k=1;k<=m;k++){
				if(k==j) continue;
				if(oier[j].y==oier[k].y&&oier[j].y==coach[i].y&&oier[j].x==oier[k].x&&oier[j].x==coach[i].x&&abs(oier[j].z-coach[i].z)==abs(oier[j].z-oier[k].z)+abs(oier[k].z-coach[i].z)){f=false;break;}
				if(oier[j].y==oier[k].y&&oier[j].y==coach[i].y&&oier[j].z==oier[k].z&&oier[j].z==coach[i].z&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-oier[k].x)+abs(oier[k].x-coach[i].x)){f=false;break;}
				if(oier[j].x==oier[k].x&&oier[j].x==coach[i].x&&oier[j].z==oier[k].z&&oier[j].z==coach[i].z&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-oier[k].y)+abs(oier[k].y-coach[i].y)){f=false;break;}
			}
			for(int k=1;k<=b;k++){
				if(k==i) continue;
				if(oier[j].y==coach[k].y&&oier[j].y==coach[i].y&&oier[j].x==coach[k].x&&oier[j].x==coach[i].x&&abs(oier[j].z-coach[i].z)==abs(oier[j].z-coach[k].z)+abs(coach[k].z-coach[i].z)){f=false;break;}
				if(oier[j].y==coach[k].y&&oier[j].y==coach[i].y&&oier[j].z==coach[k].z&&oier[j].z==coach[i].z&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-coach[k].x)+abs(coach[k].x-coach[i].x)){f=false;break;}
				if(oier[j].x==coach[k].x&&oier[j].x==coach[i].x&&oier[j].z==coach[k].z&&oier[j].z==coach[i].z&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-coach[k].y)+abs(coach[k].y-coach[i].y)){f=false;break;}
			}
			if(f) c[i]++;
		}
	for(int i=1;i<=b;i++) cout<<c[i]<<" ";
}
```
## Summary
如果能 get 到这三点，拼起来就好了
### AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,z,m,a,b,c[1001];
struct po{int x;};
struct li{int x,y;};
struct sp{int x,y,z;};
int main(){
	cin>>n>>z>>m>>a>>b;
	if(z==1){
		po oier[m+1],h[a+1],coach[b+1];
		for(int i=1;i<=m;i++) cin>>oier[i].x;
		for(int i=1;i<=a;i++) cin>>h[i].x;
		for(int i=1;i<=b;i++) cin>>coach[i].x;
		for(int j=1;j<=m;j++)
			for(int i=1;i<=b;i++){
				bool f=true;
				for(int k=1;k<=a;k++)if(abs(oier[j].x-coach[i].x)==abs(oier[j].x-h[k].x)+abs(h[k].x-coach[i].x)){f=false;break;}
				for(int k=1;k<=m;k++)if(j!=k&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-oier[k].x)+abs(oier[k].x-coach[i].x)){f=false;break;}
				for(int k=1;k<=b;k++)if(k!=i&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-coach[k].x)+abs(coach[k].x-coach[i].x)){f=false;break;}
				if(f) c[i]++;
			}
		for(int i=1;i<=b;i++) cout<<c[i]<<" ";
	}
	if(z==2){
		li oier[m+1],h[a+1],coach[b+1];
		for(int i=1;i<=m;i++) cin>>oier[i].x>>oier[i].y;
		for(int i=1;i<=a;i++) cin>>h[i].x>>h[i].y;
		for(int i=1;i<=b;i++) cin>>coach[i].x>>coach[i].y;
		for(int i=1;i<=b;i++)
			for(int j=1;j<=m;j++){
				if(!((oier[j].y==coach[i].y&&oier[j].x!=coach[i].x)||(oier[j].x==coach[i].x&&oier[j].y!=coach[i].y))) continue;
				bool f=true;
				for(int k=1;k<=a;k++){
					if(oier[j].y==h[k].y&&oier[j].y==coach[i].y&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-h[k].x)+abs(h[k].x-coach[i].x)){f=false;break;}
					if(oier[j].x==h[k].x&&oier[j].x==coach[i].x&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-h[k].y)+abs(h[k].y-coach[i].y)){f=false;break;}
				}
				for(int k=1;k<=m;k++){
					if(k==j) continue;
					if(oier[j].y==oier[k].y&&oier[j].y==coach[i].y&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-oier[k].x)+abs(oier[k].x-coach[i].x)){f=false;break;}
					if(oier[j].x==oier[k].x&&oier[j].x==coach[i].x&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-oier[k].y)+abs(oier[k].y-coach[i].y)){f=false;break;}
				}
				for(int k=1;k<=b;k++){
					if(k==i) continue;
					if(oier[j].y==coach[k].y&&oier[j].y==coach[i].y&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-coach[k].x)+abs(coach[k].x-coach[i].x)){f=false;break;}
					if(oier[j].x==coach[k].x&&oier[j].x==coach[i].x&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-coach[k].y)+abs(coach[k].y-coach[i].y)){f=false;break;}
				}
				if(f) c[i]++;
			}
		for(int i=1;i<=b;i++) cout<<c[i]<<" ";
	}
	if(z==3){
		sp oier[m+1],h[a+1],coach[b+1];
		for(int i=1;i<=m;i++) cin>>oier[i].x>>oier[i].y>>oier[i].z;
		for(int i=1;i<=a;i++) cin>>h[i].x>>h[i].y>>h[i].z;
		for(int i=1;i<=b;i++) cin>>coach[i].x>>coach[i].y>>coach[i].z;
		for(int i=1;i<=b;i++)
			for(int j=1;j<=m;j++){
				if(!((oier[j].y==coach[i].y&&oier[j].z==coach[i].z&&oier[j].x!=coach[i].x)||(oier[j].x==coach[i].x&&oier[j].y==coach[i].y&&oier[j].z!=coach[i].z)||(oier[j].x==coach[i].x&&oier[j].z==coach[i].z&&oier[j].y!=coach[i].y))) continue;
				bool f=true;
				for(int k=1;k<=a;k++){
					if(oier[j].y==h[k].y&&oier[j].y==coach[i].y&&oier[j].x==h[k].x&&oier[j].x==coach[i].x&&abs(oier[j].z-coach[i].z)==abs(oier[j].z-h[k].z)+abs(h[k].z-coach[i].z)){f=false;break;}
					if(oier[j].y==h[k].y&&oier[j].y==coach[i].y&&oier[j].z==h[k].z&&oier[j].z==coach[i].z&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-h[k].x)+abs(h[k].x-coach[i].x)){f=false;break;}
					if(oier[j].x==h[k].x&&oier[j].x==coach[i].x&&oier[j].z==h[k].z&&oier[j].z==coach[i].z&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-h[k].y)+abs(h[k].y-coach[i].y)){f=false;break;}
				}
				for(int k=1;k<=m;k++){
					if(k==j) continue;
					if(oier[j].y==oier[k].y&&oier[j].y==coach[i].y&&oier[j].x==oier[k].x&&oier[j].x==coach[i].x&&abs(oier[j].z-coach[i].z)==abs(oier[j].z-oier[k].z)+abs(oier[k].z-coach[i].z)){f=false;break;}
					if(oier[j].y==oier[k].y&&oier[j].y==coach[i].y&&oier[j].z==oier[k].z&&oier[j].z==coach[i].z&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-oier[k].x)+abs(oier[k].x-coach[i].x)){f=false;break;}
					if(oier[j].x==oier[k].x&&oier[j].x==coach[i].x&&oier[j].z==oier[k].z&&oier[j].z==coach[i].z&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-oier[k].y)+abs(oier[k].y-coach[i].y)){f=false;break;}
				}
				for(int k=1;k<=b;k++){
					if(k==i) continue;
					if(oier[j].y==coach[k].y&&oier[j].y==coach[i].y&&oier[j].x==coach[k].x&&oier[j].x==coach[i].x&&abs(oier[j].z-coach[i].z)==abs(oier[j].z-coach[k].z)+abs(coach[k].z-coach[i].z)){f=false;break;}
					if(oier[j].y==coach[k].y&&oier[j].y==coach[i].y&&oier[j].z==coach[k].z&&oier[j].z==coach[i].z&&abs(oier[j].x-coach[i].x)==abs(oier[j].x-coach[k].x)+abs(coach[k].x-coach[i].x)){f=false;break;}
					if(oier[j].x==coach[k].x&&oier[j].x==coach[i].x&&oier[j].z==coach[k].z&&oier[j].z==coach[i].z&&abs(oier[j].y-coach[i].y)==abs(oier[j].y-coach[k].y)+abs(coach[k].y-coach[i].y)){f=false;break;}
				}
				if(f) c[i]++;
			}
		for(int i=1;i<=b;i++) cout<<c[i]<<" ";
	}
}
```

---

## 作者：PCSJZ (赞：5)

## 暴力

三重循环，枚举学生，障碍和老师，再判断是否合法。

时间复杂度：$\Theta (mxy)$。但是会 TLE。

## 暴力优化

用数组 $oier$ 来存储二元组 $(x, y)$ 对应的坐标 $z$。

这样就省去的开三维数组的成本。

然后只用枚举学生和老师，再判断维度坐标不同数是否为 $k-1$ 个，以及中间有没有障碍即可。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;

const int maxm = 1003;
vector<int> oier[maxm][maxm]; // oier: 存储 (x, y) 的坐标 z 
int n, k, m, x, y;
int oi[maxm][5], bar[maxm][5], tea[maxm][5];
// oi: 学生，bar: 障碍，tea: 老师 
int ans[maxm], d[5]; // d: d[1], d[2], d[3] 存储 (x, y, z) 
// ans: 答案 
// check: 判断中间是否有障碍 
bool check() {
	int x = d[1], y = d[2], z = d[3];
	for (int i = 0; i < oier[x][y].size(); i++) {
		if (oier[x][y][i] == z) // 如果 z 坐标相同，说明撞到一起，也就是有障碍 
			return 1;
	}
	return 0;
}

int main() {
	scanf("%d%d%d%d%d", &n, &k, &m, &x, &y);
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= k; j++) 
			scanf("%d", &oi[i][j]);
		oier[oi[i][1]][oi[i][2]].push_back(oi[i][3]);
	}
	for (int i = 1; i <= x; i++) {
		for (int j = 1; j <= k; j++) 
			scanf("%d", &bar[i][j]);
		oier[bar[i][1]][bar[i][2]].push_back(bar[i][3]);
	}
	for (int i = 1; i <= y; i++) {
		for (int j = 1; j <= k; j++) 
			scanf("%d", &tea[i][j]);
		oier[tea[i][1]][tea[i][2]].push_back(tea[i][3]);
	}
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= y; j++) {
			int cha = 0, l = 0;
			// l: 记录不同的那一个维度是在哪一位 
			for (int p = 1; p <= k; p++) { // 判断维度不同数量 
				if (oi[i][p] == tea[j][p])
					cha++;
				else
					l = p;
				d[p] = oi[i][p]; // d 存储学生的坐标 
			}
			if (cha != k - 1) continue;
			int cnt = 1;
			// 因为不存在 2 个坐标相同，所以可以直接比大小，确定从那个开始 
			int start = max(oi[i][l], tea[j][l]);
			int fin = min(oi[i][l], tea[j][l]);
			for (int p = fin + 1; p < start; p++) {
				d[l] = p; // d[l] 是不同的那一个维度，变为 p 就是在循环看这一位是不是障碍 
				if (check()) {
					cnt = 0;
					break;
				}
			}
			ans[j] += cnt; // 答案更新 
		}
	}
	for (int i = 1; i <= y; i++)
		printf("%d ", ans[i]);
	return 0;
}
``````

---

## 作者：__CJY__ (赞：4)

## 题意简述
[题目传送门](https://www.luogu.com.cn/problem/P11372)。

在 $k$ 维空间中，判断每个教练能看到多少个 OIer，要求视线不能被其他 OIer、障碍物或教练阻挡。
## 思路
~我们先把该读得先读入进来。~

我们遍历所有教练，对于每个教练，执行以下步骤：
* 我们遍历所有 OIer：
  * 对于每个 OIer，检查它是否与当前教练在除了一个维度外其他维度都相同。
  * 如果满足条件，则进一步检查这个不同的维度上，教练和 OIer 之间的线段是否被阻挡：
    1. 首先，我们找到教练和 OIer 在 $k$ 维空间中唯一不同的那个维度，记为 $d$。
    2.  假设教练在维度 $d$ 上的坐标为 $cd$，OIer 在维度 $d$ 上的坐标为 $od$。
    3. 接下来，我们需要遍历所有的 OIer、障碍物和教练（除了当前正在考虑的教练和 OIer），我们检查遍历到的点是否在线段上：对于每个遍历到的点，我们检查它在维度 $d$ 上的坐标 $pd$ 是否位于 $cd$ 和 $od$ 之间，这可以通过简单的比较来实现：如果 $cd<od$，则检查 $cd<pd<od$；如果 $cd>od$，则检查 $od<pd<cd$。
    4. 除了维度 $d$ 之外，我们还需要确保遍历到的点在其他所有维度上都与教练和 OIer 相同。
这意味着，对于除了 $d$ 之外的每个维度 $i$，遍历到的点的坐标 $pi$ 应该等于教练的坐标 $ci$ 和 OIer 的坐标 $oi$。
    5. 如果一个点同时满足上述两个条件（即在维度 $d$ 上位于线段上，且在其他维度上与教练和 OIer 相同），则它阻挡了教练看向 OIer 的视线。一旦找到这样的阻挡点，我们就可以停止对当前 OIer 的检查，并标记教练不能看到这个 OIer；如果没有找到阻挡点，我们继续遍历其他的 OIer、障碍物和教练，如果遍历完所有点后都没有找到阻挡点，则教练可以看到这个 OIer。
    6. 如果教练和 OIer 之间的视线没有被阻挡，则增加计数器。
* 输出计数器。
## 后记
排版可能有点乱，请大家耐心看。

码字不易，打了好久，给个赞吧！

---

## 作者：XiaoHongChong (赞：4)

### 题目
我们需要先明白**坐标系**和**怎样才能互相看见**，注意题目的这两句话：
> 教练可不想看到 OIer 们摸鱼，而只要教练跟某个 OIer 在的坐标之间有且仅有 $k-1$ **维的坐标**相同，并且他们两个人连起来形成的一条**线段**上没有别的障碍或 OIer 或教练，那么那个 OIer 就被发现摸鱼了。  
> ……  
> $\bf{1\le k\le 3}$

这里最高是三位空间。  
看见只能有一个坐标不同！
### $0$ 分代码
为了方便，不足三维的我们就补 $0$，让它变成三维。
```cpp
#include <iostream>
using namespace std;
const int MAX = 1e3 + 5;
int n, k, m, x, y, f[5], ans[MAX];
int a[MAX][5], b[MAX][5], c[MAX][5];
bool ff[MAX][MAX][MAX]; //表示每个位置有没有东西
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> k >> m >> x >> y;
	for (int i = 1; i <= m; i++)
	{
		for (int j = 1; j <= k; j++)
			cin >> a[i][j];
		ff[a[i][1]][a[i][2]][a[i][3]] = true;
	}
	for (int i = 1; i <= x; i++)
	{
		for (int j = 1; j <= k; j++)
			cin >> b[i][j];
		ff[b[i][1]][b[i][2]][b[i][3]] = true;
	}
	for (int i = 1; i <= y; i++)
	{
		for (int j = 1; j <= k; j++)
			cin >> c[i][j];
		ff[c[i][1]][c[i][2]][c[i][3]] = true;
	}
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= y; j++)
		{
            //判断可不可以看见
			int num = 0, pos;
			for (int l = 1; l <= k; l++)
			{
				if (a[i][l] == c[j][l])
					num++;
				else
					pos = l;
				f[l] = a[i][l];
			}
			if (num != k - 1)
				continue;
			bool flag2 = true;
			int maxx = max(a[i][pos], c[j][pos]);
			int minn = min(a[i][pos], c[j][pos]);
			for (int l = minn + 1; l < maxx; l++)
			{
				f[pos] = l;
				if (ff[f[1]][f[2]][f[3]])
					flag2 = false;
			}
			ans[j] += flag2;
		}
	for (int i = 1; i <= y; i++)
		cout << ans[i] << " ";
	return 0;
}
```
递交上去，一片 MLE
### 优化
为什么会 MLE 呢？  
因为 `ff` 数组太大了！  
为了节省空间（AC），可以用 `vector` 来记录位置。   
`ff[x][y]` 存放坐标为 $(x, y, z)$ 的 $z$。
### 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;
const int MAX = 1e3 + 1;
int n, k, m, x, y, f[4], ans[MAX];
int a[MAX][4], b[4], c[MAX][4];
vector <int> ff[MAX][MAX];
//这个函数判断坐标为(X, Y, Z)的位置有没有东西
bool flag(int X, int Y, int Z)
{
	for (int i = 0; i < ff[X][Y].size(); i++)
		if (ff[X][Y][i] == Z)
			return true;
	return false;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> k >> m >> x >> y;
	for (int i = 1; i <= m; i++)
	{
		for (int j = 1; j <= k; j++)
			cin >> a[i][j];
		ff[a[i][1]][a[i][2]].push_back(a[i][3]);
	}
	for (int i = 1; i <= x; i++)
	{
		for (int j = 1; j <= k; j++)
			cin >> b[j];
		ff[b[1]][b[2]].push_back(b[3]);
	}
	for (int i = 1; i <= y; i++)
	{
		for (int j = 1; j <= k; j++)
			cin >> c[i][j];
		ff[c[i][1]][c[i][2]].push_back(c[i][3]);
	}
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= y; j++)
		{
			int num = 0, pos;
			for (int l = 1; l <= k; l++)
			{
				if (a[i][l] == c[j][l])
					num++;
				else
					pos = l;
				f[l] = a[i][l];
			}
			if (num != k - 1)
				continue;
			bool flag2 = true;
			int maxx = max(a[i][pos], c[j][pos]);
			int minn = min(a[i][pos], c[j][pos]);
			for (int l = minn + 1; l < maxx; l++)
			{
				f[pos] = l;
				if (flag(f[1], f[2], f[3]))
					flag2 = false;
			}
			ans[j] += flag2;
		}
	for (int i = 1; i <= y; i++)
		cout << ans[i] << " ";
	return 0;
}
```
使用优化后，内存最高为 $23.47MB$，总共时间 $453ms$。

---

## 作者：canwen (赞：2)

由于一二维随便写都能过，这里先不考虑（不会写的可以见代码）。

考虑到题目中的 $m+x+y\le \min(10^3,n^k)$，我们首先想到我可以考虑用 `map` 来记录位置 $(i,j,k)$ 有无障碍。

我们直接针对每个教练出发求答案，根据维度我们可以知道，对于一维，每个答案上限为 $2$；对于二维，每个答案上限为 $4$；对于三维，每个答案上限为 $6$。

我们根据方向来枚举，$k = 3$ 下最坏情况下对于一个教练我们需要跑 $3n$ 次，也就是总共最坏跑 $3ny$ 次，在本题数据范围下完全可以通过。

然后注意的是每个教练本身也是个障碍，可以直接当成障碍去枚举。

放上赛时代码（经过整理）。


```cpp
#include<bits/stdc++.h>
using namespace std;

#define _rep(i,a,b) for(int i=(a);i<=(b);i++)
#define int long long
#define mp make_pair

const int N = 1e3 + 5;

int n,k,m,x,y,tot,k1[N],k11[N],k2[N][N],k22[N][2];
map < pair<int,pair<int,int> >,int > a;
struct node{
	int x,y,z;
}e[N];

signed main(){
	ios::sync_with_stdio(time(0));
	cin >> n >> k >> m >> x >> y;
	if(k==1){
		int kk;
		_rep(i,1,m) cin >> kk, k1[kk] = 1;
		_rep(i,1,x) cin >> kk, k1[kk] = 2;
		_rep(i,1,y)	cin >> kk, k1[kk] = 2, k11[++tot] = kk;
		_rep(i,1,y){
			int now = k11[i], ans = 0;
			for(int j=now-1;j>=1;--j)
				if(k1[j]){
					if(k1[j]==1) ans++;
					break;
				}
			for(int j=now+1;j<=n;j++)
				if(k1[j]){
					if(k1[j]==1) ans++;
					break;
				}
			cout << ans << " "; 
		}
		return 0;
	}
	if(k==2){
		int u,v;
		_rep(i,1,m) cin >> u >> v, k2[u][v] = 1;
		_rep(i,1,x)	cin >> u >> v, k2[u][v] = 2;
		_rep(i,1,y) cin >> u >> v, k2[u][v] = 2, k22[++tot][0] =u, k22[tot][1]=v; 
		_rep(i,1,y){
			int u = k22[i][0], v=k22[i][1], ans = 0;
			for(int j=u-1;j>=1;--j){
				if(k2[j][v]==2) break;
				if(k2[j][v]==1){
					ans++;
					break;
				} 
			}
			for(int j=u+1;j<=n;++j){
				if(k2[j][v]==2) break;
				if(k2[j][v]==1){
					ans++;
					break;
				} 
			}
			for(int j=v-1;j>=1;--j){
				if(k2[u][j]==2) break;
				if(k2[u][j]==1){
					ans++;
					break;
				} 
			}
			for(int j=v+1;j<=n;++j){
				if(k2[u][j]==2) break;
				if(k2[u][j]==1){
					ans++;
					break;
				} 
			}
			cout << ans << " "; 
		}
		return 0;
	}
	if(k==3){
		int u,v,w;
		_rep(i,1,m) cin >> u >> v >> w, a[mp(u,mp(v,w))] = 1;
		_rep(i,1,x) cin >> u >> v>> w, a[mp(u,mp(v,w))] = 2;
		_rep(i,1,y) cin >> e[++tot].x >> e[tot].y >> e[tot].z, a[mp(e[tot].x,mp(e[tot].y,e[tot].z))] = 2;
		_rep(i,1,y){
			u = e[i].x , v  = e[i].y, w = e[i].z;
			int ans = 0;
			for(int j=w-1;j>=1;j--){
				if(a[mp(u,mp(v,j))]){
					if(a[mp(u,mp(v,j))]==1) ans++;
					break;
				}
			}
			for(int j=w+1;j<=n;j++){
				if(a[mp(u,mp(v,j))]){
					if(a[mp(u,mp(v,j))]==1) ans++;
					break;
				}
			}
			for(int j=v-1;j>=1;j--){
				if(a[mp(u,mp(j,w))]){
					if(a[mp(u,mp(j,w))]==1) ans++;
					break;
				}
			}
			for(int j=v+1;j<=n;j++){
				if(a[mp(u,mp(j,w))]){
					if(a[mp(u,mp(j,w))]==1) ans++;
					break;
				}
			}
			for(int j=u-1;j>=1;j--){
				if(a[mp(j,mp(v,w))]){
					if(a[mp(j,mp(v,w))]==1) ans++;
					break;
				}
			}
			for(int j=u+1;j<=n;j++){
				if(a[mp(j,mp(v,w))]){
					if(a[mp(j,mp(v,w))]==1) ans++;
					break;
				}
			}
			cout << ans << " ";
		}
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

根据题意，一个教练可以发现一个 OIer，当且仅当两者之间恰好有 $k-1$ 个坐标相同，并且在这两点之间的直线上没有其他障碍或人。所以我们输入后先初始化占用状态，再用一个函数检查两点之间的直线段是否为空（即没有障碍物），再用一个函数遍历所有的 OIer，统计满足条件的个数，最后输出。

还有一点，我最开始按照上面的思路写的代码中定义的标记数组是三维的，会超内存，所以我改成了使用哈希表来标记点的位置信息，而不是使用数组。可以看代码理解：

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

const int N = 1e3 + 5;

int n, k, m, x, y, oi[N][3], ob[N][3], co[N][3];
unordered_map<int, bool> vis; // 使用哈希表

int Hs(int p[], int k) // 这个函数用于计算哈希值
{
    int ans = 0;
    for (int i = 0; i < k; i++)
        ans = ans * n + p[i];
    return ans;
}

bool Check(int a[], int b[]) // 检查 a 到 b 的线段上是否存在障碍
{
    for (int i = 0; i < k; i++)
        if (a[i] != b[i])
        {
            int st = min(a[i], b[i]), en = max(a[i], b[i]);
            for (int j = st + 1; j < en; j++)
            {
                int p[3] = {0};
                for (int d = 0; d < k; d++)
                    p[d] = (d == i ? j : a[d]);
                if (vis[Hs(p, k)]) return false;
            }
        }
    return true;
}

int Calc(int x) // 检查每对教练和 OIer 是否满足条件
{
    int ans = 0;
    for (int i = 0; i < m; i++)
    {
        int pos = 0;
        for (int j = 0; j < k; j++)
            if (co[x][j] != oi[i][j]) pos++;
        if (pos == 1 && Check(co[x], oi[i])) ans++;
    }
    return ans;
}

int main()
{
    cin >> n >> k >> m >> x >> y;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < k; j++)
            cin >> oi[i][j];
        vis[Hs(oi[i], k)] = true; // 标记
    }
    for (int i = 0; i < x; i++)
    {
        for (int j = 0; j < k; j++)
            cin >> ob[i][j];
        vis[Hs(ob[i], k)] = true; // 标记
    }
    for (int i = 0; i < y; i++)
    {
        for (int j = 0; j < k; j++)
            cin >> co[i][j];
        vis[Hs(co[i], k)] = true; // 标记
    }
    for (int i = 0; i < y; i++)
        cout << Calc(i) << " \n"[i == y - 1];
    return 0;
}
```

---

## 作者：liyunhe (赞：0)

### 主题思路
由于时间十分充裕有足足 2s，所以可以枚举每一个教练，然后对于每一个教练枚举向 $k$ 个方向的视线。

然后判断是否会被遮挡或看到 OIer。

对于单一的方向可以向左和右看，即分别用循环枚举 $1$ 到当前位置和当前位置到 $n$。然后判断是否有人或障碍，进行统计，向一个方向最多只能看到一个人或障碍，所以可以在找到后直接跳出循环。
### 解决方案
#### 判断该位置有什么的部分
如果可以用数组存下整个房间那就直接用坐标就行，但是由于 $k=3$ 时空间不够所以只能反复找该位置上有什么。

由于不会重合所以对 的查找顺序没有要求。
```cpp
//a,b,c数组的含义如题面，第一维是序号，第二维表示维度
int check(int k1,int k2,int k3){//k1,k2,k3分别代表三个维度
	for(int i=1;i<=m;i++)
		if(a[i][1]==k1&&a[i][2]==k2&&a[i][3]==k3)
			return 1;
	for(int i=1;i<=x;i++)
		if(b[i][1]==k1&&b[i][2]==k2&&b[i][3]==k3)
			return 0;
	for(int i=1;i<=y;i++)
		if(c[i][1]==k1&&c[i][2]==k2&&c[i][3]==k3)
			return 0;
	return -1;//一个位置上还有可能是空的
}
```
#### 3个维度6个方向
以第一个维度为例。要找的范围在 $1\sim n$ 之间。且不能有本身所在的位置。注意控制另外的维度一致，一次只变一个，并且要从中间向两边找。
```cpp
int f1(int k1,int k2,int k3){
	int ans=0;
	bool flag=0;
	for(int i=k1+1;i<=n;i++){//向两个方向找
		int k=check(i,k2,k3);
		if(k>=0){
			flag=k;
			break;//找到OIer、教练、障碍直接跳出循环
		}
	}
	if(flag)ans++;
	flag=0;
	for(int i=k1-1;i>=1;i--){//另一个方向
		int k=check(i,k2,k3);
		if(k>=0){
			flag=k;
			break;
		}
	}
	if(flag)ans++;
	flag=0;
	return ans;
}
```
其它两个维度也大同小异，只是将循环中的 $k1$ 变成 $k2$，$k3$。
### 主要的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005][4],b[1005][4],c[1005][4];
int main(){
  int n,k,m,x,y;
	cin>>n>>k>>m>>x>>y;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=k;j++)cin>>a[i][j];
	for(int i=1;i<=x;i++)
		for(int j=1;j<=k;j++)cin>>b[i][j];
	for(int i=1;i<=y;i++)
		for(int j=1;j<=k;j++)cin>>c[i][j];
	for(int i=1;i<=y;i++){//枚举每个教练
		int k1=c[i][1],k2=c[i][2],k3=c[i][3];
/*如果k<3的情况，剩下的默认是零，不会影响*/
		int ans=f1(k1,k2,k3);//见3个维度6个方向中的定义
		if(k>1)ans+=f2(k1,k2,k3);//第二个维度
		if(k>2)ans+=f3(k1,k2,k3);//第三个维度
		printf("%d ",ans);
	}
	return 0;
}
```

---

## 作者：DFM_O (赞：0)

## [P11372 题目](https://www.luogu.com.cn/problem/P11372)

### 解题思路
首先，对于 $k=1$ 的情况，我们可以枚举每个教练，再依次枚举教练左边格子的情况，若出现 OIer 或障碍或其他教练，就停止枚举，右边同理。

对于 $k=2$ 的情况，只是由一维的左右两个方向变成了二维的上下左右四个方向，其他无区别。

对于 $k=3$ 的情况，由于格子数量达到了 $10^9$ 个，于是需要用映射来存储每个格子的情况，方向又由四个变为了六个，其他无区别。

由于代码很好写并且很长，所以就不放了。

---

## 作者：zhoujiefu (赞：0)

这道题首先要理解题意，题面写得有些复杂，但实际上如果认真读是可以读明白的。一个重点是 $k\le3$ ，所以我们可以用一个结构体里面记录一个数组，这个数组有 $\le 3$ 个数，$a_1,a_2,a_3$ ，分别表示 $k$ 个坐标。

如果暴力模拟，我们发现数组要开到 $10^9$ ，显然开不下。考虑记录一下每个教练会被哪个障碍或教练（以下统称阻挡物）阻挡，如果有 OIer 比阻挡物更靠近教练，那么这个教练是可以看到这个 OIer 的。但是还有一种情况，在某个方向上有不止一个 OIer 比阻挡物更近，如果直接算会算重。所以我们再开一个数组来记录每个方向上有没有算过，如果没算过再计入答案。时间复杂度为 $O(yk(m+y+k))$
    
因为 $m+x+y\le10^3$ 所以能过。

具体实现稍微有一点复杂，见代码。

```cpp
#include<bits/stdc++.h>
#define int long long
#define rep(i,a,b) for(register int i=a;i<=b;i++)
#define per(i,a,b) for(register int i=a;i>=b;i--)
#define debug() puts("YYYYY")
using namespace std;
template<class T>
inline void read(T &x){
	bool f=1;x=0;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();
	x=f?x:-x;
}
template<class T>
inline void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
const int N=1e3+5;
struct node{
	int a[3],b[3][2];
	bool bb[3][2];//第一维表示是第几个坐标，第二位表示坐标小于自己还是大于自己
	node(){b[0][0]=b[0][1]=b[1][0]=b[1][1]=b[2][0]=b[2][1]=1e9;}
}O[N],Z[N],C[N];
int mpa[N],mpb[N][N];
signed main(){
	int n,kkk,m,x,y;
	cin>>n>>kkk>>m>>x>>y;
	for(int i=1;i<=m;i++) for(int j=0;j<kkk;j++) cin>>O[i].a[j];
	for(int i=1;i<=x;i++) for(int j=0;j<kkk;j++) cin>>Z[i].a[j];
	for(int i=1;i<=y;i++) for(int j=0;j<kkk;j++) cin>>C[i].a[j];
	for(int i=1;i<=y;i++){//考虑每个方向上的阻挡物的位置
		for(int j=1;j<=x;j++){//障碍
			int cnt=0;
			for(int k=0;k<kkk;k++) if(C[i].a[k]==Z[j].a[k]) cnt++;
			if(cnt!=kkk-1) continue;
			for(int k=0;k<kkk;k++){
				if(C[i].a[k]!=Z[j].a[k]){
					if(Z[j].a[k]<C[i].a[k]) C[i].b[k][0]=min(C[i].b[k][0],abs(Z[j].a[k]-C[i].a[k]));
					else C[i].b[k][1]=min(C[i].b[k][1],abs(Z[j].a[k]-C[i].a[k]));
				}
			}
		}
		for(int j=1;j<=y;j++){//教练
			if(i==j) continue;
			int cnt=0;
			for(int k=0;k<kkk;k++) if(C[i].a[k]==C[j].a[k]) cnt++;
			if(cnt!=kkk-1) continue;
			for(int k=0;k<kkk;k++){
				if(C[i].a[k]!=C[j].a[k]){
					if(C[j].a[k]<C[i].a[k]) C[i].b[k][0]=min(C[i].b[k][0],abs(C[j].a[k]-C[i].a[k]));
					else C[i].b[k][1]=min(C[i].b[k][1],abs(C[j].a[k]-C[i].a[k]));
				}
			}
		}
	}
	for(int i=1;i<=y;i++){//计算答案
		int ans=0;
		for(int j=1;j<=m;j++){
			int cnt=0;
			for(int k=0;k<kkk;k++) if(C[i].a[k]==O[j].a[k]) cnt++;
			if(cnt!=kkk-1) continue;
			for(int k=0;k<kkk;k++){
				if(C[i].a[k]!=O[j].a[k]){
					if(O[j].a[k]<C[i].a[k]){
						if(abs(O[j].a[k]-C[i].a[k])<C[i].b[k][0]&&!C[i].bb[k][0]) ans++,C[i].bb[k][0]=1;
					}
					else{
						if(abs(O[j].a[k]-C[i].a[k])<C[i].b[k][1]&&!C[i].bb[k][1]) ans++,C[i].bb[k][1]=1;
					}
				}
			}
		}
		cout<<ans<<' ';
	}
	return 0;
}

```

---

## 作者：signed_long_long (赞：0)

# 题目解法

枚举每个教练的视线（即枚举从教练的点出发所有 $k-1$ 个坐标相同的点），如果那个点上有教练或障碍，那么视线被阻挡，跳出循环；如果那个点上有 OIer，那么那个 OIer 被发现，答案加一，否则继续。

没听懂的看代码（有点长，但大多数都是重复的）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int m,x,y,p,l,i,j;
short OIer[1005][4],teacher[1005][4],ans,same,bd;
short za[1005][4];
//bool vis[1005];
//bool h[1001][1001][1001];
bool flag;
//bitset<1005,1005,1005>h;
int check(int q,int w,int r){
	for(int i=1;i<=y;i++){
		if(teacher[i][1]==q and teacher[i][2]==w and teacher[i][3]==r){
			return 0;
		}
	}
	for(int i=1;i<=x;i++){
		if(za[i][1]==q and za[i][2]==w and za[i][3]==r){
			return 0;
		}
	}
	for(int i=1;i<=m;i++){
		if(OIer[i][1]==q and OIer[i][2]==w and OIer[i][3]==r){
//			printf("\n%d %d %d %d\n",q,w,r,i);
			return 1;
		}
	}
	return 2;
}
int main(){
// 	cout<<sizeof h;
	cin>>n>>k;
	cin>>m>>x>>y;
	for(i=1;i<=m;i++){
		for(j=1;j<=k;j++) cin>>OIer[i][j];
	}
	for(i=1;i<=x;i++){
		for(j=1;j<=k;j++) cin>>za[i][j];
	}
	for(i=1;i<=y;i++){
		for(j=1;j<=k;j++) cin>>teacher[i][j];
	}
	//-------------------------
	for(i=1;i<=y;i++){
		ans=0;
		int q=teacher[i][1],w=teacher[i][2],e=teacher[i][3];
		flag=false;
		if(k==1){//枚举左、右
			for(int r=q+1;r<=n;r++){
				int qqq=check(r,w,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=q-1;r>=1;r--){
				int qqq=check(r,w,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
		}else if(k==2){//枚举上、下、左、右
			for(int r=q+1;r<=n;r++){
				int qqq=check(r,w,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=q-1;r>=1;r--){
				int qqq=check(r,w,e);
//				printf("\n%d %d %d %d\n",qqq,r,w,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=w+1;r<=n;r++){
				int qqq=check(q,r,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=w-1;r>=1;r--){
				int qqq=check(q,r,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
		}else{//枚举上、下、左、右、前、后
			for(int r=q+1;r<=n;r++){
				int qqq=check(r,w,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=q-1;r>=1;r--){
				int qqq=check(r,w,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=e+1;r<=n;r++){
				int qqq=check(q,w,r);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=e-1;r>=1;r--){
				int qqq=check(q,w,r);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=w+1;r<=n;r++){
				int qqq=check(q,r,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
			for(int r=w-1;r>=1;r--){
				int qqq=check(q,r,e);
				if(qqq==0) break;
				if(qqq==1){
					flag=true;
					break;
				}
			}
			if(flag) {ans++;}
			flag=false;
		}
		printf("%d ",ans);
	}
//	puts("");
//	for(int i=1;i<=n;i++){
//		for(int j=1;j<=n;j++){
//			cout<<(h[i][j][0]);
//		}
//		puts("");
//	}
	return 0;
} 
```

---

## 作者：wdsjl (赞：0)

## 题目大意

机房被看作维正方体，有 $m$ 个摸鱼的、$x$ 个障碍与 $y$ 个教练处于不同坐标。教练发现摸鱼,需满足坐标有且仅有 $k-1$ 维相同且连线无其他干扰。

## 解题思路

1. **方向与人数上限**：因 $k$ 维空间，教练最多有 $2k$ 个观察方向，理论最多发现 $2k$ 个摸鱼。
2. **预处理最近障碍**：将教练当作障碍，遍历所有障碍与教练比较。对满足 $k-1$ 维坐标差异的障碍，依其与教练坐标大小关系，更新对应方向最近障碍信息。
3. **处理学生**：对每个学生，先查是否满足 $k-1$ 维坐标差异条件，不符则跳过。符合时，对比学生与对应方向最近障碍到教练距离，更近则更新学生为新最近对象，标记并统计。
4. **统计结果**：统计各方向最近为学生的方向数，即教练发现摸鱼数量。

注释非常详细！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX_SIZE = 1e3 + 5;
// 机房空间（看作k维正方体）的边长
int n;  
// 机房空间的维数
int dt;  
// OIer（正在摸鱼的人员）的数量
int ot;  
// 原本障碍的数量
int oc;  
// 教练的数量
int ct;  

// os数组用于存储OIer的坐标信息，第一维表示第几个OIer，第二维表示坐标维度
int os[MAX_SIZE][5];  
// all数组用于存储障碍（包含后面当作障碍处理的教练）的坐标信息，第一维表示第几个障碍（教练也算在内了），第二维表示坐标维度
int all[2 * MAX_SIZE][5];  
// cs数组用于单独存储教练的坐标信息，方便后续处理时区分使用，第一维表示第几个教练，第二维表示坐标维度
int cs[MAX_SIZE][5];  

// nr数组用于存储每个方向上到教练最近的障碍相关信息，nr[0][i]表示在某个维度上坐标小于教练坐标方向（可理解为“左”方向）的最近障碍坐标
// nr[1][i]表示在某个维度上坐标大于教练坐标方向（可理解为“右”方向）的最近障碍坐标
int nr[2][5];  
// vis数组用于标记每个方向上到教练最近的是不是学生，vis[0][i]对应“左”方向，vis[1][i]对应“右”方向
bool vis[2][5];  

// solve函数用于处理单个教练能发现的摸鱼OIer的数量，参数now表示当前处理的是第几个教练
void solve(int now) {
    int fn = 0;
    // 初始化nr数组，将nr[0]各元素置为0，通常用于记录较小值（类似左方向）时的初始比较基础
    memset(nr[0], 0, sizeof(nr[0]));  
    // 初始化nr[1]各元素为一个较大值（0x7f在本题情境下可当作一个相对很大的值用于后续比较更新）
    // 用于记录较大值（类似右方向）时的初始比较基础，方便后续找到更小的更近的值来更新
    memset(nr[1], 0x7f, sizeof(nr[1]));  
    // 初始化vis数组，将所有标记都置为false，表示初始时各方向上最近的都不是学生
    memset(vis, 0, sizeof(vis));  

    // 预处理障碍（这里的障碍包含了当作障碍处理的教练），遍历所有的障碍
    for (int i = 1; i <= oc; i++) {
        int solve = 0;  // solve用于记录当前障碍与教练有几个维度的坐标是相同的，初始化为0
        int dif = -1;  // dif用于记录第一个不同的维度编号，初始化为 -1，表示未找到不同维度
        // 遍历每个维度，判断当前障碍与当前教练在该维度上的坐标是否相同
        for (int j = 1; j <= dt; j++) {
            if (all[i][j]!= cs[now][j]) {
                dif = j;  // 如果坐标不同，记录下这个不同的维度编号
            } else {
                solve++;  // 如果坐标相同，相同维度数量加1
            }
        }
        // 如果相同维度数量不等于dt - 1，说明不满足发现摸鱼条件里关于坐标维度差异的要求，直接跳过该障碍
        if (solve!= dt - 1) continue;  
        // 如果在某个维度上，当前障碍的坐标小于教练在该维度的坐标，更新对应“左”方向上的最近障碍坐标
        if (all[i][dif] < cs[now][dif])
            nr[0][dif] = max(nr[0][dif], 
                                                             all[i][dif]);  
        else
            // 如果在某个维度上，当前障碍的坐标大于教练在该维度的坐标，更新对应“右”方向上的最近障碍坐标
            nr[1][dif] = min(nr[1][dif], 
                                                              all[i][dif]);  
    }

    // 对每个学生进行处理，遍历所有的学生
    for (int i = 1; i <= ot; i++) {
        int solve = 0;
        int dif = -1;
        // 同样遍历每个维度，判断当前学生与当前教练在各维度上的坐标异同情况
        for (int j = 1; j <= dt; j++) {
            if (os[i][j]!= cs[now][j]) {
                dif = j;
            } else {
                solve++;
            }
        }
        // 如果不满足有且仅有dt - 1维坐标不同的条件，跳过该学生
        if (solve!= dt - 1) continue;  
        // 如果学生在某个维度上的坐标小于教练坐标，且大于该维度“左”方向上已记录的最近障碍坐标
        if (os[i][dif] < cs[now][dif] && os[i][dif] > nr[0][dif]) {
            // 更新“左”方向上的最近坐标为该学生的坐标
            nr[0][dif] = os[i][dif];  
            // 如果该方向上之前最近的不是学生，说明发现了新的可被发现摸鱼的学生，数量加1，并标记该方向最近的是学生
            if (!vis[0][dif]) {  
                fn++;
                vis[0][dif] = 1;
            }
        }
        // 如果学生在某个维度上的坐标大于教练坐标，且小于该维度“右”方向上已记录的最近障碍坐标
        if (os[i][dif] > cs[now][dif] && 
            os[i][dif] < nr[1][dif]) {
            // 更新“右”方向上的最近坐标为该学生的坐标
            nr[1][dif] = os[i][dif];  
            // 如果该方向上之前最近的不是学生，说明发现了新的可被发现摸鱼的学生，数量加1，并标记该方向最近的是学生
            if (!vis[1][dif]) {  
                fn++;
                vis[1][dif] = 1;
            }
        }
    }
    // 输出当前教练能发现的摸鱼OIer的数量
    cout << fn <<' ';  
}

int main() {
    // 输入机房空间的边长、维数、OIer的数量、原本障碍的数量以及教练的数量
    cin >> n >> dt >> ot >> oc >> ct;  
    // 循环读取每个OIer的坐标信息，外层循环控制第几个OIer，内层循环控制坐标维度
    for (int i = 1; i <= ot; i++)
        for (int j = 1; j <= dt; j++)
            cin >> os[i][j];  
    // 循环读取每个障碍的坐标信息，外层循环控制第几个障碍，内层循环控制坐标维度
    for (int i = 1; i <= oc; i++)
        for (int j = 1; j <= dt; j++)
            cin >> all[i][j];  
    // 循环读取每个教练的坐标信息，外层循环控制第几个教练，内层循环控制坐标维度
    // 同时将教练的坐标信息添加到障碍坐标数组all中，将教练当作障碍处理，方便后续统一处理
    for (int i = 1; i <= ct; i++)
        for (int j = 1; j <= dt; j++) {
            cin >> cs[i][j];
            all[oc + i][j] = cs[i][j];
        }
    // 更新障碍的总数，将教练数量加到原本的障碍数量上，因为教练已经当作障碍看待了
    oc += ct;  
    // 对每个教练调用solve函数，统计并输出每个教练能发现的摸鱼OIer的数量
    for (int i = 1; i <= ct; i++)
        solve(i);  
    return 0;
}
```

---


# 「DLESS-1」回文括号序列

## 题目背景

小 A 非常喜欢回文串与括号序列，但是一天，小 B 告诉了他一个绝望的事实：不存在回文的非空合法括号序列。

## 题目描述

小 A 定义一个括号序列 $S$ 的权值为 $f(S)=\sum_{i=1}^{\lvert S\rvert}[S_i=S_{\lvert S\rvert-i+1}]$（字符串下标从 $1$ 开始），即 $S$ 与翻转后的 $S$ 括号相同的位置数。

给定 $n$，你需要构造出一个长度为 $n$ 的合法括号序列 $S$，最大化它的权值 $f(S)$。如果不存在长度为 $n$ 的合法括号序列，输出 $-1$。

## 说明/提示

#### 【样例解释】

对于 $n=6$，`()(())` 的权值为 $4$，可以证明不存在权值更大的满足条件的括号序列。

#### 【数据范围】

记 $\sum n$ 为单测试点内每组测试数据 $n$ 之和。

对于所有数据，$1\le T,n\le 10^5$，$1\le\sum n\le 10^6$。

**本题开启子任务捆绑测试。**

- Subtask 1（5 pts）：$n\le 8$，$\sum n\le 36$。
- Subtask 2（20 pts）： $n\le 20$，$\sum n\le155$。
- Subtask 3（25 pts）：$n\le 100$，$\sum n\le 500$。
- Subtask 4（20 pts）：$n\le 10^3$，$\sum n\le 10^4$。
- Subtask 5（30 pts）：无特殊限制。

## 样例 #1

### 输入

```
6
1
2
3
4
5
6```

### 输出

```
-1
()
-1
()()
-1
()(())
```

# 题解

## 作者：Rigel (赞：27)

## 思路

若数 $n$ 为奇，无可解之法，此其显然者也。

若数 $n$ 为偶，则有构造之法曰：

首位必为 `(`，末位必为 `)`。

其间余空位 $n-2$ 处。


分之为二部，$[2,m]$ 置 `)(`，$[m+1,n-1]$ 置 `()`。

其 $m$ 之值定法曰：

$m=\begin{cases}\dfrac{n}{2 }& \dfrac{n}{2} \equiv 1 \pmod{2}, \\ \\ \dfrac{n}{2} - 1 & \mathop{\operatorname{otherwise}}. \end{cases}$

今证此构造之法合法：

左部所置 `)(` 中，凡右括恒能与前者 `)(` 之左括相配，或与首左括相配；凡左括恒可与后者 `)(` 之右括相配，或与末右括相配。

右部所置 `()` 显然合法。

左部左括恒与右部左括相应，右部亦然。惟当 $\dfrac{n}{2} \equiv 0 \pmod{2}$ 时，中位二括必不可同。

是时，$f(S)$ 至大。

综上，此构造之法合法，又可极 $f(S)$ 之至大者也。

## 现代文版本

当 $n$ 为奇数时显然无解。

当 $n$ 为偶数时，我们有如下的构造方案：

首先位置 $1$ 一定是 `(`，位置 $n$ 一定是 `)`。

中间有 $n-2$ 个空位。


将其分成两半，$[2,m]$ 放置 `)(`，$[m+1,n-1]$ 放置 `()`。

其中，$m=\begin{cases}\dfrac{n}{2 }& \dfrac{n}{2} \equiv 1 \pmod{2}, \\ \\ \dfrac{n}{2} - 1 & \mathop{\operatorname{otherwise}}. \end{cases}$

接下来证明这样构造的 $S$ 合法。

左半边放置的 `)(` 中，右括号总能与上一个放置的 `)(` 中的左括号匹配，或与第一个左括号匹配；左括号总能与下一个放置的 `)(` 中的右括号匹配，或与最后一个右括号匹配。

右半边放置的 `()` 显然合法。

左半边的左括号总能与右半边的左括号对应，右半边同理。除了当 $\dfrac{n}{2} \equiv 0 \pmod{2}$ 时，中间的两个括号不可能相同。

此时 $f(S)$ 最大。

综上，此构造方案合法，且可最大化 $f(S)$。

## Code

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

int T,n; 

inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')ret=ret*10+(ch&15),ch=getchar();
	return ret*f;
}

void _solve(){
	n=read();
	if(n&1){
		printf("-1\n");
		return;
	}
	printf("(");
	for(int i=1;i<=(n-2)>>1;i++){
		if(i<=(n-2)>>2)printf(")(");
		else printf("()");
	}
	printf(")\n");
}

signed main(){
	T=read();
	while(T--)_solve();
	return 0; 
}
```

---

## 作者：Make_China_Great (赞：12)

## 思路

首先，先排除 $n\bmod 2=1$ 的情况，因为合法子序列的左括号数量和右括号数量应该是相等的，而奇数个不可能相等，也就是说明 $n\bmod 2=1$ 时没有合法括号子序列。

然后看样例，赛场上，我先打了个表，毕竟剩下的答案都有了，就差 $n=8$ 了，试也能试出来了。

打表代码如下：


```cpp
#include<iostream>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        int n;
        cin>>n;
        if(n%2){
            cout<<"-1\n";
            continue;
        }
        if(n==2)cout<<"()\n";
        else if(n==4)cout<<"()()\n";
        else if(n==6)cout<<"()(())\n";
        else if(n==8)cout<<"()()(())\n";
    }
    return 0;
}
```

然后，我继续打表，打出了 $n\le 20$ 的所有数据，拿了 25pts。

此时，我发现了规律。

当 $n\bmod 4=2$ 时，先有 $(n-2)\div 4$ 对括号，然后一个括号里面有包含了 $(n-2)\div 4$ 对括号。

比如：

| $n$    |  括号  |
| :-:    |  :-:   | 
|  $10$  |  `()()(()())`   |
|  $14$  |  `()()()(()()())`   |
|  $18$  |  `()()()()(()()()())`   |
|  $22$  |  `()()()()()(()()()()())`   |

可以证明，在 $n\bmod 4=2$ 时 $f(S)$ 最大为 $n-2$。

当 $n\bmod 4=0$ 时，先有 $n\div 4$ 对括号，然后一个括号里面有包含了 $(n-4)\div 4$ 对括号。

比如：

| $n$    |  括号  |
| :-:    |  :-:   | 
|  $8$  |  `()()(())`   |
|  $12$  |  `()()()(()())`   |
|  $16$  |  `()()()()(()()())`   |
|  $20$  |  `()()()()()(()()()())`   |

可以证明，在 $n\bmod 4=0$ 时 $f(S)$ 最大为 $n-4$。

然后，就可以过了。

## 代码


```cpp
#include<iostream>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        int n;
        cin>>n;
        if(n%2){
            cout<<"-1\n";
            continue;
        }
        if(n==2)cout<<"()\n";
        else if(n==4)cout<<"()()\n";
        else if(n==6)cout<<"()(())\n";
        else if(n==8)cout<<"()((()))\n";
        else if(n==10)cout<<"()()(()())\n";
        else if(n==12)cout<<"()()()(()())\n";
        else if(n==14)cout<<"()()()(()()())\n";
        else if(n==16)cout<<"()()()()(()()())\n";
        else if(n==18)cout<<"()()()()(()()()())\n";
        else if(n==20)cout<<"()()()()()(()()()())\n";
        else{
            for(int i=1;i<=n/4;i++)
                cout<<"()";
            cout<<"(";
            if(n%4==2)for(int i=1;i<=n/4;i++)
                cout<<"()";
            if(n%4==0)for(int i=1;i<n/4;i++)
                cout<<"()";
            cout<<")";
            cout<<endl;
        }
    }
    return 0;
}
```

## 结语

是不是很简单啊？

求给个赞。

---

## 作者：喵仔牛奶 (赞：9)

## Solution

合法括号序列第一个字符是 `(`，最后一个字符是 `)`，这两个字符是确定的。可以发现 $n$ 为奇数无解，考虑 $n\bmod 4$。

对于 $n\equiv 2\pmod 4$，构造如下：
$$(\text{ }\text{ }\underbrace{()\text{ }()\cdots()}_{n/2-1}\text{ }\text{ }\text{ }\underbrace{)(\text{ })(\cdots)(}_{n/2-1}\text{ }\text{ })$$

可以发现 $f(S)=n-2$。对于合法括号序列 $S$ 有 $S_1\neq S_{n}$，故 $f(S)\le n-2$，该构造达到了上界。

对于 $n\equiv 0\pmod 4$，构造如下：
$$((\text{ }\text{ }\underbrace{()\text{ }()\cdots()}_{n/2-2}\text{ }\text{ }\text{ }\underbrace{)(\text{ })(\cdots)(}_{n/2-2}\text{ }\text{ }))$$

可以发现 $f(S)=n-4$。如果 $f(S)=n-2$ 且 $n\equiv 0\pmod 4$，由于 $n/2-1$ 为奇数，$[2,n/2]$ 内左右括号数不等，又因为 $f(S)=n-2$，有 $\forall i\in[n/2+1,n),S_i=S_{n-i+1}$，所以 $[n/2+1,n]$ 内左/右括号数与 $[2,n/2]$ 内左/右括号数分别相等，故 $[2,n)$ 内左右括号数不等，不是合法括号序列。故 $f(S)\le n-4$，该构造达到了上界。

---

## 作者：ShiYuXuan1234 (赞：6)

## 题意简述
给你一个 $n$，让你给出一个权值最大的仅由`(`和`)`组成的回文括号序列，其中，权值 $f(S)$ 的定义如下：
$$f(S)=\sum^{|S|}_{i=1}[S_i=S_{|S|-i+1}]$$
（字符串 $S$ 的下标从 $1$ 开始）

## 思路
一个回文括号序列 $S$ 要至少由一个完整的括号`()`组成，则代表着，序列 $S$ 的长度 $|S|$ 必须为 $2$ 的倍数，因此，当 $n$ 为奇数时，可直接输出 $-1$，反之则一定能构造成功。

看到“尽可能大”这四个字，我们必须立马想到：这题应当用到贪心思想。

为了让该序列合法且权值尽可能大，根据权值的定义，我们可以将 $S$ 从中间分为两部分考虑，为了保证序列合法，将两端分别设为`(`和`)`。随后，我们会发现，当 $i=2$ 时，我们必须用右括号`)`来补全 $S_1$ 处的左括号`(`，那么，根据贪心思想，我们也应该将右边部分的 $S_{n-2}$ 设为`)`。同理，我们需要将 $S_{n-3}$ 设为`(`以补全 $S_{n-2}$ 处的`)`，并将 $S_3$ 也设为`(`，以此类推。那么，经过上述步骤，即可构造出如下序列（这里以 $n=10$ 举例，其中，`_`表示还未确定的位置）：

`()()_()())`

不难看出，此时仅剩 $S_n$ 处的`)`没有对应的`(`补全，那么，$S_{n\div2}$ 处就可以被设为`(`来完成这个回文括号序列了。

然而，此时还没完。多构造几组序列后，我们就可以发现，在 $S_{n\div2}$ 前的位置全部为`()`，而 $S_{n\div2}$ 及以后则由一组`()`将剩余的仅由`()`组成的子串括起来，组成了这个权值最大的回文括号序列。根据这个发现，我们也就得到了如下代码：
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		if(n%2==1){//奇数直接输出-1
			cout<<"-1";
		}else{
			n/=2;//这里n表示需要多少个括号，便于理解
			for(int i=0;i<n/2;i++){//前一半
				cout<<"()";
			}
			cout<<"(";
			for(int i=0;i<n-n/2-1;i++){//后一半
				cout<<"()";
			}
			cout<<")";
		}
		cout<<endl;
	}
	return 0;
}
```
最后，[AC 记录](https://www.luogu.com.cn/record/216879227)。

---

## 作者：qwqerty (赞：3)

# 解题思路
很显然在 $n$ 为奇数的时候没有合法括号序列，直接判掉。

注意到构造 $\left\lfloor\dfrac{n}{4} \right\rfloor\times \texttt{()}+\texttt{(}+\left\lfloor\dfrac{n+2}{4}\right\rfloor\times\texttt{()}+\texttt{)}$。即可满足在 $n\bmod4=0$ 时代价为 $n-4$，$n\bmod4=2$ 时代价为 $n-2$。其中 $+$ 代表的是字符串拼接，$\times$ 代表的是多个相同的字符串拼接。  

根据题目背景可得，不存在代价为 $n$ 的合法括号序列，$n\bmod4=2$ 的情况更优。考虑证明 $n\bmod4=0$ 的情况，显然左右两端的括号不同。如果存在一个代价为 $n-2$ 的合法括号序列，则去掉左右两端的括号后会留下一个回文子串。由于回文串左端为奇数，则必定能找得到一个括号无法匹配。由于回文性质，右边也一定存在一个相同的括号无法匹配。无法构成合法括号序列。

故该构造合法。

---

## 作者：jms23012 (赞：1)

## 题目大意

构造一个[合法](https://www.luogu.com.cn/problem/P5658)括号序列 $S$，使之与其翻转后得到的括号序列 $S _ {1}$ 括号相同的位置数最多。

## 题目分析

首先我们知道，一个合法括号串一定包含等量的左括号和右括号，即**合法括号串的括号总数一定是偶数**。

其次，合法括号串的第一个括号一定是左括号，最后一个括号一定是右括号，否则无法找到一个对应的括号与之匹配。

我们以一共包含 $6$ 个括号的括号串为例。

![](https://img.picui.cn/free/2025/05/11/68209a18d20b3.png)

接下来，为了最大化括号相同的位置数，我们需要**在翻转后位置相同的格子填上相同方向的括号**，这里默认以右括号为例。

![](https://img.picui.cn/free/2025/05/11/68209bd3dffe8.png)

为了保证两种括号的个数相等且括号串合法，我们需要在下一对翻转后位置相同的两个格子上填入左括号。

![](https://img.picui.cn/free/2025/05/11/68209d600b0f3.png)

所以我们构造出了合法的括号串，并且得出，有 $6$ 个括号的括号串最多有 $3$ 个括号的位置翻转后相同。

注意：**两种括号的填入必须是依次的，否则就会造成尾部某个子串中的左括号比右括号多这类情况，此时括号串不合法。**

但是还有一种情况，例如有 $8$ 个括号的括号串。

![](https://img.picui.cn/free/2025/05/11/6820a17e590bc.png)

按照上面的思路，当我们进行到最后一步时，理应填入右括号，但当我们真的填入右括号时，却发现括号串 $S$ 变成了非法括号串。

为什么会这样呢？

原来，当我们两两填入左括号与右括号时，进行偶数次操作后，左括号与右括号的个数是相同的。但是如果操作总数是奇数时，最后的括号串中就会出现一种括号的个数比另一种括号多两个的情况。

如何改正呢？也非常简单。这时只能放弃最后两个括号的配对，填入一个左括号，一个右括号，才能将括号串修正为合法括号串。

简而言之，**当操作总数为奇数时，最后一次操作不可以填入两个相同的括号**。

## 代码实现

代码还算好写，如下。


```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    for(int i=1;i<=t;i++){
        int n;
        cin>>n;
        if(n%2) cout<<-1<<endl; //合法括号串的括号总数不可能是奇数。
        else{
        	char c[100005];
        	c[1]='(';
        	c[n]=')';
        	bool cmp=0; //判断当前应该填入左括号还是右括号。
        	for(int i=2,j=n-1;i<=j;i++,j--){
        		if(i+1==j&&cmp==0){
        			c[i]='(',c[j]=')';
					break; //此时不可以填入两个相同的括号。
				}
				if(cmp==0) c[i]='(',c[j]='(';
        		if(cmp==1) c[i]=')',c[j]=')';
        		cmp^=1;
			}
			for(int i=1;i<=n;i++){
				cout<<c[i];
			}
			cout<<endl;
		}
    }
    return 0;
}
```

## 总结

主要难点在于想出正确匹配正反串括号的策略，是一道有一丢丢思维难度的好题，希望这篇题解可以帮到大家。

---

## 作者：Besheep (赞：1)

## Solution 
显然 $n\bmod 2=1$ 没有构造方案。

考虑将序列的两端分别固定为 $($ 和 $)$。

当 $n=10$ 时，以 $S=\large{\{(\textcolor{red}{(}\textcolor{blue}{)}\textcolor{green}{(}\textcolor{orange}{)}\textcolor{orange}{)}\textcolor{green}{(}\textcolor{blue}{)}\textcolor{red}{(})\}}$ 的形式构造。

此时 $f(S)=8$，由于左右两边必须固定，显然这种构造方法权值最大，推广开来，$f(S)=n-2$。

发扬人类注意力，我们发现，当 $n\bmod 4=0$ 时，此时 $S=\large{\{(\textcolor{red}{(}\textcolor{blue}{)}\textcolor{green}{(}\textcolor{green}{(}\textcolor{blue}{)}\textcolor{red}{(})\}}$，显然此时无法构成一个合法的括号序列，考虑牺牲中间部分改为 $S=\large{\{(\textcolor{red}{(}\textcolor{blue}{)}\textcolor{green}{(}\textcolor{green}{)}\textcolor{blue}{)}\textcolor{red}{(})\}}$，$f(S)=4$，权值依旧最大，推广开来，$f(S)=n-4$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+10;
ll T,n,ans[N];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>T;
    while(T--){
    	cin>>n;
    	if(n%2==1) cout<<-1<<'\n';
    	else{
    		ll temp=n-2;
    		ans[1]=0,ans[n]=1;
    		for(int i=2;i<=n/2;i++){
    			if(i%2==0){
    				ans[i]=0,ans[n-i+1]=0;
				}
				else{
					ans[i]=1,ans[n-i+1]=1;
				}
			}
			if((n/2)%2==0) ans[n/2]=(ans[n/2]+1)%2;
			for(int i=1;i<=n;i++){
				if(ans[i]==0) cout<<'(';
				else cout<<')';
			}
			cout<<'\n';
		}	
	}
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：1)

# P12497 题解

## 思路

如果 $n$ 是奇数，则显然无法构造出任何一组合法括号序列，总会留下一个括号无法配对。

为了构造出合法括号序列，$S_1$ 必定为左括号，$S_n$ 必定为右括号。

接下来考虑如何将答案最大化。

令 $S_2$ 与 $S_{n-1}$ 都为右括号，会发现 $S_2$ 与 $S_1$ 配对，留下 $S_{n-1}$ 与 $S_n$ 两个未匹配的右括号，于是令 $S_3$ 与 $S_{n-2}$ 都为左括号，此时将右侧两个右括号消掉，会发现现在的情况就和刚放完 $S_1$ 与 $S_n$ 的时候一样，都是合法序列。

于是可以两个右括号两个左括号交替放置，但只有放完两个左括号的时候才是合法括号序列，因此当 $n+2$ 是 $4$ 的倍数时，恰好放完两个左括号，若不是 $4$ 的倍数，则将最中间的两个右括号换为左括号与右括号，使得序列合法。

当然，$S_2$ 和 $S_{n-1}$ 也可以从左括号开始，只需修改小部分内容即可。

## 代码

```cpp
const int N=100005;

int T,n;
char s[N];

int main() {
    read(T);
    while (T--) {
        read(n);
        if (n&1) writeln(-1);
        else if ((n+2)%4==0) {
            s[1]='(';
            s[n]=')';
            int i=2,j=n-1;
            while (i<j) {
                if (i&1) s[i++]=s[j--]='(';
                else s[i++]=s[j--]=')';
            }
            _rep(i,1,n) putchar(s[i]);
            putchar(10);
        } else {
            s[1]='(';
            s[n]=')';
            int i=2,j=n-1;
            while (i<j) {
                if (i&1) s[i++]=s[j--]='(';
                else s[i++]=s[j--]=')';
            }
            s[j]='(',s[i]=')';
            _rep(i,1,n) putchar(s[i]);
            putchar(10);
        }
    }
    return 0;
}
```

---

## 作者：wurang (赞：1)

注意到 $1 \le T,n \le 10^5$，考虑 $O(1)$ 贪心。

考虑到 `()` 的回文串为 `)(`，希望左边放连续的 `()`，右边放连续的 `)(`。不难发现可行的一种贪心格式为 `(` + $\frac{n-2}{4}$ 个 `()` + `)` + $\frac{n-2}{4}$ 个 `)(` + `)`。

此时需要保证 $4|n-2$，对于 $4|n$ 时我们在左边多放一个 `()` 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

int T, n;

int main()
{
	cin >> T;
	while(T--)
	{
		cin >> n;
		if(n % 2 == 1) {cout << "-1\n"; continue;}
		if(n == 2) cout << "()\n";
		else if(n == 4) cout << "()()\n";
		else
		{
            cout << '(';
            if((n-2)%4 == 0)
            {
    			for(int i = 1; i <= (n-2)/4; i++) cout << "()";
    			for(int i = 1; i <= (n-2)/4; i++) cout << ")(";
            }
            else
            {
                cout << "()"; // 多放一组括号
                n -= 2;
    			for(int i = 1; i <= (n-2)/4; i++) cout << "()";
    			for(int i = 1; i <= (n-2)/4; i++) cout << ")(";
            }
            cout << ")\n";
		}
	}
	return 0;
}
```

---

## 作者：yedalong (赞：1)

## Solution

构造策略题。

首先，很容易发现当 $n$ 为奇数时答案是 $-1$，因为此时构造出来的序列一定不合法。

接下来我们来看一下其他情况。以样例 $n=6$ 来找一找规律。首先，序列的左边一定是 `(`，右边一定是 `)`，因此先构造序列 `()`，接着在中间继续添加。为了让其尽可能回文，因此变成了这样 `((()`，继续往中间添加，为了让其平衡，因此得添加 `)`，所以变成了这样：`(())()`，发现符合要求！

接着我们来自己想一下 $n=8$ 的例子。按照上面的思路一直添加，会变成这样：`(()(()()`，发现出问题了！但是这时候如果我们中间少添加一次，改为两边添加一次，就变成这样：`((())())`，经检验后发现这也是最优解。

再举一个例子：$n=10$。按照前面的策略发现构造出来的序列为 `(()())()()`，符合所有要求。

因此我们可以基本得出结论了。一开始为 `()`，一直往中间添加 `())(` 或 `)(()`，构造出的序列合法且权值最大。发现 $n$ 每增加 $4$，权值增加 $1$。因此对于 $n\bmod4=2$，按以上方法构造，对于 $n\bmod4=0$，两边再加一组括号即可。

## AC code

```cpp
#include <bits/stdc++.h>
int t,n;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		if(n%2) printf("-1\n");
		else{
			if(n%4){
				n-=2;
				printf("(");
				for(int i = 1;i<=n/2;i++) if(i%2) printf("(");else printf(")");
				for(int i = 1;i<=n/2;i++) if(i%2) printf(")");else printf("(");
				printf(")");
			}
			else{
				n-=4;
				printf("((");
				for(int i = 1;i<=n/2;i++) if(i%2) printf("(");else printf(")");
				for(int i = 1;i<=n/2;i++) if(i%2) printf(")");else printf("(");	
				printf("))");
			}
			printf("\n");
		}
	}
	return 0;
}
```

---

## 作者：cjx_AK (赞：0)

本题是一道模拟题。

题意很简单，给你一个 $n$，让你求长度为 $n$ 的合法括号序列使得最多括号回文。

我们可以让两边的尽量相同，而且相互匹配，只需在中间弄两个相同括号，然后往周围扩散，每扩散一次就换括号。

最后在特判是否两种括号的数量是否相等即可。

code：

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
typedef long long ll;
const int MAXN=2e6+10;
ll n,m,a[MAXN],b[MAXN],sum=0,ans,dis[5005][5005],vis[1005][1005],cnt;
ll dp[5005][5005],T;
char s[5005][5005];
vector<int>vec;
bool vaild(int a,int b){
	if(a>n||b>m||a<1||b<1||s[a][b]=='#'||s[a][b]=='E'||vis[a][b])return 0;
	return 1;
}
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
queue<pair<int,int>>q;
signed main(){
	cin>>T;
	while(T--){
		char s[500005]={" "};
		s[0]='(';
		cin>>n;
		if(n%2){
			puts("-1");
			continue;
		}else if(n==2||n==4){
			if(n==2){
				cout<<"()\n";
			}else
				cout<<"()()\n";
			
			continue;
		}
		else{
			int p=0;
			s[n-1]=')';
			int l=n/2-1,r=l+1,cntl=3;
			s[r]=s[l]='(';
			while(1){
				l--;
				r++;
				if(l==1){
					if(n/2-cntl==1){
						s[l]='(';
						s[r]=')';
					}else{
						s[l]=')';
						s[r]=')';
					}
					break;	
				}
				if(!p){
					s[l]=')';
					s[r]=')';
				}else{
					s[l]='(';
					s[r]='(';
					cntl+=2;
				}
				p^=1;
			}
		}
		cout<<s<<endl;
	}
	return 0;	
}
```

---

## 作者：canwen (赞：0)

## 前言

题目很棒，赛时想了 $1$ h，然后用小号打了不到 $2$ h 就无法战胜其他题，溜之大吉，最后 rk $83$ 足以涨分（bushi）。

## Solution 
与大佬完全不一样的方法出现了。

首先 $n$ 为奇数肯定会有匹配不成功的括号，无解。

考虑一种方式使得当前放的 `(` 或者 `)` 都可以有对应的。

首先第一个和最后一个一定是 `(` 和 `)`，那么我第二个字符放 `)`，倒数第二个放 `(` 又会回到这种不优的情况。

于是考虑 `(())...))()` 的放法抵消这样子不优的情况（而且能最大化在不优的情况下的贡献，当然放法不止一种，例如 `()((...(())` 也可以）。

显然中间可以一直形如 `(( )) ((...(( )) ((` 的放就会一直有贡献，一定最优。

所以讨论一下能不能刚好这样子放完，不能的话分讨一下在哪里插入一组 `()` 使得刚好放完即可。

注意特别判断一下 $n\le 8$ 的情况。

时间复杂度 $O(\sum n)$，[通过记录](https://www.luogu.com.cn/record/216906087)。

代码参考：

```cpp
void solve(){
	int n = in();
	if(n % 2 == 1) out(-1);
	else if(n == 2) cout << "()";
	else if(n == 4) cout << "()()";
	else if(n == 6) cout << "()(())";
	else if(n == 8) cout << "()((()))";
	else{
		n -= 8, cout << "(())";
		int nx = n % 4; n /= 4;
		if(nx == 2){
			_rep(i,1,1+n*2) cout<<(i&1?"((":"))");
		}else if(n){
            _rep(i,1,(n*2-2)/2) cout<<(i&1?"((":"))");
			if(n % 2 == 0){
				cout << "))()";
				_rep(i,1,(n*2-2)/2) cout<<(i&1?"((":"))");
			}else{
				cout << "()((";
				_rep(i,1,(n*2-2)/2) cout << (i&1?"))":"((");
			}
		}
		cout << "))()";
	}
	pc;
}
```

---

## 作者：_Weslie_ (赞：0)

赛时一遍过（好像是第 $13$ 个场切的）。

## Solution P12497

### Idea

首先，如果 $n$ 是奇数，显然答案是 $-1$。

设构造出的字符串为 $s$（下标从 $1$ 开始）。

首先毋庸置疑，$s_1$ 为左括号，$s_n$ 为右括号。

然后我们要尽量让 $s_i=s_{n-i+1}$。

由于这是一个合法的括号序列，于是 $s$ 中一定有 $\dfrac{n}{2}$ 个左括号和 $\dfrac{n}{2}$ 个右括号。除掉 $s_1$ 和 $s_n$，则剩下 $\dfrac{n}{2}-1$ 个左括号和 $\dfrac{n}{2}-1$ 个右括号。设最大的小于 $\dfrac{n}{2}$ 的偶数为 $x$，那么很显然最多只能有 $x$ 对符合条件。

那么如何构造这个字符串呢？我们只需要每一对左括号右括号交替输出即可。至于 $\dfrac{n}{2}-1$ 为奇数的情况，在最中间补上一个左括号和一个右括号即可。

### Code

```
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
char ch[N];
int n;
void solve(){
    scanf("%d",&n);
    if(n&1){
        printf("-1\n");
        return;
    }
    // for(i)
    ch[1]='(';ch[n]=')';
    int cnt=(n/2-1);
    if(cnt&1)cnt--;
    for(int i=2,j=n-1;i<=n/2;i++,j--){
        if(cnt){
            if(cnt&1){
                ch[i]=')';ch[j]=')';
            }
            else {
                ch[i]='(';ch[j]='(';
            }
            cnt--;
        }
        else{
            ch[i]='(';ch[j]=')';
        }
    }
    for(int i=1;i<=n;i++)cout<<ch[i];
    cout<<endl;
    return;
}
int main(){
    int T;scanf("%d",&T);
    while(T--)solve();
}
```

### Evidance

设最大的小于 $\dfrac{n}{2}$ 的偶数为 $x$ 等价于最多只能有 $x$ 对 $(i,n-i+1)$ 符合条件。

这句话为什么正确？

首先，理论最多就是 $x$ 对，这个没的说。假如再多， $2x>\dfrac{n}{2}-1$，就不是 $n$ 的长度了。

其次，一定可以构造出 $x$ 对。为什么？因为按照上面交替填写的方式（即代码中的方式），构造出来显然有 $x$ 对。这样构造出来的字符串形如 `(()()()...)()()...`，显然是合法的。

---


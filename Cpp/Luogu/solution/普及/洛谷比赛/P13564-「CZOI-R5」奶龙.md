# 「CZOI-R5」奶龙

## 题目背景

[❤点击链接直达奶龙❤](/user/621382)。

## 题目描述

现有一张 $n$ 个点，初始没有任何边的编号 $1\sim n$ 的图，给定长度为 $m$ 的数组 $A_i$，表示编号为 $A_i$ 的点上有一只奶龙，在每一次行动中，奶龙会沿着当前点连向其它点的边走向下一个点。

请你构造一张图，给定正整数 $k$，使得其满足：

- 每个点的出度均为 $1$，不得有自环。
- 经过恰好 $k$ 次行动时，所有点都被至少一只奶龙经过，且在经过恰好 $k-1$ 次行动时，至少有一个点未被任何奶龙经过。

若无解则输出 `-1`。

## 说明/提示

### 样例解释

对于样例组 #1 中的构造方案，图形态如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/8go9gc8y.png)

初始点 $1,2$ 上分别有一只奶龙，走第一轮后可以到达 $3,4$，走第二轮后可以到达 $5$，符合题意。

### 数据范围

|子任务编号|$n$|$m$|$k$|分值|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$\le 8$|$\le 8$|$< 8$|$10$|
|$2$|$\le 2\times 10^5$|$=1$|$< 2\times 10^5$|$15$|
|$3$|$\le 2\times 10^5$|$\le 2\times 10^5$|$=1$|$15$|
|$4$|$\le 2\times 10^5$|$\le 2\times 10^5$|$< 2\times 10^5$|$60$|

对于 $100\%$ 的数据，保证 $1\le m\le n\le 2\times 10^5$，$1\le k< n$，$1\le A_i\le n$，$A_i$ 互不相同。另外，为便于编写 Special Judge 保证 $1\le m\times k \le 10^6$，不保证与你的解题过程是否有关。

## 样例 #1

### 输入

```
5 2 2
1 2```

### 输出

```
1 3
3 5
5 1
2 4
4 5```

## 样例 #2

### 输入

```
5 2 1
1 2```

### 输出

```
-1```

# 题解

## 作者：__Clare613__ (赞：3)

## 思路：
一道比较水的黄，关于本场比赛的难度，难评。\
我们可以发现，如果要符合，奶龙至少要走 $k$ 步才走完，且所有奶龙加起来要走完，于是有了这：
```cpp
if(m*(k+1)<n){
	cout<<-1;
	return 0;
}
if(n-m+1<=k){
	cout<<-1;
	return 0;
}
```
接着我们需要统计所有没有奶龙的点，对于每条奶龙，我们有三种分类：
1. 龙中大首领\
这是用来保证在第 $k$ 次前一定还有点。
3. 龙中小首领\
这是用来清理其他点。
4. 龙中随从\
这是多余的龙，跟从于一号龙即可。

我们分成三种后要注意，龙中大首领和龙中小首领各自作为一个环存在，因为每个点的出度均为 $1$。
## code：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[2000005];
bool f[2000005];
bool d[2000005];
vector<int> g(200005);
signed main(){
	cin.tie(0)->sync_with_stdio(0);
	cout.tie(0)->sync_with_stdio(0);
	int n,m,k;
	cin>>n>>m>>k;
	if(m*(k+1)<n){
		cout<<-1;
		return 0;
	}
	if(n-m+1<=k){
		cout<<-1;
		return 0;
	}
	for(int i=1;i<=m;i++){
		cin>>a[i];
		f[a[i]]=1;
	}
	int l=0;
	for(int i=1;i<=n;i++){
		if(f[i]==0){
			g[++l]=i;
		}
	}
	int w=0,j=1;
	for(int i=1;i<=m;i++){
		int last=a[i],cnt=0;
		d[a[i]]=1;
		w++;
		for(;j<=l;j++){
			if(f[g[j]]==0&&d[g[j]]==0){
				d[g[j]]=1;
				cout<<last<<" "<<g[j]<<"\n";
				last=g[j];
				cnt++;
				w++;
			}
			if(cnt==k||w==n){
				break;
			}
		}
		if(last!=a[i]) cout<<last<<" "<<a[i]<<"\n";
		else cout<<a[i]<<" "<<a[1]<<"\n";
		if(w==n) break;
	}
	return 0;
}
```

---

## 作者：Reply_ (赞：2)

## 题解：P13564 「CZOI-R5」奶龙

构造题

一个显而易见想法是构造 $m$ 条链，每个奶龙所在的点为链的起始，链的点数为 $k+1$ , 链的尾部再连到链头。

再往下想，可能点数不够或者过多。

- 点数如果多了，那么 $k$ 步内必然无法覆盖到所有的点，无法构造。
- 点数如果少了，我们发现没有必要每条链都不重合，如果点不够了就直接接到其他链的合适位置即可。
- 当然如果点数连一条链都不够，也是无解。

下面给出注释代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R1 register
#define F(i,a,b) for(int i = (a);i<=(b);i++)
using namespace std;
inline int read(){R1 int x=0,t=1;R1 char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') t=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*t;}
const int N=2e5+10;
int n,m,k,a[N],b[N],c[N];
signed main()
{
	queue<int>q;
	n=read(),m=read(),k=read();
	F(i,1,m) a[i]=read(),b[a[i]]=1;
	F(i,1,n){
		if(!b[i]) q.push(i);//这里存下可以用的点
	}
	if(q.size()>m*k || q.size()<k) {//无法全部覆盖或者连一条链都无法满足都是无解
		cout << -1 << '\n';
		return 0;
	}
	for(int i = 1;i<=m;i++){
		if(q.size()>=k){//剩余点的数量够，直接开一条新的链
			int last=a[i],cnt=0;
			for(int j = 1;j<=k;j++){
				cout << last << " " << q.front() << '\n';
				c[++cnt]=q.front();//存下每一层的点，方便点不够的时候接上
				last=q.front();
				q.pop();
			}
			cout << last << " " << a[i] << '\n';//题目要求每个点的出度为1，所以连回链头
		}
		else{
			int last=a[i],cnt=0;
			while(q.size()){
				cout << last << " " << q.front() << '\n';
				c[++cnt]=q.front();
				last=q.front();
				q.pop();
			}
			cout << last << " " << c[cnt+1] << '\n'; //点的数量不够了，直接连到其他完成的链的下一层的点
		}
	}
	return;
}
/*

*/


```

---

## 作者：CaiZi (赞：2)

先判无解的情况。显然每只奶龙最多经过 $k+1$ 个点，因此当 $m(k+1)<n$ 时无解。同时，当没有奶龙的点 $<k$ 时，没有办法让某个点恰好在 $k-1$ 次行动时不被经过，因此当 $n-m<k$ 时也无解。

然后考虑构造。我们先标记上所有初始时有奶龙的点，然后对于每只奶龙，找到 $k$ 个点连成一条链。因为至少有一条有 $k+1$ 个点的链，且我们保证了可以覆盖完所有的点，所以如果找不到 $k$ 个点就不管。找这 $k$ 个点可以按照编号顺次枚举，每个点只会被枚举一次，因此复杂度是线性的。

于是现在除了每条链的末尾（单个点的末尾即本身）的点的出度均为 $1$ 了。你把每条链的末尾的点连接到 $A_1$ 即可，这是显然正确的。

代码展示：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,a[1000001],u,siz,cnt=1;
bool b[1000001];
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>a[i];
	}
	if(n>m*(k+1)||n-m<k){
		cout<<"-1";
	}
	else{
		for(int i=1;i<=m;i++){
			b[a[i]]=true;
		}
		for(int i=1;i<=m;i++){
			siz=0;
			u=a[i];
			while(siz<=k-1&&cnt<=n){//按照编号顺次枚举，选了超过k个点或没法选足够的点就退出
				if(!b[cnt]){
					cout<<u<<' '<<cnt<<'\n';
					u=cnt;
					siz++;
				}
				cnt++;
			}
			cout<<u<<' '<<a[1]<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：nbhs23a28 (赞：1)

简单题。

首先考虑是否有解边界情况。显然，当 $n>(k+1)\times m$ 时，在 $k$ 步内奶龙无法覆盖全部节点；而当 $n-m<k$ 时，第 $k$ 步一定不能覆盖新的节点（感性认知一下，在 $k-1$ 步内，由抽屉原理，任意一只奶龙一定到达了或到达过其他奶龙位置，陷入了循环），由此在这两种情况下无解。

接下来考虑如何构造解。注意到这是 $n$ 个点 $n$ 条边的图，不妨以环的方式构造，即在每个奶龙前方安排尽可能多（不超过 $k$）的没有奶龙的节点即可。实现细节见代码。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,a[200010];
bool ac[200010];
int main()
{cin>>n>>m>>k;
 for(int i=1;i<=m;i++)
 {cin>>a[i];ac[a[i]]=true;}
 if(n-m<k||n-m>k*m)
 {cout<<"-1";
  return 0;    
 }
 cout<<a[1]<<' ';
 int cnt=0,j=1;bool wa=true;
 for(int i=1;i<=n;i++)
 { if(cnt<k)
   {if(!ac[i])
    {cout<<i<<'\n'<<i<<' ';
     cnt++;
    }
   }
   else
   {j++;
    cout<<a[j]<<'\n'<<a[j]<<' ';
    cnt=0;wa=false;
    if(!ac[i])
    {cout<<i<<'\n'<<i<<' ';
     cnt++;
    }
   } 
 }
 while(j<m)
 {j++;
  cout<<a[j]<<'\n'<<a[j]<<' ';   
 }
 cout<<a[1];
}

---

## 作者：lam_dyr (赞：1)

题目中有两个重要的条件：
- 恰好 $k$ 次行动后，所有 $n$ 个点都被至少一只奶龙访问过。
- 恰好 $k-1$ 次行动后，至少有一个点未被任何奶龙访问过。

同时有一个显然的性质：每一轮至少有一个点、至多有 $m$ 个点由未访问变成访问。根据以上的条件和性质，我们可以先判断无解的情况。

1. $n>m\times(k+1)$，也就是节点总数 $n$ 大于 $m$ 只奶龙在 $k$ 次内所能访问到的最大节点数。
2. $n<m+k$，也就是不需要 $k$ 次行动就能走完 $n$ 个点。

然后再来考虑如何构造。注意到目标图一定有 $n$ 个点和 $n$ 条边，也就是说是个基环树，同时环的长度至少为 $2$。为了使方案尽可能简单，一个自然的想法是让不同奶龙的路径尽可能不重叠。因此我们对于每个 $a_i$，我们都尝试为它连一条由未经过节点组成的长度为 $k$ 的链。由于基环树的结构，我们将这些链的末尾都连向 $a_1$，从 $a_1$ 出发的路径的终点也连向 $a_1$，形成一个长度为 $k+1$ 的环，其他路径最终都进入这个主环，满足出度为 $1$ 的限制。

我们需要使用所有的 $n−m$ 个未经过节点来构建这些路径。如果 $n−m$ 个节点不足以给每只奶龙都分配 $k$ 个新节点，我们就尽力分配。如果分配完所有自由节点后，某些奶龙的路径长度不足 $k$，这也是允许的。只要我们能保证至少有一条路径的长度恰好为 $k$，就能满足题目的条件。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+10;
int n,m,k;
int a[N];
unordered_map<int,int> mp;
signed main(){
	cin>>n>>m>>k;
	if(n-m<k || (ll)n>(k+1)*m){
		cout<<-1;
		return 0;
	}
	for(int i=1;i<=m;++i){
		cin>>a[i];
		mp[a[i]]=1;
	}
	int u=1;
	for(int i=1;i<=m;i++){
		int cur=a[i],len=0;
		while(len<k && u<=n){
			if(!mp[u]){
				cout<<cur<<" "<<u<<"\n";
				cur=u;
				len++;
			}
			u++;
		}
		cout<<cur<<" "<<a[1]<<"\n";
	}
	return 0;
} 
```

---

## 作者：Lava_Dreamer (赞：1)

**[查看原题](https://www.luogu.com.cn/problem/P13564)**
## 前言：
我真是服了，被一道黄题卡了半天……
## 思路：
首先，我们该如何判断一定无解呢？知周所众，无解一共有两种可能：
1. $n$ 太大，$k$ 次行动后无法覆盖整个图；
2. $n$ 太小，不到 $k$ 次行动就已经可以覆盖整个图。

想要判断第一种可能，我们就要让奶龙覆盖的节点尽可能的多，如果最多的情况也不能覆盖所有节点，就一定无解。  
那么，想要奶龙覆盖的节点尽可能的多，就要让所有奶龙的路径都不重复，也就是让每个节点只被经过一次。  
而一只奶龙算上初始点， $k$ 次行动后可以经过 $k+1$ 个节点。所以 $m$ 只奶龙最多可以覆盖 $(k+1) \times m$ 个节点。如果 $(k+1) \times m < n$ 的话，就无解。

想要判断第二种可能，就要和第一种可能相反，让奶龙覆盖的节点尽可能的少，如果最少的情况也能覆盖大于 $n$ 个节点，就一定无解。  
那么，想要奶龙覆盖的节点尽可能的少，就要让所有奶龙的路径尽量重复。也就是让不是奶龙的初始点的节点都被经过 $m$ 次。  
因为每只奶龙的初始点都不一样，所以我们只能让除初始点外奶龙经过的 $k$ 个节点都相同。重复的 $k$ 个节点再加上 $m$ 个奶龙的初始点，$m$ 只奶龙至少需要覆盖 $k+m$ 个节点。而如果 $k+m>n$ 的话，就无解。

接下来就要开始构造了。我的思路是让整个图为一个大环，也就是每个让节点的入度和出度都一样。容易想到，让每两个有奶龙的节点之间隔 $k$ 个没有奶龙的节点（如下图所示），就可以使 __经过恰好 $k$ 次行动时，所有点都被至少一只奶龙经过，且在经过恰好 $k−1$ 次行动时，至少有一个点未被任何奶龙经过。__ 因为这样保证至少有一个节点距最近的奶龙 $k$ 个节点，且一定不存在有一个节点与最近的奶龙的距离大于 $k$ 个节点。

![下图](https://cdn.luogu.com.cn/upload/image_hosting/ap71s41c.png)
---
注：若剩余的没有奶龙的节点不足 $k$ 个，则将剩下的全部输出即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a;
unordered_set <int> x,y;//unordered_set存储和删除的速度更快；x：一开始有奶龙的节点，y：一开始没有奶龙的节点
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m>>k;
    if((k+1)*m<n || k+m>n){//判断无解
        cout<<-1;
        return 0;
    }
    for(int i=1;i<=n;i++) y.insert(i);//先将全部节点设为没有奶龙
    for(int i=0;i<m;i++){
        cin>>a;
        x.insert(a);//将a存为有奶龙的节点
        y.erase(a);//将a从没有奶龙的序列中移除
    } 
    vector<int> x1(x.begin(),x.end()),y1(y.begin(),y.end());//将unordered_set转为vector
    for(int i=0;i<m;i++){
        if(y1.empty()) cout<<x1[i]<<" "<<x1[(i+1)%m]<<'\n';//若没有没有奶龙的节点了，则将这个有奶龙的节点与下一个有奶龙的节点连接
        else cout<<x1[i]<<" "<<y1.back()<<'\n';//否则就将这个有奶龙的节点与下一个没有奶龙的节点连接
        for(int j=1;j<k && y1.size()>1;j++){
            cout<<y1.back()<<" ";//将这个没有奶龙的节点与下一个没有奶龙的节点连接
            y1.pop_back();
            cout<<y1.back()<<'\n';
        }
        if(!y1.empty()){
            cout<<y1.back()<<" "<<x1[(i+1)%m]<<'\n';//如果还有奶龙，就将这个没有奶龙的节点与下一个有奶龙的节点连接
            y1.pop_back();
        }
    }
    return 0;
}
```
但是我发现，其实在代码第 29 行和第 21 行那里，不一定要连接到 $x1_{(i+1)\bmod m}$ 的位置，其实连接到任意一个有奶龙的节点都可以。但是我们发现，如果改成 $x1_1$、$x1_{m-1}$ 等都会 WA 一些测试点，只有 $x1_0$ 可以 AC，这是为什么呢？

举个栗子，如 $n=3$，$m=2$，$k=1$，$a=\{1,2\}$ 并且都连接到 $x1_{m-1}$ 的位置，那么构造出的图就像这样：

![下图](https://cdn.luogu.com.cn/upload/image_hosting/ez25mp6e.png)

出现了自环。而由于我们前面判断过无解，所以有解的一定满足 $m<n$，也就是至少有一个点上没有奶龙。因此我们都连接到 $x1_0$ 一定不会出现自环。

---
注：$x1$ 从 $0$ 开始编号。
## AC CODE：
抄袭不是好习惯！！！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a;
vector<int> x1;//x1：一开始有奶龙的节点，
unordered_set <int> x,y;//unordered_set存储和删除的速度更快；y：一开始没有奶龙的节点
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m>>k;
    if((k+1)*m<n || k+m>n){//判断无解
        cout<<-1;
        return 0;
    }
    for(int i=1;i<=n;i++) y.insert(i);//先将全部节点设为没有奶龙
    for(int i=0;i<m;i++){
        cin>>a;
        x1.push_back(a);//将a存为有奶龙的节点
        y.erase(a);//将a从没有奶龙的序列中移除
    } 
    vector<int> y1(y.begin(),y.end());//将unordered_set转为vector
    for(int i=0;i<m;i++){
        if(y1.empty()) cout<<x1[i]<<" "<<x1[0]<<'\n';//若没有没有奶龙的节点了，则将这个有奶龙的节点与第一个有奶龙的节点连接
        else cout<<x1[i]<<" "<<y1.back()<<'\n';//否则就将这个有奶龙的节点与下一个没有奶龙的节点连接
        for(int j=1;j<k && y1.size()>1;j++){
            cout<<y1.back()<<" ";//将这个没有奶龙的节点与下一个没有奶龙的节点连接
            y1.pop_back();
            cout<<y1.back()<<'\n';
        }
        if(!y1.empty()){
            cout<<y1.back()<<" "<<x1[0]<<'\n';//如果还有奶龙，就将这个没有奶龙的节点与第一个有奶龙的节点连接
            y1.pop_back();
        }
    }
    return 0;
}
```
## 结语：
第一个的代码是我比赛时写的，其实有很多可以简化的地方，比如 $x1$ 可以不用 unordered_set 再转 vector，直接用 vector 就可以了。

题目中的图是用什么画的，我用画图画画了半个多小时还不好看。

---

## 作者：ylch (赞：1)

### $n \le 8, m \le 8, k < 8$

考虑爆搜每个点连向哪个点，得到所有边之后暴力跑 $k$ 轮 check 一下是否满足题目关于步数的要求即可。

```cpp
vector<int> to(n + 1, 0); // 每个点的指向
bool found = false; // 是否有答案
function<bool()> check = [&]() -> bool{
	vector<int> vis(n + 1, 0), vis2(n + 1, 0); // 分别统计第k步、第k-1步的覆盖情况
	for(int i = 1; i <= m; i ++){
		int now = a[i];
		for(int step = 0; step <= k; step ++){ // 走k步
			vis[now] = 1;
			if(step == k - 1) vis2 = vis;
			now = to[now];
		}
	}
	// 检查覆盖情况
	for(int i = 1; i <= n; i ++){
		if(!vis[i]) return false; // 第k步时必须全部覆盖
	}
	for(int c = 0, i = 1; i <= n; i ++){
		if(vis2[i]) c ++;
		if(c == n) return false; // 第k-1步时不能全部覆盖
	}
	return true;
};
function<void(int)> dfs = [&](int u){ // 爆搜所有可能的建边情况
	if(found) return ;
	if(u == n + 1){
		if(check()){
			for(int i = 1; i <= n; i ++){
				cout << i << ' ' << to[i] << '\n';
			}
			found = true;
		}
		return ;
	}
	for(int v = 1; v <= n; v ++){
		if(v != u){
			to[u] = v; dfs(u + 1); to[u] = 0;
		}
	}
};		
dfs(1);
if(!found) cout << -1 << "\n";
```

### 正解

首先讨论无解情况。因为每个奶龙最多走 $(k+1)$ 个点，所以若 $m(k+1)<n$，则一定无解；当没有奶龙的点数小于 $k$ 时，没有办法使在 $k-1$ 步时存在一个点没有被奶龙走过，所以若 $n-m<k$ 也一定无解。

然后思考如何构造。受到 $k=1$ 时的启发，我们发现可以对于每一只奶龙都以其为起点构建一条长度为 $k+1$ 的链，链的后面是没有奶龙的结点。根据有解判定可知 $m(k+1) \ge n$，所以这些链一定能在 $k$ 步时覆盖所有没有奶龙的点。现在我们得到 $m$ 条散链，为了凑够边数，考虑把每条链都连回 $a_1$ 即可。

示意图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ikjquakg.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 7;

int n, m, k, a[maxn];

void solve()
{
	cin >> n >> m >> k;
	for(int i = 1; i <= m; i ++){
		cin >> a[i];
	}
	
	if(m * (k + 1) < n || n - m < k){ // 每只奶龙最多经过k+1个点； 当没有奶龙的点数<k时没有办法使在k-1步时不完全覆盖
		cout << -1 << '\n';
	}
	else{
		vector<int> to(n + 1, 0); // 存储每个点的指向
		// 标记是否与奶龙连边
		vector<bool> vis(n + 1, 0); 
		for(int i = 1; i <= m; i ++){
			vis[a[i]] = true;
		}
		// 给每只奶龙都连一个普通点
		int now = 1; // 普通点计数器
		for(int i = 1; i <= m; i ++){ 
			int s = a[i]; // 下一次连边的起点
			for(int j = 1; j <= k && now <= n; ){
				if(!vis[now]){
					to[s] = now; // 继续向普通点连边
					s = now; // 下一次连边的起点为now
					j ++;
				}
				now ++;
			}
			to[s] = a[1]; // 把每条链的结尾连向a[1]即可
		}
		for(int i = 1; i <= n; i ++){
			cout << i << ' ' << to[i] << '\n';
		}
	}
}

signed main()
{
	ios :: sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	solve();
	return 0;
}
```

---

## 作者：Epitome (赞：1)

## 闲话

WXH 是世界上最美的女孩子！

## 题意

题目里面自己去看。

## 解法

显然会想到一个做法，每个关键点都往下连 $k - 1$ 个点，这个很容易发现不是最优的，然后又可以想到一个做法：把关键点都向一个关机点连边，然后这个点连出去 $k - 1$ 个点，然后剩下的点再向这个关键点连边，感性理解容易发现这个东西就是最优的，然后就是判断无解，这个方法的上界显然就是 $(k + 1) \times m$，然后下界是 $m + k$，只需要判断这两个东西与 $n$ 的大小关系就行了。

## 代码

对着题解口胡谁都会，请展示你的代码。

```cpp
// 39 X 03

#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;

int n, m, k, h[N], v[N];

vector<int> vec, yd;
vector<pair<int, int> > ans;

int main() {
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> k;
  for (int i = 1, x; i <= m; ++i) {
    cin >> x, h[x] = x;
  }
  for (int i = 1; i <= n; ++i) {
    if (!h[i]) {
      vec.push_back(i);
    } else {
      yd.push_back(i);
    }
  }
  if (m * (k + 1) < n || n == m || m + k - 1 >= n) {
    return cout << -1, 0;
  }
  for (int i = 0; i < yd.size(); ++i) {
    for (int j = 1; vec.size() && j <= k; ++j) {
      ans.push_back({h[yd[i]], vec.back()});
      v[h[yd[i]]] = 1, h[yd[i]] = vec.back(), vec.pop_back();
    }
  }
  for (int i = 1; i <= n; ++i) {
    if (!v[i] && i ^ yd.front()) {
      ans.push_back({i, yd.front()});
    } else if (!v[i]) {
      ans.push_back({i, yd.back()});
    }
  }
  for (auto i : ans) {
    cout << i.first << " " << i.second << '\n';
  }
  return 0;
}

```

---

## 作者：canwen (赞：1)

题意很清晰，不赘述。

首先我们考虑无解的情况。因为要存在一个整数 $k$，使得在第 $k-1$ 秒时并没有把每个点都走一遍，在第 $k$ 秒时刚好把每个点走一遍才算有解，由此可以推出有解的情况下每秒都会多出**至少** $1$ 个奶龙新走过的点。怎么构造使得不管 $n,m$ 为多少都是每秒多走一个奶龙会在下文构造方式中体现，这里放出结论是存在的。于是若 $k>n-m$ 无法再拖延无解。考虑 $k$ 秒后走不满 $n$ 个点，显然每只奶龙能发挥的最大价值是每秒多走 $k$ 个点，构造方式如下文，那么若 $m(k+1)<n$ 则无法走满，无解。

如下一种构造是显然正确的，类似贪心的思想。

令 $x$ 为当前剩余的没走过的点的数量，$y$ 为利用的奶龙数，初始为 $0$，初始 $x = n-m$。

$x \ne 0$ 时一直执行以下：

- 需要新的奶龙来走这些点，$y = y + 1$；

- 我们尽可能发挥每一只奶龙 $A_y$ 的最大价值，走多 $\min(x,k)$ 个点。包含奶龙 $y_i$ 在内 $\min(x,k) + 1$ 个点从左往右依次连边即可，然后令 $x = x - \min(x,k)$；

- 若 $x\ne 0$，那么肯定需要新的奶龙，新的奶龙 $A_{y+1}$ 和走的最后一个点连边。

若所有不是初始奶龙的点都走完了，还有奶龙没出边，那么这几只奶龙从左到右依次接在已经构造的这条链右边即可。

注意最后构造完的不是一条链，最后一个点也要有出边，随便与不是它本身的点构造一条出边即可。

## Code
```cpp
#include <bits/stdc++.h>
#include <unordered_map>
#include <unordered_set>
using namespace std;

#define int long long
//#define getchar getchar_unlocked
//#define putchar putchar_unlocked
#define pc putchar
int in() {
	char a=getchar();
	int k=0,kk=1;
	while(!(a>='0'&&a<='9')) {
		if(a == '-') kk = -1;
		a = getchar();
	}
	while(a>='0'&&a<='9') k = k*10 + a - '0', a = getchar();
	return k*kk;
}
void out(int a) {
	if(a < 0) pc('-'), a= -a;
	if(a > 9) out(a/10);
	pc('0'+a%10);
}
#define fst first
#define snd second
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define mp make_pair
#define pint pair<int,int>
#define i128 __int128
#define i64 long long
#define pb emplace_back
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define nowtime (double)clock()/CLOCKS_PER_SEC

const int N = 2e5 + 5;
int n,m,k;
int pd[N],tot,s[N],ss[N],tot1;
signed main() {
	n = in(), m = in(), k = in();
	if(k>n-m||m*(k+1) < n){
		out(-1);
		return 0;
	}
	_rep(i,1,m){
		int x = in();
		pd[x] = 1,ss[++tot1] = x;
	}
	_rep(i,1,n) 
		if(pd[i] == 0) s[++tot] = i;
	int c,cc;
	c = cc = 0; // 下标 
	int last = 0, q = k;
	while(c < tot) {
		if(q == k) {
			if(last == 0) last = ss[++cc];
			else {
				cout << last << " " << ss[++cc] << endl;
				last = ss[cc];
			}
			q = 0;
		}
		cout << last << " " << s[++c] << endl;
		last = s[c];
		++q;
	}
	while(cc<tot1) {
		cout << last << " " << ss[++cc] << endl, last = ss[cc];
	}
	cout << last << " " << ss[1] << endl;
	return 0;
}
```

[Accept Submission](https://www.luogu.com.cn/record/228842863)。

---

## 作者：liuziqin (赞：0)

## 思路

首先考虑无解的情况。
- 所有点的奶龙每一步都走到新点都无法将所有的点遍历到。
- 最初奶龙没占领的点数不足 $k$ 个。

由于在第 $k-1$ 步时至少要有一个点没被奶龙遍历，我们考虑这么一种构造方法：
1. 让一只奶龙沿着一条路一直走 $k$ 步。
2. 让其他奶龙优先去走还没被走过的点，注意不要超过 $k$。
3. 将入度为 0 的点随便连边，注意不要连到自己即可。

## Code

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
queue<int>q;
bool mp[N];
int du[N],s[N];
int main(){
	int n,m,k;
	cin>>n>>m>>k;
	if(m*(k+1)<n||m+k>n||n==1){
		cout<<"-1\n";//特判掉无解的情况
		return 0;
	}
	for(int i=1;i<=m;i++){
		cin>>s[i];
		mp[s[i]]=1;
	}
	for(int i=1;i<=n;i++)if(!mp[i])q.push(i);
	for(int i=1;i<=m;i++){
		int t=s[i];
		for(int j=1;j<=k&&!q.empty();j++){
			du[t]++;
			cout<<t<<" "<<q.front()<<"\n";
			t=q.front();
			q.pop();
		}//让奶龙优先去跑没有到达的点
	}
	for(int i=1;i<=n;i++)if(!du[i]){
		if(i==1)cout<<i<<" "<<n<<"\n";
		else cout<<i<<" "<<1<<"\n";
	}//处理掉剩余的入度为 0 的点
}
```

---

## 作者：spacebar (赞：0)

[我才是奶龙。](https://www.luogu.me/paste/hrlcsy75)

题目的要求：构造基环树森林，让奶龙在刚好 $k$ 次移动后访问完所有点。（如果不知道什么是基环树森林请查一下）

既然奶龙贪吃，我们就假设所有开始没有奶龙的地方都有一份食物（一共 $n-m$ 个），访问了新的节点，奶龙就会把上面的食物吃掉，都吃光了就结束了。

这样想：每只奶龙在一次移动中要么到了全新的节点（吃掉一个食物），要么来到已经被龙走过的节点（不能吃食物），在最极端的情况下所有奶龙每次移动都能吃到食物，进行 $k$ 次以后能吃 $km$ 个食物，如果说食物的数量大于了这个数，这些奶龙全力吃也吃不完，就不可能达成 $k$ 次走完的要求，无解。

无论如何，在食物吃完前，每一回合至少有一个奶龙吃到了食物。因为如果某一刻所有奶龙都来到了有龙来过的节点，它们就会沿着其他龙走过的路线兜圈子，这会致使 $k$ 个回合之内无法吃到部分食物。所以说，一回合至少消耗一个食物，如果食物的数目小于 $k$ 就肯定不够吃，无解。

而如何构造方案？我们可以给 $\lfloor \frac{n-m}{k} \rfloor$ 个奶龙开包厢，做包含这只奶龙和 $k$ 个食物的环，使他们正好能在 $k$ 个回合访问完它们所在的环。剩下的奶龙和边角料都放一个单独的环，龙多饭少肯定 $k$ 个回合前就吃完了。下面给出例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/0cer3ojg.png)

---

## 作者：Bandysol (赞：0)

我们可以将问题分解为如下两个部分：
## 1. 何时无解？
>  经过恰好 k 次行动时，所有点都被至少一只奶龙经过。

我们注意到 **恰好** 二字，这意味着我们不能提前也不能延后经过所有点，必须用正好 $k$ 次行动。

因此如下情况是无解的：
1. 我们以**最慢**的速度行动也会提前，即 $n - m < k$ 时。  
2. 我们以**最快**的速度行动也会延后，即 $ m (k + 1) < n $ 时。

以下是证明：
1. 我们可以将其它奶龙的初始位置连一条边到第一个奶龙的初始位置。这样相当于只有第一个奶龙在行动，显然是最慢的行动速度，一次行动最多经过 $1$ 个未经过的点。而未经过的点有 $n - m$ 个，所以我们需要行动 $n - m$ 次。
2. 我们让所有奶龙一起行动，显然这样是最快的行动速度。这样行动 $k$ 次就会经过 $ m (k + 1) $ 个点（奶龙的初始位置也算经过的点）。

## 2. 怎样构造解？
我们先构造 $m$ 条链，每条链的起点是奶龙的初始位置，长度最多是 $k + 1$ 且至少有一条的长度是 $k + 1$（其它链长度随意）。这样，奶龙就可以恰好在 $k$ 次行动后经过所有点，且除链的结尾之外的所有点的出度都是 $1$。

接下来，我们处理链的结尾。奶龙在到达结尾时已经经过了自己链上的所有点，所以只需要把这些点接到一个不会使它在**其它链上的奶龙经过前经过那个链上未经过的点**的点即可。比如任何一个长度大于等于 $2$ 的链的起点（显然接到长度等于 $1$ 的链上会形成自环）。

## 参考代码
```cpp
#include <stdio.h>

int n, m, k, initPos[200005], firstNoVisited;
bool visited[200005];

int main() {
	scanf("%d %d %d", &n, &m, &k);
	for (int i = 0;i < m;++i) {
		scanf("%d", &initPos[i]);
		visited[initPos[i] - 1] = true;
	}
	if (m * (k + 1) < n || n - m < k) {
		printf("%d\n", -1);
		return 0;
	}
	for (int i = 0;i < m;++i) {
		int lastVisited = initPos[i] - 1;
		for (int j = 0;j < k;++j) {
			while (visited[firstNoVisited]) {
				firstNoVisited++;
			}
			if (firstNoVisited == n) {
				break;
			}
			printf("%d %d\n", lastVisited + 1, firstNoVisited + 1);
			visited[firstNoVisited] = true;
			lastVisited = firstNoVisited;
		}
		printf("%d %d\n", lastVisited + 1, initPos[0]);
	}
}
```

---


# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# 题解

## 作者：_Deer_Peach_ (赞：0)

题意已经很简洁了不再赘述。

思路：

搜索，从小到大枚举所有被污染的数字，再判断是否为质数，这样就能求出最小的质数。因为数字长度最大为 $7$，询问次数最多为 $10$，所以不会超时。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
int t;bool flag;
int num(string s){//字符串转数字
	int nu=0;
	int len=s.size()-1;
	if(s[0]=='0')return 0;//数字最高位不能为0
	for(int i=0;i<len;i++)nu*=10,nu+=s[i]-'0';
	return nu; 
}bool check(int x){//判断质数
	if(x<2)return false;
	for(int i=2;i*i<=x;i++)if(x%i==0)return false;
	return true;
}
void dfs(string x,int id){
	if(flag)return;//已经有答案
	if(x[id]==' '){
		if(check(num(x))){
			cout<<num(x)<<endl;
			flag=true;//标记
		}return;
	}if(x[id]=='*'){
		for(int i=0;i<10;i++){//枚举数字
			x[id]=(char)(i+'0');
			dfs(x,id+1);
		}
	}else dfs(x,id+1);
}signed main() {
	IOS;cin>>t;
	while(t--){
		string s;
		cin>>s;s=s+" ";
		flag=false;
		dfs(s,0);
		if(!flag)cout<<"-1\n";//无解
	}
	return 0;
} 
```

---


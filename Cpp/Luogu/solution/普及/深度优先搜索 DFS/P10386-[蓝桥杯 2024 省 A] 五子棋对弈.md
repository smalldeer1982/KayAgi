# [蓝桥杯 2024 省 A] 五子棋对弈

## 题目描述

“在五子棋的对弈中，友谊的小船说翻就翻？” 不！对小蓝和小桥来说，五子棋不仅是棋盘上的较量，更是心与心之间的沟通。这两位挚友秉承着 “友谊第一，比赛第二” 的宗旨，决定在一块 $5 × 5$ 的棋盘上，用黑白两色的棋子来决出胜负。但他们又都不忍心让对方失落，于是决定用一场**和棋（平局）** 作为彼此友谊的见证。
比赛遵循以下规则：
1. 棋盘规模：比赛在一个 $5 × 5$ 的方格棋盘上进行，共有 $25$ 个格子供下棋使用。
2. 棋子类型：两种棋子，黑棋与白棋，代表双方。小蓝持白棋，小桥持黑棋。
3. 先手规则：白棋（小蓝）具有先手优势，即在棋盘空白时率先落子（下棋）。
4. 轮流落子：玩家们交替在棋盘上放置各自的棋子，每次仅放置一枚。
5. 胜利条件：率先在横线、竖线或斜线上形成连续的五个同色棋子的一方获胜。
6. 平局条件：当所有 $25$ 个棋盘格都被下满棋子，而未决出胜负时，游戏以平局告终。

在这一设定下，小蓝和小桥想知道，有多少种不同的棋局情况（终局不同看成不同情况，终局相同而落子顺序不同看成同一种情况），既确保棋盘下满又保证比赛结果为平局。

# 题解

## 作者：we_are_the_chuibing (赞：26)

先 dfs 计算出所有情况（要求先手必须下 $13$ 颗子，后手必须下 $12$ 颗子），然后在所有情况上判断是否有人五颗子连着，没有总方案数 $+1$。

理论最坏要跑 $12\times 2^{25}$ 次，但实际上跑得飞快，103ms。

```cpp
#include<iostream>
using namespace std;
int ans=0,a[26],r=0,t=0;
void pd(){
	if(!((a[1]+a[2]+a[3]+a[4]+a[5])%5))return;
	if(!((a[6]+a[7]+a[8]+a[9]+a[10])%5))return;
	if(!((a[11]+a[12]+a[13]+a[14]+a[15])%5))return;
	if(!((a[16]+a[17]+a[18]+a[19]+a[20])%5))return;
	if(!((a[21]+a[22]+a[23]+a[24]+a[25])%5))return;
	if(!((a[1]+a[6]+a[11]+a[16]+a[21])%5))return;
	if(!((a[2]+a[7]+a[12]+a[17]+a[22])%5))return;
	if(!((a[3]+a[8]+a[13]+a[18]+a[23])%5))return;
	if(!((a[4]+a[9]+a[14]+a[19]+a[24])%5))return;
	if(!((a[5]+a[10]+a[15]+a[20]+a[25])%5))return;
	if(!((a[1]+a[7]+a[13]+a[19]+a[25])%5))return;
	if(!((a[5]+a[9]+a[13]+a[17]+a[21])%5))return;
	ans++;
}
void dfs(int k){
	if(k==26){
		pd();
	}
	if(r<=12){
		a[k]=1;
		r++;
		dfs(k+1);
		r--;
	}
	if(t<=11){
		a[k]=0;
		t++;
		dfs(k+1);
		t--;
	}
}
int main(){
	dfs(1);
	cout<<ans;
	return 0;
}
```

---

## 作者：I_Love_DS (赞：17)

## 前言

一道很好的 dfs 搜索题，~~愚人节多次提交题。~~

## 思路1：

直接 dfs（我懒得剪枝了）。

那么有几个问题：

### 一、dfs 写法。

其实就是一个填数独的 dfs 写法。

~~没有写过填数独的童鞋出门右转[P1784 数独](https://www.luogu.com.cn/problem/P1784)。~~

```cpp
void dfs(int x,int y){
	if (y == size + 1) {
		dfs(x + 1,1);
		return;
	}
	if (x == size + 1) {
		if (!check()) cnt++;
		return;
	}
	a[x][y] = 1;//小蓝落子
	dfs(x,y + 1);
	a[x][y] = 0;
	a[x][y] = 2;//小桥落子
	dfs(x,y + 1);
	a[x][y] = 0;
	return;
}//也许有人说，这不是违反了第四条“轮流落子”的规则了吗？别急，那个我放在 check() 判断函数里了。
```

### 二、接着是判断函数。

因为平局的定义是所有的格子均已落入棋子，且没有人获胜（没有达成横竖斜均是某方棋子），所以等所有的棋子落入后再判断是否可行是一个可行的思路。

我选择 `true` 是棋局不成立，`false` 是棋局成立。

#### 1. 判断是否是轮流落子。

正如上面的注释所说，`check()` 函数里要判断轮流落子，也就是说，假设小蓝棋子数为 $x$，小桥棋子数为 $y$，那么如果 $x - y = 1$，说明是轮流落子，否则不是。

```cpp
	//size = 5
	int cnt_1 = 0,cnt_2 = 0;
	for (int i = 1; i <= size; i++) 
		for (int j = 1; j <= size; j++) {
			if (a[i][j] == 1) cnt_1++;
			if (a[i][j] == 2) cnt_2++;
		}
	if (cnt_1 - cnt_2 != 1) return true;
```

#### 2. 横竖斜判断。

这个相信大家都会。

我这里比较推荐我的快速写法：

```cpp
	//size = 5
	for (int i = 1; i <= size; i++) {
		bool flag = true;
		for (int j = 1; j <= size; j++) {
			if (a[i][j] != a[i][1]) {
				flag = false;
				break;
			}
		}
		if (flag) return true;
	}
	for (int i = 1; i <= size; i++) {
		bool flag = true;
		for (int j = 1; j <= size; j++) {
			if (a[j][i] != a[1][i]) {
				flag = false;
				break;
			}
		}
		if (flag) return true;
	}
	bool flag = true;
	for (int i = 1; i <= size; i++) {
		if (a[i][i] != a[1][1]) {
			flag = false;
			break;
		}
	}
	if (flag) return true;
	flag = true;
	for (int i = 5,j = 1; i >= 1 && j <= size; i--,j++) {
		if (a[i][j] != a[size][1]) {
			flag = false;
			break;
		}
	}
	if (flag) return true;
	else return false;
```

整个标准输出答案的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int size = 5;
int a[10][10],cnt = 0;
bool check(){
	int cnt_1 = 0,cnt_2 = 0;
	for (int i = 1; i <= size; i++) 
		for (int j = 1; j <= size; j++) {
			if (a[i][j] == 1) cnt_1++;
			if (a[i][j] == 2) cnt_2++;
		}
	if (cnt_1 - cnt_2 != 1) return true;
	for (int i = 1; i <= size; i++) {
		bool flag = true;
		for (int j = 1; j <= size; j++) {
			if (a[i][j] != a[i][1]) {
				flag = false;
				break;
			}
		}
		if (flag) return true;
	}
	for (int i = 1; i <= size; i++) {
		bool flag = true;
		for (int j = 1; j <= size; j++) {
			if (a[j][i] != a[1][i]) {
				flag = false;
				break;
			}
		}
		if (flag) return true;
	}
	bool flag = true;
	for (int i = 1; i <= size; i++) {
		if (a[i][i] != a[1][1]) {
			flag = false;
			break;
		}
	}
	if (flag) return true;
	flag = true;
	for (int i = 5,j = 1; i >= 1 && j <= size; i--,j++) {
		if (a[i][j] != a[size][1]) {
			flag = false;
			break;
		}
	}
	if (flag) return true;
	else return false;
}
void dfs(int x,int y){
	if (y == size + 1) {
		dfs(x + 1,1);
		return;
	}
	if (x == size + 1) {
		if (!check()) cnt++;
		return;
	}
	a[x][y] = 1;
	dfs(x,y + 1);
	a[x][y] = 0;
	a[x][y] = 2;
	dfs(x,y + 1);
	a[x][y] = 0;
	return;
}
int main(){
	dfs(1,1);
	printf("%d",cnt);
	return 0;
}
```

### 时间复杂度

$O(2^{5^2})$。

当然，直接提交上面的代码会 TLE，所以要等上面的代码输出 $cnt$ 后再直接输出 $cnt$。

## 思路2：

~~根据洛谷提交方式为 IOI，会返回错误信息，所以考虑一位一位交。~~

~~所以会很快过。~~

本题解完美撒花！

如果有哪里不懂，就发在评论区吧！

---

## 作者：D0000 (赞：9)

直接暴力枚举每个位置是白的还是黑的，然后统计满足下列条件的棋盘数量：

- $13$ 个黑子
- 没有任何行、列、对角线上全为相同的棋子

然后就行了，枚举棋盘 $2^{n^2}$ 次，判断大约每种 $n$ 次，总共就是 $n\times2^{n^2}$ 次，$n$ 表示这个棋盘（正方形）的边长，$n=5$ 时就是 $167772160$ 大约 $2\times10^8$ 次。

优化方法还很多，但是没有必要。

---

## 作者：_C_ccx_N_ (赞：7)

dfs 爆搜，所有情况搜出来进行判断是不是平局，同时注意判断条件.
参考程序
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5;
int dp[N][N];//存储棋盘状态1白2黑
int ans;//计方案数
bool check()//检查是否为平局
{
    for(int i=0;i<N;i++)//检查行
    {
        if(dp[i][0]==-1)continue;
        bool ok=true;
        for(int j=1;j<N;j++)
            if(dp[i][j]!=dp[i][0])
            {
                ok=false;
                break;
            }
        if(ok)return true;
    }
    for(int j=0;j<N;j++)//检查列
    {
        if(dp[0][j]==-1)continue;
        bool ok=true;
        for(int i=1;i<N;i++)
            if(dp[i][j]!=dp[0][j])
            {
                ok=false;
                break;
            }
        if(ok)return true;
    }
    if(dp[0][0]!=-1)//检查主对角线
    {
        bool ok=true;
        for(int i=1;i<N;i++)
            if(dp[i][i]!=dp[0][0])
            {
                ok=false;
                break;
            }
        if(ok)return true;
    }
    if(dp[0][N-1]!=-1)//检查副对角线
    {
        bool ok=true;
        for(int i=1;i<N;i++)
            if(dp[i][N-1-i]!=dp[0][N-1])
            {
                ok=false;
                break;
            }
        if(ok)return true;
    }
    return false;
}
void dfs(int x,int y)//dfs
{
    if(check())return;//检查成功是平局return
    if(x==N)
    {
        int sum=0;
        for(int i=0;i<N;i++)
            for(int j=0;j<N;j++)
                if(dp[i][j]==1)sum+=dp[i][j];
        if(sum==13)ans++;//一共25个格子，白的13够了
        return;
    }
    int dx=x,dy=y;
    if(y+1<N)dy++;else dy=0,dx++;
    dp[x][y]=1;//放白棋
    dfs(dx,dy);
    dp[x][y]=2;//放黑棋
    dfs(dx,dy);
    dp[x][y]=-1;//回溯
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    memset(dp,-1,sizeof(dp));//初始化设为-1；
    dfs(0,0);
    cout<<ans;
    return 0;
}
```

---

## 作者：Belia (赞：2)

这里提供一种位运算的做法。

### 题意：

在 $5 \times 5$ 棋盘上，黑白棋轮流落子（**白棋先手**），最终填满棋盘且未形成任何五连珠（横、竖、斜连续五子同色）的平局状态有多少种？**注意**：不同落子顺序但相同终局视为同一种状态。

### 思路：

我们用 $0$ 表示黑子，用 $1$ 表示白子。

因为开始时有白棋 $13$ 个，黑棋 $12$ 个，且开局时**不存在任何五连珠**，所以总共就有 $12$ 条可能连线。

在枚举时，我们只检查恰好 $13$ 个白棋的状态（约 $520$ 万种），再搭配上我们的位运算，即可轻松解决此题。

虽然总共要进行 $6\times 10^7$ 次位运算，但 $1$ 秒内就可以算出结果，已经全方面碾压了无脑的暴力枚举和深搜。

### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long//#define ll long long你值得拥有
using namespace std;
const unsigned max_state=1<<25;
ll ans;
unsigned x=(1<<13)-1;// 初始组合（最低 13位为 1）
vector <unsigned> masks;// 12条连线掩码（5 行 +5 列 +2 对角线）
unsigned nxt_com(unsigned x)// 生成下一个组合状态（位运算魔法）
{
    unsigned u=x&-x;
    unsigned v=u+x;
    return v+(((v^x)>>2)/u);
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//cincout加速代码
    for(ll i=0;i<5;i++)
	masks.push_back(0x1F<<(5*i));// 行掩码
    for(ll j=0;j<5;j++)// 列掩码
	masks.push_back((1<<j)|(1<<(j+5))|(1<<(j+10))|(1<<(j+15))|(1<<(j+20)));
    masks.push_back((1<<0)|(1<<6)|(1<<12)|(1<<18)|(1<<24));// 主对角线
	masks.push_back((1<<4)|(1<<8)|(1<<12)|(1<<16)|(1<<20));// 反对角线
    while(x<max_state)
	{
        ll flg=1;
        for(auto m:masks)
		{
            if((x&m)==m||(x&m)==0)
			{
                flg=0;
                break;
            }
        }
        ans+=flg,x=nxt_com(x);
    }
    cout<<ans<<"\n";
    return 0;
}
```

完结撒花~

---

## 作者：Andy2011_swsgroitfh (赞：1)

## [P10386 [蓝桥杯 2024 省 A] 五子棋对弈](https://www.luogu.com.cn/problem/P10386)题解
### 思路
计划分为两步
1. 直接暴力`DFS`出所有棋局的情况
2. 检查有没有人赢，没有就计数++
#### 第一步
先用两个变量 $w,b$ 记录白/黑子的剩余数量，每层搜索分别判断有无白/黑子，有就在相应的位置落子并继续搜索。
##### 重点
~~虽然搜索直接用 $x,y$ 表示搜索的位置更方便，但我还是选择用只一个 $p$。~~ 所以如何把这个 $p$ 转换为 $x,y$ 就是问题所在。上公式： $x=(p-1) \div 5+1,y=(p-1) \bmod 5+1$。如果你习惯 $x,y$ 下标从 $0$ 开始，这是公式： $x=(p-1) \div 5,y=(p-1) \bmod 5$。
#### 第二步
`for`循环从 $1$ 到 $5$，分别检查第 $i$ 行/列是否全是白/黑子。对于对角线，我会给出通用的公式。左上-右下：$y=x (1 \le x \le n)$，右上-左下：$y=n+1-x (1 \le x \le n)$。这样检查两条对角线是否全是白/黑子。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int mapp[10][10];//棋盘
int w=13,b=12;//白黑子剩余数量
int cnt;//计数
void check(){
	for (int i=1;i<=5;i++){//检查第i行/列
		if (mapp[i][1]&&mapp[i][2]&&mapp[i][3]&&mapp[i][4]&&mapp[i][5]) return ;//第i行全白
		if (!mapp[i][1]&&!mapp[i][2]&&!mapp[i][3]&&!mapp[i][4]&&!mapp[i][5]) return ;//第i行全黑
		if (mapp[1][i]&&mapp[2][i]&&mapp[3][i]&&mapp[4][i]&&mapp[5][i]) return ;//第i列全白
		if (!mapp[1][i]&&!mapp[2][i]&&!mapp[3][i]&&!mapp[4][i]&&!mapp[5][i]) return ;//第i列全黑
	}
	if (mapp[1][1]&&mapp[2][2]&&mapp[3][3]&&mapp[4][4]&&mapp[5][5]) return ;//左上-右下对角线全白
	if (!mapp[1][1]&&!mapp[2][2]&&!mapp[3][3]&&!mapp[4][4]&&!mapp[5][5]) return ;//左上-右下对角线全黑
	if (mapp[1][5]&&mapp[2][4]&&mapp[3][3]&&mapp[4][2]&&mapp[5][1]) return ;//右上-左下对角线全白
	if (!mapp[1][5]&&!mapp[2][4]&&!mapp[3][3]&&!mapp[4][2]&&!mapp[5][1]) return ;//右上-左下对角线全黑
	cnt++;//经过天衣无缝的检查后，这个棋局可以判定为和棋了
}
void dfs(int p){//搜索到第p位
	if (p==26){//5*5填完了
		check();//检查
	}
	//白棋
	if (w){//如果还有白棋
		w--;//白棋子数量--
		//好好看，好好学，搜索位数转坐标
		mapp[(p-1)/5+1][(p-1)%5+1]=1;//棋盘标记为白子
		dfs(p+1);//搜索下一个点位
		//回溯不用改棋盘，下次搜到这一位自然会改
		w++;//回溯
	}
	//黑棋
	if (b){
		b--;
		mapp[(p-1)/5+1][(p-1)%5+1]=0;
		dfs(p+1);
		b++;
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	dfs(1);//从第1位开始搜
	cout<<cnt;//输出答案
	return 0;
}
```
##### 小技巧
该说还是得说，既然这题固定输出：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout<<3126376;
	return 0;
}
```

---


# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# 题解

## 作者：绿萧 (赞：199)

### **拿到这道题，首先分析解题算法。**

如果使用贪心法，每次去最大值，那么可以发现有问题。因为每取一个数，相邻的数就不能再取，那么每次决策就会影响下次结果，从而导致贪心决策不能最优化。

动态规划也是如此，在动态规划中，每一个分步决策不能影响后续结果，所以此算法也排除。

那么再观察数据范围：

**对于100%的数据，N, M≤6,T≤20N,M≤6,T≤20。**

这是一个较小的范围，所以可以考虑暴力枚举，而对于一个图，以及一个变化的状态，**深度优先搜索（dfs）** 应该是一个比较适合的算法。



------------


### **再考虑每个数的状态。**

显然，对于一个数，有取与不取两种状态，状态改变取决于周围取数的变化。我们用 **mark[ i ][ j ]** 记录点 **( i , j )** 附近有几个数，若 **mark[ i ][ j ] ! = 0** 就代表不能取这个数。 

### **接下来上代码，具体部分具体分析**

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
const int d[8][2]={1,0,-1,0,0,1,0,-1,1,1,-1,1,1,-1,-1,-1};//方向数组用来控制搜索时的方向 
int t,n,m,s[8][8],mark[8][8],ans,mx;
void dfs(int x,int y){//搜索函数，表示搜索点(x,y) 
	if(y==m+1){//当y到边界时，搜索下一行 
		dfs(x+1,1);
		return;
	}
	if(x==n+1){//当x到边界时，搜索结束，刷新最大值 
		mx=max(ans,mx);
		return;
	}
	
	dfs(x,y+1);// 不取此数的情况 
	
	if(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）
		ans+=s[x][y];
		for(int fx=0;fx<8;++fx){ //标记周围的数 
			++mark[x+d[fx][0]][y+d[fx][1]];
		}
		dfs(x,y+1);
		for(int fx=0;fx<8;++fx){ //回溯 
			--mark[x+d[fx][0]][y+d[fx][1]];
		}
		ans-=s[x][y];
	}
	
}
int main(){
	cin>>t; 
	while(t--){
		memset(s,0,sizeof(s));
		memset(mark,0,sizeof(mark));//在做每个数据前都要初始化数组 
		cin>>n>>m;
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				cin>>s[i][j];
			}
		}
		mx=0;
		dfs(1,1);//从点(1,1)开始搜索 
		printf("%d\n",mx);//输出答案 
	}
	return 0;
}
```


------------


### **总结**

总体来说，这是一道比较简单的 **dfs** 题，主要需要确定算法和考虑标记状态，其他的就自然迎刃而解了。

---

## 作者：Harry_Potter (赞：66)


这一题每个数是否选择会影响后面的选择情况，所以需要用一个数组来保存
所以状态为当前选到那个数，之前选的数的和以及之前每个数是否选了
之后直接搜索即可。尽管复杂度较高，但因为存在大量的不合法情况所以可以通过
时间复杂度为O（2*n*m)

代码如下
**请不要抄**


```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

int T,n,m,a[10][10],jishu,use[100][100];
void DFS(int x,int y,int z)//x,y为当前搜索到的点
{
	if(x>n)//搜索整个矩阵
	{
		jishu=max(jishu,z);
		return ;
	}
	int xx=x,yy=y+1;//下一个点
	if(yy>m)//搜索下一行
	{
		xx++;
		yy=1;
	}
	if(!use[x-1][y]&&!use[x][y-1]&&!use[x-1][y-1]&&!use[x-1][y+1])//选择这个点
	{
		use[x][y]=1;
		DFS(xx,yy,z+a[x][y]);
		use[x][y]=0;
	}
	DFS(xx,yy,z);//不选这个点
}
int main()
{
    int T;
	cin>>T;
	while(T--) 
	{
		jishu=0;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
		    {
		    	cin>>a[i][j];
		    }	
		}
		DFS(1,0,0);
		cout<<jishu<<endl;
	}

	return 0;
}


```

如有问题，希望大佬多多请教。

---

## 作者：tjztjz (赞：55)

一道裸的搜索水题，思路很简单，不停的dfs就好了，直接上代码：

    #include <iostream>
    using namespace std;

    int T, n, m, a[2018][2018];

    int ans;

    int u[2018][2018];

    void dfs(int x, int y, int z)     //(x, y)表示当前搜到的坐标位置，z表示搜到了(x, y)时，所取得的最大分数
    {
        if (x > n)         //搜完时，更新答案
        {
            ans = max(ans, z);
            return ;
        }
        int next_x = x, next_y = y + 1;   //下一步的坐标(next_x, next_y)
        if (next_y > m)           //如果这一行搜完了
        {
            next_y = 1;           //从下一行的第一列继续搜
            next_x = x + 1;
        }
        if (!u[x - 1][y - 1] && !u[x - 1][y] && !u[x - 1][y + 1] && !u[x][y - 1] && !u[x][y + 1] && !u[x + 1][y - 1] && !u[x + 1][y] && !u[x + 1][y + 1])
        {                        //如果周围的8个点都没有选择的话
            u[x][y] = 1;         //标记这个点已搜
            dfs(next_x, next_y, z + a[x][y]);  //继续搜下一个点
            u[x][y] = 0;
        }
        dfs(next_x, next_y, z);   //如果周围8个点有已被选择的点的话，这个点不能选择，继续下一个点
    }

    int main()
    {
        std::ios::sync_with_stdio(false);   //这句话可以加快读入速度
        cin >> T;
        for (int sth = 1; sth <= T; ++sth)
        {
            ans = 0;                       //ans是答案
            cin >> n >> m;
            for (int i = 1; i <= n; ++i)   //输入输出不解释
                for (int j = 1; j <= m; ++j)
                    cin >> a[i][j];
            dfs(1, 0, 0);                  //开始搜
            cout << ans << endl;
        }
        return 0;
    }

---

## 作者：zhi_zhang (赞：37)

这道题用最普通的深搜（因为数据规模小，而且因为选的数要分隔，所以是能过的）
，即搜索一个标记一圈，然后回溯后，查找下一个，这种方法能拿个五十分，剩下的三个点会超时。

49分代码，该代码的Dfs本来只有当前和（大写X）的传值，第一次剪枝后才加的坐标传递
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN=6+1;
const int MAXM=6+1;
int T,N,M;
int ans=-1;
int sq[MAXN][MAXM],vis[MAXN][MAXM];
int mx[9]={0,1,1,1,0,0,-1,-1,-1};
int my[9]={0,0,-1,1,1,-1,1,0,-1};
int Rein();
void Dfs(int,int,int);
void Vis(int,int);//标记 
void D_vis(int,int);//删标记，回溯用 
int main()
{
	T=Rein();
	while(T--)
	{
		N=Rein(),M=Rein();
		for(int i=1;i<=N;i++)
			for(int j=1;j<=M;j++)
				sq[i][j]=Rein();
		Dfs(0,1,1);
		printf("%d\n",ans);
		ans=-1;
	}
	return 0;
}
int Rein()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=10*x+c-'0';
		c=getchar();
	}
	return f*x;
}
void Dfs(int X,int x,int y)
{
	bool poi_rem=false;
	for(int i=1;i<=N;i++)
	{
		for(int j=1;j<=M;j++)
		{
			if(!vis[i][j])
			{
				poi_rem=true;
				Vis(i,j);
				Dfs(X+sq[i][j],i,j);
				D_vis(i,j);
			}
		}
	}
	if(!poi_rem)
	{
		ans=max(ans,X);
	}
}
void Vis(int x,int y)//标记 
{
	for(int i=0;i<=8;i++)
	{
		int dx=x+mx[i],dy=y+my[i];
		vis[dx][dy]++;
	}
}
void D_vis(int x,int y)//删标记 
{
	for(int i=0;i<=8;i++)
	{
		int dx=x+mx[i],dy=y+my[i];
		vis[dx][dy]--;
	}
}
```

对于深搜来说，最常见的优化就是剪枝了，最容易看出的剪枝就是，搜完一个点之后，该点所在行之前的点就不用搜了，因为会和之前的点重复，于是在搜索的时候，每个点从遍历整个矩阵找下个点，改为找这个点所在行及其以下的所有点

剪枝后这次多A了一个点（才一个点啊）

修改后的Dfs

```cpp
void Dfs(int X,int x,int y)
{
	bool poi_rem=false;
	for(int i=x+1;i<=N;i++)//没错只有这里变了i=1变成了i=x+1
	{
		for(int j=1;j<=M;j++)
		{
			if(!vis[i][j])
			{
				poi_rem=true;
				Vis(i,j);
				Dfs(X+sq[i][j],i,j);
				D_vis(i,j);
			}
		}
	}
	if(!poi_rem)
	{
		ans=max(ans,X);
	}
}
```

再找新的剪枝，既然不用搜该点所在行以上的点，那么标记的时候就不用管上面的点，每次标记和删除标记都会少三次++或--

修改后的数组和标记/删标记数组

```cpp
int mx[9]={0,1,1,1,0,0};
int my[9]={0,0,-1,1,1,-1};

void Vis(int x,int y)//标记 
{
	for(int i=0;i<=5;i++)
	{
		int dx=x+mx[i],dy=y+my[i];
		vis[dx][dy]++;
	}
}
void D_vis(int x,int y)//删标记 
{
	for(int i=0;i<=5;i++)
	{
		int dx=x+mx[i],dy=y+my[i];
		vis[dx][dy]--;
	}
}
```

然后又多A了一个点（还有一个点啊）

然后是最后的剪枝了，这次剪了两处，一处是直接从该点所在行所在列的下一列开始搜，这个剪枝要注意最开始的Dfs（0,1,1）（当前和，上一个点的行，上一个点的列）改为了Dfs（0,1,0）

另一处是判断没有点可以扩展时，还加上了判断条件当前和要大于当前存储的答案，然后在赋值的时候去掉了库里自带的max函数

修改后的main函数

```cpp
int main()
{
	T=Rein();
	while(T--)
	{
		N=Rein(),M=Rein();
		for(int i=1;i<=N;i++)
			for(int j=1;j<=M;j++)
				sq[i][j]=Rein();
		Dfs(0,1,0);//这里原来是Dfs(0,1,1)
		printf("%d\n",ans);
		ans=-1;
	}
	return 0;
}

//修改后的Dfs
void Dfs(int X,int x,int y)
{
	bool poi_rem=false;
	for(int i=y+1;i<=M;i++)//先搜完当前行
	{
		if(!vis[x][i])
		{
			poi_rem=true;
			Vis(x,i);
			Dfs(X+sq[x][i],x,i);
			D_vis(x,i);
		}
	}
	for(int i=x+1;i<=N;i++)
	{
		for(int j=1;j<=M;j++)
		{
			if(!vis[i][j])
			{
				poi_rem=true;
				Vis(i,j);
				Dfs(X+sq[i][j],i,j);
				D_vis(i,j);
			}
		}
	}
	if(!poi_rem&&ans<X)//这里不知道有没有用但还是改了
	{
		ans=X;
	}
}
```

然后就可以AC了

当然这是我~~比较菜~~为了演示剪枝才做了这么多，每次多A一个点课堂效果也不错


---

## 作者：CRH380B (赞：29)

（AC代码，未优化，但对于此题已经足够了。）

```cpp

#include<cstring>
#include<cstdio>
int n,m,ans;
int a[15][15]；
int dx[9]={0,1,1,1,0,0,-1,-1,-1},dy[9]={0,1,-1,0,-1,1,0,1,-1};//方向增量
int can[15][15];//表示是否可选
void DFS(int i,int j,int now){//i为行，j为列，now为现值
    if(j>m){//列超出，行+1，列归1
        i++;
        j=1;
    } 
    if(i>n){//行超出，更新ans，结束
        if(now>ans)ans=now;
        return;
    }
    int k;
    if(can[i][j]==0){//选
        for(k=1;k<9;k++)can[i+dx[k]][j+dy[k]]++;/*此次不能用bool存储，可能有多重状态*/
        DFS(i,j+2,now+a[i][j]);
        for(k=1;k<9;k++)can[i+dx[k]][j+dy[k]]--;
    }
    DFS(i,j+1,now);//不选
}
int main(){
    int t,i,j;
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&n,&m);
        ans=0;
        for(i=1;i<=n;i++){
            for(j=1;j<=m;j++)scanf("%d",&a[i][j]); 
        }
        memset(can,0,sizeof(can));
        DFS(1,1,0);
        printf("%d\n",ans);
    }
    return 0;
}

```

---

## 作者：IntrepidStrayer (赞：23)

# 状压DP
对于本题中,每个数取或不取，只会影响到上下两行的决策；而每行的决策，只与上一行的决策有关。很显然，此题可以用DP解决。
### 思路：
对于每一行的决策，可用**二进制表示**，每位上1表示取，0满足取出的任意两个数字不相邻，则可以分为同一行和相邻两行来判断。
判断过程中，发现重复判断某行的某个决策是否合法（就有无横向相邻的1而言）。其实我们无需每次某一行的决策是否合法，只需 **预处理出**
$0..2^m -1$ 中**所有符合条件的决策**，存在数组(c)里。
### 状态转移方程：
令 $ f[i][j] $ 表示第$i$行，取数方式为$j$时，能取到的最大值，则

$ f[i][j]=max ( f[i-1][k] ) + sum(i,j)	$
 
$sum(i,j)$表示第i行按j的方案取所得的值。

其中

    !(j&(k<<1))&&!(j&k)&&!(j&(k>>1))。

    
答案$ ans=max(f[n][j])$

### 时间复杂度：
$ O (Tn 2^{2m} )$
### 代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define max(a,b) (a>b?a:b)
#define rei register int
#define _ 0
inline int read() {
	int res=0;
	char ch;
	bool f=true;
	for(ch=getchar(); ch<'0'||ch>'9'; ch=getchar())if(ch=='-')f=false;
	for(; ch>='0'&&ch<='9'; ch=getchar())res=(res<<1)+(res<<3)+(ch^48);
	return f?res:-res;
}
const int N=7;
const int M=64;
int a[N][N],f[N][M],n,m,T,v,ans,c[M],cnt;
bool check1(int x){
	for(;x;x>>=1)if((x&3)==3)return false;
   //(3)O=(11)B
	return true;
}
bool check2(int x,int y){
	//判断相邻两行是否相对合法
	return !(x&(y<<1))&&!(x&y)&&!(x&(y>>1));
}
int calc(int i,int x){//求sum(i,j)
	int res=0;
	for(rei j=m;j>=1&&x;--j,x>>=1)if(x&1)res+=a[i][j];
	return res;
}
int main(){
	T=read();
	for(;T;T--){
		n=read();m=read();
		memset(f,0,sizeof(f));
		memset(c,0,sizeof(c));
		cnt=0;
		for(rei i=0;i<(1<<m);++i) 
  			if(check1(i))c[++cnt]=i;//预处理
		for(rei i=1;i<=n;++i)
			for(rei j=1;j<=m;++j)
				a[i][j]=read();
		for(rei i=1;i<=n;++i)//DP部分
			for(rei j=1;j<=cnt;++j){
				v=0;
				for(rei k=1;k<=cnt;++k)
					if(check2(c[j],c[k]))
  						v=max(v,f[i-1][k]);
				f[i][j]=calc(i,c[j])+v;
			}
		ans=0;
		for(rei j=1;j<=cnt;++j)//找答案
			ans=max(ans,f[n][j]);
		printf("%d\n",ans);
	}
	return ~~(0^_^0);
}
```

---

## 作者：lytqwq (赞：16)

$2020/1/30 $：

发现之前写的$ TLE $了，数据加强了？~~洛谷变慢了？~~

现在来改一下，再找几个剪枝。然后发现关键在$ endl$中，它太慢了，会刷新输入，我们用$'\n'$来代替




解释在注释上
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[8][8],l,b[8][8],s;
int dp[9];
void dfs(int x,int y)
{
	if(x>=2)//~~~~~~~~~~~~~~
	{
		if(dp[x-1]>s)//众所周知dp没有后效性，所以等到他之前的就没有后效性了 
		{
			return ;//新增剪枝，判断现在是不是比之前的最大值小，如果是就return 
    	}
    	else
    	{
    	    dp[x+1]=s;
		}
	}//~~~~~~~~~~~~~~~~~~
	
	int k=0;//判断是不是一个也放不了了 
	for(int i=x;i<=min(n,x+3);i++)//因为前面的都搜过一次了，所以接着后面搜。不加这个剪枝只有49分。。。 当然现在我也不知道有几分了 
	{
		//min的原因是：如果还取的话，x到min(x+3,n)行中 肯定还有取的 
		for(int o=1;o<=m;o++)
		{
			if(b[i][o]==0&&b[i-1][o]==0&&b[i-1][o-1]==0&&b[i-1][o+1]==0&&b[i][o-1]==0&&b[i][o+1]==0&&b[i+1][o-1]==0&&b[i+1][o]==0&&b[i+1][o+1]==0)//如果四周都没有被用 
			{
				k=1;//还有能搜的 
				s=s+a[i][o];//把数加上 
				b[i][o]=1;//标记 
				dfs(i,o);//接着搜 
				b[i][o]=0;//回溯 
				s=s-a[i][o];
			}
		}
	}
	if(k==0&&l<s)//取最大的 
	{
		l=s;
	}
}
int main()
{
	int t;
	cin>>t;
	while(t>0)//多组数据 
	{
		l=0;
		t--;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		{
			for(int o=1;o<=m;o++)
			{
				scanf("%d",&a[i][o]);
				b[i][o]=0;//输入+标记为没用 
			}
			dp[i]=-1;
		}
		dp[0]=-1;//初始化dp数组 
		dp[n+1]=-1;
		s=0;
		dfs(1,1);//爆搜 
		cout<<l<<"\n";//输出 
	}
}
```

---

## 作者：回头是岸 (赞：11)

因为看大多数题解都是搜索，于是就来发个状压DP的题解
设f[i][j],表示现在枚举到第i行，用一个二进制数表示这行的状态，如果某一位是1，说明这行这个位置会被取，因为这行的状态与上一行有关，所以f[i][j]=max(f[i][j],f[i-1][k]+sum)。(sum表示这行取的数的总和),我们可以采用预处理每一行可用的状态来优化时间。
```cpp
#include<bits/stdc++.h>
const int maxn=7;
const int maxm=1<<maxn;
using namespace std;
int T,n,m,f[maxn][maxm],a[maxn][maxn];
vector<int>t;
void work(){
	for(int i=0;i<(1<<m);i++)if(!(i&(i>>1))&&!(i&(i<<1)))t.push_back(i);
}
int main(){
	scanf("%d",&T);
	for(;T;T--){
		int ans=0;
		memset(f,0,sizeof(f));
		scanf("%d %d",&n,&m);
		for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
		work();
		for(int i=1;i<=n;i++){
			for(int j=0;j<t.size();j++)
				for(int k=0;k<t.size();k++){
					int u=t[j],v=t[k];
					if((u&v)||(u&(v>>1))||(u&(v<<1)))continue;
					int num1=0;
					for(int l=0;l<m;l++)if((u&(1<<l)))num1+=a[i][m-l];
					f[i][u]=max(f[i][u],f[i-1][v]+num1);
				}
		}	
		for(int i=0;i<t.size();i++)ans=max(ans,f[n][t[i]]);
		printf("%d\n",ans);
		t.clear();
	}
	return 0;
}

```



---

## 作者：神一般的世界 (赞：11)

状压DP最好了（难得一时兴起来一波牛刀杀鸡）

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;
const int N=10,M=256;
int a[N][N],f[N][M],num[M],jump[N];
int T,n,m,ans,tot=0;
int main(){
    for(int i=0;i<(1<<7);i++)if(!(i&(i<<1))){tot++;num[tot]=i;}//先求出好的状态
    jump[0]=1;jump[1]=2;for(int i=2;i<N;i++)jump[i]=jump[i-1]+jump[i-2];//推出每种m对应的好的状态数
    scanf("%d",&T);
    for(int ii=1;ii<=T;ii++){
        memset(f,0,sizeof(f));ans=0;
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=jump[m];j++){
                int t=num[j];int sum=0;
                for(int l=m;l>=1;l--,t=t>>1)if(t&1)sum+=a[i][l];
                for(int k=1;k<=jump[m];k++){
                    if((num[j]&num[k])||(num[j]&(num[k]<<1))||(num[j]&(num[k]>>1)))continue;
                    else f[i][j]=max(f[i][j],sum+f[i-1][k]);
                }
            }
        }
        for(int i=1;i<=jump[m];i++)ans=max(ans,f[n][i]);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：傅思维666 (赞：10)

一道搜索题。

这题我用的是地图遍历题的第二种深搜处理方法。

简单地讲一下，就是一行一行搜，一行搜完了就下一行搜，每到一个点枚举8个方向，如果都合法就进行深搜，否则就不搜。这里要注意，我们一开始的深搜入口是1,1，但是我们不知道最优方案可不可以取这个1,1的点的权值，所以我们还需要继续搜一遍不取1,1的情况。这样就可以过了。

代码：

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ans,map[10][10];
bool v[10][10];
bool check(int x,int y)
{
    if(v[x][y+1]==0 && v[x][y-1]==0 && v[x+1][y]==0 && v[x+1][y+1]==0 &&
    v[x+1][y-1]==0 && v[x-1][y]==0 && v[x-1][y+1]==0 && v[x-1][y-1]==0)
        return 1;
    return 0;
}
void dfs(int x,int y,int z)
{
    ans=max(ans,z);
    int xx=x;
    int yy=y+1;
    if(yy>m)
    {
        xx=x+1;
        yy=1;
        if(xx>n)
            return;
    }
    if(check(xx,yy))
    {
        v[xx][yy]=1;
        dfs(xx,yy,z+map[xx][yy]);
        v[xx][yy]=0;
    }
    dfs(xx,yy,z);
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        ans=0;
        memset(v,0,sizeof(v));
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                scanf("%d",&map[i][j]);
        v[1][1]=1;
        dfs(1,1,map[1][1]);
        memset(v,0,sizeof(v));
        dfs(1,1,0);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：LSG_waterf (赞：5)

这是一道典型的dfs爆搜题，分8个方向，但是，我们要注意的是我们如果只用1和0标记这个点是否走过，是不行的，因为当两个增加的点有重复部分的话，你return去掉一个那个重复部分就会被标记为0，但他旁边还是有一个选中，应当还是1，所以，我们计数每次++或--。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[9]={-1,-1,-1,0,0,0,1,1,1},dy[9]={-1,0,1,-1,0,1,-1,0,1};//一共有9个点要标记，要一一对应。
int t,n,m,a[10][10],vis[10][10],ans;
void change(int x,int y,int w)//这个w就是1。
{
	for(int i=0;i<9;i++)
	{
		int vx=x+dx[i],vy=y+dy[i];
		if(vx<1||vx>n||vy<1||vy>m) continue;//判断边界。
		vis[vx][vy]+=w;
	}
}
void dfs(int x,int y,int w)//w为当前取出的数的值
{
	if(x>n&&y==1) {ans=max(ans,w);return;}//找出最大值。
	if(y<m) //当已经搜到某一行但不是最后一列的时候，继续向这一行的下一列搜。
	{
		if(vis[x][y]==0)
		{
			change(x,y,1);//累加
			dfs(x,y+1,w+a[x][y]);
			change(x,y,-1);//回溯
		}
		dfs(x,y+1,w);
	}
	if(y==m) //当已经搜到当前一行的最后一列，往下一行第一列搜。。
	{
		if(vis[x][y]==0)
		{
			change(x,y,1);//累加
			dfs(x+1,1,w+a[x][y]);
			change(x,y,-1);//回溯
		}
		dfs(x+1,1,w);
	}
}
int main()
{
//	freopen("number.in","r",stdin);
//	freopen("number.out","w",stdout);
	cin>>t;
	while(t--)
	{
		memset(vis,0,sizeof(vis));//注意每次数组清零！
		ans=-1;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) cin>>a[i][j];
		dfs(1,1,0);//一开始所有选出的数字的和为零
		cout<<ans<<"\n";
	}
	return 0;
}
```


---

## 作者：Vocalise (赞：4)

## 这题可以用状压DP做，只有想不到，没有做不到

数据范围如此之小，一方面想到用爆搜做，另一方面，看到熟悉的约束条件——

> 每一个位置只会影响到8联通的格子。

就可以发现，每一列的取值只会影响到左右两列，每一行的取值只会影响到上下两行。

所以，我的思路是：

### 设计状态：

>$f[i][j]$为考虑前i列，最后一列的摆放形如j的最大取值。

这样，第$i$行之后的取值和$i$行前的取值就一点关系都没有了。

### 方程：

$$f[i][j]=\min{f[i-1][k]}+\sum_{p\in j}a[p][i]$$

其中
~~~~
!(j&k)&&!((j<<1)&k)&&!((j>>1)&k)
~~~~
表示八个方向不影响。

目前为止都很顺利。但是数字之间还不能上下相邻啊，而我们枚举状态要判重似乎冗余了点。

所以我们要用另一个数组$fun[]$来存每一行基本合法（指本身不冲突）的状态；这样我们$f$中的第二维就可以简单地表示成该状态在$fun$数组中的下标了。

复杂度是
$$n\times 2^n\times n\times \times 2^n$$
=
$$ 2^{2n}\times n^2$$

看起来大了点。但是$n \leq= 6$还有什么好说的？？？

## 注意事项

因为我们的状态中有一维对于统计答案是不足取的，所以最后我们还要枚举$f[m]$中的每一个状态的最优值取$max$.

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>

int n,m,a[7][7];

int f[10][(1<<6)+1];
int fun[(1<<6)+1],tot;
void init(){
	int U=(1<<n)-1;
	for(int i=0;i<=U;i++)
	  if(!(i&(i<<1))&&!(i&(i>>1)))
	    fun[++tot]=i;
}
void solve(){
	std::scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	    std::scanf("%d",a[i]+j);
    init();
    for(int j=1;j<=m;j++)
      for(int i=1;i<=tot;i++){
      	int s=fun[i];
      	int sum=0;
      	for(int p=1;p<=n;p++)
		  if(s&(1<<(p-1)))sum+=a[p][j];
      	for(int k=1;k<=tot;k++)
      	  if(!(fun[k]&s)&&!(fun[k]&(s<<1))&&!(fun[k]&(s>>1))){
		    f[j][i]=std::max(f[j][i],f[j-1][k]+sum);
		  }
	  }
	int ans=0;
	for(int i=1;i<=tot;i++)
	  ans=std::max(ans,f[m][i]);
	std::printf("%d\n",ans);
	return;
}

int main(){
	int t;std::cin>>t;
	while(t--){
		tot=0;
		memset(f,0,sizeof(f));
		solve();
	}
	return 0;
}//状压DP一遍过,NB 
```
还想练练状压DP的话可以移步[P1896互不侵犯](https://www.luogu.com.cn/problem/P1896),思路和代码都很像，那题多了一维。

---

## 作者：何卓然 (赞：3)

看数据范围 n < 6

用二进制枚举显然是没有办法通过全部数据的，这样的暴力做法问题主要在于，有许多选出了非法的（即相邻的）数字的方案都被一一枚举出，显然我们可以通过深度优先搜索的方式在排查方案的过程中就不去进行这样非法的尝试。


有一点细节要注意，搜索中用全局的 vis 数组维护无法访问的区域，在选择数字的时候要记录 当前选择的这个数字具体改变了那些旁边位置的选择情况，否则你在最后搜索完成后恢复状态时，并不知道这个位置有没有被别的数字占用，无法返回正确的状态继续搜索。


还是挺水的。


**Code**










    
    

```cpp
#include <bits/stdc++.h>
using namespace std;
#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define mp make_pair
#define x first
#define y second
#define pb push_back
#define SZ(x) (int((x).size()))
#define ALL(x) (x).begin(), (x).end()
typedef long long LL;
int t,n,m,ans;
int a[20][20];
bool vis[20][20];
int dx[] = {-1,-1,-1,0,0,0,1,1,1};
int dy[] = {-1,0,1,-1,0,1,-1,0,1};
void init(){
    ans = 0;
    memset(vis,0,sizeof vis);
    scanf("%d%d",&n,&m);
    REP(i,0,n)
        REP(j,0,m)
            scanf("%d",&a[i][j]);
}
bool check(int x,int y){
    return x >= 0 && x < n && y >= 0 && y < m;
}
void dfs(int x,int y,int tot){
    if (x == n && y == 0){
        ans = max(ans, tot);
        return ;
    }
    if (vis[x][y]){
        if (y == m - 1) dfs(x + 1, 0, tot);
        else dfs(x, y + 1, tot);
        return;
    }
    int cx[10],cy[10],cnt = 0;
    REP(i,0,9){
        int curx = x + dx[i], cury = y + dy[i];
        if (check(curx,cury)){
            if (vis[curx][cury] == false){
                vis[curx][cury] = true;
                cx[cnt] = curx;
                cy[cnt] = cury;
                cnt++;
            }
        }
    }
    if (y == m - 1) dfs(x + 1, 0, tot + a[x][y]);
    else dfs(x, y + 1, tot + a[x][y]);
    REP(i,0,cnt) vis[cx[i]][cy[i]] = false;
    if (y == m - 1) dfs(x + 1, 0, tot);
    else dfs(x, y + 1, tot);
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        init();
        dfs(0,0,0);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：AKB48 (赞：3)

题目大意：在一个m\*n的矩形中取数，要求这些数不相邻（周围8个格子）且和最大。

深搜。由于N,M较小，所以可以枚举每个格子取和不取，当搜索到[I,j]时，只需判断它之前的四个就可以了，后面相邻可以由后面枚举的格子判断。

这里还可以做一些空间上的优化，假设枚举到第P个格子，此时他如果mod m =0说明他在行末，且在第 p div m行。否则他在div m+1行，在mod m 列。使用方向数组查看周围节点，继续搜索。


---

## 作者：ZLSer_2015 (赞：2)

我一开始以为是上下左右四个方向，觉得爆搜会t，写到一半发现是八个方向，但是都开始写了就接着写状压了。~~看了题解发现貌似暴力不会tle？~~
我的做法是状压+dfs。
简单来说就是每一行的情况用一个二进制数字表示，比如5是000101，然后我们把它倒过来是101000，它代表我这一行选了下标1和3的数字，其他不选。那么我们把这行能选的状态存在数组ii里面，m等于几对应的边界存在数组lim[]里面，每次for从0～lim[m],一个个情况看看能不能选，能选就dfs下去。
那么我们怎么判断一个状态能不能选呢，我们下传了个lst表示上一层的选择会导致这一层哪些位置不能选，所以如果ii[i]&lst != 0则表示ii[i]这个状态选到了不该选的位置。
那么lst怎么传呢= =我们开一个数组jj[i]表示我们选择了ii[i]时对应下一行不能选择的位置，所以直接下传jj[i]就行。
最后是ii和jj如何做出来= =当然你手算也是可以的，但是我懒，我写了个程序来算：
```cpp
#include <iostream>
using namespace std;
int main() {
	for(int i=1; i<=2*2*2*2*2*2-1; i++)
		if(!(i&(i>>1)))
			cout<<i<<",";
	cout<<endl;
	for(int i=1; i<=2*2*2*2*2*2-1; i++)
		if(!(i&(i>>1)))
			cout<<((i|(i<<1)|(i>>1))&(63))<<",";
	cout<<endl;
	return 0;
}
```
大概就是如果i和i左移没有重叠，那么就没有两个贴着的，所以左右方向不能有1没问题了.达成条件的就是有效状态，输出。然后一个位置选了1，就是左下、下、右下三个位置都不行，所以下一行不能放1的位置就是左移一下，右移一下，或起来，但是只取最后6位，所以加个&63。
然后因为是在学dfs，所以我写的是dfs，而且我写的比较丑，所以会慢= =不过问题不大，能过就是了。
```cpp
#include <iostream>
using namespace std;
int n,m,Q,ans,a[10][10];
const int ii[] = {0,1,2, 4, 5, 8, 9,10,16,17,18,20,21,32,33,34,36,37,40,41,42};
const int jj[] = {0,3,7,14,15,28,31,31,56,59,63,62,63,48,51,55,62,63,60,63,63};
const int lim[] = {0,1,2,4,7,12,20};
void dfs(int x, int sum, int lst) {
    if(x > n) {
        if(sum > ans)
            ans = sum;
        return;
    }
    for(int i=0; i<=lim[m]; i++) {
        if(ii[i] & lst) continue;
        int tmp = sum;                                                                       
        for(int j=0; j<m; j++)
            if((1<<j)&ii[i])
                tmp += a[x][j+1];
        if(tmp >= sum)
        dfs(x+1,tmp,jj[i]);
    }    
}
int main() {
    cin>>Q;
    for(int q=1; q<=Q; q++) {
        ans = -1000000000;
        cin>>n>>m;
        for(int i=1; i<=n; i++)
            for(int j=1; j<=m; j++)
                cin>>a[i][j];
        dfs(1,0,0);
        cout<<ans<<endl;
    }
    return 0;
}
```
感觉都状压了貌似记忆化一下或者干脆当dp做会更快？以后有空再写吧= =我比较弱写的也丑，能过我就满足了。

---

## 作者：AmadeusSG (赞：2)


瞅了瞅几位大佬，惊喜（meng bi）我的算法还是有点与（ju）众（ruo）不（bao）同（ling）的。
	这道题只要不像某些蒟蒻~~（本人前几次提交就是这样）~~无脑搜索，都还是可以的。
	
   **祭上代码：状压dp+dfs**

```

#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m;
int mp[10][10];
int dp[100][100];
int get_sum(int j,int k){
	int ans=0;
	for(int i=0;i<m;i++){
		if(k&(1<<i))ans+=mp[j][i+1];
	}
	return ans; 
}
int check(int a)
{
	for(int i=1;i<(1<<m);)
	{
		if((a&i)&&(a&i<<1))return 1;
		i<<=1;
	}
	return 0;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		scanf("%d",&mp[i][j]);
		memset(dp,-1,sizeof(dp));
		dp[0][0]=0;
		for(int i=1;i<=n;i++)
		for(int j=0;j<(1<<m);j++)
		if(dp[i-1][j]!=-1)
		{
			for(int k=0;k<(1<<m);k++)
			{
				if(j<<1&k||j>>1&k||j&k||check(k))continue;
				dp[i][k]=max(dp[i][k],dp[i-1][j]+get_sum(i,k));
			}
		}
		int ans=0;
		for(int i=0;i<(1<<m);i++)
		ans=max(ans,dp[n][i]);
		cout<<ans<<endl;
	} 
	return 0;
}
```

---

## 作者：xukuan (赞：1)

深度优先搜索

dfs每一个格子， 找到最大值，之后存下来，dfs完之后输出。

##因为每个点不一定只在一个取了的点的后面，所以要用longint(pas）/int(cpp)存储，不能用boolean(pas)/bool(cpp)！

```pascal
uses math;

var
 i,j,k,t,n,m,maxx:longint;
 a,b:array[-10..10,-10..10] of longint;

procedure dfs(x,y,ans:longint);
 begin
  if y=m+1 then//横坐标越界
   begin
    y:=1;
    inc(x);
   end;
  if x=n+1 then//纵坐标越界
   begin
    maxx:=max(maxx,ans)//取较大值;
    exit;//退出
   end;

  while b[x,y]>0 do//找到一个可调用的点
   begin
    inc(y);
    if y=m+1 then
     begin
      y:=1;
      inc(x);
     end;
    if x=n+1 then
     begin
      maxx:=max(maxx,ans);
      exit;
     end;
   end;//同上

  dfs(x,y+1,ans);//这个点不取
  inc(b[x-1,y-1]); inc(b[x-1,y]); inc(b[x-1,y+1]);
  inc(b[x,y-1]); inc(b[x,y]); inc(b[x,y+1]);
  inc(b[x+1,y-1]); inc(b[x+1,y]); inc(b[x+1,y+1]);//赋值
  dfs(x,y,ans+a[x,y]);//这个点取
  dec(b[x-1,y-1]); dec(b[x-1,y]); dec(b[x-1,y+1]);
  dec(b[x,y-1]); dec(b[x,y]); dec(b[x,y+1]);
  dec(b[x+1,y-1]); dec(b[x+1,y]); dec(b[x+1,y+1]);//回溯
end;

begin
 readln(t);
 for i:=1 to t do
  begin
   readln(n,m);
   for j:=1 to n do
    for k:=1 to m do
     read(a[j,k]);//像我手抽，打成read(a[i,j]);无语
   maxx:=0;
   fillchar(b,sizeof(b),0);
   dfs(1,1,0);
   writeln(maxx);
  end;
end.
```

---


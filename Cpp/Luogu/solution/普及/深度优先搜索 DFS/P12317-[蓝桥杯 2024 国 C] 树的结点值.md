# [蓝桥杯 2024 国 C] 树的结点值

## 题目描述

给定一棵包含 $n$ 个结点的树，其树根编号为 $1$。我们规定其第 $i$ 个结点的值为其对应的子树内所有与 $i$ 奇偶性相同的结点数量。请按编号从小到大的顺序输出其每个结点的值。

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$1 \leq n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 2 \times 10^5$，$1 \leq F_i < i$。

## 样例 #1

### 输入

```
5
1
2
1
2```

### 输出

```
3
1
1
1
1```

# 题解

## 作者：MingDynasty (赞：13)

[题目链接](https://www.luogu.com.cn/problem/P12317)

可以看成树形 dp。

## 题目思路：

我们从根节点遍历，每次记录当前的节点和它的父亲，递归下去直到叶子节点，再回溯上来根据当前节点的编号是否是 2 的倍数来修改 dp 数组的值就行。最终我们每一个节点结果就是当前节点对 2 取余作为第二维，节点编号为第一维的 dp 值。

**时间复杂度 $O(n)$。**

## Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,dp[222222][2];
vector<int> edge[222222]; 
inline void dfs(int u,int fa){
	dp[u][u%2]++;
	for(auto v:edge[u]){
		if(v==fa) continue;
		dfs(v,u);
		dp[u][0]+=dp[v][0];
		dp[u][1]+=dp[v][1];
	}
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    for(int i=2;i<=n;i++){
    	cin>>a;
		edge[i].push_back(a);
		edge[a].push_back(i);
	}
	dfs(1,-1);
	for(int i=1;i<=n;i++) cout<<dp[i][i%2]<<'\n';
	return 0;
}
```

祝通过！

---

## 作者：JIN_LONG (赞：5)

## 思路：
因为需要计算每个节点的子树中与其奇偶性相同的节点数量，所以我们可以想到用深度优先搜索遍历树来遍历，并在遍历过程中统计满足条件的节点数，以下是步骤。

- 首先，我们需要构建树的结构（这里就不细说了，用深度优先搜索遍历树来遍历即可）。
- 然后我们要开一个二维数组，$2\times10^5$ 行 $2$ 列。因为它是要求奇偶性一样，所以我们不能只记录一个答案，要记录两个答案。第一列用来存放子树里面奇数点的个数，第二列存放字数里面偶数点的个数。
- 接着，在遍历过程中，需要统计其中与当前节点奇偶性相同的节点数量并检查每个节点的编号与当前节点的奇偶性是否相同，累加计数。
- 将每个节点的结果用那个二维数组分开存储起来，最后按节点编号顺序输出即可。
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[200001][2];
vector<int>a[200001]; 
void dfs(int x){
	f[x][x%2]++;
	for(int i=0;i<a[x].size();i++){
		dfs(a[x][i]);
		f[x][0]+=f[a[x][i]][0];
		f[x][1]+=f[a[x][i]][1];
	}
	return;
}
int main(){
	cin>>n;
	for(int i=2;i<=n;i++){
		int b;
		cin>>b;
		a[b].push_back(i);
	}
	dfs(1);
	for(int i=1;i<=n;i++){
		cout<<f[i][i%2]<<'\n';
	}
	return 0;
}
```

---

## 作者：GeorgeDeng (赞：5)

一道树的遍历题。

[题目传送门](https://www.luogu.com.cn/problem/P12317)

## 题目分析

给定第 $i$ 个节点的父亲为 $fa_i$，求每个节点的子树中和当前节点奇偶性一样的节点有几个。

## 题目做法

很明显这是道 dfs 题目。

题目的输入是父亲表示法，这样不方便 dfs，那怎么办呢？我们可以把父亲表示法变成儿子表示法，这样就好 dfs。具体怎么转换呢？我们把输入的数用变量 $x$ 存起来，转换就可以用这样的方法：

```cpp
g[x].push_back(i);
```

g 是父亲表示法的 vector 名字。

如果你不知道父亲表示法和儿子表示法，在文章的最后有提到。

因为它是要求奇偶性一样，所以我们不能只记录一个答案，要记录两个答案。一个用来存放子树里面奇数点的个数，一个存放字数里面偶数点的个数。遍历的时候要把对应的两个加起来，作为答案。

输出的时候就输出对应奇偶性的答案即可。

## code:


```cpp
#include <iostream>
#include <vector>
using namespace std;

int ji[200005],ou[200005];//存放两个答案
vector<int> g[200005];//存图
int n;
void dfs(int now){
    if(now%2==0) ou[now]++;//注意子树包含自己本身
    else ji[now]++;
    for(auto it:g[now]){//遍历它的字节点
        dfs(it);
        ji[now]+=ji[it];//答案累加
        ou[now]+=ou[it];
    }
}
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i = 2;i<=n;i++){
        int x;
        cin>>x;
        g[x].push_back(i);//变成儿子表示法
    }
    dfs(1);
    for(int i = 1;i<=n;i++){
        if(i%2==0){//输出对应的数
            cout<<ou[i]<<endl;
        }else{
            cout<<ji[i]<<endl;
        }
    }
    return 0;
}
```


## 什么是父亲表示法

父亲表示法就是用数组存树。$fa_i$ 表示节点 $i$ 的父亲。

## 什么是儿子表示法

这种存树方法类似邻接表。

首先定义一个二维的 vector，然后第一维记录这是第几个点，第二维记录这个点的儿子。

这就是儿子表示法。

---

## 作者：xw_qwq (赞：2)

## P12317 [蓝桥杯 2024 国 C] 树的结点值
[题目传送门](https://www.luogu.com.cn/problem/P12317)
### 前言
~~wc 蓝桥杯这题这么水。~~
### 题目思路
记 $val_{x,0}$ 为当前节点为 $x$ 时，它的子树中的点编号为奇数的个数。同理，记 $val_{x,1}$ 为当前节点为 $x$ 时，它的子树中的点编号为偶数的个数。

由于子树节点应算上自己，所以我们在遍历整棵树时先初始化，当当前节点 $x$ 为奇数时，$val_{x,0} = 1$；$x$ 为偶数时，$val_{x,1} = 1$。

若该节点没有子节点，我们在初始化后直接返回，否则遍历它的所有子节点，记 $i$ 为 $x$ 的其中一个子结点，$val_{x,0}$ 加上它所有子节点的 $val_{i,0}$，$val_{x,1}$ 加上它所有子节点的的 $val_{i,1}$，最后按照奇偶性输出即可。
### code

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> g[200005];
int val[200005][2];
void dfs(int x)
{
	if (x % 2)
		val[x][0] = 1;
	else
		val[x][1] = 1;
	if (!g[x].size())
		return ;
	for (auto i : g[x])
	{
		dfs(i);
		val[x][1] += val[i][1];
		val[x][0] += val[i][0];
	}
}
int main()
{
	int n;
	cin >> n;
	for (int i = 2; i <= n; i++)
	{
		int x;
		cin >> x;
		g[x].push_back(i);
	}
	dfs(1);
	for (int i = 1; i <= n; i++)
		cout << val[i][(i % 2 == 1 ? 0 : 1)] << "\n";
	return 0;
}
```

---

## 作者：ZSYhaouuan (赞：2)

很容易看出这就是一道比较基础的树的遍历的题目。

对每一个结点都维护出以它形成的子树的**奇数**数量值和**偶数**数量值。维护就先判断这个结点的奇偶，对应的值加一，然后在加上所有子树的值即可。取答案时，根据结点的奇偶输出即可。

由于我们要先知道子树的值，所以我们在遍历时要采用**后续遍历**。具体看代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N = 2e5+1000;
//用邻接表存树
vector<ll> G[N];
ll n;
ll ji[N], ou[N];//以 i 为根的奇偶树值
// x 代表当前结点, f 代表父亲结点
void dfs(ll x, ll f) {
	if (x % 2 == 0) ou[x] = 1;
	else ji[x] = 1;
	for (auto y : G[x]) {
		if (y == f) continue;//不能判断其父亲
		dfs(y, x);//后续遍历
		ji[x] += ji[y];
		ou[x] += ou[y];
	}
	return;
}
int main() {
	cin >> n;
	for (ll i = 2; i <= n; i++) {
		ll x;
		cin >> x;
		G[x].push_back(i);
		G[i].push_back(x);
	}
	dfs(1, 0);
	for (ll i = 1; i <= n; i++) {
		//根据奇偶输出答案
		if (i % 2 == 0) cout << ou[i] << "\n";
		else cout << ji[i] << "\n";
	}
	return 0;
}
```

---

## 作者：DemonPlayer (赞：2)

### 思路：
使用树形 DP。      
1. 确定状态：$f_{i,j}$ 表示以 $i$ 为根的子树中节点编号对 $2$ 取余余数为 $j$ 的节点数。
2. 确认答案：$f_{i,i\bmod 2}$。
3. 状态转移方程：
   $$f_{i,j}=f_{i,j}+f_{v,j}$$
   其中 $v$ 为节点 $i$ 的儿子。
5. 确定初始值和边界条件：对于任意节点 $f_{i,i\bmod 2}=1$。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;

int n,a,f[maxn][2],u;
vector<int> vi[maxn]; 

void dfs(int idx){
	f[idx][idx%2]++;
	for(int i=0;i<vi[idx].size();i++){
		int v=vi[idx][i];
		dfs(v);
		f[idx][0]+=f[v][0];
		f[idx][1]+=f[v][1];
	}
	return;
}
int main(){
	scanf("%d",&n);
	for(int i=2;i<=n;i++){
		scanf("%d",&u);
		vi[u].push_back(i);
	}
	dfs(1);
	for(int i=1;i<=n;i++){
		cout<<f[i][i%2]<<'\n';
	}
	return 0;
}
```

---

## 作者：Chase12345 (赞：1)

树形 DP 板题。建议先完成 [P1352](https://www.luogu.com.cn/problem/P1352)。

设 $dp_{i,j}$ 表示节点 $i$ 的子树中模 $2$ 结果为 $j$ 的节点数量。

显然地，我们可以通过 $i$ 的所有子节点转移。则
$$
dp_{i,j}=\sum_{k \in son_i}dp_{k,j}
$$
那么这样就可以使用 DFS 进行转移。感谢 [MingDynasty](https://www.luogu.com.cn/user/1015347) 大佬的题解为我提供的思路。总的时间复杂度为 $O(n)$，可以通过此题。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
vector <int> adj[N];
int dp[N][2];

void dfs(int cur, int fa) {
	dp[cur][cur & 1]++;
	for (int nex : adj[cur])
		if (nex != fa) {
			dfs(nex, cur);
			dp[cur][0] += dp[nex][0];
			dp[cur][1] += dp[nex][1];
		}
}

int main() {
	int n;
	cin >> n;
	for (int i = 1, f; i < n; i++) {
		cin >> f;
		adj[f].push_back(i + 1);
		adj[i + 1].push_back(f);
	}
	dfs(1, 0);
	for (int i = 1; i <= n; i++)
		cout << dp[i][i & 1] << '\n';
	return 0;
}
```

---

## 作者：AnOIer (赞：0)

### Solution

非常基础的 DFS 遍历题。

用 $a,b$ 两个数组分别记录 $i$ 的子树中节点为奇数、偶数的点的数量。 

然后在 DFS 中计算每个节点的 $a,b$ 数组的值。

具体步骤如下：

- 在 DFS 开始首先计算当前节点的 $a$ 数组值（节点编号是奇数即为 $1$，否则为 $0$）与 $b$ 数组值（节点编号是偶数即为 $1$，否则为 $0$）。
- 然后遍历这个节点的儿子，进行 DFS，重复以上步骤，直到这个节点没有儿子，此时回溯到它的祖先，如此重复便可以将子树的 $a,b$ 数组值算出来。

计算的递推式如下：

$$a_u=(\sum_{v\in son_u} a_v)+u \bmod 2$$

$$b_u=(\sum_{v\in son_u} b_v)+(u-1) \bmod 2$$

最后按照点的奇偶性输出对应的值即可。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[400010],ans[400010],a[400010],b[400010];
int tot,nxt[400010],to[400010],fst[400010];
void add(int a,int b) { //用链式前向星在两点连一条边
	to[++tot]=b;
	nxt[tot]=fst[a];
	fst[a]=tot;
}
void dfs(int u,int fa) { 
	a[u]=u%2,b[u]=(u%2==0?1:0); //先处理出当前节点的奇偶
	for(int i=fst[u];i;i=nxt[i]) { //遍历
		if(to[i]==fa) { 
			continue;
		}
		dfs(to[i],u); // 进行下一个节点的 DFS
		a[u]+=a[to[i]]; // 加上先前 DFS 得到的子节点的 a 数组值
		b[u]+=b[to[i]]; // 加上先前 DFS 得到的子节点的 b 数组值
	}
} 
int main(){
	int n;
	cin>>n;
	for(int i=2;i<=n;i++) {
		cin>>fa[i];
		add(i,fa[i]); // 连无向边
		add(fa[i],i);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++) {
		if(i%2==1) { // 节点是奇数，输出 a 数组的值
			cout<<a[i]<<"\n";
		}else cout<<b[i]<<"\n"; //否则输出 b 数组的值
	}
	return 0;
}
```

---

## 作者：_IceCream_ (赞：0)

# Content

给你一个 $n$ 个节点的树，让你求出每个节点的子树中编号奇偶性跟这个节点一样的点有多少个。

# Solution

我们记一个 $siz_i$ 表示 $i$ 的子树大小，$odd_i$ 表示 $i$ 的子树中编号为奇数的节点有多少个。

那么有一个很简单的递推式。

$$siz_u = (\sum _ {v \in son_u} siz_v) + 1 \\ odd_u = (\sum _ {v \in son_u} odd_v) + u \bmod 2$$

直接实现即可。注意子树包含这个节点本身。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int n, siz[N], odd[N];

struct Edge { int v, nxt; } e[N << 1];
int ecnt, head[N];
void addEdge (int u, int v) {
	e[++ecnt] = {v, head[u]};
	head[u] = ecnt;
}

void dfs (int u, int fa) {
	siz[u] = 1;
	odd[u] = u % 2; // 子树内编号为奇数的节点个数 
	for (int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].v;
		if (v == fa) continue;
		
		dfs (v, u);
		siz[u] += siz[v];
		odd[u] += odd[v];
	}
}

int main () {

	scanf ("%d", &n);
	for (int i = 2, x; i <= n; ++i) {
		scanf ("%d", &x);
		addEdge (i, x);
		addEdge (x, i);
	}
	dfs (1, 0);
	for (int i = 1; i <= n; ++i) {
		if (i & 1) printf ("%d\n", odd[i]);
		else printf ("%d\n", siz[i] - odd[i]);
	}
	
	return 0;
}

```

---

## 作者：SCma (赞：0)

# 思路
这是一道模拟类树论题，我们需要对树进行**遍历**。

答案只会与子树中奇数点的个数与偶数点的个数有关。输出答案时，只需输出该点奇偶性所对应的答案。我们只需要建立一个数组以存储子树中奇数点和偶数点的个数，而一个点的答案来自于该点本身的奇偶性和所有子节点对应子树的答案。
# 代码

```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define MIN(a,b,c) min(min(a,b),c)
#define MAX(a,b,c) max(max(a,b),c)
#define ri register int
#define int long long
#define fixedset(a) fixed << setprecision(a)
#define pii pair<int,int>
#define mp(a,b) make_pair(a,b)
#define ls(x) x<<1
#define rs(x) x<<1|1
#define MAXN 9.2211e18
#define inf 2114514
#define mf 5011
#define sf 1011
using namespace std;
mt19937_64 randint{std::chrono::steady_clock::now().time_since_epoch().count()};
int n,a,rcd[inf][2];
vector<int> edge[inf]; 
void dfs(int u,int fa){
	rcd[u][u%2]++;
	for(auto v:edge[u]){
		if(v==fa) continue;
		dfs(v,u);
		rcd[u][0]+=rcd[v][0],rcd[u][1]+=rcd[v][1];
	}
	return ;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
	//freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    cin >> n;
    for(ri i=2;i<=n;i++){
    	cin >> a;
		edge[i].push_back(a); edge[a].push_back(i); 
	}
	
	dfs(1,0);
	
	for(ri i=1;i<=n;i++) cout << rcd[i][i%2] << endl;
	return 0;
}

```

---


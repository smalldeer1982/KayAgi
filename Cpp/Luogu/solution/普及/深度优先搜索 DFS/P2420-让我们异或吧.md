# 让我们异或吧

## 题目描述

异或是一种神奇的运算,大部分人把它总结成不进位加法.

在生活中 xor 运算也很常见。比如，对于一个问题的回答，是为 $1$，否为 $0$，那么：

（$A$ 是否是男生）xor（$B$ 是否是男生）＝ $A$ 和 $B$ 是否能够成为情侣

好了，现在我们来制造和处理一些复杂的情况。比如我们将给出一颗树，它很高兴自己有 $N$ 个结点。树的每条边上有一个权值。我们要进行 $M$ 次询问，对于每次询问，我们想知道某两点之间的路径上所有边权的异或值。


## 说明/提示

对于 $40\%$ 的数据，有 $1 \le N,M \le 3000$；  
对于 $100\%$ 的数据，有 $1 \le N ,M\le 100000$。

保证边权在 `int` 范围内。

## 样例 #1

### 输入

```
5
1 4 9644
2 5 15004
3 1 14635
5 3 9684
3
2 4
5 4
1 1
```

### 输出

```
975
14675
0
```

# 题解

## 作者：SNiFe (赞：120)

这道题就是个简单的**DFS**，我不知道为什么各dalao要打lca，这道题就是在DFS中处理u，v到根节点的异或值，然后输出dis[u]^dis[v]就可以了（因为dis[tmp]^dis[tmp]^dis[u]^dis[v]=dis[u]^dis[v])；

我就上代码了：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include<cstring> 
using namespace std;
const int N=100005;
int n,m,k=0,head[N],dis[N];
bool visit[N];
struct node
{int to,next,w;}edge[N*2];
void add(int u,int v,int w)
{
    edge[++k].to=v;edge[k].next=head[u];edge[k].w=w;head[u]=k;
}
void dfs(int id,int val)
{
    dis[id]=val;visit[id]=true;
    for(int i=head[id];i;i=edge[i].next)
        if(!visit[edge[i].to])
            dfs(edge[i].to,val^edge[i].w);//处理异或值 
}
int main()
{
    scanf("%d",&n);
    int u,v,w;
    for(int i=1;i<n;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,w);add(v,u,w);//建边 
    }
    dfs(1,0);scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u,&v);
        printf("%d\n",dis[u]^dis[v]);
    }
}
```

---

## 作者：lrj124 (赞：47)

这题其实很简单

比如说要查询u和v的xor

设tmp为u和v的lca(最近公共祖先)

dis[x]表示x到根的xor

xor有一个性质:x ^ y ^ y = x

就是说将一个数xor两遍另一个数还是那个数

因为dis[u]其中有一部分是dis[tmp],把dis[tmp]异或掉就得到u到tmp的xor

那就将dis[u] ^ dis[tmp]再异或 dis[v] ^ dis[tmp]就得到答案了



```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;
const int maxn = 100000 + 10;
int n,m,r,p,dis[maxn],dep[maxn],father[maxn][18];
vector<pair<int,int> > edges[maxn];
inline void dfs(int now,int f,int Xor) {  //dfs预处理
    dis[now] = Xor;
    for (size_t i = 0;i < edges[now].size();i++)
        if (edges[now][i].first != f) {
            dep[edges[now][i].first] = dep[now]+1;
            father[edges[now][i].first][0] = now;
            dfs(edges[now][i].first,now,Xor^edges[now][i].second);
        }
}
inline void init() {  //倍增
    for (int j = 1;j < 18;j++)
        for (int i = 1;i <= n;i++) father[i][j] = father[father[i][j-1]][j-1];
}
inline int lca(int a,int b) {  //求lca
    if (dep[a] < dep[b]) swap(a,b);
    for (int i = 0;i < 18;i++)
        if ((1<<i)&dep[a]-dep[b]) a = father[a][i];  //让深的点往上走
    if (a == b) return a;  //走到同一点
    for (int i = 18;i >= 0;i--)
        if (father[a][i] != father[b][i]) {  //两个一起往上走
            a = father[a][i];
            b = father[b][i];
        }
    return father[a][0];
}
int main() {
    scanf("%d",&n);
    for (int i = 1,u,v,w;i < n;i++) {
        scanf("%d%d%d",&u,&v,&w);
        edges[u].push_back(make_pair(v,w));
        edges[v].push_back(make_pair(u,w));
    }
    dfs(1,1,1);
    init();
    scanf("%d",&m);
    for (int i = 1,u,v;i <= m;i++) {
        scanf("%d%d",&u,&v);
        int tmp = lca(u,v);
        printf("%d\n",(dis[u]^dis[tmp])^(dis[v]^dis[tmp]));
    }
    return 0;
}
```
xor还满足结合律和交换律
我们将(dis[u]^dis[tmp])^(dis[v]^dis[tmp])打开

得到dis[u]^dis[v]^dis[tmp]^dis[tmp]

那么异或了两次dis[tmp]相当于没有异或

直接算dis[u]^dis[v]就可以了

所以我们就可以去掉求lca的部分

那么就只需要预处理出dis就可以了，一个dfs就行了


```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;
const int maxn = 100000 + 10;
vector<pair<int,int> > edges[maxn];
int n,m,dis[maxn];
inline void dfs(int now,int f,int Xor) {
    dis[now] = Xor;
    for (size_t i = 0;i < edges[now].size();i++)
        if (edges[now][i].first != f) dfs(edges[now][i].first,now,Xor^edges[now][i].second);
}
int main() {
    scanf("%d",&n);
    for (int i = 1,u,v,w;i < n;i++) {
        scanf("%d%d%d",&u,&v,&w);
        edges[u].push_back(make_pair(v,w));
        edges[v].push_back(make_pair(u,w));
    }
    dfs(1,1,1);
    scanf("%d",&m);
    for (int i = 1,u,v;i <= m;i++) {
        scanf("%d%d",&u,&v);
        printf("%d\n",dis[u]^dis[v]);
    }
    return 0;
}
```

---

## 作者：Styx (赞：21)

**切完这道题之后看了看题解，启发良多，看了看似乎没有人会写我这种又蠢又笨常数又大的代码，那就介绍一下吧。本来来切这道题为了学习一下树链剖分，结果几乎要写完了我才发现查询的是边权而非点权，当时一下就蒙了，因为并不知道树剖怎么写边权的，想了一下发现似乎并不是很难，因为点被搜到的顺序也就是边被搜到的顺序，所以一条路径上的边也是相邻的。因此只需要向下传递的时候多传一个边权就可以了。应该还是挺好写的**

**n个节点的树有n-1条边，所以有一些原来写点区间查找的代码部分边界要改一下，代码里我基本已经注释出来了。当然，为什么能用线段树维护，这和xor的性质有关，上面大佬讲了不少了，在此不再赘述,代码如下**

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
#define lson root<<1
#define rson root<<1|1
using namespace std;

struct node
{
    int l,r,lazy,sum;
}tr[400040];
int w[100010],son[100010],fa[100010],id[100010],deep[100010],size[100010],top[100010],vv[100010],cnt=0;
vector<int> g[100010],v[100010];

void push_up(int root)
{
    tr[root].sum=tr[lson].sum^tr[rson].sum;
}

void build(int root,int l,int r)
{
    if(l==r)
    {
        tr[root].l=l;
        tr[root].r=r;
        tr[root].sum=w[l];
        return ;
    }
    tr[root].l=l;
    tr[root].r=r;
    int mid=(l+r)>>1;
    build(lson,l,mid);
    build(rson,mid+1,r);
    push_up(root);
}

int query(int root,int l,int r)
{
	if(l>r)
	{
		return 0;
	}
    if(l==tr[root].l&&r==tr[root].r)
    {
        return tr[root].sum;
    }
    int mid=(tr[root].l+tr[root].r)>>1;
    if(l>mid)
    {
        return query(rson,l,r);
    }
    else
    {
        if(r<=mid)
        {
            return query(lson,l,r);
        }
    }
    return query(lson,l,mid)^query(rson,mid+1,r);
}

void dfs1(int now,int f,int dep)
{
    deep[now]=dep;
    fa[now]=f;
    size[now]=1;
    int maxson=-1;
    for(int i=0;i<g[now].size();i++)
    {
        if(g[now][i]==f)
        {
            continue;
        }
        dfs1(g[now][i],now,dep+1);
        size[now]+=size[g[now][i]];
        if(size[g[now][i]]>maxson)
        {
            maxson=size[g[now][i]];
            son[now]=g[now][i];
            vv[now]=v[now][i];               //存储向重儿子的边的权值
        }
    }
}

void dfs2(int now,int topf,int val)
{
    id[now]=++cnt;
    w[cnt]=val;                             //赋得是到父节点的边权
    top[now]=topf;
    if(!son[now])
    {
        return ;
    }
    dfs2(son[now],topf,vv[now]);
    for(int i=0;i<g[now].size();i++)
    {
        if(g[now][i]==fa[now]||g[now][i]==son[now])
        {
            continue;
        }
        dfs2(g[now][i],g[now][i],v[now][i]);
    }
}

void path_sum(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
        {
            swap(x,y);
        }
        ans^=query(1,id[top[x]]+1,id[x]);          //查询的时候边只有点数减一条，所以要加一
		ans^=w[id[top[x]]];                        //只有从一条链跳到另一条上，连接的边才有贡献。 
        x=fa[top[x]];
    }
    if(deep[x]>deep[y])
    {
        swap(x,y);
    }
    ans^=query(1,id[x]+1,id[y]);                   //查询同上 
    printf("%d\n",ans);
}

int main()
{
    int n,m;
    scanf("%d",&n);
    for(int i=1;i<=n-1;i++)
    {
    	int from,to,ww;
    	scanf("%d%d%d",&from,&to,&ww);
    	g[from].push_back(to);
    	v[from].push_back(ww);
    	g[to].push_back(from);
    	v[to].push_back(ww);
	}
	dfs1(1,0,1);
	dfs2(1,1,0);                                   
	build(1,1,n);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int from,to;
		scanf("%d%d",&from,&to);
		path_sum(from,to);
	}
}
```

---

## 作者：Honor誉 (赞：17)

## 异或
计算机中的符号：^
## 做题时异或的重要性质：
### a^a=0
## 这让我们想到了什么：
### 偶消奇不消
### 即：
### 走过偶数次的路径相当于没有走。
## 应用到这题里面来：
### 这两个点的路径上的值异或：
### 从节点a到节点b的路径上的值异或==a->lca(a,b)->b这一路径上的异或值。
## 画个图表示一下：
![](https://cdn.luogu.com.cn/upload/pic/59879.png)
### 这条路径上的异或其实与下面这条路径的异或相等：
![](https://cdn.luogu.com.cn/upload/pic/59880.png)
### 那我们就可以以任意一个节点为根，求出他到其他节点的异或，要求时直接讲两点的异或值再异或一遍，就可得出结果。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data
{
	int x,y;
};
int b[100001],n,m,x,y,z;
bool vis[100001];
vector<data> a[100001];
void dfs(int x,int sum)
{
	b[x]=sum;
	vis[x]=1;
	for(int i=0;i<a[x].size();i++)
	{
		int v=a[x][i].x,u=a[x][i].y;
		if(!vis[v])
		{
			dfs(v,sum^u);
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		a[x].push_back((data){
			y,z
		});
		a[y].push_back((data)
		{
			x,z
		});
	}
	dfs(1,0);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",b[x]^b[y]);
	}
	return 0;
}
```

---

## 作者：ghj1222 (赞：16)

这题就没人用并查集吗，我弱弱地问一句

然而是先并，后查的

建立一个带权并查集

`g[x]`表示节点x到他直接父亲的异或值

根据异或的可乱搞的性质

注意并查集一定要先getf一下

然后合并同根据异或可乱搞的性质(rt所示)

![](https://cdn.luogu.com.cn/upload/pic/28517.png )

mspaint真心毒瘤

查询的时候先getf一下

然后直接`g[u]^g[v]`即可

```cpp
#include <bits/stdc++.h>

using namespace std;

int f[100010],g[100010],n,m;

int getf(int x)
{
	if(f[x]==x)
		return x;
	int fa=getf(f[x]);
	g[x]^=g[f[x]];
	return f[x]=fa;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
		g[i]=0;
	}
	for(int u,v,w,i=1;i<n;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		getf(u);
		getf(v);
		int fa=f[u];
		f[fa]=f[v];
		g[fa]=g[u]^g[v]^w;
	}
	scanf("%d",&m);
	for(int x,y,i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		getf(x);
		getf(y);
		printf("%d\n",g[x]^g[y]);
	}
	return 0;
}
```

---

## 作者：99NL (赞：5)

### 关于我

大家好，我是一名不知名的蒟蒻，今天来给大家写一发题解。

博客传送门[酸酸的笔记](https://www.luogu.org/blog/99NL/)

# 关于本道题

一开始看见标签有LCA，然后就果断打了一个倍增。~~鬼知道用的只是小小的dfs和一点点的数学知识~~。然后我们下面开始讲这道题目的思路。

还有个人感觉这道题比模板更好写

## 什么是异或

异或，英文为exclusive OR，缩写成xor

异或(xor)是一个数学运算符。它应用于逻辑运算。异或的数学符号为"⊕"，计算机符号为"xor"。其运算法则为:

a⊕b = (¬a ∧ b) ∨ (a ∧¬b)

如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。

异或也叫半加运算，其运算法则相当于不带进位的二进制加法:二进制下用1表示真，0表示假，则异或的运算法则为:0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0(同为0，异为1)，这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。

```
       ------------------摘自百度百科
```
### 异或的一点点性质

对于任意一个数a，对b异或两次所得的结果是一样的。即a=a^b^b

下面正式开始讲这道题目

## 思考

1.这是一个树的结构，我们需要用dfs求出在某个节点到根节点的路径上的异或和。

2.对于每次询问，我们将两个点的异或值再异或起来就行了。

### 注意！！！！

异或和不是指两个节点的异或之和，而是指这两个节点路径上的值全部异或起来。。。。

## 代码+注释
```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
int d[100005];
int worth[100005];

int step1;

struct node{
int to;
int next1;
int last1;
int w;
}map1[200005];//临接表存图 

void add(int x,int y,int z)
{
   map1[++step1].to=y;
   map1[step1].next1=map1[x].last1;
   map1[x].last1=step1;
   map1[step1].w=z;
}
void dfs(int u,int f,int cnt)//其实就是一个倍增 
{
   d[u]=d[f]+1;
   worth[u]=cnt;//统计当前异或值 
   for (int j=map1[u].last1;j;j=map1[j].next1)
   {
      int v=map1[j].to;
      if (v!=f)
         dfs(v,u,cnt^map1[j].w);//向其子节点继续异或下去 
   }
}
int ans(int x,int y)
{
   return worth[x]^worth[y];
}
int main() {
cin>>n;
int a1,a2,a3;
for (int a=1;a<n;a++)
{
   scanf("%d%d%d",&a1,&a2,&a3);
   add(a1,a2,a3);
   add(a2,a1,a3);//添加两次的无向边 
}
dfs(1,0,0);//利用倍增的思想，第三个参数为到当前节点的异或值 
int m;
cin>>m;
for (int a=1;a<=m;a++)
{
   scanf("%d%d",&a1,&a2);
   cout<<ans(a1,a2)<<endl;//用一个函数输出答案 
}
	return 0;
}
```
最慢的点也就一百多ms。。。

---

## 作者：dhy0077 (赞：5)

类似SPOJ的QTREE 树链剖分即可 倍增法也是可做的

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<set>
#include<algorithm>
#include<map>
#include<vector>
#include<queue>
#include<iostream>
#include<string>
#include<cmath>
#define N 400010
#define lc(x) (x<<1)
#define rc(x) ((x<<1)+1)
#define FOR(i,a,b) for(i=(a);i<=(b);i++)
#define ROF(i,a,b) for(i=(a);i>=(b);i--)
typedef long long LL;
using namespace std;
struct node{int l,r,val;};
int last[N],pre[N],e[N],W[N],idx[N];
int w[N],pos[N],siz[N],son[N],fa[N],dep[N],top[N],b[N];
int a[N];char OP[101];
int t1,t2,t3,n,q,len=0,size=0;
void add(int x,int y,int z,int ID)
{pre[++len]=last[x];last[x]=len;e[len]=y;W[len]=z;idx[len]=ID;}
int swap(int &x,int &y){int t=x;x=y;y=t;}
struct segtree
{
  node tree[4*N];
  void init(){memset(tree,0,sizeof(tree));}
  void update(int x){tree[x].val=tree[lc(x)].val^tree[rc(x)].val;} 
  void build(int x,int L,int R)
  {
    tree[x].l=L;tree[x].r=R;int mid=(L+R)>>1;
    if (L==R) {tree[x].val=a[L];return;}
    build(lc(x),L,mid);build(rc(x),mid+1,R);
    update(x);
  }
  int query(int x,int L,int R)
  {
    if (tree[x].l==L&&tree[x].r==R) return tree[x].val;
    int mid=(tree[x].l+tree[x].r)>>1;
    if (R<=mid) return query(lc(x),L,R);
    if (L>mid) return query(rc(x),L,R);
    return query(lc(x),L,mid)^query(rc(x),mid+1,R);
  }
  void modify(int x,int p,int ti)
  {
    if (tree[x].l==tree[x].r) {tree[x].val=ti;return;}
    int mid=(tree[x].l+tree[x].r)>>1;
    if (p<=mid) modify(lc(x),p,ti);
    else modify(rc(x),p,ti);
    update(x);
  }
}Tree;
void DFS1(int x,int par,int Dep)
{
  dep[x]=Dep;siz[x]=1;son[x]=0;
  for(int p=last[x];p;p=pre[p])
  {
    int v=e[p],ID=idx[p];
    if (par==v) continue;
    fa[v]=x;b[v]=W[p];pos[ID]=v;
    DFS1(v,x,Dep+1);
    if (son[x]==0||siz[v]>siz[son[x]]) son[x]=v;
    siz[x]+=siz[v];
  }
}
void DFS2(int x,int Top)
{
  w[x]=++size;top[x]=Top;    
  a[size]=b[x];
  if (son[x]!=0) DFS2(son[x],Top);
  for(int p=last[x];p;p=pre[p])
  {
    int v=e[p];
    if (v==fa[x]||v==son[x]) continue;
    DFS2(v,v);
  }
}
int getans(int va,int vb)
{
  int f1=top[va],f2=top[vb],tmp=0;
  while (f1!=f2)
  {
    if (dep[f1]<dep[f2]){swap(f1,f2);swap(va,vb);}
    tmp=tmp^Tree.query(1,w[f1],w[va]);
    va=fa[f1];f1=top[va];
  }
  if (va==vb) return tmp;
  if (dep[va]>dep[vb]) swap(va,vb);
  return tmp^Tree.query(1,w[son[va]],w[vb]);
}
int Main()
{
  memset(pre,0,sizeof(pre));
  memset(last,0,sizeof(last)); 
  memset(idx,0,sizeof(idx));
  len=size=0;Tree.init();
  scanf("%d",&n);int i,qq;
  FOR(i,1,n-1) 
  {
    scanf("%d%d%d",&t1,&t2,&t3);
    add(t1,t2,t3,i);add(t2,t1,t3,i);
  }
  DFS1(1,-1,1);
  DFS2(1,1);
  Tree.build(1,1,n);
  scanf("%d",&qq);
  FOR(i,1,qq)
  {
    scanf("%d%d",&t1,&t2);
    int ans=getans(t1,t2);
    printf("%d\n",ans);
  }
}
int main()
{
  Main();
}
```

---

## 作者：清风我已逝 (赞：4)

有人用dfs求LCA吗？


维护节点$u$的父亲的同时，也维护抑或值


奉上代码：
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>

#define N 1010100
using namespace std;

int n,m,head[N],tot;
struct nodE {
	int to,next,w;
} e[N];

void add(int u,int v,int w) {
	e[++tot].to=v,e[tot].next=head[u],head[u]=tot,e[tot].w=w;
}

int p[N][26],f[N][26],dep[N];
void dfs(int u,int fa,int w) {
	dep[u]=dep[fa]+1,f[u][0]=fa,p[u][0]=w;
	for(int i=1; (1<<i)<=dep[u]; i++)
		f[u][i]=f[f[u][i-1]][i-1],p[u][i]=p[u][i-1]^p[f[u][i-1]][i-1];//维护父亲，也维护抑或值
	for(int i=head[u]; i; i=e[i].next) {
		int v=e[i].to;
		if(v==fa) continue;
		dfs(v,u,e[i].w);
	}
}

int lca(int u,int v) {
	int an=0;
	if(dep[u]>=dep[v]) swap(u,v);
	for(int i=20; i>=0; i--) {
		if(dep[u]<=dep[v]-(1<<i)) {
			if(!an) an=p[v][i];
			else an^=p[v][i];
			v=f[v][i];
		}
	}
	if(u==v) return an;
	for(int i=20; i>=0; i--) {
		if(f[u][i]!=f[v][i]) {
			if(!an) an=p[v][i]^p[u][i];
			else an^=p[v][i],an^=p[u][i];
			u=f[u][i],v=f[v][i];
		}
	}
	if(v==1) return an^p[u][0];
	else if(u==1) return an^p[v][0];
	return an^p[u][0]^p[v][0];//求LCA模板
}

int main() {
	scanf("%d",&n);
	for(int u,v,w,i=1; i<n; i++) {
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w),add(v,u,w);
	}
	dfs(1,0,0);
	scanf("%d",&m);
	for(int u,v,i=1; i<=m; i++) {
		scanf("%d%d",&u,&v);
		printf("%d\n",lca(u,v));
	}

	return 0;
}

别看这篇题解啦吧，别人的代码都比我短。。。
```

---

## 作者：JBLee (赞：4)

一道绿题，二话不说直接树剖。看清楚题里面的树剖是边权，这是个坑点，直接就是异或即可，用线段树维护异或和。

查询的时候注意最后要避开$LCA$，因为$LCA$根本就没有再路径上，最后跳链的时候不免会有$LCA$，所以$DFS$序要+1。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+7; 
struct node{
	int nxt,to,value;
}edge[maxn*3];
struct node1{
	int l,r,sum;
}tree[maxn*4];
int n,m;
int x,y,v; 
int k,p;
int head[maxn],cnt;
void add(int x,int y,int v){
	edge[++cnt].nxt=head[x];
	edge[cnt].to=y;
	edge[cnt].value=v;
	head[x]=cnt;
}
int dep[maxn],son[maxn],size[maxn],fa[maxn],w[maxn];
void dfs1(int x,int f){
	dep[x]=dep[f]+1;
	size[x]=1;
	fa[x]=f;
	int maxson=-1;
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa[x]) continue;
		w[v]=edge[i].value;
		dfs1(v,x);
		size[x]+=size[v];
		if(size[v]>maxson){
			maxson=size[v];
			son[x]=v;
		}
	} 
}
int top[maxn],id[maxn],rev[maxn],Time;
void dfs2(int x,int topf){
	id[x]=++Time;
	top[x]=topf;
	rev[id[x]]=w[x];
	if(!son[x]) return;
	dfs2(son[x],topf);
	for(int i=head[x];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==son[x]||v==fa[x]) continue;
		dfs2(v,v);
	}
}
void build(int now,int l,int r){
	tree[now].l=l,tree[now].r=r;
	if(l==r){
		tree[now].sum=rev[l];
		return;
	}
	int mid=(l+r)>>1;
	build(now<<1,l,mid);
	build(now<<1|1,mid+1,r);
	tree[now].sum=tree[now<<1].sum^tree[now<<1|1].sum; 
}
int query(int now,int l,int r){
	if(tree[now].l>=l&&tree[now].r<=r) return tree[now].sum;
	int mid=(tree[now].l+tree[now].r)>>1;
	int val=0;
	if(l<=mid) val^=query(now<<1,l,r);
	if(r>mid) val^=query(now<<1|1,l,r);
	return val;
}
int link(int x,int y){
	if(x==y) return 0;
	int ans=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ans^=query(1,id[top[x]],id[x]);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);
	ans^=query(1,id[y]+1,id[x]);//避开LCA
	return ans;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d%d%d",&x,&y,&v);
		add(x,y,v);add(y,x,v);
	} 
	scanf("%d",&m);
	dfs1(1,0);dfs2(1,1);build(1,1,n);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&k,&p);
		printf("%d\n",link(k,p));
	}
	return 0;
} 
```


---

## 作者：wzmszjw (赞：3)

处理出每个点到根的异或值，询问两个点即为这两个点到根的异或值异或一下即可

```cpp
#include<cstdio>  
#define ll long long  
#define M 300100  
using namespace std;  
int n;  
ll m[100100];  
int to1[M],w1[M],first1[M],s1,next1[M];  
int to[M],w[M],first[M],s,next[M];  
void add1(int x,int y,int c){  
    to1[++s1]=y; next1[s1]=first1[x]; first1[x]=s1; w1[s1]=c;  
}  
void build(int x,int y,int c){  
    to[++s]=y;  
     next[s]=first[x];   
     first[x]=s;   
     w[s]=c;  
}  
void dfs(int fa,int p){  
    for(int i=first1[p];i>0;i=next1[i]){  
        int y=to1[i];  
        if(y==fa){  
            continue;  
        }  
        build(p,y,w1[i]);  
        dfs(p,y);  
    }  
}  
void find(int x,ll op){  
    m[x]=op;  
    for(int i=first[x];i>0;i=next[i]){  
        int y=to[i];  
        find(y,w[i]^op);  
    }  
}  
int main(){  
    scanf("%d",&n);  
    int a,b,c;  
    for(int i=1;i<=n-1;i++){  
        scanf("%d%d%d",&a,&b,&c);  
        add1(a,b,c);  
        add1(b,a,c);  
    }  
    dfs(0,1);  
    find(1,0);  
    int num;  
    scanf("%d",&num);  
    for(int i=1;i<=num;i++){  
        scanf("%d%d",&a,&b);  
        printf("%lld\n",m[a]^m[b]);  
    }  
}
```

---

## 作者：jzqjzq (赞：2)

“凡是用树链剖分可以做的题，LCT都是可以做的！”

所以也可以维护一个LCT然后乱搞就行了

具体怎么乱搞嘛，边权放在新的一个节点上，然后各把边的两端link一下就好了

当然啦，边的两端的值都设0好了

然后splay的时候pushup一下（xor）就好了

这题无需cut（嘿嘿），所以还有更好的方法

查找的时候先把一端变为根，另一端access上去，最后把y直接splay一下求出这棵splay的值即可

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstdlib>
#include<string>
#include<ctime>
#include<queue>
#include<climits>
using namespace std;
int t[200001][2],fa[200001],la[200001];
int n,m,zh[200001],v[200001],s[200001];
inline void pushup(int x){s[x]=v[x]^s[t[x][0]]^s[t[x][1]];}
inline void pushdown(int x){
    if(la[x]){
        swap(t[x][1],t[x][0]);
        la[t[x][1]]^=1;la[t[x][0]]^=1;
    }
    la[x]=0;
}
inline bool rt(int x){
    return t[fa[x]][0]!=x&&t[fa[x]][1]!=x;
}
inline void turn(int x){
    int y=fa[x],z=fa[y],l=(x!=t[fa[x]][0]),r=(y!=t[fa[y]][0]);
    int p=t[x][l^1];
    if(!rt(y))t[z][r]=x;
    fa[p]=y;fa[x]=z;t[x][l^1]=y;fa[y]=x;t[y][l]=p;
    pushup(y);pushup(x);
}
inline void splay(int x){
    int i=x,y,z;for(;!rt(i);i=fa[i])zh[++zh[0]]=i;
    zh[++zh[0]]=i;while(zh[0])pushdown(zh[zh[0]--]);
    while(!rt(x)){
        y=fa[x];z=fa[y];
        if(!rt(y)){
            if((t[y][0]==x)^(t[z][0]==y))turn(x);
            else turn(y);
        }
        turn(x);
    }
}
inline void access(int x){
    int p=0;
    while(x){
        splay(x);t[x][1]=p;
        p=x;pushup(x);x=fa[x];
    }
}
inline void chrt(int x){
    access(x);splay(x);la[x]^=1;
}
inline void link(int x,int y){
    chrt(x);fa[x]=y;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<n;i++){
        int x,y,z;scanf("%d%d%d",&x,&y,&z);
        v[n+i]=z;link(x,n+i);link(y,n+i);
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        int x,y;scanf("%d%d",&x,&y);
        chrt(x);access(y);splay(y);
        printf("%d\n",s[y]);
    }
    return 0;
}
```

---

## 作者：寒鸽儿 (赞：1)

dfs建树。  
仿照lca的思路,记录结点到根的异或和。  
两结点的路径异或和即为两结点到根的异或和除去lca到根的异或和的部分。  
根据异或的自反性,lca到根的异或和被异或两次等于没加,不需要做特殊处理。  
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int maxn = 123456;
int head[maxn], ver[maxn<<1], wei[maxn<<1], nex[maxn<<1], tot;
inline void addedge(int u, int v, int w) {
    ver[tot] = v; wei[tot] = w; nex[tot] = head[u]; head[u] = tot++;
}

int xorSum[maxn];
void dfs(int cur, int fa, int w) {
    xorSum[cur] = xorSum[fa] ^ w;
    for(int i = head[cur]; ~i; i = nex[i])
        if(ver[i] != fa)
            dfs(ver[i], cur, wei[i]);
}

int main() {
    memset(head, -1, sizeof(head));
    int n, m, u, v, w;
    scanf("%d", &n);
    for(int i = 1; i < n; ++i) {
        scanf("%d %d %d", &u, &v, &w);
        addedge(u, v, w);
        addedge(v, u, w);
    }
    dfs(1, 0, 0);
    scanf("%d", &m);
    while(m--) {
        scanf("%d %d", &u, &v);
        printf("%d\n", xorSum[u] ^ xorSum[v]);
    }
    return 0;
}
```

---

## 作者：decoqwq (赞：1)

树链剖分裸题

[至于树链剖分，可以看这位大佬的博客](https://www.cnblogs.com/George1994/p/7821357.html)

不过有一些问题，比如如何解决边权？

举个例子:

![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=ea34c817003b5bb5aada28ac57babe5c/c83d70cf3bc79f3d3adc2d8cb9a1cd11728b2949.jpg)

我们将边权赋值为一条边中深度较大的点的点权即可

查询时注意，如查询路径$a-b$，查询完所有链之后会发现多查询了一个$lca(a,b)$，我们就需要对其做一次异或的逆运算

因为异或具有交换律，即

$a$^$(b$^$c)$ $=$ $(a$^$b)$^$c$

故$a$^$(a$^$b)$ $=$ $(a$^$a)$^$b$

所以异或就是异或的逆运算，对答案再异或一次其$lca$值即可

然后进行树链剖分常规操作

关于$lca$，也可以用树链剖分求出

如上方那张图

如果我们要求$(a,b)$的$lca$，伪代码是这样的：
```cpp
while top[a]!=top[b]//重链顶不同
	if a的深度<b的深度
    	swap(a,b)
    a=top[a]的父亲//爬到下一条重链上
   
if a的深度>b的深度
	swap(a,b)
    
return a//当在同一条重链上时，较浅的即为其lca
```

这样就运用了树链剖分的特性来求$lca$，最坏时间复杂度为$O(log^2n)$

于是就基本完成啦！

最后是本题代码：
code：
```cpp
#include <stdio.h>
#include <algorithm>
#include <iostream>
using namespace std;
#define maxn 200001
int seg[maxn],in[maxn],out[maxn],dep[maxn],fa[maxn],top[maxn],son[maxn],siz[maxn];
int head[maxn],sum[maxn<<2],addv[maxn<<2],a[maxn];
int begins[maxn],endsss[maxn],suma[maxn];
struct edge
{
    int next,to;
}e[maxn<<1];
int tot=0;
void add(int u,int v)
{
    tot++;
    e[tot].to=v;
    e[tot].next=head[u];
    head[u]=tot;
}
void dfs1(int u)
{
    siz[u]=1;
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa[u])
        {
            continue;
        }
        fa[v]=u;
        dep[v]=dep[u]+1;
        dfs1(v);
        siz[u]+=siz[v];
        if(siz[v]>siz[son[u]])
        {
            son[u]=v;
        }
    }
}
void dfs2(int u,int tp)
{
    tot++;
    in[u]=tot;
    seg[tot]=u;
    top[u]=tp;
    if(son[u])
    {
        dfs2(son[u],tp);
    }
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa[u]||v==son[u])
        {
            continue;
        }
        dfs2(v,v);
    }
    out[u]=tot;
}
int n,m,r;
#define pushup(o) sum[o]=sum[o<<1]^sum[o<<1|1]
void build(int o,int lf,int rg)
{
    if(lf==rg)
    {
        sum[o]=a[seg[lf]];
        return ;
    }
    int mid=(lf+rg)>>1;
    build(o<<1,lf,mid);
    build(o<<1|1,mid+1,rg);
    pushup(o);
}
int query(int o,int lf,int rg,int l,int r)
{
    if(l<=lf&&rg<=r)
    {
        return sum[o];
    }
    int ans=0;
    int mid=(lf+rg)>>1;
    if(l<=mid)
    {
        ans=ans^query(o<<1,lf,mid,l,r);
    }
    if(mid<r)
    {
        ans=ans^query(o<<1|1,mid+1,rg,l,r);
    }
    return ans;
}
int qpath(int x,int y)
{
    int ans=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])
        {
            swap(x,y);
        }
        ans=ans^query(1,1,n,in[top[x]],in[x]);
        x=fa[top[x]];
    }
    if(dep[x]<dep[y])
    {
        swap(x,y);
    }
    ans=ans^query(1,1,n,in[y],in[x]);
    return ans;
}
int lca(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(dep[top[u]]<dep[top[v]])
        {
            swap(u,v);
        }
        u=fa[top[u]];
    } 
    if(dep[u]>dep[v])
    {
        swap(u,v);
    }
    return u;
}
int main()
{
    cin>>n;
    for(int i=1;i<n;i++)
    {
        scanf("%d%d%d",&begins[i],&endsss[i],&suma[i]);
        add(begins[i],endsss[i]);
        add(endsss[i],begins[i]);
    }
    tot=0;
    dep[1]=1;
    dfs1(1);
    tot=0;
    dfs2(1,1);
    for(int i=1;i<n;i++)
    {
    	if(dep[begins[i]]>=dep[endsss[i]])
    	{
    		swap(begins[i],endsss[i]);
    	}
    	a[endsss[i]]=suma[i];//给深度较大的点赋边权
    }
    build(1,1,n);
    cin>>m;
    for(int i=1;i<=m;i++)
    {
    	int x,y;
    	scanf("%d%d",&x,&y);
    	printf("%d\n",qpath(x,y)^a[lca(x,y)]);
    }
}
```


---

## 作者：Out_Land (赞：1)

很简单，题目意思很明确让我们跑 lca ，于是我就老老实实写了一遍模板。注意：边跑边异或，用倍增跑。

对 lca 不太熟的我竟然一遍水过~~
```pascal
var
        n,m,i,j,k,s,x,y,z:longint;
        first,next,en,len,deep:array[0..1000001] of longint;
        rmq,g:array[0..200001,0..20] of longint;
procedure add(x,y,z:longint); //邻接表存储
begin
        inc(s);
        next[s]:=first[x];
        first[x]:=s;
        en[s]:=y;
        len[s]:=z;
end;
procedure dfs(x:longint); //搜索，求出深度及每个点的父节点，并存进初值。
var
        t:longint;
begin
        t:=first[x];
        while t>0 do
        begin
        		// x 为父节点，en[t] 为子节点。
                if en[t]<>rmq[x,0] then
                begin
                        rmq[en[t],0]:=x;
                        deep[en[t]]:=deep[x]+1; 
                        //子节点比父节点深度多1。
                        g[en[t],0]:=len[t];
                        dfs(en[t]);
                end;
                t:=next[t];
        end;
end;
function lca(x,y:longint):longint; //跑 lca
var
        ans,i:longint;
begin
        ans:=0;
        if deep[x]>deep[y] then //把大的放后面，后文好处理。
        begin
                i:=x;
                x:=y;
                y:=i;
        end;
        for i:=19 downto 0 do
                if deep[y]-deep[x]>=1<<i then
                //先让深度大的往上跑（倍增），直到跑到和另一个点深度一样。
                begin
                        ans:=ans xor g[y,i];
                        //边跑边异或
                        y:=rmq[y,i];
                end;
        if x=y then exit(ans); //如果到了同一个点，退出。
        for i:=19 downto 0 do
                if rmq[x,i]<>rmq[y,i] then
                //两个点同时向上跑。
                begin
                        ans:=ans xor g[x,i] xor g[y,i];
                        x:=rmq[x,i];
                        y:=rmq[y,i];
                end;
        //跑完后两个点的父节点就是 lca 
        ans:=ans xor g[x,0] xor g[y,0];
        //把到 lca 的边也异或一遍。
        exit(ans);
end;
begin
        readln(n);
        for i:=1 to n-1 do //读入，用邻接表存
        begin
                readln(x,y,z);
                add(x,y,z);
                add(y,x,z);
        end;
        dfs(1); //搜索
        //rmq[i,j] 表示 i 向上跑 2^j 的深度所到的点
        //g[i,j] 表示 i 向上跑 2^j 的深度时所经过所有边的异或值
        for j:=1 to 19 do //做 rmq（倍增跑）
                for i:=1 to n do
                begin
                        rmq[i,j]:=rmq[rmq[i,j-1],j-1];
                        g[i,j]:=g[i,j-1] xor g[rmq[i,j-1],j-1];
                end;
        readln(m);
        for i:=1 to m do //读入询问
        begin
                readln(x,y);
                writeln(lca(x,y)); //离线 lca 搞定！
        end;
end.
```

---

## 作者：Hzxleo4 (赞：1)

这么多题解竟然没有倍增的。。

来一发倍增吧!


```cpp
#include <cstdio>
int n, m, s, cnt1;
struct node{
    int a, b, c, n;
} d[1000001];
int h[500001], p[500001], dep[500001], ru[500001];
int st[500001][20], yi[500001][20];
int read(){
    int x, f = 1;
    char ch;
    while(ch = getchar(), ch<'0'||ch>'9'){
        if(ch == '-') f = -1;
    }
    x = ch - 48;
    while(ch = getchar(), ch>='0'&&ch<='9') x = x * 10 + ch - 48;
    return x*f;
}
void cr1(int a, int b, int c){
    d[++cnt1].a = a; d[cnt1].b = b; d[cnt1].c = c; d[cnt1].n = h[a]; h[a] = cnt1;
}
void dfs(int a){
    int i, b;
    for(i = h[a]; i; i = d[i].n){
        b = d[i].b;
        if(!dep[b]){
            dep[b] = dep[a] + 1;
            st[b][0] = a;
            yi[b][0] = d[i].c;
            dfs(b);
        }
    }
}
void make_st(){
    int i, j;
    for(j = 1; j <= 19; j++){
        for(i = 1; i <= n; i++){
            st[i][j] = st[st[i][j-1]][j-1];
            yi[i][j] = yi[i][j-1] ^ yi[st[i][j-1]][j-1];
        }
    }
}
int query(int x, int y){
    int i, t, a = 0, b;
    if(dep[x] > dep[y]) t = x, x = y, y = t;
    t = dep[y] - dep[x];
    for(i = 19; i >= 0; i--){
        if(1 << i & t) a ^= yi[y][i], y = st[y][i];
    }
    if(x == y) return a;
    for(i = 19; i >= 0; i--){
        if(st[x][i] != st[y][i]){
            a ^= yi[x][i];
            a ^= yi[y][i];
            x = st[x][i];
            y = st[y][i];
        }
    }
    a ^= yi[x][0]; a ^= yi[y][0];
    return a;
}
int main(){
    int i, j, a, b, c;
    n = read();
    for(i = 1; i <= n - 1; i++){
        a = read(); b = read(); c = read();
        cr1(a, b, c);
        cr1(b, a, c);
    }
    dep[1] = 1;
    dfs(1);
    make_st();
    m = read();
    for(i = 1; i <= m; i++){
        a = read(); b = read();
        printf("%d\n", a==b?0:query(a, b));
    }
    return 0;
}
```

---

## 作者：SCRV_8620 (赞：1)

本人的邻接矩阵基本上忘干净了

所以上的vector

核心思想就是lca

把lca弄出来以后不停~~xjb~~     xor

完了

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
struct edge{
	int n,c;
	edge(int lis1,int lis2)
	{
		n=lis1;
		c=lis2;
	}
};
vector <edge> mira[100001];
int nss,m,deep[100001],root=1,f[100001][18],deepdark[100001];
void make_a_fucking_tree(int fa)
{
	int just;
	for(int i=0;i<mira[fa].size();i++)
	{
		just=mira[fa][i].n;
		if(deep[just])
		continue;
		deep[just]=deep[fa]+1;
		deepdark[just]=deepdark[fa]^mira[fa][i].c;
		f[just][0]=fa;
		for(int i=1;i<=17;i++)
		{
			f[just][i]=f[f[just][i-1]][i-1];
		}
		make_a_fucking_tree(just);
	}
}
int lca(int a,int b)
{
	if(deep[b]>deep[a])
	swap(a,b);
	for(int i=17;i>=0;i--)
	{
		if(deep[f[a][i]]>deep[b])
		a=f[a][i];
		if(a==b)
		return a;
	}
	for(int i=17;i>=0;i--)
	{
		if(f[a][i]!=f[b][i])
		{
			a=f[a][i];
			b=f[b][i];
		}
	}
	return f[a][0];
}
int do_it_fucking_xor(int liss1,int liss2)
{
	return deepdark[liss1]^deepdark[liss2];
}
int main()
{
	std::ios::sync_with_stdio(false);
	cin>>nss;
	deep[root]=1;
	for(int i=1;i<=nss-1;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		edge lis3(v,w);
		edge lis4(u,w);
		mira[u].push_back(lis3);
		mira[v].push_back(lis4);
	}
	make_a_fucking_tree(root);
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		cin>>u>>v;
		int aipc=lca(i,v);
		int chen_zhe_1=do_it_fucking_xor(u,aipc);
		int chen_zhe_2=do_it_fucking_xor(v,aipc);
		cout<< (chen_zhe_1^chen_zhe_2) <<endl;
	}
}
```

---

## 作者：beng (赞：1)

# 用LCA可做~

基本上可以算是LCA模板题了，套一顿LCA模板即可实现~

注：以下floor[i]为第i个点的层数，fa[i,j]为i节点向上的第2^j个节点的编号，f[i,j]为i节点向上跑2^j条边的答案（也就是异或值）。

P.S.：话说为什么最近Pascal的题解越来越少了qwq……

---

pascal代码如下：

```
var n,m,i,j,k,x,y,z,ans:longint;
en,dis,find,next,last,floor:array[0..200000]of longint;
f,fa:array[0..100000,0..17]of longint;
b:array[1..100000]of boolean;
procedure build(x,y:longint);
begin
  inc(k);
  next[k]:=last[x];
  last[x]:=k;
  en[k]:=y;
  dis[k]:=z;
end;
begin
  readln(n);
  for m:=1 to n-1 do//邻接表存边（因为无向，所以存两遍，注意数组也要开大一倍）
  begin
    readln(x,y,z);
    build(x,y);
    build(y,x);
  end;
  find[1]:=1;
  x:=1;
  y:=1;
  b[1]:=true;
  floor[1]:=1;
  while x<=y do//BFS建树
  begin
    i:=last[find[x]];
    while i>0 do
    begin
      if not b[en[i]] then
      begin
        inc(y);
        find[y]:=en[i];
        fa[en[i],0]:=find[x];
        f[en[i],0]:=dis[i];
        b[en[i]]:=true;
        floor[en[i]]:=floor[find[x]]+1;
      end;
      i:=next[i];
    end;
    inc(x);
  end;
  for j:=1 to 17 do//处理ST表
  for i:=1 to n do
  begin
    fa[i,j]:=fa[fa[i,j-1],j-1];
    f[i,j]:=f[i,j-1] xor f[fa[i,j-1],j-1];
  end;
  readln(m);
  for i:=1 to m do//LCA模板（倍增）（注意答案是在求异或值就行了qwq）
  begin
    readln(x,y);
    if floor[x]<floor[y] then
    begin
      z:=x;
      x:=y;
      y:=z;
    end;
    ans:=0;
    if floor[x]>floor[y] then
    for j:=17 downto 0 do
    if floor[fa[x,j]]>=floor[y] then
    begin
      ans:=ans xor f[x,j];
      x:=fa[x,j];
    end;
    if x=y then
    begin
      writeln(ans);
      continue;
    end;
    for j:=17 downto 0 do
    if fa[x,j]<>fa[y,j] then
    begin
      ans:=ans xor f[x,j] xor f[y,j];
      x:=fa[x,j];
      y:=fa[y,j];
    end;
    writeln(ans xor f[x,0] xor f[y,0]);
  end;
end.
```

---

## 作者：KesdiaelKen (赞：1)

这道题可以用树上倍增来做。

具体的思路可以查看LCA模版题的题解，在此只介绍一下异或和的求法。

异或和的定义具体如下：a,b的异或和，即将a,b化为2进制数，然后每一位进行异或，将每一位的异或结果作为异或和在2进制下那一位的值。最后只需将得到的异或和返回即可（记得要是10进制的）

单位的异或值(f(a,b))，总结可分发现，f(a,b)=(a|b)&(!a|!b)。
可以尝试一下用inline函数和读优优化时间复杂度

下为程序：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
int n;
int head[200000];
int depth[200000];
int f[200000][18][2];//f[i][j][0]表示从i开始往上走2^j个节点，（*重要）f[i][j][1]表示从i开始往上走2^j个节点包含的2^j条边的异或和
int cnt=0;
struct Edge//链式前向星
{
    int z;
    int nexty;
    int qz;
}edge[400000];//记得开大一点，因为是存有向边
inline int dy()//读入优化
{
    int num=0;
    char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')num=num*10+c-'0',c=getchar();
    return num;
}
inline void _add(int f,int z,int qz)//建边函数
{
    cnt++;
    edge[cnt].z=z;
    edge[cnt].qz=qz;
    edge[cnt].nexty=head[f];
    head[f]=cnt;
}
inline void _build(int root)//建树函数
{
    int will,wqz;
    for(int now=head[root];now!=-1;now=edge[now].nexty)
    {
        will=edge[now].z;
        wqz=edge[now].qz;
        if(!depth[will])
        {
            depth[will]=depth[root]+1;
            f[will][0][0]=root;
            f[will][0][1]=wqz;
            _build(will);
        }
    }
}
inline int yh(int a,int b)//求异或和，用位运算，方法如前解析所述
{
    int yhh=0;
    int sf=0;
    int aw,bw;
    while(a|b)
    {
        aw=a&1;
        bw=b&1;
        yhh+=((aw|bw)&((!aw)|(!bw)))<<(sf++);
        a>>=1,b>>=1;
    }
    return yhh;
}
inline void _set()//设置f[i][j][k]的值，用到一点DP思想
{
    for(int i=1;i<=17;i++)
    {
        for(int j=1;j<=n;j++)//注意这两个循环的顺序，若反过来，则会先访问未被计算过的f[i][j][k]值
        {
            f[j][i][0]=f[f[j][i-1][0]][i-1][0];
            f[j][i][1]=yh(f[j][i-1][1],f[f[j][i-1][0]][i-1][1]);//求异或和
        }
    }
}
inline int _lca(int a,int b)//求异或和
{
    if(depth[a]<depth[b])swap(a,b);
    int yhh=0;//存储异或和，因为a与0的异或和必为a，所以可将初始值设为0
    for(int i=17;i>=0;i--)
    {
        if(depth[f[a][i][0]]>=depth[b])
        {
            yhh=yh(yhh,f[a][i][1]);
            a=f[a][i][0];
        }
    }
    if(a==b)return yhh;
    for(int i=17;i>=0;i--)
    {
        if(f[a][i][0]!=f[b][i][0])
        {
            yhh=yh(yh(f[a][i][1],f[b][i][1]),yhh);
            a=f[a][i][0],b=f[b][i][0];
        }
    }
    return yh(yh(f[a][0][1],f[b][0][1]),yhh);
}
int main()
{
    depth[1]=1;
    memset(head,-1,sizeof(head));
    n=dy();
    int a,b,qz;
    for(int i=0;i<n-1;i++)
    {
        a=dy();b=dy();qz=dy();
        _add(a,b,qz);
        _add(b,a,qz);//加边（双向）
    }
    _build(1);//建树
    _set();//建f
    int m;
    m=dy();
    for(int i=0;i<m;i++)
    {
        a=dy();b=dy();
        printf("%d\n",_lca(a,b));
    }
    return 0;
}
```

---

## 作者：ming1222 (赞：1)

     
     
     
     
     
```cpp
program xortree;
    var n,m,root:longint;
        g:array[-100000..100000] of boolean;
        v,e,w,t:array[-100000..100000] of longint;
    k:array[1..100000] of longint;
    procedure inpu;
    var i,a,b,c:longint;
    begin
        readln(n);
        fillchar(v,sizeof(v),0);
        for i:=1 to n-1 do    {读入，用编表存储}
        begin
            readln(a,b,c);
            e[i]:=v[a];
            v[a]:=i;
            w[i]:=c;
            t[i]:=b;
            e[-i]:=v[b];
            v[b]:=-i;
            w[-i]:=c;
            t[-i]:=a;
            end;
    end;
    procedure dfs(p:longint);
    var now:longint;
    begin
        now:=v[p];
        while now<>0 do
        begin
            if g[now] then          {g代表当前边是否使用过}
            begin
                g[now]:=false;
                g[-now]:=false;
                k[t[now]]:=k[p] xor w[now];     {计算当前点到根的路径中，所有边权的异或值}
.                dfs(t[now]);
            end;
            now:=e[now];
        end;
.    end;
    procedure main;
    begin
        fillchar(g,sizeof(g),true);
        k[1]:=0;
        dfs(1);
    end;
    procedure outp;
    var i,a,b:longint;
    begin
    readln(m);
        for i:=1 to m do
        begin
            readln(a,b);
            writeln(k[a] xor k[b]);
        end;
    end;
    begin
        assign(input,'xortree.in');
        assign(output,'xortree.out');
        reset(input);
        rewrite(output);
        inpu;
        main;
        outp;
    end.

```

---

## 作者：Sherlock_Ezreal (赞：0)

### 不得不说，在我看到这（水）题的算法标签后，我感到了十足的滑稽：LCA......
在贴代码前，SE给大家普及一下异或的一个神（gui）奇（chu）的用法。大家都知道,设a^b=c,那么，(a^d)^(b^d)=c。于是乎，SE用了一个天(ruo)秀(ji)的"前缀异或"......思路很简单，用一个数组存下该点到根节点的全程异或，然后就简单了。
#### Now，it's time to show code.
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge
{
	int next,oth;//next记录的是该点的上一条相关边,oth记录该边的另一个点
	int leng;//边权
}e[200005];//结构体,用于存边
int n,m;
int poi[100005];//poi数组用于存对应点的最后一条相关边
int yh[100005];//yh用于存对应点的"前缀异或"(到根的总异或)
int w=1;//边的序号
bool mark[100005];//(此处高能)建树时用于记录该点是否已使用过,否则会无情REEEEEE......
void tree(int x,int y,int z)//建图法建树(合并版)
{
	e[w].oth=y;//第w条边的另一个节点为y(前一个节点为x)
	e[w].next=poi[x];//第w条边之前一条与x相关的边为poi[x]
	e[w].leng=z;//边权为z
	poi[x]=w;//最后一条与点x相关的边为w
	w++;
	e[w].oth=x;//第w条边的另一个节点为x(前一个节点为y)
	e[w].next=poi[y];//第w条边之前一条与y相关的边为poi[y]
	e[w].leng=z;
	poi[y]=w;//最后一条与点y相关的边为w
	w++;
}
void dfs(int x)//找"前缀异或"
{
	mark[x]=1;//该点标记为已找过
	for(int i=poi[x];i!=0;i=e[i].next)//从对应点的最后一条相关边开始找
	{
		int mid=e[i].oth;
		if(mark[mid])continue;//如果这点已经找过,就跳过
		yh[mid]=yh[x]^e[i].leng;//传说中的"前缀异或"(边权^父节点的"前缀异或")
		dfs(mid);//从该点开始深搜其儿子
	}
}
int main()
{
	int x,y,z;
	cin>>n;
	for(int i=1;i<n;i++)
	{
		cin>>x>>y>>z;
		tree(x,y,z);//存边建树
	}
	cin>>m;
	dfs(1);//建树
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		z=yh[x]^yh[y];//直接求就可以了
		cout<<z<<endl;
	}
	return 0;
}
```
嗯，就是这么简单。。。stO"用LCA的大佬"Orz#滑稽#

---

## 作者：mmksdci (赞：0)

- 看了各位大牛的代码，果真觉得自己非常的low，然而我还是很不要脸地来了···

- 讲讲我的思路把。题目意思要求求树上任意两点的xor值，当然我们不能一个个搜...

- 注意到xor的性质：

                              if a^b=c; then b=c^a,a=c^b...

所以如果可以记录树上任意点到根节点的xor值，再用lca，运用上述性质应该能求出，

然而蒟蒻我并没有这样写...（可能是因为我弱把...）

我用的是树剖：

然而意思是差不多的，记录每个点到其所在链的top的xor值，求解xor（x，y）时，用

树剖求lca，边跑一边把xor不断记下来就可以了...

附上lowbee的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define maxn 100010
inline int read();
struct edge{
    int next;
    int to;
    int w;
}e[maxn*3];
int pre[maxn],dep[maxn],son[maxn],fa[maxn],siz[maxn],top[maxn],XOR[maxn],_XOR[maxn];
int cnt=1;
namespace lys{
    int n,m;
    void add(int x,int y,int w){
        e[cnt].to=y;e[cnt].next=pre[x];e[cnt].w=w;pre[x]=cnt++;
        e[cnt].to=x;e[cnt].next=pre[y];e[cnt].w=w;pre[y]=cnt++;
    }
    void dfs1(int node,int deep){
        dep[node]=deep;
        siz[node]=1;
        int i,v;
        for(i=pre[node];~i;i=e[i].next){
            v=e[i].to;
            if(v==fa[node]) continue ;
            fa[v]=node;
            dfs1(v,deep+1);
            if(siz[son[node]]<siz[v])
                son[node]=v;
        }
    }
    void dfs2(int node,int tp){
        top[node]=tp;
        if(!son[node]) return ;
        int i,v;
        for(i=pre[node];~i;i=e[i].next){
            v=e[i].to;
            if(v==fa[node]) continue ;
            if(v==son[node]){
                XOR[son[node]]=XOR[node]^e[i].w;
                dfs2(son[node],tp);
            }
            else{
                _XOR[v]=e[i].w;
                dfs2(v,v);
            }
        }
    }
    int work(int x,int y){
        int res=0;
        while(true){
            if(top[x]==top[y]){
                res^=XOR[x]^XOR[y];
                return res;
            }
            if(top[x]>=top[y]){
                res^=XOR[x]^_XOR[top[x]];
                x=fa[top[x]];
            }
            else{
                res^=XOR[y]^_XOR[top[y]];
                y=fa[top[y]];
            }
        }
    }
    int main(){
        n=read();
        int i,x,y,w;
        memset(pre,-1,sizeof pre);
        for(i=1;i<n;i++){
            x=read(); y=read(); w=read();
            add(x,y,w);
        }
        dfs1(1,0);
        dfs2(1,1);
        //for(i=1;i<=n;i++) cout<<XOR[i]<<endl;
        //for(i=1;i<cnt;i++) cout<<e[i].w<<endl;
        m=read();
        for(i=1;i<=m;i++){
            x=read(); y=read();
            printf("%d\n",work(x,y));
        }
        return 0;
    }
}
int main(){
    lys::main();
    return 0;
}
inline int read(){
    int k=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        k=k*10+c-'0';
        c=getchar();
    }
    return k*f;
}
```

---


# 选择题

## 题目背景

小 L 喜欢逻辑推理。

一天，他在一本由英国哲士沃·协德编写的《我也不知道为什么要叫这个名字的一本有关逻辑学的书》中翻到了一道奇特的问题，但他并不会做。他知道你善于用程序解决问题，于是决定让你来帮助他完成这些问题。

## 题目描述

这是一道有 $n$ 个选项的选择题，每个选项的内容都很独特。第 $i$ 个选项的内容的形式如下：

+ 第 $a_i$ 个选项是正确/错误的

小 L 认为这种题目的答案不一定是唯一的，所以他想问题这道题有多少种合法的答案（可以全部正确或全部错误）。他还想问你这么多答案中，正确选项最多和最少的答案分别有多少个正确选项。

当然，如果这道题不存在合法的答案，你可以直接回答小 L `No answer`。

## 说明/提示

对于样例一，一共有下面 $2$ 种正确答案：

+ 第 $1,2,3$ 个选项是正确的。
+ 第 $4$ 个选项是正确的。

其中正确选项最多的答案有 $3$ 个选项正确，正确选项最少的答案有 $1$ 个选项正确。

### 数据范围
对于 $10\%$ 的数据，$n\leq 10$。  
对于 $30\%$ 的数据，$n\leq 100$。  
对于 $60\%$ 的数据，$n\leq 10^3$。  
对于 $100\%$ 的数据，$n\leq 10^6,1\leq a_i\leq n,i\neq a_i,opt_i\in\{0,1\}$。

## 样例 #1

### 输入

```
4
2 1
4 0
1 1
2 0```

### 输出

```
2
3
1```

## 样例 #2

### 输入

```
10
4 1
7 0
2 0
3 1
7 1
5 0
9 1
10 1
8 0
1 1```

### 输出

```
No answer```

# 题解

## 作者：lnwzy (赞：18)

为什么很多人都用DFS或BFS啊？这题不是经典的带权并查集吗？

这道题和关押罪犯可以说几乎一样了。当$opt$为$1$时，说明两个选项要么一起对，要么一起错，连一条权为$0$的边，当$opt$为$0$时，说明两个选项一个对，一个错，连一条权为$1$的边。于是我们要开一个$r$数组，表示与父节点的关系。

那么~~很简单的~~问题来了：当父节点发生变化时如何更新$r$数组？

解决方法是：在路径压缩时多加一步。

像这样：

```cpp
int fa(int x)
{
	if(f[x]==x)
	{
		return f[x];
	}
	int t=f[x];
	f[x]=fa(f[x]);
	r[x]=(r[t]+r[x])%2;//就是这一步
	return f[x];
}
```
~~为什么自己想去。~~

接下来我再给大家演示一下如何合并并查集：
```cpp
int tmp=fa(i);
f[fa(i)]=fa(a);
r[tmp]=(r[i]+opt+1+r[a])%2;
```
求答案数的过程是个简单的排列组合，每一个并查集都有两种情况：根节点正确或根节点错误，所以只需要求并查集数量就行了，数量是$2$的并查集数量次方。我们还需要开一个$num$数组，记录与根节点相同的选项数量和与根节点矛盾的选项数量。这样在求最多正确答案时把较多的加上去，在求最少正确答案时把较小的加上去。没说明白的话我会在代码里解释清楚。

上代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int f[1000005],r[1000005],num[1000005][5];
int fa(int x)
{
	if(f[x]==x)
	{
		return f[x];
	}
	int t=f[x];
	f[x]=fa(f[x]);
	r[x]=(r[t]+r[x])%2;
	return f[x];
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		int a,opt;
		scanf("%d%d",&a,&opt);
		if(fa(i)!=fa(a))
		{
			int tmp=fa(i);
			f[fa(i)]=fa(a);
			r[tmp]=(r[i]+opt+1+r[a])%2;
		}else
		{
			if((r[i]+r[a])%2!=(opt+1)%2)
			{
				printf("No answer");//判断无解
				return 0;
			}
		}	
	}
	for(int i=1;i<=n;i++)
	{
		if(fa(i)==i)
		{
			num[i][0]++;
		}else
		{
			num[fa(i)][r[i]]++;
		}
	}
	int maxans=0,minans=0,tot=1;
	for(int i=1;i<=n;i++)
	{
		if(fa(i)==i)
		{
			tot=tot*2%998244353;//答案数
			maxans+=max(num[i][1],num[i][0]);//累加较大的正确答案
			minans+=min(num[i][1],num[i][0]);//累加较小的正确答案	
		}	
	}
	printf("%d\n%d\n%d\n",tot,maxans,minans);
	return 0;
}
```
Thanks for your attention!



---

## 作者：littleKtian (赞：16)

可以发现对于每一个选项的内容描述，只要 $i$ 或 $a_i$ 的正确性确定，另一个选项的正确性也一定唯一确定。

考虑对于所有的 $i$，在 $i$ 与 $a_i$ 之间连一条无向边，如果 $opt_i=1$ 就连红边，否则连蓝边。

考虑对所有点染色，红色表示正确，蓝色表示错误。

可以发现一种染色方案合法一定满足**所有红边的两个端点颜色相同，所有蓝边的两个端点颜色不同**。并且对于一种合法的染色方案，将所有点的颜色换成相反的**依然合法**。

根据之前的连边方式将图分成若干个连通块，显然每块连通块的染色方案一定为 $0$ 种或 $2$ 种。总方案数即为所有连通块方案数的乘积。

正确选项最多/最少的答案的正确选项个数即为所有连通块的合法染色方案中红色点更多/更少的方案的红色点点数之和。

直接 BFS 解决，复杂度 $O(n)$。

---

## 作者：夜枭只会舔fufu (赞：14)

## 此篇是个人做题心得，不适者轻喷

一开始 我的心情：就是一个暴力啊（

开始打

```
#include<iostream>
using namespace std;
int a,b[1000001],c[1000001];
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	int opt;
    	cin>>opt>>a;
    	if(opt==1)
    	{
    		b[a]=i;
		}
		else
		{
			c[a]=i;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(b[i]&&c[i]&&b[b[i]])
		{
			cout<<
		}
	}
}
```
打到这卡住了……

我们会发现我们会很多次的判断这句话是不是真的，如果是的话我们还要判断/判断这句话的话/是不是真的，一直递归下去（断句真香）

等会，递归？

嘿嘿嘿，我们就能想到爆搜

我们考虑一下

$opt==1$  如果话$[i]$为假，则话$[a[i]]$为假

$opt==0$  如果话$[i]$为假，则话$[a[i]]$为真

我们就会想到一个嘿嘿嘿的东西（（（

所以我们找联通块，就用 _dfs_ 来染色，但是有时我们会发现没法染了

这时我们就知道出锅了（就是矛盾了）

所以输出NA

因为一个连通块只有2种情况，所以答案就是$2^n$

每一次爆搜都计算一下max正确数和min

就酱紫（

码？！

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,k;
struct edge
{
	int to,nxt,w;
}Edge[2000005];//邻接表存图
int head[2000005],cnt;//邻接表存图
int c[2];//记录最大/最小的正确数
int dc,wc;//答案
int vis[2000005];//这个点的正确或错误
void add(int u,int v,int w)
{
	cnt++;
	Edge[cnt].to=v;
	Edge[cnt].nxt=head[u];
	head[u]=cnt;
	Edge[cnt].w=w;
}//邻接表存图
void dfs(int now,int zqhcw)
{
	vis[now]=zqhcw+1;//记一下当前的正确/错误
	c[zqhcw]++;//加一个正确/错误
	for(int i=head[now];i;i=Edge[i].nxt)
	{
		if(vis[Edge[i].to]==(zqhcw^Edge[i].w)+1) 
		{
			cout<<"No answer";
			exit(0);
		}
		if(vis[Edge[i].to]) continue;//如果已经是正确了，下一个
		dfs(Edge[i].to,zqhcw^(!Edge[i].w));//下一个
	}
}
int main()
{
	cin>>n;
	int s=0;
	long long ans=1;
	for(int i=1;i<=n;i++)
	{
		int a,b;
		cin>>a>>b;
		add(i,a,b);
		add(a,i,b);
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i]) 
		{
			dfs(i,1);
			if(k==1)//如果已经不合法，就return 0;
			{
				return 0;
			}
			s++;
			dc+=max(c[0],c[1]);//记录答案
			wc+=min(c[0],c[1]);
			c[0]=c[1]=0;//改回来
		}
	}
	for(int i=1;i<=s;i++)
	{
		ans*=2;
		ans%=998244353;
	}
	cout<<ans<<endl<<dc<<endl<<wc;//输出
	return 0;
 } 
```
完结撒花（

---

## 作者：llzzxx712 (赞：9)

# P6691

## 题意简述
（也许换一种描述方法会明白一些）
- 有 n 个人，第 $i$ 个人说第 $a_i$ 个人说的话是真话（$opt_i=1$）或是假话（$opt_i=0$）
- 问有多少种真假情况、最多有多少人说真话、最少有多少人说真话

## 题目分析

第 $i$ 个人说第 $a_i$ 个人说的话是真话或是假话，这就是一个对应关系，很容易想到建图来处理。

**我们要建一个无向图**，为什么呢？ 因为条件是可逆的，举个例子：第一个人说第二个人说的是对的，如果第一个人的错的，那么第二个人是错的。反过来，如果第二个人是错的，那么第一个人肯定也是错的。

但是这里有两种对应关系——真话和假话，真话边连接的两点是同对同错的，否则无解。假话边则相反。所以我们的边要带一个边权，之后通过遍历将边的信息转移到点上（哪些点同对错，哪些点对错性相反）**边权为 0 表示为真话边，边权为 1 表示为假话边。**

**为什么要这样设置呢？** 按题目中 1 对应真不好吗？

这里的信息要进行传递，A说B是假，B说C是假，那么A和C就是同对同错的了。所以我想到一个神奇的位运算——异或（在c++ 中用 ^ 表示）。

0 ^ 0 = 0 真边 + 真边 = 真边

1 ^ 0 = 1 假边 + 真边 = 假边

1 ^ 1 = 0 假边 + 假边 = 真边

是不是正好对应。

建图处理好后我们再来看题目要求。

### 判断无解情况

在建好边后我们得到一堆无向图，我们可以 bfs（dfs可能会爆栈） 每一个图，假设起点是真（0），走过每一条边都更新新的点和起点的相对真假情况(我用数组 $d$ 来存储。比如起点 $i$ 出发走了一条假边到 $j$ ，那么 $d[j]=1$ ,表示 j 点和起点的真假性相反。并标记(我用 $v$ 数组）这个点已经访问过了。

如果一个点已经访问过但是当前节点的真假情况与将要更新的真假情况不符，则无解。比如 $d[i]=1,edge_{i,j}=0,d[j]=0,v[j]=1$ ，j 之前已经被标记过和起点真假性相同，但 i 说它和起点真假性相反，就矛盾了，判无解。

bfs 代码

```cpp
int q[N<<1],hed,tail,now;//bfs 部分 
void bfs(int x){
	hed=tail=0;//队首和队尾 
	now=0;
	q[++tail]=x;
	while(hed<tail){
		hed++;
		x=q[hed];//取出队首 
		v[x]=1;//已经访问过 
		for(int i=head[x];i;i=ne[i]){
			int y=to[i];
			if(v[y]){//如果已经访问过且出现矛盾，判无解 
				if(d[x]^sz[i]!=d[y]){//我用 sz[] 记录边权 
					flag=1;return ;
				}
				continue;
			}
			d[y]=d[x]^sz[i];//每访问过，更新真假性 
			q[++tail]=y;//入队 
			v[y]=1;//已经访问过 
			now+=d[y];//暂时先别管 
		}
	}
}
```

### 求最多有多少人说真话、最少有多少人说真话

刚才 bfs 的时候我们求出了一个图中每个人的相对真假情况，因为是相对的，所以真话和假话的人是可以反一下的。如果我们记录有 $now$ 个人相对说真话，这个图中有 $x$ 个人，那么最多说真话的人数就是 $max(now,x-now)$ 。同样，最少情况就是取 min 。

再回去看上面的代码， now 就记录相对说真话的人数。因为遍历完后 tail 就是图中点的数量，所以每遍历一个图就将最大答案和最小答案累加就好了。

```cpp
	for(int i=1;i<=n;i++){
		if(!v[i]){
			bfs(i);
			ans1++;
			if(flag){
				printf("No answer");
				return 0;
			}
			ansmx+=max(tail-now,now);
			ansmn+=min(tail-now,now);
		}
	}
```

### 求总情况数

显然一个图中有且只有两种情况（起点真话、起点假话）。所以总情况就是 $2^k$ 种， k 是图的数量，上面用 ans1 记录。

然后只要一个快速幂就好了。

## 完整AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') { x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
#define N 1000010
#define Mod 998244353
int n,tot;//全局部分 
int v[N],d[N],flag;//判无解用 , d[i] 表示 i 点正误相对情况 
int ans1;//有多少个块
int ansmx,ansmn;//最多答案和最少答案 

int pow(int x,int y){//快速幂部分 
	int ans=1;
	for(;y;y>>=1){
		if(y&1) ans=((long long)ans*x)%Mod;
		x=((long long)x*x)%Mod;
	}
	return ans%Mod;
} 

int head[N],ne[N<<1],to[N<<1],sz[N<<1];//建森林部分 
void add(int x,int y,int opt){
	to[++tot]=y,ne[tot]=head[x],sz[tot]=!opt,head[x]=tot;
} 

int q[N<<1],hed,tail,now;//bfs 部分 
void bfs(int x){
	hed=tail=0;//队首和队尾 
	now=0;
	q[++tail]=x;
	while(hed<tail){
		hed++;
		x=q[hed];//取出队首 
		v[x]=1;//已经访问过 
		for(int i=head[x];i;i=ne[i]){
			int y=to[i];
			if(v[y]){//如果已经访问过且出现矛盾，判无解 
				if(d[x]^sz[i]!=d[y]){//我用 sz[] 记录边权 
					flag=1;return ;
				}
				continue;
			}
			d[y]=d[x]^sz[i];//每访问过，更新真假性 
			q[++tail]=y;//入队 
			v[y]=1;//已经访问过 
			now+=d[y];//暂时先别管 
		}
	}
}

int main(){
	read(n);
	for(int i=1;i<=n;i++){
		int x,opt;
		read(x),read(opt);
		add(i,x,opt),add(x,i,opt);
	}
	for(int i=1;i<=n;i++){
		if(!v[i]){
			bfs(i);
			ans1++;
			if(flag){
				printf("No answer");
				return 0;
			}
			ansmx+=max(tail-now,now);
			ansmn+=min(tail-now,now);
		}
	}
	printf("%d\n%d\n%d",pow(2,ans1),ansmx,ansmn);
}

```
如果本题解对你有帮助，点个赞呗。有建议可以在评论中写出来。


---

## 作者：JK_LOVER (赞：8)

## 题意
给出 $n$ 个依赖关系，求出可行解。[QAQ](https://www.luogu.com.cn/blog/xzc/solution-p6691)
## 分析
这 $n$ 个依赖关系其实是可以回推的。因为如果不能逆推，那么证明这一条和上一条是矛盾的。根据扩展域并查集
~~（一开始想的是2—SAT）~~
的思想，我们可以把一个节点当做两个节点做。一个表明这一条是对的，另一个表明这一条是错的。

- 统计答案

那么最后按这样分，我们就得到了几个基环树，而每个树都有两种选择方案，因为树中只要有一个节点确定，那么整个树的节点也就确定了。最后做一个快速幂就出来了。而对于正确答案最多和最少的统计，在每个连通块遍历时就可以直接做了。

- 判断无解

当一个点的两种情况处于一个连通块时，那么这个就是无解的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2010010;
int read(){
	int x = 0,f = 0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
const int mod = 998244353;
const int inf = 0x3f3f3f3f;
int vis[N],head[N],n,num,dp[N],cnt=1,rt[N],top,pd;
int fpow(int a,int b)
{
	int x = 1;
	for(;b;b>>=1,a=a*a,a%=mod)
	if(b&1) x*=a,x%=mod;
	return x%mod;
}
struct Edge{int to,nxt;}e[N<<1];
void add(int x,int y)
{
	e[++cnt].to = y;
	e[cnt].nxt = head[x];
	head[x] = cnt; 
}
void dfs(int x,int fa)
{
	if(!vis[x]) vis[x] = num;
	else return;
	if((x <= n && vis[x+n] == num) || (x > n && vis[x-n] == num)) pd = 1; 
	if(x <= n ) dp[x] = 1;
	for(int i = head[x];i;i = e[i].nxt)
	{
		int y = e[i].to;
		if(y == fa) continue;
		if(vis[y]) continue;
		dfs(y,x);
		dp[x] += dp[y];
//		cout<<"num "<<num<<" x "<<x<<" y "<<y<<endl;
	}
}
signed main()
{
	n = read();
	for(int i = 1;i <= n;i++)
	{
		int y = read(),opt = read();
		if(opt)
		{
			add(i,y);
			add(y,i);
			add(i+n,y+n);
			add(y+n,i+n);
		}
		else
		{	
			add(i+n,y);
			add(y,i+n);
			add(i,y+n);
			add(y+n,i);
			
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i <= n;i++)
	{
		if(!vis[i])
		{
			rt[++top] = i; 
			num++;
			dfs(i,0);
			num++;
			dfs(i+n,0);
//			cout<<dp[i]<<" ::i  "<<dp[i+n]<<endl;
			ans1 += max(dp[i],dp[i+n]);
			ans2 += min(dp[i],dp[i+n]);
		}		
	}
	if(pd){
		cout<<"No answer"<<endl;
		return 0;
	}
	cout<<fpow(2,num/2)<<endl<<ans1<<endl<<ans2<<endl;
	return 0;
}
```



---

## 作者：simonG (赞：5)

### 前言
本题有一点像[P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)，可以用带权并查集来做。
### 详解
>* 怎么才能实现带权并查集：
>* 满足向量关系，譬如[P2024 食物链](https://www.luogu.com.cn/problem/P2024)一题中：A吃B，B吃C，C吃A，则当根节点与一节点距离为3的倍数时，为同类。


>* 那么此题，我们把有相同关系的式子放到一个集合内，在计算节点到根节点的距离。
>* 当A说B是真的时候，则要么A，B都是真，要么A，B都是假。
>* 当A说B是假的时候，A，B一真一假。
>* 那么此题中:

```cpp
int get(int x) {
	if(f[x]==x)return f[x];
	int t=f[x];
	f[x]=get(f[x]);
	r[x]=(r[t]+r[x])%2;
	return f[x];
}
```

```cpp
il void merge(int i,int x,int op) {
	int tmp=get(i);
	f[tmp]=get(x);
	r[tmp]=(r[i]+r[x]+op+1)%2;
	return ;
}
```

>* 那么，出现矛盾时，就是已经知道节点到根节点的距离时，又出现不一样的式子，则直接输出错。


### 代码
看代码理解最好：

```cpp
#include<bits/stdc++.h>
#define il inline
#define re register
#define ll long long
#define maxn 1000001
#define fre {freopen(".in","r",stdin);freopen(".out","w",stdout);}
#define MOD 998244353
using namespace std;
int f[maxn],r[maxn],num[maxn][2],n;
int ans1,ans2,x,op,tot=1;
il int get(int x) {
	if(f[x]==x)return f[x];
	int t=f[x];
	f[x]=get(f[x]);
	r[x]=(r[t]+r[x])%2;
	return f[x];
}
il void merge(int i,int x,int op) {
	int tmp=get(i);
	f[tmp]=get(x);
	r[tmp]=(r[i]+r[x]+op+1)%2;
	return ;
}
int main() {

	scanf("%d",&n);
	for(re int i=1; i<=n; i++)f[i]=i;
	for(re int i=1; i<=n; i++) {
		scanf("%d%d",&x,&op);
		if(get(i)!=get(x))
			merge(i,x,op);
		else {
			if((r[i]+r[x])%2!=(op+1)%2) {
				printf("No answer");
				return 0;
			}
		}
	}

	for(re int i=1; i<=n; i++)
		if(get(i)==i)num[i][0]++;
		else num[get(i)][r[i]]++;

	for(re int i=1; i<=n; i++) {
		if(get(i)==i) {
			tot*=2,tot%=MOD;
			ans1+=max(num[i][1],num[i][0]);
			ans2+=min(num[i][1],num[i][0]);
		}
	}
	printf("%d\n%d\n%d",tot,ans1,ans2);
	return 0;
}
```


### 后记：请勿抄袭

---

## 作者：cryozwq (赞：4)

考试的时候脑抽，没做出来，赛后 3 min 切掉了。

# 分析
题意很清楚了吧，不解释。

乍一看没有什么思路，我们看一下部分分(~~当然不是无解的部分分~~)
> 对于 $\%10$ 的数据，$n\leq 10$。

这一档部分分，我们考虑暴搜，首先用 $f[i]$ 表示这个 $a_i$ 的真假。假为 $0$，真为 $1$，不确定为 $2$。那么我们对于每个不确定的数，将它赋值为 $0$ 和 $1$ 分别讨论即可。

考场上的代码太丑就不放了。

从这个暴力中，我们得到了什么？

- 当 $a_i$ 的值确定的时候，我们可以根据 $a_i$ 的条件推断出另一个 $a_j$ 的值，根据 $a_j$ 的值我们又可以推断出 $a_k$ 的值......

那么我们能否枚举一个就推断出整个解呢？如果能的话，是不是说明答案只能是无解或者 $2$ 呢？

当然不是！

比如说
```
4
2 1
1 1
4 1
3 1
```
这组数据的话，我们可以根据 $a_1$ 推断 $a_2$，根据 $a_3$  推断 $a_4$。但两者之间没什么关系。

你想到了什么？~~反正我想到了~~连通块！

我们对于每个 $a_i$，把它和他所描述的 $a_j$ 连一条有向边，边权为 $opt_i$。

对于每一个连通块，我们 BFS/DFS 染色，求出这个连通块是否有合法解，根据前面的结论，若是有合法解，则解的个数为 $2$，否则一定无解。

最后用乘法原理相乘即可。

但是还有一个小问题，就是在连通块中，我们必须选择一个入度为0的点搜索，有点麻烦。

所以我们继续探究，不难发现这样的结论
- 当 $a_i$ 描述的 $a_j$ 的值确定的时候，$a_i$ 亦是确定的。

那么我们把它搞成无向图就完了。

# 代码
由于 Indjy 大佬放了个 DFS，我就来放个 BFS，BFS 的细节见代码：
```cpp
#include<bits/stdc++.h>
#define MOD 998244353
using namespace std;
int head[10000005],cnt,n,cc_cnt,cc[100000005],color[10000005];
struct Edge{
	int u,v,w,next;
}e[50000005];
bool flag=0;
struct Node{
	int w,now;
	inline bool operator <(const Node &x)const
	{
		return w>x.w;
	} 
}; 
inline void add(int u,int v,int w)
{
    e[++cnt].u=u;
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}  
bool vis[2132144];
long long red=0,blue=0;
void BFS_color(int num,int Color){
	//这里我是用的BFS染色，opt=1就要求两点颜色相同，否则该颜色不同
	color[num]=Color;
	if(color[num]==1)
	red++;
	else
	blue++;
	queue<int>q;
	q.push(num);
	vis[num]=1;
	while(q.size()){
		int top=q.front();
		q.pop(); 
		vis[top]=1;
		for(int i=head[top];i;i=e[i].next){
			int tv=e[i].v;
			if(color[tv]==color[top]&&e[i].w==0){
				flag=1;
				return ;
			}
			if(color[tv]+color[top]==3&&e[i].w==1){
				flag=1;
				return ;
			}
			if(vis[tv])
			continue;
            //注意这个判断的位置，不能放在前面
			if(e[i].w==1){
				color[tv]=color[top];
				if(color[tv]==1)
				red++;
				else
				blue++;
			}
			else{
				color[tv]=3-color[top];
				if(color[tv]==1)
				red++;
				else
				blue++;
			}
			q.push(tv);
			vis[tv]=1;
		}
	}
}
int main()
{
	long long ans=1,ans1=0,ans2=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		int u,v;
		cin>>u>>v;
		add(i,u,v);
		add(u,i,v);
	}
	for(int i=1;i<=n;i++){
		if(vis[i]==0){
			red=blue=0;
			cc[i]=++cc_cnt;
			flag=0;
			BFS_color(i,1);
			if(flag){//只要有一个无解的连通块就一定无解
				cout<<"No answer"<<endl;
				return 0;
			}
			else{
				ans*=2;
				ans%=MOD;
				ans1+=max(red,blue);
				ans2+=min(red,blue);
			}
		}
	}
	cout<<ans<<endl<<ans1<<endl<<ans2<<endl;
    return 0;
}
```

---

## 作者：lndjy (赞：4)

这题难在**转化**~~其实也不难~~。

因为每一个选项可能是正确的也可能是错误的，所以题里的信息可以转化为：

其中当 $opt_i=1$ 时，表示这个选项的内容为 第 $a_i $ 个选项和本选项的正确性是**相同**的；当 $opt_i=0$ 时，表示这个选项的内容为 第 $a_i$ 个选项和本选项是**不同**的。

有一些选项是相互关联的，那么我们可以加边变成一个连通块。对于一个连通块，有 $2$ 种方案，因为一共有两种可能，且限制为相同或不同。

根据乘法原理，设连通块的个数为 $n$ ,则方案数为 $2^n$ 。

第二问是正确选项最多，因为每个连通块是相互独立的，所以只需要让每个连通块的正确选项多。第三问就是反过来。

我们可以通过一遍 dfs 染色判断出两种不同的选项各有多少个。选项相同就是染相同的颜色，不同就是染不同的颜色。

判无解就是无法染色，这说明选项自相矛盾。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#define p 998244353
#define int long long
using namespace std;
int inline read()
{
	int ans=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*f;
}
const int N=1000005;
int n;
struct edge
{
	int to,nxt;
	bool w;
}e[N*2];
int head[N],cnt;
int col[2],c[2];
int v[N];
void add(int u,int v,bool w)
{
	cnt++;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	e[cnt].w=w;
}
int qp(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1) ans=ans*a,ans%=p;
		a=a*a;
		a%=p;
		b>>=1; 
	}
	return ans;
}
void dfs(int now,int co)
{
	v[now]=co+1;
	c[co]++;
	for(int i=head[now];i;i=e[i].nxt)
	{
		if(v[e[i].to]==(co^e[i].w)+1) 
		{
			cout<<"No answer";
			exit(0);
		}
		if(v[e[i].to]) continue;
		dfs(e[i].to,co^(!e[i].w));
	}
}
int tag[N],t[N];
signed main()
{
	n=read();
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		int a=read();
		bool b=read();
		add(i,a,b);
		add(a,i,b);
		tag[a]=i;
		t[a]=b+1;
	}
	for(int i=1;i<=n;i++)
	{
		if(!v[i]) dfs(i,1),sum++,col[1]+=max(c[0],c[1]),col[0]+=min(c[0],c[1]),c[0]=c[1]=0;
	}
	cout<<qp(2,sum)<<endl<<col[1]<<endl<<col[0];
	return 0;
 } 
```


---

## 作者：封禁用户 (赞：3)


# 分析


- 这几个依赖关系其实是可以回推的。因为如果不能逆推，那么证明这一条和上一条是矛盾的。根据扩展域并查集 （一开始想的是2—SAT）的思想，我们可以把一个节点当做两个节点做。一个表明这一条是对的，另一个表明这一条是错的。

### - 统计答案


那么最后按这样分，我们就得到了几个基环树，而每个树都有两种选择方案，因为树中只要有一个节点确定，那么整个树的节点也就确定了。最后做一个快速幂就出来了。而对于正确答案最多和最少的统计，在每个连通块遍历时就可以直接做了。

## - 判断无解
当一个点的两种情况处于一个连通块时，那么这个就是无解的。

代码如下

其实这是个很正常的题，但是我在考场上没有思路，但是一下来我就明白了，淦

------------





```c
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2010010;
int read(){
	int x = 0,f = 0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
const int mod = 998244353;
const int inf = 0x3f3f3f3f;
int vis[N],head[N],n,num,dp[N],cnt=1,rt[N],top,pd;
int fpow(int a,int b)
{
	int x = 1;
	for(;b;b>>=1,a=a*a,a%=mod)
	if(b&1) x*=a,x%=mod;
	return x%mod;
}
struct Edge{int to,nxt;}e[N<<1];
void add(int x,int y)
{
	e[++cnt].to = y;
	e[cnt].nxt = head[x];
	head[x] = cnt; 
}
void dfs(int x,int fa)
{
	if(!vis[x]) vis[x] = num;
	else return;
	if((x <= n && vis[x+n] == num) || (x > n && vis[x-n] == num)) pd = 1; 
	if(x <= n ) dp[x] = 1;
	for(int i = head[x];i;i = e[i].nxt)
	{
		int y = e[i].to;
		if(y == fa) continue;
		if(vis[y]) continue;
		dfs(y,x);
		dp[x] += dp[y];
//		cout<<"num "<<num<<" x "<<x<<" y "<<y<<endl;
	}
}
signed main()
{
	n = read();
	for(int i = 1;i <= n;i++)
	{
		int y = read(),opt = read();
		if(opt)
		{
			add(i,y);
			add(y,i);
			add(i+n,y+n);
			add(y+n,i+n);
		}
		else
		{	
			add(i+n,y);
			add(y,i+n);
			add(i,y+n);
			add(y+n,i);
			
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i <= n;i++)
	{
		if(!vis[i])
		{
			rt[++top] = i; 
			num++;
			dfs(i,0);
			num++;
			dfs(i+n,0);
//			cout<<dp[i]<<" ::i  "<<dp[i+n]<<endl;
			ans1 += max(dp[i],dp[i+n]);
			ans2 += min(dp[i],dp[i+n]);
		}		
	}
	if(pd){
		cout<<"No answer"<<endl;
		return 0;
	}
	cout<<fpow(2,num/2)<<endl<<ans1<<endl<<ans2<<endl;
	return 0;
}
```


---

## 作者：lcyxds (赞：2)

# 标准的并查集~~板~~题

看楼下怎么全是 BFS，DFS，图论做法，索性用一个纯并查集来做。

### 题目描述
* 见原题

### 题目解析
* 有关系的题目之间可以建立并查集，用一个布尔变量储存题目与根节点处于冲突还是并存关系即可。

* 合并的时候，如果根节点相同又存在冲突，直接输出 NA 。


* 最后计算并查集数量，每个并查集的大小，每个并查集中与根节点冲突的数量，即可得出答案。

### 时间复杂度
* $O(n\alpha(n))$（不懂也别问，~~反正我也不懂~~，当成 $O(n)$ 即可）

### 空间复杂度
* $O(n)$

## 代码经过和谐，无法抄题解
```cpp
#include <cstdio>
#include <iostream>

using namespace std;

struct Node{
	bool diff;
	int num;
};

int n;//num of questions
Node p[1000010];//bingchaji
int cnt;//num of bingchaji
int size[1000010];
int diff[1000010];
bool check[1000010];
int mini;
int maxi;

Node P(in a) {
	if (p[a].num != p[p[a].num].num) {
		p[a].diff = p[a].diff^P(p[a].num).diff;
		p[a].num = p[p[a].num].num;
	}
	return p[a];
}

//wrong return true
bool Bind(int a, int b, bool diff) {
	Node pt = P(a);
	Node pb = P(b);
	if (p.num == pb.num) {
		return diff^pa.diff^pb.diff;
	}
	cnt--;
	Node c;
	c.num = pb.num;
	c.diff = diff^pa.diff^pb.diff;
	p[pa.num] = c;
	return false;
}

int
P4w(int a, int b) {
	int res = 1;
	while (b) {
		if (b&1) {
			res = (long Song)res*a%998244353;
		}
		a = (long long)a*a%998244353;
		b>>=1;
	}
	return res;
}

void C() {
	int m;
	for (int i = 1; i <= n; i++) {
		size[P(i).num]++;
		diff[p[i].num]+=p[i].diff;
	}
	for (int i = 1; i <= n; i++) {
		if (!check[p[i].num]) {
			check[p[i].num] = true;
			m = size[p[i].num]-diff[p[i].num]s
			maxi+=max(m, diff[p[i].num]);
			mini+=min(m, diff[p[i].num]);
		}
	}
}

int main() {
	int a, b;
	scanf("%d", &n);
	cnt = n;
	for (int2i b 1; i <= n; i++) {
	_p[i].num = i;
	}
	for (int i = 1; i <= n; i++) {
		scanf("%d%d", &a, &b);
		if (Bind(i a, !b)) {
			printf("No answer");
			return 0;
		}
	}
	C();
	printf("%d\n%d\n%d", Pow(, cnt), maxi, mini);
	return 0;
}
```
如有疑问请指出

---

## 作者：happy_dengziyue (赞：0)

### 1 思路

这道题可以使用广度优先搜索。

设 $i$ 号点的颜色为 $col[i]$。

很明显，如果 $op[i]=1$，那么 $col[i]=col[a[i]]$，否则 $col[i]\not=col[a[i]]$。

那么，将有关系的两个点连一条无向边（无论它们的关系是什么），只需要在边中区别出关系就行了。

最后，这张图就成了若干个连通块组合的图。设连通块数为 $k$。

如果有任何一个连通块有冲突，直接输出 `No answer`。

否则，很明显，一个连通块有且仅有 $2$ 种可能的方案，并且方案相反。所以总的合法答案数就是 $2^k$，设为 $ansk$。

在 `BFS` 中，我们可以记录出每个连通块中满足 $col[i]=1$ 的 $i$ 的数量（设为 $cnt[1]$）和满足 $col[i]=2$ 的 $i$ 的数量（设为 $cnt[2]$）。

最后，`正确` 答案的最大数量就是所有连通块的 $\operatorname{max}(cnt[1],cnt[2])$ 的和，设为 $ansc$。

而相反的，`正确` 答案的最小数量就是 $n-ansc$。

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define max_n 1000000
#define mod 998244353
int n;
struct E{
	int v,c,nx;
}e[max_n<<2];
int ei=0;
int fir[max_n+2];
int col[max_n+2];
long long ansk=1;
int cnt[3];
int ansc=0;
inline void addedge(int u,int v,int c){
	e[++ei]=(E){v,c,fir[u]}; fir[u]=ei;
}
inline int ma(int a,int b){
	return a>b?a:b;
}
bool bfs(const int s){
	cnt[1]=1;
	cnt[2]=0;
	col[s]=1;
	queue<int>q;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=fir[u],v;i;i=e[i].nx){
			v=e[i].v;
			if(!col[v]){
				if(e[i].c)col[v]=col[u];
				else col[v]=3-col[u];
				++cnt[col[v]];
				q.push(v);
			}
			else{
				if((col[u]==col[v])^e[i].c)return false;
			}
		}
	}
	ansc+=ma(cnt[1],cnt[2]);
	return true;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P6691_1.in","r",stdin);
	freopen("P6691_1.out","w",stdout);
	#endif
	scanf("%d",&n);
	memset(fir,0,sizeof(fir));
	for(int i=1,x,op;i<=n;++i){
		scanf("%d%d",&x,&op);
		addedge(i,x,op);
		addedge(x,i,op);
	}
	memset(col,0,sizeof(col));
	for(int i=1;i<=n;++i){
		if(!col[i]){
			if(bfs(i)){
				ansk*=2;
				ansk%=mod;
			}
			else{
				ansk=0;
				break;
			}
		}
	}
	if(!ansk)printf("No answer\n");
	else printf("%lld\n%d\n%d\n",ansk,ansc,n-ansc);
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/58866043)

By **dengziyue**

---


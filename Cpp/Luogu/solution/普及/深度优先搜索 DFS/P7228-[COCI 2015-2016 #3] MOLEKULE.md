# [COCI 2015/2016 #3] MOLEKULE

## 题目描述

有 $N$ 个点和 $N-1$ 条无向边，定义一张有向图的代价为一条在这张有向图上的最长通路长度。

现在把这 $N-1$ 条无向边指定方向，使得形成的有向图代价最小。

求一种指定方向的方案。

## 说明/提示

#### 样例 1 解释

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/f1q6jgtu.png)

这张图的代价为 $1$，注意 $0\ 1$ 也是一组最优解。

#### 样例 2 解释

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/96aku20f.png)

#### 数据规模与约定

对于 $30\%$ 的数据，$N \le 20$。       
对于 $100\%$ 的数据，$2 \le N \le 10^5$，$1 \le a_i,b_i\le N$。

**本题采用 Special Judge。**        
你只需要输出任意一种合法方案。

#### 说明

翻译自 [COCI 2015-2016 #3 C MOLEKULE](https://hsin.hr/coci/archive/2015_2016/contest3_tasks.pdf)。

## 样例 #1

### 输入

```
3
1 2
2 3```

### 输出

```
1
0```

## 样例 #2

### 输入

```
4
2 1
1 3
4 1```

### 输出

```
0
1
0```

# 题解

## 作者：AzzyZhe (赞：12)

## 题解 [P7228 [COCI2015-2016#3] MOLEKULE](https://www.luogu.com.cn/problemnew/show/P7228)
~~我也来水题解了~~
### 思路分析
----
题目要求我们构造一种方案，确定一个$n$个点$n-1$条边的无向图各边方向，使产生的有向图中的最大连通块最小。很自然会想到树的情况，或者先考虑链的情况，不难得出只要原图上直接相连的点只要满足间隔地所连边都指向指出自己，或者说入度出度间歇地为$0$，就一定能得到为$1$的最小代价。例如：
```
1->2<-3->4<-5
```
和
```
    1<-8
    ^
 2<-3->4<-5
    v     v
    6     7
```

实现上，我们可以用一次无向图$dfs$解决问题。

从任意图中任一点$p$开始，先假定构造了一个有向图使刚好可以从该点遍历全图，$dfs$过程中将与该点$p$距离为奇数（或偶数）的边标记取反，再结合原边的情况取反即可。

其中最需要注意的是虽然是无向图，但由于最后输出的是是否与给出的边反向，建立无向图时依然需要考虑区分原边和反向边。这里我们选择将反向边存在$MAXN$以后的新区域（这样同时也可以用边的下标判断是不是原边），对于反向边遍历时需要调换方向的边即不需要调换，因此从哪个点开始$dfs$都没问题

### 代码
----
```cpp
#include<iostream>
#define endl '\n'
using namespace std;
#define MAXN 100001
int n;
struct edge{
    int v;
    int next;
}e[MAXN<<1];
int head[MAXN];
bool towards[MAXN];//确认边要不要调换方向
bool f=0;//初始为0或1都没关系
bool vis[MAXN];
void dfs(int p)
{
    if(vis[p])
        return;
    vis[p]=1;
    f^=1;
    for(int i=head[p];i;i=e[i].next)
    {
        if(vis[e[i].v])
            continue;
        //f^=1;
        if(i>MAXN)
            towards[i-MAXN]=f^1;
        else
            towards[i]=f;
        dfs(e[i].v);
        //f^=1;
    }
    f^=1;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1,j=MAXN+1,u,v;i<n;i++,j++)
    {
        cin>>u>>v;
        e[i].v=v,e[i].next=head[u],head[u]=i;//加边
        e[j].v=u,e[j].next=head[v],head[v]=j;//无向图加反向边  
    }
    dfs(0);
    for(int i=1;i<n;i++)
        cout<<towards[i]<<endl;
    return 0;
}
```
### 其他
----
回到一开始，$n$个点$n-1$条边的图就一定是树吗？实际上，题面中并没有说这个$n$个点$n-1$条边的无向图是连通的（虽然测试点中是这样体现的），也许这个图可能是分别连通的两部分，甚至说不定可能有环~~和平行边（自环平行边大概一般都不考虑）~~。所以之前的思考其实是不全面的。

幸运的是，再次考虑我们刚才的思路。只需分别从每个点进行一遍$dfs$（不重置$vis[]$）即可；而对于存在环的部分$dfs$同样适用，只是不能保证奇数个节点的环上最小代价总为$1$；至于平行边的问题在$dfs$同时也可以不需要任何额外步骤就得到解决。

#### 蒟蒻作题解，如有错误欢迎各位大佬指出

###### 小错误是故意的w

---

## 作者：Computer1828 (赞：8)

原题意应为：给出一棵树，求一个给边定向的方案，使得最长通路最短。

观察样例，很明显所说的最小代价一定是 $1$。

考虑构造，观察样例 $2$ 并再造几组样例进行尝试，可以发现：对于深度为奇数的点 $u$，可以把连接它的儿子 $v$ 的边定向成 $u->v$；对于深度为偶数的点，反过来，变成 $v->u$。

然后大概就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/d31zs8tq.png)

最后注意一下输出的连边方式，因为在遍历图的时候，是默认了当前点连出去或被连，但给的数据可能与这个点序相反，所以要注意一下奇数深度和偶数深度的不同。

我估计这道题是没有 spj 的，所以如果你坚信你的代码没有错，可以试着在输出的时候反过来，即把 $1$ 换成 $0$，$0$ 换成 $1$。然而实际上，这并不会影响最小代价。

代码：
```cpp
int n,U[N],V[N],dep[N],ans[N];
vector<pair<int,int> > e[N];
inline void dfs(int u,int fa){
	dep[u] = dep[fa]+1;
	for(int i = 0;i<e[u].size();++i){
		int v = e[u][i].first,id = e[u][i].second;
		if(v == fa) continue;
		if(dep[u]%2 == 1) ans[id] = U[id]==u?1:0;
		else ans[id] = U[id]==v?1:0;
		dfs(v,u);
	}
}
int main(){
	n = read();//读入
	FOR(i,1,n-1) U[i] = read(),V[i] = read(),add(U[i],V[i],i);//连边
	dfs(1,0);
	FOR(i,1,n-1) printf("%d\n",(ans[i]+1)&1);
	return 0;
}
```

---

## 作者：liujy_ (赞：4)

### 题目大意
 给一个 $n$ 个点 $n-1$ 条边的无向图，把其中的边换成有向边，使得其中的最长通路最短。
 

 ------------
 要求最长通路尽肯能的短，我就想到如果可以使得两个相邻的点一个入度为 $0$，另一个出度为 $0$，那么最长通路一定为 $1$。  
 我们考虑把节点分层。  
 我们假定 $1$ 为根，且节点 $1$ 的深度为 $0$。从根节点开始往下搜，记录每个节点的深度。对于每条边连接的两个点，如果 $b_i$ 的深度是奇数（即 $b_i$ 在偶数层），则 $a_i$ 向 $b_i$ 连边；如果 $b_i$ 的深度是偶数（即 $b_i$ 在奇数层），则 $b_i$ 向 $a_i$ 连边。这样我们就可以使奇数层的节点入度为 $0$，偶数层的节点出度为 $0$。  
 具体可以看下方代码实现。  
 ```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int n,d[200005],head[200005],cnt;
struct node{
	int u,to,next;
}e[200005];
void add(int u,int v){e[++cnt]=((node){u,v,head[u]});head[u]=cnt;}
void dfs(int x,int fa){
	for(int i=head[x];i;i=e[i].next){
		int v=e[i].to;
		if(v==fa)continue ;
		d[v]=d[x]+1;//记录深度
		dfs(v,x);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1,x,y;i<n;i++){
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);///无向图连两条边
	}
	dfs(1,0);
	for(int i=1;i<n;i++){
		int x=e[i*2-1].u,y=e[i*2-1].to;//因为我用链式前向星存图，所以第i条边的实际存储编号是2*i-1
		printf("%d\n",d[y]&1);
	}
	return 0;
}
```


---

## 作者：Maysoul (赞：2)

随机到的一道题，感觉还蛮有意思的。

## 简化题意：

将一棵树上的无向边指定方向，使这棵树上最长通路最小。

## 简述思路：

容易想到，我们可以采用和二分图染色差不多的方法，每经过一条边的时候就进行一次染色。

在染色的过程中我们不难发现，这个所谓的最长通路一定为 $ 1 $。

显然，这是一棵树，故所有节点只能被它的父节点到达，也就是说父节点到子节点的路径唯一，这也就代表着这个点与父的连边被染色后，无法再次被染色，而这个点与它儿子的连边，所染的就不是同一颜色了。

故不会有两个颜色相同的边连接，命题得证。

然后我们再考虑是无向转为有向的选择，显然一条无向边只能被染一次，故我们在建图的时候，可以给一边附上正向标记，另一边设为反向标记。保证这两个标记都可以指向这一条无向边即可。

值得一提的是，在取到反向标记的时候，染色也应该取反向染色。因为在反向的时候，父亲和儿子的顺序也颠倒了，故需要反向染色。

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int head[MAXN];
int escnt;
struct node{
	int to,from,num,next;
}edge[2*MAXN];
void add(int from,int to,int w)
{
	edge[++escnt].from=from;
	edge[escnt].to=to;
	edge[escnt].num=w;
	edge[escnt].next=head[from];
	head[from]=escnt;
}
bool vis[MAXN];//标记是否被访问
int a[MAXN];//标记当前无向边方向
void dfs(int x,int tor)
{
	for(int i=head[x];i!=-1;i=edge[i].next){
		int id=edge[i].num;//查看当前标记
		if(vis[abs(id)]) continue;
		if(id>0){
			a[id]=tor;
			vis[id]=1;
			dfs(edge[i].to,1-tor);
		}
		else{
			id=abs(id);
			a[id]=1-tor;
			vis[id]=1;
			dfs(edge[i].to,1-tor);
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	int n,u,v;
	cin>>n;
	for (int i=1;i<=n-1;i++){
		cin>>u>>v;
		add(u,v,i);
		add(v,u,-i);
	}
	dfs(1,0);
	for (int i=1;i<=n-1;i++){
		cout<<a[i]<<endl;
	}
	return 0;
}
```


---

## 作者：_JF_ (赞：2)

##  [COCI2015-2016#3] MOLEKULE 

首先，这个题给出的是一棵树，也就是没有环，但题目没有提及。

首先如果是一棵树的话，这个“最长通路”一定是 $1$，我们考虑这么一种方式：

首先，我们钦定 $1$ 为根节点，对于当前的层数，如果是奇数的话，必定是父亲连向儿子，偶数层则是儿子连向父亲，就可以保证“最长通路”为 $1$。

证明也很简单，如果对于偶数层的点，他无法连向任何点，“最长通路”为 $0$。

如果是奇数的话，他仅仅可以连向他的父亲结点和儿子结点，而父亲和儿子都是偶数结点，没有最长通路，所以最长是 $1$。

在实现的时候，我们考虑先连接双向边，然后是如果是父亲连向儿子，父亲对儿子这条边就赋值为 $1$ ，儿子对父亲就赋值为 $-1$，表示儿子和父亲之间没有连边。

儿子连向父亲也是一样的。

最后看两个边之间的值是 $0$ 还是 $1$，按照题意输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
struct node
{
	int v,w;
};
int dep[N],u[N],v[N];
vector<node>g[N<<1];
void dfs(int u,int fath)
{
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i].v;
		if(v==fath)
			continue;
		dep[v]=dep[u]+1;
		dfs(v,u);
	}
}
void Slove(int u,int fath)
{
	if(dep[u]%2==0)
	{
		for(int i=0;i<g[u].size();i++)
		{
			int v=g[u][i].v;
			if(v==fath)
				continue;
			g[u][i].w=0;
			for(int j=0;j<g[v].size();j++)
				if(g[v][j].v==u)
				{
					g[v][j].w=1;
					break;
				}
		}
	}
	else
	{
		for(int i=0;i<g[u].size();i++)
		{
			int v=g[u][i].v;
			if(v==fath)
				continue;
			g[u][i].w=1;
			for(int j=0;j<g[v].size();j++)
				if(g[v][j].v==u)
				{
					g[v][j].w=0;
					break;
				}
		}
	}
	for(int i=0;i<g[u].size();i++)
	{
		int v=g[u][i].v;
		if(v==fath)
			continue;
		Slove(v,u);
	}
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	std::ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int n;
	cin>>n;
	dep[1]=1;
	for(int i=1;i<n;i++)
		cin>>u[i]>>v[i],g[u[i]].push_back({v[i],-1}),g[v[i]].push_back({u[i],-1});
	dfs(1,0);
	Slove(1,0);
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<g[u[i]].size();j++)
		{
			int v1=g[u[i]][j].v,w=g[u[i]][j].w;
			if(v1==v[i])
			{
				if(w==0)
					cout<<"0"<<endl;
				else
					cout<<"1"<<endl;
				break;
			}
		}
	}
	return 0;
}

```


---

## 作者：pxb0801 (赞：2)

## ~~一道大水题~~

好了，现在咱们闲话少叙，进入正题。

--------------
### 1.思考过程

首先，当我看到这道题是，先是愣了一下，因为这题的数据量还是很大的，但一开始我想到的就是暴力，即对于每条边，选择是如何指向，时间复杂度 $O(2^n)$，很明显只能拿 $30$ 分。

接着，我就突然发现，这题其实是构造！因为它不像图有环，所以相邻两条边指向不同，就是最优解，长度恒等于 $1$。

-------------
### 2.分析

既然构造好了，我们就要模拟了，由于这里的边的输入是乱序，所以我们要对每条边记录序号，便于 $ans[]$ 数组的填充。接下来给出主要 **dfs** 代码：

```cpp
void dfs(int x,int fa,bool q){
	int l=g[x].size();
	for(int i=0;i<l;i++){
		int y=g[x][i].v;
			if(y==fa) continue;
			dfs(y,x,!q); 
			ans[g[x][i].id]=q;
			if(x!=xx[g[x][i].id]) ans[g[x][i].id]=!q;
    }
}
int main(){
	……
	dfs(1,0,1);
	……
}
```

首先我们看一看函数变量：$x$ 表示当前所在的节点，$fa$ 表示当前节点的父亲节点编号，$q$ 则表示当前节点的指向，$1$ 表示当前节点指向其儿子，$0$ 则表示儿子节点指向自己本身。

然后是正常的搜索儿子节点，每次搜索时 $q$ 要取反。之后将方向存入 $ans$ 数组中。

接下来是一个小坑：输入边可能有第一个数大于第二个数的，但 dfs 是从小往大走的，所以如果发现，$q$ 还需取反一次。

-------------
### 3.正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans[100005],xx[100005],yy[100005];//注意数据范围 
struct node{
    int v,id;
    //v表示当前节点指向谁，id是这条边的序号 
};
vector<node> g[100005];
void dfs(int x,int fa,bool q){
    int l=g[x].size();
    for(int i=0;i<l;i++){
        int y=g[x][i].v;
        if(y==fa) continue;
        dfs(y,x,!q); 
        ans[g[x][i].id]=q;
        if(x!=xx[g[x][i].id]) ans[g[x][i].id]=!q;
    }
}
int main(){
    cin>>n;
    for(int i=1;i<n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        xx[i]=x;
        yy[i]=y;
        g[x].push_back((node){
            y,i
        });
        g[y].push_back((node){
            x,i
        });//vector双向加边 
    }
    dfs(1,0,1);
    for(int i=1;i<n;i++){
        printf("%d\n",ans[i]);//按序输出 
    }
    return 0;
}
```


---

## 作者：zhou2414 (赞：1)

# 题目描述
给你一颗树，让你将其变成有向图，且使得最长通路最短。
# 思路
如果这不是一棵树的话还有点难度，但是这是一棵树。

所以很显然的是只要让树每层的边方向交错，如下图：

![树](https://cdn.luogu.com.cn/upload/image_hosting/8xbhlnae.png)

那么就可以保证最长通路的长度为 $1$。把树中每条边的方向都反转也是一样的。

我们可以钦定根节点的边的方向朝下，然后每递归下去一层就让方向反转，记录边的编号以及是否为反向建的边，在 dfs 的过程中直接处理答案即可。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1e5+9;
ll n;
struct LIAN{
	ll to,ne,id;
	bool bo;
}lian[N*2];
ll h[N],cnt;
ll ans[N];
inline void add(ll u,ll v,ll id,bool bo){
	lian[++cnt].to=v;
	lian[cnt].ne=h[u];
	lian[cnt].id=id;
	lian[cnt].bo=bo;
	h[u]=cnt;
}
void dfs(ll now,bool bo,ll fa){
	for(int i=h[now];i;i=lian[i].ne){
		ll to=lian[i].to;
		if(to==fa)continue;
		ans[lian[i].id]=bo^lian[i].bo;
		dfs(to,!bo,now);
	}
}
int main(){
	cin>>n;
	for(int i=1;i<n;i++){
		ll u,v;
		cin>>u>>v;
		add(u,v,i,1),add(v,u,i,0);
	}
	dfs(1,0,0);
	for(int i=1;i<n;i++){
		cout<<ans[i]<<endl;
	}
	return 0;
}
```

---

## 作者：ZZA000HAH (赞：1)

随机跳题跳到的一道题。

题意：给定一张无向图，使其变为有向图，让最长通路最短。

分析，$N$ 个点，$N-1$ 条边，好像是树（实际上不一定，因题目未明确说图是联通的，但测试点的确全是树），我们按树来处理：一棵树，随便指定一个根，从根出发，让奇数深度的结点和偶数深度的结点的所指向方向（指向方向：向根指向或反根方向指向）不同即可，这样所得到的有向图的通路全为 $1$。可以用数组 $d_i$ 来表示点 $i$ 的深度，这样递归函数需传入最近的父结点。或者直接传入最近的父结点指向方向的数字（0 或 1），这样就省去了深度计数数组。

实现方式：可以用动态数组存图，递归遍历图，记下每两点间的方向数字，再按输入顺序输出（~~因开始时为按顺序输出，导致两次爆零~~）。具体如何记录两点之间的方向数字呢，数据范围为 $n\le 10^{5}$，那么显然用二维数组是不现实的，根据起终点变换得到一个容易双向变换且唯一对应的数的实现方式，本蒟蒻并没有很好的解决办法，但是，本蒟蒻想到了用映射来存的方式，代码如下：
```cpp
map<string,int>mp;
s=to_string(x)+"to"+to_string(y);
mp[s]=num;
```
C++ 中映射性能还是不错的，一般放心使用。

那么具体代码如何，代码如下（C++98 标准不兼容 to_string() 函数）：
## AC Code

```cpp
/*
author:zza000hah
说明：注释中 ai 和 bi 为题目中表示的变量
*/
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <algorithm>
#include <string>
using namespace std;
const int NUM=1e5+10;
vector<int>G[NUM],kG[NUM];//G 存无向图双边，kG 存 ai->bi 以记录 ai 和 bi
vector<int>::iterator it;
map<string,int>mp;//映射，以便按输入顺序输出
bool ins[NUM];
struct node
{
	int l,r;
}nodes[NUM];//记录输入顺序
void hah(int x,int num)//num 代表父结点指向方式
{
	ins[x]=1;//标记
	int len=G[x].size();
	for (int i=0; i<len; i++)
	{
		int y=G[x][i];
		if (!ins[y])
		{
			int a;
			string s2;
			it=find(kG[x].begin(),kG[x].end(),y);//判断 x 是否为 ai
			if (it==kG[x].end())//x 不是 ai
			{
				s2=to_string(y)+"to"+to_string(x);//映射方式
				mp[s2]=num;//实际上，是 abs(abs(num-1)-1)，化简为 num
			}
			else
			{
				s2=to_string(x)+"to"+to_string(y);//映射方式
				mp[s2]=abs(num-1);//x 是 ai，与父结点方向数字相反
			}
			hah(y,abs(num-1));//递归
		}
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for (int i=1; i<n; i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);//正反存边
		kG[x].push_back(y);//记录 ai->bi
		nodes[i]={x,y};
	}
	hah(1,0);//随便指定根递归
	for (int i=1; i<n; i++)
	{
		int x=nodes[i].l,y=nodes[i].r;
		string s1=to_string(x)+"to"+to_string(y);//映射方式
		printf("%d\n",mp[s1]);
	}
	return 0;
}
```
蒟蒻欢迎各位大佬指出错误。
###### End。

---

## 作者：Angelastar (赞：1)

~~很好的找规律题。~~

---

**题目大意**

给一个  $n$  个点  $n−1$  条边的无向图，把其中的边换成有向边，使得其中的最长通路最短。

---

**题解**

通过推导样例不难发现最短的最长通路一定为 $1$，其实只要画一个五层的符合题意的有向图就可以找到规律。

声明：因为输入是无向图，所以从 $a$ 节点入手和 $b$ 节点入手没有区别，这里从 $b$ 节点入手。

先考虑图的结构为一条链，若使  $n=5$，则符合题意的图如下。

$1<2>3<4>5$。

于是就会发现，根节点为 $1$，$n=5$ 时，深度为奇数的节点出度为  $0$，深度为偶数的节点入度为 $0$，即可构建题目中最长通路为 $1$ 的有向图。

若节点 $b$ 出度为 $0$，则一定有边从 $a$ 节点连向  $b$ 节点，因此输出 $0$。所以得到：若节点 $b$ 深度为奇数，则输出 $0$，反之输出 $1$。

其他图也同理。于是我们就可以快乐的 AC 这道题了。

---

**code**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+5;
int n,deep[N],u[N],v[N];
vector<int>g[N];
void dfs(int x,int fa){
	deep[x]=deep[fa]+1;
	int l=g[x].size();
	for(int i=0;i<l;i++){
		if(g[x][i]==fa)continue;
		if(deep[g[x][i]])continue;//搜过的不再搜
		dfs(g[x][i],x);
	}
}
int main(){
	cin>>n;
	for(int i=1;i<n;i++){
		int u1,v1;
		cin>>u1>>v1;
		u[i]=u1;
		v[i]=v1;
		g[u1].push_back(v1);
		g[v1].push_back(u1);
	}
	dfs(1,0);//深度
	for(int i=1;i<n;i++){
		if(deep[v[i]]%2==0){
			cout<<1<<endl;
		}else{
			cout<<0<<endl;
		}
	}
	return 0;//好习惯
}
```


---

感谢审核大大。

---

## 作者：Erica_N_Contina (赞：1)

## 思路

如果这幅图是一颗树，那么很简单。我们只要让相邻的两条边方向都不同即可。事实证明这样是可以做到的，并且也是最优的做法。

那么我们怎么样来实现呢？当然是 dfs 了。不过除了 dfs，我们还有这种方法——数学推导。很简单的，假如树的深度为奇数（我们这里定义根的深度为 $1$），那么我们定义 $d(x)$ 为第 $x$ 条边的两个节点的深度的最小值。对于一条边 $x$，如果 $d(x)$ 为奇数，那么我们让这条边从高指向低（这里指深度），反之从低指向高。

假如这幅图不是一颗树，那么就会有环出现。如果按照上面的做法，那么对于奇数长度的环，就会有长度为 $2$ 的通路。那么我们就不能用数学推导了。但是我们还是可以用dfs来做。

本题的代价要么是 $1$，要么是 $2$，并且当且仅当存在奇数长度的环时代价为 $2$。（事实上，据题解区说，好像都是树啊）

## 代码

注意本题输出的是：

- 如果 $r=1$ 代表从 $a_i$ 连向 $b_i$。

- 如果 $r=0$ 代表从 $b_i$ 连向 $a_i$。

而不是：

- 如果 $r=1$ 代表从深度大的连向深度小的。

- 如果 $r=0$ 代表从深度小的连向深度大的。

所以要么对 $4$ 种情况分类讨论（如片段 $1$），要么用异或来实现 $4$ 种情况。

片段 $1$

```C++
int d(int x,int y){
	if(dep[x]<dep[y]){
		if(dep[y]%2)return 1;
		return 0;
	}else{
		if(dep[x]%2)return 0;
		return 1;
	}
	return 0;
}


signed main(){
	//...
	for(int i=1;i<n;i++){
		cout<<d(a[i],b[i])<<endl;
	}
	return 0;
}

```


片段 $2$

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define pb push_back
using namespace std;

const int N=1e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

vector<int> e[N];
int dep[N],a[N],b[N];
int n;

void add(int a,int b){
	e[a].pb(b);
	e[b].pb(a);
}

void dfs(int x,int fa){
	dep[x]=dep[fa]+1;
	for(auto v:e[x]){
		if(v==fa)continue;
		dfs(v,x);
	}
}

int d(int x,int y){
	if(dep[x]<dep[y])return dep[y];
	return dep[x];
}

signed main(){
	cin>>n;
	for(int i=1;i<n;i++){
		cin>>a[i]>>b[i];
		add(a[i],b[i]);
	} 
	
	dfs(1,0);
	
	for(int i=1;i<n;i++){
		cout<<((d(a[i],b[i])%2)^(dep[a[i]]<dep[b[i]]))<<endl;
	}
	return 0;
}

```


两种方法均可通过。对于片段 $1$，把它复制到片段 $2$ 中替换一下即可通过。



---

## 作者：wandereman (赞：0)

## 审题和分析
有 $N$ 个点和 $N-1$ 条无向边，所以是有一棵树无疑了，再加上奇大的数据，和一时半会儿没有思路，所以考虑了构造，答案应该是要么 $0$，要么是 $1$。
## 思路和做法
1. 我们应该将所有的边记录下编号，因为我们的输入是乱序，便于接下来的操作。
```cpp
struct add{int v,id;};
//id就是这条边的编号 
```

2. 然后搜索儿子节点，每次搜索时 $p$ 要取反。之后将边的方向存入数组中。
```cpp
void dfs(int x,int fa,bool p){
    int l = a[x].size();
    for(int i = 0;i < l;i++){
        int y = a[x][i].v;
        if(y == fa){
        	continue;
		}
        dfs(y,x,!p); 
        ans[a[x][i].id] = p;
        if(x != a1[a[x][i].id]){
        	ans[a[x][i].id] = !p;
		}
    }
}
```
3. 注意：输入边可能有第一个数大于第二个数的，需要特判让 $p$ 在取反一次。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans[100005],a1[100005],a2[100005];
struct add{int v,id;};
vector<add> a[100005];
void dfs(int x,int fa,bool p){
    int l = a[x].size();
    for(int i = 0;i < l;i++){
        int y = a[x][i].v;
        if(y == fa){
        	continue;
		}
        dfs(y,x,!p); 
        ans[a[x][i].id] = p;
        if(x != a1[a[x][i].id]){
        	ans[a[x][i].id] = !p;
		}
    }
}
int main(){
    cin>>n;
    for(int i = 1;i < n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        a1[i] = x;
        a2[i] = y;
        a[x].push_back((add){y,i});
        a[y].push_back((add){x,i});
    }
    dfs(1,0,1);
    for(int i = 1;i < n;i++){
        cout<<ans[i]<<endl;
    }
    return 0;
}
```

---

## 作者：wandereman (赞：0)

## 题意
- 首先可以很敏锐地发现，当一个图是 $N$ 个点和 $N - 1$ 个无向边时，这一定是一棵树。
- 定义代价为最长通路长度。
- 为所有便指定长度，使通路最小。
## 思路
我们不难想出，让深度为奇数到偶数边，方向向上，让深度为偶数到奇数边，方向向下，是最长通路变成 $1$。最后只需跑一遍 dfs 就可以了。
## AC code
```cpp
#include<bits/stdc++.h>
#include<queue>
#define int long long
using namespace std;
int n,d[200005],head[200005],cnt;
//存树部分 
struct node{
   int u,to,next;
}e[200005];
void add(int u,int v){
	e[++cnt]=((node){u,v,head[u]});
	head[u]=cnt;
}
//深搜部分 
void dfs(int x,int fa){
   	for(int i=head[x];i;i=e[i].next){
   		int v=e[i].to;
   		if(v==fa)continue;
   		d[v]=d[x]+1;
   		dfs(v,x);
   	}
}
//主函数部分 
signed main(){
   	cin>>n;
   	for(int i=1,x,y;i<n;i++){
   		cin>>x>>y;
   		add(x,y);
		add(y,x);
   	}
   	dfs(1,0);
   	for(int i=1;i<n;i++){
   		int x=e[i*2-1].u;
		int y=e[i*2-1].to;
   		cout<<d[y]&1<<endl;
   	}
   	return 0;
}//有坑勿抄
```

---

## 作者：wandereman (赞：0)

## 思路
首先我们先看题意，他说求在一棵树上为每一条边制定方向，使最长通路最小。那么我们可以在纸上列举一下，得出是 $1$，那么我们就要加以构造。        
1. 令编号为 $1$ 的点为根节点。
1. 对于树的每一层上的边，都为统一方向，而指向父亲的边与指向儿子的边在层与层之间交替出现。
1. 用 ```dfs```遍历出每个点的深度。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],x[100005],y[100005],i;
struct node{int v,id;};//定义结构体 
vector<node>v[100005];
void dfs(int x,int fa,bool q){
    int l = v[x].size();
    for(i = 0;i < l;i++){
        int y = v[x][i].v;
        if(y==fa)continue;
        dfs(y,x,!q); 
        a[v[x][i].id] = q;
        if(x != x[v[x][i].id])a[v[x][i].id] = !q;
    }
}//搜索 
int main(){
    cin>>n;
    for(i = 1;i < n;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        x[i] = x;
        y[i] = y;
        v[x].push_back((node){y,i});
        v[y].push_back((node){x,i});//存边存树 
    }
    dfs(1,0,1);
    for(i = 1;i < n;i++){
        cout<<a[i];
    }
    return 0;
}
```

---

## 作者：_EternalRegrets_ (赞：0)

### 题目大意：
>给定一棵树，给它的每一条边制定方向，使得它的最长通路长度最小。

### Solution:
容易发现，这个最小值一定是 $1$，考虑构造。

令编号为 $1$ 的点为根节点。对于树的每一层上的边，都为统一方向，而指向父亲的边与指向儿子的边在层与层之间交替出现。

```dfs``` 遍历出每个点的深度，计算答案时注意哪个端点在树中深度大小即可。

### code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
using namespace std;

vector <int> v[100005];
map <int,pair <int,int> > mp;
int dep[100005];

void dfs(int x,int f){
    dep[x]=dep[f]+1;
    for(auto i:v[x]){
        if(i==f){
            continue;
        }

        dfs(i,x);
    }
}

signed main(){
    int n; cin>>n;

    for(int i=1;i<n;i++){
        int a,b; cin>>a>>b;

        v[a].push_back(b);
        v[b].push_back(a);
        mp[i]={a,b};
    }

    dfs(1,0);

    for(int i=1;i<n;i++){
        cout<<dep[mp[i].se]%2<<"\n";
    }

    return 0;
}
```

---


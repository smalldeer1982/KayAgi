# [蓝桥杯 2019 省 A] 糖果

## 题目描述

糖果店的老板一共有 $M$ 种口味的糖果出售。为了方便描述，我们将 $M$ 种口味编号 $1$ ∼ $M$。

小明希望能品尝到所有口味的糖果。遗憾的是老板并不单独出售糖果，而是 $K$ 颗一包整包出售。

幸好糖果包装上注明了其中 $K$ 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。

给定 $N$ 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。

## 说明/提示

对于 $30\%$ 的评测用例，$1 \le N \le 20$。

对于所有评测样例，$1 \le N \le 100$，$1 \le M \le 20$，$1 \le K \le 20$，$1 \le T_i \le M$。

蓝桥杯 2019 年省赛 A 组 I 题。

## 样例 #1

### 输入

```
6 5 3
1 1 2
1 2 3
1 1 3
2 3 5
5 4 2
5 1 2```

### 输出

```
2```

# 题解

## 作者：SamHJD (赞：36)

## P8687 题解

[题目传送门](https://www.luogu.com.cn/problem/P8687)

不难看出，此题不是爆搜就是动态规划，而爆搜需要考虑每一种搭配情况，复杂度 $O(2^n)$ 肯定超时。

考虑动态规划，可以发现数据范围很小，并且是搭配类型的，想到**状压**。

首先设计状态，一共可以设计出两种：

* $dp[i]$ 表示取状态为 $i$ 的几包糖，最多可以凑出的口味数量。这种状态比较麻烦，且结果不是很容易得出。

* $dp[i]$ 表示凑出状态为 $i$ 的口味**最少需要几包糖**。

很显然第二种很合理，那么我们来推一下方程。

思考发现，如果直接枚举 $i$，再找合理的上一种状态，不是很好找。但我们可以通过**已经求出来的一种状态**，配合**另一种状态**，来更新新的状态。

设 $v[i]$ 表示第 $i$ 包糖的口味状态，则有：

$dp[i|v[j]]=\min(dp[i|v[j]],dp[i]+1)$

$dp[i|v[i]]$ 为更新的新状态，$i$ 为已知的状态 $1$，再找**一包糖** $j$，更新出 $dp[i|v[i]]$。

考虑正确性，因为 $i$ 状态从 $0$ 开始枚举，因此枚举到 $i|v[i]$ 时肯定已经求出 $dp[i]$ 的值，并且是**最优**的。还有一个问题是是否可能重复选了某包糖，如果是，那么肯定这个值不是最优的，因为你买两包同样的糖和只买一包口味不会有新的。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20;
int n,m,k,dp[1<<20],v[1<<20];//状压的数组需要开2^n，因为表示的是状态
int main(){
    scanf("%d%d%d",&n,&m,&k);
    memset(dp,0x3f3f3f3f,sizeof(dp));
    for(int i=1;i<=n;++i){
        int h=0,p;
        for(int j=1;j<=k;++j){
            scanf("%d",&p);p--;
            h=h|(1<<p);//这里不能用+，一包糖里可能有多种同一口味的
        }
        dp[h]=1;//这些口味都可以用一包糖解决
        v[i]=h;//记录糖的状态
    }
    for(int i=0;i<(1<<m);++i){//i枚举的是状态，即0～1...11111（m个1）
        for(int j=1;j<=n;++j){
            dp[i|v[j]]=min(dp[i|v[j]],dp[i]+1);//如上
        }
    }
    if(dp[(1<<m)-1]==0x3f3f3f3f) cout<<-1;//搭配不出来
    else cout<<dp[(1<<m)-1];//搭配出来
    return 0;
}
```


---

## 作者：wuhan1234 (赞：18)

## 1. 编程思路。

用 $M$ 位二进制数来表示所购买糖果中 $M$ 种口味的组合情况。二进制数中 $b_i$ 位等于 $1$，表示有第 $i+1$ 种口味的糖果；若 $b_i$ 等于 $0$，表示没有第 $i+1$ 种口味的糖果。若 $M$ 种口味的糖果都有，则对应的 $M$ 位二进制数各位全为 $1$，用十进制整数表示为 $2^M-1$。

在输入数据时进行预处理，用 $a_i$ 保存第 $i$ 包糖果的口味组合情况。以题目中的输入输出样例为例，输入的 $6$ 包糖果的口味组合情况可以依次表示为 $3,7,5,22,26,19$。

之后就可以采用 0/1 背包进行求解。

设 $F_i$ 表示糖果的口味组合情况为 $i$ 时需要购买的最少的糖果包数。

初始时，$2^M$ 种口味组合情况的 $F_i(0\le i\le 2^M-1)$ 的值均可以设置为一个大于 $100$ 的整数，表示口味组合 $i$ 无法品尝到。

定义 $F_0=0$，什么口味也没有，显然什么糖果也不需要购买。

状态转移方程为 $F_{j \  or \  a_i}=\min(F_{j \  or \  a_i},F_j+1)$。

其中， $1\le i \le N$，$0\le j\le 2^M-1$。

最后的答案为 $F_{2^M-1}$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int f[1<<20],a[105]={0};
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
    int num=(1<<m);    // m种口味的各种组合总的状态数
	int i,j;
	for (i=0;i<num;i++)
    {
		f[i]=105;
	}
	for (i = 0;i<n;i++)
	{
		for (j = 0;j<k;j++)
		{
			int t;
			scanf("%d",&t);
			a[i] = a[i]|(1<<(t-1));
		}
	}
	f[0]=0;
	for (i=0;i<n;i++)
	   for (j=0;j<1<<m;j++)
	   {
		   if (f[j]>100) continue;
		   f[j|a[i]]= (f[j|a[i]]<f[j]+1)? f[j|a[i]] : f[j]+1;
	   }
	if (f[num - 1]==105) printf("-1");
	else printf("%d",f[num - 1]);
	return 0;
}
```


---

## 作者：初雪_matt (赞：14)

## 题意

有 $m$ 种口味，每次 $k$ 颗一袋出售，给你 $n$ 包均为 $k$ 颗的糖果，求最少买几袋可以吃到所有口味的糖果。

## 思路

- 暴力
	
    对 $n$ 包糖果做组合。如果找到其中一种包含了所有口味，将所有满足的方案取糖果包数最小即可。
    
    时间复杂度 $\mathcal{O(2^n)}$。
    
- 正解

	考虑状压 dp 优化，定义状态 $dp_i$ 为得到组合 $i$ 的最少糖果包数，即答案为 $dp_{(1<<m)-1}$。
    
    往组合 $i$ 中加入一包糖果，得到新的组合 $j$，则从 $i$ 到 $j$ 需要包数 $dp_i+1$。若原来的 $dp_j$ 本来就大于 $dp_i+1$，说明找到了更优解法，更新 $dp_j$ 即可。
   
## 代码

```cpp
for(int i=0;i<=(1<<m)-1;i++){
    if(dp[i]!=-1){
        for(int j=0;j<n;j++){
            if(dp[i|a[j]]==-1||dp[i|a[j]]>dp[i]+1){
                dp[i|a[j]]=dp[i]+1;
            }
        }
    }
}
```

---

## 作者：__KevinMZ__ (赞：2)

# [题解：P8687 \[蓝桥杯 2019 省 A\] 糖果](https://www.luogu.com.cn/problem/P8687)

## 感受

一道明显的状压 dp。

## 思路

设每包糖果状态 $t_i$（譬如说 $t_i=37=(100101)_2$ 时表示这包糖果只有 $1,3,6$ 三**种**糖果）

dp 三要素：

1. $dp_i$ 表示什么；
2. $dp_i$ 怎么转移（别人到自己或自己到别人）；
3. 循环顺序。

给出要素：

1. $dp_i$ 表示状态为 $i$ 时最少需要多少包糖果；
2. $dp_i$ 转移到 $1\le j\le n,j\in \Z$ 的 $dp_{i\operatorname{or}t_j}$；转移方程 $dp_{i\operatorname{or}t_j}\gets\min\{dp_{i\operatorname{or}t_j},dp_i+1\}$（选或不选）；
3. 先枚举 $i$ 再枚举 $j$。

好了，这下开始敲代码吧！

## 代码

```cpp
#include<bits/stdc++.h>
#define int __int128
#define ONLINE_JUDGE
using namespace std;
inline istream&operator>>(istream&is,int&k){
	int f=1;
	k=0;
	char ch=getchar();
	while(!isdigit(ch))(ch=='-'?f*=-1:f*=1),ch=getchar();
	while(isdigit(ch))k=(k<<3)+(k<<1),k+=ch-'0',ch=getchar();
	k*=f;
	return is;
}
inline ostream&operator<<(ostream&os,int k){
	if(k<0)putchar('-'),k*=-1;
	if(k>=10)os<<(k/10);
	putchar(k%10+'0');
	return os;
}
inline int qpow(int x,int y,const int mod=-1){int ans=1;while(y){if(y&1)ans*=x;x*=x;if(mod!=-1)ans%=mod,x%=mod;y>>=1;}return ans;}
//↑陋习，请勿学习↑
int n,m,k;
int dp[1<<20],t[100];//[0,i)省空间
signed main(){
#ifndef ONLINE_JUDGE
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	cin>>n>>m>>k;
	for(int i=0;i<(1<<m);i++)dp[i]=0x3f3f3f3f;
	for(int i=0;i<n;i++){
		for(int j=0;j<k;j++){
			int p;
			cin>>p;
			t[i]|=(1<<p-1);//一包糖果重复
			//p-1：二进制位0开始！
		}
		dp[t[i]]=1;
	}
	for(int i=0;i<(1<<m);i++){//枚举状态
		for(int j=0;j<n;j++){//枚举加的糖果包
			dp[i|t[j]]=min(dp[i|t[j]],dp[i]+1);//选或不选取最值
		}
	}
	cout<<(dp[(1<<m)-1]==0x3f3f3f3f?-1:dp[(1<<m)-1]);
	return 0;
}
/*
样例：
	输入：
	6 5 3
	1 1 2
	1 2 3
	1 1 3
	2 3 5
	5 4 2
	5 1 2
	输出：
	2
*/
```

---


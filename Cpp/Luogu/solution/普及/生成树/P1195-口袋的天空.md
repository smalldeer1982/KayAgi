# 口袋的天空

## 题目背景

小杉坐在教室里，透过口袋一样的窗户看口袋一样的天空。

有很多云飘在那里，看起来很漂亮，小杉想摘下那样美的几朵云，做成棉花糖。


## 题目描述

给你云朵的个数 $N$，再给你 $M$ 个关系，表示哪些云朵可以连在一起。

现在小杉要把所有云朵连成 $K$ 个棉花糖，一个棉花糖最少要用掉一朵云，小杉想知道他怎么连，花费的代价最小。


## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 100$，$1\le M \le 10^3$；

对于 $100\%$ 的数据，$1 \le N \le 10^3$，$1 \le M \le 10^4$，$1 \le K \le 10$，$1 \le X,Y \le N$，$0 \le L<10^4$。


## 样例 #1

### 输入

```
3 1 2
1 2 1
```

### 输出

```
1```

# 题解

## 作者：yangrunze (赞：298)

这个题思路倒是很简单：**最小生成树**嘛~

最小生成树是个啥？其实就像杨志一行人押送生辰纲。抛开最后生辰纲被抢的结局不谈，杨志他们需要到好几个地方，每个地方都需要花点过路费给梁山好汉们打点。比如下面就是一张城市地图：

![地图](https://cdn.luogu.com.cn/upload/image_hosting/xpqmkgyr.png)

其中每两个图之间的路径长就是要给梁山好汉们打点的银子数。比如**1号地点到2号地点的梁山好汉需要2两银子**。那么问题来了，**怎样才能选择其中一部分道路就可以到达所有地点且让总花费值最小呢？？？**

**如果有n个节点（城市），那就至少要连（n-1）条边（路线），并且肯定没有回路**。（不信？画几个图试试）众所周知，**在无向图中，只要这个图里没有回路（有（n-1）条边），那它就无疑是棵树了**。（还是不信？画图......）所以，**我们就管这棵各边权值（费用）和叫“最小生成树”**了。

那这个最小生成树到底怎么搞呢？我们伟大的先哲发明了两种算法：一种叫**Kruskal算法**，另一种叫**Prim算法**。我们这里就来介绍一下名字字典序靠前的那个Kruskal吧！~~（我才不会告诉你根本原因是本蒟蒻不会用Prim呢！）~~

那咱就开始吧！首先，我们读入的数据是这样的！
```
1 2 2
1 3 2
1 4 4
2 3 3
3 4 4
```
其中每一行的a,b,c 3个数是指**a到b的路径权值是c**哦！

既然题目中让我们求“最小”生成树，那咱们就自然而然地想到先**把这些边排个序，先用最小的边，从小到大一路把这棵树搞出来**！

说干就干，排一个呗！

```
1 2 2
1 3 2 
2 3 3
1 4 4
3 4 4
```
排好之后，映入我们眼帘的是“1，2，2”这条边，二话不说，把它放到生成树里！

![过程1](https://cdn.luogu.com.cn/upload/image_hosting/buj8anif.png)

接下来是“1，2，2”，很好，把它也加进去

![](https://cdn.luogu.com.cn/upload/image_hosting/63dd59r7.png)

然后是“2，3，3”，好多同学把它都加了进去......

![](https://cdn.luogu.com.cn/upload/image_hosting/545sebqj.png)

等会等会，先别忙着加！好像有什么猫腻！前面说过，**最小生成树，是不能带回路的**，加进去一不是最小，二它连个树都不是，所以不能加！于是我们意识到：**在每次加进去新边之前，一定要看看它和其它边会不会构成回路**才行！

那咱就只能退而求其次，选其它的边啦，“1，4，4”这可不是回路，没问题！

![](https://cdn.luogu.com.cn/upload/image_hosting/ei5ln2vc.png)

至此，边数已达（n-1）条，所有点已经选上，最小生成树大功告成！（当然，选下面的“3，4，4”也是阔以的）

总结一下，我们刚才是怎样搞出这棵最小生成树的：

1. 把边们从小到大**排个序**
1. 如果**没有回路**，一条一条**往里加**
1. 边数达到（**n-1**）**条**，完成

步骤都弄懂啦！但是这个“回路”到底怎么判断呢？

所谓判断回路，就是看看有了这条边之后，**有没有连通的部分**，从“**树**”的角度来看，就是**两个点的根节点（也就是“祖宗”）是不是一样的**

哎？话说说到这里，诸位有没有联想到什么啊？

没错，就是金光闪闪的[**并！查！集！**](https://www.luogu.com.cn/problem/P3367)

并查集是啥就不在我的责任范围之内啦，（~~其实就是懒癌犯了~~）这里我就默认泥萌都会并查集了......

所以说我们可以搞个并查集出来，**然后每加入条边时，先用并查集的“查询”功能，看看两个节点的祖宗是不是一样的，如果不一样就把他俩“合并”**，就可以放心大胆的往里加啦~

明白了最小生成树怎么搞，咱来看看这道题：现在大家都知道这题是典型的最小生成树了，但还要注意两个地方：

首先让我们选k朵云做棉花糖，换句话说就是**选k个节点构造最小生成树**，那不好办！我们都知道，**全部n个点的最小生成树有（n-1）条边**，那**选k个节点就是（n-k）条边**呗！

其次就是这个“No Answer”怎么弄的问题，其实也so easy，你想啊，**一共就m条边，如果都选完了还没有选出（n-k）条边来，那就是妥妥的No Answer 了**

bb了这么多，是时候放代码了！听我这么一讲解，大家应该都理解最小生成树的Kruskal算法了吧！

```cpp
#include<iostream>
#include<algorithm>  //sort嘛......当然要开万能的algorithm
using namespace std;
struct woyaohongming{ //不要在意这个结构体的名字......它只是用来存储图的而已
	int s,e,w;    //s-start，e-end，代表边上的两个节点，w就是权值费用了
}a[200005];
int f[200005];  //并查集用的f数组
bool cmp(woyaohongming a,woyaohongming b){   //sort排序规则，按费用从低到高排序
	return a.w<b.w;
}
int find(int a){  //并查集的“找祖宗”函数，注意别忘路径压缩
	if(f[a]==a)
	return a;
	else return f[a]=find(f[a]);
}
int main(){
	int n,m,k;
	cin>>n>>m>>k;   //输入n、m、k，没啥好讲的
	for(int i=1;i<=n;i++)   
	f[i]=i;  //并查集数组初始化，每个节点的祖宗一开始是它自己
	for(int i=1;i<=m;i++)
	cin>>a[i].s>>a[i].e>>a[i].w;  //输入图的信息
	sort(a+1,a+1+m,cmp);   //快活的按权值排个序
   int cnt=0,sum=0;  //cnt是已经选中的边数，sum是最终要输出的最小权值
	for(int i=1;i<=m;i++){   //m条边，循环m次
		if(find(a[i].s)!=find(a[i].e)){ //如果俩节点的祖宗不相等（也就是不是回路），就可以加进去
			f[find(a[i].s)]=find(a[i].e); //把它俩合并成一个祖宗
			sum+=a[i].w;    //更新最小费用
			cnt++; //边数+1
		}
		if(cnt>=n-k)  //边数到达（n-k）条边，任务完成，break
		break;
	}
	if(cnt>=n-k)   //如果选了n-k条边，可以搞最小生成树
	cout<<sum;  //输出最小权值
	else cout<<"No Answer";  //要不然选了m条边还都搞不好，不能构成最小生成树
	return 0;  //终于完事了
} 
```
The End ......

and Happy New Year!


---

## 作者：Drifterming (赞：125)

解释里有很多废话。

luogu自动缩进，然后我又手打了一遍空格。


/\*
有一句话说的是 如果n个点被n-1条边连接的话，这一定是棵树。

那么：

连的边数       得到的树的个数

n-1                        1

n-2                        2

n-3                        3

...                          ...

n-k                        k

所以我们如果想要连出k棵树，就需要连n-k条边。


题目要求用n朵云连出k个棉花糖。

因为每个棉花糖都是连通的，

那么每个棉花糖就相当于是一棵树。

就是说要用n个节点连出k棵树。

也就是说要用n-k条边连出k棵树。

也就是说要花费连出n-k条边的代价。

既然一定要花费连出n-k条边的代价，

那么当然要选择代价最小的边连起来。

所以给每条可以连的边按代价从小到大排个序，

然后连n-k条边造k个最小生成树就可以了。

如果给的关系数m小于需要连的边数（n-k），是一定连不出k个树来的，因为m个关系只能连m条边。

\*/






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 1005
using namespace std;
int n,m,k,x,y,l,sum,ans;
int fa[N];
struct Edge
{
    int u,v,w;
    bool operator <(Edge a) const    //重置运算符的函数写在里面的话必须加const
    {
        return w<a.w;
    }
}edge[N*10];
/*bool operator <(Edge a,Edge b)    //重置运算符的函数写在外面的话不能加const
{
        return a.w<b.w;
}*/
int find(int x)
{
    return fa[x]==x?fa[x]:fa[x]=find(fa[x]);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
    }
    sort(edge+1,edge+m+1);    //按代价升序排列 
    for(int i=1;i<=m;i++)
    {
        int fx=find(edge[i].u),fy=find(edge[i].v);
        if(fx!=fy)        //如果这两个点不在同一棵树中 
        {
            fa[fx]=fy;
            sum++;        //连一条边，让它们合并成为一棵树 
            ans+=edge[i].w;        //加上合并的代价 
        }
        if(sum==n-k)        //已经连好了k棵树 
        {
            printf("%d",ans);
            return 0;
        }
    }
    puts("No Answer");    //不可能连好 
    return 0;
}
```

---

## 作者：Floating__Dream (赞：31)

连接一条边----连通块数量减一
k个连通块-----连（n-k）边
运用kruskal算法的思想：每次连可以连的边中代价最小的 （贪心）
使用 并查集维护 
```cpp

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
using namespace std;
int n,k,m;
int fa[1000050];
struct node {
	int x;
	int y;
	int l;
} a[1000005];
int cmp( const void *a , const void *b ) {
	struct node *c = (node *)a;
	struct node *d = (node *)b;
	return c->l - d->l;
}
int find(int x)
{
	if(x!=fa[x])
	fa[x]=find(fa[x]);
	return fa[x];
}
void work(int x,int y)
{
	x=find(x);
	y=find(y);
	if(x==y)
	return;
	fa[x]=y;
}
int main() {
	cin>>n>>m>>k;
	for(int i=0; i<m; i++) {
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].l);
	}
	qsort(a,m,sizeof(a[0]),cmp);
	for(int i=1;i<=n;i++)
	fa[i]=i;
	int num=n-k;
	int ans=0;
	for(int i=0;i<m;i++)
	{
		if(num==0)
		break;
		int aaa=find(a[i].x);
		int wzx=find(a[i].y);
		if(aaa!=wzx)
		{
			work(a[i].x,a[i].y);
			ans+=a[i].l;
			num--;
		}
	}
	if(num)
	cout<<"No Answer"<<endl;
	else
	cout<<ans<<endl;
}
```

---

## 作者：soler (赞：20)

#查集

- n个点 m条边    连成k个树的最小代价

- 若k为1    则连成一棵MST    跑一次kruskal   n-1次连边

- 若 k为2    为最后的图必须为  两颗MST      n-2次连边

- 同理   连成k个mst     进行 n-k次连边  若进行者n-k次操作中    没有了边    （即cpp中的 h<m)  直接输出 No Answer



```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
int n,m,k,ans;
int fa[1111];

struct node {
    int u,v,w;
}bian[11111];
int comp(node a,node b)
{
    return a.w<b.w;
}
int father(int x)
{
    if(fa[x]==x) return x;
    return fa[x]=father(fa[x]);
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        bian[i].u=x;
        bian[i].v=y;
        bian[i].w=z;
        
    }
    for(int i=1;i<=n;i++)
        fa[i]=i;
    sort(bian+1,bian+1+m,comp);
    int h=1;
    int js=1;
    while(js<=n-k)
    {
        if(h>m)
        {
            cout<<"No Answer"<<endl;
            return 0;
        }
        int x=bian[h].u,y=bian[h].v,w=bian[h].w;
        int fx=father(x),fy=father(y);
        if(fx!=fy)
        {
            js++;
            fa[fx]=fy;
            ans+=w;
        }
        h++;
    }
    if(js)
    cout<<ans<<endl;
    
}
```

---

## 作者：noip (赞：18)

就是一个生成树嘛

等到生成了有k个树的森林时退出

也就是把n - 1改为n - k然后用kruskal









    
    
    
```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
using namespace std;
long long n , m , k;
long long i , j;
long long now;
long long ans;
struct link
{
       long long x , y , cost;
};
int cmp( link a , link b )
{
    if( a.cost < b.cost )
        return 1;
    return 0;
}
int pre[ 10000 + 10 ];
link a[ 10000 + 10 ];
int find( int x )
{
    if( pre[x] == x )
        return x;
    int a = x;
    x = find( pre[x] );
    pre[a] = x;
    return x;
}
void merge( long long x , long long y )
{
    pre[ find( x ) ] = find( y );
    return;
}
int main()
{
    scanf( "%lld %lld %lld" , &n , &m , &k );
    if( k > n || n - m > k )
    {
        printf( "No Answer\n" );
        return 0;
    }
    for( i = 1 ; i <= n ; i++ )
         pre[i] = i;
    for( i = 0 ; i < m ; i++ )
         scanf( "%lld %lld %lld" , &a[i].x , &a[i].y , &a[i].cost );
    sort( a , a + m , cmp );
    now = n;
    i = 0;
    ans = 0;
    while( now > k )
    {
           if( i >= m )
           {
               printf( "No Answer\n" );
               return 0;
           }
           if( find( a[i].x ) != find( a[i].y ) )
           {
               merge( a[i].x , a[i].y );
               now--;
               ans += a[i].cost;
           }
           i++;
    }
    printf( "%lld\n" , ans );
    return 0;
}
```

---

## 作者：YWY_wys (赞：16)

#生成树

- **题解**：

首先题目要求一个图生成k个树，使得花费最小求最小花费，那么很容易想到最小生成树，可是题目要求我们建k个树啊？

怎么办呢？

我们仔细想一下kruskal的过程，其实每一步建边都保证了当前的所有生成树花费最小。每次合并都少1棵生成树，那么我们只需在kruskal的过程中记录当前的生成树数量num，每次合并时num--，更新花费即可，**注意** 一开始是每个点都是有1棵生成树，故初始生成树数量为n

我们在梳理一遍思路：

1. 读入

2. kruskal（写法见代码）

3. 输出

- **code:**

```cpp
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    const int maxn=1005;
    const int maxm=10005; 
    struct e{// 边 
        int u,v,w;
        bool operator <(e a) { return w<a.w; }
    }edge[maxm];
    
    int n,m,k,cnt;
    int fa[maxn]; //并查集 
    int find(int x){
        if(x==fa[x]) return x;
        fa[x]=find(fa[x]);
        return fa[x];
    }
    int kruskal(){// kruskal建最小生成树 
        int res=0,nft=n;
        for(int i=1;i<=n;i++) fa[i]=i;// 隶属集合初始化 
        sort(edge+1,edge+m+1); 
        for(int i=1;i<=m;i++){
            if(nft<=k) break;// 是否已经建了k棵最小生成树 ，如果n<=k 则无法连成k个棉花糖 
            int fu=find(edge[i].u);//(为什么是最小生成树,可能有的人不清楚，日后我将在博客里专门
            int fv=find(edge[i].v);//         写一点关于最小生成树的东西,有兴趣的同学可以去看看） 
            if(fu!=fv){
                fa[fu]=fv;
                res+=edge[i].w;
                nft--;
            }
        }
        if(nft==k) return res;// 能建成，返回花费，否则返回-1 
        return -1;
    }
    int main(){
        int u,v,w,ans;
        scanf("%d%d%d",&n,&m,&k);
        for(int i=1;i<=m;i++) 
            scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
        ans=kruskal();
        if(ans==-1) puts("No Answer");else printf("%d",ans);
    }
```

---

## 作者：Wenxiang_MCL (赞：13)

真的没有人用Prim算法吗？

我的思路好像有点神奇，但是效率也挺高的(4ms)

首先DFS确定联通块，然后计算有几个联通块，如果cnt大于k则判断No Answer（不过好像没有No Answer的数据）

接着枚举每个联通块，在每个联通块上建一棵最小生成树；

剩下的就是砍掉k - cnt - 1条边；可以很容易的得到我们要砍掉前k - cnt - 1条最大边；

至于如何找最大边，我用了优先队列来将边有存储起来，最后将k - cnt - 1条边推出队列即可

代码（好像有点长）:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
struct EDGE{
    int out,len,nxt;
}edge[20005];
struct cmp1{
    bool operator () (EDGE &a,EDGE &b){
        return a.len > b.len;
    }
};
struct cmp2{
    bool operator () (EDGE &a,EDGE &b){
        return a.len < b.len;
    }
};
priority_queue <int,vector<EDGE>,cmp1> que;
priority_queue <int,vector<EDGE>,cmp2> Ans;
int n,m,d,tot,ans,cnt;
int head[1005],marks[1005],mark[1005],dis[1005],vis[1005];
void dfs(int pos);
void prim(int sta);
void dfs(int pos){
    marks[pos] = cnt;
    for(int i = head[pos];i != 0;i = edge[i].nxt){
        if(marks[edge[i].out] != 0) continue;
        dfs(edge[i].out);
    }
}
void prim(int sta){
    memset(dis,127,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[sta] = 0;
    EDGE cc;
    cc.out = sta,cc.len = 0;
    que.push(cc);
    while(!que.empty()){
        int u = que.top().out;//当然使用优先队列来求生成树啦 nlogn 
        que.pop();
        if(vis[u] == 1) continue;
        vis[u] = 1;
        for(int i = head[u];i != 0;i = edge[i].nxt){
            int v = edge[i].out,len = edge[i].len;
            if(vis[v] == 0 && dis[v] > len) {
                dis[v] = len;
                que.push((EDGE){v,dis[v],0});
            }
        }
    }
    for(int i = 1;i <= n;i ++){
        if(marks[i] == marks[sta]){
            ans += dis[i];
            Ans.push((EDGE){0,dis[i],0});
        }
```
}//将所有边入队
```cpp
}
int main (){
    freopen("1195.in","r",stdin);
    freopen("1195.out","w",stdout);
    scanf("%d%d%d",&n,&m,&d);
    for(int i = 1;i <= m;i ++){
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        edge[++ tot].nxt = head[a],head[a] = tot,edge[tot].out = b,edge[tot].len = c;
        edge[++ tot].nxt = head[b],head[b] = tot,edge[tot].out = a,edge[tot].len = c;
    }
    for(int i = 1;i <= n;i ++){
        if(marks[i] != 0) continue;
        cnt ++;
        dfs(i);
    }//DFS求联通块个数，顺便把每个联通块标号为cnt 
    if(cnt > d){
        printf("No Answer");
        return 0;
```
}//多余联通块数量则直接退出
```cpp
    for(int i = 1;i <= n;i ++){
        if(mark[marks[i]] == 0){//判断当前联通块是否已建树 
            prim(i);
            mark[marks[i]] = 1;
        }
    }//prim算法求最小生成树 
    for(int i = 1;i <= d - cnt;i ++){
        if(!Ans.empty()){//把最大的几条边推出 
            ans -= Ans.top().len;
            Ans.pop();
        }
        else{//当发现无边可出却还不能连成k个联通块时，退出 
            printf("No Answer");
            return 0;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：xzlhxc_ed (赞：8)

[博客内食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p1195)     
[题目链接（洛谷P1195）](https://www.luogu.org/problem/P1195)    
**前置芝士：[最小生成树](https://www.luogu.org/problem/P3366)，[并查集](https://www.luogu.org/problem/P3367)**     
**感觉证明部分有点奇怪，有疑问及时向笔者私信或评论。**

------------
## ①题意
给你$n$个点，$m$条带权有向边，选择一些边，将这$n$点连为$k$个联通块后，使得边权和最小。

 _很多人的解法是最小生成树，但很少说清楚为什么的。知其然更应知其所以然。_    
## ②做法
看一眼题目，确实很像$MST$（最小生成树），但我先想到了贪心。      
我们可以从这几个引理开始思考贪心策略：
1. 总代价最小，则每一条边尽可能小。
1. 连接一条边最多减少一个联通块（易得，可以用反证法证一证）。

那么贪心策略就出来了：

将边按照边权从小到大排序，考虑每一条边，如果加入这条边能使联通块个数减一，那就选择这条边。当选择的边数达到$n-k$时（减少了$n-k$个联通块，剩下k个联通块）停止，输出解。否则无解。

**用个并查集判断2个点是否在同一个联通块内，如果是，那么连了这条边也没用。**
## ③证明
设用贪心算法得出的解为$ans_1$ 。    
假设存在另一个方案使得解$ans_2<ans_1$ 。    
这一方案至少有一条边$edge$与贪心策略不同。     
设这条边连接$i,j$ 2个点，代价为$x$。

若在贪心策略中$i,j$不连通，则说明在$edge$出现之前已经存在另一种方案使得联通块减少1了，由于边是从小到大排序的，将这个方案换成贪心策略不会让结果变差。

若在贪心策略中$i,j$联通，则说明在$edge$出现前已经存在一种连边方式使得$i,j$联通，同理，换成贪心策略不会使结果变差。
 
## ④最小生成树
算法实现的过程很像$Kruscal$的过程，那它与$MST$有什么关系吗？    

对于$x$个点的联通块来说，只需要$x-1$条边就可以联通，贪心策略也保证了这一点，那么这就是一颗树。让这$k$个联通块的总权值最小，即让每一个联通块权值和最小，这就是$k$个最小生成树。当$k=1$时，就是原本的最小生成树问题了。
## ⑤AC！
代码不给了，都是模板。   
觉得好就点个赞呗$QAQ$。

---

## 作者：风翮雨翎 (赞：7)

这一题还算是很裸的最小生成树了，蒟蒻用的kruskal算法，AC。
输出"No Answer"的只有需要生成的棉花糖数大于云彩原料总数的情况，在kruskal开始之前特判一下就好啦！
详见代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>//C++快排调用该函数
using namespace std;
int father[10000+10],m,n,k,v,g,h,num=0,sum,payment=0;//sum记录连接至目前情况阔以做成的最多棉花糖数， payment记录花费。
struct clouds
{
	int f,t,l;
}e[10000+10];//结构体表路径。
int find(int x)
{
	if(father[x]!=x)
		father[x]=find(father[x]);
	return father[x];
}//优化的查找祖宗函数，判断两点是否联通
void uni(int q,int w)
{
	father[q]=w;
}//合并函数使祖宗相同
int cmp(const clouds&a,const clouds&b)
{
	return a.l<b.l;
}自定义结构体快排函数，按边权值从小到大排，可以保证MIN
void add(int x,int y,int z)
{
	num++;
	e[num].f=x;
	e[num].t=y;
	e[num].l=z;
}//将起点终点边权录入结构体的添加函数
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	if(k>n)
	{
		printf("No Answer");
		return 0;
	}//先行判断需要糖数与现有云朵数，若糖多于云，直接“No Answer”结束。
	else
	{
	for(int i=1;i<=n;i++)
		father[i]=i;//并查集初始化，每朵云的祖宗都是自己
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&v,&g,&h);
		add(v,g,h);
	}//路径录入结构体
	sort(e+1,e+m+1,cmp);//按边权排序
	sum=n;//开始之前，可以做的棉花糖最多朵数等于云朵数
	if(sum==k)
    {
       printf("0");
       return 0;
     }//恰好相等，输出0
    for(int i=1;i<=m;i++)
	{
		int uu=find(e[i].f);
		int ii=find(e[i].t);
		if(uu!=ii)
		{
			uni(uu,ii);
			sum--;
			payment+=e[i].l;
		}//从边权最小的路径开始找，若起点终点不连通，合并，可做成棉花糖数--，支出加上联通该两点的花费
	    if(sum==k)
           break;//现在的云朵数等于要的糖数啦！可以结束了哟
    }
    }
	printf("%d",payment);//输出
	return 0;
}```
蒟蒻要去吃棉花糖了，祝AC
撒花

---

## 作者：Cxs3 (赞：5)

题目链接：https://www.luogu.org/problemnew/show/P1195  

---

## 题目分析
题目大意是：一个有$n$个点的图可以连$m$条有边权的边，问把这个图（通过连边的方式）分成$k$个连通块的最小花费。  
($1≤n≤1000,1≤m≤10000,1≤k≤10$) 

由“最小花费”可知此题基于一个贪心的思想，自然想到了$Prim$和$Kruskal$算法，再看数据范围，排除了$Prim$（$O(nm)$），留下了$O(mlogm)$的$Kruskal$.  

判断一条边的两个端点是否在一连通块中的操作用并查集即可。

那么加边的边界呢？还是$(n-1)$条边吗？  
答案是否。我们不妨先打个表：  
| 加边数 | 连通块数 |  
| $n-1$ | $1$ |  
| $n-2$ | $2$ |  
| $n-3$ | $3$ |  
.  
.  
.  
| $n-k$ | $k$ |  
所以要分成$k$个连通块要加$(n-k)$条边，这就是边界了。  

每次加边后就把答案加上此边的边权，最后输出。  

---

## 代码实现
部分代码（头文件、宏定义略去）：  
```cpp
struct node
{
	int u,v,c;
}a[M];//记录可连边的结构体
int n,m,k;
int fa[N],cnt,ans;//并查集；已加边数；答案
bool cmp(node x,node y){return x.c<y.c;}//从小到大
int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}
bool kruskal()
{
	int i,x,y;
	for(i=1;i<=m;i++)//枚举m条边 
	{
	  x=find(a[i].u); y=find(a[i].v);
	  if(x!=y)//若不在一个联通块中 
      {
      	fa[x]=y;//加边（合并并查集） 
      	cnt++;//已加边数加1 
      	ans+=a[i].c;//更新答案 
	  }
	  if(cnt==(n-k)){cout<<ans<<endl; return 1;}//边界，如果已经加了（n-k）条边，输出并退出函数 
	}
    return 0;
}
int main()
{
	int i;
	cin>>n>>m>>k;
	for(i=1;i<=m;i++) cin>>a[i].u>>a[i].v>>a[i].c;
	for(i=1;i<=n;i++) fa[i]=i;//并查集初始化 
	sort(a+1,a+m+1,cmp);//按边权排序每条边 
	if(!kruskal()) cout<<"No Answer"<<endl;
	return 0;
}  
```


---

## 作者：USER113968 (赞：4)

> 这道题目的简明意思是，给定一张图，要求你将它分为互不相连的$k$个子图。
>
> 每一条边都有一个权值，要求权值之和最小。
>
> 如果无解，输出`No Answer`

那么我们应该怎么办？

毫无疑问，这道题目考察的是最小生成树。而最小生成树有两种算法，`prim`以及`kruskal`。

我们先不管用哪一个算法，来分析一下步骤：

1. 由于要求边权值和最小，我们应该选用边权尽量小的边，所以我们将边从小到大排序。
2. 你想，我们要将$n$个点分裂成$k$个子图，那么就是说要用$n$个点连成$k$棵树（为什么是树？因为树中没有环，就没有多余的边，我们要让边权值和最小，就不应选用无用的边）。
3. 如果说我们要连$k$棵树，就得连接$n-k$条边。但是不能循环$n-k$次，而要循环$m$次，因为如果一条边是多余的，它不算进最小生成树，但是他在循环中占了一个位置，可能导致一些有用的边没有被找到。我们应该设置一个变量$cnt$，表示已经选用了多少条有效的边。当$cnt=n-k$时，就$break$。
4. 最后输出权值和。

------

看看这些步骤，非常像$kruskal$算法。没错，就是它。

代码就放在这里了：

```c++
#include<iostream>
#include<stdio.h>
#include<algorithm>
using namespace std;
class Union_find_set//并查集
{
	protected:
		int f[1001];
	public:
		Union_find_set()
		{
			register int i;
			for(i=0;i<1001;++i)
				f[i]=i;
		}
		~Union_find_set()
		{
		}
		int find(int x)
		{
			if(f[x]==x)
				return x;
			f[x]=find(f[x]);
			return f[x];
		}
		void merge(int x,int y)
		{
			int a=find(x);
			int b=find(y);
			if(a==b)
				return;
			f[a]=b;
		}
		bool same(int x,int y)
		{
			return (find(x)==find(y));
		}
};
struct Edge
{
	int from,to,len;
};
bool cmp(Edge x,Edge y)
{
	return x.len<y.len;
}
Edge edge[10001];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	register int i;
	Union_find_set ufs;
	for(i=1;i<=m;++i)
		scanf("%d%d%d",&edge[i].from,&edge[i].to,&edge[i].len);//存储边的信息
	sort(edge+1,edge+1+m,cmp);//按照边权排序
	int answer=0;//累加边权
	int cnt=0;//已经选用的有效边数量
	for(i=1;i<=m;++i)
	{
		if(cnt==n-k)//已经OK了
			break;
		if(ufs.same(edge[i].from,edge[i].to))//这条边是有效的，也就是说，不会形成环
			continue;
		answer+=edge[i].len;//累加答案
		//printf("Edge%d:from %d to %d len=%d\n",i,edge[i].from,edge[i].to,edge[i].len);
		++cnt;
		ufs.merge(edge[i].from,edge[i].to);//并查集·合并
	}
	if(cnt!=n-k)//无法找出n-k条有效边
		printf("No Answer");
	else
		printf("%d",answer);
	return 0;
}
```

---

## 作者：云雾繁星 (赞：2)

1.由于是有权值的一个图，所以可以用并查集来实现。由于要算出最小的和，所以先进行一次排序，将权值最小的边放在队首。由于要分成K份，总数为N，所以用一个计数器（N–）。如果N的大小恰好等于K时，说明已经分成了K份，剩下的没在并查集里的都是权值大的。

2.代码

```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
inline int read()//快读，相当于cin，大家可以忽略~ 
{
    int p,data=0;
    char ch=0;
    while((ch!='-')&&ch<'0'||ch>'9') ch=getchar();
    if(ch=='-')
    {
        p=-1;
        ch=getchar();
    }
    else
    {
         p=1;
    } 
    while(ch>='0'&&ch<='9')
    {
     data=data*10+ch-'0';
     ch=getchar();
    }     
    return data*p;
}
int pre[1100];//用来存储i的祖父是谁 
struct value
{
    int j,k,l;
}val[11000];
int n,m,k;
int a,b,c;
int cmp(value x,value y)
{
    return x.l<y.l;
}
int tot=0;
int find(int q)//一个搜索操作，用来找出祖父是谁。
{
    if(pre[q]==q) return q;
    pre[q]=find(pre[q]);//优化时间复杂度 
    return pre[q];
} 
int main()
{
    n=read();
    m=read();
    k=read();
    for(int i=1;i<=n;i++)
    {
        pre[i]=i;//并查集の初始化。 
    }
    for(int i=1;i<=m;i++)
    {
        a=read();
        b=read();
        c=read();
        val[i].j=a;
        val[i].k=b;
        val[i].l=c;//快读233，第一次用。 
    }
    sort(val+1,val+m+1,cmp);//将权值进行排序。 
    for(int i=1;i<=m;i++)
    {
        if(find(val[i].j)!=find(val[i].k))//如果祖父不是同一个，那么将其加入同一个集， 
        {
            pre[find(val[i].j)]=find(val[i].k);//使他们的祖父成为同一个 
            n--;//萌萌的充当计数君 
            tot+=val[i].l;
        }
        if(n==k)//如果计数君等于k了，那么说明已经分成了k种，已经找到了最小值， 那么可以结束算法了 
        {
            cout<<tot;
            return 0;
        }
    }
    cout<<"No Answer";//如果无法成为K组，输出NO ANSWER 
    return 0;
}
```

---

## 作者：jins3599 (赞：2)

最小生成树裸题。

首先我们观察到，如果要想选出$k$个连通块的话，最优的一定是在它的最小生成树中的边进行选择。

我们可以先跑一次最小生成树，如果结果得到的连通块数量$tot$大于$k$的话一定是无解的。

若是小于$k$，那么我们仍需要$k-tot$个连通块，考虑到删去一条边可以多出一个连通块，我们可以每次贪心的删去最大的那个边，然后统计答案就可以了。

代码很简单。

$Code:$
```cpp
#include <bits/stdc++.h>

using namespace std;

int n , m , k , tot;

const int N = 10000 + 5;

struct Edge {
	int u , v , w;
	bool operator <(const Edge &a) const {
		return w < a.w;
	}
}e[N << 1];

int bin[N];
int find(int x) {
	if(bin[x] == x) return x;
	return bin[x] = find(bin[x]);
}

bool vis[N];
int sum = 0;

int main () {
	scanf("%d %d %d" , &n , &m , &k); tot = n;
	for(int i = 1 ; i <= n ; ++ i) bin[i] = i;
	for(int i = 1 ; i <= m ; ++ i) scanf("%d %d %d" , &e[i].u , &e[i].v , &e[i].w);
	sort(e + 1 , e + 1 + m);
	for(int i = 1 ; i <= m ; ++ i) {
		int u = e[i].u , v = e[i].v;
		int fu = find(u) , fv = find(v);
		if(fu != fv) {
			bin[fu] = fv;
			sum += e[i].w;
			vis[i] = 1; tot --;
		}
	}
	if(tot > k) {
		puts("No Answer"); return 0;
	} else {
		int need = k - tot;
		int cnt = 0;
		int ans = 0;
		for(int i = m ; i >= 1 ; -- i) {
			if(vis[i]) {
				if(cnt == need) break;
				cnt ++;
				ans += e[i].w;
				if(cnt == need) break;
			}
		}
		printf("%d\n" , sum - ans);
	}
	return 0;
}
```

---

## 作者：K2sen (赞：2)

# P1195
[传送门](https://www.luogu.org/problem/P1195)

### 大体题意：
就是给你$n$个点$m$条边， 然后让你把这几个点连成$k$个部分.

### 解题思路：
~~很容易就可以想到生成树~~(别问我怎么想到的).
因为最小生成树中有一个判断
```cpp
for (int i = 1; i <= m; ++i) {
		if (father(ka[i].x) != father(ka[i].y)){
			unionn(ka[i].x, ka[i].y);
			tot += ka[i].v;
			s++;
		}
		if (s == n - 1) break;//我在这里，如果这张图中已经加入了n-1条边，
	}//那就说明图已经可以联通了，然后如果去掉m条边的话，那就是把图分成了m个部分
	//那么我们可以利用这一点来用kruskal做这道题聊.
```

修改后的代码长这样：
```cpp
for (int i = 1; i <= m; ++i) {
		if (father(ka[i].x) != father(ka[i].y)){
			unionn(ka[i].x, ka[i].y);
			tot += ka[i].v;
			s++;
		}
		if (s == n - k) break;//k为分成多少个部分，自己想一下也很好想.
		//n-1条边可以把图刚刚好联通，n-k条边可以将图分成k个部分.
	}
```

### code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iomanip>

using namespace std;
int n, m, k, s, cnt, tot;
struct node {
	int x, y, v;
}ka[200001];
int fat[5001];

int read() {
	int s = 0, f = 0; char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

int father(int x) {
	if (fat[x] != x) fat[x] = father(fat[x]);//并查集用
	return fat[x];
}

void unionn(int x, int y) {//并查集用
	int fa = father(x);
	int fb = father(y);
	if (fa != fb) fat[fa] = fb;
}

bool cmp(node a, node b) {//sort用
	return a.v < b.v;
}

int main() {
	n = read(), m = read(), k = read();
	int x, y, d;
	for (int i = 1; i <= m; i++) {
		x = read(), y = read(), d = read();
		ka[++cnt].v = d;
		ka[cnt].x = x;
		ka[cnt].y = y;
	}
	for (int i = 1; i <= n; i++) fat[i] = i;//并查集用
	sort(ka + 1, ka + m + 1, cmp);
	for (int i = 1; i <= m; ++i) {//kruskal
		if (father(ka[i].x) != father(ka[i].y)){
			unionn(ka[i].x, ka[i].y);
			tot += ka[i].v;
			s++;
		}
		if (s == n - k) break;
	}
	printf("%d\n", tot);
}
```

---

## 作者：Paolo_Banchero (赞：2)

首先可以知道的是，k个棉花糖中有k-1个是单个的云，因为单个的云就是不要花费的，所以生成树就是在剩下的n-k+1朵云中产生，然后这n-k+1朵云最多用n-k+1-1条边连接是最优的，所以其实就是kruskal选出n-k+1-1条边的最小价值

然后就是一个裸的kruskal了，然后由于很久没打kruskal了，我竟然自作聪明的加了vis数组，然后光荣爆零，最后删去vis，只用并查集判断就瞬间AC了

    #include<cstdio>
    #include<cstring>
    #include<iostream>
    #include<algorithm>
    #include<cmath>
    #include<cstdlib>
    #define maxn 10005
    using namespace std;

    struct edge{
        int  u,v,w;
    }e[2*maxn];

    int n,m,k,pos,tot,ans;
    int head[maxn],fa[maxn];

    int read(){
        int xx=0,ff=1;char ch=getchar();
        while(ch<'0'||ch>'9'){if(ch=='-')ff=-1;ch=getchar();}
        while(ch>='0'&&ch<='9'){xx=xx*10+ch-'0';ch=getchar();}
        return xx*ff;
    }

    void adde(int u,int v,int w){
        e[++pos].u=u;
        e[pos].v=v;e[pos].w=w;
    }

    int comp(const void*a,const void*b){
        return (*(struct edge*)a).w>(*(struct edge*)b).w?1:-1;
    }

    int find_(int x){
        if(fa[x]==x)return fa[x];
        return fa[x]=find_(fa[x]);
    } 

    int main(){
        scanf("%d",&n);m=read();k=read();
        for(int i=1;i<=m;i++){
            int u,v,w;
            u=read();v=read();w=read();
            adde(u,v,w);
        }    
        if(k>n){
            printf("No Answer");return 0;
        }
        for(int o=1;o<=n;o++)
            fa[o]=o;
        qsort(e,m+1,sizeof(e[0]),comp);
        for(int i=1;i<=m;i++){
            int u=e[i].u,v=e[i].v;
            int fu=find_(u);int fv=find_(v);
            if(fu!=fv){
                fa[fu]=fv;
                tot++;vis[fv]=1;ans+=e[i].w;
            }
            if(tot>=n-k+1-1){
                printf("%d",ans);return 0;
            }
        }
        printf("No Answer");
    }

---

## 作者：嚯呀嚯呀 (赞：1)

简单的最小生成树（手动滑稽）

这道题目就是问怎么用最小的费用连成K个联通块

而最小生成树是用n-1条边最小费用的连成一个联通块

有相通之处哦

下面的大佬有的说建K个最小生成树

我的方法是先建一个最小生成树，然后删去k-1条边 一个最小生成树形成K个联通块了

贪心的我们肯定是删去最小生成树中最大的k-1条边

最小生成树的话用kruskal就可以了。就是把边权排序再用并查集

### **P党福利！！**
```
var
  point,a1,a2,que,tot,i,j,m,n,k,p:longint;
  father,ans,x,y,w:array[0..10005]of longint;
procedure qs(l,r:longint);//快排
var
  i,j,mid,a1:longint;
begin
  i:=l; j:=r;
  mid:=w[(l+r) div 2];
  repeat
    while w[i]<mid do inc(i);
    while w[j]>mid do dec(j);
    if not(i>j) then
      begin
        a1:=w[i]; w[i]:=w[j]; w[j]:=a1;
        a1:=x[i]; x[i]:=x[j]; x[j]:=a1;
        a1:=y[i]; y[i]:=y[j]; y[j]:=a1;
        inc(i); dec(j);
      end;
  until i>j;
  if i<r then qs(i,r);
  if l<j then qs(l,j);
end;
function find(t:longint):longint;//这里用了路径压缩
begin
  if father[t]=t then exit(t)
  else
    begin
      father[t]:=find(father[t]);
      find:=father[t];
    end;
end;
begin
  readln(n,m,k);
  for i:=1 to m do
    readln(x[i],y[i],w[i]);
  if k>n then//如果云不够连成K个棉花糖
    begin
      writeln('No Answer');
      exit;
    end;
  qs(1,m);//好羡慕你们C++啊
  for i:=1 to n do father[i]:=i;
  for i:=1 to m do
    begin
      a1:=find(x[i]); a2:=find(y[i]);
      if a1<>a2 then
        begin
          father[a1]:=a2;
          inc(tot); que:=que+w[i];//记录最小生成树的总权值
          ans[tot]:=w[i];//记录最小生成树种用了哪些边权
        end;
      if tot=n-1 then break;
    end;
  if k<>1 then
  for i:=n-1 downto 1 do
    begin
      que:=que-ans[i]; inc(point);
      if point=k-1 then break;
    end;
  writeln(que);
end.
```

---

## 作者：Dog_Two (赞：1)

看到题目描述很容易就能想到“最小生成树”。

于是我们的第一印象很可能被题目引导到“最小森林”的方向上。

但很快我们就发现了求“最小森林”的不合理性:在不确定森林里每棵树的具体情况（如高度、节点数等）的时候，可以存在指数爆炸的搭配方法。

再仔细想想，我们就可以想到一个简化方法——生成**一棵**最小生成树，并且保证其它所有的树都有且只有一个节点。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
    int u,v,w;
    bool operator <(edge n)const{
         return w<n.w;
    }
};
vector<edge>v;
int n,m,k;
int fa[1000+10];
int getfa(int a){return fa[a]==a?a:fa[a]=getfa(fa[a]);}
bool eql(int a,int b){return getfa(a)==getfa(b);}
void uni(int a,int b){fa[getfa(a)]=getfa(b);}
int main(){
    cin>>n>>m>>k;
    if(k>n){
        cout<<"No Answer\n";
        return 0;
    }
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1;i<=m;i++){
        register int fm,to,w;
        scanf("%d%d%d",&fm,&to,&w);
        v.push_back((edge){fm,to,w});
    }
    sort(v.begin(),v.end());
    int cnt=0,totfee=0;
    for(int i=0;i<v.size()&&cnt<n-k;i++){
        if(!eql(v[i].u,v[i].v)){
            uni(v[i].u,v[i].v);
            cnt++,totfee+=v[i].w;
        }
    }
    cout<<totfee;
    return 0;
}

```

---

## 作者：ghmgjf (赞：1)

首先这个题第一眼想到的是最小生成树，但他有k个树，那怎么办那？可以贪心一下。首先建图，将没有任何边得点的个数记录下来（kx），这些点自成一个集合，那么需要再建k-kx个树。

首先建一个最小生成树（共tail个边存入team【】中），那么建k-kx个树需要在最小生成树中拿走k-kx+1个边。因为要取最小花费，所以从最大的边减。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
#include<queue>
using namespace std;
int n,m,k,ta,f[100001],team[1000001],tail,kx,sum;
int exist[10001];
struct re
{
    int next,w,t,s,head;
}e[10001*4];
void build(int x,int y,int z)
{
    e[++ta].w=z;
    e[ta].t=y;
    e[ta].s=x;
    e[ta].next=e[x].head;
    e[x].head=ta;
}
bool cmp(re a,re b)
{
    return a.w<b.w;
}
int find(int x)
{
    if(f[x]==x) return x;
    return f[x]=find(f[x]);
}
void add(int a,int b)
{
    int ux,uy; ux=find(a); uy=find(b);
    f[ux]=uy;
}
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=m;++i)
    {
        int a,b,c;
        cin>>a>>b>>c;
        exist[a]=exist[b]=1;
        build(a,b,c);
        build(b,a,c);
    }
    for(int i=1;i<=n;++i)
    {
        f[i]=i;
        if(exist[i]==0)
        ++kx;
    }
    k-=kx;
    sort(e+1,e+ta+1,cmp);
    for(int i=1;i<=ta;++i)
    {
        if(find(e[i].s)!=find(e[i].t))
        {
            add(e[i].s,e[i].t);
            team[++tail]=i;
            sum+=e[i].w;
        }
    }
    for(int i=tail;i>(tail-k+1);--i)
    {
        sum-=e[team[i]].w;
    }
    if(n<(kx+k)||(kx+1)>k+kx)
    cout<<"No Answer";
    //如果点少于k或不在最小生成树中的点大于k则不成立。
    else
    cout<<sum;
    return 0;
}
```

---

## 作者：lych (赞：1)

一幕描述好像很复杂，其实就是进行n-k次合并，使得合并的代价最小

一看就想到了最小生成树的kruskal算法，每次进行一次集合的并操作，就把剩下的需要合并的次数减一。直到0的时候，就说明可以完成，退出算法并输出

具体思路见程序：

```cpp
var
  f:array[0..5000] of int64;
  a,b,c:array[0..100000] of int64;
  i,n,m,k:longint;
  ans:int64;
  bo:boolean;
procedure swap(var x,y:int64);
var t:int64;
begin t:=x; x:=y; y:=t; end;
procedure qsort(r,l:longint);
var i,j:longint;
    mid:int64;
begin
  i:=r; j:=l;
  mid:=c[random(j-i+1)+i];
  repeat
    while c[i]<mid do inc(i);
    while c[j]>mid do dec(j);
    if i<=j then
      begin
        swap(a[i],a[j]);
        swap(b[i],b[j]);
        swap(c[i],c[j]);
        inc(i); dec(j);
      end;
  until i>j;
  if i<l then qsort(i,l);
  if r<j then qsort(r,j);
end;//根据路径的长短由小到大快排
function getfather(x:int64):int64;
begin
  if f[x]=x then exit(x) else
    f[x]:=getfather(f[x]);
  exit(f[x]);
end;//并查集路径压缩
begin
  bo:=true;
  randomize;//随机化快排
  read(n,m,k);//读入
  k:=n-k;//求需要合并的步数
  for i:=1 to n do f[i]:=i;
  for i:=1 to m do read(a[i],b[i],c[i]);
  qsort(1,m);//从小到大排，以便后面的贪心选取
  for i:=1 to m do
    begin
      if getfather(a[i])<>getfather(b[i]) then
        begin
          dec(k);//需要的步数-1
          ans:=ans+c[i];//增加最少的代价
          f[getfather(a[i])]:=f[getfather(b[i])];//并集合
          if k=0 then begin bo:=false; break; end;//找到了就标记，并退出循环
        end;
    end;
  if bo then writeln('No Answer') else writeln(ans);//最后的输出
end.
```

---

## 作者：Suyun (赞：0)

题意：给出一个 $n$ 个点，$m$ 条边的无向图，求将图转化为为 $k$ 个生成树的最小代价。

将图转化为 $k$ 个生成树，需要连 $n - k$ 条边，所以将 Kruskal 的判断 `if (++cnt == n - 1)` 改为 `if (++cnt == n - k)`。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 1000;
const int MAX_M = 10000;
const int MAX_K = 10;

struct Edge {
	int u, v, w;
};

int N, M, K;
Edge edges[MAX_M + 1];

int p[MAX_N + 1];
int find(int x) {
	return p[x] == x ? x : p[x] = find(p[x]);
}

int main() {
	cin >> N >> M >> K;
	for (int i = 1; i <= M; ++i) {
		cin >> edges[i].u >> edges[i].v >> edges[i].w;
	}
	
	sort(edges + 1, edges + M + 1, [](Edge a, Edge b) { return a.w < b.w; });
	
	for (int i = 1; i <= N; ++i) {
		p[i] = i;
	}
	
	int cnt = 0, res = 0;
	for (int i = 1; i <= M; ++i) {
		Edge &e = edges[i];
		int pu = find(e.u), pv = find(e.v);
		if (pu != pv) {
			p[pu] = pv;
			res += e.w;
			if (++cnt == N - K) {
				cout << res << endl;
				exit(0);
			}
		}
	}
	
	cout << "No Answer" << endl;
}
```

---

## 作者：薛定谔的鱼 (赞：0)

挺裸的一道最小生成树了。果断Kruskal，跑得快，空间小。
代码如下，注解在行后面。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5000005;
int m,n,prt[maxn],ans=0,q;
struct edge{int x,y,z;}e[maxn];//伪前向星，因为下面要排序，所以用边没什么用其实
bool cmp(edge x,edge y){return x.z<y.z;}//结构体快排
int find(int x)//路径压缩并查集
{return prt[x]==x?x:prt[x]=find(prt[x]);}
void kruskal()
{
    int k=n;//k为联通快，也就是云朵的数量
    for(int i=1;i<=n;i++)prt[i]=i;//初始化并查集
    for(int i=1;i<=m;i++)//从头遍历最小的边权，把它加到树中
    {
        int fa=find(e[i].x);
        int fb=find(e[i].y);
        if(fa!=fb)
        {
            ans+=e[i].z;
            prt[fa]=fb;
            k--;//合并一次，联通快数量减少一个
            if(k==q)//当联通快数量等于所要求的数量
            break;//结束
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&q);
    if(n<q){printf("No Answer");return 0;}//如果云朵数量小于所需联通快数量，直接结束
    for(int i=1;i<=m;i++)
    scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].z);
    sort(e+1,e+m+1,cmp);
    kruskal();
    printf("%d\n",ans);
    return 0;
}
```
求过QAQ

---

## 作者：richardchen (赞：0)

没有人用vector?那我发一个用vector实现的Kruskai

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#define M 1000
using namespace std;
int n,m,x,y,l,k,fa[1005],mst,che;
struct Tokyo{
    int u,v,w;
};//存边的结构体
vector<Tokyo>g;//存边
typedef vector<Tokyo>::iterator ite;//重新给迭代器命名
bool operator <(const Tokyo &a,const Tokyo &b)//比较规则，从小到大排
{
    return a.w<b.w;
```
}//并查集函数
```cpp
int Find(int _x_)
{
    if(fa[_x_]!=_x_) fa[_x_]=Find(fa[_x_]);
    return fa[_x_];
}
void Union(int _x,int _y)
{
    int x_=Find(_x);
    int y_=Find(_y);
    if(x_!=y_) fa[y_]=x_;
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&l);
        g.push_back((Tokyo){x,y,l});//加边
    }
    for(int i=1;i<=n;i++) fa[i]=i;//初始化
    sort(g.begin(),g.end());//排序
    for(ite it=g.begin();it!=g.end();it++)
    {
        if(Find(it->u)!=Find(it->v))
        {
            Union(it->u,it->v);
            mst+=it->w;
            che++;
        }
        if(che==n-k)
        {
            printf("%d",mst);
            return 0;
        }
    }
    printf("No Answer");
    return 0;
}
```

---

## 作者：IceWa (赞：0)

说一个比较直观的做法...

先找出图上所有的连通子图；在每个子图里各跑一遍kruskal；然后根据子图的个数判断是否有解以及需要删边。


### 过程如下


1. 无向图，直接dfs求出每个连通块的大小N\_cc[i]以及总个数tot。注意一边搜索一边转存边


2. 判断tot是否大于k。如果大于，输出No Answer，否则开始Kruskal


3. 如果tot<k，意味着，需要剪断一些树边。为了保证代价和尽可能的小，我们sort一遍树上的边，从大往小删，显然共需删除k-tot条边


复杂度也是O(M)的。常数略大，不过已经足以a掉此题了。。。各变量作用。。。见代码吧。。。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100050
int n,m,k,cnt,x,y,w,tot,euse,ans,sum;//sum已经做完的点数；euse用于转存边时的计数；tot子图总数；
int head[10050],cc[10050],fa[10050],E_cc[10050],N_cc[10050];//E_cc第i个分量的总边数；N_cc第i个分量总点数;
int tree[MAXN],tr_cnt;
int zz;
struct Edge{
    int from,to,next,val;
}e[MAXN],val[MAXN];//val顺序存储每个分量的边便于sort; 
void addEdge(int u,int v,int w){
    e[++cnt].from=u;
    e[cnt].to=v;
    e[cnt].val=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}
bool cmp(Edge a,Edge b){
    return a.val<b.val;
}
bool cmpp(int a,int b){
    return a>b;
}
void dfs(int x){
    cc[x]=tot;
    N_cc[tot]++;
    for(int i=head[x];i;i=e[i].next){
        val[++euse].val=e[i].val;
        val[euse].from=e[i].from;
        val[euse].to=e[i].to;
        E_cc[tot]++;
        if(!cc[e[i].to])
            dfs(e[i].to);
    }
}
int find(int x){
    if(fa[x]==x)    return x;
    return fa[x]=find(fa[x]);
}
void Kruskal(int c){
    if(N_cc[c]==1){
        return;
    }
    int l=1+sum,r=l+E_cc[c];
    sort(val+l,val+r,cmp);
    for(int i=l;i<=r;i++){
        x=find(val[i].from),y=find(val[i].to);
        if(x!=y){
            ans+=val[i].val;
            fa[x]=y;
            tree[++tr_cnt]=val[i].val;
            zz++;//zz记录Kruskal用了多少条边
        }
    }
    sum+=E_cc[c];
}
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&w);
        addEdge(x,y,w),addEdge(y,x,w);
    }
    for(int i=1;i<=n;i++)
        if(cc[i]==0){
            tot++;
            dfs(i);
        }
    if(tot>k)    printf("No Answer");
    else{
        for(int i=1;i<=n;i++)
            fa[i]=i;
        for(int i=1;i<=tot;i++)
            Kruskal(i);//分别对tot个子图做生成树；
        if(tot<k){
            int need=k-tot;
            sort(tree+1,tree+zz+1,cmpp);
            for(int i=1;i<=zz;i++)
                printf("%d:",tree[i]);
            printf("\n***********\n");
            for(int i=1;i<=need;i++)
                ans-=tree[i];
        }
        printf("%d",ans);
    }
}
```

---

## 作者：陈新月 (赞：0)

思路：

1.这道题题意是让你在求最小生成树的时候特判，判断什么时候停止粘合节点

2.于题意，我们便在普通的kruskal算法做点小修改，直接在制造最小生成树的时候判断节点数与K值得关系即可

下面给出代码及部分注释







    

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int en,f[10009],m,n,siz,k;
struct edge{
    int s,e,d;
}ed[10009];
void add_edge(int s,int e,int d){
    en++;
    ed[en].s = s;ed[en].e = e; ed[en].d = d; 
}
bool operator < (const edge &a,const edge &b){
    return a.d < b.d;
}
int getf(int now){
    if(f[now] == now)return now;
    else return f[now] = getf(f[now]);
}
int kruskal(){
    sort(ed+1,ed+1+m);
    for(int a = 1; a <= n;a++)f[a] = a;
    int ans = 0;
    siz = n;
    for(int i = 1; i <= m; i++){
        int f1 = getf(ed[i].s);
        int f2 = getf(ed[i].e);
        if(f1 != f2){
            ans += ed[i].d;
            siz--;                 //两节点粘合之后棉花糖数量减一 
            f[f1] = f2;
        }
        if(siz == k)return ans;   //符合答案要求，可以组成K个棉花糖 ，则返回答案
    }
    return -1;                      //如果之前没有直接返回答案，则说明不能组成K个棉花糖则返回-1 
}
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i = 1; i <= m; i++){
        int u,v,d;
        scanf("%d%d%d",&u,&v,&d);
        add_edge(u,v,d);
    }
    int ans = kruskal();
    if(ans == -1)printf("No Answer\n");  //无答案 
    else printf("%d\n",ans);            //输出 
    return 0;
}

```

---

## 作者：shijunfeng00 (赞：0)

仿照最小生成树的Kruskal算法...

先把边按照权值从小到大排序

然后开始种树,直到还剩下K-1个孤立点

加上这棵树,图被分成K部分,符合题目要求

代码如下,基本上可以套用最小生成树的算法

改几句话就可以了,

加输出No Answer

    
    counter==n-1 改为 counter==n-k

#include<bits/stdc++.h>

class side

{
public:

```cpp
    int u,v,w;          //起点 终点 权值
}e[100000];     
int pre[100000];  
int find(int x)
{
    int r=x;
    while(r!=pre[r])r=pre[r];     // 路径压缩 并查集
    return r;
}
bool join(int x,int y)
{
    int fx=find(x),fy=find(y);
    if(fx!=fy)
    {
        pre[fx]=fy;
        return true;
    }
    return false;
}
bool cmp(side a,side b){return(a.w<b.w);}     //比较函数
using namespace std;
int main()
{
    int static n,m,k,counter,sum;        //用static不用显式初始化为0...
    cin>>n>>m>>k;
    for(int register i=1;i<=m;i++)         
        cin>>e[i].u>>e[i].v>>e[i].w;
    for(int register i=1;i<=n;i++)
        pre[i]=i;                                          //初始化
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;i++)
    {
        if(join(e[i].u,e[i].v))
        {
            counter++;
            sum+=e[i].w;
        }
        if(counter==n-k)
        {
            cout<<sum;
            return 0;
        }
    }
    cout<<"No Answer";        
}
```

---

## 作者：Niko (赞：0)

边权大的边不连就不产生代价

那么就是用kruskal算法把n-k个最小的合并，剩下k-1个独立（边权较大的）

那么把k置为n-k，每次合并k--

要是到最后k>0的话说明无法连城k个棉花糖

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct node{
    int u,v,w;
    bool operator < (const node & a)const{
        return w < a.w;
    }
}edge[100005];int head[1003];
int n,m,k;int num=0;
void Add_edge(int x,int y,int z)
{
    edge[++num].u=x;edge[num].v=y;edge[num].w=z;
}
int father[1003];
int find (int x)
{
    if(father[x]!=x)father[x]=find(father[x]);
    return father[x];
}
void unionn(int x,int y){father[x]=y;}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    int a,b,c;for(int i=1;i<=n;i++)father[i]=i;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        Add_edge(a,b,c);Add_edge(b,a,c);
    }
    k=n-k;
    int ans=0;
    sort(edge+1,edge+num+1);//把n-k个最小的合并，剩下k-1个独立（边权大的） 
    for(int i=1;i<=num;i++)
    {
        int u=edge[i].u,v=edge[i].v;
        int fu=find(u),fv=find(v);
        if(fu!=fv)
        {    
            ans+=edge[i].w;
            unionn(fu,fv);
            k--;
        }
        if(k==0)break;
    }
    if(k)puts("No Answer");
    else printf("%d\n",ans);
    return 0;
}
```

---

## 作者：circlegg (赞：0)

找最小代价相连为k个，如果是连成一个就是最小生成树，连成k个就直接再把最小生成树里最长的k-1个边删掉就行了。如果连完所有的边都不及k棵树就连不成了

20:30评测    44ms

···
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,k,f[1005],now,ans,head;
struct data{
    int u,v,w;
}e[10005],t[10005];
bool cmp(data a,data b){
    return a.w<b.w;
}
int get(int a){
    return a==f[a]?a:f[a]=get(f[a]);
}
bool merge(int a,int b){
    int fa=get(a);
    int fb=get(b);
    if(fa!=fb){
        f[fb]=fa;
        return 1;
    }
    return 0;
}
int main(){
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
    }
    sort(e+1,e+1+m,cmp);
    for(int i=1;i<=n;i++){
        f[i]=i;
    }
    for(int i=1;i<=m&&now<n-1;i++){
        if(merge(e[i].u,e[i].v)){
            t[++now]=e[i];//存下最小生成树里的边
        }
    }
    for(int i=1;i<=n;i++){
        if(f[i]==i){
            head++;
        }
    }
    if(head>k){//看能否够k棵
        printf("No Answer");
        return 0;
    }
    for(int i=1;i<=n-k;i++){//生成树有n-1条边，要删k-1条边，所以n-1-(k-1)==n-k
        ans+=t[i].w;
    }
    printf("%d\n",ans);
    return 0;
}
···
```

---

## 作者：PTC06 (赞：0)

并不难，感觉和3366难度差不多，只不过是要连成K个棉花糖而不是将N个点连起来。

Kruskal的思路主要是先以代价排序，然后用并查集判断两点是否连了起来，没有就连起来，把ans加上这两个点连接的代价，最后输出ans。

唯一注意的是最后的那条while应该写while (f<n-k) 而不是 while (f<n-1)。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,i,pre[10000],ans,f;
struct cloud
{
    int start;
    int end;
    int value;
} a[100000];
bool cmp(cloud x,cloud y)
{
    return x.value<y.value;
}
int sch(int x)
{
    if (pre[x]==x) return x;
    pre[x]=sch(pre[x]);
    return pre[x];
}
void join(int x,int y)
{
    pre[sch(x)]=sch(y);
}
int main()
{
    cin>>n>>m>>k;
    for (i=1;i<=n;i++) pre[i]=i;
    for (i=1;i<=m;i++)
    {
        cin>>a[i].start>>a[i].end>>a[i].value;
    }
    sort(a+1,a+m+1,cmp);
    i=0;
    while (f<n-k)
    {
        i++;
        if (sch(a[i].start)!=sch(a[i].end))
        {
            ans+=a[i].value;
            f++;
            join(a[i].start,a[i].end);
        }
    }
    cout<<ans;
}
```

---

## 作者：Kwork (赞：0)

根据题面我们可以知道这是最小生成树的变形。

用克鲁斯卡尔算法，不断的连边，更新答案，直到剩余云朵数量达到要求，输出解即可。

克鲁斯卡尔的具体证明请自行google。






```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
using namespace std;
const int maxn=1000+20,maxm=100000+20;
struct data{int u,v,w;};
data edge[maxm];
int n,m,k,ans=0,p[maxn];
void read(int &n){
    n=0;int f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    n=n*f;
    return;
}
void write(int n){
    if(n<0){
        putchar('-');
        n=0-n;
    }
    if(n>=10) write(n/10);
    putchar((n % 10)+'0');
    return;
}
bool cmp(const data &x,const data &y){
    return x.w<y.w;
}
int find(int x){
    return x==p[x]? x:p[x]=find(p[x]);
}
int main(){
    read(n);read(m);read(k);
    for(int i=1;i<=m;i++){
        read(edge[i].u);read(edge[i].v);read(edge[i].w);
    }
    sort(edge+1,edge+m+1,cmp);
    int tot=0;
    for(int i=1;i<=n;i++) p[i]=i;
    for(int i=1;i<=m;i++){
        int x=find(edge[i].u);
        int y=find(edge[i].v);
        if(x!=y){
            p[x]=y;
            ans+=edge[i].w;
            tot++;
        }
        if(tot==(n-k)) break;
    }
    write(ans);
    return 0;
}
```

---


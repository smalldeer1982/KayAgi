# [蓝桥杯 2025 省 Java B] 爆破

## 题目描述

小明正在参加一场爆破工作。人们在地面上放置了 $n$ 个爆炸魔法阵，第 $i$ 个魔法阵的圆心坐标为 $(x_i, y_i)$，半径为 $r_i$。如果两个魔法阵相交，则它们可以一起引爆；如果两个魔法阵不相交，则可以再使用一条魔法回路将它们的边缘连接起来。小明想知道最少需要布置总长度多长的魔法回路才能使得所有的魔法阵可以一起引爆？

## 说明/提示

### 样例说明

- 使用魔法回路连接第 $1$、$3$ 个魔法阵，长度为 $1$。
- 使用魔法回路连接第 $2$、$4$ 个魔法阵，长度为 $2\sqrt{5} - 3 = 1.47$。

总长度 $2.47$。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n \leq 500$。
- 对于 $100\%$ 的评测用例，$1\leq n \leq 5000$，$|x_i|, |y_i| \leq 2000$，$0 < r_i \leq 20$。

## 样例 #1

### 输入

```
4
0 0 1
2 0 2
-3 0 1
4 4 1```

### 输出

```
2.47```

# 题解

## 作者：weapons (赞：2)

## 这是一篇 C++ 的题解
### 题意
给你若干个圆，现在你需要用最小线段使它们互相连通，即每一圆都可以直接或间接到达。
### 思路
不难想出，这是典型的最小生成树问题。首先算出每两个圆心之间的直线距离减去它们的半径，就可以算出链接两圆的最小线段。注意，如果它们本身重叠或接触，则距离需要为零而不能为负数。再去跑裸的最小生成树板子就行了，详见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e7+5;
int n, len, fa[maxn];
struct Edg {
	int u, v;
	double w;
} edg[maxn>>2];//记录圆与圆的距离。
bool cmp(Edg a, Edg b) {
	return a.w < b.w;
}
int find(int x) {
	if (x != fa[x]) {
		return fa[x] = find(fa[x]);
	}
	return x;
}
int x[maxn>>2], y[maxn>>2], r[maxn>>2];//x横坐标，y纵坐标，r半径.
void read() {
	cin >> n;
	int cnt = 0;
	double ans = 0;
	for (int i = 1; i <= n; i++) {
		fa[i] = i;//注意初始化
	}
	for (int i = 1; i <= n; i++) {
		cin >> x[i] >> y[i] >> r[i];
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j < i; j++) {
			double w1=0;
			w1 = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]))-r[i]-r[j];//算出两点间的距离
			if(w1<0){
				w1=0;
			}//如果重叠，则距离为零。
			edg[++len] = {i, j, w1};
		}
	}
	sort(edg + 1, edg + len + 1, cmp);//裸的最小生成树板子。
	for (int i = 1; i <= len; i++) {
		int fr = edg[i].u, to = edg[i].v, rof = find(fr), ros = find(to);
		if (rof != ros) {
			fa[ros] = rof;
			ans += edg[i].w;
			cnt++;
		}
		if (cnt == n - 1) {
			printf("%.2lf",ans);//输出
			return;
		}
	}
}
int main() {
	read();
}
```

---

## 作者：ErgouTree (赞：2)

题目大意大概就是把圆形魔法阵视为图上的一个点，那么如果两个圆相离，就用边连接，计算最小魔法回路那就是构造最小生成树然后求边权，感觉用 prim 写舒服一些。  
详细过程和一些代码细节上的处理请看代码注释。
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) {
        new Solutions();
    }
}

class Solutions {
    private int n;

    private class cirlce implements Comparable<cirlce> {
        int x, y, r;

        public cirlce() {
        }

        public cirlce(int x, int y, int r) {
            this.x = x;
            this.y = y;
            this.r = r;
        }

        @Override
        public int compareTo(cirlce o) {
            return this.x - o.x;
        }
    }

    private cirlce[] cirlces = new cirlce[5005];

    private double Getdist(int u, int v) {
        return Math.sqrt((cirlces[u].x - cirlces[v].x) * (cirlces[u].x - cirlces[v].x) + (cirlces[u].y - cirlces[v].y) * (cirlces[u].y - cirlces[v].y));
    }

    private double prim() {
        boolean[] visited = new boolean[n];   // 标记每个顶点是否已经被加入到最小生成树中
        double[] dist = new double[n];   // 距离数组
        // 初始化
        Arrays.fill(visited, false);
        Arrays.fill(dist, Double.MAX_VALUE);
        // 选择0号为起点，并且设为距离0
        dist[0] = 0.0;
        double sum = 0.0;   // 最小生成树的边总权重

        for (int i = 0; i < n; i++) {
            int u = -1;
            double minDist = Double.MAX_VALUE;   // 最小距离指针
            // 找到距离最小生成树最近且未被访问的顶点
            for (int j = 0; j < n; j++) {
                if(!visited[j] && dist[j] < minDist){
                    minDist = dist[j];
                    u = j;
                }
            }
            // 没有点可以移出去了，说明全部加入
            if(u == -1){
                break;
            }
            visited[u] = true;
            sum += minDist;

            for(int v = 0; v < n; v++){
                if(!visited[v]){
                    double w;
                    double spcr = Getdist(u, v);
                    // 圆心之间距离小于等于半径之和，相交相切
                    if(spcr <= cirlces[u].r + cirlces[v].r){
                        w = 0.0;   // 不需要搭桥
                    }else{
                        w = spcr - (cirlces[u].r + cirlces[v].r);
                    }
                    // 松弛操作
                    if(w < dist[v]){
                        dist[v] = w;
                    }
                }
            }
        }
        return sum;
    }

    public Solutions() {
        FastReader sc = new FastReader();
        n = sc.nextInt();
        for (int i = 0; i < n; i++) {
            cirlces[i] = new cirlce(sc.nextInt(), sc.nextInt(), sc.nextInt());
        }

        double sum = prim();
        System.out.printf("%.2f", sum);
    }


    class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
            st = new StringTokenizer("");
        }

        public String next() {
            while (!st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
```

---

## 作者：Dicer_L (赞：1)

看完题目，要求为给定一些点，求全部连起来的最小费用。但凡是对图论有一点了解的，都知道这题应该用最小生成树的算法。

确定算法后，就很好考虑了。

首先考虑如何建边。我们的边是任意两点之间都会有，不存在无法连边的情况。那么每条边的边权如何计算呢？

> 则可以再使用一条魔法回路将它们的边缘连接起来。

所以，边权是任意两个点所形成的圆的边缘的最短距离。计算方法是把两点距离算出来，再减去两条半径。注意，如果这个算出来的距离为负的话，

> 如果两个魔法阵相交，则它们可以一起引爆；

即最后赋的边权为零，不需要任何费用。

其次，建好边后，考虑如何套最小生成树的算法。经过思考，发现没有需要特别修改的地方，那就可以直接套模板。注意，一些关键变量和存图时要用 double 类型。

自认为代码风格还是非常工整的。最小生成树算法我用的是 prim。

```
#include <bits/stdc++.h>
using namespace std;
const int N=5005;
int n,zn[N][3],vis[N],v,u;
double l,ans[N],maxn,w;
vector<double> ag[N][2];
double dis(int x1,int y1,int x2,int y2,int r1,int r2){
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))-r1-r2;
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>zn[i][0]>>zn[i][1]>>zn[i][2];
		for(int j=1;j<i;j++){
			l=dis(zn[i][0],zn[i][1],zn[j][0],zn[j][1],zn[i][2],zn[j][2]);
			if(l<=0) l=0;
			ag[i][0].push_back(j);
			ag[i][1].push_back(l);
			ag[j][0].push_back(i);
			ag[j][1].push_back(l);
		}
	}
	for(int i=2;i<n+2;i++) ans[i]=INT_MAX;
	while(1==1){
		u=n+1;
		for(int i=1;i<=n;i++)
			if(vis[i]==0&&ans[u]>ans[i]) u=i;
		if(u==n+1) break;
		vis[u]=1,maxn+=ans[u];
        for(int i=0;i<ag[u][0].size();i++){
			v=ag[u][0][i],w=ag[u][1][i];
			ans[v]=min(ans[v],w);
		}
	}
    printf("%.2lf",maxn);
}
```

---

## 作者：yihang2011 (赞：1)

# [题解：P12158 [蓝桥杯 2025 省 Java B] 爆破](https://www.luogu.com.cn/problem/P12158)

**提示：这是一篇 C++ 题解**

---

题意：定义两个圆的距离为两个圆的边缘最小的距离，如果两个圆重合，那么距离为 $0$。给定 $n$ 个圆在坐标系上的圆心以及半径，求这些圆的最小生成树。

$n \le 5000$，最极限的数据会有 $n^{2} = 2.5 \times 10^{7}$ 条边，绝对的稠密图，~~然后我就忘了 Prim 怎么写~~。

给了 3 秒的时间限制和 512MB 的空间限制，所以还是能用 Kruskal 的。

------

实现：很容易发现，两个圆的距离就是两个圆心的距离减去两个半径，即第 $i$ 个圆与第 $j$ 个圆的距离为：

$$
d = \max(\sqrt{(x1 - x2)^{2} + (y1 - y2)^{2}}, 0)
$$


有了这个就很好说了，如果两个圆不重合，那么就是一条边，放到一个数组里面去跑 Kruskal 就好了。

-------

其他细节看代码注释就行。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
    int u, v;
    double w;
    node() : u(0), v(0), w(0) { }
    node(int u, int v, double w) : u(u), v(v), w(w) { }
} g[25000010]; // n * n

int n, m, tot;
double ans;
int x[5010], y[5010], r[5010];
int f[5010]; // 并查集

int find(int u) {
    return u == f[u] ? u : f[u] = find(f[u]);
} 

double dis(int x1, int y1, int r1, int x2, int y2, int r2) { // 算距离
    double dis_p = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    if (dis_p <= r1 + r2) { // 重合
        return 0;
    }
    return dis_p - r1 - r2;
}

int main() {
    cin >> n;
    iota(f + 1, f + n + 1, 1); // 初始化 f[i] = i
    for (int i = 1; i <= n; i++) {
        cin >> x[i] >> y[i] >> r[i];
        for (int j = 1; j < i; j++) {
            double w = dis(x[i], y[i], r[i], x[j], y[j], r[j]);
            if (w == 0) {
                int u = find(i), v = find(j);
                if (u != v) { // 如果这两个圆没有通过重合连通，那么给它们连上，并且多了一条边（边权为 0）
                    tot++; 
                    f[u] = v;
                }
            } else {
                // 否则去跑 Kruskal
                g[++m] = node(i, j, w);
            }
        }
    }
    sort(g + 1, g + m + 1, [](node &x, node &y) {
        return x.w < y.w;
    }) ; // 从小到大排序
    for (int i = 1; i <= m; i++) {
        int x = find(g[i].u), y = find(g[i].v);
        if (x != y) { // 如果这两个圆没有连通，那么就选这条边
            f[x] = y;
            tot++; 
            ans += g[i].w; 
        }
        if (tot == n - 1) { // n 个点的树只有 n - 1 条边，到了就退出
            break ;
        }
    }
    printf("%.2lf\n", ans);
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/213486157)

~~写 Java 的同志码风真的很好！~~

---

## 作者：FISH酱 (赞：1)

题解区也有很多 C++ 题解，希望审核不要卡我这个。

## 前置知识

你需要先学习最小生成树、并查集、常用数学公式，最好把模板题做完。

## 思路讲解

本题较难的地方在于怎么计算魔法回路长度和判断相交：先说计算长度，只需要先计算两个圆心的直线距离，再减去各自的圆半径即可，这一点画图会更直观；然后是判断相交，如果两个魔法阵挨着，那么上一步得到的长度必然是 $0$，如果两个魔法阵相交，那么上一步得到的长度必然是负数，通过这一点就很好判断了，但在代码中要将边权设为 $0$。

建边完成后我们进行正式求解，这里需要运用最小生成树，根据代码量和本题限制，建议采用 Kruskal，剩下的就是最小生成树板子了。

## 代码展示

这题我交了好几次才过，注意以下几点：

1. 有浮点数，注意精度问题和变量类型，最后记得保留两位。
2. 相交时边权设为 $0$。
3. 计算距离时记得减去两个半径。
4. 数组开大一点，最坏的数据是稠密图，边很多容易炸数组。

下面是代码，其他语言的参考思路：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ld long double
#define inf 0x3f3f3f3f
#define endl '\n'

int n,m;
int fa[50000007];

int find(int x){
	if(fa[x]!=x) fa[x]=find(fa[x]);
	return fa[x];
}

struct edge{
	int x,y,r;
};
edge a[50000007];

struct man{
	int x,y;
	double z;
};
man p[50000007];

bool cmp(man u,man v){
	return u.z<v.z;
}

int main(){
	cin >> n;
	for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y>>a[i].r;

	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			double l=sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x) + (a[i].y-a[j].y)*(a[i].y-a[j].y));
			l=l-1.0*a[i].r-1.0*a[j].r;
			l=max(l,(double)0.0);
			
			p[++m] = man{i,j,l};
		}
	}
	
	sort(p+1,p+1+m,cmp);
	for(int i=1;i<=n;i++) fa[i]=i;
	double sum=0.0;int cnt=0;
	for(int i=1;i<=m;i++){
		int x=find(p[i].x),y=find(p[i].y);
		if(x != y){
			fa[x] = y;
			sum+=p[i].z;
			cnt++;
		}
		
		if(cnt==n-1) break;
	}
	
	printf("%.2lf",sum);

    return 0;
}
```

---

## 作者：DemonPlayer (赞：1)

### 题目大意：
使用尽可能的小距离使 $n$ 个圆连在一起。
### 思路：
典型的最小生成树题目。       
不过并没有给出边权且所有圆之间都可以连通。那圆与圆距离怎么算呢。不妨先计算出点和点之间的距离，再考虑半径，它可以向任意方向延伸。所以两圆之间的距离就是两点之间的距离减去两圆半径，然后使用 Prim 求最小生成树即可。
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,u,v,cnt,x,y,r;
double ans,w;
double dist[5005];
bool vis[5005];

struct pts{
	int idx;
	double dist;
	bool operator <(const pts& x)const{
		return x.dist<dist;
	}
};

struct circle{
	int x;
	int y;
	int r;
};

circle a[100005];

double zu(int u,int v){
	return sqrt((a[u].x-a[v].x)*(a[u].x-a[v].x)+(a[u].y-a[v].y)*(a[u].y-a[v].y));
}

void Prim(int x){
	for(int i=1;i<=n;i++){
		dist[i]=INT_MAX;
	}
	dist[x]=0;
	priority_queue<pts> q;
	pts t;
	q.push({x,0});
	while(q.size()){
		t=q.top();
		q.pop();
		u=t.idx;
		if(vis[u]){
			continue;
		}
		vis[u]=1;
		cnt++;
		ans+=dist[u];
		for(int v=1;v<=n;v++){
			if(u==v){
				continue;
			}
			w=max(0.00000,zu(u,v)-a[u].r-a[v].r);
			if(dist[v]>w){
				dist[v]=w;
				q.push({v,dist[v]});
			}
		}
	}
	return;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&x,&y,&r);
		a[i]={x,y,r};
	}
	Prim(1);
	printf("%.2f",ans);
	return 0;
}
```

---

## 作者：Dollartree (赞：0)

### 解题思路

1. 要使所有的魔法阵可以一起引爆，必须让魔法阵与其他魔法阵相交或使用魔法回路。

2. 也就是说所有的魔法阵形成了一个树，因为如果有环则会使魔法回路的总长度更长或相同，所以是没有意义的。

3. 考虑如何计算两个魔法阵之间需要的魔法回路：首先简单地认为魔法回路是两个魔法阵之间的距离，也就是圆心之间的距离。但是我们可以从边缘连接魔法回路，这样节省的魔法回路就是两个半径之和，将其减去即可。

4. 依照以上思路做最小生成树，建议用克鲁斯卡尔。
### 注意事项
1. 数组要开够。

2. 边数达到 $n-1$ 条后要结束。

3. 不要连双向边，否则数组容易炸。

4. 如果两个魔法阵之间的距离减去两个魔法阵半径之和是负数，换句话说它们相交，那么魔法回路应该是 $0$，而不是一个负数。
### 代码

```cpp
#include <bits/stdc++.h>
//#define int long long
using namespace std;
const int INF=99999999;
struct node
{
	int s,t;
	double w;
};
bool cmp(node x1,node y1)
{
	return x1.w<y1.w;
}
int vis[5010],fa[5010],n,m,u,v;
node a[25000010];//数组开够 
double dis[5010],x[5010],y[5010],r[5010],ans=0;
double cal(int i,int j)
{
	return max((double)0,sqrt(abs(x[i]-x[j])*abs(x[i]-x[j])+abs(y[i]-y[j])*abs(y[i]-y[j]))-r[i]-r[j]);
//            相交的情况                                                         减去从边缘开始连接而省下的回路 
}
int fd(int x)
{
	if(fa[x]!=x)return fa[x]=fd(fa[x]);//路径压缩 
	return x;
}
void h(int x,int y)
{
	fa[fd(x)]=fd(y);
}
bool check(int x,int y)
{
	return fd(x)==fd(y);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		fa[i]=i;
	}
	for(int i=1;i<=n;++i)
	{
		cin>>x[i]>>y[i]>>r[i];
	}
	int tot=0;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<i;++j)//单向边 
		{
			tot++;
			a[tot].s=i;
			a[tot].t=j;
			a[tot].w=cal(i,j);
		}
	}
	sort(a+1,a+tot+1,cmp);
	int cnt=0;
	for(int i=1;i<=tot;++i)
	{
		if(!check(a[i].s,a[i].t))
		{
			h(a[i].s,a[i].t);
			ans+=a[i].w;
			++cnt;//目前边的数量 
		}
		if(cnt==n-1)break;//是一个树之后就不用继续了 
	}
	printf("%.2f",ans);
}
```

---

## 作者：yanzixuan2024 (赞：0)

最小生成树。

枚举两个魔法阵，当圆心的距离小于半径之和时，连一条长度为距离减去半径之和的边。否则连一条长度为 $0$ 的边。再跑一遍最小生成树。

最小生成树我们用克鲁斯卡尔算法。把所有的边排序，枚举每一条边，当边的两端已经被连起来时，就不连这条边，否则置这条边为树边。当树边数为点数减一时，停止操作。至于如何判断边的两端已经被连起来，用个并查集就可以搞定。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5005;
int n,m,tot,fa[maxn],cnt,x[maxn],y[maxn],r[maxn];
double sum;
double dis(int x,int y,int xx,int yy){
    return sqrt(((x-xx)*(x-xx)+(y-yy)*(y-yy))*1.0);
}
int find(int x){
	if(fa[x]==x) return fa[x];
	return fa[x]=find(fa[x]);
}
struct node{
	int u,v;
    double w;
	bool operator<(const node& b)const{
		return w<b.w;
	}
}e[12502505];
void add(int u,int v,double w){
	e[++tot]={u,v,w};
}
int main(){
	scanf("%d",&n);
    for(int i=1;i<=n;++i) fa[i]=i;
    for(int i=1;i<=n;++i){
        scanf("%d %d %d",x+i,y+i,r+i);
        for(int j=1;j<i;++j){
            double diss=dis(x[i],y[i],x[j],y[j]);
            add(i,j,max(0.0,diss-r[i]-r[j]));
        }
    }
	sort(e+1,e+tot+1);
	for(int i=1;i<=tot;i++){
		int f=find(e[i].u),ff=find(e[i].v);
		if(f!=ff){
            fa[f]=ff;
			cnt++;
            sum+=e[i].w;
		}
		if(cnt==n-1) break;
	}
	printf("%.2lf",sum);
}
```

---

## 作者：Lele_Programmer (赞：0)

# P12158 题解

## 思路

对于一个满足 $1 \le i < j \le N$ 的对 $(i,j)$，如果第 $i$ 个圆和第 $j$ 个圆有交，则建立一条 $i$ 和 $j$ 之间的边，边权为 $0$，如果没有交，则通过勾股定理计算出两圆心距离，然后减去两条半径长度，得魔法回路的长度 $c$，建立一条 $i$ 和 $j$ 之间的边，边权为 $c$。

然后求一下最小生成树就行了，这里使用 Kruskal，用并查集维护，时间复杂度平方带个 $\log$。

## 代码

```cpp
const int N=5005;

int n;
double x[N],y[N],r[N];
int p[N];

struct Edge {
    int a,b;
    double c;
    friend bool operator < (const Edge& a,const Edge& b) {
        return a.c<b.c;
    }
} arr[N*N];

int find(int x) {
    return (p[x]==x)?p[x]:(p[x]=find(p[x]));
}

int main() {
    read(n);
    _rep(i,1,n) read(x[i]),read(y[i]),read(r[i]);
    int idx=0;
    _rep(i,1,n-1) _rep(j,i+1,n) {
        double dis=max(0.0,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))-r[i]-r[j]);
        arr[++idx]={i,j,dis};
    }
    sort(arr+1,arr+1+idx);
    _rep(i,1,n) p[i]=i;
    double ans=0;
    _rep(i,1,idx) {
        int a=arr[i].a,b=arr[i].b;
        double c=arr[i].c;
        if (find(a)==find(b)) continue;
        p[find(a)]=find(b);
        ans+=c;
    }
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：Alvin_Wang (赞：0)

~~虽然这是 Java 的题目，但这是一篇偏向 C++ 的题解（结尾代码有 Java 代码作为参考），参考思路和解法即可~~

首先我们看题目，题目要求用一条魔法回路将它们的边缘连接起来。意思就是要花最小的代价使着 $N$ 个点联通。

那很容易就联想到最小生成树。那边要怎么构造呢？两个圆形之间的最短距离其实就是这两个圆的圆心的距离减去两个圆的半径。**但要注意一点，如果两个圆是相交的话，那么它们之间的距离就会变成负数，此时这两个圆已经联通，在处理时只需将边权赋值为 0，也就是不需要代价。**

此时你就会发现已经做完了，用 Kruskal 求出最小生成树即可。

Code

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node{
    int x, y, z;
}a[5005];

struct E{
    int u, v;
    double w;
}b[25000005];

int n, fa[5005], m;

double dis(node a, node b){
    return max(1.0 * 0, sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y)) - a.z - b.z); // 两个圆之间的距离为它们圆心的距离（欧几里得距离）减去两个半径，因为可能有相交的情况，所以要和 0 取一个 max
}

int find(int x){
    if(x == fa[x]) return x;
    return fa[x] = find(fa[x]);
}

bool cmp(E a, E b){
    return a.w < b.w;
}

double mst(){ // Kruskal 尽量使用边权小的边，用并查集维护
    double ans = 0;
    sort(b + 1, b + m + 1, cmp);
    int cnt = 0;
    for(int i = 1 ; i <= m ; i ++){
        int u = b[i].u, v = b[i].v;
        double w = b[i].w;
        if(find(u) != find(v)){
            fa[find(u)] = find(v);
            ans += w;
            cnt ++;
        }
        if(cnt == n - 1){
            break;
        }
    } 
    return ans;
}

int main(){
    cin >> n;
    for(int i = 1 ; i <= n ; i ++){
        cin >> a[i].x >> a[i].y >> a[i].z;
        fa[i] = i; // 并查集初始化
    }
    for(int i = 1 ; i <= n ; i ++){
        for(int j = i + 1 ; j <= n ; j ++){
            b[++ m].u = i;
            b[m].v = j;
            b[m].w = dis(a[i], a[j]);
        }
    }
    printf("%.2lf", mst()); // 按照题目要求保留2位小数
    return 0;
}
```

最后~~拼尽全力用尽全身才华整出了~~ Java 的代码，求过 qwq（不是明明题解区里就是很多全是 C++ 的啊）：


```java
import java.io.*;
import java.util.*;

class Node {
    int x, y, z;
    Node(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

public class Main {
    public static void main(String[] args) throws IOException {
        FastReader br = new FastReader();
        int n = br.nextInt();
        Node[] nodes = new Node[n + 1];
        int[] fa = new int[n + 1];
        
        for (int i = 1; i <= n; i++) {
            nodes[i] = new Node(br.nextInt(), br.nextInt(), br.nextInt());
            fa[i] = i;
        }

        final int m = n * (n - 1) / 2;
        int[] u = new int[m];
        int[] v = new int[m];
        double[] w = new double[m];
        int idx = 0;
      
        for (int i = 1; i <= n; ++i) {
            for (int j = i + 1; j <= n; ++j) {
                u[idx] = i;
                v[idx] = j;
                w[idx] = distance(nodes[i], nodes[j]);
                ++idx;
            }
        }

        Integer[] indices = new Integer[m];
        for (int i = 0; i < m; i++) indices[i] = i;
        Arrays.sort(indices, (i, j) -> Double.compare(w[i], w[j]));

        double ans = 0;
        int cnt = 0;
        for (int i : indices) {
            int rootU = find(u[i], fa);
            int rootV = find(v[i], fa);
            if (rootU != rootV) {
                fa[rootU] = rootV;
                ans += w[i];
                if (++cnt == n - 1) break;
            }
        }

        System.out.printf("%.2f\n", ans);
    }

    private static int find(int x, int[] parent) {
        while (parent[x] != x) {
            parent[x] = parent[parent[x]]; 
            x = parent[x];
        }
        return x;
    }

    private static double distance(Node a, Node b) {
        double dx = a.x - b.x;
        double dy = a.y - b.y;
        double d = Math.sqrt(dx * dx + dy * dy) - a.z - b.z;
        return d > 0 ? d : 0;
    }

    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() {
            return Integer.parseInt(next());
        }
    }
}
```

---

## 作者：sherry_lover (赞：0)

# P12158 [蓝桥杯 2025 省 Java B] 爆破 题解

[题目传送门](https://www.luogu.com.cn/problem/P12158)

题面中的 “才能使得所有的魔法阵可以一起引爆”指的是所有的魔法阵形成一个连通块。

容易想到最小生成树，将两个魔法阵之间的距离设为它们之间边的长度。

两个圆 $i,j$ 之间的距离： $(x_i-x_j)^2+(y_i-y_j)^2-r_i-r_j$。

用 Kruskal 求出最小生成树即可。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct circle{
	double x,y,r;
}a[5005];
struct edge{
	int u,v;
	double w;
}b[25000005];
int n,m,fa[5005],tot,cnt;
double ans;
double dis(circle a,circle b)
{
	return max(0.0,sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r);
} 
int find_fa(int x)
{
	if(fa[x] == x) return x;
	return fa[x] = find_fa(fa[x]);
}
void Union(int x,int y)
{
	fa[find_fa(x)] = find_fa(y);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++) fa[i] = i;
	for(int i = 1;i <= n;i++) cin >> a[i].x >> a[i].y >> a[i].r;
	for(int i = 1;i <= n;i++)
	{
		for(int j = i+1;j <= n;j++)
		{
			b[++cnt] = {i,j,dis(a[i],a[j])};
		} 
	}
	sort(b+1,b+cnt+1,[](edge a,edge b){return a.w < b.w;});
	for(int i = 1;i <= cnt;i++)
	{
		int u = b[i].u,v = b[i].v;
		if(find_fa(u) == find_fa(v)) continue;
		Union(u,v);
		ans += b[i].w;
		tot++;
		if(tot == n-1) break;
	}
	cout << fixed << setprecision(2) << ans;
    return 0;
}
```

---

## 作者：chuanmu_zh (赞：0)

**最小生成树** 考试根本不会写

Prim 算法：

使用优先队列（最小堆）来选择最小边。

维护一个 key 数组记录连接到每个顶点的最小边权重。

使用 inMST 数组标记顶点是否已加入 MST。

累加所有选中的边的权重。

```java
import java.util.*;

public class Main {
    static class Circle {
        double x, y, r;
        Circle(double x, double y, double r) {
            this.x = x;
            this.y = y;
            this.r = r;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        Circle[] circles = new Circle[n];
        for (int i = 0; i < n; i++) {
            double x = scanner.nextDouble();
            double y = scanner.nextDouble();
            double r = scanner.nextDouble();
            circles[i] = new Circle(x, y, r);
        }

        double[][] graph = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                Circle c1 = circles[i];
                Circle c2 = circles[j];
                double dx = c1.x - c2.x;
                double dy = c1.y - c2.y;
                double distance = Math.sqrt(dx * dx + dy * dy);
                double sumR = c1.r + c2.r;
                if (distance <= sumR) {
                    graph[i][j] = 0;
                    graph[j][i] = 0;
                } else {
                    double edge = distance - sumR;
                    graph[i][j] = edge;
                    graph[j][i] = edge;
                }
            }
        }

        double total = primMSTOptimized(graph, n);
        System.out.printf("%.2f\n", total);
    }

    private static double primMSTOptimized(double[][] graph, int n) {
        double[] key = new double[n];
        boolean[] inMST = new boolean[n];
        Arrays.fill(key, Double.MAX_VALUE);
        key[0] = 0;

        double total = 0;
        for (int count = 0; count < n; count++) {
            int u = -1;
            double minKey = Double.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                if (!inMST[i] && key[i] < minKey) {
                    minKey = key[i];
                    u = i;
                }
            }
            if (u == -1) break;
            inMST[u] = true;
            total += minKey;

            for (int v = 0; v < n; v++) {
                if (!inMST[v] && graph[u][v] < key[v]) {
                    key[v] = graph[u][v];
                }
            }
        }
        return total;
    }
}
```

---


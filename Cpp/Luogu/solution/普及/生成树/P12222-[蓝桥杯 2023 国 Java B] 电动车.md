# [蓝桥杯 2023 国 Java B] 电动车

## 题目描述

作为一名繁忙的程序员，小蓝经常需要在 $N$ 座城市之间来回穿梭。他准备购买一辆电动车出行，但是担心电动车电量不足。

为了描述方便，我们把 $N$ 座城市编号 $1$ 至 $N$。城市之间一共有 $M$ 条双向高速公路相连。其中第 $i$ 条连接 $u_i$ 号城市和 $v_i$ 号城市，耗费 $w_i$ 个单位的电量。

假设小蓝可以在出发城市，以及任何中途经过的城市充满电。小蓝想知道，如果希望从任意城市开电动车到任意另一个城市，都可以找到一条由若干高速公路组成路径，使得不需要在任何高速公路内补充电量，那么这台电动车至少需要多少电量？

## 说明/提示

### 样例说明

- 从 $1$ 到 $2$ 可以走：$1 \rightarrow 2$，需要电量 3。
- 从 $1$ 到 $3$ 可以走：$1 \rightarrow 2 \rightarrow 4 \rightarrow 3$，其中 $1 \rightarrow 2$ 需要电量 $3$，$2 \rightarrow 4$ 需要电量 $2$，$4 \rightarrow 3$ 需要电量 $2$，全程至少需要电量 $3$。
- 从 $1$ 到 $4$ 可以走：$1 \rightarrow 2 \rightarrow 4$，其中 $1 \rightarrow 2$ 需要电量 $3$，$2 \rightarrow 4$ 需要电量 $2$，全程至少需要电量 $3$。
- 从 $2$ 到 $3$ 可以走：$2 \rightarrow 4 \rightarrow 3$，其中 $2 \rightarrow 4$ 需要电量 $2$，$4 \rightarrow 3$ 需要电量 $2$，全程至少需要电量 $2$。
- 从 $2$ 到 $4$ 可以走：$2 \rightarrow 4$，需要电量 $2$。
- 从 $3$ 到 $4$ 可以走：$3 \rightarrow 4$，需要电量 $2$。

综上所述，电动车至少需要 $3$ 个单位的电量。

### 评测用例规模与约定

- 对于 $20\%$ 的数据，$1 \leq N, M \leq 100$，$0 \leq w_i \leq 100$。
- 对于 $100\%$ 的数据，$1 \leq N, M \leq 200000$，$0 \leq w_i \leq 10^9$。

## 样例 #1

### 输入

```
4 5
1 2 3
1 3 5
2 4 2
4 3 2
4 1 4```

### 输出

```
3```

# 题解

## 作者：dendky (赞：10)

## 思路

题目想求的是这台电动车至少需要的电量，即求图中最大的一条边。那么我们只需要用[最小生成树](https://www.luogu.com.cn/problem/P3366)来解即可。求最小生成树有两种算法，一般的，我们使用 Kruskal 算法。Kruskal 就是用贪心优先选取权值较小的边，并依次连接，若出现环则跳过此边（用并查集来判断是否存在环），直到已经使用的边的数量比总点数少一。

Kruskal 算法一般会结合并查集和排序使用，有兴趣的读者课后可以写一下 [P3366](https://www.luogu.com.cn/problem/P3366)。

## code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ans, n, m, cnt, f[200005];
struct node {
    ll x, y, z;
}edge[200005];
ll find(ll a) {
    if (f[a]==a) return a;
    else return f[a]=find(f[a]);
}//并查集
bool cmp(node a, node b) {
    return a.z<b.z;
}//从小到大排序
void kruskal() {
    sort(edge+1, edge+1+m, cmp);
    for (int i=1; i<=m; i++) {
        ll f1=find(edge[i].x), k=find(edge[i].y);
        if (f1!=k) {//并查集：未合并就合并，统计的++
            f[f1]=k;
            cnt++;
            ans=edge[i].z;
        }//路径压缩
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>n>>m;
    for (int i=1; i<=n; i++) f[i]=i;//并查集初始化
    for (int i=1; i<=m; i++) cin>>edge[i].x>>edge[i].y>>edge[i].z;
    kruskal();
    if (cnt+1==n) cout<<ans;//边数为点数-1就输出
    else cout<<-1;//是环则无解
    return 0;
}
```

---

## 作者：ggpw_XNW (赞：6)

## 分析 
首先根据图的基本知识可以知道 $n-1$ 条边能让城市联通的边，答案就是这些边最长一条的长度，要让这个长度最短。  
简言之：求出一棵最长边最短的树。
## 算法
这就是瓶颈生成树了。无向图 $G$ 的瓶颈生成树是这样的一个生成树，它的最大的边权值在 $G$ 的所有生成树中最小。  
我们来看一个性质：最小生成树是瓶颈生成树，但瓶颈生成树不一定是最小生成树。
为什么？最小生成树是让这棵树的边权和最小，而瓶颈生成树是让最长边最短。也就是说最小生成树的最长边就是瓶颈生成树的最长边。因为瓶颈生成树的最长边最短，而最小生成树是所有生成树中最小的（边权），所以最长边一定相同。  
所以我们可以写最小生成树。
## 代码
然后就是模板代码了。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
	int x , y , len;
}a[200005];
int n , ans , m , f[200005];
bool cmp(node A , node B){
	return A.len < B.len;
}
int find(int x){
	if(f[x]==x)return x;
	return f[x] = find(f[x]);
}
int main(){
	cin >> n >> m;
	for(int i=1;i<=m;i++)cin >> a[i].x >> a[i].y >> a[i].len;
	for(int i=1;i<=n;i++)f[i] = i;
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++){
		if(find(a[i].x)!=find(a[i].y))f[find(a[i].x)] = find(a[i].y) , ans = max(ans,a[i].len) , n--;
	}
    if(n>1)ans = -1;
	cout << ans;
	return 0;
}
```
相信大家都会用并查集吧，如果不会请去 P3367，这里就不多说了。  
## 注意事项：
1. 并查集务必赋初始值！不赋后果自负！
2. 路径压缩！
3. 排序！
4. 判断无解！
5. 不要抄袭！

---

## 作者：Eden_star (赞：3)

## 思路：
这道题一眼是用 Kruskal 求出最小生成树中权值最大的那一条边。
### 证明：
设 $W$ 就是我们所求出最小生成树中权值最大的那一条边的权值。
1. 因为最小生成树中任意两个顶点之间的路径是唯一的，所以从一个顶点到另一个顶点的所有可能路径中，必然会经过这条权重最大的边。
2. 假设我们选择一个小于 $W$ 的电量 $x$，且起点在权值最大的哪一条边上的一个顶点，到达终点要经过这一条边，那么在就会因为最开始的一条边 $W$ 比 $x$ 大而到不了第二个点。

Kruskal 可以完美解决这个问题，因为最后那一条加入的边一定是最小生成树中最长的那一条边。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int ans;
int n,m,k,cnt,p,leb;
int fa[N],b[N],_x[N],_y[N];
struct G{
	int u,ne,w;
}pic[2*N];
int find(int );
bool cmp(G ,G );
bool fx(int ,int );
void add(int ,int ,int );
int main(){
	int u,v,w;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>u>>v>>w;
		add(u,v,w);
	}
	for(int i=1;i<=n;i++){
		fa[i]=i;
	}
	sort(pic+1,pic+1+cnt,cmp);
	int tot=0;
	for(int i=1;i<=cnt;i++){
		if(tot==n-1) break;
		int x=pic[i].u;
		int y=pic[i].ne;
		if(fx(x,y)){
			tot++;
			ans=pic[i].w;
		}
	}
	if(tot==n-1) printf("%d",ans);
	else printf("-1");
}
bool cmp(G x,G y){
	return x.w<y.w;
}
void add(int u,int v,int w){
	pic[++cnt].u=u;
	pic[cnt].ne=v;
	pic[cnt].w=w;
}
int find(int x){
	if(fa[x]==x) return x;
	else return fa[x]=find(fa[x]);
}
bool fx(int x,int y){
	int nx=find(x);
	int ny=find(y);
	if(nx==ny) return false;
	else{
		fa[nx]=fa[ny];
		return true;
	}
}
```

---

## 作者：int_inf (赞：2)

# Solution
首先，很明显本题是一道生成树的例题，类似于 [P3366](https://www.luogu.com.cn/problem/P3366)，我们可以使用 Kruskal 算法来解决此类问题。

题目中的最大电量，其实就是最小生成树里边权最大的一条边。我们可以在每次往最小生成树里加入边的时候比较答案和边权的大小。

当然也有更好的办法。对于每棵最小生成树，由于我们以边权为关键字进行从小到大排序，所以最后加入的边的边权一定是整个生成树里边权最大的。我们知道，一个有 $n$ 个点的生成树一共有 $n-1$ 条边。那么根据以上推论，我们可以写出如下代码。
# Code
```cpp
#include<bits/stdc++.h>
#define endl '\n'
typedef long long ll;
using namespace std;
int fa[1000005],cnt,n,m;
struct node{
	int x,y,val; 
}e[10000005];
int find(int x){
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);//路径压缩
}
bool cmp(node a,node b){
	return a.val<b.val;
}
void kruskal(){
	for(int i=1;i<=m;i++){
		int a=find(fa[e[i].x]),b=find(fa[e[i].y]);
		if(a==b) continue;
		cnt++;
		fa[b]=a;
		if(cnt==n-1){
			cout<<e[i].val<<endl;
			exit(0);//直接退出程序
		}
	}
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=m;i++){
		cin>>e[i].x>>e[i].y>>e[i].val;
	}
	sort(e+1,e+1+m,cmp);//以边权为关键字排序
	kruskal();
	cout<<-1<<endl;//图不联通
	return 0;
}
```
最慢的点跑了 $59$ ms，目前最优解，求管理员通过。

---

## 作者：emot1ons (赞：2)

## 思路
因为可以在城市充满电，所以答案即为无向图中最小生成树边权最大的一条边。那么用 kruskal 算法将边排序后，最后一条即第 $n-1$ 条被加入最小生成树的边即为树中的最大边权。

如果将 $m$ 条边遍历后被加入树中的边不为 $n-1$ 条，那么说明图并不联通，输出 $-1$ 即可。

---

## 作者：yihang2011 (赞：1)

## [题解：P12222 [蓝桥杯 2023 国 Java B] 电动车](https://www.luogu.com.cn/problem/P12222)

这道题为什么会想到要用 Kruskal 呢？~~因为标签里有。~~

首先，题目要求一张无向连通图的最大边权的最小值。

而我们可以把边权从小到大排序，然后对于每条边，如果边连接的两个点已经连通，那么就忽略；否则把这两条边连接，那这时就多了一条边。

一个 $n$ 个点的无向连通图至少有 $n - 1$ 条边，那选到第 $n - 1$ 条边时这条边的边权就是答案了，因为边权已经从小到大排序了。

好了思路分析完了就可以一眼 Kruskal 了，纯板子题。

C++ 代码如下：

```cpp
#include <iostream>
#include <algorithm>
#include <numeric>
using namespace std;

int n, m;
int f[200010];

struct edge {
    int u, v, w;
} g[200010];

int find(int u) {
    return u == f[u] ? u : f[u] = find(f[u]);
}

int main() {
    cin >> n >> m;
    for (int i = 1, u, v, w; i <= m; i++) {
        cin >> g[i].u >> g[i].v >> g[i].w;
    }
    sort(g + 1, g + m + 1, [&](edge& x, edge& y) {
        return x.w < y.w;
    }) ;
    int tot = 0;
    iota(f + 1, f + n + 1, 1);
    for (int i = 1; i <= m; i++) {
        int x = find(g[i].u), y = find(g[i].v);
        if (x != y) {
            f[x] = y;
            tot++;
            if (tot == n - 1) {
                cout << g[i].w << endl;
                return 0;
            }
        } 
    }
    cout << -1 << endl;
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/214419716)

----

Java 代码如下：

```java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    static int n, m;
    static int[] f = new int[200010];

    static class Edge {
        int u, v, w;

        Edge(int u, int v, int w) {
            this.u = u;
            this.v = v;
            this.w = w;
        }
    }

    static Edge[] g = new Edge[200010];

    static int find(int u) {
        if (u == f[u]) {
            return u;
        } else {
            f[u] = find(f[u]);
            return f[u];
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        m = scanner.nextInt();
        for (int i = 1; i <= m; i++) {
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int w = scanner.nextInt();
            g[i] = new Edge(u, v, w);
        }
        Arrays.sort(g, 1, m + 1, (x, y) -> Integer.compare(x.w, y.w));
        int tot = 0;
        for (int i = 1; i <= n; i++) {
            f[i] = i;
        }
        for (int i = 1; i <= m; i++) {
            int x = find(g[i].u);
            int y = find(g[i].v);
            if (x != y) {
                f[x] = y;
                tot++;
                if (tot == n - 1) {
                    System.out.println(g[i].w);
                    return;
                }
            }
        }
        System.out.println(-1);
    }
}
```

[AC Record](https://www.luogu.com.cn/record/214449258)

---

## 作者：heyou666 (赞：1)

**思路**：瞄一眼题目，是要求连通图中最大边权最小值，想到瓶颈生成树，再看到无向图（这里有个特殊性质，无向图中的瓶颈生成树一定是最小生成树），很容易联想到 Kruskal 算法中的最小生成树最大边。所以我们只需要按边排序后检查边是否联通，不联通连接即可，由于边排序过，所以最后一条连接的边即为树中边权最大的。

**Code**:

```cpp
#include<bits/stdc++.h>
using namespace std;
struct dsu {
	vector<int>pa,size;
	int count;
	dsu(int n) {
		count = n;
		pa = size = vector<int>(n + 1, 1);
		iota(pa.begin(),pa.end(),0);
	}
	int find(int x) {
		return pa[x] == x ? x : pa[x] = find(pa[x]);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x == y) return;
		if (size[x] < size[y]) swap(x, y);
		pa[y] = x;
		size[x] += size[y];
		count--;
	}
	bool pd(int x,int y) {
		return find(x) == find(y);
	}
};
struct edge{
	int u,v,w;
	bool operator < (const struct edge & rhs){
		return w<rhs.w;
	}
}e[200010];//按边排序
long long n,m,u,v,s,t,mi=INT_MAX;
vector<long long> g[200010];
long long node[200010],vis[200010];
int main(){
    cin>>n>>m;
    struct dsu uf(n);
    for(int i=1;i<=m;i++){
    	cin>>e[i].u>>e[i].v>>e[i].w;
	}
	sort(e+1,e+m+1);
	for(int i=1;i<=m;i++){
		if(uf.pd(e[i].u,e[i].v)){
			continue;//已经连通就放弃
		}else{
            uf.merge(e[i].u,e[i].v);
        }
        if(uf.count==1){
            cout<<e[i].w<<endl;//图已经联通，这是最后且最大的一条边
            return 0;
        }
	}
	cout<<"-1"<<endl;//没结束说明不联通
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 思路

简化一下题意：给定一个无向图，最小化其一个包含所有顶点的联通子图边权最大值。\
什么？你听不懂？再说直白一点，题目让我们求的就是一个无向图最小生成树的边权最大值！\
说明什么？求出最小生成树，再计算出它的边权最大值就行，如果图不联通，输出 $-1$，快去跑一遍 Kruscal 啊！

## 正解

```cpp
#include<bits/stdc++.h>
#define int long long //细节 1：开 long long
using namespace std;

struct Edge{
	int u, v, w;
};
Edge e[114514];
int f[114514];

int root(int x){
	return f[x] = (f[x] == x ? x : root(f[x])); //细节 2：压缩路径
}

signed main(){
	int n, m;
	cin >> n >> m;
	for(int i = 0; i < m; ++i) cin >> e[i].u >> e[i].v >> e[i].w;
	sort(e, e + m, [](Edge a, Edge b){return a.w < b.w;})
	for(int i = 0; i < n; ++i) f[i] = i; //细节 3：并查集初始赋值

	int cnt = 0;
	for(int i = 0; i < m; ++i){
		int ru = root(e[i].u);
		int rv = root(e[i].v);
		if(ru != rv) f[ru] = rv, ++cnt;
		if(cnt == n - 1) return cout << e[i].w, 0;
	}
    cout << -1; //细节 4：记得判联通
	return 0;
}
```

---

## 作者：_IceCream_ (赞：0)

# Content

给你一个 $n$ 个点 $m$ 条边的图，需要你找到一个连通子图，使得图中每一条路径的经过的边的最大值最小。

# Solution

最大值最小，看起来是二分，但二分并不好处理。我们考虑直接贪心。

- 这个连通子图一定是一棵生成树。

我们只需保证它的连通即可，多加边反而可能会是答案变大。

- 这个连通子图一定是一个最小生成树。

我们注意到的是最小生成树的排序过程，而不是它的加权定义。这个加权也可以改成取最大值。

若不是最小生成树，则必有一条边比当前最大值小，而这条边会把最大值挤出去，加进最小生成树中。

所以我们直接跑最小生成树即可。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int n, m, fa[N];
struct Edge {
	int u, v, w;
	
	bool operator < (const Edge &T) const {
		return w < T.w;
	}
} e[N];
int find (int x) { return fa[x] == x ? x : fa[x] = find (fa[x]); }

int main () {

	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) fa[i] = i;
	for (int i = 1; i <= m; ++i) scanf ("%d%d%d", &e[i].u, &e[i].v, &e[i].w);
	
	sort (e + 1, e + m + 1);
	int tot = 0, ans = 0;
	for (int i = 1; i <= m; ++i) {
		int u = e[i].u, v = e[i].v, w = e[i].w;
		int fu = find (u), fv = find (v);
		
		if (fu == fv) continue;
		fa[fu] = fv;
		tot++;
		ans = max (ans, e[i].w);
	}
	if (tot == n - 1) printf ("%d", ans);
	else printf ("-1");
	
	return 0;
}
```

```java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    static int N = 200005;
    static int n, m;
    static int[] fa = new int[N];

    static class Edge {
        int u, v, w;
        Edge (int u, int v, int w) { this.u = u; this.v = v; this.w = w; }
    }
    static Edge[] e = new Edge[N];

    static int find (int x) {
        if (x == fa[x]) return x;
        return fa[x] = find (fa[x]);
    }

    public static void main (String[] args) {
        Scanner scanner = new Scanner (System.in);
        n = scanner.nextInt (); m = scanner.nextInt ();
        for (int i = 1; i <= n; ++i) fa[i] = i; 
        for (int i = 1; i <= m; ++i) {
            e[i] = new Edge (scanner.nextInt (), scanner.nextInt (), scanner.nextInt ());
        }
        Arrays.sort (e, 1, m + 1, (x, y) -> Integer.compare (x.w, y.w));

        int tot = 0, ans = 0;
        for (int i = 1; i <= m; ++i) {
            int u = e[i].u, v = e[i].v, w = e[i].w;
            int fu = find (u), fv = find (v);

            if (fu == fv) continue;
            fa[fu] = fv;
            tot++;
            if (e[i].w > ans) ans = e[i].w;
        }
        if (tot == n - 1) System.out.println (ans);
        else System.out.println (-1);
    }
}
```

---


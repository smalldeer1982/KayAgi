# 村村通

## 题目描述

某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 "村村通工程" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n < 1000$ 。

## 样例 #1

### 输入

```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```

### 输出

```
1
0
2
998
```

# 题解

## 作者：Strong_Jelly (赞：127)

题目描述

某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（**但不一定有直接的道路相连，只要相互之间可达即可**）。请你计算出最少还需要建设多少条道路？



------------


**这一道题可以用并查集的方法做**

**思路：输入两个村庄后就把它们连起来，输入完毕后用i从1循环到n，所以如果i的父亲为它本身的话（它是祖先，它没有父亲），ans+1。答案要减1，因为三个点中只需用两条线连接，无需用三条线连接。**

### 并查集

**并查集是一种树型的数据结构，用于处理一些不交集的合并及查询问题（不交集的意思是两个集合中没有相同的元素）。**

并查集分两个主要步骤——**合并**，**查找**

### 1.find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。


code : 

```cpp
int find(int x) 
{
    if(x != fa[x])//当x不等于它的爸爸时(当它是祖先时，它没有爸爸) 
    {
        fa[x] = find(fa[x]);//继续找他的爸爸的爸爸 
    }
    return fa[x];//返回祖先 
}//查找 

```

### 2.unity：将两个子集合并成同一个集合。

code : 

```cpp
void unity(int x, int y)
{
    int r1 = find(x);//找到x的祖先 
    int r2 = find(y);//找到y的祖先 
    fa[r1] = r2;//祖先和祖先结为父子(谁是父亲谁是儿子都可以) 
}//合并 
```





完整代码如下：


```cpp
#include <bits/stdc++.h>
using namespace std;
int fa[1000001], n, m, x, y;
int find(int x)//并查集(路径压缩) 
{
    if(x != fa[x])//当x不等于它的爸爸时(当它是祖先时，它没有爸爸) 
    {
        fa[x] = find(fa[x]);//继续找他的爸爸的爸爸 
    }
    return fa[x];//返回祖先 
}//查找 
void unity(int x, int y)
{
    int r1 = find(x);//找到x的祖先 
    int r2 = find(y);//找到y的祖先 
    fa[r1] = r2;//祖先和祖先结为父子(谁是父亲谁是儿子都可以) 
}//合并 
int main()
{
	while(true)
	{
		int ans = 0;//ans要在循环中定义为0
		scanf("%d", &n);
		if(n == 0)
		{
			return 0;
		}
		scanf("%d", &m);
	    for(int i = 1; i <= n; i++)
	    {
	        fa[i] = i;//初始化自己的父亲是自己 
	    }
	    for(int i = 1; i <= m; i++)
	    {
	        scanf("%d %d", &x, &y);
	        unity(x, y);//合并x和y 
	    }
	    for(int i = 1; i <= n; i++)
	    {
	    	if(find(i) == i)//自己的父亲等于自己本身
	    	{
	    		ans++;
			}
		}
		printf("%d\n", ans - 1);//答案减一 
	}
    return 0;
}
```



---

## 作者：kraylas (赞：79)

## 看见下面大佬没有发LCT题解的我就来一发LCT题解
**这明显是LCT（~~并查集~~）裸题啊**

~~咳咳~~ 先说说LCT是啥

LCT（~~刘琛Tree~~）link-cut-tree

可以动态维护图的连通性（是不是和题目说的一样）

资瓷的操作：

1. 动态连边，删边
2. 动态维护边权，点权
3. 查询、修改链上的信息（最值，总和等）
4. 随意指定原树的根（即换根）
5. 合并两棵树、分离一棵树（跟上面不是一毛一样吗）
6. 动态维护连通性

其中维护联通性就可以解决此题

题目说给你n个点，m个边然后让你求还需要几个边才能让整张图联通

所以这就是一个不连通图，我们只要知道整张图里面有多少联通的部分再将它们连在一起就行啦

看下图：
![lct.png](https://i.loli.net/2018/09/05/5b8f82b5b1be1.png)

其中绿色圈起来的就是每一个部分我们只需要将它们连起来就可以让整张图达到联通

所以答案为联通块个数减一

就像这样：
![lct.png](https://i.loli.net/2018/09/05/5b8f832bded02.png)
此时整张图就是联通的了

所以对于图中的边链接的两个点所属的集合的关系维护我们就可以用LCT(~~并查集~~)维护

图中的边错综复杂使得维护信息非常麻烦，
既然复杂就请砍哥出场：把树形结构砍成一条一条的链
此时链上的信息维护就方便了许多

但链与链之间需要连接 这样树上的信息才好转移

在树剖中我们是通过跳轻边来进行重链之间的跳转

但Lct需要动态维护，所以我们选用更灵活的数据结构来维护链中的信息-splay

由于splay可以维护区间翻转（还记得那个换根操作吗）所以我们选用它作为LCT的辅助树

**了解一些基本概念（LCT）：**
1. 同样将某一个儿子的连边划分为实边，而连向其他子树的边划分为虚边。
2. 区别在于虚实是可以动态变化的，因此要使用更高级、更灵活的Splay来维护每一条由若干实边连接而成的实链。基于性质更加优秀的实链剖分，LCT(Link-Cut Tree)应运而生。

这里填一个自己的理解：

虚边 ： 该边的儿子位置 记录他的父亲 ，但父亲不记录它

实边 ：父子都互相认识

1每一个Splay维护的是一条从上到下按在原树中深度严格递增的路径，且中序遍历Splay得到的每个点的深度序列严格递增。是不是有点抽象哈比如有一棵树，根节点为1（深度1），有两个儿子2,3（深度2），那么Splay有3种构成方式：

{1−2},{3}

{1−3},{2}

{1},{2},{3}

例如：
![clt.png](https://i.loli.net/2018/09/05/5b8f9230520f4.png)
图中1和2在一个splay中3在另一个splay中但3与1通过虚边相连

绿树为原树，红树为splay


每一条链表示一个（Splay）而不能把1,2,3同放在一个Splay中（存在深度相同的点）

性质：
1. 每个节点包含且仅包含于一个Splay中
2. 边分为实边和虚边，实边包含在Splay中，而虚边总是由一棵Splay指向另一个节点（指向该Splay中中序遍历最靠前的点在原树中的父亲）。


推论：
1. 因为性质2，当某点在原树中有多个儿子时，只能向其中一个儿子拉一条实链（只认一个儿子），而其它儿子是不能在这个Splay中的。
2. 那么为了保持树的形状，我们要让到其它儿子的边变为虚边，由对应儿子所属的Splay的根节点的父亲指向该点，而从该点并不能直接访问该儿子（认父不认子）。


#### LCT 的两个基本操作 —— 一.access
LCT核心操作，也是最难理解的操作。其它所有的操作都是在此基础上完成的

因为性质3，我们不能总是保证两个点之间的路径是直接连通的（在一个Splay上）

access即定义为打通根节点到指定节点的实链，使得一条中序遍历以根开始、以指定点结束的Splay出现

比如一颗这样划分的树
![lct.png](https://i.loli.net/2018/09/05/5b8f940d9d8e6.png)

实际在LCT 中以这样 的形式呈现（绿框中为一个splay）
![lct.png](https://i.loli.net/2018/09/05/5b8f946d1cd08.png)

- 现在我们要access（N） ，把A-N上的路径拉起来成一条splay.
- 因为性质2，该路径上其它链都要给这条链让路，也就是把每个点到该路径以外的实边变虚
- 所以我们希望重新划分成这样

![lct.png](https://i.loli.net/2018/09/05/5b8f9497e4b79.png)


然后怎么实现呢？我们要一步步往上拉。首先把splay(N)，使之成为当前Splay中的根。为了满足性质2，原来N−O的重边要变轻。因为按深度O在N的下面，在Splay中O在N的右子树中，所以直接单方面将N的右儿子置为0（认父不认子）然后就变成了这样——
![lct.png](https://i.loli.net/2018/09/05/5b8f966c132fb.png)
这样在原树中正好成了刚才那个样子


#### LCT 的两个基本操作 —— 二.makeroot

这个操作是建立在access之上的。

Makeroot(x)  实际意义为 将节点x转变为它所的树的根


我们类比一棵有根树的换根操作 为了方便讲解
我们用 x 代表 我们即将换根的点
1. 由于是树 ， 那么除了 和x相关的点 ， 其父子关系是不变的与x相关的点 唯一变化就是父亲成了儿子
2. 对于所有的点的变化 ， 只有dep变了
我考虑用access ， splay方便的实现
三个操作完成makeroot:
Access(x) , splay(x) , pushr(x)
完成 // pushr 为交换x的左右儿子 (区间翻转)

因为在access扯出一条链来后，当前节点肯定是链中dep最深的一个点，所以我们进行区间翻转，将当点变为dep最浅的点，实现换根

#### 选用操作 二.findroot（x）

定义：findroot(x) 的 实际意义是
找出 x 在其树（原树，不是splay）中的根
意义：可以动态判断图的连通性（题目）


同样只需要三个操作：
```cpp

Access(x) , splay(x) ;
While(ls)push_down(x) ,  x = ls;
Return x ;

```

access扯出一条链后根肯定为dep最浅的点,那么也就是splay中最靠左子树的点，所以不断去找左儿子

#### 选用操作 三.link（x，y）

定义：表示 连接 边 x - > y

意义： 没有意义  

实现： 

把x转成根 ，直接连就行

如果 x  , y  本来不连通 直接 x - >  y连一条**虚边**

如果  出题人不负责 （渣渣——

我们就需要特判
```cpp
makeroot(x) ;
if(findroot(y) == x)return;
fa[x] = y ;
```

然后有了这几个操作我们就可以每次读入一条边，link一下，
用findroot判断在不在一个连通块里面，如果不是一个那么总块个数减一，一直到最后用总连通块个数减一即为答案


code：
splay的结构体：
```cpp
struct node{
	node * fa,*ch[2];//父亲及儿子节点
	// int sum,val;//没用
	bool rev;//区间翻转标记
	node(){//构造函数
		fa=ch[0]=ch[1]=NULL;
		// sum=val=0;
		rev=0;
	}
	bool d(){return fa->ch[1]==this;}//判断为父亲的哪个儿子
	bool ntr(){return fa!=NULL&&(fa->ch[0]==this||fa->ch[1]==this);}//不为根（not the root）加入虚边判断
	void r(){//翻转
		swap(ch[0],ch[1]);
		rev^=1;
	}
	void up(){
		// sum=val;
		// if(ch[0]!=NULL)sum+=ch[0]->sum;
		// if(ch[1]!=NULL)sum+=ch[1]->sum;
	}
	void down(){//下传标记
		if(!rev)return ;
		if(ch[0]!=NULL)ch[0]->r();
		if(ch[1]!=NULL)ch[1]->r();
		rev=0;
	}
}s[maxn];
```

access函数:
```cpp
void access(ptr x){
	for(ptr y=NULL;x!=NULL;x=(y=x)->fa){
		splay(x);x->ch[1]=y;x->up();//断实连虚
	}
}
```
makeroot:
```cpp
void makeroot(ptr x){
	access(x);splay(x);x->r();//区间翻转
}
```
findroot:
```cpp
ptr findroot(ptr x){
	access(x);splay(x);
	while(x->down(),x->ch[0]!=NULL)x=x->ch[0];//向左找
	splay(x);
	return x;
}
```
link:
```cpp
void link(ptr x,ptr y){
	if(findroot(x)==findroot(y))return;
	ans--;
	makeroot(y);
	y->fa=x;//连虚边
}
```
完整代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1e4+5;
struct node{
	node * fa,*ch[2];//父亲及儿子节点
	// int sum,val;//没用
	bool rev;//区间翻转标记
	node(){//构造函数
		fa=ch[0]=ch[1]=NULL;
		// sum=val=0;
		rev=0;
	}
	bool d(){return fa->ch[1]==this;}//判断为父亲的哪个儿子
	bool ntr(){return fa!=NULL&&(fa->ch[0]==this||fa->ch[1]==this);}//不为根（not the root）加入虚边判断
	void r(){//翻转
		swap(ch[0],ch[1]);
		rev^=1;
	}
	void up(){
		// sum=val;
		// if(ch[0]!=NULL)sum+=ch[0]->sum;
		// if(ch[1]!=NULL)sum+=ch[1]->sum;
	}
	void down(){//下传标记
		if(!rev)return ;
		if(ch[0]!=NULL)ch[0]->r();
		if(ch[1]!=NULL)ch[1]->r();
		rev=0;
	}
}s[maxn];
int ans=0;
typedef node* ptr ;
void rot(ptr x){
	ptr y=x->fa,z=y->fa;int k=x->d();ptr w=x->ch[!k];
	if(y->ntr())z->ch[y->d()]=x;
	x->ch[!k]=y;y->ch[k]=w;
	x->fa=z;y->fa=x;
	if(w!=NULL)w->fa=y;
	y->up();
}
void splay(ptr x){
	static ptr st[maxn];//手工栈，速度更快
	int top;st[top=1]=x;
	while(st[top]->ntr()){st[top+1]=st[top]->fa;top++;}
	while(top)st[top--]->down();//下传标记
	while(x->ntr()){
		if(x->fa->ntr())rot(x->d()==x->fa->d()? x->fa:x);
		rot(x);
	}
	x->up();
}
void access(ptr x){
	for(ptr y=NULL;x!=NULL;x=(y=x)->fa){
		splay(x);x->ch[1]=y;x->up();
	}
}
void makeroot(ptr x){
	access(x);splay(x);x->r();
}
ptr findroot(ptr x){
	access(x);splay(x);
	while(x->down(),x->ch[0]!=NULL)x=x->ch[0];
	splay(x);
	return x;
}
void link(ptr x,ptr y){
	if(findroot(x)==findroot(y))return;
	ans--;
	makeroot(y);
	y->fa=x;
}
int n,m;
int main(){
	while(233){
		memset(s,0,sizeof s);ans=0;
		cin>>n>>m;
		if(!n)break;
		ans=n;
		for(int i=1;i<=m;++i){
			int x,y;
			cin>>x>>y;
			link(s+x,s+y);
		}
		cout<<ans-1<<endl;
	}
	return 0;
}
```

---

## 作者：vectorwyx (赞：54)

## 并查集+桶排序


------------
显然，城镇之间构成了一个又一个的集合

而对于集合的每一个元素（城镇）又没有特殊限定

那我们直接用**并查集**解决

每建一条公路，就是把两城镇所在的集合合并

显然，**对于$n$个不同的集合，想要把它们连起来**

**至少需要连$n-1$条线**

那我们求出**一共有多少个集合**

把**集合数减去1**，输出，搞定！

------------
如何求集合的数量呢？

每个集合都有一个“祖宗”

又知道“祖宗”的序号不会超过1000

那好办，**桶排序**啊！

每遇到一个城镇，就把它的“祖宗”对应的下标变为1

我们可以通过**路径压缩**使同一个集合的城镇拥有同一个祖宗

那最后遍历桶，看看有多少被标为1的元素不就行了

注意有多组数据哦

------------
代码来了~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=1001;//定义常量maxn作为数组大小
int a[maxn];//并查集a
bool ok[maxn];//桶
int cz(int x){//并查集查找函数
	if(a[x]==x) return x;
	else return a[x]=cz(a[x]);//路径压缩
}
void hb(int x,int y){//合并函数
	int x1=cz(x),y1=cz(y);
	a[x1]=a[y1];
}
int main(){
	int n,m,x,y,ans;
	while(1){
		scanf("%d",&n);//先读一个数据
		if(n==0) break;//是0，停止读入
		scanf("%d",&m);//不是0，继续
		ans=0;//集合数量
		for(int i=1;i<=n;++i){
			a[i]=i;//并查集初始化
		}
		for(int i=1;i<=m;++i){
			scanf("%d%d",&x,&y);//把x,y两个城镇连起来
			hb(x,y);//就是合并x,y所在的集合
		}
		for(int i=1;i<=n;++i){
			ok[cz(i)]=1;//入桶
		}
		for(int i=1;i<=n;++i){
			if(ok[i]) ans++;//被标记过，代表着一个集合
		}
		printf("%d\n",ans-1);//输出答案
		memset(ok,0,sizeof(ok));//清空桶
	}
	return 0;
}
```


------------

你AC了没？AC了就点个赞呗

---

## 作者：一扶苏一 (赞：48)

## 思路：tarjan

#### 本题使用并查集的思路是最优的，但是蒟蒻觉得缩点的思路才是显然的……

观察题目，**市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通**，表明图为多个联通块，因为是无向边，所以每个联通块一定是一个强连通分量（显然）。

那么问题就变成了 **查找联通块，将所有联通块联通**，显然需要n-1条边。

### 所以 只需要tarjan搜索强连通分量的个数，然后输出强连通分量个数减一即为答案。

下面送上画风~~迥异~~清奇的代码
```cpp
#include<cstdio>
#include<cstring>
namespace read{
    void imop(int&x){		//不带号读入优化 
        char ch=getchar();
        while(ch<'0'||ch>'9') ch=getchar();
        while(ch>='0'&&ch<='9')   x=x*10+ch-'0',  ch=getchar();
        return;
    }
    void op(int&x){
        char ch=getchar();	//带号读入优化 
        int f=1;
        while(ch<'0'||ch>'9'){
            if(ch=='-') f=-1;
            ch=getchar();
        }
        while(ch>='0'&&ch<='9')   x=x*10+ch-'0',  ch=getchar();
        x*=f;
        return;
    }
}
namespace fusu{
    const int maxn = 1010 , maxm = 1000010;
    struct Edge{
        int next,to;
    };
    Edge edge[maxm];int head[maxn],ecnt;
    int n,m;
    int top,vistime,cnt,dfn[maxn],low[maxn],stack[maxn];bool instack[maxn];
    /*
    	*顺带说一下tarjan吧
		*stack,top为手写栈以及栈顶，instack判定元素是否在栈中
		*dfn[i]为整张图中i号点被第一次遍历的序号
		*low[i]表示从i号点向上推（连接）最靠上能推到的点 
		*这里“向上推”指的是在dfs搜索树中，i号点所联通的最靠近根节点（搜索树中）的点的序号
		*逐层扩展，当dfn的值与low的值相等，即这个点无法再向根节点方向联通时
		*这个点及其子树一定构成一个强连通分量
		*以上内容是在各tarjan题解中叙述比较模糊的部分，仅供参考。篇幅问题，详细题解请移步P3387【模板】缩点（其实那里也不详细） 
	*/ 
    inline int min(int a,int b){return a<b?a:b;}
    inline void connect(int from,int to){			//链式前向星存图 
        edge[++ecnt].to=to;
        edge[ecnt].next=head[from];
        head[from]=ecnt;
        return;
    }
    void tarjan(int u){
        int v;
        dfn[u]=low[u]=++vistime;				//dfn搜索树编号 
        stack[++top]=u;							//入栈 
        instack[u]=true;						//标记 
        for(int i=head[u];i;i=edge[i].next){
            v=edge[i].to;
            if(!dfn[v]){
                tarjan(v);						//拓展叶节点 
                low[u]=min(low[u],low[v]);		//显然，该点所能到达的最靠近根节点的点为自己本身的值与他所能到达的点的值取最小值 
            }
            else if(instack[v]){
                low[u]=min(low[u],dfn[v]);		//如果已经拓展过，则仍然可以更新，无需搜索。 
            }
        }
        if(!(low[u]^dfn[u])){					//位运算!(a^b)表示a==b，即自己最向上能扩展的是自己，则为强连通分量 
            ++cnt;								//记录强连通分量个数 
            do{
                v=stack[top--];					//退栈 
                instack[v]=false;
            }while(u^v);
        }
    }
    void work(){
        read::imop(m);
        while(m){
            int a=0,b=0;
            read::imop(a);read::imop(b);
            connect(a,b);connect(b,a);
            --m;
        }
        for(int i=1;i<=n;++i)	
            if(!dfn[i])	tarjan(i);				//如果没搜过则搜索 
        printf("%d\n",cnt-1);					//输出 
        return;
    }
    void clear(){
        n=m=ecnt=cnt=vistime=top=0;
        std::memset(dfn,0,sizeof dfn);
        std::memset(low,0,sizeof low);
        std::memset(instack,false,sizeof instack);
        std::memset(head,0,sizeof head);
        std::memset(edge,0,sizeof edge);
        return;
    }
    int doit(){
        read::imop(n);
        do{
            work();
            clear();
            read::imop(n);
        }while(n);
        return 0;
    }
}
int main(){
    return fusu::doit()；						//精简的main函数 
}
```

另外鉴于luogu上缩点模板题的题解的解释有点少，在此推荐一篇博客[](http://www.cnblogs.com/shadowland/p/5872257.html)，较为详尽。

---

## 作者：天泽龟 (赞：23)

连接道路的题目很容易想到的一种方法就是

#并查集

- 我的方法是：把所有的村庄看作一个个点，用道路连接起来就成了一棵棵树，最后数一数有多少棵树就行了，要求的道路就是树的数目-1；

- 怎么才能知道有多少树呢？我的想法是路径压缩，把树的节点都指向根节点，这样根节点的数目就是树的数目了~

- 最后本蒟蒻并不知道怎么数根节点，看到n<1000就直接建了一个桶把根节点丢进去，0到1000跑一边数出来了，反正又不大……

还是比较简单的吧

```cpp
#include <iostream>
using namespace std;
int n,m,a,b,p;
int f[20001]={0};
int get(int b)
{
    if (f[b]==b) return b;
    else
    {
        f[b]=get(f[b]);
        return f[b];
    }
}
int find(int a)
{
    if (f[a]==a) return a;
    else return find(f[a]);
}
int main()
{
    cin>>n;
    if (n!=0) cin>>m;
    while (n!=0)
    {
        int t[1001]={0};
        for (int i=1;i<=n;i++) f[i]=i;
        for (int i=1;i<=m;i++)
        {
            cin>>a>>b;
            int k1=find(b);
            f[k1]=get(a);
        }
        for (int i=1;i<=n;i++) f[i]=find(f[i]);
        for (int i=1;i<=n;i++) t[f[i]]++;
        int ans=0;
        for (int i=0;i<=1000;i++) if (t[i]!=0) ans++;
        cout<<ans-1<<endl;
        cin>>n;
        if (n!=0) cin>>m;
    }
    return 0;
} 
```

---

## 作者：Yuan1126 (赞：22)

并查集的思路。

第一次学，所以在代码上加了很多批注，各路大神也可以帮忙看看。。

并查集主要就是思想理解，代码还是很好实现的。

希望能帮到萌新们！！（也是我的提升(⊙o⊙)哦）




```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,ans=0;          //n城镇数目，m道路数目 
int pre[1005];              //用来存储父节点 
int find(int x)            //查找x的根节点 
{
    int r=x;                //用r来帮助查找x的根节点 
    while(pre[r]!=r)       //r的根节点不是他自己 
    {
        r=pre[r];          //pre[r]是r的父节点，就再向上查找一层 
    }                      //此时查到了x的根节点为r，返回 
    int i,j;               //路径压缩 
    i=x;
    while(pre[i]!=r)       //若一个数的父节点不是应查到的根节点r 
    {                      //即子节点i(也是x)并不是直接连在根节点r上的 
        j=pre[i];         //先记录i的父节点 
        pre[i]=r;         //让父节点直接等于根节点r 
        i=j;              //在把i的父节点j以同样方法向上查找 
    }
    return r;             //返回根节点 
}
void join(int r1,int r2)  //合并 
{
    int fr1=find(r1),fr2=find(r2);//查找两个数r1，r2的根节点 
    if(fr1!=fr2)          //若根节点不同 
    {
        pre[fr2]=fr1;      //合并 
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        pre[i]=i;          //建立新的集合，其仅有的成员是i；
    for(int i=1;i<=m;i++)
     {
         scanf("%d%d",&x,&y);//输入两个数，一个是路的起点，一个是终点
         int r1=find(x);
         int r2=find(y);
         if(r1!=r2) join(r1,r2);//判断元素是否在同一集合中；
     }
    for(int j=1;j<=n;j++)
    {
        if(pre[j]==j) ans++;
    }
    cout<<ans-1<<endl;
    return 0;
} 
```
另：推荐一篇文章，在CSDN博客上学习并查集看到的（好评很高）
讲得很好，用了一个特有爱的例子，清晰易懂（身为蒟蒻的我都看懂了）

链接：http://blog.csdn.net/dellaserss/article/details/7724401/


---

## 作者：Ticzone (赞：16)

## P1536 村村通
[题目链接](https://www.luogu.org/problemnew/show/P1536)  
这题粗略地看了一下，其实主要思想就是把已经连好的城镇看成一个点。那么，接下来定义一个数组（用作桶），来记录有多少个不同的点。设有$n$个点，那么就输出$n-1$就好啦。

$\mathcal{Code:}$  
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n=1,m;//n代表有多少个村庄，m是代表已有多少条路
int f[10000];//储存每个节点的“祖先”
void init()//预处理，一开始把每个结点的祖先设为自己
{
	for(int i=1;i<=n;i++)f[i]=i;
    //千万不能在输入前用此函数（n都没输入怎么预处理）
}
int find_(int x)//用到了路径压缩，比单纯的while更快
{
	if(f[x]==x)//如果x的祖先是自己
    	retrun x;//那么返回x就好了。
    return find_(f[x]);//如果不是的话，x的祖先的祖先就是x的祖先
}
void union_(int x,int y)//合并x,y两个结点
{
	f[find_(y)]=find_(x);//让x的祖先成为y的祖先的祖先，这样y所在的集合里所有结点的祖先全变为x的祖先。
}
int main()
{
	while(n!=0)
	{
		scanf("%d",&n);//输入n
		if(n!=0)//判断n是否等于0
			scanf("%d",&m);//是就输入m
		else//否则就跳过
			continue;
		if(m==0)//如果m（路的条数）等于0的话，那么想必就没有路了
		{
			printf("%d\n",n-1);//连起n个节点最少就要n-1条线
			continue;
		}
		init();//预处理
		int x,y;//定义x城镇的y城镇的编号
		int sum=0;//用于存储最少的路径条数
		int a[10000]={0};//桶，用于记录有多少个没有路径的城镇
		for(int i=1;i<=m;i++)
		{
			scanf("%d%d",&x,&y);//输入x and y的编号
			union_(x,y);//因为x y之间有路线了，就合并它们
		}
		for(int i=1;i<=n;i++)//开始判断
		{
			int c=find_(i);//判断编号为c的城镇的“祖先”
			if(!a[c])//如果这个“祖先”的编号没有被记录过的话
				a[c]++,sum++;//那么就记录它，节点数加一。
		}
		printf("%d\n",sum-1);//因为有n个不同的集合，那么就至少要n-1条边才能把它们连起来。
	}
    return 0;
}


```
以上就是本题的主要思想，其他巨佬们也可以用各种玄学数据结构来~~玩~~做这道题了。其实这道题可以用于给并查集入门的萌新们打基础，那么我来通俗地讲讲```并查集```到底是什么吧。

假设最开始，有一堆无依无靠的结点（可以把它们都看作一棵树），如下:  
![](https://cdn.luogu.com.cn/upload/pic/52115.png)

它们都很伤心，因为它们都很孤独。这时，上帝来了，他说:“$2$号有个朋友，它的名字叫$1$号！”这时，$1$号和$2$号便被一条边连了起来，成为了同一棵树（$1$号是$2$号的朋友，所以$1$号储存的值更改为$2$，其实反过来也可以）。如下：  
![](https://cdn.luogu.com.cn/upload/pic/52116.png)  

这时，上帝又说：“$1$号有个朋友，它的名字叫$5$号！”，这时，$1$号就为难了，它是该“归顺”$5$号，还是该“归顺”$2$号呢？这时，$1$号想到了一个办法：直接跟他的大哥（祖先：$2$号）谈！因为我们知道，朋友的朋友就是朋友，那么直接将$2$号的值赋值为$5$就好了（反过来也可以）！如下：  
![](https://cdn.luogu.com.cn/upload/pic/52120.png)  
接着，上帝说:“$3$号有个朋友，它的名字叫$7$号！”这时，我们运用刚才所说的方法，把$3,7$合并。如下:  
![](https://cdn.luogu.com.cn/upload/pic/52121.png)  
后来，上帝说：“$7$号有个朋友，它的名字叫$4$号！”这时，$7$号为难了，它是该“归顺”$4$号，还是该“归顺”$3$号呢？没关系，运用之前的方法，我们可以解决掉这个问题！  
![](https://cdn.luogu.com.cn/upload/pic/52163.png)  
上帝又说：“$8$号有个朋友，它的名字叫$6$号！”这时，你是不是觉得很$easy$?只需把$6,8$合并就好了！  
![](https://cdn.luogu.com.cn/upload/pic/52164.png)  
这时，稍微有点难度的来了，上帝说:“$2$号有个朋友，它的名字叫$6$号！”呀，是两个结点有$2$个以上的集合合并！该怎么办呢？不要慌，只需把$6$的祖先（$8$）设为$2$的祖先（$5$）即可！  
![](https://cdn.luogu.com.cn/upload/pic/52168.png)  
并查集中的“并”是不是很容易？那么让我们来看一看另一个操作———“查”吧！

让我们回到之前的内容———现在，每个人都有朋友了^_^，上帝现在想知道，谁和谁是（或者不是）朋友？  
此时，上帝问道：“$1$和$6$是朋友吗？”这时候，我们刚赋的值派上用场了！  
![](https://cdn.luogu.com.cn/upload/pic/52169.png)  
如图，红色箭头代表$6$号寻找祖先之路，绿色箭头代表$1$号寻找祖先之路，然后，他们找到了共同的祖先，“朋友的朋友就是朋友”，既然他们有共同的朋友（祖先），那么他们就是朋友了！  
然后，上帝又问道：“$2$和$7$是朋友吗？”再次运用刚才的方法，可得到如下图：  
![](https://cdn.luogu.com.cn/upload/pic/52167.png)  
橙色箭头代表$2$号寻找祖先之路，蓝色箭头代表$7$号寻找祖先之路，最终，他们的祖先并不一样（分别是$5$和$4$）。既然他们的祖先都不一样，那么他们就绝对不是朋友（不在同一集合）。   
如果你理解了以上讲的内容，那么你就理解了并查集的精髓了！并查集的“并”、“查”操作可以在上面找到。去看一看吧！  
但是，聪明的人会问：找$1$和$6$的朋友时，其实可以建一条边，使$8$可以直接到达$5$。对，没错！这就是———路径压缩！  
其实，路径压缩只需在“查”时加五个字符即可！  
$\mathcal{Code}$
```cpp
int find_(int x)
{
    if(f[x]==x)
        return x;
    return f[x]=find_(f[x]);
}
```  
这样，寻找$1$和$6$的祖先时，就会变成下图！  
![](https://cdn.luogu.com.cn/upload/pic/52172.png)  
同理，寻找$2$和$7$祖先时，就会变成下图！  
![](https://cdn.luogu.com.cn/upload/pic/52166.png)  
是不是感觉快了很多？其实，并查集是很简单的。以下是我给大家推荐的题目：  
- [P3367 【模板】并查集](https://www.luogu.org/problemnew/show/P3367)
- [P1551 亲戚 ](https://www.luogu.org/problemnew/show/P1551)
- [P2256 一中校运会之百米跑](https://www.luogu.org/problemnew/show/P2256)    

---

## 作者：Rocket_raccoon_ (赞：15)

说句实话，这题用并查集写非常简单，几乎是裸题。各位大佬用各种高深算法来写这种简单的题目实在没什么必要（吐槽一下）。

并查集是个什么东西呢？实现起来非常简单（详见find函数，两行代码），但是可以快速的解决 集合合并 并且找出某个元素属于哪个集合的问题（通俗的说），不会的同学可以[戳这里](https://blog.csdn.net/u013546077/article/details/64509038)

我们每输入一条道路，只需要找这两个道路是否在同一集合，如果不在一个集合就将ans减一（已经连好了，不需要再修路），注意ans的初值是n-1，因为把所有点连起来与用这些点构造一棵树是等价的（至少从答案上来说）。

代码比较简洁

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int f[66666];
int find(int x){//find函数
	if (f[x]==x) return x;
	else return f[x]=find(f[x]);
}
int main(){
	int i,n,m,x,y,ans;
	
	while (cin>>n>>m){//如果还能输入n,m就输入（懒得多写代码）
		ans=n-1;//ans赋初值
		for (i=1; i<=n; i++){
			f[i]=i;//并查集初始化
		}
		for (i=1; i<=m; i++){
			scanf("%d%d",&x,&y);//输入道路的头和尾
			x=find(x); y=find(y);//找出头尾属于哪个集合
			if  (x==y) continue;//如果是同一集合就不管
			f[x]=y;//集合合并
			ans--;
		}
		printf("%d\n",ans);//输出答案
	}	
	return 0;
} 
```

---

## 作者：Xuefengyyds (赞：7)

题目直通车：[P1536 村村通](https://www.luogu.org/problemnew/show/P1536)

大概看了一下底下daolao的题解，发现好像没有和我完全一样的

~~一定要过呀~~

## **进入正题**

看到这题很容易想到的一种方法就是**并查集**

今天刚好学了并查集，就拿这题来练练手

我的思路是先将提供的路径合并，然后未联通的路径连接起来，答案+1

#### 话不多说，上代码  (解释都在代码里了)

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000001],ans=0;
int find(int k){ //find函数 (寻找 "父亲") 
	if(f[k]==k) return k;
	else return f[k]=find(f[k]);
}
void pin(int x,int y){ //进行连接的函数 (我为什么要写这个函数？？？) 
	f[find(x)]=find(y);
}
int main(){
	int a,b;
	while(1){
		ans=0; //答案de计数器 
		cin>>a;
		if(a==0) return 0; //判断是否退出程序 
		cin>>b;
		for(int i=1;i<=a;i++) f[i]=i; //初始化 
		for(int i=1;i<=b;i++){
			int x,y;
			cin>>x>>y;
			pin(x,y); //连接提供的路径 
		}
		//开始计算还需要的路径 
		for(int i=1;i<a;i++){
			if(find(f[i])==find(f[i+1])){ //前后乡村联通 (好像要不要这句都无所谓)
				continue;
			}else{ //如果前后乡村未联通
				pin(i,i+1); //进行连接 
				ans++; //答案+1 
			}
		}
		cout<<ans<<"\n"; //输出答案 
	}
	return 0;
}
```
**本蒟蒻发题解不易，请各位daolao轻喷**

~~**求过啊**~~

---

## 作者：AuroraIris (赞：6)

并查集的简单题好像每道都一样

```cpp
var n,m,i,x,y,r1,r2,ans:longint;
father:array[0..100000] of longint;
a:array[0..100000] of boolean;
function find(x:longint):longint;//找父节点
begin
if father[x]<>x then father[x]:=find(father[x]);
find:=father[x];
end;
begin
read(n);
while n>0 do//题中说n为0时结束
begin
readln(m);
for i:=1 to m do//初始父节点指向自己
father[i]:=1;
ans:=n;
for i:=1 to m do//合并
begin
readln(x,y);
r1:=find(x);
r2:=find(y);//找出两个点的祖先
if r1<>r2 then//合并祖先
begin
dec(ans);//解释在下面
father[r1]:=r1;
end;
end;
writeln(ans-1);
read(n);
end;
end.
```
解释一下ans
不理解为甚要独立再做一个

只要ans每次赋村庄数即可

联通一个减一

剩下来的-1就是还未联通的

好像叫什么克鲁斯卡尔

做了一点小手脚~


---

## 作者：Guzx (赞：3)

### 本蒟蒻第一次发题解，请各位大佬多多包涵~~

其实本题可以用kruskal来做，只要记录一下有哪几个村庄通了，跑一下kruskal，再用一个变量来记录有几个节点被合并，减一个n，就OK了！

    
    
    
    
```cpp
    #include <iostream>
    #include <algorithm>
    #define INF 99999999
    using namespace std;
    int n,m,s,t;
    int i,j;
    int dad[1000 + 1];//每个节点属于的父亲集合
    struct edge
    {
        int xi,yi;
    }k[100000+1];
    int getfather (int x)//找父亲
    {
        if (x == dad[x])
            return x;
        dad[x] = getfather(dad[x]);
        return dad[x];
    }
    void kruskal()
    {
        int p = 1;//这里p = 1就可以直接n - p
        for (i = 1;i <= n;i ++)
        {
            dad[i]=i;//初始化
        }   
        for (i = 1;i <= m;i ++)
        {
               if (getfather(k[i].xi) != getfather(k[i].yi))//判断是否为同一个集合
            {
                   dad[getfather(k[i].xi)] = k[i].yi;//合并集合
                   p ++;//记录合并
               }
        }
        cout << n - p << '\n';//输出
        return ;
    }
    int main ()
    {
        while (1)
        {
            cin >> n >>m;
            if (n == 0)//当n == 0时退出循环
                break; 
            for (i = 1;i <= m;i ++)
            {
                 cin >> k[i].xi >> k[i].yi;//记录哪几个村庄相通
            }
            kruskal ();
        }
        return 0;
}
```

---

## 作者：Drug__Lover (赞：3)

**- 因为是需要的最少的道路的条数**

**- 所以我们可以把这些城（cun）市（zhuang）想成一条链**

**- 那么这条链上的所有元素联通所需要的道路条数最少即为n-1**

**- 我们每联通两个城市都需要一条道路**

**- 那么所需要建造的道路的条数就是总共的n-1条减去已建造的道路的条数**

**- 这样就保证了所需的道路的条数是最少的**

------------------------------------------------------------------------------------------------------------------------

```cpp
#include"stdafx.h"
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int n,m;
int f[1001];
int find(int x)       //找祖宗，递归+压缩路径
{
    if(f[x]!=x) f[x]=find(f[x]);   //递归过程中顺便把路上的父亲的祖宗更改过来，便于后面查找时方便（后面递归层数少）
    return f[x];
}
int main()
{
    cin>>n;
    while(n!=0)         //n不为0时输入
    {
        int ans=0;
        cin>>m;
        for(int i=1;i<=n;i++)
            f[i]=i;
        for(int i=1;i<=m;i++)
        {
            int a,b;
            cin>>a>>b;       //将a,b两个城（cun）市（zhuang）联通
            if(find(a)!=find(b))        //两个城（cun）市（zhuang）未联通
            {
                f[find(a)]=find(b);      //将这两个城（cun）市（zhuang）联通，并且与这两个城（cun）市（zhuang）相通的城（cun）市（zhuang）也相通
                ans++;         //记录下已经联通的城（cun）市（zhuang）的道路需要的条数
            }
        }
        cout<<n-1-ans<<endl;     //n个城（cun）市（zhuang）联通最少需要n-1条路，再减去已经连通的道路（ans）就是所需建造的道路
        cin>>n;         //输入下一个n
    }
    return 0;
}

```

---

## 作者：艾蕾 (赞：3)

我的做法大概就是找n个点中的联通块个数，每个联通块都可以看成一个点，那么将他们全部联通需要的边数就是联通块个数-1，找联通块的话可以用并查集，但是已经有很多并查集的题解了所以我用的是另一种方法，感觉实现起来比并查集要容易一些。具体实现方法就是从1~n一个个找，如果这个点还没有被标记（还没有在任何一个联通块里）则搜索一遍这个点能到达的所有点并加上标记，然后联通块的个数+1，求出联通块的个数之后答案就是联通块个数-1

下面是代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int w[1001][1001],n,m,u,v,sum;//w[i][j]表示i和j是否有边相连 sum记录联通块个数  
bool vis[1001];//记录点是否在联通块里 
void dfs(int x){
    vis[x]=1;//走过的点标记防止重复走
    for(int i=1;i<=n;i++)
        if(w[x][i]&&!vis[i])//找到一个与x相连且未走过的点并继续搜索 
            dfs(i);
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&u,&v);
        w[u][v]=w[v][u]=1;//标记两点是否相连
    }
    for(int i=1;i<=n;i++)
        if(!vis[i]){//若当前的点没有走过则说明发现了一个新的联通块
            sum++; 
            dfs(i);
        }
    printf("%d",sum-1);//sum个联通块用sum-1条边即可将其全部连接
    return 0;
}
```

---

## 作者：dzysc (赞：2)

并查集的思路应该非常显然，居然有楼下大佬愿意写塔洋缩点我也无法可说。

简单讲述一下思路，并查集大概的思路就是

每次我们读入一条边，那么说明这边相连的两个点就是在同一个联通快之中的

并且这个题目说实在话意思就是对于每组输入数据，要求找到连通块个数，并且输出

个数减一。

为什么是个数减一呢？学过树的都知道，树就是最简单的连通图，我们要建成一颗

树，n个节点势必要n-1个边，这就非常显然了，并查集就是用来检索联通快的高效方

法，废话不多说上代码。相信大家并查集的基本方法都会的，这里不赘述。
```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int father[100001];
int visited[10001];
int find(int x)
{
	if(father[x]!=x)father[x]=find(father[x]);
	return father[x];
}

int main()
{
	while(1)
	{
		int n,m;
		cin>>n>>m;
		if(n==0)break;
		for(int i=1;i<=n;i++)father[i]=i;
		for(int i=1;i<=m;i++)
		{
			int u,v;
			cin>>u>>v;
			if(u>v)swap(u,v);
			int uu=find(u);int vv=find(v);
			if(father[uu]!=father[vv])
				father[vv]=uu;
		}
		for(int i=1;i<=n;i++)visited[i]=0;
		int ans=0;
		for(int i=1;i<=n;i++)
		{
			if(visited[father[find(i)]]==0)
			{
				ans++;
				visited[father[find(i)]]=1;
			}
		}
		if(ans==0)cout<<0<<endl;else cout<<ans-1<<endl;
	}
	return 0;
} 
```

---

## 作者：gravf (赞：1)

主要是并查集的思路：

step1：认爹

step2：有几个家庭

step3：输出家庭数减一（植树问题）


第一步没什么好讲的，模版


第二步就是把所有的城市搜一遍，看看有没有自己是自己爸爸的


第三步输出家庭数减一


下面是充满蒟蒻气息的代码：

```cpp
#include<cstdio>
using namespace std;
int father[1001];
long long pc=0;
int find(int a)
{
    if(father[a]!=a) father[a]=find(father[a]);
    return father[a];
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        father[i]=i;
    }
    for(int i=0,a,b,fa,fb;i<m;i++)
    {
        scanf("%d%d",&a,&b);
        fa=find(a);  
        fb=find(b);
        if (fa!=fb) father[fa]=fb;
    }
    for(int i=1;i<=n;i++)
    {
        if(father[i]==i) pc++;
    }
    printf("%lld",pc-1);
    return 0;
}
```
省政府太蒟蒻了，这都不会（划掉）


---

## 作者：LMB_001 (赞：1)

我用的并查集，亲戚的亲戚就是你的亲戚！求大家不喜勿喷

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[5050];//存储一个节点的父亲节点是谁
int find(int x){
    if (f[x]==x) return x;
    else return find(f[x]);
```
}//用递归判断一个节点的祖宗节点是谁，记住，父亲的祖宗就是你的祖宗！
```cpp
int main(){
    int root1,root2,n,m,i,a,b,j,s=0;
    cin>>n>>m;
    for (i=1;i<=n;i++) f[i]=i;
    for (i=1;i<=m;i++){
        cin>>a>>b;
        root1=find(a);//a的祖宗
        root2=find(b);//b的祖宗
        if (root1!=root2) f[root2]=root1;//如果他们的祖宗不是同一个人，现在a和b是亲戚，就把a的祖宗设为b的祖宗的父亲，这两个谁是谁的父亲无所谓，因为他们是无向的
    }
    for (i=1;i<=n;i++)
        if (f[i]==i) s++;//如果一个点的父亲节点是自己，说明这个点和别的点没有联通，s记的是这样点的数量
    cout<<s-1;//s个点之间只要s-1线
    return 0;
}
```

---

## 作者：Deny_小田 (赞：1)

超简单并查集不解释。


赠送C++代码。

```cpp
#include <cstdio>
const int size = 100005;
int father[size],n,m,ans;
int getfather(int x){
    if(father[x] == x) return x;
    else return father[x] = getfather(father[x]);
}
void Union(int x, int y){
    int fx = getfather(x);
    int fy = getfather(y);
    if(fx != fy) father[fy] = fx;
}
int main(){
    int x,y;
    scanf("%d %d",&n,&m);
    for(int i = 1; i <= n; i++) father[i] = i;
    for(int i = 1; i <= m; i++){
        scanf("%d %d",&x,&y);
        Union(x, y);
    }
    for(int i = 1; i <= n; i++){
        if(father[i] == i) ans++;
    }
    printf("%d\n",ans-1);
    return 0;
}
```cpp

---

## 作者：Created_equal1 (赞：1)

求出这个无向图联通分量的个数，再-1就是答案（将所有联通分量用边连接在一起）。

求联通分量个数可以用并查集来求


---

## 作者：ljc20020730 (赞：1)

像这种多个散点的联合关系类的题目，

用并查集就好，能很快又完美地解决我们的问题。

这题的并查集就非常的裸。

查找元素所在的集合，即根节点。

合并 将两个元素所在的集合合并为一个集合。

通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。

统计联通块的个数时没必要枚举啊，完全可以O(1)统计出

维护一个CNT，表示此时的联通块的个数，初始时CNT=N， 因为每次连通操作都会使连通块个数-1，所以只要每次--CNT就可以了

树n-1个点

ans为cnt-1



```cpp
var n,m,i,j,cnt,fx,fy,x,y:longint;
    f:array[1..1000]of longint;
function father(x:longint):longint;
begin
 if f[x]=x then exit(x);
 f[x]:=father(f[x]);
 exit(f[x]);
end;
begin
 readln(n,m);
 cnt:=n;
 for i:=1 to n do f[i]:=i;
 for i:=1 to m do begin
  readln(x,y);
  fx:=father(x);
  fy:=father(y);
  if fx<>fy then begin
   dec(cnt);
   f[fx]:=fy;
  end;
 end;
 writeln(cnt-1);
end.
```

---

## 作者：Sooke (赞：1)

像这种多个散点的联合关系类的题目，用并查集就好，能很快又完美地解决我们的问题。这题的并查集就非常的裸。

并查集的做法很简单，也和下面的题解差不多，这里就不提了。但最后与下面的题解做法不同。最后求答案的方式，我是使用 STL 中的容器 set，由于一开始 set 就是空的，得到每个城市的最终的上级，也就是老大时，我们将每个城市的老大编号都投入 set 里去，依赖 set 的去重来得出答案。这样做的原理是每个村庄修完公路后可能不是个连通图，而是分成好几个连通图，但分散的连通图的老大是一样的，老大的数目就是分散的连通图的数目。想要连接各个分散的图，仅需要 图的数量 减去一 条边，也就是公路。运用上面使用 set 的方法求出老大的数目，另外再减去一，不就是答案了？

习惯加了读入优化，去掉读入优化主程序代码还是非常精炼的：

```cpp
#include <cstdio>
#include <set>
#define f(i , n) for(int i=1 ; i <= n ; i++)
using namespace std;
set < int > S;
int v[1000];
inline int Input(){
    char C=getchar();
    int N=0;
    while('0' >  C || C >  '9') C=getchar(); 
    while('0' <= C && C <= '9') N=N*10 + (C-'0') , C=getchar();
    return N;
}
int Find(int n){
    return v[n] == n ? n : (v[n]=Find(v[n]));
}
int main(){
    int n=Input() , m=Input();
    f(i , n) v[i]=i;
    f(i , m) v[Find(Input())]=v[Find(Input())];
    f(i , n) S.insert(Find(v[i]));
    printf("%d\n" , S.size()-1);
    return 0;
}
```

---

## 作者：Porsche (赞：1)

看见靠多人都用最小生成树，居然还有用深搜的大佬，我一个只用了并查集就AC的蒟蒻突然想秀一秀……

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int f[20001];//并查集数组
int ans;//输出
int find(int x)//会并查集的都知道的find函数
{
    return f[x]==x?x:f[x]=find(f[x]);//路径压缩
}
int main()
{
    int n,m;
    int x,y;
    while(1)
    {
        scanf("%d",&n);//输入城镇数目
        if(n==0)return 0;//若城镇数目为0则会跳出循环
        scanf("%d",&m);//输入道路数目
        for(int i=1;i<=n;i++)
            f[i]=i;//初始化
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d",&x,&y);
            f[find(x)]=find(y);//找出每一个点的根
        }
        for(int i=1;i<=n;i++)
            f[i]=find(i);//再扫一遍根，避免出现像样例的第二组数据出现的情况
        sort(f+1,f+n+1);//利用sort将跟是一样的数放到一起
        for(int i=2;i<=n;i++)
            if(f[i]!=f[i-1])ans++;//若相邻两个数不一样的话表示这两个数的跟不一样
        cout<<ans<<endl;//输出
        ans=0;
    }
    return 0;
}
```

---

## 作者：星之海 (赞：1)

```cpp
#include<stdio.h>
int father[1010];
int find(int x)
{
    if(father[x]!=x)
    father[x]=find(father[x]);//find优化
    return father[x];
}
void combine(int x,int y)
{
    int r1,r2;
    r1=find(x);
    r2=find(y);
    if(r1!=r2)//他们不是一个祖先
    father[r2]=r1;//合并
}
int main()
{
    int n,m,sum,i,j,x,y;
    while(scanf("%d",&n)!=0)
{
    if(n==0)
    break;//这句一定要加，不然会10个点全部超时
    for(j=1;j<=n;j++)
    father[j]=j;//father初始化
    scanf("%d",&m);
    sum=0;
    for(i=1;i<=m;i++)
{
    scanf("%d %d",&x,&y);
    combine(x,y);//合并
}
    for(i=1;i<=n;i++)
    if(father[i]==i)//指向自己
    sum++;
    printf("%d\n",sum-1);//有sum个点，则有sum-1条线
}
    return 0;
}//结束程序 就这样
```

---

## 作者：Sakura_Peng (赞：0)

**最近在练并查集
先从模板题练起...**

因为并查集合并思想是：

**将两个二叉树合并，在其中只有一个根节点。**

所以如果每条路全部连通的话就必须只有一个地点所标识的根节点是他自己。所以在扫描的时候如果遇见是自己根节点是自己的就是未被连接到一起的。（除“大树”的根节点）

程序如下：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int fa[10001],n,m,ans;
int find(int x)
{
	return x==fa[x]?x:fa[x]=find(fa[x]);
}  //并查集压缩路径
void he(int x,int y)
{
	int x1=find(x),x2=find(y);
	fa[x2]=x1;
	return ;
}
int main()
{	
	while(1)
	{
		ans=0;
		//memset(fa,0,sizeof(fa));
		scanf("%d%d",&n,&m);
		if (n==0)
		break;
		for (int i=1;i<=n;i++)
		fa[i]=i;
		for (int i=1;i<=m;i++)
		{
			int x,y;
			scanf("%d%d",&x,&y);
			he(x,y);
		}   //将他们合并
		for (int i=1;i<=n;i++)
		if (find(fa[i])==i)
		ans++;   
	    printf("%d\n",ans-1); 
   //在自己的祖先是自己的情况下还会有一个确实是大树根节点而不是未被连接在一起的点，所以需要把那个点减去
	}
	return 0;
} 

```

---

## 作者：xukuan (赞：0)

语言：pas/cpp

将有路相连的点并入同一个集中，最后算有几个点的父节点是本身，

##输出个数要-1，因为n个点的最小生成树有n-1条边！


```pascal
var
 i,n,m,x,y,f1,f2,count:longint;
 father:array[0..1010] of longint;

function searchfather(v:longint):longint;//寻找父节点
 begin
  if father[v]=v then searchfather:=v//父节点是本身
                 else searchfather:=searchfather(father[v]);
  father[v]:=searchfather;//路径压缩
end;

begin
 read(n);
 while n<>0 do
  begin
   readln(m);
   for i:=1 to n do father[i]:=i;//初始化

   for i:=1 to m do
    begin
     readln(x,y);
     f1:=searchfather(x);
     f2:=searchfather(y);
     if father[f1]<>father[f2] then father[f1]:=f2;//当它们不在同一个集时并入
    end;

# count:=-1;//初值赋成-1！！！
   for i:=1 to n do
    if father[i]=i then inc(count);//计数器加1
   writeln(count);
   read(n);
  end;
end.
```

```cpp
#include<iostream>
using namespace std;
int n,m,x,y,f1,f2,count,father[1010];

int searchfather(int v)//寻找父节点
{
    if (father[v]==v) return v;//父节点是本身
    else
    {
        father[v]=searchfather(father[v]);//路径压缩
        return father[v];
    }
}
int main()
{
    cin>>n;
    while(n!=0)
    {
        cin>>m;
        for(int i=1; i<=n; i++) father[i]=i;//初始化
        
        for(int i=1; i<=m; i++)
        {
            cin>>x>>y;
            f1=searchfather(x);
            f2=searchfather(y);
            if(father[f1]!=father[f2]) father[f1]=f2;//当它们不在同一个集时并入
        }
        
#        count=-1;//初值赋成-1！！！
        for(int i=1; i<=n; i++)
         if(father[i]==i) count++;//计数器加1
        cout<<count<<endl;
        cin>>n;
    }
    return 0;
}
```

---

## 作者：封癫 (赞：0)

思路如下

读入边并将他们所连的点都用并查集连起来

然后查找father 数组 如果father[i]==i则说明它是以他为父节点这一片（城市）区的中心

最后将ans个中心连接起来需要ans-1条路

然后就做完了

其实这题跟最小生成树没啥关系 除非把它想成路径长度都是一的最小生成树

那不就是并查集么

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
template <typename T>
T read(){
    T num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num\*10+ch-'0';
        ch=getchar();
    }
    return num\*f;
}
#define read()    read<long long>()
int father[500000];
int find(int x){
    if(father[x]!=x)    father[x]=find(father[x]);
    return father[x];
}

void unionn(int x,int y){
    x=find(x);y=find(y);
    father[y]=x;
}
using namespace std;

int main(){
    int n,m,ans=0;
    while(cin>>n&&n!=0){
        m=read();
        for(int i=1;i<=n;++i)
            father[i]=i;
        for(int i=1;i<=m;++i){
            int x=read(),y=read();
            unionn(x,y);
        }
        for(int i=1;i<=n;++i){
            if(father[i]==i)    ans++;
        }
        printf(">>>>>>>>>>>>%d\n",ans-1);
        ans=0;
    }
    return 0;
}

---

## 作者：DDullahan (赞：0)

看见各路大神都写的并查集的代码

我决定敲一个递归来水一水。毕竟技术含量很少（其实是自己想写一个新型的并查集  结果gg了****/害羞****）


思路：

经过题目的路径连通后 必然会产生****>=1****的片图（即相互独立的图）。而我们要做的就是讲这些片图连接起来  ****如果将每个片图都看作一个集合的话  其实就是给 n 个点连线****  当然答案就是n-1了


所以我就搞了个递归的做法 类似于连通块（多亏数据范围小）


上代码：（欢迎评论交流）

···cpp

        
```cpp
#define MAXN 1005
bool road[MAXN];
int Map[MAXN][MAXN];
int n,m;
void dfs(int x)
{
    road[x]=false;
    for(int i=1;i<=n;i++)
        if(road[i]&&Map[x][i])
            dfs(i);
}
int main() {
#ifdef LOCAL
    freopen("sample.in", "r", stdin);
#endif
    //ios::sync_with_stdio(false);
    while(scanf("%d",&n),n)
    {   
        scanf("%d",&m);
        int a,b;
        memset(Map,0,sizeof(Map));//多组测试还是要记住  交题时傻逼了一次
        memset(road,true,sizeof(road));
        for(int i=0;i<m;i++)
        {
            scanf("%d%d",&a,&b);
            Map[a][b]=1;Map[b][a]=1;
        }
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            if(road[i])
            {
                ans++;//因为是实时更新访问点  可以直接对答案做出贡献
                dfs(i);
            }
        }
        cout<<ans-1<<endl;
    }
    return 0;
}
```
/\* 分割线from DDullahan
\* 代码少复制终结者\*/


ps： KEKE 包佬真是太可爱了


---

## 作者：PTC06 (赞：0)

裸的并查集。

由于题目中说“是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可”，所以可以看出是并查集。

思路：

先读入N。

然后，用一个while循环，循环的条件是n!=0，即题目中说的条件。

```cpp
    while (n!=0)
    {
        ans=0;
        scanf("%d",&m);
        for (i=1;i<=n;i++)             //初始化，学过并查集的应该都看得懂。
        {
            pre[i]=i;
        }
        for (i=1;i<=m;i++)
        {
            cin>>a1>>a2;
            join(a1,a2);         //将给出的a1和a2（已经有路的村子）连起来。
        }
```
其中，join的具体步骤是这样：
```cpp
int sch(int x)
{
    if (pre[x]==x) return pre[x];       //搜索每一个村庄的祖先，返回值是它的祖先的值。
    pre[x]=sch(pre[x]);
    return pre[x];
}
void join(int x,int y)
{
    if (sch(x)!=sch(y))        //如果两个村子的祖先不一样，说明它们没有连在一起。
    {
        ans++;                 //那么已经修了的路就增加。
        pre[sch(x)]=sch(y);    //连起来。
    }
}
```
最后输出ans就可以了。
程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,i,n,m,a1,a2,pre[10000];
int sch(int x)
{
    if (pre[x]==x) return pre[x];
    pre[x]=sch(pre[x]);
    return pre[x];
}
void join(int x,int y)
{
    if (sch(x)!=sch(y))
    {
        ans++;
        pre[sch(x)]=sch(y);
    }
}
int main()
{
    scanf("%d",&n);
    while (n!=0)
    {
        ans=0;
        scanf("%d",&m);
        for (i=1;i<=n;i++)
        {
            pre[i]=i;
        }
        for (i=1;i<=m;i++)
        {
            cin>>a1>>a2;
            join(a1,a2);
        }
        ans=n-ans-1;             //总数n减去已经修了的，剩下的就是还需要修的。
        printf("%d\n",ans);      //输出
        cin>>n;            //再次读入n
    }
}
```

---

## 作者：zclzslz (赞：0)

        
```cpp
//看了楼下的题解感觉自己是个蒟蒻。。。
//最后处理答案时，我枚举每个点，看他与其他点是否联通，如果不连通就合并，记录答案
//感觉有点弱。。。
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int f[1005],ans;
int find(int x)
{
    if(f[x]!=x)
    f[x]=find(f[x]);
    return f[x];
}
void UN(int x,int y)
{
    int a=find(x);
    int b=find(y);
    f[a]=b;
}
int Read()
{
    int num(0);
    int flag(0);
    char a;
    while(!isdigit(a=getchar())&&a!='-');
    if(a=='-')
    flag=1;
    else
    num=a-'0';
    while(isdigit(a=getchar()))
    {
        num=num*10+a-'0';
    }
    if(flag)return num*-1;
    return num;
}
int n,m;
void handle()
{
    n=Read();m=Read();
    for(int i=1;i<=n;i++)
    f[i]=i;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        x=Read();
        y=Read();
        UN(x,y);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            int now=find(i);
            int now2=find(j);
            if(now!=now2)
            {
                ans++;
                UN(i,j);
            }
        }
    }
    printf("%d\n",ans);
    return ;
}
int main()
{
    handle();
    return 0;
}
```
/\*
3 3
1 2
1 2
2 1
\*/

---

## 作者：ghj1222 (赞：0)

发一个简单的，大家都能看懂的

```cpp
#include <iostream>
using namespace std;
int f[1001];
int getf(int x)//经典的递归找爹+路径压缩
{
    return f[x]==x?x:f[x]=getf(f[x]);
}
int main()
{
    int n,m,t1,t2,ans=-1;//为什么ans=-1呢？
    cin >> n >> m;
    for(int i=1;i<=n;i++)//并查集初始化
        f[i]=i;
    for(int i=1;i<=m;i++)
    {
        cin >> t1 >> t2;//读入
        f[getf(t1)]=getf(t2);//合并并查集
    }
    for(int i=1;i<=n;i++)
        if(f[i]==i)ans++;//如果某一个节点的父亲是自己，说明他带领了一个连通块儿
    cout << ans << endl;
    return 0;
}
```

---

## 作者：vegetabird (赞：0)

发一个CPP的

```cpp
#include<cstdio>
#include<vector>
using namespace std;
int n,m;
int father[1010];                            表示父节点
int a,b;
vector<int> fa;
int findfa(int u){                            寻找一个节点的根
    while(father[u]!=u){
        u=father[u];
    }
    return u;
}
void comb(int x,int y){                        将两个并查集合并
    father[findfa(y)]=findfa(x);
}
int main(){
    int i,j;
    bool dif;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++){
        father[i]=i;                        初始化：每个节点都是一个并查集
    }
    for(i=1;i<=m;i++){
        scanf("%d%d",&a,&b);                读入边
        comb(a,b);                        将边两边的节点所属并查集合并
    }
    for(i=1;i<=n;i++){                        记录并查集总数
        dif=true;
        for(j=0;j<fa.size();j++){
            if(fa[j]==findfa(i)){
                dif=false;
                break;
            }
        }
        if(dif){
            fa.push_back(findfa(i));
        }
    }
    printf("%d\n",fa.size()-1);                连接所有并查集需要的边数
    return 0;
}
```

---

## 作者：飞翔 (赞：0)

```cpp
var
  father:array[1..1000]of longint;
    i,j,n,q,ans,x,y:longint;
function search(x:longint):longint;//寻找父节点
begin
  if father[x]<>x then father[x]:=search(father[x]);
  exit(father[x]);
end;
procedure judge(x,y:longint);//合并
var a,b:longint;
begin
  a:=search(x); b:=search(y);
  if a<>b then father[b]:=a;
end;
begin
  readln(n,q);
    for i:=1 to n do father[i]:=i;
    for i:=1 to q do begin
      readln(x,y);
        judge(x,y);//并查集的基本操作，我懒得说了
    end;
    ans:=0;
    for i:=1 to n do
      if father[i]=i then inc(ans);//发现孤点
    write(ans-1);
end.
```

---

## 作者：pupuvovovovovo (赞：0)

放pas代码。

并查集的简单题。

```cpp
var i,n,m,x,y,a,b,ans:longint;
fa:array [1..1000] of longint;
function ask(x:longint):longint;
begin
  if fa[x]=x then exit(fa[x]);
  fa[x]:=ask(fa[x]);
  exit(fa[x]);
end;
begin
  read(n);
  while n>0 do
  begin
    read(m);
    for i:=1 to n do
    fa[i]:=i;//每组数据先清空
    for i:=1 to m do
    begin
      read(x,y);
      a:=ask(x);
      b:=ask(y);
      if a<>b then fa[a]:=b;//有边相连，同一集合
    end;
    for i:=1 to n do
    if ask(i)=i then inc(ans);//统计集合个数
    writeln(‘sbsbsb’);//有几个集合，就只要***条边便可联通
    ans:=0;
    read(n);
  end;
end.
```

---

## 作者：tzj666 (赞：0)

`
大佬们都写得如此** 详细**，在下一名蒟蒻，只能根据自己的理解来写题解，所以显得有些不专业，请多多指教
------------



```
优化：
     while(lx != cx)   //路径压缩
    {
         sum = fa[lx];//在改变上一个点之前用sum记录下他的值 
         fa[lx]= cx ; //把上一个点改为根节点
         lx = sum;
     }
_______________________________//分割线

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int fa[1001],n,t,m,a,b,ans = 0,vis[1001];
int find(int x)//并查集核心，找根节点
{
	int cx = x;
	while(cx != fa[cx]) cx = fa[cx];//如果自己不是根节点就一直找直到找到为止 
	return cx;
	int sum,lx = x;
    while(lx != cx)   //路径压缩
    {
         sum = fa[lx];//在改变上一个点之前用sum记录下他的值 
         fa[lx]= cx ; //把上一个点改为根节点
         lx = sum;
    }
}
void mix(int a,int b)//合并 
{
	int aa,bb;
	aa = find(a);//aa为a的根节点 
	bb = find(b);//同上 
	if(aa != bb)//如果两个的根节点不同 
	fa[bb] = aa;//那就只好让aa作bb的父亲，有点———— 
}
int main()
{
	while(scanf("%d%d",&n,&m) != EOF && n != 0)//输入 
	{
		for(int i = 1;i <= n;i++)
		fa[i] = i;//初始化，一开始每个人的父亲都是自己 
		for(int i = 1;i <= m;i++)
		{
			scanf("%d%d",&a,&b);
			mix(a,b);//合并这两个点 
		}	
		memset(vis,0,sizeof vis);//因为有多组数据，每次都要初始化 
		for(int i = 1;i <= n;i++)
		{
			vis[find(i)] = 1;//vis[i] = 1，因为与i有关系的点之间都有路可通，就不需要再修路了 
		}
		ans = 0;//一定记得初始化，我一开始忘了 
		for(int i = 1;i <= n;i++)
		if(vis[i] != 0) ans++;//发现一个没有点与他连接的点，ans++ 
		printf("%d\n",ans - 1);//千万莫忘记，边 = 点 - 1； 
	}
	return 0;
}
```
```

---

## 作者：Ash1mar (赞：0)

本人使用kruskal算法。。。由于kruskal基于并查集。。。所以就当是一下练习了两次；

先krusal求出联通的边。。。如果等于点的总数减一（n-1），

也就是说全部连通（因为两点之间有一条边，n个点之间有n-1条边）；如果不全部连通，n-1减去联通的边树就是剩下需要的边数


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=200005;
int n,m;
int father[maxn],sum,cnt;
struct node
{
    int u;
    int v;
    int val;
}edge[maxn];
int find(int v)//并查集寻找公共祖先的函数
{
    if(father[v]==v)
        return v;
    else
    {
        //路径压缩
        father[v]=find(father[v]);
        return father[v];
    }
}
bool join(int v,int u)
{
    int x,y;
    x=find(v);
    y=find(u);
    if(x!=y)
    {
        father[y]=x;
        return true;
    }
    return false;
}
//合并两个并查集*/
//按照权值w从小到大将结构体排序
bool operator < (node a,node b)
{
    return a.val < b.val;
}
/*bool cmp(node a,node b)
{
    return a.val<b.val;
}*/
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d",&edge[i].u,&edge[i].v);
    }
    sort(edge+1,edge+m+1);
    //并查集初始化
    for(int i=1;i<=n;i++)
    {
        father[i]=i;
    }
    //kruskal算法
    for(int i=1;i<=m;i++)
    {
        if(join(edge[i].u,edge[i].v))
        {
            cnt++;
        }
        if(cnt==n-1)
        {
            cout<<0;//如果边数等于n-1，则不需要加边 
            return 0;
        }
    }
    cout<<n-1-cnt;//否则输出还需要多少条边 
    return 0;
}
```

---

## 作者：龘龘龘龘龘龘 (赞：0)

这一题很水超级水，几乎是并查集模板，本人也很弱鸡，连特判都写错了（n写成了m），我也是醉了，一怒之下删了特判才过得，后来看了楼下dalao的才发现错了；

这一题是用路径压缩优化解的，很简单，就是本蒟蒻太菜了，细节没注意哎，

以下是我的代码，仅供参考，不要抄袭，

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define maxn 20001
int father[maxn];
int n,m,i,x,y,ans=0;
int find(int x)//寻找根结点编号并压缩路径
{
    if(father[x]!=x) father[x]=find(father[x]);//路径压缩，优化的核心
    return father[x];
}
void unionn(int r1,int r2)//合并两个集合
{
    father[r2]=r1;
}
int main()
{
    cin>>n>>m;
    for(i=1;i<=n;i++)
        father[i]=i;//建立新的集合，其仅有的成员是i；
    for(i=1;i<=m;i++)
     {
         scanf("%d%d",&x,&y);
            int r1=find(x);
        int r2=find(y);
        if(r1!=r2) unionn(r1,r2);//判断元素是否在同一集合中；
     }
    for(int j=1;j<=n;j++)
    {
        if(father[j]==j) ans++;
```
}//记录，路越多，ans就会越少，所需新建的路就越少，
    cout<<ans-1;//这里-1知道吧，我就不多说了

    return 0;

}
//最后说一句，和本蒟蒻一样的菜鸟们加油，noip就要开始了，只有几十天了，留给我们的时间不多了，好好做题，好好刷题，宝剑锋从磨砺出，梅花香自苦寒来，努力了就会有回报的，


---

## 作者：Sooke (赞：0)

##很裸的并查集题。

并查集的合并和查询操作和楼上的题解是没有多大区别的，唯一不同的地方是得到答案的方法（即需要修建多少条公路）。貌似大多数人都是统计有多少点的上级没有改变而仍然是自己，然而本蒟蒻并没有想到这种方法……我是使用 STL 里的 set 容器，每次置空容器，最后将 1 ~ n 的上级的上级的……的上级也就是它的老大置入容器，利用 set 本身的去重大法，最后用 size 判断一下大小减去一就行了。原理就是最后的村庄图可能并没有联通，而是分成多个分散的连通图，因此，老大的数量就是分散图的数量，将分散图连在一起故就需要老大数量减一的公路啦。

由于习惯，还是加上了读入优化，除去读入优化的代码，主程序相对还是非常精炼的，代码如下（谢绝盲目复制，关键是自己理解！）：

```cpp
#include <cstdio>
#include <set>
#define f(i , n) for(int i=1 ; i <= n ; i++)
using namespace std;
set < int > S;
int v[1000];
inline int Input(){
    char C=getchar();
    int N=0;
    while('0' >  C || C >  '9') C=getchar(); 
    while('0' <= C && C <= '9') N=N*10 + (C-'0') , C=getchar();
    return N;
}
int Find(int n){
    return v[n] == n ? n : (v[n]=Find(v[n]));
}
int main(){
    int n , m;
    while((n=Input()) != 0){
        m=Input();
        f(i , n) v[i]=i;
        f(i , m) v[Find(Input())]=v[Find(Input())];
        S.clear();
        f(i , m) S.insert(Find(v[i]));
        printf("%d\n" , S.size()-1);
    }
    return 0;
}
```
##最后提醒一句，我已经给代码动了一个手脚，千万不要盲目复制粘贴哦！


---

## 作者：1jia1 (赞：0)

核心思路：原来我没想明白原因，现在想好了。

先处理好合并，然后一个个判断。

如果一个村庄指向自己，说明：1、没有村庄和它相连。2、别的村庄都指向它。

既然这样，那么我们来分析。如果只有一个村庄处于这种状态，那么就说明所有的村庄都相连并指向它，也就不用再修路了。

但如果有两个，就说明这两个村庄和它们的子集都互不相连，否则就都指向其中一个村庄。

以此类推，有n个村庄是集合的顶点，就要在之间修n-1条路。



```cpp
-#include <iostream> -
-#define sb "aa"-
-#define doby "aa"-
-using namespace std;-
-int n=1,m,p,a[5001]={0},s=0;-
-int find(int x)---找该点的根
-{-
-    if(a[x]==x)return x;-
-    a[x]=find(a[x]);-
-    return a[x];-
-}-
-void mash(int u,int v)---合并俩点
-{-
-    if(find(u)!=find(v))a[find(u)]=find(v);---如果两个点不在同一个集合就合并
-}-
-int main()-
-{-
-    while(doby==sb)---只要doby看到这里不打我就好。
-    {-
-        cin>>n;-
-        if(n==0)break;---题目说如果n=0就结束
-        cin>>m;-
-        for(int i=1;i<=n;i++)a[i]=i;---每个点指向自己，并查集的初始化
-        for(int u,v,i=1;i<=m;i++)-
-        {-
-            cin>>u>>v;-
-            mash(u,v);---把两个点连起来
-        }-
-        for(int i=1;i<=n;i++)-
-        {-
-            if(a[i]==i)s++;---判断有几个村庄指向自己
-        }-
-        cout<<--s<<endl;---只要修这些村庄的数量-1的道路就好了，不理解就看手掌
-        s=0;-
-    }-
-    return 0;-
-}-
```

---

## 作者：重回巅峰！ (赞：0)

初始化

把每个点所在集合初始化为其自身。

通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。

查找
查找元素所在的集合，即根节点。

合并
将两个元素所在的集合合并为一个集合。

通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。

这就是并查集，其实大家都懂，可是。。。。统计联通块的个数时没必要枚举啊，完全可以O(1)统计出啊。。。。。。

维护一个CNT，表示此时的联通块的个数，初始时CNT=N， 因为每次连通操作都会使连通块个数-1，所以只要每次--CNT就可以了

```cpp
var
  fa:array[0..1005]of longint;
  list,toit,next:array[0..1005]of longint;
  cnt,i,j,x,y,n,m:longint;
function find(x:longint):longint;
begin
  if fa[x]=x then find:=x else find:=find(fa[x]);
  fa[x]:=find;
end;
begin
  readln(n,m);
  cnt:=n;
  for i:=1 to n do fa[i]:=i;
  for i:=1 to m do
  begin
    readln(x,y);
    x:=find(x); y:=find(y);
    if x<>y then
    begin
      dec(cnt); fa[x]:=y;
    end;
  end;
  writeln(cnt-1);
end.

```

---

## 作者：zclzslz (赞：0)

简单的并查集，一开始以为是最小生成树。。。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,f[1005],ans(0);
int find(int x)
{
    if(f[x]==x)return x;
    return find(f[x]);
}
void UN(int x,int y)
{
    int a=find(x);
    int b=find(y);
    f[a]=b;
}
int main()
{
    while(scanf("%d %d",&n,&m)==2)
    {
        ans=0;
        for(int i=1;i<=n;i++)
        f[i]=i;
        for(int i=1;i<=m;i++)
        {
            int x,y;
            scanf("%d %d",&x,&y);
            if(find(x)!=find(y))
            {
                UN(x,y);
                ans++;
            }
        }
        printf("%d\n",n-1-ans);
    }
    return 0;
}
```

---

## 作者：水墨书香 (赞：0)

并查集可以很容易解决这道题。

用一个Judge（）函数判断目前独立的城市（根节点）的数量，这n座城市需要n-1条道路连通。

以下是代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int maxn=1002;
int vi[maxn];
int n,m,ans;
int Find(int x)        //查找
{
    if(vi[x]!=x)    vi[x]=Find(vi[x]);
    return vi[x];
}
int Union(int x,int y)        //合并 
{
    if(Find(x)!=Find(y))    vi[Find(y)]=vi[Find(x)];    
}
void Judge()        //判断 
{
    for(int j=1;j<=n;j++)
    {
        if(vi[j]==j)    ans++;        
    }
//    计算独立根节点的数量 
}
int main()
{
    cin>>n>>m;
    if(m==0)        //一条路都没有时，n个城市需要（n-1）条路相连 
    { 
        cout<<n-1;
        return 0;      
    } 
    int i,a,b;
    for(i=1;i<=n;i++)        //初始化 
        vi[i]=i;
    for(i=1;i<=m;i++)
    {
        cin>>a>>b;
        Union(a,b);
    }
    Judge();
    cout<<ans-1;    //ans表示独立根节点数，所以应有（n-1）条路连通 
    return 0;
}
```

---


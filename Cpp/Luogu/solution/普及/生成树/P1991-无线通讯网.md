# 无线通讯网

## 题目描述

国防部计划用无线网络连接若干个边防哨所。2 种不同的通讯技术用来搭建无线网络；

每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。

任意两个配备了一条卫星电话线路的哨所（两边都有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 $D$，这是受收发器的功率限制。收发器的功率越高，通话距离 $D$ 会更远，但同时价格也会更贵。

收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 $D$。你的任务是确定收发器必须的最小通话距离 $D$，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。


## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据：$P = 2，S = 1$；
- 对于另外 $20\%$ 的数据：$P = 4，S = 2$；
- 对于 $100\%$ 的数据保证：$1 ≤ S ≤ 100$，$S < P ≤ 500$，$0 ≤ x,y ≤ 10000$。


## 样例 #1

### 输入

```
2 4
0 100
0 300
0 600
150 750
```

### 输出

```
212.13
```

# 题解

## 作者：constructor (赞：175)

这一题其实是一题很有意思的大综合题，尽管算法过程很简单，但是思考起来还是有难度的，由于题解中大部分的原理没有说出或者不完善，我就写一篇题解吧。

先看题面，由

>他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 D，这是受收发器的功率限制。收发器的功率越高，通话距离 D 会更远，但同时价格也会更贵。

>收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 D。你的任务是确定收发器必须的最小通话距离 D，使得每一对哨所之间至少有一条通话路径（直接的或者间接的）。

可以发现这是一题求[瓶颈生成树](https://baike.baidu.com/item/%E7%93%B6%E9%A2%88%E7%94%9F%E6%88%90%E6%A0%91/2397900)的题目。

稍微解释一下，瓶颈生成树指的是在一个图$(E,V)$中一个$T \in E$使得$card(T) = G - 1 $且$T.max$是最小的。

定理： 瓶颈生成树和最小生成树的关系是最小生成树是瓶颈生成树的充分不必要条件。

这里可以使用[图拟阵](https://en.wikipedia.org/wiki/Matroid)进行证明，但是拟阵过于复杂，我不想在这里引入，你只需要脑补一遍kruskal算法的过程就应该知道这是对的了。

选用最小生成树的原因有两个：

- 最小生成树方便在图发生变化时维护其性质。
- 我也不会别的算法求瓶颈生成树了。

所以我们可以先求一个最小生成树，其中的最大边就是没有所谓的“卫星电话”时的答案了。

那么接下来怎么做呢？ 卫星电话的影响究竟是什么？其他题解中大部分说了一些类似于“联通块”“删边”的东西，引起了大规模的争论，但为什么答案是正确的呢？

事实上，边从来没有被删除过，而且也没有新的联通块出现。（但仍然不排除有方便思考的可能）。

那到底该怎么想？

注意一件事：

## 由于距离是客观存在的，所以本题中的图为完全图。

这个发现将不断伴随接下来的过程，是非常重要的性质。

好，已经扯了这么多废话了，那么不如再扯一点吧：

古人云：

>一生二，二生三，三生天下。

这是很有道理的。

- 一表达事物的本身，在此处对于一个“卫星电话”点来说，它到其他卫星电话点的距离为0，而不是边被删除了。

- 二表达事物内部的联系，在本题中，一对卫星电话点的距离为0

- 三表达事物和外部的联系，这点比较复杂我们稍后介绍。

当一个卫星电话出现时，没有什么表现，跳过。

当一对卫星电话出现时，分两种情况

- 没有无边的情况，因为本图是完全图

- 若这一对点之间边为树边，则他们的边权为0后若其为树上最大边，则答案变为树上第二大边，否则不变。

- 若这一对点之间为非树边：

![pic](https://cdn.luogu.com.cn/upload/pic/35873.png)

![pic](https://cdn.luogu.com.cn/upload/pic/35874.png)


那么**交换**两点之间路径的最大边（a. k. a. 边交换）(一样，自己脑补kruskal吧)。因为保证0距离是最小距离。

那么这是否说明可以随时移除当前最大的边吗？

那还得看引入新的点是否有影响。

当第三个点出现时，如：

![pic](https://cdn.luogu.com.cn/upload/pic/35879.png)

那么会不会由于多对点产生其他影响呢？

首先前两个点交换了一条边，假定是标为虚线的这一条：

![pic](https://cdn.luogu.com.cn/upload/pic/35880.png)

那么可以发现新得到的生成树是实线标识的这一条“M”形的折线。

这个时候我们尝试用新点对其他两点连边：

![pic](https://cdn.luogu.com.cn/upload/pic/35881.png)

![pic](https://cdn.luogu.com.cn/upload/pic/35882.png)

咦？图2中两点路径只比图1多包含了一条0权边！

是巧合吗？显然不是。这是因为当0权边产生时两边的卫星电话点早已连在一起，所以向他们进行连边时所能产生的出入只有一条或一些0权边而已！

那么我们可以把这样一组卫星点缩在一起，构成“卫星电话组”，即：

![pic](https://cdn.luogu.com.cn/upload/pic/35885.png)

这样，我们就能通过连接组内组外任意两点，将一条路径上的最大边用0边更换掉。

很明显就知道这样一共能进行$(S-1)$次。那么我们就能够通过连接在生成树上尽量远的两点达到不断将生成树中的最大边更换掉的目的。

综上，生成树中前$[P-1 - (S-1)]$条边(i.e., P-S)中的最大边就是答案！

为了凑个题解的样子，下面还是给出我的C++11代码，但是建议代码还是~~抄~~借鉴别人的，我的代码可能比较小众。

```cpp
#include <iostream>
#include <list>
#include <algorithm>
#include <tuple>
#include <cmath>
#include <iomanip>
#include <vector>
#include <numeric>

#ifdef DEBUG
#include <sstream>
std::stringstream stin(R"__(2 4
0 100
0 300
0 600
150 750
)__");
#else
#define stin std::cin
#endif // DEBUG

using edge = std::tuple<double, int, int>;
constexpr int maxn = 505;
int S, P;
std::vector<edge> gra, tree;
int p[maxn];
std::pair<double, double> pos[maxn];

constexpr double EuclidDistance(std::pair<int, int> p1, std::pair<int, int> p2)
{
	return std::sqrt((p1.first - p2.first)*(p1.first - p2.first)+(p1.second - p2.second)*(p1.second - p2.second));
}

int find(int pos)
{
	return p[pos] == pos ? pos : p[pos] = find(p[pos]);
}

int main()
{
	stin >> S >> P;
	for(int i = 1; i <= P; i++)
		stin >> pos[i].first >> pos[i].second;
	std::iota(p+1, p+1+P, 1);
	for(int i = 1; i <= P - 1; i++)
		for(int j = i+1; j <= P; j++)
		{
			auto dis = EuclidDistance(pos[i], pos[j]);
			gra.emplace_back(dis, i, j);
			gra.emplace_back(dis, j, i);
		}
	std::sort(gra.begin(), gra.end());
	int count = 0;
	for(auto& i : gra)
	{
		if(find(std::get<1>(i))!=find(std::get<2>(i)))
		{
			p[p[std::get<1>(i)]] = p[std::get<2>(i)];
			count++;
		}
		if(count == P - S)
		{
			std::cout << std::fixed << std::setprecision(2) << std::get<0>(i) << std::ends;
			return 0;
		}
	}
}
```

---

## 作者：Strong_Jelly (赞：153)

# 无线通讯网

**题目描述**

国防部计划用无线网络连接若干个边防哨所。2 种不同的通讯技术用来搭建无线网络；

每个边防哨所都要配备无线电收发器；有一些哨所还可以增配卫星电话。

任意两个配备了一条卫星电话线路的哨所（两边都ᤕ有卫星电话）均可以通话，无论他们相距多远。而只通过无线电收发器通话的哨所之间的距离不能超过 D，这是受收发器的功率限制。收发器的功率越高，通话距离 D 会更远，但同时价格也会更贵。

收发器需要统一购买和安装，所以全部哨所只能选择安装一种型号的收发器。换句话说，每一对哨所之间的通话距离都是同一个 D。你的任务是确定收发器必须的最小通话距离 D，使得每一对哨所之间至少有一条通话路径（**直接的或者间接的**）。

------------
看一眼，这不就是赤裸裸的**最小生成树模板**吗？

也许你会问:"s是干嘛的？"

我来告诉你——s！没用！

之前我们做最小生成树的模板时，是不是有n - 1条边就可以退出了，这里其它的没变，就退出条件变了。这里s可能排上一点点用场了，退出条件变成了**p - s**(p和之前的n是几乎一样的)。

既然是最小生成树的模板题，那必然会有两大经典算法——**Kruskal**，**Prim**

模板都不会的同志可以先看看[题解Kruskal模板](https://www.luogu.org/blog/qqq1112/zui-xiao-sheng-cheng-shu-kruskal-mu-ban)，[题解Prim模板](https://www.luogu.org/blog/qqq1112/zui-xiao-sheng-cheng-shu-prim-mu-ban)（模板题目两个题解里都有链接）

可惜Prim出去旅游去了，错过了这场好戏，因此这篇题解的主角就变成了**Kruskal**

如果有人热烈支持Prim，那就通过上面的Prim模板改编一下吧，相信聪明的你一定能行的！

我们先来介绍一下这位主人公吧

## 2.Kruskal算法（克鲁斯卡尔算法）

**Kruskal算法是通过并查集，按照边的权重顺序（从小到大）将边加入生成树中，但是若加入该边会与生成树形成环则不加入该边,选其次。直到树中含有n - 1条边为止。**

**时间复杂度：O（E log E）（E为边数）**

这里就不多说并查集了，不懂的可以先看一下[【模板】并查集](https://www.luogu.org/problemnew/show/P3367)

这是并查集的题解----->[并查集题解](https://www.luogu.org/blog/qqq1112/solution-p3367)

最后就是code：

```cpp
#include <bits/stdc++.h>//万能头 
using namespace std;
int fa[100001], a[100001], b[100001], s, p, n, k;
double ans;
struct node
{
	double x, y, z;
}stu[1000001];
bool cmp(node a, node b)//结构体从小到大排序
{
	return a.z < b.z;
}
int find(int x)//并查集 
{
	if(x != fa[x])
	{
		fa[x] = find(fa[x]);
	}
	return fa[x];
}//查找 
void unity(int x, int y)
{
	int r1 = find(x);
	int r2 = find(y);
	fa[r1] = r2;
}//合并 
int main()
{
	scanf("%d %d", &s, &p);
	for(int i = 1; i <= p; i++)
	{
		scanf("%d %d", &a[i], &b[i]);
		for(int j = 1; j < i; j++)
		{
			n++;//存图(也就这个意思吧...) 
			stu[n].z = sqrt((a[i] - a[j]) * (a[i] - a[j]) + (b[i] - b[j]) * (b[i] - b[j]));//计算长度(不懂得可以查一下勾股定理) 
			stu[n].x = i;
			stu[n].y = j;
		}
	}
	for(int i = 1; i <= p; i++)
	{
		fa[i] = i;//自己的父亲一开始等于自己本身 
	}
	sort(stu + 1, stu + n + 1, cmp);//排序 
	for(int i = 1; i <= n; i++)
	{
		if(find(stu[i].x) != find(stu[i].y))//祖先不同 
		{
			unity(stu[i].x, stu[i].y);//合并 
			ans = stu[i].z;//取最小值(排过序了)
			k++;
			if(k >= p - s)//满足每一对哨所之间有一条通话路径（直接的或者间接的）
			{
				printf("%.2lf", ans);
				return 0;//退出 
			}
		}
	}
	return 0;
}
```

# finish！！！(～￣▽￣)～

---

## 作者：George1123 (赞：97)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)

[P1991 【无线通讯网】](https://www.luogu.org/problem/P1991)

### 此题算法:二分+并查集

大致思路:

>1.$ $输入点，算出二分$D$的平方(必定为整数)的边界。$l=0$，$r$为任意两点间的最长距离。

>2.$ $二分。若两点间距离的平方$<=mid$就合并为一块。二分条件：块数是否$<=s$。

>3.$ $最后得出整数答案$l$，$\sqrt l$就是答案。

![](https://s2.ax1x.com/2019/09/22/uSOj76.jpg)

## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define f(v) (v)*(v)
const int N=510;
int s,p,xt,yt,l,r,mid,sum; //平方必定为整数
struct point{
	int x,y;
}P[N];
struct Un{ //并查集
    int f[N];
    void clear(int x){
        for(int i=1;i<=x;i++)
            f[i]=i;
    } int find(int x){
        if(f[x]==x) return x;
        return f[x]=find(f[x]);
    } void merge(int x,int y){
        x=find(x);
        y=find(y);
        f[y]=x;
    } bool same(int x,int y){
        return (find(x)==find(y));
    } 
}BCJ;
int dis(point a,point b){//距离
	return f(a.x-b.x)+f(a.y-b.y);
} int main(){
	scanf("%d%d",&s,&p);
	for(int i=1;i<=p;i++){
		scanf("%d%d",&xt,&yt);
		P[i]=(point){xt,yt};
	} for(int i=1;i<=p;i++)
		for(int j=i+1;j<=p;j++)
			r=max(dis(P[i],P[j]),r); //求出l和r
	while(l<r){
		mid=(l+r)>>1;
		BCJ.clear(p); sum=p;
		for(int i=1;i<=p;i++){
			for(int j=i+1;j<=p;j++){
				if(!BCJ.same(i,j)&&
				dis(P[i],P[j])<=mid){
					BCJ.merge(i,j);
					sum--; //合并
				}
			}
		} if(sum<=s)
			r=mid;
		else l=mid+1;
	} printf("%.2lf\n",sqrt(l)); //得出答案
	return 0;
}
```

为我点个赞吧，祝你名后挂金钩!

谢谢大家! !


---

## 作者：来日方长 (赞：37)

做本题首先应该知道一共有p个点就是树有p-1条边，有s个卫星电话就是不用连接最大的s-1条边。

因为数据范围小，本题适用kruskal。存储每条边的权值和两端进行排序。

但本题最重要的部分是卫星电话，由前文便可只本题一共只需要树中前（p-s）条边里的最大边即可，剩下的边用卫星电话。

ac代码：

```cpp
    #include<bits/stdc++.h>
    #define reint register int
    using namespace std;
    const int N=505;
    struct P1{
        int t1,t2;double v;
    }line[N*N];
    struct po{
        double x,y;
    }st[N];
    int s,p,num,fa[N];double ans;
    inline double dis(int x1,int y1){
        return sqrt((st[x1].x-st[y1].x)*
                    (st[x1].x-st[y1].x)+
                    (st[x1].y-st[y1].y)*
                    (st[x1].y-st[y1].y));
    }
    inline bool cmp(P1 x,P1 y){
        return x.v<y.v;
    }
    int find(int x){
        if(x!=fa[x])fa[x]=find(fa[x]);
        return fa[x];
    }
    inline void unionn(int x,int y)  {  
        fa[find(x)]=find(y);  
    }
    int main(){
        scanf("%d%d",&s,&p);
        for(reint i=1;i<=p;i++)fa[i]=i;
        for(reint i=1;i<=p;i++){
            scanf("%lf",&st[i].x);
            scanf("%lf",&st[i].y);
        }
        for(reint i=1;i<=p;i++)
        for(reint j=i+1;j<=p;j++){
            num++;
            line[num].t1=i;
            line[num].t2=j;
            line[num].v=dis(i,j);
        }
        sort(line+1,line+num+1,cmp);
        int a,b;s=p-s;
        for(reint i=1;i<=num,s>0;i++){
            a=line[i].t1;b=line[i].t2;
            if(find(a)!=find(b)){
                unionn(a,b);s--;
                ans=max(ans,line[i].v);    
            }
        }
        printf("%.2lf",ans);
        return 0;
}
```

---

## 作者：shadowice1984 (赞：24)

其实这道题用prim代码超级短的。

先解释一下为啥答案就最小生成树的第n大边

首先我们知道最小生成树肯定满足最大边最小的性质

问题是，为什么我们一定可以删掉这个树里的n-1条边？

因为我们删边的时候不是把这个边的两个端点加上卫星电话，

而是利用了这样一个性质，一个树里，删掉n条边一定出现n+1个连通块。

这样我们只要保证每个联通块里有且只有一台电话即可，

所以一定·能删n-1条边，答案就是第n大的边

然后我用prim写的这道题，比克鲁斯卡尔好写多了

上代码~

```cpp
#include<stdio.h>
#include<algorithm>
#include<cmath>
using namespace std;
int x[510];int y[510];
double dis[510][510];
double d[510];
double res[510];int cnt;
int now;int p;int n;
bool book[510];
bool cmp(double a,double b)
{
 return a>b;
}
int main()
{
    scanf("%d%d",&p,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x[i],&y[i]);
        d[i]=0x3f3f3f3f;
    }
    for(int i=1;i<=n;i++)//处理两个点间的距离
    {
        for(int j=1;j<i;j++)
        {
            double a=x[i]-x[j];double b=y[i]-y[j];
            a*=a;b*=b;
            dis[i][j]=sqrt(a+b);dis[j][i]=dis[i][j];
        }
    }
    d[1]=0;
    for(int i=1;i<=n;i++)//prim膜板
    {
        double minval=0x3f3f3f3f;
        for(int j=1;j<=n;j++)//找到d值最小的点
        {
            if(minval>d[j]&&book[j]==false)
            {
                minval=d[j];now=j;
            }
        }
        book[now]=true;res[++cnt]=minval;
        for(int j=1;j<=n;j++)//加入生成树中
        {
            if(book[j]==false)
            {
                d[j]=min(d[j],dis[now][j]);
            }
        }
    }
    sort(res+1,res+n+1,cmp);//排序
    printf("%.2lf",res[p]);
    return 0;//拜拜程序~
}
```

---

## 作者：ddwqwq (赞：20)

其实不必想删边的问题，太麻烦。

我的思路是这样的：设电话数为x，则可通过电话把x个联通快连接起来。既然如此，我们只需要用无线电连接节点，使图中仅剩x个联通块。然后就是贪心策略，把边排序，从小到大依次尝试，用并查集记录，直到图中仅剩x个联通块。具体看代码

```cpp
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>

using namespace std;

struct edge {//边
    int u;
    int v;
    double d;
};

int set[600], set_num;//集合，集合的个数
int s, p;
edge e[300000];//边

int findset(int x)//并查集，搜寻根节点并压缩路径
{
    int root, i;

    root = x;
    while (set[root] != root)
    {
        root = set[root];
    }
    i = x;
    while (set[i] != root)
    {
        int j = set[i];
        set[i] = root;
        i = j;
    }
    return root;
}

void merge(int x, int y)//集合合并
{
    set[findset(y)] = findset(x);
}

edge temp[300000];//归并排序的辅助数组

void msort(edge *a, int l, int r)//归并排序
{
    if (l == r)
        return;
    if (l + 1 == r)
    {
        if (a[l].d > a[r].d)
        {
            edge t = a[l];
            a[l] = a[r];
            a[r] = t;
        }
        return;
    }
    int i = l;
    int mid = (l + r) / 2;
    int j = mid + 1;
    int k = l;

    msort(a, l, mid);
    msort(a, mid + 1, r);

    while (i <= mid || j <= r)
    {
        if (j > r || i <= mid&&a[i].d < a[j].d)
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++];
    }
    for (i = l; i <= r; i++)
        a[i] = temp[i];
}

int main()
{
    int i, j;
    int x[600], y[600];//坐标

    scanf("%d %d", &s, &p);
    set_num = p;//集合数一开始等于结点数

    for (i = 0; i < p; i++)
    {
        set[i] = i;//初始化集合
        scanf("%d %d", &x[i], &y[i]);
    }

    int k = 0;
    for (i = 0; i < p; i++)//处理边
    {
        for (j = 0; j < p; j++)
        {
            e[k].u = i;
            e[k].v = j;
            e[k++].d = sqrt((x[i] - x[j])*(x[i] - x[j]) + 
                (y[i] - y[j])*(y[i] - y[j]));
        }
    }

    msort(e, 0, k - 1);//排序

    for (i = 0; i < k; i++)//贪心策略
    {
        if (findset(e[i].u) != findset(e[i].v))
        {
            merge(e[i].u, e[i].v);
            set_num--;//成功合并集合则集合数减一
        }
        if (set_num <= s)
            break;//若集合数已经符合要求，跳出循环
    }

    printf("%.2lf", e[i].d);//第i条边的长度即为最小值

    system("pause");
    return 0;
}
```

---

## 作者：Plus_Ultra (赞：17)

1. #### 题面：
北极的某区域共有 n 座村庄，每座村庄的坐标用一对整数 (x,y) 表示。为了加强联系，决定在村庄之间建立通讯网络。通讯工具可以是无线电收发机，也可以是卫星设备。所有的村庄都可以拥有一部无线电收发机， 且所有的无线电收发机型号相同。但卫星设备数量有限，只能给一部分村庄配备卫星设备。

不同型号的无线电收发机有一个不同的参数 d，两座村庄之间的距离如果不超过 d 就可以用该型号的无线电收发机直接通讯，d 值越大的型号价格越贵。拥有卫星设备的两座村庄无论相距多远都可以直接通讯。

现在有 k 台卫星设备，请你编一个程序，计算出应该如何分配这 k 台卫星设备，才能使所拥有的无线电收发机的 d 值最小，并保证每两座村庄之间都可以直接或间接地通讯。

例如，对于下面三座村庄：

![](https://cdn.luogu.com.cn/upload/pic/65088.png)



##### 其中 |AB|=10,|BC|=20,|AC|=10√5≈22.36

如果没有任何卫星设备或只有 1 台卫星设备 (k=0 或 k=1)，则满足条件的最小的 d=20，因为 A 和 B，B 和 C 可以用无线电直接通讯；而 A 和 C 可以用 B 中转实现间接通讯 (即消息从 A 传到 B，再从 B 传到 C)；

如果有 2 台卫星设备 (k=2)，则可以把这两台设备分别分配给 B 和 C ，这样最小的 d 可取 10，因为 A 和 B 之间可以用无线电直接通讯；B 和 C 之间可以用卫星直接通讯；A 和 C 可以用 B 中转实现间接通讯。

如果有 3 台卫星设备，则 A,B,C 两两之间都可以直接用卫星通讯，最小的 d 可取 0。

~~上面来自某爆零一本通~~

### 其实这么一大堆题面只是告诉我们：求一张图，求这张图的最小生成树，去掉K条最长边，剩下的第K+1长的边.

当正向思考受阻时，逆向思维可能有奇效。本题就是这样。知道卫星设备的数量，求最小的收发距离，可能比较困难；

但如果知道距离求数量，就很简单了。把所有可以互相通讯的村庄连接起来，构成一个图。卫星设备的台数就是图的连通支的个数。

 

       问题转化为：找到一个最小的d，使得把所有权值大于d的边去掉之后，连通支的个数小于等于k。

       先看一个定理。定理2：如果去掉所有权值大于d的边后，最小生成树被分割成为k个连通支，图也被分割成为k个连通支。

       证明：用反证法。假设原图被分割成k’ (k'≠k)个连通支，显然不可能k’>k，所以k’<k。因此在某一图的连通支中，最小生成树被分成了至少两部分，不妨设其为T1,T2。因为T1和T2同属于一个连通支，所以一定存在x∈T1，y∈T2，w(x,y)≤d。又因为在整个最小生成树中，所以x到y的路径中一定存在一条权值大于d的边(u,v)（否则x和y就不会分属于T1和T2了），w(x,y)≤d<w(u,v)，所以把(x,y)加入，把(u,v)去掉，将得到一棵总权值比最小生成树还小的生成树。这显然是不可能的。所以，原命题成立。（证毕）

       有了这个定理，很容易得到一个构造算法：最小生成树的第k长边就是问题的解。

 

       首先，d取最小生成树中第k长的边是可行的。如果d取第k长的边，我们将去掉最小生成树中前k-1长的边，最小生成树将被分割成为k部分。由定理2，原图也将分割成为k部分。（可行性）

       其次，如果d比最小生成树中第k长的边小的话，最小生成树至少被分割成为k+1部分，原图也至少被分割成为k+1部分。与题意不符。（最优性）

       综上所述，最小生成树中第k长的边是使得连通支个数≤k的最小的d，即问题的解。
       
       
 下面不哆嗦了，贴代码（我相信各位大佬都不需要代码）：
 
 ```
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>

using namespace std;

int n,T,k,m,f[505],cnt;
double x[505],y[505],ans[505*505];
struct node
{
	int x,y; 
	double d;	
}p[505*505];

double dist(double x1,double y1,double x2,double y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));//勾股定理求距离
}

bool cmp(node a,node b)
{
	return a.d<b.d;
}

int getf(int x)
{
	return x==f[x]?x:f[x]=getf(f[x]);
}

int main()
{
		scanf("%d%d",&k,&n);
		if(k>=n) 
		{
			printf("0.00\n");
			return 0;
		} 
		for(int i=1;i<=n;i++)
		{
			cin>>x[i]>>y[i];
			f[i]=i;
		}
		
		for(int i=1;i<=n;i++)
		  for(int j=i+1;j<=n;j++)
		    p[++m]=(node){i,j,dist(x[i],y[i],x[j],y[j])};
		    
		sort(p+1,p+m+1,cmp);
		
		for(int i=1;i<=m;i++)
		{
			int fa=getf(p[i].x),fb=getf(p[i].y);
			double d=p[i].d;
			if(fa!=fb)
			{
				f[fa]=fb;
				ans[++cnt]=d;
			}
		}//KRUSKAL模板
		
		printf("%.2lf\n",ans[cnt-k+1]);
		
	return 0;
}
```

 

---

## 作者：pomelo_nene (赞：15)

做这道题和发题解的人挺多，但是似乎没有经过严格证明的

下面，将详细介绍做法以及利用定理证明

---

转化题意，我们知道卫星设备的数量，要求最小的收发距离？？？   
如果我们知道距离求数量就好了，直接把所有能够互相通讯的村庄连接起来构成一个图，求图中的联通支个数（也就是卫星设备的台数）就完了

所以，我们要找到一个尽量小的$d$，使得把大于$d$的便全部去掉，使得联通支个数小于$S$

在这之前，我们要知道一个定理：去掉所有权值大于$d$的边之后，最小生成树会被划分为$k$个联通支，图也就被分为了$k$个联通支——定理1

#### 证明：

我们假设原图被分为了$k'$个联通支（$k' \not = k$）显然$k' < k$，因此某一个图的联通支中，最小生成树被分成了至少两部分，把他们设成$G_1,G_2$，因为$G_1$与$G_2$属于同一个联通支，所以$x \in G_1,y \in G_2,w(x,y)\leq d$。又因为在整个最小生成树，因此$x,y$之间一定存在一条权值大于$d$的边$(u,v)$（因为如果不满足，$x,y$就不会存在于$G_1,G_2$了），$w(x,y) \leq d <w(u,v)$，所以加入$(x,y)$而去掉$(u,v)$，将得到一棵总权值比最小生成树还要小的树，显然不成立。

我们通过反证法证明了定理1

这个定理被证明成立，我们可以想到构造，得到

> 最小生成树的第$k$长边即是我们的答案

#### 证明：

$d$取最小生成树的第$k$长边可行。如果$d$为第$k$长边，我们将去掉最小生成树中前$k-1$长的边，最小生成树会被分割成$k$部分，根据我们的定理1，得到原图也被分割成为$k$部分，我们证明了这是可行的

我们要证明答案是最优的，我们假设$d$比最小生成树的第$k$边还要小，最小生成树就至少被分割成为$k+1$部分，原图也至少被分割成为$k+1$部分，与题意不符

所以说最小生成树的第$k$长边即是我们的答案

证毕

附上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int fa[505],px[505],py[505];
double ans[505];
int m,n,k,cnt;
struct ff{
	int x,y;
	double d;
}p[250000];
double dist(int ax,int ay,int bx,int by){return sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by));}
int find(int x)
{
	if(fa[x]!=x)	fa[x]=find(fa[x]);
	return fa[x];
}
bool cmp(ff a,ff b){return a.d<b.d;}
int main(){
	scanf("%d %d",&k,&n);
	if(k>=n)	return puts("0.00")&0;
	for(int i=1;i<=n;++i)	fa[i]=i,scanf("%d %d",&px[i],&py[i]);
	for(int i=1;i<=n;++i)	for(int j=i+1;j<=n;++j)	p[++m]=(ff){i,j,dist(px[i],py[i],px[j],py[j])};
	sort(p+1,p+1+m,cmp);
	for(int i=1;i<=m;++i)
	{
		int x=find(p[i].x),y=find(p[i].y);
		if(x!=y)
		{
			fa[x]=y;
			ans[++cnt]=p[i].d;
		}
	}
	printf("%.2lf",ans[cnt-k+1]);
	return 0;
}
```

---

## 作者：acfox (赞：10)

其实,可以二分 + 并查集做

枚举ans, 对于每一个点把ans范围内的点连成一个联通块, 如果剩下的联通块数量小于等于卫星数量, 就说明可以了











```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define dis(a, b, c, d) (sqrt((a - c) * (a - c) + (b - d) * (b - d)))
#define INF 0x3f3f3f3f
#define eps 1e-10
using namespace std;
const int N = 505;
int x[N], y[N], deep[N], fa[N];
double map[N][N];
int n, m;
inline int dcmp(double x) {
    if (fabs(x) < eps) return 0;
    return x < 0 ? -1 : 1;
}
inline int find(int x) {
    int o = x;
    while (fa[x] != x) x = fa[x];
    while (o != x) {
        int &t = fa[o];
        o = t;
        t = x;
    }
    return x;
}
inline void merge(int u, int v) {
    if (deep[u] < deep[v]) fa[u] = v;
    else {
        fa[v] = u;
        if (deep[u] == deep[v]) deep[u]++;
    }
}
void Init() {
    for (int i = 1; i <= n; i++) {
        fa[i] = i;
        deep[i] = 0;
    }
}
bool check(double d) {
    Init();
    int cnt = n;
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (dcmp(map[i][j] - d) <= 0) {
                int u = find(i);
                int v = find(j);
                if (u != v) merge(u, v), cnt--;
            }
        }
    }
    if (cnt <= m) return true;
    return false;
}
double find(double l, double r) {
    while (dcmp(r - l)) {
        double m = (l + r) / 2;
        if (check(m)) r = m;
        else l = m;
    }
    return (r + l) / 2;
}
int main() {
    scanf("%d %d", &m, &n);
    for (int i = 1; i <= n; i++)
        scanf("%d %d", &x[i], &y[i]);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            map[i][j] = dis(x[i], y[i], x[j], y[j]);
        }
    }
    double ans = find(0.0, 20000.0);
    printf("%.2lf", ans);
    return 0;
}

```

---

## 作者：BriMon (赞：7)

**上午模拟赛这道题被坑惨**

发题解纪念：

考虑贪心；

这道题就是最小生成树，


先预处理出两两之间的距离；

然后建边， 跑最小生成树；

用数组记录生成树的边；

重点！！

因为有S个电话， 最多能连S-1条边；

所以贪心的来想， 去掉最小生成树上的最大的S-1条边；

剩下的最大值就是答案！

！！！

（敲黑板）

生成树的边的计数必须从0开始！！

就是代码里的k；

手残模拟赛爆零！！切记！！

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;

int s, p;

inline int read()
{
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}

inline void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}

int x[510], y[510];

double dist(int x, int y, int i, int j)
{
	return sqrt((abs(x - i) * abs(x - i)) + ((abs(y - j)) * (abs(y - j))));
}

double dis[510][510];

struct Edge
{
	int x;
	int y;
	double v;
}ed[500010];int cnt;

bool cmp(Edge a, Edge b)
{
	return a.v < b.v;
}

int f[50010];
int find(int x)
{
	if(x == f[x]) return x;
	return f[x] = find(f[x]);
}

int line[500010];

int main()
{
//	freopen("wireless.in","r",stdin);
//	freopen("wireless.out","w",stdout);
	s = read(), p = read();
	for(register int i=1;i<=p;i++)
	{
		x[i] = read(), y[i] = read();

	}
	for(register int i=1;i<=p;i++)
	{
		for(register int j=1;j<=p;j++)
		{
			if(i == j) dis[i][j]/* = dis[j][i] */= 0x7fffff;
			else dis[i][j] /*= dis[j][i]*/ = dist(x[i], y[i], x[j], y[j]);
			//cout<<dis[i][j]<<" ";
			cnt++;
			ed[cnt].x = i;
			ed[cnt].y = j;
			ed[cnt].v = dis[i][j];
		}
	}
	for(register int i=1;i<=p;i++) f[i] = i;
	
	sort(ed+1, ed+1+cnt, cmp);
	
	
	int k = 0;///////注意！！！！！！！！！！！！！ 
	for(register int i=1;i<=cnt;i++)
	{
		int x = ed[i].x , y = ed[i].y ;
		if(find(x) != find(y))
		{
			f[find(x)] = find(y);
			k++;
			line[k] = i;
		}
		if(k == p - 1)break;
	}
	//cout<<line[k - s/2];
	//cout<<ed[line[k-s+1]].v;
	printf("%.2lf",ed[line[p-s]].v);
//	fclose(stdin);
//	fclose(stdout);
	return 0;
	
}
```


---

## 作者：Gloaming (赞：5)

这一题是典型的一个最短路问题，我用的是kruskar算法，并查集那里用了一个路径压缩的小优化。
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
int father[1000005],n,m,s,p,x[10001],y[10001];
struct Edge {
	int u,v;
	double w;
} edge[1000005];
int GetFather(int num) { //并查集的查找父亲操作
	if(father[num]==num) return num;
	return father[num]=GetFather(father[num]); //路径压缩
}
void merge(int x,int y) { //合并两个点的操作
	int x_father=GetFather(x);
	int y_father=GetFather(y);
	if(x_father!=y_father)
		father[y_father]=x_father;
	return;
}
bool cheak(int x,int y) { //判断两个点是否在同一个并查集里
	return GetFather(x)==GetFather(y);
}
bool cmp(Edge k,Edge x) { //STL sort的比较器
	return k.w<x.w;
}
double kruskar() { //kruskal模板
	int cnt=0;
	double ret=0,maxx=0;
	sort(edge+1,edge+1+m,cmp);
	for(int i=1; i<=m-s; i++) {
		if(cnt==p-s) break;     //由题意可得，只需要选x-s条边
		if(cheak(edge[i].u,edge[i].v)) continue;
		else {
			ret+=edge[i].w;
			merge(edge[i].u,edge[i].v);
			cnt++;
			maxx=max(maxx,edge[i].w);
		}
	}
	return maxx;
}
double pf(double k) {
	return k*k;
}
int main() {
	cin>>s>>p;
	for(int i=1; i<=p; i++)
		cin>>x[i]>>y[i];
	for(int i=1; i<=p; i++)
		for(int j=1; j<=p; j++)  //算出每两个点之间的距离
			if(i!=j) {
				m++;
				edge[m].u=i;
				edge[m].v=j;
				edge[m].w=sqrt(pf(x[i]-x[j])+pf(y[i]-y[j]));
			}
	for(int i=1; i<=p; i++) father[i]=i;
	printf("%.2lf",kruskar());
	return 1;
}
```
希望大家多多点赞（复制代码不是好习惯哟！）

---

## 作者：yu__xuan (赞：3)

### 题目
[P1991 无线通讯网](https://www.luogu.org/problem/P1991)
### 题目大意
我一开始在题意上理解有问题先说一下题意。你要让$p$个哨所都可以互相通话（可以是间接），可以通过`无线电收发器`也可以通过`卫星电话`。这个`卫星电话`它特别流啤，没有距离限制，只要两个哨所都有`卫星电话`就可以通话而`无线电收发器`有一定的距离限制，只有两个哨所之间的距离小于$D$才可以通话。现在给你$s$个`卫星电话`，让你将着$s$个电话分配一下，使得最后$D$最小。（可能描述的也不好，见谅。。。）
### 思路
并查集。算出没两个哨所之间的距离存起来，按距离由小到大排序，再由小到大枚举这些边，如果边连接的两个哨所不在同一个联通块内就连起来，连通块数量减一（一开始连通块数量为$p$），直到连通块数量为$s$（剩下的不连通的用`卫星电话`），因为$s$个`卫星电话`可以免费连接$s-1$个哨所，所以只要连通块数量为$s$就可以停止了。

### $Code$
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<string>
#include<cmath>
#define MAXN 501
int s,p,fa[MAXN],size[MAXN];
int a[MAXN],b[MAXN];
struct info{
	int u,v;
	double w;
}qwq[250001];
bool cmp(info a,info b){
	return a.w<b.w;
}
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
void Union(int x,int y){
	int rootx=find(x),rooty=find(y);
	if(rootx==rooty) return;
	if(size[rootx]>size[rooty]){
		fa[rooty]=rootx;
		size[rootx]+=size[rooty];
	}else{
		fa[rootx]=rooty;
		size[rooty]+=size[rootx];
	}
}
inline void read(int &T){
	int x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

int main(){
	read(s),read(p);
	for(int i=1;i<=p;++i) fa[i]=i;
	for(int i=1;i<=p;++i) read(a[i]),read(b[i]);
	int sum=0;
	for(int i=1;i<=p;++i){
		for(int j=1;j<=p;++j){
			if(i!=j){
				double jl=sqrt((a[i]-a[j])*(a[i]-a[j])+(b[i]-b[j])*(b[i]-b[j]));
				sum++;
				qwq[sum].u=i,qwq[sum].v=j,qwq[sum].w=jl;
			}
		}
	}
	std::sort(qwq+1,qwq+sum+1,cmp);
	int stop=1+(s-1);
	int ub=p;
	for(int i=1;i<=sum;++i){
		if(ub==stop){
			std::cout<<std::fixed<<std::setprecision(2)<<qwq[i-1].w;
			return 0;
		}
		if(find(qwq[i].u)!=find(qwq[i].v)){
			Union(qwq[i].u,qwq[i].v);
			ub--;
		}
	}
	return 0;
}
```

---

## 作者：说好不哭 (赞：3)

## 显然，这题是一道瓶颈生成树，但是由于有了卫星电话的这个麻烦操作，导致我们需要慎重思考，正确答案到底是第几大的那一条边！

### 对于这个问题，我想介绍一下我的想法。
### 1.首先，如果抛开卫星的问题，那么就是连n-1条边，但是现在有了卫星的问题，所以这个边的个数肯定要减少。
### 2.至于到底要减少多少，这里这样理解：有s个卫星点，那么这s个卫星点相当于一个联通块，这个联通块中有用的边有s-1条，所以，要连的边就是 n-1-（s-1）条。        
### 3.可能有人会问，最长的那几条边，都在这个联通块中，不就出现bug了吗？其实这种情况是不存在的。因为根据算法 ，如果当前连了边，那么将会通过并查集维护联通块的状态，而如果当前的边连的两个端点已经是同一个并查集，那么就会忽略这条边，所以相当于没有了这种情况。

## 对于下面的代码分析，就不再过多地介绍，毕竟，如果搞清楚了要求的答案是哪一条边，这道题就是瓶颈生成树的裸题了。

```cpp

#include <bits/stdc++.h>
using namespace std;
const int N=5e2;
int n,s,i,j,cnt,now,xx,yy;
int f[N],x[N],y[N];
double ans;

struct number{
int x,y;
double w;
}num[N*N];

inline bool cmp(number a,number b){return a.w<b.w;}
inline int get(int x){
if (f[x]==x) return x;	
return f[x]=get(f[x]);
} 

int main(){
scanf("%d%d",&s,&n);
for (i=1; i<=n; i++) scanf("%d%d",&x[i],&y[i]);
	for (i=1; i<=n-1; i++)
	for (j=i+1; j<=n; j++)
	{
	cnt++;
	num[cnt].x=i,num[cnt].y=j;
	num[cnt].w=sqrt((double)(x[i]-x[j])*(x[i]-x[j])+(double)(y[i]-y[j])*(y[i]-y[j]));
	}
sort(num+1,num+cnt+1,cmp);	

for (i=1; i<=n; i++) f[i]=i;
now=0;
	if (now!=n-1-(s-1))
	for (i=1; i<=cnt; i++)
	{
	if (now==n-1-(s-1)) {printf("%.2lf\n",ans); return 0;}	
	xx=get(num[i].x); yy=get(num[i].y);
	if (xx!=yy)
	f[xx]=yy,now++,ans=num[i].w;	
	}
	
printf("%.2lf\n",ans);
return 0;	
}

```


---

## 作者：zhaoyifan (赞：3)

这道题是几个月前做的，思路有一些问题，很多讨论里都有说这个问题，而大多题解说的很粗糙，让人疑惑

这里先感谢@三酒酒酒 对该问题的讲解。

错误的思路：求出所有边的距离，构造最小生成树，然后抛弃原图，大脑直接进入生成树状态，然后贪心删去最大的边，删去一条边需要2个卫星电话，那么在最坏的情况下n个卫星电话只能删去n/2条边

这是不对的，一切的原则和思路应该在原图中展开，即任意两个点可以直接到达

那么你删第一条边，毫无疑问需要2个卫星电话，但对于删除的后面的边，你只需要设置1个卫星电话即可

证明：1.第二条删除的边一端已经有卫星电话，那么这条边可以直接删除

2.另一端没有卫星电话，那么你在这一端加上一个卫星电话，可以和已经安装的卫星电话的点距离为0，点转化，安装过卫星电话的点到最大边的另外一点距离一定小于最大边，如果大于那么最大边的端点一定有卫星电话，转为1

至此，代码请看楼下的大佬们吧。


---

## 作者：x_miracle (赞：2)

这一题对我有历史性的意义，因为我深刻意识到：

不要用namespace!

不要用namespace!

不要用namespace!

写此题解，以示他人。

~~（搞错重点了吧喂！）~~

------------

好，回归正题：

这道题的思路是这样：

首先，用Kruskal算法。

（建议先把 并查集模板与 最小生成树模板 打了再继续看）

我们回顾一下Kruskal算法的过程：

把边按权值从小到大一条条排好，然后再从未选择的点中添加边，一直添加到**节点数-1**为止。

重点：为什么是节点数-1？因为最小生成树要让图连通。

**可不可以不连通？** 

可以！

该题中，卫星电话的存在，就是为了可以让图断开。而最后求的最大边，就是最后一个添加到图中的边。

附上代码：
```cpp
#include <bits/stdc++.h>
#define MAXN 200005
int node,edgenum=0,ans=0,k=0,s;
int fat[MAXN],siz[MAXN];
//坐标 
struct pair
{
	int first,second;
}	a[MAXN];
//图 
struct EDGE
{
	int from,to;double cost;
}	e[MAXN];
//比较器 
bool cmp(EDGE a,EDGE b)	{return a.cost<b.cost;}
//并查集 + 路径压缩 + 启发式搜索 
int Find(int x){ return (fat[x]==x)? x : fat[x]=Find(fat[x]); }
void unionn(int x,int y){
	x=Find(x); y=Find(y);
	if(siz[x]>siz[y])	std::swap(x,y);
	fat[x]=y;	siz[y]+=siz[x]; 
}
//两点之间距离公式 
double distance(pair m , pair n)
{
	double ans=std::sqrt( (m.first-n.first)*(m.first-n.first) + (m.second-n.second)*(m.second-n.second) );
	return ans;
}

int main()
{
	double d;
	std::scanf("%d%d",&s,&node);
	for(int i=1;i<=node;++i)	scanf("%d%d",&a[i].first,&a[i].second);
	for(int i=1;i<=node;++i)	{fat[i]=i;	siz[i]=1;}	//初始化 
	for(int i=1;i<=node;++i)	//构图 
	{
		for(int j=i+1;j<=node;++j)
		{
			e[ ++edgenum ].from=i;	e[ edgenum ].to=j;
			e[ edgenum ].cost=distance(a[i],a[j]);
		}
	}
	//	Kurskal 
	std::sort(e+1,e+edgenum+1,cmp);
	for(int i=1;i<=edgenum;++i)
	{
		if(k==node-s) break;//节点数-卫星电话数
		if(Find(e[i].from) != Find(e[i].to))
		{
			unionn(e[i].from,e[i].to); 
			d=e[i].cost;	++k; 
		}
	}		
	std::printf("%.2lf",d);
	return 0;
}
```

其实这题的数据有点弱。

我的代码是有缺陷的，可是AC了。

应该还要再添加一些特判。

比如，当卫星电话数大于节点数时，d应该为0。

当卫星电话数为0时，应该与卫星电话为1时的情况相等。



---

## 作者：EarthGiao (赞：2)

## 【思路】 
最小生成树 + 克鲁斯卡尔    

### 【题目大意】
有无线电收发器和卫星电话两种工具    
卫星电话不需要考虑距离    
无线电收发器有传播距离的限制    
求这个限制最小是多少    

### 【题目分析】
卫星电话可以当做免费的    
p个哨所需要p-1条边连接起来   
而s个卫星电话可以免去s-1条边   
所以就只剩下了p-s条边需要找   
找最小的    
所以最小生成树就很显然了   

### 【核心思路】
将两两之间的匹配方式用结构图储存一下   
然后sort排序从最短的边开始试    
如果这条边连接的两个点没有被接起来   
那就连起来就好了   
这样知道用完p-s条边    
因为从小到大排的序   
所以最后用的那一条边的权值就是最大的   
输出就好了      
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm> 
#include<cmath>

using namespace std;

int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')fg = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		sum = sum * 10 + c - '0';
		c = getchar();
	}
	return sum * fg;
}
const int Max = 503;
int x[Max],y[Max];
int father[Max];
struct node
{
	int xx,yy;
	double l;
}a[Max * Max];

bool cmp(const node aa,const node bb)
{
	return aa.l < bb.l;
}

int find(int xz)
{
	if(father[xz] != xz)father[xz] = find(father[xz]);
	return father[xz];
}

void hebing(int xz,int yz)
{
	xz = find(xz);
	yz = find(yz);
	if(yz != xz)
		father[xz] = yz;
}

int main()
{
	int s = read(),p = read();
	for(register int i = 1;i <= p;++ i)
		father[i] = i;
	for(register int i = 1;i <= p;++ i)
		x[i] = read(),y[i] = read();
	int jj = 0;
	for(register int i = 1;i <= p;++ i)
	{
		for(register int j = i + 1;j <= p;++ j)
		{
			a[++ jj].xx = i;
			a[jj].yy = j;
			a[jj].l = double(sqrt((x[i] - x[j]) * (x[i] - x[j]) * 1.0 + (y[i] - y[j]) * (y[i] - y[j]) * 1.0));
		}
	}
	sort(a + 1,a + jj + 1,cmp);
	int tot = p - s;
	int js = 0;
	double M = 0;
	for(register int i = 1;i <= jj;++ i)
	{
		if(find(a[i].xx) != find(a[i].yy))
		{
			js ++;
			M = a[i].l;
			hebing(a[i].xx,a[i].yy);
		}
		if(js == tot)
			break;
	}
	printf("%.2lf\n",M);
	return 0;
}
```

---

## 作者：pisceskkk (赞：2)

由于数据范围比较小，我就搞了个时间复杂度大一点，但代码简洁的方法：Prim+优先队列；

思路与Kruskal相类似，但好处是不需要把所有边求出来，用哪条求那条。那所有的边求出来之后都push进优先队列，然后处理一下，把前s-1大的pop出，输出top。（不要求到第p-s条边就break，有毛病）

···





    
```cpp
#include<cstdio>
#include<cmath>
#include<queue>
#define Min(a,b) a<b?a:b
#define N 502
#define INF 1e8
using namespace std;
int s,p,x[N],y[N],v[N];
priority_queue<float> ans;
float d[N];
inline float dis(int a,int b){
    return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));
}
int main(){
    scanf("%d%d",&s,&p);
    for(int i=1;i<=p;i++){
        scanf("%d%d",&x[i],&y[i]);
        d[i]=dis(i,1);
    }
    v[1]=1;
    int now=1;
    while(1){   //Prime
        float mi=INF;
        for(int i=1;i<=p;i++){
            if(v[i]==0&&mi>d[i]){
                now=i;
                mi=d[i];
            }
        }
        if(mi==INF)break;
        ans.push(mi);
        v[now]=1;
        for(int i=1;i<=p;i++)if(v[i]==0){
            d[i]=Min(d[i],dis(now,i));
        }
    }
    for(int i=1;i<s;i++)ans.pop();//优先队列处理答案 
    printf("%.2f\n",ans.top());
    return 0;
}
```
···
附丑代码……


---

## 作者：学无止境 (赞：1)

貌似大部分都是比较纯粹的最小生成树做法诶

这里 **并查集+二分答案** 的做法感觉也是很简明的

题目要我们求的**最小通话距离 $D$** 必须满足**每一对哨所之间至少有一条通话路径（直接的或者间接的）** 这个条件，因此我们可以设定精度要求来二分 $D$ ,并判定这个 $D$ 是否满足条件即可得到答案。

将哨所看成点，我们预处理出所有的边 $(i,j,k)$ 并根据 $k$ 排序 【$(i,j,k)$ 表示从点 $i$ 到点 $j$ 的边，边长为他们之间的距离 $k$ 】。

此时如果我们尝试判定一个 $D$ 是否满足条件,那么我们仅考虑长度小于等于 $D$ 的边，使用并查集维护连通性，我们可以计算出此时图中有多少个连通块。显然如果连通块数量如果大于 $1$ ，那么不同连通块之间就需要卫星电话来连接。若卫星电话数量 $s$ 大于等于连通块数量，那么就可以满足条件。

>注 ：对边排序的目的就是为了二分得到哪些边需要考虑。

设答案值域为 $V$ (本题 $V$ 最大为$10^8$) , 二分的时间复杂度为$O(log_2V)$ 。

判定是否满足条件的时间复杂度就是并查集(的时间复杂度这里我使用了路径压缩与按秩合并优化)，为 $O(pα(p))$

那么最终的时间复杂度就是 $O(pα(p)log_2V)$

代码里面有一些注释，可以结合理解。
>注 ： 这里 $α(p)$ 表示 $p$ 的反阿克曼函数值。

$Code:$
```cpp

#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;

#define eps (0.0001)
//四舍五入，所以要保证前三位精确
struct edge
{
    int u,v;
    double w;
    bool operator<(const edge q) const//运算符重载
    {
        return w<q.w; 
    }
}a[250010];

int s,p,tot,f[510],dep[510];
double pos[510][2],tmp[250010];
bool vis[510];//为了计算连通块数量添加的标记数组

inline double dis(int i,int j)//计算两点间距离
{
    return sqrt((pos[i][0]-pos[j][0])*(pos[i][0]-pos[j][0])+(pos[i][1]-pos[j][1])*(pos[i][1]-pos[j][1]));
}

int getfa(int x)//实现并查集
{
    if(f[x]==x)
        return x;
    return f[x]=getfa(f[x]);
}

inline bool check(double v)//判定是否满足条件
{
    int bound=(upper_bound(tmp+1,tmp+1+tot,v)-tmp)-1,cnt=0;//1~bound 就是需要考虑的边了; cnt为连通块计数器
    memset(vis,0,sizeof(vis));
    for(register int i=1;i<=p;i++)//并查集初始化
        f[i]=i,dep[i]=1;
    for(register int i=1;i<=bound;i++)//并查集维护连通性
    {
        int x=a[i].u,y=a[i].v;
        int fx=getfa(x),fy=getfa(y);
        if(fx!=fy)
        {
            if(dep[fx]>dep[fy])
                f[fy]=fx;
            else if(dep[fx]<dep[fy])
                f[fx]=fy;
            else
                f[fy]=fx,dep[fx]++;
        }
    }
    for(register int i=1;i<=p;i++)//计算连通块数量
    {
        int temp=getfa(i);
        if(!vis[temp])
            vis[temp]=true,cnt++;
    }
    if(cnt==1)//只有一个连通块则不需要考虑卫星电话
        return true;
    return (s>=cnt) ;//判断卫星电话够不够用

}

int main()
{
    scanf("%d%d",&s,&p);
    for(register int i=1;i<=p;i++)
        scanf("%lf%lf",&pos[i][0],&pos[i][1]);
    for(register int i=1;i<=p;i++)
        for(register int j=i+1;j<=p;j++)
            a[++tot].u=i,a[tot].v=j,a[tot].w=dis(i,j);
    sort(a+1,a+1+tot);
    for(register int i=1;i<=tot;i++)
        tmp[i]=a[i].w;
    double l=0.0,r=100000000.0,mid;
    while((r-l)>eps)//二分答案
    {
        mid=(l+r)/2;
        if(check(mid))
            r=mid;
        else
            l=mid+eps;
    }
    printf("%.2lf",mid);
    return 0;
}
```

---

## 作者：念古兰 (赞：1)

## 首先我们要先想一下一个结论：一个图的最小生成树一定是所有生成树中，最大边权值最小的  
证明嘛：想一下krusal是怎样的，是不是一点一点往上加最小的边，对于可以替换边的（也即是在环里面）我们选的一定是最小的那个先连起来，这样我们得到的最小生成树一定就是最大边权值最小  
### **这个结论非常重要！！！**  
然后呢，回到原题，假如说我们一个卫星电话都没有，那么最小生成树的最大边就是答案了，因为你还要让这一条边也连上才能满足每一个哨所都能直接或间接与其他的联系    

那么，对于有m条卫星电话道的呢，这个如果前面看得懂的话应该不难想到：只要把最小生成树中最大的那些边都连上卫星道就可以了（可以等价于求的时候先把这些边的边权都变成0然后跑最小生成树），因为说这样等价后前面的边在求最小生成树的时候依然会连接上，类似于前面分析的情况  
所以这样求解可以得到最优解  
为了避免精度误差，距离采用先平方后开方处理，完整代码如下：
```
#include <bits/stdc++.h> 
using namespace std;
typedef long long ll;
const int maxn=5e5+10;
struct edge{
	int from,to,val;
	int nxt;
	bool operator < (edge &rhs)const{
	     return val < rhs.val;
	}
}e[maxn];
struct a{
	int x,y;
}lp[maxn];
int last[maxn],cnt,n,s,ans;
void inc(int x,int y,int v)
{
	e[++cnt].from=x;
	e[cnt].to=y;
	e[cnt].val=v;
	e[cnt].nxt=last[x];
	last[x]=cnt;
}
int f[maxn];
void init(void)
{
	for(register int i=1;i<=n;i++) f[i]=i;
}
int finds(int x)
{
	if(f[x] == x) return x;
	return f[x]=finds(f[x]);
}
void uni(int x,int y)
{
	x=finds(x),y=finds(y);
	if(x != y) f[x]=y;
}
int dis(int r1,int r2)
{
    int xx=(lp[r1].x-lp[r2].x)*(lp[r1].x-lp[r2].x);
    int yy=(lp[r1].y-lp[r2].y)*(lp[r1].y-lp[r2].y);
    return xx+yy;
}
void kru(void)
{
	int u=0;
	if(n-s==0) {ans=0;return;}
	for(register int i=1;i<=cnt;i++)
	{ 
		if(finds(e[i].from) != finds(e[i].to)) 
		{
			uni(e[i].from,e[i].to);
			u++;
			if(n-s==u) {ans=e[i].val;break;}
		}
	}
}
int main()
{
	scanf("%i%i",&s,&n);
	for(register int i=1;i<=n;i++)  scanf("%i%i",&lp[i].x,&lp[i].y);
	for(register int i=1;i<=n;i++)
	   for(register int j=1;j<=n;j++)
	     if(i!=j) 
	     {
	     	int d=dis(i,j);
	     	inc(i,j,d);
	     	inc(j,i,d); 
		 }
    init();
    sort(e+1,e+cnt+1);
    kru();
    printf("%.2f",sqrt(ans));
return 0;
}

```
代码中的(n-s==u)是由u==(n-1-(s-1))得到的，其中u是已经连上的边的数量  
~~并查集跟最小生成树应该没有人看不懂吧~~


---

## 作者：Starlight237 (赞：1)

### Note
1. 本题解重点：
- 法一（二分答案）
- 堆优化prim（题解中大多Kruskal，少数普通prim）
- “优化”部分
2. 非重点部分不会赘述，详见已有题解
### 解法分析
最小生成树满足最大边最小，所以有如下方法：
#### 法1
由题意显然可以发现，如果$d$满足题意但不是最小，则一定有$ans<d$；如果$d$不满足题意，一定有$ans>d$。

由此可见，可以使用**二分算法**。

至于检查函数check如何写？大家能想起prim模板是这样写的：
```cpp
inline int prim(){
	int ans=0;
	memset(flag,1,sizeof flag);
	memset(dst,0x3f,sizeof dst),dst[1]=0;
	Q.push(Node{1,0});
	while(!Q.empty()){
		Node now=Q.top();Q.pop();
		int k=now.v;
		if(!flag[k])continue;
		flag[k]=0;
		ans+=dst[k];
		for(reg int i=head[k];i;i=eg[i].nxt){
			int v=eg[i].v,w=eg[i].w;
			if(flag[v]&&w<dst[v])dst[v]=w,Q.push(Node{v,w});
		}
	}return ans;
}
```
题意限制只能有s个卫星电话，因此在二分时，如果当前的答案是d，我们可以统计最小生成树大于d的边数，如果小于等于s，则卫星电话是够用的。否则不可。

所以我们可以把```ans+=dst[k];```一句改为```ans+=dst[k]>d;```同时要给prim函数传入一个参数d。

然后check就可以这么写了：```return prim(d)<=s;```
#### 法2
法1的效率较低，因此我们考虑一次prim是否能出答案。

二分是从已知d的角度考虑判断，我们换一种思路，已知s，求是否能把图分为s个联通分量。事实上删掉最大的s-1条边可以完美满足题意，答案即为最小生成树第s大边。这在其他题解中有严格证明。
### 优化
本题大量double，所以可以考虑把边权扩大10000倍，在保持精度的情况下转小数为整数，输出时乘以0.0001即可。事实上，这对提速是很有帮助的。

另外本题为完全图，是一个典型稠密图，故堆优化Prim效率高于Kruskal。
### 代码（法2）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define IOSIZE 10000000
#define ll long long
static char in[IOSIZE],*p=in;
inline int read(){
	reg int x=0;
	while(*p<48)++p;
	while(*p>47)x=(x<<1)+(x<<3)+(*p++^48);
	return x;
}
static char flag[501];
static int n,s,tot,head[501];
static ll dst[501];
struct Edge{
	int v,w,nxt;
}eg[250001];
inline void addedge(int u,int v,int w){
	eg[++tot]=Edge{v,w,head[u]},head[u]=tot;
}
struct pnt{
	int x,y;
}pts[501];
static ll dis(int i,int j){
	pnt a=pts[i],b=pts[j];
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))*10000;
}
struct Node{
	ll v,dst;
	friend inline bool operator<(Node a,Node b){return a.dst>b.dst;}
};
priority_queue<Node>Q;
inline void prim(){
	ll ans=0;
	memset(flag,1,sizeof flag);
	memset(dst,0x3f,sizeof dst),dst[1]=0;
	Q.push(Node{1,0});
	while(!Q.empty()){
		Node now=Q.top();Q.pop();
		int k=now.v;
		if(!flag[k])continue;
		flag[k]=0;
		for(reg int i=head[k];i;i=eg[i].nxt){
			int v=eg[i].v,w=eg[i].w;
			if(flag[v]&&w<dst[v])dst[v]=w,Q.push(Node{v,w});
		}
	}
}
inline bool cmp(ll a,ll b){return a>b;}
int main(){
	fread(in,1,IOSIZE,stdin);
	s=read(),n=read();
	for(reg int i=1;i<=n;++i)pts[i]=pnt{read(),read()};
	for(reg int i=2;i<=n;++i)
		for(reg int j=1,ds;j<i;++j)
			ds=dis(i,j),addedge(i,j,ds),addedge(j,i,ds);
	prim();
	sort(dst+1,dst+n+1,cmp);
	printf("%.2lf",dst[s]*0.0001);
	return 0;
}
```
## 点赞是一种美德

---

## 作者：chdy (赞：1)

~~我有点神志不清所有有了这篇题解~~。

这道题的大意是有点难理解的至少我直接理解错了，
以为是一个裸的最小生成树然后直接标记点的个数统计答案。

但事实上并非如此 原因是 这道题的本意是一个瓶颈生成树
瓶颈生成树是 对于这样的一棵树 其最大的边权小于<=x。

引理：

- 最小生成树一定是瓶颈生成树
- 瓶颈生成树并非最小生成树

第二条显然不需要证明，对于第一条性质 
我们可以这样想如果一个最小生成树不是瓶颈生成树那其一边一定是>x的但是对于这样一条边连在了树上那么我们完全可以更改成<=x的边连在这颗树上，构成新的最小生成树 这和最小生成树冲突 故原命题成立。

论这道题的话其实求的是还是最小生成树 题目的意思的话是让我们去掉m-1条边后最大的那条边的值。

我wa过60仔细思考是 不能模拟点被安装电话的过程 原因是

我们是在自己生成的树中安装的电话 而这样并非最优，去掉m-1条边的原因是 m个点连起来最多创造m-1条边。这时答案怎么统计其实可以克鲁斯卡尔的时候直接统计即可。

```
sort(s+1,s+1+top);
    for(int i=1;i<=top;++i)
    {
        int xx=getfather(s[i].x);
        int yy=getfather(s[i].y);
        if(xx==yy)continue;
        f[xx]=yy;++w;
        if(n-w==m){printf("%.2lf",s[i].z);break;}
     }
```
对于当前已经生成了w条边 总共要生成n-1条边 我们可以搭建的只有m-1条边 故当 n-1-w==m-1后面的边都可以被省掉。
答案也就是上一条生成的边。

~~我也不知道自己脑抽了一直证明这个过程。。~~

---

## 作者：ForwarDer (赞：1)

首先分析题意：P个哨所都有直接或间接路径相连，且每条边的权值都尽可能最小。

这让我们想到了**最小生成树**

由于是重点对边进行处理。且这题数据范围较小，所以选择**kruskal**

这题并非全裸模板题，但是了解一下意思，显然就是最长的那**S**条边我~~不要~~了

因为卫星电话的距离不限，所以再长的边都可以不用无线电相连，于是把用卫星电话连起来的边去掉之后，就是应该用无线电通话连起来的了

因为要**统一采购**所以答案就是剩下边当中权值最大的

问题得到了解决


------------


具体实施参见代码

```c++
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <vector>
#define MAXN 505
using namespace std;
struct edge {
	int u, v;
	double w;
}g[MAXN*MAXN];  //一定要开MAXN*MAXN，因为一开始要建任意两点相连的图，为P*P 
int s, p, father[MAXN], x[MAXN], y[MAXN];
int findFa(int v);
vector<double> kruskal(int n, int m);  //kruskal返回一个vector，里面全是double，存的是在最小生成树里面的边 
bool cmp(edge a, edge b) {return a.w<b.w;} //表示边权小的应排在前面 

int main()
{
	cin>>s>>p;
	for(int i=1; i<=p; ++i)	cin>>x[i]>>y[i];
	int num=0;
	for(int i=1; i<=p; ++i) {
		for(int j=1; j<=p; ++j) {
			g[num].u=i;  g[num].v=j;
			g[num].w=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
			num++;
		}	  //建立一个任意两点相连的图 
	}
	vector<double> tree=kruskal(p, p*p); //拿到在最小生成树里面的边 
	sort(tree.begin(), tree.end());      //按边权从小到大排列 
	printf("%.2lf\n", tree[p-s-1]);      //输出剩下的边中最大的 
	return 0;	
}

int findFa(int v)
{
	if(v==father[v])	return v;
	int f=findFa(father[v]);
	father[v]=f;
	return f;       //并查集找爸爸函数 
}

vector<double> kruskal(int n, int m)
{
	vector<double> ans;
	sort(g+1, g+1+m, cmp);
	for(int i=1; i<=n; ++i) father[i]=i;  //放在这里初始化一下爸爸数组 
	for(int i=1; i<=m; ++i) {
		int fau=findFa(g[i].u);
		int fav=findFa(g[i].v);
		if(fau!=fav) {
			father[fau]=fav;
			ans.push_back(g[i].w);   //这里的操作并非和一般kruskal一样，是将g[i].w放入ans这个vector中 
		}
	}
	return ans;
}
```
 

---

## 作者：QWsin (赞：1)

直接Kruskal

然后由于有S个卫星发射站

就会有S-1条边权为0得边

然后
我比较笨= =

在Kruskal的时候把选了的边记录下来

最后排序

跑得有点慢  也许是vector的缘故

然后输出第S大的（楼下方法其实更好）

代码
```cpp

#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define repn(i) for(int i=1;i<=n;i++)
#define repm(i) for(int i=1;i<=tot;i++)

using namespace std;
const int maxn=500+5;
struct Post{
    int x,y;
    Post(){}
    Post(int x,int y):x(x),y(y){}
    void input(){
        scanf("%d%d",&x,&y);
    }
    double dis_to(const Post &rhs)const{
        double dx=rhs.x-x,dy=rhs.y-y;
        return sqrt(dx*dx+dy*dy);
    }
}p[maxn];
int m,n;
double d[maxn][maxn],u[maxn*maxn],v[maxn*maxn],w[maxn*maxn];
int init_data()
{
    int tot=0;
    cin>>m>>n;
    repn(i) p[i].input(); 
    repn(i) repn(j) if(i!=j)
    {
        u[++tot]=i;     v[tot]=j;
        w[tot]=p[i].dis_to(p[j]);
    }
    return tot;
}

vector<double>vv;
int id[maxn*maxn],f[maxn];

int cmp(int a,int b){return w[a]<w[b];}
int cmp1(double a,double b){return a>b;}
int findset(int x){return f[x]==x?x:f[x]=findset(f[x]);}
void Kruskal(int tot)
{
    repn(i) f[i]=i;
    repm(i) id[i]=i;
    sort(id+1,id+tot+1,cmp);
    repm(i)
    {
        int e=id[i];
        int x=findset(u[e]);
        int y=findset(v[e]);
        if(x!=y)
        {
            f[x]=y;
            vv.push_back(w[e]);
        }
    }
    sort(vv.begin(),vv.end(),cmp1);
}

int main()
{
    Kruskal(init_data());
    int x=vv.size();
    printf("%.2f",vv[m-1]);
    return 0;
}


```

---

## 作者：司徒stuart (赞：1)

大概意思就是 现在要跑一个最小生成树 你可以免掉S-1条边的边权

就先正常跑 然后把边权记录一下 能免掉几个就从大到小免掉就可以啦

然后输出就会ac了 神不神奇！


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<functional>
#include<cmath>
#include<algorithm>
#define MAXN 250100//一定要开的够大！！！不然会40 后三个点RE 
using namespace std;
int father[MAXN];
double ans[MAXN];
int flag[MAXN];
priority_queue<int>q;
struct edge{
    int from,to;
    double value;
};edge Edge[MAXN];
struct poin{
    double x;
    double y;
}; poin point[520];
bool cmp(edge x,edge y)
{
    return x.value<y.value;//比较函数 
}
int Find(int x)
{
    if(father[x]!=x)
    {
        father[x]=Find(father[x]);//路径压缩 
    }
    return father[x];
}
void Union(int x,int y)
{
    int fx=Find(x),fy=Find(y);
    if(fx!=fy)
    {
        father[fx]=fy;
    }
}
int main()
{
    memset(flag,1,sizeof(flag));
    int n,m,cnt=0;
    double aa,bb;
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        father[i]=i;
        cin>>point[i].x>>point[i].y;//预处理 
    }
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(i==j)continue;//特判 
            Edge[++cnt].from=i;
            Edge[cnt].to=j;
            Edge[cnt].value=sqrt((point[i].x-point[j].x)*(point[i].x-point[j].x)+(point[i].y-point[j].y)*(point[i].y-point[j].y));//预处理一下 
        }
    }
    sort(Edge+1,Edge+cnt+1,cmp);
    int cut=0;
    for(int i=1;i<=cnt;i++)
    {
        int a=Edge[i].from,b=Edge[i].to;
        if(Find(a)!=Find(b)) 
        {
            Union(a,b);
            ans[cut]=Edge[i].value;
            cut++;//把所有的边记录一下 然后最后输出的时候 把要刨掉的边刨去 直接输出就可以了
        }
    }
    printf("%.2f",ans[cut-n]);//输出要记得.2f 像我 直接用cout输出 就0分很难受 
    return 0;
}
```

---

## 作者：__世界第一弱__ (赞：1)

楼下的题解写的不大详细，于是便有人发了个问题在讨论里

这道题给了我们S个卫星电话，共有P个哨塔，因此只用卫星电话可连接S-1个哨塔

为了把剩下的P-S-1个哨塔和前S-1个哨塔连起来，我们需要连接P-S条边，半径设成这P-S条边中最长的边

于是乎跑个Kruskal/Prim就行了

我写的Kruskal

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
struct dot {
    int x,y;
} d[510];
struct edge {
    int fr,to;
    double v;
} E[250010];
int t,n,m=0,pre[510]={};
double ans=0;
bool cmp(edge a,edge b) {
    return a.v<b.v;
}
int Find(int x) {
    if(pre[x]!=x) return pre[x]=Find(pre[x]);
    else return x;
}
int main() {
    scanf("%d%d",&t,&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&d[i].x,&d[i].y);
    for(int i=1;i<=n-1;i++) for(int j=i+1;j<=n;j++) E[++m].fr=i,E[m].to=j,E[m].v=std::sqrt(std::abs(d[i].x-d[j].x)*std::abs(d[i].x-d[j].x)+std::abs(d[i].y-d[j].y)*std::abs(d[i].y-d[j].y));
    std::sort(&E[1],&E[m+1],cmp);
    for(int i=1;i<=n;i++)  pre[i]=i;
    for(int i=1,j=0;i<=m&&j<n-t;++i) {
        int x=Find(E[i].fr),y=Find(E[i].to);
        if(x!=y) {
            pre[x]=y;
            ans=E[i].v;
            ++j;
        }
    }
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：SpXace (赞：1)

一道并查集~~板子~~水题


核心在于， 我们将G数组（边）排序从小到大取，直到取到（p-s）即可，剩下的每个点配备卫星电话即可。

Ans 就是连接的边里面最长的那条，因为G数组已经排好序，所以每次直接覆盖Ans即可

开始还以为要特判s == 1的噻，发现并不用


```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm> 
using namespace std;
inline int Read()
{
	int s = 0,w = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') w = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
		s = (s << 3)+(s << 1) + ch - '0',ch = getchar();
	return w * s;
}
int p,s,fa[505],a[505],b[505],tot = 0; 
struct Edge{
	int x,y;
	double val;
}G[505*505];
double RT(int x1,int y1,int x2,int y2){    
    //边权用勾股定理，什么？你说不会？打哭你信不信（手动敲你脑壳）
	return sqrt(pow(double(x1-x2),2) + pow(double(y1-y2),2));
}
int find(int x){
	return fa[x] == x ? x : fa[x] = find(fa[x]); 
}
bool cmp(Edge A, Edge B){
	return A.val < B.val;
}
int main()
{
	s = Read(), p = Read();
	for(int i = 1; i <= p; ++i)	{
		fa[i] = i;
		a[i] = Read();
		b[i] = Read();
	}
	for(int i = 1; i <= p; ++i)
		for(int j = i + 1; j <= p; ++j) {
			G[++tot].x = i;
			G[tot].y = j;
			G[tot].val = RT(a[i],b[i],a[j],b[j]); 
		} 
	double Ans = 0;
	int cnt = 0;
	sort(G + 1, G + 1 + tot, cmp);
	for(int i = 1; i <= tot; ++i){
		int x = find(G[i].x);
		int y = find(G[i].y);	
		if(x != y)
		{
			++cnt;
			fa[x] = y;
			Ans = G[i].val;  	//每次更新Ans
		}
		if(cnt == p - s)   //取到p-s即可
        	break;
	}
	printf("%.2f",Ans);
	return 0;
}

```

---

## 作者：After__rain (赞：0)

额。。。感觉这个题，题解区的做法有点迷吧。。。。~~（讲道理，我觉得这个题跟最小瓶颈树没什么关系啊。。。。。。）~~

嘛，你把这个图建成完全图之后，我们发现，很难满足题目给定的小于等于S个卫星点。。。

这时候应该引入超级源点
就是说，是否决定要放卫星（对于每一个点来说）


然后又发现，题目求得的类似与最小瓶颈的这类东西。。。。。

于是乎就要二分啦。。。

二分答案，如果当前边大于答案，跳过


然后对于每一个连通块，来一次最小生成树
如果当前连接超级点的数量大于S
显然答案是小的

不然就是合法，可以变大。。。


~~可能最小瓶颈树的那个也是正解（原谅我知识浅薄）~~


```cpp
#include<bits/stdc++.h>
#define MAXN 505
using namespace std;

int s,p; 
int h[MAXN],fa[MAXN],tot;
double l = 0 , r = 40000 , mid , best;

struct node{
	int x,y;
}tu[MAXN];

struct node2{
	int from,to,next;
	double cost;
}e[MAXN*MAXN+50];

void add(int x , int y , double z){
	tot++;
	e[tot].from = x;
	e[tot].to = y;
	e[tot].cost = z;
	e[tot].next = h[x];
	h[x] = tot;
}

double cal(int a , int b){
	return sqrt( (tu[a].x - tu[b].x) * (tu[a].x - tu[b].x) + (tu[a].y - tu[b].y) * (tu[a].y - tu[b].y) );
}

bool cmp(node2 a , node2 b){
	return a.cost < b.cost;
}

int found(int x){
	if(fa[x] == x)return x;
	fa[x] = found(fa[x]);
	return fa[x];
}

void init(){
	memset(h , -1 , sizeof(h));
	tot = 0;
	cin>>s>>p;
	for(int i = 1 ; i <= p ; i++)cin>>tu[i].x>>tu[i].y;
	for(int i = 1 ; i <= p ; i++)for(int j = i + 1 ; j <= p ; j++)add(i , j , cal(i , j));
	sort(e + 1 , e + 1 + tot , cmp);
}

int check(){
	for(int i = 1 ; i <= p + 1 ; i++)fa[i] = i;
	for(int i = 1 ; i <= tot ; i++){
		if(e[i].cost > mid)break; 
		if(found(e[i].from) != found(e[i].to)){
				fa[found(e[i].from)] = found(e[i].to);
		}
	}
	int sum = 0;
	for(int i = 1 ; i <= p ; i++){
		if(found(p + 1) != found(i)){
				sum++;
				fa[found(i)] = found(p + 1);
		}
		if(sum > s)return 2;
	}
	return 1;
	
}

int main(){
	init();
	while((r - l) > 0.0001){
		mid = (l + r) / 2;
		if(check() == 2)l = mid + 0.0001;
		else r = mid - 0.0001 , best = mid;
	}
	printf("%.2f\n" , r);
}
```


---

## 作者：HoshiuZ (赞：0)

## 思路
要求每个点都直接或间接联通，那么便是最小生成树了。
$k$个卫星电话，实质上可以看成树中有$k$个点可以被看做为一个“点”，把这$k$个点从最小生成树中挖出来，并且使得这$k$个点构成的一个“点”仍然与原来的生成树相连。

由于要求的是最小的通讯距离，那么被挖出来的点在原来生成树中含有的边当然是越大越好，于是求出最小生成树后，将边按从大到小排个序，被挖出的$k$个点距离原生成树的距离其实就是这$k$个点在原来生成树中与其相连的边的最小值，即为第$k$大的边。那么排序后输出第$k$大的边即可。
## 代码（prim）
```cpp
#include<bits/stdc++.h>
#define INF 0xfffffff
using namespace std;

int s,p,point=1;
bool vh[510];
double x[510],y[510],dist[510],edge[510];

double distan(int a,int b) {
	return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));
}

bool cmp(double p,double q) {
	return p>q;
}

void prim() {
	for(int i=1;i<=p;i++) dist[i]=1e9;
	dist[1]=0;
	while(point<=p) {
		double mind=INF;
		int mint;
		for(int i=1;i<=p;i++) {
			if(!vh[i]&&dist[i]<mind&&dist[i]!=-1) {
				mind=dist[i];
				mint=i;
			}
		}
		vh[mint]=1;
		edge[point-1]=dist[mint];
		for(int i=1;i<=p;i++) {
			if(!vh[i]) {
				dist[i]=min(dist[i],distan(i,mint));
			}
		}
		point++;
	}
}		

int main() {
	cin>>s>>p;
	for(int i=1;i<=p;i++) cin>>x[i]>>y[i];
	
	prim();
	sort(edge+1,edge+point+1,cmp);
	cout<<fixed<<setprecision(2)<<edge[s]<<endl;
	
	return 0;
}
```


---

## 作者：Believe_R_ (赞：0)

### 题目传送门

[戳这里](https://www.luogu.org/problem/P1991)

### 题意分析

其实仔细看一下这题，我们不可避免地要将两点之间的距离求出来。于是我就写了一个```clac```函数来求：

```cpp
double clac(int xa, int ya, int xb, int yb)
{
    double now=sqrt((xa-ya)*(xa-ya) + (xb-yb)*(xb-yb));
    return now;
}
```

然后，因为我们要求满足条件的最小的 $D$ 。因为 $D$ 是在一个图中的，我们就可以考虑用最小生成树来求。同时，又因为有 $s$ 个点有卫星电话，这就意味着在最好的情况下，会有 $s-1$ 条边的边权为 $0$。

那么当我们求完最小生成树后，图中有 $n-1$ 条边。然后我们可以用贪心的思维，将这 $n-1$ 条边中最大的 $s-1$ 条边全部都变成 $0$ 。那么我们要求的 $D$ 就是生成树中剩下的边中最大的那条 $QwQ$ 

### 代码就看这里吧：

```cpp
#include <bits/stdc++.h>
#define Inf 0x3f3f3f3f
#define int long long
#define M 1001000
using namespace std;

int n, m, s;
int jx[M], jy[M], fa[M];
struct Node{
    int f, t; double d;
}a[M];                   //Kruskal 最小生成树建边

inline int read()
{
    int re=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0' && ch<='9') {re=re*10+(ch-'0'); ch=getchar();}
    return re*f; 
}

double clac(int xa, int ya, int xb, int yb)
{
    double now=sqrt((xa-ya)*(xa-ya) + (xb-yb)*(xb-yb));
    return now;
}                        //求两点之间的最小距离

double cmp(Node x,Node y)
{
    return x.d<y.d;
}

int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}						//Kruskal需要的函数

void Kruskal()
{
    for(int i=1;i<=n;++i) fa[i]=i;
    int tot=0;
    for(int i=1;i<=m;++i)
    {
        int fau=find(a[i].f), fav=find(a[i].t);
        if(fau==fav) continue;
        fa[fau]=fav;
        tot++;
        if(tot==n-s)
        {
            printf("%.2lf\n",a[i].d);
            return ;
        }
        if(tot==n-1) break;
    }
    return ;
}

signed main()
{
    s=read(); n=read();
    for(int i=1;i<=n;++i) jx[i]=read(), jy[i]=read();
    m=0;
    for(int i=1;i<=n;++i)
    {
        for(int j=i+1;j<=n;++j)
        {
            a[++m].f=i;
            a[m].t=j;
            a[m].d=clac(jx[i],jx[j],jy[i],jy[j]);
        }
    }
    sort(a+1,a+m+1,cmp);
    Kruskal();
    return 0;
}
```



---

## 作者：YZL11111 (赞：0)

题目链接：https://cn.vjudge.net/problem/17341/origin

## 【题目大意】
给你很多个点，要想将这些点连起来，有两种方式，第一，给你卫星的数量，任意距离的两个点可以用卫星联系且不算距离，第二，给你点的坐标，点与点之间可以用无线电联系，但是要消耗距离，让你找到一条线将这些点连起来并输出其中除了用卫星联系的边的最小值


## 【样例输入】
1   
2 4       
0 100        
0 300       
0 600          
150 750                               


## 【样例输出】
212.13       


## 【解题笔记】
最小生成树裸题，用Prim算法找到所有最小边后sort一下，输出最大边编号减去卫星数目减一的权值。


## 【AC代码】
```cpp
//邻接矩阵  63ms  4108KB  AC;
#include <cstring>
#include <cstdio>
#include <iostream>
#include <math.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
int s, p;
double x[1010], y[1010];  //注意跟数据有关的数组最好全用double型免得WA（。。。）
double G[1010][1010];
double dis[1010];
double temp[1010];
int vis[1010];
int main()
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d%d", &s, &p);
		for (int i = 1; i <= p; i++)
		{
			scanf("%lf%lf", &x[i], &y[i]);
		}
		for (int i = 1; i <= p; i++)
		{
			for (int j = 1; j <= p; j++)
			{
				if (i == j)
					G[i][j] = 0;
				else
				{
					G[i][j] = G[j][i] = (sqrt((x[i] - x[j]) * (x[i] - x[j]) / 1.00 + (y[i] - y[j]) * (y[i] - y[j]) / 1.00));
				}
			}
		}
		for (int i = 1; i <= p; i++)
		{
			dis[i] = G[1][i];
			vis[i] = 0;
		}
		int sum = 0, k = 0;
		int t = 0;
		vis[1] = 1;
		for (int i = 1; i <= p - 1; i++)
		{
			double Min = INF / 1.00;
			for (int j = 1; j <= p; j++)
			{
				if (!vis[j] && dis[j] < Min)
				{
					Min = dis[j];
					k = j;
				}
			}
			vis[k] = 1;
			temp[i] = Min;  //temp临时数组存放最小边
			for (int j = 1; j <= p; j++)
			{
				if (!vis[j] && dis[j] > G[k][j])
				{
					dis[j] = G[k][j];
				}
			}
		}
		sort(temp + 1, temp + p);  //sort一下
		printf("%.2f\n", temp[p - s]);  //一共有p-1条边再减去s再减去1的边就是答案
	}
	return 0;
}
```

## 【补】

后来我用Kruscal又写了一下，这题果然还是Prim算法更优

## 【AC代码】
```cpp
//Kruscal 邻接表  719ms 7952KB AC;
#include <cstring>
#include <cstdio>
#include <iostream>
#include <math.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
int s, p;
int cnt = 0;
double x[1010], y[1010];
double dis[1010];
int pre[1010];
struct node
{
	int from;
	int to;
	double w;
	bool operator < (const node& x)const
	{
		return w < x.w;
	}
}edge[500005];
void insert(int u, int v, double w)
{
	cnt++;
	edge[cnt].from = u;
	edge[cnt].to = v;
	edge[cnt].w = w;
}
int find(int r)
{
	if (pre[r] != r)
		return pre[r] = find(pre[r]);
	return pre[r];
}
void join(int a, int b)
{
	int fa = find(a);
	int fb = find(b);
	if (fa != fb)
	{
		pre[fa] = fb;
	}
}
int main()
{
	int t;
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d%d", &s, &p);
		for (int i = 1; i <= p; i++)
		{
			scanf("%lf%lf", &x[i], &y[i]);
			pre[i] = i;
		}
		cnt = 0;
		for (int i = 1; i <= p; i++)
		{
			for (int j = 1; j <= p; j++)
			{
				if (i == j)
					continue;
				else
				{
					double d = double(sqrt((x[i] - x[j]) * (x[i] - x[j]) / 1.00 + (y[i] - y[j]) * (y[i] - y[j]) / 1.00));
					insert(i, j, d);  //md我忘了这是个双向连通图，关键是他竟然提示我RE了，我检查半天反向边连上就A了，我惊了
					insert(j, i, d);
				}
			}
		}
		sort(edge + 1, edge + cnt + 1);
		int k = 0;
		for (int i = 1; i <= cnt; i++)
		{
			if (k == p - 1)
				break;
			if (find(edge[i].from) != find(edge[i].to))
			{
				join(edge[i].from, edge[i].to);
				dis[++k] = edge[i].w;
			}
		}
		printf("%.2f\n", dis[p - s]);
	}
	return 0;
}
```


---

## 作者：Mosher (赞：0)

### 一定程度上考察生成树的理解吧

**正文：**

解题思路:

1. 题目：  
   卫星电话（隐含意思）：可以**使某两点之间的距离变为0**,  
   最小通话距离 D：所构成的min代价联通路中，求边权的max

2. 进一步分析：  
   每个点，直接或间接联通？  
   那么，是不是可以理解为：边权越小，最好**近点相连**。  
   即：放弃掉**跨越中间点的连接方式**。

3. 算法：  
   连通性：只需n-1即可所有点（间接）相连-->树形  
   -->最小生成树：Kruskal、Prim  
   ```cpp
   可行性：在找寻最小生成树时，即可访问到边权的max，欲使其
   	所构成的min代价，那就可以把边权的max改为0啦！！！
   ```
   **核心：于是此问题转为：求边只有p-s个的最小生成树中的最大边权**
   
4. 关于本题：两种方式(Krus,Prim)皆可。  
   只是：Kruskal处理更方便，且在点少的图（稀疏图）更快，所以用的是它。（~~才不是因为Prim模板不够熟，才没打的，哼╭(╯^╰)╮！~~）

**Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double
const int maxn=125005;//一定得开大，下方预处理了每两点之间的距离
int s,n,f[maxn],cnt,tot;
db ans;
struct node{
	int x,y;
	db dis;
	friend bool operator <(node a,node b){
		return a.dis<b.dis;
	}
}num[maxn],e[maxn];//这里偷了个懒，具体看下方赋值

inline db count(int a,int b){
	return sqrt( (db)(num[a].x-num[b].x)*(db)(num[a].x-num[b].x) + (db)(num[a].y-num[b].y)*(db)(num[a].y-num[b].y) );
}

int find(int x){//并查集
	return x==f[x] ? x : f[x]=find(f[x]);
}

void Kruskal(){
	for(int i=1;i<=n;++i) f[i]=i;
	for(int i=1;i<=tot;++i){
		int x=find(e[i].x),y=find(e[i].y);
		if(x==y) continue;
		ans=max(ans,e[i].dis);//比较边权
		f[x]=y;
		if(++cnt==n-s) return;//上方推导，我们只需要满足条件的前n-s（即:n-1-（s-1））条边，剩下s-1视为0了
	}
}

int main(){
	scanf("%d%d",&s,&n);
	for(int i=1;i<=n;++i)
	scanf("%d%d",&num[i].x,&num[i].y);//坐标
	for(int i=1;i<=n;++i)
	for(int j=i+1;j<=n;++j){//从j=i+1的话，防止重复计算，每两个点只需要计算一次
		e[++tot].x=i;e[tot].y=j;//偷懒，将就一下吧
		e[tot].dis=count(i,j);//距离
	}
	sort(e+1,e+1+tot);//选小的
	Kruskal();
	printf("%.2lf",ans);
	return 0;
}
```
rp++

---

## 作者：Azuree (赞：0)

>直到敲完这个题，我才发现原来prim如果用邻接矩阵存图即使加上堆优化时间复杂度依然是O(n2)qwq……

首先，由于两个点只需要间接联通就可以互相通讯，所以这道题可以用最小生成树去做。这一步比较好完成。  
### 问题在于怎么去加卫星电话。  
由于两个点只要间接联通就可以，那么每一个用无线电收发器连成的子图只需要有一个卫星电话即可与其它的点联通，所以我们在删边的时候需要先判断一下这两个点删完边以后是不是仍然联通而不是傻傻地给这两个点都安装上卫星电话（被这个卡了好久qwq）

 ![](http://47.92.113.238/qxiangya/wp-content/uploads/2019/06/QQ截图20190619092553.png)    
如图所示，由于2、4号点都安装了电话，所以删掉边1-3后，1、3号点之间就不需要安装电话的。    

再来看如何安装电话。  
![](http://47.92.113.238/qxiangya/wp-content/uploads/2019/06/QQ截图20190619093110.png)  
如图，我们可以发现，当前两个点安装完卫星电话以后，每一个子图都会拥有一个卫星电话。当我们继续删边时，分成的两个新的子图都是一个有卫星电话，一个没有，所以我们从第二次开始每次删边只需要增加一部卫星电话即可。所以最终留下的最大的边是第`s`大的边（由于第一次删边你需要安装两台卫星电话，所以你最多只能删`s - 1`条边）  
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

struct NODE{
	int x, y, num;
	double minn;
}a[1000];

int s,p,vis[1000],del[1000],fa[1000],f[1000];

struct node{
	int k;
	double dis;
	bool operator < ( const node &x )const{return x.dis < dis;}
};

priority_queue <node> que;

int mysort(NODE a, NODE b){return a.minn > b.minn;}

int main()
{
	s = read(); p = read();
	for(re int i = 1; i <= p; i++)
	{
		a[i].x = read();
		a[i].y = read();
		a[i].num = i;
	}
	for(re int i = 1; i <= p; i++) a[i].minn = INF;
	que.push((node){1,0});
	vis[1] = 1;a[1].minn = 0;
	while(!que.empty())
	{
		node now = que.top();
		que.pop();
		vis[now.k] = 1;
		for(re int i = 1; i <= p; i++)
		{
			if(!vis[i] && sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y))) < a[i].minn)
			{
				a[i].minn = sqrt((a[now.k].x - a[i].x) * (a[now.k].x - a[i].x) + ((a[now.k].y - a[i].y) * (a[now.k].y - a[i].y)));
				que.push((node){i,a[i].minn});
				fa[i] = now.k;
			}
		}
	}
	sort(a + 1, a + p + 1, mysort);
	int j = 1;
	double Min = a[j].minn;
	Min = a[s].minn;
	printf("%.2lf\n",Min);
    return 0;
}
```

---

## 作者：LEGION (赞：0)

# 可以用二分


------------

~~但是要求对二分很不友好，个人认为输出应该保证可行~~
```c
struct type
{
	int x;int y;
}；
type s[MAXN];//结构体存位置
```
因为要精确到2位，所以在输入时扩大 1000 倍，注意用long long做，不然后期的求距离会爆int

- ### 判断链接条件 注意long long
```c
inline int Correct(type a,type b,int D)
{
	long long ax=a.x,bx=b.x,ay=a.y,by=b.y,DD=D;
	if((DD*DD)>=((ax-bx)*(ax-bx))+((by-ay)*(by-ay)))
    return 1;//距离公式
	else return 0;
}
```
- ### 用BFS求出某一D产生的连通块
```
int ASC(int D)
{
	memset(v,0,sizeof(v));//初始化访问数组
	int blocks=0;queue<int>q;
	for(int con=1;con<=N;con++)
	{
		if(v[con]==0)
		{
			blocks++;//连通块计数器
			v[con]=1;q.push(con);
			while(q.size()>0)//快乐BFS
			{
				int now=q.front();q.pop();
				for(int i=1;i<=N;i++)
				{
					if(Correct(s[now],s[i],D)==1&&v[i]==0)
					{
						q.push(i);v[i]=1;
					}
				}
			}
		}
	}
	return blocks;//返回连通块数量
}
```
## 卫星电话的数量大于等于连通块数量才可保证联通成立
### ~~这里就不说了~~

- ### 接下来就是愉快的二分+结果处理了
```
	int l=1,r=MAXD,mid;
	while(r>l+1)
	{
		int mid=(r+l)/2;
		if(ASC(mid)<=SP)r=mid;
        //判断条件，SP为卫星数量
		else l=mid;
	}//二分得到大整数
	
    int mod=l,remain=l,t=0;//大整数转分数输出
	mod=mod%1000;
	int mod_r=mod%10;mod=mod/10;
	if(mod_r>=5)mod++;//记得四舍五入
	remain=remain/1000;
	cout<<remain<<"."<<mod<<" ";
```
- ### 附上MAXD： 
```
#define MAXD 10010000
```

---

## 作者：木木！ (赞：0)

看到各位大佬都用Kruskal，本蒟蒻瑟瑟发抖……

# Prim算法

Prim算法就是对于一个点集$V$，每次找加入代价最小的点，把它加到这个点集里面。直观地想象就是联通块的扩展过程。

由于某种原因，Prim算法和Dijkstra算法惊人地相似，只有松弛操作不一样。Prim的松弛操作是`dist[ed[p]] = min(dist[ed[p]],len[p]);`，其中`p`表示正在枚举的边，`dist[i]`表示点i的代价。

# 本题解法

我首先是把卫星电话想象成一个虚点，度为S，连着它的边权为0。这样处理之后，虚点本身连入最小生成树的代价就是0，并且还余$S-1$条边。而对于任意一个点i，当虚点与他有一条边的时候，他加入最小生成树的代价即为0。

由于这里所求的D即为最大的代价，因此我们只要去掉最大$S-1$个代价，然后取剩下的最大值就好了。

时间复杂度$\Theta(n^2logn+nlogn) = \Theta(n^2logn)$

```cpp
#include <queue>
#include <cmath>
#include <cstdio>
using namespace std;

int n;
int xi[505];
int yi[505];

int sqr(int x)
{
	return x*x;
}

double dis(int a,int b)
{
	return sqrt(sqr(xi[a]-xi[b])+sqr(yi[a]-yi[b]));
}

double dist[505];
int visited[505];

void prim()
{
	for(int i=2; i<=n; ++i)
	{
		dist[i] = 2139062143;
	}

	priority_queue<pair<double,int> > pq;
	pq.push(make_pair(-dist[1],1));

	while(!pq.empty())
	{
		int th = pq.top().second;
		pq.pop();
		while(visited[th])
		{
			if(pq.empty()) break;
			th = pq.top().second;
			pq.pop();
		}

		visited[th] = 1;

		for(int i=1; i<=n; ++i)
		{
			if(!visited[i])
			{
				if(dis(th,i) < dist[i])
				{
					dist[i] = dis(th,i);
					pq.push(make_pair(-dist[i],i));
				}
			}
		}
	}
}

int main()
{
	int s;
	scanf("%d%d",&s,&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d%d",xi+i,yi+i);
	}

	prim();

	priority_queue<pair<double,int> > pq;
	for(int i=1; i<=n; ++i)
	{
		pq.push(make_pair(dist[i],i));
	}
	for(int i=1; i<s; ++i)
	{
		pq.pop();
	}

	printf("%.2lf\n",pq.top().first);

	return 0;
}
```

---

## 作者：KDL_橙子 (赞：0)

**解法：**

**找这张P个点的图的最小生成树，**

**然后找到最小生成树上第s大的边的边权；****

**细节：**

**1.两点间的边权可以先以平方的形式存下来，到最后再开方**

**2.可以使用priority_queue记录最小生成树上的边，方便比较**

~~**时间的话，最慢的在80ms**~~

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
double ans;
int s,p,cc=1,cnt=1,x[100001],y[100001],fa[100001];
priority_queue<int >q;
struct lxx
{
	int a,b,v;
}e[252525];
bool cmp(lxx a,lxx b)
{
	return a.v<b.v;
}
int find(int k)
{
	if(fa[k]==k)return k;
	return fa[k]=find(fa[k]);
}
void kruskal()
{
	for(int i=1;i<=cnt;i++)
	{
		int x=find(e[i].a),y=find(e[i].b);
		if(x!=y)
		{
			fa[x]=y;
			q.push(e[i].v);
			cc++;
			if(cc==p)return ;
		}
	}
}
int main()
{
	s=read(),p=read();
	for(int i=1;i<=p;i++)fa[i]=i;
	for(int i=1;i<=p;i++)x[i]=read(),y[i]=read();
	for(int i=1;i<=p;i++)
	{
		for(int j=1;j<=p;j++)
		{
			e[cnt].a=i;
			e[cnt].b=j;
			e[cnt].v=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
			cnt++;
		}
	}
	sort(e+1,e+1+cnt,cmp);
	kruskal();
	for(int i=1;i<s;i++)q.pop();
	ans=q.top();
	ans=sqrt(ans);
	printf("%.2lf",ans);
    return 0;
}

```

---

## 作者：Rbrq (赞：0)


首先对题目的意思进行理解一下，可以简化为：

 

    给出一个有p个点的图，以及每个点的坐标，你可以对s个点进行标记， 两端点都被标记的边边权为0， 最后求出在该图联通时最长边的最小值

 

分析一下这个题目

 


1.我们在求解最小生成树的时候一定从小到大选择最优的几条边，所以如果我们要使选出的边最短，该边一定在最小生成树上。

 

2.我们可以对s个点进行标记，让连接他们的边边权为0，此时，很显然删去边的数量越多越优，对于s个点而言，它们最多可以连s-1个边

 

根据分析 这个题目的题意可以被再一次简化为最小生成树上p-s+1短边

 

剩下就很简单了

 ```cpp
#include<bits/stdc++.h>
using namespace std; 
const int Maxn = 1100;
const int MAxn = 250010;

int s, p, m = 0, cntt = 0 , fa[Maxn]; 

double choose[MAxn];

struct stt {
    int x, y;
} node[Maxn]; 

struct st {
    int u, v;
    double w;
} edge[MAxn];

int find ( int x ) {
    return fa[x] == x ? x :fa[x] = find( fa[x] ); 
}

inline double comp (const st &a, const st &b) {
    return a.w < b.w ;
}

inline double dis ( int a, int b ) {
    double xd = ( node[a].x - node[b].x ); 
    double yd = ( node[a].y - node[b].y );
    double anss = sqrt ( xd * xd + yd * yd );
    return anss;
}

inline void add_edge ( int u, int v ) {
     edge[++m].u = u;
     edge[m].v = v;
     edge[m].w = dis( u, v );    
}

inline void kruscal () {
    int cnt = 0 ;
    sort(edge + 1, edge + 1 + m, comp);
    for ( int i = 1; i <= m; ++i ) {
        int uu = find ( edge[i].u );
        int vv = find ( edge[i].v );
        if( uu == vv ) continue ;
        fa[uu] = vv;
        choose[++cntt] = edge[i].w;
        if( ++cnt == p - 1 ) break ;
    }
}

int main () {
    scanf ( "%d %d", &s, &p );
    for ( int i = 1; i <= p; ++i ) fa[i] = i;
    for ( int i = 1; i <= p; ++i )
        scanf( "%d %d", &node[i].x, &node[i].y );
    for ( int i = 1; i <= p; ++i )
      for ( int j = i + 1; j <= p; ++j )
        add_edge ( i, j );
    kruscal () ;
    if ( cntt <= s ) printf ( "0.00" );  
    else  printf ( "%.2f", choose[cntt - s + 1] );
    return 0;
}
```

最后希望大家看看我[博客园](https://www.cnblogs.com/Hadesa/)和洛谷博客，双边更新


---

## 作者：cenbinbin (赞：0)

看到下面有很多想法，有二分的，有克鲁斯卡尔的。。。其实也就是一个近似裸的克鲁斯卡尔。。。

重要的是，**下面没有pascal的，作为p党，**有点想出手。。。

至于程序，不难理解，答案就最小生成树的第n大边。。。

加油！你可以的！

特别注意数据范围，不要像我一样得了40分。。。

=====================================================================================

```cpp
var
  f,a,b,x,y:array[0..250000]of longint;
  c,ans:array[0..1000000] of double;
  n,i,s,f1,f2,m,ss,j:longint;
function fr(x:longint):longint;
begin
 if f[x]=x then exit(x) else
 begin f[x]:=fr(f[x]);exit(f[x]);end;
end;
procedure qsort(l,r:longint);
var i,j,y1:longint;x1,xx:double;
begin
 i:=l;j:=r;x1:=c[(l+r) div 2];
 repeat
  while c[i]<x1 do inc(i);
  while x1<c[j] do dec(j);
  if not(i>j) then
   begin
   y1:=a[i];a[i]:=a[j];a[j]:=y1;
   y1:=b[i];b[i]:=b[j];b[j]:=y1;
   xx:=c[i];c[i]:=c[j];c[j]:=xx;
   inc(i);dec(j);
   end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
begin
  readln(s,n);
  for i:=1 to n do
   readln(x[i],y[i]);
  for i:=1 to n do
   for j:=1 to n do
    if (i<>j) then
     begin inc(m);a[m]:=i;b[m]:=j;c[m]:=sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j]));end;
  for i:=1 to n do f[i]:=i;
  qsort(1,m);//克鲁斯卡尔
  ss:=0;
  for i:=1 to m do
    begin
    f1:=fr(a[i]);
    f2:=fr(b[i]);
    if f1<>f2 then begin
      f[f1]:=f2;
      inc(ss);
      ans[ss]:=c[i];
      end;
    end;
  writeln(ans[ss-s+1]:0:2);
end.
```

---

## 作者：panzheng1999 (赞：0)

个人的想法大概是这样的：

卫星电话是个好东西啊，我们可以用一个kruskal，让后把前（s-1）长的路用卫星电话代替，这样剩下的最长路即为答案；

那么，现在我们这样做，用并查集来维护点集的话，卫星电话能把s个点变为一个，也就是初始集合数变成（p-s+1）个，这样再用kruskal，同时记录最后用的边长就得到答案了，正确性明显233（反正ac辣！）

相信大家的kruskal已经很熟练啦（不然的话可以去复习前两题）




       

```cpp
#include <iostream>
#include <queue>
#include <algorithm>
#include <cmath>
#include <cstdio>
using namespace std;
struct stu
{
    int fr;
    int to;
    double dis;
    friend bool operator < (const stu& a,const stu& b)
    {
        return a.dis>b.dis;//堆顶最小的优先队列
    }
};
int s,p;
double loc[2][505];//记录点的位置
double ans;//答案
int fa[505];//并查集
priority_queue <stu> q;
void add(int a,int b)
{
    stu temp;
    temp.fr=a;
    temp.to=b;
    temp.dis=sqrt(abs((loc[0][a]-loc[0][b])*(loc[0][a]-loc[0][b]))+abs((loc[1][a]-loc[1][b])*(loc[1][a]-loc[1][b])));
    //cout<<temp.dis<<endl;
    q.push(temp);
}
int findset(int x)
{
    if(fa[x]==x) return x;
    return findset(fa[x]);//找根，并且把路径变短，1-2-3-4变成1-2，1-3，1-4，大概是这样
}
void unionset(int x,int y)
{
    int fx=findset(x);
    int fy=findset(y);
    if(fx!=fy)    fa[fx]=fy;//合并
    return ;
}
void kruskal()
{
    for(int i=1;i<=p;i++)
        fa[i]=i;
    int nos=p-s+1;//用卫星电话处理后的集合数
    for(;;)
    { 
        if(nos==1) return ;//集合数为1就全连通喽
        stu t;
        t=q.top();
        q.pop();
        if(findset(t.fr)==findset(t.to)) continue;
        unionset(t.fr,t.to);//连点
        ans=t.dis;//记录答案
        nos--;
    }
}
int main()
{
    cin>>s>>p;
    for(int i=1;i<=p;i++)
    {
        cin>>loc[0][i]>>loc[1][i];//记录位置
    }//         x           y
    for(int i=1;i<=p;i++)
        for(int j=i+1;j<=p;j++)
        {
            add(i,j);//自己造出边
        }
    kruskal();
    printf("%.2lf\n",ans);
    return 0;
}
```

---

## 作者：geek痕 (赞：0)

先翻译一下题目吧。

首先就是要根据给定的点建图，也就是把每个点之间的距离算出来，这样以后就不用每一次要用的时候都算到。

然后说下思路，思考的时候先假设一个卫星电话都不让建，这就变成了最简单的最小生成树问题，只要把题给的点转换为边再走一遍最小生成树算法即可解决。

再考虑卫星电话，既然是最大值最小，那么卫星电话肯定得给到最大，第二大一直到第S大的电上才划算。

那么我们就新开一个数组，在创建最小生成树的过程中把树上每条边的长度都记录下来，然后跑完最小生成树后输出记录的长度中的倒数第S个即可。

就是这么一个题，思路稍微转个弯就和最小生成树无异了。具体看代码。









    
    
    
    

    
    
    
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
struct edge {
    int start;
    int end;
    float value;
    bool operator < (struct edge t) const {
        return value<t.value;
    }
} edgea[250005];
struct point{
    float x;
    float y;
}pointa[505];
int fa[505];
float pastroute[505];
int findset(int goal) {
    return fa[goal]==goal?goal:fa[goal]=findset(fa[goal]);
}
void mergea(int x,int y) {
    fa[findset(x)]=fa[findset(y)];
}
int main() {
    #ifdef LOCAL
    freopen("test.in","r",stdin);
    #endif
    int s,p;
    scanf("%d%d",&s,&p);
    for(int i=1;i<=p;i++) fa[i]=i;
    for(int i=1;i<=p;i++){
        float tx,ty;
        scanf("%f%f",&tx,&ty);
        pointa[i].x=tx;
        pointa[i].y=ty;
    }
    int cus=0;
    for(int i=1;i<=p;i++){
        for(int k=1;k<=p;k++){
            if(i!=k){
                float tfar=sqrt((pointa[i].x-pointa[k].x)*(pointa[i].x-pointa[k].x)+(pointa[i].y-pointa[k].y)*(pointa[i].y-pointa[k].y));
                edgea[cus].start=i;
                edgea[cus].end=k;
                edgea[cus].value=tfar;
                cus++;            
            }
        }
    }
    sort(edgea,edgea+p*(p-1));
    cus=0;
    for(int i=0;i<p*(p-1);i++){
        if(findset(edgea[i].start)!=findset(edgea[i].end)){
            mergea(edgea[i].start,edgea[i].end);
            pastroute[cus]=edgea[i].value;
            cus++;
        }
    }
    printf("%.2f\n",pastroute[cus-s]);
    return 0;
}
```

---

## 作者：KEIONG (赞：0)

这道题就是一个PJ难度   利用提供的电话减去最长边  n个电话可以减去n-1个较长边 所以利用kruskal只需要添加p-s条边

还有一个核心 就是要自己生成边  感觉数据有点弱 自己的暴力方法也是过了的

    
    
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
int s,p;
int fx[10010];
int fy[10010];
int f[10010];
struct P
{
    int x;
    int y;
    double v;
};
P e[1000010];
double d;
int cmp(P a,P b)
{
    return a.v<b.v;
}
int find(int x)
{
    if(f[x]!=x)
    {
        return f[x]=find(f[x]);
    }
    return x;
}
int main()
{
    for(int i=1;i<=10009;i++)
    {
        f[i]=i;
    }
    cin>>s>>p;
    for(int i=1;i<=p;i++)
    {
        cin>>fx[i]>>fy[i];
    }
    int t=1;
    for(int i=1;i<=p;i++)
    {
        for(int j=(i+1);j<=p;j++)
        {
            if(i!=j)
            {
                double tmp=sqrt((fx[i]-fx[j])*(fx[i]-fx[j])+(fy[i]-fy[j])*(fy[i]-fy[j]));
                e[t].v=tmp;
                e[t].x=i;
                e[t].y=j;
                t++;
            }
        }
    }
    t--;
    int cs=0;
    double maxn;
    int c=(p-s);
    sort(e+1,e+1+t,cmp);
    for(int i=1;i<=t;i++)
    {
        P temp=e[i];
        int sx=find(f[e[i].x]);
        int sy=find(f[e[i].y]);
        if(sx!=sy)
        {
            f[sx]=find(f[sy]);
            cs++;
            if(cs==c)
            {
                printf("%.2lf",e[i].v);
                return 0;
            }
        }
    }
}
```

---

## 作者：Snitro (赞：0)

##[http://blog.csdn.net/Fine\_rose/article/details/77054314](http://blog.csdn.net/Fine\_rose/article/details/77054314)


由于题目要求使无线电收发器的传输距离最小，也就是说我们不需要考虑卫星电话的传输距离。基于贪心的思想，我们只需要用卫星电话代替传输距离最长的几个无线电线路。那么得到的最大的传输距离一定是最小的。

使用 Kruskal 求最小生成树时，也是利用了贪心的思想。将各边按照从小到大的顺序排序，依次添加到最小生成树中，由于最小生成树有 n 个节点，那么其中一定有 n - 1 条边。由于我们使用卫星电话代替了最长的无线电线路，那么最后添加进最小生成树的线路一定会用卫星电话代替，因此我们只需要在最小生成树中添加 n - m (m 卫星电话的数量) 条边，最后添加的边就是最大的传输距离。

























```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <stack>
using namespace std;
int n, m; // n 个卫星电话  m 个哨所
int f[5005]; // 并查集
struct Edge {
    int from;
    int to;
    double value;
} edges[1000005]; // 记录所有的边
stack <Edge> ans; // 记录添加进最小生成树中的边
int edge_len; // 边的数量
struct Node {
    int x;
    int y;
} nodes[5005]; // 记录已经输入的哨所坐标
void add(int from, int to, double value) { // 添加边
    edge_len++;
    edges[edge_len].from = from;
    edges[edge_len].to = to;
    edges[edge_len].value = value;
}
bool cmp(Edge a, Edge b) {
    return a.value < b.value;
}
int getFrom(int id) { // 获取所属集合
    if (id == f[id])
        return id;
    return f[id] = getFrom(f[id]);
}
void Union(int a, int b) { // 合并两个元素所在的集合
    f[getFrom(a)] = getFrom(b);
}
bool check(int a, int b) { // 判断两个元素是否属于同一个集合
    return (getFrom(a) == getFrom(b));
}
int main() {
    freopen("in.txt", "r", stdin);
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
        f[i] = i;
    for (int i = 1; i <= m; i++) {
        cin >> nodes[i].x >> nodes[i].y;
        for (int j = 1; j < i; j++) // 将新输入的点与已经输入的所有点建立边
            add(j, i, sqrt(((long long)nodes[i].x - nodes[j].x) * ((long long)nodes[i].x - nodes[j].x) +
            ((long long)nodes[i].y - nodes[j].y) * ((long long)nodes[i].y - nodes[j].y)));
    }
    sort(edges + 1, edges + 1 + edge_len, cmp); // 排序所有的边
    int cnt = 0; // 记录已经加入最小生成树的边的数量，也可以用 ans.size() 代替
    for (int i = 1; i <= edge_len && cnt < m - n; i++) { // Kruskal 求最小生成树
        Edge &edge = edges[i];
        if (!check(edge.from, edge.to)) { // 如果不属于同一个集合
            Union(edge.from, edge.to); // 合并两个点所位于的集合
            ans.push(edge); //添加进最小生成树
            cnt++;
        }
    }
    printf("%.2f", ans.top().value); // 由于使用栈存储的边，所以栈顶是当前的最小生成树中最大的边
    return 0;
}
```

---

## 作者：Rapiz (赞：0)

看了下好像没有靠谱的二分题解。

显然我们可以二分d然后在判断是否可行

用并查集维护连通性。

由于数据范围非常小，我们暴力n2遍历每个点对，距离小于当前答案就合并。

最后统计联通块个数，<s就合法。


>#include<cstdio>
```cpp
#include<cmath>
const int MAXV=610;
const double D=1e-5;
struct P{double x,y;}poi[MAXV];
inline double sqr(double a){return a*a;}
inline double dis(P& a,P& b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
int n,m,p[MAXV];
double l=0,r=20000,mid;
int find(int x){return x==p[x]?x:p[x]=find(p[x]);}
bool check(){
    for(int i=1;i<=n;i++) p[i]=i;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++) if(i!=j&&dis(poi[i],poi[j])<=mid){
            int x=find(i),y=find(j);
            if(x!=y) p[x]=y;
        }
    }
    int cnt=0;
    for(int i=1;i<=n;i++) cnt+=p[i]==i;
    return cnt<=m;
}
int main(){
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++) scanf("%lf%lf",&poi[i].x,&poi[i].y);
    while(r-l>D){
        mid=(l+r)/2;
        if(check()) r=mid;
        else l=mid;
    }
    mid=(l+r)/2;
    printf("%.2lf",mid);
}
```

---

## 作者：a526955194 (赞：0)

看题解（里程序）比较少于是心血来潮就发了一下

（顺便吐槽一下最下面的两位是什么鬼啊

大致思想是用克鲁斯卡尔算法  等到接上第（p-s）条边时终止程序（因为之后的可以用卫星）

（刚开始因为数据范围没仔细看数组开小了看了好久所以现在数组大得不必要）

```cpp

#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
int xx[1005],yy[1005],s,p,i,j,t,f[1000005],total;
double ans;
struct xxy
{
    double x,y,cost;
}a[1000005];
bool cmp(xxy p,xxy q)
{
    return p.cost<q.cost;
}
int search(int p)
{
    if (f[p]==p) return p;
    return search(f[p]);
}
bool judge(int p,int q)
{
    if (search(p)==search(q)) return true;
    return false;
}
void hebing(int p,int q)
{
    int e,r;
    e=search(p);
    r=search(q);
    f[e]=r;
    return;
}
int main()
{
    scanf("%d%d",&s,&p);
    for (i=1; i<=p; i++)
    {
        scanf("%d%d",&xx[i],&yy[i]);
        for (j=1; j<=i-1; j++)
        {
            t++;
            a[t].cost=sqrt((xx[i]-xx[j])*(xx[i]-xx[j])+(yy[i]-yy[j])*(yy[i]-yy[j]));
            a[t].x=i;
            a[t].y=j;
        }
    }
    for (i=1; i<=p; i++)
        f[i]=i;
    sort(a+1,a+t+1,cmp);
    for (i=1; i<=t; i++)
    {
        if (judge(a[i].x,a[i].y)) continue;
        hebing(a[i].x,a[i].y);
        ans=a[i].cost;
        total++;
        if (total>=p-s)
        {
            printf("%.2lf",ans);
            return 0;
        }
    }
    return 0;
}

```
然后Orz一下下面用二分做的大神


---

## 作者：TMXi (赞：0)

楼下的题解为什么好诡异→\_→  这题换过题干吧。。。


好了说正经的。。。


因为p个点任意联通，可以开邻接矩阵记录p^2-p条边。。。


这题贪心貌似是不行的【23333】

最开始本来想Prim做，然后用堆维护s个最长边，这s个边至少会涉及s+1个点，至多会涉及2\*s个点，按边从长到短选出有关的s个点并记录，然后把这m个点之间s^2-s条边长设为0

然后prim。。。[color=#FF0000]结果WA了两个点。。。[/color]


有神犇说用**并查集**。。。

并查集&二分优化

数据范围看貌似不会TLE

用二分找最短距离，然后并查集看有多少连通点，若小于s则记录，还是最后把记录的点之间的边清零，然后kruskal

果然不会TLE。。。


---


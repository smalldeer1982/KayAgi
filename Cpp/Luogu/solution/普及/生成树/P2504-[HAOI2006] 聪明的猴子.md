# [HAOI2006] 聪明的猴子

## 题目描述

在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。

现在，在这个地区露出水面的有 $N$ 棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。

在这个地区住着的猴子有 $M$ 个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。

现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。


## 说明/提示

对于 $40\%$ 的数据，保证有 $2 \le N \le 100$，$1 \le M \le 100$

对于全部的数据，保证有 $2 \le N \le 1000$，$1 \le M \le500$

感谢 @charlie003 修正数据

## 样例 #1

### 输入

```
4
 1 2 3 4
6
0 0
1 0
1 2
-1 -1
-2 0
2 2```

### 输出

```
3```

# 题解

## 作者：哥就是拽 (赞：47)

题目很水  
代码简单易懂  
~~偷看了一下标签~~  
## 没错就是生成树！！！  
# 思路：
把两个点之间的距离算出来，一边Kruskal，记录下最大的边，和每只猴子的跳跃距离比较一下，如果跳跃距离大就ans++。    

最后附上代码    

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,ans=0;
double sum=-1;
int a[1000005][3],b[1000005],pre[1000005];//	前面一直RE，开大一点；

struct zzz {
	int x,y;
	double p;
} z[1000005];

int cmp(zzz k,zzz d) {
	return k.p<d.p;
}

int find(int x) {
	if(pre[x]==x)
		return x;
	return pre[x]=find(pre[x]);
}

int main() {
	cin>>m;
	for(int i=1; i<=m; i++) {
		cin>>b[i];
	}
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i][1]>>a[i][2];
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=n; j++) {
			if(i!=j) {
				k++;
				z[k].x=i;
				z[k].y=j;
				z[k].p=sqrt((a[i][1]-a[j][1])*(a[i][1]-a[j][1])+(a[i][2]-a[j][2])*(a[i][2]-a[j][2]));
			}
		}
	}	
	int cnt=n;//Kruskal！！！
	sort(z+1,z+k+1,cmp);
	for(int i=1; i<=n; i++) {
		pre[i]=i;
	}
	for(int i=1; i<=k; i++) {
		if(cnt==1)
			break;
		int s1=find(z[i].x),s2=find(z[i].y);
		if(s1!=s2) {
			pre[s1]=s2;
			cnt--;
			sum=z[i].p;
		}
	}
	for(int i=1; i<=m; i++) {//比较
		if(sum<=b[i])
			ans++;
	}
	cout<<ans<<endl;//完美输出
	return 0;
}
```
## 第三次发题解，有错误请各位神犇指点  

最后安利一下我的[博客](https://www.luogu.org/blog/zhaozizhuo/)


---

## 作者：K2sen (赞：16)

# P2504
[传送门](https://www.luogu.org/problem/P2504)
当然是生成树....

## 题意:
给出所有猴子的最大跳跃距离，然后给你很多树，显然是让你搞一个最小生成树.

然后让你看看有几只猴子比这棵生成树上的所有边的长度都长.

## 思路:
比所有边都长的话，那就是跳跃距离比最长的边都大的话，那就比所有的都大了，然后那只猴子就可以跳到所有的树上了.

先看看怎么建边吧,大家应该都会..

先记录一下所有边的坐标，然后对每两个点都建一条边.
长这样：

```cpp
	for (int i = 1; i <= m; i++) px[i] = read(), py[i] = read();//先把边读进去
	int cnt = 0;//记录边的数量.sort用到
	for (int i = 1; i <= m; i++) 
		for (int j = i + 1; j <= m; j++) {
			edge[++cnt].x = i;//记录这条边连得两个点
			edge[cnt].y = j;
			edge[cnt].dis = sqrt((px[i] - px[j]) * (px[i] - px[j]) + (py[i] - py[j]) * (py[i] - py[j]));//欧几里得距离.
		}
```

生成树板子的话我就不放了.直接看代码吧.

### code:
```cpp
#include <bits/stdc++.h>
#define N 1000010
#define M 1010

using namespace std;
double px[M], py[M]; int fath[M];
int n, m, monkey[501];
struct node {
	int x, y;
	double dis;
}edge[N];

int read() {
    int s = 0, f = 0; char ch = getchar();
    while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
    return f ? -s : s;
}

bool cmp (node a, node b) { //sort用
	return a.dis < b.dis;
}

int father(int x) {
	if (fath[x] != x) fath[x] = father(fath[x]);//kruskal并查集用
	return fath[x];
}

void unionn(int x, int y) {
	int fx = father(x), fy = father(y);//kruskal并查集用
	fath[fx] = fy;
}

int main() {
	n = read();
	for (int i = 1; i <= n; i++) monkey[i] = read();
	m = read();
	for (int i = 1; i <= m; i++) px[i] = read(), py[i] = read();
	int cnt = 0;
	for (int i = 1; i <= m; i++) 
		for (int j = i + 1; j <= m; j++) {
			edge[++cnt].x = i;
			edge[cnt].y = j;
			edge[cnt].dis = sqrt((px[i] - px[j]) * (px[i] - px[j]) + (py[i] - py[j]) * (py[i] - py[j]));
		}
	sort(edge + 1, edge + cnt + 1, cmp);
	for (int i = 1; i <= m; i++) fath[i] = i;
	double maxn = -1; int po = 0;
	for (int i = 1; i <= cnt; i++) {
		if (father(edge[i].x) != father(edge[i].y)) {
			unionn(edge[i].x, edge[i].y);
			po++;
			maxn = max(maxn, edge[i].dis);//记录一下长边的长度.
		}
		if (po == m - 1) break;
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) if (monkey[i] >= maxn) ans++;
//如果一只猴子的最大跳跃距离比最长边都长，那么他就可以在这棵生成树上随便跳了（为所欲为）
	cout << ans;
}
```

---

## 作者：sukimo (赞：9)

这道题只要理清了思路，就会发现是MST裸题。MST具有的一个性质：“MST的最大边权是这个图所有生成树的最大边权中最小的。”对于一只猴子，它能否跳到每棵树上，取决于它跳跃的生成树的最大边权是否会超过它的跳跃限度，而MST可以做到“最大边权最小”，如果某只猴子按照MST来跳跃，就可以尽量的把跳跃的最大边权控制到最小，这样就很好的划分出来了。先用prim求出MST（不用kruskal的原因是kruskal是把所有的边全部弄出来再做，而prim是边做边求，不会浪费兀余的的空间），边做边找到最大边权，然后对于每只猴子比较一下就好了。代码见下：

```
#include<bits/stdc++.h>
#define db double
using namespace std;
const int INF=0x3f3f3f3f;db MST_max,dis[1005],vis[1005];int n,jump[505];
struct STR1{db x,y;}pos[1005];struct STR2{int ind;db num;};
STR2 pack(int ind,db num){STR2 a;a.ind=ind;a.num=num;return a;}
struct HEAP{
	int tail;STR2 tree[5000005];HEAP(){tail=0;}
	STR2 _top(){return tail?tree[1]:pack(-1,INF);}
	void _insert(STR2 q){
		tree[++tail]=q;int p=tail;
		while(p>1&&tree[p].num<tree[p>>1].num){swap(tree[p],tree[p>>1]);p>>=1;}
	}
	void _delete(){
		tree[1]=tree[tail--];int p=1;
		while(p<<1<=tail){
			int son=p<<1;if(son<tail&&tree[son].num>tree[son+1].num)son++;
			if(tree[son].num>=tree[p].num)break;
			swap(tree[son],tree[p]);p=son;
		}
	}
}heap;
db solve(int a,int b){return sqrt((pos[a].x-pos[b].x)*(pos[a].x-pos[b].x)+(pos[a].y-pos[b].y)*(pos[a].y-pos[b].y));}
void prim(){
	heap._insert(pack(1,0));for(int i=2;i<=n;i++)dis[i]=INF;
	for(int i=1;i<=n;i++){
		while(vis[heap._top().ind])heap._delete();
		STR2 q;q=heap._top();MST_max=max(MST_max,dis[q.ind]);dis[q.ind]=0;vis[q.ind]=1;
		for(int j=1;j<=n;j++)
			if(solve(q.ind,j)<dis[j])heap._insert(pack(j,dis[j]=solve(q.ind,j)));
	}
}
int main(){
	int m,cnt=0;scanf("%d",&m);
	for(int i=1;i<=m;i++)scanf("%d",&jump[i]);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lf%lf",&pos[i].x,&pos[i].y);
	prim();
	for(int i=1;i<=m;i++)if(MST_max<=jump[i])cnt++;
	printf("%d",cnt);
	return 0;
}
```


---

## 作者：Blue_wonders (赞：9)

# 生成树 AC
### 照样排坑
- 其实没啥坑，，注意数组范围就好
- 边的条数不是点的个数，所以求边的数组要开到

[数组开小了就这样了(我一开始边的条数是点的个数)](https://www.luogu.org/recordnew/show/16243026)

### 方法


------------
	
#### 小优化：
求两点之间距离是
```cpp
sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
```
我们可以不进行开根处理，反而将猴子跳跃的距离平方，其结果是相同的，直接去掉开根，使边的长度便于存储和计算

------------

#### 然后正式讲说一下怎么做的
- 先输入猴子数量以及每只猴子能跳多远
- 对每只猴子的跳跃距离进行平方处理
- 输入每个点
- 每两个点之间建立一条边(每条边的长度是两点的距离的平方)(因为只是最小生成树问题，所以[i][j]与[j][i]是一样的，只建立一条边就够了)
- 将所有边从小到大排序
- 判断每条边两点是否在一棵树上，如果不在就将两个点合并，如果在就不用管
- 如果所有点都已经在树上了就退出输出树中最大的边(因为排过序所以最大的边就是最后进入树的边)
- 对所有的猴子跳过的距离进行比较
- 输出
### 具体AC代码
[具体AC情况](https://www.luogu.org/recordnew/show/16243288)
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int n,m,q=0;
int o[501];
int f[1001];
int d[1001][1001];
struct point{//记录点的横纵坐标
    int x,y;
} h[1001];
struct edge{//记录边的开始(s)结束(e)长度(w)
    int s,e,w;
} g[1001000];
int cmd(edge a,edge b){return a.w<b.w;}//按边的长短从小到大排序
int find(int s){if(f[s]==s||f[s]==0)return f[s]=s;//如果这个点没有加入任何一棵树(f[s]==0)或者这个点的树是自己(f[s]==s)，那么这个点的树是它自己
else return f[s]=find(f[s]);}//如果这个点已经加入一个树了，那么输出这个树的树根
int k(){//最小生成树函数
    int cnt=0;//记录树上已经有几条边
    for(int i=1;i<=q;i++){//每条边都进行判断
        int x=find(g[i].s);//看看起点在哪棵树上
        int y=find(g[i].e);//看看终点在哪棵树上
        if(x!=y){//如果起点终点不在同一棵树上
            f[x]=y;//合并成为一棵树
            if(++cnt>=m-1)return g[i].w;//如果合并后边的个数是点的个数减一那么代表所有点都在树上了，返回最后一条加入的边的长度(因为排过序，所以一定是最长的)
        }
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>o[i];
        o[i]=o[i]*o[i];//对每个猴子的跳跃距离进行平方处理
    }
    cin>>m;
    for(int i=1;i<=m;i++){//输入点的坐标
        cin>>h[i].x>>h[i].y;
    }
    for(int i=1;i<=m;i++){//每两个点行程一条边
        for(int j=1;j<=m;j++){
            if(i>=j)continue;//因为是生成树所以点的顺序方向没有要求(例：[1][2]和[2][1]没有区别所以可以去掉一条边)
            int u=(h[i].x-h[j].x)*(h[i].x-h[j].x)+(h[i].y-h[j].y)*(h[i].y-h[j].y);//两点距离的平方方便运算不开根
            if(u!=0)g[++q]=(edge){i,j,u};//记录边的起始和结束以及距离
        }
    }
    sort(g+1,g+1+q,cmd);//从小到大排序
    int p=k();//进入最小生成树函数
    int t=0;
    for(int i=1;i<=n;i++){
        if(o[i]>=p)t++;
    }
    cout<<t;
    return 0;
}
```
感谢大家能看我的题解！

---

## 作者：暮光闪闪 (赞：6)

# 最小生成树板子题

看到没人发 $Prim$ 的优先队列优化，这里发一个。我猜没有 $Prim$ 题解是因为不加优先队列会超时？（~~仅仅是猜测~~）

如果一只猴子跳跃距离比最小生成树上最大边都长的话，猴子就可以跳到所有的树上了。

算出任意两棵树之间的距离并建边，跑个最小生成树再依次看猴子跳不跳得过就行了。具体看代码
# 代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#include<queue>
using namespace std;
long long n,jump[600],x[1200],y[1200],cnt,head[1200],dis[1200],max_dis=0;
bool vis[1200];
struct{
	long long v,nxt,w;
}e[2001000];//链式前向星
void adde(long long u,long long v,long long w){
	e[++cnt].v=v;
	e[cnt].w=w,e[cnt].nxt=head[u];
	head[u]=cnt;
}//建边
void prim(){
	typedef pair<long long,long long>p;
	priority_queue<p,vector<p>,greater<p> >q;//优先队列按树间距离从小到大排序，nlogn复杂度
	long long chosen_point_num=1,u=1;//chosen_point_num表示已经完成建树的点的数量。等于n时说明整棵树建完了
	memset(dis,0x3f,sizeof(dis));//初始树间距离为无穷大
	for(long long i=head[u];i;i=e[i].nxt){
		long long v=e[i].v;dis[v]=min(dis[v],e[i].w);
		q.push(make_pair(dis[v],v));
	}//初始化，把1号点周围的点加入优先队列作为待加入点
	while(++chosen_point_num<=n){
		vis[u]=1;//已经选的点打上标记，以后不再重复选
		while(vis[q.top().second])q.pop();//忽略已经选的点
		max_dis=max(max_dis,q.top().first);//这就是长度最小的边了，更新最小生成树中最长边长度，即更新max_dis
		u=q.top().second;q.pop();
		for(long long i=head[u];i;i=e[i].nxt){//继续扩展
			long long v=e[i].v;
			if(vis[v]==0&&dis[v]>e[i].w){//选过的点跳过
				dis[v]=e[i].w;
				q.push(make_pair(dis[v],v));//新更新的可选点加入优先队列
			}
		}
	}
}
int main(){
	long long m,ans=0;cin>>m;
	for(long long i=1;i<=m;i++){
		scanf("%lld",&jump[i]);
		jump[i]*=jump[i];//存猴子跳跃距离，这里平方一下后面建边时就不用开方了
	}
	cin>>n;
	for(long long i=1;i<=n;i++)
		scanf("%lld%lld",&x[i],&y[i]);
	for(long long i=1;i<=n;i++)
		for(long long j=i+1;j<=n;j++){
			long long tmp=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);//建边时建欧拉距离，前面猴子跳跃距离已平方，不用开方了
			adde(i,j,tmp),adde(j,i,tmp);//两两建双向边
		}
	prim();
	for(int i=1;i<=m;i++)if(jump[i]>=max_dis)ans++;
	cout<<ans;
	return 0;
}
```

---

## 作者：LevenKoko (赞：6)

主要思路：生成数【~~废话~~】~~（几乎是裸的）~~
详情见下面代码里面的注释

P.S. 这题情境下prim更快，但。。。
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
struct P
{
	int x,y,z;
}a[2500005];//结构体
int fa[1005],n,m,p=0,ans=0,x[1005],y[1005];
int j[1005];//j->每只猴子jump的范围
int fx,fy;

int find(int x)//找爸爸
{
	if(fa[x]==x) return x;
	else return fa[x]=find(fa[x]);
}

bool cmp(P q,P w)
{
	return q.z<w.z;
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>j[i];
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		fa[i]=i;
		cin>>x[i]>>y[i];
		fx=x[i],fy=y[i];
		for(int j=1;j<i;j++)
		{
			p++;//记录边的总数
			int fxx=fx-x[j],fyy=fy-y[j];
			int s=fxx*fxx+fyy*fyy;//来一个欧几里得距离
			a[p].x=i;
			a[p].y=j;
			a[p].z=s;
		}
	}
	sort(a+1,a+p+1,cmp);
	
	for(int i=1;i<=p;i++)
	{
		fx=find(a[i].x),
		fy=find(a[i].y);
		if(fx==fy) continue;
		fa[fx]=fy;
		ans=a[i].z;//因为已经排序过了，就不用max了，最后取到的就是最大的
	}
	double q=sqrt(ans);刚开始忘了，后来在**no_one_cm_Fe_in_hand**的帮助下发现；
	int rans=0;//最后答案
	for(int i=1;i<=n;i++)
	{
		if(q<=j[i]) rans++;
	}
	cout<<rans;
	return 0;
}
```

---

## 作者：无羡qwq (赞：4)

原谅我太水了。。。。竟然想到了每个猴子跑一遍最小生成树。。。。。。但是在加上ans=m-i+1和break后竟然过了。。。。。233  于是来写一下题解（很暴力直接的方法,不知道会不会给我过。。。。。
```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
template <class T> void read (T &x)
{
    int f=0; x=0; char ch=getchar();
    while(ch<'0'||ch>'9')  
    {
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        f=(x>>1)+(x>>3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}
int father[2001],x[2001],y[2001];
double jump[2001];
int m,n;
int find(int x)
{
    if(father[x]==x)  return x;
    else {
        int ff=find(father[x]);
        return father[x]=ff;
    }
}

int main(){
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%lf",&jump[i]);
    
    }
    scanf("%d",&n);
    sort(jump+1,jump+1+m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x[i],&y[i]);
    }
    int ans=0;
    for(int i=1;i<=m;i++)
    {
        for(int q=1;q<=n;q++)
           {
             father[q]=q;
         }
        int sum=0;
        for(int j=1;j<n;j++)
        {
            for(int k=j+1;k<=n;k++)
            {
                int temp1=find(j);
                int temp2=find(k);
                if(temp1==temp2)  continue;
                double lenth=sqrt((x[j]-x[k])*(x[j]-x[k])+(y[j]-y[k])*(y[j]-y[k]));
                if(lenth<=jump[i] )
                {
                    father[temp1]=temp2;
                    sum++;
                    if(sum==n-1)  break;
                }
                if(sum==n-1)  break;
            }
            if(sum==n-1)   break;
        }
        if(sum==n-1)
            {
             ans=m-i+1;
            break;
        }
            
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：望眼浮云 (赞：4)

显然是生成树，~~惊了，还有这么水的省选题~~

如果一个猴子能跳到所有树上，那么它的最大跳跃距离要大于最小生成树上的最大的边。

这样就简单了，把两个点之间的距离算出来，一边Kruskal，记录下最大的边，和每只猴子的跳跃距离比较一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,m,z,x[1000005],y[1000005],f[1000005],t,ans,jump[1000005]; 
double sum;  //sum记录最小生成树上最大的边
struct node{
	int a,b;
	double c;
}s[1000005]; //s记录边，点a到点b之间距离为c
int find(int u){   //并查集找爸爸
	if(f[u]==u) return u;
	else return f[u]=find(f[u]);
}
bool comp(node a,node b){
	return a.c<b.c; 
}
int main(){
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
        scanf("%d",&jump[i]);  //跳跃距离
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&x[i],&y[i]);   //树的位置
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)     //把不同的两个点连上边
        if(i!=j){
            t++;
            s[t].a=i,s[t].b=j,s[t].c=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
        }
    for(int i=1;i<=t;i++)    
        f[i]=i;
    sort(s+1,s+t+1,comp);  //给边排序
    for(int i=1;i<=t;i++)  //Kruskal
    {
        int u=find(s[i].a);
        int v=find(s[i].b);
        if(f[u]!=f[v])
        {
            f[u]=v;
            k++;
            sum=s[i].c;  //更新sum,越后取的边越大
        }
        if(k==n-1) break; //数据水啊，之前写成t-1都过了
    }
    for(int i=1;i<=m;i++)  
        if(jump[i]>=sum) ans++;  
    printf("%d",ans);
    return 0;
}

```

---

## 作者：jiangby (赞：3)

机房考试考了这个题，我第一眼居然没看出来是prim，考试之后才发现的。
我用的是二分+bfs判断能不能走完每一个就可以过
```
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
#include<vector>
#include<deque>
#include<set>
#include<map>
#define N 100005
using namespace std;
const int INF=1<<29;
struct Node{
	int x,y;
}a[N];
int s[N],v[N];
int l=INF,r=-INF;
int n,m;
double jl(int x,int y){
	return sqrt((a[x].x-a[y].x)*(a[x].x-a[y].x)+(a[x].y-a[y].y)*(a[x].y-a[y].y));
}
bool check(int s){
	int xx=1;
	memset(v,0,sizeof(v));
	queue<int>q;q.push(1);v[1]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=1;i<=n;i++){
			if(!v[i]&&jl(i,x)<=s){
				q.push(i);v[i]=1;
				xx++;
			}
		}
	}
	return xx==n;
}
int main(){
//	freopen("monkey.in","r",stdin);
//	freopen("monkey.out","w",stdout);
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&s[i]);
		l=min(s[i],l);
		r=max(s[i],r);
	}
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	l-=3,r+=3;
	while(l<r){		
		int mid=l+r>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		if(s[i]>=l)
			ans++;
	}
	printf("%d",ans);
	return 0;
}

```


---

## 作者：1saunoya (赞：2)

> # [更好的阅读体验](https://www.cnblogs.com/qf-breeze/p/10585519.html)

> # [$problem$](https://www.luogu.org/problemnew/show/P2504)

>首先呢注意数组大小 别栽在自己的数组手里

>求两点之间距离是

$sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))$

>根据这个 来跑$kruskal$
>不过特别注意的是 $kruskal$ 也是要用并查集的。。
>所以并查集的初始化 千万别省去（不然整个并查集的祖先都是0）

~~~
for(register int i=1;i<=n;i++) fa[i] = i ;
~~~

>完整代码


~~~
#ifdef Dubug

#endif
#include <bits/stdc++.h>
using namespace std;
typedef long long LL ;
inline LL In() {
    LL res(0),f(1);
    register char c ;
    while(isspace(c=getchar())) ;
    c == '-'? f = -1 , c = getchar() : 0 ;
    while(res = (res << 1) + (res << 3) + (c & 15) , isdigit(c=getchar())) ;
    return res * f ;
}
int n , m ;
struct node {
    int u,v;
    double w;
};
const int N = 1000005;
node edge[N] ;
int fa[N] ;
int a[N][3] , b[N] ;
bool cmp (node x,node y) {
    return x.w < y.w ;
}
int cnt (0) ;
inline void Add(int u,int v,double w) {
    cnt ++ ;
    edge[cnt] = node {u,v,w};
    return ;
}
inline int find(int x) {
    return fa[x] == x ? fa[x] : fa[x] = find(fa[x]) ;
}
inline void merge(int x,int y) {
    fa[x] = fa[y];
}
inline void kruskal() {
    double ans ;
    int v (0) ;
    sort(edge+1,edge+cnt+1,cmp) ;
    for(register int i=1; i<=cnt; i++) {
        int x = find(edge[i].u) , y = find(edge[i].v) ;
        if(x == y) continue ;
        merge(x,y) ;
        ans = edge[i].w ;
        if(++ v == n - 1) break ;
    }
    int count = 0 ;
    for(register int i=1; i<=m; i++) ans<=b[i]?count ++:0 ;
    cout << count << endl ;
    return ;
}
signed main() {
    
    m = In() ;
    for(register int i=1; i<=m; i++) b[i] = In() ;
    n = In() ;
    for(register int i=1; i<=n; i++) a[i][1] = In() , a[i][2] = In() ;
    for(register int i=1; i<=n; i++)
        for(register int j=1; j<=n ; j++)
            if(i!=j) Add(i,j,sqrt((a[i][1]-a[j][1])*(a[i][1]-a[j][1])+(a[i][2]-a[j][2])*(a[i][2]-a[j][2]))) ;
    for(register int i=1;i<=n;i++) fa[i] = i ;
    return kruskal() , 0 ;
}
~~~

---

## 作者：Hexarhy (赞：1)

## 看清题目本质是关键

思路：

【题目~~本质~~分析】既然要求猴子能跑遍全部树木的数量，显然是能**联通全部**树木的**边权越小**越好。

这种贪心思想自然会想到这道题目的本质问题：

> 求最小生成树中的最大边权。

分析出来了题目本质，那么做法也很好做了。$Prim$和$Kruskal$都可以，数据比较弱。


------------
坑爹的细节：

$(1)$在求两棵树的距离时，可以不`sqrt`，直接取平方，不影响结果。**但是要注意猴子的跳跃能力也变成了平方！**

$(2)$如果用$Kruskal$，存边目录的数组别开小了。具体开多大大约也就$10^6$。

$(3)$在存边的时候，由于数据小，我们可以每一棵树都与另一棵树两两相连边。不会爆内存。

$(4)$如果用$Kruskal$，在找最大边权的时候可以不用$\max$，因为边已经按从小到大排过序了。后面的一定是更大的边。当然你$\max$也没问题。

$(5)$统计答案时，大于小于等于别搞错了！

其它的小细节，就看个人细不细心了。本蒟蒻就只想到这么多坑点。



------------

送上码风清奇的代码：**本人使用$Kruskal$。**

~~注释简单别咬我……~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN=1005;
int n,m,cnt,cmp,ans;
struct node
{
	int from,to,v;
	bool operator<(const node& a)const
	{
		return v<a.v;
	}//相当于sort的cmp()
}edge[MAXN*MAXN];//开大点
struct point
{
	int x,y;
	int operator+(const point& a)const
	{
		return (x-a.x)*(x-a.x)+(y-a.y)*(y-a.y);
	}//算两点距离
}tree[MAXN];
int f[MAXN],monkey[MAXN];

int find(const int& x)
{
	return f[x]==x?x:f[x]=find(f[x]);
}

void build(void)//存边，建图
{
	for(int i=1;i<=n;i++)//别忘初始化
	 f[i]=i;
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=n;j++)
	  if(i!=j)//两两相连边，很简单
	   edge[++cnt]=node{i,j,tree[i]+tree[j]};
}

void input(void)
{
	cin>>m;
	for(int i=1;i<=m;i++)
	 cin>>monkey[i];
	cin>>n;
	for(int i=1;i<=n;i++)
	 cin>>tree[i].x>>tree[i].y;
}

void kruskal(void)//几乎是模板
{
	build();
	sort(edge+1,edge+1+cnt);
	int stop=0;
	for(int i=1;i<=cnt && stop<n;i++)
	{
		const int u=find(edge[i].from);
		const int v=find(edge[i].to);
		if(u==v)
		 continue;
		f[u]=v;
		cmp=edge[i].v;//可以不取max，理由上面提过
		stop++;
	}
}

void output(void)
{
	for(int i=1;i<=m;i++)
	 if(monkey[i]*monkey[i]>=cmp)//记住两点距离没有sqrt，猴子的跳跃距离也就平方了
	  ans++;
	cout<<ans<<endl;
}

int main()//华丽丽的主程序
{
	input();
	kruskal();
	output();
	return 0;
}

```


---

## 作者：aiyougege (赞：1)


#### Solution
　　在所有点对$(u,v)$之间连边, 边的权值为其**欧几里得距离**.求一棵**最小生成树**, 因为**两点之间边权最小的边**一定位于最小生成树上.求出最小生成树来后就知道了**树上边权的最大值**.如果猴子跳跃距离大于这个, 就说明能在树上自由活动.

　　一个小优化: 当两点之间距离大于$1000$时, 这条边是无用的. 但是这样做还需要注意最后能否形成一棵树.$\text{Test 2}$就是这样的.

#### Code
```c++
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#define M 1005
#define eps 1e-9
#define N 1000005
using namespace std;
int f[N];
int find(int u){
	return u==f[u]?u:find(f[u]);
}

struct Point{
	int x,y;
	void input(){
		scanf("%d%d",&x,&y);
	}
}p[N];

struct edge{
	int u,v;double c;
	bool operator<(const edge& s)const{
		return c<s.c;
	}
}e[N];int edge_num;

void Addedge(int a,int b){
	if(a==b)return ;
	Point i=p[a],j=p[b];
	double distan=sqrt((i.x-j.x)*(i.x-j.x)+(i.y-j.y)*(i.y-j.y));//两点之间距离
	if(distan>1000.0+eps)return ;//无用边
	e[++edge_num]=(edge){a,b,distan};//连边
}

int n,m;
int monkey[M];

int main(){
	scanf("%d",&m);
	for(int i=1;i<=m;++i)scanf("%d",&monkey[i]);
	sort(monkey+1,monkey+m+1);//给猴子排序
	scanf("%d",&n);
	for(int i=1;i<=n;++i)f[i]=i;
	for(int i=1;i<=n;++i)p[i].input();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			Addedge(i,j);//连接所有边
	double ans=0.0,tot=0;//ans为树上最大边权
	sort(e+1,e+edge_num+1);
	for(int i=1;i<=edge_num;++i){
		int f1=find(e[i].u),f2=find(e[i].v);
		if(f1!=f2)f[f2]=f1,++tot,ans=max(ans,e[i].c);
		if(tot==n-1)break;
	}
	if(tot<n-1){printf("0");return 0;}//不能形成一棵树
	for(int i=m;i;--i)
		if((double)monkey[i]<ans){
			printf("%d",m-i);//猴子不能自由活动
			return 0;
		}
	return 0;
}
```

---

## 作者：Victorique (赞：1)

这个题不要光看标签的krukal，其实这个题用prim跑要快很多（由于有1000个点的极端数据，krukal会出现1000000\*log1000000的时间效率，有点点大）。用prim跑其实也就是一个裸的prim模板，只要把最后的算和的循环改成找出最大的边权就可以了。详见代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm> 
using namespace std;
int x[1001],y[1001],sum,num,k,houzi[501],m,n,b[10101],tot;
double a[1001][1001],d[1501],maxx;
double js(int x1,int x2,int y1,int y2)
{
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
int main()
{
    cin>>m;
    for(int i=1;i<=m;i++)
    cin>>houzi[i];
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>x[i]>>y[i];
    }
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
     if(j!=i)
     a[i][j]=0x7fffffff;
     else
     a[i][j]=0;
    for(int i=1;i<=n-1;i++)
     for(int j=1;j<=n;j++)
     {
         a[i][j]=a[j][i]=js(x[i],x[j],y[i],y[j]);
     }
    memset(d,0x7f,sizeof(d));
    for(int i=1;i<=n;i++)
    d[i]=a[1][i];
    d[1]=0;
    b[1]=1;
    for(int i=1;i<=n-1;i++)
     {
         k=0;
         for(int j=1;j<=n;j++)
          if(!b[j]&&d[j]<d[k])
          k=j;
          b[k]=1;
          for(int j=1;j<=n;j++)
          if(!b[j]&&d[j]>a[k][j])
          d[j]=a[k][j];
     }
     for(int i=1;i<=n;i++)
     if(d[i]!=0)
     maxx=max(maxx,d[i]);
     for(int i=1;i<=m;i++)
     if(houzi[i]>=maxx)
     tot++;
     cout<<tot;
}
代码实在太水，就没有注释了。
```

---

## 作者：jbc392 (赞：0)

此题一看就知道是考最小生成树

用Kruskal ，Kruskal不多讲了 ，直接看代码

AC code：

```
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 1000010;

int n ,m;
double sum;//记录最小生成树中最大的边
int k ,ans ,road;//road代表已经建了几条边
int a[MAXN][3] ,monkey[MAXN] ,fa[MAXN];//a用来输入坐标 ，monkey存每只猴的跳跃能力

inline int read()//快读
{
    int x = 0 ,y = 1;
    char c = getchar();
    while(c > '9' || c < '0')
    {
        if(c == '-')y = -1;
        c = getchar();
    }
    while(c <= '9' && c >= '0')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * y;
}

struct node
{
    int x ,y;
    double p;
}tree[MAXN];

int cmp(node x ,node y)
{
    return x.p < y.p;
}

int find(int x)//并查集查找
{
    if(x == fa[x]) return x;
    else find(fa[x]);
}

void Union(int x ,int y)//并查集合并
{
    fa[find(x)] = find(y);
}

void Kruskal()
{
    sort(tree + 1 ,tree + 1 + k ,cmp);//排序
    for(int i = 1;i <= n;i++) fa[i] = i;//并查集初始化
    for(int i = 1;road < n - 1;i++)
    {
        if(find(tree[i].x) != find(tree[i].y))
        {
            Union(tree[i].x ,tree[i].y);//合并
            road++;//边数++
            sum = tree[i].p;//记录
        }
    }
}

int main()
{
    m = read();
    for(int i = 1;i <= m;i++) monkey[i] = read();

    n = read();
    for(int i = 1;i <= n;i++)
    {
       a[i][1] = read();
       a[i][2] = read();
    }

    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= n;j++)
        {
            if(i != j)//建图
            {
                tree[++k].x = i;
                tree[k].y = j;
                tree[k].p = sqrt((a[i][1] - a[j][1]) * (a[i][1] - a[j][1]) + (a[i][2] - a[j][2]) * (a[i][2] - a[j][2]));
            }
        }
    }   
    
    Kruskal();

    for(int i = 1;i <= m;i++) if(sum <= monkey[i]) ans++;//计数
    cout << ans;

    return 0;//好习惯
}
```


---

## 作者：Hiraeth (赞：0)

记录最小生成树的最大边 然后判断每只猴子的跳跃距离是否大于最大边的权值

如果满足条件即$ans++$

然后输出结果即可

~~看了一下自己两个月前的代码 dis的返回值搞错了……~~

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,h[505],f[1005],cnt,px,py,ans;
double flag;
struct p1{
	int x,y;
}a[1005];
struct p2{
	int x,y;
	double z;
}b[1000005];
bool cmp(p2 a,p2 b){
	return a.z<b.z;
}
int find(int x){
	if (x==f[x]) return x;
	return f[x]=find(f[x]);
}
double dis(int x1,int y1,int x2,int y2){
	return sqrt(double(x1-x2)*(x1-x2)+double(y1-y2)*(y1-y2));
}
int main(){
	scanf("%d",&m);
	for (int i=1;i<=m;i++) scanf("%d",&h[i]);
	scanf("%d",&n);
	for (int i=1;i<=n;i++) f[i]=i;
	for (int i=1;i<=n;i++) scanf("%d%d",&a[i].x,&a[i].y);
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++){
			cnt++;
			b[cnt].x=i;
			b[cnt].y=j;
			b[cnt].z=dis(a[i].x,a[i].y,a[j].x,a[j].y);
		}
	sort(b+1,b+cnt+1,cmp);
	for (int i=1;i<=cnt;i++){
		px=find(b[i].x);
		py=find(b[i].y);
		if (px==py) continue;
		f[px]=py;
		flag=b[i].z;
	}
	for (int i=1;i<=m;i++) 
		if (h[i]*1.0>=flag) ans++;
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：HDWR (赞：0)

本文已发布于[Handwer's Blog](https://blog.handwer-std.top/)

---

最小瓶颈生成树：图中边权最大值最小的生成树

---

把每个猴子看成点，构造完全图

找出最小瓶颈生成树

「一棵最小生成树就是一棵最小瓶颈生成树，**反之不一定**，所以直接跑一遍Kruskal就行」

记一下树上的最大边权

枚举所有猴子，判一下它能跳的长度是否大于树的最大边权即可

---

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cmath>

#define FILE_IN(__fname) freopen(__fname, "r", stdin)
#define FILE_OUT(__fname) freopen(__fname, "w", stdout)
#define IMPROVE_IO() std::ios::sync_with_stdio(false)

using std::cin;
using std::cout;
using std::endl;

const int MAXN = 1000                  + 10;
const int MAXM = 500                   + 10;
const int MAXE = (MAXN - 1) * MAXN / 2 + 10;

struct Node {
    int x, y;
    
    Node() { x = y = 0; }
} node[MAXN];

struct Edge {
    int previd, nextid;
    double weight;
    
    Edge() { previd = nextid = 0; weight = 0; }
    bool operator < (const Edge &that) const {
        return weight < that.weight;
    }
} edge[MAXE];

struct UnionFind {
    int seq[MAXN];
    
    UnionFind() { memset(seq, 0, sizeof seq); }
    int Find(int x) { return !seq[x] ? x : (seq[x] = Find(seq[x])); }
    bool Union(int x, int y) {
        x = Find(x); y = Find(y);
        if (x == y) return false;
        seq[x] = y;
        return true;
    }
} U;

double GetDist(int idx, int idy) {
    // 真·初中数学，利用勾股定理计算坐标系中两点的直线距离
    double ret = 0;
    int absx = std::abs(node[idx].x - node[idy].x);
    int absy = std::abs(node[idx].y - node[idy].y);
    ret = sqrt(absx * absx + absy * absy);
    return ret;
}

int n, m, cnt;
int monkey[MAXM];

double Kruskal() {
    std::sort(edge + 1, edge + 1 + cnt);
    int tot = 0;
    double maxWeight = 0;
    for (int i = 1; i <= cnt; ++i) {
        // 一个比较新颖的最小生成树写法
        // 直接利用并查集的合并来判断
        if (U.Union(edge[i].previd, edge[i].nextid)) {
            ++tot;
            maxWeight = std::max(maxWeight, edge[i].weight);
            // 找一下最大边权
            // 貌似是可以直接更新，因为边权是经过排序的
            // 但是这么写比较保险（雾
        }
        if (tot == n - 1) break;
    }
    return maxWeight;
}

int main() {
    IMPROVE_IO();
    cin >> m;
    for (int i = 1; i <= m; ++i) cin >> monkey[i];
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> node[i].x >> node[i].y;
    // 初始化一张完全图出来
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j < i; ++j) {
            edge[++cnt].previd = i;
            edge[cnt].nextid = j;
            edge[cnt].weight = GetDist(i, j);
        }
    }
    double maxW = Kruskal();
    int ans = 0;
    for (int i = 1; i <= m; ++i) {
        if (monkey[i] >= maxW) ++ans;
    }
    cout << ans << endl;
    return 0;
}


```

---

## 作者：kkkk0369 (赞：0)

题意：给出平面坐标系上的$n$个点，问能用最大距离$a[i]$遍历所有点的$a[i]$数量。

思路：$kruskal$算法，把所有边都连起来再跑最小生成树。

然后一发样例：挂了

？？？

发现自己蠢到不会用floor函数，导致精度出错。

第二次加了一些奇怪的判断：

```cpp
int cal(int ii,int jj)
{
    int d1=floor(sqrt((x[ii]-x[jj])*(x[ii]-x[jj])+(y[ii]-y[jj])*(y[ii]-y[jj]))*10);
    int d2=floor(sqrt((x[ii]-x[jj])*(x[ii]-x[jj])+(y[ii]-y[jj])*(y[ii]-y[jj])));
    if (d2*10==d1) return d2;
    else return d2+1;
}
```

过了样例，交一发：20分

然后老老实实改成double……

再交一发：20分

？？？

发现自己的e（存边）数组才开了2000……

改成2000010后再交一发:50分

自己又手贱了，猴子的最大距离$a[i]$也要改成double

再交一发，过了。

以下代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
struct Edge
{
	int u,v;
	double val;
}e[2000010];
int m,n,cnt,ans,num;
double maxans;
double a[510];
int x[1010],y[1010],fa[1010];
int find(int x)
{
	if (fa[x]!=x) fa[x]=find(fa[x]);
	return fa[x];
}
void unnion(int x,int y)
{
	x=find(x);y=find(y);
	if (x!=y) fa[x]=y;
}
bool judge(int x,int y)
{
	x=find(x);y=find(y);
	if (x==y) return 1;
	else return 0;
}
void add(int u,int v,double w)
{
	e[++cnt].u=u;e[cnt].v=v;e[cnt].val=w;
}
void kruskal()
{
	int u,v;
	for(int i=1;i<=cnt;i++)
	{
		u=e[i].u;v=e[i].v;
		if (!judge(u,v)) maxans=e[i].val,num++,unnion(u,v);
		if (num>n-1) break;
	}
}
bool cmp(Edge a,Edge b)
{
	return a.val<b.val;
}
int main()
{
	scanf("%d",&m);
	for(int i=1;i<=m;i++) scanf("%lf",&a[i]);
	scanf("%d",&n);for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	if (i!=j) add(i,j,sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));
	sort(e,e+cnt+1,cmp);kruskal();
	for(int i=1;i<=n;i++) if (a[i]>=maxans) ans++;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Jith_2004 (赞：0)

[P2504](https://www.luogu.org/problemnew/show/P2504)

说实话，这个省选题真的好弱啊,但我还是菜，交了5次才A...

刚看到题面，就觉得像贪心，果然正解是最小生成树~~（贪心嘛，当我没说）~~。显然一只猴子若能在所有树冠上觅食，其跳跃距离必须大于等于以所有树冠为节点的最小生成树的最长的边（最小生成树保证了所有节点都在树中，即所有点必定是联通的）。想通了这一点，其他都好办！

最后我再多说一句：最好不要用sqrt，毕竟精度有限，（有些变态题会卡精度）而且平方的话最多8000000，连int都不超。

最后用了lower_bound，懒得跑循环了（不过最后用循环找答案快一点），整体复杂度是 _O(n^2)_ ~~(具体的大概是 _O(n^2+2mlog2 m+nlog2 n+m-n)_ )~~

代码如下：

```cpp
#include <bits/stdc++.h>
#define dis(x1,x2,y1,y2) (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)
using namespace std;
const int MAXN=1000,MAXM=500;
int n,m,l[MAXM+2],x[MAXN+2],y[MAXN+2],tot;
int par[MAXN+2],rank[MAXN+2];

struct edge { int u,v,w; };
edge es[MAXN*MAXN+2];

inline int read(){
	int num=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)) f=ch=='-'?-1:1,ch=getchar();
	while(isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
	return num*f;
}

int find(int x){
	if(par[x]==x) return x;
	else return par[x]=find(par[x]);
}

void unite(int x,int y){
	x=find(x),y=find(y);
	if(rank[x]<rank[y]) par[x]=y;
	else par[y]=x,rank[x]+=rank[x]==rank[y]?1:0;
}

int same(int x,int y) { return find(x)==find(y); }

bool cmp(edge a,edge b) { return a.w<b.w; }

int kruscal(){
	int res=0;
	sort(es,es+tot,cmp);
	for(int i=0;i<tot;++i){
		edge e=es[i];
		if(same(e.u,e.v)) continue;
		res=e.w;
		unite(e.u,e.v);
	}
	return res;
}

int main(){
	m=read();
	for(int i=0;i<m;++i) l[i]=read(),l[i]*=l[i];
	sort(l,l+m);
	n=read();
	for(int i=0;i<n;++i){
		par[i]=i,rank[i]=0;
		x[i]=read(),y[i]=read();
		for(int j=0;j<i;++j)
			es[tot++]=edge{i,j,dis(x[i],x[j],y[i],y[j])};
	}
	int now1=kruscal(),now2=lower_bound(l,l+m,now1)-l;
	cout<<m-now2<<endl;
	return 0;
}
```

---

## 作者：Nero_Claudius (赞：0)

这道题要坑死人啊。。。

第一次做40分，其他RE，改了一次之后就变成20分了。。。

究其原因，是有一个数组（dis）开的太小了，于是最后本蒟蒻就随手开了个五百万，**然后，就AC了**。

看到有一篇题解说求距离最好不开根，经本蒟蒻实验，开不开根并不影响结果，全看个人喜好。

本蒟蒻还加了一个快读，其实也没有必要，只是第一次RE的时候不小心看成了TLE，为了缩短时间才写的。

总体来说，这是一道Kruskal的题~~（废话）~~。

需要注意的一个点在于题目所求的与裸题有差异。

其余的好像问题也不大，只要不像本蒟蒻一样视力不好就不会错得太离谱。

总而言之，AC代码如下（并查集find函数带优化）：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

inline int qread() {
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9') {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9') {
		x = x * 10 + (c - '0');
		c = getchar();
	}
	return x * f;
}

const int maxn = 1010;

int m, n, ans = 0, cnt = 0;
int f[maxn], leap[maxn], x[maxn], y[maxn];

struct node {
    int x, y;
    int val;
}dis[5000005];

bool cmp(node a, node b) {
    return a.val < b.val;
}

int find(int x) {
    int r = x;
    while(r != f[r]) r = f[r];
    int i = x, j;
    while(f[i] != r) {  
        j = f[i];  
        f[i] = r;  
        i = j;  
    }
    return r;  
}

void merge(int x, int y) {
	x = find(x);
	y = find(y);
	if(x != y) f[y] = x;
}

double dt(int x1,int x2,int y1,int y2) {
    return sqrt(pow(double(x1 - x2), 2) + pow(double(y1 - y2), 2));
}

int main() {
    cin >> m;
    for(int i = 1; i <= m; i++) cin >> leap[i];
	cin >> n;
    for(int i = 1; i <= n; i++) cin >> x[i] >> y[i];
    for(int i = 1; i <= maxn - 1; i++) f[i] = i;
    
    for(int i = 1; i <= n; i++) 
		for(int j = i + 1; j <= n; j++) {
			dis[++cnt].x = i;
			dis[cnt].y = j;
			dis[cnt].val = dt(x[i], x[j], y[i], y[j]);
		}
			
			
    sort(dis + 1, dis + cnt + 1, cmp);
    for(int i = 1; i <= cnt; i++)
		if(find(dis[i].x) != find(dis[i].y)) {
			ans = dis[i].val;
			merge(dis[i].x, dis[i].y);
		}
		
	int sum = 0;
    for(int i = 1; i <= m; i++) if(leap[i] >= ans) sum++;
    
    cout << sum;
}
```

---

## 作者：Samsam (赞：0)

这是一个裸的最小生成树

相当于求大于最小生成树上最长边的h[i]个数

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>
#define N 620505
using namespace std;
int a[N];
int x[N];
int y[N];
int h[N];
int d[N];
int x2[N];
int y2[N];
int find(int x)
{
    if (x==a[x]){
        return x;
    }
    else {
        a[x]=find(a[x]);
        x=a[x];
    }
} 
void make(int x,int y)
{
    a[find(x)]=find(y);
}
/*int jisuan(int x,int y,int x1,int y1)
{
    int x2=abs(x-x1);
    int y2=abs(y-y1);
    int k=floor(sqrt(x2*x2+y2*y2));
    if (k*k==x2*x2+y2*y2){
        return k;
    }
    else {
        return k+1;
    }
    //return floor(sqrt(x2*x2+y2*y2));
}*/
void qsort(int l,int r)
{
    int i=l;
    int j=r;
    int mid=d[(l+r)/2];
    while (i<=j){
        while (d[i]<mid) i++;
        while (d[j]>mid) j--;
        if (i<=j){
            int p;
            p=x[i]; x[i]=x[j]; x[j]=p;
            p=y[i]; y[i]=y[j]; y[j]=p;
            p=d[i]; d[i]=d[j]; d[j]=p;
            i++;
            j--;
        }
    }
    if (l<j) qsort(l,j);
    if (i<r) qsort(i,r);
}
int main()
{
    int n;
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&h[i]);
    }
    int m;
    scanf("%d",&m);
    for (int i=1;i<=m;i++){
        a[i]=i;
        scanf("%d%d",&x2[i],&y2[i]);
    }
    int ckr=0;
    for (int i=1;i<=m;i++){
        for (int j=i+1;j<=m;j++){
                ckr++;
                x[ckr]=i;
                y[ckr]=j;
                d[ckr]=(x2[i]-x2[j])*(x2[i]-x2[j])+(y2[i]-y2[j])*(y2[i]-y2[j]);
        }
    }
    qsort(1,ckr);
    int max1=0;
    int k=0;
    for (int i=1;i<=ckr;i++){
        if (find(x[i])!=find(y[i])){
            k++;
            a[find(x[i])]=a[find(y[i])];
            //make(x[i],y[i]);
            max1=max(max1,d[i]);
        }
        if (k==m-1) break; 
    }
    int tot=0;
    for (int i=1;i<=n;i++){
        if (h[i]*h[i]>=max1) tot++;
    }
    printf("%d",tot);
    return 0;
}
```

---


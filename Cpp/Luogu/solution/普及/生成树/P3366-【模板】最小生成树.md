# 【模板】最小生成树

## 题目描述

如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。


## 说明/提示

数据规模：

对于 $20\%$ 的数据，$N\le 5$，$M\le 20$。

对于 $40\%$ 的数据，$N\le 50$，$M\le 2500$。

对于 $70\%$ 的数据，$N\le 500$，$M\le 10^4$。

对于 $100\%$ 的数据：$1\le N\le 5000$，$1\le M\le 2\times 10^5$，$1\le Z_i \le 10^4$。


样例解释：

 ![](https://cdn.luogu.com.cn/upload/pic/2259.png) 

所以最小生成树的总边权为 $2+2+3=7$。


## 样例 #1

### 输入

```
4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3```

### 输出

```
7```

# 题解

## 作者：Nemlit (赞：966)

# 这里介绍最小生成树的两种方法：Prim和Kruskal。

[原文地址](https://www.cnblogs.com/bcoier/p/10293059.html)
## 各种Bug于2018-9-27日修复
### 两者区别：Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。
### 两者其实都是运用贪心的思路
# 洛谷数据：
![](https://cdn.luogu.com.cn/upload/pic/34515.png)
## Prim：
个人觉得Prim和最短路中的dijkstra很像，由于速度问题，所以这里我用链式前向星存图。Prim的思想是将任意节点作为根，再找出与之相邻的所有边（用一遍循环即可），再将新节点更新并以此节点作为根继续搜，维护一个数组：dis，作用为已用点到未用点的最短距离。

证明：Prim算法之所以是正确的，主要基于一个判断：对于任意一个顶点v，连接到该顶点的所有边中的一条最短边(v, vj)必然属于最小生成树（即任意一个属于最小生成树的连通子图，从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树）
### 具体算法流程图解如下：
```
```
![luogu](https://cdn.luogu.com.cn/upload/pic/28090.png)
注意：inline和register为一点点常数优化，不要的话也可以过，不理解的同学删掉即可
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define il inline
il int read()
{
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}//快读，不理解的同学用cin代替即可
#define inf 123456789
#define maxn 5005
#define maxm 200005
struct edge
{
	int v,w,next;
}e[maxm<<1];
//注意是无向图，开两倍数组
int head[maxn],dis[maxn],cnt,n,m,tot,now=1,ans;
//已经加入最小生成树的的点到没有加入的点的最短距离，比如说1和2号节点已经加入了最小生成树，那么dis[3]就等于min(1->3,2->3)
bool vis[maxn];
//链式前向星加边
il void add(int u,int v,int w)
{
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}
//读入数据
il void init()
{
    n=read(),m=read();
    for(re int i=1,u,v,w;i<=m;++i)
    {
        u=read(),v=read(),w=read();
        add(u,v,w),add(v,u,w);
    }
}
il int prim()
{
	//先把dis数组附为极大值
	for(re int i=2;i<=n;++i)
	{
		dis[i]=inf;
	}
    //这里要注意重边，所以要用到min
	for(re int i=head[1];i;i=e[i].next)
	{
		dis[e[i].v]=min(dis[e[i].v],e[i].w);
	}
    while(++tot<n)//最小生成树边数等于点数-1
    {
        re int minn=inf;//把minn置为极大值
        vis[now]=1;//标记点已经走过
        //枚举每一个没有使用的点
        //找出最小值作为新边
        //注意这里不是枚举now点的所有连边，而是1~n
        for(re int i=1;i<=n;++i)
        {
            if(!vis[i]&&minn>dis[i])
            {
                minn=dis[i];
				now=i;
            }
        }
        ans+=minn;
        //枚举now的所有连边，更新dis数组
        for(re int i=head[now];i;i=e[i].next)
        {
        	re int v=e[i].v;
        	if(dis[v]>e[i].w&&!vis[v])
        	{
        		dis[v]=e[i].w;
        	}
		}
    }
    return ans;
}
int main()
{
    init();
    printf("%d",prim());
    return 0;
}
```
## Kruskal：
Kruskal算法的思想比Prin好理解一些。先把边按照权值进行排序，用贪心的思想优先选取权值较小的边，并依次连接，若出现环则跳过此边（用并查集来判断是否存在环）继续搜，直到已经使用的边的数量比总点数少一即可。

证明：刚刚有提到：如果某个连通图属于最小生成树，那么所有从外部连接到该连通图的边中的一条最短的边必然属于最小生成树。所以不难发现，当最小生成树被拆分成彼此独立的若干个连通分量的时候，所有能够连接任意两个连通分量的边中的一条最短边必然属于最小生成树
### 具体算法流程图解如下：
```
```
![luogu](https://cdn.luogu.com.cn/upload/pic/28091.png)
# [并查集详解](https://tbr-blog.blog.luogu.org/solution-p3367)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define il inline
il int read()
{
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
struct Edge
{
	int u,v,w;
}edge[200005];
int fa[5005],n,m,ans,eu,ev,cnt;
il bool cmp(Edge a,Edge b)
{
    return a.w<b.w;
}
//快排的依据（按边权排序）
il int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    return x;
}
//并查集循环实现模板，及路径压缩，不懂并查集的同学可以戳一戳代码上方的“并查集详解”
il void kruskal()
{
    sort(edge,edge+m,cmp);
    //将边的权值排序
    for(re int i=0;i<m;i++)
    {
        eu=find(edge[i].u), ev=find(edge[i].v);
        if(eu==ev)
        {
            continue;
        }
        //若出现两个点已经联通了，则说明这一条边不需要了
        ans+=edge[i].w;
        //将此边权计入答案
        fa[ev]=eu;
        //将eu、ev合并
        if(++cnt==n-1)
        {
            break;
        }
        //循环结束条件，及边数为点数减一时
    }
}
int main()
{
    n=read(),m=read();
    for(re int i=1;i<=n;i++)
    {
        fa[i]=i;
    }
    //初始化并查集
    for(re int i=0;i<m;i++)
    {
        edge[i].u=read(),edge[i].v=read(),edge[i].w=read();
    }
    kruskal();
    printf("%d",ans);
    return 0;
}
```
#### PS：由于个人码风习惯，代码可能看上去较长，但其实自己写起来还是比较短的。

---

## 作者：封禁用户 (赞：517)

#Prim+邻接链表

看了一下其他人的，发现好像都没有我的堆优化过后的Prim要快，堆优化之后的Prim总共只要180ms，而且我要介绍一下我的毒瘤的Prim写法，看了一下网上的各种堆优化版本的Prim，都是直接存的边，代码冗长而难以理解，而既然Prim和Dijkstra的贪心思想是一样的并且也可以用类似的方法实现，那既然这样就可以用邻接链表存边并且像写Dijkstra一样写代码呀！我们可以分析一下直接存边和用邻接链表各自的优势：直接存边消耗的空间小因为存每条边的数据少而且不用因为是无向图而存两遍，但是直接存边由于不知道与该边相连的边是哪些，就需要O(N)的枚举或者用比邻接链表更多的空间来与预存下与每个点相连的边有那些。说真的，要用存边的方法写一个堆优化的Prim的代码真的其丑无比，所以这里我还是给大家推荐我的时间复杂度稳定在O(NlogN)的邻接链表版本堆优化Prim(讲了这么多结果还是在说代码的美观性……）


清爽的代码（不觉得清爽的可以看这些代码 [百度搜索:prim堆优化](https://www.baidu.com/s?ie=utf-8&f=3&rsv\_bp=1&rsv\_idx=1&tn=baidu&wd=prim%E5%A0%86%E4%BC%98%E5%8C%96&oq=prim%25E5%25A0%2586%25E4%25BC%2598%25E5%258C%2596%25E6%2597%25B6%25E9%2597%25B4%25E5%25A4%258D%25E6%259D%2582%25E5%25BA%25A6&rsv\_pq=8b20b8e70000c10f&rsv\_t=9c56PDP2aFCdoEf4Rga7fg0NNIRggz%2Fb3lNC1OWap5M0INl4O%2BuJ4BCfkko&rqlang=cn&rsv\_enter=0&inputT=1502&rsv\_sug3=54&rsv\_sug1=28&rsv\_sug7=000&prefixsug=prim%25E5%25A0%2586%25E4%25BC%2598%25E5%258C%2596&rsp=0&rsv\_sug4=2244&rsv\_sug=1)）：

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define R register int
using namespace std;

int k,n,m,cnt,sum,ai,bi,ci,head[5005],dis[5005],vis[5005];

struct Edge
{
    int v,w,next;
}e[400005];

void add(int u,int v,int w)
{
    e[++k].v=v;
    e[k].w=w;
    e[k].next=head[u];
    head[u]=k;
}

typedef pair <int,int> pii;
priority_queue <pii,vector<pii>,greater<pii> > q;

void prim()
{
    dis[1]=0;
    q.push(make_pair(0,1));
    while(!q.empty()&&cnt<n)
    {
        int d=q.top().first,u=q.top().second;
        q.pop();
        if(vis[u]) continue;
        cnt++;
        sum+=d;
        vis[u]=1;
        for(R i=head[u];i!=-1;i=e[i].next)
            if(e[i].w<dis[e[i].v])
                dis[e[i].v]=e[i].w,q.push(make_pair(dis[e[i].v],e[i].v));
    }
}

int main()
{
    memset(dis,127,sizeof(dis));
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for(R i=1;i<=m;i++)
    {
        scanf("%d%d%d",&ai,&bi,&ci);
        add(ai,bi,ci);
        add(bi,ai,ci);
    }
    prim();
    if (cnt==n)printf("%d",sum);
    else printf("orz");
}
```

---

## 作者：Tweetuzki (赞：340)

貌似还没见到 Borůvka (Sollin) 算法求最小生成树？

这个算法的教程在网上极少…… 翻了好多的博客都没理解，最终找到了维基百科的 [Borůvka's algorithm](https://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm) 词条，终于弄懂了这个十分古老的算法。

Borůvka 其实是一种多路增广的 prim。Prim 算法由一个点开始，往外不断贪心地找最短边，然后不断扩大连通块，直到形成一棵树。而 Borůvka 算法每一次的增广，会对现在的每一个连通块都找一遍的最短边，最后每个连通块择优，将这些边全部连上。

算法的执行流程大约是这样的：

- 对于现在的每个连通块，找到从这个连通块出发，不在最小生成树中的、到达别的连通块的最短边。（特别注意：若权值相同，则需要再按照另一个维度严格排序，常用标号大小排序。即边权相同时，认为编号小的边短。这样处理是为了避免两个连通块互相连的时候出现环）
- 全部找完后，将这些边加入最小生成树中。（可能出现两个连通块互连的情况，那么这时在第一个连通块连完这条边后，标记一下，说明该边已被加入最小生成树，下一次弹掉即可）

利用维基百科的样例可以形象地说明如上步骤：

![](https://i.loli.net/2018/11/05/5be0585a128cb.png)

这样，每一次合并的 $O(M)$ 的，但是每一次合并后，连通块的个数都减少一半。这样一来，只要 $\log N$ 次，就能合并成最小生成树了。所以总时间复杂度是 $O(M \log N)$ 的。Borůvka 的优势也正在此，它只需要 $\log N$ 次的合并，这是另外两个 MST 算法所难以达到的。因此，一旦有[题目](https://codeforces.com/problemset/problem/888/G)想考察 Borůvka 算法，一定跟这个特性密切相关。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int MaxN = 5000 + 5, MaxM = 200000 + 5;

int N, M;
int U[MaxM], V[MaxM], W[MaxM];
bool used[MaxM];
int par[MaxN], Best[MaxN];

void init() {
    scanf("%d %d", &N, &M);
    for (int i = 1; i <= M; ++i)
        scanf("%d %d %d", &U[i], &V[i], &W[i]);
}

void init_dsu() {
    for (int i = 1; i <= N; ++i)
        par[i] = i;
}

int get_par(int x) {
    if (x == par[x]) return x;
    else return par[x] = get_par(par[x]);
}

inline bool Better(int x, int y) {
    if (y == 0) return true;
    if (W[x] != W[y]) return W[x] < W[y];
    return x < y;
}

void Boruvka() {
    init_dsu();

    int merged = 0, sum = 0;

    bool update = true;
    while (update) {
        update = false;
        memset(Best, 0, sizeof Best);

        for (int i = 1; i <= M; ++i) {
            if (used[i] == true) continue;
            int p = get_par(U[i]), q = get_par(V[i]);
            if (p == q) continue;

            if (Better(i, Best[p]) == true) Best[p] = i;
            if (Better(i, Best[q]) == true) Best[q] = i;
        }

        for (int i = 1; i <= N; ++i)
            if (Best[i] != 0 && used[Best[i]] == false) {
                update = true;
                merged++; sum += W[Best[i]];
                used[Best[i]] = true;
                par[get_par(U[Best[i]])] = get_par(V[Best[i]]);
            }
    }

    if (merged == N - 1) printf("%d\n", sum);
    else puts("orz");
}

int main() {
    init();
    Boruvka();
    return 0;
}
```

---

## 作者：Soulist (赞：224)

用$LCT$求最小生成树是一个非常实用的思想，（个人感觉），动态连边，枚举，用$Splay$维护某种最值，每次连一条边，若其构成环，则环上断边，不难发现，这样操作后仍然为一棵树。

那么先简单的介绍一下$LCT$

它可以动态的维护一棵树，支持加边，删边，还可以维护每一条链上的许多信息
，同时，它的链也是动态的（您想维护那一条链就可以维护那一条链）

（比如维护一条链上的最大值）


回到题面，如果用$LCT$，我们可以想到一种比较直观的想法：

对于每条边，如果其连接了两个联通块，就连边，否则，其相当于在树上的一条返祖边，那么会构成环，我实际上只需要找到环上边权最大的边然后断边即可

**具体实现呢？**

首先记录当前答案：$ans$

对于每一条边，如果这条边它连接了两个现在并不联通的联通块，那么我就直接连边，但是因为实际上如果要用$LCT$上的树点来维护，其父亲到其的边会比较麻烦处理

（动态树它动来动去...，还经常换根，所以不好想树剖那样把边权映射到点上）

所以比较暴力的想法就是，**把当前的边当作一个点，那么其编号为$n+id$**

**然后这个点的点权为其边权** ，这个时候连边。假设其沟通了$x,y$，即：

```cpp
w[id + n] = z; //w表示这个点的点权
link( x, id + n ), link( id + n, y );
```

否则，这条边是树上的一条返祖边，如果连接，那么$x-y$会形成环，这个时候需要断掉最大的边。

于是，我们需要用$LCT$维护链上最大边权（按照之前讲的把边当作点，要消去点对链造成的影响，我们需要将树点的点权设为$0$）

然后先把$x-y$的链$split$出来

然后记录一个$id$表示点权最大的点的编号。

这个时候，我们判断，如果当前要加入的边比现在最大的边权（边权就是点权，前文**加粗**部分写到了）还要大，那么显然不能加入这条边

否则，我们就先把最大边所代表的点$Splay$上去，然后让其两个儿子都不认它，这样我们就完成了断边。

然后再$link( x, Id+n), \quad link(Id+n,y)$

上代码咯：$QAQ$

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 2e5 + 5005;
#define ls(x) t[x].son[0]
#define rs(x) t[x].son[1]
struct LCT {
	int son[2], mx, id, fa;
	bool mark;
}t[N]; 
int w[N], n, m, Idnet, ans;
void pushup( int x ) { //每次下传都需要更新最大点权，
	t[x].id = x, t[x].mx = w[x];
	if( t[ls(x)].mx > t[x].mx ) t[x].mx = t[ls(x)].mx, t[x].id = t[ls(x)].id;
	if( t[rs(x)].mx > t[x].mx ) t[x].mx = t[rs(x)].mx, t[x].id = t[rs(x)].id;
}
bool isroot( int x ) {
	return ( rs(t[x].fa) != x ) && ( ls(t[x].fa) != x );
}
void pushmark( int x ) { //下传翻转标记
	if( t[x].mark ) {
		t[x].mark = 0, t[ls(x)].mark ^= 1, t[rs(x)].mark ^= 1;
		swap( ls(x), rs(x) );
	}
}
void rotate( int x ) { //旋转
	int f = t[x].fa, ff = t[f].fa, qwq = ( rs(f) == x );
	t[x].fa = ff;
	if( !isroot(f) ) t[ff].son[(rs(ff) == f)] = x; //如果父亲不为根才改爷爷 
	t[t[x].son[qwq ^ 1]].fa = f, t[f].son[qwq] = t[x].son[qwq ^ 1],
	t[f].fa = x, t[x].son[qwq ^ 1] = f;
	pushup(f), pushup(x);
} 
int st[N];
void Splay( int x ) {
	int top = 0, now = x; st[++top] = now;
	while( !isroot(now) ) st[++top] = ( now = t[now].fa );
	while( top ) pushmark( st[top--] );
	while( !isroot(x) ) {
		int f = t[x].fa, ff = t[f].fa;
		if( !isroot(f) ) ( ( rs(ff) == f ) ^ ( rs(f) == x ) ) ? rotate(x) : rotate(f);
		rotate(x);
	}
}
void access( int x ) {
	for( int y = 0; x; y = x, x = t[y].fa )
		Splay( x ), t[x].son[1] = y, pushup( x );
}
void makeroot( int x ) {
	access( x ), Splay( x ), t[x].mark ^= 1, pushmark( x );
}
int findroot( int x ) {
	access( x ), Splay( x ), pushmark( x );
	while( ls(x) ) pushmark( x = ls(x) );
	return x;
}
void split( int x, int y ) {
	makeroot(x), access(y), Splay(y);
}
bool check( int x, int y ) { //判断两个点是否联通
	makeroot( x );
	return findroot( y ) != x; 
}
void link( int x, int y ) {//link的前提是这两个点联通，所以没有判断
	makeroot( x );
	t[x].fa = y;
}
signed main()
{
	n = read(), m = read();
	Idnet = n; //Idnet表示当前边
	
	int x, y, z, now; 
	
	for( register int i = 1; i <= m; ++ i ) {
		x = read(), y = read(), z = read();
		
		++Idnet, w[Idnet] = z; //表示编号为Idnet的边（也是LCT中的树点）的点权变成z
		
		if( check( x, y ) )  
			link( x, Idnet ), link( Idnet, y ), ans += z; //如果两个不在同一个联通快里面，直接连边，并更新答案
		else 
        {
			split( x, y ), //把x-y的路径先拉出来
            now = t[y].id;
			if( t[now].mx <= z ) continue; 
			ans += ( z - t[now].mx ), Splay( t[y].id ); //先把这个点旋上去
			t[ls(now)].fa = t[rs(now)].fa = 0; //子不认父，就是断边 
			link( x, Idnet ), link( Idnet, y );//再连边	
		} 
	}
	printf("%d\n", ans);
	return 0;
}
```

[$LCT$还可以做$LCA$欸？](https://www.luogu.org/blog/Soulist/solution-p3379)

---

## 作者：哥66666 (赞：145)

## 最小生成树有两个算法：$kruskal$与$Prim$
### 这两种算法是最小生成树的算法中最常用的算法~~（因为我不知道别的算法……）~~

#### $kruskal$主要思路：
1.	输入边，用结构体储存
2.	用结构体快排以边比较从小到大快排
3.	建一个并查集，并初始化并查集（并查集代表两个点有没有在同一个树里面）
#### 接下来是重点

设边edge[100000],edge.start一个点，edge.to另一个点，edge.val是边长，ans是最终答案。
1.	for(i=1;i<=m（边数）;i++)找一条边edge[i],若edge[i].start与edge[i].to不在同一个并查集里面，就将edge[i].start与edge[i].to所在的并查集合并，并将ans+=edge[i].val。
2.	若在同一个并查集，则跳过这次循环。因为如果这两个点连接起来，就会形成一个环。

![](https://cdn.luogu.com.cn/upload/pic/25212.png)

{若1与3连起来，就会造成一个环。}
- 最后一步：printf("%d",ans);

解释：
1.	快排边长，是为了让每次选的都是所有连接中都能是边长最小的（贪心思想）
2.	并查集的作用是：判断有没有连成一个环。若两个点在同一个并查集里面，则说明它们在同一个树里，若连接，就会造成一个环
3.	当到了已连边的个数是点的个数-1时，就要停止循环，因为这个时候，最小生成树已经完成了，所有的并查集都连在了一起。

														下面是点为5时的情况
![](https://cdn.luogu.com.cn/upload/pic/25320.png)

以下是本人~~(蒟蒻)~~的代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
int n,m,i,j,u,v,total;
struct edge{
    int start,to;long long val;
}bian[2000005];
int f[100000];
long long ans;

int find(int x)//并查集部分
{
    if (f[x]==x) return x; else 
    {
        f[x]=find(f[x]);
        return f[x];
    }	
}

bool cmp(edge a,edge b)//结构体快排时用到的
{
    return a.val<b.val;
}

inline void kruskal()//最小生成树
{
    
    for(int i=1;i<=m;i++)
    {
        u=find(bian[i].start);
        v=find(bian[i].to);
        if(u==v) continue;//判断在不在同一个并查集里面，在就下一个循环
            ans+=bian[i].val;//不在，就加上
            f[u]=v;//连接两个并查集
            total++;
            if(total==n-1) break;//当形成了最小生成树后，退出（之后做的也没用了）
    }
} 
int main()
{
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++) f[i]=i;
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&bian[i].start,&bian[i].to,&bian[i].val);
    }
    sort(bian+1,bian+m+1,cmp);//快排边长
    kruskal();
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Clover_INF (赞：59)

# 最小生成树
这里介绍解决最小生成树最常见的两种算法Prim和Kruskal算法，但在这之前先介绍如何判断图是否联通。

## 判断图是否联通
判断图是否连通，可用dfs和bfs遍历图算法，注意点数目较多，又是稀疏图的话，最后使用邻接表的方法存储。另外推荐采用的是并查集的方法。初始化时将每个节点看作一个集合，则每给出一条边即把两个集合合并。最后遍历所有点，有几个集合便有几个连通分量，若只有一个集合说明图连通。并查集方法通常情况下时间效率较高，还能判断一个图是否有回路，在kruskal算法中也可以使用。另外如果你是用堆优化的Prim算法的话你可以判断堆为空时节点是否全部拓展，我会在之后详细的讲解。

下面附上代码

(1)DFS
```cpp
int count = 0;
void DFS(int i)
{
    int j = 0;
    visited[i] = 1;
    count++;
    for(j=0; j<G.numVertexes; j++)
    {
        if(G.arc[i][j]==1 && !visited[j])//i和j有关系相邻，并且j顶点没有被访问过
        {
            DFS(G, j);
        }
    }
}
```
从某一点出发开始DFS，到最后，只需要判断最后count的值是否是全部的节点就可以，如果小于总节点数，则证明是不连通的，如果相等，则证明是连通的。

(2)BFS
```cpp
void bfs(int s){            //用队列广搜
    queue<int> q;
    q.push(s);
    while(!q.empty()){
        int x=q.front();
        q.pop();
        vis[x]=true;
        for(int i=0;i<g[x].size();++i){
            if(vis[g[x][i]]) g[x].erase(g[x].begin()+i);//删除图中已经遍历过的点，可提高遍历速度
            else q.push(g[x][i]);
        }
    }
}

bool judge(){                   //判断是否所有点已被遍历过
    for(int i=1;i<=n;++i)
        if(!vis[i])
            return false;
    return true;
}
```
同样如果从某一个节点广度搜完，有未访问到的节点，那么该图一定是不连通的。

(3)并查集
```cpp
int set[1000005];

int find(int x){

   return x==set[x]?x:(set[x]=find(set[x]));   //递归查找集合的代表元素，含路径压缩。

}
int main()

{

   int n,m,i,x,y;

   scanf("%d%d",&n,&m);

   for(i=1;i<1000005;++i)        //初始化个集合，数组值等于小标的点为根节点。

       set[i]=i;

   for(i=0;i<m;++i){

       int a,b;

       scanf("%d%d",&a,&b);

       int fx=find(a),fy=find(b);

       set[fx]=fy;                      //合并有边相连的各个连通分量

   }

   int cnt=0;

   for(i=1;i<=n;++i)          //统计集合个数，即为连通分量个数，为一时，图联通。

       if(set[i]==i)

           ++cnt;

   if(cnt==1)

       printf("yes\n");

   else printf("no\n");

   return 0;

}
```
DFS和BFS其实看看就行了，基本不会用到的。

## 接下来我们步入正题
给出下面这样一个无向图
![](https://cdn.luogu.com.cn/upload/pic/75507.png)

如果以V1为起点的话，让你做，你会怎么做。

根据直觉我们会每次找最小的边，直至拓展完所有节点；

以这个图为例：

1.V1距V2, V3, V4的距离分别是3，我们会先连接V1和V2;

2.在5, 8, 4, 6中4最小，所以连接V2和V4；

3.在5，6，2，11，10中2最小，所以连接V3和V4;

4.同理，连接V4和V5;

所以我们得到的这个图的最小生成树是19，可是这样做真的对吗？

其实这样做真的是正确的。因为你绕一圈之后到达这个点总比直接到达这个点要长。

下面给出严谨证明：

对于任意一个顶点v，连接到该顶点的所有边中的一条最短边(v, vj)必然属于最小生成树（即任意一个属于最小生成树的连通子图，从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树）。

### 根据这个基本思想我们可以写出一个很简单的算法
```cpp
#include<cstdio>
int a[6][6]= { {0, 0, 0, 0, 0, 0},{0, 0, 3, 5, 8, 0}, {0, 3, 0, 6, 4, 11}, {0, 5, 6, 0, 2, 0}, {0, 8, 4, 2, 0, 10}, {0, 0, 11, 0, 10, 0} }; //测试数据
int used[6]; //当前节点的状态
int main()
{
	int n = 5, ans = 0, flag;
	used[1] = 1;
	for(int k = 1; k < n; k++) //n个点需拓展 n - 1 次
	{
		int minn = 0x3f3f3f3f;
		for(int i = 1; i <= n; i++) if(! used[i]) //找一个未被拓展的节点
			for(int j = 1; j <= n; j++)
				if(used[j] && a[i][j] && a[i][j] < minn) {
					minn = a[i][j];
					flag = i;
				} //找一个已拓展的节点
		used[flag] = 1;
		ans += minn;
	}
	printf("%d\n", ans);
	return 0;
}

```
显然时间复杂度是O(n ^ 3), 所以我们需要对它进行优化。

我们定义一个lowcost[ ]，记录每个节点的最小值。

代码如下：
```cpp
#include<cstdio>
int a[6][6]= { {0, 0, 0, 0, 0, 0},{0, 0, 3, 5, 8, 0}, {0, 3, 0, 6, 4, 11}, {0, 5, 6, 0, 2, 0}, {0, 8, 4, 2, 0, 10}, {0, 0, 11, 0, 10, 0} };
int used[6], LowCost[6];
int main()
{
	int n = 5, ans = 0, k;
	used[1] = 1;
	for(int i = 1; i <= n; i++)
		LowCost[i] = a[1][i];
	for(int i = 1; i < n; i++)
	{
		int minn = 0x3f3f3f3f;
		for(int j = 1; j <= n; j++)
			if(LowCost[j] < minn && LowCost[j] && ! used[j])
			{
				minn = LowCost[j];
				k = j;
			} //从拓展的节点中选一个最小的
		used[k] = 1;
		for(int j = 1; j <= n; j++)
		{
			if(used[j]) continue;
			if((a[k][j] < LowCost[j] && a[k][j]) || ! LowCost[j]) LowCost[j] = a[k][j];
		} //更新lowcost[]
	}
	for(int i = 1; i <= n; i++)
		ans += LowCost[i];
	printf("%d\n", ans);
	return 0;
}

```
时间复杂度是O(n ^ 2)，一般情况下已经够用了，但其实还可以优化。

代码中我们多次查找lowcost[ ]中的最小值，每次的时间复杂度是O(n),所以可以写一个最小堆来进行优化。堆的时间复杂度O(logn)所以粗略估计一下时间复杂度是O(nlogn)

Prim算法的AC代码:

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn = 5001;
const int INF = 2147483647;


struct edge
{
	int to, next, w;
} e[400002]; //链式前向星

struct node
{
	int u, w; // u是节点，w是花费
	bool operator < (node x) const
	{
		return w > x.w;
	} //重载运算符，生成最小堆
};

int dis[maxn], head[maxn], num;// dis是最小花费，head存边，num为边数
bool vis[maxn];

void add(int u, int v, int w)
{
	e[++num].to = v;
	e[num].w = w;
	e[num].next = head[u];
	head[u] = num;
} // 加边

priority_queue<node> q;

int main()
{
	int n, m, ans = 0, cnt = 0;
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= m; i++)
	{
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		add(u, v, w); add(v, u, w); // 无向图要加两次
	}
	for(int i = 2; i <= n; i++)
		dis[i] = INF; // 初始化dis[]
	q.push((node) {1, 0});
	while(cnt < n) // 拓展 n - 1 次
	{
		node x = q.top();
		q.pop();
		if(vis[x.u]) continue;
		vis[x.u] = true;
		cnt++;
		ans += x.w;
		for(int i = head[x.u]; i ; i = e[i].next) 遍历u经过的所有的结点
			if(e[i].w < dis[e[i].to]) {
				dis[e[i].to] = e[i].w;
				q.push((node) {e[i].to, e[i].w});
			}
	}
	printf("%d", ans);
	return 0;
}
```
如果判断图是否联通只需要把while循环改为

```cpp
while(! q.empty() || cnt < n)
```
然后加上
```cpp
if(cnt < n) printf("orz");
else printf("%d", ans);
```
### 接下来我们介绍Kruskal算法。
Kruskal的基本思想是贪心，对所有的边进行排序，逐个相加，只要判断是否成环即可。

AC代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node
{
	int u, v, w;
} a[200001]; // 存边

int set[5001]; // 并查集数组

bool cmp (node a, node b)
{
	return a.w < b.w;
}

int find(int x) { return set[x] == x ? x : set[x] = find(set[x]); } // 并查集查找函数

int main()
{
	int n, m, ans = 0;
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) set[i] = i; // 并查集初始化
	for(int i = 1; i <= m; i++)
		scanf("%d%d%d", &a[i].u, &a[i].v, &a[i].w);
	sort(a + 1, a + m + 1, cmp);
	for(int i = 1; i <= m; i++) {
		int x = find(a[i].u);
		int y = find(a[i].v);
		if(x != y) { ans += a[i].w; set[x] = y; } // 如果两点不在一个集合，则加入之后不会成环。
	}
	printf("%d", ans);
	return 0;
}
```

写那么多不容易，点下赞谢谢。

---

## 作者：XiaQiang (赞：40)

##1. Problem Description


如题，给出一个无向图，求出最小生成树


##2. Input

第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N<=5000，M<=200000）

接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi


##3. Output

输出包含一个数，即最小生成树的各边的长度之和；


输入样例#1：

4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
输出样例#1：

7

##4. 详解


最小生成树\_Kruskal算法


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;

const int M=200100;
struct node{
    int x;
    int y;
    int w;
}a[M],t;
int n,e,dad[M],p=1,ans;

bool cmp(node x,node y){
    if(x.w<y.w)return 1;
    if(x.w==y.w)
        if(x.x>y.x)return 1;
    return 0;
}

void qsort(int l,int r){
    int i=l,j=r;node mid=a[(i+j)/2];
    while(i<=j){
        while(cmp(a[i],mid))i++;
        while(cmp(mid,a[j]))j--;
        if(i<=j){
            t=a[i];a[i]=a[j];a[j]=t;
            i++;j--;
        }
    }
    if(i<r)qsort(i,r);
    if(l<j)qsort(l,j);
}
int findx(int x){
    if(x==dad[x])return x;
    dad[x]=findx(dad[x]);
    return dad[x];
}
void solve(){
    qsort(1,e);
    for(int i=1;i<=n;i++)dad[i]=i;
    for(int i=1;i<=e;i++){
        if(findx(a[i].x)!=findx(a[i].y)){
            ans+=a[i].w;
            dad[findx(a[i].x)]=a[i].y;
            p++;
            if(p==n)return ;
        }
    }
}
int main(){
    freopen("mst.in","r",stdin);
    scanf("%d%d",&n,&e);
    for(int i=1;i<=e;i++)scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].w);
    solve();
    printf("%d",ans);
    return 0;
}
```

最小生成树\_prims算法

注意：需要注意重边的情况！！

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int M=5001,INF=999999999;
int n,e1,e;
int w[M][M];
int minc[M];

void solve(int s){
    int i,j,count=0,min,k;
    for(i=1;i<=n;i++)minc[i]=w[s][i];
    minc[s]=0;
    for(i=1;i<n;i++){
        min=INF;
        for(j=1;j<=n;j++){
            if(minc[j] && minc[j]<min){
                min=minc[j];
                k=j;
            }
        }
        minc[k]=0;
        count+=min;
        for(j=1;j<=n;j++){
            if(w[k][j]<minc[j])
                minc[j]=w[k][j];
        }
    }
    printf("%d\n",count);
}

int main(){
    freopen("mst.in","r",stdin);
    int t1,t2,t3;
    for(int i=0;i<=M;i++)
        for(int j=0;j<=M;j++)w[i][j]=INF;
    scanf("%d%d",&n,&e);
    for(int i=1;i<=e;i++){
        scanf("%d%d",&t1,&t2);scanf("%d",&t3);
        if(t3<w[t1][t2])w[t2][t1]=w[t1][t2]=t3;
    }
    solve(n>>1);
    return 0;
}
```

---

## 作者：retired_LeoStrange (赞：36)

### 在阅读这篇文章前，你需要的基础有：
	     了解图的基本概念
         会并查集，还会一点点路径压缩
         知道sort的比较函数
### 好，我们切入正题。
    何为最小生成树？
  就是给你一个~~五香~~无向连通图，让你选一些边，这些边能把图中所有节点连通，并且选出的边的权值要尽量小

## 下面介绍Kruskal算法
~~（敲重点划黑板了！）~~
#### ~~一句话概括：Kruskal就是拿个破数组存边，按权值排个序，再从头到尾扫一遍，用个并查集乱搞……~~

### 算法名称：Kruskal
### 算法思想：贪心
### 存图方式：边集数组
### 具体流程：
	1.按照边集数组中的边权从小到大排序
    2.初始化并查集
    3.从头到尾扫一遍图中所有边：
      若边连接的两个节点在同一个集合内（即两个节点被已经选择的边连通），则啥事儿也不干（因为已经连通了，没有必要选这条边）
	  若边连接的两个节点不在同一个集合内（即两个节点未连通），则合并两个节点，并把边权加到答案里（选这条边）

代码不甚好看，也未判断不连通情况，敬请谅解



------------
```cpp
//Kruscal
#include <bits/stdc++.h>
using namespace std;
struct edge{
	int f,t,v;
} g[200002];
bool cMp(edge a,edge b)
{
	return a.v<b.v;
}
int n,m,ans,f[5002];
int roots(int x)
{
	return f[x]==x?x:f[x]=roots(f[x]);
}
int main()
{
	ios::sync_with_stdio(0);//读入优化
	cin>>n>>m;
	for(int i=1; i<=m; ++i) cin>>g[i].f>>g[i].t>>g[i].v;
	sort(g+1,g+m+1,cMp);
	for(int i=1; i<=n; ++i) f[i]=i;
	for(int i=1; i<=m; ++i)
	{
		if(roots(g[i].f)==roots(g[i].t)) continue;
		f[roots(g[i].f)]=roots(g[i].t);
		ans+=g[i].v;
	}
	cout<<ans<<"\n";
	return 0;
}
```

------------
~~第一篇题解，写的不太好，欢迎提出建议~~

---

## 作者：Mine_King (赞：34)

- **2020/06/22 Upt：几乎重写了一下**  
- **2020/07/30 Upt：修了一些小锅**

在[这里](https://www.luogu.org/blog/yhdhg1395754790/)看本文章,效果更佳。  
对于最小生成树的定义：在一个有$n$个点的图中，用$n - 1$条边将其连成一棵树，使得所有$n - 1$条边的权值之和最小。  
**最小生成树有两种做法：Prim和Kruskal，本文章两个都会介绍。**

Prim：  
前置知识：[堆](https://www.luogu.org/blog/yhdhg1395754790/solution-p3378)  
Prim的做法就是把点分为已经加入最小生成树的和未被加入的，每次把距离已加入的点最近的边加入最小生成树。不过记录边比较麻烦，我们可以记录点，记$v_i$为节点$i$到已加入部分最短的边的长度，而小根堆记录$v_i$和$i$：

1. 首先随便找一个点（一般选1号点）入小根堆。
2. 每次取出堆顶$u$并pop。
3. 判断$u$是否已经加入最小生成树
4. 如果不是，将$v_u$加入最小生成树的边权和
5. 然后遍历所有连接的点$x$，
6. 若$v_x>v_u$，则将$x$加入堆。
7. 重复2,3,4,5,6直到堆为空或者已经加入了$n-1$条边

关于无法形成一个树：该情况就是在结束后判断$n$个点是否都已经被标记，或者由于记录了边的条数，也可以判断边数是否为1。

**code:**
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,cnt,ans;
int v[5005];
bool f[5005];//f判断该节点是否已经加入最小生成树
struct node
{
	int first,second;
	friend bool operator<(node x,node y){return x.first>y.first;}
};
priority_queue<node>q;//小根堆
struct graph
{
	int tot;
	int hd[5005];
	int nxt[400005],to[400005],dt[400005];
	void add(int u,int v,int w)
	{
		tot++;
		nxt[tot]=hd[u];
		hd[u]=tot;
		to[tot]=v;
		dt[tot]=w;
		return ;
	}
}g;//链式前向星存图
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		g.add(u,v,w);
		g.add(v,u,w);
	}
	memset(v,0x3f,sizeof(v));
	q.push((node){0,1});
	v[1]=0;//入堆第一个点
	while(!q.empty()&&cnt<n-1)//cnt记录边的条数，若堆不为空或边数不足n-1则继续
	{
		int xx=q.top().second;//取出堆顶
		q.pop();//弹出
		if(!f[xx])//若还未加入最小生成树
		{
			f[xx]=true;//标记为加入
			cnt++;//边数+1
			ans+=v[xx];//记录长度
			for(int i=g.hd[xx];i;i=g.nxt[i])//遍历能到达的点
				if(v[g.to[i]]>g.dt[i])//满足条件
				{
					v[g.to[i]]=g.dt[i];//先更改v
					q.push((node){v[g.to[i]],g.to[i]});//然后入堆
				}
		}
	}
	for(int i=1;i<=n;i++)
		if(!f[i])
		{
			printf("orz");
			return 0;
		}//判断是否连通
	printf("%d",ans);
	return 0;
}
```

Kruskal：  
前置知识：[并查集](https://www.luogu.org/blog/yhdhg1395754790/solution-p3367)  
Kruskal的做法：

1. 把所有边按顺序排序。
2. 从第一条边开始枚举。
3. 如果边的两端联通（用并查集判断），就跳过。
4. 否则就加入这条边，并合并两个端点的集合。
5. 重复3,4步直到枚举完。

关于无法形成一个树：判断是否所有点都在同一个集合里。 

**code：**
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,ans;
struct node
{
	int f,t,d;
}a[200005];//存边，Kruskal不用建图
bool cmp(node x,node y){return x.d<y.d;}
struct bin
{
	int w[5005];
	int find(int x)
	{
   		if(x==w[x]) return x;
	    w[x]=find(w[x]);
   		return w[x];
	}
	void add(int x,int y)
	{
    	w[find(x)]=find(y);
   		return ;
	}
	bool ask(int x,int y)
	{
   		if(find(x)==find(y)) return true;
    	else return false;
	}
}b;//并查集
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%d%d%d",&a[i].f,&a[i].t,&a[i].d);
	for(int i=1;i<=n;i++) b.w[i]=i;//并查集初始化
	sort(a+1,a+m+1,cmp);//按边权排序
	for(int i=1;i<=m;i++)//枚举每条边
	{
		if(b.ask(a[i].f,a[i].t)) continue;//连通则跳过
		ans+=a[i].d;//否则记录
		b.add(a[i].f,a[i].t);//改为连通
	}
	for(int i=2;i<=n;i++)
		if(!b.ask(1,n))
		{
			printf("orz");
			return 0;
		}//判断是否连通
	printf("%d",ans);
	return 0;
}

```

---

## 作者：Phrooce (赞：34)

然而楼下的优化prime是pas c++选手表示看不懂 2333333

好了 蒟蒻在这里来一发优先队列优化的prime 建议看之前先学习朴素的prime（然而建议你们先学最简单的Kruskal）


prime的思想是按点贪心

我们先用一个数组dist 表示如果添加了这个点需要增加的权值

因为是贪心 所以dist[ i ]越小越好

初始状态 所有dist全为一个很大的数（比方说0x7f7ff)

然后我们随机选择一个点 将它的dist变为0（我选择的是1号节点），并将它标记（因为最小生成树每个点只能用一次）

然后我们遍历与这个点相连的点 将它们的dist更新（更新为它们的边权值）

现在 我们得到了多个dist不为0x7f7ff的点了

于是 我们选择其中dist最小的点 标记它 然后再遍历与它相连的点，更新它们的dist

不断的重复 重复 直到所有点都被标记为止

当然 也存在orz的情况（虽然测试点并没有ORZ的情况 23333） 这时 被标记的点的数量是小于n的，加个判断就好啦



下面是朴素的pirme  时间复杂度O（N^2）



```cpp
#include<bits/stdc++.h>
#define INF 0x7f7ff
using namespace std;
int n,m,dist[5010],head[5010],k,ans;
bool vis[5010];
struct node
{
    int to,next,w;
}edge[400010];
void add(int u,int v,int w)
{
    edge[++k].to=v;
    edge[k].w=w;
    edge[k].next=head[u];
    head[u]=k;
}
void Prime()
{
    fill(dist+1,dist+n+1,INF);
    dist[1]=0;
    for(int j=1;j<=n;j++)
    {
        int u=-1,minn=INF;
        for(int i=1;i<=n;i++)
        {
            if(dist[i]<minn&&!vis[i])
            {
                u=i;
                minn=dist[i];
            }
        }
        if(u==-1)
        {
            ans=-1;
            return;
        }
        vis[u]=1;
        ans+=dist[u];
        for(int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(!vis[v]&&dist[v]>edge[i].w) dist[v]=edge[i].w;
        }
    }
}
int main()
{
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
        add(b,a,c);
    }
    Prime();
    if(ans==-1) cout<<"orz"<<endl;
    else cout<<ans;
}
```
从上面的代码中 我们不难发现 每次通过枚举找dist最小的点太慢了 于是就有了优先队列优化的版本

优先队列优化prime: 时间复杂度 O（rand( )） ( 群里的dalao告诉我的 黑人问号？？？）


```cpp
#include<bits/stdc++.h>
#define INF 0x7f7ff
using namespace std;
int n,m,dist[5010],head[5010],k,ans,tot;
bool vis[5010];
struct node
{
    int to,next,w;
}edge[400010];
struct p
{
    int id,d;
    bool operator < (const p &a) const
    {
        return a.d<d;
    }
};
void add(int u,int v,int w)
{
    edge[++k].to=v;
    edge[k].w=w;
    edge[k].next=head[u];
    head[u]=k;
}
void Prime()
{
    fill(dist+1,dist+1+n,INF);
    priority_queue<p> q;
    p now;
    now.id=1;now.d=dist[1]=0;
    q.push(now);
    while(!q.empty())
    {
        p now=q.top();q.pop();
        int u=now.id;
        if(now.d!=dist[u]) continue;
        vis[u]=1;
        ans+=dist[u];
        tot++;
        for(int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(!vis[v]&&dist[v]>edge[i].w)
            {
                dist[v]=edge[i].w;
                p nxt;
                nxt.d=dist[v];
                nxt.id=v;
                q.push(nxt);
            }
        }
    }
    if(tot<n) ans=-1;
}
int main()
{
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        add(a,b,c);
        add(b,a,c);
    }
    Prime();
    if(ans==-1) cout<<"orz"<<endl;
    else cout<<ans;
}
当然还有种做法叫做Kruskal 楼下有很多的题解 我就不写了_(:з」∠)_（才不是因为懒）
```

---

## 作者：Undefined_Myth (赞：11)

对于这个Prim模板我一定要逼逼一下

你说洛谷是想干什么呢，竟然数据里面又有自环又有重边。

于是我WA了N 此，又莫名的超内存。最后终于去了自环又去了重边。不多打摆了，看代码！有我去除毒药的方法。

```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
#define MAXN 5000+5 
const int INF=99999999;
int n,m;
int dis[MAXN+1];
bool book[MAXN+1];//标记一个点是否加入最小生成树 
int sum;//整条最小生成树的长度
int map[MAXN+1][MAXN+1],tot;
void Prim()
{
    int pos;//记录最小的边连向的点的编号 
    book[1]=true;//将1号顶点加入//用true比较好，因为初始化是false 
    tot++;
    while(tot<=n-1)//到n的时候就不能再进行加点操作了，因为都进入了
    {
        int min=INF;
        for(int i=1;i<=n;i++)
            if(book[i]==false && dis[i]<min){//注意对book的判断啊，加入最小生成树的就肯定不能再去判断 
                min=dis[i];
                pos=i;
            }
        book[pos]=true;//注意book的操作 
        tot++;
        sum+=dis[pos];
        for(int k=1;k<=n;k++)//枚举pos点的所有出边，进行松弛操作 
        {
            if(book[k]==false && dis[k]>map[pos][k])//如果pos不能到达k点也成立，因为那是INF不会小于的
                dis[k]=map[pos][k];
        }
```
}//怎么判断这个图不联通啊
```cpp
    //要有的输出orz 
}
int main() 
{
    scanf("%d%d",&n,&m);
    //记得初始化
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i==j)
                map[i][j]=0;
            else
                map[i][j]=INF;
    //注意初始化要在赋值之前 
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        /*if(edge[i].u==edge[i].v)
            continue;*///也可以这样去自环 
        if(w<map[u][v])//处理重边，按题目要求，求最小生成树，所以取最小 
```
{//所以之前的初始化更有必要了

```cpp
            map[u][v]=w;
            map[v][u]=w;
        }
    }
    //初始化dis数组 
    //这里最开始默认为1号顶点为源点，开始是1号顶点到各个顶点的初始距离，因为开始最小生成树里只有1号 
    for(int i=1;i<=n;i++)
        map[i][i]=0;//去环操作——数据有毒，有一个点组成正环 
    for(int i=1;i<=n;i++)
        dis[i]=map[1][i];
    Prim();
    printf("%d",sum);
        return 0; 
}
```
这个题目让我学会了猜出题者的脑洞大的程度。
然后加上这些问题的破解方法！


---

## 作者：hfee (赞：10)

# $kruskal$

kruskal简单，kruskal好懂

其实这题评分有点低，大概是黄题差不多

这篇题解主要是从头开始讲，从并查集讲到底

好了，看题。

诶，题面怎么没讲最小生成树是什么？

**最小生成树：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。**

--百度百科

用人话说：**把所有点都串起来且长度最短的一个网**

那么我们应该怎么做呢？

**$kruskal$**:

依据权值对每条边进行排序，然后依次取出每条边

如果已经取出的所有边把所有点都串起来了，那么我们就结束，输出答案

我来盗图了！图片转自[Taday_Bule_Rainbow的题解](https://www.luogu.org/blog/tbr-blog/solution-p3366)

![](https://cdn.luogu.com.cn/upload/pic/28091.png)

看起来是不是很简单？那么我们一步一步分析

前向星存图，结构体排序，很简单不说了

主要是怎么判断当前是否联通

那么又讲到了：**并查集**

并查集是什么呢？[模板题](https://www.luogu.org/problem/P3367)

其实非常好理解，一个一个暴搜显然是不可行的

我们可以为每个人定一个祖先，这样判断就可以直接判断两人的祖先是否一样

首先初始化，让每个人的祖先开始都等于自己

然后

```
int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
   //路径压缩
}
```
那么路径压缩是个啥呢？比如说你要找1的祖先，结果你找到了2，然后又找到了3，然后才找到最终祖先4

那么2和3的祖先都是4了

我们直接在递归的过程中保存就行了

现在我们直接上代码，所有的都已经注释好了，应该很好理解（逃

```
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,m,f[N],ans,bs,pd;
struct Edge{
	int u,v,w;
}e[N];//前向星，但是没有add函数，很不错 
int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}//并查集，上面讲过了 
bool cmp(Edge x,Edge y){
	return x.w<y.w;//按权值排序 
}//结构体排序，很实用的技能 
int main(){
	cin>>n>>m;
	for(register int i=1;i<=n;i++) f[i]=i;//初始化 
	for(register int i=0;i<m;i++) cin>>e[i].u>>e[i].v>>e[i].w;//输入 
	sort(e,e+m,cmp);//排序 
	for(register int i=0;i<m;i++){
		int fv=find(e[i].v),fu=find(e[i].u);//我们取出当前边的起点和终点所在的祖先 
		if(fv==fu) continue;//如果它们相同，就说明它们联通，那么就不用加这条边了 
		f[fv]=fu;//把祖先存进去 
		ans+=e[i].w;//总答案+=这条边的权值 
		if(++bs==n-1){//连通n个点需要n-1条边 
			pd=1;//判断是否连通的东西 
			break;	
		} 
	}
	if(!pd) cout<<"orz";//如果不连通就输出（这题好像没有这个数据 
	else cout<<ans;
	return 0;//愉快地结束了 
}
```
# 写了蛮久，求过QAQ

---

## 作者：glassy (赞：7)

**预告：本题解对新人不友好**，新人请忽视，算法相关：**LCT**。

本来在做[魔法森林](https://www.luogu.org/problemnew/show/P2387)，可后来发现首先要**动态维护最小生成树**。

Kruskal算法是贪心的，每次选择权值最小的一条边，尝试加入其中，但这也导致其必须先排序，能否换一个思路？

考虑每次加入一条新边 $(u,v,w)$，若加入后仍然没有形成环，则这条边（可能）在最小生成树中。  
反之，即加入这条边后形成了环，我们可以得到：这个环上（至少）有一条边不在最小生成树上。很容易想到，这条边一定是这个环上边权最大的边（之一）。那如何才能找到呢？在加入这条边之前，可以用LCT求出点 $u$ 到点 $v$ 之间的最大边权的那条边，然后断开它。

可LCT一般是维护点上信息的，要如何维护边上的信息呢？这里当然可以使用下面[某篇题解](https://www.luogu.org/blog/pupuvovovovo/solution-p3366)的方法，把**边转换为点**，但这样导致点数增大了一倍，有没有更~~(劣)~~好的方法呢？当然有，其实我们只需要在每个点中多维护 $4$ 个信息就好了。

为了方便讲解，这里先把一些定义表示好。 
1. $(a,b)$:节点A和节点B的**直接**连边。
2. $(a-b)$:节点A和节点B的**路径**。
3. $pre$:在原树中，当前节点和父亲节点的边(注意不是边权)，如下图中 $\text{F.}pre=(\text{B},\text{F}),\text{A.}pre=\text{NULL}$
4. $nxt$:在原树中，当前节点和其重儿子（也是LCT中，所在的Spaly的直接后继）的边，如下图中 $\text{G.}nxt=(\text{G},\text{H}),\text{J.}nxt=\text{NULL}$
5. $front$:当前节点所在的Splay中的节点中，在原树中深度最小的节点(也是当前节点所在的重链中，深度最小的节点)的 $pre$，如：$\text{H.}front=\text{C.}pre=(\text{A},\text{C})$
6. $back$:当前节点所在的Splay中的节点中，在原树中深度最大的节点(也是当前节点所在的重链中，深度最大的节点)的 $pre$，如：$\text{G.}back=\text{J.}nxt=\text{NULL}$

![pic](https://s1.ax2x.com/2018/06/06/RWN7y.png)

这多维护的四个信息便是 $front,back,pre,nxt$
```
struct node;
struct edge {
	node *x,*y;
	edge(node *a,node *b):x(a),y(b) {}
};
struct node {
	int rev;//翻转标记
	node *fa,*ch[2];//父亲，儿子
	edge *front,*back,*pre,*nxt;
	node(node *f=NULL):fa(f),rev(0),maxx(NULL),pre(NULL),nxt(NULL),front(NULL),back(NULL) {
		ch[0]=ch[1]=NULL;
	}
}
```
### Update
先来考虑如何维护 $front,back$，这两个硬骨头。
```
void node::update(void) {
	front=pre,back=nxt;
	if(ch[0]) front=ch[0]->front;
	if(ch[1]) back=ch[1]->back;
}
```
如果能保证update的顺序是从深度更大的点到深度更小的点，那我们就能保证 $front,back$ 的正确。
### revs
接下来考虑换根的前置操作，翻转。
```
void revs(node *x) {
	if(!x) return;
	swap(x->ch[0],x->ch[1]);
	swap(x->pre,x->nxt);
	swap(x->front,x->back);
	x->rev^=1;
}
```
由于整个先后顺序都变了，因此要交换 $pre$ 和 $nxt$，$front$ 和 $back$。
### pushdown
考虑完翻转，考虑翻转标记的下传，这里和普通LCT没有区别。
### Rotate和Splay
这里和普通LCT没有区别。
### access
接下来是打通 $x$ 到根节点的信息。
```
#define front(t) (t?t->front:NULL)
void LCT::access(node *x) {
	node *t=NULL;
	while(x) {
		splay(x); x->ch[1]=t;
		x->nxt=front(t); x->update();
		t=x; x=x->fa;
	}
}
```
由于改变了 $x$ 的右儿子(重链上的儿子)，即改变了当前的链剖分，所以 $x$ 的后一条边理应变成他新的右儿子所在的splay里最左边的点的前一条边，即他心右儿子的 $front$。
### make_root
依赖 $revs$ 和 $access$，由于那两个函数均处理完毕，这里和普通LCT没有区别。
### find_root和link
找根和普通LCT没有区别，但连边会更改。由于 $link$ 操作(一般)连的是轻边，因此只需要改变其中一个点的 $pre$。
```
node *rooter(node *x) {
		access(x);
		splay(x);
		while(x->pushdown(),x->ch[0])
			x=x->ch[0];
		return x;
	}
bool link(node *x,node *y,int w) {
	if(rooter(x)==rooter(y))//如果已连通
		return false;
	make_root(x);
	x->fa=y;
	x->pre=new edge(x,y,w);//新建边
	return true;
}
```
### Cut
这个操作要改的东西不少啊……
```
#define del(x) if(x){delete x;x=NULL;}
void cut(node *x,node *y) {
	make_root(x),access(y),splay(y);
	if(y->ch[0]==x) {
		x->fa=y->ch[0]=NULL;
		del(x->pre);
		del(y->nxt);
		del(x->front);
		del(y->back);
	} x->update(),y->update();
}
```
其中一个节点（这里选 $x$）成为根后，由于 $x$ 的父亲没有了，因而 $x.pre$ 要删除，而在 $x$ 所在的splay中为深度最浅的节点，因此 $x->front$ 也等于$x.pre$，因此也要删除，同理，$y$ 的 $back$ 和 $nxt$ 也要删去（注意 $access$ 后的节点是所在重链中深度最大的）  
有的人问，这条边只被 $new$ 了一次，却（可能）被 $delete$ 两次，什么不会报错？我只能告诉你，delete任何一个指针都不会出错，包括`delete NULL`。
至此，边权信息被很好地维护了，并且没有增加节点数量（增大Splay的规模）。  
下面给出本题完整AC代码：
```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int maxn=200010;
struct node;
struct edge {
    int w;
    node *x,*y;
    edge(node *a,node *b,int tw):x(a),y(b),w(tw) {}
};
edge* mmax(edge *a,edge *b) {
    if(!b) return a;
    if(!a) return b;
    return a->w>b->w?a:b;
}
struct node {
    int rev;
    node *fa,*ch[2];
    edge *front,*back,*pre,*nxt,*maxx;
    node(node *f=NULL):fa(f),rev(0),maxx(NULL),pre(NULL),nxt(NULL),front(NULL),back(NULL) {
        ch[0]=ch[1]=NULL;
    }
#define size(t) (t?t->size:0)
#define maxx(t) (t?t->maxx:0)
#define front(t) (t?t->front:NULL)
#define weight(t) (t?t->w:0)
    void update() {
        front=pre;
        back=nxt;
        if(ch[0]) front=ch[0]->front;
        if(ch[1]) back=ch[1]->back;
        maxx=mmax(mmax(maxx(ch[0]),maxx(ch[1])),mmax(pre,nxt));
    }
    friend void revs(node *x) {
        if(!x) return;
        swap(x->ch[0],x->ch[1]);
        swap(x->pre,x->nxt);
        swap(x->front,x->back);
        x->rev^=1;
    }
    void pushdown() {
        if(!rev) return;
        rev=0,revs(ch[0]),revs(ch[1]);
    }
};
struct  LCT {
#define which(p) (p->fa->ch[1]==p)
#define is_root(p) ((!p->fa)||(p->fa->ch[0]!=p&&p->fa->ch[1]!=p))
#define del(x) if(x){delete x;x=NULL;}
    node *pt[maxn];
    void init(int n) {
        for(int i=1; i<=n; i++)
            pt[i]=new node();
    }
    void rotate(node *p) {
        int a=which(p)^1;
        node *f=p->fa;
        f->ch[a^1]=p->ch[a];
        if(p->ch[a]) p->ch[a]->fa=f;
        p->fa=f->fa;
        if(!is_root(f)) p->fa->ch[which(f)]=p;
        f->fa=p,p->ch[a]=f;
        f->update(),p->update();
    }
    void splay(node *p) {
        static node *tmp[maxn];
        int pos=0;
        for(node *t=p;; t=t->fa) {
            tmp[++pos]=t;
            if(is_root(t)) break;
        }
        for(; pos; --pos)
            tmp[pos]->pushdown();
        for(; !is_root(p); rotate(p))
            if(!is_root(p->fa))
                rotate(which(p)==which(p->fa)?p->fa:p);
        p->update();
    }
    void access(node *x) {
        node *t=NULL;
        while(x) {
            splay(x);
            x->ch[1]=t;
            x->nxt=front(t);
            x->update();
            t=x,x=x->fa;
        }
    }
    void make_root(node *p) {
        access(p),splay(p),revs(p);
    }
    bool link(node *x,node *y,int w) {
        if(rooter(x)==rooter(y))
            return false;
        make_root(x);
        x->fa=y;
        x->pre=new edge(x,y,w);
        return true;
    } bool link(int a,int b,int w) {
        return link(pt[a],pt[b],w);
    }
    void cut(node *x,node *y) {
        make_root(x),access(y),splay(y);
        if(y->ch[0]==x) {
            x->fa=y->ch[0]=NULL;
            del(x->pre);
            del(y->nxt);
            del(x->front);
            del(y->back);
        }
        x->update(),y->update();
    }
    node *rooter(node *x) {
        access(x);
        splay(x);
        while(x->pushdown(),x->ch[0])
            x=x->ch[0];
        return x;
    }
    edge* query(int x,int y) {
        make_root(pt[x]);
        access(pt[y]);
        splay(pt[y]);
        return pt[y]->maxx;
    }
} lct;
int n,m;
long long ans=0;
int main() {
    scanf("%d%d",&n,&m);
    lct.init(n+1);
    int merge=0;
    for(int i=1,u,v,w; i<=m; i++) {
        scanf("%d%d%d",&u,&v,&w);
        if(u==v) continue;
        if(!lct.link(u,v,w)) {
            edge *tmp=lct.query(u,v);
            if(tmp->w>w) {
                lct.cut(tmp->x,tmp->y);
                ans-=tmp->w;
                ans+=w;
                lct.link(u,v,w);
            }
        } else ans+=w,merge++;
    }
    if(merge<n-1) puts("orz");
    else printf("%lld\n",ans);
}
```

---

## 作者：wick (赞：5)

## 最小生成树

[点击就送玄铁重剑](https://www.luogu.org/problem/P3366)(题目传送)

**生成树的概念**

- 在图论中,如果连通图G的一个子图是一棵包含所有顶点的树，则该子图称为G的生成树(SpanningTree).

- 生成树是连通图的包含图中的所有顶点的极小连通子图.

- 图的生成树不惟一.从不同的顶点出发进行遍历，可以得到不同的生成树.

常用的生成树算法有DFS生成树,BFS生成树,PRIM 最小生成树和Kruskal最小生成树算法.

### 普里姆算法（Prim算法）

图论中的一种算法,可在加权连通图里搜索最小生成树.意即由此算法搜索到的边子集所构成的树中,不但包括了连通图里的所有顶点(英语:Vertex (graph theory)),且其所有边的权值之和亦为最小.该算法于1930年由捷克数学家沃伊捷赫•亚尔尼克(英语:Vojtěch Jarník)发现；并在1957年由美国计算机科学家罗伯特•普里姆(英语:Robert C. Prim)独立发现；1959年,艾兹格•迪科斯彻再次发现了该算法.因此,在某些场合,普里姆算法又被称为DJP算法,亚尔尼克算法或普里姆－亚尔尼克算法.

**算法描述**

1).输入,一个加权连通图,其中令顶点集合为E,边集合为W.

2).将dis数组(生成树到任一个点的最小距离)初始化到最大.

3).(一般)找顶点1为起始点,存到递减的数据结构(优先队列,堆,multiset.......)中,以便找到权值最小的点.之后将其扔掉,从该点开始将能到的点距离更新一下.

4).重复下列操作3,直到数据结构为空或所有的点都已访问过.

5).输出.


**度娘的描述 ~~(有点玄幻)~~:**

1).输入:一个加权连通图,其中顶点集合为V,边集合为E;

2).初始化:Vnew = {x},其中x为集合V中的任一节点(起始点),Enew = {},为空;

3).重复下列操作,直到Vnew = V:

a.在集合E中选取权值最小的边<u, v>,其中u为集合Vnew中的元素,而v不在Vnew集合当中,并且v∈V(如果存在有多条满足前述条件即具有相同权值的边,则可任意选取其中之一);

b.将v加入集合Vnew中,将<u, v>边加入集合Enew中;

4).输出:使用集合Vnew和Enew来描述所得到的最小生成树.

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571721928634&di=66bfafe3e1b62f24889196c2c0f5f52d&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180607005817263640.png)

### Prim代码

用邻接表优化与dijskra神似

```
#include<bits/stdc++.h>
#define R register int//优化,可忽略
#define P pair <int,int>
using namespace std;
int k,n,m;
int cnt,sum,dis[10005],vis[10005];
vector <int> E[200005];//存点
vector <int> W[200005];//存边
inline void add(int u,int v,int w) {
	E[u].push_back(v);//存点
	W[u].push_back(w);//存边
}
priority_queue <P,vector<P>,greater<P> > q;//递减
inline void prim() {//神似dijskra
	memset(dis,127,sizeof(dis));//初始化
	dis[1]=0;//初始化
	q.push(make_pair(dis[1],1));//初始化
	while(!q.empty()&&cnt<n) {
		int d=q.top().first,u=q.top().second;
		q.pop();
		if(vis[u]) continue;//访问过就不访问了
		cnt++;
		sum+=d;//有就加
		vis[u]=1;
		for(R i=0; i<E[u].size(); i++)//dijskra这里是循环找中界点,而这里则直接找与该点相邻的边,刷新一遍距离
		   if(W[u][i]<dis[E[u][i]]){
			dis[E[u][i]]=W[u][i]；
               		q.push(make_pair(dis[E[u][i]],E[u][i]));
    		}
	}
}
int main() {
	scanf("%d%d",&n,&m);
	for(R i=1; i<=m; i++) {
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
		add(b,a,c);
	}
	prim();
	if (cnt==n)printf("%d",sum);
	else printf("orz");
}
```

### 克鲁斯卡尔算法(Kruskal)

Kruskal算法是一种用来查找最小生成树的算法,由Joseph Kruskal在1956年发表.用来解决同样问题的还有Prim算法和Boruvka算法等.三种算法都是贪心算法的应用.和Boruvka算法不同的地方是,Kruskal算法在图中存在相同权值的边时也有效.

**思想**

先构造一个只含 n 个顶点、而边集为空的子图,把子图中各个顶点看成各棵树上的根结点,之后,从网的边集 E 中选取一条权值最小的边,若该条边的两个顶点分属不同的树,则将其加入子图,即把两棵树合成一棵树,反之,若该条边的两个顶点已落在同一棵树上,则不可取,而应该取下一条权值最小的边再试之.依次类推,直到森林中只有一棵树,也即子图中含有 n-1 条边为止.

其实就是贪心.

**算法描述**

1).新建图G,G中拥有原图中相同的节点,但没有边；

2).将原图中所有的边按权值从小到大排序；

3).从权值最小的边开始,如果这条边连接的两个节点于图G中不在同一个连通分
量中,则添加这条边到图G中；

4).重复3,直至图G中所有的节点都在同一个连通分量中.

**wait!!**

请先看一下下面这个数据：

```
5 5
1 5 5
5 6 8
6 7 15
7 1 30
8 9 200
```

这个数据已经把权值从小到大排序了,暂时不用再考虑.

我们先按贪心的想法来思考:

1、连接1城市和5城市. 

2、连接5城市和6城市. 

3、连接6城市和7城市.

4、连接7城市和1城市.

到这里，就出问题了,完成这4步,便会形成一个环，无法生成最小生成树了.

所以我们要去判断是否会形成环,用并查集. (P3367  [并查集](https://www.luogu.org/problem/P3367))

![特经典的图解](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571722553609&di=ba133c4cb5711a184ff19aa0dcd426cd&imgtype=0&src=http%3A%2F%2Fwww.lwlwq.com%2Fxiaowei%2Fhome%2Fuploads%2F2015%2F03%2Fkruskal-procedure.png)

### Kruskal代码

不多做解释.

```
#include<bits/stdc++.h>
using namespace std;
struct point {
    int l,r,w;//w是路径长度
};
point a[200005];
int n,m,s;
int fa[10005];
int find(int x) {//并查集的模板,一直往上找父节点
    if(x==fa[x])return x;
    return fa[x]=find(fa[x]);
}
bool cmp(point a,point b) {//以路径长度排序
    return a.w<b.w;
}
void dfs() {
    int cnt=0;
    for(int i=1; i<=m; i++) {
        int v=find(a[i].l),u=find(a[i].r);//找父节点,看是否同根
        if(v==u)continue;//已经被接在了树上,就不用接了
        ++cnt;
        s+=a[i].w;
        fa[u]=v;
        if(cnt==n-1) return;
    }
}
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; i++)
    	fa[i]=i;//初始化,自己是自己的父节点
    for(int i=1; i<=m; i++)
        cin>>a[i].l>>a[i].r>>a[i].w;
    sort(a+1,a+m+1,cmp);//排序
    dfs();
    cout<<s;
    return 0;
}
```
**prim与kruskal的比较**

prim:该算法是直接查找,多次寻找邻边的权重最小值,时间复杂度为O(n^2),与图中边数无关,该算法适合于稠密.

kruskal:该算法先对权重排序后查找,需要对图的所有边进行访问,所以kruskal算法的时间复杂度只和边(e)又关系,可以证明其时间复杂度为O(eloge).适合稀疏图

所以说,Kruskal在算法效率上是比Prim快的,但各有各的优点.

上面还提到了一种古老的算法Boruvka,(Borůvka),已有大佬讲解,便不再赘述.


PS:

顺便附上Prim+堆优化

~~怎么长,还不如用优先队列呢~~

```
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int next;
	int c;
	int zhi;
} e[200005];
int last[2000005],dis[2000005],n,m,ans,k;
struct node {
	int num;
	node() {}
	node(int h) {
		num=h;
	}
	bool operator <(const node & p)const {
		return dis[p.num]<dis[num];
	}
};
int located[2000005];
int heap[2000005];
int heap_size;
inline void put(int d) {//手写 
	int now,next;
	heap[++heap_size]=d;
	now=heap_size;
	located[d]=now;
	while(now>1) {
		next=now>>1;
		if(dis[heap[now]]>=dis[heap[next]])break;
		located[d]=next;
		located[heap[next]]=now;
		swap(heap[now],heap[next]);
		now=next;
	}
	return;
}
inline void change(int d) {
	int now,next;
	now=located[d];
	while(now>1) {
		next=now>>1;
		if(dis[heap[now]]>=dis[heap[next]])break;
		located[d]=next;
		located[heap[next]]=now;
		swap(heap[now],heap[next]);
		now=next;
	}
	return;
}
inline int get() {
	int now,next,res;
	res=heap[1];
	heap[1]=heap[heap_size--];
	now=1;
	located[heap[1]]=1;
	located[res]=0;
	while(now*2<=heap_size) {
		next=now*2;
		if(next<heap_size&&dis[heap[next+1]]<dis[heap[next]])++next;
		if(dis[heap[now]]<=dis[heap[next]])break;
		located[heap[now]]=next;
		located[heap[next]]=now;
		swap(heap[next],heap[now]);
		now=next;
	}
	return res;
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=m; i++) {
		int a,b,c;
		cin>>a>>b>>c;
		e[++k].next=b;
		e[k].c=c;
		e[k].zhi=last[a];
		last[a]=k;
		e[++k].next=a;
		e[k].c=c;
		e[k].zhi=last[b];
		last[b]=k;
	}
	for(int i=2; i<=n; i++)
		dis[i]=INT_MAX;
	for(int j=last[1]; j; j=e[j].zhi) {
		int y=e[j].next;
		int c=e[j].c;
		if(c<dis[y])dis[y]=c;
	}
	for(int i=2; i<=n; ++i)
		put(i);
	for(int i=1; i<=n-1; ++i) {
		int x=get();
		ans+=dis[x];
		for(int j=last[x]; j; j=e[j].zhi) {
			int y=e[j].next;
			int c=e[j].c;
			if(c<dis[y]) {
				dis[y]=c;
				change(y);
			}
		}
	}
	cout<<ans;
	return 0;
}

```
希望大家能理解.

(๑•̀ㅂ•́)و✧,点个顶呗



---

## 作者：Waylish (赞：5)

## 题目描述
如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz
## 输入格式：
第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N<=5000，M<=200000）
接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi
## 输出格式：
输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz
## 输入样例
4 5

1 2 2

1 3 2

1 4 3

2 3 4

3 4 3
## 输出样例
7
## 分析
最小生成树(Minimum Cost Spanning Tree)

首先，最小生成树是一副连通加权无向图中一棵权值最小的生成树。

主要可以使用Prim和Kruskal算法实现，对于稀疏图来说，用Kruskal写最小生成树效率更好，加上并查集，可对其进行优化。
一般来说最小生成树一般有两种算法

即**Prim**与**Kruskal**

Kruskal算法（并查集实现）
在使用Kruskal实现最小生成树之前，先来看下并查集需要注意的两点：
1. 针对树可能会退化为链表的解决方案是，每次合并树时，总是将矮的树挂到高的树下，这种方式称为按秩合并。

2. 为了得到的树将更加扁平，加速以后直接或者间接引用节点的速度，Find时改变每一个节点的引用到根节点，这叫路径压缩

Kruskal算法的步骤包括：
1. 对所有权值进行从小到大排序（这里对边排序时还需要记录边的索引，这样以边的权值排完序后只改变了权值的索引位置）
2. 然后每次选取最小的权值，如果和已有点集构成环则跳过，否则加到该点集中。最终有所有的点集构成的树就是最佳的。
# Kruskal AC代码
```cpp
#include<bits/stdc++.h>
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;//奇奇怪怪的读入优化可以大幅提升读入速度，但容易出锅不推荐使用QWQ
using namespace std;
struct ss{
    int u;
    int v;
    int weight;
    int next;
};
ss s1[501010];
int cnt=0,ans=0,tot=0,a,b,c,n,m;
int head[501010],f[501001];
bool vis[501010];
int num[501010];
inline int find(int x){return x==f[x]?x:f[x]=find(f[x]);}//并查集
inline void unionn(int x,int y){f[y]=x;}
template <typename T> inline void read(T &x)
{
    x=0;int f=1;char c=getchar();
    for(;c>'9'||c<'0';c=getchar())if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())x=(x<<1)+(x<<3)+(c^48);
    x*=f;
}
template <typename T> inline void print(T x)
{
    if(x<0) putchar('-'),x=-x;
    if(x>9) print(x/10);
    putchar(x%10+48);
}
inline void abb(int x,int y,int z)
{
    cnt++;
    s1[cnt].u=x;
    s1[cnt].v=y;
    s1[cnt].weight=z;
    s1[cnt].next=head[x];
    head[x]=cnt;
}
inline bool cmp(ss x,ss y)
{
    return x.weight<y.weight;
}
int main()
{
    read(n),read(m);
    for(register int i=1;i<=m;i++)
    {
        read(a),read(b),read(c);
        abb(a,b,c),abb(b,a,c);
    }
    for(register int i=1;i<=n;i++)
        f[i]=i;
    stable_sort(s1+1,s1+1+cnt,cmp);//快拍一波
    for(register int i=1;i<=cnt;i++)
    {
        int r1=find(s1[i].u);
        int r2=find(s1[i].v);
        if(find(r1)!=find(r2))//如果两数不在同一个集合中，合并他们
        {
            unionn(r1,r2);
            ans++;
            tot+=s1[i].weight;
        }
        if(ans==n-1)
            break;
    }
    print(tot);//老实说数据并不存在输出'orz'的情况所以直接输出
    return 0;
}
```
Prim算法（使用visited数组实现）
Prim算法求最小生成树的时候和边数无关，和顶点树有关，所以适合求解稠密网的最小生成树。
Prim算法的步骤包括：
1. 将一个图分为两部分，一部分归为点集U，一部分归为点集V，U的初始集合为{V1}，V的初始集合为{ALL-V1}。
2. 针对U开始找U中各节点的所有关联的边的权值最小的那个，然后将关联的节点Vi加入到U中，并且从V中删除（注意不能形成环）。
3. 递归执行步骤2，直到V中的集合为空。
4. U中所有节点构成的树就是最小生成树。
# Prim AC 代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<bitset>
#include<cmath>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
template <typename T> inline void read(T &x)
{
	x=0;int f=1;char c=getchar();
	for(;c>'9'||c<'0';c=getchar()) if(c=='-') f=-1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	x*=f;
}
template <typename T> inline void print(T x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+48);
}
struct ss{
	int v;
	int w;
	int next;
};
ss s1[501010];
int head[501010],cnt=0;
int n,m,tot=0;
int DJ[501010];
bool u[501010];
inline void abb(int x,int y,int z)
{
	cnt++;
	s1[cnt].v=y;
	s1[cnt].w=z;
	s1[cnt].next=head[x];
	head[x]=cnt;
}
int main()
{
	
	memset(DJ,0x7f,sizeof(DJ));
	read(n),read(m);
	for(register int i=1;i<=m;i++)
	{
		int a,b,c;
		read(a),read(b),read(c);
		abb(a,b,c),abb(b,a,c);
	}
	DJ[1]=0;
	for(register int i=1;i<=n;i++)
	{
		int k=0;
		for(register int j=1;j<=n;j++)
			if(!u[j]&&DJ[j]<DJ[k])
				k=j;
		u[k]=true,tot+=DJ[k];
		for(register int j=head[k];j;j=s1[j].next)
			if(!u[s1[j].v]&&s1[j].w<DJ[s1[j].v])
				DJ[s1[j].v]=s1[j].w;
	}
	print(tot);
	return 0;
}
```
准确来说**Prim**与**Dijkstra**算法原理相似
### **那么既然Dijkstra**可以开堆优化Prim也可以用吗OvO
确实可以
## 可以将时间复杂度从O(n*n)优化到O(n*logn)
~~虽然对于本题没有太大用（雾）~~

# Prim_堆优化AC代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdio>
#include<bitset>
#include<cmath>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
template <typename T> inline void read(T &x)
{
	x=0;int f=1;char c=getchar();
	for(;c>'9'||c<'0';c=getchar()) if(c=='-') f=-1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	x*=f;
}
template <typename T> inline void print(T x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) print(x/10);
	putchar(x%10+48);
}
struct ss{
	int v;
	int w;
	int next;
};
ss s1[501010];
int head[501010],cnt=0;
int n,m,tot=0;
int DJ[501010];
bool u[501010];
priority_queue<pair<int ,int> >q;
inline void abb(int x,int y,int z)
{
	cnt++;
	s1[cnt].v=y;
	s1[cnt].w=z;
	s1[cnt].next=head[x];
	head[x]=cnt;
}
int main()
{
	memset(DJ,0x7f,sizeof(DJ));
	read(n),read(m);
	for(register int i=1;i<=m;i++)
	{
		int a,b,c;
		read(a),read(b),read(c);
		abb(a,b,c),abb(b,a,c);
	}
	DJ[1]=0;
	q.push(make_pair(0,1));
	while(q.size())
	{
		int k=q.top().second;
		q.pop();
		if(!u[k])
		{
			u[k]=true;
			tot+=DJ[k];
			for(register int j=head[k];j;j=s1[j].next)
				if(!u[s1[j].v]&&s1[j].w<DJ[s1[j].v])
				{
					DJ[s1[j].v]=s1[j].w;
					q.push(make_pair(-DJ[s1[j].v],s1[j].v));
				}
		}
	}
	print(tot);
	return 0;
}
```
 可以让本题（Prim）从396ms优化到213ms

**最后总结一下**

Kruskal VS Prim
方法上：Kruskal在所有边中不断寻找最小的边，Prim在U和V两个集合之间寻找权值最小的连接，共同点是构造过程都不能形成环。

时间上：Prim适合稠密图，复杂度为O(n * n)，因此通常使用邻接矩阵储存，复杂度为O(e * loge)，而Kruskal多用邻接表，稠密图 Prim > Kruskal，稀疏图 Kruskal > Prim。

空间上： Prim适合点少边多，Kruskal适合边多点少。

---

## 作者：_自动AC机_ (赞：5)

最小生成树无非就是两种写法：

1、**Prim算法**

2、**Kruskal算法**

然后放几个概念性的定义：


------------


**连通图：**在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。

**强连通图：**在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。

**连通网：**在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。

**生成树：**一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。

**最小生成树：**在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 


------------

###### （由于篇幅限制，所以我就只讲Kruskal算法了）


------------

Kruskal算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 
1. 把图中的所有边按代价从小到大排序； 
2. 把图中的n个顶点看成独立的n棵树组成的森林； 
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。



------------


然后接下来是代码：



------------


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int f[2000002],n,x,pp,qq,xian,bian,ans,m;
struct node {		//结构体不多说
	int u,v,w;
} p[2000002];
bool cmp(node a,node b) {return a.w<b.w;}   //比较函数（sort）
int find(int x) {
	if(f[x]==0)return x;			//并查集模板
	else return f[x]=find(f[x]);
}
int main() {
	scanf("%d %d",&m,&n);
	for(int i=1; i<=n; i++) scanf("%d %d %d",&pp,&qq,&x),p[xian].u=pp,p[xian].v=qq,p[xian++].w=x;
	sort(p,p+xian,cmp);			//直接进行排序
	for(int i=0; i<xian; i++) {
		int u=p[i].u,v=p[i].v,w=p[i].w,t1=find(p[i].u),t2=find(p[i].v);
		if(t1!=t2)ans+=w,f[t1]=t2,bian++;
        //判断是否需要进行合并
		if(bian==n-1)break;
	}
	printf("%d",ans);
}
```
------------


---

## 作者：御·Dragon (赞：5)

昨天： __[图论-最短路<Dijkstra,Floyd>](https://www.luogu.org/blog/37682/tu-lun-zui-xiao-sheng-cheng-shu-dijkstrafloyd)__

以上是昨天的Blog，有需要者请先阅读完以上再阅读今天的Blog。

可能今天的有点乱，好好理理，认真看完相信你会懂得

然而，文中提到的所有的算法在本人Blog中都会后期有讲解。~~推荐Blog~~

------------

分割线

------------

# 第三天

引子：昨天我们~~简单~~讲了讲最小生成树<Dijkstra,Floyd>算法，今天的课程就开始啦！

__今天我们要讲的是：最小生成树__

## Top1：最小生成树的概念

最小生成树，听起来好像是树呀，为什么会是图论呢？其实，处理最小生成树问题前给出的东西，就是一个图，只不过进行操作后要求变成一个最小生成树罢了。

__那什么是最小生成树呢？__

我们把这个词语拆开来看。

__树__ ，我们都好理解，父亲儿砸祖先啥的~~如果不知道的话......先百度完树再来看吧~~ ，那么我们根据树的特性可以得出一个结论：

```
最小生成树是没有环的
```
__生成树__ ，就是一个点到另一个点的路径是 __唯一的__ ，（可以通过树的无环性质证明），也就是 __一个用N-1条边连接的树，且所有点到其他点的路径唯一__

__最小__ 代表最终生成树的边权和最小（不知道什么是边权的到博主的Blog里面去看吧）。

------------


> 这里就有一个问题了：为什么会是N-1条边呢，而不是N-2或者N+1条边？

  既然要把N个点用最少数量的边（这里不是上面“最小”的定义）将所有点连接起来，（忽略边权）上过小学的都知道，将两个点连起来是要一条边，三个点要两条边，哪里见过三个点用一条边连起来的？用N条边或N+1条边（即上述例子的三条边或四条边），自然就会浪费边了。

------------

  
  ### 主要还是靠自己动手画图思考。
  
## Top2：算法-Kruskal

概念我们讲完了，进入正题。

其实最小生成树还有个算法叫做Prim，Prim算法和Kruskal算法在于，一个在稀疏图中更快，一个在稠密图中更快。然而，Kruskal在比赛中会更好用。

> 那讲了这么多，Kruskal到底怎么用呢？

我们都知道了数没有环，那么只需要每次取权值最小的边，只要加入这条边之后不行成环，就可以。

有点像贪心，但是要判断有没有环。

> 怎么判断有环没环呢？

——并查集

所以代码就很简答啦！

```
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 5000 + 10;

struct Line{
	int x, y;
	int dis;
	bool operator < (const Line& next) const {
        return dis > next.dis;
    }
};
priority_queue<Line> line;
int n, m, now;
int fa[MAXN];
int ans;

inline int read(){
    int f = 1, x = 0;
    char c = getchar();

    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }

    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }

    return f * x;
}

int find(int x){
	if(fa[x] == x)return x;
	return fa[x] = find(fa[x]);
}

int main(){
	n = read(),m = read(); 
	for(int i = 1;i <= m; i++){
		int x,y,z;
		x = read(),y = read(),z = read();
		Line tot = {x,y,z};
		line.push(tot);
	}
	
	for(int i = 1;i <= n; i++){
		fa[i] = i;
	}
	
	while(!line.empty()){
		Line tot = line.top();
		line.pop();
		int nx = tot.x, ny = tot.y;
		if(find(nx) == find(ny)){
			continue;
		} 
		fa[find(nx)] = find(ny);
		ans += tot.dis;
		now++;
		if(now == n - 1){
			printf("%d",ans);
			return 0;
		}
	} 
	
	puts("orz");
	return 0;
}
```


---

## 作者：halfrot (赞：4)

用的是kruskal算法，需要用到并查集。

我们可以用以下函数优化速度：

读入优化readint()

输出优化outint()

按秩合并level[]

路径压缩函数getfather()

所以跑的比香港记者还快。

贴代码。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=5005,MAXM=200005;
int readint(){
    int Num;
    char ch;
    while((ch=getchar())<'0'||ch>'9');
    Num=ch-'0';
    while((ch=getchar())>='0'&&ch<='9') Num=Num*10+ch-'0';
    return Num;
}
void outint(int x){
    if(x>=10) outint(x/10);
    putchar(x%10+'0');
}
struct EDGE{
    int a,b,data;
    bool friend operator < (const EDGE &a,const EDGE &b){
        return a.data<b.data;
    }
}edge[MAXM];
int father[MAXN],level[MAXN];
int getfather(int x){
    return father[x]==x?x:father[x]=getfather(father[x]);
}
bool Union(const int &x,const int &y){
    int fx=getfather(x),fy=getfather(y);
    if(fx==fy) return false;
    if(level[fx]>level[fy]) father[fy]=fx;
    else{
        father[fx]=fy;
        if(level[fx]==level[fy]) level[fy]++;
    }
    return true;
}
int main(){
    memset(level,0,sizeof(level));
    int n=readint(),m=readint(),k=0,ans=0;
    for(int i=1;i<=n;i++) father[i]=i;
    for(int i=1;i<=m;i++){
        edge[i].a=readint();
        edge[i].b=readint();
        edge[i].data=readint();
    }
    sort(edge+1,edge+1+m);
    for(int i=1;i<=m;i++){
        if(Union(edge[i].a,edge[i].b)){
            ans+=edge[i].data;
            k++;
        }
        if(k==n-1) break;
    }
    outint(ans);
}

```

---

## 作者：芷陌陌吖 (赞：4)

~~请不要直接复制粘贴程序~~
# 本人习惯使用大括号{}，请谅解(*￣︶￣)
**最小生成树：**
连通图有不同的生成树，其中树的权值（树中所有边的权值和）最小的生成树，称为最小生成树。

**最小生成树解决问题：**
如何用最小的代价，用n-1条边连接n个点的问题。

**求最小生成树的算法：**
kruskal和prim。

（附：[最小生成树百科](https://baike.so.com/doc/6806060-7023006.html)）

## Kruskal 克鲁斯卡尔算法
看到这道题，我们首先想到的算法是：贪心，按权值从小到大排序。

请先看一下下面这个数据：
```
5 5
1 2 1
2 3 2
1 3 3
4 5 4
1 5 5
```
这个数据已经把权值从小到大排序了，暂时不用再考虑。

我们先按贪心的想法来思考：

1、连接1城市和2城市。
![](https://cdn.luogu.com.cn/upload/pic/58514.png)

2、连接2城市和3城市。
![](https://cdn.luogu.com.cn/upload/pic/58515.png)

3、连接1城市和3城市。
![](https://cdn.luogu.com.cn/upload/pic/58517.png)

到这里，就出问题了，完成这3步，1、2、3便会形成一个环，无法生成最小生成树了，所以我们要去判断是否会形成环，用[并查集](https://baike.so.com/doc/6119935-6333082.html)。
（不知道的请先去完成[洛谷P3367【模板】并查集](https://www.luogu.org/problemnew/show/P3367)。）

先附上并查集代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<algorithm>
#include<sstream>
using namespace std;
int n,m,z,x,y,father[10001],p,q;
int find(int x)
{
	if (father[x]==x)
	{
		return x;
	}
	else
	{
		father[x]=find(father[x]);
		return father[x];
	}
}
void join(int x,int y)
{
	p=find(x);q=find(y);
	if (p!=q)
	{
		father[p]=q;
	}
}
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		father[i]=i;
	}
	for (int i=1;i<=m;i++)
	{
		cin>>z>>x>>y;
		if (z==1)
		{
			join(x,y);
		}
		else
		{
			if (find(x)==find(y))
			{
				cout<<"Y"<<endl;
			}
			else
			{
				cout<<"N"<<endl;
			}
		}
	}
	return 0;
}
```
在最小生成树中，我们需要用到并查集中的find和join。

**思路：**
求最短，自然考虑到贪心，首先选择最短的边，然后次短……重复选择权值较小的边，直到选出了n-1条边，使n个点连通。

**注意：**
在选择的过程中必须排除掉会构成回路的边。

**方案：**
排序+贪心+并查集

**算法流程：**

1、将数据按权值排序，我们在离散的顶点中慢慢增加边，构造并查集father[n]。

2、选择权值最小的边（x1，y1），增加到图中。这条边的两个端点（x1，y1）被选中到最小生成树中，两个顶点彼此连通了，在并查集中合并（x1,y1）。

3、选择权值次小的边，首先判断这条边的增加是否构成回路，是否在同一集合：否  增加这条边，在并采集中合并（xi，yi）；是  跳过这条边。

4、反复执行步骤3，直到选出n-1条边将n个点连通。

**代码：**
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<cmath>
#include<ctime>
#include<iomanip>
#include<algorithm>
#include<sstream>
using namespace std;
int n,m,father[5001],p,q,h=0,ans=0,cn;               //father[i]是城市i的boss 
struct student1
{
	int f,t,c;
}a[200001];                                    //用a记录两座城市建公路的费用 
bool cmp1(student1 a,student1 b)
{
	return a.c<b.c;
}
int find(int x)                              //查找城市x的boss 
{
	if (father[x]==x)
	{
		return x;
	}
	else
	{
		father[x]=find(father[x]);
		return father[x];
	}
}
void join(int x,int y)                     //把城市x和城市y合并 
{
	p=find(x);q=find(y);
	if (p!=q)
	{
		father[p]=q;
	}
}
int main()
{
	cin>>n>>m;
	cn=n;                         //储存n的值 
	for (int i=1;i<=n;i++)
	{
		father[i]=i;                //把城市i的father设为自己 
	}
	for (int i=1;i<=m;i++)
	{
		cin>>a[i].f>>a[i].t>>a[i].c;
	}
	sort(a+1,a+m+1,cmp1);                   //按权值从小到大排序 
	n--;
	while (n>0)
	{
		h++;
		if (h>m)                    //无法连通 
		{
			cout<<"orz";
			return 0;
		}
		if (find(a[h].f)==find(a[h].t))               //如果两个城市已经连通，不能再连接，否则会变成环 
		{
			continue;
		}
		else
		{
			join(a[h].f,a[h].t);                     //连通两个城市 
			n--;
			ans+=a[h].c;                             //计算答案 
		}
	}
	cout<<ans;
	return 0;
}
```
## Prim 普林姆算法
寻找图G的最小生成树，G=（V，E），最小生成树为T，T={U，TE)

**思路:**
最小生成树中,必须选到每个顶点,每个顶点必须有一条边与其相连，固定顶点看它的邻接点中那些点没有访问且边权最短。

**注意:**
标识已经进入最小生成树的顶点，如果一条边没有选择过,但其端点都在U中，则这条边的加入将构成回路，应抛弃，

**难点:**
如何找出下一个应添加到生成树的边?

——类似dijkstra的技巧，开设数组dis[i]，记录生成树到项点vi的最短距离。

——在dis数组中找最小值，可以借助最小堆优化。O(N^2)-O(logM)。

**算法流程:**

1、U，TE为空,定义book数组标识顶点状态，dis数组记录生成树到各顶点的距离。

2、从V中任意选一个顶点V1加入生成树中，U={v1}，用一维数组book来标记那些顶点已经加入了生成树，book[1]=1。

3、初始化dis,若v1存在邻接点ⅵ,则dis[i]=e[1][i]，其余为正无穷。

4、在dis数组中选择离生成树最近的顶点vj，加入到生成树中(dis数组中的最小值)，book[j]=1，考察vj的邻接点，更新dis数组，如果dis[k]>e[j][k] dis[k]=e[j][k]。

本题的讲解就到这里，喜欢就去点赞哟！有问题请在讨论区提问。谢谢大家！(〃'▽'〃)

---

## 作者：CaCl2 (赞：3)

发现题解里没有Prim＋线段树优化，于是来写一发

既然dijkstra可以用线段树优化，prim为什么不可以呢qwq

~~(其实是我不会用STL堆，手写堆又忘了)~~

思路其它题解的大佬们已经讲得很明白了

优化就是在找到根节点距离最小的点时用线段树维护每个点到根节点的距离

时间复杂度$O(nlogn)$

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5005,M = 200005,inf = 2147483647;
struct EE{
    int to,nxt,dis;
}edge[M*2] = {0};
int cnt = 0,h[N] = {0};
void ins(int x,int y,int z){
    edge[++cnt].to = y;
    edge[cnt].nxt = h[x];
    edge[cnt].dis = z;
    h[x] = cnt;
}
int n,m;
int dis[N];
long long ans = 0;
bool used[N] = {0};
//线段树
struct Node{
    int mi,c;
    //mi存储最小值，c存储最小值所在位置
}tr[N*4];
void update(int nw,int l,int r,int x,int d){
    if(l==r){
        tr[nw].mi = d;
        tr[nw].c = l;
        return;
    }
    int mid = (l+r)/2;
    if(x<=mid) update(nw*2,l,mid,x,d);
    else update(nw*2+1,mid+1,r,x,d);
    if(tr[nw*2].mi>tr[nw*2+1].mi) tr[nw].mi = tr[nw*2+1].mi,tr[nw].c = tr[nw*2+1].c;
    else tr[nw].mi = tr[nw*2].mi,tr[nw].c = tr[nw*2].c;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i = 1;i<=m;i++){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        ins(x,y,z);
        ins(y,x,z);
    }
    memset(dis,0x3f,sizeof(dis));
    memset(tr,0x3f,sizeof(tr));
    dis[1] = 0;
    update(1,1,n,1,0);
    //Prim
    for(int p = 1;p<=n;p++){
        int u = tr[1].c; // 整棵树最小值所在位置
        update(1,1,n,u,inf); // 把这个位置的值设为inf，相当于删除这个位置
        used[u] = 1;
        for(int i = h[u];i;i = edge[i].nxt){
            int v = edge[i].to;
            if(!used[v]){
                if(dis[v]>edge[i].dis){
                    dis[v] = edge[i].dis;
                    update(1,1,n,v,dis[v]);
                }
            }
        }
    }
    for(int i = 1;i<=n;i++) ans += dis[i];
    printf("%lld",ans);
    return 0;
}
```
评测记录

![](https://cdn.luogu.com.cn/upload/image_hosting/z5e9r94w.png)

祝大家CSP 2019 RP++

---

## 作者：1jia1 (赞：3)

经典的最小生成树（废话）。

Prim算法，简单好用。

核心思路：Prim算法。

```cpp
-#include <iostream>-
-#define maxn 25025048;-
-using namespace std;-
-int n,m,a[5001][5001]={0},dis[100001]={0},f[100001]={0};-
-int main()-
-{-
-    cin>>n>>m;-
-    for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)a[i][j]=maxn;-
-    for(int i=1,u,v,d;i<=m;i++)-
-    {-
-        cin>>u>>v>>d;-
-        if(d<a[u][v])a[u][v]=d,a[v][u]=d;---因为有重边，所以读入时选择最小的边
-    }-
-    for(int i=0;i<=n;i++)dis[i]=maxn; ---赋最大值
-    for(int i=1;i<=n;i++)f[i]=1;---把所有点赋值为蓝点
-    dis[1]=0;---第一个点赋值为白点
-    for(int i=1;i<=n;i++)-
-    {-
-        int k=0,o=0;-
-        for(int j=1;j<=n;j++)if(f[j]==1&&(dis[j]<dis[k]))k=j;---找出最小的蓝点
-        f[k]=0;---将它标记为白点
-        for(int j=1;j<=n;j++)-
-        {-
-            if(f[j]==1&&(a[k][j]<dis[j]))dis[j]=a[k][j],o=j;---修改与k相连的所有蓝点
-        }-
-    }-
-    int s=0;---累加答案
-    for(int i=1;i<=n;i++)s+=dis[i];---加
-    cout<<s;---输出
-    return 0;-
-}-
不管你们用什么，反正我是用Prim。
```

---

## 作者：mulberror (赞：3)

**既然没有人写kruskal的堆优化，那么我就来贡献一篇**

----
## 最小生成树
最小代价树(Minimum-cost Spanning Tree):对无向连通图的生成树，各边的权值总和称为生成树的权，权最小的生成树称为最小生成树。

---
## Kruskal
这个是一个求解最小生成树的一个好方法，也是求加权连通图的最小生成树的算法。

----
## 大致思路
![](http://img.my.csdn.net/uploads/201210/31/1351697185_6031.gif)

以边为主导地位，始终选择当前可用（所选的边不能构成回路）的最小权植边。所以Kruskal算法的第一步是给所有的边按照从小到大的顺序排序。接下来从小到大依次考察每一条边（u，v）。

### 具体实现过程如下：

* 设一个有n个顶点的连通网络为G（V,E），最初先构造一个只有n个顶点，没有边的非连通图T={V,空}，图中每个顶点自成一格连通分量。

* 在Ｅ中选择一条具有最小权植的边时，若该边的两个顶点落在不同的连通分量上，则将此边加入到Ｔ中；否则，即这条边的两个顶点落到同一连通分量上，则将此边舍去（此后永不选用这条边），重新选择一条权植最小的边。

* 如此重复下去，直到所有顶点在同一连通分量上为止。

这个算法我觉得有两点可以进行优化。
* 排序部分
* 算出连通分量中

那么又有人要问了，什么是联通分量？

----
## 联通分量
说的通俗一点，就是联通块，可以通过某些边可以到达的一个点集，就叫做联通块（连通分量）。

那么我们一般使用什么方法来求联通块呢？
* bfs
* dfs
* 并查集

前面两种的方法是在是太~~耗时~~（巨）了，所以我们就不讲了，其实就是灌水灌倒底，灌到那里是哪里。

----
## 并查集
并查集，其实就是查找自己的祖先是谁，通过祖先来判断是否是在同一个联通块里面。

### 查找
我们来看一下find也就是查找自己的祖先的函数应该怎么写。
#### 非递归写法
```cpp
int gf(int x) {
	int r=x;
    while (fa[r]!=r) r=fa[x];
}
```
#### 递归写法
```cpp
int gf(int x) {
	if (fa[x]==x) return fa[x];
    else return gf(fa[x]);
}
```
#### 为什么这个玩意是对的？
因为你的最上面的祖先，他的父亲节点是指向自己的，而其他的节点都是指向自己的父亲，也就是不同于自己的节点。

#### 但是这个玩意太慢了，为什么？
我们需要进行路径压缩，也就是没算完一次，就把自己的父亲节点指向自己的祖先，那么这样就可以大大节省时间。

#### 路径压缩
```cpp
int gf(int x) {
	if (fa[x]==x)  return fa[x];
    else return fa[x]=gf(fa[x]);
}
```
这个新加的```fa[x]=gf(fa[x])```就是在做路径压缩，就是在算的时候**顺便**把自己的父亲改掉。~~应该叫叛变（逃）~~


**还是三目运算符看上去好看**
```cpp
int gf(int x) {
	return fa[x]==x?fa[x]:fa[x]=gf(fa[x]);
}
```
### 合并
还有一个函数叫做合并。
合并这个玩意的本质就是让一个联通块的顶上的祖先变成另外一个联通块的祖先的儿子就可以了。
```cpp
void Union(int x,int y) {
	int ance1=gf(x),ance2=gf(y);
    if (ance1!=ance2) fa[ance1]=ance2;
}
```
再详细的可以自己上百度，自行阅读其他大佬的博客。

## **那么以上就是对于算联通块的算法**
总结：可以得到肯定是并查集最快了。

-----
## 关于排序的部分

那么我们就要来讲一下关于排序的部分。

要不就是sort，要不就是归并排序。

但是这个仅仅只是局限于排序的思想内，我们需要更加稳定而且快速地算法。

在说之前我们先把排序的代码贴出来
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxm=4000005;
const int maxn=5005;
struct Ed {
	int u,v,w;
} edge[maxm];
int n,m;
int fa[maxn];
inline int read() {
	int X=0,w=0;
	char ch=0;
	while (!isdigit(ch)) {
		w|=ch=='-';
		ch=getchar();
	}
	while (isdigit(ch)) {
		X=(X<<1)+(X<<3)+(ch^48);
		ch=getchar();
	}
	return w?-X:X;
}
int gf(int x) {//路径压缩
	if (fa[x]==x) return fa[x];
	else return fa[x]=gf(fa[x]);
}
bool cmp(Ed a,Ed b) {
	return a.w<b.w;
}
int main() {
	n=read(),m=read();
	for (int i=1; i<=n; i++) fa[i]=i;
	for (int i=1; i<=m; i++) {
		edge[i].u=read();
		edge[i].v=read();
		edge[i].w=read();
	}
	sort(edge+1,edge+1+m,cmp);//排序，其实可以重载运算符，懒得写
	int ans=0,cnt=0;
	for (int i=1; i<=m; i++) {
		int ance1=gf(edge[i].u),ance2=gf(edge[i].v);
		if (ance1!=ance2) {
			ans+=edge[i].w;
			cnt++;
			fa[ance1]=ance2;
		}
		if (cnt==n-1) break;
	}
	if (cnt<n-1) printf("orz\n");
	printf("%d\n",ans);
	return 0;
}

```
以上每个人都会，那么接下来我就要讲重点了。

我们可以用**优先队列**来优化我们的程序，也就是小根堆。~~我是一个蒟蒻蒟蒻~~

什么意思？就是我们直接读入的时候就把序排好了，优先队列是一个非常牛逼的东西，这个玩意有快速，而且又稳定，不会像快排那样万一来了一个坑点，那么就GG了那种。

**而且更重要的是，优先队列的代码很短，可以节约很多时间**

直接上程序吧，也不想讲太多了，通过程序来领悟
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxm=4000005;
const int maxn=5005;
struct Edge{
	int u,v,w;
	bool operator <(const Edge a) const {return w>a.w;}//重载运算符，这个是为了优先队列排序
}edge[maxm];
priority_queue<Edge>q;//优先队列
int n,m;
int fa[maxn];
inline int read() {//读入优化，不要问我这是怎么写的，自己百度
	int X=0,w=0;char ch=0;
	while (!isdigit(ch)) {w|=ch=='-';ch=getchar();}
	while (isdigit(ch)) {X=(X<<1)+(X<<3)+(ch^48);ch=getchar();}
	return w?-X:X;
}
inline int gf(int x) {return fa[x]==x?fa[x]:fa[x]=gf(fa[x]);}//路径压缩
int main() {
	n=read(),m=read();
	for (int i=1;i<=n;i++) fa[i]=i;
	for (int i=1;i<=m;i++) q.push((Edge){read(),read(),read()});//骚气的读入
	int ans=0,cnt=0;
	while (!q.empty()) {
		Edge kkk=q.top(); q.pop();//直接取出队首就是最小的，是不是很神奇，我解释不了，可以去问开发c++的大佬们。
		int ance1=gf(kkk.u),ance2=gf(kkk.v);//判联通
		if (ance1!=ance2) ans+=kkk.w,cnt++,fa[ance1]=ance2;
		if (cnt==n-1) break;
	}
	if (cnt<n-1) printf("orz\n");
	printf("%d\n",ans);
	return 0;
}

```
总结：其实我觉得时间还是优先队列优化更好一点，而且更加稳定，欢迎大家评论。

---

## 作者：AuroraIris (赞：3)

明显是并查集

如何判断这个图是否联通呢？——克鲁斯卡尔算法

就是找总共的连通块个数

如果连通块个数为1，那么可以说明这是个连通图

不是就输出orz

用一个ans来判断此图是否联通

asn初始值为n表明初始未经合并时时的连通块个数为n

在进行并查集操作时联通两点就对ans-1

表明两个图连通

还有一个coin来记录价值，联通一个就累加c[i]价值

所以还要快排

----------------------------------------------------------------------



```cpp
var n,i,x,r1,r2,m,j,ans,coin:longint;
father,a,b,c:array[0..100000] of longint;
procedure sort(l,r:longint);
var
i,j,x,y:longint;
begin
i:=l;
j:=r;
x:=c[(l+r) div 2];
repeat
while c[i]<x do
inc(i);
while x<c[j] do
dec(j);
if not(i>j) then
begin
y:=a[i];
a[i]:=a[j];
a[j]:=y;
y:=b[i];
b[i]:=b[j];
b[j]:=y;
y:=c[i];
c[i]:=c[j];
c[j]:=y;
inc(i);
dec(j);
end;
until i>j;
if l<j then
sort(l,j);
if i<r then
sort(i,r);
end;
function find(x:longint):longint;
begin
if father[x]<>x then father[x]:=find(father[x]);
find:=father[x];
end;
begin
readln(n,m);
for i:=1 to m do
readln(a[i],b[i],c[i]);
sort(1,m);//按照价值排序
for i:=1 to n do
father[i]:=i;
i:=1;
j:=1;
ans:=n;
for i:=1 to m do//并查集基本操作
begin
r1:=find(a[i]);
r2:=find(b[i]);
if r1<>r2 then
begin
coin:=coin+c[i];//如果两个图未连接，而现在有路，则连接，并累加价值
father[r2]:=r1;
ans:=ans-1;/连通后，图的个数减一
end;
end;
if ans=1 then write(coin)//如果最后只有一个图，那么输价值
           else write('orz');//不然orz
end.

```

---

## 作者：面壁者4号 (赞：2)

# ~~蒟蒻的第一篇能过的题解~~
这是求最小生成树的Kruskal算法
算法主旨就是从当前边集选取一条最小权值的边，如果这条边所连的两个点祖先不同，就把它们两个所属的集合合并（此处用到并查集），进行如上操作直至选到n-1条边

 _ _ _废话不多说，奉上代码_ _ _ 
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,Act[5010],en=0,ans=0;
struct Info{
	int s,e;
	int v;
}edge[200010];//结构体存边
int find(int x){
	if (Act[x]==x) return x;
	return Act[x]=find(Act[x]);
}//找祖宗，认祖宗
bool cmp(const Info &a,const Info &b){
	return a.v<b.v;
}//结构体排序
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);//读入优化
	cin>>n>>m;
	int x,y,V;
	for (int i=1; i<=m; i++){
		cin>>x>>y>>V;
		edge[i].s=x;
		edge[i].e=y;
		edge[i].v=V;
	}
	for (int i=1; i<=n; i++) Act[i]=i;
	sort(edge+1,edge+m+1,cmp);//将边的权值从小到大排序
	for (int i=1; i<=m; i++){
		if (en==n-1) break;
		if (find(edge[i].s)!=find(edge[i].e)) {//祖宗不同
			en++;
			ans+=edge[i].v;
			Act[find(edge[i].s)]=find(edge[i].e);
		}
	}
	if (en==n-1) cout<<ans<<endl;
	else cout<<"orz"<<endl;
	return 0;
}
```


---

## 作者：2014吕泽龙 (赞：2)

考前打板子的时候见到了这道题。

思考一件事情：Prim复杂度是$O(n^2+m)$,堆优化/zkw线段树优化之后是$O((n+m)logn)$,kruskal的复杂度是$O(mlogm)$的，所以前者适合稀疏图，后者适合稠密图，这是大家公认的事实。

然而如果给你一张边数为$10^7$，点数为$10^5$的图，怎么破？

自己yy了一种神奇的方法，用分块优化Prim（估计大佬们早就都想到了>-<）

按节点分块之后，记录每个块的最优节点。

更新的时候，由于一定是某个节点找到了更优的答案，所以可以直接更新那个块的答案。

找答案的时候，暴力找每个块的答案。

做完某个节点之后，暴力重构那个节点所在的块的答案。

注意到更新的时候复杂度是$O(1)$的，找答案/重构块的复杂度是$O(\sqrt n)$的，总复杂度是$O(n\sqrt n + m)$的，可以通过。

贴个代码。

```cpp
#include<bits/stdc++.h>
const int N = 5e3 + 10, M = 4e5 + 10, inf = 1e9;
int ri() {
	char c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
	for(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;
}
bool vis[N]; int D[N], b[N], l[N], r[N], Ans[N], n, m;
int pr[N], to[M], nx[M], w[M], tp;
void add(int u, int v, int W) {to[++tp] = v; nx[tp] = pr[u]; pr[u] = tp; w[tp] = W;}
void adds(int u, int v, int w) {add(u, v, w); add(v, u, w);}
void Up(int &x, int y) {D[x] > D[y] ? x = y : 0;}
void Add(int x, int w) {D[x] = w; Up(Ans[b[x]], x);}
void Del(int x) {
	int nw = b[x]; D[x] = inf; 
	if(x != Ans[nw]) return; Ans[nw] = 0;
	for(int i = l[nw]; i <= r[nw]; ++i)
		Up(Ans[nw], i);
}
int main() {
	n = ri(); m = ri(); int B = sqrt(n); D[0] = inf;
	for(int u, v;m--;) u = ri(), v = ri(), adds(u, v, ri());
	for(int i = 1;i <= n; ++i) {
		b[i] = (i - 1) / B + 1;
		if(!l[b[i]]) l[b[i]] = i;
		r[b[i]] = i; D[i] = inf;
	}
	for(int x = 1;x <= b[n]; ++x) Ans[x] = 0;
	Add(1, 0); int r = 0;
	for(int i = 1;i <= n; ++i) {
		int u = 0;
		for(int x = 1;x <= b[n]; ++x)
			Up(u, Ans[x]);
		vis[u] = true; r += D[u]; Del(u);
		for(int i = pr[u]; i; i = nx[i])
			if(!vis[to[i]] && D[to[i]] > w[i]) 
				Add(to[i], w[i]);
	}
	printf("%d\n", r);
	return 0;
}



```


---

## 作者：Ikaros (赞：2)

个人认为在这里克鲁兹卡尔算法好做一点

1.在图中找到最短边

为此在读入后进行排序

c++用sort就好

2.判断边的两个端点是否联通

1.建立father数组,father[i]表示i的父亲,初始自己为父亲

2.并查集

1.查集（路径优化）递归实现

1函数find(long long i):如果father[i]==i即父结点是自己（没有父结点）

返回i

否则  father[i] = find(father[i]; //树会退化成链表，所以要路径优化

                                 return find(father[i]);

2.并集    (long long a,long long b) father[find(b)] = find(a);  //右并左

3.不连通:并集 总和+=边权




```cpp
#include <bits/stdc++.h>
using namespace std;  //万能头文件
typedef long long ll; 
ll n, m; //点数 边数
ll i, j; //循环变量
ll total;//总和
ll fa[5000];//father[i]为i的父亲
struct node {
    ll a;
    ll b;
    ll size;
}lines[200001];//结构体 边 a,b为联通的顶点 size为边权
bool cmp(node c, node d) { return c.size < d.size; }//快排
int find(ll point) {
    if (fa[point] == point) return point;
    else { fa[point] = find(fa[point]); //防止退化 路径压缩 将当前的点直接连到父结点
            return find(fa[point]); }
```
}查集

void Uninon(ll a, ll b) {

    fa[find(b)] = find(a);

}//并集


```cpp
int main() {
//    freopen("MST.in", "r", stdin);
//    freopen("MST.out", "w", stdout); 洛谷不兴这个
    cin >> n >> m;//点数 边数
    for (i = 1; i <= m; i++) cin >> lines[i].a >> lines[i].b >> lines[i].size;//输入边
    sort(lines + 1, lines + m + 1, cmp);//快排
    for (i = 1; i <= n; i++)
        fa[i] = i;//将父结点置为自己表示是根节点
    for (i = 1; i <= m; i++) {
        if (!(find(lines[i].a) == find(lines[i].b))) {//如果未联通
            Uninon(lines[i].a, lines[i].b);//并集
            total += lines[i].size;//加权值
```
}//核心


```cpp
    }
    cout << total;//输出
    return 0;
}

```

---

## 作者：KKarshilov (赞：2)

那啥，发一发启发式合并……看到这个你应该就知道我是kruskal派，先说明一点，并查集，我几乎没遇见过不路径压缩的题……不压铁tle，但是，在合并方面，也有可优化的地方，对于两个集合，我们将它合并之后，如果再次访问，又要查一遍……所以说啊，如果你是写的递归式并查集，就尽量要减少集合的深度，很好理解，对吧，所以合并时，就可以将深度浅的集合并到更深的集合上，就减少了递归次数……虽然这题没有必要，但还是发一发，上代码：



```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <cstring>
#define ll long long
using namespace std;
inline int read() 
{
    int x=0; char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x;
}
int ans;
struct Node
{
    int u,v; int len;
    Node(int x1=0,int x2=0,int x3=0):u(x1),v(x2),len(x3){};
}Road[200005];
bool cmp(const Node& Road1,const Node& Road2)
{
    return Road1.len<Road2.len;
}
int f[40005];
int Find(int x)
{
    if(f[x]==x)return x;
    else return f[x]=Find(f[x]);
}
int n,m;
int rnk[40005];
void unite(int x,int y) 
{
    x=Find(x); y=Find(y);
    if(x==y) return;
    if(rnk[x]<rnk[y]) f[x]=y;
    else 
    {
        f[y]=x;
        if(rnk[x]==rnk[y]) rnk[x]++;
    }
}
int main()
{
     n=read();m=read();
     for(int i=1;i<=m;i++)
     {
         int u,v;int len;
         scanf("%d%d%d",&u,&v,&len);
         Road[i]=Node(u,v,len);
     }
     sort(Road+1,Road+m+1,cmp);
    int sum=0;
    for(int i=1;i<=n;i++)
        f[i]=i;
     for(int i=1;i<=m;i++)
     {
         int u=Road[i].u;
         int v=Road[i].v;
         int len=Road[i].len;
         if(Find(u)!=Find(v))
         {
             //sum++;
             //ans=max(ans,len);
             unite(u,v);
            ans+=len;
            sum++;
         }
     }
     if(sum<n-1)
         printf("orz\n");
     else
         printf("%d\n",ans);
     return 0;    
 }

```

---

## 作者：dph754132771 (赞：2)

/\*
\* p3366

\* Au:Small\_Ash

\* 裸的最小生成树。。。

\* prim和克鲁斯卡尔任你选

\* 因为楼上的都是克鲁斯卡尔，我就发一份prim的吧

\* 但是要劝各位，还是学一下邻接表再来用prim，因为用邻接矩阵的话，非简单图（即有重边）就会炸（我WA了8次才发现。。。）

\* 大概思路就是每次找一头在已搜索点集的另一头在未搜索点集的最小边，然后加入

\* 由于每次都是找最小边，所以可以用堆来加快运算。。。

\* 上代码：

\*/
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <functional>//优先队列关键库 
#include <queue>//同上 
using namespace std;
struct number{
    int x,i;
    bool operator < (const number &a) const {
        return x>a.x;//最小值优先，因为默认是大根堆的说。。。 
    }
}A,B;//中转站而已 
priority_queue <number> q;//堆 
int map[5005][5005],n,m,a,b,c,ans;
bool v[5005];
int main(){
    memset(v,false,sizeof(v));
    memset(map,-1,sizeof(map));
    scanf("%d%d",&n,&m);
    for (int i=0;i<m;i++){
        scanf("%d%d%d",&a,&b,&c);
        if (map[a][b]==-1||c<map[a][b]) map[a][b]=c;
        if (map[b][a]==-1||c<map[b][a]) map[b][a]=c;
    }
    v[1]=true;
    for (int i=1;i<=n;i++)
        if (map[1][i]!=-1){
            A.x=map[1][i];
            A.i=i;
            q.push(A);
        }
    for (int i=1;i<n;i++){
        if (q.empty()){
            printf("orz");
            return 0;
        }
        B=q.top();
        q.pop();
        while (v[B.i]){
            B=q.top();
            q.pop();
            if (q.empty()){
                printf("orz");
                return 0;
            }
        }
        ans+=B.x;
        v[B.i]=true;
        for (int j=1;j<=n;j++)
        if (map[B.i][j]!=-1&&!v[j]){
            A.x=map[B.i][j];
            A.i=j;
            q.push(A);
        }
    }
    printf("%d",ans);
    return 0;
}

```

---

## 作者：飞翔 (赞：2)

此题必须使用克鲁斯卡尔算法。此算法会使用并查集，所以建议先过掉P3367再做这题。

##数据太弱，导致我这种错误的判断无解的方法都AC了。。。

```pascal
var
  i,n,m,ans,root1,root2:longint;
    elen,eu,ev,father:array[0..200001]of longint;
procedure qsort(l,r:longint);
var
  i,j,temp,mid:longint;
begin
  i:=l; j:=r;
  mid:=elen[(l+r) div 2];
  repeat
    while elen[i]<mid do inc(i);
    while elen[j]>mid do dec(j);
    if i<=j then
    begin
      temp:=elen[i];elen[i]:=elen[j];elen[j]:=temp;
      temp:=eu[i];eu[i]:=eu[j];eu[j]:=temp;
      temp:=ev[i];ev[i]:=ev[j];ev[j]:=temp;
      inc(i);dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;
function getfather(x:longint):longint;
begin
  if father[x]=x then exit(x);
    father[x]:=getfather(father[x]);
    exit(father[x]);
end;
begin
  readln(n,m);
  if m<n-1 then begin write('orz');halt; end;//至少得有n-1条边，否则无法构成连通图
    for i:=1 to m do readln(eu[i],ev[i],elen[i]);
    qsort(1,m);//对边进行排序
    ans:=0;
    for i:=1 to n do father[i]:=i;
        for i:=1 to m do ans:=ans+elen[i];//所有边的权值总和
    for i:=1 to m do begin
      root1:=getfather(eu[i]); root2:=getfather(ev[i]);
        if root1=root2 then ans:=ans-elen[i] else father[root1]:=root2;//合并
    end;
        write(ans);
end.
```

---

## 作者：JasonZRY (赞：2)

这道题其实不难

我在这里介绍最小生成树的两种方法，一种是Kruskal算法，一种是prim算法。

首先，我们先看看下面这个图

![](https://cdn.luogu.com.cn/upload/pic/75015.png)

# 算法1：Kruskal算法

初始时，森林是由单个节点组成的n棵树。然后反复找出森林中连接任意两棵树的所有边中具有最小权值的边（u,v），将其作为安全边，把它添加到正在生长的森林中，直至产生最小生成树为止。 计算最小生成树采用的是贪心策略，即必须保证每次添加的边同时满足下述两个条件：

（1）不能形成回路；

（2）在保证条件1的前提下添加权尽可能小的边，这样的边称之为安全边。

算法如图

![](https://cdn.luogu.com.cn/upload/pic/75019.png)

![](https://cdn.luogu.com.cn/upload/pic/75016.png)

![](https://cdn.luogu.com.cn/upload/pic/75020.png)

代码如下：

```
//以下代码涉及并查集，不懂的童鞋可以先了解一下 
#include<bits/stdc++.h>
using namespace std;
struct edge{
    long long fr,to,len;
}ed[200005];
//用结构体来存储每条边的头、尾和权值 
int n,m,x,y,z,cnt,l,fa[5001];
bool cmp(edge a,edge b){
    return a.len<b.len;
}
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
//并查集函数*1
void merget(int x,int y){
    int fx=find(x),fy=find(y);
    if(fx!=fy)fa[fx]=fy;
}
//并查集函数*2
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)fa[i]=i;                       //初始化 
    for(int i=1;i<=m;i++){
        cin>>x>>y>>z;                                   //读入数据
        ed[i].fr=x;
        ed[i].to=y;
        ed[i].len=z;
    }
    sort(ed+1,ed+m+1,cmp);                              //排序，找到权值小的边 
    for(int i=1;i<=m;i++){
        if(cnt==n-1)break;                              //如果点数枚举完了就跳出循环 
        if(find(ed[i].fr)==find(ed[i].to))continue;     //如果这两点在一个集合内就跳过 
        merget(ed[i].fr,ed[i].to);                      //把这条边的一头一尾合并 
        l+=ed[i].len;                                   //增加长度 
        cnt++;                                          //计数器+1 
    }
    if(cnt==n-1)cout<<l;                                //如果满足条件就输出长度 
    else cout<<"orz";                                   //不然就输出orz
    return 0;
} 
```

# 算法2：prim算法

Prim算法执行过程中，集合A中的边总是只形成单棵树。初始时，A为空。接下来每次添加到A的边都是使树的边尽可能小的边，这个过程一直进行到不存在连接生成树的边为止。 Prim算法过程: 定义集合A表示已加入最小生成树的节点，定义min[]数组表示其它节点到集合A的最短距离。 初始时，A为空，min[]为无穷,min[1]=0;。 接下来每次添加到A的边都是使树的边尽可能小的边，这个过程一直进行到不存在连接生成树的边为止。 算法描述如下： 1.将一个图分为两部分，一部分归为点集A，一部分归为点集V，A的初始集合为{V1}，V的初始集合为{ALL-V1}。

2.针对A开始找A中各节点的所有关联的边的权值最小的那个，然后将关联的节点Vi加入到A中，并且从V中删除（注意不能形成环）。

3.递归执行步骤2，直到V中的集合为空。

4.A中所有节点构成的树就是最小生成树。——由于Prim算法初始化时加入了起点，而步骤2-3每执行一次都会加入一个新的节点，所以只需判断执行n-1次。

![](https://cdn.luogu.com.cn/upload/pic/75018.png)

剩下的这个我就不上代码了，自己看完是能做的。

（若真不会，看P1546
最短网络 Agri-Net）

代码：https://www.luogu.org/paste/71kkrc1h

# 总结：

Kruskal算法每次在森林中的两棵树之间添加安全边，其算法效率取决于边数，因此适用于稀疏图。

Kruskal 时间复杂度 O（ElogE） E为边数

Prim算法每次在单棵树上添安全边，其算法效率取决于节点数，因此适用于稠密图。

Prim 时间复杂度 O（n^2） n为点数，但是加上堆排优化后时间就变成了 O（ElogE）

简单来说，Kruskal是存边的，Prim是存图的

最小生成树的两个性质 （1）切割性质：假定所有边权均不相同。设S为既非空集也非全集的V的子集，边e是满足一个端点在s内，另一个端点不在s内的所有边中权值最小的一个，则图G的所有生成树均包含e。 （2）回路性质：假定所有边权值均不相同。设C是图G中的任意回路，边e是C上权值最大的边，则图G的所有生成树均不含e。

###### 留给最后大家的话：

###### ~~为了让大家更好的抄题解，我已经在程序里布下了防伪标识，这种标识只有蒟蒻才能看见~~

---

## 作者：Lyrics (赞：2)

裸的Kruskal，只是我想把自己掉的坑和大家说一说（MLE大概4~5次，后面才发现是什么原因）

详细见CODE（有解析）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=0,father[5001];
struct fkt{int x;int y;int value;}a[200001];
bool cmp(fkt xx,fkt yy){//首先Kruscal算法的经典思路有点类似贪心，我们需要每次选取最优的边扔到我们的集合里
    //所以我们用到了并查集来作为集合的存放方式，先排序来类似于贪心地选取最小的边
    //肯定最小的边是最优的，∵必然存在N-1条边，不然没意义啊，这题数据还是比较水，没有输出orz的例子，所以我的代码也没有判断orz。。。 
    return xx.value<yy.value;
}
int find_fa(int x){//并查集之找爸爸（简略跳过） 
    if(father[x]!=x) 
        father[x]=find_fa(father[x]);    //我就是在这里翻车的啊QAQ    大家记住
                                        //找爸爸的时候一定要是father[x]=find_fa(father[x])
                                        //找爸爸的时候一定不要father[x]=find_fa(x) ∵这样你的函数等于一直无限循环下去，导致MLE的结局TAT 
    return father[x];
}
void unionn(int x,int y){//并查集之合并（简略跳过） 
    x=find_fa(x);
    y=find_fa(y);
    father[y]=x;
    return;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)    father[i]=i;//并查集之初始化 
    for(int i=1;i<=m;i++)//读入 
        scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].value);
    sort(a+1,a+m+1,cmp);//贪心排序 
    n--;//我们最多只会有N-1条边就可以最小生成树 
    for(int i=1;i<=m;i++){//开始找，Kruskal运用的是找边的方式 
        int xxx=find_fa(a[i].x),yyy=find_fa(a[i].y);//首先判断我这两个点有没有在同一集合内（如果在同一集合内说明这两个点必然存在一条路径可以联通） 
        if(xxx!=yyy){//如果不连通就把它连起来 
            ans+=a[i].value;//记录答案 
            unionn(a[i].x,a[i].y);//合并两个点，说明这两个点已经在同一集合内了 
            n--;//满足一条我们删一次N 
        }
        if(n==0)break;//找到了就退出 
    }
    printf("%d\n",ans);//输出结果 
    return 0;
}

```

---

## 作者：ForwarDer (赞：2)

这题不是明显的稠密图（点少，边多）吗？

为什么不用prim（点贪心）？ 虽然prim的时间复杂度高于kruskal（边贪心），但在这一题，实际运行时间不会慢啊！

我的代码是朴素的prim，可能是用了STL，跑得非常快，在200ms左右。

楼下之所以TLE，可能是数组模拟的图，操作太慢。

思路不必多讲，自行找资料。


附上c++代码：





```cpp
#include <bits/stdc++.h>
#define MAXV 5005
#define INF 0x3fffffff
using namespace std;
struct Node
{
    int v ,w;
    Node(int _v ,int _w) : v(_v) ,w(_w) {}
};
vector<Node> G[MAXV];
int n ,m ,u ,v ,w;
int d[MAXV];
bool vis[MAXV];
int prim();
int main()
{
    scanf("%d%d" ,&n ,&m);
    for(int i=1 ;i<=m ;i++) {
        scanf("%d%d%d" ,&u ,&v ,&w);
        G[u].push_back(Node(v ,w));
        G[v].push_back(Node(u ,w));
    }
    int Ans=prim();
    if(Ans==-1) printf("orz");
    else printf("%d" ,Ans);
    return 0;
}
int prim()
{
    fill(d ,d+MAXV ,INF);
    d[1]=0;
    int ans=0;
    for(int i=1 ;i<=n ;i++) {
        int u=-1 ,minn=INF;
        for(int j=1 ;j<=n ;j++)
            if(!vis[j] && d[j]<minn) {
                u=j;
                minn=d[j];
            }
        if(u==-1)   return -1;
        vis[u]=true;
        ans+=d[u];
        for(int j=0 ;j<G[u].size() ;j++) {
            int v=G[u][j].v;
            if(!vis[v] && G[u][j].w<d[v])
                d[v]=G[u][j].w;
        }
    }
    return ans;
}

```

---

## 作者：Isprime (赞：1)

广告：配合[Blog](https://www.luogu.org/blog/149815/)食用更佳

## 什么是最小生成树？
一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。   ——百度

~~好吧看不懂~~

通俗地讲：最小生成树就是有N个点，N-1条边且边的权值之和最小的图

前面说过，求最小生成树主要用两种算法：Prim和Kruskal。这两种方法各有优势，稠密图中Prim更优，稀疏图中Kruskal更优。Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。

~~众所周知~~，存图有两种方法：邻接矩阵和邻接表，显然邻接表更优，占用空间更少，所以我使用邻接表。

prim算法使用与Dijkstra一样的“蓝白点”思想，蓝点代表处理完的点，白点代表未处理的点

以1为起点，dis[i]表示点i到蓝点的最短距离，从dis值最小的点i开始，更新与点i相连的所有点，再取dis最小的点继续即可

时间复杂度O($n^2$),本题中450ms/5.2MB

代码如下↓
```cpp
#include<cstdio>
#define INF 2147483647
#define MAXN 5001
#define MAXM 200001
using namespace std;
int head[MAXN],dis[MAXN];
bool vis[MAXN];
int edge_sum=0;
int n,m;
struct Edge{
	int next,to,dis;
}edge[MAXM<<1];//邻接表
void addedge(int from,int to,int dis){
	edge[++edge_sum].next=head[from];
	edge[edge_sum].to=to;
	edge[edge_sum].dis=dis;
	head[from]=edge_sum;
}//存图
int prim(){//prim算法
	long long MST=0;
	for(register int i=0;i<=n;i++)
		dis[i]=INF; //dis数组初始化为maxint
	dis[1]=0;//点1到蓝点的距离为0
	for(register int i=1;i<=n;i++){
		int k=0;
		for(register int j=1;j<=n;j++)
			if(!vis[j]&&dis[j]<dis[k]) k=j;//找dis最小的点
		vis[k]=1;//标记为蓝点
		for(register int j=head[k];j;j=edge[j].next){
			if(!vis[edge[j].to]&&edge[j].dis<dis[edge[j].to])
				dis[edge[j].to]=edge[j].dis;
		}
	}//更新dis数组
	for(register int i=1;i<=n;i++)
		if(dis[i]==INF) return -1;//如果不连通返回-1
		else MST+=dis[i];
	return MST;
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		addedge(x,y,z);
		addedge(y,x,z); //无向图，要存两次
	} 
	int MST=prim();
	if(MST==-1) printf("orz\n");
	else printf("%d\n",MST);
	return 0;
}
```
不难发现，在上面的代码中每次都要找dis值最小的点，十分费时

我们可以使用优化——堆，建一个小根堆，每次取出堆顶即可

~~C++ STL大法好~~

priority_queue为优先队列，可以用来建堆

优化后时间缩短至241ms
```cpp
#include<cstdio>
#include<queue>
#define INF 2147483647
#define MAXN 5001
#define MAXM 200001
using namespace std;
int head[MAXN],dis[MAXN];
bool vis[MAXN];
int edge_sum=0;
int n,m,MST;
struct Edge{
	int next,to,dis;
}edge[MAXM<<1];
void addedge(int from,int to,int dis){
	edge[++edge_sum].next=head[from];
	edge[edge_sum].to=to;
	edge[edge_sum].dis=dis;
	head[from]=edge_sum;
}
struct node{
	int u,dis;
	bool operator <(const node& rhs) const {
        return dis>rhs.dis;
    }
};
void prim(){
	priority_queue<node> q;//堆
	for(register int i=0;i<=n;i++)
		dis[i]=INF; 
	dis[1]=0;
	q.push((node{1,0}));
	while(!q.empty()){
		node tmp=q.top();
		q.pop();
		int u=tmp.u,d=tmp.dis;
		if(vis[u]) continue;
		vis[u]=1;
		for(register int j=head[u];j;j=edge[j].next){
			if(!vis[edge[j].to]&&edge[j].dis<dis[edge[j].to]){
				dis[edge[j].to]=edge[j].dis;
				if(!vis[edge[j].to]) q.push((node){edge[j].to,dis[edge[j].to]});
			}	
		}
	}	
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		addedge(x,y,z);
		addedge(y,x,z); 
	} 
	prim();
	bool flag=0;
	for(register int i=1;i<=n;i++){
		if(dis[i]==INF)
			flag=1;
		MST+=dis[i];
	}
	if(!flag) printf("%d\n",MST);
	else printf("orz\n");
	return 0;
}
```

接下来介绍另一种算法：Kruskal

Kruskal使用贪心的思想，将边按照权值排序，每次取权值最小的边，使用并查集来判断是否存在环，不存在环就将这条边的起点和终点连接，tot统计连接了几条边，当tot=n-1的时候，循环结束

245ms/2.8MB
```cpp
#include<cstdio>
#include<algorithm>
#define INF 2147483647
#define MAXN 5001
#define MAXM 200001
int head[MAXN],fa[MAXN];
int edge_sum=0;
int n,m,MST;
struct Edge{
	int from,to,dis;
}edge[MAXM<<1];
bool cmp(Edge a,Edge b){
	return a.dis<b.dis;
}
int find(int x){
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);
}
void kruskal(){//kruskal求最小生成树
	int tot=0;
	for(register int i=1;i<=m;i++){
		int u=find(edge[i].from),v=find(edge[i].to);
		if(u==v) continue;
		MST+=edge[i].dis;
		fa[u]=v;
		tot++;
		if(tot==n-1) return ;
	}
}
using namespace std;
int main(){
	scanf("%d %d",&n,&m);
	for(register int i=1;i<=n;i++) fa[i]=i;
	for(register int i=1;i<=m;i++){
		scanf("%d %d %d",&edge[i].from,&edge[i].to,&edge[i].dis);
	} 
	sort(edge+1,edge+1+m,cmp);//将边按照权值排序
	kruskal();
	printf("%d\n",MST);
	return 0;
} 
```


---

## 作者：Azuree (赞：1)

>隔了几个月，又开始写博客了qwq

# kruskal
### 时间复杂度为O(nlogn)
### 它的算法思路是这样的：
我们根据边的权值将所有边排序，然后枚举每条边，用并查集去查询这条边的两个端点是否在同一集合内，若在同一集合内，则删掉这条边，若不在同一结合则加入这条边，并将这两个端点所在的集合合并。  
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

int n,m,q[6000];

struct lalala{
    int x,y,z,save;
}a[210000];

int mysort(lalala a,lalala b)
{
    return a.z < b.z;
}

int work(int x,int y)
{
    while(q[q[x]] != q[x]) q[x] = q[q[x]];
    while(q[q[y]] != q[y]) q[y] = q[q[y]];
    if(q[x] == q[y]) return 1;
    else
    {
        q[q[y]] = q[x];
        return 0;
    }
}

int main()
{
    long long ans = 0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) q[i]=i;
    for(int i=1; i<=m; i++) 
    {
        cin>>a[i].x>>a[i].y>>a[i].z;
        ans += a[i].z;
    }
    sort(a+1,a+m+1,mysort);
    for(int i=1;i<=m;i++)
    {
        if(!work(a[i].x,a[i].y)) ans -= a[i].z;
    }
    cout << ans;
    return 0;
}
```
# prim
### 时间复杂度O(n2)
~~跑得慢，代码长，没特殊功能，真不知道为什么要学它qwq……~~
prim的思想和某最短路算法的思路是类似的，我们将更新过的点标为白色，没有更新过的标为蓝色，然后枚举每一个蓝点（按minn值从小到大更新，这里貌似可以用堆优化，然而我比较懒qwq）并更新为白点，并用它去更新其他的蓝点（这里不用把被更新的点标为白色，不然它们就没法更新其他点，也没法被其他的点更新了）。最后将每个点的minn值加起来就好啦。
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#define ll long long
#define INF 2147483647

using namespace std;

struct node{
    int k,dis;
    bool operator < ( const node &x )const{return x.dis < dis;}
};

priority_queue<node> que;

long long n,m,s,d[1000005],cnt,D[1000005],v[1000005]; 

struct Edge{
    int to,next,x;
}edge[2000005];

void add(int x,int y,int a)
{
    edge[++cnt].to = y;
    edge[cnt].x = a;
    edge[cnt].next = d[x];  
    d[x] = cnt;
}

int main()
{
    int x,y,a;
    scanf("%lld%lld%lld",&n,&m,&s);
    for(register int i = 1; i <= m; i++)
    {
        scanf("%d%d%d",&x,&y,&a);
        add(x,y,a);
    }
    que.push((node){s,0});
    for(register int i = 1; i <= n; i++) D[i] = INF;
    D[s] = 0;
    while(!que.empty())
    {
        node u = que.top();
        que.pop();
        if(v[u.k]) continue;
        v[u.k] = 1;
        for(register int i = d[u.k]; i; i = edge[i].next)
        {
            if(D[edge[i].to] > D[u.k] + edge[i].x)
            {
                D[edge[i].to] = edge[i].x + D[u.k];
                if(!v[edge[i].to]) que.push((node){edge[i].to,D[edge[i].to]});
            }
        }
    }
    for(register int i = 1; i <= n; i++) printf("%d ",D[i]);
    printf("\n");
    return 0;
}
```
## prim的堆优化
既然prim和某最短路算法的思路是相似的，那么ta和某最短路算法一样也可以用堆优化，可以把时间复杂度从O(n2)降到O(nlongn)  
~~依然是跑得慢，代码长，没特殊功能qwq……~~  
附一下代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

struct edge{
	int x,y,z;
}a[500005];

struct EDGE{
	int next,to,x,save;
}e[500005];

struct node{
	int k,dis;
	bool operator < (const node & x) const {return x.dis < dis;}
}now;

priority_queue <node> que;

int cnt,d[100005];

void add(int x,int y,int a)
{
    e[++cnt].to = y;
    e[cnt].x = a;
    e[cnt].next = d[x];  
    d[x] = cnt;
}

int n,m,q,x,y,z,ans,minn[100005],vis[100005];

int mysort(edge a1, edge a2)
{
	if(a1.x != a2.x) return a1.x < a2.x;
	if(a1.y != a2.y) return a1.y < a2.y;
	return a1.z < a2.z;
}

int main()
{
	n = read();
	m = read();
	for(re int i = 1; i <= m; i++)
	{
		a[i].x = read(); a[i].y = read(); a[i].z = read();
	}
	sort(a + 1, a + m + 1, mysort);
	for(re int i = 1; i <= m; i++)
		if(a[i].x != a[i - 1].x || a[i].y != a[i - 1].y)
		{
			add(a[i].x, a[i].y, a[i].z);
			add(a[i].y, a[i].x, a[i].z);
		}
	for(re int i = 1; i <= n; i++) minn[i] = INF;
	que.push((node){1,0}); 
	while(!que.empty())
	{
		now = que.top();
		que.pop();
		vis[now.k] = 1;
		for(re int i = d[now.k]; i; i = e[i].next)
			if(!vis[e[i].to] && e[i].x < minn[e[i].to])
			{
				minn[e[i].to] = e[i].x;
				que.push((node){e[i].to,minn[e[i].to]});
			}
	}
	for(re int i = 2; i <= n; i++) ans = ans + minn[i];
	printf("%d\n",ans);
    return 0;
}
```

推荐例题：[【模板】最小生成树](https://www.luogu.org/problemnew/show/P3366)

---

## 作者：Crazily (赞：1)

我的博客里也有讲解哦：

[传送门](https://www.cnblogs.com/crazily/p/10122044.html)

Kruskal其实是一个贪心算法（较容易理解）O(∩_∩)O~~

区别一下prim：

Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。

当然我们知道Kruskal是个容易理解的方法

所以这里仅仅讲一下Kruskal（蒟蒻只能讲Kruskal）

------------------------------------------------------------------------------------以下是个人见解（可能是片面的）

我们要找一个加权最小的树

所以我们要边们尽可能的小

所以贪心算法的本质就显现出来了

我们只要先排序，以从小到大的顺序开始加权

当我们发现一条边的两端两个点已经被连起时

这条线其实就是无用的是浪费

所以跳过ta继续

楼下的DALAO图写的很清楚

那么我们应该如何搜索是否链接呢？

并查集就可以解决了！

如果两点具有相同祖先那么就是已经连接的点了！

具体见代码哦。

[不懂并查集的小伙伴戳这里]( https://www.cnblogs.com/crazily/p/10121934.html)

还有最后一个问题未解决：end

我们知道一个最小生成树若有n个点那么他就会有n-1条边

所以当我们搜齐n-1条边后就建树完毕了

上代码：

```
#include<bits/stdc++.h>
using namespace std;
long long ans;
int n,m;
int f[200005];
int find(int k){
    if(f[k]==k){
        return k;
    }
    return f[k]=find(f[k]);
}
struct node{
    int x,y;
    int z;//sum
}tree[200005];
bool cmpp(node x,node y){
    return x.z<y.z;
}
void Kruskal(int i,int a){
    if(a==n-1){
        return;
    }
    if(find(tree[i].x)==find(tree[i].y)){
        Kruskal(i+1,a);
        return;
    } 
    ans+=tree[i].z;
    f[find(tree[i].x)]=f[tree[i].y];
    Kruskal(i+1,a+1);
}
int main(){
    cin>>n>>m;
    if(n>m) {cout<<"orz"<<endl;return 0;}
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&tree[i].x,&tree[i].y,&tree[i].z);
    }
    sort(tree+1,tree+1+m,cmpp);
    for(int i=1;i<=m;++i){
        f[i]=i;
    }
    Kruskal(1,0);
    cout<<ans<<endl;
}

/*
样例输入： 
5 18
2 4 276
3 3 435
3 4 608
2 4 860
1 2 318
1 3 547
5 4 419
2 5 98
1 5 460
5 3 399
3 5 240
3 2 733
3 3 903
4 2 909
5 2 206
3 4 810
2 1 115
2 3 419
样例输出： 
729
*/ 
```

//（悄咪咪）其实题目里那个orz情况在评分数据里并没有。。。。。

---

## 作者：Aiden邱秋秋 (赞：1)

 _**Kruscal什么的真的是太好了**_ 
 - 本蒟蒻刚一上手表示一脸懵逼，后来请教大佬，发现核心步骤就是并查集嘛，瞬间开心了许多呢
 - 首先并查集这种东西的模板很常见，本蒟蒻总结，并查集的步骤分为**查找 判断 合并 初始化（主程序中）**
 ```
int  find(int x)//查找 
{
	if(f[x]==x)//f数组存的是x的爸爸，这里是说如果x的爸爸（根节点）是他自己，那就返回他自己的值
	return x;
	else return f[x]=find(f[x]);
    //如果他爸爸不是自己，调用递归，返回继续搜索他的爸爸
}
void unite(int x,int y)//判断是否在一个树，合并 
{
	x=find(x);
	y=find(y);
	if(find(x)!=find(y))
	f[x]=y;//如果不在一个树，将x的爸爸指向y
	return ;
}
int main()
{
	for(int i=1;i<=n;i++)
	{
		f[i]=i;//初始化
	}
```
然后就是带入最小生成树了。本蒟蒻的方法是kruscal,但还有很多其他方法。kruscal就是并查集的贪心策略。主要思路如下
1. 首先要将输入的边权排序，毕竟要最小生成树，从小到大排序。
2. 然后就是并查集模板的套用了，排完序后先搜最小边，然后建立树，再搜索第二小的边，如果他俩不在一个树里，就连接他们
3. 当边比点小一个就建好了最小生成树
```
#include<cstdio>
#include<cstrin>
#include<algorithm>
#include<cmath>
using namespace std;
struct node{
//这里是结构体，本蒟蒻认为这个对于多个信息，像树这种有点有边的，还是比较好用的
	int x;int y;int z;
};
node a[200010];
int zx,zy,f[5010],sum,cnt;
int n,m;//n个结点，m条无向边 
int find(int x)
{
    if(f[x]==x)
    return x;
    else return find(f[x]);
}
bool cmp(node a,node b)//结构体排序需要这个东东
{
	return a.z<b.z;
}
void krusal()//核心代码
{
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		zx=find(a[i].x);
		zy=find(a[i].y);
		if(zx==zy)
		{
			continue;
		}
		sum=a[i].z+sum;//累计最小边
		f[zx]=zy;
		if(++cnt==n-1)
		{
			break;
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		f[i]=i;//并查集初始化
	}
	for(int i=1;i<=m;i++)
	{
				           scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
	}
	krusal();
	if(cnt==n-1)
	{
		printf("%d",sum);
	}
	else printf("orz");
	return 0;
}
```

---

## 作者：arfa (赞：1)


# Prim+heap
库克斯科拉太简单了,还是用Prim吧...

heap+Prim听说很快,其实吧...

---
## Prim
先前我被其他人的题解搞蒙了,Prim难不成就是**找出最短边然后再加?**

那跟库克斯科拉有什么区别?????

然后仔细腐败...发现Prim的真正含义是:
```psacal
1.假如我已经有一个局部的最小生成树,名字叫做A。(一个集合)

2.有一些没有连的边(并且在A旁边(与A连通但是没有计入ans)),叫做B。(一个集合)
3.你会发现,我的A会和B是相连的,边权为mincost[B]。

4.有一些没有连的边(不再A旁边???),叫做C。(一个集合)
5.你会发现,我的A会和C不相连,边权应该为 mincost[C]:=maxlongint;
```
对于A,B,C,我们有什么操作?

```psacal
1.找出一个通向B最短的边,把它连起来(加入A),计入ans。
2.这时,有可能有通到B的更优解!!更新一些mincost[B]。(min)
3.这时,有可能会通到C!! 一些mincost[C]能连通了!! 变为B。
```

哇,神奇。

---

## Heap
大家都知道,普通维护Heap是log(n),而求出最小值,只需要O(1)!

所以我们可以用heap性质来求出A到B的最短边!只需要把mincost加入(当然你想mincost更新了怎么办?凉拌!再加入一次,反正又不会怎样...)

详见代码?

---

## Code
```pascal
// luogu-judger-enable-o2
Uses math;
var
        n,m,ans,tot,num:longint;
        ask:array[1..5010] of shortint;
        mincost,cnt:array[1..5010] of longint;
        heap:array[1..2,1..800010] of longint;
        right,sum,next:array[1..800010] of longint;

procedure down(x:longint);
var
        son:longint;
        t:longint;
begin
        if x*2>num then
                exit;
        son:=x*2;
        if (son+1<=num)and(heap[2,son+1]<=heap[2,son]) then
                inc(son);
        if (heap[2,x]>heap[2,son]) then
        begin
                t:=heap[2,x];
                heap[2,x]:=heap[2,son];
                heap[2,son]:=t;
                t:=heap[1,x];
                heap[1,x]:=heap[1,son];
                heap[1,son]:=t;
        end;
        down(son);
end;

procedure insert(x:longint);
var
        fa,t:longint;
begin
        fa:=x div 2;
        if (fa>0)and(heap[2,fa]>heap[2,x]) then
        begin
                t:=heap[2,fa];
                heap[2,fa]:=heap[2,x];
                heap[2,x]:=t;
                t:=heap[1,fa];
                heap[1,fa]:=heap[1,x];
                heap[1,x]:=t;
                insert(fa);
        end;
end;

procedure add(x,y,sum_:longint);
begin
        inc(tot);
        right[tot]:=y;
        sum[tot]:=sum_;
        next[tot]:=cnt[x];
        cnt[x]:=tot;
end;

procedure start;
var
        i,j:longint;
        srx:array[1..3] of longint;
begin
        read(n,m);
        for i:=1 to n do
        begin
                cnt[i]:=-1;
                ask[i]:=-1;
                mincost[i]:=maxlongint;
        end;

        tot:=0;
        for i:=1 to m do
        begin
                for j:=1 to 3 do
                        read(srx[j]);
                add(srx[1],srx[2],srx[3]);
                add(srx[2],srx[1],srx[3]);
        end;

        mincost[1]:=0;
        ask[1]:=1;
        i:=cnt[1];
        while i<>-1 do
        begin
                mincost[right[i]]:=min(mincost[right[i]],sum[i]);
                inc(num);
                heap[1,num]:=right[i];
                heap[2,num]:=mincost[right[i]];
                insert(num);
                i:=next[i];
        end;
end;

procedure Prim;
var
        i,minway,head,rope:longint;
begin
        rope:=0;
        repeat
                head:=heap[1,1];
                minway:=heap[2,1];
                if ask[head]=-1 then
                begin
                        ask[head]:=1;
                        inc(ans,minway);
                        inc(rope);

                        heap[1,1]:=heap[1,num];
                        heap[2,1]:=heap[2,num];
                        dec(num);
                        down(1);

                        i:=cnt[head];
                        while i<>-1 do
                        begin
                                if sum[i]<mincost[right[i]] then
                                begin
                                        mincost[right[i]]:=sum[i];
                                        inc(num);
                                        heap[1,num]:=right[i];
                                        heap[2,num]:=mincost[right[i]];
                                        insert(num);
                                end;
                                i:=next[i];
                        end;
                end
                else
                begin
                        heap[1,1]:=heap[1,num];
                        heap[2,1]:=heap[2,num];
                        dec(num);
                        down(1);
                end;
        until rope=n-1;
        writeln(ans);
end;

begin
        Start;
        Prim;
end.
```

---

## 作者：chenzijie (赞：1)

这里用克鲁兹卡尔算法

用并查集的思路

找到这个图的总共连通了几个点

若循环结束前连通到了n个点就代表是连通的图

否则不连通

用sum数组存放已经连通了这个点已经连通了几个点

附上代码:



        
```cpp
#include<cstdio>
#include<algorithm>
using namespace std; 
struct note
{
    int start;
    int end;
    int time;    
};
int cmp(const note &a,const note &b)
{ 
    if(a.time<b.time)
        return 1;
    return 0;
}
int f[5001],n,m,k,s,tt,sum[5001];
struct note x[200001];
int getf(int v)
{
    if(f[v]==v)
        return v;
    else
    {
        f[v]=getf(f[v]);
        return f[v];
    }
}
void merge(int v,int u)
{
    int t1,t2;
    t1=getf(v);
    t2=getf(u);
    if(t1!=t2)
    {
        f[t2]=t1;
        sum[t1]=sum[t2]+sum[t1];
        tt=tt+s;
    }
    return;
}
int main()
{
    int i,flag=0;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
        f[i]=i,sum[i]=1;
    for(i=1;i<=m;i++)
        scanf("%d %d %d",&x[i].start,&x[i].end,&x[i].time);
    sort(x+1,x+1+m,cmp);
    for(i=1;i<=m;i++)
    {
        s=x[i].time;
        merge(x[i].start,x[i].end);
        if(sum[getf(x[i].start)]==n)
        {
            flag=1;
            break;
        }
    }
    if(flag==1)
        printf("%d",tt);
    else
        printf("orz");
    return 0;
}

```

---

## 作者：DEVILK (赞：1)

Kruskal是一种用并查集来构造最小生成树的算法


将一个连通块当做一个集合

先将每一条边按照他们的权值有小到大排序，用algorithm里的sort快排就可以啦


一开始每一个点都是孤立的，分属于n个独立的集合，


接下来枚举每一条边，如果这条边连接着两个不同的集合，就把这条边加入最小生成树（MST），如果两个点属于同一个集合就跳过，直到选取了n-1条边为止。


并查集一定要将元素的父节点指来指去地指（路径压缩），一定要路径压缩！！！！！！！！！不然会超时！！


不多说了，上代码


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int fat[5001];
int tot;
struct node{
    int x,y,z;//结构体保存起点x，终点y，以及边权z
}f[200001];
int find(int x)//路径压缩
{
    if(fat[x]!=x) fat[x]=find(fat[x]);
    return fat[x];
}
void unionn(int x,int y)//合并
{
    int x1=find(x),y1=find(y);
    if(x1==y1) return;
    else fat[y1]=x1;
}
bool cmp(node a,node b)
{
    return a.z<b.z;//快排的规则
}
int main()
{
    int m,n;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&f[i].x,&f[i].y,&f[i].z);
    for(int i=1;i<=n;i++) fat[i]=i;//自己叫自己爸爸
    sort(f+1,f+m+1,cmp);//快排
    int k=0;//计数
    for(int i=1;i<=m;i++)
    {
        if(find(f[i].x)!=find(f[i].y))//不在同一集合内
        {
            unionn(f[i].x,f[i].y);
            tot+=f[i].z;//计算权值和
            k++;
        }
    }
    if(k<n-1) printf("orz");//判断是否连通
    else printf("%d",tot);
}
```

---

## 作者：Hydra_ (赞：1)

## 分析 ##

这道题目呢，在入门的时候讲过prim算法。这里对于prim算法进行简单的介绍。prim算法，就是把所有的点划在A集合里面，然后每次选择一个点到B集合（满足AB结点的交叉边保持最小）然后边数达到n-1的时候就成功了。

**克鲁斯卡尔（这个方法优秀很多啊）**

克鲁斯卡尔就是基于并查集的。把每个点都看成一个集合，然后对每条边进行按权值从小到大排序，如果当前边的两个端点不在一个集合里面（查），那就，并他；在一个集合里面就，不要他。（哈哈哈还是我讲的贪心算法的应用）

## 代码 ##


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cc=0,sum=0;
struct edge
{
    int l,r,v;
}a[200200];
int father[6000];
以上是变量说明部分
a数组用来存放所有的边（就是一个边表），l和r是两个端点，v是权值。
father数组用来存放所有结点的父亲（根结点）
cc记录当前已经要了几条边（为n-1条边的时候，我们的最小生成树就做好了）
sum用来记录边权值之和。
void read()
{
    scanf("%d%d",&n,&m);
    int x,y,z;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        a[i].l=x;
        a[i].r=y;
        a[i].v=z;
    }
//读入数据。填边表
    for(int i=1;i<=n;i++)
    father[i]=i;
//对father数组的初始化。
}
读入和初始化
bool mycmp(edge x,edge y)
{
    return x.v<y.v;
}
int getfather(int v)
{
    if(father[v]==v) return v;
//如果一个结点的父亲结点就是自己，那么它就是根结点
    father[v]=getfather(father[v]);
//压缩路径，你懂得，记忆化嘛。
    return father[v];
}
获取根结点
void un(int x,int y)
{
    int fx,fy;
    fx=getfather(x);
    fy=getfather(y);
//获取两个点的根结点
    father[fx]=fy;
//然后一个点的根结点变成另外一个点的根结点的孩子。这样就完成了并集。
}
//并集！！！
bool judge(int x,int y)
{
    int fx,fy;
    fx=getfather(x);
    fy=getfather(y);
    return fx!=fy;
//获取两个元素的根结点，判断是否相等
}
//查点
void work()
{
    for(int i=1;i<=m&&cc<=n-1;i++)
    //cc存储已经拥有的边数。最多n-1条
    if(judge(a[i].l,a[i].r))
    //如果没有在一个结点里面。
    {
        un(a[i].l,a[i].r);
        //并
        cc++;
        //计数
        sum+=a[i].v;
        //累加权值和
    }
}
int main()
{
    read();
    sort(a+1,a+1+m,mycmp);
    //按权值排序
    work();
    printf("%d",sum);
    return 0;
}
```

---

## 作者：御坂御坂 (赞：1)

看了一下其他人Prim堆优化的题解，都用STL，pas党感觉很无奈啊


所以我再发一个Prim+heap （手打的堆）


再说用惯STL可能会忘记模板的。。


Prim+Heap 速度还是很不错的


基本上200ms左右，，我还没用邻接表呢。。


这里采用邻接矩阵方便大家理解


其中

h数组是一个最小堆，，可以吧每次选堆的时间缩短为log m


cur[i]表示顶点i在数组中的位置


其他的就不用多说的吧，都是Prim的基本


不废话，上代码


``` pas
const INF=999999999;//最大值
const MAXN=5000;
const MAXM=200000;
var 
    vis:array[1..MAXN+1] of boolean;
    dis,h,cur:array[1..MAXN+1] of longint;
    g:array[1..MAXN+1,1..MAXN+1] of longint;
    n,m,i,j,sum,count,size,x,y,z:longint;
procedure swap(x,y:longint);//交换堆中两个顶点的位置
var t:longint;
begin
    t:=h[x];
    h[x]:=h[y];
    h[y]:=t;
    t:=cur[h[x]];//同步更新cur
    cur[h[x]]:=cur[h[y]];
    cur[h[y]]:=t;
end;
procedure down(i:longint);//向下调整函数
var t:longint;
    flag:boolean;
begin
    flag:=true;//flag用来标记是否继续要向下调整
    while (i*2<=size)and(flag) do
    begin
    //在自己和左儿子、右儿子中选一个最小的
        t:=i;
        if dis[h[i]]>dis[h[i*2]] then t:=i*2;
        if ((i*2+1)<=size)and(dis[h[t]]>dis[h[i*2+1]]) then t:=i*2+1;
        if t<>i then //如果不是自己，那就交换它们
        begin
            swap(t,i);
            i:=t;//更新i
        end 
        else flag:=false;//否则说明当前父节点是最小的，就不需要调整了
    end;
end;
procedure up(i:longint);//向上调整
var flag:boolean;
begin
    flag:=true;
    if i=1 then exit;//如果是在堆顶，那么就直接退出
    while (i<>1)and(flag) do
    begin
        //判断是否比父节点小
        if dis[h[i]]<dis[h[i div 2]] then 
            swap(i,i div 2)
        else 
            flag:=false;
        i:=i div 2;//更新i
    end;
end;
function top():longint;//取堆顶，也就是dis[i]最小的那个i
var t:longint;
begin
    t:=h[1];//保存堆顶
    cur[t]:=0;
    h[1]:=h[size];//将堆最后一个结点赋到堆顶
    cur[h[1]]:=1;
    size:=size-1;//堆的元素少1
    down(1);//因为堆顶已经改动，为了维护最小堆的特性，必须调整一次
    exit(t);
end;
begin
    readln(n,m);
    //初始化
    for i:=1 to n do
        for j:=1 to n do
            if i=j then g[i][j]:=0
                else g[i][j]:=INF;
    for i:=1 to m do
    begin
        readln(x,y,z);
        if z<g[x][y] then //去重边
        begin
            g[x][y]:=z;
            g[y][x]:=z;
        end;
    end;
    for i:=1 to n do g[i][i]:=0;//去自环
    for i:=1 to n do dis[i]:=g[1][i];//初始化dis数组
    //初始化堆
    size:=n;
    for i:=1 to size do 
    begin
        h[i]:=i;
        cur[i]:=i;
    end;
    for i:=size div 2 downto 1 do down(i);
    top();//先弹出一个堆顶元素，因为此时堆顶是一号顶点
    //Prim 算法核心部分
    fillchar(vis,sizeof(vis),1);
    vis[1]:=false;//将一号顶点加入生成树
    count:=1;sum:=0;
    while (count<n) do
    begin
        i:=top();//根据最小堆的特性，dis[i]最小的那个顶点就在堆顶，所以不必扫描，通过堆来节省时间，避免TLE
        vis[i]:=false;
        inc(count);
        sum:=sum+dis[i];
        //扫描当前顶点i的所有边，并进行松弛
        for j:=1 to n do 
            if (vis[j])and((g[i][j])<dis[j]) then
            begin
                dis[j]:=g[i][j];
                up(cur[j]);//由于dis[j]已经变小了，所以要将它向上调整
            end;
    end;
    if count=n then writeln(sum) else writeln('orz');
    //嗯输出好神奇
end.
```

---

## 作者：包子入侵 (赞：1)

```cpp
#include<cstdio>
#include<algorithm>
#define N (5010) 
#define M (200010)
using namespace std;
//定义结构体存边，x为起点，y为终点，z为值
struct edge{
    int x,y,z;
}a[M];
int fat[N],tot,ans;
bool cmp(edge x,edge y){//用于sort的排序，按值排
    return x.z<y.z;
} 
int ask(int x){//查找是否在同一集合
        if (fat[x]!=x) fat[x]=ask(fat[x]);
    return fat[x];
}
void unite (int x,int y){
    int x1=ask(x),x2=ask(y);
    if (x1==x2) return;
    else fat[x1]=x2;
}
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].z);
    sort(a+1,a+m+1,cmp);//把边按从大到小排
    for (int i=1;i<=n;i++) fat[i]=i;//初始化并查集
    for (int i=1;i<=m;i++){
        if (ask(a[i].x)!=ask(a[i].y)){//克鲁斯卡尔
            tot++;
            ans=ans+a[i].z;
            unite(a[i].x,a[i].y);
        }
    }
    if (tot<n-1) printf("orz");//判断若tot=k-1则生成了最小树
    else printf("%d",ans);
return 0;
}
```

---

## 作者：乒乓高手 (赞：1)

裸的最小生成树啊。


一看数据范围是200000，太大了。直接上kruskal算法。毕竟时间复杂度比prim低很多啊。


并且kruskal必须要用到并查集，这就要求我们能够熟练掌握并查集的使用。


而且我是用的结构体存图，也没有向楼下的大佬一样用并查集存图。


这个程序真的是很麻烦啊，写了四个函数，具体解释都在程序里，仔细看吧。



```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>        //头文件
#define maxn 200010
using namespace std;
int m,n,s,ans,tot;
int xi,yi,zi,k;
int f[maxn];
struct bian    //结构体存图
{
    int x;
    int y;
    int z;
}a[200010];
int cmp(bian a,bian b)  //由于是要用到结构体排序，所以手写了CMP函数
{
    if(a.z<b.z)
      return 1;
    else
      return 0;
}
int find(int i)     //并查集的查找函数
{
    if(f[i]!=i)    //不是根节点就继续往下找
      f[i]=find(f[i]);
    return f[i];
}
void unionn(int i,int j)     //并查集合并函数
{
    int la=find(i);
    int lb=find(j);
    if(la!=lb)              //如果根节点不同，就合并
      f[lb]=la;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
      cin>>a[i].x>>a[i].y>>a[i].z;         //输入没毛病
    sort(a+1,a+1+m,cmp);                //排序
    for(int i=1;i<=n;i++)                     //初始化，附初值
      f[i]=i;
    for(int i=1;i<=m;i++)                    //算法开始，扫描每一条边
      {
          if(find(a[i].x)!=find(a[i].y))   //如果不在一个集合里，就合并
            {
                unionn(a[i].x,a[i].y);     //合并
                tot+=a[i].z;                      //计算总权值
                k++;                              //K是已经选择的边数
            }
          if(k==n-1)                            //因为最大是N-1，所以找到N-1就好了，直接退出就可以了
            break;
      }
    if(k!=n-1)                                    //判断不联通图
      cout<<"orz";
    else
      cout<<tot;
    return 0;                                    //结束
}
```

---

## 作者：gyf12138 (赞：1)

**这个明显的就是最小生成树**

最小生成树的算法有prim，kruskal

亲测都能ac

推荐kruskal

kruskal如下：

‘’#include<cstdio>

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 200001;
int father[N];
int n, m;
struct Node
{
    int value, a, b;
}e[N];
bool cmp(const Node& a, const Node& b)
{
    return a.value < b.value;
}
int find_(int x)        //并查集查找 
{
    int root = x;
    while(father[root] != 0)
        root = father[root];
    while(root != x)
    {
        int temp = father[x];
        father[x] = root;
        x = temp;
    }
    return root;
}
void kruskal()
{
    int t = 1, costlenth = 0;        //t表示已入树的边数，costlenth表示生成树权值总和 
    for(int i = 1; i <= m; i++)
    {
        int p = find_(e[i].a), q = find_(e[i].b);
        if(p != q)                    //合并集合 
        {
            costlenth += e[i].value;
            father[q] = p;
            t++;
            if(t == n)
            {
                printf("%d\n", costlenth);
                return;
            }
        }
    }
}
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++)
        scanf("%d%d%d", &e[i].a, &e[i].b, &e[i].value);
    sort(e+1, e+m+1, cmp);            //将权值从小到大排序 
    kruskal();
    return 0;
}
```

---

## 作者：hehe_54321 (赞：1)

**再来一发prim堆优化，不一样的**

\_prim算法简单来说，就是开始时所有点都是蓝点（未加入最小生成树），先选择任意一点作为起点，将它改为白点（加入树），然后不断循环寻找离白点最近的蓝点，离这个蓝点最近的白点到这个蓝点的边即为最小生成树的一条边，并将这个蓝点改为白点（将其加入树），直到所有能到达的点成为白点（所有能到达的点加入最小生成树）\_

```cpp
#include<cstdio>
#include<queue>
using namespace std;
typedef long long LL;
struct Edge
{
    LL next,to,dis;
    friend bool operator<(Edge a,Edge b)
    {
        return a.dis>b.dis;
    }
}edge[400001];//边的类型
priority_queue<Edge> q;//优先队列，依照其中边的权值排序 
LL num_edge,n,m,ans,node[5001];
bool exist[5001];//存储一个点是否已经加入最小生成树
int main()
{
    LL i,j,t1,t2,t3,k,num=1;
    Edge x;
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%lld%lld%lld",&t1,&t2,&t3);
        edge[++num_edge].next=node[t1];
        edge[num_edge].to=t2;
        edge[num_edge].dis=t3;
        node[t1]=num_edge;
        edge[++num_edge].next=node[t2];
        edge[num_edge].to=t1;
        edge[num_edge].dis=t3;
        node[t2]=num_edge;//链式前向星存图，建立双向边
    }
    exist[1]=true;//选择任意一点作为起点（此处为第一个点），将其加入最小生成树
    k=node[1];
    while(k!=0)
    {
        q.push(edge[k]);
        k=edge[k].next;
    }//将与第一个点相接的边加入优先队列
    while(!q.empty()&&num<n)
    {
        x=q.top();//取出与已经在最小生成树中的点相接的边中最短的一条
        q.pop();
        if(exist[x.to]==true) continue;//如果该边的目的地已经加入最小生成树则不用再次将目的地加入树，因此跳过此条边
        num++;//num记录最小生成树中点的数量
        ans+=x.dis;//最小边权之和加上选中的边的边权 
        exist[x.to]=true;//表示此边的目的地已经加入最小生成树 
        k=node[x.to];
        while(k!=0)
        {
            if(exist[edge[k].to]==false)
                q.push(edge[k]);
            k=edge[k].next;
        }//取所有与此边的目的地相接的边 ，如果这条边的目的地没有加入最小生成树，则将边加入优先队列 
    }
    if(num<n)
        printf("orz");//如果结束时已加入最小生成树的点的数量小于点的总数量，则图不是联通图 
    else
        printf("%lld",ans);
    return 0;
}
```

---

## 作者：拓拓 (赞：1)

看到没有prim堆优化的，发一个

其实就是在找最小边的时候直接用堆来储存


```cpp
#include <cstdio>
#include <queue>
struct Node{
    struct Edge{
        Node *to;
        int power;
        Edge *next;
        Edge(Node *to, int power, Edge *next) : to(to), power(power), next(next) {}
    } *fe;
    Node() : fe(0) {}
    void push(Node *to, int power){
        fe = new Edge(to, power, fe);
    }
}node[100001];
struct Cmp{
    bool operator () (Node::Edge *a, Node::Edge *b){
        return a->power > b->power;
    }
};
int finally[100001], sum, n;
void Prim(){
    std::priority_queue<Node::Edge*, std::vector<Node::Edge*>, Cmp> que;
    for(Node::Edge *e = node[1].fe; e; e = e->next)
        que.push(e);
    finally[1] = 1;
    for(int i = 0; i < n - 1; i++){
        Node::Edge *team;
        team = que.top();
        while(finally[team->to - node])
            que.pop(), team = que.top();
        sum += team->power;
        finally[team->to - node] = 1;
        for(Node::Edge *e = team->to->fe; e; e = e->next)
            if(!finally[e->to - node])
                que.push(e);
    }
}
int main(int argc, char *argv[]){
    int m;
    scanf("%d%d", &n, &m);
    while(m--){
        int c1, c2, c3;
        scanf("%d%d%d", &c1, &c2, &c3);
        node[c1].push(node + c2, c3);
        node[c2].push(node + c1, c3);
    }
    Prim();
    printf("%d", sum);
    return 0;
}
```

---

## 作者：RedContritio (赞：1)

最小生成树有两种算法：Prim 和 Kruskal 。

开始的时候想都没想，Prim朴素算法，然后 T 了三个点。。。

然后学乖了，开始用 Kruskal 算法，毕竟并查集速度能快一点，然后好容易才过了。

很显然，这个题目旨在教会我们最小生成树的算法，但是看到题解区里面有些代码可读性不够高，于是把自己的蒟蒻代码发上来。

该代码为 CPP 代码 ， 虽然改掉头文件就可以用 C99 标准 。

代码前半部分是Kruskal ( 100 )， 后半部分是 Prim ( 70 ) 。

具体算法解释见注释：

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#define USING_PRIM // 使用 Prim算法
#define USING_KRUSKAL // 使用 Kruskal 算法
#ifdef USING_KRUSKAL // 防止算法冲突 ， 优先保证 Kruskal
```
#undef USING\_PRIM
    


    
    
    






```cpp
#endif
// 下面的代码无法提交，只能本地查看
#ifdef USING_PRIM
    #pragma message("使用PRIM算法")
#endif
#ifdef USING_KRUSKAL
    #pragma message("使用KRUSKAL算法")
#endif
// 除非删除上面六句
typedef struct tagLINK
{
    int X; // 起点
    int Y; // 终点
    int W; // 权重（长度？）
}LINK; // 边 的结构体 
typedef LINK* PLINK; // 边指针
#ifdef USING_PRIM 
int Prim( const int N , unsigned int** W ); // prim算法，给定 N 和 权重表 ， 返回 最小的值 ， 若无法连通返回-1
unsigned int** Prim_build_W( const int N , unsigned int** W ); // 初始化权重表（为 0xFFFFFFFF）
void Prim_set_W( LINK link , unsigned int** W ); // 设置权重 ， 将 link 边的权重设置进 W 中
#endif
#ifdef USING_KRUSKAL
int Kruskal( const int N , const int M ,LINK* links ); //  Kruskal算法，给定 N 和 权重表 ， 返回 最小的值 ， 若无法连通返回-1
int Kruskal_cmp(const void* A , const void* B); // 快排比较函数
int Kruskal_find(int* f , int x ); // 并查集查找函数
bool Kruskal_union(int* f , int a , int b ); // 合并 a ， b 两个集合，若 a，b在统一集合中，则返回 false ， 否则返回 true。
#endif
int main()
{
    int N,M;
    scanf("%d%d",&N,&M);
    PLINK links = (LINK*)calloc(M,sizeof(LINK)); // 分配边的空间
    #ifdef USING_PRIM // prim算法 分配权重表空间
    unsigned int **W = NULL ;
    W = Prim_build_W(N,W);
    #endif
    for(int i=0;i<M;i++)
    {
        scanf("%d%d%d",&links[i].X,&links[i].Y,&links[i].W); // 读入边
        links[i].X -- , links[i].Y -- ; // 将 1~N 标准化为 0 ~ N-1
        #ifdef USING_PRIM // 若为 PRIM ， 加入边至权重表
        Prim_set_W( links[i] , W );
        #endif
    }
    //以下六行为 使cost等于最小代价 ， 若cost==-1，则不可连通
    #ifdef USING_PRIM
    int cost = Prim(N,W);
    #endif
    #ifdef USING_KRUSKAL
    int cost = Kruskal(N,M,links);
    #endif
    if( cost ==-1 )printf("orz\n");
    else printf("%d",cost);
}
#ifdef USING_KRUSKAL
int Kruskal( const int N , const int M ,LINK* links )
{
    int *f = (int*)calloc(N,sizeof(int)); // 并查集
    for(int i=0;i<N;i++)f[i] = i ; // 并查集初始化
    qsort(links,M,sizeof(LINK),Kruskal_cmp);
    unsigned int LS = links[0].W ; // 首先加入最短边
    Kruskal_union(f,links[0].X,links[0].Y); // 合并
    int linked = 2 ; // 已连接边的数量
    for(int i=1;i<M && linked < N ;i++)
    {
        if( Kruskal_union(f,links[i].X,links[i].Y) )
        {
            LS += links[i].W ;
            linked ++ ;
        }
    }
    free(f);
    if( linked < N )return 0xFFFFFFFF; // 若未完全连接，返回 -1 
    return LS ;
}
bool Kruskal_union(int* f , int a , int b )//并查集的合并操作
{
    int pa = Kruskal_find( f , a );
    int pb = Kruskal_find( f , b );
    if( pa == pb )return false ;
    f[pa] = f[pb] ;
    return true ;
}
int Kruskal_find(int* f , int x )
{
    if(f[x] != x)f[x] = Kruskal_find(f,f[x]);
    return f[x];
}
int Kruskal_cmp(const void* A , const void* B)
{
    PLINK a = (PLINK)A , b = (PLINK)B ;
    return a->W - b->W ;
}
#endif
#ifdef USING_PRIM
int Prim( const int N , unsigned int** W ) // prim函数
{
    int *V = (int*)calloc(N,sizeof(int)); // 已经连通的节点
    bool* reach = (bool*)calloc(N,sizeof(bool)); // 记录是否访问过节点
    int SizeofV = 1 ; // 已访问节点数
    int LS = 0; // 最短长度
    reach[0] = true ;
    for( ; SizeofV < N ; )
    {
        int best = 0 ; // 暂无最佳选择
        unsigned length = 0xFFFFFFFF; // 最小长度为 0xFFFFFFFF
        for(int i=0;i<SizeofV;i++)
        {
            for(int j=0;j<N;j++)
            {
                if(reach[j])continue; // 若 j 在集合中，跳过
                if( W[V[i]][j] < length ) // 若可能为最短边
                {
                    length = W[V[i]][j] ; // j 为最佳选择
                    best = j;
                }
            }
        }
        if( length == 0xFFFFFFFF )return 0xFFFFFFFF ; // 若本回合未发现可连接的未访问边，返回-1
        LS += length;
        V[SizeofV] = best ;
        SizeofV ++ ;
        reach[best] = true ;
    }
    return LS; 
}
unsigned int** Prim_build_W( const int N , unsigned int** W ) // 构建 权重表
{
    W = (unsigned int**)calloc(N,sizeof(unsigned int*));
    for(int i=0;i<N;i++)
    {
        W[i] = (unsigned int*)calloc(N,sizeof(unsigned int));
        memset(W[i],0xFF,sizeof(unsigned int)*N);
    };
    return W;
}
void Prim_set_W( LINK link , unsigned int** W ) // 连接边
{
    if( W[link.X][link.Y] > link.W )W[link.X][link.Y] = W[link.Y][link.X] = link.W ; // 防止两点间有多条路径
    return ;
}
#endif
```

---

## 作者：Sci_M3 (赞：1)

目测上边都是朴素Kruskal？

加个按秩合并玩玩...

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 5000 + 10;
const int MAXM = 200000 + 10;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}
    return x * f;
}

struct node { int u, v, cost; }edge[MAXM];
int fa[MAXN], rank[MAXN];
int n, m;

inline void init() { for(int i = 1; i <= n; ++i) fa[i] = i, rank[i] = 0; }
inline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
inline bool cmp(node a, node b) { return a.cost < b.cost; }
inline bool same(int x, int y) { return find(x) == find(y); }
inline void unite(int x, int y) {
    x = find(x), y = find(y);
    if(x == y) return;
    if(rank[x] < rank[y]) fa[x] = y;
    else {
        fa[y] = x;
        if(rank[x] == rank[y]) rank[x]++;
    }
}

int kruskal() {
    sort(edge + 1, edge + m + 1, cmp);
    init();
    int res = 0;
    for(int i = 1; i <= m; ++i) {
        node e = edge[i];
        if(!same(e.u, e.v)) {
            unite(e.u, e.v);
            res += e.cost;
        }
    }
    return res;
}

int main() {
    n = read(), m = read();
    for(int i = 1; i <= m; ++i)
        edge[i].u = read(), edge[i].v = read(), edge[i].cost = read();
    int ans = kruskal(), tmp = find(1);
    bool flag = false;
    for(int i = 2; i <= n; ++i) if(find(i) != tmp) {
        flag = true; break;
    }
    if(flag) puts("orz\n");
    else printf("%d\n", ans);
    return 0;
}
```

---

## 作者：321zdq (赞：1)

**Kruskal算法**

如果你不知道Kruskal算法大概长啥样，请自行查找相关资料（百度一大堆）。

我用是否能找出n-1条边来判断有没有成功搞出最小生成树。

ps.数据似乎有点弱

pascal代码如下（可能写得并不漂亮）：

```pascal
var
u,v,w:array[1..200000]of longint;//存放边E(u,v),权值为w
f:array[1..5000]of longint;//并查集数组
n,m,i,j,s,ans:longint;

procedure qsort(l,r:longint);//把所有边按权值从小到大排序，改一改快速排序模板就可以了
var    
i,j,p,mid:longint;    
begin    
i:=l;j:=r;    
mid:=w[(l+r)shr 1];    
repeat    
while w[i]<mid do inc(i);    
while w[j]>mid do dec(j);    
if i<=j then    
begin    
p:=u[i];u[i]:=u[j];u[j]:=p;p:=v[i];v[i]:=v[j];v[j]:=p;p:=w[i];w[i]:=w[j];w[j]:=p;inc(i);dec(j);    
end;    
until i>j;    
if l<j then qsort(l,j);    
if i<r then qsort(i,r);    
end;      

function find(x:longint):longint;//查找点x所在集合
begin
if f[x]=0 then exit(x);
if f[f[x]]=0 then exit(f[x]);
find:=find(f[x]);
f[x]:=find;
end;

begin
read(n,m);
for i:=1 to m do read(u[i],v[i],w[i]);
qsort(1,m);
fillchar(f,n,0);
ans:=w[1];f[v[1]]:=u[1];//先加入权值最小的边，将它的两端并入一个集合，表示已经加入了生成树
s:=1;//s记录已经加入生成树的边的数量
for i:=2 to m do
begin
if s=n-1 then begin write(ans);halt;end;//一棵n个顶点的生成树有n-1条边，找到了n-1条边循环就不必继续了
if find(u[i])<>find(v[i]) then //如果两点不在一个集合
begin//这条边加入生成树
inc(ans,w[i]);
f[find(v[i])]:=find(u[i]);
inc(s);
end;
end;
if s=n-1 then begin write(ans);halt;end;//成功搞出了最小生成树，原因和上面那条一模一样的语句一样
write('orz');//orz。。。 
end.
```

---

## 作者：约修亚_RK (赞：1)

说到最小生成树，我们有Kruskal和Prim（稠密图会MLE的话用这个），写前者就差不多了。虽然后者可以用堆来优化，不过略过不表。


Kruskal算法任意时刻的中间结果是一个森林；从n个点的集合开始，在每次选择不产生圈的前提下，找一条权值最小的边，合并边的两个端点所在的集合。


简单易懂的伪代码

From [Wikipedia https://en.wikipedia.org/wiki/Kruskal%27s\_algorithm#Example]

```cpp
KRUSKAL(G): 
1 A = ∅ 
2 foreach v ∈ G.V: 
3    MAKE-SET(v) 
4 foreach (u, v) in G.E ordered by weight(u, v), increasing: 
5    if FIND-SET(u) ≠ FIND-SET(v): 
6       A = A ∪ {(u, v)} 
7       UNION(u, v) 
```
8 return A

至于怎么看它是否连通，我是看最后是否所有点都在同一个集合里面，仅此而已。


```cpp
/* P3366
 * Au: SJoshua
 */
#include <cstdio> 
#include <algorithm> 
 
#define MAXM 200000
#define MAXN 5000  
 
using namespace std; 
 
struct edge { 
    int u, v, w;  
} edges[MAXM]; 
 
int cmp (edge a, edge b) { 
    return a.w < b.w; 
} 
 
int set[MAXN]; 
 
int findSet(int k) { 
    return set[k] == k ? k : set[k] = findSet(set[k]); 
} 
 
int main(void) { 
    int n, m, nos, wt = 0; 
    scanf("%d %d", &n, &m); 
    for (int k = 1; k <= m; k++) { 
        scanf("%d %d %d", &edges[k].u, &edges[k].v, &edges[k].w); 
    } 
    sort(edges+1, edges+1+m, cmp); 
    for (int k = 1; k <= n; k++) { 
        set[k] = k; 
    } 
    nos = n; 
    for (int k = 1; k <= m && nos > 1; k++) { 
        int fu = findSet(edges[k].u); 
        int fv = findSet(edges[k].v); 
        if (fu != fv) { 
            set[fu] = fv; 
            wt += edges[k].w; 
            nos--; 
        } 
    }
    int fc = findSet(1);
    for (int k = 2; k <= n; k++) {
        if (findSet(k) != fc) {
            printf("orz");
            return 0;
        }
    }
    printf("%d", wt);   
    return 0; 
}
```

---

## 作者：59percent (赞：0)

![](https://cdn.luogu.com.cn/upload/image_hosting/i5409ltf.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/hexcu8ib.png)
```
                kruskal                   prim
    怎么找？    每次找最小边（实现排序）     每次找最小距离(剩余点和集合T的距离)
    怎么判断？  并查集来判断（是否同一祖宗）  排除掉已有的点
    加入到集合  
    处理       合并集合                   更新最小距离
```

# prim
```cpp
/*
1. 随便找一个点T = {v0}, vis[v0] = true,
  1.2. 最短距离：任意一个点到T的最短距离, d[N]
   {v0},  d[x]=w[x->v0]
  ->{v0, v1} ,  d[x]更新
  for(int i=0; i<g[v1].size; i++) {//v1连接的所有边
     int y = g[v1][i].y, w=g[v1][i].w;//Edge{y, w}
     d[y] = min(w, d[y]);
  }
2. 循环：每次找到T的最短距离（边）的的最小，加入到T，然后更新其它距离
   循环：n
     1. 找最小，取值, 优先队列           1. 取出最小
     2. 加入                           2. 加入答案
     3. 处理后续（更新边的距离，加入队列）  3.处理后续，in[--]，如果到0就加入队列 

如果连通，T的个数是n个，T就是一个最小生成树（还有其它），如果不变通，返回-1
*/


#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;
struct Edge {
  int y, w;
};

struct Node {
  int y, w;
  //<,   Node n1, n2,   if(n1 < n2), less<Node>
  bool operator < (const Node &n1) const {
    return w > n1.w;
  }
};

const int N=1e5+5, INF=0x3f3f3f3f;
int n, m;
vector<Edge> g[N];
bool vis[N];//Vnew
int d[N];//各点到Vnew的最短距离

int prim(int v0) {
  //priority_queue<Node, vector<Node>, greater<Node> > q;//最小的出队，根据w
  priority_queue<Node> q;//默认是less<Node>
  memset(vis, false, sizeof(vis));
  memset(d, 0x3f, sizeof(d));
  //初始化Vnew和各点到Vnew的最短距离
  int ans = 0, cnt=1;
  vis[v0] = true;//第一个点，找到连出的最小边
  for(int i=0; i<g[v0].size(); i++) {
    Edge e1 = g[v0][i];
    d[e1.y] = e1.w;
    q.push(Node{e1.y, e1.w});
  }
  while(!q.empty()) {
    //1. 最小值
    Node t = q.top();
    q.pop();
    if(vis[t.y]) continue;//排除掉同一个点之前已经选过的
    //2. 加入
    int x = t.y, w=t.w;
    vis[x] = true;
    ans += w;
    cnt++;
    //cout<<"加入"<<x<<", ans+="<<w<<endl;
    //3. 更新最短距离
    for(int i=0; i<g[x].size(); i++) {
      int y=g[x][i].y, w=g[x][i].w;
      if(vis[y]) continue;
      if(w < d[y]) {//d[5]: 6,  d[5]->2
        d[y] = w;
        q.push(Node{y, w});
      }
    }
  }
  return cnt==n? ans: -1;
}

int main() {
  scanf("%d%d", &n, &m);
  for(int i=1; i<=m; i++) {
    int x, y, w;
    scanf("%d%d%d", &x, &y, &w);
    g[x].push_back((Edge){y, w});
    g[y].push_back((Edge){x, w});
  }
  
  printf("%d\n", prim(1));
  return 0;
}

```
# kruskal
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct Edge {
  int x, y, w;
  bool operator < (const Edge &e1) const {
    return w < e1.w;
  }
};

const int N=1e5+5, INF=0x3f3f3f3f;
int n, m, top[N], rk[N];//top[点的数目]
Edge e[N];//边集

int find(int x) {
  int t = x;
  while(top[t] != t)
    t = top[t];
  return top[x] = t;//优化: 压缩路径
}

void join(int x, int y) {
  int tx = find(x), ty = find(y);//tx=top[x]  ?
  if(tx != ty)
    top[tx] = ty;  
}

int kruskal() {
  for(int i=1; i<=n; i++)//初始化，每个点一个集合
    top[i] = i;
  int ans=0;
  for(int i=1; i<=m ; i++) {//O(m)
    Edge e1 = e[i];
    if(find(e1.x) == find(e1.y)) continue;//同一个不要了
    join(e1.x, e1.y);//合并
    ans += e1.w;
  }
  return ans;
}

int main() {
  scanf("%d%d", &n, &m);
  for(int i=1; i<=m; i++) {//输入边
    scanf("%d%d%d", &e[i].x, &e[i].y, &e[i].w);
  }
  sort(e+1, e+m+1);//排序 O(mlogm)
  
  printf("%d\n", kruskal());
  return 0;
}


```


---

## 作者：Lacrymabre (赞：0)

Krusckal算法模板：

1.结构体存边，每个边有3个指标:st,to,var（起始，终末，距离/长度）；

2.按权值（距离）降序排序；

3.贪心算法for m取边入图；并查集判断，两边不属于一个集合就加入；

4.ans++；

5.prntf ans；


```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;

int n,m,x,i,j,y,z,tot;
struct node
{
	int st,to;
	long long var;
}c[200001];
int f[2000001];
long long ans;

inline int find(int x)
{
	if(f[x]==x) return x;
	else
	{
		f[x]=find(f[x]);	
		return f[x];
	}
}

inline bool cmp(node a,node b)
{
	return a.var<b.var;
}

inline void smainst_tree()
{
	for(int i=1;i<=m;i++)
	{
		int u=find(c[i].st);
		int v=find(c[i].to);
		if(u==v) continue;
		ans+=c[i].var;
		f[u]=v;
		tot++;
		if(tot==n-1) return;
	}
}


inline void scan()
{
	scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++) f[i]=i;
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&c[i].st,&c[i].to,&c[i].var);
    }
    sort(c+1,c+m+1,cmp);
    smainst_tree();
}

int main()
{
	scan();
	cout<<ans<<endl;
    return 0;
}
```



---

## 作者：Object_ (赞：0)

**算法原理：**

- 在kruskal算法正确性的基础上，考虑进行优化.
- 由于kruskal的复杂度为O(mlogm)，在稠密图中表现可能不太好，思考能否利用最短这一性质对复杂度上界进行优化.

- 联想到dijkstra的性质，可以发现最小生成树在局部也满足这一性质（最小生成树的每一个子树都是一个最小生成树）.
- 由于任意一点都必然会在最小生成树中，可以从任意一点开始"探索"（类似文明VI中探索地图）.
- 假设首先选择了1号点，那么对于1号点来说，如果想要拓展自己的大小且花费尽量小，应该选择权值最小的边.
- 递归进行以上操作，就可以求出整个图的最小生成树.

**堆优化：**

- 考虑到在最小生成树的拓展过程中，每个点在被选择时，它所在的"入边"一定是最优选择，而已有的最小生成树可以证明是完美的，而且每个点实际上仅仅是对于其他点的一个"中转站"，所以它的"入边"就不需要再被更新。可以利用这一个性质，结合Dijkstra的堆优化，将"入边"长度作为小根堆的特征值，即可将算法复杂度从![](https://private.codecogs.com/gif.latex?O%28n%5E2%29)优化到![](https://private.codecogs.com/gif.latex?O%28nlogm%29)

------------

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
const int MAXN=5e3+5,MAXM=4e5+5;
struct Edge{
	int from,to,w,nxt;
}e[MAXM];
int head[MAXN],edgeCnt=1;
void addEdge(int u,int v,int w){
	e[++edgeCnt].from=u;
	e[edgeCnt].to=v;
	e[edgeCnt].w=w;
	e[edgeCnt].nxt=head[u];
	head[u]=edgeCnt;
}
struct Node{
	int nowV,nowW;
	bool operator <(Node another)const{
		return nowW>another.nowW;
	}
};
int minw[MAXM];
bool vis[MAXN];
int prim(){
	memset(minw,0x3f,sizeof(minw));
	priority_queue<Node> q;
	q.push(Node{1,0});
	int ans=0;
	while(!q.empty()){
		Node nowNode=q.top();q.pop();
		int v=nowNode.nowV,w=nowNode.nowW;
		if(vis[v])continue;
		vis[v]=1;
		ans+=w;
		for(int i=head[v];i;i=e[i].nxt){
			int nowV=e[i].to;
			if(!vis[nowV]&&e[i].w<minw[nowV]){
				minw[nowV]=e[i].w;
				q.push(Node{nowV,e[i].w});
			}
		}
	}
	return ans;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		addEdge(u,v,w);
		addEdge(v,u,w);
	}
	int ans=prim();
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：wancong (赞：0)

## kruskal算法+并查集

这是一个非常好的最小生成树算法，比prim算法的代码量小，而且在稀疏图的情况下要优于prim算法。因为大多数图都是稀疏图，所以kruskal算法是足够的。

基本思想：把边按照权值由小到大排序。初始时，生成树的边集是空集。然后，按顺序依次向边集中添加边，但是，需要跳过使得生成树成环的边。每添加一条边，就要把它连接的两个顶点加入点集。直到边全部用完，或者达到v-1条边为止。如果边全部用完，生成树依然不连通，则表明图不连通。

那么问题来了，关键在于判断加入一条边是否成环，以及最后生成树是否连通。

后一个问题简单，我们知道判断树或者图是否连通，可以用并查集最终的分支数是否为1来判断。那么，成环怎么判断呢？

依然是并查集。为什么呢？我们先看一下这个定理，当两个顶点都已经在点集中时，直接连接这两个顶点的边，必然使得生成树成环。

基于这个定理，我们又可以用并查集了，因为两个顶点同在并查集中，则它们的祖先节点相同。

使用并查集的时候，注意路径压缩。否则，有可能退化为长度为v的链表。

最需要注意的还是溢出，一切权值用long long。

限于篇幅，具体情况我就不解释了，如果还不懂，可以看我的博客https://blog.csdn.net/zhangwancongcsdn/article/details/86890744

参考代码：

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;

typedef struct
{
    int v1;
    int v2;
    int weight;
}edge;
edge elist[200000];
int father[5001];

bool cmp(edge a, edge b)
{
    return a.weight < b.weight;
}

int root(int x)
{
    if (father[x] < 0) return x;
    else return root(father[x]);
}

inline int Min(int x, int y)
{
    return x < y ? x : y;
}

bool Merge(int x, int y)
{
    x = root(x);
    y = root(y);
    if (x == y) return false;
    if (father[x] > father[y])
        father[y] = Min(father[x] - 1, father[y]), father[x] = y;
    else
        father[x] = Min(father[y] - 1, father[x]), father[y] = x;
    return true;
}

int main(int argc, char *argv[])
{
    int v, e, i, cnt = 0, branches;
    long long totalw = 0;
    scanf("%d %d", &v, &e);
    branches = v;
    for (i = 0; i < e; i++)
        scanf("%d %d %d", &elist[i].v1, &elist[i].v2, &elist[i].weight);
    sort(elist, elist+e, cmp);
    memset(father, -1, sizeof(father));
    i = 0;
    while (i < e && cnt < v-1)
    {
        if (Merge(elist[i].v1, elist[i].v2))
        {
            totalw += (long long)elist[i].weight, cnt++;
            branches--;
        }
        i++;
    }
    if (branches > 1)
    {
        printf("orz");
    }
    else printf("%lld", totalw);
    return 0;
}

```

---


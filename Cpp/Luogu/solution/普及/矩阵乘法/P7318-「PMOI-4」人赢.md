# 「PMOI-4」人赢

## 题目背景

众所周知，ducati 是人 win。

现在 lhm 也想成为人 win，于是 ducati 扔给了 lhm 下面这道题，并且 ducati 承诺在 lhm 完成此题后教他如何成为人 win。

## 题目描述

现在 lhm 手中有一个无穷长的衔尾数列 $a$，它满足：

- 对于数列中的每一个 $a_i(i>2)$，它总为 $a_{i-2} \times a_{i-1}$ 的**个位数**。

ducati 将给 lhm 衔尾数列的前两位 $a_1=n,a_2=m$ 与位置 $k$，它的任务是算出 $a_k$。

由于 lhm 太菜了并不会这道题，但他仍然想成为人 win，所以他只好请聪明的你来帮他完成这个问题。

## 说明/提示

【样例解释 $1$】

数列 $1$ 至 $10$ 位依次为：$1,6,6,6,6,6,6,6,6,\color{red}{6}$。所以答案为 $6$。

【样例解释 $2$】

数列 $1$ 至 $7$ 位依次为：$7,2,4,8,2,6,\color{red}{2}$。所以答案为 $2$。


【数据范围】

**本题采用捆绑测试**。

- Subtask 1（30pts）：$1 \leq k \leq 10^6$。
- Subtask 2（70pts）：无特殊限制。

对于 $100\%$ 的数据，$0 \leq n,m \leq 9$，$1 \leq k \leq 10^{12}$。

## 样例 #1

### 输入

```
1 6 10```

### 输出

```
6```

## 样例 #2

### 输入

```
7 2 7```

### 输出

```
2```

# 题解

## 作者：Thomas_Cat (赞：26)

对于这一题对于 $100\%$ 的数据 $1 \le k \le 10^{12}$ 则显然不会是暴力打解了，一定是有规律的，因此可以从这方面去考虑。

### Subtask 1

显然 $1 \le k \le 10^6$ 只需要暴力枚举即可，复杂度 $\mathcal{O}(n)$，注意在计算 $a_i=a_{i-1} \times a_{i-2} \bmod 10$ 的时候如果单纯按原式代入计算 $a_i$ 的话那么在后面可能会爆 $\texttt{int}$，所以注意：

因为只计算个位数，只用算出 $a_{i-1} \bmod 10, a_{i-2} \bmod 10$ （也就是个位数即可），应该把式子变成：
$$
a_i=(a_{i-1}\bmod 10) \times (a_{i-2}\bmod 10) \bmod 10
$$

直接打暴力即可：（$30 pts$）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,k;
	cin>>n>>m>>k;
	int a[100005];
	a[1]=n,a[2]=m;
	for(int i=3;i<=k;i++)
		a[i]=(a[i-1]%10*a[i-2]%10)%10;//按照式子计算得出答案
	cout<<a[k];//最后输出即可
	return 0;
}
```

### Subtask 2

显然不能打暴力了，对于 $1 \le k \le 10^{12}$ 需要找规律，因此我们尝试枚举部分情况的结果：

下表中 $k$ 均为 $15$。

| $(n,m)$ | $a_1$ | $a_2$ | $a_3$ | $a_4$ | $a_5$ | $a_6$ | $a_7$ | $a_8$ | $a_9$ | $a_{10}$ | $a_{11}$ | $a_{12}$ | $a_{13}$ | $a_{14}$ | $a_{15}$ |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :------: | :------: | :------: | :------: | :------: | :------: |
| $(4,9)$ |  $4$  |  $9$  |  $6$  |  $4$  |  $4$  |  $6$  |  $4$  |  $4$  |  $6$  |   $4$    |   $4$    |   $6$    |   $4$    |   $4$    |   $6$    |
| $(7,8)$ |  $7$  |  $8$  |  $6$  |  $8$  |  $8$  |  $4$  |  $2$  |  $8$  |  $6$  |   $8$    |   $8$    |   $4$    |   $2$    |   $8$    |   $6$    |
| $(3,9)$ |  $3$  |  $9$  |  $7$  |  $3$  |  $1$  |  $3$  |  $3$  |  $9$  |  $7$  |   $3$    |   $1$    |   $3$    |   $3$    |   $9$    |   $7$    |
| $(6,8)$ |  $6$  |  $8$  |  $8$  |  $4$  |  $2$  |  $8$  |  $6$  |  $8$  |  $8$  |   $4$    |   $2$    |   $8$    |   $6$    |   $8$    |   $8$    |
| $(7,3)$ |  $7$  |  $3$  |  $1$  |  $3$  |  $3$  |  $9$  |  $7$  |  $3$  |  $1$  |   $3$    |   $3$    |   $9$    |   $7$    |   $3$    |   $1$    |

上图中就是几个数对按照题目要求得出的 $a_1 \sim a_{15}$ 数。

在图中：

| $(n,m)$ | $a_1$ | $a_2$ |     $a_3$      |     $a_4$      |     $a_5$      |     $a_6$      |     $a_7$      |     $a_8$      |       $a_9$       |     $a_{10}$      |     $a_{11}$      |     $a_{12}$      |     $a_{13}$      |     $a_{14}$      | $a_{15}$ |
| :-----: | :---: | :---: | :------------: | :------------: | :------------: | :------------: | :------------: | :------------: | :---------------: | :---------------: | :---------------: | :---------------: | :---------------: | :---------------: | :------: |
| $(4,9)$ |  $4$  |  $9$  | $\color{red}6$ | $\color{red}4$ | $\color{red}4$ | $\color{red}6$ | $\color{red}4$ | $\color{red}4$ | $\color{purple}6$ | $\color{purple}4$ | $\color{purple}4$ | $\color{purple}6$ | $\color{purple}4$ | $\color{purple}4$ |   $6$    |
| $(7,8)$ |  $7$  |  $8$  | $\color{red}6$ | $\color{red}8$ | $\color{red}8$ | $\color{red}4$ | $\color{red}2$ | $\color{red}8$ | $\color{purple}6$ | $\color{purple}8$ | $\color{purple}8$ | $\color{purple}4$ | $\color{purple}2$ | $\color{purple}8$ |   $6$    |
| $(3,9)$ |  $3$  |  $9$  | $\color{red}7$ | $\color{red}3$ | $\color{red}1$ | $\color{red}3$ | $\color{red}3$ | $\color{red}9$ | $\color{purple}7$ | $\color{purple}3$ | $\color{purple}1$ | $\color{purple}3$ | $\color{purple}3$ | $\color{purple}9$ |   $7$    |
| $(6,8)$ |  $6$  |  $8$  | $\color{red}8$ | $\color{red}4$ | $\color{red}2$ | $\color{red}8$ | $\color{red}6$ | $\color{red}8$ | $\color{purple}8$ | $\color{purple}4$ | $\color{purple}2$ | $\color{purple}8$ | $\color{purple}6$ | $\color{purple}8$ |   $8$    |
| $(7,3)$ |  $7$  |  $3$  | $\color{red}1$ | $\color{red}3$ | $\color{red}3$ | $\color{red}9$ | $\color{red}7$ | $\color{red}3$ | $\color{purple}1$ | $\color{purple}3$ | $\color{purple}3$ | $\color{purple}9$ | $\color{purple}7$ | $\color{purple}3$ |   $1$    |

我们可以发现$\color{red}红色$部分和$\color{purple}紫色$部分的数字是完全相同的，不妨猜测所有数列都以 $6$ 次为循环。

根据这个思路我们用 $k$ 来看看，因为 $a_1,a_2$ 不考虑在数列以内，因此对于 $k$ 在循环中的点的公式为 $ans=(k-3) \bmod 6 +3$ ，因此代入计算即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,m,k;
	cin>>n>>m>>k;
	int a[10],b[7];
	a[1]=n,a[2]=m;//a1,a2按照前面算出来，因为数列中不包含
	for(int i=3;i<=9;i++)//循环
		a[i]=(a[i-1]%10*a[i-2]%10)%10;//按照前面算出第一个数列也就是六次循环算出的结果
    cout<<a[(k-3)%6+3];//代入公式计算算出即可
	return 0;
}
```

令：如果遇到相乘 $a_2,a_3$ 为 $1,5,6$，只需输出 $1,5,6$ 即可；如果遇到 $a_i=0$ 输出 $0$ 即可。

综上，求解方法为：

$$
a_i=(a_{i-1}\bmod 10) \times (a_{i-2}\bmod 10) \bmod 10  
$$

令：
$$g(x)=\min_{1 \le i \le x,a_i \in [1,9]} a$$

$$r(x)=\max_{1 \le i \le x,a_i \in [1,9]} a$$

则：

$$
\Longrightarrow ans = \begin{cases}g(x)\in\{0\}&ans=0\\r(2),r(3) \in \{5\}&ans=5\\r(2),r(3) \in \{6\}&ans=6\\else&ans=a_{(k-3) \bmod 6 +3}\end{cases}
$$

[亲测，稳过](https://www.luogu.com.cn/record/56523660)

---

## 作者：Exber (赞：14)

## 题意
- #### 给定三个数 $n,m,k$，定义 $f(x)=\begin{cases}n\mod 10&\text{x = 1}\\m\mod 10& \text{x = 2}\\f(x-1)\cdot f(x-2)\mod 10&x>2\end{cases}$，求 $f(k)$ 的值。

## 做法
矩阵快速幂+快速幂。

根据 $f(x)$ 的定义，我们可以发现：

$f(1)=n\mod 10$

$f(2)=m\mod 10$

$f(3)=n\cdot m \mod 10$

$f(4)=n\cdot m^2 \mod 10$

$f(5)=n^2\cdot m^3 \mod 10$

$f(6)=n^3\cdot m^5 \mod 10$

$f(7)=n^5\cdot m^8 \mod 10$

观察 $n$ 和 $m$ 的系数，很容易发现 $f(x)=\begin{cases}n\mod 10&\text{x = 1}\\m\mod 10& \text{x = 2}\\n^{Fib(x-2)}\cdot m^{Fib(x-1)}\mod 10&x>2\end{cases}$（$Fib$ 为斐波那契函数）。

由于 $k$ 很大，所以需要使用矩阵快速幂求出 $Fib(k-2)$ 和 $Fib(k-1)$，再套个快速幂即可通过本题。

时间复杂度 $O(\log k)$。

## AC 代码

```cpp
#include <stdio.h>
#include <string.h>

struct node // 矩阵 
{
	long long a[5][5],mod;
	node()
	{
		memset(a,0,sizeof(a));
	}
	void operator*=(node b) // 矩阵乘法 
	{
		node tmp;
		for(int i=1;i<=2;++i)
		{
			for(int j=1;j<=2;++j)
			{
				for(int k=1;k<=2;++k)
				{
					tmp.a[i][j]+=a[i][k]*b.a[k][j]%mod;
					tmp.a[i][j]%=mod;
				}
			}
		}
		for(int i=1;i<=2;++i)
		{
			for(int j=1;j<=2;++j)
			{
				a[i][j]=tmp.a[i][j]%mod;
			}
		}
	}
};

int n,m;
long long k;

inline long long fbnq(long long q,long long mod) // 矩阵快速幂求斐波那契数列第 q 项 
{
	if(q<=2)
	{
		return 1;
	}
	else
	{
		node ans,tmp;
		ans.mod=mod;
		tmp.mod=mod;
		for(int i=1;i<=2;i++)
		{
			ans.a[1][i]=1;
		}
		tmp.a[1][1]=1;
		tmp.a[1][2]=1;
		tmp.a[2][1]=1;
		q-=2;
		while(q)
		{
			if(q&1)
			{
				ans*=tmp;
			}
			tmp*=tmp;
			q>>=1;
		}
		return ans.a[1][1]%mod;
	}
}

inline long long qpow(long long a,long long b,long long mod) // 快速幂 
{
	long long res=1,x=a;
	while(b)
	{
		if(b&1)
		{
			res*=x;
			res%=mod;
		}
		x*=x;
		x%=mod;
		b>>=1;
	}
	return res;
}

inline long long read() // 快读，用来卡常 
{
	long long s=0,ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+(ch^48),ch=getchar();
	return s;
}

int main()
{
	n=read();
	m=read();
	k=read();
	// 特判前两项 
	if(k==1)
	{
		printf("%d\n",n);
		return 0;
	}
	if(k==2)
	{
		printf("%d\n",m);
		return 0;
	}
	printf("%d\n",qpow(n,fbnq(k-2,10000),10)*qpow(m,fbnq(k-1,10000),10)%10); // O(log k) 求答案 
	return 0;
}
```


---

## 作者：Remake_ (赞：8)

简单矩乘+拓展欧拉定理题。

~~实际上是考场循环节打挂了TAT所以就写了这种东西过了QAQ~~

题意：

$$f_i=f_{i-1}\times f_{i-2} (f_1=n,f_2=m)$$

求第 $f_k\mod 10$。

观察到 $f_k$ 一定形如 $n^{e_1}m^{e_2}$ 。

考虑求出 $e_1$ 和 $e_2$ 。

我们不难发现 $e_1$ 为以下数列的第 $k$ 项：

$$g_i=g_{i-1}+g_{i-2}(g_1=1,g_2=0)$$

同理，我们不难发现 $e_2$ 为以下数列的第 $k$ 项：

$$g_i=g_{i-1}+g_{i-2}(g_1=0,g_2=1)$$

然后这两个东西显然可以矩乘优化，那就做完了？

naive！

我们在求 $g$ 的时候是需要模一个数的！

那么显然我们可以套用拓展欧拉定理：

即当 $b\ge\varphi(p)$时，有 $a^b=a^{b\mod \varphi(p)+\varphi(p)}\pmod {p}$

在本题中 $p=10,\varphi(p)=\varphi(10)=4$ 。

所以就做完了？

还是太 naive！

注意到拓展欧拉定理的使用限制 $b\ge\varphi(p)$，为了保证这一条性质，我们可以在 $k\leq 10^6$ 的时候暴力，当 $k> 10^6$ 时 $e_1$ 和 $e_2$ 也显然大于 $\varphi(p)=4$ 。

那么我们终于做完了，泪目。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 0x7fffffff
#define timeused() (double)clock()/CLOCKS_PER_SEC
#define rep(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define repp(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define mp make_pair
#define pb push_back
#define mod 4
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x){
   T f=1;x=0;char c=getchar();
   for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
   for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
   x*=f;
   return x;
}
ll n,m,k,a[1000005];
ll qp(ll b,ll p){
	ll ans=1,base=b;
	while(p){
		if(p&1) ans=ans*base%10;
		base=base*base%10;
		p>>=1;
	}
	return ans;
}
struct node{
	ll a[5][5];
	void clear(){rep(i,1,2) rep(j,1,2) a[i][j]=0;}
	void dw(){clear();rep(i,1,2) a[i][i]=1;}
	void init(){clear();a[1][2]=a[2][1]=a[1][1]=1;}
}B;
node mul(node x,node y){
	node z;
	z.clear();
	rep(i,1,2) rep(j,1,2) rep(k,1,2) z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%mod;
	return z;
}
node qpp(node b,ll p){
	node ans,base=b;
	ans.dw();
	while(p){
		if(p&1) ans=mul(ans,base);
		base=mul(base,base);
		p>>=1;
	}
	return ans;
}
int main(){
	rd(n);
	rd(m);
	rd(k);
	a[1]=n;
	a[2]=m;
	if(k<=1000000){
		rep(i,3,k) a[i]=a[i-1]*a[i-2]%10;
		printf("%lld",a[k]);
		return 0;
	}
	B.init();
	B=qpp(B,k-2);
	ll anss=qp(n,B.a[2][1]+4);
	anss*=qp(m,B.a[1][1]+4);
	printf("%lld",anss%10);
}
```


---

## 作者：ycw123 (赞：7)


# Luogu P7840 「PMOI-4」人赢
### 题意

给出 $n,m,k$

$f_i$ 满足如下性质：

$$
f_i= 
    \begin{cases}
        n&(i=1)\\
        m&(i=2)\\ 
        f_{i-1} \times f_{i-2} \bmod 10 \\
    \end{cases}
$$

求 $f_k$ 的值。



## 暴力找循环节

$f_i$ 的值只与 $f_{i-1},f_{i-2}$ 有关，$f_{i-1},f_{i-2}$ 最多只有 $10^2$ 种排列，根据抽屉原理，第 101 种排列一定会与前 100 种的某种重复，所以产生循环。

所以我们对于每一组 $f_{i-1},f_{i-2}$ 转换成一个两位数作为关键字，当暴力枚举到当前关键字已经出现过时，我们就成功找到了循环节。

找到循环节，我们就可以用剩余的暴力次数对循环节大小取模，再加上循环节的开始位置推出 $f_k$ 的值，即：
```cpp
ans=f[(k-i)%q+t[key]];
```

当然，对于 $k$ 过小的数据直接暴力即可。

### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long k,ans;
int t[100];//t[i] 表示关键字 i 出现的位置，若还未出现则为 0
int f[1000010];//即题面中的 a[i]
int main() {
	cin>>f[1]>>f[2]>>k;
	if(k<=1000000) {//Subtask 1 小数据直接暴力
		for(int i=3; i<=k; i++) {
			f[i]=f[i-1]*f[i-2]%10;
		}
		cout<<f[k];
		return 0;
	}
	for(int i=3; i<=k; i++) {
		f[i]=f[i-1]*f[i-2]%10;
		ll key=f[i-1]*10+f[i-2];//计算关键字
		if(t[key]){//已经出现过
			int q=i-t[key];
			ans=f[(k-i)%q+t[key]];
			cout<<ans;
			return 0;
		}
		t[key]=i;//第一次出现，记录位置
	}
    return 0;//好习惯人人养
}
```

---

## 作者：pitiless0514 (赞：4)

## 题意

很明显就不说了

## 题解

我们先将这个数列给写开一些，发现他的形式就是 $n,m,nm,nm^2,n^2m^3,n^3m^5,n^5m^8 ... $ 
，然后你发现从第四项开始 $n$ 和 $m$ 的指数变得有规律起来，也就是成了一个斐波那契数列。

那么相当于说指数我们是很好求的，可以使用矩阵乘法快速求。

然后指数有可能太大，我们存不下，但是你发现我们最后求个位数，只与个位数有关。

那么我们只用保留个位数，而个位数乘自己得到的个位数是有一个周期的，然后周期长度就是我们的模数。

然后这么算出来之后我们就也可以计算出 $n^x$ 与 $m^y$ 的个位数，然后乘起来就是答案了。

放一波垃圾代码。

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int M = 3;
int mod;
struct Martix {
  int a[M][M];
  Martix() { memset(a, 0, sizeof(a)); }
  Martix operator*(const Martix &b) {
    Martix res;
    for (int i = 1; i <= 2; i++) {
      for (int j = 1; j <= 2; j++) {
        for (int k = 1; k <= 2; k++) {
          res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
        }
      }
    }
    return res;
  }
};
int n, m, k;
Martix power(int n) {
  Martix ans, b;
  ans.a[1][1] = ans.a[1][2] = 1;
  b.a[1][1] = b.a[1][2] = b.a[2][1] = 1;
  while (n) {
    if (n & 1) {
      ans = (ans * b);
    }
    b = (b * b);
    n >>= 1;
  }
  return ans;
}
int b[2000], c[2000];
int l1, l2;
map<int, int> vis;
int ksm(int a, int b) {
  int ans = 1;
  while (b) {
    if (b & 1)
      ans = ans * a % 10;
    b >>= 1;
    a = a * a % 10;
  }
  return ans;
}
signed main() {
  cin >> n >> m >> k;
  if (k <= 15) {
    b[1] = n, b[2] = m;
    for (int i = 3; i <= k; i++) {
      b[i] = b[i - 1] * b[i - 2] % 10;
    }
    cout << b[k] << " \n";
    return 0;
  } else {
    for (int i = 1; i <= 100; i++) {
      b[i] = ksm(n, i);
      if (!vis[b[i]])
        vis[b[i]] = 1;
      else
        break;
      l1 = i;
    }
    vis.clear();
    for (int i = 1; i <= 100; i++) {
      c[i] = ksm(m, i);
      if (!vis[c[i]])
        vis[c[i]] = 1;
      else
        break;
      l2 = i;
    }
    mod = l1;
    int nn = power(k - 4).a[1][1];
    if (nn == 0)
      nn = b[l1];
    else
      nn = b[nn];
    mod = l2;
    int mm = power(k - 3).a[1][1];
    if (mm == 0)
      mm = c[l2];
    else
      mm = c[mm];
    cout << nn * mm % 10;
  }
  return 0;
}

```



---

## 作者：EnofTaiPeople (赞：4)

此题没有太多巧妙，只要学过小学奥数，就知道本题的关键在于找**循环节**。

首先已知，假设 $a_{i-1}$、$a_i$ 已经确定，那么 $a_i$ 以后的数字能由它们推导出。

但假如存在一个 $j>i$ 使得 $a_{j-1}=a_{i-1}$，$a_i=a_j$，那么 $a_i$ 与 $a_{j-1}$ 之间的数字，就会与 $a_j$ 到 $a_{j\times2-i}$ 完全相同。

由于任意的 $a_{i-1}$ 和 $a_i$ 只有 $100$ 种组合方式，于是不难想到使用哈希。这里的哈希，就是将 $a_{i-1}$ 与 $a_i$ 转换为 $a_{i-1}\times10+a_i$。

我们设 Has[a] 表示使得 $a_i\times10+a_i+1$ 的第一个 $i$ 一旦遇到重复的数字，进行一些奇怪的操作就得到答案了。

代码如下：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long Has[100],Got[256];
int main(){
	long long n,m,k,round;
	scanf("%lld%lld%lld",&n,&m,&k);
	register long long i,j;
	if(k==1){printf("%lld\n",n);return 0;}
	Got[1]=n*10+m;Has[n*10+m]=1;
	for(i=2;i<=k;++i){
		n=(n*m)%10;swap(n,m);
		if(Has[n*10+m]){
			k=(k-Has[n*10+m])%(i-Has[n*10+m])+Has[n*10+m];
			printf("%lld\n",Got[k]/10);return 0;
		}Has[n*10+m]=i;Got[i]=n*10+m;
	}printf("%lld\n",n);
	return 0;
}

---

## 作者：HYdroKomide (赞：2)

### 题意：
给定一个数列 $a$ 的前两项，且这个数列满足 $a_i=a_{i-2}\times a_{i-1}\bmod 10$。求此序列的第 $k$ 项。

### 思路：
乍一看题想到暴力递推，但是 $1\le k\le 10^{12}$ 让我们必定 TLE。但是还是能够得到 $30$ 分的部分分。代码量很小：

```cpp
#include<cstdio>
int n,m,k,a[1000001];
int main(){
    scanf("%d%d%d",&n,&m,&k);
	a[1]=n;
	a[2]=m;
	for(int i=3;i<=k;i++)a[i]=(a[i-1]*a[i-2])%10;
	printf("%d\n",a[k]);
    return 0;
}
```

但是在纸上随便写几组数据我们便发现我们可以找到数列中的规律。



比如：$n=2,m=2$ 的序列就是：$2,2,4,8,2,6,2,2,4,8,2,6,2......$。

循环节为 $6$。

继续往下推我们还会发现：

- 数字 $0,1,5,6$ 会死循环。
- 数列前两个数可能不属于循环
- 循环节不会超过 $6$。
- 只要连续两个数与之前某连续两数相同，说明找到了循环。

所以我们无需将序列全部递推出来。只需推出前面 $20$ 项左右并找出其循环节，再将 $k$ 取模即可。

由此，我们不妨进行如下操作：

1. 递推出此序列的前 $20$ 项。
2. 随意在此序列（除前两个数）找到连续的两个数充当基准数，然后向后循环查找。
3. 找到两个连续的数与基准数相同，求出循环节。
4. 将 $k$ 取模。

于是此题就变成了模拟。

### 程序如下：
```cpp
#include<cstdio>
#define ll long long
#define rll register long long
ll n,m,k,a[21],key1,key2,len;
int main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    a[1]=n,a[2]=m;
    for(rll i=3;i<=20;i++)a[i]=a[i-1]*a[i-2]%10;//先递推法求出前20项
    key1=a[8],key2=a[9];//设a[8]和a[9]为基准数
	if(k<=20){//如果k小于等于20就没必要继续下面的操作
		printf("%lld\n",a[k]);
		return 0;
	}
    if(key1==key2&&(key1==0||key1==1||key1==5||key1==6)){//特判判0,1,5,6的死循环
    	printf("%lld\n",key1);
    	return 0;
	}
    for(rll i=9;i<20;i++)
    	if(a[i]==key1&&a[i+1]==key2){//循环查找循环节，如果查到了就与基准数下标相减得出循环节
    		len=i-8;
    		break;
    	}
    k-=7;//取模之前先减去循环节之前的部分
	k%=len;//取模
	printf("%lld\n",a[k+7]);//在数组中的下标还要加上循环节之前的部分
    return 0;
}
```
### THE END

---

## 作者：Cripple_Abyss (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P7840)


## Description ：
- 已知 $a_1 = n $ ，$a_2 = m $ 且 $a_i (i>2) = a_{i-1} * a_{i-2}\  mod\  10$ 。

- 给定 $k$ , 求 $a_k$ 的值 。

## Solution :
- 根据抽屉原理知 ：$a_i$ 的值必有循环 。

- 暴力模拟找循环节 。

- 设从 $a_{st}$ 的位置开始循环，到 $a_{ed}$ 的停止循环，循环的值存在数组 $ans$ 中 （$ans_0 = a_{ed}$）。

- $p=(k-st+1)\ mod\ (ed-st+1)$ , $a_k=ans_{p}$ 

## Code：
```cpp
#include <cstdio>
typedef long long ll;
inline void in(ll &x) {
	x=0;
	ll f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	x*=f;
}
inline void out(ll x) {
	if (x<0) putchar('-'),x=-x;
	if (x>9) out(x/10);
	putchar(x%10+'0');
}
ll n,m,k,a[100005],st,ed,len,ans[1000005],x;
int main() {
	in(a[1]),in(a[2]),in(k);
	for (int i=3; i<=k; ++i) {
		a[i]=(a[i-1]*a[i-2])%10;
		for (int j=2; j<i; ++j) {
			if (a[j]==a[i]&&a[j-1]==a[i-1]) {
				st=j-1;
				ed=i-2;
				break;
			}
		}
		if (st) break;
	}
	if (!st) out(a[k]);
	else {
		len=ed-st+1;
		for (int i=1,p=st; i<len; ++i,++p) ans[i]=a[p];
		ans[0]=a[ed];
		x=(k-st+1)%len;
		out(ans[x]);
	}
	return 0;
}


```

---

## 作者：Lonely_NewYear (赞：1)

# 洛谷 P7840 题解

## 题目分析

因为 $a_{i-2}$ 和 $a_{i-1}$ 都只能为 $0$ 到 $9$，那么这两个数一起只有 $100$ 种可能性，也就是说再计算 $100$ 次 $a_i$ 后必然会出现与之前相同的情况，就出现了循环。所以可以记录一下循环节，然后就是小学的周期问题了。

## 代码

```cpp
#include<cstdio>
using namespace std;
int f[10][10],a[110];
int main()
{
	long long k;
	scanf("%d%d%lld",&a[1],&a[2],&k);
	for(int i=0;i<10;i++)for(int j=0;j<10;j++)f[i][j]=-1;
	if(k==1||k==2){printf("%d",a[k]);return 0;}
	for(int i=3;;i++)
	{
		if(f[a[i-2]][a[i-1]]!=-1)//如果当前情况已经出现过
		{
			k=(k-f[a[i-2]][a[i-1]])%(i-f[a[i-2]][a[i-1]])+f[a[i-2]][a[i-1]];//注意这里的计算
			break;
		}
  		//如果还没出现过，就记录一下
		a[i]=a[i-2]*a[i-1]%10;
		f[a[i-2]][a[i-1]]=i;
	}
	printf("%d",a[k]);
	return 0;
}
```

谢谢观看！

---

## 作者：EgLund (赞：1)

令 $f_n$ 表示斐波那契数列 $1,1,2,3,5,8,\cdots$。

结论 ：结果为 $n^{f_{k-2}}*m^{f_{k-1}} \mod 10$。( 取 $f_0 = 0,f_{-1} =1 $）

注意到，一个数的 $k$ 次方的个位数 $S_k$ 是以 $4$ 为周期的数列。

于是我们打出 $f_n \mod 4$ 的值，为 $\text{4 1 1 2 3 1 periods} $（注意取第 $0$ 个数字为 $4$ 而非 $0$ 因为 $4u(u \ge 1)$ 次方和 $4$ 次方等价，而不一定与 $0$ 次方（即 $1$）等价），和每个数次方的个位数（详见代码）。

我们特判 $k = 0 \text{ or } 1$，然后利用 $f_n \mod 4$ 的周期，快速求出$n^{f_{k-2}} \mod 10$ 和 $m^{f_{k-1}} \mod 10$，最后相乘即可。

```cpp

const int f[]={4,1,1,2,3,1,0};
int n,m;long long k;
const int period[10][5]={{0,0,0,0,0},{0,1,1,1,1},{0,2,4,8,6},{0,3,9,7,1},{0,4,6,4,6},{0,5,5,5,5},{0,6,6,6,6},{0,7,9,3,1},{0,8,4,2,6},{0,9,1,9,1}};
int main()
{
	input::getIntegral(n);
	input::getIntegral(m);
	input::getIntegral<long long>(k);
	if(k==1){printf("%d",n);return 0;}
	if(k==2){printf("%d",m);return 0;}
	int k1=f[(k-1)%6],k2=f[(k-2)%6];
	int or1=period[m][k1],or2=period[n][k2];
	printf("%d",or1*or2%10);
}
```

---

## 作者：qwq自动机 (赞：1)

## Part 1. 审题 +分析题意

本题实际上是求这个数列的第 $n$ 项的值：

$$
a_i=
\begin{cases}
n&&(i=1)\\
m&&(i=2)\\
a_{i-1}\cdot a_{i-2}\mod 10&&(i\geq 3)
\end{cases}
$$

别的没了？没了。

## Part 2. 思路

首先 Subtask 1 里面的 $k\leq10^6$，那么显然就可以直接 $O(k)$ 模拟。代码就不放了（因为非常简单）。

那么注意到 Subtask 2 的 $k\leq10^{12}$，显然不是 $O(k)$ 的暴力可以搞定的。考虑到 $a$ 的每一项均 $<10$ 且为整数，那么对于每一个 $a_i$，有序数对 $(a_{i-1},a_{i-2})$ 的取值仅有 $100$ 种可能。那么可以由鸽巢原理知重复 $100$ 次以内必定会出现重复的两个连续的数（即循环节长度 $\leq 100$）。那么我们可以记录每一个数对第一次出现的位置，然后对于每一个计算出的新项都找一遍前面两个数是否出现过，若出现过则直接找出循环节长度然后将 $k$ 膜掉之后再跑一遍 $O(k)$ 暴力qwq；否则标记该数对第一次出现的时间并将 $k$ 减一（抛弃掉循环节开始前的部分，让后面暴力的时候可以直接从重复处开始）。

emm……有一点抽象啊 XD 具体看代码里的注释吧。注意特判 $k=0$ 和 $k=1$ 的情况，而且由于 $k\leq 10^{12}$ 用 `int` 会溢出！

## Part 3. 码

~~干嘛一脸期待地看着我？~~

C++：

```cpp
#include <iostream>
int tail = 0, vis[15][15] = {0};
int n, m;
long long k;
int main()
{
    std::cin >> n >> m >> k;
    if (k == 1)
    {
        std::cout << n;
        return 0;
    }
    if (k == 2)
    {
        std::cout << m;
        return 0;
    }
    // 上面是输入+特判
    vis[n][m] = 2; // (n, m) 在第二个位置第一次出现
    k -= 2;
    for (int i = 3; ; i++) // 循环找循环节
    {
        int t = n * m % 10;
        n = m;
        m = t;
        k--; // 减掉非循环节部分
        if (k == 0) // 没找到循环节就结束了
        {
            std::cout << m;
            return 0;
        }
        if (vis[n][m]) // 前面出现过
        {
            k %= i - vis[n][m]; // i - vis[n][m] 为循环节长，将 k 膜掉
            for (int j = 1; j <= k; j++) // 再暴力跑一遍
            {
                int l = n * m % 10;
                n = m;
                m = l;
            }
            std::cout << m;
            return 0;
        }
        vis[n][m] = i; // 记录第一次出现的地方
    }
    std::cerr << "Bad judger!!!"; // 评测姬出锅了 qwq
    return 0;
}
```

Python：

```python
vis = [[0 for i in range(11)] for j in range(11)]
s = input().split()
n = int(s[0])
m = int(s[1])
k = int(s[2])
if k == 1:
    print(n)
    exit()
if k == 2:
    print(m)
    exit()
'输入 + 特判'
vis[n][m] = 2
k = k - 2
i = 3
while True:
    t = n * m % 10
    n = m
    m = t
    k = k - 1 # 减掉非循环节部分
    if k == 0: # 没找到循环节就结束了
        print(m)
        exit()
    if vis[n][m] != 0: # 出现过
        k = k % (i - vis[n][m]) # 用循环节长度膜 k
        for j in range(1, k + 1): # 然后再暴力一遍
            l = n * m % 10
            n = m
            m = l
        print(m)
        exit()
    vis[n][m] = i
    i = i + 1
print('QwQ') # 评——测——姬——
```

嗯，就这样吧。

---

## 作者：Fan_Tuan (赞：0)

## 题意：
给出一个序列 $a$ 的前两项 $n$ 和 $m$，对于 $i > 2$，$a_i = a_{i - 1} \times a_{i - 2}$，求$a_k$。

## 思路：
矩阵加速。对于这个序列，我们将其前几项算出之后 $n$，$m$，$n \times m$，$n \times m^2$，$n^2 \times m^3$，$ \ldots$，可以看出 $n$，$m$ 的指数满足斐波那契数，第 $k$ 项 $n$ 的指数为 $f_{k-2}$，$m$ 的指数为 $f_{k-1}$，我们可以用矩阵快速求出这两项的值，由于这两项的值很大，我们根据欧拉定理，对 $n$ 和 $m$ 的指数对 $\phi_{10}$ 取模，那么 $a_k = m^{f_{k-1} \bmod \phi_{10}} \times n^{f_{k-2} \bmod \phi_{10}} \bmod 10$。

## 代码：

```cpp
#include <cstring>
#include <cstdio>
#include <queue>
#include <iostream>
#include <algorithm>
#include <string>
#define int long long
using namespace std;

inline int read() {
    int f = 0, s = 0;
    char ch = getchar();
    while (!isdigit(ch)) f |= ch == '-', ch = getchar();
    while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
    return f ? -s : s;
}

void print (int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) print (x / 10);
    putchar(x % 10 + '0');
}

const int mod = 4;
int n, k, m;

struct matrix {
    int n, m;
    int z[3][3];
    matrix () {
        n = m = 0;
        memset (z, 0, sizeof z);
    }
};

matrix operator*(const matrix &a, const matrix &b) {
    matrix c;
    c.n = a.n;
    c.m = b.m;
    for (int i = 1; i <= c.n; i++)   
        for (int j = 1; j <= c.m; j++) 
            for (int k = 1; k <= a.m; k++) 
                c.z[i][j] = ((c.z[i][j] % mod) + ((a.z[i][k] % mod) * (b.z[k][j]) % mod) % mod);
    return c;
}

matrix mi(matrix a, int b) {
    matrix ans, base = a;
    ans.n = ans.m = a.m;
    for (int i = 1; i <= a.m; i++) ans.z[i][i] = 1;
    while(b > 0) {
        if(b & 1)
            ans = ans * base;
        base = base * base;
        b >>= 1;
    }
    return ans;
}

int qpow(int a, int b) {
	int res = a, ans = 1;
	while(b) {
		if (b & 1) ans = res * ans % 10;
		res = res * res % 10;
		b >>= 1;
	}
	return ans;
}

signed main () {
	n = read(), m = read(), k = read();
    matrix a, c;
    a.n = 2, a.m = 2;
    a.z[1][2] = a.z[2][1] = a.z[2][2] = 1;
    c.n = 1, c.m = 2;
    c.z[1][1] = c.z[1][2] = 1;
    if (k == 1) cout << n;
    else if (k == 2) cout << m;
    else {
	    c = c * mi (a, k - 3); 
	    print((qpow(n, c.z[1][1]) % 10 * qpow(m, c.z[1][2]) % 10) % 10);
    }
    return 0;
} 
```

---


# 末日的传说

## 题目描述

只要是参加 jsoi 活动的同学一定都听说过 Hanoi 塔的传说：三根柱子上的金片每天被移动一次，当所有的金片都被移完之后，世界末日也就随之降临了。

在古老东方的幻想乡，人们都采用一种奇特的方式记录日期：他们用一些特殊的符号来表示从 $1$ 开始的连续整数，$1$ 表示最小而 $n$ 表示最大。创世纪的第一天，日历就被赋予了生命，它自动地开始计数，就像排列不断地增加。

我们用 $1-n$ 来表示日历的元素，第一天日历就是：
$$1,2,\ldots,n-2,n-1,n$$
第二天，日历自动变为
$$1,2,\ldots,n-2,n,n-1$$
······每次它都生成一个以前未出现过的“最小”的排列——把它转为 $n+1$ 进制后数的数值最小。

日子一天一天地过着。有一天，一位预言者出现了——他预言道，当这个日历到达某个上帝安排的时刻，这个世界就会崩溃······他还预言到，假如某一个日期的逆序达到一个值 $m$ 的时候，世界末日就要降临。

什么是逆序？日历中的两个不同符号，假如排在前面的那个比排在后面的那个更大，就是一个逆序，一个日期的逆序总数达到 $m$ 后，末日就要降临，人们都期待一个贤者，能够预见那一天到底将在什么时候到来？

## 说明/提示

对于 $10\%$ 的数据有 $n\le10$；

对于 $40\%$ 的数据有 $n\le1000$；

对于 $100\%$ 的数据有 $n\le5\times10^4$。

所有数据均有解。

## 样例 #1

### 输入

```
5 4
```

### 输出

```
1 3 5 4 2
```

# 题解

## 作者：zqy1018 (赞：163)

我们考虑把这个问题缩小范围。

比如n=5，在决定了最小的数“1”的位置之后，剩下的几个数是2 3 4 5，但是他们

具体是多少没必要关心，我们只要关心他们的**相对大小关系**。

所以考虑完当前最小的数，算出这个数对答案的贡献，然后减掉这个贡献，

就可以转而解决一个更小的子问题。（即n-->n-1）

回到题目上，要求是求一个有m个逆序对的字典序最小的排列。

我们知道一个长度为n的排列最多有(n-1)\*n/2个逆序对，也知道一个排列的逆序对数越多，排列字典序越大。

所以如果当前m不比当前的(n-2)\*(n-1)/2（也就是减少一个数之后的最多的逆序对数）大，

就可以直接把当前的最小数放在最前面，这肯定是最优的。

反之，则考虑最小数的放置位置。

假设当前排列长为n，最小数为a，则a有n种放法，放在从左到右第i个位置时会生成i-1个逆序对

（因为它左边有i-1个比他大）。

因为m大于n-1长度排列最多所能产生的逆序数，所以a不可能放在最前面，否则不满足条件。

怎么办呢？想到之前说的逆序对越多字典序越大，我们就必须让剩下的数能构成的逆序对数尽量小，所以a要放到最后，这样m减少的最多。

放完了a，问题就变成了n-1和m-(a的贡献)的子问题，递归求解即可。时间复杂度O(n)。

```cpp
typedef long long ll;
ll n,m,a[50005];
int main(){
    scanf("%lld%lld\n",&n,&m);
    ll lst=n,fst=1;
    for(int i=1;i<=n;i++){
        ll t=(ll)(n-i)*(n-i-1)/2;
        if(t>=m)a[fst++]=i;//放头上
        else a[lst--]=i,m-=(lst-fst+1);//放最后
    }
    for(int i=1;i<=n;i++)printf("%d ",a[i]);
    return 0;
}
```

---

## 作者：ASZIIIS (赞：98)

# _~~**滑稽题解第三弹**~~_
大家好，我是一个入门一年还在入门的蒟蒻。

今天我决定不去新手村了，去一下普及练习（虐心）场。

简单数学？看起来貌似不难……

看完这个题我后悔了……简单数学真的不简单……

但是在历经千辛万苦后我还是最终把它调出来了……

说实话这还是我第一次写数学方面的题解，早就听说数学题解难写，我今天就是要尝试一下我到底能不能把数学讲明白（讲不明白预定）

———————————————————————————————————————

### 往期链接：
第一弹：一个红题带你了解绿（黄）题知识点 ([传送门](https://www.luogu.org/blog/funny-talk/funny-solution-p1427))

第二弹：从搜索到贪心——求解算法的优化（[传送门](https://www.luogu.org/blog/funny-talk/funny-solution-p1478)）

———————————————————————————————————————


------------
## 1.基本知识
### （1）逆序对
逆序对是啥？这东西说难不难，说简单也不简单。逆序对就是在一个数列当中，满足$i<j$且$a_i>a_j$($i>j$且$a_i<a_j$)的数对的个数。

逆序对最常见的求法就是归并排序求逆序对个数。（归并排序这里先不普及了）为什么归并排序能够做到这一点呢？因为逆序对的个数是可以递归地求解的：

$[l,r]$中的逆序对可以分为三类：

1. 数对的两个数都在$[l,mid]$中的逆序对
2. 数对的两个数都在$[mid+1,r]$中的逆序对
3. 数对中的两个数一个在$[l,mid]$中，一个在	$[mid+1,r]$中的逆序对

前两种好说，递归求解就是了，递归终点就是$l==r$（长度等于1的数列不可能有逆序对的，连两个数都没有）。第三种就不能再把锅甩给递归了。但是归并排序有个美妙的性质：合并有序数列的时候，如果在前面的数列未空时先插入后面的数列的数的话，就意味着前面的数列中所有还未插入的数都依次和这个后面数列的正在插入的数构成逆序对（因为前面的数排位比这个数靠前但是比这个数大）。

因为这不是本题的重点，就不细讲了。下面给大家一段归并排序求逆序对的代码，大家自行学习一下吧。

~~PS：下面的代码可以AC P1908（我相信你不会道德败坏到直接抄过去的）~~
```cpp
#include<iostream>
#include<queue>
using namespace std;
int n,a[500005];
queue<int> cup;
long long guibing(int l,int r){
    if(l==r) return 0;
    int mid=(l+r)/2;
    long long ans=0;
    ans+=guibing(l,mid);
    //求解数对的两个数都在[l,mid]中的逆序对
    ans+=guibing(mid+1,r);
    //求解数对的两个数都在[mid，r]中的逆序对
    int l_now=l,r_now=mid+1;
    //下面开始求解数对中的两个数一个在[l,mid]中，一个在[mid+1,r]中的逆序对
    while(l_now<=mid&&r_now<=r){
    //其实归并排序用for循环来写最简单也最不容易出错，这里为了便于理解使用while写法
        while(l_now<=mid&&a[l_now]<=a[r_now]){
            cup.push(a[l_now++]);
        }
        while(r_now<=r&&a[r_now]<a[l_now]){
            cup.push(a[r_now++]);
            ans+=(mid-l_now+1);
            //前面数列中所有没插入的数都和当前插入的数构成逆序对
        }
    }
    if(l_now<=mid)
    while(l_now<=mid){
        cup.push(a[l_now++]);
    }
    if(r_now<=r)
    while(r_now<=r){
        cup.push(a[r_now++]);
    }
    for(int i=l;i<=r;i++){
        a[i]=cup.front();
        cup.pop();
    }
    return ans;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    cout<<guibing(1,n);
    return 0;
} 
```

### （2）全排列
给定一个1~$n$的数列，求这个数列打乱后的所有可能的组成方式，就是全排列。比如1~3的全排列就有6种：123，132，213，231，312，321。

一个长度为$n$的数列的全排列有多少种呢？这也很好想，我们使用给各个位置依次确定数的方式来求解。对于第一位，我们有$n$种选择，因为此时所有的数都没有被确定到某个位置上；对于第二位，我们有$n-1$种选择，因为这时候有一个数已经被确定到第一位上了，所以还剩$n-1$种选择；那么这样类推的话，第i位就有$n-i+1$种选择，每个数位的选择数乘起来（因为每位的选择数是基于前一位的基础上求出来的），就是$n!$种结果了。

全排列的所有情况可以按照将这个数列的每一个数都按顺序对应转换为$n+1$进制数的一个数位后得到的数的大小来进行排序（简而言之就是将数列中的每个数都想成一个ASCII码（这个数很可能大于127）后将各数列按字典序排序）。基于这种排序方式的全排列推导非常之麻烦，我也没有去研究，因为没有必要，美妙的<algorithm>库已经给我们准备好了一个高效实用的函数：next_permutation()。

next_permutation()的参量有两个，前一个是进行求解的数组的第一位的指针，后一个是进行求解的数组的最后一位的后一位的指针（也就是一个前闭后开的区间）。对于数组要格外注意你是从0开始存储的还是从1开始存储的，但对于STL就没有这么多麻烦，如果你要求解下一个排列的数组是整个vector（或者其他支持单点查询的STL数据结构），那你只需要第一个参量传入$.begin()$，第二个参量传入$.end()$就完事了。

更智能的是当你的待处理数列已经是最大的全排列（即已经是一个单调递减的数列）时，这个函数就不会再对数列进行处理了，并返回**false**。而如果你的数列还可以进一步求下一全排列的话，就会进行排列并返回**true**。

当然了，如果你想将当前数列转换为前一排列，用prev_permutation()就好了。

------------
## 2.题目解法
### （1）monkey solve
不知道大家有没有听说过一种排序叫猴子排序（monkey sort，时间复杂度是$O(n!)$的）……

最简单易懂的做法，也是最容易的想法，就是模拟这个日历的演进方式了。从一个1~$n$顺次增大的序列开始，每过一天就判断一下逆序对的个数是不是$m$，就可以了。那不就简单了，把上面给的求逆序对模板的main函数魔改一下，不就是这题的代码了吗？
```cpp
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
int n,m,a[50001],b[50001];
queue<int> cup;
long long guibing(int l,int r){
//原封不动的求逆序对模板
    if(l==r) return 0;
    int mid=(l+r)/2;
    long long ans=0;
    ans+=guibing(l,mid);
    ans+=guibing(mid+1,r);
    int l_now=l,r_now=mid+1;
    while(l_now<=mid&&r_now<=r){
        while(l_now<=mid&&a[l_now]<=a[r_now]){
            cup.push(a[l_now++]);
        }
        while(r_now<=r&&a[r_now]<a[l_now]){
            cup.push(a[r_now++]);
            ans+=(mid-l_now+1);
        }
    }
    if(l_now<=mid)
    while(l_now<=mid){
        cup.push(a[l_now++]);
    }
    if(r_now<=r)
    while(r_now<=r){
        cup.push(a[r_now++]);
    }
    for(int i=l;i<=r;i++){
        a[i]=cup.front();
        cup.pop();
    }
    return ans;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        b[i]=i;
    }
    while(guibing(1,n)!=m){
    //模拟日历一天天的进程
    	next_permutation(b+1,b+n+1);
        //下一天
    	for(int i=1;i<=n;i++) a[i]=b[i];
        //求逆序对不能把原数组排序
    }
    for(int i=1;i<=n;i++){
    	cout<<b[i]<<" ";
    }
    return 0;
}
```

但是这样子的话，如果题目卡你一波极限数据（也就是日历的最后一天逆序对个数达到最大时的个数），那你这个算法的时间复杂度就会原地直线起飞，变成$O(n!~log~n)$的复杂度。因为我们前面讲过，全排列一共有$n!$种，每次求逆序对的复杂度是$O(n~log~n)$的，乘起来就是$(n!+1)~log~n$次运算，也就是$O(n!~log~n)$的时间复杂度。事实就是，上面的代码交上后TLE了八个数据点。
### （2）正解
~~_我知道你们读了这么久一直在期待这个。_~~

有人会问，你之前讲了那么多东西，什么逆序对，全排列，有什么用吗，我们自己去查不就好了？但其实上面讲的基础知识并非毫无用处，正解就在其中：

我们每将一个无逆序对的数列（即所有数都单调递增）中两个数交换时，就会使得数列不再单调递增，也就产生了逆序对。而求下一排列的本质不就是将数的顺序交换吗？

所以这题的正解不是让你模拟日历，然后每天求逆序对，而是让你根据数学原理来造题目所要的数列。

那怎么造呢？这个地方就有点难想了。想一下我们之前讲过的求全排列个数的思想：按位确定数的位置。这题的关键也和之前讲过的归并排序求逆序对的个数的方法类似：如果我们按照所求数列的位置从前向后的顺序确定了一个数$a_i$的位置,那么所有还未确定的数中所有小于$a_i$的数都和$a_i$构成了逆序对（$a_i$比这些数都大，但是却排在这些数的前面）。简单来说，如果我们在一个从0开始存放的数组$a$里存放所有还未确定位置的数的话，那么在某个位置放置$a[i]$的话，就意味着会和数组里排在$a[i]$前的$i$个数产生$i$个逆序对。

但是这还没结束，因为我们还没定下来给各个位置安放数的标准。其实接下来就很简单了，只要你能明白上面讲的关键部分，下面其实就很好想了。按照上面的理论，我们很容易知道一个长度为$n$的数列最多可以产生$\sum_{i=1}^{n-1}$（即1 ~ $n-1$的所有自然数的和）个逆序对。这个题要求我们在产生$m$个逆序对的同时使得数列的字典序最小，但是字典序小的数列逆序对又不一定多，所以这就要求我们贪心地来安放：我们设在当前位置$i$还未产生的逆序对个数为$k$：如果剩下的长度为$l$的数列能够产生的逆序对个数也就是$\sum_{i=1}^{l-1}$（也就是$\frac{l(l-1)}{2}$）比$k$大的话，我们就可以把当前最小的数也就是$a[i]$放到当前位置上（接下来的$l$个数足够产生）；否则就将$a[k-\frac{l(l-1)}{2}]$放到当前位置上，来产生$k-\frac{l(l-1)}{2}$个逆序对（在当前位置放置$a[k-\frac{l(l-1)}{2}]$可以使字典序最小）（如果还是放最小的数的话接下来无论如何也不可能产生$k$个逆序对了），这样子再继续解决下一个位置就好了。

所以这题就是要我们维护一个数组，来存放所有未确定位置的数，然后从前向后贪心地确定所求数列各位置的数就好了。

维护也不难，C++自带的STL库里有种数据结构叫vector就支持单点删除，复杂度是$O(n)$的，叫$.erase()$，括号里传入的是要删除的数据点的迭代器（相当于指针）。

我的代码如下：
```cpp
#include<cstdio>
#include<vector>
using namespace std;
long long n,m,s,now;
//因为n*(n-1)很可能大于int范围，所以用long long 
vector<int> v;
int main(){
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;i++) v.push_back(i);
    s=(n*(n-1))>>1;
    //计算能够产生逆序对的个数
    for(int i=n-1;i>=0;i--){
        s-=i;
        //计算接下来的数列最多能产生逆序对的个数
        if(m>s){
        //如果接下来的数列产生的逆序对个数不够用的话
            now=m-s;
            m=s;
        }else now=0;
        printf("%d ",v[now]);
        v.erase(v.begin()+now);
        //这个数既然用过了，那就将它从未安排的数组中删除
    }
    return 0;
}
```
### （3）优化
如果你仔细阅读上面的题解的话，你就会发现，这个数列可以分为三部分：

1. 从1到某个数的连续自然数上升序列
2. $m-\frac{l(l-1)}{2}$
3. 剩余数组成的单调递减序列。

这也很好解释：首先我们贪心，使得字典序尽可能小，那么必然得到第一部分；之后开始出现剩余数能构成的逆序对个数不够的情况，这时必然还有m个逆序对未产生，所以得到第二部分；剩下的数为了构成$\frac{l(l-1)}{2}$个逆序对，必然要单调递减，于是得到第三部分。

上面的标程用了400多毫秒，下面的优化算法只用了40多毫秒
```cpp
#include<cstdio>
#include<vector>
using namespace std;
long long n,m,s,i,j,k;
bool use[50005];
int main(){
    scanf("%lld %lld",&n,&m);
    s=(n*(n-1))>>1;
    for(i=1;i<=n;i++){
    //打印第一部分
        s-=(n-i);
        if(m>s){
        //终止第一部分的打印，打印第二部分
            printf("%lld ",i+m-s);
            use[i+m-s]=true;
            break;
        }
        printf("%lld ",i);
        use[i]=true;
    }
    for(j=n,k=n;j>i;j--,k--){
    //打印第三部分
    	if(use[k]){
    		j++;
    		continue;
        }
        printf("%lld ",k);
    }
    return 0;
}
```


------------
看完这篇题解，你有没有对数学有更好的理解了呢？好的，本期的_~~**滑稽题解**~~_到这里就结束了。让我们下期再见吧！

---

## 作者：ingu (赞：83)

#不看题解自己研究得虽然慢，但真正收获的却是自己。
如何让逆序对数为m的序列字典序最小呢？
假设位置p是第一个非原始序列的位置，那这个点应该尽量靠右，才能使得字典序最小。而为了保证有m个逆序对，要求p后面的逆序对数尽量大。怎么才能尽量大呢？当然是降序排列。

这样问题就转成找点p，同时在找到p时还需要知道m-后面所有逆序对数剩余的值，这个值要在点p身上修改。

则我们现在可以直接输出序列。
1）p之前的部分按照顺序输出
2）输出p，如果后面逆序对不够，则需要修改p点再输出。
3）逆序输出p之后的部分，注意如果p之前改点了，需要多判断一下。

```
#include <iostream>
using namespace std;
int main() {
	int n,m;
	cin>>n>>m;
	int p=n,c=0;
	for (int s=1; m>0 ;s++,p--) {
		m-=c=min(s,m);
	}
	for(int i=1;i<p;i++){
		cout<<i<<' ';
	}
	cout<<p+c<<' ';
	for(int i=n;i>=p;i--){
		if(i!=p+c){
			cout<<i<<' ';
		}
	}
	return 0;
}
```

---

## 作者：ViXbob (赞：13)

想学更多姿势就进入我的博客来查看吧[戳这里(\*/ω＼*)吧](http://www.vixbob-lwc.pw)

看着题解里，清一色的都是一种方法，~~作为一个暴力数据结构爱好者~~，我决定用数据结构$A$掉这题

首先我们要会划分树，它的本质是一颗线段树，但是支持静态区间第$k$大

这里我大致讲讲，就是像平衡树一样，这颗线段树的每一个节点，维护一个$size$值，利用$size$值来进行二分，$k$小于左儿子$size$就往左，否则往右并更新$k$，$k=k-t[ls].size$

下面是解题思路，我们发现对于每一个没有选的位置可以产生的最大逆序对贡献是$(n-1)*n/2$，定义$n$为还可以选的数的个数,$res$用于储存最大值，那么我们在剩余的数中$lowerbound$一下找到$m-res[n-1]$的位置$k$，并用线段树求出第$k$大的数，这就是当前这个位置的答案，并在划分树中删除这个数

值得注意的是，如果$m-res[n-1]>0$,$m$要被更新为$m-k+1$，这个也很好理解，$k-1$是当前位置的这个数可以产生的逆序对的个数，所以要减去贡献值进行对$m$的更新

下面放出代码
```
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define ls p<<1
#define rs p<<1|1
#define mid (l+r>>1)
#define ull unsigned long long
#define LL long long
using namespace std;
const int MAXN=5e4+10;
const LL inf=1LL<<40;
LL num[MAXN],n,m,w[MAXN];
struct node{LL size,sum;}t[MAXN<<2];
inline LL read(){
    char ch=getchar();LL u=0,f=1;
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){u=u*10+ch-48;ch=getchar();}return u*f;
}
inline void pushup(int p){
    t[p].size=t[ls].size+t[rs].size;
}
inline void build(int l,int r,int p){
    if(l==r){t[p].sum=r;t[p].size=1;return;}
    build(l,mid,ls);
    build(mid+1,r,rs);
    pushup(p);
}
inline void modify(int l,int r,int pos,int p){
    if(l==pos&&r==pos){t[p].sum=0;t[p].size=0;return;}
    if(pos<=mid)modify(l,mid,pos,ls);
    else modify(mid+1,r,pos,rs);
    pushup(p);
}
inline LL query(int l,int r,int k,int p){
    if(l==r)return t[p].sum;
    if(k<=t[ls].size)return query(l,mid,k,ls);
    else return query(mid+1,r,k-t[ls].size,rs);
}
int main(){
    n=read();m=read();
    //for(register int i=1;i<=n*4;i++)t[i].MIN=inf,t[i].MAX=-inf;
    for(register LL i=1;i<=n;i++)
        num[i]=i,w[i]=i*(i-1)/2;
    build(1,n,1);w[0]=-inf;
    for(register LL i=n;i>=1;i--){
        LL res=(i-2)*(i-1)/2,ans=0;
        LL pos=lower_bound(w+1,w+1+i,m-res)-w;
        //if(m-res>0)m=m-res;
        //if(w[pos]>0)m-=(i-1);
        if(m-res>0)pos=m-res+1;
        m-=pos-1;
        ans=query(1,n,pos,1);
        modify(1,n,ans,1);
        printf("%lld ",ans);
    }
    return 0;
}

```

---

## 作者：ix35 (赞：12)

首先一看到这个问题，想到的是——会不会序列字典序越大，逆序对就越多呢？

然而事实上并不是这样，例如：

1 4 3 2有3个逆序对

2 1 3 4只有1个逆序对

因此这个命题是错误的，那就要另想办法，这里我稍微枚举了一下，发现了一个规律：

答案的序列都可以划分为三个部分：开头的升序部分，中间一个单独的数，结尾是一段降序部分，例如测试数据的5 4：

答案是1 3 5 4 2，其中1是开头的升序部分，3是中间的分界数，5 4 2是最后的降序部分。

下面就是具体的算法设计了，一个长度为n的排列最大逆序数为n(n-1)/2，那么假如i是满足i(i-1)/2>=m的最小整数，那么我们不需要改变前面的数，只需要调整最后i个数即可使逆序数达到m，而且字典序尽量小。

然而我们并不需要把最后i个数统统降序排，而只需要将最后i-1个数作为降序部分，并选出一个数放在第i位即可：

因为最后i-1个数降序排列之后并不能达到m个逆序对，但我们希望第i位的数尽量小（字典序最小），因此除去i-1个数的贡献外剩余的逆序对就由第i位提供，选出最后i个数中大小合适的一个数放在第i位（具体来说是最后i个数中第(n-(i-1)\*(i-2)/2)大的那个，因为它恰好能提供这么多的逆序对）即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m;    //某测试点要开long long才能过
void solve_ (int x,int y) {    //表示调整最后x位，并将第y大的数填入第x位，无需递归
	for (int i=n;i>x;i--) {
		cout << (n-i+1) << ' ';    //第x位前无需调整，升序输出
	}
	cout << (n-y) << ' ';    //第x位输出剩余x个数中第y大的数
	for (int i=n;i>=(n-x+1);i--) {
		if (i!=(n-y)) {
			cout << i << ' ';    //最后x-1个数降序输出，注意判一下是否在前面输出过
		}
	}
	return;
}
int main () {
	cin >> n >> m;
	if (m==0) {    //0的特判
		for (int i=1;i<=n;i++) {
			cout << i << ' ';
		}
		return 0;
	}
	for (long long i=2;i<=n;i++) {
		if ((i*(i-1))/2>=m&&((i-1)*(i-2))/2<m) {
			solve_(i,(i*(i-1))/2-m);
			break;
		}
	}
	return 0;
}
```

---

## 作者：zhyh (赞：10)

题意就是找到逆序对数为 $M$ 的最小字典序的序列。

对于一个序列 $(a_n)$，记其逆序对数为 $f(a_n)$，则有 $$0≤f(a_n)≤n*(n-1)/2$$并且可以使 $f(a_n)$取到其中任意一个数 $m$。证明即假设存在 $f(a^{'}_n)=m+1$，由反证知该 $a_n$中必存在相邻的逆序对，交换即可。

那么对于题中的 $M$，先找到满足 $n*(n-1)/2≥M$ 的最小值 $n$，并使构造序列的前 $(N-n)$ 项仍然升序，只对后 $n$ 项进行操作，也就构成了一个新的子问题 $a_n$（序号改为1~$n$）。然后在 $n$ 项中找出一个数 $a_i$，置于第一个位置，此时 $a_i$ 与后面形成$(i-1)$个逆序对，且序列 $a_{n-1}$构成子问题。我们发现，$f(a_{n-1})$ 越大，$a_i$越小，则找到 $i$，使得令 $a_{n-1}$ 全部降序，且满足$(n-1)*(n-2)/2=M-(i-1)$ 即可，直接求出 $i$。

复杂度 $O(N)$，代码：
```cpp
#include <cstdio>
using namespace std;
long long N,M,p=1,q;//p为an第一项的位置
int main()
{
    scanf("%lld%lld",&N,&M);
    for(;(N-p)*(N-p-1)/2>=M && p<=N;p++)printf("%lld ",p);//保持升序
    if((N-p+1)*(N-p)/2!=M){q=p+M-(N-p)*(N-p-1)/2;printf("%lld ",q);}//ai
    for(;N>=p;N--)if(N!=q)printf("%lld ",N);printf("\n");//构造降序
}
```

---

## 作者：LesterYu (赞：10)

~~蒟蒻第一篇题解，求过……~~

第一眼看到这道题目的想法就是递归……

本题要求找出逆序对=m且字典序最小的一组排列，

以样例为例，很明显 1,2,5,4,3 是逆序对为3时的最优排列，

这时肯定要把 3 放在最后，

而当m值在 3（1+2）和 6（1+2+3）之间时（不含3），

显然最好要把 2 放在最后；

而 2 放在最后得到的最小逆序对是 3 ，

所以将m值减去 3 后得到的剩余需要的逆序对值

就是需要比 2 大的 3,4,5（现在在2前面）的排列来得到了

于是通过递归就可以把需要置后的数排列好

下面是蒟蒻的丑陋代码（~~不喜勿喷~~）
```cpp
#include<cstdio>
using namespace std;
int n,m,k,num,posi;
int a[50001],add[50001];
bool judge,used[50001];

void morijianglin(int x,int y)
{
    if(x<=0)//如果位置置后的数都已放好,则返回 
    {
        judge=true;
        return;
    }
    for(int i=y;i>=0&&judge==false;i--)
    {
        if(add[i+1]>=x&&add[i]<x)
        { //减去小于当前仍需要的逆序对值的最大num值 
            a[k]=n-i-1,k--;//把放置位往前挪一格 
            used[n-i-1]=true;
            morijianglin(x-i-1,i+1);//减去最小的可能逆序对值 
        }
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    k=n;
    for(int i=1;num<=m;i++)//用num[i]数组存储 (1+2+…+i)的值 
    {
        num+=i,add[i]=num,posi=i;
    }
    morijianglin(m,posi);//posi存储离m最近的num[i]值（时间优化） 
    num=1;
    while(used[num]==true) num++;
    for(int i=1;i<=n;i++)
    {
        if(a[i]==0)
        {
            a[i]=num;
            used[num]=true;
            while(used[num]==true) num++;//找到未摆放的最小的数 
        }
    }
    for(int i=1;i<=n;i++) printf("%d ",a[i]);
    return 0；
}
```

---

## 作者：不存在之人 (赞：8)

这道题需要对排列有深刻的理解和认识

给出逆序对的个数，求改逆序对个数的字典序最小的排列

那么既然是最小，那么一开始一段肯定是升序，一直到某个数后才开始改变

即$1$ $2$ $3$$……$ $n-1$ $n$ $a$ $b$ $c$ $d$$……$

类似这样

那么我们要求出这个$n$在哪里

要字典序最小，就需要$1$到$n$这一段最长

也就是说在$a,b,c,d$后面有尽量多的逆序对

当数列为$n$ $n-1$ $n-2$$……$$1$时逆序对最多

逆序对个数就是$n-1+n-2……+1$

那么我们就可以从小到大枚举$a$ $b$ $c$$……$的长度，算出最多逆序对的个数

找到一个临界值，即第一次逆序对个数第一次大于$m$的时候
这个时候就可以根据长度求出$n$了

所以$1$到$n-1$直接输出

为什么不输出$n$呢

因为不一定后面的逆序对刚好为$m$

所以需要对$n$这个位置做调整，使得逆序对为$m$

设从$n+1$开始往后的长度逆序对个数为$len$(注意不包括$n$)
那么假设$m-len=x$

那么n的位置就输出$n+x$

因为后面的序列是$n+1n+3……$

比$n+x$小的有$n+1,n+2……n+x-1$刚好$x$个数

就把差值补上来了。

然后后面就逆序输出就行了。

具体看代码
```cpp
#include<cstdio>
#include<algorithm>
#define REP(i, a, b) for(int i = (a); i < (b); i++)
#define _for(i, a, b) for(int i = (a); i <= (b); i++)
using namespace std;
const int MAXN=51234;
int a[MAXN],n,m;
int main()
{
    scanf("%d%d",&n,&m);
    int p=n,c;
    for(int s=1;m;p--,s++)
    {
        if(m>s) m-=s;
        else {c=m;m=0;}
    }
    REP(i,1,p) printf("%d ",i);
    printf("%d ",p+c);
    for(int i=n;i>=p;i--)
        if(i!=p+c)
            printf("%d ",i);
    puts("");
    return 0;
}
```

---

## 作者：fallingdust (赞：4)

# P1338 末日的传说 题解

## 吐槽

其实，我今天本来是想去写一下代码难度不高，但是比较需要思考的题目
（本来是想说比较需要智力的题目，想了想，算了......）

言归正传，这道题目，看完之后，我其实有点懵（**N+1进制？！！**），题面：
>1, 2, 3, … N
>第二天，日历自动变为
>1, 2, 3, … N, N-1
>……每次它都生成一个以前未出现过的“最小”的排列——把它转为N+1进制后数的数值最小。

我在想：N+1进制？？什么鬼......
再认真看一下样例，才发现：**逆序**才是有用的.....
>他还预言到，假如某一个日期的逆序达到一个值M的时候
（这就是答案了<_<）

OK,那么，逆序大家都应该是了解的，应为题面上面有。
>假如排在前面的那个比排在后面的那个更大，就是一个逆序

好的，吐槽完毕，现在：
##题目分析

> * 1、问题规模
> * 2、可实现的方法
> * 3、正解&分析

###1.问题规模

>对于10%的数据有N <= 10。
>对于40%的数据有N <= 1000。
> **对于100%的数据有 N <= 50000**。
>所有数据均有解。

N<=50000,明显，O（N$^2$）解决不了，所以试试O（N$log n$）O（N）能否解决
PS：O（1）的......说实话，讲道理不存在......

####看题目，就会很自然的想：**线性复杂度**能不能解决？（O（N））
不急，先看。

###2.可实现的方法
> * 暴力（枚举全排列）
> * 神奇思路

很明显，枚举全排列暴力的做法，代码量不多，而且不难（无论是**手写**还是用**next_permutation()**），但是，你可能只能过1~4个点。

代码的话......我比较懒，没打，就不贴了......

现在，关键点到了：如何用一种思路把问题**简化**到**线性复杂度**
假设，你是一家公司的董事长，你要做一个项目，但是你不想做所有的步骤，怎么办？？很简单，你做其中的一步，然后把它交给你的秘书，让他（她，或者......它<_<）帮你完成剩下所有的，然后你做完最后一步之后，宣布：项目完成，然后向投资方交差，然后继续......
OK，那么，如果你是秘书，你该干什么？（这个问题，排除对“它”的询问）很简单，**你学习一下你的老板**，把问题分解，交给下属，然后这样一步一步下去，再传上来，一人做一步，最后，完美finish。
（**递归的思路**，线性的复杂度（**对于本题**））

现在，我们来分解一下问题，显然，假设你现在正在处理第i个数，前面都处理完了，现在还需要now个逆序，你该如何解决？？

解决前，我们应该了解一下：1、2、3~n个数，逆序最多有多少个

最少的逆序，很显然：1、2、3、······n   总共0个
做多：n、n-1、······1   总共多少个？
现在就是本问题用到的第一个（貌似也是最后一个）数学公式
**高斯求和**
对于第1个数，它的逆序个数：n-1 (从第n-1到1)
对于第2个数，它的逆序个数：n-2 (从第n-2到1)
······
第n-1个数，它的逆序个数：1
第n个数，它的逆序个数：0

归纳：逆序和（n-1+1）$*$（n-1）$/$ 2=（n-1）$*$（n-1）$/$ 2
推论：对于第i个数，i及i以后所有数的最大逆序个数和（倒叙）：
**（（n-i）$*$（n-i-1）$/$2）**
所以:用递归的思路，对于第i个数，你只要判断它放在哪，于是，神奇思路：

因为：假设逆序数相同，要求字典序最小
所以：越小的数向前放越好
所以：一层层用这种贪心思路放下去，可以保证最优解

所以**核心思想**：
假设对于第i个数的可造成的最大逆序数：（（n-i）$*$（n-i-1）$/$2）
设这个为S
如果这个S>=now（目前需要的逆序数个数）
就放在目前数组（ans数组）的开头

> * PS：为什么等于也放？这个大家想一想就知道了，我懒得码字证明了，对不起啦！！！

反之，就放在末尾。（为了防止出现后面所有数倒叙都不成立的情况）

OK，题目分析结束，代码如下（仅供参考。。。）
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <iostream>
using namespace std;

#define ll long long
#define mx(x,y) x>y?x:y
#define mn(x,y) x<y?x:y
#define _e putchar(' ')
#define _v putchar('\n')
#define BF_N 1<<17

char buf[BF_N],sl,sr;
FILE *fin;
char gc() {
	return sl==sr&&(sr=(sl=0)+fread(buf,1,BF_N,stdin),sl==sr)?EOF:buf[sl++];
}
int Read() {
	int ans=0,k=1;
	char c=gc();
	while(!isdigit(c)) {
		if(c=='-')k=-1;
		c=gc();
	}
	while(isdigit(c)) {
		ans=ans*10+c-'0';
		c=gc();
	}
	return k*ans;
}

long long n,m,fi=1,la;
long long ans[1000005];

void init(){
	scanf ("%lld%lld",&n,&m);
	la=n;
	return;
}

#define he(i) ((n-i)*(n-i-1)/2)

void work(){
	long long now=m;
	for (long long i=1;i<=n;i++){
		if (he(i)>=now)
			ans[fi++]=i;
		else
			ans[la--]=i,now-=(n-i);
	}
	for (int i=1;i<=n;i++)
		printf ("%lld ",ans[i]);
	return;
}

int main(){
	init();
	work();
	return 0;
}


```

各位自己体会一下啊，我累了，溜了！！

哦哦哦，对了，我在这边道歉一下：我不小心把**题目分析**中的2和3搞到一起了，抱歉啊QwQ

博客：https://www.luogu.org/blog/user52670/
建议大家在：https://www.zybuluo.com/luochenfall/note/1531007
中观看，效果会好一点。。。

Over，Thanks。


---

## 作者：小黑AWM (赞：4)

## 本人果然数学直觉奇差（难受.jpg）

题面很花哨，但是并不是很难看懂。就是求一个逆序对为m的字典序最小的排列。一开始我竟然蜜汁感觉这是一道next_permutation+merge_sort的水题……于是乎写出了这样的鬼畜代码
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
int calendar[50050],calendar_c[50050],n,m;
int merge(int*a, int l, int mid, int r)
{
    int count = 0;
    int p1 = l;
    int p2 = mid + 1;
    int i = 0;
    int help[r - l + 1];
    while (p1 <= mid && p2 <= r)
    {
        count += a[p1] > a[p2] ? (mid - p1 + 1) : 0;
        help[i++] = a[p1] <= a[p2] ? a[p1++] : a[p2++];
    }
    while (p1 <= mid)
        help[i++] = a[p1++];
    while (p2 <= r)
        help[i++] = a[p2++];
    for (i = 0; i < r-l+1; i++)
        a[l + i] = help[i];
    return count;
}
int mergeSort(int *a, int l, int r)
{
    if (l == r)
        return 0;
    int mid = l + (r - l) / 2;
    return mergeSort(a, l, mid) + mergeSort(a, mid + 1, r) + merge(a, l, mid, r);
}
int SmallSum(int *a,int len)
{
    if (len < 2)
        return 0;
    return mergeSort(a, 0, len - 1);
}
int main(){
    cin>>n>>m;
    //可证明0<=m<=1/2*n*(n-1)
    for(int i=0;i<n;i++)
        calendar_c[i]=calendar[i]=i+1;
    while(SmallSum(calendar_c,n)!=m){
        next_permutation(calendar, calendar+n);
        for(int i=0;i<n;i++)
            calendar_c[i]=calendar[i];
    }
    for(int i=0;i<n;i++)
        cout<<calendar[i]<<" ";
    return 0;
}
```
算错了复杂度，把复杂度当成了~~$O(nlgn+n)$~~，TLE了才发现忽视了有一个阶乘级数~~(捂脸)于是开始思考如何维护出一个字典序最小的满足逆序对数m的数据结构~~（惨痛的现实打醒了我）无头绪之下（我简直蠢到极致）翻题解，基本没看懂别人的贪心策略……可能我太蠢了，但数据结构那位老哥受我一拜。

突然想起来，我可以废物利用啊！这种数据很明显有数学规律啊，打个表什么的多舒服。于是用之前只有20分的程序打了个表（这里放一部分）
```
6 0
1 2 3 4 5 6
6 1
1 2 3 4 6 5
6 2
1 2 3 5 6 4
6 3
1 2 3 6 5 4
6 4
1 2 4 6 5 3
6 5
1 2 5 6 4 3
6 6
1 2 6 5 4 3
6 7
1 3 6 5 4 2
6 8
1 4 6 5 3 2
6 9
1 5 6 4 3 2
6 10
1 6 5 4 3 2
6 11
2 6 5 4 3 1
6 12
3 6 5 4 2 1
6 13
4 6 5 3 2 1
6 14
5 6 4 3 2 1
6 15
6 5 4 3 2 1

```
惊奇地发现，所有的是答案的排列构成的图像最多只有一个单峰(即单调性不改变或先单调增，再单调减)！且纵向观察可以发现，第$i$列在变成6之前的分布很有规律，是$\frac{(n-i)*(n-i+1)}{2}$个i然后依次递增直到增至$n$为止。在表中，$m$为行数，所以可以借此性质求出第$m$行单调增部分的第$i$个元素。伪代码如下：
```cpp
Define BASE as 1/2(n-i)*(n-i-1)
if(m is lower than BASE)
	element is i;
else
	if(m-BASE+i is bigger than n)
    	element is n
    else
    	element is m-BASE+i

```
而其余单调减部分直接倒序输出即可（这个我们从表里可以看出6之后都是递减的）
AC代码如下：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
long long n, m,output;
long long base [50050],use[ 50050];
int main(){
  cin>>n>>m;
  for(int i=1;i<=n;i++)
    base[i]=(n- i)*(n -i-1)/ 2;
  for (int i=1;i<= n&&output !=n ;i++){
    output =(m-base[i]<=0 )?i :(m-base[i]+ i<=n ?m -base[i]+i:n);
    printf("%lld ",output);
    use[output]=1;
  }
  for(int i=n; i >= 1;i--)
    if( !use[i] )
      printf("%lld ",i);
  return 0;
}

```

---

## 作者：fallingdust (赞：3)

# P1338 末日的传说 题解

## 吐槽

其实，我今天本来是想去写一下代码难度不高，但是比较需要思考的题目
（本来是想说比较需要智力的题目，想了想，算了......）

言归正传，这道题目，看完之后，我其实有点懵（**N+1进制？！！**），题面：
>1, 2, 3, … N
>第二天，日历自动变为
>1, 2, 3, … N, N-1
>……每次它都生成一个以前未出现过的“最小”的排列——把它转为N+1进制后数的数值最小。

我在想：N+1进制？？什么鬼......
再认真看一下样例，才发现：**逆序**才是有用的.....
>他还预言到，假如某一个日期的逆序达到一个值M的时候
（这就是答案了<_<）

OK,那么，逆序大家都应该是了解的，应为题面上面有。
>假如排在前面的那个比排在后面的那个更大，就是一个逆序

好的，吐槽完毕，现在：
##题目分析

> * 1、问题规模
> * 2、可实现的方法
> * 3、正解&分析

###1.问题规模

>对于10%的数据有N <= 10。
>对于40%的数据有N <= 1000。
> **对于100%的数据有 N <= 50000**。
>所有数据均有解。

N<=50000,明显，O（N$^2$）解决不了，所以试试O（N$log n$）O（N）能否解决
PS：O（1）的......说实话，讲道理不存在......

####看题目，就会很自然的想：**线性复杂度**能不能解决？（O（N））
不急，先看。

###2.可实现的方法
> * 暴力（枚举全排列）
> * 神奇思路

很明显，枚举全排列暴力的做法，代码量不多，而且不难（无论是**手写**还是用**next_permutation()**），但是，你可能只能过1~4个点。

代码的话......我比较懒，没打，就不贴了......

现在，关键点到了：如何用一种思路把问题**简化**到**线性复杂度**
假设，你是一家公司的董事长，你要做一个项目，但是你不想做所有的步骤，怎么办？？很简单，你做其中的一步，然后把它交给你的秘书，让他（她，或者......它<_<）帮你完成剩下所有的，然后你做完最后一步之后，宣布：项目完成，然后向投资方交差，然后继续......
OK，那么，如果你是秘书，你该干什么？（这个问题，排除对“它”的询问）很简单，**你学习一下你的老板**，把问题分解，交给下属，然后这样一步一步下去，再传上来，一人做一步，最后，完美finish。
（**递归的思路**，线性的复杂度（**对于本题**））

现在，我们来分解一下问题，显然，假设你现在正在处理第i个数，前面都处理完了，现在还需要now个逆序，你该如何解决？？

解决前，我们应该了解一下：1、2、3~n个数，逆序最多有多少个

最少的逆序，很显然：1、2、3、······n   总共0个
做多：n、n-1、······1   总共多少个？
现在就是本问题用到的第一个（貌似也是最后一个）数学公式
**高斯求和**
对于第1个数，它的逆序个数：n-1 (从第n-1到1)
对于第2个数，它的逆序个数：n-2 (从第n-2到1)
······
第n-1个数，它的逆序个数：1
第n个数，它的逆序个数：0

归纳：逆序和（n-1+1）$*$（n-1）$/$ 2=（n-1）$*$（n-1）$/$ 2
推论：对于第i个数，i及i以后所有数的最大逆序个数和（倒叙）：
**（（n-i）$*$（n-i-1）$/$2）**
所以:用递归的思路，对于第i个数，你只要判断它放在哪，于是，神奇思路：

因为：假设逆序数相同，要求字典序最小
所以：越小的数向前放越好
所以：一层层用这种贪心思路放下去，可以保证最优解

所以**核心思想**：
假设对于第i个数的可造成的最大逆序数：（（n-i）$*$（n-i-1）$/$2）
设这个为S
如果这个S>=now（目前需要的逆序数个数）
就放在目前数组（ans数组）的开头

> * PS：为什么等于也放？这个大家想一想就知道了，我懒得码字证明了，对不起啦！！！

反之，就放在末尾。（为了防止出现后面所有数倒叙都不成立的情况）

OK，题目分析结束，代码如下（仅供参考。。。）
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <iostream>
using namespace std;

#define ll long long
#define mx(x,y) x>y?x:y
#define mn(x,y) x<y?x:y
#define _e putchar(' ')
#define _v putchar('\n')
#define BF_N 1<<17

char buf[BF_N],sl,sr;
FILE *fin;
char gc() {
	return sl==sr&&(sr=(sl=0)+fread(buf,1,BF_N,stdin),sl==sr)?EOF:buf[sl++];
}
int Read() {
	int ans=0,k=1;
	char c=gc();
	while(!isdigit(c)) {
		if(c=='-')k=-1;
		c=gc();
	}
	while(isdigit(c)) {
		ans=ans*10+c-'0';
		c=gc();
	}
	return k*ans;
}

long long n,m,fi=1,la;
long long ans[1000005];

void init(){
	scanf ("%lld%lld",&n,&m);
	la=n;
	return;
}

#define he(i) ((n-i)*(n-i-1)/2)

void work(){
	long long now=m;
	for (long long i=1;i<=n;i++){
		if (he(i)>=now)
			ans[fi++]=i;
		else
			ans[la--]=i,now-=(n-i);
	}
	for (int i=1;i<=n;i++)
		printf ("%lld ",ans[i]);
	return;
}

int main(){
	init();
	work();
	return 0;
}
```
各位自己体会一下啊，我累了，溜了！！

哦哦哦，对了，我在这边道歉一下：我不小心把**题目分析**中的2和3搞到一起了，抱歉啊QwQ

博客：https://www.luogu.org/blog/user52670/
Over，Thanks。


---

## 作者：wangboyue (赞：3)

#  P1338 末日的传说
## 题意
求长度为 $n$ 的排列，满足条件：
- 逆序对个数为 $m$ 个。
- 字典序最小。

## 思路
定义 $f_i$ 表示在一个序列 $a$ 中的第 $i$ 项，满足 $j>i$ 且 $a_j<a_i$ 的所有可能的 $j$ 的个数。  
明显地，当 $f$ 序列确定时，可以通过以下方法构造出答案序列 $ans$：
1. 按 $f_i$ 为第一关键字，$i$ 为第二关键字进行排序。
2. 排序后从小到大赋值 $ans_i$。
3. 按原顺序（排序前顺序）输出。

那么应当如何构造出序列 $f$ 呢？  
可以发现 $f$ 具有以下性质：
1. $f_i$ 一定不会超过 $n-i$。  
   满足 $j>i$ 的 $j$ 只会有 $n-i$ 个。
2. 要使序列 $ans$ 的字典序最小，要尽可能使 $f$ 末尾的值最大。  
    $f$ 前面的值越大就说明 $ans$ 中的大值越靠前，而要使 $ans$ 字典序最小就应当避免出现此情况。
3. $f$ 的和为 $m$。

由此可得贪心策略：尽可能让 $f_i$ 末尾的值在不超过 $n-i$ 的情况下最大。详见代码。
## 代码
```cpp
//08 24 1/1
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=5e4+5;
struct node{
	int val,id,num;
	bool operator<(const node &o)const{
		if(val==o.val){
			return id<o.id;
		}
		return val<o.val;
	}
}a[N];
bool cmp(node a,node b){
	return a.id<b.id;
}
int n,m;
signed main(){
//	freopen("legend.in","r",stdin);
//	freopen("legend.out","w",stdout);
	cin>>n>>m;
	for(int i=n;i>=1;i--){
		if(m==0){
			a[i].id=i;
//			cerr<<0<<" "<<m<<endl;
			continue;
		} 
		if(m<=n-i){
			a[i].val=m;
			a[i].id=i;
			m=0;
			continue;
		}
		a[i].val=n-i;
		a[i].id=i;
		m-=n-i;
	}
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++){
		a[i].num=i;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=n;i++){
		cout<<a[i].num<<" ";
	}
	return 0;
}
```

---

## 作者：JustinRochester (赞：2)

差分树状数组牛逼！

---

**【分析】**
---

**法一：**

关键的重点在于怎么确定相应逆序对数的最小排列

我们考虑 $n$ 个数全排列，逆序对数最大的情况无非是

$n,(n-1),(n-2)\dots3,2,1$

这个情况下，逆序对数为 $(n-1)+(n-2)+(n-3)+\dots+3+2+1={n(n-1)\over 2}$

也就是说， $n$ 个数的逆序对数最小值为 $0$ ，最大值为 ${n(n-1)\over 2}$

也就是说，我们在已知的 $n$ 个数中，要使得逆序对数为 $m$

则选择剩余的第 $i$ 个数，使得 $i+{n(n-1)\over 2}\geq m$ 即可

接下来，我们用 $No_i$ 标记第 $i$ 次选择剩余的 $(n-i+1)$ 个数的第 $No_i$ 个数。至于它具体是多少，那是后面的问题

---

最后，我们输出的时候进行一些小标记即可完成：

我们设置一个数组 $Cnt_i$ 表示选择  **第 $\boldsymbol i$ 个数字要往后移几位**

这个定义有点神奇，它的来源是这样的：

我取了数 $j$ 后，再取第 $j$ 个数就要相应地后移。那么后移多少呢？就是后移 $Cnt_j$ 个单位了

就相当于第一次取到了数 $j$ ，第二次就要取到数 $(j+Cnt_j)$ 了

而取了数 $j$ 后，再取到第 $k$ 个数 $(k\geq j)$ 都要往后移一位

所以我们每次的操作都是这样：
1. 确定当前的第 $i$ 个数是数 $(i+Cnt_i)$
2. 将 $Cnt_{i+Cnt_i}$ 到 $Cnt_n$ 都 $+1$

~~然后你们会相信我就那么耿直地打上去了，T了 $6$ 个点？~~

我们想一想，我们要先单点查询，再区间修改

这不就是差分树状数组吗？

打上去就完事了

---

**【代码】**
---

那本蒟蒻就放 ~~我码风极丑的~~ 代码了：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
// #define LOCAL
typedef int i32;
typedef unsigned int u32;
typedef long long int i64;
typedef unsigned long long int u64;
const i32 MAXN=50010;
typedef i32 ar[MAXN];
#ifdef LOCAL
    inline char gc() { return getchar(); }
#else
    inline char gc() {
        static char s[1<<20|1]={0},*p1=s,*p2=s;
        return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);
    }
#endif
inline i32 read(){
    register i32 ans=0;register char c=gc();register bool neg=0;
    while(c<48||c>57) neg^=!(c^'-'),c=gc();
    while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
    return neg?-ans:ans;
}
//无聊的读入优化

char Output_Ans[1<<20|1],*Output_Cur=Output_Ans;
inline bool output() { Output_Cur-=fwrite(Output_Ans,1,Output_Cur-Output_Ans,stdout); }
inline void print(char c) { (Output_Cur-Output_Ans+1>>20)&&output(),*(Output_Cur++)=c; }
inline void print(i32 x){
    char buf[20]={0}; (Output_Cur-Output_Ans+sprintf(buf,"%d",x)>>20)&&output();
    Output_Cur+=sprintf(Output_Cur,"%d",x);
}
//无聊的输出优化

i32 d_N;
ar ar_d_No;

namespace Tree_arr{
    ar ar_d_Num;
    inline void add(i32 d_Pos,i32 d_A){
        for(register i32 i=d_Pos;i<=d_N;i+=(i&(-i))) ar_d_Num[i]+=d_A;
    }
    inline i32 sum(i32 d_Pos){
        i32 d_Ans=0;
        for(register i32 i=d_Pos;i;i-=(i&(-i))) d_Ans+=ar_d_Num[i];
        return d_Ans;
    }
    inline void update(i32 d_Pos){
        add(d_Pos,1);
        add(d_N+1,-1);
    }
}
//无聊的树状数组

inline void solve(i32 d_Pos,i32 &d_Lst){
    i32 d_Max;
    if(d_Pos&1) d_Max=(d_Pos-1)/2*d_Pos;
    else d_Max=d_Pos/2*(d_Pos-1);
    f(i,0,I,d_Pos) if(i+d_Max>=d_Lst){
        ar_d_No[d_N-d_Pos]=i+1;
        d_Lst-=i;
        break;
    }
}

inline void cal(){
    f(i,1,I,d_N){
        print(ar_d_No[i]+Tree_arr::sum(ar_d_No[i]));
        Tree_arr::update(ar_d_No[i]);
        print(' ');
    }
}

int main(){
    d_N=read();
    i32 d_M=read();
    f(i,1,I,d_N) solve(d_N-i,d_M);
    cal();
    output();
    return 0;
}
```

---

**法二：**

刚写完法一的题解，立马想到了 $O(n)$ 的法二

对于剩余的 $n$ 个数，由法一得到逆序对数处于 $[0,{n(n-1)\over 2}]\bigcap Z$ 中

而如果这 $n$ 个数中，第一个数确定是剩余的第 $i$ 个，则逆序对数最大值为 $[i+{(n-1)(n-2)\over 2}]$

好，我们回到考虑如何使得排列最小：

如果前面的数尽可能小，则排列一定也会尽可能小

而前面的数尽可能小，后面数的逆序对数一定就要尽可能大

那怎么令后面的逆序对数最大？剩下的几个数直接倒序排列即可

总之，我们要尽可能先选**剩余的数中**最小的数，然后通过选数让它们的逆序对数达到 $m$ ，再将剩下的数倒序输出

---

这是我们的思路，但我们实现起来没必要那么复杂：

所有的数中，最小的是 $1$ ，其次是 $2\ ,\ 3\ ,\ 4\dots$

也就是说，我们先尽可能按序输出

同时，我们计算，如果此时选择最小的数，那么剩下的数的逆序对数总和为多少

因为前面都是按序的，逆序对数为 $0$ ，所以当剩下数的逆序对数总和为 $a$ 时，如果此时仍选择最小的数，则整个排列的逆序对数最大为 $t$

若 $t\geq m$ ，说明此时选择最小的，后面的数还能使得逆序对总数为 $m$

若 $t<m$ ，说明若此时仍选择最小的，后面的数已经无法使得逆序对总数为 $m$ 了

所以当 $t<m$ 时，我们不能选择最小的，但我们仍要尽可能选择最小的

我们可以发现，如果我们选择第 $k$ 小的数，它会大于后面 $(k-1)$ 个数，整个排列的最大逆序对数即为 $(t+k-1)$

而我们要使得逆序对数为 $m$ ，所以我们此时要选择第 $(m-t+1)$ 个数

选完我们就有了总数为 $(m-t)$ 的逆序对数，再将后面倒序排列，就达成 $m$ 的逆序对数了

---

**【代码】**
---

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
//#define LOCAL
typedef int i32;
typedef unsigned int u32;
typedef long long int i64;
typedef unsigned long long int u64;
const i32 MAXN=50010;
typedef i32 ar[MAXN];
#ifdef LOCAL
    inline char gc() { return getchar(); }
#else
    inline char gc() {
        static char s[1<<20|1]={0},*p1=s,*p2=s;
        return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);
    }
#endif
inline i32 read(){
    register i32 ans=0;register char c=gc();register bool neg=0;
    while(c<48||c>57) neg^=!(c^'-'),c=gc();
    while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
    return neg?-ans:ans;
}
//无聊的读入优化

char Output_Ans[1<<20|1],*Output_Cur=Output_Ans;
inline bool output() { Output_Cur-=fwrite(Output_Ans,1,Output_Cur-Output_Ans,stdout); }
inline void print(char c) { (Output_Cur-Output_Ans+1>>20)&&output(),*(Output_Cur++)=c; }
inline void print(i32 x){
    char buf[20]={0}; (Output_Cur-Output_Ans+sprintf(buf,"%d",x)>>20)&&output();
    Output_Cur+=sprintf(Output_Cur,"%d",x);
}
//无聊的输出优化

int main(){
    i32 d_N=read(),d_M=read(),d_Un;
    g(i,d_N-1,I,0){
        i32 d_T;
        if(i&1) d_T=(i-1)/2*i;
        else d_T=i/2*(i-1);
        //算剩下的数的逆序对最大值
        
        if(d_T>d_M) print(d_N-i),print(' ');
        else{
            d_Un=(d_N-i)+(d_M-d_T);
            //选的那个数具体为多少
            print(d_Un),print(' ');
            g(j,d_N,J,d_N-i) if(j^d_Un)
                print(j),print(' ');
            break;
        }
    }
    output();
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：shiroha (赞：1)

 * 题目求的使最小的拥有n对逆序对的全排列。
 * 显然这样的全排列高位部分是按照顺序的1~n。
 * 所有数字逆序可以提供最大的逆序对数目n(n-1)/2
 * 寻找中间界点it，令所求逆序对数m∈[(n-it-1)(n-it)/2,(n-it)(n-it+1)/2];
 * 数组被分为三部分：<it——没有逆序对，=it——等于之后小于it的数目，>it——全逆序(n-it-1)(n-it)/2
 * 显然，在>=it的部分的最小值是it，设放置在it位置的值为it+dx，则dx就是=it情况下的逆序对数。
 * 显然，由上面的分析可知，dx = m - (n-it-1)(n-it)/2;
 * 那么第三部分只需要逆序输出被挖掉的值除外的其他所有的数的逆序就可以了。

```c++
#include <iostream>

using namespace std;
int n,m;
int dx,it;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m;
    int tmp=m;it=n;
    for(int i=1;tmp>0;++i,--it) //i+it==n+1
    {
        dx = tmp<i?tmp:i; //tmp<i时，表示已经到达区间，tmp此时的值就是还需要达成的逆序对数目，下一步m将<=0
        tmp-=i;
    }
    for(int i=1;i<it;++i)cout<<i<<' '; //输出第一部分，对逆序对没有贡献
    cout<<it+dx; //输出第二部分，对逆序对贡献为dx
    for(int i=n;i>=it;--i)
        if(i-it-dx)cout<<' '<<i; //输出第三部分，对逆序对奉献为(n-it)(n-it-1)/2
    return 0; //总贡献 = dx + (n-it)(n-it-1)/2 = tmp + (i-1)(i-2)/2 = m;
}
```

---

## 作者：xiaosongliu (赞：1)

排列的逆序对求和公式：(N - i) * (N - i - 1) / 2
如果最小的放在最前面可以得到比M更多的逆序对，那就将最小的数放在最前面。
反之，将最小的放在最后面，并且让M减去这次通过将最小的放在最后面得到的逆序对
最终得到的序列就是答案
```python
N, M = map(int, input().split())
fst, lst = 1, N
ans = [0 for i in range(N + 1)]
for i in range(1, N + 1):
    t = (N - i) * (N - i - 1) // 2
    if t >= M:
        ans[fst], fst = i, fst + 1
    else:
        ans[lst], lst = i, lst - 1
        M -= (lst - fst + 1)
for i in range(1, N + 1):
    print(str(ans[i]), end=' ')

```

---

## 作者：dph754132771 (赞：1)

/\*
\* P:1338

\* Au:Small\_Ash

\* 本题，嗯，怎么说呢，真是纯数论。

\* 这里把对应逆序对为x第一次出现的数串给写下来 （n==5）

```cpp
 * 12354...x=1
 * 12453...x=2
 * 12543...x=3
 * 13542...x=4
 * 14532...x=5
 * 15432...x=6
```
\*   .
\*   .
\* 很明显，可以发现每次的数串只交换了两个数字，再次看会发现交换的两个数的位置有规律。总结一下就是下面的伪代码

   
    
```cpp
    x=n;
    y=n-1;
    for (int i=1;i<=m;i++){
        swap(a[x],a[y]);
        if (x-y<=1) {
            x=n;
            y--;
        }
        else x--;
    }
```
\* 然而我就这么交了上去，T了两个点。。。。
\* 不是O(N)的算法吗？？等等，是O(M)的。。。M的范围有点大。。。

\* 嗯，那就需要优化了，然后就发现每隔 1 3 6 10 15 21 28...(就是S=1+...N)的数串，正好都是把尾末的一段数字倒转而已

 \* x=1        123 54

 \* x=1+2=3    12 543

 \* x=1+2+3=6  1 5432

\* 于是就可以设计程序了(不理解的可以看代码。)

\*/
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
int a[50005],n,m,x,y;
int main(){
    freopen("1338.out","w",stdout);
    scanf("%d%d",&n,&m);
    if (n==1){
        printf("1");
        return 0;
    }
    for (int i=1;i<=n;i++) a[i]=i;
    if (m==0) {
        for (int i=1;i<=n;i++) printf("%d ",a[i]);
        return 0;
    }
    y=0;
    while (m-y>=0) {y++; m-=y;}
    for (int i=n;i>=n-y;i--) a[i]=2*n-i-y;
    y=n-y-1;
    x=n;
    for (int i=1;i<=m;i++){
        int t=a[x];
        a[x]=a[y];
        a[y]=t;
        if (x-y<=1) {
            x=n;
            y--;
        }
        else x--;
    }
    for (int i=1;i<=n;i++) printf("%d ",a[i]);
    return 0;
}

```

---

## 作者：Mr_Li (赞：1)

既然没有人发题解，那我就做第一个吧。

我们可以寻找日期逆序对的规律：当n=1时，只能记录一天，逆序对为0（这不用解释吧）；当n=p(p>1)时，记ai表示当i为第一个数时，日历的第一个数以后的，比第一个数小的数字个数，bj表示当n=p-1时，第j天的日历的逆序对，则第(i-1)·(p-1)!+j天的日历的第一个数为i，后p-1个数字为第j天的日历，逆序对为ai+bj。而a有什么规律呢？[delete]没有[/delete]当然是ai=i-1。于是，我们可以递推求解。

然而你会发现这种算法的时间复杂度特别大，为O(n^2)。所以，我们需要对其进行优化。

我们发现，ai最大为n-1，最后一天的日历的逆序对最大，进而得出世界末日一定在第i▪j!（1＜i≤j+1）天，其中j表示第n-j个数以前的数分别是1,2,3,…,n-j-1，i表示第n-j个数是n-j-1+i（请自己证明）。所以，我们可以用O(n)算法求出i和j的值，然后根据i和j求出世纪末日的日历的前n-j位，至于之后的数，就是除前n-j位以外的数的逆序（证明了前面那个，这个应该很容易了吧）。

附代码：

```cpp

#include<iostream>
using namespace std;
int n,m,i,MF=0,out,LO;
int main ()
{
    cin>>n>>m;
    if (m==0)
    for (i=1;i<=n;i++)
    cout<<i<<' ';
    if (m==0)
    return 0;
    for (i=1;i<=n;i++)
    if (MF+i<m)
    MF+=i;
    else
    break;
    out=n-i-1;
    for (i=1;i<=out;i++)
    cout<<i<<' ';
    LO=out;
    for (;MF<=m;MF++)
    out++;
    cout<<out<<' ';
    for (i=n;i>LO;i--)
    if (i!=out)
    cout<<i<<' ';
    return 0;
} 

```

---


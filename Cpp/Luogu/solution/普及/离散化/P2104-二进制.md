# 二进制

## 题目描述

小 Z 最近学会了二进制数，他觉得太小的二进制数太没意思，于是他想对一个巨大二进制数做以下 $4$ 种基础运算：

运算 $1$：将整个二进制数加 $1$。

运算 $2$：将整个二进制数减 $1$。

运算 $3$：将整个二进制数乘 $2$。

运算 $4$：将整个二进制数整除 $2$。

小 Z 很想知道运算后的结果，他只好向你求助。

（Ps：为了简化问题，数据保证 `+`，`-` 操作不会导致最高位的进位与退位）

## 说明/提示


对于 $30\%$ 的数据，$1 \leq n,m \leq 1000$。

对于 $60\%$ 的数据，$1 \leq n,m \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq n,m \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
4 10
1101
*/-*-*-/*/```

### 输出

```
10110```

# 题解

## 作者：Stay_Hungry (赞：35)

我是做了$HHHOI$上的一道极为相似的题才来此拿双倍经验的

$O(nm)$暴力想必大家都会，而问题的瓶颈在于$+-$操作的进位，如果有组数据是$n = 5e7, m = 5e7$   
$11111111......1111$    
$+-+-+-+-.......+-+-$    
绝对原地爆炸，我在模拟赛中即使是判了相邻$+-$操作消除部分操作还是只有$73pts$   

题意明了，直接上$O(m)$做法（其实我也很好奇上限$O(nm)$的暴力是咋过的）  

不难发现，每次操作针对的，都只是最后一位，所以只需在最后一位打延迟标记，$\times$的时候向后推一位$0$，$/$的时候把延迟标记向前推，$+-$时就直接在最后一位上加减即可。    

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e6 + 5;
int f[N * 2], n, m, r; char c;
signed main() {
	ios :: sync_with_stdio(false);
	cin >> n >> m; r = n;
	for(int i = 1; i <= n; ++i) cin >> c, f[i] = c - '0';
	while(m --) {
		cin >> c;
		if(c == '*') f[++ r] = 0;  //向后拓展一位
		else if(c == '+') ++ f[r];  //直接累加
		else if(c == '-') -- f[r];
		else f[r - 1] += f[r] >> 1, --r;  //考虑二进制下进位
        // 这里没必要修改f[r]
	}
	for(int i = r; i > 1; --i) {
		f[i - 1] += f[i] >> 1;
		f[i] = f[i] & 1;
	}  // 一次把延迟标记向前推完
	for(int i = 1; i <= r; ++i) cout << f[i]; cout << "\n";
	return 0;
}
```


---

## 作者：jx2014wzd (赞：14)

### 1.一般实现
既然不能误认子弟。。。正常的，AC的代码是必要的。。。

题目是让程序依次按照输入的运算符顺序计算：

‘*2’：在二进制中，乘以2就相当于十进制中的乘以十，只需要将数字右移一位即可。由于我们是用字符串形式存储的，所以直接在字符串格式存储的二进制数字末尾加零即可。

‘/2’：除以二就是乘以二的逆运算，乘以二把数字有移一位，除以二就要将数字左移一位即可。字符串处理的话，我们只需要将数字末尾赋值成'\0'即可

‘+2’：就有些麻烦了，因为需要处理进位。这里拿10011举例。10011 + 1，列竖式计算，逢二进一，结果为10100。稍微观察一下，末位加一，变为2后，需要向前进位，原数变为零，而倒数第二位原本是1，加上1以后也需要进位。直到第三位，是0了，再加1，该位值为1，无需进位，得到10100。于是，我们就得到了加一的规律：从后往前遍历，将每一位赋值成0，直到遇到原本的零，将其赋值成1，结束计算。然鹅，如果原数一个零也没有，例如11111，加一就涉及到进一的问题了。但是，题目中有提到：“数据保证+，-操作不会导致最高位的进位与退位”，所以，我们并不需要考虑这个问题而将整个数组移位。

‘-2’：类似地，-2也是+2的逆运算，原来是将一变零，遇到原本就是零为止，现在只需要将零变一，遇到原本就是一为止。

AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100000000] = {0}, oper[6000000] = {0};
int main()
{
	int n, m;
	scanf("%d%d%s%s", &n, &m, s, oper);
	for(int i = 0; i < m; i++)
		switch(oper[i])
		{
			case '*': s[n++] = '0';  break;
			case '/': s[--n] = '\0'; break;
			case '+': for(int k = n; s[--k] != '0' && (s[k] = '0') || !(s[k] = '1'); ); break;
			case '-': for(int k = n; s[--k] != '1' && (s[k] = '1') || !(s[k] = '0'); ); break;
		}
	puts(s);
}
```
### 2.稍改：main()递归
此方案类似于前者，但不需要用任何的循环、三元表达式、逗号表达式。由于此题卡常，不开O2会有五个点TLE,也别开02，因为可能会有更多的点TLE（O2优化会使得main的调用时间变长）。

首先要了解一下main()
main()是可以有参数的，但必须为一个int型和一个char** 型。main()同样也可以递归。

其次，正常的+ - * / 是没有运算顺序的。但是，||和&&为了节约时间，是有从左到右的运算顺序的。

a || b()：先计算a的值，如果为true，那么全式的值一定为true，就不需要求b()的值。所以可以将a||b()用作与之等效的用法if(a == false) b();

a && b()：先计算a的值，如果为false，那么全式的值一定为false，就不需要求b()的值。所以可以将a&&b()用作与之等效的用法if(a == true) b();

于是，就有了这个代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100000000] = {0}, oper[6000000] = {0};
int n = -1;
int main(int argc, char **argv)
{
	return (n + 1 || scanf("%d%d%s%s", &n, &argc, s, oper) && 0 || (*argv = NULL) || main(argc, argv) && 0) 
		&& (argc || puts(s) && 0)
		&& (oper[strlen(oper) - argc] - '*' || (s[n++] = '0') && main(argc - 1, argv) && 0)
		&& (oper[strlen(oper) - argc] - '/' || !(s[--n] = '\0') && main(argc - 1, argv) && 0)
		&& (oper[strlen(oper) - argc] - '+' || (
			(!*argv || (*(--*argv) != '0' && (**argv = '0') && (main(argc, argv) || 1) || !(**argv = '1')
				|| (*argv = NULL) || main(argc - 1, argv)) && 0)
			&& (*argv || !(*argv = s + n) || main(argc, argv) && 0)))
		&& (oper[strlen(oper) - argc] - '-' || (
			(!*argv || (*(--*argv) != '1' && (**argv = '1') && (main(argc, argv) || 1) || !(**argv = '0')
				|| (*argv = NULL) || main(argc - 1, argv)) && 0)
			&& (*argv || !(*argv = s + n) || main(argc, argv) && 0)))
		&& 0;
}
```


---

## 作者：luckydrawbox (赞：6)

## 题意

模拟二进制加减乘数操作。

## 分析

先考虑数据存储：

我们可以用一个 ``int`` 数组 $a$ 来存这个二进制数的每一位，用一个 ``string`` 字符串 $s$ 来存最后的加减乘除运算，但**一定**一定要**注意**：有一种极限情况，即 $n、m$ 都是 $5* 10^6$，且 $s$ 中每个操作都是 $* $，那么这个二进制数的位数就会达到 $10^7$！所以定义时千万不要少了，不然你就会看到两个紫色的**RE**。

接下来先解决简单的**乘**和**除**的操作：

- 如果是**乘法**，我们直接 ``++n`` 就行了，因为这样就相当于在 $a$ 数组的末尾加了一位，也就是二进制的左移（$* 2$），不过还要来一步 ``a[n]=0``，不然你新加的 $a_n$ 可能是上次运算留下的 $1$。

```cpp
if(s[i]=='*')a[++n]=0;
```

- 如果是**除法**，我们只需 ``n--`` 就OK了，相当于在 $a$ 数组的末尾减了一位，也就是二进制的右移（$/2$）。

```cpp
if(s[i]=='/')n--;
```

然后处理一下难亿点的**加**和**减**：

我们定义一个函数 ``void jia_jian(int x,int f)``，进行加减运算，其中 $x$ 代表当前在第 $x$ 位，$f$ 的值为 $1$ 或 $-1$，即加或减，我们先把 $a_x$ 加上 $f$，如果此时的 $a_x$ 不是 $0$ 或 $1$，那么我们就进行**进位**和**借位**，可以发现，进行进位时 $a_x=2$，进行借位时 $a_x=-1$，此时，我们就可以递归，把运算传到下一位去，即 ``jia_jian(x-1,f)``，因为题目中说 ``数据保证+，-操作不会导致最高位的进位与退位`` ，所以不用考虑边界。然后，我们需要把进位的 $a_x$ 赋值为 $0$，把借位的 $a_x$ 赋值为 $1$，找规律可得二者都可以表示为 ``a[x]-=2*f``。这样我们就得到了加减运算的通用函数：
```cpp
void jia_jian(int x,int f)
{
	a[x]+=f;
	if(a[x]>1||a[x]<0)
	{
		a[x]-=2*f;
		jia_jian(x-1,f);
	}
}
```

剩下的就不用说了，直接上代码：

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+10;//千万千万不要少定义
int n,m,a[N];
string s;
void jia_jian(int x,int f)
{
	a[x]+=f;
	if(a[x]>1||a[x]<0)//判断a[x]是否需要进位或借位
	{
		a[x]-=2*f;
		jia_jian(x-1,f);//向下一位进位或借位
	}
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
    	scanf("%1d",&a[i]);//每次读入一位
	}
	cin>>s;
	for(int i=0;i<m;i++)
	{
		if(s[i]=='*')a[++n]=0;
		if(s[i]=='/')n--;
		if(s[i]=='+')jia_jian(n,1);
		if(s[i]=='-')jia_jian(n,-1);
	}
	for(int i=1;i<=n;i++)printf("%d",a[i]);
	return 0;
}
```


---

## 作者：Diogenes (赞：5)

[@luogu](https://www.luogu.org/problemnew/show/P2104)

[原文](https://blog.csdn.net/chtcht_/article/details/81536588)

>这题luogu评测机跑得太快以至于没卡掉纯模拟。标算做法是把二进制数放在一个栈里， * 和 / 操作就是对尾指针加一或减一，+和-操作对最后一位数加一或减一，但是要延迟进位，在最后处理。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
#include<iostream>
#define N 11000000
#define ll long long
#define max(x,y) ((x)>(y) ? (x) : (y))
#define min(x,y) ((x)<(y) ? (x) : (y))
using namespace std;

inline int getint() {
	int t=0,p;
	char ch=getchar();
	for(;ch!='-' && !(ch>='0' && ch<='9');ch=getchar());
	if(ch=='-') p=-1,ch=getchar();
	else p=1;
	for(;ch>='0' && ch<='9';ch=getchar()) {
		t=t*10+ch-48;
	}
	return t*p;
}

string ans;
int n,m,a[N];
char s[5000010];

int main() {
	freopen("two.in","r",stdin);
	freopen("two.out","w",stdout);
	n=getint(),m=getint();
	int l=0,r=l+n;
	char ch;
	for(int i=0;i<n;i++) {
		for(ch=getchar();ch!='1' && ch!='0';ch=getchar());
		a[i]=ch-48;
	}
	scanf("%s",s);
	for(int o=0;o<m;o++) {
		if(s[o]=='*') {
			a[r++]=0;
			continue;
		}
		if(s[o]=='/') {
			r--;
			if(l==r) {
				a[r++]=0;
				continue;
			}
			if(a[r]<0) {  //处理进位
				a[r-1]+=(a[r]-1)/2;
				continue;
			}
			if(a[r]>1) {
				a[r-1]+=a[r]>>1;
				continue;
			}
			continue;
		}
		if(s[o]=='+') {
			a[r-1]+=1;
			continue;
		}
		if(s[o]=='-') {
			a[r-1]-=1;
			continue;
		}
	}
	int tmp;
	for(int i=r-1;i>l;i--) {
		if(a[i]<0) {       //处理进位
			tmp=(a[i]-1)/2;
			a[i-1]+=tmp;
			a[i]-=tmp*2;   //退1作2
		}
		if(a[i]>1) {
			a[i-1]+=a[i]>>1;  //大于1进位
			a[i]%=2;
		}
	}
	for(int i=l;i<r;i++) {
		ans+=(char)(a[i]+48);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Terrific_Year (赞：4)

## 题面传送门：[$P2104$](/problem/P2104)
看一遍题面，说是要给巨大的二进制数做运算，所以肯定不能用单个数的类型，要用数组或字符串~~废话~~，代码实现其实比较简单~~我调了半个小时~~我在此给出字符串做法~~其他不会~~：
## 1.加减法
题目保证最高位不进退位，那么长度是不变的我们只需做完运算后检查当前位是否要进退位即可：
```cpp
	if(t[i]=='+'){
		s[tmp=len-1]+=1;//+1
		while(s[tmp]=='2'){//进位
			s[tmp]='0';
			s[tmp-1]=s[tmp-1]+1;
			tmp--;
		}
	}
	else
	if(t[i]=='-'){
		s[tmp=len-1]--;//-1
		while(s[tmp]<'0'){//不够减
			s[tmp]='1';
			s[tmp-1]=s[tmp-1]-1;
			tmp--;
		}
	}
```
## 2.乘除
这一种比较简单我们只需要后面添个$0$或者把最后一位删掉即可：
```cpp
	else
	if(t[i]=='*'){
		s+="0";//添个0
		s[len++]='0';//长度+1
	}
	else{
		len--;//长度-1
	}
```
下面附上$AC$代码（巨佬勿喷）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,len,tmp;
string s,t;
int main(){
    cin>>n>>m>>s>>t;
    len=s.length();
    for(int i=0;i<t.length();++i){
        if(t[i]=='+'){
            s[tmp=len-1]+=1;
            while(s[tmp]=='2'){
                s[tmp]='0';
                s[tmp-1]=s[tmp-1]+1;
                tmp--;
            }
        }
        else
        if(t[i]=='-'){
            s[tmp=len-1]--;
            while(s[tmp]<'0'){
                s[tmp]='1';
                s[tmp-1]=s[tmp-1]-1;
                tmp--;
            }
        }
        else
        if(t[i]=='*'){
            s+="0";
            s[len++]='0';
        }
        else{
            len--;
        }
    }
    for(int i=0;i<len;++i){
        putchar(s[i]);
    }
}
```

---

## 作者：cdyjyz (赞：4)

```cpp
var n,m,i,t:longint;
s,s1:ansistring;
begin
readln(n,m);
readln(s);
readln(s1);
for i:=1 to m do
  begin
  if s1[i]='+' then//判断“+”时
    begin
    s[n]:=chr(ord(s[n])+1);加时最末尾加1，若为2则进位
    t:=n;
    while s[t]='2' do//进位
      begin
      if t=0 then
        begin
        if s[t]='2' then
        s[t]:='0';
        s:='1'+s;
        break;
        end;
      s[t]:='0';
      s[t-1]:=chr(ord(s[t-1])+1);
      dec(t);
      end;
    end
  else if s1[i]='-' then//减时则末尾减1,0
    begin
    s[n]:=chr(ord(s[n])-1);ascll’0‘前一位是’/’
    t:=n;
    while s[t]='/' do
      begin
      s[t]:='1';
      s[t-1]:=chr(ord(s[t-1])-1);
      dec(t);
      end;
    end
  else if s1[i]='*' then//二进制乘2则末尾加0，除以2则末尾减一位
  s:=s+'0'
  else if s1[i]='/' then
  delete(s,length(s),1);
  n:=length(s);
  end;
writeln(s);
end.
```

---

## 作者：_•́へ•́╬_ (赞：3)

## $vector$是个好东西
```cpp
#include<stdio.h>
#include<vector>
#define rpt(n) for(register int ttxyc=0;ttxyc<(n);++ttxyc)//宏定义
int n,m,_;std::vector<int>a;char c;
main()
{
	scanf("%d%d",&n,&m);//输入
	rpt(n){scanf("%1d",&_);a.push_back(_);}//再输入
	rpt(m)
	{
		for(;c=getchar(),c!='+'&&c!='-'&&c!='*'&&c!='/';);//获取操作
		switch(c)
		{
			case'*':a.push_back(0);break;
			case'/':a.pop_back();break;
			case'+':++a.back();for(register int i=a.size()-1;a[i]==2;--i)++a[i-1],a[i]=0;break;
			case'-':--a.back();for(register int i=a.size()-1;a[i]<0;--i)--a[i-1],a[i]=1;break;
		}
	}
	for(register int i=0;i<a.size();++i)printf("%d",a[i]);//输出
}/**/
```

---

## 作者：清风我已逝 (赞：2)

模拟大法好

模拟二进制的运算，

+从后向前找到第一个为0的，赋为1，中间为1的全赋为0

-从后向前找到第一个为1的，赋为0，中间为0的全赋为1

‘*’ 相当于<<操作 ++l，将二进制数长度加1，最后一位赋为0

‘/’ 相当于>>操作 --l，将二进制数长度减1


```
# pragma GCC optimize "O3"
#include<bits/stdc++.h>

using namespace std;

int n,m,k[5],l,tl;
char a[50000010];
void scz(char x) {
	if(x=='-') {
		int tp;
		for(int j=l; j>=1; j--) {
			if(a[j]=='1') {
				tp=j;
				break;
			}
		}
		a[tp]='0';
		for(int j=tp+1; j<=l; j++) a[j]='1';
	} else if(x=='+') {
		for(int i=l; i>=1; i--){
			if(a[i]=='0') {
				a[i]='1';
				break;
			}
			else a[i]='0';
		}
	} else if(x=='*') {
		a[++l]='0';
	} else if(x=='/') {
		if(l!=1) --l;
		else a[l]='0';
	}
}
void Print() {
	for(int i=1; i<=l; i++) {
		cout<<a[i];
	}
	cout<<"\n";
}
int main() {
	cin>>n>>m;
	l=n;
	for(int i=1; i<=n; i++) cin>>a[i];
	for(int i=1; i<=m; i++) {
		char b;
		cin>>b;
		scz(b);
	}
	Print();
	return 0;
}
```

---

## 作者：Insouciant21 (赞：1)

看完题面可以发现这题难点主要是 加减法的进退位

下面我们来找规律：

一个二进制数 $10111111111$

对其进行 $+1$ 操作

即得到 $11000000000$

再来一个 $10110101111$

$+1$ 后得到 $10110110000$

可以发现当需要进位时将从后往前的第一个 $0$ 变成了 $1$，其后的所有 $1$ 都变成 $0$

再看减法

$1101000101001000-1=1101000101000111$

$111101010100-1=111101010011$

即需要退位时将从后往前的第一个 $1$ 变成了 $0$，其后的所有 $0$ 都变成 $1$

$\times 2$ 在二进制中就像十进制中的 $\times 10$ 所以直接在后面添加一位 $0$

$\div 2$ 在二进制中就像十进制中的 $\div 10$ 所以直接在后面去掉一位

在这里将每一位数字存储在 `vector` 中，通过递归来进行进退位

```
#include <bits/stdc++.h>

using namespace std;
vector<int> num;
long long n, m;

// 进位加

void add(int place) {
    num[place]++;
    if (num[place] == 2) { // 一直向前直到无需再进位
        num[place] = 0;
        add(place - 1);
    }
    return;
}

// 进位减

void reduce(int place) {
    num[place]--;
    if (num[place] == -1) {
        num[place] = 1;
        reduce(place - 1);
    }
    return;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        char a;
        cin >> a; // 一位一位输入
        num.push_back(a - '0');
    }
    for (int i = 0; i < m; i++) {
        char oper;
        cin >> oper;
        switch (oper) {
            case '+':
                add(num.size() - 1);
                break;
            case '-':
                reduce(num.size() - 1);
                break;
            case '*':
                num.push_back(0);
                break;
            case '/':
                num.pop_back();
                break;
            default:
                break;
        }
    }
    for_each(num.begin(), num.end(), [](int x) { cout << x; }); // for_each 输出 （）
    cout << endl;
    return 0;
}
```

---

## 作者：时律 (赞：1)

我看题解里有人用数组模拟栈……

为什么不用$STL$里实打实的栈呢？

~~恭喜你，TLE了~~

思路是这样的：

把二进制的每一位加入栈，最高位放在栈底，最高位放在栈顶

针对每个操作，如下：

---

$$$$

**乘法**：

在栈顶加入一个$0$即可。

```
if(c=='*') q.push(0);
```

$$$$

---

$$$$

**除法**：

差不多，直接抛弃掉栈顶的数，因为是整除。

```
if(c=='/') q.pop();
```
$$$$

---

**加法**：

$$$$

所以此时用数组模拟栈的好处就来了。直接读取？

不！不要放弃$STL$！虽然说有点慢，但是还是能过此题的！~~本人亲自验证~~

考虑一下：如果最低位是$0$的话，就不用进位，直接弹出$0$加入$1$就好。

那如果是$1$怎么办？

先用一个变量$e$来记住弹出了多少个数。如果栈顶的数是$1$，就把它弹出，同时`e++`。

碰到$0$后，把这个$0$改为1，然后再加入$e$个$0$，因为前面全是$1$，然后都进了位变成$0$。

要是一直没碰到$0$怎么办？~~题目里没说，就不写了吧~~

```
if(c=='+')
{
	int e=0;
	while(q.top()==1)
		e++,q.pop();
	q.pop();q.push(1);
	for(int i=1;i<=e;i++)
		q.push(0);
}
```

$$$$

----

$$$$

**减法**：

类似加法，只不过是读到$1$时弹出，碰到$0$停止，并且加入的是$e$个$1$。

```
if(c=='-')
{
	int e=0;
	while(q.top()==0)
		e++,q.pop();
	q.pop();q.push(0);
	for(int i=1;i<=e;i++)
		q.push(1);
}
```

$$$$

---

$$$$

**完整代码**：

~~啊这道题好难啊用`cin`会TLE只好用字符数组了我要`string`啊~~

```
#include<bits/stdc++.h>
using namespace std;
stack<int> q;
char x[5000005];
int main()
{
	int a,b;
	char c;
	scanf("%d%d",&a,&b);
	getchar();
	scanf("%s",x+1);
	for(int i=1;i<=a;i++)
		q.push(int(x[i]-'0'));
	getchar();
	scanf("%s",x+1);
	for(int i=1;i<=b;i++)
	{
		c=x[i];
		if(c=='*') q.push(0);
		if(c=='/') q.pop();
		if(c=='+')
		{
			int e=0;
			while(q.top()==1)
				e++,q.pop();
			q.pop();q.push(1);
			for(int i=1;i<=e;i++)
				q.push(0);
		}
		if(c=='-')
		{
			int e=0;
			while(q.top()==0)
				e++,q.pop();
			q.pop();q.push(0);
			for(int i=1;i<=e;i++)
				q.push(1);
		}
	}
	string s;
	while(!q.empty()) s+=char(q.top()+'0'),q.pop();
	for(int i=s.size()-1;i>=0;i--)
		putchar(s[i]);
}
```

$$$$

---

$$$$

**题外话**：

~~刚开始以为`n<=63`的我竟然用了`unsigned long long`，我是在干嘛，这可是黄题~~

---

## 作者：loi_hjh (赞：1)

# 本题我们可以模仿栈的原理，虽然代码量稍微大了一点，但加减乘除复制粘贴一下就可以了

首先将读入的数据存入栈

```cpp
int l1,l2,t,sta[10000100];//二进制初始长度，操作次数，栈（存储二进制） 
char a[10000010],b[10000010];//读入二进制，操作
l1=read();//读入二进制初始长度
l2=read();//读入操作次数 
scanf("%s%s",a+1,b+1);//读入二进制，操作 
for(ri i=1;i<=l1;i++)//存储初始的二进制（char转成int） 
		sta[++t]=a[i]-'0'; 
```

加法运算：

我们可以从后往前加，我们自然可以用标准的二进制来处理，但是每次的时间复杂度都是O(m)的，n次操作，如果全是加法我们就gg了

我们可以优化成这样：

```cpp
in void doplus(){//切记：函数名字叫plus会CE 
	bool flag=false;//设置一个标记 
	for(ri i=t;i>=1;i--){//从后往前枚举，假如栈内的数为10010，可以按照1<-0<-0<-1<-0进行枚举 
		if(flag) break;//如果已经碰到了0，那就无法继续进位了，break 
		if(!sta[i]){//如果碰到0，停止进位 
			sta[i]=1;
			flag=true; 
		}
		else sta[i]=0;//如果是1，就就进位，如10111，是1就进位，到11000为止 
	}
}
```

减法运算：

直接类比加法，略改一下即可：

```cpp
in void dominus(){
	bool flag=false;//设置一个标记 
	for(ri i=t;i>=1;i--){//从后往前枚举，假如栈内的数为10010，可以按照1<-0<-0<-1<-0进行枚举 
		if(flag) break;//如果已经碰到了1，那就不必继续退位了，break
		if(sta[i]){//如果是1，就可以退位，如10变成02，减成01 
			sta[i]=0;
			flag=true; 
		}
		else sta[i]=1;//所有在最后的0都会变成1，如11000，变成10111 
	}
}
```

乘法运算：

乘法就比较简单了，直接在后边加一个0就可以了：

```cpp
in void domultiplication(){
	t++;
}
```

除法运算：

类比乘法：

```cpp
in void dodivision(){
	sta[t--]=0;//这里不同的是，不但尾指针减一还要把这个数清0，如11先除后乘是10，否则变11 
}
```

## 附上代码：

```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define in inline
#define ri register int
using namespace std;
in int read(){//快读 
	char c=' ';
	while((c<'0')||(c>'9'))
		c=getchar();
	int v=0;
	while((c>='0')&&(c<='9')){
		v=v*10+c-'0';
		c=getchar();
	}
	return v;
}
int l1,l2,t,sta[10000100];//二进制初始长度，操作次数，栈的长度，栈（存储二进制） 
char a[10000010],b[10000010];//读入二进制，操作 
in void doplus(){//切记：函数名字叫plus会CE 
	bool flag=false;//设置一个标记 
	for(ri i=t;i>=1;i--){//从后往前枚举，假如栈内的数为10010，可以按照1<-0<-0<-1<-0进行枚举 
		if(flag) break;//如果已经碰到了0，那就无法继续进位了，break 
		if(!sta[i]){//如果碰到0，停止进位 
			sta[i]=1;
			flag=true; 
		}
		else sta[i]=0;//如果是1，就就进位，如10111，是1就进位，到11000为止 
	}
}
in void dominus(){
	bool flag=false;//设置一个标记 
	for(ri i=t;i>=1;i--){//从后往前枚举，假如栈内的数为10010，可以按照1<-0<-0<-1<-0进行枚举 
		if(flag) break;//如果已经碰到了1，那就不必继续退位了，break
		if(sta[i]){//如果是1，就可以退位，如10变成02，减成01 
			sta[i]=0;
			flag=true; 
		}
		else sta[i]=1;//所有在最后的0都会变成1，如11000，变成10111 
	}
}
in void domultiplication(){
	t++;///类比栈 
}
in void dodivision(){
	sta[t--]=0;//这里不同的是，不但尾指针减一还要把这个数清0，如11先除后乘是10，否则变11 
}
int main(){
	l1=read();//读入二进制初始长度
	l2=read();//读入操作次数 
	scanf("%s%s",a+1,b+1);//读入二进制，操作 
	for(ri i=1;i<=l1;i++)//存储初始的二进制（char转成int） 
		sta[++t]=a[i]-'0'; 
	for(ri i=1;i<=l2;i++){//进行操作 
		if(b[i]=='+') doplus();
		if(b[i]=='-') dominus();
		if(b[i]=='*') domultiplication();
		if(b[i]=='/') dodivision();
	}
	for(ri i=1;i<=t;i++)
		printf("%d",sta[i]);
	return ~~(0-0);
}




```





---

## 作者：redegg (赞：1)

我们可以统一最后算出答案（而且不麻烦，因为保证了加减不进位）。

如果一个二进制数的下一位进了两位，那么我这一位一定进一位。

如果上一个二进制退了两位，我，这里一定也退了一位。

于是，此题的核心就是，我们可以像线段树的懒操作（区间加法用的那个），延迟更新答案。这样比较快。

我们存两个数组，应该是$a$数组，就是字符串，还有一个是$b$数组，$b_i$表示以$i$为最低位的串，一共加了多少个$1$。

我们加的话，直接在最低位上加就好了，如果我们要除的话，我们就要把最低位的“懒操作”标记数组$b$往更高位更新，也就是开头说的逢$2$进$1$的规则，但是会有一些细节和特殊情况：

设$b_{i-1}$是$b_i$的更高位。（最高位是$b_1$）

1.如果$b_i+a_i \ge 0$，那么$b_{i-1} +=(b_i+a_i)/2$就好了。

2.如果$b_i+a_i \lt 0$，那么$b_{i-1} +=(b_i+a_i-1)/2$。

为什么呢？因为大于$0$时，两数相加满足我为偶数时向前进1。而小于$0$时，我为奇数的时候前面就需要退位。

做完后开始计算真正的$01$串

最后从$n$到$1$（从低位到高位），每次就把这一位的懒操作向前传递，并且计算这一位的值（直接加上然后$\%2$就好了，当然要转换成正数）。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;

int p0,p1;

int a[10000005];
int b[10000005];
char in[6000005];

int main()
{
    scanf("%d%d",&n,&m);
    scanf("%s",in+1);
    int op=0;
    for(int i=1;i<=n;i++)
        a[i]=in[i]-'0';
    scanf("%s",in+1);
    for(int i=1;i<=m;i++)
    {
        if(in[i]=='+')
        {
            b[n]+=1;
        }
        if(in[i]=='-')
        {
            b[n]-=1;
        }
        if(in[i]=='*')
        {
            n++;
            a[n]=0;
            b[n]=0;
        }
        if(in[i]=='/')
        {
            int an=a[n]+b[n];
            if(an<0)
                an-=1;
            b[n-1]+=(an)/2;
            n--;
        }
    }

    for(int i=n;i>=1;i--)
    {
        int an=a[i]+b[i];
        a[i]=((a[i]+b[i])%2+2)%2;
        if(an<0)
            an-=1;
        b[i-1]+=an/2;
    }

    for(int i=1;i<=n;i++)
        printf("%d",a[i]);
    printf("\n");
    return 0;
}

```

---

## 作者：MZMH (赞：0)

这题其实就是一个水题

只要在判断的时候注意一下就好了

注意除法时如果当前小于0，那么就要向前借位！！！

**延迟处理进退位**

```cpp
#include <bits/stdc++.h>
#define File(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout);
using namespace std;
const int MAXN=5e6+10;
int n,m;
int lenc,c[MAXN*2];
char a[MAXN],b[MAXN];
inline int abs(int x) { return x>0?x:-x; }
signed main() {
    // File("two");
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m>>(a+1)>>(b+1);
    lenc=n;
    for(register int i=1;i<=n;i++)
        c[i]=a[i]-'0';
    for(register int i=1;i<=m;i++) {
        if(b[i]=='+')
            c[lenc]++;
        if(b[i]=='-')
            c[lenc]--;
        if(b[i]=='*')
            c[++lenc]=0;
        if(b[i]=='/') {
            if(c[lenc]<0)
                c[lenc-1]-=((abs(c[lenc])+1)>>1);
            else if(c[lenc]>1)
                c[lenc-1]+=(c[lenc]>>1);
            c[lenc]=0,lenc--;
        }
    }
    for(register int i=lenc;i>0;i--)
        if(c[i]<0)
            c[i-1]-=((abs(c[i])+1)>>1),c[i]=(abs(c[i])&1);
        else if(c[i]>1)
            c[i-1]+=(c[i]>>1),c[i]&=1;
    bool flag=0;
    for(register int i=1;i<=lenc;i++)
        if(c[i]!=0||flag)
            putchar(c[i]+'0'),flag=1;
    if(!flag)
        putchar('0');
    return 0;
}

```

---

## 作者：不愿WA的蒟蒻 (赞：0)

# **deque(双端队列)解法**


科普一下deque，

deque 即双端队列。

(deque，全名double-ended queue)是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。

双端队列是限定插入和删除操作在表的两端进行的线性表。这两端分别称做端点1和端点2。也可像栈一样，可以用一个铁道转轨网络来比喻双端队列。在实际使用中，还可以有输出受限的双端队列(即一个端点允许插入和删除，另一个端点只允许插入的双端队列)和输入受限的双端队列(即一个端点允许插入和删除，另一个端点只允许删除的双端队列)。而如果限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻的栈了。

详见[deque](https://blog.csdn.net/zwy18064117182/article/details/52419619)

回归本题，

先全压入deque

处理方面

，* 就用push_back(0);

，/ 就用pop_back();

，+ 就扫到0为止，1全变0，最前面的0变1；

，- 就扫到1为止，0全变1，最前面的1变0；

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	deque <char> rjz;
	cin>>n>>m;
	string yyy;
	cin>>yyy;
	for(register int i=0;i<n;++i){
		rjz.push_back(yyy[i]);
	}
	cin>>yyy;
	for(register int i=0;i<m;++i){
		if(yyy[i]=='*'){
			rjz.push_back('0');
		}
		else if(yyy[i]=='/'){
			rjz.pop_back();
		}
		else if(yyy[i]=='-'){
			int data=0;
			while(rjz.back()=='0'){
				++data;
				rjz.pop_back();
			}
			rjz.pop_back();
			rjz.push_back('0');
			while(data--){
				rjz.push_back('1');
			}
		}
		else if(yyy[i]=='+'){
			int data=0;
			while(rjz.back()=='1'){
				++data;
				rjz.pop_back();
			}
			rjz.pop_back();
			rjz.push_back('1');
			while(data--){
				rjz.push_back('0');
			}
		}
	}
	while(!rjz.empty()){
		cout<<rjz.front();
		rjz.pop_front();
	}
	cout<<endl;
	return 0;
}
```


---


# [NICA #1] 乘只因

## 题目背景

咯咯咯（只因叫）。

## 题目描述


给定 $n,k$，请统计有多少个长度为 $k$ 的序列 $[a_1,a_2,\dots,a_k]$ 满足：

- $a_1\times a_2\times a_3\times \dots\times a_k=n$。
- $1<a_1\leq a_2\leq a_3\leq \dots\leq a_k$。
- 这 $k$ 个数的最小公倍数等于 $n$。


## 说明/提示

#### 【样例解释】

- 只能拆分为 $2\times 5$。
- $2$ 和 $5$ 的最小公倍数为 $10$。

#### 【数据范围】

对于 $100\%$ 的数据，满足 $n,k\leq 10^7$，$T\leq 10^5$。

## 样例 #1

### 输入

```
1
10 2
```

### 输出

```
1```

# 题解

## 作者：zhczcg314 (赞：13)

# B3801题解
### [题目传送门](https://www.luogu.com.cn/problem/B3801)

~~这是一篇写给自己的题解~~
说白了就是写的比较浅，易懂。

给定 $n,k$，去统计符合给定三个要求序列的结果的个数。

看条件：

第一、三个条件中给到了 $n$，那么分析一下：有 $k$ 个数字的乘积是 $n$，且他们的最小公倍数还是 $n$，我们可以得到这 $k$ 个数两两互质。

再来看第二个条件，这 $k$ 个数的序列是非严格单调递增的序列。（没什么用）

那么分析到这里，大概可以感觉到这道题的解法了：先将 $n$ 分解质因数，得到质因数的种类数（注意这里是种类数，不是个数），所有的这些质因数都需要参加到序列的组建中，而数列的长度是 $k$，那么假设质因数种类数大于 $k$，就需要将质因数两两配对或者多个配对，即将它们相乘，最后得出  $k$ 个数字，就是这个序列。但是这里注意一个特殊情况，如果最后求出来的质因数种类数小于 $k$，那么就没有分配策略了，直接特判，答案为 0。

而这道题的问题是要去找序列的个数，那么我非常自然地想到之前做过的一道题，解法和这个类似，[学生分组](https://blog.csdn.net/apple_60774625/article/details/119651401?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%AD%A6%E7%94%9F%E5%88%86%E7%BB%84%E6%96%AF%E7%89%B9%E6%9E%97&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-119651401.142^v88^control_2,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)。看到大佬说的第二类斯特林数，我不禁低下了头……第二类斯特林数的直观体现其实就是上面贴的那个问题，有兴趣的可以去了解一下。

看到这差不多就可以写代码了，加油吧~~



---

## 作者：FFTotoro (赞：10)

注意到题目中有一个很重要的性质：

$$\prod\limits_{i=1}^na_i=\mathrm{lcm}\{a_1,a_2,\ldots,a_n\}$$

易证 $a_i$ 之间两两互质，即 $\forall 1\le i<j\le n,\gcd(a_i,a_j)=1$，所以如果 $n$ 的唯一分解中包含的某个质数有多个，只能放在同一个 $a_i$ 里。于是我们只需统计 $n$ 的唯一分解中包含的质数**种类数** $c$。

问题转化一下，就是如下的形式：

$c$ 个**不同的**球放进 $k$ 个**同样的**盒子里，要求不能有空盒子（即题目中的 $a_i>1$），问有多少种放法？

显然是第二类斯特林数，套递推公式直接计算即可。第二类斯特林数递推公式如下：

$$\begin{Bmatrix}n\\m\end{Bmatrix}=\begin{Bmatrix}n-1\\m-1\end{Bmatrix}+m\begin{Bmatrix}n-1\\m\end{Bmatrix}$$

边界条件为 $\begin{Bmatrix}n\\0\end{Bmatrix}=[n=0]$。这里 $[]$ 指艾弗森括号。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bitset<10000001> b;
vector<int> p;
int f(int n,int m){
  vector<vector<int> > s(n+1,vector<int>(m+1));
  for(int i=0;i<=n;i++)s[i][0]=!i;
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
      s[i][j]=s[i-1][j-1]+j*s[i-1][j];
  return s[n][m];
} // 计算第二类斯特林数
main(){
  ios::sync_with_stdio(false);
  cin.tie(0); cout.tie(0);
  for(int i=2;i<1e7;i++){
    if(!b[i])p.emplace_back(i);
    for(int j:p){
      if(i*j>1e7)break;
      b[i*j]=true;
      if(!(i%j))break;
    }
  } // 线性筛
  int t; cin>>t;
  while(t--){
    int n,k,c=0; cin>>n>>k;
    for(int i:p){
      if(i*i>n)break;
      if(!(n%i))c++;
      while(!(n%i))n/=i;
    } // 统计质数种类数
    if(n>1)c++;
    if(k>c)cout<<"0\n"; // 特判
    else cout<<f(c,k)<<'\n';
  }
  return 0;
}
```

---

## 作者：FlyPancake (赞：6)

# B3801 乘只因（？！！）题解

 
**[题目传送门](https://www.luogu.com.cn/problem/B3801)**
## Ideas
* **首先看题目的三个条件**：
1. $n = a_1 \times a_2 \times a_3 \times \dots \times a_k$。
2. $1 < a_1 \le a_2 \le a_3 \le \dots \le a_k$。
3. 这 $k$ 个数的最小公倍数为 $n$。

---

由 1 和 3 条件可知：$a_1,a_2,a_3,\dots,a_k$ 这几个数**两两互质**。

所以我们接下来只要将对 $n$ 分解质因数，并且统计其**质因数种类数目**（即：是否出现过 $2,5$，若出现过则 $cnt\leftarrow cnt+1$，而不是出现过几次）。

那么接下来只要考虑将这 $cnt$ 个数放入 $k$ 个位置（序列长度），即可将此题转换为如下问题：

**将 $cnt$ 个小球放入 $k$ 个无差别的盒子里，求放置的方法数。**

一眼第二类斯特林（Stirling）数，不知道的可以左转康一康。**[Stirling！](https://zhuanlan.zhihu.com/p/350774728)**


__递推公式：__
```
s[i][j]=j*s[i-1][j]+s[i-1][j-1];
```


那么这道题就结束了！

---
## Code
```
#include<bits/stdc++.h>
using namespace std;

int read(){ // 快读代码(手贱加的)
    int k=0, f=1;
    char c = getchar();
    while(c<'0' || c>'9'){
        if(c=='-') f=-1;
        c = getchar();
    }
    while(c>='0' && c<='9'){
        k = (k<<1) + (k<<3) + (c^48);
        // k = k*10 + c;
        c = getchar(); 
    }
    return f*k;
}


int s[9][9];
// Stirling数存储
// 因为n<=10^7, 所以可以证得cnt<=8

int main(){
    int t, cnt;
    t = read();
    s[0][0]=1;
    // 第二类Stirling数计算
    for(int i=1; i<=8; ++i){
        for(int j=1; j<=8; ++j){
            s[i][j]=j*s[i-1][j]+s[i-1][j-1];
        }
    }
    int n, k;
    while(t--){
        cnt=0;
        n = read(), k = read();
        // 分解质因数
        for(int i=2; i*i<=n; ++i){
            if(n%i == 0) cnt++; // 记录质因数种类
            while(n%i == 0) n/=i;
        }
        if(n > 1) cnt++; // 最后分解出来的数
        // 例: n=10 -> n=n/i=5(i=2), cnt++ -> 5>1(a1!=1) ->cnt++
        if(k > cnt) printf("0\n"); // 如果队列数大于质因数种类数，则没有放置方式
        else printf("%d\n", s[cnt][k]);
    }
    return 0;
}
```

Over $\dots$

---

## 作者：_lgh_ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B3801)

首先对 $n$ 进行分解质因数。

记 $n={s_1}^{k_1}{s_2}^{k_2}\cdots{{s_{cnt}}^{k_{cnt}}}$，其中 $cnt$ 表示质因数个数。

因为 $n\le {10}^7$，所以我们可以证明 $cnt\le 8$。 

然后我们考虑一个性质：对于每个质因数 $s_i$，**这 $k_i$ 个 $s_i$ 都在序列 a 的同一项中**。

考虑使用反证法证明。

假设这些 $s_i$ 不在序列 a 的一项中。

因为序列 a 的 $k$ 个数的最小公倍数等于 $n$，所以这 $k$ 个数中含有 $s_i$ 的数中，应该有一个含有 ${s_i}^{k_i}$，这点由最小公倍数的定义可以得出。

但是又因为这些 $s_i$ 不在同一项中，因此不可能存在有一项 $a_j$ 中含有 ${s_i}^{k_i}$，矛盾，所以命题得证。

因此问题转化为将 $cnt$ 个质因数放入 $k$ 个位置。

可以发现这是第二类斯特林数的定义，直接 $O({cnt}^2)$ 递推即可。

当然，也可以通过 dfs 来单次求 $S(cnt,k)$，~~反正数据范围小啥都能过~~。

### CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,k,cnt,s[9][9];
int main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  s[0][0]=1;
  for(int i=1; i<=8; i++)
    for(int j=1; j<=8; j++)
        s[i][j]=j*s[i-1][j]+s[i-1][j-1];
  cin>>t;
  while(t--){
    cin>>n>>k;
    for(int i=2; i*i<=n; i++){
      if(n%i==0){
        cnt++;
        while(n%i==0)n/=i;
      }
    }
    if(n>1) cnt++;
    if(k>cnt) cout<<"0\n";
    else cout<<s[cnt][k]<<'\n';
    cnt=0;
  }
  return 0;
}
```

---

## 作者：hjqhs (赞：2)

一眼丁真，鉴定为数学题。  
由条件 $1$ 和条件 $3$ 易得 $a_1,a_2,\dots,a_k$ 两两互质。  
于是对 $n$ 分解质因数，统计不同质因子数量。记数量为 $t$，则题目变成将这 $t$ 个数放入长度为 $k$ 的序列。就是第二类 Stirling 数。  
然后就做完了。
```cpp
#include<bits/stdc++.h>
// #define int long long
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define per(i,a,b) for(int i=b;i>=a;--i)
#define pv(i,p) for(int i=0;i<p.size();++i)
#define ptc putchar
#define il inline
#define reg register
// #define push_back pb
#define mp make_pair
#define eb emplace_back
// #define ret; return 0;
using namespace std;
const int N=100005;
const int MOD=998244353;
const int INF=0x3f3f3f3f;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
int Max(int a,int b){return a>b?a:b;}
int MAX(int a,int b,int c){return Max(a,Max(b,c));}
int Min(int a,int b){return a<b?a:b;}
int MIN(int a,int b,int c){return Min(a,Min(b,c));}
void Swap(int&a,int&b){int tmp=a;a=b;b=tmp;}
int read(){
  int x=0,f=1;
  char ch=getchar();
  while(ch<'0'||ch>'9'){
    if(ch=='-')f=-1;
    ch=getchar();
  }
  while(ch>='0'&&ch<='9'){
    x=(x<<3)+(x<<1)+(ch^48);
    ch=getchar();
  }
  return x*f;
}
int T,s[11][11],n,k,cnt;
void init(){
  s[0][0]=1;
  for(int i=1;i<=8;++i){
    for(int j=1;j<=8;++j){
      s[i][j]=j*s[i-1][j]+s[i-1][j-1];
    }
  }
}
void clear(){
  cnt=0;
}
void solve(){
  cin>>n>>k;
  for(int i=2;i*i<=n;++i){
    if(!(n%i))++cnt;
    while(!(n%i))n/=i;
  }
  if(n>1)++cnt;
  if(cnt<k){
    cout<<0<<'\n';
  }else{
    cout<<s[cnt][k]<<'\n';
  }
}
signed main(){
  // freopen(,,stdin);
  // freopen(,,stdout);
  ios::sync_with_stdio(0);
  cin.tie(0);
  cin>>T;
  init();
  while(T--){
    clear();
    solve();
  }
  return 0;
}
```

---

## 作者：KarmaticEnding (赞：1)

如果有 $k$ 个数，满足 $a_1\times a_2\times……\times a_k=n$，并且这 $k$ 个数的最小公倍数又是 $n$，那么我们可以确定：这些数全部互质。

证明：

假设这其中有两个数 $a_1$ 和 $a_2$ 不互质，那么这两个数的最小公倍数就是 $a_1\times a_2 \div \gcd(a_1,a_2)$（其中 $\gcd(a_1,a_2)>1$），那么这 $k$ 个数的最小公倍数的最小值就是 $a_1\times a_2 \div \gcd(a_1,a_2)\times a_3\times a_4 \times……\times a_k=\frac{n}{\gcd(a_1,a_2)}$。证毕。

如若这些数全部互质，那么，设 $n=p_1^{a_1}\times p_2^{a_2}\times……\times p_x^{a_x}$（其中 $p_1,p_2,……p_x$ 全为质数），则要使所有乘数互质，每一个乘数必然可以表示为 $p_{i_1}^{a_{i_1}}\times p_{i_2}^{a_{i_2}}\times p_{i_3}^{a_{i_3}}\times p_{i_4}^{a_{i_4}}\times……\times p_{i_j}^{a_{i_j}}$（其中 $i_1,i_2,i_3,i_4,……i_j\in \{a_1,a_2,……,a_x \}$）

也就是说，我们只要分解质因数，得到 $n$ 的质因数数量 $d$，然后求出 $C_d^k$ 即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long T;
long long n,k;
set<long long> prime_divisor;
void Prime_Factor(long long x){//分解质因数
	prime_divisor.clear();
	if(x==2){
		prime_divisor.insert(2);
	}
	else{
		for(long long i=2;i<=x/i;++i){
			if(x%i==0){
				prime_divisor.insert(i);
				while(x%i==0){	
					x/=i;
				}
			}
			else{
				continue;
			}
		}
		if(x>1){
			prime_divisor.insert(x);
		}
	}
}
long long Factorial(long long x){//计算阶乘
	if(x==0){
		return 0;
	}
	long long res=1;
	for(long long i=2;i<x;++i){
		res*=i;
	}
	return res;
}
long long C(long long a,long long b){//组合运算
	if(a==b){
		return 1;
	}
	return Factorial(a)/Factorial(a-b)/Factorial(b);
}
int main(){
	scanf("%lld",&T);
	for(long long u=0;u<T;++u){
		scanf("%lld%lld",&n,&k);
		Prime_Factor(n);
		if(k>n){
			printf("0\n");
			continue;
		}
		if(k==0){
			printf("0\n");
			continue;
		}
		printf("%lld\n",C(prime_divisor.size(),k));
	}
	return 0;
}

```

---

## 作者：hzxphy (赞：1)

- 先看看题目的三个条件：
1. $n = a_1 + a_2 + ...... + a_k$
1. $1 < a_1 \le a_2 \le a_3 \le ...... \le a_k$
1. 这 $k$ 个数的最小公倍数为 $n$

由条件 $1$ 和条件 $3$ 得知，若所有数非互质，则不满足条件 $3$ 。

所以我们对 $n$ 分解质因数，并记录其对应个数。

code:

```cpp
for (int i = 2; i * i <= n; i++)
{
	if (n % i == 0) {
   	  cnt++;
	}
	while (n % i == 0)
	{
		n /= i;
	}
}
```

接下来问题转化为：将 $cnt$ 个数放入 $k$ 个无差别的盒子里，求放置的方案数。

[斯特林](https://zhuanlan.zhihu.com/p/350774728)

可以对此做出递推公式

```cpp
dp[i][j] = j * dp[i - 1][j] + dp[i - 1][j - 1];
```

由于为了防止抄袭，就不放代码了。

望管理审核通过。

---

## 作者：123456789dd (赞：0)

### 分析

分析题目中的三个条件可知，需要先对 $\it n$ 进行质因数分解。若假设 $\it n = {p_1}^{d_1} \times {p_2}^{d_2} \times \dots \times {p_n}^{d_n}$，其中 ${p_i}$ 表示每个质因子，而 ${d_i}$ 则表示对应质因子的指数。

我们会想到一个思路，就是对于每一个质因数，该 ${d_i}$ 个这个质因数都在一项中，也就是说 ${d_i}$ 个 ${p_i}$ 必须在同一项中，不可能出现分开的情况。

那么如何证明呢?

#### 证明

方法：反证法。

若 ${d_i}$ 个质因数 ${p_i}$ 不在同一项中，且设序列一共有 $\it len$ 项，就可以推导：

因为 $\it len$ 个数的最小公倍数等于 $\it n$。

所以 $\it len$ 个数中含有因数 ${s_i}$ 的数中一定有一个含有因数 ${s_i}^{k_i}$。

与假设矛盾，即原命题成立。

### 继续分析

也就是将 $\it n$ 个质因子放入 $\it k$ 个位置，也就是斯特林数，递推，${n^2}$ 的时间复杂度。

整体思路：先分解质因数求质因子个数，再特判，细节见代码注释即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[9][9],cnt=0,n,k;//f数组即求斯特林数,cnt在这里定义是因为后面函数里用到了cnt
void chicken()//分解质因数，求质因子
{
    for(int i=2;i*i<=n;i++)//直接枚举不同的质因子
    {
        if(n%i==0)//若能整除
        {
            cnt++;//不同的质因子个数加一
            while(n%i==0) n/=i;//判断有没有其他的质因子i
        }
    }
}
int main()
{
    f[0][0]=1;//初始化
    //求斯特林数
    for(int i=1;i<=8;i++)
    {
        for(int j=1;j<=8;j++)
        {
            f[i][j]=j*f[i-1][j]+f[i-1][j-1];
        }
    }
    int t;
    cin>>t;
    while(t--)//t组数据
    {
        cin>>n>>k;
        chicken();//求不同的质因子数量
        if(n>1) cnt++;//若没有除完，即说明有一个较大的质因子，最后肯定只剩最后一个
        if(k>cnt) cout<<0<<endl;//若所需质因子数量大于这个数所有的质因子数量，就说明无解，输出0
        else cout<<f[cnt][k]<<endl;//若有解，则输出对应的斯特林数
        cnt=0;//数量清空
    }
    return 0;//完美结束程序
}
```


---

## 作者：Frozen_Ladybug (赞：0)

首先对输入的 $n$ 分解质因数，记 $n=p_1^{d_1} \times p_2^{d_2} \times ... \times p_n^{d_n}$，其中每个 $p_i$ 表示质因子，每个 $d_i$ 表示指数。

接下来考虑这样一个命题：每一个质因数 $p_i$，这 $d_i$ 个 $p_i$ 都在序列的同一项中。下面使用反证法证明。

如果这 $d_i$ 个质因数不在序列的同一项中，因为序列的 $k$ 个数的最小公倍数等于 $n$，所以这 $k$ 个数中含有 $s_i$ 的数中一定有一个含有 ${s_i}^{k_i}$。但是又与我们的假设矛盾，原命题得证。

这样就是将 $n$ 个质因子放入 $k$ 个位置，这就是第二类斯特林数的定义，递推即可，时间复杂度 $O(n^2)$。因为数据较小，使用深搜单独求也行。

最后在写代码的时候需要加上特判，如果需要的质因子个数大于这个数有的质因子个数，说明无解，输出 $0$。

```c
#include<bits/stdc++.h>
using namespace std;
int t,n,k,m,s[9][9];//s就是要求的斯特林数
int main(){
    s[0][0]=1;//从0个里面选出0个,方案数为1
    for(int i=1;i<=8;i++)
        for(int j=1;j<=8;j++) s[i][j]=j*s[i-1][j]+s[i-1][j-1];
        //斯特林数的递推
    scanf("%d",&t);//先读入测试数据的个数
    while(t--){
        scanf("%d%d",&n,&k);//每次读入两个正整数n,k
        for(int i=2;i*i<=n;i++)//直接枚举每一个可能的因子
            if(n%i==0){//如果能够整除
                m++;//不同的质因子个数+1
                while(n%i==0) n/=i;//一直除到没有相同的可除尽的质因子
            }
        if(n>1) m++;//如果还剩东西,说明有一个较大的质因子,一定最后只会剩下小于一个
        if(k>m) printf("0\n");//需要的质因子个数大于这个数所有的质因子个数,说明无解
        else printf("%d\n",s[m][k]);//如果有解,输出斯特林数对应的值
        cnt=0;//重新初始化
    }
    return 0;
}
```


---


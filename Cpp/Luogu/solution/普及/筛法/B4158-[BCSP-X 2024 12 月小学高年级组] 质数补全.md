# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# 题解

## 作者：2789617221guo (赞：9)

## 思路

这题是一道简单的 DFS 搜索题，在读入字符串 $str$ 后，遍历 $str$，如果 $str[i]$ 为 `*`，则计数器 $p$ 加一，并且记录下来当前的位置 $i$（为后面的 DFS 搜索位置做铺垫）。

这里可以进行一个特判：若 $p=0$（即没有污点），则直接判断 $str$ 表示的数是否是质数，如果是的话直接输出 $str$，否则输出 -1（无解）。

否则就调用函数 `dfs(int t,string s)`，其中 $t$ 表示当前在搜索的是第 $t$ 个数位，$s$ 表示当前的已经修改 $t-1$ 个被污染数位后的字符串。如果 $t>p$（即已经搜索完所有的污染数位），就判断 $s$ 是否是质数，若是的话就直接输出 $s$，并且判断最小答案的变量 $flag$ 记为 true，后面的所有 `DFS` 函数直接return；其他情况下，若当前枚举的数位 $c(pos[t])$ 是第 0 位（即开头），就从 1 到 9 枚举数字（防止前导 0），然后带入 $s$ 进行下一次 `dfs` 递归，否则就从 0 到 9 枚举数字。

最后，不要忘了在每个数据组开始时清空所有变量。
## 代码（我知道你们在等的是这个）
```cpp
#include <bits/stdc++.h>
#define endl '\n'

using namespace std;

const int INF = 0x3f3f3f3f;
const double EPS = 1e-8;
const int N = 10;

string str;
int p, pos[N];
bool flag = 0;

bool prime(string s) {
    int a = atoi(s.c_str());
    if (a <= 1)
        return 0;
    for (int i = 2; i * i <= a; i++) {
        if (a % i == 0)
            return 0;
    }
    return 1;
}

void dfs(int t, string s) {
    if (flag)
        return;
    if (t > p) {
        if (prime(s)) {
            cout << s << endl;
            flag = 1;
        }
        return;
    }
    int c = pos[t];
    if (c == 0) {
        for (int i = 1; i <= 9; i++) {
            s[c] = i + '0';
            dfs(t + 1, s);
            s[c] = '*';
        }
    } else {
        for (int i = 0; i <= 9; i++) {
            s[c] = i + '0';
            dfs(t + 1, s);
            s[c] = '*';
        }
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        cin >> str;
        p = 0;
        for (int i = 0; i < str.size(); i++) {
            if (str[i] == '*') {
                pos[++p] = i;
            }
        }
        flag = 0;
        if (p == 0) {
            if (prime(str))
                cout << str << endl;
            else {
                cout << -1 << endl;
            }
        } else {
            dfs(1, str);
            if (!flag)
                cout << -1 << endl;
        }
    }
    return 0;
}
```
## Upd 25.3.4 AC记录
[AC](https://www.luogu.com.cn/record/204689898)。

~~**管理大大求过，我已经交了5次了QWQ**~~

---

## 作者：yuhaotian000 (赞：6)

~~考场上睡着了，只水过了这一道题。~~
# 质数补全 题解
我的考场代码太过于难看，所以其实这是一篇全新出炉的题解。

## 题目大意
有一些质数，但是质数的某些数位不告诉你，请你判断这能否是一个质数。如果是，输出最小的可能，否则输出 $-1$。

## 题目解法
大多人想到了搜索解法，但我的想法与众不同。我们先来说一下为什么能用搜索，原因很简单就是 $n \le 7$ 的数据范围太过于小，导致七重循环都可以过。这里我提到了“七重循环”，没错我就是这么“七重循环”写的。

## 具体写法
我写的数组很多，所以可能会有点绕。

首先定义一个 $vis$ 数组来判断第 $i$ 个数是否确定，接着定义两个数组 $st$ 与 $en$，代表第 $i$ 个数位的范围。注意，如果这个数位为固定的那就是那个数，否则范围是 $0\sim9$。

用字符串来存储整个数，接着完成上述内容，最后七重循环，看组合出来的数是否为质数，如果是的话直接输出即可。而如果循环后，没有任意一个数满足要求，输出 $-1$。

## AC code
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[10];
int vis[10];
int st[10],en[10];
bool is_prime(int x){ // 判断质数
	if(x==0||x==1) return false;
    for(int i=2;i<=sqrt(x);i++){
        if(x%i==0){
            return false;
        }
    }
    return true;
}
int main(){
    int t;
    cin>>t;
    while(t--){
        // 初始化
        memset(vis,0,sizeof vis);
        memset(st,0,sizeof st);
        memset(en,0,sizeof en);
        cin>>a;
        int len=strlen(a);
        int sum=0;
        for(int i=0;i<len;i++){
            if(a[i]=='*'){
                vis[i]=1;
                sum++;
            }
        }
        for(int i=0;i<len;i++){
            if(vis[i]==0){ // 如果是固定的，那么循环时直接固定数
                st[7-len+i]=a[i]-'0';
                en[7-len+i]=st[7-len+i];
            }else{ // 否则将所有数全部循环一遍
                st[7-len+i]=0;
                en[7-len+i]=9;
            }
        }
        bool flag=0; // 判断是否有数满足条件
        // 开始循环
        for(int i1=st[0];i1<=en[0];i1++){
            for(int i2=st[1];i2<=en[1];i2++){
                for(int i3=st[2];i3<=en[2];i3++){
                    for(int i4=st[3];i4<=en[3];i4++){
                        for(int i5=st[4];i5<=en[4];i5++){
                            for(int i6=st[5];i6<=en[5];i6++){
                                for(int i7=st[6];i7<=en[6];i7++){
                                    if(is_prime(i1*1000000+i2*100000+i3*10000+i4*1000+i5*100+i6*10+i7)&&flag==0){
                                        cout<<i1*1000000+i2*100000+i3*10000+i4*1000+i5*100+i6*10+i7;
                                        flag=1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if(flag==0){
            cout<<-1;
        }
        cout<<endl;
    }
    return 0; // 好习惯
}
```

---

## 作者：canwen (赞：3)

注意到 $t \le 10,1 \leq |s| \leq 7$，也就是最终这个质数的值不会超过 $10^{7}$，那么使用根号算法判断质数的复杂度是比线性筛还优的。

爆搜即可，每个 `*` 的位置枚举 $0 \sim 9$（除了首位不能为 $0$），从最后一位跑到首位即可，加上最优性剪枝，对于我代码最后的数据，在洛谷可以跑到 $392$ ms 的好成绩。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
#define nowtime (double)clock()/CLOCKS_PER_SEC
int in(){int k=0,kk=1;char a=getchar();while(!isdigit(a)){if(a=='-') kk=-1;a=getchar();}while(isdigit(a))k=(k<<3)+(k<<1)+a-'0',a=getchar();return k*kk;}
void out(int a){if(a<0) putchar('-'),a=-a;if(a>9) out(a/10);putchar('0'+a%10);}
string s;
int ans,l;
map <int,int> m;
void dfs(int x,int res){
	if(res > ans) return;
	if(x == -1){
		if(m[res] == -1) return;
		else if(m[res] == 1){
			ans = min(ans,res);
			return;
		}else{
			int f = 0;
			for(int i=2;i<=sqrt(res);++i){
				if(res % i == 0){
					f = 1;
					break;
				}
			}
			if(f == 1) m[res] = -1;
			else{
				m[res] = 1, ans = min(ans,res);
			}
			return;
		}
	}
	if(s[x] == '*'){
		_rep(i,0,9){
			if(i == 0){
				if(x != l-1) dfs(x-1,res+i*pow(10,l-x-1));
			}else dfs(x-1,res+i*pow(10,l-x-1));
		}
	}else{
		dfs(x-1,res+(s[x]-'0')*pow(10,l-x-1));
	}
}
signed main(){
	int t;
	cin>>t;
	while(t--){
		cin>>s, ans = 1e18,l = s.size();
		dfs(l-1,0);
		if(ans == 1e18) cout << "-1\n";
		else out(ans), pc;
	}	
	return 0;
}
/*
10
9******
9******
9******
9******
9******
9******
9******
9******
9******
9******

out:
9000011
9000011
9000011
9000011
9000011
9000011
9000011
9000011
9000011
9000011
*/
```

---

## 作者：mcturtle (赞：3)

## 题意
给你 $n$ 个质数，将它们的某些位隐藏，让你填补隐藏的那些数位，使得这个质数最小，并将这个质数完整地输出；如果这种情况不存在，输出 `-1`。
## 思路
这是一道深搜与质数的好题。

由于 `*` 最多存在 $7$ 个，所以爆搜就完全够用。

先说一说递归部分。

使用一个参数 $p$，代表递归的层数（说白了，就是当前遍历到了这个数的第 $p$ 位）。

如果 $p$ 到达了枚举数的最后一位，就要将这个数判断一下是否为质数。若为质数，就将答案更新，取最小值，并跳出。注意，我们是用字符串来存储的，所以我们要调用 `STL` 函数 `stoi()` 将字符串转为数字。

若 $p$ 没有到达，那就相当于枚举还没有结束。如果该位是数字，就不用考虑，直接递归下一层；如果是 `*` 号，就需要进行如下枚举操作。

循环枚举 $0\sim9$（如果是首位就不能取 $0$ ），将数字更新，搜索下一轮。注意，循环完后要回溯。

主函数没啥可讲的，就是输入输出和更新 `ans`。

判断质数函数就是基本功，$\mathtt{O(\sqrt{n})}$ 就能搞定，没有重点，不知道的可以学习一下。
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int l, ans, t;
bool isp(int x)//判断质数函数
{
    if (x < 2)
        return 0;
    for (int i = 2; i * i <= x; i++)
    {
        if (x % i == 0)
        {
            return 0;
        }
    }
    return 1;
}
void dfs(int p)
{
    if (p == l)
    {
        int k = stoi(s);//转换
        if (isp(k))//是质数
        {
            if (ans == -1 || ans > k)//符合
            {
                ans = k;//更新
            }
        }
        return;
    }
    if (s[p] == '*')//非数字
    {
        for (char i = (p == '0' ? '1' : '0'); i <= '9'; i++)//首位不能为0
        {
            s[p] = i;//更新
            dfs(p + 1);//下一层
        }
        s[p] = '*';//回溯很重要
    }
    else
    {
        dfs(p + 1);//数字直接过
    }
}
int main()
{
    cin >> t;
    while (t--)
    {
        cin >> s;//输入，注意使用字符串
        l = s.size(), ans = -1;//更新初始化
        dfs(0);//开搜
        cout << ans << endl;//输出，记得换行
    }
    return 0;
}
```

---

## 作者：qi__ (赞：3)

从第零位开始 dfs 每一位数字，搜完了就判断是否为质数，是则存为 ans，否则回溯再来，都不行就直接输出

1. atoi 函数：存在于 cstdlib 库中，用来将字符串转换为数字。虽然很少见但是比手写好多了；
2. lambda 表达式 ~~用来装逼~~ 一种比较简洁的函数表达方式，但是需要 c++14 环境；

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;
string s;
int l, ans, t;

//-std=c++14
auto isPrime=[](int x)->bool{if(x<=1)return false;for(int i=2;i*i<=x;i++)if(x%i==0)return false;return true;};
//默写

void search(int nowDigit)
{
    if (nowDigit == s.size())//搜完了
    {
        if (isPrime(atoi(s.c_str())))
               ans = atoi(s.c_str());//string -> int
        return;
    }
    if (s[nowDigit] == '*')//如果这一位未知
    {
        for (char i = (nowDigit == '0' ? '1' : '0'); i <= '9'; i++)//从0到9开始搜
        {
            s[nowDigit] = i;
            search(nowDigit + 1);
        }
        s[nowDigit] = '*';//回溯
    }
    else
        search(nowDigit + 1);//搜下一位
}
int main()
{
    cin >> t;
    while (t-->0)//相当于 for(int i=1;i<=t;i++)
    {
        cin >> s;
        ans = -1;//初始化防止无解
        search(0);
        cout<<ans<<endl; 
    }
    return 0;//QwQ
}
```

---

## 作者：leozhao123 (赞：2)

**[传送门](/problem/B4158) | [AC 记录](/record/204895816)**

**省流：线性筛 + 二分查找。**

~~然而本题这么做是多此一举的，优秀的时间复杂度使它跑出了 546 ms 的好成绩，远不及爆搜~~ ：( 。

-----

$|s|\le7$ 说明所求质数不超过 $10^8$，于是可以预处理出 $[1,10^8]$ 之间所有质数（存在 $pri$ 数组中）。

每次询问时求出 $s$ 所表示数最大、最小可能情况（分别记为 $maxP,minP$），并从小到大检查 $[minP,maxP]$ 之间的质数是否符合 $s$ 的格式直到出解。


- **Q**：如何求 $[1,10^8]$ 之间所有质数？  
**A**：线性筛 + `bitset`，见 [P3383](/problem/P3383)。

- **Q**：如何求 $maxP,minP$？  
**A**：遍历 $s$ 的每一位，若某一位为数字则这照抄，否则这一位上 $maxP$ 为 $9$，$minP$ 为 $0$。

  例如，当 $s=\texttt{1*1*810}$ 时，$maxP=1919810,minP=1010810$。

- **Q**：如何找到 $[minP,maxP]$ 之间的质数？  
**A**：二分查找。调用 STL 的查找函数 `lower_bound` 和 `upper_bound` 找到 $minP,maxP$ 在 $pri$ 中的位置。

-----

此解法理论最劣时间复杂度为 $\mathcal{O}(t\cdot n\cdot |s|)$，其中 $n=5761455$ 为 $[1,10^8]$ 之间质数个数。但实际不会超时，因为一旦发现答案就退出循环了，而质数分布较密，所以不会花太多时间。

```cpp
// By leozhao123
// -std=c++14 -O2

#include<bitset>
#include<iostream>
#include<algorithm>
using namespace std;
using u32=unsigned int;
const u32 N=1e8;
u32 pri[N+1],cnt;
bitset<N+1>vis;// 节省空间
void get_prime() {// 求 [1,10^8] 之间质数
	for(u32 i=2;i<=N;++i) {
		if(!vis[i]) pri[++cnt]=i;
		for(u32 j=1;j<=cnt&&1LL*i*pri[j]<=N;++j) {
			vis[1LL*i*pri[j]]=1;
			if(i%pri[j]==0) break;
		}
	}
}
int main() {
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	u32 t,maxP,minP,l,r;
	bool flg;
	string s;
	get_prime();
	cin>>t;
	while(t--) {
		cin>>s;
		maxP=minP=0;
		flg=0;
		for(auto j=s.begin();j!=s.end();++j) {
			if(*j=='*') {
				minP=minP*10;
				maxP=maxP*10+9;
			}
			else {
				minP=minP*10+(*j)-'0';
				maxP=maxP*10+(*j)-'0';
			}
		}
		l=lower_bound(pri+1,pri+cnt+1,minP)-pri;// 第 1 个大于等于 minP 的质数位置
		r=upper_bound(pri+1,pri+cnt+1,maxP)-pri;// 第 1 个大于 maxP 的质数位置
		for(u32 i=l,k;i<r;++i) {
			auto j=s.end();
			for(--j,k=1;;--j,k*=10) {
				if(*j=='*') continue;
				if(pri[i]/k%10!=(u32)(*j-'0')) break;
				if(j==s.begin()) {
					flg=1;
					break;
				}
			}
			if(flg) {
				cout<<pri[i]<<'\n';
				break;
			}
		}
		if(!flg) cout<<"-1\n";
	}
	return 0;
}
```

---

## 作者：_lxc__ (赞：2)

考虑质数筛。

* 首先欧拉筛出 $10^7$ 以内的质数，存入 vector 中。

* 接着对于每一个未补全的数字，遍历存放质数的 vector，将 vector 中的质数通过 `to_string` 函数变为字符串，判断是否与当前输入字符串 $s$ 可以补全成这个质数，判断条件如下：

  * 如果这两个字符串长度不等，直接返回 $0$。
 
  * 如果长度相等但字符串中的某一位字符不相等且不为 $*$，也返回 $0$。
 
  * 否则返回 $1$。
 
总时间复杂度为 $O(10^7+t\times q)$，其中 $q$ 为质数个数。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+10,M=2e6;
bool vis[N];
int prime[M],t,cnt=0;
string s;
vector<int> v;
void init(){
	vis[0]=vis[1]=1;
	for(int i=2;i<=10000000;i++){
		if(vis[i]==0){
			prime[++cnt]=i;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=10000000;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]==0) break;
		}
	}
	for(int i=1;i<=10000000;i++){
		if(!vis[i]) v.push_back(i);
	}
}
//质数筛
bool chk(string a,string b){
	if(a.size()!=b.size()) return 0;
	for(int i=0;i<a.size();i++){
		if(a[i]!=b[i]&&b[i]!='*') return 0;
	}
	return 1;
}
//判断函数
int main(){
	init();
	cin>>t;
	while(t--){
		bool f=0;
		cin>>s;
		for(auto i:v){
			string a=to_string(i);
			if(chk(a,s)){
				f=1;
				cout<<i<<"\n";
				break;
			}
		}
		if(!f) cout<<"-1\n";
	}
	return 0;
}

```

---

## 作者：zh_felix (赞：2)

# B4158 题解
### Step 0 前言 Preface
~~[博客食用更佳](https://www.luogu.com.cn/article/eg2bcmoc)~~ 知周所众，BCSP-X 是北京的一场比赛，小高组中就做出来这一道，所以只能把这一道的题解写了。
### Step 1 思路 Idea
很简单，一道大模拟，但代码量很大。梳理一下思路：首先就是枚举每种补全这个数字的方案，判断是否是质数，如果是质数，就输出，不在枚举。需要以下这些函数：
1. 深搜：用来枚举每种补全这个数字的方案。
2. 判断质数：判断这个数是不是质数。
3. 字符串转数字：把字符串转为`int`类型的数字。
4. 寻找弄脏的地方：把这个数字的污损下标保存起来。
### Step 2 代码 Code
先是寻找弄脏的地方，我们把脏的地方下标存在`vector`里面：
```cpp
void finddirt(string s) {
	for(int i = 0;i<s.length();i++) {
		if(s[i]=='*') {
			dirt.pb(i);  // dirt就是所有脏的地方的下标
		}
	}
}
```
接着是转`int`，顺序遍历每个字符，每次答案就是答案乘 $10$ 加上当前字符：
```cpp
int to_int(string s) {
	int ans=0;
	for(int i = 0;i<s.length();i++) {
		ans=ans*10+(s[i]-'0');  // 更新答案
	}
	return ans;
}
```
然后是判断质数，一个模板，直接套：
```cpp
bool is_prime(int x) {  // 判断质数模板
	if(x<2) {
		return false;
	}
	for(int i = 2;i*i<=x;i++) {
		if(x%i==0) {
			return false;
		}
	}
	return true;
}
```
最后是深搜，这可以剪枝，找到可以的就直接返回，不继续搜了：
```cpp
void dfs(int step) {
	if(step==dirt.size()) {
		if(is_prime(to_int(s))&&!flag) {
			ps(s.c_str());
			flag=true;  // 剪枝
		}
		return;
	}
	if(!flag) {  // 剪枝
		for(int i = 0;i<10;i++) {
			s[dirt[step]]=i+'0';
			dfs(step+1);
		}
	}
}
```
注意，如果没找着就输出 $-1$ ，完整代码：
```cpp
#include<bits/stdc++.h>
#define llmax numeric_limits<long long>::max()
#define llmin numeric_limits<long long>::min()
#define imax numeric_limits<int>::max()
#define imin numeric_limits<int>::min()
#define pb push_back
#define gc getchar
#define pc putchar
#define ps puts
#define nl ps("")
#define ir iterator
#define dis(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
using namespace std;
vector<int> dirt;
bool flag;
string s;
bool is_prime(int x) {  // 判断质数模板
	if(x<2) {
		return false;
	}
	for(int i = 2;i*i<=x;i++) {
		if(x%i==0) {
			return false;
		}
	}
	return true;
}
void finddirt(string s) {
	for(int i = 0;i<s.length();i++) {
		if(s[i]=='*') {
			dirt.pb(i);  // dirt就是所有脏的地方的下标
		}
	}
}
int to_int(string s) {
	int ans=0;
	for(int i = 0;i<s.length();i++) {
		ans=ans*10+(s[i]-'0');  // 更新答案
	}
	return ans;
}
void dfs(int step) {
	if(step==dirt.size()) {
		if(is_prime(to_int(s))&&!flag) {
			ps(s.c_str());
			flag=true;  // 剪枝
		}
		return;
	}
	if(!flag) {  // 剪枝
		for(int i = 0;i<10;i++) {
			s[dirt[step]]=i+'0';
			dfs(step+1);
		}
	}
}
int main() {
	int t;
	cin>>t;
	while(t--) {
		flag=false;
		cin>>s;
		dirt.clear();
		finddirt(s);
		if(dirt.size()==0&&is_prime(to_int(s))) {  // 优化，本身没有污损并且是质数就直接输出，否则输出-1
			ps(s.c_str());
			continue;
		} else if(dirt.size()==0&&!is_prime(to_int(s))) {
			ps("-1");
			continue;
		}
		dfs(0);
		if(!flag) {
			ps("-1");
		}
	}
	return 0;
}
```

---

## 作者：x11223344 (赞：1)

## Subtask 1
因为 $s$ 中没有 `*`，所以直接判断 $s$ 是否为质数即可。
## 正解
每次从 $s$ 中找出第一个 `*` 的位置：
- 如果存在，就枚举这个位置的数字，然后重复以上过程。
- 如果不存在，直接判断这个数是否为质数即可，如果是，返回这个数；如果不是，返回 $-1$。

但是，考虑到最极端情况的 $s$ 为 `x******`，其中 $x$ 为非零数字，此时需要判断 $10^6$ 次质数，如果每次都 $O(\sqrt{n})$ 判断质数会超时。因此需要先使用埃氏筛筛出 $1 \sim 10^7$ 的所有数是否为质数，每次 $O(1)$ 判断。

---

## 作者：lizhixun (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4158)

### $\texttt{Description}$

有一个数字缺了若干位，现在要将这些数位补充，使其成为一个质数。现在要求这个质数的最小值。本题有多组数据。

### $\texttt{Solution}$

看到数据范围很小，于是爆搜。我们只需要在每一个星号的地方枚举 $0\sim9$ 这些数字，最后判断数字是否是质数即可。

对于质数判断，只需要用正常的 $O(T\sqrt{n})$ 即可，因为用筛法 $O(n \log n)$ 直接炸掉。不过 $O(T\sqrt n)$ 大概还要加几倍的常数，应该可以忽略不记。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int T, ans;
string s;

bool pr(int x) {
	if (x < 2) return 0;
	for (int i = 2; i <= x / i; i++) {
		if (x % i == 0) return 0;
	}
	return 1;
}

void dfs(int step, string ss) {
	if (ss.size() == s.size()) {
		int num = stoi(ss);
		if (pr(num) == 1) ans = min(ans, num);
		return;
	}
	if (s[step] != '*') dfs(step + 1, ss + s[step]);
	else for (char i = '0'; i <= '9'; i++) dfs(step + 1, ss + i);
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> T;
	
	while (T--) {
		cin >> s;
		ans = INT_MAX;
		dfs(0, "");
		
		if (ans == INT_MAX) cout << -1 << "\n";
		else cout << ans << "\n";
	}
	return 0;
}
```

最慢的点大概 500 毫秒左右，还算可以。完结。

---

## 作者：LG086 (赞：0)

$t$ 组数据。每组数据是一个模糊的质数，让你把每个未知的地方替换为一个数字，看能否把数字串填补成一个质数，还要求这个质数最小。

注意到 $s$ 最长不超过 $7$ 位，最高位保证已知，最坏情况下后六位全部未知，每个未知的位置我们都从 $0$ 到 $9$ 枚举，那么需枚举 $10^6$ 次，当然实际上并不会枚举很多次，所以放心写暴力就行了。使用试除法暴力判断质数，如果是一个质数，直接输出。否则继续枚举。


核心代码：

```cpp
void dfs(int i,int num,int len){
    if(flag)return ;
    if(i == len){
        if(check(num))
            cout << num << "\n",
            flag = 1;
        return ;
    }
    if(s[i] != '*')
        dfs(i+1,num*10+s[i]-48,len);
    else
        for(int _ = 0;_ <= 9;_ ++)
            dfs(i+1,num*10+_,len);
    return ;
}
```

这么纯的暴搜竟然只跑了 4ms，属实惊人。

---

## 作者：aaalys (赞：0)

### 暴力

暴力 dfs，判断是否为质数即可，时间复杂度为 $10^{\lvert s \rvert}$，加上特殊性质可以获得 89 分。

### 正解

发现 $\lvert s \rvert \le 7$，即最终的质数 $\le 10^7$，而 $10^7$ 内的质数只有大约 $6.6 \times 10^5$ 个质数。
所以可以先预处理 $10^7$ 内的质数，对于每一次查询，枚举每个质数，判断是否可行，找到可行的最小解。

### Code (只展示关键代码)

```cpp
int t, cnt;
int isprm[N], primes[N];//primes[]数组存1e7以内所有质数。
void init(){//线性筛预处理1e7内所有质数。
	memset(isprm, 1, sizeof(isprm));
	isprm[0] = isprm[1] = 0;
	for (int i = 2; i <= 1e7; i++){
		if (isprm[i]){
			primes[++cnt] = i;
		}
		for (int j = 1; j <= cnt && i * primes[j] <= 1e7; j++){
			isprm[i * primes[j]] = 0;
			if (i % primes[j] == 0)break;
		}
	}
}
inline bool check(string s, int t){//检查。
	string s2 = to_string(t);//先把数转化成字符串。
	if (s.size() != s2.size())return false;
	for (int i = 0; i < s.size(); i++)
		if (s[i] != s2[i] && s[i] != '*')//不合法，返回 false。
        return false;
	return true;
}
init();
while (t--){
    string s;
    cin >> s;
    bool flag = 0;
    for (int i = 1; i <= cnt; i++)
        if (check(s, primes[i])){//检测到答案。
            cout << primes[i] << '\n';
            flag = 1;
            break;
        }
    if (!flag)cout << "-1\n";//没找到答案，输出 -1。
}
```

---

## 作者：_Deer_Peach_ (赞：0)

题意已经很简洁了不再赘述。

思路：

搜索，从小到大枚举所有被污染的数字，再判断是否为质数，这样就能求出最小的质数。因为数字长度最大为 $7$，询问次数最多为 $10$，所以不会超时。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
int t;bool flag;
int num(string s){//字符串转数字
	int nu=0;
	int len=s.size()-1;
	if(s[0]=='0')return 0;//数字最高位不能为0
	for(int i=0;i<len;i++)nu*=10,nu+=s[i]-'0';
	return nu; 
}bool check(int x){//判断质数
	if(x<2)return false;
	for(int i=2;i*i<=x;i++)if(x%i==0)return false;
	return true;
}
void dfs(string x,int id){
	if(flag)return;//已经有答案
	if(x[id]==' '){
		if(check(num(x))){
			cout<<num(x)<<endl;
			flag=true;//标记
		}return;
	}if(x[id]=='*'){
		for(int i=0;i<10;i++){//枚举数字
			x[id]=(char)(i+'0');
			dfs(x,id+1);
		}
	}else dfs(x,id+1);
}signed main() {
	IOS;cin>>t;
	while(t--){
		string s;
		cin>>s;s=s+" ";
		flag=false;
		dfs(s,0);
		if(!flag)cout<<"-1\n";//无解
	}
	return 0;
} 
```

---


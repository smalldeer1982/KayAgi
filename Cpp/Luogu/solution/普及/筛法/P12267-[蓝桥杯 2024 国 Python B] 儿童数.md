# [蓝桥杯 2024 国 Python B] 儿童数

## 题目描述

若一个正整数 $n$ 满足 $n^{61}$ 整除 $2024!$，即 $2024!$ 除以 $n^{61}$ 的余数为 $0$，则称 $n$ 为“儿童数”。其中 $2024!$ 表示 2024 的阶乘，即 $1 \times 2 \times \cdots \times 2024$。

现在，请你计算在区间 $[1, \infty)$ 内一共有多少个“儿童数”。

# 题解

## 作者：Lyx8058 (赞：5)

## 思路：

不难发现我们可以将 $2024!$ 分解成形如 $p_1^{a_1}\times p_2^{a_2}\times ...\times p_m^{a_m}$，其中，$p_1$ 到 $p_m$ 均是质数。

那么若要满足 $2024!$ 是 $n^{61}$ 的倍数，则须满足 $n^{61}$ 分解成 $p_1^{b_1}\times p_2^{b_2}\times ...\times p_m^{b_m}$ 的时候满足 $\forall 1\leq i\leq m$，$a_i\geq b_i$。

那么问题就转化为在 $2024!$ 的质因数里面任意选择若干个数所组成的数有多少个（算上 $1$）。

我们可以知道，分解成以上形式时，可以得到公式为 $\prod_{i=1}^{m} (a_i+1)$，那么由于要得到的数字为 $n^{61}$ 中的 $n$，我们根据乘法原理得到 $\prod_{i=1}^{m} (\lfloor \frac{a_i}{61} \rfloor+1)$。

那么本题也是比较轻松的做完了。

## 代码：

说明：该代码已经过格式化，放心观看。

```cpp
#include<bits/stdc++.h>

#define int long long
using namespace std;
const int N = 2024;
int p[N], cnt = 0, dis[N]; //2024
bool check(int x) {
    for (int i = 2; i <= sqrt(x); i++) {
        if (x % i == 0) return false;
    }
    return true;
}
void solve(int x) {
    int j = 1;
    while (x > 1 && j <= cnt) {
        while (x % p[j] == 0 && x > 1) {
            x /= p[j];
            dis[p[j]]++;
        }
        j++;
    }
    dis[x]++;
    return;
}
signed main() {
    for (int i = 2; i <= 2024; i++) {
        if (check(i)) {
            p[++cnt] = i;
            dis[i]++;
        } else solve(i);
    }
    int ans = 1;
    for (int i = 1; i <= cnt; i++) {
        ans *= (1 + dis[p[i]] / 61);
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：W_C_B_H (赞：5)

题意简述：求 $\begin{aligned}\sum_{n=1}^{\infty}[n^{61}\mid2024!]\end{aligned}$。

考虑先筛出 $[1,2024]$ 范围内的质数（假设共有 $cnt$ 个，依次为 $p_1,p_2,\dots,p_{cnt}$，我的代码中 $p$ 数组记为 `primes`），然后对 $2024!$ 进行质因数分解，记结果为 $\begin{aligned}2024!=\prod_{i=1}^{cnt}{p_i}^{f_i}\end{aligned}$（我的代码中 $f$ 数组记为 `fac`）。

对于正整数 $n$，$n^{61}$ 的质因数分解中每个指数都是原来的 $61$ 倍。而 $n^{61}\mid2024!$ 等价于 $n^{61}$ 的质因数分解中每一个指数都小于等于对应项的 $f_i$。根据乘法原理，答案为 $\begin{aligned}\prod_{i=1}^{cnt}(\lfloor\dfrac{f_i}{61}\rfloor+1)\end{aligned}$。

Code：

```python
N = 2024
is_prime = [True] * N   # 标记是否是素数
is_prime[0] = is_prime[1] = False
primes = []  # 存放素数
cnt = 0  # 素数个数
for i in range(2, N):
    if is_prime[i]:
        primes.append(i)
        cnt += 1
        for j in range(i*i, N, i):
            is_prime[j] = False

# 计算 2024! 的所有因子
fac = [0] * cnt
for i in range(1, N + 1):
    tmp = i
    for j in range(cnt):
        if primes[j] > tmp:
            break
        while tmp % primes[j] == 0:
            fac[j] += 1
            tmp //= primes[j]

# 计算答案
ans = 1
for i in range(cnt):
    ans *= (fac[i] // 61) + 1
print(ans)
```

---

## 作者：_Null_Ptr (赞：3)

# [蓝桥杯 2024 国赛 Python B] 儿童数题解

思路：提交答案题暴力即可，这个题目叫我们枚举所有满足 $n^{61}$ 整除 $2024!$ 的正整数 $n$。由于 $n^{61}$ 要整除 $2024!$，所以对于每个质因数，我们需要计算其在 $n$ 中的最大指数，即该质因数在 $2024!$ 中的指数除以 $61$ 后的商。所以，儿童数的数量就等于每个质因数在 $n$ 中可能的指数组合数的乘积。

下面贴上~~打表~~代码
```python
def count(n, power):
    result = 1
    p = 2
    while p <= n:
        exp = 0
        current = p
        while current <= n:
            exp += n // current
            current *= p
        result *= (exp // power + 1)
        p += 1
        while p <= n and any(p % q == 0 for q in range(2, int(p**0.5) + 1)):
            p += 1
    return result

result = count(2024, 61)
print(result)

```

---

## 作者：KomeijiReimu (赞：2)

https://www.luogu.com.cn/problem/P12267

对 $\displaystyle 2024!$ 分解质因数，得到其每个质因数与对应的指数。
我们对 $\displaystyle n^{61}$ 同样分解质因数，如果出现的所有质因数在 $\displaystyle 2024!$ 的质因数中都存在，且每个质因数的指数都小于等于 $\displaystyle 2024!$ 的每个质因数的指数，那说明当前的 $\displaystyle n^{61}$ 整除 $\displaystyle 2024!$ ，找到了一个儿童数。

要求儿童数的数量，我们就要找到有多少种满足这种条件的数。假设我们分解 $\displaystyle 2024!$ 的质因数结果为（质因数 指数）：
```python
2 61
3 61
```

那么显然儿童数有 $\displaystyle 4$ 个，分别为 $\displaystyle 1,2,3,6$ ，都是由这些质因数组合出来的，具体如下：

对于质因数 $\displaystyle 2$ ，满足条件的有两种情况，分别是 $\displaystyle 2^{0\times 61} \:\text{与}\: 2^{1\times 61}$ ，$\displaystyle 0$ 表示不选择当前质因数的组合。
质因数 $\displaystyle 3$ 同理，因此最终有 $\displaystyle 2 \times 2$ 种情况。

因此对于每一个质因数 $\displaystyle x$ ，其指数为 $\displaystyle e$ ，设其贡献的情况数为 $\displaystyle t$ ，都有儿童数 $\displaystyle n \in \left\{ x^{0\times 61}, x^{1\times 61}\dots \: x^{(t - 1) \times 61}\ | \ t - 1 \leq  \lfloor \frac{e}{61} \rfloor \right\}$ 。则最终的所有情况数，就是每一个质因数的情况数 $\displaystyle t$ 的乘积，即：
$$
\prod \left( \lfloor \frac{e}{61} \rfloor + 1 \right)
$$

算式中 $\displaystyle \lfloor \frac{e}{61} \rfloor$ 表示向下取整。
```python
import sys

n = 1

for i in range(1, 2025):
    n = n * i

i = 2
a = []

# 分解质因数
while i < n // i:
    if n % i == 0:
        cnt = 0
        while n % i == 0:
            cnt += 1
            n = n // i
        a.append((i, cnt))
    i += 1



cnt = 1
for i in a:
    cnt *= i[1] // 61 + 1

sys.stdout.write(str(cnt))

```

---

## 作者：cse071549 (赞：1)

### 题目大意
若一个正整数 $n$ 满足 $n^{61}$ 整除 $2024!$，即 $2024!$ 除以 $n^{61}$ 的余数为 $0$，则称 $n$ 为“儿童数”。需计算在区间 $[1, \infty)$ 内一共有多少个“儿童数”。

### 题目详解
可以先对 $2024!$ 进行质因数分解，找出每个质数 $i$ 对应的指数 $k_i$，然后对于每个质数 $i$，计算最大的 $i$ 在 $2024$ 中的指数，最终答案是所有最大的 $i$ 在 $2024$ 中的指数加上一的乘积。
### 代码示例
```cpp
#include<bits/stdc++.h>
using namespace std;
int c,s[310];
bool vis[2025];
int count(int p,int n){
	int cnt=0;
	while(n>0){
		n/=p;
		cnt+=n;
	}
	return cnt;
}
int main(){
	for(int i=1;i<=2024;i++){
		vis[i]=true;
	}
	for(int i=2;i<=2024;i++){
		if(vis[i]){
			s[++c]=i;
			for(int j=i*2;j<=2024;j+=i){
				vis[j]=false;
			}
		}
	}
	long long ans=1;
	for(int i=1;i<=c;i++){
		int p=s[i];
		int k=count(p,2024);
        ans*=(k/61+1);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：mumuxiao20111101 (赞：0)

## 算法思路

首先使用埃氏筛法生成所有不大于 $2024$ 的素数（欧拉筛也可）。

然后，我们对每个素数 $p$，利用 **Legendre 公式** 计算其在 $2024!$ 中的指数：$e(p)=\sum_{k=1}^{\infty} \left\lfloor \frac{2024}{p^k} \right\rfloor$ 实际计算时，当 $p^k > 2024$ 时终止循环。

接下来就是判定了。对于每个素数 $p$，计算其满足 $n^{61} \mid 2024!$ 的最大指数：$k_{\max} = \left\lfloor \frac{e(p)}{61} \right\rfloor$ 每个素数的可选指数方案数为 $k_{\max} + 1$。

最终结果为各素数方案数的乘积：$\prod_{p \in \mathbb{P}} (k_{\max}^{(p)} + 1)$ 采用高精度处理大数运算。

## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

string Chengfa(string num, int f) {
    string res;
    int c = 0;
    for (int i = num.size() - 1; i >= 0; i--) {
        int dig = num[i] - '0';
        int pro = dig * f + c;
        res.push_back(pro % 10 + '0');
        c = pro / 10;
    }
    while (c > 0) {
        res.push_back(c % 10 + '0');
        c /= 10;
    }
    reverse(res.begin(), res.end());
    return res.empty() ? "0" : res;
}

signed main() {
    int mxp = 2024;
    vector<bool> flag(mxp + 1, true);
    flag[0] = flag[1] = false;
    for (int i = 2; i * i <= mxp; i++) {
        if (flag[i]) {
            for (int j = i * i; j <= mxp; j += i)
                flag[j] = false;
        }
    }   
    vector<int> pri;
    for (int i = 2; i <= mxp; i++)
        if (flag[i]) pri.push_back(i);
    
    string ans = "1";
    for (int p : pri) {
        int e = 0, cur = p;
        while (cur <= 2024) {
            e += 2024 / cur;
            cur *= p;
        }
        ans = Chengfa(ans, e / 61 + 1);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：jsisonx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12267)

# 题目分析

显然的一点是：若 $n_0^{61}$ 是 $n^{61}$ 的因数，$n^{61}$ 是 $2024!$ 的因数，则 $n_0^{61}$ 是 $2024!$ 的因数。因此，只需找到最大的可表示为 $n^{61}$ 的 $2024!$ 的因数，则它的所有形如 $n_0^{61}$ 的因数都是满足条件的数。

首先给一个定理：$k!$ 中质因数 $p$ 的次数为
$$ \operatorname{f}(k)=\sum \limits_{i=1}^\infin (\lfloor \frac{k}{p^i}\rfloor)$$

证明需要另一个定理：小于等于 $k$ 的正整数中，有且仅有 $\lfloor \frac{k}{p} \rfloor$ 个数被 $p$ 整除。

这个定理很好证明：小于等于 $k$ 且被 $p$ 整除的的数形如 $p,2p\dots \lfloor \frac{k}{p} \rfloor p$，一共 $\lfloor \frac{k}{p} \rfloor-1+1=\lfloor \frac{k}{p} \rfloor$ 个。

下面我们来证明第一个定理：在小于等于 $k$ 的正整数中，$p^i$ 的倍数有 $\lfloor \frac{k}{p^i}\rfloor$ 个。因此我们对该式 $i$ 从 $1$ 到 $\infin$ 求和。设 $2,3,4\dots k$ 这些数中，每个数中质因子 $p$ 的次数为 $a_1,a_2\dots a_k$。则 $\operatorname{f}(k)=\sum\limits_{i=1}^k (a_i)$。换一个角度，我们每次从 $a_1$ 到 $a_k$ 中每个数取 $1$ 加到答案中，然后被取了 $1$ 的数全部减 $1$，如果哪个数被减到了 $0$，则下一次就不从这个数中取 $1$。如此，第一轮取到了 $\lfloor \frac{k}{p^1}\rfloor$ 个 $1$，第二轮取到了 $\lfloor \frac{k}{p^2}\rfloor$ 个 $1$，第 $i$ 轮取到了 $\lfloor \frac{k}{p^i}\rfloor$ 个 $1$，求和为 $\sum\limits_{i=1}^k (a_i)$，即为 $\operatorname{f}(k)$，因此定理得证。

设 $2024!=p_1^{t_1} \times p_2^{t_2} \times \dots \times p_r^{t_r}$，$n^{61}=p_1^{61h_1} \times p_2^{61h_2} \times \dots \times p_r^{61h_r}$，则我们有 $61h_i \le \sum \limits_{i=1}^\infin (\lfloor \frac{k}{p^i}\rfloor)$，右侧可以暴力计算，解不等式即为答案。因此最大的形如 $n^{61}$ 的数就是 $p_1^{61H_1} \times p_2^{61H_2} \times \dots \times p_r^{61H_r}$，其中 $H_i$ 为满足上述不等式的最大整数。

设 $n_0=p_1^{61g_1} \times p_2^{61g_2} \times \dots \times p_r^{61g_r}$，则对于任意 $i$，有 $61g_i \le 61H_i$，即 $g_i \le H_i$，因此对于任意 $i$，$g_i$ 的选择为 $0$ 到 $H_i$ 共 $H_i+1$ 个，因此答案为 $\prod\limits_{i=1}^r(H_i+1)$。

经过编程计算，答案为 $17978112$。

---

## 作者：zhongchentao_ (赞：0)

### **方法思路：**
要解决这个问题，我们需要确定所有正整数 $n$ 使 $n^{61}$ 能够整除 $2024!$。换句话说，我们需要找到所有 $n$，使得 $2024!$ 包含至少 $61$ 个 $n$ 的质因数分解中的每个质因数的幂次。

具体步骤如下：

1. 计算 $2024!$ 中每个质数的幂次。

2. 对于每个质数 $p$，其在 $2024!$ 中的幂次为 $e$，那么 $n$ 中 $p$ 的幂次最多为 $e^{61}$。

3. 根据每个质数的限制，计算所有可能的 $n$ 的个数。这相当于计算每个质数幂次限制下的组合数，并将它们相乘。

## _code_ 
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
//分解 n!的质因数分解
map<int, int> f(int n){
    vector<bool>s(n+1,true);
    s[0]=s[1]=false;
    for(int i=2;i*i<=n;i++){
        if(s[i]){
            for(int j=i*i;j<=n;j+=i){
                s[j]=false;
            }
        }
    }
    map<int, int> e;
    for(int p=2;p<=n;p++){
        if(s[p]){
            int c=0;
            int x=p;
            while(x<=n){
                c+=n/x;//计算p在n!中的指数
                x*=p;
            }
            e[p]=c;
        }
    }
    return e;
}
//计算满足条件的子数个数
long long c() {
    map<int, int> e=f(2024);
    long long t=1;
    for (map<int, int>::const_iterator i=e.begin();i!=e.end();i++){ 
        int k=i->second/61;//计算最大的 k 使得 p^61k 能整除 2024!
        t*=(k + 1);//乘法原理计算总数
    }
    return t;
}

int main() {
    cout<<c()<<endl;
    return 0;//好习惯
}
```
输出：$17978112$。

---


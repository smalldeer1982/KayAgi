# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# 题解

## 作者：zjp_shadow (赞：1017)

# 乘法逆元小结

> 乘法逆元，一般用于求 $$\frac{a}{b} \pmod p$$ 的值（$p$ 通常为质数），是解决模意义下分数数值的必要手段。

> [有兴趣可以点进我的博客看看啊qwq](https://www.cnblogs.com/zjp-shadow/p/7773566.html)

## 逆元定义

> 若$a*x\equiv1 \pmod {b}$，且$a$与$b$互质，那么我们就能定义:
$x$ 为 $a$ 的逆元，记为$a^{-1}$，所以我们也可以称 $x$ 为 $a$ 在 $\bmod b$ 意义下的倒数，

> 所以对于 $\displaystyle\frac{a}{b} \pmod {p}$ ，我们就可以求出 $b$ 在 $\bmod {p}$ 下的逆元，然后乘上 $a$ ，再 $\bmod {p}$，就是这个分数的值了。


## 求解逆元的方式

### 拓展欧几里得

这个方法十分容易理解，而且对于单个查找效率似乎也还不错，比后面要介绍的大部分方法都要快(尤其对于 $\bmod {p}$ 比较大的时候)。

这个就是利用拓欧求解 线性同余方程 $a*x \equiv c \pmod {b}$ 的$c=1$的情况。我们就可以转化为解 $a*x + b*y = 1$ 这个方程。

求解这个方程的解。不会拓欧可以点[这里](https://www.cnblogs.com/zjp-shadow/p/9267675.html#autoid-3-3-0)~

而且这个做法还有个好处在于，当 $a \bot p$ （互质），但 $p$ 不是质数的时候也可以使用。

代码比较简单：

```cpp
void Exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) x = 1, y = 0;
    else Exgcd(b, a % b, y, x), y -= a / b * x;
}
int main() {
    ll x, y;
    Exgcd (a, p, x, y);
    x = (x % p + p) % p;
    printf ("%d\n", x); //x是a在mod p下的逆元
}
```

### 快速幂


这个做法要利用 **费马小定理**

> 若$p$为素数，$a$为正整数，且$a$、$p$互质。
则有$a^{p-1} \equiv 1 (\bmod {p})$。

 
这个我们就可以发现它这个式子右边刚好为 $1$ 。


所以我们就可以放入原式，就可以得到：


$$a*x\equiv 1 \pmod p$$


$$a*x\equiv a^{p-1} \pmod p$$


$$x \equiv a^{p-2} \pmod p$$



所以我们可以用快速幂来算出 $a^{p-2} \pmod p$的值，这个数就是它的逆元了


代码也很简单：

```cpp
ll fpm(ll x, ll power, ll mod) {
    x %= mod;
    ll ans = 1;
    for (; power; power >>= 1, (x *= x) %= mod)
    	if(power & 1) (ans *= x) %= mod;
    return ans;
}
int main() {
	ll x = fpm(a, p - 2, p); //x为a在mod p意义下的逆元
}
```

### 线性算法


用于求一连串数字对于一个$\bmod p$的逆元。[洛谷P3811](https://www.luogu.org/problem/show?pid=3811)

只能用这种方法，别的算法都比这些要求一串要慢。


首先我们有一个,$1^{-1}\equiv 1 \pmod p$

然后设 $p=k*i+r,(1<r<i<p)$ 也就是 $k$ 是 $p / i$ 的商，$r$ 是余数 。

再将这个式子放到$\pmod p$意义下就会得到：

$$k*i+r \equiv 0 \pmod p$$

然后乘上$i^{-1}$,$r^{-1}$就可以得到:

$$k*r^{-1}+i^{-1}\equiv 0 \pmod p$$

$$i^{-1}\equiv -k*r^{-1}  \pmod p$$

$$i^{-1}\equiv -\lfloor \frac{p}{i} \rfloor*(p \bmod i)^{-1} \pmod p$$


于是，我们就可以从前面推出当前的逆元了。

代码也很短：

```cpp
inv[1] = 1;
for(int i = 2; i < p; ++ i)
    inv[i] = (p - p / i) * inv[p % i] % p;
```


### 阶乘逆元 $O(n)$ 求

因为有如下一个递推关系。

$\displaystyle inv[i+1]=\frac{1}{(i+1)!}$

$\displaystyle inv[i+1]*(i+1)=\frac{1}{i!}=inv[i]$


所以我们可以求出$n!$的逆元，然后逆推，就可以求出$1...n!$所有的逆元了。


递推式为

$inv[i+1]*(i+1)=inv[i]$

所以我们可以求出 $\displaystyle \forall i, i!,\frac{1}{i!}$ 的取值了。

然后这个也可以导出 $\displaystyle \frac{1}{i} \pmod p$ 的取值，也就是

$$\displaystyle \frac{1}{i!} \times (i - 1)! = \frac{1}{i} \pmod p$$

具体实现可以参考我[这发提交](https://www.luogu.org/record/show?rid=12236223)（卡了常。。）


---

## 作者：Rising_Date (赞：197)

## 逆元：
　　一般用于求 $\frac{a}{b}\ \;mod\; p$ 

## 定义：
　　若  $a*x ≡ 1 \;(mod \;p)$ ，且 $a$ 与 $p$ 互质，那么我们就能定义: $x$ 为 $a$ 的逆元，记为 $a^{-1}$ ，所以我们也可以称 $x$ 为 $a$ 的倒数( $mod \;p$ 意义下)。

　　所以对于 $\frac{a}{b}\ \; mod\;p$ ，我们就可以求出 $b$ 在 $mod\; p$ 意义下的逆元，然后乘上 $a$ ，再 $mod \; p$ ，就是这个乘法逆元的值了。

## 求法：
### First：费马小定理

定理内容：如果 $a,p$ 互质，那么 $a^{p-1} ≡ 1 \;(mod\; p)$

　　结合逆元方程 $a*x ≡ 1 \;(mod\; p)$ ,得到 $a*x ≡ a^{p-1}\;(mod \;p)$
$\;\;\;\;\;\;$根据同余的性质,若 $p$ 为质数,得到 $x ≡ a^{p-2}\; {mod \; p}$
  
$\;\;\;\;\;\;$即 $x = a^{p-2} \;mod\; p$, **快速幂** 求解即可

### Second：欧拉定理

定理内容：如果$a,p$互质，那么$a^φ(p) ≡ 1 \;(mod\; p)$，当 $p$ 为质数时，$φ(p)=p-1$。

　　同理，结合同余方程，得 $x=a^{p-2} \;mod \;p$, **快速幂** 求解即可

 _（这只是两种不同的证明，代码是相同的）_ 
```cpp
//TLE_83分
#include<cstdio> 
#define ll long long
using namespace std;
int n,p;
inline ll ksm(ll a,ll b){
    ll ans=1;
    a%=p;
    while(b){
        if(b&1) ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans%p;
}
void write(ll x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);putchar(x%10^48);
}
int main(){
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;i++)
        write(ksm(i,p-2)),putchar('\n');
    return 0;
}
```
### Third:解不定方程 

　　**解同余方程** $ax≡1 \;(mod \;p)$ 等价于 **解不定方程** $ax+py=1$
　　**Exgcd**求解即可（不会 请左转 [](https://www.cnblogs.com/RisingGods/p/9497928.html) _Exgcd_  ）
　　
  
$\;\;\;\;\;\;$由于 $p$ 是质数，那么$gcd(a,p)=1$;
　　
  
$\;\;\;\;\;\;$即求解不定方程 $ax+by=gcd(a,b)$;
  ```cpp
//AC_1240ms
#include<cstdio>
using namespace std;
int x,y;
void exgcd(int a,int b){
    if(!b){x=1,y=0;return ;}
    exgcd(b,a%b);
    int t=x;
    x=y,y=t-a/b*y;
}
void write(int x){
    if(x>9) write(x/10);
    putchar(x%10^48);
}
int main(){
    int n,p;
    scanf("%d%d",&n,&p);
    for(int i=1;i<=n;++i)
        exgcd(i,p),write((x%p+p)%p),putchar('\n');
    return 0;
}
```
### Forth：线性递推

#### 复杂度 $O(n)$
 
 #### 递推过程：
　　令 $p=ki+r$ ; {$\;k=\big\lfloor\frac pi\big\rfloor$, $r=p\;mod\;i\;$} $(i<p,k<p,r<i)$
　　
  
$\;\;\;\;\;\;$则有 $ki+r≡0\;(mod\; p) $ ①
  
①式左右同乘$i^{-1}*r^{-1}$ 得：
 
　　$k*r^{-1}+i^{-1} ≡ 0 \;(mod \;p)$

移项 得
　　
  
  $\;\;\;\;\;\;$ $i^{-1} ≡ -k*r^{-1} \;(mod\; p)$
　
 
 带入 $\;k=\big\lfloor\frac pi\big\rfloor$ , $r=p\; mod\; i$;
　　
  
  $\;\;\;\;\;\;$ $i^{-1}$ ≡ $\;-\big\lfloor\frac pi\big\rfloor$ $*(p\; mod \;i)^{-1} \;\;(mod\; p)$ ② 
　
 
 由于 $(p\; mod\; i) < i$ ,
 
 $\;\;\;\;\;\;$ 所以,在求出 $i^{-1}$ 之前,我们早已求出 $(p\; mod \;i)^{-1}$；
　　
  
  $\;\;\;\;\;\;$ 因此用数组 $inv[i]$ 记录$i^{-1}$ ( $i$ 的逆元)
　　
  
  $\;\;\;\;\;\;$ 则$inv[i]=-\frac{p}{i}\ * inv[p\;mod\;i]\;mod\;p$ ;

　不要以为到这里就结束了
　　
  
  $\;\;\;\;\;\;$ 因为我们需要保证 $i^{-1}>0$
　
 
 $\;\;\;\;\;\;$ 所以,我们在②式右边$\;+p\; $( $p\;mod\; p=0$, 答案不变)
　　
  
  $\;\;\;\;\;\;$ 即 $inv[i]=p-\frac{p}{i}\ * inv[p\;mod\;i]\;\;mod\;p$;
　　
  
  $\;\;\;\;\;\;$ 当然 $inv[1]=1,inv[0]=tan90$°(赋值为$0$);
　　
  
  $\;\;\;\;\;\;$而且$for$循环 要从$2$开始，防止改变 $inv[1]$ 的值;
　
 
 至此,证毕。
 ```cpp
//AC_664ms
#include<cstdio>
#define ll long long
using namespace std;
const int maxn=3e6+5;
ll inv[maxn]={0,1};
int main(){
    int n,p;
    scanf("%d%d",&n,&p);
    printf("1\n");
    for(int i=2;i<=n;i++)
        inv[i]=(ll)p-(p/i)*inv[p%i]%p,printf("%d\n",inv[i]);
    return 0;
}
```

---

## 作者：一扶苏一 (赞：41)

# 【数论】乘法逆元

## Definition

对于一个数 $x$ 和一个模数 $p$，若存在一个数字 $y$，满足

$$x \times y \equiv 1 \pmod p$$

则称 $y$ 是 $x$ 在模 $p$ 意义下的**逆元**，记做 $x^{-1}~\equiv y \pmod p$。

一个数字逆元在模意义下的运算中可以完全取代该数字的倒数。例如 $\frac{x}{y}~\equiv x \times y^{-1} \pmod p$，其中 $y^{-1}$ 代表 $y$ 的逆元。

## Algorithm

#### Lemma

首先需要指出的是，一个数 $x$ 在模 $p$ 意义下存在逆元，当且仅当 $x$ 与 $p$ 互质。

#### Proof

这里只证明当 $x$ 与 $p$ 不互质时不存在逆元。对于逆元的存在性，由于下面的部分给出了逆元的构造算法，这就已经证明了在互质时逆元是存在的。

反证法，设对于任意的 $x \in Z^+$，存在 $x^{-1} \in Z^+$

$$x \times x^{-1} \equiv 1 \pmod p~~~~~~(1)$$

且

$$\gcd(x,~p) = d \neq 1~~~~~~(2)$$

根据同余的定义，$(1)$ 可以写成：

$$x \times x^{-1} = k \times p + 1~~~~~~(3)$$

其中 $k$ 是一个非负整数。

将 $(3)$ 的等号两侧同时除以 $(2)$ 中的 $d$：

$$\frac{x \times x^{-1}}{d}~=~\frac{k \times p + 1}{d}~~~~~~(4)$$

整理得到

$$\frac{x}{d} \times x^{-1}~=~\frac{p}{d} \times k  + \frac{1}{d}~~~~~~(5)$$

因为 $d = \gcd(x, p)$，所以 $d$ 一定是 $x$ 和 $p$ 的因数。所以

$\frac{x}{d}$ 和 $\frac{p}{d}$ 都是整数，进而 $\frac{p}{d} \times k$ 是整数，$\frac{x}{d} \times x^{-1}$ 是整数。

而因为 $d \neq 1$，所以 $\frac{1}{d}$ 一定不是整数，因此 $\frac{p}{d} \times k + \frac{1}{d}$ 不是整数。

于是等号左侧是整数，等号右侧不是整数，左侧一定不等于右侧，产生矛盾。这就矛盾证明了 $x$ 在模 $p$ 意义下存在逆元仅当 $x$ 与 $p$ 互质。

---

以下介绍求逆元的算法：

#### 求单个数字的逆元

##### Algorithm 1

$$x \times x^{-1}~\equiv 1 \pmod p$$

显然可以转化成方程

$x \times x^-1 = 1 + kp$

令 $y = -k$，移项得到

$$x \times x^{-1} + y \times p = 1$$

注意到这个式子就是扩展欧几里得算法所求的式子

$$ax + by = 1$$

只不过 $x$ 作为一个常数，是欧式式子里的 $a$，同理 $p$ 是欧式式子里的 $b$。使用扩展欧几里得算法求解上面这个式子即可。时间复杂度 $O(\log x)$。

##### Algorithm 2

根据欧拉定理

$x^{\phi(p)} \equiv 1 \pmod p$

其中 $\phi$ 为欧拉函数，$\phi(p)$ 表示小于 $p$ 的正整数中与 $p$ 互质的数的个数。

等式两侧同乘 $x^{-1}$ 可以得到

$$x^{\phi(p) - 1} \equiv x^{-1} \pmod p$$

显然当 $p$ 是一个质数时，$\phi(p) = p - 1$，这时可以 $O(1)$ 算出 $\phi(p) - 1$ 的值，即可用快速幂 $O(\log x)$ 求出 $x$ 的逆元。这个算法好写好记，常数也较小。一般当 $p$ 为 ``int`` 范围内的质数时选择此算法。当 $p$ 不在 ``int`` 范围内时，由于快速幂时需要两个 ``long long`` 相乘，会爆精度。

有关欧拉定理的证明可以看[这里](https://www.cnblogs.com/zylAK/p/9569668.html)

#### 求 $n$ 以内所有正整数模 $p$ 的逆元

显然，由于 $n$ 以内所有正整数都有在模 $p$ 意义下的逆元，所以 $p$ 和 $n$ 以内的所有数互质。

结论：设 $inv_i$ 为 $i$ 的逆元，则有递推式

$$inv_i \equiv -\left\lfloor\frac{p}{i}\right\rfloor \times inv_{p \bmod i} \pmod p$$

边界条件为

$$inv_1 = 1$$

##### Proof

首先 $inv_1 = 1$ 显然成立。

对于 $i > 1$，写出 $p$ 除以 $i$ 的带余除法表达式：

$$p = ki + r$$

其中 $r \in [0, i - 1]$

等式两侧对 $p$ 取余数，有 

$$0 \equiv ki + r \pmod p$$

移项得到

$$r \equiv -ki \pmod p$$

两侧同乘 $i^{-1} \times r^{-1}$，整理得到

$$i^{-1} \equiv -kr^{-1} \pmod p$$

由于 $k = \left\lfloor\frac{p}{i}\right\rfloor$，$r = p \bmod i$，所以原式得证。

又因为 $r < i$，所以在计算 $inv_i$ 时，$inv_r$ 已经被计算完成，所以上述递推可以完成。

证毕。

这样做的时间复杂度显然是 $O(n)$

#### 求 $n!$ 的逆元

因为 $(n!)^{-1} \equiv \frac{1}{n!} \equiv \prod_{i = 1}^n n^{-1}$，所以线性筛出 $n$ 以内所有数字的逆元时，可以顺便求出 $n!$ 的逆元。时间复杂度 $O(n)$

## Code

### Ex_Gcd

```cpp
#include <iostream>

typedef long long int ll;

ll x, p;

void Ex_gcd(const ll a, const ll b, ll &X, ll &Y);

int main() {
  std::cin >> x >> p;
  ll a, b;
  Ex_gcd(x, p, a, b);
  std::cout << (a % p + p) % p << std::endl;
  return 0;
}

void Ex_gcd(const ll a, const ll b, ll &X, ll &Y) {
  if (b == 0) {
    X = 1; Y = 0;
  } else {
    Ex_gcd(b, a % b, Y, X);
    Y -= a / b * X;
  }
}
```

### 欧拉定理

```cpp
#include <iostream>

typedef long long int ll;

ll X, p;

ll mpow(ll x, ll y);

int main() {
  std::cin >> X >> p;
  std::cout << mpow(X, p - 2) << std::endl;
  return 0;
}

ll mpow(ll x, ll y) {
  ll _ret = 1;
  while (y) {
    if (y & 1) (_ret *= x) %= p;
    y >>= 1;
    (x *= x) %= p;
  }
  return _ret;
}
```

### 线性求逆元

这里的 ``factinv`` 即为阶乘逆元。

```cpp
#include <cstdio>

const int maxn = 3000005;

int n, p;
int inv[maxn], factinv[maxn];

int main() {
  scanf("%d%d", &n, &p);
  factinv[1] = inv[1] = 1;
  printf("%d\n", 1);
  for (int i = 2; i <= n; ++i) {
    inv[i] = 1ll * (p - p / i) * inv[p % i] % p;
    printf("%d\n", inv[i]);
    factinv[i] = 1ll * factinv[i - 1] * inv[i] % p;
  }
  return 0;
}
```



---

## 作者：langmouren (赞：2)

# 乘法逆元

本文对乘法逆元的求解进行了粗略介绍。

如果你想要了解更多数论知识，可以访问我的博客[数论学习笔记](https://noiblog.top/archives/1744418701478)。

# 定义

如果 $ax \equiv 1 \pmod b$，则称 $x$ 为 $a \bmod b$ 的逆元，记作 $a^{-1}$。

# 算法介绍

求单个乘法逆元，可以使用**扩展欧几里得算法**。

了解扩展欧几里得算法之前，你需要了解**欧几里得算法**。

如果需要求解多个乘法逆元，则需要使用**线性求逆元**。

## 欧几里得算法

欧几里得算法用于求解两数的最大公约数。

## 扩展欧几里得算法

扩展欧几里得算法（Extended Euclidean algorithm, EXGCD）常用于求出 $ax+by = \gcd(a,b)$ 的一组可行解。

其可以应用于求乘法逆元。

## 质数的线性求逆元

如果需要求解多个数的逆元，那么使用扩展欧几里得算法求解就很慢了，所以衍生出了线性求逆元。

# 正确性证明

## 欧几里得算法

### 算法正确性证明

已知 $a、b$ 两个数，设 $a>b$，根据约数的定义，可以知道，若 $b=0$，则 $\gcd(a,b)=a$。

同时，我们知道 $\gcd(a,b) = \gcd(b, a \bmod b)$，这个等式可以不断缩小 $a、b$。

所以我们可以不断进行 $\gcd(b, a \bmod b)$，直到 $b=0$，此时 $a$ 就是答案。

### 复杂度证明

当求解 $\gcd(a,b)$ 时，会遇到两种情况。

1. $a<b$ 时，$\gcd(a,b)=\gcd(b,a)$，可以化为第二种情况。

2. $a>=b$ 时，一定有 $a \bmod b <= \dfrac{a}{2}$，即每次取模后，$a$ 的大小不超过原来的 $\dfrac{1}{2}$。

所以，欧几里得算法的复杂度为 $O(\log (\max(a,b)))$。

## 扩展欧几里得算法

### 为什么能求解乘法逆元

对于 $ax \equiv b \pmod n$，其可以化为 $ax+nk=b$，其中 $x$ 和 $k$ 均为未知数。

也就是说，当 $b=\gcd(a,n)$ 时，扩展欧几里得算法就可以用来求解乘法逆元了。

求解乘法逆元时 $b=1$，所以转证 $a,n$ 互质，在本题中，模数 $n$ 保证是质数，所以一定有两数互质，扩展欧几里得算法一定可以求解。

### 算法正确性证明

根据欧几里得算法可知：$\gcd(a,b) = \gcd (b,a \bmod b)$。

我们设 $ax_1+by_1 = \gcd(a,b)$，$bx_2+ (a \bmod b)y_2 = \gcd(b,a \bmod b)$。

所以 $ax_1+by_1 = bx_2+(a \bmod b)y_2$。

又因为 $a \bmod b = a - \lfloor \dfrac{a}{b} \rfloor \times b$。（自己手模即可发现）

所以

$$
\begin{aligned}
ax_1+by_1   &= bx_2+(a - \lfloor \dfrac{a}{b} \rfloor \times b)y_2 \\
&=bx_2+ay_2 - \lfloor \dfrac{a}{b} \rfloor \times by_2 \\
&=ay_2 + b(x_2 -  \lfloor \dfrac{a}{b} \rfloor \times y_2)
\end{aligned}
$$

同项的数一定相等，有 $x_1=y_2,y_1=x_2 -  \lfloor \dfrac{a}{b} \rfloor \times y_2$。

我们可以借用欧几里得算法不断递归，直到 $b=0$，此时设置 $x=1,y=0$，回溯后按照上述等式不停计算。

### 复杂度证明

扩展欧几里得算法在欧几里得算法上进行了拓展，其本质是欧几里得算法的一种应用，复杂度和欧几里得算法相同。

## 质数的线性求逆元

### 算法正确性证明

很明显，不论模数 $p$ 是多少，$1$ 的逆元都是  $1$。

对于 $i^{-1}$，我们设 $k = \lfloor \dfrac{p}{i} \rfloor$，$j = p \bmod i$，则有 $p=ki+j$，将其换为模意义下的等式，则有 $ki+j \equiv 0 \pmod p$。

在等式两边同时乘 $i^{-1} \times j^{-1}$，则有 $kj^{-1} + i^{-1} \equiv 0 \pmod p$，可化为 $i^{-1} \equiv -kj^{-1} \pmod p$。

再代入 $k$ 和 $j$，则有 $i^{-1} \equiv -\lfloor \dfrac{p}{i} \rfloor \times (p \bmod i)^{-1} \pmod p$。

因为对于任意 $p$ 和 $i$，一定有 $p \bmod i < i$，所以乘法逆元 $i^{-1}$ 一定可以通过一个比 $i$ 小的数的乘法逆元得到，那么我们可以进行线性的求解，从小到大求出乘法逆元。

### 复杂度证明

明显为 $O(n)$。

# 代码实现

## 欧几里得算法

```cpp
int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}
```

## 扩展欧几里得算法

```cpp
void exgcd(int a,int b){
    if(b==0){
        x=1,y=0;
        return;
    }
    exgcd(b,a%b);
    int tmp=x;
    x=y;
    y=tmp-a/b*y;
}
```

## 质数的线性求逆元

```cpp
s[1]=1;
for(int i=2;i<=n;i++){
		s[i]=(p-p/i)*s[p%i]%p;
}
```

---

## 作者：wurang (赞：0)

## 前置知识

### 什么是逆元

当我们计算 $a - b$ 时，可以将其视为 $a + (-b)$；当我们计算 $\frac{a}{b}$ 时，可以将其视为 $a \times \frac{1}{b}$，也就是乘以其倒数。逆元可以理解为在**同余**情况下的倒数。

在数论中，如果一个线性同余方程 $ax \equiv 1 \pmod p$，则称 $x$ 为 $a \bmod p$ 意义下的逆元，记作 $a^{-1}$ 或 $\text{inv}(a)$。在模 $p$ 的意义下，除去一个数，等于乘以这个数的逆元，即 $\frac{a}{b} \equiv a \times \text{inv}(b) \pmod{p}$。

需要注意，逆元仅在所求数与模数互质，乘法逆元有两个性质：

- 在特定模数下唯一，不存在多解。
- 乘法逆元是完全积性函数，也就是说 $\text{inv}(a) \times \text{inv}(b) = \text{inv}(a \times b)$。

### 逆元的作用

逆元有什么用呢？我们常常遇到一些题目要求结果对一个大质数 **$p$** 取模，这是因为答案很大。**加减法**和**乘法**对取模运算都是**封闭**的，但是当我们遇到除法的时候，步步取模就行不通了，如果套用加减乘的步步取模公式，算出来的答案和一次取模的答案不一样。为什么除法是错的呢，证明也很简单，设：

$$
a = k_0p + a', b = k_1p + b', k_0, k_1 \in \mathbb{Z}
$$

可得

$$
\frac{a \bmod p}{b \bmod p} = \frac{a'}{b'} = \frac{a - k_0p}{b - k_1p} \neq \frac{a}{b}
$$

这时逆元就可以派上用场了。

## 算法介绍

由于这题需要求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。我们可以使用线性递推法。

设 $p = q \times a + r$，即 $q = \lfloor \frac{p}{a} \rfloor, r = p \bmod a$。

在模 $p$ 意义下，有 $aq + r \equiv 0 \pmod p$

移项整理得 $a \equiv -r \times \text{inv}(q) \pmod p$。

则 $\text{inv}(a) \equiv -q \times \text{inv}(r) \pmod p$。

代入式子，得到 $\text{inv}(a) \equiv -\lfloor \frac{p}{a} \rfloor \times \text{inv}(p \bmod a) \pmod p$。

观察上面的式子可以发现一个数的逆元可以由比它小的数的逆元递推而来，因此我们可以用递推或者递归求解，时间复杂度为 $O(N)$。

## 正确性与复杂度证明

显然。

## 代码实现

利用推出来的式子 $\text{inv}(a) \equiv -\lfloor \frac{p}{a} \rfloor \times \text{inv}(p \bmod a) \pmod p$ 写出递推公式， 注意 $-\lfloor \frac{p}{a} \rfloor$ 要转换成正数。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long mod;
long long n;
long long inv[10000005];

int main()
{
    cin >> n >> mod;
    inv[1] = 1;
    cout << 1 << "\n";
    for(int i = 2; i <= n; i++)
    {
        inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        cout << inv[i] << "\n";
    }
    return 0;
}
```

---

## 作者：liyelei (赞：0)

### （一）[题目传送门](https://www.luogu.com.cn/problem/P3811)

### （二）乘法逆元定义

如果 $ax \equiv 1 \pmod{p}$，且 $a$，$p$ 互质，就称 $x$ 为 $a$ 在模 $p$ 意义下的**乘法逆元**，写作 $a^{-1}$。

### （三）费马小定理解法

> 若 $p$ 是质数，则对于任意的 $a$，有 $a^p \equiv a \pmod{p}$。

更多在 [OI wiki](https://oi-wiki.org/) 相关界面查询。

它等价于 $a^{p-1} \equiv 1 \pmod{p}$，将此式两边同乘 $a$ 可得上式。

再结合逆元，可以得出这么一个式子：  
$$
a^{p-1} \equiv aa^{-1} \equiv 1 \pmod{p}
$$
又因为 $a^{p-1} = aa^{p-2}$，带入原式，得：
$$
aa^{p-2} \equiv aa^{-1} \equiv 1 \pmod{p}
$$

约掉 $a$，得：
$$
a^{-1} \equiv a^{p-2} \pmod{p}
$$

#### 注：只有 $p$ 为质数时，上述式子成立。

还需注意：这里使用快速幂，要是使用 ``pow`` 函数， TLE 到让你怀疑人生。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long

ll Pow(ll a, ll b, ll n) {  //快速幂
	ll ret = 1;
	while (b) {
		if (b % 2 == 1) ret = ret * a % n;
		a = a * a % n;
		b = b / 2;
	}
	return ret;
}

int main() {
	ll n, p;
    scanf("%lld %lld", &n, &p);
	for (ll i = 1; i <= n; i++) {
		ll t = Pow(i, p - 2, p);
		printf("%lld\n", (t % p + p) % p);
	}
  return 0;
}
```

时间复杂度： $O(n \log n)$。  
不卡常会喜提 TLE。~~蒟蒻不会~~

### （四）线性求法（递推）

先假设已经求出 $1 \sim i-1$ 的乘法逆元，设 
$$
p= \lfloor \frac{p}{i} \rfloor ×i+r$$
那么有 
$$
\lfloor \frac{p}{i} \rfloor ×i+r \equiv 0 \pmod{p}
$$
两边同时乘上 $i^{-1}r^{-1}$，得: 
$$
\lfloor \frac{p}{i} \rfloor ×r^{-1}+i^{-1} \equiv 0 \pmod{p}
$$
两边同时减去 $r^{-1}× \lfloor \frac{p}{i} \rfloor$，得：
$$
i^{-1} \equiv -r^{-1}× \lfloor \frac{p}{i} \rfloor \pmod{p}
$$

这即为 $i^{-1}$ 的求法。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
long long inv[3000001];

int main() {
	ll n, p;
	scanf("%lld %lld", &n, &p);
	inv[1] = 1;
	printf("%lld\n", inv[1]);
	for (ll i = 2; i <= n; i++) {
		inv[i] = ((p - p / i * inv[p % i]) % p + p) % p;  //求逆元
		printf("%lld\n", inv[i]);
	}
}
```

时间复杂度： $O(n)$。  
500ms 可以过。

---

## 作者：fanjiayu666 (赞：0)

#### 更新历史

>2025.5.6 题解过审
>
>2025.5.7 更改费马小定理和逆元方程合并时出现的歧义句。感谢 @[liyelei](/user/1385862) 的指出。
### 1.术语定义

- 模意义下：指任何数都转变为了模上一个数后的状态。模 $x$ 意义下就是指任何数都转变为了 $\pmod x$ 后的状态，如在模 $4$ 的意义下数列 ${0,1,2,3,4,5,6,7,8,9}$，就会变成 ${0,1,2,3,0,1,2,3,0,1,2,3}$。
- 乘法逆元，一般就用于求 $\frac {a}{b}$ 在模 $p$ 意义下的值，若 $ax\equiv1\pmod p$ 且 $\gcd(a,p)=1$ 就称 $x$ 是 $a$ 在模 $p$ 意义下的乘法逆元，一般我们将 $a$ 在 $\mod p$ 意义下的乘法逆元写作  $a^{-1}\pmod p$，你也可以理解为 $x$ 是 $a$ 在模 $p$ 意义下的倒数。

### 2.回归正题

>
>所以说来说去到底怎么求乘法逆元呢？

以下是求乘法逆元的常见方法：

#### （1）~~最简单~~的，费马小定理。
首先回顾一下费马小定理的内容：

>若 $p$ 是质数，则对于任意的 $a$，有 $a^p \equiv a\pmod p$。（摘自蓝书）

不过有些人是这么写的 $a^{p-1}\equiv 1 \pmod p$。

其实他的本质是一样的：根据余数可乘性，第二个式子的两边同时乘上 $a$，则变为 $a^{p-1}\times a\equiv a\times1\pmod p$，简化得 $a^p\equiv a\pmod p$。

结合逆元方程（就是术语解释中的那段方程），因为逆元方程和费马小定理的第二种表达形式中都同余于 $1$，将他们合并，变成 $a^{p-1}\equiv ax \equiv1 \pmod  p$。再将 $x$ 转变为 $a^{-1}$ 后得 $a^{p-1}\equiv a^{-1} \equiv 1\pmod p$，由于 $a^{-1}\equiv 1$，所以可以合并前两项得 $a^{p-2} \equiv 1\pmod p$。

所以用快速幂解就可以:
```cpp
//TLE 64pts 稍微卡卡常才能过
#include<bits/stdc++.h>
using namespace std;
long long n,p,x,y;
long long qmi(long long a,long long b,long long n){
	long long t=1;
    while(b){
        if(b&1) t=t*a%n;
        a=a*a%n;
        b>>=1;
    }
    return t;
}
int main(){
	cin>>n>>p;
	for(int i=1;i<=n;i++){
	    cout<<qmi(i,p-2,p)<<"\n";
	}
	return 0;
}
```
#### （2）有点难但不多的 $\varphi$ 函数——欧拉定理

其实就是欧拉函数……

我们再来看一下欧拉定理的内容：
>若正整数 $a,n$ 互质，则 $a^{\varphi(n)}\equiv 1\pmod p$，其中 $\varphi(n)$ 为欧拉函数。（摘自蓝书）

其实和上面的是一样的，因为对于 $n$ 是质数的情况，$\varphi(n)=n-1$ 结合乘法逆元方程后就变成了刚才的式子。所以代码是一样的，只是推导方式有不同。

#### （3）exgcd
首先我们来看一个 Bézout 定理：

>对于任意的整数 $a,b$，有一对整数 $x,y$，满足 $ax+by=\gcd(a,b)$。（摘自蓝书）

证明就不抄了，有点复杂。

代码就比正常 gcd 多了一行和一句：
```cpp
int exgcd(int a, int b,int &x,int &y) {
    if (b == 0){x=1,y=0;return abs(a); }
    int d=gcd(b, a % b,x,y);
    int z=x;x=y;y=z-y*(a/b);
}
```
如何用它求解同余方程呢？
其实求 $ax \equiv1 \pmod p$ 等价于求 $ax+py=1$，直接用 exgcd 求解就可以了。复杂度大约为 $O(n \log n)$，还是要卡常。

#### （4）线性递推

设此时的模数为 $p$，对于每个 $i$ 可以将 $p$ 表示为 $ki+r$。
显然
$$ki+r\equiv0\pmod p$$
两项同时乘以 $i^{-1}\times r^{-1}$ 可得
$$ki\times i^{-1}\times r^{-1}+r\times i^{-1}\times r^{-1}\equiv 0\pmod p$$
化简得：
$$kr^{-1}+i^{-1}\equiv0\pmod p$$
移项可得
$$i^{-1}\equiv -k*r^{-1}\pmod p$$
也就是
$$i^{-1}\equiv -\lfloor \frac{p}{i}\rfloor*(p\mod i)^{-1}\pmod p$$

这就是递推公式，由于 $(p\mod i)^{-1}$ 一定算过（原因见下），所以直接用 $inv[p\%i]$ 即可。 

（证明参考[这篇博客](https://www.cnblogs.com/qixingzhi/p/9332813.html)）

- 为什么 $(p\mod i)^{-1}$ 一定算过？

  因为 $p$ 模 $i$ 后结果一定小于 $i$，而 $i$ 一下的都算过了。


按递推公式写就可以了，代码：
```cpp
//AC 217ms
#include<bits/stdc++.h>
using namespace std;
long long n,p,x,y;
long long inv[3000010];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
	cin>>n>>p;
	inv[1]=1;
	cout<<"1\n";//以防在 i=1 的时候爆炸，直接输 1。
	for(int i=2;i<=n;i++){
	    inv[i]=((p-p/i)*inv[p%i]%p);//防止负数，也可以写成 inv[i]=((-(p/i)*inv[p%i])%p+p)%p，一样的效果。
	    cout<<inv[i]<<"\n";
	}
	return 0;
}
```
### 3.The End
至此本题解结束，如果有证明部分的错误，敬请指出，感激不尽。

---


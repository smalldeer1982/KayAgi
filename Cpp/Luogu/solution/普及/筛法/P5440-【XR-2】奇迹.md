# 【XR-2】奇迹

## 题目背景

> 相信奇迹的人，本身就和奇迹一样了不起。——笛亚 《星游记》

## 题目描述

我们称一个**日期**为一个八位数，第 $1\sim 4$ 位构成年，第 $5\sim 6$ 位构成月，第 $7\sim 8$ 位构成日，不足位数用 $0$ 补足。同时，要求日期所代表的这一天真实存在，且年的范围为 $1\sim 9999$。

出现奇迹的日期都存在相同的特点：由“日”组成的两位数，由“月+日”组成的四位数，由“年+月+日”组成的八位数均为**质数**。但并不是所有存在这样特点的日期都一定会出现奇迹。

现在，你得到了一个可能会出现奇迹的日期，然而不幸的是这个日期却是残缺的，八位中可能有若干位无法确定。你需要知道这个日期有多少种可能，这样你才能做好充足的准备去迎接奇迹的到来。

## 说明/提示

【样例 $1$ 说明】

`53-7-3-7` 的 $6$ 种可能的日期如下：

```plain
53070307
53070317
53170307
53370307
53570317
53770307
```

【数据规模与约定】

一共 $10$ 个测试点，记 $c$ 为八位字符串中 `-` 的个数。

对前 $9$ 个测试点，在第 $i$ 个测试点中保证 $c = i - 1$。

对 $100\%$ 的数据保证 $1 \le T \le 10$。

## 样例 #1

### 输入

```
2
53-7-3-7
20190629
```

### 输出

```
6
0
```

# 题解

## 作者：xht (赞：140)

#### 题目大意

> 求满足“日”组成的两位数，“月+日”组成的四位数，“年+月+日”组成的八位数均为质数的日期的个数。

#### 前置知识

- ~~乱搞~~搜索
- 质数

#### 题解

略...

只要保证正确性且不会超时得太过分都能 AC

~~别问我部分分有啥用，我也不知道~~

两个易错点：

1. $29$ 为质数，$229$ 也为质数，因此要正确判断闰年。值得一提的是，$3200,6400,9600$ 年是否为闰年存在争议，但并不影响本题，因为 $32000229,64000229,96000229$ 均不是质数。
2. $1$ 不是质数，因此“日”不能为 $1$。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p[] = {0,3,5,7,11,13,17,19,23,29,31,37};
const int d[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
int T, a[66], t, ans[66666], tot;
char s[10];

inline bool is_prime(int x) {
    for (int i = 2; i * i <= x; i++)
        if (x % i == 0) return 0;
    return 1;
}

int main() {
    ios::sync_with_stdio(0);
    for (int i = 1; i <= 12; i++)
        for (int j = 1; p[j] <= d[i]; j++)
            if (is_prime(i * 100 + p[j]))
                a[++t] = i * 100 + p[j];
    for (int i = 4; i <= 9999; i += 4)
    	if ((i % 100 || !(i % 400)) && is_prime(i * 10000 + 229))
    		ans[++tot] = i * 10000 + 229;
    for (int i = 1; i <= 9999; i++)
        for (int j = 1; j <= t; j++)
            if (is_prime(i * 10000 + a[j]))
                ans[++tot] = i * 10000 + a[j];
    cin >> T;
    while (T--) {
        cin >> (s + 1);
        int cnt = 0;
        for (int i = 1; i <= tot; i++) {
            int now = ans[i], flag = 1;
            for (int j = 8; flag && j; j--, now /= 10)
                if (s[j] != '-' && s[j] - '0' != now % 10)
                    flag = 0;
            cnt += flag;
        }
        cout << cnt << endl;
    } 
    return 0;
}
```

---

## 作者：⚡LZSY01_XZY⚡ (赞：63)

看了一下题解区，好像没有人和我写的一样。我的主要思路是确定枚举上下界，提高枚举效率。另外，改变枚举顺序也是提高效率的好方法。

# 讲讲我的做法
题目中说输入一个长度为$8$的字符串，字符串中有字符为$-$，我们可以假设这一位上下界为$0$~$9$，~~然后我们打一个八重循环就好了。~~，预处理满足条件的日和月组成的四位数。这个预处理我们只需打一个线性筛，筛选$0$~$9999$的素数，就好了。$\tiny\texttt{不会线性筛，普通筛也是可以的。}$然后枚举预处理的日月组成的四位数，并判断是否符合当前字符串。然后，枚举年份，通过筛选出的素数判断日月年组成的八位数是否是素数。  

另外，当出现$--------$时，可以特判，速度会提高很多。  
我的记录：
- [$\small\color{#ff4081}\texttt{加特判}$](https://www.luogu.org/recordnew/show/20146339)$637ms$
- [$\small\color{#ff4081}\texttt{未加特判}$](https://www.luogu.org/recordnew/show/20146213)$3405ms$

## $code:$
```cpp
#include <cstdio>
#include <bitset>
#include <iostream>
#define year (a*1000+b*100+c*10+d)
using namespace std;

int read()
{
    int x=0,f=1;char c=getchar();
    while (c<'0' || c>'9'){if (c=='-')f=-1;c=getchar();}
    while (c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-48;c=getchar();}
    return x*f;
}

const int MAXN=10005;
const int sum[]={0,229,103,107,113,131,211,223,307,311,313,317,331,419,503,523,607,613,617,619,719,811,823,829,907,911,919,929,1013,1019,1031,1103,1117,1123,1129,1213,1217,1223,1229,1231};
													//我把满足条件的日月打了表，这打表代码特简单就不给出了
string s;
int len,ans;
int prim[MAXN],tot;
int l[10],r[10];
bitset<MAXN> v;

inline void prime()									//线性筛
{
    v[1]=true;
    for (int i=2;i<=MAXN;i++)
    {
        if (!v[i]) prim[++tot]=i;
        for (int j=1;j<=tot;j++)
        {
            if (i*prim[j]>=MAXN) break;
            v[i*prim[j]]=true;
            if (i%prim[j]==0) break;
        }
    }
}

inline bool ok(int x)								//判断是否满足当前字符串
{
    int w=8;
    while (x>0)
    {
        if (l[w]>(x%10)||r[w]<(x%10)) return false;
        w--;x/=10;
    }
    if (w>=5)
        for (int i=5;i<=w;i++) if (l[i]!=0) return false;
    return true;
}

inline bool is_(int n)
{
    for (int i=1;i<=tot;i++)
        if (n%prim[i]==0) return false;
    return true;
}

int main()
{
    prime();
    int cas,i,a,b,c,d;cas=read();
    while (cas--)
    {
        cin>>s;ans=0;bool flag=true;
        for (i=0;i<8;i++)
        {
            if (s[i]!='-') l[i+1]=r[i+1]=s[i]-48,flag=false;
            else l[i+1]=0,r[i+1]=9;
        }
        if (flag) printf("%d\n",55157);
        else 
        {
            for (i=1;i<=39;i++)
                if (ok(sum[i]))
                    for (a=l[1];a<=r[1];a++)
                        for (b=l[2];b<=r[2];b++)
                            for (c=l[3];c<=r[3];c++)
                                for (d=l[4];d<=r[4];d++)
                                {
                                    if (i==1)
                                    {
                                        if ((year%4==0)&&((year%100!=0)||(year%400==0)));//闰年特判
                                        else continue;	
                                    }
                                    if (year!=0&&is_(year*10000+sum[i])) ans++;
                                }
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

$Please~give~a~like.$

---

## 作者：Ciyang (赞：32)

#### 这又是一道新出的搜索好题。

打一波广告：[我的博客](https://xciyang.github.io/)

### 分析

正解搜索或暴力枚举，代码区已经几乎是相同的思路，只是有些大佬有很多优化，效率快，但是特批有很多并且极其复杂。经对比我觉得我的代码可视性还是不错的，并且没有乱七八糟的特判，可以说是常规DFS代码+筛质数优化的代码。

下面说一下思路。首先题目很好理解，一个有效日期，日、月+日、年+月+日组成的数字均为质数，那就先不考虑优化，直接上模拟。

按DFS的常规模板（自己总结出来的），先有一个参数，代表搜索到哪一位。在本题中就是日期的第几位数字，我选择的顺序为：日->月->年，这样可以逐层判断，而且效率较高代码优雅。

第二个参数，是为了方便和小幅提升效率，我们把已经枚举完的位编成一个整数$ x $，然后日就是 x % 100 ，月就是 x % 10000 /  100 ，年就是x / 10000
。

这道题中还需要考虑到特殊情况，是否必须为闰年或大月。我为了方便，当成两个参数来传递，现在想想好像可以改一个。因为一个只考虑年份，一个只考虑月份。DFS带详细注释代码如下，自己觉得算得上优雅。
```cpp
// 调用方法: dfs(8, 0, 0, 0)
int dfs(int nown, int num, int rn, int jy) {
	if(nown == 0) {
    // 日期全部枚举完
		if(num / 10000 == 0) return 0;
    // 非常关键，0不能当年份（我一开始没加就得10分）
		if(rn && pdrn(num / 10000) == 0) return 0;
    // 如果必须为闰年就判断年份
		return pdzs(num);
    // 总日期还得为质数
	}
	if(nown == 6) {
    // 枚举完日
		if(num == 0 || num > 31 || !pdzs(num)) return 0;
    // 如果是等于0日、31日以上或不是质数就return
		if(num == 31) jy= 1;
    // 如果是31日就必须为大月
	}
	if(nown == 4) {
    // 判断完日、月
		if(num < 32 || num > 1231 || !pdzs(num)) return 0;
    // 如果是等于0月、13月以上或不是质数就return
		if(jy && !yue[num / 100]) return 0;
    // 如果必须为大月就判断月份num / 100，yue数组代表是否为大月
		if(num / 100 == 2) {
			if(num % 100 > 29) return 0;
        // 2月最多29天
			if(num % 100 == 29) rn= 1;
        // 如果是2月29日就必须为闰年
		}
	}
	if(a[nown] != -1) return dfs(nown - 1, a[nown] * p10[8 - nown] + num, rn, jy);
    // 如果输入给出就直接进入下一层，p10数组相当于pow10
	int res= 0;
	for(int i= 0; i <= 9; i++) res+= dfs(nown - 1, i * p10[8 - nown] + num, rn, jy);
    // 枚举0~9为此位
	return res;
}
```

如果是用复杂度为$ O(\sqrt{n}) $ 的判断质数就只有90分，所以还得用线性筛预处理出$  \sqrt{100000000} = 10000 $ 以内的质数，然后我们判断质数就对这些数取模就行了，具体原理不再解释。

```cpp
// 筛10005以内的质数
inline void init() {
	flag[1]= 1;
	for(int i= 2; i < 10005; i++) {
		if(!flag[i]) prim[++tot]= i;
		for(int j= 1; j <= tot; j++) {
			if(i * prim[j] >= 10005) break;
			flag[i * prim[j]]= 1;
			if(i % prim[j] == 0) break;
		}
	}
	return;
}
// 判断质数
inline int pdzs(int x) {
	if(x < 2) return 0;
	for(int i= 1; i <= tot; i++)
		if(x % prim[i] == 0) return x == prim[i];
	return 1;
}
```

然后就可以愉快的AC了，总代码只有70行且简单优雅。

### 代码

```cpp
#include <iostream>
#include <stdio.h>
#include <math.h>
using namespace std;
int n, a[9], prim[10005], flag[10005], tot;
char tmpc;
int p10[]= {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000};
int yue[]= {0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1};
inline void init() {
	flag[1]= 1;
	for(int i= 2; i < 10005; i++) {
		if(!flag[i]) prim[++tot]= i;
		for(int j= 1; j <= tot; j++) {
			if(i * prim[j] >= 10005) break;
			flag[i * prim[j]]= 1;
			if(i % prim[j] == 0) break;
		}
	}
	return;
}
inline int pdrn(int x) {
	return (x % 4 == 0 && x % 100 != 0) || (x % 400 == 0 && x % 3200 != 0);
}
inline int pdzs(int x) {
	if(x < 2) return 0;
	for(int i= 1; i <= tot; i++)
		if(x % prim[i] == 0) return x == prim[i];
	return 1;
}
int dfs(int nown, int num, int rn, int jy) {
	if(nown == 0) {
		if(num / 10000 == 0) return 0;
		if(rn && pdrn(num / 10000) == 0) return 0;
		return pdzs(num);
	}
	if(nown == 6) {
		if(num == 0 || num > 31 || !pdzs(num)) return 0;
		if(num == 31) jy= 1;
	}
	if(nown == 4) {
		if(num < 32 || num > 1231 || !pdzs(num)) return 0;
		if(jy && !yue[num / 100]) return 0;
		if(num / 100 == 2) {
			if(num % 100 > 29) return 0;
			if(num % 100 == 29) rn= 1;
		}
	}
	if(a[nown] != -1) return dfs(nown - 1, a[nown] * p10[8 - nown] + num, rn, jy);
	int res= 0;
	for(int i= 0; i <= 9; i++) res+= dfs(nown - 1, i * p10[8 - nown] + num, rn, jy);
	return res;
}
char get() {
	char ch= getchar();
	while((ch < '0' || ch > '9') && ch != '-') ch= getchar();
	return ch;
}
void put(int x) {
	if(x > 9) put(x / 10);
	putchar('0' + x % 10);
	return;
}
int main() {
	init(), cin >> n;
	while(n--) {
		for(int i= 1; i <= 8; i++) tmpc= get(), a[i]= (tmpc == '-' ? -1 : tmpc - '0');
		put(dfs(8, 0, 0, 0)), putchar('\n');
	}
	return 0;
}
```

---

## 作者：寒冰大大 (赞：13)

这道题if写的太多，考察也比较多

首先这道题常数比较大，其次有争议的年份(3200，6400,9600）也没毒瘤


这个题比赛交的有TLE，然后优化了几个地方，TLE→AC

因为本人交的是爆搜，其实这道题完全可以打表打出存在的月份，然后直接这样，就好了，本人比赛比较懒，打了个素数表

因为这个素数表，常数优化（1万→1229）因此过了第九个点

可能你们认为打表不好，其实打一部分与题目有关的表后，对问题解决就简单多了

另外还有个优化，先判断这日是不是质数，然后月+日……看似微不足道然后本人过了低8和10个点

另外本人用的是dfs，这样按位来计算比较方便

还有就是有关日期存在的极为复杂的判断，我在dfs里面说一下吧

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<vector>
#include<string>
#include<queue>

using namespace std;

int n,m,ans;
int d,y,wei[20];
int looker[]={0,9,9,9,9,1,9,3,9};
int chose[20]; 
int zd[20];
int my[]={0,1,0,1,0,1,0,1,1,0,1,0,1};
int ssb[12300]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973,10007};  //打表部分
string s;


inline int is_prime(int x)
{
    int i;
    if(x==2) return 1;
    if(x==1) return 0;
    for(i=1;ssb[i]*ssb[i]<=x;i++)
    {
        if(x%ssb[i]==0) return 0;
    }
    return 1;
}

inline int rn(int ye)  //判断是不是闰年
{
    if(ye%3200==0) return 0;
    if(ye%400==0) return 1;
    if(ye%100==0) return 0;
    if(ye%4==0) return 1;
    return 0;
}
void dfs(int dep,int nowmath)
{
    if(dep==9) 
    {
        if(is_prime(chose[7]*10+chose[8]))//先判断日
        {
            if(is_prime(chose[5]*1000+chose[6]*100+chose[7]*10+chose[8]))//月
            if(is_prime(nowmath))
            {
            ans++;	
            //printf("%d\n",nowmath);
            //年，printf的目的是查错
            return ;		
            }
        }
        return ;
    }
    int i;
    for(i=wei[dep];i<=zd[dep];i++)
    {
        if(dep>4) if(chose[1]*1000+chose[2]*100+chose[3]*10+chose[4]==0) return ; //如果没有年的存在（0年）
        if(dep==6&&chose[5]==1) if(i>2) return ;  //13月？ 
        if(dep==8)  //如果月或者日不存在
        {
        if(chose[5]==0&&chose[6]==0) return ;
        if(chose[7]==0&&i==0) continue;
        if(dep==8&&chose[7]==3) if(i>2) return ;
        if(dep==8&&chose[7]>=2) 
        {
        if(rn(chose[1]*1000+chose[2]*100+chose[3]*10+chose[4])) //闰年 2月不存在30+日
        if(chose[5]==0&&chose[6]==2)
        if(chose[7]==3) continue;	
        } 
        if(!rn(chose[1]*1000+chose[2]*100+chose[3]*10+chose[4]))//平年 2月不存在 29日
        if(chose[5]==0&&chose[6]==2)
        if((chose[7]==2&&i>8) )return ;
        if(chose[7]==3&&my[chose[5]*10+chose[6]]<i&&dep==8&&chose[5]*10+chose[6]!=2) continue;
        }
        if(i>looker[dep]) return ;
        chose[dep]=i;
        dfs(dep+1,nowmath*10+i);  //每一位能到达的最大数字
        chose[dep]=0;
    }
    
    return ;
}

int main()
{
    int i,j;
    scanf("%d",&n);
    //53-7-3-7
    for(j=1;j<=n;j++)
    {
    ans=0;
    scanf("\n");
    for(i=1;i<=8;i++)
    {
        char t;
        scanf("%c",&t); //按字符读，一定要先读了上一行的回车符，不然会出现错位
        if(t=='-') wei[i]=0,zd[i]=9;  //如果这一位是‘-’那么我们枚举所有的可能存在的日期
        else wei[i]=zd[i]=int(t-'0');
    }
    m=8;
    dfs(1,0);	
    printf("%d\n",ans);
    }
    
}
```


---

## 作者：StudyingFather (赞：6)

搜索题好毒瘤啊QAQ

我们从日期第一位开始扫描，没有数字的位置枚举该填的数字填上。

填完所有数字后，先判断日期是否合法，再判断该日期是否满足题意要求即可。

这里为了方便，先使用线性筛在 $ O(n) $ 的时间内筛出了所有的质数。从而可以在 $ O(1) $ 的时间内判断任意一个数字是否是质数。

当然，在搜索中途就排除无效日期可以加快搜索效率。

~~比赛时候代码有些丑，不要介意~~

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int daynum[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int f[100000005],res[6000005],cnt,date[15],num,ans;
char s[15];
inline bool is_run(int y)
{
 if(y%4==0)
 {
  if(y%100==0)
  {
   if(y%400==0)return true;
   return false;
  }
  return true;
 }
 return false;
}
inline bool legal(int y,int m,int d)
{
 if(m>12||m==0||d==0||y==0)return false;
 if(m==2)
 {
  if(is_run(y))
  {
   if(d>29)return false;
   return true;
  }
  else
  {
   if(d>28)return false;
   return true;
  }
 }
 else
 {
  if(d>daynum[m])return false;
  return true;
 }
}
void dfs(int d)
{
 if(d==8)
 {
  int y=num/10000,m=(num%10000)/100,d=num%100;
  if(legal(y,m,d))
   if((!f[d])&&(!f[m*100+d])&&(!f[y*10000+m*100+d]))ans++;
  return;
 }
 if(date[d]!=-1)
 {
  num=num*10+date[d];
  dfs(d+1);
  num/=10;
  return;
 }
 for(int i=0;i<=9;i++)
 {
  if(d==4&&i==2)break;
  if(d==5&&i==0&&date[d-1]==0)continue;
  if(d==5&&date[4]*10+i>12)break;
  if(d==6&&i==4)break;
  date[d]=i;
  num=num*10+i;
  dfs(d+1);
  date[d]=-1;
  num/=10;
 }
}
int main()
{
 int t;
 scanf("%d",&t);
 f[0]=f[1]=1;
 for(long long i=2;i<=99991231;i++)
 {
  if(!f[i])res[++cnt]=i;
  for(long long j=1;j<=cnt&&i*res[j]<=99991231;j++)
  {
   f[i*res[j]]=1;
   if(i%res[j]==0)break;
  }
 }
 while(t--)
 {
  ans=0;
  scanf("%s",s);
  for(int i=0;i<8;i++)
  {
   if(s[i]=='-')date[i]=-1;
   else date[i]=s[i]-'0';
  }
  dfs(0);
  printf("%d\n",ans);
 }
 return 0;
}
```


---

## 作者：LB_tq (赞：5)


# 质数判断+枚举
这道题卡了我很长时间。。
#### 大体思路：1.根据输入的字符串确定枚举的左右端点
#### 	 2.月数不超过12，日数不超过31（具体月份具体判断）
####          3.在可能范围内枚举判断（具体解释在代码）
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
string a;
ll m,n,p[10010],v[100010],s[10010];//p存储10000以内的质数，s[i]表示i是否为质数，v[i]是线性筛中存储i的最小质因子
const ll b[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};//b[i]存储第i个月的天数
bool check(ll x){
    if(x/10000<1)
        return false;//要有年
    ll z=x/10000;
    x%=10000;
    ll y=x%100;
    x/=100;
    if(x==0||x>12)
        return false;//月份
    if(y==0||y>b[x])
        return false;//日
    if(z%4!=0||(z%100==0&&z%400!=0))
        if(x==2&&y>28)
            return false;//特判平年2月只有28天
    return true;
}//判断日期格式是否正确
bool check1(ll x){
    ll q=x,i=7;//i为字符串下标
    while(q>0){
        if(a[i]-'0'!=q%10&&a[i]!='-')
            return false;
        q/=10;
        i--;
    }//按位匹配'-'
    for(int j=i;j>=0;j--)
        if(a[i]!='-'&&a[i]-'0'!=0)
            return false;
    return true;
}//判断日期是否符合输入的格式
bool check2(int x){
    if(x==1)
        return false;//特判1
    for(int i=1;i<=m&&p[i]<=sqrt(x);i++)
    	if(x%p[i]==0)
        	return false;//用筛出的质因子枚举判断会更快，只需枚举到sqrt(x)即可
    return true;
}//判断一个数是否为质数
void primes(){
    for(int i=2;i<10000;i++){
        if(v[i]==0){
            p[++m]=i;
            v[i]=i;
        }
        for(int j=1;j<=m;j++){
            if(p[j]>v[i]||p[j]*i>10000)
                break;
            v[i*p[j]]=p[j];
        }
    }
    for(int i=1;i<=m;i++)
    	s[p[i]]=1;//给10000以内的质数打个表，便于判断后四位，后两位
}//线性筛素数
int main(){
    primes();
    cin>>n;
    ll l,r,ans=0;
    for(int i=1;i<=n;i++){
        cin>>a;
        if(a=="--------"&&i>1){
        	cout<<ans<<endl;
        	continue;
		}//特判：由于第9个点都是'-'，答案相同，所以只运行一次，后面直接输出答案
        l=r=0;
        for(int j=0;j<8;j++){
            if(a[j]=='-'){
                l=l*10;
                r=r*10+9;
            }
            else{
                l=l*10+a[j]-'0';
                r=r*10+a[j]-'0';
            }
        }//确定左右端点
        ans=0;//赋初值
        int j=l-1;
        while(j<=r){
			j++;
			if(j-j/10000*10000>1231)
				j=j+8770;//用'j-j/10000*10000'代替'j%10000'会快一些
        	if(j-j/100*100>31)
        		j=j+70;//避免不可能的情况
			if(s[j-j/10000*10000]==0)
            	continue;
            if(s[j-j/100*100]==0)
            	continue;//判断后4位和后2位
            if(!check(j))
                continue;
            if(!check1(j))
            	continue;//格式
            if(check2(j))
            	ans++;//如果8位数也是质数，ans++
		}
        cout<<ans<<endl;
    }
    return 0;
}
```
#### 主要是第9个点的特判优化作用大，其他时限较长。祝大家早日通过！

```


---

## 作者：whale142857 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P5440)

题意还是很清楚的，因为只有8位数，所以考虑直接~~爆~~搜索

而对于搜索过程中那些不合法的日期，直接舍弃就行了，对于质数的判断，用了Miller-Rabin算法

对于Miller-Rabin，因为有[费马小定理](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin)：
$$a^{p - 1}\equiv1 \mod p$$
其中 $p$ 是质数,可以考虑随机一个 $a$，看上式是否成立

但存在一些数不是质数，但也能使上面的式子成立，那样的数被称为强伪素数，但那种数很少，我们可以多随机几个 $a$ 来提高正确率

但这其实是简陋版的Miller-Rabin，不过对于这道题其实够了，真正的Miller-Rabin比这里提到的多些步骤，正确率会高些

接下来就是写爆搜了，不过由于本人弱小的代码不能过"--------"这种数据，所以我只好含泪特判~~没办法我太弱了~~

详见代码：（判断质数可以多试几次，我这里写的15次足够了~~如果这都过不了那您也太非了~~）
```cpp
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<ctime>
using namespace std;
int T,num,ans;
bool isp[100000000];
char s[9];
int mon[13] = {0,31,30,31,30,31,30,31,31,30,31,30,31};

int r(int a,int b) {//生成[a,b]随机数
	return 1ll * rand() * rand() % (b - a + 1) + a;
}

int qmi(int a,int b,int mod) {
	int ans = 1;
	while(b) {
		if(b & 1) ans = 1ll * a * ans % mod;
		a = 1ll * a * a % mod;
		b /= 2;
	}
	return ans;
}

bool Prime(int x) {
	if(isp[x]) return true;//Miller-Rabin 用了个记忆化，虽然会快些，但错了的话就救不回来了
	if(x <= 1) return false;
	for(int i = 1;i <= 15;i += 1) {
		int a = r(1,x - 1);
		if(qmi(a,x - 1,x) != 1) return false;
	}
	isp[x] = true;
	return true;
}

bool isry(int x) {			//判断是不是闰年
	if(x % 100) {
		return x % 4 == 0;
	}
	return x % 400 == 0;
}

bool can(int x,int pos) {			//判断日期是否合法
	int year = x / qmi(10,pos - 4,10001),month,day;
	if(pos >= 4) {
		if(year == 0) return false;
	}
	if(pos >= 6) {
		month = x / qmi(10,pos - 6,101) % 100;
		if(month == 0 or month > 12) return false;
	}
	if(pos == 7) {
		if(month == 2) {
			if(x % 10 > 2) return false;
		}
		else {
			if(x % 10 > 3) return false;
		}
	}
	if(pos == 8) {
		day = x % 100;
		if(day == 0) return false;
		if(month == 2) {
			if(day > 28 + isry(year)) return false;
		}
		else {
			if(day > mon[month]) return false;
		}
		if(!Prime(day) or !Prime(month * 100 + day) or !Prime(x)) return false;
	}
	return true;
}

void dfs(int pos,int x) {				//爆搜本体
	if(!can(x,pos)) return;
	if(pos == 8) {
		ans += 1;
		return;
	}
	if(s[pos] == '-') {
		for(int i = 0;i < 10;i += 1) {
			dfs(pos + 1,x * 10 + i);
		}
	}
	else {
		dfs(pos + 1,x * 10 + (s[pos] xor 48));
	}
}

int main() {
	srand(time(0));
	scanf("%d",&T);
	while(T--) {
		bool j = 1;
		scanf("%s",s);
		for(int i = 0;i < 8;i += 1) {
			if(s[i] != '-') {
				j = 0;break;
			}
		}
		if(j) {				//特判
			printf("55157\n");
			continue;
		}
		ans = 0;
		dfs(0,0);
		printf("%d\n",ans);
	}
	return 0;
}
```
注：此做法非正解，仅供参考~~跑得还挺快~~

---

## 作者：zi小眼聚光 (赞：5)

这题就是个大模拟。。。

思路是这样的，满足“日”是质数且“月+日”是质数的后四位数很少，只有39个（不幸的是，229也是）

然后就愉快的打了个表出来

剩下的就是枚举年并判断是不是素数咯

这里判断素数的方法是先预处理出1w以内的素数，然后用类似埃式筛的方法暴力判断

判断对答案贡献的话，在apart函数里，我觉得写的很清楚



放上代码

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cctype>
using namespace std;
int mindiv[10001],t;
int tot,prime[10000];
bool isprime[10000];
int day[50]={0,103,503,1103,107,307,607,907,211,311,811,911,113,313,613,1013,1213,317,617,1117,1217,419,619,719,919,1019,223,523,823,1123,1223,829,929,1129,1229,131,331,1031,1231};
int cnt;
int ans[101];
char s[10];
int todo[101][10],fz[10];
void euler(){
    mindiv[0]=0;mindiv[1]=1;
    int k;
    for(int i=2;i<10000;i++){
        if(!mindiv[i])mindiv[i]=i,prime[++tot]=i,isprime[i]=1;
        for(int j=0;j<=tot&&prime[j]<=mindiv[i]&&(k=prime[j]*i)<10000;j++)mindiv[k]=prime[j];
    }
}
bool jd(int x){
  int fw=sqrt(x)+1;
  for(int i=1;i<=tot&&prime[i]<=fw;i++){
    if(x%prime[i]==0)return 0;
  }
  return 1;
}
inline void apart(int x){
  int ws=8;
  bool ok;
  memset(fz,0,sizeof(fz));
  while(x){
    fz[ws--]=x%10;
    x/=10;
  }
  for(int i=1;i<=t;i++){
    ok=1;
    for(int j=1;j<=8;j++){
      if(todo[i][j]^fz[j]&&todo[i][j]!=233){
        ok=0;
        break;
      }
    }
    if(ok)ans[i]++;
  }
}
int main(){
  euler();
  scanf("%d",&t);
  for(int i=1;i<=t;i++){
    scanf("%s",s+1);
    for(int j=1;j<=8;j++){
      if(isdigit(s[j])){
        todo[i][j]=s[j]-'0';
      }
      else todo[i][j]=233;
    }
  }
  for(int i=1;i<=9999;i++){
    for(int j=1;j<=39;j++){
      int x=i*10000+day[j];
      if(jd(x)){
        apart(x);
      }
    }
  }
  for(int i=1;i<=9999;i++){
    if(i%100&&i%4==0){
      int x=i*10000+229;
       if(jd(x))apart(x);
    }
    else if(i%400==0){
      int x=i*10000+229;
       if(jd(x))apart(x);
    }
  }
  for(int i=1;i<=t;i++)printf("%d\n",ans[i]);
  return 0;
}

```


---

## 作者：mulberror (赞：5)

先预处理出所有合法的日期。  
然后对于每一个日期都暴力匹配即可。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace IOstream_chhokmah {
	ll read() {
		ll x = 0, w = 0; char ch = 0;
		while (ch < '0' || ch > '9') { if (ch == '-') w = 1; ch = getchar(); }
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
		return w ? -x : x;
	}
	template <typename T>
	void write(T x) {
		if (x < 0) putchar('-'), x = -x;
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
	template <typename T>
	void write(T x, char ch) {
		write(x); putchar(ch);
	}
	template <typename T>
	void writeln(T x) {
		write(x); puts("");
	}
} using namespace IOstream_chhokmah;
const int Pre[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
namespace chhokmah {
char s[15];
int acc[10005][15][35];
bool check(int x) {
	if (x == 1 || x == 0) return 0; 
	for (int i = 2; i * i <= x; i ++) {
		if (x % i == 0) return 0;
	}
	return 1;
}
void pre() {
	memset(acc, 0, sizeof(acc));
	for (int Year = 1; Year <= 9999; Year ++) {
		for (int Month = 1; Month <= 12; Month ++) {
			int day = Pre[Month];
			if (Month == 2) {
				if ((Year % 4 == 0 && Year % 100 != 0) || (Year % 400 == 0)) day ++;
			}
			for (int Day = 1; Day <= day; Day ++) {
				int x1 = Day, x2 = Day + Month * 100, x3 = Day + Month * 100 + Year * 10000;
				if (check(x1) && check(x2) && check(x3)) acc[Year][Month][Day] = 1;
			}
		}
	}
}
void solve() {
	scanf("%s", s + 1);
	int ans = 0;
	for (int month = 1; month <= 12; month ++) {
		if ((s[5] != '-' && s[5] - '0' != month / 10)) continue; 
		if ((s[6] != '-' && s[6] - '0' != month % 10)) continue;
		for (int day = 1; day <= 31; day ++) {
			if ((s[7] != '-' && s[7] - '0' != day / 10)) continue; 
			if ((s[8] != '-' && s[8] - '0' != day % 10)) continue;
			for (int year = 1; year <= 9999; year ++) {
				if (s[1] != '-' && s[1] - '0' != year / 1000) continue;
				if (s[2] != '-' && s[2] - '0' != year % 1000 / 100) continue; 
				if (s[3] != '-' && s[3] - '0' != year % 100 / 10) continue;
				if (s[4] != '-' && s[4] - '0' != year % 10) continue;
				if (acc[year][month][day]) ans ++;
			}
		}
	}
	printf("%d\n", ans);
}
void main() {
	int cas = read();
	pre(); 
	while (cas --) solve();
}	
} int main() {
	chhokmah::main();
	return 0;
}
```

---

## 作者：yangyujia18 (赞：2)

## **这道题让我明白了一个道理**
### **~~打表是无所不能的~~面向数据编程**
因为空位个数不定，所以要一次枚举所有空位，我的方法是枚举一个c位数（c为空位的个数）然后把每一位填进日期  
前面几个数据没什么好说的，9号数据特判一下也过了~~10号也被我水过了~~......  
这个8号......  
我竭尽局部优化之能事，也没有让那个蓝色的方块回心转意......  
随手打开题解看看大佬们的做法......  
大佬们也在打表啊......  
不就是一个数据吗，表也不是很大......


------------
分割废话与代码的魔法之线

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
bool p[10005];
int e7[8][10]={6486,5852,5592,5507,5384,5403,5236,5273,5207,5217,
			   5660,5568,5415,5635,5424,5516,5483,5459,5517,5480,
			   5541,5430,5559,5514,5465,5531,5500,5570,5592,5455,
			   5569,5606,5519,5429,5547,5390,5593,5472,5536,5496,
			   37834,17323,0,0,0,0,0,0,0,0,
			   4344,11565,10449,7245,1435,2859,5727,1444,4315,5774,
			   10092,26062,13217,5786,0,0,0,0,0,0,
			   0,11622,0,18733,0,0,0,11544,0,13258};//不保证此表数据完全正确 
bool zchu(int a,int b)
{
	if(a%b==0)
		return true;
	return false;
}
int change(char d[10])
{
	int ans=0;
	for(int i=0;i<8;i++)
	{
		ans*=10;
		ans+=(d[i]-'0');
	}
	return ans;
}
bool su(int x)
{
	if(x==1)
		return false;
	if(x==2)
		return true;
	for(int i=2;i<=sqrt(x);i++)
		if(zchu(x,i))
			return false;
	return (p[x%10000]&&p[x%100]);
}
void prime()
{
	memset(p,true,sizeof(p));
	p[0]=p[1]=false;
	for(int i=2;i<=1231;i++)
		if(p[i]&&su(i))
			for(int j=2*i;j<=1231;j+=i)
				p[j]=false;
	return;
}
bool leagle(int date)
{
	int m[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
	int year=date/10000,month=date%10000/100,day=date%100;
	if(zchu(year,400)||(zchu(year,4)&&!zchu(year,100)))
		m[2]++;
	if(month==0||month>12)
		return false;
	if(day==0||day>m[month])
		return false;
	if(year==0||year>9999)
		return false;
	return true;
}
int main()
{
	int t;
	cin>>t;
	prime();
	for(int lll=0;lll<t;lll++)
	{
		char d[10];
		cin>>d;
		int e=0,ans=0,n=0,num=0;
		bool place[10];
		memset(place,false,10);
		for(int i=0;i<8;i++)
			if(d[i]=='-')
			{
				place[i]=true;
				e++;
			}
			else
			{
				n=i;
				num=d[i]-'0';
			}
		if(e==8)
		{
			cout<<55157<<endl;
			continue;
		}
		if(e==0)
		{
			int date=change(d);
			if(leagle(date)&&su(date))
				cout<<1<<endl;
			else
				cout<<0<<endl;
			continue;
		}
		if(e==7)
		{
			cout<<e7[n][num]<<endl;
			continue;
		}
		if(!place[7])
			if(zchu(d[7]-'0',2)||d[7]-'0'==5)
			{
				cout<<0<<endl;
				continue;
			}
		for(int l=0;l<pow(10,e);l++)
		{
			int tmp=l;
			for(int i=7;i>=0;i--)
				if(place[i])
				{
					d[i]=tmp%10+'0';
					tmp/=10;
				}
			int date=change(d);
			if(leagle(date)&&su(date))
				ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
### 第一次打表感觉不错

---

## 作者：hgoicjl (赞：2)

### 题意：

>由“日”组成的两位数，由“月+日”组成的四位数，由“年+月+日”组成的八位数均为质数。

>然而不幸的是这个日期却是残缺的，八位中可能有若干位无法确定。你需要知道这个日期有多少种可能，

### 算法：
啊？**DFS** 不是**暴力**吗？ （快逃

### 时间复杂度 O($10^n$)
### 解法：
#### ①对于质数的计算
```
bool iprime(unsigned long long n)
{
	long long stop =sqrt(n)+1;
	if (n==2)
		return true;
	if (n%2==0)
		return false;
	for (int i=3;i<=stop;i+=2)
		if (n%i==0) 
			return false;
	return true;
}
```
或者更快的
```
bool iprime(int n)
{
    int stop=n/6+1,Tstop=sqrt(n)+5;
    if (n==2||n==3||n==5||n==7||n==11)
        return true;
    if (n%2==0||n%3==0||n%5==0||n==1)
        return false;
    for (int i=1;i<=stop;i++)
    {
        if (i*6>=Tstop) 
            break;
        if ((n%(i*6+1)==0)||(n%(i*6+5)==0))
            return false;
    }
    return true;
}
```
或者**线性筛**也可以但是我没有试过
**（逃 **
***
#### ②对于日期的判断
```
int isdate(int num)
{
    int year=num/10000,month=(num/100)%100,day=num%100;
    if(year==0)//没有这个会爆0
        return 0; 
    int a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    if((year%4==0&&year%100!=0)||year%400==0)//注意判断闰年，没有卡3200这些有争议的年份
        a[2]+=1;
    if(month<=12&&month>=1&&day<=a[month])
        return 1;
    else 
        return 0;
}
```
***
#### ③怎么将字符串转化为数字（当然直接做数字的存储也没事）
```
int getnum(int type1)
{
    int start=0;
    int ans1=0;
    if(type1==1)//获得日
        start=6;
    if(type1==2)//获得月+日
        start=4;
    if(type1==3)//获得年+月+日
        start=0;
    for(int i=start;i<=7;i++)
    {
        ans1*=10;
        ans1+=m[i]-'0';
    }
    return ans1;
}
```
***
#### ④怎么暴力 当然是~~递归~~**DFS（逃**
```
int getans(int num)//num表示还需要的循环的层数
{
    if(num==0)//所有的'-'都已经被赋值
    {
        if(isdate(getnum(3))==1)
        {
            if(iprime(getnum(1))==1&&iprime(getnum(2))==1&&iprime(getnum(3))==1) //符合题意，都是质数
                ans++;
            return 0;
        }
        else
            return 0;
    }
    else
        for(int i=0;i<=9;i++)//枚举每个'-'，从0到9
        {
            m[wt[num]]='0'+i;//wt用来记录'-'的位置
            getans(num-1);//少一层循环
        }
    return 0;
}
```
***
#### ⑤**TLE**掉怎么办 当然是~~打表~~ **优化**
按照上面的办法，你应该只有90分

所以T9 ( 8个'-' ) 可以直接输出答案
```
if(count1==8)
                cout<<55157<<endl;
```
***
#### ⑥如何接近最优解 当然还是~~打表~~ **优化**
```
int t[8][10]={6486,5852,5592,5507,5384,5403,5236,5273,5207,5217,5660,5568,5415,5635,5424,5516,5483,5459,5517,5480,5541,5430,5559,5514,5465,5531,5500,5570,5592,5455,5569,5606,5519,5429,5547,5390,5593,5472,5536,5496,37834,17323,0,0,0,0,0,0,0,0,4344,11565,10449,7245,1435,2859,5727,1444,4315,5774,10092,26062,13217,5786,0,0,0,0,0,0,0,11622,0,18733,0,0,0,11544,0,13258};
```
对于T8，可以开一个数组，$t[i][j]$表示$j$(唯一的一个数字)在第$i$位上
***
#### ⑦如何做一些微不足道的优化
```
 if(m[7]=='2'||m[7]=='4'||m[7]=='6'||m[7]=='8'||m[7]=='0'||m[7]=='5')
            cout<<0<<endl;
```
日期的末尾特判
***
### AC code:
```
#include<bits/stdc++.h>
using namespace std;
char m[100];
int wt[15],count1;
int ans;
int t[8][10]={6486,5852,5592,5507,5384,5403,5236,5273,5207,5217,5660,5568,5415,5635,5424,5516,5483,5459,5517,5480,5541,5430,5559,5514,5465,5531,5500,5570,5592,5455,5569,5606,5519,5429,5547,5390,5593,5472,5536,5496,37834,17323,0,0,0,0,0,0,0,0,4344,11565,10449,7245,1435,2859,5727,1444,4315,5774,10092,26062,13217,5786,0,0,0,0,0,0,0,11622,0,18733,0,0,0,11544,0,13258};
bool iprime(int n)
{
    int stop=n/6+1,Tstop=sqrt(n)+5;
    if (n==2||n==3||n==5||n==7||n==11)
        return true;
    if (n%2==0||n%3==0||n%5==0||n==1)
        return false;
    for (int i=1;i<=stop;i++)
    {
        if (i*6>=Tstop) 
            break;
        if ((n%(i*6+1)==0)||(n%(i*6+5)==0))
            return false;
    }
    return true;
}
int isdate(int num)
{
    int year=num/10000,month=(num/100)%100,day=num%100;
    if(year==0)
        return 0; 
    int a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    if((year%4==0&&year%100!=0)||year%400==0)
        a[2]+=1;
    if(month<=12&&month>=1&&day<=a[month])
        return 1;
    else 
        return 0;
}
int getnum(int type1)
{
    int start=0;
    int ans1=0;
    if(type1==1)
        start=6;
    if(type1==2)
        start=4;
    if(type1==3)
        start=0;
    for(int i=start;i<=7;i++)
    {
        ans1*=10;
        ans1+=m[i]-'0';
    }
    return ans1;
}
int getans(int num)
{
    if(num==0)
    {
        if(isdate(getnum(3))==1)
        {
            if(iprime(getnum(1))==1&&iprime(getnum(2))==1&&iprime(getnum(3))==1)
                ans++;
            return 0;
        }
        else
            return 0;
    }
    else
    {
        for(int i=0;i<=9;i++)
        {
            m[wt[num]]='0'+i;
            getans(num-1);
        }
    }
    return 0;
}
int mian()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>m;
        memset(wt,0,sizeof(wt));
        count1=0;
        if(m[7]=='2'||m[7]=='4'||m[7]=='6'||m[7]=='8'||m[7]=='0'||m[7]=='5')
            cout<<0<<endl;
        else
        {
            ans=0; 
            for(int i=0;i<strlen(m);i++)
                if(m[i]=='-')
                    count1++;
            if(count1==8)
                cout<<55157<<endl;
            else if(count1==7)
            {
                int pos=0,x=0;
                for(int i=0;i<=7;i++)
                    if(m[i]!='-')
                    {
                        pos=i;
                        x=m[i]-'0';
                    }
                cout<<t[pos][x]<<endl;
            }
            else 
            {
                count1=0; 
                for(int i=0;i<strlen(m);i++)
                if(m[i]=='-')
                {
                    m[i]='0';
                    count1++;
                    wt[count1]=i;
                }
                getans(count1);
                cout<<ans<<endl;
            }
        }
    }
    return 0;
}
```
**你说抄题解的人会不会WA掉呢（滑稽）**

---

## 作者：Meatherm (赞：2)

暴力搜索即可。

注：此非正解，仅供参考（且有机率TLE）。

## 思路

首先，从字符串的第7位开始搜索。搜到第8位时，**判断是否为质数，判断是否组成合法天数**。若符合，跳到第5位继续搜索。从第5位开始搜到第6位，**判断5至8位是否组成质数，以及5至6位是否组成了合法月份。**若符合，跳至第1位。从第1位开始搜到第4位，**判断1~8位是否组成质数，再判断整个日期是否合法。**

总结：7->8->check(7~8)->5->6->check(5~8)->1->2->3->4->check(1~8)。

算法复杂度：$O(\text{玄学})$。

这样就A了？~~图样图森破~~ 当日期中出现$8$个'-'的时候，**可能**会超时。**所以我们需要面向数据编程——即让程序在本地跑出结果之后打表交上去。**

## 代码实现

我的做法思路简单，但是**十分难写**。请睁大眼睛看好了。（注：已经过格式化）

```
# include <bits/stdc++.h>
# define rr register
//# define DEBUG 	printf("%d %d M %d D %d\n",i,sum,Monthsum,Daysum);
//# define DEBUG2 printf("!%d %d\n",i,sum);
int T;
int ans;
int qwq[20]= {0,9,9,9,9,1,9,3,9};//记录每一位数字的最大取值
int D[20]= {0,31,28,31,30,31,30,31,31,30,31,30,31};//记录每个月的天数
char a[20];
int Daysum,Monthsum,Yearsum;//事实证明Yearsum没有必要。Daysum：当前7~8位数字组成的数 Monthsum：当前5~6位数字组成的数
inline int read(void) {//没啥卵用的快读
	int res,f=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')f=-1;
	res=c-48;
	while((c=getchar())>='0'&&c<='9')
		res=res*10+c-48;
	return res*f;
}
inline bool is_prime(int x) {//暴力判断质数
	if(x<2)
		return false;
	for(rr int j=2; j<=sqrt(x); ++j)
		if(!(x%j))
			return false;
	return true;
}
inline bool pd(int x) {//判断数字是否合法
	int year=x/10000;//提取年份
	if(year==0) {//特判0
		return false;
	}
	int month=(x%10000)/100;//提取月份
	if(month>12||month<1) {//判断
		return false;
	}
	int day=x%100;//提取天数
	if(!day)//判断0
		return false;
    //这里我是把2月拎出来单独写的    
	if(month!=2&&day>D[month])//如果超出了当月的天数 返回不合法
		return false;
	else if(month!=2&&day<=D[month])//否则合法
		return true;

	if(month==2) {//恶心的2月
		if(day>29)//没有一个二月有大于29的天数
			return false;
		if(day<=28)//所有二月都有至少28天
			return true;
		if(day==29&&((year%400==0)||(year%100!=0&&year%4==0)))//闰年
			return true;
		else
			return false;
	}
	return false;
}
void dfs(int i,int sum) {//搜索 sum为当前阶段数字之和
	if(a[i]!='-') {
		sum=sum*10+a[i]-48;//如果不能自由搜索 加上当前位的数字
		//DEBUG
		if(i==8) {//判断日
			if(is_prime(sum)&&sum<=31) {
				Daysum=sum;
				dfs(5,0);
			}
			return;
		}
		if(i==6) {//判断月
			if(is_prime(sum*100+Daysum)&&sum<=12) {
				Monthsum=sum;
				dfs(1,0);
			}
			return;
		}
		if(i==4) {//判断整个日期
			if(is_prime(sum*10000+Monthsum*100+Daysum)&&pd(sum*10000+Monthsum*100+Daysum)) {
				//printf("%d\n",sum*10000+Monthsum*100+Daysum);
				++ans;//答案+1
			}
			return;
		}
		dfs(i+1,sum);//否则在当前阶段继续搜索
	} else {
		int tmp;
		for(rr int j=0; j<=qwq[i]; ++j) {//如果可以自由选择 那么就在当前位所有可能的取值中循环
			tmp=sum*10+j;
			if(i==8) {
				if(is_prime(tmp)&&tmp<=31) {
					Daysum=tmp;
					dfs(5,0);
				}
				continue;
			}
			if(i==6) {
				if(is_prime(tmp*100+Daysum)&&tmp<=12) {
					Monthsum=tmp;
					dfs(1,0);
				}
				continue;
			}
			if(i==4) {
				if(is_prime(tmp*10000+Monthsum*100+Daysum)&&pd(tmp*10000+Monthsum*100+Daysum)) {
					//printf("%d\n",tmp*10000+Monthsum*100+Daysum);
					++ans;
				}
				continue;
			}
			dfs(i+1,tmp);//
		}
	}
}
int main(void) {
	T=read();
	while(T--) {
		ans=0;
		scanf("%s",a+1);//这里为了使下标从1开始
		if(a[1]=='-'&&a[2]=='-'&&a[3]=='-'&&a[4]=='-'&&a[5]=='-'&&a[6]=='-'&&a[7]=='-'&&a[8]=='-') {//特判
			puts("55157");
			continue;
		}
		dfs(7,0);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Social_Zhao (赞：2)

### 此题解非正解

而且很慢

第一眼看上去想到了虫食算，于是就想``dfs``。但是因为太弱，没能具象化。

第一个思路：

- 上筛表

- 判断出满足情况的最大数。这部分简单，就是把``'-'``直接换成9

- 从0001年01月01日开始，枚举。枚举部分思路如下：

  - 先提取出年、月、日
  - 分类讨论：
  - 1.闰年、平年二月分别30、29日向月进位，日期改成1
  - 2.大、小月分别32、31日向月进位，日期改成1
  - 通用情况：到了13月向年进位

  代码：

  ```cpp
  bool isrn(int year) //判断平（0）闰（1）年
  {
      if(year % 100 == 0) {
          return year % 400 == 0;
      }
      else return year % 4 == 0;
  }
  
  bool isbm(int mon) //判断大（1）小（0）月
  {
      return mon == 1 || mon == 3 || mon == 5 || mon == 7 || mon == 8 || mon == 10 || mon == 12;
  }
  
  int jw(int a)
  {
      int year = a / 10000; 
      int mon = a / 100 % 100;
      int day = a % 100; //提取年月日
      day++; //模拟加法
      if(isrn(year) && mon == 2 && day == 29 + 1) mon++, day = 1; //这里上面已经解释了
      else if(!isrn(year) && mon == 2 && day == 28 + 1) mon++, day = 1;
      else if(isbm(mon) && day == 31 + 1) mon++, day = 1;
      else if(!isbm(mon) && day == 30 + 1) mon++, day = 1;
      if(mon > 12) mon = 1, year++;
      return year * 10000 + mon * 100 + day;
  }
  ```

- 对于每一个枚举出来的日期，判断是否与原日期相符，方法： 

  - 每一位比较，如果相等或该位是``'-'``说明合法，否则``return 0``；

  代码：

  ```cpp
  bool judge(int a)
  {
      if(a / 1 % 10 != c[7] - '0' && c[7] != '-') return 0;
      if(a / 10 % 10 != c[6] - '0' && c[6] != '-') return 0;
      if(a / 100 % 10 != c[5] - '0' && c[5] != '-') return 0;
      if(a / 1000 % 10 != c[4] - '0' && c[4] != '-') return 0;
      if(a / 10000 % 10 != c[3] - '0' && c[3] != '-') return 0;
      if(a / 100000 % 10 != c[2] - '0' && c[2] != '-') return 0;
      if(a / 1000000 % 10 != c[1] - '0' && c[1] != '-') return 0;
      if(a / 10000000 % 10 != c[0] - '0' && c[0] != '-') return 0;
      return 1;
  }
  ```

- 然后判断是否为奇迹日期，如果是，``ans++``

  - 这部分简单，直接上代码

  ```cpp
  bool lucky(int a) //当时以为是幸运日期。。。函数名清奇
  {
      int year = a / 10000;
      int mon = a / 100 % 100;
      int day = a % 100;
      if(!v[day] && !v[mon * 100 + day] && !v[year * 10000 + mon * 100 + day]) return 1; //v是筛表标记数组
      else return 0;
  }
  ```

但是``TLE``了一个点。可能因为我过于轻敌，用的是埃氏筛，也可能是这个方法本身的质量问题

于是我把埃氏筛改成了欧拉筛。

成功``AC``。但是用时``15439ms``。

代码就算了，请看后面的优化。

如何优化呢？（这么垃圾的方法就别优化了吧）

既然都上了欧拉筛了，那么意味着我们可以把素数表打出来，而不只是一个标记数组。

现在我们重新考虑步骤。

- 优化一：素数比日期少得多，让我们从每个素数开始，判断是否是奇迹日期就行了。
- 优化二：如果我们按照之前的方法，每次都会从头到尾枚举一次。我们来卡一下常：再上一个筛表，筛出所有奇迹日期即可。

这样一来，时间减少了``5000ms``，心满意足。（虽然还是比深搜慢得多）

于是就有了这么一份完整的代码。马蜂清奇，轻喷

```cpp
#include<bits/stdc++.h>
using namespace std;

int get()
{
    int x = 0, f = 1; char c = getchar();
    while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
    while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
    return x * f;
}

int prime[100000005];
int f[100000005];
bool v[100000005] = {1, 1};
bool date[100000005];
int m=0;

void sprime() //素数筛表
{
    for(int i = 2; i <= 100000000; i++){
        if(!v[i]) { 
            prime[++m] = i, f[m] = i;
        } 
        for(int j = 1; j <=m && prime[j] * i <= 100000000; j++){
            int k = prime[j] * i;
            v[k] = 1;
            if(!(i % prime[j])){
                if(i == f[j]){
                    f[j] = f[j] * prime[j];
                }
                break;
            }
        }
    }
}


char c[15];
int lmt = 0;
int ans = 0;

void init()
{
    memset(c, 0, sizeof(c));
    lmt = 0;
    ans = 0;
    scanf("%s", c);
    for(int i = 0; i < 8; i++)
    {
        if(c[i] == '-') lmt = lmt * 10 + 9; 
        else lmt = lmt * 10 + c[i] - '0'; //求出满足条件的最大日期（范围上界）
    }
}

bool isrn(int year) //判断闰年
{
    if(year % 100 == 0) {
        return year % 400 == 0;
    }
    else return year % 4 == 0;
}

bool isbm(int mon) //判断大月
{
    return mon == 1 || mon == 3 || mon == 5 || mon == 7 || mon == 8 || mon == 10 || mon == 12;
}

bool lucky(int a) //判断奇迹日期
{
    int year = a / 10000;
    int mon = a / 100 % 100;
    int day = a % 100;
    if(!v[day] && !v[mon * 100 + day] && !v[year * 10000 + mon * 100 + day]) return 1;
    else return 0;
}

int jw(int a) //枚举，进位
{
    int year = a / 10000;
    int mon = a / 100 % 100;
    int day = a % 100;
    day++;
    if(isrn(year) && mon == 2 && day == 29 + 1) mon++, day = 1;
    else if(!isrn(year) && mon == 2 && day == 28 + 1) mon++, day = 1;
    else if(isbm(mon) && day == 31 + 1) mon++, day = 1;
    else if(!isbm(mon) && day == 30 + 1) mon++, day = 1;
    if(mon > 12) mon = 1, year++;
    return year * 10000 + mon * 100 + day;
}

void s_date() //奇迹日期筛表
{
    int a = 10101;
    while(a <= 99991231)
    {
        if(lucky(a)) date[a] = 1;
        a = jw(a);
    }
}

bool judge(int a) //判断是否与原数相符
{
    if(a / 1 % 10 != c[7] - '0' && c[7] != '-') return 0;
    if(a / 10 % 10 != c[6] - '0' && c[6] != '-') return 0;
    if(a / 100 % 10 != c[5] - '0' && c[5] != '-') return 0;
    if(a / 1000 % 10 != c[4] - '0' && c[4] != '-') return 0;
    if(a / 10000 % 10 != c[3] - '0' && c[3] != '-') return 0;
    if(a / 100000 % 10 != c[2] - '0' && c[2] != '-') return 0;
    if(a / 1000000 % 10 != c[1] - '0' && c[1] != '-') return 0;
    if(a / 10000000 % 10 != c[0] - '0' && c[0] != '-') return 0;
    return 1;
}

void work() //求解：
{
    for(int i = 1; i <= m; i++) //枚举素数
    {
        int a = prime[i]; 
        if(a > lmt) break; //如果大于上界，退出
        if(date[a] && judge(a)) ans++; //满足条件，答案累加
    }
    printf("%d\n", ans);
}

int main()
{
    sprime(); //筛素数
    s_date(); //筛日期
    int T = get();
    while(T--)
    {
        init(); //初始化
    	work(); //解
    }
}
```

这么个题竟然写了``100 lines``，我好菜啊。
Edit By [MaHua](http://mahua.jser.me)

---

## 作者：米奇奇米 (赞：2)

## 一眼大模拟好题啊！
### $1.1$题目意思
给你一个数字，中间有很多个等待填数字的空格，问你有几种合法的填数方案。
### $2.1$思路
我们可以先大力筛选出$1..1e9$的素数 **（线性筛既可以啦）**。然后就开始暴搜，然后计算合法的填数方案有多？关键是在细节的处理：

$A.$闰年与平年的二月的天数是不同的，这个要进行特判。

$B.$如果月的数量不合法 **（>12）**，这个月的日子数不合法，对于不同月份不同判断。

$C.$**日**以及**月+日**以及**年+月+日**要是素数

### $3.1$代码实现
```cpp
#include <bits/stdc++.h>
#define re register
using namespace std;
int num[13],tmp[14],n,m,res,cnt,ans,prime[100000010];
bool is[100000010];
char c[101];
inline void solve() {
	int ri,yue,nian;
	num[2]=28;
	nian=tmp[1]*1000+tmp[2]*100+tmp[3]*10+tmp[4];
	yue=tmp[5]*10+tmp[6];
	ri=tmp[7]*10+tmp[8];//计算年月日对应的数字
	if(nian%4==0&&nian%100!=0||nian%400==0) num[2]=29;
   //判断这年是否为闰年，闰年2月有29天
	if(!nian) return;
	if(!yue||yue>12) return;
	if(!ri||ri>num[yue]) return;//判断年月日是否合法
	int sum1=ri;
	int sum2=yue*100+ri;
	int sum3=nian*10000+yue*100+ri;
	if(is[sum1]||is[sum2]||is[sum3]) return;//C条件
	ans++;
}
inline void dfs(int x) {
	if(x==9) {
		solve();
		return;
	}
	if(c[x]!='-') {
		tmp[x]=c[x]-'0';
		dfs(x+1);
	}
	else {
		for ( re int i=0;i<=9;i++ ) {
			tmp[x]=i;
			dfs(x+1);
			tmp[x]=0;//回溯
		}
	}
}//暴搜
//inline void special_judge() {
//	if(c[1]=='-'&&c[2]=='-'&&c[3]=='-'&&c[4]=='-'&&c[5]=='-'&&c[6]=='-'&&c[7]=='-'&&c[8]=='-') 
//		puts("55157");
//} 
int main() {
	num[1]=31;
	num[2]=28;
	num[3]=31;
	num[4]=30;
	num[5]=31;
	num[6]=30;
	num[7]=31;
	num[8]=31;
	num[9]=30;
	num[10]=31;
	num[11]=30;
	num[12]=31;//每个月的日子的数量
	is[1]=1;
	for ( re int i=2;i<=100000005;i++ ) {
		if(!is[i]) prime[++cnt]=i;
		for ( re int j=1;j<=cnt;j++ ) {
			if(prime[j]*i>100000005) break;
			is[prime[j]*i]=1;
			if(i%prime[j]==0) break;
		}
	}//线性筛素数
	int q;
	scanf("%d",&q);
	while(q--) {
		scanf("%s",c+1);
		memset(tmp,0,sizeof(tmp));
		ans=0;
		dfs(1);
		if(c[1]=='-'&&c[2]=='-'&&c[3]=='-'&&c[4]=='-'&&c[5]=='-'&&c[6]=='-'&&c[7]=='-'&&c[8]=='-') {
			puts("55157");
			continue;
		}
      //特判，否则会T一个点
		printf("%d\n",ans);
	}
	return 0;
}

```
### $4.1$总结
这道题目很简单，主要是细节多，交了好多次才调出来！认真做肯定能够A掉的呀。算是**XR-2**第二简单的题目啦吧！

---

## 作者：Warriors_Cat (赞：1)

## ~~耗了本蒟蒻一个晚上的题~~

在比赛期间，我正在思索这道题，可是~~上课铃响了~~时间不够，只好在赛后的某一天A掉了这道题。

其实这道题思路很简单，就是

### 暴力dfs加回溯！~~跟暴力枚举差不多emmm…~~

操作很简单，就dfs，然后判断即可。

但这道题坑点很多，老是“听取WA声一片”，我~~一气之下~~内心却毫无波澜，~~愤怒~~平静地打出了所有的断点（你等会就知道我的断点有多恐怖）。

还有"--------"这样会超时，于是我在本地评测机等了4-5秒，然后直接特判了~~不会遭到公愤吧~~。

本蒟蒻还枚举了本题所有的坑点。

-------------------------~~代码准备中~~-------------------------

## Code:
```
#include<bits/stdc++.h>
using namespace std;
int day[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
int t, ans;
string s;
inline bool is_prime(int n){
    if(n < 2) return 0;
    if(n == 2) return 1;
    if(!(n & 1)) return 0;
    for(int i = 3; i * i <= n; ++i){
        if(n % i == 0) return 0;
    }
    return 1;
}//判断质数 
inline bool is_run(int a){
    return a % 4 == 0 && a % 100 != 0 || a % 400 == 0;
}//判断闰年 
void dfs(int step){
    if(step == 5){ 
        int x = 0;
        for(int i = 6; i <= 7; ++i){
            x = (x << 3) + (x << 1) + (s[i] ^ 48);
        }
        if(!is_prime(x)){
        	//cout << "the day isn't prime\n";
        	return;
        }
        //else cout << "the day is prime\n";
    }//判断日是否质数 
    else if(step == 3){
        int x = 0;
        for(int i = 4; i <= 7; ++i){
            x = (x << 3) + (x << 1) + (s[i] ^ 48);
        }
        if(!is_prime(x)){
        	//cout << "the month and day isn't prime\n";
            return;
        }
        //else cout << "the month and day is prime\n";
    }//判断月+日是否质数 
    else if(step == -1){
        int x = 0;
        for(int i = 0; i <= 3; ++i){
            x = (x << 3) + (x << 1) + (s[i] ^ 48);
        }
        if(!x){//坑点1：年月日不能为0 ！ 
        	//cout << "the year isn't existing\n";
            return;
        }
        if(is_run(x)) day[2] = 29;
        x = 0;//坑点2：记得归零 ！ 
        for(int i = 4; i <= 5; ++i){
            x = (x << 3) + (x << 1) + (s[i] ^ 48);
        }
        if(!x || x > 12){
        	//cout << "the month isn't existing\n";
            return;
        }
        int y = x;
        x = 0;
        for(int i = 6; i <= 7; ++i){
            x = (x << 3) + (x << 1) + (s[i] ^ 48);
        }
        if(!x || x > day[y]){
        	//cout << "the day isn't existing\n";
        	return;
        }
        x = 0;
        day[2] = 28;
        for(int i = 0; i <= 7; ++i){
            x = (x << 3) + (x << 1) + (s[i] ^ 48);
        }
        if(is_prime(x)) /*cout << "YES\n",*/ ans++;
        //else cout << "the year, month and day isn't prime\n";
        return;
    }//判断日期是否存在且年月日是否质数 
    //else if(step != 7) cout << "it's a useless search\n";
    if(s[step] == '-'){
        if(step == 0 || step == 1 || step == 2 || step == 3 || step == 5 || step == 7){
            for(int i = 0; i <= 9; ++i){
                s[step] = i + '0';
                //cout << s << " " << step << "\n";
                dfs(step - 1);
                s[step] = '-';//坑点3：记得回溯！ 
            }
        }
        else if(step == 4){
            for(int i = 0; i <= 1; ++i){
                s[step] = i + '0';
                //cout << s << " " << step << "\n";
                dfs(step - 1);
                s[step] = '-';
            }
        }
        else for(int i = 0; i <= 3; ++i){
            s[step] = i + '0';
            //cout << s << " " << step << "\n";
            dfs(step - 1);
            s[step] = '-';
        }
    }
    else{
    	//cout << s << " " << step << "\n";
        dfs(step - 1);
    }
}
int main(){
    //freopen(".out.txt", "w", stdout);
    ios::sync_with_stdio(false);
    cin >> t;
    for(int i = 1; i <= t; ++i){
        cin >> s;
        if(s == "--------"){
        	cout << "55157\n";//节约时间qwq 
        	continue;
        }
        dfs(7);
        cout << ans << '\n';
        ans = 0;//坑点4：答案归零！ 
    }
    return 0;
}
```
以上就是本蒟蒻的思路。如有不懂者，欢迎留言。

最后安利一下自己的[Blog](https://www.luogu.org/blog/134342xcy252625/)~~本蒟蒻的Blog需要各位神犇们的资瓷~~。

## End


---

## 作者：Hexarhy (赞：1)

### 思路（非正解）：

- 搜索穷枚+判断

采用$\text{dfs(now)}$，$\text{now}$代表这是字符串第几位。当到达第$8$位，进行判断。（0起点）

------------


这当然会超时啦~~4s都跑不过~~。于是我们要剪枝。

### 时间优化：

- 月份十位数只能是$0$或$1$，剩下的不用枚举。

- 日期十位数只能是$0-3$，剩下的不用枚举。

- 日期个位数必然只能是奇数，否则必定不是素数。

- 没有$0$月或$0$日。

- **但是**还是会超时，`--------`这个点过不去。于是我们就让程序跑出答案，并打表处理。

- 本来想用`unordered_map`记忆化搜索，但是貌似STL会使得程序更慢（测出来是这样）。

- 筛素数采用欧拉筛。但是本人太菜不会欧拉筛。埃氏筛数组会MLE。优化此处可以卡过本题。

- 其它自行补充……


------------

### 一些细节： 

- 注意闰年判定方法。

- $1$和$0$不是素数，记得判断。

- 将字符串转为数字使用`stoi()`函数。

- $\text{dfs}$时记得回溯。

- 字符串以$0$开始，所以$\text{dfs}$从$0$开始，以$8$结束


------------

献上丑陋的代码qaqaq：



```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <sstream>
#include <string>
using namespace std;

int ans;
string st;
int day[20]={0,31,28,31,30,31,30,31,31,30,31,30,31};

inline bool leap_year(const int& a)
{
	return (a%4==0 && a%100!=0) || a%400==0;//注意闰年判断方法
}

bool prime(const int& a)//建议使用欧拉筛，这里是本人不会
{
	if(a==1 || a==0)
	 return false;
	if(a==2 || a==3)
	 return true;
	if(a%6!=1 && a%6!=5)
	 return false;
	for(register int i=5;i*i<=a;i+=6)
	 if(a%i==0 || a%(i+2)==0)
	  return false;
	return true;
}

inline bool valid(const string s)
{
	register const int year=stoi(s.substr(0,4));//stoi()将字符串转为int
	register const int month=stoi(s.substr(4,2));
	register const int date=stoi(s.substr(6,2));
    //一系列判断
	day[2]=(leap_year(year)?29:28);
	if(year<1 || year>9999)
	 return false;
	if(month<1 || month>12)
	 return false;
	if(date<1 || date>day[month])
	 return false;
	return (prime(date) && prime(month*100+date) && prime(year*10000+month*100+date));
}

void dfs(register int now)
{
	if(now==8)
	{
		if(valid(st))
		 ++ans;
		return;
	}
	if(st[now]=='-')
	 for(register char i='0';i<='9';i++)
	 {
     	 //一系列剪枝
		 if(now==4 && i>'1')
		  continue;
		 if(now==5 && st[4]=='1' && i>'2')
		  continue;
		 if(now==5 && st[4]=='0' && i=='0')
		  continue;
		 if(now==6 && i>'3')
		  continue;
		 if(now==7 && !(i-'0')&1)
		  continue;
		 st[now]=i;
		 dfs(now+1);
		 st[now]='-';//记得回溯
	 }
	else//别忘了这个else。不是空位就继续往下搜。
	 dfs(now+1);
}

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		cin>>st;
		if(st=="--------")//打表大法好！
		{
			puts("55157");
			continue;
		}
		dfs(0);
		printf("%d\n",ans);
		ans=0;//记得清零
	}
	return 0;
}

```


---

## 作者：Erusel (赞：1)

注：我的这篇题解，代码复杂度应该是全谷最高的了。

思路：

step 1:如果对于$--------$暴力枚举的话，dfs时间复杂度就高达$10^{8}$，显然是不可取的。

step 2:普通筛法预处理出所有的八位的质数空间复杂度会爆炸。

step 3:因此，暴力枚举前四位，后四位用筛法得出质数并判断是否为合法的月和日。

step 4:避免TLE，在判断质数的时候用Miller_Rabin

几个小提醒：

1.注意判断年份不为0

2.在统计答案的时候，注意判断闰年和229。

3.注意判断日期为质数

4.判断月份不为0

代码：

```
// luogu-judger-enable-o2
#include<bits/stdc++.h>

#define rd(x) x=read()

#define int long long

#define N 10005

using namespace std;

int T;
int p[N]={0},vis[N]={1,1},prime[N];
int cnt,tot,res;
int ans[5];
string s;

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

inline void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}

int pow_mod(int a,int b,int r)
{
    int ans=1,buff=a;
    while(b)
    {
        if(b&1)ans=(ans*buff)%r;
        buff=(buff*buff)%r;
        b>>=1;
    }
    return ans;
}

bool test(int n,int a,int d)
{
    if(n==2)return true;
    if(n==a)return false;
    if(!(n&1))return false;
    while(!(d&1))d>>=1;
    int t=pow_mod(a,d,n);
    while(d!=n-1&&t!=n-1&&t!=1)
	{
        t=t*t%n;
        d<<=1;
    }
    return t==n-1||(d&1)==1;
}

bool isprime(int n)
{
    int a[]={2,3,5,7};
    for(int i=0;i<=3;i++)
	{
        if(n==a[i])return true;
        if(!test(n,a[i],n-1))return false;
    }
    return true;
}
//Miller_Rabin判质数 

/*bool check(int x)
{
	if(x<2)return false;
	for(int i=2;i<=sqrt(x);i++)
	{
		if(x%i==0)return false;
	}
	return true;
}*/ 

bool leap(int x)
{
	if(x%4)return false;
	if(!(x%100)&&(x%400))return false;
	return true;
}//判断闰年 

void dfs(int step)
{
	if(step==4)
	{
		int sum=ans[0]*1000+ans[1]*100+ans[2]*10+ans[3];//统计年 
		if(sum)//注意判断年份不为0 
		for(int i=0;i<tot;i++)
		{
			int Sum=sum*10000+prime[i];//得出八位数 
			if(isprime(Sum))//如果符合质数 
			{
//				cout<<Sums<<endl;
				if(!leap(sum)&&prime[i]==229);//如果是不是闰年但出现了2月29日 
				else 
				{
//					cout<<Sum<<endl;
					res++;	
				}//答案++ 
			} 
		}
		return ;
	}
	if(s[step]=='-')
	{
		for(int i=0;i<=9;i++)
		{
			ans[step]=i;
			dfs(step+1); 
		} 
	} //如果可填 
	else{ans[step]=s[step]-'0';dfs(step+1);}//如果不可填 
}//暴力搜索前四位 

main()
{
//	vis[0]=1,vis[1]=1;
//	p[0]=0;
//	cout<<run(1904)<<endl;//测试 
	rd(T);
	for(int i=2;i<N;i++)         
    {              
        if(!vis[i])p[cnt++]=i;           
        for(int j=0;j<cnt&&i*p[j]<N;j++)  
        {                 
            vis[i*p[j]]=1;
        	if(!(i%p[j]))break;       
		}
	}//筛法统计后四位的质数 
	while(T--)
	{
		memset(prime,0,sizeof(prime));
		tot=0,res=0;
		cin>>s;
		for(int i=0;i<cnt;i++)
	    {
	    	int x=p[i]%10,y=p[i]%100/10,z=p[i]%1000/100,w=p[i]/1000;
			int f=1;
			int month=w*10+z,date=y*10+x;
//			cout<<month<<' '<<date<<endl;
			
			if(date!=2&&date!=3&&date!=5&&date!=7&&date!=11&&date!=13&&date!=17&&date!=19&&date!=23&&date!=29&&date!=31)f=0;//注意判断日是否为质数 
			if(month==2&&date>29)f=0;
            if((month==1||month==3||month==5||month==7||month==8||month==10||month==12)&&date>31)f=0; 
            if((month==2||month==4||month==6||month==9||month==11)&&date>30)f=0; //判断月份和日期 
            if(month>12||month==0)f=0;//判断月份是否超限 
			if(s[4]!='-')if(s[4]-'0'!=w)f=0;
			if(s[5]!='-')if(s[5]-'0'!=z)f=0;
			if(s[6]!='-')if(s[6]-'0'!=y)f=0;
			if(s[7]!='-')if(s[7]-'0'!=x)f=0;
			if(f)prime[tot++]=p[i];//判断质数是否符合年月日 
		}
//		cout<<tot<<endl;
//		for(int i=0;i<tot;i++)cout<<prime[i]<<endl; 
		dfs(0);
		printf("%d\n",res); 
	}
    
	

    return 0;
}



```

---

## 作者：xh39 (赞：0)

首先,有多组测试数据,要判断是否是素数很多次,所以先用筛法求是不是质数。

筛法就不多讲了,不会的自己查。
```cpp
    for(i=2;i<=size;i++){
        if(!mark[i]){
            prime[sum++]=i;
        }
        for(j=0;j<sum&&i*prime[j]<=size;j++){
            mark[i*prime[j]]=1;
            if(i%prime[j]==0){
                break;
            }
        }
    }
```
接下来要开始枚举了,我们要优化枚举顺序,这样就可以剪枝。因为天要单独满足质数,为了剪枝,先枚举天。

剪枝:
```cpp
    if(mark[day]){
        continue; //continue是跳过一次循环的意思。
    }
    if((s[6]!='-')&&(day/10!=s[6]-'0')||(s[7]!='-')&&(day%10!=s[7]-'0')){
        continue;
    } //day/10=十位,day%10=个位
```

因为天已经知道了,而月+天要是质数,所以再枚举月。

月的剪枝有点复杂,如果天是31而月又是2,4,6,9,11,就不用枚举了。

月的剪枝(day30表示是不是只有30或以下的天):
```cpp

if(mark[month*100+day]){
    continue;
}
if(day30[month]&&day==31){
    continue;
}
if((s[4]!='-')&&(month/10!=s[4]-'0')||(s[5]!='-')&&(month%10!=s[5]-'0')){
    continue;
}
```
接下来只有年可以选择了,如果不是闰年(不知道闰年的翻小学数学课本去),就要判断天是不是29(如果月是2)

年的判断:
```cpp

    if(mark[year*10000+month*100+day]){
        continue;
    }
    if((!xyq(year))&&month==2&&day==29){
        continue;
    }
    if((s[0]!='-')&&(year/1000!=s[0]-'0')||(s[1]!='-')&&(year/100%10!=s[1]-'0')||(s[2]!='-')&&(year/10%10!=s[2]-'0')||(s[3]!='-')&&(year%10!=s[3]-'0')){
        continue;
    }
```
如果满足条件,sum++,最后输出sum

完整代码(注释就不会那么多了):
```cpp
#include<bits/stdc++.h>
using namespace std;
#define size 100000005 //#define方便修改。若多出出现,就不用一个个改了。
int prime[size]={0};
bool mark[size]={0};
bool day30[]={0,0,1,0,1,0,1,0,0,1,0,1};
bool xyq(int a){ //判断是不是闰年。
    if(a%400==0||a%100!=0&&a%4==0){
        return true;
    }
    return false;
}
int main(){
    int t,sum=0,i,j,day,month,year;
    string s;
    scanf("%d",&t);
    for(i=2;i<=size;i++){
        if(!mark[i]){
            prime[sum++]=i;
        }
        for(j=0;j<sum&&i*prime[j]<=size;j++){
            mark[i*prime[j]]=1;
            if(i%prime[j]==0){
                break;
            }
        }
    }
    sum=0;
    for(i=1;i<=t;i++){
        cin>>s;
        sum=0;
        for(day=2;day<=31;day++){
            if(mark[day]){
                continue;
            }
            if((s[6]!='-')&&(day/10!=s[6]-'0')||(s[7]!='-')&&(day%10!=s[7]-'0')){
                continue;
            }
        //	cout<<"day="<<day<<endl;
            for(month=1;month<=12;month++){
                if(mark[month*100+day]){
                    continue;
                }
                if(day30[month]&&day==31){
                    continue;
                }
                //cout<<"month="<<month<<endl;
                if((s[4]!='-')&&(month/10!=s[4]-'0')||(s[5]!='-')&&(month%10!=s[5]-'0')){
                    continue;
                }
                //cout<<"month="<<month<<endl;
                for(year=1;year<=9999;year++){
                    if(mark[year*10000+month*100+day]){
                        continue;
                    }
                    if((!xyq(year))&&month==2&&day==29){
                        continue;
                    }
                    if((s[0]!='-')&&(year/1000!=s[0]-'0')||(s[1]!='-')&&(year/100%10!=s[1]-'0')||(s[2]!='-')&&(year/10%10!=s[2]-'0')||(s[3]!='-')&&(year%10!=s[3]-'0')){
                        continue;
                    }
                    sum++;
                }
            }
        }
        cout<<sum<<endl;
    }
    return 0;
}
```
[ac](https://www.luogu.org/recordnew/show/20155672)记录(真不知道4s有什么用,我最慢的也只有965ms)。

吐槽:蓝色标签是什么鬼。。。

---

## 作者：Cesare (赞：0)

## $Soltuion$

一道有细节的模拟题。

先线性筛筛出 $1e8$ 以内的所有质数，对于一个字符串暴力枚举所有质数判断是否匹配即可。

注意要预处理出该质数的年月日是否合法。

坑点在于每个年月日、每个月日、每个日期都要是质数，这个要特判。

复杂度基本是满的，而且常数巨大。

## $Code:$

```cpp
#include <bits/stdc++.h>
//#include <tr1/unordered_map>
//#include"Bignum/bignum.h"
//#define lll bignum
#define lowbit(x) (x & -x)
#define debug(x) (cout << "#x = " << (x) << endl)
#define Set(x, i) memset (x, i, sizeof(x))
#define R register
#define int long long 
#define For(i, j, k) for(R int i = (j), ED = (k); i <= ED; ++i)
#define foR(i, j, k) for(R int i = (j), ED = (k); i >= ED; --i)
#define Cross(i, j, k) for(R int i = (j); i; i = (k))
using namespace std;
typedef long long ll;
const ll M = 1e7 + 10;
const ll N = 100000011;
const ll INF = 5e16;

namespace IO {

    inline char gc() {
        static char buf[100000], *p1 = buf, *p2 = buf;
        return (p1 == p2) && (p2 = (p1 = buf) +
            fread (buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++;
    }

    #define dd ch = getchar()
    inline ll read() {
        ll x = 0; int f = 0; char dd;
        for (; !isdigit (ch); dd) f ^= (ch == '-');
        for (; isdigit (ch); dd)  x = x * 10 + (ch ^ 48);
        return f? -x: x;
    }
    #undef dd

    inline void write( ll x ) {
        if (x < 0) putchar ('-'), x = -x;
        if (x > 9) write (x / 10); putchar (x % 10 | 48);
    }

    inline void wrn ( ll x ) { write (x); putchar (' '); }

    inline void wln ( ll x ) { write (x); putchar ('\n'); }

    inline void wlnn ( ll x, ll y ) { wrn (x), wln (y); }

}

using IO::wln;
using IO::read;

bool Vis[N];
ll cnt = 0, CCC = 0, p[M], Way[M];

inline void Init() {
    Vis[0] = Vis[1] = 1;
    For ( i, 2, 1e8 ) {
        if (!Vis[i]) p[++cnt] = i;
        for (R int j = 1; j <= cnt && i * p[j] <= 1e8; ++j) {
            Vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
        }
    }
}

const ll PY[] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
const ll RY[] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

char s[11];

inline int Check ( ll *a ) {
//	For ( i, 1, 8 ) cout << a[i]; puts ("");
    For ( i, 1, 8 ) if (s[i] != '-' && s[i] - '0' != a[i]) return 0; return 1;
}

signed main()
{
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
    Init();
    For ( i, 1, cnt ) {
        ll Nian = p[i] / 10000, yue = p[i] % 10000 / 100, ri = p[i] % 100;
        if (Nian <= 0 || yue <= 0 || yue > 12 || ri <= 0 || ri > RY[yue]) 
            { p[i] = -1; continue; }
        if (!((Nian % 4 == 0 && Nian % 100 != 0) || Nian % 400 == 0)) {
            if (ri > PY[yue]) { p[i] = -1; continue; }
        }
        if (Vis[yue * 100 + ri] || Vis[ri]) { p[i] = -1; continue; }
    }
    ll T = read(); while (T--) {
        scanf ("%s", s + 1);
        ll Ans = 0;
        For ( i, 1, cnt ) {
            if (p[i] == -1) continue;
            ll T = p[i];
            ll cc = 0, a[11], b[11];
            Set (a, 0); Set (b, 0);
            for (R int j = 8; j; --j) a[j] = T % 10, T /= 10;
//			For ( j, 1, cc ) a[j] = b[cc - j + 1];
            Ans += Check (a);
        }
        wln (Ans);
    } return 0;
}

/*
1
--------
53470327
*/

```

---

## 作者：RioBlu (赞：0)

本题主要就是暴搜+优化
___
优化会一一解释
```
#include<bits/stdc++.h>
using namespace std;
int n,ans;
short year,day,month,days[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
string k;
bool a[10];
short visit[30000];//该数是否是质数（不知道0 是1 不是2）
bool ch(int x)//是否质数int内的
{
	if(x<=1)return 0;
	if(x==2||x==3)return 1;
	if(x%2==0||x%3==0)return 0;
	for(short s=5;s<=sqrt(x);s+=6)
	{
		if(x%s==0||x%(s+2)==0)return 0;
	}
	return 1;
}
bool ch2(short x)//是否质数short内的
{
	if(visit[x]==1)return 1;//记录过
	if(visit[x]==2)return 0;//记录过
	if(x<=1)return 0;
	if(x==2||x==3)return 1;
	if(x%2==0||x%3==0)return 0;
	for(short s=5;s<=sqrt(x);s+=6)//高效筛法
	{
		if(x%s==0||x%(s+2)==0)
		{
			visit[x]=2;
			return 0;
		}
	}
	visit[x]=1;
	return 1;
}
void check()
{
	int u=0;
	for(short s=0;s<8;s++)
	{
		u=u*10+k[s]-'0'; 
	}
    //字符串改数字
	year=u/10000,day=u%100,month=u%10000/100;//计算年月日
	if(month<1||month>12||day>31||year==0)return;//如果不符合条件
	if(year%4==0&&year%100||year%400==0)days[2]=29;//是否是闰年
	else days[2]=28;
	if(days[month]<day)return;
	if(ch(u)&&ch2(u%10000)&&ch2(u%100))//是否是质数
	{
		ans++;
	}
	
}
void dfs(short x)//标准dfs, short是用来优化的
{
	if(x==8)//8位了
	{
		check();
		return;
	}
	if(a[x]==0)//不是减号
	{
		dfs(x+1);
	}
	else//是减号
	{
		for(short s=0;s<10;s++)
		{
			if(x==6&&s>=4||x==4&&s>=2)break;//剪枝
			if(x==7&&k[6]!='0'&&(s==2||s==4||s==6||s==5||s==8||s==0))continue;//剪枝
			k[x]=(s+'0');
			dfs(x+1);
		}
	}
}
int main()
{
	cin>>n;
	while(n--)
	{
		memset(a,0,sizeof(a));//初始化
		ans=0;//答案
		cin>>k;
		if(k=="--------")//特判
		{
			cout<<55157<<endl;
			continue;
		}
		for(int s=0;s<8;s++)//记录哪些地方是减号
		{
			if(k[s]=='-')a[s]=1;
		}
		dfs(0);
		cout<<ans<<endl;
	}
}
```
___
主要优化：
___
①判断质数的方法从$O(\sqrt n)->O(\frac{\sqrt n}{3})$

原因：任何一个质数（除了$2,3$）必定是$6n+1$或$6n-1$
___
②神奇的特判90分变100分
```
if(k=="--------")
{
	cout<<55157<<endl;
	continue;
}
```
___
③dfs剪枝：哪些位不可能哪些数，比如最后一位只能是$1,3,7,9$，倒数第二位只能是$0,1,2,3$,倒数第四位只能是$0,1$
___
总体来说，速度比纯枚举，无剪枝的快上不少

---


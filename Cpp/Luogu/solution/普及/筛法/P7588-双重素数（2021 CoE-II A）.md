# 双重素数（2021 CoE-II A）

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。定义**双重素数**为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 说明/提示

**样例说明**

从 $1$ 到 $15$ 共有 $6$ 个素数：$2$，$3$，$5$，$7$，$11$，$13$。前五个素数各自的数字之和也是素数，因此都是双重素数。素数 $13$ 的各位数字之和为 $4$，不是素数，故 $13$ 不是双重素数。

------------


**数据范围**

- Subtask $1$ ：$1 \le L \le R \le 10^2$，$10$ 分。
- Subtask $2$ ：$1 \le L \le R \le 10^4$，$20$ 分。
- Subtask $3$ ：$1 \le L \le R \le 10^6$，$60$ 分。
- Subtask $4$ ：$1 \le L \le R \le 10^8$，$10$ 分。

对于 $100\%$ 的数据，$1 \le T \le 100$。


------------

**提示（数据已经加强）**

最后一个子任务要求你的程序必须具有较高的空间使用效率和时间效率，否则容易超出内存限制或时间限制。

## 样例 #1

### 输入

```
4
3 3
4 4
1 5
1 15```

### 输出

```
1
0
3
5```

# 题解

## 作者：王熙文 (赞：15)

[题目传送门](https://www.luogu.com.cn/problem/P7588)

前置知识：[欧拉筛](https://www.luogu.com.cn/problem/P33830)

思路：

$1.$ 先筛出 $1 \sim 10^8$ 的所有素数，用欧拉筛。有一个问题，用普通的 `bool` 数组标记素数 or 合数空间会爆，那么可以用 STL 里的 `bitset`。定义写 `bitset<100000001> b;`  其它的和 `bool` 数组差不多，但空间是 `bool` 数组的 $\dfrac{1}{8}$。

$2.$ 从小到大枚举每个筛好的素数，求出各位数字和，由于塔小于等于 $9 \times 8 = 72$，所以可以直接用枚举判断。如果是双重素数，那么放到答案数组储存。

$3.$ 对于每次输入，我们需要找到答案数组中第一个严格大于 $r$ 的数的位置与第一个大于等于 $r$ 的数的位置。因为答案数组是递增的（因为 $2.$ 是从小到大枚举的），于是可以用二分快速找到位置。

有两个很好用的函数：`lower_bound` 和 `upper_bound`，`lower` 是找到一个递增数组里第一个大于等于某数的位置，`upper` 是找到一个递增数组里第一个大于某数的位置（你没看错，只差一个等于）。

它们的用法（找到位置）：`lower_bound/upper_bound(a+1,a+n+1,x)-a`。

这里 $a$ 是要寻找的递增数组，$n$ 是这个数组的长度，$x$ 是要找到的数（上文中的“某数”）。这样写是数组存数 $1 \sim n$ 的，如果数组存数是 $0 \sim n-1$，那么把两个 `+1` 删掉即可。

那么输出就是 `upper_bound(ans+1,ans+k+1,r)-ans-(lower_bound(ans+1,ans+k+1,l)-ans)`。

这是我的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

inline bool sushu(int a) { // 暴力判断数字和是否为素数 
	if(a==43 || a==47 || a==53 || a==59 || a==61 || a==67 || a==71) {
		return 1;
	}
	if(a==41 || a==37 || a==31 || a==29 || a==23 || a==19 || a==17 || a==13 || a==11 || a==7 || a==5 || a==3 || a==2) {
		return 1;
	}
	return 0;
} 

int dp[10000010]; // double prime
bitset<100000001> b;
int ans[10000010];
int k=0;
void work() { // 欧拉筛 + 筛出双重素数 
	const int n=100000000;
	b[1]=1;
	for(int i=2; i<=n; ++i) {
		if(!b[i]) {
			dp[++k]=i;
		}
		for(int j=1; j<=k && i*dp[j]<=n; ++j) {
			b[dp[j]*i]=1;
			if(!(i%dp[j])) {
				break;
			}
		}
	}
	int k1=k;
	k=0;
	for(int i=1; i<=k1; ++i) {
		int sum=0,t=dp[i];
		while(t) {
			sum+=t%10;
			t/=10;
		}
		if(sushu(sum)) {
			ans[++k]=dp[i];
		}
	}
}

int main() {
	work();
	int t,l,r;
	cin>>t;
	for(; t; --t) {
		cin>>l>>r;
		cout<<upper_bound(ans+1,ans+k+1,r)-ans-(lower_bound(ans+1,ans+k+1,l)-ans)<<endl;
	}
	return 0;
}
```

另外，我发明了一种方式存储 `bool` 数组值，时间和空间都和 `bitset` 差不多，详见我的[这篇 blog](https://www.luogu.com.cn/blog/wangxiwen/you-hua-bool-shu-zu-kong-jian)。下面是我的用这种方式做的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int Size=100000000;

unsigned int B[(Size+32+1)>>5];

inline void change(int wz,int turn) {
    int add=wz&31;
    wz>>=5;
    if(!turn && B[wz]>>add&1 && (B[wz]-=(1<<add)));
    if(turn && !(B[wz]>>add&1) && (B[wz]+=(1<<add)));
}

inline bool find(int wz) {
    return B[wz>>5]>>(wz&31)&1;
}

inline bool sushu(int a) {
	if(a==43 || a==47 || a==53 || a==59 || a==61 || a==67 || a==71) {
		return 1;
	}
	if(a==41 || a==37 || a==31 || a==29 || a==23 || a==19 || a==17 || a==13 || a==11 || a==7 || a==5 || a==3 || a==2) {
		return 1;
	}
	return 0;
} 

int dp[10000010]; // double prime
int ans[10000010];
int k=0;
inline void work() {
	const int n=100000000;
	change(1,1);
	for(register int i=2; i<=n; ++i) {
		if(!find(i)) {
			dp[++k]=i;
		}
		for(register int j=1; j<=k && i*dp[j]<=n; ++j) {
			change(dp[j]*i,1);
			if(!(i%dp[j])) {
				break;
			}
		}
	}
	int k1=k;
	k=0;
	for(register int i=1; i<=k1; ++i) {
		int sum=0,t=dp[i];
		while(t) {
			sum+=t%10;
			t/=10;
		}
		if(sushu(sum)) {
			ans[++k]=dp[i];
		}
	}
}

int main() {
	work();
	register int t,l,r;
	cin>>t;
	for(; t; --t) {
		cin>>l>>r;
		cout<<upper_bound(ans+1,ans+k+1,r)-lower_bound(ans+1,ans+k+1,l)<<endl;
	}
	return 0;
}
```

---

## 作者：Buried_Dream (赞：10)

## 这道题主要考察的素数筛法。

所以这里先对素数筛法进行讲解：

### 第一种筛法：开根法:

比较简单，从 $2$ 开始枚举到 $\sqrt{n}$,如果有数能是他的因子，那这个数就不是素数，否则就是素数，唯一的一处优化就是枚举到 $\sqrt{n}$，因为在根号前的因子都有一个因子与他相对，并且在 $\sqrt{n}$ 之后，如果扫到 $n$ 的话就会重复扫，这样可以减少时间。

```cpp
#include<iostream>  //开根法
#include<bits/stdc++.h>
#define maxn 2100010
using namespace std;
bool g(int x){
    if(x<2) return false;
    for(int i=2;i<=sqrt(x);i++){
        if(x%i==0) return false;
    }
    return true;
}
int n,a[maxn];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(g(a[i])) cout<<a[i]<<" ";
    }
    return 0;
}
```
### 第二种筛法：埃氏筛法
![](https://img-blog.csdnimg.cn/20181218124213973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvbGx5X1pfUF9G,size_16,color_FFFFFF,t_70)


原理如图，就是将已经是素数的倍数全部标记为不是素数。利用当前已经找到的素数，从后面的数中筛去当前素数的倍数，由预备知识一可知，当前素数已经是筛去数的质因子，如此下去能筛除所有之后的合数，是一种比较快的筛法。

```cpp
#include<iostream>   //埃氏筛
#include<bits/stdc++.h>
#define maxn 2100010
using namespace std;
int n,t;
bool vis[maxn];
void era(int tt){
    for(int i=2;i<=tt;i++){
        if(vis[i]) continue;//如果已经被标记，继续就好了
        for(int j=i*2;j<=tt;j+=i){ //把i的倍数标记一遍，他都倍数了还怎么可能是质数。。
            vis[j]=1; //标记
        }
    }
}
int main(){
    cin>>n;
    vis[0]=1,vis[1]=1;
    era(100001);
    for(int i=1;i<=n;i++){
        cin>>t;
        if(!vis[t]){
            cout<<t<<" ";
        }
    }
    return 0;
}
```
### 第三种筛法：欧拉筛法

和埃氏筛法的区别是对于每一个要筛除的数，欧拉筛法只筛除一次，而埃氏筛法会重复筛除，比如 8 和 16 同时被 2 和 4 筛去，推荐使用欧拉筛法。

能筛到 $10^8$ 的数据范围，更详细的解释都在注释里。
```cpp
#include<iostream>  //欧拉筛  较优，时间复杂度较小 
#include<bits/stdc++.h>
#define maxn 2100010
using namespace std;
int f[maxn],vis[maxn],cnt,n,t; 
void prime(int tt){
    for(int i=2;i<=tt;i++){
        if(!vis[i]) {
            f[++cnt]=i; //把质数存进去
        }
        for(int j=1;j<=cnt;j++){ //把每个质数的倍数标记成不是质数
            if(f[j]*i>tt) break; //判断越界
            vis[f[j]*i]=1;  //标记
            if(i%f[j]==0) break;  //这里是如果在上面那个循环里遍历到的数已经是存进去的质数的倍数了，那我们就没必要重复进行了
        }
    }
}
int main(){
    cin>>n;
    vis[0]=1;
    vis[1]=1;
    prime(100001);
    for(int i=1;i<=n;i++){
        cin>>t;
        if(!vis[t]){
            cout<<t<<" ";
        }
    }
    return 0;
}
```
## 题意：

先将素数判断出来，然后将素数的每一位加起来，判断一下是不是也是素数。

## 思路：

用欧拉筛先将素数筛出来，用一个手写函数将各位上的数字都加起来，再判断一下是不是素数就可以了。

因为答案数组是递增的，这里就可以用二分查找；

体现了 c++ 的好处：`STl` 库

`lower_bound` 函数，查找第一个大于等于 $x$ 的下标。

想要更加深入的了解，这里给出链接 [OI Wiki](https://oi-wiki.org/basic/binary/)

## AC code：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<bitset>
#define LL long long
#define int long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 6e6+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

int T, L, R;
int cnt[MAXN];
int tmp[MAXN], Cnt = 0;
bitset<100000015> vis;

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

int check(int x) {
    int res = 0;
    while(x) res += x % 10, x /= 10;
    return !vis[res];
}

void Init(int limit) {
    for(register int i = 2; i <= limit; ++i) {
//        if(i % 100000 == 0) cout<<i<<" "<<Cnt<<endl;
        if(!vis[i]) tmp[++Cnt] = i;
        for(register int j = 1; j <= Cnt && tmp[j] * i <= limit; ++j) {
            vis[tmp[j] * i] = true;
            if(i % tmp[j]) continue;
        }
    }
//    orz;
    for(register int i = 1; i <= Cnt; ++i) {
        if(check(tmp[i])) cnt[i] = 1;
        cnt[i] += cnt[i - 1]; 
    }
//    orz;
}


signed main()
{
    Init(100000008);
    T = read();
    while(T--) {
        L = read(), R = read();
        int L_ = lower_bound(tmp + 1, tmp + Cnt + 1, L) - tmp;
//        if(tmp[L_] == L) L_ --;
        int R_ = lower_bound(tmp + 1, tmp + Cnt + 1, R) - tmp;
        if(tmp[R_] > R) R_ --;
        printf("%lld\n", cnt[R_] - cnt[L_ - 1]);
    }
    
    return 0;
}
```


---

## 作者：_lfxxx_ (赞：7)

**题目传送门：[P7588 双重素数(2021 CoE-II A)](https://www.luogu.com.cn/problem/P7588)**

建议先去做[这道题](https://www.luogu.com.cn/problem/P3383)了解**线性筛**。

### 题意：
给出 $L,R$ ，求区间 $[L,R]$ 双重素数的个数。其中有 $T$ 组数据。
### 思路：
先筛出所有的普通质数，再筛所有的双重素数。

看了一眼数据范围 $1\le L\le R\le10^8$ ，肯定就是要用欧式筛法和 `bitset` 卡一下常了。

稍微说一下 `bitset` ：跟 `bool` 用法类似，但是内存是 `bool` 的 $\frac{1}{8}$ ，时间也比 `bool` 快一些 。

定义方法： `bitset<元素个数>b` 。

这里再稍微提一下**欧式筛法**：（ $n$ 是筛的范围， $cnt$ 记录是质数个数）
```cpp
void Getprime(){
	for(int i=2;i<=n;i++){//从第一个质数开始
		if(!numlist[i])
			prime[++cnt]=i;//计入质数表
		for(int j=1;i*prime[j]<=n;j++){
			numlist[i*prime[j]]=1;//筛走
			if(!(i%prime[j]))//保证每个数只筛一次，以加快筛的速度
				break;
		}
	}
}
```
接下来筛出双重素数：
```cpp
inline int s(int x){//求各个位之和
    int ans=0;
    while(x){
        ans+=x%10;
        x/=10;
    }
    return ans;
}
inline void Getdprime(){//cntt是记录双重素数
    int cntt=0;
    for(int i=1;i<=cnt;i++)
        if(!numlist[s(prime[i])])//看各个位之和在表中是否为质数
            prime[++cntt]=prime[i];
	cnt=cntt;
}
```
这样，我们就得出了所有的双重素数，此时差不多用掉了 $500ms$ 了。考虑到 $1\le L\le R\le10^8$ ，因此剩下的的询问我们需要较快的速度解决。

不难想到前缀和，~~也许吧？~~ 但内存不允许，因此需要换一种针对于质数表的方法。

~~自然~~想到可以通过查找位置相减来算素数，怎么查找呢， $\texttt{STL}$ 已经帮我们准备好了。

我们可以通过 `upper_bound(prime+1,prime+cnt+1,r)-prime-(lower_bound(prime+1,prime+cnt+1,l)-prime` 来算出中间隔了多少个质数。（不懂这两个函数的可以自行了解一下，这里不再赘述） 

这样一来，这道题就被解决了。
### 代码：
```cpp
#include<cstdio>
#include<bitset>
#include<algorithm>
using namespace std;
const int n=100000000;
int cnt,prime[5761460];//提前算出有多少个正常素数
bitset<n+1> numlist;//一些定义
void Getprime(){
	for(int i=2;i<=n;i++){
		if(!numlist[i])
			prime[++cnt]=i;
		for(int j=1;i*prime[j]<=n;j++){
			numlist[i*prime[j]]=1;
			if(!(i%prime[j]))
				break;
		}
	}
}
inline int s(int x){
    int ans=0;
    while(x){
        ans+=x%10;
        x/=10;
    }
    return ans;
}
inline void Getdprime(){
    int cntt=0;
    for(int i=1;i<=cnt;i++)
        if(!numlist[s(prime[i])])
            prime[++cntt]=prime[i];
	cnt=cntt;
}
int main(){
    Getprime();//获取正常素数
    Getdprime();//获取双重素数
    int t;
    scanf("%d",&t);
    while(t--){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",upper_bound(prime+1,prime+cnt+1,r)-prime-(lower_bound(prime+1,prime+cnt+1,l)-prime));//输出
    }
	return 0;
}
```

---

## 作者：metaphysis (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P7588?contestId=41599)


本题主要考察对素数筛和二分查找的掌握。

解题思路很直接：首先确定在给定的数据范围内的所有素数，对于每个素数进行判定，检查它是否为双重素数，然后再确定在每个给定的区间内有多少个双重素数。

由于给定的测试数据范围较大，需要效率较高的筛选素数的方法。在筛选得到双重素数后，需要查询给定范围内双重素数的个数，如果使用暴力枚举的方法，肯定是超时的。一种比较好的方法是利用二分查找确定区间 $[L - 1,R]$ 在双重素数数组中的位置 $x$ 和 $y$，则 $y - x$ 即为所求。具体读者可以参考代码。

最后一个子任务主要考察 [位标记在素数筛中的应用](https://www.luogu.com.cn/blog/metaphysis/wei-biao-ji-zai-su-shuo-shai-zhong-di-ying-yong)。

参考代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

#define GET(x) (B[x >> 5] & (1 << (x & 0x1F)))
#define SET(x) (B[x >> 5] |= (1 << (x & 0x1F)))

const int MAXB = 100000001, MAXN = 6000000;
int B[MAXB >> 5], dp[MAXN], pc = 0, dpc = 0;
int magic[25] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};

inline bool isDoublePrime(int n)
{
    int ds = 0;
    while (n) ds += (n % 10), n /= 10;
    for (int i = 0; i < 25; i++)
        if (ds == magic[i])
            return true;
    return false;
}

int main(int argc, char *argv[])
{
    for (int i = 2; i < MAXB; i++)
    {
        if (!GET(i)) dp[++pc] = i;
        for (int j = 1; j <= pc && i * dp[j] < MAXB; j++)
        {
            SET(i * dp[j]);
            if (i % dp[j] == 0) break;
        }
    }
    for (int i = 1; i <= pc; i++) if (isDoublePrime(dp[i])) dp[++dpc] = dp[i];
    
    int cases;
    cin >> cases;
    for (int cs = 1; cs <= cases; cs++)
    {
        int L, R;
        cin >> L >> R;
        L = upper_bound(dp + 1, dp + dpc + 1, L - 1) - dp - 1;
        R = upper_bound(dp + 1, dp + dpc + 1, R) - dp - 1;
        cout << R - L << '\n';
    }

    return 0;
}
```

---

## 作者：0606x (赞：5)

线性素数筛的简单应用，按照题目意思写下来并不需要太多的优化。

对欧拉筛不太了解的同学可以去[P3383 【模板】线性筛素数](https://www.luogu.com.cn/problem/P3383)先练习一下。

## 题目大意
给出数据组数和数据范围，求范围内“双重素数”的个数，其中双重素数的定义是该数本身和各位数字和都是素数。
## 解题思路
扫读题目后不难得出，我们需要两个函数：函数GetPrime用来筛素数，函数sum用来计算一个数的各位数字和。其中GetPrime的做法可以参考上面的模板题：
```cpp
bool isPrime[100000001];
int Prime[6000010],cnt=0;
void GetPrime(int n){
	memset(isPrime,1,sizeof(isPrime));
	isPrime[1]=0;
	for(int i=2;i<=n;i++){
		if(isPrime[i]) Prime[++cnt]=i; 
		for(int j=1;j<=cnt&&i*Prime[j]<=n;j++){
			isPrime[i*Prime[j]]=0;
			if(i%Prime[j]==0) break;
		}
	}
}//代码参考自https://www.luogu.com.cn/blog/_post/45977
```
然后就是sum函数了，用while不断取最后一位数相加，最后返回这个值就可以了：
```cpp
int sum(int n){
	int x=0;
	while(n!=0){
		x+=n%10;
		n/=10;
	}
	return x;
}
```
这样两个主要函数就做好了，其余部分根据题目进行模拟就行了：
## AC代码
```cpp
//By 0606x
#include <bits/stdc++.h>
#define ll long long
#define ull unsinged long long
#define il inline
#define rg register
using namespace std;
il ll read(){
	ll X=0;bool flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') flag=0;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		X=(X<<1)+(X<<3)+ch-'0';
		ch=getchar();
	}
	if(flag) return X;
	return ~(X-1);
}
il void write(ll X){
	if(X<0){
		X=~(X-1);
		putchar('-');
	}
	if(X>9) write(X/10);
	putchar(X%10+'0');
}//上面都是按平时习惯打的，本题并没有用到
bool isPrime[100000001];
int Prime[6000010],cnt=0;//看过题目中的提示开这么大的数组还是有点心虚的，实际交的时候空间是够用的
void GetPrime(int n){
	memset(isPrime,1,sizeof(isPrime));
	isPrime[1]=0;
	for(int i=2;i<=n;i++){
		if(isPrime[i]) Prime[++cnt]=i; 
		for(int j=1;j<=cnt&&i*Prime[j]<=n;j++){
			isPrime[i*Prime[j]]=0;
			if(i%Prime[j]==0) break;
		}
	}
}//筛素数
int t;
int sum(int n){
	int x=0;
	while(n!=0){
		x+=n%10;
		n/=10;
	}
	return x;
}//得到各位数之和
int main(){
	GetPrime(int(1e8)+1);//将题目中最大范围内的素数筛出
	scanf("%d",&t);
	for(int i=1;i<=t;i++){
		int l,r,ans=0;
		scanf("%d%d",&l,&r);//左右区间
		for(int j=l;j<=r;j++) if(isPrime[j]&&isPrime[sum(j)]) ans++;//循环查找并累加答案
		printf("%d\n",ans);
	}
	system("pause");
	return 0;//华丽结束
}
```
$p.s.:$代码打下来思路也是很清晰的，并没有出现题目和楼上题解中所描述的MLE的情况，还有就是因为数据较弱，区间内查找可以直接遍历，如果遇到毒瘤数据还要使用更复杂的数据结构进行维护。

总的要点就这么多啦，祝各位早日AC！

---

## 作者：DWT8125 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P7588)

本题为线性筛 + 二分，其实学好线性筛就能通过。[线性筛模板题](https://www.luogu.com.cn/problem/P3383)

本题解给读者提供了新思路，如果想看新思路可以直接跳过前面的普通做法。
## 普通做法+错误方法解析
**题解区的大佬们都说了**，我就不赘述了。

首先先筛出普通的素数，再逐一选出双重素数。

考虑到空间问题，我们使用[bitset](https://www.cnblogs.com/zwfymqz/archive/2018/04/02/8696631.html#_label0_0)代替bool数组。

**备注**：由于作者不喜欢一行太长，所以把代码中的
```upper_bound(_p+1,_p+cnt+1,r)-_p-(lower_bound(_p+1,_p+cnt+1,l)-_p)```缩减成了
```upper_bound(_p+1,_p+cnt+1,r)-lower_bound(_p+1,_p+cnt+1,l)```。
```cpp
#include<cstdio>
#include<bitset>
#include<algorithm>
//upper_bound 和 lower_bound 的头文件 
using namespace std;
const int n=100000000;
bitset<n+1> vis;
int t,l,r,p[6000001],
cnt=0, //个数 
_p[6000001];//双重素数 
int sum(int a){
	int x=0;
	while(a){
		x+=a%10;
		a/=10;
	}
	return x;
}
int check(int b){
	for(int j=2;j*j<=b;j++)
		if(b%j==0) return 0;
	return 1;
}
void prime(){ //线性筛 
	for(int i=2;i<=n;i++){
		if(!vis[i]) p[++cnt]=i;
		for(int j=1;j<=cnt&&i*p[j]<=n;j++){
			vis[i*p[j]]=true;
			if(i%p[j]==0) break;
		}
	}
}
void _prime(){
	int _cnt=0;
	for(int i=1;i<=cnt;i++)
		if(check(sum(p[i]))) _p[++_cnt]=p[i];
	//选出双重素数 
	cnt=_cnt; //更新 
}
int main(){
	scanf("%d",&t);
	prime(); _prime();
	while(t--){
		scanf("%d%d",&l,&r);
		printf("%d\n",upper_bound(_p+1,_p+cnt+1,r)-lower_bound(_p+1,_p+cnt+1,l));
		//直接二分查找元素个数 
	}
	return 0;
}
```
### 错误方法
有人会发现，我们为什么不把 $prime$ 函数改成
```cpp
void prime(){ //线性筛 
	for(int i=2;i<=n;i++){
		if(!vis[i]) //是素数
			if(check(sum(i))) //是双重素数
				p[++cnt]=i;
		for(int j=1;j<=cnt&&i*p[j]<=n;j++){
			vis[i*p[j]]=true;
			if(i%p[j]==0) break;
		}
	}
}
```
不就好了吗？**NO！**

举个例子， $221=13 \times 17$ ，两个质因子都不是双重素数，就会导致**筛不掉** 221 ，完全违反筛法“**合数会被自己的因数筛掉**”的基本思路，所以**是错的**！
## 优化：记忆化
这里的 $sum$ 函数要多次分离数位，使得复杂度严格来说不再是 $O(10^8+cnt+T$ log $cnt)$（ $cnt$ 是普通素数个数），能优化吗？

我们可以使用记忆化，定义数组 $sum$，记下前 $10^7$ 个数，对于数字 $a$，各个数位的和即为 $sum[ \dfrac{a}{10} ]+a\%10$ 。这样可以省去分离数位的时间，不过内存大约多出 40MB 。

[普通做法](https://www.luogu.com.cn/record/55714787)和[优化做法](https://www.luogu.com.cn/record/55715591)

记得要初始化：```for(int i=0;i<=9;i++) sum[i]=i;```

改进后的筛数过程：
```cpp
void prime(){
	for(int i=2;i<=n;i++){
		if(i<=n/10) sum[i]=sum[i/10]+i%10;
		//记忆化，注意别越界
		if(!vis[i]) p[++cnt]=i;
		for(int j=1;j<=cnt&&i*p[j]<=n;j++){
			vis[i*p[j]]=true;
			if(i%p[j]==0) break;
		}
	}
}
void _prime(){
	int _cnt=0;
	for(int i=1;i<=cnt;i++)
		if(p[i]>n/10){ //可有可无的特判 
			if(check(sum[p[i]/10]+p[i]%10))
				//方便多了 
				_p[++_cnt]=p[i];
		}
		else
			if(check(sum[p[i]]))
				//小于等于 10^7 的直接查表 
				_p[++_cnt]=p[i];
	cnt=_cnt;
}
```
希望这篇题解能帮到读者。给作者点个关注吧！

---

## 作者：FuriousC (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P7588)

一道非常暴力的题

思路是先用 线性筛 筛出素数，再在素数里筛双重素数

但是，这是一道绿题，总不可能套一个 线性筛 板子（黄）就让你过：

**卡空间**

所以，个人认为这题有绿的原因就是因为考察了 `bitset` 的使用

`bitset` 其实和 `bool` 数组类似，只是比 `bool` 数组占的空间少了约 $\dfrac{1}{8}$，所以可以通过这题

最后有点麻烦的就是多组数据的询问，我们可以通过将查找的位置相减来得到答案

代码：

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000005;
const int maxm=5761460;
int cnt=0,p[maxm],t,l,r;
bitset<maxn+1> ip;//相当于bool ip[maxn+1]
inline void TommyInnit(){
	for(int i=2;i<=maxn;i++){
		if(!ip[i]){
		    cnt++;
			p[cnt]=i;
		}
		for(int j=1;i*p[j]<=maxn;j++){
			ip[i*p[j]]=1;
			if(!(i%p[j])){
				break;
			}
		}
	}
	return ;
}//线性筛筛素数
inline int sum(int n){
    int res=0;
    while(n){
        res+=n%10;n/=10;
    }
    return res;
}//求素数每一位之和
inline void Double_TommyInnit(){
    int cnt1=0;
    for(int i=1;i<=cnt;i++){
        if(!ip[sum(p[i])]){
            cnt1++;
            p[cnt1]=p[i];
        }
    }
	cnt=cnt1;
	return ;
}//筛双重素数
int main(){
    TommyInnit();Double_TommyInnit();
    cin>>t;
    while(t--){
        cin>>l>>r;
        cout<<upper_bound(p+1,p+cnt+1,r)-p-(lower_bound(p+1,p+cnt+1,l)-p)<<"\n";//通过STL自带的函数减少时间
    }
	return 0;
}
```


---

## 作者：yerrjjjf (赞：1)

## 1 理解题意
首先读题([看这里](https://www.luogu.com.cn/problem/P7588))

找出文中重要信息：
- 多组数据(这也直接导致了循环超时)

- 它的各位数字之和也是一个素数

- 给定一个闭区间，试确定在该区间内双重素数的个数

## 2 分析题目
思路：
1. 定义一个变更的左(L) 右(R) 区间来节省第二次筛查时间与空间

2. 第一遍筛出普通的素数
3. 第二遍重复利用，再筛出题目所要求的双重素数

分析：看一眼数据：$1≤L≤R≤10^8$，数据较大，要用适当方式来卡常

这时候就要用到 ```lower_bound``` 和 ```uppere_bound``` 了

Tips：

```lower_bound()``` 和 ```upper_bound()``` 都是C++自带的函数，利用**二分查找**

在一个**排好序**的数组中进行**区间查找**最小值及最大值的函数

声明方式:
```lower_bound(begin,end,num)```

解释：

从数组的 begin 位置到 (end-1) 位置二分查找第一个大于等于 num 的数字

找到返回该数字的地址，不存在则返回 end

通过返回的地址减去起始地址 begin，得到找到数字在数组中的下标

(upper_bound 与之相反，不在此赘述)
## 3 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
inline int read()//快读+快速查找
{
	int s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')f=-1;ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
	}
	return s*f;
}
const int N=6e6+5,M=1e8+10;
int prime[N],pm,kl;//prime 用来存第一遍筛出来的素数 
bitset<M> vis;
inline bool check(int x)//更新筛后素数的位置，方便第二次筛选
{
	int ret=0;
	while(x)
	{
		ret+=x%10;x/=10;
	}
	return !vis[ret];
}
inline void init(int n)//筛素数(第二次也是用这个，重复使用)
{
	for(int i=2;i<=n;++i)
	{
		if(!vis[i])
		{
			prime[++pm]=i;
		}
		for(int j=1;j<=pm&&1ll*prime[j]*i<=n;++j)
		{
			vis[i*prime[j]]=1;
			if(!(i%prime[j]))
			{
				break;
			}
		}
	}
	for(int i=1;i<=pm;++i)
	{
		if(check(prime[i]))//更新prime数组 
			{
				prime[++kl]=prime[i];
			}
	}
}
struct lxz{//定义结构体来确定左右区间
	int L,R;
}q[105];
int T,mx;
int main()
{
	T=read();
	for(int i=1;i<=T;++i)
	{
		q[i].L=read();q[i].R=read(); 
		mx=max(mx,q[i].R);
	}
	init(mx);
	for(int i=1,p1,p2;i<=T;++i)
	{
		p2=lower_bound(prime+1,prime+kl+1,q[i].R+1)-prime;//lower_bound节省时间
		p1=lower_bound(prime+1,prime+kl+1,q[i].L)-prime;
		printf("%d\n",p2-p1);
	}
	return 0;
}
```
 在我的博客中[查看](https://www.luogu.com.cn/blog/FBBBOOS/solution-p7588)
 

---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15254150.html)

## 题目描述

素数（质数）是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。

定义双重素数为这样的素数：它的各位数字之和也是一个素数。给定一个闭区间，试确定在该区间内双重素数的个数。

## 题目分析

**一道线性筛好题。**

这道题的题意很好理解，但是注意到空间`96.00MB ~ 128.00MB`，众所周知线性筛需要的空间一般很大，我们如果强制开两个 100000005 大小的数组会在最后一个点 MLE，此时最好的方法就是用 bitset 替代 bool 类型，空间好像可以降到 $\dfrac{1}{8}$ 左右？

对于输出 $[l,r]$ 内的双重素数这一步，观察到质数单调上升，所以解决办法是二分查找：

**在已经求出的双重质数表中，先二分查找出第一个大于 $r$ 的位置 $pos_r$，再求出第一个大于等于 $l$ 的位置 $pos_l$，答案就是 $pos_r-pos_l$。**

我们手玩一下样例 `1 15`，$[1,15]$ 内的双重质数有：$2,3,5,7,11$，第一个大于 $15$ 的双重质数为 $23$，那么 $pos_r$ 等于 $6$，第一个大于等于 $1$ 的双重质数为 $2$，那么 $pos_l$ 等于 $1$，答案为 $pos_r-pos_l=5$。

## 代码
$\rm IO$ 较长，故省略：

```cpp
const int ma=100000005;

int pri[ma];

bitset<ma+1>is_pri;

int idx;

inline void init(int n)
{
	for(register int i=2;i<=n;i++)
	{
		if(is_pri[i]==false)
		{
			pri[++idx]=i;
		}
		
		for(register int j=1;i*pri[j]<=n;j++)
		{
			is_pri[pri[j]*i]=true;
			
			if(i%pri[j]==0)
			{
				break;
			}
		}
	}
}

inline int sum(int n)
{
	int res=0;
	
	while(n!=0)
	{	
		res+=n%10;
		
		n/=10; 
	}
	
	return res;
} 

inline void solve()
{
	int ans=0;
	
	for(register int i=1;i<=idx;i++)
	{
		if(is_pri[sum(pri[i])]==false)
		{
			pri[++ans]=pri[i];
		}
	}
	
	idx=ans;
}

int main(void)
{
	init(ma);
	
	solve();
	
	int T=read();
	
	while(T--)
	{
		int l=read(),r=read();
		
		printf("%d\n",upper_bound(pri+1,pri+idx+1,r)-pri-(lower_bound(pri+1,pri+idx+1,l)-pri));
	}
	
	return 0;
}

---

## 作者：SunsetSamsara (赞：0)

这题(个人感觉)认为配不上这个难度,应该是普及/提高-才对

我的思路特别简单:线性筛素数,然后对素数再筛一遍,看看是不是双重素数.

首先,要卡空间,我直接选择手写位数组(不过说实话`bitset`更好一些,好用,常数也不大)

```cpp
int _data[3125000];
void set0(int id){//第id位赋值为0 
	_data[id>>5]&=~(1<<(id&31));//与上11...1011..1 
}
void set1(int id){//第id位赋值为1
	_data[id>>5]|=1<<(id&31);//或上00...0100..0 
}
char get(int id){
	return (_data[id>>5]>>(id&31))&1;//类似地 
}
```

接下来直接筛就可以了.

```cpp

int prs[5761461],cnt;
int prs2[5761461],cnt2;
//线性筛素数 
void _sieve(){
    for(int i=2,j,x;i<=maxn;++i){
        if(!get(i))prs[++cnt]=i;
        for(j=1,x=i*prs[j];x<=maxn;++j,x=i*prs[j]){
        	set1(x); 
            if(!(i%prs[j]))break;
        }
    }
}
//获取素数数字和 
int getSum(int n){
	int ret=0;
	while(n)ret+=n%10,n>>=1,n/=5;
	return ret;
}
//在素数中筛双重素数
void sieve(){
	_sieve();
	cnt2=0;
	for(int i=1;i<=cnt;++i){
		if(!get(getSum(prs[i])))
			prs2[++cnt2]=prs[i];
	}
} 
```
最后用一遍二分随便写一写就可以 AC 了,下面直接贴完整代码:
```cpp
#include<stdio.h>
#define maxn 100000000
//压空间 
int _data[3125000];
void set0(int id){//第id位赋值为0 
	_data[id>>5]&=~(1<<(id&31));//与上11...1011..1 
}
void set1(int id){//第id位赋值为1
	_data[id>>5]|=1<<(id&31);//或上00...0100..0 
}
char get(int id){
	return (_data[id>>5]>>(id&31))&1;//类似地 
}
int prs[5761461],cnt;
int prs2[5761461],cnt2;
//线性筛素数 
void _sieve(){
    for(int i=2,j,x;i<=maxn;++i){
        if(!get(i))prs[++cnt]=i;
        for(j=1,x=i*prs[j];x<=maxn;++j,x=i*prs[j]){
        	set1(x); 
            if(!(i%prs[j]))break;
        }
    }
}
//获取素数数字和 
int getSum(int n){
	int ret=0;
	while(n)ret+=n%10,n>>=1,n/=5;
	return ret;
}
//在素数中筛双重素数
void sieve(){
	_sieve();
	cnt2=0;
	for(int i=1;i<=cnt;++i){
		if(!get(getSum(prs[i])))
			prs2[++cnt2]=prs[i];
	}
} 
//二分找到第一个大于等于x的双重素数下标 
int getInd1(int x){
	int l=1,r=cnt2,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(prs2[mid]>=x)r=mid-1;
		else l=mid+1;
	}  
	return l;
}
//二分找到第一个大于x的双重素数下标 
int getInd2(int x){
	int l=1,r=cnt2,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(prs2[mid]<=x)l=mid+1;
		else r=mid-1;
	}  
	return l;
}
int main(){
	sieve();
	int T,l,r;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&l,&r);
		printf("%d\n",getInd2(r)-getInd1(l));
	}
}
```
最后说(赞扬?)一下洛谷评测机,在本地调试的我花了 $3$ 个小时卡初始化都卡不进 $1s$,在评测机上 $500ms$ 就过了???

---


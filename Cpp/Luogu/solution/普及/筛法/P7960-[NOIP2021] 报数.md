# [NOIP2021] 报数

## 题目描述

报数游戏是一个广为流传的休闲小游戏。参加游戏的每个人要按一定顺序轮流报数，但如果下一个报的数是 $7$ 的倍数，或十进制表示中含有数字 $7$，就必须跳过这个数，否则就输掉了游戏。

在一个风和日丽的下午，刚刚结束 SPC20nn 比赛的小 r 和小 z 闲得无聊玩起了这个报数游戏。但在只有两个人玩的情况下计算起来还是比较容易的，因此他们玩了很久也没分出胜负。此时小 z 灵光一闪，决定把这个游戏加强：任何一个十进制中含有数字 $7$ 的数，它的所有倍数都不能报出来！

形式化地，设 $p(x)$ 表示 $x$ 的十进制表示中是否含有数字 $7$，若含有则 $p(x) = 1$，否则 $p(x) = 0$。则一个正整数 $x$ 不能被报出，当且仅当存在正整数 $y$ 和 $z$ ，使得 $x = yz$ 且 $p(y) = 1$。


例如，如果小 r 报出了 $6$ ，由于 $7$ 不能报，所以小 z 下一个需要报 $8$；如果小 r 报出了 $33$，则由于 $34 = 17 \times 2$，$35 = 7 \times 5$ 都不能报，小 z 下一个需要报出 $36$ ；如果小 r 报出了 $69$，由于 $70 \sim 79$ 的数都含有 $7$，小 z 下一个需要报出 $80$ 才行。

现在小 r 的上一个数报出了 $x$，小 z 想快速算出他下一个数要报多少，不过他很快就发现这个游戏可比原版的游戏难算多了，于是他需要你的帮助。当然，如果小 r 报出的 x 本身是不能报出的，你也要快速反应过来小 r 输了才行。

由于小 r 和小 z 玩了很长时间游戏，你也需要回答小 z 的很多个问题。

## 说明/提示

**【样例解释 #1】**

这一组样例的前 $3$ 次询问在题目描述中已有解释。

对于第 $4$ 次询问，由于 $300 = 75 \times 4$，而 $75$ 中含有 $7$ ，所以小 r 直接输掉了游戏。

**【数据范围】**

对于 $10\%$ 的数据，$T \leq 10$，$x \leq 100$。  
对于 $30\%$ 的数据，$T \leq 100$，$x \leq 1000$。  
对于 $50\%$ 的数据，$T \leq 1000$，$x \leq 10000$。  
对于 $70\%$ 的数据，$T \leq 10000$，$x \leq 2 \times {10}^5$。  
对于 $100\%$ 的数据，$1 \le T \leq 2 \times {10}^5$，$1 \le x \leq {10}^7$。

## 样例 #1

### 输入

```
4
6
33
69
300
```

### 输出

```
8
36
80
-1
```

## 样例 #2

### 输入

```
5
90
99
106
114
169
```

### 输出

```
92
100
109
-1
180
```

## 样例 #3

### 输入

```
见附件中的 number/number3.in```

### 输出

```
见附件中的 number/number3.ans```

## 样例 #4

### 输入

```
见附件中的 number/number4.in```

### 输出

```
见附件中的 number/number4.ans```

# 题解

## 作者：银杉水杉秃杉 (赞：272)

谨以此题解来纪念我七年的 OI 生涯（退役了，再见了 OI）

像今年 T1 这种几年不遇的水题你是不可能再遇见第二次的。

这道题提前预处理单纯地筛一筛就可以了，没有别的任何操作。

需要注意的是，在预处理时要合理的剪枝，保证时间复杂度控制在  $O(10^7+T)$（$10^7$ 是数据范围，$T$是询问数）。

我们用 $f$ 数组表示该数是否被标记。如果一个数 $i$ 被标记过了，就直接跳过；如果 $i$ 含有数字 $7$，我们就将 $i$ 的所有倍数（包括 $i$ 本身）全部标记。

我们用 $nx$ 数组（也就是 $next$ 的缩写）来记录该数的下一个报的数是多少。在处理的时候，我们需要记录上一个报的数 $ls$（$last$ 的缩写，也就是没有标记的数）。如果 $i$ 没有标记过也不含有数字 $7$，那么 $nx_{ls}$ 就是 $i$，然后将 $ls$ 更新为 $i$。

预处理的好处就是保证询问的时候每次询问都是 $O(1)$。如果询问的 $x$ 被标记了，就输出 $-1$；反之，输出 $nx_x$。

还要注意一点，考场上一定要用上读入优化和输出优化，小心可能会被卡。

代码非常的好写，看看就可以了：

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()//读入优化
{
    int x = 0, f = 1;
    char ch = getchar();
    while (!isdigit(ch))
    {
        f = ch != '-';
        ch = getchar();
    }
    while (isdigit(ch))
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return f ? x : -x;
}
inline void write(int x)//输出优化
{
    if (x >= 10)
        write(x / 10);
    putchar(x % 10 + 48);
}
const int N = 1e7 + 100;
int T, x, ls;
int f[N], nx[N];
bool check(int x)//判断是否含有数字7
{
    while (x)
    {
        if (x % 10 == 7)
            return 1;
        x /= 10;
    }
    return 0;
}
void init()//预处理部分
{
    for (int i = 1; i <= N - 10; i++)
    {
        if (f[i])//如果被标记过，就跳过
            continue;
        if (check(i))//如果含有数字7，标记其倍数
        {
            for (int j = i; j <= N - 10; j += i)
                f[j] = 1;
            continue;
        }
        nx[ls] = i;//记录i
        ls = i;//更新ls
    }
}
int main()
{
    init();//先预处理
    T = read();
    while (T--)
    {
        x = read();
        if (f[x])//被标记了输出-1，否则输出nx
            puts("-1");
        else
            write(nx[x]), putchar('\n');
    }
    return 0;
}
```

T1 太水了，导致其他三道很难，拉不开差距。今年 NOIP 直接爆炸，直接宣告了我的退役 QwQ。

总之，再见了 OI，感谢陪伴的七年，祝一切顺利。

---

## 作者：StudyingFather (赞：46)

这次 T1 算是比较常规。

禁止报的数的生成规则与 [埃氏筛法](https://oi-wiki.org/math/number-theory/sieve/) 类似，考虑用筛法预处理可以报出的数字列表和不可报出的数字，从而 $O(1)$ 回答每一组询问。

具体来说，我们从 $1$ 开始逐一处理每个正整数。当我们处理到数字 $x$ 时，如果数字 $x$ 尚未被标记为不合法，就通过拆位判断它是否合法。如果是合法数字，则将其加入合法数字列表，否则将 $x$ 的所有倍数（包括 $x$ 本身）全部标记为不合法数字；如果数字 $x$ 已经被标记为不合法，则因为数字 $x$ 的所有倍数都已经在之前和数字 $x$ 一同被标为不合法数字，不需要再执行额外操作。

小细节：虽然 $x \leq 10^7$，但是要输出的下一个合法数字可能大于 $10^7$，因此筛的范围要稍微大一些（事实上，大于 $10^7$ 的第一个合法数字是 $10^7+1$）。

问题来了，这个做法的时间复杂度是多少呢？是 $O(n \log \log n)$ 吗？并不是。[可以证明](https://www.luogu.com.cn/blog/tyqtyq/noip2021-t1-mou-zhong-suan-fa-fu-za-du-di-jian-dan-zheng-ming)，该做法的时间复杂度是 $O(n \log n)$。

```cpp
// Problem: P7960 [NOIP2021] 报数
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7960
// Memory Limit: 512 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
using namespace std;
const int maxn = 10000000 + 1000;
int vis[maxn + 5], lis[maxn + 5], cnt;
bool check(int x) {
  while (x) {
    if (x % 10 == 7) return false;
    x /= 10;
  }
  return true;
}
void init() {
  for (int i = 1; i <= maxn; i++)
    if (vis[i] == 0) {
      if (check(i)) {
        vis[i] = ++cnt;
        lis[cnt] = i;
      } else
        for (int j = 1; i * j <= maxn; j++) vis[i * j] = -1;
    }
}
int main() {
  ios::sync_with_stdio(false);
  int T;
  cin >> T;
  init();
  while (T--) {
    int x;
    cin >> x;
    if (vis[x] == -1)
      cout << -1 << endl;
    else {
      cout << lis[vis[x] + 1] << endl;
    }
  }
  return 0;
}
```

---

## 作者：滑_稽 (赞：16)

# 0 前言

我是真的没想到我这么水一个成绩还能鬼混进 NOIP，怕不是某组织见我们学校那么弱，多给了几个名额（雾

这篇题解是建立在考场上四个样例全过和你谷民间数据 $\text{100pts}$ 的基础上写的，~~100%高质量。~~

如有发现错误请在讨论区指出，万分感谢！

# 1 简化题意

虽然题面算是比较清晰的，不过我还是写一下简化后的题意：

$T$ 组数据 $(1<T\le2\times10^5)$，每组数据占一行，包括一个正整数 $x(1\le x\le10^7)$，你需要输出一行一个整数。

- 假设正整数 $n$ 不能被任何一个数位中带 $7$ 的数整除，我们就称数 $n$ 为合法的数。注意，由此定义可得，如果 $n$ 的数位中本身含有 $7$，$n$ 也是不合法的。所有合法的数可以组成一个单调递增序列 $\{S_i\}(i\ge1)$。例如，$S_1=1$，$S_2=2$。

- 如果 $x$ 是合法的数，就输出 $x$ 的下一个合法的数（即如果 $S_i=x$，就输出 $S_{i+1}$）。如果 $x$ 不合法，则输出 $-1$。

# 2 题目分析

由题可知，所有合法的数都在 $10^7$ 之内，考虑筛法。

可以用和**埃氏筛**相似的思路：从 $1$ 开始枚举正整数，如果该正整数的数位中含有 $7$，就将它的所有在数据范围内的倍数都打上不合法标记，一直到 $10^7$ 枚举结束。

正确性的证明（如果知道埃氏筛的原理可以跳过不看）：

反证法。假设用这种方法筛完所有数后仍有不合法的数没被筛出，记这个数为 $a$。那么根据定义，它一定至少有一个因子是不合法的数，记这个因子为 $b$。这样的话，$b$ 肯定也没被筛出，因为算法没有通过 $b$ 去筛掉 $a$（而算法本应该这样做）。所以 $b$ 肯定也至少有一个因子是不合法的数，而这个因子没有被筛掉。就这样一层层往前推，就推到了一开始枚举到的一个不合法的数 $c$，它没被筛掉导致了后面一连串的数没被筛掉。而算法每枚举到一个数都会判断它数位中是否含有 $7$，不存在漏判的现象，于是这个与前面没筛出的 $c$ 矛盾，从而证明了算法的正确性。

判断一个数的数位中是否含有 $7$，可以利用除十法逐位判断。另外提一个优化的细节：筛出所有合法的数后，没必要在输入 $x$ 之后一个个枚举 $x$ 后面的数判断是否合法，可以将所有合法的数放进一个有序数组 $S$，再利用**映射**的思想去将数和在数组中的下标对应，有数就能求出下标，有下标就能求出数。具体地讲，对于每个 $S_i$，可以利用另一个数组 $A$，使 $A_{S_i}=i$。这样，对于一个给定的合法数 $x$，可以直接找到 $x$ 在 $S$ 中的下标为 $A_x$。就这样，可以在 $O(1)$ 的时间内得出 $S_{A_x+1}$ 就是答案。

时间复杂度基本与埃氏筛相似，具体实现细节参见代码。

# 3 代码实现

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int maxN=1e7+5;
int t,n,tot,Safenum[maxN],Numsafe[maxN];//映射
bool Ill[maxN];//筛表

bool judge(int x){//判断数位中是否含有7
	while(x){
		if(x%10==7) return true;
		x/=10;
	}
	return false;
}

void GetSafeNum(){//筛出所有合法的数
	for(int i=1;i<maxN;i++){
		if(judge(i)) for(int j=1;j*i<maxN;j++) Ill[j*i]=1;
		if(!Ill[i]){
			tot++;//tot就是当前筛出的合法的数的个数
			Safenum[tot]=i,Numsafe[i]=tot;
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	GetSafeNum();
	cin>>t;
	while(t--){
		cin>>n;
		if(!Numsafe[n]) cout<<-1;
		else cout<<Safenum[Numsafe[n]+1];
		if(t) cout<<endl;
	}
	return 0;
}
```

---

## 作者：GI录像机 (赞：15)

## 题意简述：

已知含有 $7$ 的自然数及其倍数不合法，给出一个数，问这个数是否合法。若合法，输出下一个合法的数；若不合法，输出 $-1$。

## 思路：

我们只需要把每个有 $7$ 的数找出来然后把它的倍数都标记为不合法，并将每个不含有 $7$ 且未被标记过的数加入合法序列中，再将这个数及其对应的下标存入一个映射。这样，在输入时若这个数合法，我们就可以找出它在合法序列中的下标，从而找到序列中的下一个合法数。注意：这个 $10^7$ 指的是输入数的范围，因此最终的答案有可能是超过 $10^7$ 的，所以我们应该多算出一个合法数。

## 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF = 1e7 + 1e6;
bool vis[INF + 10];
map<int, int>ko;
long long t, x, ok[INF + 10], tot = 0;
void p(long long m) {
	long long s = m;
	while (m != 0) {
		if (m % 10 == 7) {
			for (long long i = 1; i * s <= INF; i++)vis[i * s] = true;
			break;
		}
		m /= 10;
	}
}
int main() {
	//freopen("number.in","r",stdin);
	//freopen("number.out","w",stdout);
	for (long long i = 1; i <= INF; i++) {
		if (vis[i] == true)continue;
		p(i);
		if (!vis[i]) {
			ok[++tot] = i;
			ko[i] = tot;
		}
	}
	cin.tie();
	cin >> t;
	while (t--) {
		cin >> x;
		if (vis[x])cout << -1 << endl;
		else cout << ok[ko[x] + 1] << endl;
	}
	return 0;
}
```


#### 考后感受：
这道题是真的水。~~然鹅考场上觉得不需要优化写挂了~~

---

## 作者：Poncirus (赞：12)

## 预处理

本文将会介绍在本题中比较亲民的埃筛。

埃筛时有一个小优化：我们使用两个数组作标记：$vis_x$ 表示 $x$ 中含有 $7$，$vis'_x$ 表示 $x$ 是某个不能报的数的倍数。

对于 $x$，能且仅能由它标记出它的倍数（即 $vis'$ 数组）。当 $vis'_x=\text{true}$ 时，$x$ 一定被其因数（假设为 $y$）标记，而明显 $x$ 的倍数即为 $y$ 的倍数，所以 $x$ 的倍数在 $vis'$ 中都会被 $y$ 标记。所以，此时 $x$ 不用再标记自己的倍数。

现在我们已知，当 $vis_x$ 和 $vis'_x$ 中，两者有任意一个值为 $\text{true}$ 时，$x$ 不能报。

## 查询

容易想到把所有询问从小到大排序，离线处理。

对于的询问 $A_i$，我们分讨一下：

* 若 $A_i$ 被标记，直接输出 $-1$；
* 反之，若 $A_i$ 未被标记，若 $A_i=A_{i-1}$，输出 $A_{i-1}$ 的对应要优化。

	否则，从 $A_i$ 开始，寻找下一个被标记的数，这个过程依次枚举每一个数即可，容易证明这个过程是 $\mathcal O(10^7)$ 的，即每次执行这个操作时的操作区间两两不相交。

整体复杂度 $\mathcal O(10^7\log 10^7)$，当然因为多个优化实际不可能这么多。

## 代码

赛时代码。

```cpp
#include<cstdio>
#include<algorithm>
const int Sub1=1e4;
const int lmt=2e5+5;
const int maxt=2e5+5;
const int limit=1e7+5;
const int maxn=1e7+10;
struct _{
	int d,u,ans;
	bool operator<(const _ q)const{
		return u<q.u;
	}
};
int T,x;
_ a[maxt];
bool vis[maxn],vis2[maxn];
inline bool cmp(_ x,_ y){ return x.d<y.d; }
void read(int&x){
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
		x=x*10+ch-'0', ch=getchar();
	return;
}
void print(int x){
	if(x>=10) print(x/10);
	putchar(x%10+'0');
	return;
}
int main(){
	read(T);
	for(int i=1;i<=limit;++i){
		if(vis2[i]) continue;
		x=i; while(x){
			if(x%10==7){
				vis[i]=1;
				break;
			}
			x/=10;
		}
		if(vis[i])
		for(int j=i;j<=limit;j+=i)
			vis[j]=vis2[j]=1;
	}
	for(int i=1;i<=T;++i){
		read(a[i].u);
		a[i].d=i;
	}
	std::sort(a+1,a+T+1);
	for(int i=1;i<=T;++i){
		if(vis[a[i].u]) a[i].ans=-1;
		else if(a[i].u==a[i-1].u)
			a[i].ans=a[i-1].ans;
		else {
			for(int j=a[i].u+1;j<=limit;++j){
				if(!vis[j]){
					a[i].ans=j;
					break;
				}
			}
		}
	}
	std::sort(a+1,a+T+1,cmp);
	for(int i=1;i<=T;++i){
		if(a[i].ans==-1) puts("-1");
		else print(a[i].ans), putchar('\n');
	}
	return 0;
}
```

---

## 作者：Mortis_Vampire (赞：10)

以此题解来纪念我的第一次 NOIP。

考场心理记录：

这道题该怎么做呢？

从对方报出的数开始，向后进行枚举，对于每个数分解出它的每个因数，依次判断它的每个因数是否合法吗？

似乎是不可行的。

于是我想到只要这个数不合法，那它的倍数也一定不合法。

那这不就是个筛吗。

于是直接掏出埃筛祭天。

也就是说，从 1 开始枚举到 $10^7$ ，判断其是否合法，若不合法，筛除它从 1 到 $10^7$ 间的所有倍数，同时若它已被标记（筛除），直接跳过。

然后就过了。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
bool pd(int x)//判断数的十进制表示中是否有7
{
    while(x){
        if(x%10==7)return true;
        x/=10;
    }
    return false;
}
int ton[10000005],ans[10000005];
inline int rd()//快读
{
    register int x=0;
    register char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c<='9'&&c>='0')
    x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x;
}
int main()
{
    for(int i=1;i<=10000000;i++)//类埃氏筛
    {
        if(ton[i])continue;
        if(pd(i)){
            for(int j=1;j<=10000000/i;j++)
            ton[i*j]=1;
        }
    }
    int last=10000001;//10000001是第一个大于等于10000000的符合条件的数
    for(int i=10000000;i>=1;i--){//存储答案
        ans[i]=last;
        if(!ton[i])last=i;
    }
    int T=rd(),n;
    while(T--){//O(1)回答
        n=rd();
        if(ton[n]){
            puts("-1");continue;
        }
        printf("%d\n",ans[n]);
    }
    return 0;
}
```


---

## 作者：Terraria (赞：4)

## $\text{Introduction}$

$T$ 组数据，每组数据给定 $n$，求 $n$ 的因数中是否有含有 $7$ 的数，如果是则输出 $-1$，否则输出下一个因子中不含有 $7$ 的数。

## $\text{Solution}$

我们知道，对于 $1 \sim 6$，都是合法的。

对于 $7$，显然不合法。那么我们可以：

**将所有 $7$ 的倍数打上标记，记为不合法。**

接下来 $8 \sim 13$ 都是合法的。

到了 $14$，我们发现这个数在筛 $7$ 的倍数时已经被筛过了，所以不予考虑。

$15 \sim 16$ 也都是合法的。

到了 $17$，我们发现这个数还没有被筛过。但是由于 $17$ 中有一位数字为 $7$，所以我们要将 $17$ 筛去，同时将 $17$ 的倍数都筛去。

以此类推，我们得到了某个数是否合法。

现在考虑怎么做回答。

对于本身就不合法的数字，我们可以直接输出 $-1$。

对于合法的数字，我们想快速找到下一个满足要求的数字。在这之前我们可以预处理一个 $ans$ 数组，$ans_i$ 表示若 $i$ 合法，则下一个报的数字。显然我们可以从 $10^7$ 开始倒着扫一遍前面求一个数是否合法的数组，然后对于一个合法的数，将其作为下一个合法的数的答案。

但是这样会遇到一个问题：最大的合法的数字，其答案超过了 $10^7$。

经过测试，这个答案是 $10^7+1$，所以还需要一定判断。

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
bool f[10000002];
int ans[10000002];
int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x;
}
void write(int x){
	if(x<0) x=~x+1,putchar('-');
	if(x>=10) write(x/10);
	putchar(x%10+'0');
}
int main(){
	//freopen("number.in","r",stdin);
	//freopen("number.out","w",stdout);
	T=read(); 
	f[1]=0;
	for(int i=2;i<=10000000;i++){
		if(f[i]==1) continue;
		int now=i;
		while(now){
			int k=now%10;
			now/=10;
			if(k==7) f[i]=1;
		}
		if(f[i]==1){
			for(int j=i;j<=10000000;j+=i) f[j]=1;
		}
	}
	int lst=10000001;//注意这里的初始化！
    //lst存的是大于i的最小的合法的数
	for(int i=10000000;i>=1;i--){
		if(f[i]==0){
			ans[i]=lst;//这时候i的下一个数应该是lst
			lst=i;//同时更小一点的数应该报的数就是i
			continue;
		}
	}
	while(T--){
		int x;
		cin>>x;
		if(f[x]==1){//记得先判断是否合法！
			write(-1);
			putchar('\n');
		}
		else{
			write(ans[x]);
			putchar('\n');
		}
	}
}
/*
4
6
33
69
300

5
90
99
106
114
169
*/
```

讲个笑话，我差点因为 `int` 不敢开 $10^7$ 的数组（

好在是看到了 $512\text{MB}$ 的内存而没有挂分（

---

## 作者：2020kanade (赞：4)

# **UPD on 2021-12-03：修改了部分变量名和一些细节并进行重新提交**

**前排：由于考场电脑太拉，误判了复杂度，导致本来能AC的题让我加了个剪枝，100->70，估计这波是要省二AFO了**

这题......个人感觉想要AC挺不容易的，可以评个绿（也可能是我太蒻了？）

直接考虑正解（打表的话，我们队有个50分的，据说还有个老哥打表打了18G？）：

设 $N=1e7$ 

首先考虑数位里带7的数：直接扫一遍判断即可：复杂度 ${O(N(sizeofnumber))}$ ，位数最大是 $7$ ，可以看作常数。

接下来，去标记掉以这些数为因数的数。
直接一个一个膜之类的暴力判断肯定是不行的，对于这种依靠因数的筛数（实际上算是筛数），可以想到埃氏筛。笔者接下来的做法可以看作是埃氏筛的一种变形：

话都说到这里了，不少人脑子里估计码已经出来了：双重循环，外层的$i$查数，如果$i$没被标记就进二重循环，设一个 $j$ 从 $2$ 开始每次加1，把 ${i \times j}$ 标记出来，边界是 ${i \times j  \le N}$ 。

这里，笔者再加一些小优化：

建立一个数组（最好不要用vector），在第一轮标记带 $7$ 的数的时候把标记的数顺便存进去；之后，外层循环的 $i$ 改为从 $1$ 开始的该数组的下标，相应的，标记的数是 $j$ 与那个数组中下标为 $i$ 的数的乘积；再建一个bool数组，标记数的时候同时在这个新数组中进行标记；外层循环如果下标为 $i$ 的数在新数组中被标记，直接跳过。

以上优化经笔者测试，在代码其他部分（详见最后）相同的情况下，洛谷的民间数据在C++14 O2下可以 4.63s->2.99s（官方数据6.27s->3.68s）。

这一部分的时间复杂度小于 $O(N {\log} N+N)$ （证明许多神犇已给出，故此处略去）， $1e7$ 跑进1s没问题。

接下来考虑处理查询：

很容易想出这样的算法：对于询问的合法性，直接看标记；若合法，二分查找第一个合法的最大值。

这种写法时间复杂度最坏是接近 ${O(T {\log} N)}$ 的，加上前面的预处理，想不炸都难。（实际上因为被标记为不合法的数占大多数加上常数较低，这种写法可以通过。）

实际上，$O(N {\log} N)$ 复杂度对于 $1e7$ 来说已经比较吃力，再加上常数等因素，应该会想到：单个查询需要 $O(1)$ 处理才能过。

笔者这里的写法有一点贪心的思想，下面直接放：


首先建立一个查询表，然后从表的尾部开始遍历

维护“前一个合法的数”，初始为 $1e7+1$ ；

若当前的数不合法，直接在查询表当前数的下标中存入-1；否则，存入“前一个合法的数”，并将它改为当前数。

正确性显然，故证明略去。

算上前面的预处理，总时间复杂度大概略小于 ${O(N+N {\log} N+T)}$ （预处理进行了剪枝），理论上可以通过（反正洛谷民间数据过了（UPD：官方数据也过了），考场上我查询写了二分导致错判复杂度然后......）

[洛谷上的官方数据AC](https://www.luogu.com.cn/record/64170498)

贴上代码（非考场代码，freopen是为了测试）：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 10000000+1000
using namespace std;
LL ccfNB,cnta,cntb,idx=N-999;
bool ccfTQL[N],ccfORZ[N];
LL ans[N],ccfSTO[N];
inline LL qread()
{
    LL a=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f*=-1;ch=getchar();}
    while(ch>='0' && ch<='9') {a=a*10+ch-'0';ch=getchar();}
    return a*f;
}
inline void CCFNB(LL x)
{
    char w[128];LL cnt=0;
    if(x<0) putchar('-'),x*=-1;
    while(x) {w[cnt++]=(x%10)+'0';x/=10;}
    while(cnt--) putchar(w[cnt]);putchar('\n');
}
int main()
{
    freopen("number4.in","r",stdin);freopen("number.ans","w",stdout);
    for(LL i=1;i<=N-1;i++)
    {
        LL tmp=i;
        while(tmp){if(tmp%10==7) {ccfTQL[i]=1,ccfSTO[++cnta]=i;break;}tmp/=10;}
    }
    for(LL i=1;i<=cnta;i++) if(!ccfORZ[ccfSTO[i]])
    {
        for(LL j=2;j*ccfSTO[i]<=N-1;j++) ccfTQL[ccfSTO[i]*j]=1,ccfORZ[ccfSTO[i]*j]=1;
    }
    for(auto i=N-1000;i>=1;i--)
    {
        if(ccfTQL[i]) ans[i]=-1;
        else ans[i]=idx,idx=i;
    }
    ccfNB=qread();
    while(ccfNB--) CCFNB(ans[qread()]);
    return 0;
}
```

这道题最大的“坑点”笔者感觉不在于筛数，而是查询。

笔者认为，这道题极好地考察了选手“以空间换时间”的能力，评个绿......应该不过分吧？（然后评黄了......可能只是笔者太菜了而已）

---

## 作者：a1co0av5ce5az1cz0ap_ (赞：2)

题意简述：定义一个数 $x$ 要被跳过为 $x$ 包含 `7` 或者 $x$ 是要被跳过的数的倍数，现在每次给出一个数，求这个数之后最小的不被跳过的数。如果给出的数要被跳过，输出 `-1`。
# 一、预处理
因为我们每次 $x\leq 10^7$ ，所以我们可以事先预处理，把每一个数是否要被跳过算出来，不过最好多算几个。
```cpp
const int MAXN=1e7+1e4;//似乎加的多了，不过不影响
bool tiao[MAXN+5];
void init(){
	for(int i=1;i<=MAXN;i++){
		if(tiao[i]) continue;//如果已经确定是要跳过的，就没有必要继续算了（肯定是倍数，那么一个数的倍数的倍数必然是这个数的倍数，所以后面都被淘汰过了）
		if(i%10==7||i/10%10==7||i/100%10==7||i/1000%10==7||i/10000%10==7||i/100000%10==7||
		i/1000000%10==7||i%7==0){//判断数位里包含7或者是7的倍数
			tiao[i]=1;//那很明显是
			for(int j=i+i;j<=MAXN;j+=i) tiao[j]=1;//所有倍数全设成跳过
		}
	}
}
```
之后我们每次输入就从 $x+1$ 开始一直找（肯定是有的），只要遇到可以的就立刻停止并输出。
然后，喜提 70 on luogu！
# 二、优化
假设我有一个很恐怖的数据：
```
200000
6999999
6999999
.....
6999999(每一个x都是6999999)
```
那么，每一次都大概需要花费 $10^6$，也就是说总共需要计算 $2\times 10^{11}$ 次！
很明显会超时，于是我们用一个数组来记录下来算出的结果：
```cpp
int memorySearch[MAXN+5];
```
然后对于`main`函数，也要改动：
```cpp
int main(){
	init();//初始化
	int t,n;
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		if(tiao[n]) cout<<-1<<endl;//直接不行了
		else{
			if(memorySearch[n]){//已经记录过了直接输出
				cout<<memorySearch[n]<<endl;continue;
			}
			for(int i=n+1;;i++){//之后就是正常做法
				if(!tiao[i]){
					cout<<(memorySearch[n]=i)<<endl;break;//这里就是既赋值又输出
				}
			}
		}
	}
	return 0;
}
```
最后，整体代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN=1e7+1e4;
bool tiao[MAXN+5];
int memorySearch[MAXN+5];
void init(){
	for(int i=1;i<=MAXN;i++){
		if(tiao[i]) continue;
		if(i%10==7||i/10%10==7||i/100%10==7||i/1000%10==7||i/10000%10==7||i/100000%10==7||
		i/1000000%10==7||i%7==0){
			tiao[i]=1;
			for(int j=i+i;j<=MAXN;j+=i) tiao[j]=1;
		}
	}
}
int main(){
	freopen("number.in","r",stdin);
	freopen("number.out","w",stdout);
	ios::sync_with_stdio(0);
	init();
	int t,n;
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		if(tiao[n]) cout<<-1<<endl;
		else{
			if(memorySearch[n]){
				cout<<memorySearch[n]<<endl;continue;
			}
			for(int i=n+1;;i++){
				if(!tiao[i]){
					cout<<(memorySearch[n]=i)<<endl;break;
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：DeusExMachina (赞：2)

### 题意梗概

给定 $T$ 个数，若每次给定的数 $x$ 不在含有 $7$ 的数及其所有倍数的集合中，输出集合内第一个比 $x$ 大的数，否则输出 $-1$。

### 可能需要了解的内容

埃氏筛，欧拉筛。利用了类似的思想。

### 思路

处理掉含有 $7$ 的，每次寻找到后标记出它及其所有倍数，最后一键查询。

一个奇奇怪怪的优化魔改埃氏筛。我优化的地方是排除了含有数字 $7$ 的 $7$ 的倍数，例如说 $70$ 和 $77$，减少了筛查次数。

魔改欧拉筛会比我现在这个快，但是考场上写的不是。我其他的倍数优化没有写，也不会写，不然就完全可以说是魔改欧拉筛了。

#### 关于代码中参数 `p` 和 `__sLimit__`

`__sLimit__` 大可以 `define` 成 $10000000$，但是我考场上为了方便调试，逐步开大数据，使用了一个参数。

`p` 表示我搜索到的数，需要实时改变，于是用了地址。但是我后来发现完全可以定义成全局变量。

#### 关于代码中函数 `mark`

`voidmark (int n, int __sLimit__)`。

用于标记所有 $n$ 的倍数的。

#### 关于代码中函数 `i100` 至 `i10m`

`void i100 (int &p, int __sLimit__)`  
……  
`void i10m (int &p, int __sLimit__)`

$1k$ 为 $10^3$。$1m$ 为 $10^6$。

我将从 $1$ 到 $10^7$ 中对于符合条件的数的搜索分成了很多函数。主函数调用函数 `i10m ()`，`i10m ()` 内调用函数 `i1m ()`……一直到调用 `i100m ()`。

`i100 ()` 搜索了每 $100$ 个数中的第 $7, 17, 27, 37, 47, 57, 67$，$70 \sim 79$ 和 $87, 97$。

`i1k ()` 在每 $1000$ 个数中进行了 $9$ 次调用 `i100 ()`，在 $700\sim799$ 范围做了特殊处理。

以下函数以此类推。

### 代码

题解代码删除了部分考试时写的无意义注释，改正了考试中犯下的错误并标明出来了。并将只有我自己能看懂的注释进行了调整。

```
// Author: user/361833 | Luogu
#include <bits/stdc++.h>
using namespace std;

bool u[10000500]; // used
int P[10000002]; // Point
int T, x; // 题目里有
// 范围 10000000，但是在 u 中故意开大一些，多搜了一点。

void mark (int n, int __sLimit__) {
  // 这个是用来筛所有 n 的倍数的。

  if (n % 7 == 0 && n != 7) return; // 简单小优化

  int w = n + n; // 从 n * 2 筛起
  while (w <= __sLimit__) {
    u[w] = 0;
    w += n;
  }
}

void i100 (int &p, int __sLimit__) {
  // 每 100 位的搜索
  p -= 3;
  for (int i = 0; i <= 6; i++) {
    // 7, 17, 27, 37, 47, 57, 67
    p += 10;
    u[p] = 0;
    mark (p, __sLimit__);
  }
  p += 3;
  for (int i = 0; i <= 9; i++) {
    // 70 ~ 79
    u[p] = 0;
    mark (p, __sLimit__);
    p += 1;
  }
  p -= 3;
  for (int i = 8; i <= 9; i++) {
    // 87, 97
    p += 10;
    u[p] = 0;
    mark (p, __sLimit__);
  }
  p += 3;
}
void i1k (int &p, int __sLimit__) {
  // 每 1000 位
  for (int i = 0; i <= 6; i++) {
    // 7 ~ 697
    i100 (p, __sLimit__);
  }
  for (int i = 0; i <= 99; i++) {
    // 700 ~ 799
    u[p] = 0;
    mark (p, __sLimit__);
    p += 1;
  }
  for (int i = 8; i <= 9; i++) {
    // 807 ~ 997
    i100 (p, __sLimit__);
  }
}
void i10k (int &p, int __sLimit__) {
  // 每 10000 位
  for (int i = 0; i <= 6; i++) {
    // 7 ~ 6997
    i1k (p, __sLimit__);
  }
  for (int i = 0; i <= 999; i++) {
    // 7000 ~ 7999
    u[p] = 0;
    mark (p, __sLimit__);
    p += 1;
  }
  for (int i = 8; i <= 9; i++) {
    // 8007 ~ 9997
    i1k (p, __sLimit__);
  }
}
void i100k (int &p, int __sLimit__) {
  // 每 100000 位
  for (int i = 0; i <= 6; i++) {
    // 7 ~ 69997
    i10k (p, __sLimit__);
  }
  for (int i = 0; i <= 9999; i++) {
    // 70000 ~ 79999
    u[p] = 0;
    mark (p, __sLimit__);
    p += 1;
  }
  for (int i = 8; i <= 9; i++) {
    // 80007 ~ 99997
    i10k (p, __sLimit__);
  }
}
void i1m (int &p, int __sLimit__) {
  // 每 1000000 位
  for (int i = 0; i <= 6; i++) {
    // 7 ~ 699997
    i100k (p, __sLimit__);
  }
  for (int i = 0; i <= 99999; i++) {
    // 700000 ~ 799999
    u[p] = 0;
    mark (p, __sLimit__);
    p += 1;
  }
  for (int i = 8; i <= 9; i++) {
    // 800007 ~ 999997
    i100k (p, __sLimit__);
  }
}
void i10m (int &p, int __sLimit__) {
  // 每 10000000 位 (max)
  for (int i = 0; i <= 6; i++) {
    // 7 ~ 6999997
    i1m (p, __sLimit__);
  }
  for (int i = 0; i <= 999999; i++) {
    // 7000000 ~ 7999999
    u[p] = 0;
    mark (p, __sLimit__);
    p += 1;
  }
  for (int i = 8; i <= 9; i++) {
    // 8000007 ~ 9999997
    i1m (p, __sLimit__);
  }
}

void init (int __sLimit__) {
  // 初始化函数。
  memset (u, 1, sizeof (u)); // 1 为能报， 0 为不能报

  // 7 17 27 ……
  int POINT = 0;
  i10m (POINT, __sLimit__ + 500);
  POINT = 1;
  for (int i = 2; i <= __sLimit__ + 500; i++) {
    if (u[i] == 1) {
      P[POINT] = i;
      POINT = i;
      if (POINT > __sLimit__) break; // 我考试时 10 pts 就是在这里的 __sLimit__ 后面多打了六个字符：“ + 500” 导致数组越界。
    } else P[POINT] = -1;
  }
}


int main () {
  init (10000000);
  scanf ("%d", &T);
  while (T--) {
    scanf ("%d", &x);
    if (u[x]) printf ("%d\n", P[x]);
    else printf ("-1\n");
  }
  return 0;
}
```

---

## 作者：Shunpower (赞：2)

## 思路

考虑先确定一个数可不可以被报出来。

考虑递归定义布尔函数 $f(x)$ 表示 $x$ 不可以报出来，那么：

$$
\begin{cases}
1, &f(x\bmod 10)\land x\bmod 10\neq 7
\\
1, &\forall y|x\land f(y)
\\
0,&other
\end{cases}
$$

读者可以思考一下第一个条件的正确性。

那么现在我们要算所有 $x$ 在 $10^7$ 的 $f(x)$，怎么算呢？

首先这个东西不用搞递归，容易发现 $f(x\bmod 10)$ 或者 $\forall y|x$ 中的 $f(y)$ 会比 $x$ 先算到，所以可以直接 $O(n)$ 递推。

然后呢？然后为了标记对于每个 $y$ 的所有倍数，我们要搞一个均摊 $\log n$ 的循环去标记。对于任意一个 $i$，若 $vis_i=0\land f(i)$，那么就要把 $i$ 的倍数 $j(j\geqslant1)$ 标记为 $vis_j=1$。

这一部分做完之后，我们已经用 $n\log n$ 的时间复杂度算出了任意一个数是否可行。那怎么处理下一个数要报多少呢？

考虑递推，因为 $vis_i$ 被预处理出来表示这个数可不可行，所以若 $x_i$ 表示 $i$ 的下一个可报出数，那么：

$$
\begin{cases}
x_i=x_{i+1},&vis_{i+1}=0
\\x_i=i+1,&vis_{i+1}=1
\end{cases}
$$

直接从前往后递推即可。

## 代码

先 $n\log n$ 处理 $vis_i$，像在思路中提到的一样：

```
for(int i=1;i<=n;i++){
	if(cannot[i/10]||i%10==7){
		cannot[i]=1;
	}
	if(cannot[i]&&!vis[i]){
		vis[i]=1;
		for(int j=i+i;j<=n;j+=i){
			vis[j]=1;
		}
	}
}
```

这里的 $n$ 取 $10^7+1$。下同。

然后像思路中所述的 $O(n)$ 递推即可：

```
for(int i=n;i>=1;i--){
	if(vis[i+1]){
		ans[i]=ans[i+1];
	}
	else{
		ans[i]=i+1;
	}
}
```

最后答案都被存进 $ans$ 里面了，对于每个询问，输出对应的 $ans$。当然若对于每个询问，对应的 $vis$ 是 $1$ 的话就要输出 $-1$ 了。

---

## 作者：打程序的咸鱼 (赞：1)

## 前言

于是我就愉快的 AC 了 。

希望审核能给我过了这篇题解 。

## 题目

[题目传送门](https://www.luogu.com.cn/problem/P7960)

## 正文

题目大意是数位中含有 7 的数不能报出 ， 并且它的倍数也不能报出 。 （ 7 也是数位中含有 7 的数 ）

所以我们要枚举出不能报出的数：

```cpp
void init()
{
	for(int i=1;i<=maxn;i++)
	{
		if(retire[i]) continue;
		if(i%10==7||i/10%10==7||i/100%10==7||i/1000%10==7||i/10000%10==7||i/100000%10==7||i/1000000%10==7||i/10000000%10==7)
		{
			retire[i]=1;
			for(int j=i+i;j<=maxn;j+=i)
			{
				retire[j]=1;
			}
		}
	}
}
```

预处理没了，接下来就好做了。

判断这个数是不是能报出的，如果不能，输出 -1 。 如果能 ， 就往后找可输出的数，然后输出。

但是 ， 如果给你一组数据 ：

```
100000
699999
699999
699999
699999
699999
…
699999
//有 100000 个 6999999
```
那么肯定超时，所以我们要用到记忆化数组 。

```cpp
long long find_sum[10010005];
```
它可以将当前数要输出的数记忆下来 ， 等到又输入同样的数时 ， 直接输出 。

## AC code：（有大量注释帮助理解）
```cpp
#include<cstdio>
using namespace std;
inline long long read()//快读 
{
	long long s=0,f=1;
	char a = getchar();
	while(a<'0'||a>'9')
	{
		if(a=='-') 
		{
			f=-1; 
			a=getchar();
		}
	}
	while(a <= '9' && a >= '0') s = s * 10 + a - '0', a = getchar();
	return s * f;
}
const long long maxn=1e7+1e4;//有些情况需报出比题目数据大的数，这些数也要处理 
long long n,retire[maxn+5],AFO;
long long find_sum[maxn+5];//记忆化 
void init()//枚举不可报出的数 
{
	for(int i=1;i<=maxn;i++)
	{
		if(retire[i]) continue;//已经处理过了，跳过 
		if(i%10==7||i/10%10==7||i/100%10==7||i/1000%10==7||i/10000%10==7||i/100000%10==7||i/1000000%10==7||i/10000000%10==7)//判断数中有没有7 
		{
			retire[i]=1;//处理当前数 
			for(int j=i+i;j<=maxn;j+=i)
			{
				retire[j]=1;//将它的倍数也处理了 
			}
		}
	}
}
int main()
{
	init(); 
	n=read();
	while(n--)
	{
		AFO=read(); 
		if(retire[AFO]) printf("-1\n");//如果它不可报出 
		else
		{
			if(find_sum[AFO])//如果它报出过，直接输出应报出的数 
			{
				printf("%d\n",find_sum[AFO]);
			}
			else
			{
				int JC=AFO+1;//不能报出当前数 
				while(retire[JC])//查找下一个可报出的数 
				{
					JC++;
				}
				find_sum[AFO]=JC;//记忆化 
				printf("%d\n",find_sum[AFO]);
			}
		}
	}
}
```
### 最后希望这篇题解能帮到屏幕前的你，但是不要抄袭哦！

---

## 作者：Liynw (赞：1)

考场上打玄学复杂度还没处理 $10^7+1$ 的屑只得了 $70$ 分。

***

首先，注意到所有**包含 7 或者这些数的倍数**都不可以报。那么我们可以利用一个类似于埃氏筛的东西来筛出这些不能报的数。

### 什么是埃筛

埃氏筛法本来是用来找质数的一种质数筛法。

我们知道，一个质数只有 $1$ 和它本身两个因数，所以，我们可以通过任意两个不为 $1$ 的数相乘得到一个合数。

我们开一个数组 $b$，$b_i$ 代表 $i$ 是否为合数。从 $2$ 开始筛，如果此时 $b_i=0$，就说明这个数不能通过任意两个不为 $1$ 的数相乘得到，它是一个质数。

如果 $b_i=1$，说明这是一个合数。我们知道，任何一个数一定有至少一个因子是质数，所以每个数都可以通过让任意一个数和质数相乘得到。用合数再去与别的数相乘会浪费时间，所以我们需要直接跳过下面的步骤。

此时我们拿到了一个质数 $i$，然后我们开始遍历 $2\times i,3\times i,\ldots$，这些全部都是合数，所以把它们全部标记为合数，直到超出筛的范围。

代码很简单，大概长这样：

```cpp
void Prime() {
	for(int i = 2; i * i <= n; i++) {
		if(f[i])
        	continue;
		for(int j = 2 * i; j <= n; j += i)
        	f[j] = 1;
	}
	return;
}
```

时间复杂度大概是 $O(n\log \log n)$。

***

### 怎么做这道题

因为任何含有 $7$ 的数字或其倍数都不可以报出，所以我们可以通过乘积来筛掉所有不合法的数，这很明显是一道埃筛的变形。那么我们该如何做这道题呢？

我们还是开一个 $b$ 数组记录所有的数是否能报，其中 $b_i=0$ 代表 $i$ 可以报，$b_i=1$ 则不能。

首先我们要知道怎么判断一个数 $x$ 是否含有 $7$。这个很简单，只需要重复以下两个步骤：

1. 计算 $x/10$ 的余数是否等于 $7$，如果有，说明此数含有 $7$；
1. $x$ 除以 $10$。

用这样的方法可以遍历到 $x$ 每个数位上的数。

```cpp
// 判断这个数能不能报，若 x 中有 7，返回 1 
inline bool pan7(int x) {
	int qwq;
	while(x) {
		qwq = x % 10;
		if(qwq == 7)
			return 1;
		x /= 10;
	}
	return 0;
}
```

每次筛到一个不能报的数，因为其倍数也不能报，所以我们把它乘以不同的数，把这些数也标记为不能报。期间我们需要保证不筛到 $10^7+1$ 外面去。代码长这样：

```cpp
inline void prime() {
	for(int i = 1; i <= n; i++) {
		if(pan7(i)) {
			b[i] = 1;
			for(int j = 1; j <= n; j++) {
				int qwq = i * j;
				if(qwq > n)
					break;
				b[qwq] = 1;
			}
		}
	}
	return;
}
```

时间复杂度 $O(n \log \log n)$。

接着我们已经知道了所有能报的的数，此时我们只需要从大到小遍历 $10^7+1\sim 1$ 的所有数，拿一个变量存当前遍历到的最小能报的数字，每次到一个数，这个变量里存的值就是它报了之后能报的下一个数字，把这个数存在 $ans$ 数组里面。

这样的预处理可以避免查询一个一个跳导致的玄学复杂度。

时间复杂度 $O(n)$。

然后我们就可以实现 $O(1)$ 询问。

***

### 一个坑

题目数据范围是 $10^7$，为什么需要筛到 $10^7+1$ 呢？

因为可能询问的就是 $10^7$，而它的下一个数是 $10^7+1$。

这个坑卡掉了许许多多悲伤的 OIers。

***

### Code

```cpp
#include <cstdio>
#include <cctype>

const int maxn = (int) 1e7 + 5;
const int n = maxn - 4;

int t, q, tot, g[maxn], ans[maxn];
bool b[maxn];
// b[x] = 1 说明 x 不能被选

// 若 x中有 7，返回 1 
inline bool pan7(int x) {
	int qwq;
	while(x) {
		qwq = x % 10;
		if(qwq == 7)
			return 1;
		x /= 10;
	}
	return 0;
}

inline void prime() {
	for(int i = 1; i <= n; i++) {
		if(pan7(i)) {
			b[i] = 1;
			for(int j = 1; j <= n; j++) {
				int qwq = i * j;
				if(qwq > n)
					break;
				b[qwq] = 1;
			}
		}
	}
	return;
}

// 快读快写
inline int read() {
    int x = 0, w = 0;
	char ch = 0;
    while(!isdigit(ch)) {
		w |= ch == '-';
		ch = getchar();
	}
    while(isdigit(ch)) {
    	x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
    return w ? -x : x;
}

inline void write(int x) {
    if(x < 0) putchar('-'), x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int main() {
	// freopen("number.in", "r", stdin);
	// freopen("number.out", "w", stdout);
	prime();
	int Ans = (int) 1e7 + 1; // 必须 +1
	for(int i = n; i; i--) {
		ans[i] = Ans;
		if(!b[i])
			Ans = i;
	}
	t = read();
	while(t--) {
		q = read();
		write(b[q] ? -1 : ans[q]);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：ztytql (赞：1)

## 题目背景
给定 $T$ 组询问，每组包含一个数 $x$ ,如果 $x$ 在数列 num 中，输出数列中的下一个数，如果不存在，输出 $-1$ .

对数列 num 的定义为：

1. 数列是严格递增的。
2. $7$ 的倍数不在数列中。
3. 数字中各位含有 $7$ 或因数各位数字中含有 $7$ 的数不在数列中。
4. 其他的正整数都在数列中。

## Solution:
本题我采用了预处理 + 二分查找的方法来做，具体为：

首先，建立一个长度为 $10^7$ 的 bool 类型的数组，先把 $7$ 的倍数筛掉，再利用类似于埃筛（其实可以欧拉筛）的方法筛掉数字中含有 $7$ 的数的倍数。

其次，建立一个长度同样为 $10^7$ 的 int 类型的数组（其实用不到那么多），将刚刚 bool 数组的合法数据存储进去，方便之后二分。

最后，如果输入的数据存在于 int 类型的数组内，二分查找大于它的最小合法数据，否则输出 $-1$ .

其中预处理的复杂度约为 $\Theta (n \log\log n)$ $(n=10^7)$ , 判断复杂度为 $\Theta (T \log x)$ , 可以通过本题。

实测民间数据最慢 $142ms$,最快 $90ms$ , 官方数据最慢 $150ms$
。
## Code:
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int maxn=10000000;
int n,x,p=1;
int num[8000010];
bool a[maxn];

//判断数字中是否含有 7
bool is_n(int n){
	while (n){
		if (n%10 == 7)
			return true;
		n/=10;
	}
	return false;
}

//预处理埃筛
void in_num(void){
	for (int i=7;i<=maxn;i+=7)
		a[i]=true;//先筛 7 的倍数
	for (int i=1;i<=maxn;i++){
		if (a[i] == false && i%7!=0)
			if (is_n(i) == true)
				for (int j=i;j<=maxn;j+=i)
					a[j]=true;
	}//筛数字中含有 7 的数的倍数
}

//将预处理的结果存放在 num 数组中
void in_snum(void){
	for (int i=1;i<=maxn;i++)
		if (a[i] == false)
			num[p++]=i;
}

int main(){
	//freopen("number.in","r",stdin);
	//freopen("number.out","w",stdout);
	memset(a,false,sizeof(a));//初始化
	scanf("%d",&n);
    //预处理
	in_num();
	in_snum();
    
	for (int i=1;i<=n;i++){
		scanf("%d",&x);
		if (a[x] == true) printf("-1\n");
		else printf("%d\n",num[upper_bound(num,num+p,x)-num]);//二分查找
	}
    return 0;
}
```

## 注意事项：
- 函数 $upper\_bound()$ 返回的是一个地址，需减去首地址 $(num)$ 得到下标，再进行输出。

- 在 $in\_num()$ 函数中，先筛 $7$ 的倍数，原因是如果不写，在之后的循环中一起判断的时候，每次遇到 $7$ 的倍数是都要筛一遍它的倍数，写的话可能会优化一点。

---

## 作者：王江睿 (赞：1)

#### 本文将分为三部分解释该题。

一、思路：

 $Step$ $1$：
 - 目的：预先筛出带有七的数及其倍数。
 - 实现：在初始化为全假的 `bool` 型数组 `pp` 中将这样的数（形式化地表述为 `bool pan(x)`为 `true` ）的正整数倍作为下标的数组元素置为真。

 $Step$ $2$：
- 目的：降低时间复杂度。
- 实现：对于第一步处理过的，跳过；对于 `pp` 数组在之前（$Step$ $1$）置为真的，跳过；对于前二者都不的，用`qq`数组存储它的后继元素（对于这个前二者都不的序列），以达到方便查询的目的（时间复杂度降至$\Theta(1)$）。

二、实现：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline unsigned int cinn(){
    register unsigned int x=0;
    register unsigned char y;
    do y=getchar(); while(y<'0'||y>'9');
    while(y<='9'&&y>='0'){
        x=x*10+y-'0';
        y=getchar();
    }return x;
}inline bool pan(register int n){
    do if((n-n/10*10)==7) return 1; while(n/=10);
    return 0;
}int main(){
    freopen("number.in","r",stdin);
    freopen("number.out","w",stdout);
    register bool pp[10000400]={0};
    register int i=10000400,j=0,frok=0,k=cinn()+1,qq[10000400],m;
    memset(qq,-1,sizeof(qq));
     while(--i&&++j){
         if(pp[j]) continue;
         else if(pan(j)){
             register int p=0;
             while((p+=j)&&p<=10000400)
                 pp[p]=1;
         }else frok=qq[frok]=j;
     }while(--k)
         printf("%d\n",qq[cinn()]);
    return 0;
}
```
三、注解：
- `int cinn()` : 快速读入一个 `unsigned int` 型整数。
    - 实际上，应用中仅可读入 `signed int` 的非负整数部分。
- `int frok` : 存储第二步中当前元素的前导元素（对于$Step$ $2$ 中“前二者都不的序列”）。
- $10000400$ ：等于 $10^7+400$，$400$是考虑到输入元素最大时严格等于$10^7$的后果。

2021.11.20

---

## 作者：hensier (赞：0)

仔细看一眼题目，发现每次询问都只给出一个数，因此可以想到需要预处理。那么怎么进行预处理呢？

一开始可能会想到这样一种算法：把 $[1,\max\{x\}]$ 中每一个含有 $7$ 的整数存入队列中，在数的前面、后面补上任意数位，具体实现可以使用搜索。但仔细一想，发现这样重复的状态多、效率极低，同时写起来也比较麻烦，不可行。

既然**枚举出所有不能报出的整数**不行，那我们能不能**从所有的整数中**找到不能报出的整数呢？

要想找到这样的整数，我们可以在一个足够大的整数范围之内进行判断。具体地，对于每个待判断的整数，先看是否含有数位 $7$。若含有，则对该整数在区间范围内的所有整数倍进行覆盖。因此可以写出这样的初步代码：

```cpp
bool check(int x)
{
    while(x)
    {
        if(x%10==7)return true;
        x/=10;
    }
    return false;
}
void init(int N) // N 表示枚举整数的上限
{
    for(int i=2;i<=N;++i)
        for(int j=1;i*j<=N;++j) // 覆盖该整数的所有正整数倍
            flag[i*j]=true; // flag[i] 为真表示该数不能被报出
}
```

这样我们便可以在 $\mathcal O(N^2 \lg N)$ 的复杂度内找出所有不能被报出的数。

对于询问，我们可以 $\mathcal O(N)$ 预处理比每个能被报出的整数大的第一个不能被报出的整数，再单次 $\mathcal O(1)$ 询问。当然，也可以将预处理之后的数据直接进行存储，然后在询问时临时进行二分，单次询问复杂度为 $\mathcal O(\log_2{\text{len}})$（$\text{len}$ 表示区间范围内能报出的整数的数量）。

但是，询问整数最大值在 $10^7$ 数量级下，肯定会超时。不难发现，每次覆盖的复杂度为 $\mathcal O(N)$。但如果当前枚举到的整数已经被覆盖到，那么它的倍数也一定已经被覆盖过了。因此对于已经覆盖到的整数，不再进行覆盖：

```cpp
void init(int N)
{
    for(int i=2;i<=N;++i)
    {
        if(flag[i]||!check(i))continue;
        for(int j=1;i*j<=N;++j)flag[i*j]=true;
    }
}
```

接着我们需要考虑 $N$ 的取值大小。由于 $10^7$ 本身可以被报出的，因此需要找到大于该数且不能被报出的最小整数。经过试验可知为 $10^7+1$。因此取 $N=10^7+1$ 即可。

该部分的代码乍一看像埃氏筛，但实际上与埃氏筛的复杂度并不相同，而且比较难证。不过，我们可以通过一个更为直观的方法证明该算法不会超时：

当 $N$ 取 $10^7+1$ 时，经过试验可知，筛选过程中不需要继续向后覆盖的整数个数为 $923655$。

也就是说对于其中 $923655$ 个整数，只需进行一次覆盖操作；而剩余的无需覆盖。

单次覆盖操作的复杂度取决于 $N$ 和当前整数的大小。设当前整数为 $i$，则单次覆盖的期望复杂度为 $\mathcal O(\dfrac{N}{i})$。

那么总覆盖的复杂度的常数在最坏情况下等于 $\sum_{i=1}^{923655} \dfrac{10^7+1}{i} \approx 143133115 \approx 1.4 \times 10^8$，可以保证不超时。实际上，需要被覆盖的不可能只集中在前面。由于最坏情况的效率都可以保证，因此这样的做法显然是可以通过的。

因此我们可以得到采用这种方法的两种代码：

单次 $\mathcal O(1)$ 询问：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,a[10000101];
bool flag[10000101];
bool check(int x)
{
    while(x)
    {
        if(x%10==7)return true;
        x/=10;
    }
    return false;
}
void init(int N)
{
    for(int i=2;i<=N;++i)
    {
        if(flag[i]||!check(i))continue;
        for(int j=1;i*j<=N;++j)flag[i*j]=true;
    }
    for(int i=1,t=1;i<=N;++i)
    {
        if(!flag[i])
        {
            a[t]=i;
            t=i;
        }
    }
}
namespace IO
{
    char buf[1<<21],*p1=buf,*p2=buf,obuf[1<<21],*p3=obuf;
    char gc()
    {
        if(p1==p2)
        {
            p1=buf;
            p2=buf+fread(buf,1,1<<21,stdin);
        }
        return p1==p2?EOF:*p1++;
    }
    template<typename T>void read(T &x)
    {
        x=0;
        char ch=gc();
        while(!isdigit(ch))ch=gc();
        while(isdigit(ch))
        {
            x=(x<<3)+(x<<1)+(ch^48);
            ch=gc();
        }
    }
    void pc(char c)
    {
        if(p3-obuf<(1<<21))*p3++=c;
        else
        {
            fwrite(obuf,p3-obuf,1,stdout);
            p3=obuf;
            *p3++=c;
        }
    }
    template<typename T>void write(T x)
    {
        if(x>9)write(x/10);
        pc(x%10+48);
    }
}using namespace IO;
int main()
{
    init(10000001);
    read(T);
    for(int i=1,x;i<=T;++i)
    {
        read(x);
        if(flag[x])
        {
            pc('-');
            pc('1');
        }
        else write(a[x]);
        pc('\n');
    }
    fwrite(obuf,p3-obuf,1,stdout);
    return 0;
}
```

每次在 $\mathcal O(\log_2{\text{len}})$ 的复杂度内通过二分进行询问：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,len,a[800001];
bool flag[10001001];
bool check(int x)
{
    while(x)
    {
        if(x%10==7)return true;
        x/=10;
    }
    return false;
}
void init(int N)
{
    for(int i=2;i<=N;++i)
    {
        if(flag[i]||!check(i))continue;
        for(int j=1;i*j<=N;++j)flag[i*j]=true;
    }
    for(int i=1;i<=N;++i)
    {
        if(flag[i])continue;
        a[++len]=i;
    }
}
int binary(int l,int r,int x)
{
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(a[mid]>x)r=mid-1;
        else l=mid+1;
    }
    return a[l];
}
namespace IO
{
    char buf[1<<21],*p1=buf,*p2=buf,obuf[1<<21],*p3=obuf;
    char gc()
    {
        if(p1==p2)
        {
            p1=buf;
            p2=buf+fread(buf,1,1<<21,stdin);
        }
        return p1==p2?EOF:*p1++;
    }
    template<typename T>void read(T &x)
    {
        x=0;
        char ch=gc();
        while(!isdigit(ch))ch=gc();
        while(isdigit(ch))
        {
            x=(x<<3)+(x<<1)+(ch^48);
            ch=gc();
        }
    }
    void pc(char c)
    {
        if(p3-obuf<(1<<21))*p3++=c;
        else
        {
            fwrite(obuf,p3-obuf,1,stdout);
            p3=obuf;
            *p3++=c;
        }
    }
    template<typename T>void write(T x)
    {
        if(x>9)write(x/10);
        pc(x%10+48);
    }
}using namespace IO;
int main()
{
    init(10000001);
    read(T);
    for(int i=1,x;i<=T;++i)
    {
        read(x);
        if(flag[x])
        {
            pc('-');
            pc('1');
        }
        else write(binary(1,len,x));
        pc('\n');
    }
    fwrite(obuf,p3-obuf,1,stdout);
    return 0;
}
```

---


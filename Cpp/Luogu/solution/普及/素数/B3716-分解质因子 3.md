# 分解质因子 3

## 题目描述

给定一个正整数 $n$，设 $n = p_1 \times p_2 \times \dots p_k$，其中 $p_i$ 均为质数，对 $1 \leq i < k$，$p_i \leq p_{i + 1}$。

可以证明，序列 $p_i$ 是唯一的。

对每个给定的 $n$，请你求出 $p_1, p_2, \dots p_k$。

为了避免输出过大，请你输出 $p_1, p_2, \dots p_k$ 的**按位异或和**。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq T \leq 10^6$，$2 \leq n \leq 10^8$。

### 提示

请注意大量数据读入输出对程序效率造成的影响，选择合适的 IO 方式，避免超时。

## 样例 #1

### 输入

```
2
3
9```

### 输出

```
3
0```

# 题解

## 作者：EurekaStriker (赞：30)

## 一道预处理就行的题


------------
这道题一看感觉很简单，实际上正常的暴力找过不去，因为有这句话：**对于全部的测试点，保证 $1 \leq T \leq 5 \times 10^5$，$2 \leq n \leq 10^8$**  


数据既然这么大，那么第一时间想到的肯定是预处理了啊。我们使用一个欧拉筛，把所有的质数都先筛出来，再去做就会节省很多时间了。不会的小伙伴可以先做这道题：[线性筛质数](https://www.luogu.com.cn/problem/P3383)。

要注意的是：这道题在筛的时候可以将每一个合数都标记上它是从哪里得到这个标记的，这样每一个需要找的数就可以直接跳回去，不需要质因数分解了。具体实现也很简单，只需要将打标记的这一句话
```
v[prime[j]*i]=1;
```
改为
```
v[prime[j]*i]=prime[j];
```
就可以知道它是哪来的了。



------------
下面是完整代码
```
#include<bits/stdc++.h>
using namespace std;
int v[100000010],prime[5770000],cnt,t,n;
int main()
{
	for(int i=2;i<=100000000;i++)
	{
		if(!v[i])
			prime[++cnt]=i;
		for(int j=1;j<=cnt&&(long long)prime[j]*i<=100000000;j++)
		{
			v[prime[j]*i]=prime[j];//标记它是从哪里来的部分
			if(!(i%prime[j]))
				break;
		}
	}//欧拉筛预处理
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		int ans=0;
		if(v[n]==0)
		{
			printf("%d\n",n);
			continue;
		}//如果是质数就直接输出
		while(1)
		{
			if(!v[n])
			{
				ans^=n;
				break;
			}
			ans^=v[n];
			n/=v[n];
		}//不是就从前往后找，每一次都异或一下那个质因数，直到找到一个质数
		printf("%d\n",ans);
	}
    return 0;
}
```
### 完结撒花！
注；萌新的第一篇题解，求管理大大给过啊

---

## 作者：一扶苏一 (赞：18)

# B3716 分解质因子 3

## Analysis

考虑一个数 $n$ 的质因子只有 $O(\log n)$ 个。在分解质因子时，如果知道了每个数的最小质因子，则可以通过一路除掉最小质因子完成分解。容易想到在线性筛的同时求出每个数的最小质因子。

**引理**：在欧拉筛时，被 $i \times p$（其中 $p$ 是质数）筛掉的合数 $k$ 的最小质因子就是 $p$。

**证明**：容易注意到 $i$ 中不含小于 $p$ 的质因子（反证法，假设 $q \mid i$ 且 $q < p$，则当枚举到质数 $q$ 时，$i \bmod q = 0$ 成立，`break` 条件成立，则不会枚举到 $p$，于是 $k$ 不是被 $i \times p$ 筛掉的）。而 $k = i \times p$，于是 $p$ 就是 $k$ 的最小质因子。

于是在欧拉筛时维护出最小质因子，把 $n$ 不断除当前的最小质因子即可完成质因子分解。

预处理复杂度 $O(n)$，每次分解不会有无效试除，复杂度 $O(\mathrm d (n))$，于是总时间复杂度 $O(n + T \mathrm d(n))$，其中 $\mathrm d(n)$ 表示 $n$ 的质因子个数，不会超过 $\log_2 n$。

## Code

```cpp
#include <bitset>
#include <vector>
#include <iostream>
#include <algorithm>

const int maxn = 100000008;

std::vector<int> prm, pre;  // pre is the min-factor array.
bool np[maxn];

void getPrime(const int N = 100000000) {
  pre.resize(N + 1);
  for (int i = 2; i <= N; ++i) {
    if (!np[i]) {
      prm.push_back(i); pre[i] = i;
    }
    for (auto p : prm) if (i * p <= N) {
      int k = i * p;
      np[k] = true;
      pre[k] = p;
      if (i % p == 0) break;
    } else break;
  }
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  getPrime();
  int T, n;
  for (std::cin >> T; T; --T) {
    std::cin >> n;
    int ans = 0;
    while (n != 1) {
      ans ^= pre[n];
      n /= pre[n];
    }
    std::cout << ans << '\n';
  }
}
```

---


# [蓝桥杯 2025 国 B] 互质藏卡

## 题目描述

小蓝整理着阁楼上的旧物，偶然发现了一个落满灰尘的卡片箱。打开箱子，里面整齐地摆放着 17600 张卡片，每张卡片上都写有一个数字，恰好包含了从 1 到 17600 的所有正整数。

儿时的他热衷于收集各种卡牌，数量之多令人咋舌。如今，再次翻阅这些尘封的记忆，小蓝不禁感慨万千。他想起收藏家前辈的箴言：“收藏的魅力在于精粹，而非数量”。于是，他决定从这些卡牌中选取 $2025$ 张，组成一套“互质藏卡”。

“互质藏卡”的特点在于：任意两张卡片上的数字之间互质，即它们的最大公约数恒为 $1$。现在，请你帮小蓝计算，共有多少种不同的选取方案，使得选出的 $2025$ 张卡片满足“互质藏卡”的条件。由于答案可能很大，你只需给出其对 $10^9 + 7$ 取余后的结果即可。

注意：两个选取方案被认为是不同的，当且仅当它们所包含的数字集合不完全相同。即，若存在至少一个数字出现在其中一个集合但不出现在另一个集合中，则这两个方案被视为不同。

# 题解

## 作者：Sunrise_up (赞：10)

## 思路

我们发现这个 $17600$ 似乎有些不合规律，我们惊奇的发现：这里刚好有 $2024$ 个质数！

那我们要这个 $2025$ 个数互质，肯定是这样的：

假设 $p_i$ 为第 $i$ 个质数，$k_i$ 为符合的正整数，使得 $p_i^{k_i}\le 17600$，则这些数为：$1,p_1^{k_1},p_2^{k_2},p_3^{k_3},\dots,p_{2024}^{k_{2024}}$。

我们只需求出前 $2024$ 个质数，并求出其最大的 $k_i$ 即可。

答案即为：

$$k_1\times k_2\times k_3\times\dots\times k_{2024}  \mod (10^9+7)$$

你可以使用编程，但是这里我就用数学解法了。

由于 $17600$ 以内有 $2024$ 个质数，其中小于等于 $\sqrt{17600} \approx 132.66$ 的质数有 $32$ 个，其余 $1992$ 个质数的平方均大于 $17600$（故 $k_i = 1$）。

计算前 $32$ 个质数的幂次上限：

$p=2:\ 2^{14} = 16384 \leq 17600$，故 $k_1=14$。

$p=3:\ 3^8 = 6561 \leq 17600$，故 $k_2=8$。

$p=5:\ 5^6 = 15625 \leq 17600$，故 $k_3=6$。

$p=7:7^5 = 16807 \leq 17600$，故 $k_4=5$。

$p=11:\ 11^4 = 14641 \leq 17600$，故 $k_5=4$。

$p=13,17,19,23:\ 13^2,17^2,19^2,23^2\leq 17600$，故 $k_6=k_7=k_8=k_9=3$。

其余 $23$ 个 $\leq 132$ 的质数：$p_i^2\leq17600$， 但是 $p_i^3>17600$，其中 $i\in(10,32)$，故 $k_{10} \sim k_{32}=2$。

计算乘积并取模：前 $9$ 个质数的 $k$ 乘积为 $14 \times 8 \times 6 \times 5 \times 4 \times 3 \times 3 \times 3 \times 3 = 1088640$，后 $23$ 个质数的 $k$ 均为 $2$，故总乘积为 $1088640 \times 2^{23} \mod (10^9+7)$。

$$\begin{align*}
&1088640 \times 2^{23} \mod (10^9+7) \\
=&1088640 \times 8388608 \mod 1000000007 \\
=&9132174213120 \mod 1000000007 \\
=&174149196
\end{align*}$$

答案即为 $174149196$。


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<174149196;
    return 0;
}
```

如果有用的话，请点个赞吧 qwq！

---

## 作者：mahiro_zcy (赞：5)

由于 $\left[1, 17600\right]$ 上有且仅有 $2024$ 个质数，所以，这 $2025$ 张卡片必然是：其中一张是 $1$，剩下的分别为这 $2024$ 个质数的**正整数**次方，且不超过 $17600$. 

记这些质数是 $p_1, p_2, \cdots, p_{2024}$，对于每个 $p_i$，设有 $f_i$ 个**正整数** $k$ 使得 $p_i^k \leq 17600$，那么答案就是
$$
\prod_{i=1}^{2024} f_i \equiv 174149196 \pmod{10^9 + 7}
$$
可由下面的代码计算.

```cpp
#include <bits/stdc++.h>

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

using i128 = __int128;
using u128 = unsigned __int128;

template <typename T>
std::tuple<T, T, T> exgcd(const T& a, const T& b) {
    if (b == T(0)) {
        return {a, T(1), T(0)};
    }
    auto [g, x, y] = exgcd(b, a % b);
    return {g, y, x - a / b * y};
}

template <long long mod>
class ModInt {
    static_assert(mod >= 1LL, "The modulus must be a positive integer.");
private:
    long long value;
public:
    ModInt() : value(0LL) {}

    ModInt(const ModInt& v) : value(v.value) {}

    template <typename T>
    ModInt(const T& v): value(((long long)(v % mod) + mod) % mod) {}

    explicit operator long long() const {
        return value;
    }

    long long get_value() const {
        return value;
    }

    static long long get_mod() {
        return mod;
    }

    ModInt inv() const {
        auto [g, x, y] = exgcd<long long>(value, mod);
        // 可以证明 -mod < x && x < mod
        if (g != 1LL) {
            throw std::runtime_error("The modular inverse does not exist.");
        }
        ModInt res;
        res.value = x;
        if (res.value < 0LL) {
            res.value += mod;
        }
        return res;
    }

    template <typename V>
    ModInt pow(V b) const {
        long long a = ((b >= V(0)) ? value : inv().value);
        ModInt res;
        res.value = ((mod >= 2LL) ? 1LL : 0LL);
        while (b != V(0)) {
            if (b % V(2) != V(0)) {
                res.value = res.value * a % mod;
            }
            a = a * a % mod;
            b = b / V(2);
        }
        return res;
    }

    ModInt& operator+=(const ModInt& b) {
        value += b.value;
        if (value >= mod) {
            value -= mod;
        }
        return *this;
    }

    ModInt& operator-=(const ModInt& b) {
        value -= b.value;
        if (value < 0LL) {
            value += mod;
        }
        return *this;
    }

    ModInt& operator*=(const ModInt& b) {
        value *= b.value;
        value %= mod;
        return *this;
    }

    ModInt& operator/=(const ModInt& b) {
        value *= b.inv().value;
        value %= mod;
        return *this;
    }

    ModInt& operator=(const ModInt& b) {
        value = b.value;
        return *this;
    }

    ModInt operator+() const {
        return *this;
    }

    ModInt operator-() const {
        ModInt res;
        res.value = -value;
        if (res.value < 0LL) {
            res.value += mod;
        }
        return res;
    }

    ModInt& operator++() {
        ++value;
        if (value >= mod) {
            value -= mod;
        }
        return *this;
    }

    ModInt operator++(int) {
        ModInt temp(*this);
        ++value;
        if (value >= mod) {
            value -= mod;
        }
        return temp;
    }

    ModInt& operator--() {
        --value;
        if (value < 0LL) {
            value += mod;
        }
        return *this;
    }

    ModInt operator--(int) {
        ModInt temp(*this);
        --value;
        if (value < 0LL) {
            value += mod;
        }
        return temp;
    }

    friend ModInt operator+(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value + b.value;
        if (res.value >= mod) {
            res.value -= mod;
        }
        return res;
    }

    friend ModInt operator-(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value - b.value;
        if (res.value < 0LL) {
            res.value += mod;
        }
        return res; 
    }

    friend ModInt operator*(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value * b.value % mod;
        return res;
    }

    friend ModInt operator/(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value * b.inv().value % mod;
        return res;
    }

    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) {
        os << x.value;
        return os;
    }

    friend std::istream& operator>>(std::istream& is, ModInt& x) {
        if (is >> x.value) {
            x.value = (x.value % mod + mod) % mod;
        }
        return is;
    }
};

using Z = ModInt<1'000'000'007LL>;

std::vector<int> prime, minp;

int sieve(int M) {
    minp.resize(M + 1);
    for (int i = 2; i <= M; i++) {
        if (!minp[i]) {
            minp[i] = i;
            prime.push_back(i);
        }
        for (int j : prime) {
            if (j > minp[i] || j > M / i) {
                break;
            }
            minp[i * j] = j;
        }
    }
    return 0;
}

int v_ = sieve(17600);

void solve() {
    assert(prime.size() == 2024);
    Z ans = 1;
    for (int p : prime) {
        int cnt = 0;
        int now = p;
        while (now <= 17600) {
            cnt += 1;
            now *= p;
        }
        ans *= cnt;
    }
    std::cout << ans << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t = 1;
    // std::cin >> t;

    while (t--) {
        solve();
    }

    return 0;
}
```

---

## 作者：wjh27465 (赞：3)

# 题解：P12831 [蓝桥杯 2025 国 B] 互质藏卡
## 分析
首先把这份代码在本地上跑一遍，看一下 $1$ 到 $17600$ 中共有多少个素数。

```cpp
#include <bits/stdc++.h>
using namespace std;

bool f(int x)
{
    for(int i=2;i<=sqrt(x);i++)
    {
        if(x%i==0)
            return 0;
    }
    return 1;
}

int main()
{
    int s=0;
    for(int i=2;i<=17600;i++)
    {
        if(f(i))
        {
            cout<<i<<" ";
            s++;
        }
    }
    cout<<endl<<s;
    return 0;
}
```
得出共有 $2024$ 个素数，分别是：
[素数](https://www.luogu.com.cn/paste/nfe92e1i)  
这 $2024$ 个素数加上 $1$ 之后正好是 $2025$ 个，符合题意。  
每一个素数都可以变为自身的几次方，这样还能保证它们互素，但不能超过 $17600$。根据组合数步步相乘，答案就是每个素数的次方数相乘。接下来继续枚举：
$$
2^{14}=16384 \le 17600
$$
$$
3^8=6561 \le 17600
$$
$$
5^6=15625 \le 17600
$$
$$
7^5=16807 \le 17600
$$
$$
11^4=14641 \le 17600
$$
$13、17、19、23$ 都取三次方。  
$29$ 到 $131$ 都取平方，共 $23$ 个。  
剩余的素数都取一次方，对答案没有影响。  
所以最终答案为
$$
14 \times 8 \times 6 \times 5 \times 4 \times 3^4 \times 2^{23}=9132174213120
$$
将 $9132174213120$ 对 $10^9+7$ 取余，得到`174149196`。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    cout<<174149196;
    return 0;
}
```

---

## 作者：litangzheng (赞：0)

### 思路：  

计算一下，我们发现 $17600$ 内的质数只有 $2024$ 个，也就是**互质藏卡中必须要选 $1$。**（不然如果不选 $1$，那么在选完所有的质数后，就必定要选一个合数，明显 $17600$ 内的合数一定与这些质数不互质，就一定不合法。）   
选完 $1$ 之后，我们还剩 $2024$ 张卡片要选，可以怎么选呢？由上面质数的个数，我们又注意到，**每个质数的整数次幂都必须要选，且只能选一次。**  
由于不同质数的正整数次幂集合不相交，且只能选一个，所以我们可以利用乘法原理计算。  
设对于小于 $17600$ 的质数 $p_i$（$1 \le i \le 2024$），存在 $k_i$ 使 $p_i^{k_i} \le 17600 \text{且} p_i^{k_i+1} > 17600$，则答案为：  
$$\prod^{2024}_{i=1} k_i$$  
答案在对 $10^9+7$ 取模后为 $174149196$。

---


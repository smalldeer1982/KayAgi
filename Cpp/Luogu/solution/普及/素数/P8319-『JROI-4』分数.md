# 『JROI-4』分数

## 题目背景

万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(1/10000) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/10000)(1/5000) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/5000)(1/2500) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/2500)(1/1250) $\to$ 万人血书 [KHIN](https://www.luogu.com.cn/user/236807) 完成[女装 flag](https://www.luogu.com.cn/paste/pdsav61j)(2/1250)(1/625) $\cdots$ 以此类推，在可以约分的情况下，“万人血书”很快就能完成。[](KH粉丝群群号：808706015)

## 题目描述

“$x$ 人血书”的过程可以看成一个函数 $f(x)$：

有一个 $\frac{0}{x}$ 的分数。重复以下步骤直到这个分数为 $1$：

1. 分子 $+1$。
2. 如果这个分数可以约分，约分到最简形式。

现在小 D 给了你 $T$ 组数据，每组数据都是给定 $n$，求在 $1\le x\le n$ 的情况下 $f(x)$ 的最大操作次数。

但是他太菜了，不会，你能帮帮他吗？

## 说明/提示

### 样例解释

$f(1)=1,f(2)=2,f(3)=3,f(4)=3,f(5)=5$。

我也想把更大的 $f(x)$ 列出来，但是地方不够了。

### 数据范围


对于全部数据，$1\le T\le 5\times 10^5$，$1\le n\le 2\times 10^6$。

Subtask 中没填的部分表示和全部数据的范围一样。

| 子任务编号 | $T$ 的范围 | $n$ 的范围 | 特殊性质 |分值|
| -----------: | -----------: | -----------: | -----------: |-----------: |
| Subtask $1$ | $T\le 3$ | $n\le 10$ |  |$10$|
| Subtask $2$ | $T\le 5$ | $n\le 10^3$ |  |$30$|
| Subtask $3$ |  |  | $n$ 为质数|$10$|
| Subtask $4$  |  | $n\le 5\times 10^5$ |  |$20$|
| Subtask $5$  |  |  |  |$30$|


## 样例 #1

### 输入

```
5
1
2
5
8
114514```

### 输出

```
1
2
5
7
114493
```

# 题解

## 作者：CarroT1212 (赞：16)

~~P8318 的题解大家可能都在抢着写，咱就不争了写个 P8319 吧~~

------------

感觉这道题的题意写得不是很清晰，补充一下内容：

分子加上 1 之后，如果这个分数可以约分，一定要约分到最简形式；

约分不算操作次数；

现在小 D 给了你 $T$ 组数据，每组数据都是给定 $n$，求 $\max(f(1),f(2),\cdots ,f(n))$。

------------

直接模拟每组数据显然是不可行的，会 T 飞。

那我们想一个问题：什么时候 $f(x)$ 的操作次数会最大？

来，看一下 $f(12)$ 的操作过程：

$\dfrac{0}{12}\rightarrow\dfrac{1}{12}\rightarrow(\dfrac{2}{12})\,\dfrac{1}{6}\rightarrow(\dfrac{2}{6})\,\dfrac{1}{3}\rightarrow\dfrac{2}{3}\rightarrow(\dfrac{3}{3})\,1$

共 5 步。

而 $f(11)$ 呢？

$\dfrac{0}{11}\rightarrow\dfrac{1}{11}\rightarrow\dfrac{2}{11}\rightarrow\dfrac{3}{11}\rightarrow\cdots\rightarrow(\dfrac{11}{11})\,1$

共 11 步。

$f(10)$ 呢？

$\dfrac{0}{10}\rightarrow\dfrac{1}{10}\rightarrow(\dfrac{2}{10})\,\dfrac{1}{5}\rightarrow\dfrac{2}{5}\rightarrow\dfrac{3}{5}\rightarrow\dfrac{4}{5}\rightarrow(\dfrac{5}{5})\,1$

共 6 步。

不难发现，**约分次数越少，操作次数就越大**。

因为每一次约分，分母都会变小，而分数值增加到 1，也就是分子增加到和分母一样大小的操作次数就会更少。

那什么时候约分次数会最小呢？

答：**分母是质数的时候约分次数最小，即没有任何约分操作，这时 $f(x)$ 的操作次数就会等于分母**。

所以这题就变成了一个素数筛的问题。

我们先跑一遍埃氏筛，然后对于每组数据，找**最大的小于或等于 $n$ 的质数**输出就可以了。特别且显然地，当 $n=1$ 时，答案就为 1。

------------

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
using namespace std;
int t,n;
int flag[2000010];
void init() { //埃氏筛初始化
	for (int a=2;a<=2000000;a++) {
		if (flag[a]) continue;
		for (int b=a+a;b<=2000000;b+=a) flag[b]=1;
	}
}
int main() {
	cin>>t;
	init();
	while (t--) {
		cin>>n;
		for (int a=n;a;a--) { //循环找最大质数
			if (!flag[a]) {
				cout<<a<<endl;
				break;
			}
		}
	}
	return 0;
}
```

------------

题外话：比赛时，我于 18:00:01 交了代码，于是 200pts -> 100pts，rank #400 -> rank #1300……

---

## 作者：Dream_weavers (赞：5)

## 思路

先单看一个数的“操作次数”，例如 $24$（箭头表示增加和约分的过程）：

$\dfrac{0}{24}\rightarrow\dfrac{2}{24}\rightarrow\dfrac{1}{12}\rightarrow\dfrac{2}{12}\rightarrow\dfrac{1}{6}\rightarrow\dfrac{2}{6}\rightarrow\dfrac{1}{3}\rightarrow\dfrac{3}{3}\rightarrow1$

算出 $24$ 的操作次数是 $2+(2-1)+(2-1)+(3-1)$，把 $24$ 分解质因数得到 $24=2\times2\times2\times3$，对比前面可以发现：$x$ 的操作次数是 $x$ 所有质因数和再减一些 $1$。那 $n$ 以内哪个数的操作次数最大？换句话说哪个数的质因数和最大（不考虑 $-1$）？很明显是质数。所以问题就变成了：**求 $n$ 以内最大的质数。**

转换成这个问题就简单了。先用最快的欧拉筛（预处理）把素数筛出来。然后进行用筛出的素数进行区间赋值，例如 $l$ 到 $r$ 之间最大的素数为 $l$，就把区间的数都赋值为 $l$（注意 $1$ 虽然不是素数，但也要赋值为 $1$）。最后进行单次 $O(1)$ 复杂度的查询。


欧拉筛复杂度 $O(2\times10^6)$，查询复杂度 $O(T)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+100;
int book[N],prime[N],mp[N];
int ind;
int t,n;

inline int read(){//快读
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){//快写
    if(x<0){putchar('-');x=-x;}
    if(x>9)write(x/10);
    putchar(x%10+'0');
}

void shai(){
    book[1]=1;
    for(int i=2;i<=N-50;i++){//欧拉筛
        if(!book[i]) prime[++ind]=i;
        for(int j=1;j<=ind&&i*prime[j]<=N-50;j++){
            book[i*prime[j]]=1;
            if(!i%prime[j]) break;
        }
    }
    mp[1]=1;//把1赋值为1
    for(int i=1;i<=ind;i++){//赋值为最大素数
    	int l=prime[i],r=prime[i+1]-1;
    	for(int j=l;j<=r;j++)mp[j]=prime[i];
    }
}
signed main(){
    shai();
    t=read();
    while(t--){//查询
    	n=read();
    	write(mp[n]);//直接输出n以内最大素数
    	puts("");
    }
    return 0;
}
```

---

## 作者：RE_Prince (赞：5)

# P8319 『JROI-4』分数

## 1.题目

[link](https://www.luogu.com.cn/problem/P8319)

## 2.思路

@_zyINF 大佬已经把思路讲得很清楚了，我就不多叙述了。

## 3.优化

其实这才是这篇题解的重点，我们可以在最后查找最大质数时用循环，但还有一种更快的方法—— `upper_bound()` 函数！

[ `upper_bound` 函数用法](https://blog.csdn.net/weixin_45719581/article/details/115324132)

我们在前面再加上一个埃氏筛，代码就写完啦~

因此，此代码时间复杂度为 $\mathcal O(n+logv)$  

注： $v$ 为素数个数。

## 3.code

```cpp
#include<bits/stdc++.h>
#pragma G++ optimize(3)
using namespace std;
int n, m, i, j, k;
const int N = 2 * 1e6 + 9;
int p[N/3]; 
bool a[N];
inline void prime(int x)
{
	for (i = 1; i <= x; i++) a[i] = 1;
	a[1] = 0;
	for (i = 2; i <= x; i++)
	{
		if (a[i]) p[++k] = i;
		for (j = 1; j <= k && i * p[j] <= x; j++)
		{
			a[i * p[j]] = 0;
			if (i % p[j] == 0) break;
		}
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	int T;
	prime(2 * 1e6);
	cin >> T;
	while (T--)
	{
		cin >> n;
		cout << p[upper_bound(p + 1, p + k + 1, n) - p - 1] << endl;
	}
	return 0;
}
```

---

## 作者：Shimotsuki (赞：3)

首先要明确一个重点信息：约分不算在操作次数内。

为了让操作次数最大，那就要保证中间没有约分，即分子在 $1$ 到 $x-1$ 的区间内都要与 $x$ 互质，所以 $x$ 必须是个质数，也就是说，答案是 $n$ 以内的最大质数。

考虑根号枚举判断质数，时间复杂度是 $O(T n \sqrt{n})$，因为 $1 \le T \le 5 \times 10^5,1 \le n \le 2 \times 10^6$，所以该算法无法通过此题。

考虑线性筛，预处理时间复杂度 $O(n)$，总复杂度 $O(T+n)$，可以通过此题。

```cpp
#include<cstdio>

using namespace std;

#define int long long
#define N (int)(2e6+10)

bool isprime[N];
int prime[N];

inline void euler(){
	int cnt=0;
	for(int i=2;i<=N;i++){
		if(!isprime[i])
			prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=N;j++){
			isprime[i*prime[j]]=true;
			if(i%prime[j]==0) break;
		}
	}
}//欧拉筛

signed main(){
	int t,n;
	euler();
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		int ans=0;
		for(int i=n;i>=2;--i){
			if(!isprime[i]){
				ans=i;
				break;
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：lndjy (赞：3)

官方题解

结论：答案是小于等于 $n$ 的最大质数。

质数的 $f(x)=x$，且如果 $x$ 不是质数，则至少约分一次，即 $f(x)\le \lfloor \frac{x}{2} \rfloor$ ，也就是说如果 $ \lfloor \frac{n}{2} \rfloor$ 到 $n$ 有质数，那么满足 $f(x)$ 最大的 $x$ 是质数。[百度质数分布规律可以知道](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515#4)，$ \lfloor \frac{n}{2} \rfloor$ 到 $n$ 一定有质数。这个结论也可以打表证明。

```cpp
#include<iostream>
using namespace std;
const int N=2e6+5;
bool is[N];
int pri[N],ans[N];
void xxs()
{
	for(int i=2;i<=N-5;i++)
	{
		if(!is[i]) pri[++pri[0]]=i;
		for(int j=1;j<=pri[0]&&i*pri[j]<=N-5;j++)
		{
			is[i*pri[j]]=1;
			if(i%pri[j]==0) break;
		}
	}
}
void init()
{
	int now=0;
	for(int i=1;i<=N;i++)
	{
		if(!is[i]) now=i;
		ans[i]=now;
	}
}
int main()
{
	xxs();
	init();
	int T;
	cin>>T;
	while(T--)
	{
		int n;
		cin>>n;
		cout<<ans[n]<<'\n';
	}
	return 0;
}
```


---

## 作者：duchengjun (赞：2)

# 题意

给你一个 $n$，求在 $1\le x\le n$ 中 $f(x)$ 的最大操作次数。

定义 $f(x)$ 为：

有一个 $\dfrac{0}{x}$ 的分数。重复以下步骤直到这个分数为 1：
  
1. 分子 $+1$。

2. 如果这个分数可以约分，约分到最简形式。

# 分析

首先我们可以发现当一个 $\dfrac{0}{x}$ 的分子一次又一次的加时肯定有一次会被约分或者变成 1，且约分后一定会变成形如 $\dfrac{1}{x\div a}$ 的分数。

因为若可以约分就约分到最简形式，所以当第一次有 $x\bmod a=0$ 时就会约分且约分成 $\dfrac{1}{x\div a}$。

那么我们令 $t[x]$ 为 $\dfrac{0}{x}$ 变成 1 的操作次数。

则我们就尝试求出 $x$ 的除一外的最小因数即可，此时状态转移方程就是 $t[x]=t[x\div a]+a-1$，$a$ 为 $x$ 的除一外的最小因数，因为 $t[x]$ 为 $\dfrac{0}{x}$ 变成 1 的操作次数而约分后为 $\dfrac{1}{x\div a}$ 且 $t[x\div a]$ 的意义是 $\dfrac{0}{x\div a}$ 变成 1 的操作次数，多操作了一次，所以要减去 1；但是当 $x$ 是一个质数时，$t[x]=x$，因为 $\dfrac{0}{x}$ 变成 1 的过程中一定不会约分。

例如：

$$t[36]=t[18]+(2-1)=t[9]+(2-1)+(2-1)=t[3]+(3-1)+(2-1)+(2-1)=3+(3-1)+(2-1)+(2-1)=3+3+2+2-3=7$$

但是题目要求的是求出 $1\le x\le n$ 中 $f(x)$ 的最大操作次数，所以取一个 $max$ 即可。

可以 AC，但是时间非常大 4.96s，考虑换方法。

我们令每一个不是质数的 $x$ 都表示成 $p_1^{a_1}\cdot p_2^{a_2}\cdot p_3^{a_3}\cdot …\cdot p_m^{a_m}$，且 $p$ 数组时递增的。

$$t[x]=t[x\div p_1]+(p_1-1)=t[x\div p_1^2]+(p_1-1)+(p_1-1)=……=\sum\limits^m_{i=1}{p_i\cdot a_i}-\sum\limits^{m-1}_{i=1}a_i$$

例如：

$$t[36]=t[2^2\times3^2]=2\times 2+3\times 2-(2+2-1)=4+6-3=7$$

因为我们发现答案都小于等于 小于 $n$ 的最大质数，所以我们只需要求一下即可。

你可以用埃氏筛或者试欧拉筛，我用欧拉筛时间可以到 366ms。

这里只放两个代码，一个是[欧拉筛](https://www.luogu.com.cn/paste/6pxsw3s2)，一个是[普通枚举，再加一个“记忆化”](https://www.luogu.com.cn/paste/29v3mnwq)。



---

## 作者：TheSky233 (赞：2)

## Description

有一个形如 $\dfrac{0}{x}$ 的分数。重复以下步骤直到这个分数为 $1$：

1. 分子 $\gets$ 分子 $+1$。
2. 如果这个分数可以约分，约分到最简形式。

现在小 D 给了你 $T$ 组数据，每组数据都是给定 $n$，求在 $1 \le x \le n$ 的情况下 $f(x)$ 的最大操作次数。

## Solution

### 思路 1：模拟

时间复杂度 $O(Tn^3)$，甚至连样例的 `114514` 都跑不过去。

### 思路 2：素数筛法

我们可以把题意理解成在 $1 \le x \le  n$ 这个区间里，与 $x$ 互质的最大的不超过 $x$ 的数。

因为如果这个数与 $x$ 互质，那么它只有自增至 $x$ 时才会被一次约分掉。

所以对于每个输入的 $n$，从后往前扫一遍，是质数就直接输出。

欧拉筛（线性筛）的时间复杂度为 $O(Tn)$，本题可以 AC。

## Code

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
#include <map>
#include <bitset>
#include <vector>
#include <cstring>
using namespace std;

void read(int &x){
	x=0; int f=1; char ch=getchar();
	while(ch<'0' || ch>'9') f=(ch=='-')?-1:1,ch=getchar();
	while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	x=x*f;
}

void write(int x){
	x==0?putchar('0'):1;
	if(x<0) putchar('-'),x=-x;
	char buf[32]; int cnt(0);
	while(x) buf[++cnt]=x%10+48,x/=10;
	while(cnt) putchar(buf[cnt--]);
}

bitset<100000005> isPrime;
vector<int> Prime;

void Euler(int Siz){
	for(int i=2;i<=Siz;i++){
		if(!isPrime[i]) Prime.push_back(i);
		for(int j=0;j<Prime.size() && i*Prime[j]<=Siz;j++){
			isPrime[i*Prime[j]]=1;
			if(i%Prime[j]==0) break;
		}
	}
}

int n,k,x;

int main(){
	read(k);
	Euler(2000005);
	while(k--){
		read(x);
		for(int i=x;i>=1;i--){
			if(!isPrime[i]){
				write(i);
				break;
			}
		}
		putchar('\n');
	}
	return 0;
}

```

## 卡常技巧

我们注意到，上面这份代码居然跑了 $\tt 1.94s$，太慢了，下面提供几个卡常的技巧。

1. 每次不必筛到题目中给出的 $n$ 的最大值，先存储下来，筛到 $\max\limits^{T}_{i=1} n_i$ 范围即可（优化约 $\tt 600ms$）。
2. 用 `bool` 代替 `std::bitset`，优化约 $\tt 250ms$。
3. $O(n)$ 预处理出每个 $1 \le i \le n$ 所对应的互质的数，然后 $O(1)$ 查询（优化约 $\tt 400ms$）。
4. 快读加上 `fread` 优化，优化约 $\tt 10ms$。

卡常后：$\tt 446ms$。

代码：[Link](https://www.luogu.com.cn/paste/iq6ted4q)。

---

## 作者：D2T1 (赞：2)

# 题解 P8319 『JROI-4』分数

[link](https://www.luogu.com.cn/problem/P8319)

------------

受上场月赛的 B 启发，设 $x$ 的最小因数为 $y$，则血书女装过程为：

$$\displaystyle\frac 0x\to \frac1x\to...\to\frac yx,\frac1{x/y}\to\frac2{x/y}\to...$$

然后 $\frac1{x/y}$ 后面的步骤数就是 $f(x/y)-1$ 了。所以我们可以从 $f(x/y)$ 推出 $f(x)$：

$$
f(x) = 
\begin{cases}
1&if~x=1\\
x&if~x\in\Bbb{P}\\
y+f(x/y)-1&if~x\not\in\Bbb{P}~\&~x\not= 1
\end{cases}
$$

判断质数以及对每个 $x$ 求最小质因子 $y$ 可以用线性筛解决。

```cpp
//LGR-108 B
#include <bits/stdc++.h>
using namespace std;

const int N = 2e6 + 10;
int v[N], prime[N], mindiv[N], ans[N], mx[N];
inline void getf(int n){
	int cnt = 0;
	for(int i = 2; i <= n; ++ i){
		if(!v[i]) prime[++cnt] = i, mindiv[i] = i;
		for(int j = 1; j <= cnt && i * prime[j] <= n; ++ j){
			v[i*prime[j]] = 1;
			mindiv[i*prime[j]] = prime[j];
			if(i%prime[j] == 0) break;
		}
	}
}

int main(){
	int t, n; scanf("%d", &t);
	getf(N-10);
	ans[1] = 1; mx[1] = 1;
	for(int i = 2; i <= N-10; ++ i){
		if(!v[i]) ans[i] = i;
		else ans[i] = mindiv[i] + ans[i/mindiv[i]] - 1;
		mx[i] = max(mx[i-1], ans[i]);
	}
	while(t--){
		scanf("%d", &n);
		printf("%d\n", mx[n]);
	}
	return 0;
}
```

------------

当然，可以很容易发现一个性质：

$$\max_{1\leq i \leq x}\{f(x)\}=\max_{1\leq p \leq x,p\in\Bbb{P}}\{p\}$$

即 $f(x)$ 为 $[1,x]$ 中最大的质数。理解也很容易：质数不会被约分，所以他只能不停地分子 $+1$，因此比合数答案大。

记得特判以下 $f(1)$。

```cpp
//LGR-108 B
#include <bits/stdc++.h>
using namespace std;

const int N = 2e6 + 10;
int v[N], prime[N], mx[N];
inline void getf(int n){
	int cnt = 0;
	for(int i = 2; i <= n; ++ i){
		if(!v[i]) prime[++cnt] = i;
		for(int j = 1; j <= cnt && i * prime[j] <= n; ++ j){
			v[i*prime[j]] = 1;
			if(i%prime[j] == 0) break;
		}
	}
}

int main(){
	int t, n; scanf("%d", &t);
	getf(N-10);
	mx[1] = 1;
	for(int i = 2; i <= N-10; ++ i){
		if(!v[i]) mx[i] = i;
		else mx[i] = mx[i-1];
	}
	while(t--){
		scanf("%d", &n);
		printf("%d\n", mx[n]);
	}
	return 0;
}
```

---

## 作者：Abeeel51 (赞：1)

#### 题意

有一个 $\frac{0}{x}$ 的分数。重复以下步骤直到这个分数为 $1$：
1. 分子 $+1$。
2. 如果这个分数可以约分，约分到最简形式。
#### 题解
理解题意这句话，你就解决了这道题的一半。

如果纯模拟，似乎只能过第二个子任务。

看 $n$ 的范围，只有 $O(n)$ 的时间复杂度带些常数可以过，别的有些悬。

![](https://cdn.luogu.com.cn/upload/image_hosting/b5ene6e6.png)

所以答案就是 $n$ 以内最大的质数。
质数筛考虑[欧拉筛](https://blog.csdn.net/qaqwqaqwq/article/details/123587336?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165146673316782246433779%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165146673316782246433779&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-123587336.142^v9^pc_search_result_control_group,157^v4^new_style&utm_term=%E6%AC%A7%E6%8B%89%E7%AD%9B+%E8%AF%A6%E8%A7%A3&spm=1018.2226.3001.4187)。
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int Prime[2000020];
int V[2000020]={0,1};
bool Vis[100000005];
int OulaPrime(int n){
    n=2000000;
    int tot=0;
    for(int i=2;i<=n;i++){
        if(Vis[i]==0){
            Prime[tot++]=i;
            V[i]=i;
        }else{
            V[i]=V[i-1];
        }
        for(int j=0;j<tot;j++){
            if(i*Prime[j]>n) break;
            Vis[i*Prime[j]]=1;
            if(i%Prime[j]==0) break;
        }
    }
    return tot;
}
int main(){
    int T;
    scanf("%d",&T);
    OulaPrime(1);
    while(T--){
        int n;
        scanf("%d",&n);
        printf("%d\n",V[n]);
    }
    return 0;
}
```


---


# [BCSP-X 2024 12 月初中组] 序列选择

## 题目描述

给定两个长度为 $ n $ 的序列 $ a, b $，找出一个长为 $ n $ 的序列 $ c $，满足对于 $ i = 1, 2, \cdots, n $，有 $ c_i = a_i $ 或 $ c_i = b_i $，使得 $\sum_{i=2}^{n} |c_i - c_{i-1}|$ 最小，你只需要输出这个最小值。

## 说明/提示

### 样例 1 解释
令序列 $ c = [2, 3, 4, 2, 1] $，此时 $\sum_{i=2}^{n} |c_i - c_{i-1}| = 5$，可以证明不存在更小的答案。

### 样例 2

见附件的 `seq/seq2.in` 与 `seq/seq2.ans`。

### 数据范围

- 对于 $20\%$ 的数据，满足 $n\leq 20$。
- 对于 $100\%$ 的数据，满足 $1\leq n\leq 2\times 10^5$，$0\leq |a_i|,|b_i|\leq 10^9$。

## 样例 #1

### 输入

```
5
1 3 4 2 5
2 5 4 2 1```

### 输出

```
5```

# 题解

## 作者：lunjiahao (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/B4163)

[博客园](https://www.cnblogs.com/lunjiahao/p/18726792)**可能**食用更佳

> 给定长度为 $n$ 的序列 $a,b$，指定一个长度为 $n$ 的序列 $c$，钦定 $\forall i \in [1,n] \cap \mathbb Z,c_i=a_i \lor c_i=b_i$，最小化 $\sum_{i=2}^{n} |c_i-c_{i-1}|$。
> 
> $n \leq 2 \times 10^5,|a_i|,|b_i| \leq 10^9$。

考虑 dp，记 $dp_{i,0/1}$ 表示第 $i$ 个数选 $a_i/b_i$ 的最小代价，则：

$$
\begin{aligned}

dp_{i,0} &=
\begin{cases}
0 &,i=1\\
\min \lbrace dp_{i-1,0}+|a_i-a_{i-1}|,dp_{i-1,1}+|a_i-b_{i-1}| \rbrace &,i \geq 2\\
\end{cases}\\

dp_{i,1} &=
\begin{cases}
0 &,i=1\\
\min \lbrace dp_{i-1,0}+|b_i-a_{i-1}|,dp_{i-1,1}+|b_i-b_{i-1}| \rbrace &,i \geq 2\\
\end{cases}\\

\end{aligned}
$$

答案即为 $\min \lbrace dp_{n,0},dp_{n,1} \rbrace$。

代码没什么细节，注意到 $10^5 \times 10^9 = 10^{14} > 2^{31}-1$，故记得开 `long long`。

时间复杂度 $\mathcal O(n)$。

```cpp
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define min(a,b) (a<b?a:b)
using namespace std;
template <typename T>
il void read(T &x)
{
	x=0;int f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	x*=f;
}
template <typename T>
il void write(T x)
{
	if(x<0) putchar('-'),x=~x+1;
	if(x>9) write(x/10);
	putchar(x%10^48);
}
const int N=2e5+5;
int n,a[N],b[N];
ll f[N][2];
int main()
{
	read(n);
	for(int i=1;i<=n;i++) read(a[i]);
	for(int i=1;i<=n;i++) read(b[i]);
	for(int i=2;i<=n;i++)
	{
		f[i][0]=min(f[i-1][0]+abs(a[i]-a[i-1]),f[i-1][1]+abs(a[i]-b[i-1]));
		f[i][1]=min(f[i-1][0]+abs(b[i]-a[i-1]),f[i-1][1]+abs(b[i]-b[i-1]));
	}
	write(min(f[n][0],f[n][1]));
	return 0;
}
```

---

## 作者：oVo_yangxy (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B4163)

被拿捏了。
## 题目描述
直接给你两个长度为 $n$ 的数组 $a$ 和 $b$ 构造一个数组 $c$，$c_i$ 只能在 $a_i$ 和 $b_i$ 中选择一个赋值。赋值后，求出在 $c$ 数组中相邻两数之差的绝对值之和的最小值。
## 思路
输入。

开一个 $dp$ 数组，分为两种情况，一种表示当前值选择 $a_i$ 的两种方案的最小值，一种表示当前值选择 $b_i$ 的两种方案的最小值。注意，在找出最小值的时候一定要加上如果为该种方案对应的前一个数，这样才能找出完全的当前值。

输出最小值。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200005],b[200005],dp[3][200005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=2;i<=n;i++){
		dp[1][i]=min(abs(a[i]-a[i-1])+dp[1][i-1],abs(a[i]-b[i-1])+dp[2][i-1]);
		dp[2][i]=min(abs(b[i]-a[i-1])+dp[1][i-1],abs(b[i]-b[i-1])+dp[2][i-1]);
	}
	cout<<min(dp[1][n],dp[2][n]);
	return 0;
}
```
[被拿捏现状](https://www.luogu.com.cn/record/list?pid=B4163&user=oVo_yangxy&page=1)

~~（给蒟蒻点个赞吧）~~

---

## 作者：superLouis (赞：3)

## 题解：B4163 [BCSP-X 2024 12 月初中组] 序列选择

![](https://cdn.luogu.com.cn/upload/image_hosting/2xr3b1h4.png)

还是我的一个朋友 [@Leo926](https://www.luogu.com.cn/user/1304782) 告诉了我这道题又水又可以写题解，我就快快过来发一篇。

----------
### 1. 解题思路

一眼动态规划水题。直接来说定义：$f_{i,j}$ 表示 $c$ 序列中第 $i$ 位为 $a_i$ $(j=0)$ 或 $b_i$ $(j = 1)$ 时最小的答案。最终答案就是 $\min\{f_{n,0}, f_{n,1}\}$。

现在我们来分析转移方程：

> $$f_{i,0} = \min\{f_{i-1,0} + |a_i - a_{i-1}|, f_{i-1,1} + |a_i - b_{i-1}|\}\\f_{i,1} = \min\{f_{i-1,0} + |b_i - a_{i-1}|, f_{i-1,1} + |b_i - b_{i-1}|\}$$

最后来确定初始条件：$f_{1,0} = f_{1,1} = 0$。

----------
### 2. 代码实现

$O(n)$ 时间复杂度秒掉。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
constexpr int maxn = 2e5 + 10;
int n, a[maxn], b[maxn], f[maxn][2];
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr); cout.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> b[i];
    f[1][0] = f[1][1] = 0;
    for (int i = 2; i <= n; i++) {
        f[i][0] = min(f[i - 1][0] + abs(a[i] - a[i - 1]), f[i - 1][1] + abs(a[i] - b[i - 1]));
        f[i][1] = min(f[i - 1][0] + abs(b[i] - a[i - 1]), f[i - 1][1] + abs(b[i] - b[i - 1]));
    }
    cout << min(f[n][0], f[n][1]) << "\n";
    return 0;
}
```

---

## 作者：bh2013 (赞：3)

---


[题目传送门](https://www.luogu.com.cn/problem/B4163)


---


**题目分析:**

本题的目标是从两个长度为 $n$ 的序列 $a$ 和 $b$ 中构造出一个长度为 $n$ 的序列 $c$，对于每个位置 $i$，$c[i]$ 可以选择等于 $a[i]$ 或者 $b[i]$，我们需要使得 $c$ 序列中相邻元素差值的绝对值之和最小，最后输出这个最小值。

**解题思路:**

我们可以使用动态规划的方法来解决这个问题。定义两个状态数组 $dp1$ 和 $dp2$，其中：

·$dp1[i]$ 表示当 $c[i]$ 选择 $a[i]$ 时，前 $i$ 个元素满足条件的最小相邻元素差值绝对值之和。

·$dp2[i]$ 表示当 $c[i]$ 选择 $b[i]$ 时，前 $i$ 个元素满足条件的最小相邻元素差值绝对值之和。

**状态转移方程如下：**

·当 $c[i]$ 选择 $a[i]$ 时，$c[i-1]$ 可以选择 $a[i-1]$ 或者 $b[i-1]$，我们取这两种情况下的最小值加上 $|a[i] - a[i-1]|$ 或 $|a[i] - b[i-1]|$，即 $dp1[i] = \min(dp1[i-1] + |a[i] - a[i-1]|, dp2[i-1] + |a[i] - b[i-1]|)$。

·当 $c[i]$ 选择 $b[i]$ 时，同理可得 $dp2[i] = \min(dp1[i-1] + |b[i] - a[i-1]|, dp2[i-1] + |b[i] - b[i-1]|)$。
最终的答案就是 $\min(dp1[n-1], dp2[n-1])$。

**代码：**

``` C++ 14
#include <bits/stdc++.h>
#define int long long
using namespace std;

int a[200005], b[200005], dp[200005][2];

signed main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i ++) cin >> a[i];
	for (int i = 1; i <= n; i ++) cin >> b[i];
	dp[2][0] = min(abs(a[2] - a[1]), abs(a[2] - b[1]));
	dp[2][1] = min(abs(b[2] - a[1]), abs(b[2] - b[1]));
	for (int i = 3; i <= n; i ++) {
		dp[i][0] = min(dp[i - 1][0] + abs(a[i] - a[i - 1]), dp[i - 1][1] + abs(a[i] - b[i - 1]));
		dp[i][1] = min(dp[i - 1][0] + abs(b[i] - a[i - 1]), dp[i - 1][1] + abs(b[i] - b[i - 1]));
	}
	cout << min(dp[n][0], dp[n][1]) << endl;
	return 0;
}
```

**复杂度分析:**

·时间复杂度：代码中主要的操作是一个循环，循环次数为 $n-1$，每次循环内的操作时间复杂度为 $O(1)$，因此总的时间复杂度为 $O(n)$。

·空间复杂度：使用了两个长度为 $n$ 的数组 $dp1$ 和 $dp2$ 来保存中间结果，因此空间复杂度为 $O(n)$。

**注意事项:**

·输入的序列长度为 $n$，数组下标从 $0$ 开始，因此最终结果需要取 $dp1[n-1]$ 和 $dp2[n-1]$ 中的最小值。

·代码中使用了 $abs$ 函数来计算绝对值，确保差值为非负数。


---


谢谢大家观看我的题解

---

## 作者：CJR_Rain (赞：2)

### $f$ 的定义：

$f_{i,\ 0}$ 为确定完 $c$ 中前 $i$ 个数的值且 $c_i=a_i$ 时 $\sum_{k=2}^{i}|c_k-c_{k-1}|$ 的最小值，$f_{i,\ 1}$ 为确定完 $c$ 中前 $i$ 个数的值且 $c_i=b_i$ 时 $\sum_{k=2}^{i}|c_k-c_{k-1}|$ 的最小值。

### 状态转移方程：

$f_{i,\ 0}=\min(|a_i-a_{i-1}|+f_{i-1,\ 0},\ |a_i-b_{i-1}|+f_{i-1,\ 1})$。

$f_{i,\ 1}=\min(|b_i-a_{i-1}|+f_{i-1,\ 0},\ |b_i-b_{i-1}|+f_{i-1,\ 1})$。

最后答案为 $\min(f_{n,\ 0},\ f_{n,\ 1})$。

### 滚动数组优化：

注意到 $f_{i,\ 0}$ 和 $f_{i,\ 1}$ 的值只与 $f_{i-1,\ 0}$ 和 $f_{i-1,\ 1}$ 有关，于是代码实现时只要存储 $f_{i-1,\ 0}$ 和 $f_{i-1,\ 1}$ 就行了。这样说不太好理解，请看代码：


```cpp
#include <bits/stdc++.h>

#define IS std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false)
#define OS std::cout.tie(nullptr) -> std::ios::sync_with_stdio(false)

using namespace std;

int n, a[200005], b[200005];
pair <long long, long long> dp;//十年OI一场空，不开long long见祖宗

signed main() {

    IS;
    OS;
    
    cin >> n;

    for(int i = 1; i <= n; ++i) {

        cin >> a[i];
    }

    for(int i = 1; i <= n; ++i) {

        cin >> b[i];
    }

    for(int i = 2; i <= n; ++i) {//注意题目中也是i = 2，这边也得这样写

        pair <long long, long long> last = dp;

        dp.first = min(abs(a[i] - a[i - 1]) + last.first, abs(a[i] - b[i - 1]) + last.second);
        dp.second = min(abs(b[i] - a[i - 1]) + last.first, abs(b[i] - b[i - 1]) + last.second);
    }

    cout << min(dp.first, dp.second);
    
    return 0;
}
```

---

## 作者：xiaobeng_0912 (赞：2)

## $\mathbf{Knowledge}$

1. 动态规划

## $\mathbf{Solution}$

一道动态规划题目。

首先，我们令 $dp_{i,0}$ 为第 $i$ 个数选 $a_i$ 时的最小代价，$dp_{i,1}$ 为第 $i$ 个数选 $b_i$ 时的最小代价。

接着我们开始初始化。我们将 $dp_{1,0}$ 和 $dp_{1,1}$ 初始化为 $0$，这样，简单的初始化就完成了。

最后，有两个转移方程，分别是对应 $dp_{i,0}$ 和 $dp_{i,1}$ 的：

$$dp_{i,0}=\min\{dp_{i-1,0}+|a_i-a_{i-1}|,dp_{i-1,1}+|a_i-b_{i-1}|\}$$
$$dp_{i,1}=\min\{dp_{i-1,0}+|b_i-a_{i-1}|,dp_{i-1,1}+|b_i-b_{i-1}|\}$$

而答案 $ans$ 则表达为：

$$ans=\min\{dp_{n,0},dp_{n,1}\}$$

**最后附上一句：这道题需要开 `long long`！！！**

## $\mathbf{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[200001],b[200001],dp[200001][2];
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&b[i]);
	}
	dp[1][0]=dp[1][1]=0;//初始化
	for(int i=2;i<=n;i++){//转移过程
		dp[i][0]=min(dp[i-1][0]+abs(a[i]-a[i-1]),dp[i-1][1]+abs(a[i]-b[i-1]));
		dp[i][1]=min(dp[i-1][0]+abs(b[i]-a[i-1]),dp[i-1][1]+abs(b[i]-b[i-1]));
	}
	printf("%lld",min(dp[n][0],dp[n][1]));//求出答案
	return 0;
}
```

---

## 作者：lmq308270 (赞：2)

## **思路：动态规划**
显然该题对于$c_i$来说有两种情况要么选$a_i$要么选$b_i$。

所以我们定义 $dp[i][0]$ 为选 $a_i$ 时的最小值 $dp[i][1]$ 为选 $b_i$ 的最小值

所以有以下状态转移方程

 
 $dp[i][0]=\min(dp[i-1][0]+\lvert a[i]-a[i-1] \rvert,dp[i-1][1]+\lvert a[i]-b[i-1] \rvert)$
 
$dp[i][1]=\min(dp[i-1][0]+\lvert b[i]-a[i-1] \rvert,dp[i-1][1]+\lvert b[i]-b[i-1] \rvert)$ 

解释如下：
若当前选 $a[i] $ 那么看前一个选什么

若为 $a[i-1] $ 那么就是 $dp[i-1][0]+\lvert a[i]-a[i-1] \rvert$

若为 $b[i-1]$ 那么就是  $dp[i-1][0]+\lvert a[i]-b[i-1] \rvert$

反过来 $b[i]$ 也是一样的

[传送门](https://www.luogu.com.cn/problem/B4163)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int a[N],b[N]; 
long long dp[N][2];
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];//输入a数组 
	for(int i=1;i<=n;i++)cin>>b[i];//输入b数组 
	dp[2][0]=min(abs(a[2]-a[1]),abs(a[2]-b[1]));//先初始化 
	dp[2][1]=min(abs(b[2]-a[1]),abs(b[2]-b[1]));
	//状态转移 
	for(int i=3;i<=n;i++){
		dp[i][0]=min(dp[i-1][0]+abs(a[i]-a[i-1]),dp[i-1][1]+abs(a[i]-b[i-1]));//若选择a数组 
		dp[i][1]=min(dp[i-1][0]+abs(b[i]-a[i-1]),dp[i-1][1]+abs(b[i]-b[i-1]));//若选择b数组 
	}
	cout<<min(dp[n][0],dp[n][1]);//输出答案
}
```

---

## 作者：piano_pei (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/B4163)

### 题目大意

给定 $a_{[1,n]},b_{[1,n]}$，构造序列 $c_{[1,n]}$，使得$c_i$为$a_i$或$b_i$且$\sum_{i=2}^n|c_i-c_{i-1}|$尽可能小。输出这个最小值。

### 思路

最优化问题，考虑动态规划。

状态定义：$dp_{i,0/1}$ 表示 $c_i$ 取 $a_i/b_i$ 时的最小和。

根据状态定义和题意，分类讨论得出状态转移方程：


1. $c_i$ 取 $a_i$：这种情况计算的是 $dp_{i,0}$ 的值，还有两种子情况，一种是 $c_{i-1}$ 取 $a_{i-1}$，一种是 $c_{i-1}$ 取 $b_{i-1}$，两种情况产生的权值分别是 $dp_{i-1,0}+|a_i-a_{i-1}|$ 和 $dp_{i-1,1}+|a_i-b_{i-1}|$，打擂求得最小值即可。
2. $c_i$ 取 $b_i$：同样有两种子情况，也是 $c_{i-1}$ 分别取 $a_{i-1}$ 和 $b_{i-1}$ 的情况，权值分别为 $dp_{i-1,0}+|b_i-a_{i-1}|$ 和 $dp_{i-1,1}+|b_i-b_{i-1}|$，打擂求得最小值即可。

答案为 $\min\{dp_{n,0},dp_{n,1}\}$。

时间复杂度 $O(n)$，并无什么细节，唯一要注意的就是得开long long。

### $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 10;
int a[N], b[N], n;
ll dp[N][2];
int main()
{
	cin >> n;
	for(int i = 1;i <= n;++i)
		scanf("%d", &a[i]);
	for(int i = 1;i <= n;++i)
		scanf("%d", &b[i]);
	for(int i = 2;i <= n;++i)
	{
		dp[i][0] = min(dp[i - 1][0] + abs(a[i] - a[i - 1]), dp[i - 1][1] + abs(a[i] - b[i - 1]));
		dp[i][1] = min(dp[i - 1][0] + abs(b[i] - a[i - 1]), dp[i - 1][1] + abs(b[i] - b[i - 1]));
	}
	cout << min(dp[n][0], dp[n][1]);
	return 0;
}

```

---

## 作者：Jason2013awa (赞：1)

# B4163 序列选择
## 题目描述

> 给定两个长度为 $ n $ 的序列 $ a, b $，找出一个长为 $ n $ 的序列 $ c $，满足对于 $ i = 1, 2, \cdots, n $，有 $ c_i = a_i $ 或 $ c_i = b_i $，使得 $\sum_{i=2}^{n} |c_i - c_{i-1}|$ 最小，你只需要输出这个最小值。

一道经典的 `dp` 题目，比较简单

既然题目要求我们对于每个下标 $i$ 从 $a,b$ 两个数组中选一个，而每次求第 $i$ 位最小值我们需要上一步的 $dp$ 状态，不妨定义 $dp_{i,0}$ 为第 $i$ 位选 $a_i$ 的最小值，$dp_{i,1}$ 为第 $i$ 位选 $b_i$ 的最小值

设这一步选择的数是 $t$：如果上一步选了 $a_i$，则这一步最小值是 $|a_i-t|$，选了 $b_i$ 则是 $|b_i-t|$。 

则状态转移方程是：



$$
dp_{i,0}=\min\begin{cases}
  dp_{i-1,0}+|a_i-a_{i-1}|\\
  dp_{i-1,1}+|a_i-b_{i-1}|
\end{cases}
$$
(第 $i$ 位选 $a_i$，考虑 $dp_{i-1}$ 选 $a_i$ 或 $b_i$ 两种情况)
$$
dp_{i,1}=\min\begin{cases}
  dp_{i-1,0}+|b_i-a_{i-1}|\\
  dp_{i-1,1}+|b_i-b_{i-1}|
\end{cases}
$$
(第 $i$ 位选 $b_i$，考虑 $dp_{i-1}$ 选 $a_i$ 或 $b_i$ 两种情况)

之后就简单了，答案是 $$\min\begin{cases}
dp_{n,0}\\
dp_{n,1}
\end{cases}$$ 因为需要累加求答案记得开 `long long` 哦 awa 

## AC 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[200005][2];
int a[200005],b[200005]; 
signed main(){
   	int n;
   	cin>>n;
   	for(int i=1;i<=n;i++)cin>>a[i];
   	for(int i=1;i<=n;i++)cin>>b[i];
   	for(int i=2;i<=n;i++){//记得从2开始，如果从1开始用到了a[i-1]会溢出
   		dp[i][0]=min(dp[i-1][0]+abs(a[i]-a[i-1]),dp[i-1][1]+abs(a[i]-b[i-1]));
        dp[i][1]=min(dp[i-1][0]+abs(b[i]-a[i-1]),dp[i-1][1]+abs(b[i]-b[i-1]));
	}
    cout<<min(dp[n][0],dp[n][1]);
	
    return 0;
}
```
[题目传送门](https://www.luogu.com.cn/problem/B4163)


---

感谢观看我的第一篇题解 awa

---

## 作者：qhr2023 (赞：1)

## solution

一道简单 dp。

设 $f_{i, 0/1}$ 表示选完 $c$ 的前 $i$ 个位置，且 $c_i=a_i/c_i=b_i$ 的最小代价。

对于第 $i$ 位的转移可以从第 $i-1$ 位选 $a_{i-1}$ 还是 $b_{i-1}$ 来转移。

转移：$f_{i, 0}=\min(f_{i-1, 0} + \lvert a_i-a_{i-1} \rvert, f_{i-1, 1} + \lvert a_i-b_{i-1} \rvert)$。$f_{i, 1}=\min(f_{i-1, 0} + \lvert b_i-a_{i-1} \rvert, f_{i-1, 1} + \lvert b_i-b_{i-1} \rvert)$。

答案就是 $\min(f_{n, 0}, f_{n, 1})$。发现第一维可以滚掉但是没有必要。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n, a[200005], b[200005], f[200005][2];
int main () {
	cin >> n;
	for (int i=1; i<=n; ++i)
		cin >> a[i];
	for (int i=1; i<=n; ++i)
		cin >> b[i];
	for (int i=2; i<=n; ++i)
		f[i][0]=min(abs(a[i]-a[i-1])+f[i-1][0], abs(a[i]-b[i-1])+f[i-1][1]),
		f[i][1]=min(abs(b[i]-a[i-1])+f[i-1][0], abs(b[i]-b[i-1])+f[i-1][1]);
	cout << min(f[n][0], f[n][1]);
	return 0;
}
```

---

## 作者：xu_jh (赞：0)

### 题目描述

给定两个长度为 $ n $ 的序列 $ a, b $，找出一个长为 $ n $ 的序列 $ c $，满足对于 $ i = 1, 2, \cdots, n $，有 $ c_i = a_i $ 或 $ c_i = b_i $，使得 $\sum_{i=2}^{n} |c_i - c_{i-1}|$ 最小，你只需要输出这个最小值。

---
### 理解题意
大概意思就是给两个序列，每次决策最终序列 $c$ 的位置 $i$ 上的数 $c_i$ 是选 $a_i$ 还是选 $b_i$，使得所有 $\left| c_i - c_{i - 1}\right|$ 相加最小。

---
### 分析复杂度
看到数据范围，暴搜只能拿 20pts，而正解显然是需要 $O(n)$ 或 $O(n \log n)$ 的复杂度的。

因此，我们考虑 $O(n)$ 的 dp。

---
### 设计状态
不妨用 $f[i][0/1]$ 表示选到了第 $i$ 个位置，当前位置要选 $a_i$ 或 $b_i$，所能获得的最小值。

---
### 转移
显然，我们选第 $i$ 个位置，肯定是从第 $i - 1$ 个位置转移过来的。第 $i - 1$ 个位置可以是 $a_{i - 1}$ 也可以是 $b_{i - 1}$，于是，我们分两种情况来看。

第一种情况：从同一序列的 $i - 1$ 转移过来，我们不妨设当前考虑的是 $a_i$，那么我们就可以把 $f[i][0]$ 更新为 $f[i - 1][0] + \text{abs}(a[i] - a[i - 1])$ 。

第二种情况：从不同序列的 $i - 1$ 转移过来，我们还设当前考虑的是 $a_i$，那么我们就可以把 $f[i][0]$ 更新为 $f[i - 1][1] + \text{abs}(a[i] - b[i - 1])$ 。

对以上两种情况取一个 $\min$ ，得到 $f[i][0] = min(f[i - 1][0] + \text{abs}(a[i] - a[i - 1]),f[i - 1][1] + \text{abs}(a[i] - b[i - 1]))$。

$f[i][1]$ 同理。

---
### 边界
因为我们是要从 $i = 2$ 开始，求出 $c_i - c_{i - 1}$，所以边界：

$f[1][0] = 0, f[1][1] = 0$。

---
### 目标
$\min(f[n][0], f[n][1])$

---
### 关于 long long
这道题不开 long long 一个点都过不了。

---
### 代码
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <climits>

using namespace std;
const int N = 2e5 + 10;

int a[N];
int b[N];
long long f[N][2];

int main()
{
  int n;
  cin >> n;
  for (int i = 1; i <= n; ++i)
    cin >> a[i];
  for (int i = 1; i <= n; ++i)
    cin >> b[i];
  f[1][0] = 0;
  f[1][1] = 0;
  for (int i = 2; i <= n; ++i)
  {
    f[i][0] = min(f[i - 1][0] + abs(a[i] - a[i - 1]), f[i - 1][1] + abs(a[i] - b[i - 1]));
    f[i][1] = min(f[i - 1][0] + abs(b[i] - a[i - 1]), f[i - 1][1] + abs(b[i] - b[i - 1]));
  }
  cout << min(f[n][0], f[n][1]) << '\n';
  return 0;
}
```

---

## 作者：YBa2Cu3O7 (赞：0)

DP。

先约定下面提到的“前缀和”是指 $S_n=\sum_{i=2}^{n}|c_{i+1}-c_{i}|$，$S_1=0$。

设第 $i$ 个位置选取 $a_i$ 时的最小前缀和为 $dp_{a,i}$，选取 $b_i$ 时的最小前缀和为 $dp_{b,i}$，显然有 $dp_{a,1}=dp_{b,1}=0$。

如果第 $i+1$ 个位置上选择 $a_{i+1}$，那么前一个位置应该选择能让前缀和更小的：
$$dp_{a,i+1}=\min\{dp_{a,i}+|a_{i+1}-a_{i}|,\,dp_{b,i}+|a_{i+1}-b_{i}|\}.
$$
类似的，如果选择 $b_{i+1}$：
$$dp_{b,i+1}=\min\{dp_{a,i}+|b_{i+1}-a_{i}|,\,dp_{b,i}+|b_{i+1}-b_{i}|\}.
$$
最后的结果就是 $\min \{dp_{a,n},dp_{b,n}\}$。

主要代码：
```
vector<vector<long long>> dp(n, vector<long long>(2, 0));
for(int i = 1; i < n; ++i){
    dp[i][0] = min(dp[i-1][0] + abs(a[i] - a[i-1]), dp[i-1][1] + abs(a[i] - b[i-1]));
    dp[i][1] = min(dp[i-1][0] + abs(b[i] - a[i-1]), dp[i-1][1] + abs(b[i] - b[i-1]));
}
cout << min(dp[n-1][0], dp[n-1][1]);
```
这里二维数组的第一列代表 $dp_{a}$，第二列代表 $dp_{b}$，可以优化为只用两个变量记录。

---


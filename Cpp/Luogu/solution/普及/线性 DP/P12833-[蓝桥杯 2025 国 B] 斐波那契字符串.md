# [蓝桥杯 2025 国 B] 斐波那契字符串

## 题目描述

斐波那契字符串 $S$ 是由 $\tt 0$ 和 $\tt 1$ 所组成的字符串，其生成规则如下：
- $S_1 = \tt 0$。
- $S_2 = \tt 1$。
- 对于任意正整数 $n (n \geq 3)$，$S_n = S_{n-2} + S_{n-1}$（“+”表示字符串拼接）。

例如：$S_3 = 01$、$S_4 = 101$、$S_5 = 01101$。

在斐波那契字符串 $S$ 中，定义逆序对为满足以下条件的整数对 $(i, j)$:
- $1 \leq i < j \leq |S|$（其中 $|S|$ 表示 $S$ 的长度）。
- $S[i] = 1$（第 $i$ 个字符为 $\tt 1$）并且 $S[j] = 0$（第 $j$ 个字符为 $\tt 0$）。

现在，给定一个正整数 $N$，请你计算出 $S_N$ 中所有逆序对 $(i, j)$ 的总数。由于结果可能很大，请输出其对 $10^9 + 7$ 取余后的值。

## 说明/提示

**【样例说明】**

对于 $N = 3$，$S_3 = 01$，逆序对总数为 0。

对于 $N = 5$，$S_5 = 01101$，逆序对为 $(2, 4)$、$(3, 4)$，总数为 2。

**【评测用例规模与约定】**

对于 20% 的评测用例，$1 \leq T \leq 20$，$3 \leq N \leq 35$。

对于 100% 的评测用例，$1 \leq T \leq 10^5$，$3 \leq N \leq 10^5$。

## 样例 #1

### 输入

```
2
3
5```

### 输出

```
0
2```

# 题解

## 作者：mairuisheng (赞：4)

- 题目：[P12833 [蓝桥杯 2025 国 B] 斐波那契字符串](https://www.luogu.com.cn/problem/P12833)

- 主要算法：动态规划。

- 分析：

由于字符串 $S$ 只含有 $\tt 0$ 和 $\tt 1$，所以组成的逆序对只能是 $\tt 10$ 的形式，所以我们需要统计每个字符串 $\tt 0$ 和 $\tt 1$ 的数量。

设 $zero_i$ 表示 $S_i$ 零的数量；

再设 $one_i$ 表示 $S_i$ 一的数量；

最后设 $ans$ 表示 $S_i$ 的逆序对数量。

$zero_i$ 的状态转移方程是它前两项零的数量之和，即：

$$zero_i=zero_{i-1}+zero_{i-2}$$

$one_i$ 的状态转移方程是它前两项一的数量之和，即：

$$one_i=one_{i-1}+one_{i-2}$$

接下来，考虑计算 $ans_i$，由于 $S_i$ 是由 $S_{i-2}$ 和 $S_{i-1}$ 拼接而成的，所以产生的新的逆序对数量就是第 $i-2$ 项 $\tt 1$ 的数量与第 $i-1$ 项 $\tt 0$ 的数量的乘积，最后再加上它前两项原有的逆序对数量，即：

$$ans_i=one_{i-2}\times zero_{i-1}+ans_{i-1}+ans_{i-2}$$



- 时间复杂度：由于本题输出较多，所以采用 $O(N)$ 预处理，$O(1)$ 回答每个问题的方法。总时间复杂度：$O(N)$。

- 参考代码：

```cpp
//Author : mairuisheng
//#pragme GCC optimize(3)
#include<cstdio>
#define int long long
using namespace std;
inline int read()
{
	int x=0,f=1;
	char s;
	s=getchar();
	while(s<48||s>57)
	{
		if(s=='-')f=-f;
		s=getchar();
	}
	while(s>47&&s<58)
	{
		x=(x<<3)+(x<<1)+s-48;
		s=getchar();
	}
	return x*f;
}
constexpr int N=1e5+1,MOD=1e9+7;
int sum0[N],sum1[N],ans[N];
int T,n;
void Pre()
{
	int i;
	sum0[1]=1;
	sum1[2]=1;
	for(i=3;i<N;++i)
	{
		sum0[i]=(sum0[i-1]+sum0[i-2])%MOD;
		sum1[i]=(sum1[i-1]+sum1[i-2])%MOD;
		ans[i]=((sum1[i-2]*sum0[i-1]%MOD+ans[i-1])%MOD+ans[i-2])%MOD;
	}
}
signed main()
{
	T=read();
	Pre();
	while(T--)
	{
		n=read();
		printf("%lld\n",ans[n]);
	}
	return 0;
}
```

---

## 作者：zhoujunchen (赞：3)

计数问题考虑 dp。

我们使用三个数组 $a,b,ans$。

$a_i$ 表示第 $i$ 个字符串 $0$ 的个数，$b_i$ 表示第 $i$ 个字符串 $1$ 的个数，$ans_i$ 表示第 $i$ 个字符串逆序对个数。

$a_i$ 的状态转移很显然：

$$a_i=a_{i-1}+a_{i-2}$$

$b$ 数组同理。

$ans_i$ 可以分成三部分：

- $S_{n-2}$ 的逆序对。
- $S_{n-1}$ 的逆序对。
- 跨部分，$S_{n-2}$ 的 $1$ 与 $S_{n-1}$ 的 $0$ 会产生逆序对，数量为 $b_{n-2}\times a_{n-1}$。

得出 $ans_i$ 的转移：

$$ans_i=ans_{i-1}+ans_{i-2}+b_{n-2}\times a_{n-1}$$

一个 $O(N)$ 预处理然后 $O(1)$ 回答即可。



```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int mod=1e9+7;
int t,n,dp0[114514],dp1[114514],ans[114514];
void init(){
	dp0[1]=1,dp1[1]=0,ans[1]=0;
	dp0[2]=0,dp1[2]=1,ans[2]=0;//初始化
	for(int i=3;i<=1e5;i++){
		dp0[i]=(dp0[i-1]+dp0[i-2])%mod,
		dp1[i]=(dp1[i-1]+dp1[i-2])%mod,
		ans[i]=ans[i-1]+ans[i-2]+(dp1[i-2]*dp0[i-1]%mod),ans[i]%=mod;
	} 
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	init();
	while(t--)cin>>n,cout<<ans[n]<<"\n";
	return 0;
}
```

---

## 作者：Smirk (赞：2)

# [蓝桥杯 2025 国 B] 斐波那契字符串


## 考场（废话）

写到 D 已经过去一个小时，迅速写了一个暴力，直接把 $S_n$ 求出来数逆序数。然后这里点名表扬一波长沙理工电脑，$n=100$ 测一波电脑直接卡死，被迫换机子。换好机子后冷静打表找到规律。

## 思路

读题我们知道字符串 $S$ 由 01 构成，又
$$
S_1 = 0, S_2 = 1 \\
S_n = S_{n-2}+S_{n-1}
$$
, 然后求逆序对个数。我们可以把具体的每个 $S_N$ 求出来，但是数据范围在 $3\le N\le10^5$，显然长度会爆掉。

所以我们不求其具体字符串，而是**考虑其逆序对数量的继承**。我们定义 $dp[i]$ 为 $S_i$ 中的逆序对个数，$Zero[i]$ 为 $S_i$ 中 0 的个数，$One[i]$ 为 $S_i$ 中 $1$ 的个数。

$dp[i]$ 也就是 $S_i$ 中每个 $0$ 能构成的逆序对个数之和。

$S_i$ 中各个 0 能构成的逆序对个数取决于在这个 0 之前 1 的个数。

那么每次做字符串拼接的时候，我们发现 **在 $S_n$ 中 $S_{n-2}$ 中 0 的逆序对数量并不改变，而 $S_{n-1}$ 中每个 0 的逆序对数量增加 $S_{n-2}$ 中 1 的数量个。**

例如题中例：
$$
S_3 = 01, S_4 = 101,\\
S_5 = S_3+S_4 = 01101\\
$$
$S_5$ 中 $S_3$ 的那个 $0$ 的逆序数并没有增加，而 $S_5$ 中的 $S_4$ 的那个 $0$ 逆序数增加了 $One[3]=1$。

我们也发现，**在拼接后 $S_3、S_4$ 内部的逆序数没有改变**，那么状态转移方程就呼之欲出也。
$$
dp [i] = dp [i-1]+dp [i-2]+Zero [i-1]*One [i-2]
$$
$Zero[i]$ 和 $One[i]$ 的维护非常好想，就是继承前两者之和。
$$
Zero [i] = Zero [i-1]+Zero [i-2]\\
One [i] = One [i-1]+One [i-2]
$$
别忘记取模！

## 代码

~~~c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 7;
const ll Mod = 1e9 + 7;
int t, n;
ll dp [N], Zero [N], One [N];
int main() {
    ios:: sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    Zero [1] = 1, Zero [2] = 0;
    One [1] = 0, One [2] = 1;
    dp [1] = 0, dp [2] = 0;
    for (int i = 3; i <= N - 7; i++) {
        Zero [i] = (Zero [i - 1] + Zero [i - 2]) % Mod;
        One [i] = (One [i - 1] + One [i - 2]) % Mod;
        dp [i] = (dp [i - 1] + dp [i - 2] + Zero [i - 1] * One [i - 2]) % Mod;
    }
    cin >> t;
    while (t--) {
        cin >> n;
        cout << dp [n] << "\n";
    }
    return 0;
}
~~~



## 谢谢观看~

---

## 作者：itzxianfish (赞：2)

# 题解

注意到题目递推式：$S_i = S_{i-2} + S_{i-1}$，由于这是字符串拼接操作，相应的，对于 $S_i$，其长度 $|S_i|$ 也满足上述递推，也就是斐波那契数列，于是我们不可能存储每一个字符串。

但是这么显眼得递推式摆在面前，我们要考虑使用动态规划，我们先假设：$dp_i = dp_{i-2} + dp_{i-1} + R$，其中 $dp_i$ 表示第 $i$ 个斐波那契字符串的逆序对数量，$R$ 是拼接之后新产生的逆序对数量，这里我们先不分析。

这个式子是比较显然的，还是根据 $S_i = S_{i-2} + S_{i-1}$，意味着 $S_{i-2}$ 和 $S_{i-1}$ 是组成 $S_i$ 的子串，所以 $S_i$ 的逆序对数量，至少是要从 $S_{i-2}$ 和 $S_{i-1}$ 的逆序对数量来，但是拼接时，由于两个部分的字串都会有 $0$ 和 $1$，所以会产生新的逆序对，于是就有了 $dp_i = dp_{i-2} + dp_{i-1} + R$。

接下来我们分析 $R$，注意到斐波那契字符串是 $01$ 串，这意味着其只存在唯一的逆序对可能，就是 $(1,0)$，所以，$R$ 的来源只可能是 $S_{i-2}$ 中的 $1$，与 $S_{i-1}$ 中的 $0$，形成的新逆序对，也就是 $R = cnt1_{i-2} \times cnt0_{i-1}$。

根据以上的分析，我们维护三个数组，分别是 $dp$，$cnt0$，$cnt1$。

又注意到题目是多次询问，所以我们可以预处理 $dp$ 数组用于查询，于是我们的核心代码如下。


```cpp
    dp[1] = dp[2] = 0;
    cnt0[1] = cnt1[2] = 1;
    cnt0[2] = cnt1[1] = 0;
    for (int i = 3; i <= 100000; i++) {
        dp[i] = (dp[i - 2] + dp[i - 1] + cnt1[i - 2] * cnt0[i - 1]) % MOD;
        cnt0[i] = (cnt0[i - 2] + cnt0[i - 1]) % MOD;
        cnt1[i] = (cnt1[i - 2] + cnt1[i - 1]) % MOD;
    }
```

之后每次查询 $x$ 只要输出 $dp_x$ 即可。

时间复杂度是 $O(100000 + t)$ 线性时间可以通过。

---

## 作者：litangzheng (赞：2)

### 前言：

这种题目万变不离其宗，只要找出递推式子即可。

### 思路：

我们定义 $f_i$ 为 $S_i$ 的逆序对个数，$a_i$ 为 $S_i$ 中的字符 $1$ 的个数，$b_i$ 为 $S_i$ 中的字符 $0$ 的个数。  

容易看出，$a_i = a_{i-1} + a_{i-2}$，$b_i = b_{i-1} + b_{i-2}$。  

而 $f_i = f_{i-1} + f_{i-2} + S_{i-1} 与 S_{i-2} 合并多出的逆序对个数 $，即 $f_i = f_{i-1} + f_{i-2} + a_{i-2} \times b_{i-1}$。因为根据题目中逆序对的定义，**一个逆序对中字符 $1$ 的下标肯定是比字符 $0$ 的下标要靠前的**，我们就让合并在前的字符串中的 $1$ 与合并在后的字符串中的 $0$ 配对，就是合并多出的逆序对个数。  

有了递推式，我们的代码也就跟着出来了，记得取模。  

### 代码：  


```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
#define N 100010
using namespace std;
int t,f[N],os[N],zs[N];//os为a数组，zs为b数组
signed main(){
    cin>>t;
    os[1]=0;os[2]=1;
    zs[1]=1;zs[2]=0;
    f[1]=f[2]=0;//初始化，有些地方可以删减
    for(int i=3;i<=100000;i++){
        //递推时间到
        os[i]=(os[i-1]+os[i-2])%mod;
        zs[i]=(zs[i-1]+zs[i-2])%mod;
        f[i]=(f[i-1]+f[i-2]+os[i-2]*zs[i-1])%mod;
    }
    for(int i=1;i<=t;i++){
        int n;
        cin>>n;
        cout<<f[n]<<endl;
    }
}
```

---

## 作者：Chenyuze24 (赞：1)

## Part1：思路解析
考虑到用动态规划，$dp[i][2]$ 表示 $S_i$ 中所有逆序对的个数，$dp[i][0]$ 表示 $S_i$ 中的 $0$ 的个数，$dp[i][1]$ 表示 $S_i$ 中的 $1$ 的个数。

因为 $S_i$ 是由 $S_{i-1}$ 和 $S_{i-2}$ 构成的，
而 $S_i$ 中只有 $0$ 和 $1$，所以逆序对肯定是由 $0$ 和 $1$构成的，所以 $S_{i-1}$ 中的 $0$ 和 $S_{i-2}$ 中的 $1$ 还能构成逆序对。

所以状态转移方程如下。
```cpp
dp[i][2] = (dp[i-1][2]+ dp[i-2][2] + dp[i-2][1] * dp[i-1][0])%1000000007;
```
$dp[i][0]$ 与 $dp[i][1]$ 的转移方程如下。
 
```cpp
dp[i][0] = (dp[i-1][0] + dp[i-2][0])%1000000007;
dp[i][1] = (dp[i-1][1] + dp[i-2][1])%1000000007;//都是前两个的和，因为是拼起来的。
```

## Part2：细节
- 看清是多组数据。
- 不要忘记取模。
- 不要忘记初始化，想清楚 $S_1$ 与 $S_2$ 中的 $0$ 和 $1$ 的个数。
- 输出的是 $dp[n][2]$。
## Part3：代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[100030][3];
const int MOD=1e9+7;//取模
int T;
int main() {
	ios::sync_with_stdio(0);//快读
	cin.tie(0);
	cout.tie(0);
	dp[1][0] = 1;
	dp[1][1] = 0;
	dp[2][0] = 0;
	dp[2][1] = 1;//初始化
	for (int i = 3; i <= 100000; ++i)//注意从3开始
	{
		dp[i][0] = (dp[i-1][0] + dp[i-2][0])%MOD;
		dp[i][1] = (dp[i-1][1] + dp[i-2][1])%MOD;//都是前两个的和，因为是拼起来的。
		dp[i][2] = (dp[i-1][2]+ dp[i-2][2] + dp[i-2][1] * dp[i-1][0])%MOD;//转移方程
	}
	cin >> T;//多组数据
	while (T--) 
	{		
		int n;
		cin >> n;
		cout << dp[n][2] << '\n';//输出答案
	}
	return 0;//不能忘
}//完结撒花！！！
```

---

## 作者：4041nofoundGeoge (赞：1)

## 思路

给定一个斐波那契字符串，得到所有的逆序对。

显然 $10^5$ 的数据无法使用 $O(n)$ 的算法。

既然题目是以递推的形式给出，我们就以递推的形式做这道题。

一个长度为 $n$ 的字符串，记作 $S_n$，他产生的逆序对有两种方式：

1. $S_{n-1}$ 产生。
2. $S_{n-2}$ 产生。
3. $S_{n-1}$ 和 $S_{n-2}$ 中跨越的逆序对。

于是第一个递推式出现了：
$$
f(S_n)=f(S_{n-1})+f(S_{n-2})+\text{Cross}(S_{n-1},S_{n-2})
$$

其中 $f(S_n)$ 为 $S_n$ 中的逆序对数量，$\text{Cross}(S_{n-1},S_{n-2})$ 为横跨的逆序对数量。其实我们设 $S_n$ 中奇数个数为 $A(S_n)$，偶数为 $A'(S_n)$，第二个假递推式出现：
$$
\text{Cross}(S_{n-1},S_{n-2})=A(S_{n-2})\times A'(S_{n-1})
$$
同样，奇偶数也可以递推：
$$
A(S_{n})=A(S_{n-1})+A(S_{n-2})\\
A'(S_{n})=A'(S_{n-1})+A'(S_{n-2})
$$

#### 边界条件：

$f(1)=0,f(2)=0$。

$A(1)=0,A(2)=1$。

$A'(1)=1,A'(2)=0$。

时间复杂度：$O(n)$。

再做就像斐波那契数列那样简单了。

## 后续

![](https://cdn.luogu.com.cn/upload/image_hosting/vzwcvy21.png)

很显然你不会这样。

---

## 作者：a202401006 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12833)

# 解析

## 题目大意

给出一个按规律生成的 01 串 $S$，其规律如下。

- $S_1=0$。
- $S_2=1$。
- 对于大于等于 $3$ 的任意整数，$S_n$ 就是 $S_{n-2}$ 和 $S_{n-1}$ 拼接。

逆序对 $(i,j)$ 就是满足 $1\le i<j\le |S|$（$|S|$ 是串的长度）且满足 $S_{i}=1$ 并且 $S_{j}=0$。

## 考察知识

数组处理以及分析、找规律。

## 思路

首先，由题意得逆序对只能是 $10$ 的形式。

我们用两个数组 $sum0$ 和 $sum1$ 分别表示 $S$ 的 $0$ 和 $1$ 数量，分别是前两项 $0$ 和 $1$ 的数量之和。

接着得出合并的逆序对总数，计入数组 $output$ 里。怎么得出逆序对总数呢？依题意的，$S_i$ 是由 $S_2$ 和 $S_1$ 拼接而成的，所以第 $i-2$ 项的所有 $1$ 均可以匹配第 $i-1$ 项的所有 $0$，及所产生的逆序对数量就是第 $i−2$ 项 $1$ 的数量与第 $i−1$ 项 $0$ 的数量的乘积，再加上这两项原有的逆序对数量即可。所以 $output_i=sum1_{i-2}\times sum0_{i-1}+output_{i-1}+output_{i-2}$ 就是计算逆序对总数的公式。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10,MOD=1e9+7;
int sum_0[N],sum_1[N],output[N],t,n;
signed main()
{
	cin>>t;
	sum_0[1]=1;
	sum_1[2]=1;
	for(int i=3;i<N;i++)
	{
		sum_0[i]=(sum_0[i-1]+sum_0[i-2])%MOD;
		sum_1[i]=(sum_1[i-1]+sum_1[i-2])%MOD;
		output[i]=((sum_1[i-2]*sum_0[i-1]%MOD+output[i-1])%MOD+output[i-2])%MOD;
	}
	for(int i=1;i<=t;i++)
	{
		cin>>n;
		cout<<output[n]<<endl;
	}
}
```

---

## 作者：HetmesAskalana (赞：0)

## 题意分析

有一个字符串数组，其中 $S_1 = 0, S_2 = 1, S_i = S_{i-2} + S_{i - 1}$，求 $S_n$ 的逆序对数。

## 题解

我们任选两个 $01$ 串连接起来，设 $T = A+B$，$\operatorname{f}(s)$ 表示 $s$ 的逆序对数。我们先将 $T$ 分为两段处理。在 $A, B$ 的部分中，$\operatorname{f}(A), \operatorname{f}(B)$ 自然不会发生改变。那么由字符串连接导致的新增逆序对出现在 $A$ 和 $B$ 连接的地方，即会跨越 $A, B$ 的分界线。

而由于这个字符串只是一个 $01$ 串，所以我们只需要考虑 $A$ 中每一个 $1$ 去匹配 $B$ 中每一个 $0$ 即可，所以得到：

$$\operatorname{f}(T) = \operatorname{f}(A) + \operatorname{f}(B) + \operatorname{cnt_1}(A) \times \operatorname{cnt_0}(B)$$

即可得到递推公式：

 $$\operatorname{f}(S_i) = \operatorname{f}(S_{i - 2}) + \operatorname{f}(S_{i - 1}) + \operatorname{cnt_1}(S_{i - 2}) \times \operatorname{cnt_0}(S_{i - 1})$$ 

其中 $\operatorname{cnt_1}(s), \operatorname{cnt_0}(s)$ 分别表示求字符串 $s$ 中 $1$ 或 $0$ 的数量。

由于 $\sum N$ 未做限制，所以预处理一下，就可以固定 $\Theta(1)$ 回答每次询问。

总时间复杂度 $\Theta(N + T)$。

## 代码
```cpp
constexpr int MOD = 1e9 + 7;
constexpr int N = 2e5 + 7;

struct Node{
    LL cnt0, cnt1; // 0的数量，1的数量
    LL rvs; // 逆序对数
};

vector<Node> f(N);

void init(){
    f[1].cnt0 = 1, f[1].cnt1 = 0, f[1].rvs = 0;
    f[2].cnt0 = 0, f[2].cnt1 = 1, f[2].rvs = 0; // 固定值
    for(int i = 3; i <= N - 1; ++i){
        LL cnt1 = (f[i - 1].cnt1 + f[i - 2].cnt1) % MOD;
        LL cnt0 = (f[i - 1].cnt0 + f[i - 2].cnt0) % MOD;
        LL rv = (f[i - 1].rvs + f[i - 2].rvs) % MOD;
        rv = (rv + (f[i - 2].cnt1 * f[i - 1].cnt0) % MOD) % MOD;// 递推
        f[i].cnt0 = cnt0, f[i].cnt1 = cnt1, f[i].rvs = rv;
    }
}

void solve(){
    int n; cin >> n;
    cout << f[n].rvs << endl;
    return;
}
```

---

## 作者：true_kun (赞：0)

我们考虑，一个斐波那契串中逆序对的个数是由哪些部分构成的。不难发现，由于串是有拼接得到的，所以串中逆序对的个数是拼接前两个串的逆序对个数之和加上由于拼接产生的逆序对个数，也就是第一个串中 $1$ 的数量与第二个串中 $0$ 的数量的乘积。

状态设计：设 $dp_i$ 表示 $S_i$ 中所有逆序对的总数。$f_{0,i}$ 表示 $S_i$ 中 $0$ 的个数。$f_{1,i}$ 表示$S_i$ 中 $1$ 的个数。


转移如下：

$$dp_i=f_{0,{i-1}} \times f_{1,{i-2}}+dp_{i-1}+dp_{i-2}$$

记得取模。

因为是多测，所以我们预处理一下即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int  long long
const int mod=1e9+7;
int dp[100005];
int f0[100005],f1[100005];
signed main(){
	f0[1]=1,f1[1]=0,f0[2]=0,f1[2]=1;
	for(int i=3;i<=1e5+1;i++){
		f0[i]=(f0[i-1]+f0[i-2])%mod;
		f1[i]=(f1[i-1]+f1[i-2])%mod;
		dp[i]=( ( (f0[i-1]*f1[i-2])%mod+dp[i-1])%mod+dp[i-2])%mod;
	}
	int t;
	cin>>t;
	for(int i=1;i<=t;i++){
		int x;
		cin>>x;
		cout<<dp[x]<<endl;
	}
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 题意

定义字符串 $S_i$ 满足以下条件：
$$
S_i = \begin{cases}
\tt {0} & i = 1, \\
\tt {1} & i = 2, \\
S_{i-2} + S_{i-1} & \text{otherwise.}
\end{cases}
$$

对于任意正整数 $n\  (3 \le n \le 10^5)$，求解 $S_n$ 中存在的逆序对数量。答案对 $10^9 + 7$ 取模。

## 思路

~~碰上最不会的组合记数题了。~~

考虑用 DP 解决。因此自然少不了三要素.

### 状态

这一题为稍微复杂一点的线性 DP，我们需要开三个数组 $one, zero, ans$，三个数组中的第 $i$ 个元素分别代表：$S_i$ 中的 $\tt 0$ 总数，$\tt 1$ 总数，以及最终答案（逆序对数量）。

### 边界

很明显，$one_1 = 0, one_2 = 1, zero_1 = 1, zero_2 = 0, ans_1 = ans_2 = 0$，具体原因不作过多赘述。

### 转移

首先先考虑转移 $zero$ 和 $one$，显然 $zero_i = zero_{i - 1} + zero_{i - 2}$，因为两个字符串的拼接后 $\tt 0$ 的总个数肯定等于合并前的两个字符串 $\tt 0$ 的个数相加。$one_i$ 的转移同理。

接着是略有难度的 $ans$ 转移。不难看出 $ans_i$ 为以下三个部分之和：
- $ans_{i - 1};$
- $ans_{i - 2};$
- $S_{i-1},S_{i-2}$ 进行拼接后，产生的新逆序对数量。

由于逆序对需要保证 $\tt 1$ 出现在 $\tt 0$ 的前面，所以第三部分只可能是 $S_{i-2}$ 里面的 $\tt 1$ 与 $S_{i-1}$ 里面的 $\tt 0$ 组成的，那么第三部分的总数便是 $one_{i - 2} \times zero_{i - 1}$。

最终总结出的动态转移方程如下（不含边界，即保证 $i \ge 3$）：
$$
\begin{cases}
zero_i = zero_{i - 1} + zero_{i - 2} \\
one_i = one_{i - 1} + one_{i - 2} \\
ans_i = ans_{i - 1} + ans_{i - 2} + one_{i - 2} \times zero_{i - 1}
\end{cases}
$$

对了，不要忘记取模，并且两个 `int` 相乘可能会爆，要用 `long long` 存。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int ans[114514], zero[114514], one[114514];
const int Mod = 1e9 + 7;
int main(){
	zero[1] = one[2] = 1; //初始化
	for(int i = 3; i <= 100005; ++i){ //递推（预处理）
		zero[i] = (zero[i - 1] + zero[i - 2]) % Mod;
        one[i] = (one[i - 1] + one[i - 2]) % Mod;
        ans[i] = (ans[i - 2] + ans[i - 1] + one[i - 2] * zero[i - 1]) % Mod;
	}
    int T;
    while(T--){
    	int n; cin >> n;
    	cout << ans[n] << endl; //预处理后直接输出答案即可
	}
	return 0;
}
```

---

## 作者：枫原万叶 (赞：0)

# P12833 题解

## 分析

斐波那契字符串的生成规则就不在过多赘述，因为 $N,T \le 10^5$ 所以直接生成字符串显然是不可行的，我们可以考虑先用动态规划预处理然后读入。

我们设置两个数组 a 和 b 分别表示在原字符串中 0 出现的个数和 1 出现的个数。

因为 $S_n=S_{n-1}+S_{n-2}$ 所以 $a_i=a_{i-1}+a_{i-2}$ 同理可得 $b_i=b_{i-1}+b_{i-2}$ 获得两条转移方程。

再设置一个 f 数组表示在所有逆序对 $(i,j)$ 的数量，其中 $i<j$ 并且 i 表示的数为 1，j 表示的数为 0。

分为三个状态：

1. 完全在 $S_{n-2}$ 中的逆序对：$f_{n-2}$。
2. 完全在 $S_{n-1}$ 中的逆序对：$f_{n-1}$。
3. 跨越 $S_{n-2}$ 和 $S_{n-1}$ 的逆序对：即 $S_{n-2}$ 中的每个 1 和 $S_{n-1}$ 中的每个 0 组成的对，数量为 $b_{n-2} \times b_{n-1}$。

这下相信你应该会写了。

---

但是在看的时候你可能会产生一些疑问。

为什么需要三个数组？我们来阐述一下这些数组的作用。

a 和 b 的作用：我们需要知道每个字符串中 0 和 1 的数量，才能计算跨越拼接点的逆序对数量。

f 的作用：直接记录每个字符串的逆序对总数，避免出现重复计算。

既然思路讲解完毕，接下来献上代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=1e5+5;
const ll MOD=1000000007LL;
ll a[MAXN],b[MAXN],f[MAXN];

int main(){
	a[1]=1,a[2]=0,b[1]=0,b[2]=1,f[1]=0,f[2]=0;
	
	ll cs;
	for(int i=3;i<=MAXN;i++){
		a[i]=(a[i-1]+a[i-2])%MOD;
		b[i]=(b[i-2]+b[i-1])%MOD;
		cs=(b[i-2]*a[i-1])%MOD;
		f[i]=(f[i-2]+f[i-1]+cs)%MOD;
	}
	
	int t;
	scanf("%d",&t);
	while(t--){
		int n;
		scanf("%d",&n);
		printf("%lld\n",f[n]);
	}
	return 0;
}
```

---


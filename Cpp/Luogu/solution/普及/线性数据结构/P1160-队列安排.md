# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# 题解

## 作者：BT狸——Frozen (赞：553)

## 本蒟蒻第一篇题解
若有错误，请谅解


------------
这道题是一道典型的模拟题，故本蒟蒻第一个想到的就是用数组（~~太年轻~~），然后每加一个同学，就把他后面的同学位置整体向后挪，将他放进去，然后
#### 就没有然后了···
对于N，M ≤ 100000和这个无比粗暴的方法，不TLE就是奇迹


------------
妄想偷懒不行，只能好好分析一下题

稍加观察可以看出，这是一个链式结构，移动同学肯定是不行的（时间复杂度太高），那么，只能对他们间的关系下手了

我们可以把每相邻的的两个同学想象成他们牵着手（如图）
![](https://i.loli.net/2019/05/25/5ce93d68a98c016430.jpg)
既然如此，我们就只需要改动左右手指向的同学就可以了
定义一个结构体
```cpp
struct T{
    int l,r;        //每个同学的“左右手” 
}t[mx]={0};
```
现在我们就手动模拟一下加入同学（以右边为例）
将编号为J的同学加入编号为i的同学右边
![示例](https://i.loli.net/2019/05/25/5ce94307c4cbd77890.jpg)
##### 第一步 J的右手牵I右手牵的同学
![第一步](https://i.loli.net/2019/05/25/5ce9434b2793f64382.jpg)
```cpp
t[j].r=t[i].r;
```
##### 第二步 J的左手牵I
![第二步](https://i.loli.net/2019/05/25/5ce94432b882920324.jpg)
```cpp
t[j].l=i;
```

##### 第三步 I的右手牵J
![第三步](https://i.loli.net/2019/05/25/5ce946dce376247864.jpg)
```cpp
t[i].r=j;
```

##### 第四步 J右手牵的同学的左手牵J
注意：此时I的右手已经不牵原来那个同学了
![第四步](https://i.loli.net/2019/05/25/5ce9482add74d49726.jpg)
```cpp
t[t[j].r].l=j;
```

此时J就加入链当中了

左边同理

加入函数如下
```cpp
void add(int i,int k,int f)       //新增同学 
{
    if(f==1)         //右 
    {
        t[k].r=t[i].r;
        t[k].l=i; 
        t[i].r=k;
        t[t[k].r].l=k;
    }
    else             //左
    {
        t[k].r=i;
        t[k].l=t[i].l;
        t[i].l=k;
        t[t[k].l].r=k;
    }
}
```


------------
接下来是移除

我们虽然也可以用上面方法来删除

不过我用的是另一种方法（~~主要是懒~~）

我们可以给每个同学一个标记，标记了的将不会输出
```cpp
struct T{
    int l,r;        //每个同学的“左右手” 
	int d;          //表示同学是否输出 
}t[mx]={0};
```
结构体

```cpp
while(m--)
    {
        cin>>x;           //要删去的同学
        t[x].d=1;         //将该同学标记为不输出 
    }
```
标记


------------
# 接下来是细节问题
## 链的初始化
如果我们将1同学先输入进去
```cpp
t[1].l=1,t[1].r=1;
```
因为没有其他同学只能自己牵自己（~~紧紧抱住弱小的自己~~）

但如果这样，到输出时就有一个问题（以样例为例）
![样例](https://i.loli.net/2019/05/25/5ce94e224fc9b89880.jpg)
找不到开头！

这时我们就要在初始化时动些手脚
```cpp
    t[0].r=0,t[0].l=0;
    add(0,1,1);
```
定义个0同学
链将变成这样
![链](https://i.loli.net/2019/05/25/5ce94fc4077b913854.jpg)
我们只要从0的右手牵的同学开始输出，再到0结束就行了

输出代码
```cpp
    for (int i=t[0].r;i;i=t[i].r)
    {
        if (t[i].d==0)    //输出未标记的 
          cout<<i<<" ";
    }
```


------------
# 纯代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
const int mx=1e5+10;
int n,m;
struct T{
    int l,r;        //每个同学的“左右手” 
	int d;          //表示同学是否输出 
}t[mx]={0};
void add(int i,int k,int f)       //新增同学 
{
    if(f==1)         //左 
    {
        t[k].r=t[i].r;
        t[k].l=i; 
        t[i].r=k;
        t[t[k].r].l=k;
    }
    else             //右 
    {
        t[k].r=i;
        t[k].l=t[i].l;
        t[i].l=k;
        t[t[k].l].r=k;
    }
}
int main()
{
    int x,k,f;
    cin>>n;
    t[0].r=0,t[0].l=0;
    add(0,1,1);
    for (int i=2;i<=n;i++)
    {
        cin>>x>>f;
        add(x,i,f);
    }
    cin>>m;
    while(m--)
    {
        cin>>x;
        t[x].d=1;         //将该同学标记为不输出 
    }
    for (int i=t[0].r;i;i=t[i].r)
    {
        if (t[i].d==0)    //输出未标记的 
          cout<<i<<" ";
    }
    return 0;
}
```


---

## 作者：Orina_zju (赞：273)

看了一下题解区似乎没有用STL的，那我就发个STL的解法好了(〃'▽'〃)

C++标准库自带了std::list这个双向链表的模板类，使用时需要包含头文件：#include <list>。
```cpp
list<int> myList;
```
  这句代码声明了一个list<int>类型的变量，也就是一个包含int类型元素的双向链表。尖括号里边的部分称为**模板参数**，对于list而言，它表示链表里的元素是什么类型。
```cpp
myList.push_front(1);
myList.push_back(2);
```
  顾名思义，这两个成员函数分别用于在链表的头部和尾部插入元素。对应地，pop_front()用于移除头部的元素，pop_back()用于移除尾部的元素。
```cpp
typedef list<int>::iterator Iter;
Iter itBegin = myList.begin();
Iter itEnd = myList.end();
for (; itBegin != itEnd; ++itBegin)
	printf(" %d", *itBegin);
```
  这段代码演示的是list提供的，用于访问内部元素的**迭代器**。迭代器的类型是list<Tp>::iterator（这里模板参数Tp需要与你操作的链表一致）。
  
  迭代器的用法和指针有些像，可以用*运算符访问内部的元素，++和--运算符可以将它后移或前移一位（建议写成前置形式），用==和!=运算符进判断两个迭代器所指的位置是否一致。但要注意：list的迭代器不支持it += x或it1 - it2这样的运算，也不支持<，<=等运算符。
  
  begin()成员函数返回指向头部元素的迭代器。
  
  end()成员函数返回指向末尾位置的迭代器。这个“末尾位置”指的是最后一个元素**再往后一位**，也就是说end()所指的位置不包含有效元素，它相当于一个虚设的节点。这样设计是为了满足C++标准库表示区间时左闭右开的惯例。
```cpp
//接上例
Iter it = myList.end();
--it;
//C++11中可以直接写成it = prev(myList.end());
//这里prev是头文件<iterator>提供的函数，用于返回将某个迭代器前移一位的结果
Iter it2 = myList.insert(it, 3);
//myList的内容：1,3,2
```
  这段代码首先定义了一个迭代器it，然后在end()的基础上左移一位，让它指向链表中最后一个元素。
  
  insert(it, val)成员函数用于在链表中插入元素。it为该链表的一个迭代器，val为待插入的值，插入后val位于it所指位置的**前一位**。返回值为一个迭代器，表示val插入到了哪个位置。
```cpp
//接上例
myList.remove(it);
//myList的内容：1,3
int x = *it + 10; //ERROR!
```
  remove(it)成员函数用于删除某个迭代器所指的节点。注意在删除之后it就失效了，除非给it重新赋值，否则对它的任何操作都会导致错误！
  
  除上述主要操作以外，list还提供了其他一些实用的成员函数：size()返回链表内元素的个数，empty()判断链表是否为空，remove(val)用于移除所有值为val的节点，以及作为成员函数的sort()和unique()。（注意sort(myList.begin(), myList.end())是错误的写法）
  
  有了这些基础知识，我们就可以用STL来写本题了。代码如下：
  ```cpp
#include <cstdio>
#include <list>

using namespace std;

using Iter = list<int>::iterator;

const int maxN = 1e5 + 10;
Iter pos[maxN];
list<int> queList;
bool erased[maxN];
int N;

void buildQueue()
{
    queList.push_front(1);
    pos[1] = queList.begin();

    for (int i = 2; i <= N; i++)
    {
        int k, p;
        scanf("%d%d", &k, &p);
        if (p == 0)
        {
            pos[i] = queList.insert(pos[k], i); //left
        }
        else
        {
            auto nextIter = next(pos[k]);
            pos[i] = queList.insert(nextIter, i); //right
        }
    }
    int M;
    scanf("%d", &M);
    for (int x, i = 1; i <= M; i++)
    {
        scanf("%d", &x);
        if (!erased[x])
        {
            queList.erase(pos[x]);
        }
        erased[x] = true;
    }
}

int main()
{
    scanf("%d", &N);
    buildQueue();
    bool first = true;
    for (int x: queList)
    {
        if (!first)
            putchar(' ');
        first = false;
        printf("%d", x);
    }
    putchar('\n');
    return 0;
}

```

---

## 作者：夜刀神十香ღ (赞：168)

因为n还是比较大的(n<=100000),又因为要不停的插入和删除，所以我们可以用链表。读入每一个同学时，都把他左边和右边的同学更新；删除同学时，先把这个同学赋为0，再把他左边的同学连上右边的同学；最后找到排在最左边的同学，挨个输出。时间复杂度O(n)。

注解代码：

```cpp
#include<cstdio>
#include<cstring>
int a[100010][3],n,m;
//a[i][2]表示学号为i的同学右边同学的学号
//a[i][3]表示学号为i的同学左边同学的学号
int main()
{
    scanf("%d",&n); int j=1;
    memset(a,0,sizeof(a)); a[1][1]=1;
    for(int i=2;i<=n;i++)
    {
        int x,y; scanf("%d %d",&x,&y);
        a[i][1]=i;
        if(y==0)
        //插入左边
        { 
            a[a[x][3]][2]=i; a[i][2]=x;
            a[i][3]=a[x][3]; a[x][3]=i;
            if(x==j) j=i;
            //比较麻烦，要改链表
        }
        else
        //插入右边
        {
            a[i][2]=a[x][2]; a[a[x][2]][3]=i;
            a[x][2]=i; a[i][3]=x;
        }
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        int x; scanf("%d",&x);
        if(a[x][1]!=0)
        //该同学还在 
        {
            a[x][1]=0;
            //踢掉……(好可怜) 
            a[a[x][3]][2]=a[x][2];
            a[a[x][2]][3]=a[x][3];
            n--;
            if(x==j) j=a[x][3];
        }
    }
    int i=1,x=j;
    while(i<=n)
    {
        printf("%d ",a[x][1]);
        x=a[x][2]; i++;
    }
    return 0;
}
```
纯代码：
```cpp
#include<cstdio>
#include<cstring>
int a[100010][3],n,m;
int main()
{
    scanf("%d",&n); int j=1;
    memset(a,0,sizeof(a)); a[1][1]=1;
    for(int i=2;i<=n;i++)
    {
        int x,y; scanf("%d %d",&x,&y);
        a[i][1]=i;
        if(y==0)
        {
            a[a[x][3]][2]=i; a[i][2]=x;
            a[i][3]=a[x][3]; a[x][3]=i;
            if(x==j) j=i;
        }
        else
        {
            a[i][2]=a[x][2]; a[a[x][2]][3]=i;
            a[x][2]=i; a[i][3]=x;
        }
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        int x; scanf("%d",&x);
        if(a[x][1]!=0)
        {
            a[x][1]=0;
            a[a[x][3]][2]=a[x][2];
            a[a[x][2]][3]=a[x][3];
            n--;
            if(x==j) j=a[x][3];
        }
    }
    int i=1,x=j;
    while(i<=n)
    {
        printf("%d ",a[x][1]);
        x=a[x][2]; i++;
    }
    return 0;
}
```

---

## 作者：LiRewriter (赞：130)

嗯...终于找到一道链表模板题，顺便发波题解吧

蒟蒻一直都是用list的orzzzzz

首先，这道题我们看到是对一个数列进行频繁的插入和删除操作，这和链表正好是吻合的。

这里大佬们纷纷用的双向链表...于是想一想也写双向链表好了。

那么就说说其实现细节吧，因为我也纠结了很久。

由于个人喜好问题在下用的是结构体

```cpp
struct node{
 int L, R;
}a[100003];
```
来作为链表节点的qwq

先看看删除：

我们把当前节点pos的左边节点a[pos].L的右边节点设置成a[pos.R]，也就是`a[a[pos].L].R = a[pos].R`，对右边节点也同样的处理，即`a[a[pos].R].L = a[pos].L`，这样在遍历这个链表的时候就可以跳过这个节点，最后再将该节点的左、右均设置成-1，就完成了删除操作。

```cpp
inline void del(int x) {
    if(a[x].L == -1) return;
    a[a[x].L].R = a[x].R;
    a[a[x].R].L = a[x].L;
    a[x].L = -1;
    a[x].R = -1; 
}
```
再来看看如何插入节点。

将一个节点i插入pos的左边，

- 将节点i的右边置为pos，即`a[i].R = pos`

- pos的左边节点a[pos].L的右边节点变为当前的i，即`a[a[pos].L].R = i`

- 节点i的左边应该是a[pos].L，即`a[i].L = a[pos].L`


- pos的左边节点修改为i，即`a[pos].L = x`

这样的四步之后就可以实现插入到左边的操作辣！

右边用相反的步骤完成即可。

完整的插入操作：

```cpp
inline void addRight(int x, int pos) { //插入右边 
    a[x].L = pos;
    a[a[pos].R].L = x;
    a[x].R = a[pos].R;
    a[pos].R = x;
}
inline void addLeft(int x, int pos) { //插入左边
    a[x].R = pos;
    a[a[pos].L].R = x;
    a[x].L = a[pos].L;
    a[pos].L = x;
}
```
最后是遍历。一开始我开了个头指针，后来看了题解区的大佬，感觉好厉害w

由于我们的链表是从1开始的，我们不妨将节点0变为一切的开始，也就是将a[0].R=1,a[1].L=0这样的强行插入节点0

显然，在最后的时候i仍然是整个链表的第一个节点，这样还可以避免在插入时遇到链表开头的讨论。

所以遍历输出的代码就是：

```cpp
inline void go() {
    int x = a[0].R;
    while(1) {
        cout<<x<<" ";
        if(a[x].R == -1) break;
        x = a[x].R;
    }
}
```
那么数组模拟双向链表就完成辣！

AC代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct node{
    int L, R;
}a[100003];
int n, m;
inline void addRight(int x, int pos) { //插入右边 
    a[x].L = pos;
    a[a[pos].R].L = x;
    a[x].R = a[pos].R;
    a[pos].R = x;
}
inline void addLeft(int x, int pos) { //插入左边
    a[x].R = pos;
    a[a[pos].L].R = x;
    a[x].L = a[pos].L;
    a[pos].L = x;
}
inline void del(int x) {
    if(a[x].L == -1) return;
    a[a[x].L].R = a[x].R;
    a[a[x].R].L = a[x].L;
    a[x].L = -1;
    a[x].R = -1; 
}
inline void go() {
    int x = a[0].R;
    while(1) {
        cout<<x<<" ";
        if(a[x].R == -1) break;
        x = a[x].R;
    }
}
inline void init() {
    for(int i = 1; i <= n; ++i) a[i].L = a[i].R = -1;
    a[1].R = -1; a[1].L = 0; a[0].R = 1;
}
int main() {
    scanf("%d", &n);
    int cmd1, cmd2;
    init();
    for(int i = 2; i <= n; ++i) {
        scanf("%d %d", &cmd1, &cmd2);
        if(!cmd2) addLeft(i, cmd1);
        else addRight(i, cmd1);
    }
    scanf("%d", &m);
    for(int i = 1; i <= m; ++i) {
        scanf("%d", &cmd1);
        del(cmd1);
    }
    go();
    return 0;
}
```

---

## 作者：Mickey_snow (赞：80)

######题目还是非常有意思的，重点是链表读取效率的优化。

首先，既然题目中多次提到了“移去”、“插入”等字眼，很明显需要用到链表。

在这里，我们使用一个结构体存储这个链表，并使用一个head指针指向队列的队首，方便输出时使用。


```cpp
    struct queueDat
    {
        int ID;            //该同学的号码
        queueDat *front = NULL, *back = NULL;
    }que[100001];
    queueDat *head = &que[1];
```
使用链表，可以极大地方便我们进行\*插入\*和\*删除\*的操作，不过，相比较于数组，链表最大的弊端就是在读取时不方便，我们为了寻找一个数据，可能需要从链表的某一个地方开始，一个个地找，这样就浪费了大量的时间，程序的效率极为低下。 幸运的是，在这道题中，所有的数据均为整数，所以我们可以让同学们的号码和que一 一对应。也就是说，如果需要寻找i号同学，直接使用que[i]即可，这么做不仅使我们的代码更为简单易懂，更重要的是节约了大量的宝贵时间。

     for (int i = 1; i < 100001; i++)

        que[i].ID = i;        //que[i]对应i号同学

我们还需要做的另外一件事，就是设置好已经在队列中的1号同学的数据信息，由于在程序刚刚开始运行时，队列中只有1号同学一个人，为了方便后面的\*插入\*和\*删除\*的操作，在这里我使用了双向链表，因此，1号同学的前面和后面都是1号同学。

 
     que[1].back = &que[1]; que[1].front = &que[1];

接下来我们就可以开始构建整个队列了，本题当中，比较好的选择是边读边做，一次读完不仅没有必要，而且会复杂化我们的程序。

在后面的处理中，移去的同学编号有重复，因此我们可以使用一个布尔数组判断i号同学是否在队列之中。

 
bool inQueue[100001]; memset(inQueue, false, sizeof(inQueue)); inQueue[1] = true;

```cpp
        for (int i = 1; i < 100001; i++)
            que[i].ID = i;        //que[i]对应i号同学
        que[1].back = &que[1]; que[1].front = &que[1];
        int totStudents, a, b;
        cin >> totStudents;            //同学总数
        for (int i = 2; i <= totStudents; i++)    //i代表同学的号码
        {
            inQueue[i] = true;                    //确认i号同学在队列当中
            cin >> a >> b;                        //插入在a同学的 左边或右边
        }
```
至此，我们只是读取了需要的数据，并没有在链表中进行相应的操作。所以，我们需要一些代码来实现插入的过程。这里我把它封装成了一个函数\_add.
 
```cpp
     void _add(int num, int ID, bool back)
    {
        queueDat *find = &que[ID], *add = &que[num];
        if (back)        //插入在后面
        {
            add->front = find;
            add->back = find->back;
            find->back = add;
            find = find->back->back;
            find->front = add;
            return;
        }
        else            //插入在前面
        {
            add->back = find;
            add->front = find->front;
            find = find->front;
            find->back = add;
            find = find->back->back;
            find->front = add;
            if (ID == head->ID)head = add;
        }
    }
```
在这当中，num代表需要插入的数，ID代表插入到的位置，back则表示是否插入在该同学的后面。首先定义指针find和add，分别指向需要插入的数和插入到的位置，之后进行相应的操作。
这些乱七八糟的代码可能会让不少初学者感到不适，所以在这里详细解释一下，以back==true的情况——即插入在后面为例。

我们需要在一条完整的双向链表中插入一项，更改的数据包括四项：我们需要插入的数据的front和back指针，以及被我们“破坏了”的find->next指针和原本是find->back的front指针。

 
    add->front = find;

    add->back = find->back;

这两行代码设置好了add即需要插入的数的两个指针，让它们分别指向插入到的位置和这个位置下一个，也就是back指针指向的位置。

 
     find->back = add;

接着，设置好find的back指针，让它指向需要添加的数。

 
    find = find->back->back;

    find->front = add;

然后，来到原本是find->back的位置，设置好front指针。这样，整个添加过程就完成了，插入在前面与后面的原理基本都是一样的。只不过若是插入在前面，有可能这个同学插入到了原先队首同学前，所以完成插入后需要再判断一下，更新一下队首的指针。

 
     if (ID == head->ID)head = add;

我们完成了实现插入的函数之后，删除就变得非常简单了，实现起来并没有什么困难（如果理解了插入的过程的话）。

 
```cpp
     void _cut(int ID)
    {
        queueDat *cut = &que[ID];
        if (cut->ID == head->ID)head = cut->back;
        cut = cut->front;
        cut->back = cut->back->back;
        cut = cut->back;
        cut->front = cut->front->front;
    }
```
到这里，程序主体部分就写完了，剩下的就是非常简单的模拟，按照题目的要求一步步来即可。
以下是完整代码。

 
    
    
    
    
    
    
```cpp
    #include<iostream>
    #include<cstring>    //仅用作memset
    using namespace std;
    struct queueDat
    {
        int ID;            //该同学的号码
        queueDat *front = NULL, *back = NULL;
    }que[100001];
    queueDat *head = &que[1];
    void _cut(int ID)
    {
        queueDat *cut = &que[ID];
        if (cut->ID == head->ID)head = cut->back;
        cut = cut->front;
        cut->back = cut->back->back;
        cut = cut->back;
        cut->front = cut->front->front;
    }
    void _add(int num, int ID, bool back)
    {
        queueDat *find = &que[ID], *add = &que[num];
        if (back)        //插入在后面
        {
            add->front = find;
            add->back = find->back;
            find->back = add;
            find = find->back->back;
            find->front = add;
            return;
        }
        else            //插入在前面
        {
            add->back = find;
            add->front = find->front;
            find = find->front;
            find->back = add;
            find = find->back->back;
            find->front = add;
            if (ID == head->ID)head = add;
        }
    }
    int main()
    {
        bool inQueue[100001]; memset(inQueue, false, sizeof(inQueue)); inQueue[1] = true;
        for (int i = 1; i < 100001; i++)
            que[i].ID = i;        //que[i]对应i号同学
        que[1].back = &que[1]; que[1].front = &que[1];
        int totStudents, a, b;
        cin >> totStudents;            //同学总数
        for (int i = 2; i <= totStudents; i++)    //i代表同学的号码
        {
            inQueue[i] = true;                    //确认i号同学在队列当中
            cin >> a >> b;                        //插入在a同学的 左边或右边
            _add(i, a, ((b == 0) ? false : true));
        }
        cin >> totStudents;
        for (int i = 0; i < totStudents; i++)
        {
            cin >> a;
            if (inQueue[a] == true)
            {
                inQueue[a] = false;
                _cut(a);
            }
        }
        b = head->ID;
        do
        {
            cout << head->ID << " ";
            head = head->back;
        } while (b != head->ID);
        cout << endl;
        system("pause");
        return 0;
    }
这道题目对于才刚刚接触链表不久的我和其它初学者来说或许有些难度，不过只要正确理解并掌握了链表的插入和删除操作，这种数据结构的相关题目其实也并没有多难。
```

---

## 作者：royzhu (赞：53)

/\*蒟蒻的我不会链表


所以我只能用树做了


思路：


1.用树存点与点之间的前后关系


2.用中序遍历的方法输出

\*/

```cpp
#include<cstdio>
struct lol{int lc,rc,v;} d[101000];//v表示是否被删，lc是左儿子(相当于当前点的前面的第一个数)，rc是右儿子 (相当于当前点的后面的第一个数)
void dfs(int x)//用中序遍历的方法输出 
{
    if(x==-1)return;//-1代表没空，如果该点为空就不需要再往下找 
    dfs(d[x].lc);//搜左儿子 
    if(d[x].v==0)printf("%d ",x);//搜完左儿子（相当于输完前面的人的编号）输出自己的编号 
    dfs(d[x].rc);//搜右儿子 
}
int main()
{
    int n,m;scanf("%d",&n);
    d[1].v=0;d[1].lc=d[1].rc=-1;
    //-1表示空，初始化第一个点 
    for(int i=2;i<=n;i++)
    {
        int x,y;scanf("%d %d",&x,&y);
        d[i].lc=d[i].rc=-1;d[i].v=0;//先初始化i点 
        if(y==0)
        {
            if(d[x].lc!=0)//当d[x]有左儿子，把当前点的左儿子设为d[x]的左儿子，d[x]左儿子设为当前点
            {d[i].lc=d[x].lc;d[x].lc=i;} 
            //否则，把d[x]有左儿子设为当前点
            else d[x].lc=i;
        }
        else
        {
            if(d[x].rc!=0)//当d[x]有右儿子，把当前点的右儿子设为d[x]的右儿子，d[x]右儿子设为当前点
            {d[i].rc=d[x].rc;d[x].rc=i;} 
            //否则，把d[x]有右儿子设为当前点
            else d[x].rc=i;
        }
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        int x;scanf("%d",&x);d[x].v=1;//删除x点 
    }
    dfs(1);//利用中序遍历输出 
}
```

---

## 作者：樱式分解 (赞：49)

#### 刚学链表，这道题正好可以来试一试。
1.首先，先建一个结构体，分left和right，然后一开始只有1号，要设一个边界，表的最左边是0,最右边是100010(因为数据大不过100010)。

2.接着对于每次插入，有左和右种情况，如A,C中插入B，就要改A的right，将A.right的C改为B,就要改C.left的A改为B,那新来的B呢？它的左右邻居就要赋值（B.left=A,B.right=C）。

3.对于每次删除，就要更新被删除者的左右两边数据，如A,B,C删除B,就要改B.left的右边（A.right）为C,就要改B.right的左边（C.left）为A。

4.最后输出时先从bib.right开始判断(一开始bib为0)，如果bib.right是有数据的，那么就输出并把下一个的bib跟新为bib.right以准备判断。如果bib.right是100010，也就是边界，说明没有后路了就退出。

### 具体代码如下
```
#include <iostream>
using namespace std;
int n,m;
int xx,p;
struct d{
    int left;
    int right;
}a[100010];
int yy;
int v[100010];
int main(){
    cin>>n;
    a[1].left=0;
    a[1].right=100010;
    a[0].right=1;
    for(int i=2;i<=n;i++){
        cin>>xx>>p;
        if(p==0)
        {
        a[i].left=a[xx].left,a[i].right=xx;
        a[a[xx].left].right=i;
        a[xx].left=i;
        }//分别更新插入者，插入者左和右的数据
        if(p==1)
        {
        a[i].right=a[xx].right,a[i].left=xx;
        a[a[xx].right].left=i;
        a[xx].right=i;
        }
    }
    int bib=0;
    cin>>m;
    for(int i=1;i<=m;i++){
        cin>>xx;
        if(!v[xx]){
        int s=a[xx].left;
        int b=a[xx].right;
        a[s].right=b;
        a[b].left=s;
        v[xx]=true;
        }//判重；
    }
    bib=0;
    v[0]=true;
    for(int i=1;i<=n;i++){
        bib=a[bib].right;
        if(bib!=100010)cout<<bib<<" ";
        else break;
    }
    return 0;
} 
```
### 用心写题解，希望给大家带来点帮助呀！

---

## 作者：天狗的手帖 (赞：27)

蒟蒻思路：当元素在左侧插入时看做一个先进先出的队列，在右侧插入时看做一个先进后出的栈。通过c++的STL中的vector和stack实现了这两种数据结构，并通过递归完成输出


```cpp

#include<cstdio>
#include<stack>
#include<vector>
#define N 100005

using namespace std;

vector<int>left[N];
stack<int>right[N];
int tot;
bool hash[N];

void print(int k)
{
    for (int i=0;i<left[k].size();i++) print(left[k][i]);
    
    if (hash[k]) 
    {
        tot--;
        if (!tot) printf("%d\n",k);
            else printf("%d ",k);
    }
    while (!right[k].empty())
    {
        print(right[k].top());
        right[k].pop();
    }
}

int main()
{
    int n,a,b,tmp;
    
    scanf("%d",&n);
    
    for (int i=2;i<=n;i++)
    {
        scanf("%d%d",&a,&b);
        if (!b) left[a].push_back(i);
            else right[a].push(i);
    }
    for (int i=1;i<=n;i++) hash[i]=true;
    tot=n;
    
    scanf("%d",&n);
    for (int i=1;i<=n;i++) 
    {
        scanf("%d",&tmp);
        if (hash[tmp])
        {
            tot--;
            hash[tmp]=false;
        }
    }
    
    print(1);
}

```

---

## 作者：Mr_Leceue (赞：27)

~~第一篇题解，啊，蒟蒻的我无比激动；~~


------------咳咳------------

说实话，写这道题是因为我们老师明天要考该类型，然后临时~~抱佛脚~~。。。


------------咳咳------------

好了说正事，这个是一个链式结构，确实也是线性，我们大家可以想象一下一个链子，一块一块连起来，是头挨头尾接尾
~~（这个说法好zz）~~

反正大家想象一下就好~~（我的物理老师告诉我做题都是要情景想象）~~

好的，大家都想象好了，然后我们就引进两个数组head[]，next[];
顾名思义，它就是头和尾的意思。思考一下，怎么连接呢？

大家可以查一下有一个叫 [前向星]((https://baike.baidu.com/item/前向星/8737279?fr=aladdin))
和 [链式前向星]((https://baike.baidu.com/item/链式前向星))
（ssfz神牛Malash最强），重点就是链式前向星，大家一定要看。

然后就有了这个
```
if(!p){ //放在左边 
            next[head[k]]=i;//断开链子并接上 
            head[i]=head[k];//将我们上一步完善 
            next[i]=k;// 连接下一个 
            head[k]=i;//将下一个的head连在i上 
        }else{//放在右边，而且具有对称性，比较容易来修改代码 
            head[next[k]]=i;
            next[i]=next[k];
            head[i]=k;
            next[k]=i;//由于同理，就不再解释了 
        }
```

大家可以手动模拟一下咯，受到链式前向星的启发就有了它；

		0	1	2	3	4
head    /	4	0	2	3
next	2	0	3	4	1

作为一个~~良心~~讲题人，上面是我模拟的（有错请指出，~~我没在纸上写~~）

再模拟几遍大家就应该知道了；

删去了话，其实也可以用链式的常规操作，但是我太懒，而数据又不是太大，所以开了个桶，操作简单。

再附上蒟蒻的代码
```
#include<bits/stdc++.h>//万能头 大家都在用吧 
using namespace std;
int n,tong[100007],m;//桶删数 
int head[100007],next[100007];//链式常规操作 
int main(){
    scanf("%d",&n);
    next[0]=1;//将0的下一个定为1 
    for(int i=2,p,k;i<=n;i++){
        scanf("%d%d",&k,&p);
        if(!p){ //放在左边 
            next[head[k]]=i;//断开链子并接上 
            head[i]=head[k];//将我们上一步完善 
            next[i]=k;// 连接下一个 
            head[k]=i;//将下一个的head连在i上 
        }else{//放在右边，而且具有对称性，比较容易来修改代码 
            head[next[k]]=i;
            next[i]=next[k];
            head[i]=k;
            next[k]=i;//由于同理，就不再解释了 
        }
    }
    scanf("%d",&m);
    for(int i=1,t;i<=m;i++){
        scanf("%d",&t);
        tong[t]=1;//tong删法 
    }
    for(int i=next[0];1;i=next[i]){
        if(!tong[i]) printf("%d ",i);
        if(!next[i]) break;/*为甚要放在后面而不是for循环上，
		大家可以试试，这样应该就能明白了 */
    }
} 
```
~~（呼，第一篇题解，好虚好虚）~~

这样大家就可以了解链式结构了
最后附上链式前向星，（板子可能不好，仅供参考）
```
void add(int a,int b,int w){
	edge[++cent].next=head[a];
	edge[cent].to=b;
	edge[cent].w=w;
	head[a]=cent;
}
```
有什么错误，请各位大佬指出，我会第一时间改的(｀・ω・´)

---

## 作者：niiick (赞：18)

###**经典序列操作竟然没人写splay？？？**

先加入两个哨兵结点0和n+1

插入操作
将编号为k的同学旋转到根

若p==1，编号k的下一位同学旋转到根的右子树，
然后将带插入的结点直接插入根的右子树的左子树

若p==0，编号k的上一位同学旋转到根的左子树，
然后将带插入的结点直接插入根的左子树的右子树

删除操作

找到编号x的同学的上一个同学旋转到根，
下一个同学旋转到根的右子树，
然后直接删除根的右子树的左子树

对于重复的开一个judge数组记录就好了

最后中序遍历输出
```
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return x*f;
}

const int maxn=200010;
int n,m;
int ch[maxn][2],fa[maxn],rt=1;
int size[maxn],v[maxn],pos[maxn],sz;
int judge[maxn];

void print(int p)
{
	if(!p) return;
	print(ch[p][0]);
	if(v[p]!=0&&v[p]!=n+1)printf("%d ",v[p]);
	print(ch[p][1]);
}

void update(int p)
{
	size[p]=size[ch[p][0]]+size[ch[p][1]]+1;
}

void rotate(int& p,int x) 
{ 
    int y=fa[x],z=fa[y]; 
    int d=(ch[y][0]==x);
    if(y==p) p=x; 
    else if(ch[z][0]==y) ch[z][0]=x; 
    else ch[z][1]=x;  
    fa[y]=x; fa[ch[x][d]]=y; fa[x]=z;  
    ch[y][d^1]=ch[x][d]; ch[x][d]=y;   
    update(y); update(x);  
} 

void splay(int& p,int x) 
{	
    while(x!=p) 
    {
        int y=fa[x],z=fa[y];
        if(y!=p) 
        {
            if((ch[y][0]==x)^(ch[z][0]==y)) rotate(p,x);
            else rotate(p,y);
        }
        rotate(p,x);
    }
}

void insert(int x)
{
	v[++sz]=x; pos[x]=sz;
	size[sz]=1; ch[sz][1]=ch[sz][0]=0;
	if(sz>1)
	{
		ch[sz-1][1]=sz; fa[sz]=sz-1;
		splay(rt,sz);
	}
}

int find(int p,int k)
{ 
    int ss=size[ch[p][0]]; 
    if(k==ss+1) return p;    
    if(k<=ss) return find(ch[p][0],k);
    else return find(ch[p][1],k-ss-1);  
}  

void ins(int x,int d,int k)//k号同学在x号同学的右(p==1)/左(p==0)边
{
	splay(rt,x);int y;
	if(d==1) y=find(rt,size[ch[x][0]]+2); //插入右边，找到x的下一个
	else y=find(rt,size[ch[x][0]]);//插入左边，找到x的上一个
	splay(ch[x][d],y);
	
	v[++sz]=k; pos[k]=sz;//插入
	size[sz]=1; ch[sz][1]=ch[sz][0]=0;
	fa[sz]=y; ch[y][d^1]=sz;
	update(y); update(x);
}

void del(int x)
{
	splay(rt,x);
	int y=find(rt,size[ch[x][0]]); //x的上一个同学
	int z=find(rt,size[ch[x][0]]+2); //x的下一个同学
	splay(rt,y); splay(ch[y][1],z);//上一个伸展到根，下一个伸展到根的右子树
	fa[ch[z][0]]=0; ch[z][0]=0;//删除
	update(z); update(y);
}

int main()
{
	n=read();
	insert(0); insert(n+1);//哨兵结点
	
	ins(pos[0],1,1);//先让1号入队
	for(int i=2;i<=n;++i)
	{
		int k=read(),p=read();
		ins(pos[k],p,i);
	}
	
	m=read();
	while(m--)
	{ 
	    int x=read(); if(judge[x]) continue; 
	    judge[x]=1;
	    del(pos[x]);
	}
	
	print(rt);
	return 0;
    //niiick
}
```

---

## 作者：一条咸鱼orz (赞：13)

# 总体思路:用数组来模拟队列(链表)

既然每次新同学入列都是在某个已入列同学的左侧或右侧 那么自然想到用两个数组

L[MAX]和R[MAX]来保存队列信息。

L[i]、R[i]分别记录第i个同学左侧同学和右侧同学的编号。(初始化为0)

这样只要知道K(即同学的编号)和P的值(0左侧 1右侧)就可以直接模拟入队操作。

仔细思考就知道 入队要分两种情况 这里以p=0 即插入k号同学左侧为例来说明。

(1)k号同学左侧没有同学 即L[k]=0时:

执行下列操作即可(i为当前入队的同学编号)
  ```cpp
  L[k]=i;
  R[i]=k
  ```
(2)k号同学左侧有同学 即L[k]!=0时:

先记录i同学的左右同学编号(因为后面要修改其左右同学的信息)

然后修改k号同学左侧同学的信息 即R[L[k]]=i

最后修改k号同学的信息 即L[k]=i

(顺序很重要!)
  ```cpp
  L[i]=L[k];
  R[i]=k;
  R[L[k]]=i;
  L[k]=i;
```

到此 我们的入队模拟已经完成了！

那么考虑输出的情况 既然是从向右输出编号 那么我们需要最左侧同学的编号 

当然可以循环遍历L[n]数组 L[i]=0时的i即是最左侧同学

这里提供另外一种方法 在执行入队操作的时候 我们用left标记最左侧同学的编号

当p=0 且入队操作已经模拟完成时 我们判断L[i]是否为0 若为0 则left=i 否则不做操作

好了 现在队列的头也有了 终于可以进行输出了！

但是题目还有出队的操作啊 其实没有必要进行出队的模拟了 

我们使用一个flag数组 初始化为0 读入出队的同学编号i 然后flag[i]=1

最后遍历队列的时候 若flag[i]=1则不进行输出即可 


以下是代码~
```cpp
#include<iostream>
using namespace std;

int L[100005],R[100005],flag[100005];

int main()
{
    int n,m,left=1;
    cin>>n;
    L[1]=0,R[1]=0;
    for(int i=2;i<=n;i++)
    {
        int temp1,temp2;
        cin>>temp1>>temp2;
        if(temp2==0)    //左侧
        {
            if(L[temp1]==0) //temp1左侧没有人
            {
                L[temp1]=i;
                R[i]=temp1;
            }
            else
            {
                L[i]=L[temp1];
                R[i]=temp1;
                R[L[temp1]]=i;
                L[temp1]=i;
            }
            if(L[i]==0) //i左侧没有人
                left=i;
        }
        else    //右侧
        {
            if(R[temp1]==0)
            {
                R[temp1]=i;
                L[i]=temp1;
            }
            else
            {
                L[i]=temp1;
                R[i]=R[temp1];
                L[R[temp1]]=i;
                R[temp1]=i;
            }
        }
    }
    cin>>m;
    for(int i=0;i<m;i++)
    {
        int temp1;
        cin>>temp1;
        flag[temp1]=1;
    }
    while(left!=0)
    {
        if(!flag[left])
            cout<<left<<' ';
        left=R[left];
    }
    return 0;
}

```

第一次写这么长的题解 求给过~~嘤嘤婴

---

## 作者：dy0607 (赞：8)

简单的双向链表

使用结构体指针的实现

```cpp

#include<cstdio>
struct node{
    int n;//保存节点的值
    node *left,*right;//左边右边各一个
    node(int t){//构造函数
        left=right=NULL;
        n=t;
    }
}*p[100010],*q;
int main(){
    int m,n,i,j,k,u=1,v;
    p[1]=new node(1);
    scanf("%d",&n);
    for(i=2;i<=n;i++){
        scanf("%d%d",&j,&k);
        p[i]=new node(i);
        if(k){//插入过程
            if(p[j]->right){
                p[j]->right->left=p[i];
                p[i]->right=p[j]->right;    
            }
            p[j]->right=p[i];
            p[i]->left=p[j];
        }
        else{
            if(p[j]->left){
                p[j]->left->right=p[i];
                p[i]->left=p[j]->left;    
            }
            p[j]->left=p[i];
            p[i]->right=p[j];
            if(j==u)u=i;//用u来记录链表开端
        }
    }
    scanf("%d",&m);
    for(i=1;i<=m;i++){//删除过程
        scanf("%d",&k);
        if(p[k]->left)
            p[k]->left->right=p[k]->right;
        if(p[k]->right){
            p[k]->right->left=p[k]->left;
            if(k==u)
                u=p[k]->right->n;
        }
        p[k]->left=p[k]->right=NULL;
    }
    q=p[u];
    while(q){//循环直到q为空
        printf("%d ",q->n);
        q=q->right;
    }
    return 0;
}

```

---

## 作者：CoolTeam (赞：7)

思路是**[color=red]模拟双向链表[/color]**，核心的添加和删除操作都是4行代码完成。

只要在笔上画画链表图、列列表思路就挺清晰的了。

壮我大**C语言**哉。（总耗时间264ms,最高单个数据93ms）

```cpp
#include<stdio.h>
int main(void)
{
    int right[110000]={0};
    int left[110000]={0};//模拟双向链表 
    int book[110000]={0};//在队列中则为1，方便删除操作的去重。 
    int n,m,i,j,k,p;
    scanf("%d",&n);
    book[1]=right[0]=1;//初始化，right[0]指向第一人(目前来说是编号1，即地址1) 
    for(i=2;i<=n;i++)
    {
        scanf("%d %d",&k,&p);
        book[i]=1;//表示在队列中 
        if(p==0) 
        {    
            right[i]=k;
            left[i]=left[k];
            right[left[k]]=i;
            left[k]=i; //4条指令完成添加元素到k左边的操作。 
        }
        else 
        {
            left[i]=k;
            right[i]=right[k];
            left[right[k]]=i;
            right[k]=i;//对称 
        }
    }
    scanf("%d",&m);
    int count=0;//存储重复删除的次数 
    for(i=1;i<=m;i++)
    {
        scanf("%d",&j);
        if(!book[j]) {count++;continue;} //不在队列中 
        right[left[j]]=right[j];
        left[right[j]]=left[j];
        left[j]=0;
        right[j]=0;//4条指令完成删除操作。 
        book[j]=0;//移出了队列 
    }
    int max=n-m+count,current=0;//因为right[0]存储了队列最前面的编号(即地址)。 
    for(i=0;i<max;i++)
    {
        current=right[current]; //从编号1开始遍历。 
        printf("%d ",current);
    }
    return 0; 
}
```

---

## 作者：封禁用户 (赞：7)

这其实是一道链表题  
但是vector优化一点加吸氧能水过去？？？  
吸氧+优化后 2.09s /  1.39MB  
#### 这充分地说明了某澡堂一位讲师的话：STL开O2跑的飞快 
#### 又印证了一句话：STL慢是以钟长者为首的一帮OI选手的偏见
### 但是，(NOIP && C++11) || (NOIP && 02) = false
### 不对，~~NOIP,它死了~~
不开O2会T3个点，40pts  
说一下find()函数吧  
#### find()：
- 库：algorithm
- 用法：find(first, end, value);  
- 作用：返回区间[first，end)中第一个值等于value的元素位置；若未找到，返回end。函数返回的是迭代器或指针。  

看代码吧
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

vector<int> que;
int n, k, p;
bool out[100010]; //统计是否删除过，这样就不用在vector里删了，省一点时间

int main() {
    scanf("%d", & n);
    vector<int>::iterator it; //迭代器
    que.push_back(1); //要把1先放进去
    for (int i = 1; i < n; i++) { //插入部分
        scanf("%d%d", & k, & p);
        if (p) que.insert(find(que.begin(), que.end(), k) + 1, i + 1); //在右边插入
        else que.insert(find(que.begin(), que.end(), k), i + 1); //在左边插入
    }
    scanf("%d", & k); //反正k和p闲的也是闲的后面又不需要，就把它们用着吧
    for (int i = 1; i <= k; i++)
        scanf("%d", & p), out[p] = true; //打上删除过的标记
    for (it = que.begin(); it < que.end(); it++)
        if (!out[*it]) printf("%d ", *it); //如果删过了就不输出
    return ~~（0-0）; //卖萌求通过
}
```

---

## 作者：judgejudge (赞：6)

# 双向链表（头尾）
这是一道比较标准的链表模板题。

题目的要求是：

1.  _起始队列里面只有一个人_

（那么我们设计一个**领头的变量head**来确定**从谁开始输出**）

2.  _依次放入编号为i的同学在编号为x的同学的左边或右边_

（我们可以设计**一个双向链表l数组和r数组**，用于记录**第i个位置上的同学左边和右边的编号**）

3.  _去掉某些同学_ 

利用双向链表改变前后位置的编号。



------------
## 1. 放入链表

```cpp
ll k,p;
		cin>>k>>p;
		if(p==0){//左边
			ll q=l[k];
			if(l[k]==0)l[k]=i,r[i]=k,head=i;//注意：l[k]为0时
            //要改变领头
			else r[q]=i,l[k]=i,l[i]=q,r[i]=k;//大家可以用笔推导一下
		}
		else{//右边
			ll q=r[k];
			if(r[k]==0)r[k]=i,l[i]=k;//同理
			else l[q]=i,r[k]=i,r[i]=q,l[i]=k;
		}
```


------------

## 2.删除元素
```cpp
cin>>m;
	for(i=1;i<=m;i++){
		ll k;
		cin>>k;
		if(l[k]==0)head=r[k];//注意改变head
		r[l[k]]=r[k];l[r[k]]=l[k];//程序填空常见题
		l[k]=-1;r[k]=-1;//最好改变值，否则90分
	}
```


------------
AC代码：
```cpp
#include <iostream>
using namespace std;
typedef long long ll;
ll l[100001],r[100001];
ll n,m,head=1,sum=0;//head起始为1
int main(){
	register int i,j;
	cin>>n;
	l[1]=0;r[1]=0;
	for(i=2;i<=n;i++){
		ll k,p;
		cin>>k>>p;
		if(p==0){
			ll q=l[k];
			if(l[k]==0)l[k]=i,r[i]=k,head=i;
			else r[q]=i,l[k]=i,l[i]=q,r[i]=k;
		}
		else{
			ll q=r[k];
			if(r[k]==0)r[k]=i,l[i]=k;
			else l[q]=i,r[k]=i,r[i]=q,l[i]=k;
		}//加入链表
	}
	cin>>m;
	for(i=1;i<=m;i++){
		ll k;
		cin>>k;
		if(l[k]==0)head=r[k];
		r[l[k]]=r[k];l[r[k]]=l[k];
		l[k]=-1;r[k]=-1;
	}//删除元素
	while(head!=0){
		cout<<head<<" ";
		head=r[head];
	}//利用链表查询的性质输出
	return 0;
}
```



---

## 作者：softsun (赞：6)

此题是利用数组模拟链表。
用结构体记录每个每个位置的人的前驱和后继，然后模拟插入和删除操作即可。
特别说明的是，只要初始化1号的前驱和后继为0，后面不用特判该节点的前驱和后继是否为空。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
   int pre,next;
};
node lst[100001];
int n,m,s,p;
int main(){
    cin>>n;
    lst[1].pre=0,lst[1].next=0;
    for(int i=2;i<=n;i++)
    {
        cin>>s>>p;
		if(p==0)  //插到s号的左边
		{
		    lst[lst[s].pre].next=i;	
			lst[i].pre=lst[s].pre;	
			lst[i].next=s;
			lst[s].pre=i;
		}
		else  //插入s号的右边
		{
		    lst[lst[s].next].pre=i;	
			lst[i].next=lst[s].next;
			lst[i].pre=s;
			lst[s].next=i;
		} 
    }
    cin>>m;
    for(int i=1;i<=m;i++)
    {
    	cin>>s;
    	if(lst[s].pre==-1&&lst[s].next==-1)  //此人已被删除 
		  continue; 
    	lst[lst[s].pre].next=lst[s].next;
    	lst[lst[s].next].pre=lst[s].pre;
    	lst[s].pre=-1;
    	lst[s].next=-1;
    }
    for(int i=1;i<=n;i++)
      if(lst[i].pre==0)
      {
      	 s=i;
      	 break;
      }
    do{
    	cout<<s<<" ";
    	s=lst[s].next;
    }while(s>0);
    return 0;
}
```
 

---

## 作者：月影困 (赞：6)

先上代码！！

```cpp
//这串是TLE的！！
//#include <cstdio>

//struct Node
//{
//	Node *front;
//	int value;
//	Node *next;
//};

//Node hd, tl;
//int mem[112345];

//Node* FindPos(int num)
//{
//	for (Node *i = hd.next; i->next != NULL; i = i->next)
//	{
//		if (i->value == num)
//			return i;
//	}
//	return NULL;
//}

//void Add(int num, int v, int dir)
//{
//	Node *n = new Node();
//	n->value = v;
//	if (dir == 1)
//	{
//		Node *pos = FindPos(num);
//		n->front = pos;
//		n->next = pos->next;
//		pos->next->front = n;
//		pos->next = n;
//	}
//	else
//	{
//		Node *pos = FindPos(num);
//		pos = pos->front;
//		n->front = pos;
//		n->next = pos->next;
//		pos->next->front = n;
//		pos->next = n;
//	}
//}

//void Del(int num)
//{
//	if (mem[num] == 1)
//		return;
//	Node *pos = FindPos(num);
//	if (pos != NULL)
//	{
//		mem[num] = 1;
//		pos->front->next = pos->next;
//		pos->next->front = pos->front;
//		delete pos;
//	}
//}

//void Print()
//{
//	for (Node *i = hd.next; i->next != NULL; i = i->next)
//	{
//		printf("%d ", i->value);
//	}
//}

//int main()
//{
//	freopen("testdata.in", "r+", stdin);
//	freopen("testdata.out", "w+", stdout);
//	
//	int a;
//	scanf("%d", &a);
//	Node *n = new Node();
//	n->front = &hd;
//	n->value = 1;
//	n->next = &tl;
//	hd.next = n;
//	hd.front = NULL;
//	tl.front = n;
//	tl.next = NULL;

//	for (int i = 2; i <= a; i++)
//	{
//		int k, p;
//		scanf("%d%d", &k, &p);
//		Add(k, i, p);
//	}
//	int m;
//	printf("MDZZ\n");
//	scanf("%d", &m);
//	for (int i = 1; i <= m; i++)
//	{
//		int x;
//		scanf("%d", &x);
//		Del(x);
//	}

//	Print();

//	return 0;
//}

//这串是正确的！！！
#include <cstdio>

// 我们定义一个结构体作为双向链表的节点。
// front和next分别存放前后两个节点的下标。

struct Node
{
	int front;
	int next;
}ls[112345]; // 多开点hhhh

int hd; // 用来标记第一个元素下标。

void Add(int num, int k, int p)
{
	if (p == 1)
	{
    	// 链表的插入了解一下！这个初赛都要考的啊！！
        // 这里虽然做了一些改变，但是大同小异！
        // 关于指针链表的插入，请去被注释的里面找！
		ls[num].front = k;
		ls[num].next = ls[k].next;
		ls[ls[k].next].front = num;
		ls[k].next = num;
	}
	else
	{
    	// 如果要插入到前面，就找到前一个位置。
        // 然后就和插入到后面一样辣！
		k = ls[k].front;
		ls[num].front = k;
		ls[num].next = ls[k].next;
		ls[ls[k].next].front = num;
		ls[k].next = num;
	}
}

void Del(int num)
{
	//如果front == -1，就表示已经被删除了，不用查找。
	if (ls[num].front != -1)
	{
		ls[ls[num].front].next = ls[num].next;
		ls[ls[num].next].front = ls[num].front;
		ls[num].front = -1;
	}
	
}

void Print()
{
	// 链表的遍历了解一下！
	for (int i = ls[0].next; i != -1; i = ls[i].next)
	{
		printf("%d ", i);
	}
}

int main()
{
//	freopen("testdata.in", "r+", stdin);
//	freopen("testdata.out", "w+", stdout);
	// 这里我们把ls[0]作为第一位左侧的一个空位，便于插入。
	ls[1].front = 0;
	ls[1].next = -1;
	ls[0].next = 1;
	ls[0].front = -1;
	
	int n;
	scanf("%d", &n);
	for (int i = 2; i <= n; i++)
	{
		int k, p;
		scanf("%d%d", &k, &p);
		Add(i, k, p);
	}
	
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		int x;
		scanf("%d", &x);
		Del(x);
	}
	
	Print();
	
	return 0;
}

```


------------


这题目咱一看，emmm，很妙，练习**手打链表**嘛……
然后吭哧吭哧写了一大串前面被注释的代码……
前面的为什么要被注释呢？前面这串明明运行的好好的啊！
因为咱**tle**了三个点……（叹气
![](https://cdn.luogu.com.cn/upload/pic/15603.png )

……
emmmmmm……

那怎么优化呢？
仔细一想，查找删除的时候好像挺费劲啊！
要查到末尾才能跳出！
标记一下被删的就不用找了不就好了嘛！！

……

然后我就又T了……OTL



------------


下面是真正的题解！
因为这里的元素都不重复的，所以我们直接用数组模拟链表，其下标表示学生的编号，这样寻找一个元素就是O(1)，就非常稳当，避免了之前找一个数得从头到尾跑的麻烦，自然轻松自如AC。
其余说明请见代码中注释！！



---

## 作者：zhaowangji (赞：5)

很久以前看到，今天才做。苦于没有满足该性质的数据结构，于是——手工模拟（看了别人的题解，原来这算链表？）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;//由题
struct node{
	int r;//左边
	int l;//右边
}a[100007];
void dcout(int k){//不断找右边的人
	if(!a[k].r)return;//右边没人了
	cout<<a[k].r<<' ';//输出当前右边的人
	dcout(a[k].r);//找右边的人的右边
}//其实您也可以用递归的方法先找队尾，压栈输出他的左边
int main(){
	cin>>n;
	for(int i=2;i<=n;i++){//注意是第2~n个人
		int k,p;
		cin>>k>>p;//最好按照题目里来
		if(p==0){//在左边
			a[i].r=k;i的右边是k
			a[i].l=a[k].l;i的左边是原来k的左边
			a[a[k].l].r=i;原来k的左边的人，现在的右边是i
			a[k].l=i;k的左边是i
		}
		else {//在右边
			a[i].l=k;//i的左边是k
			a[i].r=a[k].r;//i的右边是原来k的右边
			a[a[k].r].l=i;//原来k的右边的人，现在的左边是i
			a[k].r=i;k的右边是i
		}
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;//由题
		a[a[x].l].r=a[x].r;//x的左边的人，现在的右边是原来x的右边
		a[a[x].r].l=a[x].l;//x的右边的人，现在的左边是原来x的左边
		a[x].l=a[x].r=0;//把x的左右两边都删除，不然下面输出不好找最左边的人
	}
	for(int i=1;i<=n;i++)
		if(!a[i].l&&a[i].r){//左边没人了，并且右边还有人，说明这是队头
			cout<<i<<' ';//先把队头输出
			dcout(i);//找他的右边
			break;
		}
	return 0;
}
```


---

## 作者：chauchat (赞：4)

觉得自己的代码看起来最舒服所以贴一个。


思路就是插入的时候改变插入的位置左右两边节点的指向

前继改变next域，后继pre，然后插入。

删除的时候把两个值搞成-1就行了。


把0的next指向第一个节点，最后输出就行了。

```cpp
#include<iostream>
using namespace std;
#include<cstring>

struct node{
    int pre;
    int next;
}queue[100010];
int n,m,head;

int main()
{
    cin>>n;
    queue[0].next = 1;
    queue[1].pre = 0;queue[1].next = -1;
    for(int i = 2;i <= n;i++)
    {
        int k,p;cin>>k>>p;
        if(p)
        {
            queue[i].pre = k;
            queue[queue[k].next].pre = i;
            queue[i].next = queue[k].next;
            queue[k].next = i;
        }else
        {
            queue[i].next = k;
            queue[queue[k].pre].next = i;
            queue[i].pre = queue[k].pre;
            queue[k].pre = i;
        }
    }
    cin>>m;
    for(int i = 1;i <= m;i++)
    {
        int temp;cin>>temp;
        
        if(queue[temp].next == -1 && queue[temp].pre == -1)
            continue;
        
        queue[queue[temp].pre].next = queue[temp].next;
        queue[queue[temp].next].pre = queue[temp].pre;
        queue[temp].next = queue[temp].pre = -1;
    }
    int k = queue[0].next;
    while(k != -1)
    {
        cout<<k<<' ';
        k = queue[k].next;
    }
    return 0;
}
```

---

## 作者：StephenYoung (赞：3)

手工实现双向链表的好题吧。

#### 思路

一看数据范围，就知道$n^2$的算法过不了，恰好今日看资料时做到了一道双向链表的题。于是就往这方面想了。

#### 具体实现

插入一个数会有几个数的关系受到影响，就以插在左边为例。

我们先设$L[x]$表示$x$左边嘅数，$R[x]$表示$x$右边嘅数。

一次插入$p$在$i$嘅左边，$R[i]$就变咗$x$,$R[L[p]]$就变咗$i$,$L[i]$就变咗$L[p]$,$L[p]$再变成$i$。

右边同理。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=100000+5;
int n,L[maxn],R[maxn],m,st;
bool vis[maxn];

int main()
{
	scanf("%d",&n);
	for(int i=2;i<=n;i++)
	{
		int p,op;
		scanf("%d%d",&p,&op);
		if(!op)
		{
			R[i]=p;
			R[L[p]]=i;
			L[i]=L[p];
			L[p]=i;
		}
		else
		{
			L[i]=p;
			L[R[p]]=i;
			R[i]=R[p];
			R[p]=i;
		}
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%d",&x);
		if(vis[x]) continue;
		R[L[x]]=R[x];
		L[R[x]]=L[x];
		vis[x]=1;
	}
	for(int i=1;i<=n;i++)
	{
		if(L[i]==0&&vis[i]==0)
		{
			st=i;
			break;
		}
	}
	for(int i=st;;i=R[i])
	{
		if(R[i])
		printf("%d ",i);
		if(R[i]==0)
		{
			printf("%d\n",i);
			break;
		}
	}
	return 0;
}
```


---

## 作者：A_little_fresh (赞：3)

不多说，本萌新就用最最普通的链表模拟一遍，一次过了=。=
基本就是酱紫：

Accepted  100
用时: 112ms / 内存: 5730KB

先来一波定义：
```
#include <cstdio>
#include <cstdlib>
#include <iostream>

using namespace std;

struct Ndlk
{
    struct Ndlk * last;
    int num;
    struct Ndlk * next;
};
```

这个就定义了一个最普通的同学，左边我计作last，右边我计作next，分别指向左边的和右边的同学。

然后就进入int main()部分：

```
int main()
{
    int n,m,p,k,i,nu;
    while (scanf("%d",&n)!=EOF)
    {
        Ndlk ** arr=(Ndlk **)calloc(n+1,sizeof(Ndlk *));   //这其实是个数组声明 Ndlk * arr[n+1] ;
        arr[0]=NULL;//这个无用，纯粹习惯初始化
        Ndlk *tmp;// 临时中间变量，各种用途
        int first=1; //最左边同学编号，方便最后输出
        for (i=1;i<=n;i++)
            arr[i]=(Ndlk *)calloc(1,sizeof(Ndlk)),
            arr[i]->num=i ,arr[i]->last=NULL ,arr[i]->next=NULL ;
```

先把1号同学塞进去，一开始他前后都没有人，没有人就指向NULL。

考虑到我一会儿要找人删人=。=，第一瞬间想到的是map……然后摸索了下（还是不是很熟练，所以）还是放弃了，决定用一个 
```
struct Ndlk *
```
类型的数组记录每个学生结构体的地址，用动态分配就变成了上面这个可能某些大佬不太习惯的 
```
Ndlk ** arr=(Ndlk **)calloc(n+1,sizeof(Ndlk *));
```
至于那个first变量，我是用来记录最左边的同学编号，方便我一会儿输出，最开始就一个1号同学，自然初始化为1。

初始化完成后，模拟插入就开始了：请看~~：
```
	for (i=2;i<=n;i++)
        {
            scanf("%d %d",&k,&p);
            if (k==first && p==0)
                first=i;//如必要，更新最左边同学编号
            if (p==0)
            {
                arr[i]->next=arr[k];//i同学的右边更新
                arr[i]->last=arr[k]->last;
                					//i同学的左边更新
                arr[k]->last=arr[i];
                    //本质是i同学右边同学的左侧指向更新
                if (arr[i]->last!=NULL)
                    arr[i]->last->next=arr[i];
                    //最后是i同学左边同学的右侧指向更新
            }
            if (p==1)		//类同上面说明
            {
                arr[i]->last=arr[k];
                arr[i]->next=arr[k]->next;
                arr[k]->next=arr[i];
                if (arr[i]->next!=NULL)
                    arr[i]->next->last=arr[i];
            }
        }
```
读取玩k,q后，确定并更新下最左边的同学编号，显然只有当k和first相同并且向左插入（p为0）的时候才成立。

接下来就是分p==0 和 p==1 两种情况 插入i号同学节点的过程
值得注意的是：i号同学的last 和 next 很容易确定，但原先的两位（或一位）同学的last 或 next 都要注意更新。一开始本宝宝就是漏掉了一半，导致（!$@$!$我就不说了）的奇怪死亡=。=

插入完成就是删除同学了
考虑了下，打算最后统一free（）动态分配的空间，所以，
删除过一次的同学把他的号码变成0，然后读取完搜索前判断下号码是不是0就可以了，就像酱紫：

```
	scanf("%d",&m);
        for (i=0;i<m;i++)
        {
            scanf("%d",&nu);
            if (arr[nu]->num==0) continue;
			//跳过无意义删除
            if (first==nu) first=arr[nu]->next!=NULL ?
            			 arr[nu]->next->num : 0 ;
			// 如必要，更新最左边同学编号（first）
            if (arr[nu]->last!=NULL)
                arr[nu]->last->next=arr[nu]->next;
            if (arr[nu]->next!=NULL)
                arr[nu]->next->last=arr[nu]->last;
                //更新删除节点的左右链接
            arr[nu]->next=NULL ,//没有小伙伴了
            arr[nu]->last=NULL ,//同上
            arr[nu]->num=0;//没有这个同学了，防无意义删
        }
```

同样的，我更新了first便于后面的输出。删除节点就是把左边的同学（如果有）的next改为右边的同学的地址（若左边有变不必管右边是不是NULL），同理跟新右边的同学（如果有）的last。
对于要删除的同学，last和next改为NULL，号码改为0，便于跳过重复删除的判断。

然后就是对剩下同学的基本输出操作了。

```
 for (tmp=arr[first];tmp->next!=NULL;tmp=tmp->next)
            printf("%d ",tmp->num);
        printf("%d\n",tmp->num);

        for (i=0;i<=n;i++)
            if (arr[i]!=NULL)
                free(arr[i]);
        free(arr);
    }
    return 0;
}
```
养成好习惯，free()掉动态分配的所有空间=。=

完整代码如下：

```
// luogu-judger-enable-o2
#include <map>
#include <set>
#include <stack>
#include <cstdio>
#include <string>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

struct Ndlk
{
    struct Ndlk * last;
    int num;
    struct Ndlk * next;
};

int main()
{
    int n,m,p,k,i,nu;
    while (scanf("%d",&n)!=EOF)
    {
        Ndlk ** arr=(Ndlk **)calloc(n+1,sizeof(Ndlk *));
        arr[0]=NULL;
        Ndlk *tmp;
        int first=1;
        for (i=1;i<=n;i++)
            arr[i]=(Ndlk *)calloc(1,sizeof(Ndlk)),
            arr[i]->num=i ,arr[i]->last=NULL ,arr[i]->next=NULL ;
        for (i=2;i<=n;i++)
        {
            scanf("%d %d",&k,&p);
            if (k==first && p==0)
                first=i;
            if (p==0)
            {
                arr[i]->next=arr[k];
                arr[i]->last=arr[k]->last;
                arr[k]->last=arr[i];
                if (arr[i]->last!=NULL)
                    arr[i]->last->next=arr[i];
            }
            if (p==1)
            {
                arr[i]->last=arr[k];
                arr[i]->next=arr[k]->next;
                arr[k]->next=arr[i];
                if (arr[i]->next!=NULL)
                    arr[i]->next->last=arr[i];
            }
        }
        scanf("%d",&m);
        for (i=0;i<m;i++)
        {
            scanf("%d",&nu);
            if (arr[nu]->num==0) continue;

            if (first==nu) first=arr[nu]->next!=NULL ? arr[nu]->next->num : 0 ;

            if (arr[nu]->last!=NULL)
                arr[nu]->last->next=arr[nu]->next;
            if (arr[nu]->next!=NULL)
                arr[nu]->next->last=arr[nu]->last;
            arr[nu]->next=NULL ,arr[nu]->last=NULL ,arr[nu]->num=0;
        }
        for (tmp=arr[first];tmp->next!=NULL;tmp=tmp->next)
            printf("%d ",tmp->num);
        printf("%d\n",tmp->num);

        for (i=0;i<=n;i++)
            if (arr[i]!=NULL)
                free(arr[i]);
        free(arr);
    }
    return 0;
}
```




---

## 作者：_zjr (赞：3)

# 双向链表！！！
### 这一道题看到题面，插入，删除emmm……
我这个蒟蒻灵稽一动，这不是双向链表吗？
于是就有了如下的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct student//结构体，代表学生
{
    int right,left;//右指针和左指针
}stu[100010];
int vis[100010];//标记数组，标记是否删过
int main()
{
    // freopen("arrange.in","r",stdin);
    // freopen("arrange.out","w",stdout);
    stu[0].right=1;
    stu[0].left=1;
    stu[1].left=0;
    stu[1].right=0;//初始化链表，用一般用不着的0当做引子
    int n,m;
    int k,p;
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
        scanf("%d %d",&k,&p);
        if(p==0)//在k的左边插入
        {
            stu[stu[k].left].right=i;//k左边的右边的元素的右指针指向要插入的学生
            stu[i].left=stu[k].left;//要插入的学生的左指针指向k学生原来的右边
            stu[i].right=k;//要插入的学生的右指针指向k
            stu[k].left=i;//k的左指针指向要插入的学生
            // printf("stu[%d].right=%d stu[%d].left=%d \n",i,stu[i].right,i,stu[i].left);
        }
        if(p==1)//同上
        {
            stu[stu[k].right].left=i;
            stu[i].right=stu[k].right;
            stu[i].left=k;
            stu[k].right=i;
            // printf("stu[%d].right=%d stu[%d].left=%d \n",i,stu[i].right,i,stu[i].left);
        }
    }
    scanf("%d",&m);
    int x;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&x);
        if(vis[x]==1) continue;//如果之前删除过一次就不要再删了，不然会WA掉
        else 
            {
                vis[x]=1;//打上已经删除过的标记
                stu[stu[x].left].right=stu[x].right;
                stu[stu[x].right].left=stu[x].left;
            }
        // printf("x=%d stu[stu[%d].left].right=%d stu[stu[%d].right].left=%d\n",x,x,stu[stu[x].left].right,x,stu[stu[x].right].left);
    }
    // for(int i=0;i<=n;i++)
    // {
    // 	printf("stu[%d].right=%d stu[%d].left=%d \n",i,stu[i].right,i,stu[i].left);
    // }
    int tmp=0;
    for(int i=1;i<=n;i++)
    {
        if(stu[tmp].right!=0)//如果右边的学生是0的话，就不要输出了
        {
            printf("%d ",stu[tmp].right);
            tmp=stu[tmp].right;
        }
        else break;
    }
    // fclose;
    // fclose;
    return 0;
}

```
这道题就这么被A掉了

---

## 作者：priority_queue (赞：3)

```cpp
#include<cstdio>
#include<cstring> //这个库没用 
int n,a,b,k,u[100000];
//双向链表
struct studen{
    int l,r;//l表示前驱编号，r表示后继编号 ，以编号代替指针 ； 
}d[100000];//同学编号 
int main(){
    scanf("%d",&n);
    d[0].r=1,d[1].l=0;//d[0]是头节点，d[1]入队； 
    for(int i=2;i<=n;i++){
        scanf("%d%d",&a,&b);
        //插入至右边； 
        if(b) {
            d[d[a].r].l=i;  
            d[i].r=d[a].r;
            d[a].r=i;
            d[i].l=a;
        }
        //插入至左边； 
        else{
            d[d[a].l].r=i;
            d[i].l=d[a].l;
            d[a].l=i;
            d[i].r=a;
        }
    }
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a);
        if(u[a]==1) continue;//u数组记录是否已删； 
        u[a]=1;//更新记录 
        d[d[a].l].r=d[a].r;
        d[d[a].r].l=d[a].l;
    }
    //从头结点d[0]开始 
    for(int i=0;;){
        printf("%d",d[i].r);
        i=d[i].r;
        if(d[i].r) printf(" ");//如果有下一个输出空格 
        else break;//没有下一个则结束 
    }
    return 0;
}
```

---

## 作者：知光 (赞：3)

我们可以把每一个同学都看成一个一个的点，每在两个同学中插入一个新同学就把这两位同学间原来的边断裂，由新同学连接起左右的同学，问题一下子就变得非常简单了。
以样例为例
![](http://imgsrc.baidu.com/forum/pic/item/da59193eb80e7bec69cb2fc4202eb9389b506b5f.jpg)
怎么样，够简单吧？
代码献上↓↓↓
```cpp
#include<bits/stdc++.h>
using namespace std;
struct  node{
	int date,fa=-1,to;//date记录此点编号，fa♂是左边的点，to是右边的点
}f[1000000];
int num=1,n;
int o[1000000]={0};//记录哪些点要挖去
void unify(int a,int b,int array)//这个是连接点和断边的
{
	if(b==0)
	{   
	    f[array].fa=f[a].fa;
	    f[array].to=a;
	    f[array].date=array;
		f[f[a].fa].to=array;
		f[a].fa=array;
	}
	else
	{
		f[array].fa=a;
	    f[array].to=f[a].to;
	    f[array].date=array;
		f[f[a].to].fa=array;
		f[a].to=array;
	}
}
int main()
{
	int x,y,m;
	scanf("%d",&n);
	f[1].date=1;
	for(int i=2;i<=n;i++)
	{
	 scanf("%d%d",&x,&y);
	 unify(x,y,i);//注入灵魂
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
	 scanf("%d",&x);
	 o[x]=1;	
	}
	int sx=f[1].fa;
	while(1)//找到最左边的点
	{
	 if(f[sx].fa==-1)
	 break;
	 else
	 sx=f[sx].fa;
	}
	for(int i=sx;i;i=f[i].to)//从左到右刚刚好
	{
		if(!o[i])
		printf("%d ",i);
	}
	return 0;
}
```
圆满结束。
如有不足敬请斧正。

---

## 作者：____lhx____ (赞：3)

```cpp
#include<cstdio>
int n,m,i,j,k,p,t,c;
struct pd{
    int l=0,r=0; //记录左边和右边
}q[100005];
int main(){ //不用指针的链表 直接记录
    int head=1; //记录队头
    scanf("%d",&n);
    for(i=2;i<=n;i++){
        scanf("%d%d",&k,&p);
        if(p){
            q[i].r=q[k].r;
            q[k].r=i;
            q[i].l=k;
            q[q[i].r].l=i; //插到右边
        }
        else{
            q[i].l=q[k].l;
            q[k].l=i;
            q[i].r=k;
            q[q[i].l].r=i; //插到左边
            if(k==head) head=i; //更新队头
        }
    }
    scanf("%d",&m);
    for(i=1;i<=m;i++){
        scanf("%d",&t);
        q[q[t].r].l=q[t].l;
        q[q[t].l].r=q[t].r;
        q[t].l=q[t].r=0; //删除元素
    }
    printf("%d",head);
    p=head;
    while(q[p].r){
        p=q[p].r;
        printf(" %d",p);//输出直到右边为零的 直到队尾
    }
    return 0;
}
```

---

## 作者：桀骜的野心家 (赞：3)

我就是用链表乱搞一下就过了。代码也写的非常的傻，a数组存每个数的前一个数，b数组存下一个数是什么，如果a数组中的存的是-1，表示这个数没有前一个数，如果b数组是0表示这个数没有下一个数。top用来存第一个数。

```cpp
#include<cstdio>  
#include<cstring>  
using namespace std;  
int a[100001];  
int b[100001];  
int n,m,i,j,k,top;  
int main()  
{int x,l;  
    memset(a,0,sizeof(a));  
    scanf("%d",&n);  
    b[1]=-1;  
    top=1;  
    for (i=2;i<=n;i++)  
      {  
        scanf("%d%d",&x,&l);  
        if (l==0)  
           {  
             if (b[x]==-1)  
                  {  
                     top=i;  
                     a[i]=x;  
                     b[i]=-1;  
                     b[x]=i;  
                  }  
                  else  
                   {  
                     b[i]=b[x];  
                     a[b[x]]=i;  
                     a[i]=x;  
                     b[x]=i;  
                   }  
           }  
        else {  
             if (a[x]==0)  
                  {  
                     a[x]=i;  
                     b[i]=x;  
                     a[i]=0;  
                  }  
                else   
                 {  
                    b[i]=x;  
                    a[i]=a[x];  
                    b[a[x]]=i;  
                    a[x]=i;  
                 }  
             }  
      }  
      scanf("%d",&m);  
      for (i=1;i<=m;i++)  
         {  
         scanf("%d",&x);  
         if (b[x]!=-1)  
             {  
                a[b[x]]=a[x];  
             }  
         if (a[x]!=0)  
             {  
                b[a[x]]=b[x];  
                if (b[a[x]]==-1) top=a[x];  
             }  
         b[x]=-1;  
         a[x]=0;  
         }  
        k=top;  
        while (k!=0)  
          {  
            printf("%d ",k);  
            k=a[k];  
          }  
}
```

---

## 作者：蒟蒻lxy (赞：2)

编写者：[QAQer](https://www.luogu.org/space/show?uid=34500)

欢迎到[我的博客](https://www.luogu.org/blog/lxy0508cpp/#type=%E9%A2%98%E8%A7%A3)中查看
### 拿到题目，一看：插入+删除
### 那肯定就是链表啊QWQ

思路：

用双向链表维护学生队列的插入~~显而易见~~   
但删除可以用别的办法

神奇的方法:

> 本来如果用链表删除的话比较难打、易错   
> 所以我们想想   
> 我们为什么不用标记法呢？   
> 把要删掉的用一个数组记录下来，输出时跳过不就可以了吗？

代码中的used数组就是这样的QAQ

### ~~终于到了~~代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct student//学生 
{
	int id,left,right;//分别记录学生编号，前驱、后继节点 
}a[100005];//双向链表 
int n,head=1,tail=1,m;//head、tail是链表的起始位置和结尾位置 
bool used[100005];//删除用的 
void print()//输出 
{
	int h=head;
	//cout << head <<' '<< tail <<"\n\n"; //调试，请忽略 
	while(h!=tail)//遍历一遍输出 
	{
		if(!used[a[h].id])//如果没被删掉 
			printf("%d ",a[h].id);//输出 
		h=a[h].right;//跳到下一个同学 
	}
	if(!used[a[h].id])//还有最后一个没输出 
		printf("%d\n",a[h].id);
}
int insert_left(int x,int p)//左插入(插入位置,插入元素)
{
	if(x!=head)//如果不是第一位，就可以访问x的前驱节点 
		a[a[x].left].right=p,a[p].left=a[x].left;//链表基本操作 
	a[x].left=p;//链表基本操作 
	a[p].right=x;//链表基本操作 
	if(x==head)//更新起始节点 
		head=p;
}
int insert_right(int x,int p)//把insert_left反过来就行了 
{
	if(x!=tail)//同上 
		a[a[x].right].left=p,a[p].right=a[x].right;//同上
	a[x].right=p;//同上
	a[p].left=x;//同上
	if(x==tail)//同上
		tail=p;//同上
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)//初始化学生的编号 
		a[i].id=i;
	for(int i=2;i<=n;i++)//从第二个开始 
	{
		int k,w;
		scanf("%d%d",&k,&w);
		if(w==1)
			insert_right(k,i);//左插入 
		else
			insert_left(k,i);//右插入 
	}
	cin >> m;
	for(int i=1;i<=m;i++)
	{
		int k;
		scanf("%d",&k);
		used[k]=1;//删掉 
	}
	print();//输出
	return 0;
}
//QAQ完美QAQ 
```


---

## 作者：地表最强男人 (赞：2)

这题需要对整个队列进行插入和删除的操作，如果用数组或者队列就不能这么方便的操作，所以想到了插入与删除最方便的结构——链表。

我用了一个结构体存储每一个节点
```cpp
struct rec{
	int fr,ba;//fr是左边,ba是右边 
	bool cz;//是否存在队列中 
}edge[200010];
```
然后模拟

- 插入的操作，为了防止出现RE，我进行了特判，一般时候，如果插入在左边的话，将这个元素设为num,要插入在fa的左边,原来fa的左边是fuc，我们要把num的左边标记为fuc,num的右边标记为fa,fa的左边标记为num,fuc的右边标记为num，然后特殊情况比如fa为最左边要特判，还有插入右边基本相同,注意标记队头，要不后面遍历的时候会很麻烦
```cpp
for(int i=2;i<=n;i++)
{
		int c,num;
		cin>>num>>c;
		if(c==0)
		{
			if(edge[num].fr!=-1)
				edge[edge[num].fr].ba=i;
			edge[i].fr=edge[num].fr;
			edge[i].ba=num;
			edge[num].fr=i;
			edge[i].cz=true;
		}
		if(c==1)
		{
			if(edge[num].ba!=-1)
				edge[edge[num].ba].fr=i;
			edge[i].ba=edge[num].ba;
			edge[i].fr=num;
			edge[num].ba=i;
			edge[i].cz=true;
		}
		if(edge[i].fr==-1)
			st=i;//每次更新标记队头
}
```
- 删除的话也差不多,一般情况该数为num,原来左边为fa,右边为fuc,我们可以将num标记为不在队列中,把fa的右边赋值为fuc,fuc左边赋值为fa，需要对num为最左边和最右边特判，也要记得处理队头，代码如下
```cpp
for(int i=1;i<=m;i++)
{
		int num;
		cin>>num;
		if(edge[num].cz==false)
			continue;
		if(edge[num].fr==-1)
		{
			edge[num].cz=false;
			int numm=edge[num].ba;
			edge[numm].fr=-1;
			st=numm;//如果删除的是最左边，记得更新队头
			continue;
		}
		if(edge[num].ba==-1)
		{
			edge[num].cz=false;
			int nunn=edge[num].fr;
			edge[nunn].ba=-1;
			continue;
		}
		edge[num].cz=false;
		int numm=edge[num].ba,nunn=edge[num].fr;
		edge[nunn].ba=numm;
		edge[numm].fr=nunn;
}
```
- 然后访问就行了
```cpp
while(st!=-1)
{
		cout<<st<<" ";
		st=edge[st].ba;
}
```
- 整体代码如下
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
struct rec{
	int fr,ba;//fr是左边,ba是右边 
	bool cz;//是否存在队列中 
}edge[200010];
int n,m,st;
int main()
{
      cin>>n;
      edge[1].fr=-1,edge[1].ba=-1,edge[1].cz=true,st=1;
      for(int i=2;i<=n;i++)
      {
          int c,num;
          cin>>num>>c;
          if(c==0)
          {
              if(edge[num].fr!=-1)
                  edge[edge[num].fr].ba=i;
              edge[i].fr=edge[num].fr;
              edge[i].ba=num;
              edge[num].fr=i;
              edge[i].cz=true;
          }
          if(c==1)
          {
              if(edge[num].ba!=-1)
                  edge[edge[num].ba].fr=i;
              edge[i].ba=edge[num].ba;
              edge[i].fr=num;
              edge[num].ba=i;
              edge[i].cz=true;
          }
          if(edge[i].fr==-1)
              st=i;
      }
      cin>>m;
      for(int i=1;i<=m;i++)
      {
          int num;
          cin>>num;
          if(edge[num].cz==false)
              continue;
          if(edge[num].fr==-1)
          {
              edge[num].cz=false;
              int numm=edge[num].ba;
              edge[numm].fr=-1;
              st=numm;
              continue;
          }
          if(edge[num].ba==-1)
          {
              edge[num].cz=false;
              int nunn=edge[num].fr;
              edge[nunn].ba=-1;
              continue;
          }
          edge[num].cz=false;
          int numm=edge[num].ba,nunn=edge[num].fr;
          edge[nunn].ba=numm;
          edge[numm].fr=nunn;
      }
      while(st!=-1)
      {
          cout<<st<<" ";
          st=edge[st].ba;
      }
}
```



---

## 作者：momo5440 (赞：2)

和诸多前辈所说的一样这题其实就是一个双向链表的模板题（~~有插入和删除的肯定是链表了~~），在调了好久以后本蒟蒻终于ac了这题，这题的标准解法就是拿个数组记录下标为i的人的左右的编号，然后每进来，或出去就维护一下原理我就不多说了毕竟已经有那么多前辈说完了，这里只给出代码。
```cpp
#include <iostream>
using namespace std;
struct node{
    int left,right;
    bool alive;
};//结构体
node a[100005];
int main(){
    int n,i,m,j,k,t1,t2;
    cin>>n;
    for (i=1;i<=n;i++) a[i].left=-1,a[i].right=-1,a[i].alive=1;//初始化
    for (i=2;i<=n;i++){
        cin>>t1>>t2;
        if(t2==0){
            if (a[t1].left==-1){
                a[i].right=t1;
                a[t1].left=i;
                a[i].left=-1;
                continue;
            }//特判，即t1为最左边的
            a[i].right=t1;
            a[i].left=a[t1].left;
            a[a[t1].left].right=i;
            a[t1].left=i;
        }
        if(t2==1){
            if (a[t1].right==-1){
                a[i].left=t1;
                a[t1].right=i;
                a[i].right=-1;//同理，t1为最右边的
                continue;
            }
            a[i].left=t1;
            a[i].right=a[t1].right;
            a[a[t1].right].left=i;
            a[t1].right=i;插入操作
        }
    }
    cin>>m;
    int sum=0;
    for (i=1;i<=m;i++){
        cin>>t1;
        if (a[t1].alive==0) continue;
        if (a[t1].left==-1){
            a[a[t1].right].left=-1;
            a[t1].alive=0;
            //a[t1].left=-1;
            //a[t1].right=-1;
            continue;//仍是特判
        }
        if (a[t1].right==-1){
            a[a[t1].left].right=-1;
            //a[t1].right=-1;
            //a[t1].left=-1;
            a[t1].alive=0;
            continue;//仍是特判
        }
        a[a[t1].left].right=a[t1].right;
        a[a[t1].right].left=a[t1].left;
        a[t1].alive=0;//交换，并删除
    }
    int head=0;
    for (i=1;i<=n;i++){
        if (a[i].left==-1&&a[i].alive==1){
            head=i;
            break;
        }//寻找开头
    }
    while (a[head].right!=-1){
        cout<<head<<' ';
        head=a[head].right;
    }//依次输出
    cout<<head;//最后一个没被输出
    return 0;
}
```
然后我就陷入了思考，有没有什么偷懒的方法呢（~~毕竟我最懒了~~），当然有，其实再删除过程中我们根本没必要将左右的交换，因为在遍历时只用把他跳过去就行了，但要注意遍历时的结束条件，上代码
```cpp
#include <iostream>
using namespace std;
struct node{
	int left,right;
	bool alive;
};
node a[100005];
int main(){
	int n,i,m,j,k,t1,t2;
	cin>>n;
	for (i=1;i<=n;i++) a[i].left=-1,a[i].right=-1,a[i].alive=1;
	for (i=2;i<=n;i++){
		cin>>t1>>t2;
		if(t2==0){
			if (a[t1].left==-1){
				a[i].right=t1;
				a[t1].left=i;
				a[i].left=-1;
				continue;
			}
			a[i].right=t1;
			a[i].left=a[t1].left;
			a[a[t1].left].right=i;
			a[t1].left=i;
		}
		if(t2==1){
			if (a[t1].right==-1){
				a[i].left=t1;
				a[t1].right=i;
				a[i].right=-1;
				continue;
			}
			a[i].left=t1;
			a[i].right=a[t1].right;
			a[a[t1].right].left=i;
			a[t1].right=i;
		}
	}
	cin>>m;
	int sum=n;//记录存活个数
	for (i=1;i<=m;i++){
		cin>>t1;
		if (a[t1].alive==0) sum--;
		/*if (a[t1].left==-1){
			a[a[t1].right].left=-1;
			a[t1].alive=0;
			continue;
		}
		if (a[t1].right==-1){
			a[a[t1].left].right=-1;
			a[t1].alive=0;
			continue;
		}
		a[a[t1].left].right=a[t1].right;
		a[a[t1].right].left=a[t1].left;*///全废了（笑） 
		a[t1].alive=0;
	}
	int head=0;
	for (i=1;i<=n;i++){
		if (a[i].left==-1){
			head=i;
			break;
		}
	}
	int sum2=0;
	while (a[head].right!=-1){
		if (a[head].alive==1) cout<<head<<' ',sum2++;//如果他还活着（笑）
		head=a[head].right;
		if (sum==sum2) break;//如果输出数跟剩余的一样就提前结束
	}
	if (a[head].alive==1) cout<<head;（有可能最后一个还是活着的）
	return 0;
}
```
当然，这样会慢一些，一个是213ms,另一个是182ms,但这无伤大雅，起码在这题上是这样的。
求管理员大大让我过谢谢

---

## 作者：Blind_God (赞：2)

##来一波蠢蠢哒题解庆祝下（贡献我来啦）

```cpp
#include<iostream>
using namespace std;
int k,n,m,a[100005][2],i,p,q,s;  //用二维数组表示数字右边和左边分别是什么数字
void lj(int n)   //用函数找到队首
{
    s=n;
    if(a[n][0]!=0)
      lj(a[n][0]);
}
void zwz(int s)  //用以输出的函数（递归向右）
{
    cout<<s<<" ";
    if(a[s][1]!=0)
      zwz(a[s][1]);
}
int main()
{
    cin>>n;
    for(i=2;i<=n;i++)
      {
          cin>>p>>q;
          if(q==0)  //q=0时，数字p的左边是i
            {
                a[i][0]=a[p][0];   //将数字p本来左边的数赋给i
                a[a[p][0]][1]=i;
                a[p][0]=i;  //数字p的左边是i，i的右边是p
                a[i][1]=p;
            }
          if(q==1)  //q=1时，数字p的右边是i
            {
                a[i][1]=a[p][1];  //同上
                a[a[p][1]][0]=i;
                a[p][1]=i;  //同上
                a[i][0]=p;
            }
      }
    cin>>m;
    for(i=1;i<=m;i++)
      {
          cin>>k;
          if(a[a[k][0]][1]==k)  //判断k是否在队列中
            {
                a[a[k][0]][1]=a[k][1];  //将k左右的数连起来，相当于去掉了k
              a[a[k][1]][0]=a[k][0];
            }
      }
    lj(1);  //括号里面......随便啦(￣▽￣)~*
    zwz(s);  //输出
    return 0;  //打“return 0”是个好习惯￣▽￣
}
```

---

## 作者：SEELE (赞：2)

一道双向链表初级题。

nxt数组是指向下一个元素的指针。

prv数组是指向前一个元素的指针。

dat数组记录学生是否被删。

可以空着数组中第0个元素进行初始化。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int dat[100001], nxt[100001],prv[100001];
int main()
{
    int n,i,k;
    cin >> n;
    nxt[0] = 1; dat[1] = 1; prv[1] = 0;\\初始化
    for (i = 2; i <= n; i++)
    {
        int k, p;
        cin >> k >> p;
        dat[i] = i;
        if (p)
        {
            nxt[i] = nxt[k];
            nxt[k] = i;
            prv[i] = k;
            prv[nxt[i]] = i;
//在第i个元素后插入数据
        }
        else
        {
            int tem = prv[k];
            nxt[tem] = i;
            prv[i] = tem;
            nxt[i] = k;
            prv[k] = i;
//在第i个元素前插入数据
        }
    }
    cin >> n;
    for (i = 1; i <= n; i++)
    {
        cin >> k;
        dat[k] = 0;
    }
    i = 0;
    while (true)
    {
        i = nxt[i];
        if (!i)
        {
            cout << endl;
            break;
        }
        if (dat[i])
            cout << dat[i] << ' ';
    }
    return 0;
}
```

---

## 作者：ROOToj (赞：2)



非常简单的链表&模拟问题，运用链表就成了最最简单的模拟题，但要注意：链表改变左右值时不能写反，否则会乱七八糟的。


附上AC源代码​：


















































```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define MAXN 1000010
int left[MAXN],right[MAXN],n,i,a,f,m,first=1;
int main()
{
    memset(left,-1,sizeof(left));
    memset(right,-1,sizeof(right));
    left[1]=right[1]=0;
    left[0]=right[0]=1;
    scanf("%d",&n);
    for(i=2;i<=n;i++)
    {
        scanf("%d%d",&a,&f);
        if(!f)
        {
            right[left[a]]=i;
            left[i]=left[a];
            left[a]=i;
            right[i]=a;
        }
        else
        {
            left[right[a]]=i;
            right[i]=right[a];
            right[a]=i;
            left[i]=a;
        }
    }
    scanf("%d",&m);
    for(i=1;i<=m;i++)
    {
        scanf("%d",&f);
        if(left[f]<0)continue;
        right[left[f]]=right[f];
        left[right[f]]=left[f];
        left[f]=right[f]=-1;
    }
    i=0;
    for(;;)
    {
        if(!right[i]){putchar('\n');return 0;}
        if(first){printf("%d",right[i]);first=0;}
        else printf(" %d",right[i]);
        i=right[i];
    }
}
```
​

​-------------------------------------------END-------------------------------------------​​​​​​​​​


---

## 作者：spacetime (赞：2)

鉴于下面没有用指针模拟链表的Pascal程序，我还是贴一个吧：

type
    list=^node;//指针模拟双向链表

    node=

record
```cpp
        key:longint;
        left,right:list;
    end;
var
    n,i,p,k:longint;
    place:array[1..100000] of list;
    head,tail:list;
begin
    read(n);
    new(place[1]);
    place[1]^.key:=1;
    head:=place[1];
        tail:=place[1];
    for i:=2 to n do
    begin
        new(place[i]);
        place[i]^.key:=i;
        read(k,p);
        if p=0 then
        begin
            if place[k]=head then head:=place[i]
                        else
                        begin
                                place[k]^.left^.right:=place[i];
                                place[i]^.left:=place[k]^.left;
                        end;
                        place[k]^.left:=place[i];
            place[i]^.right:=place[k];
        end
        else
        begin
                        if place[k]=tail then tail:=place[i]
                        else
                        begin
                                place[k]^.right^.left:=place[i];
                                place[i]^.right:=place[k]^.right;
                        end;
            place[k]^.right:=place[i];
            place[i]^.left:=place[k];
        end;
    end;
    read(n);
    for i:=1 to n do
    begin
        read(k);
                if place[k]<>nil then
                begin
                   if place[k]=head then head:=place[k]^.right
                   else place[k]^.left^.right:=place[k]^.right;
                       if place[k]=tail then tail:=place[k]^.left
                       else place[k]^.right^.left:=place[k]^.left;
                       place[k]:=nil;
//这里place[k]一定要赋成nil，dispose释放空间时并不会把指针变成nil
                       dispose(place[k]);//释放空间，这句不加亦可
                end;
    end;
    while head<>tail do
    begin
        write(head^.key,' ');
        head:=head^.right;
    end;
    writeln(head^.key);
end.
```

---

## 作者：汇文客 (赞：2)

PASCAL的指针并不是太灵活，于是很多同学选用数组模拟。这很好。还要补充一点，第一遍排完后，用一个数组记录各数位置，这样每次删除时间复杂度都是O(1)。

```delphi

type list=record
     id,pre,suc:longint;
end;
var a:array[0..100001]of list;
    v:array[0..100001]of longint;
    n,m,h,t,i,x,z:longint;
begin
  readln(n);
  a[1].id:=1;
  a[1].pre:=0;h:=1;
  a[1].suc:=0;t:=1;
  for i:=2 to n do
  begin
    readln(x,z);
    a[i].id:=i;
    case z of
    0:begin
        if a[x].pre=0 then
        begin
          a[i].pre:=0;
          a[i].suc:=a[x].id;
          a[x].pre:=a[i].id;
          h:=i;
        end else
        begin
          a[i].pre:=a[a[x].pre].id;
          a[a[x].pre].suc:=a[i].id;
          a[i].suc:=a[x].id;
          a[x].pre:=a[i].id;
        end;
      end;
    1:begin
        if a[x].suc=0 then
        begin
          a[i].suc:=0;
          a[i].pre:=a[x].id;
          a[x].suc:=a[i].id;
        end else
        begin
          a[i].suc:=a[a[x].suc].id;
          a[a[x].suc].pre:=a[i].id;
          a[i].pre:=a[x].id;
          a[x].suc:=a[i].id;
        end;
      end;
    end;
  end;t:=h;z:=0;
  while t<>0 do
  begin
    inc(z);
    v[t]:=z;
    t:=a[t].suc;
  end;
  readln(m);
  for i:=1 to m do
  begin
    readln(x);
    if v[x]=0 then continue;
    if a[x].pre=0 then
    begin a[a[x].suc].pre:=0;h:=a[x].suc;end
    else if a[x].suc=0 then
    a[a[x].pre].suc:=0 else
    begin a[a[x].pre].suc:=a[x].suc;
    a[a[x].suc].pre:=a[x].pre;end;
    v[x]:=0;
  end;t:=h;
  while t<>0 do
  begin
    write(t,' ');
    t:=a[t].suc;
  end;
end.

```

---

## 作者：Shallowy (赞：2)

不得不说，**这题非常适合学习、理解指针和链表**。

所以建议初学者一定要用链表（指针）做做看。（比如我这样的蒟蒻就交了n遍，不过受益匪浅...）

题意也很清楚，是最基本的插入、删除操作，但注意点应该也不少：

### 1.千万不要让对空指针（NULL）操作这种事情发生！在赋值前要判断。
### 2.不是所有指针一开始都new就行，比如要将p1=p2，则只要*p1,new p2,然后p1=p2，而不能new p1再=p2...
### 3.听说这题输出格式很萎哈...

指针这东西一定要多看多试，几次之后总能搞清的...反正别怕烦
贴上我那丑陋的c++代码
```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#define rep(x,y) for(int i=x;i<=y;i++)
using namespace std; 
int rd(){int x=0; char c=getchar(); 
    while(!isdigit(c)) c=getchar(); 
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-48,c=getchar(); 
    return x;
}  //读优
inline void rt(int x){x>=10?rt(x/10),putchar(x%10+48):putchar(x+48);}  //输优
int n,m,x; 
struct je{
    int data;
    je *next,*pre;
};
je *p,*h=new je; //p在后面会附掉，不用new
int main(){ 
    n=rd(); je *pp[n+1]; //指针数组pp
    h->data=1,h->next=h->pre=0,pp[1]=h; //对指针，0=NULL
    rep(2,n){
        x=rd(),p=pp[x]; je *q=new je; q->data=i;
        if(rd())
            q->next=p->next,p->next=q,q->pre=p,pp[i]=q,
            q->next?(q->next->pre=q):0;  //一定要判断是否为空指针，下同
        else
            q->pre=p->pre,p->pre=q,q->next=p,pp[i]=q,
            q->pre?(q->pre->next=q):(h=q);
    }  //以上为插入
    m=rd(); 
    rep(1,m){
        x=rd();
        if(!pp[x]) continue; else p=pp[x],pp[x]=0; 
        if(p->pre) p->pre->next=p->next; 
        if(p->next) p->next->pre=p->pre;
    }  //以上为删除
    while(h) rt(h->data),h=h->next,putchar(h?' ':'\n'); //格式...
    return 0; 
}
```

---

## 作者：Undefined_Myth (赞：2)

毕竟水平有限，对指针不熟悉，发一波模拟双向链表。——也十分好用。


```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
#define INF 100000+5
int n,m;
int bef[INF+1],nex[INF+1];
bool book[INF+1];
//对于此题目我们用数组模拟双向链表的方法 
//输入输出优化 
inline void read(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
inline void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
int main() 
{
    read(n);
    //最开始1入列    初始化操作 
    book[1]=true;    bef[1] = 0;    nex[1] = 0;
    for(int i=2;i<=n;i++)
    {
        int k,p;
        read(k),read(p);
        if(p == 0)//放在k左边 
        {
            int temp = bef[k];//用temp保存之后将会更改的值为了配合i的处理 
            book[i] = true;//入队操作
            //对k的前面后面的数进行调整 
            nex[temp] = i;
            bef[k] = i;
            //别忘记了对i的前面后面的处理 
            bef[i] = temp;
            nex[i] = k; 
            //printf("%d %d ",bef[k],nex[k]);静态调试 
        }
        else//放在k右边 
        {
            int temp = nex[k];
            book[i] = true;
            bef[temp] = i;
            nex[k] = i;
            bef[i] = k;
            nex[i] = temp;
            //printf("%d %d ",bef[k],nex[k]);
        }
    }
    //printf("%d %d ",bef[1],nex[1]);
    read(m);
    for(int i=1;i<=m;i++)
    {
        int x;
        read(x);
        if(!book[x])
            continue;
        else
        {
        int temp = nex[x];
        bef[temp] = bef[x];
        nex[bef[x]] = temp;
        book[x] = false;
        }
        //printf("%d %d ",bef[nex[x]],nex[nex[x]]);
    }
    int pos=nex[0];
    while(pos != 0)//输出挂着的这条链表，末尾是0 
    {
        write(pos);
        printf(" "); 
        pos = nex[pos];
    } 
        return 0; 
}
```

---

## 作者：wzxx (赞：2)

萌新来发一篇数组模拟双向链表的题解~

代码似乎长了点？不过思路是很清晰的，具体看注释。



```cpp
#include<iostream>
#include<cstdio>
    using namespace std;
    int Node[100005],L[100005],R[100005];//Node存放学生的编号，L存放第i个人左边的人在哪里，R存放第i个人右边的人在哪里
int main()
{
    int n=0,m=0;
    scanf("%d",&n);//读入 
    Node[1]=1;//第一个人先进去 
    for(int i=2;i<=n;i++)
    {
        int x=0,y=0;
        scanf("%d%d",&x,&y);//读入 
        Node[i]=i;//记录第i个人的编号 
        if(y==0)//如果是插入到左边 
        { 
            R[i]=x;//第i个人右边那个人的位置自然是x 
            if(L[x]>0)//如果第x个人不是最左边的话 
            {
                L[i]=L[x];//第i个人左边那个人的位置就是原先x左边那个人的位置 
                R[L[x]]=i;//原先x左边那个人的右边就是i 
            }
            L[x]=i;//x的左边就是i 
        }
        else//否则 
        {
            L[i]=x;//第i个人左边那个人的位置就是x 
            if(R[x]>0)//如果第x个人不是最右边 
            {
                R[i]=R[x];//第i个人右边那个人的位置就是原先x右边那个人的位置 
                L[R[x]]=i;//原先x右边那个人的左边就是i 
            }
            R[x]=i;//x的右边就是i 
        }//P.S:这段else里的代码就是把上面的反转一下，左变右，右变左...... 
    }
    scanf("%d",&m);//读入 
    for(int i=1;i<=m;i++)
    {
        int x=0;
        scanf("%d",&x);
        Node[x]=-1;//被去掉的人标记为-1 
    }
    for(int i=1;i<=n;i++)
        if(L[i]==0)//找到最左边的那个人 
        {
            int T=i;
            while(T>0)//开始遍历，输出 
            {
                if(Node[T]!=-1) printf("%d ",Node[T]);//如果没被去掉，就输出 
                T=R[T];//移到接下来的右边那个人 
            }
        }
    return 0;
}
谨此纪念第一道AC的链表题
```

---

## 作者：road (赞：1)

## 一道……
嗯，做这道题之前我还不知道链表是个啥，上来直接暴力，20分，用了一点小优化，30……想了大概十多分钟，突然想到用结构体储存他的前面和后面分别是啥，那么我在更新的时候就不用循环了，复杂度瞬间减小，然后就A了，后来在看其他人的题解时才知道这个东西叫链表……上代码……
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100008;
int m,n,now,vis[N];//n个点//m次删除//当前队列的第一个点//这个点是否在队列中 
struct node
{
	int before;
	int next;
}a[N];//结构体储存这个点的前后元素分别是什么 
int main()
{
	scanf("%d",&n);
	now=1;//当前第一个点是1 
	for(int i=2;i<=n;i++)
	{
		int p,q;scanf("%d%d",&p,&q);
		if(q==0&&p!=now){//若这个点不是更新在第一个点之前 
			a[i].before=a[p].before;//更新这个点的前后元素 
			a[i].next=p;
			a[a[p].before].next=i;//更新这个点之前的点的尾元素 
			a[p].before=i;//更新这个点之后的点的前元素 
		}
		else if(q==0&&p==now){//若这个点更新在第一个点之前 
			a[p].before=i;
			a[i].next=p;
			now=i;//更新now 
		}
		else if(q==1){//这个点更新在某个点之后 
			a[i].before=p;
			a[i].next=a[p].next; 
			a[a[p].next].before=i;
			a[p].next=i;
		}
		//若这个点更新在原本最后一个点的后面是不用更新他的尾元素的值的，想想为什么？ 
	}
	scanf("%d",&m);//进行m次删除操作 
	for(int i=1;i<=m;i++)
	{
		int l;
		scanf("%d",&l);
		if(!vis[l]){//这个点是否在队列中 
			a[a[l].before].next=a[l].next;//将这个点的前一个点的尾元素更新为这个点的尾元素 
			a[a[l].next].before=a[l].before;//这一步可以删去，因为我们这时候只需要知道它的下一个点是什么。 
			vis[l]=1;//这个点已经没在队列之中 
		}
	}
	while(now){
		printf("%d ",now);
		now=a[now].next;//下一个now 
	}
	return 0;
} 	//圆满谢幕 
```


---

## 作者：ModestCoder_ (赞：1)

pascal里貌似有个叫数组模拟链表的东西~~~

只要定义两个数组：l[i]表示i同学左边的人，r[i]表示i同学右边的同学

每次更新分为两种可能：
- 把i插到k左边：那么i的右边变成k，i的左边变成l[k]，l[k]的右边变成i，k的左边变成i
- 把i插到k右边：那么i的左边变成k，i的右边变成r[k]，r[k]的左边变成i，k的右边变成i

如何删除？
若要删掉x，只要：把l[x]的右边变成r[x]，r[x]的左边变成l[x]即可。
但若x已经被删掉了，就不能再删了，否则会影响答案，所以用一个flag记录是否被删

如何输出？
显然，整个输出序列中只有最左边那一个数（即最先输出的）的l数组为0，那么一层循环找一下就好了。输出后把当前这个数变成右边那个数就好了

Code：
```
//该解释的上面已经解释好了，Code也很好理解的
var
    l,r:array[0..1000000] of longint;
    flag:array[0..1000000] of boolean;
    n,k,p,i,x,m:longint;

begin
    readln(n);
    for i := 2 to n do
    begin
        readln(k,p);
        if p = 0 then
        begin
            r[i] := k;
            l[i] := l[k];
            r[l[k]] := i;
            l[k] := i;
        end else
        begin
            l[i] := k;
            r[i] := r[k];
            l[r[k]] := i;
            r[k] := i;
        end;
    end;
    readln(m);
    for i := 1 to m do
    begin
        readln(x);
        if flag[x] then continue;
        flag[x] := true;
        l[r[x]] := l[x];
        r[l[x]] := r[x];
    end;
    for i := 1 to n do if (l[i] = 0) and not flag[i] then break;
    while i <> 0 do
    begin
        write(i,' ');
        i := r[i];
    end;
end.
```

---

## 作者：圣光天子 (赞：1)

这道题使用建树的方法。
可以发现在插入时，将放置在左边的节点设为k的“左子树”，右边的节点设为“右子树”，然后就可以形成一个树形的结构，但不是二叉树。
那么子树怎么储存呢？我发现可以使用一维邻接表，将“左子树”和“右子树”分开存储，则只需要n的储存空间来将所有的节点存下来。
接着对存储的节点进行一趟中序遍历。但注意“左子树”要按照从输入前往后的顺序遍历，“右子树”则是从后往前的顺序遍历。同时删除的节点在遍历中不输出即可。
时间复杂度O(n)
```pascal
program line;
var
  lchild,rchild,lnext,lfirst,llast,rnext,rlast:array[0..100000] of longint;
  b:array[0..100000] of boolean;
  i,j,n,m,k,p,tot,lt,rt:longint;
procedure build(t,k,i:longint);
begin
  if t=0 then begin
    inc(lt);
    if lfirst[k]=0 then lfirst[k]:=lt;
    lchild[lt]:=i;
    lnext[llast[k]]:=lt;
    llast[k]:=lt;
  end;
  if t=1 then begin
    inc(rt);
    rchild[rt]:=i;
    rnext[rt]:=rlast[k];
    rlast[k]:=rt;
  end;
end;
procedure dfs(k:longint);
var i:longint;
begin
  i:=lfirst[k];
  while i>0 do begin
    dfs(lchild[i]);
    i:=lnext[i];
  end;
  if b[k] then write(k,' ');
  i:=rlast[k];
  while i>0 do begin
    dfs(rchild[i]);
    i:=rnext[i];
  end;
end;
begin
  readln(n);
  tree[1]:=1;
  for i:=2 to n do begin
    readln(k,p);
    build(p,k,i);
  end;
  b[0]:=false;
  for i:=1 to n do b[i]:=true;
  readln(m);
  for i:=1 to m do begin
    read(k);
    b[k]:=false;
  end;
  dfs(1);
end.
```

---

## 作者：thhhty (赞：1)

****EMMM这里是来自一个真正蒟蒻的题解。。
解法上应该和前面的各位大佬用的链表是一样的
是简单粗暴的用结构体存l,r记录这个人左右人的编号
上代码吧还是=)
```c
#include<cstdio>
#include<cstring>
#include<cstdlib>
using namespace std;
struct node
{
	int l,r,c;//c只是判断是否被删的，或者说是贮存的编号？（感觉木有必要）
	node()
	{
		l=r=c=0;
	}
}ren[360000];
void print(int x)//输出
{
	if(ren[x].c>0)printf("%d ",ren[x].c);
	if(ren[x].r!=0)print(ren[x].r);//右边还有人就继续找
	return ;
}
int find_l(int x)
{
	if(ren[x].l==0)return x;//左边木有人这个就是最前面的了~
	else return find_l(ren[x].l);//找左边还有木有人
}
int main()
{
	int n,m,op,x;
	scanf("%d",&n);
	ren[1].l=ren[1].r=0;ren[1].c=1;
	for(int i=2;i<=n;i++)
	{
		scanf("%d%d",&x,&op);
		if(op==0)
		{
			int l=ren[x].l;//十分暴力的。。找到原来左边的人
			ren[l].r=i;//告诉它右边现在是i
			ren[x].l=i;//告诉x左边是i
			ren[i].l=l;//下面懒得打了。。。大约这个意思
			ren[i].r=x;
		}
		else
		{
			int r=ren[x].r;
			ren[r].l=i;
			ren[x].r=i;
			ren[i].l=x;
			ren[i].r=r;
		}
		ren[i].c=i;
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int x;
		scanf("%d",&x);
		ren[x].c=0;//被删掉就变0吧。。。（懒得再拆一个又重新拼起来。）
	}
	int root=find_l(1);
	print(root);
	return 0;
}
```
以上是一个蒟蒻简单粗暴的代码。。（应该挺好懂得）

---

## 作者：Qiu233 (赞：1)








```cpp
#include <iostream>
using  namespace std;
//用双向链表（似乎单向也可以？懒得想）完成的，效率还不错吧。。最慢的点用了80ms
//这是比较正统的链表算法，如果加上一些骚操作，可能会更快？
int n, m;
typedef struct node//链表的每一个节点
{
    bool removed;//标识是否移除
    node *prev;
    node *next;
    int i;//学生的编号
}node;
node *d[100001];//这不是链表，只是用来储存学生编号和节点的对应关系
int head = 1;//链头在数组d的位置
void insert(int i, int k, int p)//将编号i的学生插入到编号k的学生的旁边，操作为p
{
    d[i] = new node{ 0,0,0,0 };//即将插入的元素
    d[i]->i = i;
    if (p == 0)//左边
    {
        //设置新属性
        d[i]->next = d[k];//新元素的后继指向原元素的后继
        d[i]->prev = d[k]->prev;//前驱指向原元素的前驱
        if (d[k]->prev != NULL)
            d[k]->prev->next = d[i];//原元素的前驱的后继(WTF)指向新元素
        d[k]->prev = d[i];//原元素的前驱指向新元素
        //这个很重要，我们需要保证head始终指向链头，如果一个新元素插入到了头部的左边，那么他就是新头
        if (k == head)
            head = i;
    }
    else if (p == 1)//右边，与上面类似，只是不需要处理头部的位置
    {
        d[i]->prev = d[k];
        d[i]->next = d[k]->next;
        if (d[k]->next != NULL)
            d[k]->next->prev = d[i];
        d[k]->next = d[i];
    }
}
int main()
{
    cin >> n;
    d[1] = new node{ 0,0,0,0 };//第一个元素，也就是初始的链头
    d[1]->i = 1;
    for (int i = 0; i < n - 1; i++)
    {
        int k, p;
        cin >> k >> p;
        insert(i + 2, k, p);//插入数据
    }
    //到这里为止，所有的学生都已经归位，接下来只需要执行移除操作
    cin >> m;
    for (int i = 0; i < m; i++)
    {
        int x;
        cin >> x;
        d[x]->removed = true;//设置移除的标识
    }
    node *e = d[head];
    while (e != NULL)
    {
        //如果没有移除才输出，否则跳过
        if (!e->removed)
            cout << e->i << " ";
        e = e->next;
    }
    return 0;
}
```

---

## 作者：嚯呀嚯呀 (赞：1)

```cpp
var
  a1,a2,a3,i,j,m,n,k,p:longint;
  before,next,a,check,num:array[0..1000000]of longint;
begin
  readln(n);
  before[1]:=0; next[1]:=0;
  for i:=2 to n do
    begin
      readln(k,p);
      if p=0 then
        begin
          next[i]:=k;
          before[i]:=before[k];
          next[before[k]]:=i;
          before[k]:=i;
        end;
      if p=1 then
        begin
          before[i]:=k;
          next[i]:=next[k];
          before[next[k]]:=i;
          next[k]:=i;
        end;
    end;
   for i:=1 to n do
     if before[i]=0 then
       begin
         a1:=i; break;
       end;
   inc(a2); a[a2]:=a1; num[a1]:=a2;
   for i:=2 to n do
     begin
       a1:=next[a1];
       inc(a2);a[a2]:=a1; num[a1]:=a2;
     end;
   for i:=1 to n do check[i]:=1;
   readln(m);
   for i:=1 to m do
     begin
       readln(a3);
       check[num[a3]]:=0;
     end;
   for i:=1 to n do
     if check[i]<>0 then
       write(a[i],' ');
end.
//用离散化思想 next数组表示这个位置数的后一个数。 before数组表示这个数的前一个数（没用的，我用来找第一个数是什么）
num数组表示这个数所在的位置是什么。 a数组是真实的排列组合方式。 check数组用来标记被排出去的数。 很简单吧
```

---

## 作者：nkoi18 (赞：1)

简单的链表模拟

看了一下下面的题解，都是输出是去找队首，其实可以定一个first变量记录队首变化：

1.在队首左边插入时修改队首

2.在删除时修改队首为右边的人

附上代码 希望对大家有帮助

```cpp
#include <iostream>
#include <cstdio>
struct ff{
    int left;
    int right;
    ff() {
        left=0;
        right=0;
    }
}queue[100001];
using namespace std;
int fl[100001]={0};
int main()
{
    int n,m,first=1;fl[1]=1;
    cin>>n;
    for(int i=2;i<=n;i++)
      {
          int k,p;
          cin>>k>>p;
          if(p)
            {
                if(queue[k].right)
                  {
                      queue[queue[k].right].left=i;
                      queue[i].right=queue[k].right;
                  }
                 queue[k].right=i;
                 queue[i].left=k;
            }
          else
            {
                if(queue[k].left)
                  {
                      queue[queue[k].left].right=i;
                      queue[i].left=queue[k].left;
                      queue[k].left=i;
                      queue[i].right=k;
                  }
                else
                  {
                      queue[k].left=i;
                      queue[i].right=k;
                      first=i;
                  }
            }
          fl[i]=1;
      }
    cin>>m;
    for(int i=1;i<=m;i++)
      {
          int x;
          cin>>x;
          if(fl[x])
            {
                queue[queue[x].left].right=queue[x].right;
                queue[queue[x].right].left=queue[x].left;
                fl[x]=0;
                if(x==first)
                  first=queue[x].right;
            }
      }
    int c=first;
    while(c)
      {
          cout<<c<<" ";
          c=queue[c].right;
      }
    return 0;
}
```

---

## 作者：普通的萝莉控 (赞：1)

嘿嘿……

用数组模拟链表~比较简单的模板题呢

分别用addl和addr和qpop表示在pos的左边/右边添加一个x和把X移出队列

- 个人感觉还是比较简单易懂





```cpp
- #include<iostream>
- #include<cstdlib>
- #include<cstdio>
- #include<cstring>
- #include<cmath>
- #include<algorithm>
- #include<stack>
- using namespace std;
- const int maxn=1e5+10;
- int read() {
- char ch=getchar();int ret=0;
- int neg=1;
- while(ch<'0'||ch>'9') {
- if(ch=='-') neg=-1;
- ch=getchar();
- }
- while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
- return ret*neg;
- }
- int l[maxn],r[maxn];
- int n,outq[maxn],m;
- void addl(int pos,int x) {
- l[x]=l[pos];
- r[x]=pos;
- r[l[pos]]=x;
- l[pos]=x;
- }
- void addr(int pos,int x) {
- r[x]=r[pos];
- l[r[pos]]=x;
- l[x]=pos;
- r[pos]=x;
- }
- void qpop(int x) {
- r[l[x]]=r[x];
- l[r[x]]=l[x];
- }
- int main()
- {
- n=read();
- r[0]=1;
- l[1]=0;
- for(int i=2;i<=n;i++) {
- int a,b;
- a=read();b=read();
- if(b==0) addl(a,i);
- else if(b==1) addr(a,i);
- }
- m=read();
- for(int i=1;i<=m;i++) {
- int a;
- a=read();
- if(outq[a]) continue;
- outq[a]=1;
- qpop(a);
- }
- for(int i=r[0];i;i=r[i]) {
- printf("%d ",i);
- }
- return 0;
- }

```

---

## 作者：Azrael_Death (赞：1)

**用数组模拟链表（我用的是双向链表，好操作），再按题意操作。AC源码+注释如下（代码仅供参考）**



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
//定义链表节点，l表示左边节点，r表示右边节点
struct node {
    int l, r;
        //定义构造函数
    node() {
        l = -1;
        r = -1;
    }
};
int main() {
    int n, m;
    cin >> n;
    node li[n+1];
    for (int i = 2; i <= n; i++) {
        int k, p;
        cin >> k >> p;
        if (p == 0) {
                        //如果此节点是插入在两个节点，先将左右两个节点的l和r改变，再进行普通操作
            if (li[k].l != -1) {
                li[li[k].l].r = i;
                li[i].l = li[k].l;
            }
            li[k].l = i;
            li[i].r = k;
        } else {
                        //p==1的情况，与上同理，只是l和r要交换
            if (li[k].r != -1) {
                li[li[k].r].l = i;
                li[i].r = li[k].r;
            }
            li[k].r = i;
            li[i].l = k;
        }
    }
    int mark[n+1], t;        //mark数组用于存储此节点还在不在队列中，0表示还在，1表示已被删除
                                         //注意数组大小应开到n+1
    memset(mark, 0, sizeof(mark));
    cin >> m;
    for (int i = 0; i < m; i++) {
        cin >> t;
        mark[t] = 1;
    }
    int head;        //head表示最左边的节点的编号，相当于链表表头
        //寻找head
    for (head = 1; head <= n; head++) {
        if (li[head].l == -1) {
            break;
        }
    }
    for(;;) {
        if (mark[head] == 0) {
            cout << head << " ";        //当此节点还在队列中时才输出
        }
        if (li[head].r == -1) {
            break;        //若此节点右边没有更多节点，则输出完毕
        }
        head = li[head].r;
    }
    return 0;
}
```
**或许我用的双向链表有些麻烦，但本人链表用得不熟，貌似双向链表更易理清思路**
**各位若熟悉链表，也可用普通链表（应该比这个简单很多）**


---

## 作者：姜一洲 (赞：1)

记录一下每个人左右的人分别是什么，被踢的人记录一下（以后就不管了），然后中间有人别踢就把他左右的人连起来。

输出时循环找到最左边的人，然后一个个输出。我是蒟蒻，不要问我为什么代码这么垃圾。





```cpp
#define C (c=getchar())
#include <cstdio>
using namespace std;
int n;
struct Y
{
    int k[2];
    Y(void){k[0]=k[1]=0;}
}t[100002];
bool b[100002];
inline void read(int &a){a=0;static char c;C;while(c<'0'||c>'9')C;while(c>='0'&&c<='9'){a=a*10+c-'0';C;} return ;}
inline void read(int &a, int &b){read(a),read(b);}
int main(void)
{
    read(n);
    int x, y;
    for (int i=1;i<n;++i)
        read(x,y),t[i+1].k[!y]=x,t[i+1].k[y]=t[x].k[y],t[t[x].k[y]].k[!y]=i+1,t[x].k[y]=i+1;
    read(n);
    for (int i=1;i<=n;++i)
        {
            read(x);
            if(b[x]==0){
                        t[t[x].k[0]].k[1]=t[x].k[1];
                        t[t[x].k[1]].k[0]=t[x].k[0];
                        b[x]=1;
                        }
        }
    int now=0;
    for (int i=1;i<=n;++i)
        if(b[i]==0)
            {
                now=i;
                break;
            }
    if(now)
    {
        while(t[now].k[0]!=0)
                now=t[now].k[0];
        while(now!=0)
            {
                printf("%d ",now);
                now=t[now].k[1];
                }    
    }
    return 0;
}
```

---


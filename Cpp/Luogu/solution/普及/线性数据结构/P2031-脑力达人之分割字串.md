# 脑力达人之分割字串

## 题目背景

好吧，该来的废话还是要来的。

画外音：

终于，在两轮的重重选拔之后，我们的海选终于结束了。现在进入我们的循环赛环节。循坏赛一共有四场，最后选出得分最高的 $16$ 人进入对决，得分相同则和按用时排名，若仍有不能确定 $16$ 人的情况，则去尾处理。

欢迎您收看有洛谷卫视重磅推出的综合性文艺知识类节目“开心玩游戏，轻松赢比赛”，我是 LUWM。学编程，就选洛谷， 感谢洛谷 Online Judge 对本节目的大力支持。下面，我们有请 $10$ 位选手上台，由大屏幕给出题目。


## 题目描述

现在有一个字符串，你可以对这个字符串进行拆分，如 `abcvsdaas` 可以拆分为 `abc|vs|d|aas`，现在再给你一个字典，要求分割成的每一个子串必须要有包含其中的任意一个单词。那么最多可以分为几个子串呢？


## 说明/提示

特殊情况：

如果原字符串不能被分割，请输出 $0$。



数据范围：

对于 $20\%$ 的数据，$1\leq |s| \leq 50,1\leq n\leq 50$。

对于 $100\%$ 的数据，$1\leq |A_i| \leq |s|\leq 300，1\leq N\leq 500$。

其中，$|s|,|A_i|$ 表示字符串 $s$ 与 $A_i$ 的长度。

## 样例 #1

### 输入

```
asdsd
3
as
sd
ds```

### 输出

```
2```

# 题解

## 作者：syf2008 (赞：17)

这是一道字符串模拟题,举个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/kvf4q8f4.png)

我们来画张图：
![](https://cdn.luogu.com.cn/upload/image_hosting/x6k8snxu.png)

这里有 $3$ 个区间，但我们只能选择 $2$ 个，因为有区间重合。

不难发现，这题就是求出所有子串的区间，记录下来，然后求最大不相交区间数量。

上代码
```
#include <bits/stdc++.h>
using namespace std;
struct ss
{
    int l,r;
}f[100005];
string a,b;
int s,n,lena,lenb,tmp=-2e9,ans;
bool cmp(ss a,ss b){return a.r<b.r;}
int main()
{
    cin>>a;
    lena=a.size();
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>b;
        lenb=b.size();
        for(int j=0;j<=lena-lenb;j++)
        if(a.substr(j,lenb)==b) //求出符合要求的子串区间
        {
            ++s;
            f[s].l=j;
            f[s].r=j+lenb-1;
        }
    }
    sort(f+1,f+s+1,cmp);
    for(int i=1;i<=s;i++) //求最大不相交区间数量
    if(tmp<f[i].l)
    {
        tmp=f[i].r;
        ans++;
    }
    cout<<ans<<endl;
}
```

---

## 作者：深海鱼的眼泪 (赞：12)

先枚举字符串每一位 i，判断从这一位字符开始是否有单词 j 恰为它的前缀，若有则从k= i+length(j)-1 位开始到末位的 f[k]=max(f[k],f[i-1]+1) 。

最后输出 f[length(s)-1]即可。



```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int f[310];
int main(){
    int i,n,l;
    bool x;
    char s[310],si[510][310];
    scanf("%s%d",s,&n);
    for (i=1;i<=n;i++){
        scanf("%s",si[i]);
    }
    l=strlen(s);
    for (i=0;i<l;i++){
        for (int j=1;j<=n;j++){
            int len=strlen(si[j]);
            if (l-i<len) continue;
            x=true;
            for (int k=0;k<len;k++){
                if (s[k+i]!=si[j][k]){
                    x=false;
                    break;
                }
            }
            if (x){
                for (int k=i+len-1;k<l;k++){
                    if (i==0) f[k]=max(f[k],1);
                    else f[k]=max(f[k],f[i-1]+1);
                }
            }
        }
    }
    cout<<f[l-1];
    return 0;
}
```

---

## 作者：xiezihanAKIOI (赞：3)

这道题不用 dp 也不用链表。其实有个更优的算法，而且时间复杂度也很可观。这个算法就是贪心。~~（为啥题解区好像没人有这种做法。）~~

我看到好像没有人用我这种做法，所以不确定我做法是否正确。如果你发现了问题或造出了 hack 数据，可以私信找我。

首先我们先看一个图片。

![](https://cdn.luogu.com.cn/upload/image_hosting/kvf4q8f4.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/x6k8snxu.png)

（图片源于 @syf2008 大佬，如有侵权，立刻删。）

如果有重合的区间，我们只能取其中一个。大家可以自己造几个简单的样例，大家就会发现不管有多少个重合的样例。能取即取就是最优的。因为你取前面的那个区间和后面的那个区间都是一样的。所以这道题就变成一道模拟啦。

我们先开个字符串 $str$ 把我们遍历到的字符加起来。然后再枚举 $n$ 个字符是否有重合的，如果有重合的，就将 $str$ 清 0，子串数量加一。最后输出即可。

我不知道我讲清楚没有，大家可以看代码理解。

```
#include <bits/stdc++.h>
#define min(a,b) (a < b ? a : b)
#define int long long

using namespace std;

map <string, bool> ma;
string s, str, c[505];
int n, cnt, ans;

signed main () {
	ios::sync_with_stdio (false), cin.tie (0), cout.tie (0);
	cin >> s >> n;
	for (int i = 1 ; i <= n ; i++) {
		cin >> str;
		c[++cnt] = str;
	}
	str = "";
	for (int i = 0 ; i < s.size () ; i++) {
		str += s[i];
		for (int i = 1 ; i <= n ; i++) {
			if (str.find (c[i]) != string::npos) {
				ans++;
				str = "";
			}
		}
	}
	cout << ans;
	return 0;
}
```
这题的时间复杂度是 $O(n\left|s\right|)$。如果有人有更优的做法，欢迎于我私信讨论。

---

## 作者：a16_ (赞：3)

设用于分割的串为 $S$，

设前$i$个字符最多可以分为 $\mathit f_{i}$ 个子串。

题目要求 **包含** ,而不是 **等于**，

故相较 $f_{i-1}$ 没有新词出现情况下 $f_i=f_{i-1}$。

考虑有新词出现的情况，则新词一定以 $S_i$ 结尾。

枚举 $j:i \rightarrow 0$ ,判断 $S_{j \sim i}$ 这个子串是否构成新词。

如果有，则可以进行状态转移: $f_i=\max(f_i,f_{j-1}+1)$。

还有别忘了当 $j=0$ 时 $f_{j-1}$ 会 RE，特判下就好了。

（新词就是在字典中的词啦。）

还有一个对代码实现的解释： `unordered_map` 用于判断是否在字典中，

其用法与`map`基本相同，但时间复杂度是 $O(1)$ 的，本质上是一种 Hash。

放下代码 $\sim\_\sim$

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<string,bool>m;
int n,f[305];
int main(){
	ios::sync_with_stdio(0);
	string s,a;
	cin>>s>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		m[a]=1;
	}
	int l=s.length();
	for(int i=0;i<l;i++){
		string temp="";
		f[i]=f[i-1];
		for(int j=i;j>=0;j--){
			temp=s[j]+temp;
			if(m[temp]){
				f[i]=max(f[i],(j>0?f[j-1]:0)+1);
			}
		}
	}
	cout<<f[l-1];
	return 0;
} 
```
私以为复杂度是 $O(|s|^2)$ 的，应该不算太慢，

但受限于`cin`、`string`，速度有点慢。

还可以做些小优化，但效果没有很明显qwq。

管理大大辛苦啦，求过！

---

## 作者：卷王 (赞：3)

## 题目大意

[传送门](https://www.luogu.com.cn/problem/P2031)

## 思路

**总评：这题没有大家想的那么难啊！！！只是有些人不知道 string 这个神器的好处！**

介绍一个 string 里面的一个好用的东西：```string::npos``` —— 它是用来判断两个字符串 $a,b$，$a$ 是否包含 $b$ 的。

有了这个，问题不就解决了吗？

我们用 $cnt$ 记录个数（最终答案），$ans$ 便是现在的字符串，代码如下（很简短，估计基本上没人能比我的短了）：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s, a[507];
int n, len, num = 0, cnt = 0;
string ans = "", c;
int main() {
	cin >> s >> n; len = s.size();
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	for(int i = 0; i < len; i++) {
		ans = ans + s[i];
		for(int j = 1; j <= n; j++)
			if(ans.find(a[j]) != string::npos) {
				cnt++;
				ans = "";
			}
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：夏色祭 (赞：2)

一道水题


没P党的，那我来一发P党的题解。


这题显然用dp来做会简便些。（除了dp我实在是想不到用其它算法来解决了）


状态：f[i]，为s前第i位的最优解；


阶段：1 to len(s)


状态转移方程：f[i]:=max{f[j-1]+从第j位开始到第i位是否可以构成子串（可以为1，反之则为0，当然为0题目中说不能构成子串）}；


边界:f[0]:=0;


AC代码：


```cpp
var
  f:array[0..301]of longint;
  a:array[0..501]of ansistring;
  n,i,j,k:longint;
  s:ansistring;
  p:boolean;
function ff(x:ansistring):longint;
var
  i:longint;
  p:boolean;
begin
  p:=false;
  for i:=1 to n do 
    if pos(a[i],x)<>0 then begin p:=true;break; end;
  if p then exit(1) else exit(0);//判断从第j位开始到第i位是否可以构成子串
end;
begin
  readln(s);
  readln(n);
  p:=false;
  for i:=1 to n do 
    begin
      readln(a[i]);
      if pos(a[i],s)<>0 then p:=true;
    end;
  if not p then //如果每个单词都没出现，则不能拆分
    begin
      writeln(0);
      halt;
    end;
  f[0]:=0;//边界
  for i:=1 to length(s) do 
    begin
      for j:=1 to i do 
        begin
          k:=ff(copy(s,j,i-j+1));
          if (f[i]<f[j-1]+k)and(k>0) then f[i]:=f[j-1]+k;
        end;
    end;//dp
  write(f[length(s)]);//最终答案保存在f[length(s)]里
end.
```

---

## 作者：Orion_Rigel (赞：2)

其实是随机了这道题目

Trie 树+动态规划 即可。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int t[150001][30],root=1,cnt=1;
int end[150001],f[301],n,l1,l2;
char s1[301],s2[301];
void insert()
{
    int now=root; scanf("%s",s2+1); l2=strlen(s2+1);
    for (int i=1;i<=l2;++i)
    {
        if (!t[now][s2[i]-'a']) t[now][s2[i]-'a']=++cnt;
        now=t[now][s2[i]-'a'];
    }
    end[now]++;
}
void dp()
{
    memset(f,0,sizeof f);
    f[0]=0;l1=strlen(s1+1);
    for (int i=1;i<=l1;++i)
    {
        f[i]=max(f[i-1],f[i]);
        int now=1,p=i;
        while (now)
        {
            now=t[now][s1[p]-'a'];
            if (end[now]) f[p]=max(f[p],f[i-1]+1);
            p++;
        }
    }
    int ans=0;
    for (int i=1;i<=l1;++i) ans=max(ans,f[i]);
    printf("%d\n",ans);
}
int main()
{
    scanf("%s",s1+1);
    scanf("%d",&n);
    for (int i=1;i<=n;++i) insert();
    dp();
}
```

---

## 作者：Neven (赞：1)

这一题其实没有多难，主要是要熟练掌握字符串相关的操作。

重点只有两个，一个是要判断是否包含字典里中的字符串，另一个就是如何分割字符。

首先解决第一个。其实只需要一个函数就可以了，就是`substr`。`substr`可以判断一个字符串是否包含另一个字符串，具体用法如下：`a.substr(i, i + len)`代表在`a`字符串中，以`a[i]`为起点，`len`为长度的字串。所以我们只要枚举起点i，再将字串与字典中的字符串相比较，如果一样就是包含。

其次是第二个。题目标签给的是`dp`，其实跟它一点关系也没有。我们只需要一个小贪心：如果包含就分割，如果重合就跳过。只需要记录上一个子串的结尾，再与下一个字串的起点比较，如果末尾小于起点，就没有重合，将新的字串的末尾记录，`ans++`即可。

有了以上思路，就可以写代码了。还有不懂得可以看代码的注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, ans, cnt, rgt = -1;//rgt记录上一个分割的字串的末尾 
string a, b;
struct node{
	int lft, rgt;//记录每个字串的起点和末尾 
}chunk[505];
bool cmp(node x, node y){
	return x.rgt < y.rgt;//按末尾进行排序，是因为枚举是按每个字串的起点 
}
int main(){
	cin >> a >> n;
	for(int i = 1; i <= n; i++){
		cin >> b;
		for(int j = 0; j <= a.size() - b.size(); j++){//j+b.size()<=a.size，所以j<=a.size()-b.size()
			if(a.substr(j, b.size()) == b){
				chunk[++cnt].lft = j;//记录字典中每个字符串在字符串中出现的位置。 
				chunk[cnt].rgt = j + b.size() - 1;//注意要减一！！！ 
			}
		}
	}
	sort(chunk + 1, chunk + 1 + cnt, cmp);
	for(int i = 1; i <= cnt; i++){
		if(rgt < chunk[i].lft){//上一个的末尾与这个字串的起点不重合 
			ans++;
			rgt = chunk[i].rgt;
		}
	}
	cout << ans << endl;
	return 0;
}
```
第一次写题解，表达不清楚的请谅解~

---

## 作者：小柯 (赞：1)

$\texttt{其实我的思路和其他大佬的差不多，但是多了一些优化。}$

# 删减

$\texttt{材料：}$
$\color{black}{string,string::find(),map}$
$\texttt{（}$
$\color{black}{STL}$
$\texttt{必备）}$
 
$\texttt{方法：重复的以及切不出来的全部过滤掉。}$
 
$\texttt{代码：}$

```
	#include<string>
	#include<map>
	using namespace std;
	map<string,bool>mp;
	string a[505];
	......
	for(int i=1;i<=n;i++){
		cin>>a[i];
		int v=s.find(a[i]);
		if(v==-1||mp[a[i]]){
			i--,n--;
			continue;
		}
		mp[a[i]]=true;
	}
    	......
```
# 预处理

$\texttt{材料：}$
$\color{black}{string::find()}$

$\texttt{方法：提前把每个单词出现在原串中的位置记记下来，用的时候直接枚举就好了。}$

$\texttt{代码：}$

```
#include<iostream>
#include<string>
#include<map>
using namespace std;
map<string,bool>mp;
string s,a[505];
int n,m,v,lens,lena[505],f[505],k[505][505];
int main(){
	cin>>s>>n;
    	lens=s.size();
	for(int i=1;i<=n;i++){
		cin>>a[i],v=s.find(a[i]);
		if(v==-1||mp[a[i]]){
			i--,n--;
			continue;
		}
        	lena[i]=a[i].size(),mp[a[i]]=true;
		while(v!=-1)k[v][++k[v][0]]=i,v=s.find(a[i],v+1);
	}
	for(int i=0;i<lens;i++)for(int j=1;j<=k[i][0];j++)for(int l=i+lena[k[i][j]]-1;l<lens;l++)f[l]=(i==0)?max(f[l],1):max(f[l],f[i-1]+1);
	cout<<f[lens-1]<<endl;
	return 0;
}
```

~~压行使我快乐!~~

---

## 作者：flyfree (赞：1)

思路其实差不多，就是加了个小优化

还是说一说思路吧：

先把字符转换成数字，a是1，b是2，以此类推（~~这个不重要，主要是看着顺眼~~）

f[i]表示的是前i个字符最多能拆成几个子串。假设原字符串存在数组a中，状态转移就是枚举以a[i]结尾的单词（假设是s[]），看看s[len-1],s[len-2]……s[1]能否与a[i-1],a[i-2]……a[i-len+1]匹配。（len就是单词的长度）

若匹配，f[i]=max(f[i],f[i-len]+1);对于每一个f[i]，初始化应该是f[i]=f[i-1]，因为无论如何它至少和前一个一样。

优化：因为每次枚举的都是以同一个字母结尾的所有单词，所以可以利用类似邻接表（前向星）的思想把以同一个字母结尾的所有单词用一个链表串起来，方便枚举。

上代码~

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int a[305],n,len,head[30],f[305];
struct string//存每个单词
{
    int s[305],next,len;//s是单词，len是单词长度，next就是指向下一个以这个字母结尾的单词，起指针作用
}h[505];
void read(int num)
{
    char x=' ';
    while(x<'a'||x>'z')
    x=getchar();
    while(x>='a'&&x<='z')
    {
        h[num].len++;
        h[num].s[h[num].len]=x-'a'+1;
        x=getchar();
    }
}
void insert(int num,int vi)
{//学过邻接表（前向星）的应该能懂
    h[num].next=head[vi];
    head[vi]=num;
}
int pipei(int num1,int num2)
{
    int x=h[num2].len;
    while(x)
    {//从后往前一位一位地检查
        if(a[num1]!=h[num2].s[x])
        return 0;
        num1--;
        x--;
    }
    return 1;
}
int main()
{
    char c=getchar();
    while(c>='a'&&c<='z')
    {
        len++;//统计原始字符串长度
        a[len]=c-'a'+1;//字符转换为数字
        c=getchar();
    }
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        read(i);//读入每个单词
        insert(i,h[i].s[h[i].len]);//制作链表，s[h[i].len]就是该单词的最后一个字母
    }
    for(int i=1;i<=len;i++)
    {
        f[i]=f[i-1];//初始化
        for(int j=head[a[i]];j;j=h[j].next)
        {
            if(i<h[j].len)//如果目前的字符串还不如单词长就不可能匹配
            continue;
            if(pipei(i,j))//如果匹配成功
            f[i]=max(f[i],f[i-h[j].len]+1);//更新
        }
    }
    printf("%d",f[len]);
    return 0;
}
```

求过~

---

## 作者：GNAQ (赞：1)

##首先预处理区间** [j,i]** 里有没有单词，然后设状态f[i]表示以i结尾的字串的最大划分数目为f[i]，则枚举每个f[j] (j<=i) 让f[i]取f[j]+1和f[i]的最大值就可以了。

##要注意只有一个单词的串可以被划分成1段

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iterator>
#include<utility>
using namespace std;

int dicnum=0,lena=0,diclen[510]={0},f[310]={0};
char dic[510][310]={0},a[310]={0};
bool k[310][310]={0};

bool match(int pos,int dicv)
{
    for (int i=0;i<=diclen[dicv];i++) if (a[pos+i]!=dic[dicv][i]) return false;
    return true;
}

int main()
{
    scanf("%s%d",a,&dicnum);
    for (int i=1;i<=dicnum;i++) 
    {
        scanf("%s",dic[i]);
        diclen[i]=strlen(dic[i])-1;
    }
    lena=strlen(a);
    
    for (int i=lena;i>=1;i--)
        for (int j=i;j>=1;j--)
        {
            if (k[j+1][i])
            {
                k[j][i]=1;    
                continue;
            }
            for (int d=1;d<=dicnum;d++) if ((a[j-1]==dic[d][0]) && (i-j>=diclen[d]) && match(j-1,d)) k[j][i]=1;
        }
    
    f[0]=0;
    for (int i=1;i<=lena+1;i++)
        for (int j=0;j<=i;j++)
            f[i]=max(f[i],f[j]+k[j+1][i]);
            
    
    printf("%d\n",f[lena+1]);
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

这题我用的邻接矩阵+记搜。首先拿Trie树存字典，然后再暴力枚举字符串中的每个子串看是否在Trie树中，如果是字典中的单词的话就把这个子串外围的字符设为连通。举个例子：字符串为ywcasm，字典中有个单词ca，那么就可以建立y->s、y->m、w->s、w->m、w->a、c->s、y->a、c->m、c->a的有向边，于是这个题就变成了一个DAG上的最长路问题，其中起点为字符串开头，终点为字符串结尾，边权为1。拿记搜就能实现了。

代码如下：

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    using namespace std;
    typedef struct _t{
        bool isend;
        int childs[26];
    }trie;
    trie memchi[150001];//用于存放Trie的内存池
    int gn=1;
    int gend;//查找终点
    char str[1000];
    char str1[1000];
    bool find(int l,int tree){//在Trie树中查找字符串
        trie &ans=memchi[tree];
        int zi=ans.childs[str[l]-'a'];
        if(zi==0){
            return(0);
        }
        else{
            if(l==gend){
                if(memchi[zi].isend)return(1);//找到
                return(0);
            }
            return(find(l+1,zi));
        }
    }
    int build(int index,int tree){//构造Trie树
        trie &ans=memchi[tree];
        if(str1[index]=='\0'){
            ans.isend=1;
        }
        else{
            int zi=str1[index]-'a';
            if(ans.childs[zi]==0){
                ans.childs[zi]=gn;
                gn++;
                build(index+1,gn-1);
            }
            else{
                build(index+1,ans.childs[zi]);
            }
        }
    }
    unsigned char bv[400];//这个起点是否已被搜到
    int f[400];//结果
    int len;//字符串长度
    unsigned char G[400][400];//邻接矩阵
    int dp(int start){//记搜
        if(bv[start])return(f[start]);
        bv[start]=1;
        gend=len-1;
        int maxn=G[start][len-1];//如果当前子串可以单独划分，就初始化为1
        if(find(start,0)==1)maxn=1;
        for(int i=start;i<len-1;i++){
            if(G[start][i]){
                int res=dp(i+1);//继续划分
                if(res!=0){//若这里不能划分，就不更新
                    maxn=max(maxn,res+1);
                }
            }
        }
        return(f[start]=maxn);
    }
    int main(){
        cin>>str;
        len=strlen(str);
        int n;
        cin>>n;
        for(int i=0;i<n;i++){
            cin>>str1;
            build(0,0);
        }
        for(int i=0;i<len;i++){
            for(int j=i;j<len;j++){
                gend=j;
                if(find(i,0)){//如果中间有个单词，则两边的字符都能建有向边
                    for(int k=0;k<=i;k++){
                        for(int l=j;l<len;l++){
                            G[k][l]=1;
                        }
                    }
                }
            }
        }
        cout<<dp(0)<<endl;
        return(0);
}
```

---

## 作者：__YancBuxIya (赞：0)

参考了[深海鱼的眼泪](https://www.luogu.com.cn/user/17123)的题解，感谢。因作者解释较少，特此加以说明，可帮助初学者理解。

----------------

## 题目大意
给定一个原串 $s$ 以及相应的若干词汇 $dic_i$ 求最多可将 $s$ 分割为多少块。

#### 分割要求：

- 尽可能多的分割
- 每一个分割块里至少包含一个 $dic_i$ 中的单词

--------------
### STEP1--分析题目：
可以发现，本题主要考查的知识点是字符串和动态规划，通过数据范围可知，将时间复杂度控制在 $O(n^3)$ 之内是合理的。

--------------
### STEP2--理清思路：
将 $s$ 串进行一次遍历 $O(n)$，并同时枚举 $dic$ 数组 $O(n)$，将两个字符串一一匹配，若匹配成功，进行动态规划。

-------------
### STEP3--思考DP：
设 $dp_i$表示在原串 $s$ 中，前 $i$ 个字符所可划分的最大块数。则可发现：

- 若可以另起一块，则另起。
- 若不可以，则将其并入前一块。

```cpp
for(int k=i+ld-1;k<ls;k++){
    if(i==0) dp[k]=max(dp[k],1);
    else dp[k]=max(dp[k],dp[i-1]+1);
}
```
---------------
### STEP4--代码实现：
###### 具体注释看代码：

```cpp
#include<algorithm>
#include<string.h>
#include<stdio.h>
using namespace std;
const int L=305,N=505;
int n,dp[L];
char s[L],dic[N][L];
int main(){
	scanf("%s",s);
	scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%s",dic[i]);
    int ls=strlen(s);
    for(int i=0;i<ls;i++){//依次枚举原串的字符以便与词典配对  
        for(int j=1;j<=n;j++){//枚举各个词典(dic[i]) 
            int ld=strlen(dic[j]);
            if(ls-i<ld) continue;//若剩余的原串字符数小于词典字符数，直接舍去  
			bool x=1;
            for(int k=0;k<ld;k++){//字符串依次配对  
                if(s[k+i]!=dic[j][k]){//注意此处判断，因为是从0开始读入，所以是k+i  
                    x=0;//配对失败，打上标记，跳出循环  
                    break;
                }
            }
            if(x==1){//配对成功，开始dp 
                for(int k=i+ld-1;k<ls;k++){
                    if(i==0) dp[k]=max(dp[k],1);//进行特判，相当于初始化  
                    else dp[k]=max(dp[k],dp[i-1]+1);//如果不是，则并入前一个分割块 
                }
            }
        }
    }
    printf("%d\n",dp[ls-1]);//字符串的最后位置为ls-1 
    return 0;
}
```



---

## 作者：细数繁星 (赞：0)

# 思路
啊，伟大的贪心！

我们先把样例中的每一个字符串中含有的单词标记出来：

```
[a (s] {d) (s} d)
```

为了方便大家看的比较清楚，不同的单词我用了不同的括号。

我们再把每一个区间的起点和终点记录下来，分别是：$[1,2]$，$[2,3]$，$[4,5]$。

我们再使用 P1803 的代码，找出尽可能多的区间，使得他们之间互不重合。可以得出，答案是 $2$。那么这个算法对不对呢？

# 贪心证明
本题的目的是什么？分割出尽可能多的子串，保证每一个子串都至少包含一个单词，那么，为了使能分割出的子串足够多，最好是什么情况？那就是每一个子串只包含一个单词！所以这里相当于把所有符合条件的子串找了出来，然后在保证它们不相交的情况下，选择尽可能多的子串。这也是这个贪心算法的证明（很多题解好像没有）！对于线段覆盖算法，不用我多讲了吧……先按照右端点的大小升序排序，然后按顺序选就行了，这个证明要是不知道就去看 P1803 的题解吧。
# 代码环节
```cpp
// Problem: 
//     P2031 脑力达人之分割字串
//   
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2031
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstring>
#include <algorithm>
// xzls 不让用万能头
using namespace std;
int qjgs = 0;
struct qj 
{
    int left;
    int right;
}qjs[1005];
string str;
string arr[1005];
int main()
{
    cin >> str;
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> arr[i];
        for (int j = 0; j <= str.size() - arr[i].size(); j++)
        {
            // 将模板串像滑块一样滑过去比较，其实就是暴力匹配
            if (str.substr(j, arr[i].size()) == arr[i])
            {
                qjgs++;
                qjs[qjgs].left = j;
                qjs[qjgs].right = j + arr[i].size() - 1;
                // 用区间把匹配上的单词记录下来，后面的代码就和贪心里的区间覆盖很像了
            }
        }
    }
    sort(qjs + 1, qjs + qjgs + 1, 
        [] (qj a, qj b)
        {
            return a.right < b.right;
        });
    // 这个是行内函数的写法，类似 Python 的 lambda 和 JS 的 function
    int maxium = -1145141919;
    register int ans = 0;
    for (int i = 1; i <= qjgs; i++)
    {
        if (maxium < qjs[i].left)
        {
            maxium = qjs[i].right;
            ans++;
        }
    }

    cout << ans;
}
```

---

## 作者：luminary3 (赞：0)

~~这不是一道很简单的字符串吗~~。

这道题一些巨佬用了结构体，本蒟蒻觉得没有必要，我用的是 `string`。有很多使用的函数，比如说下面我用到的 `find()` 函数，能简化代码。

我们可以用一个字符串去记录枚举到的字符，放入字符串，如果找到了，就把它清空，这样可以保证不会有重叠。
***
先讲一下 `find()` 这个函数的用法。

`find()` 会返回找到字符串的第一个下标，如果找不到，会返回 $-1$，括号内填写需要找的字符串。    

具体的解释看代码。

```cpp

#include<bits/stdc++.h>
using namespace std;
string s,t[505],x;//x是用来保证搜索的字符串没有重叠
int n,cnt;
int main() 
{
    cin>>s>>n;
    for(int i=1;i<=n;i++)//输入
        cin>>t[i];
    for(int i=0;i<s.size();i++) //枚举
    {
        x+=s[i];
        for(int j=1;j<=n;j++)
            if(x.find(t[j])!=string::npos)//如果能够搜索得到
            {
                cnt++;//答案+1
                x="";//清空
            }
    }   
    cout<<cnt;
    return 0;
}
```

---

## 作者：DF_Factory (赞：0)

将题意转换成用字典中的字符串覆盖原字符串。

考虑 dp 。设状态 $f_i$ 表示原字符串的第 $0 \to i$ 位字符可以被 $f_i$ 个字典中的字符串覆盖。

那么，如何转移？

可以发现，当从第 $i$ 个字符开始时若后面为字典中的某一个子串，那么这一段的 $f$ 值就可以从 $f_{i-1}$ 转移过来。特别的，当 $i=0$ 时他们的转移值是 $1$。

答案即是 $f_{|s|-1}$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s,a[510];
int n,f[310];
bool can(int plus,int j){//判断是不是子串
	bool ret=1;
	for(int i=0;i<a[j].size();i++) ret&=(s[i+plus]==a[j][i]);
	return ret;
}
int main(){
	cin >> s >> n;
	for(int i=1;i<=n;i++) cin >> a[i];
	for(int i=0;i<s.size();i++)
		for(int j=1;j<=n;j++)
			if(s.size()-i>=a[j].size()&&can(i,j))
				for(int k=i+a[j].size()-1;k<s.size();k++)//转移
					f[k]=max(f[k],1+(i!=0)*f[i-1]);
	cout << f[s.size()-1];
	return 0;
}
```


---


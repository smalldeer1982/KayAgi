# [SDOI2016] 排列计数

## 题目描述

求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

本题共 20 个测试点，各测试点等分，其数据规模如下表。

| 测试点编号 | $T =$  | $n, m \leq$ |  测试点编号  |      $T =$      | $n, m \leq$ |
| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |
| $1\sim 3$  | $10^3$ |     $8$     | $10 \sim 12$ |     $10^3$      |   $10^3$    |
| $4 \sim 6$ | $10^3$ |    $12$     | $13 \sim 14$ | $5 \times 10^5$ |   $10^3$    |
| $7 \sim 9$ | $10^3$ |    $100$    | $15 \sim 20$ | $5 \times 10^5$ |   $10^6$    |

对于全部的测试点，保证 $1 \leq T \leq 5 \times 10^5$，$1 \leq n \leq 10^6$，$0 \leq m \leq 10^6$。

## 样例 #1

### 输入

```
5
1 0
1 1
5 2
100 50
10000 5000```

### 输出

```
0
1
20
578028887
60695423```

# 题解

## 作者：冒泡ioa (赞：98)

没思路？我们来找规律！  
比如一个$n=5$的排列，我们假设$m=2$也就是说，我们其实已经确定了排列种某些位置的值，就这个例子来说：

$12???$ $1?3??$ $1??4?$ $1???5$ $?23??$ $?2?4?$ $?2??5$ $??34?$ $??3?5$ $???45$ 

共10种，很容易发现其实就是$C_n^m$，那么其中的问号又多少种排列呢？

没思路？我们再来找规律！  
我们设$D_i$为i个?的可能的排列数，显然，$D_1=0$ $D_2=1$  
接着我们来看下$D_3$，可以有$312$,$231$  
如果我们继续找下去的话，容易出错，所以我们现在来找找规律（灵魂画师）。  
就拿$D_4$来说，上面的是数，下面的是位置，首先，1不能放到1号位，而且放到2，3，4上对于递推是等价的，于是他别无选择地放到了其他地方（假设是2号位）  
![](https://s1.ax1x.com/2018/08/22/PTVWbn.png)  
然后我们假设2放到1号位上去，剩下的3，4正好是$D_2$  
![](https://s1.ax1x.com/2018/08/22/PTVy8S.png)  
但2怎么可能只有放在1号位上的命运呢？它还可以不放到1号位，咦？我们之前说，i不能放到i号位，那么既然2不放到1号位，那么1号位在这里是不是等价于2号位呢？没错！
![](https://s1.ax1x.com/2018/08/22/PTVcvQ.png)  
而之前的“万恶之源”数字1，它有$n-1$种放法，所以我们就大胆猜测：$D_n=(n-1)(D_{n-1}+D_{n-2})$  
严谨的证明还请大家自己百度  
然后我们就愉快地输出$C_n^m\times D_{n-m}$就好啦    
其他知识点比如说逆元求组合数（费马小定理）还请大家自行了解  

[欢迎来我博客玩~](https://bubbleioa.github.io/)

## 代码
```c++
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
const int MAXN=1000005,mod=1000000007;
ll f[MAXN],inv[MAXN],d[MAXN];
int t;

ll qpow(ll a,ll b){
    ll ans=1;
    while(b){
        if(b&1)ans=a*ans%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}

void prework(){
    f[0]=1;
    for(int i=1;i<MAXN;i++){
        f[i]=f[i-1]*i%mod;
        inv[i]=qpow(f[i],mod-2);
    }
    d[1]=0,d[2]=1,d[3]=2;
    for(int i=4;i<MAXN;i++){
        d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
    }
}

int main(){
    cin>>t;
    prework();
    for(int i=1;i<=t;i++){
        ll n,m;
        scanf("%lld%lld",&n,&m);
        if (n - m == 1) printf("0\n");
        else if (m == n) printf("1\n");
        else if (m == 0) printf("%lld\n",d[n]);
        else {
            printf("%lld\n",f[n] * inv[m] % mod * inv[n-m] % mod * d[n-m] % mod);
        }
    }
    return 0;
}
```

---

## 作者：K2sen (赞：28)

update in 2020.5.5
## P4071
### 题意:
给出一个序列，然后A[i]的位置放i则称这是稳定的,然后剩下的n-m种则是不稳定的,

### 思路:
稳定的那m个数就是在n个数中选择m个数让他稳定，
然后剩下的不稳定的就是n-m个数做错排的方案数,

#### 啥是错排:
[错排例题](https://www.luogu.org/problem/P1595)

这就是一个错排的板子题，然后我们按照这个板子题来讲错排的原理，

就是n封信，装到n个信封中，都装错了.

我们先看第一个人，因为第一个人装错的话有n-1种情况，就长这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/mrq1kdx3.png)

然后拿出其中的一种来看，如果第二封信选择了第一个信封那就是后边的n-2个数做错排:

![](https://cdn.luogu.com.cn/upload/image_hosting/9hejy801.png)

如果第二个没有选第一封信，那就相当于对剩下的n-1个做错排.

我们就很容易得到一个递推式（设f[i] 为给i个数做错排的方案数）:

$$(n - 1) \ast (f[n - 1] + f[n - 2])$$

边界条件就是n为1和2的时候，当n只有1的时候只能放到这个信封中，所以方案数为0，

当n为2的时候只有下图这一种可能,所以方案数为1.剩下的递推可得.

![](https://cdn.luogu.com.cn/upload/image_hosting/t2jhik35.png)


求组合数的话我们可以用Lucas定理来求得.

Lucas定理:

$$Lucas(n, m) \%  mod = \tbinom{n \% mod}{m \% mod} * Lucas(n/mod, m/mod) % mod$$

 因为这个题中n,m太大了，我们可以用公式直接求，因为需要mod一个数，

 然后因为公式为$\frac {n!} {m!(n - m)!}$ 有除法，因为mod意义下没有除法运算，

然后我们可以求出$m!(n - m)!$ 的逆元，让$n!$ 乘以$m!(n - m)!$ 的逆元来求mod意义下的组合数.

因为mod的这个数为质数，我们可以直接利用费马小定理来求逆元.

费马小定理;

$$a^{p - 1} \equiv 1 \ (mod \ p)$$

所以 $a \ast a^{p -2} \equiv 1 \ (mod \ p)$
所以在$mod  \ p $的情况下$a$的逆元就是$a ^ {p - 2}$

做的时候我们可以先处理出前1000000的错排和阶乘.

#### code :
```cpp
#include <bits/stdc++.h>
#define N 1000010
#define M 1010
#define ll long long

using namespace std;
ll mod = 1e9 + 7;
ll t, n, m, f[N], jc[N];

ll read() {
	ll s = 0, f = 0;
	char ch = getchar();
	while (!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

ll q_pow(ll a, ll b) {
	ll ans = 1;
	while (b) {
		if (b & 1) ans = (ans * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return ans;
}

ll c(ll a, ll b) {
	return (jc[a] % mod * q_pow(jc[b] * jc[a - b] % mod, mod - 2) % mod) % mod;
}

ll lucas(ll a, ll b) {
	if (!b) return 1;
	else return (lucas(a / mod, b / mod) * c(a % mod, b % mod)) % mod;
}

int main() {
	t = read();
	f[1] = 0, f[2] = 1, jc[1] = 1, jc[2] = 2;
	for (ll i = 3; i <= 1000000; i++)
		f[i] = ((i - 1) * (f[i - 1] + f[i - 2]) % mod) % mod, jc[i] = (jc[i - 1] * i) % mod;
	while (t--) {
		n = read(), m = read();
		if (n == m) puts("1");
		else if (n - m == 1) printf("0\n");
		else if (m == 0) printf("%lld\n",f[n]);
		else {
			ll ans = (f[n - m] % mod * lucas(n, m)) % mod;
			printf("%lld\n", ans);
		}
	}
	return 0;
}
```

---

## 作者：lemir3 (赞：15)

[*在我的博客阅读*](https://www.lemir3.red/2020/05/08/SDOI2016-%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/)

## 题目分析

如果读过《组合数学》的话,很容易就可以看出这是个错排问题.

错排问题的定义如下(直接抄书):

>给定n元素集合X,它的每一个元素都有一个特定的位置,而现在要求求出集合X的排列中没有一个元素在它指定位置上的排列的数目.

用$D_n$表示$\{1,2,...,n\}$错排数目,根据容斥原理可以得到$D_n$的公式(证明见《组合数学》第五版108页):

>   $D_n = n!(1-\frac{1}{1!}+\frac{1}{2!}-\frac{1}{3!}+...+(-1)^n\frac{1}{n!})$

还可以通过$D_1=0$,$D_2=1$出发,递推得:

>   $D_n=(n-1)(D_{n-1}+D_{n-2}) ~ (n=3,4,5,...)$

本人能力有限,只能做个初步的介绍,现在回到这道题上,题意是让长度为n的序列有且仅有有m个数在原本的位置上.

所以其他的n-m个数就一定不在原本的位置上,这样的情况数就是n-m的错位排列数目,即$D_{n-m}$.

然后是这m个在原本位置上的数,这样m个数可以在序列中任取,情况数就是$C_n^m$,因为题目要求模一个质数,直接lucas求即可.

根据乘法原理,$D_{n-m}*C_n^m$就是答案了.

特判一下n=m的情况,答案为1,因为只有原序列满足答案.

预处理一下阶乘和$D_n$就可以了,之前很憨地暴算阶乘t掉了. /kk

## 代码

```cpp
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
const lxl maxn=1000010,p=1e9+7;
lxl T,n,m;
lxl d[maxn],cm[maxn];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
inline lxl FastPow(lxl a,lxl b,lxl mod)
{
	lxl sum=1;
	for(;b;b>>=1,a=a*a%mod)(b&1)&&(sum=sum*a%mod);
	return sum;
}
inline lxl inv(lxl a,lxl p)
{
	return FastPow(a,p-2,p); 
}
inline lxl C(lxl n,lxl m,lxl p)
{
	// if(m>n)return 0;
	// lxl up=1,down=1;
	// for(R int i(n-m+1);i<=n;++i)up=up*i%p;
	// for(R int i(1);i<=m;++i)down=down*i%p;
	// return up*inv(down,p)%p;
	return (cm[n]*inv(cm[m]*cm[n-m]%p,p)%p);
}
lxl Lucas(lxl n,lxl m,lxl p)
{
	if(m==0)return 1;
	return C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;
}
inline void prework()
{
	d[1]=0,d[2]=1,cm[1]=1,cm[2]=2;
	for(R int i(3);i<maxn;++i)d[i]=(i-1)*(d[i-1]+d[i-2])%p,cm[i]=cm[i-1]*i%p;
}
int main(void)
{
	prework();
	T=read();
	while(T--)
	{	
		n=read(),m=read();
		if(m==n)
		{
			printf("1\n");
			continue;
		}
		printf("%lld\n",Lucas(n,m,p)*d[n-m]%p);
	}
	return 0;
}
```

---

## 作者：starseven (赞：10)

# 对于任何一个卡读入的题，我都只能说醉了……


## 这是一篇通俗的题解，没有多大的技术含量，适合初学者使用

## 自然也就不用懂什么错不错排啦（我就没听说过）

这道题的题意非常简单，就是说给出n长度的序列，有m个数的大小等于自己的下标，叫我们求合法的方案数。

在没有真正接触容斥原理之前，我对于这类题都是理解错误，可是当真正学了容斥原理之后，我发现了容斥原理的妙用（~~当然是对于我而言~~）

这道题，我们可以很习惯的把序列拆成大小等于数组下标的和大小不等于数组下标的

- 对于大小等于数组下标的

我们明显可以得出一个结论，这就是从n个数里面选出m个数，这m个数的大小等于其数组下标，那么合法的方案数为：

$$ ans1=\frac{n!}{m! \times (n-m)!}=C_n^m $$

- 对于大小不等于数组下标的

我一开始想的是先算出其余数的排列(n-m)!,然后减去1就可以了，减去1是因为在其余方案数中，只有一种方案是所有数的大小都等于数组下标，花了
$$ \color{Red}5mins $$

打出来之后，卡死在样例上。


$$ n=5 $$

$$ m=2 $$

我的输出是50，但事实上该是20

我仔细一想，对哦，如果在剩下的n-m个数里面，如果有一个数的大小等于数组下标，那么此方案就不合法，因为我在前面已经挑出来了m个数了。


### 敲黑板

所以我们现在应该想一想，到底该怎么办？


#### 根据某不愿透露姓名的dalao所说，当你碰到一个题，如果你发现你没法直接算出来方案数，而且限制条件是有m个数不满足XX，那么就基本是容斥原理了

所以我们可以发现:

方案数=至少有0个数的数组下标等于大小（的方案数）-至少有1个数的数组下标等于大小+至少2个……

而至少i个数的数组下标等于大小的方案数等于

$$ C_{n-m}^i \times (n-m-i)! $$

其中，C代表的是从n-m个数中选出i个数，这i个数的数组下标等于大小（可以类比上面的东西）

而后面的阶乘就是剩下的数的全排列（因为我们说的是至少，所以不用管等不等于）

可能一些同学会问，为什么这个是对的（就是为什么容斥原理是对的），我以前也这样问过，可是最后发现只有自己想出来的才最靠谱，不然都会在考场上爆炸（几位学长学姐**血**的教训）

所以

$$ ans2= \sum\limits_{i=0}^{n-m}C_{n-m}^i \times (n-m-i)! \times (-1)^i $$
 
ans2 又等于

$$  ans2=\sum\limits_{i=0}^{n-m}\frac{(n-m)!}{i!} \times (-1)^i $$

所以说，总的方案数就是

$$ ans1\times ans2 = \frac{n!}{m!} \sum\limits_{i=0}^{n-m}\frac{(-1)^i}{i!} $$

这里是将ans2中的(n-m)!提了出来与ans1中的约掉。


然后我们就走完了80%的路程

$$ {\color{Red}On\;reaching\;the\;last\;leg\;of\;a \;journey,\;you\;are\;only\;half\;way\;there.} $$

我们现在看看时间复杂度……

是不是很恐怖，可是

## 有一种强大的优化，他叫前缀和

前缀和是一种特殊的树状数组，他的功能很少，但是很好用

因此，我们可以把阶乘，逆元（用费马小定理，如果你连这个都不知道，请出门右拐）提前处理出来，然后就可以AC这道例题了。

## 慢着，我怎么只有60分！

如果亲爱的你碰到了这个问题，并且后面的是TLE的话，看看最上面的东西


现在贴代码：

```cpp
#include<cstdio>
#include<iostream>
#define Starseven main
#define ll long long
#define ri register int
using namespace std;
const ll mod=1e9+7;
const int N=1e6+20;
ll p[N];
ll merse[N],dda[N]; 

ll read(){
	char ch=getchar();
	ll re=0,op=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-') op=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		re=(re<<3)+(re<<1)+ch-'0';
		ch=getchar();
	}
	return re*op;
}

void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9) write(x/10);
	putchar(x%10+'0');
	return ;
}

ll Power(ll a,ll b,ll c){
	ll re=1;
	while(b){
		if(b&1) re=(re*a)%c;
		b>>=1;
		a=(a*a)%c;
	}
	return re;
}

int Starseven(void){
	p[0]=1;
	merse[0]=1;
	for(ri i=1;i<=N-20;i++){
		p[i]=(p[i-1]*i)%mod;//这个是预处理阶乘 
		p[i]=(p[i]+mod)%mod;
		ll y;
		merse[i]=Power(p[i],mod-2,mod);//这个是用费马小定理提前处理逆元 
	} 
	int t=read();
	dda[0]=merse[0];
	for(ri i=1;i<=N-20;i++){
		if(i&1) dda[i]=dda[i-1]-merse[i];
		else dda[i]=dda[i-1]+merse[i];//这个是前缀和，提前把那个求和符号里面的东西弄出来 
		dda[i]=(dda[i]+mod)%mod;  
	}
	while(t--){
		ll n=read(),m=read();
		ll ans=(p[n]*merse[m])%mod*dda[n-m]%mod;
		write(ans);
		puts("");
	}
	return 0;
}
```

 

---

## 作者：March_H (赞：9)

[题目传送门](https://www.luogu.org/problemnew/show/P4071)
##### 组合数+错排＋逆元
[线性逆元传送门](https://www.luogu.org/blog/Marchrua/xian-xing-qiu-ni-yuan)
关于线性逆元，洛谷P3811模板题（这题没必要线性逆元）

[组合数传送门](https://www.luogu.org/blog/Marchrua/post-ocd)
### 关于错排：
即装错信封问题，n封信，每封都装错了，求装错的方法有多少种。

公式：d[i]=(i-1)*(d[i-1]+d[i-2])(i>=3)。

初始化d[0]=d[2]=1,d[1]=0;

递推推导：显然d[1]=0,d[2]=1;
当n>=3时，我们假设一个数字k(1<=k<n),并令n位于第k位，此时会出现2种情况：

1.k位于第n位，那么此时的错排相当于d[n-2]（因为k的位置已经确定，相当于求剩下的n-2个数的错排）;

2.k不位于第n位，那么此时的错排相当于d[n-1];

由于1<=k<n，所以k的取值有（n-1）种，于是便得到了上面的递推公式。

然后就是此题，大意就是求1-n的全排列中,第i位恰好是i，并且符合此条件的i的个数恰好是m的排列的个数。

1-n的全排列是n!，那么我们将题目转化为从n个数中取走m个数，这m个数都是符合第i位恰好是i的条件。那么剩下的(n-m)个数就必须符合第i位不等于i，从上面的讲解中就可以看出是错排了。显然答案就是C(n,m)*d[n-m]。

### 暴力伪代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int T,n,m,ans=0;
int a[n!+1];

int main(){
	cin>>T;
	while(T--){
		scanf("%d %d",&n,&m);ans=0;
		for(int i=1;i<=n;++i) a[i]=i;
		for(int i=1;i<=n!;++i){
			int tot=0;
			for(int j=1;j<=n;++j){
				if(a[j]==j) ++tot;
				if(tot>m) break;
			}
			next_permutation(a+1,a+n+1);//求下一个全排列 
			if(tot==m) ++ans;
		}
		printf("%d\n",ans);
	}
	
	return 0;
}
```
要是想不出正解的话可以暴力，代码还是很短的。
### 正解代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
const ll mod=1000000007;
ll f[1000000+50],inv[1000000+50],d[1000000+50];
ll T;
ll n,m;

ll q_pow(ll a,ll b){
    ll ans=1;
    while(b){
        if(b&1){
            ans=ans*a%mod;
        }
        b>>=1;
        a=a*a%mod;
    }
    return ans%mod;
}

inline void init(){
    f[0]=f[1]=d[0]=d[2]=inv[0]=inv[1]=1;f[2]=2;inv[2]=q_pow(f[2],mod-2);
}

inline void prework(){
    for(ll i=3;i<=1000000;++i){
        f[i]=f[i-1]*i%mod;
        inv[i]=q_pow(f[i],mod-2);
        d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
    }
}

inline ll ask(ll n,ll m){
    return (f[n]*inv[m]%mod*inv[n-m]%mod)%mod;
}

inline ll read(){
    ll ans;
    char c;
    while(c=getchar(),c<'0'||c>'9'){
        
    }
    ans=c-'0';
    while(c=getchar(),c>='0'&&c<='9'){
        ans=ans*10+c-'0';
    }
    return ans;
}

int main(){
    init();
    prework();
    scanf("%lld",&T);
    while(T--){
        n=read();m=read();
        printf("%lld\n",ask(n,m)*d[n-m]%mod);
    }
    
    return 0;
}
```

---

## 作者：Warriors_Cat (赞：8)

## 题解 P4071 【[SDOI2016]排列计数】

### $Solution:$

 [P1595 信封问题](https://www.luogu.com.cn/problem/P1595) 在这道题中就相当于 $m=0$ 的情况。如果知道 P1595 的 trick 了话，这道题其实并不难。

我们定义 $D_i$ 为 $1$ 到 $i$ 的排列中 $m = 0$ 的排列数。

那么易知 $D_1 = 0, D_2 = 1$。接着我们考虑 $D_i$ 的递推式：

对于 $1$，它只能放在 $2, 3, ... \;i$ 这几个位置上，不妨设数 $1$ 放在位置 $2$。

那么，对于数字 $2$，它有两种情况：

$i. $ 数字 $2$ 放到位置 $1$，那么就相当于 $3$ 到 $i$ 的排列中 $m=0$ 的排列数，显然有 $D_{i-2}$ 种排列数。

$ii. $ 数字 $2$ 不放到位置 $1$，那么就相当于 $2$ 到 $i$ 的排列中 $m=0$ 的排列数，显然有 $D_{i-1}$ 中排列数。

综上，可得 $D$ 数列的递推式为：

$D_n = \begin{cases}0&n=1\\1&n=2\\(i-1)\times(D_{n-1}+D_{n-2})&n\ge 3\end{cases}$

于是，$m=0$ 的答案就算出来了，求得 $m=0$ 后，任意情况就可以推广了。

有 $m$ 个位置 $i$ 满足 $a_i = i$，其实就相当于 $n-m$ 个位置 $i$ 满足 $a_i\neq i$。

那么，我们可以先挑出 $m$ 个位置，让这些位置都满足 $a_i=i$，有 $C_{n}^m$ 种挑法，然后，对于剩下 $n-m$ 个位置都要满足 $a_i\neq i$，由上述分析可得有 $D_{n-m}$ 种。

综上，对于两个数 $n, m$，其答案为 $D_{n-m}\times C_{n}^{m}$。

$D$ 数列直接递推即可，组合数 $C$ 可以预处理阶乘和阶乘逆元。

时间复杂度为 $O(n+t)$。

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int mod = 1000000007, N = 1000000;
int t, n, m, jc[N + 10], inv[N + 10], d[N + 10];
inline int fpow(int n, int p, int mod){
	n %= mod;
	int ans = 1, base = n;
	while(p){
		if(p & 1) ans = ans * base % mod;
		base = base * base % mod;
		p >>= 1;
	}
	return ans;
}
inline int C(int n, int m){ return jc[n] * inv[m] % mod * inv[n - m] % mod; }
signed main(){
	t = read();
	jc[0] = 1; d[1] = 0; d[2] = 1;
	for(int i = 1; i <= N; ++i) jc[i] = jc[i - 1] * i % mod;
	for(int i = 3; i <= N; ++i) d[i] = (i - 1) * (d[i - 1] + d[i - 2]) % mod;
	inv[N] = fpow(jc[N], mod - 2, mod);
	for(int i = N - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % mod;
	while(t--){
		n = read(); m = read();
		if(n == m) printf("1\n");
		else printf("%lld\n", d[n - m] * C(n, m) % mod);
	}
	return 0;
}
```


---

## 作者：Jayun (赞：5)

# 题目大意：

求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i=i$，答案对 $10^{9}+7$。

# 正文：

可以先列个表：

![](https://img2020.cnblogs.com/blog/1748322/202007/1748322-20200720083049201-978158950.png)

再从题目意思出发，若 $m=0$，即没有一个数字在自己位置上，那就是错位排列。错位排列的递推式是 $f_i=(i-1)(f_{i-1}+f{i-2})$。而我们在列表的过程中会发现，特殊情况除外，除在自己位置上的 $m$ 个数，其它的数进行错位排列。也就是说 最终答案 = 确定排列的数的总值 * 其它数错位排列。

问题来了，确定排列的数的总值是多少？我们不妨举举例，设 $n=4,m=2$，那么就有 $\{1,2,x,x\},\{1,x,3,x\},\{1,x,x,4\},\{x,2,3,x\},\{x,2,x,4\},\{x,x,3,4\}$.总共就有 $C_{n}^{m}$

# 代码：

```cpp
ll _pow(ll a, int b){
    a %= p;
	ll ans = 1;
	for(; b; b >>= 1, a = a * a % p)
		if(b & 1)
			ans = ans * a % p;
    return ans;
}
void init()
{
	prod[0] = 1;
	for (register int i = 1; i <= 1000000; i++)
		prod[i] = (prod[i - 1] * i) % p,
		inv[i] = _pow(prod[i], p - 2);
	a[2] = 1;
	for (register int i = 3; i <= 1000000; i++)
		a[i] = (i - 1) * ((a[i - 1] + a[i - 2]) % p) % p;
}

int main()
{
	int t;
	init();
	for (scanf("%d", &t); t--;)
	{
		scanf("%d%d", &n, &m);
		if(m == 0)
		{
			printf("%lld\n", a[n]);
			continue;
		}
		if(n == m){puts("1");continue;}
		if(n - 1 == m){puts("0");continue;}  //图表中的几个特殊情况
		printf("%lld\n", (prod[n] * inv[m] % p * inv[n-m] % p) * a[n-m] % p); //括号内的是组合数，a数组是错位排列个数
	}
	return 0;
}
```

---

## 作者：冰桨 (赞：4)

这道题可以很容易想到在n个中固定m个数在自己的位置上，然后其余的不在自己的位置上，对于第一问，可以想到在n中随意取m个数，即组合问题，而难点在于第二问，要保证每个数不在其自己的位置，我是写了个爆搜找的规律，
发现如果n-m为偶数的话它的排列数为
```cpp
pinto[n-m]=pinto[n-m-1]*(n-m)+1
```
如果n-m为偶数的话排列数为

```cpp
pinto[n-m]=pinto[n-m-1]*(n-m)-1
```
然后一个线性求逆元就A掉了，注意0的逆元要初始化为1.
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
const int N=1010101;
const ll mod=1e9+7;
ll t,n,m,num[N],kans[N],pinto[N],ans;
ll check(ll x,ll y){
	ans=1;
	while(y>0){
		if(y%2) ans=(ans*(x%mod))%mod;
		x=((x%mod)*(x%mod))%mod;
		y>>=1;
	}
	return ans;
}
int main(){
	num[0]=1;
	num[1]=1;
	pinto[0]=1;
	pinto[2]=1;
	pinto[3]=2;
	kans[1]=1;
	for(int i=2;i<=N;i++) kans[i]=((kans[i-1]%mod)*(i%mod))%mod;
	
	for(int i=4;i<=N;i++) 	
	if(i%2==0) pinto[i]=((pinto[i-1]%mod*i%mod)%mod+1)%mod;
	else pinto[i]=((pinto[i-1]%mod*i%mod)%mod-1+mod)%mod;
	
	num[N]=check(kans[N],mod-2);
	for(ll i=N;i>=2;i--) num[i-1]=((num[i]%mod)*i)%mod;
	scanf("%lld",&t);
	while(t--){
		scanf("%lld%lld",&n,&m);
		printf("%lld\n",(((kans[n]%mod*num[n-m]%mod)%mod*num[m]%mod)%mod*pinto[n-m]%mod)%mod);	
	}
	return 0;
}
```


---

## 作者：PPL_ (赞：4)

# 前言(可跳过)

这不是错排吗？！

诶，我怎么一眼就看出来了？

诶，我怎么打不来错排？

~~诶，我怎么躺地上了？~~  

# 正题

$m$ 个数字是对应的位置那么就有 $C_n^m$ 种情况，剩下的数字只需要求出错排数，即求出 $D(n-m)$，就搞定了

那么怎么求错排呢？前往博客食用：

[错排](https://www.luogu.org/blog/CQBZLYT/cuo-pai-gu-gu-gu-post)

组合数就不用多说了吧，配合逆元求解

答案就是 $C_n^m * D(n-m)$

下面是丑陋的代码：

```cpp
//12252024832524
#include <cstdio>
#include <algorithm>
#define Min(x,y) (x<y?x:y)
#define Max(x,y) (x>y?x:y)
using namespace std; 

typedef long long LL;
const int MAXN = 1000005;
const int MOD = 1e9 + 7;
int n,m;
LL cp[MAXN],inv[MAXN],jc[MAXN];//cp即错排，jc即阶乘

int Read()
{
	int x = 0,f = 1;char c = getchar();
	while(c > '9' || c < '0'){if(c == '-')f = -1;c = getchar();}
	while(c >= '0' && c <= '9'){x = (x*10) + (c^48);c = getchar();}
	return x * f;
}
void Put(LL x)
{
	if(x > 9)
		Put(x/10);
	putchar(x%10^48);
}
void pre()
{
	cp[1] = 0;
	cp[2] = 1;
	jc[1] = 1;
	inv[0] = inv[1] = 1;
	for(int i = 3;i < MAXN;++ i)
		cp[i] = (i-1) * (cp[i-1] + cp[i-2]) % MOD;
	for(int i = 2;i < MAXN;++ i)
	{
		jc[i] = jc[i-1] * i % MOD;
		inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;
	}
	for(int i = 1;i < MAXN;++ i)
		inv[i] = inv[i-1] * inv[i] % MOD;
	return;
}
LL C(int x,int y)
{
	return jc[x] * inv[y] % MOD * inv[x-y] % MOD;
}

int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	pre();
	for(int T = Read(); T ;-- T)
	{
		n = Read();
		m = Read();
		if(n == m)
			putchar('1');
		else
			Put(C(n,m) * cp[n-m] % MOD);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：TLE_Automat (赞：3)

感觉最近被组合数学的题虐惨了，于是就来水一波简单组合数学题的题解。

虽说这题结论很简单，但蒟蒻还是推了一个多小时，而且还推错了一次，第二次推才发现是~~sb错排~~。。。

好了，进入正题。

## 一.题目大意:

求 $1$ 到 $n$ 的排列 $a$，在 $a$ 中，有且仅有 $m$ 个 $i$，使得 $a_i=i$ ，问这样的排列的个数，答案对 $10^9+7$ 取模。

## 二.题目分析:

开题没思路？当然是手玩样例了，举个 $n=5,m=2$ 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/0yz9awnq.png)

以上图片是 $n=2,m=3$ 时的所有情况，其中，最顶上橙色的一行是下标，下面青色的格子中是已经确定好的数字，对应题目中的 $a_i=i$ ，绿色格子中的 $?$ 表示该格子中的数字还未确定。

我们发现，对于以上样例，如果只考虑 $a_i=i$ ，那么 $2$ 个 $i$ 的所有取法共有 $C^5_2$ 种，那么对于每种 $i$ 的取法(即图中的每一行)，问号上的数字又有多少种取法呢？

首先，我们会注意到，问号上的数字一定不会等于该点的下标，而**当前情况**中的问号在**其他情况中**的位置上至少有一个是等于该点的下标，这就意味着我们这种计算方法不会算重。

其次，还是由于问号上的数字一定不会等于该点的下标，那么计算问号的取法的问题就转化成了：给你下标从 $1$ 到 $n-m$ 的 $n-m$ 个位置，每个位置上放取值从 $1$ 到 $n-m$ 的不重复的元素，问下标与元素值都不对应的方案数。**大概用眼一瞅,艹,这不是错排问题吗?** 不知道**错排问题**的同学请转[P1595信封问题](https://www.luogu.com.cn/problem/P1595)。

这里只写**错排问题的结论**：设 $f_i$ 为 $i$ 个编号元素放在 $i$ 个编号位置，元素编号与位置编号各不对应的方案数，则有 $f_i=(i-1)\times f_{i-1}+(i-1)\times f_{i-2}$ 。（然后我们就可以开心递推了）

那么，总的来说，根据乘法原理，总方案就等于 $C^n_m\times f_{n-m}$ 。

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

ll Mod=1e9+7;
ll jiecheng[1000010];
ll f[1000010];

inline ll read()
{
    char ch=getchar();
    ll cur=0;
    while(ch<'0' || ch>'9') ch=getchar();
    while(ch>='0' && ch<='9')
    {
        cur=(cur<<3)+(cur<<1)+ch-'0';
        ch=getchar();
    }
    return cur;
}

inline ll ksm(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1) res*=a,res%=Mod;
        a*=a;
        a%=Mod;
        b>>=1;
    }
    return res;
}

inline ll inv(ll x)
{
    return ksm(x,Mod-2);
}

void init()
{
    jiecheng[0]=1;
    for(ll i=1;i<=1000000;i++)
        jiecheng[i]=jiecheng[i-1]*i%Mod;
    f[0]=1; f[1]=0; f[2]=1;
    for(ll i=3;i<=1000000;i++)
        f[i]=((i-1)*f[i-1]%Mod+(i-1)*f[i-2]%Mod)%Mod;
}

inline ll C(ll x,ll y)
{
    return jiecheng[x]*inv(jiecheng[x-y])%Mod*inv(jiecheng[y])%Mod;
}

int main()
{
    init();
    ll T;
    T=read();
    while(T--)
    {
        ll n,m;
        n=read(); m=read();
        ll ans=C(n,m)*f[n-m]%Mod;
        printf("%lld\n",ans);
    }
    return 0;
}
```
### 之后:
![](https://cdn.luogu.com.cn/upload/image_hosting/4i4jltey.png)

啊这！SDOI怎么天天卡常？

### 又交了一遍:

![](https://cdn.luogu.com.cn/upload/image_hosting/b6iv7v3v.png)

啊这！你谷评测姬似乎有点不稳定，直接过了，还比 1.00s 快不少。

**所以，本题解并不能保证一次通过，总之，多交几次就过了（确信**

---

## 作者：EarthGiao (赞：2)

## 【思路】
组合数学 / 错排     

### 【题目大意】
a[i]在i的位置上面是稳定的    
求有m个数是稳定的序列有多少个   

### 【题目分析】    
求符合条件序列的个数    
符合条件序列可以先只看那稳定的数    
一个序列中只有m个数是稳定的    
其他的都是稳定的      
那么稳定的数组合方式就是n个数里面取m个    
因为如果稳定那一个数只对应一个位置  
所以不存在顺序这一说，所以就是 $C_n^m$     
知道了稳定数的组合方式    
拿在看看除了这些稳定数之外数的组合方式   
其他的数都是不在自己的位置上面的   
也就是错排    
直接用错排求出n-m（这里是减号下同下下同）个人错排方法的数量就好了     
因为一种稳定数对应n-m个人的错排方式     
所以数量数就是 $C_n^m$ * (n-m)个人的错排方式   

### 【存在的问题】

**1.因为n和m的数据范围都是小于等于1e6**   
  不是很小,而且T很大，    
  所以每次T 不能都单独求C和错排次数了   
  这样一定会超时    
**2.因为这道题中有取模运算**   
  而递推求组合数只能过2000所以用这个阶乘求组合数就是必然的了    
  那么就要用到除法     
  而取模运算中不能用除法     

### 【优化】
**1.针对问题1**
  多次求解会超时     
  那就先预处理出来所有的阶乘和i个人的错排方式   
  到时候O(1)查询就好了   
**2.针对问题2**
  既然不能用除法那就用乘法   
  用逆元来代替除法就可以啦    
  求逆元因为模数是质数   
  所以可以用费马小定理求   
  费马小定理求逆元详见    
  [这里](https://www.cnblogs.com/acioi/p/11736379.html)     
  
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int k = 1e9 + 7;
const int Max = 1000005;
int d[Max];
int f[Max];
int inv[Max];

int p(int a,int b)
{
	int ans = 1;
	while(b)
	{
		if(b & 1)
			ans = ans * a % k;
		b >>= 1;
		a = a * a % k;
	}
	return ans;
}

signed main()
{
	d[0] = 1,d[2] = 1;
	for(register int i = 3;i <= 1000000;++ i)
		d[i] = (i - 1) * (d[i - 1] + d[i - 2]) % k;
	f[0] = 1,f[1] = 1;
	for(register int i = 2;i <= 1000000;++ i)
		f[i] = f[i - 1] * i % k;
	inv[0] = p(f[0],k - 2);
	for(register int i = 1;i <= 1000000;++ i)
		inv[i] = p(f[i],k - 2) % k;
	int t;
	cin >> t;
	while(t --)
	{
		int n,m;
		scanf("%lld%lld",&n,&m);
		//c(n,m) * d(n-m)
		//n!/m!(n - m)! * d[n-m]
		printf("%lld\n",(f[n] * inv[m] % k * inv[n-m] % k * d[n-m]) % k);
	}
	return 0;
}
```

---

## 作者：poorpool (赞：2)

“稳定的”数要求第 $i$ 个数就是 $i$，可以发现对于一个 $a_i$，若它是稳定的则一定在 $i$ 位置，否则一定不在 $i$ 位置。

所以答案就是 $\binom{n}{m} \times D_{n-m}$，其中 $D_{n-m}$ 代表错位排列数。且 $D_i=(i-1)(D_{i-1}D_{i-2})$。

还有一点就是求阶乘逆元。我从别人代码里学了一下这种方法，不用扩欧，而且在 $n>p$ 时也是适用的。（尽管这题 $n < p$）

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
int T, uu, vv, fac[1000005], inv[1000005], d[1000005];
const int mod=1e9+7;
int main(){
	fac[0] = fac[1] = inv[0] = inv[1] = d[0] = d[2] = 1;
	for(int i=3; i<=1000000; i++)
		d[i] = (ll)(i-1) * (d[i-1] + d[i-2]) % mod;
	for(int i=2; i<=1000000; i++){
		fac[i] = (ll)fac[i-1] * i % mod;
		inv[i] = (ll)(mod - mod / i) * inv[mod%i] % mod;
	}
	for(int i=2; i<=1000000; i++)
		inv[i] = (ll)inv[i-1] * inv[i] % mod;
	cin>>T;
	while(T--){
		scanf("%d %d", &uu, &vv);
		int ans=(ll)fac[uu]*inv[vv]%mod*inv[uu-vv]%mod*d[uu-vv]%mod;
		printf("%d\n", ans);
	}
	return 0;
}
```


---

## 作者：_HLLY_ (赞：2)

这个题描述的本身就很离散，所以就相当于选出m个位置，剩下的位置的错排

错排的公式也不是很难推，注意及时利用以前的结果就好了，实在不行根据印象打表找规律


设有n个数  ，n个位置，第一个数一定不能选第一个位置，所以可选的位置就有 n-1个

考虑剩下的n-1个数，一定有一个数可以放在1的位置，那这个数放在1的位置的方案数就等于这个数不放在1的位置+这个数放在1的位置= f(n-1)+f(n-2)

虽然感觉应该是个递归到1的过程，但实际上只用到n-2



码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define leaves 1000000007
#define ll long long 
#define N 1000005
ll jc[N],f[N],ni[N],T,n,m,x,y,i;
void exgcd(ll a,ll b)
{
    if(!b)
    {
    x=1;
    y=0;
    return ;    
    }
    exgcd(b,a%b);
    ll t=x;
    x=y;
    y=t-a/b*y;    
}
ll C(ll a,ll b)
{
    return jc[b]*ni[a]%leaves*ni[b-a]%leaves;    
}
int main()
{
f[0]=1;
f[1]=0;
f[2]=1;
ll sx=1000000;
for(i=3;i<=sx;i++)
{
    f[i]=(i-1)*(f[i-1]+f[i-2])%leaves;    
}
jc[0]=1;
for(i=1;i<=sx;i++)
jc[i]=jc[i-1]*i%leaves;
exgcd(jc[sx],leaves);
ni[sx]=x;
for(i=sx-1;i>=0;i--)
ni[i]=ni[i+1]*(i+1)%leaves;
    scanf("%lld",&T);
    while(T--)
    {
    scanf("%lld%lld",&n,&m);
    printf("%lld\n",(C(m,n)*f[n-m]%leaves+leaves)%leaves);            
    }
}
```

---

## 作者：Provicy (赞：1)

此题前置芝士：基础组合数推导 $+$ 求逆元。

题意就是：长度为 $n$ 的序列中选 $m$ 个数使其固定，其他数可以交换但不能处在自己原来的位置上。

考虑从 $n$ 个数中选 $m$ 个数，且把剩下 $n-m$ 个数错排，答案显然就是：

$$C_{n}^{m}\times D_{n-m}\qquad$$

$D_{k}$ 表示长度为 $k$ 的序列的错排个数。这个公式很好记，不过也很好推。

考虑一个长度为 $n$ 的序列，且第 $n$ 个数放在第 $k$ 个位置上$(1\leq k < n)$

此时要分类讨论：

$$D_{n}=(n-1)\times\begin{cases}D_{n-2}(\texttt{第 k 个数放在第 n 个位置上})\\D_{n-1}(\texttt{第 k 个数不放在第 n 个位置上})\end{cases}\qquad$$

因为 $k$ 有 $n-1$ 种选择，所以还要乘上 $n-1$，这个东西就很好递推了。注意边界：$D_{0}=D_{2}=1,D_{1}=0$。

那么预处理一下错排，就可以实现 $O(1)$ 查询了。

代码如下：

```cpp
#include <bits/stdc++.h>
#define ri register
#define int long long
using namespace std; const int N=1000000,Mod=1e9+7;
inline int read()
{
	int s=0, w=1; ri char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48), ch=getchar(); return s*w;
}
int T,fac[N+5],inv[N+5],d[N+5];
inline int ksc(int x,int p) {int res=1; for(;p;p>>=1, x=x*x%Mod) if(p&1) res=res*x%Mod; return res; }
signed main()
{
	fac[0]=1; for(ri int i=1;i<=N;i++) fac[i]=fac[i-1]*i%Mod;
	inv[N]=ksc(fac[N],Mod-2); for(ri int i=N;i;i--) inv[i-1]=inv[i]*i%Mod;
	d[0]=d[2]=1; for(ri int i=3;i<=N;i++) d[i]=(i-1)*(d[i-1]+d[i-2])%Mod;
	for(T=read();T;T--)
	{
		int n=read(), m=read();
		if(m>n) puts("0");
		else printf("%lld\n",fac[n]*inv[n-m]%Mod*inv[m]%Mod*d[n-m]%Mod);
	}
	return 0;
}
```


---

## 作者：御·Dragon (赞：1)

[~~更好地阅读效果~~](https://www.cnblogs.com/CJYBlog/p/permutation.html)

### 由于Latex以及Markdown莫名出锅，请各位参考上面的cnBlog进行阅读。

[SDOI2016-排列计数](https://www.luogu.com.cn/problem/P4071)

发现很多题解都没有讲清楚这道题为什么要用逆元、递推公式怎么来的。 ~~我，风雨兼程三十载，只为写出一篇好题解。~~ 还是我来造福大家一下吧。

> ## 题目大意：

一个长度为 n 且 1~n 各出现一次的序列，希望在“序列中有且只有 m个数的值 等于 它的位置”条件下求出序列个数。答案对1000000007取模。

> ## 题目分析：

这道题也许是加强版的“装错了的信封”，在“装错了的信封”上搞搞比利就好。我们不妨设：
__值等于位置的数字__ 称 __稳定的__
__值不等于位置数字__ 称 __不稳定的__

稳定的数字由于要保证 值等于位置，故 __稳定的数字从序列左到右的值是递增的__

首先我们根据组合数的思想可以知道： 

__答案 = 稳定的挑选方法数 乘上 不稳定的挑选方法数__ 。

所以现在我们的目的改成了求出 __稳定的挑选方法数__ 和 __不稳定的挑选方法数__ 。

> ### 稳定的挑选方法数：

我们已经知道了 __稳定的数字从序列左到右的值是递增的__，那么我们只需要模拟是哪几个数是稳定的即可。

不难想到，数量其实就是 __在 $n$ 个数中 挑选 $m$ 个数的方案数__ 。

这不就是组合数里面的 $C_n^m$ 吗？有 $C_n^m$ = $\frac{n!}{m!(n-m)!}$

搞定

> ### 不稳定挑选方法数（错排）：

我们假设已经知道了哪 $m$ 个数是稳定的，那么我们可以在数组中暂时只看不稳定的数。

也就是 __错排__

我们令数组 $F_x$ 为 __有 $x$ 个数字，每个数字均为不稳定的方法数__。

由于这些数是不稳定的，那么就没有值的大小递增关系，所以我们对于每一个 $F_x$ ，都要进行分类讨论。

$$假设一个数字 k ,并令 n 位于第 k 位
\begin{cases}
当 k 位于第n位& \text{此时的错排数为 $F_{n-2}$（因 k 的位置已知，即求余的 n-2 个数的错排数）}\\
当 k 不位于第n位& \text{此时的错排数为 $F_{n-1}$}
\end{cases}$$

于是对于每个 $F_i$ ，有 $F_i$ = $(i - 1)\times(F_{x-1} + F_{x-2})$

#### 所以最终答案为：($C_n^m \times$$F_{n-m}$)%MOD

> ## 具体操作思路：
我们先要初始化，对于 $C_x^y$ 要初始化阶乘，对于 $F_i$ 要递推。

然后对于每一组数据，套 ($C_n^m \times$$F_{n-m}$)%MOD 即可。

> __但是（还没完）：__

由题意得，最终方案数可能很大（所以才要取模），我们在进行 答案累乘时，($C_n^m \times$$F_{n-m}$)%MOD 可能会爆精度，我们于是要用到：

__逆元（inv）__

> 何为逆元（ $inv$ ）？

比如当有 $(a \div b) \% MOD$ 时，防止 $b$ 过大而爆精度，将 $a \div b$ 转化为某种简单的乘法。

若 $c$ 为 $b$ 的逆元，则有 $(b \times c) \equiv 1 (mod 模数)$

那么 $(a \div b) \% MOD$ = $(a \div b) \times 1 \% MOD$ = $(a \div b) \times b \times c \% MOD$ = $(a \times c) \% MOD$

即 （一个数 除以 另一个数）%模数 = （一个数 乘上 另一个数的逆元）%模数

> ### 如何将逆元应用到该题中

我们初始化逆元数组 $inv$ ， $inv$ 为 阶乘的逆元

那对于固定的值于模数，那个值的逆元怎么求呢？

~~请你参考费马小定理~~

直接给出答案：对于 $a \% 1000000007$ 的逆元，为 $a^{1000000007-2}$

__搞个快速幂就好了__

## 代码请在[这里](https://www.cnblogs.com/CJYBlog/p/permutation.html)进行查看

---

## 作者：SA丶S (赞：1)

## 2019.8.20(隔天）
### 我才看到题目里面要求对1e9+7取模，因此请无视下列的模法！！


这是一题错~~误~~(位)排序入门题，然而对于我这个数论渣滓来说简直是暴击。~~（看看机房别的dalao秒懂秒切）~~


------------

关于错位排序其实可以用一个很形象的描述来表达，即有n封信件，要投放到n个信箱中，但是这个邮递员有恶趣味，一定要将所有的信件都投放在不正确的信箱内，而我们要做的，就是帮他求出到底有多少种可能可以放错所有的信件。（我是成帮凶了？还有原来放错东西也是一门技术活啊喂！）

假设我们有一封给wly奆佬的信件，他的信箱是第k个，因此我们不能把这封信放在他的信箱里，我们需要另外找一个信箱g，那么此时有两个位置我们是不能放wly的信件的，即k和g两个位置（k不能放wly的信件，原本在g的信件不能放在g）。因此现在的错排就是d[n-2]。

而相反的，如果我们不将他放在g这个位置，那么也就是说wly奆佬的信件依然没有放下去，那么要在上面那种情况的基础上加上一封信，也就是n-1.因此现在的错排就是d[n-1]。

因为两者是相反的关系，因此我们都需要考虑，所以这里一共就有d[n-2]+d[n-1]种排序的方式。

然后我们发现，k的取值范围是1<=k<=n的，因此总排序数量就是(n-1)* (d[n-2]+d[n-1])种。

当我们在求d[i]的时候，我们需要明确的一点即此时的k取值范围是1<=k<=i，那么此时的公式就变为了(i-1)* (d[i-2]+d[i-1]).


------------


下面是求错排排序数量的code.

```cpp
void pre()
{
	f[0]=1;
	d[1]=0,d[2]=1,d[3]=2;
	for(int i=1; i<1000005; i++)
		{
			f[i]=f[i-1]*i%mod;
			inv[i]=C(f[i],mod-2);
		}
	for(int i=4; i<1000005; i++)
		{
			d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
		}
}
```


------------

因为这道题有一个限定条件——有m个数字是已经被固定在正确的位置上的，所以我们可以预先处理这些数，将他们放在正确的位置上，然后剩下的n-m个数则是我们需要进行错排的数。

这道题有点坑的地方（其实这是题目的惯性），就是他的数据范围偏大，大到什么程度呢？他会把long long给炸掉，因此我们需要进行qpow操作以及magic操作（“模”法）。

（qpow操作）
```cpp
ll C(ll a,ll b)
{
	ll ans=1;
	while(b)
		{
			if(b&1)
				ans=a*ans%mod;
			a=a*a%mod;
			b>>=1;
		}
	return ans;
}
```

然后接下来就是特判那么一两个不乖的特例了。

当n=1、m=0的时候，是无论如何都不可能出现符合题意的情况的，因此此时的序列数为0.

当n=1、m=1的时候，总是且唯一满足题意，因此此时序列数为1.

如果m=0（n≠1）时，则无论我们怎么错排，都是符合题意的，那么只需要直接输出错排的个数d[n]即可。

对于其他的情况，也就是本题的真意，我们可以理解为有n个i满足第i位恰好为i的n~1的全排列的个数。

我们知道，1~n的全排列个数为n!，当我们固定下m个数字的时候，其他的n-m个数为错排数字，这些错排数字的排序个数则是C(m,n)了，那么代替上面的(n-1)（或者是(i-1)），可得答案为C(m,n)* （d[n-m]）。


------------

## 然后！就是我死去的“模”法了！
因为本蒟蒻没有模的习惯，因此以为只需要模一个1en+7就可以了，但是直到我把1e3~1e10都试过去之后……

总之以后养成好习惯，都模1e9+7吧！

至于1e9+7的作用是什么？

根据本蒟蒻的调查，1e9+7是十位整数里最小的质数，然后它能有效的防止int和long long爆炸（因为相加不爆int，相乘不爆long long）。


------------

下面是蒟蒻的code……（其实大家的code都大同小异……）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const long long mod=1e9+7;
ll f[1000005],inv[1000005],d[1000005];
int t;
ll C(ll a,ll b)
{
	ll ans=1;
	while(b)
		{
			if(b&1)
				ans=a*ans%mod;
			a=a*a%mod;
			b>>=1;
		}
	return ans;
}
void pre()
{
	f[0]=1;
	d[1]=0,d[2]=1,d[3]=2;
	for(int i=1; i<1000005; i++)
		{
			f[i]=f[i-1]*i%mod;
			inv[i]=C(f[i],mod-2);
		}
	for(int i=4; i<1000005; i++)
		{
			d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
		}
}
int main()
{
	scanf("%d",&t);
	pre();
	for(int i=1; i<=t; i++)
		{
			ll n,m;
			scanf("%lld%lld",&n,&m);
			if(n-m==1) 
				printf("0\n");
			else if(m==n) 
				printf("1\n");
			else if(m==0) 
				printf("%lld\n",d[n]);
			else
				{
					printf("%lld\n",f[n]*inv[m]%mod*inv[n-m]%mod*d[n-m]%mod);//这里要用到逆元啦！具体怎么实现可以去看看别的大佬的，因为我也是向他们学习过的。
				}
		}
	return 0;
}
```


---

## 作者：Oxygen_L (赞：1)

很明显，这是一个需要用到组合数来求解的题，并且还要知道 [错位排列是什么](https://baike.baidu.com/item/%E5%85%A8%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97/6806416?fr=aladdin)

首先很容易得出一个式子C(n,m)*(....)，括号内暂时不管，就是先假设符合条件的m个数字的摆放的位置，接下来处理剩余的n-m个数字，简记为K。

对于剩下的K个数字，因为它们的排列一定不满足A[i]=i，所以就可以用到错位排列的知识。

记D[i]为有i个数的错位排列的个数，那么由乘法原理可得答案为C(n,m)*D(K)。

 

### 接下来
1.组合数的求法，用阶乘+逆元预处理求组合数，先预处理出数据范围内的阶乘，根据费马小定理

(a MOD p意义下的逆元等于a^(p-2)%p)，求出fact(i)的逆元inv[i]。最后O(1)回答。

2.对于错排列的求法，有这么一个递推公式D[i]=(i-1)*(D[i-1]+D[i-2])

至此问题基本得到解决。
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#define MOD 1000000007
#define MAXN 1000007
#define N 1000000
#define LL long long
using namespace std;
 
LL n,m;
LL fact[MAXN],inv[MAXN];
LL f[MAXN],tmp;
 
//快速幂，求逆元
inline LL Q_pow(LL x,LL y){
	LL res=1;
	while(y){
		if(y&1) res=(res*x)%MOD;
		x=(x*x)%MOD;
		y>>=1;
	}
	return res;
}
 
//预处理，求阶乘及其逆元
inline void init(){
	f[0]=1;f[1]=0;f[2]=1;     //初始化，为了处理掉一些特殊情况
	fact[0]=1;inv[0]=1;       //
	for(LL i=1;i<=N;++i){
		fact[i]=fact[i-1]*i%MOD;
		inv[i]=Q_pow(fact[i],MOD-2);
	}
	for(LL i=3;i<=N;++i){
		f[i]=((i-1)*(f[i-1]+f[i-2]))%MOD;
	}
}
 
inline void solve(){
	LL T;
	scanf("%lld",&T);
	while(T--){
		scanf("%lld %lld",&n,&m);
		tmp=((fact[n]*inv[m]%MOD)*inv[n-m])%MOD;
		tmp=(tmp*f[n-m])%MOD;
		printf("%lld\n",tmp);
	}
}
 
int main(){
	init();
	solve();
	return 0;
}

```

---

## 作者：shadowice1984 (赞：1)

那么这道题是一个非常棒的错排问题的入门题

对于这类求方案数的问题的话

关键是不重不漏……，对于这道题可以使用枚举“区分点”的方法

也就是说，我们枚举的“区分点”，必须要让任意两个方案，只要区分点不同，那么这两个方案就不同

那么对于这道题来讲，就是如果连稳定的数字都不一样了，这两个方案就肯定不同了，那这样的话，那些数字是稳定的就是所谓的区分点所以我们可以先钦定到底哪m个数是稳定的，一共有$C_{n}^{m}$种方案

下面在钦定了这m个数字稳定之后，其他的数字必须全部不稳定，这个问题被称为全错排问题，也就是说，没有一个数字是稳定的序列个数

设$D_{n}$为长度为n的全错排序列个数那么的话我们呢会有一个一个递推式子

假设我们现在要求长度为n的错排方案数

那么我们呢就枚举第n个位置放在那个位置数上

显然一共有n-1个位置可以放，并且肯定有一个数t放在了第n个位置上

假设n放在了t位置上，那么剩下的序列必须构成一个长度为n-2的错排列

假设n没有放在t位置上，那么剩下的序列必须构成一个长度为n-1的错排列(因为n不能放在t上了)

上述两种情况是互斥的，因此可以直接加起来

枚举n放在那个位置是独立的，因此可以和上述两种情况乘起来

因此我们就有了一个极吼的递推公式

$D_{n}=(n-1)(D_{n-1}+D_{n-2})$

然后我们最后输出$C_{n}^{m}×D_{n-m}$就好啦

关于求组合数的问题可以打表逆元和阶乘，然后我们就可以$O(10^{6})$预处理
然后$O(1)$回答询问啦~

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e6+10;typedef long long ll;
const ll mod=1e9+7;ll inv[N];ll fac[N];ll ifac[N];ll d[N];int T;int n;int m;
int main()
{
    inv[1]=1;for(int i=2;i<=N-10;i++){inv[i]=(mod-mod/i)*inv[mod%i]%mod;}//打标逆元 
    fac[0]=1;for(int i=1;i<=N-10;i++){fac[i]=fac[i-1]*i%mod;}//打表阶乘 
    ifac[0]=1;for(int i=1;i<=N-10;i++){ifac[i]=ifac[i-1]*inv[i]%mod;}//打表逆元和阶乘 
    d[0]=1;d[1]=0;d[2]=1;for(ll i=3;i<=N-10;i++){d[i]=(i-1)*(d[i-1]+d[i-2])%mod;}//打表错排 
    scanf("%d",&T);
    for(int i=1;i<=T;i++)
    {
        scanf("%d%d",&n,&m);
        printf("%lld\n",fac[n]*ifac[m]%mod*ifac[n-m]%mod*d[n-m]%mod);//输出答案 
    }return 0;//拜拜程序~ 
}
```

---

## 作者：Elma_ (赞：0)

#### UPD：修改了 $\LaTeX$ 格式及码风。


------------


> - 求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。答案对 $10^9 + 7$ 取模。


简单错排 + 组合数问题。

先考虑在序列 $a$ 中选择 $m$ 个位置明显有 $C^m_n$ 种选法。这个组合数可以预处理阶乘和逆元算。

接下来考虑剩下的 $n-m$ 个位置如何选。显然这是一个错排问题。

记 $n$ 个元素的错排数为 $D_i$。考虑第剩下 $n-m$ 个位置中的第一个位置 $i$，假设这个位置上的数为 $k$。

- 如果位置 $k$ 上的数对应为 $i$，那么位置 $k$ 和位置 $i$ 就相当于互相抵消了，则相当于一个 $D_{i-2}$ 的子问题；

- 如果位置 $k$ 上的数不是 $i$，那么相当于把位置 $k$ 和数字 $k$ 都消去，然后将位置 $k$ 上的数放在位置 $i$ 上，这样则相当于一个 $D_{i-1}$ 的子问题。

对于每个位置 $k$ 都有 $D_{i-1}+D_{i-2}$ 种选法，而 $k$ 很明显不能是自身。共有 $i-1$ 个位置。所以递推式为：

$$D_i = (i-1) \times (D_{i-1}+D_{i-2})$$

其中边界条件是 $D_1=0$，$D_2=1$。

根据乘法原理，易得答案为
$$C^m_n \times D_{n-m}$$

算是一个简单题吧。

```cpp
#include <map>
#include <queue>
#include <stack>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
 
inline int read() {
	int x = 0, w = 1;char ch = getchar();
	while (ch > '9' || ch < '0') { if (ch == '-')w = -1;ch = getchar(); }
	while (ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();
	return x * w;
}
inline void write(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}
 
const int maxn = 1e6 + 5;
const int mod = 1e9 + 7;
const int inf = 1e9;
 
inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }

int fac[maxn], inv[maxn], d[maxn];
inline int qpow(int a, int b) {
	int res = 1;
	for (;b;b >>= 1, a = a * a % mod) {
		if (b & 1) res = res * a % mod;
	}
	return res;
}
inline void init(int n) {
	fac[0] = 1, d[1] = 0, d[2] = 1;
	for (int i = 1;i <= n;i++)  fac[i] = fac[i - 1] * i % mod;
	inv[n] = qpow(fac[n], mod - 2);
	for (int i = n;i >= 1;i--) inv[i - 1] = inv[i] * i % mod;
	for (int i = 3;i <= n;i++) d[i] = (i - 1) * (d[i - 1] + d[i - 2]) % mod;
}
inline int C(int n, int m) {
	return fac[n] * inv[m] % mod * inv[n - m] % mod;
}

int t, n, m;

signed main() {
	t = read(), init(maxn);
	while (t--) {
		n = read(), m = read();
		if (n - m == 1) puts("0");
		else if (m == n) puts("1");
		else if (m == 0) printf("%lld\n", d[n]);
		else printf("%lld\n", C(n, m) * d[n - m] % mod);
	}
	return 0; 
}
```

---

## 作者：GoPoux4 (赞：0)

### 分析

大致题意是：求使有 $m$ 个 $i$ 满足 $a_i=i$ ，其余 $i$ 满足 $a_i \not= i$ 的 $1 -n$ 的排列 $a$ 的个数。

看着没什么思路，就先满足有 $m$ 个 $i$ 满足 $a_i=i$ 吧，很明显，这是一个组合数，为 $C_n^m$。而剩下的数必须满足 $a_i \not= i$。

问题转化为了如何求 $a_i \not= i$ 的排列数。

### 暴力

先不管 $a_i \not= i$ 的限制，求 $n-m$ 个数的排列数，为 $(n-m)!$，而其中包含了非法排列，需要从这当中减掉。

当排列中有一个 $i$ ，使得 $a_i=i$ 这种排列显然不合法，有 $C_{n-m}^1*(n-m-1)!$ 个，从答案中减去。

发现这样减，还将有两个 $i$ 使 $a_i=i$ 的排列减重了，我们再将这种情况加回来，共有 $C_{n-m}^2*(n-m-2)!$ 个排列。

又发现有三个 $i$ 使 $a_i=i$ 的排列算重了，再减去……

这不就是个容斥嘛?于是我们得到：

$$ans=C_n^m* \sum_{i=0}^{n-m}(-1)^i \left [(n-m-i)! * C_{n-m}^i \right]$$

于是暴力 $O(n^2)$ 过了 60 分。

**暴力代码**：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define maxn 1000
#define lxl long long
using namespace std;

const lxl mod=1e9+7;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

inline lxl fti(lxl a,lxl b)
{
	lxl ans=0;
	while(b>0)
	{
		if(b&1) ans=(ans+a)%mod;
		a=(a+a)%mod;
		b>>=1;
	}
	return ans;
}

int n,m;
lxl tim[maxn+5],c[maxn+5][maxn+5];

int main()
{
	//freopen("P4071.in","r",stdin);
	tim[0]=1;
	for(int i=1;i<=maxn;i++) tim[i]=(tim[i-1]*i)%mod;
	c[0][0]=1;
	for(int i=1;i<=maxn;i++) c[i][0]=1;
	for(int i=1;i<=maxn;i++)
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
	int t=read();
	while(t--)
	{
		n=read(),m=read();
		lxl ans=c[n][m],p=1,res=0;
		for(int i=0;i<=n-m;i++,p=-p)
			res=(res+p*fti(tim[n-m-i],c[n-m][i])+mod)%mod;
		printf("%lld\n",fti(ans,res));
	}
	return 0;
}

```

---

### 正解

正解是错排啊，之前完全没听过。

错排：考虑一个有 ${\displaystyle n}$ 个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 ${\displaystyle n} $个元素的错排数记为 ${\displaystyle D_{n}}$ 或 ${\displaystyle !n}$。

$D_i$ 满足递推式：

$D_1=0,D_2=1$ 且 $D_i=(i-1) * (D_{i-1}+D_{i-2})$

证明略。

则：

$$ans=C_n^m * D_{n-m}$$

**代码**：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define maxn 1000005
#define lxl long long
using namespace std;

const lxl mod=1e9+7;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

inline lxl fti(lxl a,lxl b)
{
	lxl ans=0;
	while(b>0)
	{
		if(b&1) ans=(ans+a)%mod;
		a=(a+a)%mod;
		b>>=1;
	}
	return ans;
}

inline lxl fmi(lxl a,lxl b)
{
	lxl ans=1;
	a%=mod;
	while(b>0)
	{
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans;
}

int n,m;
lxl tim[maxn+5],d[maxn+5];

inline lxl C(lxl n,lxl m)
{
	return (tim[n]*fmi(tim[m]*tim[n-m],mod-2))%mod;
}

inline lxl Lucas(lxl n,lxl m)
{
	if(m==0) return 1;
	return C(n%mod,m%mod)*Lucas(n/mod,m/mod)%mod;
}

int main()
{
	//freopen("P4071.in","r",stdin);
	tim[0]=1;
	for(int i=1;i<=maxn;i++) tim[i]=(tim[i-1]*i)%mod;
	d[1]=0;d[2]=1;
	for(int i=3;i<=maxn;i++) d[i]=(lxl)(i-1)*(d[i-1]+d[i-2])%mod;
	int t=read();
	while(t--)
	{
		n=read(),m=read();
		if(n==m) {puts("1");continue;}
		printf("%lld\n",(Lucas(n,m)*d[n-m])%mod);
	}
	return 0;
}

```


---

## 作者：青鸟_Blue_Bird (赞：0)

（推荐在洛谷博客或者博客园食用哦）

### 这题要用到错排，先理解一下什么是错排：

#### 问题：有一个数集A，里面有n个元素 a[i]。求，如果将其打乱，有多少种方法使得**所有**第原来的i个数a[i]不在原来的位置上。

可以简单这么理解：

数集（初始）          
1\
2\
3\
4\
5\
6

错排转化后（一种情况）：

2\
1\
4\
3\
6\
5

于是，我们设f[i]为数集中有总共i个数时，其错排的方案数有多少。
那么，~~经过大量的手摸~~， 我们来求一下递推式：

f[0] = f[2] = 1, f[1] = 0,这些是显而易见的。当i大于3以后，假设存在一个数字k，我们手摸一下n出现在第k位的情况，发现会有以下两种：

1、数字n刚好在第k位，则我们要求的就是剩下n - 2个数的错排。即f[i - 2]\
2、数字n不在第k位，则我们要求的就是n - 1个数的错排，即f[i - 1]
又由于我们的k是属于区间[1, n）的，又有n - 1种取值。\
所以，我们要再乘上n - 1.即为 f[i] = (i - 1) * (f[i - 1] + f[i - 2]) 

### 回归本题 。   题目翻译：求在长为n的全排列中，第i位恰好是i，且满足条件的个数刚好有m个。  如果反过来看，就是把排列中的m个数抽出来，使得剩下的n - m个数全都不在自己的位置上。

#### 那么答案就很明显了，ans = C(n, m) * f[n - m];

代码来一波：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 1000010
#define isdigit(c) ((c)>='0'&&(c)<='9')
const ll mod = (int)1e9 + 7;

inline ll read(){
	ll x = 0;
	char c = getchar();
	while(!isdigit(c)){
		c = getchar();
	}
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');
		c = getchar();
	}
	return x;
}

ll n, m;
struct node{
	ll l, r;
} t[N];

ll inv[N], fac[N];
ll maxn = 0, maxm = 0;
ll f[N]; 

ll pow(ll a,ll b){//求a的 b次方 
	ll s = 1,temp = a;
	while(b){
		if(b & 1)s = (s * temp) % mod;
		temp = (temp * temp) % mod;
		b >>= 1;
	}
	return s % mod;
}

inline ll C(ll n, ll m){
	if(n < m) return 0;
	else return inv[n] * fac[m] % mod * fac[n-m] % mod;
}

void prepare(){
	inv[0] = fac[0] = 1;
    for(int i = 1;i <= maxn;i++)
        inv[i] = inv[i-1] * i % mod;
    fac[maxn] = pow(inv[maxn], mod - 2) % mod;//费马小定理求逆元
    for(int i = maxn - 1; i;i--)
        fac[i] = fac[i + 1] * (i + 1) % mod;  /*以上均是组合数求解*/
    f[1] = 0, f[2] = 1, f[0] = 1;
    for(int i = 3;i <= maxn; i++){
    	f[i] = ((i - 1) * (f[i - 1] + f[i - 2] % mod)) % mod; /*错排处理*/
	}
    return ;
}

int main(){
	ll T = read();
	for(int i = 1;i <= T; i++){
		n = read(), m = read();
		t[i] = (node){n, m}; 
		maxn = max(maxn, n);/*先找最大值可以降低某些点的复杂度*/ 
	}
	prepare();
	for(int i = 1;i <= T; i++){
		printf("%lld\n", C(t[i].l, t[i].r) * f[t[i].l - t[i].r] % mod);
		
	} 
	return 0;
}

```


---

## 作者：aiyougege (赞：0)

### 排列计数
#### Solution
　　这道题目还是很良心的.

　　求$\text{n}$的一种特殊排列的个数.它有$\text{m}$个数保持在原来的位置不会改变, 其实就是剩下的数全部改变了自己原本的位置.有$\text{m}$个数在自己原本的位置, 其实就是从$\text{n}$个人中选出$\text{m}$个人来——$C_{n}^{m}$, 剩下的问题就是从$\text{n-m}$的排列$p$满足$p_i\ne i, i\le n-m$的方案数, 其实这就是那个**装错信问题**.
	
***一个人写了n封不同的信及相应的n 个写有不同地址的信封，问没有一封信装入它本身该装入信封的方式有多少种？***

　　记$D_i$表示$\text{i}$个人全部送错信的方案数, 那么此题中$\text{n-m}$个人的排列方案数就是$D_{n-m}$.那么此题的答案为$C_{n}^{m}D_{n-m}$.

- 用**组合数递推公式**求组合数吃药丸, 不如用
$$\binom{n}{m}=\frac{n!}{m!(n-m)!}$$
- 实际上需要一个**线性求逆元**, 因为上述组合数公式需要**除法取模**.
- 实际上需要递推$D_i$.这个东西大概叫**全错位排列**, 有好几种方法求, 证明之类的有[***论文***](https://wenku.baidu.com/view/2371163fb52acfc789ebc9f3.html), 我就不班门弄斧了.
- 阶乘逆元什么的其他的可以借鉴楼下, 其实我也是……

**递推公式**为
$$D_{i+1}=n(D_{i}+D_{i-1}),n\ge 2$$
其中$D_{1}=0,D_{2}=1$

#### Code
```cpp
#include<cstdio>
#define N 1000005
#define int long long
#define mod 1000000007

int invfac[N];
int inv[N];
int fac[N];
int d[N];
int T;

main(){
    fac[0]=fac[1]=inv[0]=inv[1]=d[0]=d[2]=invfac[1]=invfac[0]=1;
    for(int i=2;i<N;++i)fac[i]=fac[i-1]*i%mod;//阶乘
    for(int i=3;i<N;++i)d[i]=(i-1)*(d[i-1]+d[i-2])%mod;//全错位排列
    for(int i=2;i<N;++i)inv[i]=(mod-mod/i)*inv[mod%i]%mod;//逆元线性递推
    for(int i=2;i<N;++i)invfac[i]=invfac[i-1]*inv[i]%mod;//阶乘的逆元
    scanf("%lld",&T);int a,b;
    while(T--){
        scanf("%lld%lld",&a,&b);
        printf("%lld\n",fac[a]*invfac[b]%mod*invfac[a-b]%mod*d[a-b]%mod);//根据组合数公式算出来
    }
    return 0;
}
```

---


# 忠诚

## 题目描述

老管家是一个聪明能干的人。他为财主工作了整整  $10$ 年。财主为了让自已账目更加清楚，要求管家每天记  $k$ 次账。由于管家聪明能干，因而管家总是让财主十分满意。但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚，他把每次的账目按  $1, 2, 3 \ldots$ 编号，然后不定时的问管家问题，问题是这样的：在   $a$ 到  $b$ 号账中最少的一笔是多少？为了让管家没时间作假，他总是一次问多个问题。

## 说明/提示

对于 $100\%$ 的数据，$m \leq 10^5$，$n \leq 10^5$。

## 样例 #1

### 输入

```
10 3
1 2 3 4 5 6 7 8 9 10
2 7
3 9
1 10```

### 输出

```
2 3 1```

# 题解

## 作者：Notshgiook (赞：93)

# 非常水的关于P1816【忠诚】的题解
# 前言：嘿嘿嘿嘿嘿嘿！！！！
这个题貌似非常有~~简单（滑稽）~~！可以很明显的看出这个题就是个板子题。众所周知，这是个问题，有无数种做法。such as 树状数组，线段树，ST表，暴力and so on！

本人非常的菜鸡只会ST表和线段树，对于~~树状数组~~那种高深的解法（~~包括lowbit那种玄学问题~~）鄙人并不明白！！


------------

## ST表解法
ST表示一种简单有效求静态RMQ（Range MIinimum/Maximum Query 离线查询区间最大最小值）问题的方法，他比较类似于动态规划（~~毒品！！！~~）

在进行ST表的操作中，我们用O( nlog(n) )的时间复杂度来进行预处理，用大概O(1) 的时间复杂度来进行查询

我们可以用一个数组 f[i][j] 来表示 “从i作为左端点，长度为 (1<<j) 长度的区间内的最大或最小值”

### 对于预处理而言 O（n log（n））
如果一个区间i的长度为1，那么f[i][0]就为位置i对应的值
对于一个长度为2的区间a—>b，我们可以用f[a][1]来表示这个区间的极值，那么对于这个区间而言，f[a][1]的最小值就可以看做min(a,b),即可以看做min(f[a][0],f[a+(1<<0)][0])。

如果我们把 左端点记做i，区间长度改为j呢
那么**f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1];**

所有我们在预处理的时候，我们不妨先枚举区间长度j，再枚举区间左端点i，只要能保证i+(1<<j)-1≤n，那么我们便可以将各种区间给预处理出来；

```
	for(register int i=1;i<=n;i++) scanf("%d",&f[i][0]);
	for(register int j=1;j<=20;j++)
	{
		for(register int i=1;i<=n;i++)
		{
			if(i+(1<<j)-1<=n) f[i][j]=min(f[i][j-1],f[i+(1<<j-1)][j-1]);
		}
	}
    

```
### 关于查询操作
我们首先读入了 某个区间的左端点L，和右端点R；
我们并不能保证 区间长度 （R-L+1） 是2的n次方。所以怎么才能用我们预处理的信息呢？（~~如果用不上预处理他干什么~~）

对于一个区间的最大值的数值，一个区间肯定只要一个，如果我们用他的两个有重叠的子区间来更新这个区间肯定没有任何问题。

那么我们可以找距离区间长度（R-L+1）最近的一个2的n次方数k，那么我们就可以用 **L为左端点，长度为k的区间**和**以R为右端点，区间长度为k**的两个区间长度来更新所求的区间。不懂得可以画画图！

综上所述，对于左端点为L，右端点为R的区间，他的最小值**MIN=min(f[L][log2(R-L+1)],f[R-(1<<(log2(R-L+1))+1][log(R-L+1]**

```
int ask(int l,int r)
{
	int k=log2(r-l+1);
	return min(f[l][k],f[r-(1<<k)+1][k]);
}
```
## 下面是鄙人的弱弱的代码
```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
#define maxn 100005
#define re register
int n,m,l,r,f[maxn][22];

int ask(int l,int r)
{
	int k=log2(r-l+1);
	return min(f[l][k],f[r-(1<<k)+1][k]);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(re int i=1;i<=n;i++) scanf("%d",&f[i][0]);
	for(re int j=1;j<=20;j++)
	{
		for(int i=1;i<=n;i++)
		{
			if(i+(1<<j)-1<=n)
			{
				f[i][j]=min(f[i][j-1],f[i+(1<<j-1)][j-1]);
			}
		}
	}
	for(re int i=1;i<=m;i++)
	{
		scanf("%d%d",&l,&r);
		printf("%d ",ask(l,r));
	}
	return 0;
}
```

于是你就可以看见你的屏幕中间绿了一片
![ST表——忠诚](https://cdn.luogu.com.cn/upload/pic/57790.png)



------------
## 现在我们开始转入线段树

众所周知，我们刚刚结束了紧张有趣的ST表，开始用可爱的线段树！！！

这个题没修改，没有lazytag！只需要把线段树建好，然后区间查询，那么无论相比于[P3372【模板】线段树1](https://www.luogu.org/problemnew/show/P3372)和[P3373【模板】线段树2](https://www.luogu.org/problemnew/show/P3373)实在是没有可比性，其实和[P1047校门外的树](https://www.luogu.org/problemnew/show/P1047)用线段树做差不多，用线段树更像是大材小用！

但是，线段树那么厉害！据某老师而言：st表，树状数组能做的事，线段树都能做（膜拜膜拜）；那么不妨开始线段树！！！

在没有区间修改的情况下，一个线段树就显得简单多了。

### 对于建树来看没有什么特别的地方，直接贴代码
```
void build(int p,int l,int r)
{
	s[p].l=l;
	s[p].r=r;
	if(l==r)
	{
		s[p].Min=data[l];
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	s[p].Min=min(s[p<<1].Min,s[p<<1|1].Min);
}
```

### 对于查询来看，不说什么了，还是直接贴代码吧

```
inline int ask(int p,int l,int r)
{
	if(l==s[p].l&&s[p].r==r) return s[p].Min;//如果恰好完全覆盖，则直接返回 
	int mid=s[p].l+s[p].r>>1;
	if(r<=mid) return ask(p<<1,l,r);//如果查询的区间完全在这个节点所代表的区间的左端，直接去查询左边 
	if(l>mid) return ask(p<<1|1,l,r);//如果查询的区间完全在这个节点所代表的区间的右端，直接去查询右边
	return min(ask(p<<1,l,mid),ask(p<<1|1,mid+1,r));//如果正好跨过中间 
} 
```

### 然后鄙人弱弱的代码~~~

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define maxn 100005
#define re register
#define INF 0x7fffffff

struct tree
{
	int l,r,Min=INF;
}s[(maxn<<2)+5];

int n,m,L,R,data[maxn];

void update(int p)
{
	s[p].Min=min(s[p<<1].Min,s[p<<1|1].Min);
}

void build(int p,int l,int r)
{
	s[p].l=l;
	s[p].r=r;
	if(l==r)
	{
		s[p].Min=data[l];
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	update(p); 
}

inline int ask(int p,int l,int r)
{
	if(l==s[p].l&&s[p].r==r) return s[p].Min; 
	int mid=s[p].l+s[p].r>>1;
	if(r<=mid) return ask(p<<1,l,r);
	if(l>mid) return ask(p<<1|1,l,r);
	return min(ask(p<<1,l,mid),ask(p<<1|1,mid+1,r));
} 

int main()
{
	scanf("%d%d",&n,&m);
	for(re int i=1;i<=n;i++) scanf("%d",&data[i]);
	build(1,1,n);
	for(re int i=1;i<=m;i++)
	{
		scanf("%d%d",&L,&R);
		printf("%d ",ask(1,L,R)); 
	}
	return ~~(0-0);
}
```

### 于是您的屏幕之前会出现一片绿色
~~（若不是你突然闯进我生活）~~~~

![线段树——忠诚](https://cdn.luogu.com.cn/upload/pic/57791.png)





------------
## 本蒟蒻太弱，若有不正确的地方请各位大神及时指出

---

## 作者：浅色调 (赞：61)

###典型的RMQ模板题，本人用了相对简单的ST表###

用数组a[i，j]表示从第i个数起连续2^j个数中的最小值，则很容易得到状态转移方程

**a[i][j]=min(a[i][j-1],a[i+2^(j-1)][j-1]);**

我们只需要开始时对于a数组进行预处理(时间复杂度n\*(logn))

注意：

**先更新所有长度为a[i][0]即1个元素，然后通过2个1个元素的最值获得所有长度为a[i][1]即2个元素的最值，以此类推更新。**

然后对于每一次查询(时间复杂度O(1));

若查询区间为(i，j)，易得区间长度为j-i+1，所以取k=log(j-i+1),则**min(i,j)=min(a[i][k],a[j-(1<<k)+1][k]);**

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int a[100005][20],m,n;
inline int getint()                    //读入优化
{
    int a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')f=1,x=getchar();
    while(x>='0'&&x<='9')
    {a=a*10+x-'0';x=getchar();}
    return f?-a:a;
}
void rmq_st(int n)                //预处理，st表
{
    for(int j=1;j<=20;j++)
    for(int i=1;i<=n;i++)           //思考为什么外循环j套i，而不是外循环i套j
    if(i+(1<<j)-1<=n)
    a[i][j]=min(a[i][j-1],a[i+(1<<(j-1))][j-1]);   //原因在于每个区间更新都是由1个点开始慢慢增加区间范围
}
int main()
{
    m=getint();n=getint();
    for(int i=1;i<=m;i++)a[i][0]=getint();   //读入数据，对于每个点开始时最小值就是它本身
    rmq_st(m);
    while(n--)
    {
        int l=getint(),r=getint(),k=log2(r-l+1);
        printf("%d ",min(a[l][k],a[r-(1<<k)+1][k]));        //查询时注意思路 
    }
    return 0;
}
```

---

## 作者：离子键Ionic_Bond (赞：50)

# 不就是个ST表板子啊
## ST表详解：
### 引入：
**- ST表用于解决$R.M.Q$问题（区间最值问题）**

**1.预处理原理**
- **首先是这张图**
![](https://cdn.luogu.com.cn/upload/pic/58967.png)
- **倍增的目的是快速预处理每个区间的最大值而不遗漏，查询时只需取出该区间最大值即可;**

- **每次处理，都用$maxn[i][j]$数组存下$[i...i+2^j-1]$区间的最大值，总的时间复杂度为$O(nlogn)$**

~~这一部分的代码有点暴力意味，相当于打了个表~~
```cpp
const int MAXN=21;//maxn的值根据实际情况而定
for(int j=1;j<=MAXN;j++）//注意j在外层循环
	for(int i=1;i+(1<<j)-1<=n;i++)
		maxn[i][j]=max(maxn[i][j-1],maxn[i+(1<<(j-1))][j-1];
```
**2.查询原理**
- **又是一张图**
![](https://cdn.luogu.com.cn/upload/pic/58969.png)
- **设$k=log_2R$**
- **查询$L$~$R$这一区间的最大值，就是求$max(maxn[L][k],maxn[R-2^k+1][k])$**
- **为啥呢？**
- **很明显有时候对$R$取底会得到一个小数甚至是无理数**如：
>$log_25≈2.32192809$

- **这时，就会出现向下取整，引用不全的情况**
- **所以我们从头到尾再从尾到头地查两遍，把区间全部覆盖就会避免这样的问题**
这一部分代码极简如下，~~思路清晰优美显然~~
```cpp
int lookit(int le,int ri)
{
	int lg;
	lg=log2(ri-le+1);
	return min(minn[le][lg],minn[ri-(1<<lg)+1][lg]);
}
```
# 看AC代码


------------
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int lef,rig;
int n,m;
int minn[2333333][30];
int ans[100001];
/*查询*/
int lookit(int le,int ri)
{
	int lg;
	lg=log2(ri-le+1);
	return min(minn[le][lg],minn[ri-(1<<lg)+1][lg]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&minn[i][0]);
	}
	/*预处理*/
	for(int j=1;j<=21;j++)
	{
		for(int i=1;i+(1<<j)-1<=n;i++)
		{
			minn[i][j]=min(minn[i][j-1],minn[i+(1<<(j-1))][j-1]);
		}
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&lef,&rig);
		ans[i]=lookit(lef,rig);
	}
	for(int i=1;i<=m;i++)printf("%d",ans[i]);
	return ~~(0-0)
}
```
## ~~话说洛谷MARKDOWN变了好多啊，代码高亮用法求解~~
- ~~我太弱了连markdown都不会用了~~

**最后请管理员帮我过一下这个题解，虽然有用ST表做的，但不如我这个讲得详细嘛**

---

## 作者：life_w_back (赞：36)

**先按照动归做的，结果的了九十分，代码比较好理解；**
## 就超了4毫秒。。。。。。。。。
### 90分代码；
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int main(){
    int m,n,t,k,ans=9999999;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++){
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){
        scanf("%d%d",&t,&k);
        for(int j=t;j<=k;j++){
            ans=min(ans,a[j]);
        }
        printf("%d ",ans);
        ans=9999999;
    }
    return 0;
}
```
------------
# 下面是AC程序；
### 主要是快排，先把账目排一遍，再找提问范围里靠前的，找到后就输出；（比较好理解）
#### 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct fff{
  int x,y;  
};
fff a[100001];
bool cmp(fff l,fff v){
    return l.x<v.x;
}
int main(){
    int m,n,t,k;
    scanf("%d%d",&m,&n);
        for(int i=1;i<=m;i++){
            scanf("%d",&a[i].x);
            a[i].y=i;    //为每个账目编号；
        }
        sort(a+1,a+1+m,cmp);
        for(int i=1;i<=n;i++){
            scanf("%d%d",&t,&k);
            for(int j=1;j<=m;j++){
                if(a[j].y>=t&&a[j].y<=k){
                    printf("%d ",a[j].x);
                    break;     //一个小优化；
                }
            }
        }
    return 0;
}
```

---

## 作者：yybyyb (赞：24)

好吧，老是用线段树就没意思了。

这道题又不需要对区间进行修改操作

直接用树状数组就行了

每个节点都是lowbit上来的点的最小值即可

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int a[1000001];    
int tree[1000001];   
int n,m;
int lowbit(int x)
{
    return x&(-x);
}
void update(int x,int v)
{
    while(x<=n)
    {
        if(tree[x]>v)
          tree[x]=v;
         else
          return;     
        x+=lowbit(x);  
    }
}
int getmin(int x,int y)
{
    int now=y;
    int maxl=2147483647;
    while(now>=x)
    {
        if(now-lowbit(now)>x)
        {
           maxl=min(maxl,tree[now]);
           now-=lowbit(now);
        }
        else
         {
             maxl=min(maxl,a[now]);
             --now;
         }
    }
    return maxl;
}
int main()
{
    memset(tree,127,sizeof(tree));
    cin>>n>>m;
    int x,y;
    //n++;
    for(int i=1;i<=n;++i)
     {
         cin>>a[i];
         update(i,a[i]);
     }
    for(;m>0;--m)
    {
        cin>>x>>y;
        cout<<getmin(x,y)<<' ';
    }
    return 0; 
}
```

---

## 作者：decoqwq (赞：13)

qwq~~我特别喜欢暴力分块~~，给大家介绍一下此题的分块做法

首先是分块这种算法，时间复杂度是$O(\sqrt n)$级别的，不是很快也不是很慢 ~~代码短最适合我这种懒人了~~

首先是如何分块

```cpp
block=sqrt(n);
for(int i=1;i<=n;i++)
{
	scanf("%d",&a[i]);
	belong[i]=(i-1)/block+1;//每个数属于哪一块
	minn[belong[i]]=min(minn[belong[i]],a[i]);//每一块维护最小值
}
```
这一题只需要维护每一块最小值即可

而查询操作主要是这样的：
```cpp
序列：1 2 3 4 5 
查询：[2,5]间最小值
可知1 2是一块，3 4是一块，5是一块
minn[1]=1,minn[2]=3,minn[3]=5//每块最小值
先查询第一个不完整的块[2,2]，暴力查询最小值为2
再查询一个整块[3,4]，最小值为minn[2]=3
最后查询不完整的快[5,5]，暴力查询最小值为5
所以[2,5]最小值为2
```
查询代码：
```cpp
int query(int x,int y)
{
	int minx=0x3f3f3f3f;
	for(int i=x;i<=min(belong[x]*block,y);i++)//处理左边不完整块
	{
		minx=min(minx,a[i]);
	}
	if(belong[x]!=belong[y])//如果不在同一块
	{
		for(int i=(belong[y]-1)*block+1;i<=y;i++)//处理右边不完整块
		{
			minx=min(minx,a[i]);
		}
	}
	for(int i=belong[x]+1;i<belong[y];i++)//处理完整块
	{
		minx=min(minx,minn[i]);
	}
	return minx;
}
```
因为暴力查询的点肯定小于$2 \sqrt n$，查询的块个数也小于等于$\sqrt n$，故每次查询时间复杂度为$O(\sqrt n)$，总时间复杂度$O(n \sqrt n)$
最后上代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int block;
int n,m;
int belong[100010],a[100010],minn[400];
int query(int x,int y)
{
	int minx=0x3f3f3f3f;
	for(int i=x;i<=min(belong[x]*block,y);i++)
	{
		minx=min(minx,a[i]);
	}
	if(belong[x]!=belong[y])
	{
		for(int i=(belong[y]-1)*block+1;i<=y;i++)
		{
			minx=min(minx,a[i]);
		}
	}
	for(int i=belong[x]+1;i<belong[y];i++)
	{
		minx=min(minx,minn[i]);
	}
	return minx;
}
main()
{
	memset(minn,0x3f3f3f3f,sizeof(minn));
	cin>>n>>m;
	block=sqrt(n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		belong[i]=(i-1)/block+1;
		//cout<<"count "<<i<<":"<<minn[belong[i]]<<" "<<a[i]<<endl;
		minn[belong[i]]=min(minn[belong[i]],a[i]);
		//cout<<"count "<<i<<":"<<minn[belong[i]]<<" "<<a[i]<<endl;
	}
	/*for(int i=1;i<=5;i++)
	{
		cout<<minn[i];
	}*/
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%lld%lld",&x,&y);
		printf("%lld ",query(x,y));
	}
}
 
```

---

## 作者：Inkyo (赞：10)

## [题目](https://www.luogu.org/problem/P1816)，[blog阅读体验更佳](https://www.luogu.org/blog/266011/solution-p1816)

------------

想用树状数组其实也可以。线段树难写又难调，$ST$表不好维护边界条件。相对来说树状数组要均衡一些。

**已经有人写了树状数组做法了（而且还在第一页，可以自己去看）。但是他并没有解释树状数组如何解决此类问题。我这里来补充一下。**

----------

建树没什么好说的，把传统树状数组的加改成求最值函数即可。

**但是对于区间求最值，有人表示有些看不懂**

>guodong：“getmin函数有点蒙”

这里解释一下树状数组区间求最值的方法。

假设我们现在要求$[x,y]$的区间最值。对于求区间和的树状数组来说，我们一般是求$[1,x-1]$和$[1,y]$的区间和，然后再相减得到答案。**显然求最值不满足这种性质。**

我们可以考虑拆开$[x,y]$这个区间。以下，我们分两种情况讨论

- **The first case：** 当$y-lowbit(y) > x$时

	显然，我们可以把$[x,y]$拆成$[x,y-lowbit(y)]$ 和$[y-lowbit(y) + 1,y]$。拆成这个样子有什么好处呢？**如果再细心一点，可以发现$[y-lowbit(y) + 1,y]$其实就是$tree[y]$。** 这里可以自己口算一下验证。

	这样，我们求最值的区间直接减小了一半。效率其实还不错。

- **The second case：** 当$y-lowbit(y) < x$

	这种情况下，由于$y-lowbit(y)$会超过左区间范围，这个时候，考虑直接把$[x,y]$拆为$[x,y - 1]$ 与 $a[y]$。**这样看似只拆了一个出来，但是拆过后$[x,y - 1]$区间可能就满足了第一种情况。** 所以效率其实也很不错。

	然后，上述过程用递归完成即可。当递归到某一层，$x==y$，这个时候返回$a[x]$或者$a[y]$即可

**代码大致是这样的：**

```cpp
int _findmin(int x, int y)//区间查询最小值 
{ 
    if(y > x)
    {
        if(y - lowbit(y) > x) return min(treex[y], _findmax(x, y - lowbit(y)));
        else return min(a[y], _findmin(x, y - 1));
    }
    return a[x];
}
```

剩下的，写个标准的树状数组即可。

---

## 作者：JasonZRY (赞：9)

## 来一发线段树：

### 定义：

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。

### 基本结构编辑

线段树是建立在线段的基础上，每个结点都代表了一条线段[a,b]。长度为1的线段称为元线段。非元线段都有两个子结点，左结点代表的线段为[a,(a + b) / 2]，右结点代表的线段为[((a + b) / 2）+1,b]。

下图就是一棵线段树。

![](http://img1.imgtn.bdimg.com/it/u=2123623719,206087890&fm=26&gp=0.jpg)

![](data:image/jpeg;base64,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IONpwMY7mtjT/Bc+rWEV7YfEXxLcW0y7o5BcLtYdMj5a6HxrfT2mifYrBtuoalItnbeoZ/vN/wABXc34VuabYQaXYW9jbJtgt4ljQegAAFAHD/Dw6jDr/ivSb3VrzUo9PuoY4ZbuTcwBTcfbvXodcF4I/wCR98ff9f1v/wCiq72gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA5rxR4MtPFkdkLq9vrSSzlMsM1jKI5FbGM7sE1jD4Wpjnxr4zz7asf/AImu+ooA4H/hVsf/AEOvjP8A8G5/+Jo/4VbH/wBDr4z/APBuf/ia76igDlfDPgSz8MardanHqmrahd3MSwySahciY7QcgA7Qf1qbxv4Ym8WeHW0y3vEtJDNHMszR7wpRg3TI9K6SigDgR4c+Iw6eOrIf9whP8aP+Ed+I5/5nux/8E6f4131FAHAf8I58Rv8AoebH/wAE6f40v/COfEbv47ssen9kJ/jXfUUAcp4K8K6h4bfVp9T1SPULvUrkXEkkcHlAELjpk11dFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFcD41/5KJ4A9rq6/8ARNd9XM+KfBth4smsXvLm/tpLJmeGWzm8tgWAB5wewoA6C5tory3eCeNJIZFKujjIYHgg1gaf4I0rTJHlt/tLTmJoYpZrl5WgQ9o95Owew9BWP/wqmw/6GbxV/wCDVv8ACj/hVNh/0M3ir/wat/hQBt3Hg3TbrS7Gxk89RYoEt54p2jmQAYPzqQeR19a0tJ0ez0SxSzsYRHEpJPJZnY9WYnkk9STXJf8ACqbD/oZvFX/g1b/Cj/hVNh/0M3ir/wAGrf4UAHxF/wCQ54H9tcQ/+ONXReMv+RG8Qf8AYNuP/RTVz9v8LdLtdUsb9tX127ls5hNCt5fGVA46HBFdZrWnnVtA1DTRL5X2u2kg8zbu271K5x3xnpQBheEbCLUvhboVnPu8mfSIYn2MVO1ogDgjkda2LvQbW60BtFUvb2hhEAEJ2lUGAAD9BiuM07wR460zTbbT7P4hpFa2sSwwodEibaijAGS2TwKtf8It8Q/+ikR/+CKH/wCKoA6ubRLS41Kyv5ELT2QcW5LHCbwATjpnAxntk+taVcF/wi3xD/6KRH/4Iof/AIqj/hFviH/0UiP/AMEUP/xVAB4I/wCR98ff9f1v/wCiq72uR8HeEtQ8N3mr3mpa0NVvNTlSWWYWogwVXb90Ejpj0rrqACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/Z)

长度范围为[1,L] 的一棵线段树的深度为log (L) + 1。这个显然，而且存储一棵线段树的空间复杂度为O(L）。

线段树支持最基本的操作为插入和删除一条线段。下面以插入为例，详细叙述，删除类似。

将一条线段[a,b] 插入到代表线段[l,r]的结点p中，如果p不是元线段，那么令mid=（l+r）/2。如果b<mid，那么将线段[a,b] 也插入到p的左儿子结点中，如果a>mid，那么将线段[a,b] 也插入到p的右儿子结点中。

插入（删除）操作的时间复杂度为O（logn）。

###### 摘自度娘

## 下面我们看回这题

区间查询啊，明显的线段树啊！！！

代码：

```
#include<bits/stdc++.h>
#define ls o*2                           //左儿子编号为2*i 
#define rs o*2+1                         //右儿子编号为2*i+1 
using namespace std;
int n,m,p,x,y,minn[400005];
void build(int o,int l,int r){           //递归建树 
	if(l==r){
		cin>>minn[o];
		return;
	}
	int mid=(l+r)/2;
	build(ls,l,mid);
	build(rs,mid+1,r);
	minn[o]=min(minn[ls],minn[rs]);
}
int ask(int o,int l,int r,int x,int y){  //二分递归询问
	if(r<x||y<l)return 0;
	if(x<=l&&y>=r)return minn[o];
	int mid=(l+r)/2;
	int v1=0x7fffffff,v2=0x7fffffff;
	if(x<=mid)v1=ask(ls,l,mid,x,y);
	if(y>mid)v2=ask(rs,mid+1,r,x,y);
	return min(v1,v2);
}
int main(){
	ios::sync_with_stdio(false);          //关闭同步流，cin会更快 
	cin.tie(0);                           //妈妈再也不用担心我的cin会超时啦
	cin>>n>>m;
	build(1,1,n);                         //构造线段树 
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		cout<<ask(1,1,n,x,y)<<" ";        //询问 
	}
	return 0;
}
```

线段树推荐：

[P4523 小白逛公园](https://www.luogu.org/problem/P4513)

[P1970 花匠](https://www.luogu.org/problem/P1970)

[P5094 USACO04OPEN MooFest 狂欢节](https://www.luogu.org/problem/P5094)

[P1083 借教室](https://www.luogu.org/problem/P1083)

[P1047 校门外的树](https://www.luogu.org/problem/P1047) （☜对，你没看错，这东西标程就是线段树）

---

## 作者：Tessie (赞：7)

像线段树这种高深东西我不懂

（因为我太蔡了）

所以呢，我的第一直觉告诉我，这道题可以用桶排序。

原因是因为打完暴力，下了一组数据，看到输出很多都是0

~~于是只要范围间有0就break~~

桶排序可以AC，我还是很震惊的=w=

```c
#include <cstdio> //本蒟蒻最喜欢的唯一的头文件
int ai[100001];
int min=999999;
int shu[100001][101];
// shu[233][666]表示数字233出现第666次所在的位数
int shu_biao[100001];//用于记录每个数字出现的次数
//如 shu_biao[2]表示数字2出现的次数
int a,b;
int m,n;
int ji=0;
int main()
{
	
	scanf("%d %d",&m,&n);//正常输入
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&ai[i]);
		shu_biao[ai[i]]++;//对应数字出现次数+1
		shu[ai[i]][shu_biao[ai[i]]]=i;//对应数字存上位置
	}
	
	for(int i=1;i<=n;i++)
	{
		scanf("%d %d",&a,&b);
		ji=0;
		for(int i=0;i<=100000;i++)//本蒟蒻的桶排序
		{
			for(int j=1;j<=shu_biao[i];j++)
			{
				if(a<=shu[i][j] && shu[i][j]<=b)
				{
					ji=1;
					min=i;
					break;//只要在i数字找到，就直接跳出循环
				}
			}
			if(ji==1)
			{
				break;
			}
		}
		printf("%d ",min);//正常输出
	}
	
	return 0;
}
```

~~本蒟蒻现在线段树还没搞懂呢~~

---

## 作者：jxcakak (赞：6)

来一个不太一样的解法：离线+单调队列。

先把所有询问读进来按右端点排序（这里我用了基数排序），然后按顺序将每个点插入队列。插入队列的时候如果队尾的元素的大于待插入的元素就弹出，这样就保证队列内的元素是递增的。

对于每个询问，在这个询问的右端点被插入后，在队列中二分下标大于等于左端点的第一个数，由于队列是递增的，所以二分出来的数就是答案。

这样做常数要比线段树小很多。

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
struct data{int l,num;}; vector<data> G[100001];
int a[100001],ans[100001],Q[100001],l=1,r=0;
int main(){
    int n,m; scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    for(int i=1;i<=m;++i){
        int l,r; scanf("%d%d",&l,&r); G[r].push_back({l,i});
    }
    for(int i=1;i<=n;++i){
        for(;l<=r&&a[Q[r]]>=a[i];--r); Q[++r]=i;
        for(int j=0;j<G[i].size();++j) ans[G[i][j].num]=a[*lower_bound(Q+l,Q+r+1,G[i][j].l)];
    }
    for(int i=1;i<=m;++i) printf("%d ",ans[i]); return 0;
}
```

---

## 作者：LemonJuice95 (赞：4)

这道题，本蒟蒻只会线段树qwq

先来讲一下线段树的概念。

维护一棵区间长度为10的线段树是这样的：

![线段树_区间长度10_.PNG](https://i.loli.net/2019/11/21/3WTVQYqCAgSJH24.png)

所以我们可以看到，一个叶子节点的 l 是等于 r 的。

那么就可以写出如果下落到叶子的情况：

```
if(l==r)
{
    tree[p]=a[l];
    return;  //由于已经到叶子了，所以没必要执行下面的操作了
}
```

可是如果不是叶子呢？

那么还可以从上图看出，结点的左子树和右子树的区间分别是 [l,mid] 和 [mid+1,r]

由此写出：

```
int mid=(l+r)>>1  //位运算更快
build(l,mid,p<<1);  //l=区间最左边的下标，r=区间最右边的下标，p=树的数组的下标
build(mid+1,r,p<<1|1);
```

这样一个build的过程就写好了：

```
void build(int l,int r,int p)
{
    if(l==r)
    {
        tree[p]=a[l]
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,p<<1);
    build(mid+1,r,p<<1|1);
    tree[p]=min(tree[p<<1],tree[p<<1|1]);  //在上面的build都完成之后，这个结点要合并左右子树的解
}
```

接下来是query的部分

既然树已经构建好了，那么对于区间的一个查询也是较为容易的，如果x<=l 且 y>=r了，那么就说明查询的区间已经重合或包含在了 [l,r] 之间

所以query也是很容易的：

```
int query(int l,int r,int p,int x,int y)//x是查询区间的左端下标，y是查询区间的右端下标
{
    if(x<=l && r>=y)
        return tree[p];  //返回这一个区间的解
    int mid=(l+r)>>1;
    int a,b;  //小小的优化
    a=b=1e9;
    if(x<=mid) a=query(l,mid,p<<1,x,mid);
    if(y>mid) b=query(mid+1,r,p<<1|1,mid+1,y);
    return min(a,b);//返回解
}
```
AC代码：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,q,a[100005],tree[400005]; //树必须定义成数组的四倍
void build(int l,int r,int p)
{
	if(l==r)
	{
		tree[p]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,p<<1);
	build(mid+1,r,p<<1|1);
	tree[p]=min(tree[p<<1],tree[p<<1|1]);  //合并子树的解
}
int query(int l,int r,int p,int x,int y)
{
	if(x<=l && y>=r) //判断[x,y]有没有包含在[l,r]中
		return tree[p]; //返回解
	int mid=(l+r)>>1;
    int a,b; //优化
    a=b=1e9;
	if(x<=mid) a=query(l,mid,p<<1,x,y);
	if(y>mid) b=query(mid+1,r,p<<1|1,x,y);
	return min(a,b);
}
int main()
{
	scanf("%d%d",&n,&q); //输入账目个数和问题个数
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]); //输入每个账目的钱数
	build(1,n,1); //建树
	while(q--)
	{
        int x,y; //查询区间
		scanf("%d%d",&x,&y); //输入要查询的区间
		printf("%d ",query(1,n,1,x,y));  //进行查询
	}
	return 0; //完结撒花
} 
```

---

## 作者：傅思维666 (赞：4)

# ST算法求区间最值
RMQ问题的经典裸题，知识点是使用ST算法快速求解区间最大值（最小值）

个人认为ST算法是比较数学的一个方法，思想很独特也很好用。

这里简单介绍一下ST算法以及我对ST算法的浅薄理解。

首先我们明确ST算法的适用范围，即给定数列区间求最值。设每个查询区间为[x,y]，那么它的长度就是y-x+1，（很好理解吧）。ST算法的原理是动态规划以及倍增思想，换句话说，假如我们要求解一个区间的最大值最小值，我们可以这样考虑：把一个区间分成两块，求左边那块和右边那块的最值，最后把答案汇总更新即可。那么我们的动归状态就出来了：

设f[i][j]为数列a中a[i]到a[i+2^j-1]这个区间的最值。

状态转移方程：

f[i][j]=max(f[i][j-1],f[i+2^(j-1)][j-1]);

初值很好判断，将f[i][0]置成a[i]即可。

我们可以在O（nlogn）的时间内预处理f数组。

具体过程如下：
```cpp
for(int j=1;(1<<j)<=n;j++)
    for(int i=1;i<=n;i++)
        f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
```
这里要注意，j一定要写在外层！！

然后对于每个询问，我们可以用O（1）的时间求解。

这里要注意，我们ST算法的原理是倍增和DP，也就是在左区间和右区间分别求最大值，但是我们的询问并不一定是2的n次方个元素，也就是我们再最终计算的时候，一定需要考虑两个区间重合的情况。

对于询问[x,y]，用一个变量k记录log[y-x+1].

所以ans=max(f[x][k],f[y-(1<<k)+1][k]);

很好理解吧！

好好敲模板，这道题不难AC。

Code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m;
int lg[100010],f[100010][20],ans[100010];
int main()
{
    scanf("%d%d",&m,&n);
    //lg[0]=-1;
    for(int i=1;i<=m;i++)
        scanf("%d",&f[i][0]);
    for(int i=2;i<=m;i++)
        lg[i]=lg[i>>1]+1;
    for(int j=1;(1<<j)<=m;j++)
        for(int i=1;i+(1<<j)-1<=m;i++)
            f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        int k=lg[y-x+1];
        ans[i]=min(f[x][k],f[y-(1<<k)+1][k]);
    }
    for(int i=1;i<n;i++)
        printf("%d ",ans[i]);
    printf("%d",ans[n]);
    return 0;
}
```


---

## 作者：mulberror (赞：4)

安利一下自己的[博客](https://www.cnblogs.com/Dawn-Star/p/9782076.html)
#题目描述
老管家是一个聪明能干的人。他为财主工作了整整10年，财主为了让自已账目更加清楚。要求管家每天记k次账，由于管家聪明能干，因而管家总是让财主十分满意。但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚，他把每次的账目按1，2，3…编号，然后不定时的问管家问题，问题是这样的：在a到b号账中最少的一笔是多少？为了让管家没时间作假他总是一次问多个问题。

#分析
关于线段树的详细讲解可以参考拙作（点击传送门）：[【算法微解读】浅谈线段树](https://www.cnblogs.com/Dawn-Star/p/9678198.html)
那么我们就开始讲解一下这一道模板题，题目的主要意思就是区间查询最小值。
首先定义线段树的节点的状态`segment_tree_node`
```cpp
struct segment_tree_node{//线段树节点状态
	int Min;//表示当前区间的最小值
}tree[maxn];
```
-----
接下来就是建树`build`的过程了。
```cpp
void build(int l,int r,int nod) {//建树
	if (l==r) {//如果l与r指针相撞，那么就是已经到了目标区间，赋值
		tree[nod].Min=a[l];
		return;
	}
	int mid=(l+r)>>1;//取中间mid
	build(l,mid,lson); build(mid+1,r,rson);//lson和rson可以恒定义一下，缩短代码
	pushup(nod);//更新父节点
}
```
----
建树好之后，我们要进行一下区间查询的操作，区间查询的本质其实就是将原区间分成两部分，然后对每一个区间的目标区间进行查询。
`|----l----|----r----|`当做是原区间
* 情况一：[ll,rr]区间在l区间内，那么就是`query(l,mid,ll,rr,lson)`意思就是在[l,mid]区间内查询[ll,rr]
* 情况二：[ll,rr]区间在r区间内，那么就是`query(mid+1,r,ll,rr,lson)`意思就是在[mid+1,r]区间内查询[ll,rr]
* 情况三：[ll,rr]区间一部分在l区间内，一部分在r区间内，那么就要把原区间和目标区间都分成两部分，因为线段树中同一深度的区间互不干扰，那么我们就查询`query(l,mid,ll,mid,lson),query(mid+1,r,mid+1,rr,rson)`
>注：区间查询一般是不需要pushup的，但是如果之前是有区间修改，那么是要pushdown的。
那么我们通过代码来详细的看一下区间查询最小值是如何写的。

```cpp
int query(int l,int r,int ll,int rr,int nod) {//区间查询最小值
	if (l==ll&&r==rr) return tree[nod].Min;//已经找到了目标区间
	int mid=(l+r)>>1;//取中间
	if (rr<=mid) return query(l,mid,ll,rr,lson);//整个区间在mid的左边
	else if (ll>mid) return query(mid+1,r,ll,rr,rson);//整个区间在mid的右边
	else return min(query(l,mid,ll,mid,lson),query(mid+1,r,mid+1,rr,rson));//区间被mid分成两部分
}
```
----
主程序就不写了，也是很简单的
>恒定义：define lson nod<<1 define rson (nod<<1)+1

#完整代码
```cpp
#include <bits/stdc++.h>
#define lson nod<<1
#define rson (nod<<1)+1
#define ms(a,b) memset(a,b,sizeof(a))
using namespace std;
const int maxn=100000<<2;
const int inf=1<<30;
struct segment_tree_node{//线段树节点状态
    int Min;
}tree[maxn];
int n,m;
int a[maxn>>2];
inline int read() {
    int x=0,w=0; char ch=0;
    while (!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while (isdigit(ch)) {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return w?-x:x;
}
void pushup(int nod) {//pushup操作，更新父节点内的信息
    tree[nod].Min=min(tree[lson].Min,tree[rson].Min);
}
void build(int l,int r,int nod) {//建树
    if (l==r) {//如果l与r指针相撞，那么就是已经到了目标区间，赋值
        tree[nod].Min=a[l];
        return;
    }
    int mid=(l+r)>>1;//取中间mid
    build(l,mid,lson); build(mid+1,r,rson);//lson和rson可以恒定义一下，缩短代码
    pushup(nod);//更新父节点
}
int query(int l,int r,int ll,int rr,int nod) {//区间查询最小值
    if (l==ll&&r==rr) return tree[nod].Min;//已经找到了目标区间
    int mid=(l+r)>>1;//取中间
    if (rr<=mid) return query(l,mid,ll,rr,lson);//整个区间在mid的左边
    else if (ll>mid) return query(mid+1,r,ll,rr,rson);//整个区间在mid的右边
    else return min(query(l,mid,ll,mid,lson),query(mid+1,r,mid+1,rr,rson));//区间被mid分成两部分
}
int main() {
    ms(tree,inf);//先将树的每一个节点都赋值成inf，因为我们要求最小值
    n=read(),m=read();
    for (int i=1;i<=n;i++) a[i]=read();
    build(1,n,1);
    while (m--) {
        int x=read(),y=read();
        printf("%d ",query(1,n,x,y,1));
    }
    return 0;
}
```

---

## 作者：crowworks695 (赞：4)

这道裸的RMQ居然没人发RMQ的题解。。。

RMQ主要思想是倍增，用f[i][j]表示包括i在内i之后的2^j个数中的最小值，于是有状态转移方程 f[j][i]=min(f[j][i-1],f[j+(1<<(i-1))][i-1]);


[codec]







```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int maxm=1e5+1e4;
int bill[maxm],f[maxm][40];
int min(int a,int b)
{
    return a<b?a:b;
}
int query(int l,int r)
{
    int i=0;
    for(;(1<<i)+l-1<=r;i++){}
    i--;
    return min(f[l][i],f[r-(1<<i)+1][i]);//这里是找出长度小于且最接近要查询的区间长度的i，然后答案就是min(f[l][i],f[r-(1<<i)+1][i])
}
int main()
{
    int n,m;
    memset(f,0x7f,sizeof(f));
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",bill+i);
        f[i][0]=bill[i];
    }
    for(int i=1;(1<<i)<m;i++)
    {
        for(int j=1;j+(1<<i)-1<=m;j++)
        {
            f[j][i]=min(f[j][i-1],f[j+(1<<(i-1))][i-1]);
        }
    } 
    for(int i=1;i<=n;i++)
    {
        int t1,t2;
        scanf("%d%d",&t1,&t2);
        printf("%d ",query(t1,t2));
    }
    return 0;
}
[/codec]
```

---

## 作者：清远学会 (赞：3)

# 遇事不决先分块

>用分块感受暴力的优美

用分块维护块内的最小值，对于整块，块内最小值才会对答案产生贡献，而对于残块，应遍历残块的所有值以保证答案的正确性

>复杂度应为根号级别，比线段树要慢一些，但代码实现与代码长度要短的多；

### 奉上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 200500
using namespace std;

int n,m;
int a[N],Min[N];
int tag[N],L[N],R[N];

inline int Ask(int l,int r) {
	int res = 999999999;
	if(tag[l] == tag[r]) {
		for(int i = l;i <= r;i ++)
			res = min(res,a[i]);
		return res;
	}
	for(int i = l;i <= R[tag[l]];i ++) res = min(res,a[i]);
	for(int i = tag[l] + 1;i < tag[r];i ++) res = min(res,Min[i]);
	for(int i = L[tag[r]];i <= r;i ++) res = min(res,a[i]);
	return res;
}

int main() {
	memset(Min,127,sizeof(Min));
	scanf("%d%d",&n,&m); int len = sqrt(n);
	for(int i = 1;i <= n;i ++) scanf("%d",&a[i]);
	for(int i = 1;i <= n;i ++) tag[i] = (i - 1) / len + 1;
	for(int i = 1;i <= tag[n];i ++) 
		L[i] = R[i - 1] + 1,R[i] = min(L[i] + len - 1,n);
	for(int i = 1;i <= tag[n];i ++)
		for(int j = L[i];j <= R[i];j ++) 
			Min[i] = min(Min[i],a[j]);
	for(int i = 1;i <= m;i ++) {
		int l,r; scanf("%d%d",&l,&r);
		printf("%d ",Ask(l,r));
	}		
	return 0;
}
```


---

## 作者：Katoumegumi (赞：3)

###  zkw线段树解法：
- 什么？在主函数里写完一颗线段树？这就是zkw线段树的优势之一，短小易写。

- 什么？线段树不用递归？不用递归这一特性使得zkw线段树常数更小，更接近于树状数组。


------------

它到底有多好写？以本题为例，zkw线段树的代码长度只有0.63KB，~~简直是懒人福音~~
以下是本题的zkw代码，这种不带修的区间问题……写起来就非常简单，代码也没什么好说的：

可以结合图来理解或手动模拟：

(ps:节点上为节点编号二进制表示)
![图片](http://thyrsi.com/t6/366/1535854347x-1566663106.png)

```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define l(x) x<<1
#define r(x) x<<1|1
using namespace std;

int n,m,M=1;
int c[100005<<2];//表示节点个数一般开不小于区间长度+2的最小2的正整数次幂*2+10，因为懒就直接乘四了……
int main()
{
    scanf("%d%d",&n,&m);
    while(M<=n) M<<=1;
    memset(c,127,sizeof(c));
    for(int i=1; i<=n; i++) scanf("%d",&c[i+M]);//底层记录长度为一的区间
    for(int i=M-1; i>=1; i--)
        c[i]=min(c[l(i)],c[r(i)]);//建树
    while(m--) {
        int x,y;
        scanf("%d%d",&x,&y);
        int ans=c[0];
        for(x=M+x-1,y=M+y+1; x^y^1; x>>=1,y>>=1) {//从底层开始跳转，当处于同一层时跳出，查询的区间处理为开区间
            if(~x&1) ans=min(ans,c[x^1]);//是否为左儿子
            if(y&1) ans=min(ans,c[y^1]);//是否为右儿子
        }
        printf("%d ",ans);
    }
}

```
~~顺便宣自己新开的博客~~:http://www.cnblogs.com/KatouKatou/
找时间在博客上填个zkw的坑……

---

## 作者：沉辰 (赞：3)

今天复习RMQ，用以前的板子交了一遍A了，后来自己手打，发现了好几处错误。

注意的点：

1）询问的时候把区间分成两部分，l -> l+2^k  和r-2^k+1  ->r...

2)预处理的时候一定要赋值

```cpp
//特此纪念
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
using namespace std;
inline int read()
{
    int x=0,w=1;char ch=0;
    while(ch<'0' || ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;     
}
/*含义：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j<=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。
```
时间复杂度：预处理时间复杂度O（n\*log(n)），查询O(1)
基础：dp

F[i][j]表示从第i位起，2^j个数中的最值。

那么dp的初值是什么？

显然f[i][0]的值为a[i]。

Dp的方程呢？

对于i~i+2^j-1这段区间，我们将它分为长度相同的两部分：

显然2^j=2^(j-1)+2^(j-1),所以分为i~i+2^(j-1)-1, i+2^(j-1)~i+2^j-1；

那么f[i][j]=max/min(f[i][j-1],f[i+2^(j-1)][j-1])。

所以当查询一段区间[l,r]时：

int k=trunc(log2(r-l+1));

int ans=max/min(f[l][k],f[r-2^k+1][k]);

\*/
```cpp
int n,m;
int a[100004];
int f[100004][30];
//f[i][j]表示以i为起点，区间长度为2^j的一段区间的最小（大）值 
void YU()
{
    for(int i=1;i<=n;i++) f[i][0]=a[i];
    for(int j=1;(1<<j)<=n;j++)
     for(int i=1;i+(1<<j)-1<=n;i++)//因为区间的定义，所以注意循环
      f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);
    //是DP原理 
      //根据需要取min或者max 
}
int query(int l,int r) 
{
    int u=int(log2(r-l+1));//l->r区间长度---为2^k(向下取整) 
    //cout<<l<<" "<<r<<" "<<(1<<u)<<" "<<u<<endl; 
    return min(f[l][u],f[r-(1<<u)+1][u]); 
    //根据需要取min或者max 
}
int main()
{
    n=read();m=read();//n个数，m次询问
    for(int i=1;i<=n;i++) a[i]=read();
    YU();//RMQ的预处理，是O(nlogn)的
    for(int i=1;i<=m;i++)
    {
      int l,r;
      l=read();r=read();
      printf("%d ",query(l,r));//查询是O(1)的    
    } 
    return 0;
}

```

---

## 作者：S_Gloria (赞：2)

**轻轻说一句树状数组好少啊...**

~~于是我找到了我存在的意义~~

如果树状数组没有接触过的话，建议戳这里->
[非常详细的树状数组基础](https://www.luogu.org/paste/sd8iz57b)

这个题与普通树状数组求和的区别就在于c_数组中存的不再是和而是最小值。

具体在代码中讲

 _写在前面：_
 
 a_代表输入的原数组
 
 c_代表原序列a中区间[x-lowbit(x)+1,x]的最小值
 
 这段加点操作的代码貌似是简明易懂的叭QwQ
```cpp
void update(int x,int k)//加点操作
{
	a[x]=k;
	while(x<=n)
	{
		c[x]=min(c[x],k);
		x+=lowbit(x);
	}
}
```

接下来是求区间[l,r]最小值。
如图
![](https://cdn.luogu.com.cn/upload/image_hosting/jljrprcx.png)
若我要求区间[3,6]最小值，就是求min(a[3],a[4],a[5],a[6])（蓝框框内），但这样复杂度过高，于是我就利用树状数组啦

这就转化成了求min(a[3],a[4],c[6])，当然数据太小看不出有什么优势，但是当一波大数据接近时就会大大提高效率。

这两部分怎么分开呢？详见代码好了QwQ~
```cpp
int getmin(int l,int r)
{
	int ans=a[r];//小小初始化相信都理解
	while(l!=r)
	{
		r--;//r--就相当于上图从a[5]到a[4]的跨越
		while(r-lowbit(r)>=l)
		{
			ans=min(ans,c[r]);
			r-=lowbit(r);
		}
		ans=min(ans,a[r]);
	}
	return ans;
}
```

由于这个题没有
要求区间修改，所以较简单。
完整代码：

```cpp
#include<stdio.h>
#include<iostream>
#include<string.h>
using namespace std;
int c[200005],a[200005];
int n,m;
int lowbit(int x)
{
	return x&(-x);
}
void update(int x,int k)
{
	a[x]=k;
	while(x<=n)
	{
		c[x]=min(c[x],k);
		x+=lowbit(x);
	}
}
int getmin(int l,int r)
{
	int ans=a[r];
	while(l!=r)
	{
		r--;
		while(r-lowbit(r)>=l)
		{
			ans=min(ans,c[r]);
			r-=lowbit(r);
		}
		ans=min(ans,a[r]);
	}
	return ans;
}
int main()
{
	memset(c,127,sizeof(c));
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		update(i,a[i]);
	}
	while(m--)
	{
		int l,r;
		cin>>l>>r;
		printf("%d ",getmin(l,r));
	}
}
```

[博客广告QwQ](https://www.luogu.org/blog/S-Gloria/)


---

## 作者：吃的 (赞：2)

- ## 题意

    给定$m$个元素的序列，有$n$次询问，每次询问区间$[l,r]$内的最小值。

- ## 分析

  看到题目，判断这是一个**区间查询最小值**问题。

  因为不带修改，用$ST$表即可$AC$，实现$O(N\log N)$的预处理，$O(1)$查询的时间复杂度。

  能不写线段树尽量不写线段树 ~~好吧是我太蒻了~~。
  
  如果你$A$了$ST$表的模版题，可以不要看这篇题解了。

- ## ST表

  - 注意：下文均使用左闭右开区间，区间用表格表示。~~凑合着看。~~
  
  - 预处理

    $ST$表实际上是一个递推的过程。我们设$f[i][j]$为区间$[i,i + 2^j)$内（或者说从第$i$个数开始包括的$2^j$个数中）的最小值。

    若读入了$m$个数字，令它们存储在数组$a[m]$中。
由$ST$表定义可得，$f[i][0]=a[i]$（区间里只有$2^0=1$个数字，该数字就是最小值）。

  - 如何递推？
  
    递推式子：
$f[i][j]=\min(f[i][j-1], f[i+2^{j-1}][j-1])$。

    怎么理解？区间$[i,i + 2^j)$可以看做由两个小区间组成，分别是该区间的前半部分和后半部分。整个区间的最小值由它们的最小值合并得来。

    举个栗子：对于区间$[1,9)$

    | 1|2  |3  |4  |5  |6  |7  |8  |
    | :----------- | :----------- | :----------- | :-----------     | :----------- | :----------- | :----------- | :----------- |
    |这|是|区|间|这|是|区|间|
    可以表示为$f[1][3]$，这个区间的最小值由区间$[1,5)$和$[5,9)$的答案合并得来。

    又$f[1][2]$表示$[1,5)$，
    | 1|2  |3  |4  |
    | :----------- | :----------- | :----------- | :-----------    |
    |这|是|区|间|
    $f[5][2]$表示$[5,9)$。
    |5  |6  |7  |8  |
    | :----------- | :----------- | :----------- | :----------- |
    |这|是|区|间|

    $f[1][3]=\min(f[1][2],f[5][2])$

    $\ \ \ \ \ \ \ \ \ \ \ \ =\min(f[1][3-1],f[1+2^{3-1}][3-1])$。

    把规律推广一下即可。
   
   - 区间查询
 
     我们预处理的区间最小值，区间长度都是$2^n$，如果题目查询的区间长度是$2^n$，那很简单，如果不是呢？
     
     比如 区间$[1,8)$
     
     |  1|  2|  3|  4|  5|  6|  7|
     | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
     |这|真|的|是|区|间|啊|
     
     考虑把这个区间分成两个小区间$[1,5)$
     | 1|2  |3  |4  |
     | :----------- | :----------- | :----------- | :-----------    |
     |我|是|区|间|
     和$[4,7)$，
     | 4|5  |6  |7  |
     | :----------- | :----------- | :----------- | :-----------    |
     |我|是|区|间|
     用小区间的答案合并而成。
     
     这两个区间的长度都是$4=2^2$，已经预处理了。合并一下。
     
     令查询区间为$[l,r)$就是要找到一个最小的$k$，满足$2^{k+1}>r-l$。此时必有$2^k\le r-l$。即$2^k\le$区间长。且$2^k>\frac12*$区间长，所以两个长为$2^k$的区间足以覆盖整个大区间。
     
     这里证明的时候用左闭右开区间，但是题目给我们的是闭区间，我们对于询问的区间$[x,y]$，将之分为两个区间，左端点向右$2^k$个元素的区间，和右端点向左$2^k$个元素的区间，即区间$[l,l+2^k],[r-2^k+1,r]$。
     
     你可能会注意到，这两个区间都可能会重叠，是否会对答案有影响？
     
     然而这并没有什么影响。请先自己思考一下原因。
     
     如果最终答案在重叠区间之内，两个区间的$\min$都会是最终答案，再取$\min$对结果没有影响。
     
     如果最终答案不在重叠区间之内，重叠区间对答案更没有影响。
     
     但如果改成区间求和问题就有影响了。区间求和不允许把一个元素计算两次。
     
     综上所述，$query(l,r)=\min(f[l][k],f[r-2^k+1][k])$。
     
     
$AC$代码
~~~cpp
  #include <algorithm>
  #include <cstdio>
  #include <iostream>
  #include <cmath>

  using namespace std;

  const int N = 1e5 + 5, CNT = 20; //常量
  int n, m;
  int f[N][CNT]; //预处理数组

  //自己写一个min函数，会快一点吧……
  //内联+常量引用+三目运算符 加速
  inline int mn(const int& x, const int& y) {
      return x < y ? x : y;
  }

  //快读 不解释
  inline int read(void){
      register int b = 1, c = getchar(), r = 0;
      while (!isdigit(c)) b = c == '-' ? -1 : 1, c = getchar();
      while (isdigit(c))  r = r * 10 + c - '0', c = getchar();
      return r * b;
  }

  //ST表的预处理，原理在前面有，此处不赘述
  inline void build(void) {
      for (int i = 0; i < n; ++i) {
          f[i][0] = read();
      }
      for (int j = 1; (1 << j) <= n; ++j) {
          for (int i = 0; i + (1 << j) - 1 < n; ++i) {
              f[i][j] = mn(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
          }
      }
  }

  //查询操作
  inline int query(const int& l, const int& r) {
  //找到最小的k，你也可以用cmath库的log2函数
      int k = 0;
      while ((1 << (k + 1)) <= r - l + 1) {
          ++k;
      }
      return mn(f[l][k], f[r - (1 << k) + 1][k]);
  }

  int main(void) {
      n = read(); m = read();
      build();
      while (m--) {
          int l, r;
          l = read(); r = read();
          //因为我让元素从0开始存储，查询时区间要左移1位。
          printf("%d ", query(l - 1, r - 1));
      }
      return 0;
  }
~~~

---

## 作者：NeosKnight (赞：2)

一道练习线段树基本操作的好题，这道题就是用线段树来查询区间最小值；

虽然查询最小值我们可能首先想到的是 暴力（听说可以出奇迹，但这题没给你机会）

是的，这题数据量太大，用暴力铁定超时；（啥，你说把区间中的元素全区出来排序？那还不如一个个找呢）

所以嘛，这题还是用线段树吧，查找区间最小值；


‘‘cpp’‘

```cpp
    #include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
struct linetree{
    int low;
    int l;int r;
}a[400001];
int m,n;
inline int read()//读入优化路过。。 
{
    int x=0;char ch=getchar();
    int t=1;
    while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
    if(ch=='-') 
    {
        t=-1;ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*t;
}
void build(int now,int l,int r)//建树 
{
    if(l==r){
        a[now].low=read();
        a[now].l=l;a[now].r=r;
        return ;
    }
    a[now].l=l;
    a[now].r=r;
    int mid=l+r>>1;
    build(now<<1,l,mid);
    build(now<<1|1,mid+1,r);
    a[now].low=min(a[now<<1].low,a[now<<1|1].low);
    return ;
}
int Query(int now,int L,int R)
{
    if(a[now].l>=L&&a[now].r<=R){
        return a[now].low;
    }
    int mid=a[now].l+a[now].r>>1;
    int ans=2147483647;//赋为很大的数 
    if(mid>=L) ans=min(ans,Query(now<<1,L,R));
    if(mid<R) ans=min(ans,Query(now<<1|1,L,R));//线段树查找区间最小值； 
    return ans; 
}
int main()
{
    m=read();n=read();
    build(1,1,m);
    for(register int i=1;i<=n;i++)
    {
        int l,r;
        l=read();r=read();
        cout<<Query(1,l,r)<<" ";
    }
    return 0;
}
’‘’‘
```

---

## 作者：小卖部招商 (赞：2)

[P1816 忠诚](https://www.luogu.org/problem/P1816)
# RMQ算法（简洁易懂）
### 一个刚刚学了RMQ算法的蒟蒻，~~忍不住想来发篇题解。~~
看了那么多篇题解，也有写RMQ的巨佬，但是沉了，作为RMQ的深爱者，忍不住想来发篇题解，若有相似，不好意思啊
# ST表
来看个样例

3，2，4，7，4取区间最小值
|  | 2^0 |2^1  |2^2  |
| -----------: | -----------: | -----------: | -----------: |
| 3 | 3 | 2 |2  |
| 2 | 2 |  2| 2 |
| 4 | 4 |  4|  |
| 7 | 7 |  4|  |
| 4 | 4 |  |  |

### 我们发现其实就是去两个包括目标区间的小区间，求其中的最小值

对于一串数字，从第l个到第r个之间最大或最小的数。

我们可以用一个数组**f[i][j]** 来存储。但是我们看看题目的范围发现，这个数组好像会太大。

所以我们在设一个**k=log2(l-r+1)** 来压缩空间，同时表示以i为左端点，区间长度为2^k次，以j为端点的数列中最大或最小的数。

但是我们会发现这个区间长度可能不恰好为2^n次方，所以我们可以在两段区间内比较，**一段以i为左端点的2^k次方的数列**，**另一端以j为右端点，向左边扩2^k次的数列**，进行比较。
## 那么问题来了
**在读入这一串数列后，我们怎么建这个~~NB不拉几~~的ST表呢**

我们核心的一点就是在RMQ函数里 **，先循环j，确定区间长度，从而循环左端点，** 进行初始化。

**代码来一波**
```cpp
void rmq()
{
for(int j=1;j<=20;j++)//区间长度的循环 
   for(int i=1;i<=m;i++)//左端点 
       if(i+(1<<j)-1<=m)
   a[i][j]=min(a[i][j-1],a[i+(1<<(j-1))][j-1]);
   //区间查找,进行st表的建立, 
}
```
**接下来就是，如何进行整体判定了**
```cpp

for(int i=1;i<=n;i++)	
{
    cin>>l[i]>>r[i];
    k[i]=log2(r[i]-l[i]+1);//长度klog
}
for(int i=1;i<=n;i++)
    cout<<min(a[l[i]][k[i]],a[r[i]-(1<<k[i])+1][k[i]]);
//确定两端数列,寻找最小值
```
## 接下来，献上小蒟蒻的代码，若不喜欢我的码风，敬请见谅。
```cpp
#include<bits/stdc++.h>//万能头文件,真香
#define maxn 100010//宏定义一波
using namespace std;
int n,m,a[maxn][20],l[maxn],r[maxn],k[maxn];
//emmmm,因为喜欢看输出在一行,就用了数组
void rmq()
{
    for(int j=1;j<=20;j++)//区间长度的循环 
      for(int i=1;i<=m;i++)//左端点 
        if(i+(1<<j)-1<=m)
         a[i][j]=min(a[i][j-1],a[i+(1<<(j-1))][j-1]);
//区间查找,进行st表的建立, 
}
int main()
{
	cin>>m>>n;
	memset(a,0,sizeof(a));
	for(int i=1;i<=m;i++)	cin>>a[i][0];
	rmq();
	for(int i=1;i<=n;i++)	
	{
		cin>>l[i]>>r[i];
		k[i]=log2(r[i]-l[i]+1);//长度klog
	}
for(int i=1;i<=n;i++)
    cout<<min(a[l[i]][k[i]],a[r[i]-(1<<k[i])+1][k[i]])<<" ";
	//确定两端数列,寻找最小值
	cout<<endl;
    system("pause");
	return 0;
}

```


---

## 作者：king_xbz (赞：1)

搜线段树的标签找到的题，不得不说，这道绿题确实要比模板题简单了不少。

线段树的基础知识请戳->[线段树模板1精讲](https://www.luogu.com.cn/blog/kingxbz/xian-duan-shu-1-mu-ban-wen-ti)：

建树部分:
```cpp
inline void build(int x,int l,int r)
{
    tree[x].l=l;
    tree[x].r=r;
    if(l==r)
    {
    tree[x].tot=a[l];
    return ; 
}
    //如果l=r，线段树树值直接等于相应项的数字 
    int mid=(r+l)/2;
    //二分建树 
    build(x*2,l,mid);
    //左区间是2*x 
    build(x*2+1,mid+1,r);
    //右区间是2*x+1 
    tree[x].tot=min(tree[x*2].tot,tree[x*2+1].tot);
    //父节点=左右子节点中的较小者 
}
```
二分查找：
```cpp
inline int sectiondfs(int x,int l,int r)
{
    if(tree[x].l>=l&&tree[x].r<=r)
    return tree[x].tot;
    //完全包含就直接返回父节点值 
    if(tree[x].r<l||tree[x].l>r)
    return 0;
    //完全包含就返回0 
    int mid=(tree[x].l+tree[x].r)/2;
    //寻找中间节点 
    int t=4536235665,s=4536235665; 
    if(l<=mid)
    t=sectiondfs(2*x,l,r);
    //左区间包含就搜索左区间 并更新答案 
    if(r>mid)
    s=sectiondfs(2*x+1,l,r);
    //右区间包含就搜索右区间并更新答案 
    return min(t,s);
    //返回最小的区间答案
 } 
 ```
 完成代码
 ```cpp
 #include<bits/stdc++.h>
#define fread ios::sync_with_stdio
#define int long long
#define fint register long long
#define p 147323
#define h 6001
using namespace std;
int n,m;
struct node
{
	int l;
	int r;
	int tot;
	int flag;
}
tree[p*4];
int a[p]; 
inline void build(int x,int l,int r);
inline int sectiondfs(int x,int l,int r,int ll,int rr);
inline void change(int x,int l,int r,int y);
inline void pushdown(int x);
signed main()
{
	fread(false);
	cin>>m>>n;
	for(fint i=1;i<=m;i++)
		cin>>a[i];
		build(1,1,m);
		for(fint i=1;i<=n;i++)
		{
		int c,d; 
		cin>>c>>d;
		cout<<sectiondfs(1,c,d,1,n)<<" ";
		}
		exit(0);
}
inline void build(int x,int l,int r)
{
	tree[x].l=l;
	tree[x].r=r;
	if(l==r)
	{
	tree[x].tot=a[l];
	return ; 
}
    int mid=(r+l)/2;
	build(x*2,l,mid);
	build(x*2+1,mid+1,r);
	tree[x].tot=min(tree[x*2].tot,tree[x*2+1].tot);
}
inline int sectiondfs(int x,int l,int r,int ll,int rr)
{
	if(tree[x].l>=l&&tree[x].r<=r)
	return tree[x].tot;
	if(tree[x].r<l||tree[x].l>r)
	return 0;
	int mid=(tree[x].l+tree[x].r)/2;
	int t=4536235665,s=4536235665; 
	if(l<=mid)
	s=sectiondfs(2*x,l,r,ll,mid);
	if(r>mid)
	t=sectiondfs(2*x+1,l,r,mid+1,rr);
	return min(t,s);
 } 
 ```
 其实这道题也可以用如树状数组，dp等解决，大家尽可以探索一下；
 
 祝大家ac愉快！

---

## 作者：USSENTERPRISE (赞：1)

# $0.$ RMQ问题

[P1816](https://www.luogu.com.cn/problem/P1816)

人话翻译

给定一个长度为$n$的数列$a$，然后有$m$组询问，每次询问一个区间$[l,r]$的最小值。

其中$m,n\leq10^5$

# $1.$ 暴力做法

很显然，暴力做法就是便历 $\max\limits_{l\leq i\leq r}a_i$ 。这个做法最坏时间复杂度将会高达$O(n^2)$。很显然，这对于$1e5$的数据范围要炸

# $2.$ 正解
## 线段树

如果不知道什么是线段树，请点击这里 [线段树](https://www.luogu.com.cn/blog/USSENTERPRISE-juruo/post-suan-fa-xue-xi-bi-ji-xian-duan-shu)

对于这种区间信息，线段树显然是能够维护的。但鉴于本题没有区间修改，线段树显然有点大材小用，并且数组模拟的线段树空间将会达到$O(4n)$

线段树还有一些缺点，就是它的查询时间复杂度最坏是$O(logn)$的，因为没有区间修改，这个时间开销也略微有点大。

## $ST$表(倍增)

倍增算法的含义就是成倍增长。我们考虑一个这样的数据结构：

一个二维数组$st$，其中 
$$st_{i,j}=\min\limits_{i\leq k\leq i+2^j}a_k$$

我们假设一个数据：$9\ 3\ 1\ 7\ 5\ 6\ 0\ 8$

可以建立如下所示的$ST$表：

![](https://cdn.luogu.com.cn/upload/image_hosting/2idlr0yc.png)

### 建表

我们发现，我们可以一层层地建表。这样，我们就可以通过递推，利用上层的信息，建表。

我们先将读入数据存在$0$这一行。

我们发现，要想实现建立这个表，我们需要每次倍增长度。而最简单的倍增长度方法就是将两段不相交的区间合并起来。

所以我们可以得到如下公式：

$$st_{i,j}=min(st_{i,j-1},st_{i+2^{j-1},j-1}$$

这样，我们就能完成建表

```cpp
for(rg int i=1;i<=16;i++){ // 由计算器可得 log1e5 约为 17，但是这里循环16次已经够了。
	for(rg int j=1;j+(1<<i)-1<=n;j++){
		st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);
	}
}
```
* 注：为了方便，我们常常把这个表“竖”过来。本篇中的代码一律如此

我们可以发现，建表的时间复杂度是$O(nlogn)$的

### 查询

我们由上表知道，想要查询$[l,r]$的最值，只需求出 
$$ min(st_{l,log(len)},st_{r-2^{log(len)+1},log(len)})$$

其中

$$ len=r-l+1 $$

比如上方的数据，我们想要查询$[3,8]$

我们只需要从$3$往后$4$个，$8$ 往前$4$个，肯定能够完全覆盖这个区间

所以我们的查询开销是$O(1)$的

```cpp
ans=min(st[(int)log2(len)][l],st[(int)log2(len)][r-(1<<((int)log2(len)))+1]);
```

至此，我们已经完成了全部内容



---

## 作者：NIMNIM (赞：1)

## 看到这道题的第一眼——ST表
### ST算法求解RMQ问题 

RMQ(Range Minimum/Maximum Query)问题是求区间最值问题。~~可以写一个线段树（我现在并不会写），但是预处理和查询的复杂度都是O（logn)。这里有更牛的算法，就是~~ST（Sparse Table）算法，可以做到O(nlogn)的预处理，O(1)地回答每个询问。

来看一下ST算法是怎么实现的(以最大值为例）：
首先是预处理，用一个DP解决。设a[i]是要求区间最值的数列，f[i,j]表示从第i个数起连续 个数中的最大值。例如数列3 2 4 5 6 8 1 2 9 7 ,f[1，0]表示第1个数起，长度为 的最大值，其实就是3这个数。f[1，2]=5，f[1，3]=8，f[2，0]=2，f[2，1]=4……从这里可以看出f[i,0]其实就等于a[i]。这样，Dp的状态、初值都已经有了，剩下的就是状态转移方程。我们把f[i，j]的求值区间平均分成两段（因为 一定是偶数），从i到 为一段， 为到 为为一段(长度都为 为）)。用上例说明，当i=1，j=3时就是3,2,4,5 和 6,8,1,2这两段。f[i，j]就是这两段的最大值中的最大值。于是我们得到了动规方程

f[i,j]=max(f[i,j-1],f[i+2^(j-1),j-1]);

F[i,j]表称为稀疏表（Sparse Table）。有了稀疏表，我们就可以做到O(1)时间查询任意区间的最值。如在上例中我们要求区间[2，8]的最大值，就要把它分成[2,5]和[5,8]两个区间，因为这两个区间长度为 ，最大值我们可以直接由f[2，2]和f[5，2]得到。扩展到一般情况，就是把区间[l，r]分成两个长度为 的区间（保证有f[i，j]对应，其中 为小于r-l+1的最大值）。即，q[l,r] 表示 从第l个数到第r个数中最大的数,那么：

q[l,r]=max(f[l,j],f[r-2^j+1,j]);

（算最大值同理~~）
还有道题可以练练手（模板题，较轻松，但时间有点卡）[P3865 【模板】ST表](https://www.luogu.org/problemnew/show/P3865)


~~如果你觉得复制这题的题解，改个max,min就可以过那题的话你可以试试~~

题解奉上~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[100005][20]={},ans[1000005];
int main ( )
{
    int n,m,zs,l,r,q;
    cin>>n>>m;
    zs=(int)(log2(n));
    for(int k=1;k<=n;k++)
    cin>>f[k][0];
    for(int j=1;j<=zs;j++)
    for(int i=1;i<=n;i++)
    {
        q=1<<j;
        if(i+q-1<=n) 
        f[i][j]=min(f[i][j-1],f[i+q/2][j-1]);
        else
        break;
    }
    for(int k=1;k<=m;k++)
    {
        cin>>l>>r;
        zs=(int)(log2(r-l+1));
        q=1<<zs;
        ans[k]=min(f[l][zs],f[r-q+1][zs]);
    }
    for(int k=1;k<=m;k++)
    cout<<ans[k]<<" ";
    return 0;
}
```

PS：有一点提醒下，"i<<j"是将i转成二进制后整体向左移动j位，即为i*2^j；"i>>j"则为向右。

---

## 作者：Celebrate (赞：1)

P1816 这一题是一道模版题，所以比较容易

这一题本想记忆化搜索的，但是后来感觉会爆，所以就

没有这样了，直接线段树，不做任何优化一样能AC

代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
struct node
{
    int l,r,lc,rc,c;
    //l表示tr控制的最左，r表示tr控制的最右 
    //lc表示tr坐孩子的编号，rc表示右孩子的编号(左右两孩子几乎平分l-r, 可能存在1的差别） 
    //c表示l-r的最小值 
}tr[210000];int len;
int n,m,a[110000];
void bt(int l,int r)//建立l-r范围的线段树 
{
    len++;int now=len;//记录当前，原因是后面len会增加 
    tr[now].l=l;tr[now].r=r;//坐孩子和右孩子 
    tr[now].lc=tr[now].rc=-1;//一开始两个孩子的坐标为-1 
    if(l==r) tr[now].c=a[l];//判断最底层 
    else
    {
        int mid=(l+r)/2;//分成两半 
        tr[now].lc=len+1;bt(l,mid);//生成左边 
        tr[now].rc=len+1;bt(mid+1,r);//生成右边 
        tr[now].c=min(tr[tr[now].lc].c,tr[tr[now].rc].c);//他的值就是坐孩子与右孩子中最小的那个 
    }
}
int findmin(int now,int l,int r)//now表示这个点的编号，l-r的范围 
{
    if(l==tr[now].l && r==tr[now].r) return tr[now].c;//如果是要找的范围，就return最小值 
    int lc=tr[now].lc,rc=tr[now].rc;
    int mid=(tr[now].l+tr[now].r)/2;
         if(r<=mid)   return findmin(lc,l,r);//如果完全在左边 
    else if(mid+1<=l) return findmin(rc,l,r);//如果完全在右边 
    else return min(findmin(lc,l,mid),findmin(rc,mid+1,r));//如果有在左边也有在右边
}
int main()
{
    int i,x,y;
    scanf("%d%d",&n,&m);//输入 
    for(i=1;i<=n;++i) scanf("%d",&a[i]);
    len=0;bt(1,n);//初始化 
    for(i=1;i<=m;++i)
    {
        scanf("%d%d",&x,&y);
        if(x>y){int t=x;x=y;y=t;}//如果x>y 
        printf("%d ",findmin(1,x,y));//输出 
    }
    printf("\n");
    return 0;
}
```

---

## 作者：redegg (赞：1)

只会写线段树的我...

看倍增看不懂，但是我一眼就看出这是线段树。

一般考虑多次更新，访问的题就是线段树啦，当然时间也会比较慢（总比你一个一个枚举好）。

先是建树，我在建树的同时也更新了树（题又没说要不断地添数）。

```cpp
void build(int l,int r,int id)
{
    if(l==r)
    {
        a[id].x=b[l];
        return ;
    }
    int mid=(l+r)/2;
    build(l,mid,id*2);
    build(mid+1,r,id*2+1);
    a[id].x=min(a[id*2].x,a[id*2+1].x);
}
```
访问的话分三种情况（线段树套模板呗），一种左边，一种右边，还有一种是从两边都返回值（看不懂还是赶快补习吧）

```cpp
int ck(int l,int r,int z,int y,int id)
{
    //cout<<l<<" "<<r<<endl;
    //system("pause");
    if(l==z&&r==y)
    {
        return a[id].x;
    }
    else
    {
        int mid=(l+r)/2;
        //cout<<mid<<endl;
        if(mid>=y)return ck(l,mid,z,y,id*2);
        else if(mid<z)return ck(mid+1,r,z,y,id*2+1);
        else return min(ck(l,mid,z,mid,id*2),ck(mid+1,r,mid+1,y,id*2+1));
    }
}
```
以下为全代码：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
using namespace std;

struct tree
{
    int m;
    int x;
}a[500000];

int b[200000];

void build(int l,int r,int id)
{
    if(l==r)
    {
        a[id].x=b[l];
        return ;
    }
    int mid=(l+r)/2;
    build(l,mid,id*2);
    build(mid+1,r,id*2+1);
    a[id].x=min(a[id*2].x,a[id*2+1].x);
}

int ck(int l,int r,int z,int y,int id)
{
    //cout<<l<<" "<<r<<endl;
    //system("pause");
    if(l==z&&r==y)
    {
        return a[id].x;
    }
    else
    {
        int mid=(l+r)/2;
        //cout<<mid<<endl;
        if(mid>=y)return ck(l,mid,z,y,id*2);
        else if(mid<z)return ck(mid+1,r,z,y,id*2+1);
        else return min(ck(l,mid,z,mid,id*2),ck(mid+1,r,mid+1,y,id*2+1));
    }
}


int main()
{
    int n,m;
    scanf("%d%d",&n,&m);

    for(int i=1;i<=n;i++)
    {
        scanf("%d",&b[i]);
    }

    build(1,n,1);

    for(int i=1;i<=m;i++)
    {
        int q,e;
        scanf("%d%d",&q,&e);
        printf("%d ",ck(1,n,q,e,1));
    }
    printf("\n");
    return 0;
}
```

---

## 作者：Drug__Lover (赞：1)

**RMQ板子题没毛病**

**区间最大最小值**

**初始化的时候利用了动规的思想**

**就是把每个区间分成两部分**

**然后这个区间的最值就是这两个区间之中的一个了**

**然后就可以直接查询了**


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int m,n;
int minn[100001][22];
int RMQ_init()
{
    for(int j=1;1<<j<=m;j++)
        for(int i=1;i+(1<<j)-1<=m;i++)
            minn[i][j]=min(minn[i][j-1],minn[i+(1<<(j-1))][j-1]); 
}
int RMQ_ask(int l,int r){
    int k=log2(r-l+1);
    return min(minn[l][k],minn[r-(1<<k)+1][k]);
}
int main()
{
    cin>>m>>n;
    for(int i=1;i<=m;i++) scanf("%d",&minn[i][0]);       //每个数的最小值就是他自己 
    RMQ_init();           //预处理 
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        printf("%d ",RMQ_ask(x,y));     //查询区间最值 
    }
    return 0;
}
```

---

## 作者：nekko (赞：1)

QAQ有木有人也写整体二分啦。。。

（可能是因为写的太挫导致T了10分。。。）

区间最小值。。。换句话来说就是区间1th。。。

普通的求最小值是可以通过二分+判断查到的。。。

整体二分就是将询问进行二分进行查询。。。

也就是说二分一个答案。。。所有可能比答案更大的放到一边，更小的放到一边，然后分治下去。。。

参见poj2704 kth number。。。

附上代码 http://www.cnblogs.com/KingSann/articles/7340240.html


---

## 作者：WLQ567 (赞：1)

这些天考的题都跟线段树有关，所以来复习一下

看见之前写的代码，都不知道什么意思了，唉~




```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1//不知道之前看到哪位大神的代码，这样写确实方便很多
using namespace std;
const int maxn=100000+10;
const int INF=1<<30;
int n,m;
int sum[maxn*4];
void Pushup(int rt){
    sum[rt]=min(sum[rt<<1],sum[rt<<1|1]);
```
}//向上传递



```cpp
void build(int l,int r,int rt){
    if(l==r){
        scanf("%d",&sum[rt]);
        return;
    }
    int m=(l+r)>>1;
    build(lson);//方便吧
    build(rson);
    Pushup(rt);
}
int query(int L,int R,int l,int r,int rt){
    if(L<=l&&r<=R)return sum[rt];
    int m=(l+r)>>1;
    int ret=INF;
    if(L<=m)ret=min(ret,query(L,R,lson));
    if(R>m)ret=min(ret,query(L,R,rson));//维护区间最值（min）
    return ret;
}
int main(){
    scanf("%d%d",&n,&m);
    build(1,n,1);//建树过程
    int x,y;
    while(m--){
        scanf("%d%d",&x,&y);
        printf("%d ",query(x,y,1,n,1));
    }
}
这题太裸了，居然一次AC
```

---

## 作者：fighter_OI (赞：1)

同二楼思路。裸的线段树。维护最小值。

Pascal版本：

```cpp
uses math;
var f,a:array[1..2000000] of longint;
    n,m,i,x,y,ans:longint; op:char;
procedure buildtree(l,r,k:longint);
var mid:longint;
begin
 if l=r then
  begin
   f[k]:=a[l];
   exit;
  end;
 mid:=(l+r) shr 1;
 buildtree(l,mid,k shl 1);
 buildtree(mid+1,r,k shl 1+1);
 f[k]:=min(f[k shl 1],f[k shl 1+1]);
end;
procedure find(l1,r1,l2,r2,k:longint);
var mid:longint;
begin
 if (l1=l2)and(r1=r2) then
  begin
   ans:=min(f[k],ans);
   exit;
  end;
 mid:=(l2+r2) shr 1;
 if r1<=mid then 
  begin 
   find(l1,r1,l2,mid,k shl 1);
   exit;
  end;
 if l1>mid then
  begin
   find(l1,r1,mid+1,r2,k shl 1+1);
   exit;
  end;
 find(l1,mid,l2,mid,k shl 1);
 find(mid+1,r1,mid+1,r2,k shl 1+1);
end;
begin
 read(n,m);
 for i:=1 to n do read(a[i]);
 buildtree(1,n,1);
 for i:=1 to m do
  begin
   readln(x,y);
         ans:=1000000000;  
         find(x,y,1,n,1);
         write(ans,' ');
  end;
end .
```

---

## 作者：timetravler (赞：1)

当我A完这道题看题解才发现原来TM能用RMQ。。。(╯‵□′)╯︵┻━┻。我表示脑抽了。。。

思路：这道题明显线段树。设t[x].l以及t[x].r分别为此节点的l—r区间的父节点，t[x].w为其子节点的最小值，然后就是线段树了。。

```cpp

#include<iostream>
#include<cstdlib>
#include<math.h>
#include<stdio.h>
#include<algorithm>
#include<cstring>
using namespace std;
struct tree
{
    int l,r,w;
}t[2000001];
int n,m;
void init(int x,int l,int r)
{
    if(l==r)
    {
      t[x].l=l;
      t[x].r=r;
      t[x].w=0x3f3f3f3f;
      return;
    }
    t[x].l=l;
    t[x].r=r;
    t[x].w=0x3f3f3f3f;
    int mid=(l+r)>>1;
    init(x*2,l,mid);
    init(x*2|1,mid+1,r);
}
int add(int x,int l,int r,int s,int a)
{
    if(l==r&&l==s)
    {
      t[x].w=a;
      return a;
    }
    if(l==r)
      return t[x].w;
    int mid=(l+r)>>1;
    if(mid+1<=s)
      add(x*2|1,mid+1,r,s,a);
    else add(x*2,l,mid,s,a);
    t[x].w=min(t[x*2].w,t[x*2|1].w);
    return t[x].w;
}
int mi=0x3f3f3f3f;
void ask(int x,int l,int r,int a,int b)
{
    if(l>=a&&r<=b)
    {
      mi=min(t[x].w,mi);
      return;
    }
    if(l==r)
      return;
    int mid=(l+r)>>1;
    if(mid>=a)
    ask(x*2,l,mid,a,b);
    if(mid+1<=b)
    ask(x*2|1,mid+1,r,a,b);
    return;
}
int main()
{
    scanf("%d%d",&n,&m);
    init(1,1,n);    
    int i;
    for(i=1;i<=n;i++)
    {
      int j;
      scanf("%d",&j);
      add(1,1,n,i,j);
    }
    int j;
    for(i=1;i<=m;i++)
    {
      int a,b;
      scanf("%d%d",&a,&b);
      ask(1,1,n,a,b);
      printf("%d ",mi);
      mi=0x3f3f3f3f;
    }
    return 0;
}

```

---

## 作者：usqwedf (赞：1)

对于不会RMQ的我来说。。。


以下三种也是可以过的说。。


快速排序是个好办法 >\_<

排序时记录编号 查询时穷举可过。。

这个复杂度比较难估计 我会说最差是O(nm)的么。。 不过对于平均数据实测是不错的。


树状数组也是个好伙伴呢。。

嗯。。维护一下也可以的。。。O(nlogn)吧。。。


分块[喵呜~]也可以。。 只是复杂度略nlogn等方法高。。

O(√nm)也挺理想的呀。。


当然您可以乱搞。。。


[呜咕~] [思考熊]


---

## 作者：我珂真尽梨了 (赞：1)

发个题解，按照汝佳巨神的板子写的，不会**倍增/RMQ**的可以看一下。

方程~~不~~难得到：

令d[i][j]为以i开始的**2^j**为长度的数中的最小值//想想为什么

那么我们就可以将[i,2^j]这个区间分成两个部分：
**[i,i+2^(j-1)-1],[i+2^(j-1),j]**   //其实有倍增的思想

所以可以得到方程——
**d(i,j)=min{d(i,j-1),d(i+2^(j-1),j-1)}**

注意的是，**j-1表示的是区间的长度为2^(j-1)**

然后预处理一下d数组就可以OVER啦；

时间复杂度——初始化O(nlogn)；查询O(1);

代码在下面~~qwq~~

```cpp
#include<cstdio>
#include<algorithm>
#define N 100005
using namespace std;
int n,T,l,r;
int a[N],d[N][20];
void RMQ_init(){
	for(int i=0;i<n;i++)d[i][0]=a[i];
	for(int j=1;(1<<j)<=n;j++)
		for(int i=0;i+(1<<j)-1<n;i++)
			d[i][j]=min(d[i][j-1],d[i+(1<<(j-1))][j-1]);
}
int RMQ(int l,int r){
	int k=0;
	while((1<<(k+1))<=r-l+1)k++;
	return min(d[l][k],d[r-(1<<k)+1][k]);
}
int main(){
	scanf("%d%d",&n,&T);
	for(int i=0;i<n;i++)scanf("%d",&a[i]);
	RMQ_init();
	while(T--){
		scanf("%d%d",&l,&r);
		l--;r--;
		printf("%d",RMQ(l,r));
		if(T)printf(" ");
	}
	return 0;
}
```
发这个方法的也不是一个人了，我主要想发一下的是**lrj**写的（我除了用的是数组没有用vector基本上跟他写的是一样的）

---

## 作者：huyufeifei (赞：1)

翻了一下题解，发现主要有这几种做法：
+ ST表
+ 线段树
+ 树状数组
+ 分块
+ 离线
+ 瞎搞

提供一种与众不同的~~(十分奇葩的)~~思路：Splay。
众所周知，Splay能够维护区间最值，那么这道题一看就是Splay裸题了。于是我们就兴高采烈地打了一发Splay交上去，A了。

发现代码也不是很长，才160行(跟P3379相比)。

上代码。
```cpp
#include <cstdio>
#include <algorithm>

const int N = 1000010, INF = 0x7f7f7f7f;

inline void Read(int &x) { /// 快读
    x = 0;
    char c = getchar();
    while(c < '0' || c > '9') {
        c = getchar();
    }
    while(c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    return;
}

struct SplayTree {
    int fa[N], s[N][2], siz[N];
    int val[N], small[N];
    int tot, root;

    SplayTree() { /// 初始化
        root = 1;
        tot = 2;

        val[1] = val[2] = INF;
        fa[2] = 1;
        s[1][1] = 2;
        siz[1] = 2;
        siz[2] = 1;
        small[1] = small[2] = INF;
    }

    inline void pushup(int p) { /// 更新
        int ls = s[p][0];
        int rs = s[p][1];
        siz[p] = siz[ls] + siz[rs] + 1;
        small[p] = val[p];
        if(ls) {
            small[p] = std::min(small[p], small[ls]);
        }
        if(rs) {
            small[p] = std::min(small[p], small[rs]);
        }
        return;
    }

    int build(int l, int r, int f) { /// 建树
        int mid = (l + r) >> 1;
        int p = ++tot;

        if(l < mid) {
            s[p][0] = build(l, mid - 1, p);
        }
        Read(val[p]);
        fa[p] = f;
        if(mid < r) {
            s[p][1] = build(mid + 1, r, p);
        }

        pushup(p);
        return p;
    }

    inline void rotate(int x) { /// 旋转
        int y = fa[x];
        int z = fa[y];
        bool f = (s[y][1] == x);

        if(z) {
            s[z][s[z][1] == y] = x;
        }
        fa[x] = z;
        s[y][f] = s[x][!f];
        fa[s[x][!f]] = y;
        fa[y] = x;
        s[x][!f] = y;

        pushup(y);
        pushup(x);
        if(!z) {
            root = x;
        }
        return;
    }

    inline void splay(int x, int g) {
        int y = fa[x];
        int z = fa[y];
        while(y != g){
            if(z != g) {
                (s[z][1] == y) ^ (s[y][1] == x)
                ? rotate(x) : rotate(y); /// 双旋
            }
            rotate(x);
            y = fa[x]; 
            z = fa[y];
        }
        return;
    }

    inline int getNbyR(int x) { /// 查找第x个
        int p = root, t;
        while(1) {
            t = siz[s[p][0]];
            if(t + 1 == x) {
                break;
            }
            if(t + 1 > x){
                p = s[p][0];
            }
            else if(t + 1 < x) {
                x -= (t + 1);
                p = s[p][1];
            }
        }
        return p;
    }

    inline int get(int l, int r) { /// 提取区间[l, r]
        r += 2;
        int p = getNbyR(l);
        splay(p, 0);
        p = getNbyR(r);
        splay(p, root);
        return s[p][0];
    }

    inline int getmin(int l, int r) { /// 查找最小值
        int p = get(l, r);
        return small[p];
    }

    void out(int p) { /// 输出序列
        if(s[p][0]) {
            out(s[p][0]);
        }
        printf("%d ", val[p]);
        if(s[p][1]) {
            out(s[p][1]);
        }
        return;
    }
}spt;

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    spt.s[2][0] = spt.build(1, n, 2); /// 建树
    spt.pushup(2);
    spt.pushup(1);
    for(int i = 1, x, y; i <= m; i++) {
        scanf("%d%d", &x, &y);
        printf("%d ", spt.getmin(x, y));
    }
    return 0;
}

```

---

## 作者：huang_yue (赞：1)

这一题可以用不带修改的线段树解决。线段树的根节点储存的是区间[1: n]的最小值，而一个储存[p: q]节点的左右孩子储存的分别是[p: (p+q)/2], [(p+q)/2+1, q]的最小值。

在查询的时候，只需要把区间[_b: _e]分解成一些在线段树里的区间，再取最小值就行了。比如对于样例的第一个询问[2: 7]，可以分解成[2: 2], [3: 3], [4: 5]以及[6: 7]。（可以画一下图模拟一下）

来发一下自认为比较短的线段树代码：
```
#include<iostream>
#define l(x) ((x) << 1) //左儿子
#define r(x) (l(x) | 1) //右儿子
using namespace std;

int s[400010], arr[100010]; //s[i]: 线段树的节点i对应的区间的最小值

int build(int c, int b, int e) { //[b: e]是节点c所对应的区间
	if (b == e) return s[c] = arr[b]; //arr里是原始数据
	int m = ((b + e) >> 1); //运用线段树的定义建树
	return s[c] = min(build(l(c), b, m), build(r(c), m + 1, e));
}

int _(int c, int _b, int _e, int b, int e) { //查找函数，[b: e]是节点c所对应的区间， [_b: _e]是要查询的区间
	if (_e < b || e < _b) return -1; //两区间未相交
	if (_b <= b && e <= _e) return s[c]; //当前区间在查询区间之内
	int m = ((b + e) >> 1); //把当前区间分割成更小的区间
	int p = _(l(c), _b, _e, b, m), q = _(r(c), _b, _e, m + 1, e);
	return ~p ? ~q ? min(p, q) : p : q;
    /*相当于
    if(p!=-1)
    	if(q!=-1) return min(p, q);
        else return p;
    else return q;*/
}

int main() {
	int n, m; cin >> n >> m;
	for (int i = 1; i <= n; ++i) cin >> arr[i];
	build(1, 1, n); //建树
	for (int i = 0; i < m; ++i) {
		int f, t; cin >> f >> t;
		cout << _(1, f, t, 1, n) << ' '; //查找
	}
	return 0;
}
```

---

## 作者：Fuko_Ibuki (赞：1)

这个题是静态区间最小值,按照道理来说应该用果的rmq来做.然而我研究了半年都不会写rmq,(我太菜了不会倍增)反而是不修改的线段树更好写一些.
```
#include<bits/stdc++.h>
#define ls rt<<1,l,mid//lson和rson在以后经常用到,所以define一下.
#define rs rt<<1|1,mid+1,r//左半部分,右半部分
using namespace std;
const int boss=1e5,inf=0x3f3f3f3f;
int n,m,a[boss|15],seg[boss<<2|15];//线段树的数组要开4倍大小.

void build(int rt,int l,int r)//建树
{
if (l==r) seg[rt]=a[l];
else 
  {
  int mid=l+r>>1;
  build(ls),build(rs);//建立左儿子和右儿子
  seg[rt]=min(seg[rt<<1],seg[rt<<1|1]);//这个区间的最小值取左半部分和右半部分的最小值.
  }
}

int query(int ql,int qr,int rt,int l,int r)//前两个数是询问的区间,后两个是目前覆盖到的区间
{
if (l>qr||r<ql) return inf;//覆盖的区间不在询问范围内,要找一个不会影响答案的数返回,比如说inf
if (l>=ql&&r<=qr) return seg[rt];//覆盖的区间完全包含在询问范围内,显然要返回root上的值
int mid=l+r>>1;
return min(query(ql,qr,ls),query(ql,qr,rs));//其他情况当然就是返回左半部分和右半部分的最小值了.
}

int main()
{
int i;
scanf("%d%d",&n,&m);
for (i=1;i<=n;++i) scanf("%d",&a[i]);
build(1,1,n);
for (;m--;)
  {
  int l,r;
  scanf("%d%d",&l,&r);
  printf("%d ",query(l,r,1,1,n));
  }
}
```

---

## 作者：EternalAlexander (赞：1)

提供一种分块解法。
把数列分为大小为sqrt(n)的块，分别计算出每个块内的最小值。
然后查询时首先扫一遍范围内的整块，直接就能得出最小值。
然后对于不在一个整块儿内的，使用暴力的方法扫一遍。

分块同样是支持修改操作的，单点修改时，将修改点的数值改动同时更新所属块的值就行了。

时间复杂度为n*sqrt(n)。虽然没有线段树的n*log(n)以及ST表快，但是对于一般的题目分块的编程复杂度会小一些，并且更不容易写错、更好调试。

```C++
```
#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;

int n, m;
int A[200001];
int size;
int bmin[500];
void init();
void update(int x, int v);
int query(int left, int right);
int read();
int main()
{
	char c; int a, b;
	scanf("%d %d", &n, &m);
	for (int i =0; i < n; ++i) A[i]=read();
	size=(int)sqrt(n); init(); 
	for (int i = 0; i < m; ++i) {
		a=read(); b=read();
		printf("%d ", query(a-1, b-1));
	}
	return 0;
}
int query(int left, int right) {
	int ret = 2147483647;
	int lstop=(left-1)/size; int rstop=(right+1)/size;
	for (int i = lstop+1; i < rstop; ++i) {ret=min(ret, bmin[i]);}
	for (int i = left; i < (lstop+1)*size&&i<=right; ++i) {ret=min(ret, A[i]);}
	for (int i = max((rstop-1)*size+1, left); i<=right; ++i) {ret=min(ret, A[i]);}
	return ret;
} void init() {
	for (int i = 0; i <= size; ++i) bmin[i]=2147483647;
	int belong;
	for (int i = 0; i < n; ++i) {
		belong = i/size;
		bmin[belong]=min(bmin[belong], A[i]);
	}
} int read() {
	  int x = 0, f = 1;
  char ch = getchar();
  while (ch < '0' || ch > '9') {
    if (ch == '-')
      f = -1;
    ch = getchar();
  }
  while (ch >= '0' && ch <= '9') {
    x = x * 10 + ch - '0';
    ch = getchar();
  }
  return x * f;
}

	
	
```

---

## 作者：EarthGiao (赞：0)

## 【思路】
ST表 + 倍增 + RMQ区间最值    

### 【题目大意】
求区间最小值     

### 【题目分析】
区间最小值    
看到这里一定会情不自禁想到可以用ST表来做这种区间最值得题目    

### 【核心思路】
读入数据    
然后预处理出ST表里面对应的区间最值是多少      
最后输入需要查询的区间      
然后输出区间最小值就好了     

### 【注意】
做这种区间最值题目的时候   
一定要考虑好区间的范围    
不要到时候求a到b区间范围内数最值   
因为处理不当导致求到了a到b范围外面   
就会出现很大的问题   

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int read()
{
	int sum = 0,fg = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')fg = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		sum = sum * 10 + c - '0';
		c = getchar();
	}
	return sum * fg;
}
const int Max = 100005;
int f[Max][22];
int LG[Max]; 

int main()
{
	int m = read(),n = read();
	for(register int i = 1;i <= m;++ i)
		f[i][0] = read();
	for(register int j = 1;(1 << j) <= m;++ j)
		for(register int i = 1;i + (1 << j) - 1 <= m;++ i)
			f[i][j] = min(f[i][j - 1],f[i + (1 << (j - 1))][j - 1]);
	for(register int i = 1;(1 << i) <= m;++ i)
		LG[(1 << i)] = i;
	for(register int i = 1;i <= m;++ i)
		if(LG[i] == 0)
			LG[i] = LG[i - 1];
	for(register int i = 1;i <= n;++ i)
	{
		int a = read(),b = read();
		int k = LG[b - a + 1];
		cout << min(f[a][k],f[b - (1 << k) + 1][k]) << " ";
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

基本情况：l==r时，tree[p]=a[l];

合并：tree[p]=max(tree[p+p],tree[p+p+1]);

2.区间取最小值

原问题：[l..r]的树的根结点为p，找[x..y]中的最小值

子问题1：[l..Mid]的树的根结点为p+p，找[x..y]中的最小值

子问题2：[Mid+1..r]的树的根结点为p+p+1,找[x..y]中的最小值

子问题3：[l..Mid]的树的根结点为p+p,找[x..Mid]中的最小值

子问题4：[Mid+1..r]的树的根结点为p+p+1,找[Mid+1..y]中的最小值

基本情况：l==x&&r==y时，rturn tree[p];

合并：y<=Mid时，return 子问题1；x>Mid时，return 子问题2

否则 return max(子问题3,子问题4)```

```cpp
include <bits/stdc++.h> //万能头文件
define Maxn 100000
using namespace std;

int n,m,a[Maxn+5],tree[Maxn*4+5],answer[Maxn+5];

void Build(int p,int l,int r) //建树

{

if(l==r)

{

tree[p]=a[l];

return;
}

int Mid=(l+r)/2; //有兴趣的可以去证明一下

Build(p+p,l,Mid); //"+"比"*"快，所以我用"+"。不过你用什么，我才不管呢(滑稽)

Build(p+p+1,Mid+1,r);

tree[p]=max(tree[p+p],tree[p+p+1]); //合并

}

int getmin（int p,int l,int r,int x,int y) //求区间最小

{

if(l==x&&r==y)

{

return tree[p];
}

int Mid=(l+r)/2;

if(y<=Mid) //如果都在[l...Mid]区间里的话...

return getmax(p+p,l,Mid,x,y);
else if(x>Mid) //如果都在[Mid+1,r]区间里的话...

return getmax(p+p+1,Mid+1,r,x,y);
else //如果不都在[l...Mid]区间里，也不都在[Mid+1,r]区间里的话...

return max(getmax(p+p,l,Mid,x,Mid),getmax(p+p+1,Mid+1,r,Mid+1,y));
}

int main()

{

cin>>n>>m; //输入

for(int i=1;i<=n;i++)

cin>>a[i];
Build(1,1,n); //建树

for(int i=1;i<=m;i++)

{

int x,y;

cin>>x>>y;

answer[i]=getmax(1,1,n,x,y);
}

for(int i=1;i<m;i++)

{

cout<<answer[i]<<" ";
}

cout<<answer[m]<<endl;

return 0;

}
```

[必看](https://www.luogu.org/space/show?uid=221030)

---

## 作者：Starlight_Glimmer (赞：0)

RMQ裸题

可以用st表做

复杂度$O(n+nlogn)$，询问$O(1)$

**st表的思想其实也就是dp和倍增**

st表的应用好像不怎么广泛 除了单纯的RMQ和LCA会用到之外好像没啥用处 而且不支持修改~~没有线段树强~~ 
但是它比线段树短多了 更好打


设$f(i,j)$表示$[i,i+2^j-1]$的最小值

$[i,i]$的最小值就是$a[i]$,所以$f(i,0)=a[i]$

转移的时候将$[i,i+2^j-1]$平均分成两部分：

$[i,i+2^{j-1}-1]$和$[i+2^{j-1},i+2^j-1]$
$[i,i+2^j-1]$的最小值是$[i,i+2^{j-1}-1]$和$[i+2^{j-1},i+2^j-1]$中的最小值的最小值

即$f(i,j)=min(f(i,j-1),f(i+2^{j-1},j-1))$

查询的时候 因为查询的区间$[l,r]$的长度不一定就是2的整数次幂，所以我们就取区间长度的log值 **（要下取整，不能上取整，否则会涉及到其他区间的数，可能会影响答案）** 。由于不一定会覆盖到整个区间，我们把它劈成两部分，一部分以l为起点，另一部分以r为终点。由于是求最值，所以区间的重叠并没有什么影响。

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
#define MAXN 100005
int n,m;
int dp[MAXN*2][20];//st表
void RMQ(int k)
{
	for(int j=1;(1<<j)/*2^j*/<=k;j++)
		for(int i=1;i+(1<<j)-1<=k;i++)
		{
			int a=dp[i][j-1],b=dp[i+(1<<(j-1))][j-1];
			dp[i][j]=min(a,b);
		}
}

//询问最小值 
int Query(int l,int r)
{
	int k=0;
	while(1<<(k+1)<=r-l+1)
		k++;
	int a=dp[l][k],b=dp[r-(1<<k)+1][k];
	return min(a,b);
}
int main()
{
	scanf("%d %d",&m,&n);
	for(int i=1;i<=m;i++)
		scanf("%d",&dp[i][0]);
	RMQ(m);	
	while(n--)
	{
		int l,r;
		scanf("%d %d",&l,&r);
		printf("%d ",Query(l,r));
	}
	return 0;
}


```

最后当然是一波广告 博客链接:[Blog](https://blog.csdn.net/CQBZLYTina/article/details/88551297)


---

## 作者：Celebrate (赞：0)

# 难道就没有人发rmq的题解吗？？？

那么我来发一篇吧！

详见博客：

[我的博客](https://blog.csdn.net/zsyzClb/article/details/84330028)


题解：

闭区间多次求最值（rmq）

时间O(nlogn+m)

如果查询次数多起来，应该比线段树的O(mlogn)要快一些吧

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<queue>
#include<stack>
#include<cmath>
#include<map>
using namespace std;
inline int read(){
    int x=0,f=0;char s=getchar();
    while(!isdigit(s))f|=s=='-',s=getchar();
    while( isdigit(s))x=(x<<1)+(x<<3)+s-48,s=getchar();
    return !f?x:-x;
}
const int N=1e6+10;
const int logn=20;
int n,k;
int Log[N],st[N][logn+5],a[N];
int main(){
	int x,y,t;
	n=read();k=read();
	for(int i=1;i<=n;i++)a[i]=read();
	Log[0]=-1;//log[i]的意义：2^log[i]<=i && 2^(log[i]+1)>i 
	memset(st,63,sizeof(st));//初始化无穷大 
	for(int i=1;i<=n;i++)st[i][0]=a[i],Log[i]=Log[i>>1]+1;//初始化log和st[i][0] 
	for(int j=1;j<=logn;j++)//nlogn预处理出每一项st 
		for(int i=1;i+(1<<j)-1<=n;i++)
			st[i][j]=min(st[i][j-1],st[i+(1<<j-1)][j-1]);
	while(k--){//查询 
		x=read(),y=read();
		t=Log[y-x+1];
		printf("%d ",min(st[x][t],st[y-(1<<t)+1][t]));
	}
	return 0;
}

```

---

## 作者：彼岸朱砂 (赞：0)

倍增，顾名思义就是一倍一倍的增加。举个例子你每次可以跳2的k次方步。现在你要跳到距离7步的地方。

跳8步 跳过了（不跳）

跳4步 没跳到（跳）

跳2步 没跳到 （跳）

跳1步 跳到 （停）

这里就只跳了3次 比普通的7次跳发优化了4次；

如果数据很大就是O(n) 和 O(logn)的区别了；

这里主要讲RMQ和LCA的2种简单算法

RMQ（区间最值查询）是一个预处理O（n*logn）区间极值O(1)查询任意区间极值的工具

主要思想就是区间dp出每个点起2的k次方的长度内的极值。运用大区间的极值由小区间得到，同时大区间的答案可以由小区间随意组合得到。比如我们已经预处理1为起点长度为4的答案，和2为起点向后4的答案，我们查询区间1到5的极值就可以比较1-4区间和2-5区间的答案来得到1-5的答案；

预处理的代码如下

f数组的意思是以i为起点2的j次方长度的区间的极值是多少

```
void ST(int n)///预处理
{    
	 for(int i=1;i<=n;i++)        
	 f[i][0]=a[i];///初始化以自己为起点2的0次方长的区间就是自己    
     for(int j=1;(1<<j)<=n;j++)///枚举区间长度    
     {        
       for(int i=1;i+(1<<j)-1<=n;i++)///枚举起点 
       {
          f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);    
       }
     }
}

```

模拟一下: 我们要得到f[1][1]就可以通过f[1][0]和f[2][0]得到 f[1][2]可以由f[1][1]和f[3][1]得到。由于我们是小区间得到大区间，所以比如求区间大小为8的时候，我们已经处理了所以4大小的区间了

查询极值如下

```
int RMQ(int l,int r)
{
       int k=trunc(log2( r-l+1 ));///向下取整
       printf("k=%d\n",k);
       return max(  f[l][k],  f[r-(1<<k)+1][k]   );
}

```

代码处的k是找2个小一点的区间可以覆盖玩需要查询的区间，比如查找5长度的区间，我们就找2个长度为4的区间完全覆盖查询的区间。为什么能这样，举个例子1 2 4可以任意组合出1-7之内的所有数，正是这个性质才使得这个算法可以存在。


-----------------------------------

------------


LCA（最近公共祖先）也可以认为在树上找最短路，因为找到了最近公共祖先也就等于找到了最短路，维护一个dis[]数组表示所有节点到根节点的距离，u到v的最短距离就是dis[u]+dis[v]-2dis[LCA(u,v)]；

这个算法利用的是思想是找到u和v第一个不同祖先不同的位置，然后这个位置向上走一步就是最近公共的祖先。

但是u和v不在同一个深度肯定不行，所有需要dfs求去所有节点的深度

需要注意的是根据不同情况DFS是必须找到这个树的根节点，从根节点开始搜索

怎么找到根节点就开自己开标记数组处理啦！


```
void DFS(int u)
{
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(vis[v]==0)
        {
            vis[v]=1;///标记
            deep[v]=deep[u]+1;
            DFS(v);
          
        }
    }
}

```

然后要做的就是倍增预处理每个节点上面2的k次方个祖先节点是什么

```
void ST(int n)///倍增预处理i 节点上面1<<j步的节点
{
    for(int j=1;(1<<j)<=n;j++)
        for(int i=1;i<=n;i++)
          f[i] [j] = f[f[i][j-1]][j-1];
}

```

需要注意的是输入边的时候就把f[i][0]初始化好，f[i][0]表示i节点上面2的0次方的祖先是什么，输入的时候很容易就初始化好了。

举个例子

![](https://img-blog.csdn.net/20180818111710254?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pa2VKYWNrU1RH/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

f[1][0]=0表示没有祖先，这个1节点就是根
f[2][0]=1表示2号节点祖先是1
以此内推f[4][0]=2  f[5][0]=2  f[3][0]=1
处理f[4][1]的时候就可以通过  f[ f[4][0]] [ 0 ]得到
f[4][0]=2 所以 f[4][1]=f[2][0]就意味着  i的上面2个节点可以通过i的上面1个节点的再跳1个节点得到 同理4个节点可以跳2次2个节点得到.

做完准备工作后就可以很高效的查询任意2个点的公共祖先了

```
int LCA(int u,int v)
{
    if(deep[u]<deep[v])///默认u的深度大一点简化后面的问题
        swap(u,v);
    int h=deep[u]-deep[v];///求出高度差
    for(int i=0;i<20;i++)///这个操作可以将u节点向上提升任意高度，觉得难懂就需要自己模拟一下过程
    {
        if(  h&(1<<i) )///二级制位上存在1就提升 1<<i步
          {
               u=f[u][i];
          }
    }
    if(u==v)///如果u==v表示 u就是v下面的分支节点
        return u;
    for(int i=19;i>=0;i--)///找到第一个不相同的节点
    {
        if( f[u][i]!=f[v][i] )///还是利用了 1 2 4 可以任意组合出1-7所有的步数
        {
            u=f[u][i];
            v=f[v][i];
        }
    }
    return f[u][0];///第一个不相同的节点的上一个就是最近公共祖先
}

```

[ P1816 忠诚](https://www.luogu.org/problemnew/show/P1816)
---------------------

```
//void ST(int n)///预处理
//{
//    for(int i=1;i<=n;i++)
//        f[i][0]=a[i];///初始化以自己为起点2的0次方长的区间就是自己
//    for(int j=1;(1<<j)<=n;j++)///枚举区间长度
//    {
//        for(int i=1;i+(1<<j)-1<=n;i++)///枚举起点  1<<j:1的j次方 
//        f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
//    }
//}

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

const int N=1e5+10;
int a[N][20];
int m,n,x,y,k;

void RMQ()
{
	for(int j=1;1<<j<=m;j++)
    {
    	for(int i=1;i+(1<<j)-1<=m;i++)
    	{
    		a[i][j]=min(a[i][j-1],a[i+(1<<(j-1))][j-1]); 
    	}   
    }
}
int RMQask(int l,int r)
{
	k=log2(r-l+1);
    return min(a[l][k],a[r-(1<<k)+1][k]);
}
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i][0];//每个数的最小值就是他自己  
	}	
	RMQ();//预处理 
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y;
		cout<<RMQask(x,y)<<" ";//查询区间最值 
	}
	return 0;
}
```



------------

本文来自 MikeJackSTG 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/MikeJackSTG/article/details/81806120?utm_source=copy 

---

## 作者：ume酱 (赞：0)

**p1816模版题RMQ做法**

**预处理部分**

A数列为：3 2 4 5 6 8 1 2 9 7,dp[1,0]表示第1个数起,长度为2^0=1的最大值,其实就是3这个数。同理 F[1,1] = max(3,2) = 3, dp[1,2]=max(3,2,4,5) = 5，dp[1,3] = max(3,2,4,5,6,8,1,2) = 8;

**状态转移部分**

我们把dp[i，j]平均分成两段（因为dp[i，j]一定是偶数个数字），从 i 到i + 2 ^ (j - 1) - 1为一段，i + 2 ^ (j - 1)到i + 2 ^ j - 1为一段(长度都为2 ^ (j - 1))。于是我们得到了状态转移方程F[i, j]=max（F[i，j-1], F[i + 2^(j-1)，j-1]）。

```cpp
void st(int n) 
{
    for(int i=1;i<=n;i++)
        dp[i][0]=a[i];//设a[i]是要求区间最值的数列，dp[i, j]表示从第i个数起连续2^j个数中的最大值，所以dp[i,0]就等于a[i]
    for (int j=1;(1<<j)<=n;j++) 
	{
        for(int i=1;i+(1<<j)-1<=n;i++)
		{
            dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
        }
    }
}

```


**查询**

假如我们需要查询的区间为(i,j)，那么我们需要找到覆盖这个闭区间(左边界取i，右边界取j)的最小幂（可以重复，比如查询1，2，3，4，5，我们可以查询1234和2345）。因为这个区间的长度为j - i + 1,所以我们可以取k=log2( j - i + 1)，则有：RMQ(i, j)=max{F[i , k], F[ j - 2 ^ k + 1, k]}。举例说明，要求区间[1，5]的最大值，k = log2（5 - 1 + 1）= 2，即求max(F[1, 2]，F[5 - 2 ^ 2 + 1, 2])=max(F[1, 2]，F[2, 2])；

```cpp
int rmq(int l,int r)
{
	int k = 0;
    while ((1 << (k + 1)) <= r - l + 1) k++;
    return min(dp[l][k], dp[r - (1 << k) + 1][k]);
}
```
完整代码
```cpp
#include <iostream>
using namespace std;
int a[100100];
int dp[100100][55];
int rmq(int l,int r)
{
	int k = 0;
    while ((1 << (k + 1)) <= r - l + 1) k++;
    return min(dp[l][k], dp[r - (1 << k) + 1][k]);
}
void st(int n) 
{
    for(int i=1;i<=n;i++)
        dp[i][0]=a[i];
    for (int j=1;(1<<j)<=n;j++) 
	{
        for(int i=1;i+(1<<j)-1<=n;i++)
		{
            dp[i][j]=min(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
        }
    }
}
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	st(n);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		cout<<rmq(x,y)<<" ";
	}
	return 0;
}
```
（感谢大佬丿残念灬博客 **orz**）

---

## 作者：嚯呀嚯呀 (赞：0)

都没有P党的题解呢

表示RMQ写不来

写了一个没有修改功能的线段树嘿嘿

L,R数组是写这个点的管理范围，LC,RC是这个点左右孩子是几。KEY就是关键字，这题目是求最小值

下面亮代码咯

```cpp
var
  len:longint;
  q,i,j,m,n,k,p:longint;
  a,l,r,lc,rc,key:array[0..200005]of longint;
function min(x,y:longint):longint;
begin
  if x<y then exit(x)
  else exit(y);
end;
procedure built(x,y:longint);
var
  mid,now:longint;
begin
  inc(len); now:=len;
  l[now]:=x; r[now]:=y;
  lc[now]:=-1; rc[now]:=-1;//一开始认为没有左右孩子呢
  if x=y then key[now]:=a[x]
  else
    begin
      mid:=(x+y) div 2;//二分这个点管的范围
      lc[now]:=len+1; built(x,mid);
      rc[now]:=len+1; built(mid+1,y);
      key[now]:=min(key[lc[now]],key[rc[now]]);
    end;
end;
function findmin(now,x,y:longint):longint;
var
  mid,a1,a2:longint;
begin
  if (l[now]=x)and(r[now]=y) then findmin:=key[now]
  else
    begin
      a1:=lc[now]; a2:=rc[now];
      mid:=(l[now]+r[now]) div 2;
      if y<=mid then findmin:=findmin(a1,x,y) //如果要求的区间完全在左孩子管的范围内
      else if mid<x then findmin:=findmin(a2,x,y) //如果要求的区间完全在右孩子管的范围内
      else
        findmin:=min(findmin(a1,x,mid),findmin(a2,mid+1,y));//两边都有就分开
    end;
end;
begin
  readln(n,q);
  for i:=1 to n do
    read(a[i]);
  readln;
  len:=0; built(1,n);//这个就是建树啦
  for i:=1 to q do
    begin
      readln(k,p);
      write(findmin(1,k,p),' ');//查找区间
    end;
end.
```

---

## 作者：AFOier (赞：0)

Luogu P1816 解题报告

By huangxuanao

[分析]

这道题其实是一道很简单的线段树模版，比线段树模版1还简单了不少，出题人真有良心……好吧，现在来分析一下题目。我们可以把这道题简化一下，具体如下：

输入m个数，然后问你n个问题，请输出每次输入的x到y之间最小的数。(1<=n,m<=100000)

数据很小，但用暴力就别想了，正解当然是线段树啦。

作为一题线段树模板题，我觉得有必要讲一下线段树（会线段树的自行跳过）

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。

使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。

是不是很高级，这当然不是我写的，是百度写的。好吧，看看下面的图片。

 
最上面的[1,10]里存的是区间1-10里面最小的那个数，[1,5]存的是区间1-5里面最小的那个数，[6,10]存的是区间6-10里面最小的那个数，依此类推……

首先，我们要做的是建树。因为某种原因，我们在更改某个节点的数字时，也要更改它的父节点——即它的上一层节点。嗯，听懂了吗，大概吧，再模（mo）拟（ha）一下吧。

假设原来[1,1]的值是100000(空的，初始值)，我们现在要把它改成6，那么我们应该把[1,1]、[1,2]、[1,3]、[1,5]、[1、10]都和6比较一下，看6有没有比这些节点的值小，如果有就替换。具体的建树我用的是二叉堆，不懂的还是度娘比较清楚。

建树完毕，我们开始寻找。如果要寻找的区间全部在左儿子中，那么就找左儿子，区间不变。如果要寻找的区间全部在右儿子中，那么就找右儿子，区间一样不变。需要注意的是如果要寻找的区间在左儿子和右儿子都有分布，那么就应该两个都找，区间变为l~mid以及mid+1~r。线段树的介绍完毕，还不会的就去度娘吧。

会线段树的到此跳过结束。

[代码]

因为之前我AC了 P1531【I hate it】，于是我就直接把那份代码拿来改了一下，就贴上来了（实际上我不建议这么做）。为了代码更易懂，我把代码分成了几个部分。

```cpp
#include <iostream> 
using namespace std;
int n,m,a[1000001],x;//定义变量
int change(int k,int l,int r,int w,int s)
{
    if(l==r){a[k]=s;return 0;}//如果已经到达了指定节点，停下，更新数据
    int mid=(l+r)/2;//算出mid
    if(w<=mid)change(k*2,l,mid,w,s);
    else change(k*2+1,mid+1,r,w,s);//更新子节点
    a[k]=min(a[k*2],a[k*2+1]);//更新子节点后更新本身
```
}//这一部分是建树
```cpp
int ques(int k,int l,int r,int l1,int r1)
{
    if(l1<=l&&r1>=r)return a[k];
    int mid=(l+r)/2,ans=1000000;
    if(l1<=mid)ans=min(ans,ques(k*2,l,mid,l1,r1));
    if(r1>mid)ans=min(ans,ques(k*2+1,mid+1,r,l1,r1));
    return ans;
```
}//这一部分是查询(线段树的常见模版)
```cpp
int main()
{
    cin>>n>>m;//我还是习惯先n再m
    for(int i=1;i<=n;i++)
    {
        cin>>x;
        change(1,1,n,i,x);
```
}//建树
```cpp
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        cout<<ques(1,1,n,x,y)<<" ";
```
}//输出每个询问的答案
}//主程序(续)


---

## 作者：重回巅峰！ (赞：0)

线段树是个神奇的东西。。。。。。。

线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。


使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)。而未优化的空间复杂度为2N，因此有时需要离散化让空间压缩。

但是很明显，这题不用优化也不要离散化。


PS:对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树，最后的子节点数目为N，即整个线段区间的长度。

var
node:array[0..400000]of record

```cpp
                            left,right,value:longint;
                          end;
  a,ans:array[0..400000]of longint;
  n,m,i,j,L,R:longint;
function min(a,b:longint):longint;
begin
  if a>b then exit(b) else exit(a);
end;
procedure build(u,left,right:longint);
var mid:longint;
begin
  node[u].left:=left; node[u].right:=right;
  if left=right then
  begin
    node[u].value:=a[left];
    exit;
  end;
  mid:=(left+right) div 2;
  build(u*2,left,mid);
  build(u*2+1,mid+1,right);
  node[u].value:=min(node[u*2].value,node[u*2+1].value);
end;
function query(u,left,right:Longint):longint;
begin
  if (node[u].left>right)or(node[u].right<left) then exit(maxlongint);
  if (node[u].left>=left)and(node[u].right<=right) then exit(node[u].value);
  exit(min(query(u*2,left,right),query(u*2+1,left,right)));
end;
begin
  fillchar(a,sizeof(a),$7f div 3);
  readln(m,n);
  for i:=1 to m do read(a[i]);
  build(1,1,m);
  for i:=1 to n do
  begin
    read(L,R);
    ans[i]:=query(1,L,R);
  end;
  for i:=1 to n do write(ans[i],' ');
end.

```

---

## 作者：never_see (赞：0)

用zkw线段树估计是要快一些的

但是网上大部分这种求区间最值的zkw线段树的打法都有些问题

搞得本蒟蒻几乎想放弃zkw

还好还是找到了zkw线段树做区间极值的正确方法


```cpp
#include<cstdio>
#include<climits>
#include<algorithm>
using namespace std;

const int MAXN = 100001*4;

int n,m,M,Read,u,v;
int d[MAXN];

void Change(int x,int k){
    for(d[x+=M]=k,x>>=1;x;x>>=1)
        d[x]=min(d[x<<1],d[x<<1|1]);//插入每一个权值的时候要如此维护
}

int Query(int s,int t){
    int Ans=INT_MAX;
    for(s+=M-1,t+=M+1;s^t^1;s>>=1,t>>=1){
        if(~s&1) Ans=min(Ans,d[s^1]);//如果s是左儿子，那么其兄弟节点一定是在查询区间内
        if( t&1) Ans=min(Ans,d[t^1]);//如果t是右儿子，那么其兄弟节点一定是在查询区间内
    }
    return Ans;
}

int main(){
    scanf("%d%d",&n,&m);
    for(M=1;M<n+2;M<<=1);
    for(int i=1;i<=n;i++) scanf("%d",&Read),Change(i,Read);
    
    for(int i=1;i<=m;i++){
        scanf("%d%d",&u,&v);
        printf("%d ",Query(u,v));
    }
    
    return 0;
}
```

---

## 作者：saisai (赞：0)

我们可以通过倍增的思想来完成此题；

那么下面我们来看看到底如何求出任意一个区间内的最小值；

首先，我们要对输入进来的数据进行预处理；

那么怎么做预处理呢？

我们对于每一个点比较他后面的 2的i次方个数里最小的是什么（包括该数）

那么我们应该如何比较呢？

假设我们使用f数组存储，对于f[i][j]来说，它存储的是从第i个点开始的2的j次方点内的最大值是多少；

那么这个最大值就等于f[i][j-1](从第i个点开始后2的j-1次方个点中最小的也就是前半段中最小的)

以及f[i+2^(j-1)][j-1]（从第上半个区间的末尾开始后2的j-1次方个点中最小的，也就是后半段中最小的）

这两个值中的最小值就是f【i】【j】的值

那么预处理完了之后我们就可以读入数据了

对于读入的数据x和y（u为起点，v为终点），有两种情况：

1是区间的长度正好为2的k次方，那么我们就可以直接输出f[u][k]就是我们的结果

2是区间的长度不为2的k次方：

对于这种可能性，我们可以吧这个拆为两段；

假设输入的是3、7；

那么我们可以知道3到7的距离是5；

那么我们可以吧这段，拆成3到6是一段，4到7是另一段；

我们比较这两段的最小值就可以了；

那么这段的长度是多少呢；

我们假设是2的k次方；

有公式k=floor(log((double)(y-x+1))/log(2.0));（也就是对以2为底这段长度的对数）

那么我们要的结果就是min(f[x][k],f[y-er(k)+1][k])

那么下面贴上代码，希望大家不要直接复制，细心品味，对于上面的解释有不明白的地方多结合代码理解一下（谁让我语文不好的）



```cpp
0. #include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int a[200010];
int n;int m;
int f[200010][100];
int er(int x){
    int ans=1;
    for(int i=1;i<=x;i++)ans*=2;
    return ans;
}
int pan(int x,int y){
    int now=y-x+1;
    while(now){
        if(now%2)return 0;
        now/=2;
    }
    return 1;
}
void solve(int x,int y){
    int k=floor(log((double)(y-x+1))/log(2.0));
    if(pan(x,y)){cout<<f[x][k];return ;}
    cout<<min(f[x][k],f[y-er(k)+1][k])<<" ";
    return ;
}
int main(){
    int n;int m;cin>>n;cin>>m;
    memset(f,127,sizeof(f));
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)f[i][0]=a[i];
    int lenth=2,biaoji=1;
    while(lenth<=n){
        for(int i=1;i<=n;i++){
                f[i][biaoji]=min(f[i][biaoji-1],f[i+er(biaoji-1)][biaoji-1]);
        }
        lenth*=2;
        biaoji++;
    }
    for(int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        solve(u,v);
    }
    return 0;
}
```

---

## 作者：fengjunjie (赞：0)

对于此题，发一个RMQ的pas版本

倍增思想，预处理出每个点的后2^i个数的最小值，然后每次用O（1） 的时间复杂度查找区间内的最小元素，

查找时，如果正好区间长度为2^i，直接查找

如果不是，那么2个为2^k（k=log2（区间长度）下取整）的长度区间的区间的并集的最小值就是当前区间的最小值。

当然 第一种情况可以看做第二种情况的特例；

```cpp
program luo1816;
const maxn=100000;
      jc:array[0..20] of longint=(1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576);//打表，快速幂，或直接幂运算都可以
var f:array[1..maxn,0..20] of longint;
    n,m,i,j,x,y:longint;
function min(a,b:longint):longint;
begin
  if a<b then exit(a);
  exit(b);
end;
procedure init;
var i:longint;
begin
  readln(n,m);
  for i:=1 to n do
   read(f[i,0]);
end;
procedure pre;//预处理RMQ
var i,j:longint;
begin
  for j:=1 to 20 do
   for i:=1 to n do
   begin
     if i+jc[j]-1>n then  break;//别忘了-1
     f[i,j]:=min(f[i,j-1],f[i+jc[j-1],j-1]);//同上
   end;
end;
function find(l,r:longint):longint;//查找
var k:longint;
begin
  k:=trunc(ln(r-l+1)/ln(2));//关键
  exit(min(f[l,k],f[r-jc[k]+1,k]));
end;
begin
  init;
  pre;
  for i:=1 to m do
  begin
    readln(x,y);
    write(find(x,y),' ');
  end;
end.
```

---


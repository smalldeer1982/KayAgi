# 滑动窗口 /【模板】单调队列

## 题目描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

## 说明/提示

【数据范围】    
对于 $50\%$ 的数据，$1 \le n \le 10^5$；  
对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。


## 样例 #1

### 输入

```
8 3
1 3 -1 -3 5 3 6 7```

### 输出

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7```

# 题解

## 作者：hilsinleri (赞：877)

此题为单调队列模板题，其实楼下把单调队列与优先队列混为一谈本人并不赞同。

# 单调队列有两个性质

1. 队列中的元素其对应在原来的列表中的顺序必须是单调递增的。

1. 队列中元素的大小必须是单调递\*(增/减/甚至是自定义也可以)


# 单调队列与普通队列不一样的地方就在于单调队列既可以从队首出队，也可以从队尾出队。


# 那么我们应该怎样实现单调队列呢?

就拿样例来谈谈，设以最小的为标准。

```cpp
8 3
1 3 -1 -3 5 3 6 7
```
下文中我们用q来表示单调队列，p来表示其所对应的在原列表里的序号。

1. 由于此时队中没有一个元素，我们直接令1进队。此时，q={1},p={1}。

2. 现在3面临着抉择。下面基于这样一个思想:假如把3放进去，如果后面2个数都比它大，那么3在其有生之年就有可能成为最小的。此时，q={1,3},p={1,2}

3. 下面出现了-1。队尾元素3比-1大，那么意味着只要-1进队，那么3在其有生之年必定成为不了最小值，原因很明显:因为当下面3被框起来，那么-1也一定被框起来，所以3永远不能当最小值。所以，3从**队尾**出队。同理，1从队尾出队。最后-1进队，此时q={-1},p={3}

4. 出现-3，同上面分析，-1>-3，-1从队尾出队,-3从队尾进队。q={-3}，p={4}。

4. 出现5，因为5>-3，同第二条分析，5在有生之年还是有希望的，所以5进队。此时，q={-3,5},p={4,5}

4. 出现3。3先与队尾的5比较，3<5，按照第3条的分析，5从队尾出队。3再与-3比较，同第二条分析，3进队。此时，q={-3,3},p={4,6}

4. 出现6。6与3比较，因为3<6，所以3不必出队。由于3以前元素都＜3，所以不必再比较，6进队。因为-3此时已经在滑动窗口之外，所以-3从**队首**出队。此时，q={3,6},p={6,7}

4. 出现7。队尾元素6小于7，7进队。此时，q={3,6,7},p={6,7,8}。


那么，我们对单调队列的基本操作已经分析完毕。因为单调队列中元素大小单调递\*(增/减/自定义比较)，因此，队首元素必定是最值。按题意输出即可。


# 下面放代码啦，为了方便大家复制(划掉)，鄙人就写点注释，反正前面已经很清楚了。


```cpp
#include<cstdio>
#include<cstring>
using namespace std; 

struct Monotone_queue
{
    static const int maxn=1000001;
    int n,k,a[maxn];
    int q[maxn],head,tail,p[maxn];//同题目叙述一样，q是单调队列，p是对应编号。
    
    void read()
    {
        scanf("%d %d",&n,&k);
        for(int i=1;i<=n;++i)
            scanf("%d",&a[i]);
    }//读入不必说了
    
    void monotone_max()//单调最大值
    {
        head=1;
        tail=0;
        for(int i=1;i<=n;++i)
        {
            while(head<=tail&&q[tail]<=a[i])
                tail--;
            q[++tail]=a[i];
            p[tail]=i;
            while(p[head]<=i-k)
                head++;
            if(i>=k)printf("%d ",q[head]);
        }
        printf("\n");
    }
    
    void monotone_min()
    {
        head=1;
        tail=0;//为啥要这样呢?因为head要严格对应首元素，tail要严格对应尾元素，所以当tail>=head时，说明有元素。而一开始队列为空，说一要这样赋值。其实这跟普通队列一样。
        for(int i=1;i<=n;++i)
        {//a[i]表示当前要处理的值
            while(head<=tail&&q[tail]>=a[i])
                tail--;//只要队列里有元素，并且尾元素比待处理值大，即表示尾元素已经不可能出场，所以出队。直到尾元素小于待处理值，满足"单调"。
            q[++tail]=a[i];//待处理值入队。
            p[tail]=i;//同时存下其编号
            while(p[head]<=i-k)
                head++;//如果队首元素已经"过时"，出队。
            if(i>=k)printf("%d ",q[head]);//输出最值，即队首元素。i>=k表示该输出，至于why就自己看题目。
        }
        printf("\n");
        
    }
}worker;

int main()
{
    worker.read();
    worker.monotone_min();
    worker.monotone_max();
    return 0;
}
```

---

## 作者：囧仙 (赞：29)

## 前言

- 尽管题目名称是单调队列模板，但这并不能阻止我们用其他的思路。

- 这篇题解简要介绍了一个**线性**的分块做法，它的复杂度不亚于单调队列。

- 同时，这篇文章分析了这种方法的优劣，希望你能学到一些。

## 题解

滑动窗口的询问操作，有一个特殊的性质：**每个询问的长度相同**，都为 $k$ 。

这个性质告诉我们，任何询问都会恰好包含 $k,2\times k,\cdots ,\lfloor\frac{n}{k}\rfloor \times k$ 这 $\lfloor\frac{n}{k}\rfloor-1$ 个节点中的某个节点。

考虑题目要求的 $\min$ 和 $\max$ 操作。我们发现，它们满足结合律。因此，如果我们能够将一个询问拆成两个区间，使得它们的并为这个询问，那么我们就能通过合并它们来直接求得答案。

于是，我们将上述节点定义为**关键点**。枚举每个关键点，然后分别向左右拓展，计算以它为左/右端点的区间最大值和最小值，直到碰到另外一个关键点或边界。于是， 每个询问都能通过它包含的关键点的信息得出。

以题面的样例 $a=\{1,3,-1,-3,5,3,6,7\},k=3$ 为例，计算滑块的最小值：

- 枚举到关键点 $3$ 。 
  - 分别计算出 $[3,3],[2,3],[1,3]$ 的最小值，以及 $[3,4],[3,5]$ 的最小值。
  - 计算出 $[1,3],[2,4]=[2,3]\cup[3,4],[3,5]$ 的最小值分别为 $-1,-3,-3$ 。
- 枚举到关键点 $6$ 。
  - 分别计算出 $[6,6],[5,6],[4,6]$ 的最小值，以及 $[6,7],[6,8]$ 的最小值。
  - 计算出 $[4,6],[5,7]=[5,6]\cup [6,7],[6,8]$ 的最小值分别为 $-3,3,3$ 。

最大值过程同理。

该算法的复杂度为 $\mathcal O(n)$ ，因为我们从每个关键点向左右拓展的次数为 $4\times k$ ，而一共有 $\lfloor \frac{n}{k}\rfloor$ 个关键点。
  
## 参考代码 

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<r;i++)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =2e6+3;
int n,k,A[MAXN],B[MAXN],C[MAXN],P[MAXN],Q[MAXN];
int main(){
    n=qread(),k=qread(); up(0,n,i) A[i]=qread();
    for(int i=k-1;i<n;i+=k){
        B[i]=C[i]=A[i]; int j=i+1; B[j]=C[j]=A[j];
        up(1,k,t) B[i-t]=min(B[i-t+1],A[i-t]);
        up(1,k,t) C[i-t]=max(C[i-t+1],A[i-t]);
        up(1,k,t) B[j+t]=min(B[j+t-1],A[j+t]);
        up(1,k,t) C[j+t]=max(C[j+t-1],A[j+t]);
        up(j-k,j,t) P[t]=min(B[t],B[t+k-1]),Q[t]=max(C[t],C[t+k-1]);
    }
    up(0,n-k+1,i) printf("%d ",P[i]); puts("");
    up(0,n-k+1,i) printf("%d ",Q[i]); puts("");
    return 0;
}
```

## 分析

- 这种方法和单调队列复杂度相同，码量略少。

- 单调队列还可以处理滑块长度不一定固定的情况。该方法可能会有问题。

- 这种方法能够处理下方问题：

> 有一个长度为 $n$ 的整数序列 $a$ 。现在要求求出区间 $[i,i+m-1]$ 的**连乘积**对 $p$ 取模的值。

单调队列难以维护；而求前缀积及其逆元的方法，无法处理逆元不存在的情况。

这种时候，我们就能用上述的分块做法，直接维护每个关键点向左右延伸的前缀/后缀积。

---

## 作者：Cerisier (赞：14)

一种复杂度为 $\mathcal{O}(n)$ 的分块做法。不需要开 O2。

显然，这题可以想出一种 $\mathcal{O}(n\sqrt{n})$ 的垃圾分块做法，过不了，实测只有 [70 分](https://www.luogu.com.cn/record/76536917)，但是开 O2 可过，但是这样就没有优化的乐趣了。

观察查询阶段：

同一个块内我们不考虑，因为这部分直接暴力即可。看两端点不在同一个块内的情况，朴素代码如下：

```cpp
for (int i = l; i <= b[bel[l]].ed; i++) {
	minv = min(minv, a[i]);
	maxv = max(maxv, a[i]);
}
for (int i = b[bel[r]].st; i <= r; i++) {
	minv = min(minv, a[i]);
	maxv = max(maxv, a[i]);
}
for (int i = bel[l] + 1; i < bel[r]; i++) {
	minv = min(minv, b[i].minv);
	maxv = max(maxv, b[i].maxv);
}
```

我们使用了比较大的时间在暴力计算零散块的值，这会花费很多时间。（之所以这样说，是因为如果注释了前两个暴力的 for 之后，我们发现[只有一个点超时了](https://www.luogu.com.cn/record/76537264)）

注意到，这里零散块的暴力都是从一个块的起点或终点到某个点之前的最值，我们可以使用前缀和后缀最值来实现 $\mathcal{O}(1)$ 查询块的起点、终点到一个点之间的最值。我的代码中使用 premin/max 和 sufmin/max 分别表示前缀最小最大值和后缀最小最大值。

那么恭喜，使用这种方法我们可以得到 [90 pts](https://www.luogu.com.cn/record/76490775)，正好对应了之前注释掉的评测记录。说明这种优化是大有作用的。

此刻，你发现你陷入了一个窘境——你想不出别的方法优化了。这里，我们就需要对块长入手。

我们要充分发挥 ~~人类的智慧~~ 前缀最值和后缀最值的作用，因为使用这两个数组可以 $\mathcal{O}(1)$ 找到最值。

能用到前缀最值和后缀最值的情况只有当查询的两个端点在不同的块内。为了达到这个目标，我们需要将块长设置为 $k-1$。（我的代码中 $k$ 与块的个数重复了，于是使用 $l$ 代替）可能说的不是很清楚，我画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/kpduogal.png)

上图中红色框表示块，绿色框表示查询区间。对于查询区间的 ①，可以看做是从 $l$ 到 $l$ 所在的块末尾的最值（使用后缀最值数组），② 同理可以看做是从 $r$ 所在的块的起始到 $r$ 的最值（使用前缀最值数组）。这样可以直接 $\mathcal{O}(1)$ 解决查询问题。

那么时间复杂度也就降到了 $\mathcal{O}(n)$，好像不能再低了。

### 代码

```cpp
#include<iostream>
#include<cmath>
#include<ctype.h>
#include<climits>
#include<vector>
using namespace std;

#define int long long

const int maxn = 1e6 + 10;
const int maxblocksize = 1010;

int n, l;
int a[maxn];

struct block {
    int st, ed;
    vector<int> premax, premin;
    vector<int> sufmax, sufmin;
};
vector<block> b;

int blocksize, k, bel[maxn];

void init() {
    blocksize = l - 1, k = n / blocksize;
    b.resize(k + 5);
    for (int i = 1; i <= k; i++) {
        b[i].st = b[i - 1].ed + 1;
        b[i].ed = b[i].st + blocksize - 1;
    }
    if (b[k].ed != n) {
        k++;
        b[k].st = b[k - 1].ed + 1;
        b[k].ed = n;
    }
    for (int i = 1; i <= k; i++) {
        b[i].premax.resize(b[i].ed - b[i].st + 20);
        b[i].premin.resize(b[i].ed - b[i].st + 20);
        b[i].sufmax.resize(b[i].ed - b[i].st + 20);
        b[i].sufmin.resize(b[i].ed - b[i].st + 20);
        b[i].premax[0] = b[i].sufmax[b[i].ed + 1 - b[i].st + 1] = LLONG_MIN;
        b[i].premin[0] = b[i].sufmin[b[i].ed + 1 - b[i].st + 1] = LLONG_MAX;
        for (int j = b[i].st; j <= b[i].ed; j++) {
            bel[j] = i;
            b[i].premax[j - b[i].st + 1] = max(b[i].premax[j - b[i].st], a[j]);
            b[i].premin[j - b[i].st + 1] = min(b[i].premin[j - b[i].st], a[j]);
        }
        for (int j = b[i].ed; j >= b[i].st; j--) {
            b[i].sufmax[j - b[i].st + 1] = max(b[i].sufmax[j - b[i].st + 2], a[j]);
            b[i].sufmin[j - b[i].st + 1] = min(b[i].sufmin[j - b[i].st + 2], a[j]);
        }
    }
    return;
}
pair<int, int> query(int l, int r) {
    int minv = LLONG_MAX, maxv = LLONG_MIN;
    minv = min(minv, b[bel[l]].sufmin[l - b[bel[l]].st + 1]);
    minv = min(minv, b[bel[r]].premin[r - b[bel[r]].st + 1]);
    maxv = max(maxv, b[bel[l]].sufmax[l - b[bel[l]].st + 1]);
    maxv = max(maxv, b[bel[r]].premax[r - b[bel[r]].st + 1]);
    return make_pair(minv, maxv);
}

pair<int, int> ans[maxn];

signed main() {
    cin >> n >> l;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    if (l == 1) {
        for (int i = 1; i <= n; i++) {
            cout << a[i] << ' ';
        }
        cout << endl;
        for (int i = 1; i <= n; i++) {
            cout << a[i] << ' ';
        }
        cout << endl;
        return 0;
    }
    init();
    int cnt = 0;
    for (int i = 1; i + l - 1 <= n; i++) {
        ans[++cnt] = query(i, i + l - 1);
    }
    for (int i = 1; i <= cnt; i++) {
        cout << ans[i].first << ' ';
    }
    cout << endl;
    for (int i = 1; i <= cnt; i++) {
        cout << ans[i].second << ' ';
    }
    cout << endl;
    return 0;
}
```

---

## 作者：　　　吾皇 (赞：12)

这道题用优先队列可以过得啊（80分那位可能没有吸氧，我最慢的点350ms左右）
### 先普及一下优先队列
- 优先队列一般用来解决一些贪心问题，其底层是用“堆”来实现的。
- 任何时刻，队首元素一定是当前队列中优先级最高的（大根堆），也可以是最小的（小根堆），这也意味着我们可以手写优先级的比较
- 可以不断往优先队列中添加某个优先级的元素，也可以不断弹出优先级最高的那个元素，每次操作会自动调整结构，始终保持队首元素的优先级最高。
### 优先队列的代码
1. 优先队列的定义和访问
```
priority_queue<typename> name;
```
其中，typename可以是任何基本类型或者容器，name为优先队列的名字

2. 加入元素 复杂度O（log2 n）n为当前元素个数
```
name.push(X);
```
其中name为优先队列的名字（不再复述），X为加入元素的名字

3. 获得队顶元素 复杂度 O（1）
```
name.top();
```
可以在赋值语句中使用也可以当做一个变量

4.弹出堆顶元素 复杂度O（log2 n）
```
name.pop();
```
X为要弹出的元素的名字（可以直接定义一个并弹出，下方有举例）
### 代码举例
```
priority_queue<int>q;
q.push(3);
q.push(4);
q.push(1);
cout<<q.size()<<" ";//返回元素个数
q.push(4);
cout<<q.size()<<" "<<q.top()<<" ";
q.pop();
cout<<q.top();
```
这段程序输出"3 4 4 4"

解析：这是大根堆，先存入3,4,1，在堆中表现为4,3,1；此时询问元素个数返回3；
再存入4，堆中现在为4,4,3,1，询问元素个数和堆顶元素返回4,4；
再弹出堆顶元素，堆中为4,3,1，询问堆顶元素返回4
### 本题思路核心
```
开两个优先队列，自己手写比较程序（结构体），在进行时如果i-xx.top().xu>=k 就不断弹出 定义两个数组存放答案 最后输出
```
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct num1{
	int xu,zhi;
	bool operator < (const num1 x) const {return (zhi>x.zhi)||(zhi==x.zhi&&xu<x.xu);}
}p1;//自己手写比较函数注意要用小于号 定义一个p1是为了存入方便
struct num2{
	int xu,zhi;
	bool operator < (const num2 x) const {return (zhi<x.zhi)||(zhi==x.zhi&&xu<x.xu);}
}p2;
priority_queue<num1>q1;
priority_queue<num2>q2;//定义两个优先队列 一个是zhi小的优先，一个是zhi大的优先
int n,k,top,a[1000001],ans1[1000001],ans2[1000001];//ans1和ans2分别储存最小值和最大值
int main(){
	scanf("%d %d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=k;i++){
		p1.xu=i,p1.zhi=a[i];
		q1.push(p1);
		p2.xu=i,p2.zhi=a[i];
		q2.push(p2);
	}//先将1-k的数据存入两个优先队列中
	ans1[++top]=q1.top().zhi,ans2[top]=q2.top().zhi;//把两个队首元素保存
	for(int i=k+1;i<=n;i++){
		p1.xu=i,p1.zhi=a[i];
		q1.push(p1);
		p2.xu=i,p2.zhi=a[i];
		q2.push(p2);//不停存入下一个准备进来的元素
		while(i-q1.top().xu>=k) q1.pop();
		while(i-q2.top().xu>=k) q2.pop();//如果超过了范围弹出
        ans1[++top]=q1.top().zhi,ans2[top]=q2.top().zhi;//保存答案
	}
	for(int i=1;i<=top;i++) printf("%d ",ans1[i]);
	printf("\n");
	for(int i=1;i<=top;i++) printf("%d ",ans2[i]);//最后输出
}
```


---

## 作者：Jerrycyx (赞：8)

本文摘自我的专栏：**[单调队列：实用而好写的数据结构](https://www.luogu.com.cn/article/1fiztcrj)**。

2025.3.21 更新：修正了一处笔误，感谢 @[Galaxy_Ivan](https://www.luogu.com.cn/user/85055) 的贡献；将讲解部分求最大值改成了求最小值以匹配模板和题面；语言进行了些微润色，删除了部分冗余内容。

-----

> 顾名思义，单调队列的重点分为「单调」和「队列」。
> 
> 「单调」指的是元素的「规律」——递增（或递减）。
> 
> 「队列」指的是元素只能从队头和队尾进行操作（实际上是个双端队列）。
>
> —— [OI Wiki](https://oi-wiki.org/ds/monotonous-queue/)

老生常谈的单调队列模板题了，题面要求定长区间最值，下面来说单调队列的运作方式（以求取区间最小值为例）。

单调队列的核心思想是：“**老而更劣的元素永远不可能成为最值**”~~（让我想起了我的 OI 生涯）~~。

例如：在从左往右滑动窗口求最小值时，考虑右侧新加入一个元素 $a_j$ 时会发生什么。假设区间中已经有的一个元素 $a_i$ 使得 $a_i \ge a_j$，那么 $a_j$ 离开窗口一定比 $a_i$ 要晚，且今后 $a_i$ 在队列里的时候 $a_j$ 也一直在队列里。**在 $a_i$ 剩下的生命里直到离开区间，$a_j$ 永远比它小，$a_i$ 再也不可能成为（唯一的）最小值了**。

现实是残酷的，OIer 们是残忍的，$a_i$ 已经失去了成为（唯一）最小值的机会，OIer 们毫不留情地抛弃掉它，来**保证留下的都是有机会成为最小值的**。

如此，单调队列保证了其中不存在 $a_i,a_j$ 使 $i<j$ 且 $a_i \ge a_j$，即**对于任意 $i<j$ 都有 $a_i<a_j$**，换言之，**这个单调队列里的元素是单调递增的**。

总的来说，单调队列解决这道题（最小值部分）的过程分为两步：

1. 加入新的元素时，从队尾踢掉之前所有不小于它的元素，并自己加入队尾
2. 从队头移除已经离开窗口的元素

通常情况下上面两步顺序可以任意交换，少数情况下（即新加入的元素可能不在窗口内时）必须按照上面的顺序。**对于这道题，顺序可以任意交换**。每次完成上面两步以后，**队头即为最小值**。

附上我常用的模板代码（求定长区间最小值）：

```cpp
int q[N],head,tail; //单调队列记录最小值的位置，方便后面判断某元素是否已经离开窗口
...
head=1,tail=0; //清空队列
for(int i=1;i<=n;i++) //枚举窗口右端
{
  while(head<=tail && i-q[head]+1>k) q[head++]=0; //弹出已经离开窗口的元素
  while(head<=tail && a[q[tail]]>a[i]) q[tail--]=0; //从队尾踢掉之前所有不小于当前元素的数
  q[++tail]=i; //当前元素自己加入队尾
  if(i>=k) res[i-k+1]=q[head]; //完成以上操作后，队头即为最小值
}
```

**每个元素最多入队出队一次，所以时间复杂度是 $O(n)$ 线性的**。

-----

对于这道题，同时要求最小和最大值。因为 $\max(a_i) = - \min(-a_i)$，即区间最大值等于序列相反数的最小值的相反数，所以我们可以只写一个求最小值的代码，求过区间最小值以后把序列所有元素取相反数再求一遍最小值，然后再取一次相反数就是区间最大值。

代码：

```cpp
#include<cstdio>
using namespace std;

const int N=1e6+5;
int n,k,a[N];
int ans1[N],ans2[N];

int q[N],head,tail;
void Calc(int res[]) //指针传参，答案计入 res 数组
{
	head=1,tail=0; //清空队列
	for(int i=1;i<=n;i++) //枚举窗口右端
	{
	  while(head<=tail && i-q[head]+1>k) q[head++]=0; //弹出已经离开窗口的元素
	  while(head<=tail && a[q[tail]]>a[i]) q[tail--]=0; //从队尾踢掉之前所有比当前元素大的数
	  q[++tail]=i; //当前元素自己加入队尾
	  if(i>=k) res[i-k+1]=q[head]; //完成以上操作后，队头即为最小值
	}
	return;
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	
	Calc(ans1); //计算滑动窗口最小值位置，答案计入 ans1
	for(int i=1;i<=n-k+1;i++)
		printf("%d ",a[ans1[i]]);
	putchar('\n');
	
	for(int i=1;i<=n;i++)
		a[i]=-a[i]; //所有元素取相反数
	Calc(ans2); //计算此时的滑动窗口最小值位置，答案计入 ans2
	for(int i=1;i<=n-k+1;i++)
		printf("%d ",-a[ans2[i]]); //再取一遍相反数即为最大值
	return 0;
}
```

-----

**单调队列代码简短而好写，能够解决的问题范围清晰，是一种很实用的数据结构**。未来可以发现，它的下限很低但上限也很高。单调队列不常作为一个裸的知识点来单独考，而是**常常与动态规划等问题结合在一起，用作优化时间复杂度**。

单调队列可以优化的问题具有以下特点：

+ 在一个区间 $[l,r]$ 上求最值；
+ **区间左右端点 $l,r$ 均单调不减/单调不增**。

同时，类似本题这种 **“（连续移动的）定长区间最值问题”是单调队列中考得最多的一种**，也是必须掌握的一种。

下面附上一份更加通用的单调队列模板（或者说其实算是伪代码？）：

```cpp
定义/清空单调队列 //需要队头队尾均可压入和弹出，如双端队列
for(int i=1;i<=n;i++)
{
  while(队列非空 && 队尾劣于当前元素i) 弹出队尾;
  队尾压入i;
  while(队列非空 && 队头超出范围) 弹出队头;
  //此时队头为最优元素，按题目需要使用
}
```

---

## 作者：yr409892525 (赞：6)

## 题解：P1886 滑动窗口 /【模板】单调队列
### 算法
单调队列，可以 $O(n)$ 求解区间最大值。               
### 实现过程
我们以区间最大值为例。
1. 如果队首元素过时，弹出队首元素。
2. 如果当前元素大于队尾元素，弹出队尾元素。
3. 在队尾加入当前元素。
4. 当前队首元素就是答案。
### 正确性证明
由于每个元素只会入队一次，所以时间为 $O(n)$，空间为 $O(n)$。               
因为队列里的元素从队首到队尾是按从大到小的顺序排列。            
所以队首元素一定是当前区间的最大值。             
### 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5,inf=1e18;
int n,m;
int a[N];
int q[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	} 
	int l=1,r=0;
	for(int i=1;i<=n;i++){
		while(l<=r && a[q[r]]>=a[i]){
			r--;
		}
		while(l<=r && q[l]+m<=i){
			l++;
		}
		q[++r]=i;
		if(i>=m){
			cout<<a[q[l]]<<" ";
		}
	}
	cout<<"\n";
	l=1,r=0;
	for(int i=1;i<=n;i++){
		while(l<=r && a[q[r]]<=a[i]){
			r--;
		}
		while(l<=r && q[l]+m<=i){
			l++;
		}
		q[++r]=i;
		if(i>=m){
			cout<<a[q[l]]<<" ";
		}
	}
	return 0;
}
```

---

## 作者：kunkun127 (赞：4)

## 题目描述
给定一个长度为 $ n $ 的数组 $ a $ 和一个长度为 $ k $ 的滑动窗口，窗口从数组的最左端滑动到最右端。每次窗口滑动时，输出窗口中的最小值和最大值。

## 解题思路
这道题的核心是高效地维护滑动窗口中的最值。直接暴力枚举每个窗口的最值会导致时间复杂度为 $ O(n \cdot k) $，无法通过本题。因此，我们需要使用**单调队列**来优化。

### 单调队列的核心思想

单调队列通过以下两个操作来维护队列的单调性：

1. **移除队尾元素**：
   
   - 当新元素加入队列时，如果新元素破坏了队列的单调性，则从队尾移除一些元素，直到队列重新满足单调性。
     
2. **移除队首元素**：
   
   - 当队首元素已经不在当前窗口范围内时，将其从队首移除。

通过这两个操作，单调队列能够始终维护窗口内的最值或其他性质。

### 单调队列的应用场景

单调队列常用于解决以下问题：

1. **滑动窗口的最值问题**：
   
   - 给定一个数组和一个固定大小的窗口，求每个窗口中的最大值或最小值。
2. **优化动态规划问题**：
   
   - 在某些动态规划问题中，单调队列可以用于优化状态转移方程，减少时间复杂度。

### 单调队列的实现细节
以下以滑动窗口的最小值为例，详细说明单调队列的实现过程。

#### 维护单调递增队列
- **目标**：维护一个单调递增的队列，队首元素始终是当前窗口的最小值。
- **操作**：
  1. 当新元素加入队列时，从队尾移除所有比新元素大的元素，以保持队列的单调递增性。
  2. 当队首元素已经不在当前窗口范围内时，将其从队首移除。
  3. 队首元素即为当前窗口的最小值。


## 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;

int a[1000005], q[1000005];

int main()
{
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int head = 1, tail = 0;
	for (int i = 1; i <= n; i++)
	{
		if (head <= tail && q[head] < i - k + 1) head++;
		while (head <= tail && a[q[tail]] > a[i]) tail--;
		q[++tail] = i;
		if (i >= k) cout << a[q[head]] << ' ';
	}
	cout << endl;
	head = 1, tail = 0;
	for (int i = 1; i <= n; i++)
	{
		if (head <= tail && q[head] < i - k + 1) head++;
		while (head <= tail && a[q[tail]] < a[i]) tail--;
		q[++tail] = i;
		if (i >= k) cout << a[q[head]] << ' ';
	}
	cout << endl;
	return 0;
}
```

---

## 作者：nothingness (赞：2)

全是线段树或单调队列。。。来发一篇树状数组题解。

单调队列是正解，这里不讲了（能有空看树状数组题解的大佬肯定都会），但是各位用线段树的大佬就要各种常数优化，不然TLE了。

但是这样，为什么不考虑一下**功能一样**而且**常数更小**的**树状数组**呢？

大致思路：当 $r-lowbit(r)>l$ 时，区间 $[l,r]$ 的最大值相当于 $\max([l,r-lowbit(r)-1],[r-lowbit(r),r])$ ，否则有 $\max([l,r-1],a[r])$ 。

这样子的话哪怕不吸氧也能AC~

平均时间复杂度为 $O(nlog_2n)$ 。

## Code
```
#include "bits/stdc++.h"
#define lowbit(x) ((x)&(-(x)))
#define N 1000001
using namespace std;

int n,m,a[N],c1[N],c2[N];

inline void read(int &x)
{
	int s=1;
	char ch=0;
	x=0;
	while(ch^'-'&&!isdigit(ch))
		ch=getchar();
	if(ch=='-')
	{
		s=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	x*=s;
}

void update1(int i,int x)
{
	while(i<=n)
	{
		c1[i]=min(c1[i],x);
		i+=lowbit(i);
	}
}

void update2(int i,int x)
{
	while(i<=n)
	{
		c2[i]=max(c2[i],x);
		i+=lowbit(i);
	}
}

int query1(int l,int r)
{
	int t=INT_MAX;
	while(l<=r)
		if(r-lowbit(r)>l)
			t=min(t,c1[r]),r-=lowbit(r);
		else
			t=min(t,a[r]),r--;
	return t;
}

int query2(int l,int r)
{
	int t=INT_MIN;
	while(l<=r)
		if(r-lowbit(r)>l)
			t=max(t,c2[r]),r-=lowbit(r);
		else
			t=max(t,a[r]),r--;
	return t;
}

int main()
{
	read(n),read(m);
	for(int i=1;i<=n;i++)
		c1[i]=INT_MAX,c2[i]=INT_MIN;
	for(int i=1;i<=n;i++)
		read(a[i]),update1(i,a[i]),update2(i,a[i]);
	for(int i=m;i<=n;i++)
		printf("%d ",query1(i-m+1,i));
	printf("\n");
	for(int i=m;i<=n;i++)
		printf("%d ",query2(i-m+1,i));
	return 0;
}
```

虽然不是最快的，但是比上不足比下有余，也顺便为像我一样的蒟蒻介绍一下区间查询最值的树状数组。

---

## 作者：Smokey_Days (赞：2)

显然是单调队列的模板题。就我做的这几题单调队列的题而言，单调队列的使用情况是很明显的：

1. 在某个/某组区间内求解，该组区间符合以下特征：

	a. 预先给出，或者可以求得。
    
    b. 对于每个区间$[l_{i},r_{i}]$以及它们的下一个区间$[l_{i+},r_{i+1}]$，一定存在$l_{i}<=l_{i+1}$且$r_{i}<=r_{i+1}$。
   
2. 解满足这样一组性质：

	a.解存在单调性。
    
    b.在解集$A$中，对于$∀x∈A$，它的求解不需要用到$∀y∈A∪y|y_{id}>x_{id}$

满足上面两组特征的问题，通常可以用单调队列求解。

对于这一题，由于它求的是最值，所以解显然性质$2.a$；对于每一次询问的回答，都只需要用到该询问或它之前已有的元素，所以满足性质$2.b$而它所求的「窗口」，可以被视为一个宽度为$k$的区间$[i-k,i]$，满足性质$1$。故可以用单调队列求解。

------------

所谓单调队列，是队列的子集，是满足以下性质的队列：

1. 队列具有单调递增/递减性。
2. 前一个元素永远比后一个元素先进队。

而为了维护这种性质，在每一次将新的元素$i$插入队列时，进行以下操作：

1. 比对元素$i$与队尾元素$j$。
2. 若插入$i$后会破坏性质1则弹出$j$。
3. 回到步骤1，直到性质1被保持或队列为空。

这样就维护了队列的单调性，并且可以查询在区间$[1,i]$之间的解。

然后，为了保证能够求得$[i-k,i]$的解，我们需要弹出不符合条件的解。因此，对于每个队首元素，我们都需要将它的$id$与$i-k$比对，求得它是否在所求区间内。

这就做完了。

------------

单调队列由于它的特殊性，需要使用双端队列来求解，这个可以手写也可以调用$STL-deque$库。具体选择什么还是看情况。一般来说手写会快一点（笑）

下面是我的代码。

```cpp
#include<iostream>
#include<cstdio>
#include<deque>
using namespace std;
struct data{
	int nm;
	int id;
};

int mx[1000005],mn[1000005],n,k;//注意数据范围 

deque<data> xq;
deque<data> nq;

void init(){
	scanf("%d%d",&n,&k);
	int ni;
	data nw;
	for(int i=1;i<=n;i++){
		scanf("%d",&ni);
		nw.nm=ni;
		nw.id=i;
		while((!xq.empty())&&xq.back().nm<=ni){
			xq.pop_back();
		}
		xq.push_back(nw);
		while((!nq.empty())&&nq.back().nm>=ni){
			nq.pop_back();
		}
		nq.push_back(nw);
		while((!xq.empty())&&xq.front().id<=i-k){
			xq.pop_front();
		}
		while((!nq.empty())&&nq.front().id<=i-k){
			nq.pop_front();
		}
		if(i>=k){
			mx[i-k]=xq.front().nm;
			mn[i-k]=nq.front().nm;
		}
	}
	for(int i=0;i<=n-k;i++){
		printf("%d ",mn[i]);
	}
	printf("\n");
	for(int i=0;i<=n-k;i++){
		printf("%d ",mx[i]);
	}
}

int main(){
	init();
	return 0;
}
```

---

## 作者：SuyctidohanQ (赞：1)

### 思路分析

这题是单调队列。

首先考虑暴力（居然可以拿 $90$ 分？？）。

```cpp
#include <map>
#include <set>
#include <queue>
#include <cmath>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <bits/stdc++.h>

#define unmap unordered_map
#define unset unordered_set
#define muset multiset
#define ll long long
#define unint unsigned int
#define ull unsigned ll
#define please return
#define AC 0
#define il inline
#define cst const
#define db double
#define ld long db
#define pii pair<int,int>
#define pll pair<ll,ll>

#define str string


#define int long long

using namespace std;

cst ll INF = 9223372036854775807;
cst int inf = 2147483647;
cst int xinf = 0x3f3f3f3f;
cst ll XINF = 0x3f3f3f3f3f3f3f3fll;
cst db pi = acos (-1.0), eps = 1e-12;

cst int MAXN = 1e6 + 10; 
cst int mod = 11;

#define rep(i, a, b) for (int i = a; i <= b; i++)
#define repr(i, a, b) for (int i = a; i >= b; i--)

il int _abs (int a) { if (a < 0) return -a; return a; }
il int _pow (int a, int b) { int x = 1, y = a; while(b > 0) {if (b & 1) x *= y; y *= y; b >>= 1; } return x; }

int read () { int sum = 0, f = 1; char ch; ch = getchar (); while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar ();} while (ch >= '0' && ch <= '9') {  sum = sum * 10 + ch - '0'; ch = getchar ();} return sum * f;}
void print (int x) { if (x < 0) { putchar ('-'); x = -x;} if (x > 9) print (x / 10); putchar (x % 10 + '0'); return ;}


// ------------------------------
signed main () {
    
    int shu[MAXN], n, k;
	
	cin >> n >> k;
	rep(i, 1, n) cin >> shu[i];
	rep(i, 1, n - k + 1) {
		
		int minn = 0x3f3f3f3f;
		rep(j, i, k + i - 1) minn = min (minn, shu[j]);
		cout << minn << ' ';
	}
	cout << endl;
	rep(i, 1, n - k + 1) {
		
		int maxx = - (0x3f3f3f3f - 1);
		rep(j, i, k + i - 1) maxx = max (maxx, shu[j]);
		cout << maxx << ' ';
	}
	cout << endl;  
	please AC;
}
```

暴力不可做。时间复杂度为 $O(n ^ 2)$。考虑优化。

考虑情况如下（其实就是样例）：

![](https://cdn.luogu.com.cn/upload/image_hosting/lwazrbcm.png)

第一次选择：

![](https://cdn.luogu.com.cn/upload/image_hosting/ygrnesw6.png)

最大值为 $3$，最小值为 $-1$。

第二次选择：

![](https://cdn.luogu.com.cn/upload/image_hosting/tpy6ae9i.png)

最大值为 $3$，最小值为 $-3$。此时一开始（对头）的数字 $1$ 已经被排除在外，新增加数字 $-3$。

第三次选择：

![](https://cdn.luogu.com.cn/upload/image_hosting/7kkazsb0.png)

最大值为 $5$，最小值为 $-3$。此时一开始（对头）的数字 $1$ 和数字 $3$ 已经被排除在外，新增加数字 $5$。

第四次选择：

![](https://cdn.luogu.com.cn/upload/image_hosting/6vwvub7d.png)

最大值为 $5$，最小值为 $-3$。此时一开始（对头）的数字 $1$、数字 $3$ 和数字 $-1$ 已经被排除在外，新增加数字 $3$。

第五次选择：

![](https://cdn.luogu.com.cn/upload/image_hosting/2lxcby2e.png)

最大值为 $6$，最小值为 $3$。此时一开始（对头）的数字 $1$、数字 $3$、数字 $-1$ 和数字 $-3$ 已经被排除在外，新增加数字 $6$。

第六次选择：

![](https://cdn.luogu.com.cn/upload/image_hosting/a342152z.png)

最大值为 $7$，最小值为 $3$。此时一开始（对头）的数字 $1$、数字 $3$、数字 $-1$、数字 $-3$ 和数字 $5$ 已经被排除在外，新增加数字 $7$。

于是，我们发现了一个规律：当我新加入的 $a_i$ 是当前队列里的最大值时，所有之前 $< a_i$ 的数就失去了作用。于是，经过操作后，这个序列变成里**单调递增的。**

单调队列解决这道题（以最大值为例）的过程分为两步：

- 加入新的数字时，循环从队尾踢掉之前**所有比它小的数字**，并自己加入队尾。因为之前比自己小的数字已经**没有作用了。**

- 每次操作过后，**一定**有一个数字**离开区间范围**，所以从队头移除已经离开窗口的元素，这个元素已经**没有作用了。**

要维护对头和队尾，所以需要**双端队列。**

每个元素**最多**入队出队一次，所以时间复杂度是 $O(n)$ 的，可以通过。

### 代码实现

```cpp
#include <map>
#include <set>
#include <queue>
#include <cmath>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <bits/stdc++.h>

#define unmap unordered_map
#define unset unordered_set
#define muset multiset
#define ll long long
#define unint unsigned int
#define ull unsigned ll
#define please return
#define AC 0
#define il inline
#define cst const
#define db double
#define ld long db
#define pii pair<int,int>
#define pll pair<ll,ll>

#define str string


#define int long long

using namespace std;

cst ll INF = 9223372036854775807;
cst int inf = 2147483647;
cst int xinf = 0x3f3f3f3f;
cst ll XINF = 0x3f3f3f3f3f3f3f3fll;
cst db pi = acos (-1.0), eps = 1e-12;

cst int MAXN = 1e6 + 10; 
cst int mod = 11;

#define rep(i, a, b) for (int i = a; i <= b; i++)
#define repr(i, a, b) for (int i = a; i >= b; i--)

il int _abs (int a) { if (a < 0) return -a; return a; }
il int _pow (int a, int b) { int x = 1, y = a; while(b > 0) {if (b & 1) x *= y; y *= y; b >>= 1; } return x; }

int read () { int sum = 0, f = 1; char ch; ch = getchar (); while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar ();} while (ch >= '0' && ch <= '9') {  sum = sum * 10 + ch - '0'; ch = getchar ();} return sum * f;}
void print (int x) { if (x < 0) { putchar ('-'); x = -x;} if (x > 9) print (x / 10); putchar (x % 10 + '0'); return ;}


// ------------------------------

int shu[MAXN], n, k;
deque <int> deq;
signed main () {
    
	cin >> n >> k;
	rep(i, 1, n) cin >> shu[i];
	rep(i, 1, n) {
		
		while (!deq.empty () && shu[deq.back ()] >= shu[i]) deq.pop_back ();
		if (!deq.empty () && i - deq.front () >= k) deq.pop_front ();
		deq.push_back (i);
		if (i >= k) cout << shu[deq.front ()] << ' ';
	}
	
	deq.clear ();
	cout << endl;	
	
	rep(i, 1, n) {
		
		while (!deq.empty () && shu[deq.back ()] <= shu[i]) deq.pop_back ();
		if (!deq.empty () && i - deq.front () >= k) deq.pop_front ();
		deq.push_back (i);
		if (i >= k) cout << shu[deq.front ()] << ' ';
	}
	
	cout << endl; 
	please AC;
}
```

---

## 作者：_yang_yi_bo_ (赞：1)

关于单调队列，有一句名言。

> 如果一个人比你小，还比你强，那你就没救了。

事实上，单调队列确实是这个样子的。

因为当出现一个数比 $x$ 大，还比你晚出现，那代表在包含 $x$ 的区间内，这个数一直比 $x$ 大，而且 $x$ 肯定比这个数先离开区间，那你接下来就不会被输出，不必存储。

单调队列，正是那样，队列里的元素是单调的。

根据上面的说法，容易给出单调队列的写法，我们以维护窗口最大值为例：

1. 弹出过时的元素；
2. 当队尾元素 $<$ 新加入的元素时，弹出队尾元素；
3. 重复操作 $2$，直到队列为空或队尾元素 $>$ 新加入的元素；
4. 队首元素就是当前答案；
5. 移动窗口。

这里根据我们开头的性质，容易得出答案一定正确。

求最小值同理。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,l=1,r=0;
int a[1000005],q[1000005];
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}for(int i=1;i<=n;i++){
		while(l<=r&&a[q[r]]>=a[i]){
			r--;
		}q[++r]=i;
		while(l<=r&&q[l]+k<=i){
			l++;
		}if(i>=k){
			cout<<a[q[l]]<<" ";
		}
	}cout<<"\n";
	l=1,r=0;
	for(int i=1;i<=n;i++){
		while(l<=r&&a[q[r]]<=a[i]){
			r--;
		}q[++r]=i;
		while(l<=r&&q[l]+k<=i){
			l++;
		}if(i>=k){
			cout<<a[q[l]]<<" ";
		}
	}
	return 0;
}
```

这里不推荐使用双端队列，建议使用手写队列。

注意代码里往队列里插入的是下标而不是元素本身的值。

---

## 作者：Union_Find (赞：1)

首先声明，优先队列不等同于单调队列，后文会提到。

# 算法介绍

单调队列，是一种静态处理满足条件的**区间**的最值的算法，时间复杂度是 $O(n)$ 的。使用单调队列的
前提是所有数字不会在处理之后再次处理。注意，不代表不能被多次询问，而是询问不能中断

下面我们以求最小值为例，讲解单调队列的思考过程和实现方法。

如果这题的询问区间长度不是固定的，我们就只能使用 $O(n\log n)$ 的 ST 表或者其他数据结构维护了。但是这题给了我们一个好的条件，就是长度都是 $k$。我们可以从这个入手。

注意到，直接暴力算是 $O(n^2)$ 的，因为我们要对于每个长度为 $k$ 的区间枚举一遍。但是我们发现，枚举的过程会有很多是重复枚举的，时间复杂度也就是浪费在这。如果我们可以做到每个数字只枚举 $1$ 次，我们就可以 $O(n)$ 解决这个问题了。

  考虑到，我们可以在 $[l,l+k-1]$ 区间的基础上求出 $[l+1,l+k]$ 的答案。因为这两个区间只有 $l$ 和 $l+k$ 两个位置不同。$l+k$ 是好做的，直接取 min 即可，但是如何删除 $l$ 呢？

我们要删除**最小值**之后并知道答案，就一定要知道**次小值**。但如果次大值也删除了呢？我们就要知道**第三小值**。以此类推，我们要把所有之按顺序存下来，然后删除的时候直接判断当前的最大值是否在 $[l+1,l+k]$ 的区间之外。而单调队列，存储的就是排好序的值。

删除的代码如下。

```cpp
il void pop(ll x){
	while (hd <= tl && q[hd] <= x - k) hd++;
}
```

其中我们用数组模拟队列，$hd$ 表示队列头，$tl$ 表示队列尾。$q$ 数组中以此存的是最小值的下标，次小值的下标之类的。因为队列的值是单调不降的，所以叫做**单调队列**。

现在删除可以做了，但是插入呢？如果我们暴力枚举插入的值插在队列的哪里，时间复杂度最坏还是 $O(n^2)$ 的。这时候，我们发现，已经出现在队列里的**下标**一定比当前的 $i$ 要更小。如果当前这个值比队列中的某个值更小，这个值就一定不会成为答案。

```
3 3
1 3 2 4
```

以上面的数据为例，如果此时 $1$ 和 $3$ 在单调队列中，我们此时要插入 $2$，我们发现，$3$ 因为在 $2$ 前面，那么在 $2$ 弹出之前，$3$ 肯定已经弹出了。所以 $3$ 肯定不会成为后面的任何一个答案，我们可以直接把 $3$ 弹出来，把 $2$ 塞进来。

所以我们得出结论，只要找出所有比 $a_i$ 大的数字，直接拎出来丢掉。而又因为队列是单调的，所以所有比 $a_i$ 大的数字一定在队列的末尾，直接暴力枚举末尾即可。

最后我们插入的代码也有了。

```cpp
il void insert(ll x){
	while (hd <= tl && a[q[tl]] >= a[x]) tl--;
	q[++tl] = x;
}
```

# 正确性分析

我们来分析一下时间复杂度。因为这道题他的区间持续右移，每次移动涉及到的数字只有 $l$ 和 $l+k$。所以每个数字最多操作两次，一次进入队列，一次弹出队列。最后时间复杂度就是 $O(n)$ 的。

# CODE

因为这道题要求最小和最大值，可以求完最小值之后把所有 $a_i$ 取相反数，再求一边最小值，输出相反数，这样子代码就比较简单了。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 1000005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
ll n, k, a[N], q[N], hd = 1, tl;
il void pop(ll x){
	while (hd <= tl && q[hd] <= x - k) hd++;
}il void insert(ll x){
	while (hd <= tl && a[q[tl]] >= a[x]) tl--;
	q[++tl] = x;
}il void solve(ll t){
	for (int i = 1; i < k; i++) insert(i);
	for (int i = k; i <= n; i++){
		pop(i), insert(i);
		printf ("%lld ", t * a[q[hd]]);// 为了方便，直接反过来 
	}
}
int main(){
	n = rd(), k = rd();
	for (int i = 1; i <= n; i++) a[i] = rd();
	solve(1);
	puts("");
//  处理第一问
	memset (q, 0, sizeof q);hd = 1, tl = 0;// 清空
	for (int i = 1; i <= n; i++) a[i] = -a[i];
	solve(-1);
//  处理第二问 
	return 0;
}

```

---

## 作者：Manchester_City_FC (赞：0)

### 题目大意
有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

### 算法介绍——单调队列
我们不妨先思考一个朴素的暴力做法。考虑从头开始，对于每个长度为 $k$ 的区间都去一一判断，这样的时间复杂度是 $\mathcal O(nk)$ 的，在数据范围较大的时候不可行。那么，这个算法该如何去优化呢？其实很简单。由于中间部分的数会被计算很多次，所以我们考虑使用单调队列这一算法。

什么是单调队列呢？其实和普通的队列大同小异，只不过队列中的元素必须满足递增或递减的要求。换句话说，用单调队列来解决问题，一般都是需要得到当前的某个范围内的最小值或最大值。

我拿样例做一个解释吧。我们现在有一个序列 $[1,3,-1,-3,5,3,6,7]$ 且 $k$ 的值为 $3$，初始时队列为空。我以求最小值举个例子：
1. 将 $1$ 插入队列中。此时队列为 $\{1\}$。
2. 将 $3$ 插入队列中。由于 $3$ 比 $1$ 要大，所以我们将 $3$ 插入到队列的末尾，此时队列为 $\{1,3\}$。
3. 将 $-1$ 插入到队列中。我们发现，此时队首元素 $1$ 大于 $-1$，所以我们清空队列，并将 $-1$ 插入，此时队列为 $\{-1\}$。
4. 将 $-3$ 插入到队列中。此时队首元素 $-1$ 大于 $-3$，我们清空队列并将 $-3$ 插入，此时队列为 $\{-3\}$。
5. 将 $5$ 插入队列中。由于 $5$ 比 $-3$ 要大，所以此时队列为 $\{-3,3\}$。
6. 将 $3$ 插入队列中。由于 $3$ 比 $5$ 小，所以 $5$ 出队，$3$ 入队，此时队列为 $\{-3,3\}$。
7. 将 $6$ 插入队列中。由于 $6$ 比 $3$ 要大，所以我们将 $6$ 插入到队尾。但是请注意，由于窗口的范围是 $3$，所以此时 $-3$ 这个元素已经超出窗口的范围，所以 $-3$ 要出队。此时队列为 $\{3,6\}$。
8. 将 $7$ 插入队列中。由于 $7$ 比 $6$ 要大，所以我们将 $7$ 插入到队尾即可。最终的队列为 $\{3,6,7\}$。

这样我们就完成了这道问题，就可以写代码了。时间复杂度是 $\mathcal O(n)$ 的。

最后提两点注意事项：
+ 题目中要求把最小值和最大值都输出，所以一种可行的做法就是跑两遍单调队列。
+ 手写单调队列是比使用 deque 稍快一点的。不过由于使用 deque 比较方便，我就不手写了。
### AC 代码
代码中有注释，读者可以自行理解：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1;
struct node{
	int t,q;//t 用来存要插入的元素，q 为该元素的位置下标 
}p;
int a[N],b[N],n,k;//a 用来存最小值，b 用来存最大值 
deque<node>minn,maxn;//最小值的队列与最大值的队列 
int main(){
	cin>>n>>k;
	for(int i=1,x;i<=n;i++){
		cin>>x;
		p.t=x,p.q=i;
		//插入新元素 
		while((!minn.empty())&&minn.back().t<=x) minn.pop_back();
		minn.push_back(p);
		while((!maxn.empty())&&maxn.back().t>=x) maxn.pop_back();
		maxn.push_back(p);
		//将队首元素弹出 
		while((!minn.empty())&&minn.front().q<=i-k) minn.pop_front();
		while((!maxn.empty())&&maxn.front().q<=i-k) maxn.pop_front();
		//将最小值与最大值存入答案数组中 
		if(i>=k){
			a[i-k]=maxn.front().t;
			b[i-k]=minn.front().t;
		}
	}
	//输出答案 
	for(int i=0;i<=n-k;i++) cout<<a[i]<<' ';
	cout<<endl;
	for(int i=0;i<=n-k;i++) cout<<b[i]<<' ';
}
```

---

## 作者：GZXUEXUE (赞：0)

### 算法介绍

[单调队列](https://oi.wiki/ds/monotonous-queue/)是数据结构的一种，非常的实用，用法包括优化动态规划等。  
那么，如何实现单调队列呢？  
下面让我们以本题为例。

**题意简述**  
给出一个长度为 $n$ 的数组 $a$，输出每 $k$ 个连续的数中的最大值和最小值。$1 \le k \le n \le 10^6$。

**思路**  
以第二小问求最大值为例。我们定义一个队列 $q$。为了方便，$q$ 中存储下标。  
首先，我们依次把所有 $a_i (1 \le i \le n)$ 入队。
假设现在在队头有一个 $a_j (j \le i \operatorname{and} a_j \le a_i)$，那么 $a_j$ 应该出队，因为从现在开始在 $a_j$ 存在的时候，最大值显然不会是 $a_j$，所以把它出队，然后再去检查新的队头，直到不存在这样的 $a_j$ 为止。  
另外，显见当队头存在一个已经不在当前区间（窗口）内的数字时，我们也应该把它出队。

### 正确性证明

#### 命题
每次窗口滑动后，队列的队首元素即为当前窗口的最大值（以本题第二小问为例）。

#### 初始

1. **初始状态**  
队列按规则构建，依次将前 $k$ 个元素入队并移除比当前元素小的队尾元素。
2. **单调性**  
通过入队时的尾部清理操作，队列始终保持递减。
3. **窗口是否在范围内**  
所有元素下标均在 $[0, k-1]$ 范围内。

此时，队首元素为前 $k$ 个元素的最大值，初始状态正确。

#### 循环

假设在处理第 $i$ 个元素（当前窗口右边界为 $i$）时，队列仍满足循环不变式，故可以通过证明处理 $i+1$ 后仍成立证明这一步正确。

1. **入队操作的单调性**
   - 操作  
   将 $a_i$ 入队前，从队尾移除所有 $a_j(a_j \le a_i)$。
   - 正确性  
   移除队尾的 $a_j$ 后，$a_i$ 成为新的队尾，队列仍递减。  
被移除的 $a_j$ 在后续窗口中不可能成为最大值（因为 $a_i$ 更大且位置更靠右，存在时间更长）。
2. **窗口有效性的维护**
   - 操作  
   检查队首元素索引是否超出窗口左边界 $(i + 1) - k$，若超出则出队。
   - 正确性  
   确保队列中仅包含当前窗口 $[(i + 1) - k + 1,i + 1]$ 内的索引。
3. **队首为当前最大值**
   - 结论  
   队列单调递减表明队首是窗口内最大元素。
   - 反证  
   若存在 $a_j$（$j$ 在窗口内）比队首大，则根据入队规则，$a_j$ 应已使队首出队，故矛盾。
4. **结论**  
   算法对所有位置均正确维护队列，队首始终为窗口最大值。

### 代码实现

以本题第二小问为例。
```cpp
deque<int> dq; /*dq.clear();*/
for (int i = 0;i < n;i++){
  while (!dq.empty() && i - k + 1 > dq.front()) dq.pop_front();
  while (!dq.empty() && a[i] > a[dq.back()]) dq.pop_back();
  dq.push_back(i);
  if (i + 1 >= k) cout << a[dq.front()] << " "; // 输出队头，即最大值
}
```

---


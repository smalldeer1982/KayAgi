# 查单词

## 题目背景

滚粗了的 HansBug 在收拾旧英语书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本英语书里面找到了一个单词表，包含 $N$ 个单词（每个单词内包含大小写字母）。现在他想要找出某一段连续的单词内字典序最大的单词。


## 说明/提示

### 样例说明

第一次操作：在{absi,hansbug,lzn,kkk,yyy}中找出字典序最大的，故为yyy

第二次操作：在{absi}中找出字典序最大的，故为absi

第三次操作：在{absi,hansbug}中找出字典序最大的，故为hansbug

第四次操作：在{hansbug,lzn}中找出字典序最大的，故为lzn

第五次操作：在{kkk}中找出字典序最大的，故为kkk

### 数据规模

 ![](https://cdn.luogu.com.cn/upload/pic/2274.png) 


## 样例 #1

### 输入

```
5 5
absi
hansbug
lzn
kkk
yyy
1 5
1 1
1 2
2 3
4 4```

### 输出

```
yyy
absi
hansbug
lzn
kkk
```

# 题解

## 作者：HansBug (赞：33)

用Trie树求出字典序的大小。（逐个插入字符串 ，然后dfs一遍就行了。）


之后查询就是RMQ问题了。


不过由于丧心病狂出题人卡常数，线段树很难过，于是可以用ST算法。


---

## 作者：Dr_殇 (赞：19)

##楼上的题解都好难啊，闪现表示不会。

##题目解析

于是闪现用了一个强势的操作：把字符串排序一遍，并把这个字符串一开始的位置记一下，然后边读边模拟不就行了吗？

让我们对样例这么模拟一遍：

absi 1

hansbug 2

lzn 3

kkk 4

yyy 5

排序后得：

yyy 5

lzn 2

kkk 4

hansbug 2

absi 1


然后读入第一个查找1 5，因为yyy的一开始的位置就已经在这个范围内，直接输出。

再看第二个查找1 1，一直模拟，因为前面所有一开始的位置都不在这个范围内，模拟到最后一个，输出。

后面的也是如此。

##代码如下
```
//--新阶梯工作室防伪水印--
//--By新阶梯工作室 闪现--
#include <ctime>
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>//头文件准备
#define in freopen (".in","r",stdin)
#define out freopen (".out","w",stdout)
#define INF 2147483647
#define UNINF -2147483648ll
#define ch char
#define bo bool
#define ui unsigned int
#define ll long long//闪现为了少打几个字符，弄了好多好多宏定义
using namespace std;

int n,m;
struct Name{
    string c,s;
    int id;
}name[50005];
inline bo cmp(Name x,Name y){
    return x.s>y.s;
}
inline void work();

int main(){
    //in;out;
    work();
    return 0;
}

inline void work(){
	scanf ("%d %d",&n,&m);
    string c1;
    for (int i=1;i<=n;i++){
        cin>>c1;
        int l=sizeof(c1);
        name[i].c=c1;
        for (int j=0;j<l;j++){
            if (c1[j]<='Z'&&c1[j]>='A')c1[j]=c1[j]-'A'+'a';
            else c1[j]=c1[j];
        }
        name[i].s=c1;
        name[i].id=i;
    }
    sort (name+1,name+1+n,cmp);
    for (int i=1,x,y;i<=m;i++){
        scanf ("%d %d",&x,&y);
        int j=1;
        while (1){
            if (name[j].id>=x&&name[j].id<=y)break;
            j++;
        }
        cout<<name[j].c<<endl;
    }
}
```
##珍爱生命，拒绝抄袭

---

## 作者：LightningUZ (赞：11)

没人用ST表啊，ST表会伤心的~

先讲一下ST表是啥。ST表就是用一个st数组，st[i][j]表示从i开始1<<j个元素的最大值。显然，一段区间的最大值=max(该区间的左半部分，该区间的右半部分)，故st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1])

st[i][j-1]就是左半部分，st[i+(1<<(j-1))][j-1]就是右半部分

边界：st[i][0]就是i开始1个元素的最大值。显然，st[i][0]=第i个元素

如何询问最值：见代码注释

代码实现：
```cpp
/*♂*/
#include<bits/stdc++.h>
using namespace std;
int n,m;
void upr(char &x)//将一个字符变大写 
{
	if ('a'<=x and x<='z') x-=32;
}
string mx(string a,string b)
{
	string x=a,y=b;//开副本 
	for(int i=0;i<a.size();i++) upr(x[i]);
	for(int i=0;i<b.size();i++) upr(y[i]);
	return x>y?a:b;
	//注意这里记得:以x,y为比较标准，但返回原串。
	//我在这里错了很door♂次！ 
}
string st[50100][30];
//st数组 
string ask(int l,int r)
{
	int lc=log2(r-l+1);//区间长度求log 
	return mx(st[l][lc],st[r-(1<<lc)+1][lc]);
	//st[l][lc]即为该区间左半部分 
	//st[r-(1<<lc)+1][lc]即为该区间的右半部分 
} 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		char x[20];
		scanf("%s",x);
		st[i][0]=x;
		//边界条件 
	}
	for(int j=1;(1<<j)<=n;j++)
	//注意:一定要j在外面 
	{
		for(int i=1;i+(1<<(j-1))<=n;i++)
		{
			st[i][j]=mx(st[i][j-1],st[i+(1<<(j-1))][j-1]);
			//转移 
		}
	} 
	while(m--)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%s\n",ask(l,r).c_str());
	}
	return 0;
} 
```

---

## 作者：zhengrunzhe (赞：10)

最骚的线段树，真是一股清流

第一次string+cincout被卡的半死

后来cstring(字符数组)+scanfprintf+inline+register+读入优化终于过了

用字符数组的话要注意strcmp和strcpy的使用

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define reg register
#define lson k<<1
#define rson k<<1|1
using namespace std;
const int N=50001,M=300001;
int n,m,i,a,b;
struct tree
{
    int l,r;
    char s[15],ss[15]; //s是转换小写之后的串，ss保存原串 
}t[4*N];  //线段树结构 
inline void read(reg int &x)  //读入优化(虽然并没有什么x用) 
{
    reg int out=0;reg char ch=getchar();
    while (ch<48||ch>57)ch=getchar();
    while (ch>47&&ch<58)
        out=out*10+ch-48,ch=getchar();
    x=out;
}
inline void build(reg int l,reg int r,reg int k)
{
    t[k].l=l;t[k].r=r;
    if (l==r)
    {
        scanf("%s",t[k].s);
        strcpy(t[k].ss,t[k].s);  //把s赋给ss 
        reg int len=strlen(t[k].s);
        for (i=0;i<len;i++)
            t[k].s[i]=tolower(t[k].s[i]);  //转小写比较 
        return;
    }
    reg int mid=(l+r)>>1;
    build(l,mid,lson);
    build(mid+1,r,rson);
    if (strcmp(t[lson].s,t[rson].s)>0) //更新
        strcpy(t[k].s,t[lson].s),strcpy(t[k].ss,t[lson].ss);
    else strcpy(t[k].s,t[rson].s),strcpy(t[k].ss,t[rson].ss);
}
inline int query(reg int l,reg int r,reg int k) //查询 
{
    if (t[k].l>r||t[k].r<l)return 0;
    //如果不属于这个区间就return 0，而t[0].s是"1"，比任何字母的字典序都要小，所以不会取到0 
    if (t[k].l>=l&&t[k].r<=r)return k;
    reg int a=query(l,r,lson),b=query(l,r,rson);
    return strcmp(t[a].s,t[b].s)>0?a:b;
}
int main()
{
    read(n);read(m);
    build(1,n,1);  //建树 
    strcpy(t[0].s,"1");
    for (i=1;i<=m;i++)
        read(a),read(b),printf("%s\n",t[query(a,b,1)].ss);   //记得输出的是原串 
    return 0;
}
```

---

## 作者：ADay (赞：7)

听说这题卡线段树/yiw...吓得我打了个zkw/jk!  


---

首先简单讲一下zkw线段树，这玩意其实就是**非递归的线段树**。

那么怎样做到非递归呢？每次修改/查询自底向上即可。

那么怎样做到自底向上呢？详见往期日报第35期...[link](https://www.luogu.com.cn/blog/82152/Introduction-of-zkwSegmentTree)

---

在这道题中，我们把zkw线段树上的一个节点定义为**其子树中字典序最大的字符串**，就能实现RMQ查询了。

但是要注意一下，题目中的字符串比较方式是$\Huge 不区分大小写的$。把字符串先变成全部小写再比较就可以了qwq。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
#define il inline
#define cs const
#define sta static//常用的def
#define fp(i,x,y) for(rg int i=(x);i<=(y);++i)
#define fd(i,x,y) for(rg int i=(x);i>=(y);--i)
namespace io{sta streambuf *inbuf=cin.rdbuf();sta streambuf *outbuf=cout.rdbuf();char buf[1<<21],*p1=buf,*p2=buf;il char gc(){return (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,1<<21),p1==p2)?EOF:*p1++);}il void pc(char x){outbuf->sputc(x);}il void ps(cs char *x){outbuf->sputn(x,sizeof(x)),pc(10);}il int read(){rg int _s=0,_f=1;rg char _ch=gc();for(;!isdigit(_ch);_ch=gc())if(_ch=='-')_f=-1;for(;isdigit(_ch);_ch=gc())_s=_s*10+_ch-'0';return _s*_f;}il void write(int _x){unsigned int _x1;if(_x<0)putchar('-'),_x1=1u*(-_x);else _x1=_x;sta char _sta[15];int _p=0;do{_sta[_p++]=_x1%10^48;_x1/=10;}while(_x1);while(_p--)pc(_sta[_p]);}string _s;il string reads(){_s.clear();rg char _ch=gc();while(isspace(_ch))_ch=gc();for(;!isspace(_ch);_ch=gc())_s+=_ch;return _s;}il void writes(string _s){if(_s.empty())return;fp(i,0,_s.size()-1)pc(_s[i]);}il void writeln(int _x){write(_x);pc(10);}il void writesp(int _x){write(_x);pc(' ');}}using namespace io;
//快读快写
cs int maxn=5e4+5;
int n,m,q;
string a[maxn<<2];//4倍空间awa
il bool cmp(string x,string y)
{//字符串的比较
    if(x=="")return 0;if(y=="")return 1;
    //特判为空
    fp(i,0,x.size()-1)x[i]=tolower(x[i]);
    fp(i,0,y.size()-1)y[i]=tolower(y[i]);
    //转成小写
    return x>y;//string重载了大于号
}
il string max(string x,string y){return cmp(x,y)?x:y;}//取字符串max
void build()
{//建树
    n=read();q=read();
    for(m=1;m<=n+1;m<<=1)"YOU AK IOI";
    //zkw线段树深度
    fp(i,m+1,m+n)a[i]=reads();//reads为读字符串
    fd(i,m-1,1)a[i]=max(a[i<<1],a[i<<1|1]);
    //每个节点保存最大的
}
il string ask(int s,int t)
{//区间查询
    string res="";
    for(s=m+s-1,t=m+t+1;s^t^1;s>>=1,t>>=1)
    {//自底向上
        if(~s&1)res=max(res,a[s^1]);
        //左指针的父亲的右儿子在查询范围内
        if(t&1)res=max(res,a[t^1]);
        //同理
    }
    return res;
}
int main()
{
    build();
    while(q--)
    {
        int x=read(),y=read();
        writes(ask(x,y)+"\n");
        //别忘了换行哦
    }
    return 0;
}
```

如过还卡不过就开O2吧...[无奈]

---

## 作者：Refined_heart (赞：5)

线段树卡时间过掉了。

正常$string$即可。线段树中维护$string$，不需要什么常数优化。

线段树中要注意，笔者维护了两个值，一个是比较用的$string$，即比较字典序；

另一个需要维护原来的$string$，以便输出。

至于输入输出，笔者就用的$cin,cout$，并没有超时。

注意转小写的函数是$tolower$.

$Code$:

```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
struct node{
	int l,r;
	string maxn,out;
}tr[1200001];
string max(string a,string b){return a>b?a:b;}
string min(string a,string b){return a<b?a:b;}
string ans,kp,Out;
inline void pushup(int x){
	if(tr[x<<1].maxn>tr[x<<1|1].maxn){
		tr[x].maxn=tr[x<<1].maxn;
		tr[x].out=tr[x<<1].out;
	}
	else {
		tr[x].maxn=tr[x<<1|1].maxn;
		tr[x].out=tr[x<<1|1].out;
	}
}
void build(int l,int r,int x){
	tr[x].l=l;
	tr[x].r=r;
	if(l==r){
		cin>>tr[x].maxn;tr[x].out=tr[x].maxn;
		for(int i=0;i<tr[x].maxn.size();++i)tr[x].maxn[i]=tolower(tr[x].maxn[i]);
		ans=min(ans,tr[x].maxn);
		return;
	}
	int mid=l+r>>1;
	build(l,mid,x<<1);
	build(mid+1,r,x<<1|1);
	pushup(x);
}
int n,m;
void query(int l,int r,int x){
	if(tr[x].l>=l&&tr[x].r<=r){
		if(tr[x].maxn>ans){
			ans=tr[x].maxn;
			Out=tr[x].out;
		}
		return;
	}
	int mid=tr[x].l+tr[x].r>>1;
	if(l<=mid)query(l,r,x<<1);
	if(mid<r)query(l,r,x<<1|1);
}
int main(){
	scanf("%d%d",&n,&m);
	build(1,n,1);
	kp=ans;
	for(int i=1,x,y;i<=m;++i){
		ans=kp;
		scanf("%d%d",&x,&y);
		query(x,y,1);
		cout<<Out<<endl;
	}
	return 0;
}
```


---

## 作者：☆木辛土申☆ (赞：3)

题目大意：输出区间字典序最大的字符串，**字典序大小对大小写不敏感，但必须输出原字符串，字典序相同输出靠后的**。

思考：个人觉得就是线段树求区间最值的板子题，难度评定得稍高，按题目要求改一下Max函数即可，详解在代码中。

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<cctype>

const int N=5e4+1;
const int Len=(1<<16);//内存池大小

std::string str[N]={"a"};//string数组，存原来输入的字符串

inline int Max(const int &a,const int &b){
	int len=std::min(str[a].size(),str[b].size());
	for(int i=0;i<len;i++){
		char x=tolower(str[a][i]);
		char y=tolower(str[b][i]);
		if(x!=y) return x>y?a:b;
	}//比较前缀字典序大小
	if(str[a].size()==str[b].size()) return a>b?a:b;//如果字典序相同，输出靠后的
	return str[a].size()>str[b].size()? a:b;//前缀字典序相同，比较字符串长度，长的字典序大
}

struct seg{
	seg *ls,*rs;
	int data;//这里的data指字符串数组的下标
	inline void *operator new(size_t){
		static seg *mempool,*c;
		if(mempool==c)
			mempool=(c=new seg[Len])+Len;
		return c++;
	}//个人比较喜欢指针写法，所以手写了个mempool
	inline void update(){data=Max(ls->data,rs->data);}
	#define mid ((l+r)>>1)
	void build(int l,int r){
		if(l==r){data=l;return;}
		(ls=new seg)->build(l,mid);
		(rs=new seg)->build(mid+1,r);
		update();
	}//标准建树
	int ask(int l,int r,int L,int R){
		int ans=0;
		if(L<=l&&r<=R) return data;
		if(L<=mid) ans=Max(ans,ls->ask(l,mid,L,R));
		if(R>mid) ans=Max(ans,rs->ask(mid+1,r,L,R));
		return ans;
	}//标准求最值
	#undef mid
}*T;//线段树求区间最值的模板，基本无改动，把写好的max套上即可

int main(){
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) std::cin>>str[i];
	(T=new seg)->build(1,n);
	for(int i=1;i<=m;i++){
		int l,r;scanf("%d%d",&l,&r);
		std::cout<<str[T->ask(1,n,l,r)]<<'\n';
	}
	return 0;
}

---

## 作者：有素质的2B铅笔 (赞：3)

Dalao们都在用线段树，本蒟蒻不懂，直接用结构体。

#### 结构体存每个单词的序号（即输入顺序）和单词名，输入完后直接用Sort从大到小排序（要写一个排序函数）。对于每次询问，只需将从大到小排序好的数组从1-n扫一遍，当第一次出现x≤序号≤y时，就停止，并输出该序号对应的单词名。

如果用纯模拟，当x-y区间越大时，程序效率越慢；用这种方法，当x-y区间越大时，程序效率通常越高。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num;
	string name;
}a[50010];//定义结构体
bool cmp (node cmp1,node cmp2)
{
	return cmp1.name>cmp2.name;
}//排序函数
int n,m,x,y;
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>a[i].name;
		a[i].num=i;
	}
	sort(a+1,a+n+1,cmp);
	for (int i=1;i<=m;i++)
	{
		cin>>x>>y;
		for (int j=1;j<=n;j++)
		{
			if (a[j].num>=x && a[j].num<=y)//判断是否在x-y的区间
			{
				cout<<a[j].name<<endl;//输出单词名
				break;//停止，做下一次询问
			}
		}
	}
	return 0;
}
```
### 但是你以为这就完了？

提交上去，爆零，十个点全WA。

然后才注意到题目里有这样一段描述：
```
注意事项：1.该题目单词字典序比对过程中大小写不敏感，但是输出必须输出原单词
```
所以要在结构体中多定义一个字符串，用来存每个单词名的全小写版，输入时将全小写版存入该字符串。

真正的AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int num;
	string name,small;
}a[50010];
bool cmp (node cmp1,node cmp2)
{
	return cmp1.small>cmp2.small;
}
int n,m,x,y;
int main()
{
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>a[i].name;
		a[i].small=a[i].name;
		for (int j=0;j<a[i].name.size();j++)
		{
			if (a[i].name[j]<='Z')
			a[i].small[j]+='a'-'A';
		}
		a[i].num=i;
	}
	sort(a+1,a+n+1,cmp);
	for (int i=1;i<=m;i++)
	{
		cin>>x>>y;
		for (int j=1;j<=n;j++)
		{
			if (a[j].num>=x && a[j].num<=y)
			{
				cout<<a[j].name<<endl;
				break;
			}
		}
	}
	return 0;
}

```





---

## 作者：junior97 (赞：3)

可持久化字典树，每个单词结尾的节点用个vector存下标，查询时在对应的叶子节点vector上二分出$[l,r]$的答案就可以了。
```cpp
# include <bits/stdc++.h>
using namespace std;
const int maxn = 2e6+30;
int cur, cnt=0, tot, len, ans, a[maxn][26], root[maxn], sum[maxn];
vector<int>g[maxn];
char s[maxn][20];
void update(int &x, int pos){
    int id, tmp = x; x = ++cnt;
    for(int i=0; i<26; ++i) a[x][i] = a[tmp][i];
    sum[x] = sum[tmp] + 1;
    g[x] = g[tmp];
    if(pos == len){
        g[x].push_back(cur);
        return;
    }
    if(s[cur][pos] >= 'A' && s[cur][pos] <= 'Z') id = s[cur][pos]-'A';
    else id = s[cur][pos]-'a';
    update(a[x][id], pos+1);

}
void solve(int l, int r){
    ans = r;
    for(int i=25; ~i; --i){
        if(sum[a[r][i]] - sum[a[l][i]] > 0){
            solve(a[l][i], a[r][i]);
            return;
        }
    }
}
int main(){
    int n, m, l, r;
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; ++i){
        scanf("%s",s[i]);
        cur = i;
        len = strlen(s[i]);
        root[i] = root[i-1];
        update(root[i], 0);
    }
    while(m--){
        scanf("%d%d",&l,&r);
        solve(root[l-1], root[r]);
        int x = upper_bound(g[ans].begin(), g[ans].end(), r)-g[ans].begin();
        if(x != 0) --x;
        printf("%s\n",s[g[ans][x]]);
    }
    return 0;
}

```

---

## 作者：Sirius_X (赞：3)

### 前言
这道题我一看就是线段树，于是就把模板打了上去。AC以后看题解，发现很多题解说这题卡线段树，还要有什么特别的优化 ~~但是我瞎写写一次就过了~~
### 思路
#### 用线段树解决区间最值查询问题。
	1. 建树 O(n)
    2. 区间最值查询 O(logn)
    (时间效率应该很快吧)
#### 重点：这里的线段树存的不是字符串，而是它的下标
	1. 创建一个结构体，成员分别是{
    	原始字符串(输出用的),
    	修改后的字符串(因为题目中说不管大小写比较，所以我把统一成大写字符，这样也便于比较字符串的大小）,
    	字符串的长度
       }
       (思路到这就差不多了)
    2. 因为线段树数组里存的是字符串的下标，所以线段树建树，查询时只需要根据下标查找对应的修改后的字符串，再将其比较大小就可以了
    （其实就是把线段树比大小的函数改改）
`````cpp
#include<cstdio>
#include<cstring>
const int N=50010;
struct node{
	char a[20],b[20];//a数组就是原始字符串，b数组就是修改后的字符串
	int len;
}val[N];
int id[4*N];//线段树数组，存的是下标
int n,m;
void read(int &x){//快速读入，但好像并没有什么用，就快了100多ms
	x=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
}
int mn(int x,int y){//普通的min(不是要修改的那个)
	return x<y?x:y;
}
bool check(int x,int y){//比较字符串大小函数
	int l=mn(val[x].len,val[y].len);
	for(int i=1;i<=l;i++){
		if(val[x].b[i]>val[y].b[i]) return 1;
		if(val[x].b[i]<val[y].b[i]) return 0;
	}
	return val[x].len>val[y].len;//如果字符串a的前缀就是字符串b，那么当然a更大了，所以应该输出长度长的
}
int mx(int x,int y){//输出两个字符串中的较大的字符串的下标
	if(check(x,y)) return x;
	return y;
}
void build(int k,int l,int r){//建树
	if(l==r){
		id[k]=l;
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	id[k]=mx(id[k<<1],id[k<<1|1]);//根据左孩子区间和右孩子区间的最大值，来更新父区间的最大值
}
int query(int k,int l,int r,int x,int y){//区间最值查询
	if(y<l||x>r) return 0;
	if(l>=x&&r<=y) return id[k];
	int mid=(l+r)>>1;
	return mx(query(k<<1,l,mid,x,y),query(k<<1|1,mid+1,r,x,y));
}
int main(){
	read(n);read(m);
	for(int i=1;i<=n;i++){//读入
		char c=getchar();
		while(c<'A'||(c>'Z'&&c<'a')||c>'z') c=getchar();
		while((c>='a'&&c<='z')||(c>='A'&&c<='Z')){
			val[i].len++;
			val[i].a[val[i].len]=c;
			if(c>='a'&&c<='z') val[i].b[val[i].len]=c-'a'+'A';//小写变大写
			else val[i].b[val[i].len]=c;
			c=getchar();
		}
	}
	build(1,1,n);
	while(m--){
		int x,y;
		read(x);read(y);
		int flag=query(1,1,n,x,y);
		for(int i=1;i<=val[flag].len;i++)
			printf("%c",val[flag].a[i]);//输出
		printf("\n");
	}
	return 0;
}
`````
本蒟蒻写的题解不多，所以有什么写的不好的地方请指出

---

## 作者：Viston (赞：2)

# 人生苦短，我用map    
话说那些码线段树的都是大佬%%%%%%    
本蒟蒻不会，于是就用了两个map+cincout，开$O_2$才过，但我没优化常数，优化常数的话肯定是能过的。    
为什么用$O_2$?   
map常数贼大.....   
我们用一个map存他的初始位置，一个存更改大小写以后的字符串（然而用结构体肯定更好，然而我懒，就用map了）

```
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d;
string s[50002],s3[50002];
map<string,int>mmp;
map<string ,string>mmq;     //两个map，但实际上你也可以用结构体存改了大写以后的，都差不多
bool cmp(string s1,string s2){return s1>s2;}//反向sort必备
int main(){
	ios::sync_with_stdio(false);
	cin>>a>>b;         //就是喜欢用cin
	for(int i=1;i<=a;i++)
		cin>>s[i],mmp[s[i]]=i;  //存初始位置
	for(int i=1;i<=a;i++){
		string s4=s[i];
		for(int j=0;j<s4.size();j++){
			if(s4[j]>='A'&&s4[j]<='Z')
				s3[i]+='a'+s4[j]-'A'; 
			else s3[i]+=s4[j];
		}
		mmq[s3[i]]=s4;
	}            //更改那些大写的字母
	sort(s3+1,s3+a+1,cmp);
	for(int i=1;i<=b;i++){
		cin>>c>>d;
		for(int j=1;j<=a;j++)
			if(mmp[mmq[s3[j]]]>=c&&mmp[mmq[s3[j]]]<=d){
				cout<<mmq[s3[j]]<<'\n';break;}      //这才是主程序，前面都是预处理
	}
} 
```
人生苦短，我用STl

---

## 作者：手链剖分 (赞：1)

来一发c++题解。

本题是一个RMQ问题，可以用st算法求解。但是用朴素的方法比较两个字符串的大小需要O(n)的时间，最后三个点会TLE。于是我们想到把所有字符串插入到一个trie树里，然后对trie树进行dfs，先遍历到的字符串字典序小。题目说字母大小写不影响字典序的比较，所以在把字符串插入trie树的过程中无视大小写。注意st数组里存的是字符串的编号。具体看代码和注释。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cmath>
using namespace std; 
const int maxn =50003;

struct Trie{
    int nx[28];//当前节点的孩子 
    int num;//当前插入trie树的单词在输入时的编号 
}node[maxn*10];

int tot=0;//tot是trie树节点的编号
int t=0;//t是对trie树进行dfs时的先后顺序，t越大，字典序越大 
int a[maxn];//a[i]存储第i个字符串的字典序大小
int f[maxn][20];//f是st表的递推数组，f[i][j]代表区间i~i+2^j-1内的最值 
char s[maxn][20];//s数组按存储字符串 

//把字母映射为数字，并且同一个字母的大小写对应的数字相同 
int idx(char c)
{
    if(c>='a'&&c<='z') 
        return c-'a';
    else
        return c-'A';
}

//读入优化 
inline int read()
{
    char c=' ';
    while(c<'0'||c>'9') c=getchar();
    int x=0;
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}

//把单词插入trie树 
void insert(int num,char *s)
{
    int u=0;//从根节点开始遍历trie树 
    for(int i=0;s[i]!='\0';i++)
    {
        int x=idx(s[i]);
        if(node[u].nx[x])//如果当前字符代表的结点存在，直接跳到这个结点 
            u=node[u].nx[x];
        else
        {
            node[u].nx[x]=++tot;//否则，创建新结点 
            u=tot;
        }
    }
    node[u].num=num;//在trie树上记录一下当前字符串的编号 
}

//对trie树进行dfs，先搜到的字典序小 
void dfs(int u)
{
    if(node[u].num)//如果该节点对应一个单词，记录一下字典序 
        a[node[u].num]=++t;
    for(int i=0;i<26;i++)
        if(node[u].nx[i])//如果子结点存在，遍历子结点 
            dfs(node[u].nx[i]);
}

int main()
{
    int n,m;
    n=read();m=read();
    for(int i=1;i<=n;i++)
    {
        scanf("%s",s[i]);
        insert(i,s[i]);
    }
    dfs(0);//对trie树进行dfs 
    for(int i=1;i<=n;i++) f[i][0]=i;//st表初始化，注意st表中存的不是字典序大小，而是字符串的编号 
    for(int j=1;(1<<j)<n;j++)//预处理st表 
        for(int i=1;i+(1<<j)-1<=n;i++)
        {
            //找出两个小区间里编号对应字典序较大的一个区间，用它来更新大区间 
            if(a[f[i][j-1]]>a[f[i+(1<<(j-1))][j-1]])
                f[i][j]=f[i][j-1];
            else
                f[i][j]=f[i+(1<<(j-1))][j-1];
        }
    for(int i=1;i<=m;i++)
    {
        int l,r,ans,k=0;
        l=read();r=read();
        //st表查询，找出一个最大的正整数k，使得2^k<=区间长度 
        while((1<<(k+1))<=r-l+1) k++;
        //区间l~l+2^k和区间r-2^k+1~r完整地覆盖了要查询的区间 
        if(a[f[l][k]]>a[f[r-(1<<k)+1][k]])
            ans=f[l][k];
        else
            ans=f[r-(1<<k)+1][k];
        printf("%s\n",s[ans]);//注意ans对应的是字符串编号 
    }
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

这题真棒啊；
好吧直接上代码


------------

```
#include<iostream>
#include<algorithm>
#include<cstring>
#include<iomanip>
#include<stdio.h>
#include<queue>
#include<string>
using namespace std;
struct what{
	char a[16];//原本的字串
	int num;
	char b[16];//全变成小写的字串
}ha[50001];
bool cs(what x,what y){//排序
	for(int i=0;i<16;i++){
		if(x.b[i]>y.b[i]){
			return true;
		}else if(x.b[i]<y.b[i]){
			return false;
		}
	}
}
int main(){
	int n,m;
	cin>>n>>m;
    for(int i=1;i<=n;i++){
    	cin>>ha[i].a;
    	ha[i].num=i;
    	for(int j=0;j<15;j++){//把大写字母变成小写
    		if(ha[i].a[j]>='A'&&ha[i].a[j]<='Z'){
    			ha[i].b[j]=ha[i].a[j]+32;
			}else{
				ha[i].b[j]=ha[i].a[j];
			}
		}
	}
	sort(ha+1,ha+1+n,cs);
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		for(int i=1;i<=n;i++){
			if(ha[i].num>=x&&ha[i].num<=y){//从最大开始，第一个在范围内的ok
				cout<<ha[i].a<<endl;
				break;
			}
		}
	}
	return 0;
}
```


------------


---

## 作者：Na2PtCl6 (赞：0)

## 分析题目

我们发现，这道题是询问区间最大值，于是想到这题可以用线段树解决。我们**在每个节点存一个区间最大值**，就可以把查询的时间复杂度降到O(logn)。

## 注意事项

- 所谓单词的大小，是指把单词大小写统一后的字典序

- 此题常数极大，需要卡常+O2

## 代码部分
### 比较单词"大小"
```cpp
//把一个字串的全部字符变成小写的 
inline void strlower(string &s){ 
	int sz=s.size();
	for(int i=0;i<sz;i++)
		s[i]=tolower(s[i]);
}

//找出小写处理后的字串那个大 
string strmax(const string &a,const string &b){
	string aa=a,bb=b;
	strlower(aa),strlower(bb);
	if(aa>bb)
		return a;
	else
		return b;
}

```

### 建立线段树
```cpp
void build(int l,int r,int node){
	if(l==r){//如果是叶节点，直接赋值 
		tree[node]=s[l];
		return ;
	}
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	build(l,mid,lnode);
	build(mid+1,r,rnode);
	//维护线段树的性质，即区间最大字串 
	tree[node]=strmax(tree[lnode],tree[rnode]);
}
```

### 查询

```cpp
string query(int l,int r,int node){
	//如果现在的区间不在查询范围内，就舍弃该区间 
	if(a>r||b<l) 
		return "";//空串是字典序最小的字串 
	if(l==r||(a<=l&&b>=r))
		return tree[node];
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	//查找最大值 
	string lmax=query(l,mid,lnode);
	string rmax=query(mid+1,r,rnode);
	return strmax(lmax,rmax);
}
```

### 完整代码
```cpp
#include<iostream>
using namespace std;
int n,m,a,b;
string s[50004],tree[200016];

inline int getint(){//快读整数 
	char c=getchar();int a=0;
    for(;c<'0'||c>'9';c=getchar());
    for(;c>='0'&&c<='9';c=getchar())
		a=(a<<1)+(a<<3)+(c^48);
    return a;
}

inline void getstr(string &x){//快读 
	char c=getchar();x="";
	for(;!isupper(c)&&!islower(c);c=getchar());
	for(;isupper(c)||islower(c);c=getchar())
		x.push_back(c);
}

inline void printstr(const string &x){//快速输出 
	int sz=x.size();
	for(int i=0;i<sz;i++)
		putchar(x[i]);
	putchar('\n');
}

//把一个字串的全部字符变成小写的 
inline void strlower(string &s){ 
	int sz=s.size();
	for(int i=0;i<sz;i++)
		s[i]=tolower(s[i]);
}

//找出小写处理后的字串那个大 
string strmax(const string &a,const string &b){
	string aa=a,bb=b;
	strlower(aa),strlower(bb);
	if(aa>bb)
		return a;
	else
		return b;
}

void build(int l,int r,int node){
	if(l==r){//如果是叶节点，直接赋值 
		tree[node]=s[l];
		return ;
	}
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	build(l,mid,lnode);
	build(mid+1,r,rnode);
	//维护线段树的性质，即区间最大字串 
	tree[node]=strmax(tree[lnode],tree[rnode]);
}

string query(int l,int r,int node){
	//如果现在的区间不在查询范围内，就舍弃该区间 
	if(a>r||b<l) 
		return "";//空串是字典序最小的字串 
	if(l==r||(a<=l&&b>=r))
		return tree[node];
	int mid=(l+r)>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	//查找最大值 
	string lmax=query(l,mid,lnode);
	string rmax=query(mid+1,r,rnode);
	return strmax(lmax,rmax);
}

int main(){
	n=getint(),m=getint();
	for(int i=0;i<n;i++)
		getstr(s[i]);
	build(0,n-1,0);
	while(m--){
		a=getint(),b=getint();
		--a,--b;
		printstr(query(0,n-1,0));
	}
	return 0;
}
```

### 拓展

如果要修改某个位置的单词，该怎么做呢？

```cpp
void update(int l,int r,int node,int ind,string v){
	if(l==r){
		s[ind]=v;
		tree[node]=v;
		return ;
	}
	int mid=l+r>>1;
	int lnode=(node<<1)+1;
	int rnode=(node<<1)+2;
	if(ind>=l&&ind<=mid)//如果在左边，向左分支搜索 
		update(l,mid,lnode,ind,v);
	else//在右边，向右分支搜索 
		update(mid+1,r,rnode,ind,v);
	tree[node]=strmax(tree[lnode],tree[rnode]);//重新维护 
}
```

**感谢您的仔细观看**


---

## 作者：Hexarhy (赞：0)

简单但是考细节的数据结构题。

---------

### 解题思路

对于**区间最大值**，我们可以用线段树维护，也可以用 RMQ。本题采用线段树。

如果是线段树，就是纯粹的不带修改的模板。

唯一的重点在于如何**将字符串映射为对应权值**。

#### 方法一

不难想到，排序字符串后，它的下标就是对应权值了。

于是将字符串用数组`s`保存起来，并备份一个`ts`。将`ts`排序，并逐个把字符串和下标存入`unordered_map`。（`map`慢了，`unordered_map`是 hash 实现的）

但是要开两个`unordered_map`，一个把`string`转为`int`，另一个在输出的时候要把`int`转为`string`。

建树的时候，就可以直接调用`unordered_map[s[i]]`了。输出同理。

至于为什么要用两个字符串数组，原因很简单，我们不能改变原序列的顺序。这会影响建树。

注意，由于大小写不敏感，我们需要重写`cmp()`而不是把`ts`转为统一大小写字母。对应到`unordered_map`里是错误的。可以参考如下代码：

```cpp
bool cmp(const string x,const string  y)
{
	const int len=min(x.size(),y.size());
	for(int i=0;i<len;i++)
	 if(tolower(x[i])!=tolower(y[i]))
	  return tolower(x[i])<tolower(y[i]);
	return x.size()<y.size();
}
```

`cmp()`里，字符串长度很小，可以看做 $O(1)$，所以这一部分时间复杂度为 $O(n\log n)$。

#### 方法二

一想到映射，总会有人想到 hash。于是你就可以使用 hash，得到每一个字符串的权值。利用这张 hash 表，也可以轻松完成。

时间上常数比方法一小，但是写起来不熟练的容易有 bug。

#### 方法三

出题人 Hansbug 的正解做法。

建一个字典树 Trie，并在树上 dfs 确定字典序。

这个时候如果字符串很长的话，方法一二就不适用了，只能用此方法。当然代码难度会加大。

### 实现细节

- **大小写不敏感。**

- 不要使用较慢的输入方式。

- 不要直接在线段树中存`string`。速度会很慢，常数大大增加直接 TLE。

- 检查数组和线段树开够了没有。

### 参考代码

下面代码使用了线段树和方法一。时间复杂度 $O(n\log n)$。

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<iostream>
#include<cctype>
#include<unordered_map>
using namespace std;

typedef const int cint;
cint MAXN=5e4+5;
int n,m;
string s[MAXN],ts[MAXN];//字符串数组
unordered_map<string,int> tmp; 
unordered_map<int,string> ans;
struct node
{
	int l,r,val;//val不要存字符串，实践证明相当慢
}tree[MAXN<<2];

void build(cint now,cint l,cint r)//模板
{
	tree[now].l=l;tree[now].r=r;
	if(l==r)
	{
		tree[now].val=tmp[s[l]];//是s而非ts
		return;
	}
	cint mid=(l+r)>>1,lson=now<<1,rson=now<<1|1;
	build(lson,l,mid);
	build(rson,mid+1,r);
	tree[now].val=max(tree[lson].val,tree[rson].val);
}

int query(cint now,cint l,cint r)//模板
{
	if(l<=tree[now].l && tree[now].r<=r)
	 return tree[now].val;
	int ans=0;
	cint mid=(tree[now].l+tree[now].r)>>1,lson=now<<1,rson=now<<1|1;
	if(l<=mid)	ans=max(ans,query(lson,l,r));
	if(mid<r)	ans=max(ans,query(rson,l,r));
	return ans;
}

bool cmp(const string x,const string  y)//大小写不敏感的排序
{
	const int len=min(x.size(),y.size());
	for(int i=0;i<len;i++)
	 if(tolower(x[i])!=tolower(y[i]))
	  return tolower(x[i])<tolower(y[i]);
	return x.size()<y.size();
}

int main()
{
	ios_base::sync_with_stdio(false);//关闭同步，加速cin读入
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	 cin>>s[i];
	for(int i=1;i<=n;i++)
	 ts[i]=s[i];//备份
	sort(ts+1,ts+1+n,cmp);
	for(int i=1;i<=n;i++)
	{
		tmp.insert(make_pair(ts[i],i));//字符串转数字
		ans.insert(make_pair(i,ts[i]));//数字转字符串
	}
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int l,r;cin>>l>>r;
		cout<<ans[query(1,l,r)]<<endl;
	}
	return 0;
}
```

---

## 作者：Lates (赞：0)

## 这题我首先想到把字符串离散化成区间$[1,n]$的整数，然后放进线段树里做区间最值就好了。

- 唯一一个我被坑的点，就是我把字典序理解错了，是忽略大小写再排序(如果有解释错误麻烦dalao更正)，结果就cmp函数就直接排序了，导致交了几遍才过。

所以，读题很关键！！！

有不会线段树的同学可以去自学一下QAQ。

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string.h>
using namespace std;
inline int read(){
	register int x=0,v=1,ch=getchar();
	while(!isdigit(ch)){if(ch=='-')v=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^'0');ch=getchar();}
	return x*v;
}
const int MAX=50005;
int n,m,op[MAX];
struct Node{
	string s;
	int p,t;//分别表示原来的位置和字典序排名
}a[MAX];

//两个cmp过程，第一个是获取字典序的排名，第二个是将序列还原

inline bool cmp(Node x,Node y){return x.s<y.s;}
inline bool comp(Node x,Node y){return x.p<y.p;}

int tree[MAX<<2];
inline int Max(int a,int b){
	return a>b?a:b;
}

//以下至58行是线段树的过程

inline void pushup(int x){
	tree[x]=Max(tree[x<<1],tree[x<<1|1]);
}
void build(int x,int l,int r){
	if(l==r){
		tree[x]=a[l].t;
		return ;
	}
	register int mid=l+r>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	pushup(x);
}
int query(int x,int l,int r,int s,int t){
	if(s<=l&&r<=t)return tree[x];
	register int mid=l+r>>1,res=-0x7fffffff;
	if(s<=mid)res=Max(res,query(x<<1,l,mid,s,t));
	if(mid<t)res=Max(res,query(x<<1|1,mid+1,r,s,t));
	return res;
}
int l,r;
string c[MAX];
int main(){
	n=read();m=read();
	for(register int i=1;i<=n;++i){
		cin>>a[i].s;
		c[i]=a[i].s;
		a[i].p=i;	
	}
	for(register int i=1;i<=n;++i){//字典序大小转换
		for(register int j=0;j<a[i].s.length();++j){
			if('a'<=a[i].s[j]&&a[i].s[j]<='z')a[i].s[j]-=32;
		}
	}
	sort(a+1,a+1+n,cmp);
	for(register int i=1;i<=n;++i)a[i].t=i;
	sort(a+1,a+1+n,comp);
	for(register int i=1;i<=n;++i)op[a[i].t]=i,a[i].s=c[i];
   //op将查询到的最大排名映射回原来的查询字符串，c用于将a的字符串还原
	build(1,1,n);
	while(m--){
		l=read(),r=read();
		printf("%s\n",a[op[query(1,1,n,l,r)]].s.c_str());//输出字符串
	}
	return 0;
}

```



---

## 作者：YZL11111 (赞：0)

题目链接：https://www.luogu.com.cn/problem/P2412

## 【题目背景】
滚粗了的HansBug在收拾旧英语书，然而他发现了什么奇妙的东西。

## 【题目描述】
#udp2.T3如果遇到相同的字符串，输出后面的

蒟蒻HansBug在一本英语书里面找到了一个单词表，包含N个单词（每个单词内包含大小写字母）。现在他想要找出某一段连续的单词内字典序最大的单词。

## 【输入格式】
第一行包含两个正整数N、M，分别表示单词个数和询问个数。

接下来N行每行包含一个字符串，仅包含大小写字母，长度不超过15，表示一个单词。

再接下来M行每行包含两个整数x、y，表示求从第x到第y个单词中字典序最大的单词。

## 【输出格式】
输出包含M行，每行为一个字符串，分别依次对应前面M个询问的结果。

## 【解题思路】
线段树+各路优化。。。。。

记得看清题目，不区分大小写，但是要输出原字符串

## 【AC代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
#define min(a , b) (a) < (b) ? (a) : (b)  //宏定义优化
struct Tree
{
	int l, r;
	string s;
}tree[2000010];
inline int read()  //读入优化
{
	register int X = 0, w = 0; register char ch = 0;
	while (!isdigit(ch)) { w |= ch == '-'; ch = getchar(); }
	while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
	return w ? -X : X;
}
inline bool operator > (register const string& a, register const string& b)  //重载字符串比较函数，register+inline优化
{
	register int la = a.length();
	register int lb = b.length();
	register int l = min(la, lb);
	for (register int i = 0; i < l; ++i)
	{
		register char c = tolower(a[i]);
		register char d = tolower(b[i]);
		if (c == d) continue;
		return c > d;
	}
	return la > lb;
}
inline void build(register int root, register int l, register int r)  //建树
{
	tree[root].l = l;
	tree[root].r = r;
	if (l == r)
	{
		cin >> tree[root].s;
		return;
	}
	register int mid = (l + r) >> 1;
	build(root << 1, l, mid);
	build(root << 1 | 1, mid + 1, r);
	if (tree[root << 1].s > tree[root << 1 | 1].s) tree[root].s = tree[root << 1].s;
	else tree[root].s = tree[root << 1 | 1].s;
}
inline int query(register int root, register int l, register int r) //查询，注意，此处与传统线段树不同，我们返回的是节点下标，如果直接返回字符串会超时，神仙优化都救不了。。
{
	if (l <= tree[root].l && tree[root].r <= r) return root;
	register int mid = (tree[root].l + tree[root].r) >> 1;
	if (mid >= r) return query(root << 1, l, r);
	else if(mid < l) return query(root << 1 | 1, l, r);
	else
	{
		register int a = 0, b = 0;
		a = query(root << 1, l, mid);
		b = query(root << 1 | 1, mid + 1, r);
		return tree[a].s > tree[b].s ? a : b;
	}
}
int main()
{
	register int l, r, n, m;
	n = read(), m = read();
	build(1, 1, n);
	while (m--)
	{
		l = read(), r = read();
		cout << tree[query(1, l, r)].s << endl;
	}
	return 0;
}
```

---

## 作者：zhanghb (赞：0)

这道题我们可以直接把输入的时候把单词统一转换成小写形式，方便排序。

后面的排序就简单极了，因为在C++中的快排函数sort可以直接坐到把单词按照字典序排序。

当然，在使用前，别忘了加头文件
```
#include<algorithm>
```
附AC代码（可能有点麻烦，这道题应该可以输入一组数据，输出一组，但是保险起见，我还是把它们都存起来一起输出了，但是影响不大）

---------------------------------------
```
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct word//定义结构体
{
	int bh;//储存编号
	char zd[16];//储存处理后的小写单词，用于比较
	char b[16];//储存原单词
}jg[50005];
int cmp(struct word a,struct word b)//定义快排规则
{
	for(int i=0;i<15;i++)
	  if(a.zd[i]>b.zd[i])
		return 1;
	  else if(a.zd[i]<b.zd[i]) return 0;
}
string bb[300002];
int main()
{
	int i,n,m,x,y,j,k;
	cin>>n>>m;//输入个数
	for(i=1;i<=n;i++)
	{
		cin>>jg[i].b;//输入原单词
		j=0;
		while(j<strlen(jg[i].b))//把原单词大小写转换
		{
			if(jg[i].b[j]>='A'&&jg[i].b[j]<='Z')
			  jg[i].zd[j]=jg[i].b[j]+32;
			else jg[i].zd[j]=jg[i].b[j];
			j++;
		}
		jg[i].bh=i;//储存单词编号
	}
	sort(jg+1,jg+n+1,cmp);//根据快排规则排序结构体
	k=1;
	for(i=1;i<=m;i++)
	{
		cin>>x>>y;//输入需要寻找的编号范围
		for(j=1;j<=n;j++)
			if(jg[j].bh>=x&&jg[j].bh<=y)//从字典序最大的开始寻找，一旦编号在范围内就储存
			{	
				bb[k++]=jg[j].b;
				break;
			}
	}
	for(i=1;i<k;i++)
	  cout<<bb[i]<<endl;//输出最后的结果
}
```


---

## 作者：qq907232781 (赞：0)

这题首先线段树你不优化到极限应该是过不了的，反正我是没优化线段树AC的水平；

我们发现只需要区间字符串最大最小值即可，且询问次数极多，所以有更快的ST算法。（不会的出门左转百度，很简单的）；

接下来我们只需处理出我们所需要的数组来回答询问就好了，这个复杂度是线段树不能比的。

好接下来就是是否TLE 与 MLE 的关键了，首先求解ST时数组可以记录字串编号来压缩空间。

同时还需要两个数组分别存储原字串与大写转换过的字串;(千万别在比较时转换，一定要直接比较转换过的，输出原串，upcase真的超耗时的，TLE了别说我没告诉你)；

下面附代码：


```cpp
var
        g,o:array[1..50000] of string;
        f:array[1..50000,0..15] of longint;
        p:array[0..15] of longint;
    n,m,a,b,i,t,j:longint;
function min(a,b:longint):longint;
begin
        if a>b then exit(b) else exit(a);
end;
function max(a,b:longint):longint;
var
        i:longint;
begin
        for i:=1 to min(length(o[a]),length(o[b])) do
                if o[a][i]>o[b][i] then exit(a)
                else if o[a][i]<o[b][i] then exit(b);
        if length(o[a])>length(o[b]) then exit(a)
        else exit(b);
end;
function get(x:longint):longint;
var
    i:longint;
begin
    for i:=15 downto 0 do
        if x>=p[i] then exit(i);
end;
begin
         readln(n,m);
        for i:=1 to n do
        begin
               readln(g[i]);
               o[i]:=upcase(g[i]);
        end;
        for i:=1 to n do
                f[i,0]:=i;
        p[0]:=1;
        for i:=1 to 15 do
                p[i]:=p[i-1] shl 1;
        for j:=1 to 15 do
            for i:=1 to n do
                if (i+p[j-1]<=n) then f[i,j]:=max(f[i,j-1],f[i+p[j-1],j-1])
                else f[i,j]:=f[i,j-1];
        for i:=1 to m do
        begin
                readln(a,b);
                t:=get(b-a+1);
                writeln(g[max(f[a,t],f[b-p[t]+1,t])]);
        end;
end.

```

---

## 作者：kczno1 (赞：0)

自创的st优化，用记忆化搜索，不进行预处理，只处理对于询问所需的

（虽然最差情况下是一样的）








```cpp
const p=50000;
var
 n,m,i,l,j,x,y:longint;
 f:array[1..p,0..16]of longint;//f[i,j]记录i开始的2^j个中的max
 b:array[1..p,0..16]of boolean;//处理过则标记为true
 a,dy:array[1..p] of string;
function max(x,y:longint):longint;//比较x,,y位置的字符串
begin
 if dy[x]>dy[y] then exit(x);
 exit(y);
end;
procedure try(x,y:longint);
var l:longint;
begin
 if b[x,y] then exit;b[x,y]:=true;
 l:=x+1<<(y-1);
 try(x,y-1);try(l,y-1);
 f[x,y]:=max(f[x,y-1],f[l,y-1]);
end;
begin
 readln(n,m);
 for i:=1 to n do readln(a[i]);
 for i:=1 to n do
 begin
  dy[i]:=upcase(a[i]);
  f[i,0]:=i;
  b[i,0]:=true;
 end;
 for i:=1 to m do
 begin
  read(x,y);
  j:=0;l:=1;
  while (l<<1)<y-x+1 do
  begin
   l:=l<<1;
   inc(j);
  end;
  try(x,j); try(y-l+1,j);
  writeln( a[max(f[x,j],f[y-l+1,j])] );
 end;
end.

```

---


# [SDOI2005] 区间

## 题目描述

现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \le i \le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \le b < c \le d$。

请写一个程序：

读入这些区间；

计算满足给定条件的不相交闭区间；

把这些区间按照升序输出。

## 说明/提示

对于 $100 \%$ 的数据，$3 \le n \le 50000$，$1 \le a _ i \leq b _ i \le 1000000$。

## 样例 #1

### 输入

```
5
5 6
1 4
10 10
6 9
8 10
```

### 输出

```
1 4
5 10
```

# 题解

## 作者：蹲在丛中笑 (赞：79)

震惊地发现竟然还没有人贴差分的题解。。

没错，就像楼下某位大佬说的，每次输入x和y，于是x的度++，y的度--

然后再扫一遍，累积从0到+的就是左端点，从+到0的就是右端点。

时间复杂度O（1e6）

貌似不是很优越？

总之代码很短很好写

```cpp
#include<stdio.h>
#define N 1000005
int n,x,y,cnt,a[N],b[N];
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        scanf("%d%d",&x,&y);
        a[x]++; b[y]++;
    }
    for(int i=1;i<N;i++) {
        if(!cnt&&a[i]) printf("%d ",i);
        cnt+=a[i]-b[i];
        if(!cnt&&b[i]) printf("%d\n",i);
    }
}
```

---

## 作者：NF_水饺 (赞：21)

很荣幸被dalao邀请来做这道~~省选~~题

区间并问题，想到了之前看过的一道模板题，题意大概是：
给定若干个闭区间，求最少多少个闭区间能够刚好囊括所有给出的闭区间

跟这题真的是像得不能再像了

思路大致是：先把所有区间按起点排序，然后将最左边的区间的两端设为答案区间的两端。接下来顺次查找剩下的区间，如果 **答案区间** 的右端小于当前查找到的区间的左端，输出区间，并将区间的左右值替换为当前查找区间的左右值。否则，更新答案区间右端

虽然是模板贪心，还是有几点需要强调的：

1.答案区间加粗，是因为这里不能设为上一个区间右端（亲测爆0）。

2.更新答案区间最右端，不要直接更新，而是要取一个最大值（二次爆0）。

3.最后的最后，在退出查找前，输出一次区间左右端（WA1个点）。

1、2点有时候可以实测，3点想必刷扫描/查找题的都应该有感触吧。。。

不多说，贴上代码：


```
#include<iostream>
#include<algorithm>
using namespace std;
int n,st,ov;
struct node //结构体存区间 
{
	int lo,hi;
}a[50000+10];
bool cmp(node a,node b) //排序 
{
	return a.lo<b.lo;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].lo>>a[i].hi;
	sort(a+1,a+n+1,cmp);
	st=a[1].lo;
	ov=a[1].hi; //答案区间初始化 
	for(int i=2;i<=n;i++)
	{
		if(a[i].lo>ov) //开新区间 
		{
			cout<<st<<" "<<ov<<endl;
			st=a[i].lo;
			ov=max(ov,a[i].hi);
		}
		else ov=max(ov,a[i].hi); //扩展原有区间 
		if(i==n) cout<<st<<" "<<ov<<endl; //注意点3 
	}
	return 0;
 } 

```

感觉是老题了

~~不是很难啊还是蛮水的~~

虽然还是WA了3次







---

## 作者：DDOSvoid (赞：9)

这个题实际上就是求是区间并，然后输出

发现题解里没有人用并查集啊（应该是没有人用吧

那么直接用并查集就好了啊

不过需要特判一下单点，而且复杂度跟区间长度有关

```cpp
#include<iostream>
#include<cstdio>
#define maxn 50010
#define maxm 1000010
using namespace std;

int n;

struct node{
	int x, y;	
}a[maxn];

int fa[maxm], Max, Min = maxm; bool vis[maxm];
int find(int x){return x == fa[x] ? x : fa[x] = find(fa[x]);}

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i){
		scanf("%d%d", &a[i].x, &a[i].y);
		Max = max(Max, a[i].y);
		Min = min(Min, a[i].x);
	}
	for(int i = Min; i <= Max; ++i) fa[i] = i;
	for(int i = 1; i <= n; ++i){
		int x = a[i].x, y = a[i].y; 
		if(x == y) vis[x] = 1;
		x = find(x);
		while(x < y) x = fa[x] = find(x + 1);
	}
	for(int i = Min; i <= Max; ++i) find(i);
	int i = Min;
	while(i <= Max){
		if(fa[i] == i){
			if(vis[i]) printf("%d %d\n", i, i);
			++i;
		}
		else printf("%d %d\n", i, fa[i]), i = fa[i] + 1; 	
	}
	return 0;
}

```

---

## 作者：一中益达 (赞：7)

差分可AC。

设一个二维数组a[1000001][2];

第二维【0】存加（区间左端点）
【1】存减（区间右端点）

对于普通差分不能解决上一区间右端点+1=下一区间左端点的情况

这里我们分开考虑

对于每一个位点K，我们先sum+=a[k][1];

也就是先把这一位点已经结束的区间减去;

设cnt表示现在扫过的区间长度

如果发现cnt!=0&&sum==0表示上一区间已结束，
直接输出K-cnt，K-1即可

顺便cnt=0；

处理完这个，再sum+=a[k][0];

if(sum) cnt++;

这样就完美处理了覆盖问题。

下面奉上代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int sum[1010101][2];
int cnt;
int sumx;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		sum[x][0]++;
		sum[y+1][1]++;//这里用了正，也无伤大雅
	}
	for(int i=1;i<=1000001;i++)
	{
		sumx-=sum[i][1];
		if(cnt&&!sumx)
		{
			printf("%d %d\n",i-cnt,i-1);
			cnt=0;
		}
		sumx+=sum[i][0];
		if(sumx) cnt++;
	}
	return 0;
}
```

  

---

## 作者：Apro1066 (赞：6)

题解中大佬也说了：本题要求求出给定区间并集中的互不相交区间。

贪心做法很容易想到，这里简单说一下并查集的做法。由于我们有查找2个区间是不是有交集以及要有合并区间的操作，所以我们不妨可以像并查集那样做。

贪心：
```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;
typedef struct
{
	int l,r;
}lxydl;
lxydl a[50001];
int n,start,end,s;
inline bool cmp(lxydl a,lxydl b)
{
	return a.l<b.l;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register int i,j;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i].l>>a[i].r;
	}
	sort(a+1,a+n+1,cmp);//按左区间从大到小排序 
	start=a[1].l,end=a[1].r;
	for(i=2;i<=n;i++)
	{
		if(a[i].l<=end)//如果当前区间的左端点 在选定区间的右端点之内 
		{
			end=max(end,a[i].r);//合并区间 
		}
		else//反之就是找到一个新区间 
		{
			cout<<start<<' '<<end<<endl;
			start=a[i].l;//更改 
			end=a[i].r;
		}
	}
	cout<<start<<' '<<end<<endl;//最后一次必然没有找到，所以要在输出一次。 
	return 0;
}
```
并查集：
```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;
int f[100001],n,s;
typedef struct
{
	int l,r;
}lxydl;
lxydl a[50001];
inline bool cmp(lxydl a,lxydl b)
{
	return a.l<b.l;
}
int getfind(int v)//找祖先，父亲是最先出现的区间编号 
{
	if(f[v]==v)
	{
		return v;
	}
	else
	{
		f[v]=getfind(f[v]);
		return f[v];
	}
}
inline void merge(int v,int u)//合并 
{
	register int t1,t2;
	t1=getfind(v);
	t2=getfind(u);
	if(t1!=t2)
	{
		f[t2]=t1;
	}
	if(a[u].r<a[v].r)
	{
		a[u].r=a[v].r;//注意2个右区间要相同 
	}
	return;
}
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	register int i,j;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		f[i]=i;//预处理 
		cin>>a[i].l>>a[i].r;
	}
	sort(a+1,a+n+1,cmp);//按左区间从大到小排序 
	for(i=1;i<n;i++)
	{
		if(a[i+1].l<=a[i].r)//如果区间重合 
		{
			merge(i,i+1);//把这2个区间合并 
		}
	}
	int cnt(-999999);
	for(i=1;i<=n;i++)
	{
		if(cnt!=f[i])//如果发现新区间 
		{
			cout<<a[i].l<<' ';
			cnt=f[i];
		}
		if(cnt!=f[i+1])//若下个区间不和它重合 
		{
			cout<<a[i].r<<endl;
		}
	}
	return 0;
}
```

---

## 作者：顾z (赞：4)

**题目描述**

给定n个区间,求满足给定条件的不相交闭区间。

条件：两个区间[a, b]和[c, d]是按照升序排列的，那么我们有a<=b<c<=d。

## 广告 [安利博客](https://87960.blog.luogu.org/#)

**分析：**

~~题目不用概括了吧...~~

所以说,我们可以将区间按照升序排序,然后更新区间左右端点,左端点取最靠左的,右端点取最靠右的。

至于为什么是正确的？~~(尝试说一下~~

我们去将相交区间合并,因为这样我们可以得到相交区间所覆盖最大的区间,而这样,如果我们枚举过程中遇到一个区间的左端点大于当前区间的右端点,我们就可以输出当前的区间,然后更新左右端点,继续去求下一个满足条件的区间。

然后根据这种思想去实现即可.

记得输出最后一次的答案.

-----------------------代码------------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
IL void read(int &x)
{
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n;
struct cod{int l,r;}qujian[50008];//区间
IL bool ccp(const cod&a,const cod&b){return a.l<b.l;}
int main()
{
	read(n);
	for(RI i=1;i<=n;i++)
		read(qujian[i].l),read(qujian[i].r);
	std::sort(qujian+1,qujian+n+1,ccp);
	int le=qujian[1].l,re=qujian[1].r;
	for(RI i=2;i<=n;i++)
	{
		if(re<qujian[i].l)
		{
			printf("%d %d\n",le,re);
			le=qujian[i].l;
		}
		le=std::min(le,qujian[i].l);
		re=std::max(qujian[i].r,re);
	}
	printf("%d %d\n",le,re);
}
```

---

## 作者：Jelly_Goat (赞：3)

想要更好的体验请戳[这里](https://jelly-goat.gitee.io/2019/07/22/%E9%A2%98%E8%A7%A3-P2434-%E3%80%90-SDOI2005-%E5%8C%BA%E9%97%B4%E3%80%91/)
### 核心：栈
这个题就是[区间覆盖（加强版）](https://www.luogu.org/problemnew/show/P2082)的输出数据类型嘛！  
直接括号法！（看题解区中也没有说明白）  
（~~两眼放光双倍经验~~）  

----------

### 简单概括证明：
首先我们将**区间左右端点看做是一对左右括号**  
由于我们求的是并集，所以内部的一对括号匹配不影响最终答案  
反而是排除了更差的解  
因此就变成了**括号匹配问题**  
即求一些括号**最外层的左右位置**  

-------

### 算法流程：
括号匹配那当然是直接上**栈**这个好东西  
当输入的是左括号，直接压进去  
否则就弹出内部的左括号  
如果弹出之后没有多余的左括号了，证明这个是最左端的左括号  
输出这个左括号和要匹配的右括号即可  

--------

时间复杂度是$O(n\cdot logn)$（瓶颈是排序），还是跑的比较快的  
~~我love STL~~  
### Code
```cpp
#include <iostream>
#include <utility>
#include <algorithm>
#include <cstdio>
#include <stack>

using namespace std;
struct node
{
	long long pos;
	char ch;
	inline bool friend operator<(const node &a, const node &b)
	{
		return make_pair(a.pos, a.ch) < make_pair(b.pos, b.ch);
		//鍊熷姪STL_pair鏉ユ帓搴?
	}
} kh[100011 << 1];
int n;
long long ans;
stack<long long> s;

int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	for (register int i = 1; i <= n; i++)
	{
		cin >> kh[i].pos >> kh[i + n].pos;
		kh[i].ch = '(';		//宸︽嫭鍙?
		kh[i + n].ch = ')'; //鍙虫嫭鍙?
	}
	sort(kh + 1, kh + (n << 1) + 1);
	for (register int i = 1; i <= (n << 1); i++)
	{
		if (kh[i].ch == '(')
			s.push(kh[i].pos);
		if (kh[i].ch == ')')
		{
			int left = s.top();
			s.pop();
			if (s.empty())
				cout << left << ' ' << kh[i].pos << endl;
		}
	}
	return 0;
}
```

---

## 作者：尤安 (赞：3)

乍一看这题貌似很难，但实际上这儿有一个神奇的等价关系

有若干个区间，将他们的左端点和右端点分别排序，他们的互相关系是不变的。

这样一看这简直就是一道水题......

代码很简单，32行（其实还能更短）

```cpp
#include<algorithm>
#include<vector>
#include<iostream>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    int be=0,en=0;
    vector<int>c;
    vector<int>d;
    int n,a,b;
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a>>b;
        c.push_back(a);
        d.push_back(b);
    }
    make_heap(c.begin(),c.end());
    sort_heap(c.begin(),c.end());
    make_heap(d.begin(),d.end());
    sort_heap(d.begin(),d.end());
    for(int i=0;i<n;i++)
     if(d[i]>=c[i+1]&&i+1<n)
        en++;
     else
     {
        cout<<c[be]<<" "<<d[en]<<endl;
        be=i+1;
        en=be;
     }
}
```

---

## 作者：Conical (赞：3)

这题有那么难吗？？？【黑人问号脸】

此题并不需要线段树这类的数据结构啊

审清题意，这题就是让我们求出给定区间并集中的互不相交区间

很容易想到，对所有区间按左端点进行排序，然后。。。

然后直接做啊！找断点不是很容易的吗。。。

这个故事告诉我们，就算学习了高深一点的算法和数据结构，那些基础和最实用的东西也千万千万不能忘掉。

上代码

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
using namespace std;
const int MaxN(50005);
struct Node
{
    int l,r;
}a[MaxN];
inline bool Cmp(Node x,Node y)
{
    return x.l<y.l;
}
int main()
{
    int N,i,L,R;
    scanf("%d",&N);
    for(i=1;i<=N;i++)
        scanf("%d%d",&a[i].l,&a[i].r);
    sort(a+1,a+1+N,Cmp);
    L=a[1].l;
    R=a[1].r;
    for(i=2;i<=N;i++)
        if(a[i].l<=R)
            R=max(R,a[i].r);
        else
        {
            printf("%d %d\n",L,R);
            L=a[i].l;
            R=a[i].r;
        }
    printf("%d %d\n",L,R);
    return 0;
}
```

---

## 作者：waOooo (赞：2)

看题解如果是区间贪心的话，都是以左端点为第一关键字由小到大排，其实右端点为第一关键字也可以写，但是必须是由大到小排；

具体看代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pa pair<int,int>
#define ls k<<1
#define rs k<<1|1
#define inf 0x3f3f3f3f
using namespace std;
const int N=100100;
const int M=50100;
const int mod=1e9;
struct Node{
	int l,r;
}qu[N]; 
bool cmp(Node p,Node q){
	if(p.r==q.r) return p.l>q.l;
	return p.r>q.r;
}
vector<pa>ans;
int main(){
	int n;cin>>n;
	for(int i=1;i<=n;i++) cin>>qu[i].l>>qu[i].r;
	sort(qu+1,qu+n+1,cmp);
	int L=qu[1].l,R=qu[1].r;
	for(int i=2;i<=n;i++){
		if(qu[i].r<L){
//			cout<<L<<" "<<R<<endl;
			ans.push_back(pa(L,R));
			L=qu[i].l,R=qu[i].r;
		}
		else L=min(L,qu[i].l);
	}
//	cout<<L<<" "<<R<<endl;
	ans.push_back(pa(L,R));
	sort(ans.begin(),ans.end());
	for(int i=0;i<ans.size();i++) cout<<ans[i].first<<" "<<ans[i].second<<endl;
	return 0;
}

```


---

## 作者：Na2PtCl6 (赞：2)

这题和
[P2082](https://www.luogu.com.cn/problem/P2082)
非常的像，只是我们要输出的是那不相交区间的两端

## 题意简述
在一条无限长的直线上，有一些线段，这些线段的两头都用整数表示。现在，要你求这些线段覆盖的总长。

## 分析题目

不难发现，题意中，线段的位置关系有3种

**1.一条线段在另一条内部，称为重合**

**2.一条线段和另一条有接触的部分，但不完全重合，这种情况简称相接**

**3.一条线段和另一条完全没有接触部分，称为相隔**

（以上并非标准术语，本人瞎编的）

于是可以得出：

**当我们发现两条线段重合时，舍去较短的一条**

**如果发现有相接的线段，我们就锁定相接的线段中较靠右的一条，寻找与之相接的线段，一直下循环去**

**如果发现没有与当前线段相接的线段，就输出目前找到的线段的前端和后端，因为这条线段已经到头了**

有了这些，我们就可以用以下步骤，AC本题了。

**1.对线段进行排序（第一关键字为前端，第二关键字为后端）**

**2.对于重合的线段，把较小的那条舍去**

**3.O(n)的遍历，连接相接的线段，找出每条不相交的线段**

## 代码
### 去掉重合线段
```cpp
//先让第一段线段进入最终遍历的数组，排序保证了此操作的正确性 
	v.push_back(list[0]);
	for(int i=1;i<n;i++){
		//判断这条线段是否与前面一条重合 
		if(v.back().begin<=list[i].begin&&
		v.back().end>=list[i].end)
			continue;
		v.push_back(list[i]);
	}
```

### 遍历数组找出所有线段
```cpp
int sz=v.size();
	int i=0,j=0;
	//i是要连在一起的线段的起始线段,j是结尾线段 
	while(i<sz){
		j=i; 
		//相接的定义 
		while(v[j].end>=v[j+1].begin&&j<sz-1)
			++j;
		printf("%d %d\n",v[i].begin,v[j].end); 
		//把i更新到j的下一个，成为下一个起始线段
		i=j+1; 
	} 
```

### 完整代码
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int n,res;
struct sub {int begin,end;}list[100004];
vector < sub > v;

bool cmp(const sub &a,const sub &b){
	if(a.begin==b.begin)
		return a.end<b.end;
	return a.begin<b.begin;
} 

int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&list[i].begin);
		scanf("%d",&list[i].end);
	}
	sort(list,list+n,cmp);
	//先让第一段线段进入最终遍历的数组，排序保证了此操作的正确性 
	v.push_back(list[0]);
	for(int i=1;i<n;i++){
		//判断这条线段是否与前面一条重合 
		if(v.back().begin<=list[i].begin&&
		v.back().end>=list[i].end)
			continue;
		v.push_back(list[i]);
	}
	int sz=v.size();
	int i=0,j=0;
	//i是要连在一起的线段的起始线段,j是结尾线段 
	while(i<sz){
		j=i; 
		//相接的定义 
		while(v[j].end>=v[j+1].begin&&j<sz-1)
			++j;
		printf("%d %d\n",v[i].begin,v[j].end); 
		//把i更新到j的下一个，成为下一个起始线段
		i=j+1; 
	} 
	return 0;
}
```

这份题解和我P2082的题解可能有些一样的地方，望管理大大见谅。

---

## 作者：loi_ys (赞：1)

# 贪心...

~~代码简单易懂~~

## 一条华丽的分割线
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 1000100
using namespace std;
struct node
{
	int l,r;
}a[maxn];
int n,num=0,ans=0;
bool cmp(node a,node b)
{
	return a.l<b.l;
}
int main()
{
	std::ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].l>>a[i].r;
	}
	sort(a+1,a+n+1,cmp);
	num=a[1].r;
	ans=a[1].l;
	for(int i=2;i<=n;i++)
	{
		if(num<a[i].l)
		{
			cout<<ans<<" "<<num<<endl;
			num=max(num,a[i].r);
			ans=a[i].l;
		}
		else
		{
			num=max(num,a[i].r);
		}
		if(i==n)
		{
			cout<<ans<<" "<<num<<endl;
		}
	}
	return 0;
}
```
~~以上就是本蒟蒻的代码~~

# 入oi以来第一篇题解！

---

## 作者：Mys_C_K (赞：1)

总结一下楼下大神的各种解法：

1.前缀和和差分，这个应该是代码最短的做法，对于区间[u,v],a[u]++,a[v+1]--即可。

最好离散化一下。

2.线段树，这个就是无脑暴力的套数据结构罢了……

3.平衡树，基本上和线段树是一个实质……

4.把几条线段合并即可，其实从某种意义上来说，和5是一样的

5.事件记录。记录一个事件的发生时间和性质（开始或者结束）。

然后扫一遍就好了。这个做法个人认为是没有优化的差分算法（因为需要对事件排序）

差分无非就是边读便O(1)修改，然后O(n)扫描。

为了凑字数贴一下丑陋的代码一开始被坑了还真的写了线段树，不过这里是事件记录的做法……

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct events{
    int seconds;
    bool is_start;//is_start=true then the event is starting event
    bool operator<(const events &eve)const
    {
        if(seconds==eve.seconds)
            return is_start>eve.is_start;
        else return seconds<eve.seconds;
    }
}e[50000*2+10];int etop;
bool cmp(const events &a,const events &b)
{
    return a<b;
}
inline void add_event(int seconds,bool is_start)
{
    etop++;
    e[etop].seconds=seconds;
    e[etop].is_start=is_start;
}
int main()
{
    int m,u,v;etop=0;
    scanf("%d",&m);
    while(m--)
    {
        scanf("%d%d",&u,&v);
        add_event(u,true);
        add_event(v,false);
    }
    sort(e+1,e+etop+1,cmp);
    int cur=1,cnt=0;
    while(cur<=etop)
    {
        if(e[cur].is_start){
            if(cnt==0)
                printf("%d ",e[cur].seconds);
            cnt++;
        }
        else{
            cnt--;
            if(cnt==0)
                printf("%d\n",e[cur].seconds);
        }
        cur++;
    }
    return 0;
}
```

---

## 作者：ars4me (赞：1)

这个题不需要差分 不需要贪心排序 不需要线段树

我们用一个bool数组(a)表示区间 然后没读入一个区间就把该区间的bool值付为1 初始都为0

然后 从第一个开始看 如果当前的a[i]为true 记录一下 然后往后找知道a[i]为false了 就把刚才那一段输出

注意 举个例子吧 加入输入的区间为1 4 那我们要把a[2]a[3]a[4]变成true 为什么画画图就看出来了

代码如下







```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
    using namespace std;
    #define in = read();
    typedef long long ll;
    typedef unsigned int ui;
    const ll size = 1000000 + 1000;
        int n , x , y;
        int len , leftpoint;
        bool a[size];
inline ll read(){
        ll num = 0 , f = 1;    char ch = getchar();
        while(!isdigit(ch)){
                if(ch == '-')   f = -1;
                ch = getchar();
        }
        while(isdigit(ch)){
                num = num*10 + ch - '0';
                ch = getchar();
        }
        return num*f;
}
int main(){
        n in;
        for(register int i=1;i<=n;i++){
                x in;    y in;
                for(register int i=x+1;i<=y;i++)
                        a[i] = true;
                len = max(len , y);
        }
        for(register int i=1;i<=len;i++)
                if(a[i]){
                        leftpoint = i;
                        for(register int j=leftpoint;j<=len;j++)
                                if(!a[j + 1]){
                                        printf("%d %d\n" , leftpoint - 1 , j);
                                        i = j;
                                        break;
                                }
                }
}
```
我管这个方法叫做
**暴力**

COYG

---

## 作者：NewSjf (赞：0)

逛了下好像没有set的做法     
这里贡献一个奇怪的做法     
重载小于符号a<b为 a.r<b.l     
那么a<b代表a完全在b右边    
a>b代表a完全在b左边     
那么a==b就是a和b有交集      
s.find(a)!=s.end()就是说在已经插入的区间里面找到了和a有交集的区间    
删除旧的区间,合并到新的将要插入的区间      
最有把区间并插入      
时间复杂度O(NlogN)     
~~代码很短很好理解~~    
```cpp
#include<iostream>
#include<set>
#define MAXN 100001
using namespace std;
struct node
{
	int l,r;//a<b 表示a完全在b左边 a>b 表示a完全在b右边 那么a==b就是a和b有交集 
	bool friend operator<(const node&a,const node&b){return a.r<b.l;}
}a;
set<node>s;
int main()
{
	int n;cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a.l>>a.r;
		auto it=s.find(a);       //是否有相交的区间 
		while(it!=s.end())
		{
			a.l=min(a.l,it->l);  //合并到新插入的区间,左右取最大值 
			a.r=max(a.r,it->r);
			s.erase(it);         //删除被合并的区间 
			it=s.find(a);
		}
		s.insert(a);            //插入区间并 
	}
	for(auto val:s)
		cout<<val.l<<" "<<val.r<<endl;   //从左到右输出区间 
}
```


---

## 作者：封禁用户 (赞：0)

# 并查集
看了下题解，发现都看不懂，就烦躁的自己打了一篇并查集做法的

①先排序（用左端点排序）

②若有重合的，则把他们merge起来，父亲是最先出现的区间编号

③输出，要稍微判断一下

~~思路是很好懂的~~

见代码
```cpp
#include<cstdio>
#include<algorithm>
#define N 50050
using namespace std;
int f[N];
struct section
{
	int l;
	int r;
} e[N+50];
int n;
int _find(int x)
{
	if(x==f[x]) return x;
	else return f[x]=_find(f[x]);
}
void _merge(int x,int y)
{
	int roox=_find(x);
	int rooy=_find(y);
	if(roox!=rooy)
	f[rooy]=roox;
	return;
}
bool comp(const section &x,const section &y) {return x.l<y.l;}
int main()
{
	scanf("%d",&n);
	int x,y;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&e[i].l,&e[i].r);
	}
	sort(e+1,e+1+n,comp);
	for(int i=1;i<=n;i++) 
		f[i]=i;
	for(int i=1;i<n;i++)
	{
		if(e[i+1].l<=e[i].r)
		{
			_merge(i,i+1);
			if(e[i+1].r<e[i].r) e[i+1].r=e[i].r;//特判，不然爆0
		}
	}
	int cnt=-9;
	for(int i=1;i<=n;i++)
	{
		if(cnt!=f[i])
		{
			printf("%d ",e[i].l);//发现新区间
			cnt=f[i];
		}
		if(cnt!=f[i+1])
		{
			printf("%d\n",e[i].r);//若下一个区间与它无重合
		}
	}
	return 0;
} 
```

---

## 作者：Vin_1999 (赞：0)

看到你们都用很imba的方式我都不好意思发题解了。

平衡树······好吧我是模拟。你说贪心也可以。

把区间按l排一遍序，然后对于下一个区间l在R里面的就会并在一起喽，如果r更大就更新喽。







```cpp
#include<bits/stdc++.h>
#define rep(i,s,n) for(int (i)=(s);(i)<=(n);++(i))
using namespace std;
struct segmentation{
    int l,r;
}seg[50000+7];
bool cmp(segmentation a, segmentation b)
{
    return a.l<b.l;
}
static int n;
int main()
{
  scanf("%d",&n);
  rep(i,1,n) scanf("%d%d",&seg[i].l,&seg[i].r);
  sort(seg+1,seg+1+n,cmp);
  int L=seg[1].l,R=seg[1].r,cur=1;
  while(cur++<=n)
  {
      if(seg[cur].l>R)
        {
      printf("%d %d\n",L,R);
      L=seg[cur].l;R=seg[cur].r;
    }
      else if(seg[cur].r>R) R=seg[cur].r;
    }
    printf("%d %d\n",L,R);
     return 0;
}//by fjlyyz-ljy

```

---

## 作者：上进的z君 (赞：0)

**这题有两种做法**

#一、差分

[delete]应该是叫做差分吧算了不管了[/delete]

**具体做法如下**

每读进一个区间，在线段上找到这个区间的头和尾，头++，尾--。

读完之后就扫一遍，一开始遇到一个大于零的点，就设x储存这个位置。

扫的过程中sum累加当前这个点的值。

一直到sum=0的时候，就输出x和当前的位置。

一只做下去知道循环结束。

时间复杂度是O(2000000)。


#二、模拟

[delete]应该是不叫模拟吧算了不管了[/delete]

**具体做法如下**

开个struct储存区间，假设是l和r。然后根据区间头排个序，假设用了一个数组a来存。

然后答案的开头肯定a[1].l，因为已经排过序了。

然后就将a[1]这个区间用一个数组r存起来。

然后就把这n个区间扫一遍，如果某个区间与r数组里面的区间有交集，那么就更新r数组里的区间，否则就塞进r数组里。另外，可以知道，如果这个区间与r数组里的区间有交集，那么一定就是r数组里最后的区间。\_想一想，为什么？\_

最后，输出r数组。

**然而好像会出现一个问题：那就是如果区间a和区间b没有交集，都存进了数组r里，但是后来区间a被更新后，就与区间b产生了交集，那么这不就错了么？**

我这么做为什么不会有问题呢？你可以仔细的想想。

时间复杂度是O(n log n)

\_占时间的部分是快排，程序主体部分是O(n)的。\_


**下面附了一个模拟的程序。有很多多出来的部分，因为我一开始看错题目了.....**


```cpp

#include<cstdio>  
#include<cstring>  
#include<cstdlib>  
#include<algorithm>  
#include<iostream>  
using namespace std;  
  
const int maxn=50010;  
const int maxm=1000010;  
const int INF=1000000;  
  
struct data{  
    int l,r;  
}a[maxn],r[maxn];  
  
int re[maxm],n,cur=0,sum=0;  
  
bool Cmp(data x,data y){  
    if(x.l<y.l)return true;  
    if(x.l==y.l&&x.r<y.r)return true;  
    return false;  
}  
  
int Find(int x){  
    int l=0,r=n+1;  
      
    while(l+1<r){  
        int mid=(l+r)/2;  
        if(a[mid].l>=x)r=mid;  
        else l=mid;  
    }  
      
    return l;  
}  
  
int Work(int x,int y){  
    if(x==y)return 0;  
      
    int ax=Find(x),bx=Find(x+1),ans=INF;  
      
    if(ax==bx)return INF;  
      
    for(int i=ax+1;i<=bx;i++)  
    if(a[i].r<=y){  
        ans=min(ans,Work(a[i].r,y)+1);  
    }  
      
    return ans;  
}  
  
int main()  
{  
      
    scanf("%d",&n);  
    for(int i=1;i<=n;i++)scanf("%d%d",&a[i].l,&a[i].r);  
      
    sort(a+1,a+n+1,Cmp);  
      
    cur=1;  
    r[1].l=a[1].l;  
    r[1].r=a[1].r;  
  
    for(int i=2;i<=n;i++)  
    if(a[i].l>=r[cur].l&&a[i].l<=r[cur].r){  
        r[cur].r=max(r[cur].r,a[i].r);  
    }  
    else{  
        cur++;  
        r[cur].l=a[i].l;  
        r[cur].r=a[i].r;  
    }  
      
    /\*for(int i=1;i<=cur;i++) 
    sum+=Work(r[i].l,r[i].r);\*/  
      
    for(int i=1;i<=cur;i++)  
    printf("%d %d\n",r[i].l,r[i].r);  
      
    return 0;  
}

---

## 作者：jsyjsy (赞：0)

思路：离散化。读进区间，头递增，尾递减，最后扫描一遍


程序嘛，当然比线段树短小得多


```cpp
var
  n,i,j,x,y,s,start:longint;
  a:array[1..1000000]of longint;
begin
  read(n);
  start:=1000000;
  for i:=1 to n do
    begin
      read(x,y);
      if x<start then start:=x;
      inc(a[x]); dec(a[y]);           
    end;
  s:=0;
  for i:=1 to 1000000 do
    if a[i]<>0 then
      begin
        inc(s,a[i]);
        if s=0 then
          begin
            writeln(start,' ',i);
            for j:=i+1 to 1000000 do 
              if a[j]>0 then begin start:=j; break; end;
          end;
      end;
end.
```

---

## 作者：依依 (赞：0)

贪心，

将区间按照（第一关键字）左端点从小到大排序，然后按照（第二关键字）右端点从小到大排序

然后从当前线段出发，找到能够合并到的最远的区间的右端点，

一旦不能够合并，输出答案

然后从上一次能够合并到的最远的区间开始
更新

TimeO(n)  
[代码](http://www.cnblogs.com/adelalove/p/8629137.html)

~~（没错，我就是来刷访问量的）~~

---


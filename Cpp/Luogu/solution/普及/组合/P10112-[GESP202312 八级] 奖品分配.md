# [GESP202312 八级] 奖品分配

## 题目描述

班上有 $N$ 名同学，学号从 $0$ 到 $N-1$。有 $M$ 种奖品要分给这些同学，其中，第 $i$ 种奖品总共有 $a_i$ 个 （$i=0,1, \cdots ,M-1$）。

巧合的是，奖品的数量不多不少，每位同学都可以恰好分到一个奖品，且最后剩余的奖品不超过 $1$ 个（即：$N\le a_0+a_1+ \cdots +a_{M-1}\le N+1$）。

现在，请你求出每个班级礼物分配的方案数，所谓方案，指的是为每位同学都分配一个种类的奖品。

只要有一位同学获得了不同种类的奖品，即视为不同的方案。方便起见，你只需要输出方案数对 $10^{9}+7$ 取模后的结果即可。

共有 $T$ 个班级都面临着奖品分配的问题，你需要依次为他们解答。

## 说明/提示

**样例解释 1**

对于第 $1$ 个班级，学号为 $0,1,2$ 的同学可以依次分别获得奖品 $0,1,1$，也可以依次分别获得奖品 $1,0,1$，也可以依次分别获得奖品 $1,1,0$ ，因此共有 $3$ 种方案。

对于第 $2$ 个班级，学号为 $0,1,2$ 的同学可以依次分别获得奖品 $0,1,1$ ，也可以依次分别获得奖品 $1,0,1$，也可以依次分别获得奖品 $1,1,0$，也可以依次分别获得奖品 $1,1,1$，因此共有 $4$ 种方案。

对于第 $3$ 个班级，可以把编号为 $0$ 的奖品分配给 $5$ 名同学中的任意一名，共有 $5$ 种方案；再把编号为 $2$ 的奖品分配给剩余 $4$ 名同学中的任意一名，共有$4$ 种方案；最后给剩余 $3$ 名同学自然获得 $1$ 号奖品。因此，方案数为 $5 \times 4 = 20$。

**数据范围**

对于 $30\%$ 的测试点，保证 $N \le 10$。

对于另外 $30\%$ 的测试点，保证 $M=2$。

对于所有测试点，保证 $N \le 1000$；保证 $T \le 1000$ ；保证 $M \le 1001$。

## 样例 #1

### 输入

```
3
3 2 1 2
3 2 1 3
5 3 1 3 1 ```

### 输出

```
3
4
20```

## 样例 #2

### 输入

```
5
100 1 100
100 1 101
20 2 12 8
123 4 80 20 21 3
999 5 101 234 499 66 99```

### 输出

```
1
1
125970
895031741
307187590```

# 题解

## 作者：CleverRaccoon (赞：34)

首先祝大家除夕快乐！新年快乐！

## 题目

一句话题意：求将 $M$ 种奖品共 $N\sim N+1$ 个发给 $N$ 个人有多少种方案。

## 思路

很明显，此题考察组合数学。

把每个人想象成一个位置，然后将奖品一类一类地依次填充到这些位置中。需要应用到组合数 $C_{n}^{m}$，根据组合数公式 $C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1}$ 可以预处理出来。那么为什么不是排列而是组合呢？因为一位同学获得了不同种类的奖品，才算是不同的方案。而如果求排列，假设第 $k$ 类奖品有 $p$ 个，那么这位同学拿到第 $k$ 奖品的第 $1$ 个和拿到第 $p$ 个就会被视为不同的方案，显然不符合题意。

通过例子来解释，比如样例一的第一组数据：

```
3 2 1 2
```

三个人，两种奖品，每种奖品分别有 $1$ 个和 $2$ 个。

- 首先考虑第一种物品。第一种物品有 $1$ 个，它有 $3$ 个位置可以选择，故有 $C_{3}^{1}=3$ 种方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/pep15hj4.png)

- 接着，考虑第二种物品。第二种物品有 $2$ 个，无论第一种物品选择了哪个位置，都只剩下 $3-1=2$ 个位置供它选择了，故有 $C_{2}^{2}=1$ 种方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/njq8ckt4.png)

根据乘法原理，因为几次选择是顺次进行的，所以将两次选择的方案数乘起来即为答案。

于是，我们便得到了一份代码。但别着急，因为这份代码存在问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD=1e9+7;
const int N=1005;
int T,n,m,ls,a[N],c[N][N],ans;
void init(){	// 初始化组合
	for(int i=0;i<N;i++)
		for(int j=0;j<=i;j++)
			if(j==0)c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;	// 记得取模
}
int main(){
	init();
	cin>>T;
	while(T--){
		cin>>n>>m;
		for(int i=1;i<=m;i++)cin>>a[i];
		ans=1;
		for(int j=1,ls=n;j<=m;j++){	// 每一种奖品
			ans=(1ll*ans*c[ls][a[j]])%MOD;	// 注意转化为 long long 类型后再取模，否则有可能爆 int
			ls-=a[j];	// 将还未领奖品的人数，即空的位置数减一
		}
		cout<<ans%MOD<<"\n";
	}
	return 0;
}
```

## 棘手的问题

我们会发现，由于 $a_0+a_1+\cdots+a_{M-1}$ 有可能等于 $N+1$，而上述的做法只能解决等于 $N$ 的情况。

那么怎么做呢？我们发现，多出来的那一个奖品其实就相当于发给了空气，那么就把空气也当成是一个人，它也参与领取奖品就好了。

我们在上面代码的基础上进行了修改，计算出 $a_0+a_1+\cdots+a_{M-1}$ 的值，然后他如果超过了 $N$，就将初始总人数加一。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD=1e9+7;
const int N=1005;
int T,n,m,ls,a[N],c[N][N],ans,sum;
void init(){	// 初始化组合
	for(int i=0;i<N;i++)
		for(int j=0;j<=i;j++)
			if(j==0)c[i][j]=1;
			else c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;	// 记得取模
}
int main(){
	init();
	cin>>T;
	while(T--){
		cin>>n>>m;
		sum=0;	// sum 记录奖品总数
		for(int i=1;i<=m;i++)cin>>a[i],sum+=a[i];	// 输入的同时更新 sum
		ans=1;
		// ls=n+(sum>n) 表示如果 sum>n，那么 ls=n+1，否则 ls=n，即解决上面所说的问题
		for(int j=1,ls=n+(sum>n);j<=m;j++){	// 每一种奖品
			ans=(1ll*ans*c[ls][a[j]])%MOD;	// 注意转化为 long long 类型后再取模，否则有可能爆 int
			ls-=a[j];	// 将还未领奖品的人数，即空的位置数减一
		}
		cout<<ans%MOD<<"\n";
	}
	return 0;
}
```

这样，我们就可以通过本题了。


---

## 作者：miaoyu2022 (赞：6)

[传送门](https://www.luogu.com.cn/problem/P10112)

## 题意

$N$ 个同学，$M$ 种礼物，每种礼物 $a_i$ 个，多出的奖品不超过一个。

## 思路

考虑将当前奖品分给暂未拿到奖品的人，如果当前共有 $n$ 人暂未拿到奖品，当前分的是第 $i$ 种奖品，则分完当前这种奖品共有 $C_{n}^{a_i} = \frac{n!}{(n-a_i)!a_i!}$ 种可能。再利用乘法原理将所有答案乘起来即可。

但多出的奖品如何处理？

我们可以发现多出的奖品其实并没有影响，我们只要假设开始时多一个人，也就是把 $n$ 设为 $n+1$ 就可以了。

然后我就TLE+WA了。

再利用杨辉三角将组合数预处理后，便可以[AC](https://www.luogu.com.cn/record/146344474)了。

## Code（加入详细注释）

```cpp
//洛谷P10112
//https://www.luogu.com.cn/problem/P10112
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MOD=1e9+7;
int c[1005][1005];
int _,n,m,ans,sum,a[1005];
signed main()
{
    //杨辉三角预处理组合数
    for(int i=0;i<1005;i++) c[i][0]=c[i][i]=1;
    for(int i=1;i<1005;i++) for(int j=1;j<i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;
    scanf("%lld",&_);
    while(_--)
    {
        ans=1;sum=0; //初始化
        scanf("%lld %lld",&n,&m);
        for(int i=1;i<=m;i++) scanf("%lld",a+i),sum+=a[i];
        n=sum==n?n:n+1; //判断是否多出奖品
        for(int i=1;i<=m;i++) //枚举每种奖品
            ans=ans*c[n][a[i]]%MOD,n-=a[i]; //利用组合数计算
        printf("%lld\n",ans%MOD); //输出答案
    }
    return 0;
}
```


---

## 作者：__O_w_O__ (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P10112)

这道题目总的来说代码量不多，但是思维很麻烦。

题目说，所有的奖品加起来正好等于 $n$ 或等于 $n+1$。

那么，就可以进行分类讨论。

**第一种情况：奖品数正好等于 $n$。**

这种情况下就是说每个同学正好只拿一个奖品。

假设有 $10$ 名同学，奖品有 $3$ 种，每种奖品的个数分别为 $3,2,5$。

首先，我们要从 $10$ 个人中选择 $5$ 个人拿第三种奖品，那么组合情况数 $C_{10}^{5}$。

接下来，从剩下的 $5$ 个人中选择 $2$ 个人拿第二种奖品，那么组合情况数为 $C_{5}^{2}$。

那么最后只剩下 $3$ 个人，只能拿第一种奖品，即组合情况数位 $C_{3}^{3}$。

这样的选取方法结果就是 $C_{10}^{5}\times C_{5}^{2}\times C_{3}^{3}=2520$。

如果换一种顺序取选取奖品，假如说从前往后取，先取第一种奖品，再取第二种奖品，最后取第三种奖品，结果就是 $C_{10}^{3}\times C_{7}^{2}\times C_{5}^{5}=2520$。

两个式子的结果相等的，这就证明了这种计算方法的正确性。

这种情况下的公式为 $C_{n}^{a_1}\times C_{n-a_1}^{a_2}\times C_{n-a_1-a_2}^{a_3}\times...\times C_{n-a_1-a_2-...-a_{n-1}}^{a_n}$ 。

**第二种情况：奖品数等于 $n+1$。**

如果奖品数等于 $n+1$ 的话，最终就会多出来一个奖品。

仍然举一个例子：有 $10$ 名同学，$3$ 种奖品，每种奖品的数量分别是 $4,5,2$。

第一种思路：我们可以**假设多出的奖品分别是第几种奖品。**

假设多出的是第一种奖品，那就减掉好了，奖品数就变成了 $3,5,2$。

假设多出的是第二种奖品，奖品数就变成了 $4,4,2$。

假设多出的是第三种奖品，奖品数就变成了 $4,5,1$。

一共就得到了三种情况，分别按照第一种情况算即可。

分别相加，得到结果为 $C_{10}^{3}\times C_{7}^{5}\times C_{2}^{2}+C_{10}^{4}\times C_{6}^{4}\times C_{2}^{2}+C_{10}^{4}\times C_{6}^{5}\times C_{1}^{1}=6930$。

但是这样做的复杂度是多少呢？毫无疑问，是 $O(MT)$，很明显会超时。

第二种思路：**不是去掉物品，而是多加一个人**。因为多出的奖品即使不给人也要放在那里，因此可以假设多出来一个人，多出的一个奖品正好给多出的一个人。这样就转换成了第一种情况。

最终结果为 $C_{11}^{4}\times C_{7}^{5}\times C_{2}^{2}=6930$。

第一种思路的结果和第二种思路的结果正好相等，说明了第二种思路的正确性。

因为只是让同学数加一，所以复杂度和第一种情况相等，完全可以通过。

这种情况下的公式为 $C_{n+1}^{a_1}\times C_{(n+1)-a_1}^{a_2}\times C_{(n+1)-a_1-a_2}^{a_3}\times...\times C_{(n+1)-a_1-a_2-...-a_{n-1}}^{a_n}$ 。

题目中说，所有奖品的数量不是等于 $n$ 就是等于 $n+1$，简单整理以下，设 $sum$ 为所有奖品的总数量，最终的答案就是  $C_{sum}^{a_1}\times C_{sum-a_1}^{a_2}\times C_{sum-a_1-a_2}^{a_3}\times...\times C_{sum-a_1-a_2-...-a_{n-1}}^{a_n}$ 。

至于组合数可以使用杨辉三角预处理。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;
const int mod = 1e9 + 7;

int a[N], C[N][N];

//利用杨辉三角预处理组合数
void init() {
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= i; j++) {
            if (j == 0 || j == i) C[i][j] = 1;
            //边加边取模
            else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
        }
    }
}
int main() {
    init();
    int T;
    scanf("%d", &T);
    while(T--) {
        int n, m;
        scanf("%d%d", &n, &m);
        int sum = 0;
        for (int i = 1; i <= m; i++) {
            scanf("%d", &a[i]);
            sum += a[i];
        }
        long long ans = 1;//注意开long long
        for (int i = 1; i <= m; i++) {
            //这里的结果计算方法参考上面的讲解
            //直接用sum来计算答案省的考虑两种情况
            ans = (ans * C[sum][a[i]]) % mod;
            sum -= a[i];
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```


---

## 作者：__DayLight__ (赞：2)

## 前言
思路分析于 GESP 官网的[题解](https://gesp.ccf.org.cn/101/attach/1584918480027680.pdf)。
## 思路

[回顾题目](https://www.luogu.com.cn/problem/P10112)。


虽然标签里没标算法，但从题目中很容易能读出**组合数**的味道。

所以我们就要先进行**预处理**。

### 预处理分析

- **声明**：组合数 $c(i,j)$ 表示从 $i$ 个元素中选择 $j$ 个元素的组合数。

	如下是组合数当中的一个经典方程

     $$c(i,j)=c(i-1,j-1)+c(i-1,j)$$
  

  那这又是如何**推导**出来的呢？
  
  
  根据组合数的性质，我们知道：
	1. $c(i,0) = 1$，表示从 $i$ 个元素中选择 $0$ 个元素的组合数为 $1$。
    
    
	1. $c(i,i) = 1$，表示从 $i$ 个元素中选择 $i$ 个元素的组合数为 $1$。
   
	1. $c(i,j) = c(i-1,j-1) + c(i-1,j)$，表示从 $i$ 个元素中选择 $j$ 个元素的组合数等于从 $i\sim1$ 个元素中选择 $j\sim1$ 个元素的组合数加上从 $i\sim1$ 个元素中选择 $j$ 个元素的组合数。
    
   **举个例子** 
   
   假设我们要计算 $c(4,2)$，即从 $4$ 个元素中选择 $2$ 个元素的组合数。根据递推关系，我们可以将其拆分为两部分：
   
   1. 从 $3$ 个元素中选择 $1$ 个元素的组合数，即 $c(3,1)$。
   
   
   1. 从 $3$ 个元素中选择 $2$ 个元素的组合数，即 $c(3,2)$。
   
   根据递推关系，我们可以继续拆分 $c(3,1)$ 和 $c(3,2)$：

	1. $c(3,1) = c(2,0) + c(2,1) = 1 + 2 = 3$。
    
	1. $c(3,2) = c(2,1) + c(2,2) = 2 + 1 = 3$。
   
   最后，将 $c(3,1)$ 和 $c(3,2)$ 的结果相加，得到 $c(4,2) = 3 + 3 = 6$。

	通过类似的方式，我们可以推导出其他组合数的值。
    

- 那么将其代入便得到了预处理的代码。
```cpp
	c[0][0]=1;//组合数的性质
	for(int i=1; i<=1005; i++)
	{
		c[i][0]=c[i][i]=1;
		for(int j=1; j<i; j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j],c[i][j]%=mod;
	}
```


------------


如果用 $sum$ 表示礼物总数，那么题目让我们求的就是 $c(sum,a[i])$。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,m,a[1010],c[1010][1010],t,sum,ans;
signed main(){
	cin>>t;
	c[0][0]=1;//组合数的性质
	for(int i=1; i<=1005; i++)
	{
		c[i][0]=c[i][i]=1;
		for(int j=1; j<i; j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j],c[i][j]%=mod;
	}
	while(t--)
	{
		cin>>n>>m;
		ans=1,sum=0;
		for(int i=1; i<=m; i++)
			scanf("%d",&a[i]),sum+=a[i];
		for(int i=1; i<=m; i++)
			ans*=c[sum][a[i]],ans%=mod,sum-=a[i];//每分配完一次礼物要记得减去 
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 思路：
- 首先考虑奖品总个数=人数的情况，设奖品数分别是 $a_1,a_2,a_3...a_n$。
- 则总方案数为 $n$，可以提前预处理排列数 $C$ 数组的值,，方便计算，接着考虑奖品总个数=人数 $+1$ 的情况，我们可以额外虚设 $1$ 个人，依然按照奖品总个人=人数的情况计算，并输出方案数，具体的方案为不考虑虚设人拿的奖品种类。
- 把前 $n$ 个人拿的奖品种类作为方案，考虑为什么这样是对的，对于两种方案，如果虚设人拿的奖品编号相同，那么说明前面 $n$ 个人拿的奖品编号必然有不同，那么方案是不同的，如果虚设人拿的奖品编号不同，因为总共只有 $n+1$ 个奖品，所以前面 $n$ 个人拿的奖品编号必然也不同，方案也是不同的，说明我们在虚设人的情况下得到的任意两个方案都不会重复，所以直接按照人数=奖品总个数计算即可。
## 代码：
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include <string>
#include <map>
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
const int N=1085;
const int mod=1e9+7;
int c[N + 5][N + 5],a[N + 5];
void add(int &a,int b){
    a+=b;
    if(a>mod)a-=mod;
}
void init(){
    c[0][0]= 1;
    for(int i=1;i<= N; i ++){
        c[i][0]=c[i][i]=1;
        for(int j=1;j<i;j++)
            c[i][j]=c[i-1][j -1],add(c[i][j],c[i -1][j]);
    }
}
int main(){
    init();
    int T;
    cin>>T;
    while(T--){
        int n,m,sum=0;
        scanf("%d%d",&n,&m);
        for(int i = 1; i <= m; i ++)
            scanf("%d",&a[i]),sum += a[i];
        int ans = 1;
        for(int i =1;i<=m;i++){
            ans=1ll*ans*c[sum][a[i]]% mod;
            sum-=a[i];
        }
        cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：xiaoliebao1115 (赞：1)

这是一道非常经典的排列组合问题。

## 本题思路
在分第一种礼物时（假设有 $a$ 个），有 $n$ 个学生需要分发，也就是说把  $n$ 个学生挑出 $a$ 个来进行组合。

在分后面的礼物时，只需把没发过的学生分发，即把上文中的 $n$ 换成剩下的学生。

但当礼物数比学生数多 $1$ 时，可以看成有一个多的学生拿剩下的礼物。

~~排列组合不会的可以自己去查资料。~~

## $60$ pts
$t$ 最大是 $1000$，如果直接在循环内进行计算，会超时。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll t,a[1002];
const ll mod=1e9+7;
ll jie(ll x)
{
	ll sum=1;
	for(ll i=x;i>=1;i--) 
	{
		sum*=i,sum%=mod;
	}
	return sum;
}
long long poww(long long a,long long b)
{
	ll k=mod;
	if(b==1) return a%k;
	ll y=poww(a,b/2);
	if(b%2==0) return y%k*y%k;
	else return y%k*y%k*a%k;
}
int main()
{
	cin>>t;
	while(t--)
	{
		ll n,m,human,sum=1,tot=0;
		cin>>n>>m;
		human=n;
		for(int i=1;i<=m;i++) cin>>a[i],tot+=a[i];
		if(tot==n+1) human=n+1;
		for(int i=1;i<=m;i++)
		{
			if(a[i]>human) a[i]=human;
			ll s1=jie(human),s2=jie(human-a[i])*jie(a[i])%mod;
		//	cout<<s1<<" "<<s2<<endl;
			ll cheng=poww(s2,mod-2);
			ll ans=s1*cheng%mod;
			sum=sum*ans%mod;
			human-=a[i];
		}
		cout<<sum<<endl;
	}
	return 0;
}
```
这道题还有个小技巧，在模意义下除法无法直接进行计算，需要使用逆元。
## $100$ pts
预处理出阶乘，不再循环内进行计算。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll t,a[1002],s[1002];
const ll mod=1e9+7;
ll jie(ll x)
{
	return s[x];
}
long long poww(long long a,long long b)
{
	ll k=mod;
	if(b==1) return a%k;
	ll y=poww(a,b/2);
	if(b%2==0) return y%k*y%k;
	else return y%k*y%k*a%k;
}
int main()
{
	cin>>t;
	s[0]=1;
	for(int i=1;i<=1001;i++) s[i]=s[i-1]*i%mod;
	while(t--)
	{
		ll n,m,human,sum=1,tot=0;
		cin>>n>>m;
		human=n;
		for(int i=1;i<=m;i++) cin>>a[i],tot+=a[i];
		if(tot==n+1) human=n+1;
		for(int i=1;i<=m;i++)
		{
			if(a[i]>human) a[i]=human;
			ll s1=jie(human),s2=jie(human-a[i])*jie(a[i])%mod;
		//	cout<<s1<<" "<<s2<<endl;
			ll cheng=poww(s2,mod-2);
			ll ans=s1*cheng%mod;
			sum=sum*ans%mod;
			human-=a[i];
		}
		cout<<sum<<endl;
	}
	return 0;
}
```

---

## 作者：Anemo_Slime (赞：1)

$N$ 种同学，$M$ 种奖品，$N/N+1$ 个奖品，问分奖品的方案数。

考虑如何入手，样例解释 $3$ 其实能给我们很大的启发。对于每种奖品的分发，会选择给还未分到的同学中分发 $a_i$ 个奖品 ，有 $C^{a_i}_{cnt}$ 种可能的情况，$cnt$ 表示还未分到的同学的数量，然后枚举每种奖品进行分发情况数利用乘法原理乘起来，就做完了。 

但是奖品的数量可能会多出来一个，我们可以转换一下，看做是多了一个空气同学进行分发，当最后只剩下一个奖品分发到它的时候，$C^1_1=1$。乘起来不会增加多余的结果。

对于组合数的处理见[组合数问题](https://www.luogu.com.cn/problem/B3717)。总时间复杂度为$O(Tm)$。足够通过本题。
```
#include<bits/stdc++.h>
using namespace std;
#define out(x) printf("%lld ",x)
#define getend() printf("\n")
#define int long long
#define F(x,y,z) for(int x=y;x<=z;x++)
const int maxn=1005;
const int mod=1e9+7;
int T,n,m,inv[maxn],f[maxn],a[maxn],ret;
int qpow(int a,int b){
	int ans=1,base=a;
	while(b){
		if(b&1) ans=ans*base%mod;
		base=base*base%mod;
		b/=2;ans%=mod;
	}
	return ans%mod;
} 
void getready(){
	f[1]=1;
	F(i,2,maxn){
		f[i]=(i*f[i-1])%mod;
	}
	inv[maxn]=qpow(f[maxn],mod-2);
	for(int i=maxn-1;i>=0;i--){
		inv[i]=inv[i+1]*(i+1)%mod;
	}
}
int C(int m,int n){
	return f[n]*inv[m]%mod*inv[n-m]%mod;
}
signed main(){
	getready();
	cin>>T;
	while(T--){
		int sum=0;
		scanf("%lld%lld",&n,&m);
		F(i,1,m){
			cin>>a[i];
			sum+=a[i];
		}
		int cnt=n+(sum==n+1),ans=1;
		F(i,1,m){
			if(a[i]){
				ans*=C(a[i],cnt);
				ans%=mod;
				cnt-=a[i];
			}
		}				
		out(ans%mod);getend();										
	}
}	
```

---

## 作者：DFM_O (赞：0)

## [P10112 题目](https://www.luogu.com.cn/problem/P10112)

### 解题思路
因为奖品的个数只有两种情况，所以我们可以分情况讨论。

当奖品的个数为 $n$ 时：  
将第 $i$ 种奖品分配给同学时，共有 $\sum_{j=1}^{i-1}a_j$ 个同学已分配到奖品，则这一步共有 $C_{n-\sum_{j=1}^{i-1}a_j}^{a_i}$ 种方案。

即总方案数为：
$$\prod_{i=1}^{m}C_{n-\sum_{j=1}^{i-1}a_j}^{a_i}$$

当奖品的个数为 $n+1$ 时：   
我们可以想象为又多了一个同学，那么将第 $i$ 种奖品分配给同学时，共有 $\sum_{j=1}^{i-1}a_j$ 个同学已分配到奖品，这一步共有 $C_{n+1-\sum_{j=1}^{i-1}a_j}$ 种方案。

即总方案数为：
$$\prod_{i=1}^{m}C_{n+1-\sum_{j=1}^{i-1}a_j}^{a_i}$$

运算时别忘了对 $10^9+7$ 取模，最后输出即可。
### Code
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
long long zh[1002][1002],a[1002],p=1e9+7;//注意要开到1002
int main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	zh[0][0]=1;//别忘了给zh[0][0]赋值
	for(int i=1;i<=1001;i++)//预处理
	{
		zh[i][0]=1;
		for(int j=1;j<=i;j++)
			zh[i][j]=(zh[i-1][j-1]+zh[i-1][j])%p;
		zh[i][i]=1;
	}
	for(int ii=1;ii<=t;ii++)
	{
		int n,m;
		long long ss=0,sn=1,sn1=1;//sn记录所有奖品之和为n的情况,sn1记录和为n+1的情况
		cin>>n>>m;
		long long ns=n;
		for(int i=1;i<=m;i++)
		{
			cin>>a[i];
			ss+=a[i],sn=sn*zh[ns][a[i]]%p,sn1=sn1*zh[ns+1][a[i]]%p,ns-=a[i];
		}
		if(ss==n)
			cout<<sn<<"\n";
		else
			cout<<sn1<<"\n";
	}
    return 0;
}
```

---

## 作者：ChenZQ (赞：0)

$2024$ 年的第一篇题解，祝大家新年快乐。

这道题的题意非常明确，就是让我们求方案数。

而在数学中，有一个很常用的算方案的公式：$C_n^m$，表示从有 $n$ 个小球本质为不同，从中选 $m$ 个的方案数。

算 $C_n^m$ 的公式为：

$$C_n^m = \frac {n!} { m! ( n - m )!}$$

然后我们就可以开始考虑这道题的思路啦。

我们可以逆向思维，把人去选奖品变为奖品去选人。

我们一个一个去考虑每一种奖品，那么对于每一种奖品，我们都要从班里挑选对应数量的人去接受它。很显然，假设奖品数为 $a_i$，班里人数为 $n$，则方案数为 $C_n^{a_i}$。

但是注意，一个人只能拿一个奖品，所以我们每考虑完一种奖品后要将班里的总人数减去这个奖品的数量。

但是注意，奖品的总数有可能会等于 $N + 1$ 的，对于这种情况，我们会发现其实无论怎么选，奖品数最后只会剩下一个，这剩下的一个不会增加方案数，为了方便计算，我们可以增加一个同学，这个同学最后对答案的影响也仅是乘上了 $C_1^1$。不影响答案。

那么形式化来讲，设 $sum$ 为总人数，$a_i$ 为第 $i$ 种奖品的人数，那么答案为：

$$C_{sum}^{a_1} \times C_{sum-a_1}^{a_2} \times C_{sum-a_1-a_2}^{a_3} \dots C_{sum-a_1-a_2 \dots -a_{m-1}}^{a_m}$$

然后这个 $C$ 我们可以用杨辉三角来预处理，那么我们就可以写出代码啦。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int inf = 1e9 + 7;
int c[1010][1010];
int t,n,m;
int a[1010];

int main()
{
	scanf("%d",&t);
	
    for(int i=0;i<1010;i++) 
	{
        for(int j=0;j<=i;j++) 
		{
            if (j==0 || j==i) c[i][j]=1;
            else c[i][j]=(c[i-1][j]+c[i-1][j-1])%inf;
        }
    }
    while(t--)
    {
    	scanf("%d%d",&n,&m);
    	int sum=0;
    	int ans=1;
    	for(int i=1;i<=m;i++) scanf("%d",&a[i]),sum+=a[i];
    	if(sum==n+1) n++;
    	for(int i=1;i<=m;i++)
    	{
    		ans=ans*(c[sum][a[i]])%inf;
    		sum-=a[i];
		}
		printf("%d\n",ans);
	}
}
```

---


# 小 Y 拼木棒

## 题目背景

上道题中，小 Y 斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？

答案对 $10^9+7$ 取模。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$1 \le a_i \le 5 \times 10^3$。

关于标题：因为一些不可抗力的原因，名称进行了更改。深表歉意。

## 样例 #1

### 输入

```
4 
1
1
2
2```

### 输出

```
1```

# 题解

## 作者：灵乌路空 (赞：298)

知识点:组合数学，暴力枚举 

[原题面](https://www.luogu.com.cn/problem/P3799)

$\text{Rewrited on 2020.6.14.}$  
感谢 [TheStars](https://www.luogu.com.cn/user/247889) 发现错误，并提出宝贵意见。

## 题目要求
有 $n$ 根木棒，Yoomu 现从中选 4 根。  
求组成一个正三角形的方案数。

---


## 分析题意
  
欲由4根木棒组成一个正三角形，则必有 **2根长度相等**。  
且另外2根长度之和，等于 **前2根相等的木棒 的长度**。 

发现 各木棍 的长度 $a_i \leq 5000$，时间复杂度 $O(n^2)$ 可过。  
考虑直接用两层循环，**暴力枚举** 上述两种木棒的长度，计算方案数并累加。 

---

## 感性理解

记 $num_i$ 为，长度为 $i$ 的木棒的个数。

### 外层循环:

先要从 许多长度为 $i$ 的木棒 中取出2根 ,    
方案数为 从 $num_i$ 个数中取出2个数的组合，即$C(num_i,2)$。
      
### 内层循环:

要从 剩余的木棒中 取出2根长度之和为 $i$ 的木棒。  
令其中一根长度为 $j$，则另一根长度为 $i-j$。  
显然有 $1\le j<i$，$1\le i-j < i$。

讨论 $j$ 与 $i-j$ 的关系：

1. 若 $j=i-j$：  
   即从长度为 $j$ 的木棒中取出2根 合成一条边。  
   方案数为 从 $num_j$ 个数中取出2个数的组合，即 $C(num_j,2)$。
        
2. 若 $j \not= i-j$：
   需从长度为 $j$ 和 $i-j$ 的木棒中各取出1个。  
   根据乘法原理，则方案数为 $C(num_j,1) \times C(num_{i-j},1)$

根据乘法原理，将所有方案数相乘，即得 $ans$ 的增量 。

---
  
## 算法分析:

定义计数数组 $num[i]$，记录长度为 $i$ 的木棒的个数。  
在读入长度时求得 $num[i]$的值。

### 外层循环:    
枚举两根相等的木棒的长度 $i$ ,  
为保证可构成三角形，此长度的木棒数量 $\ge 2$ 时才可进入内层循环。    
     
### 内层循环:  

枚举一根用来合成的木棒长度 $j$，另一根长度即为 $i-j$。  
为保证不重复计算，强制要求 $j\le i-j$，枚举 $j$ 时到$\dfrac{i}{2}$ 停止。

分上述两种情况讨论:

1. 若 `(j == i - j && num[j] >= 2)` 成立，  
   则有 `ans += C(num[i], 2) * C(num[j], 2)`
      
2. 若 `(j != i - j && num[j] >= 1 && num[i - j] >= 1)` 成立，         
   则有 `ans += C(num[i],2) * C(num[j], 1) * C(num[i - j], 1);`  

一定注意随时取模。

---

## 代码 : 

```cpp
//知识点：组合数，暴力
/*
By:Luckyblock
*/
#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
const int kMaxn = 1e6 + 10;
const ll kMod = 1e9 + 7;
//=============================================================
ll n, ans, maxa, a[kMaxn], num[kMaxn];
//=============================================================
ll C(ll x, ll k) { 
  //求得从n个数中取出k个数的组合
  //此处k=1 / 2，用了特判写法。
  //k = 1 时，C(x, 1) = x;
  //k = 2 时，C(x, 2) = x * (x - 1) / 2;
  return (k == 1ll ? x : x * (x - 1ll) / 2ll) % kMod;
}
//=============================================================
int main() {
  scanf("%lld\n", &n);
  for (int i = 1; i <= n; ++ i) { //读入,并放入计数数组中 
    scanf("%lld", &a[i]); 
    maxa = max(a[i], maxa);
    num[a[i]] ++;
  }

  for (int i = 2; i <= maxa; ++ i) { //枚举两根相等的边
    if (num[i] >= 2ll) {
      ll times = C(num[i], 2ll) % kMod; //求出组合数 
      for (int j = 1; j <= i / 2; ++ j) { //枚举被合成的边(到i / 2即可)
        if (j != i - j && num[j] >= 1 && num[i - j] >= 1) //用来合成的木棒长度不等 
          ans += times * C(num[j], 1) * C(num[i - j], 1) % kMod;
        if (j == i - j && num[j] >= 2) //用来合成的木棒长度相等 
          ans += times * C(num[j], 2) % kMod;
        ans %= kMod;
      }
    }
  }
  printf("%lld", ans);
  return 0;
}
```

恭喜妖梦获得 第16回东方Project人气投票 人妖部门第一位！

---

## 作者：zhangziyi_xshsnoi (赞：67)

# solution 
[转到题目](https://www.luogu.com.cn/problem/P3799)

在解决这道题目前，我们需要了解一些关于组合数学的知识

我们知道，当我们在$n$个数中选择$m$个（不重复）那么可以选择的方案数为$C_n ^m$

$$C_n ^m=\frac {n!}{m!\times(n-m)!}$$
那么，当$m=2$时
$$C_n ^m=\frac {n!}{m!\times(n-m)!}$$
$$=\frac {n!}{2\times(n-2)!}$$
又因为
$$n!=n\times (n-1)\times(n-2)\times ……\times2\times1$$
$$(n-2)!=(n-2)\times(n-3)\times……\times2\times1$$
所以
$$\frac{n!}{(n-2)!}=n\times(n-1)$$
$$C_n^2=\frac{1}{2}\times(n)\times(n-1)$$

### 有了这些铺垫以后，我们再来看这道题

> 要从$n$根木棒中选出$4$根，使他们能组成一个正三角形。

简单的来说，就是先选出两根一样的，在选出两根使这两根的长度之和与先前选出的相同

### 那么现在来看核心代码
```
for(int i=Min+1;i<=Max;i++)
	{
		if(num[i]>=2)
		{
			for(int j=Min;j<=i/2;j++)
			{
				if(j!=i-j)
					ans+=num[i]*(num[i]-1)*num[j]*num[i-j]/2%mod;//后选的两条不相等
				else if(num[j]>=2&&j*2==i)
					ans+=num[i]*(num[i]-1)*num[i/2]*(num[i/2]-1)/4%mod;//后选的两根相等
			}
			ans%=mod;
		}
	}
```
如果你看懂了，那么
#### at last
# Code
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5*1e3+500,mod=1e9+7;
int num[maxn],n,Max=-1,Min=0x3f3f,ans=0;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin>>a;
		num[a]++;
		Max=max(Max,a);Min=min(Min,a);
	}
	for(int i=Min+1;i<=Max;i++)
	{
		if(num[i]>=2)
		{
			for(int j=Min;j<=i/2;j++)
			{
				if(j!=i-j)
					ans+=num[i]*(num[i]-1)*num[j]*num[i-j]/2%mod;
				else if(num[j]>=2&&j*2==i)
					ans+=num[i]*(num[i]-1)*num[i/2]*(num[i/2]-1)/4%mod;
			}
			ans%=mod;
		}
	}
	cout<<ans;
}
```

---

## 作者：微香玉烛暗 (赞：50)

这道题是一道**排列组合**的的好题，主要思路：先用桶记录每个木棒长度出现的次数，然后进行枚举，用**组合数公式**推出即可。一般的话组合数我用杨辉三角，但是现在：

第一层枚举**木棒长度**，后面找**两根**两根一样长的。因此是$C(2,f[j])$，直接可化简为如下公式

### (f[i]*(f[i]-1)/2)*f[j]*f[i-j])

下面代码详解

```cpp
# include <cstdio>
# include <iostream>
# include <algorithm>
using namespace std;
const int N=100005;
const int mod=1e9+7;
int n,a[N],f[N],sum;
int s=1e9,e=-1e9;//分别是最小最大长度
long long ans;

int main () {
	scanf ("%d",&n);
	for (int i=1;i<=n;i++) {
		scanf ("%d",&a[i]);
		s=min(s,a[i]);
		e=max(e,a[i]);
		f[a[i]]++;//记录该长度出现次数
	}
	for (int i=s+1;i<=e;i++) {
		if (f[i]<=1) continue;//不可能组成三角
		for (int j=s;j<=i/2;j++)
			if (f[j]&&f[i-j])//能组成三角
				if (j!=i-j)
					ans=ans+((f[i]*(f[i]-1)>>1)*f[j]*f[i-j])%mod;//次数不相等
				else if (f[j]>=2)
					ans=ans+((f[i]*(f[i]-1)>>1)*(f[j]*(f[j]-1)>>1)%mod)%mod;//直接f[j]中取2
	}
	printf ("%lld\n",ans%mod);//输出即结束
	return 0;
}
```


---

## 作者：Mr_WA的大号 (赞：31)

因为聪明，所以我才橙名。小学生又来发题解了！

题号：P3799

算法：枚举，暴力，数组计数

难度：★★★

## 开课了！

这道题虽然只是一道枚举的题目，但也还是有点难的。先给大家介绍一下枚举。

枚举，在一个**有限**的区间里面逐个查找。这里强调一下有限的区间，如：1~100中的正整数，这是一个有限的区间。而1~10中的小数，是一个无限的区间。

这题很容易让人想到四重循环暴力枚举，但是数据不饶人，这样子时间复杂度是O(n^4)，而n最大是100000，所以很显然这是不行的。

我们又从数据发现，ai好像比较小，所以我们就应该从ai入手。正三角形他的三条边都一样长，我们要挑四条木棒，说明至少有两条边的长度相等，另外两条边的长度之和等于四条边总长度的三分之一。至于为什么，想必大家都可以自己推理出来。

我们要找哪两根或以上的木棍长度先等，就要使用到数组计数。ai当中从最小的到最大的循环，如果当前位置数组的量大于等于2，就开始从最小的ai到i枚举。至于具体怎样做，大家可以看我的代码上的批注。

**注意：统计的时候就要边统计边求余了，不然可能会爆掉。**

课讲完了，上代码：
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<string>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<iomanip>
using namespace std;
int n,b[5010],a[1000010],minn=1e9,maxx;
long long ans;
const int mod=1e9+7;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i];//输入
		minn=min(minn,a[i]);//找出最小的ai
		maxx=max(maxx,a[i]);//找出最大的ai
		b[a[i]]++;//数组计数
	}
	for(int i=minn+1; i<=maxx; i++)//这里从最小量+1开始枚举，是因为最小量不可能有两个比它更小的两组成
	{
		if(b[i]>1)//如果这个数字有一个以上
			for(int j=minn; j<=i/2; j++)//开始枚举
				if(b[j]>=1&&b[i-j]>=1)//如果他可以被两个比他小的两组成
				{
					if(j*2!=i)ans=(ans+(b[i]*(b[i]-1)/2)*b[j]*b[i-j]%mod)%mod;//统计
					else if(b[j]>1)ans=(ans+((b[i]*(b[i]-1)/2)*(b[j]*(b[j]-1)/2)%mod)%mod)%mod;//统计
				}
	}
	cout<<ans%mod;//输出
	return 0;
}
```
祝大家能AC!

---

## 作者：orangebird (赞：29)

良心满满的送分水题

4个木棒拼正三角形，就是2根一样长的和另外2根拼起来

木棒长度最大5000，可以用一个桶存下

枚举两根短的木棒的长度就可以了

核心代码：

```cpp
for(int i=1;i<=5000;i++)
for(int j=1;j<=5000;j++)
{
    if (i+j>5000) break;
    if (i==j) ans+=C(i,2) * C(i+j,2)
    else ans+=cnt[i]*cnt[j]*C(i+j,2)
}
```
完整代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<array>
#include<vector>
#include<map>
#define ll long long
#define ll long long
#define MOD 1000000007LL
using namespace std;
ll buc[5011];
int main()
{
    int n;
    scanf("%d",&n);
    while(n--)
    {
        int x;
        scanf("%d",&x);
        buc[x]++;
    }
    ll ans=0;
    for(int i=1;i<=5000;++i)
    {
        for(int j=i;j<=5000;++j)
        {
            if(i+j>5000)break;
            if(i==j)
            {
                if(buc[i]>=2&&buc[i<<1]>=2)
                ans=(ans+(buc[i]*(buc[i]-1)/2LL%MOD*(buc[i<<1]*(buc[i<<1]-1)/2)%MOD))%MOD;
            }else{
                if(buc[i]>=1&&buc[j]>=1&&buc[i+j]>=2)
                ans=(ans+(buc[i]*buc[j]%MOD*(buc[i+j]*(buc[i+j]-1)/2)%MOD))%MOD;
            }
        }
    } 
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：RemiliaScar1et (赞：13)

一道水题 ~~(还是做了一个小时，我太菜了~~

### 基本思路：
题里面说，4根棍子拼成一个正三角形（等边三角形）

若设这四根棍子长度为$a,b,c,d$且$a≥b>c≥d$

那很容易得到 ~~(真的很容易)~~:

$a=b=c+d$

自然，我们只需枚举$a$的长度和$c$的长度就行了

长度最长才5k，木棍用桶按长度装一下，遍历的时候也方便。

代码要好好看完啊kora
```cpp
#include <bits/stdc++.h>
#define c1(a) (a)//带参宏定义，本题不必写函数 
#define c2(a) ((a)*((a)-1)/2)
using namespace std;
const int mode=1000000007;
int aaa[5010];//桶 
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);//io流解绑 
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int k;
		cin>>k;
		aaa[k]++;//往桶里扔
	}
	int ans=0;
	for(int a=2;a<=5000;a++)
   {
			for(int c=1;c<=a/2;c++)//c最大只能到a的一半 
			{
				int d=a-c;//把d算出来判定相等 
				if(d!=c&&aaa[a]>=2&&aaa[c]>=1&&aaa[d]>=1)//c d不同 
				{
					ans+=((c2(aaa[a])%mode)*(c1(aaa[c])%mode)*(c1(aaa[d])%mode))%mode;
				}
				else if(d==c&&aaa[a]>=2&&aaa[c]>=2)//c d相同 
				{
					ans+=((c2(aaa[a])%mode)*(c2(aaa[c])%mode))%mode;
				}
				ans%=mode;
			}
	}
	cout<<ans%mode;//多模几次总没问题的 
	return 0;
}

```

---

## 作者：Terrible (赞：13)

这道题**纯暴力**是不行的，需要结合**组合数学**求解。
## 思路：
4根木棒组合成正三角形，那么一定是**2个小木棒**组成其中一边，另外两边是两个**相等的大木棒**。

把2个小木棒看成一个**整体**，和**大木棒**进行组合数求解即可。
#### 首先
我们需要两个桶：$x[i]$表示用2个小木棒（小是相对的）组合成长度为$i$的**整体组合种类数**，$y[i]$表示长度为$i$的**木棒数目**。
#### 然后
题目会给出$y[i]$，怎么求$x[i]$呢？

举个例子：$x[4]=y[1]*y[3]+C_{y[2]}^2$，其中$(y[2]\geq 2)$。

从长度为$1$的木棍中抽出一个，从长度为$3$的木棍中抽出一个，就可以组成长度为$4$的木棍，根据乘法原理相乘即可，然后加上从长度为$2$的木棍中抽出两个的种类数。

$x[i]$可以用递推式表示，分两种情况。

·两个**不同**木棍组合，$x[i+j]$+=$y[i]*y[j]$。其中$i<j$，避免重复计数；

·两个**等长**木棍组合,$x[2*i]$+=$C_{y[i]}^2$。其中$(y[i]\geq 2)$。
#### 最后
那么长度为$i$时，组合数即：从长度为$i$的木棍中抽出两个的种类数乘以$x[i]$，也就是$sum_i=C_{y[i]}^2*x[i]=\frac{y[i]*(y[i]-1)}{2}*x[i]$，其中$(y[i]\geq 2)$。

**枚举**长度$i$，计数得出结果。（**记得取模！**）
## 代码：
```cpp
#include<cstdio>
inline short read()//快读 
{
	register short a=0;register char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')a=a*10+(c^48),c=getchar();
	return a;
}
int x[5001],y[5001];
//x[i]表示两根小棍子总长度为i的组合数目
//y[i]表示一根棍子长度为i的数目 
//两根棍子组合长度超过5000不需要记录 
int main()
{
	int n;register int i,j,sum=0;
	scanf("%d",&n);
	for(i=0;i<n;i++)y[read()]++;
	//将棍子长度的数据装入桶里
	for(i=1;i<=2500;i++)
		for(j=i+1;j<=5000-i;j++)
			x[i+j]+=y[i]*y[j];
	//计算两个不等木棍的组合数目 
	for(i=1;i<=2500;i++)
		if(y[i]>1)
			x[2*i]+=y[i]*(y[i]-1)/2;
	//加上两个等长木棍的组合数目 
	for(i=1;i<=5000;i++)
		if(y[i]>1)
			sum+=y[i]*(y[i]-1)/2*x[i],sum%=1000000007;
	//求组合数，sum=y*(y-1)/2*x，还要记得取模！ 
	printf("%d",sum);
}
//PS：吸氧跑得还可以，100+ms
```


---

## 作者：dbxxx (赞：10)

[传送门](https://www.luogu.yom.yn/proxlem/P3799)
# 妖梦拼木棒

## 题目背景

上道题中，妖梦斩了一地的木棒，现在她想要将木棒拼起来。

## 题目描述

有 $n$ 根木棒，现在从中选 $4$ 根，想要组成一个正三角形，问有几种选法？ 

答案对 $10^9+7$ 取模。

## 输入输出格式

### 输入格式



第一行一个整数 $n$。 

第二行 $n$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 根木棒的长度。

### 输出格式



一行一个整数代表答案。

## 输入输出样例

### 输入样例 #1

```plwin
4
1 1 2 2
```

### 输出样例 #1

```plwin
1
```

## 说明

#### 数据规模与约定 

- 对于 $30\%$ 的数据，保证 $n \le 5 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，$0 \le a_i \le 5 \times 10^3$。

# 分析
首先，四根木棍要拼成正三角形，不难想到只有一种可能：两根木棍的长度相等，另外两根的长度和也和前面那两根木棍长度相等。

为了方便起见，我们把木棍从大到小长度命名为$w, x, y, z$，此时就有$w = x = y + z$。


那么此题的思路也就比较好想了，采用桶计数思想，记录每个长度出现的次数，然后枚举每一种可能的长度作为$w, x$，然后再在二层循环中枚举和为前两根木棍长度$w$（$x$也等效，因为$w = x$）的木棍$y, z$，然后再用乘法原理，组合数来计算新方案。同时，我们还设桶计数思想中的这个桶数组为$a$，也就是说，$a_i$代表长度为$i$的木棍数量。

但还是这个具体怎么计算呢？分为两种情况。

- $y \not= z$：这种情况就是在长度为$w$（$x$）取$2$根的方案数$\times$长度为$y$的木棍中取$1$根的方案数$\times$长度为$z$的木棍中取$1$根的方案数。因为$y \not= z$，长度为$y$的木棍中取$1$根的方案数和长度为$z$的木棍中取$1$根的方案数之间可以直接画乘号（互不干涉性）。这种方案的公式就是$C^2_{a_w} \times C^1_{a_y} \times C^1_{a_z}$。
- $y = z$：这种情况就是在长度为$w$（$x$）取$2$根的方案数$\times$长度为$y$（$z$）的木棍中取$2$根的方案数。这次$y = z$了，我们要放在一个地方中考虑。用公式表示就是$C^2_{a_w} \times C^2_{a_y}$

讲完思路，我们就上代码咯。

# 代码
```cpp
/*
 * @Author: crab-in-the-northeast 
 * @Date: 2020-04-06 00:25:54 
 * @Last Modified by: crab-in-the-northeast
 * @Last Modified time: 2020-04-06 10:23:32
 */
#include <iostream>
#include <cstdio>
#include <climits>

typedef long long ll;
const int mod = 1e9 + 7;
const int maxl = 5e3 + 5;

int a[maxl];

inline int max(int a, int b) {
    return a > b ? a : b;
}

inline int min(int a, int b) {
    return a < b ? a : b;
}

int main() {
    int n;
    ll ans = 0;
    std :: cin >> n;
    
    int begin = INT_MAX;
    int end = INT_MIN;

    for(int i = 1; i <= n; i++) {
        int len;
        std :: cin >> len;
        begin = min(begin, len);
        end = max(end, len);
        a[len]++;
    }

    for(int i = begin + 1; i <= end; i++) {
        if(a[i] > 1) {//数量必须>1，要不然凑不成前面的两根木棍
            for(int j = begin; j <= i / 2; j++) {
                if(a[j] && a[i - j]) {//看看是不是都有
                    if(j == i - j && a[j] >= 2)//如果两个是相等的，还需要注意这个够不够两根
                        ans = ans + ((a[i] * (a[i] - 1) >> 1) * (a[j] * (a[j] - 1) >> 1) % mod) % mod;
                    else if(j != i - j)//要特别注意这个if，因为上边的条件中如果j == i - j但是a[j] < 2仍然会来到这个分支，所以我们必须保证j != i - j才能进行下一步计算
                        ans = ans + ((a[i] * (a[i] - 1) >> 1) * a[j] * a[i - j]) % mod;      
                }
                ans %= mod;
            }
        }
    }

    std :: cout << ans << std :: endl;
    return 0;
}
```

# 评测结果
- WA 70：[R32516251](https://www.luogu.com.cn/record/32516251)（在条件分支处没有注意`else if(j != i - j)`这个不能去掉后面的`if`
- AC 100：[R32516573](https://www.luogu.com.cn/record/32516573)


---

## 作者：Limit (赞：7)

# 题目大意

给出 $N$ 根木棒,求出在这些木棒中选出 $4$ 根组成等腰三角形的方案数.

# 分析

四根木棒要组成一个等腰三角形只有当两根木棒的长度相同,另外两根木棒的长度和与这两根木棒长度相同时才行.

于是可以预处理一个数组 $p$,$p_i$ 表示选两根木棒的长度和为 $i$ 的方案数,这样对于长度为 $k$ 的等腰三角形的个数就是 $C_{sum_k}^2\times p_k$,于是最后的答案就是 $\sum_{k=1}^{5000}C_{sum_k}^2\times p_k$了,具体计算部分放在代码中讲解.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=1e4+7;
const long long mod=1e9+7;
int N;
int sum[MAXN];//记录每个长度出现的次数
long long p[MAXN];
int main()
{
	scanf("%d",&N);
	int len;
	REP(i,1,N)
	{
		scanf("%d",&len);
		sum[len]++;
	}
	REP(i,1,2500)
	{
		p[i*2]+=1ll*(sum[i]*(sum[i]-1)/2);//对于长度为i的木棒对于长度为i*2的贡献即使在这些木棒中选出两根的方案数
		p[i*2]%=mod;
		REP(j,i+1,5000-i)
		{
			p[i+j]+=1ll*sum[i]*sum[j];//如果不一样就可以直接用乘法原理
			p[i+j]%=mod;
		}
	}
	long long answer=0;
	REP(i,1,5000)
	{
		answer+=(1ll*sum[i]*(sum[i]-1)/2)%mod*p[i]%mod;//对于长度为i的等腰三角形的计算就直接套用分析中的公式
		answer%=mod;
	}
	printf("%lld",answer);//输出
	return 0;
}
```

---

## 作者：XERIN (赞：7)

**第一篇题解不知道能不能过**
 
看了大佬的题解才写出来的，原本打算把组合列出来然后一个个判断是不是等边三角形的，后来才发现还要用到数学


------------
```java
import java.util.Scanner;

public class Main {
	
	static Scanner sc;
	static int MO = 1000000007;
	static int n;//n个数
	static int[] num;//存储每个数字出现的个数
	static int max = 0;//存储木棍长度最大值
	static int temp;//临时变量存储sc.nextInt()
	static int sum = 0;
	
	
	public static void main(String[] args) {
		//初始化
		sc = new Scanner(System.in);
		n = sc.nextInt();
		num = new int[5001];
		
		for (int i = 0; i < n; i++) {
			temp = sc.nextInt();
			if (temp > max) {
				max = temp;
			}
			num[temp]++;
		}
		
		/**
		 * 易知:a=b=c+d
		 * 一、即先取两支一样长且长度为i的木棍
		 * 二、再从比i长度小的木棍取两支木棍j、i-j
		 * 	  ①j == i-j,从相同长度木堆取两个
		 * 	  ②j != i-j,从不同长度两个木堆分别取一个
		 * 	  ③为避免取重复,应控制 j < i - j,即j < i / 2
 		 */
		
		//如果从长度为1的木堆开始取两个,很明显没有这种情况,因此从长度为2的木堆开始取
		for (int i = 2; i <= max; i++) {
			if (num[i] >= 2) {//此木堆超过两支木棍
				 int fs = C(num[i], 2) % MO;
				//取完两支长短一样的木棍后,开始取另外两根长度未知的
				for (int j = 1; j <= i / 2; j++) {
					//1、长度一样;那么就在同一木堆取两个
					if (j == i - j && num[j] >= 2) {
						sum = (sum + fs * C(num[j], 2)) % MO;
					}
					//2、长度不一样;那么就在两个不同木堆分别取一个
					if (j != i - j && num[j] >= 1 && num[i-j] >= 1) {
						sum = (sum + fs * C(num[j], 1) * C(num[i-j], 1)) % MO;
					}
				}
			}
		}
		
		System.out.println(sum);
	}

	// 求组合数
	// 要么C(n,1) 要么C(n,2)
	public static int C(int k, int r) {
		if (r == 1) {
			return k % MO;
		}
		return (k * (k - 1) / 2) % MO;
	}
}

```


---

## 作者：bjrjk (赞：4)

这道题注意两个点：

1、没有必要专门为计算组合单写一个递归函数，这道题里只用得到$$C^1_n$$和$$C^2_n$$，直接手打define宏就好；

2、如果枚举大棍长度和小棍长度之一的话，一定要注意判断，小棍长度循环时只能到大棍长度的一半，避免重复计算！

看代码：

```cpp
#include<iostream>
using namespace std;
#define MOD 1000000007 //1e9+7
#define C1(x) (x) //C(1,x)
#define C2(x) ((x)*((x)-1)/2) //C(2,x)
int n;
long long arr[5005]; //桶排序
long long sum;
int main(){
    ios::sync_with_stdio(false); //关闭同步
    cin >> n;
    for (int i = 1; i <= n; i++){
        int t;
        cin >> t;
        arr[t]++;
    }
    for (int a = 2; a <= 5000; a++){
        for (int c = 1; c <= a/2; c++){ //注意只能循环到a/2
            int d = a - c; //分c,d是否相同讨论
            if (d != c){ 
                if (arr[a] >= 2 && arr[c] >= 1 && arr[d] >= 1)
                    sum += ((C2(arr[a]) % MOD)*(C1(arr[c]) % MOD)) % MOD*(C1(arr[d]) % MOD) % MOD;
            }
            else{
                if (arr[a] >= 2 && arr[c] >= 2)
                    sum += (C2(arr[a]) % MOD)*(C2(arr[c]) % MOD) % MOD;
            }
            sum %= MOD;
        }
    }
    cout << sum;
}
```

---

## 作者：raincity (赞：3)

## 题意简述
求在$n$个数中选4个数$x_1,x_2,x_3,x_4$，使$x_1=x_2=x_3+x_4$的方法数$mod$ $10^9+7$的余数。

## 分析
第一反应：四层循环枚举。然而如果这么简单就应该是红题了。$\color{white}\colorbox{black}{TLE}$。

第二反应：$0 \le a_i \le 5 \times 10^3$，范围这么小？感觉可以用桶。那么我们可以$O(range)$枚举$x_1$和$x_2$的取值，接着我们需要在这个取值的所有数中选出两个（无序），设有$k$个，那么有$C_k^2 = \dfrac{k \times (k-1)}{2}$种方法。


接着呢？我们还需要知道$x_3$和$x_4$。它们是等价的，不妨设$x_3 \le x_4$。如果$2|x_1$ 且 $x_3=x_4$，那么我们只需要在$\dfrac{x_1}{2}$的个数$m$种无序取出2个数，有$C^2_m = \dfrac{m \times (m-1)}{2}$种方法。如果$x_3 \not = x_4$，那么枚举$x_3$的数值，则$x_4=x_1-x_3$。设有$a$个数等于$x_3$，$b$个数等于$x_4$，那么就有$\dfrac{a \times b}{2}$种方法(无序)。

所以，我们设$S(x)$表示等于$x$的数的个数，则$ans=\sum^{\max{a_i,1 \le i \le n}}_{j=1} C_{S(j)}^2 \times [\sum_{k=1}^{[\frac{j-1}{2}]} S(k) \times S(j-k)]+\sum^{[\frac{n}{2}]}_{i=1} C_{S(i \times 2)}^2 \times C^2_{S(i)}$ 。时间复杂度为$O(range^2)$。$\color{white}\colorbox{green}{AC}$！

（这个式子有点~~恶心~~长，可以跳过，直接看代码）

## 解决

上代码：

```cpp
#include <iostream>
#include <cmath>
#define int long long

using namespace std;

const int MOD = 1e9 + 7, W = 5e3 + 5;
int n, x, sum[W], ans, maxi;

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x;
		maxi = max(maxi, x);
		sum[x]++;
	}
	for (int i = 1; i <= maxi; i++) {
		int cur = sum[i] * (sum[i] - 1) / 2 % MOD, s = 0;
		for (int j = 1; j * 2 <= i; j++)
			if (j * 2 == i)
				s = (s + sum[j] * (sum[j] - 1) / 2) % MOD;
			else 
				s = (s + sum[j] * sum[i - j]) % MOD;
		ans = (ans + cur * s) % MOD;
	}
	cout << ans << endl;
	return 0;
}
```

#### THE END

---


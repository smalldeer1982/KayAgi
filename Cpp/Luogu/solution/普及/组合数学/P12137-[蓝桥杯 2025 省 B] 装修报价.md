# [蓝桥杯 2025 省 B] 装修报价

## 题目描述

老王计划装修房子，于是联系了一家装修公司。该公司有一套自动报价系统，只需用户提供 $N$ 项装修相关费用 $A_1, A_2, \dots , A_N$，系统便会根据这些费用生成最终的报价。

然而，当老王提交数据后，他发现这套系统的运作方式并不透明：系统只会给出一个最终报价，而不会公开任何运算过程或中间步骤。

公司对此解释称，这套系统会依据某种内部算法，在每对相邻数字之间插入 $+$（加法）、$-$（减法）或 $\oplus$（异或）运算符，并按照特定优先级规则计算结果：异或运算优先级最高，其次是加减。但由于保密性，具体的运算符组合以及中间过程都不会对外公开。

为了验证系统报价是否合理，老王决定模拟其运作方式，尝试每种可能的运算符组合，计算出所有可能出现的结果的总和。如果最终报价明显超出这个范围，他就有理由怀疑系统存在异常或误差。只是老王年事已高，手动计算颇为吃力，便向你求助。

现在，请你帮老王算出所有可能的结果的总和。由于该总和可能很大，你只需提供其对 $10^9+7$ 取余后的结果即可。

## 说明/提示

对于输入样例中的三个数 $A = [0, 2, 5]$，所有可能的运算符组合共有 $9$ 种。计算结果如下：

$$0 \oplus 2 \oplus 5 = 7$$
$$0 \oplus 2 + 5 = 7$$
$$0 \oplus 2 - 5 = -3$$
$$0 + 2 \oplus 5 = 7$$
$$0 + 2 + 5 = 7$$
$$0 + 2 - 5 = -3$$
$$0 - 2 \oplus 5 = -7$$
$$0 - 2 + 5 = 3$$
$$0 - 2 - 5 = -7$$

所有结果的总和为：

$$7 + 7 + (-3) + 7 + 7 + (-3) + (-7) + 3 + (-7) = 11$$

$11$ 对 $10^9 + 7$ 取余后的值依然为 $11$，因此，输出结果为 $11$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N \leq 13$，$0 \leq A_i \leq 10^3$。
- 对于 $60\%$ 的评测用例，$1 \leq N \leq 10^3$，$0 \leq A_i \leq 10^5$。
- 对于 $100\%$ 的评测用例，$1 \leq N \leq 10^5$，$0 \leq A_i \leq 10^9$。

## 样例 #1

### 输入

```
3
0 2 5```

### 输出

```
11```

# 题解

## 作者：SDSXC (赞：34)

首先我们注意到，因为符号有加有减，所以将某一项前面的正负号反转其他的都不变就一一对应到了负的这一项，所以除了第一项前面的符号不能翻，每一项的贡献都是 $0$。

于是有贡献的只有从第一项开始，中间全填 $\oplus$ 的项。只需要求出对于 $A_{[1,k]}$ 每个构成的这一项，他一共贡献了多少次即可。$A_k$ 与 $A_{k+1}$ 之间必须是加或减，后面的随便填，一共是 $2\times 3^{n-k-1}$ 次，注意最后一项只有 $1$ 的贡献需要特判。预处理 $3$ 的幂次，再结合前缀和就 $O(n)$ 的解决了这个问题。以上就足以通过此题。

虽然时间复杂度到瓶颈了，但是空间上还可以再优化。我们设 $S_k=\bigoplus_{i=1}^k A_i$，只考虑前 $k$ 项时答案为 $Ans_k$，由之前的推导不难发现递推式 $Ans_k=3Ans_{k-1}-S_{k-1}+S_k$。于是就做到了 $O(n)$ 时间，$O(1)$ 空间。

213B，目前最短的 AC 代码。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define p 1000000007ll
using namespace std;
ll ans=0,sum=0;int n;
int main(){
	cin>>n;for(int i=1,x;i<=n;i++)cin>>x,ans=(ans*3-sum+(sum^=x)+p)%p;cout<<ans;
	return 0;
}
```

---

## 作者：vegetableYe (赞：22)

我们考虑枚举所有操作符，一共只有 $3^{n-1}$ 种，然后暴力求解即可。

正解：

我们考虑给式子的第一个值前面也补上符号，实际上就是 $+$ 。

例如：$2-3\oplus4$ 实际上是 $+2-3\oplus 4$。

由于本题中异或运算的优先级更高，因此我们将一串异或运算的结果合并成一个数字。这样一来，我们的式子就只剩下了 $+$ 和 $-$。

接下来我们就会发现，由于所有的 "$+$XXX" 和 "$-$XXX" 都会在不同的式子中同时出现，因此其贡献会抵消（这一点在题目的样例解释中就可以看得很清楚）。

因此对答案产生贡献的，只有一段前缀的异或，因为这一段异或对应的运算符实际上是我们一开始就提到的最前面被"隐藏"起来的 $+$。这一段是不存在 $-$ 将其抵消的。

因此我们枚举前缀异或的长度 $i$，统计其贡献即可，其贡献就是：首先 $i+1$ 位置的运算符不能是异或（因为这样一来前缀异或的长度就不是 $i$ 而至少是 $i+1$ 了），接着 $i+2$ 包括后面的运算符都可以任取三种。

因此对于每个前缀异或，其贡献为：$pre\_xor\times2 \times 3^{n-i-1}$。

注意第 $n$ 个位置的贡献需要特判，为所有数字的异或。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
typedef unsigned long long ull;
typedef __int128 lll;
typedef pair<ll, ll> P;
#define x first
#define y second
#define int long long
using i64 = long long;

const int mod = 1e9 + 7;
const int MOD = 998244353;

ll ksm(ll a, ll b, ll p) {
    ll ans = 1;
    a %= p;
    while(b) {
        if(b & 1) ans = (ans * a) % p;
        b >>= 1;
        a = (a * a) % p;
    }
    return ans % p;
}



void solve() {
    int n;
    cin >> n;
    int S = 0;
    int ans = 0;
    for(int i = 1, x; i <= n; i++) {
        cin >> x;
        S ^= x;
        if(i < n) {
            ans += S * 2 * ksm(3LL, n - i - 1, mod) % mod;
        } else {
            ans += S;
        }
        ans %= mod;
    }
    cout << ans << endl;
}

/*



*/

signed main () {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int _ = 1;
    // cin >> _;
    while(_ -- ) {
        solve();
    }
    return 0;
}
```

时间复杂度：$O(n\times \log(A))$。（$\log$ 的复杂度源自快速幂，这一步可以通过预处理的方式省略，也就是说本题可以做到 $O(n)$。）

---

## 作者：FTW_H (赞：3)

# **题目概括**

共 $n$ 个数，相邻两个数之间插入 $+$、$-$、$⊕$ 三种运算符之一，考虑所有可能的情况，将不同式子的结果相加。

# **初步思路**

本人首先想到的还是暴力枚举。共 $n$ 个数，有 $n-1$ 个空可以插入运算符，则有 $3^{n-1}$ 种可能的运算符组合，即不同算式的数量，要遍历每种情况计算结果再相加吗？No！因为 $n$ 最大为 $10^{5}$，必然会超时。所以，不妨再观察一下该题！

# **观察优化**

对于非异或的部分（即加减法部分），$+$ 和 $-$ 是等概率出现的，它们的期望贡献会相互抵消，如 $a⊕b+c$ 和 $a⊕b-c$ 会相互抵消 $c$ 的贡献，因此只有 $a⊕b$ 部分对总和有贡献。所以，只有“异或前缀”会对最终的总和产生贡献。异或前缀是指从序列开头直到运算符不为 $⊕$ 之间的所有数字的异或结果，换句话说，异或前缀的结束位置必须是一个“加减法边界”或序列末尾，如 $a⊕b⊕c+d-e$ 的贡献是 $a⊕b⊕c$ 的异或结果，后面的加减法部分会抵消。此题转化为：计算所有可能的运算符组合中，每个“异或前缀”对总和的贡献。

>总贡献：每个异或前缀×其存在的组合数量，
即：$ans=\sum_{i=1}^{n}(pre[i]×cnt[i])$。

>其中，$pre[i]=a_{1}⊕a_{2}⊕...⊕a_{i}$,
>>当 $i<n$ 时，$cnt[i]=2×3^{n-i-1}$；
>>
>>当 $i=n$ 时，$cnt[i]=1$。

**说明**：为什么 $cnt[i]=2×3^{n-i-1}$ 或 $1$？

①对于 $i<n$，因为 $a_{1}$ 至 $a_{i}$ 是异或前缀，所以在 $a_{i}$ 和 $a_{i+1}$ 之间必须插入 $+$ 或 $-$（$2$ 种选择）。对于剩下的 $n-i-1$ 个空隙（即 $a_{i+1}$ 到 $a_{n}$ 之间），每个空隙有 $3$ 种选择，因此 
$cnt[i]=2×3^{n-i-1}$；

②对于 $i=n$，无后续运算符可选，因此贡献数量为 $1$。

该解法的时间和空间复杂度均为 $O(n)$。

# **注意事项**

我在写代码时遇到的问题：在计算 $3^{n-i-1}$ 时图方便直接使用了函数 `pow(a,b)`，这是不行的！`pow(a,b)` 返回的是 `double` 类型，而 `double` 的精度有限（约 15-17 位有效数字），若 `b` 很大，结果会超出`double`的精确表示范围。直接选用快速幂，无精度问题，且边计算边取模，避免溢出。

# **C++代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long; 
const ll m=1e9+7;
ll n,fare[100005],ans;
ll pre[100005],cnt[100005];//分别记录异或前缀,贡献数量
ll quike(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1){
			ans=(ans*a)%m;//必须边乘边取模,否则会溢出!
		}
		a=(a*a)%m;
		b>>=1;
	}
	return ans;
}

int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>fare[i];
	}
	//枚举:从开头到第`i`个数之间的符号都是异或 
	for(ll i=1;i<=n;i++){
		
		//只有异或前缀会对总和产生贡献,而非异或部分的期望贡献会相互抵消 
		pre[i]=pre[i-1]^fare[i];
		
		//贡献的数量,分`i<n`和`i=n`两种情况 
		if(i<n){
			cnt[i]=2*quike(3,n-i-1);//不能直接用`pow(a,b)` 函数,否则会溢出!
		}else{
			cnt[i]=1;
		}
	}
	//计算总和
	for(ll i=1;i<=n;i++){
		ans = (ans + pre[i] * cnt[i]) % m;
		//不能写`ans += (pre[i] * cnt[i]) % m`,未给 `ans`取模,仍会溢出! 
	}
	cout<<ans;
	return 0;
}
```
欢迎学习编程的同胞们参考与指正！

辛苦亲爱的管理员大大了！

---

## 作者：渡墨残殇 (赞：3)

## 题意简述
题目本质上是让我们枚举出所有合法的括号表达式结构，在每一对相邻数字之间放置「+」「-」「⊕」三种操作符，并求出这些所有表达式的最终计算结果的和。最后对 $10^9+7$ 取模。

## 题目分析
观察到，对于每一个位置均可以填 「+」「-」「⊕」三种操作符，那方案数就是 $3^{n-1}$，时间复杂度必然是过不去的。可以观察到，对于一个位置如果填「+」，那么就必然存在 「-」会使得该位置后添加的数产生一个无贡献的情况，这种情况对于答案的贡献就是前面一些数的异或和。只需要维护一个异或前缀和，枚举第 $i$ 位置填非 「⊕」位置的所有方案数产生的贡献，即
$$
res_i = sum⊕_{i} \times 2 \times 3^{i-1}
$$
预处理出来 $3$ 的指数幂，时间复杂度 $O(n)$。
## 赛时代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N = 123456;
const int mod=1e9+7;
int n;
int a[N];
int _3[N];
int ans=0;
void init()
{
	int res=1;
	for(int i=1;i<=n;i++)
	{
		res=(res*3)%mod;
		_3[i]=res;
	}
	_3[0]=1;
} 
signed main ()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	init();
	int ans=0;
	int k=0;
	for(int i=1;i<=n-1;i++)
	{
		k^=a[i];
		ans=(ans+k*2*_3[n-i-1])%mod;
		//cout<<ans<<"\n"; 
	}
	k^=a[n]; 
//	cout<<k<<"\n";
	ans=(ans+k)%mod;
	cout<<ans;
	return 0;
} 
```

---

## 作者：粥2414 (赞：1)

# 思路
暴力枚举是肯定不行的，需要优化。

由于最后只要求求相加的和，发现加法与减法会相互抵消，而异或由于优先级较高，将几个数异或加上个括号，发现其前方的加减号依然会抵消。所以大多数情况是不用考虑的。

唯一的例外是首位，它的前方只能是加号，所以只考虑首位以及与首位关联的异或即可。

枚举从首位开始的异或前缀和。设当前枚举到第 $i$ 位，显然第 $i+1$ 位只能取加减号，后面可以取三种符号任意一个，贡献答案的次数显然为 $2\cdot3^{n-i-1}$，快速幂优化即可。  
注意特判 $n-i\le0$ 的情况。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1e5+9,MOD=1e9+7;
ll n,a[N];
ll ans;
inline ll qp(ll a,ll b){
	ll res=1;
	while(b){
		if(b&1)res=(res*a)%MOD;
		a=(a*a)%MOD,b>>=1;
	}
	return res;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	ll sum=0;
	for(int i=1;i<=n;i++){
		sum^=a[i];
		if(n-i>0)ans+=sum*2*qp(3,n-i-1);
        else ans+=sum;
		ans%=MOD;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Levisuper (赞：1)

由于异或的优先级最高，我们可以将表达式划分为若干个异或和的加减运算，这里我们仅考虑划分为 $s + x$，其中 $x$ 表示最后一段异或和，$s$ 表示除了 $x$ 的前缀和。

考虑 $\rm{dp}$ 维护三个信息：
- $dps[i]$ 表示 $[0, i)$ 里的所有添加方案的前缀和之和 $s$；
- $dpx[i]$ 表示 $[0, i]$ 里所有添加方案的后缀异或和之和；
- $cnt[i]$ 表示向 $[0, i]$ 添加运算符的合法方案数。

考虑想要在 $i$ 之后插入运算符的状态转移。

- 若为 $+$，则应该有
  - $dps[i + 1] = dps[i] + dpx[i]$，表示将上文中的 $s + x$ 加入总和；
  - $dpx[i + 1] = cnt[i] \times A[i + 1]$，表示后缀异或和换成单独的一个 $A[i + 1]$，不过要乘上方案数 $cnt[i]$。
- 若为 $-$，则应该有
  - $dps[i + 1] = dps[i] + dpx[i]$，表示将上文中的 $s + x$ 加入总和；
  - $dpx[i + 1] = cnt[i] \times -A[i + 1]$，表示后缀异或和换成单独的一个 $A[i + 1]$，不过要乘上方案数 $cnt[i]$。
- 若为 $\oplus$，则应该有
  - $dps[i + 1] = dps[i]$，表示将上文的 $s$ 加入总和；
  - $dpx[i + 1] = dpx[i] \oplus A[i + 1]$，表示所有后缀异或和都需要再异或一个 $A[i + 1]$。

三者合起来，发现 $cnt[i]$ 抵消，不用维护，得到最终的转移方程。
- $dps[i + 1] = 2(dps[i] + dpx[i]) + dps[i],$
- $dpx[i + 1] = dpx[i] \oplus A[i + 1].$

初始状态。
- $dps[0] = 0,$
- $dpx[0] = A[0].$

最终答案为 $dps[N - 1] + dpx[N - 1]$。

### 时间复杂度 $O(n)$

### C++ Code
```cpp
#include <bits/stdc++.h>

using i64 = long long;

template<class T>
std::istream &operator>>(std::istream &is, std::vector<T> &v) {
    for (auto &x: v) {
        is >> x;
    }
    return is;
}

template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
     
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998244353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1000000007;
using Z = MInt<P>;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int N;
    std::cin >> N;

    std::vector<int> A(N);
    std::cin >> A;

    std::vector<Z> dps(N);
    std::vector<int> dpx(N);
    dpx[0] = A[0];

    for (int i = 0; i + 1 < N; i++) {
        dps[i + 1] += 2 * (dps[i] + dpx[i]) + dps[i];
        dpx[i + 1] = dpx[i] ^ A[i + 1];
    }
    std::cout << dps.back() + dpx.back() << "\n";
    
    return 0;
}
```

---


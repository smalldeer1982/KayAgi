# [蓝桥杯 2022 省 Python B] 全排列的价值

## 题目描述

对于一个排列 $A=(a_1,a_2,\cdots,a_n)$，定义价值 $c_i$ 为 $a_1$ 至 $a_{i-1}$ 中小于 $a_i$ 的数的个数，即 $c_i=|\{a_j|j<i,a_j<a_i\}|$。定义 $A$ 的价值为 $\displaystyle \sum_{i=1}^{n}c_i$。

给定 $n$，求 $1$ 至 $n$ 的全排列中所有排列的价值之和。

## 说明/提示

### 样例说明

$1$ 至 $3$ 构成的所有排列的价值如下:

$$\begin{aligned}& (1,2,3): 0+1+2=3 \\& (1,3,2): 0+1+1=2 \\& (2,1,3): 0+0+2=2 \\& (2,3,1): 0+1+0=1 \\& (3,1,2): 0+0+1=1 \\& (3,2,1): 0+0+0=0\end{aligned}$$

故总和为 $3+2+2+1+1=9$。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n \leq 20$；
- 对于 $70\%$ 的评测用例，$n \leq 5000$；
- 对于所有评测用例，$2 \leq n \leq 10^6$。

## 样例 #1

### 输入

```
3```

### 输出

```
9```

## 样例 #2

### 输入

```
2022```

### 输出

```
593300958```

# 题解

## 作者：_DATA_X_ (赞：6)

# P12369 题解

## 题目大意：

给你一个 $n$，求 $n$ 的全排列中所有逆序对之和。

## 公式推导：

给定一个排列 $A=(a_1,a_2,...a_n)$ ，其价值定义为：
$$
A= \sum_{i = 1}^{n} \ C_i
$$
其中 $C_i$ 是 $a_1$ 到 $a_{i-1}$ 中小于 $a_i$ 的数的个数。

### 推导过程：

#### 顺序对的定义：
* 对于排列 $A$，顺序对是指满足 $i<j$ 且 $a_i<a_j$ 的对 $(i,j)$。
* 每个顺序对 $(i,j)$ 会贡献到 $C_j$ 的值中。

#### 顺序对的总数：

* 在所有排列中，顺序对 $(i,j)$ 出现的概率是 $\frac{1}{2}$，因为 $a_i$ 和 $a_j$ 的大小关系是等概率的。


* 总共有 $
\begin{pmatrix}
  n \\
  2 \\
\end{pmatrix}=\frac{n(n-1)}{2}
$ 个可能的位置对。
   
* 因此，所有排列中顺序对的总数为：

$$
\begin{pmatrix}
  n \\
  2 \\
\end{pmatrix}\times n! \times \frac{1}{2}=\frac{n(n-1)}{2}\times n! \times \frac{1}{2}=\frac{n(n-1) \times n!}{4}
$$

#### 价值之和：

* 每个顺序对的价值为 $\frac{n\times (n-1)}{4}$。
* 总共有 $n!$ 个顺序对，价值之和为 $\frac{n!\times n\times (n-1)}{4}$。
* 由于结果可能很大，我们需要对 $998244353$ 取模。注意到 $\frac{1}{4}\bmod 998244353$ 的逆元是 $748683265$，因为 $4\times 748683265\equiv1 \pmod{998244353} $。
因此，最终公式为：
$$
  n!\times n\times (n-1)\times  74868326\bmod 998244353
$$
$$
## 主要思路：

首先读取整数 $n$，如果 $n<2$ 直接输出 $0$ 并结束程序，否则计算 $n$ 的阶乘 $sum$（每次计算都取模防止溢出），最后套公式计算并输出结果。

## 代码实现：

~~码风很烂，dalao 勿喷。~~

### C++：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
const int N=748683265;//mod 的模逆元
int n;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	if(n<2)//特判{
		cout<<0<<endl;
		exit(0);
	}
	int sum=1;//阶乘
	for(int i=1;i<=n;i++){
		sum=sum*i%mod;
	}
	cout<<sum*n%mod*(n-1)%mod*N%mod;//打印结果。
	return 0;
} 
``````

### Python：
```python
OD = 998244353

n = int(input())
if n == 1:
    print(0)
    exit()

fact = [1] * (n + 1)
for i in range(1, n + 1):
    fact[i] = fact[i - 1] * i % MOD

inv_fact = [1] * (n + 1)
inv_fact[n] = pow(fact[n], MOD - 2, MOD)
for i in range(n - 1, -1, -1):
    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

def comb(a, b):
    if a < 0 or b < 0 or a < b:
        return 0
    return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD

res = 0
for k in range(1, n + 1):
    term = comb(n, k) * fact[k - 1] % MOD
    term = term * fact[n - k] % MOD
    term = term * (k * (k - 1) // 2) % MOD
    res = (res + term) % MOD

print(res)
``````

---

## 作者：cold_jelly (赞：4)

[可能更好的阅读体验](https://www.cnblogs.com/cold-jelly/p/18868515)

思考价值的本质是什么，发现其实就是把逆序对数换了个说法嘛。所以题目其实是让我们求长度为 $n$ 的所有排列的逆序对数总和。

直接求肯定是不行的，考虑如何快速计算答案。发现答案可以分拆为两个子问题答案的乘积：求解单个数对贡献以及数对的数量。

考虑单独计算数对 $(i,j)$ 产生的贡献。由于 $i$ 和 $j$ 的相对位置可以自由变换，所以 $(i,j)$ 有 $\dfrac{1}{2}$ 的概率是逆序对。全排列总数为 $n!$，那么 $(i,j)$ 的贡献即为 $\dfrac{n!}{2}$ 啦。

接下来考虑这样的数对一共有多少个。这其实等价于求在 $n$ 个互不相同的小球中选 $2$ 个小球的方案数，即 $\displaystyle \binom{n}{2}=\dfrac{n!}{2!(n-2)!}=\dfrac{n(n-1)}{2}$。

于是答案为：$ans=\dfrac{n!}{2}\times \dfrac{n(n-1)}{2}=\dfrac{n!n(n-1)}{4}$。

阶乘部分预处理即可，除法用费马小定理算逆元。注意取模要勤快。

附 AC 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define _ 0
using namespace std;
const int N = 1e6 + 10, mod = 998244353;
int n;
int fac[N];//阶乘 
int qp(int a, int b, int p)//快速幂 
{
	int res = 1;
	while(b)
	{
		if(b & 1) res = res * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return res;
}
void initfac()//预处理阶乘 
{
	fac[0] = 1;
	for(int i = 1; i < N; i ++)
		fac[i] = fac[i - 1] * i % mod;
}
signed main()
{
	initfac();
	cin >> n;
	cout << fac[n] * n % mod * (n - 1) % mod * qp(4ll, mod - 2, mod) % mod;
	return (0^_^0);
}
```

---

## 作者：l15130880055 (赞：4)

## P12369 [蓝桥杯 2023 省 Python B] 全排列的价值 题解

### Problem
给你一个 $n$，求 $n$ 的全排列中所有逆序对之和。

### Solution
对于一个序列，满足条件的 $i, j$ 显然有 $\frac{n \times (n-1)}{2}$ 对，而对于全排列，这个 $i, j$ 是逆序对的均摊下来肯定是全部的一半，而一个序列有 $n!$ 个全排列，所以对于每个 $n$，答案即为 $n! \times \frac{n \times (n-1)}{2} \times \frac{1}{2}$，即为 $n! \times \frac{n \times (n-1)}{4}$。

当然如果你和我一样是一名 C++ 玩家，因为要取模，直接除是错的，所有要乘上 $4$ 在模 $998244353$ 意义下的逆元，注意别乘炸了。

时间复杂度 $O(n)$，瓶颈在于求阶乘。
### Code

```cpp
#include <bits/stdc++.h>
#define int long long
int n;
constexpr int mod = 998244353;
inline int qpow(int x, int y){
	int ret = 1;
	while(y){
		if(y & 1) ret = ret * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ret;
}
int32_t main(){
	std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false);
	int facn = 1;
	std::cin >> n;
	for(int i = 1; i <= n; i++) facn = facn * i % mod;
	std::cout << facn * n % mod * (n - 1) % mod * qpow(4ll, mod - 2) % mod << '\n';
	return 0;
}
```

---

## 作者：dg114514 (赞：2)

注意到题面中的“价值”其实就是逆序对数量。在全排列里面，任意两个元素 $i,j$ 在所有排列中 $i$ 在 $j$ 前面的概率为 $\frac{1}{2}$，也就是说，在一个排列里面，这对数对答案的期望贡献为 $\frac{1}{2}$。因为全排列其实相当于是把一个长度为 $n$ 的所有的可能的排列都列出来，概率均等，而全排列共有 $n!$ 个。所以每对 $i,j$ 都会对答案产生 $\frac{1}{2}\times n!=\frac{n!}{2}$ 的贡献。然后统计所有的这样的可能的 $i,j$，显然，这个等价于 $\binom{n}{2}=\frac{n(n-1)}{2}$。所以答案为 $\frac{n(n-1)}{2}\times\frac{n!}{2}=\frac{n(n-1)n!}{4}$。除法这部分需要逆元，当然也可以用 Python 直接高精度计算。

---

## 作者：zhanghy123 (赞：1)

## P12369 [蓝桥杯 2022 省 Python B] 全排列的价值 题解
### 思路
分享一种不用逆元的做法。

考虑线性递推。设答案为 $f(n)$，那么对于前面已知的 $f(n-1)$，设它的一种全排列方式为 $a_1,a_2,a_3,\cdots,a_{n-1}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/nqzivojj.png)

如图，将 $n$ 的增加视为向这个排列内**插入**一个 $n$，算上该序列的头尾，共有 $n$ 个位置可以插，插在第 $k$ 个位置上的贡献即为**该位置前方元素的数量**，即 $k-1$（因为这时 $n$ 一定是最大的，前面的所有元素都比它小，后面的所有元素都没它大，所以只对前面有影响）。因此该排列下插入带来的贡献为：

$$\sum^n_{k=1}k-1=\dfrac{n(n-1)}{2}$$

~~（挺显然的说是…）~~

每次不同的插入方法都视为一种答案，$n$ 种方法，就需要将原答案数乘 $n$。在 $n-1$ 下的 $(n-1)!$ 个排列都得计算一遍，合起来就是总答案的 $n$ 倍与插入带来的总贡献 $\dfrac{n(n-1)}{2}(n-1)!$ 之和。初始的状态为 $n=2$，答案显然为 $1$。于是我们即可得到递推式：

$$f(n)=\begin{cases}
1 & n=2\\
nf(n-1)+\dfrac{n(n-1)}{2}(n-1)! & n>2
\end{cases}$$

时间复杂度 $O(n)$。阶乘采用预处理。

### C++
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=1e6+5,mod=998244353;
ll n,ans[N],jc[N]={1,1};
int main()
{
	cin>>n;
	ans[2]=1;
	for(int i=1; i<=N; i++)
		jc[i]=jc[i-1]*i%mod;//阶乘预处理
	for(int i=3; i<=n; i++)
		ans[i]=(i*1ll*ans[i-1]%mod+i*1ll*(i-1)/2ll%mod*1ll*jc[i-1]%mod)%mod;
		//记住在常数后面加 ll 防止转 int 炸掉
		//由于 i*(i-1) 一定为偶数，所以可以直接 /2 而不用考虑逆元
	cout<<ans[n]%mod;
	return 0;
}
```
### Python

```python
mod = 998244353
N = 1000005
n = int(input())
ans = [0] * N
ans[2] = 1  
jc = [1] * N
for i in range(1, N):
    jc[i] = (jc[i-1] * i) % mod
for i in range(3, n + 1):
    t1 = (i * ans[i-1]) % mod
    t2 = ((i * (i - 1) // 2) % mod) * jc[i-1] % mod
    ans[i] = (t1 + t2) % mod
print(ans[n] % mod)
```
upd on 2025/5/5 18:30：添加了 Python 代码。

upd on 2025/6/7 22:05：修改了凌乱冗余的语言描述，增强可读性。

---

## 作者：SatoruXia (赞：1)

一道数学题。  
直接枚举所有排列显然是不行的，$n!$ 增长太快。

设在一个排列中，位置为 $i$ 的数为 $k$。考虑排列中每个位置 $i$ 和数字 $k$ 的贡献。因为数字是 $1$ 到 $n$ 的排列，所以得出：$c_i$ 的期望是 $(i-1)\times\frac{k-1}{n-1}$。

根据定义，$a_i$ 可以是任意 $k$，且每个 $k$ 出现的次数相同（因为排列是对称的，自己理解）。所以 $a_i=k$ 的排列数量是 $(n-1)!$（因为其他 $n-1$ 个数字可以任意排列）。

所以每个排列的 $c_i$ 就是把它们乘起来，也就是 $(i-1)\times\frac{k-1}{n-1}\times (n-1)!$。

因此，对于固定的 $i$，所有排列的 $c_i$ 总和是：
$$\sum_{k=1}^n(i-1)\times\frac{k-1}{n-1}\times (n-1)!=(i-1)\times\frac{n!}{2}$$
（略去了中间超长的化简过程）

然后对 $i$ 从 $1$ 到 $n$ 求和，得答案为：
$$\frac{n! \times n(n-1)}{4}\bmod998244353$$

然后就是此式的实现问题。我套了模逆元加上快速幂，如果有更简单的实现方式欢迎大家提出。

```cpp
#include <iostream>
using namespace std;
const int MOD = 998244353;//模数
//阶乘
long long factorial(int n) {
    long long ans = 1;
    for (int i = 1; i <= n; ++i) {
        ans = (ans * i) % MOD;//每次取余防止爆掉
    }
    return ans;
}
//快速幂
long long pow(long long base, int exp, int mod) {
    long long ans = 1;
    while (exp > 0) {
        if (exp % 2 == 1) {
            ans = (ans * base) % mod;//每次取余
        }
        base = (base * base) % mod;//同上
        exp /= 2;
    }
    return ans;
}
//模逆元
long long mod_inverse(int a, int m) {
    return pow(a, m - 2, m);//快速幂就是为了这个
}
int main() {
    int n;cin >> n;
    //下面都要开long long
    long long fact = factorial(n);
    long long inverse = mod_inverse(4, MOD);
    long long ans = fact * n % MOD;
    //计算答案两步走
    ans = ans * (n - 1) % MOD;
    ans = ans * inverse % MOD;
    cout << ans << endl;
    return 0;
}
```
至于 Python，有的人可能觉得能用它高精度的特点，但其实不行。原因是 $n!$ 可能会非常大，再除以 $4$ 的话会有误差。  
但有一点是可以~~偷懒~~使用的：Python 中 `pow()` 函数支持一个模数的参数，还自带优化，说白了不用手写快速幂了！别的部分与 C++ 并无太大区别。以下是 Python 代码。

```python
MOD = 998244353 #模数
n = int(input())
#阶乘
fact = 1
for i in range(1, n + 1):
    fact = fact * i % MOD #每次取余加速效率（Python不存在爆掉一说……）
inverse = pow(4, MOD - 2, MOD) #直接套函数
ans = fact * n % MOD
#计算答案两步走
ans = ans * (n - 1) % MOD
ans = ans * inverse % MOD
print(ans)
```

---

## 作者：ZTengW (赞：1)

[question](https://www.luogu.com.cn/problem/P12369)  
~~我相信所有人都能看得懂题。~~  
## 思路  
不难想到暴力搜索，但是 $N$ 超过 $10$ 就会超时，所以还是要用数学方法。

我们用幼儿园大班学的组合数学推一下：

考虑任意一对数 $(i,j)(i<j)$，在排列中，如果i在j的前面，那么对于位置 $j$（即数 $j$ 所在的位置），$i$ 对 $c_j$ 的贡献为 $1$（因为 $i<j$，所以 $i$ 在 $j$ 前面且小于 $j$ ，所以会贡献 $1$ ）；反之，如果j在i前面，则对 $c_i$ 没有贡献（因为 $j>i$，不会在 $i$ 前面产生小于i的贡献）。但是注意，每个位置上的 $c_i$ 是由前面所有小于它的数决定的。

因此，我们可以考虑每一对 $(i,j)$（其中 $i<j$）在所有排列中，有多少次满足 $i$在 $j$ 的前面。因为 $i$ 在 $j$ 前面且 $i<j$，那么就会在 $j$的位置上贡献 $1$。而这样的排列数是多少？固定 $i$ 和 $j$ ，其他数任意排列，那么 $i$ 在 $j$ 前面的概率是 $\frac {1}{2}$，所以总排列数为 $N!$，其中有一半是 $i$ 在 $j$ 前面。因此，对于每一对 $(i,j)$ ，它对总价值之和的贡献为：$\frac {N!}{2}$。

那么总共有多少对 $(i,j)$？从 $1$ 到 $n$ 中选取两个不同的数，且 $i<j$，有 $C_{N}^{2} = \frac {N \times (N-1)}{2}$ 对。

综上，我们可以发现发现 $\frac {N \times (N-1) \times N!}{4}$ 就是答案公式。

其中，除法在模运算中需要转换为乘以逆元。具体实现步骤如下：  
1. 计算阶乘 $N!$ 模 $998244353$。
2. 将阶乘结果乘以 $n$ 和 $(n-1)$，并取模。
3. 计算 $4$ 的逆元：由于 $998244353$ 是质数，$4$ 的逆元可以通过先计算 $2$ 的逆元（即 $(MOD+1)/2$），然后平方取模得到。
## 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD=998244353,INV=748683265; // 模与逆元
int main()
{
    ll n,ans=1,i;
    scanf("%lld",&n);
    for(i=2;i<=n;i++)
    {
        ans=ans*i%MOD;
    }
    ans=ans*n%MOD;
    ans=ans*(n-1)%MOD;
    ans=ans*INV%MOD;
    printf("%lld",ans);
    return 0;
}
```
最后给我点个[关注](https://www.luogu.com.cn/user/1384934)吧。

---

## 作者：Nahia (赞：0)

### 思路

价值？就是逆序对的个数。

对于 $n$ 个数，一定有 $n!$ 个排列，而对于每一个排列，一定有 $\dfrac{n(n+1)}{2}$ 个满足条件的 $(i,j)$ 二元组，而对于所有的二元组，一定有一半是逆序对。

所以对于 $n$ 个数的所有排列中的逆序对的个数 $f(n)$，满足 $f(n) = n! \times \frac{n(n+1)}{2} \times \frac{1}{2}$，即：

$$f(n) = \dfrac{n! \times n(n+1)}{4} $$

### solution

```cpp
#include<bits/stdc++.h>
#define ll long long
#define For(i,a,b) for(int i = a;i<=b;i++)
using namespace std;
inline __int128 read(){__int128 x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-'){f=-1;}c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}
inline void write(__int128 x){if(x<0){putchar('-');x=-x;}if(x>9)write(x/10);putchar(x%10+'0');}
const ll N = 1000010;
const ll mod = 998244353;
ll n,a[N],f[N]={1,1};
int main(){
	int n = read();
	a[2] = 1;
	For(i,1,N) f[i] = f[i-1]*i%mod;
	For(i,1,n){
		a[i] = (1ll*i*a[i-1]%mod+1ll*i*(i-1)/2%mod*1*f[i-1]%mod)%mod;
	}
	write(a[n]);
	return 0;
}
```

### 注意

**随时取模**好习惯。

---

## 作者：Tracy_Loght (赞：0)

有一个无需写逆元的方法。

分析一下。

显然，对于序列来说，任意两个不同位置的数一定有大小关系，而不是相等的，所以对于两个位置的数来说，有**一半**的概率使得答案加一。

而在 $n$ 个数中任意选 $2$ 个，显然是 $\frac{n \times (n+1)}{2}$ 个。

而全排列的个数是 $n!$ 的。

答案显然，这里再讲一下为什么不用逆元。

显然，要用逆元的时候是因为数被取模且计算的时候会不满足条件，及大家经常说的取模与除法。

由于最后除了 $4$，我们考虑每次增加上模数，直到可以被 $4$ 整除的时候。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll Mod=998244353;
ll n,zxy=1;
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0);
	cin>>n;
	for(ll i=1;i<=n;i++) zxy=zxy*i%Mod;
	zxy=zxy*(n-1)%Mod;zxy=zxy*n%Mod;
	while(1){
		if(zxy%4!=0) zxy=zxy+Mod;
		else {cout<<(zxy/4)%Mod;return 0;}
	}
	return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

先把题目转换一下。求所有排列的逆序对数。

可以推个式子。

先考虑每个数对。每两个位置 $(i,j)$ 为逆序对的几率为 $\frac{1}{2}$，$n$的排列有 $n!$ 个，总数为 $\frac{n!}{2}$。

再考虑数对的数量。我们小学二年级就学过，$n$ 个东西里选两个的公式为 $\frac{n(n-1)}{2}$。把两个式子相乘为 $\frac{n!n(n-1)}{4}$。

记得处理逆元。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=998244353ll;
const ll inv=748683265ll;//4 在模 998244353 意义下的逆元
int n;
ll ans=1;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i) ans=ans*i%mod;
    printf("%lld",ans*n%mod*(n-1)%mod*inv%mod);
}
```

---


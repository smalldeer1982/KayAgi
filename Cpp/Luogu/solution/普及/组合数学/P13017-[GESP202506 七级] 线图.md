# [GESP202506 七级] 线图

## 题目描述

给定由 $n$ 个结点与 $m$ 条边构成的简单无向图 $G$，结点依次以 $1,2,\dots,n$ 编号。简单无向图意味着 $G$ 中不包含重边与自环。$G$ 的**线图** $L(G)$ 通过以下方式构建：

- 初始时线图 $L(G)$ 为空。

- 对于无向图 $G$ 中的一条边，在线图 $L(G)$ 中加入与之对应的一个结点。

- 对于无向图 $G$ 中两条不同的边 $(u_1,v_1),(u_2,v_2)$，若存在 $G$ 中的结点同时连接这两条边（即 $u_1,v_1$ 之一与 $u_2,v_2$ 之一相同），则在线图 $L(G)$ 中加入一条无向边，连接 $(u_1,v_1),(u_2,v_2)$ 在线图中对应的结点。

请你求出线图 $L(G)$ 中所包含的无向边的数量。

## 说明/提示

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/72ffa0a3.png)

**【数据范围】**

对于 $60\%$ 的测试点，保证 $1 \le n \le 500,1 \le m \le 500$。

对于所有测试点，保证 $1 \le n \le 10^5,1 \le m \le 10^5$。

## 样例 #1

### 输入

```
5 4
1 2
2 3
3 1
4 5```

### 输出

```
3```

## 样例 #2

### 输入

```
5 10
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
4 5```

### 输出

```
30```

# 题解

## 作者：CodeForceser (赞：15)

## 前言

**请不要直接复制代码，建议理解后自己写一遍**。本文偏学术、较长，请耐心阅读。若对您有帮助，您可以关注[这位](https://www.luogu.com.cn/user/1407701)。

## 题目大意

使用一个 $n$ 个结点 $m$ 条边的简单无向图 $G$，构造一个线图 $L(G)$。对于无向图 $G$ 中的一条边，在线图 $L(G)$ 中加入与之对应的一个结点。对于无向图 $G$ 中两条不同的边 $(u_1,v_1),(u_2,v_2)$，若存在 $G$ 中的结点同时连接这两条边，则在线图 $L(G)$ 中加入一条无向边，连接在线图中对应的结点。请你求出线图 $L(G)$ 中所包含的无向边的数量。

## $60$ 分做法

由于 $1\le m\le10^5$，考虑使用 $O(m)$ 的时间复杂度完成此题。

画出图 $L(G)$ 后不难发现，对于 $L(G)$ 中的每个点，所连接边的数量为此结点的 $u,v$ 与其他节点的 $u,v$ **相同的数量**（下文会多次出现）。将这些相同的数量累加再除以 $2$ 便能得到答案。可以使用双重循环，第一重遍历 $L(G)$ 中的所有结点，第二重统计相同的数量。

不过这一做法的时间复杂度为 $O(m^2)$，只有 $60$ 分，考虑优化。

核心代码：  
```cpp
int ans = 0;
for (int i = 1; i <= m; i++){
    for (int j = 1; j <= m; j++){
        if (i == j)
            continue;
        ans += (u[i] == u[j] || u[i] == v[j] || v[i] == u[j] || v[i] == v[j]);
    }
}
cout << ans / 2;
```

## 优化（$100$ 分做法）

由于每次统计相同的数量时，都会遍历其他的节点，导致时间复杂度多乘以一个 $m$。可以使用统计数组进行优化。

定义统计数组 $cnt$：$cnt_i$ 表示 $i$ 号结点在 $L(G)$ 中的 $u_i$ 或 $v_i$ 中出现的次数。

+ 初始化 $cnt$ 数组。

+ 遍历 $L(G)$ 中的每条边。  
  + `cnt[u[i]]--,cnt[v[i]]--;` 这样不会发生后面的节点有重复统计。
  + `ans += cnt[u[i]] + cnt[v[i]];` 将答案累加相同的数量。
+ 输出 $ans$，**注意：定义时记得使用 long long（$m^2\ge 2^{31}$）**。

## 100 分代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, m;

int u[100010];
int v[100010];
int cnt[1000010];

main(){
	cin >> n >> m;
	for (int i = 1; i <= m; i++){
		cin >> u[i] >> v[i];
		cnt[u[i]]++;
		cnt[v[i]]++;
        //初始化
	}
	int ans = 0;
	for (int i = 1; i <= m; i++){
		cnt[u[i]]--;
		cnt[v[i]]--;
        //避免重复统计
		ans += cnt[u[i]] + cnt[v[i]];
        //累加答案
	}
	cout << ans;
    //输出
	return 0;
}
```

---

## 作者：ZHR100102 (赞：4)

[Blog](https://www.cnblogs.com/zhr0102/p/18960738)

树的遍历，但是只要统计边数。怎么感觉 P13017 和 P13020 都是从 P11363 里拆出来弱化的。

注意到线图中一条边存在，当且仅当两个端点所代表的边在原图中有一个共同的端点。

于是**以原图中的节点计数**，对每个点找任意与它相连的两条边在线图中相连，该节点贡献的边的总数显然是 $C_{d_u}^2=\dfrac{d_u(d_u-1)}{2}$，其中 $d_u$ 表示点 $u$ 在原图中的度数。最后将原图中所有节点贡献的边数相加即为答案。

时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define eb(x) emplace_back(x)
#define pb(x) push_back(x)
#define lc(x) (tr[x].ls)
#define rc(x) (tr[x].rs)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ldb;
using pi=pair<int,int>;
const int N=100005;
ll n,m,ans=0,d[N];
int main()
{
    //freopen("sample.in","r",stdin);
    //freopen("sample.out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    while(m--)
    {
        int u,v;
        cin>>u>>v;
        d[u]++;d[v]++;
    }
    for(int i=1;i<=n;i++)ans+=d[i]*(d[i]-1)/2;
    cout<<ans;
    return 0;
}
```

---

## 作者：DeImage (赞：3)

这道题我的考场代码竟然还没二十行……
*****
## 题意描述
别看题目说得弯弯绕绕，其实大概意思就是这样：
1. 初始时“线图”$L(G)$ 为空；
2. 将原图 $G$ 中的所有边分别连接的顶点（即 $u_i, v_i$）记录下来，在线图 $L(G)$ 中创建一个新的节点，其编号为 $e_{u_i,v_i}$；
3. 在原图 $G$ 中找到任意两条边，若这两条边所连接的顶点有一个相同（如边 $\{1,2\}$ 与边 $\{2,3\}$），那么在线图 $L(G)$ 中将这两条边所对应的点相连（即将 $e_{1,2}$ 与 $e_{2,3}$ 相连）；
4. 统计线图 $L(G)$ 中的边数。
## 解题思路
自己造了一组数据，可以画出这样的图：
![](https://cdn.luogu.com.cn/upload/image_hosting/4nztopo9.png)
我们将线图 $L(G)$ 中所有包含 $1$ 的顶点单独拿出来重新连边，如右图 $L(G)'$ 所示。有没有发现什么？  
对了，**它是个*完全图*！**

你可以再举出一些例子，它们依然会形成 **完全图**，准确来说是 **完全无向图**！（如果你不知道 *完全图* 是什么，请点击 [这里](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E5%9B%BE/10073908)）
*****
好了，我们知道，线图 $L(G)$ 中包含 $i$ 的节点都会单独形成一个 **完全无向图**，那么我们是不是只要统计图 $G$ 中点 $i(1 \le i \le n)$ 出现的次数 $c_i$，并求出有 $c_i$ 个顶点的 *完全无向图* 中的边数就行了？

我们知道，对于有 $k$ 个节点的完全无向图，共有 $\frac{k(k-1)}{2}$ 条边（这里给出一段证明）。
> 对于完全无向图中编号为 $i$ 的点，可以与编号比 $i$ 大的 $k - i$ 个点相连，那么总共就会有 $(k - 1) + (k - 2) + (k - 3) + \cdots + (k - k)$ 条边。我们发现，相邻两项之间的差都是一。那么，根据 **等差数列求和公式**，自然可以得到总边数为 $\frac{k(k-1)}{2}$。

因为 $1 \le n \le 10^5$，用数组进行点数记录即可。

### 注意：
最后统计答案记得开 `long long`！因为边数最多可达约 $5 \times 10^9$！

### 最后附上极短代码：
```cpp
#include <cstdio>
using namespace std;

int n, m, a[100005];
long long ans;
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		a[u]++;
		a[v]++;
	}
	for (int i = 1; i <= n; i++)
	    ans += (long long)a[i] * (a[i] - 1) / 2;
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：0Io_oI0 (赞：2)

这道题目是 $7$ 级，历史上最简单的，不接受反驳！

**题目大意：**

就是给你一个图，让你求里面有多少组边有公共节点。

实现也很简单，我们枚举可能作为公共节点的点，然后假设与这个点连接的其它点的个数为 $size$，那么这里一共能构成  $\frac{size\times (size-1)}{2}$ 组有公共节点的边，因为任意无序的选两个与这个点连接的点，都能够成一组符合要求的边。

所以这道题目的答案就是：

$$\sum_{i=1}^n \frac{size_i\times (size_i-1)}{2}$$

其中 $size_i$ 表示与节点 $i$ 连接的点的个数。

上一个核心代码：

```cpp
for(int i=1;i<=n;i++){
    int size=g[i].size();
    ans+=size*(size-1)/2;
}
```

亲测可过，请勿抄袭！

---

## 作者：Ryanhao (赞：1)

# [GESP 2025 JUN G7 线图](https://www.luogu.com.cn/problem/P13017)

作者赛时思路历程：

由样例 $1$ 得，
$$
ans=\left(\sum_{i=1}^{n}\deg_i\right)-n
$$

（其中 $deg_i$ 表示点 $i$ 连接的边数。）

于是获得 $0$ 分的好成绩。

考虑每个点在线图中会变成多少条边。

由题意得，有公共顶点的边是相邻的，在线图中这两条边代表的点会连一根线。

每个点产生的相邻的边一共有 $\dbinom{\deg_i}{2}=\dfrac{\deg_i\cdot(\deg_i-1)}2$ 条。

所以，

$$
ans=\sum_{i=1}^{n}\dfrac{\deg_i\cdot(\deg_i-1)}2
$$

于是你会[获得 $100$ 分的好成绩](https://www.luogu.com.cn/record/221969466)。

## ACCode

```cpp
#include <cstdio>
#include <vector>
using namespace std;
typedef long long ll;

const int GXR = 1e5+5;
int d[GXR];

int main() {
  int n,m; 
  scanf("%d%d",&n,&m);
  for (int i = 1; i <= m; i++) {
    int u,v; 
    scanf("%d%d",&u,&v);
    d[u]++; 
    d[v]++;
  }
  ll ans = 0;
  for (int i = 1; i <= n; i++) 
    ans += 1ll*d[i]*(d[i]-1)/2;
  printf("%lld",ans);
  return 0;
}
```

---

## 作者：Zhang1024 (赞：1)

无需多言。
### **题意**
给定由 $n$ 个结点与 $m$ 条边构成的简单无向图 $G$ ，求出原图中的两条边共享一个公共节点的情况总个数。
### **思路**
线图中的边数量等于原图中所有共享至少一个公共节点的边对的数量。所以先计算出每个点的度数（即连接的边数），然后对于度数为 $deg_i$ 的节点 $i$ ，贡献的边对数量为 $ C(deg_i,2) = \dfrac{deg_i \times (deg_i - 1)}{2} $ ，将所有节点的贡献相加即可得到线图中的总边数，时间复杂度 $O(n)$ 。

代码：
```
#include<bits/stdc++.h>
#define int long long
#define REP(i,a,b,c) for(int i=a;i<=b;i+=c)
#define PER(i,a,b,c) for(int i=a;i>=b;i-=c)
//using ll = long long;
using namespace std;
const int N=1e5+10;
int n,m,u,v,deg[N],ans;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>n>>m;
	REP(i,1,m,1){
		cin>>u>>v;
		deg[u]++,deg[v]++;
	}
	REP(i,1,n,1) ans+=deg[i]*(deg[i]-1)/2;
	cout<<ans;
}
```

---

## 作者：SudoXue (赞：0)

[更好的阅读体验](https://www.cnblogs.com/xueruhao/p/18960212)

线图 $L(G)$ 的一条边对应原图 $G$ 中一对共享同一端点的边。设原图中顶点 $v$ 的度数为 $\mathrm{deg}_v$。在 $G$ 里，这个顶点贡献的“邻接边对”数量正是 $\binom{\mathrm{deg}_v}{2}=\mathrm{deg}_v(\mathrm{deg}_v-1)/2$。因此，线图边数就是所有顶点贡献之和，即 $\sum_{v=1}^{n}\mathrm{deg}_v(\mathrm{deg}_v-1)/2$。实现时先读入所有边并统计每个点的度数，然后一次遍历累加组合数即可。注意需要开 `long long`。

算法相当于遍历每条边更新两端度数，时间复杂度 $O(n+m)$。

[link](https://www.luogu.com.cn/record/221980030)

---

## 作者：封禁用户 (赞：0)

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/P13017)
## 题目分析
希望审核大大给过。

这道题我在考场上一边过，只要弄明白规律就很简单了。

由题目可知，这道题的 $L(G)$ 是把 $G$ 的每一条边变成一个点进行计算。**即：**
- 对于无向图 $G$ 中的一条边，在线图 $L(G)$ 中加入与之对应的一个结点。

然后题目说给出图 $G$ 上的任意两条边，如果这两条边有公共点，那么连接在线图 $L(G)$ 上的两个对应的点。**即：**
- 对于无向图 $G$ 中两条不同的边 $(u_1,v_1),(u_2,v_2)$，若存在 $G$ 中的结点同时连接这两条边（即 $u_1,v_1$ 之一与 $u_2,v_2$ 之一相同），则在线图 $L(G)$ 中加入一条无向边，连接 $(u_1,v_1),(u_2,v_2)$ 在线图中对应的结点。

最后题目让我们计算线图 $L(G)$ 的边的数量。此为题目的意思，下面为我在考场上的思路。

先使用 vector 数组储存这个图 $G$，假设与某一个点 $d$ 连接的边的数量为 $s$，如果在这 $s$ 条边中任选两条边，那么一定这两条边交于点 $d$，而在 $s$ 条边中选 $2$ 条，有 $C^2_s$ 种方法，也就是 $s \times (s - 1) \div 2$ 种方法，用一个数组记录即可。

下面是本题代码。
## 题目[代码](https://www.luogu.com.cn/record/221971281)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define speed ios::sync_with_stdio(0),cin.tie(0), cout.tie(0);
int n,m,sum;
vector<int>tree[100001];
signed main() {
	speed
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		tree[u].push_back(v);
		tree[v].push_back(u);
	}
	for(int i=1;i<=n;i++)sum+=(tree[i].size()*(tree[i].size()-1)/2);
	cout<<sum;
	return 0;
}
//留个关注再走吧qwq
```

---

## 作者：DPOI (赞：0)

### 做法
直接暴力枚举两个点是否中间隔了一个点，如果你用邻接表，就是 $O(n^4)$ 的，用上二分，是 $O(n^3 \log n)$，期望得分：$60pts$。

考虑枚举中间的“接点”，也就是两个点相连中间的点。对于一个节点 $u$，假设它连了 $k$ 条边，我们从中任意选取 $2$ 条连向不同节点的边，就可以构成“线图”的一条边，明显是有 $C_{k}^2$ 条边，$C_{k}^2=\frac{A_k^2}{A_2^2}=\frac{k \times (k-1)}{2}$。

把每个节点当做“接点”时可构成线图的边的数量累加起来就是答案，就做完了。要开 `long long`。
### CODE
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<int>g[100005];
signed main(){
    int n,m;cin>>n>>m;
    for (int i=1;i<=m;++i){
        int u,v;cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    int ans=0;
    for (int i=1;i<=n;++i){
        ans+=g[i].size()*(g[i].size()-1)/2;
    }
    cout<<ans;
}
```

---


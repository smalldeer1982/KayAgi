# 跑步

## 题目描述

路人甲准备跑 $n$ 圈来锻炼自己的身体，他准备分多次（$\gt1$）跑完，每次都跑正整数圈，然后休息下再继续跑。

为了有效地提高自己的体能，他决定每次跑的圈数都必须比上次跑的多。

可以假设他刚开始跑了 $0$ 圈，那么请问他可以有多少种跑完这 $n$ 圈的方案？

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $5\le n\le 500$。

## 样例 #1

### 输入

```
212```

### 输出

```
995645335```

# 题解

## 作者：翼德天尊 (赞：249)

### 首先，让我们分析一下题意，提炼后如下：
1.次数 > 1；

2.V后一秒 > V前一秒；

3.跑n圈。
### 理清了思路，还有一个问题，用什么方法做这题？
1.DFS（深搜），炸时间，**取消**；

2.BFS（广搜），依旧炸时间，**取消**；

3.暴力，**当然更不行**；

于是，~~经过了漫长的思考，~~ 我们决定——
### 出来吧，~~皮卡丘~~ DP动规！
**什么是动规？**
```
动规，全称动态规划
指动态地演变每一步，类似著名的斐波那契数列：
末路等于来路之和……
实现过程即为开一个足够的数组，然后模拟每一步，最终答案为数组的第n项。
时间复杂度：低
```
### 话不多说，上AC代码！
```cpp
#include<bits/stdc++.h>//棒棒哒头文件
using namespace std;
long long n,ans[501]; //分别为总圈数n以及动规数组,动规数组的第i个下标表示前i圈的方案总数
int main(){
    scanf("%d",&n);//输入
    ans[0]=1;//第0项暂时设为1，保证数据来源（相当于借的）
    for (int i=1;i<=n;i++){//模拟前i圈
    	for (int j=n;j>=i;j--){//模拟前i圈中每一圈的演变过程
    		ans[j]+=ans[j-i];//第i圈是由它的前i圈（1~i)演变而来
		}
	}
    //DP结束
	cout<<ans[n]-1<<endl;//完美输出
    return 0;//习惯性 好习惯撒花
}
```
#### 不知道你看懂了没有呢，你看这里也没发双击666，不如直接“以赞代6”吧！
### 谢谢诸位捧场啦！！！


---

## 作者：Anoxiacxy (赞：33)

考虑动态规划，用dp[ i ][ j ]来表示一共跑了 i 圈，且最后一次跑了 j 圈的方案数，

不难想到以下方程 dp[ i ][ j ] += dp[ i - j ][ k ] 其中 i >= j + k ，且 k < j，

由于不能一次跑完，所以dp[ i ][ i ]这样的方案数是不能统计的

代码如下， 记得开 long long



```cpp
#include <cstring>
#include <cstdio> 
#include <queue>
#include <stack>
#include <vector>
#include <bitset>
#include <set> 
#include <cmath>
#define inf 2e9
#define LL long long
#define nl NULL
#define mod (1000)
using namespace std;
LL dp[520][520], ans;
int main(){
    int n; scanf("%d", &n);
    for(int i = 1; i <= n; i++) dp[i][i] = 1;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j < i; j++)
            for(int k = 1; k < j && j + k <= i; k++)
                dp[i][j] += dp[i-j][k];
    }
    for(int i = 1; i < n; i++) ans += dp[n][i];
    printf("%lld\n", ans);
}
```

---

## 作者：AveMarina (赞：16)

## 01背包求方案数
__01背包求方案数：__ 如果我们将要跑的距离$n$看做背包容积，每次跑的距离$i$看做物品代价，就可以发现这其实是个 __01背包求方案数的题目__。

__为什么是01背包：__

1.每种可能的距离$i$只能被选一次。（题目中的信息就是每次只能跑更远的距离）

2. 每种距离都只有选或不选两种情况

__空间上的优化__

可选物品的代价为$1,2,3...n$，背包容积为$n$，即每次可以放入背包的物品的代价都是$n$到$1,2,3...n$，且选过的物品无法再选。由此就能得到下面的状态转移方程了。
```cpp
#include <iostream>
using namespace std;

// 突然发现这是个01背包求方案数... 

// 不开long long见祖宗 
typedef long long LL;
const int N = 510;
LL f[N];
int main() {
	int n;
	cin >> n;
	f[0] = 1;
	for (int i = 1; i <= n; i++) {
    // 小小的优化
		for (int j = n; j >= i; j--) {
			// 01背包求方案数的状态转移方程 
			f[j] += f[j - i];
		}
	}
	cout << f[n] - 1;
	return 0;
} 
```
## 另附完全背包求方案数模板
__完全背包求方案数的关键__
1. 首先看题目是不是要求方案数
2. 看一个物品是否可以无限用（如果是可以用多次那么就是多重背包问题，转换为01背包就行）

没错，就是把01背包的代价从大到小改成了从小到大，另外解集数组的初始化也非常重要。

```cpp
f[0] = 1;
for (int i = 1; i <= n; i++) {
	for	 (int j = i; j <= n; j++) {
		// 完全背包求方案数的状态转移方程 
		f[j] += f[j - i];
	}
}
```
~~不能理解就背模板多打几遍找规律好了~~

---

## 作者：liangsheng (赞：9)

### ~~发现题解实在太少了,我来补一发吧~~

~~其实这是个挺水的一道题~~

这道题第一眼看就发现像是背包计数问题

然后我们来分析一下题意:

题上说每次跑的圈数都必须比上一次多

我们往我们平时做的背包计数问题方面去想

我们可以先把每次走的圈数打表,然后跑一遍计数dp就ok了

#### `dp[i]:跑i圈的方案数量`


### 转移方程: `dp[j] += dp[j-a[i]]`


#### 上代码:
```cpp

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long ll;

int n;
int a[505];
ll dp[505];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        a[i] = i;
    }
    dp[0] = 1;   //赋初值
    for(int i = 1; i <= n; i++) {
        for(int j = n; j >= a[i]; j--) {
            dp[j] += dp[j - a[i]];
        }
    }
    cout << dp[n] - 1 << endl;  //减去dp[0]的情况
    return 0;
}

```
就这样,又愉快的水过一题

---

## 作者：品小呈 (赞：7)

## 做法1：暴力 DFS -- 50分
在比赛中，会做的题当然要尽可能拿到满分，而对于其他题目，尽量拿到部分分也是一种应试技巧。并且，很多时候部分分的解经过一定的分析和优化后就能成为正解。

该题只需用模拟的思想，在保证每一次跑步的长度都大于前一次的基础上，穷举所有可能的跑法即可。

主要DFS 函数如下：
```cpp
void dfs(int step,int sum)
{
	if(sum==n)
	{
		ans++;
		return;
	}
	if(step+sum>n)
		return;
	for(int i=step+1;i<=n-step;i++)
	{
		dfs(i,sum+i);
	}
}
```
这里的 
```cpp
for(int i=step+1;i<=n-step;i++)

```
实际上还渗透了一些剪枝的思想：题目中要求每一次圈数不少于上一次，所以若现在的圈数比剩下的圈数还多，就没必要继续搜索下去了。这样的剪枝操作一般不会改变算法复杂度，但是能使运行时间得到一定减小。

但是提交上去之后，你会发现~~意料之中地~~只得了 50pts。

注意到题目的数据范围为 $5 \leq n \leq 500$ ，而我们的 DFS 算法复杂度为 $O(n^n)$ ，并且递归调用函数还会造成额外的时空消耗，对于这个数据范围来说还是太慢了。
## 做法2：DP -- AC
再次仔细思考跑步的过程，其实模拟的过程可以不必用 DFS 这么暴力的做法。

**可以每一次模拟后，用一个数组储存 到第 $n$ 圈的所有可能跑法有 $dp(n)$ 种**，这样每一次模拟都可以在上一次的基础上进行操作。问题规模逐步缩小，复杂度被降为了 $O(n^2)$ ，并且没有使用时间成本较高的函数递归，所以通过本题自然就十分轻松。

核心代码：
```cpp
dp[0]=1;
for(int i=1;i<=n;i++)
{
	for(int j=n;j>=i;j--)
	{
		dp[j]+=dp[j-i];
	}
}
cout << dp[n]-1;
```
这里出现了一个本题的小坑点：按照题目要求，存储状态的数组应被初始化为 $dp(0) = 0$ ,然而，如果真的这么做，就会发现不论你输入什么，输出都会是 0。自己手动算两个循环就会发现 $dp(0) = 0$ 会使 $dp(j) = dp(j) + dp(j-i)$ 这个式子没有计算意义。

正确的方法是初始化时采用 $dp(0)=1$ ，保证式子可以正常计算。计算完成输出结果时输出 $dp(n)-1$ 即可。

~~答案算出来会很大，记得开 ```long long```~~

### 备注：
> 做法1的 DFS 算法复杂度分析参考了 @zhangbinsai 题解中的结论：[传送门](https://www.luogu.com.cn/blog/wgyangzhuhezuoshe/solution-p1806)

~~第一篇题解祭~~

---

## 作者：XL4453 (赞：5)

需要一定理解的DP，其他题解中一般只讲了一种，这一把两种结合起来看。

------------
解题思路：

一眼看出是 DP 。

然后考虑状态，用 $f[i][j]$ 来表示跑了 $i$ 圈，其中最后一次跑了 $j$ 圈的方案数。这一种状态的转移很好想，直接枚举一个 $k$ ，然后加上可行的方案即可，即 $f[i+k][k]+=f[i][j]$ 。

这种方法是最容易想到的，也是非常好写的的一种。

然后就过了。。。

连优化都没有。。。

------------

但如果我们加强一下数据呢？

将 $n$ 的范围扩大至 $10^4$ ，此时 $n^2$ 的复杂度并没有超过 $1s$ 限制，而空间出了问题，$10^8$ 的空间是肯定开不下的。

（当然如果真这样改可能会加一个取模，不然就要高精了）

考虑优化，可以通过改变枚举的顺序的方式来将空间复杂度压缩至线性。


------------

先不要往下看，自主思考一下
------------

其实在上一种做法中，枚举的 j 是需要每一次从之前的可行解中转移过来，如果换一种枚举方式将枚举的i直接作为答案就好了。

那么我们就可以将枚举的单次跑步圈数改为对于每一个总圈数都是递增的，也就是对于当前的 $i$ ，拓展到 $i$ 的所有值都是最大圈数比 $i$ 小的。这一种方式的实现比较简单的是先枚举跑的圈数然后在通过从后往前枚举要跑的总圈数来实现转移。

具体的方程为：$f[j]+=f[j-i]$，其中 $i$ 为当前跑的圈数，$j$ （好像说过了 $QAQ$ ）。

------------
代码

```cpp
#include<cstdio>
using namespace std;
long long n,f[505];
int main(){
    scanf("%lld",&n);
    f[0]=1;
    for(int i=1;i<=n;i++)
    for(int j=n;j>=i;j--)
	f[j]+=f[j-i];
    printf("%d",f[n]-1);
    return 0;
}
```
------------

如前，首先枚举跑的圈数 $i$ ，然后对于每一个圈数进行转移，其中，因为跑的圈数线性递增，所以所有可能的解都是满足跑的圈数递增的。

最后注意一点，j是要从后往前枚举的。


---

## 作者：天才颓废学家 (赞：5)

### 我不会和[上次](https://www.luogu.com.cn/record/38480424)一样莽了（！
## 前言
这道题目呢，坑点不多，主要是两个

①：他准备分多次(>1)跑完

②：他决定每次跑的圈数都必须比上次跑的多

避开了这些坑，题目也就八九不离十了

那么

进入正题：
## 拿到题目

咦？怎么没有算法标签？盲猜DFS！

不对！
```
对于 100% 的数据，保证 5≤n≤500。
```
#### ！

显然，以dfs近乎n^n的光速，顶多30分，但是孔子(?)说：“拿到题目，先写暴力！”

所以
```pascal
var
 n,i,j,k:longint;
 ans:int64;
procedure dfs(t,k:longint);
var
 i:longint;
begin
 if t=n then begin inc(ans); exit; end;
 if t+k>n then exit;
 for i:=k+1 to n-1  do
  if t+i<=n then dfs(t+i,i)
   else break;
end;
begin
 readln(n);
 dfs(0,0);
 writeln(ans);
end.
```
#### [天(zhen)哪(xiang)！](https://www.luogu.com.cn/record/38744164)

然而，上进的我并不满足于50分，所以，经过大佬点拨：

DFS：o(玄学)×

BFS：o(玄学)×

bulabula：o(n^3)√

abab：o(n^2)√

EEE：o(n)×(我太柴了，无法实现)
### 这不就DP吗！
又是一阵深(tou)思熟(tu)虑，n^3的DP横空出世！
### 这里用f[i,j]表示跑完第i圈时，这次跑了j圈。
### 由题意可得，f[i,j]=f[i,j]+f[i-j,k].(将答案更新为当前方案数加上跑完i-j圈的这次跑了k圈的状态）
```pascal
// shei ga ga 666
//拒绝math库，从我做起！
type
 longlong=int64;
 ll=longlong;
 int=longint;
 bool=boolean;
 float=real;
 qwq=qword;
 arr=array[0..2000,0..2000] of string;
 arrr=array[0..200000] of string;
———————以上纯属搞笑——————————
var
 f:array[0..666,0..666] of qwq;
 n,i,j,k:longint;
 ans:qwq;
begin
 readln(n);
 for i:=0 to n do f[i,i]:=1;
 for i:=1 to n do //枚举已跑过的圈数
  for j:=1 to i-1 do //枚举这次跑的圈数
   begin
    for k:=1 to j-1 do //枚举上一个状态
     begin
      if k+j>i then break
       else f[i,j]:=f[i,j]+f[i-j,k]; //DP状态的转移。     
     end;
    if i=n then ans:=ans+f[i,j];
   end;
 writeln(ans);
end.
```
#### [啊哈！](https://www.luogu.com.cn/record/38743528)

但是，上进的我不满足于N^3。

因为鲁迅(?)说过：“DP总能再压一维。”

所以，经过大(ti)佬(jie)点拨：

n^2的DP横空出世！

### 我们用f[i]表示跑到第i圈时的方案数。
### 由题意可得：f[j]=f[j]+f[j-i].(表示将答案更新为当前方案数加上跑第(j-i)圈时的方案数
```pascal
// shei ga ga 666
//拒绝math库，从我做起！
type
 longlong=int64;
 ll=longlong;
 int=longint;
 bool=boolean;
 float=real;
 qwq=qword;
 arr=array[0..2000,0..2000] of string;
 arrr=array[0..200000] of int;
——————以上纯属搞笑——————————
var
 f:arrr;
 i,j,n:int;
begin
 readln(n);
 f[0]:=1;
 for i:=1 to n do
  for j:=n downto i do
   f[j]:=f[j]+f[j-i];
 writeln(f[n]-1); //因为至少要分两次跑，所以要减去一次跑完的。
end.
//精辟！
```
#### [嚯哈哈哈](https://www.luogu.com.cn/record/38747420)
这时，当你回头看时，你会发现

### 这**不就是个01背包吗？！
###### ~~今天的新闻联播到此结束，观众朋友们再会%%%~~

P.S. 附[大佬神文](https://www.luogu.com.cn/blog/1008208820D/an-ununderstand-but-diyskiedss)
###### ~~P.S.码风太丑请见谅~~

---

## 作者：issue_is_fw (赞：5)

题解太少啦只有俩篇，所以虽然不是什么创新解法也让我通过把
(●'◡'●)

**一、设计状态**
	状态转移嘛，每次只能跑得更多，所以上一次跑了几圈肯定是一个状态。然后要跑完n圈,所以一共跑了几圈也算一个状态，不然我们怎么知道跑完了没呢？？
    
 定义$dp[i][j]$为总共跑了i圈最后一次跑j圈
 
 **二、状态转移**
 
**转移方程:**$dp[i][j]+=dp[i-j][q];$

那么显然,当跑了i圈且这次跑j圈，上一次肯定跑q圈,q<j
                              
初始化很显然,当总共跑i圈时这次跑i圈的方案是一种
                              
```cpp
for(int i=1;i<=n;i++)	dp[i][i]=1;
```

                              
三重循环:
 ```cpp
for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			for(int q=1;q<j;q++)
				dp[i][j]+=dp[i-j][q];
```

最后，由于题目要求不能1次跑完，所以不统计$dp[i][i]$

**分割线**
-------------------------------------------------------
我们换一种思路.总共要跑n圈,每次可以跑1圈，2圈，....n圈，直到凑出n为止。那是不是相当于有n个物品,物品的重量为1到n,同时价值也是1到n,选那些物品能凑出n呢??这是一个简单的背包问题了。

值得一提的是,这是n^2的做法。

                              
                           

---

## 作者：fyx_Catherine (赞：4)

### 这道题一眼看上去就应该知道是动态规划
f[i][j]表示跑i圈，最后一次跑j圈，∑总共方法数。

f[i][j]= ∑(f[i-j][k]);
直接附上AC代码
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
long long f[505][505];//f数组一定要开long long,否则会爆
int main () {
    long long n;//n也开成long long型
    scanf ("%lld",&n);
    for (long i=0;i<n+1;i++)
	f[i][i]=1;//初始化，将f[0][0]到f[n][n]全部赋值为1
    for (int i=1;i<n+1;i++)
	for (int j=1;j<i+1;j++)
	    for (int k=1;k<j&&k<=i-j;k++)
	    f[i][j]+=f[i-j][k];//f[i][j]每次都加上f[i-j][k]
    long long ans=0;//ans也一定要开long long
    for (int i=1;i<n;i++)
	ans+=f[n][i];//ans求出f[n][1]到f[n][n-1]的值即可
    printf ("%lld\n",ans);//输出答案，完美结束
    return 0;
}  

```
蒟蒻的代码码风丑陋，勿喷（QWQ）

---


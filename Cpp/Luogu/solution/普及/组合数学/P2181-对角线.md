# 对角线

## 题目描述

对于一个 $n$ 个顶点的凸多边形，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。

例如，$6$ 边形：

![](https://cdn.luogu.com.cn/upload/pic/6023.png)

## 说明/提示

#### 数据规模与约定

- 对于 $50 \%$ 的数据，保证 $3 \leq n \leq 100$。
- 对于 $100 \%$ 的数据，保证 $3 \leq n \leq 10^5$。

## 样例 #1

### 输入

```
3```

### 输出

```
0```

## 样例 #2

### 输入

```
6```

### 输出

```
15```

# 题解

## 作者：ww3113306 (赞：1502)

这明明是一道组合数的题，，，不懂为什么会放在计算几何当中。。。。

感觉下面几个题解都只是放了个公式，并没有具体讲怎么来的

（如果你觉得“在经过一些排列组合的技巧，就可以得出”算具体的话就另当别论了）

感觉推起来还是很妙的

其实这和对角线的公式没什么关系。。。。

首先由于不会有三条对角线交于一点，所以过某一个交点有且只能有２条对角线

而这两条对角线实质上是确定了４个顶点（也可以看做是一个四边形的两条对角线交于一点，求四边形的数量）。

因此我们只需要确定４个顶点就得到了这个唯一确定的交点。

因此我们只需要求这样４个顶点的搭配有多少个了

也就是从ｎ个顶点中取４个出来。

根据组合数的公式，（如果你不知道组合数的公式可以这么推：第一次取可以ｎ个点都是可以取的，第二次取的时候第一个取的点就不能取了，所以只能取(n-1)种，以此类推）

由于改变四个点的顺序不会改变对角线，因此是求的组合而不是排列，也就要除以４！，也就是２４

于是我们就得到了公式：
n * (n-1) * (n-2) * (n-3) / 24

同时为了防止爆掉，但又不想写高精，

我们可以采用一种化简的技巧

于是原式可以化为:

n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4

那为什么这样一定是对的呢？难道不会因为除不尽却向下取整而导致错误吗？

事实上是一定除得尽的

首先n和n-1一定有一个是２的倍数，因此２可以除尽，

同理n,n-1,n-2中一定有一个是３的倍数，因此３可以除尽（除掉２只会消除因数２而对３没有影响）

同理４也可以除尽

完＼（＾ｏ＾）／～

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long n,ans;
int main()
{
    scanf("%lld",&n);
    ans=n * (n-1) / 2 * (n-2) / 3 * (n-3) / 4;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：りゅうこせい (赞：475)

嗯...

各位大佬都用了O（1）的代码

蒟蒻推不出公式瑟瑟发抖

这里我打了一个表

n   交点

2 = 0

3  =  0

4  = 1

5  =  5

6   = 15

7   = 35

8   = 70

...   ...

对数列每相邻两项作差

得到

1. a[3]-a[2] = 0

2. a[4]-a[3]  = 1

3. a[5]-a[4]  = 4

4. a[6]-a[5]  = 10

5. a[7]-a[6]  = 20

6. a[8]-a[7]  = 35

真相就要浮出水面了！

再做差得到

1

3

6

10

15

有没有很熟悉了？得到结论：再做差

1

2

3

4

5

...

所以，类似的这种题都可以坚持不懈做差找规律

虽然是道入门难度...

那附上代码，这里十分简洁明了

```
#include<cstdio>
long long a1[100000];
long long a2[100000];
long long a3[100000];
int main()
{
	long long n;
	scanf("%lld",&n);
	int t=0;
	for(int i=1;i<=n;i++)
	{
		a1[i]=a1[i-1]+i;//这里生成1,3,6,10序列
	}
	for(int i=1;i<=n;i++)
	{
		a2[i]=a2[i-1]+a1[i];//这里生成1,4,10,20序列
	}
	for(int i=1;i<=n;i++)
	{
		a3[i]=a3[i-1]+a2[i];//这里生成答案序列：1,5,15,35
	}
	printf("%lld",a3[n-3]);
	return 0;
}
```
注意开longlong，显然数列连着加到100000项会很大

希望对大家有帮助

来自蒟蒻的第一篇可能过审的题解

---

## 作者：pengym (赞：119)

本蒟蒻随机跳题看到这道题，一看就十分兴奋，毕竟学过这个的公式。这个公式还是比较好推得，首先我们易求得对角线条数为：n\*(n-3)/2,在经过一些排列组合的技巧，就可以得出。即n\*(n-1)\*(n-2)\*(n-3)/24,看了一眼数据范围，大约估摸比long long大了几位，本准备打一波高精，但突然想起了unsigned long long，于是用计算器算了一下100000的答案，发现正好在范围里面，于是我就打程序。其中有一个小细节，如果按照原来的公式光乘法就会爆范围的，于是就换一种形式：n\*(n-1)/2\*(n-2)/3\*(n-3)/4，这样就可以过了。（比楼下几位dalao的高精弱爆了。。）


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    unsigned long long n;
    cin>>n;
    cout<<(n*(n-1)/2*(n-2)/3*(n-3)/4)<<endl;
    return 0;
}
```

---

## 作者：peiyangsong (赞：54)

# P2181 对角线 #
##  题目描述  ##

对于一个N个定点的凸多边形，他的任何三条对角线都不会交于一点。请求楚图形中对角线交点的个数。

例如，6边形：
![图片引自洛谷](https://i.imgur.com/4IBEq9g.png)

## 输入输出格式 ##
### 输入格式 ###
第一行一个n，代表边数。

### 输出格式 ###
第一行输出交点数量

### 输入输出样例 ###

输入样例#1： 

3

输出样例#1： 

0

输入样例#2： 

6

输出样例#2： 

15

## 数据范围 ##

50%的测试数据 3≤N≤100;

100%的测试数据 3≤N≤100000.




## 程序 ##


    
    #include <cstdio>
    #include <cstring>
    #include <cmath>
    
    unsigned long long n; 
    
    int main(){
    	
    	//读入 
    	scanf("%lld",&n);
    	
    	//计算并输出 C4/n
    	printf("%lld\n",n*(n-1)/2*(n-2)/3*(n-3)/4);
    	
    	return 0;
    
    } 



## 算法 ##
1.排列组合

2.数学几何推导

3.高精？（可用也可回避）





**已知**：保证任何三条对角线都不会交于一点


**推导如下**：


1. 每两个顶点连一条对角线
2. 每两条对角线有一个顶点
3. 所以每一个交点对应四个顶点


**则问题转化为**：

> 若从n个顶点之中选出4个，有多少种选法？


因为无序，选择组合数，即计算C4/n


## 注意 ##



- 数据范围较大

可用 高精算法 或 将变量定义为“unsigned  long  long” 类型来解决。

- 计算时的技巧

可将 n (n-1) (n-2) * (n-3) / 24 转化为 n (n-1) / 2 (n-2) / 3 * (n-3) / 4

---

## 作者：wangxuye (赞：25)

看着大佬们直接出公式，蒟蒻来水一篇递推的

我们考虑已经得出n-1边形的交点数f[n-1]，要求n边形的交点数

将点顺时针依次标号为1~n

我们将这个n-1边形的(n-1)和1的连边“折弯”，就得到了一个n边形。由于原来n-1条边的交点数已经求出来了，所以只要考虑新“造”出来的n号点就可以了。

考虑n和2的连边，与其相交的有1号点和其他点的连边，共有1*(n-3)条

考虑n和3的连边，与其相交的有1号点、2号点和其他点的连边，共有2*(n-4)条

由此可得f[n]=f[n-1]+Σi*(n-i-2) (1<=i<=n-3)

再推一下可得f[n]=f[n-1]+(n-2)^2*(n-3)/2-Σi^2 (1<=i<=n-3)

预处理一下n^2的前缀和就可以了

上代码 

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;

ll f[100010];
ll sum[100010];

int main()
{
	int n;
	scanf("%d",&n);
	f[4]=1;
	sum[0]=0;
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+(ll)i*i;
	for(int i=5;i<=n;i++) f[i]=f[i-1]+(ll)(i-2)*(i-2)*(i-3)/2-sum[i-3];
	cout<<f[n]<<endl;
	return 0;
} 

```

---

## 作者：wangweiba (赞：17)

#温馨提示：楼下题解有毒，请勿跟抄**


##原公式：n(n-1)(n-2)(n-3)/24，为了防止太大，将原式改为：n\*(n-1)/2\*(n-2)/3\*(n-3)/4


##其实这题也不是光运用个公式就可以AC啦，第一是数据范围，用longint肯定不行，第4和第7个点过不去，其次是公式的运用，可千万别直接将公式复制上去，有毒有毒，如果你用原式n\*(n-1)/2\*(n-2)/3\*(n-3)/4只能AC6个点，因为用‘/’时返回值为实数，你必须得加个场宽，而div是整除，返回值为整数，当你把原式n\*(n-1)/2\*(n-2)/3\*(n-3)/4改为n\*(n-1) div 2\*(n-2) div 3\*(n-3) div 4 时，直接AC，所以还有个坑是这题的‘除‘必须得用div。。。。。。。。

另附pas代码：

```cpp
var n:qword;
begin
  readln(n);
  writeln(n*(n-1)div 2*(n-2)div 3*(n-3)div 4);
end.
```
#附：QAQ,刚刚又看了一下这题，发现原来的题解居然只能得84分了，所以又从新改了一下QAQ（雾）

---

## 作者：Slime (赞：4)

### 画图找规律，自己推公式。  
> ![](https://s1.ax1x.com/2018/10/31/iR8SJJ.png)  
第一个点有（4+3+2+1）\*0 个交点。  
![](https://s1.ax1x.com/2018/10/31/iR3voF.png)  
第二个点有（3+2+1）\*1 个交点。  
![](https://s1.ax1x.com/2018/10/31/iR3zi4.png)  
第三个点有（2+1）\*2 个交点。  
![](https://s1.ax1x.com/2018/10/31/iR8pW9.png)  
第四个点有（1）\*3 个交点。  
所以用（首项+末项）\*项数/2 可以求出总交点数。   
```cpp
#include<iostream>
int main(){
	unsigned long long re=0;
	int n;
	std::cin>>n;
	for(int i=1;i<=n-3;i++)
		re+=i*(n-i-1)*(n-i-2)/2;
	std::cout<<re;
}
```

---

## 作者：沧澜 (赞：4)

### 找规律

通过画图可发现：

```cpp
3:0；
4:1；    ->1；
5:5；    ->4；    ->3；
6:15；  ->10；  ->6；    ->3；
7:35；  ->20；  ->10；  ->4；  ->1；
8:70；  ->35；  ->15；  ->5；  ->1；
```
然后，根据初中所学的找规律的相关内容，可以解出一个一元四次方程：(n^4-6\*n^3+11\*n^2-6\*n)/24，然后，进行化简得：

n\*（n-1）/2\*(n-2)/3\*(n-3)/4,然后就完成了。

代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
unsigned long long n;
int main(){
    cin>>n;
    cout<<(n*(n-1)/2*(n-2)/3*(n-3)/4)<<endl;
    return 0;
}
```

---

## 作者：RicardoShips (赞：3)

本人数学几何学不太好，不清楚原来的结论，即那啥

## $n(n-1)(n-2)(n-3)\over{24}$

自己手推了一个，没那么好，给大家参考一下

首先，**每一个点射出去的线段数量都是相等的**

其次，**每一个点射出去的所有线段上的点的数量也是相等的**，这个可以推

然后，我们就可以先推每一个点射出去所有线段上的点的数量，再乘上点的数量（即输入$n$），就是最后的输出

我们观察样例，发现当$n=6$的时候，会射出去$n-3$条线，一条一条求吧

第一条是$4$个点，可以看成是$1*$($n-3$)

第二条是$6$个点，可以看成$2$*($n-4$)

用一个循环累加一下，再乘上点的数量，就是输出了？

但是这是错的，因为一个点会被多次遍历

那到底是多少次呢？

本人一开始以为是两次，两条线段交于一个点嘛

实际上是四次，两条线段会引出四个点（不要钻牛角尖跟我讲三个点，那种情况不算）

所以将刚才的结果除以$4$，就是最后的输出。

~~不打特判会爆精度~~

```c
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n;
    unsigned long long ans;
    ans=0;
	cin>>n;
	for(int i=1;i<=n-3;i++)
	    ans+=(n-i-2)*i;
	if(ans%4==0)
	    ans=ans/4*n;
	else if(ans%2==0)
	        ans=ans/2*n/2;
	    else if(ans%2==1)
	            ans=n/4*ans;
	cout<<ans;
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：3)

貌似没有用STLstring的题解

楼下说了就是求C n-4 n

那么我用的是公式C n m=m!/n!(n-m)!

那么如果把n-4当作n，n当作m的话，代入公式中得

C n-4 n=n!/(n-4)!\*4!即n\*(n-1)\*(n-2)\*(n-3)/24

因为n≤100000，所以要用到高精，求出n乘到(n-3)最后除以24即可

写高精乘，高精除以单精

```cpp
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
string x;
string times(string a,int bb)
{
    string b;while (bb)b.push_back(bb%10),bb/=10;
    string c;c.resize(a.length()+b.length(),0);
    reverse(a.begin(),a.end());
    for (int i=0;i<a.length();i++)
        for (int j=0;j<b.length();j++)
            c[i+j]+=a[i]*b[j],c[i+j+1]+=c[i+j]/10,c[i+j]%=10;
    reverse(c.begin(),c.end());
    while (!c[0] && c.length())c.erase(0,1);
    return c;
}
string divide(string a,int b)
{
    string c;int d=0;
    for (int i=0;i<a.length();i++)
        c.push_back((d*10+a[i])/b),d=(d*10+a[i])%b;
    while (!c[0] && c.length())c.erase(0,1);
    return c;
}
int main()
{
    cin>>n;x.push_back(1);
    if (n==3){cout<<"0";return 0;} //特判，否则无输出
    for (int k=n-3;k<=n;k++)x=times(x,k);  //计算n乘到(n-3)
    x=divide(x,24);  //除以24
    for (int i=0;i<x.length();i++)x[i]+=48;
    cout<<x;
    return 0;
}
```

---


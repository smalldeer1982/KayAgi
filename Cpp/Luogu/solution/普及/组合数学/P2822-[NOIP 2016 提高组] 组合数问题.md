# [NOIP 2016 提高组] 组合数问题

## 题目背景

NOIP2016 提高组 D2T1

## 题目描述

组合数 $\binom{n}{m}$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1,2,3)$ 三个物品中选择两个物品可以有 $(1,2),(1,3),(2,3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数 $\binom{n}{m}$ 的一般公式：

$$\binom{n}{m}=\frac{n!}{m!(n-m)!}$$

其中 $n!=1\times2\times\cdots\times n$；特别地，定义 $0!=1$。

小葱想知道如果给定 $n,m$ 和 $k$，对于所有的 $0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$ 有多少对 $(i,j)$ 满足 $k\mid\binom{i}{j}$。

## 说明/提示

【样例1说明】

在所有可能的情况中，只有 $\binom{2}{1} = 2$ 一种情况是 $2$ 的倍数。

【子任务】

![](https://cdn.luogu.com.cn/upload/pic/3457.png)

- 对于全部的测试点，保证 $0 \leq n, m \leq 2 \times 10^3$，$1 \leq t \leq 10^4$。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
2 5
4 5
6 7```

### 输出

```
0
7
```

# 题解

## 作者：Trinity (赞：521)

# 题目 ：P2822 组合数问题 2016 提高组 T1 & 组合数求解方法总结
## 题目描述  
组合数$C^m_n$表示的是从n个物品中选出m个物品的方案数。举个例子,从$(1,2,3)$三个物品中选择两个物品可以有$(1,2),(1,3),(2,3)$这三种选择方法。
根据组合数的定义，我们可以给出计算组合数的一般公式：  
$C^m_n=\frac{n!}{m!(n-m)!}$
其中$n!=1\times2\times\cdots\times n$特别地，定义$0!=1$。  
小葱想知道如果给定$n,m$和$k$对于所有的$0≤i≤n,0≤j≤min(i,m)$,有多少对 $(i,j)$满足$C_i^j$是$k$的倍数。 
## 分析
_1_.看一波数据范围，发现事情并没有这么简单![数据范围](https://cdn.luogu.com.cn/upload/pic/3457.png)
用公式不可能过。  
_2_.可以利用多组数据，加快组合数的求解。  
_3_.对数据取模可以防止溢出和TLE  
## 解题过程&题解
$1$ . $30$分 暴力(套公式法，千万别像我一样思维简单)  
对于小范围数据可以直接打阶乘和组合数公式，对于稍稍大的可以打出阶乘表( 下方未实现 ),但是对于超过long long范围的数据无能为力
```cpp
LL t,k,n,m,ans;
inline LL ck(LL x)//开long long可以算更多
{
  if(x==0)return 1;
  int sum=1;
  for(int i=1;i<=x;i++)sum*=i;
  return sum;
}
inline LL C(LL n,LL m)
{
  return ck(n)/(ck(m)*ck(n-m));//组合数公式
}
int main()
{
  t=read(),k=read();
  while(t--)
  {
    ans=0;
    n=read(),m=read();
    for(LL i=0;i<=n;i++)
      for(int j=0;j<=min(m,i);j++)
        if(C(i,j)%k==0)ans++;//统计
      printf("%lld\n",ans);
  }
  return 0;
}
```
$2$ . $70$分 组合数递推法    
针对大多数仅仅是利用组合数求解问题的题目运用递推法打表，不仅方便，而且可以稳稳地控制复杂度，对于需要多次引用组合数的题目效果极佳：  
基于组合数公理性质：$C^m_n=C^{n-m}_n$ （请大家务必记住此公式，由此在考场上灵活使用）
推得：$ C^m_n=C^{m-1}_{n-1}+C^m_{n-1}$  
 
   **_感谢各位大佬指出我的问题，确实当年的递推公式写错了，完全在于当时的我对其理解不清晰，特在高二退役后8个月修正_  **
 
由这个递推公式就可以熟练的写出组合数代码，但要注意初始化:   

$C^0_0=0$  
$C^i_0=C^1_0=C^1_1=1$   ( $i$为自然数 )  

同时，把表打出来后，我们会发现———这就是杨辉三角，这个三角可以解决很多问题，记住打印三角的方法也可以打出组合数。
```cpp
inline void build()//记得加入main函数，数组范围要开够，我就是在此RE。
{
  c[0][0]=1;
  c[1][0]=c[1][1]=1;//如上初始化，绝对绝对不能忘记或错，结合常识。
  for(int i=2;i<=2000;i++)
  {
    c[i][0]=1;
    for(int j=1;j<=2000;j++)//这不是此方法能承受的最大范围，打出题目要求的即可。
      c[i][j]=c[i-1][j-1]+c[i-1][j];//递推公式。
  }
}
inline void solve()
{
  build();
  t=read(),k=read();
  while(t--)
  {
    ans=0;
    n=read(),m=read();
    for(int i=0;i<=n;i++)
      for(int j=0;j<=my_min(i,m);j++)
        if(c[i][j]%k==0)ans++;
    printf("%lld\n",ans);
  }
}
```
$3$  . 90分 本题的特殊优化———取模大法（我没想出来，看了题解才恍然大悟 ）  
三部一取模，有效的防止溢出，还减少了递推的次数，但你会问为什么取模能保证递推式的正确性，而不加大位运算的时间呢？   
显然，我们带几个数字试一试，可以初步确定：  
$ (C^m_n)\bmod k=(C^{m-1}_{n-1})\bmod k+(C^{m}_{n-1})\bmod k$  
完全正确。  
但可惜的是，本题数据惊人，还是会TLE两个点，还需要继续优化和卡常。
```cpp
inline void build()
{
  c[0][0]=1;
  c[1][0]=c[1][1]=1;
  for(int i=2;i<=2000;i++)
  {
    c[i][0]=1;
    for(int j=1;j<=2000;j++)
      c[i][j]=(c[i-1][j-1]%k+c[i-1][j]%k)%k;//重中之重，绝不能盲目地模。
  }
}
```
$4$  . 95分 本人瞎搞出的玄学优化———先模再说  
$mod$是高级运算（ 可能运用了位运算 ）比四则运算更耗时。我们在建立组合数表的时候先判断元素是否满足整除条件，在主函数计数时可以减小计算量。（时间消耗）  
不信，来看![](http://m.qpic.cn/psb?/80c76f18-4372-4a40-bc51-07add1310ee4/KQcrWgRlrnXxlEeWBxT6MLnCCz1dc*w8mX6rNUI4X*o!/b/dAgBAAAAAAAA&bo=YwBhAAAAAAADByA!&rf=viewer_4)
```cpp
inline void build()
{
  c[0][0]=1;
  c[1][0]=c[1][1]=1;
  for(int i=2;i<=2000;i++)
  {
    c[i][0]=1;
    for(int j=1;j<=2000;j++)
    {
      c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
      if(c[i][j]%k==0)s[i][j]=1;//先记一下，如果已经满足条件，就标记一下，省去了更多的计算。
    }
  }
}
inline void solve()
{
  t=read(),k=read();
  build();
  while(t--)
  {
    ans=0;
    n=read(),m=read();
    for(int i=0;i<=n;i++)
      for(int j=0;j<=my_min(i,m);j++)
        ans+=s[i][j];
    printf("%lld\n",ans);
  }
}
```
$5$  .$100$分  前缀和+递推打表  
大家知道，即使打过表，算法的复杂度其实还多的一维，也就是这反复查询让人难以想到，使得我死死卡在95分一整天，才又翻了题解。  
前缀和，有效减少查询统计时的复杂度，每一次查询$O(n)$降到$O(1),绝对过的了  
记住：上加左 减左上 加自己（ by 巨佬[Arthur_L](https://www.luogu.org/blog/user42796/solution-p2822) )  
$ans[i][j]=ans[i][j-1]+ans[i-1][j]-ans[i-1][j-1]$
```cpp
inline void build()
{
  c[0][0]=1;
  c[1][0]=c[1][1]=1;
  for(int i=2;i<=2000;i++)
  {
    c[i][0]=1;
    for(int j=1;j<=i;j++)
    {
      c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
      ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1];//前缀和。
      if(!c[i][j])ans[i][j]++;//如果满足结论，计数加一。(有没有感觉很像我的玄学优化）
    }
    ans[i][i+1]=ans[i][i];//继承。
  }
}
inline void solve()
{
  t=read(),k=read();
  build();
  while(t--)
  {
    n=read(),m=read();
    if(m>n)printf("%lld\n",ans[n][n]);//如果m>n,ans只会达到n，只需输出ans[n,n]就可以了。
    else printf("%lld\n",ans[n][m]);
  }
}
```
## 总结
_1_.需掌握组合数的基本两种求解方法(通项公式，递推公式），根据数据范围选定方法。  
_2_.结合数据范围找到优化方法，无论是取模还是自己的玄学优化都尝试一下.(建议取模输出的题，绝！对！不！要！乱！模！，既费时又易错)  
_3_.掌握前缀和，利用前缀和对降维的作用。 

最后，我的题解又臭又长，主要是总结求解组合数的各种方法，其次分享一下自己的优化(卡常)技巧，谢谢大家的更正。


---

## 作者：纸片人 (赞：168)

#### 要写出这道题，你需要掌握：

### 组合数与杨辉三角的关系、前缀和

//当然我说的是AC，如果只会前者也能90分

------------

AC代码：

```
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll t,flag[2002][2002];
int k,f[2002][2002];
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;
	for (int i=2;i<=2000;i++){
		f[i][0]=1;
		for (int j=1;j<=i;j++){
			f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
			flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
			if (f[i][j]==0) flag[i][j]++;
		}
		flag[i][i+1]=flag[i][i];//本篇题解的重点，这里想明白了这题就很简单了
	}
}
int main (){
	scanf("%lld%d",&t,&k);
	yh();
	while (t--){
		int m,n;
		scanf("%d%d",&n,&m);
		if(m>n) printf("%lld\n",flag[n][n]);
		else printf("%lld\n",flag[n][m]);
	}
	return 0;
}
```


------------

先说说一开始的思路。**不用任何高级做法就能拿到90这个看起来还能过得去的分数你敢信吗？**

同学们如果接触过杨辉三角，并且对它有一定的了解的话，一定会知道有这样一个性质：

**第n行的m个数可表示为 C(n-1，m-1)，即为从n-1个不同元素中取m-1个元素的组合数。**

所以在这道题里面，完全可以通过杨辉三角把需要用到的组合数给算出来，%k判一下存到数组 f[i][j] 里，若 f[i][j]==0,则计数器ans+1。最后输出ans的值就好啦。

那么怎么通过杨辉三角把需要用到的组合数给算出来呢？看代码。

```
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;//初始化前两行
	for (int i=2;i<=2000;i++){
		f[i][0]=1;//每行第一个都是1
		for (int j=1;j<=2000;j++){
			f[i][j]=(f[i-1][j-1]+f[i-1][j])%k;//这句很重要！！！【tip1】
			if (f[i][j]==0) flag[i][j]=1;//bool型的flag数组用来存f是否符合要求【tip2】
		}
	}
}
```
【tip1】因为杨辉三角的性质（上文提到过），组合数实际上是和杨辉三角里每个数一一对应的，那就可以将题目要求的组合数转化为杨辉三角了。

```
f[i][j]=f[i-1][j-1]+f[i-1][j];//不带任何优化的杨辉三角递推公式
```

但，杨辉三角到下面会变得很大，不带任何优化无疑过不了。题目中明确地说明了：只要统计满足是k的倍数的C(i，j)。

那么很显然，**先把k给%了再说啊**！！这样一来f数组里的数字小了很多，所以就是上面代码里的写法了。

【tip2】照应前面没放出来的主函数部分代码
```
for (int i=0;i<=n;i++){
	for (int j=0;j<=min(i,m);j++){
	    ans+=flag[i][j];//因为flag里现在符合要求的是1，不符的是0，所以直接加就好啦
	}
}
```

------------
看起来很有道理是吧？除去部分超大数据能拿不少分是吧？然鹅lz却拿到了美丽的50分。

![](https://cdn.luogu.com.cn/upload/pic/70880.png)
是不是很美腻qwq

为什么会50？看一眼圣诞树般的评测记录，结合数据范围，可以看出一开始的代码所有t是long long的点都WA了。检查，果然t开到int去了。

```
#define ll long long
ll f[2002][2002],y,ans,flag[2002][2002];
int t,k;// <=就是这里
```
超微扯出来一点，像“范围没开够”这种错误实际上并不少见，当只过了部分的时候，不妨好好看看数据范围。下图即为本题数据范围，很明显，只要是t过大的点就是红的。

![](https://cdn.luogu.com.cn/upload/pic/3457.png)

------------

改好这个，然后还是50.。。原来WA的点还是WA，下了数据（为了写文件输入输出对比还翻出了陈年笔记）。结果比答案大很多，由此推断是累加器出问题了。果然ans忘记在循环里初始化了。。。（过去最常犯的错误）

```
while (t--){
	ans=0;//一定不要忘记初始化！！！
    //……（中间代码略去）
	printf("%d\n",ans);
}
```
------------


于是90了，剩下要用前缀和只能现学：[一篇谁都能看懂的前缀和](https://blog.csdn.net/k_r_forever/article/details/81775899)

二维前缀和的公式：$ ans[i][j]$=$ ans[i][j−1] $ + $ ans[i−1][j] $ − $ans[i−1][j−1] $

**BUT!!!!你离成功还有一步！！！**（也正是这一步卡了我好久）

## 敲黑板，这是本篇题解最重要的部分，别的题解都没有写到。


#### 前方低能，请大佬光速撤离以免窥探蒟蒻的世界！没完全搞懂的童鞋们可以看过来了!

虽然AC代码开头就放过了，但不麻烦大家翻了，把重要部分再放一次：

```
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;
	for (int i=2;i<=2000;i++){
		f[i][0]=1;
		for (int j=1;j<=i;j++){
			f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
			flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
			if (f[i][j]==0) flag[i][j]++;
		}
		flag[i][i+1]=flag[i][i];//本篇题解的重点，这里想明白了这题就很简单了
	}
}
```
是的，重点就是“$ flag[i][i+1]$=$flag[i][i]$;”这句看起来简单的话，实际上，就算你会了前缀和，不加上这句话也A不了。

WHY?我们来看个实例感受一下就知道了。

![](https://cdn.luogu.com.cn/upload/pic/70898.png )

（鼠标写字丑，谅解一下。下面就用颜色来说了，如果有色盲或者色弱的同学lz表示抱歉）

以上三个输出的是什么呢，当输入k的时候，将代码中的flag数组前10x10 位打出来，此处k=5.

图1，是正确的写法，代码如下：（和前面差不多，此处只是为了输出比较，可以跳过这个代码不看）

```
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;
	for (int i=2;i<=2000;i++){
		f[i][0]=1;
		for (int j=1;j<=i;j++){//图3是j<=2000，为了把整个矩形打出来看
			f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
			flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
			if (f[i][j]==0) flag[i][j]++;
		}
		flag[i][i+1]=flag[i][i];//图1的写了这句重要的话，图2没写
	}//i是行数，j是列数 
	for (int i=0;i<=10;i++){
		for (int j=0;j<=10;j++){
			cout<<flag[i][j]<<"   ";
		}
	    cout<<endl;
	}
}
```
图2图3代码与图1的区别在上面代码的注释中

对比1、2的结果来看，从 j=6开始，输出就不一样了（米色笔圈出来的地方），**且2的输出要比1的小**。

为了方便说明原因举个栗子，如图中用白色光标点出来的部分（图1是7，图2是3）。为什么图2会比正确答案小呢？我们看看图3就知道了。图3中蓝笔圈出来的，就是图1没打出来的部分flag数组。

关注点转移到三个结果都用绿色笔圈出来的部分。由3可一看出，1中（绿色圈出来的）**右上角没打出来的其实是4**，（因为$flag[i][i+1]$=$flag[i][i]$，**这个4实际上是由空格处前一个的4转移来的**）；而因为没用这句话，**2中右上角的空格实际上是0**（没有进行过操作，就是flag数组的初值0）

如果将这个空格里的数设为x，白色光标的数设为y的话，那么由于flag中的数是由前缀和算出来的，y=x+4+7+4-4=x+4+7.如果没用这句话，那么结果就会像2中一样，反而比前面小。**范围大了反而符合要求的数字变少了，这很显然就是错误的。**

还有一点，为什么这个式子就是正确的？

既然要证实这个，我们不妨抛弃掉所以有技巧的方法，就用最最基本的公式死算暴力出答案看看是不是这样的，实验结果如下：

![](https://cdn.luogu.com.cn/upload/pic/70910.png)

（代码是第一篇题解里给出的30分代码，非lz自己写的，特此声明）

可以看出，$flag[i][i+1]$和$flag[i][i]$的的确确是一样的，那么$ flag[i][i+1]$=$flag[i][i]$就能合情合理且正确地用了。简单理解可以就把它认为是设置边界。

------------
完结撒花 ★,°*:.☆(￣▽￣)/$:*.°★* 。


---

## 作者：Zskioaert1106 (赞：6)

题目传送门：[P2822 [NOIP2016 提高组] 组合数问题](https://www.luogu.com.cn/problem/P2822)

###### [原文，但是被拒了。](https://www.luogu.com/article/xm45r3ma/)

众所周知杨辉三角表现在二维数组里就是 $f_{i,j}=f_{i-1,j-1}+f_{i-1,j}$。

而众所又周知：

$$
\begin{equation}
\begin{aligned}
&\binom{n-1}{m-1}+\binom{n-1}{m}\\
\\=&\frac{(n-1)!}{(m-1)![(n-1)-(m-1)]!}+\frac{(n-1)!}{m![(n-1)-m]!}\\
\\
=&\frac{(n-1)!m}{m!(n-m)!}+\frac{(n-1)!(n-m)}{m!(n-m)!}\\
\\
=&\frac{(n-1)!(m+n-m)}{m!(n-m)!}\\
\\
=&\frac{n!}{m!(n-m)!}\\
\\
=&\binom{n}{m}
\end{aligned}
\end{equation}
$$

所以组合数可以直接用杨辉三角来推。$2\times 10^3$ 的数据范围正好开二维数组，而之前会爆 long long 却无计可施的原因是除法不能取模，现在变成加法就可以了。而我只关心它模 $k$ 的余数。于是：

```cpp
const int MAXN=2000;
int t,n,m;
long long k;
int C[2003][2003];//存 C(n,m) 模 k 后的余数
int main(){
	cin>>t>>k;
	for(int i=0;i<=MAXN;i++){
    	for(int j=0;j<=i;j++){
    		if(j==0||j==i)C[i][j]=1;
    		else C[i][j]=(C[i-1][j-1]+C[i-1][j])%k;
    	}
    }
	while(t--){
		int ans=0;
		cin>>n>>m;
		for(int i=0;i<=n;i++){
			int mn=min(i,m);
			for(int j=0;j<=mn;j++){
				ans+=(C[i][j]%k==0);
			}
		}
		cout<<ans<<'\n';
	}
	return 0;
}
```

得分：[$90$pts](https://www.luogu.com.cn/record/195917636)。

剩下的两个点 TLE 了。


我发现，每次求的东西都是从 $0$ 遍历到 $n$，然后每维再从 $0$ 遍历，这样求一个二维相邻部分的状态和。所以可以很容易地使用二维前缀和优化。

```cpp
#include<iostream>
using namespace std;
const int N=2000;
int t,n,m,k;
int C[2003][2003];//杨辉三角
int d[2003][2003];//前缀和
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);  
	cin>>t>>k;
	for(int i=0;i<=N;i++){
		for(int j=0;j<=i;j++){
			if(j==0||j==i)C[i][j]=1;
			else C[i][j]=(C[i-1][j-1]+C[i-1][j])%k;
		}
	}
	for(int i=0;i<=N;i++){
		for(int j=0;j<=N;j++){
			if(j<=i)d[i][j]=d[i-1][j]-d[i-1][j-1]+d[i][j-1]+(C[i][j]%k==0);//二维前缀和的式子
			else d[i][j]=d[i][i];//杨辉三角的空白部分要填充上
		}
	}
	while(t--){
		cin>>n>>m;
		cout<<d[n][min(n,m)]<<'\n';//答案
	}
	return 0;
}
```

得分：[$100$pts](https://www.luogu.com.cn/record/195920585)。

---

## 作者：「QQ红包」 (赞：5)

全部预处理出来。

组合数的递推式可以自己推。

n个物品中取m个物品，若不取这个物品，则从n-1，m推过来，若取这个物品则从n-1，m-1推过来。

所以f[i][j]=f[i-1][j-1]+f[i-1][j]

```cpp
#include<cstdio>
#include<iostream>
#include<map>
#include<set>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>
#include<queue>
#include<stack>
#include<vector>
using namespace std;
long long f[2011][2011];
long long h[2011],l[2011]; 
long long ff[2011][2011];
long long n,m,k,t,i,j;
int main()
{
    scanf("%d%d",&t,&k);
    f[0][0]=1;//初始化 
    for (i=1;i<=2001;i++)
    {   f[i][0]=1;
        for (j=1;j<=i;j++)
        {
            f[i][j]=(f[i-1][j-1]+f[i-1][j])%k;//递推求组合数，记得去模！ 
            if (f[i][j]==0) //是k的倍数 
            {
                h[i]++;//统计，h[i]是存第i行有多少个符合条件的组合数 
            }
            ff[i][j]=ff[i-1][j]+h[i];//ff[i][j]是存对于n=i，m=j时候的方案数的 
            if (j==i) ff[i][j]=h[i]+ff[i-1][j-1];//特判一下 
        }
    }
    while (t--)
    {
        scanf("%d%d",&n,&m);//读入 
        if (m>n) m=n;//题目说明了0 <= j <= min(i,m)，也就是m应要<=n; 
        printf("%d\n",ff[n][m]);//输出 
    }
    return 0;
}
```

---

## 作者：Gorun (赞：4)

# 组合数问题 题解

### 1. 在考场上的思路

首先看到这道题，可以使用暴力，具体思路如下。

组合数里面有阶乘，求一个数的阶乘可以使用如下递推公式：

$Fact(x)=\begin{cases}x \times Fact(x-1)&x>=1\\1&x=0\end{cases}$

再结合组合数公式：

$C_n^m=\dfrac{Fact(n)}{Fact(m)\times Fact(n-m)}$

可以枚举所有的$i,j$，一个个验证。

但是这样写有两个问题：

1. 时间复杂度过高：计算单次$Fact(x)$所用的时间是$O(n)$，那么把所有的$i,j$都枚举出来，最坏的情况就是$O(3\times n\times n^2)$，必爆无疑。

2. 精度问题，$Fact(x)$的增长速度过快，$Fact(22)>UnsignedLLong_{max}$想算也算不了了（应该没有人会想到高精度吧）

所以我们可以先把前面的$C_i^j$输出出来看看，结果惊喜地发现：

**“这不就是杨辉三角吗？”**

当然大神们可以省略以上的分析步骤直接得出杨辉三角的结论。

### 2. 自己研究时的思路

有了杨辉三角，我们就把原本的阶乘乘除解决了，可以使用递推法，精度问题也不需要担心，毕竟$k$的值是一定的，我们可以对于每一个递推出来的组合数取模，结果是0个数的即为答案。即：

$C_i^j=\begin{cases}(C_{i-1}^j+C_{i-1}^{j-1})\bmod k&j\in [1,i]
\\1&j=0\end{cases}$

$Ans_i^j$定义为取模之后的杨辉三角中的前缀0个数，严谨地说：

$Ans_i^j=Ans_{i-1}^{j}+Ans_{i}^{j-1}-Ans_{i-1}^{j-1}+\begin{cases}0&C_i^j \ne 0\\1&C_i^j =0\end{cases}(j<=i)$

$Ans_i^{j}=Ans_i^i(j=i+1)$

其实就是利用了前缀和的思想，不过需要注意的是当$j=i+1$的情况，按道理来说这个地方应该是没有数的，这里的目的是为了在下一行最后一个递推的时候能够去除越界带来的影响。

附源代码：

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long ll;
const int MAXN=2010;
const int MAXT=1010;
int t;
struct Task{
	ll a,b;
}task[MAXT];
ll n,m,k,c[MAXN][MAXN],ans[MAXN][MAXN];
inline void solve()
{
	c[0][0]=1;
	for (ll i=1;i<=2000;i++)
	{
		c[i][0]=1;
		for (ll j=1;j<=i;j++)
		{
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%k;
			ans[i][j]=ans[i-1][j]+ans[i][j-1]-ans[i-1][j-1]+(c[i][j]?0:1);
		}
		ans[i][i+1]=ans[i][i];
	}
}
int main()
{
	scanf("%d%lld",&t,&k);
	solve();
	while (t--)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		printf("%lld\n",ans[a][min(a,b)]);
	}
}
```


---

## 作者：HHC883 (赞：2)

# 题目分析
如果能预处理出对于所有的 $n , m \le 2 \times 10^3$，$\binom{n}{m} \bmod k$ 是否为 $0$，再用二维前缀和统计一下，即可做到 $O(1)$ 回答。

现在问题变为如何快速计算 $\binom{n}{m}$。

容易发现，

$$\begin{aligned}
\binom{n}{m}
& = \frac{n!}{m!(n - m)!} \\
& = \frac{(n - 1)! \cdot n}{m!(n - m)!} \\
& = \frac{(n - 1)![m + (n - m)]}{m!(n - m)!} \\
& = \frac{(n - 1)! \cdot m + (n - 1)!(n - m)}{m!(n - m)!} \\
& = \frac{(n - 1)! \cdot m}{m!(n - m)!} + \frac{(n - 1)!(n - m)}{m!(n - m)!} \\
& = \frac{(n - 1)!}{(m - 1)!(n - m)!} + \frac{(n - 1)!}{m!(n - m - 1)!} \\
& = \frac{(n - 1)!}{(m - 1)![(n - 1) - (m - 1)]!} + \frac{(n - 1)!}{m![(n - 1) - m]!} \\
& = \binom{n - 1}{m - 1} + \binom{n - 1}{m}
\end{aligned}$$

于是，我们得到了递推公式

$$\binom{n}{m} = \binom{n - 1}{m - 1} + \binom{n - 1}{m}$$

这样，由 $\binom{0}{0} = 1 , \binom{n}{n + 1} = 0$，我们就可以快速完成预处理了。

时间复杂度为 $O(\max{n} \max{m} + t)$。
# 参考代码
```cpp
#include<iostream>
using namespace std;
int t,k,c[2005][2005],pre[2005][2005];
int main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>t>>k;
	c[1][0]=c[1][1]=1%k;
	for(int i=2;i<=2000;i++){
		c[i][0]=1;
		for(int j=1;j<=i;j++){
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%k;
			pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1];
			if(!c[i][j]) pre[i][j]++;
		}
		pre[i][i+1]=pre[i][i];
	}
	int n,m;
	while(t--){
		cin>>n>>m;
		if(m>n) cout<<pre[n][n]<<'\n';
		else cout<<pre[n][m]<<'\n';
	}
	return 0;
}
```

---

## 作者：zlqwq (赞：2)

有点像组合数板子。

众所周知，组合数的递推公式和杨辉三角是一样的。

就是这个 $f_{n,m}=f_{n-1,m}+f_{n-1,m-1}$。

这个式子就是在解决从 $n$ 个里选 $m$ 个的问题。

只需要看第一个选不选，如果不选就从剩下的 $n-1$ 个里挑 $m$ 个。否则就是从 $n-1$ 个挑 $m-1$ 个。

放在二元组 $(i,j)$ 的值由其上方两个数决定的杨辉三角中，这个式子也是合理的。

然后我们发现这个 $f_{i,j}$ 我们只关心它对 $k$ 的余数，所以，我们就得出了这道题的递推式。就是让上面那一坨对 $k$ 取模。

但是，我们发现这个 $t$ 次询问非常的烦人，因为每次都要去枚举，所以肯定超时。

没关系，我们加一个二维前缀和数组 $ans$ 维护一下即可。

这样就边处理 $f$ 边对 $ans$ 做跟新。

对于询问，直接输出 $ans_{n,m}$ 即可。


```cpp
#include<iostream>
#define int long long
#define inf 2e9
#define debug cout << "zlqwq"
#define llinf 1e18

using namespace std;
int t,k,n,m,f[2005][2005],ans[2005][2005];
signed main() {
	cin >> t >> k;
	for(int i = 0;i <= 2000;++i) {
		f[i][0] = 1;
	}
	for(int i = 1;i <= 2000;++i) {
		for(int j = 1;j <= 2000;++j) {
			f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % k;
			if(f[i][j] == 0 && i >= j) {
				ans[i][j]++;
			}
			ans[i][j] += ans[i][j - 1] + ans[i - 1][j] - ans[i - 1][j - 1];
		}
	}
	while(t--) {
		cin >> n >> m;
		cout << ans[n][m] << '\n';
	}
	return 0;
}
```

---

## 作者：stringdp100005 (赞：1)

# 解题思路
看到多组测试数据，自然想到预处理。  
有什么办法可以高效预处理组合数呢？先分析一下：

$
\begin{aligned}
C_n^m&=\dfrac{n!}{m!(n-m)!}\\&=\dfrac{n(n-1)!}{m!(n-m)!}\\&=\dfrac{[m+(n-m)](n-1)!}{m!(n-m)!}\\&=\dfrac{m(n-1)!}{m!(n-m)!}+\dfrac{(n-m)(n-1)!}{m!(n-m)!}\\&=\dfrac{(n-1)!}{(m-1)!(n-m)!}+\dfrac{(n-1)!}{m!(n-m-1)!}\\&=C_{n-1}^{m-1}+C_{n-1}^m
\end{aligned}
$

还要考虑边界情况，也就是 $C_n^n=C_n^0=1$。  
这样，我们就可以递推求解组合数了，注意每次计算时都要对 $k$ 取模。  
而直接这样递推是不行的，还需要适当的优化。  
考虑使用二维前缀和，如果满足要求，$a_{i,j}=1$，否则 $a_{i,j}=0$。  
而二维前缀和就是 $s_{i,j}=s_{i-1,j}+s_{i,j-1}-s_{i-1,j-1}+a_{i,j}$，画个图很容易理解。  
每次询问时输出前缀和即可。
# AC 代码
```cpp
#define Code using
#define namespace by
#define std stringdp100005
#include<bits/stdc++.h>
#define int long long
Code by stringdp100005;
int dp[2005][2005],s[2005][2005];
int t,k,n,m;
void init(){
	for(int i=0;i<=2000;i++) dp[i][i]=dp[i][0]=1;//边界情况处理
	dp[1][1]=1;
	for(int i=2;i<=2000;i++){
		for(int j=1;j<=i;j++){
			dp[i][j]=(dp[i-1][j]+dp[i-1][j-1])%k;//每次取模减少运算量
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+(dp[i][j]==0);//二维前缀和
		}
		s[i][i+1]=s[i][i];
	}
}
signed main(){
	cin>>t>>k;
	init();
	while(t--){
		cin>>n>>m;
		if(m>n) cout<<s[n][n]<<"\n";//我就被这个坑过， m>n 时组合数是无意义的
		else cout<<s[n][m]<<"\n";
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

# 题解：P2822 [NOIP2016 提高组] 组合数问题

## 思路

杨辉三角模板题。

想要深入了解[杨辉三角](https://baike.baidu.com/item/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/215098)可在百度百科中查看，这里仅稍作讲解。

我们知道组合公式：

$$C\textstyle\binom{n}{m}=\frac{n!}{m!(n-m)!}$$

而杨辉三角则是数形结合：

![](https://cdn.luogu.com.cn/upload/image_hosting/5bn1b87c.png)

我们发现，$C(i, j)$ 为它左上角（$C(i - 1, j - 1)$）和右上角（$C(i - 1, j)$）的两个值的和。

当然也有一个在本题用不到的性质：第 $i$ 行的总和为 $2 ^ {i - 1}$。

这是我对于本题的思路推导：

- 第一步：计算杨辉三角。
- 第二步：计算杨辉三角对 $k$ 取模。
- 第三步：计算杨辉三角对 $k$ 取模后里面有几个 $0$。

为什么是对 $k$ 取模呢？

因为本题需要我们求有多少对 $(i, j)$ 满足 $k \mid C(i, j)$，因此我们对 $k$ 取模。

这样就基本没有问题了。

如果你想获得剩下的 $5$ 分，可以使用前缀和处理后面的大规模数据。

前缀和在本题主要有三个用途：

1. 降低时间  
    例如，查询 $C(0, 0)$ 到 $C(5, 5)$ 的范围，需要遍历 $36$ 个（从 $(0, 0)$ 到 $(5, 5)$ 总共 $6 \times 6$ 个位置）组合数进行判断和计数。  
    而使用前缀和，我们只需要事先通过一次遍历计算，把所有可能的前缀和信息都存储在 $sum$ 数组中。后续查询任何一个范围时，直接通过 $sum_{x, y}$ 就能获取到对应的总和。
2. 快速查询  
    假设我们想知道从 $C(a, b)$ 到 $C(n, m)$ 这个子区域内组合数取模为 $0$ 的个数总和，利用前缀和可以方便地通过几个简单的计算得出结果。  
    如果已经计算好了二维前缀和数组 $sum$，这个子区域的总和可以通过公式来得到。  
    这就相当于把整个二维区域的组合数按照一定顺序进行了所谓的“累加”存储在 $sum$ 数组中，通过简单的公式就能快速获取任意指定子区域的统计总和，而不需要再次去逐个查看子区域内的每个组合数情况。
3. 契合本题  
    本题中程序的流程是先进行一些预处理（计算组合数取模和对应的前缀和），然后要根据输入的 $t$ 次不同的 $n$ 和 $m$ 值，去查询相应范围内组合数取模为 $0$ 的个数总和。  
    由于存在多次查询不同范围的情况，使用前缀和这种数据结构和计算方式，正好契合这种需求，能够在预处理阶段花费一定时间去计算前缀和，之后在多次查询阶段快速获取结果，能大大优化程序。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int c[2010][2010], sum[2010][2010];
void calcC(int n,int m,int k){
	memset(c,-1,sizeof(c));
	for(int i = 0;i <= n;i++){
		c[i][0] = c[i][i] = 1 % k;
		for(int j = 1;j < i;j++){ 
			c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % k;
		}
	}
}
void calcSum(int n, int m) {
	for(int i = 0;i <= n;i++){
		sum[i][0] = (c[i][0] == 0);
		for(int j = 1;j <= m;j++){
			sum[i][j] = sum[i][j - 1] + (c[i][j] == 0);
		}
	}
	for(int i = 1;i <= n;i++){
		for (int j = 0;j <= m;j++){
			sum[i][j] = sum[i - 1][j] + sum[i][j];
		}
	}
	
}
int main(){
	int t,k,n,m;
	cin>>t>>k;
	calcC(2000,2000,k);
	calcSum(2000,2000);
	while(t--){
		cin>>n>>m;
		cout<<sum[n][m]<<endl;
	}
	return 0;
}
```

---

## 作者：xingshuyan000 (赞：1)

# 题外话

刚学完排列组合没多久，来做个[组合数问题（NOIP2016）](https://www.luogu.com.cn/problem/P2822)玩一玩。

可能是我组合数写 $C_n^m$ 写习惯了，突然看到 $n \choose m$ 不太适应（不过影响不大），所以我在这篇题解里面就写成 $C_n^m$ 的形式了。

# 题目分析

**前置知识：组合数**

先来看一下组合数的定义（该定义来自人教 A 版高中数学选择性必修第三册第六章第 6.2.2 节）：从 $n$ 个不同元素中取出 $m(m \le n)$ 个元素的所有不同组合的个数，叫做从 $n$ 个不同元素中取出 $m$ 个元素的**组合数**，用符号 $C_n^m$ 表示。组合数也可以用符号 $n \choose m$ 来表示。

组合数的计算公式：

$$C_n^m=\frac{n!}{m!(n-m)!}$$

在这个公式中，$n!$ 表示正整数 $1$ 到 $n$ 的连乘积，叫做 $n$ 的阶乘。即 $n!=\prod_{i=1}^n i$。另外，我们规定：$0!=1$。

组合数有如下的两个性质：

- $C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$；

- $C_n^i=C_n^{m-i}$，其中 $i \in [0,m]$ 且 $i \in \mathbb N$。

至于这道题呢，我们观察一下数据范围，$n,m \le 2 \times 10^3$，所以我们可以先预处理出每个组合数的值。这一共有两个方法：第一种方法，直接利用组合数公式求解，这样的话，需要你先算出所有 $i!(0 \le i \le n)$ 和 $j!(0 \le j \le m)$ 的值，但是如果 $n,m$ 的值稍微大一点点，就会直接爆 long long，需要写高精度，而且非常麻烦，复杂度也比较高，于是，这种方法就被 pass 掉了；第二种方法，刚才我提到了组合数的一个性质：$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$，这不就可以直接递推求解了吗，这样的时间复杂度应该是 $O(nm)$ 的。

然后，这道题给你 $t$ 组询问，对于每次询问，给你两个整数 $n,m$，你需要找到对于 $0 \le i \le n$ 和 $0 \le j \le \min(i,m)$，有多少组 $(i,j)$ 满足 $C_i^j$ 是 $k$ 的倍数。

其实暴力法很容易就能想到，直接暴力枚举每个 $i,j$，如果找到满足题意的，就给答案数 +1，但是这样，单组询问的时间复杂度就已经达到了 $O(nm)$，而一共 $t$ 组询问——直接 T 飞了。

考虑优化。我们考虑使用二维前缀和进行优化，对于每一个 $C_i^j$，如果 $C_i^j \mod k=0$，那么对应位置的前缀和数组就 +1。在预处理组合数的值的同时，我们就可以对二维前缀和进行计算、更新，这样，在查询的时候只需要使用 $O(1)$ 的复杂度就可以完美解决问题（对于一组询问），而一共 $t$ 组询问，最后只需要用 $O(t)$ 的复杂度就可以解决查询的问题。

这样子下来，本题的时间复杂度就是 $O(t+\max n \cdot \max m)$，可以完美通过本题。

# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2050;
int C[N][N], sum[N][N];
int t, k;
void init()
{
	C[0][0] = C[1][0] = C[1][1] = 1;
	for(int i = 2; i <= 2000; i ++) C[i][0] = C[i][i] = 1;//给每个C[i][0]和C[i][i]赋初始值为1
	for(int i = 2; i <= 2000; i ++)
	{
		for(int j = 1; j <= i; j ++)
		{
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % k;//求出来值以后直接对k取模
			sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];//二维前缀和的模板
			if(C[i][j] == 0) sum[i][j] ++;//如果C[i][j]是k的倍数，sum[i][j]++
		}
		sum[i][i + 1] = sum[i][i]; //因为组合数要保证i>j，所以为了避免组合数
								   //的意义丧失，就在这里给sum[i][i+1]赋值为sum[i][i]
	}
	return;
}
void solve()
{
	int n, m;
	cin >> n >> m;
	cout << (m <= n ? sum[n][m] : sum[n][n]) << "\n";//还是注意组合数要保证m<=n
	return;
}
int main()
{
	cin.tie(nullptr) -> sync_with_stdio(false);
	cout.tie(nullptr);
	cin >> t >> k;
	init();
	while(t --) solve();
	return 0;
}
```

---

## 作者：___AaAa_bBcCd___ (赞：1)

## [P2822 [NOIP2016 提高组] 组合数问题](https://www.luogu.com.cn/problem/P2822)

这题只要知道杨辉三角和前缀和的应用就可以迎刃而解了。

### 杨辉三角

组合数函数可以用杨辉三角推导而得。具体地，$\binom{i}{j}=\binom{i-1}{j}+\binom{i-1}{j-1}$。这个相信各位同学都学过。没学过也不要紧，很容易就可以算出来。

这时我们就可以用到杨辉三角了，它的推导过程与上面一样，所以我们可以建立一个 $(2\times 10^3)^2$ 的二维数组来存储每个 $\binom{i}{j}$。

此处我们只关心 $\binom{i}{j} \bmod k$ 的值，原值会很大，为了防止溢出，我们要在每次操作后将记录的值对于 $k$ 取模。

可是多组数据每次都要遍历 $\Theta(nm)$ 的时间真的很烦诶，于是我们可以用二维前缀和存储。

### 二维前缀和

定义 $qzh_{n,m}$ 表示所有的 $0\leq i\leq n,0\leq j\leq \min \left ( i, m \right )$ 中 $(i,j)$ 满足 $k\mid\binom{i}{j}$ 的数量。

我们可以用二维前缀和公式来用与建立杨辉三角相同的时间预处理所有的 $qzh_{n,m}$。要注意的地方除了边界以外还有一个，就是当 $m>n$ 时，多出来的这部分是无意义的，所以可以让 $qzh_{n,m}\leftarrow qzh_{n,n}(n<m)$，具体见代码。

### 代码编写

```cpp
#include<bits/stdc++.h>
using namespace std;
int yanghui[2001][2001];
int qzh[2001][2001];
int t,k,n,m;
int main(){
     cin>>t>>k;
     for(int i=0;i<=2000;i++){
        for(int j=0;j<=i;j++){
/*杨辉三角边界*/if(j==0||i==j)yanghui[i][j]=1;
/*公式*/        else yanghui[i][j]=yanghui[i-1][j]+yanghui[i-1][j-1];
/*取模防止溢出*/yanghui[i][j]%=k;

/*零维边界*/    if(i==0&&j==0)qzh[i][j]=(yanghui[i][j]==0);
/*一维边界*/    else if(j==0)qzh[i][j]=qzh[i-1][j]+(yanghui[i][j]==0);
/*二维前缀和*/  else if(j<=i)qzh[i][j]=qzh[i][j-1]-qzh[i-1][j-1]+qzh[i-1][j]+(yanghui[i][j]==0);
         }
         for(int j=i+1;j<=2000;j++){
/*没有意义处*/  qzh[i][j]=qzh[i][i];
         }
     }
     for(int i=0;i<t;i++){
         cin>>n>>m;
         cout<<qzh[n][m]<<endl;
     }
     return 0;
}
```

这样预处理的时间是 $4\times 10^6$，每次查询是 $\Theta(1)$，[可以通过本题](https://www.luogu.com.cn/record/197015499)。

---

## 作者：qhr2023 (赞：1)

## solution

组合数学加前缀和。

有 $n$ 个数选 $m$ 个数，求方案数 $C_{n, m}$，对于其中一个数考虑选不选。
* 若选这个数，则应在另外 $n-1$ 个数中选 $m-1$ 个数，方案数 $C_{n-1, m-1}$。
* 若不选，则要在另外 $n-1$ 个数中选 $m$ 个数，方案数 $C_{n-1, m}$。

由加法原理得到组合数递推公式：$C_{n, m}=C_{n-1, m}+C_{n-1, m-1}$。

题目要求是 $k$ 的倍数，加个取模即可，$C_{n, m}=(C_{n-1, m}+C_{n-1, m-1}) \mod k$，若是 $0$ 则是 $k$ 的倍数。

问题转化成求有多少 $C_{i, j}$ 为 $0$。

这个可以用二维前缀和预处理，这样单次查询就是 $\mathcal O(1)$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, k, n, m, c[2005][2005], s[2005][2005];
int main(){
	cin >> t >> k;
	c[1][1]=1;
	for(int i=0; i<=2000; i++) c[i][0]=1;
	for(int i=2; i<=2000; i++)
		for(int j=1; j<=i; j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%k;
	for(int i=2; i<=2000; i++){
		for(int j=1; j<=i; j++)
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+(!c[i][j]);
		s[i][i+1]=s[i][i];
	}
    while(t--)
    	cin >> n >> m,
    	cout << s[n][min(m, n)] << '\n';
    return 0;
}
```

---

## 作者：zhangzirui66 (赞：1)

组合数，还是多测，考虑预处理所有答案。

组合数的递推公式如下，证明在本文底部：

$$
C_{i,j} = C_{i - 1, j} + C_{i - 1, j - 1}
$$

由于求的是是否能被 $k$ 整除，转化式子为：

$$
C_{i,j} = (C_{i - 1, j} + C_{i - 1, j - 1}) \bmod k
$$

易得若 $C_{i,j} = 0$ 即为可整除。

但这样每次询问还需枚举 $C$ 数组，直接二维前缀和优化即可。

预处理复杂度为 $O(n^2)$，单次查询 $O(1)$，可以通过：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t, k, n, m, c[2005][2005], ans[2005][2005];
void init(){
	c[0][0] = c[1][0] = c[1][1] = 1;
	for(int i = 2; i <= 2000; i ++){
		c[i][0] = 1;//赋上初值
		for(int j = 1; j <= i; j ++){
			c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % k;//上述公式
			ans[i][j] = ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1];//二维前缀和
			if(c[i][j] == 0){
				ans[i][j] ++;//可整除，增加答案
			}
		}
		ans[i][i + 1] += ans[i][i];//继承一下
	}
}
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> t >> k;
	init();
	while(t --){
		cin >> n >> m;
		cout << ans[n][min(n, m)] << "\n";//组合数第二项显然不能超过第一项
	}
	return 0;
}
```
前方公式证明：

组合数 $C_{i,j}$ 实际上是在 $i$ 个物品中选 $j$ 个的问题，对于物品 $i$，有两种处理方法：

- 不取，此时剩余 $i - 1$ 个物品，还能选 $j$ 个，方案数为 $C_{i - 1, j}$。
- 取，此时剩余 $i - 1$ 个物品，还能选 $j - 1$ 个，方案数为 $C_{i - 1, j - 1}$。

根据加法原理相加即可，得到原公式。

---

## 作者：CaiZi (赞：1)

首先，根据 $\binom{n}{m}$ 的定义和组合意义，有 $\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}$。

所以考虑先把 $\binom{0}{0}\sim \binom{2000}{2000}$ 全部预处理出来，使用数组存储。你会发现这个值非常大，但是题目只要求你判断 $\binom{i}{j}$ 是否为 $k$ 的倍数。因此我们一边计算一边将 $\binom{i}{j}$ 对 $k$ 取模，然后每次查询求出给定范围内 $\binom{i}{j}\bmod k=0$ 的个数即可。

然而这样时间复杂度是 $O(tn^2)$ 的，不可以通过本题。我们考虑将令 $f_{i,j}=[\binom{i}{j}\bmod k=0]$，即当 $\binom{i}{j}\bmod k=0$ 时 $f_{i,j}=1$，否则 $f_{i,j}=0$，注意这里要求 $i\ge j$。然后每次查询就变成查询一个子矩阵的和，使用二维前缀和即可，对于 $i<j$ 的点默认 $f_{i,j}=0$。

注意数组越界问题，我们可以考虑将这里的 $f_{i,j}$ 存储在代码中的 $f_{i+1,j+1}$，这样就不会越界了。

时间复杂度 $O(n^2+t)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,k,n,m,f[2002][2002];
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>t>>k;
	f[1][1]=1;
	for(int i=2;i<=2001;i++){
		for(int j=1;j<=i;j++){
			f[i][j]=(f[i-1][j]+f[i-1][j-1])%k;
		}
	}
	for(int i=1;i<=2001;i++){
		for(int j=1;j<=i;j++){
			if(f[i][j]==0){
				f[i][j]=1;
			}
			else{
				f[i][j]=0;
			}
		}
	}
	for(int i=1;i<=2001;i++){
		for(int j=1;j<=2001;j++){
			f[i][j]=f[i][j]+f[i-1][j]+f[i][j-1]-f[i-1][j-1];
		}
	}
	while(t--){
		cin>>n>>m;
		cout<<f[n+1][m+1]<<'\n';
	}
	return 0;
}
```

---

## 作者：Salamander (赞：1)

分解质因数最好懂。

先把k分解质因数，然后计算C（i，j）里有多少个k的某个质因数，如果个数比k里有的个数小就证明不可能是k的倍数。

计算n！里有多少个质因数p的方法：nump=n/p+n/p^2+n/p^3+n/p^4+...+n/p^k。这里的/是整除，当p^k>n时终止。

用f[i][j]表示C（i，1-j）里有多少个能整除k，g[i][j]表示C（1-i，1-j）里有多少个能整除k。（前缀和思想）

然后用离线的方式先处理好递推，再统一输出结果。

这题很阴险的卡常，O（n\*m）的算法不用读入优化会有几个点TLE。

其他详见代码。


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int read()
{
    int in=0,k=1;char c=getchar();
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') k=-1; 
    for(;c<='9'&&c>='0';c=getchar())
    in=in*10+c-'0';
    return k*in;
}
const int p[]={0,2,3,5,7,11,13,17,19};
int T,k,n,m,maxn=0,maxm=0,que[20001][2],prime[21],num[21];
int f[2001][2001],g[2001][2001];
void fenjie(int t)//把t分解质因数，prime记录质因数，num记录该质因数的个数。
{
    int i=1;
    while(t>1)
    {
        if(t%p[i]==0)
        {
            if(prime[prime[0]]==p[i]){num[prime[0]]++;t/=p[i];}
            else {prime[++prime[0]]=p[i],t/=p[i];num[prime[0]]=1;}
        }
        else i++;
    }
}
int calc(int t,int k)//计算t！里有多少个质因数k
{
    int ans=0,rec=k;
    while(t>=rec)
    {
        ans+=t/rec;
        rec*=k;
    }
    return ans;
}
bool pd(int i,int j)
{
    int a,b,c;
    for(int t=1;t<=prime[0];t++)
    {
        a=calc(i,prime[t]);//根据组合数计算公式，计算n！，m！和（n-m）！里有多少个质因数prime[i]
        b=calc(j,prime[t]);
        c=calc(i-j,prime[t]);
        if(a-b-c<num[t])return 0;//如果个数不够那么不能整除。
    }
    return 1;
}
int main()
{
    T=read();k=read();
    fenjie(k);
    for(int t=1;t<=T;t++)
    {
        n=read();m=read();
        que[t][0]=n;
        que[t][1]=m;
        if(n>maxn)maxn=n;
        if(m>maxm)maxm=m;
    }
    for(int i=1;i<=maxn;i++)
        for(int j=1;j<=i&&j<=maxm;j++)
        {
            f[i][j]=f[i][j-1]+pd(i,j);
            g[i][j]=g[i-1][min(i-1,j)]+f[i][j];
```
}//前缀和递推，注意j>i-1的情况
```cpp
    for(int t=1;t<=T;t++)
    {
        int a=que[t][0],b=que[t][1];
        printf("%d\n",g[a][min(a,b)]);//注意b>a的情况。
    }
    return 0;
}
```

---

## 作者：sherry_lover (赞：0)

# P2822 [NOIP2016 提高组] 组合数问题 题解

[题目传送门](https://www.luogu.com.cn/problem/P2822)

## 思路

发现 $k$ 是固定的，而 $n,m \le 2000$，可以用杨辉三角求出 $C_{i,j}$ 模 $k$ 的值，然后求出统计出 $C_{i,j}$ 有多少个为 $0$ 即为答案。

但是发现这样会 TLE，只能获得 $95$ 分。发现每次询问的答案为 $\sum\limits_{i=0}^n \sum\limits_{j=0}^{\min\{i,m\}} (C_{i,j} \bmod k = 0)$，可以利用前缀和维护后半部分，并不需要从 $0$ 一直遍历到 $\min\{i,m\}$。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,k,n,m,c[2005][2005],tot,sum[2005][2005];
inline void init()
{
	for(int i = 0;i <= 2000;i++)
    {
		c[0][i] = 0;
        c[i][0] = 1;
	}
	for(int i = 1;i <= 2000;i++)
	{
		for(int j = 1;j <= 2000;j++) c[i][j] = (c[i-1][j]+c[i-1][j-1])%k;
	}
  	for(int i = 0;i <= 2000;i++)
	{
		for(int j = 0;j <= 2000;j++) sum[i][j] = sum[i][j-1]+(!c[i][j]);
	}  
}
int main()
{
    cin >> t >> k;
	init();
	while(t--)
	{
		tot = 0;
        cin >> n >> m;
		for(int i = 0;i <= n;i++) tot += sum[i][min(i,m)];
		cout << tot << endl;
	}
    return 0;
}
```

---

## 作者：array2022 (赞：0)

### 题目分析
- 数据范围中提到 $0\le n,m \le 2\times 10^3$，因此可以想到可以使用组合数递推式 $\tbinom{n}{m}=\tbinom{n-1}{m-1}+\tbinom{n-1}{m}$ 进行预处理，时间复杂度 $O(nm)$。
- 对于每次询问，如果暴力查找的话时间复杂度为 $O(nm)$，只能拿到部分分数。由于每次询问的 $k$ 都一样，还是访问子矩阵，可以考虑二维前缀和。如果 $k\mid\tbinom{n}{m}$，设矩阵 $x$ 的 $x_{n,m}$ 为 $1$，否则为 $0$，每次询问输出 $x$ 前缀和即可。时间复杂度 $O(1)$。

### 通过代码
```cpp
#include<iostream>
using namespace std;
int t,k,n,m,c[2005][2005],x[2005][2005],a[2005][2005];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>t>>k;
	for (int i=0;i<=2000;i++){
		for (int j=0;j<=i;j++){
			if (j==0||j==i) c[i][j]=1;
			else c[i][j]=(c[i-1][j-1]%k+c[i-1][j]%k)%k; // 记得取模。
			if (c[i][j]==0) x[i][j]+=1; // 如果 c[i][j] 整除 k，将 x[i][j] 记为 1，查询时输出它的前缀和。
		}
	} // 预处理，注意边界情况。
	for (int i=0;i<=2000;i++){
		for (int j=0;j<=2000;j++){
			if (i>0&&j>0) a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+x[i][j];
			else if (i>0&&j==0) a[i][j]=a[i-1][j]+x[i][j];
			else if (i==0&&j>0) a[i][j]=a[i][j-1]+x[i][j];
			else a[i][j]=x[i][j];
		}
	} // 计算 x 数组的前缀和，同样记得注意边界情况。
	while (t--){
		cin>>n>>m;
		cout<<a[n][m]<<"\n";
	} // 每次访问，输出前缀和。
	return 0;
}
```

---


# 父子

## 题目背景

上演在各大学男生寝室的日常 $:$

$A :$ “我没带纸，快来厕所救我！”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

$............................................$

$A :$ “我没钱了，能借我点吗。”

$B :$ “叫爸爸。”

$A :$ “爸爸！”

一个月后、

$B :$ “能把钱还给我吗。”

$A :$ “叫爸爸。”

$B :$ “爸爸！”

## 题目描述

对于全国各大大学的男生寝室，总是有各种混乱的父子关系。

那么假设现在我们一个男生寝室有不同的 $n$ 个人，每个人都至多有一个“爸爸”，可以有多个“儿子”，且有且只有一个人没有“爸爸”(毕竟是室长，还是要给点面子，当然了，室长人人当嘛)。

那么现在问题来了，对于一个有 $n$ 个人的寝室，最多可能存在多少种父子关系，当然每个人之间都必须要有直接或间接的父子关系。

## 说明/提示

- 对于 $10\%$ 的数据，保证 $t=0$；

- 另有 $30\%$ 的数据，保证 $n≤5$；

- 对于 $100\%$ 的数据，$t≤10^4$，$1\le n\le10^9$。


## 样例 #1

### 输入

```
1
3
```

### 输出

```
9```

## 样例 #2

### 输入

```
1
323
```

### 输出

```
283888610```

# 题解

## 作者：mulberror (赞：32)

## 这道题还是很简单的，只要你了解一个公式就很好推导

首先我们需要理解题意，大致意思就是：给你一个$ n$个节点，求出有多少种不同的有根树。

---
既然我们已经知道了题意，那么就来分析一下。

有人的第一反应是求卡特兰数。
** 注：这个是错的，你应该去重新看一看卡特兰数的性质和应用**

---

好了我们来讲一下正解

我们需要用到$ Cayley$公式：
$Cayley$公式的定义是这样的，对于$n $个不同的节点，能够组成的**无根树**（原来是无向连通图或者是有标志节点的树）的种数是$n^{n-2}$种。（这里让大家好理解一点，就写成了无根树，其实应该是一样的概念）

### 证明的话我就不证明了，我做这道题的时候也就只是知道这个公式

----
那么我们的初步问题就解决了，接下来就是解决无根树和有根树之间的转换。

但是转换很难吗？把有根树转换成根节点有$n$种情况的无根树，也就是$ n^{n-2}\times n$，化简就是$n^{n-1}$。答案也就是这个玩意了。

因为这道题，$n$比较大，所以就用一下快速幂。

---
## 以下是AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const LL Mod=1e9+9;
LL power(LL n,LL m,LL p) {
    LL ret=1;
    while (m) {
        if (m&1) ret=(ret*n)%Mod;
        n=(n*n)%Mod;
        m>>=1;
    }
    return ret;
}
int main() {
    int cas; scanf("%d",&cas);
    while(cas--) {
        LL n;
        scanf("%lld",&n);
        printf("%lld\n",power(n,n-1,Mod));
    }
    return 0;
}

```

---

## 作者：DPair (赞：30)

## 楼下的巨佬都没有详细讲证明啊，在此我简单说一下详细证明

## 【思路】
这道题经过建模易得出，我们要求的就是有$n$个节点的有根树可能的形态数。

最后得出一个公式（有证明）
$$ans = n^{n - 1}$$
代码就出来了，不过重要的是证明部分
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
#define MOD 1000000009
LL ksm(LL n, LL m)
{//快速幂
    LL ret = 1;
    while(m) 
    {
        if(m & 1) ret = (ret * n) % MOD;
        n = (n * n) % MOD;
        m >>= 1;
    }
    return ret;
}
int main()
{
    int k;
    scanf("%d", &k);
    while(k --) 
    {
        LL n;
        scanf("%lld", &n);
        printf("%lld\n", ksm(n, n-1));
    }
}
```
## 【证明】（~~重点~~）
p.s 学习自https://www.cnblogs.com/dirge/p/5503289.html

首先引入$prufer$编码（这个单词的正确写法不是这样，但是很难打出来，以下以此代称）

一棵无根树的$prufer$编码的值运算如下：
```
首先定义无根树中度数为1的节点是叶子节点。
找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下2个节点。
```
（转载自https://www.cnblogs.com/dirge/p/5503289.html）

举个例子，对于下图的树
![](https://cdn.luogu.com.cn/upload/pic/58231.png)

它的$prufer$编码就是4, 3, 3

显然，一棵有$n$个结点的无根树，它的$prufer$编码是唯一的，且有$n-2$个可能相同的元素。

### 那么如何由一个$prufer$编码转化为二叉树？
那个博客上的巨佬是这么说的：
```
设点集V={1,2,3,...,n}，每次取出prufer序列中最前面的元素u，在V中找到编号最小的没有在prufer序列中出现的元素v，给u，v连边然后分别删除，最后在V中剩下两个节点，给它们连边。最终得到的就是无根树。
```
很显然，每一个$prufer$序列与一棵无根树一一对应。

因此，对于一棵已知有$n$个结点的无根树，一定有一个$n-2$长度的序列，那么，我们枚举所有长度为$n-2$的序列，发现其与所有可能形态的无根树一一对应。而这种序列，根据**乘法原理**，有
$$n ^{n - 2}$$
个可能的序列。

因此，对于一个已知的$n$，有$n^{n-2}$种不同的无根树。

而由于无根树没有根，而题目要求的是有根树，因此，对于一棵$n$个结点的无根树，我们有$n$种选根的可能。

因此，对于一个已知的$n$，有$n^{n-2} * n$即$n ^ {n-1}$种不同的有根树。

证毕。

---

## 作者：Aleph1022 (赞：17)

考虑有标号有根树的 EGF $W(z)$，显然其满足
$$
W(z) = z \mathrm e^{W(z)}
$$

即
$$
z = W(z) \mathrm e^{-W(z)}
$$

根据拉格朗日反演
$$
\left[\frac{z^n}{n!}\right] W(z) = \left[\frac{z^{n-1}}{(n-1)!}\right] \left(\frac z{z\mathrm e^{-z}}\right)^n = n^{n-1}
$$

故输出 $n^{n-1}$ 即可。

---

## 作者：zjyqwq (赞：10)

### P4981 父子 题解
Pascal题解。


------------
#### 题意理解
其实这题意思为：

有 $n$ 个人，叫你给他们安排“父子关系”。


------------
#### 解题思路
题解区 ives 大佬讲得很明白。详见[这里](https://chhokmah.blog.luogu.org/solution-p4981)。

使用 $Cayley$ 公式。

$Cayley$ 公式定义为对于 $n$ 个不同的节点，能够组成的无根树（原来是无向连通图或者是有标志节点的树）的种数是 $n^{n-2}$ 种。出自 ives 大佬。

但是这个题目却是让你求有根树，那么就还要乘上 $n$ , $n^{n-2}*n$ 不就等于 $n^{n-1}$  吗?

那么就直接输出 $n^{n-1}$ 就好了呀。


------------
#### 关于“power”
 $power$ 函数便是快速幂函数。详情见[P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226).
 

------------
#### 代码
```Pascal
var
n,i:longint;//定义部分，不多讲
x:int64;//不知道为啥不定int64总觉得不踏实
function power(a,b,n:int64):int64;//快速幂
var t,y:int64;
begin
  t:=1;
  y:=a;
while b<>0 do
    begin
      if (b and 1)=1 then t:=t*y mod n;
      y:=y*y mod n;
      b:=b shr 1;
    end;
  exit(t);
end;
begin
readln(n);
for i:=1 to n do//多组数据，不讲
 begin
  readln(x);//输入，不说了
  writeln(power(x,x-1,1000000009));//输出，1000000009是模数
 end;
end.

```
结束了，不点个赞吗？



---

## 作者：周道_Althen (赞：4)

$\ \ \ \ \ \ \ $本题属于的签到水题，主要可以通过找规律得到答案……多画几组，便可以得到我们需要求的答案是：
## $$n^{n-1}$$

$\ \ \ \ \ \ \ $下面我们解释一下为什么：

------------

$\ \ \ \ \ \ \ $题目要求很明显，询问的是生成树个数，但是因为有向，所以求的具体是一个又向完全图内，生成树形图的个数。

$\ \ \ \ \ \ \ $我们不妨先把有向这个条件忽略一下，先考虑一下一个无向完全图的生成树个数。

$\ \ \ \ \ \ \ $已知每一棵树对应一个$\rm \ Prüfer\ $编码，$\rm Prüfer\ $编码中每一个数出现的次数为$(n-1)$，且$\rm \ Prüfer\ $编码的长度为$(n-2)$，
完全图中每一个节点的度数为$(n-2)$，所以每一个$\rm \ Prüfer\ $编码的元素都有$\ n\ $种可能，所以答案为$n^{n-2}$。

$\ \ \ \ \ \ \ $此即为$\rm \ Cayley\ $公式，这里简单证明一下，有兴趣的可以在网上找相关证明。

### $\ \ \ \ \ \ \ $所以我们现在知道，对于一个$\ n\ $个点无向完全图，生成树个数为$n^{n-2}$。

$\ \ \ \ \ \ \ $那么加上有向的条件呢？

$\ \ \ \ \ \ \ $注意这里的无向完全图生成树，是没有根的。当一棵树有根的时候，我们就可以把它自然地转换成一棵树形图，这是一一对应的。对于任何一棵生成树，我们都有$\ n\ $个节点。所以就有$\ n\ $种树根。那么我们的答案就应该为：

## $$n^{n-2}\times n$$

$\ \ \ \ \ \ \ $既:

## $$n^{n-1}$$

$\ \ \ \ \ \ \ $代码就是一个快速幂的事，就不放代码了。


---

## 作者：JustinRochester (赞：2)

[传送门](https://www.luogu.com.cn/problem/P4981)

用矩阵树定理推一波公式

---

**【分析】**
--

由于题目中任意两点均可连边。故问题等价为：给定 $n$ 个点的标号完全无向图 $K_n$ ，问生成有根树的数量。

简单一想，对于任一生成的无根树，任选一点作为根节点，都会产生不同的有根树。故有根树数量为无根树数量的 $n$ 倍。

矩阵树定理可以求图中所有无根生成树边权积的和，令所有边权均为 $1$ ，则等价于统计无根树的数量。

列出基尔霍夫矩阵对应的行列式如下：

$\left|
\begin{matrix}
n-1&-1&-1&\cdots&-1
\\-1&n-1&-1&\cdots &-1
\\-1&-1&n-1&\cdots &-1
\\\vdots&\vdots&\vdots&\ddots&\vdots
\\-1&-1&-1&\cdots&n-1
\end{matrix}
\right|_n$

取任一主子式：

$\left|
\begin{matrix}
n-1&-1&-1&\cdots&-1
\\-1&n-1&-1&\cdots &-1
\\-1&-1&n-1&\cdots &-1
\\\vdots&\vdots&\vdots&\ddots&\vdots
\\-1&-1&-1&\cdots&n-1
\end{matrix}
\right|_{n-1}$

将各行加至第一行

$\left|
\begin{matrix}
1&1&1&\cdots &1
\\-1&n-1&-1&\cdots &-1
\\-1&-1&n-1&\cdots &-1
\\\vdots&\vdots&\vdots&\ddots&\vdots
\\-1&-1&-1&\cdots&n-1
\end{matrix}
\right|_{n-1}$

再将第一行加至各行

$=\left|
\begin{matrix}
1&1&1&\cdots &1
\\&n
\\&&n
\\&&&\ddots
\\&&&&n
\end{matrix}
\right|_{n-1}$

$=n^{n-2}$

因此，$K_n$ 生成的无根树数量为 $n^{n-2}$

答案因此为 $n\cdot n^{n-2}=n^{n-1}$

---

**【代码】**
---

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+9;
inline ll fpow(ll a,ll x) { ll ans=1; for(;x;x>>=1,a=a*a%MOD) if(x&1) ans=ans*a%MOD; return ans; }
//快速幂
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    ll n,t; cin>>t;
    while(t--&&cin>>n) cout<<fpow(n,n-1)<<"\n";
    cout.flush();
    return 0;
}
```

---

## 作者：Yyxxxxx (赞：1)

- 题意

求节点数为$n$的有根树数量

- Prufer数列   

每一个对应着有$n$个结点的无根树的$Prufer$序列的长度为$n-2$

![](https://cdn.luogu.com.cn/upload/image_hosting/40jr9us9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

**对于一个有编号的无根树，每次选取一个编号最小的叶子节点（度数为1的节点），删除，并把他所连接的节点编号加入序列。直到剩下两个结点一条边**  
比如对于上面这一棵无根树，序列可以这样求出：


------------
- 叶子节点有$3,4,5$；编号最小的为$3$；它连接的是$2$，加入序列；此时序列为$2$
- 叶子节点有$4,5$；编号最小的为$4$；它连接的是$2$，加入序列；此时序列为$2,2$
- 叶子节点有$2,5$；编号最小的为$2$；它连接的是$1$，加入序列；此时序列为$2,2,1$
- 剩下两个节点$1,5$和连接他们的一条边，结束。
- 所以这棵无根树的$Prufer$序列就是$2,2,1$


------------
性质：对于一棵无根树，节点的度数是其在$Prufer$序列出现的次数$+1$
- Cayley公式

$\because$每一个对应着有$n$个结点的无根树的$Prufer$序列的长度为$n-2$且每个结点所对应的编号为$1$~$n$  
$\therefore$无根树的个数为$n\cdot n\cdot n\cdot...\cdot n(n-2$个$)$，即$n^{n-2}$个   
$\because$对于每一棵无根树，可以有$n$个节点为根   
$\therefore$有根树的个数为$n^{n-2}\cdot n=n^{n-1}$个

一个[快速幂](https://www.luogu.com.cn/problem/P1226)搞定
- 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+9;
long long ksm(long long n,long long p)//快速幂
{
    long long ans=1;
    while(p>0)
	{
		if(p%2==1)ans=ans*n%mod;
		n=n*n%mod;
		p=p>>1;
	}
	return ans;
}
int main()
{
	long long n,t;
	scanf("%lld",&t);//多组数据
	while(t--)
	{
	    scanf("%lld",&n);
	    printf("%lld\n",ksm(n,n-1));//公式
	}
	return 0;
}
```
















---

## 作者：lndjy (赞：1)

这题题解很少，来发个题解。

首先，了解一下Cayley公式：对于n个不同的节点，能够组成的有标志节点的树（无根树）的个数为$n^{n-2}$个。

这题是有根树，对于每种无根树，有n种有根树，总数就是$n^{n-1}$个。

数据范围较大，要使用快速幂。

AC code
```cpp
#include<iostream>
#define int long long
using namespace std;
int qpow(int x,int y,int m)
{
	int base=x,ans=1;
	while(y)
	{
		if(y&1)
		ans*=base;
		base*=base;
		ans%=m;
		base%=m;
		y>>=1;
	}
	return ans%m;
}
signed main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		cout<<qpow(n,n-1,1e9+9)<<endl;
	}
	return 0;
}
```


---

## 作者：COUPDETAT (赞：1)

题意如上所述

求生成树的个数
## 这里需要知道Prüfer编码与Cayley公式

这个东西我想了好久

这里贴一篇我认为很容易理解的链接prufer详解

选取一棵无根树 删除最小的叶子节点 直到只剩两个节点为止 这样就得到了prufer编码

任何一个Prüfer编码都唯一地对应了一棵无根树，有多少个n-2位的Prüfer编码就有多少个带标号的无根树（请看链接具体证明）

请大家牢记无根树的个数公式是(n-2)! / [ (D1-1)!(D2-1)!..(Dn-1)! ]

本题中生成无根树的生成方式有(n-1)!种

综上可得代码
```cpp
#include<iostream>
using namespace std;
long long ksm(long long a,long long b,long long p) {long long  ans=1;while (b) {if (b%2==1) ans=ans*a%p; a=a*a%p; b/=2;}return ans;}
int main()
{
    int k;cin>>k;
    for(int i=1;i<=k;i++)
    {
    long long b;
	cin>>b;
	long long p=b-1,k=1e9+9;
	cout<<ksm(b,p,k)<<endl;
    }
}
```


---

## 作者：cjZYZtcl (赞：0)

## 蒟蒻又来发题解啦~~
### 题目大意
给出节点个数，求由这些节点能组成的有根树的数量。

### 解法

由于我不知道直接求有根树个数的方法（蒟蒻太菜awa），所以要通过求无根树个数来转化成求有根树。

#### $n$ 个点无根树个数：$n^{n-2}$

由于一棵 $n$ 个点的无根树可以由任意一个点作为根节点，所以由一棵无根树可以求出 $n$ 棵有根树。

#### 所以，$n$ 个点有根树个数 $=n$ 个点无根树个数 $*$ $n$

推出公式，代码就很简单啦~~~

## AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int mod = 1e9+9;
inline int read(){
	int x = 0, m = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-') m = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * m;
}
inline void write(int x){
	if(x < 0){
		putchar('-');
		write(-x);
		return;
	}
	if(x >= 10) write(x / 10);
	putchar(x % 10 + '0');
}
int qpow(int x, int y){
	int a = 1;
	while(y){
		if(y % 2){
			a = (a * x) % mod;
		}
		x = (x * x) % mod;
		y = y / 2;
	}
	return a;
}
signed main(){
	int t = read();
	for(int i = 1; i <= t; i++){
		int n = read();
		write(qpow(n, n - 1));
		putchar('\n');
	}
}
```


---

## 作者：Terraria (赞：0)

## 题目大意：用 $n-1$ 条边将 $n$ 个已知的顶点连接起来的连通图的个数是多少。

这道题我们只需要一个柿子——$Cayley$ 定理。

那么这个定理究竟是什么呢？详见[这篇文章](https://www.cnblogs.com/lfri/p/10433011.html)，个人认为这篇文章讲的比较好。

同时，里面最为关键的就一句话——
## 用 $n-1$ 条边将 $n$ 个已知的顶点连接起来的连通图的个数是 $n^{n-1}$。

也就是说，这道题公式都已经出来了——$n^{n-1}$ $mod$ $(10^9+9)$。

由于这道题的n给的比较大，因此死算是肯定不行的，这时候我们需要快速幂。

代码 ~~（直接套上快速幂代码就可以了）~~：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long m=1000000009;//模数
long long n,p,t;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		long long ans=1;//以防万一，开long long为好
		cin>>n;
		p=n-1;//求n^{n-1}即n^p
		while(p>=1){
			if(p%2==1) ans=ans*n%m;
			p/=2;
			n=n*n%m;
		}
		cout<<ans%m<<endl;
	}
	return 0;
}
```
谢谢观看！

---

## 作者：suxxsfe (赞：0)

# prufer 编码 

对于一个无根树，他的 prufer 编码是这样确定的：  

- 每次找到**编号最小的**一个叶子节点，也就是度数为$1$的节点，把**和它相连的点**，加入 prufer 编码序列的末尾，然后把这个点从树中删掉  
- 如果当前树只有两个节点了，就停止  

那么，通过给定的无根树求 prufer 编码就很简单了  
比如下面这个无根树，它的 prufer 编码就是$\texttt{125214}$  

![](https://pic.downk.cc/item/5e8a9d06504f4bcb04b1824d.png)  

这个 prufer 编码有一些很显然的性质  
首先长度肯定是$n-2$，但每个元素**可能相同**，然后对于每个无根树，它的 prufer 编码肯定也唯一    
如果编码的每个元素都相同，那么它可以是一个编号最大的点连向其它所有点（特殊的菊花图），如果都不同，可以是一个链  
当然，这里说“可以”是因为有可能还存在其它的构造方式  

那么，prufer 编码对应的树是否唯一？  
也就是说，每一个编码是不是只能求出唯一的树？  
是可以的，先给出求的方式：  
设这棵树点的集合为$V$，初始状态下$V=\{1,2,\cdots,n\}$  

- 每次找到编码最前面的一个点，在$V$中找到**不在编码序列中出现**的编号**最小**的点，连边，然后分别把他们在$V$中和编码中删掉  
- 显然，当编码被全部删掉后，$V$中还有两个元素，再把他们两个连边，结束  

然后验证一下刚才那个图，发现是正确的  

可以感性理解一下，编码序列的第一个数，就是我们第一次删除叶子节点以后添加的它的相邻节点，而这个被删掉的节点肯定不在编码中，它也是序号最小的，所以还原树的时候就要把它和它相邻的那个被添加到编码中的点连边  
然后每次都这样做就得出了原树  
又因为在找编码的时候最后剩了两个节点，那两个节点肯定是连在一起的，所以这就是为什么要把$V$中剩下的两个点连边  

所以，上面通过 prufer 编码求树的操作，也是唯一的  
那么可以得出一下更深入的性质：  

- prufer 编码和无根树**一一对应**  
- 对于有$n$个节点的**无根树**，有$n^{n-2}$种构造方式  
因为编码和树一一对应，所以长度为$n-2$，每一位有$n$种取值的编码的种类数是$n^{n-2}$，这个东西也叫做 Cayley 公式  
- 对于有$n$个节点的**有根树**，有$n^{n-1}$种构造方式，很显然，就是让每个节点轮流当根，然后运用上面那个式子  
- 度数为$k$的点，在 prufer 编码中出现的次数是$k-1$  
因为在$k-1$个点被删掉的时候，它被加入编码，此时度数为$1$，直接被删掉不会加入编码中  
- 对于给定$n$个点的度数分别是$k_1,k_2,\cdots,k_n$的有根树，有$\dfrac{(n-2)!}{\prod (k_i-1)!}$种构造方式  
问题即为求每个元素出现$k_i$次的排列个数，分子的$(n-2)!$是说，没有这个限制条件的全排列个数，分母上是去重，就是说如果相同的元素交换位置应该算一种方案，所以要除以它的阶乘  
- 上面那个性质再扩展一下，假设有$cnt$个点对度数有要求，其它的没要求，设$sum=\sum_{i=1}^{cnt}k_i$，则方式有：  
$\tbinom{n-2}{sum}\frac{sum!}{\prod_{i=1}^{cnt}(k_i-1)!}\times (n-cnt)^{n-2-sum}$  
解释一下什么意思，那个组合数就是从$n-2$个数里面算出$sum$个，然后对这$sum$个用上一条性质的公式，然后还有$n-2-sum$个位置可以任意排列剩下的$n-cnt$个点，所以得出上面式子  


应该没有了，如果有大佬知道其它性质欢迎在评论区给出  

-------------  

[P4981 父子](https://www.luogu.com.cn/problem/P4981)  
然后看这个题，显然就是要求$n$个点的有根树个数，直接输出$n^{n-1}$就行  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
inline LL power(LL a,LL b,LL mod){
	LL ret=1;
	while(b){
		if(b&1) ret=ret*a%mod;
		a=a*a%mod;b>>=1;
	}
	return ret;
}
int main(){int T=read();while(T--){
	int n=read();
	std::printf("%lld\n",power(n,n-1,1e9+9));
}
	return 0;
}
```

---

## 作者：zzr8178541919 (赞：0)

### 一、Cayley定理

Cayley公式。

凯莱定理，是所有群 G 同构于在 G 上的对称群的子群。

定理另一种表述：过n个有标志顶点的树的数目等于n^(n-2)，也即完全图K_n有n^(n-2)棵生成树。

然后我们要把无根树转成有根的树，就是用n^(n-2)乘上n就是n的（n-1）次方。用快速幂就能通过这道题。

于是此题得到完美解决
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const long long Mod=1e9+9;
long long power(long long n,long long m,long long p) 
{
    long long res=1;
    while(m) 
	{
        if(m & 1) 
		res=(res*n)%Mod;
        n=(n*n)%Mod;
        m>>=1;
    }
    return res;
}
int main() 
{
    int T; 
	scanf("%d",&T);
    while(T--) 
	{
        long long n;
        scanf("%lld",&n);
        printf("%lld\n",power(n,n-1,Mod));
    }
    return 0;
}
```


---

## 作者：liuyifan (赞：0)

## 来发一波Cayley公式的证明

解法:对于每一个n,输出n^(n-1)即可

但是重点不在此,重点是证明的方法~~OI不需要证明~~

## 前置知识:
首先介绍一种树的编码方式，就是我首先知道这个树上的节点时标好了号的，其实号应该是随意标的，因为完全图是对称的。然后我对这棵树可以有一个编码的方式，就是取树上标号最小的叶子节点，写下与它相邻的节点的标号，然后把这个删掉，以此类推，直到这棵树最后只剩下了两个节点为止，此时此刻我们得到了一个长度为n-2的数列。第一部分也就证明完毕了即一棵完全图的生成树唯一对应一个长度为n-2的数列。 
## 开始证明了
第二部分我们证明一个长度为n-2的数列是唯一对应一棵完全图的生成树，首先对于这个数列，其中的元素都是1-n之间的，但是这其中的元素又不是完全包含1-n之间的所有元素，所以我们去寻找不包含在这个数列之中的最小的数字是多少，找到这个数字就说明这个数字肯定是原树的叶子，并且是最小的叶子，（因为假如这个节点不是叶子的话，那么他就得有两条边，最后只剩了一条边，所以这个节点的某一个连接点被去掉过，所以数列中就必须有这个节点，但是数列中没有，并且它是这棵树最小的叶子节点）所以第一个数就是和这个最小的叶子相连的节点，然后我们按照相同的方式去应用于后面n-3个节点，寻找第二个叶子和哪一个节点相连以此类推，我们最后得到了唯一一颗完整的树。所以证毕了,~~AC了~~

## SO CODE:(基于[P1226](https://www.luogu.org/problemnew/show/P1226#sub))
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll m=1e9+9,n,p,mm,nn,pp,ans=1,t;
int main()
{
    scanf("%lld",&t);
    while(t--)//多组数据读入
    {
		scanf("%lld",&n);
		p=n-1;//质数
		ans=1;//初始值
	    mm=m;nn=n;pp=p;
	    //if(pp==0)return puts("0"),0;
	    for(;p;p/=2,n=n*n%m)if(p&1)ans=ans*n%m;//快速幂
	    printf("%lld\n",ans);//输出
	}
    return 0;
}
```

部分内容转自[CSDN](https://blog.csdn.net/wanwandebaba/article/details/78946057)

---


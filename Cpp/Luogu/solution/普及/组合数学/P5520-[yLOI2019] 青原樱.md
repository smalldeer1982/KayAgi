# [yLOI2019] 青原樱

## 题目背景

> 星川之下皆萤火尘埃，  
> 我独行在人潮你天真而待。  
> 相遇若是借丹青着色，  
> 青原上 绯樱如海。

——银临《青原樱》(Cover 人衣大人)

## 题目描述

扶苏是一个非常喜欢边听古风鸽边写数学题的人，因此这道题其实是个五三原题。

扶苏希望重现青原上樱花盛开的景色，于是他准备了很多**互不相同**樱花树幼苗，准备种成一行。

这一行中，一共有 $n$ 个位置可以种下樱花，而扶苏准备了 $m$ 支幼苗。由于樱花盛放时对左右空间需求非常大，所以樱花不能紧挨着种植，也就是任意两支幼苗之间必须至少存在一个不种花的空位置。

按照这种方式种花并不难，但是令扶苏感到好奇的是一共有多少合法的方案让他把这 $m$ 支幼苗都种下去。一个方案是合法的当且仅当他满足上一段中叙述的要求。如果我们将花按照 $1,2,3,\dots,m$ 编号，两种方案不同当且仅当被选择种花的位置不同或从左向右数花的编号序列不同。

为了避免输出过大，答案对一个参数 $p$ 取模。

## 说明/提示

#### 样例输入输出 1 解释
一共有 $2$ 个樱花幼苗， $3$ 个种花的位置，如果给幼苗编号为 $1,~2$，位置编号为 $1,~2,~3$，那么两种方案分别如下：

| 位置 | $1$ | $2$ | $3$ |
| :---: | :---: | :---: | :---: |
| 方案 1 | 幼苗 $1$ | 空 | 幼苗 $2$ |
| 方案 2 | 幼苗 $2$ | 空 | 幼苗 $1$ |

---

#### 数据规模与约定

**本题采用多测试点捆绑测试，共有 6 个子任务**。

| 子任务编号 | $n \leq$ | $m \leq$ | $type=$ | 特殊性质 | 子任务分值 |
| :----------: | :--------: | :----------: | :-------: | :--------: | :-----------: |
| 1 | $1$ | $1$ | $0$ | 特殊性质 1 | $5$ |
| 2 | $20$ | $20$ | $1$ | 特殊性质 1 | $15$ |
| 3 | $400$ | $200$ | $2$ | 无 | $20$ |
| 4 | $2000$ | $2000$ | $3$ | 无 | $20$ |
| 5 | $2000000$ | $1000000$ | $4$| 特殊性质 2 | $20$ | 
| 6 | $2000000$ | $1000000$ | $5$| 无 | $20$ | 

特殊性质 1：保证对应测试点的**实际**方案数(在取模前)不超过 $10^6$

特殊性质 2：保证 $p$ 是一个质数。

对于 $100\%$ 的数据，保证：
- $1 \leq n \leq 2 \times 10^6$。
- $1 \leq m \leq 10^6 $。
- $1 \leq p \leq 10^9$。
- $1 \leq m \leq \lceil\frac{n}{2} \rceil$。

---

#### 提示

- 请使用合适的数据类型来进行运算，避免溢出。
- 参数 $type$ 可以帮助你快速的判断子任务编号。


## 样例 #1

### 输入

```
1 3 2 19260718```

### 输出

```
2```

# 题解

## 作者：yyh_1102 (赞：256)

# 青原樱/wa,好有诗意的题目/
- 首先，感谢银临为我们提供的NOIP模拟赛/话说NOIP改名了/

- 本篇文章为萌新oier而做，dalao及神犇绕路

-   废话不多说，这道题考察的是排列组合中的插空法，我先分析一下题目：一共有n个位置，m棵树，两棵树之间要有空位
    
    那么，我们把这m棵树以及他们所占的位置拿出来，那道路上是不是还剩下n-m个坑，而这n-m个坑有n-m+1个空位，我们要把带坑的树插进这n-m+1个空位中，那么有多少种插法？
        
   	ans=$A^m_{n-m+1}$
    
    因为树是有序的，所以是A而不是C
    
    什么？你不明白A,C怎么算？
   
	- $A^m_n$=$n(n-1)···(n-m+1)$=$\frac{n!}{(n-m)!}$
    
    - $C^m_n$=$\frac{A^m_n}{m!}$=$\frac{n!}{m!(n-m)!}$=$C^{n-m}_n$
    
-  A是排列数，C是组合数，那么什么叫排列，什么叫组合呢？
    
    所谓排列，就是指从给定个数的元素中取出指定个数的元素进行排序，是有序的。
    
    组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序，是无序的，这就是为什么$C^m_n$=$\frac{A^m_n}{m!}$的原因，当有序的排列除去顺序后就是组合。
    
    这里有个特殊规定，$0!=1$,怎么理解呢，通过上面的式子我们可以知道$A^m_n$表示在n个元素中有序的选取m个元素，当m=n的时候，$A^n_n$=$n!$，那么$0!$=$A^0_0$，从0个元素中有序地选出0个元素的方案数，应该只有一个，所以$0!$=1.
    
- 举个栗子吧,老师从十个人中选五个排成一列，一共有多少种排法？
    
    首先我们看，十个人中选五个排成一列的组合数是$C^5_{10}$，那么排成一列的同学们有没有顺序呢？
    
    答案是肯定的，你可以这么想，第一个人你给他1wRMB，第二个人你给他1w美刀，第三个人你给他1w欧，第四个人你给他1w津巴布韦币，第五个人你给他一巴掌，这待遇能一样吗，不同的排序结果能一样吗，既然不一样，那就是有顺序的，所以还要对组合数乘上一个5的全排列，答案是
    
    $C^5_{10}$×$A^5_5$=$A^5_{10}$=$10×9×8×7×6$=$30240$种
    
    这是一道简单的排列题，下面我们再来看一道组合题：老师从十个人中选取4个人去乡村支教，一共有多少种选法？
    
    我们看这道题有没有顺序，比如$a_1$到$a_{10}$十个人，老师选$a_1,a_2,a_3,a_4$去和选$a_4,a_3,a_2,a_1$去有区别吗，都是这四个人去，没有区别，所以这道题是无序的。无序的就是组合数，答案是
    
    $C^4_{10}$=$\frac{10!}{4!×(10-4)!}$=$210$种
    
    经过这两道例题，想必大家对排列组合有了一定的了解，下面开始讲一些比较难的题目了
    
    例一：三个女生和五个男生站成一排
    
    (1)如果女生必须全排在一起，有多少种排法？
    
    (2)如果女生必须全分开，有多少种排法？
    
    (3)如果两端都不排女生，有多少种排法？
    
    (4)如果两端不都排女生，有多少种排法？
    
    首先看第一题，所有女生全部都在一起，我们可以把女生全部绑在一起（某些绅士不要想歪），把三个女生看成一个女生，这样就成了一个女生，五个男生，一共有多少种排法。
    
    这是个排列问题，所以是有序的，一个女生五个男生的排法数是$A^6_6$种，又因为三个女生的顺序也是需要考虑的，所以答案还要乘上一个$A^3_3$，最后答案是
    
    $A^6_6 × A^3_3 = 6! × 3! = 4320$种
    
    这是第一题，下面看第二题，如果女生必须分开，有多少种排法，这就是不相邻问题，跟本题青原樱是一样的，使用插空法。我们看一共有五个男生，那连头带尾的算一共有六个空位，这里我简单表示一下，用@表示男生，用__表示空位
    
    __ @ __  @  __  @ __  @ __  @ __
    
    是不是六个空位，然后把三个女生插入这六个空位（再次警告绅士们不要想歪）中，由于三个女生的排列是有序的，所以女生排列的方案数是$A^3_6$，但这道题不是种树，男生的顺序也是要考虑的，所以最后答案是
    
    $A^3_6 × A^5_5 = 14400 $种
    
    第二题是不相邻问题，我们一般对不相邻问题进行插空法解决问题，看第三题，两端都不排女生，意思是女生只能在中间6个位置中进行排列，由于是有序的，方案数是$A^3_6$，然后对剩余的五个男生进行排序，由于八个位置女生已经占了三个，所以还剩五个位置，男生排序又是有序的，所以答案是
    
     $A^3_6 × A^5_5 = 14400 $种
     
     你们有没有发现答案跟上一题一模一样，这样不好分辨，我们还有另外一种方法，我们可以这样想，两端不能排女生，所以两端只能排男生，这个的方案数是$A^2_5$，然后再对剩下六个位置六个人进行排序$A^6_6$，最后把两个相乘就是答案
     
     $A^2_5 × A^6_6 = 14400$种
     
     答案是一样的，所以一道题可能有不同的表示方法，关键在于你怎么想，看第四题，要求女生不都在两端，这就和第三题不一样了，要求女生不都在两端，说明可以有一个女生在前端或后端，我们可以这样考虑，如果首位排的是男生，那么后面就不再有限制，然后对后面七个位置排序就行，首位男生的方案数是$A^1_5 ×A^7_7$种，再想，如果首位是女生，那么最后一位肯定是男生，然后对剩余六个人六个位置进行排序即可，方案数是$A^1_3 \times A^1_5 \times A^6_6$种，最后把两个方案相加就是最终答案
     
     $A^1_5 \times A^7_7 + A^1_3 \times A^1_5 \times A^6_6 = 36000$种
     
     还有第二种方法，就是从所有排列方案种把两端都是女生的方案全部扣下来，就是最终方案
     
     $A^8_8 - A^2_3 \times A^6_6 =36000$种
     
     经过了例题一的洗礼，你是否对排列组合已经有了初步的了解，那么一起来看例题二吧
     
     例二：排一张有5个歌唱节目和4个舞蹈节目的演出节目单。     
     
     （1）任何两个舞蹈节目不相邻的排法有多少种？
     
     （2）歌唱节目与舞蹈节目间隔排列的方法有多少种？
     
     看第一题，任何两个舞蹈节目不相邻，是不是跟例一的第二题一样，使用插空法，五个歌唱节目有六个空，又因为节目的排列是有顺序的，所以答案是
     
     $A^4_6 \times A^5_5 =43200$种
     
     对舞蹈排序，对歌唱排序，最后相乘就是结果，难度不大，看第二题，歌唱节目和舞蹈节目间隔排列的方法数，这道题可以这样想，先把舞蹈节目排好有$A^4_4$种方案，再观察一下，四个舞蹈节目正好有五个空供五个歌唱节目插入，所以答案再乘上$A^5_5$就行了，最后答案是
     
     $A^4_4 \times A^5_5 = 2880$种
     
     例题二的第二题需要一点技巧，但也不算太难，我们再做几题巩固一下吧
     
     例三：某一天的课程表要排入政治、语文、数学、物理、体育、美术共六节课，如果第一节不排体育，最后一节不排数学，那么共有多少种不同的排课程表的方法？
     
     这道题不同于之前的题，复杂度变大了一点，我们看一下这道题：一共六节课，要求第一节课不排体育，最后一节课不排数学，我们直接想是不是很难想到方案，那么这里要用到一个概念：正难则反。
     
     正难则反的意思是如果顺着题目意思很难想出答案，那么就跟他反着来，他不是问第一节不是体育，最后一节不是数学的方案数吗，我们就求第一节是体育和最后一节是数学的方案总数，最后用总方案数减去这个方案数就是最后答案。
     
     我们可以看一下，第一节是体育的方案是$A^5_5$种，就是把体育排好，剩下五门课的全排列，数学同理，也是$A^5_5$种，两个相加是$2A^5_5$种，你以为这就是答案？
     
     少年啊你太天真了，你难道没有发现这里面有重复的方案吗，两个$A^5_5$都包括了体育第一节，数学最后一节，其他四门放中间的方案数，等于这一块算了两遍，所以我们要减去一遍这种方案，数学体育固定好了，中间四门课的方案数是$A^4_4$种，所以体育第一节，数学最后一节的总方案数是$2A^5_5-A^4_4$，再用总数减去方案数，最后答案是
     
     $A^8_8-(2A^5_5-A^4_4) = 504$种
     
     最后再看两题吧
     
     例四：现有3辆公交车、3位司机和3位售票员，每辆车上需配1位司机和1位售票员．问车辆、司机、售票员搭配方案一共有多少种？
     
     这道题我们可以分步骤进行排列，把三个司机分到三辆车上的方案数有$A^3_3$种，把三个售票员分到三辆车上的方案数有$A^3_3$种，所以最后答案是
     
     $A^3_3 \times A^3_3 = 36$种
     
     最后看一下例五吧
     
     例五：下是表是高考第一批录取的一份志愿表．如果有4所重点院校，每所院校有3个专业是你较为满意的选择．若表格填满且规定学校没有重复，同一学校的专业也没有重复的话，你将有多少种不同的填表方法？
     ![](https://cdn.luogu.com.cn/upload/pic/75348.png)
     
     我们可以看出来这道题的难度大大提升，所以我们要冷静分析，首先，志愿只能填三个学校，所以学校的方案数是$A^3_4$种，再分析专业，每个学校有三个专业是我满意的，但只能填两个专业，所以是$A^2_3$种，由于有三个学校 所以专业的排列数有$A^2_3 \times A^2_3 \times A^2_3$种，最后分步相乘，得出最终答案
     
     $A^3_4 \times A^2_3 \times A^2_3 \times A^2_3 = 5184$种
     
     例五这种比较复杂的题要分步考虑，冷静分析，把复杂的大问题拆成简单的子问题，然后再对子问题进行相乘或相加就是最后的答案
     
- # 总结

- 排列组合的经典例题我挑了几题来讲，可以说足够你们排列组合入门了，而且一般考试题都能做对，至于还有没有我没有讲到的题型？肯定是有的，但这要靠你自己去探索，我能做的就只有这么多了。

最后奉告一句，凡事都要仔细，冷静，写题也是一样，不管是数学还是oi，能拿高分靠的都是仔细看题，冷静分析，所有的难题都是靠一个一个简单的问题堆积起来的，只要你能够把这些简单的问题拆开，那所谓的难题对你来说就没有难度了。

至于这道题的代码我就不放了，上面的大佬都有，我主要是为了给萌新们普及排列组合的知识，可能有问题，希望大佬们找到问题后评论出来，让我及时纠正。

看在这么有诗意的题目名称及背景上，我写了一首打油诗来帮助你们记忆排列组合的方法，同时也作为这篇题解的结尾

           ‘A’‘C’基础全排列，相邻捆绑反插空

            正难则反思维逆，复杂问题细分析
  
                 常言道排列组合问题难
 
                   我偏把难题拆分开
 
                   欲问过程如何写
 
                   加减乘除全‘A’‘C’

---

## 作者：一扶苏一 (赞：91)

# A [yLOI2019] 青原樱

## Background

星川之下皆萤火尘埃

我独行在人潮你天真而待

相遇若是借丹青着色

青原上 绯樱如海

——银临《青原樱》(Cover 人衣大人)

## Description

给定 $n$ 个位置，要求放下 $m$ 个互不相同的东西，东西两两之间不能相邻，求方案数对 $p$ 取模的结果。

## Limitations

![qwq](https://cdn.luogu.com.cn/upload/pic/72252.png)

特殊性质1：保证对应测试点的**实际**方案数(在取模前)不超过 $10^6$

特殊性质2：保证 $p$ 是一个质数。

对于 $100\%$ 的数据，保证 $1 \leq p \leq 10^9$，$1 \leq m \leq \lceil \frac{n}{2} \rceil$

## Solution

子任务 $1$：

显然 $n = m = 1$，所以共有 $1$ 种方案，但是直接输出 $1$ 是没有分的，因为这个点的 $p = 1$，应该输出 $1 \bmod 1 = 0$。

期望得分 $5~pts$

子任务 $2$：

考虑方案数不超过 $10^6$，因此只要在爆搜的时候保证搜索树上每个节点的情况都是合法的且他的后代一定至少存在一种合法的方案即可。考虑搜索树的最后一层节点数是 $O(ans)$ 的，树共有 $O(n)$ 层，因此总复杂度 $O(n \times ans)$，期望得分 $15~pts$

子任务 $3$：

数数题，考虑DP。

先不考虑幼苗的编号，设 $f_{i, j}$ 为放了 $i$ 个幼苗，第 $i$ 个幼苗在位置 $j$ 的方案数，转移显然：

$$f_{i, j} = \sum_{k = 0}^{j - 2}f_{i - 1,k}$$

初始化为 $f_{0, 0} = 1$。注意由于这里幼苗是互不相同的，因此算出答案以后要乘上 $m!$。

共有 $O(nm)$ 个状态，每次转移是 $O(n)$ 的，总复杂度 $O(n^2m)$，期望得分 $20~pts$

子任务 $4$：

考虑上面的转移方程显然可以对每个 $i$ 维护一个前缀和来让转移变成 $O(1)$，于是总复杂度 $O(nm)$，期望得分 $20~pts$

子任务 $5$：

DP看起来已经到了尽头，无论如何状态数都不可能低于 $O(nm)$，于是考虑组合数学。

考虑将所有的方案分为两类：对于所有的第 $n$ 个位置没有树苗的方案，归为第一类方案，有树苗的方案归为第二类方案。显然这两类方案囊括了所有可能的情况且互不相同。

先考虑第一种情况，第 $n$ 个位置没有树苗。那么对于所有的 $m$ 个树苗，显然每个树苗后面都紧跟着一个空位，如果将每个树苗和他后面的紧跟着的空位看作一个物品，那么问题就变成了共有 $(n - m)$ 个位置，在这 $(n - m)$ 个位置种选择 $m$ 个位置，放上 $m$ 个物品，摆放方式没有限制，求方案数。根据排列数的定义，共有 $C_{n - m}^m$ 种方式。注意到这样求出的方案是 $m$ 个物品相同的方案，由于要求 $m$ 个物品互不相同的方案，答案应该乘上 $m!$。于是这种情况的方案数是 $m! \times C_{n - m}^m$。

再考虑第二种情况，第 $n$ 个位置有树苗，那么对于前面的 $(m - 1)$ 个树苗，每个树苗后面都紧跟着一个空位，同样的我们将树苗和空位捆绑在一起看，那么不考虑最后一个树苗，问题变为有 $[(n - 1) - (m - 1) = n - m]$ 个位置，在这些位置种选择 $(m - 1)$ 个，共有 $C_{n - m}^{m - 1}$ 种方式。注意到最后一个树苗的选择一共有 $m$ 种情况，所以在 $m$ 个树苗相同时的方案数应是 $m \times C_{n - m}^{m - 1}$。对于前面 $(m - 1)$ 个物品，有 $(m - 1)!$ 种排列方式，因此这种情况的总方案数为 $m!~\times~C_{n - m}^{m - 1}$

由于保证了模数 $p$ 是一个质数，因此 $O(n)$ 处理逆元后 $O(n)$ 计算即可。期望得分 $20~pts$

子任务 $6$：

如果你足够机智（划掉。如果你不像扶苏一样傻），你就可以发现第一种方案的方案数 $m! \times C_{n - m}^m~=~A_{n - m}^m$，第二种方案的方案数 $m! \times C_{n - m}^{m - 1}~=~m \times A_{n - m}^{m - 1}$。所以根本不需要处理逆元，直接做即可。

当然，由于代数恒等式 $A_x^y + y \times A_x^{y - 1} = A_{x + 1}^y$，可以直接求 $A_{n - m + 1}^{m}$，时间复杂度 $O(n)$，期望得分 $20~pts$。

## Code

```c
#include <stdio.h>

int main() {
  int I, love, yin, lin;
  scanf("%d%d%d%d", &I, &love, &yin, &lin);
  love = love - yin + 1; 
  int ans = 1;
  for (int i = love - yin + 1; i <= love; ++i) {
    ans = 1ll * ans * i % lin;
  }
  printf("%d\n", ans);
  return 0;
}
```

---

## 作者：ez_lcw (赞：68)

由于两支幼苗之间至少要有一个空位，所以$m$支幼苗之间必须有$m-1$个空位。

那我们不妨把这$m-1$个空位空出来，那么剩下的$n-(m-1)=n-m+1$个位置可以随便乱放树苗，因为它们之间已经有空位了。

那么就是无序排列，即方案数为$A_{n-m+1}^{m}$。

这个东西可以直接暴力算出来。

代码：

```cpp
#include<bits/stdc++.h>

#define ll long long

using namespace std;

ll ans=1,type,n,m,p;

int main()
{
	scanf("%lld%lld%lld%lld",&type,&n,&m,&p);
	for(int i=n-m+1;i>=n-2*m+2;i--)
		ans=(ans*i)%p;//计算A
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：1saunoya (赞：19)

$\text{如果你会组合数 请跳过这个题解}$

$\text{这题我们可以先写个DFS , 然后打表找规律}$

$\text{如果水平达标 其实DFS根本不难写。。}$

$\text{定义 void DFS(int pos , int k , bool flg)}$

$pos$指的是当前位置 $k$指的是选了$k$个 $flg$指的是上一个地方选没选。。


然后打一个$n = 10$ 的表就差不多了。。

$\text{我找了规律}$

$\text{发现 m = 1 时 ans = n}$

$\text{发现 m = 2 时 ans = (n - 1) * (n - 2)}$

$\text{发现 m = 3 时 ans = (n - 2) * (n - 3) * (n - 4)}$


$\text{公式是}$ $\prod_{i = 1}^{m} (n-m+2-i)$

不贴代码了 本来就是个数学题

---

## 作者：⚡LZSY01_XZY⚡ (赞：13)

## 组合数解题
**题意**：$n$个数，选出$m$个互不相邻的数的方案数。

考虑$m$个花盆之间的花盆：有$n-m$个花盆，$n-m$个花盆之间有$n-m+1$个地方可以放那$m$个花盆。  

方案数便是
$$C_{n-m+1}^{m}$$

根据公式得：
$$\frac{(n-m+1)!}{(n-m+1-m)!~*~m!}$$

又因为$m$个花盆先后顺序没有要求。所以，还要乘上$m$的排列：
$$\frac{(n-m+1)!}{(n-2*m+1)!~*~m!}*m!=\frac{(n-m+1)!}{(n-2*m+1)!}$$

约分得：
$$\prod_{i=n-2*m+2}^{n-m+1} i$$

$Code:$
```cpp
#include <cstdio>
using namespace std;
long long n,m,mod,res=1;

int main()
{
	scanf("%*d%lld%lld%lld",&n,&m,&mod);
	for (int i=n-2*m+2;i<=n-m+1;i++) res=res*i%mod;
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：yu__xuan (赞：7)

### 题目
[P5520 [yLOI2019] 青原樱](https://www.luogu.org/problem/P5520)

### 思路

题目大意：我们有$m$朵编好号的樱花，以及$n$个可以种樱花的位置。可以看成一排，没两朵花之间要有一个空位。

* $m$朵花需要$m-1$个空位，既可以保证绝对满足题目要求
* 所以题目可以转化成$m$朵编好号的花，$n-m+1$个位置种植的方案数。即$A^m_{n-m+1}$

有人问当两朵花之间有多个空位呢？上面这个做法其实是先预先空出了$m-1$个位置,然后在选择完成之后的方案中每两朵花之间插一个空位，这样肯定满足题意。

* 只有$m < n-m+1$两朵花之间才有多个空位
* 那么m朵花必然占不满n-m+1个空位，所以选出来的方案中必然有两朵花之间已经有空位了，再插入一个空位就是有多个空位的情况。

**$A^m_{n-m+1}$就是答案**

### $Code$
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>

inline void read(long long &T) {
	long long x=0;bool f=0;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	T=f?-x:x;
}

typedef long long ll;
ll type,n,m,p,ans=1;

int main() {
	read(type),read(n);
	read(m),read(p);
	for(int i=n-m+1;i>=n-2*m+2;--i) {
		ans=(ans*i)%p;
	}
	std::cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：wancong (赞：5)

## 组合数学（雾）

说起来你可能不信，这是一道数学题（废话）

它可以建模为：n个盒子放m个球，每个盒子最多放一个球，且相邻的两个盒子不能同时有球。

我们的第一思路肯定是这样：考虑前n个盒子放m个球的方法数$f(n, m)$。根据题意可得，$f(n, m)=Σdp(i,m-1)$，其中$2m-3≤i≤n-2$，自己想想为什么是这个范围，不会就画图。

但是，咳咳，题目范围是多少？一百万、两百万！完蛋了吧。

并没有，都说了这是个数学题，这只是说明我们用递推的方法行不通。

但我们这个模型依然是正确的，只是思考的方法可以不同。考虑两个球中间相隔的空盒子数，有m个球，中间就有m-1个空隙，每个空隙有至少1个空盒子。

但这样依然不够美，因为我们并未考虑两端的空盒子，导致这些空盒子的个数限制并不统一。

题目并未规定两端必须有空盒子，但我们可以人为制造。现在有n个盒子，我们可以给两端分别加一个空盒子，并且规定这两个盒子必须为空。这样就有n+2个盒子，但这m个球必须放在中间的n个盒子内。m个球的中间、加上两端，就有m+1个空隙，每个空隙至少有1个空盒子。比如下面$f(6,3)$的情况：

0 | 1 0 1 0 0 1 | 0

那么，这些空盒子的总个数是多少呢？当然是n+2-m咯。

所以，问题转化为：求不定方程$Σ_{i=1}^{m+1}x_i=n-m+2\ \ \ (x_i≥1)$的整数解个数。

这个问题在组合数学中是个模板了，公式为$C_{n-m+1}^m$。不会的可以百度“不定方程整数解个数”。

这就完了吗？注意了啊，我们还有题目中的一个条件没用到呢，当排列顺序不同的时候，算作不同的方案。所以，最终答案应该乘上m的全排列：

$C_{n-m+1}^m*m!=(n-m+1)!/(n-2m+1)!$。

两个阶乘的除法非常简单，手推一下就能解决。

于是，这个复杂度立刻变成线性的：

```cpp
#include <stdio.h>
#include <stdlib.h>

using namespace std;

int main() {
    int t;
    long long i, n, m, p, ans = 1;
    // 注意用long long，两个10^9相乘必爆int
    scanf("%d %lld %lld %lld", &t, &n, &m, &p);
    for (i = n + 1 - m; i > n + 1 - 2 * m; i--) {
        ans *= i;
        ans %= p;
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：洛白の纸 (赞：3)

从n个数里面找出m个不相邻的元素，m的排列顺序不同，不算一种；
可以用插入法。。。。。。。
插入法注意事项：你找出来的数，中间，两端，都可以插；
你是要找出m个，那么有n-m个空白。
将空白找出来，


![](https://cdn.luogu.com.cn/upload/image_hosting/qsdt9cb0.png)




找出来的有m-n个，那么可插入的位置（n-m-1）+2=（n-m+1）；
插入这箭头中的每一个都满足条件。
所以就是从m-n+1里面选m个。再乘以m的排列数。
(n-m+1)!*m!/m!*(n-m+1-m)
就是从n-2m+2*到n-m+1；

---

## 作者：Plus_Ultra (赞：3)

### 解法：

我在比赛时推了三个小时的公式，公式是推出来了，但是...还是爆炸了！于是，在一番思考后写出了这篇题解来加深记忆.

我们来总结一下思路.

排列组合

- 我们可以先把 m 株幼苗放在一起.

- 在每两株幼苗中插一个空格，这样就确保了方案的合法性，用掉了 m - 1 个空格.

- 然后，我们还剩下 n - m - (m - 1) = n - 2m + 1 个空格可以放.

- 在m株幼苗中的 m - 1 个空隙中，我们可以随意填空格，然后在m株幼苗的两边，我们也可以随意填空格(中间的 m - 1 个空位和两边还没有放空格的位置 )，这样方案一定合法.

- 于是！！！我们可以将问题转化为将 n - 2m + 1 个小球放到 m + 1 个盒子里，盒子可以为空的方案数！！！可以直接用公式计算.

- 什么公式呢，那就是：x个小球放到y个盒子中，盒子可以为空的方案数，即为$\dbinom{x+y-1}{y-1}$.

- 所以将 n-2m+1 个小球放到 m+1 个盒子里，盒子可以为空的方案数即为$\dbinom{n-m+1}{m}$.


我们来证明x个小球放到y个盒子中，盒子可以为空的方案数为什么是$\dbinom{x+y-1}{y-1}$.

- 挡板法： 我们有 y - 1 个挡板（可将小球分为y份，也就是y个盒子），可以随意插.

- 插完之后，小球+挡板就有 x + y - 1 个.

- 而挡板可以任意放，则方案数就是从 x+y-1 个物品中选出y - 1 个组成一个集合（不考虑顺序），产生的不同集合数量.

- 也就是$\dbinom{x+y-1}{y-1}$啦！！！

而 m 株幼苗的排列顺序可以不同，故要乘上 m 株幼苗的全排列：m！.

于是公式就可以逐步化简：

![334223424.PNG](https://i.loli.net/2019/08/25/Ng8hqxn6I5VkGF2.png)

（此图片来自AK爷@[interestingLSY](https://www.luogu.org/space/show?uid=25630)，%%%）.

举个栗子：当N=18，M=5时.

如图：

1. 将5株幼苗放在一起，再在其中插入4个空格.

![234234.PNG](https://i.loli.net/2019/08/25/kclvNRAbw53VWCq.png)

2. 剩下的9个空格可以插到6个空隙中

![二位热无若.PNG](https://i.loli.net/2019/08/25/OVuZG1dpBt5QIFW.png)

再套公式，则方案数就是 $\dbinom{14}{5}$ * **5!** .

上代码（其实我相信各位大佬也不需要代码）：


```
#include<iostream>

#define LL long long

using namespace std;

LL type,n,m,p,ans=1;

int main()
{
	cin>>type>>n>>m>>p;
	
	for(int i=n-2*m+2;i<=n-m+1;i++)  ans=(ans*i)%p;
	
	cout<<ans<<endl;
	
	return 0;
}
```

## [Plus Ultra!!!](https://www.luogu.org/blog/OnePunchManGO/solution-p5520)

最后祝大家 CSP2019 RP++!!!(滑稽）


---

## 作者：Retucl (赞：2)

自从某杯赛咕咕咕了后就没碰过组合数学

由于树苗互不相邻，我们可以认为至少有m-1个空位

于是剩下n-m+1个位置放m个数，根据乘法原理，

每种组合共n!种排列，最终答案为A （n−m+1，
m）

龟速乘即可

code：
```cpp
#include<iostream>
long long t,n,m,p,ans=1;
int main() {
    std::cin>>t>>n>>m>>p;
	for(int i=0;i<m;i++)
		(ans*=((n-m+1-i)))%=p;
	std::cout<<ans%p;
}
```




---

## 作者：huangxuhan (赞：1)

 因为中间要有间隔，所以如果$n>2m$那就说明只能放一个空一个且刚好放完，故只有$1%p$种方法  

------------

 中间必须要有间隔，所以相当于是把剩下$n-m$个空位置分成$m,m-1,m+1$组分别插空，$m$表示只有开头有空格（没放花）或者相反，$m-1$表示开头结尾都没有空格，$m+1$表示两头都有空格  

------------

 根据隔板法，我们假设花全部按顺序排列（最后乘$m!$即可），那么方案数为

------------
$2*\tbinom{n-m-1}{m-1}+\tbinom{n-m-1}{m-2}+\tbinom{n-m-1}{m}$

------------
所以总方案数为  
  
  $(2*\tbinom{n-m-1}{m-1}+\tbinom{n-m-1}{m-2}+\tbinom{n-m-1}{m})*m!$  

这时候我们就会发现计算组合数时取模是个问题，于是我们需要继续化简  
- 根据组合数的性质   

$\tbinom{n-m-1}{m-1}+\tbinom{n-m-1}{m}=\tbinom{n-m}{m}$    

$\tbinom{n-m-1}{m-1}+\tbinom{n-m-1}{m-2}=\tbinom{n-m}{m-1}$    

$\tbinom{n-m}{m-1}+\tbinom{n-m}{m}=\tbinom{n-m+1}{m}$    

于是答案变为$\tbinom{n-m+1}{m}*m!$    

进行化简，变为$\dfrac{(n-m+1)!}{(n-2m+1)} $，即

------------
$\prod^{n-m+1}_{i=n-2m+1}i$


------------
问题得到解决，保险起见，开$long long$
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
using namespace std;
inline int read()
{
	int x=0,f=1;char ch;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch>'9'||ch<'0');
	do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	return f*x;
}
ll p,n,m,type,ans=1;
int main()
{
	type=read();
	n=read();
	m=read();
	p=read();
	if (m==1) 
	{
		cout<<n%p<<endl;
		return 0;
	}
	if (m*2>n)
	{
		for (ll i=2;i<=m;i++)
		{
			ans=ans*(i%p)%p;
		}
		cout<<ans<<endl;
		return 0;
	}
	ans=n-m+1;
	for (ll i=(long long)n-2*m+2;i<=n-m;i++)
	{
		ans=ans*(i%p)%p;
	}
	cout<<ans<<endl;
	return 0;
} 
```


---

## 作者：suxxsfe (赞：1)

# P5520 【[yLOI2019] 青原樱】题解  
整理博客的时候改了下分类标签，重新审一下  
[题目传送门](https://www.luogu.org/problem/P5520)  
翻了翻题解区，发现基本没和我写的一样的（~~主要是都比我的写的简单~~  
看题目：  
第一眼，数学题；第二眼：组合数  
接着想起来那道[放苹果](https://www.luogu.org/problem/P2386)  
n个位置，m棵树，就有n-m个空位，记space=n-m  
转化问题为：  
1. space个空位插入m-1个位置（即左右两边都不留空）  
2. sapce个空位插入m个位置（即左边或右边留空，这种情况的答案要乘2）  
3. space个空位插入m+1个位置（即左右两边都留空位） 

现在将space个空位看作space个苹果，m或m-1或m+1个位置看成盘子，因为每个位置（盘子）都要有至少一个空位（苹果），所以，这和[放苹果](https://www.luogu.org/problem/P2386)就没什么区别了  
运用一点隔板法解决：  
以情况1为例： space个苹果间有space-1个间隔，因为要放进m-1个盘子，所以只需在space-1个间隔中选m-2个插入隔板，不重复不考虑顺序，所以：$\tbinom {space-1} {m-2}$  
那么另外两种也就简单了，分别为：$\tbinom {space-1} {m-1}$,$\tbinom{space-1} {m}$  
考虑如何算组合数，发现p不一定为质数，所以对组合数计算的每个数分解，再约分  
我用he数组表示一个数的最小质因子，为0说明不为合数  
用sum数组记录每个质数的指数，是分子就加一，分母就减一  
之后再快速幂乘起来  
因为那m棵树是不同的，所以有m！种排列方式，也就是ans$\times {m!}$  
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define R register
#define EN printf("\n")
#define LL long long
inline LL read(){
	LL x=0,y=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') y=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=getchar();}
	return x*y;
}
int he[2000006],prime[2000006],cnt;//he[i]为i的最小质因子 
LL sum[2000006];
inline void getprime(LL n){
	for(R int i=2;i<=n;i++){
		if(!he[i]) prime[++cnt]=i;
		for(R int j=1;j<=cnt&&i*prime[j]<=n;j++){
			he[prime[j]*i]=prime[j];
			if(!(i%prime[j])) break;
		}
	}
}
inline LL pow(LL a,LL b,LL p){
	LL ret=1;
	while(b){
		if(b&1) ret=(ret*a)%p;
		a=(a*a)%p;
		b>>=1;
	}
	return ret;
}
inline void fenjie(int x,int v){
	while(he[x]){
		sum[he[x]]+=v;
		x/=he[x];
	}
	if(x>1) sum[x]+=v;
}
inline LL C(LL n,LL k,LL p){
	memset(sum,0,sizeof sum);
	if(k>n) return 0;
	if(k==n) return 1%p;
	if(k==0) return 1%p;
	if(k==1) return n%p;
	LL ret=1;
	for(R int i=n-k+1;i<=n;i++) fenjie(i,1);
	for(R int i=1;i<=k;i++) fenjie(i,-1);
	for(R int i=2;i<=n;i++){
		if(sum[i]) ret=(ret*pow(i,sum[i],p))%p;
	}
	return ret;
}
int main(){
	LL ty=read(),n=read(),m=read(),p=read();
	LL space=n-m;
	getprime(n);
	LL jc=1;
	for(R int i=2;i<=m;i++) jc=(jc*i)%p;
	LL ans=C(space-1,m-2,p);
	ans=(ans+C(space-1,m-1,p)*2)%p;
	ans=(ans+C(space-1,m,p))%p;
	ans=(ans*jc)%p;
	printf("%lld",ans);
	return 0;
}  
```

---

## 作者：shzr (赞：1)

在讨论区看到这道题就进来做了，感觉这道题并没有题解讲的那么复杂？（雾

一个显然的事实是，如果没有（不能相邻）的限制，答案就是 $A_{n}^m$ 。

如果首先去掉 $m-1$ 个格子，按照没有限制的方法做，最后再在每一对元素间插入一个之前留好的空格，就可以将一个不知道合不合法的方案变成成一个一定合法的方案。这样做其实是在两个问题间建立了一一映射的关系，显然不重不漏，所以最终答案就是 $A_{n-m+1}^m$ 。
```cpp
# include <cstdio>

using namespace std;

int n,m,p,ans=1;

int main()
{
	scanf("%d%d%d%d",&n,&n,&m,&p);
	for (int i=n-2*m+2;i<=n-m+1;++i)
		ans=1LL*ans*i%p;
	printf("%d",ans);
	return 0;
}
```


---

## 作者：littleKtian (赞：1)

首先假设所有幼苗是一样的，则$ans=$放置幼苗的方案数$*m!$

把$n-m$个空位看做物品，此时这$m$盆幼苗相当于隔板，一共有$n-m+1$个位置插入隔板

可得 放置幼苗的方案数$=C^{m}_{n-m+1}$

由组合数公式可知$C^{m}_{n-m+1}=\frac{(n-m+1)!}{m!(n-2m+1)!}$

得   
$ans=C^{m}_{n-m+1}*m!$          
$ans=\frac{(n-m+1)!}{m!(n-2m+1)!}*m!$                  
$ans=\frac{(n-m+1)!}{(n-2m+1)!}$                
$ans=(n-2m+2)*(n-2m+3)...(n-m+1)$                    

精简的代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n,m,p,ans;
int type;
int main()
{
	scanf("%d%lld%lld%lld",&type,&n,&m,&p);
	ans=1;
	for(long long i=n-m*2+2;i<=n-m+1;i++)ans=ans*i%p;
	printf("%lld",ans);
}
```


---

## 作者：zfn07 (赞：0)

这道题是一个组合数学题。

因为任意两支幼苗之间必须至少存在一个不种花的空位置。
所以可以把m-1个位置先留出来,然后剩下的位置就可以随意种上樱花了。所以答案为$A_{n-m+1}^{m}$
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int type,n,m,p,i;
	long long ans=1;
	cin>>type>>n>>m>>p;
	n-=m-1;//留出m-1个位置
	for(i=n-m+1;i<=n;i++){//算出结果
		ans*=i;
		if(ans>=p)//超过了p就%p
			ans%=p;
	}
	cout<<ans;
	return 0;
} 
```


---

## 作者：LinkyChristian (赞：0)

# 看到没有人写题解后立马写了一篇

~~我将是第一个题解吗？~~

## 本题解适合蒟蒻观看
（大佬可能会觉得太繁琐了但请勿喷qwq）

言归正传，让我们来看这题

一道组合数学（我这么简单的题还做不好，太蔡了）：

将情况分为两类

- 最后一个位置不放树

- 最后一个位置放了树

我们先讨论第一种情况：

**因为最后一个位置不放树，所以第m颗树后面也一定有空位，因此每棵树后面都有空位**

既然每棵树后面都有空位，那一共能放树的位置就只有$n-m$个（n个位置减去每颗树后面都有的一共m个空位），在这些位置里放上$m$颗树，那一共就是C $\binom{m}{n-m}$.（由于是决定位置，所以是组合），而第i个位置一共有（n-i+1）中选择（例如第一个位置可以种1到m中的任意一棵，而第二个位置就只有m-1棵树可选），因此总的方案数为

$m!*$C $\binom{m}{n-m}$

C $\binom{m}{n-m}$ $=$ A $\binom{m}{n-m}$ $/$ $m!$

$m!*$C $\binom{m}{n-m}$=A$\binom{m}{n-m}$

考虑第二种情况：

**最后一棵树后面没有空位，即前m-1棵树后面有空位，他们分享n-1个位置** 

同理，$m-1$棵树苗的空位占了$m-1$ 个位置，因此最后剩余的位置为$(n-1)-(m-1)$即$n-m$个位置，在这些位置中取树苗的位置一共有C $\binom{m-1}{n-m}$种悬法，同上，最终的方案数要乘上$m!$，$m!=m* (m-1)!$，再次同上，C $\binom{m-1}{n-m}$* $(m-1)!$=A $\binom{m-1}{n-m}$，因此总方案数为m $* $ A $\binom{m-1}{n-m}$


将两种方案加起来一共A $\binom{m}{n-m}$ $+$ m * A $\binom{m-1}{n-m}$，就可以直接算了，算法复杂度O（2n）

简化1：存下A$\binom{m}{n-m}$，m * A $\binom{m-1}{n-m}$ =A $\binom{m}{n-m}$ $/$ $(n-m+1)  *  m$，算法复杂度O(N)

简化二（感谢@--扶苏--） ：A $\binom{m}{n-m}$ $+$ m * A $\binom{m-1}{n-m}$ $=$ A $\binom{m}{n-m+1}$，具体原理就不解释了，时间复杂度O(N)

完结撒花！

---

## 作者：Aprilllll (赞：0)

这道题的关键在于处理“任意两支幼苗之间必须至少存在一个不种花的空位置”这个条件

如何处理能将题目转化为基本的排列组合？

我们发现，由题，每一棵幼苗右侧一定有一个空位（最右边一棵除外），同时，如果每个幼苗右侧有一个空位，也能确保每个幼苗左侧留空（最左侧一棵除外）。

反证法：如果有一个幼苗的左侧是幼苗，那么左侧的一棵幼苗的右侧并没有空格，和“每一棵幼苗右侧一定有一个空位（最右边一棵除外）”的假设矛盾。

由此可见，**每个幼苗（最右侧一棵除外）右侧为空位**是一个排列符合题设条件的充要条件。

所以，我们可以将**每个幼苗（最右侧一棵除外）及其右侧的空位**捆绑处理。这样来，捆绑处理的空位多占了**m-1**个位置，空位总数变为**n-m+1**

于是问题就转化为：**m个幼苗，插入n-m+1个空位，考虑顺序，无其他限制条件**。


AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m,t,p;

int main(){
	scanf("%lld%lld%lld%lld",&t,&n,&m,&p);
	ll x=1;
	ll k=n-m+1;
	for(int i=1;i<=m;i++){
		x*=k;
        k--;
        x=x%p;
    }
	printf("%d\n",x%p);
	return 0;
}
```

蒟蒻首次发题解，若有错误请指正！

---

## 作者：Honor誉 (赞：0)

这题是小学奥数啊。

题意：求$m$个不同物品两两不相邻的方案数。

直接排列组合。

我们可以减掉他们之间最少需要空出来的位数——$m-1$个空位

![](https://cdn.luogu.com.cn/upload/pic/74818.png)

像这样，我们只用留$m-1$个空位放在每两个物品中间使他们两两不相邻即可。

所以剩下的位置有$n-m+1$个空位。

这个问题就转换成了一下这个问题：

给定$n-m+1$个位子，放入m个不同物品的方案数。

直接排列一下就好了。

$ans$=$A_{n-m+1}^{m}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int type,n,m,mod,cnt;
long long ans=1;
int main()
{
	scanf("%d%d%d%d",&type,&n,&m,&mod);
	for(int i=n-m+1;i>=n-2*m+2;i--)
	{
		ans=(ans*i)%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


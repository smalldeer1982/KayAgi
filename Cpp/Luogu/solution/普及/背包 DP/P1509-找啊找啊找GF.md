# 找啊找啊找GF

## 题目背景

“找啊找啊找 GF，找到一个好 GF，吃顿饭啊拉拉手，你是我的好 GF。再见。”

“诶，别再见啊…”

七夕… 七夕… 七夕这个日子，对于 sqybi 这种单身的菜鸟来说是多么的痛苦… 虽然他听着这首叫做“找啊找啊找 GF”的歌，他还是很痛苦。为了避免这种痛苦，sqybi 决定要给自己找点事情干。他去找到了七夕模拟赛的负责人 zmc MM，让她给自己一个出题的任务。经过几天的死缠烂打，zmc MM 终于同意了。

但是，拿到这个任务的 sqybi 发现，原来出题比单身更让人感到无聊 -\_- … 所以，他决定了，要在出题的同时去办另一件能够使自己不无聊的事情——给自己找 GF。

## 题目描述

sqybi 现在看中了 $n$ 个 MM，我们不妨把她们编号 $1$ 到 $n$。请 MM 吃饭是要花钱的，我们假设请 $i$ 号 MM 吃饭要花 $rmb[i]$ 块大洋。而希望骗 MM 当自己 GF 是要费人品的，我们假设请第 $i$ 号 MM 吃饭试图让她当自己 GF 的行为（不妨称作泡该 MM）要耗费 $rp[i]$ 的人品。而对于每一个 MM 来说，sqybi 都有一个对应的搞定她的时间，对于第 $i$ 个 MM 来说叫做 $time[i]$。sqybi 保证自己有足够的魅力用 $time[i]$ 的时间搞定第 $i$ 个 MM ^\_^。

sqybi 希望搞到尽量多的 MM 当自己的 GF，这点是毋庸置疑的。但他不希望为此花费太多的时间（毕竟七夕赛的题目还没出），所以他希望在保证搞到 MM 数量最多的情况下花费的总时间最少。

sqybi 现在有 $m$ 块大洋,他也通过一段时间的努力攒到了 $r$ 的人品（这次为模拟赛出题也攒 rp 哦\~\~）。他凭借这些大洋和人品可以泡到一些 MM。他想知道，自己泡到最多的 MM 花费的最少时间是多少。

注意 sqybi 在一个时刻只能去泡一个 MM ——如果同时泡两个或以上的 MM 的话，她们会打起来的…

## 说明/提示

sqybi 说：如果题目里说的都是真的就好了…

sqybi 还说，如果他没有能力泡到任何一个 MM，那么他就不消耗时间了（也就是消耗的时间为 $0$），他要用这些时间出七夕比赛的题来攒 rp…

**【数据规模】**

对于 $20 \%$ 的数据，$1 \le n \le 10$；  
对于 $100 \%$ 的数据，$1 \le rmb \le 100$，$1 \le rp \le 100$，$1 \le time \le 1000$。  
对于 $100 \%$ 的数据，$1 \le m, r, n \le 100$。

## 样例 #1

### 输入

```
4
1 2 5
2 1 6
2 2 2
2 2 3
5 5
```

### 输出

```
13```

# 题解

## 作者：Anguei (赞：174)

通过读题，不难发现，这道题是一道 0-1 背包问题，只是有点特殊罢了。既然是 0-1 背包问题，那么基本的套路都是一样的：**开数组，写循环**。

接下来让我们分析一下此题特殊之处，顺便梳理一下思路。
1. 普通的 0-1 背包问题只有一个成本，而这道题有两个成本（泡妹子所需的 rmb 和 rp）。所以，需要**多写一层循环，同时 dp 数组也要多一维**。
2. 普通的 0-1 背包问题，只要求出最大价值就好了。而这道题不仅要泡到尽量多的妹子，而且还要保证花费的时间尽量小。所以需要**两个 dp 数组**，分别保存泡到的妹子数量、所花费的时间。且，每个妹子的价值都为 1。

----------

综上，可以得出代码：

```cpp
//【P1509】找啊找啊找 GF - 洛谷 - 100 
#include <iostream>
#include <algorithm>

int n, m, r;
const int kMaxN = 100, kMaxM = 100, kMaxR = 100; // 常量开头带 k，符合命名规范 
int rmb[kMaxN + 5], rp[kMaxN + 5], time[kMaxN + 5];
int dpNum[kMaxM + 5][kMaxR + 5], dpTime[kMaxM + 5][kMaxR + 5]; // 两个 dp 

int main() {
	std::cin >> n;
	for (int i = 1; i <= n; ++i) std::cin >> rmb[i] >> rp[i] >> time[i];
	std::cin >> m >> r;

	for (int i = 1; i <= n; ++i)
		for (int j = m; j >= rmb[i]; --j) // 小心，不要把 j 和 m 写混，否则死循环 
			for (int k = r; k >= rp[i]; --k) {
				// 如果能泡到更多妹子 
				if (dpNum[j][k] < dpNum[j - rmb[i]][k - rp[i]] + 1) {
					dpNum[j][k] = dpNum[j - rmb[i]][k - rp[i]] + 1; // 数量++ 
					dpTime[j][k] = dpTime[j - rmb[i]][k - rp[i]] + time[i]; // 花费的时间加进去 
				}
				else if (dpNum[j][k] == dpNum[j - rmb[i]][k - rp[i]] + 1)
					// 如果能泡到同样多的妹子，选择时间最少的方案 
					dpTime[j][k] = std::min(dpTime[j][k], dpTime[j - rmb[i]][k - rp[i]] + time[i]);
			}
	
	// 不需要特判能否泡到妹子，因为如果泡不到，这里的值一定为 0 
	std::cout << dpTime[m][r] << std::endl;
}
```

----------

如果对于动态规划的背包问题仍然不是很懂（包括但不限于不知道数组该开多大、循环条件和边界是什么），建议刷一下洛谷试炼场当中的这几道简单题，不仅可以有效帮助**理解**，还可以在忘了的时候辅助**复习**：
+ [P1048 采药](https://www.luogu.org/problemnew/show/P1048)
+ [P1049 装箱问题](https://www.luogu.org/problemnew/show/P1049)
+ [P1060 开心的金明](https://www.luogu.org/problemnew/show/P1060)

注：采药那道题里面有一篇质量非常高的题解（20+ 赞同），详细分析了 0-1 背包问题的基本做法，值得一看。

----------

最后，祝愿广大 OIer 早日找到 GF~~（虽然这不可能~~

---

## 作者：a2920353120 (赞：44)

**看见别的大佬都用两个二维数组做这个题本蒟蒻突然想到一个神奇的思路**

> ### “只用一个数组就能解决问题”

就是把一个物品（~~mm....~~）的权重看成是20000-t[i];


  #### 对于本题，所有的“物品”的权值相对来说是一样的，即都可以看做一个相同的常数，
  
  那么，我们想要在得到物品最多的前提下花费**最少**的时间
  
  
  #### 不妨看成时间会在物品基础价值上减少物品的价值
  
  #### 而我们将问题转化成为一个一般的二维01背包问题


#### 而我们在花费更多时间和获得更多物品的选择上倾向于获得物品

#### 所以物品原本的价值应该远大于时间带来的影响

#### 则将物品初始价值设为一个足够大的常数


我们考虑数据范围，发现当所有人的时间累加在一起的时候会到达10000左右

所以设为20000一定不会对最后的结果造成影响

则设$w[i] = 20000 - t[i]$


这样dp完了以后得到的就是

> $f$[$m$][$r$] = $ans\times20000$ $-$ $\displaystyle \sum_{i \to ans}{time_i}$ 

答案ans即为

> ($f[m][r] \div 20000 + 1 $) $\times 20000 $ $- f[m][r]$


~~节省了一点点空间~~


以下是完整代码

用时46ms 内存3.04MB


```

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;

const int N = 1000;
int f[N][N], w[N], c[N], t[N];
int n, m, r;

//f数组为二维背包数组，w数组记录物品对于rp的消费,c数组记录物品对于rmb的消费

int main(){
	int i, j, k, lin;
	
	cin >> n;
	for(i = 1; i <= n; i++) 
		cin >> c[i] >> w[i] >> t[i];
	cin >> m >> r;
	
	for(i = 1; i <= n; i++)
	  for(j = m; j >= c[i]; j--)
	    for(k = r; k >= w[i]; k--) {
	    	if(f[j - c[i]][k - w[i]] + 20000 - t[i] > f[j][k]) {
	    		f[j][k] = f[j - c[i]][k - w[i]] + 20000 - t[i];
            //20000 - t[i]即为更新含义后的权值
	    	}
	    }
	
	cout << ((f[m][r] / 20000 + 1) * 20000) - f[m][r];
	
	return 0;
}

```

---

## 作者：不许雷同 (赞：28)

 ##### 很用心的一篇题解， 希望管理员大大给过！！！！##### 

这道题感觉我自己还是想了一下下的。相信大家一眼看出来这道题是0-1背包， 不过有些变形， 有两个量的限制：rp & rmb;

所以， 我们的dp也得有二维：f[ m ][ r ], 变量名就是题目中的变量名。
然后呢， 由于题目统计的是在能够泡到最多MM的最短时间（~~也就是说他得快！！~~）我们因此开两个dp数组： fn[ m ][ r ] (记录的是在花费m块大洋和r的人品能够泡到最多MM的数量)以及 ft[ m ][ r ] (记录达到这一阶段最大值所用的最短时间， 该数组随着上一个数组的更新而更新， 具体可以看代码). 

最后， 我们再遍历一遍所有的fn[ ][ ], 对于每一个到达了最大值的阶段， 不断更新最小的答案， 输出即可。
以下是我的代码： 
```cpp
#include <bits/stdc++.h>
#define N 101
using namespace std;
const int inf = 0x7fffffff;
int n, rmb[N], rp[N], t[N], m, r;
int ans = inf, fn[N][N], ft[N][N];
inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)){
		if(ch == '-')	f = -1;
		ch = getchar();
	}while (isdigit(ch))
		x = x * 10 + ch - '0', ch = getchar();
	return x * f;
}
int main(){
	n = read();
	for (int i = 1; i <= n; i++)
		rmb[i] = read(), rp[i] = read(), t[i] = read();
	m = read(), r = read();
	for (int i = 1; i <= n; i++)
		for (int j = m; j >= rmb[i]; j--)
			for (int k = r; k >= rp[i]; k--){
				int fr = fn[j][k], nxt = fn[j - rmb[i]][k - rp[i]] + 1;
				int ti = ft[j - rmb[i]][k - rp[i]] + t[i];
				fn[j][k] = max(nxt, fr);//更新 fn
				if (nxt == fr)	ft[j][k] = min(ft[j][k], ti);
				if (nxt > fr)	ft[j][k] = ti;//ft 随着 fn 一起更新
			}
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= r; j++)
			if (fn[m][r] == fn[i][j])	
				ans = min(ans, ft[i][j]);//寻找最小的时间
	cout << ans;
	return 0;
}

```

---

## 作者：dzz1537568241 (赞：25)

# 次要性动态规划

本篇题解有...

- **介绍次要性动态规划** 

- **适用条件**

- **解题思路**

- **局限性**

# 一，什么是次要性dp

**次要性dp**是指，在使得一个**条件到达最优**的情况下，让第二个条件也达到最优，在**第二个条件也达到最优**时，让**第三个条件也最优**...

这种分先后次序（或者说**分主次**）依次达成最优解的动态规划，被称为 **次要性dp**

（定义看看就好了，不懂也没事）

# 二，怎样做

（参考算法竞赛入门经典解题指南）

**确定优化目标**

本题的优化目标有两个

1）让xx的女朋友最多

2）让xx在女朋友最多的情况下，花费时间最少

我们可以设xx最后的女朋友数最后为 a ，xx最后花费的时间为t,

则我们可以把最小化目标定为

M * a - t

其中M是一个很大的正整数

你一定会问，为什么要这么干？

你可以想象成**一个百分比**：

xx的女朋友数对答案的影响为 p%

xx的花费时间对答案的影响为 k%

在这道题目里xx的女朋友个数 对 答案的影响

比xx的花费时间对答案的影响**大的多**

（或者说起决定性作用）

因此，我们要确保xx的女朋友数**对答案的影响的百分比** **远大于** **xx的花费时间 对答案的影响**

事实上，你只需要确保

M > 所有的 xx花费的时间 总和 tmax

**这样，当a不同的时候，a对答案起决定性作用，**

**只有当a相同的时候，t 才会对答案起决定性作用**

给出代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring> 
using namespace std;
const int maxn = 150;
int rd(){
	int x = 0, f = 1;char c = getchar();
	while( c < '0' || c > '9' ){if(c == '-'){f = -1;}c = getchar();} 
	while( c <= '9' && c >= '0'){x = x * 10 + c - '0'; c = getchar();}
	return x*f; 
}

int cmax, rpmax;
int N, c[maxn], t[maxn], rp[maxn], f[maxn][maxn];
//f[i][j]表示花费i点money，j点rp，所能得到的最大权值

int w[maxn];//权值被估算后的总权值
 
int main(){
	N = rd();
	for(int i = 1; i <= N; i++){
		c[i] = rd();
		rp[i] = rd();
		t[i] = rd();		
	}
	
	for(int i = 1; i <= N; i++){
		w[i] = 20000 - t[i];
	}
	
	cmax = rd(); rpmax = rd();
	
	for(int i = 1; i <= N; i++){
		for(int j = cmax; j >= c[i]; j--){
			for(int k = rpmax; k >= rp[i]; k--){
				f[j][k] = max(f[j - c[i]][k - rp[i]] + w[i], f[j][k]);
			}
		}
	}
	cout<<((f[cmax][rpmax]/20000) + 1)*20000 - f[cmax][rpmax];
} 
```
# 三，优缺点

次要性dp的优缺点是非常明显的：

先来说说优点吧：

代码非常短，非常好写，在处理非常复杂的问题的时候可以大幅度的降低思考时间和出错可能，骗分的不二选择

然后是缺点：

M的值非常难定，而且很容易爆精度，一旦定的太高或者太低，就会爆零，**风险很大**


---

## 作者：剑鞘承天 (赞：12)

  大家好我还是那只瑟瑟发抖的蒟蒻承天~
  
  为了~~水估值~~建设洛谷社区的完整性，我来写一下这一道~~刚会不久~~简简单单的题目的题解。
  
  阅读题面，我们不难~~生出单身的痛苦~~发现，这是一道0-1背包。仔细阅读后，又会~~生出单身的痛苦~~发现，它和普通的0-1背包有些不同：
  
  1. 每一个姑娘的价值相同，都是1，但答案要求的是最大价值时的最小时间；
  
  2. 除了每次消耗的人品（不妨看做原先的背包容量）以外，还要消耗手上的大洋，故每泡一个妹子有两个代价。
  
  于是针对以上两点不同，我们可以有下面两个对策：
  
  1. 开两个数组，一个记录该状态时的价值（即人数num），和该状态时用掉的时间（time）；
  
  2. 将数组提高一个维度，同时多来一次循环。
  
  于是0-1背包原先的状态转移方程
  ```cpp
	dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])
```
  就变成了
  ```cpp
	if(num[i-1][j][z]<num[i-1][j-dayang[i]][z-rp[i]]+1)       //当人数大于原先时
	{
		num[i][j][z]=num[i-1][j-dayang[i]][z-rp[i]]+1;      //人数加上去
		time[i][j][z]=time[i-1][j-dayang[i]][z-rp[i]]+ti[i];//时间也要加
	}
```
  但这只有一部分，还没有考虑价值相同时，要取最短的时间，故再加一个 else ：
  ```cpp
	else
		if(num[i-1][j][z]==num[i-1][j-dayang[i]][z-rp[i]]+1)
		{
			time[i][j][z]=min(time[i-1][j-dayang[i]][z-rp[i]]+ti[i],time[i-1][j][z]);
			num[i][j][z]=num[i-1][j-dayang[i]][z-rp[i]]+1;
		}
```
  最后价值小于原先时，再加一个判断语句
  ```cpp
	else
	{
		num[i][j][z]=num[i-1][j][z];
		time[i][j][z]=time[i-1][j][z];
	}
```
  现在完成了作为灵魂的程序的编辑，最后将肉体加上就好了~
  
  上代码！！
  
  ```cpp
	#include<bits/stdc++.h>
	using namespace std;
	long time[105][105][105],num[105][105][105],ti[105],dayang[105],rp[105],n,m,r;//time当然是时间，num是人数 
	int main()
	{
		cin>>n;//n为人数 
		for(int i=1;i<=n;i++)
		{
			cin>>dayang[i]>>rp[i]>>ti[i];//dayang是钱，rp是人品，ti则是时间 
		}
		cin>>m>>r;//m是手头的大洋，r是脸上的人品
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=m;j++)
			{
				if(j>=dayang[i])
				{
					for(z=0;z<=r;z++)
					{
						if(z>=rp[i])
						{
							if(num[i-1][j][z]<num[i-1][j-dayang[i]][z-rp[i]]+1)
							{
								num[i][j][z]=num[i-1][j-dayang[i]][z-rp[i]]+1;
								time[i][j][z]=time[i-1][j-dayang[i]][z-rp[i]]+ti[i];
							}
							else
							{
								if(num[i-1][j][z]==num[i-1][j-dayang[i]][z-rp[i]]+1)
								{
									time[i][j][z]=min(time[i-1][j-dayang[i]][z-rp[i]]+ti[i],time[i-1][j][z]);
									num[i][j][z]=num[i-1][j-dayang[i]][z-rp[i]]+1;
								}
								else
								{
									num[i][j][z]=num[i-1][j][z];
									time[i][j][z]=time[i-1][j][z];
								}
							}
						}
						else
						{
							time[i][j][z]=time[i-1][j][z];
							num[i][j][z]=num[i-1][j][z];
						}
					}
				}
				else
				{
					for(int z=0;z<=r;z++)//要是不行的话记得要把全部的z遍历一遍
					{
						time[i][j][z]=time[i-1][j][z];
						num[i][j][z]=num[i-1][j][z];	
					}
				}
			}
		}
		cout<<time[n][m][r];
		return 0;
	} 
```
  本篇题解因本题所有题解都来压维，~~我看不怎么懂~~，所以来一篇不压维的，望管理员大大通过一下吧~
  
  ~~要是题目里的事发生在我身上该多好~~

---

## 作者：jyz666 (赞：12)


【思路】

二维费用背包。

特点：需要花费两种代价。

f[m][r]为找到的最多的妹子数。如果在某个妹子泡了之后，剩下花费x-rmb[i] 和k-rp[i]泡的妹子+1 与原来的妹子相等。

就考虑这个妹子花费的时间了，是原来多还是现在得多。再开一个二维数组，存花费的时间。

上代码。。。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,rp[101],tim[101],rmb[101],f[101][101],m,r,ff[101][101];
int main() {
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
        scanf("%d%d%d",&rmb[i],&rp[i],&tim[i]);
    scanf("%d%d",&m,&r);//m块大洋r的人品。
    for(int i=1; i<=n; i++) {
        for(int j=m; j>=rmb[i]; j--) {
            for(int k=r; k>=rp[i]; k--) {
                    if(f[j][k]<f[j-rmb[i]][k-rp[i]]+1)
                    {
                        f[j][k]=f[j-rmb[i]][k-rp[i]]+1;
                        ff[j][k]=ff[j-rmb[i]][k-rp[i]]+tim[i];
                    }
                    if(f[j][k]==f[j-rmb[i]][k-rp[i]]+1&&ff[j][k]>ff[j-rmb[i]][k-rp[i]]+tim[i])
                    {
                        ff[j][k]=ff[j-rmb[i]][k-rp[i]]+tim[i];
                    }
            }
        }
    }
    printf("%d\n",ff[m][r]);
    return 0;
}
 

```


---

## 作者：litangxingxing (赞：6)

蒟蒻贡献一篇题解


简单分析一下，把妹子看成一堆物品（但好像把妹子看成物品经常会被掐死），每个物品有两个权重。

并且有两个价值（人数和时间，人数的优先级要高于时间）

然后跑01背包就行了


顺便祝各位蓝孩子们早日找到BF，各位绿孩子早日找到GF


下面是代码


```cpp
    #include<cstdio>
    #include<iostream>
    using namespace std;
    int n,m,r;
    int dp[105][105],time[105][105];
    int userp[105],usemo[105],useti[105];
    int main(){
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d%d%d",&usemo[i],&userp[i],&useti[i]);
        }
        scanf("%d%d",&m,&r);
        for(int i=1;i<=n;i++){
            for(int j=m;j>0;j--){
                for(int k=r;k>0;k--){
                    if(j>=usemo[i]&&k>=userp[i]){
                        if(dp[j][k]<dp[j-usemo[i]][k-userp[i]]+1){
                            dp[j][k]=dp[j-usemo[i]][k-userp[i]]+1;//如果能泡到更多当然多多益善
                            time[j][k]=time[j-usemo[i]][k-userp[i]]+useti[i];
                        }
                        else if(dp[j][k]==dp[j-usemo[i]][k-userp[i]]+1){
                            if(time[j][k]>time[j-usemo[i]][k-userp[i]]+useti[i])
                                time[j][k]=time[j-usemo[i]][k-userp[i]]+useti[i];//如果不能更多的话，那就找好搞定的
                        }
                    }
                }
            }
        }
        printf("%d\n",time[m][r]);
        return 0;
}
```

---

## 作者：Legendre_Gauss (赞：5)

本题是一道背包常规题。

抛开题面描述，本题的意思就是给定n个物品，一共有三个条件，要注意的是不能直接对三类数据进行直接处理。

那我们不如先想一想普通的01背包，我们已知的有每个商品的价值和体积。

那么在本题中，每个物品的价值都已经固定为1，但是每个商品的耗费同时存在两类数据，即rmb和rp；

所以首先我们要将原本的两层循环增加到三层，一层枚举商品，一层枚举rmb，一层枚举rp。

接着，本题要求的是获得最多商品的最小时间，那没我们不能只用一个数组处理出最大价值，还要一个数组处理时间。

处理最大价值当01背包来进行状态转移就可以了，那么对于时间，我们需要根据最大价值的改变更新时间。这里有两种情况：

1.如果当前状态没有前一个状态优，更新当前状态，同时更新时间。

2.如果当前状态不劣于前一个状态，那么更新最短时间

```
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int n,m,r;
int f[200][200],ftime[200][200];

struct Node
{
    int rmb;
    int rp;
    int time;
}a[150];

void init()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&a[i].rmb,&a[i].rp,&a[i].time);
    scanf("%d%d",&m,&r);
    return;
}

void work()
{
    for(int i=1;i<=n;i++)
        for(int j=m;j>=a[i].rmb;j--)
            for(int k=r;k>=a[i].rp;k--)
                if(f[j][k]<f[j-a[i].rmb][k-a[i].rp]+1)
                    f[j][k]=f[j-a[i].rmb][k-a[i].rp]+1,ftime[j][k]=ftime[j-a[i].rmb][k-a[i].rp]+a[i].time;
                else if(f[j][k]==f[j-a[i].rmb][k-a[i].rp]+1)
                    ftime[j][k]=min(ftime[j][k],ftime[j-a[i].rmb][k-a[i].rp]+a[i].time);
    cout<<ftime[m][r]<<endl;
}

int main()
{
    init();
    work();
    return 0;
}
```

---

## 作者：林普巴兹提特 (赞：4)

小蒟蒻偷偷提交一篇题解,望大佬采纳
在这道题中用到了三个变量rp,rmb,time,其中time和GF的数量作为判断的标准,所以呢,我就想到了结构体dp.
```cpp
#include<iostream>
using namespace std;
const int N=1005;
const int M=105;
struct Node{
    int num;
    int tim;
    void show()
    {
        cout<<tim<<endl;
    }
	Node()
	{
		num=0;
		tim=0;
	}
    Node(int _num,int _tim)//可以快捷地定义一个Node结构体
    {
        num=_num;
        tim=_tim;
    }
    bool operator > (const Node &n1) const
    {
        if(num!=n1.num)//如果GF数量不相等,就判断GF的数量
        {
            return num > n1.num;
        }
        else//如果GF数量相等,就判断时间
        {
            return tim < n1.tim;//因为是时间小的优先所以是 <
        }
    }
    Node operator + (const Node &n1) const//重载加号,方便后面操作
    {
		Node ans;
        ans.num=num+n1.num;
        ans.tim=tim+n1.tim;
		return ans;
    }
};
int n,m,r;
int rp[M],rmb[M],tim[M];
Node dp[M][M];

int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>rmb[i]>>rp[i]>>tim[i];//输入,并没有什么好解释的
    }
    cin>>m>>r;
    for(int i=1;i<=n;i++)
    {
        for(int j=r;j>=rp[i];j--)//如果j<rp[i]的话就泡不到了,直接剪掉(告诉了我们平时攒rp的重要性)
        {
            for(int k=m;k>=rmb[i];k--)//如果k<rmb[i]的话就泡不到了,直接剪掉
            {
				if(dp[j-rp[i]][k-rmb[i]]+Node(1,tim[i])>dp[j][k])//如果泡这个妹子的价值大于当前状态就更新
				{
					dp[j][k]=dp[j-rp[i]][k-rmb[i]]+Node(1,tim[i]);//因为前面重载了+,所以可以直接相加
				}
            }
        }
    }
    dp[r][m].show();//懒得写输出所以编了一个show函数
    return 0;
}
```
### 最后疯狂强调不要定义变量叫time!!!!!!!
### 就因为开始把tim定义成time,交了两次都没过

---

## 作者：TESJackeyLove (赞：3)

**刚看到这个题的时候第一反应就是背包问题，但是这个背包又和模板的01背包，完全背包稍微有点不太一样。谈一下自己的想法吧（大佬勿喷）**
- 之前的01或者完全背包的模板题就是直接套模板，两层循环解决问题，这里似乎就行不通了，因为它有双重代价：rmb和rp两层限制，而且题目要求的是在保证数量尽可能多的条件下使得花费的时间尽可能少。
- 为了方便我们理解，我们可以把原来的dp数组开成三维的，dp[i][j][k]表示用j这么多的rmb和k这么的rp去泡i个妹子花费的最小代价，但是我们还需要去判断一下是否保证了数量，那么这里可以把dp数组开成一个结构体的形式：

  ```cpp
  struct node{
      int num;//泡了几个妹子
      int tim;//花费的时间
  };
  ```
- 那么dp[i][j][k].num就是在i,j,k的限制下最多可以泡几个妹子，dp[i][j][k].time就是在i,j,k和dp[i][j][k].num的限制下最少花费的时间了(当然这里不用结构体，开两个数组也是可以的)
- 然后就是DP的重点了，状态转移方程，怎么去转移?这题每个妹子只能泡一次，那就是01背包了。  
按照01背包的思想，第一层for循环遍历物品(这里是妹子)，第二层for循环遍历rmb钱数，第三层循环遍历rp人品。  
dp[i][j][k]肯定是从dp[i-1][j-rmb[i]][k-rp[i]]转移过来的，那么怎么转移呢？  
- 我们首先得保证数量，再去看时间  
那么就看dp[i][j][k].num与dp[i-1][j-rmb[i]][k-rp[i]].num+1的大小（因为你选了这个MM，个数肯定得加1呀） :  
  1. 如果相等，那么：  
  dp[i][j][k].tim就更新为二者tim的较小值。  
  1. 如果dp[i][j][k].num较小，那么就把dp[i][j][k].num更新为后者的num加1，dp[i][j][k].tim更新为后者的tim+第i个妹子的时间。  
  1. 如果dp[i][j][k].num较大，就不管，保持不变。
  
- 当然这里按照01背包滚动数组的方法可以把第一维优化掉，只需要开二维数组就可以了，最后我们输出当rmb到达最大值m，rp到达最大值r的dp[m][r].tim就可以了。以下是丑陋的代码：
  ```cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<algorithm>
  #include<cstring>
  #include<cstdlib>
  #include<queue>
  #include<stack>
  #define fore(i,a,b) for(int i=a;i<=b;i++)
  #define foru(i,a,b) for(int i=a;i<b;i++)
  #define ford(i,a,b) for(int i=a;i>=b;i--)
  #define IGNB std::ios::sync_with_stdio(false);
  #define ll long long
  #define INF 0x3fffffff
  using namespace std;
  struct node{
      int num;
      int tim;
  };
  int rmb[105],rp[105],t[105];
  node dp[105][105];
  int main(){
      IGNB;
      int n,m,r;
      cin>>n;
      fore(i,1,n){
          cin>>rmb[i]>>rp[i]>>t[i];
      }
      cin>>m>>r;
      fore(i,1,n){
          ford(j,m,rmb[i]){
              ford(k,r,rp[i]){
                  if(dp[j][k].num==dp[j-rmb[i]][k-rp[i]].num+1){
                      dp[j][k].tim=min(dp[j][k].tim,dp[j-rmb[i]][k-rp[i]].tim+t[i]);
                  }
                  else if(dp[j][k].num<dp[j-rmb[i]][k-rp[i]].num+1){
                      dp[j][k].num=dp[j-rmb[i]][k-rp[i]].num+1;
                      dp[j][k].tim=dp[j-rmb[i]][k-rp[i]].tim+t[i];
                  }
              }
          }
      }
      cout<<dp[m][r].tim;
      return 0;
  }

  ```








---

## 作者：s223568907 (赞：2)

（人生第一次写题解）

一个两种费用的01背包，用结构体存了一下此money和rp所能获得的时间和妹子数

···cpp



    

```cpp
#include<bits/stdc++.h>
using namespace std;
struct girl
{
    int money,rp,time;
};
girl g[1010];
struct vir
{
    int num,cost;
};
vir s[1010][1010];//s[i][j]即钱数为i，rp为j时的最优情况
int n,m,r;
void init()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    scanf("%d%d%d",&g[i].money,&g[i].rp,&g[i].time);
    scanf("%d%d",&m,&r);
    return;
}
bool check(int i,int j,int k)
{
    if(s[i-g[k].money][j-g[k].rp].num+1>s[i][j].num)return true;//如果选上后人数更多
    if(s[i-g[k].money][j-g[k].rp].num+1==s[i][j].num&&
    s[i-g[k].money][j-g[k].rp].cost+g[k].time<s[i][j].cost)return true;//如果选上后人数一样但是时间更少
    return false;
}
void dp()
{
    for(int i=0;i<=m;i++)
    for(int j=0;j<=r;j++)
    s[i][j].num=0,s[i][j].cost=0;
    for(int k=1;k<=n;k++)//两个费用的01背包，当前选第k个妹子
    for(int i=m;i>=g[k].money;i--)//money
    for(int j=r;j>=g[k].rp;j--)//rp
    if(check(i,j,k))//如果选这个妹子更优
    {
        s[i][j].num=s[i-g[k].money][j-g[k].rp].num+1;
            s[i][j].cost=s[i-g[k].money][j-g[k].rp].cost+g[k].time;
    }
    return;
}
void print()
{
    if(s[m][r].num==0)//OIer没有妹子......
    {
        printf("0");
        return;
    }
    printf("%d",s[m][r].cost);
    return;
}
int main()
{
    init();
    dp();
    print();
    return 0;
}
···
```

---

## 作者：蔡俊黠 (赞：1)

我们老师管这个叫二维费用背包~

对于每个girl，有两种不同的费用rmb和rp，要想用现有的RMB和RP来找到尽可能多的GF，很容易想到背包

设f[i][j]表示花费i个RMB和j个RP能找到的最多GF数量，则递推式为

### f[i][j]=max(f[i][j],f[i-a[k].rmb][j-a[k].rp]+1)

这里我用k表示第k个钟意的女生

那么当花费i,j找到的girl相同时怎么办？当然是找花费时间最少的，所以就多加一个t数组来存花费i,j而且能找到GF的情况下用的最少时间

详情见code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,RMB,RP,f[110][110],t[110][110];
struct node{
	int rmb;
	int rp;
	int time;
}a[110];
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
	  scanf("%d%d%d",&a[i].rmb,&a[i].rp,&a[i].time);
	scanf("%d%d",&RMB,&RP);
	for (int k=1;k<=n;k++)
	  for (int i=RMB;i>=a[k].rmb;i--)
		for (int j=RP;j>=a[k].rp;j--)
		{
			if (f[i][j]<f[i-a[k].rmb][j-a[k].rp]+1)
			{
				f[i][j]=f[i-a[k].rmb][j-a[k].rp]+1;
				t[i][j]=t[i-a[k].rmb][j-a[k].rp]+a[k].time;
			}
		  	if (f[i][j]==f[i-a[k].rmb][j-a[k].rp]+1)
			  t[i][j]=min(t[i][j],t[i-a[k].rmb][j-a[k].rp]+a[k].time);
		}
	printf("%d\n",t[RMB][RP]);
	return 0;
}
```


---

## 作者：神秘人哈哈 (赞：1)

    #include <iostream>
    using namespace std;
    // f[i][j]表示消耗i钱j人品最多得到的女朋友数
     // time[i][j]表示消耗i钱j人品获得最多女朋友的最少花费时间 
     int n,m,r,r1[105],r2[105],r3[105],f[105][105],time[105][105];
    int main()
    {

    cin>>n;
    for(int i=1;i<=n;i++) cin>>r1[i]>>r2[i]>>r3[i];
    cin>>m>>r;
    for(int i=1;i<=n;i++){
        for(int j=100;j>=1;j--){
            for(int k=100;k>=1;k--){
                if(j-r1[i]>=0&&k-r2[i]>=0){
                    if(f[j][k]<f[j-r1[i]][k-r2[i]]+1){
                        f[j][k]=f[j-r1[i]][k-r2[i]]+1;
                        time[j][k]=time[j-r1[i]][k-r2[i]]+r3[i];
                    }
                    else if(f[j][k]==f[j-r1[i]][k-r2[i]]+1){//这里的等于号被我写成了赋值号，找了半天错 
                        time[j][k]=min(time[j][k],time[j-r1[i]][k-r2[i]]+r3[i]);
                    }
                }
            }
        }
    }
    cout<<time[m][r]<<endl;
    return 0;
    }

---

## 作者：Max_Leo (赞：0)

[传送门](https://www.luogu.org/problem/P1509)

## 典型的**01背包**
[没听说过？点这儿](https://www.cnblogs.com/zyacmer/p/9961710.html)
### 本蒟蒻只会用**3维**

因为数据范围都比较小所以用3维dp也可以过，而且理解起来更加方便。~~（至少本蒟蒻根本看不懂其他巨佬的题解）~~专门为新学DP的OIer准备

dp[i][j][k]表示用i的rmb，j的rp泡k个GF所用的最少的时间
很简单就可以找到动态转移方程

#### dp[i][j][k]=min(dp[i][j][k],dp[i-a[l].rmb][j-a[l].rp][k-1]+a[l].time)

整个内容的核心就是这个了（其中-1代表不能用i的rmb,j的人品泡到k个GF）
```cpp
for(int l=1;l<=n;l++)
		for(int i=m;i>=a[i].rmb;i--)
			for(int j=r;j>=a[i].rp;j--)
				for(int k=i;k>0;k--)
					if(dp[i-a[l].rmb][j-a[l].rp][k-1]!=-1)
						if(dp[i][j][k]==-1)dp[i][j][k]=dp[i-a[l].rmb][j-a[l].rp][k-1]+a[l].time;
						else dp[i][j][k]=min(dp[i][j][k],dp[i-a[l].rmb][j-a[l].rp][k-1]+a[l].time);
```
然后最后在找k最大为多少，再在中找最小值

附上完整的AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,r;
struct a
{
	int rmb,rp,time;
}a[110];
int dp[110][110][110];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
        scanf("%d %d %d",&a[i].rmb,&a[i].rp,&a[i].time);
    scanf("%d %d",&m,&r);
	memset(dp,-1,sizeof(dp));
    dp[0][0][0]=0;
	for(int i=1;i<=n;i++)
		for(int j=m;j>=a[i].rmb;j--)
			for(int k=r;k>=a[i].rp;k--)
				for(int l=i;l>0;l--)
					if(dp[j-a[i].rmb][k-a[i].rp][l-1]!=-1)
						if(dp[j][k][l]==-1)dp[j][k][l]=dp[j-a[i].rmb][k-a[i].rp][l-1]+a[i].time;
						else dp[j][k][l]=min(dp[j][k][l],dp[j-a[i].rmb][k-a[i].rp][l-1]+a[i].time);
	for(int i=n;i>0;i--)
	{
		bool flag=0;
		int ans=0xfffff;
		for(int j=0;j<=m;j++)
			for(int k=0;k<=r;k++)
				if(dp[j][k][i]!=-1)
				{
					ans=min(ans,dp[j][k][i]);
					flag=1;
				}
		if(flag)
		{
			cout << ans;
			return 0;
		}
	}	
	cout << 0;
	return 0;
}
```


---

## 作者：依依 (赞：0)

解：二维费用背包的应用

f[j][k]表示花费j的钱币，k的人品最多能够泡到的妹子个数

转移同普通的二维费用背包

但我们要求的是最多妹子下的最少时间，

那我们就在转移的时候进行判断一下
```
             int jj=j-co[i],kk=k-rp[i];
	  	    if(jj>=0 && kk>=0) 
	  	    {
	  	    	if(f[j][k]<f[jj][kk]+1)
	  	        {
	  	     	    f[j][k]=f[jj][kk]+1;
				    dp[j][k]=dp[jj][kk]+t[i];
			    }else if(f[j][k]==f[jj][kk]+1){
			    	dp[j][k]=min(dp[j][k],dp[jj][kk]+t[i]);
				}
			}
```


更新dp[j][k]就好了

最后答案，dp[m][r].  
[日常链接](http://www.cnblogs.com/adelalove/p/8849392.html)



---

## 作者：睿屿青衫 (赞：0)

#提交了n遍，不好意思又把通过率拉低了

##反复改，路程坎坷==个人代码风格都不一样（学习别人的除外），所以贴上来说不定看不懂楼下代码的各位会ac这道题

###第一个20分代码，直接求泡到最多mm时花费的时间，忘记还要求最短了（本人蒟蒻，如果这也写错了请指正）

···cpp

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 1010
using namespace std;
int n,ti[maxn],rmb[maxn],m,rp[maxn],r,f[maxn][maxn];
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         x=x*10+ch-'0';
         ch=getchar();
     }
    return x;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
     {
         rmb[i]=read();
         rp[i]=read();
         ti[i]=read();
     }
    m=read();r=read();
    for(int i=1;i<=n;++i)
     for(int j=r;j>=rp[i];--j)
      for(int v=m;v>=rmb[i];--v)
       {
           f[j][v]=max(f[j][v],f[j-rp[i]][v-rmb[i]]+ti[i]);
       }
    printf("%d\n",f[r][m]);
    return 0;
}
```
···
###第二份代码，30分，3色（ac，wa，tle）你会惊讶的发现不提供数据==

···cpp

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 2020
using namespace std;
int n,ti[maxn],sum_tot,f[maxn][maxn],rmb[maxn],m,rp[maxn],r,sum[maxn][maxn];
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         x=x*10+ch-'0';
         ch=getchar();
     }
    return x;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
     {
         rmb[i]=read();
         rp[i]=read();
         ti[i]=read();
     }
    m=read();r=read();
    for(int i=1;i<=r;++i)
     for(int j=1;j<=m;++j)
      f[i][j]=-2000;//看到后面的处理你就懂我为什么这样写了 
    for(int i=1;i<=n;++i)
     for(int j=r;j>=rp[i];--j)
      for(int v=m;v>=rmb[i];--v)
       for(int z=0;z>=-ti[i];--z)
       {
//       多次修改，最后这个z的循环貌似并没有用，去掉说不定tle的点会变成ac或wa 
//       我们要求最少时间，但是用min，一定是0！每次处理都是0！ 
//       所以说，前面初始化为-2000，然后时间都用负数求最大，最后结果变符号就是最少时间 
//         其实，这份代码只能得一部分分，我不知道这么想对不对，大家考虑一下 
       f[j][v]=max(f[j][v],f[j-rp[i]][v-rmb[i]]-ti[i]);
       }
    printf("%d\n",-f[r][m]);
    return 0;
}
```
···
###第三份代码，终于ac了，个人感觉挺详细的（捂脸），两个状态数组

···cpp

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 2020
using namespace std;
int n,ti[maxn],sum_tot,f[maxn][maxn],rmb[maxn],m,rp[maxn],r,sum[maxn][maxn];
int read()//读入优化，背过即可 
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
     {
         x=x*10+ch-'0';
         ch=getchar();
     }
    return x;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
     {
         rmb[i]=read();
         rp[i]=read();
         ti[i]=read();//应该都是题目给的变量，不过time改成ti，貌似time是个特殊玩意== 
     }
    m=read();r=read();
    //差不多就是个01背包，然后j,v就这么出来，比普通的多了一层 
    for(int i=1;i<=n;++i)
     for(int j=r;j>=rp[i];--j)
      for(int v=m;v>=rmb[i];--v)
       {
           if(sum[j][v]<sum[j-rp[i]][v-rmb[i]]+1)
            {
                sum[j][v]=sum[j-rp[i]][v-rmb[i]]+1;//sum数组代表泡到最多mm 
                f[j][v]=f[j-rp[i]][v-rmb[i]]+ti[i];//更新泡到最多mm时的花费时间 
            }
        if(sum[j][v]==sum[j-rp[i]][v-rmb[i]]+1)
         {
             f[j][v]=min(f[j][v],f[j-rp[i]][v-rmb[i]]+ti[i]);
             //如果已经泡到了目前阶段最多的mm，则更新一下最少的时间 
         }
       }
    printf("%d\n",f[r][m]);//想一想，普通01背包的f后面（成员）不是也跟着个最大值吗 
    return 0;
}
```
···
#祝大家最后被这道题绿（|=\_=|）


---


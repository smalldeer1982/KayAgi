# [COCI 2024/2025 #2] 游戏 / Igre

## 题目背景

译自 [COCI 2024/2025 #2](https://hsin.hr/coci/) T2。$\texttt{2s,0.5G}$。满分为 $70$。

## 题目描述

游戏 $i$ 需要 $p_i$ 分钟来学习。一款游戏只有学习怎么玩之后才可以玩。

玩一局游戏 $i$ 需要 $t_i$ 分钟，可以获得 $o_i$ 分。可以多次游玩一款游戏。

适度游戏益脑，过度游戏伤身。如果只花 $m$ 分钟来玩（包括学习玩）游戏，最多可以获得多少分？


## 说明/提示


#### 样例解释

样例 $3$ 解释：

学第 $1,3$ 款游戏，耗时 $1+2=3$ 分钟。

游玩游戏 $1,3,3$，获得 $1+5+5=11$ 分，耗时 $1+3+3=7$ 分钟。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le n,m,t_i\le 5\, 000$；
- $0\le p_i\le 5\, 000$；
- $1\le o_i\le 10^9$。


| 子任务编号 | $n\le$ |  特殊性质 | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $1$ |     |   $ 6 $   |  
| $ 2 $    | $10$ |   |  $ 13 $   |  
| $ 3 $    | $5\, 000$  | A | $ 23 $   |
| $ 4 $    | $5\, 000$  | | $ 28 $   |

- 特殊性质 A：$\forall 1\le i\le n$，$p_i=0$。




## 样例 #1

### 输入

```
3 10
2 3 5
5 1 5
3 2 5```

### 输出

```
25```

## 样例 #2

### 输入

```
4 13
0 6 5
0 3 4
0 2 3
0 4 4```

### 输出

```
19```

## 样例 #3

### 输入

```
3 10
1 1 1
3 2 3
2 3 5```

### 输出

```
11```

# 题解

## 作者：cy20110922 (赞：9)

# 分析
先看一眼算法标签，哦是背包啊。再看一眼题目，既然可以多次游玩，那一定就是完全背包！
# 思路
本题跟完全背包不同的一点是他要先学习完游戏才能开始玩，所以只要把  $dp$ 数组下标从  $j$ 改为  $t-j$ 就可以了。对于完全背包的做法  $dp[j]$ 表示时间为  $j$ 时所获得的最大分数。然后我们可以在创建一个数组  $maxn$ 来实时保存最大值。最后便利一遍  $maxn$ 找出最大值就可以了。 
# 上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[60000],c[60000],w[60000],t[60000],maxn[6000],sum=0;
signed main(){
	int n,m;
	cin >> n >> m;
	for(int i=1;i<=n;i++){
		cin >> t[i] >> w[i] >> c[i];
		for(int j=m;j>=t[i];j--){
			dp[j]=maxn[j-t[i]];
		}
		for(int j=w[i]+t[i];j<=m;j++){
			dp[j]=max(dp[j],dp[j-w[i]]+c[i]);
			maxn[j]=max(maxn[j],dp[j]);
		}
	}
	for(int i=1;i<=m;i++){
		sum=max(sum,maxn[i]);
	}
	cout << sum;
	return 0;
}
```

---

## 作者：FZY_CZY (赞：7)

# 读题
我们来看一下题面，然后抓住一些关键信息。

1. 玩这款游戏之前需要花费 $p_i$ 的时间。
2. 一局游戏的时间为 $t_i$，得分为 $o_i$。
3. $n$ 种游戏，$m$ 分钟的时间。

对于上面这些十分轻易就能整理得出的信息，我们可以发现，这道题是一道与模板高度相似（不完全一样）的完全背包问题。

# 思路
那么对于题目的特殊条件，我们进行一个推导。

首先，我们设答案为 $f_{\max}$，也就是说，我们用一个 $f$ 数组存储答案，最后进行 $\max$。

由信息的第一点可知，我们对于每一个 $f_i$，都需要在递推（应该是叫递推吧）之前，进行一个 $f_i=f_{i-p_i}$，以此达到题目的要求。

然后第二点、第三点要求就非常容易理解了，这就是一个完全背包的板子，所以状态转移方程就不给了。

其实应该到这里就结束了，但是我们要进行一个正确的 dp，还要考虑一点，那就是 dp 的无后效性，这一点在我看来比前面的归纳总结都重要。

因此，我们需要用两个数组（下面结合代码分析这样的原因）$dp$ 和我们原来就有的 $f$。

大致的思路就讲到这里了，余下的事情在代码注释里看吧。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long//十年OI一场空，不开long long见祖宗
using namespace std;
const int N=5e3+10;//个人习惯
int n,m;
int dp[N],f[N];
int p,t,o;
signed main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>p>>t>>o;
		for (int j=m;j>=p;j--) dp[j]=f[j-p];//文章里面提到了，需要对当前的状态进行一个偏移，以此符合题目中p[i]的要求
		for (int j=t+p;j<=m;j++)//正常的完全背包板子
		{
			dp[j]=max(dp[j],dp[j-t]+o);//正常的完全背包板子
			f[j]=max(f[j],dp[j]);//更新f[i]的值
			//这里用dp和f来表示对于当前的时间来说，得分的Max值
			//用两个数组是因为f是最终答案，但是会受到每一次运算的影响
			//所以用dp作为一个暂时存储答案的数组，如果需要更新答案再对dp取Max
		}
	}
	int res=0;
	for (int i=1;i<=m;i++) res=max(res,f[i]);//我们需要对f整体取一个Max
	cout<<res;
	return 0;
}
``````
需要强调的是，$o_i \le 10^9$，所以及其容易爆 long long。

完结撒花！！！

---

## 作者：Ascnbeta (赞：5)

## P11430 [COCI 2024/2025 #2] 游戏 / Igre
看了下题解好像是都是完全背包修改，空间复杂度是 $O(nm)$。而我想到的是这不一眼依赖背包么，所以写一发依赖背包的题解，时间复杂度一样但是空间复杂度更优，为 $O(m)$。

本题依赖背包的做法可以延伸到另一道题，可以做做：[P2967](https://www.luogu.com.cn/problem/solution/P2967)，以及我的题解：[这里](https://www.luogu.com.cn/article/u5wq4okk)。

## 思路分析
我们可以把一款游戏拆成两个物品，一个物品获取需花费 $p_i$ 的代价，没有收益，数量是 $1$（其实是几没关系，因为你不可能学习多次）。另一个物品花费 $t_i$，收益是 $o_i$，数量是无穷多，但是想要获取它必须先获取上一个物品。于是这个问题就成了依赖背包问题。

然后我们用依赖背包的想法去思考。由于每款游戏的第一个物品没有收益，我们可以先对第二个物品做完全背包，统计不计算**第 $i$ 款游戏**的 $p_i$ 时前 $i$ 款游戏的最大收益（伪收益），状态转移方程如下：（未进行降维优化，因此有 $k$ 的出现，表示玩当前游戏的局数）
$$
f_{i,j} \gets \max(f_{i-1,j},f_{i-1,j-t_ik}+o_ik)
$$
然后我们再统计算上第 $i$ 款游戏的 $p_i$ 时，前 $i$ 款游戏的最大收益（真收益）：
$$
g_{i,j} \gets \max(g_{i-1,j},f_{i-1,j-p_i})
$$
最后统计数组的最大值，问题就解决了。注意因为我们要用上一个阶段的真收益来计算下一个状态的伪收益，因此**在降维优化后**对于每一个物品在处理前要先把 $g$ 数组的值拷贝到 $f$ 数组。

不进行降维优化，时间复杂度是 $O(nm^2)$，会 TLE，因此必须进行降维优化。

## 具体实现
可以开辟两个数组，一个用于计算伪收益，一个用于计算真收益，处理完每个物品再更新真收益的数组。

降维优化后，空间复杂度降到 $O(m)$，时间复杂度降到 $O(nm)$（因为不用枚举 $k$ 了），由于是完全背包，所以体积直接升序枚举即可，注意开 `long long`。

## AC Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans;
int p[5004],t[5004],o[5004];
int f[5004],g[5004];
signed main () {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> p[i] >> t[i] >> o[i];//读入一个处理一个，可以降低代码常数。
		for (int j = 0; j <= m; j++) {
			f[j] = g[j];//拷贝上一阶段的值来计算当前阶段的伪收益。
		}
		for (int j = t[i]; j <= m; j++) {
			f[j] = max(f[j],f[j-t[i]]+o[i]);//计算当前阶段伪收益。
		}
		for (int j = p[i]; j <= m; j++) {
			g[j] = max(g[j],f[j-p[i]]);//对于当前阶段的伪收益再考虑上 p[i] 时，收益才是真收益，然后更新 g 数组。
		}
	}
	for (int i = 0; i <= m; i++) ans = max(g[i],ans);
	cout << ans << '\n';
	return 0;
}
```

## 后记
真的建议做一做 [P2967](https://www.luogu.com.cn/problem/solution/P2967)，做完之后对依赖背包这种依赖物只有代价无收益的情况能更好理解，别看它是个蓝，实际上思维难度并不大。

其实用依赖背包的思路做这个题有点小题大做，因为依赖物和被依赖物是一个物品，因此可以直接用完全背包做，但是拓展一下思路也不错，空间复杂度还会更优。

---

## 作者：chzhh_111 (赞：5)

首先注意到这个学习游戏和玩游戏是分开的，而且我们一定会有如果我们学了这个游戏，那么我们一定要玩这个游戏，否则那它一定就会浪费时间。

普通的背包肯定不行，因为我们无法处理哪些游戏学过这个条件（也有可能是我太菜了），所以说我们就得在原来的背包上改点。

现在可设一个状态为 $dp_{i,j}$，其中的第一维表示时间为 $i$， 第二维表示当前有学过的游戏当中编号最大的是什么。那么我们就可以通过这样子的方式来实现维护哪些游戏曾经学过这个条件。状态转移方程就分为两个部分：

- 第一个部分就是由学习过的游戏编号最大由编号 $0$ 到编号 $i-1$ 这个范围转移到编号 $i$。可是这样子，我们对于每一个时间我们都得去枚举，编号 $0$ 到编号 $i-1$ 的最大值。这样的时间复杂度是 $O(n^3)$。所以我们就可以用一个数组来维护每一个时间编号 $0$ 到编号 $i-1$ 的最大值，这样时间复杂度就优化到 $O(n^2)$。
- 第二个部分就是直接一个完全背包套进去，为 $dp_{time,i} = \max ( dp_{time,i},dp_{time-t_{i},i}+o_{i} ),time \ge p_{i}+t_{i}$。要注意的是，边转移的时候要维护那个最大值数组。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5001;
int n,m,dp[N][N],maxn[N];
struct game{
	int p,t,o;
}g[N];
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld%lld%lld",&g[i].p,&g[i].t,&g[i].o);
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=g[i].p;j--)
		{
			dp[j][i]=maxn[j-g[i].p];
		}
		for(int j=g[i].p+g[i].t;j<=m;j++)
		{
			dp[j][i]=max(dp[j][i],dp[j-g[i].t][i]+g[i].o);
			maxn[j]=max(maxn[j],dp[j][i]);
		}
	}
	int ans=0;
	for(int i=1;i<=m;i++) ans=max(ans,maxn[i]);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Reserved_ (赞：4)

# 前言：
一道背包题，类似完全背包，可以参考[百度百科](https://baike.baidu.com/item/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2416931?fr=ge_ala)。
# 思路：
我们假设一个状态 $dp_{i,j}$ `i`表示时间，`j`表示当前有学过的游戏当中最大编号。再用数组 $k$ 去维护当前最大值。

我们分两种情况，可以推出来 dp 状态方程式为：

第一种：

- $dp_{j,i} \leftarrow k_{j-a_i}$。

第二种：
- $dp_{j,i} \leftarrow \max(dp_{j,i},dp_{j-b_i,i}+c_i)$。
- $k_j \leftarrow \max(k_j,dp_{j,i})$。

最后输出 $k_m$ 即可。
# code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long a[5005],b[5005],c[5005],f[5005][5005],a1[5005],k[5005];
int main()
{
	cin>>n>>m;
	for(long long i=1; i<=n; i++)
	{
		cin>>a[i]>>b[i]>>c[i];
    	a1[i]=a[i]+b[i];
	}
	for(long long i=1; i<=n; i++)
	{
		for(long long j=m; j>=a[i]; j--)
		{
			f[j][i]=k[j-a[i]];
		}
		for(long long j=a1[i]; j<=m; j++)
		{
			f[j][i]=max(f[j][i],f[j-b[i]][i]+c[i]);
			k[j]=max(k[j],f[j][i]);
		}
	}
	cout<<k[m];
	return 0;
}
```

---

## 作者：_xdd_ (赞：2)

如果学了一款游戏就必须要玩这款游戏，不然没有意义。

如果去掉学习这个阶段，那么这道题就是一个完全背包板子题。

所以这道题分两步走，首先设状态 $dp_{i,j}$，$i$ 表示时间，$j$ 表示学过的游戏的最大编号。

接下来分两步：

- 第一步，类似 01 背包，只不过每次枚举是 $\mathcal{O}(n^3)$ 的，可以开一个数组维护每一个时间编号的最大价值，这样时间复杂度就能降至 $\mathcal{O}(n^2)$。
- 第二步，一个完全背包，转移方程很好写，直接看代码吧。

注意不开 `long long` 见祖宗。

### code


```cpp
#include<bits/stdc++.h>
#define endl '\n'
#define maxn 5000+5
#define int long long
using namespace std;
inline int read(){int x=0,f=1;char ch=getchar();while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}return x*f;}
int id[maxn],dp[maxn][maxn],n,m,p[maxn],t[maxn],o[maxn];
signed main(){
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        cin >> p[i] >> t[i] >> o[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=m;j>=p[i];j--){
            dp[j][i]=id[j-p[i]];
        }
        for(int j=p[i]+t[i];j<=m;j++){
            dp[j][i]=max(dp[j][i],dp[j-t[i]][i]+o[i]);
            id[j]=max(id[j],dp[j][i]);
        }
    }
    int ans=0;
    for(int i=1;i<=m;i++){
        ans=max(ans,id[i]);
    }
    cout << ans;
    return 0;
}
```

---

## 作者：wandereman (赞：1)

## 题意
一道很显然的背包问题，更自然地想到用动态规划，又因为可以玩很多次，因此是完全背包，不会的可以看这里。
## 思路
先打出正常模版。
```cpp
for(i = 1;i <= n;i++){
	for(j = v[i];j <= m;j++){
		dp[j] = max(dp[j],f[j - v[i]] + w[i]);
	}
	// v 是价值， w 是重量 
}
```
再切合题目进行改进。
```cpp
for(j = m;j >= p[i];j--){
    dp1[j][i] = dp2[j - p[i]];
}
for(j = l[i];j <= m;j++){
	dp1[j][i] = max(dp1[j][i],dp1[j - t[i]][i] + o[i]);
	dp2[j] = max(dp2[j],dp1[j][i]);
}
```
最后得出以下代码。
## AC code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll p[5005],t[5005],i,j;
ll o[5005],dp1[5005][5005],dp2[5005],l[5005];
int main(){
	ll n,m;
	cin>>n>>m;
	for(i = 1;i <= n;i++){
		cin>>p[i]>>t[i]>>o[i];
		l[i] = p[i] + t[i];
	}
	for(i = 1;i <= n;i++){
		for(j = m;j >= p[i];j--){
			dp1[j][i] = dp2[j - p[i]];
		}
		for(j = l[i];j <= m;j++){
			dp1[j][i] = max(dp1[j][i],dp1[j - t[i]][i] + o[i]);
			dp2[j] = max(dp2[j],dp1[j][i]);
		}
	}
	cout<<dp2[m];
	return 0;
}
```
## 一些注意
十年 OI 一场空，不开 long long 见祖宗。    
[背包问题详解](https://blog.csdn.net/2301_79558858/article/details/137546255?ops_request_misc=%257B%2522request%255Fid%2522%253A%25228d6663638d481f97a519333b27b4dc72%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=8d6663638d481f97a519333b27b4dc72&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-137546255-null-null.142^v100^pc_search_result_base3&utm_term=%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85&spm=1018.2226.3001.4187)

---

## 作者：longyitongxue (赞：1)

这道题明显的背包问题，正解应该用 DP 来做。

可以多次游玩一款游戏，说明这是一个完全背包。

这题的难点是：要学习玩这款游戏，不学就不能玩。

我们要建两个 $dp$ 数组。

我们推出来的状态转移方程为：

- $dp\_1 [j,i] ←dp\_2 [j−p _i]$。
- - -
- $dp \_1
[j,i]
​
 ←\textup{max}(dp \_1
[j,i]
​
 ,dp \_1
[j−t [i]]
​
 ,i
​
 +o [
i]
​
 )$；

- $dp\_2 [
j]
​
 ←\textup{max}(dp\_2 [
j]
​
 ,dp\_1 [j,i]
​
 )$。

最后输出 $dp\_2[m]$。
# 附上 AC 代码

```cpp
#include<iostream>
using namespace std;
long long p[5005],t[5005],o[5005],dp_1[5005][5005],dp_2[5005],lll[5005];
int main()
{
	long long n,m;
	cin>>n>>m;
	for(long long i=1; i<=n; i++)
	{
		cin>>p[i]>>t[i]>>o[i];
		lll[i]=p[i]+t[i];
	}
	for(long long i=1; i<=n; i++)
	{
		for(long long j=m; j>=p[i]; j--)
		{
			dp_1[j][i]=dp_2[j-p[i]];
		}
		for(long long j=lll[i];j<=m;j++){
			dp_1[j][i]=max(dp_1[j][i],dp_1[j-t[i]][i]+o[i]);
			dp_2[j]=max(dp_2[j],dp_1[j][i]);
		}
	}
	cout<<dp_2[m];
	return 0;
}

```
提示一下，不开 long long 见祖宗

* * *

呜呜呜，管理员你就通过一下吧，我改了三次了，第一次是上下标，我改成了中括号，第二次是句号，我加了，第三次是改正 $\LaTeX$ 和有序表无需表，我真想发出去这第一篇题解啊！如果有问题，能一次说完嘛？

---

## 作者：wwppd (赞：1)

## 思路
整体不难，正常的完全背包不同是要算上学习时间，所以要改点，改完点后和正常的完全背包差不多。

改点方法：循环一遍 $1 \sim n$ 。把 $dp$ 数组的下标改到 $j-t$ 即可。
## 代码
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long n , m , sum = 0 , w , v , t , dp[100005] , maxn[100005] ;//定义，sum为最后的答案
int main() 
{
	cin >> n >> m;
	for( int i = 1 ; i <= n ; i ++ )//按照完全背包来做
	{
		cin >> t >> w >> v ;//输入：t为学习时间，w为游玩时间，v为分数
		for( int j = m ; j >= t ; j -- )//改点
		{
			dp[j] = maxn[j-t] ;//把dp数组的下标改到j-t
		}
		for( int j = w + t ; j <= m ; j ++ )
		{
		    dp[j] = max( dp[j] , dp[j-w] + v );//更新dp[]
		    maxn[j] = max( maxn[j] , dp[j] );//记录最大值,存入maxn[]数组
		}
	}
	for(int i = 1 ; i <= m ; i ++ )sum = max( sum , maxn[i] );//找最大值
    cout << sum ;//输出答案
    return 0;
}
```

---

## 作者：Planet_Earth (赞：1)

## 题解：P11430 [COCI 2024/2025 #2] 游戏 / Igre
这道题目可以看作是一个动态规划问题，目标是在给定的时间限制内（包括学习和游戏时间）最大化获得的分数。我们有 $n$ 个游戏，每个游戏需要一定的学习时间 $p_i$，玩一局需要 $t_i$ 分钟，并且可以获得 $o_i$ 分的分数。

#### 代码思路
输入处理：首先读取游戏的数量 $n$ 和可用的总时间 $m$。接着读取每个游戏的学习时间 $p_i$、玩游戏所需时间 $t_i$ 和获得的分数 $o_i$。

动态规划数组：使用一个一维数组 $idx$ 来存储在每个时间点 $j$ 下的最大分数。$dp[j][i]$ 表示在时间 $j$ 内，考虑前 $i$ 个游戏时的最大分数。

#### 状态转移：

对于每个游戏 $i$，首先更新学习时间后的状态。对于每个时间 $j$，如果 $j$ 大于等于学习时间 $p_i$，则可以更新 $dp[j][i]$ 为 $idx[j - p_i]$，表示学习完游戏后可以获得的分数。
然后，考虑在学习后玩游戏的情况。对于每个时间 $j$，如果 $j$ 大于等于学习时间加上玩游戏的时间 $p_i + t_i$，则可以通过玩游戏来更新分数，使用 $dp[j - t_i][i] + o_i$ 来计算。
结果计算：最后，遍历 $idx$ 数组，找到在时间限制 $m$ 内的最大分数，并输出结果。

这种方法有效地利用了动态规划的思想，通过状态转移来逐步构建出最优解，确保在时间限制内获得最大分数。整体时间复杂度为 $O(n * m)$，适合给定的输入范围。

#### AC代码

```cpp
#include<bits/stdc++.h>
#define N 5010
#define int long long
using namespace std;
int read(){
    int x=0,f=1;
  	char ch=getchar_unlocked();
	  while(!isdigit(ch)){
		    if(ch=='-') f=-1;
		    ch=getchar_unlocked();
	  }
	  while(isdigit(ch)){
		    x=(x<<1)+(x<<3)+(ch^48);
		    ch=getchar_unlocked();
  	}
	  return x*f;
}
void write(int x){
  	if(x<0){
	    	putchar('-');
		    x=-x;
	  }
  	if(x>9) write(x/10);
  	putchar(x%10+'0');
}
int n,m,idx[N],dp[N][N],qwq[N],times[N],op[N];
signed main(){
    cin >> n >> m;
    for(int i=1;i<=n;i++){
        cin >> qwq[i] >> times[i] >> op[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=m;j>=qwq[i];j--){
            dp[j][i]=idx[j-qwq[i]];
        }
        for(int j=qwq[i]+times[i];j<=m;j++){
            dp[j][i]=max(dp[j][i],dp[j-times[i]][i]+op[i]);
            idx[j]=max(idx[j],dp[j][i]);
        }
    }
    int ans=0;
    for(int i=1;i<=m;i++){
        ans=max(ans,idx[i]);
    }
    write(ans);
    return 0;
}
//Planet_Earth 澜煋
```

---

## 作者：signed_long_long (赞：1)

# 题目解法

$f_{j,i}$ 表示前 $i$ 个游戏过了 $j$ 分钟能得到的最大得分。


对于状态转移：

- 不选第 $i$ 个游戏：$dp_{j,i}=dp_{j,i-1}$。

- 选第 $i$ 个游戏：首先，要保证能学习并玩至少一次该游戏（$p_i+t_i\le j$），然后 $dp_{j,i}=\max(dp_{j,i},dp_{j-t_i,i}+o_i)$。

但是每次都求最大值很费时间，时间复杂度能达到立方级别，所以要用数组存储一下在第 $j$ 分钟能得到的最大时间。

最后，**十年 OI 一场空，不开 long long 见祖宗**！

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,p[5050],t[5050],o[5050],f[5050][5050],maxn[5050];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>p[i]>>t[i]>>o[i];
	}
	for(int i=1;i<=n;i++){
		for(int j=m;j>=p[i];j--){
			f[j][i]=maxn[j-p[i]];
		}
		for(int j=p[i]+t[i];j<=m;j++){
			f[j][i]=max(f[j][i],f[j-t[i]][i]+o[i]);
			maxn[j]=max(maxn[j],f[j][i]);
		}
	}
	int ans=-1;
	for(int i=1;i<=m;i++) {
		ans=max(ans,maxn[i]);
	}
	printf("%lld\n",ans);
	return 0;
} 
```

---

## 作者：Like_Amao (赞：1)

**分析**

经观察，因为每个游戏可以**重复学习和游玩**，所以可以断定此题为**完全背包问题**。

**思路**

我们可以用数组 $a$ 来表示每个游戏的学习时间，用数组 $b$ 来表示每个游戏的游玩时间，用数组 $c$ 来表示每个游戏的价值，因此，我们可以用一个 $w$ 数组来表示 $a$ 和 $b$ 的和，简单点来讲就是背包模板里面的花费，用循环变量 $i$ 来表示游戏的编号，用循环变量 $j$ 来枚举价值，用 $dp _ {j,i}$ 来递推，再利用数组 $k$ 来维护 $dp$ 数组的最大性，然后即可推出递推式：

$dp _ {j,i}=k _ {j-a_i}$

与

$dp _ {j,i}=\max(dp _ {j,i},dp _ {j-b _ i,i}+c _ i)$

$k _ j=\max(k _ j,dp _ {j,i})$。

最后输出 $k _ m$ 即可。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[5001],b[5001],c[5001],k[5001],dp[5001][5001],w[5001];
int main()
{
	long long n,m;
	cin>>n>>m;
	for(long long i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i]>>c[i];
		w[i]=a[i]+b[i];
	}
	for(long long i=1;i<=n;i++)
	{
		for(long long j=m;j>=a[i];j--)
		{
			dp[j][i]=k[j-a[i]];
		}
		for(long long j=w[i];j<=m;j++)
		{
			dp[j][i]=max(dp[j][i],dp[j-b[i]][i]+c[i]);
			k[j]=max(k[j],dp[j][i]);
		}
	}
	cout<<k[m];
	return 0;
}
```

---

## 作者：_ayaka_ (赞：0)

### 思路
从性质入手。

性质 A 很明显是一个板的多重背包，而棘手的就是 $p_i$ 了。因此，方向往多重背包走。

可以考虑到，每次多重背包是一个一个增加可选的物品，那么这一个循环里，只要改变 $ans$ 的值，那么一定会花学游戏的时间。那么就可以建立一个临时数组 $dp$，使得 $dp_i=ans_{j-p_i}$，接着多重背包的操作对 $dp$ 整，最后两者取 $\max$ 就行了。

然后就没了，复杂度 $O(nm)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,p[10005],t[10005],o[10005],dp[10005],ans[10005],cot; 
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>p[i]>>t[i]>>o[i];
	for(int i=1;i<=n;i++){
		for(int j=p[i];j<=m;j++) dp[j]=ans[j-p[i]];
		for(int j=t[i]+p[i];j<=m;j++){
			dp[j]=max(dp[j],dp[j-t[i]]+o[i]);
			ans[j]=max(ans[j],dp[j]);
		}
	}
	for(int i=1;i<=m;i++) cot=max(cot,ans[i]);//统计最大值 
	cout<<cot;
	return 0;
}

```

---


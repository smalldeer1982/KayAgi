# 积木城堡

## 题目描述

XC 的儿子小 XC 最喜欢玩的游戏用积木垒漂亮的城堡。城堡是用一些立方体的积木垒成的，城堡的每一层是一块积木。  

小 XC 是一个比他爸爸 XC 还聪明的孩子，他发现垒城堡的时候，如果下面的积木比上面的积木大，那么城堡便不容易倒。所以他在垒城堡的时候总是遵循这样的规则。

小 XC 想把自己垒的城堡送给幼儿园里漂亮的女孩子们，这样可以增加他的好感度。为了公平起见，他决定送给每个女孩子一样高的城堡，这样可以避免女孩子们为了获得更漂亮的城堡而引起争执。  

可是他发现自己在垒城堡的时候并没有预先考虑到这一点。所以他现在要改造城堡。由于他没有多余的积木了，他灵机一动，想出了一个巧妙的改造方案。他决定从每一个城堡中挪去一些积木，使得最终每座城堡都一样高。为了使他的城堡更雄伟，他觉得应该使最后的城堡都尽可能的高。

任务：

请你帮助小 XC 编一个程序，根据他垒的所有城堡的信息，决定应该移去哪些积木才能获得最佳的效果。

注意：一座城堡的高度，是组成它的所有积木的棱长之和。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 100$，一座城堡中的积木不超过 $100$ 块，每块积木的棱长不超过 $100$。

## 样例 #1

### 输入

```
2
2 1 -1
3 2 1 -1
```

### 输出

```
3
```

# 题解

## 作者：Dispwnl (赞：59)

求出最大高度

从最大高度~1枚举

如果能恰好达到这个高度（即用它有的积木恰好能拼出）有n个城堡

就输出这个高度

每输入一组数据

一遍01背包，拼出一个高度，这个高度城堡个数++



都没有就输出0

```cpp
# include<iostream>
# include<cstring>
using namespace std;
int n,maxn,x,g,sum;
int a[1001],ans[100001];
bool f[100001];
int main()
{
    cin>>n;
    for(int k=1;k<=n;k++)
      {
          memset(f,0,sizeof(f));
        int g=0,sum=0;
          while(1)
          {
              cin>>x;
              if(x<0) break;
              a[++g]=x;
              sum+=x;
        }
        f[0]=1;
        a[0]=g;
        if(sum>maxn) maxn=sum;
        for(int i=1;i<=g;i++)
          {
              for(int j=sum;j>=a[i];j--)
              if(f[j-a[i]]&&!f[j])
              f[j]=1,ans[j]++;
          }
      }
    for(int i=maxn;i>=0;i--)
      {
        if(ans[i]==n)
        {
            cout<<i;
            return 0;
        }
      }
    cout<<0;
    return 0;
}

```

---

## 作者：Dw_hans (赞：46)

~~这是我第一篇题解~~~

博客食用更佳~

**这道题可以用$DP$（动态规划）来做~**

**DP必备三步：**
- $状态表示$
- $动态转移$
- $初始状态$

## 开始吧！$~~~~~$我们可以先只考虑单独城堡$~k~$~~

------------

### $First~~状态表示$

- $dp[i][j]~$表示用前$~i~$块积木能否达到高度$~j~$


------------


### $Next ~~动态转移$

-  不选第$~i~$块积木 $dp[i][j] = dp[i-1][j]$

-  选第$~i~$块积木 $dp[i][j] = dp[i-1][j-w[i]]$

**倒叙降维,用$~|=~$连接$~~$得：**

- $dp[j] ~~|= ~~dp[j-w[i]]$


------------


### $Last ~~初始状态$

很简单~

不搭积木肯定行呀！

- $dp[0] = 1$


------------
## 用代码呈现~

```cpp
#include <bits/stdc++.h> //万能头
using namespace std;

int n,len,min_high = 2e9,w[105],ans[10005];
// w数组为每一城堡积木的高度 ans数组为达到高度i的个数
bool dp[10005];
// Dp嘛
int main() {
    cin >> n; //n个城堡
    for(int k=1;k<=n;k++)// 每一个城堡
    {
        //memset(w,0,sizeof(w)); // 其实不用
        memset(dp,0,sizeof(dp)); // 以免前一个影响当前城堡
        int cnt = 0,high = 0; //cnt为积木个数，high为高度~
        while(1)
        {
            cin >> len; //输入len
            if(len == -1) break; // 输入完了~
            w[++cnt] = len; // 存高度~
            high += len; // 算高度~
        }
        // 开始DP！
        dp[0] = 1; // 初始状态
        for(int i=1;i<=cnt;i++)// 物品维（cnt个积木）
            for(int j=high;j>=w[i];j--)// 容量~倒叙枚举压物品维 枚举到物品大小
                dp[j] |= dp[j-w[i]]; //动态转移方程
        min_high = min(min_high,high); // 最小值~
        for(int i = high;i>=1;i--) // 检查一下能否达到高度
            if(dp[i] == 1) ans[i]++;// 加到ans数组~
    }
    for(int i = min_high;i>=1;i--)// 看看那个高度可以所有达到！
        if(ans[i] == n)
        {
            cout << i;// 输出
            return 0;
        }
    cout << "0";//没有，输出0
    return 0;
}
```
PS:代码两重循环，看范围，不会$TLE$的~

---

## 作者：AgrumeStly (赞：26)

## 大家好，
欢迎回到_TNT_BOOM大讲堂！

今天我们讲$P1504!$
首先我们理下思路

这提示01背包（$DP$)

如何判断要拆走那个积木，首先定义一个$ans$数组，来存放这对积木能拼成多高的，然后如果$ans_i = n$那么就说明这个高度的积木可以。

#### 话不多说，上代码！
```cpp
#include<cstdio> //从最小高度~1枚举, 如果能恰好达到这个高度（即用它有的积木恰好能拼出）有n个城堡
#include<cstring>
#include<algorithm>
using namespace std;

int n, len, min_high = 2e9;
//n表示城堡数,len表示每块立方体积木的棱长, min_high表示所有城堡初始高度最小值 
int w[10005],ans[10005]; //设ans[i]表示i能被多少组w[1..n]凑成，当dp[i]==true时，ans[i]++
//w[i]表示组成这座城堡的第i块积木的棱长 
bool dp[10005]; //dp[i]表示能否使用当前的w[1..n]相加得到i
/* 有n件物品(积木)，每件物品体积(积木的棱长)为w[i], 价值(积木的棱长)为w[i]。
有容量(城堡高度)为 V 的背包(城堡)。求在容量(城堡高度)允许的范围下，背包装入物品的价值和(积木的棱长和)有哪些可能值。*/ 


int main()
{
	scanf("%d", &n);
	for(int k = 1; k <= n; k++)
	{
		memset(dp, 0, sizeof(dp));
		int cnt = 1, high = 0; //cnt表示每座城堡含积木的块数，high表示每座城堡的初始高度 
		while(1)
		{
			scanf("%d", &w[cnt]); //len表示组成这座城堡的每块积木的棱长
			if(w[cnt] == -1) break;
			high += w[cnt];
			cnt++;
		}
		dp[0] = 1; // dp[0] = 1表示能使用当前的w[1..n]相加得到高度0
		min_high = min(min_high, high); //求出所有城堡初始高度最小值 
        for(int i = 1; i < cnt; i++) //对每座城堡从1~g去枚举每一块积木 
			for(int j = high; j >= w[i]; j--)
				dp[j] = dp[j] || dp[j-w[i]]; //01背包变形，即动态转移方程
		for(int i = high; i >= 1; i--)
        	if(dp[i] == true) ans[i]++; //统计高度i出现次数
	}
    for(int i = min_high; i >= 1; i--) //从最小高度~1枚举
		if(ans[i] == n) //如果能恰好达到这个高度（即用它有的积木恰好能拼出）有n个城堡
		{
			printf("%d\n", i);  
			return 0;
		}
	printf("0\n");
    
	return 0;
}
```

$Bye Bye!$



---

## 作者：18lxxrz (赞：14)

这道题属于暴力求解，当时我也是模拟了好多次，才过样例的，以下是代码，大家可以看看，了解下思路。

解释不到位，还请大家见谅

------------

```cpp
#include<bits/stdc++.h>
using namespace std;

bool s[101][10001]; //s数组用于存储记录该高度能否搭建 ;
int max,maxi;

int main ()
{
    int n;
    int h;
    scanf("%d",&n); //读入n;
	 
    for(register int i=1;i<=n;++i) //register ,++i 优化循环 ;
    {
        s[i][0]=1; // 记录 ;
        while(cin>>h&&h!=-1)  
        {
            for(register int j=10000;j>=0;--j)
              	if(s[i][j]==1) s[i][j+h]=1;
        }
    }
    
    for(register int j=5052;j>=1;--j)//暴力求解 ;
    {
      	maxi=0;
      	for(int i=1;i<=n;i++)
      	{
        	if(s[i][j]==1)
          		maxi++;
        	if(maxi==n)
        	{
          		cout<<j<<endl;
          		return 0;
        	}
      	}
    }
   	puts("0");//无解输出"0"; 
    return 0;
}
```


---

## 作者：早右昕 (赞：10)

####**降维,再降维**(题解By Plue Jheng/InfoEoR)

#####解释请看main函数**QAQ**

```cpp
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
int n,a[1001],num,sum,maxn;
int tot[100010],dp[100010];
int main() {
    /*
    其实思路很简单的,对每个城堡进行一次01背包,并统计
    每个城堡可以堆叠的高度,将其累加与tot,最后从大到小
    查看tot[i]的值是否为n(即每个城堡都能堆叠到这个高度)
    输出即可. 
    */
    scanf("%d",&n);
    for(register int p=1; p<=n; p++) {
        memset(a,0,sizeof a);//降维 
        memset(dp,0,sizeof dp);
        num=sum=0;
        dp[0]=1;
        while(scanf("%d",&a[++num]) && a[num]!=-1) {
            sum+=a[num];
        }
        maxn=max(maxn,sum),num--;
        for(int i=1; i<=num; i++) {//01背包 
            for(int j=sum; j>=a[i]; j--) {
                if(!dp[j]&&dp[j-a[i]]) {
                    dp[j]=1;
                    tot[j]++;
                }
            }
        }
    }
    maxn++;//细节需注意 
    while(--maxn) if(tot[maxn]==n) break;
    printf("%d\n",maxn);
    return 0;
}
```

---

## 作者：小柯 (赞：10)

# 思路

$\texttt{求出每个城堡所能到达的所有高度，并找到所有城堡都能拼出的最大高度。}$

$\texttt{这时就可以用到哈希表，存下每一个城堡都能拼出的高度。}$

$\texttt{因为是所有城堡都要有，所以可以用}$
$bool$
$\texttt{型的数组。}$

$\texttt{这道题就可以用}$
$bitset$
$\texttt{水过去了。}$

$\texttt{不明白的可以看看：}$

1.[相似题题解](https://www.luogu.org/problemnew/solution/P2347)

2.[百度百科](https://baike.so.com/doc/2300648-2433736.html)

# 代码

```cpp
#include<iostream>
#include<bitset>//bitset的头文件
using namespace std;
int n,a;
bitset<10005>x;
bitset<10005>ans;
int main(){
	ans.set();//全变成1
	cin>>n;
	for(int i=1;i<=n;i++){
		x.reset();//全变成0
		x[0]=1;
		cin>>a;
		while(a!=-1){
			x|=x<<a;//bitset可以进行位运算
			cin>>a;
		}
		ans&=x;
	}
	for(int i=10000;i>=0;i--){
		if(ans[i]){
			cout<<i<<endl;
			return 0;
		}
	}
    return 0;
}
```


---

## 作者：WZKQWQ (赞：7)

### STLnb，世界属于蒟蒻

楼下没有蒟蒻看的懂的题解嘤嘤嘤。

为了洛谷蒟蒻们的利益（虽然我是最弱的）。

特地来写一篇 QWQ。

------------

回归正题：

俗话说的好，STL 小汉堡，一天三题水的好。

我用的是 STL 里的 $bitset$。

这个 $bitset$ 他能干什么呢。

他 nb 大了，他可以模拟一个二进制数。

可以对这个数进行位运算，还可以和数组一样访问。

而且 $bitset$ 快(38ms 卡入线)。

这题的思路是记录一个数组（这里和后面的数组都指  $bitset$）。

$num[x] = 1$ 代表积木可以拼出 x 这个数。

然后每次：

```cpp
ans &= num
```

这句话让 ans 等于 num 和 ans 都可以拼出的数的集合。

ans 是答案数组。

最后从大往小，如果 $ans[i] == 1$。

那么输出 $i$ 再 $return$。

现在难点在怎么算 num 数组。

其实

```cpp
num |= (num << a);
```

就好了。

假如现在可以拼出 0，1，3 现在来个 4。

$num << a$ 就是把每一个可以拼出的数 $+a$。

$|=$ 就是把它和原数组合并。

其他就是细节了。

AC 代码完结撒花:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10005;
int n,a;
bitset <N> ans,num;
int main(){
    scanf("%d",&n);
    ans.set();//把ans全置为1
    for(int i = 1;i <= n;i++){
        num.reset();//清空num数组
        num.set(0);//注意，一定可以拼出0，这里把0位置为1
        scanf("%d",&a);
        while(a > 0){
            num |= (num << a);
            scanf("%d",&a);
        }
        ans &= num;
    }
    for(int i = 10000;i >= 0;i--) if(ans[i]){
        printf("%d\n",i);
        return 0;
    }
    return 0;
}
```


---

## 作者：revenger (赞：7)

看了一下下面一堆P的题解 来一发C++的

装箱问题升级版

每次读入一组积木 就做一遍装箱 然后如果某个高度能达到 就在数组里对应的位置加1

做n遍背包以后 从最大高度开始倒序枚举 如果枚举到一个高度 能达到的积木组数是n的话 直接输出结束

最后别忘了输出0(在第八个点上被卡了 一直提示too many or too few lines)

不记录最大高度的话倒序枚举的时候就从10000开始枚举 不过能节省的效率还是节省吧 这么暴力的方式

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int high[10005],v[10005],n,ni,sum,maxsum,a[10005]; 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        ni=1;
        sum=0;
        scanf("%d",&a[ni]);
        sum+=a[ni];
        while(a[ni]!=-1)
        {
            ni++;
            scanf("%d",&a[ni]);
            sum+=a[ni];
        }
        ni--;
        sum++;
        if(sum>maxsum)
        maxsum=sum;
        for(int j=1;j<=sum;j++)
        v[j]=0;
        v[0]=1;
        for(int j=1;j<=ni;j++)
        for(int k=sum;k>=a[j];k--)
        if(!v[k]&&v[k-a[j]])
        {
            v[k]=1;
            high[k]++;
        }
    }
    for(int i=maxsum;i>=1;i--)
    if(high[i]==n)
    {
        printf("%d",i);
        return 0;
    }
    printf("0");
}
```

---

## 作者：午尘 (赞：4)

这题的话，我用的是背包的思路qwq……



------------


**首先是读入……**

以-1结束告诉我们，输入的数据个数是不确定的，只能边读边判……

```cpp
for (i=1;i<=n;i++){
		scanf("%d",&x);j=0;
		while (x!=-1){
			j++;
			h[i][j]=x;
			sum[i]+=x;
			scanf("%d",&x);
		}
		tot[i]=j;
	}
```

就是这样啦！

```cpp
//tot[i] 表示第i个城堡有几块积木，
//sum[i]表示第i个城堡的积木总高度。
```




------------

**然后就是背包部分啦！！**

```cpp
//a[k][i]表示第k个城堡能否被拿走i块积木
```



------------

**最后是输出！！**

遍历城堡的高度，从大到小，遇到合适的就退出。

```cpp
for (j=sumin;j>0;j--){  //the height of the castle
		if (tf) break;
		qwq=1;
		for (i=1;i<=n;i++){  //the number of the castle
			if (a[i][sum[i]-j]==0) qwq=0;
		}
		if (qwq) {
		    tf=1;
		    printf("%d\n",j);
		    break;
	}
```

```cpp
//a[i][sum[i]-j]就是表示第i座城堡如果要保持j的高度要拿走的积木数是否可行啦！！

```


------------


放代码啦~

```cpp
#include <bits/stdc++.h>
using namespace std;
bool a[101][10001],tf,qwq;
int h[101][101],tot[101],sum[101],x,i,j,k;
int sumin,n,m,s,ans,t;
int main(){
	scanf("%d",&n);
	for (i=1;i<=n;i++){
		scanf("%d",&x);j=0;
		while (x!=-1){
			j++;
			h[i][j]=x;
			sum[i]+=x;
			scanf("%d",&x);
		}
		tot[i]=j;
	}
	sumin=1000000000;
	for (i=1;i<=n;i++)  sumin=min(sum[i],sumin);
	for (k=1;k<=n;k++){  //castle  k
        a[k][0]=1;
		for (i=1;i<=tot[k];i++)  //toy i
		  for (j=sum[k];j>=h[k][i];j--)
		   a[k][j]=a[k][j]|a[k][j-h[k][i]];
	}
	tf=0;
	for (j=sumin;j>0;j--){  //the height of the castle
		if (tf) break;
		qwq=1;
		for (i=1;i<=n;i++){  //the number of the castle
			if (a[i][sum[i]-j]==0) qwq=0;
		}
		if (qwq) {
		    tf=1;
		    printf("%d\n",j);
		    break;
	}
   }  
    if (!tf) cout<<0<<endl;
	return 0;
}


```


---

## 作者：伟大的王夫子 (赞：3)

如果想要更好的体验，可以到[我的博客](https://www.luogu.org/blog/I-AK-IOI/)去看

lj DP题害我调试了一个小时。（~~正是因为数组越界，没有开$10^4$!~~）

其实就用背包问题的状态转移方程就可以了

记得积木高度那维要开$10^4(100 \times 100)$

设布尔数组$f$为表示当前第$i$组的DP数组，$f[k]$表示总高度为$k$是否可行

运用状态转移方程

$\forall k \in [a[i][j], s[i]], f[k] \ne 1 $

$f[k] = f[k - a[i][j]] $

其中$j$表示第$j$个元素, $s[i]$表示第$i$组所有元素的和

最后进行统计即可

最后倒序枚举$i \in [0, \min\limits_{1 \le j \le n} s_j]$发现有一个可行即输出

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110][110], s[110], val = 1e9;
int n;
bool f[10010];
int cnt[10010];
int main() {
	cin >> n;
	memset(f, 0, sizeof f);
	memset(cnt, 0, sizeof cnt);
	for (register int i = 1; i <= n; ++i) {
		int x;
		while (cin >> x && x != -1) 
			a[i][++a[i][0]] = x, s[i] += x;
		val = min(val, s[i]);
		memset(f, 0, sizeof f);
		f[0] = 1;
		for (register int j = 1; j <= a[i][0]; ++j)
			for (register int k = s[i]; k >= a[i][j]; --k)	
				f[k] |= f[k - a[i][j]];
				
		for (register int j = 0; j <= s[i]; ++j) {
			cnt[j] += f[j];//进行统计，看看j这个策略是否每一组都可行 
		}
	}
	for (register int i = val; ~i; --i) {
		if (cnt[i] == n) {
			cout << i;
			return 0;
		}
	}
}


```

---

## 作者：0x80mem (赞：3)

看到大佬们都是用背包写的，才发现背包可以这样用. . .

整体思路很简单，就是得到一个城堡所有高度，然后将这些高度记一下数。

与背包略微不同的是得到高度的方法。

**在这里使用了一个临时数组，每加一块积木将数组中的数全部取出，加上积木棱长，如果与原数组不重复，就放回去。**

实现时使用了vector类，只是因为某些原因（比较懒）。

代码如下：
```cpp
#include <cstdio>
#include <cstring>
#include <vector>

#define maxn 10005

using namespace std;

int N; 
int F[maxn];
int M[maxn];
vector<int> vec;

int main()
{
    scanf("%d", &N);
    for (int i = 1; i <= N; i++)
    {
        vec.clear(); vec.push_back(0);
        memset(M, 0, sizeof(M));
        
        int h; scanf("%d", &h);
        for (; ~h; scanf("%d", &h))
        {
            int size = vec.size();
            for (int i = 0; i < size; i++)
                if (!M[vec[i] + h])
                {
                    vec.push_back(vec[i] + h);
                    M[vec[i] + h] = 1;
                }
        }
        for (int i = 0; i < vec.size(); i++)
            F[vec[i]]++;
    }
    int i;
    for (i = maxn; F[i] != N; i--){}
    printf("%d\n", i);
    return 0;
} 
```

---

## 作者：飞翔 (赞：3)

```cpp
var
  f,g:array[0..20000] of integer;
  i,j,n,s,h,min:longint;
begin
  readln(n);
  min:=maxlongint;
  fillchar(g,sizeof(g),0);
  for i:=1 to n do
  begin
    fillchar(f,sizeof(f),0);
      f[0]:=1;
    h:=0;
        read(s);
    while s<>-1 do
    begin
      for j:=h downto 0 do       //注意如果是for j:=0 to h do就错了
        if (f[j]=1)and(f[j+s]=0) then
                begin
                  f[j+s]:=1;
                    inc(g[j+s]);
                end;
            h:=h+s;
      read(s);
    end;
    if h<min then min:=h;
  end;
  for i:=min downto 1 do
    if g[i]=n then begin write(i);halt;end;
  write(0);
end.
一种类似于打标记的算法，不过用背包算法写程序
```

---

## 作者：Memorize (赞：3)

建议可以先看一下装箱问题在做这道题 这道题大概是装箱问题的升级版

其实塔好积木在拿走就相当于当初搭的时候没选拿走的积木。这样一转化思维问题就清楚了。把积木可搭建的最大高度看做背包的载重，每块积木的高度就是物品的重量。也就是用给定的物品装指定的包，使每个包装的物品一样多，且在符合条件的前提下尽量多。（转载于动态规划化教程）


```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
using namespace std;
int n;
bool dp[110][10010];
int ans[10010];
int h[110][110];
int sum[110],tot[110];
int maxn=-1;
int main()
{
    memset(dp,false,sizeof(dp));
    memset(sum,0,sizeof(sum));
    memset(tot,0,sizeof(tot));
    memset(ans,0,sizeof(ans));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
      int x;dp[i][0]=true;ans[0]=n;
      scanf("%d",&x);
      while(1)
      {
          if(x==-1) break;
          h[i][++sum[i]]=x;tot[i]+=x;
          scanf("%d",&x);
      }
      maxn=max(maxn,tot[i]);
    }
    for(int i=1;i<=n;i++)
     for(int j=1;j<=sum[i];j++)
      for(int k=tot[i];k>=1;k--)
       if(k-h[i][j]>=0&&dp[i][k-h[i][j]]&&!dp[i][k]) dp[i][k]=true,ans[k]++; 
    for(int i=maxn;i>=0;i--) if(ans[i]==n) printf("%d",i),exit(0); 
    return 0;
}
```

---

## 作者：lych (赞：1)

总的来说不算太难，就是数据卡的比较紧。

首先需要装箱算法，求出每一座城堡所能够达到的所有高度。其次在从大到小枚举所有的高度，一旦找到就立即退出，节约时间。

具体思路见程序：

```cpp
var
  i,n,m,j,x,min:longint;
  f:array[1..100,0..10000] of boolean;
function ok(x:longint):boolean;
var i:longint;
begin
  for i:=1 to n do
    if not f[i,x] then exit(false);
  exit(true);
end;//表示能否搭成N个高为x的城堡
begin
  readln(n);
  min:=maxlongint;//表示N座城堡的最大高度
  for i:=1 to n do
    begin
      read(x);
      m:=x;
      f[i,0]:=true;//定义边界，高度为0是可以达成的
      while x<>-1 do
        begin
          for j:=m downto x do
            f[i,j]:=f[i,j] or f[i,j-x];//如果可以搭成，赋为true
          read(x);
          m:=m+x;
        end;//装箱问题
      if m+1<max then max:=m+1;//需要用+1，因为读入时多减了1
      readln;
    end;
  for i:=min downto 0 do//枚举所有可能的高度
    if ok(i) then begin writeln(i); halt; end;//找到就退出，避免做重复
end.
```

---

## 作者：RedreamMer (赞：1)

# P1504题解
算法：01背包（$DP$）

思路：思路很简单，将每组读入的时候，对这组数据进行背包操作，求出这组数据能够达到的范围

创建一个 $bool$ 数组 $dp[i][j]$ ，定义为第 $i$ 组数据是否能达到高度 $j$ ，则很容易推得状态转移方程：

```cpp
dp[i][j]=dp[i][j]|dp[i][j-v[k]];//v[k]为这组数中第k个数
```

然后也就轻而易举地写出程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,mx,mxx;
int v[101],V;
bool s[101][10001],p=1;
int main() {
	cin>>a;
	for(int i=1; i<=a; i++)
		s[i][0]=1;
	for(int i=1; i<=a; i++) {
		int j=0;
		while(cin>>V) {//读入操作
			if(V==-1)
				break;
			v[++j]=V;
			mx+=v[j];//总体积为这组数据所有数的和
		}
		for(int k=1; k<=j; k++)
			for(int l=mx; l>=v[k]; l--)
				s[i][l]=s[i][l-v[k]]|s[i][l];//状态转移方程
		mxx=max(mxx,mx);
		mx=0;
	}
	for(int i=mxx; i>=0; i--) {
		for(int j=1; j<=a; j++)
			if(!s[j][i]) {
				p=0;
				break;
			}
		if(p) {//找到一个各组数据都可以达到的高度，输出
			cout<<i;
			exit(0);
		}
		p=1;
	}
	return 0;//结束，本蒟蒻献丑了
}
```
心得：这类题为背包的变形题，只要找到题目中所给的线索得到状态转移方程，就可以轻松AC了

---

## 作者：HPXXZYY (赞：0)

[题目链接](https://www.luogu.org/problemnew/show/P1504)

设f[i]表示能否使用当前的a[1..n]相加得到i，设t[i]表示i能被**多少**组a[1..n]凑成，很明显，当f[i]==true时，t[i]++

首先，对每一组数据进行**01背包变形**，即f[j]=f[j]||f[j-a[i]]，其中j满足j>=a[i]。

然后，枚举**每一个**有可能的解，当f[i]==true时，令t[i]++（有可能的解（计为sum[i]）的范围：1到∑a[i]，其中1<=i<=n）

最后，**从大到小**枚举每一个可行解（范围：1到min(sum[i])），若t[i]==总组数，则i为最大解，输出

[代码评测记录：](https://www.luogu.org/recordnew/show/15903951)

耗时/内存：402ms, 908KB

语言/长度：C++，0.66KB

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int t[10100],n,a[105],i,j,k,v;
bool f[10100];int ans,sum;
int main(){
    scanf("%d",&n);//n表示有几组数据
    ans=0x7FffFFff;
    //0x7fffffff即2147483647
    for(k=1;k<=n;k++){
        sum=0;v=0;
        while (scanf("%d",&a[++v])){
            if (a[v]==-1) break;
            sum+=a[v];
        }
        //输入a[1..v]
        --v;f[0]=true;
        //注意a[v]=-1!!!
        fill(f+1,f+sum+1,false);
        //fill函数作用：把f[1]到f[n]赋值为false
        for(i=1;i<=v;i++)
        for(j=sum;j>=a[i];j--)
        f[j]=f[j]||f[j-a[i]];
        //01背包变形，即动态转移方程
        for(i=sum;i>=0;i--)
        if (f[i]) t[i]++;
        //统计i出现次数
        ans=min(ans,sum);
        //更新可行解范围
    }
    for(i=ans;i>=0;i--)
    if (t[i]==n){
        printf("%d",i);
        return 0;
    }
    //一定要从大到小循环！！！
}
```

或许，有人会问输出为0呢？其实f[0]一直等于true，在统计i出现次数时t[0]++，最后t[0]肯定等于n，所以会输出0，但注意i一定要≥0，否则，就循环不到0

---


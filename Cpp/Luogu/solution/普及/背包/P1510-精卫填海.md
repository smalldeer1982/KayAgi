# 精卫填海

## 题目描述

本题为改编题。

> 发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》

精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？

事实上，东海未填平的区域还需要至少体积为 $v$ 的木石才可以填平，而西山上的木石还剩下 $n$ 块，每块的体积和把它衔到东海需要的体力分别为 $k$ 和 $m$。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为 $c$。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$0<n \le 50$；
- 对于 $50\%$ 的数据，$0<n \le 1000$；
- 对于 $100\%$ 的数据，$0<n \le 10^4$，所有读入的数均属于 $[0,10^4]$，最后答案不大于 $c$。


## 样例 #1

### 输入

```
100 2 10
50 5
50 5```

### 输出

```
0```

## 样例 #2

### 输入

```
10 2 1
50 5
10 2```

### 输出

```
Impossible```

# 题解

## 作者：Jason_Lee (赞：411)

## QAQ蒟蒻红名后第一篇题解吼吼吼
（以前的都没有过）

 哭辽
 
 
 身为蒟蒻的我 看到这道题就笑了 这不就是个01背包吗 哈哈哈  又可以水题了
 
 十分钟后。。。算了 先玩会吧 这题不简单
 
 对 就是 这题不简单 乍一看是一道水题 实际上暗藏杀气QAQ
 
 
 # 不扯了 进入正题
 
####  这道的的确确是一道01背包 还是道不错的练手题
 
 首先 此题有三个量 我们需要先理清他们之间的关系
 
 ```cpp
int vn,n,c,sum;//vn：need—v（所需总体积） n：石子个数 c：总体力 
int v[MAXN],w[MAXN],f[MAXN];//v：石子体积 w：所需体力 
```

大致的都写出来了 然后看数据范围 <=10000  QAQ 有点大
来波快读

```
inline int read(){//（推销一波）如老衲所见 必有大数据 所以还是有必要来个快读优化的QAQ 
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {if(ch=='-')f=-1; ch=getchar();}
    while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0'; ch=getchar();}
    return x*f;
}
```

然后就该开始无尽的思索了 这题的状态转移方程是什么？

本蒟蒻的思路是将体力看做背包 将石子看做物品 然后就很自然地得出了本题的状态转移方程：

## f[j]=max(f[j],f[j-w[i]]+v[i])

然后就是蒟蒻的代码了（码丑勿批QAQ）

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define int long long
#define MAXN 10000+3
using namespace std;

inline int read(){//（推销一波）如老衲所见 必有大数据 所以还是有必要来个快读优化的QAQ 
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {if(ch=='-')f=-1; ch=getchar();}
    while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0'; ch=getchar();}
    return x*f;
}

int vn,n,c,sum;//vn：need—v（所需总体积） n：石子个数 c：总体力 
int v[MAXN],w[MAXN],f[MAXN];//v：石子体积 w：所需体力  

signed main()
{
	vn=read(),n=read(),c=read();
	for(int i=1;i<=n;i++){
		v[i]=read(),w[i]=read();
//		cout<<v[i]<<" "<<w[i]<<endl;
		sum+=v[i];
//		cout<<sum<<endl;
	}
	if(sum<vn){//若石子总体积<vn，直接输出Impossible （特判一波）
		cout<<"Impossible"<<endl;
		return 0;
	}
//	cout<<"ha"<<endl;静态测试 检查代码在哪里出的锅QAQ 
	for(int i=1;i<=n;i++){
		for(int j=c;j>=w[i];j--){
			f[j]=max(f[j],f[j-w[i]]+v[i]);
		}
	}
	for(int i=0;i<=vn;i++){//从小到大搜 第一个大于vn的直接输出
		if(f[i]>=vn){
			cout<<c-i<<endl;
			return 0;
		}
	}
	cout<<"Impossible"<<endl;
	return 0;
}
```

# 码字不易 求过 求各位大爷赏个赞

---

## 作者：llzzxx712 (赞：107)

## 01背包“水题”

  是的，它确实是一道水题，但是它多了一个求最少体力的问题，如果思路不清楚就可能混乱。~~（比如我第一遍打完01背包模板没过样例，回过头看自己程序都不知道自己在写什么）~~
  
  但理好思路后一切就变得豁然开朗了起来。这道题让我们算精卫是否能把东海**填平**，并求能填平的最小**体力**。我们可以看到体力是本题的要点，那我们不妨设数组f[i]表示消耗i的体力可以搬运的最多石子。然后套用01背包模板，算出每一个f的值
  
  不会用一维数组实现01背包的看一下我的博客，里面有超级详细的解释[01背包，完全背包](https://www.luogu.org/blog/llzzxx712/solution2-p2722)
  
  最后我们就可以判断用全部的体力（也就是i==c）是否能填平，如果不能，就输出“Impossibel”，不然就一直向下找，直到找到刚好够填平时消耗的体力，用总体力一减，就是答案了，总代码只有20行，是不是很棒呢？
  
------------
下面附上AC代码
```cpp
#include<iostream>
using namespace std;
int v,n,c,tj[10002],tl[10002];//v,n,c同题目意思， tj表示体积，tl表示体力 
int f[10002];//f[i]表示消耗i的体力最多可以搬运的石子 
int main()
{
	cin>>v>>n>>c;
	for(int i=1;i<=n;i++) cin>>tj[i]>>tl[i];//输入v,n,c和每块石头的体积和搬它要消耗的体力 
	for(int i=1;i<=n;i++)
		for(int j=c;j>=tl[i];j--)
			f[j]=max(f[j],f[j-tl[i]]+tj[i]);//一维数组求01背包，不断更新消耗j的体力可以搬多少石子
	if(f[c]<v) cout<<"Impossible";//最终结果出来后，如果用上所以体力（c），能搬的体积仍小于需要的体积，那么就输出不能 
	else{//如果可以 
		int i=c;
		while(f[i]>=v) i--;//那么就不断递减找到刚好够搬所需的体力（注意：这里并不一定要刚好填满） 
		cout<<c-(i+1);//由于while循环找到的是刚好不能搬时的体力，所以刚好够搬的体力就是现在的i加上1 
	}//再用总体积减一下，就是剩下的最大体力了 
	return 0;
}

```


---

## 作者：ww3113306 (赞：19)

其实这道题就是01背包，只不过多了一个搜索最佳解的过程

我的思路是用01背包求出当精卫剩下的体力为x时，她最多能填多少海。这样，她第一次能填完海时剩下的体力就是所需的最小体力

---update in 2021/11/11---
应某题解爆破中的说明，将统计答案的循环改成从0开始枚举，以适应有石子的体力消耗为0的情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
int need,n,power,vi,pi,i,j,k,f[11000];bool z; 
int main()
{
    z=false;//一开始默认精卫不能填完海
    scanf("%d%d%d",&need,&n,&power);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&vi,&pi);
        for(j=power;j>=pi;j--)//体力为j时最多可以填多少海 
            f[j]=max(f[j],f[j-pi]+vi);
    }
    for(j=0;j<=power;j++)//搜索体力最少为多少时可以填完海，并记录最少的体力 
        if(f[j]>=need){k=j;z=true;break;}    //当精卫第一次填完海时，终止循环，并记录精卫可以填完海
    if(z==false) printf("Impossible");//如果精卫不能填完海，输出
    else printf("%d",power-k);//如果可以填完，输出所需最小体力与总体力的差值
    return 0;    
}
```

---

## 作者：qkm鸭 (赞：14)

这道题和0-1背包有一个**区别**：

         0-1背包最后求可以装的最大价值
         
         这道题最后求满足一定价值时需要的最少容积
         （也就是在能填完海时消耗的最小体力，也就是剩余体力最大）
         
```cpp
#include<iostream>
using namespace std;
int a[10004],v,n,c,vi[10003],ci[10003],dp[10003],ans=-1;
int main()
{
	cin>>v>>n>>c;
	for(int i=1;i<=n;i++)
	cin>>vi[i]>>ci[i];
	for(int i=1;i<=n;i++)
	for(int l=c;l>=ci[i];l--)
	{
		dp[l]=max(dp[l],dp[l-ci[i]]+vi[i]);
	    if(dp[l]>=v)ans=max(ans,c-l);    每找到一种状态，就看是否满足可以填满，然后更新。
	}
	if(ans==-1)
	cout<<"Impossible";
	else
	cout<<ans;
	return 0;
 } 
```


---

## 作者：__gcd (赞：10)

首先看到这道题，立马想到01背包

好的我们开始想这个DP的写法

* 定义状态

看题目要求的是精卫剩下的最大体力，而精卫剩余体力给出

那么就求填满最少用的体力吧

那么定义状态大概就出来了

$dp[i]$ :填满$i$的体积最少要多少体力。

* 初始化

开始先假设每个都填不满，也就是需要的体力是无限

所以$dp[i]$赋予一个极大的数（比如0x7ffffff)

* 状态转移方程

分两种情况

1. 第$i$块能直接填满，那么就直接放吧（考虑这种情况是因为可以超出）
	
$dp[j]=min(dp[j],m[i])$

2. 不能填满，那么就像平常写背包一样

$dp[j]=min(dp[j],dp[j-k[i]]+m[i])$

好的，那么就有了以下代码

```
#include<iostream>
using namespace std;
const int N = 10010;
const int INF = 0x7ffffff;
int k[N], m[N], dp[N];
int main()
{
    int v, n, c;
    cin >> v >> n >> c;
    for(int i = 1; i <= n; i++)
        cin >> k[i] >> m[i];
    for(int i = 1; i <= v; i++)
        dp[i] = INF;//初始化
    for(int i = 1; i <= n; i++)
        for(int j = v; j >= 0; j--)
        {
            if(j >= k[i]) 
                dp[j] = min(dp[j], dp[j-k[i]] + m[i]);
            else dp[j] = min(dp[j], m[i]);//状态转移方程
        }
    if(c < dp[v])cout << "Impossible";
    else cout << c - dp[v];//开心地输出剩余体力
    return 0;
}
```


---

## 作者：nth_element (赞：10)

### 前言：
其实这道题挺水的，但我居然把ta想成了 **~~贪心~~** ~~啪啪打脸~~
***
好了，废话不多说。
### 思路：


- step 1：先翻译以下题意，其实就是求出最多消耗多少体力能把东海填满，如果不能填满，就输出“Impossible”



- step 2:于是想到 **~~贪心~~** 01背包，以搬石头消耗的体力为物品的体积，以石头的

- step 3:我们现在已经求出（1~c）所有体力可搬走的最大的体积，假如此时以i体力可填满东海，消耗的体力就是（c-i）；如果以c的体力都不能填满，就输出“Impossible”
*** 
### 最后给你一个假code（~~不要抄哦，后果自负~~）


```cpp
#include<bits/stdc++.h>
#define Maxn 10010
#define Maxv 10010
#define Maxc 10010
#define int long long
using namespace std;
int v,n,c;
struct node
{
	int v0,c0;//每个石头的体积及搬走需要的体力 
}rock[Maxn];
int f[Maxc];
int main()
{
	scanf("%d%d%d",&v,&n,&c);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&rock[i].v0,&rock[i].c0);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=c;j>=rock[i].c0;j--)
		{
			if(f[j]<f[j-rock[i].c0]+rock[i].v0)
			{
				f[j]=f[j-rock[i].c0]+rock[i].v0;//以搬石头消耗的体力为物品的体积，以石头的体积为物品可创造的价值，最后f[i](i=1~c)表示耗费i体力搬走的石头的总体积 
			}
		}
	}
	for(int i=1;i<=c;i++)
	{
		if(f[i]>=v)//假如此时耗费了i体力已经填满了 
		{
			printf("%d",c-i);//计算剩下的体积 
			return 0;
		}
	}
	puts("Impossible");//枚举完了所有可用的体积，都不可以填满，就Impossible
	return 0;
}
```


***
### 相似题：
[P2918 [USACO08NOV]买干草Buying Hay](https://www.luogu.org/problemnew/show/P2918)


思路：两道题其实很相似，这道题是以开销的美元为物品的体积，以购买的干草的磅数为物品可创造的价值做完全背包
*** 
### 后记：
其实这道题想到01背包挺容易的，主要是看到 **只能用一次的石头消耗一次性的体力可填的最大的体积**

这就是01背包的本质

~~其实这一段是给自己看的~~

---

## 作者：雒仁韬 (赞：7)

这道题如果熟练的话应该一眼就看出这是一个01背包的变形。

此处就不多赘述01背包了，直接讲变形：

01背包是求最大价值

而这道题是求剩下的最大空间(在满足条件的情况下)

所以我们只要跑一遍01背包，设f[i]表示体力值剩下i的时候可以搬的最多石头，那么每一个石头的体积为价值，耗费体力为费用，然后加一个判断，如果当前f[i]已经填满海了，那么比较f[i]剩下的空间与当前剩下的最大空间即可。

代码应该很好懂(原谅我不按照题目中给的变量名称来写)

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstdlib>
using namespace std;
int v,n,m;
int w[10005];
int c[10005];
int f[10005];
int ans=-1;
int main()
{
	cin>>v>>n>>m;
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d",&c[i],&w[i]);
	}
	for(int i=1;i<=n;++i)
	{
		for(int j=m;j>=w[i];--j)
		{
			f[j]=max(f[j],f[j-w[i]]+c[i]);
			if(m-j>ans && f[j]>=v)
			{
				ans=m-j;
			}
		}
	}
	if(ans==-1)
	{
		cout<<"Impossible"<<endl;
	}
	else
	{
		cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：doby (赞：6)

01背包……

状态转移方程……反正大家都知道了……

很多都是模板内容，需要解释的不多哈哈哈……

```cpp
#include<iostream>
using namespace std;
int vol,n,v[10001],w[10001],f[100001]={0},c;
int main()
{
    cin>>vol>>n>>c;
    for(int i=1;i<=n;i++){cin>>v[i]>>w[i];}
    for(int i=1;i<=n;i++)
    {
        for(int j=vol;j>=w[i];j--)
        {
            if(f[j]<=f[j-w[i]]+v[i]){f[j]=f[j-w[i]]+v[i];}
        }
    }
    for(int i=0;i<=c;i++){if(f[i]>=vol){cout<<c-i;return 0;}}//从最小的体力开始找，保证使用的体力最小
    cout<<"Impossible";//如果没出现多于需要的体积的解，说明无解
    return 0;
}
```

---

## 作者：湖里的杭 (赞：4)

用f[i]表示花费i体力后剩填余力最大值

可得状态转移方程为f[j+b[i]]=max(f[j+b[i]],f[j]+a[i]); 

下面附上代码 
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int f[10009];//f[i]表示花费i体力后填的最大值 
int a[10009],b[10009];//a 体积；b 体力 
int main()
{
	int v,n,c;//意义如题目中所示
	scanf("%d%d%d",&v,&n,&c);//输入这三个值
	memset(f,0,sizeof(f));//清空f
	f[0]=0;
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i],&b[i]);
	for(int i=1;i<=n;i++)
		for(int j=c-b[i];j>=0;j--)
			f[j+b[i]]=max(f[j+b[i]],f[j]+a[i]);
	for(int i=1;i<=c;i++)//找到第一个满足v的数，并输出，然后return0
		if(f[i]>=v)
		{
			printf("%d\n",c-i);
			return 0;
		}
	printf("Impossible\n");//没有一个数满足条件(~~精卫不容易的~~)
	return 0;
}
```

---

## 作者：PHarr (赞：3)

这也是一个经典的背包问题，背包求最小费用

`f[i][j]`表示前$i$个物品用了$j$的体力所能填满的最大空间，显然滚动数组优化一维空间

然后枚举一下体力，找到最先填满全部体积的一个即可

简单分析一下，当花费的体力增加时，所填满的体积保证不会减小，满足单调性

二分查找会更快

```cpp
#include<bits/stdc++.h>
using namespace std;


const int N = 10005;
int n , V , power ,f[N] , use;
bool flag = 0;

inline int read()
{
    register int x = 0;
    register char ch = getchar();
    while( ch < '0' || ch > '9' ) ch = getchar();
    while( ch >= '0' && ch <= '9' )
    {
        x = ( x << 3 ) + ( x << 1 ) + ch - '0';
        ch = getchar();
    }
    return x;
}


int main()
{
    V = read() , n = read() , power = read();
    for( register int i = 1 , v , w ; i <= n ; i ++ )
    {
        v = read() , w = read();
        for( register int j = power ; j >= w ; j -- ) f[j] = max( f[j] , f[ j - w ] + v );
    }
    use = lower_bound( f + 1 , f + 1 + power , V ) - f;
    if( f[use] >= V ) printf( "%d\n" , power - use );
    else puts("Impossible");
    return 0;
}
```
看到一位老哥想用二分答案的方式加`0/1`背包判断，我想跑背包在二分查找会比他的更快

---

## 作者：le_星辰 (赞：2)

  这一看首先想到的就是01背包是没有疑问的，然后我来吧题目化简成01背包的特征，你有容积为c的背包，有n个物品，每一块物体的价值和体积分别为k和m，用dp[i][j]表示前i个物品，用容积为j的背包最大的价值，那么:
  
  dp[i][j]=max(dp[i-1][j],dp[i-1][j-m]+k)

  然后可以用滚动数组以及边读边输入的方式优化他的空间复杂度和增大代码可读性（美观），新的定义下动态规划公式：
  
  dp[i]=max(dp[i],dp[i-m]+k)
  
  背包写好后再进行一个判断，最大的dp如果大于v，那就有方案了，否则就输出Impossible
  以上是01背包的部分，但是为什么这题难度比01背包高呢？原来题目多了一个要求，就是要求在能填满海的条件下尽量省体力，其实也不难，中间加一个判断就行了，当可以填满海的时候体力可以用一个变量ans来表示，然后不断打擂台更新，最后就是结果了，上代码。
  ```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    int v,n,c,ans=-1,dp[10005];
    scanf("%d%d%d",&v,&n,&c);
    for(int i=1;i<=n;i++){
        int k,m;
        scanf("%d%d",&k,&m);
        for(int j=c;j>=m;j--){
            dp[j]=max(dp[j],dp[j-m]+k);
            if(dp[j]>=v)ans=max(ans,c-j);
        }
    }
    if(ans==-1) printf("Impossible");
    else printf("%d",ans);
    return 0;
}
```

---

## 作者：Christopher_Yan (赞：2)

大佬们的做法都这么高深，然而这个题明明可以一个01背包的板子+答案更新来AC。

这里用一维数组f来记录当前状态，f[x] 表示还剩x体力时，精卫所能填出的体积，这样只需在01背包过程中判断f[x] 的值是否大于V,是则更新答案。

下附AC代码：
```
#include<iostream>
#include<cstdio>
using namespace std;
int V,n,R;
int v[10010];    //每块石头的体积
int w[10010];	 //每块石头消耗的体力
int f[10010];
int ans=-1;
int main()
{
	scanf("%d%d%d",&V,&n,&R);
	for(int i=1;i<=n;++i)
		scanf("%d%d",&v[i],&w[i]);
	for(int i=1;i<=n;++i)
		for(int j=R;j>=w[i];--j)
			if(f[j]<f[j-w[i]]+v[i])    //01背包
			{
				f[j]=f[j-w[i]]+v[i];
				if(f[j]>=V) ans=max(ans,R-j); //一旦f的值大于V,用R-j更新答案
			}
	if(ans>=0) printf("%d",ans);
	else printf("Impossible");   //注意题目要求
	return 0;
}
```

---

## 作者：陈新月 (赞：2)

思路：

这道题的话用01背包的思想就能解决，但是就是在模型的使用上有有点诡异（......我居然一开始把变量名给弄错了）

我是这样做的，设状态d[j]为使用j个体力值后能搬走石头体积的最大值，显然可得动态转移方程为：d[j] = max(d[j],d[j-w[i]] + v[i]);

这里的w[i]是搬第i块石头所需的体力，v[i]为第i块石头的体积。

于是我们就可以在每次状态转移后就进项判定，如果当前能搬走的石头体积大于剩余石头体积则更新答案（最大剩余体积）；


下面为代码，部分重要细节已注释，如果有问题可以给我留言















```cpp
#include<cstdio>
#include<algorithm> 
#define N 10009
using namespace std;
int d[N],k[N],m[N];
int v,c,n;
int main(){
    scanf("%d%d%d",&v,&n,&c);
    for(int i = 1; i <= n; i++)scanf("%d%d",&k[i],&m[i]);
    int ans = -1;
    for(int i = 1; i <= n; i++)
      for(int j = c; j >= m[i];j--){
            d[j] = max(d[j],d[j-m[i]]+k[i]);            //状态转移 
            if(d[j] >= v)ans = max(ans,c-j);            //对当前d[j]进行判定，如果大于剩余石块体积则更新答案
                                                    //就是将现在状态剩余的体力与前一个计算出
                                                    //的剩余最大体力取最大值 
      }
    if(ans == -1)printf("Impossible\n");            //如果ans = -1则是无解状态，输出Impossible 
    else printf("%d\n",ans);                        //否则有解，输出答案 
    return 0;
}

```

---

## 作者：WangA (赞：2)







```cpp
//01背包问题
//可以将体力看为容量，体积看为总价值
//在内层循环不断地判断， 如果当前总价值大于等于要填的体积，就进行保存
//此题注意体积不用恰好相等，只要大于等于即可
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#import <Foundation/Foundation.h>//OC遗留症 
using namespace std;
int f[10005];
int a[10005];
int w[10005];
int main() {
    int v, n, c;
    int ans = -1;
    scanf("%d%d%d", &v, &n, &c);
    for (int i = 1; i <= n; i ++)
        scanf("%d%d", a + i, w + i);
    for (int i = 1; i <= n; i ++)
        for (int j = c; j >= w[i]; j --) {
            f[j] = max(f[j], f[j - w[i]] + a[i]);
            ans = (f[j] >= v && ans <= c - j) ? c - j : ans;
    }
    if (ans == -1)
        NSLog(@"Impossible\n");//OC遗留症 
    else 
        NSLog(@"%d\n", ans);//OC遗留症 
    return 0;
}

```

---

## 作者：LJLYROCK (赞：1)

## 超简单 ~~弱~~ 的背包正解
我们设 f[i][j] 为 i 个物体 j 个体力 所能拿的最大体积

设 rv[i] 为第 i 个物体的体积 ，rs[i] 为第 i 个物体所需的体力

那么就可以得到状态推导方程

当 j < rs[i] 时 f[i][j] = f[i - 1][j];

当 j = rs[i] 时 f[i][j] = max(f[i - 1][j], rv[i])

当 j > rs[i] 时 f[i][j] = max(f[i - 1][j], f[i - 1][j - rs[i]] + rv[i])

当时我就觉得好水然后上代码

### PS不是正解！！！

```c
#include<iostream>
using namespace std;

int vlast, slast, n, ans;//vlast是要填满的体积，slast是剩余的体力，n是物体数量
int rv[10001], rs[10001], f[10001][10001];//rv是物体体积，rs是物体搬运所需体力
bool tf = 0;

int main () {
	cin >> vlast >> n >> slast;
	for (int i = 1; i <= n; i++) cin >> rv[i] >> rs[i];
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= slast; j++) {
			if (j == rs[i]) f[i][j] = max(f[i - 1][j], rv[i]);
			else if (j < rs[i]) f[i][j] = f[i - 1][j];
			else if (j > rs[i]) {
				f[i][j] = max(f[i - 1][j], f[i - 1][j - rs[i]] + rv[i]);
			}
			
			if (f[i][j] >= vlast) {//注意是大于等于
        		ans = max(ans, slast - j);//寻找剩余体力最大值（剩余体力 = slast - j）
        		tf = 1;//当有一个满足大于等于要填满的体积时即为可以填满
			}  
		}
	}
	
	if (tf) {
		cout << ans;
	} else {
		cout << "Impossible";
	}
	return 0;
} 
```

### 然后就悲惨的80分，两个点过不了，MLE
那就简单的简化一下

通过方程可知 f[i][j] 只取决于 f[i - 1][?];

那么就可以将 f[10001][10001] 改为 f[2][10001] 

这样就只保存 f[i][j] 和 f[i - 1][?] 了

当然要做一些循环处理

f[1][j] = f[0][?]

f[0][j] = f[1][?]

### 正确代码
```c
#include<iostream>
using namespace std;

int vlast, slast, n, ans;
int rv[10001], rs[10001], f[2][10001];
bool tf = 0;

int main () {
	cin >> vlast >> n >> slast;
	for (int i = 1; i <= n; i++) cin >> rv[i] >> rs[i];
	
	int z;//z = i - 1;
	for (int i = 1; i <= n; i++) {
		if (i % 2 == 0) z = 1;//当 i 为 2 的倍数时f[0][j] = f[1][?];
		else z = i % 2 - 1;//f[1][j] = f[0][?];
		for (int j = 1; j <= slast; j++) {
			if (j == rs[i]) f[i % 2][j] = max(f[z][j], rv[i]);
			else if (j < rs[i]) f[i % 2][j] = f[z][j];
			else if (j > rs[i]) {
				f[i % 2][j] = max(f[z][j], f[z][j - rs[i]] + rv[i]);
			}
			
			if (f[i % 2][j] >= vlast) {
        		ans = max(ans, slast - j);
        		tf = 1;
			}  
		}
	}
	
	if (tf) {
		cout << ans;
	} else {
		cout << "Impossible";
	}
	return 0;
} 
```


---

## 作者：Forever丶CIL (赞：1)

这个题的一个简单思路：

$0—1$背包 $\Rightarrow O(n^2)$  求出对于每个体力值所能填满的最大体积(用数组$A[i]$来存)

然后$for(0\rightarrow n)$ 扫一遍 找到第一个大于$v$的$A[i]$ 直接输出$c-i$就可以了

如果整个数组中都不存在满足要求的$A[i]$的话，就输出Impossible；

$2333$ 蒟蒻瑟瑟发抖



------------


```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int A[10101];
int k[10101];
int m[10101];
int v, n, c;
void dp()
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = c; j >= m[i]; j--)
        {
            A[j] = max(A[j], A[j - m[i]] + k[i]);
        }
    }
}
int main()
{
    scanf("%d%d%d", &v, &n, &c);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d%d", &k[i], &m[i]);
    }
    dp();
    for (int i = 0; i <= c; i++)
    {
        if (A[i] >= v)
        {
            printf("%d", c - i);
            return 0;
        }
    }
    printf("Impossible");
    return 0;
}

```


------------
感谢@Mars_Dingdang 提供hack数据。现已修正。

---

## 作者：汇文客 (赞：1)

前面的题解已经说得很详细了，我再补充一点：大家一定要习惯写空间复杂度

O(n)的背包，否则此题O（n^2）刚好会炸内存。提供一个模板吧：

```delphi

for i:=1 to n do                       
  for j:=c downto 0 do
  if j>=v[i] then
  f[j]:=max(f[j],f[j-v[i]]+w[i]); 

```

---

## 作者：usqwedf (赞：1)

[1]
体积->价值

体力->重量

转化成了01背包。

[2]
需要体积->需要价值

另类装箱？

[3]
建议 Impossible 复制。。

恩。。打错了大小写。。

附代码：

```delphi
var  
  v,n,m,x,y,i,j:longint;  
  f:array[0..100000] of longint;  
begin  
  readln(v,n,m);  
  for i:=1 to n do begin  
    readln(x,y);  
    for j:=m downto y do  
      if f[j-y]+x>f[j] then f[j]:=f[j-y]+x;  
  end;  
  for i:=0 to m do  
    if f[i]>=v then begin writeln(m-i); halt; end;  
  writeln('Impossible');  
end. 
```
[4]
需要膜拜一下野菜汤 && 洋葱头 同学么。。

需(xi)要(wen)吧(le)！(jian)


---

## 作者：野菜汤 (赞：1)


```delphi
var i,j,k,m,n,o,p,q:longint;
    sum:int64;
    a:array[1..10000,1..2] of longint;
    f:array[0..10000] of longint;
function max(x,y:longint):longint;
begin
  if x>y then exit(x) else exit(y);
end;
begin
  read(o,n,m);
  for i:=1 to n do begin read(a[i,1],a[i,2]);sum:=sum+a[i,1]end;
  if sum<o then begin write('Impossible');exit;end;
  for i:=1 to n do
   for j:=m downto 1 do
   begin
     if j>=a[i,2] then f[j]:=max(f[j],f[j-a[i,2]]+a[i,1]);
   end;
  for i:=1 to m do if f[i]>=o then begin write(m-i);exit;end;
  write('Impossible');
end.
[color=turquoise blue]**题解：**[/color]

        [color=violet]此题其实只是一道普通的动规题，只是变量有点多，所以有点无从下手的感觉，那么就明确一下思路，通过模拟体力的多少来处理所能填的最大面积（记得用一位数组），最后在做个循环，找到第一个超出所剩面积的位置，输出他所用的体力，也就是当前循环的i，就可以得出答案了。所以呢，必须要用一维数组。[/color]

        **[color=teal]以下是我的ac程序。[/color]**

```

---

## 作者：Celebrate (赞：1)

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
#define MAXX 11000
int v,n,c;
int f[MAXX],a[MAXX],b[MAXX];//f[i]表示用i点体力最多能填多少海 
inline void read(int &Input) {//输入优化
	char Character;
	Input=0;
	Character=getchar();
	while(Character>'9'||Character<'0')Character=getchar();
	while(Character<='9'&&Character>='0') {
		Input*=10;
		Input+=Character-'0';
		Character=getchar(); } }
inline void write(int Output) {//输出优化
	char Digit[11];
	int Lenth=0;
	while(Output>0) {
		Digit[++Lenth]='0'+Output%10;
		Output/=10; }
	for(int i=Lenth; i>=1; i--) putchar(Digit[i]);
	printf(" "); }
inline void dp() {
	int i,j;
	read(v); read(n); read(c);//输入 
	for(i=0; i<=c; i++) f[i]=0;//初始化 
	for(i=1; i<=n; i++) {
		read(a[i]);
		read(b[i]); }
	for(i=1; i<=n; i++) {
		for(j=c; j>=b[i]; j--) {
			f[j]=max(f[j],f[j-b[i]]+a[i]); } }//dp求最大值 
	bool bk=false;
	for(i=0; i<=c; i++) {//只要找到就输出，因为这肯定是最小的花费，也就是最大的体力 
		if(f[i]>=v) {
			bk=true;
			write(c-i); break; } }//记得break 
	if(bk==false) printf("Impossible\n"); }//输出 
int main() {
	dp(); }
```

---

## 作者：war1111 (赞：1)

P1510 精卫填海

二分答案

二分背包容量，判断能否满足v。

判断的话就跑01背包就好了。

代码：http://www.cnblogs.com/war1111/p/7747570.html


---

## 作者：Y_B_Y (赞：0)

01背包问题

### 一.主要思路

由于如果设f[j][i]为堆到第j个石头i米高是体力消耗的最小值,因为堆的体积可能会超过v,所以这里设剩余的最大体积比较方便

因为n与c比较大所以这里压成了一维,f[i]表示剩余i体力时,最大能堆多少(由于j的顺序是1-n所以只要i从小到大循环,每一次更新f用的其实都是j-1时f的值,相当于覆盖了原来的值)

#### 压维的解释:

j=1时(值是初始化的),f[5]=4,f[4]=3,f[3]=2,f[2]=1,f[1]=1,f[0]=2

假如这里的状态转移方程为:f[i]=max(f[i],f[i+1]+l[j])

到j=2的时候(i从0-5),f[0]=max(f[0],f[1]+3),f[1]=max(f[1],f[2]+2),....(用的都是j=1时f的值,但注意要i要从小到大循环),这样就用j=1时f的值完成了j=2时f的值的更新

#### 关于循环的顺序:

如果状态转移方程为f[x]=max(f[x],f[x+m]+k)(m为非负整数) 时x从小到大循环

当f[x]=max(f[x],f[x-m]+k)时,x从大到小循环


### 二.状态转移方程
```
f[i]=max(f[i],f[i+m[j]]+k[j]);(j=1~n(i=0~c-m[j]))//因为体力最大为c所以只要拿了这个石头剩余体力一定小于等于c-m[j]
```
#### 解释

当体力剩i时第j块石头如果捡那么捡之前剩余的体力为i+m[j],于是就用f[i+m[j]]+k[j](填了面积所以加上k[j])更新f[i]的值

如果不捡就为f[i],在这两个值中找一个较大者作为f[i]的值

### 三.输出

从体力剩c找到0,如果有f[i]>=v就输出,结束程序

如果都找不到输出impossible

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000000],v,c,n,k[100000],m[1000000];//f就是上文说的意思,其它和题目的定义一样
int main()
{
	cin>>v>>n>>c;//输入
	for(int p=1;p<=n;p++) cin>>k[p]>>m[p];//输入
	for(int j=1;j<=n;j++)//开始DP
	{
	for(int i=0;i<=c-m[j];i++)
	{
		 f[i]=max(f[i],f[i+m[j]]+k[j]);
    }
	}
	for(int i=c;i>=0;i--)//找可以的
	{
		if(f[i]>=v)
		{
			cout<<i;//输出
			return 0;
		}
	}
	cout<<"Impossible";//都不可以
   return 0;
}
```


---

## 作者：SIGSEGV (赞：0)

dalao们的算法好复杂啊...... 蒟蒻看不懂........

背包问题就没必要弄得那么复杂嘛！

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[20005],v,n,c,t1,t2;
int main ()
{
	scanf("%d%d%d",&v,&n,&c);
    memset(dp,-1,sizeof(dp));//重置
	dp[0] = c;//初始化
	for (int i = 0;i < n;i++)
	{
		scanf("%d%d",&t1,&t2);
		for (int i = v + 500;i >= t1;--i) /*500是为了防止出现
        v完不成但v+k(k>0)能够完成的情况 这个数应该够大 要自己估
        但看dalao们题解好像并不用这样做*/
			dp[i] = max(dp[i],dp[i - t1] - t2);//dp常例 但方程要换一下
	}
	int ans = -1;
	for (int i = v;i <= v + 500;i++) ans = max(ans,dp[i]);
	if (ans == -1) printf("Impossible");else cout << ans;//输出
	return 0;
} 
```

---

## 作者：清风我已逝 (赞：0)

01背包问题的变形

分解：

子问题：已经填的体积耗费的体力由上一个物品选与不选所转移过来（填满或填超出此海的体积由上一个物品选与不选所转移过来）

状态转移方程：f[j]=min(f[j],f[j-k[i]]+m[i])

即  填了j个体积所耗费的体力

边界条件：f[0]=0;


//附上代码

```c
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int maxx,n,c,k[10007],m[10007],v,f[99999],ans=24859613;
int main()
{
	memset(f,0x7f,sizeof(f));
	cin>>v>>n>>c;
	for(int i=1;i<=n;i++){
		cin>>k[i]>>m[i];
		maxx=max(maxx,k[i]);
	}
	f[0]=0;
	for(int i=1;i<=n;i++){
		for(int j=v+maxx;j>=k[i];j--){
			f[j]=min(f[j],f[j-k[i]]+m[i]);
		}
	}
	for(int i=v;i<=v+maxx;i++) ans=min(ans,f[i]);
	if(ans>c) cout<<"Impossible";
	else cout<<c-ans;
	return 0;
} 
```

---

## 作者：封癫 (赞：0)

这道题是一个比较普通的01背包

如果f【m】还是小于要填的体积的话直接Impossible

否则从1到m开始扫数组，因为f数组表示的是在还有体力i下能填的最大体积

所以如果遇到一个f【i】>=要填的体积就直接输出体力m-i

最后 本人的读入优化使用函数模板，可以自动改变返回值数据类型，但亲测在输入可以溢出的数据时会出问题（溢出值和cin不一样）

所以要慎用，防止把自己坑了（虽然我只看重那少达600ms的运行时间）

如果有优化办法请私信我 多谢

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
template <typename T>
T read(){
    T num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num\*10+ch-'0';
        ch=getchar();
    }
    return num\*f;
}
#define read()    read<long long>()




int  w[20000];
int c[20000];
int f[20000];
int main()
{
    int q=read(),n=read(),m=read();
    for(int i=1;i<=n;++i){
        c[i]=read();
        w[i]=read();
    }
    for(int i=1;i<=n;++i)
        for(int v=m;v>=w[i];--v)
            if(f[v]<f[v-w[i]]+c[i])    f[v]=f[v-w[i]]+c[i];
    if(f[m]<q){
        printf("Impossible");
        return 0;
    }
    else 
    for(int i=1;i<=m;++i)
        if(f[i]>=q){
            printf("%d",m-i);
            return 0;
        }
    return 0;
}

---


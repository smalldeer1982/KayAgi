# 樱花

## 题目背景

《爱与愁的故事第四弹·plant》第一章。


## 题目描述

爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \le C_i \le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $P_i(0 \le P_i \le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \le T_i \le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。


## 说明/提示

$100\%$ 数据：$T_e-T_s \leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。

样例解释：赏第一棵樱花树一次，赏第三棵樱花树 $2$ 次。


## 样例 #1

### 输入

```
6:50 7:00 3
2 1 0
3 3 1
4 5 4```

### 输出

```
11```

# 题解

## 作者：Y_B_Y (赞：101)

## 混和背包问题的一种简单但比二进制优化慢一点的做法

### 一.朴素的做法

#### 1.时间输入:

cin>>小时1>>符号':'(char型)>>分钟1>>小时2>>符号':'>>分钟2;//当cin输入到数据类型不一样的是后它会跳到下一个数据类型一样的

如 
12:55 13:21输入完就是

第一个. 12 第二. : 第三. 55 第四. 13 第五. : 第六. 21 //被分开了 

总时间:60*(小时2-小时1)+分钟2-分钟1 (单位是分钟)

上面的总时间就是60*(13-12)+21-55=26分钟

#### 2.背包:

01背包,完全背包和多重背包不会的可以[看这里](https://blog.csdn.net/u012630961/article/details/80911956)

这里主要讲优化

- $dp[j]$表示消耗了$j$分钟最多可以有多少美学值,$a[i]$表示第i朵花最多可以看多少次

- 当$a[i]=0$时,用完全背包

- 其他时候用多重背包(01可以算是只能一次的多重背包)

代码
```cpp
        for(int i=1;i<=n;i++)
	{
		if(a[i]==0)//如果为完全背包
		{
			for(int j=t[i];j<=tz;j++) dp[j]=max(dp[j],dp[j-t[i]]+c[i]);//记得是正序
		}
		else
		{
		        for(int l=1;l<=a[i];l++)//重复a[i]次01背包的结果就相当于最多取a[i]个的多重背包
		        for(int j=tz;j>=t[i];j--) //01背包,倒序
			{
				dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
			}
		}
	}
```


### 二.优化

我们可以发现当第$i$个朵花,重复第$k$次01背包时,对于第$i$朵花$dp[k*t[i]]$前(不包括本身)的值都是已经确定了的,由于前面都是确定的就不要再循环到了

#### 解释

我们先看第一次01背包时,$dp[t[i]]$之前的都是可以确定对于第$i$朵花,是一定为0的(也就他们的贡献为0),因为消耗那么多时间根本不够看第$i$朵花

所以在第一次01背包中:$dp[2*t[i]-1]$由已经确定的$dp[t[i]-1]$得来,$dp[2*t[i]-2]$由已经确定的$dp[t[i]-2]$得来...$dp[t[i]]$由已经确定的$dp[0]$得来,所以他们在之后的第二次01背包中也是确定的

第二次01背包与第一次一样由$dp[2*t[i]]$之前都是确定的可以得出$dp[3*t[i]]$之前都是确定的给第三次01用,这样重复直到次数的上限结束

代码

```cpp
	for(int i=1;i<=n;i++)
	{
		if(a[i]==0)//完全背包和前面一样
		{
			for(int j=t[i];j<=tz;j++) dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
		}
		else
		{
		    for(int l=1;l<=a[i];l++)
		    for(int j=tz;j>=l*t[i];j--) //倒序,前面确定的不要循环到
			{
				dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
			}
		}
	}
```

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int c[100001],a[1000001],t[1000001],te1,te2,ts1,ts2,n,tz;//c[],t[]为题目等于,a[]表示最多看的次数,te1小时1,te2分钟1,ts1小时2,ts2分钟2,tz总时间
int dp[1001];//dp[j]表示消耗了j分钟最多可以有多少美学值
char cc;//符号':'
int main()
{
	cin>>te1>>cc>>te2>>ts1>>cc>>ts2;
	tz=60*(ts1-te1)+ts2-te2;
	cin>>n;
	for(int p=1;p<=n;p++) scanf("%d%d%d",&t[p],&c[p],&a[p]);
	for(int i=1;i<=n;i++)
	{
		if(a[i]==0)
		{
			for(int j=t[i];j<=tz;j++) dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
		}
		else
		{
		    for(int l=1;l<=a[i];l++)
		    for(int j=tz;j>=l*t[i];j--) 
			{
				dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
			}
		}
	}
	cout<<dp[tz];
	return 0;
}
```






---

## 作者：Infinity_shl (赞：65)

#### 先说80分代码：最基本的混合背包，判断是完全，01，或是多重，再选择。

##                  状态转移方程：f[j]=max(f[j],f[j-co[i]]+v[i]);
                

                 变量有些乱，dalao勿喷

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],c[10001],t[10001],f[10010],n,m;
int main()
{
    int x1,y1,x2,y2;
    scanf("%d:%d %d:%d",&x1,&y1,&x2,&y2);
    if(y1>y2)
    {
        y2+=60;
        x2--;
    }
    m=(x2-x1)*60+y2-y1;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d%d",&a[i],&c[i],&t[i]);
    for(int i=1;i<=n;i++)
    {
        if(t[i]==0)
        {
            for(int j=a[i];j<=m;j++)
                f[j]=max(f[j],f[j-a[i]]+c[i]);
        }
        else
        {
            for(int k=1;k<=t[i];k++)
            {
                for(int j=m;j>=a[i];j--)
                {
                    f[j]=max(f[j],f[j-a[i]]+c[i]);
                }
            }
        }
    }
    printf("%d\n",f[m]);
}
```

#### ### 再说100分代码：把每个物品进行二进制拆分，分成1，2，4，8，16，32，64 ，，，再把花费和价值乘以次数即可。

例如：某个物品可以用20次，那么可以分成1 2 4 8 5；

##### PS：对于完全背包，可以把次数定为一个很大的数，如9999999；

具体见代码：



------------


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],b[10001],c[10001],f[1000010],n,m;
int x1,yy,x2,y2;
int co[1000001],v[1000001],top;
void aaa()
{
	for(int i=1;i<=n;i++)
	{
		int aa=1;
		while(c[i]!=0)
		{
			co[++top]=a[i]*aa;
			v[top]=b[i]*aa;
			c[i]-=aa;
			aa*=2;
			if(c[i]<aa)
			{
				co[++top]=a[i]*c[i];
				v[top]=b[i]*c[i];
				break;
			}
		}
	}
}
int main()
{
    scanf("%d:%d %d:%d",&x1,&yy,&x2,&y2);
    if(yy>y2)
    {
        y2+=60;
        x2--;
    }
    m=(x2-x1)*60+y2-yy;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
    	scanf("%d%d%d",&a[i],&b[i],&c[i]);
    	if(!c[i]) c[i]=9999999;
    }
    aaa();
    for(int i=1;i<=top;i++)
    	for(int j=m;j>=co[i];j--)
    		f[j]=max(f[j],f[j-co[i]]+v[i]);
    printf("%d\n",f[m]);
}
```



------------
希望能给大家带来帮助！

---

## 作者：Ofnoname (赞：35)

虽然是黄题，但是能找到这题的人一定不一般。

如果你理解的01/完全背包里降维优化的本质，你就可以发现，我们是每次读入一个新物品，然后用放他或不放来更新f数组。那么对于物品可能是有限次或无限次放置的情况，我们只需要对每一个物品分类讨论即可。

1. 使用次数无限：直接按完全背包公式（正序）更新即可。

2. 使用次数有限：如果是多重背包，也直接把该物品按完全背包的解法带入即可，01背包可以看做多重背包的特殊情况，不用再讨论。

完全背包可以使用二进制优化或单调队列优化，这里都简单说一下。注意v是重量，w是价值。

### 二进制优化
将使用次数为c的物品拆分为权值为$1, 2, 4, ...2^i,c-2^{i+1}+1$的物品。

比如$(w=2,v=3,c=13)$，可拆分为$(2,3)$，$(2*2,3*2)$，$(2*4,3*4)$，$(2*6,3*6)$，容易证明这`log(c)`个数的物品可以拼接出$[1,c]$的所有数，所以是合法的。

### 单调队列优化

容易发现，在读入$(v,w,c)$时，$f[j]$可由$f[j-v],f[j-v*2],...f[j-v*c]$推得。

而$f[j-v]$可以由$f[j-v*2],...f[j-v*c],f[j-v*(c+1)]$推得。

它们的备选区间只在左右端点有变化。

又有$f[j+p*v] = max(f[j+k*v]+(p-k)*w)(k\le c)$

将右边化简为$(f[j+k*v]-k*w)+p*w$，因此我们枚举固定的`j`作为模数（代码中为d），在p不断后移的同时，用单调队列维护在范围内的$f[j+k*v]-k*w$最大值即可。由于又要通过式子的值淘汰无用值，又要用下标淘汰过期值，我使用了两个队列。

后者思维难度略大，效率略高，两者码量差距不大，这里使用第二种。

```cpp
#include <bits/stdc++.h>
#define MAX (1000 + 7)
using namespace std;

int N, M, a0, b0, a1, b1, f[MAX], Q1[MAX], Q2[MAX];

int main()
{
	scanf("%d:%d %d:%d %d", &a0, &b0, &a1, &b1, &N);
	M = (a1 - a0) * 60 + b1 - b0;
	
	for (int i = 1, v, w, c; i <= N; i++)
	{
		scanf("%d%d%d", &v, &w, &c);
		if (!c)
		{
			for (int j = v; j <= M; j++)
				f[j] = max(f[j], f[j - v] + w);
			continue;
		}
		for (int d = 0; d < v; d++)
		{
			int L = 1, R = 0, maxp = (M - d) / v;
			for (int p = 0; p <= maxp; p++)
			{
				int &x = f[d + v*p];
				while (L<=R && x - w*p >= Q2[R]) R--;
				Q1[++R] = p, Q2[R] = x - w*p;
				while (L<=R && Q1[L] < p - c) L++;
				x = max(x, Q2[L] + w * p);
			}
		}
	}printf("%d\n", f[M]);
}
```

---

## 作者：Drifterming (赞：27)




```cpp
//一个01背包、多重背包和完全背包的混合。
//在进行到第i棵树的时候，对它进行判断，判断属于哪一种背包
//然后根据它所属的类型做背包 
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
char s;
int a,b,c,d,n,tim;
struct tree
{
    int t,c,p;
}t[205];
int dp[205];
int main()
{
    scanf("%d%c%d%c%d%c%d%c",&a,&s,&b,&s,&c,&s,&d,&s);
    tim=(c-a)*60-b+d;        //计算时间 
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&t[i].t,&t[i].c,&t[i].p);
    }
    for(int i=1;i<=n;i++)
    {
        if(t[i].p==0)        //完全背包 
        {
            for(int j=t[i].t;j<=tim;j++)
            {
                //for(int i=)
                dp[j]=max(dp[j],dp[j-t[i].t]+t[i].c);
            }
        }
        else if(t[i].p==1)        //01背包 
        {
            for(int j=tim;j>=t[i].t;j--)
            {
                dp[j]=max(dp[j],dp[j-t[i].t]+t[i].c);
            }
        }
        else    //多重背包 
        {
            for(int j=tim;j;j--)
            {
                for(int k=1;k<=t[i].p&&j-k*t[i].t>=0;k++)    //从1开始正序枚举，一开始写的倒序，WA了 
                {
                    dp[j]=max(dp[j],dp[j-t[i].t*k]+t[i].c*k);
                }
            }
        }
    }
    //printf("%d\n",tim);
    printf("%d",dp[tim]);
    return 0;
}
```

---

## 作者：WOWHandsome (赞：20)

![](http://5b0988e595225.cdn.sohucs.com/images/20180224/08196272d5454c1fb85e84f0b4fd44ca.jpeg)


**创新之处**

1. 背包的处理用模块化，封装成几个函数，可以当成模板使用

2. 输入时，时间的处理用了数学方法，无需写繁琐的$if$

3. 本题解介绍了一下多重背包 $O(V*Σlog n[i])$ 的推导过程，弱化成了生活中常见的 **称砝码问题**。

## 弱化

首先我们先考虑一下 **01背包** 和 **完全背包** 的混合。

```cpp
for i=1..N
    if 第i件物品属于01背包
        for v=V..0
            f[v]=max{f[v],f[v-c[i]]+w[i]};
    else if 第i件物品属于完全背包
        for v=0..V
            f[v]=max{f[v],f[v-c[i]]+w[i]};
```

伪代码已给出，应该很容易想到这个代码实现。

## 多重背包

一种很好实现的思路就是 转化为 **01背包** 进行求解。对于一组~~物品~~樱花树，我们设其观赏时间为 $weight$，观赏美感值为 $cost$，观赏上限为 $amount$，那么我们可以得到一个伪代码

```cpp
for j=1..amount   //做amount次
  ZeroOnePack(weight, cost) //01背包
```

其时间复杂度为 *$O(V*Σn[i])$* 。显然在此题中是无法通过满分的。

我们考虑另外一种思路，就是将其进行 **二进制拆分**。因为任意一个数都能转换成一个二进制数。如果你无法理解，那么可以想象成一个 **称砝码** 的小游戏——

> 现在有一堆砝码。我们要称重量不超过 $100g$ 的物体。如何用最少的砝码来称出所有重量的物体？

显然我们可以使用 $1,2,4,8,16,32,64......2^k$ 重量的砝码来进行称重，只是注意我们不能 **超量(超量程qaq)** ，也就是说我只想称 $20g$ 的物体，然后你拿着 $1,2,4,8,16$ 的砝码来称，这样意味着最多可以称出 $1+2+4+8+16=31g$ 的物体！~~超重~~ 

这样我们写出了时间复杂度为 $O(V*Σlog n[i])$ 的基于 **01背包** 的 **多重背包** 问题。*伪代码如下——*

```cpp
void MultiplePack(int dp[], int weight, int cost, int amount) {
    if (weight * amount >= v || amount == 0) {  //其实就是一个完全背包，不必要进行拆分，直接 O(n) 做
        CompletePack(dp, weight, cost);
        return;
    }
    for (int k = 1; k <= amount; k <<= 1) {   //进行二进制拆分
    	ZeroOnePack(dp, weight*k, cost*k);  //做01背包
    	amount -= k;   //将物品减去，防止“超重”
	}
    ZeroOnePack(dp, amount*weight, amount*cost);  //剩余的“砝码”再做一次
    return;
} 
```

希望你理解一下这个代码，不懂的话多模拟几遍。

## 整合

整合起来就可以 $3$ 种背包进行分类操作。*伪代码如下*

```cpp
for i=1..N   
    if 第i件物品属于01背包
        ZeroOnePack(....)
    else if 第i件物品属于完全背包
        CompletePack(.....)
    else if 第i件物品属于多重背包
        MultiplePack(.....)
```

当然如果想偷个懒，直接调用 `MultiplePack()` 也是可以的。但是需要特判一下输入 $0$ 去做完全背包。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int dp[10005]; int v;
 
void ZeroOnePack(int dp[], int weight, int cost) {
    for (int j = v; j >= weight; j--)
        dp[j] = max(dp[j], dp[j-weight]+cost);
    return;
}
 
void CompletePack(int dp[], int weight, int cost) {
    for (int j = weight; j <= v; j++)
        dp[j] = max(dp[j], dp[j-weight]+cost);
    return;
}
 
void MultiplePack(int dp[], int weight, int cost, int amount) {
    if (weight * amount >= v || amount == 0) {
        CompletePack(dp, weight, cost);
        return;
    }
    for (int k = 1; k <= amount; k <<= 1) {
    	ZeroOnePack(dp, weight*k, cost*k);
    	amount -= k;
	}
    ZeroOnePack(dp, amount*weight, amount*cost);
    return;
} 
 
int main() {
	int time1, time2, time3, time4, n, w, c, a;
	scanf("%d:%d %d:%d %d\n", &time1, &time2, &time3, &time4, &n);  //时间的处理，输入用scanf进行格式化输入
	v = time3*60+time4-time1*60-time2;  //很暴力地直接算
    for (int i = 0; i < n; i++) {
        scanf("%d%d%d", &w, &c, &a);
        if (a == 0) CompletePack(dp, w, c);
        else MultiplePack(dp, w, c, a);
//        printf("DP on Time [%d]: %d\n", i, dp[v]);
    }
    printf("%d\n", dp[v]);
    return 0;
}
```

---

## 作者：iiiiiyang (赞：14)

# 题解：樱花

[题目链接](https://www.luogu.com.cn/problem/P1833)

### 前言
这是一道混合背包的问题，其他题解讲述的十分清晰，但在多重背包的问题上大多只是使用了二进制拆分优化，本篇文章将以通俗易懂的方法讲解单调队列优化多重背包，因此默认大家已经掌握了背包的知识，推荐大家拿着笔推一推式子。

### 前置知识
- 多重背包

- 优先队列

### 什么样的 DP 可以使用单调队列优化

状态转移方程形如：
$$
F_i = \max / \min_{j=l_i}^{i-1} \{ {g_j} \} + w_i  \quad l_i \leqslant l_{i+1}
$$

~~翻译成人话~~意思就是对于序列中的点，决策区间随着序列下标的增大从左向右进行转移，类似于一个窗口从左向右进行滑动。如果存在 $i_1 \lt i_2$ ，且 $g_{i_1}$ 劣于 $g_{i_2}$ 。那么当窗口滑动到 $i_2$ 时，$i_1$ 永远不会成为最优决策点，此时这个点也将不用进行转移了。

~~一个人如果比你小还比你强，那么你就可以退役了。~~

对此我们可以维护一个下标递增的单调队列，使队头一直保持最优转移。每次从队尾判断，若已经不可能成为最优决策就弹出。特别的，当队头超出了所在的新区间，因为下标单调递增，以后它也不可能回到这个区间，这时我们还需要将队头弹出。这样每次转移之后，我们只需要取出队头，队头就是最优解。

保持单调性的方法非常简单，在新的队尾入队前，要先将劣于它的元素从尾部弹出；“窗口”滑动之后，要检查队头是否合法，如果不合法要从队头弹出。因此一般使用双端队列或者直接数组模拟。

### 单调队列优化多重背包
记总共有 $N$ 种物品，每种物品中一个物品的体积为 $V_i$ ，价值为 $W_i$ ，数量为 $C_i$ , $F_{i,j}$ 为前 $i$ 件物品选出总重量为 $j$ ， DP 值表示最大价值。

容易得出多重背包的状态转移方程为：
$$
F_{i,j} = \max_{1 \leqslant k \leqslant C_i} \{F_{i - 1,j - k * V_i} + k * W_i\}
$$

这个东西看起来可能不是很清晰，我们把它分成一项一项来看：
$$
F_{i,j} = \max \{ F_{i-1,j} , F_{i-1,j-v}+w , F_{i-1,j-2v}+2w , \cdots , F_{i-1,j-kv}+kw \}
$$
$$
F_{i,j-v} = \max \{F_{i-1,j-v} , F_{i-1,j-2v}+w , \cdots , F_{i-1,j-kv}+(k-1)w , F_{i-1,j-(k+1)v}+kw \}
$$
$$
\cdots
$$

可以发现对于任何一个 $F_{i,j}$ 是由它前面的 $(k+1)$ 项形如 $F_{i - 1,j - k * V_i} + k * W_i$ 的式子转移而来，直到背包的体积不能再用。

但是，这个队列中前面的数，每次都会增加一个 $w$ ，所以我们需要做一些转换。

不妨设 $j=k' * V_i +d$ ，其中 $k'$ 表示的是 $j$ 重量所能装下的该物品最大数量， $d$ 则是余数。可以得到：
$$
F_{i,j} = \max_{1 \leqslant k \leqslant C_i} \{F_{i - 1,k' * V_i +d - k * V_i} + k * W_i\}
$$
$$
F_{i,j} = \max_{1 \leqslant k \leqslant C_i} \{F_{i - 1,(k'-k) * V_i +d} + k * W_i\}
$$
$$
F_{i,j} = \max_{1 \leqslant k \leqslant C_i} \{F_{i - 1,(k'-k) * V_i +d} + k * W_i - k' * W_i  + k' * W_i \}
$$
$$
F_{i,j} = \max_{1 \leqslant k \leqslant C_i} \{F_{i - 1,(k'-k) * V_i +d} + (k'-k) * W_i \} + k' * W_i
$$

对于每一种余数 $d$ 我们可以维护一个单调队列，因为通过式子可以看出不同余数之间的状态不会互相转移，这样我们就可以在线性的时间里求出在第 $i$ 个物品时，对于 $j \equiv d (\mod V_i ) $ 的 $F_{i,j}$ 最大值。

时间复杂度 $O(NV)$ ，空间复杂度 $O(NV)$ 。

二维数组代码：
```cpp
int n,V,v[MAX],w[MAX],c[MAX];  
	int f[MAX][MAX],q[MAX];   //数组模拟单调队列 
	cin>>n>>V;
	for(int i=1;i<=n;i++)
		cin>>v[i]>>w[i]>>c[i];
	for(int i=1;i<=n;i++)
		for(int j=0;j<v[i];j++)  //枚举余数
		{
			int head=0,tail=-1;
			for(int k=j;k<=V;k+=v[i])
			{
				//(j-q[tail])/v[i] 以及下面的 (j-q[head])/v[i] 对应的都是每一个k' 
				//超出可取范围，弹出队头  
				while(head<=tail&&(k-q[head])/v[i]>c[i]) head++;   
				//当前队尾解劣于新解，全部弹出
				while(head<=tail&&f[i-1][q[tail]]+(k-q[tail])/v[i]*w[i]<=f[i-1][k]) tail--;   
				q[++tail]=k;
				//每次更新直接取出队头最优解 
				f[i][k]=f[i-1][q[head]]+(k-q[head])/v[i]*w[i]; 
			}
		} 
	cout<<f[n][V];
```

### 空间上的进一步优化 

虽然时间优秀了，但是空间还不够优秀。

因为第 $i$ 层的状态只会用到第 $i-1$ 层，我们可以把这个式子用优化完全背包的思路压成一维，倒着向回推一边。考虑倒序枚举背包体积，对于每种余数 $d \in [0 , V_i-1]$ ，倒序循环 $k = \lfloor (V-d) / V_i \rfloor \sim 0$ ,这样就可以得到一个新的状态转移方程。
$$
F_{d + k * V_i} = \max_{k-C_i \leqslant k' \leqslant k-1} \{ F_{d + k' * V_i} +( k - k') * W_i \}
$$

这样我们就可以得到一个空间复杂度为 $O(V)$ 的更优秀算法。

一维数组代码：
```cpp
int n,V,v[MAX],w[MAX],c[MAX];  
	int f[MAX],q[MAX],g[MAX];   //数组模拟单调队列 
	cin>>n>>V;
	for(int i=1;i<=n;i++)
		cin>>v[i]>>w[i]>>c[i];
	for(int i=1;i<=n;i++)
	{
		memcpy(g,f,sizeof g);
		for(int j=0;j<v[i];j++)  //枚举余数
		{
			int head=0,tail=-1;
			for(int k=j;k<=V;k+=v[i])
			{
				while(head<=tail&&(k-q[head])/v[i]>c[i]) head++;
				while(head<=tail&&g[q[tail]]+(k-q[tail])/v[i]*w[i]<=g[k]) tail--;
				q[++tail]=k;
				f[k]=g[q[head]]+(k-q[head])/v[i]*w[i];
			}
		} 
	}
	cout<<f[V];
```
### 完整代码
```cpp
#include<bits/stdc++.h>
#define MAX 10010
using namespace std;

inline int read()
{
	int s=0,w=1;
	char c=getchar();
	while(!isdigit(c)) (c=='-')?w=-1:w=1,c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s*w;
}

int t1,t2,t3,t4,V;
int n,c[MAX],w[MAX],v[MAX];
int f[MAX],g[MAX];

inline void Zerone_Bag(int i)
{
	for(int k=V;k>=w[i];k--)
		f[k]=max(f[k],f[k-w[i]]+v[i]);
	return;
}
inline void Full_Bag(int i)
{
	for(int k=w[i];k<=V;k++)
		f[k]=max(f[k],f[k-w[i]]+v[i]);
	return;
}
inline void Multiple_Bag(int i)
{
	int q[MAX];
	memcpy(g,f,sizeof g);
	for(int j=0;j<w[i];j++)
	{
		int head=0,tail=-1;
		for(int k=j;k<=V;k+=w[i])
		{
			while(head<=tail&&(k-q[head])/w[i]>c[i]) head++;
			while(head<=tail&&g[q[tail]]+(k-q[tail])/w[i]*v[i]<=g[k]) tail--;
			q[++tail]=k;
			f[k]=g[q[head]]+(k-q[head])/w[i]*v[i];
		}
	}
	return;
}

int main()
{
	t1=read(),t2=read(),t3=read(),t4=read();
	V=(t3*60+t4)-(t1*60+t2);
	n=read();
	for(int i=1;i<=n;i++)
		w[i]=read(),v[i]=read(),c[i]=read();
	for(int i=1;i<=n;i++)
	{
		if(c[i]==0) Full_Bag(i);
		if(c[i]==1) Zerone_Bag(i);
		if(c[i]>=2) Multiple_Bag(i);
	}
	cout<<f[V];
	return (0-0);
}
```
### 参考资料
[多重背包优化](https://www.acwing.com/solution/content/53507/)

李煜东 《算法竞赛进阶指南》

---

## 作者：L_Y_T (赞：14)

放一个简单易懂的伪100分代码（需开02），不过这题爆读入优化的样子
```cpp
#include<iostream>

using namespace std ;

int n , m , w[10020] , c[100010] , f[100101] ,s[10500];

int a , b ;
char ch ;

int main()
{
    int pre[10];
    int t=1;
    for(int i = 1 ; i <= 2 ; i ++)//输两遍
    {
    	cin >> a >> ch >> b ;//输入
    	pre[t] = a * 60 + b ;//时间
    	t ++ ;
	}
	m = pre[2] - pre[1] ;//求时间
	cin >> n ;
    for(int i = 1 ; i <= n ; i ++)
	{
		int p ;
		cin >> w[i] >> c[i] >> s[i] ;
	 } 
    for(int i = 1 ; i <= n ; i ++)//混合背包
    if(s[i] == 0)//完全背包
    {
    	for(int j = w[i] ; j <= m ; j ++)
    	f[j] = max(f[j] , f[j-w[i]] + c[i]) ;
	}
	else//01背包和多重背包（因为01背包s[i]为1）
		for(int j = 1 ; j <= s[i] ; j ++)
		for(int k = m ; k >= w[i] ; k --)
		{
			f[k] = max(f[k] , f[k-w[i]] + c[i]) ;
		}
	cout << f[m] ;
 } 
```

---

## 作者：「　」 (赞：11)

# 传说中的完全背包问题！！！
首先给大家看一下我的结构体，不然后期程序看不懂：
```cpp
struct tree
{
    int t,c,p;
};
tree a[10001];
int s[10001][1001];
```
t是耗费时间，c是美学值，p是次数

其实本题跟普通的01背包差别并不大。
只不过需要加一个像下面一样的判断:
```cpp
for(k=1;k<=x;++k)
s[i][j]=max(s[i][j],s[i][j-a[i].t*k]+a[i].c*k);
```
其实就是将1到最多次数的所有情况遍历一遍。s是我储存DP结果的数组，而a就是储存每棵树的数据的数据，而x就是每棵树最多能看几次。

这时候你们是不是想问：那么无限次的怎么办呢？
其实也只需要一个判断，因为看得再多次，也不可能超出题目给出的时间限制。
也就是说每棵树都有一个最大观赏次数，而它就是极限次数：（总时间/当前树观赏一次的时间）和（题目给出次数）中小的那个
```cpp
x=min(a[i].p,j/a[i].t);
```

但其实可以在节约一下空间，也就是DP可以重复利用空间，使空间的利用率最大。
从而就变成了这样：
```cpp
for(i=1;i<=n;++i)
    {
        for(j=t;j>=a[i].t;--j)
        {
        	x=min(a[i].p,j/a[i].t);
            for(k=1;k<=x;++k)
            s[j]=max(s[j],s[j-a[i].t*k]+a[i].c*k);
        }
    }
```
记得要倒序DP，因为前面的DP结果会影响后面的，如果先替换了，就会导致DP结果错误。

但是，我们发现，其实for(k=1;k<=x;++k)一直是在与自己进行DP，也就是说，只要我们略微修改一下状态转移方程，就可以将3重循环变为2重循环：
```cpp
for(i=1;i<=n;++i)
    {
    	if(a[i].p==0)
        for(j=a[i].t;j<=t;++j)
        {
            s[j]=max(s[j],s[j-a[i].t]+a[i].c);
        }
        else
        for(j=t;j>=a[i].t;--j)
        {
            for(k=1;k<=a[i].p;++k)
            s[j]=max(s[j],s[j-a[i].t*k]+a[i].c*k);
        }
    }
```
只需判断其是否是无限就行了。

所以将上述结构拼凑在一起就可以AC了。

---

## 作者：critnos (赞：6)

竟然没有记忆化搜索！？

过背包的两大另类解：[随机贪心](https://www.luogu.com.cn/blog/2-6-5-3-5/solution-p1048)和记忆化搜索

但是这题是多重背包，所以就没办法用随机贪心了

记忆化搜索，就是把已经算过的结果存入一张表，然后下次如果要使用就直接读取答案。

记忆化搜索其实是这么敲的：

1. 敲出一个裸暴力（推荐DFS）

```cpp
int dfs(int z,int y)
{
	if(z==n) return 0;
	int mx=0;
	for(int i=0;y+a[z]*i<=t&&i<=p[z];i++)
		mx=max(mx,dfs(z+1,y+a[z]*i)+w[z]*i);
	return mx;
}
```
2. 函数里有几个参数，就开几维数组（注意估算每个参数的上限）

```cpp
int j[10005][1005];//z和y的上限分别是10000和1000
```
3. 加上一些固定的代码

```cpp
int dfs(int z,int y)
{
	if(z==n) return 0;
	if(j[z][y]!=-1) return j[z][y];//这是必须的
	int mx=0;
	for(int i=0;y+a[z]*i<=t&&i<=p[z];i++)
		mx=max(mx,dfs(z+1,y+a[z]*i)+w[z]*i);
	return j[z][y]=mx;//必须++
}
```
注意加上：

```cpp
memset(j,-1,sizeof(j));
```
记忆化搜索的好处：

* 不用推动态转移方程

* 不用像DP那么灵活

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,mx;
int a[10005],w[10005],p[10005];
int j[10005][1005];
int dfs(int z,int y)
{
	if(z==n) return 0;
	if(j[z][y]!=-1) return j[z][y];
	int mx=0;
	for(int i=0;y+a[z]*i<=t&&i<=p[z];i++)
		mx=max(mx,dfs(z+1,y+a[z]*i)+w[z]*i);
	return j[z][y]=mx;
}
int main()
{
	memset(j,-1,sizeof(j));
	int tsh,tsm,teh,tem,i;
	char q;
	cin>>tsh>>q>>tsm>>teh>>q>>tem>>n;
	t=teh*60+tem-tsh*60-tsm;
	for(i=0;i<n;i++) 
	{
		scanf("%d %d %d",&a[i],&w[i],&p[i]);
		if(p[i]==0) p[i]=1e9;
	}
	cout<<dfs(0,0);
}
```
当然，要开O2（卡常万岁！！！）

---

## 作者：孙广宸 (赞：5)

~~本蒟蒻的第一篇题解~~

~~管理员大佬求过~~
****
这道题就是一个裸的**多重背包**，唯一要注意的地方是看花时间的处理

具体思路楼下大佬们也都很清楚地讲过了，我在这里对**PJ组**常用的背包模型做一个**总结**

~~神犇可直接跳过~~

****
```cpp
//多重背包 
for(int i=1;i<=n;i++)
	for(int j=m;j>=0;j--)
		for(int k=0;k<=s[i];k++)
		{
			if(j-k*v[i]<0)break;
			f[j]=max(f[j],f[j-k*v[i]]+k*w[i])
		}
//完全背包 
for(int i=1;i<=n;i++)
	for(v=w[i];v<=m;v++)
		if(f[v-w[i]]+c[i]>f[v])f[v]=f[v-w[i]]+c[i];
//零一背包 
for(int i=1;i<=n;i++)
	for(int v=m;v>=w[i];v--)
		if(f[v-w[i]]+c[i]>f[v])
			f[v]=f[v-w[i]]+c[i];
```



****


### 注意事项：（敲黑板）

1.多重，零一背包第二层循环都是**倒序**（从V到W【i】），为了避免重复

2.完全背包是正序，因为只有重复，才能‘完全’

### 巧妙化用：（重中之重）

1.题目如果让你求最小的剩余空间，你可以把问题转化为求最大的已占据空间

2.有的题目背包可能要存两个价值，不要方，增加一层循环就秒杀了

3.灵活找到题目中可以作为‘重量’的量，化用模板，决胜千里

最后祝大家NOIP2018 RP++

~~（滑稽）~~

---

## 作者：lijianyangyf (赞：4)

蒟蒻的第一个题解，求dalao勿喷。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001],c[1001],t[1001],f[10010],n,m;//美学值，时间，次数，答案等等
int main()
{
    int x1,y1,x2,y2;
    scanf("%d:%d %d:%d",&x1,&y1,&x2,&y2);
    if(y1>y2)y2+=60,x2--;
    m=(x2-x1)*60+y2-y1;//计算时间
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d%d%d",&a[i],&c[i],&t[i]);
    for(int i=1;i<=n;i++)
    {
        if(t[i]==0)//判断是不是无限次数的
        {
            for(int j=a[i];j<=m;j++)//完全背包
                f[j]=max(f[j],f[j-a[i]]+c[i]);
        }
        else
        {
            for(int k=1;k<=t[i];k++)//循环次数，求最多的那个情况，其实可以剪枝的，但我懒得剪（说得好像我很棒的样子）
            {
                for(int j=m;j>=a[i];j--)//01背包
                {
                    f[j]=max(f[j],f[j-a[i]]+c[i]);
                }
            }
        }
    }
    printf("%d\n",f[m]);
}
```

---

## 作者：lcglcg (赞：3)

这是一道裸的混合背包（01+完全+多重）

这题的话有两种解法

# 1.01+完全
## 思路
我们可以把多重背包进行二进制拆分，将其转化成01背包问题。

那么，什么是二进制拆分呢？

首先，一般的多重背包的递推公式是这样的

f[i][v]=max{f[i-1][v-k* t[i]]+k* c[i]|0<=k<=p[i]}

我们考虑将k进行二进制拆分，从而用O(logp[i])的复杂度来枚举第i件物品选择多少个。

例如：
如果一个物品可以选9件，则可以拆成1,2,4,2四种物品，这样就可以表示选0-9范围内的所有个数的改物品。

那么怎么拆呢？

对于一个数，我们先减去2^0,再减去2^1……直到不能减为止。

比如11

11-1=10

10-2=8

8-4=4

所以11应该拆成1，2，4，4

那么怎么去实现呢

对于一个物品，我们把它拆分后，对于每一个拆分的数s，就相当于新建了一个价值为c[i]* s,代价为t[i]* s的新物品。

代码实现：
```cpp
int _p=p[i]-1;
//注意要-1 
for(int j=2;j<=_p;j<<=1)
{
	_p-=j;
	c[++tot]=j*c[i];
	t[tot]=j*t[i];
}
if(_p)
{
c[++tot]=_p*c[i];
t[tot]=_p*t[i];
}
```
将多重拆成01后，对于每一个物品i，我们先判断它是01还是完全，
然后决定j从大到小还是从小到大枚举。

时间复杂度为![](https://cdn.luogu.com.cn/upload/pic/71619.png)
## 代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,dp[10001],t[100001],c[100001],p[10001],tot,tim;

int main()
{
	int x1,y1,x2,y2;
	scanf("%d:%d %d:%d %d",&x1,&y1,&x2,&y2,&n);
	if(y1>y2)
	{
		y2+=60;
		x2--;
	}
	tim=(x2-x1)*60+y2-y1;
	for(int i=1;i<=n;i++)scanf("%d%d%d",&t[i],&c[i],&p[i]);
	
	
	tot=n;
	for(int i=1;i<=n;i++)//将多重背包拆分 
	{
		if(p[i]<=1)continue;
		//如果是01或完全,跳过就行了 
		
		int _p=p[i]-1;
		//注意要-1 
		for(int j=2;j<=_p;j<<=1)
		{
			_p-=j;
			c[++tot]=j*c[i];
			t[tot]=j*t[i];
		}
		if(_p)
		{
			c[++tot]=_p*c[i];
			t[tot]=_p*t[i];
		}
	}



	for(int i=1;i<=tot;i++)
	{
		if(i<=n&&p[i]==0)//如果是完全背包
		//注意,如果这里不加i<=n,m[i]可能会越界 
			{
				for(int j=1;j<=tim;j++)
				if(j>=t[i])dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
			}
			
		else//如果是01背包 
			for(int j=tim;j>=1;j--)
				if(j>=t[i])dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
	}
	
	
	printf("%d",dp[tim]);
	return 0;
}
```
# 2.三种背包混合
## 思路

把完全背包和多重背包都转化成01背包。

完全背包怎么转化成01背包呢？

其实一样物品最多只能选time/t[i]件，所以我们只需p[i]=time/t[i],
然后和多重背包一样拆分

时间复杂度为![](https://cdn.luogu.com.cn/upload/pic/71620.png) 
## 代码
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
int n,dp[10001],t[100001],c[100001],p[10001],tot,tim;

int main()
{
	int x1,y1,x2,y2;
	scanf("%d:%d %d:%d %d",&x1,&y1,&x2,&y2,&n);
	if(y1>y2)
	{
		y2+=60;
		x2--;
	}
	tim=(x2-x1)*60+y2-y1;
	for(int i=1;i<=n;i++)scanf("%d%d%d",&t[i],&c[i],&p[i]);
	
	 
	tot=n;
	for(int i=1;i<=n;i++)//二进制拆分 
	{
		if(p[i]==1)continue;
		//如果是01,跳过就行了 
		
		if(p[i]==0)//如果是完全背包 
			p[i]=tim/t[i];


		int _p=p[i]-1;
		//注意要-1 
		for(int j=2;j<=_p;j<<=1)
		{
			_p-=j;
			c[++tot]=j*c[i];
			t[tot]=j*t[i];
		}
		if(_p)
		{
			c[++tot]=_p*c[i];
			t[tot]=_p*t[i];
		}
	}
	
	for(int i=1;i<=tot;i++)
		for(int j=tim;j>=1;j--)
				if(j>=t[i])dp[j]=max(dp[j],dp[j-t[i]]+c[i]);
				
	printf("%d",dp[tim]);
	return 0;
		
}
```
# 最后
祝大家CSP-J/S 2019 while（RP++）！！！







---

## 作者：lzyqwq (赞：2)

# 题目分析

首先这是个混合背包，很烦，所以，我们要把他转化成不烦的。

于是，我的 OI 导师 FJ 教我了直接由混合背包转化成 01 背包的方法。转化主要分为四步走，接下来我们一起康康。

### First Things First。

为了方便讲解，我把定义的变量、数组以及结构体先放上来。

```cpp
const int M=1005,N=10005,K=70005;//偷个小懒，可以用#define完成
struct lim
{
	int w,c;//w表示耗费时间，c表示美学值
}f2[N];//一开始筛选物品用的完全背包樱花树的数组
int f[M],w1[N],c1[N],s1[N],wf[K],cf[K];
//f是dp的数组，w1、c1、s1非完全背包樱花树的时间、美学
//值、棵数，wf、cf存放二进制拆分后转化成01背包的樱花
//树。由于棵树最多10000，而二进制拆分会拆出来新的、更
//多的，所以wf和cf适当开大一点（由于要二进制拆分是log，而最多看pi遍不超过100，所以是log100×10000，70000就够了）
```

### 第一步：完整输入数据，并筛选出属于完全背包的物品。

这个没什么好说的，就是普通的读入加上特判 $P_i$ 是否为 $0$。

```cpp
int h1,m1,h2,m2;
scanf("%d:%d%d:%d",&h1,&m1,&h2,&m2);//这边scanf读入可以把字符的位置占用（预处理）掉，使我们读出整数
int n,m;
m=(h2*60+m2)-(h1*60+m1);//结束时间减起始时间为总时间，通过观察样例可知欣赏所用时间单位为分钟，所以把总时间用分钟的单位计算
scanf("%d",&n);
int k=0,l=0;//k为非完全背包物品个数，l为完全背包物品个数，都当下标使用
for(int i=1;i<=n;i++)
{
	int x,y,z;
	scanf("%d%d%d",&x,&y,&z);
	if(z)//如果不是完全背包
	{
		k++;//存入非完全背包
		w1[k]=x;
		c1[k]=y;
		s1[k]=z;
	}
	else//否则存入完全背包
	{
		l++;
		f2[l].w=x;
		f2[l].c=y;
	}
}
```

### 第二步：将完全背包中的樱花按照美学值从小到大排序，删除掉“残次品”，然后对于剩下的每一棵樱花树，用总时间除以这棵樱花树的欣赏时间，得出理论最大欣赏次数，转化成为多重背包，放入非完全背包（01 背包物品也可以看作物品个数为 1 的多重背包物品，所以非完全背包其实就是多重背包）。

这里对“残次品”的定义是：如果一棵樱花树的欣赏时间比别的樱花树长，但是美学值却比别的樱花树低，那肯定是去欣赏别的樱花树，而不是这棵。所以可以直接不要。

由于总共只有 $m$ 分钟，而这棵樱花树需要 $T_i$ 分钟，所以最多只能欣赏这颗樱花树 $\left\lfloor\dfrac{x}{T_i}\right\rfloor$ 分钟(向下取整因为分钟是整数，而没有可以欣赏半次这种说法。所以要取整。因为向上取整的话会超出总时间，所以要向下。比如说 $\dfrac{52}{8}=6.5$，向上取整是 $7$，但是在 $52$ 分钟中只有 $6.5$ 个 $8$，不能到达 $7$ 个 $8$，所以不能向上，而要向下。而没有欣赏 $0.5$ 次的说法，肯定是一次一次欣赏，所以要取整）。

因为是结构体，所以我们排序要先写排序函数。

```cpp
//排序函数
bool com(lim a,lim b)
{
	return a.c<b.c;
}

//第二步具体操作
if(l==1)//这边特判一下，如果只有一个完全背包樱花树就不存在比别的多花时间这种情况，所以直接转化成
{
    k++;
    w1[k]=f2[l].w;
    c1[k]=f2[l].c;
    s1[k]=m/w1[k];
}
else
{
    sort(f2+1,f2+1+l,com);//从小到大排序，注意范围
    for(int i=1;i<=l-1;i++)
    {
        bool q=0;//是否为残次品，=1为是，=0为否
        for(int j=i+1;j<=l;j++)//从小到大排序，i前面的美学值肯定小于等于i，i美学值更大，所以在前i个中肯定不算残次品，所以从i的下一个，即i+1，开始找
        {
            if(f2[i].w>f2[j].w&&f2[i].c<f2[j].c)//如果当前樱花树花的时间更长美学值反而少，说明是残次品，直接不要
            {
                q=1;//是残次品
                break;//不要
            }
        }
        if(!q)//不是残次品
        {
            k++;//处理后放入非完全背包，当作多重背包处理
            w1[k]=f2[i].w;
            c1[k]=f2[i].c;
            s1[k]=m/w1[k];
        }
    }
    k++;//最后那个是美学值最大的，肯定不是残次品，所以处理后直接放入非完全背包
    w1[k]=f2[l].w;
    c1[k]=f2[l].c;
    s1[k]=m/w1[k];
}
```

### 第三步：对非完全背包内的樱花树进行二进制拆分，将非完全背包转化为 01 背包。

对于二进制拆分，我将做出证明，即：为什么一个数 $n$ 二进制拆分后，可以表示出 $1...n$ 的所有数。

首先，我们要明白，二进制拆分指的是把一个自然数 $n$ 拆分成 $1+2+4+...+2^k+[n-(2^{k+1}-1)]$ 的形式。

解释一下中括号中的内容，前面我们已经拆出了 $2^0+2^1+...+2^k$ 的部分，但是不一定能正好拆完，所以肯定会有剩余不能被拆分的部分，不能拆的就是 $n$ 减去拆的部分。

我们令 $S=2^0+2^1+...+2^k$，即二进制拆的部分。

则 $2S=2 \times (2^0+2^1+...+2^k)=2×2^0+2 \times 2^1+...+2 \times 2^k$。

然后 $2$ 就相当于 $2^1$，我们把以 $2$ 为底的幂的指数相加，最后得出 $2S=2^1+2^2+...+2^{k+1}$。

所以 $S=2S-S=(2^1+2^2+...+2^{k+1})-(2^0+2^1+...+2^k)$，把同底（为 $2$）的幂消掉，得出 $S=2^{k+1}-2^0=2^{k+1}-1$。

原来是 $n$，二进制拆了 $S$，所以剩余不能被拆分的部分为 $n-S=n-(2^{k+1}-1)$。为了体现“整体”，所以加了中括号。

解释完之后，我们举例说明二进制拆分。以 $12$ 为例，$12=1+2+4+5$，写成二进制之后为：

| 原数      / | 二进制 |
| :----------:       | :----------: |
| 1 | 0001 |
| 2 | 0010 |
| 4	| 0100 |
| 5	| 0101 |

通过观察我们发现，每一位二进制上都有 $1$（最高位可以通过 $4+5$ 进位得到），这说明我们可以通过对这些 $1$ 进行排列组合，组成 $1...n$ 中所有的数。

证明了二进制拆分的正确性，对于每一棵樱花树，我们对其欣赏次数进行二进制拆分，就可以凑出欣赏 $1...n$ 次樱花中所有的次数了。

我们接下来来看代码：
```cpp
int p=0;//转化成01背包后物品个数，做下标
for(int i=1;i<=k;i++)//一个一个物品拆过去，到k是因为无论之前是非完全背包还是完全背包都放在了非完全背包里
{
    for(int j=1;s1[i]>0;j<<=1)//只要还有没拆完的就继续拆，保证s1[i]>0，>=0也没关系，下面有解释，j<<=1就是说j的二进制左移一位，相当于j*=2
    {
        int d=min(j,s1[i]);
        /*s1一直在拆，如果够拆，则s1[i]中包含j的部
        分，s1[i]>=j，所以最小值返回j，是二进制拆
        分新拆出来的部分；如果不够拆，说明j超过
        s1[i]，j>s1[i]，最小值返回s1[i]，此时s1[i]
        是不够拆的剩余部分，也要把它算上。上面如果
        是s1[i]>=0的话，则会存在s1[i]=0的情况，而j
        是从1开始一直乘2，所以>0，因此这种情况下
        j>s1[i]，最小值返回s1[i]，即0，而0×d还是
        0，所以会放入时间、美学值都为0的樱花树，都
        为0既不加时间，也不加美学值，所以对dp没影
        响，也没关系*/
        p++;//放入二进制拆分的樱花树，物品个数+1
        wf[p]=d*w1[i];//时间和美学值拆成d份
        cf[p]=d*c1[i];
        s1[i]-=j;//拆的就没了
    }
}
```

### 第四步：01 背包。

模板了，不用多说，用 $f[j]$ 表示看 $j$ 分钟获得的最大美学值。状态转移方程为 $f[j]=\max(f[j],f[j-wf[i]]+cf[i])$，直接上代码。

```cpp
for(int i=1;i<=p;i++)//p棵树
{
	for(int j=m;j>=wf[i];j--)
	{
		f[j]=max(f[j],f[j-wf[i]]+cf[i]);
		/*考虑看不看这颗樱花树，不看则是f[j]，看时由于
		这棵树需要wf[i]的时间，所以看这棵树必须至
		少有wf[i]的时间，而最多有m的时间，所以j的范围
		是m...wf[i]。看这棵树要wf[i]的时间，能获得
		cf[i]的美学值，所以之前要j-wf[i]的时间，看这棵
		树的美学值f[j-wf[i]]+cf[i]由于是01背包，所以要
		倒着往前扫，因为如果从前往后扫前面的用了一次，
		后面的转移时要用到前面的于是又用了一次，就不是
		01背包了，虽然对多重没什么影响，但是之前是01背
		包的樱花树就被重复看了。而从后往前，后面先看
		掉，此时前面还没看，所以没有重复，而前面的不会
		用到后面的，也不会重复后面。这样后面不重复前
		面，前面不重复后面，就是正宗、土生土长的01背包*/
	}
}
```
最后我们输出的答案就是 $f[m]$。

# AC 代码

讲解中都写过注释了，所以这里不再重复写（码字不易，互相体谅，码风保证不毒瘤）。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1005,N=10005,K=70005;
struct lim
{
	int w,c;
}f2[N];
int f[M],w1[N],c1[N],s1[N],wf[K],cf[K];
bool com(lim a,lim b)
{
	return a.c<b.c;
}
int main()
{
	//第一步
	int h1,m1,h2,m2;
	scanf("%d:%d%d:%d",&h1,&m1,&h2,&m2);
	int n,m;
	m=(h2*60+m2)-(h1*60+m1);
	scanf("%d",&n);
	int k=0,l=0;
	for(int i=1;i<=n;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		if(z)
		{
			k++;
			w1[k]=x;
			c1[k]=y;
			s1[k]=z;
		}
		else
		{
			l++;
			f2[l].w=x;
			f2[l].c=y;
		}
	}
	//第二步
	if(l==1)
	{
		k++;
		w1[k]=f2[l].w;
		c1[k]=f2[l].c;
		s1[k]=m/w1[k];
	}
	else
	{
		sort(f2+1,f2+1+l,com);
		for(int i=1;i<=l-1;i++)
		{
			bool q=0;
			for(int j=i+1;j<=l;j++)
			{
				if(f2[i].w>f2[j].w&&f2[i].c<f2[j].c)
				{
					q=1;
					break;
				}
			}
			if(!q)
			{
				k++;
				w1[k]=f2[i].w;
				c1[k]=f2[i].c;
				s1[k]=m/w1[k];
			}
		}
		k++;
		w1[k]=f2[l].w;
		c1[k]=f2[l].c;
		s1[k]=m/w1[k];
	}
	//第三步
	int p=0;
	for(int i=1;i<=k;i++)
	{
		for(int j=1;s1[i]>0;j<<=1)
		{
			int d=min(j,s1[i]);
			p++;
			wf[p]=d*w1[i];
			cf[p]=d*c1[i];
			s1[i]-=j;
		}
	}
	//第四步
	for(int i=1;i<=p;i++)
	{
		for(int j=m;j>=wf[i];j--)
		{
			f[j]=max(f[j],f[j-wf[i]]+cf[i]);
		}
	}
	printf("%d\n",f[m]);
	return 0;//完结撒花，此时0:13
}
```
跪求过审 orz，虽然今晚麻烦了兔队很多，但还是要表示感谢！！！

---

## 作者：人殇物已非 (赞：2)

# 暴力出奇迹！

这个题简直是有毒！

好好的搞什么时间点到时间点？

卡了我半天;while for使劲用，最后发现scanf就好了。。。

由于数据范围小，直接暴力转换为01背包就好了，完美！



    
    
        
```cpp
include<bits/stdc++.h> //万能头；
using namespace std;
int c[3000];
int v[3000];
int f[3000];
int num[3000];
int main(){
//以上这部分死活都转换不成代码。。。。。。。
    int t=0,n,a,l,p,q,x,y;
    scanf("%d:%d %d:%d %d",&q,&p,&x,&y,&n); //令人无奈的“简单的”输入；
    if(x<q) {cout<<0; return 0;}
    if(x==q && y<=p) {cout<<0; return 0;}//以上这两个是判断去学校的时间是否大于现在时间，若大于。。。。还看个辣子樱花
    if(y>=p) {t+=y-p;t+=60*(x-q);}//后分钟数大于前分钟数时
    if(y<p) {t+=60-p;t+=60*(x-q-1);t+=y;}   //先加到前的满时，再小时差，再加上后的那几分钟；
    l=n;//全部换为01的总长的初值；
    for(int i=1;i<=n;i++)
    {
        cin>>c[i]>>v[i]>>num[i];
        if(num[i]!=1 && num[i]!=0)
        {
            a=i;
            for(int j=2;j<=num[a];j++) //由于前面已经输入时保存了一个，循环从2开始即可以在这里少循环一个，达到要的num；
            {
                c[++l]=c[i];v[l]=v[i];//注意v[l]不能++；
            }
        }
        if(num[i]==0)
        {
            for(int j=1;j<=50;j++)//无限？直接给你50个！（40不够）
            {
                c[++l]=c[i];v[l]=v[i];
            }
        }
    }
    for(int i=1;i<=l;++i)
      for(int j=t;j>=c[i];--j) 
          f[j]=max(f[j],f[j-c[i]]+v[i]);//一维的01背包；
    cout<<f[t]; //答案！！
    return 0;
}
```

---

## 作者：DEVILK (赞：2)

更好的阅读体验点这里：[博客传送门](https://www.cnblogs.com/devilk-sjj/p/9065567.html)


一道01背包、完全背包、多重背包的混合题目。

01背包可以看做是只有一件物品的多重背包，所以可将三类背包问题化为两类：

1. 多重背包
2. 完全背包

但多重背包直接做时间复杂度太大，所以需要二进制优化，此时如何处理完全背包问题？

可以将完全背包的数量看做一个比较大，而数组中也存的开的数，比如$9999$，然后当做多重背包来做.

```cpp
//348ms
#include<iostream>
#include<cstdio>
using namespace std;

const int MAXN = 1000000 + 1;
const int INF = 9999;

int n, T;
int t[MAXN], c[MAXN], p[MAXN];
int a[MAXN], b[MAXN], f[MAXN];
struct Time {
    int h, min;
}s, e;

inline int read() {
    int x=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(ch>='0' && ch<='9')
        x=(x<<3) + (x<<1) + ch-48, ch = getchar();
    return x * f;
}

int main() {
    s.h = read(), s.min = read();
    e.h = read(), e.min = read();
    n = read();
    T = e.min - s.min + (e.h - s.h) * 60;
    int cnt = 0;
    for(int i=1; i<=n; ++i) {
        t[i] = read(), c[i] = read(), p[i] = read();
        if(!p[i]) p[i] = INF;
        int s = 1;
        while(p[i] > s) {
            a[++cnt] = t[i] * s;
            b[cnt] = c[i] * s;
            p[i] -= s;
            s <<= 1;
        }
        if(p[i]) {
            a[++cnt] = t[i] * p[i];
            b[cnt] = c[i] * p[i];
        }
    }
    for(int i=1; i<=cnt; ++i)
        for(int j=T; j>=a[i]; --j)
            f[j] = max(f[j], f[j - a[i]] + b[i]);
    printf("%d\n", f[T]);
}
```
没有用二进制优化的做法开了$O_2$优化也可以过，但是耗时比不开$O_2$优化之后的背包还要慢上不少

```cpp
// luogu-judger-enable-o2
//1040ms
#include<iostream>
#include<cstdio>
#define re register
using namespace std;

const int MAXN = 1000000 + 1;

int n, T;
int t[MAXN], c[MAXN], p[MAXN];
int a[MAXN], b[MAXN], f[MAXN];
struct Time {
    int h, min;
}s, e;

inline int read() {
    int x=0, f=1; char ch=getchar();
    while(ch<'0' || ch>'9') {
        if(ch == '-') f = -1;
        ch = getchar();
    }
    while(ch>='0' && ch<='9')
        x=(x<<3) + (x<<1) + ch-48, ch = getchar();
    return x * f;
}

int main() {
    s.h = read(), s.min = read();
    e.h = read(), e.min = read();
    n = read();
    T = e.min - s.min + (e.h - s.h) * 60;
    int cnt = 0;
    for(re int i=1; i<=n; ++i)
        t[i] = read(), c[i] = read(), p[i] = read();
    for(re int i=1; i<=n; ++i) {
        if(p[i] == 0) {
            for(re int j=t[i]; j<=T; ++j)
                f[j] = max(f[j], f[j - t[i]] + c[i]);
        }
        else{
            for(re int k=1; k<=p[i]; ++k)
                for(re int j=T; j>=t[i]; --j)
                    f[j] = max(f[j], f[j - t[i]] + c[i]);
        }
    }
    printf("%d", f[T]);
}
```

---

## 作者：ModestCoder_ (赞：2)

又是一道DP水题==

有限背包？名称我不清楚~~

先把总时间算出来

比如样例：7:00-6:50=10min

f[i]表示用时最多为i最大美丽值

三重循环

一重：枚举树

二重：枚举用时

三重：枚举看几遍

另外
别忘了特判看无数遍的情况



```cpp
uses math;
var
    s:ansistring;
    f:array[0..10000] of longint;
    n,m,i,a,b,c,j,k,x,y,ta,tb:longint;
begin
    readln(s);
    val(copy(s,1,pos(':',s)-1),x);
    delete(s,1,pos(':',s));
    val(copy(s,1,pos(' ',s)-1),y);
    delete(s,1,pos(' ',s));
    ta:=x*60+y;
    val(copy(s,1,pos(':',s)-1),x);
    delete(s,1,pos(':',s));
    val(copy(s,1,pos(' ',s)-1),y);
    delete(s,1,pos(' ',s));
    tb:=x*60+y;
    m:=tb-ta;
    val(s,n);
    for i:=1 to n do
        begin
            readln(a,b,c);
            if c=0 then //特判一下，给他一个大数
                c:=m;
            for j:=m downto a do
                for k:=1 to min(j div a,c) do
                    f[j]:=max(f[j],f[j-k*a]+k*b);
        end;
    writeln(f[m]);
end.
```

---

## 作者：Lee02 (赞：1)

## 多重背包板子题

### 状态转移方程：f[j]=max(f[j],f[j-c[i]+w[i]);
	最直接的想法，就是将完全、01、分组背包分开处理，把分组背包看作是有tim[i]个物体来处理。
   但是这种方法处理，时间复杂度就会很高，具体是多少我就不在这写了~~主要是不会Latex~~
   ```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int c[10005],w[10005],tim[10005],f[10000005];
int main ()
{
	int x1,yy,x2,y2;
	scanf("%d:%d %d:%d",&x1,&yy,&x2,&y2);
    if(yy>y2)
    {
        y2+=60;
        x2--;
    }
    int m=(x2-x1)*60+y2-yy;
    cin>>n;
    for(int i=1;i<=n;i++)
    	cin>>c[i]>>w[i]>>tim[i];
    for(int i=1;i<=n;i++)
    {
    	if(!tim[i])
    	{
    		for(int j=c[i];j<=m;j++)
    		f[j]=max(f[j],f[j-c[i]]+w[i]);
		}
		else
		{
			for(int k=1;k<=tim[i];k++)
			{
				for(int j=m;j>=c[i];j--)
				f[j]=max(f[j],f[j-c[i]]+w[i]); 
			}
		}
	}
	cout<<f[m];
	return 0;
}
```
这个程序只能得80pts，剩下两个点T掉，~~但是吸氧就A了~~

## 下面看正解

由于任何一个数都能通过2的次方的和表示，所以我们可以将每一个物品的个数进行二进制拆解，最后将次数和值相乘即可。

比如说，35=1+2+4+8+16+4

对于完全背包来说，我们只需要设一个非常大的数，使得它并不会影响我们的程序就行了

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int c[10005],w[10005],tim[10005],f[10000005],cc[1000001],ww[1000001],top;
void ll()
{
	for(int i=1;i<=n;i++)
	{
		int base=1;
		while(tim[i]!=0)
		{
			cc[++top]=c[i]*base;
			ww[top]=w[i]*base;
			tim[i]-=base;
			base<<=1;
			if(tim[i]<base)
			{
				cc[++top]=c[i]*tim[i];
				ww[top]=w[i]*tim[i];
				break;
			}
		}
	}
}
int main ()
{
	int x1,yy,x2,y2;
	scanf("%d:%d %d:%d",&x1,&yy,&x2,&y2);
    if(yy>y2)
    {
        y2+=60;
        x2--;
    }
    int m=(x2-x1)*60+y2-yy;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>c[i]>>w[i]>>tim[i];
    	if(!tim[i]) tim[i]=9999999;
	}
	ll();
    for(int i=1;i<=top;i++)
    {
    	for(int j=m;j>=cc[i];j--)
    	f[j]=max(f[j],f[j-cc[i]]+ww[i]);
	}
	cout<<f[m];
	return 0;
}
```

## 超级强的做法

## 单调队列

通过单调队列进行优化，我们能将时间复杂度降至O(NM)的程度，和01背包一样。

这个我还不太懂，暂时就不贴代码了，有兴趣的同学可查阅《算法竞赛进阶指南》



---

## 作者：Aehnuwx (赞：1)

这道题大概输入也算是一个奇技淫巧了

我看题解一大片一大片地都用`scanf`，

但是我让你读入几千万次，你`scanf`难道不会超时吗（~~虽然根本不会出这种题~~）？

那你怎么办？

```cpp
int read() {
	int x = 0, ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x;
} 
```

读入优化，你值得拥有。

读入类似`23:33`这样的时间时，就可以直接绕过中间的`:`了！

还有，为什么你们都用离线做法啊，这题直接在线就行了

我个人认为，我的代码还是比较通俗易懂的

> Talk is cheap, show me the code.

$\rm code$

```cpp
# pragma GCC optimize(2)
# pragma GCC optimize(3)
# pragma GCC optimize("Ofast")
// 不加这些硬核优化，你就会 TLE
# include <bits/stdc++.h>
using namespace std;
const int maxN = 10005;
int n, m, dp[maxN];
// n 的意思去看题目
// m 的意思下面会说
// dp[] 就是背包数组
struct Time {
	int h, m;
    // h -> hour，小时
    // m -> minute，分钟
};
// 这里把时间用一个结构体封装起来，这样的话看得清楚一些。这也是一个好的 OIer，一个好的程序员的基本素养（雾）
Time Ts, Te;
int read();
void write(int);
void DPfinite(int, int, int);
// finite：有限的
void DPinfinite(int, int);
// infinite：无限的，我们平时常说的 INF 就是它的缩写哦
int main() {
	Ts.h = read(), Ts.m = read();
	Te.h = read(), Te.m = read();
	m = 60 * (Te.h - Ts.h) + Te.m - Ts.m;
  	// m 指两个时间之间还有多长的时间
	n = read();
	for(int i = 1; i <= n; ++i) {
		int t = read(), c = read(), p = read();
		p ? DPfinite(t, c, p) : DPinfinite(t, c);
        // 使用三目运算符，小小地优化一下常数
        // 若 p 非 0，跑有限次背包
        // 否则，跑完全背包，即无限次背包
	}
	cout << dp[m];
    // 输出最大价值
	return 0;
}
int read() {
	int x = 0, ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	return x;
} 
void write(int x) {
	if(x > 9) write(x / 10);
	write(x % 10 + 48);
}
// 可爱的 IO 优化
void DPfinite(int t, int c, int p) {
	for(int i = 1; i <= p; ++i)
		for(int j = m; j >= t; --j)
			dp[j] = max(dp[j], dp[j - t] + c);
    // 跑有限次背包（多重+01）
}
void DPinfinite(int t, int c) {
	for(int i = t; i <= m; ++i)
		dp[i] = max(dp[i], dp[i - t] + c);
    // 跑无限次背包（完全）
}
```

因为我觉得应该不会有没学过背包的人来做这题，所以跑 DP 的过程就没有太多的注释了。

求管理通过qaq

---

## 作者：柠青哟 (赞：1)

其实就是一道裸的多重背包，稍加修改即可。
首先上多重背包的模板。
```c
#include<bits/stdc++.h>
using namespace std;
int bag,w[1001],v[1001],n[1001],f[1001],a;
void bagg(int w,int v){
	int i;
	for(i=bag;i>=w;i--){
		f[i]=max(f[i],f[i-w]+v);
	}
}//01背包 
void bagcomplete(int w,int v){
	int i;
	for(i=w;i<=bag;i++){
		f[i]=max(f[i],f[i-w]+v);
	}
}//完全背包 
void bagmultip(int w,int v,int n){
	if(bag<=n*w){//如果总容量比这个物品的容量要小，那么这个物品可以直到取完，相当于完全背包

		bagcomplete(w,v);
		return;
	}
	else{//否则就将多重背包转化为01背包
		int k=1;
		while(k<=n){
			bagg(k*w,k*v);
			n-=k;
			k*=2;
		}
	}//增加了二进制优化 
	bagg(n*w,n*v);
}//多重背包 
int main(){
	cin>>a>>bag;
	for(int i=1;i<=a;i++){
		cin>>w[i]>>v[i]>>n[i];
	}
	for(int i=1;i<=a;i++){
		bagmultip(w[i],v[i],n[i]);
	}
	cout<<f[bag];
}
```
参考了https://blog.csdn.net/qq_38984851/article/details/81133840 的代码；
不要在意奇怪的变量名啦

然后是此题的AC代码，只需在转换完全背包那里修改一下即可。
```c
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d,m,g,w[10001],v[10001],n[10001],f[10001];
void bagg(int w,int v){
	int i;
	for(i=m;i>=w;i--){
		f[i]=max(f[i],f[i-w]+v);
	}
}
void bagcomplete(int w,int v){
	int i;
	for(i=w;i<=m;i++){
		f[i]=max(f[i],f[i-w]+v);
	}
}
void bagmultip(int w,int v,int n){
	if(m<=n*w||n==0){//如果为次数为0的话，也要转化完全背包 
		bagcomplete(w,v);
		return;
	}
	else{
		int k=1;
		while(k<=n){
			bagg(k*w,k*v);
			n-=k;
			k*=2;
		}
	}
	bagg(n*w,n*v);
}
int main(){
	scanf("%d:%d %d:%d",&a,&b,&c,&d);
	if(b>d) m=60-b+d+(c-a-1)*60;
	else m=(c-a)*60+d-b;//计算出时间m 
	cin>>g;//樱花树棵数 
	for(int i=1;i<=g;i++){
		scanf("%d%d%d",&w[i],&v[i],&n[i]);//一定要用scanf，80分的惨痛教训QWQ 
	}
	for(int i=1;i<=g;i++){
		bagmultip(w[i],v[i],n[i]);	
	}
	cout<<f[m];
}
```
点个赞再走吧QWQ



---

## 作者：夏色祭 (赞：1)

**一道简单的背包题**


（其实就是混合背包）


p[i]>0时，就把它看成是p[i]件物品，时间都为a[i]，美学度为b[i]的物品，用01背包来做就行了


p[i]=0时，就直接用完全背包来做这个物品就行了


AC代码：


```cpp
uses math;
var
  a,b,p:array[0..31]of longint;
  f:array[0..1000]of longint;
  n,i,j,k,t,sum1,sum2,sum:longint;
  s,t1,t2:string;
function ff(var s:string):string;
begin
  ff:=copy(s,1,pos(' ',s)-1);
  delete(s,1,pos(' ',s));
end;
function time(var t:string):longint;
var
  x:string;
begin 
  x:=copy(t,1,2);
  if x[1]='0' then delete(x,1,1);
  val(x,time);
  delete(t,1,3);
end;
begin
  readln(s);
  t1:=ff(s)+' ';
  if length(t1)=5 then t1:='0'+t1;
  t2:=ff(s)+' ';
  if length(t2)=5 then t2:='0'+t2;//提取时间 ~~c++再读入里可以直接读入数字，不用提取，桑心~~
  val(s,n);//提取时间后，剩下的就是树的棵数
  sum1:=time(t1)*60+time(t1);
  sum2:=time(t2)*60+time(t2);
  sum:=sum2-sum1;
  if sum<0 then sum:=sum+1440;//算出可以看的时间 ~~可能我最后的特判（用来特判后面的时间比前面的早）没什么卵用的~~
  for i:=1 to n do readln(a[i],b[i],p[i]);
  for i:=1 to n do 
    if p[i]>0 then 
      for k:=1 to p[i] do 
        for j:=sum downto a[i] do 
          f[j]:=max(f[j],f[j-a[i]]+b[i])//01背包
      else 
        for j:=a[i] to sum do 
          f[j]:=max(f[j],f[j-a[i]]+b[i]);//完全背包
  write(f[sum]);
end.

```

---

## 作者：cxy004 (赞：1)

嗯，陈泽胧总算不发太水的水题了

这题是混合背包问题（背包九讲第四讲）

```cpp
#include<cstdio>
#define max(a,b) (a)>(b)?(a):(b)
using namespace std;

int n,v,t1,t2,m1,m2,f[201];

int main()
{
     scanf("%d:%d%d:%d%d",&t1,&m1,&t2,&m2,&n);v=(t2-t1)*60+m2-m1;
     for(int c,w,p;n--;)
     {
       scanf("%d%d%d",&c,&w,&p);
       if(!p) for(int i=c;i<=v;++i) f[i]=max(f[i],f[i-c]+w); //完全背包
       else if(p==1) for(int i=v;i>=c;--i) f[i]=max(f[i],f[i-c]+w); //01背包
       else //多重背包
          if((c*p)>=v) for(int i=c;i<=v;++i) f[i]=max(f[i],f[i-c]+w); //转化成完全背包
          else //转化成01背包
       {
            for(int i=1;i<p;i*=2) {for(int j=v;j>=c*i;--j) f[j]=max(f[j],f[j-c*i]+w*i);p-=i;}
            for(int i=v;i>=c*p;--i) f[i]=max(f[i],f[i-c*p]+w*p);
       }
     }
     printf("%d",f[v]);
     return 0;
}
```
#关于其中的多重背包（搬运）

##转化为01背包问题

另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(V\*Σn[i])。

但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。

方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。例如，如果n[i]为13，就将这种 物品分成系数分别为1,2,4,6的四件物品。

分成的这几件物品的系数和为n[i]，表明不可能取多于n[i]件的第i种物品。另外这种方法也能保证对于0..n[i]间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n[i]两段来分别讨论得出，并不难，希望你自己思考尝试一下。

这样就将第i种物品分成了O(log n[i])种物品，将原问题转化为了复杂度为<math>O(V\*Σlog n[i])的01背包问题，是很大的改进。


---

## 作者：蔡俊黠 (赞：0)

### 混合背包的模板题
每棵樱花树可以看的次数有无限次，有限次（1或其他），我们可以尝试将二者用二进制拆分转换成多重背包，然后跑01背包的模板，思路很容易明白，那如何转换？可以参考[P1776 宝物筛选_NOI导刊2010提高（02）](https://www.luogu.org/problem/P1776)
另外还要注意的是时间的问题，这里的时间是24小时制，在读入的时候要计算出可以观赏的时间
### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int x1,yy,x2,y2,n,W,cnt,f[11000000];
struct node{
	int w;
	int v;
	int num;
}a[11000000];
int main()
{
	scanf("%d:%d %d:%d",&x1,&yy,&x2,&y2);
	scanf("%d",&n);
	if(yy>y2)
    {
        y2+=60;
        x2--;
    }
    W=(x2-x1)*60+y2-yy;
	for (int i=1;i<=n;i++) 
	{
		int w,v,num;
		scanf("%d%d%d",&w,&v,&num);
    	if (num==0) num=9999999;
    	for (int j=1;j<=num;j<<=1)
    	{
    		a[++cnt].w=j*w;
    		a[cnt].v=j*v;
    		num-=j;
    		if (a[cnt].w>W) {num=0;cnt--;break;}
		}
		if (num!=0) a[++cnt].w=num*w,a[cnt].v=num*v;
	}
	for (int i=1;i<=cnt;i++)
	  for (int j=W;j>=a[i].w;j--)
	    f[j]=max(f[j],f[j-a[i].w]+a[i].v);
	printf("%d\n",f[W]);
	return 0;
}
```


---

## 作者：温栀槿 (赞：0)

这题就是一个简单的混合背包问题，

需要注意的是如果在多重背包时不加入优化，会T两个点的。
具体看代码

```c
#include<bits/stdc++.h>
using namespace std;

int aa,f[3500],n,m,n1,m1,w[14000],c[14000],num[140000],v;

void ze(int we,int va){//01背包
    for(int i=v;i>=we;i--) f[i]=max(f[i],f[i-we]+va);
}

void com(int x){//完全背包
    for(int i=w[x];i<=v;i++) f[i]=max(f[i],f[i-w[x]]+c[x]);
}

void mul(int x){
    if(w[x]*num[x]>=v){//是否可以当做完全背包来做
        com(x);
        return ;
    }
    int k=1;
    while(k<num[x]){//精髓 每次k*2，打包成一件物品，从num[i]复杂度优化到log（num[i]）；
        ze(k*w[x],k*c[x]);
        num[x]-=k;
        k*=2;
    }
    ze(num[x]*w[x],num[x]*c[x]);
}

int main(){
    scanf("%d:%d%d:%d%d",&n,&m,&n1,&m1,&aa);
    v=(n1-n)*60+m1-m;
    for(int i=1;i<=aa;i++){
        scanf("%d%d%d",&w[i],&c[i],&num[i]);
    }
    for(int i=1;i<=aa;i++){
    	if(!num[i]){
    		com(i);
    	}
    	else {
    		mul(i);
    	}
    }
    printf("%d",f[v]);
    
    By lzx729687719
}

```

---

## 作者：Drinkkk (赞：0)

/\*
P1833 题解

含价值的混合三种背包问题

\*/
```cpp
#include <cstdio>//头文件
int t[10001],c[10001],p[10001],f[10001];//t数组是用来存储看第i樱花树所需要的时间的（即f[i]），c数组是用来存储第i颗樱花的美学值的（即c[i]），p数组是用来存储这颗樱花树最多可以看多少次的（即p[i]）
int maxx(int x,int y)//maxx函数是用来判断两个数到底那个数更大一些的
{
    return x>y?x:y;//如果x>y，那么就返回x，否则就返回y
}
int main()//主函数
{
    int sa=0,sb=0,ea=0,eb=0,v=0,n=0;//sa和sb是用来存储开始的时间的，ea和eb则是用来存储结束的时间的
    scanf("%d:%d %d:%d %d",&sa,&sb,&ea,&eb,&n);//读入开始的时间的结束的时间，以及有多少棵樱花树是可以用来观赏的
    v=(ea*60+eb)-(sa*60+sb);//可以用来观赏烟花的时间（即这个背包的容量）
    for(int i=1;i<=n;i++)//读入这n棵樱花树的相关数据
    {
        scanf("%d %d %d",&t[i],&c[i],&p[i]);//读入观赏第i棵樱花树所需的时间（即t[i]），以及第i棵樱花树的美学值（即c[i]）和第i棵樱花树最多可以观赏多少次（即p[i]），注意，如果p[i]等于0的话，那么就表明第i棵樱花树可以观赏无数次（即完全背包），否则就表示这棵樱花树可以观赏p[i]次（即做p[i]次01背包即可）
    }
    for(int i=1;i<=n;i++)//从第1棵樱花树循环到第n棵樱花树
    {
        if(p[i]==0)//如果第i棵樱花树可以观赏无数次
        {
            for(int j=0;j<=v-t[i];j++)//完全背包（从0做到v-t[i]，因为不能超过的所给定的时间，即可以省去v-t[i]+1~v的这一段）
            {
                f[j+t[i]]=maxx(f[j]+c[i],f[j+t[i]]);//不管当前这一层有没有东西存在这里，都更新一下最大值
            }
        }
        else if(p[i]!=0)//如果第i棵樱花树只能够观赏p[i]次
        {
            for(int j=1;j<=p[i];j++)//那么就做p[i]次完全背包
            {
                for(int k=v-t[i];k>=0;k--)//01背包（原理同上，只不过倒着循环了而已）
                {
                    f[k+t[i]]=maxx(f[k]+c[i],f[k+t[i]]);//同上
                }
            }
        }
    }
    int ans=0;//存储最大值（即答案）
    for(int i=v;i>=0;i--)//找最大值
    {
        if(f[i]>=ans)//如果找到了一个比当前的最大值还要大的数字
        {
            ans=f[i];//那么就更新它（即更新最大值）
        }
    }
    printf("%d",ans);//输出最大值
    return 0;//结束程序
}
```

---

## 作者：YoChian (赞：0)

这是一道较为简单的一维背包，只要注意把欣赏次数转化为树的棵数就行（无限根据时间化为有限）


```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    //输入代码段 
    int s1,s2,e1,e2,n,n2=0;
    scanf("%d:%d %d:%d %d",&s1,&s2,&e1,&e2,&n);
    int time=e1*60+e2-s1*60-s2;//时间转换 
    struct tree
    {
        int t,c,p;
    }a[n+1];
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&a[i].t,&a[i].c,&a[i].p);
        if(a[i].p==0)
            a[i].p=time/a[i].t;//能够无限次欣赏的根据时间化为有限的欣赏次数 
        n2+=a[i].p;//将欣赏次数转化为树的棵数 
    }
    int f[n2+1],ci[n2+1],ti[n2+1],count=1;
    //每棵树的属性赋给其复制品 
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=a[i].p;j++)
        {
            ci[count]=a[i].c;
            ti[count]=a[i].t;
            count++;
        }
    }
    //状态转移数组初始化 
    for(int i=0;i<=time;i++)
        f[i]=0;
    //背包问题解决代码段 
    for(int i=1;i<=n2;i++)
        for(int j=time;j>=ti[i];j--)
            f[j]=f[j]>=f[j-ti[i]]+ci[i]?f[j]:f[j-ti[i]]+ci[i];//状态转移方程 
    //输出代码段 
    printf("%d",f[time]);
    return 0;
}

```

---

## 作者：skylee (赞：0)

正如@cxy004所说的，本题是混合背包问题。然而本题并不需要像他讲的这样复杂，我们只需要两种DP即可解决本题。

当P=0时，樱花可以欣赏无数次，则使用完全背包；

当P≠0时，樱花只能欣赏限定的次数，则我们不妨进行P次01背包。

具体实现见代码注释。

'''cpp
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int main(){
    struct time{//结构体用于储存时间
        int h,m;
        int t(){//成员函数的使用可以是代码简洁明快
            return h*60+m;
        }
    } ts,te;
    int n,time;
    scanf("%d:%d%d:%d%d",&ts.h,&ts.m,&te.h,&te.m,&n);//利用scanf特殊的读入格式过滤':'
    int t,c,p;
    int f[(time=te.t()-ts.t())+1];//时间长度作为背包大小
    memset(f,0,sizeof(f));
    for (int i=0;i<n;i++){
        scanf("%d%d%d",&t,&c,&p);//一边读一边DP可以减少内存开销
        if (p){//当P≠0时，樱花只能欣赏限定的次数，则我们不妨进行P次01背包。
            for (int j=1;j<=p;j++){
                for (int k=time;k>=t;k--){
                    f[k]=max(f[k],f[k-t]+c);
                }
            }
        }
        else{//当P=0时，樱花可以欣赏无数次，则使用完全背包；
            for (int j=t;j<=time;j++){
                f[j]=max(f[j],f[j-t]+c);
            }
        }
    }
    printf("%d\n",f[time]);
    return 0;
}
'''
```

---

## 作者：星之海 (赞：0)

这是一道动态规划中的混合背包问题

思路：动态规划

难点：完全背包与多重背包的判断，时间的计算

解决问题过后，代码也就简单的Coding出来了

```cpp
#include<stdio.h>
int max(int a,int b)//返回较大数
{
    if(a>b)
    return a;
    else
    return b;
}
int main()
{
    int k,v,w,p,n,m,j,i,f[20001]={0},a,b,c,d;
        scanf("%d:%d %d:%d %d",&a,&b,&c,&d,&n);//读入数据
    m=(c-a)*60-b+d;//计算时间
    for(i=1;i<=n;i++)
{
    scanf("%d %d %d",&w,&v,&p);//读入重量、价值与数量
    if(p==0)//是完全背包
{
    for(j=w;j<=m;j++)
    f[j]=max(f[j],f[j-w]+v);//DP式
}
else
{
    for(k=1;k<=p;k++)//枚举放的个数
    for(j=m;j>=w;j--)
    f[j]=max(f[j],f[j-w]+v);//DP式
}
}
    printf("%d\n",f[m]);//输出结果
    return 0;
}
```

---

## 作者：Blind_God (赞：0)

#我是蒟蒻的代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>  //说实话，这个头文件我放来仅仅是为了确定时间233
using namespace std;
int m,n,t[35],c[35],p[35],i,v,k,q=1,f[205],Ts[2],Te[2];
int main()
{
    scanf("%d:%d %d:%d %d",&Ts[0],&Ts[1],&Te[0],&Te[1],&n);
    m=60*Te[0]+Te[1]-60*Ts[0]-Ts[1];  //这是偷学了别人题解的方法来的(￣▽￣)~*，我原本的特别啰嗦
    for(i=1;i<=n;i++)
      {
          cin>>t[i]>>c[i]>>p[i];
          if(p[i]==0)p[i]=m/t[i]+1;  //当次数为零时，将它赋值为可能的最大值
      }
    for(i=1;i<=n;i++)
      for(v=m;v>=0;v--)
        for(k=1;k<=p[i];k++)  //基本就是多重背包的思路
          {
              if(v-k*t[i]<0)break;  //判断是否还有时间
              f[v]=max(f[v],f[v-k*t[i]]+k*c[i]);  //多重背包的朴素算法（是不是很挫）
          }
    cout<<f[m];
}
```

---


# 魔术棋子

## 题目描述

在一个 $M \times N$ 的魔术棋盘中，每个格子中均有一个整数，当棋子走进这个格子中，则此棋子上的数会被乘以此格子中的数。一个棋子从左上角走到右下角，只能向右或向下行动，请问此棋子走到右下角后，模（mod）$K$ 可以为几？

如以下 $2 \times 3$ 棋盘：

```
3    4    4
5    6    6
```
棋子初始数为 $1$，开始从左上角进入棋盘，走到右下角，上图中，最后棋子上的数可能为 $288,432$ 或 $540$。所以当 $K = 5$ 时，可求得最后的结果为：$0,2,3$。


## 样例 #1

### 输入

```
2 3 5
3 4 4
5 6 6
```

### 输出

```
3
0 2 3
```

# 题解

## 作者：Drifterming (赞：27)






```cpp
/*dp[i][j][l]表示在位置(i,j)能不能得到l。*/ 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int m,n,k,ans;
int num[105][105];
bool dp[105][105][105];
inline int read(int &num)
{
    num=0;char c=getchar();
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar()){num=num*10+c-'0';}
}
int main()
{
    read(m),read(n),read(k);
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            read(num[i][j]);
            num[i][j]%=k;    //一开始就mod 
        }
    }
    dp[1][1][num[1][1]]=true;    //初始化位置(1,1)的数 
    for(int i=1;i<=m;i++)
     for(int j=1;j<=n;j++)
      for(int l=0;l<k;l++)    //因为mod k 后得到的数一定小于k，所以从0到k枚举 
       if(!dp[i][j][l*num[i][j]%k])        //没有计算过 
        dp[i][j][l*num[i][j]%k]=dp[i-1][j][l]||dp[i][j-1][l];    //l*num[i][j]%k表示当前格子数乘从左边或上边传下来的数l再mod k，dp[i-1][j][l]和dp[i][j-1][l]表示在上方或左方能不能得到l 
    for(int i=0;i<k;i++)    //找个数 
    {
        if(dp[m][n][i]) ans++;
    }
    printf("%d\n",ans);
    for(int i=0;i<k;i++)    //找可能得到的数 
    {
        if(dp[m][n][i]) printf("%d ",i);
    }
    return 0;
}
```

---

## 作者：SIGSEGV (赞：23)

表示不想写dp....... bfs不照样过去了？

bfs爆搜20分，加了个used数组用来防止点重复入队就AC了？！

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
bool vis[102],used[102][102][102];
int n,m,k,a[102][102],dx[] = {0,1},dy[] = {1,0};
struct Node{int x,y,val;};
int main ()
{
	scanf("%d%d%d",&n,&m,&k);
	for (int i = 0;i < n;i++)
		for (int j = 0;j < m;j++)
			scanf("%d",&a[i][j]),a[i][j] %= k;//读入时顺便mod一下
	queue<Node> q;q.push({0,0,a[0][0]});//STL的玩意
	while (!q.empty())//bfs常规操作
	{
		Node nd = q.front();q.pop();//出队
		if (nd.x == n - 1 && nd.y == m - 1)
		{
			vis[nd.val] = 1;continue;
		}
		for (int i = 0;i < 2;i++)
		{
			int nx = dx[i] + nd.x,ny = nd.y + dy[i],nval = a[nx][ny] * nd.val % k;
			if (nx < 0 || nx >= n || ny < 0 || ny >= m || used[nx][ny][nval]) //最后一步是hash操作
				continue;
			q.push({nx,ny,nval});//出队
            used[nx][ny][nval] = 1;//记录点
		}
	}
	int cnt = 0;//先算一遍个数
	for (int i = 0;i < k;i++) cnt += vis[i];
	printf("%d\n",cnt);
	for (int i = 0;i < k;i++) if (vis[i]) printf("%d ",i);
	return 0;
}
```

---

## 作者：一ZCH一 (赞：14)

看数据范围$1 ≤ M ,N,K ≤ 100$

显而易见，dp数组可以开三维

所以 $dp[i][j][w]$ 表示到达第 $i$ 行第 $j$ 列值为 $w$ 的存在情况 

那么我们就可以考虑动态转移方程了

首先 $dp[i][j]$ 肯定是不动的，既然 $dp$ 数组存的是存在情况，那肯定就等于1啊。

所以我们只需要考虑 第三个数组下标

根据题目里的意思，$w*a[i][j]$，但是我们最好是能时刻模$k$,所以$(w*a[i][j])%k$

初始化：

$dp[0][1][1]=1;dp[1][0][1]=1;$


------------


代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=105;
int n,m,k,cnt;
int dp[N][N][N],a[N][N]; 
//dp[i][j][w]表示到达第i行第j列值为w的存在情况 

int main() 
{
   	cin>>n>>m>>k;
   	for(int i=1;i<=n;i++)
   		for(int j=1;j<=m;j++)
   			cin>>a[i][j];
   	dp[0][1][1]=1;dp[1][0][1]=1;
   	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++) 
			for(int w=0;w<k;w++)//保证这个值不超过k 
			{
				if(dp[i-1][j][w]==1)//从dp的上面推过来 
					dp[i][j][(w*a[i][j])%k]=1;
				if(dp[i][j-1][w]==1)//从dp的左边推过来 
					dp[i][j][(w*a[i][j])%k]=1;
			} 
	for(int i=0;i<k;i++)
		if(dp[n][m][i]==1)/*当这个位置存在值时*/ cnt++;
	cout<<cnt<<endl;
	for(int i=0;i<k;i++)//按顺序扫，可以保证是升序输出 
		if(dp[n][m][i]==1) cout<<i<<" ";		
    return 0;
}
```






---

## 作者：JeffWang2019 (赞：8)

## **由于此题卡了我太久**

## 所以我决定今天写篇题解来不让大家向我一样~~左问右问~~

这题可以写dfs，但是一定要加一个标记数组

```cpp
bool vis[105][105][105];
```


标记数组比地图加一个维度，用bool表示，vis【x】【y】【z】表示坐标为x，y时对k模z有没有路

不加的话，会像~~本蒟蒻~~一样TLE

dfs就按照递归那样去写就可以了

### 好了，上面是思路，下面是AC代码：

```cpp
#include <bits/stdc++.h>//写万能头文件已经成为我的习惯
using namespace std;
int a[105],mp[105][105];//mp储存地图，a【i】的值表示可以走到终点模k得余数i的个数

bool vis[105][105][105];//前面说的，标记数组
int m,n,k,ans=0;
void dfs(int x,int y,int s)//这里是dfs，整个程序的核心
{
    if(x<1||x>m||y<1||y>n)//边界
    {
        return;
    }
    int z=s;
    z=(s%k)*(mp[x][y]%k)%k;
    if(vis[x][y][z])//如果已经标记过
    {
        return;
    }
    vis[x][y][z]=true;//标记
    if(x==m&&y==n)//如果到了终点
    {
        a[z]++;//a数组下标为余数z的数加上1
        return;
    }
    if(x!=m)
    {
        dfs(x+1,y,z);
    }
    if(y!=n)
    {
        dfs(x,y+1,z);
    }
}
void in()//输入数据
{
    scanf("%d%d%d",&m,&n,&k);
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            scanf("%d",&mp[i][j]);//输入地图
        }
    }
}
void out()//输出数据
{
    for(int i=0;i<k;i++)//从0开始，因为模k的余数只有从0到k-1
    {
        if(a[i]!=0)
        {
            ans++;//不等于0，ans就自增
        }
    }
    printf("%d\n",ans);//注意换行
    for(int i=0;i<k;i++)
    {
        if(a[i]!=0)//出现了这个余数就打印
        {
            printf("%d ",i);//注意要空格
        }
    }
}
int main()//有了那么多函数，主函数就很简洁了
{
    memset(a,0,sizeof(a));// 清空
    memset(vis,false,sizeof(vis));//清空
    in();//输入
    dfs(1,1,1);//从1,1开始，余数也从1开始
    out();//输出
    return 0;//完美结束
}
```

## 最后预祝各位尽早AC！

**还有最最最重要一点：NO 抄袭！**

---

## 作者：斯德哥尔摩 (赞：6)

f[i][j][l] 表示在 （i，j）这个位置能否使乘积达到 l ，那么状态转移方程就很好推了：

f[i][j][l\*a[i][j]%k]=1（f[i-1][j][l]||f[i][j-1][l]==1）
附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define MAXN 110
using namespace std;
int n,m,k,ans=0,a[MAXN][MAXN],f[MAXN][MAXN][MAXN];
inline int read(){//无用的读优。。。
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
int main(){
    n=read();m=read();k=read();
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    a[i][j]=read();//读入
    f[1][0][1]=f[0][1][1]=1;//初始化，当初我傻傻地将第0行与第0列全部赋为1，然后爆炸了。。。
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)//枚举每个位置
    for(int l=0;l<k;l++){//枚举每个能达到的数
        if(f[i-1][j][l])
        f[i][j][(l*a[i][j])%k]=1;//转移
        if(f[i][j-1][l])
        f[i][j][(l*a[i][j])%k]=1;//转移
    }
    for(int i=0;i<k;i++)if(f[n][m][i])ans++;//计算个数
    printf("%d\n",ans);
    for(int i=0;i<k;i++)if(f[n][m][i])printf("%d ",i);//输出结果
    printf("\n");
    return 0;
}

```

---

## 作者：ych153 (赞：3)

Go语言来一发——
```go
package main
import "fmt"
var m,n,k,ans int
var mp[110][110] int
var opt[110][110][110] bool
func main(){
    fmt.Scanf("%d%d%d",&m,&n,&k);
    for i:=1;i<=m;i++{
        for j:=1;j<=n;j++{
            fmt.Scan(&mp[i][j])
        }
    }
    opt[1][1][mp[1][1]%k]=true
    for i:=2;i<=m;i++{
        for j:=0;j<k;j++{
            opt[i][1][j*mp[i][1]%k]=opt[i-1][1][j]||opt[i][1][j*mp[i][1]%k]
        }
    }
    for i:=2;i<=n;i++{
        for j:=0;j<k;j++{
            opt[1][i][j*mp[1][i]%k]=opt[1][i-1][j]||opt[1][i][j*mp[1][i]%k]
        }
    }
    for i:=2;i<=m;i++{
        for j:=2;j<=n;j++{
            for l:=0;l<k;l++{
                opt[i][j][l*mp[i][j]%k]=opt[i-1][j][l]||opt[i][j-1][l]||opt[i][j][l*mp[i][j]%k]
            }
        }
    }
    for i:=0;i<k;i++{
        if opt[m][n][i]{
            ans++;
        }
    }
    fmt.Printf("%d\n",ans)
    for i:=0;i<k;i++{
        if opt[m][n][i]{
            fmt.Printf("%d ",i)
        }
    }
    fmt.Printf("\n");
}
```

---

## 作者：小柯 (赞：3)

$\texttt{为什么有人用}$
$\color{black}{BFS}$
$\texttt{，却没人用}$
$\color{black}{DFS}$
$\large\texttt{?}$
——蒟蒻

$\texttt{维护状态用三个参数}$
$\color{black}{i,j,sum.}$

>$\color{black}{i,j:}$
$\texttt{当前在第}$
$\color{black}{i}$
$\texttt{行，第}$
$\color{black}{j}$
$\texttt{列。}$

>$\color{black}{sum:}$
$\texttt{如题目所述的路径上的数的积。}$

$\texttt{具体代码如下：}$

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int m,n,k,big,nn,a[105][105],ans[105];
bool vis[105][105][105];
void f(int i,int j,int sum){
	sum=(sum*a[i][j])%k;                                  //预处理 
	if(vis[i][j][sum]||i>m||j>n)return;                   //判重和边界 
	if(i==m&&j==n){                                       //到达终点 
		big=max(big,sum);                                 //最大的值，优化后来的查表 
		ans[sum]++;                                       //这个数能被凑出来 
		if(ans[sum]==1)nn++;                              //如果这个数是第一次能被凑出来，则计数器加一 
		return;                                           //返回 
	}
	vis[i][j][sum]=true;                                  //标记 
	f(i+1,j,sum);                                         //状态拓展——向下走 
	f(i,j+1,sum);                                         //状态拓展——向右走 
}
int main(){
	cin>>m>>n>>k;
	for(int i=1;i<=m;i++)for(int j=1;j<=n;j++)cin>>a[i][j];
	f(1,1,1);                                             //DFS 
	cout<<nn<<endl;                                       //输出计数器 
	for(int i=0;i<=big;i++)if(ans[i])cout<<i<<" ";        //如果这个数能被凑出来就输出 
	return 0;
}
```



---

## 作者：lych (赞：3)

吐槽（可以无视）：好久没有写题解了吧。。因为学业的缘故。不过还是要练一练。

    <hr>

初看这一道题目，好像没有什么思路。其实搜索也是能够写的。显然，这一道题目不用动规是不行的。像这一类的题目，**[color=red]一定要关注数据[/color]**，比如说取模的K，只有100。于是我们很容易联想到背包问题的剩余容量的可能性。**[u]我们可以用一个布尔型三维数组f[i,j,x]（由于K已经作为了取模数，所以不再重复），表示第i行j列在mod  K后能否取到。[/u]**

由于这一道题目规定只能向下或者向右，所以具有明显的无后效性，可以用动态规划。显然，对于f[i,j,x]，我们只需要知道f[i-1,j,l]或者f[i,j-1,l]满足l\*a[i,j] mod K=x即可。但是我们发现，对于f[i,j,x]，需要用O(K)的时间来进行状态转移，同时又有MNK个状态，时间复杂度为O(MNK^2)，当取到极限值100时，极易超时，所以需要改进。

[u]我们发现，有许多l都是不满足条件的。而当l满足条件时，一定能找到符合条件的。只要枚举所有符合的l，就能找到所有符合条件的x。显然，我们可以通过枚举l来实现，这样时间复杂度就下降到了O(MNK)，可以通过全部的测试点。[/u]

    <hr>

通过以上我们可以发现，动态规划也不是一定就能高时效，还需要通过优化。比较明显的有比如说上海省选的的一道“吃豆豆”，有兴趣的同学可以探讨一下。

    <hr>

标程（核心代码）：

```delphi
begin
  readln(m,n,k);
  for i:=1 to m do
    begin
      for j:=1 to n do
        begin
          read(x);
          x:=x mod k;//直接取余，显然不会影响结果，但可以降低数据量
          if i+j=2 then
            begin
              f[i,j,x]:=true;
              continue;
            end;//对于i=j=1的情况，无需转移。
          for l:=0 to k-1 do//枚举l
            f[i,j,x*l mod k]:=
              f[i,j,x*l mod k] or f[i-1,j,l] or f[i,j-1,l];//状态转移
        end;
      readln;
    end;
end.
```
最后附一句（可以无视）：动态规划是个好东西，一定要学好。


---

## 作者：微香玉烛暗 (赞：1)

看到小数据没想要$DP$，较自信地写了$dfs$，只有$20pts$。然后就想办法优化了一下，甚至都没用到记忆化，只是简单记录了一下该状态有无被访问—即$visit$数组，便过了。   

------------
状态：$ij$为当前位置；$num$为当前乘积。     
边界：$i==n$且$j==m$：如未曾有该数，计入ans数组

------
代码：
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ri register int
using namespace std;
const int N=105;
int n,m,k,sum,a[N][N],ans[N*N];
bool v[N],u[N][N][N];
//v:答案桶；u：状态桶

inline int read () {
    int x=0,y=1; char ch='\000';
    for (;!isdigit(ch);ch=getchar()) if (ch=='-') y=-1;
    for (;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch^'0');
    return x*y;
}

void dfs (int i,int j,int num) {
	u[i][j][num%k]=1;//状态已访问
	if (i==n&&j==m) {//边界
		if (!v[num%k]) {//答案不存在
			ans[++sum]=num%k;//则加入ans数组
			v[num%k]=1;//答案定义为已被访问
			return ;
		}
	}
    /*若下一状态为访问，则转移*/
	if (i<n&&(!u[i+1][j][(num*a[i+1][j])%k])) dfs (i+1,j,(num*a[i+1][j])%k);
	if (j<m&&(!u[i][j+1][(num*a[i][j+1])%k])) dfs (i,j+1,(num*a[i][j+1])%k); 
}

int main () {
	n=read(); m=read(); k=read();
	for (ri i=1;i<=n;i++) 
		for (ri j=1;j<=m;j++) 
			a[i][j]=read();
	dfs (1,1,a[1][1]);//a[1][1]为必乘数
	printf ("%d\n",sum);
	sort (ans+1,ans+1+sum);//从小到大
	for (ri i=1;i<=sum;i++) printf ("%d ",ans[i]);
	printf ("\n");
	return 0;
}
//By famvics

```
完结撒花

---

## 作者：Mychael (赞：1)

我想说。。。只有我尝试用STL中的set吗？

**虽然只得了90分TLE了第8个点**

\_如果嫌弃就看楼下大佬们的正解吧\_


主要思路就是把每个点可能的情况用set存起来，然后对于每个点只需将其上一个和左一个点的可能的值一一枚举存起来即可


献上丑陋的代码：





```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
#include<set>
#include<algorithm>
using namespace std;
const int maxn=105;
set<int> dp[maxn][maxn];        //保存每个点所有的可能，自动除重
inline int read()                          //快速读入
{
    int out=0;
    char c=getchar();
    while(c<48||c>57) c=getchar();
    while(c>=48&&c<=57)
    {
        out=out*10+c-48;
        c=getchar();
    }
    return out;
}
int main()
{
    int M=read(),N=read(),K=read(),n;
    dp[1][1].insert(read());                        //第一个点特判
    for(int i=1;i<=M;i++)
        for(int j=(i==1 ? 2:1);j<=N;j++)         //当i=1时不计算j=1的点
        {
            n=read();                                  //边读边计算
            if(i>1)                                        //上一个
                for(set<int>::iterator it=dp[i-1][j].begin();it!=dp[i-1][j].end();it++)
                    dp[i][j].insert(n*(*it)%K);
            if(j>1)                                         //左一个
                for(set<int>::iterator it=dp[i][j-1].begin();it!=dp[i][j-1].end();it++)
                    dp[i][j].insert(n*(*it)%K);
        }
    cout<<dp[M][N].size()<<endl;                    //输出结果
    set<int>::iterator it=dp[M][N].begin(),endd=dp[M][N].end();
    printf("%d",*it);
    for(it++;it!=endd;it++)
    {
        printf(" %d",*it);
    }
    printf("\n");
    return 0;
}

```

---

## 作者：l1360300734 (赞：0)

我来一发题解，这种动态规划与递推的内容，这和过河卒差不多，一个三维的bool数组f[i][j][k]表示第i行第j列，k已经去过了，标记为true，没取过就标记为false；

状态转移方程就是：

                if (f[i-1][j][k]==true||f[i][j-1][k]==true)
                    f[i][j][(k\*a[i][j])%p]=true;

其中第一行和第一列要先初始化

主要就是递推思想，从前一个推过去；

还有一点是：a\*b%p=(a%p)\*(b%p)%p,

所以在循环中间%也是可以的，不影响最后的结果，还能省空间

献上蒟蒻的代码：


```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int a[101][101];
int f[101][101][901];
int main()
{
    int n,m,p,s=0,i,j,k,linshi;
    scanf("%d%d%d",&n,&m,&p);//读入
    for (i=1;i<=n;i++)
        for (j=1;j<=m;j++)
        {
            scanf("%d",&a[i][j]);
            a[i][j]%=p;//一开始就%p，反正最后也是要%p的
        }            
    memset(f,0,sizeof(f));
    f[1][1][a[1][1]]=true;//初始化
    linshi=a[1][1];
    for (i=2;i<=n;i++)
    {
        linshi=(linshi*a[i][1])%p;
        f[i][1][linshi]=true;//初始化
    }
    linshi=a[1][1];
    for (i=2;i<=m;i++)
    {
        linshi=(linshi*a[1][i])%p;
        f[1][i][linshi]=true;//初始化
    }
    for (i=1;i<=n;i++)    
        for (j=1;j<=m;j++)
            for (k=0;k<=p;k++)
                if (f[i-1][j][k]==true||f[i][j-1][k]==true)//状态转移方程
                    f[i][j][(k*a[i][j])%p]=true;
    for (i=0;i<=p;i++)
        if (f[n][m][i])
            s++;            //统计
    printf("%d\n",s);//输出
    for (i=0;i<=p;i++)
        if (f[n][m][i]) 
            printf("%d ",i);//输出
}
```

---


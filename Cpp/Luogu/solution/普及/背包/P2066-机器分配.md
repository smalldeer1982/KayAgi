# 机器分配

## 题目描述

总公司拥有高效设备 $M$ 台，准备分给下属的 $N$ 个分公司。各分公司若获得这些设备，可以为国家提供一定的盈利。问：如何分配这 $M$ 台设备才能使国家得到的盈利最大？求出最大盈利值。其中 $M \le 15$，$N \le 10$。分配原则：每个公司有权获得任意数目的设备，但总台数不超过设备数 $M$。


## 样例 #1

### 输入

```
3 3
30 40 50
20 30 50
20 25 30
```

### 输出

```
70
1 1
2 1
3 1
```

# 题解

## 作者：冈崎梦美 (赞：113)

一道经典的区间DP练习题。

设f[i][j]为前i个公司总共分配j台机器的最大利润。对于第i家子公司，我们可以给其分配的机器台数为：

`0,1,2……m`

所以在该区间内枚举一个值k，状态转移方程即为：

`f[i][j]=max(f[i-1][j-k],f[i][j]);`

那么，如何处理方案输出问题呢？

我们设`path[i][j][h]`对于前i个公司共分配j台机器的最优方案，第h个公司应分配多少台机器，当状态发生转移时，更新path数组即可。最终的答案就存放在`path[n][m][i]`之中。

贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[11][16],graph[11][16],path[11][16][11],n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            cin>>graph[i][j];
    }
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)    
            for(int k=0;k<=j;k++)
            {
                if (f[i][j]<f[i-1][j-k]+graph[i][k])
                {
                    f[i][j]=f[i-1][j-k]+graph[i][k];
                    for(int h=1;h<i;h++) path[i][j][h]=path[i-1][j-k][h];//path数组只有在状态发生转移时才更新
                    path[i][j][i]=k;
                }    
            }
    cout<<f[n][m]<<endl;
    for(int i=1;i<=n;i++) cout<<i<<" "<<path[n][m][i]<<endl;
    return 0;
}
```
如果你依照上述思想写出了dp程序并提交，恭喜你，只有90分。

#那么这是为什么呢？

回到题面，我们会发现小小的一行字，人畜无害的样子：

`P.S.要求答案的字典序最小`

你会发现如果这样做，方案输出是错的。

如何使字典序最小呢？这需要我们倒着枚举。

设表示的意思为“不给”第i家公司k台机器（k的值域同上），那么状态转移方程需改为：

`f[i][j]=max(f[i][k],f[i-1][k]+graph[i][j-k]);`

再根据这个，对于path数组的更新操作进行一些微调，即可得到满分程序了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[11][16],graph[11][16],path[11][16][11],n,m;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            cin>>graph[i][j];
    }
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)    
            for(int k=0;k<=j;k++)
            {
                if (f[i][j]<f[i-1][k]+graph[i][j-k])
                {
                    f[i][j]=f[i-1][k]+graph[i][j-k];
                    for(int h=1;h<i;h++) path[i][j][h]=path[i-1][k][h];
                    path[i][j][i]=j-k;//因为改为了“不给”第i家公司k台机器，所以必须如此调整
                }
            }
    cout<<f[n][m]<<endl;
    for(int i=1;i<=n;i++) cout<<i<<" "<<path[n][m][i]<<endl;
    return 0;
}
```

---

## 作者：prefer (赞：108)

# 搜索出奇迹

让我们一起见证DFS的辉煌

**DFS保证找到最大答案的时候就是字典序最少的，因为我从1号-n号枚举用的多少机器，用的机器数量也是由少到多。当最后得到答案相等的情况下就不用需要比较字典序了，直接return，只有碰到大小不一的时候才更新答案机器数**
```cpp

#include<bits/stdc++.h>
using namespace std;
int n,m,a[20][20],pau[20],f[20],ans;//f[i]是答案机器数，pau是当前假设的机器数量
void dfs(int Nnum,int Nans,int Nm) {//Nnum是现在的公司编号，Nans是现在的盈利，Nm是剩余的机器 
	if(Nm<0) return;
	if(Nnum==n+1) {
		if(Nans>ans) {
			ans=Nans;
			for(int i=1;i<=n;i++) f[i]=pau[i];
		}
		return;
	}
	for(int i=0; i<=m; i++) pau[Nnum]=i,dfs(Nnum+1,Nans+a[Nnum][i],Nm-i);//i枚举这个公司用多少台机器 
	return;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			scanf("%d",&a[i][j]);
	dfs(1,0,m);
	printf("%d\n",ans);
	for(int i=1; i<=n; i++) printf("%d %d\n",i,f[i]);
	return 0;
}
```

---

## 作者：ouuan (赞：60)

照例看了一眼第一页的所有题解，发现没有dp数组1维path数组2维的，唯一一个不用path数组的是递归输出而且输出复杂度大概看了一眼貌似是O(nm)，所以讲一下我小小的优化。

f(i,j)表示将j台机器分给1~i公司的最大盈利，w[i][j]表示第i公司有j台机器的盈利

转移方程就是f(i,j)=max(k∈[0,j]){f(i+1,j-k)+w[i][j]}

重点在如何优化数组大小（虽然这题数据极小）

注意到转移方程里只用到了f(i+1,l)(l∈[0,j])，因此只要从大到小枚举j就可以在dp数组里去掉i这一维

接下来是输出，我是用ans数组保存f(i,j)取最大时k的值，然后依次求出f(i,j)是由f(i+1,?)转移而来就可以输出方案了。字典序最小所以k要正序枚举，比较f[j]与f[j-k]+w[i][k]大小时不能取等；为方便正序输出所以i倒序枚举（如果正序枚举i答案就是f(n,m)，输出就要从n开始，如果要正序输出就得用数组保存）。

具体细节看程序吧：

```
#include <iostream>

using namespace std;

int f[20],n,m,w[20][20],ans[20][20];

int main()
{
	int i,j,k;
	
	cin>>n>>m;
	
	for (i=1;i<=n;++i)
	{
		for (j=1;j<=m;++j)
		{
			cin>>w[i][j];
		}
	}
	
	for (i=n;i>0;--i)
	{
		for (j=m;j>=0;--j)
		{
			for (k=1;k<=j;++k)
			{
				if (f[j-k]+w[i][k]>f[j])
				{
					f[j]=f[j-k]+w[i][k];
					ans[i][j]=k;	//保存f(i,j)取最大时k的值
				}
			}
		}
	}
	
	cout<<f[m];
	
	for (i=1,j=m;i<=n;++i)
	{
		cout<<endl<<i<<" "<<ans[i][j];
		j-=ans[i][j];	//算出最优方案第i+1~n公司共使用了几台机器，也就是f(i,j)是由f(i+1,?)转移过来的
	}
	
	return 0;
}
```

其实正序枚举i倒序枚举k也是可以的，只不过有些麻烦：
```
#include <iostream>

using namespace std;

int f[20],n,m,w[20][20],ans[20][20],out[20];

int main()
{
    int i,j,k;
    bool flag;
    
    cin>>n>>m;
    
    for (i=1;i<=n;++i)
    {
        for (j=1;j<=m;++j)
        {
            cin>>w[i][j];
        }
    }
    
    for (i=1;i<=n;++i)
    {
        for (j=m;j>=0;--j)
        {
            flag=true;	//flag用来标识当前f(i,j)的最大值是否为k=0时取的，因为倒序枚举的话不能算k=0的情况，否则f[j-k]+w[i][k]==f[j]必定满足，ans里面就全是0了；但如果是k≠0时f(i,j)同样可以取到最大值，就没有取到字典序最小
            for (k=j;k>0;--k)
            {
                if (flag&&f[j-k]+w[i][k]>=f[j]||f[j-k]+w[i][k]>f[j])
                {
                    flag=false;
                    f[j]=f[j-k]+w[i][k];
                    ans[i][j]=k;
                }
            }
        }
    }
    
    cout<<f[m];
    
    for (i=n,j=m;i>0;--i)
    {
        out[i]=ans[i][j];  //将结果保存在out数组里
        j-=ans[i][j];
    }
    
    for (i=1;i<=n;++i)
    {
        cout<<endl<<i<<" "<<out[i];	//正序输出
    }
    
    return 0;
}
```

---

## 作者：Kevin_Wa (赞：36)

此题是DP的经典题。

题意剖析：

按照公司的顺序来分配机器，即按照公司的顺序划分阶段，

第一个阶段把$M$台设备分给第一给公司，记录下来获得的盈利值，

然后再把$M$台设备分给前两个公司，和第一个阶段比较记录下来的更优的各个盈利值，

一直到第$N$个阶段吧$M$台机器全都分给了$N$个公司，就可以得到最优解，

下面来讨论两个阶段之间的关系，

设数组$f$[$i$,$j$]表示前$i$个公司分配$j$台机器的最大盈利，

数组$f$[$i$-$1$,$k$]表示前$i$-$1$给公司分配$k$台机器的最大盈利($1 \leq i \leq n$，$1 \leq j \leq m$，$0 \leq k \leq j$)

用$value$[$i$,$j$]表示第$i$给公司分配$j$台机器的盈利，$f$[$i$,$j$]可以由下面的式子取最大值获得：

$f$[$i$-$1$,$0$]+$value$[$i$,$j$]//前$i$-$1$公司分配$0$台机器最大盈利+第$i$个公司分配$j$台机器的盈利

$f$[$i$-$1$,$1$]+$value$[$i$,$j$-$1$]//前$i$-$1$公司分配$1$台机器最大盈利+第$i$个公司分配$j$-$1$台机器的盈利

$f$[$i$-$1$,$2$]+$value$[$i$,$j$-$2$]//前$i$-$1$公司分配$2$台机器最大盈利+第$i$个公司分配$j$-$2$台机器的盈利

$f$[$i$-$1$,$j$-$1$]+$value$[$i$,$1$]//前$i$-$1$公司分配$j$-$1$台机器最大盈利+第$i$个公司分配$1$台机器的盈利

$f$[$i$-$1$,$j$]+$value$[$i$,$0$]//前$i$-$1$公司分配$j$台机器最大盈利+第$i$个公司分配$0$台机器的盈利

这用机器数用作每个阶段的状态，

由于$value$[$i$,$j$]的值为定值，要使前面每个式子的值最大，

就必须使第$i$-$1$阶段的各个状态的值最大，阶段$i$的状态只能由阶段$i$-$1$中的状态通过状态转移方程求得，与其他状态没有关系。

由此可见，该问题具备了最优子节构和无后效性原则，适宜用动态程序方法求解，

状态转移方程$f$[$i$,$j$]=$max${$f$[$i$-$1$,$k$]+$value$[$i$,$j$-$k$]}

($1 \leq i \leq n$，$1 \leq j \leq m$，$0 \leq k \leq j$)

### Code

```
var n,m:longint;
i,j,k,max:longint;
f,value:array[0..10,0..15] of longint;
procedure show(i,j:longint);
var k:longint;
begin
if i=0 then exit;
for k:=0 to j do
  if max=f[i-1,k]+value[i,j-k] then
    begin
    max:=f[i-1,k];
    show(i-1,k);
    writeln(i,' ',j-k);
    exit;
    end;
end;
begin
readln(n,m);
for i:=1 to n do
  for j:=1 to m do
    read(value[i,j]);
for i:=1 to n do
  for j:=1 to m do
    begin
    max:=0;
    for k:=0 to j do
      if f[i-1,k]+value[i,j-k]>max then
        max:=f[i-1,k]+value[i,j-k];
    f[i,j]:=max;
    end;
writeln(f[n,m]);
show(n,m);
end.
```


---

## 作者：Hydra_ (赞：26)

## 分析 ##

显然是一个经典的dp题目。我们定义一个数组：f[i][j]表示前i个公司分配j台机器的最大盈利。那么求解f[i][j]的过程应该怎么求解呢？首先，我们在给第i个公司分配机器的时候，我们肯定为第i-1个公司分配过机器了，所以显然，i的状态由j的状态推导而来，那么我们需要怎么枚举呢？就是：通过枚举i个公司需要多少台机器，再枚举i-1个公司需要多少机器，再找出最大值就可以了。下面上代码：


代码
--

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int num=0;
    char c=getchar();
    for(;c<'0'||c>'9';c=getchar());
    for(;c>='0'&&c<='9';c=getchar())num=num*10+c-'0';
    return num;
}//快读 
int n,m,f[30][30],value[30][30],maxl;
/*以上是变量说明阶段。
f数组：f[i][j]表示前i个公司分j台机器的最大盈利
value数组：value[i][j]表示第i个公司分j台机器的盈利
*/ 
int print(int i,int j)
{
    if(i==0)return 0;
    for(int k=0;k<=j;k++)
    //k枚举了前i-1个分公司分得多少机器 
    if(maxl==f[i-1][k]+value[i][j-k])
    //知道结果倒推回去 
    {
        maxl=f[i-1][k];//步步为营的方式 
        print(i-1,k);//继续低柜求解 
        printf("%d %d\n",i,j-k);//倒序输出 
        break;//搜到了直接跳出循环 
    }
}
int main()
{
    n=read();
    m=read();
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    value[i][j]=read();
    //读入各种数据 
    for(int i=1;i<=n;i++)//枚举公司数 
    for(int j=1;j<=m;j++)//枚举机器数（总） 
    {
        maxl=0;
        for(int k=0;k<=j;k++)//枚举前i-1个公司分到的机器数 
        if(f[i-1][k]+value[i][j-k]>maxl)
        /*f[i-1][k]：前i-1个公司分k台机器的利润
        value[i][j-k]：第i个公司分j-k台机器的利润
        加起来是i个公司分j台机器的最大利润*/ 
        maxl=f[i-1][k]+value[i][j-k];
        f[i][j]=maxl;
    }
    printf("%d\n",f[n][m]);//输出结果 
    print(n,m);//输出分配方案 
    return 0;
}
```

---

## 作者：lyyi2003 (赞：19)

这组数据可以hack掉大部分所谓标程：

3 6

10 10 1 1 1 1

10 1 10 1 1 1

10 10 10 1 1 1

正确做法应该在每个状态里记录这个状态的最大价值以及取到这个最大价值时的最小字典序，转移时如果最大价值相同，再比较字典序，取字典序小的转移。

正确的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 107
int w[N][N];
struct str
{
	int x;
	string s;
	str operator +(int y)
	{
		return {x+y,s};
	}
	str operator +(char c)
	{
		return {x,s+c};
	}
	bool operator <(str a) const
	{
		return x<a.x||x==a.x&&s>a.s;
	}
}f[N][N];
int main()
{
	int n,m,i,j,k;
	//freopen("data.in","r",stdin);
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			scanf("%d",&w[i][j]);
	for(i=1;i<=n;i++)
		for(j=0;j<=m;j++)
		{
			f[i][j]=f[i-1][j]+'0';
			for(k=1;k<=j;k++)
				f[i][j]=max(f[i][j],f[i-1][j-k]+w[i][k]+(char)('0'+k));
		}
	printf("%d\n",f[n][m].x);
	for(i=1;i<=n;i++)
		printf("%d %d\n",i,f[n][m].s[i-1]-48);
	return 0;
}
```

---

## 作者：xzyxzy (赞：18)

说明一下:这道题在刚学动规的我还是很难的，难在它的转移方程和输出

先让我们分析一下这道题的思路：按照经典动态规划的老套路，都要定义那么一个F数组，所以这里我用F[i][j]表示前i个公司分配j台机器所能获得的最大利润，那么在枚举公司时，可以发现这个值是等于前i-1个公司分配k台机器和第i个公司分配j-k台机器的和的最大值（k在0到j之间，注意分配的机器总数可以小于M，也可以为0），那么状态转移方程就出来了：用for循环枚举k的值，F[i][j]=max(F[i-1][k]+V[i][j-k])，再如此循环，可得最终F[N][M]的值


此题的另外一个难点！难点！难点！在于输出！

定义一个show函数来输出，由于max1是全局变量，所以在主函数循环完之后留下了一个F[N][M]的值，再在主函数中定义k，在枚举k的数值过程中发现k满足了第N个公司分配M-k台机器时，那么第N个公司就分配到了M-k台机器，按理说应当最后输出，所以我们先不急，先将这个值压到栈底，再次进行递归调用将max1的值改变为前N-1个公司分配k台机器的盈利最大值，用i于j传参调用，到了公司枚举完了时，再次调用应该是i=0，所以这个时候应该直接return，再从栈中取出元素输出（代码中有详尽的注释）


很难吧，希望这篇题解对你有帮助！


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
void show(int i,int j);
int N,M,max1,V[11][16],F[11][16];//F[i][j]表示第i个公司分配j台机器的最大盈利 
int main()
{
    cin>>N>>M;
    for(int i=1;i<=N;i++)
        for(int w=1;w<=M;w++) 
            cin>>V[i][w];
    //转移方程：前i个公司分配j台机器所获的最大盈利
    //应该是前i-1个公司分配k台机器和第i个公司分配
    //j-k台机器的盈利和的最大值 
    for(int i=1;i<=N;i++)//前i个公司 
    {
        for(int j=1;j<=M;j++)//分配j台机器
        {
            max1=0;//把max1先往小赋值，便于更新
            for(int k=0;k<=j;k++)
            {
                int w=F[i-1][k]+V[i][j-k];
                if(max1<w) 
                {
                    max1=w;
                }
            }
            F[i][j]=max1;//以上是状态转移方程
        } 
    }
    cout<<F[N][M]<<endl;
    show(N,M);
    return 0;
} 
//最难的部分到了！
void show(int i,int j)//i表示前i个公司，j表示前i个公司分到了j台机器
{
    if(i==0) return;//递归终点
    for(int k=0;k<=j;k++)//寻找满足条件的k
        if(max1==F[i-1][k]+V[i][j-k])
        {
            max1=F[i-1][k];//更新max1便于继续递归
            show(i-1,k);//自调用
            cout<<i<<" "<<j-k<<endl;//先进后出的栈的输出
            break;
        }
}
```

---

## 作者：XingYing (赞：7)

**这是一道典型的动态规划题**

**如何判断呢，**

**思考：当前公司如何分配，分配多少台机器，才能使最后总和获得最大盈利呢？**

**显然，这与 这个公司 之前的公司如何分配息息相关**

**如此，我定义方程f[i][j]表示前i个公司分配j台机器所获得的最大盈利**

**又如何动态转移方程呢？**

**我们已知第i(i<=n)个公司分配j(<=m)台机器所得盈利**

**我们把它存贮在s[15][20]中**

**对于当前公司而言，它最多有m+1种方案，**

**及 不分配机器，分配1、2、3······m台机器；**

**对于前i台公司而言，也有m+1种方案，**

**及 不分配机器，共分配1、2、3······m台机器；**

**则f[i][j]=f[i-1][j-k]+s[i][k](0<=k<=j)**

**前提条件是 ：f[i-1][j-k]+s[i][k]>f[i][j]只有在前者的方案优于当前方案时，我们才更新方案(0<=k<=j)**

**最终的最大盈利则在f[n][m]中;**

**表示所有公司共分配m台机器的最大盈利。**

**另外，我们用z[15][20][15]来存储与f[i][j]相应的各个公司所分配的机器数**

以下为参考程序（节选）

```cpp
**for(int i=1;i<=n;i++){
       for(int j=0;j<=m;j++){
           for(int k=j;k>=0;k--){
                if(f[i-1][j-k]+s[i][k]>f[i][j]){
//如果前i-1个公司分配j-k台机器的盈利+当前公司分配k台机器的盈利 大于 前i个公司分配j台机器的盈利
                       f[i][j]=f[i-1][j-k]+s[i][k];
//就更新f[i][j]的盈利，以次才能得到···最大盈利
                       for(int l=1;l<=i-1;l++)z[i][j][l]=z[i-1][j-k][l];
//要将相应的分配数也一起更新
                       z[i][j][i]=k;
                 }
            }
        }
   }
printf("%d\n",f[n][m]);
for(int i=1;i<=n;i++)printf("%d %d\n",i,z[n][m][i]);//答案所在。
```

---

## 作者：fanfan (赞：6)

用a[i][j]储存第i个公司分j个机器时的利润。

首先是dp方程，楼下都已经有了，f[i][j]表示前i个公司分j个机器的最大值，f[i][j]可以由f[i-1][k]得来（k枚举一下前i-1个公司分k个的情况）

f[i][j]=max(f[i][j],f[i-1][k]+a[i][j-k])

我没有用dalao们的递归方法，而用了一个简单易懂的方法记录分配方案，num数组表示前i个公司分j个机器最大收益时第k个公司分配的机器数。

状态转移方程就有了。。。

if(f[i][j]<f[i-1][k]+a[i][j-k])（当f[i][j]要被替换的时候）这时分配方案也要更新。

所以num数组进行一下更新，此时前i-1个公司中分配了的个机器的个数方案数由前i-1个公司分配k个机器时的状态转移过来即可，然后第i个公司分配j-k个机器。

最后输出前n个公司分配m个机器时的第i个公司的机器数，即num[n][m][i]

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxm=15+2,maxn=10+2;
int a[maxn][maxm],f[maxn][maxm],num[maxn][maxm][maxn];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            scanf("%d",a[i]+j);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
        {
            for(int k=0;k<=j;++k)
            if(f[i][j]<f[i-1][k]+a[i][j-k])
            {
                f[i][j]=f[i-1][k]+a[i][j-k];
                for(int tmp=1;tmp<=i-1;++tmp)
                {
                    num[i][j][tmp]=num[i-1][k][tmp];
                }
                num[i][j][i]=j-k;
            }
        }
    printf("%d\n",f[n][m]);
    for(int i=1;i<=n;++i)
    printf("%d %d\n",i,num[n][m][i]);
}
```

---

## 作者：小样儿鸣 (赞：5)

这是一个来自真·萌新做本题的思路与过程，也是我的第一篇题解

刚开始像无头苍蝇一样想了二三十分钟，最后画起了01背包的图...
就在对比着第i 个公司与第 i-1 个公司的分配时，突然想到了状态转移方程：

把已扫过的公司看作一个整体=f[1][x];
把当前公司看作待加入的整体=f[2][x];
当分配i台机器时(i=1->m);

**f[1][i]=max{f[1][i]+f[2][0],f[1][i-1]+f[2][1],...,f[1][0]+f[2][i]};**

解释：在第 i 个公司分配 j 个机器时，她有如下的选择：
{一个也不要，从之前公司中抢一个，从之前公司中抢两个，……全都要（j个）}

而f[1][0],f[1][1],……f[1][j]分别为：
{前 (i-1) 个公司没有机器时的最大利益，前 (i-1) 个公司有一个机器时的最大利益，前 (i-1) 个公司有两个机器时的最大利益，……前 (i-1) 个公司有 j 个机器时的最大利益}

决策就是从这之中做出选择，而决策的标准就是“谁最大”，即max{}。
决策过后，我们能获得前 i 个公司获得 j (j=1->m) 个机器时的最大利益。
于是整个问题就可以通过递推（应该是这么说的吧）解决了。

这时我还没有意识到第二问（求各个公司各获得了多少机器），但已经想到了把数组压缩一维（因为我还想着01背包），再看转移方程：

f[1][i]=max{f[1][i]+f[2][0],f[1][i-1]+f[2][1],...,f[1][0]+f[2][i]};
在 i=1->m 中我们需要用到的之前的状态范围为 0->i，也就是说，这个过程不需要 i 以后的数据，所以可以用从后向前推的方式压缩掉一维，状态转移方程变为：

**f[i]=max{f[0]+w[i],f[1]+w[i-1],……，f[i]+w[0]}**

其中i 从m到0，w数组代指当前公司获得 k 台机器时的回报。

然后打完了，提交，发现还有第二问……

解第二问的思路：字符串 c[i][j] 。一个字符串对应一个f[i]。
使用memset初始化字符串为 ’0’ 后，字符串内部应该是这样的：

c={“0000000000000000”,”0000000000000000”,……}
每个字符串（从第0位开始）第 i 位的数字即为该条件下第 i 个公司的机器数。
如：c[1][2]=’1’ 即表示分配1个机器时第2个公司获得了1个机器。

然而写题解时发现一个问题，如果一个公司获得的机器多于9个呢，岂不是直接爆了？然而我ac了，正想嘲笑数据太弱时，看了一眼我的输出：
printf("%d %d\n",i,c[m][i]-48);

原来我一直把char类型当数字用了，换句话说，这个c用int也可以。所以那个“+-48”就毫无必要了？
有必要，因为在char类型中0是’\0’，strncpy函数就用不了了。
然而由于重构成int 类型成本比较高，可能要开三维数组或是加入其他运算（好吧其实是我懒），所以这样用就行了，反正0~15的机器数量怎么也爆不了，反而可能会快些？

看了看大神们的代码，发现我还是要好好多学习学习啊。

下面是我的完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int a[11][16];		//存放数据 
int f[16];		//用来第一问的推导 
char c[16][16];		//16个字符串对应f[16];
//"000000...","010250..." 方便输出但不方便理解 
int main()
{
	memset(c,48,sizeof(c));			//把c变成"00000000000..."; 
	scanf("%d%d",&n,&m);
	for(int i=1;i<n+1;i++)
	{
		for(int j=1;j<m+1;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	//万一设备多了收益反而降了呢？
	//想起了做了无数遍的一元二次方程题...
	int xyem=0,itp=0;			
	for(int i=1;i<m+1;i++)		
	{
		if(a[1][i]>xyem)
		{
			f[i]=a[1][i];
			c[i][1]=i+48;
			xyem=a[1][i];
			itp=i;
		}
		else
		{
			f[i]=xyem;
			c[i][1]=itp+48;
		}
	}
	for(int i=2;i<n+1;i++)
	{
		for(int j=m;j>0;j--)
		{
			//f[j]初始状态为f[j]+a[0](a[0]显然为零),
			//所以k不需要=j就可以包括转移方程中的所有情况; 
			for(int k=0;k<j;k++)
			{
				//小于就可以保证字典序最小了
				if(f[j]<f[k]+a[i][j-k])
				{
					f[j]=f[k]+a[i][j-k];
					strncpy(c[j],c[k],m+1);
					c[j][i]=c[j][i]+j-k;
				}
			}
		}
	}
	//以下是输出 
	printf("%d\n",f[m]);		 
	for(int i=1;i<n+1;i++)		
	{
		printf("%d %d\n",i,c[m][i]-48);
	}
	return 0;
}
```



---

## 作者：lieee (赞：5)

第一问很简单的动态规划，略。
这一题比较难的是第二问要求字典序，不要求字典序的每个公司机器数可以根据第一问的二维数组倒着推出。但是要保证倒着推字典序就不容易了，可以通过搜索剪枝等方法，比较麻烦。
但是发现每个公司的顺序不一样，第一问的结果是相同的。
我们可以通过倒转输入（第一次输入第n个公司，以此类推），这样倒着推得到的顺序答案，就是每个公司的机器数，这时候我们倒着推每次取最小，就能保证字典序了。

---

## 作者：wwwsy (赞：4)

# 题目描述
有高效设备M台，分给N个分公司。

如何分配使盈利最大？

求出最大盈利值。**M≤15，N≤10。**

# 输入输出格式
## 输入格式：
第一行NM

然后N*M的矩阵，表明了第 I个公司分配 J台机器的盈利。

## 输出格式：
第1行为最大盈利值

第2到第n为第i分公司分x台

P.S.要求答案的字典序最小


------------
这道题的特点就是需要记录分配的方式，观察到数据范围不大，所以就可以大胆地循环。

1. 
------------

	for(int i=1;i<=n;i++)
		for(int j=m;j>=1;j--)
			for(int t=j;t>=0;t--)
            
第一层是公司的序号，第二层是共分配的机器数，第三层是给第i个公司分配几台；
### 第三层使用倒序是因为题目要求答案的字典序最小 
2. 
------------

	if(f[j-t]+a[i][t]>f[j])
				{
					for(int l=1;l<i;l++) b[l][j]=b[l][j-t];
					b[i][j]=t;
				}
                
b[ i ][ j ] 表示体积为 j 的背包价值最大时，给第 i 个公司分配个数；

当最大价值改变时，同样需要改变分配方式，只要将状态转移就好。




---

## 作者：yangshirui (赞：3)

【算法分析】

按照公司的顺序来分配机器，即按照公司的顺序划分阶段，第一个阶段把M台设备分给第一个公司，记录下来获得的各个盈利值，然后把M台设备分给前两个公司，和第一个阶段比较记录下来更优的各个盈利值，一直到第N个阶段把M台机器全部分给了N个公司，就可以得到最优解，下面来讨论两个阶段之间的关系，设数组F[I][J]表示前I个公司分配J台机器的最大盈利，数组F[I-1][K]表示前I-1个公司分配K台机器的最大盈利(1≤I≤N,1≤J≤M,0≤K≤J),用Value[I][J]表示第I个公司分配 J台机器的盈利, 则F[I][J]可以由下面的式子中取最大值获得：

F[I-1][0]+Value[I][J]   //前I-1公司分配0台机器最大盈利+第I个公司分配J台的机器的盈利

F[I-1][1]+Value[I][J-1] //前I-1公司分配1台机器最大盈利+第I个公司分配J-1台的机器的盈利

F[I-1][2]+Value[I][J-2] //前I-1公司分配2台机器最大盈利+第I个公司分配J-2台的机器的盈利

F[I-1][J-1]+Value[I][1] //前I-1公司J-1分配台机器最大盈利+第I个公司分配1台的机器的盈利

F[I-1][J]+Value[I][0]    //前I-1公司分配J台机器最大盈利+第I个公司分配0台的机器的盈利

在这里用机器数用做每个阶段的状态，由于Value[I][J]的值为定值，要使前面每个式子的值最大，就必须使第i-1阶段的各个状态的值最大，阶段i的状态只能由阶段i-1中的状态通过状态转移方程求得，与其他状态没有关系。由此可见，该问题具备了最优子结构和无后效性原则，适宜使用动态程序设计方法求解。状态转移方程为：F[I][J]=MAX{F[I-1][K]+Value[I][J-K]} (1≤I≤N,1≤J≤M,0≤K≤J)

初始值：F[0][0]=0，F[n][m]的值即为所求最大盈利值。

【参考程序】

  

```cpp
#include<iostream>
using namespace std;
#include<cstring>
int show(int,int);
long max1,f[11][20],value[11][20];
int main()
{
  long m,n,i,j,k;
  cin>>n>>m;
  for (i=1;i<=n;i++)
   for (j=1;j<=m;j++)
    cin>>value[i][j];
  for (i=1;i<=n;i++)
   for (j=1;j<=m;j++)
    { 
      max1=0;
      for (k=0;k<=j;k++)
       if (f[i-1][k]+value[i][j-k]>max1)
          max1=f[i-1][k]+value[i][j-k];
      f[i][j]=max1; 
    } 
cout<<f[n][m]<<endl;                         //输出最大盈利值
  show(n,m);                                   //输出分配情况
}
int show(int i,int j)                          //输出各分公司分配情况
{
  int k;
  if (i==0) return 0;
  for (k=0;k<=j;k++)
   if (max1==f[i-1][k]+value[i][j-k])          //递归求各公司分配的机器数量
     {
       max1=f[i-1][k];
       show(i-1,k);
       cout<<i<<" "<<j-k<<endl;
       break;
     }
}

```

---

## 作者：世界第一蒟蒻 (赞：2)

做了三天才想通第二问则么做

然后发现第二问好像没人用我这么蠢的方法

所以发上来了

希望能过审

~~被一道黄题卡了三天真是丢人~~

代码很丑，但不想改了

~~就是懒~~

第一问其他大佬写的比我好就不发了，直接第二问

思路是用深搜枚举所有可能的组合，剪枝

```cpp
void dfs(int deep,int ans,int mm){//mm为已分配的机器数
	if(ans>f[n][m]||mm>m) return;//剪枝
	if(deep>n){
		if(ans==f[n][m]){
			int tot=0;
			for(int i=1;i<=n;i++){//判断是否是更小的字典序
				if(b[i]<c[i]){
					break;
				}
				if(b[i]>c[i]){
					tot=1;
					break;
				}
			}
			if(tot==0){//如果是，更新
				for(int i=1;i<=n;i++){
					c[i]=b[i];
				}
			}
			return;
		}
		return;
	}
	for(int i=0;i<=m;i++){//i=0代表不选
		int bb=b[deep];
		b[deep]=i;
		dfs(deep+1,ans+a[deep][i],mm+i);
		b[deep]=bb;
	}
}
}
```

---

## 作者：lenaalyth (赞：2)

分组背包，扫了一眼好像没有一维背包写的。。所以发一下。。。其实也不算一维啦。。。。将公司获得的机器数当成重量，机器数为容量，每个公司为一组，然后直接用分组背包模板就可以了，因为数据较小，所以可以直接暴力得出结果。。。。代码如下
```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;
int dp[30],b,c,d,e[30][30],p[30][30];
int main()
{
	scanf("%d%d",&b,&c);
	for(int x=1;x<=b;x++)
	for(int y=1;y<=c;y++)
	{
		scanf("%d",&e[x][y]);
	}
	for(int x=1;x<=b;x++)//分组背包
	{
		for(int y=c;y>=1;y--)
		{
			for(int z=1;z<=y;z++)
			{
					int v=dp[y];
					dp[y]=max(dp[y],dp[y-z]+e[x][z]);
					if(v!=dp[y])//暴力
					{
						for(int i=1;i<=b;i++)
						{
							p[y][i]=p[y-z][i];
						}
						p[y][x]=z;
					}
					else if(dp[y]==dp[y-z]+e[x][z])
					{
						int i;
						for(i=1;i<=b;i++)
						{
							if(p[y][i]>p[y-z][i])
							break;
						}
						if(i!=b)
						{
						for(i=1;i<=b;i++)
						{	p[y][i]=p[y-z][i];}
						p[y][x]=z;	
						}
					}
			}
		}
	}
	printf("%d\n",dp[c]);
	for(int x=1;x<=b;x++)
	{
		printf("%d %d\n",x,p[c][x]);
	}
	return 0;
}
```

---

## 作者：Hunter_Will (赞：2)

奇奇怪怪的循环顺序，对于这种dp输出方案的题，还真是不好处理啊，wa了3遍。下面说说wa3遍的教训吧。这种输出字典序最小方案的题最好不要用滚动数组，因为滚动数组会限制循环的顺序。我使用了一个pre数组记录每一个状态从它之前的那个状态转移过来，然后再倒序输出，第二层枚举体积的循环一定要正序进行这样才能保证方案一定是字典序最小的。因为最外层是倒序枚举的，所以越靠后的物品越先被枚举到，这时要让越靠后的公司分到的机器越多的方案自然是字典序最小的了。因为只有最后一次更新的方案才会被保留下来，所以体积要正序枚举，使得体积最大的最后被枚举到，这样就可以AC了。

```cpp
for(int i=n;i>0;i--){
    for(int j=0;j<=m;j++){
        for(int k=0;k<=j;k++){
        if(dp[i][j]<dp[i+1][j-k]+f[i][k]){
            dp[i][j]=dp[i+1][j-k]+f[i][k];
            pre[i][j]=j-k;
        }
        }
    }
}
```

---

## 作者：Grace_White (赞：2)

【算法分析】  

   按照公司的顺序来分配机器，即按照公司的顺序划分阶段，第一个阶段把M台设备分给第一个公司，记录下来获得的各个盈利值，然后把M台设备分给前两个公司，和第一个阶段比较记录下来更优的各个盈利值，一直到第N个阶段把M台机器全部分给了N个公司，就可以得到最优解，下面来讨论两个阶段之间的关系，设数组F[I,J]表示前I个公司分配J台机器的最大盈利，数组F[I-1,K]表示前I-1个公司分配K台机器的最大盈利(1≤I≤N,1≤J≤M,0≤K≤J),用Valvu[I,J]表示第I个公司分配 J台机器的盈利, 则F[I,J]可以由下面的式子中取最大值获得：
   
F[I-1,0]+Value[I,J]     //前I-1公司分配0台机器最大盈利+第I个公司分配J台的机器的盈利 

F[I-1,1]+Value[I,J-1]  //前I-1公司分配1台机器最大盈利+第I个公司分配J-1台的机器的盈利

F[I-1,2]+Value[I,J-2]  //前I-1公司分配2台机器最大盈利+第I个公司分配J-2台的机器的盈利 

F[I-1,J-1]+Value[I,1]   //前I-1公司J-1分配台机器最大盈利+第I个公司分配1台的机器的盈利

F[I-1,J]+Value[I,0]     //前I-1公司分配J台机器最大盈利+第I个公司分配0台的机器的盈利

   在这里用机器数用做每个阶段的状态，由于Value[I,J]的值为定值，要使前面每个式子的值最大，就必须使第i-1阶段的各个状态的值最大，阶段i的状态只能由阶段i-1中的状态通过状态转移方程求得，与其他状态没有关系。由此可见，该问题具备了最优子结构和无后效性原则，适宜使用动态程序设计方法求解。
   
  状态转移方程为：F[i,j]=MAX{F[i-1,k]+Value[i,j-k]} (1≤I≤N,1≤J≤M,0≤K≤J)
  
  初始值：F[0,0]=0，F[n,m]的值即为所求最大盈利值。
 
【参考程序】

```
var  m，n：integer；      
i，j，k，max：longint;    
f- ，value：array[0..10,0..15] of  integer;
procedure  show(i，j：longint)；       //输出各分公司分配情况
var  k：longint;
begin 
if  i=0  then  exit; 
for k:=0 to j do   
  if max=f[i-1,k]+value[i,j-k]  then   
    begin   
    max:=f[i-1,k];    
    show(i-1,k);     
    writeln(i，‘ ‘，j-k);    
    exit;     
    end;     
end;
begin
readln(n，m); 
for I:= 1  to  n  do    
   for j:= 1  to  m  do       
      read(value[i，j]);      
for i:= 1  to  n  do
   for j:=1  to  m  do   
      begin              
      max:=0;               
      for k：= 0  to  j  do        
         if f[i-1,k]+value[i,j-k]>max  then  
           max：=f[i-1,k] + value[i,j-k];   
      f[i,j]：=max;     
      end;  
writeln(f[n，m]);   //输出最大盈利值 
show(n，m);    //输出分配情况
end.
```




---

## 作者：Arashi丶 (赞：2)

关于字典序的问题

把状态转移方程里的 < 或 > 改成 >=(<=)  就可以了
相同答案的话就直接字典序更新了
没必要倒序枚举

---

## 作者：wrhllll (赞：1)

我们可以按照公司的顺序来分配机器，即按照公司的顺序来划分阶段，第一个阶段把M台机器发给第一个公司，记录下获得的各个盈利值，然后把M台机器发给前两个公司，和第一个阶段比较记录下来更优的各个盈利值，一直到第N个阶段把M台机器全部分给了N个公司即可得到最优解。

# 注意以下部分!
设数组F[I][J]表示前I个公司分配J台机器的最大盈利,数组F[I-1][K]表示前I-1个公司分配K台机器的最大盈利(1<=I<=N;1<=J<=M;0<=K<=J)，用Value[I][J]表示第I个公司分配J台机器的盈利，则F[I][J]可以由下面的式子中取最大值获得：
```c
F[I-1][0]+Value[I][J]
F[I-1][1]+Value[I][J-1]
F[I-1][2]+Value[I][J-2]
F[I-1][J-1]+Value[I][1]
F[I-1][J]+Value[I][0]
```
状态转移方程：
```c
F[I][J]=MAX{F[I-1][K]+Value[I][J-K]}(1<=I<=N;1<=J<=M;0<=K<=J)
```
代码：
```c
#include<bits/stdc++.h>
using namespace std;
long max1;
long f[11][20],value[11][20];
int show(int i,int j)
{
    int k;
    if(i==0)return 0;
    for(k=0;k<=j;k++)
        if(max1==f[i-1][k]+value[i][j-k])
        {
            max1=f[i-1][k];
            show(i-1,k);
            cout<<i<<" "<<j-k<<endl;
            break;
        }
}
int main()
{
    long m,n,i,j,k;
    cin>>n>>m;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            cin>>value[i][j];
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
        {
            max1=0;
            for(k=0;k<=j;k++)
                if(f[i-1][k]+value[i][j-k]>max1)
                    max1=f[i-1][k]+value[i][j-k];
            f[i][j]=max1;
        }
    cout<<f[n][m]<<endl;
    show(n,m);
    return 0;
}
```

---

## 作者：wxy_god (赞：1)

发现有一篇题解是讲$dfs$的，但没有详细证明复杂度。本文讲解完思路后分析复杂度。  

### 主要思路

外部两个全局变量，$tot\ \&\ ans$，表示当前和以及当前最优解。$dfs$两个形参，分别为$num$和$get$，表示当前枚举第几个公司以及还剩下多少个机器。进入$dfs$，如果当前$num > n\ \&\ tot > ans$，将每个公司分配台数记录下来（这个在递归的时候也顺便记录下来），更新$ans$。接着，枚举当前这个公司分配的台数，从$0$到$get$（公司可以分配$0$台），递归之前更新$tot$和记录机器数量的数组即可。

### 代码

```
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>

const int N = 16;
int n, m;
int ans;
int tot;
int g[N];
int s[N];
int a[N][N];

inline void dfs (int num, int get) {
	if(num > n) {
		if(tot > ans) {
			ans = tot;
			for(register int i = 1; i <= n; ++ i ) s[i] = g[i];
		}
		return;
	}
	for(register int i = 0; i <= get; ++ i ) {
		tot += a[num][i];
		g[num] = i;//临时记录第num个公司分配台数
		dfs(num + 1, get - i);
		tot -= a[num][i];//递归之后要减去
	}
}

int main () {
	
	scanf("%d%d", &n, &m);
	for(register int i = 1; i <= n; ++ i )
	    for(register int j = 1; j <= m; ++ j )
	        scanf("%d", &a[i][j]);
	
	dfs(1, m);
	
	printf("%d\n", ans);
	for(register int i = 1; i <= n; ++ i ) {
		printf("%d %d\n", i, s[i]);
	}
	
	return 0;
}
/*
3 3
30 40 50
20 30 50
20 25 30
*/
```

### 复杂度分析

我们先把问题简化一下，如果每个公司至少$1$台，那么应该是多少呢？  
这个问题大概是相当于我们在小学学过的插板法，在$n$个数中有$n-1$个空隙来插板，要分成$m$段，则插$m-1$个板。则复杂度为$C^{m-1}_{n-1}$。  
现在每个公司可以分$0$台，这个问题没法直接求解，那么就需要将其转换为刚才的问题。我们只需要将物品个数加上$m$个，即可求出答案。所以复杂度为$C^{m-1}_{n+m-1}$。这个数算出来后是一个百万级别的数，在$10^8$的范围内。所以此题$dfs$可以过。

---

## 作者：doby (赞：1)

来一波动态规划解法……

状态转移方程：f[i][j]=max(f[i][j],f[i-1][k]+v[i][j-k])

```cpp
#include<iostream>
using namespace std;
int n,m,v[19][19],f[19][19],maxn;
void ss(int i,int j)
{
    if(i==0){return;}//如果所有公司都找过了，退出
    for(int k=0;k<=j;k++)//给当前公司分机器
    {
        if(maxn==f[i-1][k]+v[i][j-k])//此时的答案与某个解相同，则这个解就是我们曾经的解
        {
            maxn=f[i-1][k];//搜索上一个公司
            ss(i-1,k);//搜索
            cout<<i<<" "<<j-k<<endl;//输出当前公司的机器数
            break;//已找到解，退出避免重复
        }
    } 
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cin>>v[i][j];}}
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            for(int k=0;k<=j;k++)
            {
                if(f[i-1][k]+v[i][j-k]>=f[i][j]){f[i][j]=f[i-1][k]+v[i][j-k];}//状态转移
            }
        }
    }
    cout<<f[n][m]<<endl;
    maxn=f[n][m];ss(n,m);//最后根据最优解找路径
}
```

---

## 作者：Ouaoan (赞：1)

这题可以用动规做，但因数据较小，我用的dfs。

递归的第i层就是第i各公司分得的机器数量，在最后一层取最大就好。

cpp代码：





```cpp
#include<stdio.h>
#include<iostream>
using namespace std;
int n,m;    //公司数n，设备数m
int a[20][20]= {0};    //利益表
int b[20]= {0},c[20]= {0};
int total=0;
void dfs(int x,int s,int w) {
    int i,j;
    if(x==n+1&&w==m) {
        if(s>total) {
            total=s;
            for(i=1; i<=n; i++) {
                c[i]=b[i];
            }
        }
        return ;
    }
    if(x==n+1) {
        return ;
    }
    for(i=0; i<=m; i++) {
        if(i+w<=m) {
//            cout<<x<<' '<<s<<' '<<w<<' '<<i<<endl;
//            getchar();
            b[x]=i;
            dfs(x+1,s+a[x][i],w+i);
            b[x]=0;
        }
    }
}
int main() {
    int i,j,k;
    cin>>n>>m;
    for(i=1; i<=n; i++) {    //输入
        for(j=1; j<=m; j++) {
            cin>>a[i][j];
        }
    }
    dfs(1,0,0);
    cout<<total<<endl;
    for(i=1; i<=n; i++) {
        cout<<i<<' '<<c[i]<<endl;
    }
    return 0;
}
```

---

## 作者：maorui_cow (赞：1)

这一道题其实很简单的

首先我们可以推出此题的状态转移方针为f[i][j]=max(f[i-k][j]+v[i][j-k]);

然后就是简单dp欧
```
#include<bits/stdc++.h>
using namespace std;
int v[101][101],f[101][101],max1;
int out(int i,int j)//递归结果函数
{
	int k;
	if(i==0)
	{
		return 0;
	}
	for(k=0;k<=j;k++)
	{
		if(max1==f[i-1][k]+v[i][j-k])
		{
			max1=f[i-1][k];
			out(i-1,k);
			printf("%d %d\n",i,j-k);
			break;
		}
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&v[i][j]);//输入
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			max1=0;//注意max1要设为全局变量
			for(int k=0;k<=j;k++)
			{
				if(f[i-1][k]+v[i][j-k]>max1)
				{
					max1=f[i-1][k]+v[i][j-k];//记录最大值
				}
			}
			f[i][j]=max1;
		}
	}
	printf("%d\n",f[n][m]);//输出
	out(n,m);//用递归推出结果
	return 0;
}

```

//ac!!

---

## 作者：xuan__xuan (赞：0)

本题由于数据较小，也可以用搜索代码来解决。不过要注意的是，此题用动态规划同样可以解决。在这里提供C++代码

```cpp
#include<iostream>  
#include<cstdio>  
#include<cstring>  
#include<algorithm>  
#include<cmath>  
using namespace std;  
int G[100][100],n,m;  
int a[100],b[100];  
int bestf;  
int ans=-1;  
void dfs(int t,int tot,int last){  
    if(tot>m)return;   
    if(t>n){  
        if(tot==m){  //求出当前最优解，并赋值为当前最优方案；
            if(bestf>ans){  
                ans=bestf;  
                for(int j=1;j<=n;j++){  
                    b[j]=a[j];  
                }  
            }  
        }  
        return;  
    }  
    else{  
        for(int i=0;i<=m-last;i++){  
            if(i==0)dfs(t+1,tot,i);  //当我们选择0这个决策时，就什么也不用做，直接往下递归；
            else{  
                bestf+=G[t][i];  
                tot+=i;  
                a[t]=i;  
                dfs(t+1,tot,i);  
                a[t]=0;  
                bestf-=G[t][i];  
                tot-=i;  
            }  
        }  
    }  
}  
int main(){  
    cin>>n>>m;  
    memset(G,0,sizeof(G));  
    memset(b,0,sizeof(b));  
    for(int i=1;i<=n;i++){  
        for(int j=1;j<=m;j++){  
            cin>>G[i][j];  
        }  
    }  
    dfs(1,0,0);  
    cout<<ans<<endl;  
    for(int i=1;i<=n;i++){  
        cout<<i<<" "<<b[i]<<endl;  
    }  
    return 0;  
}  
值得注意的是，要记住b数组要初始化为0，一开始因为没有初始化就得了20分QAQ；
```

---

## 作者：Skywalker_David (赞：0)

最重要的，动态转移方程为：F[I,J]=MAX { F[I-1,K] + A[I,J-K]}  （1<=I<=N , 1<=J<=M , 0<=K<=J）

初始值：F[0,0]:=0 , F[N,M]的值即为所求最大盈利值。

```delphi

var
    m,n,i,j,k,max:longint;
    f,a:array[0..10,0..15] of longint;
    
procedure show(i,j:longint);
var 
    k:longint;
begin
    if i=0 then exit;
    for k:=0 to j do
        if max=f[i-1,k]+a[i,j-k] then
            begin
                max:=f[i-1,k];
                show(i-1,k);
                writeln(i,' ',j-k);
                exit;
            end;
end;

begin
    readln(n,m);
    for i:=1 to n do
        for j:=1 to m do
            read(a[i,j]);
    for i:=1 to n do
        for j:=1 to m do
            begin
                max:=0;
                for k:=0 to j do
                    if f[i-1,k]+a[i,j-k]>max then max:=f[i-1,k]+a[i,j-k];
                f[i,j]:=max;
            end;
    writeln(f[n,m]);
    show(n,m);
end.

```

---


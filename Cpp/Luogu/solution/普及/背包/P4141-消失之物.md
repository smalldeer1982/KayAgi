# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# 题解

## 作者：Kelin (赞：136)

题意:求少了第i个物品,装满大小为j的背包的方案数$\mod10,n,m\le 2e3$


暴力显然是$O(n^2m)$做$n$次背包就好了


其实只要跑一次背包(全部物品都在)


然后我们考虑少了某个物品怎么办?


我们在01背包DP时会用到这个转移


```cpp
for(int j=m;j>=w[i];--j)
    f[j]+=f[j-w[i]];
```

我们少了i物品就是在原来的基础上少了一次这样的转移


所以我们在原来的基础上顺推减去这样的一次转移就ok了


```cpp
memcpy(g,f,sizeof f);
for(int j=w[i];j<=m;++j)
    g[j]-=g[j-w[i]];
```

---

## 作者：King丨帝御威 (赞：63)

嗯……洛谷这个$OJ$还真的是挺好的……这道题是$BZOJ$的权限题……不扯了，来看这道题——


------------


大家看完这道题目，第一感觉肯定是要用背包来做(前提是你学过背包这种东西)，但是，直接用原先的$01$背包好像不太行，如果你非要用……那么就要跑n遍，对于每个消失的物品都跑一遍，然而，结果是$TLE$！！！

我们考虑在$01$背包的基础上的另一种策略：我们用$f[i][0]$表示不算消失的物品的能组成容积为$i$的方案数，那么这就成了一个$01$背包，显然：
```
for(int j=m;j>=v[i];--j)
f[j][0]+=f[j-v[i]][0];
```
用$f[i][1]$表示删掉某个物品后能组成容积为$i$的方案数，那么：
```
for(int i=1;i<=n;++i)
for(int j=1;j<=m;++j)
if(j-v[i]>=0) f[j][1]=f[j][0]-f[j-v[i]][1];
```
其中循环中的i表示删掉哪个物品，应该不难理解吧……最后，f数组的初始化就是:
```
f[0][0]=f[0][1]=1;
```
因为组成的容积是$0$，方案数显然就是$1$。
于是我们便有了下面的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#define maxn 2001
#define ll long long
using namespace std;
ll n,m,v[maxn],f[maxn][2];
inline ll qread()            //快读。
{
	char c=getchar();ll num=0,f=1;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) num=num*10+c-'0';
	return num*f;
}
int main()
{
	n=qread(),m=qread();
	for(int i=1;i<=n;++i) v[i]=qread();
	f[0][0]=f[0][1]=1;           //初始化。
	for(int i=1;i<=n;++i)
	{
		for(int j=m;j>=v[i];--j)    //f[i][0]的转移(这里的i代表容积)。
		{
			f[j][0]+=f[j-v[i]][0];
			f[j][0]%=10;
		}
	}
	for(int i=1;i<=n;++i)             //f[i][1]的转移(i含义同上)。
	{
		for(int j=1;j<=m;++j)
		{
			if(j-v[i]>=0) f[j][1]=(f[j][0]-f[j-v[i]][1]+10)%10;
			else f[j][1]=f[j][0]%10;
			cout<<f[j][1];
		}
		cout<<'\n';
	}
	return 0;
}
```
完美落幕，如果有什么问题或者代码出了什么$bug$，可以私信找我$QwQ$！

---

## 作者：Gary818 (赞：37)

# 【消失之物】  
[题目传送](https://www.luogu.org/problem/P4141)  
先说句题外话，这道题今年的新题解好少啊，不过这题目前没啥新鲜解法  
机房dalao最近在讲DP，偶然发现了这个好久之前就看了但是没敢做的题（还是我太菜了QwQ  
今天看了看，还是蛮裸的的一个背包    
**思路**：总的方案数-选当前物品的方案数=不选当前物品的方案数  
**过程**：我们首先定义三个数组w，f，g。（尽量定义的和其他dalao的题解一样，为了让大家参考多篇题解时，不用绞尽脑汁的一直切换变量的含义）显然w就是读入的数据，那么f和g呢？  
f[j]保存的是填满容积为j的背包的方案数，g[i]表示不选i的方案数，所以g[x-w[i]]表示开始不选i，最后再选上的方案数  
然后结合思路，你就AC了，是不是so easy，代码中有两次判断，分别是如果w[i]>x，g[x]=f[x]如果w[i]<=x,g[x]=f[x]-g[x-w[i]]。每次循环更新答案即可。  
**代码实现：**
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

const int maxn=2333;
int w[maxn],f[maxn],g[maxn];
int n,m;


int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>w[i];
    f[0]=1;
    for(int i=1;i<=n;i++)
        for(int j=m;j>=w[i];j--)
            f[j]=(f[j]+f[j-w[i]])%10;
    for(int i=1;i<=n;i++){
        g[0]=1;
        for(int x=1;x<=m;x++){
            if(w[i]>x) g[x]=f[x]%10;
            else g[x]=(f[x]-g[x-w[i]]+10)%10;//这里一定要+10,防止负数，我亲测不+10会只有10分……
            cout<<g[x];
        }
        cout<<endl;
    }
    return 0;   
}
```

---

## 作者：7KByte (赞：27)

简单证明一下撤销操作正确性。

正确性依赖于一个结论，就是物品的顺序对答案没有影响。

你会认为，这不是显然吗，向背包里放物品本来就没有顺序。但这是解题的关键。

既然改变一下物品的顺序对答案没有影响。因为背包不论先转移$a_1$还是先转移$a_n$都是一样的。

先对所有元素求出$f[]$数组。

所以当我们准备删除第$i$个元素时，此时的$f[]$数组可以看作将$a_i$最后一个转移，且刚刚转移完$a_i$时的状态。

显然刚转移完$i$，则可以撤销转移。原来是倒序转移，现在反过来，正序撤销。两者顺序正好相反，所以是正确的。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 2005
using namespace std;
int g[N],f[N],a[N],n,m;
int main(){
	scanf("%d%d",&n,&m);
	f[0]=1;
	rep(i,1,n){
		scanf("%d",&a[i]);
		pre(j,m-a[i],0)f[a[i]+j]+=f[j],f[a[i]+j]%=10;
	}
	rep(i,1,n){
		rep(j,0,m)g[j]=f[j];
		rep(j,0,m-a[i])g[a[i]+j]-=g[j],g[a[i]+j]+=10,g[a[i]+j]%=10;
		rep(j,1,m)printf("%d",g[j]);putchar('\n');
	}
	return 0;
}
```

---

## 作者：SpXace (赞：17)

楼上$dalao$的分治，$FFT$表示完全不懂$QWQ$


冥思苦想之后—— 背包

首先考虑普通二位背包的转移方程：
$f[i] = f[i - v[i]] +w[i] (i - v[i] >= 0)$


而这题的区别在于求的是方案数而非最大价值，
自然的我们考虑改一下方程

$f[i] = f[i - v[i] $

初始状态令 $f[0] = 1$

考虑每次删掉一个物品，由于我们计算的每个$f[i]$ 都由$f[i - v[i]]$ 转移而来，因此当删掉一个物品，必须将$v[i]$的贡献从每个$f[j]$ 中删掉，因此对于删掉一个物品，随着背包容量的增加，删掉的状态必然是递减的。

如何保存？

考虑开一个$g[i]$ 表示当删掉某一个物品时，容量为$i$的方案数。这样，在背包容量递减的时候，我们需要不断的删掉$v[i]$转移过来的状态，并不断累减。

当$j - v[i] >= 0$时，$g[j] = f[j] - g[j - v[i]]$

否则说明当前状态不会由$v[i]$转移过来，令$g[j] = f[j]$即可。

而此题只需输出最低位，为防止爆int，计算时不断取膜即可。
```
/*
time:2018年10月28日15:05:50 
Author:飞马の幻想
place:lzyz
type:背包 
from:https://www.luogu.org/problemnew/show/P4141
input:

output:

*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#define LL long long
#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define per(i, a, b) for(int i = a; i >= b; --i)
#define clr(a,b)  memset((a),b,sizeof(a))
using namespace std;
inline int Read(){
	int s = 0, w = 1; char ch = getchar();
	while(ch < '0' || ch > '9')   { if(ch == '-') w = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar(); }
	return s * w;
}
const int MX = 2e5 + 10;
int N, M, v[MX], f[MX], g[MX]; 
int main() {
	N = Read(), M = Read();
	rep(i, 1, N) v[i] = Read();
	f[0] = 1; 
	rep(i, 1, N) 
		per(j, M, v[i])
			f[j] = (f[j] + f[j - v[i]]) % 10;
	rep(i, 1, N) {
		g[0] = 1;
		rep(j, 1, M) {
			if(j - v[i] >= 0) g[j] = (f[j] - g[j - v[i]] + 10) % 10;
			else g[j] = f[j] % 10; 
			printf("%d", g[j]);
		}
		puts("");
	}
	return 0;
}



```

---

## 作者：Treaker (赞：14)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
## 背包计数
这道题是机房某巨佬讲DP时留的。今天来做一做。。。

看上去好像没有头绪。。

我们考虑这个物品所带来的贡献。从DP转移方程来看
$~f[j] += f[j-w[i]]~$。我们用$i$这个物品使得$~f[j-w[i]]~$转移到了$~f[j]~$。那么不用它之后剩下的方案数就是$~f[j] - f[j-w[i]]~$。

考虑真的对吗？ 仔细想想是不对的。。。$~f[j-w[i]]~$中也可能有$~w[i]~$的贡献。

所以我们引入一个$g$数组，$g[j]$表示容量为$j$不选$i$的方案数。

那么得到转移方程$~g[j] = f[j] - g[j - w[i]]~$

完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 2005;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m;
int w[N] , f[N] , g[N];
int main()
{
	n = read(); m = read();
	for(int i = 1;i <= n;i ++) w[i] = read();
	f[0] = g[0] = 1;
	for(int i = 1;i <= n;i ++)	for(int j = m;j >= w[i];j --)	f[j] += f[j - w[i]] , f[j] %= 10;
	for(int i = 1;i <= n;i ++)
	{
		for(int j = 1;j <= m;j ++)
		{
			if(j < w[i]) g[j] = f[j];
			else g[j] = (f[j] - g[j - w[i]] + 10) % 10;
			printf("%d",g[j]);
		}
		puts("");
	}
	return 0;
}

```


---

## 作者：keep_ (赞：8)

# 洛谷 p4141消失之物 (退背包)

***

[题目链接](https://www.luogu.com.cn/problem/P4141)

## 思路分析

如果我们去掉删除一个物品的限制，该题便转化为一个01背包了，但目前有删除物品的

限制，跑$n$次01背包？这样肯定会tle。我们考虑先忽略掉删除物品的限制，求出所有

的方案数，然后再枚举删除哪个物品，减去不符合的方案数，便可得到答案，有点类似容

斥。

## 算法分析

我们设$f[i][1]$表示装入物品总体积为$i$,删除掉目前所枚举物品时的方案数.设

$f[i][0]$表示装入物品总体积为$i$，未删除物品时的方案数。

先预处理无限制时的方案数
```c++
f[0][1]=f[0][0]=1;
for(int i=1;i<=n;i++){//i为物品编号
		for(int j=m;j>=v[i];j--){
			f[j][0]+=f[j-v[i]][0];
			f[j][0]%=10;//mod10是因为题目要求输出尾数字
		}
	}
```
接着减掉不符合目前情况的方案数
```c++
for(int i=1;i<=n;i++){//i为当前删除物品
		for(int j=1;j<=m;j++){
			if(j-v[i]>=0){
				f[j][1]=(f[j][0]-f[j-v[i]][1]+10)%10;
			}
			else{
				f[j][1]=(f[j][0]+10)%10;
			}
			cout<<f[j][1];
		}
		cout<<endl;
	}
```
为什么我们要这样递推
```c++
f[j][1]=(f[j][0]-f[j-v[i]][1]+10)%10;
```
我们来分析，$f[ j-v[i] ][1]$为占用体积为$j-v[i]$且不包含$i$物品的方案数，

为什么要把它减掉呢？因为$f[ j-v[i] ] [1]$表示所有使用物品$i$体积达到$j$的方案数,因为只要加上$v[i]$此时使用$i$且体积为$j$很明显，这是需要减掉的;

这样代码就可以写出来了

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<string>
using namespace std;
const int maxn=1e5;
inline int read(){
	int ret=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			f=-f;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		ret=ret*10+(ch^'0');
		ch=getchar();
	}
	return ret*f;
}
int f[maxn][2];
int v[maxn];
int n;
int m;
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		v[i]=read();
	}
	f[0][1]=f[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=m;j>=v[i];j--){
			f[j][0]+=f[j-v[i]][0];
			f[j][0]%=10;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(j-v[i]>=0){
				f[j][1]=(f[j][0]-f[j-v[i]][1]+10)%10;
			}
			else{
				f[j][1]=(f[j][0]+10)%10;
			}
			cout<<f[j][1];
		}
		cout<<endl;
	}
	return 0;
}
```

完结撒花

---

## 作者：Plus_Ultra (赞：5)

### 题解：

一. 前言

这道题是老师在 qbxt 讲的，现在想起来了，写篇题解加深记忆，同时希望能帮到和我一样的萌新.

二. 具体解法

1. 我们先考虑都可以选的情况.

   - 设 f[ x ] 表示全部物品都可用恰好装满 x 体积时的方案数，这不就是01背包吗，求出即可（别忘了第二维倒序循环）.
   
   - 这是总方案数.

2. 然后我们考虑不选某物品的情况.

   - 设 g[ x ] 为不选当前物品恰好装满 x 体积时的方案数.

	- 当x小于 w[ i ] 时， i 物品一定不会被选上 g[ i ] = f[ i ]. 

	- 当x大于等于 w[ i ] 时， i 物品可能会被选上.

	- 总方案数即 f[ x ] ，不选的方案数可以想为先不选 i 再最后把 i 选上,即 g[ x - w[ i ] ]。 

	- 所以 g[ x ] = f[ x ] - g[ x - w[ i ] ]， x 从小到大枚举计算 g 即可。

3. 时间复杂度

	- 每次都是线性复杂度，一共 n 次计算，总复杂度是 O(n * m).
    
下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>

#define N 2019

using namespace std;

int n,m,f[N]={1},g[N]={1},v[N];//初始化 

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)  
		cin>>v[i];
	
	for(int i=1;i<=n;i++)//这里先将f数组求出，和0/1背包一样 
	{
		for(int j=m;j>=v[i];j--)//别忘了0/1背包倒序枚举 
	  		f[j]=(f[j]+f[j-v[i]])%10;//选了的方案加上没选的方案 
	}
	  
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)//要正推，因为后面的g要用到前面不加这个物品的方案数 
		{
			if(j-v[i]>=0)  g[j]=(f[j]-g[j-v[i]]+10)%10;//见上方推导过程,还有,怕出现负数取模，先加一个10 
			else  g[j]=f[j]%10;//没选这个物品（体积不够） 
			cout<<g[j];
		}
		cout<<endl;//注意输出格式 
	}	
		
	return 0;//各数别忘了取模 
}
```

去掉空行后20来行，也是比较短的了.

###  _[Plus Ultra!](https://www.luogu.org/blog/OnePunchManGO/)_ 

---

## 作者：生而为人 (赞：4)

#### 题目描述
ftiasch 有 N 个物品, 体积分别是 W1, W2, …, WN。 由于她的疏忽, 第 i 个物品丢失了。 “要使用剩下的 N – 1 物品装满容积为 x 的背包，有几种方法呢？” — 这是经典的问题了。她把答案记为 Count(i, x) ，想要得到所有1 <= i <= N, 1 <= x <= M的 Count(i, x) 表格。

[](https://cdn.luogu.com.cn/upload/pic/13426.png)

#### 输入格式
第1行：两个整数 N (1 ≤ N ≤ 2 × 10^3)N(1≤N≤2×10 
3
 ) 和 M (1 ≤ M ≤ 2 × 10^3)M(1≤M≤2×10 
3
 )，物品的数量和最大的容积。

第2行： N 个整数 W1, W2, …, WN, 物品的体积。

### 输出格式
一个 N × M 的矩阵， Count(i, x)的末位数字。!

###### 一个巨大的坑， 要输出 末尾的数，所以 要MOD 10
设f[i][0]为嘛都不去的 计数DP，f[i][1]为去了一个物品的计数ＤＰ，
##### 枚举　删去的物品，设删去的物品编号为ｋ
f[i][0]=f[i][1]+f[i-v[k]][1];
根据小学数学理论 去移向 则有f[i][1]=-f[i][0]+f[i-v[k]][1]; 此题完。。。
```c
#include<iostream>
#include<cstdio>
using namespace std;
const int N=2005;
int n,m;
int a[N];
int f[N][2];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	f[0][0]=f[0][1]=1;
	for(int i=1;i<=n;i++)
	for(int j=m;j>=a[i];j--)
	f[j][0]+=f[j-a[i]][0],f[j][0]%=10;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(j-a[i]>=0)
			f[j][1]=(f[j][0]-f[j-a[i]][1]+10)%10;
			else
			f[j][1]=f[j][0];
			f[j][1]%=10;
			cout<<f[j][1];
		}
		cout<<endl;
	}
}
```


---

## 作者：Akaina (赞：1)

设f[i]表示填满容积为i的背包的方案数(0/1背包可以解决)

g[x]表示不选第i个物品的方案数

显然如果w[i]>x，g[x]=f[x]

如果w[i]<=x,g[x]=f[x]-g[x-w[i]]

注意：因为有取模运算，所以g[x]=(f[x]-g[x-w[i]]+10)%10是为了保证求出的是最小正整数解

```c++
#include <iostream>
#include <cstdio>
using namespace std;
int n,m;
int w[2010];
int f[2100],g[2100];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    f[0]=1;
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=w[i];j--)
            f[j]=(f[j]+f[j-w[i]])%10;
    }
    for(int i=1;i<=n;i++)
    {
        g[0]=1;
        for(int x=1;x<=m;x++)
        {
            if(w[i]>x)g[x]=f[x]%10;
            else g[x]=(f[x]-g[x-w[i]]+10)%10;printf("%d",g[x]);
        }
        printf("\n");
    }
    return 0;
}

```



---


# [蓝桥杯 2023 国 A] 圆上的连线

## 题目描述

给定一个圆，圆上有 $n=2023$ 个点从 $1$ 到 $n$ 依次编号。

问有多少种不同的连线方式，使得完全没有连线相交。当两个方案连线的数量不同或任何一个点连接的点在另一个方案中编号不同时，两个方案视为不同。

答案可能很大，请将答案对 $2023$ 求余后提交。

# 题解

## 作者：wangbinfeng (赞：24)

[![](https://img.shields.io/badge/题目-P10413_[蓝桥杯_2023_国_A]_圆上的连线-green)
![](https://img.shields.io/badge/难度-普及/提高−-yellow)
![](https://img.shields.io/badge/考点-数学（卡特兰数、排列组合）-blue)
![](https://img.shields.io/badge/题型-提交答案题（填空题）-red)](https://www.luogu.com.cn/problem/P10413)
[![](https://img.shields.io/badge/作者-wangbinfeng(387009)-purple)](https://www.luogu.com.cn/user/387009)

------------
> 引子：本题目前已有题解写的都挺滑稽的，全是“显然”、“可知”，但是看题解的人大概都是没有看出来卡特兰数的人。因此，我写这一篇题解，希望能帮助读者理解。

前置知识：卡特兰数。如果不会的同学可以看下面这个视频：
![](bilibili:BV1td4y1F7v1)

要在 $2023$ 个点中选任一些点进行连线，因为每个点最多只能连出一条线，所以每次选的点数一定是一个偶数。

假设选 $n$ 个点的方案数为 $a_n$，此时答案为 $b_n$，易得最终答案为 $\displaystyle\sum^{2023}_{i=1}\left[i \equiv 0\left(\bmod 2\right)\right]a_i b_i$。方案数 $a_n$ 代表从 $2023$ 个点中选出 $n$ 个点的方案数，可以看出是组合数 $C_{2023}^n$，那么问题就变成了如何求 $b_n$。其实 $b_n$ 的求法在题解最开始的视频中已经有了讲解，如果没看懂可以看下面的分析：
>令 $n=2x\left(x\in\N^*\right)$ ，对于任意一个点，所有合法的连出去的线，一定要把其余的点分成两个区域，且两个区域的点均为偶数个。令 $f(x)$ 表示点数为 $2x$ 时的连法，有 $f(x)=f(0)\times f(x-1)+f(1)\times f(x-2)+\dots+f(x-1)\times f(0)$。可以发现是卡特兰数，一般表示为 $H_n$。   
> 常见通项公式有 $3$ 种，分别是：$\normalsize H_n=C^{n}_{2n}-C^{n-1}_{2n}\tiny{\colorbox{yellow}{[1]}}\normalsize=\frac{1}{n+1}C^{n}_{2n}\tiny{\colorbox{yellow}{[2]}}=\normalsize\frac{4n-2}{n+1}H_{n-1}\tiny{\colorbox{yellow}{[3]}}$。题解开头的视频中有详细的证明，这里不再赘述。

带入 $a_n=C_{2023}^n,b_n=H_{\frac{n}{2}}$，可知答案为 $\displaystyle\sum^{2023}_{i=1}\left[i \equiv 0\left(\bmod 2\right)\right]C_{2023}^iH_{\frac{i}{2}}$（其中 $H_n$ 代表卡特兰数第 $n$ 项）。

组合数和卡特兰数的计算可以使用预处理，不要忘记对 $2023$ 取余，代码如下，答案为 `104`。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int n=2023,mod=2023;
long long c[n+9][n+9],h[n+9]={1,1},ans=1;
signed main(){
	for(int i=0;i<=n;i++)c[i][0]=1;
	for(int i=0;i<=n;i++)for(int j=1;j<=i;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    for(int i=2;i<=n;i++)for(int j=0;j<=i-1;j++)h[i]=(h[i]+h[j]*h[i-j-1]%mod)%mod;
	for(int i=1;i<=n;i++)if(i%2==0)ans=(ans+c[n][i]*h[i/2]%mod)%mod;
	cout<<ans;
}
```

---

## 作者：tanzexiaodezhonghao (赞：9)

~~一开始我还以为是求某个数的阶乘，但实际和这一点关系都没有。~~ 我看了看题解似乎都是卡特兰数，我一个蒟蒻可不会，就贡献一篇数学方法吧:
- 首先考虑连线的数量，对于每个点，可以选择与其连接的另一个点有 $n−1$ 个选项。因此，总的连线数量为 $(n−1)!$。
- 接下来考虑连线的顺序。当没有连线相交时，任意两条线的相对顺序是不重要的，因此我们需要对总的连线数量除以相对顺序的排列数量。每条连线的相对顺序有 $2$ 种可能，因此总的排列数量为 $2^{\dbinom{n}{2}}$。

所以有 $\dfrac{(n-1)!}{2^{\binom{n}{2}}} \bmod 2023$ 种方案，即 $104$。

---

## 作者：破壁人罗辑 (赞：5)

## 题意简述

给定一个圆，圆上有 $2023$ 个互不相同的点，求满足连线两两不相交的在圆上取点连线的方案总数。

## 解题思路

先考虑任意一个点都有连线的情况，这种情况下选取的点的个数一定是偶数。选取 $m$ 个节点，将节点按顺时针排序，考虑一号节点与 $k$ 号节点相连。若 $k$ 为奇数，则圆被分成两块 $k-2$ 和 $m-k$，每一块都有奇数个节点，两部分都不能全部连线配对，必然有一条线与一号节点所在的连线相交，不合题意；若 $k$ 为偶数，则圆被分成两块 $k-2$ 和 $m-k$，每一块都有偶数个节点，分治递归求解即可，终止条件为 $n\leq2$，此时方案数为 $1$。

因为不是每个节点都必须选中，所以我们求出所有选取偶数 $m$ 个节点的方案然后分别乘以 $C_n^m$ 即可，数据较小可以直接暴力求解。

## 解题代码
提交答案题，不用担心超时。
```cpp
#include<bits/stdc++.h>
#define MOD 2023
#define phi 1632
using namespace std;
unordered_map<int,int>mp;
int f(int n){
	if(n<=2)return 1;
	if(mp.find(n)==mp.end()){
		for(int i=0;i<n;i+=2)mp[n]=(mp[n]+f(i)*f(n-2-i))%MOD;
	}
	return mp[n];
}
int qpow(int x,int n){
	int r=1;
	while(n){
		if(n&1)r=r*x%MOD;
		x=x*x%MOD;n>>=1;
	}
	return r;
}
int C(int m,int n){
	int r=1;
	int cnt17=0,cnt7=0;
	for(int i=m;i>n;i--){
		int j=i;
		while(j%17==0){
			cnt17++;j/=17;
		}
		while(j%7==0){
			cnt7++;j/=7;
		}
		r=r*j%MOD;
	}
	for(int i=2;i<=m-n;i++){
		int j=i;
		while(j%17==0){
			cnt17--;j/=17;
		}
		while(j%7==0){
			cnt7--;j/=7;
		}
		r=r*qpow(j,phi-1)%MOD;
	}
	return qpow(7,cnt7)*qpow(17,cnt17)%MOD*r%MOD;
}
int main(){
	int ans=1;
	for(int i=2;i<2023;i+=2){
		ans=(ans+C(2023,i)*f(i))%MOD;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Nostopathy (赞：5)

# Solution

看题可知总方案数等于选偶数点的方案数乘对应偶数点的连线方案数之和。挑选偶数点的方案数可以使用组合数，偶数点的连线方案数就是一个卡特兰数。

为什么是卡特兰数，这里给出证明：在圆上任选一点，枚举这个点连边的位置，这条边把点分为左右部分，方案数就等于这两个部分各自方案数之积。结合卡特兰数的性质，可以发现，这就是一个卡特兰数。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int ir=2023;
int f[2033],a[2033][2033];
signed main(){
 f[0]=f[1]=1;
 for(int i=2;i<=1012;++i)
  for(int j=0;j<i;++j)
   f[i]=(f[i]+f[j]*f[i-j-1]%ir)%ir;
 for(int i=0;i<=ir;++i)
  for(int j=0;j<=i;++j){
   if(j==0)
    a[i][j]=1;
   else
    a[i][j]=(a[i-1][j]+a[i-1][j-1])%ir;
  }
 int quq=1;
 for(int i=2;i<=2022;i+=2)
  quq=(quq+a[ir][i]*f[i/2]%ir)%ir;
 cout<<quq<<'\n';
}
```

代码中，

```cpp
for(int i=2;i<=1012;++i)
 for(int j=0;j<i;++j)
  f[i]=(f[i]+f[j]*f[i-j-1]%ir)%ir;
```

可以求出卡特兰数；

```cpp
for(int i=0;i<=ir;++i)
 for(int j=0;j<=i;++j){
  if(j==0)
   a[i][j]=1;
  else
   a[i][j]=(a[i-1][j]+a[i-1][j-1])%ir;
}
```

可求出组合数，即挑选偶数点的方案数；

```cpp
quq=(quq+a[ir][i]*f[i/2]%ir)%ir;
```

则表示选偶数个点的方案乘偶数个点连线的方案。

答案为 $104$，直接提交即可。

谢谢观看。

---

## 作者：_Sky_Dream_ (赞：1)

# [传送门](https://www.luogu.com.cn/problem/P10413)

很显然总的方案数等于挑选偶点的方案数乘以对应偶点的连线方案数之和。

挑选偶点的方案数靠[组合数](https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E6%95%B0/2153250?fr=ge_ala)得出，偶点的连线方案数就是个[卡特兰数](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=ge_ala),结合[卡特兰数的性质](https://answer.baidu.com/answer/land?params=AFxKGEfCZ0a4RHnq9FefGL1aU%2FfxaaHoSKR3LNNN%2FX4NbyvIA%2FhOeE5XNQB57uL0kMSnSbb7spiYThC9U9zsGU3yV%2FHYHo0wBJWRlMFKviyf8tU%2Fe0VIdnEfUCUt3mshW5p8aKQx9hpxpUAefBbIU0UFHJfTUElPTHgmdLiPaVnnYi9MRLOrilK%2FI2nysk4JLpUD6pJUEGkY7oyCIfzUew%3D%3D&from=dqa&lid=a79b9b85024c3ea7&word=%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8)，即可得出正确代码。

AC Code:
```cpp
//#pragma GCC optimize(1)
//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define itn int
#define tni int
#define tin int
#define nit int
#define nti int
#define int long long
#define MAX 1145141919810
#define rep(i,x,y) for(int i=x;i<=y;++i)
using namespace std;
#define mod 2023
int f[2024]={1,1}; 
int a[2028][2028];
int ans=1; 
void Enchanted(){
	srand(time(0));
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	rep(i,2,1012)//求卡特兰数
	    rep(j,0,i-1)
	    	f[i]=(f[i]+f[j]*f[i-j-1]%mod)%mod;
	rep(i,0,2023)//求组合数
		rep(j,0,i)
			if(j==0) a[i][j]=1;
			else a[i][j]=(a[i-1][j]+a[i-1][j-1])%mod;
	for(int i=2;i<=2022;i+=2)ans=(ans+a[2023][i]*f[i/2]%mod)%mod;//全部加起来
	cout<<ans;
	exit(0);
}
signed main(){Enchanted();}

```

---

## 作者：ダ月 (赞：0)

首先，我们从 $2023$ 个点选 $n$ 个进行连边（$n$ 是一个偶数），那么有 $\binom{2023}{n}$ 种选择方式。

接下里问题变成了 $n$ 个点在一个环上，两两连边，要求不交的方案数。方案数是卡特兰数第 $\dfrac{n}2{}$ 项，记作 $H_{n/2}$。这个问题的证明见 P1375。

最后答案就是 

$$\sum_{i=0}^{1011}\binom{2023}{2i}H_{i}$$

你说 $2023$ 不是一个质数，有些数在模 $2023$ 下是没有逆元？但是 $H$ 和 $\binom{n}{m}$ 都是有 $n^2$ 递推式的。

```
const int N=3e3+10;
const int mod=2023;
ll C[N][N],H[N];
void solve(){
	//don't forget to open long long
	C[0][0]=1;
	for(int i=1;i<=3000;i++)
		for(int j=0;j<=3000;j++){
			if(j)C[i][j]=(C[i-1][j-1]+C[i][j])%mod;
			C[i][j]=(C[i][j]+C[i-1][j])%mod;
		}
	H[0]=1;
	for(int i=1;i<=3000;i++)
		for(int j=0;j<=i-1;j++)
			H[i]=(H[i]+1ll*H[j]*H[i-j-1]%mod)%mod;
	int ans=0; 
	for(int i=0;i<=2013;i+=2)
		ans=(ans+1ll*C[2023][i]*H[i/2]%mod)%mod;
	std::cout<<ans;
}
```

---

## 作者：abc1856896 (赞：0)

~~好的思路被抢了~~

# 题目大意

给定一个圆，圆上有 $n=2023$ 个点从 $1$ 到 $n$ 依次编号。

问有多少种不同的连线方式，使得完全没有连线相交，将答案对 $2023$ 求余后提交。

# solution

显然，答案等于挑选偶数点的方案数乘以对应偶数点的连线方案数之和。

挑选偶数点的方案数是简单的，直接用组合数求出即可。

而对于偶数点的连线方案数，我们根据卡特兰数的性质可以判断出偶点的连线方案数就是个卡特兰数。

在这里给出是卡特兰数的原因：我们可以在这个圆上选一点，然后再枚举这个点与其他点连边的位置。**这条边把点分为左右部分，结合卡特兰数的性质易得方案数就等于这两个部分各自方案数之积。**

# code

```cpp
#define int long long
#define mod 2023
int f[2030],a[2030][2030];
void cantlan(){
	f[0]=f[1]=1;
	for(int i=2;i<=1012;i++){
		for(int j=0;j<i;j++){
			f[i]=(f[i]+f[j]*f[i-j-1]%mod)%mod;
		}
	}
}
void CA(){
	for(int i=0;i<=2023;i++){
		for(int j=0;j<=i;j++){
			if(j==0) a[i][j]=1;
			else a[i][j]=(a[i-1][j]+a[i-1][j-1])%mod;
		}
	}
}
void solve(){
	cantlan();
	CA();
	int ans=1;
	for(int i=2;i<=2022;i+=2){
		ans=(ans+a[2023][i]*f[i/2]%mod)%mod;
	}
	cout<<ans;
}
```

---


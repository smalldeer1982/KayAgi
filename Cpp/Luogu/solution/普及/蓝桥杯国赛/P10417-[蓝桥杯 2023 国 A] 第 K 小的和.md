# [蓝桥杯 2023 国 A] 第 K 小的和

## 题目描述

给定两个序列 $A,B$，长度分别为 $n,m$。

设另有一个序列 $C$ 中包含了 $A,B$ 中的数两两相加的结果 ($C$ 中共有 $n\times m$ 个数)。问 $C$ 中第 $K$ 小的数是多少。请注意重复的数需要计算多次。例如 $1,1,2,3$ 中，最小和次小都是 $1$，而 $3$ 是第 $4$ 小。

## 说明/提示

**【评测用例规模与约定】**


- 对于 $40\%$ 的评测用例，$n,m\le 5000$，$A_i,B_i\le 1000$;
- 对于所有评测用例，$1\le n,m\le 10^5$，$1\le A_i,B_i\le 10^9$，$1\le K\le n\times m$。


## 样例 #1

### 输入

```
3 4 5
1 3 4
2 3 5 6
```

### 输出

```
6```

# 题解

## 作者：abc1856896 (赞：17)

# 题目大意

给定两个序列 $A,B$，长度分别为 $n,m$。

设另有一个序列 $C$ 中包含了 $A,B$ 中的数两两相加的结果。

问 $C$ 中第 $K$ 小的数是多少。

# solution
因为 $k \le 10^{10}$，所以我们不能枚举。

考虑二分。

左右边界都是简单的，一个设为 $0$，一个设为极大值即可。

判断函数也显而易见的：枚举 $A$ 序列里面的数，然后再找 $B$ 序列能和 $A$ 序列里选出来的数加起来之和小于等于 $t$ 即可。

但这样判断函数的时间复杂度是 $O(nm)$，会超时。

考虑优化。

超时的问题出现在判断函数的时间复杂度是 $O(nm)$。所以我们将枚举 $B$ 序列的循环改成二分即可。注意提前排序。

这样，判断函数的时间复杂度是 $O(n \log m)$。不会超时。

# code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m, k, a [100005], b [100005];
bool check ( int x ) { 
    int sum = 0;
    for(int i = 0 ; i < n ; i++ ) {
        sum += upper_bound ( b, b + m, x - a[i] ) - b;
    }
    return sum >= k;
}
signed main(){
    cin >> n >> m >> k;
    for(int i = 0 ; i < n ; i++ ) {
        cin >> a [i];
    }
  
    for(int i = 0 ; i < m ; i++ ) {
        cin >> b[i];
    }
    sort( b, b + m );
    int l = 0, r = INT_MAX;
    while(l + 1 < r ) {
        int mid = ( l + r ) / 2;
        if (check ( mid ) ) r = mid;
        else l = mid;
    }
    cout << r;
    return 0;
}

```

---

## 作者：stripe_python (赞：8)

题解都是二分套二分？来篇双指针。

首先说一下二分的思路：

对值域二分，将 $B$ 提前排序，`check` 中枚举 $A$ 的数，找 $B$ 中有几个数加上它小于等于 $k$。用 `std::upper_bound` 非常方便。

```cpp
#include <bits/stdc++.h>
#define N 100005
using namespace std;

long long n, m, k, a[N], b[N];

inline bool check(long long x) {
	long long cnt = 0;
	for (int i = 1; i <= n; i++) {
		cnt += upper_bound(b + 1, b + m + 1, x - a[i]) - b - 1;
	}
	return cnt >= k;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> b[i];
	sort(b + 1, b + m + 1);
	long long l = 0, r = INT_MAX, res = 0;
	while (l <= r) {
		long long mid = (l + r) >> 1;
		if (check(mid)) r = mid - 1, res = mid;
		else l = mid + 1;
	}
	cout << res;
	return 0;
}
```

考虑优化。对 $A$ 也排序。此时，答案有单调性，可以设置两个指针 $i,j$，当 $A_i+B_j > mid$ 时不断令 $j \gets j-1$，并统计答案。

```cpp
#include <bits/stdc++.h>
#define N 100005
using namespace std;

long long n, m, k, a[N], b[N];

inline bool check(long long x) {
	long long cnt = 0;
	for (int i = 1, j = m; i <= n; i++) {
		while (a[i] + b[j] > x) j--;
		cnt += j;
		if (cnt >= k) return true;
	}
	return false;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> b[i];
	sort(a + 1, a + n + 1), sort(b + 1, b + m + 1);
	long long l = 0, r = INT_MAX, res = 0;
	while (l <= r) {
		long long mid = (l + r) >> 1;
		if (check(mid)) r = mid - 1, res = mid;
		else l = mid + 1;
	}
	cout << res;
	return 0;
}
```

---

## 作者：Kazeno_Akina (赞：8)

发现 $K$ 数据范围十分的大，于是考虑怎么出一个合理一点的复杂度。遂想到二分。

然后你考虑怎么二分。容易发现题目让你输出的是数值而不是具体谁和谁加一起的。鉴于算的是 kth，所以直接考虑如何计算一个数是不是 kth：你直接算比它小的有多少个就好了。这个可以二分做，复杂度 $O(n \log n)$。

发现那个“有多少个数比它小”很有单调性，所以外面再套一个二分就行了。总复杂度 $O(n \log n \log W)$，其中 $W$ 是值域。

代码如下：（远古时期写的，太丑了别骂）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
long long a[N],b[N];
long long n,m,k,ans;
long long find1(long long l,long long r,long long p)
{
  long long mid;
  if(b[r]<=p) return r;
  while(l<r)
  {
      mid=(l+r)>>1;
      if(b[mid]>p) r=mid;
      else l=mid+1;
  }
  if(b[r]>p) return l-1;
  else return 0;
}
long long check(long long t)
{
  long long res=0;
  for(int i=1;i<=n&&a[i]<t;i++) res+=find1(1,m,t-a[i]);
  return res;
}
long long find(long long l,long long r,long long p)
{
  long long mid;
  while(l<r)
  {
    mid=(l+r)>>1;
    if(check(mid)>=p) r=mid;
    else l=mid+1;
  }
  return l;
}
int main()
{
  cin >> n >> m >> k;
  for(int i=1;i<=n;i++) cin >> a[i];
  for(int i=1;i<=m;i++) cin >> b[i];
  sort(a+1,a+n+1);
  sort(b+1,b+m+1);
  ans=find(a[1]+b[1],a[n]+b[m],k);
  cout << ans;
  return 0;
}
```

---

## 作者：2023gdgz01 (赞：5)

见到字眼“第 $K$ 小”，考虑二分答案。判断当前 $mid$ 是否小于 $K$。

很显然，我们不能强行计算 $C_i$，于是我们需要先对 $B$ 数组从小到大排序，然后在判断 $mid$ 是否小于 $K$ 的函数中遍历 $A$ 数组，二分查找出 $A_i+B_j\le mid$ 的最大的 $j$，将 $j$ 累加起来并存入 $cnt$ 变量。遍历完 $A$ 数组后的 $cnt$ 就是小于等于当前 $mid$ 的 $C_i$ 个数。若 $cnt<K$，则 $l\gets mid+1$，否则，$r\gets mid$。注意，虽然 $l,r$ 在极限情况下最大为 $2\times10^9$，但是在计算 $mid$ 时，$l+r$ 最大可能为 $4\times10^9$，需要开 `long long`；$K$ 和 $cnt$ 最大可能为 $nm=10^{10}$，也需要开 `long long`。代码如下：

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

int n, m;
long long K, l, r = 2e9, mid, A[100005], B[100005];

inline bool check() { //判断小于等于当前 mid 的 C[i] 个数是否小于 K
	long long cnt = 0;
	for (register int i = 1; i <= n; ++i) //遍历 A 数组
		cnt += upper_bound(B + 1, B + m + 1, mid - A[i]) - B - 1; //计算小于等于 mid - A[i] 的 B[j] 个数
	return cnt < K;
}

int main() {
	scanf("%d%d%lld", &n, &m, &K);
	for (register int i = 1; i <= n; ++i)
		scanf("%lld", A + i);
	for (register int i = 1; i <= m; ++i)
		scanf("%lld", B + i);
	sort(B + 1, B + m + 1); //将 B 数组排序以便二分查找
	while (l < r) { //二分答案
		mid = l + r >> 1;
		if (check())
			l = mid + 1;
		else
			r = mid;
	}
	printf("%lld", l);
	return 0;
}
```

时间复杂度为 $O((n+m)\log m)$。[AC 链接](https://www.luogu.com.cn/record/159065548)

---

## 作者：wwxxbb (赞：4)

## 思路：二分+双指针

看到第 $k$ 小，想到二分，又因为值域有单调性，所以我们对值域二分答案，`check` 函数套一个双指针。

为什么这样可以？我们把 $a,b$ 数组排序后，此时，答案也具有单调性，可以用双指针来判断。

时间复杂度 $\mathcal{O}(n\log{n})$，比二分套二分的 $\mathcal{O}(n\log^2{n})$ 优。

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
const int N = 100005;

int n, m, k, a[N], b[N];

bool check(int x) {
    int cnt = 0;
    for (int i = 1, j = m; i <= n; i ++) {
        while (a[i] + b[j] > x) j --;
        cnt += j;
        if (cnt >= k) return 1;
    }
    return 0;
}

signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> m >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= m; i++) cin >> b[i];
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    int l = 1, r = INT_MAX, ans = 0;
    while (l <= r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid - 1, ans = mid;
        else l = mid + 1;
    }
    return cout << ans, 0;
}
```

---

## 作者：PineappleSummer (赞：4)

[Problem](https://www.luogu.com.cn/problem/P10417)

一个比较板的二分答案。

考虑 check 当前二分值 $mid$ 与第 $k$ 小数的关系，如果比第 $k$ 小数小，让 $l=mid+1$，否则 $r=mid$。

如何 check？考虑对于一个数 $a_i$，要想让 $a_i+b_j\le x$，则应使 $b_j\le x-a_i$，对于 $b_j$ 的个数如何求，可以在 $b$ 数组排序后 `upper_bound` 一下再减 $1$ 得到。得到 $b_j$ 的个数并累加，判断是否大于等于 $k$ 即可。

代码：
```cpp
#define int long long
bool check (int x) {
	int res = 0;
	for (int i = 1; i <= n; i++)
		res += upper_bound (b + 1, b + m + 1, x - a[i]) - b - 1;
	return res >= k;
}
signed main ()
{
	ios::sync_with_stdio (false);
	cin.tie (0); cout.tie (0);
	
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> b[i];
	sort (b + 1, b + m + 1);
	int l = 0, r = INT_MAX;
	while (l < r) {
		int mid = (l + r) >> 1;
		if (check (mid)) r = mid;
		else l = mid + 1;
	}
	cout << l;
	return 0;
}
```
时间复杂度 $O(n\log n\log V)$，其中 $V$ 是值域。

---

## 作者：xiaoyang111 (赞：3)

## 前言

[题目传送门。](https://www.luogu.com.cn/problem/P10417)

没错就是我天真的以为用堆维护就可以直接过了。没错就是我开始没开长整。没错我就是个小丑。

## 题解

### 思路

看数据范围，发现 $K$ 可以到可怕的 $10^{10}$。这种范围显然是不能枚举的，所以我们考虑其他方法。

我们显然是不能从枚举数来下手的，所以我们直接从答案下手。直接找答案只有一种方法，就是二分答案。

范围就是答案的范围，最大可以到 $2 \times 10^9$，最小可以是 $2$。

那么判断函数怎么写呢。显然我们是要跟 $K$ 做对比的，因为 $K$ 这么重要不可能不出现对吧。假设我们现在已经拿到加和的最大值 $t$ 了，所以考虑算出有多少对数的和是小于等于 $t$ 的。再和 $K$ 做对比。

判断函数里面的算有多少对数的和是小于等于 $t$ 怎么算呢？我们可以先枚举 $a$ 数组里面的数，然后再找 $b$ 数组能和再 $a$ 数组选出来的数加起来是小于等于 $t$ 的就可以了。对于找 $b$ 数组这件事，可以先把 $b$ 数组给排序，再直接二分查找就可以了。

那么答案序列是否具有单调性呢，因为这个 $t$ 越大说明这两个数加起来的数就可以越大，所以答案序列具有单调性。

### 代码

思路出来了，代码很简单。

```cpp
//直接二分答案 
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
const int N=1e5+5;
int a[N],b[N];
long long n,m,k;
bool check(int mid){
	long long ans=0;//数对个数
	for (int i=0;i<n;++i){//枚举算个数 
		ans+=upper_bound(b,b+m,mid-a[i])-b;//计算
	}
	return ans>=k;//判断
}
signed main(){
	cin >> n >> m >> k;
	for (int i=0;i<n;++i){
		scanf("%lld",&a[i]);
	}
	for (int i=0;i<m;++i){
		scanf("%lld",&b[i]);
	}
	sort(b,b+m);//排序
	int l=0,r=2e9+5;//保险开大一点
	while (l<r){//二分模板
		int mid=l+r>>1;
		if (check(mid)){
			r=mid;
		}else{
			l=mid+1;
		}
	}
	cout<<l<<endl;
	return 0;
}
```

---

## 作者：Melo_qwq (赞：1)

好的双指针，可以当板子刷。

# 题目大意

两个数组中两两求和构成第三个数组，求第三个数组中第 $k$ 小的数。

# 题目实现

求第 $k$ 小显然用二分。

设当前枚举的数是 $x$，用双指针维护小于 $x$ 的值（注意保证单调性）。

如果已经大于等于 $k$，那显然不行（因为 $x$ 肯定超过第 $k$ 大），不然就继续向大枚举。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
const int N = 1e5 + 7 ;
int n ,m ,k ,a[N] ,b[N] ; 
template < typename T > inline void read (T &x) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = -x : 0 ;
}
inline bool check (int x) {
	int j = m ,cnt = 0 ;
	f (i ,1 ,n ,1) {
		while (j && b[j] + a[i] > x) {
			j -- ;
		} // 一个正着一个倒着循环可以保证单调性，不明白可以手模一下
		cnt += j ;
		if (cnt >= k) return false ;
	}
	return true ;
}
signed main () {
	read (n) ,read (m) ,read (k) ;
	int m1 = LONG_LONG_MIN ,m2 = LONG_LONG_MIN ;
	f (i ,1 ,n ,1) {
		read (a[i]) ;
		m1 = max (m1 ,a[i]) ; 
	}
	f (i ,1 ,m ,1) {
		read (b[i]) ;
		m2 = max (m2 ,b[i]) ;
	}
	sort (a + 1 ,a + n + 1) ;
	sort (b + 1 ,b + m + 1) ;
	int l = 0 ,r = m1 + m2 ,ans ;
	while (l <= r) {
		int mid = l + r >> 1 ;
		if (check (mid)) {
			l = mid + 1 ;
		}
		else r = mid - 1 ,ans = mid ; // 注意 ans 要在这里更新，因为 ans 最后记录的 mid 值一定是最大的满足二分中 cnt < k 的，也就是第 k 小，仔细想一想 
	} 
	cout << ans << '\n' ;
	return 0 ;
}
//kafka & かみや & 申鶴
```

---

## 作者：Redamancy_Lydic (赞：1)

我又来水估值啦。

## 分析

~~这道题不是板子么。~~

先对序列排序，然后二分答案，设当前答案为 $x$，枚举 $a$ 中的数，然后二分查找 $b$ 中不大于 $x-a$ 的元素个数，累加判断是否不大于 $k$。

然后稍微调一调端点就过了。

## Code

```cpp

#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#include<ext/pb_ds/trie_policy.hpp>
#include<ext/pb_ds/priority_queue.hpp>
#define int long long
using namespace std;
using namespace  __gnu_pbds;
//gp_hash_table<string,int>mp2;
//__gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> q;
inline int read()
{
	int w=1,s=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+(ch-'0');ch=getchar();}
	return w*s;
}
const int mod=998244353;
const int maxn=1e5+10;
int n,m,k,a[maxn],b[maxn];
bool ch(int x)
{
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]>=x)break;
		int t=upper_bound(b+1,b+m+1,x-a[i])-b;
		t--;
		sum+=t;
	}
	return sum<=k;
}
signed main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=m;i++)b[i]=read();
	sort(a+1,a+n+1);sort(b+1,b+m+1);
	b[m+1]=1e9+7;
	int l=1,r=2e9+10;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(ch(mid))l=mid+1;
		else r=mid;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：GeXiaoWei (赞：0)

# P10417 [蓝桥杯 2023 国 A] 第 K 小的和
## 题目解析
先想一种血腥的思路，把合成的序列算出来再排序求解。但那样的话，不是时间超限就是内存超限。

再想想如何优化，滚动数组肯定不行。用二分的话，需要在有序序列中进行。可以二分答案大小，下限为零，上限极大值，先枚举序列一里面的数，然后再找序列二能和序列一选出来的数加起来是小于等于答案的就可以了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,a[100005],b[100005],l,r,mid,ans;
bool check(long long x){
	ans=0;
	for(int i=1;i<=n;i++) ans=ans+upper_bound(a+1,a+n+1,x-b[i])-(a+1);
	return ans>=k;
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=m;i++) scanf("%lld",&b[i]);
	sort(a+1,a+n+1);
 	r=0x3f3f3f3f;
	while(l<r){
		mid=(l+r)>>1;
		if(check(mid)) r=mid;
		else l=mid+1;
	}
	printf("%lld",l);
	return 0;
} 
```

---


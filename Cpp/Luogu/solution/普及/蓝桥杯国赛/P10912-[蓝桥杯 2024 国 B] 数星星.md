# [蓝桥杯 2024 国 B] 数星星

## 题目描述

小明正在一棵树上数星星，这棵树有 $n$ 个结点 $1, 2,\cdots, n$。他定义树上的一个子图 $G$ 是一颗星星，当且仅当 $G$ 同时满足：

1. $G$ 是一棵树。
2. $G$ 中存在某个结点，其度数为 $|V_G| - 1$。其中 $|V_G|$ 表示这个子图含有的结点数。

两颗星星不相同当且仅当它们包含的结点集合 $V_G$ 不完全相同。小明想知道这棵树上有多少颗不同的星星包含的结点的数量在区间 $[L, R]$ 中，答案对 $1000000007$ 取模。

## 说明/提示

**【样例说明】**

包含 $3$ 个结点的星星有 $5$ 个，它们的结点集合分别为 $\{1, 2, 3\}$，$\{1, 2, 4\}$，$\{1, 2, 5\}$，$\{2, 4, 5\}$，$\{1, 3, 6\}$。

包含 $4$ 个结点的星星有 $1$ 个，它的结点集合为 $\{1, 2, 4, 5\}$。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，保证 $n \le 20$。  
对于 $100\%$ 的评测用例，保证 $n \le 10^5$，$1 \le L \le R \le n$。


## 样例 #1

### 输入

```
6
1 2
1 3
2 4
2 5
3 6
3 4```

### 输出

```
6```

# 题解

## 作者：buowen123 (赞：16)

- 2024-08-24：交题解。
- 2025-03-12：思路会在 $|V_G|=2$ 时假掉，修改题解。感谢 tmp_get_zip_diff 大佬提出问题。

## 题目大意
给你一棵 $n$ 个点的树 $T$ 和两个数 $L,R$，问你有多少个 $T$ 的子图 $G$ 满足：
- $G$ 是一棵树，且存在一个结点 $u$，满足在 $G$ 中 $u$ 的度数为 $|V_G|-1$，其中 $|V_G|$ 表示 $G$ 的点数。
- $|V_G| \in [L,R]$。

## 题目分析

好题。

首先 $u$ 的度数为 $|V_G|-1$，这是一个非常逆天的性质。

$G$ 中总共只有 $|V_G|$ 个点，哪怕 $u$ 和其他所有点相连，度数也才 $|V_G|-1$。换句话说，$G$ 中所有点都与 $u$ 相连，即 $G$ 是一张以 $u$ 为中心的**菊花图**。

然后你发现，如果一个点 $u$ 的度数为 $d_u$，你想要一个大小为 $m$ 的菊花图，你就可以在与 $u$ 相连的 $d_u$ 个点中任意选择 $m-1$ 个点作为叶子（为什么要减一自己想）。所以选择方案就是 $C_{d_u}^{m-1}$。

题目限定了 $m \in [L,R]$，所以答案就是

$$\sum_{u\in T}\sum_{i=L}^RC_{d_u}^{i-1}$$

然而非常迅速地发现，这么做的时间复杂度是 $O(n\times(R-L+1))=O(n^2)$，会超时。很快的想到一个优化：对于相等的 $d_u$，右边的式子没必要再算一遍，调用之前的结果即可。

你发现你过了，为什么呢？

注意到一个性质：$\sum_{u \in T}d_u=2(n-1)$。这是因为每增加一条边，结点度数的和只增加 $2$。

你算算 $d_u$ 里究竟有多少个不同的数。哪怕所有数都不同而且尽可能小，有 $k$ 个不同的数，也有 $1+2+3+\dots +k=\frac{k(k+1)}{2}\le n$，**也就是 $k$ 最多只有 $\sqrt n$ 级别。**

所以优化后的时间复杂度是 $O(n \sqrt n)$，而且基本跑不满，可以通过。

----

当然，上述的做法**是错的**。

注意到，若 $|V_G|=2$，那么 $G$ 就只有一条边，这样的 $G$ 有 $n-1$ 个。然而上述代码中，对于一条边 $(u,v)$，$u,v$ **都是这个这个菊花的中心**，因而这条边在以 $u$ 为中心，$v$ 为中心时**各计算了一遍**，所以总共计算了 $2(n-1)$ 个！在 $|V_G|\neq2$ 时，一个菊花只会有一个中心，所以不会错。

因此，$L\le 2\le R$ 时，答案要减去 $n-1$。当然官方数据中似乎不存在这种情况。

心心念念的 code 来啦！

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 100000 + 5, mod = 1e9 + 7;
int n, d[N], L, R, ans, cur[N], vis[N];
ll fac[N], infac[N];
ll qpow(ll a, ll b) {
	ll res = 1;
	while (b) {
		if (b & 1) res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;
}
ll inv(ll a) {
	return qpow(a, mod - 2);
}
void init(int n) {
	fac[0] = infac[0] = 1;
	for (int i = 1; i <= n; i++) {
		fac[i] = fac[i - 1] * i % mod;
		infac[i] = inv(fac[i]);
	}
}
ll C(ll a, ll b){
	if (a < b || a < 0 || b < 0) return 0;
	return fac[a] * infac[a - b] % mod * infac[b] % mod;
}
ll get(int a) {
	if (vis[a] == false) {
		vis[a] = true;
		for (int i = L - 1; i <= R - 1; i++) {
			cur[a] = (cur[a] + C(a, i)) % mod;
		}
		return cur[a];
	}
	else return cur[a];
}
int main() {
	cin >> n;
	for (int i = 1; i <= n - 1; i++) {
		int u, v;
		cin >> u >> v;
		d[u]++, d[v]++;	
	}
	cin >> L >> R;
	init(n);
	for (int i = 1; i <= n; i++) {
		ans = (ans + get(d[i])) % mod;
	}
	// 下面这句话要加，当然不加可以 AC
	if (L <= 2 && 2 <= R) ans = ((ans - n + 1) % mod + mod) % mod;
	cout << ans << '\n';
	return 0;
} 
```

---

## 作者：Ke9_qux (赞：5)

前置知识：[组合数](https://oi.wiki/math/combinatorics/combination/) 、[逆元](https://oi.wiki/math/number-theory/inverse/) 。~~不会的出门右转。~~

## Part 1. 题意

给定一棵树，定义树上的一个子图 $G$ 是一颗星星，当且仅当：
- $|V_G| \in [L, R]$。
- $G$ 中存在某个结点，其度数为 $|V_G| - 1$。
  
求这棵树不同的星星个数，对 $10^9+7$ 取模。

## Part 2. 分析

一个星星的本质，就是**有且仅有两层的树**。  
设某个星星的节点数为 $K$，根节点的度数为 $D$，显然叶节点的选取方式有 $\dbinom{D}{K-1}$ 种，分别枚举 $K$ 和根节点，累加即可。要注意特判 $K=1$ 时，总的方案数是 $N$；$K=2$ 时，总的方案数要除以 $2$，因为此时无法区分根节点，会算重复。组合数的计算可以通过预处理阶乘和阶乘逆元实现。  
分析一下时间复杂度。令节点 $i$ 的度数为 $D_i$，那么 $K$ 的枚举范围在 $L-1$ 与 $\min(D_i,R-1)$ 之间（含）。由于给定的图是树，那么 $\sum_{D} = 2 N$。易得 $T(N) \le 2N$。时间复杂度 $\Theta(N)$。

## Part 3. AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=1e5;
const ll mod=1e9+7;

bool __stb;

int n,l,r;
int deg[N+1];
ll frc[N+1],inv[N+1],finv[N+1];
ll ans;

bool __enb;

ll qpow(ll a,ll b) {
	if(b==1) return a;
	ll t=qpow(a,b/2);
	if(b%2==0) return t*t%mod;
	return t*t%mod*a%mod;
}

void init() {
	frc[0]=1;
	for(int i=1;i<=n;i++) frc[i]=frc[i-1]*i%mod;
	inv[0]=1;
	for(int i=1;i<=n;i++) inv[i]=qpow(i,mod-2);
	finv[0]=1;
	for(int i=1;i<=n;i++) finv[i]=finv[i-1]*inv[i]%mod;
}

ll C(int x,int y) {
	if(x<0||y<0||x<y) return 0;
	return frc[x]*finv[y]%mod*finv[x-y]%mod;
}

int main() {
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cerr<<(&__enb-&__stb)/1024.0/1024.0<<" MB"<<endl;
	cin>>n;
	for(int i=1,u,v;i<n;i++) {
		cin>>u>>v;
		deg[u]++;
		deg[v]++;
	}
	cin>>l>>r;
	init();
	if(l==1) ans+=n,l++;
	if(l==2&&l<=r) {
		ll t=0;
		for(int i=1;i<=n;i++) (t+=deg[i])%=mod;
		ans+=t/2;
		l++;
	}
	if(l<=r) for(int i=1;i<=n;i++) {
		for(int j=l-1;j<=min(deg[i],r-1);j++) {
			(ans+=C(deg[i],j))%=mod;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：MaiJingYao666 (赞：1)

### P10912 [蓝桥杯 2024 国 B] 数星星 题解  
### 解题思路  
首先，题目的意思就是数菊花图。  

记一个节点的子节点个数为 $s_i$。  

我们对于一个菊花，考虑它在树中的构造。显然如果已经确立了菊花的“根”，那么剩下的“花瓣”就一定是它的子节点或父节点。  

那么对“花瓣”中有无父节点进行讨论，假设要选 $x$ 个点：  
1.    有父节点。前置条件是至少也要选一个子节点，不然会有重复。那么个数就是 $C_{s_i}^{x-2}$。
2.    无父节点。个数显然是 $C_{s_i}^{x-1}$。

显然一个点只会作为子节点一次，所以大力枚举即可。  

组合数的话，模数是质数，预处理阶乘再用费马小定理即可。

### AC 代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1e9+7;
const int N=1e5+50;
int n,l,r;
vector<int> G[N];
int siz[N];
void dfs(int p){
	for(auto j:G[p]){
		if(siz[j]) continue;
		siz[p]++;
		dfs(j);
	}
}
ll qpow(ll a,ll b){
	ll res=1LL;
	while(b){
		if(b&1) res=res*a%mod;
		b>>=1;
		a=a*a%mod;
	}
	return res;
}
ll jc[N];
ll C(int a,int b){
	if(b>a) return 0LL;
	return jc[a]*qpow(jc[a-b],mod-2)%mod*qpow(jc[b],mod-2)%mod;
}
int main(){
	scanf("%d",&n);
	jc[0]=jc[1]=1LL;
	for(ll i=2;i<=n;i++){
		jc[i]=jc[i-1]*i%mod;
	}
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1);
	scanf("%d%d",&l,&r);
	ll ans=0;
	for(int j=l-1;j<=min(r-1,siz[1]);j++){
		ans=(ans+C(siz[1],j))%mod;
	}
	for(int i=2;i<=n;i++){
		for(int j=l-1;j<=min(r-1,siz[i]+1);j++){
			if(j>=2) ans=(ans+C(siz[i],j-1))%mod;
			if(j<=siz[i]) ans=(ans+C(siz[i],j))%mod;
		}
	}
	printf("%lld",ans);
}
/*

*/
```

---

## 作者：Programmeryhl (赞：1)

### 题意简介

给定一棵 $n$ 个节点的树和 $L,R$，询问有多少个子图 $G$，满足该子图是一棵树，树中存在一个节点 $u$，其度数为 $|V_G|-1$，且 $|V_G| \in [L,R]$。

### 思路

观察到每一个满足条件的子图 $G$中，$u$ 的度数为 $|V_G|-1$ 意味着 $u$ 和 $G$ 中其他所有点均有一条连边，故 $G$ 必然是一张**菊花图**。

那么对于每一个节点 $u$，设其度数为 $deg_u$，对于 $\forall m \in [1,deg_u+1]$，该节点可以对大小为 $m$ 的星星数量产生 $C_{deg_u}^{m-1}$ 的贡献。

如果直接遍历每一个节点分别统计，时间复杂度将会达到 $O(n \times (R-L+1))$ 即 $O(n^2)$ 级别，对于 $N=1 \times 10^5$ 显然会超时，所以我们考虑预处理出 $num_i$ 表示度数为 $i$ 的节点数量，这样在算到度数相同的节点时可以直接将贡献乘上一个 $num_i$，此时设有 $t$ 种不同的 $deg_u$，$\Sigma_{i=1}^t \leq n$，即 $t$ 一定不会超过 $\sqrt{n}$，最终的时间复杂度为 $O(n\sqrt{n})$。

### Code

```c++
//度为i的节点可以为节点数为j的星星数提供C(i,j-1)的贡献
#include<iostream>
#define IOS ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
using namespace std;
const int N=1e5+5;
const int MOD=1e9+7;
int n,L,R,degree[N],num[N];
long long fac[N],inv[N],ans=0;
long long quick_pow(long long a,long long b)
{
    long long base=a,res=1;
    while(b)
    {
        if(b&1) res=res*base%MOD;
        base=base*base%MOD;
        b>>=1;
    }
    return res;
}
void init(int n)
{
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=fac[i-1]*i%MOD;
    inv[n]=quick_pow(fac[n],MOD-2);
    for(int i=n;i>=1;i--)
        inv[i-1]=inv[i]*i%MOD;
}
long long C(int n,int m)
{
    if(m<0||m>n) return 0;
    return fac[n]*inv[m]%MOD*inv[n-m]%MOD;
}
int main()
{
    IOS;
    cin>>n;
    init(n);
    for(int i=1;i<n;i++)
    {
        int u,v;
        cin>>u>>v;
        degree[u]++,degree[v]++;
    }
    cin>>L>>R;
    for(int i=1;i<=n;i++)
        num[degree[i]]++;
    for(int i=max(1,L-1);i<=n;i++)
    {
        if(num[i]>0)
            for(int j=L;j<=min(R,i+1);j++)
                ans=(ans+num[i]*C(i,j-1)%MOD)%MOD;
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：liuchuliang666 (赞：0)

首先观察这个特殊的条件：$G$ 中存在一个度数为 $|V_G| - 1$ 的结点。

$G$ 可是一棵树啊！这说明 $G$ 是一个菊花图（好像也叫「星星图」来着）。

我们取这个菊花图的根，也就是这个度数为 $|V_G| - 1$ 的结点为这个图的代表元，很容易得到下面的算法：

枚举每一个结点作为菊花图的根，记其度数为 $d$，枚举每一个 $s \in [L, R]$ 作为菊花的大小，那这意味着除去这个结点自己，还需要在其相邻的结点中选 $s - 1$ 个，这有 $\binom{d}{s - 1}$ 种方案，求和即可。

但是需要注意，对于 $s = 2$ 的情况，上述算法会正好算多一倍，这是因为这时每一条边及其连接的两个结点都分别为菊花的根算了一遍，因此要在总结果中减去边数 $n - 1$（本题目数据并未）。

你可能会问：这个复杂度不是 $O(n^2)$ 的吗？

实则不然，注意到我们枚举 $s \in [L, R]$ 时候，我们枚举到 $s \in [L, \min(d + 1, R)]$ 即可，那么每个结点枚举量级在 $O(d)$，每个都来一次，就是 $O(n)$。

我们一开始便可以 $O(n)$ 线性递推阶乘及其逆元，那么总复杂度为 $O(n)$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int ll
typedef long long ll;
typedef const int cint;
constexpr int MAXN = 1e5 + 10, mod = 1e9 + 7;
int frac[MAXN], ifrac[MAXN], L, R, n, d[MAXN], ans;
template <typename T> inline void add(T &a, const T b) { a = ((a + b) % mod + mod) % mod; }
template <typename T> inline void mul(T &a, const T b) { a = ((a * b) % mod + mod) % mod; }
int qpow(int a, int b)
{
    static int res;
    for (res = 1; b; b >>= 1, mul(a, a)) ((b & 1) && (mul(res, a), 1));
    return res;
}
int inv(cint x) { return qpow(x, mod - 2); }
void init(cint n) // 预处理阶乘及其逆元
{
    frac[0] = 1;
    for (int i = 1; i <= n; i++) frac[i] = frac[i - 1] * i % mod;
    ifrac[n] = inv(frac[n]);
    for (int i = n - 1; i >= 0; i--) ifrac[i] = ifrac[i + 1] * (i + 1) % mod;
}
int comb(cint n, cint m) { return frac[n] * ifrac[m] % mod * ifrac[n - m] % mod; }
signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n, init(n);
    for (int u, v, i = 1; i < n; i++) cin >> u >> v, d[u]++, d[v]++;
    cin >> L >> R;
    if (L <= 2 && 2 <= R) ans -= n - 1; // 特判：当要统计大小为 2 的菊花时，会多算 n - 1 个！
    for (int i = 1; i <= n; i++)
        for (int j = L; j <= min(R, d[i] + 1); j++)
            add(ans, comb(d[i], j - 1));
    cout << ans;
    return 0;
}
```

---

## 作者：Breath_of_the_Wild (赞：0)

题意：给一棵树，求多少个子树，满足有节点的度在 $[L,R]$ 之间。

以下将当前枚举的“节点的度在 $[L,R]$ 之间”简称为“子树结点数”。

是计数题。很明显你需要枚举每一个结点，看看子树中每一种在 $[L,R]$ 的子树节点数的个数之和。

特殊情况：若子树结点数为 $1$，此时贡献为 $n$；若子树结点数为 $2$，显然贡献为 $n-1$。

否则，枚举每一个结点。设当前节点编号为 $i$，当前枚举的子树结点数为 $j$，则贡献为 $\dbinom{deg_i}{j-1}$，$j$ 要减 $1$ 是因为要去除掉当前结点再去选 $j-1$ 个。

然后因为计算组合数要取模，所以用一下逆元。树不用真正建出来，因为用到的信息只有每一个结点的度。以下代码省略输入部分和定义变量部分。
```cpp
#include<bits/stdc++.h>
using namespace std;
ll QP(ll a,ll b){
	ll as=1;
	while(b){
		if(b&1) as=as*a%M;
		a=a*a%M;
		b>>=1;
	}
	return as;
}
ll C(ll n,ll m){
	if(n==m) return 1;
	return jc[n]*QP(jc[m],M-2)%M*QP(jc[n-m],M-2)%M;
}

// jc: 阶乘
int main(){
// 预处理阶乘，输入...
	if(L==1){
		ans+=n;
		L++;
		if(L>R){
			cout<<ans;
			return 0;
		}
	}
	if(L==2){
		ans+=n-1;
		L++;
		if(L>R){
			cout<<ans;
			return 0;
		}
	}
	for(int i=1;i<=n;i++){
		if(deg[i]+1>=L){
			for(int j=L;j<=min(deg[i]+1,R);j++){
				if(j==1){
					ans+=n;
					ans%=M;
					continue;
				}else if(j==2){
					ans+=n-1;
					ans%=M;
					continue;
				}
				ans+=C(deg[i],j-1);
				ans%=M;
			}
		}
	}
  return 0;
}
```

---


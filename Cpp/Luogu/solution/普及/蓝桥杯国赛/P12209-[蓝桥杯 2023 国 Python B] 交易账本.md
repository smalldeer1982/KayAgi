# [蓝桥杯 2023 国 Python B] 交易账本

## 题目描述

小蓝最近研发了一种新的记账方式，并邀请了一些用户参加测试。交易账本可以看作是交易记录的集合，每条交易记录都有着一个独一无二的交易编号 $txId$（编号大小反映了交易记录产生的时间顺序，$txId$ 小的交易记录先发生于 $txId$ 大的交易记录），每条交易记录包含一个或多个输入信息以及一个或多个输出信息。

其中输入来自于已经发生过的某笔交易的某个输出，可以理解为这笔钱从某笔交易输出后继续输入到了当前这笔交易中，输入信息主要包含以下数据： $fromTxId$、$fromTxOutNumber$，这表示当前输入来自于交易编号为 $fromTxId$ 的第 $fromTxOutNumber$ （$fromTxOutNumber=0,1,2, \cdots$）个输出；输出信息主要包含以下数据：$account$、$val$，表示将 $val$ 数目的钱转移到了账户编号为 $account$ 的账户上。注意，当 $fromTxId$ 和 $fromTxOutNumber$ 都为 $-1$ 时，表明这是一笔特殊交易，由系统账户直接产生输出，特殊交易只含有一个输入和一个输出，可以认为系统账户拥有无限多数目的钱，特殊交易一定可以成功。

一个合法的账本应满足以下条件：
1) 对于每笔交易记录，所有的输入中涉及到的钱的总数目应和所有输出中钱的总数目相等；
2) 交易中的一个输出要么不使用，要使用的话输出中的钱应该全部分配给下一个输入，而不能分配给多个输入（特殊交易除外）；
3) 交易按照顺序进行，不可以在某笔交易中引用还未发生的交易。

现在已知一共有 $N$ 个不同的账户，初始时所有账户钱数目都为 $0$，账本上总计有 $M$ 条交易记录（按照交易完成的顺序进行记录），请你来判断下账本上的记录是否是合法的。

## 说明/提示

### 样例说明

对于第一个数据：第一条交易 $(txId=0)$ 为特殊交易，给账户 0 转入了 100；第二条交易 $(txId=1)$ 将上一条交易的唯一一个输出作为当前交易的输入，有两个输出，分别给账户 1 和 2 转入了 50；最后一条交易 $(txId=2)$ 将上一条交易的两个输出作为当前交易的输入，给账户 2 转入了 100 。

对于第二个数据，第三条交易中输入与输出总额不相等。

对于第三个数据，第一条交易中的输出被使用了超过一次。

对于第四个数据，第二条交易中引用了还未发生的交易的输出。

### 评测用例规模与约定

对于所有评测用例， $1 \leq T \leq 10$，$1 \leq N \leq 100$，$1 \leq M \leq 1000$，$1 \leq inCount, outCount \leq 100$，$1 \leq$ 交易中涉及到钱的数目 $\leq 10000$，$0 \leq account \leq N-1$。

## 样例 #1

### 输入

```
4
3 3
1 -1 -1 1 0 100
1 0 0 2 1 50 2 50
2 1 0 1 1 1 2 100
3 3
1 -1 -1 1 0 100
1 0 0 2 1 50 2 50
2 1 0 1 1 1 2 150
3 3
1 -1 -1 1 0 100
1 0 0 2 1 50 2 50
3 0 0 1 0 1 1 1 2 200
3 3
1 -1 -1 1 0 100
2 0 0 2 0 2 1 100 2 100
1 -1 -1 1 2 100```

### 输出

```
YES
NO
NO
NO```

# 题解

## 作者：Lele_Programmer (赞：0)

# P12209 题解

## 思路

记交易编号为 $i$ 的第 $j$ 个输出为 $d_{i,j}$，其是否被使用过为 $g_{i,j}$。

每一次处理输入的时候，如果 $fromTxId$（下文称 $id$）和 $fromTxOutNumber$（下文称 $num$） 均为 $-1$，则标记 $flag$ 为 $1$，表示出现特殊交易，否则的话，如果 $id<i$ 即引用的输出必须在此之前并且 $g_{id,num}$ 为 $0$ 即还未用过，则将 $d_{id,num}$ 加入 $add$ 中，并将 $g_{id,num}$ 标为 $1$，如果至此还不能成为合法输入，则标记为不合法。

至此，如果合法，那么来处理交易输出，读入用户的 $account$ 压根没用，读入 $val$，则从 $add$ 中减去 $val$，并将 $d_{i,j}$ 设置为 $val$。

处理完输出，如果已经 $flag$ 为 $1$ 即存在特殊交易，则无需判定无解，如果 $add$ 不是等于 $0$，则无解。

## 代码

```cpp
const int N=105;
const int M=1005;

int T,n,m;
int d[M][N];
bool g[M][N];

int main() {
    read(T);
    while (T--) {
        memset(d,0,sizeof(d));
        memset(g,0,sizeof(g));
        read(n),read(m);
        bool yes=true;
        _rep(i,0,m-1) {
            int inc;
            read(inc);
            bool flag=false;
            bool ok=true;
            int add=0;
            _rep(j,0,inc-1) {
                int id,num;
                read(id),read(num);
                if (!~id && !~num) flag=true;
                else if (id<i && !g[id][num]) add+=d[id][num],g[id][num]=true;
                else ok=false;
            }
            if (!ok) yes=false;
            int ouc;
            read(ouc);
            _rep(j,0,ouc-1) {
                int acc,val;
                read(acc),read(val);
                add-=val,d[i][j]=val;
            }
            if (flag) continue;
            if (add!=0) yes=false;
        }
        if (yes) puts("YES");
        else puts("NO");
    }
    return 0;
}
```

---


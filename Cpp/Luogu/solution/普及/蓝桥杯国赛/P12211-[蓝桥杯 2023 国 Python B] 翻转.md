# [蓝桥杯 2023 国 Python B] 翻转

## 题目描述

小蓝制作了 $n$ 个工件，每个工件用一个由小写英文字母组成的，长度为 $2$ 的字符串表示，第 $i$ 个工件表示为 $s_{i}$。小蓝想把 $n$ 个工件拼接到一起，方便转移到另一个地方完成下一道工序，而拼接后的工件用字符串 $S=s_{1}+s_{2}+\ldots+s_{n}$ 表示，其中 $+$ 表示一种奇特的拼接方式：对于 $c=a+b$ 来说，如果 $a$ 的第二个字符和 $b$ 的第一个字符相同，则拼接后的结果 $c$ 长度为 $3$ 而不是 $4$，中间相同的字符可以省略一个，比如 $\tt{xy}+\tt{yz}=\tt{xyz}$ 而 $\tt{xy}+\tt{zy}=\tt{xyzy}$。小蓝为了让拼接后的字符串 $S$ 的长度尽量小，可以将若干个工件进行左右翻转之后再进行拼接，请问拼接后的字符串 $S$ 的最小长度是多少?

请注意所有工件必须按出现顺序依次拼接，可以翻转任意工件。


## 说明/提示

### 样例说明

将 $s_{2}$ 翻转后, 拼接结果为 $\tt{abczz}$, 长度为 $5$。

### 评测用例规模与约定

- 对于 $20 \%$ 的评测用例, $n \leq 20$；
- 对于所有评测用例, $1 \leq n \leq 10^{5}$。

## 样例 #1

### 输入

```
3
ab
cb
zz```

### 输出

```
5```

# 题解

## 作者：czh1005 (赞：4)

这道题很明显是 dp，最开始想的是一维状态。 \
$dp_{i}$ 表示前 $i$ 个字符串拼起来的最小长度。\
但发现这样子就不知道上一个字符串翻没翻转。\
所以加一个维度。\
$dp_{i,0/1}$ 表示前 $i$ 个字符串拼起来，如果是 $0$ 表示第 $i$ 个字符串不进行翻转，如果是 $1$ 表示第 $i$ 个字符串进行翻转的最小长度。\
每个字符串用 $a_{i}$，$b_{i}$ 表示。\
转移方程：\
$$dp_{i,0} \gets \min(dp_{i-1,0}+2-[b_{i-1}=a_{i}],dp_{i-1,1}+2-[a_{i-1}==a_{i}])$$\
$$dp_{i,1} \gets \min(dp_{i-1,0}+2-[b_{i-1}=b_{i}]),dp_{i-1,1}+2-[a_{i-1}==b_{i}])$$\
代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,dp[maxn][2];
char a[maxn],b[maxn];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i]>>b[i];
    dp[1][0]=dp[1][1]=2;//初始化 
    for(int i=1;i<=n;i++){
    	//转移方程 
    	dp[i][0]=min(dp[i-1][0]+(b[i-1]==a[i]?1:2),
		dp[i-1][1]+(a[i-1]==a[i]?1:2));
		dp[i][1]=min(dp[i-1][0]+(b[i-1]==b[i]?1:2),
		dp[i-1][1]+(a[i-1]==b[i]?1:2));
	}
	cout<<min(dp[n][0],dp[n][1])<<'\n';//输出答案 
    return 0;
}
```

---

## 作者：chrispang (赞：2)

## 题目大意

给定 $n$ 个长度为 $2$ 字符串，可以将其中的任意字符串进行翻转，然后按顺序将这些字符串拼接起来。最后拼接完成的字符串将删去相邻且相等的两个字符中的一个。问最后可获得的最短字符串的长度是多少。

## 题目分析

考虑使用 DP。

- **状态**：设 $f_{i,0/1}$ 为前 $i$ 个字符串可以构成的最短字符串，其中 $0$ 表示第 $i$ 个字符串不翻转，$1$ 表示第 $i$ 个字符串翻转。

- **状态转移方程**：

  > $f_{i,0}=\min\{f_{i-1,0}+2-[s_{i,0}= s_{i-1,1}],f_{i-1,1}+2-[s_{i,0}= s_{i-1,0}]\}$。
  >
  > $f_{i,1}=\min\{f_{i-1,0}+2-[s_{i,1}= s_{i-1,1}],f_{i-1,1}+2-[s_{i,1}= s_{i-1,0}]\}$。

- **初始化**：$f_{1,0/1}=2$。
- **答案**：$\min\{f_{n,0},f_{n,1}\}$。

代码就不放了，按照题解思路实现就可以了。

---

## 作者：Forge_Unique (赞：2)

## 题意

有 $n$ 个长度为 $2$ 的字符串，对于 $c=a+b$ 来说，如果 $a$ 的第二个字符和 $b$ 的第一个字符相同，则拼接后的结果 $c$ 长度为 $3$ 而不是 $4$，中间相同的字符可以省略一个，比如 $\tt{xy}+\tt{yz}=\tt{xyz}$ 而 $\tt{xy}+\tt{zy}=\tt{xyzy}$。

## 思路

用 $dp_{i,0/1}$ 来表示第 $i$ 个字符串翻不翻转与前 $i - 1$ 个字符串的最优解，就是上一个字符串的尾部与当前字符串的首部，上一个字符串的尾部与当前字符串的尾部，上一个字符串的首部与当前字符串的首部，上一个字符串的首部与当前字符串的尾部分别判断这四种情况能否相连即可。

初始化：$dp_{i,0}$ 与 $dp_{i,1}$ 都为 $2$。

答案：$dp_{n,0}$ 与 $dp_{n,1}$ 的最小值。

## 优化

由于每次的转台转移只在 $i$ 和 $i - 1$ 中发生。所以只要设一个 $dp1$ 和 $dp2$ 分别表示 $i$ 翻与不翻的最优解。

最后输出 $dp1$ 和 $dp2$ 的最小值即。
时间复杂度为 $O(N)$ 可以通过本题。

[c++代码](https://www.luogu.com.cn/paste/hfkr1dpk)

[python代码](https://www.luogu.com.cn/paste/27sphk7e)

---

## 作者：linruicong_gegeji (赞：1)

一眼动态规划。

## 题目大意

有 $n$ 个字符串，每个字符串都只有两位，我们要把它们拼接起来。如果字符串 $a$ 的末位与字符串 $b$ 的首位一样，我们在拼接的时候可以将这两个字符融合起来，使得长度变短。我们还可以将任意字符串翻转，最终目的是使得拼接过后的字符串长度尽可能短。

## 题目分析

我们定义一个二维数组 $f$ 来表示每一阶段的答案。定义 $f_{i,j}$ 为进行到第 $i$ 个字符串时的最优解。$j$ 只可能等于 $1$ 或者 $0$，分别表示当前字符串翻转和不翻转的情况。

接下来状态转移方程就很好推了。

对于 $i-1$ 的不同状态，我们取其最小值并加上当前长度做为当前阶段的最优解。易得方程（假定字符串数组命名为 $s$）：
$$f_{i,0}=\min(f_{{i-1},0}+2-[s_{{i-1},2}=s_{i,1}],f_{{i-1},1}+2-[s_{{i-1},1}=s_{i,1}])$$
$$f_{i,1}=\min(f_{{i-1},0}+2-[s_{{i-1},2}=s_{i,2}],f_{{i-1},1}+2-[s_{{i-1},1}=s_{i,2}])$$

## AC 代码
[记录](https://www.luogu.com.cn/record/229561769)

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[100005][5];
int n,f[100005][2];
int main()
{
	scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
    f[1][0]=f[1][1]=2;//预处理
    for(int i=2;i<=n;i++)
    {
        f[i][0]=min(f[i-1][0]+(s[i-1][2]==s[i][1]?1:2),f[i-1][1]+(s[i-1][1]==s[i][1]?1:2));//状态转移方程
        f[i][1]=min(f[i-1][0]+(s[i-1][2]==s[i][2]?1:2),f[i-1][1]+(s[i-1][1]==s[i][2]?1:2));
    }
    printf("%d",min(f[n][0],f[n][1]));//输出答案
    return 0;
}
```

---

## 作者：chenyunting (赞：1)

# 思路

这是一道动态规划的题目，每个工件有翻转和不翻转两种情况。

## 定义状态

- `fanzhuan[i]` 表示前 $i$ 个单词中第 $i$ 个单词要翻转的最优解。
- `bufanzhu` 表示前 $i$ 个单词中第 $i$ 个单词不翻转的最优解。

## 决策

### &zwnj;**更新 `bufanzhuan[i]`（第 $i$ 个不翻转）**&zwnj;  
   - 如果前一个单词&zwnj;**不翻转**&zwnj;：  
     检查当前单词的首字符与前一单词的末尾字符是否相同（`a[i][0] == a[i-1][1]`）。 
     - 相同 → 长度叠加 `+1`。  
     - 不同 → 长度叠加 `+2`。
     ```
     bufanzhuan[i] = min(bufanzhuan[i], bufanzhuan[i-1] + (条件满足 ? 1 : 2))
     ```
   - 如果前一个单词&zwnj;**翻转**&zwnj;：  
     检查当前单词的首字符与前一翻转单词的首字符是否相同（`a[i][0] == a[i-1][0]`）。  
     - 相同 → 长度叠加 `+1`。  
     - 不同 → 长度叠加 `+2`。  
     ```
     bufanzhuan[i] = min(bufanzhuan[i], fanzhuan[i-1] + (条件满足 ? 1 : 2))
     ```

### &zwnj;**更新 `fanzhuan[i]`（第 $i$ 个翻转）**&zwnj;  
   - 如果前一个单词&zwnj;**不翻转**&zwnj;：  
     检查当前单词的末尾字符（翻转后的首字符）与前一单词的末尾字符是否相同（`a[i][1] == a[i-1][1]`）。 
     - 相同 → 长度叠加 `+1`。  
     - 不同 → 长度叠加 `+2`。  
     ```
     fanzhuan[i] = min(fanzhuan[i], bufanzhuan[i-1] + (条件满足 ? 1 : 2))
     ```
   - 如果前一个单词&zwnj;**翻转**&zwnj;：  
     检查当前单词的末尾字符（翻转后的首字符）与前一翻转单词的首字符是否相同（`a[i][1] == a[i-1][0]`）。  
     - 相同 → 长度叠加 `+1`。  
     - 不同 → 长度叠加 `+2` 。 
     ```
     fanzhuan[i] = min(fanzhuan[i], fanzhuan[i-1] + (条件满足 ? 1 : 2))

# 代码

``` c++

#include <iostream>
#include <algorithm>
#include <climits>
namespace noip {
typedef long long ll;
constexpr ll MAX_N_c = 100000;
ll n;
char a[1+MAX_N_c][2];
ll fanzhuan[1+MAX_N_c], bufanzhuan[1+MAX_N_c];
void main() {
	std::cin >> n;
	for (ll i = 1; i <= n; i++)
		std::cin >> a[i];
		
	fanzhuan[1] = bufanzhuan[1] = 2;
	for (ll i = 2; i <= n; i++) {
		bufanzhuan[i] = fanzhuan[i] = LLONG_MAX;
		if (a[i][0] == a[i-1][1])
			bufanzhuan[i] = std::min(bufanzhuan[i], bufanzhuan[i-1]+1);
		else
			bufanzhuan[i] = std::min(bufanzhuan[i], bufanzhuan[i-1]+2);
		if (a[i][0] == a[i-1][0])
			bufanzhuan[i] = std::min(bufanzhuan[i], fanzhuan[i-1]+1);
		else
			bufanzhuan[i] = std::min(bufanzhuan[i], fanzhuan[i-1]+2);
		if (a[i][1] == a[i-1][1])
			fanzhuan[i] = std::min(fanzhuan[i], bufanzhuan[i-1]+1);
		else
			fanzhuan[i] = std::min(fanzhuan[i], bufanzhuan[i-1]+2);
		if (a[i][1] == a[i-1][0])
			fanzhuan[i] = std::min(fanzhuan[i], fanzhuan[i-1]+1);
		else
			fanzhuan[i] = std::min(fanzhuan[i], fanzhuan[i-1]+2);
	}
	
	std::cout << std::min(fanzhuan[n], bufanzhuan[n]);
}
}

int main() {
	noip::main();
	return 0;
}

---

## 作者：wangwang0307 (赞：1)

# 思路

这道题明显是动态规划，但是我们该怎么做呢？

## 状态

首先，为了知道前一个工件是否翻转，所以我们可以先定义两个数组，分别是 $fanzhuan$ 和 $bufanzhuan$（下文将简写成 $f$ 和 $bf$）。$f_{i}$、$bf_{i}$ 分别指第 $i$ 个工件翻转（不翻转）后，前 $i$ 个工件能连成的最小长度。

## 决策

第 $i - 1$ 个工件是否翻转。

以 $f_i$ 为例，如果前一个翻转了，那么也就是前一个的工件的首部与当前工件的尾部拼接，只需判断两个部分是否相等即可判断增加的长度；如果前一个没有翻转，那么前一个的工件的尾部与当前工件的尾部拼接，也是要判断两部分是否相等决定增加的长度。$bf_i$ 同理。

## 结果

最终输出 $f_i$ 和 $bf_i$ 的最小值即可。

# AC CODE
```cpp
#include<iostream>
#include<queue>
#include<utility>
#include<algorithm>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<string>
#include<climits>
#include<vector>
#include<numeric>
#include<stdio.h>
#include<stack>
#include<bitset>
namespace noip{
	using Int = long long;
	
	constexpr Int Max_N = 100000;
	
	std::string a[1 + Max_N];
	Int n;
	Int fanzhuan[1 + Max_N] {}, bufanzhuan[1 + Max_N] {};
	
	void init() {}
	void main() {
		std::cin >> n;
		for (Int i = 1; i <= n; i++) std::cin >> a[i];
		
		fanzhuan[1] = bufanzhuan[1] = 2;
		for (Int i = 2; i <= n; i++) {
			fanzhuan[i] = std::min(bufanzhuan[i - 1] + (a[i - 1][1] == a[i][1] ? 1 : 2), fanzhuan[i - 1] + (a[i - 1][0] == a[i][1] ? 1 : 2));
			bufanzhuan[i] = std::min(bufanzhuan[i - 1] + (a[i - 1][1] == a[i][0] ? 1 : 2), fanzhuan[i - 1] + (a[i - 1][0] == a[i][0] ? 1 : 2));
		}
		
		std::cout << std::min(fanzhuan[n], bufanzhuan[n]) << std::endl;
	}
}
int main() {
	noip::init();
	noip::main();
	return 0;
}
```

---

## 作者：mairuisheng (赞：1)

[P12211 [蓝桥杯 2023 国 Python B] 翻转](https://www.luogu.com.cn/problem/P12211)

算法：动态规划

分析：

由于题目说“工件必须按出现顺序依次拼接”满足动态规划无后效性的性质，所以考虑动态规划。

设 $s_i$ 为第 $i$ 个字符串。$s_{i,0}$ 为字符串第一位；$s_{i,1}$ 为字符串第二位。

设 $dp_{i,0}$ 为第 $i$ 个字符串不反转，与前面的字符串所组成的最小长度；

又设 $dp_{i,1}$ 为第 $i$ 个字符串反转，与前面的字符串所组成的最小长度。

所以，状态转移方程为：

$$dp_{i,0}=\min(dp_{i-1,0}+2-[s_{i,0}=s_{i-1,1}],dp_{i-1,1}+2-[s_{i,0}=s_{i-1,0}])$$

$$dp_{i,1}=\min(dp_{i-1,0}+2-[s_{i,1}=s_{i-1,1}],dp_{i-1,1}+2-[s_{i,1}=s_{i-1,0}])$$

答案：$\min(dp_{n,0},dp_{n,1})$。

初始化：$dp_{1,0}$ 与 $dp_{1,1}$ 均为 $2$（第一个字符串无论怎么操作长度都为二）。

代码：
```cpp
//#pragma GCC optimize(3)
#include<iostream>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char s;
	s=getchar();
	while(s<48||s>57)
	{
		if(s=='-')f=-f;
		s=getchar();
	}
	while(s>47&&s<58)
	{
		x=(x<<3)+(x<<1)+(s-48);
		s=getchar();
	}
	return x*f;
}
constexpr int N=1e5+1;
int n;
string s[N];
int dp[N][2];
int min(int x,int y)
{
	return x<y?x:y;
}
int main()
{
	n=read();
	int i;
	for(i=1;i<=n;++i)cin>>s[i];
	dp[1][0]=dp[1][1]=2;
	for(i=2;i<=n;++i)
	{
		dp[i][0]=min(dp[i-1][0]+(s[i-1][1]==s[i][0]?1:2),dp[i-1][1]+(s[i-1][0]==s[i][0]?1:2));
		dp[i][1]=min(dp[i-1][0]+(s[i-1][1]==s[i][1]?1:2),dp[i-1][1]+(s[i-1][0]==s[i][1]?1:2));
	}
	printf("%d",min(dp[n][0],dp[n][1]));
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

### 题目大意：
把 $n$ 个字符串，每个字符串的大小为 $2$。相邻重复的字母会消除，只剩一个，求最小的字符串。

### 解题思路：
一看题目容易想到动态规划，但如何做呢？我们可以设一个 $f$ 数组何一个 $dp$ 数组，设 $f$ 为第 $i$ 个字符不反转最小解，$dp$ 为第 $i$ 个字符翻转最小解。如果第 $i$ 个第一个字符和第 $i+1$ 个第一个字符相等，就是可以消除，否则就增加 $2$，如果第 $i$ 个最后一个字符和第 $i+1$ 个最后一个字符相等，就是可以消除，否则 $2$。

### 代码：
```.python
n=int(input())
a=[0]*(n+2) 
b=[0]*(n+2)
for i in range(1,n+1):
    line=input().strip()
    a[i],b[i]=line[0],line[1] 
INF=float('inf')
f=[INF]*(n+2)
dp=[INF]*(n+2)
f[1]=2
dp[1]=2
for i in range(2,n+1):
    if a[i]==b[i-1]:f[i]=min(f[i],f[i-1]+1)
    else:f[i]=min(f[i],f[i-1]+2)
    if a[i]==a[i-1]:f[i]=min(f[i],dp[i-1]+1)
    else:f[i]=min(f[i],dp[i-1]+2)
    if b[i]==b[i-1]:dp[i]=min(dp[i],f[i-1]+1)
    else:dp[i]=min(dp[i],f[i-1]+2)
    if b[i]==a[i-1]:dp[i]=min(dp[i],dp[i-1]+1)
    else:dp[i]=min(dp[i],dp[i-1]+2)
print(min(dp[n],f[n]))

```

---

## 作者：worldcat (赞：0)

显然的动态规划。

首先，看到求最短长度就可以想到动归，接下来的任务就是推导状态转移方程。

我们设 $dp_{i, j}$ 意为加入第 $i$ 个工件后的最短长度，$j = 1$ 表示翻转工件加入，$j = 0$ 表示不翻转工件加入。那么，为了方便与运算，就可以先处理翻转后的工件，其次再考虑拼接后的长度。

此外，**奇特的拼接方式**就是如果上一个工件的最后一个字母是当前工件的第一个字母，就在加入时，直接合并，不懂的话再自己举例，我们设 $fan(x)$ 表示字符串 $x$ 翻转后的字符串，$ch(a, b)$ 为 $b$ 加入 $a$ 后会增加的长度（考虑合并！！）。

接下来就是状态转移方程了，对于第 $i$ 个工件，无论当前工件是否发生翻转，它都有两种可能的路径，一是从上一个不翻转的工件走过来，相关的量为 $dp_{i - 1,0}$，二是从上一个翻转的工件走过来，相关量为 $dp_{i - 1,1}$。

说这么多，具体还得看代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define min(x, y) (x > y ? y : x)
#define worldcat return 
#define code 0;
string s[100005];//输入
ll n, dp[100005][2];
//dp[i][j]:到s数组中加入第i个工件后的最短长度，
//j = 1表示翻转工件加入，j = 0表示不翻转工件加入
string fan(string x) {
	string op = "";
	op += x[1];
	op += x[0];
	return op;
}
//fan(x) :返回x反转后的字符串
//由题意得每个工件长度为2，直接手搓反转就行
//-------------------------------------------------
ll ch(string a, string b) {
	ll la = a.size();
	if (a[la - 1] == b[0]) {
		return 1;
	}
	//如果a的尾巴和b的头部相同，那么它们直接合并
	//奇特的拼接方式
	return 2;
}
//ch(a, b):如果把b加入a，返回a会增加的长度
//-------------------------------------------------------
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> s[i];
	}
	dp[1][0] = dp[1][1] = 2;
	//初始化：加入第1个工件后长度肯定为2，无论是否翻转都无法发生合并
	for (int i = 2; i <= n; i++) {//从第2个工件开始
		string node = fan(s[i]), emper = fan(s[i - 1]);
		//node:当前工件翻转后的字符串
		//emper:前一个工件翻转后的字符串
		dp[i][0] = min(dp[i - 1][0] + ch(s[i - 1], s[i]),
			dp[i - 1][1] + ch(emper, s[i]));
		//比较长度大小：当前工件不发生翻转状况
		dp[i][1] = min(dp[i - 1][0] + ch(s[i - 1], node),
			dp[i - 1][1] + ch(emper, node));
		//比较长度大小：当前工件发生翻转状况
	}
	cout << min(dp[n][0], dp[n][1]);
	//输出加入最后一个字符串后的最短长度
	worldcat code//完成
}
```
求通过啊啊啊管理员大人。

---

## 作者：XuZile (赞：0)

# P12211 题解
## 题目解释
给定 $n$ 个长度为 $2$ 的字符串。要求按顺序将 $n$ 个字符串连起来后的最短长度，其中每个字符串都可以进行反转。如果字符串的第一个与前一个字符串的第二个相等，可以省略一个长度。
## 题目解法
这道题很明显需要用 DP 的方法去做。首先定义 $f_{i,j}$，表示第 $i$ 个字符串翻不翻转时前 $i$ 个字符串拼成的最短长度。$j=0$ 时表示第 $i$ 个字符串不翻转，$j=1$ 时表示第 $i$ 个字符串翻转。既然如此我们就可以去推 DP 方程。在一开始要先初始化 $f$ 数组为最大值，然后将 $f_{1,0}$ 与 $f_{1,1}$ 设为 $2$。推的时候我们需要分类讨论。

- 如果 $a_{i,0}=a_{i-1,1}$，那么 $f_{i,0}=\min(f_{i,0},f_{i-1,0}+1)$。否则 $f_{i,0}=\min(f_{i,0},f_{i-1,0}+2)$。
- 如果 $a_{i,0}=a_{i-1,0}$，那么 $f_{i,0}=\min(f_{i,0},f_{i-1,1}+1)$。否则 $f_{i,0}=\min(f_{i,0},f_{i-1,1}+2)$。
- 如果 $a_{i,1}=a_{i-1,1}$，那么 $f_{i,1}=\min(f_{i,1},f_{i-1,0}+1)$。否则 $f_{i,1}=\min(f_{i,1},f_{i-1,0}+2)$。
- 如果 $a_{i,1}=a_{i-1,0}$，那么 $f_{i,1}=\min(f_{i,1},f_{i-1,1}+1)$。否则 $f_{i,1}=\min(f_{i,1},f_{i-1,1}+2)$。

在最后输出 $\min(f_{n,0},f_{n,1})$。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char a[100010][5];
int f[100010][5];
int main(){
	cin>>n;
	memset(f,0x3f,sizeof(f));
	f[1][0]=f[1][1]=2;
	cin >> a[1];
	for(int i=2;i<=n;i++){
		cin >> a[i];
		if(a[i][0]==a[i-1][1]) f[i][0]=min(f[i][0],f[i-1][0]+1);
		if(a[i][0]==a[i-1][0]) f[i][0]=min(f[i][0],f[i-1][1]+1);
		if(a[i][1]==a[i-1][1]) f[i][1]=min(f[i][1],f[i-1][0]+1);
		if(a[i][1]==a[i-1][0]) f[i][1]=min(f[i][1],f[i-1][1]+1);
		f[i][0]=min(f[i][0],f[i-1][0]+2);
		f[i][0]=min(f[i][0],f[i-1][1]+2);
		f[i][1]=min(f[i][1],f[i-1][0]+2);
		f[i][1]=min(f[i][1],f[i-1][1]+2); 
	}
	cout << min(f[n][0],f[n][1]);
	return 0;
}
```

---

## 作者：emot1ons (赞：0)

## 思路
简单的 dp。

定义 $f(i,0)$ 表示对于第 $i$ 个字符串按正常顺序的最短长度， $f(i,1)$ 表示对于第 $i$ 个字符串按翻转后顺序的最短长度。

那么分别判断在正常和翻转情况下与前一个字符串正常和翻转情况下前后能否相连即可。

时间复杂度为  $O(n)$。

---


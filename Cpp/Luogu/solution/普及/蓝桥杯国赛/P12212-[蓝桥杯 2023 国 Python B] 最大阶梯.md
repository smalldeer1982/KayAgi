# [蓝桥杯 2023 国 Python B] 最大阶梯

## 题目描述

小蓝特别喜爱阶梯图案，阶梯图案可以看做是由若干个大小和颜色都相同的方格组成的，对于大小为 $N$ 的阶梯图案，包含了 $N$ 个连续的列，其中第 $i$ 列恰好有 $i$（ $1 \leq i \leq N$）个方格，将这 $N$ 列的底部对齐后便组成了一个阶梯图案，将其按照 90 度旋转若干次后仍是阶梯图案，下图展示了几个不同大小的阶梯图案：

![](https://cdn.luogu.com.cn/upload/image_hosting/rdpqw4jc.png)

小蓝有一块大小为 $H \times H$ 的布匹，由 $H \times H$ 个大小相同的方格区域组成，每一个方格都有自己的颜色。小蓝可以沿着方格的边缘对布匹进行裁剪，他想要知道自己能得到的最大的同色阶梯图案的大小是多少？

## 说明/提示

### 样例说明

如下图所示，最大的同色阶梯图案用红色边框标出。

![](https://cdn.luogu.com.cn/upload/image_hosting/sdouq50c.png)

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq H \leq 10$；
- 对于 $60\%$ 的评测用例，$1 \leq H \leq 100$；
- 对于所有评测用例， $1 \leq H \leq 1000$，$0 \leq$ 方格颜色 $\leq 10$。

## 样例 #1

### 输入

```
5
0 2 1 1 0
0 0 2 2 0
0 0 1 1 1
0 0 1 1 1
2 1 1 0 2```

### 输出

```
3```

# 题解

## 作者：chenyunting (赞：5)

# 思路

![](https://cdn.luogu.com.cn/upload/image_hosting/0gcrd9r0.png)
当三角形都是为图中这个样子的时候，如果顶点为`[i-1][j]`和顶点为`[i][j-1]`三角形的颜色相同，则顶点为`[i][j]`的三角形的腰为上面两个三角形中腰较短的加 1。

发现了这个规律，将每个朝向的三角形都算一遍最后取`max`就可以得到答案。

# 代码

```c++
#include <iostream>
#include <algorithm>
namespace noip {
typedef long long ll;
constexpr ll MAX_H_c = 1000;
ll h;
ll a[1+MAX_H_c][1+MAX_H_c];
ll zuoshang[1+MAX_H_c][1+MAX_H_c];
ll zuoxia[1+MAX_H_c][1+MAX_H_c];
ll youshang[1+MAX_H_c][1+MAX_H_c];
ll youxia[1+MAX_H_c][1+MAX_H_c];
void main() {
	std::cin >> h;
	for (ll i = 1; i <= h; i++)
		for (ll j = 1; j <= h; j++)
			std::cin >> a[i][j];
	
	for (ll i = 1; i <= h; i++)
		for (ll j = 1; j <= h; j++)
			zuoshang[i][j] = zuoxia[i][j] = youshang[i][j] = youxia[i][j] = 1;
	
	for (ll i = 2; i <= h; i++) 
		for (ll j = 2; j <= h; j++) 
			if (a[i][j] == a[i-1][j] && a[i][j] == a[i][j-1])
				zuoshang[i][j] = std::min(zuoshang[i-1][j], zuoshang[i][j-1])+1;
	
	for (ll i = 2; i <= h; i++)
		for (ll j = h-1; j >= 1; j--)
			if (a[i][j] == a[i-1][j] && a[i][j] == a[i][j+1])
				youshang[i][j] = std::min(youshang[i-1][j], youshang[i][j+1])+1;
			
	for (ll i = h-1; i >= 1; i--)
		for (ll j = 2; j <= h; j++)
			if (a[i][j] == a[i+1][j] && a[i][j] == a[i][j-1])
				zuoxia[i][j] = std::min(zuoxia[i+1][j], zuoxia[i][j-1])+1;
	
	for (ll i = h-1; i >= 1; i--)
		for (ll j = h-1; j >= 1; j--)
			if (a[i][j] == a[i+1][j] && a[i][j] == a[i][j+1])
				youxia[i][j] = std::min(youxia[i+1][j], youxia[i][j+1])+1;
	
	ll ans = 0;
	for (ll i = 1; i <= h; i++)	
		for (ll j = 1; j <= h; j++)	
			ans = std::max({ans, zuoshang[i][j], zuoxia[i][j], youshang[i][j], youxia[i][j]});
			
	std::cout << ans;
			
}
}

int main() {
	noip::main();
	return 0;
}

---

## 作者：wangwang0307 (赞：1)

# 思路

这道题用动态规划做，容易理解。

## 状态

我们先定义一个数组 $zs$。$zs_{i,j}$ 的意思是以 $i$，$j$ 为直角且斜边朝左上方的同色阶梯图形的最大边长（即最大的图形大小）。

同理，我们还可以定义 $zx$（斜边朝左下）、$ys$（斜边朝右上）、$yx$（斜边朝右下）这几种数组。

## 决策

我们还是以 $zs$ 为例。那么状态转移方程为：

$zs_{i,j} = \min(zs_{i-1,j}, zs_{i,j-1}) + 1$

但此状态转移的前提是 $zs_{i-1,j} = zs_{i,j-1}$ 且 $zs_{i,j} = zs_{i-1,j}$（即要同色）。

具体理解过程会在下文展示。

## 小细节

我们每个数组的每个元素初始值设为 $1$。因为一个方格也算阶梯图形。

边界情况和循环的顺序也需注意（具体看程序注释）。

## 结果

最后我们用一个 $ans$ 变量在更新数组时取最大值即可。

## 理解

以数组 $zs$ 为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/7w3dk2we.png)

该图中的黑色方块表示 $zs_{i,j}$ 那么它的最大边数就是 $zs_{i,j - 1}$ 与 $zs_{i - 1,j}$ 取最小值加 $1$ 即可（前提是要同色）。

# AC CODE

```cpp
#include<iostream>
#include<queue>
#include<utility>
#include<algorithm>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<string>
#include<climits>
#include<vector>
#include<numeric>
#include<stdio.h>
#include<stack>
#include<bitset>
namespace noip{
	using Int = long long;
	
	constexpr Int Max_H = 1000;
	
	Int h, g[1 + Max_H][1 + Max_H];
	Int zs[1 + Max_H][1 + Max_H] {}, zx[1 + Max_H][1 + Max_H] {}, ys[1 + Max_H][1 + Max_H] {}, yx[1 + Max_H][1 + Max_H] {};
	Int ans = 1;
	
	void init() {}
	void main() {
		std::cin >> h;
		for (Int i = 1; i <= h; i++) {
			for (Int j = 1; j <= h; j++) {
				std::cin >> g[i][j];
				zs[i][j] = zx[i][j] = ys[i][j] = yx[i][j] = 1;
			}
		}
		//左上部分思路已讲
		for (Int i = 1; i <= h; i++) {
			for (Int j = 1; j <= h; j++) {
				if (i != 1 && j != 1 && g[i - 1][j] == g[i][j - 1] && g[i][j] == g[i - 1][j]) zs[i][j] = std::min(zs[i - 1][j], zs[i][j - 1]) + 1;
				ans = std::max(ans, zs[i][j]);
			}
		}
        //左下部分因为是取 g[i + 1][j] 作取最小值的一部分，所以 i 要从大往小 for。其余同理
		for (Int i = h; i >= 1; i--) {
			for (Int j = 1; j <= h; j++) {
				if (i != h && j != 1 && g[i + 1][j] == g[i][j - 1] && g[i][j] == g[i + 1][j]) zx[i][j] = std::min(zx[i + 1][j], zx[i][j - 1]) + 1; //切记一定要先判断边界再判断是否相等。边界如何判断的原因与判断循环顺序的理由一样，其余同理。
				ans = std::max(ans, zx[i][j]);
			}
		}
      //更新 ys
		for (Int i = 1; i <= h; i++) {
			for (Int j = h; j >= 1; j--) {
				if (i != 1 && j != h && g[i - 1][j] == g[i][j + 1] && g[i][j] == g[i - 1][j]) ys[i][j] = std::min(ys[i - 1][j], ys[i][j + 1]) + 1;
				ans = std::max(ans, ys[i][j]);
			}
		}
      //更新 yx
		for (Int i = h; i >= 1; i--) {
			for (Int j = h; j >= 1; j--) {
				if (i != h && j != h && g[i + 1][j] == g[i][j + 1] && g[i][j] == g[i + 1][j]) yx[i][j] = std::min(yx[i + 1][j], yx[i][j + 1]) + 1;
				ans = std::max(ans, yx[i][j]);
			}
		}
		
		std::cout << ans << std::endl;
	}
}
int main() {
	noip::init();
	noip::main();
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P12212 题解

无需其它题解的分类讨论。

## 思路

我们只处理靠左上角的答案，于是可以倒着刷一遍，如果 $a_{i,j}=a_{i,j+1}$，则 $f_{i,j}=f_{i,j+1}+1$，否则 $f_{i,j}=1$，即用 $f_{i,j}$ 表示从 $i,j$ 这个位置开始向右最长的相同数字长度。

对于一个合法的靠左上角的阶梯图案，从某个位置开始向上数 $k$ 个位置，则这 $k$ 个位置都要相等，且其对应 $f$ 值从下往上呈 $1,2,3,\cdots,k$ 分布，所以，如果 $a_{i,j}=a_{i+1,j}$，则 $g_{i,j}=\min(f_{i,j},g_{i+1,j}+1)$，否则 $g_{i,j}=1$，即用 $g_{i,j}$ 表示以 $i,j$ 为左上角能搞出多大的阶梯。

那么其它三种情况？把 $a$ 数组转一下不久行了嘛。

## 代码

```cpp
const int N=1005;

int n,ans;
int arr[N][N],b[N][N];
int f[N][N],g[N][N];

int main() {
    read(n);
    memset(arr,-1,sizeof(arr));
    _rep(i,1,n) _rep(j,1,n) read(arr[i][j]);
    _rep(k,1,4) {
        _rrep(i,n,1) _rrep(j,n,1) if (arr[i][j]==arr[i][j+1]) f[i][j]=f[i][j+1]+1; else f[i][j]=1;
        _rrep(i,n,1) _rrep(j,n,1) if (arr[i][j]==arr[i+1][j]) g[i][j]=min(f[i][j],g[i+1][j]+1); else g[i][j]=1;
        _rep(i,1,n) _rep(j,1,n) ans=max(ans,g[i][j]);
        _rep(i,1,n) _rep(j,1,n) b[i][j]=arr[n-j+1][i];
        _rep(i,1,n) _rep(j,1,n) arr[i][j]=b[i][j];
    }
    write(ans);
    return 0;
}
```

---


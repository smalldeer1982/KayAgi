# [蓝桥杯 2024 国 Python B] 马与象

## 题目描述

小蓝有一个大小为 $N \times N$ 的棋盘（棋子可以走的位置有 $(N+1) \times (N+1)$ 个），棋盘上只有两个棋子：一个马和一个象，他们的行动规则是：马走日，马可以走到一个日字形状的对角；象飞田，象可以走到一个田字形状的对角，即斜着走两格（注意无需遵守象棋中的蹩马腿、塞象眼的规则）。在下图所示的大小为 $4 \times 4$ 的棋盘上，展示了两种棋子具体的行进方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/73wb4l9u.png)

在任意一方先手、每一方都可以连续走任意步的情况下，请问有没有可能出现一方吃掉另一方的局面，如果有，请输出最少需要经过几步可以达到这个局面，否则输出 $-1$。注意：棋子不能走出棋盘。

## 说明/提示

### 样例说明 1

![](https://cdn.luogu.com.cn/upload/image_hosting/h3wu7zlr.png)

### 样例说明 2

各走一步可能出现一方吃掉另一方的局面。

### 评测用例规模与约定

- 对于 $50\%$ 的评测用例，$1 \leq N \leq 10$；
- 对于所有评测用例，$1 \leq N \leq 50$，$0 \leq x_1, y_1, x_2, y_2 \leq N$。

## 样例 #1

### 输入

```
4 0 2 1 2```

### 输出

```
3```

## 样例 #2

### 输入

```
4 2 2 2 3```

### 输出

```
2```

# 题解

## 作者：ZBXAPCY (赞：11)

在做本题之前可以先做一下马的遍历，两题的有些地方比较相似，只需稍加改动。

首先我们把马和象的到所有的位置的所需最短步数都在遍历的过程中记录下来，再看看有没有它们都能到的点，如果有就说明在这个点它们中的一方有可能被吃掉，走到这个点所需的步数当然就是它们的步数之和了。

假设我们已经把马和象的可能到路径都搜索了一遍。取它们到可能互吃的点的步数的最小值。这个最小值就是我们要的答案啦！

以下是代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
int a[55][55],b[55][55],ans=99999999,n,mx,my,xx,xy;//a数组用于记录马到每个点的步数，b数组记录象，其实它们也起到了布尔作用，具体见代码。 
//n用于记录棋盘大小，注意棋盘的范围是0到n。mx,my,xx,xy用于记录马和象的初始位置。
//因为ans是要取最小值，所以先赋成很大的数。
void mbfs(){
	int t=1,h=0,x[]={1,1,-1,-1,2,2,-2,-2},o[3500][2]={mx,my},y[]={2,-2,2,-2,1,-1,1,-1};//o是队列，t是队列的头，h是尾。 
	while(h<t){//手打队列的标配 
		for(int i=0;i<8;i++){//遍历8个方向 
			int nx=o[h][0]+x[i],ny=o[h][1]+y[i];
			if(nx<0||ny<0||nx>n||ny>n||a[nx][ny]!=-1)
				continue;//如果超出棋盘范围或是已经走过了就跳过 
			o[t][0]=nx;o[t][1]=ny;//记录坐标 
			a[nx][ny]=a[o[h][0]][o[h][1]]+1;//步数=上一步的步数加一 
			t++;//尾端加一 
		}
		h++;//头加一 
	}
}
void xbfs(){
	int t=1,h=0,x[]={2,2,-2,-2},y[]={-2,2,-2,2},o[3500][2]={xx,xy};//与马的遍历差不多，这里就不说了 。 
	while(h<t){
		for(int i=0;i<4;i++){
			int nx=o[h][0]+x[i],ny=o[h][1]+y[i];
			if(nx<0||ny<0||nx>n||ny>n||b[nx][ny]!=-1)
				continue;
			o[t][0]=nx;o[t][1]=ny;
			b[nx][ny]=b[o[h][0]][o[h][1]]+1;
			t++;
		}
		h++;
	}
}
int main(){
	cin>>n>>my>>mx>>xy>>xx;
	if(mx==xx&&my==xy){cout<<0;return 0;} //特判，如果它们在同一位置则直接输出0 
	memset(a,-1,sizeof(a));
	memset(b,-1,sizeof(b));//先把数组全部赋值为-1,方便以后判断 
	a[mx][my]=b[xx][xy]=0;//到起点的位置都是0 
	mbfs();xbfs();//对马和象进行搜素 
	for(int i=0;i<=n;i++)for(int j=0;j<=n;j++)//遍历每个点，具体做法之前已经说了 
		if(a[i][j]!=-1&&b[i][j]!=-1)//如果有一个点是-1就说明有一方没有到，就不能算是吃
			ans=min(ans,a[i][j]+b[i][j]);
	if(ans>99999998)cout<<-1;//注意如果它们不可能吃子则输出-1 
	else cout<<ans;
	return 0;
}
```


这是一篇异常粗糙的题解，根本原因还是我太菜了，呜呜呜。

看在这样的份上，能赏个赞吗？

---

## 作者：dendky (赞：8)

## 思路

相信大家都做过 [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)，其实这题思路与马的遍历相似，我们只需要对马先进行一次广搜，再对象进行一次广搜，最后循环遍历找出马与象都会走到的点，记录输出即可。注意，无解要输出 $-1$。多次广搜记得清空。

与马的遍历略有不同的是，在进行广搜的时候我们需要建立偏移量数组，这次不仅有马，更有象，也要为象创立一个偏移量数组。

## code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, a[55][55], b[55][55], ans=114514111;
int fx1[9]={2, 1, -1, -2, -2, -1, 1, 2}, fy1[9]={1, 2, 2, 1, -1, -2, -2, -1};//马的偏移量
int fx2[5]={2, 2, -2, -2}, fy2[5]={2, -2, 2, -2};//象的偏移量
struct node {
    int x, y;
};
queue <node>q;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int x1, y1, x2, y2;
    cin>>n>>x1>>y1>>x2>>y2;
    memset(a, -1, sizeof(a));
    memset(b, -1, sizeof(b));//初始化，数组清空
    q.push({x1, y1});//马的bfs()
    a[x1][y1]=0;
    while (!q.empty()) {
        node fr=q.front();
        q.pop();
        for (int i=0; i<8; i++) {
            int dx=fr.x+fx1[i], dy=fr.y+fy1[i];
            if (dx>=0 && dy>=0 && dx<=n && dy<=n && a[dx][dy]==-1) {
                q.push({dx, dy});
                a[dx][dy]=a[fr.x][fr.y]+1;//标记步数
            }
        }
    }
    q.push({x2, y2});//进行象的bfs()
    b[x2][y2]=0;
    while (!q.empty()) {
        node fr=q.front();
        q.pop();
        for (int i=0; i<4; i++) {
            int dx=fr.x+fx2[i], dy=fr.y+fy2[i];
            if (dx>=0 && dy>=0 && dx<=n && dy<=n && b[dx][dy]==-1) {
                q.push({dx, dy});
                b[dx][dy]=b[fr.x][fr.y]+1;//标记步数
            }
        }
    }
    //注意if判断，如果为-1说明马或象有一方没有走到这个点，那么就不是所求答案
    for (int i=0; i<=n; i++) 
        for (int j=0; j<=n; j++) 
            if (a[i][j]!=-1 && b[i][j]!=-1) ans=min(ans, a[i][j]+b[i][j]);
    //全图遍历，注意下标要从0开始！
    if (ans==114514111) cout<<-1;//未找到答案
    else cout<<ans;
    return 0;
}
```

---

## 作者：Ashankamiko (赞：3)

# 题目简述
### 题意
给定一张 $N \times N$ 的地图，并给定马的坐标和象的坐标，求两者相遇最少需要移动几步，并给出了移动规则。
### 思路
本题特殊的地方在于两者可以同时移动而不是像广搜模板题那样只有一个坐标会变化，因此整个分支我们无法控制，需要用 $dis1$ 来记录马到达 $(x,y)$ 的最少步数，再用 $dis2$ 数组来记录象到达 $(x,y)$ 的最少步数，最后只需要求出 $dis1$ 和 $dis2$ 到达 $(x,y)$ 的最少步数并求和，比较出最小值即可。如果两者不可能相遇，输出 $-1$。

对于本题，值得注意的是 $(0,0)$ 也是合法位置。

#### 获取 $dis$
```cpp
#define in cin
#define out cout
struct node {
	int x, y, r;
};
int dis[55][55]; // 记录到达(x,y)的最少步数
queue<node> q;
void bfs() {
	while (!q.empty()) {
		int ux = q.front().x, uy = q.front().y, ur = q.front().r;
		q.pop();
		for (int i = 0; i < 8; i++) {
			int tx = ux + dxm[i][0], ty = uy + dxm[i][1];
			if (tx >= 0 && ty >= 0 && tx <= n && ty <= n && dis[tx][ty] == -1)
				q.push({tx, ty, ur + 1}), dis[tx][ty] = ur + 1; //入队，并使dis[tx][ty]的值为ur
		}
	}
}
```
这样我们就求出了一个 $dis1$，那么求 $dis2$ 只需要更改方向数组再进行一次 bfs，最后求和。

求和时只需要先判断 $dis1$ 和 $dis2$ 是不是极大值，如果都不是用 $minx$ 求出 $dis1 + dis2$ 的最小值。最后如果 $minx$ 任然为极大值，说明无解，输出 $-1$，否则输出 $minx$。
## [AC 代码](https://www.luogu.com.cn/record/217573157)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long //防止溢出
#define in cin
#define out cout
int dxm[8][2] = {{-2, 1}, {-2, -1}, {2, 1}, {2, -1}, {1, 2}, {1, -2}, {-1, -2}, {-1, 2}}, dxx[4][2] = {{-2, 2}, {2, 2}, {2, -2}, {-2, -2}}; //方向数组
int n, a, b, c, d, minx = INT_MAX;
struct node { //基础定义
	int x, y, r;
};
int dis1[55][55], dis2[55][55]; //记录最少步数
queue<node> q;
signed main() {
	memset(dis1, -1, sizeof(dis1));
	memset(dis2, -1, sizeof(dis2));
	in >> n >> a >> b >> c >> d;
	q.push({a, b, 0}), dis1[a][b] = 0;
	while (!q.empty()) { //获取dis1，即马能走到的点和最少步数
		int ux = q.front().x, uy = q.front().y, ur = q.front().r;
		q.pop();
		for (int i = 0; i < 8; i++) {
			int tx = ux + dxm[i][0], ty = uy + dxm[i][1];
			if (tx >= 0 && ty >= 0 && tx <= n && ty <= n && dis1[tx][ty] == -1)
				q.push({tx, ty, ur + 1}), dis1[tx][ty] = ur + 1;
		}
	}
	q.push({c, d, 0}), dis2[c][d] = 0;
	while (!q.empty()) { //获取dis2，象能走到的点和最少步数
		int ux = q.front().x, uy = q.front().y, ur = q.front().r;
		q.pop();
		for (int i = 0; i < 4; i++) {
			int tx = ux + dxx[i][0], ty = uy + dxx[i][1];
			if (tx >= 0 && ty >= 0 && tx <= n && ty <= n && dis2[tx][ty] == -1) {
				q.push({tx, ty, ur + 1}), dis2[tx][ty] = ur + 1;
			}
		}
	}
	for (int i = 0; i <= n; i++)
		for (int j = 0; j <= n; j++)
			if (dis1[i][j] != -1 && dis2[i][j] != -1)
				minx = min(minx, dis1[i][j] + dis2[i][j]); //求最优解
	if (minx == INT_MAX) //不存在解
		out << -1;
	else
		out << minx; //存在解
	return 0;
}
```

---

## 作者：Charged_Charge (赞：2)

# 洛谷 P12270
## 题目大意：
给定矩阵的边长 $n$ 和马的位置与象的位置，判断是否存在一方能吃掉宁外一方的局面，如果有，输出最小步数，如果没有，输出负一。
## 解题思路：
打两个广搜，搜索所有马与象能够到达的位置，并记录步数。最后，遍历所有马与象能够重合的位置，把每一个马与象到达这个地方的步数的和与当前的答案求较小值，最终输出答案。
## AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 55;
int n, ans = 0x3f3f3f3f;
int x, y, r, c;
int h[N][N];
int e[N][N];
int vh[N][N];
int ve[N][N];
int hx[8] = {-1, -2, 1, 2, -2, -1, 1, 2};
int hy[8] = {-2, -1, -2, -1, 1, 2, 2, 1};
int ex[4] = {-2, 2, -2, 2};
int ey[4] = {-2, -2, 2, 2};
struct node {
	int xx, yy;
	int s;
};

void bfs1(int l, int r) {
	queue<node> q;
	q.push({l, r, 0});
	vh[l][r] = 1;

	while (q.size()) {
		node p = q.front();
		q.pop();

		for (int i = 0; i < 8; i++) {
			int nx = p.xx + hx[i];
			int ny = p.yy + hy[i];

			if (nx < 0 || nx > n || ny < 0 || ny > n || vh[nx][ny]) {
				continue;
			}

			vh[nx][ny] = 1;
			h[nx][ny] = p.s + 1;
			q.push({nx, ny, h[nx][ny]});
		}
	}
}

void bfs2(int l, int r) {
	queue<node> q;
	q.push({l, r, 0});
	ve[l][r] = 1;

	while (q.size()) {
		node p = q.front();
		q.pop();

		for (int i = 0; i < 4; i++) {
			int nx = p.xx + ex[i];
			int ny = p.yy + ey[i];

			if (nx < 0 || nx > n || ny < 0 || ny > n || ve[nx][ny]) {
				continue;
			}

			ve[nx][ny] = 1;
			e[nx][ny] = p.s + 1;
			q.push({nx, ny, e[nx][ny]});
		}
	}
}

int main() {
	cin >> n;
	cin >> x >> y >> r >> c;
	memset(h, 0x3f, sizeof h);
	memset(e, 0x3f, sizeof e);
	h[x][y] = 0;
	e[r][c] = 0;
	bfs1(x, y);
	bfs2(r, c);

	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= n; j++) {
			ans = min(h[i][j] + e[i][j], ans);
		}
	}

	if (ans == 0x3f3f3f3f) {
		cout << -1;
	} else {
		cout << ans;
	}

	return 0;
}
```

---

## 作者：chen_kun (赞：2)

# P12270 [蓝桥杯 2024 国 Python B] 马与象题解

## 思路简述

这是一道典型的 BFS 题目。我们需要分别计算马和象到达棋盘上每个格子的最少步数，然后找出它们能在同一格子相遇的最小总步数。

既然要问有没有可能一方吃掉另一方，我们就可以对两种棋子能走到的格子都用 BFS 遍历一遍，分别用数组 $a_{x,y} $，$b_{x,y}$ 记录马或象到达点 $(x,y)$ 的最少步数。再枚举整个棋盘，当到达点 $(i,j)$ 时 $a_{i,j}+b_{i,j}$ 即为两棋在该点相遇时所需的步数。于是我们可以开一个变量 $mmin$ 以记录最小步数，将其设为一个很大的值，再将 $a$ 数组与 $b$ 数组设为比 $mmin$ 还要大的值，即可在马或象在某点无法同时到达时防止 $mmin$ 更新成一个更小的值。最后判断 $mmin$ 是否为初值，若为初值则代表两棋不可能相遇，输出 -1。否则输出 $mmin$。

### 具体步骤

1. 使用 BFS 计算马到达所有格子的最少步数，存储在数组 `a` 中。
2. 使用 BFS 计算象到达所有格子的最少步数，存储在数组 `b` 中。
3. 遍历整个棋盘，对于每个格子 $(i,j)$ 计算 $a_{i,j}+b_{i,j}$。
4. 找出所有格子中的最小值，即为答案。
5. 如果没有任何格子可以同时到达，输出 -1。

## 代码实现

```cpp
import sys
from collections import deque

def main():
    # 读取输入
    n, ax, ay, xx, yy = map(int, sys.stdin.readline().split())
    
    # 初始化最小步数
    mmin = float('inf')
    
    # 马的移动方向(8种)
    xm = [2, -2, 2, -2, 1, -1, 1, -1]
    ym = [1, 1, -1, -1, 2, 2, -2, -2]
    
    # 象的移动方向(4种)
    dx = [2, -2, 2, -2]
    dy = [2, 2, -2, -2]
    
    # 初始化步数数组
    a = [[float('inf')] * (n + 1) for _ in range(n + 1)]
    b = [[float('inf')] * (n + 1) for _ in range(n + 1)]
    
    # 马的BFS
    def bfs_horse():
        vis = [[False] * (n + 1) for _ in range(n + 1)]
        q = deque()
        q.append((ax, ay, 0))
        vis[ax][ay] = True
        a[ax][ay] = 0
        
        while q:
            x, y, cnt = q.popleft()
            for i in range(8):
                tx, ty = x + xm[i], y + ym[i]
                if 0 <= tx <= n and 0 <= ty <= n and not vis[tx][ty]:
                    vis[tx][ty] = True
                    a[tx][ty] = cnt + 1
                    q.append((tx, ty, cnt + 1))
    
    # 象的BFS
    def bfs_elephant():
        vis = [[False] * (n + 1) for _ in range(n + 1)]
        q = deque()
        q.append((xx, yy, 0))
        vis[xx][yy] = True
        b[xx][yy] = 0
        
        while q:
            x, y, cnt = q.popleft()
            for i in range(4):
                tx, ty = x + dx[i], y + dy[i]
                if 0 <= tx <= n and 0 <= ty <= n and not vis[tx][ty]:
                    vis[tx][ty] = True
                    b[tx][ty] = cnt + 1
                    q.append((tx, ty, cnt + 1))
    
    # 执行BFS
    bfs_horse()
    bfs_elephant()
    
    # 寻找最小相遇步数
    for i in range(n + 1):
        for j in range(n + 1):
            if a[i][j] != float('inf') and b[i][j] != float('inf'):
                mmin = min(mmin, a[i][j] + b[i][j])
    
    # 输出结果
    print(-1 if mmin == float('inf') else mmin)

if __name__ == "__main__":
    main()

---

## 作者：March_Seventh (赞：2)

## 题目大意

在任意一方先手、每一方都可以连续走任意步的情况下，请问有没有可能出现一方吃掉另一方的局面，如果有，请输出最少需要经过几步可以达到这个局面，否则输出 −1。注意：棋子不能走出棋盘。

## 思路分析

因为任意一方先手、每一方都可以连续走任意步，所以行棋的顺序无需考虑，只需考虑各个点马最少需要几步到达，象需要几步到达，马的最小步数与象的最小步数之和就为马和象在这个点出现一方吃掉另一方的局面。而怎么求马和象到各个点需要最小步数呢？答案就是宽搜！

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 55;
const int kdh[8][2] = {{-2, 1}, {-2, -1}, {2, 1}, {2, -1}, {1, 2}, {1, -2}, {-1, -2}, {-1, 2}};//马的方向

const int kde[4][2] = {{-2, 2}, {2, 2}, {2, -2}, {-2, -2}};//象的方向
int n, hx, hy, ex, ey;//依题意定义
bool vis[N][N];
int hor[N][N], ele[N][N];//hor[i][j]为马到(i,j)的最小步数，ele[i][j]为象到(i,j)的最小步数
int minn = 0x3f3f3f3f;//定义最小值，初始化为极大值

void bfs1() {//搜马
	memset(vis, 0, sizeof(vis));//清空
	queue<pair<int, int>>q;//存储坐标
	q.push({hx, hy});
	hor[hx][hy] = 0;//到达起始位置的步数自然就是0
	while (!q.empty()) {
		int u = q.front().first, v = q.front().second;
		q.pop();
		if (u < 0 || u > n || v < 0 || v > n || vis[u][v])//如果越界或已搜过
			continue;//跳过
		vis[u][v] = 1;
		for (int i = 0; i < 8; i++) {
			int ux = u + kdh[i][0], uy = v + kdh[i][1];
			if (ux >= 0 && ux <= n && uy >= 0 && uy <= n && !vis[ux][uy]) {//如果下一步不越界且下一步没搜过
				q.push({ux, uy});//入队
				hor[ux][uy] = hor[u][v] + 1;//下一步的步数为这一步步数加一
			}
		}
	}
}

void bfs2() {//搜象，与马几乎相同
	memset(vis, 0, sizeof(vis));//清空
	queue<pair<int, int>>q;
	q.push({ex, ey});
	ele[ex][ey] = 0;
	while (!q.empty()) {
		int u = q.front().first, v = q.front().second;
		q.pop();
		if (u < 0 || u > n || v < 0 || v > n || vis[u][v])
			continue;
		vis[u][v] = 1;
		for (int i = 0; i < 4; i++) {
			int ux = u + kde[i][0], uy = v + kde[i][1];
			if (ux >= 0 && ux <= n && uy >= 0 && uy <= n && !vis[ux][uy]) {
				q.push({ux, uy});
				ele[ux][uy] = ele[u][v] + 1;
			}
		}
	}
}

int main() {
	memset(hor, 0x3f3f3f3f, sizeof(hor));//初始设为极大值
	memset(ele, 0x3f3f3f3f, sizeof(ele));
	cin >> n >> hy >> hx >> ey >> ex;
	bfs1();
	bfs2();
	for (int i = 0; i <= n; i++)
		for (int j = 0; j <= n; j++)
			minn = min(minn, hor[i][j] + ele[i][j]);//遍历每一个点，取最小值
	if (minn == 0x3f3f3f3f)//如果没有更新过，说明没有一个点马与象能同时到达
		cout << -1;//无解
	else
		cout << minn;//输出答案
	return 0;//结束
}
```

---

## 作者：zhangaixi (赞：1)

# **思路**
两次 BFS，分别求出马能到达的点，和其最小步数，以及象能到达的点和其最小步数，答案为象和马都能到达的点的最小步数之和，若没有象和马都能到达的点，则无解，输出 $-1$。
### 代码实现
- 将初始位置放入队中，每次取队首位置进行移动入队。
- 用 $d1_{i,j}$ 和 $d2_{i,j}$ 分别表示马和象到达 $(i,j)$ 的最少步数。
- 若找到一种移动方案，使得步数比当前数组中所存的步数要少：更新数组；若该点已入队，则不管；若该点未入队，则让该点入队，并标记已入队。
- 最后循环所有点，找出马和象都能到达的点中步数和最小的点，循环结束后输出最小值。
# AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,c,d,d1[51][51],d2[51][51],ans=INT_MAX,v[51][51]; 
int dx[8]={-1,-2,-2,-1,1,2,2,1};
int dy[8]={-2,-1,1,2,2,1,-1,-2};//马的坐标移动变化 
struct node{
	int x,y;
};
queue<node> q;
int main(){
	memset(d1,0x3f,sizeof(d1));
	memset(d2,0x3f,sizeof(d2));
	cin>>n>>a>>b>>c>>d;
	d1[a][b]=0;
	v[a][b]=1;//标记入队 
	q.push((node){a,b});
	while(!q.empty()){//找出马能走到的点并求出最小步数 
		node k=q.front();
		q.pop();
		v[k.x][k.y]=0;//标记出队 
		for(int i=0;i<8;i++){
			int nx=k.x+dx[i],ny=k.y+dy[i];
			if(nx>-1 && nx<=n && ny>-1 && ny<=n && d1[k.x][k.y]+1<d1[nx][ny]){
				//坐标合法且步数比当前答案更小 
				d1[nx][ny]=d1[k.x][k.y]+1;
				if(!v[nx][ny]){//没有入队则入队，并标记已入队 
					q.push((node){nx,ny});
					v[nx][ny]=1;
				}
			}
		}
	}
	dx[0]=-2,dx[1]=-2,dx[2]=2,dx[3]=2;
	dy[0]=-2,dy[1]=2,dy[2]=2,dy[3]=-2;//更新成象的坐标移动变化 
	memset(v,0,sizeof(v));
	d2[c][d]=0;
	v[c][d]=1;
	q.push((node){c,d});
	while(!q.empty()){//找出象能走到的点并求出最小步数 
		node k=q.front();
		q.pop();
		v[k.x][k.y]=0;
		for(int i=0;i<4;i++){
			int nx=k.x+dx[i],ny=k.y+dy[i];
			if(nx>-1 && nx<=n && ny>-1 && ny<=n && !v[nx][ny] && d2[k.x][k.y]+1<d2[nx][ny]){
				d2[nx][ny]=d2[k.x][k.y]+1;
				q.push((node){nx,ny});
				v[nx][ny]=1;
			}
		}
	}
	for(int i=0;i<=n;i++)
		for(int j=0;j<=n;j++)
			ans=min(ans,d1[i][j]+d2[i][j]); 
	if(ans<10000000) cout<<ans;
	else cout<<-1;
	return 0;
}
```

---

## 作者：Forge_Unique (赞：1)

## 思路

两次 BFS。

定义 $a_{i,j}$ 表示马从它的初始位置走到 $(i,j)$ 这个位置的最小步数，在第一次 BFS 里实现。

第二次 BFS 让象从它的初始位置搜索，搜做过程记一个 $sum$ 表示当前象走的步数。则当前的答案为 $a_{i,j}+sum$，每次计入最小值即可。

## 代码

[c++](https://www.luogu.com.cn/paste/a1rn1j62)。

[python](https://www.luogu.com.cn/paste/w1uoflcs)。

---

## 作者：zhangzehao (赞：1)

# P12270 [蓝桥杯 2024 国 Python B] 马与象
## 题意简述
在一个 $N \times N$ 的棋盘上放置了一个马和一个象。马遵循"日"字形移动规则，象遵循"田"字形移动规则。双方轮流行动，每次可以连续移动任意步数。需要判断是否存在一方能够吃掉另一方，若存在则计算最少需要的步数，否则返回 $-1$。
## 思路
首先，看到“**棋盘**”，“**棋子**”两个关键词，一般就是用搜索，又看到“**最少**”，就能想到用广搜。“**出现一方吃掉另一方的局面**”，即两颗棋要走到同一个位置，“**任意一方先手、每一方都可以连续走任意步**”，所以只要分别记录一下两颗棋分别走到棋盘各处的时间，找到两颗棋走到当前位置的时间和最小的格子并输出这个最小值就行了。
具体实现方法见代码：
## Python
```py
import sys
from collections import deque
def main():
    n, h_x, h_y, e_x, e_y = map(int, sys.stdin.readline().split())
    d = [
        [[2,1], [1,2], [-1,2], [-2,1], [-2,-1], [-1,-2], [1,-2], [2,-1]],  # 马的移动方向
        [[2,2], [2,-2], [-2,2], [-2,-2]]                                   # 象的移动方向
    ]
    global mmin = float('inf')
    v = [      # v[0] 记录马到各点的步数，v[1] 记录象到各点的步数，初始值-1表示该点未被访问
        [[-1] * (n + 1) for _ in range(n + 1)],  # 马的步数记录
        [[-1] * (n + 1) for _ in range(n + 1)]   # 象的步数记录
    ]
    q = [deque(), deque()] # q[0] 是马的BFS队列，q[1] 是象的BFS队列
    q[0].append((h_x, h_y)) # 加入队列
    q[1].append((e_x, e_y))
    v[0][h_x][h_y] = 0  # 起点步数为0
    v[1][e_x][e_y] = 0
    def bfs(k):  #k=0表示马，k=1表示象
        en = 8 if k == 0 else 4 # 确定移动方向数量：马有8个方向，象有4个方向
        while q[k]:  # 当队列不为空时继续搜索
            x, y = q[k].popleft()  # 取出队列首部的坐标
            if v[1 - k][x][y] != -1: # 如果双方都已访问该点，则计算总步数并更新最小值
                total_steps = v[k][x][y] + v[1 - k][x][y]
                mmin = min(mmin, total_steps)
            
            for i in range(en):  # 尝试所有可能的移动方向
                nx = x + d[k][i][0]
                ny = y + d[k][i][1]
                if 0 <= nx <= n and 0 <= ny <= n and v[k][nx][ny] == -1:   # 检查新坐标是否在棋盘范围内且未被访问
                    v[k][nx][ny] = v[k][x][y] + 1 # 记录步数并入队
                    q[k].append((nx, ny))
    bfs(0)
    bfs(1)
    print(mmin if mmin != float('inf') else -1)
if __name__ == "__main__":
    main()
```
## C++
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,h_x,h_y,e_x,e_y,j,mmin=INT_MAX;
    int d[2][10][2]={{{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}},  // 马的移动方向
                    {{2,2},{2,-2},{-2,2},{-2,-2}}};                                   // 象的移动方向
    cin>>n>>h_x>>h_y>>e_x>>e_y;
    using vvi=vector<vector<int>>;
    vector<vvi> v(2,vvi(n+1,vector<int>(n+1,-1)));  // v[0] 记录马到各点的步数，v[1] 记录象到各点的步数，初始值-1表示该点未被访问
    queue<pair<int,int>>q[2]; // q[0] 是马的BFS队列，q[1] 是象的BFS队列
    q[0].push({h_x,h_y}); // 加入队列
    q[1].push({e_x,e_y});
    v[0][h_x][h_y]=0;  // 起点步数为0
    v[1][e_x][e_y]=0;
    auto bfs=[&](int k){  //k=0表示马，k=1表示象
        int en=k==0?8:4; // 确定移动方向数量：马有8个方向，象有4个方向
        while(!q[k].empty()){  // 当队列不为空时继续搜索
            auto [x,y]=q[k].front();  // 取出队列首部的坐标
            q[k].pop();
            if(v[!k][x][y]!=-1){ // 如果双方都已访问该点，则计算总步数并更新最小值
                mmin=min(v[k][x][y]+v[!k][x][y],mmin);
            }
            for(int i=0;i<en;i++){  // 尝试所有可能的移动方向
                int nx=x+d[k][i][0],ny=y+d[k][i][1];
                if(nx>=0&&nx<=n&&ny>=0&&ny<=n&&v[k][nx][ny]==-1){   // 检查新坐标是否在棋盘范围内且未被访问
                    v[k][nx][ny]=v[k][x][y]+1; // 记录步数并入队
                    q[k].push({nx,ny});
                }
            }
        }
    };
    bfs(0);
    bfs(1);
    cout<<(mmin==INT_MAX?-1:mmin)<<endl;
    return 0;
}
```

---

## 作者：fly_x (赞：1)

# 题意

马和象轮流行动，在**任意一方先手**、每一方都可以**连续走任意步**的情况下，问**最少**需要经过几步可以让一方吃掉另一方，若无法达到则输出 $−1$。

# 思路

一方吃掉另一方即马和象在一个位置上，我们可以用 bfs 分别求出马和象到每个位置的步数，那么在这个位置上一方吃掉另一方的步数就是马和象到达这个位置的步数和，因此答案就是每个位置上马和象的步数和的最小值。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
// a,b,c,d 是马和象的初始位置，m1,m2 存储马和象到某个点的步数，ans 存储最终结果
int n, a, b, c, d, ans = 1061109567, m1[55][55], m2[55][55];
// 行动的方位数组
int da[] = {-2, -2, -1, -1, 1, 1, 2, 2};
int db[] = {1, -1, 2, -2, 2, -2, 1, -1};
int dc[] = {-2, -2, 2, 2};
int dd[] = {2, -2, 2, -2};
int main(){
	scanf("%d%d%d%d%d", &n, &a, &b, &c, &d);
	queue<int> qx, qy;
    memset(m1, 63, sizeof m1);
    memset(m2, 63, sizeof m2);
    // 处理马到每个点的距离
	qx.push(a), qy.push(b); m1[a][b] = 0;
	while (!qx.empty()){
		int x = qx.front(), y = qy.front(); 
		qx.pop(), qy.pop();
		for (int i = 0, xx, yy; i < 8; i++){
			xx = x+da[i], yy = y+db[i];
			if (m1[xx][yy] == 1061109567 && xx >= 0 && xx <= n && yy >= 0 && yy <= n)
				qx.push(xx), qy.push(yy), m1[xx][yy] = m1[x][y]+1;
                // 亲测，如果多开一个存步数的队列会 MLE，因此老老实实存 m1 里吧 ><
		}
	}
    // 处理象到每个点的距离
	qx.push(c), qy.push(d); m2[c][d] = 0;
	while (!qx.empty()){
		int x = qx.front(), y = qy.front();
		qx.pop(), qy.pop();
		for (int i = 0, xx, yy; i < 4; i++){
			xx = x+dc[i], yy = y+dd[i];
			if (m2[xx][yy] == 1061109567 && xx >= 0 && xx <= n && yy >= 0 && yy <= n)
				qx.push(xx), qy.push(yy), m2[xx][yy] = m2[x][y]+1;
		}
	}
    // 计算象和马到某个点相遇所需的步数，求最小值
	for (int i = 0; i <= n; i++)
		for (int j = 0; j <= n; j++)
			ans = min(ans, m1[i][j] + m2[i][j]);
	if (ans == 1061109567) ans = -1;
	cout << ans;
	return 0;
}
```

---

## 作者：W_C_B_H (赞：1)

因为任意一方先手、每一方都可以连续走任意步，所以最终一方吃掉另一方的位置（也就是最终的“汇合点”）一定是马到该点的距离与象到该点的距离之和（此处“距离”表示从起点到达该点需要的最小移动步数，下同）最小的点，故答案为所有点中，马到该点的距离与象到该点的距离之和的最小值。

我们可以开两个二维数组，分别记录马到该点的距离和象到该点的距离，并使用 bfs 求出其值。最后枚举每个点，计算答案并特判无解的情况即可。时间复杂度 $O(N^2)$，可以通过本题。

Code：

```python
N = 55
inf = 1e9
dis1 = [[inf] * N for _ in range(N)]
dis2 = [[inf] * N for _ in range(N)]
ans = inf

# 马的走法
dx1 = [2, 1,-1,-2,-2,-1, 1, 2]
dy1 = [1, 2, 2, 1,-1,-2,-2,-1]
# 象的走法
dx2 = [2,-2,-2, 2]
dy2 = [2, 2,-2,-2]

# 输入
n, x1, y1, x2, y2 = map(int, input().split())

def check(x, y):    # 判断坐标是否合法
    return 0 <= x <= n and 0 <= y <= n
def bfs(sx, sy, dis, dx, dy, len):  # 广度优先搜索
    # 参数: 起点坐标, 距离数组, 走法数组, 走法数量
    queue = [(sx, sy)]
    dis[sx][sy] = 0
    while queue:
        x, y = queue.pop(0)
        for i in range(len):
            nx, ny = x + dx[i], y + dy[i]
            if check(nx, ny) and dis[nx][ny] == inf:
                dis[nx][ny] = dis[x][y] + 1
                queue.append((nx, ny))

# 进行 bfs
bfs(x1, y1, dis1, dx1, dy1, 8)  # 马
bfs(x2, y2, dis2, dx2, dy2, 4)  # 象

# 计算最小步数
for i in range(0, n + 1):
    for j in range(0, n + 1):
        ans = min(ans, dis1[i][j] + dis2[i][j])

# 输出答案
print(ans if ans != inf else -1)
```

---

## 作者：__Kyw666__ (赞：1)

## 题意解释

给你一副 $n \times n$ 的棋盘，再给你马和象的坐标，问你最少几步两者能相遇，即马吃象或象吃马。\
众所周知：马飞日，象飞田。

## 思路分析

一道~~简单的~~宽搜。\
这里介绍一下我的思路：

### 一：预处理

这题表示的马和象的坐标很难受，至少我这么认为。
因为题中表示的坐标是按平面直角坐标系的方式表示的，而数组不是这样的，所以让我们转换一下。

- 坐标系中是先列后行，数组是先行后列。
- 注意！题中给的是 $n$ 个格子，而马和象有 $n+1$ 个点可走。
- 坐标系是从 $0$ 开始，我习惯用数组从下标 $1$ 开始。

参考代码如下：

```cpp
swap(xa,ya),swap(xb,yb);//交换横纵坐标
xa=n-xa+1,ya++;
xb=n-xb+1,yb++;
```

### 二：地图设置

先设置一张地图，把地图中的位置设置成象走到此处的步数，无法走到则置成 $-1$。\
以样例一为例，地图设置成这样：

```
-1 -1 -1 1  -1
-1 -1 -1 -1 -1
-1 0  -1 -1 -1
-1 -1 -1 -1 -1
-1 -1 -1 1  -1
```

为下面马的遍历做铺垫。\
参考代码如下：

```cpp
void bfs1()
{
	while(!q.empty())
	{
		node temp=q.front();
		q.pop();
		for(int i=0;i<4;i++)
		{
			int xx=temp.x+ex[i];
			int yy=temp.y+ey[i];
			if(xx<1||yy<1||xx>(n+1)||yy>(n+1)) continue;
			if(a[xx][yy]!=(-1)) continue;
			a[xx][yy]=temp.step+1;
			q.push(node{xx,yy,temp.step+1});
		}
	}
 } 
```

想测试一下可以加上输出代码：

```cpp
for(int i=1;i<=n+1;i++)
{
	for(int j=1;j<=n+1;j++) printf("%-2d ",a[i][j]);//左对齐
	cout<<endl;
}
```

### 三：马的遍历

相信大家都做过[马的遍历](https://www.luogu.com.cn/problem/P1443)。\
那么这里简单介绍一下。

- 将起点坐标放入队列。
- 取队头元素，判断是否对应象可到达的坐标。
- 对马向 $8$ 个方向搜索，符合要求的坐标放入队列，并标记。

**注意最后答案是马走的步数加上对应坐标上象到此处需走的步数。**

参考代码如下：

```cpp
void bfs2()
{
	while(!q.empty())
	{
		node temp=q.front();
		q.pop();
		if(a[temp.x][temp.y]!=(-1))
			ans=min(ans,(temp.step+a[temp.x][temp.y]));
		for(int i=0;i<8;i++)
		{
			int xx=temp.x+dx[i];
			int yy=temp.y+dy[i];
			if(xx<1||yy<1||xx>(n+1)||yy>(n+1)) continue;
			if(vis[xx][yy]) continue;
			vis[xx][yy]=1;
			q.push(node{xx,yy,temp.step+1});
		}
	}
}
```

### 四：总结

通过两次广度优先搜索，利用了记忆化搜索的思想，将从终点出发能到达的节点信息记录下来，然后从起点出发搜索到这些节点，从而找到最短路径。

那么接下来看看完整代码。

## 代码实现

### `c++` 代码：

```cpp
#include<bits/stdc++.h> 
using namespace std; 

struct node{ 
    int x,y,step; 
}; 

int n,xa,ya,xb,yb,ans=1e9,sum; 
int a[55][55]; 
bool vis[55][55]; 
int dx[10]={2,2,1,1,-1,-1,-2,-2}; 
int dy[10]={1,-1,2,-2,2,-2,1,-1}; 
int ex[4]={2,2,-2,-2}; 
int ey[4]={2,-2,2,-2};  
queue <node> q; 
 
// 从终点出发进行第一次广度优先搜索 
// 目的是标记从终点按照特定移动规则（ex 和 ey 定义的移动方式）能到达的节点，并记录到达这些节点所需的步数 
void bfs1() 
{ 
    // 当队列不为空时，继续搜索 
    while(!q.empty())  
    { 
        // 取出队列的队首元素 
        node temp=q.front();  
        q.pop();  
        // 遍历 4 种特殊的移动方式 
        for(int i=0;i<4;i++) 
        { 
            // 计算新的节点坐标 
            int xx=temp.x+ex[i]; 
            int yy=temp.y+ey[i]; 
            // 判断新节点是否越界 
            if(xx<1||yy<1||xx>(n+1)||yy>(n+1)) continue; 
            // 如果新节点已经被访问过（a[xx][yy] 不为 -1），则跳过 
            if(a[xx][yy]!=(-1)) continue; 
            // 更新新节点的步数为当前节点步数加 1 
            a[xx][yy]=temp.step+1;  
            // 将新节点加入队列 
            q.push(node{xx,yy,temp.step+1});  
        } 
    } 
} 
 
// 从起点出发进行第二次广度优先搜索 
// 目的是找到从起点到第一次搜索中标记的节点的最短路径 
void bfs2() 
{ 
    // 当队列不为空时，继续搜索 
    while(!q.empty())  
    { 
        // 取出队列的队首元素 
        node temp=q.front();  
        q.pop();  
        // 如果当前节点是第一次搜索中标记的节点 
        if(a[temp.x][temp.y]!=(-1)) 
            // 更新最短路径长度 
            ans=min(ans,(temp.step+a[temp.x][temp.y]));  
        // 遍历马的 8 种常规移动方式 
        for(int i=0;i<8;i++) 
        { 
            // 计算新的节点坐标 
            int xx=temp.x+dx[i]; 
            int yy=temp.y+dy[i]; 
            // 判断新节点是否越界 
            if(xx<1||yy<1||xx>(n+1)||yy>(n+1)) continue; 
            // 如果新节点已经被访问过，则跳过 
            if(vis[xx][yy]) continue; 
            // 标记新节点为已访问 
            vis[xx][yy]=1; 
            // 将新节点加入队列 
            q.push(node{xx,yy,temp.step+1});  
        } 
    } 
} 
 
int main() 
{ 
    cin>>n>>xa>>ya>>xb>>yb; 
    swap(xa,ya),swap(xb,yb); 
    xa=n-xa+1,ya++; 
    xb=n-xb+1,yb++; 
    memset(a,(-1),sizeof(a)); 
    a[xb][yb]=0;	
    q.push(node{xb,yb,0});  
    // 从终点出发进行第一次广度优先搜索 
    bfs1(); 
    while(!q.empty())  q.pop();  
    vis[xa][ya]=1; 
    q.push(node{xa,ya,0});  
    // 从起点出发进行第二次广度优先搜索 
    bfs2(); 
    // 如果最短路径长度仍然是初始值 1e9，表示无法到达终点 
    if(ans==1e9) cout<<"-1"; 
    else cout<<ans; 
    return 0; 
} 
```

### `python` 代码：

注：此代码为 AI 转换得来，仅供参考。

```python
from collections import deque 
 
def main():
    import sys 
    input = sys.stdin.read().split() 
    n = int(input[[0]()][[1]()][[5]()][[1]()][[1]()][[1]()][[1]()][[1]()] * (n+2) for _ in range(n+2)]
    vis =  * (n+2) for _ in range(n+2)]
    
    ex = [2, 2, -2, -2]
    ey = [2, -2, 2, -2]
    
    dx = [2, 2, 1, 1, -1, -1, -2, -2]
    dy = [1, -1, 2, -2, 2, -2, 1, -1]
 
    a[xb][yb] = 0 
    q = deque()
    q.append((xb,  yb, 0))
    
    while q:
        x, y, step = q.popleft() 
        for i in range(4):
            xx = x + ex[i]
            yy = y + ey[i]
            if 1 <= xx <= n+1 and 1 <= yy <= n+1 and a[xx][yy] == -1:
                a[xx][yy] = step + 1 
                q.append((xx,  yy, step + 1))
 
    ans = float('inf')
    vis[xa][ya] = True 
    q = deque()
    q.append((xa,  ya, 0))
    
    while q:
        x, y, step = q.popleft() 
        if a[x][y] != -1:
            ans = min(ans, step + a[x][y])
        
        for i in range(8):
            xx = x + dx[i]
            yy = y + dy[i]
            if 1 <= xx <= n+1 and 1 <= yy <= n+1 and not vis[xx][yy]:
                vis[xx][yy] = True 
                q.append((xx,  yy, step + 1))
 
    print(-1 if ans == float('inf') else ans)
 
if __name__ == "__main__":
    main()
```

结束！

---

## 作者：ylzpl (赞：1)

本题算法：BFS（广度优先搜索）。  
难度建议：橙。  
这题说实话，很简单，我十五分钟就写出来了，这是模版题。  
我们来说一下本题的思路：
- 首先，我们要知道的是广度优先搜索的原理：在原点进行扩散，对于每一个 $a_{i,j}$，扩散了之后也要从 $(i,j)$ 这个位置开始扩散。当 $(x,y)$ 被第一次扩散到时，那么它离原点的距离就是你扩散的次数。
- 然后，我们来想，既然题目要求最少步数，那么我们可以写两个函数，一个扩散马，一个扩散象。注意：我们的下标是 $0$ 到 $n$，只要 $(i,j)$ 合法才进行扩散，否则不行。
- 最后，我们需要计算步数。遍历这个棋盘的所有点。在此之前，我们可以定义两个数组 $mway$ 和 $xway$，是二维数组。用来记录步数。$(i,j)$ 的最少步数就是 $mway_{i,j}+xway_{i,j}$，最后取最小值即可。
- 注意：如果没有最小值，我们需要输出 `-1`。

接下来我们来讲一下代码实现细节：
- 方向数组的找法。我举个例子，我们找象的方向数组。从左上到右上，先依次数坐标 $x$ 偏移了多少，再数 $y$ 偏移了多少，把偏移量记录到方向数组即可。马的也就同理了。
- 我们一开始的时候要把所以的步数设为最大值，因为如果 $(i,j)$ 走不到，那么我们的步数是 $0$ 时最小步数就是 $0$，而这个点走不到，与题目不符。所以我们可以写个循环，把 $mway_{i,j},xway_{i,j}$ 设为极大值。
- 我们可以用一个队列维护搜索时扩散的顺序，每扩散一个，就把这个点弹出队列。每找到一个可以扩散的点，就把它给装进队列。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n";
const int maxn=1005;
struct node{
	int x,y;
	int step;
};
int n,mx,my,xx,xy;
//m开头的遍历是关于马的数组，x开头的数组和象有关。
int mway[maxn][maxn],xway[maxn][maxn];//记录每个位置的步数
bool mvis[maxn][maxn],xvis[maxn][maxn];
int mdx[]={-2,-1,1,2,2,1,-1,-2},mdy[]={-1,-2,-2,-1,1,2,2,1};//方向数组
int xdx[]={-2,2,2,-2},xdy[]={-2,-2,2,2};
bool mcheck(int x,int y){
	if(x<0||x>n||y<0||y>n){//越界了
		return true;
	}
	if(mvis[x][y]){//走过了
		return true;
	}
	return false;
}
bool xcheck(int x,int y){
	if(x<0||x>n||y<0||y>n){
		return true;
	}
	if(xvis[x][y]){
		return true;
	}
	return false;
}
void mbfs(){
	queue<node>q;
	q.push({mx,my,0});//把原点入队
	while(!q.empty()){
		node t=q.front();
		q.pop();
		for(int i=0;i<8;i++){
      //计算下一步走到的位置
			int nx=mdx[i]+t.x;
			int ny=mdy[i]+t.y;
			if(mcheck(nx,ny)){//不合法
				continue;
			}
			mvis[nx][ny]=true;
			q.push({nx,ny,t.step+1});
			mway[nx][ny]=t.step+1;//计算步数，是在上一个点走过来的，所以要加一
		}
	}
}
void xbfs(){
	queue<node>q;
	q.push({xx,xy,0});
	while(!q.empty()){
		node t=q.front();
		q.pop();
		for(int i=0;i<4;i++){
			int nx=xdx[i]+t.x;
			int ny=xdy[i]+t.y;
			if(xcheck(nx,ny)){
				continue;
			}
			xvis[nx][ny]=true;
			q.push({nx,ny,t.step+1});
			xway[nx][ny]=t.step+1;
		}
	}
}
signed main(){
	cin>>n>>mx>>my>>xx>>xy;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			mway[i][j]=INT_MAX;
			xway[i][j]=INT_MAX;
		}
	}
	mvis[mx][my]=true;
	xvis[xx][xy]=true;
	mway[mx][my]=0;
	xway[xx][xy]=0;
	mbfs();
	xbfs();
	int mini=INT_MAX;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			mini=min(mway[i][j]+xway[i][j],mini);//计算步数总和
		}
	}
	if(mini==INT_MAX){//特判，如果答案不存在，输出-1
		cout<<-1<<endl;
		return 0;
	}
	cout<<mini<<endl;
	return 0;
}
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
任意一个棋子都可以连续走任意步，也就是说，如果马到了一个点，它可以等象跑过来（无论多少步）吃掉它。问题就变成了求两个棋子分别走到一个点所需要的步数之和的最小值。我们可以对两个棋子各跑一遍广度优先搜索，把每个棋子能够走到的点走到需要的步数求出来，存在二维数组里，最后再一个一个点遍历，对两个棋子走到那个点要的步数之和求最小值。由于答案不存在输出 $-1$，所以答案变量初始化为 $10^9$，最后再进行特判即可。
### 代码：

```cpp
import sys
from collections import deque

n, x1, y1, x2, y2 = map(int, sys.stdin.readline().split())
hd = [[-1 for _ in range(55)] for _ in range(55)]
ed = [[-1 for _ in range(55)] for _ in range(55)]
dxh = [1, 2, 2, 1, -1, -2, -2, -1]  # 马
dyh = [2, 1, -1, -2, -2, -1, 1, 2]
dxe = [2, 2, -2, -2]  # 象
dye = [2, -2, 2, -2]
q = deque()

def bfs(x, y, d, dx, dy, m):
    d[x][y] = 0
    q.append((x, y))
    while q:
        x, y = q.popleft()
        for i in range(m):
            nx = x + dx[i]
            ny = y + dy[i]
            if 0 <= nx <= n and 0 <= ny <= n and d[nx][ny] == -1:
                d[nx][ny] = d[x][y] + 1  # 每个点马象走了多少步到。
                q.append((nx, ny))

bfs(x1, y1, hd, dxh, dyh, 8)  # bfs马
bfs(x2, y2, ed, dxe, dye, 4)  # bfs象
ans = 1e9
for i in range(n + 1):
    for j in range(n + 1):
        if hd[i][j] != -1 and ed[i][j] != -1:
            ans = min(ans, hd[i][j] + ed[i][j])
print(-1 if ans == 1e9 else ans)
```

---


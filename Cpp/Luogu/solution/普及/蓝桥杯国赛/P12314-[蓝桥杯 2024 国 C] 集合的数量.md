# [蓝桥杯 2024 国 C] 集合的数量

## 题目背景

截止 2025 年 4 月 23 日，蓝桥杯官网本题测试数据不符合测试点范围要求（或者说，本题数据点范围限制不明确），存在类似如下的数据：

```
9
{}
{}
{""}
{"ejoa"}
{"aehr","ncuy"}
{"lidm","dgxy"}
{"fzxh"}
{"vtfh","vtfh","ksoc","vtfh"}
{"ksoc","vtfh","ksoc","vtfh"}
```

洛谷的数据剔除了此类情况。如果需要在蓝桥杯题库提交本题请注意这个问题。

## 题目描述

小蓝有 $n$ 个集合，这些集合中的元素还未去重。每个集合 $S_i$ 最多含有 $5$ 个长度不大于 $4$ 的仅含小写字母的字符串 $S_{i,j}$。

你需要计算小蓝的这些集合去重后有多少个（集合内的元素和集合之间都要去重）。

每个集合用 `{"abc"}`，`{"a","b","c","d"}` 的形式输入 (无空格)。


## 说明/提示

### 样例说明

三个集合本质上都是 `{"a","b"}`。

### 评测用例规模与约定
- 对于 $40\%$ 的评测用例，$n \leq 10$；
- 对于所有评测用例，$1 \leq n \leq 1000$，$|S_i| \leq 5$，$|S_{i,j}| \leq 4$ 。


## 样例 #1

### 输入

```
3
{"a","b","b","b"}
{"a","a","b","b"}
{"a","a","a","b"}```

### 输出

```
1```

# 题解

## 作者：MingDynasty (赞：9)

[题目链接](https://www.luogu.com.cn/P12314)

楼下有用 set 过掉的，那我就用 map 水过。

## 题目思路：

由于我们要在集合内去重，因此可以用一个 map，存放去重后的集合，集合之间的去重我们可以另外开一个 map 做标记，最终的答案是集合之间的 map 的大小。

## Code：

```cpp
/*
    Auther:MingDynasty
    Problem:https://www.luogu.com.cn/problem/P12314
*/
#include<bits/stdc++.h>
using namespace std;
int m;
map<map<string,bool>,bool> l;
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>m;
	while(m--){
		string a;
		cin>>a;
		map<string,bool> w;
		string x="";
		for(int i=0;i<a.size();i++){
			if(a[i]<='z'&&a[i]>='a') x+=a[i];
			else w[x]=1,x="";
		}
		l[w]=1;
	}
	cout<<l.size();
	return 0;
}

```

祝通过！

---

## 作者：juruo_zhuyl (赞：6)

较简单的 map 题。

## 思路：

由于需要去重，我们考虑用 map 套 map，外面的 map 记去重后的字符串集合，再另开一个 map 记集合两两间去重，答案即为 map 的大小。

## 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;

int m;
map<map<string, bool>, bool> a;
map<string, bool> t;
string s, v;

int main() {
	ios::sync_with_stdio(0);//关闭同步流
	cin.tie(0);
	cout.tie(0);
	cin >> m;
	while (m--) {
		v = "";
		t.clear();//清空
		cin >> s;
		int n = s.size();
		s = ' ' + s;
		for (int i = 1; i <= n; i++) {
			if (s[i] <= 'z' && s[i] >= 'a'){//判断是否为 'a' ~ 'z' 的字符
				v += s[i];
			}else{
				t[v] = 1;//记录集合并去重
				v = "";//清空字符串
			}
		}
		a[t] = 1;
	}
	cout << a.size() << "\n";
	return 0;//完美结束
}
```


温馨提示：如果每次计算不清空，你会获得 55pts 的“好成绩”。~~别问我咋知道的~~。

[记录](https://www.luogu.com.cn/record/216281584)

---

## 作者：_IceCream_ (赞：2)

# Content

给你 $n$ 个形如 `{"string1", "string2", ...}` 的集合，问你将它们去重后的集合有多少个。

# Solution

我们知道集合中有互异性，也就是集合中没有重复元素。那么我们首先要给集合内元素去重。

其次我们要求不同的集合有多少个，那么我们还需要给集合本身去重。

set 正好符合这个性质，它本身就代表集合，且有互异性。

用一个 set 记集合内，一个 set 记集合即可。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
string s;
set <set <string>> m; // 集合去重 

int main () {

	ios::sync_with_stdio (false);
	cin.tie (0); cout.tie (0);
	
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> s;
		
		string t = "";
		set <string> tmp; // 元素去重 
		tmp.clear ();
		
		for (int j = 0; j < s.length (); ++j) {
			if (islower (s[j])) t += s[j];
			else {
				// 如果不是，说明这个字符就是分隔的，需要插入集合内然后清空。 
				tmp.insert (t);
				t = "";
			}
		}
		m.insert (tmp);
	}
	cout << m.size ();
	
	return 0;
}
```

---

## 作者：niuniudundun (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12314)

# Problem

将集合内的元素和集合之间都要去重后有多少个集合。

# Solution

  定义 `string` 型变量 $str,tstr$、`set<set<string> >` 型 $s_1$ 和 `set<string>` 型 $s_2$，分别用于整体集合、集合元素、存储集合和集合元素去重。首先读入 $n$，并循环 $n$ 次。每次读入 $str$，清空 $s_2$，对于每个位置判定，如果是双引号，则把 $tstr$ 插入 $s_2$，$tstr$ 清空；否则如果是 $\texttt{a}\sim\texttt z$ 则添加到 $tstr$。然后把 $s_2$ 插入 $s_1$。最后输出 $s_1$ 的长度。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
set<set<string> > s1;
set<string> s2;
signed main(){
	cin>>n;
	while(n--){
		string str,tstr="";
		cin>>str;
		int l=str.length();
		s2.clear();
		for(int i=0;i<l;i++){
			if(str[i]=='\"'){
				s2.insert(tstr);
				tstr="";
			}
			if(str[i]>='a'&&str[i]<='z'){
				tstr+=str[i];
			}
		}
		s1.insert(s2);
	}
	cout<<s1.size()<<endl;
	return 0;
}
/*	
3
{"a","b","b","b"}
{"a","a","b","b"}
{"a","a","a","b"}
*/
```

---

## 作者：heyou666 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P12314)

很水的一道题，思路较为直接。考察对 set 的使用方法是否明晰及 set 去重和自动排序的特性。

**题目大意**：给出 $n$ 个由一些符号和小写字母构成的子串组成的未去重集合，求将它们中的所有元素去重后再将它们本身去重还剩下几个集合。

**题目思路**：看到集合和去重很容易想到 STL 中的 set。先每行输入一个字符串代表一个集合，利用集合中子串只有小写字母的特性遍历字符串去掉中间分隔用的符号以求出子串，因为 set 容器本身有自动去重和排序的特性，拿到每个字符串中的子串后放入一个 set 中自动去重和按照字典序即可，拿到去重后的 set 在放入一个大的 set 中去重和排序，这样大的 set 就去除了所有**本质相同**的集合，输出大的 set 的长度（即去重后剩余集合数）即可。

***Code:***

```cpp
#include<bits/stdc++.h>
using namespace std;
set<set<string>>st;//用于存储小集合的大集合
set<string> sts;//存储子串的小集合
long long n;
int main(){
    cin>>n;
    while(n--){
        sts.clear();//每次循环前清空用过的集合
        string s;
        cin>>s;
        string s1="";
        for(int i=0;i<s.size();i++){//遍历出每个子串拿到小集合 
            if(97<=s[i]&&s[i]<=122) s1+=s[i];//如果不是分隔符号而是小写字母就是一个子串中的内容
            else{
                sts.insert(s1);//当前不是小写字母，说明接下来有一个新的子串，将上一个将子串放入小集合中并去重
                s1="";//当前不是小写字母，说明接下来有一个新的子串，清空当前收集子串的字符串，收集下一个子串
            }
        }
        st.insert(sts);//将去重后的小集合放入大集合并去重
    }
    cout<<st.size();//输出大集合去重后的长度
    return 0;
}
```

---

## 作者：ssxzhang (赞：1)

思路：读入 $n$，循环 $n$ 次，每次输入一个字符串，遍历此字符串，将此字符串里的子串分出来，加入一个 set 去重，求出这个字符串实质是哪个集合，再将求出的这个 set 加入另一个用来求有多少种集合的 set ，最后输出这个 set 的长度就可以啦。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
set<set<string>> st;
int main()
{
    int n;
    cin>>n;
    getchar();
    for(int i=1;i<=n;i++)
    {
        string s;
        getline(cin,s);
        string ss="",ans="";
        set<string> stt;
        for(int i=0;i<s.size();i++)
        {
            if(s[i]<='z'&&s[i]>='a')ss=ss+s[i];
            else
            {
                stt.insert(ss);
                ss="";
            }
        }
        st.insert(stt);
    }
    cout<<st.size();
    return 0;
}
```

---

## 作者：Ak_hjc_using (赞：0)

很明显可以使用 set，此题问去重数量，无非使用 $2$ 个 set 分别维护**当前的集合**进行去重的结果，和**总共的集合**去重的结果，最后输出维护总共结果的 set 的元素个数就是答案。

```cpp
cin >> n;
for (int i = 1; i <= n; i++) {
  cin >> s, x.clear(); // x为当前的集合进行去重的结果
  for (int i = 0; i < s.size() - 1; i++) {
    if (s[i] == '\"') { // 提取出每一个字符串
      x.insert(t), t = "";
    } else if (s[i] >= 'a' && s[i] <= 'z') {
      t += s[i];
    }
  }
  y.insert(x); // y是总共的集合去重的结果
}
cout << y.size() << '\n';
```

---

## 作者：New_Void (赞：0)

## [P12314 [蓝桥杯 2024 国 C] 集合的数量](https://www.luogu.com.cn/problem/P12314)

### 思路

这题其实就是一个去重，提到去重，我们就想到了 set 来解决这道题。

- 首先，我们看到每个序列里有若干个字符串，而这些序列里的字符串也需要进行去重，所以我们需要两个 set 方法。
- 其中一个用来存储一个序列里的字符串的去重，而另一个则是存储序列的去重。
- 之后我们循环每个序列，判断如果字符串里的字符是引号，则说明，有一个独立的元素，这时候我们用一个变量一直记录每个字符，当条件成立，则将这个变量字符串清空。
- 在清空变量字符串之前，将字符串放入存储序列里的字符串的 set 里。
- 在循环结束后，将集合放入大集合里，并清空。
- 最后输出大集合的长度。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
set<set<string>> s;
set<string> s2;
signed main(){
    int n;
    cin>>n;
    while (n--){
        string str1="";
        s2.clear();
        string str;
        cin>>str;
        int len=str.size();
        for (int i=0;i<len;i++){
            if (str[i]=='\"'){
                s2.insert(str1);
                str1="";
            }
            if (str[i]>='a' && str[i]<='z'){ //只有是字符时，才要放进去。
                str1+=str[i];
            }
        }
        s.insert(s2);
    }
    cout<<s.size();
    return 0;
}

```

---

## 作者：ATION001 (赞：0)

对于每个集合 $S_i$：

如果当前字符 $x$ 为小写字母，那么加入字符串 $t$。

否则，加入集合 $st$。

对于每一个集合，用 map 进行标记，最终 map 的大小就是不相同集合的数量。
### 实现
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,ans;
string s,t;
map<set<string>,bool>mp;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		set<string>st;
		t="";
		for(auto z:s){
			if(z>='a'&&z<='z'){
				t+=z;
			}else{
				st.insert(t);
				t="";
			}
		}
		mp[st]=true;
	}
	cout<<mp.size();
	return 0;
}
```

---

## 作者：All_Wrong_Answer (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P12314)

## 题目大意：

输入 $n$ 个集合，判断所有集合中**本质不同**的集合有多少个，**本质不同**指按字典序排序后的两个集合对应位置的元素至少有一个不同。

## 思路：

集合的本质就是去重，容易想到使用一个映射 ```map<string,int>``` 去做，但是我想了一下发现不是很好实现，逐倒闭。

注意到 C++ 本身就有一个集合的 STL，即 ```set```，考虑用它实现。

### 本文中要使用的 STL 与相关函数：

1. ```string ls```：定义字符串 $ls$。
2. ```ls.size()```：返回字符串 $ls$ 的长度。
3. ```set<string>q```：定义一个集合 $q$，内部存储字符串，会自动去重。
4. ```set<set<string> >f```：定义一个集合 $f$，内部存储另一个集合，本质相同的集合会自动去除，只保留本质不同的集合。
5. ```q.insert(ls)```：向集合 $q$ 中加入一个字符串 $ls$ 并去重。
6. ```f.insert(q)```：向集合 $f$ 中加入一个集合 $q$ 并去除本质相同的集合，只保留一个。
7. ```f.size()```：查询集合 $f$ 中元素的个数。

每次输入一行，将输入的元素先加入一个集合 $q$ 中，每行输入完一行将集合 $q$ 加入集合 $f$ 中，最后输出集合 $f$ 中的元素个数即可。

## 完整代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
set<set<string> >f;
int x;
int main(){
	cin>>x;
	for(int i=1;i<=x;i++){
		set<string>q;
		q.clear();
		string a;
		cin>>a;
		int s=a.size();
		int flag=0;
		string ls="";
		for(int j=0;j<s;j++){
			if(a[j]=='\"'){
				if(flag==1){
					flag=0;
					q.insert(ls);
					ls="";
				}
				else flag=1;
				continue;
			}
			if(flag==1) ls=ls+a[j];
		}
		f.insert(q);
	}
	cout<<f.size();
	return 0;
	
}

```
[通过记录](https://www.luogu.com.cn/record/214939783)

---


# [蓝桥杯 2025 国 B] 新型锁

## 题目描述

密码学家小蓝受邀参加国际密码学研讨会，为此他设计了一种新型锁，巧妙地融合了数学的严谨性与密码学的安全性。这把锁包含 2025 个连续的数字格，每个格子需填入一个正整数，从而形成一个长度为 2025 的序列 $\{a_1, a_2, \ldots, a_{2025}\}$，其中 $a_i$ 表示第 $i$ 个格子上的数字。

要想解锁，该序列需满足以下条件：任意两个相邻格子中的数字，其最小公倍数（LCM）均为 2025。即对于所有的 $i$（$1 \leq i \leq 2024$），需满足：

$$\text{LCM}(a_i, a_{i+1}) = 2025$$

现在，请你计算有多少个不同的序列能够解开这把锁。由于答案可能很大，你只需输出其对 $10^9 + 7$ 取余后的结果即可。

# 题解

## 作者：Sunrise_up (赞：10)

这道题目发现直接模拟不可行。

## 思路

我们发现最小公倍数，就马上想到分解质因数。

将 $2025$ 进行分解质因数，得 $2025=3^4\times 5^2$。

那么我们得出：

$$a_i=3^n\times 5^m$$

$$a_{i+1}=3^k\times 5^l$$

所以将题目中的式子简化：

$$\text{LCM}(a_i,a_{i+1})=\text{LCM}(3^n\times 5^m,3^k\times 5^l)=3^{\max(n,k)}\times 5^{\max(m,l)}=2025=3^4\times 5^2$$。

所以得出：
$$\max(n,k)=4$$
$$\max(m,l)=2$$

所以推出 $a_i$ 和 $a_{i+1}$ 的组合是有限的，且每一个位置的计算只依赖前一个，考虑动态规划。

### 状态定义

定义 $dp_{i,0/1,0/1}$ 表示位置 $i$ 的因子是否含有 $3^4$ 和 $5^2$。

### 初始化

很明显，$dp_{0,0,0}=dp_{0,1,0}=dp_{0,0,1}=dp_{0,1,1}=0$，无需做任何变化。

### 转移方程

对于第 $i$ 个位置，只有四种需要变化：

- $dp_{i,0,0}$

  此时，它的前一个数必须拥有 $3^4$ 和 $5^2$，即状态 $dp_{i-1,1,1}$，但是它可以任意变化，对于因子 $3$，它可以选择 $3^0\sim 3^3$ 共四种；对于因子 $5$，它可以选择 $5^0\sim 3^1$ 共两种。则它符合的只有 $4\times2=8$ 种。

  所以我们可以得出：

  $$dp_{i,0,0}=8dp_{i-1,1,1}$$

- $dp_{i,0,1}$

  此时，它的前一个数必须拥有 $3^4$，即状态 $dp_{i-1,1,0}$ 和 $dp_{i-1,1,1}$，但是它还可以变化因子 $5$，它可以选择 $5^0\sim 5^1$ 共两种。则它符合的只有 $2$ 种。

  所以我们可以得出：

  $$dp_{i,0,1}=2(dp_{i-1,1,0}+dp_{i-1,1,1})$$

- $dp_{i,1,0}$

  同 $dp_{i,0,1}$，它的前一个数必须拥有 $5^2$，即状态 $dp_{i-1,0,1}$ 和 $dp_{i-1,1,1}$，但是它还可以变化因子 $3$，它可以选择 $3^0\sim 3^3$ 共四种。则它符合的只有 $4$ 种。

  所以我们可以得出：

  $$dp_{i,1,0}=4(dp_{i-1,0,1}+dp_{i-1,1,1})$$

- $dp_{i,1,1}$

  此时它只有唯一一种可能，但是它的前一个数是任意的，即 $i-1$ 的所有状态：

  $$dp_{i,1,1}=dp_{i-1,0,0}+dp_{i-1,0,1}+dp_{i-1,1,0}+dp_{i-1,1,1}$$


综上，我们得出状态转移方程：

$$
\begin{cases}

dp_{i,0,0}=8dp_{i-1,1,1} \\
dp_{i,0,1}=2(dp_{i-1,1,0}+dp_{i-1,1,1})\\
dp_{i,1,0}=4(dp_{i-1,0,1}+dp_{i-1,1,1})\\
dp_{i,1,1}=dp_{i-1,0,0}+dp_{i-1,0,1}+dp_{i-1,1,0}+dp_{i-1,1,1}

\end{cases}
$$

### 结果

答案即为 $dp_{2025,0,0}+dp_{2025,0,1}+dp_{2025,1,0}+dp_{2025,1,1}$。

所以使用编程进行~~复杂的~~运算后，我们得出结果是 $385787853$。

## 代码

使用 C++：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cout<<385787853;
	return 0;
}
```

使用 python：

```python
print(385787853)
```


求点赞 qwq！

---

## 作者：Nostopathy (赞：6)

# Solution

将 $2025$ 分解为 $3^4 \times 5^2$，因为每个值只与上一个值有关，考虑动态规划。

若 $s=3^a\times5^b$，$t=3^c\times5^d$，则 LCM 结果为 $3^{\text{max}(a,c)}\times5^{\text{max}(b,d)}$，由此考虑表示 $a_i$ 分解后是否含有 $3^4$ 与 $5^2$。

定义 $dp_{i,j,k}$：当 $j=1$，则 $a_i$ 分解后含有 $3^4$；当 $k=1$，则 $a_i$ 分解后含有 $5^2$。此时该值表示前 $i$ 格的排法种数。

状态转移：

- $dp_{i,0,0}$：由于本格不含有 $3^4$ 或 $5^2$，因此上格必须含有 $3^4$ 与 $5^2$，又本格可选 $3^0$ 至 $3^3$ 的任一个乘上 $5^0$ 至 $5^2$ 的任一个，故 $dp_{i,0,0}=dp_{i-1,1,1} \times 8$；
- $dp_{i,0,1}$：由于本格不含有 $3^4$，因此上格必须含有 $3^4$，又本格可选 $3^0$ 至 $3^3$ 的任一个乘上 $5^2$，故 $dp_{i,0,1}=(dp_{i-1,1,0}+dp_{i-1,1,1}) \times 4$；
- $dp_{i,1,0}$：由于本格不含有 $5^2$，因此上格必须含有 $5^2$，又本格可选 $5^0$ 至 $5^1$ 的任一个乘上 $3^4$，故 $dp_{i,1,0}=(dp_{i-1,0,1}+dp_{i-1,1,1}) \times 2$；
- $dp_{i,1,1}$：由于本格同时含有 $3^4$ 与 $5^2$（即本格为 $2025$），因此种数为上一格所有种数之和，故 $dp_{i,1,1}=dp_{i-1,0,0}+dp_{i-1,0,1}+dp_{i-1,1,0}+dp_{i-1,1,1}$。

初始化简单枚举排列数即可：

- $dp_{1,0,0} \leftarrow 8$；
- $dp_{1,0,1} \leftarrow 4$；
- $dp_{1,1,0} \leftarrow 2$；
- $dp_{1,1,1} \leftarrow 1$。

厘清思路，写代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
const int mod = 1e9 + 7;
int dp[2026][2][2];
signed main () {
	dp[1][0][0] = 8;
	dp[1][0][1] = 4;
	dp[1][1][0] = 2;
	dp[1][1][1] = 1;
	for (int i = 2; i <= 2025; ++ i) {
		dp[i][0][0] = (dp[i - 1][1][1] << 3) % mod;
		dp[i][0][1] = ((dp[i - 1][1][0] + dp[i - 1][1][1]) << 2) % mod;
		dp[i][1][0] = ((dp[i - 1][0][1] + dp[i - 1][1][1]) << 1) % mod;
		dp[i][1][1] = (dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][1][0] + dp[i - 1][1][1]) % mod;
	}
	cout << (dp[2025][0][0] + dp[2025][0][1] + dp[2025][1][0] + dp[2025][1][1]) % mod;
	return 0;
}
```

- DP 的过程中需要随时取模；
- 乘 $2$ 的自然数幂可用位运算简化；
- **十年 OI 一场空，不开【】见祖宗！**

得出答案 $385787853$，Python 代码：

```python
print(385787853)
```

结语：这绝对不是所有题解中最短的，但肯定是最详细的，非常感谢您能看到这里，另外也希望这篇题解能帮助您对这道题以及动态规划有更深的理解。

~~没有求关的题解不是好题解。~~

---

## 作者：mahiro_zcy (赞：4)

由于 $2025 = 5^2 \cdot 3^4$，并且对于质数 $p_1, p_2, \cdots, p_s$，有
$$
\mathrm{lcm}\left(\prod_{i=1}^s p_i^{x_{i}}, \prod_{i=1}^s p_i^{y_{i}}\right) = \prod_{i=1}^s p_i^{\max\left\{x_{i}, y_{i}\right\}}
$$
我们分开考虑 5 的指数和 3 的指数.

设 $f\left(m, n\right)$ 为，长度为 $n$ 的，满足
$$
\forall i \in \left\{1, 2, \cdots, n - 1\right\}, \max\left\{e_i, e_{i+1}\right\} = m
$$
的非负整数序列 $e$ 的个数.

那么我们能给出转移
$$
\forall n \geq 2, f\left(m, n\right) = f\left(m, n - 1\right) + mf\left(m, n - 2\right)
$$
这是因为，所有长度为 $n$ （$n \geq 2$）的序列，可以由以下方法不重不漏地得到：

1. 所有长度为 $n-1$ 的序列，末尾添加 $m$
2. 所有长度为 $n - 2$ 的序列，末尾添加 $m$ 后，再添加一个 $\left[0, m - 1\right]$ 上的整数

另外，我们有初值 $f\left(m, 0\right) = 1, f\left(m, 1\right) = m + 1$.

那么，我们的答案就是
$$
f\left(2, 2025\right) \cdot f\left(4, 2025\right) \equiv 385787853 \pmod{10^9 + 7}
$$
可由下面的代码计算.

```cpp
#include <bits/stdc++.h>

using i64 = long long;
using u64 = unsigned long long;
using u32 = unsigned int;

using i128 = __int128;
using u128 = unsigned __int128;

template <typename T>
std::tuple<T, T, T> exgcd(const T& a, const T& b) {
    if (b == T(0)) {
        return {a, T(1), T(0)};
    }
    auto [g, x, y] = exgcd(b, a % b);
    return {g, y, x - a / b * y};
}

template <long long mod>
class ModInt {
    static_assert(mod >= 1LL, "The modulus must be a positive integer.");
private:
    long long value;
public:
    ModInt() : value(0LL) {}

    ModInt(const ModInt& v) : value(v.value) {}

    template <typename T>
    ModInt(const T& v): value(((long long)(v % mod) + mod) % mod) {}

    explicit operator long long() const {
        return value;
    }

    long long get_value() const {
        return value;
    }

    static long long get_mod() {
        return mod;
    }

    ModInt inv() const {
        auto [g, x, y] = exgcd<long long>(value, mod);
        // 可以证明 -mod < x && x < mod
        if (g != 1LL) {
            throw std::runtime_error("The modular inverse does not exist.");
        }
        ModInt res;
        res.value = x;
        if (res.value < 0LL) {
            res.value += mod;
        }
        return res;
    }

    template <typename V>
    ModInt pow(V b) const {
        long long a = ((b >= V(0)) ? value : inv().value);
        ModInt res;
        res.value = ((mod >= 2LL) ? 1LL : 0LL);
        while (b != V(0)) {
            if (b % V(2) != V(0)) {
                res.value = res.value * a % mod;
            }
            a = a * a % mod;
            b = b / V(2);
        }
        return res;
    }

    ModInt& operator+=(const ModInt& b) {
        value += b.value;
        if (value >= mod) {
            value -= mod;
        }
        return *this;
    }

    ModInt& operator-=(const ModInt& b) {
        value -= b.value;
        if (value < 0LL) {
            value += mod;
        }
        return *this;
    }

    ModInt& operator*=(const ModInt& b) {
        value *= b.value;
        value %= mod;
        return *this;
    }

    ModInt& operator/=(const ModInt& b) {
        value *= b.inv().value;
        value %= mod;
        return *this;
    }

    ModInt& operator=(const ModInt& b) {
        value = b.value;
        return *this;
    }

    ModInt operator+() const {
        return *this;
    }

    ModInt operator-() const {
        ModInt res;
        res.value = -value;
        if (res.value < 0LL) {
            res.value += mod;
        }
        return res;
    }

    ModInt& operator++() {
        ++value;
        if (value >= mod) {
            value -= mod;
        }
        return *this;
    }

    ModInt operator++(int) {
        ModInt temp(*this);
        ++value;
        if (value >= mod) {
            value -= mod;
        }
        return temp;
    }

    ModInt& operator--() {
        --value;
        if (value < 0LL) {
            value += mod;
        }
        return *this;
    }

    ModInt operator--(int) {
        ModInt temp(*this);
        --value;
        if (value < 0LL) {
            value += mod;
        }
        return temp;
    }

    friend ModInt operator+(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value + b.value;
        if (res.value >= mod) {
            res.value -= mod;
        }
        return res;
    }

    friend ModInt operator-(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value - b.value;
        if (res.value < 0LL) {
            res.value += mod;
        }
        return res; 
    }

    friend ModInt operator*(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value * b.value % mod;
        return res;
    }

    friend ModInt operator/(const ModInt& a, const ModInt& b) {
        ModInt res;
        res.value = a.value * b.inv().value % mod;
        return res;
    }

    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) {
        os << x.value;
        return os;
    }

    friend std::istream& operator>>(std::istream& is, ModInt& x) {
        if (is >> x.value) {
            x.value = (x.value % mod + mod) % mod;
        }
        return is;
    }
};

using Z = ModInt<1'000'000'007LL>;

void solve() {
    auto calc = [&](int m) {
        std::array<Z, 2026> f;
        f[0] = 1;
        f[1] = m + 1;
        for (int i = 2; i <= 2025; ++i) {
            f[i] = f[i - 1] + m * f[i - 2];
        }
        return f[2025];
    };
    Z ans = calc(2) * calc(4);
    std::cout << ans << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t = 1;
    // std::cin >> t;

    while (t--) {
        solve();
    }

    return 0;
}
```

---

## 作者：mktx (赞：4)

知识点：最小公倍数，分解质因数， $DP$ 

这题尝试利用一个结论：对正整数 $a$ 和 $b$ 分别进行质因数分解：

 $ a=p_{1}^{\alpha _{1}}p_{2}^{\alpha _{2}}...p_{k}^{\alpha _{k}}$ 
 
  $ b=p_{1}^{\beta _{1}}p_{2}^{\beta _{2}}...p_{k}^{\beta _{k}}$ 

那么正整数 $a$ 和 $b$ 的最小公倍数即为：

 $\textrm{lcm}\left ( a,b \right )=p_{1}^{\textrm{max}\left ( \alpha _{1},\beta _{1} \right )}p_{2}^{\textrm{max}\left ( \alpha _{2},\beta _{2} \right )}...p_{k}^{\textrm{max}\left ( \alpha _{k},\beta _{k} \right )}$ 

为此可以对 $2025$ 进行分解质因数，得到：

  $2025=3^{4}\times 5^{2}$ 

那么对于相邻的两个数 $a$ 和 $b$，应至少有一个数的 $3$ 的质因子选择 $4$ 次方，至少有一个数的 $5$ 的质因子选择 $2$ 次方。对于 $3$ 的质因子选择 $4$ 次方有 $1$ 种选法，不选 $4$ 次方有 $ 3^{0}\sim 3^{3}$ 共 $4$ 种选法；对于 $5$ 的质因子选择 $2$ 次方有 $1$ 种选法，不选 $2$ 次方有 $ 5^{0}\sim 5^{1}$ 共 $2$ 种选法，因此可以使用 $DP$ 解决这道题。

定义 $dp_{i,0/1,0/1}$ 表示前 $i$ 个数中 $3$ 的质因子是否选择 $4$ 次方（ $0$ 表示不选，$1$ 表示选），$5$ 的质因子是否选择 $2$ 次方（ $0$ 表示不选，$1$ 表示选）的合法方案。

初始化：

 $dp_{1,0,0}=4\times2=8$ 
 
 $dp_{1,0,1}=4\times1=4$ 

 $dp_{1,1,0}=1\times2=2$ 

 $dp_{1,1,1}=1\times1=1$

状态转移：考虑第 $i$ 个数，如果第 $i$ 个数对于 $3$ 的质因子**不选** $4$ 次方，对于 $5$ 的质因子**不选** $2$ 次方，那么第 $i-1$ 个数就必须同时选择 $3$ 的质因子的 $4$ 次方，$5$ 的质因子的 $2$ 次方，第 $i$ 个数本身对于 $3$ 的质因子不选 $4$ 次方，对于 $5$ 的质因子不选 $2$ 次方有 $4\times2=8$ 种方案，因此

$dp_{i,0,0}=8dp_{i-1,1,1}$

如果第 $i$ 个数对于 $3$ 的质因子**不选** $4$ 次方，对于 $5$ 的质因子**选** $2$ 次方，那么第 $i-1$ 个数就必须选择 $3$ 的质因子的 $4$ 次方,但对于 $5$ 的质因子 $2$ 次方可选可不选，第 $i$ 个数本身对于 $3$ 的质因子不选 $4$ 次方，对于 $5$ 的质因子选 $2$ 次方有 $4\times1=4$ 种方案，因此

 $dp_{i,0,1}=4\left ( dp_{i-1,1,0} + dp_{i-1,1,1}\right )$ 

如果第 $i$ 个数对于 $3$ 的质因子**选** $4$ 次方，对于 $5$ 的质因子**不选** $2$ 次方，那么第 $i-1$ 个数就必须选择 $5$ 的质因子的 $2$ 次方,但对于 $3$ 的质因子 $4$ 次方可选可不选，第 $i$ 个数本身对于 $3$ 的质因子选 $4$ 次方，对于 $5$ 的质因子不选 $2$ 次方有 $1\times1=2$ 种方案，因此

 $dp_{i,1,0}=2\left ( dp_{i-1,0,1} + dp_{i-1,1,1}\right )$ 

如果第 $i$ 个数对于 $3$ 的质因子**选** $4$ 次方，对于 $5$ 的质因子**选** $2$ 次方，那么第 $i-1$ 个数 $3$ 的质因子的 $4$ 次方可选可不选，$5$ 的质因子的 $2$ 次方可选可不选，因此

$dp_{i,1,1}=dp_{i-1,0,0} + dp_{i-1,0,1} + dp_{i-1,1,0} + dp_{i-1,1,1}$

最终答案即为 $dp_{2025,0,0} + dp_{2025,0,1} + dp_{2025,1,0} + dp_{2025,1,1}$ 

参考代码：


```cpp
using i64=long long;
const int mod=1e9+7;

void mktx()
{
    int n=2025;
    vector<vector<vector<i64>>>dp(n+1,vector<vector<i64>>(2,vector<i64>(2,0)));
    dp[1][0][0]=8;
    dp[1][0][1]=4;
    dp[1][1][0]=2;
    dp[1][1][1]=1;
    for(int i=2;i<=n;i++)
    {
        dp[i][0][0]=dp[i-1][1][1]*8%mod;
        dp[i][0][1]=(dp[i-1][1][0]+dp[i-1][1][1])%mod*4%mod;
        dp[i][1][0]=(dp[i-1][0][1]+dp[i-1][1][1])%mod*2%mod;
        dp[i][1][1]=((((dp[i-1][0][0]+dp[i-1][0][1])%mod+dp[i-1][1][0])%mod)+dp[i-1][1][1])%mod;
    }
    i64 res=0;
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            res=(res+dp[n][i][j])%mod;
    cout<<res;
}
```

---

## 作者：zhoujunchen (赞：2)

计数问题考虑使用 dp 解决。

众所周知，$2025=3^4\times5^2$，所以数列中的每个数字都是 $3^x\times 5^y$，$0\le x\le4$，$0\le y\le 2$，共 $5\times 3 =15$ 种状态。

将状态压缩一下，定义编号 $s=3x+y$，用 $dp_s$ 表示当数列末尾的数为状态 $s$ 所表示的数时，有多少可能。


状态转移直接用两个数组，~~因为我懒得写滚动数组~~，转移时开两个循环，一个枚举前一个数，一个枚举新数，如果两个数最小公倍数为 $2025$，则计入答案。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int n=2025,dp[20],ans,dp2[20];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	for(int i=0;i<=15;i++)dp[i]=1;
	for(int i=1;i<n;i++){
		memset(dp2,0,sizeof dp2);
		for(int o=0;o<15;o++){
			int x=o/3,y=o%3;
			for(int nw=0;nw<15;nw++){
				int xx=nw/3,yy=nw%3; 
				if(max(x,xx)==4&&max(y,yy)==2)dp2[nw]=(dp2[nw]+dp[o])%mod;
			}
		}
		for(int j=0;j<20;j++)dp[j]=dp2[j];
	}
	for(int i=0;i<15;i++)ans=(ans+dp[i])%mod;
	cout<<ans;
	return 0;
}
```


时间复杂度 $O(n)$。

---

## 作者：dashabi35 (赞：1)

一个十分简单的思路。

我们知道 $\operatorname{LCM}(i,j)=\frac{i\times j}{\gcd}(i,j)$ 其中 $j$ 为 $\gcd(i,j)$ 的倍数，所以 $i$ 一定是 $\operatorname{LCM}(i,j)$ 的因数，所以第一步，先将 $2025$ 的因数预处理出来，再将满足与其的 LCM 为 2025 的数给预处理出来，我们记满足与因数 $i$ 符合的数组成的数组为 $f_i$ ，然后再开始 dp 。

首先是表示数组的含义 ， $dp_{i,j}$ 表示的是长度为 $i$ 末尾为 $j$ 的种数。

初始化：从 $2$ 开始 dp ，显然 $dp_{2,i}$ 的值为 $f_i$ 的元素数量，原因：数列 $i,f_{i,j}$ 一定符合。

状态转移方程：

$$dp_{i,j}=\sum dp_{i-1,f_{i,j}}$$

最后，结果就是 $\sum dp_{2025,i}$ 。

然后就好了，一些代码细节详见代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int dp[2026][2026];//dp[i][j] 表示长度为 i 以 j 结尾的方案的组数
vector<int> f[2026];
vector<int> u;
int ans; 
int gcd(int a,int b)
{
	if(a<b) swap(a,b);
	return b?gcd(b,a%b):a;
}
signed main()
{
	// 预处理 2025 的因数
	for(int i=1;i<=2025;++i)
	{
		if(2025%i==0)u.push_back(i);
	}
    // 预处理和 i 的最小公倍数为 2025 的数
	for(auto i:u)
	{
		// 若符合的数有 k 则 i*k/gcd(i,k)=2025 
		for(int j=1;j<=i;++j)
		{
			int k=j*2025/i;
			if(gcd(k,i)==j) 
			{
				f[i].push_back(k);
			}
		}
	} 
	for(auto i:u)
	{
		dp[2][i]=f[i].size();
	}
	for(int i=3;i<=2025;++i)
	{
		for(auto j:u)
		{
			for(auto p:f[j])
			{
				dp[i][j]+=dp[i-1][p];
				dp[i][j]%=mod;
			}
			if(i==2025)
			{
			    ans+=dp[i][j];
				ans%=mod;	
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

---


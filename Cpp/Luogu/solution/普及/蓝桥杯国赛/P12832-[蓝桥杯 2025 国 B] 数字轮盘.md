# [蓝桥杯 2025 国 B] 数字轮盘

## 题目描述

“数字轮盘”是一款益智游戏，基于一个带有指针的圆形轮盘展开。轮盘边缘按顺时针刻有数字 1 至 $N$，初始时指针指向 1。

游戏分为两阶段：旋转轮盘和恢复轮盘。

第一阶段，将轮盘顺时针旋转 $K$ 次。每次旋转，数字依次后移一位，指针指向的数字随之改变。例如，对于 $N = 4$ 的轮盘，初始状态为 1, 2, 3, 4（指针指向 1），旋转一次变为 4, 1, 2, 3（指针指向 4），再旋转一次变为 3, 4, 1, 2（指针指向 3），依此类推。

第二阶段，小蓝需通过操作恢复初始状态，每次操作包含以下两步：
- 第一步：翻转以指针为起点、顺时针方向的前 $N - 1$ 个数字的顺序。
- 第二步：翻转除指针外的 $N - 1$ 个数字的顺序。

例如，对 $N = 4$，状态为 4, 1, 2, 3（指针指向 4）进行一次操作：
- 第一步：翻转 4, 1, 2，变为 2, 1, 4, 3（指针指向 2）。
- 第二步：翻转 1, 4, 3，变为 2, 3, 4, 1（指针指向 2）。

现在，给定轮盘的数字个数 $N$ 和旋转次数 $K$，请计算小蓝最少需要几次操作才能恢复初始状态。如果无法恢复初始状态，则输出 -1。


## 说明/提示

**【评测用例规模与约定】**

对于 30% 的评测用例，$1 \leq T \leq 10^2$，$2 \leq N \leq 500$，$0 \leq K \leq 500$。

对于 100% 的评测用例，$1 \leq T \leq 10^5$，$2 \leq N \leq 10^9$，$0 \leq K \leq 10^9$。

## 样例 #1

### 输入

```
2
3 2
4 1```

### 输出

```
2
-1```

# 题解

## 作者：lychen2025 (赞：5)

# ~~闲话~~ 前言
由于没写过题解被小糖人认为不够地道，于是写了一篇比较新的题）  
一道数学题！  
# 正文
初看吓一跳，然后打表观察发现：**一次“操作”就是“旋转”两次**。  
这下简单了，如果旋转周期剩下的旋转次数是偶数就可以完成操作；如果旋转周期剩下的次数再加一个周期次数是偶数也可以完成操作；易证只有这两种情况。  
### Code  

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,k;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>k;
		int x=(n-k%n)%n;
    	if(x%2==0)cout<<x/2<<'\n';
    	else if((x+n)%2==0)cout<<(x+n)/2<<'\n';
    	else cout<<"-1\n";
	}
	return 0;
}
```

---

## 作者：Nostopathy (赞：2)

# Solution

下面简单证明一下大佬 [@lychen2025](https://www.luogu.com.cn/user/1111184) 发现的规律：（以下图中最上面的点为指针所在处）

![](https://cdn.luogu.com.cn/upload/image_hosting/sg01ame5.png)

最开始，从 $1$ 到 $N$ 顺时针排列；

![](https://cdn.luogu.com.cn/upload/image_hosting/nzbjav4n.png)

旋转 $K$ 次后，可看作每个数加上 $K$ 后对 $N$ 取模；

![](https://cdn.luogu.com.cn/upload/image_hosting/6adxgnhm.png)

将除表示 $K$ 的点以外的点翻转；（可以看出从顺时针增大变为逆时针增大）

![](https://cdn.luogu.com.cn/upload/image_hosting/mygehq41.png)

将除表示 $K-1$ 的点以外的点翻转，与第二张图对比，可看出**一次操作等于两次顺时针旋转**。

回归题目，询问旋转后操作几次还原，也就是需要旋转的次数的一半。很明显看出需要旋转 $N-K\text{mod}N$ 次。这时需要分类讨论：

- 当 $N-K\text{mod}N$ 能被 $2$ 整除，则至少总旋转 $1$ 圈，答案为 $\frac{N-K\text{mod}N}{2}$；
- 当 $N-K\text{mod}N$ 不能被 $2$ 整除，若至少总旋转 $2$ 圈时 $2N-K\text{mod}N$ 能被 $2$ 整除，答案为 $\frac{2N-K\text{mod}N}{2}$，否则无解。

厘清思路，写代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
signed main () {
	int t; scanf("%lld", &t);
	while (t --) {
		int n, k; scanf("%lld%lld", &n, &k);
		k %= n;
		if (!((n - k) % 2))
			printf("%lld\n", (n - k) >> 1);
		else if (!((2 * n - k) % 2))
			printf("%lld\n", (2 * n - k) >> 1);
		else
			puts("-1");
	}
	return 0;
}
```

非常感谢您没有抄，因为这段代码只能得 $65$ 分。

数据范围中 $K$ 可以取 $0$，因此应特判该情况，或采用大佬 [@lychen2025](https://www.luogu.com.cn/user/1111184) 的方法，令 $N-K\text{mod}N$ 取模 $N$，这样得出的也是 $0$。

结语：这道题目看似很复杂，实际上可以用数学方法简化。在编程中，数学是很实用的工具，可以有效简化代码。题解区目前还没有严谨的证明，因此写这篇题解，希望能帮助您更好地理解本题以及数学在编程中的运用。

~~没有求关的题解不是好题解。~~

---

## 作者：koukou (赞：1)

找规律，判断每一种情况。

模拟样例和更多数据发现，一次操作等价于两次旋转，于是问题就转化为：给出 $n$ 和 $k$，每次将 $k$ 加 $2$，求最少要多少次使 $k$ 变为 $n$ 的倍数，若无法实现，输出 $-1$。

很显然，如果 $k$ 和 $n$ 或 $k$ 和 $2n$ 的差值为偶数，就一定可以做到，因为 $3n$ 和 $n$ 是等效的，$4n$ 和 $2n$ 是等效的，所以不用在考虑别的了。特别的，当 $k$ 等于 $0$ 时，直接输出 $0$ 即可，因为 $0$ 本身就是 $n$ 的倍数。

代码：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T, n, k; 
signed main()
{
	cin >> T;
	while(T--)
	{
		cin >> n >> k;
		k %= n;//取模，或者做差时使用abs
		if(k == 0) cout << "0\n";//特判0
		else if((n - k) % 2 == 0) cout << (n - k) / 2 << "\n";//和n的差值为偶数
		else if((2 * n - k) % 2 == 0) cout <<  (2 * n - k) / 2 << "\n";//和2n的差值为偶数
		else cout << "-1\n";//无解
	}
    return 0;
}
```

---

## 作者：zhaokeyu123 (赞：1)

## 题意
我们需要确定小蓝最少需要多少次操作才能将数字轮盘从旋转 $k$ 次后的状态恢复到初始状态。如果无法恢复，则返回 $-1$。

## solution
问题涉及两个阶段：旋转轮盘和恢复轮盘。旋转阶段将轮盘顺时针旋转 $k$ 次，恢复阶段通过特定操作恢复初始状态。操作包括两步：翻转指针位置开始的前 $n-1$ 个数字的顺序，然后翻转除指针外的所有数字的顺序。

## AC code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
    int T;
    cin >> T;
    while (T--) {
        int N, K;cin >> N >> K;
        K %= N;
        if(N % 2 == 1)
		{
            int a = (N - K) % N;
            int inv2 = (N + 1) / 2;
            int x = (a * inv2) % N;
            cout << x << "\n";
        }
		else
		{
            if (K % 2 != 0)cout << "-1\n";
            else {
                int a = (N - K) % N;
                int x = a / 2;
                cout << x << "\n";
            }
        }
    }
    return 0;
}
```

---


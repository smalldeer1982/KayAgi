# [蓝桥杯 2025 国 A] 小蓝的生日礼物

## 题目描述

2025 年 6 月 15 日是小蓝的生日，他的妈妈为他准备了一盒特别的生日礼物：8 张印有数字的卡片，上面分别写着 0, 0, 2, 2, 5, 5, 1, 6。

小蓝想用这些卡片拼凑出三角形。他的想法是，从卡片中选择至少一张卡片，组成一个数字，作为三角形的一条边长。例如，他可以选择卡片 2, 5, 1，组成 251、215、521、512、125、152 等数字。在组合数字时，不允许出现前导 0，也不允许组合出值为 0 的数（无法成为三角形的边）。

为了拼成一个三角形，他需要用同样的方法，再选择一些卡片组成第二个数字，作为三角形的第二条边长，然后再选择一些卡片组成第三个数字，作为三角形的第三条边长。

需要注意的是，在每次组成边长时，每张卡片只能使用一次。也就是说，如果卡片 6 已经被用来组成第一个边长，那么在组成第二个和第三个边长时，就不能再使用这张卡片 6 了。

现在，小蓝想知道，他总共可以拼凑出多少个不同的三角形？这里不同的三角形指的是三条边长所构成的集合不同。例如，边长为 $\{1, 2, 3\}$ 和 $\{2, 3, 4\}$ 的三角形被认为是不同的，而边长为 $\{2, 5, 6\}$ 和 $\{5, 2, 6\}$ 的三角形则被认为是相同的。

# 题解

## 作者：fzt510107 (赞：1)

~~我做过的最水的黄题。~~
### [提交记录](https://www.luogu.com.cn/record/list?pid=P12841&user=1637994)
*  *  *

这道题其实没有你们想象的那么难。

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	cout<<253;
	return 0;
}
``````
~~众所周知，只需要把大佬们的代码复制下来运行就行了。~~

众所周知，这道题可以打暴力算出答案再输出。

```cpp
for(int i=1;i<=700;i++){
		for(int j=i;j<=700;j++){
			for(int k=j;k<=700;k++){
				if(){
                    sum++;
				}
			}
		}
	}
``````
重要的是 if 里的判断条件。

首先必须能组成一个三角形：


```cpp
bool aa(int a,int b,int c){
	if(a+b<=c||b+c<=a||a+c<=b){
		return 0;
	}
	return 1;
}
``````
然后要判断这三个数是否由 0，0，2，2，5，5，1，6 组成。

建议用桶排。
```cpp
bool bb(int a,int b,int c){
	int z[10]={0,0,0,0,0,0,0,0,0,0};
while(a){
    z[a%10]++;
    a/=10;
}	
while(b){
    z[b%10]++;
    b/=10;
}
while(c){
    z[c%10]++;
    c/=10;
}
//数位分离，存入桶数组。
	for(int i=0;i<=9;i++){
		if(i==0||i==2||i==5){
			if(z[i]>2){
				return 0;
			}
		}else if(i==1||i==6){
			if(z[i]>1){
				return 0;
			}
		}else{
			if(z[i]){
				return 0;
			}
		}
	}
	return 1;
}
//判断  
``````
~~相信大家都能看懂。~~

最后搬入 if 语句中就行了。

**注意：这个代码直接交上去会超时。**

所以还要优化一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool aa(int a,int b,int c){
	if(a+b<=c||b+c<=a||a+c<=b){
		return 0;
	}
	return 1;
}
bool bb(int a,int b,int c){
	int z[10]={0,0,0,0,0,0,0,0,0,0};
while(a){
    z[a%10]++;
    a/=10;
}	
while(b){
    z[b%10]++;
    b/=10;
}
while(c){
    z[c%10]++;
    c/=10;
}

	for(int i=0;i<=9;i++){
		if(i==0||i==2||i==5){
			if(z[i]>2){
				return 0;
			}
		}else if(i==1||i==6){
			if(z[i]>1){
			
				return 0;
			}
		}else{
			if(z[i]){
				return 0;
			}
		}
	}
	return 1;
}
int main(){
for(int i=1;i<=700;i++){
   for(int j=i;j<=700;j++){
			for(int k=j;k<=700;k++){
				if(aa && bb){
                    sum++;
				}
        if ( k % 10 == 2 ) k += 2;
        if ( k % 10 == 6 ) k += 3;
			}
      if ( j % 10 == 2 ) j += 2;
      if ( j % 10 == 6 ) j += 3;
		}
    if( i % 10 == 2 ) i += 2;
    if ( i % 10 == 6 ) i += 3;
	}
return 0;
}
``````

优化非常简单，但能省下5s，直接卡线过。（0.96s）

---

## 作者：youqida (赞：1)

按照题意即可这个题

1. 首先暴力枚举所有可能的凑成三角形边长的数字，手推发现，这个可能的数最多为 **3** 位数，然后这个枚举过程用 **dfs** 枚举存下来即可。

2. 枚举后，发现可能的边长数不是很多，我们三个 **for** 循环枚举每一种可能的组合判断即可，然后这里按照题意用 **set** 存下来去重就能得到答案


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
//#define ll long long
const int N=10;
int a[10]={0,0,0,2,2,5,5,1,6};
set<array<int,3>> st;
bool vis[N];
vector<int> v;

void dfs(int u,int cur) {
    if (cur>1) v.emplace_back(u);
    if (cur==4)return;

    if (cur==1) {
        for (int i=3;i<=8;i++) {
            if (vis[i])continue;
            vis[i]=1;
            dfs(u*10+a[i],cur+1);
            vis[i]=0;
        }
    }
    else {
        for (int i=1;i<=8;i++) {
            if(vis[i])continue;
            vis[i]=true;
            dfs(u*10+a[i],cur+1);
            vis[i]=false;
        }
    }
}

void solve(void)
{
    dfs(0,1);
    int n=v.size();
    for (int i=0;i<n;i++) {
        for (int j=i+1;j<n;j++){
            for (int k=j+1;k<n;k++){
                int b[10] = {};
                int x=v[i],y=v[j],z=v[k];
                int xx=x,yy=y,zz=z;
                while (x!=0){b[x%10]++;x/=10;}
                while (y!=0){b[y%10]++;y/=10;}
                while (z!=0){b[z%10]++;z/=10;}
                if (b[0]<=2&&b[2]<=2&&b[5]<=2&&b[1]<=1&&b[6]<=1){
                    if (xx>yy)swap(xx,yy);
                    if (yy>zz)swap(yy,zz);
                    if (xx>yy)swap(xx,yy);
                    if (xx+yy>zz) st.insert({xx,yy,zz});
                }
            }
        }
    }
    cout<<st.size()<<endl;
}

signed main()
{
    std::ios::sync_with_stdio(false);cin.tie(0); cout.tie(0);
    int T=1;
    // cin>>T;
    while(T--)
        solve();
}
```

---


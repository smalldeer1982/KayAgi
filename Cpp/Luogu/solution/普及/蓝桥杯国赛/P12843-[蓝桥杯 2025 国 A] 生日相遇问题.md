# [蓝桥杯 2025 国 A] 生日相遇问题

## 题目描述

小蓝和小乔是好朋友，他们想知道在未来的日子里，什么时候他们的生日会在同一个星期几。已知小蓝的生日是 $m$ 月 $d_1$ 日，小乔的生日是 $n$ 月 $d_2$ 日，请你计算从今年开始（今年为 2025 年），未来 $k$ 年内（包括今年，即年份在区间 $[2025, 2025 + k)$ 中），他们生日在同一个星期几的年份有哪些。

提示：
- 闰年的判断规则为：年份能被 $4$ 整除但不能被 $100$ 整除，或能被 $400$ 整除。闰年的 $2$ 月有 $29$ 天，非闰年的 $2$ 月有 $28$ 天。
- 如果某人的生日是 $2$ 月 $29$ 日，那么在非闰年中，他/她的生日将被视为 $2$ 月 $28$ 日进行计算。
- 保证输入日期均为合法日期。

## 说明/提示

**【样例说明】**

此样例中，小蓝的生日是 1 月 16 日，小乔的生日是 5 月 21 日。

从 2025 到 2032 年间，满足题意的是：

- 2028 年，1 月 16 日是星期日，5 月 21 日也是星期日。
- 2032 年，1 月 16 日是星期五，5 月 21 日也是星期五。

**【评测用例规模与约定】**

对于 25% 的评测用例，$1 \leq k \leq 10$；

对于 50% 的评测用例，$1 \leq k \leq 20$；

对于 75% 的评测用例，$1 \leq k \leq 30$；

对于所有评测用例，$1 \leq k \leq 50$，$1 \leq m, n \leq 12$，$1 \leq d_1, d_2 \leq 31$。

## 样例 #1

### 输入

```
1 16 5 21 8```

### 输出

```
2028
2032```

# 题解

## 作者：Sunrise_up (赞：10)

目前最优解。

~~为什么这题是黄题啊，妥妥大水题。~~

## 思路

发现 $k$ 的值域很小，考虑直接模拟。

这里要注意了：

> 如果某人的生日是 $2$ 月 $29$ 日，那么在非闰年中，他/她的生日将被视为 $2$ 月 $28$ 日进行计算。

那么我们直接使用[基姆拉尔森计算公式](https://baike.baidu.com/item/%E5%9F%BA%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/713396)进行计算就可以了。

基姆拉尔森计算公式：

$$W= (d+2m+\frac{3(m+1)}{5}+y+\frac{y}{4}-\frac{y}{100}+\frac{y}{400}) \bmod 7$$

其中，当 $W=0$ 时代表星期日，当 $W=1$ 时代表星期一，当 $W=2$ 时代表星期二，以此类推。若是一月份，则 $m=13$，若是二月份，则 $m=14$。

## 基姆拉尔森计算公式证明

令 $y$ 代表年份，$m$ 代表月份，$d$ 代表日期，$W$ 代表星期。

对于第一个月我们可以得出公式 $1$：
$$W = (d-1) \bmod 7$$

在不考虑闰年的情况下，一年 $365$ 天，$365 \bmod 7=1$，就是说一年的第一天和最后一天是相同的。

这就等价于，下一年的第一天星期几是会比这一年的最后一天多 $1$ 的。

所以我们可以完善公式 $1$，得出公式 $2$：

$$W = (d-1 + y) \bmod 7$$

接下来考虑闰年。因为闰年会多出来一天，所以相当于，计算当前年份前面有多少个闰年，将日期数 $w$ 额外多 $1$。

我们知道，计算闰年的公式为:

$$\frac{y}{4}-\frac{y}{100}+\frac{y}{400}$$


当计算结果为 $1$ 时，结合之前的公式 $1,2$，得出公式 $3$：

$$W = (d-1+y +\frac{y-1}{4}-\frac{y-1}{100}+\frac{y-1}{400}) \bmod 7 $$

对于其它月份，假设每个月都是 $28$ 天
因为 $28\bmod 7=0$，也就是说每个月的 $W$ 是相同的；
按正常月份计算的话，大月是 $31$ 天，比 $28$ 多  $3$ 天，也就是说，2月的 $w$ 值，是应该比 $1$ 月按 $28$ 计算的往后推迟 $3$ 天。以此类推。

因为 $12$ 月已是最后一个月，所以不用考虑 $12$ 月的误差天数，同理，$1$ 月份的误差天数是 $0$，因为前面没有月份影响它。

我们可以推出这样一个误差表：

|月份|误差|累积|$\bmod\ 7$|
|:-:|:-:|:-:|:-:|
|$1$|$3$|$0$|$0$|
|$2$|$0$|$3$|$3$|
|$3$|$3$|$3$|$3$|
|$4$|$2$|$6$|$6$|
|$5$|$3$|$8$|$1$|
|$6$|$2$|$11$|$4$|
|$7$|$3$|$13$|$6$|
|$8$|$3$|$16$|$2$|
|$9$|$2$|$19$|$5$|
|$10$|$3$|$21$|$0$|
|$11$|$2$|$24$|$3$|
|$12$|$-$|$26$|$5$|


如果用一个集合记录就是 $e=\{0,3,3,6,1,4,6,2,5,0,3,5\}$。

所以我们完善公式：

$$W = (d-1+y +e_{m-1}+\frac{y-1}{4}-\frac{y-1}{100}+\frac{y-1}{400}) \bmod 7 $$

如果是闰年的话，$2$ 月之后的都会顺移一天，即：

$$W = (d-1+y +e_{m-1}+\frac{y-1}{4}-\frac{y-1}{100}+\frac{y-1}{400}+1) \bmod 7 $$

以上为基本推导过程。

观察 $e$ 的规律我们对公式继续进行了优化（但是太难了，这里不做推导，可自己尝试）：


$$W= (d+2m+\frac{3(m+1)}{5}+y+\frac{y}{4}-\frac{y}{100}+\frac{y}{400}) \bmod 7$$

## 代码

注意没有符合的年份要输出 `No Answer`。


```cpp
#include<bits/stdc++.h>
using namespace std;
int m,d1,n,d2,k;
bool f=0;
int day(int y,int m,int d){
    if(m==2&&d==29&&!((y%4==0&&y%100!=0)||(y%400==0)))d=28;
    if(m<3)m+=12,y--;
    return (d+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7;
}
int main(){
    cin>>m>>d1>>n>>d2>>k;
    for(int y=2025;y<2025+k;y++){
    	if(day(y,m,d1)==day(y,n,d2)){
    		cout<<y<<endl;
    		f=1;
		}
	}
    if(!f)cout<<"No Answer";
    return 0;
}
```

都看到这里了，还不点个赞？

---

## 作者：Cake_W (赞：3)

# 洛谷P12843题解
[题目传送门](https://www.luogu.com.cn/problem/P12843)
## 思路
因为 $k$ 很小，所以我们可以直接从 $2025$ 年枚举至 $2025+k-1$ 年，依次判断这一年是否满足两人的生日在同一个星期几。需要注意的是，闰年的处理方式比较特殊：当在平年且某人生日是 $2$ 月 $29$ 日时，将此人的生日算作在 $2$ 月 $28$ 日。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,d1,n,d2,m;
bool f=0;
int months[]={31,28,31,30,31,30,31,31,30,31,30,31};//预处理每个月份的天数 
bool r(int i)//判断闰年 
{
	if(i%4==0)
	{
		if(i%100==0)
		{
		    if(i%400==0)
		    {
		        return true;
			}
		}
		else
		{
			return true;
		}
	}
	return false;
}
int day_x(int x,int y,int i)
{
	int day=0;
	if(r(i))
	{
		months[1]=29;//如果是闰年的话就把2月的天数改为29天 
	}
	else
	{
		months[1]=28;//注意，如果不是闰年，一定要把天数改回来
	}
	if(months[1]!=29&&x==2&&y==29)
	{
		y=28;//如果某人的生日是2月29日，那么在非闰年中，他/她的生日将被视为2月28日进行计算。 
	}
	for(int j=0;j<x-1;j++)
	{
		day+=months[j];//累加天数 
	}
	day+=y;//加上剩余的 
	return day;
}
int main()
{
	cin>>m>>d1>>n>>d2>>k;
	int xq=3;//2025年1月1日是星期三 
	for(int i=2025;i<=2025+k-1;i++)
	{
		int day_m=day_x(m,d1,i),day_n=day_x(n,d2,i);
		if((day_n+xq-1)%7==(day_m+xq-1)%7)//满足条件，输出 
		{
			cout<<i<<endl;
			f=1;
		}
		if(r(i))
		{
			xq=(xq+366)%7;//算出是今年是闰年的情况下，下一年是星期几 
		}
		else
		{
			xq=(xq+365)%7;//算出是今年是平年的情况下，下一年是星期几 
		}
	}
	if(!f)
	{
		cout<<"No Answer";
	}
	return 0;
} 
```

---

## 作者：IkillDream (赞：1)

# P12843 题解

## 思路

~~以为管理员大人以我没写思路打回了，所以我加了一下思路。~~

首先我们从 $2025$ 年枚举到 $2025+k-1$ 年，逐年检查，这样就能找到符合范围内的数了，但是要注意闰年的判断，最后只需要计算一下就好了。

## [AC](https://www.luogu.com.cn/record/220747715) 代码

```c++
#include<bits/stdc++.h>
using namespace std;
int main() {
    int m, d1, n, d2, k;
    cin >> m >> d1 >> n >> d2 >> k;
    int r[50] = {0};
    int c = 0;
    for (int y = 2025; y < 2025 + k; y++) {
        int td1 = d1, td2 = d2, tm1 = m, tm2 = n;
        if (tm1 == 2 && td1 == 29 && !((y % 400 == 0) || (y % 100 != 0 && y % 4 == 0))) {
            td1 = 28;
        }
        if (tm2 == 2 && td2 == 29 && !((y % 400 == 0) || (y % 100 != 0 && y % 4 == 0))) {
            td2 = 28;
        }//判断闰年
        int m1 = tm1, d1 = td1, y1 = y;
        if (m1 < 3) {
            m1 += 12;
            y1--;
        }
        int k1 = y1 % 100, j1 = y1 / 100;
        int h1 = (d1 + 13*(m1+1)/5 + k1 + k1/4 + j1/4 + 5*j1) % 7;
        int w1 = (h1 + 5) % 7 + 1, m2 = tm2, d2 = td2,y2 = y;
        if (m2 < 3) {
            m2 += 12;
            y2--;
        }
        int k2 = y2 % 100;
        int j2 = y2 / 100;
        int h2 = (d2 + 13*(m2+1)/5 + k2 + k2/4 + j2/4 + 5*j2) % 7;
        int w2 = (h2 + 5) % 7 + 1;
        if (w1 == w2) {
            r[c++] = y;
        }
    }
    if (c == 0) cout << "No Answer" << endl;
    else {
        for (int i = 0; i < c; i++) {
            cout << r[i] << endl;
        }
    }
    return 0;
}
```

因为这是一道模拟题，一般都很长，为了让大家看起来更方便我用 Deepseek 优化了以下格式。

---

## 作者：linhanmo (赞：1)

# 题解：P12843 [蓝桥杯 2025 国 A] 生日相遇问题

## 思路

原条件可化为天数之差 $\bmod\ 7=0$。

由于 $k$ 很小，枚举判断即可。

## 代码

注意看注释。


```
#include <stdio.h>

constexpr int s[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
// 12 个月天数的前缀和，后面用于计算

#define leap(x) ((x) % 4 == 0)
// 是否为闰年（因为 k 很小，不会让年份满足 mod 100 = 0 或 mod 400 = 0，所以简化判断）

#define day(m, d) (/* 距离年初的天数 */\
s[(m) - 1] /* 整月的天数 */ \
+ (m == 2 && d == 29 && !leap(y) ? 28 : d) /* 如果 2 月 29 日且平年，按 28 日计算，否则正常计算*/\
+ (leap(y) && m > 2)) /* 如果是闰年，比平年多 1 天 */

int m1, d1, m2, d2, k; bool fg;
int main(void) {
	scanf("%d %d %d %d %d", &m1, &d1, &m2, &d2, &k);
    for (int y = 2025; y < 2025 + k; ++y) // 遍历
        if ((day(m1, d1) - day(m2, d2)) % 7 == 0 /* 天数之差 mod 7 = 0 */ ) 
		    printf("%d\n", y), fg = true /* 打标记 */;
    if (!fg) printf("No Answer"); // 如果没有合法的，输出“No answer”
    return 0;
}
```

---

## 作者：0Io_oI0 (赞：1)

**题目大意：**

找出未来 $k$ 年内，小蓝和小乔的生日在同一星期几的所有年份。

大致思路就是，我们可以通过把两个日期与一个固定日期做差然后求出这两个差模 $7$ 是否同余，这里特别需要注意，我们需要处理闰年的特殊情况。

作者求的是两个日期到 $2025$ 年 $1$ 月 $1$ 日的天数差，具体的，大概实现步骤就是首先求出从这一天到目标年份的前一年的天数，然后求出从目标年份的第一天到目标月份的上一个月的天数，接着求出从目标月份的第一天到目标日那一天的天数，最后加在一起，就是总共隔了几天。

上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,d1,n,d2,k,month[15]={0,31,28,31,30,31,30,31,31,30,31,30,31};
vector<int>res;
bool check(int year){
    return (year%4==0&&year%100!=0)||(year%400==0);
}
int solve(int y,int m,int d){
    int sum=0;
    for(int i=2025;i<y;i++){
    	if(check(i))sum+=366;
    	else sum+=365;
    }
    if(check(y))month[2]=29;
    for(int i=1;i<m;i++)sum+=month[i];
    month[2]=28;
    sum+=d;
    return sum;
}
signed main(){
    cin>>m>>d1>>n>>d2>>k;
    for(int y=2025;y<2025+k;y++){
        int d1_=d1,d2_=d2;
        if(m==2&&d1==29&&!check(y))d1_=28;
        if(n==2&&d2==29&&!check(y))d2_=28;
        int day1=solve(y,m,d1_);
        int day2=solve(y,n,d2_);
        if((day1-day2)%7==0)res.push_back(y);
    }
    if(res.empty())puts("No Answer");
	else for(auto it:res)cout<<it<<'\n';
    return 0;
}
```

亲测可过，请勿抄袭。

---

## 作者：封禁用户 (赞：0)

# P12843 题解

## 思路

这题其实就是纯模拟，只需要考虑几种情况即可：

1. 判断是否是闰年。
2. 处理特殊日期。

最后循环枚举一便即可。

## [AC](https://www.luogu.com.cn/record/222798971) 代码

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    int m, d1, n, d2, k, year, month1, day1, month2, day2, temp_month1, temp_year1, k1, j1, h1, week1, temp_month2, temp_year2, k2, j2, h2, week2;
    bool bj, found = false;
    cin >> m >> d1 >> n >> d2 >> k;
    for (year = 2025; year < 2025 + k; year++) {
        bj = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
        month1 = m; day1 = d1; month2 = n; day2 = d2;
        if (month1 == 2 && day1 == 29 && !bj) day1 = 28;
        temp_month1 = month1; temp_year1 = year;
        if (temp_month1 < 3) { 
		    temp_month1 += 12; 
			temp_year1--; 
		}
        k1 = temp_year1 % 100; 
		j1 = temp_year1 / 100;
        h1 = (day1 + 13 * (temp_month1 + 1) / 5 + k1 + k1 / 4 + j1 / 4 + 5 * j1) % 7;
        week1 = (h1 + 5) % 7;
        if (month2 == 2 && day2 == 29 && !bj) day2 = 28;
        temp_month2 = month2; 
		temp_year2 = year;
        if (temp_month2 < 3) {
			temp_month2 += 12;
			temp_year2--; 
		}
        k2 = temp_year2 % 100; j2 = temp_year2 / 100;
        h2 = (day2 + 13 * (temp_month2 + 1) / 5 + k2 + k2 / 4 + j2 / 4 + 5 * j2) % 7;
        week2 = (h2 + 5) % 7;
        if (week1 == week2) {
			cout << year << endl;
			found = 1;
		}
    }
    if (!found) cout << "No Answer" << endl;
    return 0;
}
```

---

## 作者：Sakura_Emilia (赞：0)

# Solution

本题的核心思路是考察根据年月日得到星期几的计算公式。相关的变种公式有很多，但都大差不差，形式差不多。比如说 kimLarsen 公式、zeller 公式等等，随便用哪一个都可以。

然后就是简单的枚举遍历年份了，根据计算公式，判断该年份下两人的生日是否是同一个星期几。最后记得特判 $2$ 月 $29$ 日的情况和 No Answer 的情况即可。

Kim Larsen 算法是一种用于计算给定日期是星期几的高效方法。输入参数：年份 _y，月份 _m，日期 _d，如果月份是 $1$ 月或 $2$ 月，则将年份减 $1$，月份加 $12$（即视为上一年的 $13$ 月和 $14$ 月），之后完整的计算公式如下：

$$
week = \left(d + 2m + \left\lfloor \frac{3(m + 1)}{5} \right\rfloor + y + \left\lfloor \frac{y}{4} \right\rfloor - \left\lfloor \frac{y}{100} \right\rfloor + \left\lfloor \frac{y}{400} \right\rfloor \right) \bmod 7
$$

# Code

```cpp
#include <bits/stdc++.h>
#define Ciallo main
using namespace std;

int m, d1, n, d2, k, t1, t2;
bool flag;

int kimLarsen(int _y, int _m, int _d) {
    if(_m <= 2)
        _y--, _m += 12;
    return (_d + 2 * _m + 3 * (_m + 1) / 5 + _y + _y / 4 - _y / 100 + _y / 400) % 7;
}

bool isLeap(int _y) {
    return (_y % 4 == 0 && _y % 100 != 0 || _y % 400 == 0);
}

signed Ciallo() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);

    cin >> m >> d1 >> n >> d2 >> k;
    for(int y = 2025; y < 2025 + k; y++) {
        t1 = d1, t2 = d2;
        if(!isLeap(y)) {
            if(m == 2 and d1 == 29)
                t1 = 28;
            if(n == 2 and d2 == 29)
                t2 = 28;
        }
        if(kimLarsen(y, m, t1) == kimLarsen(y, n, t2))
            cout << y << endl, flag = true;
    }
    
    if(!flag)
        cout << "No Answer" << endl;

    return 0;
}
```

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P12843)

# 思路

## 分析

1. 需判断每个年份是否为闰年。
2. 使用 Zeller 公式计算给定日期的星期几（不懂的请看[百度](https://baike.baidu.com/item/%E8%94%A1%E5%8B%92%E5%85%AC%E5%BC%8F/10491767)）。
3. 特别地，若生日为 $2$ 月 $29$ 日，非闰年按 $2$ 月 $28$ 日计算。

### 判断闰年

这个都很熟悉，能被 $4$ 整除但不能被 $100$ 整除的年份或能被 $400$ 整除的年份是闰年。

### 每月的天数

小学就背过，非闰年 $2$ 月 $28$ 天，闰年 $2$ 月 $29$ 天，其他月份天数固定。

### 根据 Zeller 公式计算星期几

公式为：

$$h=\left ( q+\left \lfloor \frac{13\times \left ( m+1 \right ) }{5}  \right \rfloor +K+\left \lfloor \frac{K}{4}  \right \rfloor +\left \lfloor \frac{J}{4}  \right \rfloor -2\times J\right )\bmod 7  $$

其中：$h$ 为星期几（$0$ = 星期六，$1$ = 星期日，$\dots$，$6$ = 星期五）。$q$ 为日期，$m$ 为月份（$3$ = 三月，$4$ = 四月，$\dots$，$12$ = 十二月；$1$ 月和 $2$ 月视为上一年的 $13$ 月和 $14$ 月）。$K$ 为年份的后两位，$J$ 为年份的前两位。

# 代码

```cpp
#include<bits/stdc++.h>
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=3e4+5,mod=1e9+7,MOD=998244353;
bool isLeap(int y){// 判断是否为闰年
    return(y%4==0&&y%100!=0)||(y%400==0);
}
vector<int>day(int y){// 获取每月天数
    vector<int>d={0,31,28,31,30,31,30,31,31,30,31,30,31};
    if(isLeap(y))d[2]=29;
    return d;
}
int get(int y,int m,int d){// 计算星期几 (0=星期日)
    if(m<3){
        m+=12;
        y--;
    }
    int c=y/100;
    y%=100;
    int w=(c/4-2*c+y+y/4+13*(m+1)/5+d-1)%7;
    return(w+7)%7;
}
int m,d1,d2,n,k;
bool f=false;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>m>>d1>>n>>d2>>k;
    for(int y=2025;y<2025+k;y++){
        vector<int>days=day(y);
        int a1=d1,a2=d2;// 实际日期
        // 处理2月29日在非闰年的情况
        if(m==2&&d1==29&&!isLeap(y))a1=28;
        if(n==2&&d2==29&&!isLeap(y))a2=28;
        int w1=get(y,m,a1),w2=get(y,n,a2);
        if(w1==w2){
            cout<<y<<'\n';
            f=true;
        }
    }
    if(!f)cout<<"No Answer\n";
    return 0;
}
```

## 时间复杂度

应该是 $O\left ( k \right ) $，因为只需要遍历 $k$ 个年份。

[**AC 记录**](https://www.luogu.com.cn/record/221286015)

---

## 作者：封禁用户 (赞：0)

# [P12843 [蓝桥杯 2025 国 A] 生日相遇问题](https://www.luogu.com.cn/problem/P12843)
## 题目简介：
从 $2025$ 年开始，到 $2025 + k$ 年，俩人各有一个生日，求他们俩有多少次生日在同一个星期几的年份有哪些。

注意，生日是 $2$ 月 $29$ 的人，在平年时生日是 $2$ 月 $28$ 日。

## 分析做法：
**纯模拟**，很简单。

建两个函数，一个用来判断是否为闰年，另一个用来计算星期几，返回值从 $0$ 到 $6$。

特别注意，要用到泽勒公式来计算星期几。

函数：
1. 整除 $4$ 等于零，整百情况下整除 $400$ 等于零。
2. 先调整 $1$ 月和 $2$ 月，再求世纪部分的前两位数，然后求出年份后两位数，最后用泽勒公式求解星期几。

主函数：
1. 读取输入参数。

2. 遍历从 $2025$ 年到 $2025 + k - 1 $ 的每一年。

3. 处理 $2$ 月 $29$ 日在非闰年的情况。

4. 直接比较两个生日的星期几，如果相同则输出年份。

5. 判断有没有符合条件的年份。

奉上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
bool f(int year) {//判断闰年
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}
int date(int y, int m, int d) {//求解星期几
    if (m < 3) {
		y--;
		m += 12; 
	}
    int c = y / 100;
    y %= 100;
    int w = (d + 13 * (m + 1) / 5 + y + y / 4 + c / 4 + 5 * c) % 7;//泽勒(Zeller)公式
    return (w + 5) % 7;
}

signed main() {
    int m, d1, n, d2, k;
    cin >> m >> d1 >> n >> d2 >> k;
    bool found = false;
    for (int y = 2025; y < 2025 + k; y++) {
        int bd = d1, qd = d2;
        if (m == 2 && d1 == 29 && !f(y)) bd = 28;
        if (n == 2 && d2 == 29 && !f(y)) qd = 28;
        if (date(y, m, bd) == date(y, n, qd)) {
            cout << y << endl;
            found = true;
        }
    }
    if (!found) cout << "No Answer" << endl;
    return 0;
}
```
谢谢观看，求过求赞。

---

## 作者：cyngugugu (赞：0)

# 分析

没有什么严谨的分析，毕竟这题年份只有 $50$ 年，直接暴力把之后所有天的星期统计出来就可以了，最后不要忘了判无解。

# 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int N=10000;
const int M=1000000;
int f[60][15][34];
int mouth[15]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int fi(int a,int b,int c){
	if(c%4!=0&&a==2&&b==29)b=28;
	return f[c][a][b];
}
int main(){
	ios::sync_with_stdio(0);
	int now=2;
	fo(i,1,50){
		if(i%4==0)mouth[2]=29;
		else mouth[2]=28;
		fo(j,1,12){
			fo(k,1,mouth[j]){
				now++;
				if(now>7)now=1;
				f[i][j][k]=now;
			}
		}
	}
	int a,b,c,d,e;
	cin>>a>>b>>c>>d>>e;
	bool flag=0;
	fo(i,1,e){
		if(fi(a,b,i)==fi(c,d,i)){
			cout<<i+2024<<endl;
			flag=1;
		}
	}
	if(flag==0)cout<<"No Answer"<<endl;
	return 0;
}
```

---

## 作者：iChen (赞：0)

题意很好理解。  
其实这道题就纯大模拟吧 @-@。  

在每一年中干如下几件事：

- 闰年判断：根据规则判断某年是否为闰年（年份能被 $4$ 整除但不能被 $100$ 整除，或能被 $400$ 整除）。

- 计算一年中的第几天（doy）：对于给定的日期，计算它在该年中是第几天，注意处理 $2$ 月 $29$ 日在非闰年的情况（视为 $2$ 月 $28$ 日）。

- 星期递推：从 $2025$ 年 $1$ 月 $1$ 日为星期三开始，递推每年 $1$ 月 $1$ 日的星期几。平年下一年 $1$ 月 $1$ 日星期数增加 $1$（$365$ 对 $7$ 取模为 $1$），闰年增加 $2$（$366$ 对 $7$ 取模为 $2$）。

- 比较生日的星期几：对于每一年，计算小蓝和小乔生日的星期几，如果相同则记录该年份。


Code：

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int N = 1e5;
int m, d1, n, d2, k;
int ans[N];
int idx;

inline bool isleap (int year) {
    return (!(year % 4) and year % 100) or (!(year % 400));
}
int getdoy(int month, int day, int year) {
    int months[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    // 每个月的天数 
    if (isleap(year)) months[1] = 29;
    else months[1] = 28;
    if (month == 2 and day == 29 and !isleap(year)) {
    	// 特判 2 月 29 日 
        day = 28;
    }
    int doy = 0;
    for (int i = 0; i <= month - 2; i++) {
        doy += months[i];
    }
    doy += day;
    return doy;
}

int main() {
    cin >> m >> d1 >> n >> d2 >> k;
    int st = 2025;
    int en = st + k;
    int now = 3; // 2025 年 1 月 1 日是星期三
    for (int year = st; year < en; year++) {
        int doy1 = getdoy(m, d1, year);
        int w1 = (now + doy1 - 1) % 7;
        int doy2 = getdoy(n, d2, year);
        int w2 = (now + doy2 - 1) % 7;
        
        if (w1 == w2) {
            ans[++ idx] = year;
        } if (isleap(year)) {
            now = (now + 366) % 7;
        } else {
            now = (now + 365) % 7;
        }
    }
    if (idx == 0) {
    	cout << "No Answer";
    } else {
        for (int i = 1; i <= idx; i ++) {
            cout << ans[i] << '\n';
        }
    }
    return 0;
}
```

---


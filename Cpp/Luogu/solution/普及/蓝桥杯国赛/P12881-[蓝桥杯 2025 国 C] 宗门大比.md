# [蓝桥杯 2025 国 C] 宗门大比

## 题目描述

小蓝所在宗门准备进行宗门大比，共有 $n$ 名弟子参与，从左到右站成一排。第 $i$ 名弟子的功力值为 $a_i$，小蓝是第 $k$ 名弟子。宗门大比将举行 $m$ 次切磋，每次切磋由两名弟子进行，其中功力值高的弟子将获胜，功力值低的弟子的功力值将减 $1$。如果切磋的两名弟子功力值相同则平局，切磋后两名弟子的功力值保持不变。同一名弟子可能参与多次切磋，也可能一次都不参与。一名弟子可以和多名弟子切磋，两人也可以进行多次切磋。

切磋结束后，弟子们将按照功力值从高到低的顺序进入藏宝阁进行功法挑选，功力值相同的弟子按初始站位靠左的优先。小蓝想知道，如果他能规定每次切磋的人选，他在最优情况下能第几个进入藏宝阁？

## 说明/提示

**【样例说明】**

其中一种方案：第一次切磋 $(a_1, a_4)$，第二次切磋 $(a_1, a_6)$，最终功力值分别为 $4, 5, 5, 6, 3, 1$，小蓝 $a_2 = 5$ 排第二。

**【评测用例规模与约定】**

对于 $40\%$ 的评测用例，$2 \leq n \leq 100$；

对于所有评测用例，$2 \leq n \leq 500000$，$1 \leq a_i \leq 1000$，$1 \leq k, m \leq n$。

## 样例 #1

### 输入

```
6 2 2
5 5 5 6 3 2```

### 输出

```
2```

# 题解

## 作者：leo_hrl (赞：5)

对题目进行分析，得题目：  
给定一个序列，每一次可以选定其中两个元素，其中唯一最小的元素减 $1$ ，总共可以进行 $m$ 次该操作，问 $m$ 次操作后，数组第 $k$ 个元素最低是从大到小的第几个元素（大小相同按初始顺序排序）。  

---
再次进行化简，得：  
给定一个序列，你可以进行 $m$ 次操作，每次可以是一个非最大值的数减 $1$ （只要是最大值，就没有人可以使它减 $1$ ，否则总有最大值比它大），问 $m$ 次操作后，数组第 $k$ 个元素最低是从大到小的第几个元素（大小相同按初始顺序排序）。  

---
我们可以将所有比第 $k$ 个的大的数和和第 $k$ 个数相等但比第 $k$ 个数更靠前的数需要减 $1$ 的次数，存进一个数组里，并使答案加 $1$ （注：最大值可以不放到数组里，少一个特判，但答案仍然要加 $1$ ，答案变量的初始值为 $1$ ）。然后从小到大排序，计算如果剩余可用的次数 $\ge$ 遍历到的这个数，则答案减 $1$ （可以把这个人降到我的后面，排名就更靠前了一个），如果已经小于了，退出循环并输出答案。（因为之前已经从小到大排了序）。

---
## 代码：
```.cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;//std命名空间
int n,m,k,a[500005],ans=1,mx=0,arr[500005],cnt=0;//所需要的数组和变量 ， n m k a 和题目意思相同 ，mx储存最大值，arr储存比第k个靠前的数降到k的后面所需的次数，cnt是arr数组的长度
void add(int x){//将数x添加至arr数组的最后端
	arr[++cnt]=x;
}
int main(){
	cin>>n>>m>>k;//输入n,m,k
	for(int i=1;i<=n;i++) cin>>a[i],mx=max(mx,a[i]);//输入a[i]的同时求mx
	for(int i=1;i<=n;i++){//从1遍历到n，看每一个数是否比第k个靠前
		if(i!=k){//如果为k就没必要讨论，虽然讨论了也没关系，但要有好的习惯
			if(a[i]>a[k]||a[i]==a[k]&&i<k){//如果a[i]比a[k]大或a[i]与a[k]相等但i在k的前面，普及一下，逻辑或的优先级小于逻辑与的优先级
				if(a[i]!=mx) add(a[i]-a[k]+(i<k));//如果a[i]不是最大值，它就属于可以被减少的，加入数组。
				ans++;//只要满足条件，不论小蓝可不可以超过，小兰的排名都应该先降低一位
			}
		}
	}
	sort(arr+1,arr+cnt+1);//对小蓝需要超过前面的人所需的次数排序，这样就可以保证为最优解。普及，sort函数不写判断默认从小到大
	for(int i=1;i<=cnt;i++){//遍历arr数组
		int x=arr[i];//找出小蓝想要超过这个人需要进行多少次操作
		if(m>=x) m-=x,ans--;//剩余操作次数大于等于需要的次数，超过它
		else break;//这个都超过不了，后面的都是更多的，更超过不了了
	}
	cout<<ans<<endl;//输出答案
	return 0;
} 
```

---

## 作者：beicige (赞：3)

# 题意
给出 $n$ 名弟子及其功力值，并根据功力值排名。若功力值更高，或功力值相等且站位更靠前，则排名更优先。

可以通过 $m$ 次切磋，将功力值高与低的弟子切磋，降低功力值低的弟子的功力值。求出第 $k$ 名弟子小蓝的最优先名次。

# 思路
只有通过降低他人的功力值才能提高自己的排名，要用有限的切磋次数，降低尽可能多比小蓝优先的人的功力值。

计算出每一个比小蓝优先的弟子，使他们低于小蓝所需的切磋次数。

然后对所有值进行从小到大排序，优先降低所需次数小的弟子。计算出 $m$ 的值足够降低的弟子数量。

注意**如果功力值比小蓝大但站位在小蓝右侧，只需要降低至与小蓝相同即可**。因为在功力值相同时，站位靠左优先级更高。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,a[500010],ma=0,t[500010],x,sum,cnt;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		ma=max(ma,a[i]);
	}	//读入并记录最大功力值 
	for(int i=1;i<=n;i++){
		if(a[i]>a[k]||(i<k&&a[i]==a[k])){//排名在小蓝前 
			cnt++;//人数增加 
			if(a[i]!=ma) t[i]=a[i]-a[k]+(i<k);//若功力值不为最大，即可以通过切磋降低功力值，则记录所需切磋次数 
		}								//若i<k，即处于小蓝左侧，需要多降低一点功力值。否则只需降低至与小蓝相同即可 
		if(t[i]==0) t[i]=INT_MAX;//若未被记录所需切磋次数，则设为最大值，便于排序和计算 
	}
	sort(t+1,t+n+1);//对所需功力值排序 
	for(int i=1;i<=n;i++){
		if(t[i]==INT_MAX) break;//若没有排名可以降低至小蓝后的人，则退出 
		if(sum+t[i]<=m){
			sum+=t[i];
			cnt--;
		}
	}
	cout<<cnt+1;//排名比自身高的人数+1即为排名 
	return 0;
}
```

---

## 作者：hwh_qwq (赞：2)

我们想要让小蓝最后的排名靠前，就需要让其他弟子的功力值尽可能下降，而每次切磋可以让一个弟子的功力值减 $1$（除了功力值最大的弟子）。

可以预处理出小蓝的初始排名，以及每个排名比小蓝靠前且功力值不是最大的弟子分别需要多少次切磋才能让他的排名降低到比小蓝低。题目中提到，功力值相同的弟子按初始站位排名，所以每个在小蓝左边的弟子都需要多切磋一次。

然后，就变成了一个经典的贪心问题，我们优先让消耗切磋次数少的弟子进行切磋，当剩余切磋次数不足以让任何一位弟子的排名降低到比小蓝低时结束。

```
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,k,a[500001],t[500001],tot;
int main(){
	cin>>n>>m>>k;
	int maxx=0,ans=1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]>maxx) maxx=a[i];
	}
	for(int i=1;i<=n;i++){
		if(i==k) continue;
		if(a[i]==maxx){//功力值最大的弟子功力值无法降低
			if(a[k]==maxx&&i<k||a[k]!=maxx) ans++;//注意这些弟子如果排名比小蓝高也要记录
			continue;
		}
		if(i<k) a[i]++;//站位比小蓝靠左，需要多进行一次切磋
		if(a[i]-a[k]>0){
			ans++;
			t[++tot]=a[i]-a[k];
		}
	}
	sort(t+1,t+tot+1);//按需要切磋的次数从小到大进行切磋
	for(int i=1;i<=tot;i++){
		if(m<t[i]) break;
		else{
			m-=t[i];
			ans--;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：lmz105 (赞：2)

### 思路
这题可以分为两种情况讨论：

- 小蓝的功力值是 $n$ 名弟子中最大的，找出前 $k$ 名弟子中有多少弟子的功力值等于小蓝的功力值，这个值就是答案。
- 小蓝的功力值不是 $n$ 名弟子中最大的，令 $ans=n$，然后遍历每个弟子的功力值，如果这个弟子的功力值小于小蓝的功力值，$ans$ 就减一，否则判断这个弟子的功力值是不是最大的，是的话直接跳过，不是的话就算出他要和功力值最大的弟子切磋多少次才能让他排名低于小蓝，并把这个值记录下来，遍历完后，将记录下来的值从小到大排序，每次用最少的切磋次数来让 $ans$ 减一才能让 $m$ 次切磋提升的排名最多，最后算出的 $ans$ 是排名在小蓝前面的弟子个数，$ans+1$ 才是小蓝的排名。

### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define rw() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#ifndef rw()
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif

namespace Pv {
	template<typename T> inline void r(T &in) {
		in = 0;
		bool bo = 0;
		char ch = getchar();
		while (!isdigit(ch))
			bo ^= (ch == '-'), ch = getchar();
		while (isdigit(ch))
			in = (in << 1) + (in << 3) + (ch ^ 48), ch = getchar();
		if (bo)
			in = -in;
	}
	template<typename T> inline void w(T out) {
		static char op[25];
		int top = 0;
		if (out < 0) {
			putchar('-');
			do {
				op[++top] = -(out % 10) + 48, out /= 10;
			} while (out);
		} else {
			do {
				op[++top] = out % 10 + 48, out /= 10;
			} while (out);
		}
		while (top)
			putchar(op[top--]);
		putchar('\n');
	}
	template<typename T, typename... Ts> inline void r(T &in, Ts &... ins) {
		r(in), r(ins...);
	}
	template<typename T, typename... Ts> inline void w(T out, Ts... outs) {
		w(out), w(outs...);
	}
	inline void w(const char *p) {
		while (*p) {
			putchar(*p++);
		}
	}
}
#undef getchar
#undef putchar
using namespace Pv;
#endif
using namespace std;
const ll N=5e5+6;
ll n,m,k,a[N],num,ans,maxx;
priority_queue<ll,vector<ll>,greater<ll> >q;
int main(){
	r(n,m,k);
	for (ll i=1;i<=n;i++){
		r(a[i]);
		maxx=max(maxx,a[i]);
	}
	if (a[k]==maxx){
		for (ll i=1;i<=k;i++){
			ans+=(a[i]==maxx);
		}
		w(ans);
		return 0;
	}
	ans=n;
	for (ll i=1;i<=n;i++){
		if (a[i]<a[k]){
			ans--;
		}else if (a[i]!=maxx){
			q.push(a[i]-a[k]+(i<k));
		}
	}
	while(q.size()){
		if (m<q.top()){
			break;
		}
		m-=q.top();
		q.pop();
		ans--;
	}
	w(ans+1);
	return 0;
}
```

### 时间复杂度
$O(n \log n)$

---

## 作者：Circle_Table (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12881)

题意简述：给定的 $n$ 个正整数 $a_1,a_2,⋯,a_n$ 中，进行 $m$ 此操作，每次可以将不超过它们最大值的任意一个整数的值减一，然后令 $a_k$ 的排名尽可能靠前。

然后观察样例。样例中小蓝的功力值为 $5$ 点，由于存在 $a_4=6$ 是最大值，**最大值无论如何切磋都不会输**，因此最后小蓝只能排第二。

可以看出，最大值是不会变的，所以如果小蓝就是那个最大值，即当 $a_k=a_{max}$ 时直接输出他左边与他同功力的人数即可（至于为什么不是 $1$ 在后文有提到）。  
若小蓝不是最大值，就让最大值和比小蓝强的进行切磋，从而使得小蓝的排名尽可能靠前。这个过程当然优先选择功力值与小蓝尽可能接近的，所以计算每一个人直到小蓝成为第二名或者 $m=0$ 时停止。

---

然而以上是在洛谷评测judging的时候写的，但是 judging 完后才发现事情不对劲，因为细节太多了，[错了好多次](https://www.luogu.com.cn/record/list?pid=P12881&user=Circle_Table&page=1)之后在 ImposterAnYu 大佬的帮助下通过了（另还感谢大佬 lrqcs 提供 hack 数据），拜谢。  
我也就总结一下这个题的细节吧。  
第一，做的时候要多斟酌一下什么时候算小蓝自己，什么时候不算的情况；  
第二，在小蓝左边的与他同功力的最后会排在其前面，所以在他左边的弟子就需要多消耗一次切磋才可以使得小蓝超过他；  
第三，小蓝功力最高时，说不定有与他同功力的，因此不是直接输出 $1$ 而应该输出他左边与他同功力的人数，右边的当然是不用管的。

还有别的小细节，也就只能说这题细节真多了。
## 代码如下

```cpp
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio,cin.tie(0),cout.tie(0)
using namespace std;
int n,m,k,x;
int a[500005];
int ans=1;//排名包括他自己
vector<int> v;//存储比小蓝功力高的弟子 
int main() {
	ios;cin>>n>>m>>k;
	int maxn=0;
	for(int i=1;i<=n;i++){	
		cin>>a[i];
		maxn=max(maxn,a[i]);//记录最大功力
	}
	x=a[k]; //小蓝的功力值
	
	//收集功力大于等于小蓝的弟子
	//并计算将其将至低于小蓝的切磋次数 
	for(int i=1;i<=n;i++){
		if(i==k)continue;//已经算过自己了，这回就别把自己算进去了
		if(a[i]==maxn&&(x!=maxn||i<k)){//功力最大的弟子无法被减功力
			ans++;//但有个特殊情况：小蓝功力最大且右边有同功力的人时，不用算答案
			continue;
		}
		if(i<k)a[i]++;//如果在小蓝左边则要多减一次 
		if(a[i]>x)v.push_back(a[i]);
	}
	
	//如果小蓝功力最高，直接输出和他同功力的人数
	if(v.empty()){
		cout<<ans;
		return 0;
	}
	//将功力比小蓝高的排序 
	sort(v.begin(),v.end());//从小到大排，因为要贪心，先把小的减到比小蓝小
	//这样能尽可能多的把其他弟子的功力降到排在小蓝后面
	//求能将多少人功力值降到比小蓝低,当然不用算最大值 
	//此时是相同即可因为在前面已经a[i]++了 
	ans+=v.size();
	for(int i=0;i<v.size();i++){
		if(m<v[i]-x){//k是下标，x才是小蓝的功力……
			break;
		}
		m-=v[i]-x;
		ans--;
	}
	cout<<ans;
}
```
感谢阅读~

---

## 作者：shentianxing (赞：1)

[原题](https://www.luogu.com.cn/problem/P12881)

回归后第一篇题解。这题就是贪心，但细节比较多。

排除特殊情况，每次我们让最厉害的弟子和别人比试。小蓝不用比试，因为输了降功力，赢了和他也没关系。

先计算小蓝的初始排名，是比他厉害的弟子数量加上排在他前面的同级弟子数量加上 $1$。为了特殊情况，我们需要计算最厉害的弟子的功力值。

因为排在小蓝前面且比小蓝厉害的弟子需要比排在小蓝后面但比小蓝厉害的弟子多费一场比试，给这些弟子加一点功力值。

先考虑排在小蓝前面的同级弟子，每个人需要一场比试降级。同时排名更新。

保存小蓝的功力 $l$，然后给数组排序，因为优先考虑较低功力的弟子，如果弟子 $a_i$ 比小蓝厉害，需要 $a_i - l$ 次比试将其排名降到小蓝下面。同时排名更新。以上过程中，当比赛次数用完，结束比试。

还有特殊情况，如果小蓝是最大值，输出最初排名即可。如果处理比小蓝功力高的弟子时，该弟子如果是最强的，不要比试。这些可能导致 $70$ 分和 $85$ 分。\
注意，最大值要在给某些弟子加 $1$ 后计算。如果不是，可能导致 $95$ 分。

最后完整 AC 代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int ans=1;
signed main(){
	int n,m,k;cin>>n>>m>>k;k--;
	int a[n],b[n];int maxn=-INT_MAX;
	for(int i=0;i<n;i++){
		cin>>a[i];
	} 
	int l=a[k];
	for(int i=0;i<n;i++){
		if((i<k&&a[i]==a[k])||a[i]>a[k]){
			ans++;
		}
		
	}
	for(int i=0;i<k;i++){
		if(a[i]>a[k]){
			a[i]++;
		}
	}
	for(int i=0;i<n;i++){
		maxn=max(maxn,a[i]); 
	}
	for(int i=0;i<k;i++){
		if(a[i]==a[k]&&m>0&&a[i]<maxn){
			ans--;
			m--;
		}
	}
	sort(a,a+n);
	for(int i=0;i<n;i++){
		if(a[i]>l&&m>=a[i]-l&&a[i]<maxn){
			m-=a[i]-l;
			ans--;
		} 
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：1)

一眼贪心，但是细节处理比较复杂。

首先将数组排序。以功力值为第一关键字降序排序，再以出现位置为第二关键字升序排序，因为题目提到“功力值相同的弟子按初始站位靠左的优先”，所以要把出现位置大的放到后面才能更好地替代。

接下来考虑如何让小蓝替代他前面的人的位置。小蓝肯定不能切磋，因为他切磋不过比他厉害的人，跟比他弱的人切磋也没有用处。考虑让最厉害的人和小蓝前面的那一个人切磋。如果小蓝前面的那个人的原位置在他右边，那么只需把他的功力值降到和小蓝一样即可。如果原位置在他左边，那么需要把他的功力值降到比小蓝低，因为“功力值相同的弟子按初始站位靠左的优先”。

如果小蓝替代到某个位置（或没有替代）时，前面的人的功力值均相同，那么前面的人的功力值就再也不会减少了，此时的位置就是最优位置。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{
	int num,id;
}a[500005];
bool cmp(node x,node y)
{
	if(x.num!=y.num) return x.num>y.num;
	return x.id<y.id;
}
signed main()
{
	int n,m,k;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].num;
		a[i].id=i;
	}
	int p=0;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
		if(a[i].id==k)
		{
			p=i;
			break;
		}
	int flag=0;
	for(int i=2;i<p;i++)
		if(a[i].num!=a[i-1].num)
		{
			flag=i-1;
			break;
		}
	if(!flag)
	{
		cout<<p;
		return 0;
	}
	int ans=p;
	for(int i=p-1;i>flag;i--)
	{
		if(m>=a[i].num-a[p].num+(a[i].id<a[p].id))
		{
			m-=(a[i].num-a[p].num+(a[i].id<a[p].id));
			ans=i;
		}
		else break;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Lacuna (赞：1)

### 思路：

我们先考虑谁要被削弱：

- 本身比小蓝强的人。

- 和小蓝实力相等但站位更靠左的人。

将这些人需要削弱的值加入一个数组中，需要注意，站位比小蓝靠左的人需要削弱到比他小一，站位在他右边的人只要削弱到和他相等。从小到大排序，然后看看最多能削弱多少个人。

再考虑没法削弱的情况，若这个人是这里面最强的人，那无论如何都打不过，所以若这个人的实力等于最大值就将排名加一，在代码中用一个 $cnt$ 统计。

若小蓝是最强的，那么只要统计有多少在他左边的人可以和他打平手就行。

注意，不存在第 $0$ 名，所以答案都要加一。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define gc getchar
#define pb push_back
template<typename T>inline void read(T&x){x=0;int f=1;char ch=gc();while(!isdigit(ch)){if(ch=='-') f=-1;ch=gc();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=gc();}x*=f;}
template<typename T,typename ...T1>inline void read(T&x,T1&...x1){read(x);read(x1...);}
int n,m,k,maxn,cnt;
const int ri=5e5+5;
int main(){
    read(n,m,k);
    vector<int> a(n+1),q;
	for(int i=1;i<=n;i++){
	  read(a[i]);
	  maxn=max(maxn,a[i]);
    }
    if(a[k]==maxn){
      for(int i=1;i<k;i++)
        if(a[i]==a[k]) cnt++;
      printf("%d\n",cnt+1),exit(0);
	}
	for(int i=1;i<=n;i++){
	  if(a[i]==maxn){cnt++;continue;}
	  if(i<k&&a[i]>=a[k]) q.pb(a[i]-a[k]+1);
	  if(i>k&&a[i]>a[k]) q.pb(a[i]-a[k]); 
	}
	int s=q.size();
	//cout<<s<<endl;
	sort(q.begin(),q.end());
	for(int i=0;i<q.size();i++){
	  //cout<<q[i]<<endl;
	  if(m>=q[i]) m-=q[i],s-=1;
	  else break;
    }
	printf("%d\n",s+1+cnt);
    return 0;
}
```

---

## 作者：YBa2Cu3O7 (赞：1)

排序贪心

## 思路
全部扫一遍得到最大值和最大值的个数，如果本身就是最大值那么只需要重新统计自身是第几个最大值，反之利用最大值去削弱其他人。

因为相同的值会按从左到右的顺序去排，所以如果想要超越自身左侧的，需要额外减一，而右侧的只需要减到与自身相等。将这些差值从小到大排序，最大小于等于 $m$ 的那个前缀就是可以超越的人数。

## 代码
要注意最大值之间是没法互相减小的，以及最大值是无法超越的。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n,m,k;
    cin>>n>>m>>k;
    --k;
    vector<int> vp(n);
    int mmax=0;
    int maxcnt=1;
    for(int i=0;i<n;++i){
        cin>>vp[i];
        if(mmax<vp[i]){
            mmax=vp[i];
            maxcnt=1;
        }
        else if(mmax==vp[i]){
            ++maxcnt;
        }
    }
    
    int kval=vp[k];
    if(mmax==kval){
        int ans=1;
        for(int i=0;i<k;++i){
            if(mmax==vp[i]){
                ++ans;
            }
        }
        cout<<ans;
        return 0;
    }
    
    vector<int> vs;
    for(int i=0;i<k;++i){
        if(vp[i]>=kval&&vp[i]!=mmax){
            vs.emplace_back(vp[i]-kval+1);
        }
    }
    for(int i=k+1;i<n;++i){
        if(vp[i]>kval&&vp[i]!=mmax){
            vs.emplace_back(vp[i]-kval);
        }
    }
    sort(vs.begin(),vs.end());
    int i;
    for(i=0;i<vs.size();++i){
        if(m>=vs[i]){
            m-=vs[i];
        }
        else{
            break;
        }
    }
    cout << maxcnt + (vs.size() - i) + 1;

    return 0;
}
```

---


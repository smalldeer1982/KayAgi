# [蓝桥杯 2013 国 B] 格子刷油漆

## 题目描述

X 国的一段古城墙的顶端可以看成 $2 \times N$ 个格子组成的矩形（如图 $1$ 所示），现需要把这些格子刷上保护漆。

![](https://cdn.luogu.com.cn/upload/image_hosting/k52ovrzc.png)

你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）

比如：`adbcef` 就是合格的刷漆顺序。

`cefdab` 是另一种合适的方案。

当已知 $N$ 时，求总的方案数。当 $N$ 较大时，结果会迅速增大，请把结果对 $1000000007(10^9+7)$ 取模。

## 说明/提示

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
2```

### 输出

```
24```

## 样例 #2

### 输入

```
3```

### 输出

```
96```

## 样例 #3

### 输入

```
22```

### 输出

```
359635897```

# 题解

## 作者：fish_gugu (赞：12)

### [题目传送门](https://www.luogu.com.cn/problem/P8607)

### 警告：本题解较长，建议前往[博客](https://www.luogu.com.cn/blog/a1-l2-a3-n4/)食用

## 思路
本题的实质是在已知几个基本行走规则的前提下，求解遍历整个矩形的行走路线数量。

很多同学的第一想法是搜索，但在本题 $n$ 最大可取到 $1000$ 的前提下，搜索必然超时（递归层次太深），因此我们不得不另辟蹊径。从题目的描述来看，这道题也更像是一道**动态规划**的题目。

对于题目给出的几类行走规则，我们可以很容易地联想到递推。因为对于某个格子，其走到当前可能有很多种走法，但是从另一个角度看来，以某个格子为出发点进行“刷漆”，其行走方式却是固定的。我们首先要做的，就是来分析这个过程，并找到动态转移方程。对城墙刷漆时，我们的起点主要分为以下两大类：

1. 从四个顶点之一出发。
2. 从中间某个点出发。

下面给出了两类的分析：


------------

### 1. 从四个顶点出发

统一附图：![](https://cdn.luogu.com.cn/upload/image_hosting/0gfg9sqe.png)

在此前提下，又可分为3小类行走方式：

- 第一步走同一列的另一个格子，第二步走下一列的任意格子……如此循环直到走完所有列。
- 第一步走下一列的任意格子，第二步再走下一列的任意格子……如此行走直到最后一列。返回时路径唯一。
- 第一步走下一列的任意格子，第二步由该格子返回前一列剩下的尚未走的格子，第三步再来到前一步所在列剩下的尚未走的格子……如此循环直到走完所有列。

下面对这些小类进行进一步分析：

1. 现假设初始情况下从顶点 A 出发。根据描述，第一步应该走向 B。接下来在 B 点时就有两种选择方案：要么走向 C；要么走向 D。而无论选择走哪一点，接下来的情形都将回到初始情况：“从某个顶点出发，走完一个 $m \times 2$ 的格子（这里的 $m$ 自然取 $n - 1$）”。如果我们将这种“一趟过去，不再返回”的行走方式用数组 $a$ 来表示，则从上面的分析可知，它存在一个递推关系，即：

$$ a[i] = 2 \times a[i - 1]$$

2. 现假设初始情况下从顶点A出发。根据描述，第一步可以选C或D作为接下来的落点（假设我们选的是C）；那么接下来又可以选择E或F作为第二步的落点（假设我们选的是E）……当走到最后一列（假设最后一列的落点为I），此时返回的路线也被唯一确定了。如果我们将这种“一趟过去，一趟回来”的行走方式用数组 $b$ 来表示，则从上面的分析可知，它存在一个递推关系，即：

$$ b[i] = 2 \times b[i - 1]$$

3. 现假设初始情况下从顶点 A 出发。根据描述，第一步有两条路线： A→C→B→D 或 A→D→B→C，假设最终落点为 D，则在 D 时将面临两种选择，要么到 E 要么到 F），而无论选择哪一点，接下来都将回到初始情况：“从某个顶点出发，走完一个 $m \times 2$ 的格子（这里的 $m$ 自然取 $n - 2$）。该走法也属于“一趟过去，不再返回”的类型，因此这里依然用数组 $a$ 来表示。但是注意到一点：这种行走方式从一种状态到下一种状态需要的最小行走次数为 $2$，因此其状态转移方程为：

$$ a[i] = 2 \times 2 \times a[i - 2] = 4 \times a[i - 2]$$

以上便是从顶点出发刷完所有墙面的全部行走方式。但需要注意的是，在实际刷墙时，这些行走方式可以任意组合，而不仅仅是单一化的。比如，可以先用方法一走一段，再用方法二走另一段；或者先用方法三走一段，再用方法一走一段，再用方法二走最后一段……这些组合方式是不胜枚举的。因此在进行状态转移的时候，我们需要将上面这三种情况都加到一起。在这样的前提下，我们可以直接将 $a$ 数组的含义赋予为“从墙壁顶点处出发，刷完整面墙的方案数”，于是可以得到新的状态转移方程为：

$$a[i] = 2 \times a[i - 1] + b[i] + 4 \times a[i - 2]$$

对于“一趟过去，一趟返回”的走法而言，他是独特的，因为他的遍历路径不能插入其他任何遍历方式：其只有两趟，一趟必须到底，另一趟则走剩余路径。因此他的走法在迭代时，与其他走法（方法一、方法三）没有任何关系，而仅仅取决于其前一种状态。所以它的状态转移方程为：

$$b[i] = 2 \times b[i - 1]$$

注：由于从顶点出发时有 $4$ 个顶点，因此最后的结果实际上是 $4 \times a[n]$。

------------

### 2.从中间出发

统一附图：![](https://cdn.luogu.com.cn/upload/image_hosting/0gfg9sqe.png)

由于墙的高度为 $2$ 且不能走已经刷过的点，因此从中间某个点出发时必然是先刷该点的某一边，然后再倒回来刷该点的另一边。见下图，假设我们从图中 $i = 3$（E 点）处出发（以 $i = 3$ 为分割线，将图分为左边的 ABCDEF 以及右边的 GHIJ），为了遍历所有格子，我们必须先走完左边的 ABCDEF 才能继续走右边的 GHIJ（注意：出发点为 E 时，回来的终点必须是 F），然后再把右边的 GHIJ 视为以 G（或 H）为起点的一组格子，并将其走完（因此这里有两个出发点，所以需要乘以 $2$）。

在上面的遍历过程中，当从 E 点出发并往左边走时，由于其必须返回到 $i = 3$ 列的 F 点，因此属于“一趟过去，一趟回来”的类型。在左边长度为 $i = 3$ 时，左边的遍历方式就有 $b[i] $ 种；当从 F 出发时，由于其有两个落点（G 或 H），因此这里要乘以 $2$。接下来，无论在哪一个点出发，此时既可以选择“一趟过去，一趟回来”，也可以选择“一趟过去，不再返回”，还可以选择两者的任意合法组合。总之，就是前面我们已经修改后的 $a$ 数组（从墙壁顶点处出发，刷完整面墙的方案数）。于是，可以得到整个右边的行走方式有 $2 \times a[n - i]$ 种。于是，可以得到从E点出发先往左侧移动时，总的刷漆方式有 $b[i] \times 2 \times a[n - i]$ 种。此外，一开始时，我们还可以选择从 F 点出发，然后回到 E 点，所以这里还需要再乘以 $2$，即：

$$2 \times b[i] \times 2 \times a[n - i] = 4 \times b[i] \times a[n - i]$$

还有一种情况，当我们从E出发时先往右边 EFGHIJ 走（最终返回至F点），这时，该部分的遍历方案就有 $b[n - i + 1]$ 种；接下来对于左边的 ABCD，同样是“从墙壁顶点处出发，刷完整面墙的方案数”这一方式，即 $2 \times a[i - 1]$ 种（这里乘以 $2$ 依然是因为在 ABCD 部分，其出发点可以选择 C 或者 D）。于是，可得到总的刷漆方式为 $b[n - i + 1] \times 2 \times a[i - 1]$ 种。同样地，这里一开始的出发点可以选E也可以选F，所以上述方案最终还要乘以 $2$，即：

$$2 \times b[n - i + 1] \times 2 \times a[i - 1] = 4 \times b[n - i + 1] \times a[i - 1]$$

综上所述，可得到从中间出发的总方案数为：

$$4 \times (b[i] \times a[n - i] + b[n - i + 1] \times a[i - 1])$$


------------

### 汇总
综合方案一、方案二可以得到的最终方案数为：

$$ sum = 4 \times a[n] + 4 \times (b[i] \times a[n - i] + b[n - i + 1] \times a[i - 1])$$

下面我们来确定初值。在上面的所有相关公式中，存在的有 $a[i - 1]$，$a[i - 2]$，$b[i - 1]$ 那么我们就需要确定出 $a[1]$、$a[2]$、$b[1]$ 的初值。

- 当 $n = 1$ 时，从某个顶点出发显然只有一种行走方式，因此 $a[1] = 1$；
- 当 $n = 2$ 时，从某个顶点出发会有以下 6 种方式，见下图，因此 $a[2] = 6$。

- 当 $n = 1$ 时，对于“一趟过去，一趟返回”这种走法而言，其从某个顶点出发显然只有一种走法，即走向该列的另一个点；
- 当 $n = 2$ 时，对于“一趟过去，一趟返回”这种走法而言，其从某个顶点出发显然只有 $2$ 种方式，因此 $b[2] = 2$（为了在写代码的时候能够将 $a$ 数组和 $b$ 数组放进同意循环，这里也顺带给出了 $b[2]$ 的值）。


------------

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e9 + 7;
long long a[1005],b[1005];

int main()
{
    int n;
    cin >> n;
    if(n == 1)
    {
        cout << 2;
        return 0;
    }
    a[1] = 1,a[2] = 6;
    b[1] = 1,b[2] = 2;
    for(int i = 3;i <= n;i++)
    {
        b[i] = (2 * b[i - 1]) % N;
        a[i] = (2 * a[i - 1] + b[i] + 4 * a[i - 2]) % N;
    }
    long long sum = (4 * a[n]) % N; //必须开long long，否则有可能会溢出
    for(int i = 2;i < n;i++) sum = (sum + 4 * (b[i] * a[n - i] + b[n - i + 1] * a[i - 1])) % N;
    //根据前面算出的a数组和b数组，递推出从中间出发时的方案数量
    //注意i的范围大于1小于n
    cout << sum;
    return 0;
}
```

---

## 作者：Ar_cher (赞：8)

## 分析

用 $a[i]$ 表示从某一角到刷完 $i$ 列终点任意的情况数。$b[i]$ 表示从某一角到刷完  $i$ 列，终点与起点同列的情况数

![https://cdn.luogu.com.cn/upload/image_hosting/k52ovrzc.png](https://cdn.luogu.com.cn/upload/image_hosting/k52ovrzc.png)

一、如果从角出发，有三种情况

①：一列一列的走（ $A-D-B-E$ 或 $A-D-E-B$ ），那么走到下一列有上下的选择，故$a[i]=2 \times a[i-1]$

②：走到下一列回到上一列,再去往下一列（$A-B-D-E-C-F$ 或 $A-E-D-B-C-F$ 或 $A-B-D-E-F-C$ 或 $A-E-D-B-F-C$ ）所以 $a[i]=2 \times 2 \times a[i-2]$

③：走到下一列再继续走下一列，那么就必须一直走到结尾再回来，不然两边都有空。 $b[i]=2 \times b[i-1]$

二、如果从中间出发，那么就是分成两个矩形。先左边按照③走，另一个随意走。然后再右边按照③走，另一个随意走

　　那么就是 $2 \times (2 \times b[i-1] \times 2 \times a[n-i] + 2  \times b[n-i] \times 2 \times a[i-1])$
  
　　红色2：从第 $i$ 列可以有左右两个选择
  
　　绿色2：从第 $i$ 列开始左走有上下连个选择，此时必须按③走，所以  $b[i-1]$ 。回到第 $i$ 列往右走有上下两个选择，此时随意走。然后先右后左同理。

### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1010;
const int mod=1000000007;
typedef long long ll;
ll a[maxn],b[maxn];
int n;
int main() {
    while(~scanf("%d",&n)) {
        if(n==1) puts("2");
        else {
            a[1]=1;
            a[2]=6;
            b[1]=1;
            b[2]=2;
            for(int i=3;i<=n;i++) {
                b[i]=b[i-1]*2%mod;
                a[i]=(2*a[i-1]+4*a[i-2]+b[i])%mod;
            }
            ll sum=4*a[n]%mod;
            for(int i=2;i<n;i++) {
                sum=sum+(8*b[i-1]*a[n-i]%mod+8*b[n-i]*a[i-1]%mod);
                sum=sum%mod;
            }
            printf("%lld\n",sum);
        }
    }
    return 0;
}
```
其实这道题思路还是比较简单的，只是看要怎么分析

---

## 作者：WydnksqhbD (赞：8)

# [P8607 [蓝桥杯 2013 国 B] 格子刷油漆](https://www.luogu.com.cn/problem/P8607) 题解
## 思路
别看人家什么 dp 动规、状态转移方程，其实就是循环算一算就好了。

![](https://cdn.luogu.com.cn/upload/image_hosting/l9d6hl7z.png)

图 0-1

首先，我们来考虑一下：

题目中说了我们可以从**任意一格**开始刷，那么就应该分两种情况：从顶点出发和从中间出发。分类讨论：

1.从顶点出发

这时，我们又得分出来 $3$ 种情况（$3$ 种刷漆的方法）：

+ “一往无前”式：第一步向**同列**的另一个格子走，然后走到下一列的任意一个格子，以此类推。由于这种走法一次就可以走完（不用回头），我们形象地称之为“一往无前”式。

![](https://cdn.luogu.com.cn/upload/image_hosting/ud3qnsz1.png)

图 1-1 一往无前

在“一往无前”式中，我们从 $a$ 开始。如果我们走到了 $c$，这又变成了原来的形式。所以，“一往无前”式的动态转移方程（不要管它是什么，就是个名字而已）是：（用数组 $a$ 中的 $a_i$ 来表示到达第 $i$ 行时的合法刷漆方式）$a_i=2\times a_{i-1}$。

+ “摇摆”式：首先走到下一列的任意一个格子，然后回来走完剩下的这个。称之为“摇摆”式。

![](https://cdn.luogu.com.cn/upload/image_hosting/hku6sru1.png)

图 1-2 摇摆

这个也很简单，不再细述。方程为 $a_i=4\times a_{i-2}$。

+ “往返”式：首先只管往前冲，每次都选择下一列的一个格子刷，然后回来时刷掉剩下的。

![](https://cdn.luogu.com.cn/upload/image_hosting/0ynrin7v.png)

图 1-3 往返

Tips:图中黄线表示去，绿线表示中途转向，蓝线表示回来的路程。

这是个人都能想出来（如果这个词伤害到了您，我表示深深的道歉），每次乘 $2$ 嘛。$b_i=2\times b_{i-1}$。

那么到这里，我们就都搞出来了。

**但是，这只是从顶点出发啊！**

2.从中间出发

很简单，看个图你就懂了：

![](https://cdn.luogu.com.cn/upload/image_hosting/0hbpdfdp.png)

懂了吗？

然后它的方案数就是这个：

$$4\times (b_i\times a_{n-i}+b_{n-i+1}\times a_{i-1})$$

## 综上，总方案数为：

$$\text{sum}=4\times a_n+4\times (b_i\times a_{n-i}+b_{n-i+1}\times a_{i-1})$$

然后，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005,mod=1e9+7;
typedef long long ll;
ll n,ans,a[N],b[N];
int main()
{
	scanf("%lld",&n);
	a[1]=b[1]=1,a[2]=6,b[2]=2;
	for(int i=3;i<=n;i++)
	{
		b[i]=b[i-1]*2%mod;
    	a[i]=(2*a[i-1]+4*a[i-2]+b[i])%mod;
	}
	ans=(4*a[n])%mod;
	for(int i=2;i<n;i++)
	{
		ans+=(8*b[i-1]*a[n-i]%mod+8*b[n-i]*a[i-1]%mod),ans%=mod;
	}
	printf("%lld",ans);
	return 0;
}
```

最后：本文参考[该文章](https://blog.csdn.net/the_zed/article/details/104724184)。

本题解图片纯手绘，不喜勿喷。

---

## 作者：Chillturtle (赞：0)

# 写在前面的话

嗯嗯，小清新分讨。上位黄？

# 题意

给一个 $2 \times n$ 的格子涂色，每次可以移动到相邻（对角线也可）的格子。每次输入 $n$ 问有多少种方案。

# 思路

一眼分类讨论。

首先，来看起点，很明显起点可以分为以下两类：这个矩形的四个角，还有中间。

## 起点在四个角

在这种情况下我们在尝试将它分成三种情况：

- 一列一列的走，就是说这次走这一列的一个格子，下次走这一列的另外一个格子，下下次走下一列的任意一个格子。
- 把总的路径分成两个部分，前半部分每次都走下一列的任意一个格子，这显然，后一半的路径就是把前一半没有走过的格子走了就可以了。
- 第一步走下一列的任意格子，然后返回上一列没走的那个格子，然后再走回来。

这里我们设一趟直接过去不走回头路的方案数记作数组 $x$，同理设一趟过去一趟回来的数组为 $y$。

### 方案一

这个挺显然的，就是说，我们不妨令上面的格子为 $A$ ，下面为 $B$。那么我们这一列的路径就显然可以是 $[A,B]$ 或者 $[B,A]$。那么每一列就有两种可能，就显然有递推式：

$$
x_i = x_{i-1} \times 2
$$

有图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/fuarrzgz.png)

### 方案二

这个跟上面那个同理，当你在第 $i$ 的任意一个格子上时，显然第 $i+1$ 列的任意一个格子你都是可以走的。注意，在这种方案中不存在在同一列的两个格子在同一半段被走。

前面我们已经定义好了 $y$ 数组，那么显然，$y$ 数组也有递推式：

$$
y_i = y_{i-1} \times 2
$$

有图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ajuwuodo.png)

当然这只是一种合法情况，仅作示意。

### 方案三

这个就有一些不同了，第一步走下一列的任意格子，然后返回上一列没走的那个格子，然后再走回来。这边直接给图可能会看得更清楚：

![](https://cdn.luogu.com.cn/upload/image_hosting/exkcplfz.png)

这两个框框分别呈现了两种可能。

现在来整理递推式：首先绿色框框里的跟之前那一种一趟过去一趟回来显然是一样的。至于黄色框框里的其实也是一样的。这和方案一是一样的策略，只是说只有 $2 \times 2$ 的格子，看起来会特殊一点。

所以式子就很好得了，这显然是两倍的方案一的方案数，即：

$$
x_i = x_{i-2} \times 2 + x_{i-2} \times 2 = 4 \times x_{i-2}
$$

现在起点在四个角的情况就分析完了。注意因为能从四个角分别出发，故真正的方案数还应该乘以 $4$。

## 起点在中间

起点在中间的情况，我们可以把它分成两种情况：

- 第一步往左边走。
- 第一步往右边走。

### 方案一

第一步往左边走。

嗯嗯，对于一个中间的点来说，和四个角的情况不同在于第一步既可以往左也可以往右。有图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/lz34gk99.png)

显然，在这张图里点 $J$ 是个关键点。因为我们先向左走为了走回右边（就是全部走完）那么我们从左边回来的时候必然经过 $J$。所以**左边的方案数相当于一趟过去一趟回来的方案数**。右边呢，这也很显然，因为我们不需要考虑回不回来的问题，所以一趟过去一趟回来或者说不回来都是可以的。

所以我们有方案数为左边的总方案数乘以右边的总方案数（乘法原理）：

$$
y_i \times 2 \times x_{n-i} \times 2 = 4 \times x_{n-i} \times y_i
$$

### 方案二

第一步往右边走。

其实大同小异，只是注意把 $x$ 换成 $y$ 然后再处理下区间的长度问题即可。这里不再赘述。

有式子如下：

$$
y_{n-i+1} \times 2 \times x_{i-1} \times 2 = 4 \times x_{i-1} \times y_{n-i+1}
$$


## 总结

现在，我们把两种情况都分析完了，我们直接把两种情况的方案数相乘即可。

$$
4 \times a_n + 4 \times (b_i \times a_{n-i} + b_{n-i+1} \times a_{i-1})
$$

现在就差两个数组的初始值就可以递推了：这个蛮显然的这边就不在赘述了。直接给出：

$$
x_1 = 2, x_2 = 6, y_1 = 2
$$

然后就没有然后了。

# AC code

直接打表递推即可，~~为维护社区秩序~~，这里就不贴代码了 QwQ。

本文参考了 [这篇文章](https://blog.csdn.net/the_zed/article/details/104724184)。

---

## 作者：封禁用户 (赞：0)

题解：P8607 [蓝桥杯 2013 国 B] 格子刷油漆
-

设 $a[x]$ 为 $4$ 个角中任意一个格子为起始点的总方案数，$b[x]$ 为 $4$ 个角中任意一个格子为起始点，其上或者其下的格子为终点的方案数。

对于 $b[x]$，后面的每一列都必须有 $1$ 个格子过去 $1$ 个格子回来才能回到终点，所以 $b[x]=2\times b[x-1]$。

对于 $a[x]$,以左上角的格子为例，有三个方向可以走，分类如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/8y0eazl1.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

起点在角上的总方案数为：

$$ans_1=4\times a[i]=4(2a[x-1]+4b[x-2]+4a[x-2])=4(2a[x-1]+2b[x-1]+4a[x-2])$$

起点在中间的总方案数：

$$ans_2=\sum_{i=1}^{n-1}(b[n-i]a[i-1]+b[i-1]a[n-i])$$


```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1000000007
using namespace std;
ll a[1011],b[1011];
int main(){
    int n;
    scanf("%d",&n);
    b[1]=1,a[1]=1;
    b[2]=2,a[2]=6;
    for(int i=3;i<=n;i++){
        b[i]=b[i-1]*2%inf;
        a[i]=(2*a[i-1]+4*a[i-2]+2*b[i-1])%inf;
    }
    ll ans1,ans2;
    if(n==1)printf("2\n");
    else{
        ans1=4*a[n]%inf;
        ans2=0;
        for(int i=2;i<n;i++)
            ans2+=8*(b[i-1]*a[n-i]%inf+b[n-i]*a[i-1]%inf)%inf;
        	printf("%lld\n",(ans1+ans2)%inf);
        }
    return 0;
}

```

---

## 作者：StarRain3 (赞：0)

我们可以先考虑从从顶点出发。第一种情况：第一步走它同一列的另外一个格子，再去走下一列，重复这样的操作，这样属于回不来的的情况，第 $i$ 列有两种选择情况。


第二种情况：第一步走下一列，第二步还是走下一列，走到最后再返回，由于行固定为 $2$，所以回来的路径是唯一的。


第三种情况：第一步走另外一列，第二步由该列，再走回来，第三步走另外一列剩余的格子。

然后从中间出发有两种，先从中间第 $i$ 列往左边出发，再回到右边，从中间第i列往右边出发，再回到左边，最后可以得出总的方案数，见代码部分。

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1000000007;
const int N = 1005;
ll a[N], b[N];
int n;
ll f, f1;

int main() {
	cin >> n;
	if (n == 1)//特判
		cout << 2 << endl;
	else {
		a[1] = 1;
		b[1] = 1;
		a[2] = 6;
		b[2] = 2;
		for (int i = 3; i <= n; i++) {//第一种
			b[i] = (b[i - 1] * 2) % mod, a[i] = (2 * a[i - 1] + b[i] + 4 * a[i - 2]) % mod;
		}
		f = (4 * a[n]) % mod;
		for (int i = 2; i <= n - 1; i ++ ) {//第二种
			f1 = f1 + (4 * (b[i] * a[n - i] + b[n - i + 1] * a[i - 1])) % mod;
			f1 = f1 % mod;

		}
		cout << (f + f1) % mod << endl;
	}
	return 0;
}
```

---


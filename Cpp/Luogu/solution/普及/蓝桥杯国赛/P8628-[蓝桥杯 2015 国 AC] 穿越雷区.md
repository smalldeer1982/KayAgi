# [蓝桥杯 2015 国 AC] 穿越雷区

## 题目描述

$X$ 星的坦克战车很奇怪，它必须交替地穿越正能量辐射区和负能量辐射区才能保持正常运转，否则将报废。

某坦克需要从 $A$ 区到 $B$ 区去（$A$，$B$ 区本身是安全区，没有正能量或负能量特征），怎样走才能路径最短？

已知的地图是一个方阵，上面用字母标出了 $A$，$B$ 区，其它区都标了正号或负号分别表示正负能量辐射区。

例如：

```
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -
```

坦克车只能水平或垂直方向上移动到相邻的区。


## 说明/提示

时限 1 秒, 512M。蓝桥杯 2015 年第六届国赛

## 样例 #1

### 输入

```
5
A + - + -
- + - - +
- + + + -
+ - + - +
B + - + -```

### 输出

```
10```

# 题解

## 作者：fish_love_cat (赞：7)

[01 迷宫](https://www.luogu.com.cn/problem/P1141)的弱化版，BFS 版子题，哪要什么最短路……

唯一的区别就是没有墙了，改成只能走不同辐射区域。定义数组存辐射区能量正负极和安全区，所以要用整型变量。初始所有图内的点全部为真能走，走过的点不再重走置为假。所以只要这地方为真而且正负极与当前不同，即可入队。

如果下一步是目的地，直接返回值即可。

代码长这样：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sx,sy,ex,ey;
int f[105][105];
bool b[105][105];
struct wz{
    int x,y,ans;
};
queue<wz> q;
int gx[4]={1,-1,0,0};
int gy[4]={0,0,1,-1};
int bfs(){
    wz a;
    a.x=sx;
    a.y=sy;
    a.ans=0;
    q.push(a);
    b[sx][sy]=false;
    while(!q.empty()){
        a=q.front();
        q.pop();
        for(int i=0;i<4;i++){
            wz xin;
            xin.x=a.x+gx[i];
            xin.y=a.y+gy[i];
            xin.ans=a.ans+1;
            if(xin.x==ex&&xin.y==ey) return xin.ans;
            if(b[xin.x][xin.y]&&f[xin.x][xin.y]!=f[a.x][a.y]) q.push(xin),b[xin.x][xin.y]=false;
        }
    }
    return -1;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            char c;
            cin>>c;
            if(c=='+') f[i][j]=1;
            if(c=='-') f[i][j]=-1;
            if(c=='A') sx=i,sy=j;
            if(c=='B') ex=i,ey=j;
            b[i][j]=true;
        }
    }
    cout<<bfs();
    return 0;
}
```

---

## 作者：weifengzhaomi (赞：4)

题目意思简单来讲就是求 $A$ 点到 $B$ 点的最少步数。

## 思路

考虑 DFS。

直接写个 DFS 爆搜就可以了，每次判断能否走到当前位置。

如果能，则走的步数加一。

如果走到 $B$ 点就更新答案。

简单来讲就是一个 DFS 模版题。

如果愿意，可以**剪枝**。

## 代码（码风巨丑，谨慎观看）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[4] = {1,-1,0,0};
const int dy[4] = {0,0,1,-1};
int n,ans = INT_MAX,x,y;
char a[110][110];
bool f[110][110];
void dfs(int x,int y,int cnt){
	if(a[x][y] == 'B'){ans = min(cnt,ans);return;}
	for(int i = 0;i < 4;i++){
		int xx = x + dx[i],yy = y + dy[i];
		if(!f[xx][yy] && (xx >= 1 && xx <= n && yy >= 1 && yy <= n && a[xx][yy] != a[x][y])) f[xx][yy] = true,dfs(xx,yy,cnt + 1),f[xx][yy] = false;
	}
}
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++){
			cin >> a[i][j];
			if(a[i][j] == 'A') x = i,y = j,f[x][y]=true;
		}
	dfs(x,y,0),printf("%d\n",ans);
}
```

---

## 作者：SilverLi (赞：3)

[穿越雷区 の 传送门](https://www.luogu.com.cn/problem/P8628)

让我们求的是 $A$ 区到 $B$ 区的最少移动步数，所以考虑 DFS。

直接用 DFS 模板，然后一点改动就是**交替地穿越正能量辐射区和负能量辐射区**，这个地方其实不用取反，因为开始位置是 `A`，目的地是 `B`，其它位置是 `+` 和 `-`，单纯取反不好操作，其实只需要下一步走到的位置跟当前位置不一样就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,Ax,Ay,Bx,By;
int step=1<<30;
bool vis[107][107];
char mapp[100+7][100+7];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
bool check(int x,int y,int new_x,int new_y){
	if(new_x<1||new_x>n||new_y<1||new_y>n||mapp[x][y]==mapp[new_x][new_y])
		return false;
	return true;
}
void dfs(int x,int y,int cnt){
	if(mapp[x][y]=='B'){
		step=min(step,cnt);
		return;
	}
	for(int i=0;i<4;i++){
		int new_x=x+dir[i][0];
		int new_y=y+dir[i][1];
		if(!vis[new_x][new_y] && check(x,y,new_x,new_y)){
			vis[new_x][new_y]=true;
			dfs(new_x,new_y,cnt+1);
			vis[new_x][new_y]=false;
		}
	}
}

int main(){
	cin>>n;
	memset(vis,0,sizeof(vis));
	for(int i=1;i<n+1;i++){
		for(int j=1;j<n+1;j++){
			cin>>mapp[i][j];
			if(mapp[i][j]=='A'){
				Ax=i;Ay=j;
				vis[Ax][Ay]=true;
			}
		}
	}
	dfs(Ax,Ay,0);
	cout<<(step==1<<30?-1:step)<<endl;
	return 0;
}

```

---

## 作者：linkai20111030 (赞：3)

### 题目大意：
在矩阵内，只可以 $+$，$-$ 来回走，求从 $A$ 点，到 $B$ 点最短路程。 

### 做法：
很容易可以想到用BFS，如果是 $+$，就走 $-$，如果是 $-$ 就走 $+$。

### 代码：
```.cpp
#include<bits/stdc++.h>
#pragma optimize(1)
#pragma optimize(2)
#pragma optimize(3)
#pragma optimize("Ofast")
using namespace std;
typedef long long ll;
ll n;
char a[105][105];
struct ab{
    ll x,y,w;
};
queue<ab>q;
bool b[105][105];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
            if(a[i][j]=='A')
                q.push({i,j,0}),b[i][j]=1;
        }
    }
    while(!q.empty()){
        ll x=q.front().x;
        ll y=q.front().y;
        ll w=q.front().w;
        q.pop();
        if(a[x][y]=='B'){
            cout<<w;
            return 0;
        }
        if(a[x][y]!='-'){
            if(a[x+1][y]!='+'&&x+1<=n&&!b[x+1][y])
                q.push({x+1,y,w+1}),b[x+1][y]=1;
            if(a[x][y+1]!='+'&&y+1<=n&&!b[x][y+1])  
                q.push({x,y+1,w+1}),b[x][y+1]=1;
            if(a[x-1][y]!='+'&&x-1>=1&&!b[x-1][y])
                q.push({x-1,y,w+1}),b[x-1][y]=1;
            if(a[x][y-1]!='+'&&y-1>=1&&!b[x][y-1])
                q.push({x,y-1,w+1}),b[x][y-1]=1;
        }
        if(a[x][y]!='+'){
            if(a[x+1][y]!='-'&&x+1<=n&&!b[x+1][y])  
                q.push({x+1,y,w+1}),b[x+1][y]=1;
            if(a[x][y+1]!='-'&&y+1<=n&&!b[x][y+1])  
                q.push({x,y+1,w+1}),b[x][y+1]=1;
            if(a[x-1][y]!='-'&&x-1>=1&&!b[x-1][y])  
                q.push({x-1,y,w+1}),b[x-1][y]=1;
            if(a[x][y-1]!='-'&&y-1>=1&&!b[x][y-1])  
                q.push({x,y-1,w+1}),b[x][y-1]=1;
        }
    }
    cout<<-1;
}
```

---

## 作者：weizilong (赞：2)

## [题目传送门](https://www.luogu.com.cn/problem/P8628)
## 闲话
本蒟蒻第四篇题解。
既然是单源最短路，怎么能少了 SPFA 呢，同时这里给出一种新的建图方式。
# 正文
## 代码思路
### 建图
输入地图，判断当前字符。
- 如果是 $A$ 那么记录出发点。
- 如果是 $B$ 那么记录结束点。

然后进行连边。
#### 连边操作
因为是顺序输入，那么当`c[i][j]`输入时，`c[i-1][j]`和`c[i][j-1]`必然已经被输入了（除 $i=1$ 或 $j=1$ 时）。那么在输入时查看`c[i][j]`与`c[i-1][j]`和`c[i][j-1]`是否可以连边，如果可以相互连边即可。

```cpp
	for(int i=1,k=1;i<=n;i++){
		for(int j=1;j<=n;j++,k++){//k表示当前点编号
			cin>>c[i][j];	
			if(c[i][j]=='A')A=k; //出发点
			else if(c[i][j]=='B')B=k; //结束点
			if(i!=1&&c[i-1][j]!=c[i][j]){
				a[k].push_back(k-n);
				//第k个点的上一行的编号即为k-n;
				a[k-n].push_back(k);//无向图，两次连边
			}
			if(j!=1&&c[i][j-1]!=c[i][j]){
				a[k].push_back(k-1);
				//第k个点的上一列的编号即为k-;
				a[k-1].push_back(k);
			}
		}	
	}
```
**注意：**
- 因为是依次输入，所以每个点的编号即为他们输入的顺序。
### 找最短路
SPFA 没什么好说的，注意使每个边边权为 $1$ 即可，我就不给代码了。

### 时间复杂度；
SPFA 的时间复杂度通常为 $O(e) $，最坏为$ O(ve)$（$v$ 为节点数，$e$ 为边数）。本题中节点数为 $n\times n$，边数最坏大约为 $n\times n\times 4$（每个点 $4$ 条边），对于 $n \le 100$ 的数据规模是完全可行的。而且本题中没有负权环，不用进行特判。 
## 代码
最终代码如下，完结撒花。**（〃'▽'〃）**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dis[10005],A,B;
bool vis[10005];
char c[105][105];
vector<int> a[10005];
queue<int>q;
void spfa(int s) {
	q.push(s);
	dis[s] = 0;
	vis[s] = 1;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		vis[u] = 0;
		for (int v:a[u]) {
			if (dis[u] + 1 < dis[v]) {
				dis[v] = dis[u] + 1;
				if (!vis[v]) {
					q.push(v);
					vis[v] = 1;
				}
			}
		}
	}
	return ;
}
int main(){
	cin>>n;
	for(int i=1,k=1;i<=n;i++){
		for(int j=1;j<=n;j++,k++){
			cin>>c[i][j];	
			if(c[i][j]=='A')A=k;
			else if(c[i][j]=='B')B=k;
			if(i!=1&&c[i-1][j]!=c[i][j]){
				a[k].push_back(k-n);
				a[k-n].push_back(k);
			}
			if(j!=1&&c[i][j-1]!=c[i][j]){
				a[k].push_back(k-1);
				a[k-1].push_back(k);
			}
		}	
	}
	for(int i=1;i<=n*n;i++)dis[i]=1e9;
	spfa(A);
	if(dis[B]!=1e9)cout<<dis[B];
	else cout<<-1;
	return 0;
}
```

---

## 作者：Trump__Biden (赞：2)

### 题意：

有一个小车，要从一个坐标走到另一个坐标，只能向上下左右走，并且每两次穿越的地方性质不可相同。

### 思路：

输入数组时记录每个点的性质与起点坐标，然后直接搜索。搜完之后进行回溯，搜到终点后取最小值，最后输出答案。需要注意的点是一个点不能与他的上一个点性质不同，需要进行一下判断。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[110][110];
bool vis[110][110];
int n,ans=1e9,ax,ay;
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
void dfs(int x,int y,int sum){
	if(a[x][y]=='B'){
		ans=min(sum,ans);
		return;
	}
	for(int i=0;i<4;++i){
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(!vis[xx][yy]&&(xx>=1&&xx<=n&&yy>=1&&yy<=n&&a[xx][yy]!=a[x][y])/*判断是否合法*/){
			vis[xx][yy]=true;
			dfs(xx,yy,sum+1);
			vis[xx][yy]=false;
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			cin>>a[i][j];
			if(a[i][j]=='A'){
				ax=i;ay=j;
				vis[ax][ay]=true;
			}
		}
	}
	dfs(ax,ay,0);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：StarRain3 (赞：2)

看见另一位大佬用了 DFS 解法，这里给出 BFS。

我们 BFS 从最后一个出现的 `A` 开始，建立一个队列，放入当前的坐标以及步数，然后用 BFS 模板进行搜索，我们只要考虑正、负能量辐射区，**只要当前的与之前的不相同，并且没有走过，还得不超过这个图**，就从这里开始枚举，如果当前是 `B` 的话，就输出当前的步数。最后队列中所有点都走完了还没有能找到一个最短的移动方案就输出没找到。

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1005;

int n;
char a[N][N];
bool v[N][N]; 
int dxy[][2]={{1,0},{0,-1},{0,1},{-1,0}}; 

struct st
{
	int x,y,step;
	st(int a,int b,int c)
	{ 
		x=a,y=b,step=c; 
	}
};

bool check(int x,int y){
	if(x > 0 && x <= n && y > 0 && y <= n) return true;
	return false;
}
void bfs(int x,int y)
{
	queue<st> q;
	st p(x,y,0);
	q.push(p);
	v[x][y]=true;
	while(!q.empty())
	{
		st k=q.front();
		q.pop();
		for(int i=0;i<4;i++)
		{
			int nx=k.x+dxy[i][0],ny=k.y+dxy[i][1];
			if(check(nx,ny)&& !v[nx][ny] && a[k.x][k.y]!=a[nx][ny])
			{
				if(a[nx][ny]=='B'){ 
					cout << k.step+1;
					return; 
				}
				v[nx][ny]=true;
				q.push(st(nx,ny,k.step+1));
			}
		}
	}

	cout<<-1<<endl;
}

int main()
{
	int firstx,firsty;
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]=='A')
				firstx=i,firsty=j;
		}
	bfs(firstx,firsty);
	return 0;
}


```

[AC记录](https://www.luogu.com.cn/record/108528086)。

---

## 作者：Iniaugoty (赞：1)

[传送门](/problem/P8628)。

单源最短路简单题，适合新手练习。

***

## 题意

一个包含 $\texttt A$、$\texttt B$、$\texttt +$、$\texttt -$ 几种字符的方阵，初始时在 $\texttt A$，要到达 $\texttt B$。有一系列移动规则，问从 $\texttt A$ 到 $\texttt B$ 最少移动距离。

***

## 解法

依题意建图，然后从 $\texttt A$ 开始跑一边堆优化 dijkstra 即可。

建图操作：

- $\texttt A$ 或 $\texttt B$：向周围 $4$ 个点各连一条边。

- $\texttt +$：向周围 $4$ 个点中，不是 $\texttt +$ 的点连边（注意这其实还包括 $\texttt A$ 和 $\texttt B$）。

- $\texttt -$：向周围 $4$ 个点中，不是 $\texttt -$ 的点连边。

**注意：一定要判断出界！**

一个小技巧，将点的坐标转为编号的公式：$id=n\times(x-1)+y$。

***

## 代码

码风比较清奇，将就看看吧。

这份代码采用的是链式前向星存图。

```
#include<bits/stdc++.h>
#define N 105
#define inf 0x3f3f3f3f
#define id(x,y) ((x-1)*n+y)//转化公式
using namespace std;
struct star{//链式前向星存图
	int next,to;
}e[N*N<<2];
int head[N*N],cnt;
void add(int u,int v){//连边操作
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
int vis[N*N],dis[N*N];
struct node{
	int u,val;
};
bool operator<(node a,node b){
	return a.val>b.val;
}
void dijkstra(int x){//堆优化 dijkstra
	memset(vis,0,sizeof vis);
	memset(dis,inf,sizeof dis);
	priority_queue<node>pq;
	pq.push(node{x,0});
	dis[x]=0;
	while(!pq.empty()){
		int t=pq.top().u,d=dis[t]+1;
		pq.pop();
		if(vis[t])
			continue;
		vis[t]=1;
		for(int i=head[t];i;i=e[i].next){
			int y=e[i].to;
			if(dis[y]>d)
				dis[y]=d,pq.push(node{y,d});
		}
	}
}
const int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};//方向数组
int n,s1,s2;
char ch[N][N];
signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>ch[i][j];
	//以上是输入，下面的循环是建图部分
	for(int i=1,k=1;i<=n;i++)
		for(int j=1;j<=n;j++,k++)
			if(ch[i][j]=='+')
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(ch[x][y]!='+'&&x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			else if(ch[i][j]=='-')
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(ch[x][y]!='-'&&x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			else if(ch[i][j]=='A'){
				s1=k;
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			}
			else if(ch[i][j]=='B'){
				s2=k;
				for(int l=0;l<4;l++){
					int x=i+dx[l],y=j+dy[l];
					if(x>0&&y>0&&x<=n&&y<=n)
						add(k,id(x,y));
				}
			}
	dijkstra(s1);
	cout<<(dis[s2]==inf?-1:dis[s2]);
	return 0;
}
```

***

全文完。

---

## 作者：Dollartree (赞：0)

### 解题思路

1. 要求路径最短，所以用广度优先搜索。和广度优先搜索不同的一点，因为要交替地穿越正能量辐射区和负能量辐射区，所以到 `+` 后不能到 `-`，到 `-` 后不能到 `+`，只需要在条件判断中加一句不能和上一次走的地方相同即可。

### 注意事项

1. 不能重走，要打标记。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[110][110];
int vis[110][110],dis[110][110];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
queue<int> qx,qy;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
	{
		for(int j=1;j<=n;++j)
		{
			cin>>a[i][j];
			if(a[i][j]=='A')//找起点 
			{
				qx.push(i);
				qy.push(j);
				vis[i][j]=1;
			}		
		}
	}
	while(!qx.empty())
	{
		int x=qx.front();
		int y=qy.front();
		qx.pop();
		qy.pop();
		if(a[x][y]=='B')//到终点 
		{
			cout<<dis[x][y];
			break;
		}
		for(int i=0;i<4;++i)
		{
			int xx=x+dir[i][0];
			int yy=y+dir[i][1];
			if(xx>0&&xx<=n&&yy>0&&yy<=n&&vis[xx][yy]==0&&a[xx][yy]!=a[x][y])
			{//                                             判断是否相同 
				qx.push(xx);
				qy.push(yy);
				dis[xx][yy]=dis[x][y]+1;
				vis[xx][yy]=1;//打标记 
			}
		}
	}
}
```

---

## 作者：yanzixuan2024 (赞：0)

宽搜。

拓展点为上下左右，当没走过、两个字符不同且不越界就放进队列。直到该点为出口时，输出步数并退出。如果最后队列为空都没有一个合适的解，输出 $-1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x,y,step;
};
const int walk[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
int n,sx,sy;
char a[105][105];
bool vis[105][105];
queue<node> q;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            cin>>a[i][j];
            if(a[i][j]=='A') sx=i,sy=j;
        }
    }
    q.push({sx,sy,0});
    vis[sx][sy]=1;
    while(!q.empty()){
        node t=q.front();
        q.pop();
        if(a[t.x][t.y]=='B') return printf("%d",t.step),0;
        for(int i=0;i<4;++i){
            int xx=t.x+walk[i][0],yy=t.y+walk[i][1];
            if(vis[xx][yy]||a[t.x][t.y]==a[xx][yy]) continue;
            if(xx<1||xx>n||yy<1||yy>n) continue;
            q.push({xx,yy,t.step+1});
            vis[xx][yy]=1;
        }
    }
    puts("-1");
}
```

---


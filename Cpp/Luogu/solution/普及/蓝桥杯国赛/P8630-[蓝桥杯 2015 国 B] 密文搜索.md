# [蓝桥杯 2015 国 B] 密文搜索

## 题目描述

福尔摩斯从 X 星收到一份资料，全部是小写字母组成。

他的助手提供了另一份资料：许多长度为 $8$ 的密码列表。

福尔摩斯发现，这些密码是被打乱后隐藏在先前那份资料中的。

请你编写一个程序，从第一份资料中搜索可能隐藏密码的位置。要考虑密码的所有排列可能性。

## 说明/提示

第一个密码匹配了 $3$ 次，第二个密码匹配了 $1$ 次，一共 $4$ 次。

时限 3 秒, 512M。蓝桥杯 2015 年第六届国赛

## 样例 #1

### 输入

```
aaaabbbbaabbcccc
2
aaaabbbb
abcabccc```

### 输出

```
4```

# 题解

## 作者：qwerty12346 (赞：25)

# [题目传送门](https://www.luogu.com.cn/problem/P8630)

## 题意

就是求从第一份资料中搜索可能隐藏密码的位置。并要输出所有排列在 $s$ 中匹配次数的总和。

## 思路

因为密码是打乱的，所以要先对这个字符串排序。然后将排列后出现的号码依次相加，最后再在字符串中取连续 $8$ 位，加上出现次数就可以了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>mp;//map容器统计出现的号码
string s,x;
int n,ret;
int main(){
    cin>>s>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>x;
        sort(x.begin(),x.end());//对字符串x排序
        mp[x]++;
    }
    for(int i=0;i<s.size()-7;i++)
    {
        x=s.substr(i,8);
        sort(x.begin(),x.end());
        ret+=mp[x];
    }
    cout<<ret;
    return 0;
}
```


---

## 作者：Shadow_T (赞：20)

### 作者的前言

[传送门](https://www.luogu.com.cn/problem/P8630)

看到题解区里大家都是用 `map` 的，这里来贡献一发哈希的。

### 哈希的好处

>哈希这种算法一般用来快速查找，通过 $\operatorname{hash}$ 函数将输入的键值 $key$ 映射到某一个地址，然后就可以获得该地址的内容。\
同样，如果要储存一对值（键值和数据），则也是通过 $\operatorname{hash}$ 函数获得地址来存入。

—— [Moua 的 CSDN 博客](https://blog.csdn.net/qq_47406941/article/details/117753077)

### 哈希的实现

没学过哈希的人可以先学这道题：

[P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)

我们可以将需要加密的字符串转换成一个特定的数来表示，不过在所难免的，还是存在几率使两个不同字符串被转换成同一个数的情况，为了让概率尽量小，我们可以采用一种常用的哈希转换法：**进制哈希**。

我们可以自己随便定义一个进制数 $base$，将一个串的每一个元素看做一个进制位上的数字，然后将这个 $base$ 进制数转换为 $10$ 进制，这个数就是**哈希值**，我们可以通过对比哈希值来判断串是否相同。

### 本题的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
int base=114;
int t[128],a[200001];
int change()
{
	int cnt=1;
	for(int i='a';i<='z';i++)
	cnt=cnt*base+t[i];
	return cnt;
}
signed main()
{
    int len,n,ans=0;
    string s,s1;
	cin>>s>>n;
	len=s.size();
	for(int i=0;i<=len-8;i++)
	{
		memset(t,0,sizeof t);
		for(int j=i;j<i+8;j++)
		t[s[j]]++;
		a[i]=change();
	}
	memset(t,0,sizeof t);
	while(n--)
	{
		memset(t,0,sizeof t);
		cin>>s1;
		for(int j=0;j<8;j++)
		t[s1[j]]++;
		int b=change();
		for(int i=0;i<=len-8;i++)
		if(b==a[i]) ans++;
	}
	cout<<ans;
}
```

[AC 记录](https://www.luogu.com.cn/record/114073136)

---

## 作者：LegendaryGrandmaster (赞：6)

既然密码都打乱了，那么我们排序后就整齐了，把出现的密码依次累加，得到的就是这个密码出现的次数。

在字符串 $s$ 中每次取连续的 $8$ 位，排序后加上这个字符串出现的次数即可。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<string,int>mp;
int main()
{
	string str;
	cin>>str;
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		string st;
		cin>>st;
		sort(st.begin(),st.end());
		mp[st]++;
	}
	int ans=0;
	for(int i=0;i<str.size()-7;i++){
		string st=str.substr(i,8);
		sort(st.begin(),st.end());
		ans+=mp[st];
	}
	cout<<ans;
}
```

---

## 作者：LHQing (赞：5)

### 题目分析：

打乱的密码我们直接排序即可。

对于每组询问，我们暴力查询，时间复杂度为 $O(n|s|)$，显然过不了。

既然是求所有匹配总和，那么不妨统计 $s$ 所有长度为 $8$ 的子串对所有查询的贡献次数。可以考虑 Hash，但这里提供一种更快的方法，即 stl 库中提供了 `map` 这个容器，我们可以将密码串排序后让其所对应的贡献 $+1$。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pd(x) push_back(x)
#define all(x) x.begin(),x.end()
//==============================================================================
ll QP(ll x,ll y,ll mod){ll ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}
//==============================================================================
namespace IO{
	int readInt(){
		int x=0,y=0;char c=0;
		while(!isdigit(c))y|=c=='-',c=getchar();
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		return !y?x:-x;
	}
	void write(int x){if(!x)return;write(x/10);putchar(x%10);}
	void Output(int x){if(x<0)putchar('-'),x=-x;if(!x)putchar('0');else write(x);}
	void WL(int x){Output(x);putchar('\n');}
	void WS(int x){Output(x);putchar(' ');}
}
namespace Debug{
	void DeVec(vector<int> c){for(auto y:c)printf("%d ",y);puts("");}
}
//==============================================================================
const int N=1e3+10;
string s;int n;
map<string,int> mp;
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>s>>n;
	for(int i=1;i<=n;i++){
		string str;cin>>str;
		sort(all(str));mp[str]++;
	}int l=s.size();int ans=0;
	for(int i=0;i<l-7;i++){
		string str;
		for(int j=i;j<=i+8-1;j++)
			str+=s[j];
		sort(all(str));
		ans+=mp[str];
	}cout<<ans;
	return 0;
}
```

时间复杂度：$O(n\log n)$。

---

## 作者：ccg12345 (赞：5)

## P8630 [蓝桥杯 2015 国 B] 密文搜索题解
### 前景知识（来源于知乎）
`s.substr(a,b)`：

返回值 `string`：包含 $s$ 中从 $a$ 开始的 $b$ 个字符的拷贝（$a$ 的默认值是 $0$，$b$ 的默认值是 `s.size() - a`，即不加参数会默认拷贝整个 $a$）。

``map``：

``map`` 是 ``STL``（中文标准模板库）的一个关联容器。

1. ``map`` 可以将任何基本类型映射到任何基本类型。如 `int array[100]` 事实上就是定义了一个 `int` 型到 `int` 型的映射。

2. ``map`` 提供一对一的数据处理，`key-value` 键值对，其类型可以自己定义，第一个称为关键字，第二个为关键字的值。

3. ``map`` 内部是自动排序的。

### 本题思路

题目中说密码是打乱的，所以显然我们需要先对这个字符串进行排序。排列后将出现的号码依次相加。

最后再在字符串中取连续 $8$ 位，加上出现次数即可。

附上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
map<string, int> k;
int main()
{
    string s, ss;
    int n, ans = 0;
    cin >> s;
    cin >> n;
    for(register int i = 1; i <= n; i++)
    {
        cin >> ss;
        sort(ss.begin(), ss.end());//将ss中的字母从小到大排序
        k[ss]++;
    }
    for(register int i =0 ; i < s.size() - 7; i++)
    {
        ss = s.substr(i, 8);//取s中的连续8位
        sort(ss.begin(),ss.end());
        ans += k[ss];
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Aisaka_Taiga (赞：2)

我们看到给出的 $n$ 个小串可能是被打乱了再成为大串的子串的，所以我们可以先把给定的 $n$ 个串每个串都按字符大小重新排序成一个按字典序排好的小串，然后考虑在枚举的时候把大串取出八个字符排序一下，然后再与上面排完序的 $n$ 个小串比较是否相等即可。

对于这个比较是否相同的过程完全可以直接判或者用 `map` 来实现，这里我选择了哈希。

```cpp
#include <bits/stdc++.h>

#define int long long
#define P 998244353
#define N 1001000

using namespace std;

const int base = 131;
int n, ans, b[N];
string s, a[N];

inline int Hash(string s)
{
	int len = s.size(), res = 0;
	for(int i = 0; i < len; i ++)
		res = (res * base + (int)s[i]) % P;
	return res;
}

signed main()
{
	cin >> s >> n;
	int up = s.size();
	for(int i = 1; i <= n; i ++)
	{
		cin >> a[i];
		sort(a[i].begin(), a[i].end());
		b[i] = Hash(a[i]);
	}
	if(up < 8) {puts("0"); return 0;}
	for(int i = 0; i < up - 7; i ++)
	{
		string now = s.substr(i, 8);
		sort(now.begin(), now.end());
		int cao = Hash(now);
		for(int j = 1; j <= n; j ++)
			if(b[j] == cao) ans ++;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Maysoul (赞：2)

提供一个比较清奇的思路：

对于密码的所有排列，全部求出来一定是不行的，我们可以把它视为一个小写字母的集合，这样只记录每个字母出现的次数就可以，然后再对文本串进行划分，我们每 $ 8 $ 个划分一次，划分的每一个都视为一个小写字母的集合，然后再对密码进行比对。

但是这样还是太过麻烦，因为每一次比对都要比对 $ 26 $ 个字母，全部相等的时候才视为成功一次。我们考虑更加简单的比对方案。

我们还是可以回到哈希，对于 $ 26 $ 个字母的状态，都建立一个与之对应的哈希值，就跟平常求字符串哈希一个思路，这样，我们对于每一个密码，只查找是否有与之相等的哈希值就可以了。

```cpp
#include<bits/stdc++.h>
typedef unsigned long long ull;
using namespace std;
const int MAXN=1048576+10;
int num,ans;
int b[26];
ull base=114;
ull a[MAXN];
ull gethash()//得到该数字的哈希
{
	ull tot=1;
	for (int i=0;i<26;i++)
	{
		tot=tot*base+b[i];
		//cout<<tot<<endl;
	}
	return tot;
}
int main()
{
	string s;
	cin>>s;
	int len=s.length()-8;
	for (int i=0;i<=len;i++)
	{
		for (int j=i;j<i+8;j++)//记录每个字母出现的次数
		{
			b[s[j]-'a']++;
		}
		a[i]=gethash();
		memset(b,0,sizeof(b));
	}
	/*for (int i=0;i<=len;i++)
	{
		cout<<a[i]<<" ";
	}*/
	int t;
	cin>>t;
	for (int i=1;i<=t;i++)
	{
		cin>>s;
		for (int j=0;j<8;j++)
		{
			b[s[j]-'a']++;
		}
		ull but=gethash();
		memset(b,0,sizeof(b));
		for (int i=0;i<=len;i++)//比较哈希值
		{
			if(but==a[i])
			{
				ans++;
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```




---

## 作者：SSTF2022ywh (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8630)

## 思路

读入一个字符串 $s$，一个整数 $n$，以及 $n$ 个长度为 $8$ 的字符串，然后统计 $s$ 中所有连续 $8$ 个字符的排列在这 $n$ 个字符串中出现的次数之和。

具体来说，代码首先创建一个空字典 $k$，然后对于每个长度为 $8$ 的字符串，将其字符按照字典序排序后作为键，出现次数作为值，存入字典 $k$ 中。接着，代码遍历 $s$ 中所有长度为 $8$ 的子串，将其字符按照字典序排序后在字典 $k$ 中查找出现次数，并将所有出现次数累加到变量 $ans$ 中。最后，代码输出变量 $ans$ 的值。


## Python Code

```python
# 读入一个字符串 s
s = input().strip()
# 读入一个整数 n
n = int(input())
# 创建一个空字典 k
k = {}
# 对于每个长度为 8 的字符串，将其字符按照字典序排序后作为键，出现次数作为值，存入字典 k 中
for i in range(n):
    # 读入一个长度为 8 的字符串
    ss = input().strip()
    # 将字符串 ss 中的字符按照字典序排序
    ss = ''.join(sorted(ss))
    # 如果排序后的字符串 ss 已经在字典 k 中，将其出现次数加 1
    if ss in k:
        k[ss] += 1
    # 否则，将其出现次数设为 1
    else:
        k[ss] = 1

# 初始化变量 ans 为 0
ans = 0
# 遍历 s 中所有长度为 8 的子串
for i in range(len(s) - 7):
    # 取出 s 中从第 i 个字符开始的连续 8 个字符
    ss = s[i:i+8]
    # 将字符串 ss 中的字符按照字典序排序
    ss = ''.join(sorted(ss))
    # 如果排序后的字符串 ss 在字典 k 中，将其出现次数加到变量 ans 中
    if ss in k:
        ans += k[ss]

# 输出变量 ans 的值
print(ans)
```

### 注意

这段代码的时间复杂度为 $O(n \times 8! \times m)$，其中 $n$ 是密码个数，$8!$ 是每个密码的排列数，$m$ 是字符串 $s$ 的长度。对于较大的输入，可能需要优化算法以满足时限要求。 


[已AC，请放心食用](https://www.luogu.com.cn/record/110674039)


---

## 作者：Gumbo (赞：0)

这里默认已经读过题目了，没有的话先去读一下。

首先，我们注意到密码是没有顺序的。

也就是说，我们的密码并非是一个小写字母的字符串，而是一个小写字母的集合。

只要有某个长度符合的子串所代表的字母可重集相同，就代表能被匹配。

先放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
string u;
string r[1005];
map<string,int>mp;
string trans(string&x,const int&p){
    string res="00000000000000000000000000";
    for(int i=0;i<8;++i){
        res[x[p+i]-'a']++;
    }
    return res;
}
int main(){
    cin>>s;
    int n;
    cin>>n;
    for(int i=0;i<n;++i){
        cin>>r[i];
    }
    for(int i=0;i<s.size()-7;++i){
        mp[trans(s,i)]++;
    }
    int ans=0;
    for(int i=0;i<n;++i){
        ans+=mp[trans(r[i],0)];
    }
    cout<<ans;
    return 0;
}
```
核心做法就是将一个字符串（函数中的参数 `x`）中的一个长度为 8 的子串（函数中指从第 `p` 个开始的长度为 8 的子串），转化成一个代表着集合中每个字符个数的东西，这里我用的是 C++ 自带的 `string`，也可以用其它的方式，总之能表达集合就行。

这里我的每一位表示当前子串中这个位置对应字符的个数，因为最多每种只会有 8 个，所以可以使用 `string` 中的一位来表示一个字符的个数。

主函数就是简单地读入、存储每种集合的出现次数、累加，最后输出答案即可。

---


# [蓝桥杯 2017 国 B] 发现环

## 题目描述

小明的实验室有 $N$ 台电脑，编号 $1 \sim N$。原本这 $N$ 台电脑之间有 $N-1$ 条数据链接相连，恰好构成一个树形网络。在树形网络上，任意两台电脑之间有唯一的路径相连。

不过在最近一次维护网络时，管理员误操作使得某两台电脑之间增加了一条数据链接，于是网络中出现了环路。环路上的电脑由于两两之间不再是只有一条路径，使得这些电脑上的数据传输出现了 BUG。

为了恢复正常传输。小明需要找到所有在环路上的电脑，你能帮助他吗？

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 1000$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le a,b \le N$。

时限 1 秒, 256M。蓝桥杯 2017 年第八届国赛

## 样例 #1

### 输入

```
5
1 2
3 1
2 4
2 5
5 3```

### 输出

```
1 2 3 5```

# 题解

## 作者：FHenryh (赞：16)

# 题目概述

[题目传送门](https://www.luogu.com.cn/problem/P8655)

在一棵树中新增一条边，使得这个图产生一个环，求在环上的点。

# 思路：

对于这道题我的思路类似于**拓补排序**。

首先可以将无向图转化为有向图，即将对于每条无向边变换为双向建边，就好处理了。

在这种情况下，很显然当一个点的入度大于或等于 $2$ 时，即有不止一条边连向这个点时，该点就在环上。

我们可以建一个布尔类型 $vis$ 数组来标记这个点的入度是否等于 $1$，那么这个点就不在环上，那么没有被标记的点就是我们要求的答案了。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1; 
int n;
int in[N];
vector<int>e[N];
bool vis[N];//标记入度是否为1，即该点是否在环上
void topo()//拓补排序
{
	queue<int>q;
	for(int i=1;i<=n;i++)
		if(in[i]==1)//标记入度为1的点
		{
			q.push(i);
			vis[i]=true;
		}
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=0;i<e[u].size();i++)
		{
			int v=e[u][i];
			in[v]--;
			if(in[v]==1)//标记入度为1的点
			{
				q.push(v);
				vis[v]=true;
			}
		}
	}
}
void print()//输出未标记的点
{
	for(int i=1;i<=n;i++)
		if(!vis[i])cout<<i<<' ';
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);//双向建边
		in[u]++;
		in[v]++;//两点的入度都增加
	}
	topo();
	print();
	return 0;
}
```

---

## 作者：liangbob (赞：6)

### P8655 题解

#### 思路分析

一道并查集加 DFS 的题。

首先，看到判环这一个要求，我就自然而然地想到了并查集。于是我们可以先用边集数组把所有边存起来。接着遍历，每遍历一条边就判一次环，如果某条边插入后会出现环，则记录这个环的两个顶点 $u$，$v$，不做插入。否则就插入并在并查集中合并。这个操作就相当于把环破坏成链。

接着，根据题意，没有环之后是一个树形结构，也就是两点之间路径唯一。所以可以使用 DFS 遍历从 $u$ 到 $v$ 的路径，这个即是环上的所有数。（因为从边 $(u,v)$ 破开成链后 $u$ 为起点，$v$ 为终点）

按照上述步骤实现即可。这里有个小技巧：因为题目的点的编号在 $1$ 到 $n$ 之间，所以我们在 DFS 遍历时只需记录访问过的节点，然后输出时就从 $1$ 到 $n$ 遍历并输出已经访问过的节点就可以实现按序输出，但需注意标记起点。

#### 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e5 + 10;

int fa[N]; //并查集数组
vector <int> g[N]; //vector 存图
struct edge
{
	int fr, to;
} e[N]; //边集数组
bool vis[N]; //访问过的节点
int s, f, n; //起点，终点，题意中的 n

void dfs(int u) //DFS 遍历路径
{
	if(u == f) //搜到了终点
	{
		for(int i = 1;i <= n;i++)
		{
			if(vis[i]) //访问过
			{
				cout << i << " ";
			}
		}
		cout << endl;
		exit(0); //直接退出，因为路径唯一
	}
	for(int i = 0;i < g[u].size();i++) //遍历邻接节点
	{
		int v = g[u][i];
		if(!vis[v]) //如果未访问
		{
            //访问该节点
			vis[v] = true; 
			dfs(v);
            //回溯
			vis[v] = false;
		}
		
	}
	
}
 
int find(int x) //并查集查找祖先函数
{
	return (fa[x] == x ? x : fa[x] = find(fa[x]));
}

void merge(int i, int j) //并查集合并函数
{
	fa[find(j)] = find(i);
}

int main()
{
	cin >> n;
	for(int i = 1;i <= n;i++) fa[i] = i; //并查集初始化
	s = f = 0; //初始化起点、终点 
	int d = 0; //边数
	for(int i = 1;i <= n;i++)
	{
		int x, y;
		cin >> x >> y;
		e[++d].fr = x; //记录边 (u, v) 的 u
		e[d].to = y; //记录 v
	}
	for(int i = 1;i <= d;i++)
	{
		if(find(e[i].fr) == find(e[i].to)) //如果产生环
		{
            //记录起点、终点
			s = e[i].fr;
			f = e[i].to;
		}
		else
		{
			g[e[i].fr].push_back(e[i].to); //插入边
			g[e[i].to].push_back(e[i].fr);
			merge(e[i].fr, e[i].to); //合并
		}
	}
	vis[s] = true; //标记起点
	dfs(s); //DFS 遍历路径
	return 0;
}
```



---

## 作者：Maysoul (赞：5)

原来的接线是树形结构，多接了一条变成了环。

我们可以考虑复原出这个树，然后对于多出来的这条边再进行操作。

当然我们并不需要真的建树，我们可以通过**并查集**的方式来考虑。

前面的操作有些类似 Kruskal 但无需排序，对于读入的每一条边 $ (u,v) $，我们合并这两个端点的父亲，并记录这条边，直到有一次无需合并，那就证明已经成环。

然后，我们在刚刚存的图上跑 DFS 即可，显然一个环应该是首尾相接的，故返回条件就是跑到两者相接的地方。

记录并输出即可。

```cpp
//2023/5/11
//别着急，先通读一遍题目
//别忘了开long long
//写完先看一遍怎么降复杂度
//要么开全局变量要么给定初值
//想想看，有什么情况需要特判
//看看数组开的够不够大
//std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num,ans;
vector<vector<int>> edge;
int fa[1000000];
int vis[1000000];
int n;
int find(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
void dfs(int op,int ed,vector<int> path)
{
	vis[op]=1;
	if(op==ed)
	{
		sort(path.begin(),path.end());//注意题目要求按照由小到大的顺序输出
		for (int i:path)
		{
			cout<<i<<" ";
		}
		return;
	}
	for (auto i:edge[op])
	{
		if(vis[i]==0)
		{
			vector<int> s=path;
			s.push_back(i);
			dfs(i,ed,s);
		}
	}
} 
int main()
{
	
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		fa[i]=i;
	}
	edge.resize(n+1);
	int x,y;
	for (int i=1;i<=n;i++)
	{
		cin>>x>>y;
		edge[x].push_back(y);//vector存图
		edge[y].push_back(x);
		int t1=find(x);//查询
		int t2=find(y);
		if(t1==t2)
		{
			vector<int> path;//path用于记录路径
			path.push_back(x);
			dfs(x,y,path);
		}
		fa[t2]=t1;//合并
	}
	return 0;
}
```



---

## 作者：5k_sync_closer (赞：5)

~~【模板】基环树找环~~

用并查集维护连通性，先把没有环的部分建出来。

考虑加入边 $(u,v)$ 时出现环，则该环由 $(u,v)$ 和树上 $u\to v$ 的路径组成。

从 $u$ DFS 这棵树，记录遍历的路径，遍历到 $v$ 时输出路径即可。

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
struct E
{
    int v, t;
} e[200050];
int n, c, a[100050], f[100050], h[100050];
void A(int u, int v)
{
    e[++c] = {v, h[u]};
    h[u] = c;
}
int F(int x) { return x == f[x] ? x : f[x] = F(f[x]); }
void D(int u, int k, int d, int t)
{
    a[d] = u;
    if (u == t)
    {
        sort(a, a + d + 1);
        for (int i = 0; i <= d; ++i)
            printf("%d ", a[i]);
        exit(0);
    }
    for (int i = h[u], v; i; i = e[i].t)
        if ((v = e[i].v) != k)
            D(v, u, d + 1, t);
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        f[i] = i;
    for (int i = 0, u, v; i < n; ++i)
    {
        scanf("%d%d", &u, &v);
        if (F(u) != F(v))
            A(u, v), A(v, u), f[F(u)] = F(v);
        else
            D(u, 0, 0, v);
    }
}
```


---

## 作者：_JF_ (赞：3)


[P8655 [蓝桥杯 2017 国 B] 发现环](https://www.luogu.com.cn/problem/P8655)

完成情况：独立完成。


考虑每个点对于产生环的贡献：

如果当前的点是叶子结点，并且除了父亲和他有连边以外没有点和他连边，显然不可能形成环。把这个点以及其连边删去。

一直这样操作下去，剩下的点都可以对形成环做出贡献，那就是在环里面了。

具体实现参照拓扑排序的思路，不同的只是删去度数为 $1$ 点。


[$Code$](https://www.luogu.com.cn/record/100259386)

---

## 作者：huangrenheluogu (赞：2)

### P8655 LCA

我们可以采用 dfs 遍历一棵树，并且搜到的点用 `vis` 数组标记一下。

然后就是处理搜到已经搜过的点的部分了。

![](https://cdn.luogu.com.cn/upload/image_hosting/vqrl1s4m.png)

可以看这一张图片，图中的点是已经搜索过的点，红色的边是我们当前搜到的 $(2,5)$ 的边，接下来我们要处理发现环的情况。

我们发现，可以在 `ans` 中装入 $1,2$ 两个点，再装入 $5, 4, 1$ 三个点，去掉重复的 $1$，就是我们需要的答案了。

两条链交在哪一个点呢？我们发现，就是他们的最近公共祖先！

~~不会 LCA 的请移步 [P3379](https://www.luogu.com.cn/problem/P3379)。~~（但是这一题不一定要倍增）

记 $lca_{x,y}$ 为 $x$ 和 $y$ 的最近公共祖先。

然后就把找到的两个点 $(x,y)$ 分别跳到 $lca_{x,y}$ 即可。

注意去掉算了两次的 $lca_{x,y}$。

下面是本蒟蒻的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, fir[N << 1], nxt[N << 1], son[N << 1], tot, u, v, fa[N][18], ans[N], lca, dep[N];
bool vis[N];
inline void add(int x, int y){
	nxt[++tot] = fir[x];
	fir[x] = tot;
	son[tot] = y;
}
inline int LCA(int x, int y){//LCA的板子
	if(dep[x] > dep[y]) swap(x, y);
	for(int i = 17; ~i; i--){
		if(dep[fa[y][i]] >= dep[x]) y = fa[y][i];
	}
	if(x == y) return x;
	for(int i = 17; ~i; i--){
		if(fa[x][i] != fa[y][i]){
			x = fa[x][i], y = fa[y][i];
		}
	}
	return fa[x][0];
}
inline void print(int x, int y){
	lca = LCA(x, y);
	for(int i = x; i != fa[lca][0]; i = fa[i][0]) ans[++tot] = i;
	for(int i = y; i != lca; i = fa[i][0]) ans[++tot] = i;
	sort(ans + 1, ans + tot + 1);
	for(int i = 1; i <= tot; i++) printf("%d ", ans[i]);
	exit(0);//相当于在main里 return 0;
}
inline void dfs(int x, int ff){
	vis[x] = 1, fa[x][0] = ff, dep[x] = dep[ff] + 1;
	for(int i = 1; i <= 17; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];
	for(int i = fir[x]; i ; i = nxt[i]){
		if(son[i] == ff) continue ;
		if(vis[son[i]]) print(x, son[i]);
		dfs(son[i], x);
	}
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%d%d", &u, &v);
		add(u, v), add(v, u);
	}
	tot = 0;
	dfs(1, 0);
	return 0;
}
```

可能本蒟蒻写得不太好，大佬请多多指教。

不会 LCA 其实没有关系，反正我们就做一遍，而且我们就算计算出 LCA 也要从 $x,y$ 往上跳到 $lca_{x,y}$ 的，所以不妨就直接跳了。

根上面的相比，不用倍增，但是多了一条从 $lca_{x,y}$ 到根节点的路径，但蒟蒻觉得这样子写风险小一点。

下面请各位大佬欣赏蒟蒻的纯暴力 LCA 写法。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, fir[N << 1], nxt[N << 1], son[N << 1], tot, u, v, fa[N], ans[N], lca, dep[N];
bool vis[N], aa[N];
inline void add(int x, int y){
    nxt[++tot] = fir[x];
    fir[x] = tot;
    son[tot] = y;
}
inline void print(int x, int y){
	lca = 0;
    for(int i = x; i ; i = fa[i]) vis[i] = 1;
	for(int i = y; i && !lca; i = fa[i]){
		if(!vis[i]) ans[++tot] = i;
		if(vis[i]) lca = i;
	}
	for(int i = x; i != fa[lca]; i = fa[i]) ans[++tot] = i;
    sort(ans + 1, ans + tot + 1);
    for(int i = 1; i <= tot; i++) printf("%d ", ans[i]);
    exit(0);
}
inline void dfs(int x, int ff){
    vis[x] = 1, fa[x] = ff, dep[x] = dep[ff] + 1;
    for(int i = fir[x]; i ; i = nxt[i]){
        if(son[i] == ff) continue ;
        if(vis[son[i]]) print(x, son[i]);
        dfs(son[i], x);
    }
}
int main(){
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d", &u, &v);
        add(u, v), add(v, u);
    }
    tot = 0;
    dfs(1, 0);
    return 0;
}
```

---

## 作者：XBaiC (赞：2)

### 思路：

拓扑判环：本题因为是树 + 一条边只有一个环且度为 $1$ 的点的邻接点只有一个。

1. 邻接表形式记录图并记录每一个顶点的度。

2. 度为 $1$ 的点和与其相连的边 一定不在环上。
3. 度为 $1$ 的点 一定只有一个邻接点。
4. 如果度为 $1$ 的点的邻接点在度数减 $1$ 后也变成了度为 $1$ 的点，那么这个点一定也不在环上。 
5. 在环上的点度都为 $2$。

### CODE：

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>
#include<set>
#include<queue> 
using namespace std;
const int inf=0x3fffffff;
const int maxn=100100;
 
int n;
int d[maxn]={0};
vector<int> Adj[maxn];
bool vis[maxn]={0};
 
void bfs(){
    
    queue<int> q;
    
    for(int i=1;i<=n;i++){
        
        if(d[i]==1){
            
            q.push(i);
            vis[i]=true;
        }
    }

    while(!q.empty()){
        
        int top = q.front();    q.pop();
        
        int len = Adj[top].size();
        
        for(int i=0;i<len;i++){
            
            int v = Adj[top][i];
            
            if( --d[v] == 1){
                
                q.push(v);
                vis[v]=true;
            }
        }
        
    }
    
}
 
int main(){
 
    
    cin>>n;
    
    int a,b;
    for(int i=0;i<n;i++){
        
        cin>>a>>b;
        
        d[a]++;
        d[b]++;
        
        Adj[a].push_back(b);
        Adj[b].push_back(a);
    }
    
    bfs();
    
    int flag=0;
    for(int i=1;i<=n;i++){
        
        if(vis[i]==true) continue;
        
        if(flag==0){
            
            flag=1;
        }else    
            cout<<" ";
        
        cout<<i;
    }
    
 
    return 0;
}
```
谁敢ctj我会吃了你的！！！

~~按管理要求不增加并查集判环 + dfs 的方法。~~

---

## 作者：ZZA000HAH (赞：1)

# 递归回溯法

## 题目大意
在一棵树上加上一条边，形成一个环，找出所有在环上的点。

这样的图叫作基环树，基环树是一个由 $n$ 个点及 $n$ 条边组成的联通图，其是由树增添一条边而来的，由于形成了一个环，所以称作基环树。

## 思路分析
我们可以先将图 dfs 一遍，找到一个在环上的点，然后从这个点出发，用递归回溯的方式找到在环上的所有顶点。

1. 通过 dfs 找环上的点时，如果一个图是一棵树，只需要判断向下递归的不是父节点（由此点递归而来）即可，这由树的性质而得。但是现在多了一条边，那么必然在递归的时候有一个顶点要被递归到两次，且这个点肯定在环上，那么我们可以用布尔数组标记一下，如果一个点被递归过然而又要去递归它时，那么这个点就是我们要找的那个在环上的点。
2. 递归回溯：现在我们已经找到了在环上的一个点，那么我们将它作为递归的起始点 $node$，如果是一颗树，那么从 $node$ 点递归最后肯定回不到 $node$ 点，但现在 $node$ 点在环上，那么按照正常的递归方式（不用布尔数组标记，仅传参父节点）会再次回到 $node$ 点，那么从 $node$ 点又回到 $node$ 点路径上的点就是我们要找的点。
3. 最后注意：这种递归回溯法只适用于正常逻辑上的由三个或三个以上顶点组成的环，但在图论中还有二元环这种特殊的环，即两个顶点中存在重边（~~两个 hack 数据均是二元环的测试数据~~），那么我们再特殊判断一下有没有重边即可（有重边的话就不用递归回溯了，多一条边只可能有一个环）。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
vector<int>G[N];
bool ins[N],vis[N];//ins[]--dfs 找环上点用,vis[]-- 递归回溯标记用
int node=0,n,fl;
map<string,int>mp;//判断重边用
void dfs(int x,int fa)
{
	ins[x]=1;
	for (size_t i=0; i<G[x].size(); i++)
	{
		int y=G[x][i];
		if (y==fa) continue;//父节点记得跳过
		if (ins[y])
		{
			node=y;//这就是我们需要的顶点
			continue;
		}
		dfs(y,x);
	}
}
void __dfs(int x,int fa)
{
	vis[x]=1;
	for (size_t i=0; i<G[x].size(); i++)//用 int i 有的编译器会报错
	{
		if (fl) return;//结束递归函数
		int y=G[x][i];
		if (y==fa) continue;
		if (y==node)//完美闭环
		{
			for (int i=1; i<=n; i++)
				if (vis[i]) printf("%d ",i);
			fl=1;
			return;
		}
		__dfs(y,x);
		vis[y]=0;//回溯
	}
}
int main()
{
	int x,y;
	scanf("%d",&n);
	for (int i=0; i<n; i++)
	{
		scanf("%d%d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);
		if (mp[to_string(x)+"to"+to_string(y)])//由于记录是记录的双向边,判断的时候判断一边即可
		{
			printf("%d %d",min(x,y),max(x,y));
			return 0;
		}
		else
		{
			mp[to_string(x)+"to"+to_string(y)]=1;
			mp[to_string(y)+"to"+to_string(x)]=1;
		}
	}
	dfs(1,0);
	__dfs(node,0);
	return 0;
}
```
##### End。

---

## 作者：_Wind_Leaves_ShaDow_ (赞：1)

~~好水啊，那我来水一篇题解。~~

题目就是要你在树上找环。那么我们想，怎么知道出现了环？

首先明确一点，在一棵树上，**任意两点有且只有一条路径使它们相连**。所以当我们发现原本就相连的点又要再连一次就知道出现了环。

是不是很像最小生成树里面的 Kurskal 算法？其实 Kruskal 的原理就是用并查集来判断两点是否联通，不连通就连一条边。和找环其实是一样的。

然后找环的操作就是 dfs 就好了，树上操作很多时候都要用到递归或者 dfs。

详见代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))

using namespace std;
const int N=1e5+114;

int n,fa[N];
bool vis[N];//不要重复访问
vector<int>v[N];

inline int find(int p){
	if(fa[p]!=p)fa[p]=find(fa[p]);
	return fa[p];
}

inline void dfs(int p,int e,vector<int>ans){//dfs 里面传 vector 参数
	vis[p]=1;
	if(p==e){
		sort(ans.begin(),ans.end());//从大到小
		for(auto i:ans)cout<<i<<' ';
		return;//因为每个点只访问一遍，不用担心还会有多余输出
	}
	for(auto i:v[p]){
		if(vis[i])continue;//访问过
		ans.push_back(i);//加进去
		dfs(i,e,ans);
		ans.resize(ans.size()-1);//删掉，其实这里用 pop_back() 一样的，但是这玩意比 pop_back() 快我是真没想到
	}
	return;
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		v[x].push_back(y);
		v[y].push_back(x);
		int fx=find(x),fy=find(y);
		if(fx==fy){
			vector<int>tmp;
			tmp.push_back(x);
			dfs(x,y,tmp);
		}else fa[fx]=fy;
	}
	return 0;
}
```

---

## 作者：kkksc1223 (赞：1)



## 题目分析

这是一道求环的题目，可以使用深度优先搜索（DFS）或广度优先搜索（BFS）来解决。

我们可以从任意一个节点开始，进行 DFS 或 BFS，如果在搜索过程中遇到了已经访问过的节点，那么就说明找到了环。

找到环之后，我们可以记录下环上的节点，然后继续搜索，直到所有的节点都被访问过为止。

## 代码实现

这里我们使用 DFS 来实现，具体实现过程如下：

1. 从任意一个节点开始，进行 DFS，记录下访问过的节点。
2. 如果在搜索过程中遇到了已经访问过的节点，那么就说明找到了环，记录下环上的节点。
3. 继续搜索，直到所有的节点都被访问过为止。

需要注意的是，我们需要记录下每个节点的父节点，以便在搜索过程中判断是否遇到了已经访问过的节点。

另外，我们可以使用一个栈来记录下搜索过程中的节点，以便在找到环之后，可以从栈中弹出环上的节点。


完整代码如下：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
typedef long long ll;
int n , xian[maxn],net[maxn<<1],u[maxn<<1],v[maxn<<1],d[maxn],cnt=1; // 定义变量
int q[maxn],f[maxn],du[maxn],zong; // 定义变量
ll g[maxn]; // 定义变量
void jia_ru(int x,int y,int z) // 添加边
{
    u[++cnt] = y , d[cnt] = z , net[cnt] = xian[x] , xian[x] = cnt;
    ++du[y];
}
void bfs(int x) // 广度优先搜索
{
    int l , r , now , y;
    l = r = 1;
    q[1] = x ;
    while (l <= r) 
    {
        now = q[l] , ++l , --du[now];
        for (int i = xian[now] ; i ; i = net[i]) 
        {
            if (du[y = u[i]] > 1) 
            {
                if (--du[y] == 1) 
                q[++r] = y;
            }
        }
    }
}
void dfs(int x) // 深度优先搜索
{
    int l , r , now , y;
    l = r = 1 , q[1] = x;
    f[++zong] = x ;
    while (l <= r) 
    {
        now = q[l] , ++l;
        for (int i = xian[now] ; i ; i = net[i]) 
        {
            if (du[y = u[i]] && !v[i]) 
            {
                v[i] = v[i^1] = 1;
                f[++zong] = y;
                g[zong] = g[zong - 1] + d[i];
                q[++r] = y;
                break; 
            }
        }
    }
}
int main()
{
    scanf("%d" , &n);
    for (int i = 1 ; i <= n ; ++i) 
    {
        int a , b , c;
        scanf("%d%d" , &a , &b );
        jia_ru(a , b , 1) , jia_ru(b , a , 1);
    }
    for (int i = 1 ; i <= n ; ++i) 
    {
        if (du[i] == 1) bfs(i);
    }
    for (int i = 1 ; i <= n ; ++i) 
    {
        if (du[i]) 
        {
            dfs(i);
            for (int j = 1 ; j <= zong ; ++j) 
            {
                du[f[j]] = 0;
            }
        }
    }
    sort(f+1,f+zong); // 排序
    for (int i = 1 ; i < zong ; ++i) 
    {
        printf ("%d " , f[i]); // 输出结果
    }
    return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

深搜。

从 $1$ 开始，标志每个点的父亲和访问记录，当此点已经访问过了，说明此点在环上，标记起点和终点。最后在主函数里从终点开始，跳到父亲上，到起点停止，把走过的点按编号排序，输出。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int n;
vector<array<int,2>> e[N];
bool st[N];
stack<int> stk;
vector<int> ans;

void dfs(int u,int f){
    if(st[u]){
        int t;
        do{
            t=stk.top();stk.pop();
            ans.push_back(t);
        }while(t!=u);
        sort(ans.begin(),ans.end());
        for(auto x:ans)cout<<x<<' ';
        exit(0);
    }
    st[u]=1;stk.push(u);
    for(auto [v,id]:e[u])if(id^f){
        dfs(v,id);
    }
    stk.pop();
}

int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        int u,v;cin>>u>>v;
        e[u].push_back({v,i});
        e[v].push_back({u,i});
    }

    dfs(1,0);
    
    return 0;
}
```

---

## 作者：_H17_ (赞：0)

## 题目分析

基环树找环模板题。

建图的时候用并查集随便找到一个环上的边 $(u,v)$，把这条边断掉形成一棵树，树上连接 $u,v$ 路径上的点就是环上的点。

## 证明

考虑一条链首尾相连就可以组成一个环，$u,v$ 之间的路径就相当于这个链，树的其他部分显然对题目没有影响。

---

## 作者：XBaiC (赞：0)

### 思路

并查集判环 + dfs 输出

并查集用来判断环的起始点和终止点。

用 dfs 遍历图，当符合要求时 输出环即可。

### CODE

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#include<cstring>
#include<vector>
#include<map>
#include<set>
using namespace std;
const int inf=0x3fffffff;
const int maxn=100100;
 
int n;
int start,stop;
int father[maxn];
vector<int> ans;
vector<int> Adj[maxn];
int vis[maxn];
 
 
void init(){
    
    for(int i=0;i<maxn;i++)
        father[i]=i;
        
}
 
int findFather(int x){
    
    if(father[x]==x) return x;
    
    return findFather(father[x]);    
}
 
bool Union(int a,int b){
    
    int fa = findFather(a);
    int fb = findFather(b);
    
    if(fa!=fb){
        
        father[fb]=fa;
        
//        cout<<fa<<" "<<fb<<endl;
        
        return true;
    }
        
    return false;
}
 
void dfs(int x){
    
     
     if(x==stop){
         
         sort(ans.begin(),ans.end());
         for(int i=0;i<ans.size();i++)
            cout<<ans[i]<<" ";
            
                     
         return ;
    }
     
     
     int len = Adj[x].size();
     for(int i=0;i<len;i++){
                 
         if(vis[ Adj[x][i] ] == false){
         
             vis[ Adj[x][i] ] = true;
            ans.push_back( Adj[x][i] );
            
             dfs( Adj[x][i] ) ;
            
            ans.pop_back() ;                 
        }             
    }
 
}
 
 
int main(){
 
    // ios::sync_with_stdio(false);
    // cin.tie(0),cout.tie(0);
    
    init();
    
    cin>>n;
        
    int a,b;
    
    for(int i=0;i<n;i++){
    
        cin>>a>>b;
        
        Adj[a].push_back(b);
        Adj[b].push_back(a);  
        
        bool flag = Union(a,b);
        if( flag == false ){
            
             start = a;
             stop = b;
        }
    }
    
    vis[start]=true;
    ans.push_back( start );
    dfs( start );
 
 
    return 0;
}
```


---


# [蓝桥杯 2017 国 B] 对局匹配

## 题目描述

小明喜欢在一个围棋网站上找别人在线对弈。这个网站上所有注册用户都有一个积分，代表他的围棋水平。

小明发现网站的自动对局系统在匹配对手时，只会将积分差恰好是 $K$ 的两名用户匹配在一起。如果两人分差小于或大于 $K$，系统都不会将他们匹配。

现在小明知道这个网站总共有 $N$ 名用户，以及他们的积分分别是 $A_1,A_2, \cdots A_N$。

小明想了解最多可能有多少名用户同时在线寻找对手，但是系统却一场对局都匹配不起来（任意两名用户积分差不等于 $K$）？

## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 10$。

对于 $100\%$ 的数据，$1 \le N\le 10^5$，$0\le K,A_i \le 10^5$
。

时限 1 秒, 256M。蓝桥杯 2017 年第八届国赛

## 样例 #1

### 输入

```
10 0
1 4 2 8 5 7 1 4 2 8```

### 输出

```
6```

## 样例 #2

### 输入

```
10 1
2 1 1 1 1 4 4 3 4 4```

### 输出

```
8```

# 题解

## 作者：xiaoxiaoxia (赞：17)

### 题目分析：
题目给定了 $N$ 名用户的积分，以及系统只会匹配积分差为 $K$ 的两名用户。现在需要计算最多有多少名用户在线寻找对手时，系统却一场对局都匹配不起来。
### 解题思路：
1. 用一个数组 $a$ 记录每个积分出现的次数。
2. 遍历数组，用贪心算法计算无法匹配的用户数。
### 解题步骤：
1. 读取输入，得到用户数量 $n$ 和积分差 $k$。
2. 遍历用户，读取每个用户的积分 $x$，并在数组 $a$ 中增加对应的计数。
3. 初始化无法匹配的用户数 $ans$ 为 $0$。
4. 如果 $k$ 等于 $0$，说明只有积分相同的用户才能匹配，遍历数组 $a$，统计有积分的用户数，输出结果并返回。
5. 遍历数组 $a$ 中的积分 $i$（$0$ 到 $\text{MAXN}-k$），对于每个积分 $i$，计算无法匹配的用户数：
- 如果$a_{i} < a_{i+k}$，说明积分差为 $k$ 的用户更多，将 $a_{i+k}$ 减去$a_{i}$。
- 否则，将 $a_{i+k}$ 置为 $0$。
6. 遍历数组 $a$ 中的积分 $i$（$0$ 到 $\text{MAXN}-k$），累加无法匹配的用户数。
7. 输出结果。
### 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100010
int a[MAXN];
int n, k, x;
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=0;i<n;i++) 
	{
		scanf("%d",&x);
		a[x]++; 
	} 
	int ans=0;
	if(k==0) 
	{
		for(int i=0;i<MAXN;i++)
		{
			if(a[i]) 
			{
				ans++;
			}
		}
		printf("%d\n",ans);
		return 0;
	}
	for(int i=0;i<MAXN-k;i++) 
	{
		if( a[i]<a[i+k]) 
		{
			a[i+k]-=a[i];
		} 
		else 
		{
			a[i+k]=0;
		}
	}
	for (int i=0;i<MAXN-k;i++) 
	{
		ans+=a[i];
	}
	printf("%d\n",ans);
	return 0;
} 
```


---

## 作者：_buzhidao_ (赞：12)

[题面传送门](/problem/P8656)
# 题目分析
本题考虑桶排序，统计积分为不同值的用户个数。

当 $k=0$，相同积分的用户只能选择一个，所以输出积分不同的用户数即可。
## 题目简化I
给定 $N$ 件物品，每件物品价值为 $a_i$，选定第 $i$ 件物品就不能再选择第 $i-K$、$i+K$ 件物品，每件物品最多选择一次。求可能获得的最大价值。
### 分析
> 简化中的物品数相当于用户积分的最大值加一，第 $i$ 件物品相当于积分为 $i-1$ 的用户，它的价值相当于积分为 $i-1$ 的用户数量。

若我们选择第 $1$ 件物品，则我们不能选择第 $K+1$ 件物品；

若我们选择第 $K+1$ 件物品，则我们不能选择第 $1$、$2K+1$ 件物品；

若我们选择第 $2K+1$ 件物品，则我们不能选择第 $K+1$、$3K+1$ 件物品……

所以我们可以发现，第 $1,K+1,2K+1,3K+1,...$ 件物品中，相邻两项不能同时选择。

同理，第 $2,K+2,2K+2,3K+2,...$ 件物品中，相邻两项不能同时选择。

第 $1,2,...,K$ 件物品相互独立。
## 题目简化II
已知一个序列 $b$ 有 $n$ 个数，求这个序列中不相邻数的和的最大值。
### 分析
> 这个序列代表第 $1,K+1,...$ 件物品或第 $2,K+2,...$ 件物品等序列中的一个序列，性质可以和物品序列类比。

考虑动态规划，$dp_i$ 表示序列中前 $i$ 个数中不相邻数的和的最大值。

- 若不选择第 $i$ 项，易证最大值即为 $dp_{i-1}$。

- 若选择第 $i$ 项，最大值为 $dp_{i-2}+b_i$。 

所以：
- 当 $i=1$，$dp_i=b_1$。

- 当 $i=2$，$dp_i=\max(b_1,b_2)$。

- 否则，$dp_i=\max(dp_{i-1},dp_{i-2}+b_i)$。

# 解题思路
令用户积分最大值为 $m$。

先将输入的数据桶排序，统计拥有相同积分的用户数量。

再将序列分割成 $K$ 个部分。

想实现这个效果，我们可以进行两重循环。外循环 $i$ 从 $0$ 到 $k-1$，增量为 $1$；内循环 $j$ 从 $i$ 到 $m$，增量为 $k$。

然后在内循环中使用动态规划。注意数组从 $0$ 开始且增量为 $k$，状态转移方程会和上述的有些不同。

最后计算 $dp_{m-K+1}$ 到 $dp_m$ 的和作为答案输出即可。
# AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &x){//快读
	x=0;int f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	x*=f;
}
int n,k,tmp,s[100005],ma,ans,dp[100005];
int main(){
	read(n);read(k);
	for(int i=1;i<=n;++i) read(tmp),++s[tmp],ma=max(ma,tmp);//桶排序的同时计算m
	if(k==0){//特判
		for(int i=0;i<=ma;++i) if(s[i]) ++ans;
		cout<<ans;return 0;
	}
	for(int i=0;i<k;++i){//外循环
		for(int j=i;j<=ma;j+=k){//内循环
			if(j-i==0) dp[j]=s[j];//对应上文i=1
			else if(j-i==k) dp[j]=max(s[j-k],s[j]);//对应上文i=2
			else dp[j]=max(s[j]+dp[j-2*k],dp[j-k]);//对应上文否则
		}
	}
	for(int i=ma-k+1;i<=ma;++i) ans+=dp[i];//统计答案
	cout<<ans;
	return 0;
}
```

---

## 作者：zhjx2023 (赞：7)

### 思路
这道题目的目标是找出最多可能同时在线寻找对手，但是系统却无法匹配的用户数量。为了解决这个问题，我们可以使用计数排序的思想。

首先，我们需要统计每个积分对应的用户数量。我们可以定义一个数组 $a$，其中 $a[i]$ 表示积分为 $i$ 的用户数量。然后，我们遍历输入的积分数组，将相应积分的用户数量加一。

接下来，我们分两种情况讨论。

当 $K$ 为 $0$ 时，任意两个用户的积分差都不会等于 $0$，因此答案为不等于 $0$ 的 $a[i]$ 的数量之和。

当 $K$ 不为 $0$ 时，我们需要遍历积分数组，并更新数组 $a$。对于每个积分 $i$，我们检查是否存在积分为 $i - K$ 的用户数量小于积分为 $i$ 的用户数量。如果存在，则将积分为 $i$ 的用户数量减去积分为 $i - K$ 的用户数量；否则，将积分为 $i$ 的用户数量设为 $0$。

最后，我们将数组 $a$ 中的所有元素相加，得到的结果就是答案。

[AC记录](https://www.luogu.com.cn/record/143510039)

### 下面是代码，不能直接复制哦

```cpp
#include <bits/stdc++.h>
//#define cin std:cin
//#define cout std:cout
#define ll l0ng l0ng
using namespace std;
const ll N = 1e5 + 5;
ll n, k, tmp, cnt, a[N];
int main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for (ll i = 1; i <= n; i++)	cin >> tmp, a[tmp]++;
	if (!k) {
		for (ll i = 0; i < N; i++)	cnt += !(a[i] == 0);
		cout << cnt;
		return 0;
	}
	for (ll i = 0; i < N - k; i++)
		if (a[i] < a[i + k])	a[i + k] -= a[i];
		else	a[i + k] = 0;
	for (ll i = 0; i < N - k; i++)	cnt += a[i];
	cout << cnt;
	return 0;
}
```

---

## 作者：liaoxingrui (赞：4)

## Content

给你一个 $N$ 个数的非负整数数列 $A$ 和一个非负整数 $K$，让你求出数列中最多有多少个数与其他任意一个之数差不等于 $K$。

## Solution

注意观察 $K$ 的数据范围，

$0 \le K \le 10^5$

所以我们可以分类讨论 $K$ 的数值。

1. 当 $K = 0$ 时

因为是差不等于 $K$，所以说数值相同的我们就直接排除了，要求的答案就是有多少个不同的数值。

2. 当 $K \neq 0$ 时

如果说数值为 $x$ 的数量小于数值为 $x + K$ 的数量，那么我们可以假设保留 $x + K$ 的数值是正解。

但是如果数值为 $x + K$ 的数量也小于 $x + 2K$ 的数值数量，那么此时舍去数值为 $x$ 的方法就并不是正解，将数值为 $x + K$ 的数量减去一个数值为 $x$ 的数量才是正解。

如果数值为 $x$ 的数量大于等于数值为 $x + K$ 的数量，那么我们才将数值为 $x + K$ 的舍去。

而数值相同，数值为 $x$ 的数量这些都符合桶，所以我们可以用桶来实现。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int N,K,A[100005],tj[100005],ans;
//N,K,A数组按题目意思来，tj数组是桶数组，ans是答案
signed main(){
	ios::sync_with_stdio(false);//优化 
	cin.tie(0);
	cout.tie(0);
	cin>>N>>K;
	for(int i=1;i<=N;i++){
		cin>>A[i];
		tj[A[i]]++;//输入时统计
	}
	if(K==0)//特判k=0的情况 
		for(int i=0;i<=100000;i++)
			ans+=(tj[i]>0?1:0);
	else{//k!=0的情况 
		for(int i=0;i<=100000-K;i++)//因为是判断如果i>100000-K的话，那么数组会越界
			tj[i+K]-=(tj[i]<tj[i+K]?tj[i]:tj[i+K]);
		for(int i=0;i<=100000-K;i++)//将答案加起来 
			ans+=tj[i];
	}
	cout<<ans; 
	return 0;
}
```

---

## 作者：TheSky233 (赞：3)

## Solution

[也许更好的阅读体验](https://www.cnblogs.com/TheSky233/p/17043410.html)
。

我们注意到，如果 $a_i \bmod k \neq a_j \bmod k$，那么这两种实力的人是互不影响的，也就是说，和 $a_i$ 有关的选择和和 $a_j$ 有关的选择毫无关系，我们考虑把 $\{a\}$ 按照 $a_i\bmod k$ 的值分成 $k$ 类。

在每一类中，我们先排序，再去重成不重复的元素，然后就是经典的线性 dp 了：设 $f_{i,0/1}$，表示第 $i$ 个元素结尾最多能取 $f_{i,0/1}$ 个人。取第 $i$ 个即为 $f_{i,1}$，否则为 $f_{i,0}$。

于是状转方程就很容易推了，设 $d_i$ 为 $a_i$ 的出现次数，$p$ 为 $a_i \bmod k$ 的值：

$$f_{i,1}=\begin{cases}d_i & \text{If } i=0 \\ f_{i-1,0}+d_i & \text{If } (a_{p,i}-a_{p,i-1}) = k \\ \max(f_{i-1,0},f_{i-1,1})+d_i & \text{Otherwise.}\end{cases}$$

$$f_{i,0}=\begin{cases}0 & \text{If } i=0 \\ \max(f_{i-1,1},f_{i-1,0}) & \text{Otherwise.}\end{cases}$$

注意当 $(a_{p,i}-a_{p,i-1}) = k$ 时只能选一种。以及 dp 数组记得每一次之前都要初始化。

记得当 $k=0$ 的时候要特判，其最优解即为每个元素都选**一个**，不判的话在 C++ 中 $a_i \bmod 0$ 会 RE。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
const int mod = 1e9 + 7;

inline int read() {
	int x(0),f(0);
	char ch=getchar();
	for(; !isdigit(ch); ch=getchar()) f|=(ch=='-');
	for(;  isdigit(ch); ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
	return f?-x:x;
}

int n,k,ans;
int a[N],d[N],g[N];
int dp[N][2];
vector<int> v[N];

int main() {
	n=read(), k=read();
	for(int i = 1; i <= n; i++) a[i]=read(),d[a[i]]++;;
	sort(a+1, a+n+1);
	int m = unique(a+1, a+n+1)-a-1;
	if(k == 0) {
		printf("%d\n", m);
		return 0;
	}
	for(int i = 1; i <= m; i++) {
		g[a[i]]++;
		if(g[a[i]] == 1)
			v[a[i] % k].push_back(i);
	}
	// dp
	for(int i = 0; i < k; i++) {
		if(v[i].empty()) continue;
		int siz = v[i].size();
		memset(dp, 0x3f, (siz + 5) * sizeof(dp[0][0]));
		for(int j = 0; j < siz; j++) {
			if(j == 0) dp[0][1] = d[a[v[i][j]]], dp[0][0] = 0;
			else if((a[v[i][j]] - a[v[i][j-1]]) == k) {
				dp[j][0] = max(dp[j-1][1], dp[j-1][0]);
				dp[j][1] = dp[j-1][0] + d[a[v[i][j]]];
			} else {
				dp[j][0] = max(dp[j-1][1], dp[j-1][0]);
				dp[j][1] = max(dp[j-1][1], dp[j-1][0]) + d[a[v[i][j]]];
			}
		}
		ans += max({dp[siz - 1][0], dp[siz - 1][1]});
	}
	printf("%d\n",ans);
}
```


---

## 作者：lqsy002 (赞：2)

## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P8656)。

## 解题思路
先分组，再动态规划。

1. 根据数字对 $k$ 取模的值的不同分成 $k$ 组，因为对 $k$ 取模为 $0$ 的数的下一个可能相差为 $k$ 的数只可能是对 $k$ 取模同样为 $0$ 的。

2. 动态规划是对每个组内的元素进行动态规划，算出每个组内的最大值。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int num[100005],val[100005],dp[100005];
int n,k,m,sum,t;
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        cin>>m;
        num[m]++;
    }
    if(k==0){
        for(int i=0;i<=N-5;i++)
            if(num[i]) 
                sum++;
        cout<<sum;
        return 0;
    }
    for(int i=0;i<k;i++){
        t=0;
        for(int j=i;j<=100000;j+=k)
            val[t++]=num[j];
        dp[0]=val[0];
        for(int j=1;j<t;j++){
            if(j==1)  
                dp[j]=max(dp[0],val[j]);
            else 
                dp[j]=max(dp[j-2]+val[j],dp[j-1]);
        }
        sum+=dp[t-1];
    }
    cout<<sum;
    return 0;
}
```

---

## 作者：BLuemoon_ (赞：2)

[link](https://www.luogu.com.cn/problem/P8656)

## 题意

匹配对手。只有实力差 **刚好** 为 $k$ 时才会将两人匹配到一起。问在一对都匹配不上的情况下，最多可以选几个人。

## 思路

开桶记录每个数出现了几次，然后分类讨论

1. $m = 0$

只有分数相同才会匹配，统计有多少个不同的分数即可。

2. $m \not= 0$

遍历桶，如果 $a_i < a_{i + k}$ 则将 $a_{i + k} \gets a_{i + k} - a_i$，否则 $a_{i + k} \gets 0$。

最后统计未匹配上的人的个数。

## 代码

```cpp
// J2023 | BLuemoon_
#include<bits/stdc++.h>

using namespace std;

const int kMaxN = 1e5 + 5;

int n, k, x, ans, a[kMaxN];

int main()
{
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        a[x]++;
    } 
    if(!k) {
        for (int i = 0; i < kMaxN; i++) {
            ans += a[i] != 0;
        }
        cout << ans << '\n';
        return 0;
    }
    for (int i = 0; i < kMaxN - k; i++) {
        a[i + k] = (a[i] < a[i + k] ? a[i + k] - a[i] : 0);
    }
    for (int i = 0; i < kMaxN - k; i++) {
        ans += a[i];
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：liupei (赞：2)

## 思路
使用哈希表

对于一个用户 $A_i$，如果存在另一个用户 $A_j$ 满足 $A_i - A_j = K$ 或者 $A_j - A_i = K$，则说明 $A_i$ 无法匹配到一名对手。因此我们可以使用一个哈希表记录所有的用户积分出现的次数，然后对于每个用户 $A_i$，在哈希表中查询 $A_i \pm K$ 出现的次数，将二者之和累加到答案中。
### 时间复杂度
使用哈希表维护每个积分出现次数的时间复杂度为 $O(n)$，对于每个用户查询哈希表的时间复杂度为 $O(1)$，因此总时间复杂度为 $O(n)$。

---

## 作者：Darkworldmystery (赞：2)

原题链接：[P8656 [蓝桥杯 2017 国 B] 对局匹配](https://www.luogu.com.cn/problem/P8656)

## 题意

一个匹配系统，让两个积分相差为 $k$ 的人匹配在一起。求在没有一个人可以匹配上的前提下，最多选的人数。

## 思路

因为题目不要将积分相差为 $k$ 的两个人匹配在一起，所以 $k$ 的数值一定是我们要重点考虑的。

大致讲 $k$ 的值可以分为两类：

1.$k = 0$。

2.$k \neq 0$。

我们可以考虑维护一个桶 $t$ 来统计每一个积分的人的数量。

如果 $k = 0$，在这里，因为只有积分相差为 $0$ 的两个人才会被匹配，所以我们可以考虑统计有多少个不同的分数。

如果 $k \neq 0$，我们考虑维护当前的积分 $i$，求题目要求我们的匹配不到的人数。

因为两个人可以匹配上的积分差距必须为 $k$，那么我们可以看这两个积分的值所对应的桶，下标分别是：$i, i + k$，现在不能让他们两个同时共存，所以需要让多的减去小的，剩下的就是匹配不上的人数了。即：

如果 $t_i \gt t_{i + k}$，那么积分为 $i$ 最多的人数就是 $t_{i + k} - t_i$。

如果 $t_i \lt t_{i + k}$，那么将 $t_{i + k}$ 设为 $0$，因为人比 $t_i$ 少所以人被匹配没了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, k, a[N], ans, cnt[N];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> k;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
        cnt[a[i]]++;
    }
    if(k == 0)
    {
        for(int i = 0; i <= 100000; i++)
            if(cnt[i])
                ans++;
        cout << ans;
        return 0;
    }
    for(int i = 0; i <= 100000 - k; i++)
    {
        if(cnt[i] < cnt[i + k])
            cnt[i + k] -= cnt[i];
        else   
            cnt[i + k] = 0;
    }
    for(int i = 0; i <= 100000 - k; i++)
        ans += cnt[i];
    cout << ans;
    return 0;
}
```


---

## 作者：whx2009 (赞：1)

## 本题题解：
这道题其实很简单，我们只需要开一个桶，因为范围很小所以不会超空间。

我们可以分成两个部分分开计算，一种是当 $k$ 为零时，我们只需要把每个积分段除以二相加即可。另一种是不为零时，我们只需要找到比当前积分多 $k$ 的积分段有多少人，然后把总人数减去他们中小的，再分别减去相应的人数，最后输出总人数。
## 本题代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000001];
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		a[x]++;
	}
	if(m==0)
	{
		for(int i=0;i<=100000;i++)
		{
			n-=a[i]/2;
		}
	}
	if(m!=0)
	 for(int i=0;i<=100000;i++)
	 {
		if(a[i]!=0 && a[i+m]!=0)
		{
			n-=min(a[i],a[i+m]);
			a[i+m]=max(a[i+m]-a[i],0);
		}
  	 }
	cout<<n;
	return 0;
}

```


---

## 作者：filletoto (赞：0)

## 思路

首先枚举 $0$ 到 $k$，然后在这个元素上迭代加 $k$，每个元素保存两个状态，于是我们不妨考虑递推过去。

由于我们只是尽可能选更多的数，也就是如果这个元素可以选，那么所有这么大的元素都可以选，也就是说我们要提前把这些元素的数量都统计下来，到时候计算可行数据时，直接调用。

如果这个元素取，那么就为

$dp_{i,1} = dp_{i-k,0}+ number_i$。

如果这个元素不取，那么就为

$dp_{i,0} = \max ( dp_{i-k,0},dp_{i-k,1} )$。

## 代码
[AC记录](https://www.luogu.com.cn/record/123643399)
```cpp
#include <iostream>
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-f;
		ch=getchar(); 
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
int n,k,a[100005],maxn,dp[100005][2];
int main()
{
	ios::sync_with_stdio(false);
	n=read();
	k=read();
	for(int i=1;i<=n;i++)
	{
		int t=read();
		a[t]++;
		maxn=max(maxn,t);
	}
	int sum=0;
	if(k==0) 
	{
		for(int i=0;i<=maxn;i++)
			if (a[i]!=0)
				sum++;
	} 
	else 
	{
		for(int i=0;i<k;i++) 
		{
			for(int j=i;j<=maxn;j+=k) 
			{
				if(j<k) 
				{
					dp[j][0]=0;
					dp[j][1]=a[i];
				} 
				else
				{
					dp[j][0]=max(dp[j-k][0],dp[j-k][1]);
					dp[j][1]=dp[j-k][0]+a[j];
					if (j+k>maxn)
						sum+=max(dp[j][0], dp[j][1]);
				}
			}
		}
	}
	cout << sum << endl;



	return 0;
}
```

---

## 作者：liangbob (赞：0)

### P8586 题解

显然的贪心。

如果 $k=0$，直接统计有多少个不同个数即可，因为但凡选一个相同的都不满足。

否则，贪心地解决问题，过程如下：

- 若 $i$ 的个数比 $i + k$ 的个数小，直接更新 $i+k$ 的个数，让它减去 $i$ 的个数。

- 否则，让 $i+k$ 的个数设为 $0$，因为它已经被匹配得干干净净了。

最后统计所有 $0$ 到 $100000-k$ 的个数之和就是答案。（只统计较小的，因为较大的被拿去匹配了）

由于该方法每次总是拿小的去匹配大的，因此不会重复。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;

int p[N];

int main()
{
	int n, k;
	cin >> n >> k;
	for(int i = 1;i <= n;i++)
	{
		int t;
		cin >> t;
		p[t]++; //计数
	}
	if(!k)
	{
		int ans = 0;
		for(int i = 0;i <= 100000;i++) ans += (p[i] ? 1 : 0); //统计不同的数的个数
		cout << ans << endl;
	}
	else
	{
		int ans = 0;
		for(int i = 0;i <= 100000 - k;i++)
		{
			if(p[i])
			{
				if(p[i] < p[i + k]) //如果小
				{
					p[i + k] -= p[i]; 
				}
				else
				{
					p[i + k] = 0;
				}
			}
		}
		for(int i = 0;i <= 100000 - k;i++) //统计剩余的
		{
			ans += p[i];
		}
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

## 题目描述

[SMALL - Smallest Number](https://www.luogu.com.cn/problem/SP22461)

### 注意事项

本题用了桶排的思想，不会的同学先看看[这个](https://blog.csdn.net/m0_64036070/article/details/123826962?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8%3D)。

## 算法思路

#### 算法：贪心

用一个 $tong$ 数组存贮 $a_i$ 出现的次数。

我们按情况分成以下几类：

1：$k = 0$

因为只有积分相同的人才能匹配到，所以只要统计不同积分的用户数就行了。

2：$k \ne 0$

遍历 $tong_i$,对于每个积分 $i$ ，计算不能匹配到的用户数：

- 如果 $tong_i < tong_{i+k}$，说明积分差为 $k$ 的用户更多，将 $tong_{i+k}$ 减掉 $tong_i$。

- 否则就将 $tong_{i+k} = 0$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//不开long long见祖宗 
const ll N=100010;
ll n,m,a[N],tong[N],ans;//ans表示答案 
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);//输入输出优化（关同步） 
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		tong[a[i]]++;//记录次数 
	}
	if(m==0)//分类讨论，如果m=0 
	{
		for(int i=0;i<=100000;i++)//统计不同积分的用户数
		{
			if(tong[i])
			{
				ans++;
			}
		}
		cout<<ans<<"\n";
	}
	else//分类讨论，如果m!=0 
	{
		for(int i=0;i<=100000-m;i++)
		{
			if(tong[i]<tong[i+m])//如果tong[i]<tong[i+m] 
			{
				tong[i+m]-=tong[i];//tong[i+m]-=tong[i]
			}
			else//否则 
			{
				tong[i+m]=0;//tong[i+m]=0
			}
		}
		for(int i=0;i<=100000-m;i++)
		{
			ans+=tong[i];
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```

---


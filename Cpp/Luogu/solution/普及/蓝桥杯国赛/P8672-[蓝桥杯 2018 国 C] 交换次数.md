# [蓝桥杯 2018 国 C] 交换次数

## 题目描述

IT 产业人才需求节节攀升。业内巨头百度、阿里巴巴、腾讯（简称 BAT）在某海滩进行招聘活动。

招聘部门一字排开。由于是自由抢占席位，三大公司的席位随机交错在一起，形如：

`ABABTATT`，这使得应聘者十分别扭。

于是，管理部门要求招聘方进行必要的交换位置，使得每个集团的席位都挨在一起。即最后形如：

`BBAAATTT` 这样的形状，当然，也可能是：

`AAABBTTT` 等。

现在，假设每次只能交换 $2$ 个席位，并且知道现在的席位分布，

你的任务是计算：要使每个集团的招聘席位都挨在一起需要至少进行多少次交换动作。

## 说明/提示

输入字符串的长度 $n$ 不大于 $10^5$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
TABTABBTTTT```

### 输出

```
3```

## 样例 #2

### 输入

```
TTAAABB```

### 输出

```
0```

# 题解

## 作者：wuhan1234 (赞：21)

## 1. 编程思路。

题目中的字母有 B、T、A 这 $3$ 种，$3$ 种字母有 $6$ 种排列方式（BAT、BTA、ABT、ATB、TAB、TBA），对每种排列方式求出其最少的交换次数，取 $6$ 个最少交换次数的最小值就是所求的答案。
下面我们来讨论将只包含 $A$、$B$、$C$ 三种字母的字符串 $S$ 按 $ABC$ 进行排列需要的最少交换次数。

先统计出字符串 $S$ 中 $A$、$B$、$C$ 三种字母各自的个数，不妨分别记为 $acnt$、$bcnt$、$ccnt$。字符串 $S$ 按要求排列好后，应该分成 $A$、$B$、$C$ 三段（或三个区域），其中第 $1$ 段应该是 $acnt$ 个 $A$，第 $2$ 段应该是 $bcnt$ 个 $B$，第 $3$ 段应该是 $ccnt$ 个 $C$。

我们先考察第 $1$ 段，这一段应该全部放字母 $A$。第 $1$ 段不是字母 $A$ 的字符肯定要换到后面的两段中去，其个数记为 $f1t23$（表示需要从第 $1$ 段换到后面的第 $2$、$3$ 两段的非 $A$ 字母个数）。但是这个不是 $A$ 的字符究竟换到后面的哪一段还是有讲究的，如果是字母 $B$，显然换到第 $2$ 段更好些，为此也统计出第 $1$ 段中优先换到第 $2$ 段的字母 $B$ 的个数，记为 $f1t2$。

再考察第 $2$ 段，这一段应该放 $bcnt$ 个字母 $B$。不是字母 $B$ 的字符 $A$ 肯定要换到第 $1$ 段，其个数记为 $f2t1$，字符 $C$ 肯定要换到第 $3$ 段，其个数记为  $f2t3$。

前 $2$ 段全部排好了，剩下的第 $3$ 段肯定会排好，就不再考察了。

在前面的考察中，若 $f1t2= f2t1$，也就是说第 $1$ 段正好有 $x$ 个 $B$ 需要换到第 $2$ 段，而第 $2$ 段中正好有 $x$ 个 $A$ 需要换到第 $1$ 段，则它们直接交换肯定皆大欢喜，交换次数也最少。这种情况下，需要的最少交换次数为 $f1t23+f2t3$。注意：$f1t23$ 次数中包括 $f1t2$ 次数的。

若 $f1t2<f2t1$，此时第 $2$ 段有 $f2t1$ 个 $A$ 需要换到第 $1$ 段，但第 $1$ 段可以换过来的 $B$ 只有 $f1t2$ 个，不够，但第 $2$ 段的 $A$ 是必须换到第 $1$ 段的，因此，只能先将第 $1$ 段的 $f2t1-f1t2$ 个 $C$ 先换到第 $2$ 段，最后再将这 $f2t1-f1t2$ 个 $C$ 交换到第 $3$ 段。因此，需要的最少交换次数为
 $f1t23+f2t3+f2t1-f1t2$。
 
若 $f1t2>f2t1$，此时第 $2$ 段只有 $f2t1$ 个 $A$ 需要换到第 $1$ 段，但第 $1$ 段可以换过来的 $B$ 却有 $f1t2$ 个，多了。将这些多余的 $B$ 先换到第 $3$ 段中，到时会在第 $2$ 段的 $C$ 必须交换到第 $3$ 段时与它们交换，换回到第 $2$ 段，不会多增加交换次数。因此，需要的最少交换次数为
 $f1t23+f2t3$。
 
所以，当 $f1t2<f2t1$ 时，最少交换次数为  $f1t23+f2t3+f2t1-f1t2$。这点也可以这样理解。在第 $1$ 段的 $f1t23$ 个非 $A$ 字母交换完成后，第 $2$ 段字母 $C$ 的个数就是交换前第 $2$ 段 $C$ 的个数（$f2t3$）加上从第 $1$ 段换过来的 $C$ 的个数（$f2t1-f1t2$）。

当 $f1t2\ge f2t1$ 时，最少交换次数为 $f1t23+f2t3$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int calc(char s[],char a,char b,char c) // 将字符串s 按 ABC 顺序排列需要的最少交换次数
{
    int acnt=0,bcnt=0,ccnt=0;
    int f1t23=0,f1t2=0,f2t1=0,f2t3=0;
    int i;
    for (i=0;i<strlen(s);i++)       // 统计字符串 s 中 A、B、C三种字符各自的个数
    {
        if (s[i]==a) acnt++;
        else if (s[i]==b) bcnt++;
        else ccnt++;
    }
    for (i=0;i<acnt;i++)          // 先看第1段,应该放acnt个字符A
    {
        if (s[i]!=a) f1t23++;      // 第1段不是A的字符要换到后面2、3两段中
        if (s[i]==b) f1t2++;       // 第1段是B的字符，优先换到第2段中
    }
    for (i=acnt;i<acnt+bcnt;i++)  // 再第2段的情况，应该放bcnt个字符B
    {
        if (s[i]==a) f2t1++;      // 第2段中的A 肯定换到第1段中
        if (s[i]==c) f2t3++;      // 肯定要换到第3段去
    }
    int  res = f1t23 + f2t3 ;
    if (f2t1>f1t2) res+=(f2t1 -f1t2);
    return res;
}
int main()
{
    char s[100005];
    scanf("%s",s);
    char c[][4]={"BAT","BTA","ABT","ATB","TAB","TBA"};
    int ans=0x7f7f7f7f;
    int i;
    for (i=0;i<6;i++)
    {
        int t=calc(s,c[i][0],c[i][1],c[i][2]);
        if (t<ans) ans=t;
    }
    printf("%d\n",ans);
    return 0;
}

```




---

## 作者：lqsy002 (赞：5)

## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P8672)。

## 解题思路

有六种排列方式，可分为三个区 A，B，C。

交换次数为（A 区非 A 个数）加上（B 区 C 的个数）加上（B 区 A 的个数）减去 （A 区 B 的个数与 B 区 A 的个数中的较小值）。

比较六种排列中，交换次数最小的即为答案。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int ans=0x3f3f3f3f;
char p[6][4]={"ABT","ATB","BAT","BTA","TAB","TBA"};
int changes(char A,char B,char C){
    int a=0,b=0,num=0,numb=0,numa=0,numc=0,len=s.length();
    for(int i=0;i<len;++i){
        if(s[i]==A)
            ++a;
        else if(s[i]==B)
            ++b;
    }
    for(int i=0;i<a;++i){
        if(s[i]!=A)
            ++num;
        if(s[i]==B)
            ++numb;
    }
    for(int i=a;i<a+b;++i){
        if(s[i]==A)
            ++numa;
        if(s[i]==C)
            ++numc;
    }
    num+=numa+numc-min(numa,numb);
    return num;
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>s;
    for(int i=0;i<6;++i)
        ans=min(ans,changes(p[i][0],p[i][1],p[i][2]));
    cout<<ans;
    return 0;
}
```

---

## 作者：fish_gugu (赞：2)

### [传送门](https://www.luogu.com.cn/problem/P8672)


------------

## 思路

经过读题和一系列分析，发现，有这六种顺序：$ABT$、$ATB$、$TAB$ 、$TBA$、$BTA$、$BAT$，后三个其实就是**把字符串倒序后再排**。分别把这几种依次排，然后记**最小**的交换次数就好。用递归的话，**字符数大会导致栈溢出**。所以我这里没有用递归。

## 代码
```c
#include <bits/stdc++.h>
using namespace std;
const int INF = 0x3f3f3f3f;
int func(string s,char A,char B,char C)
{
    int a = 0,b = 0,c = 0;
    int Abc = 0,Ab = 0,Ba = 0,Bc = 0,res;
    for(int i = 0;i < s.size();i++)
    {
        if(s[i] == A) a++;
        if(s[i] == B) b++;
        if(s[i] == C) c++;
    }
    for(int i = 0;i < a;i++)
    {
        if(s[i] != A) Abc++;
        if(s[i] == B) Ab++;
    }
    for(int i = a;i < a + b;i++)
    {
        if(s[i] == A) Ba++;
        if(s[i] == C) Bc++;
    }
    res = Abc + Bc + Ba - min(Ba,Ab);
    return res;
}
int main()
{
	string s;
	cin >> s;
    int min = INF;
    int res; 
    char c[][4]={"BAT","ATB","TBA","BTA","ABT","TAB"};
    for(int i = 0;i < 6;i++)
    {
        res = func(s,c[i][0],c[i][1],c[i][2]);
        if(res < min) min = res;
    }
    cout << min << endl;
    return 0;
}
```

---

## 作者：cff_0102 (赞：2)

最后的排列只有六种情况，分别为 `A...AB...BT...T`，`A...AT...TB...B`，`B...BA...AT...T`，`B...BT...TA...A`，`T...TA...AB...B`，`T...TB...BA...A`。可以直接枚举这六种情况，然后计算交换次数，取最小值即可。计算交换次数的方法见代码中的函数 `calc`。

```cpp
#include<bits/stdc++.h>
using namespace std;
int calc(int ab,int at,int ba,int bt,int ta,int tb){//变量 xy 表示要从 x 区域换到 y 区域的字母个数
	int ans=0;
	ans+=min(ab,ba);
	ab=ba=abs(ab-ba);
	ans+=min(at,ta);
	at=ta=abs(at-ta);
	ans+=min(bt,tb);
	bt=tb=abs(bt-tb);
	ans+=(ab+bt+ta)/3*2;
	return ans;
} 
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	string s;cin>>s;
	int n=s.length();
	int a=0,b=0,t=0;
	for(int i=0;i<n;i++){
		if(s[i]=='A')a++;
		else if(s[i]=='B')b++;
		else t++;
	}
	int ans=0xcff0102,ab=0,at=0,ba=0,bt=0,ta=0,tb=0;
	for(int i=0;i<n;i++){//ABT
		if(i<a){
			if(s[i]=='B')ab++;
			if(s[i]=='T')at++;
		}else if(i<a+b){
			if(s[i]=='A')ba++;
			if(s[i]=='T')bt++;
		}else{
			if(s[i]=='A')ta++;
			if(s[i]=='B')tb++;
		}
	}
	ans=min(ans,calc(ab,at,ba,bt,ta,tb));ab=at=ba=bt=ta=tb=0;
	for(int i=0;i<n;i++){//ATB
		if(i<a){
			if(s[i]=='B')ab++;
			if(s[i]=='T')at++;
		}else if(i<a+t){
			if(s[i]=='A')ta++;
			if(s[i]=='B')tb++;
		}else{
			if(s[i]=='A')ba++;
			if(s[i]=='T')bt++;
		}
	}
	ans=min(ans,calc(ab,at,ba,bt,ta,tb));ab=at=ba=bt=ta=tb=0;
	for(int i=0;i<n;i++){//BAT
		if(i<b){
			if(s[i]=='A')ba++;
			if(s[i]=='T')bt++;
		}else if(i<a+b){
			if(s[i]=='B')ab++;
			if(s[i]=='T')at++;
		}else{
			if(s[i]=='A')ta++;
			if(s[i]=='B')tb++;
		}
	}ans=min(ans,calc(ab,at,ba,bt,ta,tb));ab=at=ba=bt=ta=tb=0;
	for(int i=0;i<n;i++){//BTA
		if(i<b){
			if(s[i]=='A')ba++;
			if(s[i]=='T')bt++;
		}else if(i<t+b){
			if(s[i]=='A')ta++;
			if(s[i]=='B')tb++;
		}else{
			if(s[i]=='B')ab++;
			if(s[i]=='T')at++;
		}
	}ans=min(ans,calc(ab,at,ba,bt,ta,tb));ab=at=ba=bt=ta=tb=0;
	for(int i=0;i<n;i++){//TAB
		if(i<t){
			if(s[i]=='A')ta++;
			if(s[i]=='B')tb++;
		}else if(i<a+t){
			if(s[i]=='B')ab++;
			if(s[i]=='T')at++;
		}else{
			if(s[i]=='A')ba++;
			if(s[i]=='T')bt++;
		}
	}ans=min(ans,calc(ab,at,ba,bt,ta,tb));ab=at=ba=bt=ta=tb=0;
	for(int i=0;i<n;i++){//TBA
		if(i<t){
			if(s[i]=='A')ta++;
			if(s[i]=='B')tb++;
		}else if(i<t+b){
			if(s[i]=='A')ba++;
			if(s[i]=='T')bt++;
		}else{
			if(s[i]=='B')ab++;
			if(s[i]=='T')at++;
		}
	}ans=min(ans,calc(ab,at,ba,bt,ta,tb));
	cout<<ans;
	return 0;
}
```

---

## 作者：sieve (赞：1)

# 题解：[P8672 [蓝桥杯 2018 国 C] 交换次数](https://www.luogu.com.cn/problem/P8672)

## 思路

考虑贪心。

不难发现，这几个字符其实可以划分为几个区域，每个区域的长度就是每个字符需要的个数。当然，这会有 $6$ 中不同的区间选择，所以我们要进行 $6$ 次操作，然后取所有操作次数的最小值。

对于每次选择，如果直接暴力肯定会超时，这里就是我们贪心要贪的地方了。

首先，我们截取出前两个区间，假设此时的 $3$ 个字符分别是 $x,y,z$，然后统计 $y$ 和 $z$ 在截取出的 $x$ 的区间中的出现次数，分别记作 $sum01$ 和 $sum02$。

然后统计 $x$ 和 $z$ 在截取出的 $y$ 的区间中的出现次数，分别记作 $sum10$ 和 $sum12$。

对于 $sum02$ 和 $sum12$ 是必须要进行交换的，但是 $sum01$ 和 $sum10$ 是两个一样的区间的不同出现个数，所以，交换的次数是 $\max(sum01,sum10)$。因为进行了 $\min(sum01,sum10)$ 次操作后，还有 $\max(sum01,sum10) - \min(sum01,sum10)$ 个字符没有进行交换，不在应该在的位置上。

然后答案就自然是 $sum02 + sum12 + \max(sum01,sum10)$ 了。

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;
const int N=1e5+5;
string s;
int n,mn=1e9;
map<char,int> sum;
void stable_sart(char x,char y,char z)
{
	string s1(s.substr(0,sum[x])),s2(s.substr(sum[x],sum[y]));//截取区间
	int sum01=0,sum02=0;
	for(int i=0;i<s1.size();++i)
	{
		if(s1[i]==y) sum01++;
		if(s1[i]==z) sum02++;
	}
	int sum10=0,sum12=0;
	for(int i=0;i<s2.size();++i)
	{
		if(s2[i]==x) sum10++;
		if(s2[i]==z) sum12++;
	}
	int ans=sum02+sum12+max(sum01,sum10);
	mn=min(mn,ans);//取最小值
	return;
}
signed main()
{
	cin>>s;
	n=s.size();
	for(int i=0;i<n;++i) sum[s[i]]++;//统计每个字符出现的个数，也就是区间长度
	stable_sart('B','A','T');//6中排列都要考虑
	stable_sart('B','T','A');
	stable_sart('A','T','B');
	stable_sart('A','B','T');
	stable_sart('T','A','B');
	stable_sart('T','B','A');
	cout<<mn;
	return 0;
}
```

---

## 作者：dongrunxuan (赞：1)

# P8672题解

## 前言

蓝（bao）桥（li）杯的题居然题解通道还没关？我来交一发。

## 思路

采取模块化。因为题目中只会有三种字母，根据全排列，可知一共有 $6$ 种排列方式。分别在每种方式中，记录最小的交换次数，然后取最小值即可。

### 如何求最小的交换次数呢？

创建 $6$ 个变量，记录不同区域移动到指定区域的操作步数。不妨设为 $m1t2,m1t3,m2t1,m2t3,m3t1,m3t2$。在模块中，将输入的字符串分 $3$ 段遍历，可以分别求出上述 $6$ 个变量的值。

而答案分为几种情况：

1. 若 $m1t2=m2t1$，则皆大欢喜，两个相互交换即可，不会增加混乱度。

2. 若 $m1t2 \ne m2t1$，则会增加 $m1t2$ 的混乱度，这时 $m1t2$ 增加的混乱度就等于 $m1t3-m3t1$。

故该种方式的最小交换次数可以求得。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
int res=1e6+10;
string arr[6]={"ABT","ATB","BAT","BTA","TAB","TBA"};//6种情况
string str;
map<char,int>mymap;
int f(int i){
	int tres=0;//该种情况最小的交换次数
	int len1=mymap[arr[i][0]];//该种字母的数量
	int len2=mymap[arr[i][1]];//该种字母的数量
	int len3=str.size()-len1-len2;//该种字母的数量
	int m1t2=0,m1t3=0,m2t1=0,m2t3=0,m3t1=0,m3t2=0;
	for(int j=0;j<len1;j++){
		if(str[j]==arr[i][1]) m1t2++;
		else if(str[j]==arr[i][2]) m1t3++;
	}//算出第一部分应移往别的部分的数量
	for(int j=len1;j<len1+len2;j++){
		if(str[j]==arr[i][0]) m2t1++;
		else if(str[j]==arr[i][2]) m2t3++;
	}//算出第二部分应移往别的部分的数量
	for(int j=len1+len2;j<str.size();j++){
		if(str[j]==arr[i][0]) m3t1++;
		else if(str[j]==arr[i][1]) m3t2++;
	}//算出第三部分应移往别的部分的数量
	tres+=m1t3+m2t3;//必要的步数
	if(m1t3>m3t1) m1t2+=m1t3-m3t1;//增加混乱度
	tres+=m1t2;
	return tres;
}
int main(){
	cin>>str;
	for(int i=0;i<str.size();i++) mymap[str[i]]++;//统计每种字符个数
	for(int i=0;i<6;i++) res=min(res,f(i));//模块处理答案，并取min
	cout<<res;
	return 0;//好习惯
}

```


---

## 作者：2b2b2bbb (赞：0)

# 题意简化
给定一个字符串，然后将这个字符串中的所有相同的字符放在一起。问：将这个字符串通过交换，要至少多少次才能满足条件。
# 思路
首先，这道题目总共就只有三种字符，那么我们就可以暴力枚举每个字符的出现顺序。然后我们就考虑一下如何贪心。

我们为了让修改的次数最小，我们的交换就要有所改变。那么具体怎么改变呢。难道是直接看看这个位置是不是我们要的字符，然后统计不同的次数？

显然不是，因为当字符串是 `AABBBATT` 那么我们的答案就会输出 $2$。

所以我们的贪心策略应该是什么呢？我们要次数最小，肯定是尽量让交换的字符都到尽量可以到达正确的位置上。

那么我们的操作应该是有四种情况的，就是 $A$ 与 $B$ 交换，$B$ 与 $A$ 交换，$A$ 与 $T$ 交换，$B$ 与 $T$ 交换。

这个时候就有人问了，那还有两种呢？那两种其实在我们操作以上四种的时候就已经交换完了，所以根本不用管。

最后我们的交换次数就是 $A$ 与 $B$ 交换次数和 $B$ 与 $A$ 交换次数的最大值加上 $A$ 与 $T$ 交换次数和 $B$ 与 $T$ 交换次数。
## code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int f[10],a[10];
int len,ans = 1e9;
bool vis[5];
char d[5]={' ' , 'B' , 'A' , 'T'};
int check(){
	string t = "";
	int sum = 0 , num = 0 , cnt = 0;
	for(int i = 1 ; i <= 3 ; i ++){
		for(int j = 1 ; j <= a[f[i]] ; j ++){
			t += d[f[i]];
		}
	}
	for(int i = 0 ; i < len ; i ++){
		if(t[i] == 'A' && s[i] == 'B'){
			num ++;
		}
		if(t[i] == 'B' && s[i] == 'A'){
			cnt ++;
		}
	}
	num = max(num , cnt);
	cnt = 0;
	for(int i = 0 ; i <= len ; i ++){
		if(t[i] == 'A' && s[i] == 'T'){
			sum ++;
		}
		if(t[i] == 'B' && s[i] == 'T'){
			cnt ++;
		}
	}
	return num + sum + cnt;
}
void dfs(int k){
	if(k == 4){
		ans = min(ans , check());
		return;
	}
	for(int i = 1 ;  i <= 3 ; i ++){
		if(!vis[i]){
			vis[i] = 1;
			f[k] = i;
			dfs(k + 1);
			vis[i] = 0; 
		}
	}
}
int main(){
	cin >> s;
	len = s.size() - 1;
	for(int i = 0 ; i <= len ; i ++){
		if(s[i] == 'B'){
			a[1] ++;
		}else if(s[i] == 'A'){
			a[2] ++;
		}else{
			a[3] ++;
		}
	}
	dfs(1);
	cout << ans;
	return 0;
} 
```

---

## 作者：yr409892525 (赞：0)

## 题解 [P8672 [蓝桥杯 2018 国 C] 交换次数](https://www.luogu.com.cn/problem/P8672)
### 思路
我们发现最后的顺序只有 $6$ 种，不妨枚举每一种顺序。   

当我们确定一种顺序后，我们发现只有四种情况。  

1. 从 $a$ 换到 $b$。
2. 从 $a$ 换到 $c$。
3. 从 $b$ 换到 $a$。
4. 从 $b$ 换到 $c$。

可是我们发现当从 $a$ 换到 $b$ 时，$b$ 也会换到 $a$。

所以我们只需记录从 $a$ 要换到 $b$ 的和从 $b$ 换到 $a$ 的最大值。

加上从 $a$ 换到 $c$ 和从 $b$ 换到 $c$ 的。 

### code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int sum=1e9;
string s;
int n;
int a[N],op[N];
int work(char x,char y,char z){
	string s1=s.substr(0,op[x]),s2=s.substr(op[x],op[y]);
	int l1=s1.size(),l2=s2.size();
	int sum12=0,sum13=0;//sum12是从1要交换到2的，sum13是从1要交换到3的
	for(int i=0;i<l1;i++){
		if(s1[i]==y) sum12++;
		if(s1[i]==z) sum13++;
	}
	int sum21=0,sum23=0;//sum21是从2要交换到1的，sum23是从2要交换到3的
	for(int i=0;i<l2;i++){
		if(s2[i]==x) sum21++;
		if(s2[i]==z) sum23++;
	}
	int ans=max(sum12,sum21)+sum13+sum23;
	return ans;
}
string str[10]={"ABT","ATB","BAT","BTA","TAB","TBA"}; //6种情况
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>s;
	n=s.size();
	for(int i=1;i<=n;i++){
		op[s[i-1]]++; //统计每一种字符出现的数量
	}
	for(int i=0;i<6;i++){
		sum=min(sum,work(str[i][0],str[i][1],str[i][2]));
	}
	cout<<sum<<"\n";
	return 0;
}
```

---

## 作者：Jimmy_Cao (赞：0)

# 思路
从输入中读取席位分布，然后用一个 map 记录 $A、B、T$ 的数量。定义了一个变量 $ans$，用来存储最小的交换次数，初始化为一个很大的数。然后定义了一个字符串 $abt$，是 $A、B、T$ 的一个排列，然后使用 do while 循环，对 $abt$ 进行全排列，调用 calc 函数计算需要交换的最小次数。

然后定义一个 calc 函数，该函数接受一个字符串，该字符串是 $A、B、T$ 的一个排列，然后计算如果席位按照该排列进行排列，需要交换的最小次数。

在 calc 函数中，首先定义了两个变量 $s01$ 和 $s02$，这两个变量用来记录 $0$ 区的字符需要移动到 $1$ 区和 $2$ 区的数量。然后遍历字符串的前 $cnt_{code_0}$ 个字符，如果字符是 $code_1$，则 $s01$ 加一，如果字符是 $code_2$，则 $s02$ 加一。这个过程就是计算 $0$ 区的字符需要移动的数量。

然后定义了两个变量 $s20$ 和 $s21$，这两个变量用来记录 $2$ 区的字符需要移动到 $0$ 区和 $1$ 区的数量。然后遍历字符串的后 $cnt_{code_2}$ 个字符，如果字符是 $code_0$，则 $s20$ 加一，如果字符是 $code_1$，则 $s21$ 加一。这个过程就是计算 $2$ 区的字符需要移动的数量。

当 $0$ 区和 $1$ 区都完成排序后，$2$ 区自然也就排序完成了。不需要再检查 $2$ 区。

$s01$ 和 $s21$ 分别表示 $0$ 区需要移到 $1$ 区和 $2$ 区需要移到 $1$ 区的字符数量，这两部分的字符移动是必须的。至于 $s02$ 和 $s20$，表示 $0$ 区需要移到 $2$ 区和 $2$ 区需要移到 $0$ 区的字符数量，这两部分的字符移动存在冲突，即如果 $0$ 区的字符移到 $2$ 区，那么 $2$ 区的字符就不能移到 $0$ 区，反之亦然。因此，选择 $s02$ 和 $s20$ 中的最大值，即选择需要移动的字符数量最多的区域进行移动。这样可以保证总的交换次数最少。

所以最少的交换次数等于 $0$ 区需要移到 $1$ 区的字符数量，加上 $2$ 区需要移到 $1$ 区的字符数量，再加上 $0$ 区和 $2$ 区中需要移动的字符数量最多的那个区域的字符数量。函数返回`sum=s01+s21+max(s02,s20);`

对每一个排列，计算需要交换的最小次数，然后更新 $ans$。最后，输出 $ans$。
# 完整代码
```cpp
#include <algorithm>
#include <cmath>
#include <iostream>
#include <map>

using namespace std;
using ll = long long;

const int N = 1e6 + 7;
const int INF = 0x3f3f3f3f;
const ll MOD = 1e9 + 7;

int n;
string s;
int len = s.length();
map<char, int> cnt;

/*
将字符串划分为0、1、2三个区域
每个区域排序后应该只有一种字符
*/
ll calc(string code) {
	ll sum = 0;

	ll s01 = 0;
	ll s02 = 0;
	// 检查0区
	for (int i = 0; i < cnt[code[0]]; i++) {
		// cout << s[i] << endl;
		if (s[i] == code[1]) {
			// 该字符属于1区，将其字符从0区移到1区
			s01++;
		} else if (s[i] == code[2]) {
			// 该字符属于2区，将其从0区移到2区
			s02++;
		}
	}

	ll s20 = 0;
	ll s21 = 0;
	// 检查2区
	for (int i = s.length() - 1; i >= s.length() - cnt[code[2]]; i--) {
		// cout << s[i] << endl;
		if (s[i] == code[1]) {
			// 该字符属于1区，将该字符从2区移到1区
			s21++;
		} else if (s[i] == code[0]) {
			// 该字符属于0区，将该字符从2区移到0区
			s20++;
		}
	}

	sum = s01 + s21 + max(s02, s20);
	// cout << sum << endl;
	return sum;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	cin >> s;
	for (const auto i : s) {
		cnt[i]++;
	}

	ll ans = INF;
	string abt = "ABT";
	do {
		ans = min(ans, calc(abt));
	} while (next_permutation(abt.begin(), abt.end()));
	cout << ans << "\n";
	return 0;
}
``````

---


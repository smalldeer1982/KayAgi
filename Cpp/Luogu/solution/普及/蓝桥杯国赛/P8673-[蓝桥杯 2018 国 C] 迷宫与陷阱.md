# [蓝桥杯 2018 国 C] 迷宫与陷阱

## 题目描述

小明在玩一款迷宫游戏，在游戏中他要控制自己的角色离开一间由 $N \times N$ 个格子组成的二维迷宫。

小明的起始位置在左上角，他需要到达右下角的格子才能离开迷宫。

每一步，他可以移动到上下左右相邻的格子中（前提是目标格子可以经过）。

迷宫中有些格子小明可以经过，我们用 `.` 表示；

有些格子是墙壁，小明不能经过，我们用 `#` 表示。

此外，有些格子上有陷阱，我们用 `X` 表示。除非小明处于无敌状态，否则不能经过。

有些格子上有无敌道具，我们用 `%` 表示。

当小明第一次到达该格子时，自动获得无敌状态，无敌状态会持续 $K$ 步。

之后如果再次到达该格子不会获得无敌状态了。

处于无敌状态时，可以经过有陷阱的格子，但是不会拆除 / 毁坏陷阱，即陷阱仍会阻止没有无敌状态的角色经过。

给定迷宫，请你计算小明最少经过几步可以离开迷宫。

## 说明/提示

时限 3 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
5 3
...XX
##%#.
...#.
.###.
.....```

### 输出

```
10```

## 样例 #2

### 输入

```
5 1
...XX
##%#.
...#.
.###.
.....```

### 输出

```
12```

# 题解

## 作者：Zaku (赞：36)

这题是普通 bfs 的变形题。加了一个道具的操作。

板子相信大家都会敲，那么主要讲一下如何处理无敌道具。

在结构体内新加一个变量 $magic$，表示当前还剩几步的无敌效果。在遍历过程中，如果遇到“X”，并且不剩无敌了，就不能走；如果遇到“%”，$magic$ 变为 $k$。其他情况，并且不为“#”时，把点入队。

这里要加一个剪枝：加一个 int 型的数组 $vis$，入队时需要 ```vis[x][y] < magic```，即如果当前节点已经被访问过，且之前到达该节点时的无敌状态剩余步数比现在要多，则不需要再次访问该节点。因为如果我们之前已经访问过该节点并且使用了更多的无敌步数，那么这条路径一定不是最优解。初始时要赋值为全 $-1$。

代码+详细注释：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e3 + 5;
int n, k; 
char g[N][N]; 
int vis[N][N]; // 存储每个格子是否被访问过以及无敌状态剩余步数
struct node{
	int x, y, step, magic;
};

int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};

int main(){
	cin >> n >> k;
	for (int i = 1; i <= n; i ++ )
		for (int j = 1; j <= n; j ++ )
			cin >> g[i][j];
	memset(vis, -1, sizeof vis);
	queue<node> q;
	vis[1][1] = 0; // 将起点的访问状态设置为0
	q.push({1, 1, 0, 0}); // 将起点入队，并设置其到达该点的步数为0、当前不处于无敌状态
	while (q.size()){
		node t = q.front(); // 取出队头节点
		q.pop();
		if (t.x == n && t.y == n){ // 如果当前节点为终点，则输出最短路长度并结束程序
			cout << t.step;
			return 0;
		}
		for (int i = 0; i < 4; i ++ ){
			int tx = t.x + dx[i];
			int ty = t.y + dy[i];
			if (g[tx][ty] == 'X' && t.magic == 0) // 如果下一步位置是陷阱且当前不处于无敌状态，则跳过该节点
				continue;
			int magic = max(0, t.magic - 1); // 计算当前无敌状态剩余步数
			if (g[tx][ty] == '%') // 如果下一步位置有道具，更新无敌状态剩余步数
				magic = k;
			if (tx >= 1 && tx <= n && ty >= 1 && ty <= n && vis[tx][ty] < magic && g[tx][ty] != '#'){ // 如果下一步位置是合法的可到达位置
				vis[tx][ty] = magic; // 更新访问状态和无敌状态剩余步数
				q.push({tx, ty, t.step + 1, magic}); // 将下一步位置入队，并更新到达该点的步数和无敌状态剩余步数
			}
		}
	}
	cout << -1;
    return 0;
}

```

---

## 作者：DreamLand_zcb (赞：8)

## 简要题意

走迷宫，求最短路径长度。较普通走迷宫多了两个物品：

* `%`：无敌道具，只能使用一次，使用了它可以将无敌时间变成 $K$，每走一步无敌时间减一。

* `X`：陷阱，无敌时间大于 $0$ 时才能往这里走（到达该格子时无敌时间可以为 $0$）。

## 思路

求最短路径就用 bfs，但是因为有了陷阱所以有的格子可以重复走，因为走到该格子时无敌时间可能不一样。以样例一举例，我们重复走了 $(3, 1)$ 这个地方，因为第一次到这里时无敌时间是 $0$，而第二次到这里时无敌时间是 $2$，足够通过右面两个陷阱，走更短路径（相比来说样例二因为无敌时间不够所以无法过去走更短路径）。

如果这样直接定义三维数组 $vis[x][y][inv]$（在 $(x, y)$ 时无敌时间是 $inv$）会 TLE，所以考虑优化。

改变一下思路，如果之前已经到过 $(x, y)$ 这个地方了，且当时到这里时总共走了 $st[x][y]$ 步，无敌时间是 $ti[x][y]$ 时刻。如果此时又到了一次 $(x, y)$，但是步数大于等于 $st[x][y]$ 且无敌时刻小于等于 $ti[x][y]$，可以忽略这次移动，因为显然步数越小越好，无敌时间越大越好。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

const int INF = 0x3f3f3f3f;
int n, k;
char c[1005][1005];
int st[1005][1005];//到(x, y)时的步数 
int ti[1005][1005];//到(x, y)时的无敌时间 
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
bool f = 0;
int ans;
struct node {
	int x, y;//坐标 
	int inv;//无敌时间 
	int step;//步数 
};
bool check(int x, int y, int step, int inv)
{
	if(x < 1 || x > n || y < 1 || y > n)	return false;
	if(c[x][y] == '#')	return false;
	if(step >= st[x][y] && inv <= ti[x][y])	return false;
	if(c[x][y] == 'X' && inv < 0)	return false;
	return true;
}
void bfs()
{
	queue <node> q;
	q.push((node){1, 1, 0, 0});
	ti[1][1] = 0;
	st[1][1] = 0;
	while(!q.empty())
	{
		node t = q.front();
		q.pop();
		int x = t.x, y = t.y, step = t.step, inv = t.inv;
		if(x == n && y == n)
		{
			f = 1;
			ans = step;
			break;
		}
		inv--;
		step++;
		for(int i=0;i<4;i++)
		{
			int X = x + dx[i];
			int Y = y + dy[i];
			if(check(X, Y, step, inv))
			{
				if(c[X][Y] == '%' && st[X][Y] == INF)	inv = k;
				st[X][Y] = step;
				ti[X][Y] = inv;
				//cout << X << " " << Y << " " << inv << " " << endl;
				q.push((node){X, Y, inv, step});
			}
		}
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> k;
	mem(st, INF);
	mem(ti, -INF);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin >> c[i][j];
	bfs();
	if(f)	cout << ans;
	else	cout << -1;
	return 0;
}

```


---

## 作者：wuhan1234 (赞：5)

## 1.编程思路。

求小明最少走几步可以走出迷宫，用广度优先搜索算法 BFS。

相比一般的 BFS 走迷宫问题，本题需要处理好小明处于无敌状态的情况。

为此，在定义的结构体类型中，加入一个成员分量 $sta$，表示处于无敌状态剩余可持续的步数，$sta$ 的值为 $0$，表示当前不是无敌状态。

另外，对 $vis$ 数组的用法进行优化。一般的 BFS 中，$vis[x][y]=0$ 表示坐标 $(x,y)$ 处没有访问过，访问过之后置 $vis[x][y]=1$，以后再次访问坐标 $(x,y)$ 处时，由于 $vis[x][y]=1$，不再进行访问。

本题中，可以将 $vis$ 数组的全部元素初始值赋值为 $-1$，表示坐标 $(x,y)$ 处没有访问过。每次访问到 $(x,y)$ 处时，将 $vis[x][y]$ 的值与当前的无敌状态剩余步数 $sta$ 进行比较。若 $vis[x][y]<sta$，才对坐标 $(x,y)$ 处的格子进行访问，并置 $vis[x][y]=sta$；若 $vis[x][y]\ge sta$，就不再对 $(x,y)$ 重新访问了。这是因为坐标 $(x,y)$ 处曾经以更多剩余无敌状态步数都访问过，再用剩余无敌状态步数少的来重新访问是没有意义的。也就是说，在本题中，$vis[x][y]$ 中保存的值一定是访问坐标 $(x,y)$ 处格子的最多无敌状态剩余步数。即使该格子只能以非无敌状态进行访问，其值也会置为 $0$，比初始设定的值 $-1$ 大，保证可以访问到。

## 2.源程序。

```c
#include <stdio.h>
#include <string.h>
#define MAXLEN 1000000
int n,k;
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
char mp[1005][1005];
int vis[1001][1001];
struct Node
{
    int sta;   // 无敌状态剩余时间
    int x,y,step;
};
struct Node q[1000005];
int judge(int x,int y,int sta)
{
    if (x<0 || x>=n || y<0 || y>=n)  // 越界判断
        return 0;
    if (mp[x][y]=='#' || (mp[x][y]=='X' && sta==0)) // 墙和非无敌状态下的陷阱不能过
        return 0;
    return 1;
}
void bfs()
{
    memset(vis,-1,sizeof(vis));
    int front=0,rear=0;
    struct Node cur;
    cur.x=cur.y=cur.step=cur.sta=0;
    q[rear++]=cur;
    while (front<rear)
    {
        cur=q[front];
        front=(front+1)%MAXLEN;
        int sta=cur.sta;
        if (cur.x==n-1 && cur.y==n-1)
        {
            printf("%d\n",cur.step);
            return ;
        }
        for (int i=0;i<4;i++)
        {
            int nx=cur.x+dx[i];
            int ny=cur.y+dy[i];
            if (mp[nx][ny]=='%' && vis[nx][ny]<k)  // 遇到无敌道具且此状态未访问过
            {
                vis[nx][ny]=k;
                q[rear].x=nx;  q[rear].y=ny;
                q[rear].step=cur.step+1;
                q[rear].sta=k;
                rear=(rear+1)%MAXLEN;
             }
            if (vis[nx][ny]<sta && judge(nx,ny,sta))
            {
                vis[nx][ny]=sta;
                q[rear].x=nx;  q[rear].y=ny;
                q[rear].step=cur.step+1;
                if (sta>=1) q[rear].sta=sta-1;
                else        q[rear].sta=0;
                rear=(rear+1)%MAXLEN;
            }
        }
    }
    printf("-1\n");
}
int main()
{
    scanf("%d%d",&n,&k);
    int i;
    for (i=0;i<n;i++)
        scanf("%s",mp[i]);
    bfs();
    return 0;
}

```


---

## 作者：Ashankamiko (赞：4)

# 题目简述
### 题意
给定一个 $N \times N$ 的地图，按照以下要求移动，求最少需要几步能从最左上角移动到最右下角。
- 每次只能向上下左右四个方向行走。
- 不可以移动到 `#`。
- 如果移动到 `%`，获得无敌状态 $k$ 步，无敌状态时可以移动到不是 `#` 的任何一个地方。
- 如果没有无敌状态，不可以移动到 `X`。
### 思路
采用 bfs 算法，从最左上角开始扩展，直到扩展到最右下角或队列为空时输出 $-1$。

需要额外注意的是当扩展到 `%` 的时候，要特判并且忽略标记和 `X`，扩展时只要 $(x,y)$ 不是 `#` 就入队。

定义队列的时候需要定义四个参数，参考以下代码。
```
struct node {
	int x, y; //坐标
  int r; //步数
  int s; //无敌时间
};
```
## [AC 代码](https://www.luogu.com.cn/record/217514527)
```
#include <bits/stdc++.h>
#define int long long
using namespace std;
#define in cin
#define out cout

struct node { //结构体
	int x, y, r, s;
};
queue<node> q; //队列

signed main() {
	int n, k;
	in >> n >> k;
	char maps[n][n];
	for (int i = 0; i < n; i++) //输入地图
		for (int j = 0; j < n; j++)
			in >> maps[i][j];
	int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, 1, -1}; //方向数组
	q.push({0, 0, 0, false}), maps[0][0] = 'F'
	while (!q.empty()) {
		int ux = q.front().x, uy = q.front().y, ur = q.front().r, us = q.front().s;
		q.pop();
		if (ux == n - 1 && uy == ux) { //可以到达
			out << ur;
			return 0;
		}
		for (int i = 0; i < 4; i++) {
			int tx = ux + dx[i], ty = dy[i] + uy;
			if (us) //有无敌时间
				if (tx >= 0 && ty >= 0 && tx < n && ty < n && maps[tx][ty] != '#') { //只要不是#就可以扩展
					int x = us;
					if (maps[tx][ty] == '%' )
						x = k;
					else
						x--;
					q.push({tx, ty, ur + 1, x}), maps[tx][ty] = 'F';
				} else;
			else if (tx >= 0 && ty >= 0 && tx < n && ty < n && (maps[tx][ty] == '.' || maps[tx][ty] == '%')) { //没有无敌时间
				if (maps[tx][ty] == '.')
					q.push({tx, ty, ur + 1, 0});
				else
					q.push({tx, ty, ur + 1, k});
				maps[tx][ty] = 'F';
			}
		}
	}
	out << -1; //无法到达
	return 0;
}
```

---

## 作者：_cpp (赞：4)

一道 bfs 的板子题，几乎没有任何变化。对于无敌道具来说，可以在 edge 结构体中加一个 invincible，表示剩下的无敌步数。注意：此题宽搜要加一个剪枝，用 book 数组来标记每一个走过点的无敌步数，如果当前这个点曾经走过的无敌步数比现在要多，那就没必要往下了（因为无敌步数总是越多越好）。

### 详细解析见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int x,y,invincible,sum;
};
int n,x,nx[] = {0,0,1,-1},ny[] = {1,-1,0,0},book[1001][1001];
char a[1001][1001];
queue<edge>q; //建立结构体数组
int main()
{
	cin >> n >> x;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= n;j++) cin >> a[i][j],book[i][j] = -1;  //初始化book数组，-1代表没有走过
	edge t;
	t.x = 1,t.y = 1,t.invincible = 0,t.sum = 0;
	q.push(t);
	book[1][1] = 0; //初始位置入队，标记初始点为0（剩余无敌步数为0）
	while(!q.empty()){
		t = q.front();
		q.pop();
		if(t.x == n && t.y == n) return cout << t.sum,0;
		edge k;
		for(int i = 0;i < 4;i++){
			int dx,dy;
			dx = t.x + nx[i];
			dy = t.y + ny[i];  //计算下一步
			if(a[dx][dy] == 'X' && t.invincible == 0) continue;  //如果没有无敌，并且当前是陷阱，就无法通过
			if(a[dx][dy] == '#') continue;
			k.invincible = max(0,t.invincible - 1); //无敌步数是上一步-1
			if(a[dx][dy] == '%') k.invincible = x;  //如果当前还是无敌道具，重置无敌步数
			if(dx >= 1 && dx <= n && dy >= 1 && dy <= n && k.invincible > book[dx][dy]){  //可行性剪枝
				k.x = dx;
				k.y = dy;
				book[dx][dy] = k.invincible;
				k.sum = t.sum + 1;
				q.push(k);
			}
		}
	}
	cout << "-1";
	return 0;
}
```


---

## 作者：Lemonlwl (赞：2)

## P8673 [蓝桥杯 2018 国 C] 迷宫与陷阱 题解
### 题意：
给出一个迷宫，问小明能不能走出这个迷宫，如果可以，则输出最短路径的长度。

------------

### 思路：
本题为最短路问题，我们可以用广度优先搜索解决。

与模板题不同的是，本题多了一个无敌道具，在一定时间内，无敌道具，用 ```%``` 表示，可以破坏掉迷宫中的陷阱，用 ```X``` 表示。

所以我们只需要在搜的过程中加入陷阱和无敌道具的判断即可。

1. 定义结构体存储坐标，步数和剩余无敌时间；定义 ```vis[x][y][z]``` 数组用来记录当剩余 $z$ 个无敌时间的状态下，该坐标有没有被访问过，这样就可以避免出现同一个点被重复查找。

1. 广搜：对**当遇到无敌道具时**，**当遇到陷阱且有剩余无敌时间时**，**当有剩余无敌时间且可以经过时**和**当无剩余无敌时间且可以经过时**这四种情况进行特判（注意：在遇到无敌道具时，应将 ```time``` 重置为 ```k``` 而不是 ```k-1```），若到达终点，则返回该点的步数，若地图被搜完还没到终点，则返回 $-1$。

1. 主函数：输入输出。

------------

附上 [AC](https://www.luogu.com.cn/record/112259028) 代码：
```cpp
#include<iostream>
#include<queue>
using namespace std;
struct node{  //定义搜索位置的结构体。
	int cx;
	int cy;
	int sum;  //表示当前步数。
	int time; //表示当前剩余的无敌时间。
};
int n,k;
char a[1005][1005];  //地图。
int xx[4]={-1,1,0,0};
int yy[4]={0,0,-1,1};
bool vis[1005][1005][15];
/*这里vis[x][y][z]三维数组表示在剩余z个无敌时间时，有没有经过(x,y)这个点。*/
int bfs(int x,int y){
	queue<node> q;
	node v;
	v.cx=x;
	v.cy=y;
	v.sum=0;
	v.time=0;
	q.push(v);
	vis[x][y][v.time]=true;//第一个位置。
	while(!q.empty()){
		node f=q.front();  //当前位置。
		q.pop();
		if(f.cx==n && f.cy==n){  //走出迷宫。
			return f.sum;
		}
		for(int i=0;i<4;i++){  //四个方向。
			node tmp;
			tmp.cx=f.cx+xx[i];
			tmp.cy=f.cy+yy[i];
			if(a[tmp.cx][tmp.cy]!='#' && tmp.cx>=1 && tmp.cy>=1 && tmp.cx<=n && tmp.cy<=n){
				//第一个if滤除走不过去的墙。
				if(a[tmp.cx][tmp.cy]=='%' && !vis[tmp.cx][tmp.cy][f.time]){
					//当遇到无敌道具时，即在无敌时间剩余k时。
					vis[tmp.cx][tmp.cy][k]=true;
					a[tmp.cx][tmp.cy]='.';
					tmp.time=k;
					tmp.sum=f.sum+1;
					//步数加1，下同。
					q.push(tmp);
				}
				if(f.time && !vis[tmp.cx][tmp.cy][f.time-1] && a[tmp.cx][tmp.cy]=='X'){
					//当遇到陷阱且有剩余无敌时间。
					vis[tmp.cx][tmp.cy][f.time-1]=true;
					tmp.sum=f.sum+1;
					tmp.time=f.time-1;
					//走一步就会减少一个无敌时间，下同。
					q.push(tmp);
				}
				if(f.time && !vis[tmp.cx][tmp.cy][f.time-1] && a[tmp.cx][tmp.cy]=='.'){
					//当有剩余无敌时间且可以经过时。
					vis[tmp.cx][tmp.cy][f.time-1]=true;
					tmp.sum=f.sum+1;
					tmp.time=f.time-1;
					q.push(tmp);
				}
				if(f.time==0 && !vis[tmp.cx][tmp.cy][0] && a[tmp.cx][tmp.cy]=='.'){
					//当无剩余无敌时间且可以经过时。
					vis[tmp.cx][tmp.cy][0]=true;
					tmp.sum=f.sum+1;
					tmp.time=0;
					//无敌时间依然是0。
					q.push(tmp);
				}
			}
		}
	}
	return -1;   //不能通过迷宫。
}
int main(){
	cin>>n>>k;
	//k为无敌时间。
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j]; //输入。
		}
	}
	cout<<bfs(1,1)<<endl; //输出最短路。
	return 0;
}
```


---

## 作者：chrispang (赞：2)

考虑使用 `BFS` 做法。

因为本题有了一个无敌状态，因此我们的标记数组不仅要标记格子是否经过，还需要注意无敌状态还可以走几步。详见代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct node {
	int x, y, pts, wd;
};

int n, m;
int dx[4] = {0, -1, 0, 1};
int dy[4] = {-1, 0, 1, 0};
bool is[1025][1025], vis[1025][1025][20];
char a[1025][1025];
queue<node> q;
vector<node> res;
int bfs(int x, int y) {
    q.push({x, y, 0, 0});
    while(!q.empty()) {
        int x = q.front().x;
        int y = q.front().y;
        int pts = q.front().pts;
        int wd = q.front().wd;
        q.pop();
        if (x == n && y == n) return pts;
        for (int i = 0; i < 4; i++) {
            int tx = x + dx[i], ty = y + dy[i];
            if (tx < 1 || tx > n || ty < 1 || ty > n || a[tx][ty] == '#') continue;
            if (a[tx][ty] == 'X') {
                if (wd == 0 || vis[tx][ty][wd - 1]) continue;
                q.push({tx, ty, pts + 1, wd - 1});
                vis[tx][ty][wd - 1] = 1;
            }
            if (a[tx][ty] == '%') {
                if (is[tx][ty] || vis[tx][ty][m]) continue;
                is[tx][ty] = 1, vis[tx][ty][m] = 1;
                q.push({tx, ty, pts + 1, m});
            }
            else {
				if(vis[tx][ty][wd >= 1 ? wd - 1 : 0]) continue;
				q.push({tx, ty, pts + 1, wd >= 1 ? wd - 1 : 0});
                vis[tx][ty][wd >= 1 ? wd - 1 : 0] = 1;
            }
        }
    }
    return -1;
}

signed main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
	    for (int j = 1; j <= n; j++)
		    cin >> a[i][j];
	cout << bfs(1, 1) << endl;
    return 0;
}
```

---

## 作者：zxChicken4088 (赞：1)

**观前提醒**：建议先完成 [P10491 \[USACO09NOV\] The Chivalrous Cow B](https://www.luogu.com.cn/problem/P10491)，以获得更好的体验。

考虑使用 BFS 完成。

与 P10491 不同的是：这题新添加了“陷阱”以及“道具”，每个道具只能捡**一次**，会获得 $K$ 步的无敌状态。除非当前为**无敌状态**，否则无法穿过陷阱。

我们可以用一个记忆化数组 $rem$，$rem_{i,j}$ 表示当前经过 $(i,j)$ 这点的**最大剩余无敌状态步数**。
如果下次经过该点时剩余无敌状态**小于等于** $rem_{i,j}$，则**剪枝**；否则将 $rem_{i,j}$ 更新为当前值，并将节点入队。

无解的条件可以在**队列为空**后输出 `-1`。

---

## 作者：add123122 (赞：1)

又来欢乐的写题解了，早日上绿名。
    
废话不多说，那么这题就是一道经典的结构体 BFS（广搜）题目。题目说从左上角开始，表示成 $(1, 1)$，目标是到达 $(n, n)$。其中小明可以走 `.`，不能走墙壁 `#`，`X` 表示陷阱，只在无敌的情况下能通过，否则不能通过。`%` 表示无敌道具，只能持续走 $K$ 步。题目还说，“当小明第一次到达该格子时，自动获得无敌状态，之后如果再次到达该格子不会获得无敌状态了。处于无敌状态时，可以经过有陷阱的格子，但是不会拆除 / 毁坏陷阱，即陷阱仍会阻止没有无敌状态的角色经过。”

## 代码

```cpp
#include <iostream>//标准头文件

#include <queue>//创建队列的头文件

using namespace std;

struct node {
    
    int x, y, k;//x,y表示坐标(x,y),k为剩余步数
    
};

int n, k;//定义n和k

char mp[1005][1005];//负责储存地图，因为包含符号用char类型

int via[1005][1005];//int类型判断是否访问过，不能是bool

int dx[4] = {1, -1, 0, 0};//表示上下左右四个方向的移动

int dy[4] = {0, 0, 1, -1};//表示上下左右四个方向的移动。

bool f(int x, int y) { //坐标(x,y),检查坐标是否在边界内
    
    return x >= 1 && x <= n && y >= 1 && y <= n;
}

int bfs() {
    
    queue<node> q;//创建队列
    
    q.push({1, 1, 0});//起点坐标(1,1),初始步数为0步
    
    via[1][1] = 0; //起点标记为访问过，才能继续运行
    
    int step = 0;//step表示层级

    while (!q.empty()) {
        
        int size = q.size();//队列长度记录
        
        step++;//当前层级的步数
        
        for (int i = 0; i < size; i++) { //长度得从0开始，小于长度，很重要！！！
            
            node t = q.front();//每次取队首
            
            q.pop();//记得要删除当前的元素，不然会死循环
            for (int j = 0; j < 4; j++) { //枚举四个方向
                int nx = t.x + dx[j];
                
                int ny = t.y + dy[j];
                
                int nk = t.k - 1;//走完后，步数要记得减1
                if (!f(nx, ny)) continue;//超出边界跳过
                if (mp[nx][ny] == '#') continue;//当前是墙壁跳过
                if (mp[nx][ny] == 'X' && nk == -1) continue;//是陷阱但当前不是无敌期间跳过
               
                if (via[nx][ny] >= nk && via[nx][ny] >= 0) continue;//跳过当前节点，减少冗余计算
                
                if (nx == n && ny == n) {
                    
                    return step;//到终点输出层数
                
                }
                if (mp[nx][ny] == '%') {
                    
                    via[nx][ny] = k;//更新步数
                    
                    mp[nx][ny] = '.';
                    
                    q.push({nx, ny, k});//加入队列
                }
                else {
                    
                    via[nx][ny] = max(0, nk);//更新步数
                    q.push({nx, ny, max(0, nk)});//加入队列
                }
            }
        }
    }
    
    return -1;//不能的话返回-1
}

int main() {
    
    cin >> n >> k;//输入
    
    for (int i = 1; i <= n; i++) { //行
       
        for (int j = 1; j <= n; j++) { //列
           
            cin >> mp[i][j]; //输入地图
            
            via[i][j] = -1;//表示未访问
        }
    }
    int result = bfs();//储存bfs()值
   
    cout << result << endl;//输出
    
    return 0;//好习惯
}
```

---

## 作者：lihouze1019 (赞：1)

## 解题思路
这是一道 **BFS** 题（如果你连BFS是什么都不知道，你可以不用看这篇题解了）

这道题在普通 BFS（这里指普通的迷宫求最短路径 BFS）的基础上，增加了无敌 `%` 和陷阱 `X` 。

在普通的 BFS 中，已经走过的路径是不能重复走的，但是这道题有一种情况，就是**我们遇到陷阱的时候，可以先去捡附近的无敌状态，然后原路返回到原点去踩着陷阱走**，这个时候，我们会需要走一些重复路径。

在这道题中，我们重复走是为了 **去捡无敌状态** ，那么如果你重复走这个点，又没有获得无敌状态，就相当白走。如果上一次走这个点已经有无敌状态了，如果当我们再次走到这个点的时候，无敌状态的剩余时间和上一次比，**没有增加，甚至反而减少，** 那么我重复走到这里就是在浪费步数，所以这个时候同样也不能走。

那么，这里判断重复走的条件就步能不能只是简单的说之前有没有走过，而是**和上次比，无敌状态的剩余时间有没有增加**。

因为判断条件变成了剩余时间有没有增加，那么我们肯定要用一个二维数组 `vis` 记录上一次到这个点的时候剩余时间是多少。

而没有无敌状态的时候剩余时间是 $0$，为了防止被误判，所以我们要在最开始把 `vis` 的每一个值都初始化为 $-1$。

## Accept Code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,stp,val;//存储坐标、步数和剩余的无敌时间
};
int n,k;
char a[1005][1005];
int vis[1005][1005];//每个点的剩余无敌时间
int d[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//偏移数组，告诉程序可以往哪些方向走
int bfs(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			vis[i][j]=-1;//初始化vis数组为-1
		}
	}
	vis[1][1]=0;//出发点，这个时候没有无敌状态
	queue<node> q;//使用队列，存还有哪些点需要找相邻点
	q.push({1,1,0,0});//出发点，步数为0，没有无敌状态
	while(q.size()){
		node xs=q.front();//取出队列第一个数
		q.pop();
		if(xs.x==n&&xs.y==n){//已经到了终点，直接返回这里的步数
			return xs.stp;
		}
		for(int i=0;i<4;i++){//遍历偏移数组
			int px=xs.x+d[i][0],py=xs.y+d[i][1];//计算接下来要走的位置
			if(px<1||px>n||py<1||py>n){//越界
				continue;
			}
			if(a[px][py]=='#'){//这个点是障碍，不能走
				continue;
			}
			if(a[px][py]=='X'&&xs.val==0){//这个点是陷阱，并且我们没有无敌时间
				continue;
			}
			int val=max(0,xs.val-1);//无敌时间-1，如果本来就没有就是0
			if(a[px][py]=='%'){//捡到无敌时间
				val=k;//剩下的无敌时间回满
				a[px][py]='.';//无敌被捡了，下次就不能捡了
			}
			if(val<=vis[px][py]){//现在剩余的时间比上次剩余的时间少，走了没用，那就不走
				continue;
			}
			vis[px][py]=val;//经过筛选发现这个点可以走，那么就把剩余时间变成这次来到这里时的剩余时间
			q.push({px,py,xs.stp+1,val});//下次可以根据这个点来继续找相邻点，把步数+1
		}
	}
	return -1;//一直都没有遇到终点，返回-1
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
		}
	}
	cout<<bfs();//直接把bfs返回的结果输出出来
	return 0;
}
```

---

## 作者：Zhangxm2012 (赞：1)

~~这道题卡了我半小时，太吃操作了。~~

回归正题，这道题的难点在于处理无敌道具和格子可以重复走（就是这一点卡了我好久） 
可以用结构体来存下这个迷宫：字符 $c$ 来存储 $(x,y)$ 这个位置上的字符，$x,y$ 来存储坐标，$tag$ 来存储 $(x,y)$ 上的无敌时间，$sp$ 来存储到达 $(x,y)$ 上的最少步数，$vis$ 来存储是否到达过 $(x,y)$。

在 bfs 中，如果走到了，输出步数，退出程序。否则遍历四个方向，记录此位置上的无敌时间，应为 $tag\leftarrow \max{0,f_{tag}-1}$ （$f$ 为队首）。若此位置为 `%` 并且这个位置没有被访问过，则 $tag \leftarrow k$。

如果之前到达此位置时的无敌状态剩余时间比现在要多，由于如果我们之前已经访问过此位置并且使用了更多的无敌时间，那么这条路径一定不是最优解，则不需要再次访问此位置（直接 continue）。
若此位置是陷阱（即为`X`），并且无敌时间小于等于 $0$，则不需要访问此位置；若此位置合法，更新步数和无敌时间及访问状态，压入队列。

主函数里，将 $tag$ 赋值为极大值，若此位置为`%`，无敌时间更新为 $k$，左上角的步数更新为 $0$。

~~大家最期待的~~代码放这了：
``` cpp
#include<bits/stdc++.h>
#define debug cout<<"here!\n";
using namespace std;
const int N=1004;
int dir[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
struct Node{
	char c;
	int x,y;
	int tag;
	int sp;
	int vis;
}M[N][N];
int n,k;
void bfs(){
	queue<Node>q;
	M[1][1].vis=1;
	q.push(M[1][1]);
	while(!q.empty()){
		Node f=q.front();
		q.pop();
		if(f.x==n&&f.y==n){
			cout<<M[n][n].sp;
			exit(0);
		}
		for(int i=0;i<4;i++){
			int x=f.x+dir[i][0];
			int y=f.y+dir[i][1];
			int tag=max(0,f.tag-1);
			if(M[x][y].c=='%'&&M[x][y].vis==0){
				tag=k;
			}
			if(x<1||x>n||y<1||y>n){
				continue;
			}
			if(M[x][y].c=='#'){
				continue;
			}
			if(f.sp+1>=M[x][y].sp&&f.tag-1<=M[x][y].tag){
				continue;
			}
			if(M[x][y].c=='X'&&f.tag<=0){
				continue;
			}
			M[x][y]={M[x][y].c,x,y,tag,f.sp+1,1};
			q.push(M[x][y]);
		}
	}
}
int main(){
	cin>>n>>k;
	memset(M,0x3f,sizeof M);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>M[i][j].c;
			M[i][j].x=i,M[i][j].y=j;
			M[i][j].tag=M[i][j].c=='%'?k:0;
			M[i][j].vis=0;
		}
	}
	M[1][1].sp=0;
	bfs();
	return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

常规宽搜。

要注意标记数组不止标记位置，还要标记无敌状态还能持续多少步。因为从样例来分析，有个点走了两次。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,k,step;
};
const int work[4][2]={{0,-1},{0,1},{-1,0},{1,0}};
int n,k;
char a[1005][1005];
bool is[1005][1005],vis[1005][1005][15];
queue<node> q;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			cin>>a[i][j];
		}
	}
	q.push({1,1,0,0});
	while(!q.empty()){
		node t=q.front();
		q.pop();
//		cout<<t.x<<" "<<t.y<<" "<<t.k<<" "<<t.step<<endl;
		if(t.x==n&&t.y==n) return cout<<t.step,0;
		for(int i=0;i<4;++i){
			int xx=t.x+work[i][0],yy=t.y+work[i][1];
			if(xx<1||xx>n||yy<1||yy>n) continue;
			if(a[xx][yy]=='#') continue;
			if(a[xx][yy]=='X'){
				if(t.k<=0||vis[xx][yy][t.k-1]) continue;
				q.push({xx,yy,t.k-1,t.step+1});
				vis[xx][yy][t.k-1]=1;
			}
			else if(a[xx][yy]=='%'){
				if(is[xx][yy]||vis[xx][yy][k]) continue;
				is[xx][yy]=1;
				q.push({xx,yy,k,t.step+1});
				vis[xx][yy][k]=1;
			}
			else {
				int nk=t.k>1?t.k-1:0;
				if(vis[xx][yy][nk]) continue;
				q.push({xx,yy,nk,t.step+1}),vis[xx][yy][nk]=1;
			}
		}
	}
	puts("-1");
}
```

---


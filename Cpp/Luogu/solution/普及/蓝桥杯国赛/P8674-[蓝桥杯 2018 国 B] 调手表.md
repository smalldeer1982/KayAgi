# [蓝桥杯 2018 国 B] 调手表

## 题目描述

小明买了块高端大气上档次的电子手表，他正准备调时间呢。

在 M78 星云，时间的计量单位和地球上不同，M78 星云的一个小时有 $n$ 分钟。

大家都知道，手表只有一个按钮可以把当前的数加一。在调分钟的时候，如果当前显示的数是 $0$，那么按一下按钮就会变成 $1$，再按一次变成 $2$。如果当前的数是 $n-1$，按一次后会变成 $0$。

作为强迫症患者，小明一定要把手表的时间调对。如果手表上的时间比当前时间多 $1$，则要按 $n-1$ 次加一按钮才能调回正确时间。

小明想，如果手表可以再添加一个按钮，表示把当前的数加 $k$ 该多好啊……

他想知道，如果有了这个 $+k$ 按钮，按照最优策略按键，从任意一个分钟数调到另外任意一个分钟数最多要按多少次。

注意，按 $+k$ 按钮时，如果加 $k$ 后数字超过 $n-1,$ 则会对 $n$ 取模。

比如，$n=10,k=6$ 的时候，假设当前时间是 $0$，连按 $2$ 次 $+k$ 按钮，则调为 $2$。


## 说明/提示

**【样例解释】**

如果时间正确则按 $0$ 次。否则要按的次数和操作系列之间的关系如下：
1. +1
2. +1, +1
3. +3
4. +3, +1

**【数据约定】**

对于 $30\%$ 的数据 $0<k<n \le 5$。

对于 $60\%$ 的数据 $0<k<n \le 100$。

对于 $100\%$ 的数据 $0<k<n \le 10^5$。

时限 3 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
5 3```

### 输出

```
2```

# 题解

## 作者：Nuyoah_awa (赞：20)

### 题目分析

小明有一块电子表，准备调时间，M78 星云上一个小时 $n$ 分钟，小明每次可以往前调 $1$ 分钟或 $k$ 分钟，求按照最优策略按键，从一个时间调到另一个时间最多要按多少次。

### 题目分析

小明从第 $a$ 分钟调到第 $b$ 分钟，假设 $a$ 与 $b$ 相差 $c$ 分钟（$c < n$），我们可以把从第 $a$ 分钟调到第 $b$ 分钟看为从第 $0$ 分钟调到第 $c$ 分钟，这样题意就简化为了从 $0$ 开始，调到任意时间最少按多少次。

我们可以把这道题视为一个图论题，我们将每个数 $u$ 向 $u + k$ 和 $u + 1$ 连边，问题就转化为了求 $0$ 号节点到每个节点最短路的最大值，然后这道题就可以转换为 $\operatorname{bfs}$ 求解了。

由于每个点到 $0$ 的距离最大为 $n - 1$，就说明即使每回往后调 $1$，调 $n - 1$ 次就可以调到所有时间了，所以时间复杂度是 $\mathcal O(n)$ 的。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <queue>

using namespace std;

const int N = 1e5 + 5;
int n, k, t[N], cnt[N], x, y1, y2, ans;
queue <int> q;

int main()
{
	scanf("%d %d", &n, &k);
	cnt[0] = true;
	q.push(0);
	while(!q.empty())
	{
		x = q.front();
		q.pop();
		ans = max(ans, t[x]);
		y1 = (x + k) % n, y2 = (x + 1) % n;
		if(!cnt[y1])
		{
			t[y1] = t[x] + 1, cnt[y1] = true;
			q.push(y1);
		}
		if(!cnt[y2])
		{
			t[y2] = t[x] + 1, cnt[y2] = true;
			q.push(y2);
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Maysoul (赞：14)

### 先看题目要求：

**从一个时间调到另一个时间**，按照常规的思想，就需要枚举两种时间可能性，在这个数据范围内是绝对不可能跑过的，我们考虑对其进行数学归纳。

设开始时间为 $ a $，结束时间为 $ b $，易得 $ a - b $ 就是我们所需要求的时差， $ a-b $ 的时差就是从 $ 0 $ 到  $ a-b $  的时间段，综上所述，我们只需要将开始时间设为 $ 0 $，就可以涵盖所有情况。

这并不难理解，举个例子，当 $ k=1 $ 的时候，每个点的按表的最大次数，就是从它到它的前一个数的距离，因为到一个点的最大距离缩短的时候，到另一个点的最大距离也在延长，所以是等价的。

综上，我们需要解决的问题，就变成了从 $ 0 $ 到所有点的最大距离，一下给出三种方案供大家参考：

### 法一：最短路

标签写的是最短路，当然可以用最短路来解决。

可是怎么建图呢？

当只能执行 $ +1 $ 的操作时，显而易见这是一个环：

![](https://cdn.luogu.com.cn/upload/image_hosting/dwky9fil.png)

那我们再把 $ +k $ 的操作加上，就是无非链接 $ i $ 到 $ i+k $。

![](https://cdn.luogu.com.cn/upload/image_hosting/8pmvl46t.png)

看上去还挺艺术，一个五芒星的形状。

对照这张图，那我们建边就变得非常简单了，对于每一个点 $ i $，都建立一条连接 $ i+1 $ 的边，并对 $ n $ 取模，再建立一条连接 $ i+k $ 的边，并对 $ n $ 取模，这个图就建完了。

然后跑一遍 Dijkstra 即可。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
const int INF=0x3f3f3f3f;
int num,ans;
int n,m,s,t,k; 
struct node{
	int id;
	int dist;
	node()
	{
		id=0;dist=0;
	}
	node(int c,int d)
	{
		id=c;dist=d;
	}
	bool operator < (const node &x)const
	{
		return x.dist<dist;
	}
};
priority_queue<node> que;//堆优化
struct linkstar{
	int to,from;
	int w;
	int next;
}edge[3300000];//区区链式前向星
int head[2200000];
int dis[2200000];
int vis[2200000];
int escnt;
void add(int from,int to,int w)
{
	edge[escnt++].from=from;
	edge[escnt].to=to;
	edge[escnt].w=w;
	edge[escnt].next=head[from];
	head[from]=escnt;
}
void Dijkstra(int u)//Dijkstra板子
{
	for (int i=0;i<n;i++)
	{
		dis[i]=INF;
	}
	memset(vis,0,sizeof(vis));
	dis[u]=0;
	que.push(node(u,0));
	int cnt=0;
	while(que.size())
	{
		node cp=que.top();
		que.pop();
		if(vis[cp.id]) continue;
		cnt++;
		vis[cp.id]=true;
		for (int i=head[cp.id];i!=-1;i=edge[i].next)
		{
			if(dis[edge[i].to]>dis[cp.id]+edge[i].w)
			{
				dis[edge[i].to]=dis[cp.id]+edge[i].w;
				if(!vis[edge[i].to])
				{
					que.push(node(edge[i].to,dis[edge[i].to]));
				}
			}
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	cin>>n;
	cin>>k;
	for (int i=0;i<n;i++)//建图
	{
		add(i,(i+1)%n,1);
		add(i,(i+k)%n,1);
	}
	Dijkstra(0);
	for (int i=0;i<n;i++)//求最大值
	{
		ans=max(ans,dis[i]);	
	}
	cout<<ans<<endl;
	return 0;
}

```
### 法二：BFS

这种情况也同样适用于BFS，按照法一中建图的规则，用 $ vis $ 数组判断是否走过，每次往队列里塞 $ i+1 $ 和 $ i+k $ ，然后记录一下当前的步数，最后输出即可。

顺带一提，在这个时限与数据范围之内，BFS是最优的。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num[MAXN],ans;
bool vis[MAXN];
queue<int> que;
int n,k;
int bfs()
{
	memset(vis,0,sizeof(vis));
	while(!que.empty())
	{
		que.pop();
	}
	int step=0;
	vis[0]=1;
	num[0]=0;
	que.push(0);
	while(!que.empty())
	{
		int cur=que.size();
		step++;
		while(cur--)
		{
			int now=que.front();
			que.pop();
			if(vis[(now+1)%n]==0)//其实也可以写成num[(now+1)%n]==0 不必使用vis
			{
				que.push((now+1)%n);
				num[(now+1)%n]=step;//这里也可以num[(now+1)%n]=num[now]+1,省去step不必要的记录
				vis[(now+1)%n]=1;
			}
			if(vis[(now+k)%n]==0)
			{
				que.push((now+k)%n);
				num[(now+k)%n]=step;
				vis[(now+k)%n]=1;
			}
		}
	}
	return 0;
}
int main()
{
	cin>>n>>k;
	bfs();
	for (int i=0;i<n;i++)
	{
		ans=max(ans,num[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```
### 法三：DFS

能 BFS,自然也可以 DFS，方法等同于上面的，不同的是这次只用 $ num $数组记录，如果当前步数要比 $ num $ 数组内的数字小，就证明这种方法更优，更改成这种方法，再继续 DFS。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num[MAXN],ans;
int n,k,goal;
int vis[MAXN];
void dfs(int now,int step)
{
	int a=(now+1)%n;
	int b=(now+k)%n;
	if(num[a]>step) 
	{
		num[a]=step;
		dfs(a,step+1);
	}
	if(num[b]>step) 
	{
		num[b]=step;
		dfs(b,step+1);	
	}
	
}
int main()
{
	cin>>n>>k;
	for (int i=1;i<=n;i++)
	{
		num[i]=MAXN;
	}
	dfs(0,1);
	for (int i=1;i<n;i++)
	{
		//cout<<num[i]<<endl;
		ans=max(ans,num[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```




---

## 作者：Lamb_Carp (赞：4)

# 题目分析

由于调时间的时候必定是先从下再逐渐往上升起的（暂不考虑取模），所以我们第一次遍历到的时候必定是这个时间所对应的最小拨动次数。

这个时候再考虑取模，其实无非就是让这不断向上的数字变成一个环，取模后第一次遍历到的数字也就是最小的拨动次数。

# 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rl register ll

const ll N = 1e5+10;

ll n, k, dis[N];

queue<ll> q;

inline ll mod(ll x)
{
	return (x % n + n) % n;
}

inline void bfs()
{
	dis[0] = 0;
	q.push(0);
	
	while(!q.empty())
	{
		ll u = q.front();
		q.pop();
		ll v1 = mod(u + k), v2 = mod(u + 1);
		if(!dis[v1]) dis[v1] = dis[u] + 1, q.push(v1);
		if(!dis[v2]) dis[v2] = dis[u] + 1, q.push(v2);
	}
}

int main()
{
	cin >> n >> k;
	
	bfs();
	
	ll res = -1;
	for(rl i=1; i <= n; ++ i)
		res = max(res, dis[i]);
	
	cout << res << endl;
	return 0;
}
```


---

## 作者：SunsetVoice (赞：4)

更新：修缮了 Latex 公式，补充了正确性的证明。

这是一道 bfs 题目。

使用一个数组 $s$，$s_i$ 存储从时间 $1$ 调到时间 $i$ 最少需要调多少次。

从 $1$ 开始搜索，直到 $s_1$ 至 $s_i$ **都被搜索到**。

最终的答案就是 $s$ 数组中的最大值。

证明：由于超过 $n$ 会直接取模，**所以等于是一个环**，因此只有**你需要向后调的时间**数影响答案，也就是开始的时刻和目标时刻的**差**影响需要调的次数。差相等的时刻对最优方案也相同。

代码中的细节：

由于将 $s_1$ 设为 $0$ 不好判断有没有被搜索过，所以将其设为 $1$，统计答案时再减去即可。

时间复杂度 $O(n)$。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int s[100001] = {0},n,k,i,j;
void bfs(int n,int k){
	queue<int>p;
	p.push(1);
	s[1] = 1;
	while(p.empty()==false){
		if(s[(p.front()+1)%n]==0){
			s[(p.front()+1)%n] = s[p.front()]+1;
			p.push((p.front()+1)%n);
		}
		if(s[(p.front()+k)%n]==0){
			s[(p.front()+k)%n] = s[p.front()]+1;
			p.push((p.front()+k)%n);
		}
		p.pop();
	}
	return;
}
int main(){
	cin>>n>>k;
	bfs(n,k);
	int ans = -1;
	for(int i = 0;i<n;i++){
		ans = max(ans,s[i]-1);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：fengyuxuan (赞：2)

### 题目大意
有一块能显示 $0 \sim n-1$ 分钟的表，每次调时间可以使时间加 $1$ 或 $k$。问按照最优策略按键，从一个时间调到另一个时间最多要按多少次。
### 题目分析
题目中问的是从任意时间到另一任意时间最多要按多少次，但其实我们可以转化一下:

比方说我们从 $1$ 调到 $5$ 和从 $3$ 调到 $7$ 它们的**差是一样的**，而我们调时间换种说法就是在弥补开始时间和结束时间的差，也就是说只要开始时间和结束时间**差一样那按的次数也是一样的**。

既然这样我们就可以假设一开始的时间都是 $0$，我们只需求出从 $0$ 到别的时间所要按的最小次数，再找到最大值即可。

这里用到的是广搜。
### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans=-1,x;
int vis[100005];//标记数组如果重复到达了同一个时间那必定还有更优解 
struct node{
	int num;//表示调到的时间 
	int step;//表示调的次数 
};
queue<node>q;
node f;
int main()
{
	cin>>n>>k;
	q.push((node){0,0});
	vis[0]=1;
	while(!q.empty())
	{
		f=q.front();
		q.pop();
		//考虑时间+1的情况 
		x=(f.num+1)%n;//防止调到的时间大于n-1 
		if(!vis[x])
		{
			vis[x]=1;
			q.push((node){x,f.step+1});	
			ans=max(ans,f.step+1);//更新答案 
		} 
		x=(f.num+k)%n; 
		//同上考虑时间+k的情况
		if(!vis[x])
		{
			vis[x]=1;
			q.push((node){x,f.step+1});
			ans=max(ans,f.step+1);
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Mzaaa (赞：2)

## 题意描述

小明的手表可以往后调 $1$ 或 $k$ 分钟，$n$ 分钟为一小时。

求按照最优策略，从任意时间调到任意时间最多要按多少次。

## 分析

从题目中可得，无论在何时，只要往后调的时间相同，最少次数就相同。

则可以转化为求往后调 $n-1$ 个时间内，最多的按键次数。

又因为这题的权值为 $1$ 所以使用 BFS，如果权值不同，就要用最短路。

## $code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,ans;	
bool vis[100009];	//记录是否走过。
struct node
{
	int t,cnt; 
};
queue<node>q;
void bfs()
{
	q.push((node){0,0});	//将时间为0入队列。
	vis[0]=true;
	while(!q.empty())
	{
		node now=q.front(); q.pop();
		ans=max(ans,now.cnt);	//每个点只会走一遍。
		//那一遍到达所花费的次数就是到达这个时间的最小次数。 
		if(vis[(now.t+1)%n]==false)		//如果下个点没走过。 
			vis[(now.t+1)%n]=true,		//标记为走过。 
			q.push((node){(now.t+1)%n,now.cnt+1});
		if(vis[(now.t+k)%n]==false)
			vis[(now.t+k)%n]=true,
			q.push((node){(now.t+k)%n,now.cnt+1});	
	}
}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>k;
	bfs();
	cout<<ans;
	return 0;
}
```





---

## 作者：what_can_I_do (赞：2)

[传送门](https://www.luogu.com.cn/problem/P8674)

这一题就是从一个多源多点最短路问题。因为它求的是从 $n$ 个点到 $n$ 个点的最优策略。

它的边连的情况有两种，第一种是从点 $i$ 到点 $i+1$，第二种是从点 $i$ 到点 $i+k$，每一条边的权值都是 $1$。

但这题不管是从什么时间开始按，它的结果都是一样的。意思就是如果你从时间 $1$ 开始调，调到时间 $11$ 的最优次数，是跟从时间 $5$ 开始调，调到时间 $15$ 的最优次数一样。

最优次数一样，这很好证明。我们假设要从时间 $a$ 到时间 $b$，需要从 $a$ 往后调 $b-a$ 分钟。那么现在我们让 $a$ 和 $b$ 同时减去 $c$，就变成从时间 $a-c$ 调到时间 $b-c$，那么你就要往后调 $(b-c)-(a-c)$，也就是 $b-a$。我们会发现从时间 $a$ 到 $b$ 所需的时间跟 $a-c$ 到 $b-c$ 相等，那么所需往后调的时间相等，执行的最优策略也一定会相等。

所以我们就可以把这题的多源多点问题改为单源多点问题，也就是从 $0$ 出发的单源最短路径（其实你爱从几出发就从几出发，反正刚才我们已经证了从几点开始进行的单源最短路径最优策略都一样）。

不过这题可以不用最短路的算法，只需要用 bfs 就行了。因为这题每条边的权值都是 $1$，是相同的，所以可以使用 bfs。但如果一个图每条边权值不同，那么你就只能用最短路算法，否则你无法保证此时它是最优解。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,dis[100010],ans=0;
inline void bfs()
{
	queue<int> q[2];
	q[0].push(0),q[1].push(0);
	while(!q[0].empty())
	{
		int x=q[0].front(),s=q[1].front();
		q[0].pop(),q[1].pop();
		if(dis[x]) continue;
		dis[x]=s;
		q[0].push((x+1)%n),q[1].push(s+1);
		q[0].push((x+k)%n),q[1].push(s+1);
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	bfs();
	for(register int i=1;i<=n-1;i++) ans=max(ans,dis[i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：qiuqiuqzm (赞：1)

## P8674 [蓝桥杯 2018 国 B] 调手表题解
一道~~非常~~简单的 BFS 题目。

看到题目说求任意一个时间到另一个时间最多要花费多久时间。我们难道要一个一个去枚举吗。

看到数据范围，一个一个枚举必然会超时。那要怎么办呢？如果我们是从 $x$ 调到 $y$ 的话，那就等于从 $0$ 调到 $|y-x|$。那题目就能转换成求从 $0$ 调到所有其他的数，所花费的时间最大值。

我们可以将标记的 $vis$ 数组来记录时间，顺便标记是否访问。

## $Code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,ans;
int vis[100005]; //标记数组 
queue<int> q;
void bfs()
{
	vis[0]=1; //如果赋值为 0 的话可能会重复回到时间为0时 
	q.push(0);
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		ans=max(ans,vis[now]); //计算最大值 
		if(!vis[(now+k)%n]) //+k 的情况 
		{
			q.push((now+k)%n);
			vis[(now+k)%n]=vis[now]+1; //时间++ 
		}
		if(!vis[(now+1)%n]) //+1 的情况 
		{
			q.push((now+1)%n);
			vis[(now+1)%n]=vis[now]+1;//时间++ 
		}
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>k;
	bfs();
	cout<<ans-1; //因为一开始时间为 0 时赋值为 1，多赋值了 1 ，最后要减掉 a 
	return 0;
}
```


---

## 作者：DegChuZm (赞：1)

## 刷最短路遇到的一道水题

题意：给出 $n$ 和 $m$，求从 $0$ 开始到 $n$ 最长的最短路径。

由题可知，这是一个最短路的题。

本题的难度就在建边上，建边建好了，跑个dij就行了。

我们先按题目模拟，每 $+k$ 建一次边权为 $1$ 的边，其他用 $+1$ 建边。

然后跑最短路，这道题就过了。

给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int head[1000001],cnt,dis[1000001],n,o,v,w,m,x,y,z,ans=-1;
struct node{
    int nex,to,val;
}a[1000001];
struct dcz{
    int u,d;
    bool operator<(const dcz& jntm)const {
        return d>jntm.d;
    }
};
void add(int x,int y,int z){
    a[++cnt].val=z;
    a[cnt].to=y;
    a[cnt].nex=head[x];
    head[x]=cnt;
}
void dij(int o){
    for(int i=1;i<=n;i++){
        dis[i]=INT_MAX;
    }
    dis[o]=0;
    priority_queue<dcz> q;
    q.push((dcz){o,0});
    while(!q.empty()){
        dcz xx=q.top();
        q.pop();
        int u=xx.u;
        int d=xx.d;
        if(d!=dis[u])
            continue;
        for(int i=head[u];i;i=a[i].nex){
            v=a[i].to;
            w=a[i].val;
            if(dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                q.push((dcz){v,dis[v]});
            }
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<n;i++){
        add(i-1,i,1);
    }//建+1的边
        add(n-1,0,1);// 记得连上环
    int val=0,sum;
    for(int i=1;i<=n;i++){
    	sum=val;
    	val+=m;
    	if(val>n-1){
    		val%=n;
		} 
        add(sum,val,1);
    }//建+k的边
    dij(0);
    for(int i=0;i<n;i++){
        ans=max(ans,dis[i]);
    }
    cout<<ans;
    return 0;
}

```

---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

一个数从零开始，通过 $+1$ 或 $+k$ 改变数的大小。如果加之后超过 $n-1$ 就对 $n$ 取模。求该数调到 $1$ 到 $n - 1$ 的次数最多是多少。

## 思路

考虑使用 bfs 维护队列，每次枚举将队首出队（记为队首 $ft$），**当 $ft + 1$ 或 $ft + k$ 之前没有没有被枚举过时候再将 $ft + 1$ 或 $ft + k$ 入队。**

但是要考虑 $ft + 1$ 和 $ft + k$ 是否大于 $n - 1$，这里可以不用加特判，每次考虑的时候直接对其取模就可以了，即 $ft + 1$ 和 $ft + k$ 变成 $(ft + 1) \bmod n$ 和 $(ft + k) \bmod n$：

![](https://huatu.98youxi.com/markdown/work/uploads/upload_92962074d5f2e287fb3f2d7cce7d5d57.png)

最后建立一个数组 $a$ 在每次操作之后更新数组，其中 $a_i$ 表示这个数调到 $i$ 所需最少次数。转移方程是 `a[(ft + 1) % n] = a[ft] + 1` 和 `a[(ft + k) % n] = a[ft] + 1;`，意思为到 $(ft + 1) \bmod n$ 的次数等于到 $ft$ 的次数加一。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

int n, k;
int ans=0;
queue <int> q;
int a[100005];
void bfs()
{
	while(!q.empty())
	{
		int ft=q.front();
		q.pop();
		if(!a[(ft + 1) % n])//判断这种情况之前有没有被枚举过
		{
			a[(ft + 1) % n] = a[ft] + 1;
			q.push((ft + 1) % n);
		}
		if(!a[(ft + k) % n])
		{
			a[(ft + k) % n] = a[ft] + 1;
			q.push((ft + k) % n);
		}
		bfs();
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> k;
	q.push(0);
	bfs();
	for(int i=1;i<n;i++)
		ans=max(ans, a[i]);
	cout << ans;
	return 0;
}
```

---

## 作者：Yoimiyamwf (赞：0)

# 题目大意
给定 $n$ 和 $k$，求将一个数字 $num$ （初始为 $0$）在最优策略下通过如下两种操作：

- $num \gets num+1 \bmod n$
- $num \gets num+k \bmod n$

转变为 $n-1$ 以内的任意一个数字的最大操作数。

# 分析
求最优策略步数，可以将问题建模成图，然后利用最短路来解决。

对于 $n-1$ 以内的每一个数字 $i$，我们可以将 $i$ 向 $n+1 \bmod n$ 和 $n+k \bmod n$ 各连一条边权为 $1$ 的有向边，表示数字 $i$ 经过一次操作可以变为 $i+1 \bmod n$ 或 $n+k \bmod n$，然后以 $0$ 为起点跑一遍最短路，最终得到的每一个数字的最短路径即为最少操作数，取其中最大的输出即可。

# 代码
```cpp
#include <bits/stdc++.h>
#define rint register int
#define in inline
#define r(a) runtimerror(a)
#define w(a) wronganswer(a)
using namespace std;
int n,k,head[1145140],tot,cost[1145140],ans;
bool vis[1145140];
struct node{
	int id,cost;
	bool operator <(const node x) const{
		return cost>x.cost;
	}
}asd;
priority_queue <node> q;
in void runtimerror(int &a){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	a=x*f;
}
void wronganswer(int x){
	if(x<0){x=-x;putchar('-');}
	if(x>9) wronganswer(x/10);
	putchar(x%10^48);
}
struct Edge{
	int to,nex,cost;
}edge[1145140];
in void add_edge(int from,int to,int cost){
	edge[++tot]={to,head[from],cost};
	head[from]=tot;
}
in void dijkstra(int start){
	memset(cost,0x3f,sizeof(cost));
	cost[start]=0;
	q.push((node){start,0});
	while(!q.empty()){
		asd=q.top();
		q.pop();
		if(vis[asd.id]) continue;
		vis[asd.id]=true;
		for(rint i=head[asd.id];i;i=edge[i].nex){
			if(cost[edge[i].to]>asd.cost+edge[i].cost){
				cost[edge[i].to]=asd.cost+edge[i].cost;
				q.push((node){edge[i].to,cost[edge[i].to]});
			}
		}
	}
}
int main(){
	r(n),r(k);
	for(rint i=0;i<n;i++){
		add_edge(i,(i+1)%n,1);
		add_edge(i,(i+k)%n,1);
	}
	dijkstra(0);
	for(rint i=1;i<n;i++) ans=max(ans,cost[i]);
	w(ans);
	return 0;
}
```


---

## 作者：wangyuhao111 (赞：0)

#### 1、题意分析
这道题说：有两种方法到 $n$ 点，分别是 $+1$ 和 $+k$ ，求用这两种方法到达 $n$ 的最小步数，需注意对 $n$ 的取余。
#### 2、主体思路
既然这道题求最小步数，我率先想到了广度优先搜索 $(bfs)$ 。将 $+1$ 设为第一种方式，将 $+k$ 设为另一种方式。
#### 3、 $bfs$ 代码
```cpp
void bfs()
{
    //初始化
    q[r][0]=0;
    q[r][1]=0;
    r++;
    v[0]=1;
    while(h<r)
    {
        d[0]=(q[h][0]+1)%n;   //第一种方式
        d[1]=(q[h][0]+k)%n;   //第二种方式
        for(int i=0;i<2;i++)
        {
            if(!v[d[i]])   
            {
                q[r][0]=d[i];
                q[r][1]=q[h][1]+1;   //步数加1
                r++;
                v[d[i]]=1;
                ans=max(q[r-1][1],ans);
            }
        }
        h++;
    }
    return ;
}
```
#### 4、分析 $bfs$
这个 $bfs$ 用的是数组模拟队列，用 $q[r][0]$ 来表示上一次走到哪，用 $q[r][1]$ 表示上一次的步数，用 $vi$ 数组来打标记 （如果走过，现在又走到了，就死循坏了） 。
#### 5、完整代码
```cpp
#include <iostream>
using namespace std;
int q[100005][2],h,r;
int v[100005]; 
int d[2];
int n,m,ans;
void bfs()
{
    q[r][0]=0;
    q[r][1]=0;
    r++;
    v[0]=1;
    while(h<r)
    {
        d[0]=(q[h][0]+1)%n;
        d[1]=(q[h][0]+k)%n;
        for(int i=0;i<2;i++)
        {
            if(!v[d[i]])
            {
                q[r][0]=d[i];
                q[r][1]=q[h][1]+1;
                r++;
                v[d[i]]=1;
                ans=max(q[r-1][1],ans);
            }
        }
        h++;
    }
    return ;
}
int main()
{
    cin>>n>>k;
    bfs();
    cout<<ans;
    return 0;
}
```
#### 完。

---

## 作者：wuhan1234 (赞：0)

## 1. 编程思路。

一道简单的 BFS 题目。

定义一个数组 $d$，其中 $d_i$ 保存从时刻 $0$ 调整到时刻 $i$ 需要的最少按钮次数。初始值全部赋值为 $-1$。这个数组在搜索过程中还起到一般 BFS 中数组 $vis$ 的作用。若 $d_i$ 的值不为 $-1$，表示时刻 $i$ 已访问过，无需再入队。

执行一次 BFS 过程，求得 $0 \sim n-1$ 这 $n$ 个时刻的每个时刻调整到位需要的最少按键次数 $d_i(0\le i \le n-1)$，求它们的最大值就是所求的答案。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int d[100005];   // d[i]表示 i 时刻需要按的最少次数，初始值设为-1
int n, k;
void bfs()
{
	int q[100005];
	int front=0,rear=0;
	d[0]=0;
	q[rear++]=0;
	while (front<rear)
	{
		int t=q[front++];
		int a=(t+1)%n;    // 按加 1 按钮
		if (d[a]==-1)
		{
			d[a]=d[t]+1;
			q[rear++]=a;
		}
		a=(t+k)%n;        // 按加 k 按钮
		if (d[a]==-1)
		{
			d[a]=d[t]+1;
			q[rear++]=a;
		}
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	memset(d,-1,sizeof d);
	bfs();
	int ans=0;
	for (int i=1;i<n;i++)
		if (ans<d[i]) ans=d[i];
	printf("%d\n",ans);
	return 0;
}

```


---


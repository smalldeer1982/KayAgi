# [蓝桥杯 2018 国 A] 自描述序列

## 题目描述

小明在研究一个序列，叫 Golomb 自描述序列，不妨将其记作 ${G(n)}$。这个序列有 $2$ 个很有趣的性质：

1. 对于任意正整数 $n$，$n$ 在整个序列中恰好出现 $G(n)$ 次。

2. 这个序列是不下降的。

以下是 $G(n)$ 的前几项：

$n$|1|2|3|4|5|6|7|8|9|10|11|12|13
-|-|-|-|-|-|-|-|-|-|-|-|-|-
$G(n)$|1|2|2|3|3|4|4|4|5|5|5|6|6

给定一个整数 $n$，你能帮小明算出 $G(n)$ 的值吗？

## 说明/提示

对于 $30\%$ 的数据，$1 \le n \le 10^6$。

对于 $70\%$ 的数据，$1 \le n \le 10^9$。

对于 $100\%$ 的数据，$1 \le n \le 2\times 10^{15}$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

## 样例 #1

### 输入

```
13```

### 输出

```
6```

# 题解

## 作者：Flanksy (赞：7)

### 数学

很难想的分类讨论，笔者的思路中只有一种能够得到答案。

------------

#### $n \leq 1000000$

直接计算 $G_1,G_2,G_3 \cdots G_{10^6}$ 的值，计算完毕后可以回答 $n \leq 10^6$ 的询问。

------------

#### $n \leq 3793540542$

利用得到的信息扩展可以求解的范围，发现 $G_{10^6}=6137,G_{6137}=264$，但 $6137$ 在序列前 $10^6$ 项中只出现 $117$ 次，扩展时需要考虑未出现的 $147$ 个 $6137$ 造成的影响。

为了方便，计算 $G_1,G_2,G_3 \cdots G_{10^6+147}$，从 $G_{10^6+147+1}$，即 $G_{1000148}=6138$ 开始扩展。

由 $G_{6138}=264$ 得 $\forall \ i \in [10^6+147+1,10^6+147+264],G_i=6138$。像这样枚举 $[6138,10^6+147]$ 中每个整数 $i$ 并计算满足 $G_j=i$ 的整数 $j$ 的范围能够得到 $n \leq 3793540542$ 时任意 $G_n$ 的值。

------------

#### $3793540543 \leq n \leq 2 \times 10^{15}$

进一步扩展，如果区间 $[l,r]$ 满足 $\forall \ j \in [l,r],G_j=i$，那么 $[l,r]$ 中的数在 $G$ 中将出现 $(r-l+1) \times i$ 次。

**满足 $G_j=i$ 的整数 $j$ 必定为一段连续自然数。**

利用以上性质确定 $G_n$ 的值域 $[l,r]$，该区间不仅需要满足 $\forall \ j \in [l,r],G_j=i$，还需要满足 $G_{l-1} \neq G_l,G_{r+1} \neq G_r$。

确定 $G_n$ 值域 $[l,r]$ 的同时可以确定满足 $G_k \in [l,r]$ 的整数 $k$ 的范围 $[l',r']$，显然 $n \in [l',r']$。

根据自描述序列的定义，由于 $\forall \ j \in [l,r],G_j=i$，**值域 $[l,r]$ 中的每个数在 $G$ 中都出现 $i$ 次**。

根据 $n$ 在区间 $[l',r']$ 中第 $n-l'+1$ 个位置得到 $G_n=l +\left \lceil \frac{n-l'+1}{i} \right \rceil -1 = l+ \left \lfloor \frac{n-l'}{i} \right \rfloor$。

结合 $n \leq 3793540542$ 时的做法能够通过本题。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr long long uim=3793540542ll;
constexpr int sta=6138,lim=1000147;
int pos,dp[2000005];//dp[i]存储数列第i项的值  
long long n,ans;
int main(){
	scanf("%lld",&n);
	pos=3,dp[1]=1ll,dp[2]=2ll,dp[3]=2ll;
	for(int i=3;pos+1<=lim;i++)
		for(int j=1;j<=dp[i]&&pos+1<=lim;j++){
			dp[++pos]=i;
			if(pos==n) return printf("%d\n",i),0;
		}
	long long l=lim,r=lim,ls=uim,rs=uim;
	for(int i=sta;i<=lim;i++){
		l=r+1,r+=dp[i];					//更新j的范围 
		ls=rs+1,rs+=(r-l+1)*i;			//更新k的范围 
		if(n>=l&&n<=r) ans=i;			//找到答案(n<=3793540542)
		if(n>=ls&&n<=rs) ans=l+(n-ls)/i;//找到答案(n>=3793540543)
		if(ans!=0ll) break;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：zhanghao233 (赞：6)

感谢 zhanghao 给我的帮助。

# 题目大意

* 自描述序列，记作 ${G(n)}$。

* 对于任意正整数 $n$，$n$ 在整个序列中恰好出现 $G(n)$ 次。

* 这个序列是不下降的。

* $1 \le n \le 2\times 10^{15}$

# 思路
## #1 暴力

最多卡到 40 分。

```cpp
const int N=6e7+5;
a[0]=3,a[1]=1,a[2]=2,a[3]=2;
for(int i=3;i<=N;i++)
	for(int j=1;j<=a[i];j++){
		a[++a[0]]=i;
		if(a[0]==N)
			goto end;
	}
   
end:cin>>n;
cout<<a[n];
```

## #2 优化

用范围来代表每个数的位置。

用二分查找出 $G_i$ ~~没有其他优化的方案了~~

```cpp
struct node{
	int l,r,i;
}G[N];

int find_x(int x){
	int mid=0,l=1,r=x;
	while(l<=r){
		mid=(l+r)/2;
		
		if((G[mid].l<=x&&G[mid].r>=x)||l==r)
			return G[mid].i;
		if(G[mid].l>x)
			r=mid-1;
		if(G[mid].r<x)
			l=mid+1;
	}
}

for(int i=3;i<=N;i++){	
	G[i].l=l,G[i].r=r,G[i].i=i;
	l=r+1,r=l+find_x(i+1)-1;
	
	if(G[i].l<=n&&G[i].r>=n){
		cout<<i<<"\n";
		return 0;
	}
}
```

## #3 正解

我们不妨扩大代表的范围。

对于每一个 $i$ 都是其他的 $i$ 衍生出的。（除了前 2 项。）

* 对于 $i$ 则会衍生出 $G_i$ 段长度相等的数据段。

注意：衍生和产生在文中不一样！产生是指 $G_n=i$ 时，$n$ 和 $i$ 的关系。衍生是指 $G_{G_n}=i$ 时，$n$ 和 $i$ 的关系。

所以，我们可以确定 $n$ 与之衍生的 $i$ 和在总数据段中的第几段。

例：

![](https://cdn.luogu.com.cn/upload/image_hosting/fjz1ffkh.png)

因为 $G_{12}=6,G_6=4$。

对于 $n=12$，可以推断它是由 $i=4$ 衍生出的而且它在总数据段中的第 1 位。

推断：

因为数据段有 $i$ 组，所以 $n$ 在总数据段中的位置：

* $  \lceil (n-m)/i \rceil$

$m$ 代表 $i$ 段前面一共有多少数字。

枚举 $i$ 的衍生总数据长度。如果它超过了 $n$，则超出了 $n$ 的总数据段的范围，所以 $n$ 就在 $m-i \times G_i$ 和 $m+i \times G_i$ 之间。

* $m-i \times G_i \le n \le m+i \times G_i$

我们已经知道了 $n$ 在总数据段中的位置，衍生出 $n$ 的 $i$。

则我们只需要求出当 $G_x=i$ 时的 $\min(x)-1$

因为我们 $G_n$ 是由 $x_n$ 产生的，所以求出 $x_n$ 就行了，所以求出总产生段前一个数再加上 $n$ 在总数据段中的第几段就是答案。

答案为：$\min(x)-1 + \lceil (n-m)/i \rceil$

```cpp
g[0]=2,g[1]=1,g[2]=2;
for(int i=2;i<=N;i++)
	for(int j=1;j<=g[i];j++){
		g[g[0]++]=i;
		if(g[0]>=N-1)
			goto end;
	}
end: cin>>n;

int t=0,q=0;
for(int i=1;;i++){
	t+=g[i]*i;
	if(t>=n){
		t-=g[i]*i;//ceil((n-t)*1.0/i) 我也不知道这样写为什么不可以
		cout<<q+(n-t+i-1)/i<<"\n";
		break;
	}
	q+=g[i];
}
```

---

## 作者：U•ェ•*U (赞：3)

[参考文章](https://www.luogu.com.cn/article/67b5c592)
## 题意
题目表述的很清楚
## 思路
### #1 暴力枚举
根据题目给出的规律，很容易用 $O(n)$ 的时间求出 $10^6$ 的数据，这样就可以得到 $30$ 分。

显然，这种方法是不对的，我们在上面进行优化。

### #2 枚举优化

$g_i$ 用来表示对应**下标出现的次数**，先对 $g_i$ 求和（$x=\sum_{i=1}^{n} g_i$）。在求和的时候判断与目标数据的大小。如果大于目标 $n$，则答案就是下标 $i$。

这样可以得到 $70$ 分。

### #3 正解

因为第 $i$ 个数据会在 $g$ 中出现 $g_i$ 次，那么那么就相当于在 $g$ 中会出现 $g_i$ 个长 $i$ 且数字相等的区间，这样的话，就可以根据 $n$ 所在的区间去求解。

推断出 $n$ 在第 $i$ 个数据段中，是第 $n - m$ 个数字。在第 $i$ 个区域中，每一个数据会重复出现 $i$ 次。那么 $n - m$ 就是在这个段中的位置就是 $\left \lceil ((n - m) / i) \right \rceil$。

这样可以得到 $100$ 分。

## 代码

```
#include <bits/stdc++.h>
#define int long long // 定义int为long long类型，便于处理大数
using namespace std;

int n, res, cnt, g[1000010];

int main() {
	ios :: sync_with_stdio(false); // 关闭同步，提高输入输出效率
	cin >> n; // 读取输入的n值
	g[1] = 1, g[2] = 2; // 初始化g数组的前两个元素

	// 预处理 g[i] 数组
	for (int i = 2, j = 2; i < 1000010; i++)
		for (int k = 0; k < g[i] && j < 1000010; k++) g[j++] = i;

	int i = 1;
	while (true) {
		res += i * g[i]; // 计算当前总和
		if (res >= n) // 如果总和大于等于n，计算并输出结果
			return res -= i * g[i], cout << cnt + (n - res + i - 1) / i << endl, 0;
		cnt += g[i++]; // 计数器增加
	}
	return 0;
}
```

---

## 作者：3_14 (赞：0)

[**题目传送门**](https://www.luogu.com.cn/problem/P8676)

# 思路

由于 $n$ 的取值范围较大，直接暴力计算整个序列会超时。因此，我们采用分阶段计算的策略。先直接计算序列的前一部分，存储在数组中，在计算过程中若找到对应位置则直接输出结果；对于超出这部分范围的 ，通过分析序列性质，利用区间范围来确定 $G \left(n\right)$ 的值。

 * **直接计算序列的前一部分**：我们先手动模拟序列的生成规则，计算出序列的前 $1000147$ 项，并存储在 $dp$ 数组中。在计算过程中，一旦发现当前位置 $pos$ 等于输入的 ，就直接输出对应的 $G\left(n\right)$ 值并结束程序。
 * **利用区间范围计算**：对于 $n$ 大于 $1000147$ 的情况，我们分析序列的位置和值累加和的规律，将其划分为不同的区间。通过遍历这些区间，找到 $n$ 所在的区间，进而确定 $G \left(n\right)$ 的值。

# 代码

```cpp
#include<bits/stdc++.h>
#define Freopen(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
#define lcm(x,y) x/__gcd(x,y)*y
#define lb(x) (x&-x)
#define str to_string
using namespace std;
using ll=long long;
const double EPS=1e-6,PAI=acos(-1.0);
const int MAX=1e6+5,mod=1e9+7,MOD=998244353;
int pos,dp[MAX];  // dp[i] 存储数列第 i 项的值
ll n,ans;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);// 跑更快
    // 读取输入
    cin>>n;
    // 初始化序列的前三项
    pos=3;
    dp[1]=1;
    dp[2]=2;
    dp[3]=2;
    // 直接计算序列的前 1000147 项
    for(int i=3;pos+1<=1000147;i++){
        for(int j=1;j<=dp[i]&&pos+1<=1000147;j++){
            dp[++pos]=i;
            // 如果当前位置等于 n，直接输出结果并结束程序
            if(pos==n){
                cout<<i<<'\n';
                return 0;
            }
        }
    }
    ll l=1000147,r=1000147,ls=3793540542ll,rs=3793540542ll;// 初始化区间范围
    // 利用区间范围计算 G(n)
    for (int i=6138;i<=1000147;i++){
        // 更新序列位置的区间
        l=r+1;
        r+=dp[i];
        // 更新序列值累加和的区间
        ls=rs+1;
        rs+=(r-l+1)*i;
        // 如果 n 在序列位置的区间内，直接确定 G(n) 的值
        if(n>=l&&n<=r)ans=i;
        // 如果 n 在序列值累加和的区间内，通过计算确定 G(n) 的值
        if(n>=ls&&n<=rs)ans=l+(n-ls)/i;
        // 如果已经找到答案，跳出循环
        if(ans!=0ll)break;
    }
    cout<<ans<<'\n';// 输出
    return 0;
}
```

[**AC 记录** ](https://www.luogu.com.cn/record/203626739)

---


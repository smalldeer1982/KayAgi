# [蓝桥杯 2020 国 ABC] 答疑

## 题目描述

有 $n$ 位同学同时找老师答疑。每位同学都预先估计了自己答疑的时间。老师可以安排答疑的顺序，同学们要依次进入老师办公室答疑。

一位同学答疑的过程如下:

1. 首先进入办公室，编号为 $i$ 的同学需要 $s_{i}$ 毫秒的时间。

2. 然后同学问问题老师解答，编号为 $i$ 的同学需要 $a_{i}$ 毫秒的时间。

3. 答疑完成后，同学很高兴，会在课程群里面发一条消息，需要的时间可以忽略。

4. 最后同学收拾东西离开办公室，需要 $e_{i}$ 毫秒的时间。一般需要 $10$ 秒、$20$ 秒或 $30$ 秒，即 $e_{i}$ 取值为 $10000$、$20000$ 或 $30000$。

一位同学离开办公室后，紧接着下一位同学就可以进入办公室了。

答疑从 $0$ 时刻开始。老师想合理的安排答疑的顺序，使得同学们在课程群里面发消息的时刻之和最小。


## 说明/提示

**【样例说明】**

按照 $1,3,2$ 的顺序答疑，发消息的时间分别是 $20000,80000,180000$ 。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例, $1 \leq n \leq 20$ 。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 200$ 。

对于所有评测用例, $1 \leq n \leq 1000,1 \leq s_{i} \leq 60000,1 \leq a_{i} \leq 1000000$, $e_{i} \in\{10000,20000,30000\}$ ，即 $e_{i}$ 一定是 $10000 、 20000 、 30000$ 之一。 

蓝桥杯 2020 年国赛 A 组 H 题（B 组 H 题, C 组 J 题）。

## 样例 #1

### 输入

```
3
10000 10000 10000
20000 50000 20000
30000 20000 30000```

### 输出

```
280000```

# 题解

## 作者：ydclyq (赞：14)

[题目链接](https://www.luogu.com.cn/problem/P8732)

本题的基本思路是贪心。

对于任意一种顺序，

如果我们交换相邻的学生 $i,i+1$, 在交换前这两个同学的时刻总和是：

$(s_i+a_i)+(s_i+a_i+e_i+s_{i+1}+a_{i+1})$

交换后这两个同学的时刻总和是：

$(s_{i+1}+a_{i+1})+(s_{i+1}+a_{i+1}+e_{i+1}+s_i+a_i)$

显然这两个同学的交换顺序不会引起其他学生发消息的时刻变化。

我们不妨令未交换之前时刻总和更小，对式子进行化简：

$s_i+a_i+e_i<s_{i+1}+a_{i+1}+e_{i+1}$

那么说明 $s_i,a_i,e_i$ 加和越小，放在前面的的话答案越小。

于是我们便找到了排序方法。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
int T = 1;
int n;
struct D{
    int s,a,e;
    bool operator < (const D&B) const{
        return s+a+e<B.s+B.a+B.e;
    }
}h[1005];

void solve(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>h[i].s>>h[i].a>>h[i].e;
    }
    sort(h+1,h+n+1);
    ll ans=0,now=0;
    for(int i=1;i<=n;i++){
        now+=h[i].s+h[i].a;
        ans+=now;
        now+=h[i].e;
    }
    cout<<ans;
}

int main(){
    //cin >> T;
    while (T--) solve();
    return 0;
}
```




---

## 作者：linyukun (赞：7)

## 1. 前言
本文的分析会比较通俗，自己要多去思考，麻烦一定 _仔细全部看完_，有异议、不懂或认为可以优化请私信反馈呢。  

## 2. 题目解析：
首先，这是一道比较纯的贪心题，按题目要求，我们分析一下。  
输入一个个访问时间，我们将它分为三部分:
* 发消息前 ——> 进入并且问了个问题。
* 发消息中 ——> 获得解答后开心地~~以超越时间的速度~~发了我们要求时刻的消息。
* 发消息后 ——> 走出办公室，换下一个人循环。

显而易见的，**要想让后面的尽早发，那么前面的时间越短越好**。因为越靠前的人，他的耗时影响的人越多【所以后面的人和他一起等】，和接水问题思路差不多。 

_排序思路：总时间从小到大。 最后记录时刻输出即可。_

## 3.提示要点：
* 时刻是**个体的累计，不是最后一个人**！
* 时刻**不能输入时预处理，我们那时还不知道进入顺序**。
* 排序比较函数写全面。

## 4.代码写作：
理论存在，实践开始。  

代码理有详细的注释幺~
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,n,ke;//ke是时刻
struct aaa{
	long long s,a,e,sum;//sum是总和，其他的在题目里
}a[1005];
bool cmp(aaa a,aaa b){
	return a.sum<b.sum;//按思路排序
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].s>>a[i].a>>a[i].e;
		a[i].sum=a[i].a+a[i].s+a[i].e;//预处理求总和
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		ke+=a[i].a+a[i].s+a[i-1].e;//累计时刻
		ans+=ke;
	}
	cout<<ans;
	return 0;
}
```

## 5.总结鸣谢：
**本题是一道考验耐心思维的贪心，难度适中。**  
**另：还有感谢管理大大的的审核帮助。**

---

## 作者：small_john (赞：3)



## 分析

简单的贪心题。

这道题与排队打水的问题很相似。让时刻之和最小，等同于让每个人等待的时间之和最小，每个人需要花 $s_i+a_i+e_i$ 的时间，那么按照 $s_i+a_i+e_i$ 从小到大的顺序排序即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1e3+5;
int n;
LL ans,sum;
struct node{
	int s,a,e,sum;
}a[N];
bool cmp (node a,node b) {return a.sum<b.sum;}
int main()
{
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);//给cin和cout加速
	cin>>n;
	for(int i = 1;i<=n;i++)
		cin>>a[i].s>>a[i].a>>a[i].e,a[i].sum = a[i].s+a[i].a+a[i].e;
	sort(a+1,a+n+1,cmp);
	for (int i = 1;i<=n;i++) 
		ans+=sum+a[i].s+a[i].a,sum+=a[i].sum;
	cout<<ans;
	return 0;
}
```

## 证明

交换法。

设 $p_i = s_i+a_i+e_i$，$d_i = s_i+a_i$，假设现在同学按 $p$ 数组从大到小排好序。我们随机确定一个 $q$，将第 $q$ 与第 ${q+1}$ 个人交换。那么第 $1\sim q-1$ 个人的时刻不变，第 $q+2\sim n$ 个人的时刻不变。接下来就是证明过程。其中 $d_q,d_{q+1},p_{q},q_{q+1}$ 是交换后的数据。

第 $q$ 个人的时刻变为了 $\displaystyle\sum_{i=1}^{q-1}p_i+d_q$，比原来加上了 $d_q-d_{q+1}$，第 $q+1$ 个人的时刻变为了 $\displaystyle\sum_{i=1}^{q-1}p_i+p_q+d_{q+1}$，比原来加上了 $p_q-p_{q+1}+d_{q+1}-d_{q}$。那么第 $q$ 与第 $q+1$ 个人的时刻和加上了 $d_q-d_{q+1}+p_q-p_{q+1}+d_{q+1}-d_{q}=p_q-p_{q+1}$，又因为交换了第 $q$ 与第 $q+1$ 个人，所以 $p_q>p_{q+1}$，所以 $p_q-p_{q+1}>0$。没有原来好；

综上所述，按照 $s_i+a_i+e_i$ 从小到大的顺序排序一定是最优的，可以贪心。

## 后记

$2023.03.14\text{ update: }$ 修改了部分表达问题。

---

## 作者：Maysoul (赞：2)


### 十年 OI 一场空，不开 long long 见祖宗!!!

------------


## 分析：

这是一道很经典的贪心题。

要求我们找出同学在课程群中所发信息的间隔最小。

简单地说，就是让同学发消息的间隔尽可能**紧凑**。

那么，也就是将它们的用时**从小到大排列**，让前面的用时越短越好。

前面的用时又分为三部分:

1. 进入办公室的时间。

2. 答疑所用的时间（发消息的时间）。

3. 收拾东西离开的时间。


让我们分析一下，第一位同学用时为发消息之前的两条。

但是他收拾东西离开的时间大小会影响下一位同学。

**所以应该比较三条时间之和**。

若时间之和相等呢？

那就仅比较前两条的大小，原因上面已经给出。

还有一个细节：

**要求是发消息的时刻之和，而每个同学占用时间的加和是时刻**。

所以我们还要把每个时刻再加起来。

------------


## AC Code:

```cpp
//2023/3/30
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num,ans;
struct stu{
	long long si,ai,ei;
}a[1010];
bool cmp(stu x,stu y)
{
	long long hex=x.ai+x.ei+x.si;
	long long hey=y.ai+y.ei+y.si;
	if(hex==hey)
	{
		return x.ai+x.ei<y.ai+y.ei;
	}
	else
	{
		return hex<hey;
	} 
}
int main()
{
	long long n,he=0,zonghe=0;
	cin>>n;
	for (int i=0;i<n;i++)
	{
		cin>>a[i].si>>a[i].ai>>a[i].ei;
	}
	sort(a,a+n,cmp);
	for (int i=0;i<n;i++)
	{
		if(i>=1)
		{
			he+=a[i-1].ei;
		}
		he+=a[i].si;
		he+=a[i].ai;
		zonghe+=he;
		//cout<<he<<endl;
	}
	cout<<zonghe<<endl;
	return 0;
}
```


---

## 作者：liupei (赞：1)

## 思路
这到题就是说同学从进去到结束的最少时刻为多少，比如第一个同学进去时间 $10000$ 加 发完信息 $10000$ 那么这就是他发完信息的时刻 $20000$。 小为同学的时刻就是上位同学的总时间加是他发完信息的时间之和，题目说的是最少时刻，那么我们只需要把每位同学的总时间从小到大排列就行了，因为是时刻的累计，不是用的时间的累积，所以前面用的总时间越少的话发消息的时刻之和就越小。
## 代码
```python
n = int(input().strip())
s = [list(map(int,input().split())) for i in range(n)]
r = []
for i in range(n):
    r.append([sum(s[i]),s[i][2]])
r.sort()
m = 0
s1 = 0
for i in range(n):
    m += r[i][0]-r[i][1] + s1
    s1 += r[i][0]
print(m)

```

---

## 作者：Yujinhe469 (赞：1)

这道题用**贪心**就可以解决。

每次选当前剩余选总用时间 $t_i$ 最短的，若有相同则选 $s_i+a_i$ 最小的。

证明：若选的不是当前剩余总用时间最短的（或其中 $s_i+a_i$ 最小的，后文省略）是最优解，设选的是 $i$ 号，当前剩余总用时间最短的是 $j$ 号，则交换这两个同学在最终排位中的顺序，此时其他同学发消息的时间必会减少；对于这两个同学，易证这两个同学的发消息时间总和也会减少，发现更优解，矛盾，贪心算法的正确性得证。

故排序数组并计算即可。

**AC 代码如下：**

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1009;
ll n,ans,cnt;
struct Time{
	int t,e;
}T[N];
bool cmp(const Time&A,const Time&B){
	return A.t<B.t||A.t==B.t&&A.e<B.e;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		ll s,a,e;
		cin>>s>>a>>e;
		T[i].t=s+a+e; T[i].e=e;
	}
	sort(T+1,T+n+1,cmp);
	for(int i=1;i<=n;i++)
		ans+=(cnt+T[i].t-T[i].e),cnt+=T[i].t;
	cout<<ans<<endl;
	return 0;
}

```

注意开 long long（题目中使用毫秒作为单位的意义于此）。

---


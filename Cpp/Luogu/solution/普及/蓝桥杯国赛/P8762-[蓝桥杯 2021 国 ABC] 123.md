# [蓝桥杯 2021 国 ABC] 123

## 题目描述

小蓝发现了一个有趣的数列, 这个数列的前几项如下:

$1,1,2,1,2,3,1,2,3,4, \ldots$

小蓝发现, 这个数列前 $1$ 项是整数 $1$ , 接下来 $2$ 项是整数 $1$ 至 $2$ , 接下来 $3$ 项是整数 $1$ 至 $3$ , 接下来 $4$ 项是整数 $1$ 至 $4$ , 依次类推。

小蓝想知道, 这个数列中, 连续一段的和是多少。

## 说明/提示

对于 $10 \%$ 的评测用例, $1 \leq T \leq 30,1 \leq l_{i} \leq r_{i} \leq 100$ 。

对于 $20 \%$ 的评测用例, $1 \leq T \leq 100,1 \leq l_{i} \leq r_{i} \leq 1000$ 。

对于 $40 \%$ 的评测用例, $1 \leq T \leq 1000,1 \leq l_{i} \leq r_{i} \leq 10^{6}$ 。

对于 $70 \%$ 的评测用例, $1 \leq T \leq 10000,1 \leq l_{i} \leq r_{i} \leq 10^{9}$ 。

对于 $80 \%$ 的评测用例, $1 \leq T \leq 1000,1 \leq l_{i} \leq r_{i} \leq 10^{12}$ 。

对于 $90 \%$ 的评测用例, $1 \leq T \leq 10000,1 \leq l_{i} \leq r_{i} \leq 10^{12}$ 。

对于所有评测用例, $1 \leq T \leq 100000,1 \leq l_{i} \leq r_{i} \leq 10^{12}$ 。 

蓝桥杯 2021 国赛 A 组 E 题（B 组 F 题，C 组 F 题）。

## 样例 #1

### 输入

```
3
1 1
1 3
5 8```

### 输出

```
1
4
8```

# 题解

## 作者：Light_az (赞：25)

怎么其他题解这么不人性化，这道题可以不需要前缀和，利用数学思想就能轻松过关。

首先，我们的任务是求出 $l$ 和 $r$ 所在的行坐标和列坐标，对于行坐标，我们可以手写一个二分查找，通过枚举前 $mid$ 行以前的数的个数来判断 $l$ 和 $r$ 是否在这一行：

```cpp
ll Find(ll n){
	ll l=1,r=1000000;
	while(l<r){
		ll mid=(l+r)/2;//mid代表行
		if((1+mid)*mid/2>=n) r=mid;//求第mid行及以前的数的个数
		else l=mid+1;
	}
	return r;
}
```

然后我们得知了 $n$ 的行数，那么列数就是 `n-Find(n-1)`，此时我们已经得知了 $n$ 的坐标，现在我们可以求 $l$ 和 $r$ 的区间和了。

首先我们要知道如何求前 $n$ 行的和，我们可以使用前 $n$ 行求和函数：

```cpp
ll Ans(ll n){
	return n*(n+1)/6*(n+2)/6;//前 n 行都是等差数列，合起来得出以下公式
}
```

之后我们要求第 $n$ 行的和，也就是 1  一直数到 $n$ 的横坐标的和，我们使用高斯公式：

```cpp
ll f(ll n){
	return (1+n)*n/2;//（首项+末项）*项数/2
}
```

最后，我们已经得到了前 $l$ 个数和前 $r$ 个数的和，我们只需要把它们相减就可以得出答案，当然，保险起见，我们要使用 `unsigned long long`，下面是完整代码：

```cpp
#include<bits/stdc++.h>
#define ll unsigned long long
#define F(i,a,b) for (int i=a;i<=b;i++)
#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)
using namespace std;
const int N=1e7+10,NN=1e4+10;
ll n,m,k,x,y,u,v,w,cnt=0,ans=0,t=0,l,r,len,T;
ll mini=INT_MAX,maxi=0,Mod;
string s1,s2;
ll a[5];
ll Find(ll n){//二分
	ll l=1,r=10000000;
	while(l<r){
		ll mid=(l+r)/2;
		if((1+mid)*mid/2>=n) r=mid;
		else l=mid+1;
	}
	return r;
}
ll f(ll n){//高斯公式
	return (1+n)*n/2;
}
ll Ans(ll n){//前 n 行的和
	return n*(n+1)*(n+2)/6;
}
int main(){
	Test;
	cin>>T;
	while(T--){
		cin>>l>>r;
		a[1]=l-f(Find(l)-1);//前 l 行
		a[2]=r-f(Find(r)-1);//前 r 行
		ll ans1=Ans(Find(l)-1)+a[1]*(a[1]-1)/2;//前 l 个数的和
		ll ans2=Ans(Find(r)-1)+(a[2]+1)*a[2]/2;//前 r 个数的和
		cout<<ans2-ans1<<"\n";
	}
	return 0;
}
```



---

## 作者：ztntonny (赞：22)

## 分析+思路+代码

#### 前附阅读本题解所必须掌握的算法[前缀和](https://www.luogu.com.cn/blog/ztntonny/qian-zhui-hu-jian-shu)，大佬请忽略。

观察下面的表格：

| 数列 | 1 | 1 | 2 | 1 | 2 | 3 | 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 | 5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 序号 | num.1 | num.2 | num.3 | num.4 | num.5 | num.6 | num.7 | num.8 | num.9 | num.10 | num.11 | num.12 | num.13 | num.14 | num.15 |
| 层级 | lev.1 | lev.2 | lev.2 | lev.3 | lev.3 | lev.3 | lev.4 | lev.4 | lev.4 | lev.4 | lev.5 | lev.5 | lev.5 | lev.5 | lev.5 |

其中“层级”是一个关键，我们分析这个数列，是多个等差数列组成的，那么就自然想要模拟，但是看到 $10^{12}$ 的数据规模又望而生怯，所以通过一些技巧来拿下。下面利用一些前缀和的思想来实现，我们把数列形象的划成一个等差数列：

```
{1},{1,2},{1,2,3},{1,2,3,4},{1,2,3,4,5}......
```

从而每一项的数值都代表了该段所对应的子等差数列的项数，那么将其转化为前缀和形式：

```
{1},{1+2},{1+2+3},{1+2+3+4},{1+2+3+4+5}......
```

更直观的：

```
{s[1]},{s[2]},{s[3]},{s[4]},{s[5]}......
```

其中 ```s[i]``` 代表 $1$ 到 $i$ 的数值和，也就是一个前缀和数组 ```s[]```，从而写出前缀和代码：

```
for ( int i = 1; i < 2000005; i++ )
	s[i] = s[i - 1] + i;
```

然后再分析数组本身的前缀和，可以先不考虑具体到每一个数值得，但是要每一个元素对应的，也就是这个数组：

```
{s[1]},{s[2]},{s[3]},{s[4]},{s[5]}......
```

为了求每一个元素对应的前缀和，那么写出预处理代码：

```cpp
for ( int i = 1; i < 2000005; i++ )
	s[i] = s[i - 1] + i , f[i] = f[i - 1] + s[i];
```

```f[i]``` 即为所求，但是这没有精确到数值，设要求的数值 $a$ 在第 $lev$ 层，那么还需要再补一个循环：

```cpp
for ( int i = 1; i <= a - s[lev]; i++ )	sum += i;
```

来弥补在 $a$ 所在阶梯内部的小于 $a$ 的数值和，易发现这个可以简化为：

```cpp
sum += ( a - s[lev] + 1 ) * ( a - s[lev] ) / 2;
```

就是 $\mathcal{O(1)}$ 的时间复杂度了，那么如何求出 $lev$ 呢？用一个stl库的自带二分查找函数来解决，也可以手写：

```cpp
ll lev = max( 0ll , (ll)( lower_bound( s , s + 2000005 , a ) - s - 1 ) );
//不过好像直接暴力搜也可以，没试过还是用最省时间的啦 ：)
```

那么现在写出了求出第 $i$ 个数值的对应前缀和的核心代码：

```cpp
for ( int i = 1; i < 2000005; i++ )
	s[i] = s[i - 1] + i , f[i] = f[i - 1] + s[i];
cin >> t;
while ( t-- )
{
	cin >> a;
	ll lev = max( 0ll , (ll)( lower_bound( s , s + 2000005 , a ) - s - 1 ) );
	ll sum = f[lev];
	sum += ( r - s[lev] + 1 ) * ( r - s[lev] ) / 2 ;
	cout << sum << endl;
}
```

下面应用前缀和的思想，$r$ 到 $l$ 的和就是 ```sum[l]-sum[r - 1]```，列出主程序：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll s[2000005] , f[2000005] , ans , t , r , l; 
int main()
{
	for ( int i = 1; i < 2000005; i++ )
		s[i] = s[i - 1] + i , f[i] = f[i - 1] + s[i];
	cin >> t;
	while ( t-- )
	{
		cin >> r >> l;
		r--;
		ll levr = max( 0ll , (ll)( lower_bound( s , s + 2000005 , r ) - s - 1 ) ) , levl = max( 0ll , (ll)( lower_bound( s , s + 2000005 , l ) - s - 1 ) );
		ll sumr = f[levr] , suml = f[levl];
		sumr += ( r - s[levr] + 1 ) * ( r - s[levr] ) / 2 , suml += ( l - s[levl] + 1 ) * ( l - s[levl] ) / 2;
		cout << suml - sumr << endl;
	}
	return 0;
}
```

于是我们就完美的AC啦~希望这份题解对您有帮助！

```cpp
//对了补一句，大家不要忘了开long long哦————要不然会得到满屏热血沸腾的颜色（doge
```

---

## 作者：DengDuck (赞：13)

就像其他题解那样，我们将这个数列分解成一个二维的三角形，大概长这样：

```
1
1 2
1 2 3
1 2 3 4
...
```

来推导几个公式。

第 $i$ 行的数字总和：

$$
1+2+...+i=\frac{1+2+...+i+1+2+...+i}{2}=\frac{(1+i)+(2+i-1)+...+(i+1)}{2}=\frac{i\times(i+1)}{2}
$$

前 $i$ 行的数字总和：

$$
\frac{1\times 2}{2}+\frac{2\times 3}{2}+...+\frac{i\times (i+1)}{2}=\frac 1 2 (1\times 2+2\times 3+...+i\times (i+1)) =\frac 1 6 \times (1\times 2\times 3+2\times 3\times (4-1)+...+i\times (i+1)\times(i+2-i+1))=\frac 1 6 \times i\times (i+1)\times (i+2)
$$

于是我们用类似前缀和的思想，把问题拆成几个式子加加减减即可。

这里我们还需要一个函数来求某个数字在哪一行，二分即可，实现如下：

```cpp
long long fd(long long x)
{
    long long l=1,r=10000000,ans;
    while(l<=r)
    {
        long long mid=(l+r)/2;
        if(mid*(mid+1)/2<x)l=mid+1;
        else 
        {
            r=mid-1;
            ans=mid;
        }
    }
    return ans;
}
```

全部代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,l,r,ans,t1,t2,st,ed,k1,k2;
long long fd(long long x)
{
    long long l=1,r=10000000,ans;
    while(l<=r)
    {
        long long mid=(l+r)/2;
        if(mid*(mid+1)/2<x)l=mid+1;
        else 
        {
            r=mid-1;
            ans=mid;
        }
    }
    return ans;
}
int main()
{
    scanf("%lld",&n);
    while(n--)
    {
        scanf("%lld%lld",&l,&r);
        st=fd(l),ed=fd(r);//找出行
        t1=l-st*(st-1)/2;//划归为几个完整的行，方便计算
        t2=r-ed*(ed-1)/2;
        k1=(st-1)*st*(st+1)/6;//求出两个行的前缀和
        k2=(ed-1)*ed*(ed+1)/6;
        cout<<k2-k1+(t2+1)*t2/2-(t1-1)*t1/2<<endl;//运算，把刚才处理掉的补上
    }
}
```

---

## 作者：Struggle_ong (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8762)

### 题目大意：

有一个数列，有 $ n $ 段，每一段由 $ 1 $ 到 $ n $ 组成，现给定 $ l $ 和 $ r $，求 $ l $ 到 $ r $ 区间的和。

### 解决方案：

一看这个题目，你就想起了哪个算法？对，就是前缀和。我们可以用 $ a $ 数组来存储第 $ i $ 段的和以及第 $ i $ 段及之前所有数的个数。同时用 $ b $ 数组存储第 $ i $ 段及之前的所有数的和。通过打表可知，每一项数之前的和都是有规律的，容易得到以下代码：

```cpp
long long sum(long long x)
{
    long long k=floor(sqrt(x*2));
    while(k*(k+1)/2>x)k--;
    return b[k]+a[x-a[k]];
}
```

### 注意开  ```long long``` 


#### AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
inline long long read()
{
	long long s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
const long long N=5000000;
long long a[5000010],b[5000010];
long long sum(long long x)
{
    long long k=floor(sqrt(x*2));
    while(k*(k+1)/2>x)k--;
    return b[k]+a[x-a[k]];
}
int main()
{
	for(long long i=1;i<=N;++i)
	{
        a[i]=a[i-1]+i;
        b[i]=b[i-1]+a[i];   
    }
    long long t=read();
    while(t--)
    {
    	long long l=read(),r=read();
    	cout<<sum(r)-sum(l-1)<<endl;
	}
	return 0;
}
```


---

## 作者：Infinite_Eternity (赞：4)

# Description

[P8762 [蓝桥杯 2021 国 ABC] 123](https://www.luogu.com.cn/problem/P8762)

对于数列：$1,1,2,1,2,3,1,2,3,4,\cdots$, 求其中第 $l_{i}$ 个数到第 $r_{i}$ 个数的和。共 $T$ 组询问。

数据范围：$1 \leq T \leq 100000$，$1 \leq l_{i} \leq r_{i} \leq 10^{12}$。 

# Analysis

首先，二分查找 $l$ 和 $r$ 所在的位置。然后，计算 $l$ 和 $r$ 之间所有数的和 $sum$。由于数据范围很大，若直接利用 `for` 循环求和，一定会超时。

我们将数字表现为二维数组的形式（此处列举前五行）：

```
1
1，2
1，2，3
1，2，3，4
1，2，3，4，5
```
因为每一行都是以 $1$ 为首的等差序列，因此，对于第 $n$ 行，其所有数的和为 $\dfrac{n(n+1)}{2}$。由此，我们也可得出前 $n$ 行所有数的和为 $\dfrac{n(n+1)(n+2)}{6}$。

# Code

> 有点乱，仅供参考。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pb push_back
typedef pair<int,int>PII;
const int Max=1e5+5;
const int INF=1e15+5;
inline int read()
{
    register char c = getchar();
    register int x = 0, f = 1;
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + c - 48;c = getchar();}
    return x * f;
}
inline int Power(int base, int power)
{
    int result = 1;
    while (power > 0)
    {
        if (power % 2 == 1)
        {
            result = result * base;
        }
        power = power / 2;
        base = (base * base);
    }
    return result;
}
inline int gcd(int x,int y)
{
    if(x==0&&y!=0) return y;
    if(x!=0&&y==0) return x;
    if(x==0&&y==0) return 0;
    if(x%y==0) return y;
    return gcd(y,x%y);
}
inline int binary(int x)
{
    int l=0,r=1e7;
    while(l<=r)
    {
        int mid=(l+r)/2;
        int m=mid;
        mid=mid*(mid+1)/2;
        if(mid>x) r=m-1;
        else l=m+1;
    }
    return r;
}
signed main()
{
    int t;
    t=read();
    while(t--)
    {
        int left,right;
        left=read(),right=read();
        int l=binary(left);
        int r=binary(right);
        int sum=0;
        if(l==r)
        {
            if((l+1)*l/2!=left) left=left-l*(l+1)/2;
            else left=l;
            if((r+1)*r/2!=right) right=right-r*(r+1)/2;
            else right=l;
            sum+=((right*(right+1)/2)-(left-1)*left/2);
            printf("%lld\n",sum);
            continue;
        }
        if((l+1)*l/2==left&&(r+1)*r/2==right)
        {
            if(l+1<=r)
            {
                int len=r-l-1;
                sum+=((l+1)*(l+2)/2)*(r-l);
                if(len>=0) sum=sum+(l+2)*(len*(len+1)/2);
                len--;
                if(len>=0) sum+=(len*(len+1)*(len+2)/6);
            }
            sum+=l;
        }
        else if((l+1)*l/2!=left&&(r+1)*r/2==right)
        {
            if(l+2<=r)
            {
                int len=r-l-2;
                sum+=((l+2)*(l+3)/2)*(len+1);
                if(len>=0) sum=sum+(l+3)*(len*(len+1)/2);
                len--;
                if(len>=0) sum+=(len*(len+1)*(len+2)/6);
            }
            left=left-l*(l+1)/2;
            sum+=((l+1)*(l+2)/2-left*(left+1)/2+left);
        }
        else if((l+1)*l/2==left&&(r+1)*r/2!=right)
        {
            if(l+1<=r)
            {
                int len=r-l-1;
                sum+=((l+1)*(l+2)/2)*(r-l);
                if(len>=0) sum=sum+(l+2)*(len*(len+1)/2);
                len--;
                if(len>=0) sum+=(len*(len+1)*(len+2)/6);
            }
            sum+=l;
            right=right-r*(r+1)/2;
            sum+=(right*(right+1)/2);
        }
        else
        {
            left=left-l*(l+1)/2;
            right=right-r*(r+1)/2;
            if(l+2<=r)
            {
                int len=r-l-2;
                sum+=((l+2)*(l+3)/2)*(len+1);
                if(len>=0) sum=sum+(l+3)*(len*(len+1)/2);
                len--;
                if(len>=0) sum+=(len*(len+1)*(len+2)/6);
            }
            sum+=((l+1)*(l+2)/2-left*(left+1)/2+left);
            sum+=(right*(right+1)/2);
        }
        printf("%lld\n",sum);
    }
    return 0;
}
```


---

## 作者：while_true (赞：3)

为什么可以使用前缀和，这里提供解释：  
初读题目，我们发现这个数列很迷惑，似乎不能使用数学方法来解。
$$
1,1,2,1,2,3,1,2,3,4,\cdots
$$

 但是，我们可以想到 **数形结合** 的方式，我们将数列看作一个三角形，于是他变成了：   
$$1$$
$$1,2$$
$$1,2,3$$
$$1,2,3,4$$
$$\cdots\cdots$$

 于是本题变得好思考了些：我们只要记录每一行的总和，再记录到数列第 $n$ 项的前缀和，然后在每次输入 $l,r$ 时，答案便等于数 $r$ 所在的行最后一个数位置的前缀和，减去数 $r$ 所在行的位于 $r$ 后面的数的总和，减去 $l,r$ 两数所在行之间所有行的和，再减去数 $l$ 所在行的位于 $l$ 之前的所有数的和。  
 使用 `tmp * (tmp + 1) / 2` 的方式来估计行，最后再进行前缀和相减。   
 

---


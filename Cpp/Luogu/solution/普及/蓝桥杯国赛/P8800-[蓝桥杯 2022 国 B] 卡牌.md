# [蓝桥杯 2022 国 B] 卡牌

## 题目描述

这天，小明在整理他的卡牌。

他一共有 $n$ 种卡牌，第 $i$ 种卡牌上印有正整数数 $i(i \in[1, n])$, 且第 $i$ 种卡牌现有 $a_{i}$ 张。

而如果有 $n$ 张卡牌，其中每种卡牌各一张，那么这 $n$ 张卡牌可以被称为一套牌。小明为了凑出尽可能多套牌，拿出了 $m$ 张空白牌, 他可以在上面写上数 $i$，将其当做第 $i$ 种牌来凑出套牌。然而小明觉得手写的牌不太美观，决定第 $i$ 种牌最多手写 $b_{i}$ 张。

请问小明最多能凑出多少套牌?

## 说明/提示

**【样例说明】**

这 $5$ 张空白牌中，拿 $2$ 张写 $1$，拿 $1$ 张写 $2$，这样每种牌的牌数就变为了 $3,3,3,4$，可以凑出 $3$ 套牌，剩下 $2$ 张空白牌不能再帮助小明凑出一套。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，保证 $n \leq 2000$;

对于 $100 \%$ 的数据，保证 $n \leq 2 \times 10^{5} ; a_{i}, b_{i} \leq n ; m \leq n^{2}$ 。 

蓝桥杯 2022 国赛 B 组 C 题。

## 样例 #1

### 输入

```
4 5
1 2 3 4
5 5 5 5```

### 输出

```
3```

# 题解

## 作者：Bitter_Tea (赞：17)

我的做法是**二分**

有序性是显然的，如果我们不能凑出$\ c\  $套牌，那么我们一定不能凑出$c+1$套牌。

二分的$\ l\ $也就是直接由$\ a_i\ $凑出的牌的数目，$\ r\ $是由$\ a_i+b_i\  $凑出的牌的数目。

在判断函数中，如果能当前能凑出期望的$\ mid\ $张，那么就把需要手写的加起来，否则直接不符合条件。最后再计较需要的数目$\ s\ $和$\ m\ $。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

int n;
int a[N];
int b[N];
long long m;

bool judge(int x) {
    long long s = 0;
    for (int i = 1; i <= n; i++) {
        if (x - a[i] <= b[i]) {
            s += max(x - a[i], 0);
        }
        else return false;
    }
    if (s <= m) return true;
    return false;
}
int main() {
    cin >> n >> m;
    int l = 0x3f3f3f3f;
    int r = 0;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        l = min(l, a[i]);
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
        r = max(r, b[i] + a[i]);
    }
    int ans;
    while (l <= r) {
        int mid = l + r >> 1;
        if (judge(mid)) {
            ans = mid;
            l = mid + 1;
        }
        else r = mid - 1;
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：wangyi_c (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P8800)

## 1.题目大意

给我们 $n$ 和 $m$，告诉我们原有的 $a$ 数组和能手写的 $b$ 数组，问最多能凑取多少副牌。

## 2.思路讲解

一个**最多**，告诉我们这道题要么是贪心，要么是二分。因为题解区里多数是贪心做出来的，而二分的思路又比较简单，所以我来一发二分题解。

二分答案的核心在于 ```check``` 函数，而其余就是套模板就行了。这次，我主要是来讲解一下 ```check``` 函数应该怎么写。先看代码。

```cpp
bool check(int x){
	int sum=0;
	for(int i=1;i<=n;i++){
		if(x-a[i]>b[i]) return false;
		sum+=max(x-a[i],0ll);
	}
	return (sum<=m)?true:false;
}
```

我们一句一句来看。

首先，看到循环体内的第一句，那么为什么在 $x-a_i>b_i$ 的时候要直接返回“不可以，总司令”呢？因为我们的 $x$ 代表的是凑齐 $x$ 副牌，而凑齐牌又是每个花色都要有的，当最多手写的数量加上原本的数量都不够的时候，即 $x>a_i+b_i$，那肯定是不行的。

再看到下面那一句，这句就比较好理解了，如果 $x-a_i$ 是负数，那么是足够的，就不用手写了，否则是要用 $x-a_i$ 张手写牌。

看到返回语句，这里比较偷懒，用了三目运算符，先换成通用版本：

```cpp
if(sum<=m) return true;
else       return false;
```

这就一目了然了，当需要的数量比能供给的数量还要多时，肯定不行。否则就可以。

希望大家先自行理解一遍再看代码。

## 3.AC 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2e5+10;
int n,m,a[maxn],b[maxn],l=0,r=1e7;
bool check(int x){//上面解释过了
	int sum=0;
	for(int i=1;i<=n;i++){
		if(x-a[i]>b[i]) return false;
		sum+=max(x-a[i],0ll);
	}
	return (sum<=m)?true:false;
}
int solve(){//二分板子
	while(l+1<r){
		int mid=(l+r)/2;
		if(check(mid)){
			l=mid;
		}
		else r=mid;
	}
	if(check(r)) return r;
	return l;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	cout<<solve();
	return 0;
}
```

_THE END_

By wangyi_c

---

## 作者：w9095 (赞：8)

[P8800 [蓝桥杯 2022 国 B] 卡牌](https://www.luogu.com.cn/problem/P8800)

我们看到这样一句话：

    请问小明最多能凑出多少套牌?
    
很明显用贪心可以做了。

首先要理解一个东西，**卡牌套数等于最少的卡牌牌数**。因为一套卡牌需要所有卡牌各一张，所以对于最少的卡牌，它如果只有 $x$ 张，则只能有 $x$ 套卡牌含有最少的卡牌。再多的其他卡牌就没用了，所以卡牌套数等于最少的卡牌牌数。

那具体怎么贪心呢？使卡牌套数最多。由于卡牌套数等于最少的卡牌牌数，只需要**尽量让最终各种卡牌数量接近**即可。那就**优先画数量少的卡牌**，直到空卡牌用完。

每次 $O(n)$ 选择最小的卡牌，复杂度会很高。由于这个贪心策略是要连续选择最小的，所以可以通过**排序**来降低复杂度。

最后还有一个问题：可画的卡牌数有限制。还是根据卡牌套数等于最少的卡牌牌数，在空卡牌够用的情况下，最终的卡牌套数取决于初始卡牌数与可画卡牌数的和最少的卡牌。所以可以判断**目前求得的卡牌数是否大于每张卡牌初始卡牌数与可画卡牌数的和的最小值**来解决这个问题。若小于，继续贪心。若大于，则证明空卡牌够用，但受可画的卡牌数的限制，卡牌套数只能为每张卡牌初始卡牌数与可画卡牌数的和的最小值。（好吧这一段有点难理解，可以结合代码里的注释理解）

时间复杂度为 $O(n\log n+n)$ ，可以通过。

最后是~~丑陋的的~~代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,an=0,min1=5000000000,ans=0,a[500000],b;
int main()
{
	scanf("%lld%lld",&n,&m);
    for(int i=0;i<n;i++)scanf("%lld",&a[i]); 
    for(int i=0;i<n;i++)
        {
	    scanf("%lld",&b);
	    if(a[i]+b<min1) //这里是求出初始卡牌数与可画卡牌数的和的最小值
	       min1=a[i]+b;
	    }
    sort(a,a+n); //STL自带的排序
    ans=a[0]; //最开始就有的卡牌套数
    for(int i=0;i<n;i++)
        {
        	if(i==n-1&&an<m) //数组a扫到最后了且空卡牌还有剩余
        	   {
			   ans+=(m-an)/n; //平均分
			   if(ans>min1)ans=min1; //防止超过初始卡牌数与可画卡牌数的和的最小值
        	   break;
			   }
        	if(a[i]!=a[i+1]) //数量不相等，给前i+1张卡牌分空卡牌
        	   {
        	   an+=(i+1)*(a[i+1]-a[i]); //用去的空卡牌
        	   ans+=(a[i+1]-a[i]); //卡牌套数增加
               }
            if(an>m) //用去的空卡牌数超过了空卡牌总数
               {
               	an-=(i+1)*(a[i+1]-a[i]); //撤销增加
               	ans-=(a[i+1]-a[i]); 
               	ans+=((m-an)/(i+1)); //平均分
               	break; //接下来肯定不用再分了，可以退出了
			   }
			if(ans>min1)  //判断是否超过初始卡牌数与可画卡牌数的和的最小值
			   {
			   ans=min1; 
			   break; //可以退出了
		       }
		}
	printf("%lld",ans); //输出结果
    return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/95034455)

---

## 作者：i_love_tym (赞：7)

由于这题是让我们求**最大**，所以要么用贪心做，要么用二分答案做。

显然，在这题中，如果我们无法凑出 $x$ 套牌，那么一定也无法凑出 $x+1$ 套牌。

所以，这题是可以用二分答案的。

由于我们二分的是牌数，所以我们可以写出下面的 $\operatorname{check}$ 函数。

``` cpp
bool check(int x) {
	int sum = 0;
	for (int i = 1; i <= n; i++)
		if (x - a[i] <= b[i])  sum += max(x - a[i], (long long)0);
		else return false;
	if (sum <= m) return true;
	return false;
}
```

由于题目说要每种花色都有，所以如果 $x-a_i\le b_i$ 时我们就可以累加需要手写的牌数了，最后在判断一下 $sum$ 是否 $\le m$ 即可。

接着我们思考一个问题，为什么只有 $x-a_i\le b_i$ 时才累加 $sum$ 呢？

我们先将柿子变形一下，得到 $x\le a_i+b_i$。

由于 $x$ 表示的是要凑出 $x$ 套牌，那么显然只有原有的牌数 $a_i$ ，加上能够手写的牌数 $b_i$ 是小于 $x$ 的时候才能进行累加手写牌的数量的。

# 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long	
const int N = 2e5 + 5;
int n, m;
int a[N], b[N];
bool check(int x) {
	int sum = 0;
	for (int i = 1; i <= n; i++)
		if (x - a[i] <= b[i])  sum += max(x - a[i], (long long)0);
		else return false;
	if (sum <= m) return true;
	return false;
}
signed main() {
	cin >> n >> m;
	int l = 0,r = 1e18;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) cin >> b[i];
	int ans;
	while (l <= r) {
		int mid = (l + r) / 2;
		if (check(mid)) {
			ans = mid;
			l = mid + 1;
		} 
		else r = mid - 1;
	}
	cout << ans;
}
```


如果有不明白的可以私信我。

---

## 作者：Night_sea_64 (赞：2)

这道题可以用二分答案。

显而易见，能凑出的牌的套数等于最少的牌的张数。于是二分这个最小张数就行了。

二分的时候，假设当前二分到的最小张数是 $x$。如果当前这个 $a_i≥x$，也就是不用加牌就能满足要求，就不加牌；如果 $a_i+b_i<x$，说明加满了也没有达到要求，方案不行；否则，加 $(x-a_i)$ 张牌。因为我们只要达到 $x$ 张就可以了，所以根本不用多加牌。顺手就切了。

但是有个问题，为什么 $a_i,b_i≤n$？看样例就不是这样，$n=4$ 但是所有 $b_i=5$。也不知道为啥。

放上我丑陋的代码：

```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
int n,m;
int a[200010],b[200010];
bool chk(int x)
{
    int sum=0;
    for(int i=1;i<=n;i++)
    {
        if(a[i]+b[i]<x)return 0;
        if(a[i]<x)sum+=x-a[i];
    }
    return sum<=m;
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
    int l=0,r=9e18,ans=0;
    while(l<=r)
    {
        int mid=(l+r)/2;
        if(chk(mid))l=mid+1,ans=mid;
        else r=mid-1;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：pxb0801 (赞：1)

### 建议算法标签加上“二分”。

[题目传送门](https://www.luogu.com.cn/problem/P8800)

-------------
## 分析+代码：

就像刚刚说的，这题是一道明显的[二分答案](https://blog.csdn.net/lijingheng66/article/details/125722878)题，时间复杂度 $O(n\operatorname{log}n)$。

当然，我们还是需要知道二分的 $l$ 和 $r$ 的范围是多少。很明显，最少可能一套牌都凑不出来；最多则是所有的牌加上可以用的手写牌，即 $a_i+b_i$。

代码：

```cpp
ll search(){
	ll l=0,r=n*2,mid;//l和r的范围已说
	while(l<=r){
		mid=(l+r)/2;
		if(check(mid)) l=mid+1;//可以则尝试套数再多一点
		else r=mid-1;
	}
	return l-1;//最后输出大多就两个答案：l和l-1，试一试就好了
}
```

---------------
现在，还有一个重要的 **check** 函数没有写。

我们从 $1$ 到 $n$ 遍历，看一看每一个能不能凑出来，也就是 $a_i+b_i≥mid$，且剩下的 $m$ 还够凑出 $mid-a_i$ 张牌，则将 $m$ 减去，否则直接返回 $0$。

代码：

```cpp
bool check(ll mid){
	ll cnt=m;//换一个变量保存m
	for(int i=1;i<=n;i++){
		if(cnt-(mid-a[i])>=0&&a[i]+b[i]>=mid){//两个条件判断能否将第i种牌凑出mid张
			cnt-=max(mid-a[i],0ll);//可以就减。注意，如果a[i]本身就有mid张，则cnt不动
		}
		else return 0;//不符合条件返回0
	}
	return 1;//所有的都符合条件，返回1
}
```

---------------
最后，注意要开 `long long` 哦！

---

## 作者：Oracynx (赞：0)

## P8800 [蓝桥杯 2022 国 B] 卡牌 题解

### 思路

~~过于明显的一道二分板题~~

首先，本题的数据范围如下。

$$
n \le 2 \times 10 ^ 5 , m \le 4 \times 10 ^ {10} , a_i \le 2 \times 10 ^ {5} , b_i \le 2 \times 10 ^ {5}
$$

可以计算答案的范围为：

$$
ans = \min { ( \sum ^1 _ n a_i + b_i) = 4 \times 10 ^ { 5 } }
$$

同时因为答案需要 $n$ 的时间复杂度来计算是否符合要求，而且所需的空白牌的数量单调不减，故采用二分的方式寻找答案。

------------

### 代码实现

#### Check 函数

这份代码中含金量最高的就是 `Check` 函数，其他的都是模板。

```cpp
bool Check(long long x)
{
    long long need;
    need = 0; // 存放所需的空白牌
    for (long long i = 1; i <= n; i++)
    {
        if (x - p[i] > m[i])
        {
            return false; // 所需的空白牌大于允许绘制的牌
        }
        need += max(x - p[i], 0ll); // 累计所需的空白牌
    }
    if (need <= k)
    {
        return true; // 数量足够
    }
    else
    {
        return false; // 数量不够
    }
}
```

#### 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long inf = 0x3f3f3f3f; // 无穷大
const long long N = 2e5 + 5;
long long n, k;
long long l, r;
long long ans;
long long p[N];
long long m[N];
bool check(long long x)
{
    long long need;
    need = 0; // 存放所需的空白牌
    for (long long i = 1; i <= n; i++)
    {
        if (x - p[i] > m[i])
        {
            return false; // 所需的空白牌大于允许绘制的牌
        }
        need += max(x - p[i], 0ll); // 累计所需的空白牌
    }
    if (need <= k)
    {
        return true; // 数量足够
    }
    else
    {
        return false; // 数量不够
    }
}
int main()
{
    scanf("%lld%lld", &n, &k);
    for (long long i = 1; i <= n; i++)
    {
        scanf("%lld", &p[i]);
    }
    for (long long i = 1; i <= n; i++)
    {
        scanf("%lld", &m[i]);
    }
    l = 1;
    r = inf;
    for (; l <= r;)
    {
        long long mid;
        mid = (l + r) / 2;
        if (check(mid))
        {
            ans = mid;   // 更新答案
            l = mid + 1; // 如果可以满足要求，证明更大的也可能满足要求
        }
        else
        {
            r = mid - 1; // 过大，无法满足要求
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：autumnrain_qhc (赞：0)

# 分析

这道题可以用二分！

从有序性来看，如果不能凑出 $k$ 套牌，一定凑不出 $k + 1$ 套牌。

所以可以用二分。

------------
二分的 $l$ 是 $a_i$ 里最小的，$r$ 是 $a_i + b_i$ 里最大的。

判断函数里如果 $mid$ 可以凑出来，那就把手写的加起来，
如果不可以凑出来，那就直接不符合条件，最后再把 $k$ 和 $m$ 进行比较。

# 上代码
```
#include <bits/stdc++.h>
using namespace std;
int n, a[200005], b[200005], ans;
long long m;
bool check(int mid){
    long long k = 0;
    for(int i = 1; i <= n; i++){
        if(mid - a[i] <= b[i])
             k += max(mid - a[i], 0);
        else return 0;
    }
    if(k > m) return 0;
    return 1;
}
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    } 
    for(int i = 1; i <= n; i++) cin >> b[i];
    int l = 1, r = 1e9;
    while(l <= r){
        int mid = (l + r) / 2;
        if(check(mid)) l = mid + 1, ans = mid;
        else r = mid - 1;
    } 
    cout << r;
    return 0;
}
```



---

## 作者：zhanghao233 (赞：0)

感谢 zhanghao 的启发。

# 题目大意

* 给定 $n$ 种卡牌，$m$ 个空牌，求一共可以凑出多少副牌。

# 思路
明显的暴力，但是没有二分好用。

用二分枚举有多少副牌。

然后判断可不可以凑出这么多副牌。

```cpp
while(l+1<r){
	int mid=(l+r)/2;
	if(check(mid))
		l=mid;
	else
		r=mid;
}
```

满足以下条件的都不符合题意。

* 超出能加入这种牌的数量。

* 空白牌不够。

```cpp
bool check(int x){
	for(int i=1;i<=n;i++){
		if(x-a[i]>b[i])
			return 0;
		sum+=max(0,x-a[i]);
	}
   if(sum>m)
    	return 0;
   else
        return 1;
}
```

------------

教训：暴力可以用二分。

---

## 作者：wuhan1234 (赞：0)

## 1. 编程思路。

采用二分法进行求解。

用结构体数组 $card$ 来保存输入的 $n$ 张卡牌，每个数组元素有两个成员分量 $a$ 和 $b$。

将输入的 $n$ 张卡牌按已有张数 $a$ 从小到大排列，则可以凑出的最小的套数为 $card[0].a$，可以凑出的最大套数不会超过 $card[n-1].a+m/n$。以这两个值作为初始的左右边界值进行二分，判断其中值 $mid$ 套牌是否可以凑出。

在判断是否能凑出 $mid$ 套牌时，从小到大枚举 $card$ 数组的各元素，如果当前的现有的牌数 $a$ 大于或等于 $mid$，则肯定可以凑出 $mid$ 套牌（因为后面的每种牌的现有张数都大于 $mid$），直接返回真值；

如果当前的现有牌数加上最多可手写的牌数之和小于 $mid$，则当前这种牌没法凑到 $mid$ 张，肯定也凑不出 $mid$ 套牌，直接返回假值；

如果可以通过空白牌写成当前牌数字将当前牌凑到 $mid$ 张，则空白牌数减去当前用掉的空白牌数。若空白牌够用，继续进行下一种牌的检查；若空白牌都不够，则肯定凑不出 $mid$ 套牌，也直接返回假值。

## 2. 源程序。
```c
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
int n;
long long m;
struct Node
{
    long long a, b;
};
struct Node card[200005];
int cmp(struct Node a, struct Node b)
{
    return a.a < b.a;
}
int  judge(int x)
{
    long long r = m;   // 空白牌的剩余张数
    for (int i = 0; i < n; i++)
    {
        if (card[i].a >= x)  // 最少的牌也有x 张，肯定可以凑出x副牌
            return 1;
        if (card[i].a + card[i].b < x)  // 第i种牌的张数与空白可写成的牌数不足x,肯定凑不出x副牌
            return 0;
        r -= (x - card[i].a);  // 用掉相应的空白牌
        if (r < 0)             // 空白牌都不够用了
            return 0;
    }
    return 1;
}
int main()
{
    scanf("%d%lld",&n,&m);
    int i;
    for (i = 0; i < n; i++)
        scanf("%lld",&card[i].a);
    for (i = 0; i < n; i++)
        scanf("%lld",&card[i].b);
    sort(card,card+n, cmp);
    long long left = card[0].a, right = card[n-1].a + m/n;
    while (left < right)
    {
        long long  mid = (left + right + 1) / 2;
        if (judge(mid))
            left = mid;
        else
            right = mid - 1;
    }
    printf("%lld\n",left);
    return 0;
}

```


---

## 作者：liupei (赞：0)

## 题意
$a$ 数组是已有的 $i$ 类手牌的数量，每个类（$1-n$ 类）的出 $1$ 张可以组成一套，还有 $m$ 张空白的，可以随便写成任意 $i$ 类。$b$ 数组是该类最多被空白牌写成几张，求组成的最多套牌。

修改：这题比赛的时候被改成 $a$, $b < n \times 2$ 了，不是原来的 $n \times n$ 了。
## 思路
二分

容易知道是把空白牌用到少的类上，这题思路就是直接二分答案了。

如果当前类牌不够 $mid$ 张，当然是将空白的编变成该类牌，一是看是否超过了 $b$ 数组的限制，二是看是否超过了最大空白牌数量。

直到最后也是没有被返回 NO，那么返回 YES。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define M 1000005
LL n,m;
LL a[M],b[M];
int check(int mid){
    LL sum=0;
    for(int i=1;i<=n;i++){
        if(a[i]<mid){
            if(mid-a[i]>b[i]) return 0;
            sum+=mid-a[i];
            if(sum>m) return 0;
        }
    }
    return 1;
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
    LL l=0,r=n*2,ans=0;
    while(l<=r){
        LL mid=(l+r)/2;
        if(check(mid)){
            l=mid+1;
            ans=mid;
        }else{
            r=mid-1;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---


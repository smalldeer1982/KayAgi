# [蓝桥杯 2022 国 B] 出差

## 题目描述

$\mathrm{A}$ 国有 $N$ 个城市，编号为 $1 \ldots N$ 小明是编号为 $1$ 的城市中一家公司的员工，今天突然接到了上级通知需要去编号为 $N$ 的城市出差。

由于疫情原因，很多直达的交通方式暂时关闭，小明无法乘坐飞机直接从城市 $1$ 到达城市 $N$，需要通过其他城市进行陆路交通中转。小明通过交通信息网，查询到了 $M$ 条城市之间仍然还开通的路线信息以及每一条路线需要花费的时间。

同样由于疫情原因，小明到达一个城市后需要隔离观察一段时间才能离开该城市前往其他城市。通过网络，小明也查询到了各个城市的隔离信息。（由于小明之前在城市 $1$，因此可以直接离开城市 $1$，不需要隔离）

由于上级要求，小明希望能够尽快赶到城市 $\mathrm{N}$, 因此他求助于你，希望你能帮他规划一条路线，能够在最短时间内到达城市 $N$ 。


## 说明/提示

**【样例说明】**

![](https://cdn.mathpix.com/cropped/2022_09_29_8ee8d95d6d0319bca20dg-09.jpg?height=464&width=478&top_left_y=1249&top_left_x=309)

**【评测用例规模与约定】**

对于 $100 \%$ 的数据, $1 \leq N \leq 1000,1 \leq M \leq 10000,1 \leq C_{i} \leq 200,1 \leq u, v \leq$ $N, 1 \leq c \leq 1000$ 


蓝桥杯 2022 国赛 B 组 E 题。

## 样例 #1

### 输入

```
4 4
5 7 3 4
1 2 4
1 3 5
2 4 3
3 4 5```

### 输出

```
13```

# 题解

## 作者：Strelizia_Qy (赞：10)

## **Dijkstra 堆优化 + vector 存图**

看到各位 dalao 都用链式前向星，奈何我不会，所以写一篇用 vector 存的。

### **思路：**

注意到是单源最短路，且没有负边权，选择 Dijkstra。

隔离的时间可以丢进路线的时间里，具体操作如下：

每条路的边权=原来的边权+目的地的点权。

这样就转化成了一个 Dijkstra 板子题。

（**温馨提示**：因为目的地不需要隔离，所以输出时减去城市 N 的隔离时间）

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
const int maxn=1e5+5,inf=0x3f3f3f3f;
int n,m,add[maxn],dis[maxn];
bool vis[maxn]={0};
vector<pii> G[maxn];
void dijkstra()//Dijkstra 
{
	for(int i=1;i<=n;i++) dis[i]=inf,vis[i]=0;
	dis[1]=0;
	priority_queue<pii,vector<pii>,greater<pii> >p;//堆优化 
	p.push({0,1});
	while(!p.empty())
	{
		int u=p.top().second;
		p.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=0;i<G[u].size();i++)
		{
			int cost=G[u][i].second,v=G[u][i].first;
			if(dis[v]>dis[u]+cost)
			{
				dis[v]=dis[u]+cost;
				p.push({dis[v],v});
			}
		} 
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>add[i];
	for(int i=1;i<=m;i++)
	{
		int a,b,len;
		cin>>a>>b>>len;
		G[a].push_back({b,len+add[b]});
		G[b].push_back({a,len+add[a]});
		//vector存图，加上目的地点权 
	}
	dijkstra();
	cout<<dis[n]-add[n];//终点不用隔离 
}
```


---

## 作者：Zvelig1205 (赞：4)

很简单最短路问题。

数据范围不大，可以使用 SPFA，但是没有负边权还是推荐写 dijkstra。

[假如你不会 dijkstra。](https://www.cnblogs.com/Zvelig1205/p/15875043.html)

在求最短路的时候，除了对应边的边权，还需要将指向点的点权加上，然后一起塞到优先队列里。

时间复杂度 $O(m\log m)$。

代码：

```cpp
const int inf=1e4+7;
int n,m,a[inf];
int fir[inf],nex[inf<<1],poi[inf<<1],val[inf<<1],cnt;
void ins(int x,int y,int z)
{
	nex[++cnt]=fir[x];
	poi[cnt]=y;
	val[cnt]=z;
	fir[x]=cnt;
}
struct dijk{
	int pos,val;
	bool operator <(const dijk &b)const
	{
		return val>b.val;
	}
};
priority_queue<dijk>h;
int dis[inf];
bool vis[inf];
int main()
{
	n=re();m=re();
	for(int i=1;i<=n;i++)
		a[i]=re();
	for(int i=1;i<=m;i++)
	{
		int u=re(),v=re(),w=re();
		ins(u,v,w),ins(v,u,w);
	}
	memset(dis,127,sizeof(dis));
	dis[1]=a[1]=a[n]=0;
	h.push((dijk){1,0});
	while(h.size())
	{
		int now=h.top().pos;h.pop();
		if(vis[now])continue;
		vis[now]=1;
		for(int i=fir[now];i;i=nex[i])
		{
			int p=poi[i];
			if(dis[p]>dis[now]+val[i]+a[p])
			{
				dis[p]=dis[now]+val[i]+a[p];
				h.push((dijk){p,dis[p]});
			}
		}
	}
	wr(dis[n],'\n');
	return 0;
}
```

---

## 作者：Cutler (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8802)

一道基础的带点权单源最短路。

下面默认各位会最短路，不会的戳这里 [Link](https://blog.csdn.net/wmy0217_/article/details/105438163)

因为没有负边权，所以直接用 dij 解决，把模板里加边权的地方再加上一个点权，最后输出的时候把点 $n$ 的点权减去，因为城市 $n$ 不需要隔离。

代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;
const int Maxn = 20010;

struct node{
	int val, to, nxt;
}e[Maxn];
int cnt, c[Maxn], dis[Maxn], head[Maxn], n, m;
bool vis[Maxn];

void add(int u,int v,int w){
	e[++ cnt].nxt = head[u];
	e[cnt].to = v,e[cnt].val = w;
	head[u] = cnt;
}
void dij(){
	priority_queue <pair<int,int> > q;
	memset(dis, 127, sizeof(dis));
	dis[1] = 0;q.push(make_pair(0, 1));
	while(!q.empty()){
		int u = q.top().second;q.pop();
		if(vis[u]) continue;
		vis[u] = 1;
		for(int i = head[u]; i ;i = e[i].nxt){
			int v = e[i].to,w = e[i].val;
			if(dis[v] > dis[u] + w + c[v]){
				dis[v] = dis[u] + w + c[v];
				q.push(make_pair(-dis[v], v));
			}
		}
	}
}

int main(){
	scanf("%d%d", & n, & m);
	
	for(int i = 1;i <= n;++ i) scanf("%d", c + i);
	
	int u, v, w;
	while(m --){
		scanf("%d%d%d", & u,& v,& w);
		add(u, v, w),add(v, u, w);
	}
	
	dij();
	
	printf("%d\n", dis[n] - c[n]);
	return 0;
}
```

优雅结束。

---

## 作者：gesong1234 (赞：1)

传送门：[P8802 [蓝桥杯 2022 国 B] 出差](https://www.luogu.com.cn/problem/P8802) 。
# 题目大意
有 $N$ 个点 $M$ 条边，除了第 $N$ 个点以外，每到达一个点，都要隔离那个点的隔离时间，求 $1$ 点，到 $N$ 点的最短路。
# 思路
显然，这道题是求最短路，就是要考虑，隔离的情况，其实，我们只要把到达这个点的每一条边，都加上隔离的时间，就可以了，最后输出时要注意，减去 $C_N$，终点不用隔离。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
vector<pair<int,int> >f[12345];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
int b[1234567],d[1234567],n,m,s,e[1234567];
void dijkstra(){//最短路算法
	memset(d,0x7f,sizeof(d));
	d[s]=0;
	q.push({0,s});
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if (b[u]) continue;
		b[u]=1;
		for (int i=0;i<f[u].size();i++){
			int v=f[u][i].first,w=f[u][i].second;
			if (d[u]+w<d[v]){
				d[v]=d[u]+w;
				q.push({d[v],v});
			}
		}
	}
}
main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++) cin>>e[i];
	s=1;
	for (int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		f[u].push_back({v,w+e[v]});
		f[v].push_back({u,w+e[u]});//加上隔离时间
	}
	dijkstra();
	cout <<d[n]-e[n];//终点不用隔离
    return 0;
}
```

---

## 作者：Ja50nY0un9 (赞：0)

带点权单源最短路径模板题。

我们运用 dijkstra。

考虑到每个点都有点权，我们在 dijkstra 中对每个点进行松弛操作的时候，都要在判断时加上被松弛点的点权。

在代码中，我们将每个点的点权表示为 $a_i$。

然后注意几个坑，看看你踩过没有：

- 道路是双向的。
- 在点 1 时不需要隔离，所以 $dis_1=0$。
- 在点 $n$ 时也不需要隔离，所以答案为 $dis_n\color{red}-a_n$。

附代码。

```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <vector>
# include <queue>
# include <ctime>
# include <cmath>

using namespace std;

const int NR = 1e3 + 10;

struct Edge{
	int to, w;
};

struct Node{
	int x, dis;
	bool operator <(const Node &B) const{
		return B.dis < dis;
	}
};

vector <Edge> g[NR];
int dis[NR];
bool flag[NR];
int n, m;
int a[NR];
priority_queue <Node> q;

void dijkstra(){
	memset(flag, false, sizeof(flag));
	memset(dis, 999999, sizeof(dis));
	dis[1] = 0;
	q.push((Node){1, 0});
	while (!q.empty()){
		int x = q.top().x;
		q.pop();
		if (flag[x]) continue;
		flag[x] = true;
		for (int j = 0; j < g[x].size(); j++){
			int y = g[x][j].to, w = g[x][j].w;
			if (dis[y] <= dis[x] + w + a[y]) continue;
			dis[y] = dis[x] + w + a[y];
			q.push((Node){y, dis[y]});
		}
	}
}

int main(){
    memset(a, -1, sizeof(a));
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++){
		int x, y, w;
		cin >> x >> y >> w;
		g[x].push_back((Edge){y, w});
		g[y].push_back((Edge){x, w});
	}
	dijkstra();
	cout << dis[n] - a[n];
	return 0;
}
```

SPFA 也是可做的，跑得比 dij 还要快一点，显然是因为出题人没想卡。

需要注意的点与 dij 相同。

附代码。

```cpp
# include <iostream>
# include <cstdio>
# include <vector>
# include <string>
# include <queue>
# include <cmath>
# include <ctime>
using namespace std;

int dis[1001];
vector <int> g[1001];
vector <int> l[1001];
queue <int> q;
bool flag[1001];
int a[1001];
int n, m, s;

void spfa(){
	while(!q.empty()){
		int x = q.front();
		flag[x] = false;
		q.pop();
        cin.tie(0);
		for(int i = 0; i < g[x].size(); i++){
			int y = g[x][i], w = l[x][i];
			w += a[y];
			if (dis[x] + w >= dis[y]) continue;
			dis[y] = dis[x] + w;
			if (!flag[y]){
				q.push(y);
				flag[y] = true;
			}
		}
	}
}

int main(){
	cin >> n >> m;
	s = 1;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int x, y, w;
	for (int i = 1; i <= m; i++){
        ios::sync_with_stdio(0);
		scanf("%d%d%d", &x, &y, &w);
		g[x].push_back(y);
		l[x].push_back(w);
		g[y].push_back(x);
		l[y].push_back(w);
	}
	for (int i = 1; i <= n; i++){
		dis[i] = 1e9;
	}
	dis[s] = 0;
	flag[s] = true;
	q.push(s);
	spfa();
	cout << dis[n] - a[n];
	return 0;
}
```

请不要试图抄袭我的代码，谢谢。我能看出来的。

---

## 作者：__Cartesian__Tree__ (赞：0)

最短路问题。

建议使用稳定的 dijkstra 算法，因为此处没有负边权。

将每一个点的点权加载指向它的边。

注意：
1. 到达 $n$ 点是无需隔离，减去 $c[n]$。
2. 双向边，链式前向星开两倍空间。

代码：
```cpp
#include <bits/stdc++.h>
#define maxn 1010
#define maxm 10010
using namespace std;
long long n, m, s, ecnt;
long long dis[maxn], head[maxn], c[maxn];
bool flag[maxn];
struct Edge{
	int v, nxt, w;
}e[maxm*2];//两倍空间
void add(int u, int v, int w){
	e[ecnt].v = v;
	e[ecnt].w = w;
	e[ecnt].nxt = head[u];
	head[u] = ecnt++;
}
struct Node{
	int u, dis;
	bool operator < (const Node &x)const{
		return dis > x.dis;
	}
};
void Dijkstra(int s){//模板
	dis[s]=0;
	priority_queue<Node> q;
	q.push((Node){s, 0});
	while (!q.empty()){
		Node now = q.top();q.pop();
		int u = now.u;
		if (flag[u]) continue;
		flag[u] = 1;
		for (int now = head[u]; now+1; now = e[now].nxt){
			int v = e[now].v;
			int w = e[now].w;
			if (dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				if (!flag[v])
				    q.push((Node){v, dis[v]});
			}
		}
	}
}
int main(){
	cin >> n >> m;
	memset(head, -1, sizeof(head));
    memset(dis, 0x3f, sizeof(dis));
    for (int i = 1; i <= n; i++){
        cin>>c[i];
    }
	for (int i = 1; i <= m; i++){
		int u, v, w;
		cin >> u >> v >> w;
		add(u, v, w+c[v]);
		add(v, u, w+c[u]);//双向边，点权附加
	}
	Dijkstra(1);
	cout<<dis[n]-c[n];//注意减去隔离时间
	return 0;
} 

```

---


# [蓝桥杯 2022 国 B] 故障

## 题目描述

在软件或系统开发中，我们会遇到各种各样的故障。为了从故障现象反推故障原因，工程师们会总结一种叫做相关性矩阵的二维表格，来表示故障原因与故障现象之间的关系。比如:

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/P8804.png)

其中每行表示一种故障原因，每一列表示一种故障现象。该矩阵表示故障原因 $A$ 可能产生故障现象 $2$、$3$、$4$，故障原因 $B$ 可能产生故障现象 $1$、$3$。

在实际开发过程中，如果出现了故障原因，工程师就可以根据故障现象，去计算每种故障原因产生的概率，并按照概率大小对故障原因进行排查，以达到快速定位故障原因的目的。

现在，我们假设系统开发中同一时间只会出现一种故障原因, 并且故障原 因引起各故障现象是独立事件。举个例子来说:

假设系统现在发生了故障原因 $A$, 有 $\frac{1}{3}$ 的概率出现故障现象 $2$，有 $\frac{1}{4}$ 的概率出现故障现象 $3$，有 $\frac{1}{2}$ 的概率出现故障现象 $4$。由于 $3$ 种现象是独立发生的，因此有 $\frac{1}{2 \times 3 \times 4}$ 的概率同时出现故障 $2$、$3$、$4$。

约定若相关性矩阵中没有 `x` 记号, 则表示该故障原因一定不会产生某故障现象，比如故障原因 $A$，一定不会产生故障现象 $1$。根据历史经验数据，我们统计得到了每一种故障原因出现的概率以及每一种故障原因对应的故障现象产生概率。

现在已知系统出现的故障现象，求问各个故障原因发生的概率。

## 说明/提示

对于所有测试用例，$1 \leq N \leq 40,1 \leq M \leq 20,0 \leq P_{i} \leq 100, \sum\left(P_{i}\right)=100$, $0 \leq P_{i j} \leq 100$。

蓝桥杯 2022 国赛 B 组 G 题。

## 样例 #1

### 输入

```
3 5
30 20 50
0 50 33 25 0
30 0 35 0 0
0 0 0 25 60
1
3```

### 输出

```
2 56.89
1 43.11
3 0.00```

# 题解

## 作者：FS_qwq (赞：18)

## 前置知识：

这一题要用到贝叶斯公式，接下来我们看一下贝叶斯公式：就是 $P(B|A)=\frac{P(A|B)×P(B)}{P(A)}$ ，这里 $A$ 事件发生的概率为 $P(A)$，$B$ 事件发生的概率为 $P(B)$， $A$ 事件发生时 $B$ 事件发生的概率为 $P(B|A)$。

## 题目大意

其实题目那么长，其实就是要判断每种故障的出现概率，最后 sort 快排一下输出即可。

## 题目解答

这题在计算的时候要用到贝叶斯公式。

首先，定义 a 数组,$a[i]$ 表示故障原因 $i$ 产生的概率 $P_{i}$ ;还有 b 数组（是一个二维数组），$b[i][j]$ 表示故障原因 $i$ 出现故障现象 $j$ 的概率，因为这两个数组都是用百分比输入的，所以先转成小数。

然后，定义一个浮点类型的数 sum 表示当前故障原因发生并且产生出现的现象的概率，和一个数组 dp 计算第 $i$ 故障发生并且导致出现当前现象的概率，最后的 $sum$ 就是把数组 dp 的所有数累加起来。

接着，一个 for 循环，就是如果这个现象发生了，就标记为 $1$。

接下来一个 for 循环，就是用叶贝斯公式计算 $dp[i]$。

最后把故障的编号和发生故障的概率统计一下，输出即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500;
double a[maxn],b[maxn][maxn],dp[maxn];
int N,M,K,c[maxn];
struct bro{
	int id;double p;
}d[maxn];
bool cmp(bro x,bro y){
	if(fabs(x.p-y.p)<1e-6)return x.id<y.id;//防止精度丢失 
	return x.p>y.p; 
}
int main(){
	cin>>N>>M;
	int i,j,k;
	double sum=0;//当前故障原因发生并且产生出现的现象的概率 
	for(i=1;i<=N;i++){
		cin>>a[i];
		a[i]*=0.01;//百分比还原成小数 
	} 
	for(i=1;i<=N;i++)
		for(j=1;j<=M;j++){
			cin>>b[i][j];
			b[i][j]=b[i][j]*0.01;//百分比还原成小数 
		} 
	cin>>K;
	for(i=1;i<=K;i++){
		cin>>k;
		c[k]=1;//这个现象发生了 
	}
	for(i=1;i<=N;i++){//i故障发生并且导致出现当前现象的概率 
		dp[i]=a[i];
		for(j=1;j<=M;j++){
			if(c[j])dp[i]=dp[i]*b[i][j];
			else dp[i]=dp[i]*(1-b[i][j]);
		} 
	} 
	for(i=1;i<=N;i++)sum+=dp[i];//发生当前现象的总概率 
	for(i=1;i<=N;i++){
		d[i].id=i;//记录故障编号 
		d[i].p=dp[i]*100.0/sum;//计算故障概率 
	}
	sort(d+1,d+N+1,cmp);
	for(i=1;i<=N;i++)printf("%d %.2lf\n",d[i].id,d[i].p); 
	return 0;
}
```


---

## 作者：行吟啸九州 (赞：8)

这个题需要用到概率学中的贝叶斯公式，即 $P(A \mid B) = P(B \mid A) \times P(A) \div P(B)$，$P(A \mid B)$ 含义为发生事件 $B$ 的条件下事件 $A$ 发生的概率。

题意有点难以理解，实际上就是求题中给定的那些故障现象出现的条件下，每种故障原因的出现概率，然后排序输出即可。

故根据贝叶斯公式，对于每个故障原因，不妨设事件 $A$ 为这个故障原因出现，事件 $B$ 为那些故障现象出现，所求为 $P(A \mid B)$。$P(A)$，$P(B)$，$P(B \mid A)$都很易知，根据贝叶斯公式求 $P(A \mid B)$ 即可。复杂度$ O(NM)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 105
#define int long long
#define For(i, j, n) for(int i = j ; i <= n ; ++i)
int k, n, m, t, vis[N];
long double sum, P[N], p[N][N];
struct node{
	int x;
	long double w; 
}a[N];
inline bool cmp(node x, node y){
	if(x.w == y.w) return x.x < y.x;
	return x.w > y.w;
}

signed main(){
	scanf("%lld %lld", &n, &m);
	For(i, 1, n) scanf("%Lf", &P[i]);
	For(i, 1, n) For(j, 1, m) scanf("%Lf", &p[i][j]);
	scanf("%lld", &k);
	For(i, 1, k) scanf("%lld", &t), vis[t] = 1;
	For(i, 1, n){
		a[i].x = i, a[i].w = P[i];
		For(j, 1, m){
			if(vis[j]) a[i].w *= p[i][j];
			else a[i].w *= (100 - p[i][j]);
		}
		sum += a[i].w;
	}
	sort(a + 1, a + n + 1, cmp);
	For(i, 1, n) printf("%lld %.2Lf\n", a[i].x, a[i].w / sum * 100);
	return 0;
}


---

## 作者：yanzixuan2024 (赞：1)

有几个要点。

输入处理: 读取故障原因数量、现象数量、先验概率、相关性矩阵和出现的现象。

似然度计算: 对每个故障原因，检查是否能产生所有出现的现象，计算其产生这些现象且不产生未出现现象的概率。

后验概率计算: 使用贝叶斯定理计算每个故障原因的后验概率，并进行归一化处理。

排序和输出: 按后验概率从高到低排序，若概率相同则按编号从小到大排序，输出结果并保留两位小数。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int id;
    double prob;
    bool operator>(const node& other) const {
        return (prob > other.prob) || (prob == other.prob && id < other.id);
    }
};
int main() {
    int n, m;
    cin >> n >> m;
    vector<int> priors(n);
    for (int i = 0; i < n; i++) {
        cin >> priors[i];
    }
    vector<vector<int>> prob_matrix(n, vector<int>(m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> prob_matrix[i][j];
        }
    }
    int k;
    cin >> k;
    set<int> s_set;
    for (int i = 0; i < k; i++) {
        int s;
        cin >> s;
        s_set.insert(s);
    }
    vector<double> numerators(n, 0.0);
    for (int i = 0; i < n; i++) {
        bool valid = true;
        double likelihood = 1.0;
        for (int s : s_set) {
            int col = s - 1;
            int p = prob_matrix[i][col];
            if (p == 0) {
                valid = false;
                break;
            }
            likelihood *= p / 100.0;
        }
        if (!valid) {
            numerators[i] = 0.0;
            continue;
        }
        for (int j = 0; j < m; j++) {
            int pheno = j + 1;
            if (s_set.find(pheno) == s_set.end()) {
                int p = prob_matrix[i][j];
                likelihood *= (100 - p) / 100.0;
            }
        }
        double prior = priors[i] / 100.0;
        numerators[i] = prior * likelihood;
    }
    double denominator = 0.0;
    for (double num : numerators) {
        denominator += num;
    }
    vector<node> ress(n);
    for (int i = 0; i < n; i++) {
        double prob_val = 0.0;
        if (denominator != 0) {
            prob_val = (numerators[i] / denominator) * 100.0;
        }
        ress[i] = {i + 1, prob_val};
    }
    sort(ress.begin(), ress.end(), greater<node>());
    cout << fixed << setprecision(2);
    for (const auto& item : ress) {
        cout << item.id << " " << item.prob << endl;
    }
    return 0;
}
```

---


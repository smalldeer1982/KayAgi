# [蓝桥杯 2022 国 C] 近似 GCD

## 题目描述

 小蓝有一个长度为 $n$ 的数组 $A = (a_1,a_2,\cdots,a_n)$，数组的子数组被定义为从原数组中选出连续的一个或多个元素组成的数组。数组的最大公约数指的是数组中所有元素的最大公约数。如果最多更改数组中的一个元素之后，数组的最大公约数为 $g$，那么称 $g$ 为这个数组的近似 GCD。一个数组的近似 GCD 可能有多种取值。

具体的，判断 $g$ 是否为一个子数组的近似 GCD 如下：

1. 如果这个子数组的最大公约数就是 $g$，那么说明 $g$ 是其近似 GCD。
2. 在修改这个子数组中的一个元素之后（可以改成想要的任何值），子数组的最大公约数为 $g$，那么说明 $g$ 是这个子数组的近似 GCD。

小蓝想知道，数组 $A$ 有多少个长度大于等于 $2$ 的子数组满足近似 GCD 的值为 $g$。

## 说明/提示

**【样例说明】**

满足条件的子数组有 $5$ 个 ：

$[1,3]$：将 $1$ 修改为 $3$ 后，这个子数组的最大公约数为 $3$，满足条件。
   
$[1,3,6]$：将 $1$ 修改为 $3$ 后，这个子数组的最大公约数为 $3$，满足条件。

$[3,6]$：这个子数组的最大公约数就是 $3$，满足条件。

$[3,6,4]$：将 $4$ 修改为 $3$ 后，这个子数组的最大公约数为 $3$，满足条件。

$[6,4]$：将 $4$ 修改为 $3$ 后，这个子数组的最大公约数为 $3$，满足条件。

【评测用例规模与约定】

对于 $20\%$ 的评测用例，$2\le n\le100$；
  
对于 $40\%$ 的评测用例，$2\le n\le1000$；

对于所有评测用例，$2\le n\le10^5$，$1\le g,a_i \le10^9$。

蓝桥杯 2022 国赛 C 组 F 题。

## 样例 #1

### 输入

```
5 3
1 3 6 4 10```

### 输出

```
5```

# 题解

## 作者：翟翟 (赞：12)

## 解法一
枚举区间左端点和右端点，扫描区间，看不是 $g$ 的倍数的数是否小于等于 $1$ 个，若是，则 $ans+1$。

代码略。

时间复杂度：$\mathcal O(n^3)$，期望得分 $20$ ~ $40 pts$。


## 解法二
在解法一的基础上，进行优化。

我们把不是 $g$ 的倍数的数标记成 $1$ ，把是 $g$ 的倍数的数标记成 $0$。则问题被转化为求区间和小于等于 $1$ 的区间个数。我们便可在边扫描边处理，当区间和大于 $1$ 时，就退出当前循环。（这种思想最终可以演化为解法四）。

代码略。

或者使用前缀和。（这种思想最终可以演化为解法三）。
```cpp
#include<cstdio>
int n,g,a[100001],x;
long long ans;
int main(){
	scanf("%d%d",&n,&g);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		if(x%g)a[i]=1;
		a[i]+=a[i-1];
	}
	for(int i=1,j;i<n;++i){
		for(j=i+1;j<=n;++j)
			if(a[j]-a[i-1]>1)
				break;
		ans+=j-i-1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

时间复杂度：$\mathcal O(n^2)$，期望得分 $40$ ~ $70 pts$。


## 解法三
计 $a_i$ 为数组前 $i$ 个数的前缀和。

在解法二前缀和的基础上进行二分。
找到第一个大于 $a_i+1$ 的 $a_j$ 的位置。
```cpp
#include<cstdio>
int n,g,a[100001],x;
long long ans;
int upper(int l,int r,int x){
	int mid;
	for(;l<=r;){
		mid=(l+r)>>1;
		if(a[mid]<=x)l=mid+1;
		else r=mid-1;
	}
	return l;
}
int main(){
	scanf("%d%d",&n,&g);
	for(int i=1;i<=n;++i){
		scanf("%d",&x);
		if(x%g)a[i]=1;
		a[i]+=a[i-1];
	}
	for(int i=1;i<n;++i)
		ans+=upper(i+1,n,a[i-1]+1)-i-1;
	printf("%lld\n",ans);
	return 0;
}
```
时间复杂度：$\mathcal O(n log n)$，期望得分 $100 pts$。


## 解法四
在解法二枚举的基础上用双指针乱搞一波，但也要前缀和。

时间复杂度：$\mathcal O(n)$，期望得分 $100 pts$。

代码略。

---

## 作者：0x282e202e2029 (赞：6)

- [P8809](/problem/P8809)

TAG：枚举，双指针

## 题面

我们要求的是数组 $A$ 有多少个长度大于等于 $2$ 的子数组满足近似 GCD 的值为 $g$。

如何判断一个数组满足近似 GCD 的值为 $g$ 呢？把题面的意思换个说法就是，**只要数组中有少于等于一个的数与 $g$ 的 $\gcd$ 不为 $g$ 即可**。

## 思路

$\gcd$ 满足结合律，即，$\gcd(a, \gcd(b, c)) = \gcd(a, b, c)$。

这意味着，只要一个序列的近似 GCD 的值为 $g$，其所有子序列的近似 GCD 的值也都为 $g$。

所以，我们只需要**用双指针枚举累计以当前元素结尾的满足题意序列的个数**就可以了！！！

为了方便，我们用变量 $lst$ 维护当前最后一个不满足 $\gcd(A_i, g) = g$ 的 $i$，遇到新的则替换，因为最多只能有 $1$ 个不符合要求的。

接着，如果出现第二个 $i$ 使得 $\gcd(A_i, g) ≠ g$，则更新，将区间左端点设为 $lst$，再将 $lst$ 设为 $i$。

~~懒得写 $\gcd$ 实现，用 `<algorithm>` 库函数 `__gcd()` 即可。~~

## AC 代码

```cpp
#include <cstdio>
#include <algorithm> // __gcd()
using namespace std;
int N, g, A;
int lst;
long long ans; // 十年 OI 一场空，_______
int main()
{
	scanf("%d%d", &N, &g);
	ans = -N; // 预先减去长度为 1 的子数组，下面加上所有符合的个数
	for (int r = 1, l = 0; r <= N; ++r) // 枚举右端点
	{
		scanf("%d", &A);
		if (__gcd(g, A) != g) // 如果新的一个 A 不满足要求
		{
			l = lst, lst = r; // 更新区间及 lst
		}
		ans += (r - l); // 加上子区间个数（右端点固定，因此等于区间长度）
	}
	printf("%lld", ans); // 开了 long long 要写 %lld
	return 0;
}
```

- [AC 记录](/record/117610043)

---

## 作者：行吟啸九州 (赞：6)

以下只考虑数组大小大于等于 $2$ 的数组。

可以发现一个数组的近似 GCD 是 $g$ 的充分必要条件是这个数组里最多只有一个元素不是 $g$ 的倍数。

这个结论的证明如下。如果数组里的所有元素都是 $g$ 的倍数，那么将任意一个元素改成 $g$，则这个数组所有元素的最大公约数显然是 $g$。如果数组里有一个元素不是 $g$ 的倍数，将这个元素改成 $g$，则这个数组所有元素的最大公约数显然是 $g$。

那么这个问题就变成了如何求原数组有多少个子数组满足这个数组里最多只有一个元素不是 $g$ 的倍数，这个问题 $O(n^2)$ 的解法是平凡的，但是无法通过全部数据。

对于每个子数组的左端点，考虑有多少个右端点满足形成的子数组只有一个元素不是 $g$ 的倍数。对于每个元素 $i$，相当于找到 $i$ 右边第二个（算上 $i$ 自己）不是 $g$ 的倍数的元素 $f[i]$，然后 $i + 1$ 和 $f[i] - 1$ 之间的所有元素都能成为合法的右端点，换而言之，$i$ 作为左端点对答案的贡献是$f[i]- i - 1$，如果$i$的右边没有两个不是 $g$ 的倍数的元素，则 $f[i] = n + 1$。复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
#define int long long
#define Fol(i, j, n) for(int i = j ; i >= n ; --i)
#define For(i, j, n) for(int i = j ; i <= n ; ++i)
int n, g, t, ans, a[N], f[N];

signed main(){
	scanf("%lld %lld", &n, &g);
	For(i, 1, n) scanf("%lld", &a[i]);
	t = n + 1, f[n + 1] = n + 1;
	Fol(i, n, 1){
		f[i] = t;
		if(a[i] % g != 0) t = i;	
	}
	For(i, 1, n) if(a[i] % g == 0) f[i] = f[f[i]];
	For(i, 1, n) ans += (f[i] - i - 1);
	printf("%lld", ans);
	return 0;
}

---

## 作者：Cattle_Horse (赞：4)

## P8809 [蓝桥杯 2022 国 C] 近似 GCD

[题目链接](https://www.luogu.com.cn/problem/P8809)

近似 $gcd$ 表示一个子数组，可以选择修改一个数，之后若 $gcd=g$，则为近似 $gcd$ 

区间内 $gcd=g$，代表这个区间一定都是 $g$ 的倍数

题目转化为：

数组有几个子数组，满足 不是 $g$ 的倍数的数的个数小于等于 $1$

由于数组是连续的一个区间，可以采用前缀和的方式，求区间和是否小于等于 $1$（这个和 指的是 不是 $g$ 的倍数的数的个数）

循环遍历左端点，确定右端点有两种方式：

1. [二分查找](https://www.cnblogs.com/Cattle-Horse/p/16938033.html)
2. 双指针

> 这类求连续区间个数的问题通常都是
>
> 遍历左端点 再通过 二分或双指针 确定右端点

**二分查找**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), g = sc.nextInt();
        int[] a = new int[n + 1];
        for (int i = 1, x; i <= n; ++i) {
            x = sc.nextInt();
            a[i] = x % g == 0 ? 0 : 1;
        }
        for (int i = 1; i <= n; ++i) {
            a[i] = a[i] + a[i - 1];
        }
        long ans = 0;
        // 枚举左端点
        for (int i = 1; i < n; ++i) {
            // 二分确定右端点
            // 从 i + 1 开始，因为题目要求子数组长度大于等于2
            // 最大不超过 n
            int l = i + 1, r = n, mid;
            while (l < r) {
                mid = (l + r + 1) / 2;
                if (a[mid] - a[i - 1] > 1) {
                    r = mid - 1;
                } else {
                    l = mid;
                }
            }
            // 如果都没有满足的就跳过
            if (a[l] - a[i - 1] > 1) continue;
            ans += l - (i + 1) + 1;
        }
        System.out.println(ans);
    }
}
```

**双指针**

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), g = sc.nextInt();
        int[] a = new int[n + 1];
        for (int i = 1, x; i <= n; ++i) {
            x = sc.nextInt();
            a[i] = x % g == 0 ? 0 : 1;
        }
        for (int i = 1; i <= n; ++i) {
            a[i] = a[i] + a[i - 1];
        }
        long ans = 0;
        // 枚举左端点
        for (int i = 1, r = 2; i < n; ++i) {
            // 找到第一个不满足区间和小于等于1的
            while (r <= n && a[r] - a[i - 1] <= 1) ++r;
            ans += r - (i + 1);
        }
        System.out.println(ans);
    }
}
```



---

## 作者：DEMAC (赞：3)

## 1. 分析

对于一个子数组 $a$：

显然的，任何一个 $a_i$ 都是 $\gcd$ 的倍数。

1. 当 $a$ 中的每一项都是 $g$ 的倍数，我们只需要将 $a$ 中某元素改为 $g$，即可满足要求。

1. 当 $a$ 中存在至多一个不是 $g$ 的倍数的项，我们只需要将它改为 $g$，即可满足要求。

1. 当 $a$ 中存在至少两个不是 $g$ 的倍数的项，由于我们不能同时改动他们，所以无法满足要求。

将 $a$ 重新赋值为模 $g$ 的余数。如果余数非零，赋值为一

所以可以转换为，有多少个子段和小于等于 $1$？

可以划分然后组合计数，也可以无脑双指针，可过此题。

## 2.代码

> ~~要代码没有，要思路一条~~

为了激发学员思维积极度，提升学员动手能力，培养自信自强的社会主义接班人，本题解不提供代码，为文明洛谷建设做出力所能及的贡献。

Happy Coding! :D

---

## 作者：StarRain3 (赞：0)

看到大佬们都用了二分找答案，这里介绍一种双指针算法。

#### 分析
我们建立一个指针 $i$，它表示以 $i$ 结尾的子数组。

修改一次后左端移动，最远延伸到了指针 $j$，那么以 $i$ 结尾的子数组左端取任意的 $j$ 到 $i-1$ 都是满足条件的子数组，然后我们把 $i-j$ 累加至答案中即可。

#### 代码
挑战一波最短代码。
```
#include<bits/stdc++.h>
 
#define int long long//数据有点大，开long long

using namespace std;
 
const int N = 1e5 + 10;
 
int n, g;

int a[N];
 
int rgt;
int res;

signed main()
{
    cin >> n >> g;
 
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
 
    for (int i = 1, j = 1; i <= n; i ++ )
    {
        int t = __gcd(g, a[i]);//取最大公因数现成函数
        if (t != g) {
        	j = rgt + 1;
           rgt = i;
        |
        
        int k = i - j + 1;
        
        if (k >= 2) {
        	res += i - j;
        }
    }
 
    cout << res << endl;
 
    return 0;
}
```


---


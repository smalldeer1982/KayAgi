# [蓝桥杯 2023 国 B] 合并数列

## 题目描述

小明发现有很多方案可以把一个很大的正整数拆成若干正整数的和。他采取了其中两种方案，分别将他们列为两个数组 $\{a_1, a_2, \cdots a_n\}$ 和 $\{b_1, b_2, \cdots b_m\}$。两个数组的和相同。

定义一次合并操作可以将某数组内相邻的两个数合并为一个新数，新数的值是原来两个数的和。小明想通过若干次合并操作将两个数组变成一模一样，即 $n = m$ 且对于任意下标 $i$ 满足 $a_i = b_i$。请计算至少需要多少次合并操作可以完成小明的目标。

## 说明/提示

### 样例说明

只需要将 $a_2$ 和 $a_3$ 合并，数组 $a$ 变为 $\{1,5,4\}$，即和 $b$ 相同。

### 评测用例规模与约定

 - 对于 $20\%$ 的数据，保证 $n,m \le 10^3$。
 - 对于 $100\%$ 的数据，保证 $n, m \le 10^5$，$0 < a_i, b_i \le 10^5$。
 
第十四届蓝桥杯大赛软件赛决赛 C/C++ 大学 B 组 D 题

## 样例 #1

### 输入

```
4 3
1 2 3 4
1 5 4```

### 输出

```
1```

# 题解

## 作者：wmrqwq (赞：9)

# 原题链接
[P9422 [蓝桥杯 2023 国 B] 合并数列](https://www.luogu.com.cn/problem/P9422)

# 题目简述

有两个和都相同的数组，现在要通过最少的合并操作使得两个数组变成一模一样。

# 解题思路

我们可以把两个数列看做两个队列。定义 $a1$，$a2$ 两个队列用于存储两个数组，再遍历一遍这两个队列，遍历的时候一共有 $3$ 种情况：

1. $a1$ 的第一项小于 $a2$ 的第一项，这时就需要将 $a1$ 队列中的第 $1$ 项和第 $2$ 项合并，弹出 $a2$ 队列中的第一个元素，以及将合并次数增加 $1$ 。 

2. $a1$ 的第一项大于 $a2$ 的第一项，这时就需要将 $a2$ 队列中的第 $1$ 项和第 $2$ 项合并，弹出 $a2$ 队列中的第一个元素，以及将合并次数增加 $1$ 。

3. $a1$ 的第一项等于 $a2$ 的第一项，这时就需要弹出 $a1$ 队列中的第一个元素以及弹出 $a2$ 队列中的第一个元素。

最后再输出需要合并的次数即可。

# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a,sum;//sum 用于记录答案 
deque<int>a1,a2;
int main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)
		cin>>a,a1.push_back(a);//输入 n 次 a，并在 a1 队列中加入 a 元素
	for(int i=0;i<m;i++)
		cin>>a,a2.push_back(a);//输入 m 次 a，并在 a2 队列中加入 a 元素
	while(!a1.empty())//如果 a1 队列还有剩余元素，那么就继续运行程序
	{
		if(a1.front()==a2.front())//如果相等就直接出队 
		{
			a1.pop_front();//弹出 a1 队列中的第一个元素
			a2.pop_front();//弹出 a2 队列中的第一个元素
		}
		else if(a1.front()>a2.front())//如果a2小就合并a2的前两个数
		{
			a2[1]+=a2[0];//将 a2 队列中的第 1 项和第 2 项合并
			a2.pop_front();//弹出 a2 队列中的第一个元素
			sum++;//将合并次数增加 1 
		}
		else//如果 a1 小就合并 a1 前两个数
		{ 
			a1[1]+=a1[0];//将 a1 队列中的第 1 项和第 2 项合并
			a1.pop_front();//弹出 a2 队列中的第一个元素
			sum++;//将合并次数增加 1 
		} 
	}
	cout<<sum<<endl; //输出需要合并的次数
}

```


---

## 作者：MoonCake2011 (赞：5)

我们可以用两个队列匹配。

如果两个队列的队首相同，那么就可以判定为匹配成功。

如果 `q1.front()<q2.front()` 那么说明 `q1` 的匹配之路需要加把劲，于是将 `q1` 的前两个合并。

`q2` 同理。

可以用两个双端队列模拟。

因为 `deque` 时间复杂度与空间复杂度都有点高，所以我选择用更优的 `list` 代替 `deque`。

代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
list<int>q1,q2;
int main() {
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		q1.push_back(x); 
	}
	for(int i=1;i<=m;i++){
		int x;
		cin>>x;
		q2.push_back(x);
	}
	int cnt=0;
	while(!q1.empty() && !q2.empty()){
		if(q1.front()==q2.front())
			q1.pop_front(),q2.pop_front();
		else if(q1.front()<q2.front()){
			int u=q1.front();q1.pop_front();
			int v=q1.front();q1.pop_front();
			q1.push_front(u+v);
			cnt++;
		}
		else{
			int u=q2.front();q2.pop_front();
			int v=q2.front();q2.pop_front();
			q2.push_front(u+v);
			cnt++;
		}
	}
	cout<<cnt;
	return 0;
} 
```

---

## 作者：封禁用户 (赞：4)

# 题目解法

将两个数列看成两个队列 $a,b$，用 $cnt$ 来记录合并的次数，会遇到以下几种情况：

- $x$ 的队首等于 $y$ 的队首，那么同时取出 $x,y$ 的队首。

- $x$ 的队首大于 $y$ 的队首，让队首小的加上队第二个数，同时让 $cnt$ 加上 1。

- 如果以上两条都不属于的话，就让 $x_{1}+x_{0}$，再取出 $x$ 的队首，同时让 $cnt$ 加上 1。

所以代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,a,cnt;
deque<int>x,y;
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++)cin>>a,x.push_back(a);
	for(int i=0;i<m;i++)cin>>a,y.push_back(a);
	while(!x.empty()){
		if(x.front()==y.front()) x.pop_front(),y.pop_front();
		else if(x.front()>y.front()) y[1]+=y[0],y.pop_front(),cnt+=1;
		else x[1]+=x[0],x.pop_front(),cnt+=1;
	}
	cout<<cnt;
	return 0;
}
```


---

## 作者：_O_v_O_ (赞：2)

可以将两个数列看成两个队列，定义一个变量 $ans$ 来记录至少要合并几次，则将会遇到以下几种情况：

1. 两队队首相等：则同时取出两队队首。
2. 两队队首不相等，则让队首比较小的加上那队第二个数，同时让 $ans$ 加 $1$。

因为进行加操作时，要从队首放元素，所以要用双端队列。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,a;
list<int> q1,q2;  //用 list 代替 deque。
int ans;

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a;
		q1.push_back(a);
	}
	for(int i=1;i<=m;i++){
		cin>>a;
		q2.push_back(a);
	}
	while(!q1.empty()&&!q2.empty()){
		if(q1.front()==q2.front()){  //第一种情况。
			q1.pop_front();
			q2.pop_front();
		}
		else if(q1.front()>q2.front()){  //第二种情况，因为有两个队列，所以有两个判断。
			int x=q2.front();
			q2.pop_front();
			int y=q2.front();
			q2.pop_front();
			q2.push_front(x+y);
			ans++;
		}
		else{
			int x=q1.front();
			q1.pop_front();
			int y=q1.front();
			q1.pop_front();
			q1.push_front(x+y);
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Wangjunhao2011 (赞：1)

这题是一道考验双端队列  `deque` 的基础题。

我们先将队首相同的元素弹出，说明他俩匹配成功。

如果 `d1.front()<d2.front()` 就说明 `d1` 的第一个元素与第二个元素应该合并。

反之，也说明 `d2` 的第一个元素与第二个元素应该合并。

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	deque<int> d1,d2;
	int cnt=0;
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++){
		int a;cin>>a;
		d1.push_front(a);
	}
	for(int i=1;i<=m;i++){
		int a;cin>>a;
		d2.push_front(a);
	}
	while(!d1.empty() || !d2.empty()){
		if(d1.front()==d2.front()){
			d1.pop_front();
			d2.pop_front();
			continue;
		}
		if(d1.front()<d2.front()){
			int a=d1.front();
			d1.pop_front();
			int b=d1.front();
			d1.pop_front();
			int sum=a+b;
			d1.push_front(sum);
			cnt++;
			continue;
		}
		else{
			int a=d2.front();
			d2.pop_front();
			int b=d2.front();
			d2.pop_front();
			int sum=a+b;
			d2.push_front(sum);
			cnt++;
			continue;
		}
	}
	cout<<cnt;
	return 0;
} 
```

---

## 作者：Vct14 (赞：1)

我们把两个数列看成两个队列。

由于最后要让序列中的所有数都相同，所以队首也必须相同。而队首只能和第二个数合并，所以只用比较队首，把小的那个队首和第二个数合并，直到两个队首相等即可把两个队首出队。当两个队列非空时，再比较下一个队首。由于两个数列和相等，所以最后两个队列一定会同时变空。

对于合并操作，我们只需要让第二个数加上队首，然后把第一个数出队即可。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long

#define push(q) q.push_back(in)
#define pop(q) q.pop_front()
#define plus(q) q[1]+=q[0]

deque<int> a;
deque<int> b;

signed main(){
	int n,m;
	cin>>n>>m;
	int in;
	for(int i=1; i<=n; i++){
		cin>>in;
		push(a);
	}
	for(int i=1; i<=m; i++){
		cin>>in;
		push(b);
	}
	int ans=0;
	while(!a.empty()){
		if(a.front()==b.front()){
			pop(a);
			pop(b);
			continue;
		}
		if(a.front()<b.front()){
			plus(a);
			pop(a);
		}
		else{
			plus(b);
			pop(b);
		}
		ans++;
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：YangXiaopei (赞：1)

## Solution:
我的思路和其他 dalao 差不多，都是一直判断第一项的情况，这儿就不多说了,有需要请看上面 dalao 的题解，但我最进特别反感队列，便写了一篇游标的代码。

情况1：$suma$ 与 $sumb$ 一样
```cpp
if(suma == sumb){
	l++;
	r++;
	suma = a[l];
	sumb = b[r];
}
```
情况2：$suma$ 大于 $sumb$
```cpp
if(suma > sumb){
	r++;
	cr += b[r];
	cnt++;
}
```
情况3：$suma$ 小于 $sumb$
```cpp
if(suma < sumb){
	r++;
	cr += b[r];
	cnt++;
}
```
### 知道了这些写出代码便很容易了

---

## 作者：HDZmessi (赞：0)

一道水题，居然没有测试点？？

这题的解法其实有很多，但看到巨佬们都用了 deque，蒟蒻也发一篇 deque 的题解吧！

这题只需要建立一个 deque 数组，然后一直遍历每个 deque 的队始元素，比较他们的大小再依据大小关系分别判断并解决。

AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
deque<int> p[2];
int main(){
	int n,m;cin>>n>>m;
	for(int i=0;i<n;i++){
		int u;cin>>u;
		p[0].push_back(u);
	}
	for(int i=0;i<m;i++){
		int u;cin>>u;
		p[1].push_back(u);
	}
	int ans=0;
	while(!(p[0].empty()&&p[1].empty())){
		if(p[0].front()==p[1].front()){
			p[0].pop_front();
			p[1].pop_front();
			continue;
		}
		else if(p[0].front()<p[1].front()){
			int u=p[0].front();
			p[0].pop_front();
			p[0].front()+=u;
			ans++;
		}
		else{
			int u=p[1].front();
			p[1].pop_front();
			p[1].front()+=u;
			ans++;
		}
	}
	cout<<ans;
	return 0;
} 
```

语文不好，不注释了。


---

## 作者：YuanHaoYu6315 (赞：0)

Part1:题意：
=
有两个和相同的数组，要求通过最少的合并次数使数组完全一样。

Part2:思路：
=
这题其实是一个队列（queue）。 		   									    
由于最后要求两个数组的所有数相等，所以我们首先应该考虑队首。我们可以通过ans记录合并次数。   
如果两个队列的队首相等就出队。  
那如果不相等呢？  

-  $q1$ 的队首 $>$ $q2$ 的队首  这时候我们应该合并 $q1$ 的前两个。
-  $q1$ 的队首 $<$ $q2$ 的队首  这时候我们应该合并 $q2$ 的前两个。

Part3:上代码：
=
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	int n,m;
	deque<int> q1,q2;
	cin>>n>>m;
   	int ans = 0;
	for(int i=0;i<n;i++){
		int a;
		cin>>a;
		q1.push_back(a);
	}
	for(int i=0;i<m;i++){
		int a;
		cin>>a;
		q2.push_back(a);
	}
	while(!q1.empty()){
		if(q1.front()==q2.front()){//相等直接出队 
			q1.pop_front();
			q2.pop_front(); 
		}else if(q1.front()>q2.front()){
			q2[1]+=q2[0];
			q2.pop_front();
			ans++;//合并次数++
		}else{//q1小就合并q1前面两个 
			q1[1]+=q1[0];
			q1.pop_front();
			ans++;//合并次数++
		} 
	}
	cout<<ans<<endl; 
   return 0;
}


```
感谢您的阅读，我们下次再见~~~

---


# [蓝桥杯 2023 国 B] 抓娃娃

## 题目描述

小明拿了 $n$ 条线段练习抓娃娃。他将所有线段铺在数轴上，第 $i$ 条线段的左端点在 $l_i$，右端点在 $r_i$。小明用 $m$ 个区间去框这些线段，第 $i$ 个区间的范围是 $[L_i, R_i]$。如果一个线段有 **至少一半** 的长度被包含在某个区间内，则将其视为被这个区间框住。请计算出每个区间框住了多少个线段？



## 说明/提示

### 评测用例规模与约定

 - 对于 $20\%$ 的数据，保证 $n, m \le 10^3$。
 - 对于 $100\%$ 的数据，保证 $n, m ≤ 10^5$，$l_i < r_i$，$0 < l_i, r_i, L_i, R_i \le 10^6$，$\max \{r_i − l_i\} \le \min \{R_i − L_i\}$。
 
第十四届蓝桥杯大赛软件赛决赛 C/C++ 大学 B 组 H 题

## 样例 #1

### 输入

```
3 2
1 2
1 3
3 4
1 4
2 4```

### 输出

```
3
2```

# 题解

## 作者：EchoHua0402 (赞：23)

# P9426 [蓝桥杯 2023 国 B] 抓娃娃 题解


## 思路

这道题的整体思路以及需要用到的算法：一点思维+前缀和/差分。

首先题目保证了 $\max \{r_i-l_i\} \leq \min\{R_i-L_i\}$，那么如果某个区间包含了某个线段，则该区间一定包含了这个线段的中点。

这样一来，我们就可以在输入 $l_i,r_i$ 的时候，标记其中点 `(mp[(l+r)/2]++)`，再做一遍前缀和（方便过会儿使用），最后查询时 $[L_i,R_i]$ 这个区间的和就是答案。

**注意：**

~~我就是因为这个被卡了。~~

有可能会出现中点的位置是个小数这种情况，所以我们不妨把所有坐标都 $\times 2$ （不要忘记数组大小也要开两倍），以避免上述情况的发生。

-----
附上完整 `AC` 代码~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int n,m;
int mp[N];
int main()
{
	cin>>n>>m;
	int l,r;
	for (int i=1;i<=n;i++)
	{
		cin>>l>>r;
		mp[l+r]++;//标记中点
	}
	for (int i=1;i<N;i++)
	{
		mp[i]+=mp[i-1];//前缀和预处理
	}
	for (int i=1;i<=m;i++)
	{
		cin>>l>>r;
		l*=2;
		r*=2;
		cout<<mp[r]-mp[l-1]<<endl;
	}
	return 0;
}
```

---

## 作者：Little_x_starTYJ (赞：12)

### 解题思路
我们只需要明白一点，就是如果一条 $l\sim r$ 的线段被框住了，那么 $\frac{l + r}{2}$ 这个点一定被框住了，也就是说这条线段的中点一定被框住了。

那么我们就可以用一个前缀和数组维护答案。将中点所在的下标处加 $1$，再从 $1\sim 10^6$ 进行前缀和计算，对于每次查询我们直接输出即可。

但是这里需要注意的是， $\frac{l + r}{2}$ 不一定是整数，所以在进行标记的时候，需要将 $\frac{l + r}{2}$ 变成整数后处理。我们可以发现 $l + r$ 肯定是整数，所以标记 $l + r$ 就行，那我们在预处理的时候就要从 $1\sim 2\times 10^6$。在查询时我们将 $L, R$ 都乘以 $2$ 即可。

总时间复杂度 $\mathcal{O}(n)$。

CODE：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int sum[2000010];
signed main() {
	ios::sync_with_stdio(false);
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	int n, m, l, r;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> l >> r;
		sum[l + r]++;
	}
	for (int i = 1; i <= 2000000; i++) {
		sum[i] = sum[i - 1] + sum[i];
	}
	while (m--) {
		cin >> l >> r;
		cout << sum[r << 1] - sum[(l << 1) - 1] << "\n";
	}
	return 0;
}
```

---

## 作者：Elaina_ (赞：6)

前缀和的使用模版题。

我们不难知道如果套中了一半，必定会经过中点：

- 设区间长度为 $len$，从最左端到中点的长度为 $len/2$ 从最右端到中带你的长度亦为 $len/2$ 如果不过中点则必定长度会小于 $len/2$ 因此如果套中了区间的长度为一半，必定会过该区间的中点。

但是我们也要考虑一个问题：“如果中点的坐标是小数怎么办”。

我们可以考虑将总长度扩大一倍，所选择区间也扩大一倍，我们就可以使得中点坐标为整数了！

我们将中点标记完后，计算一个前缀和，然后就自然而然的可以求出答案啦！


```cpp
#include<bits/stdc++.h>
using namespace std;
const int F=1000100;

int n,m,len,ble,st,ed,ans;
int a[2*F],block[2*F],out[2*F];

int main(){
    cin>>n>>m;
    for(int x,y,i=1;i<=n;i++){
        cin>>x>>y;
        a[x+y]++;
    }
    for(int i=1;i<=2*F-10;i++) a[i]+=a[i-1];
    for(int x,y,i=1;i<=m;i++){
        cin>>x>>y;
        cout<<a[2*y]-a[2*x-1]<<endl;
    }
    return 0;
}
```


---

## 作者：abc1234shi (赞：2)

### 题意理解
这题就是在求重叠的面积，我们找到中点坐标，再计算前缀和，就能求出答案。
### 具体求法
定义一个数组，刚开始输入 $l$，$r$，将数组的第 $l+r$ 项加加，然后数组的第 $i$ 项加上 $i-1$ 项，将 $l$，$r$ 各乘 $2$ 方便找中点，最后数组的第 $r$ 项和第 $l-1$ 项就行了，别忘了输出换行。

    #include <bits/stdc++.h>
    using namespace std;
    int n,m,l,r;
    int da[2*1000100-10];
    int main()
    {
	     cin>>n>>m;
	     for (int i=1;i<=n;i++)
	    {
		    cin>>l>>r;
		    da[l+r]++;
	     }
	     for (int i=1;i<2*1000100-10;i++)
	     {
		    da[i]+=da[i-1];
	     }
	     for (int j=1;j<=m;j++)
	     {
		   cin>>l>>r;
		   cout<<da[r*2]-da[l*2-1]<<endl;
	     }
	return 0;
     }

---

## 作者：ybc2026lhy (赞：1)

[博客食用效果更佳](https://www.luogu.com.cn/article/yuqugl9k)

##### 分析：

因为对于线段而言，只要至少一半的长度被包含则就会被一个区间框住，也就是说，只要包含其中一个端点和这个线段的中点即可。所以只要某个区间包含了某个线段的中点，则一定包含这个线段至少一半的长度。

对于每一个查询的区间，用前缀和存储该区间包含的线段中点的最小值和最大值，两者之差就是该区间包含的线段数量。

AC Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int sum[200005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int l,r;
		cin>>l>>r;
		sum[l+r]++;
	}
	for(int i=1;i<=200005;i++){
		sum[i]+=sum[i-1];
	}
	while(m--){
		int l,r;
		cin>>l>>r;
		cout<<sum[r*2]-sum[l*2-1]<<"\n";
	}
	return 0;
}

---

## 作者：ganyu1 (赞：1)

# P9426 抓娃娃 题解
## ~~还是没有数据点嘛~~
由题可得，若一个区间覆盖了某条线段的一半及以上，则认为该线段被此区间框住。
![](https://cdn.luogu.com.cn/upload/image_hosting/8fqny6wy.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/upwnttvp.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5361xbnm.png)

如上是区间框住线段的几种情况，很明显若区间框住了某条线段，则区间必定包含该线段的中点。因此只需要存储所有线段的中点，再进行一次前缀和操作，最后根据区间输出即可。
- 最后一个问题，若线段左右区间相加得奇数，即中点为小数点的情况怎么办？这里可以选择将所有点乘上 $2$，这样就不存在有小数点情况了。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
const int N=2000005;
using namespace std;
int x[N],n,m;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1,l,r;i<=n;i++){
		cin>>l>>r;
		x[l+r]++;
		//中点原本是(l+r)/2，但是我们需要乘2，所以就直接存l+r
	}
	for(int i=1;i<=N;i++) x[i]+=x[i-1];//前缀和
	for(int i=1,L,R;i<=m;i++){
		cin>>L>>R;
		cout<<x[R*2]-x[L*2-1]<<endl;
		//右端点前中点个数减去左端点前中点个数即为答案，记得乘2
	}
	return 0;
}
```

---

## 作者：_SkyLine_ (赞：1)

## 思路分析
不难发现只要线段 $[l_i,r_i]$ 的中点 $\frac{l_i+r_i}{2}$ 被包含在区间 $[L_j,R_j]$ 内，区间 $[L_j,R_j]$ 就可以框住该线段。一个很直接的想法就是：

1. 在数轴上标记每个线段的中点 $\frac{l_i+r_i}{2}$。
2. 求出每个区间 $[L_j,R_j]$ 的区间和作为区间 $[L_j,R_j]$ 框住的线段个数。

## 具体实现
步骤 $1$ 就不说了。。。

对于步骤 $2$，我们可以对数轴建立**线段树/树状数组/前缀和**等结构来帮助我们快速求出区间 $[L_j,R_j]$ 的区间和作为答案。但存在一种 $2 \nmid l_i+r_i$ 的情况使得 $\frac{l_i+r_i}{2}$ 带着小数部分，不方便作为以上三种数据结构的下标。为了解决这个问题，我们可以存储 $\frac{l_i+r_i}{2} \times 2$ 即 $l_i+r_i$ 以消去小数部分，在求区间和的时候对应地乘一下 $2$，求出 $[L_j \times 2,R_j \times 2]$ 的区间和即可得到正确的结果。观察得知 $0 < l_i,r_i,L_i,R_i \le 10^6$，则最极端情况的区间右端点不会超过 $2 \times 10^6$。上述三种数据结构都不会出现内存超限的情况，可以解决本题。

## $Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+1;
int n,m;
struct node
{
	int L,R;
	int sum;
}tr[N<<2];
inline void Pushup(int p)
{
	tr[p].sum=tr[p<<1].sum+tr[(p<<1)|1].sum;
	return;
}
void Build(int p,int bl,int br)
{
	tr[p].L=bl;
	tr[p].R=br;
	if(bl==br)
		return;
	int mid=(bl+br)>>1;
	Build(p<<1,bl,mid);
	Build((p<<1)|1,mid+1,br);
	Pushup(p);
	return;
}
void Update(int p,int i)
{
	if(tr[p].L==tr[p].R)
	{
		tr[p].sum++;
		return;
	}
	int mid=(tr[p].L+tr[p].R)>>1;
	if(i<=mid)
	{
		Update(p<<1,i);
		Pushup(p);
	}
	else
	{
		Update((p<<1)|1,i);
		Pushup(p);
	}
}
int Query(int p,int ql,int qr)
{
	if(ql<=tr[p].L&&tr[p].R<=qr)
		return tr[p].sum;
	int mid=(tr[p].L+tr[p].R)>>1;
	if(qr<=mid)
		return Query(p<<1,ql,qr);
	else if(ql>mid)
		return Query((p<<1)|1,ql,qr);
	return Query(p<<1,ql,qr)+Query((p<<1)|1,ql,qr);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    Build(1,1,N-1);
    for(int i=1;i<=n;i++)
    {
    	int a,b;
    	cin >> a >> b;
    	Update(1,a+b);
	}
    for(int i=1;i<=m;i++)
    {
    	int l,r;
    	cin >> l >> r;
    	cout<<Query(1,l<<1,r<<1)<<endl;
	}
    return 0;
}
```

---

## 作者：_xdd_ (赞：0)

注意到 $\max{r_i-l_i}\le\min{R_i-L_i}$，因此我们每读入一个线段就把它的中点记录下来，如果这个区间包含了他的中点则答案加一，查询操作可以前缀和优化。

可能出现 $\displaystyle \frac{l+r}{2}$ 是小数的情况，可以把每个数都 $\times 2$，数组大小也要 $\times 2$。

---


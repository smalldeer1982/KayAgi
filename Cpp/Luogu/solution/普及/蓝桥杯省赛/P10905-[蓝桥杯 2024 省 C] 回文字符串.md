# [蓝桥杯 2024 省 C] 回文字符串

## 题目描述

小蓝最近迷上了回文字符串，他有一个只包含小写字母的字符串 $S$，小蓝可以往字符串 $S$ 的开头处加入任意数目个指定字符：`l`、`q`、`b`（ASCII 码分别为：$108$、$113$、$98$）。小蓝想要知道他是否能通过这种方式把字符串 $S$ 转化为一个回文字符串。

## 说明/提示

**【样例说明】**

对于 `gmgqlq`，可以在前面加上 `qlq` => `qlqgmgqlq` 转化为一个回文字符串；

对于 `pdlbll`，无法转化为一个回文字符串；

对于 `aaa`，本身就是一个回文字符串。

**【评测用例规模与约定】**

对于 $50\%$ 的评测用例，$1 \le |S| \le 1000$，其中 $|S_j|$ 表示字符串 $S$ 的长度；  
对于所有评测用例，$1 \le T \le 10$，$1 \le \sum |S| \le 10^6$。

## 样例 #1

### 输入

```
3
gmgqlq
pdlbll
aaa```

### 输出

```
Yes
No
Yes```

# 题解

## 作者：DarkShadow (赞：12)

# P10905（模拟）

## 题目大意：

给出一个字符串，求是否可以在左边任意加 `l`、`q`、`b` 三个字符，使得字符串变成回文字符串。

## 思路分析：

首先我们发现有三种情况是可以变成回文的：

1. 整个字符串本来就是回文的。
2. 整个字符串都由 `l`、`q`、`b` 三个字符组成。
3. 左边有一部分字符串是回文的，右边的字符串都由 `l`、`q`、`b` 三个字符组成。

于是我们有了一个想法：把右边连续的由 `l`、`q`、`b` 组成的字符串删掉，然后判断左边是否回文。

然而这个想法是错误的（我就在这卡了很久），因为有些字符串如果把右边的 `l`、`q`、`b` 都删掉的话左边就没法形成回文字符串了（比如 `qwq`）。

然后我们可以想到把左、右侧连续的 `l`、`q`、`b` 都取出来，那么中间剩下的这一段必须是回文的，然后我们再判断一下左边的字符串是否可以和右边字符串的前面一部分形成回文串就可以了（因为右边字符串的后面部分可以通过再整个字符串前面添加一些字符得到）。

**注意：如果整个字符串都由 `l`、`q`、`b` 组成，左右指针可能会分别跑到右端点、左端点，一定要判断一下。**

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n;
char s[1000005];
int main(){
	int p1,p2;
	bool flag;
	scanf("%d",&T);
	while(T--){
		scanf("%s",s+1);
		n=strlen(s+1),p1=0,p2=n+1,flag=1;
		while(p2>1&&(s[p2-1]=='l'||s[p2-1]=='q'||s[p2-1]=='b'))  p2--;//计算右指针
		while(p1<p2-1&&(s[p1+1]=='l'||s[p1+1]=='q'||s[p1+1]=='b'))  p1++;//计算左指针
		for(int i=p1+1,j=p2-1;i<j;i++,j--)//判断中间字符串是否回文
			if(s[i]!=s[j]){
				flag=0;
				break;
			}
		if(p2+p1-1>n)  flag=0;//防止MLE
		else
			for(int i=1;i<=p1;i++)//判断左右字符串是否合法
				if(s[p1-i+1]!=s[p2+i-1]){
					flag=0;
					break;
				}
		printf("%s\n",flag?"Yes":"No");
	}
	return 0;
}
```

---

## 作者：hyl_____ (赞：9)

## Part 0 前言
这是一道思考难度比较大的题，我前后改了七次才过，特此纪念。
## Part 1 思路
先读题，题意大致为给定一个字符串，能在字符串的前面添加数个 `l`，`q`，`b` 三个字符，问能不能构成回文字符串。

我们可以将原字符串（长度为 $len$）分为三段：

第一段，只包含题目中给出的三个特殊字符且在原字符串的最前方的字串，设长度为 $len1$。

第二段，只包含题目中给出的三个特殊字符且在原字符串的最后方的字串，设长度为 $len2$。

第三段，第二段和第一段之间的子串，设长度为 $len3$。

例如字符串 `lqbkkklqbkkklqb`，第一段为 `lqb`，长度为 $3$；第二段为 `kkklqbkkk`，长度为 $9$；第三段为 `lqb`，长度为 $3$。

分情况讨论，若 $len1 \leq len2$，那么从 $0$ 开始，遍历到 $len-len2+len1-1$，判断这个区间内是否回文，若回文，则答案为 `Yes`，否则答案为 `No`。

若 $len1 > len2$，那么可以[证得](https://www.luogu.com.cn/paste/94f53ea0)，永远不可能回文，答案为 `No`。

## Part 2 AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int len;
int get_len_front(){
	int sum=0;
	for(int i=0;i<len;i++){
		if(s[i]=='l'||s[i]=='q'||s[i]=='b') sum++;
		else break;
	}
	return sum;
}//获取len1
int get_len_back(){
	int sum=0;
	for(int i=len-1;i>=0;i--){
		if(s[i]=='l'||s[i]=='q'||s[i]=='b') sum++;
		else break;
	}
	return sum;
}//获取len2
int main(){
	int t;
	cin>>t;
	while(t--){
		cin>>s;
		len=s.length();
		int len1=get_len_front();
		int len2=get_len_back();
		if(len1==len2&&len1==len){
			cout<<"Yes\n";
			continue;
		}//若整个字符串都为特殊字符，那么将原串倒序拼在前面即可，所以答案为Yes
		int bj=1;
		if(len1<=len2){
			for(int i=0;i<len-len2+len1-1;i++){
				if(s[i]!=s[len-len2+len1-1-i]){
					cout<<"No\n";bj=0;break;
				}//判断是否回文
			}
			if(bj) cout<<"Yes\n";
		}
		else
		{
			cout<<"No\n";
		}
	}
} 
```

---

## 作者：canwen (赞：5)

PS：交了 $5$ 发才过，且参照了不少来自讨论区的 hack，特写题解纪念。

~~（虽说好像是抱着水题解的心来的）~~。
## 题意
在字符串 $x$ 前可以加入若干个字符 `l`，`q` 或 `b`，问其可否若干个操作后形成一个回文字符串。
## 分析
笔者用 $len$ 表示 $x$ 的长度，$x$ 的下标从 $0$ 开始。

首先明确**只能添加上述的三个字符**，所以对于不是其中的字符的字符所形成的字符串，若不是回文的，就无解。

用 $l,r$ 分别表示这段需要被判断的区间的左右端点，可以这么求。

```cpp
int l=0,r=x.size()-1;
while(x[l]=='l'||x[l]=='q'||x[l]=='b') l++;
while(x[r]=='l'||x[r]=='q'||x[r]=='b') r--;
```

如果是回文串，就逐位匹配前后的字符 `l`，`q` 或 `b` 形成的字符串，判断 $x$ 可不可以经过添加字符使其成为回文串。


```cpp
l--,r++;//之前处理区间端点留下的贡献
while(x[l]==x[r]&&l>=0&&r<=x.size()) l--,r++;
if(r==x.size()||l==-1) cout<<"Yes\n";
else cout<<"No\n";
```

记得还有特殊的情况要特判。

当 $l=0$，那肯定是有解的，毕竟你可以在前面插入后面的字符串中的对应的字符。

当 $r=len-1$ 且 $l>0$ 时，必然没有解，因为末尾都没有 `l`，`q` 或 `b`，前面多余的 `l`，`q` 或者 `b` 也匹配不上。

当前面的字符比后面的字符数量多时，也没有解，同上。
## CODE

```cpp
#include<bits/stdc++.h>
using namespace std;

int t;
string x;

int main(){
	cin>>t;
	while(t--){
		cin>>x;
		string s=x;
		//求区间的两个端点
		int l=0,r=x.size()-1;
		while(x[l]=='l'||x[l]=='q'||x[l]=='b') l++;
		while(x[r]=='l'||x[r]=='q'||x[r]=='b') r--;
		//判断回文串
		int pd=1;
		for(int i=l,j=0;i<=(l+r)/2;i++,j++){
			if(x[i]!=x[r-j]){
				pd=0;break;
			}
		}
		if(!pd) cout<<"No\n";/*不是回文串*/
		else{
			if(l==0) cout<<"Yes\n";
			else if(r==x.size()-1) cout<<"No\n";
			else if(x.size()-r<l) cout<<"No\n";
			else {
				l--,r++;//之前处理区间端点留下的贡献 
				while(x[l]==x[r]&&l>=0&&r<=x.size()) l--,r++;
				if(r==x.size()||l==-1) cout<<"Yes\n";
				else cout<<"No\n";
			}
		}
	}
	return 0;
} 
```

---

## 作者：Soviet_Onion (赞：4)

## P10905 [蓝桥杯 2024 省 C] 回文字符串 题解
### Solution
由于我们可以在开头添加任意的 `l`、`q`、`b` 三个字母，所以对应地，我们就可以去除末尾含有这三个字母的部分。然后判断剩下的是否是回文就可以了。

不过这样的解法会被卡掉：

```
1
lqbioibqllqb
```

对于这组数据，显然，我们可以通过仅仅去除后三个字母，剩下 `lqbioibql` ，就是回文串。但是由于上述思路会自动去除末尾所有符合条件的字母，所以我们还要找到**第一个**不是 `b`、`q`、`l` 的下标，然后和**最后一个**不是 `b`、`q`、`l` 的下标相加，就可以得到上述子串啦。

#### 一些小优化
不难发现，当一个字符串回文**或**全部由指定的三个字母组成，它必然符合条件。~~虽然这么优化作用不大。~~

本解法时间复杂度为 $\mathcal{O(n)}$，可以通过本题。
### [AC](https://www.luogu.com.cn/record/174726216) Code
```cpp
#include<iostream>
#include<cstring>
#include<map>
using namespace std;
bool hw(string s){
	int l=0,r=s.size()-1;
	while(l<r){
		if(s[l]!=s[r]) return 0;
		l++,r--;
	}
	return 1;
}
map<char,int>lib;
int main(){
	int T;
	cin>>T;
	for(;T;T--){
		string s;
		cin>>s;
		int del_pos=s.size()-1,f=0;
		for(auto i:s) lib[i]++;
		if(hw(s)||lib['l']+lib['b']+lib['q']==s.size()){
			puts("Yes");
			continue;
		}
		int fir=-1,last=-1;
		for(int i=0;i<s.size();i++){
			if(s[i]!='l'&&s[i]!='q'&&s[i]!='b'){
				if(fir<0) fir=last=i;
				else last=i;
			}
		}
		last+=fir;
		string ns=s.substr(0,last+1);
		if(hw(ns)) puts("Yes");
		else puts("No");
	}
    return 0;
}
```

###### ~~求过。~~

---

## 作者：gavinliu266 (赞：3)

# 思路
由于只可以在开头插入特定字符，所以合法的串必定由一段回文与一个全部是 `l`，`q` 和 `b` 的字符串相接而成。

于是就有两种做法。

## 做法一
可以考虑先用 Manacher 算法求出每个点为中心的回文长度，然后预处理所有后缀是否全为限定字符。

然后按照枚举每个字符，判断当前的回文是否到达开头，以及回文后的后缀是否可以通过添加字符得到。

单次时间复杂度：$\Theta(|S|)$。

## 做法二
我们可以把两边连续的限定字符求出，于是字符串分成三段。

因为第三段已经全部为限定字符，所以只需要满足前面的部分是回文即可。

考虑到第二段中不全为限定字符，所以只能第一段与第三段匹配，然后第二段为回文，而它们的判定可以在线性时间复杂度内完成。

单次时间复杂度：$O(|S|)$。

# 代码实现
## 做法一
[提交记录](https://www.luogu.com.cn/record/174715848)，速度慢，空间占用多。
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 1e6 + 5;
int T, n;
char s[N], c[N * 2];
bool suf[N];
int pa[N];
bool check(char c) { return c == 'l' || c == 'q' || c == 'b'; }
int main() {
    scanf("%d", &T);
    while(T--) {
        memset(pa, 0, sizeof(pa));
        memset(suf, 0, sizeof(suf));
        scanf("%s", s + 1);
        n = strlen(s + 1);
        suf[n + 1] = true;
        for(int i = n; i >= 1; --i) {
            suf[i] = suf[i + 1];
            if(suf[i])
                suf[i] &= check(s[i]);
        }  // 预处理后缀
        int l = 0, r = 0;
        c[0] = '@';
        for(int i = 1; i <= n; ++i) {
            c[(i << 1) - 1] = s[i];
            c[i << 1] = '#';
        }
        for(int i = 1; i <= (n << 1); ++i) {
            if(i < r) pa[i] = min(pa[(l << 1) - i], r - i);
            while(c[i + pa[i]] == c[i - pa[i]])
                ++pa[i];
            if(i + pa[i] > r)
                l = i, r = i + pa[i];
        } // Manacher
        bool fl = false;
        for(int i = 1; i <= (n << 1); ++i)
            if(i - pa[i] == 0 && suf[(i + pa[i] + 3) / 2]) {  // 注意下标的转换
                fl = true;
                break;
            }
        if(fl) printf("Yes\n");
        else printf("No\n");
    }
}
```

## 做法二
[提交记录](https://www.luogu.com.cn/record/174513086)，速度快，空间占用少。
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 1e6 + 5;
char s[N], t[N];
int T, n;
int main() {
    scanf("%d", &T);
    while(T--) {
        scanf("%s", s + 1);
        n = strlen(s + 1);
        int l = 1, r = n;
        while(s[r] == 'q' || s[r] == 'l' || s[r] == 'b')
            --r;
        while((s[l] == 'q' || s[l] == 'l' || s[l] == 'b') && l <= r)
            ++l;
        for(int i = l; i <= r; ++i)
            t[i - l + 1] = s[i];
        int len = r - l + 1;
        --l, ++r;
        while(l >= 1 && r <= n) {  // 一三段保证匹配
            if(s[l] != s[r]) {
                printf("No\n");
                break;
            }
            --l, ++r;
        }
        if(l != 0 && r != n + 1)
            continue;
        if(r == n + 1 && l != 0) {
            printf("No\n");
            continue;
        }
        l = 1, r = len;
        while(l < r) {  // 第二段保证为回文
            if(t[l] != t[r]) {
                printf("No\n");
                break;
            }
            ++l, --r;
        }
        if(l >= r) printf("Yes\n");
    }
}
```

---

## 作者：xyx404 (赞：1)

## 思路：
因为可以添加 `l`、`q`、`b` 这三个字符，所以我们可以先把左、右端的这三个字符先拿出来，然后判断一下中间是否回文，如果不回文输出 `No`，如果回文再判断一下左，右端拿出来的字符串。  

因为只能在开头处加字符，所以当从右端取出来的字符串的字符数量比左端取出来的字符串的字符数量少时，输出 `No`，当从右端取出来的字符串的字符数量比左端取出来的字符串的字符数量多时，分别从两个字符串的结尾对比字符，如果字符不一样则输出 `No`，因为只能加，不能删。 

如果以上都过了，那么就输出 `Yes`。
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std; 
#define LL long long
#define itn int
#define ull unsigned long long
string s;
int T;
int main(){
	cin>>T;
	while(T--){
		cin>>s;
		int flag1=0,flag2=0;
		int len=s.size();s=" "+s;
		string c="";
		for(int i=1;i<=len;i++){// 从开头开始 
			if(!flag1){
				if(s[i]=='l'||s[i]=='q'||s[i]=='b')c+=s[i];// 取出字符串 
				else{
					flag1=i;break;// 标记从哪里开始不同的 
				}
			}
		}
		string d="";
		for(int i=len;i>=1;i--){// 从结尾开始 
			if(!flag2){
				if(s[i]=='l'||s[i]=='q'||s[i]=='b')d+=s[i];
				else{
					flag2=i;break;
				}
			}
		}
		bool bj=0;
		for(int i=d.size()-1,j=c.size()-1;i>=0&&j>=0;i--,j--){
			if(d[i]!=c[j]){
				bj=1;break;
			}
		}
		if(bj||d.size()<c.size()){ 
			cout<<"No\n";continue;
		}
		c="",d="";
		for(int i=flag1,j=flag2;i<=j;i++,j--){// 判断中间的字符串是否回文 
			c+=s[i];d+=s[j];
		}
		if(c==d)cout<<"Yes\n";
		else cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：Suite_No1_G (赞：0)

设字符串长度为 $n$。

由于只能在字符串前面添加字符，这样字符只能匹配字符串最后面的一部分。所以设 $suf_i$ 表示从 $i$ 到 $n$ 是否全部为可添加的字符，是为 $1$，不是则为 $0$。

此时，假设从 $1$ 到 $i$ 是回文串，且 $suf_{i+1}=1$，那么在字符串前添加与 $i+1$ 到 $n$ 匹配的字符串，则最终字符串回文。

注意特判特殊情况：如果 $suf_1$ 等于 $1$ 时可以匹配出回文串。

所以题目转化成了如何判断一个字符串是回文串，用哈希解决即可。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int unsigned long long

const int maxn=1e6+10;
char s[maxn];
int h1[maxn],h2[maxn];
int base[maxn];
bool suf[maxn];
const int B=1e9+7;

int query1(int l,int r){
	return h1[r]-h1[l-1]*base[r-l+1];
}

int query2(int l,int r){
	return h2[l]-h2[r+1]*base[r-l+1];
} 

void solve(){
	scanf("%s",s+1);
	int n=strlen(s+1);
	suf[n+1]=1;
	for (int i=n;i>=1;i--){
		if (s[i]=='l'||s[i]=='q'||s[i]=='b') suf[i]=suf[i+1];
		else suf[i]=0;
	}
	
	if (suf[1]){
		printf("Yes\n");
		return ;
	}
	
	base[0]=1;
	for (int i=1;i<=n;i++) base[i]=base[i-1]*B;
	
	h1[0]=0;
	for (int i=1;i<=n;i++) h1[i]=h1[i-1]*B+s[i];
	
	h2[n+1]=0;
	for (int i=n;i>=1;i--) h2[i]=h2[i+1]*B+s[i];
	
	for (int i=1;i<=n;i++){
		//part1: [1,i]
		//part2:[i,2*i-1]
		if (2*i-1<=n&&query1(1,i)==query2(i,2*i-1)){
			if (suf[2*i]){
				printf("Yes\n");
				return ;
			}
		}
		
		if (2*i<=n&&query1(1,i)==query2(i+1,2*i)){
			if (suf[2*i+1]){
				printf("Yes\n");
				return ;
			}
		}
	}
	
	printf("No\n");
}

signed main(){
	int T;
	scanf("%llu",&T);
	while (T--) solve();
	return 0;
} 
```

---

## 作者：zts201210 (赞：0)

[原题。](/problem/P10905)

# 知识点：回文字符串

回文字符串指一个字符串反转形式与原字符串相同。

回文字符串有这个性质：

设有字符串 $A,B,C$。字符串 $C$ 是字符串 $A$ 的反转形式，字符串 $B$ 是回文字符串。

字符串 $A,B,C$ 拼接后，仍是回文字符串。

# 输入处理

将输入的字符串 $S$ 分成两部分，后面是由 `l`,`q`,`b` 组成的字符串 $T$。

若前面是回文字符串，在开头加入 $T$ 反转形式即可。

反之，在开头加入任何东西都不能把字符串 $S$ 转化为一个回文字符串。

# 注意

字符串 $S$ 开头要是有 `l`/`q`/`b`，就有可能是最后连续的 `l`,`q`,`b` 开头一部分的反转形式。

# 步骤

先找不以 `l`/`q`/`b` 开头、结尾的最长子串。

设其开头为 $k$，结尾为 $j$，字符串大小为 $a$。

流程如下：

1. 如果 $j=-1$，那么说明整个字符串都由 `l`,`q`,`b` 组成。在这种情况下，我们在开头加上字符串 $S$ 的反转形式即可。
2. 如果这个开头为 $k$，结尾为 $j$ 的子串不是回文串，那么加什么都没用。
3. 若以上条件都不符合，看前 $k$ 个字符是否为后面由 `l`/`q`/`b` 组成的最长子串的反转形式。若是，则前 $k+j+1$ 个字符组成的字符串是回文串，在开头插入后 $a-k-j-1$ 个字符的反转形式即可。否则，加什么都没用。

# AC Code

```cpp
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int main(){
	int n,j,k; 
	string s,temp;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		for(j=s.size()-1;((s[j]=='l'||s[j]=='q')||s[j]=='b')&&j>=0;j--);
		if(j<=0)cout<<"Yes"<<endl;
		else{
			for(k=0;k<j&&((s[k]=='l'||s[k]=='q')||s[k]=='b');k++);
			temp=s.substr(k,j-k+1);
			reverse(temp.begin(),temp.end());
			if(temp!=s.substr(k,j-k+1))cout<<"No"<<endl;
			else{
				for(k--,j++;(k>=0&&j<=s.size())&&s[k]==s[j];k--,j++);
				if(k==-1)cout<<"Yes"<<endl;
				else cout<<"No"<<endl;
			}
		}
	}
}
```

---

## 作者：xxseven (赞：0)

下文记题目中给出的三种字母为**特殊字母**，其余字母为**一般字母**。

根据回文串的性质，在左边添加字符等同于在右边减少对应字符。因此我们可以将题面转化为在右边去除任意个特殊字符。

因为删除过后开头的特殊字符数量不会减少，所以假如 $s$ 的**极长特殊字符前缀**的长度为 $p$，那么删除过后的**极长特殊字符后缀**长度也需要为 $p$。

据此我们就可以知道要删几个字母，之后直接做回文串匹配即可。

时间复杂度 $O(\sum |S|)$，可以通过此题。

下面是代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int T,len,a[255];
string s;
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>T; a[98]=a[108]=a[113]=1;//标记特殊字符
	while(T--){
		cin>>s; len=s.size();
		int l=-1,r=len,flag=0;
		while(a[s[l+1]]==1&&l+1<=len) l++;
		while(a[s[r-1]]==1&&r-1>=0) r--;//找到极长特殊字符前后缀
		if(l>r) {//全都是特殊字符
			cout<<"Yes\n"; continue; 
		}
		if(l+1>len-r){//前缀长度长于后缀
			cout<<"No\n"; continue;
		}
		for(int i=0;i<=r+l;++i){//普通回文串匹配
			if(s[i]!=s[r+l-i]){
				flag=1; break;
			}
		}
		cout<<(flag==1?"No\n":"Yes\n");
	}
	return 0;
}

```

---

## 作者：Lele_Programmer (赞：0)

# P10905 题解

## 思路

先将左右两端的所有 `l`、`q`、`b` 拿走，看一下中间剩下的是不是回文串，如果是回文串，还要再看一下从这个串左右两端逐渐添加字符，是不是还是回文串，直到左边没有字符可以再添加了，右边刚好也用完或者还剩下一些字符，那么就是可行的。

举个例子。

字符串 `qbacabqbqbqbq`，把左右两端的指定字符去掉，得到 `aca`，这是一个回文串，然后两端逐渐添加字符，直到左边用完，也就是 `qbacabq`，剩下右边还有 `bqbqbq` 就不管了因为可以在左边插入。

但有一个注意点，比如这个 `qbqbqbacabq`，这个是不成立的，因为后面在添加字符的时候，左边还没用完，右边已经用完了。

时间复杂度：$\mathcal{O}(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1000005;

int T,n;
char s[N];

inline bool check(char c) {
    return c=='l' || c=='q' || c=='b';
}

inline bool check_palindrome(int l,int r) {
    while (l<r) if (s[l++]!=s[r--]) return false;
    return true;
}

int main() {
    scanf("%d",&T);
    while (T--) {
        scanf("%s",s+1);
        n=strlen(s+1);
        int l,r;
        for (l=1;l<=n;++l) if (!check(s[l])) break;
        if (l==n+1) {
            puts("Yes");
            continue;
        }
        for (r=n;r;--r) if (!check(s[r])) break;
        if (l-1>n-r || !check_palindrome(l,r)) {
            puts("No");
            continue;
        }
        --l,++r;
        bool ok=true;
        while (l && r<=n) {
            if (s[l]!=s[r]) {
                ok=false;
                break;
            }
            --l,++r;
        }
        if (ok) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

---


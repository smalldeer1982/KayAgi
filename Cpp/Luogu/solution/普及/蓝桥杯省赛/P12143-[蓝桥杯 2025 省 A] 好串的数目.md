# [蓝桥杯 2025 省 A] 好串的数目

## 题目描述

对于一个长度为 $n$ 的字符串 $s = s_0s_1 \cdots s_{n-1}$ 来说，子串的定义是从中选出两个下标 $l, r$ $(0 \leq l \leq r \leq n-1)$，这之间所有的字符组合起来的一个新的字符串：$s' = s_ls_{l+1} \cdots s_r$ 就是其中一个子串。

现在给出一个只有数字字符 $0 \sim 9$ 组成的数字字符串，小蓝想要知道在其所有的子串中，有多少个子串是好串。一个子串是好串，当且仅当它满足以下两个条件之一：
1. 单字符子串一定是好串，即当子串长度为 $1$ 时，它总是好串；
2. 长度大于 $1$ 时，可以拆分为两个**连续非递减子串**：
   一个串 $p = p_0p_1 \cdots p_{k-1}$ 为**连续非递减子串**是指，对于所有 $1 \leq i < k$，满足 $p_i = p_{i-1}$ 或 $p_i = p_{i-1} + 1$。即数字串中的每一个数字，要么等于上一个数字，要么等于上一个数字加 $1$。例如 `12233`、`456` 是连续非递减子串。

## 说明/提示

### 样例说明 1

- 长度为 $1$ 的好串：`1`、`2`、`2`、`5`、`8`，共 $5$ 个；
- 长度为 $2$ 的好串：`12`、`22`、`25`、`58`，共 $4$ 个；
- 长度为 $3$ 的好串：`122`、`225`，共 $2$ 个；
- 长度为 $4$ 的好串：`1225`，共 $1$ 个；

总计 $5 + 4 + 2 + 1 = 12$ 个。

### 样例说明 2
- 长度为 $1$ 的好串：`9`、`7`、`8`、`5`、`6`，共 $5$ 个；
- 长度为 $2$ 的好串：`97`、`78`、`85`、`56`，共 $4$ 个；
- 长度为 $3$ 的好串：`978`、`785`、`856`，共 $3$ 个；
- 长度为 $4$ 的好串：`7856`，共 $1$ 个；

总计 $5 + 4 + 3 + 1 = 13$ 个。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 5$；
- 对于 $40\%$ 的评测用例，$1 \leq n \leq 20$；
- 对于 $60\%$ 的评测用例，$1 \leq n \leq 100$；
- 对于 $70\%$ 的评测用例，$1 \leq n \leq 10^3$；
- 对于 $80\%$ 的评测用例，$1 \leq n \leq 10^4$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$s$ 中只包含数字字符 $0 \sim 9$。

## 样例 #1

### 输入

```
12258```

### 输出

```
12```

## 样例 #2

### 输入

```
97856```

### 输出

```
13```

# 题解

## 作者：snnbyyds (赞：15)

---
# P12143 [蓝桥杯 2025 省 A] 好串的数目

## 思路
滑动窗口

先来分析一些性质。阅读题目，我们发现，连续非递减子串必须满足：对于相邻字符 $c_1$ 和 $c_2$，满足 $c_1=c_2$ 或者 $c_1+1=c_2$，我们将这个条件称之为一个约束。那么好串的定义就可以简化为“破坏约束的次数小于等于  $1$ 的字符串”。基于此简化的定义，我们不难发现，子串越长，越难以成为好串；子串越短，越可能成为好串。严格来说，如果一个字符串是好串，那么它的所有子串也都是好串。这个性质构成了暴力解法的重要优化方向。

我们可以枚举子串的右端点下标 $r$，同时维护左端点下标 $l$，使得以 $r$ 结尾的子串中，从 $l$ 到 $r$ 的部分是满足要求的最长好串，然后将答案累加 $r-l+1$，此数值即为以 $r$ 结尾的所有好串的个数。其中，用变量 $brk$ 来维护约束破坏的发生次数。当 $brk$ 超过 $1$ 时，滑动窗口左边界 $l$ 向右移动，直至窗口内好串的条件得以恢复。

## Code
可以用变量 $brk$ 来维护约束破坏的发生次数。在 $brk$ 过大时，就增加 $l$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int nn = 100005;
char s[nn];

int main() {
    cin.tie(0);
    ios::sync_with_stdio(0);
    cin >> s;
    int brk = 0, l = 0;
    int64_t ans = 0;
    for (int r = 0; s[r]; r++) {
        if (r && s[r - 1] + 1 != s[r] && s[r - 1] != s[r])
            brk++;
        while (brk > 1) {
            l++;
            if ((s[l] != s[l - 1] && s[l - 1] + 1 != s[l]))
                brk--;
        }
        ans += r - l + 1;
    }
    cout << ans << '\n';
    return 0;
}
```

## 时间复杂度

时间复杂度为 $O(n)$。

---

## 作者：Levisuper (赞：7)

考虑令 $pre[i]$ 表示 $[pre[i], i]$ 是连续非递减子串，这可以 $O(n)$ 预处理：

```cpp
std::vector<int> pre(n);
for (int r = 1, l = 0; r < n; r++) {
    if (s[r] != s[r - 1] and s[r] != s[r - 1] + 1) {
        l = r;
    }
    pre[r] = l;
}
```

而题目要求能分成两段，那其实就是对 $pre$ 再做一遍 $pre$，即逆序遍历 $pre$，做操作 $pre[i] = pre[\max(0, pre[i] - 1)]$。

```cpp
for (int i = n - 1; i > 0; i--) {
    pre[i] = pre[std::max(0, pre[i] - 1)];
}
```

最后的答案即为 $ans = \sum\limits_{i = 0}^{n - 1}(i - pre[i] + 1)$。

### 时间复杂度 $O(n)$

### C++ Code

```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    std::string s;
    std::cin >> s;

    int n = s.size();

    std::vector<int> pre(n);
    for (int r = 1, l = 0; r < n; r++) {
        if (s[r] != s[r - 1] and s[r] != s[r - 1] + 1) {
            l = r;
        }
        pre[r] = l;
    }
    for (int i = n - 1; i > 0; i--) {
        pre[i] = pre[std::max(0, pre[i] - 1)];
    }

    i64 ans = 0;
    for (int i = 0; i < n; i++) {
        ans += i - pre[i] + 1;
    }
    std::cout << ans << "\n";
    
    return 0;
}
```

---

## 作者：Wsl886 (赞：3)

## 分析
好串一共有两种，一种是本身就是好串（本身就是好串所以从哪里分开都能是连续非递减子串），第二种是由两个连续非递减子串拼成的好串。
## 做法
我们可以把整个序列分成一个个小块，这些小块的特点为它无法向两边继续扩展成为更大的连续非递减子串，也就是极大的连续非递减子串。这样不难发现，第一种好串一定在某一个小块里，第二种好串一定横跨了恰好两个块。之后就可以先预处理每一个块的长度。最后运用等差序列求和公式就可以 $O(1)$ 的时间里求出块里有几个好串。用乘法原理求出第二种好串。 
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010],len[100010];	
char s[100010];
int main()
{
	cin>>s+1;
	int n=strlen(s+1),sum=0;
	int last=0;
	long long ans=0;
	for(int i=2;i<=n;i++){
		if(!(s[i-1]==s[i]||s[i-1]+1==s[i])){
			len[++sum]=i-last-1;
			last=i-1;
		}
	}
	len[++sum]=n-last;
	for(int i=1;i<=sum;i++){
		ans+=1LL*(len[i])*(len[i]-1)/2+len[i];
		ans+=1LL*(len[i])*(len[i-1]);
	}
	cout<<ans;
}
```

---

## 作者：Lmx120815 (赞：2)

我们可以发现长度为 1 或 2 的字符串一定是好串，而长度为 3 以上的字符串要么本身为连续非递减子串，要么由 2 个连续非递减子串拼接而成。所以我们可以提前预处理出所有连续非递减子串，记录起点与终点，最后计算答案即可。对于本身是连续非递减子串的好串，它一定在某个连续非递减子串中，可以用等差数列求出；对于由 2 个连续非递减子串拼接而成的好串，可以用乘法原理，将连续两个区间长度相乘即可求出。
```cpp
#include <bits/stdc++.h>
#define int long long
#define ll long long
#define ull unsigned long long
#define inf 1e18
#define eps 1e-9
#define ls 2*k
#define rs 2*k+1
#define endl "\n"
#define il inline
using namespace std;
const int N=1e6+5,M=3e5;
const int mod=998244353;
inline int read(){
	int x(0),f(1);char c=getchar();
	while(!isdigit(c)) {if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)) {x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
string s;
int n,ans,a[N];
signed main(){
	cin>>s;
	n=s.size();
	vector<pair<int,int> >pre;
	int st=1;
	for(int i=1;i<=n;i++){
		a[i]=s[i-1]-'0';
		if(i>1 && a[i]!=a[i-1] && a[i]!=a[i-1]+1){
			pre.push_back({st,i-1});
			st=i;
		}
	}
	pre.push_back({st,n});
	int abc=0;
	for(auto e : pre){
		int len=e.second-e.first+1;
		ans+=(len+1)*len/2;
		ans+=len*abc;
		abc=len;
	} 
	cout<<ans;
	return 0;
}
```

---

## 作者：Meickol (赞：1)

## 后缀处理 + 字符串模拟

简单题，维护 $ne$ 数组，用 $ne_i$ 记录 $i$ 位置作为左端点最右能扩展到的位置。

显然 $[i,ne_i]$ 这段区间的子串是一个连续非递减子串，当该区间长度等于 $1$ 时，符合题意好串的定义；当该区间长度大于 $1$ 时，显然我们有办法将这个区间拆分成两部分，使得两部分都是连续非递减子串，于是也符合题意好串的定义。

同时，若记 $p=ne_i$，显然区间为 $[i,p]$ 的这个连续非递减子串可以和区间为 $[p+1,ne_{p+1}]$ 的这个连续非递减子串拼接，也符合题意好串的定义。

于是得出结论，对于位置 $i$ 而言，当其作为好串左端点，那么右端点可以选取为 $[i,ne_p+1]$。考虑计算贡献即可。

一些细节可见下方代码。

```cpp
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
const int N=1e5+5;
int stk[N],top;
int ne[N];
void solve(){
	string s;
	cin>>s;
	int n=s.size();
	s=" "+s;
	ne[n]=n;
	per(i,n-1,1){
		if(s[i]==s[i+1] || s[i]+1==s[i+1]) ne[i]=ne[i+1];
		else ne[i]=i;
	}
	LL ans=0;
	rep(i,1,n){
		int p=ne[i];
		if(p!=n) p=ne[p+1];
		int cnt=p-i+1;
 		if(cnt>=0) ans+=cnt;
	}
	cout<<ans;
}
```

---

## 作者：コマエダ (赞：1)

**题意：**

给定一个仅有 $0 \sim9$ 组成的字符串，求出好串的数目。

**思路：**

这里本蒟蒻给出一个较笨但好想的做法，就是对字符串分段。

首先比较好想的是，$1$ 个字符和相邻 $2$ 个字符一定是好串，所以我们最后加上这一部分的答案即可。

接下来，我们按照题目中对**单调非递减**的定义，将原字符串分为若干段，同时记录每一段的长度，记为 $block_i$。

现在我们考虑每一段对答案的贡献。

如果某一段字符串长度不超过 $2$ 那么不用管这一段本身，因为最后统计 ① 中的答案就考虑进去了；

然后考虑如果某一段字符串长度超过 $2$，那么在这一段的内部就有好串。具体地，它就会产生 $\dfrac{(block_i-2)\times (block_i-1)}{2}$ 的答案（自己手玩以下可以发现就是一个公比为 $1$ 的等差数列求和只需求到长度为 $3$ 时即可）；

最后考虑不同段之间的答案，每次只需要考虑相邻两段即可。第 $i-1$ 段可以与第 $i$ 段的前 $k$ 个字符构成好串，第 $i$ 段可以与第 $i-1$ 段的后 $l$ 个字符构成好串。但是别忘了两种情况里有一个重叠的字符串就是直接把这两个串接在一起，所以这个时候的答案就是 $block_i\times block_{i-1}-1$。最后把所有贡献加在一起就好了。时间复杂度 $O(n)$。

**代码：**

```c++
#include<bits/stdc++.h>
#define N 100050
using namespace std;
typedef long long ll;
char ch[N];
int len,a[N];
ll cnt=1,tot=0,block[N];
ll ans=0;
int main()
{
	memset(block,0,sizeof(block));
	memset(a,0,sizeof(a));
	scanf("%s",ch+1);
	len=strlen(ch+1);
	for(int i=1;i<=len;i++) a[i]=ch[i]-48;
	for(int i=2;i<=len;i++)
	{
		if(a[i]-a[i-1]==0||a[i]-a[i-1]==1) cnt++;
		else 
		{
			block[++tot]=cnt;
			cnt=1;
		}
	}
	block[++tot]=cnt;
	ans=(block[1]-2)*(block[1]-1)>>1;
	for(int i=2;i<=tot;i++) 
	{
		ans+=((block[i]-2)*(block[i]-1))>>1;
		ans+=(block[i]*block[i-1])-1;
	}
	ans+=2*len-1;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：断清秋 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12143)

蓝桥 F 题。

首先好串可以分为两种，一种是连续非递减串，一种是有断点但是可以分割成两个连续非递减子串。

考虑在一个好串后面添加一个数字，如果它能跟上一个连起来那肯定是好串，且整个串的性质不变。如果连不起来那么没有断点的好串会变成有断点的好串，有断点的好串则无法作出贡献。

然后又注意到如果 $[i,j]$ 是好串那么它的子区间肯定全是好串，所以只需要计算大段贡献即可。

于是双指针扫一遍整个串，记录当前好串类型和断点位置即可。

时间复杂度 $O(n)$。


```cpp
//简单题需要代码……
n=s.length(),ans=n;
int i=0,j=1,rec=-1;
while(i<j&&j<n)
{
	if(s[j-1]==s[j]||s[j-1]+1==s[j])
		ans+=(j-i),j++;
	else if(rec==-1)
		ans+=(j-i),rec=j,j++;
	else
		i=rec,rec=-1;
}
cout<<ans<<"\n";
```

---

## 作者：Kagamino_Natsumi (赞：1)

# P12143 [蓝桥杯 2025 省 A] 好串的数目

## 思路
我们可以把一整个串分割为多个极大的“连续非递减子串”，称之为“块”。例如， $12258$ 可以被分割为 $122$ ， $5$ 和 $8$ 。

题目中要求一个好串长度为 $1$ （此时其本身为连续非递减子串），或可以拆分为两个连续非递减子串（注意到长度大于 $1$ 的连续非递减子串也可以被拆分成两个连续非递减子串）。也就是，好串要么本身就是连续非递减子串，要么是两个连续非递减子串拼接的结果。

换句话说，好串必须在某个块内，或正好在相邻的两个块中。

据此可以写出代码，时间复杂度为 $O(n)$。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
char s[100007];
int cut[100007];
int cnt = 0;
long long ans = 0;

int main()
{
	cin >> (s + 1);
	n = strlen(s + 1);
	int last = 0;
	for(int i = 2; i <= n; i++)
	{
		if(s[i] == s[i - 1] || s[i] == s[i - 1] + 1)
			continue;
		cut[++cnt] = i - last - 1;
		last = i - 1;
	}
	cut[++cnt] = n - last;
	for(int i = 1; i <= cnt; i++)
	{
		ans += 1ll * cut[i] * (cut[i] - 1) / 2 + cut[i];//在块内，长度大于1或长度为1 
		ans += 1ll * cut[i] * cut[i - 1];//分在相邻两块中 
	}
		
	cout << ans << endl;
	return 0;
}
```

## 考场Code

考场上没来得及细想，使用了更劣、更丑陋的算法进行统计，不过也足以通过此题。思路是：枚举好串的首位，则在它所处的块的下一块末尾之前的所有数，都可以成为该好串的末位。


```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
char s[100007];
int cut[100007];
int cnt = 1;
long long ans = 0;

int main()
{
	cin >> (s + 1);
	n = strlen(s + 1);
	cut[1] = 1;
	for(int i = 2; i <= n; i++)
	{
		if(s[i] == s[i - 1] || s[i] == s[i - 1] + 1)
			continue;
		else 
		{
			cnt++;
			cut[cnt] = i;
		}
	}
	cnt++;
	cut[cnt] = n + 1;
	cnt++;
	cut[cnt] = n + 1;
	for(int i = 1; i <= n; i++)
	{
		int pos = upper_bound(cut + 1, cut + cnt + 1, i) - cut - 1;
		ans += (cut[pos + 2] - i);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Tdr1017 (赞：0)

## 分析

首先我们要理解题意，什么是好串，对于一个长度大于一的字符串，如果我们可以找到一个位置给他切割成两半，这两半分别都是连续非递减子串，即每一个字符要么等于前一个字符，要么等于前一个字符加一，$$n$$ 的数据范围显然不支持我们去遍历所有子串，我们考虑这些切割点能在什么地方，我们要保证每一个子串都必然至少有一个位置供我们切割成两个连续非递减子串，考虑把原字符串拆成一个个的连续非递减子串；对于每一个子串而言，他的任意一个子串必然都是满足的，例如 122 的子串 12 , 22, 122 均是合法的好串。

所以答案的一部分则是对于我们切割的每一个子串，统计其子串个数。

## 思路

对于切割得到的两个相领的子串，如果我们把他们进行拼接，显然是必定存在着一个位置(拼接点）可以把它分割成两个连续非递减子串，那么拼接的子串一共有多少个呢？

对于 122 和 5，

首先既然要拼接，那么两个子串都至少提供一个字符，122 一共可以提供 1，2，3 个字符这三种情况，形成 25，225，1225 这是三个即是好串，不难发现实际上就是  $a_i \times a_ {i+1}
  $ 的数量。

所以最后的 $ans = 8 + 3 \times 1 + 1 \times 1 = 12$ 个。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn=1e5+5;
typedef long long ll;

int n;
string s;
int mir[maxn];

int main(){
	cin>>s;
	n=s.length();
	s=" "+s;
	for(int r=n,l=n+1,lst=n+1;r>=1;r=l-1){//双指针拓展段，每次循环得到一段，段为[l,r]
		l--;
		while(l-1>=1 && (s[l]-s[l-1]==1 || s[l]-s[l-1]==0))l--;
		for(int i=l;i<=r;i++)mir[i]=lst;
//		cout<<l<<" "<<r<<" "<<lst<<endl;
		lst=r+1;
	}
	
	ll ans=0;
	for(int l=1,r,len;l<=n;l++){//右端点在[l,r)任取 
		r=mir[l];
		len=r-l;
		ans+=len;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

将串按最长连续非递减子串切段，答案是每段内部所有子串和相连段连续子串的统计值。复杂度 $O(n)$。
```python
a=[0];b=0
for i in map(int,input().strip()):
    if i==b or i==b+1:a[-1]+=1
    else:a.append(1)
    b=i
print(sum(i*(i+1)//2 for i in a)+sum(a[i]*a[i+1]for i in range(len(a)-1)))
```

---

## 作者：egg_boy (赞：0)

## 思路  
  首先根据题目可以将好串分成两类：  
1. 自身就是连续非递减子串。
2. 由两个连续非递减子串组合。

  由此我们可以先预处理所有 $1$ 类好串。并计算 $1$ 类好串的数量。

```cpp
// 这里是作者处理字符串的习惯
cin >> s; n = s.size(); s = " " + s;

// 这里计算了1类好串的数量
// 并且将所有1类子串长度依次存入a数组
for(int i = 1; i <= n; i++)
{
  if(s[i] == s[i - 1] || s[i] == s[i - 1] + 1) x++;
  else a[++m] = x, x = 1;
  ans += x;
}
a[++m] = x; // 最后的一个1类好串单独存
// 注：这里a[1]是一个空串的长度，但不影响计算
```
  接下来就可以处理 $2$ 类子串，这里举个例子方便大家理解：  
  
  例如 $1245$ 这个子串，首先我们将这个子串分成两个 $1$ 类好串：$12$ 和 $45$。长度都是 $2$。 
  
  接着列举出它包含的所有 $2$ 类好串：$24$，$245$，$124$，$1245$ 有 $4$ 个。  
  
  $4=2 \times 2$，这里可以发现一个 $2$ 类子串的贡献就是他所分成的 $2$ 个 $1$ 类子串之积。这句话也确实是对的，至于证明十分简单，留给读者自行思考。
  
```cpp
// 计算2类子串数量。
for(int i = 1; i < m; i++) ans += a[i] * a[i + 1];
```
感谢观看。

---


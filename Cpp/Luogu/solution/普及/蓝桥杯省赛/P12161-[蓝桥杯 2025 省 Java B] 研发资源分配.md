# [蓝桥杯 2025 省 Java B] 研发资源分配

## 题目描述

在蓝桥科技公司，$A$ 部门和 $B$ 部门正在竞争一种新型 AI 芯片的研发资源。

为了公平分配资源，公司设计了一个为期 $N$ 天的分配方案：

每天早上，$A$ 部门和 $B$ 部门各自提交一个需求等级（从 $1$ 到 $N$ 的整数）。提交等级较高的部门获得当天的资源，资源份额等于当天的日期编号（第 $1$ 天为 $1$ 单位，第 $2$ 天为 $2$ 单位，依次递增）。若两部门提交的等级相同，则当天资源作废，双方均无法获得资源。

每个部门必须在 $N$ 天内使用 $1$ 到 $N$ 的所有等级，且每个等级只能使用一次。

有趣的是，$A$ 部门在 $B$ 部门内部安插了一名 “间谍”，提前获知了 $B$ 部门的需求等级提交顺序，记为排列 ($P_1, P_2, \dots , P_N$)，其中 $P_i$ 表示 $B$ 部门在第 $i$ 天提交的需求等级。

现在，请你帮助 $A$ 部门分析，在已知 $B$ 部门需求等级顺序的情况下，$A$ 部门的总资源份额减去 $B$ 部门的总资源份额的差值最大可以是多少？

## 说明/提示

### 样例说明

$A$ 部门可以选择排列 $[2, 1, 3]$：
- 第 $1$ 天：$A(= 2) > B(= 1)$，$A$ 获得 $1$ 单位资源；
- 第 $2$ 天：$A(= 1) < B(= 3)$，$B$ 获得 $2$ 单位资源；
- 第 $3$ 天：$A(= 3) > B(= 2)$，$A$ 获得 $3$ 单位资源。

两者的差值为 $4 - 2 = 2$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq N \leq 11$，$1 \leq P_i \leq N$，$P_1, P_2, \dots , P_N$ 各不相同。
- 对于 $100\%$ 的评测用例，$1 \leq N \leq 10^5$，$1 \leq P_i \leq N$，$P_1, P_2, \dots , P_N$ 各不相同。

## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
2```

# 题解

## 作者：落落的去 (赞：8)

## 题意分析
给你一份 $n$ 的全排列 $a$，请你再给出一份 $n$ 全排列 $b$ 使得所有满足 $b_i>a_i$ 的 $i$ 的总和 $sumb$ 减去 所有满足 $b_i<a_i$ 的  $i$  的总和 $suma$ 的差值最大。

如果 $a_i==b_i$ ，则都不得分。  
## 思路分析
这不就是田忌赛马，考虑用下等马换掉对方的上等马。  

比如样例中的 `1 3 2` 这个排列，我们可以摆出 `2 1 3` 就是用最下等的马换掉对方最上等的马，而且由于是全排列，所以剩下的所有位置一定可以排出都比对方大的排列。

但是，如果我们遇到了 `2 1 3` 这个排列，如果还摆出 `3 2 1` 得到的结果是 `0` ，但是摆出 `1 2 3` 得到的结果是 `1` ,所以我们还需要考虑对方的上等马得到的分数特别多，这个时候就需要也用我们的上等马和他抵消掉了。

我选择打表找找规律。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
const int N = 2e5 + 10;

int a[100], n;
int t[100][100], cnt;

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) a[i] = i;
	do
	{
		cnt++;
		for (int i = 1; i <= n; i++) {
			t[cnt][i] = a[i];
		}
	}while(next_permutation(a+1, a+1+n));
	
	for (int i = 1; i <= cnt; i++) {
		for (int z = 1; z <= n; z++) cout<<z<<" "; cout << endl;
		cout << "----------------" << endl;
		for (int z = 1; z <= n; z++) cout<<t[i][z]<<" "; cout<<endl;
		int maxn=INT_MIN, id_;
		for (int j = 1; j <= cnt; j++) {
			int sa = 0, sb = 0;
			for (int k = 1; k <= n; k++) {
				if (t[j][k] > t[i][k]) sa += k;
				else if(t[j][k] < t[i][k]) sb += k;
			}
			if(sa - sb > maxn)
			{
				maxn = sa - sb;
				id_ = j;
			}
		}
		for (int z = 1; z <= n; z++) cout<<t[id_][z]<<" "; cout<<endl<<endl;
	}
	return 0;
}
```
打完表恍然大悟，我们能确定的是对方最多只能拿到一天的分数，如果要给对方拿到这一天的分数，那么对方之前投入的比这天更多数字的天数我们一定会用相同的数字抵消掉。

那么我们可以用结构体存储天数和数字，然后按数字降序排列。

然后从最大的数字开始选择是否用 `1` 去田忌赛马，如果用 `1` 去田忌赛马，有可能不会是最优解，尤其是最大的数字在最后一天的时候。

所以还可以考虑直接用最大的数字去抵消对方的最大的数字，那么再考虑剩下的数字中最大的数字即可。

## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
const int N = 1e5 + 10;

struct node{
	int val, pos;
}a[N];

bool cmp(node x, node y)
{
	return x.val > y.val;
}
ll n;
ll sum; // 目前能获得的资源总数
ll ans;

int main()
{
	cin >> n;
	sum = (1 + n) * n / 2; // 总得分
	for (int i = 1; i <= n; i++) {
		cin >> a[i].val;
		a[i].pos = i;
	}
	sort(a + 1, a + 1 + n, cmp);
	for (int i = 1; i <= n; i++) {
		sum -= a[i].pos; // 选择到这里田忌赛马能否得到最大值
		ans = max(ans, sum - a[i].pos);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Maxsong (赞：1)

# P12161 [蓝桥杯 2025 省 Java B] 研发资源分配

## 浅层理解

更高级的**田忌赛马**。每轮的得分根据轮数所定。允许通过相同的马来**撞马**。

明显易知最优肯定是放对面赢一局，剩下的自己赢。于是我们先按照田忌赛马理解。

## 深层分析

我们测试数据：

> $2\ 1\ 3$

输出 $0$，但是如果使用 $1\ 2\ 3$ 来**撞马**能得到 $1$。

全局视角想，当对面把最大的马放在后面时，我们使用田忌赛马肯定会吃亏。所以要考虑**撞最大的马**。

同理**撞最大的马**后还要考虑这个问题。思路是类递归。

## 总结 & 代码

- 按数字从大到小排序；
- 遍历，尝试**进行田忌赛马**或**继续撞最大的马**（我使用了伪递归）；

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans,sum,pnt;
pair<int,int>a[100001];
signed main(){
    scanf("%lld",&n);
    for(long long i=1;i<=n;i++){
        scanf("%d",&a[i].first);
        a[i].second=i;
    }sort(a+1,a+n+1);
    reverse(a+1,a+n+1);
    sum=n*(n+1)/2;
    for(long long i=1;i<=n;i++){
        if(sum-a[i].second>ans) pnt=a[i].second;
        ans=max(ans,sum-a[i].second-pnt);
        sum-=a[i].second;
    }printf("%lld\n",ans);
    return 0;
}
```

> 我不是孙膑。

---

## 作者：tiantianyang (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12161)

### 题目大意

给你一个总数 $n$ 再给你一个全排列 $a$，让你求一个全排列 $b$，问如何使所有 $a _ {i} ^ {} < b _ {i} ^ {}$ 的 $sumb$ 与 $a _ {i} ^ {} > b _ {i} ^ {}$ 的 $suma$，让 $sumb - suma$ 的值最大化。

如果 $a _ {i} ^ {} = b _ {i} ^ {}$ 则双方都无法得分（题意还是很好理解的）。

### 思路

这个题乍一看是很像**田忌赛马**的，但是仔细一看还是有很大区别的，因为在每一天是有对应的权值的，且权值是等于天数的（假如田忌赛马是这样的，孙膑再怎么聪明都赢不了）。

具体区别就是在这组样例中 `2 1 3` 如果你用 `3 2 1` 迎战是 `0`，但如果你用 `1 2 3` 迎战是 `1`，很明显后面一种更优。这样的话我们就不能简单的考虑用下等马去迎战对方的上等马。

我们可以多枚几组数据，来找找规律：

当 $n=3$ 时 `1 2 3` 用 `1 2 3` 最优；`1 3 2` 用 `2 1 3` 最优；`1 3 2` 用 `3 2 1` 最优；`1 2 3` 用 `1 2 3` 最优；`3 1 2` 用 `1 2 3` 最优；`2 3 1` 用 `1 3 2` 最优；你还可以再多枚几组或者写一个打表程序。

但枚到现在我们大概就知道了，一些规律：

首先我们可以发现我们在只输掉一场的比赛肯定是最优的，其次我们发现我们不能直接用 `1` 来换掉对方的上等马，尤其是在对方上等马占据高收益的时候。然后我们发现当对方占据大数之时可以选择使用同样的数消掉，最后将剩下的数进行排列获取收益。

就是说我们将 $b _ {i} ^ {}$ 的值以及他的对应天数存储在一个结构体中，将其按照从大到小的顺序排序，然后我们从最大的数字开始判断是否需要用 `1` 来换掉，或者选择用同样大的值进行消掉，具体实现来看代码。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5;
struct node{
	int day;int many;
}p[N];
int cmp(node x,node y){return x.many>y.many;}//从大到小的排序
int n,sum,ans;
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;sum=(1+n)*n/2;//算出资源总数
	for(int i=1;i<=n;i++) cin>>p[i].many,p[i].day=i;//存储B公司出示的等级及对应天数
	sort(p+1,p+1+n,cmp);//排序
	for(int i=1;i<=n;i++){//从大到小枚举
		sum-=p[i].day;//减掉对应资源
		ans=max(ans,sum-p[i].day);//看是选择用下等马兑换对面上等马优还是上等马对撞优
	}
	cout<<ans;
	return 0;//完美收官
}
```

---

## 作者：Charged_Charge (赞：1)

# 洛谷 P12161
## 题目分析：
这道题就是让你规划一份方案，让公司一的总资源份额之和大于公司而的总资源份额，并求出差值的最大值。
### 解题思路：
大体与田忌赛马一样。从前后两个方向分别构造两个不同的方案（因为可以通过多拿前面的资源超过最后一个资源），如果拿下当前资源是亏的，那么就从最小的资源开始，用目前能用的最小的资源去抵消对方最大的资源，保证亏损最小化，最后比较前后两个方向一公司与二公司资源的差值，求最大值，就是答案。到这里代码就不难了，但注意，一个资源只能用一次。
### AC 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+20;
int n;
int a[N];//二公司方案
int b[N];//从前往后构造一公司的方案
int c[N];//从后往前构造一公司的方案
int vis1[N];
int vis2[N];
int sum3, sum4;
int sum1, sum2;
signed main() {
	cin >> n;

	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	for (int i = 1; i <= n; i++) {//从前往后构造
		if (!vis1[a[i] + 1] && a[i] + 1 <= n) {//表示二公司没有提交最高等级并且一公司还没有提交相同等级
			c[i] = a[i] + 1;//那一 公司就抢下当天资源
			vis1[c[i]] = 1;//标记去重
		} else {
			for (int j = 1; j <= n; j++) {//不然就从最小的等级开始，用最小的代价输掉当天的资源
				if (!vis1[j]) {
					c[i] = j;
					vis1[j] = 1;
					break;
				}
			}
		}
	}

	for (int i = 1; i <= n; i++) {
		if (a[i] < c[i]) {
			sum3 += i;
		} else if (a[i] > c[i]) {
			sum4 += i;
		}
	}//统计一、二公司的情况

	if (a[n] == n) {
		b[n] = n;
		vis2[n] = 1;
	} else {
		b[n] = a[n] + 1;
		vis2[b[n]] = 1;
	}

	for (int i = n - 1; i >= 1; i--) {//从后往前构造，思路与上面相同
		if (a[i] == n) {
			if (!vis2[n]) {
				b[i] = n;
				vis2[n] = 1;
			} else {
				for (int j = 1; j <= n; j++) {
					if (!vis2[j]) {
						b[i] = j;
						vis2[j] = 1;
						break;
					}
				}
			}
		} else {
			if (!vis2[a[i] + 1]) {
				b[i] = a[i] + 1;
				vis2[b[i]] = 1;
			} else {
				for (int j = 1; j <= n; j++) {
					if (!vis2[j]) {
						b[i] = j;
						vis2[j] = 1;
						break;
					}
				}
			}
		}
	}

	for (int i = 1; i <= n; i++) {
		if (a[i] < b[i]) {
			sum2 += i;
		} else if (a[i] > b[i]) {
			sum1 += i;
		}
	}

	cout << max(sum3 - sum4, sum2 - sum1);//求出两种方向的差值的最大值
	return 0;
}
```

---

## 作者：yingxi (赞：1)

## [题面传送门](https://www.luogu.com.cn/problem/P12161)

既然要使 A 部门最终获得的资源与 B 部门的差值最大，而 A 部门又知道 B 部门的等级提交顺序，如果要让 A 部门赢，就应该让 A 部门在资源量大的日子获胜，在资源量小的日子输。

首先算出所有资源的总和 `sum = n*(n+1)/2`，然后存储 B 部门每天的需求等级及其对应的日期。再将 B 部门的需求等级按从大到小排序，这样就可以决定 A 部门如何分配自己的等级。

这里说一下贪心的思路：

- 对于 B 部门最高的需求等级，A 部门使用比 B 部门小的等级（让 A 输掉）
- 对于 B 部门次高的需求等级，A 部门还是使用比 B 部门小的等级（还是让 A 输掉）

然后这样以此类推，一直到某个点时，再让 A 赢。

最后再去算答案就可以了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 100005;
struct node{
	int id, x;
}a[N]; 
int n, ans;
bool cmp(node a, node b) //用于排序
{
	return a.x > b.x;
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    int sum = n * (n + 1) / 2; //计算总和
    for (int i = 1; i <= n; i++)
    {
    	cin >> a[i].x;
    	a[i].id = i;
	}
	sort(a + 1, a + n + 1, cmp);
	for (int i = 1; i <= n; i++)
	{
		sum -= a[i].id;
		ans = max(ans, sum - a[i].id);
	}
	cout << ans;
    return 0;
}
```

**时间复杂度：** 排序是 $O (N \log N)$，循环是 $O (N)$，所以省略常数后是 $O (N \log N)$。

---

## 作者：YYF_Maple_Leaves (赞：0)

## 题意分析

[题目传送门](https://www.luogu.com.cn/problem/P12161)

我们需要让 `A` 部门所获得的资源总数 $S_{A}$ 与 `B` 部门所获得的资源总数 $S_{B}$ 的差最大，并且题目中指明 `A` 部门资源获得要比 `B` 部门获得的多，所以我们要尽量增多 $S_{A}$，尽量减少 $S_{B}$，使得两者差值最大。

同时题目中还存在一种情况，如果 $S_{A}=S_{B}$，则两者皆不可得。

我们很容易地可以想到贪心。

## 思路解析

我们观察样例可以发现，`B` 部门的每次请求 $P_{b}$ 值除最大值 $P_{bmax}$ 外，其他的相应地都可以用比 $P_{b}$ 略大 $1$ 的 $P_{a}$ 抵消掉，最后我们可以用 $P_{a}=1$ 去应对 $P_{bmax}$，以至于 B 部门只能获得一天的资源，使得差值最大。

这种思想相当于田忌赛马的思想，用下等马对上等马。

但是，我们忽略了一个最重要的条件。

我们先来看一组样例 `2 1 3`，当我们按照上面思想进行贪心时，我们的分配方式是这样的 `3 2 1`。

这时我们的答案 $ans$ 为0，但是如果我们按照 `1 2 3` 来分配，$ans$ 为 $1$。

这也许能给我们一些启发，我们需要用循环从大到小枚举重合的量，用总的资源数不断减去 $i$，再将所得的值与 $ans$ 取最大值，即为所求答案。

记得 $n,ans,sum$ 都要开 `long long`。~~别问我怎么知道的，不开只有 $55$ 分。~~

## AC代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct point
{
	long long pos,tnt;
};
point s[100005];
bool cmp(point x,point y)
{
	return x.pos>y.pos;
}
int main()
{
	long long n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i].pos;
		s[i].tnt=i;
	}
    long long num=((1+n)*n)/2;
	sort(s+1,s+n+1,cmp);
	long long ans=num-s[1].tnt-s[1].tnt;
	for(int i=1;i<n;i++)
	{
		num-=s[i].tnt;
		ans=max(ans,num-s[i+1].tnt-s[i+1].tnt);
	}
	cout<<ans<<endl;
 } 
```

---


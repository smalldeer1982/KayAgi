# [蓝桥杯 2025 省 C/Python A] 倒水

## 题目描述

小蓝有 $n$ 个装了水的瓶子，从左到右摆放，第 $i$ 个瓶子里装有 $a_i$ 单位的水。为了美观，小蓝将水循环染成了 $k$ 种颜色，也就是说，第 $i$ 个瓶子和第 $i + k$ 个瓶子里的水的颜色相同。

小蓝发现有的瓶子里的水太少了，因此他规定如果第 $i$ 个瓶子和第 $j$ 个瓶子中的水颜色相同并且满足 $i < j$，即可将任意整数单位的水从第 $i$ 个水瓶倒出，倒入第 $j$ 个水瓶中。小蓝想知道任意次操作后所有瓶子中的水的最小值 $\min\{a_i\}$ 最大可以是多少？

## 说明/提示

### 样例说明

其中一种方案：
- $a_1$ 往 $a_4$ 倒入 $3$ 单位；
- $a_2$ 往 $a_5$ 倒入 $2$ 单位；
- $a_3$ 往 $a_6$ 倒入 $1$ 单位；
最终每个瓶子里的水：$5, 3, 4, 5, 4, 4, 4$，最小值为 $3$。

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$1 \leq n, a_i \leq 100$；
- 对于所有评测用例，$1 \leq n, a_i \leq 100000$，$1 \leq k \leq n$。

## 样例 #1

### 输入

```
7 3
8 5 5 2 2 3 4```

### 输出

```
3```

# 题解

## 作者：GeomeTryC (赞：4)

注意到对于一个任意次操作后所有瓶子中的水的最小值 $\min\left \{ a_{1},a_{2},\cdots,a_{n} \right \} $，小于它的值也一定可行，因此答案具有单调性，并且可以 $O(n)$ 检查一个值是否可行，因此可以使用二分答案。

将每一种相同颜色的水（也就是相隔 $k$ 的数）分为一组，预处理得到每一组数平均值的最小值，记为 $m$，对 $m$ 进行二分即可。那么时间复杂度就是 $O(n\log m)$，可以通过本题。


---


代码如下：


```python
import sys
import copy

input = lambda: sys.stdin.readline().strip()
n, k = map(int, input().split())
ls = list(int(x) for x in input().split())
r = float(1e9)
nums = []


def test(n, nums):
    for ls in nums:
        for i in range(len(ls) - 1):
            if ls[i] > n:
                ls[i + 1] += ls[i] - n
                ls[i] = n
            elif ls[i] < n:
                return False
        if ls[-1] < n:
            return False
    return True


for i in range(k):
    tmp = []
    s = 0
    for j in range(i, n, k):
        tmp.append(ls[j])
        s += ls[j]
    r = min(r, s // len(tmp))
    nums.append(tmp)
l = 0
ans = 0
while l < r:
    m = (r + l + 1) // 2
    if test(m, copy.deepcopy(nums)):
        ans = max(m, ans)
        l = m
    else:
        r = m - 1

print(ans)

---

## 作者：tuxiaolai (赞：3)

#### 开头介绍：
该题解为本蒟蒻第一个题解，不用二分做法，想用二分的见其他题解。

注意：本文中“!”表感叹。

---

#### 题目分析：

[传送门](https://www.luogu.com.cn/problem/P12167)

大概看一下题目就可以知道：其实就是同种颜色的水在倒来~~倒去~~。

这里就要注意了：题目中说：

> 因此他规定如果第 $i$ 个瓶子和第 $j$ 个瓶子中的水颜色相同并且满足 $i<j$，即可将任意整数单位的水从第 $i$ 个水瓶倒出，倒入第 $j$ 个水瓶中。

所以：只能从左往右倒，不能反过来。

右边的水不能倒过来，就不能增加同种颜色中前 $i$ 个杯子的水的总量。所以，前 $i$ 个水的总量的最大值就是这 $i$ 个数的和。那么，这 $i$ 个数的最小值的最大值就是他们的平均数。

我们找出的数必须满足大于等于所有平均数。所以，这个数就是所有平均数的最小值。

---

#### 算法解析
首先：我们建一个类，来记录一种颜色中目前的前缀和以及杯子数。
```cpp
struct Node { //用于表示每种颜色的情况
    long long sum=0,cnt=0; //sum前缀和 cnt数量
} s[M];
```

接下来，输入 $n$ 和 $k$ 后，按顺序输入每个 $a$ 的值。将 $a$ 加到对应颜色的 $sum$ 中，并使 $cnt$ 加1。
```cpp
for(int i=1; i<=n; i++) {
    cin>>a[i];
    s[i%k].sum+=a[i];
    s[i%k].cnt++;
```
最后求出平均值并更新 $ans$ 即可。

完整代码如下：
```cpp
//luogu P12167
#include <bits/stdc++.h>
using namespace std;
const int M=100010;
struct Node { //用于表示每种颜色的情况
    long long sum=0,cnt=0; //sum前缀和 cnt数量
} s[M];
long long n,k;
long long a[M],ans=1e9;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>k;
    for(int i=1; i<=n; i++) {
        cin>>a[i];
        s[i%k].sum+=a[i];
        s[i%k].cnt++;
        ans=min(s[i%k].sum/s[i%k].cnt,ans);
    }
    cout<<ans;
    return 0;
}
```


---


复杂度 $O(n)$，
代码长度应该没有更短的了吧。

[交作业](https://www.luogu.com.cn/problem/P12167)

---

## 作者：chen_kun (赞：3)

# P12167 [蓝桥杯 2025 省 C/Python A] 倒水题解

## 思路简述

题目中出现了**最小值最大**，于是我们可以很容易地想到这是**二分答案**。

二分函数里的内容很简单，主要是 $\operatorname{check}$ 函数里的内容怎么写。

既然我们二分的 $mid$ 是最大的最小值，因此我们应控制 $a$ 数组里的值都要大于等于 $mid$。首先把相隔 $k$ 个数的数分为一组，我们可以先开一个 $tot_{pos}$ 数组记录第 $pos$ 组中目前比 $mid$ 值多出多少。然后遍历 $n$ 个数，当第 $i$ 个数大于 $mid$ 时，则把 $a_i$ 多出 $mid$ 的值累加进 $tot$ 数组中，为后面留水。当第 $i$ 个数小于 $mid$ 时，就要用它这一组前面省下的水补上，如果前面省下的水都不够它补则说明 $mid$ 太大了不满足。

## 代码实现


```python
import sys
def check(x, n, k, a):
    tot = [0] * k
    for i in range(1, n + 1):
        pos = i % k                         # 分组
        tot[pos] += max(0, a[i - 1] - x)
        if a[i - 1] - x < 0:                # 当前的水太少了
            if a[i - 1] - x + tot[pos] < 0: # 且前面省下的水无法补足
                return False                # 则代表mid太大不成立
            tot[pos] -= (x - a[i - 1])      # 否则补上之前省下的水
    return True
def GG_bound(l, r, n, k, a):                # 二分函数
    ans = 0
    while l <= r:
        mid = (l + r) // 2
        if check(mid, n, k, a):
            l = mid + 1
            ans = mid
        else:
            r = mid - 1
    print(ans)
def main():
    n, k = map(int, sys.stdin.readline().split())
    a = list(map(int, sys.stdin.readline().split()))
    GG_bound(0, 1 << 60, n, k, a)
if __name__ == "__main__":
    main()
```

---

## 作者：Charged_Charge (赞：2)

# 洛谷 P12167
## 题目大意：
给出 $n$ 个装了水的瓶子，以及一个 $k$ 表示第 $a_i$ 与第 $a_{i+k}$ 个瓶子的颜色是相同的。求出任意次操作后所有瓶子中的水的最小值最大可以是多少。
## 解题思路：
看见求最多或最少的值时，优先考虑二分。这里我们的判断函数里采用移多补少的思想，枚举每一种颜色，用一个计数器统计当前颜色的剩余补充值，当一瓶水的量大于二分的最大值时，计数器加上多出的部分当作补充值，反之减去不足的部分当作用去值，每一步操作后，判断计数器是否小于零，如果是，则不满足条件，函数返回否；如果否，则继续操作。当然，由于枚举的是每一种颜色，不是相同颜色的水不能操作，所以下标应该每次加 $k$。
## AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+20;
int n, k;
int a[N];
bool check(int mid) {
	for (int i = 1; i <= k; i++) {
		int sum = 0;

		for (int j = i; j <= n; j += k) {
			if (a[j] >= mid) {
				sum += a[j] - mid;
			} else {
				sum -= (mid - a[j]);
			}

			if (sum < 0) {
				return false;
			}
		}
	}

	return true;
}

int main() {
	cin >> n >> k;

	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	int l = 1, r = N;

	while (l <= r) {
		int mid = (l + r) >> 1;

		if (check(mid)) {
			l = mid + 1;
		} else {
			r = mid - 1;
		}
	}

	cout << r;
	return 0;
}
```

---

## 作者：Ceyase (赞：0)

# P12167

由于是最小值最大化的题目，我们当然会想到二分答案。

对于目标最小值 $x$，我们可以检查是否所有瓶子都至少能装 $x$ 个单位的水。

先将 $n$ 个瓶子 $a_i$ 划分为 $k$ 组，第 $i$ 组 $G_i=\{a_j \mid j \bmod k = i\}(0 \leq i < k)$。

由于在每组中，水只能从左往右倒，所以前面的瓶子可以支援后面的，但后面的不能支援前面的。

因此我们需要验证每个组中，从左到右的累积水量是否在每个步骤都能满足 $x$。具体来说，对于组中的每个瓶子，从组开始到该瓶子的水量之和必须至少是 $x$ 乘以该组已处理的瓶子数量。

假如前 $i+1$ 个瓶子的总水量小于 $(i+1)×x$，那么前 $i+1$ 个瓶子中必然会有一个瓶子的水量小于 $x$，此时 $x$ 当然就不是最小值了。

## 代码实现

```python
def main():
    import sys
    data = sys.stdin.read().split()
    n = int(data[0])
    k = int(data[1])
    a = list(map(int, data[2:2+n]))
    total = sum(a)
    groups = [[] for _ in range(k)]
    for i in range(n):
        groups[i % k].append(a[i])
    l, r = 0, total // n
    def check(x):
        for group in groups:
            s = 0
            for num in group:
                s += num - x
                if s < 0:
                    return False
        return True
    while l <= r:
        mid = (l + r) // 2
        if check(mid):
            l = mid + 1
        else:
            r = mid - 1
    print(r)
if __name__ == "__main__":
    main()
```

---

## 作者：chenxinran12 (赞：0)

### 题意理解
给定 $n$，$k$ 及一个长度为 $n$ 的序列 $a$，我们可以把 $a_i$ 转移至 $a_j$ 当且仅当 $j-i$ 为 $k$ 的倍数。最后求序列 $a$ 中最小值的最大值。
### 分析  
我们二分答案。  
二分十分好写。然后就是写 $check$。  
我们设 $x$ 为答案，用 $i$ 枚举前 $k$ 个数，用 $j$ 枚举 $i$ 可以转移的点。然后用一个数记录在满足之前的数都为 $x$ 的情况下剩余的数。若此数为负，就不行。  
详见代码。
### code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a[100002],l,r;
bool check(int x)
{
	for(int i=1;i<=k;i++)
	{
		int ans=0;
		for(int j=i;j<=n;j+=k)
		{
			ans+=a[j]-x;
			if(ans<0) return 0;
		}
	}
	return 1;
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    l=1,r=1e5;
    while(l<=r)
    {
    	int mid=l+r>>1;
    	if(check(mid)) l=mid+1;
    	else r=mid-1;
	}
	cout<<l-1;
    return 0;
}
```

---

## 作者：Chenyuze24 (赞：0)

看到最小值最大这一类题目，就显然要用[二分](https://oi-wiki.org//basic/binary/)。
## Part1 分析
最模版的就是二分里面的代码了。

```cpp
long long l = 0, r = INT_MAX;
while (l <= r) {
	long long mid = (l + r) / 2;
	if (judge(mid)) {
		l = mid + 1;
		ans = mid;
	}
	else {
		r = mid - 1;
	}
}
```
但是里面的 ```judge``` 函数怎么写呢，这才是重点。显然这一道题的思想就是平分。设参数为 $mid$，用 $q$ 来记录颜色，要注意的是它是要取模的，所以可以直接遍历整个数组，再让对应的下标模 $k$ 即可，设模完后的下标为 $s$，那么每次就让 ```q[s] = q[s] + a[i] - mid``` 即可，再来个判断，如果 $q_s<0$，那就说明不够补了，返回错误。

```cpp
bool judge(long long mid) {
	for (long long i = 1; i <= n; ++i) {//遍历。
		long long s = i % k;//取模。
		q[s] = q[s] + a[i] - mid;
		if (q[s] < 0) {//如果<0了，那就返回错误。
			return false;
		}
	}
	return true;//否则返回正确。
}
```
要注意，每次 $q$ 数组都要初始化成 $0$。

```cpp
void init() {
	fill(q, q + k, 0);
}
```


## Part2 代码

```cpp
#include<bits/stdc++.h>//万能头。
#define int long long//注意。
using namespace std;
long long n, k;
long long a[100005];
long long q[100005];
long long ans = 0;

void read() {//读入。
	cin >> n >> k;
	for (long long i = 1; i <= n; ++i) {
		cin >> a[i];
	}
}

void init() {//初始化。
	fill(q, q + k, 0);
}

bool judge(long long mid) {
	for (long long i = 1; i <= n; ++i) {//遍历。
		long long s = i % k;//取模。
		q[s] = q[s] + a[i] - mid;
		if (q[s] < 0) {//如果<0了，那就返回错误。
			return false;
		}
	}
	return true;//否则返回正确。
}

void solve() {
	long long l = 0, r = INT_MAX;//二分。
	while (l <= r) {
		long long mid = (l + r) / 2;
		init();//每次记得初始化。
		if (judge(mid)) {
			l = mid + 1;
			ans = mid;
		}
		else {
			r = mid - 1;
		}
	}
	cout << ans;//输出。
}

signed main() {
	read();
	solve();
	return 0;
}
```

---

## 作者：Merlin_Meow (赞：0)

## Analysis

注意到题目要求 $\min{a_i}$ 的最大值，套路二分转化为可行性问题。

我们显然需要按颜色讨论，不难发现最优情况是把所有瓶子里的水平分。于是我们对于每一种颜色计算出这个均值用来更新二分上界。~~然而直接从 `LLONG_MAX` 开始二分也不会怎么样。~~

考虑 `check` 函数的写法。我们模拟从前往后倒水的过程，记录一个变量 `cur` 表示前面所有瓶子可用的水量，如果用完了所有的水还不能使某一瓶水达到当前要求的值，那么表示无法满足条件，应该缩小答案，否则扩大答案。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define int long long

const int maxn = 100'000 + 10;

int n, k;
int a[maxn], tot[maxn], cnt[maxn];

bool check(int mid)
{
    for (int r = 0; r < k; r++)
    {
        int cur = 0;
        for (int i = r + 1; i <= n; i += k)
        {
            if (a[i] + cur < mid)
                return false;
            cur += a[i] - mid;
        }
    }
    return true;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    for (int i = 1; i <= n; i++)
    {
        int r = i % k;
        tot[r] += a[i];
        cnt[r]++;
    }
    int right = LLONG_MAX;
    for (int r = 0; r < k; r++)
        right = min(right, tot[r] / cnt[r]);
    int left = 0, ans = 0;
    while (left <= right)
    {
        int mid = left + (right - left) / 2;
        if (check(mid))
        {
            ans = mid;
            left = mid + 1;
        }
        else
            right = mid - 1;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：蒋淋雨 (赞：0)

# P12167 [蓝桥杯 2025 省 C/Python A] 倒水

## 题目分析

有一排水，其中前面的水可以向之后距离为 $k$ 的 水瓶里倒水，求水位最小值的最大。

求**最大值最小/最小值最大**，一般都是二分查找。

## 具体做法
我们将所有水杯按照距离为 $k$ 分成  $\lceil \frac{n}{k} \rceil$ 组，然后二分答案即可。

观察到值域为 $1\le n,a_i \le100000  $，$ 1 \le k \le n$。

时间复杂度 $O(n\log n)$ 可以通过本题。

## 代码
```cpp
#define rep(i,a,b) for(int i=a;i<=b;i++)
int a[100005],n,k;
bool check(int x){
    for(int i=1;i<=k;i++){
        int j=i;
        int yu=0;
        while(j<=n){
            if(a[j]>=x)yu+=a[j]-x;
            else yu-=(x-a[j]);
            if(yu<0){
                return false;
            }
            j+=k;
        }
    }
    return true;
}
void solve() {
    cin>>n>>k;
    rep(i,1,n)cin>>a[i];
    int l=1,r=100000;
    while(l<=r){
        int mid=(l+r)>>1;
        if(check(mid))l=mid+1;
        else r=mid-1;
    }
    cout<<l-1<<'\n';
}
```

---

## 作者：ylzpl (赞：0)

本题算法：二分。  
难度：橙。  
思路：
- 要使 $\min\{a_i\}$ 最小，那么我们可以考虑移多补少的性质。
- 我们考虑二分 $\min\{a_i\}$，我们设 $\min\{a_i\}$ 为 $x$。那么我们水的量也就是以 $x$ 作为基准。当 $a_i>x$，我们就把多的水弄出来。当 $a_i<x$ 时，我们就把多的水补给它。
- 注意：只有颜色属性相同才能补。所以，我们还要用桶的思想，把不同颜色多的水用不同颜色的桶来装。当不够补时，这个 $x$ 不成立。
- 要保证 $i<j$，那么这两个操作必须同时进行才能保证。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
int a[maxn];
int tong[maxn];
int n,k;
bool check(int x){
    memset(tong,0,sizeof(tong));
    for(int i=1;i<=n;i++){
        int t=i%k;
        if(a[i]>x){
            tong[t]+=a[i]-x;
        }
        if(a[i]<x){
            if(tong[t]<abs(a[i]-x)){
                return false;
            }
            else{
                tong[t]-=abs(a[i]-x);
            }
        }
    }
    return true;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
    int lt=-1,rt=1e9;
    int ans=0;
    while(lt+1<rt){
        int mid=(lt+rt)/2;
        if(check(mid)){
            ans=mid;
            lt=mid;
        }
        else{
            rt=mid;
        }
    }
    cout<<ans;
    return 0;
}
```

---


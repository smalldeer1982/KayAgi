# [蓝桥杯 2025 省 C/Python A/Java A] 拼好数

## 题目描述

我们将含有不少于 $6$ 个 $6$ 的数视为一个好数。例如 $666666$、$162636465666$ 是好数，$12366666$ 不是好数。

给定 $n$ 个正整数 $a_i$，你可以把这些数分成若干组拼起来，每组内的数可以按任意顺序拼，但一组最多只能有 $3$ 个数。求最多可以得到多少个好数。

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$1 \leq n \leq 20$；
- 对于所有评测用例，$1 \leq n \leq 1000$，$0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
3
66 66 66```

### 输出

```
1```

## 样例 #2

### 输入

```
7
666666 16166 6696 666 6 6 6```

### 输出

```
2```

# 题解

## 作者：minstdfx (赞：9)

## 闲话
这出题人是不是吃拼好饭吃的脑积水了想出来的这题
## 题解
首先注意到只和每个数的数码 $6$ 的个数有关。

然后注意到所有 $6$ 的个数不小于 $6$ 的数单成一组是不劣的。

接着注意到对 $5$ 拿尽可能小的数去组二元组是不劣的，因为 $5$ 只需要且总要和另一个数组。

接下来是 $1234$ 的情况，发现因为 $1$ 必然此时要和两个组，那么把 $1$ 打包去和 $4$ 按照 $5$ 的贪心去做也同理不劣（边界条件 $4+1+2$ 不优于 $4+2$）。

接下来对 $123$ 的情况，由于最多要三元组所以不能 $3+1+1+1$，首先 $3+2+1$ 不劣于 $3+2+2$，然后 $3+2+1$ 不劣于 $3+3$（因为 $1$ 没有 $2,3$ 就废了）。

对于只有 $23$ 的情况，有一个上界是 $(3c_3+2c_2)/6$，枚举两个 cnt 的余数发现是紧的。

否则 $1$ 是没有用的。

然后就做完了。

```c
a,b,c,d,e,f,g,d,_,*p;main(C){scanf("%*d");for(;~C;)(C=getchar())<48?(++*(&a+_),_=0):(_+=C==54&&_<6);for(p=&b;f>0;)_=1+(p==&f),(*p<_||(++g,--f,--*p)<_)&&++p;for(p=&b;e>0;)_=1+(p==&b||p==&e),(*p<_||(++g,p<&e&&--e,*p-=_)<_)&&++p;for(;b*d*c;--b,--d,--c)++g;printf("%d",g+(3*d+2*c)/6);}
```
什么，看不懂吗？

```cpp
int main()
{
	cin>>n;
	for(int i=1,a;i<=n;++i)
		cin>>a,c[count6(a)]+=1;
	int ans=c[6];
	int ptr=1;
	while(c[5]>0)
	{
		int cc=(ptr==5)+1;
		if(cc>c[ptr] || (++ans,c[5]-=1,c[ptr]-=1)<cc) ++ptr;
	}
	while(c[4]>0 && c[1]>1)
	{
		--c[4]; --c[1]; --c[1];
		++ans;
	}
	ptr=2;
	while(c[4]>0)
	{
		int cc=(ptr==4)+1;
		if(cc>c[ptr] || (++ans,c[4]-=1,c[ptr]-=1)<cc) ++ptr;
	}
	while(c[3] && c[2] && c[1])
	{
		--c[3]; --c[2]; --c[1];
		ans++;
	}
	ans+=(3*c[3]+2*c[2])/6;
}
```

---

## 作者：Maxsong (赞：1)

# P12168 [蓝桥杯 2025 省 C/Python A/Java A] 拼好数 题解

## 思路这一块

把所有数分成 $7$ 类，也就是 $0\sim 6$ 个 $6$ 的情况。其中 $6$ 个以上的 $6$ 也记作 $6$ 个。然后分类讨论。

### $6$ 个

不需要处理，它本身就是有效的。

### $5$ 个

易知与任意数结合形成二元组都是有效的，且优先用最小的 $6$ 个数的数。

### $4$ 个

先考虑 $4/1/1$ 这种，优先用最小的 $6$ 个数的数。然后考虑像 $5$ 个一样形成二元组。

### $3$ 个

先考虑 $3/2/1$，再考虑 $3/2/2$，对于二元组统一计算。

### $2$ 个和 $1$ 个

统一计算。

## 细节这一块

- 使用最小的 $6$ 个数的数最优，使用的越少越优。
- 统一计算：把所有的 $3$ 条件和 $2$ 条件的 $6$ 个数相加再除以 $6$ 向下取整。
- 形成二元组的运算中要注意：在两个 $5$ 的 $6$ 数或 $4$ 的 $6$ 数运算时一定要**特判**数量大于 $1$ 而不是大于 $0$。

## 代码这一块

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[7];
int pinhaofan(int x){
    int cnt=0;
    while(x>0){
        if(x%10==6) cnt++;
        x/=10;
    }if(cnt>6) cnt=6;
    return cnt;
}signed main(void){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int p;
        scanf("%d",&p);
        f[pinhaofan(p)]++;
    }int pnt=1;
    while(f[5]>0){
        if(int(pnt==5)>=f[pnt]) pnt++;
        f[6]++;
        f[5]--;
        f[pnt]--;
    }while(f[4]>0&&f[1]>1){
        f[4]--;
        f[1]-=2;
        f[6]++;
    }pnt=2;
    while(f[4]>0){
        if(int(pnt==4)>=f[pnt]) pnt++;
        f[6]++;
        f[4]--;
        f[pnt]--;
    }while(f[3]&&f[2]&&f[1]){
        f[3]--;
        f[2]--;
        f[1]--;
        f[6]++;
    }f[6]+=(3*f[3]+2*f[2])/6;
    printf("%d\n",f[6]);
    return 0;
}
```

> 我边吃拼好饭边写的。

---


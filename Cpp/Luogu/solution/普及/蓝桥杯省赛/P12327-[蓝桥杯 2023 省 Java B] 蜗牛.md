# [蓝桥杯 2023 省 Java B] 蜗牛

## 题目描述

这天，一只蜗牛来到了二维坐标系的原点。

在 $x$ 轴上长有 $n$ 根竹竿。它们平行于 $y$ 轴，底部纵坐标为 $0$，横坐标分别为 $x_1, x_2, \ldots, x_n$。竹竿的高度均为无限高，宽度可忽略。蜗牛想要从原点走到第 $n$ 个竹竿的底部也就是坐标 $(x_n, 0)$。它只能在 $x$ 轴上或者竹竿上爬行，在 $x$ 轴上爬行速度为 $1$ 单位每秒；由于受到引力影响，蜗牛在竹竿上向上和向下爬行的速度分别为 $0.7$ 单位每秒和 $1.3$ 单位每秒。

为了快速到达目的地，它施展了魔法，在第 $i$ 和 $i+1$ 根竹竿之间建立了传送门（$0 < i < n$），如果蜗牛位于第 $i$ 根竹竿的高度为 $a_i$ 的位置 $(x_i, a_i)$，就可以瞬间到达第 $i+1$ 根竹竿的高度为 $b_{i+1}$ 的位置 $(x_{i+1}, b_{i+1})$，请计算蜗牛最少需要多少秒才能到达目的地。

## 说明/提示

### 样例说明

蜗牛路线：$(0,0) \rightarrow (1,0) \rightarrow (1,1) \rightarrow (10,1) \rightarrow (10,0) \rightarrow (11,0)$，花费时间为 $1 + \frac{1}{0.7} + 0 + \frac{1}{1.3} + 1 \approx 4.20$

### 评测用例规模与约定

对于 $20\%$ 的数据，保证 $n \leq 15$；

对于 $100\%$ 的数据，保证 $1\leq n \leq 10^5$，$1\leq a_i, b_i \leq 10^4$，$1\leq x_i \leq 10^9$。

## 样例 #1

### 输入

```
3
1 10 11
1 1
2 1```

### 输出

```
4.20```

# 题解

## 作者：chenzefan (赞：3)

# 提供一篇 C++ 的题解。
[题目传送门](https://www.luogu.com.cn/problem/P12327)
## 涉及知识
- **动态规划基础与转移**。
## 思路分析
本人没有尝试暴力做法，用 dfs 暴力，应该可以拿点分。

来看正解，一眼题目用**动态规划**，因为容易发现，第 $i$ 根柱子的状态可以由第 $i-1$ 根柱子的状态进行转移。

**状态定义**——定义一个 `dp[N][2]`，`dp[i][0]` 表示不用传送门到达 $i$ 号柱子**底部**的时间，`dp[i][1]` 表示使用传送门到达 $i$ 号柱子**底部**的时间。

此部分代码：
```cpp
double dp[N][2];
```
**状态初始化**——因为求最小值 $\min$，所以初始值要赋极大值，本人赋值了 `0x3f`，可供参考。还有，因为原点到第1根柱子之间没有传送门，所以 `dp[1][0]` 和 `dp[1][1]` 也要初始化为 $x_1$。

此部分代码：
```cpp
memset(dp,0x3f,sizeof(dp)); 
dp[0][0]=0;
dp[1][0]=dp[1][1]=x[1];
```
**状态转移**——枚举每一个柱子：

- 如果不走传送门：用 `dp[i-1][0]` 和 `dp[i-1][1]` 的较小值 $\min$ 加上横坐标之差进行转移。
- 如果要走传送门：则要先减去传送门起点到底部所需时间，再加上使用传送门的时间，因为要更新到 $i$ 号柱子**底部**的最少时间，所以还要加上传送门终点到底部的时间。
  
此部分代码：

```cpp
for(int i=2;i<=n;i++){//按照题目描述计算时间
		//不用传送门（直接转移） 
		dp[i][0]=min(dp[i-1][1]+x[i]-x[i-1],dp[i-1][0]+x[i]-x[i-1]);
		//使用传送门
		double last=0;
		if(a[i-1]<b[i-2]) last=(b[i-2]-a[i-1])/1.3;
		else last=(a[i-1]-b[i-2])/0.7;
		dp[i][1]=min(dp[i-1][0]+a[i-1]/0.7+b[i-1]/1.3,dp[i-1][1]-b[i-2]/1.3+last+b[i-1]/1.3);
	}
```
最后求时间只需按照题目描述模拟即可。输出即求到达第 $n$ 根柱子的最小方案，也就是 `min(dp[n][0],dp[n][1])`。

此部分代码：
```cpp
printf("%.2lf",min(dp[n][0],dp[n][1]));//输出答案 
```
**注意: `dp` 数组类型为 `double`。输出要保留两位小数**

如果还没听懂请看代码。

## 代码（完整版）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,a[N],b[N],x[N];
double dp[N][2];//状态定义 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",x+i);
	for(int i=1;i<n;i++) scanf("%d%d",a+i,b+i);
	//状态初始化
	memset(dp,0x3f,sizeof(dp)); 
	dp[0][0]=0;
	dp[1][0]=dp[1][1]=x[1];
	//状态转移 
	for(int i=2;i<=n;i++){//按照题目描述计算时间
		//不用传送门（直接转移） 
		dp[i][0]=min(dp[i-1][1]+x[i]-x[i-1],dp[i-1][0]+x[i]-x[i-1]);
		//使用传送门
		double last=0;
		if(a[i-1]<b[i-2]) last=(b[i-2]-a[i-1])/1.3;
		else last=(a[i-1]-b[i-2])/0.7;
		dp[i][1]=min(dp[i-1][0]+a[i-1]/0.7+b[i-1]/1.3,dp[i-1][1]-b[i-2]/1.3+last+b[i-1]/1.3);
	}
	printf("%.2lf",min(dp[n][0],dp[n][1]));//输出答案 
	return 0; 
}
```

---

## 作者：JIN_LONG (赞：3)

## 思路：
这是一个很典型的动态规划题，我们可以在每个步骤中找到两种情况，一是走竹竿中的传送门，二是走前竹竿的底部。

- 先从 $2$ 地推到 $n$，并且定第一条竹竿的底坐标离原点的长度是 $x_1$，第一条竹竿的传送门离原点的长度是 $x_1+a_1$。
- 再计算上一个传送门的入口到现在这一个传送门的入口的距离，上一个传送门的入口到现在这一个竹竿的底部的距离，上一个竹竿的底部到这一个传送门的入口的距离，以及上一个竹竿的底部到这一个竹竿的底部的距离。
- 最后用计算出，第 $i$ 个竹竿的底部离原点的长度是，上一个竹竿的底部离原点长度，加上上一个竹竿的底部到现在这一个竹竿的底部的距离，与上一个竹竿的传送门入口离原点长度，加上传送门的入口到现在这一个竹竿的底部的距离的最小值。第 $i$ 个竹竿的传送门的状态转移方程同理。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
double b[100001],dp[3][100001];
struct kok{
	double x,y;
}a[100001];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n-1;i++){
		cin>>a[i].x>>a[i].y;
	}
	dp[2][1]=b[1],dp[1][1]=b[1]+a[1].x/0.7;
	for(int i=2;i<=n;i++){
		if(a[i].x>=a[i-1].y){
			double jeix_jeiy=min((a[i].x-a[i-1].y)/0.7,a[i-1].x/1.3+a[i].x/0.7+b[i]-b[i-1]);
			double jeix_by=min(a[i-1].y/1.3,a[i-1].x/1.3+b[i]-b[i-1]);
			double bx_jeiy=min(a[i-1].x/0.7+(a[i].x-a[i-1].y)/0.7,b[i]-b[i-1]+a[i].x/0.7);
			double bx_by=min(a[i-1].x/0.7+a[i-1].y/1.3,b[i]-b[i-1]);
			dp[1][i]=min(jeix_jeiy+dp[1][i-1],bx_jeiy+dp[2][i-1]);
			dp[2][i]=min(jeix_by+dp[1][i-1],bx_by+dp[2][i-1]);	
		}
		else {
			double jeix_jeiy=min((a[i-1].y-a[i].x)/1.3,a[i-1].x/1.3+a[i].x/0.7+b[i]-b[i-1]);
			double jeix_by=min(a[i-1].y/1.3,a[i-1].x/1.3+b[i]-b[i-1]);
			double bx_jeiy=min(a[i-1].x/0.7+(a[i-1].y-a[i].x)/1.3,b[i]-b[i-1]+a[i].x/0.7);
			double bx_by=min(a[i-1].x/0.7+a[i-1].y/1.3,b[i]-b[i-1]);
			dp[1][i]=min(jeix_jeiy+dp[1][i-1],bx_jeiy+dp[2][i-1]);
			dp[2][i]=min(jeix_by+dp[1][i-1],bx_by+dp[2][i-1]);	
		}
	}
	cout<<fixed<<setprecision(2)<<dp[2][n];
	return 0;
}
```

---

## 作者：Objective (赞：2)

## 思路与算法

### 题目分析

题目描述了一只蜗牛从二维坐标系的原点 $(0, 0)$ 出发，沿着 $x$ 轴或竹竿爬行，最终到达第 $n$ 根竹竿的底部 $(x_n, 0)$。

蜗牛在 $x$ 轴上的爬行速度为 $1$ 个单位每秒，在竹竿上向上和向下爬行的速度分别为 $0.7$ 个单位每秒和 $1.3$ 个单位每秒。

此外，蜗牛可以利用传送门在相邻竹竿之间快速移动。我们的任务是计算蜗牛到达目的地的最短时间。

### 解题思路

这道题目，我们可以通过动态规划来解决。

我们令这里有两组数 $dpg$，$dpp$。其中：

- $dpg_i$ 表示到达第 $i$ 根竹竿底部的最短时间；  
- $dpp_i$ 表示到达第 $i$ 根竹竿传送门起点 $(x_i, a_i)$ 的最短时间。

每次移动考虑两种选择：直接爬行或使用传送门。

我们发现，蜗牛到达第 $i$ 根竹竿底部有以下两种情况：

- 直接从第 $i-1$ 根竹竿底部沿 $x$ 轴爬过来；  
- 通过第 $i-1$ 根竹竿的传送门传送到第 $i$ 根竹竿的某个高度，再爬下来。

它们对应的式子就是：

- $dpg_{i-1} + (x_i - x_{i-1})$；  
- $dpp_{i-1} + b_i \div 1.3$。

同时，蜗牛到达第 $i$ 根竹竿传送门起点 $(x_i, a_i)$ 的最短时间也可以由两种方式得到：

- 从第 $i$ 根竹竿底部爬上来，  
- 从第 $i-1$ 根竹竿的传送门终点 $x_i, b_{i-1}$ 爬过来。

它们对应的式子就是：

- $dpg_i + a_i \div 0.7$；  
- 当 $b_{i-1} \ge a_i$ 时：  
  - $dpp_{i-1} + (b_{i-1} - a_i) \div 1.3$；  
- 当 $b_{i-1} < a_i$ 时：  
  - $dpp_{i-1} + (a_i - b_{i-1}) \div 0.7$。

具体细节如下：

1. **从地面到下一根竹竿的地面**：
    - 直接沿 $x$ 轴爬行。

2. **使用传送门**：
    - 从第 $i$ 根竹竿的传送门起点 $(x_i, a_i)$ 传送到第 $i+1$ 根竹竿的 $(x_{i+1}, b_{i+1})$。

3. **从地面爬到传送门起点**：
    - 从第 $i$ 根竹竿的地面爬到传送门起点 $(x_i, a_i)$。
    - 如果从第 $i-1$ 根竹竿的传送门终点 $(x_i, b_i)$ 爬到 $(x_i, a_i)$，时间取决于 $b_i$ 和 $a_i$ 的相对高度。


## 代码

这里我稍微做了一些**初始化**：

我将 $dpg_1$ 初始化为 $x_1$，表示从原点直接到达第一根竹竿底部的时间。

剩下的就好说啦！

### C++
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
int n;
int x[N];
double dpg[N];
double dpp[N];
int prev_b;     // 记录前一个传送门的b值
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &x[i]);

    // 初始化
    if (n >= 1) {
        dpg[1] = x[1];
    }
    for (int i = 1; i < n; i++) {
        int a, b;
        scanf("%d%d", &a, &b);

        // 计算到达当前传送门起点的最短时间
        double mint;
        if (i == 1) {
            // 第一次只能从地面爬上来
            mint = dpg[i] + a / 0.7;
        } else {
            // 两种选择：从地面爬上来 或 从前一个传送门过来
            double op1 = dpg[i] + a / 0.7;
            double op2 = dpp[i-1] + (prev_b >= a ? (prev_b-a)/1.3 : (a-prev_b)/0.7);
            mint = min(op1, op2);
        }
        dpp[i] = mint;
        prev_b = b;  // 保存当前b值供下次使用
        // 计算到达下一根竹竿底部的最短时间
        dpg[i+1] = min(dpg[i] + (x[i+1]-x[i]), dpp[i] + b/1.3);
    }
    // round()函数用于取四舍五入的整数值，这里保留两位小数，所以要先乘100
    printf("%.2lf", round(dpg[n] * 100) / 100.0);
    return 0;
}
```
### C#
```csharp
using System;

class Program
{
    const int N = 100005;
    static int n;
    static int[] x = new int[N];
    static double[] dpg = new double[N];
    static double[] dpp = new double[N];
    static int prev_b; // 记录前一个传送门的b值

    static void Main()
    {
        n = int.Parse(Console.ReadLine());
        string[] xInput = Console.ReadLine().Split();
        for (int i = 1; i <= n; i++)
            x[i] = int.Parse(xInput[i - 1]);

        // 初始化
        if (n >= 1)
        {
            dpg[1] = x[1];
        }
        for (int i = 1; i < n; i++)
        {
            string[] abInput = Console.ReadLine().Split();
            int a = int.Parse(abInput[0]);
            int b = int.Parse(abInput[1]);

            // 计算到达当前传送门起点的最短时间
            double mint;
            if (i == 1)
            {
                // 第一次只能从地面爬上来
                mint = dpg[i] + a / 0.7;
            }
            else
            {
                // 两种选择：从地面爬上来 或 从前一个传送门过来
                double op1 = dpg[i] + a / 0.7;
                double op2 = dpp[i - 1] + (prev_b >= a ? (prev_b - a) / 1.3 : (a - prev_b) / 0.7);
                mint = Math.Min(op1, op2);
            }
            dpp[i] = mint;
            prev_b = b; // 保存当前b值供下次使用

            // 计算到达下一根竹竿底部的最短时间
            dpg[i + 1] = Math.Min(dpg[i] + (x[i + 1] - x[i]), dpp[i] + b / 1.3);
        }
        // Math.Round()函数用于取四舍五入的值，这里保留两位小数
        Console.WriteLine($"{Math.Round(dpg[n], 2):F2}");
    }
}
```

### Java
```java
import java.util.Scanner;

public class Main {
    static final int N = 100005;
    static int n;
    static int[] x = new int[N];
    static double[] dpg = new double[N];
    static double[] dpp = new double[N];
    static int prev_b; // 记录前一个传送门的b值

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        n = scanner.nextInt();
        for (int i = 1; i <= n; i++) {
            x[i] = scanner.nextInt();
        }

        // 初始化
        if (n >= 1) {
            dpg[1] = x[1];
        }
        for (int i = 1; i < n; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();

            // 计算到达当前传送门起点的最短时间
            double mint;
            if (i == 1) {
                // 第一次只能从地面爬上来
                mint = dpg[i] + a / 0.7;
            } else {
                // 两种选择：从地面爬上来 或 从前一个传送门过来
                double op1 = dpg[i] + a / 0.7;
                double op2 = dpp[i - 1] + (prev_b >= a ? (prev_b - a) / 1.3 : (a - prev_b) / 0.7);
                mint = Math.min(op1, op2);
            }
            dpp[i] = mint;
            prev_b = b; // 保存当前b值供下次使用
            // 计算到达下一根竹竿底部的最短时间
            dpg[i + 1] = Math.min(dpg[i] + (x[i + 1] - x[i]), dpp[i] + b / 1.3);
        }
        // Math.round()函数用于取四舍五入的整数值，这里保留两位小数，所以要先乘100
        System.out.printf("%.2f", Math.round(dpg[n] * 100) / 100.0);
        scanner.close();
    }
}
```

---

## 作者：weapons (赞：2)

## 一篇 C++ 题解
### 题意
有若干柱子，在一根柱子上仅有一个传送点，可传送至下一根柱子上的到达点，求到达最后一根柱子底部的最小时间。
### 思路
既然求最小时间，考虑动规，设两个状态，分别表示是否用了传送门到达当前柱子的底部，还是直接走横轴。枚举柱子，如果不用传送门，则取到达上一根柱子底部是否使用传送门的最短时间，加上走横坐标之差的时间。如果使用传送门，则先减去走上一根柱子的到达点到底部的时间，毕竟我们动规的是到达柱子底部的最短时间，再加上走上一根柱子上的到达点与传送点之差的时间，加走当前柱子上的到达点到底部的时间。于是，此题就解决了。上代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[100000], b[1000000], x[1000000];//x[i]表示第i根柱子的横坐标。
double dp[1000000][2];//dp[i][0]代表不用传送门到达第i根柱子，dp[i][1]表示用传送门。
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> x[i];
	}
	for (int i = 1; i < n; i++) {
		cin >> a[i] >> b[i];
	}
	memset(dp, 0x3f, sizeof(dp));//求最小值，所以初始化
	dp[0][0] = 0;
	dp[1][0]=dp[1][1] = x[1];//原点到第1根柱子没有传送门，所以初始化。
	for (int i = 2; i <= n; i++) {
		double last=0;//last代表如果使用传送门，到达上一根柱子的传送点和到达点的距离所用的时间。
		if (a[i - 1] < b[i - 2]) {
			last = (b[i - 2] - a[i - 1]) / 1.3;
		} else {
			last = (a[i - 1] - b[i - 2]) / 0.7;
		}
		dp[i][0] = min(dp[i - 1][1] + x[i] - x[i - 1], dp[i - 1][0] + x[i] - x[i - 1]);//如果不用传送门
		dp[i][1] = min(dp[i - 1][0] + a[i - 1] / 0.7 + b[i-1] / 1.3, dp[i - 1][1] - b[i - 2] / 1.3 + last + b[i - 1] / 1.3);//如果用传送门
	}
	printf("%.2lf", min(dp[n][0],dp[n][1]));//输出最小值
}
```

---

## 作者：chenxinran12 (赞：0)

### 题目分析
蜗牛需要从原点移动到第 $n$ 根竹竿的底部。移动方式包括在 $x$ 轴上水平爬行（速度 $1$ 单位每秒），在竹竿上向上爬（速度 $0.7$ 单位每秒）和向下爬（速度 $1.3$ 单位每秒）。相邻竹竿间有传送门：从第 $i$ 根竹竿的高度 $a_i$ 可瞬间传送到第 $i+1$ 根竹竿的高度 $b_{i+1}$。
### 解题思路
$dp_{i,0}$ 为到达第 $i$ 根竹竿底部的最短时间。  
$dp_{i,1}$  为到达第i根竹竿传送门起点高度的最短时间。  
##### 状态转移：    
从第 $i-1$ 根竹竿底部沿 $x$ 轴爬行为 $dp_{i-1,0} + x_i - x_{i-1}$。  
从第$i-1$根竹竿传送门起点传送后向下爬为 $dp_{i-1,1} + \frac {b_i} {1.3}$。 
从当前竹竿底部向上爬为 $dp_{i,0} + \frac {a_i} {0.7}$。
##### 初始状态：  
$dp_{1,0}$ 为 $x_1$。  
$dp_{1,1}$ 为 $x_1 + \frac {a_1} {0.7}$。  

详见代码。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100010;
long long x[MAXN],A[MAXN],B[MAXN],n;
double dp[MAXN][2];
int main()
{
	cin>>n;
    for (int i = 1; i <= n; i++) cin>>x[i];
    if(n==1)
	{
        printf("%.2f\n",(double)(x[1]));
        return 0;
    }
    for (int i = 1; i <= n - 1; i++)
	{
        int a,b;
        cin>>a>>b;
        A[i]=a;
        B[i+1]=b;
    }
    dp[1][0] = (double)(x[1]);
    dp[1][1] = (double)(x[1]) + (double)(A[1]) / 0.7;
    for (int i = 2; i <= n; i++) {
        double dx = (double)(x[i] - x[i - 1]);
        double op1 = dp[i - 1][0] + dx;
        double op2 = dp[i - 1][1] + (double)(B[i]) / 1.3;
        dp[i][0] = min(op1, op2);

        if (i < n) {
            double op3 = dp[i][0] + (double)(A[i]) / 0.7;
            double qwq;
            if (B[i] >= A[i])
                qwq = (double)(B[i] - A[i]) / 1.3;
            else
                qwq = (double)(A[i] - B[i]) / 0.7;
            double op4 = dp[i - 1][1] + qwq;
            dp[i][1] = min(op3, op4);
        }
    }

    printf("%.2f\n", dp[n][0]);
    return 0;
}
```

---

## 作者：hhy11_ (赞：0)

# 思路
一道不难的动态规划题。从数据范围 $n \le 10^{5}$ 中可以看出本题需要 $O(n)$ 的算法。可以用 $dp_{i, 0}$ 表示在第 $i$ 根棍子底部，用 $dp_{i, 1}$ 表示在第 $i$ 根棍子上高度为 $a_{i}$ 的位置。用 $x_i$ 表示第 $i$ 根棍子的 $x$ 坐标，用 $mov(a, b)$ 表示在 $y$ 坐标上从 $a$ 移动到 $b$ 的时间，于是可得状态转移方程

$$
dp_{i, 0} = \min(dp_{i-1,0}+(x_i-x_{i-1}), dp_{i-1,1} + mov(b_{i-1}, 0))
$$

$$
dp_{i,1} = \min(dp_{i-1,0}+(x_i-x_{i-1})+mov(0,a_i), dp_{i,1}+mov(b_{i-1},a_i))
$$

并且提前处理出 $dp_{1, 0}$ 和 $dp_{1,1}$，最后输出的是

$$
\min(dp_{n,0}, dp_{n,1} + mov(b_{n-1},0))
$$

# Code:



```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N = 1e5 + 7;
long long read() {
	long long ans = 0;
	char c;
	while (1) {
		c = getchar();
		if (isdigit(c))break;
	}
	while (1) {
		ans *= 10;
		ans += c - '0';
		c = getchar();
		if (!isdigit(c))break;
	}
	return ans;
}
int n;
int x[N], a[N], b[N];
double dp[N][2];
double mov(int f, int t) {
	if (f > t)return (f - t) / 1.3;
	else return (t - f) / 0.7;
}
int main() {
	n = read();
	for (int i = 1; i <= n; i++) {
		x[i] = read();
	}
	for (int i = 1; i < n; i++) {
		a[i] = read();
        b[i] = read();
	}
	dp[1][0] = x[1];
	dp[1][1] = x[1] + a[1] / 0.7;
	for (int i = 2; i <= n; i++) {
		dp[i][0] = min(dp[i - 1][0] + x[i] - x[i - 1], dp[i - 1][1] + mov(b[i - 1], 0));
		dp[i][1] = min(dp[i - 1][0] + x[i] - x[i - 1] + mov(0, a[i]), dp[i - 1][1] + mov(b[i - 1], a[i]));
	}
	printf("%.2lf\n", min(dp[n][0], dp[n][1] + mov(b[n - 1], 0)));
	return 0;
}
```



拿下最优解，庆祝一下

[AC记录](https://www.luogu.com.cn/record/216642831)

---


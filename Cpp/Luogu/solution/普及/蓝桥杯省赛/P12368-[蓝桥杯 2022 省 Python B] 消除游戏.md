# [蓝桥杯 2022 省 Python B] 消除游戏

## 题目描述

在一个字符串 $S$ 中，如果 $S_i = S_{i-1}$ 且 $S_i \neq S_{i+1}$，则称 $S_i$ 和 $S_{i+1}$ 为边缘字符。如果 $S_i \neq S_{i-1}$ 且 $S_i = S_{i+1}$，则 $S_{i-1}$ 和 $S_i$ 也称为边缘字符。其它的字符都不是边缘字符。

对于一个给定的串 $S$，一次操作可以一次性删除该串中的所有边缘字符（操作后可能产生新的边缘字符）。

请问经过 $2^{64}$ 次操作后，字符串 $S$ 变成了怎样的字符串，如果结果为空则输出 EMPTY。

## 说明/提示

### 评测用例规模与约定

- 对于 $25\%$ 的评测用例, $|S| \leq 10^3$，其中 $|S|$ 表示 $S$ 的长度；
- 对于 $50\%$ 的评测用例, $|S| \leq 10^4$；
- 对于 $75\%$ 的评测用例, $|S| \leq 10^5$；
- 对于所有评测用例, $|S| \leq 10^6$，$S$ 中仅含小写字母。

## 样例 #1

### 输入

```
edda```

### 输出

```
EMPTY```

## 样例 #2

### 输入

```
sdfhhhhcvhhxcxnnnnshh```

### 输出

```
s```

# 题解

## 作者：海洋守卫者 (赞：4)

# [P12368](https://www.luogu.com.cn/problem/P12368) [蓝桥杯 2022 省 Python B] 消除游戏

## 解题思路
将连续的相同字符看作一个整体，用链表维护，不断操作至结果不改变为止。思路很简单，主要考察的是对链表的操作。

## 完整代码
### C++：
~~代码写得有些繁琐，但思路是正确的。~~
```cpp
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<iterator>
#include<list>
#include<map>
using namespace std;
const int MAXN=1e6+7;
char S[MAXN];
typedef pair<char,int> P;
int n;
list<P>l;
list<P>::iterator it,p,q;
int main()
{
	scanf("%s",S+1);
	n=strlen(S+1);
	for(int i=1;S[i];i++)if(S[i]==S[i-1])(--l.end())->second++;
	else l.push_back(P(S[i],1));
	bool changed=1;
	while(changed)
	{
		changed=0;
		bool bp=0;
		for(it=l.begin();it!=l.end();){    //删除该串中的所有边缘字符
			if(it!=--l.end())
			{
				if((it->second==1&&bp)||it->second>1||next(it)->second>1){
					it->second--;
					(++it)->second--;
					changed=1;
					bp=1;
				}
				else ++it,bp=0;
			}
			else break;
		}
		for(it=l.begin();it!=l.end();++it)    //去掉已经被完全删除的字符（串）
		{
			if(it->second<=0)
			{
				it=l.erase(it);
				--it;
			}
		}
		for(it=l.begin();it!=l.end();){    //将链表上相同且连续的单位合并
			if(it!=--l.end())
			{
				p=it,q=++it;
				if(p->first==q->first)
				{
					p->second+=q->second;
					l.erase(q);
					it=p;
				}
			}
			else break;
		}
	}
	if(l.size()==0)puts("EMPTY");
	else for(it=l.begin();it!=l.end();++it)for(int i=1;i<=it->second;i++)putchar(it->first);
	return 0;
}
```
### Python：
~~基于 Python 本身的优秀性能。~~

我们可以用其强大的功能来完成代码。
```py
s=list(str(input()))
f=[False for i in range(len(s))]
while True:
	n=len(s)
	change=False
	for i in range(1,n-1):
		if s[i]==s[i-1] and s[i]!=s[i+1]:
			f[i]=True
			f[i+1]=True
		if s[i]!=s[i-1] and s[i]==s[i+1]:
			f[i-1]=True
			f[i]=True
	for i in range(n):
		if f[i]:
			f[i]=False
			s[i]=''
			change=True
	s=list(''.join(s))
	if not change:
		break
if len(s)==0:
	print('EMPTY')
else:
	print(''.join(s))
```

---

## 作者：ZY_king_YB (赞：1)

[传送门](https://www.luogu.com.cn/problem/P12368)

### -1.前置

知识点：链表（`list`）。

我们可以设将原字符串 $S$ 分为 $n$ 个子段 $s_1,s_2,...,s_n$，每个子段都为相同的字符。比如：$S=$`abchhhnnnnss`，此时 $n=6$，$s_1=$ `a`，$s_2=$`b`，$s_3=$`c`，$s_4=$`hhh`，$s_5=$`nnnn`，$s_6=$`ss`。

再设 $k=\bar{|s_i|}$。

### 0.基础骗分

`cout << "EMPTY";`

~~这不用讲了吧。~~

~~虽然比赛时对非捆绑多测的题是挺好用的。~~

期望得分：5。

### 1.暴力模拟

时间复杂度：一次修改为 $O(nk)$，修改次数为 $k$ 次。总复杂度 $O(nk^2)$。

那么你就会喜提一个大大的——

![](https://cdn.luogu.com.cn/upload/image_hosting/ioy51rcd.png)

期望得分：15~30。

### 2.AC 做法

考虑优化。

设子段的字符为 $c$，长度为 $l$，则将该子段表示为 $(c,l)$。

比如：还是 $S=$`abchhhnnnnss`，就可以表示为 $(a,1)(b,1)(c,1)(h,3)(n,4)(s,2)$。

每次操作时：

- 设当前子段 $s_i=(c_i,l_i)$。

- $l_{i-1}>1\lor l_i>1\Rightarrow s_i$ 的左端点为边缘字符；$l_{i+1}>1\lor l_i>1\Rightarrow s_i$ 的右端点为边缘字符。

- 操作后，子段变为 $(c_i,l_i-[l_{i-1}>1\lor l_i>1]-[l_{i+1}>1\lor l_i>1])$。

- 若 $l_i\le0$，删除该子段。

一次操作的时间复杂度为 $O(n)$，共 $k$ 次操作，总时间复杂度为 $O(nk)=O(|S|)$，在 $|S|\le10^6$ 时能稳定 AC。

思路已经讲得很清楚了，代码就不附了。

---

## 作者：Sliarae (赞：1)

如果直接模拟题目中的过程，时间复杂度为 $O(n^2)$（$n = |S|$），肯定是不行的。需要进行优化。

我们称一个字符串是**一类连续段**，当且仅当任意两个相邻字符不相同，比如 $\texttt{sdf}$。称一个字符串是**二类连续段**，当且仅当它由至少两个相同字符构成，如 $\texttt{hhhh}$。

我们将字符串 $S$ 划分为若干极长（一类/二类）连续段。比如将 $\texttt{sdfhhhhcvhhxcxnnnnshh}$ 划分为 $\{\texttt{sdf, hhhh, cv, hh, xcx, nnnn, s, hh}\}$。

此时一个字符是**边缘字符**（题目中的定义），当且仅当它位于两个连续段交界处，于是一次操作相当于对于每个连续段，删除它的开头和结尾字符（第一个连续段不要删开头，最后一个连续段不要删结尾）。

设连续段个数为 $c$，显然这样删一次，花费的时间为 $O(c)$，且在字符串 $S$ 中，删去了 $2c - 2$ 个字符，看上去复杂度就对了。但是，我们还需要在删除字符后维护连续段发生的变化。

首先去掉长度为 $0$ 的连续段，将长为 $1$ 的二类段改为一类。然后相当于要对若干连续段进行拼接。两个连续段拼接时，首先修改一下开头和结尾的 $O(1)$ 个元素，如果是两个字符相同的二类段拼接，或者两个一类段拼接时两段会合并成一段，这时用启发式合并 deque 即可（简单说就是将长度小的合并到长度大的，时间复杂度为均摊的 $O(n \log n)$）。

总时间复杂度 $O(n \log n)$，瓶颈在于启发式合并 deque。代码实现有一定细节。

```cpp
#include <iostream>
#include <list>
#include <vector>
#include <numeric>

using namespace std;

const int kN = 2e6 + 5; 

int n;
int type[kN];
list<char> ls[kN];

void Join (int i, int j) {
  if (ls[i].size() > ls[j].size()) {
    for (auto c : ls[j]) ls[i].push_back(c);
  }
  else {
    for (auto it = ls[i].rbegin(); it != ls[i].rend(); ++it) ls[j].push_front(*it);
    swap(ls[i], ls[j]);
  }
}

int main () {
  cin.tie(0)->sync_with_stdio(0);
  for (char c; cin >> c; ) {
    if (!n || type[n] == 2 && c != ls[n].back()) {
      ++n;  
      type[n] = 1;
      ls[n].push_back(c);
    }
    else if (type[n] == 1 && c == ls[n].back() && ls[n].size() >= 2) {
      ls[n].pop_back();
      ++n;
      type[n] = 2;
      ls[n].push_back(c), ls[n].push_back(c);
    }
    else {
      if (c == ls[n].back()) type[n] = 2;
      ls[n].push_back(c);
    }
  }
  vector<int> vec(n);
  iota(vec.begin(), vec.end(), 1);
  while (true) {
    if (vec.size() <= 1) break;
    vector<int> new_vec;
    for (int id = 0; id < vec.size(); ++id) {
      int i = vec[id];
      if (id != 0) ls[i].pop_front();
      if (id != vec.size() - 1 && !ls[i].empty()) ls[i].pop_back();
      if (!ls[i].empty()) {
        new_vec.push_back(i);
        if (ls[i].size() == 1) type[i] = 1; 
      }
    }
    vector<int>().swap(vec);
    for (auto i : new_vec) {
      if (vec.empty()) {
        vec.push_back(i);
        continue;
      }
      int j = vec.back();
      if (type[i] == 2) {
        if (type[j] == 2) {
          if (ls[i].back() == ls[j].back()) {
            Join(j, i);
          }
          else {
            vec.push_back(i);
          }
        }
        else {
          if (ls[j].back() == ls[i].back()) {
            ls[j].pop_back();
            ls[i].push_front(ls[i].back());
            if (ls[j].empty()) vec.pop_back();
          }
          vec.push_back(i);
        }
      }
      else {
        if (type[j] == 2) {
          if (ls[i].front() == ls[j].back()) {
            ls[j].push_back(ls[i].front());
            ls[i].pop_front();
          }
          if (!ls[i].empty()) vec.push_back(i);
        }
        else {
          if (ls[i].front() != ls[j].back()) {
            Join(j, i);
          }
          else {
            ++n;
            type[n] = 2;
            ls[n].push_back(ls[j].back()), ls[n].push_back(ls[i].front());
            ls[i].pop_front(), ls[j].pop_back();
            if (ls[j].empty()) vec.pop_back();
            vec.push_back(n);
            if (!ls[i].empty()) vec.push_back(i);
          }
        }
      }
    } 
  }
  if (vec.empty()) {
    cout << "EMPTY"; 
  }
  else {
    for (auto i : vec) {
      for (auto c : ls[i]) cout << c;
    }
  }
  cout << '\n';
  return 0; 
}
```

---

## 作者：Nazq (赞：0)

每个极长相同字符的段为一段。设有 $c$ 个字符段，每个字符段平均长度为 $k$。

若暴力模拟，一次时间复杂度为 $O(ck)$，一共有 $k$ 次，总复杂度为 $O(ck^2)$。

$s$ 表示每段的字符，$c$ 表示每段的大小，用 $(s, c)$ 这样的二元组表示。\
$\text{edda}$ 表示为 $(e, 1), (d, 2), (a, 1)$。

每次操作如下。\
设当前二元组为 $(s_i,c_i)$。\
若 $c_{i-1}\gt 1 \vee c_i\gt 1$，则 $i$ 的左端点是边缘字符。若 $c_{i+1}\gt 1 \vee c_i\gt 1$，则 $i$ 的右端点是边缘字符。\
在下一次，二元组就变为 $(s_i, c_i - [c_{i-1}\gt 1 \vee c_i\gt 1] - [c_{i+1}\gt 1 \vee c_i\gt 1])$。当 $c_i\le 0$ 删除该二元组。

每次模拟是 $O(c)$ 的，总复杂度为 $O(ck) = O(n)$。

---


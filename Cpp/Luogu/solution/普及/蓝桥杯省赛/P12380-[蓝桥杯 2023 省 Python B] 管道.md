# [蓝桥杯 2023 省 Python B] 管道

## 题目描述

有一根长度为 $len$ 的横向的管道，该管道按照单位长度分为 $len$ 段，每一段的中央有一个可开关的阀门和一个检测水流的传感器。

一开始管道是空的，位于 $L_i$ 的阀门会在 $S_i$ 时刻打开，并不断让水流入管道。

对于位于 $L_i$ 的阀门，它流入的水在 $T_i (T_i \geq S_i)$ 时刻会使得从第 $L_i - (T_i - S_i)$ 段到第 $L_i + (T_i - S_i)$ 段的传感器检测到水流。

求管道中每一段中间的传感器都检测到有水流的最早时间。

## 说明/提示

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$n \leq 200$，$S_i, len \leq 3000$；
- 对于 $70\%$ 的评测用例，$n \leq 5000$，$S_i, len \leq 10^5$；
- 对于所有评测用例，$1 \leq n \leq 10^5$，$1 \leq S_i, len \leq 10^9$，$1 \leq L_i \leq len$，$L_{i-1} < L_i$。

## 样例 #1

### 输入

```
3 10
1 1
6 5
10 2```

### 输出

```
5```

# 题解

## 作者：hhy11_ (赞：3)

# P12380 管道题解

# 题意简介

有一个长为 $len$ 的管道，有 $n$ 段上面有一个阀门，位于 $L_i$，可以在 $S_i$ 时打开。求水填满管道的时间。

# 思路

因为 $len$ 很大，考虑二分。每次二分都检查是否可以填满水管，时间复杂度为 $O(n)$，合起来是 $O(n\log len)$，可以通过本题。每次检查都设置一个变量 $lp$，用于统计水从左边开始能流到的位置。如果第 $i$ 个阀门流的水可以流到 $lp$ 这个位置，那么将 $lp$ 设为水流到的最右端。

# 代码


```cpp
#include<iostream>
#include<vector>
using namespace std;
typedef long long ll;
const int N = 1e5 + 7;
int n, len, ans = 2e9 + 1;
int L[N], S[N];
//二分 
void solve() {
	ll l = 1, r = 2e9 + 1;
	while (l < r) {
		ll mid = (l + r) >> 1;
		//检查 
		ll lp = 0;
		for (int i = 1; i <= n; i++) {
			if (S[i] <= mid) {
				if (lp >= L[i] - (mid - S[i]) - 1) {
					lp = max(lp, L[i] + (mid - S[i]));
				}
			}
			if (lp >= len)break;
		}
		if (lp < len)l = mid + 1;
		else r = mid;
	}
	ans = l;
}
int main() {
	cin >> n >> len;
	for (int i = 1; i <= n; i++) {
		cin >> L[i] >> S[i];
	}
	solve();
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：JIN_LONG (赞：3)

## 思路：
这题的思路是用二分答案来猜时间，在输出得到的答案即可，以下是集体步骤。

- 首先输入，然后进入二分的循环中。
- 接着就是最重要的检查函数了，在检查函数中枚举 $1$ 到 $n$，计算水流流经范围，然后给流经的范围做上标记，检查是否全部的传感器是否有水流经过。
## 代码：
给流经的范围做上标记其实是个难点，以下是 $75$ 分代码，使用的是桶来计数和前缀和，但因为 $len$ 的取值是 $10^9$，所以爆数组了。

```
#include <bits/stdc++.h>
using namespace std;
long long n,len;
struct kok{
	long long L,S;
}a[100002];
int cmp(kok x,kok y){
	return x.S<y.S;
}
int check(long long mid){
	int tong[100002];
	for(int i=0;i<=len;i++){
		tong[i]=0;
	}
	for(int i=1;i<=n;i++){
		if(a[i].S<=mid){
			int l=a[i].L-(mid-a[i].S);
			int r=a[i].L+(mid-a[i].S);
			//cout<<mid<<" "<<l<<" "<<r<<endl;
			if(l<0)l=0;
			if(r>len)r=len;
			tong[l]++;
			tong[r+1]--;
		}
		else break;
	}
	for(int i=1;i<=len;i++){
		tong[i]+=tong[i-1];
	}
	int q=1;
	for(int i=1;i<=len;i++){
		if(tong[i]==0)q=0;
	}
	return q;
}
int main(){
	cin>>n>>len;
	for(int i=1;i<=n;i++){
		cin>>a[i].L>>a[i].S;
	}
	sort(a+1,a+1+n,cmp);
	long long l=0,r=1000000000;
	while(l+1<r){
		long long mid=(l+r)/2;
		if(check(mid)){
			r=mid;
		}
		else {
			l=mid;
		}
		//cout<<l<<" "<<r<<endl;
	}
	cout<<r;
	return 0;
}
```
正确代码要把桶来计数和前缀和改成下面一小段代码来计算检测到水流的传感器的数量。

```
    sort(b.begin(),b.end());
    int ans=0;
    for(auto p: b){
        int l=p.x,r=p.y;
        if(ans+1<l)
            return false;
        ans=max(ans,r);
    }
    return ans>=m;
```
以下是 $python$ 代码。
```python
def s():
    import sys
    i=sys.stdin.read
    d=i().split()
    x=0
    n,l=int(d[x]),int(d[x + 1])
    x+=2
    v=[]
    for _ in range(n):
        L, S = int(d[x]), int(d[x + 1])
        v.append((L, S))
        x += 2
    
    a = 0
    b = 2 * 10**18
    
    def c(t):
        r = []
        for L, S in v:
            if t >= S:
                d = t - S
                a = L - d
                b = L + d
                a = max(1, a)
                b = min(l, b)
                if a <= b:
                    r.append((a, b))
        if not r:
            return False
        r.sort()
        k = 0
        for a, b in r:
            if a > k + 1:
                return False
            k = max(k, b)
            if k >= l:
                return True
        return k >= l
    
    ans = b
    while a <= b:
        m = (a + b) // 2
        if c(m):
            ans = m
            b = m - 1
        else:
            a = m + 1
    print(ans)

s()
```

---

## 作者：Aliadgnus (赞：3)

## 解题思路
题意不用多说，根据题意的话，假如说在 $t_i$ 时刻满足题目要求，那么比 $t_i$ 大的时刻也一定满足要求，所以具有单调性，此时可以想到用二分来做。

对于每个二分出来的时刻，可以将每一个水阀所能检测的范围算出来（若 $t_i$ 时刻小于当前水阀打开的时刻，则该水阀跳过）。

此时问题就变成了这些所检测出来的范围是否能覆盖整个管道，这是一个区间合并。将所有区间合并之后，再看看该区间是否能覆盖 $1$ 到 $len$ 的位置即可。

当然，区间合并就直接将每一个左端点进行排序就行。

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long 
#define maxn 1000005
#define maxa 1005
#define repr(i,a,b) for(int i = a;i <= b;i++)
#define PII pair<int,int>
//typedef long long ll;
struct node{
    int L,S;
};
int n,len;
vector<node> v;
bool check(int T){
    vector<PII> v1;
    for(auto &wei:v){
        if(wei.S>T) continue;
        int d = T-wei.S;
        int a = wei.L-d;
        int b = wei.L+d;
        a = max(a,1);
        b = min(b,len);
        if(a>b) continue; 
        v1.emplace_back(a,b);
    }
    sort(v1.begin(),v1.end());
    int ans = 0;
    for(auto &p : v1){
        int a = p.first,b = p.second;
        if(a>ans+1){
            return false;
        }
        ans = max(ans,b);
    }
    return ans>=len;
}
signed main(){
    cin.tie(0)->ios::sync_with_stdio(0);
    cout.tie(0);
    cin>>n>>len;
    v.resize(n);
    repr(i,0,n-1){
        cin>>v[i].L>>v[i].S;
    }
    int l=0,r=0;
    for(auto &value:v){
        r = max(r,value.S+max(value.L-1,len-value.L));
    }
    int ans = r;
    while(l<=r){
        int mid = (l+r)>>1;
        if(check(mid)){
            ans = mid;
            r = mid-1;
        } 
		else{
            l = mid+1;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Hy13_xsm (赞：2)

## 形式化题意

有 $1\times len$ 个格子，有 $n$ 个阀门，分别在第 $L_i$ 个格子中心，每个阀门会在 $S_i$ 秒时打开，并且每秒往左右分别扩散一格水，问多长时间后 $len$ 个格子能被全部覆盖。

## Solution

观察到数据范围，$1\le L_i \le 10^9$，也就是说覆盖完的时间 $t$ 大概最多就只有这么多。不难想到，当 $t$ 到一个临界值，就代表水已经全部覆盖，那么再往后的 $t$ 都能够使水完全覆盖管道，于是就能够想到二分答案 $t$ 的值，最后找到最小满足条件的 $t$，这就是我们的任务。

接下来讲如何快速判断时间 $t$ 时水是否能完全覆盖。首先可以求出每个阀门覆盖水的区间，题目已经给出了，即 $[L_i-t+S_i,L_i+t-S_i]$。然后将结构体数组按照左端点的大小排序，如果出现一个左端点不在上一个右端点的后一个以内，那管道一定是不能完全覆盖的。反之，如果判断到最后没有找到缺口，那么就说明此时的 $t$ 符合条件。

## 参考代码


```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
using namespace std;
int n,len,l[N],s[N],L=1,R=1e9;
struct node{
	int l,r;
}a[N];
int cmp(node p,node q)
{
	return p.l<q.l;
}
int check(int t)
{
	int tmp=1,cnt=0;
	for(int i=1;i<=n;i++)
	{
		if(s[i]<=t)
		{
			cnt++;
			a[cnt].l=l[i]-t+s[i];
			a[cnt].r=l[i]+t-s[i];
		}
	}
	sort(a+1,a+cnt+1,cmp);
	for(int i=1;i<=cnt;i++)
	{
		if(a[i].l>tmp)return 0;
		tmp=max(tmp,a[i].r+1);
	}
	return tmp>len;
}
signed main()
{
	cin>>n>>len;
	for(int i=1;i<=n;i++)
	cin>>l[i]>>s[i];
	while(L<R)
	{
		int mid=(L+R)>>1;
		if(check(mid))R=mid;
		else L=mid+1;
	}//二分答案
	cout<<L;
	return 0;
}
```

---

## 作者：Bill_luogu (赞：2)

## 题目思路：
由于 $len$ 比较大，所以考虑二分。

发现当 $T_{i}$ 可行时， $T_{i}+1$ 必定可行。题目要求我们把 $T_{i}$ 的最大值尽可能小化，于是想到二分模型 $(l,r]$ （ $l$ 不取， $r$ 取）。

接下来写 check 函数，枚举每个阀门，用 $maxr$ 记录当前水流最多流到的位置，当 $L_{i}-(x-S_{i})-1\le maxr$ 时，表示能跟之前的阀门接上，于是更新 $maxr=\max(L_{i}+(x-S_{i}),maxr)$ ，最后判断 $maxr\ge len$ 。二分完后，输出 $r$ 。（因为我们的模型是左闭右开的，所以输出 $r$ ）。
## AC Code：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,len;
int l=0,r=1e9,mid;
struct node
{
	int l,s;
}a[100010];
bool cmp(node x,node y)
{
	return x.l<y.l;
}
bool check(int x)
{
	int maxr=0;
	for(int i=1;i<=n;i++)
		if(x>=a[i].s)
			if(a[i].l-(x-a[i].s)-1<=maxr)
				maxr=max(maxr,a[i].l+(x-a[i].s));//能接上，更新 maxr
	return maxr>=len;
} 
int main()
{
	cin>>n>>len;
	for(int i=1;i<=n;i++)
		cin>>a[i].l>>a[i].s;
	sort(a+1,a+1+n,cmp);
	while(r-l>1)
	{
		mid=(l+r)>>1;
		if(check(mid))
			r=mid;//右端点不取
		else
			l=mid;//左端点不取
	}
	cout<<r;//注意！！！输出是 r
	return 0;
} 
```

---

## 作者：jur10n (赞：1)

## 简单思路

二分答案基础题，直接二分枚举最短的时间。

然后进行检验：直接让所有水龙头放水，看看是否满足淹没了整个管道。

如果满足，继续找更小的解；反之往大找可行解。

## 代码实现

注意检验部分有一处细节，当前水龙头的范围更大才更新最远点，要取新范围和历史最远的较大值。


```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;

class Quick_IO
{
  public:
	template<typename T>
	void read(T &r)
	{
		T x = 0, f = 1;
		char ch = getchar();
		while (ch < '0' || ch > '9')
		{
			if (ch == '-') f = -1;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
		r = x * f;
	}
	template<typename T, typename... Args>
	void read(T &tmp, Args &... tmps)
	{
		read(tmp);
		read(tmps...);
	}
} io;

int n, len;
int l[N], s[N];

bool Judge(int aim)	//检验
{
	int far = 0;
	for (int i = 1, z, y; i <= n; i++)
	{
		if (aim < s[i]) continue;
		z = l[i] - (aim - s[i]);
		y = l[i] + (aim - s[i]);
		if (z - 1 <= far) far = max(y, far); //注意这里需要比较一下
	}
	return far >= len;
}

signed main()
{
	io.read(n, len);
	for (int i = 1; i <= n; i++) io.read(l[i], s[i]);

	int L = 1, R = 1e9, mid = 0, ans = 1e9;
	while (L <= R)	//二分答案
	{
		mid = L + (R - L) / 2;
		if (Judge(mid)) ans = mid, R = mid - 1;
		else L = mid + 1;
	}
	cout << ans;
}

```

---

## 作者：guoshengyu1231 (赞：1)

本题解前置知识：[二分答案](https://blog.csdn.net/weixin_44179892/article/details/104197011)。
# 思路
考虑到答案具备单调性，所以考虑二分答案。 $\\$ 
那具体怎么做呢？ $\\$ 
首先，题目要我们求管道中每一段中间的传感器都检测到有水流的最早时间。那我们就二分答案管道中每一段中间的传感器都检测到有水流的最早时间，这是显而易见的。那我们知道了究竟如何二分答案，接下来我们就应该去设计 $\operatorname{check}$ 函数了。 $\\$ 

设 $\operatorname{check(x)}$ 用来判断当水流了 $x$ 个时间单位后是否能让每一段中间的传感器都检测到有水流。换句话说，当水流了 $x$ 个时间单位后，每个阀门都会让一个区间的传感器检测到水流。而我们要判断的是，这些区间是否能覆盖区间 $[1,len]$。那这下就简单多了，所以我直接写流程。
# 具体流程
我们可以先设一个变量 $p$ 来表示区间 $[1,p]$ 已经均被覆盖。那对于第 $i$ 个阀门，如果当前的 $x>s_i$，那么则计算出 $l$ 和 $r$ 表示第 $i$ 个阀门能覆盖的区间。 $\\$ 
此时，如果 $l-1\le p$，说明这段区间和之前的区间是可以连接上的，此时更新 $p\gets \max(p,r)$。 $\\$ 
最后，我们只需要判断是否 $p\ge len$ 就行啦！
# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1e5+5;
int n,len,d[maxn],s[maxn];
bool check(int x)
{
	int p=0;
	for(int i=1;i<=n;i++)
	 if(x>=s[i])
	  {
	  	if(p>=len) return true;
	  	int l=d[i]-(x-s[i]);
	  	int r=d[i]+(x-s[i]);
	  	if(l-1<=p) p=max(p,r);
	  }
	if(p>=len) return true;
	return false;
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>len;
	for(int i=1;i<=n;i++) cin>>d[i]>>s[i];
	int l=1,r=2e9;
	while(l<r)
	 {
	 	int mid=l+r>>1;
	 	if(check(mid)) r=mid;
	 	else l=mid+1; 
	 }
	cout<<l;
	return 0;
}
```

---

## 作者：Epitome (赞：1)

## 题意

求出一个时刻 $t$ 并使得让满足 $t \geq s_i$ 的区间 $(l_i - (t - s_i), l_i + (t - s_i))$ 覆盖 $1, 2, \dots, len$，并最小化 $t$。

## 解法

对于一个 $t$，如果 $t$ 可以使条件成立，$t + 1$ 必定可以，有单调性。

二分 $t$，然后对于 $mid$ 求出每个满足 $mid \geq s_i$ 的区间 $(l, r)$ 按左端点排序，然后定义 $last$ 表示前面所有区间的右端点最大值，如果有区间满足了 $r > last + 1$，那么这个 $mid$ 不成立，否则成立。

## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
using pii = pair<int, int>;

const int N = 1e5 + 5;

struct RBD {
  int l, s;
} r[N];

int n, len, dif[N];

bool check( int x ) {
  vector<pii> s;
  for (int i = 1; i <= n; ++i) {
    if (x >= r[i].s) {
      s.push_back(make_pair(r[i].l - (x - r[i].s), r[i].l + (x - r[i].s)));
    }
  }
  sort (s.begin(), s.end());
  int last = 0;
  for (auto i : s) {
    if (i.first > last + 1) {
      return 0;
    }
    last = max(last, i.second);
  }
  return last >= len;
}

int main() {
  ios :: sync_with_stdio(0), cin.tie(0);
  cin >> n >> len;
  for (int i = 1; i <= n; ++i) {
    cin >> r[i].l >> r[i].s;
  }
  int l = 1, r = 2e9 + 1;
  while (l < r) {
    int mid = l + r >> 1;
    if (check(mid)) {
      r = mid;
    } else {
      l = mid + 1;
    }
  }
  return cout << l, 0;
}
```

---

## 作者：Tongyx666 (赞：0)

# 题意
### [题目传送门](https://www.luogu.com.cn/problem/P12380)
有一根长度为 $len$ 的横向管道，分 $len$ 段，每段中央有阀门和传感器。给定 $n$ 个阀门的位置 $Li$ 和打开时刻 $Si$，阀门打开后，其水流在 $Ti$ 时刻覆盖从 $Li-(Ti-Si)$ 到 $Li+(Ti-Si)$ 的区间。求管道中每段传感器都检测到水流的最早时间，即所有位置被覆盖的最早时间中的最大值。输入保证阀门位置递增，需处理各区间覆盖时间并取全局最大值。

**********总而言之**********，就是求管道各段传感器均检测到水流的最早时间。

# 思路
每个阀门在 $Si$ 时刻打开后，水流覆盖范围随时间 $t$ 增长为 $[Li - (t-Si), Li + (t-Si)]$。
需要找到最小的时间 $T$，使得所有位置 $x∈[1,len]$ 都被至少一个阀门在 $T$ 时刻的覆盖范围内。

每个阀门的覆盖范围随时间呈线性扩展，覆盖时间 $t$ 与位置 $x$ 的关系为：

- 左侧阀门覆盖 $x$ 的条件：$Li + (t - Si) ≥ x ⇒ t ≥ x - Li + Si$；

- 右侧阀门覆盖 $x$ 的条件：$Li - (t - Si) ≤ x ⇒ t ≥ Li - x + Si$。


对每个位置 $x$，其被覆盖的最早时间是所有可能覆盖它的阀门的时间上限中的最小值。

这道题可以转换成[区间覆盖问题](https://blog.csdn.net/yl_puyu/article/details/109682733)，一个水阀在 $mid$ 时间内能将水流到的左右端点形成了一个区间，左右端点的公式如下：

- $l=V[i]-(mid-T[i])$。左端点 $=$ 阀门位置 $-$ 打开后的持续时间
- $r=V[i]+(mid-T[i])$。右端点 $=$ 阀门位置 $+$ 打开后的持续时间

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long//将所有int类型转换为long long，避免整数溢出（注意：主函数需改为signed main）
using namespace std;
using namespace std;
const int maxn=100005;
//定义结构体存储每个阀门在某个时间点的覆盖区间
struct Flag{
    int l,r;//l:区间左端点（包含），r:区间右端点（包含）
}mark[maxn];
int V[maxn],T[maxn],n,len;
// 自定义排序函数：按区间左端点升序排序，左端点相同时按右端点升序排序
bool cmp(Flag x,Flag y){
    if(x.l==y.l)return x.r<y.r;
    else return x.l<y.l;
}
bool check(int mid){
	vector<Flag> v;//存储当前时间mid下所有已打开阀门的覆盖区间
	// 遍历所有阀门，计算其在时间mid时的覆盖区间（仅当mid>=阀门打开时间时才有效）
    for(int i=0;i<n;i++){
    	if(mid>=T[i]){
        mark[i].r=V[i]+(mid-T[i]);//右端点=阀门位置+打开后的持续时间
        mark[i].l=V[i]-(mid-T[i]);//左端点=阀门位置-打开后的持续时间
        v.push_back(mark[i]);
    	}
    }
    sort(v.begin(),v.end(),cmp);
    int R=0;
    for(int i=0;i<v.size();i++){
        if(v[i].l>R+1) return 0;
        R=max(R,v[i].r);
        if(R>=len) return 1;
    }
    return R>=len;
}
signed main(){//由于使用了#define int long long，主函数需声明为signed
    cin>>n>>len;
    int l=0,r=1e9,ans=0; 
    for(int i=0;i<n;i++){
        cin>>V[i]>>T[i];
    }
    while(l<=r){
        int mid=(l+r)/2;
        if(check(mid)) { // 如果mid时间满足覆盖条件
		    r=mid-1; // 尝试更小的时间
		    ans=mid; // 记录当前可行解
		}
		else { // 不满足条件，需要更大的时间
		 	l=mid+1;
		}
    }
    cout<<ans; 
    return 0;
}
```

---

## 作者：UNNN (赞：0)

## **题意**
 题目相当于是说在一个时刻打开一个位置的闸门，这个位置就会有水，在接下来的时间里，这个水会不断向左右蔓延，问你最终水漫完后瞬间的时刻是多少。

## **思路**

 记当前时刻为 $t$，被水覆盖的管道数量为 $f(t)$。那么我们只需要找到一个最小值 $x$，使得 $f(x) = len$ 即可。
 
 此时随着 $t$ 的不断增加，$f(t)$ 的值只能不断变大（毕竟水不会倒流），存在单调性，因此考虑二分。

 需要注意的是，为节省时间，二分时的左端点应取最先打开的闸门的打开时间，而由于管道中水能够灌满整个管道可以用的最长时间为 $len - 1$ (即只有第一个位置的管道打开)，所以右端点应取左端点加 $len - 1$。

 那么二分主体的代码就如下：

 
```cpp
while(lef < rig){
    mid = (lef + rig) >> 1;
    if(f(mid) >= len) rig = mid;
    else if(f(mid) < len) lef = mid + 1;
}
```

 那么如何求 $f(t)$ 的值呢？

 对于时刻 $t$，我们可以对于第 $i$ 个打开的闸门来计算它流出来的水的覆盖区间：

- 如果 $t < s_i$，那么它的覆盖区间范围为 $\empty$。
- 如果 $t ≥ s_i$，那么它的覆盖区间范围为 $[\max\{1, l_i - (t - s_i)\}, \min\{len, l_i + (t - s_i)\}]$。

 拿一组样例来举例：
 ```
 3 20
 3 1
 9 2
 20 5
 ```
 
   当 $t = 6$ 时，管道的水分布及覆盖区间如下图所示(其中，“源”代表打开的闸门，蓝色格子代表被水覆盖的管道)：
   
 ![](https://cdn.luogu.com.cn/upload/image_hosting/c35xsdlj.png)

 显然，$t = 6$ 时，`3 1` 覆盖了区间范围为 $[1, 8]$ 的管道；`9 2` 覆盖了区间范围为 $[5, 13]$ 的管道；`20 5` 覆盖了区间范围为 $[19, 20]$ 的管道
 
 从上面蓝色格子可以看出，对于以上的样例，$f(6) = 15$，那么这个 $15$ 是怎么求出来的呢？

 我们可以将以上所有两两存在交集的小区间并起来，也就是去掉区间重合的部分，就可以得到若干个大区间，对于每个大区间 $[l_i, r_i]$，它所覆盖的范围里包含了 $r_i - l_i + 1$ 个管道。假设最终可以得到 $k$ 个大区间，那么可以求得 $f(t) = \sum_{i = 1}^k (r_i - l_i + 1)$。
 
 将上述样例的所有小区间相并得到的大区间的分布如下图所示：
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/gcsjmfok.png)

 此时可以得到两个大区间，求得 $f(t) = (13 - 1 + 1) + (20 - 19 + 1) = 15$。

 代码的实现也很简单，先定义一个变量 `res` 代表最终 $f(t)$ 的值。首先对所有小区间按左端点排序，记录当前区间的最左端点 `kl` (在开始遍历前，最左端点的值为第一个区间的左端点)，随后从第一个区间开始遍历，遍历过程中不断更新当前区间的最右端点。

 遍历过程中，如果下一个区间的左端点大于当前的最右端点，说明区间之间出现了“断层”，此时对 `res` 的值进行累加，即 `res = res + (kr - kl + 1)`，然后将最左端点的值更新为下一个区间的左端点即可。遍历完成后，`res` 的值即为 $f(t)$ 的值。

 求 $f(t)$ 的代码如下：

 
```cpp
ll f(ll t){
    ll res = 0, cur = 0, kl, kr = 0;
    for(ll i = 1;i <= n;i++){
        if(t < s[i]) continue; // 当前闸门仍未打开可以直接跳过
        cur++;
        d[cur].l = max(1LL, l[i] - t + s[i]); // 存储区间左端点
        d[cur].r = min(len, l[i] + t - s[i]); // 存储区间右端点
    }
    sort(d + 1, d + 1 + cur);
    kl = d[1].l; // 最左端点
    for(ll i = 1;i <= cur;i++){
        kr = max(kr, d[i].r); // 不断更新最右端点
        if(i < cur){
            if(d[i + 1].l > kr){ // 出现断层
                res = res + (kr - kl + 1); // 累加
                kl = d[i + 1].l; // 更新最左端点
            }
        }
        else res = res + (kr - kl + 1); // 遍历到最后一个区间，直接累加
    }
    return res;
}
```


## **代码**

 注意，由于范围中给出 $1≤S_i ,len≤10^9$，所以一定要记住开 `long long`。
 
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll MAXN = 1e5 + 5;
struct node{
    ll l, r;
}d[MAXN];
bool operator< (node a, node b){
    return ((a.l == b.l) ? (a.r < b.r) : (a.l < b.l));
} // 排序规则
ll n, l[MAXN], s[MAXN], len, lef = 9223372036854775807, rig, mid;
ll f(ll t){
    ll res = 0, cur = 0, kl, kr = 0;
    for(ll i = 1;i <= n;i++){
        if(t < s[i]) continue; // 当前闸门仍未打开可以直接跳过
        cur++;
        d[cur].l = max(1LL, l[i] - t + s[i]); // 存储区间左端点
        d[cur].r = min(len, l[i] + t - s[i]); // 存储区间右端点
    }
    sort(d + 1, d + 1 + cur);
    kl = d[1].l; // 最左端点
    for(ll i = 1;i <= cur;i++){
        kr = max(kr, d[i].r); // 不断更新最右端点
        if(i < cur){
            if(d[i + 1].l > kr){ // 出现断层
                res = res + (kr - kl + 1); // 累加
                kl = d[i + 1].l; // 更新最左端点
            }
        }
        else res = res + (kr - kl + 1); // 遍历到最后一个区间，直接累加
    }
    return res;
}
int main()
{
    // 输入
    scanf("%lld%lld", &n, &len);
    for(ll i = 1;i <= n;i++){
        scanf("%lld%lld", &l[i], &s[i]);
        lef = min(lef, s[i]); // 求二分的左端点
    }
    rig = lef + len - 1LL; // 二分右端点
    // 二分
    while(lef < rig){
        mid = (lef + rig) >> 1LL;
        if(f(mid) >= len) rig = mid;
        else if(f(mid) < len) lef = mid + 1LL;
    }
    printf("%lld", lef);
    return 0; // 结束 (｡･ω･｡)
}

```

---

## 作者：封禁用户 (赞：0)

# P12380 题解

## 思路

二分查找，我们需要找到最小的 $T$，使得所有管道的段都被覆盖。这类似于区间覆盖问题，其中每个阀门在时间 $T$ 贡献一个区间 $[L[i]-(T-S[i]),L[i]+(T-S[i])]$，并且这些区间的并集需要覆盖 $[1,len]$ 就可以了。

## [AC](https://www.luogu.com.cn/record/215584275) 代码

```cpp
#include <bits/stdc++.h> 
typedef long long ll;
using namespace std;
struct Val {
    ll L, S;
};
bool is(ll T, const Val vs[], int n, ll len) {
    pair<ll, ll> ints[n];
    int cnt = 0;
    for (int i = 0; i < n; ++i) {
        if (T >= vs[i].S) {
            ll d = T - vs[i].S;
            ll l = vs[i].L - d;
            ll r = vs[i].L + d;
            ints[cnt++] = make_pair(max(1LL, l), min(len, r));
        }
    }
    if (cnt == 0) return false;
    sort(ints, ints + cnt);
    ll cur = 0;
    for (int i = 0; i < cnt; ++i) {
        if (ints[i].first > cur + 1) {
            return false;
        }
        cur = max(cur, ints[i].second);
    }
    return cur >= len;
}
ll fe(const Val vs[], int n, ll len) {
    ll l = 0;
    ll r = 0;
    for (int i = 0; i < n; ++i) {
        r = max(r, vs[i].S + len);
    }
    ll ans = r;
    while (l <= r) {
        ll m = l + (r - l) / 2;
        if (is(m, vs, n, len)) {
            ans = m;
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return ans;
}
int main() {
    int n;
    ll len;
    cin >> n >> len;
    Val vs[n];
    for (int i = 0; i < n; ++i) {
        cin >> vs[i].L >> vs[i].S;
    }
    cout << fe(vs, n, len) << '\n';
    return 0;
}
```

---

## 作者：imnotcfz (赞：0)

# P12380 [蓝桥杯 2023 省 Python B] 管道 题解
[原题链接](https://www.luogu.com.cn/problem/P12380)

本题考察二分答案、简单模拟。

## 核心出装

由于我们可以$\small\overset{O(1)}{\bf直接}$知道任何时刻阀门的开闭情况，以及任意一个阀门水流的情况，所以我们容易想到二分答案。

题目要求的是**最早**的时间，所以我们要写一个 lower_bound：

$$
\begin{array}{r|l}
1 & \textbf{while } l < r\\
2 & \quad mid\gets \left\lfloor\frac{l+r}{2}\right\rfloor\\
3 & \quad \textbf{if } \operatorname{check}(mid) \\
4 & \quad \quad r\gets mid \\
5 & \quad \textbf{else } \\
6 & \quad \quad l\gets mid + 1
\end{array}
$$

可以证明 $l$ 即为所求。

也可以用另一种使用 $l \le r$ 的写法：

$$
\begin{array}{r|l}
1 & \textbf{while } l \le r\\
2 & \quad mid\gets \left\lfloor\frac{l+r}{2}\right\rfloor\\
3 & \quad \textbf{if } \operatorname{check}(mid) \\
4 & \quad \quad ans\gets mid \\
5 & \quad \quad r\gets mid - 1 \\
6 & \quad \textbf{else } \\
7 & \quad \quad l\gets mid + 1
\end{array}
$$

此时 $ans$ 即为所求。

## 可行性验证

我们可以开一个 vector，存储每个打开的阀门流出的水覆盖的区间，接下来再检查这些区间是否覆盖了整个管道。

存储这些大家应该都会，判断覆盖就有点难了，因为 $len$ 高达 $10^9$，我们不能用`vis`数组存。

遇事不决先排序，我们将所有区间按左端点排序，然后检查相邻两个区间是否连续，最后别忘了管道的头尾。

很完美对吧，那我问你，如果有三个区间，第一个区间覆盖了整个管道，第二个和第三个不连续，那你不炸了？

因此检查相邻两个区间，应当改为将当前区间的左端点与**之前检查过的区间覆盖到的最右端**比较。

## Talk is cheap, show me the code!

[完整代码](https://www.luogu.com.cn/paste/13ljpuix)，进行了格式化，并对核心代码（以及一些你可能遇到的问题）进行了详细的解释，为了让你看懂。

## Changelog

* 2025/5/1 19:07 一发过审
* 2025/5/1 19:30 修正了一处勘误

---


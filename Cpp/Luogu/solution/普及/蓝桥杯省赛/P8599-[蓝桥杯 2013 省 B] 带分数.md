# [蓝桥杯 2013 省 B] 带分数

## 题目描述

$100$ 可以表示为带分数的形式：$100 = 3 + \frac{69258}{714}$。

还可以表示为：$100 = 82 + \frac{3546}{197}$。

注意特征：带分数中，数字 $1$ ~ $9$ 分别出现且只出现一次（不包含 $0$）。

类似这样的带分数，$100$ 有 $11$ 种表示法。






## 说明/提示

原题时限 3 秒, 64M。蓝桥杯 2013 年第四届省赛

## 样例 #1

### 输入

```
100```

### 输出

```
11```

## 样例 #2

### 输入

```
105```

### 输出

```
6```

# 题解

## 作者：pxb0801 (赞：60)

## 1.题目大意：

题目很简单：给你一个 $n$，问有多少种表示为 $a+\frac{b}{c}$ 的形式，且 $a,b,c$ 中的数字正好不重复不遗漏的包含数字 $1$ ~ $9$。

-----------
## 2.分析：

如果这道题去枚举 $a$，再去一个一个枚举 $b$，算出 $c$，最后再验证，会极其的麻烦。

我们不如这样想：将 $a,b,c$ 中的所有数字连在一起，是不是就是一个 $1$ ~ $9$ 的全排列？

我们以样例为例：对于 $82+\frac{3546}{197}$ 而言，这个全排列就是 `823546197`。这样，我们去枚举 $1$ ~ $9$ 的全排列会轻松许多，时间上也会快很多。

写代码时，可以选择手打深搜，也可以用一下 [next_permutation](https://blog.csdn.net/qq_47997583/article/details/115802189) 这个函数（非常的好用）。

当我们生成一个排列时，只需要枚举两个断点 $i$ 和 $j$，此时下标 $1$ ~ $i$ 的就是 $a$；$i+1$ ~ $j$ 的就是 $b$；$j+1$ 到 $9$ 的就是 $c$。最后判断一下即可。

-----------------
## 3.正确代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[10]={0,1,2,3,4,5,6,7,8,9},ans;
int main(){
	cin>>n;
	while(1){
		int x=0;
		for(int i=1;i<=7;i++){
			x=x*10+a[i];
			int y=0;
			for(int j=i+1;j<=8;j++){//枚举断点 
				y=y*10+a[j];
				int z=0;
				for(int k=j+1;k<=9;k++){
					z=z*10+a[k];
				} 
				if(y%z==0&&x+y/z==n){//判断是否满足条件 
					ans++;//满足则答案+1 
				}
			}
		}
		next_permutation(a+1,a+9+1);
		//检查，如果此时的全排列又回到第一次的，则跳出循环 
		bool ok=0;
		for(int i=1;i<=9;i++){
			if(a[i]!=i){
				ok=1;
				break;
			}
		}
		if(!ok) break;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：tianzijun (赞：21)

 ### 题目大意：

题意很清楚：求一个整数表示成带分数形式的种数。

--------------
 ### 分析：

看到这个题目，第一反应是暴力找出整数部分 $a$，分子部分 $b$，分母部分 $c$，看看哪一组 $a+\frac{b}{c}$ 刚好等于 $n$。

但是这样做比较麻烦，所以我们有一种新的办法。

通过观察，我们不难发现：每个组成带分数的数字正好是 $1 \sim9$，那么我们只要枚举 $1\sim9$ 中的数字的全排列，再进行验证，是不是就筛选出了答案的种数呢？

而且，题目还说了，只需要求种数，所以就不需要把每一个数字都求出来了。

------------------
### 实现：

先说一句，求全排列有两种方式：一种是暴力搜索，一种是直接用函数 ```next_permutation```。

个人推荐第二种，好用还不会写错。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]; 
int work(int l, int r){
	int sum=0;
	for (int i=l; i<=r; i++)
		sum=sum*10+a[i];
	return sum;
}//验证
int t,n;
int main(){
	for (int i=0; i<10; i++) a[i]=i+1;
	scanf("%d", &n);
	int ans=0;
	do {
		for (int i=0; i<7; i++){
			int x=work(0, i);
			if (x>n) break;
			for (int j=i+1; j<8; j++){
				int y=work(i+1, j), z=work(j+1, 8);
				if (y%z==0 && x+y/z==n) {
					ans++;//满足条件则答案+1
				}				
			}	
		}
	} while (next_permutation(a, a+9));//全排列 
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Rain_chr (赞：13)

###  题意简述
+ 用 1$\sim$9 的数字凑出形如 $a+\frac{b}{c}$ 的算式；

+ 请问算式结果为 $n$ 的有多少种方案？

### 题意分析

由于 1$\sim$9 数字范围超小，所以我们可以直接暴力求解。

怎么暴力呢？

当然是**全排列**啊！

用全排列枚举每一种可能，再用约束条件去判断一下即可

亮代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int book[9]={1,2,3,4,5,6,7,8,9};
vector<int> a;
int to_num(int l,int r) //使数组中的数字变成数 
{
	int ans=0;
	for(int i=l;i<=r;i++)
		ans=ans*10+book[i];
	return ans;
}
int main()
{
	int n;
	cin>>n;
	int ans=0;
	do
	{
		for(int i=0;i<10;i++)
		{
			int num=0;
			num=to_num(0,i);
			for(int j=i+1;j<8;j++)
				if(num+to_num(i+1,j)/to_num(j+1,8)==n&&to_num(i+1,j)%to_num(j+1,8)==0)//约束条件判断
					ans++;
		}
	}
	while(next_permutation(book,book+9)); //全排列函数 
	cout<<ans;
	return 0;
} 
```



---

## 作者：bigsmart21 (赞：9)

# 题解

[题目传送门](https://www.luogu.com.cn/problem/P8599)

## 题目大意

给出一个整数 $N$，在数字 1~9 中不重复不遗漏的分成三个数 $a$，$b$，$c$。求 $a + \frac{b}{c} = N$ 的情况有多少种。

## 题目分析

* 一看到这道题时限 3 秒，我们就可以枚举出 1~9 的全排列。

* 然后把每一种全排列的可能切分成三个数带入题目中的公式即可。

**注意**

由于数字是 int 类型，我们要判断 $b$ 是否为 $c$ 的倍数，不然会出现误差。

~~但是本蒟蒻还是想偷懒。~~

* 于是乎，本蒟蒻发现了 STL 中的 [next_permutation](https://blog.csdn.net/howardemily/article/details/68064377) 函数，可以快速给出全排列。

## 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int xu[11]{0,1,2,3,4,5,6,7,8,9};
int make_number(int x,int y){//将每一个数字拼起来 
	int yi=0;
	for(int i=x;i<=y;i++){
		yi*=10; 
		yi+=xu[i];
	}
	return yi;
}
int main(){
	int n,ans=0;
	cin>>n;
	do{
		for(int i=1;i<=7;i++){//第一个数最多有7位 
			for(int j=i+1;j<=8;j++){//第二个数和第一个数的位数和最多为8 
				int num1=make_number(1,i);
				int num2=make_number(i+1,j);
				int num3=make_number(j+1,9);//把全排列分成三个数
				if(num1+(num2/num3)==n&&(num2%num3==0)){//套入公式 
					ans++;
				}
			}
		}
	}
	while(next_permutation(xu+1,xu+10));//非常高级的省代码函数 
	cout<<ans;
	return 0;
} 
```


---

## 作者：zhangyuanxiao (赞：7)

[题目传送门](https://www.luogu.com.cn/problem/P8599)

## 题意
- 给出**正整数** $N$，用数码 $1 \sim 9$ 不重复不遗漏地组成形如 $a+\dfrac{b}{c}$ 的算式，使其值等于 $N$。
- $N \le 10^6$。

## 分析
- 因为数字范围是 $1 \sim 9$，很小，可以直接暴力枚举。因为要不重复，不遗漏，因此我们可以使用全排列来枚举所有可能，再按顺序拆分成三个数，检验是否满足题意。
- 对于全排列，可以使用 STL 中的 ```next_permutation``` 函数，可以给出当前排列的下一个排列。如果已是最后一个排列，则返回 false。

## 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int N,num[]={0,1,2,3,4,5,6,7,8,9},ans;

int tonum(int l,int r){//将num数组的第l至r个数转为一个数
	int re=0;
	for(int i=l;i<=r;i++){
		re=re*10+num[i];
	}
	return re;
}

int main(){
	cin>>N;
	do{
		for(int i=1;i<=7;i++){
			for(int j=i+1;j<=8;j++){//拆分
				int a=tonum(1,i);
				int b=tonum(i+1,j);
				int c=tonum(j+1,9);
				if((N-a)*c==b) ans++;//因为是int类型，除法不方便，所以转换为等价的乘法
			}
		}
	}while(next_permutation(num+1,num+10));//找下一个全排列函数
	cout<<ans;
	return 0;
}
```

---

## 作者：sw2022 (赞：7)

## 题意简析

将一个数写成带分数的形式，整数部分、分子、分母中数码 $1\sim 9$ 不重不漏出现一次。全排列枚举所有可能出现的情况并计算值，如果与这个数相等则计数器累加，累加结果就是答案。

## 代码/解释
```cpp
#include<bits/stdc++.h>
#define stoi(str,pos,len) atoi(str.substr(pos,len).c_str())//子串转整数
using namespace std;
int main()
{
	string s="123456789";
	int n,t=0,a,b,c,i,j;
	cin>>n;
	while(next_permutation(s.begin(),s.end()))//枚举全排列
	for(i=1;i<=7;i++)
	{
		a=stoi(s,0,i);
		if(a>=n) break;
		for(j=1;j<=8-i;j++)
		{
			b=stoi(s,i,j);
			c=stoi(s,i+j,9-i-j);
			if(b%c==0&&a+b/c==n) t++;
		}
	}
	printf("%d\n",t);  
	return 0;
}
```

---

## 作者：huangruiheng0217 (赞：5)

## 题意简述
- 把一个正整数表示为$a+\dfrac{b}{c}$的形式（带分数），其中数码 $1-9$ 在 $abc$ 中出现且仅出现 $1$ 次。(不含 $0$ ）

- 例如，
$100=3+\dfrac{69258}{714}$

- 求这个正整数有多少种带分数表示方法。

有人讲过生成全排列了，但是可能有些同学不知道 `next_permutation`
这个函数的用法，不过并没有关系。“万物皆搜索”吗。

数据范围小，可以考虑递归，~~不知道为什么没人写这种题解~~

## 递归

- 每次在还没有使用过的数中选择一个，确认一下这个数有没有被用过，然后选择把它放在整数部分，分子还是分母。

- 计算带分数的值的时候，用分子除以分母，加上整数部分，与原数比较。注意判断一下是否能够整除。

结果TLE了（时间复杂度和给定的正整数无关，跑出来 $1.05s$ 左右）

~~话说本题时限不是3s吗~~

思考一下有没有可以剪枝的地方？

我们可以按照顺序，先枚举整数，再枚举分子，最后枚举分母。

也就是说，如果在这一步选择把这个数放在了分子，就不能把下一步选择的数重新放在整数部分。

我们知道，带分数三个部分都不能出现 $0$ ，这意味着如果把所有的数码全部枚举完毕之后，还没有数字出现在分母位置上，即：分母为 $0$ ，这种方案就必定挂了。

往前推，如果第 $8$ 个数码枚举完毕后还没有数字在分子位置上，那么第 $9$ 个数码必定要摆在分子位置上，但是这样分母为 $0$ 了。

如果把它摆在分母位置上则分子为 $0$ 。所以，检查第 $8$ 个数码是否摆在整数部分，如果是，那么就可以舍弃这种状态。

附代码：
```cpp
#include<iostream>
using namespace std;
int n,cnt;
int mry[15];//mry[k]记录第k步选择的数字 
int mtype[15];//mtype[k]记录第k步选择的数字是整数部分（1），分子（2）还是分母（3） 
bool used[15];//记录数码是否被使用 
void dfs(int step,int type){
	if(step==9&&type==2)return;//剪枝 
	if(step==8&&type==1)return;
	if(step>9){
		if(type!=3)return;//如果分母没有数字，肯定挂了 
		if(mtype[9]!=3)return;
		int sum=0,i=1,reg1=0,reg2=0;
		while(mtype[i]==1)//整数部分 
			sum=sum*10+mry[i++];
		while(mtype[i]==2)//分子 
			reg1=reg1*10+mry[i++];
		while(mtype[i]==3)//分母 
			reg2=reg2*10+mry[i++];
		if(reg1%reg2!=0)return;//如果不是整数，必定不符合要求 
		sum+=reg1/reg2;
		if(sum==n)cnt++;
		return;
	}
	for(int i=1;i<=9;i++){
		if(used[i])continue;
		used[i]=1;
		mry[step]=i;
		mtype[step]=type;
		for(int j=type;j<=3;j++)//枚举不同位置 
			dfs(step+1,j);
		used[i]=0;
		mry[step]=0;
		mtype[step]=0;
	}
}
int main(){
	cin>>n;
	dfs(1,1);
	cout<<cnt<<endl;
	return 0;
} 
```

---


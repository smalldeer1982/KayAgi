# [蓝桥杯 2013 省 A] 大臣的旅费

## 题目描述

很久以前，T 王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，T 国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

J 是 T 国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了 J 最常做的事情。他有一个钱袋，用于存放往来城市间的路费。

聪明的 J 发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第 $x - 1$ 千米到第 $x$ 千米这一千米中（$x$ 是整数），他花费的路费是 $x+10$ 这么多。也就是说走 $1$ 千米花费 $11$，走 $2$ 千米要花费 $23$。

J 大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？


## 说明/提示

样例解释：大臣 J 从城市 $4$ 到城市 $5$ 要花费 $135$ 的路费。

时限 5 秒, 64M。蓝桥杯 2013 年第四届省赛

## 样例 #1

### 输入

```
5
1 2 2
1 3 1
2 4 5
2 5 4```

### 输出

```
135```

# 题解

## 作者：XIxii (赞：26)

由于题目说到不重复经过大城市，从首都到达每个大城市的方案都是唯一的。因此可以知道该图是一棵树，本题求的是树的直径。

树的直径：树中长度最长的路径。

求树的直径的步骤：

1. 任取一点 $x$ ;

2. 找到距离 $x$ 最远的点 $y$ ;

3. 从 $y$ 开始遍历，找到离 $y$ 最远的点，与 $y$ 最远的点的距离是树的直径;

这道题我们可以使用深搜来解决。

步骤：

1. 通过深度优先遍历找到与 $x$ 的最远距离的点 $y$ ;

2. 再通过深度优先遍历找到与 $y$ 的最远距离;

下面给出AC代码，更详细的思路请见注释：

```
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n;
struct edge
{
    int id,w;//定义每个节点的编号和去该点的距离
};
vector<edge> h[N];//用vector存储图
int dist[N];//存放离当前节点的最大距离
void dfs(int u,int father,int distance)
{
    dist[u]=distance;
    for(auto node:h[u])//遍历当前节点可以到达的节点
    {
        if(node.id!=father)//排除父节点防止返回
        {
            dfs(node.id,u,distance+node.w);
        }
    }
}
int main()
{
    cin>>n;
    for(int i=0;i<n-1;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        h[a].push_back({b,c});
        h[b].push_back({a,c});
    }
    dfs(1,-1,0);//可从任一点开始dfs，找到该点能到达的所有点
    int u=1;
    for(int i=1;i<=n;i++)
    {
        if(dist[i]>dist[u])
        {
            u=i;//找到与当前点距离最远的一个点（即树的直径的一个端点）
        }
    }
    dfs(u,-1,0);//再找到树的直径的端点能到达的所有点
    for(int i=1;i<=n;i++)
    {
        if(dist[i]>dist[u])
        {
            u=i;//找到最远的那个点，就找到了当前树的直径的另一个端点
        }
    }
    int s=dist[u];//树的直径
    printf("%lld",10*s+s*(s+1ll)/2);//可能爆int转成LL，根据题意推出路费和距离的关系
    return 0;
    
}

```




---

## 作者：5k_sync_closer (赞：6)

来点板子题复健一下。

考虑连续走 $x$ 千米的花费，不难发现是 $10x+\sum\limits_{i=1}^xi=\dfrac12 x^2+\dfrac{21}2 x$。

然后这玩意对称轴在 $-\dfrac{21}2$，显然 $f(x)=\dfrac12 x^2+\dfrac{21}2 x$ 在 $\mathbf N$ 上单调递增，所以要最大化 $x$。

或者说你也可以一眼看出来这个题是求树的直径。用树上 DP 来做。

维护 $x$ 子树内点到 $x$ 距离的最大值 $a_x$ 和次大值 $b_x$，然后 $\max\limits_{i=1}^na_i+b_i$ 就是直径长度。
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
struct E{int v, w, t;}e[200050];
int n, u, v, w, c, h[100050];long long q, a[100050], b[100050];
void A(int u, int v, int w) {e[++c] = {v, w, h[u]};h[u] = c;}
void D(int u, int k)
{
	for(int i = h[u], v, x;i;i = e[i].t) if((v = e[i].v) != k)
	{
		D(v, u);if((x = a[v] + e[i].w) > a[u]) b[u] = a[u], a[u]
		= x;else if(x > b[u]) b[u] = x;q = max(q, a[u] + b[u]);
	}
}
int main()
{
	scanf("%d", &n);for(int i = 1;i < n;++i)
		scanf("%d%d%d", &u, &v, &w), A(u, v, w), A(v, u, w);
	return D(1, 0), printf("%d", q * (q + 21) / 2), 0;
}
```


---

## 作者：Rainsleep (赞：4)

思路其他大佬都说过了，我简单复述一下吧

------------

注意到题目给定的几个信息：
>任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

>（ $T$ 国的高速路一定是 $n - 1$条）。

由此得知该图一定是一棵**树**。可以使用 $\text{LCA}$ 暴力求解树上两点距离。时间复杂度 $O(n^2)$，无法通过此题。

在树的基础知识中，我们将树中最长的一条简单路径称为树的直径。关于树的直径，我们有两种求法，树形dp以及两次dfs，这里使用的是树形dp，时间复杂度为 $O(n)$，可以通过本题。

留意到题目特有的计算距离方法，楼上已经讲过了，即为 $10x+\sum_{i=1}^x i$，通过等差数列求和我们可以化简为 $\dfrac{x(x+1)}{2}$。

这里安利下[自己写的关于树的直径的博客](https://www.luogu.com.cn/blog/Rainsheep-Blog/post-suan-fa-bi-ji-shu-di-zhi-jing)

代码如下，仅供参考。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

struct Edge
{
	int to, nxt;
	int w;
} edges[N << 1];

int head[N], idx = 0, n;

int lg[N], slg[N], res = - INT_MAX;

inline void link(int from, int to, int w)
{
	++ idx;
	edges[idx] = {to, head[from], w};
	head[from] = idx;
	return ;
}

inline int max(int x, int y)
{
	return x > y ? x : y;
}

inline void dfs(int cur, int pa)
{
	for(int i(head[cur]);i;i = edges[i].nxt)
	{
		int to = edges[i].to;
		int w = edges[i].w;
		
		if(to == pa)
			continue;
		
		dfs(to, cur);
		
		if(lg[to] + w > lg[cur])
			slg[cur] = lg[cur], lg[cur] = lg[to] + w;
		else if(lg[to] + w > slg[cur])
			slg[cur] = lg[to] + w;
			
	}
	
	res = max(res, lg[cur] + slg[cur]);
	
	return ;
}

int main()
{
	
	scanf("%d", &n);
	
	for(int i(1);i <= n - 1; ++ i)
	{
		int x, y, z;
		scanf("%d %d %d", &x, &y, &z);
		link(x, y, z);
		link(y, x, z);
	}
	
	dfs(1, 0);
	
	int t = 10 * res + (((1 + res) *  res) >> 1);
	
	printf("%d", t);
	
	return 0;
}
```







---

## 作者：sw2022 (赞：4)

## 题意简析

给定一个图，求图上任意两点间的最长路。因为边的数量 $m=$ 点的数量 $n-1$，所以可以把这个图看成一棵树，那么图上任意两点间的最长路就是树的直径，可以通过求两次单源最长路径的方法解决。由题意可知，当总路程为 $x$ 千米时，总路费为 $10x+\sum_{i=1}^x i=10x+\dfrac{x(x+1)}{2}$，将最长路答案代入计算即可。

## 代码/解释
```cpp
#include<bits/stdc++.h>
using namespace std;
int hd[100001],go[100000],nxt[100000],cst[100000],dis[100001],l;
void Add(int u,int v,int t)
{
	nxt[++l]=hd[u],hd[u]=l,go[l]=v,cst[l]=t;
}
void dfs(int s,int f,int d)
{
	dis[s]=d;
	for(int i=hd[s];i;i=nxt[i])
	{
		if(go[i]==f) continue;
		dfs(go[i],s,d+cst[i]);
	}
}
int main()
{
	int n,m,u,v,w,s=1,i;
	cin>>n;m=n-1;
	for(i=1;i<=m;i++)
	{
		cin>>u>>v>>w;
		Add(u,v,w);
		Add(v,u,w);
	}
	dfs(1,0,0);
	for(i=2;i<=n;i++)
	if(dis[s]<dis[i]) s=i;
	dfs(s,0,0);
	for(i=1;i<=n;i++)
	if(dis[s]<dis[i]) s=i;
	printf("%d\n",dis[s]*10+(dis[s]+1)*dis[s]/2);
	return 0;
}
```

---

## 作者：lrqlrq250 (赞：3)

## 题意简述
首先题目中给了这两条信息：

- 任何一个大城市都能从首都直接或者通过其他大城市间接到达。

- 如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

因此整张图是一棵树，问题即为求树上最大路径长度，也就是求**树的直径**。

## 解题思路

树的直径一般用树形 DP 或两次 DFS 的方式求解，我这里使用的是两次 DFS。

第一次 DFS 从根向下，寻找离根最远的结点（可以证明一定是叶子结点）

第二次 DFS 从第一次找到的最远的节点开始，寻找离这个点最远的点，两者的距离就是树的直径。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Edge{int to, w, next;}e[200001];
int n, head[100001], tot, ans[100001];
int maxlen, p;

inline void addedge(int u, int v, int w){
    e[++tot].to = v;
    e[tot].w = w;
    e[tot].next = head[u];
    head[u] = tot;
}

void dfs(int x, int last, int sum){
    if (sum > maxlen){
        maxlen = sum;
        p = x;//最远的节点
    }
    for (int i=head[x], y; i; i=e[i].next) if (e[i].to != last){
        y = e[i].to;
        dfs(y, x, sum + e[i].w);
        ans[y] = max(ans[y], sum + e[i].w);
    }
}

int main(){
    scanf("%d", &n);
    int u, v, w;
    for (int i=1; i<n; i++){
        scanf("%d%d%d", &u, &v, &w);
        addedge(u, v, w); addedge(v, u, w);
    }
    dfs(1, -1, 0);
    dfs(p, -1, 0);
    int dis = 0;
    for (int i=1; i<=n; i++) dis = max(dis, ans[i]);
    printf("%d\n", dis * 10 + (dis + 1) * dis / 2);
    return 0;
}
```


---

## 作者：Charles_with_wkc (赞：2)

# 绪论

树的直径模板题。

# 思路

这里找两个城市要求路径最长，不难想到树的直径。从每个点出发寻找离自己最远的和次远的这两个点，因为找的是最长的路径。我们每次选择最大的和次大的合在一起就可以了，这里直接写模板，不在多说。最后直接用等差数列，公差为 $1$，来计算和即可。最后答案记录证明，路径总长为 $ans$，那么这些数一定从 $11$ 开始到 $10+ans$ 的，显然为等差数列，首项为 $1$，末项为 $10+ans$，项数为 $ans$，那么不难算出最后的答案就是 $(11+10+ans) \times ans \div 2$，整合为 $(21+ans)\times ans \div 2$，但是我们也可以将每个数提取一个 $10$ 出来这样式子会变成 $(1+ans) \times ans \div 2+10 \times ans$。两点之间有且只有一条简单路径，所以从一出发一定可以到所有点。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N=1e5+5;
int d1[N],d2[N];
int n,u,v,ans,k;
struct node{
	int v,w;
};
vector<node>edge[N];
void dfs(int now,int fa){
	int d3;
	for(int i=0;i<edge[now].size();i++){
		if(fa==edge[now][i].v) continue;
		dfs(edge[now][i].v,now);
		d3=edge[now][i].w+d1[edge[now][i].v];
		if(d1[now]<d3){
			d2[now]=d1[now];
			d1[now]=d3;
			//比最大值更有 
		}
		else if(d2[now]<d3) d2[now]=d3;//比次大值更优 
	}
	ans=max(ans,d1[now]+d2[now]);
	return ;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<n;i++){
		cin>>u>>v>>k;
		edge[u].push_back(node{v,k});
		edge[v].push_back(node{u,k});
	}
	dfs(1,0);//两点之间有且只有一条简单路径，所以从一出发一定可以到所有点 
	cout<<(ans+1)*ans/2+ans*10;//等差数列求和 
	return 0;
} 
```

---

## 作者：ZTengW (赞：0)

以防你不知道是哪一题：  
[HeRe](https://www.luogu.com.cn/problem/P8602)  
## 题意  
求树的直径，然后再算一个等差数列的和。  
## 思路  
首先我们用链式前向星存好图。  
——那为什么不能用邻接表呢？  
——因为存权值的数组会爆掉。  
接着，我们可以用二次 DFS 或者树状 DP 求出树的直径。  
最后，我们再求一个首项为 $11$，末项为 $ans+10$，项数为 $ans$ 的等差数列的各项之和（$ans$ 为树的直径）。  
## [AC](https://www.luogu.com.cn/record/222284711) code  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+5;
ll n,ans,h[N],ne[2*N],cnt,w[2*N],e[2*N],dis[N];
void add(ll u,ll id,ll l) // 前向星
{
	e[cnt]=id;
	w[cnt]=l;
	ne[cnt]=h[u];
	h[u]=cnt++;
}
void dfs(ll u,ll f,ll l) // 二次深搜
{
	dis[u]=l;
	for(int i=h[u];~i;i=ne[i])
		if(e[i]!=f)
			dfs(e[i],u,l+w[i]);
}
int main()
{
	memset(h,-1,sizeof(h));
	scanf("%lld",&n);
	for(ll i=1;i<n;i++)
	{
		ll u,v,t;
		scanf("%lld%lld%lld",&u,&v,&t);
		add(u,v,t);
		add(v,u,t);
	}
	dfs(1,-1,0);
	int u=1;
	for(int i=1;i<=n;i++)
		if(dis[i]>dis[u])
			u=i;
	dfs(u,-1,0);
	for(int i=1;i<=n;i++)
		if(dis[i]>dis[u])
			u=i;
	ans=dis[u];
	printf("%lld",10*ans+(ans*(ans+1ll))/2);
	return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

树的直径板题。主要就是如何求树的直径。

先从根节点开始，一次深搜求出离它最远的节点 $x$ 。再从 $x$ 开始，一次深搜求出离它最远的节点 $y$ ，此时 $x$ 和 $y$ 为树的直径的两端，它俩之间的距离为树的直径的长度。证明可以看[这里](http://oi-wiki.com/graph/tree-diameter/)。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=114514;
struct node{int v,w;};
int n,x,y,z,res;
int dis[maxn];
vector<node> v[maxn];
inline void dfs(int x,int f){
    if(dis[x]>dis[res]) res=x;
    for(auto i:v[x]){
    	int v=i.v,w=i.w;
    	if(v==f) continue;
    	dis[v]=dis[x]+w;
    	dfs(v,x);
	}
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<n;i++){
        scanf("%d %d %d",&x,&y,&z);
        v[x].push_back({y,z});
		v[y].push_back({x,z});
    }
    dis[1]=1,dfs(1,0);
	dis[res]=0,dfs(res,0);
	cout<<10ll*dis[res]+dis[res]*(dis[res]+1ll)/2;
}
```

---


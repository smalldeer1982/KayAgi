# [蓝桥杯 2014 省 AB] 蚂蚁感冒

## 题目描述

长 $100$ 厘米的细长直杆子上有 $n$ 只蚂蚁。它们的头有的朝左，有的朝右。

每只蚂蚁都只能沿着杆子向前爬，速度是 $1$ 厘米 / 秒。

当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。

这些蚂蚁中，有 $1$ 只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。

请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。

## 样例 #1

### 输入

```
3
5 -2 8```

### 输出

```
1```

## 样例 #2

### 输入

```
5
-10 8 -20 12 25```

### 输出

```
3```

# 题解

## 作者：Vct14 (赞：49)

我们先来分析一下样例 $2$ 。

|  秒数|  第 $2$ 只蚂蚁|  第 $1$ 只蚂蚁|  第 $4$ 只蚂蚁|  第 $3$ 只蚂蚁|  第 $5$ 只蚂蚁|  事件|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  $0$|  $8R$|  $10LG$|  $12R$|  $20L$|  $25R$|  第 $1$ 只蚂蚁感冒|
|  $1$|  $9RG$|  $9LG$|  $13R$|  $19L$|  $26R$|  第 $2$ 只蚂蚁与第 $1$ 只蚂蚁碰面掉头，第 $2$ 只蚂蚁被传染|
|  $4$|  $6LG$|  $12RG$|  $16R$|  $16L$|  $29R$|  第 $4$ 只蚂蚁与第 $3$ 只蚂蚁碰面掉头|
|  $6$|  $4LG$|  $14RG$|  $14LG$|  $18R$|  $31R$|  第 $1$ 只蚂蚁与第 $4$ 只蚂蚁碰面掉头，第 $4$ 只蚂蚁被传染|

其中 $L$ 表示向左， $R$ 表示向右， $G$ 表示感冒。

最后第 $1,2,4$ 只蚂蚁感冒。

由表格可以发现，由于碰面就掉头，这些蚂蚁的相对排列顺序是保持不变的，那么，应该可以从开始的位置就能预测谁会被传染。

在样例 $2$ 中，第 $1$ 只蚂蚁（感冒蚂蚁）朝左。
1. 位于第 $1$ 只蚂蚁左侧且朝右蚂蚁有一只，即第 $2$ 只蚂蚁，被传染；
2. 由于步骤 $1$ ，第 $1$ 只蚂蚁朝右，位于第 $1$ 只蚂蚁右侧且朝左蚂蚁也有一只，即第 $4$ 只蚂蚁，也被传染。

------------

再举个第 $1$ 只蚂蚁朝右的例子。
```
10 8 20 -12 -25
```
|  秒数|  第 $2$ 只蚂蚁|  第 $1$ 只蚂蚁|  第 $4$ 只蚂蚁|  第 $3$ 只蚂蚁|  第 $5$ 只蚂蚁|  事件|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  $0$|  $8R$|  $10RG$|  $12L$|  $20R$|  $25L$|  第 $1$ 只蚂蚁感冒|
|  $1$|  $9R$|  $11RG$|  $11LG$|  $21R$|  $24L$|  第 $1$ 只蚂蚁与第 $4$ 只蚂蚁碰面掉头，第 $4$ 只蚂蚁被传染|
|  $2$|  $10RG$|  $10LG$|  $12RG$|  $22R$|  $23L$|  第 $2$ 只蚂蚁与第 $1$ 只蚂蚁碰面掉头，第 $2$ 只蚂蚁被传染|
|  $3$|  $9LG$|  $11RG$|  $13RG$|  $22L$|  $23R$|  第 $3$ 只蚂蚁与第 $5$ 只蚂蚁碰面掉头|
|  $9$|  $4LG$|  $16RG$|  $17LG$|  $18RG$|  $28R$|  第 $4$ 只蚂蚁与第 $3$ 只蚂蚁碰面掉头，第 $3$ 只蚂蚁被传染|

最后第 $1,2,3,4$ 只蚂蚁感冒。

在这个例子中第 $1$ 只蚂蚁（感冒蚂蚁）朝右。
1. 位于第 $1$ 只蚂蚁右侧且朝左蚂蚁有两只，即第 $4$ 只蚂蚁和第 $5$ 只蚂蚁，它们都被传染；（其中第 $3$ 只蚂蚁在与第 $5$ 只蚂蚁碰面后朝左）
2. 由于步骤 $1$ ，第 $1$ 只蚂蚁朝左，位于第 $1$ 只蚂蚁左侧且朝右蚂蚁有一只，即第 $2$ 只蚂蚁，也被传染。

------------
 
总结以上两个例子：

设被感染的蚂蚁数为 $n$ ，第 $1$ 只蚂蚁左侧朝右的蚂蚁数为 $x$ ，第 $1$ 只蚂蚁右侧朝左的蚂蚁数为 $y$。
1. 第 $1$ 只蚂蚁朝左时，

① $x≠0$ 时， $n=x+y+1$；

② $x=0$ 时， $n=1$；

2. 第 $1$ 只蚂蚁朝右时，

① $y≠0$ 时， $n=x+y+1$；

② $y=0$ 时， $n=1$ 。

------------

代码：
```c++
#include<bits/stdc++.h>
using namespace std;

int x[55];

int main(){
	int n;
	cin>>n;
    for(int i=1; i<=n; i++) scanf("%d",&x[i]);
    int l=0,r=0;
    for(int i=2; i<=n; i++){
        if(abs(x[i])<abs(x[1]) && x[i]>0) l++;
        if(abs(x[i])>abs(x[1]) && x[i]<0) r++;
    }
    int sum=0;
    if(x[1]<0){
        if(l==0) sum=1;
        else sum=l+r+1;
    }
    else{
        if(r==0) sum=1;
        else sum=l+r+1;
    }
    cout<<sum;
    return 0;
}
```

注释版：
```c++
#include<bits/stdc++.h>
using namespace std;

int x[55];//定义蚂蚁数组

int main(){
	int n;//定义蚂蚁数
	cin>>n;//输入蚂蚁数
    for(int i=1; i<=n; i++) scanf("%d",&x[i]);//输入每个蚂蚁的情况
    int l=0,r=0;//统计在第1只蚂蚁左侧朝右、右侧朝左的蚂蚁数。
    for(int i=2; i<=n; i++){
        if(abs(x[i])<abs(x[1]) && x[i]>0) l++;//左侧朝右
        if(abs(x[i])>abs(x[1]) && x[i]<0) r++;//右侧朝左
    }
    int sum=0;//定义感冒蚂蚁总数
    if(x[1]<0){//第1只蚂蚁朝左
        if(l==0) sum=1;
        else sum=l+r+1;
    }
    else{//第1只蚂蚁朝右
        if(r==0) sum=1;
        else sum=l+r+1;
    }
    cout<<sum;//输出
    return 0;//华丽结束
}
```

---

## 作者：Purple_Circle (赞：12)

相信很多同学看到题面都会执着于如何模拟两个蚂蚁相撞后的状态，其实很简单，我们只要认为这 $n$ 只蚂蚁 ~~都是幽灵~~ 都互相可以穿过，那么两只蚂蚁相撞就可以看作两只蚂蚁互相穿过。

注：下文用 $l$ 表示向左走的蚂蚁数量，$r$ 表示向右走的蚂蚁数量。

对于患病的蚂蚁来说，当它向右走时，它右边的蚂蚁向左走，那这只蚂蚁就会被感染。同理得如果患病的蚂蚁向左走，那他左边的蚂蚁向右走就会被感染。也就是说，**与它相向而行且在它的运动方向上的蚂蚁会被感染**。则我们可以得到式子 $ans=l+r+1$，其中 $+1$ 是因为有一只患病的蚂蚁。

不过还有一种特殊情况，就是所有的蚂蚁都不在患病蚂蚁的运动方向上，由于所有蚂蚁运动速度相同，所以永远无法感染到任何一个蚂蚁，此时 $ans=1$。

### My code

```cpp
#include <bits/stdc++.h>
#define rd read()
#define getchar() (strto1==strto2&&(strto2=(strto1=fsr)+fread(fsr,1,1<<15,stdin),strto1==strto2)?EOF:*strto1++)
char fsr[1<<15],*strto1=fsr,*strto2=fsr;
using namespace std;
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * f;
}
int n,now,l,r;
int main(){
	n=rd,now=rd;
	for(int i=1;i<n;i++){
		int x=rd;
		if(abs(x)<abs(now)&&x>0){
			r++;
		}else if(abs(x)>abs(now)&&x<0){
			l++;
		}
	}
	if((now<0&&!r)||(now>0&&!l)){
		cout<<"1";
	}else{
		cout<<l+r+1;
	}
	return 0;
}

```

---

## 作者：chyuya (赞：12)

# 前言
本题解属于纯模拟，没有任何需要思维的地方，适合新手食用。

# 思路模拟
相信很多同学看到题面都会执着于蚂蚁相撞的条件。

我们可以将蚂蚁走一格相当于走两个 0.5 格，所以将杆子长度看作 200 格，把走 0.5 格看作 1 格，**如果碰面绝对有坐标相等的情况**(~~实践出真知~~)。

代码有注释。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node {
	int a,b,c;//a=蚂蚁坐标 b=蚂蚁方向(-1向左,1向右) c=蚂蚁是否被感染 
} ant[60];
int ans;
//结构体快排需要写cmp函数
bool cmp(node i,node j) {
	return i.a<j.a;
}
void check() {
	for(int i=2; i<=n; i++) {
		if(ant[i].a==ant[i-1].a&&ant[i].b!=ant[i-1].b) {//蚂蚁坐标相同方向相反
  			//两只蚂蚁如果有一只被感染则都被感染
			if(ant[i].c==1)
				ant[i-1].c=1;

			if(ant[i-1].c==1)
				ant[i].c=1;
  			//交换方向
			swap(ant[i].b,ant[i-1].b);
			
		}
	}
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>ant[i].a;
		if(i==1)
			ant[i].c=1;
		if(ant[i].a<0) {
			ant[i].a=-ant[i].a*2;//转正且乘二
			ant[i].b=-1;
		} else {
			ant[i].a*=2;//同上
			ant[i].b=1;
		}
	}
	int sum=0;
	sort(ant+1,ant+n+1,cmp);
	while(1) {
		for(int i=1; i<=n; i++) {
			if(ant[i].b==1) {
				ant[i].a+=1;//右走一格
			} else if(ant[i].b==-1) {
				ant[i].a-=1;//左走一格
			}
			if(ant[i].a>=200)
				ant[i].b=0,ant[i].a=1000;//超出范围，
			if(ant[i].a<0)
				ant[i].b=0,ant[i].a=1000;
		}
		sum=0;//统计多少蚂蚁爬出杆子范围
		for(int i=1;i<=n;i++)
			if(ant[i].b==0)
				sum++;
		if(sum>=n) 
			break;
  		//排序,便于统计蚂蚁坐标
		sort(ant+1,ant+n+1,cmp);
		check();
	}
  	//统计多少蚂蚁被感染
	for(int i=1;i<=n;i++)
		if(ant[i].c==1)
			ans++;
	cout<<ans;
	return 0;
    	//愉快的结束
}
```


------------
~~我是不会告诉你我调了半个小时的~~。

---

## 作者：Wind_Smiled (赞：5)

## 题意
第一行输入一个整数 $n(1<n<50)$ 表示蚂蚁的总数。

接着的一行是 $n$ 个用空格分开的整数 $X_i(-100<X_i<100)$，$X_i$ 的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现 $0$ 值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。

要求输出 $1$ 个整数，表示最后感冒蚂蚁的数目。

## 分析
首先，我们自然而然的想到和 [P1007独木桥](https://www.luogu.com.cn/problem/P1007) 的机制是一样的，我们只需要把蚂蚁的相遇并掉头视作互相穿过，这里不再赘述，因为我要来讲一种新的方法。

### 做法
显然，~~因为这是一道简单的入门题，所以~~我们首先想到的就是靠公式推导。但是，对于这一题并不可取。虽然可以通过此题，但若是数据毒瘤一点，就会出错。

这一题对于公式法，只需要一种数据即可推翻：就是满足有一只蚂蚁和另一只蚂蚁碰面，但是此时并没有生病，反而是穿过之后的某一时间点被传染。就和我在讨论版发出的[帖子](https://www.luogu.com.cn/discuss/517576)一样，找出了对于前两篇题解的 hack 数据，所以我就立即排除掉了公式法推算数目的程序。所以此题正解就只能大模拟或者加一点技巧的搜索。

我们首先自然要用结构体记录每一只蚂蚁的各种状态，需要储存蚂蚁的绝对位置，朝向，被感染时的时间，以及是否被感染。
```cpp
struct node{
	int x,cx,t,ill;//x记录位置，cx记录朝向，t记录被感染时的时间，ill记录是否被感染。
}a[55];
```

我们可以先根据题意写出两个相遇的条件。（或者只写一个，调用时把参数交换就行）
```cpp
bool onleft(node a,node b){//前者在左侧，后者在右侧
	if(a.x<b.x&&a.cx>b.cx){//cx是 0,1 记录，所以大于就代表了前者为 1，后者为 0 
		return 1;
	}
	return 0;
}
bool onright(node a,node b){//前者在右侧，后者在左侧
	if(a.x>b.x&&a.cx<b.cx){//cx是 0,1 记录，所以小于就代表了前者为 0，后者为 1 
		return 1;
	}
	return 0;
}
```

然后，我们可以开始构思程序主体。

首先，我们一定要把第一位的病原数据设置为已感染。接下来就可以写出读入数据的转化：
```cpp
for(int i=1;i<=n;i++){
	scanf("%d",&x1);
	a[i].x=abs(x1);//取绝对位置 
	if(x1>0){//往右走 
		a[i].cx=1;//朝向标记为 1 
	}
}
```
接下来，我们整理数据，可以将数据按绝对位置排序。因为是结构体，所以要手写 `cmp` 函数进行排序的标准。但是没必要对第一位排序，因为我们以后对第一位都是直接调用，否则需要另一个参数判断是否为病原。
```cpp
bool cmp(node a,node b){//结构体排序要用手写 cmp 函数 
	return a.x<b.x;
}
```
接下来，对于每一个数据都存在两种情况：已生病和未生病。
所以对情况进行分条判断。

若是已生病的情况，则在所有数据中扫描（可以除去第一位）。若满足传染条件且扫描的那一位没有被感染（如果已被感染还要继续扫描就需要取 $t$ 的最小值）：当前已感染的蚂蚁被感染的时间要小于这两只蚂蚁的相遇时间：`a[i].t<abs(a[i].x-a[j].x)`

且两只蚂蚁可以相遇：
```cpp
(onleft(a[i],a[j])||onright(a[i],a[j]))
```

就把这一只蚂蚁算出感染时间并标记：
```cpp
a[j].t=abs(a[i].x-a[j].x)/2;//算出被感染的时间
a[j].ill=1;//打上已被感染的标记
```

否则就是没有生病。那么我们需要将所有数据（是否去除第一个不影响，若是追求极限时间，可以去掉）进行判断。

如果枚举的那一位是已生病的，则可以进行判断感染时间和是否可以相遇，和上文相同。

若找到了可以使这个蚂蚁被感染的方法，算出时间，打上标记，立即跳出循环。

最后，我们判断一下有几只蚂蚁被感染，如果已经被感染了，就累加答案。
```cpp
for(int i=1;i<=n;i++){//统计被感染的数目 
	if(a[i].ill==1){//如果被感染 
		ans++;//累加答案 
	}
}
```

时间复杂度：$O(n^2)$，足已通过此题。

最终代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x1,ans;
struct node{
	int x,cx,t,ill;//x记录位置，cx记录朝向，t记录被感染时的时间，ill记录是否被感染。
}a[55];
bool cmp(node a,node b){//结构体排序要用手写 cmp 函数 
	return a.x<b.x;
}
bool onleft(node a,node b){//前者在左侧，后者在右侧
	if(a.x<b.x&&a.cx>b.cx){//cx是 0,1 记录，所以大于就代表了前者为 1，后者为 0 
		return 1;
	}
	return 0;
}
bool onright(node a,node b){//前者在右侧，后者在左侧
	if(a.x>b.x&&a.cx<b.cx){//cx是 0,1 记录，所以小于就代表了前者为 0，后者为 1 
		return 1;
	}
	return 0;
}
int main(){
	//freopen("t1.in","r",stdin);
	//freopen("t1.out","w",stdout);
	scanf("%d",&n);
	a[1].ill=1;
	for(int i=1;i<=n;i++){
		scanf("%d",&x1);
		a[i].x=abs(x1);//取绝对位置 
		if(x1>0){//往右走 
			a[i].cx=1;//朝向标记为 1 
		}
	}
	sort(a+2,a+n+1,cmp);//排序使数据有序 
	for(int i=1;i<=n;i++){
		if(a[i].ill==1){
			for(int j=2;j<=n;j++){
				if(a[j].ill==0){
					if(a[i].t<abs(a[i].x-a[j].x)&&(onleft(a[i],a[j])||onright(a[i],a[j]))){
						a[j].t=abs(a[i].x-a[j].x)/2;//算出被感染的时间
						a[j].ill=1;//打上已被感染的标记
					}
				}
			}
		}
		else{
			for(int j=1;j<=n;j++){
				if(a[j].ill==1){
					if(a[j].t<abs(a[i].x-a[j].x)&&(onleft(a[i],a[j])||onright(a[i],a[j]))){
						a[i].t=abs(a[i].x-a[j].x)/2;//算出被感染的时间
						a[i].ill=1;//打上已被感染的标记
						break;//已被感染可以不用继续枚举 
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){//统计被感染的数目 
		if(a[i].ill==1){//如果被感染 
			ans++;//累加答案 
		}
	}
	printf("%d",ans);
	return 0;
}
```
其实这一题如果此种做法是唯一正解的话，难度还是不低的，但是可能是数据的缘故，可以用公式法推导答案，在此就不奉上啦。

---

## 作者：clarinet_pht (赞：0)

## 题意简述：
在长为 $100$ 厘米的杆子上有 $n$ 只蚂蚁，每只蚂蚁以 $1$ 厘米每秒的速度向左或向右爬行。当两只蚂蚁相遇时，它们会同时掉头并传播感冒（若其中一只感冒）。已知第一只蚂蚁感冒，求最终感冒的蚂蚁数量。

## 思路：
利用蚂蚁相遇掉头的等效性质：可以视为蚂蚁穿过彼此继续前进，感冒会传播给相遇的蚂蚁。

### 统计：

在感冒蚂蚁左侧且向右爬的蚂蚁（会与感冒蚂蚁相遇）。

在感冒蚂蚁右侧且向左爬的蚂蚁（会与感冒蚂蚁相遇）。

### 分类讨论：
令感冒的蚂蚁数量为 $x$，左侧向右蚂蚁数为 $a_l$，右侧向左蚂蚁数为 $a_r$。 

* 若感冒蚂蚁向右爬：若其右侧存在向左爬的蚂蚁，则 $x=1+a_l+a_r$。否则，$x=1$。

* 若感冒蚂蚁向左爬：若其左侧存在向右爬的蚂蚁，则 $x=1+a_l+a_r$。否则，$x=1$。

时间复杂度：$O(n)$，其中 $n \leq 50$，可以通过此题。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int ants[200010];
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
		cin>>ants[i];
	int c=ants[0];
	int pc=abs(c);
	int cntl=0;//左侧向右爬的蚂蚁数
	int cntr=0;//右侧向左爬的蚂蚁数
	for(int i=1;i<n;i++)
	{
		int a=ants[i];
		int pa=abs(a);
		if(pa<pc&&a>0)
			cntl++;
		else if(pa>pc&&a<0)
			cntr++;
	}
	int ans;
	if(c<0)
	{
		//感冒蚂蚁向左爬
		if(cntl>0)
			ans=1+cntl+cntr;
		else
			ans=1;
	}
	else
	{
		//感冒蚂蚁向右爬
		if(cntr>0)
			ans=1+cntl+cntr;
		else
			ans=1;
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：chenxinran12 (赞：0)

### 题意分析
给定 $n$ 个蚂蚁在一条数轴上，有的向左行，有的向右行，其中第一只蚂蚁有病，他每经过一只蚂蚁就会将其感染，问最多有多少只蚂蚁被感染。
### 思路
其实调头这个操作根本没必要做。因为每只蚂蚁的速度都一样，所以掉头就是**两只蚂蚁相互穿过**。  
因为蚂蚁 $1$ 被感染，所以先判定与蚂蚁 $1$ 相遇的数量，如果没有答案当然为 $1$，如果有则答案还要加上那些与蚂蚁 $1$ 同向且相对在蚂蚁 $1$ 之后的数量。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x[52],ans=1;
pair<int,int> vis[102];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin>>n;
    for(int i=0;i<n;i++)
	{
		cin>>x[i];
		vis[abs(x[i])]={1,(x[i]<=0)};
	}
	x[0]=abs(x[0]);
	if(vis[x[0]].second==1)
	{
		bool q=0;
		for(int i=x[0]-1;i>=0;i--)
			if(vis[i].first&&vis[i].second==0) ans++,q=1;
		if(q)
			for(int i=x[0]+1;i<=100;i++)
				if(vis[i].first&&vis[i].second==1)
					ans++;
	}
	else
	{
		bool q=0;
		for(int i=x[0]+1;i<=100;i++)
			if(vis[i].first&&vis[i].second==1) ans++,q=1;
		if(q)
			for(int i=x[0]-1;i>=0;i--)
				if(vis[i].first&&vis[i].second==0)
					ans++;
	}
	cout<<ans;
    return 0;
}
```

---


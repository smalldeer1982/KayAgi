# [蓝桥杯 2014 省 AB] 地宫取宝

## 题目描述

X 国王有一个地宫宝库。是 $n \times m$ 个格子的矩阵。每个格子放一件宝贝。每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 $k$ 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 $k$ 件宝贝。

## 说明/提示

时限 1 秒, 256M。蓝桥杯 2014 年第五届省赛

## 样例 #1

### 输入

```
2 2 2
1 2
2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 2
1 2 3
2 1 5```

### 输出

```
14```

# 题解

## 作者：_cpp (赞：23)

这题考查我们对记忆化搜索的掌控。


### Code 1：

首先，暴力搜索。对于任何一个点，都有四种状态，分别是：向右走，不拿；向下走，不拿；向右走，拿；向下走，拿。只要分别搜索这四个状态，再加边界值。，我们的第一份暴力代码就完成了。注意，还有一个特判。那就是终点前有两种状态，一种为不拿终点格子中的宝物，并且手上的宝物正好为 $k$ 件。还有一种是到终点了，手上只有 $k-1$ 件宝物，并且终点格子中的宝物价值比小明手中任意宝贝价值都大，那也可以算一种方案。预计得分60。 
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD = 1000000007;
int n,m,k;
int map[59][59];
int ans=0;
void dfs(int x, int y, int maxV, int num){
	if(x==n+1 || y==m+1)	return;  //边界
	if(x==n && y==m){    //到终点了
		if(num==k || num==k-1&&map[x][y]>maxV){
			ans++; //到终点前有两种状态
		}
		ans %= MOD;  //注意取模
		return;
	}
	dfs(x,y+1,maxV,num);
	dfs(x+1,y,maxV,num);
	if(map[x][y] > maxV){
		dfs(x,y+1,map[x][y],num+1);
		dfs(x+1,y,map[x][y],num+1); //四种状态的搜索
	}
}
int main(){
	cin >> n >> m >> k;
	for( int i=1; i<=n; i++ )
		for( int j=1; j<=m; j++ ) cin >> map[i][j];
	dfs(1,1,-1,0); //注意，一开始最大值要为-1
	cout << ans;
	return 0;
}
```

### Code 2：
要想拿到满分，就要用记忆化搜索。简单来说，就是拿一个 $cache$ 数组分四维，分别记录上面说过的四种状态。如果有之前算过的值，那就直接返回，如没有，就算，算好后再存入数组中。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int MOD = 1000000007;
int cache[59][59][14][14],Map[59][59],n,m,k; 
int dfs(int x, int y, int maxV, int num){
	if(x==n+1 || y==m+1) return 0;  //边界
	if(cache[x][y][maxV+1][num] != -1){
		return cache[x][y][maxV+1][num]; //如果有值了，就直接返回
	}
	long long res=0;
	if(x==n && y==m){
		if(num==k || num==k-1&&Map[x][y]>maxV){
			res++;  //到终点了
		}
	}else{   
		res += dfs(x,y+1,maxV,num);  //计算四种状态
		if(Map[x][y] > maxV){
			res += dfs(x,y+1,Map[x][y],num+1);
		}
		res += dfs(x+1,y,maxV,num);
		if(Map[x][y] > maxV){
			res += dfs(x+1,y,Map[x][y],num+1);
		}	
	} 
	cache[x][y][maxV+1][num] = res % MOD;  //储存运算结果
	return cache[x][y][maxV+1][num];  //返回
}
int main()
{
	cin >> n >> m >> k;
	for( int i=1; i<=n; i++ )
		for( int j=1; j<=m; j++ ) cin >> Map[i][j];
	memset(cache,-1,sizeof(cache));  //注意要初始化为-1
	cout << dfs(1,1,-1,0);
	return 0;
}
```


---

## 作者：Tomwsc (赞：13)

一道蓝桥杯的记忆化搜索题（~~其实是因为蒟蒻本人还不会 dp 才用的 dfs~~）。

## 1. 题意：

小明从一个迷宫的左上角走到右下角，每个格子上都有一个宝物。小明可以将宝物取走，也可不取，但前提是这个格子里的宝物比小明手上的最大的宝物要大。问有多少种可能性能取到 $k$ 种宝物。


## 2. 思路及代码实现：


刚看完题目的第一眼就会想到~~暴力解法~~。

即为暴力搜索，每次都枚举 4 种可能的情况：

1. 向下走，取走了宝物。

2. 向下走，没取宝物。

3. 向右走，取走了宝物。

4. 向右走，没取宝物。

所以我们便可以枚举两种方向以及两种状态，如果越界就直接返回，如果到达目的地（右下角）再判断是否满足条件，若满足就方案数加一。接着我们便可以写出 dfs 了（其他详见注释）。

代码如下：

```cpp
#include<bits/stdc++.h>		//懒人万能头文件
#define int long long		//宏定义省事
using namespace std;
const int P = 1e9 + 7;		//不要忘记取模
int n , m , k , cnt;
int a[55][55];		
int dx[2] = {1 , 0};		//两种方向
int dy[2] = {0 , 1};

void dfs(int x , int y , int num , int maxn)		//x与y记录当前行列坐标，num记录当前已拿的物品总数，maxn记录当前物品最大值
{
	if(x > n || y > m)	return;		//越界了就直接返回
	if(x == n && y == m){		//到达右下角
		if(num == k || num + 1 == k && a[x][y] > maxn)		//满足条件，cnt ++
			++ cnt , cnt %= P;
		return;
	}
	else{
		for(int i = 0;i < 2;i ++){		//枚举两种方向
			int xx = x + dx[i];
			int yy = y + dy[i];
			dfs(xx , yy , num , maxn);
			if(a[x][y] > maxn)		//能否拿格子上的物品
			dfs(xx , yy , num + 1, a[x][y]);
		}
	}
	return;
}
signed main()
{
	cin >> n >> m >> k;		//输入
	for(int i = 1;i <= n;i ++)		//还是输入
		for(int j = 1;j <= m;j ++)
			cin >> a[i][j];		
	dfs(1 , 1 , 0 , -1);		//搜索
	cout << cnt << endl;		//这次是输出
	return 0;
}
```
但这个代码只能拿差不多一半的分，怎么办呢？

**记忆化搜索隆重登场！**

## 3. 什么是记忆化搜索：


顾名思义，记忆化搜索的意思便是把搜索到的结果记录下来，下次搜索到时便可以直接将结果返回，可以大大降低时间复杂度。

比如说递归求斐波那契，如果不用记忆化，必超时。


## 4. 怎样实现记忆化搜索：


其实并不难，只需要定义一个数组来保存搜索到的结果即可。

那在这道题中，我们如何用记忆化搜索来实现优化呢？

~~显而易见~~，我们只需要定义一个四维数组（~~惊~~）`mem[55][55][15][15]`，每个 `mem[x][y][maxn][num]` 记录的是当前位置的方案总数。而如果记忆数组已经保存了此方案的结果，就可以直接返回，否则再继续搜索。其它几乎和暴力差不多。


不多说了，直接上代码，~~我知道你们只看这个~~：

```cpp
#include<bits/stdc++.h>		//懒人万能头文件
#define int long long		//宏定义省事
using namespace std;
const int P = 1e9 + 7;		//记得取模
int n , m , k , ans;
int a[55][55];
int dx[2] = {1 , 0};		//两种方向
int dy[2] = {0 , 1};
int mem[55][55][15][15];		//记忆数组

int dfs(int x , int y , int num , int maxn)		//x与y记录当前行列坐标，num记录当前已拿的物品总数，maxn记录当前物品最大值
{
	if(x > n || y > m)	return 0;		//越界了就直接返回0
	if(mem[x][y][maxn][num] != -1)	return mem[x][y][maxn][num];		//如果mem数组的值不为-1就直接返回
	int cnt = 0;		//记录方案数
	if(x == n && y == m)
	{
		if(num == k || num == k - 1 && a[n][m] > maxn)
			++ cnt , cnt %= P;
	}
	else
	{
		for(int i = 0;i < 2;i ++)		//枚举两种方向
		{
			int xx = x + dx[i];
			int yy = y + dy[i];
			cnt += dfs(xx , yy , num , maxn);
			if(a[x][y] > maxn)		//能否拿格子上的物品
				cnt += dfs(xx , yy , num + 1, a[x][y]);
		}
	}
	mem[x][y][maxn][num] = cnt % P;		//记录当前情况的值
	return mem[x][y][maxn][num];		//直接返回即可
}	

signed main()
{
	memset(mem , -1 , sizeof(mem));		//不要忘了初始化
	cin >> n >> m >> k;		//输入
	for(int i = 1;i <= n;i ++)		//还是输入
		for(int j = 1;j <= m;j ++)
			cin >> a[i][j];
	cout << dfs(1 , 1 , 0 , -1) % P;		//这次是输出
	return 0;
}
```

本蒟蒻的第一篇题解，求管理员大人一定要给过啊！！！

欢迎各位 dalao 批评指正。

---

## 作者：Nathan123 (赞：12)

# 分析
1. 首先明确$dp$数组含义，**很重要**。$dp[i][j][k][c]$ ：走到$(i, j)$，拿取k个宝贝，且这些宝贝中的具有最大价值的宝贝的价值为c的方案数。
2. 初始化（在$(1, 1)$拿或不拿宝贝），其他保持默认值0就可以了。

(1) $dp[1][1][1][w[1][1]] = 1$,这是拿的初始化，方案数为1。

我们再看不拿，如果不拿，那么最大价值就不存在，可以用-1代替，但是C++中数组索引不允许负数，所以我们可以把宝贝价值都加1，从$0 ...12$变成$1...13$，那么就可以用0表示最大价值不存在。

(2) $dp[1][1][0][0] = 1$,这是不拿的初始化，方案数为1。

3. 明确动态转移过程。 

假设我们现在在$dp[i][j][k][c]$,那么可以从哪些地方转移而来呢？

首先，大体上看，来自上方$(i - 1, j)$，或者左方$(i, j - 1)$。这两种情况**之中**，又各自有在$(i, j)$位置的宝贝取和不取的情况，其中取的要加一层循环，不取的比较简单，具体细节可以看看代码注释，分析到此结束。

# 代码以及注释
```cpp
#include <iostream>
using namespace std;
const int MOD = 1000000007;
const int N = 55;
int w[N][N]; // 坐标(i, j)宝贝价值
// dpp[i][j][k][c] : 走到(i, j),拾取k个宝贝，且所有宝贝中最大的价值为c的方案数
int dp[N][N][13][14];

int main() {
    int n, m, k;
    cin >> n >> m >> k;
    // 收集物品价值，扩展到1～13，0代表还没有拾取物品
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> w[i][j];
            w[i][j]++;
        }
    }
    // 初始化
    dp[1][1][1][w[1][1]] = 1; 
    dp[1][1][0][0] = 1; 
    // 开始动态规划
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
        	// (1, 1)的所有情况都初始化过了，直接跳过
            if (i == 1 && j == 1) continue;
            for (int u = 0; u <= k; u++) {
                for (int v = 0; v <= 13; v++) {
                    int &val = dp[i][j][u][v]; // dp数组常用，这样方便后面用到时好写
                    val = (val + dp[i - 1][j][u][v]) % MOD; // 来自上方且不取(i, j)的宝贝
                    val = (val + dp[i][j - 1][u][v]) % MOD; // 来左边且不取(i, j)的宝贝
                    // 下面是取(i, j)宝贝情况
                    if (u > 0 && v == w[i][j]) // u > 0 才能取，根据dp定义以及题目含义，取的(i, j)宝贝价值w必须为v
                    { 
                        for (int c = 0; c < v; c ++ ) // 上一个状态的最大价值宝贝的价值有很多可能，但一定价值小于v
                        { 
                            val = (val + dp[i - 1][j][u - 1][c]) % MOD; // 转移自上方且取(i, j)的宝贝
                            val = (val + dp[i][j - 1][u - 1][c]) % MOD; // 转移自左边且取(i, j)的宝贝
                        }
                    }
                }
            }
        }
    }
    // 计算答案，累加各种c的可能
    int res = 0;
    for (int c = 0; c <= 13; c++) {
        res = (res + dp[n][m][k][c]) % MOD;
    }
    cout << res;
    return 0;
}
```


---

## 作者：ryf_loser (赞：5)

此题建议评绿。

此题正解记忆化搜索或者动态规划。

如果此题爆搜，仅仅拿到一半的分数。

动态规划思路在此题解中并不讲述。

记忆化搜索是对某一种重复出现情况进行记录。

此题我们要明确递归参数是什么，通过探究我们可以得知： $x,y$ 表示所在位置，$maxx$ 表示手里有的物品的最大值，$step$ 表示共取了多少个物品。

则递归就是 `dfs(x,y,maxx,step)`。

对于记忆化数组，也是记录 $s[x][y][maxx][step]$ 的值，因为记忆化搜索原理，记录与此节点相似节点的值，然后直接返回即可。

根据记忆化搜索易得程序。

AC CODE

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,k,a[60][60],s[60][60][15][15];
int dfs(int x,int y,int maxx,int step){
	if (x==n+1||y==m+1)return 0;//边界条件。
	if (s[x][y][maxx+1][step]!=-1)return s[x][y][maxx+1][step];//记忆化搜索。
	long long cnt=0;
	if (x==n&&y==m){
		if (step==k||(step==k-1&&a[x][y]>maxx))
			cnt++;
	}
	else {
		cnt+=dfs(x,y+1,maxx,step);
		if (a[x][y]>maxx)cnt+=dfs(x,y+1,a[x][y],step+1);
		cnt+=dfs(x+1,y,maxx,step);
		if (a[x][y]>maxx)cnt+=dfs(x+1,y,a[x][y],step+1);//怎样搜索。
	}
	s[x][y][maxx+1][step]=cnt%1000000007;
	return s[x][y][maxx+1][step];
}
int main(){
	scanf ("%d%d%d",&n,&m,&k);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			scanf ("%d",&a[i][j]);//读入
	memset(s,-1,sizeof(s));//赋值为 -1。
	printf ("%d",dfs(1,1,-1,0));
	return 0;
}
```


---

## 作者：FISH酱 (赞：4)

## 前言

本题主要考察动态规划、记忆化搜索、DP。本篇题解主要讲解记忆化搜索方法。

这题看似简单，但是坑点和细节真的很多，适合训练代码能力和排错能力。

## 思路与代码

首先我们使用普通暴力搜索实现一次，搜索时传入四个参数，$x$ 表示当前的行下标，$y$ 表示当前的列下标，$sum$ 表示当前拾取了几件宝贝，$maxn$ 表示当前宝贝中的最大价值，其他按照题意模拟即可，下面是一份暴搜代码：

```cpp
#include <bits/stdc++.h> // 万能头

using namespace std; // 命名空间

#define ll long long
#define ld long double
#define endl '\n'

int n,m,k,ans; // 题目中所述的三个变量n,m,k，和累计方案数的变量 ans
int a[100][100]; // 数组存储宝物价值
bool vis[100][100]; // 标记数组

int dx[2]={0,1}; // 偏移量1
int dy[2]={1,0}; // 偏移量2

void dfs(int x,int y,int sum,int last){ // 参数含义：当前的行下标、当前的列下标、当前拾取了几件宝贝、当前宝贝中的最大价值
	if(sum>k) return; // 手上超过了k件宝贝就退出，算是一个剪枝优化
	if(x==n&&y==m){ // 到达终点的特判
		if(sum==k) ans+=1,ans%=1000000007; // 判断是否恰好有k件宝贝，并且累加、取模
		return; // 退出，不需要继续搜索
	}

	for(int i=0;i<2;i++){ // 搜索两个方向
		int nx=x+dx[i],ny=y+dy[i]; // 计算下一个位置

    // 判断下一个位置是否合法，保证在边界内且没有走过
		if(1<=nx&&nx<=n&&1<=ny&&ny<=m&&vis[nx][ny]==0){
			dfs(nx,ny,sum,last); // 不拾取下一个点的宝贝
			if(a[nx][ny]>last){ // 判断是否能拾取
				dfs(nx,ny,sum+1,a[nx][ny]); // 拾取下一个点的宝贝
			}
		}
	}
}

int main(){
	cin >> n >> m >> k; // 读入n,m,k

	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin >> a[i][j]; // 读入宝贝价值
		}
	}

	vis[1][1]=1; // 起点标记
	dfs(1,1,0,-1); // 不拾取起点宝贝
	dfs(1,1,1,a[1][1]); // 拾取起点宝贝
	vis[1][1]=0; // 起点取消标记

	cout<<ans%1000000007; // 输出答案，注意取模

	return 0; // 结束
}
```

显然，这份代码会超时，只能拿到四十二分，我们需要时间复杂度更优秀的算法，接下来我们介绍正解：记忆化搜索。

记忆化搜索的本质是记录每个点的答案，防止重复搜索同一个点，节约时间。我们可以定义一个记忆化数组，$dp[i][j][q][w] = e$ ，表示行下标为 $i$ 、列下标为 $j$ 、拾取了 $q$ 件宝贝、当前宝贝中的最大价值为 $w$ 的情况下，从当前点走到终点的答案是 $e$ 种方案。每次搜索时检查是否已经搜索过这种情况，如果是就返回记录的答案，如果不是就正常搜索模拟，存储到记忆化数组。

其实记忆化搜索的代码只需要在暴搜的基础上简单修改即可。根据上述思路，我们可以写出以下代码：

```cpp
#include <bits/stdc++.h> // 万能头

using namespace std; // 命名空间

#define ll long long
#define ld long double
#define endl '\n'

int n,m,k; // 题目中所述的三个变量
int a[100][100]; // 数组存储每个位置的宝贝价值
ll dp[60][60][20][20]; // 记忆化数组，这里需要开 long long！！！

int dx[2]={0,1}; // 偏移量1
int dy[2]={1,0}; // 偏移量2

int dfs(int x,int y,int sum,int last){ // 参数含义：当前的行下标、当前的列下标、当前拾取了几件宝贝、当前宝贝中的最大价值
	if(dp[x][y][sum][last+1]!=-1) return dp[x][y][sum][last+1]%1000000007; // 如果已经搜索过这种情况，直接返回记忆化数组中对应的答案

	if(x==n&&y==m){ // 到达终点时，更新记忆化数组，并且返回存储的方案数答案
		if(sum==k || (sum==k-1&&last<a[n][m])) dp[x][y][sum][last+1]=1;
		else dp[x][y][sum][last+1]=0;
		return dp[x][y][sum][last+1];
	}

	dp[x][y][sum][last+1]=0; // 初始化当前情况
	for(int i=0;i<2;i++){ // 两个方向
		int nx=x+dx[i],ny=y+dy[i]; // 拓展下一个点，计算位置

		if(1<=nx&&nx<=n&&1<=ny&&ny<=m){ // 判断下一个点是否合法，保证不越界
			dp[x][y][sum][last+1] += dfs(nx,ny,sum,last)%1000000007; // 累加不拾取当前点宝贝的情况的答案，注意取模
			if(a[x][y]>last){ // 特判是否能拾取当前点宝贝
				dp[x][y][sum][last+1] += dfs(nx,ny,sum+1,a[x][y])%1000000007; // 累加拾取当前点宝贝的情况的答案，注意取模
			}
		}
	}
	dp[x][y][sum][last+1]%=1000000007; // 取模

	return dp[x][y][sum][last+1]; // 返回记录的方案数答案
}

int main(){
	cin >> n >> m >> k; // 读入

	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin >> a[i][j]; // 读入宝贝的价值
		}
	}
	for(int i=0;i<60;i++){
		for(int j=0;j<60;j++){
			for(int q=0;q<20;q++){
				for(int w=0;w<20;w++){
					dp[i][j][q][w]=-1; // 初始化记忆化数组，先将每一种情况标记为未搜索
				}
			}
		}
	}

	int ans=dfs(1,1,0,-1); // 开始搜索，并使用变量存储答案，注意第一次搜索时的宝贝最大价值要设为-1，因为宝贝价值有可能为0
	ans%=1000000007; // 取模
	cout<<ans; // 输出

	return 0; // 结束
}
```

## 坑点

1. 记忆化数组需要开 long long。
2. 注意取模是否到位。
3. 拓展下一个点时特判是否越界。
4. 记忆化数组大小要合理且正确。
5. 偏移量不能写错，注意方向。
6. 第一次搜索时的宝贝最大价值要设为 $-1$ ，因为宝贝价值有可能为 $0$ 。
7. 第一次搜索时当前宝贝最大价值初始为负数，数组没有负下标，我们存储时可以统一加一处理。

注意细节，认真审题，肯定能写出来，加油吧。

---

## 作者：Angelastar (赞：2)

**记忆化搜索**

看各位大佬都在写动态规划，可我只会写记忆化搜索啊。

---

**思路**

从左上角开始，向下或向右移动，记录手里宝物最大价值和宝物数量。对于每个点，如果这个点的宝物比手里宝物最大价值大，搜索取和不取两种情况，并更新宝物最大价值。

---

**代码**
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=55;
const ll mod=1e9+7;
int n,m,k,a[N][N];
ll f[N][N][15][15];//记忆化数组
ll dfs(int x,int y,int maxt,int cnt){//maxt在记录状态时一定要加1，不然就会访问负下标和作者一样难受
	if(f[x][y][maxt+1][cnt]>=0)return f[x][y][maxt+1][cnt];//状态搜索过直接返回
	f[x][y][maxt+1][cnt]=0;
	if(x==n&&y==m){
		if(cnt==k||(cnt==k-1&&maxt<a[n][m])){
			f[x][y][maxt+1][cnt]++;
		}
	}else{//四种情况
		int xx=x+1,yy=y+1;
		if(xx<=n){
			f[x][y][maxt+1][cnt]+=dfs(xx,y,maxt,cnt);
			if(a[x][y]>maxt)f[x][y][maxt+1][cnt]+=dfs(xx,y,a[x][y],cnt+1);
		}
		if(yy<=m){
			f[x][y][maxt+1][cnt]+=dfs(x,yy,maxt,cnt);
			if(a[x][y]>maxt)f[x][y][maxt+1][cnt]+=dfs(x,yy,a[x][y],cnt+1);
		}
	}
	f[x][y][maxt+1][cnt]%=mod;//记得取模
	return f[x][y][maxt+1][cnt];
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)cin>>a[i][j];
	}
	memset(f,-1,sizeof(f));//初始化
	cout<<dfs(1,1,-1,0);
	return 0;
}
```

---

## 作者：null___ (赞：2)

**动态规划**

 $f[i][j][p][q]$ 表示 “走到坐标为 $(i,j)$ 的位置，拿了 $p$ 件物品，且所拿物品最大价值小于等于 $q$ 的所有方案数” 

 对于“走到坐标为 $(i,j)$ 的位置，拿了 $p$ 件物品，且所拿物品最大价值小于等于 $q$ ”的所有方案的集合可以划分为两个小集合: 
 
 $1$  .拿 $(i,j)$ 上的物品的所有方案的集合,但当 $q$ 小于 $(i,j)$ 上的物品的价值时，该集合为空集。
 
 $2$  .不拿 $(i,j)$ 上的物品的所有方案的集合

 最后状态转移方程如下 
 
 若 $q$ 大于等于 $c[i][j]$  ： $f[i][j][p][q]=f[i-1][j][p][q]+f[i][j-1][p][q]+f[i-1][j][p-1][c[i][j]-1]+f[i][j-1][p-1][c[i][j]-1]$ 

 若 $q$ 小于 $c[i][j]$ : $f[i][j][p][q]=f[i-1][j][p][q]+f[i][j-1][p][q]$   

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000007;
long long n,m,k,c[55][55],f[55][55][15][15];

int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>c[i][j];c[i][j]++;
            for(int p=0;p<=k;p++){
                for(int q=0;q<=13;q++){
                	if(i==1&&j==1&&p==0)f[1][1][p][q]=1;
                	else if(q>=c[i][j]&&i==1&&j==1&&p==1)f[1][1][p][q]=1;
                    else if(q>=c[i][j])f[i][j][p][q]=(f[i-1][j][p][q]+f[i][j-1][p][q]+f[i-1][j][p-1][c[i][j]-1]+f[i][j-1][p-1][c[i][j]-1])%mod;
                    else f[i][j][p][q]=(f[i-1][j][p][q]+f[i][j-1][p][q])%mod;
                }
            }
        }
    }
    cout<<f[n][m][k][13];
}

```

---

## 作者：TheShuMo (赞：2)

## 思路

由于题目中说了这样一句话：


要求输出一个整数，表示正好取 $k$ 个宝贝的行动方案数。该数字可能很大，输出它对 $10^9+7$ 取模的结果。

$10^9+7$ 和方案数很大直接否决了暴力搜索的可能性，所以我们应该使用动态规划！


状态： $dp [ x ] [y][k][c]$ 为 当前坐标在 $(x,y)$ 时，已经拿了 $k$ 个宝贝，当前宝贝最大价值小于等于 $c$ 时，总共的方案数。

状态转移方程：

设 $mp[x][y]$ 为 $(x,y)$ 上宝物的价值，那么如果 $mp[x][y] < c$，就可以选择取和不取，否则就只能不取，所以不管怎么怎么样都要不取。

所以 设 $tp1=dp[x-1][y][k][c] + dp[x][y-1][k][c] $，


$tp2=dp[x-1][y][k-1][mp[x][y]]+dp[x][y-1][k-1][mp[x][y]]$

如果 $c>mp[x][y]$，那么 $dp[x][y][k][c]= (tp1 + tp2 )\bmod 10^9+7$
否则 $dp[x][y][k][c] = tp2 \bmod 10^9+7$

## 代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000007;
int mp[60][60];
int dp[60][60][15][15];
int main(){
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
		}
	}
	int tp2,tp1;
	for(int k=0;k<=p;++k){
		for(int c=0;c<=13;++c){
			if(k==0){
				dp[1][1][0][c]=1;
			}else{
				if(k==1&&c>mp[1][1]){
					dp[1][1][1][c]=1;
				}
			}
		}
	}//对处在起点的时候进行初始化
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			for(int k=0;k<=p;++k){
				for(int c=0;c<=13;++c){
					if(i==1&&j==1){
						continue;
					}//已经初始化的点就不走了，否则就会覆盖掉
					tp2=0;
					tp1=dp[i-1][j][k][c]+dp[i][j-1][k][c];
					if(c>mp[i][j]&&k!=0){
						tp2=dp[i-1][j][k-1][mp[i][j]]+dp[i][j-1][k-1][mp[i][j]];
					}//注意是c要大于，我之前写>=挂了好久……
					dp[i][j][k][c]=(tp1%mod+tp2%mod)%mod;
				}
			}
		}
	}cout<<dp[n][m][p][13];
}
~~~

---

## 作者：wuhan1234 (赞：1)

## 1.编程思路
采用记忆化搜索完成。

定义 $4$ 维数组 $dp[51][51][15][15]$。

设数组元素 $dp[x][y][num][val]$ 表示在坐标 $(x,y)$ 时拿了 $num$ 件宝贝并且宝贝中价值最大的为 $val$，其中 $1\le x \le n$，$1\le y \le m $，$num$ 的初值为  $0$，表示还没有拿到宝贝，$val$ 的初值本来应该为 $-1$，表示此时手上还没有宝物（因为从题目数据说明中可以看出宝贝的价值可以为 $0$），为了让 $val$ 初始值为 $0$，可以将输入的宝贝的价值统一加 $1$，这样宝贝的最小价值为 $1$（不是 $0$）。

定义二维数组 $map[51][51]$ 保存地宫各格子的宝贝价值。其中数组元素 $map[x][y]$ 表示在坐标 $(x,y)$ 处的格子中所放置宝贝的价值。

采用倒推法列出状态转移方程，即把后面的情况种数不断的往前更新。

当 $ map[x][y]>val $ 时，
$$ dp[x][y][num][val]=dp[x+1][y][num+1][map[x][y]]+dp[x][y+1][num+1][map[x][y]]$$
$$  +dp[x+1][y][num][val]+dp[x][y+1][num][val] $$

当 $ map[x][y] \le val $ 时，
$$ dp[x][y][num][val]=dp[x+1][y][num][val]+dp[x][y+1][num][val] $$

在通过 DFS 搜索方式求数组 $dp$ 的各元素值时，由于数组元素值 $dp[x][y][num][val]$ 跟位置 $(x,y)$、宝贝个数以及当前最大的宝贝价值有关，当重复遍历这个结点时，若 $dp[x][y][num][val]$ 的值已经计算出来了，则直接应用无需重复递归计算。

为此，定义数组 $dp$ 的全部元素的初始值为 $-1$。若计算时需要用到 $dp[x][y][num][val]$，此时 $dp[x][y][num][val]\ne -1 $，则无需重复调用，直接应用计算好的 $ dp[x][y][num][val]$ 元素值。之所以初值定义为 $-1$，是考虑到若路径不存在的情况（此时方案数应为 $0$）。

## 2.源程序
```c
#include <stdio.h>
#include <string.h>
#define MOD 1000000007
long long dp[51][51][15][15];
int map[51][51];
int n,m,k;
void dfs(int x, int y, int num, int val)
{
	if (dp[x][y][num][val] != -1)
		return;
	dp[x][y][num][val] = 0;
	if (x == n && y == m && num == k)
	{
		dp[x][y][num][val] = 1;
		return;
	}
	if (map[x][y] > val && num < k)
	{
		dfs(x, y, num + 1, map[x][y]);
		dp[x][y][num][val] += dp[x][y][num + 1][map[x][y]];
		dp[x][y][num][val] %= MOD;
	}
	if (x < n)  // 向下走
	{
		dfs(x + 1, y, num, val);
		dp[x][y][num][val] += dp[x + 1][y][num][val];
		dp[x][y][num][val] %= MOD;
	}
	if (y < m)  // 向右走
	{
		dfs(x, y + 1, num, val);
		dp[x][y][num][val] += dp[x][y + 1][num][val];
		dp[x][y][num][val] %= MOD;
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for (int i = 1; i <=n ; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			scanf("%d",&map[i][j]);
			map[i][j]++;
		}
	}
	memset(dp, -1, sizeof(dp));
	dfs(1, 1, 0, 0);
	printf("%d\n",dp[1][1][0][0]);
	return 0;
}

```




---

## 作者：Lcm_simida (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P8612)

注意题意可知，选取的物品价值必须是严格单调上升的，因此对于每种选取情况只需记录选了几个物品和最后一个物品的价值。

由此得到思路用 $dp_{i,j,k,l}$ 表示走到 $(i,j)$ 拿了 $k$ 个物品且最后一个物品的价值是 $l$ 的情况数，用 $dp_{i,j,k,l}=dp_{i,j,k,l}+dp_{i-1,j,k-1,t}+dp_{i,j-1,k-1,t}$ 转移即可.

注意价值是可以 $0$ 的。

---

## 作者：PDAST (赞：0)

## 思路
发现某格的方案数是由它左边和上边的格子转移来的，具有单调性，故考虑 dp。

定义状态 $f_{i,j,k,l}$ 表示走到第 $i$ 行，第 $j$ 列时，取的宝物最大值为 $k$，共取了 $l$ 个的方案数。

我们发现，当 $k \le C_{i,j}$ 时，我们可以选择取该格的物品，故列出转移方程 $f_{i,j,k,l} = \sum _{p=0}^{12} (f_{i-1,j,p,l-1} + f_{i-1,j,p,l-1})$。

当不能取该格的物品时，该格的方案数由左边的格子和上面的个子转移而来，故列出转移方程 $f_{i,j,k,l} = \sum _{p=0}^{12} (f_{i-1,j,p,l} + f_{i-1,j,p,l})$。

分类讨论以上两种情况即可，代码就不放了。

---

## 作者：pioneer2000 (赞：0)

来发到黄题题解水一下。

### 思路：

要统计使得走到终点宝物个数恰好为 $k$ 的方案数，我们可以尝试暴力搜索，每次尝试向下或向右走，以及如果能取走宝物，取或不取四种情况，那么很明显这个指数级别的复杂度肯定会超时。

考虑记忆化（你该庆幸不需要动态规划），记录下在当前位置，当前最大价值，当前宝物数量时的方案数，后通过记忆化层层递推上去，就可以大大优化时间复杂度。

注意思考如果走不到终点的话输出 $0$。

### 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
int n,m,k,a[55][55],ans,f[55][55][55][55];//f是记忆化数组
int dfs(int x,int y,int maxn,int g){
	if(x==n+1||y==m+1) return 0;
	if(f[x][y][maxn+1][g]!=-1) return f[x][y][maxn+1][g];
	ll res=0;
	if(x==n&&y==m){
		if(g==k||(g==k-1&&a[x][y]>maxn)){
			res++;
		}
	}else{
		res+=dfs(x,y+1,maxn,g);
		res+=dfs(x+1,y,maxn,g);
		if(a[x][y]>maxn){
			res+=dfs(x,y+1,a[x][y],g+1); 
			res+=dfs(x+1,y,a[x][y],g+1);
		}
	} 
	f[x][y][maxn+1][g]=res%mod;
	return f[x][y][maxn+1][g];
}
int main(){
	ios::sync_with_stdio(0);//关闭输入输出流
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;//输入
	memset(f,-1,sizeof f);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	cout<<dfs(1,1,-1,0);//记忆化搜索
	return 0;
}

```

---

## 作者：hexuchen (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8612)

[更好的阅读体验？](https://www.luogu.com.cn/article/6samqcgi)

## 思路分析

记忆化搜索好题。

看到题目，第一眼考虑搜索。因为小明可以选择拿或不拿格子里的宝物，所以对于每一个点，一共有 $4$ 种状态：向右拿宝物、向右不拿宝物、向下拿宝物、向下不拿宝物。根据这个思路，可以写出第一份暴搜代码。有一个小坑就是搜索搜不到终点，要记得特判。

## 代码一

```cpp
#include <bits/stdc++.h>
#define MOD 1000000007 //模数
using namespace std;
int n,m,k,s[60][60],ans=0;
int dh[3]={0,0,1}; //两个方向
int dl[3]={0,1,0};
void dfs(int x,int y,int max_price,int sum){ //深搜
	if(x==n && y==m){ //到达终点
		if(max_price<s[x][y] && sum==(k-1)){ //特判终点
			sum++;
		}
		if(sum==k){ //符合条件
			ans++;
		}
		ans%=MOD; //取模
		return ;
	}
	for(int i=1;i<=2;i++){ //拿上宝物的两种走法
		int dx=x+dh[i],dy=y+dl[i];
		if(dx>=1 && dx<=n && dy>=1 && dy<=m){ //没有走出格
			if(s[x][y]>max_price){ //可以拿
				dfs(dx,dy,s[x][y],sum+1);
			}
		}
	}
	for(int i=1;i<=2;i++){ //不拿宝物的两种走法
		int dx=x+dh[i],dy=y+dl[i];
		if(dx>=1 && dx<=n && dy>=1 && dy<=m){
			dfs(dx,dy,max_price,sum);
		}
	}
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	dfs(1,1,-1,0);
	cout<<ans;
	return 0;
} 
```

交上去，只有 $42$ 分，超时了。由于 $n,m \le 50$，可能的走法很多，直接暴搜一定会超时。

如果我们尝试在深搜函数中输出四个参数：

![](https://cdn.luogu.com.cn/upload/image_hosting/tocvoyqo.png)

可以明显看出，四个参数出现了很多重复，意味着有很多重复运算，浪费了大量时间。所以我们可以采用记忆化搜索的方式，用一个四维数组存四个参数的答案，如果再遇到重复的参数，可以直接从数组里取答案。

最后，十年 OI 一场空，不开 long long 见祖宗！

## AC 代码

```cpp
#include <bits/stdc++.h>
#define int long long //开 long long
#define MOD 1000000007
using namespace std;
int n,m,k,s[60][60],f[60][60][22][22]; //存四个参数的答案
bool used_f[60][60][22][22]; //存四个参数有没有答案
int dh[3]={0,0,1};
int dl[3]={0,1,0};
int dfs(int x,int y,int max_price,int sum){
	if(used_f[x][y][max_price+1][sum]){ //如果答案算过了
		return f[x][y][max_price+1][sum]; //直接用
	}	
	int ans=0;
	if(x==n && y==m){
		if(max_price<s[x][y] && sum==(k-1)){
			sum++;
		}
		if(sum==k){
			ans++;
		}
	}
	else{
		for(int i=1;i<=2;i++){
			int dx=x+dh[i],dy=y+dl[i];
			if(dx>=1 && dx<=n && dy>=1 && dy<=m){
				if(s[x][y]>max_price){
					ans+=dfs(dx,dy,s[x][y],sum+1);
				}
			}
		}
		for(int i=1;i<=2;i++){
			int dx=x+dh[i],dy=y+dl[i];
			if(dx>=1 && dx<=n && dy>=1 && dy<=m){
				ans+=dfs(dx,dy,max_price,sum);
			}
		}
	}
	ans%=MOD;
	f[x][y][max_price+1][sum]=ans;
	used_f[x][y][max_price+1][sum]=true; //更新答案
	return f[x][y][max_price+1][sum];
}
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	cout<<dfs(1,1,-1,0);
	return 0;
} 
```

---

## 作者：U•ェ•*U (赞：0)

一道简单的 $\texttt{dfs}$ 搜索题。

对于当前的点，我们分类讨论以下 $4$ 种情况：
* 向下走，不拿；
* 向右走，不拿；
* 向下走，拿；
* 向右走，拿。

注意，我们还需要特判两种情况：
* 未到终点但是已经拿满了（即拿了 $k$ 个物品）；
* 到了终点但是没有拿满，但是拿走的物品价值最大。

由于直接搜索的理论复杂度为 $4^{50}$ 次方，所以我们需要考虑使用记忆化搜索。

记忆化搜索，简单来说，就是对于每个已经搜索过的或者搜到了的点，我们将答案存到一个数组中保存，当再次搜索到时，直接返回。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, k, mp[55][55], vis[55][55][15][15];
int dfs(int x, int y, int maxn, int cnt) {
	if (x == n + 1 || y == m + 1) return 0; // 如果到达终点了
	if (vis[x][y][maxn + 1][cnt] != -1) return vis[x][y][maxn + 1][cnt];
	// 如果记忆数组中已经有值了，直接返回
	int tmp = 0; // 用于记录答案
	if (x == n && y == m) {
		if (cnt == k || (cnt == k - 1 && mp[x][y] > maxn)) tmp ++;
		// 分类讨论的两种情况
	} else {
		tmp += dfs(x, y + 1, maxn, cnt); // 不拿走
		if (mp[x][y] > maxn) tmp += dfs(x, y + 1, mp[x][y], cnt + 1);
		// 如果没有超过最大值，拿走
		tmp += dfs(x + 1, y, maxn, cnt); // 不拿走
		if (mp[x][y] > maxn) tmp += dfs(x + 1, y, mp[x][y], cnt + 1);
		// 如果没有超过最大值，拿走
	}
	return vis[x][y][maxn + 1][cnt] = tmp % 1000000007;
	// 将值赋给记忆数组，然后返回
}
signed main() {
	ios :: sync_with_stdio(false);
	cin . tie(nullptr);
	memset(vis, -1, sizeof(vis)); // 初始时记忆数组全部赋为-1
	cin >> n >> m >> k;
	for ( int i = 1; i <= n; i ++)
		for ( int j = 1; j <= m; j ++) cin >> mp[i][j];
	cout << dfs(1, 1, -1, 0) << endl;
	return 0;
}
```

---

## 作者：Starry_Ocean (赞：0)

## 暴力搜索

### 思路

对于每一个当前的合法的状态，如果他的下一步也合法，则枚举选与不选的情况。对于点 $(1,1)$，在主函数内特别考虑。

### 核心代码实现
```cpp
void DFS(ll x,ll y,ll mv,ll cnt){
//当前正在 (x,y) 点，当前拿到的宝贝的最大价值为 mv,当前一共拿到了 cnt 件宝贝
	//cout << x << " " << y << " " << mv <<  " " << cnt << endl; 
	if(x==n&&y==m){
		if(cnt==k){
			ans++;
			ans%=mod;
		}
		return ;
	} 
	
	for(ll i = 0;i < 2;++i){
		ll xx=x+dx[i];
		ll yy=y+dy[i];
		if(xx>=1&&xx<=n&&yy>=1&&yy<=m){
			if(c[xx][yy]>mv){
				DFS(xx,yy,c[xx][yy],cnt+1);
			}
			DFS(xx,yy,mv,cnt);
		}
	}
}
int main(){
    DFS(1,1,0,0);
    DFS(1,1,c[1][1],1);
	cout << ans;
	return 0;
}
```

然后就成功拿下了 [28 分](https://www.luogu.com.cn/record/179484261)的优秀成绩。

## 记忆化搜索

我们可以定义一个数组 $dp[x][y][mv][cnt]$ 存储状态，主函数内对核心函数的调用可以改为 `cout << DFS(1,1,-1,0);`。

### 核心代码实现

```cpp
ll DFS(ll x,ll y,ll mv,ll cnt){
//当前正在 (x,y) 点，当前拿到的宝贝的最大价值为 mv,当前一共拿到了 cnt 件宝贝
//	cout << x << " " << y << " " << mv <<  " " << cnt << endl; 
	if(dp[x][y][mv+1][cnt]!=-1){
		return dp[x][y][mv+1][cnt];
	}
	ll res=0;
	if(x==n&&y==m){
		if(cnt==k||(cnt+1==k&&c[x][y]>mv)){
			res++;
			res%=mod;
		}
	} 
	else{
		for(ll i = 0;i < 2;++i){
			ll xx=x+dx[i];
			ll yy=y+dy[i];
			if(xx>=1&&xx<=n&&yy>=1&&yy<=m){
				res+=DFS(xx,yy,mv,cnt);
				if(c[x][y]>mv){
					res+=DFS(xx,yy,c[x][y],cnt+1);
				}	
			}
		}
	}
	dp[x][y][mv+1][cnt]=res%mod;
	return dp[x][y][mv+1][cnt];
}
int main(){
	cin>>n>>m>>k;
	for(ll i = 1;i <= n;++i){
		for(ll j = 1;j <= m;++j){
			cin>>c[i][j];
		}
	}
	memset(dp,-1,sizeof dp);
	cout << DFS(1,1,-1,0);
	return 0;
}
```

---

## 作者：xyzcoolplayer (赞：0)

# 地宫寻宝
## 思路
一道蓝桥杯省选题，不是很难，只不过因为没加记忆化逝了……
### $DFS$
#### 爆搜肯定不行，会 $TLE$ ，只能得 $60$ 分
 有四种状态，拿，往下走，不拿，往下走，拿，往右走，不拿，往右走。到终点之后要判断是否拿到 $k$ 件物品，或者在马上到终点时(即 $[i-1]$ $[j]$ 或 $[i]$ $[j-1]$)是否拿到 $k-1$ 件物品。
#### 要加记忆化，降低时间复杂度，应该可以拿满
因为可能会有重复,会浪费很多时间，我们用一个 $Mark$ 数组来储存已计算过的路径，降低复杂度,避免不必要的重复。即 $if(mark[x][y][maxk+1][k]!=-1) return$ $mark[x][y][maxk+1][k];$
### $DP$
#### 动态规划可能会比较难理解
用 $dp$ 数组存当前位置拿的宝物的数量,最后输出就行了。

下面附上 $DFS$ 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007
int mark[55][55][14][14],a[55][55],n,m,k;
int dfs(int x, int y, int maxk, int k){
	if(x==n+1||y==m+1) return 0;
	if(mark[x][y][maxk+1][k]!=-1) return mark[x][y][maxk+1][k];
	long long cnt=0;
	if(x==n&&y==m) if(k==k||k==k-1&&a[x][y]>maxk){ cnt++;
	else{
		cnt+=dfs(x,y+1,maxk,k);
		if(a[x][y]>maxk) cnt+=dfs(x,y+1,a[x][y],k+1);
		cnt+=dfs(x+1,y,maxk,k);
		if(a[x][y]>maxk) cnt+=dfs(x+1,y,a[x][y],k+1);
	}
	mark[x][y][maxk+1][k]=cnt%mod;//注意一定要摸
	returnmark[x][y][maxk+1][k];
}
int main() {
	cin>>n>>m>>k;
	for(inti=1;i<=n;i++) for(intj=1;j<=m;j++) cin>>a[i][j];
	memset(mark,-1,sizeof(mark));
	cout<<dfs(1,1,-1,0);
	return 0;
}

```
#### 这是本蒟蒻写的第一篇题解，管理员大大一定要过！！！
### 谢谢！


---


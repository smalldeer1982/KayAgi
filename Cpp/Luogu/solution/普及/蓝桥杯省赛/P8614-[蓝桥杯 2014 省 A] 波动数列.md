# [蓝桥杯 2014 省 A] 波动数列

## 题目描述

观察这个数列：

$1,3,0,2,-1,1,-2, \cdots $。

这个数列中后一项总是比前一项增加 $2$ 或者减少 $3$。

栋栋对这种数列很好奇，他想知道长度为 $n$ 和为 $s$ 而且后一项总是比前一项增加 $a$ 或者减少 $b$ 的整数数列可能有多少种呢？

## 说明/提示

【样例说明】

这两个数列分别是 2 4 1 3 和 7 4 1 -2。

【数据规模与约定】

对于 $10\%$ 的数据，$1 \le n \le 5$，$0 \le s \le 5$，$1 \le a,b \le 5$；

对于 $30\%$ 的数据，$1 \le n \le 30$，$0 \le s \le 30$，$1 \le a,b \le 30$；

对于 $50\%$ 的数据，$1 \le n \le 50$，$0 \le s \le 50$，$1 \le a,b \le 50$；

对于 $70\%$ 的数据，$1 \le n \le 100$，$0 \le s \le 500$，$1 \le a,b \le 50$；

对于 $100\%$ 的数据，$1 \le n \le 1000$，$-10^9 \le s \le 10^9$，$1 \le a,b \le 10^6$。

时限 1 秒, 256M。蓝桥杯 2014 年第五届省赛

## 样例 #1

### 输入

```
4 10 2 3```

### 输出

```
2```

# 题解

## 作者：卷王 (赞：24)

## 题目大意

求满足和为 $s$ 且 $t_i=t_{i-1}+a$ 或 $t_i=t_{i-1}-b$ 的长度为 $n$ 的数列 $t$ 的方案数。

## 思路

**首先，得确定大概方向：**

一提到方案数，你会想到什么？

* 搜索（当然可以，只是会 T 到飞起）

* 记忆化搜索（emmm，我暂时还没研究过，或许可以吧）

* 大炮——dp！（此题正解）

**其次，冷静分析数据范围：**

看到题目里面的 $n \leq 1000$，再看看空间范围就可以大概猜测：用 $O(n^2)$ 的时空复杂度。这就是本题最清晰的解法。

**然后，设计状态：**

我们发现只有 $n$ 这一个变量可以二重循环，因此，我们尝试进行每重循环的次数都和 $n$ 有关。但是即使这样，空间也有可能不够啊！后面的都是 $10^6$ 级以上的！怎么办？我们会想到取模。于是设 $dp_{i, j}$ 表示前 $i$ 项的和模 $n$ 等于 $j$ 时的方案数。

**最后，最重要的转移方程：**

关于取模的转移方程，我不细讲了，就看 RoMantic_Queue 大佬的吧。觉得他讲的详细些。

在一些数学推导（其实这题也是个数学题）后，得到转移方程 $dp[i][j]=(dp[i-1][c(j-a×i)] + dp[i-1][c(j+b×i)])$，其中 $c(x)$ 表示 $x$ 对 $n$ 取模的结果，注意负数。

### 坑点：

* 注意模数是 $10^8 + 7$。

* 注意转移方程里面的加减，别搞混了。

代码奉上：
```cpp
//time：2023-04-01
#include <bits/stdc++.h>
using namespace std;
#define mod 100000007
typedef long long ll;
int n, s, a, b;
int dp[1007][1007];
inline int c(int x) {
	return (x % n + n) % n;
}
int main() {
	cin >> n >> s >> a >> b;
	dp[0][0] = 1;
	for(int i = 1; i < n; i++)
		for(int j = 0; j < n; j++)
			dp[i][j] = (dp[i - 1][c(j - a * i)] + dp[i - 1][c(j + b * i)]) % mod;
	cout << dp[n - 1][c(s)];
	return 0;
}
```

---

## 作者：Little_RMQ (赞：20)

# P8614[蓝桥杯 2014 省 A] 波动数列题解

这种计数的题一般不是 dp 就是数学题。

通过观察数据发现这道题 $n \leq 1000$ 所以推测这个题是一道 dp ~~（一般数学题 n 的范围不会这么小）~~。

- ## 状态的设计

设这个数列为 $\{ a_i\} $ 其中 $i\in[1,n]$ 且 $a_i\in Z$。

由题意不难得知  $a_i = a_{i-1} + a$ 或 $a_i =a_{i-1} -b$。

如果我们令 $P = a$ 或 $-b$。

那么我们可得 $a_i = a_{i-1} + P$。

又因为 ：

$$
\begin{aligned}
s=\sum_{i=1}^{n} a_i
\end{aligned}
$$

所以：
$$
\begin{aligned}
s=\sum_{i=1}^{n} a_1+(i-1)P
\end{aligned}
$$

将其展开可得：
$$
\begin{aligned}
s=na_1+P\sum_{i=1}^{n} (i-1)
\end{aligned}
$$

由小学学习的等差数列求和可得：
$$
\begin{aligned}
s=na_1+\frac{n\times(n-1)}{2}P
\end{aligned}
$$

然后我们另 $z=\frac{n\times(n-1)}{2}P$。

则：
$$
\begin{aligned}
s=na_1+z
\end{aligned}
$$

移项可得：
$$
\begin{aligned}
a_1=\frac{s-z}{n}
\end{aligned}
$$

由于 $a_1 \in Z$。

所以 $s-z \equiv 0\ (\bmod\ n)$。

即 $s \equiv z\ (\bmod\ n)$。

这个时候我们可以设计状态 $dp_{i,j}$ 表示前 $i$ 项的和模 $n$ 等于 $j$ 时的方案数。

很容易可以想出状态转移方程：

$$dp_{i,j}=dp_{i-1,Mod(j-i \times a)}+dp_{i-1,Mod(j-i \times b)}$$

这个方程的意义为 从 $i-1$ 状态转移到 $i$ 状态需要对 $a_{i-1}$ 进行   $+a$ 或 $-b$ 那么余数会受到相应的影响。

- ### 注意

1. 初始状态 $dp_{0,0}=1$。

2. $Mod(x)$ 表示 $(x \bmod n+n) \bmod n $。

3. 本题取模为 $10^8+7$ 。

## 代码
```cpp
#include"bits/stdc++.h"
#define N 1005
#define M 55
#define int long long
using namespace std;
int read()
{
	int x = 0, fff = 1;
	char c;
	while ((c = getchar()) < '0' || c > '9')
		if (c == '-')
			fff = -1;
	while (c >= '0' && c <= '9')
		x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
	return x * fff;
}
const int mod=1e8+7;
int n,s,a,b;
int dp[N][N];
signed main()
{
	n=read();
	s=read(),a=read(),b=read();
	dp[0][0]=1;
	for(int i=1;i<n;i++) 
		for(int j=0;j<n;j++)
			dp[i][j]=(dp[i-1][((j-i*a)%n+n)%n]+dp[i-1][((j+i*b)%n+n)%n])%mod;
	printf("%lld\n",dp[n-1][(s%n+n)%n]);
	return 0;
}
```

---

## 作者：wuhan1234 (赞：8)

## **1. 编程思路**

   当 $n$ 等于 1 的时候，很明显方案数为 1。
   
   当 $n>1$ 时，设起始数字为 $x$，且设波动序列为 $ x,x+d_1,x+d_1+d_2, ... , x+d_1+d_2+...+d_{n-1} $
   
   其中，差值序列为 $D={d_1,d_2,d_3,...,d_{n-1}}$，任意 $d_i$ 的值为 $+a$ 或 $-b$ 之一。

   则  
   $ s =x+(x+d_1)+(x+d_1+d_2)+...+(x+d_1+d_2+...+d_{n-1})$
   
  $$     =nx+(n-1)d_1+(n-2)d_2+...+d_{n-1} $$
   由于式中任意 $d_i$ 的值为 $+a$ 或 $-b$ 之一，设 $+a$ 在和式 $s$ 中出现 $y$ 次（ $ 0 \le y \le n(n-1)/2 $ ），则 $ -b $ 一定出现 $ n(n-1)/2-y $ 次。
   
   因此，和式
   $$ s = nx + ay - b( n(n-1)/2 - y )$$ 
  $$       s+b( n(n-1)/2 )  = nx + (a+b)y $$
   
   由于 $ n,s,a,b $ 均是整数，所以原问题等价于求方程 $s+b( n(n-1)/2 ) = nx + (a+b)y$ 的整数解的个数。
   
   另外，对于 $y$ 的每种情况，可能有不同的排序。由于 $0 \le y \le n(n-1)/2$，因此 $y$ 值可看成是集合 $ U = { 1，2，3，…，n-1 } $ 的子集的所有元素之和。即对于每个 $[0, n(n-1)/2 $] 之间的每个 $y$ 值，需要知道集合 $U$ 中有多少个子集之和等于它。
   
   这个问题用 dp 解决。
   
   设 $dp[i][j]$ 表示从集合 $U$ （假设集合中元素从小到大排列）中前 $i$ 个数中选择，使得和为 $j$ 的方案数，则有
   
   1）初始状态
   
 $  dp[0] [ j] = 0 $  （前 0 个数的和非 0，显然是不可能的）
   
$ dp[i][0]=1 $  （前 $ i $ 个数的和为 0，即一个数不选，只有 1 种可能）  
   
   2）状态转移方程
   
   当 $i >j $ 时，此时第 $i$ 个元素不能选（因为选了的话元素之和肯定大于 $j$），则
$$ dp[ i][ j] = dp[ i-1][ j] $$ 
   
   当 $i \le j$ 时，第 $i$ 个元素要么选，要么不选，则有   
   
$$　dp[i][ j] = dp[i-1][ j] + dp[i-1][ j- i]   $$
 
 实质上，数组元素 $dp[i][j]$ 表示了波动序列的前 $i$  项中 $a$ 使用的次数为 $j$ 时的方案种数。前 $i$ 项中 $a$ 的使用次数和为 $j$，显然与序列顺序是有关的，即 dp 记录的方案数是与序列有关的。但只要确定了波动序列中 $a$ 的各项的分布顺序，$-b$ 也就确定了，即为一种合法的变化序列。
   
   最后，由于题目中的数据规模较大，采用二维数组进行 dp 过于浪费存储空间。因为每次更新 dp 数组时，只有它的前一个状态与当前状态有关系，因此采用一维数组完成。仿照用一维数组生成杨辉三角形的方法。
    
## 2. 源程序
```c
#include <stdio.h>
#define MOD 100000007
#define maxn 1000010
int dp[maxn];
int main()
{
    long long n,s,a,b;
    scanf("%I64d%I64d%I64d%I64d",&n,&s,&a,&b);
    int temp = n*(n-1)/2;
    dp[0] = 1;
    int i,j;
    for (i=1;i<n;i++)
    {
        for (j=i*(i+1)/2;j>=i;j--)
        {
            dp[j] = (dp[j] + dp[j-i])%MOD;
        }
    }
    // 设x为序列第一个数，a的个数为y，0=<y<=n(n-1)/2
    // 求方程 s+b*n*(n-1)/2=nx + (a+b)y的整数解个数
    int ans = 0;
    for (int y=0; y<=temp; y++)
    {
        long long tt =s+b*temp-(a+b)*y;
        if (tt%n==0)
        {
            ans = (ans + dp[y])%MOD;
        }
    }
    printf("%d", ans);
    return 0;
}

```


---

## 作者：liushuaishuai (赞：6)

## 题目大意

求满足和为 $s$，且 $l_i=l_{i-1}+a$ 或 $l_i=l_{i-1} - b$ 长度为 $n$ 的数列 $l$ 的方案数。

## 方法
这题其实就是一道普通的 dp。

一般像这种范围，要么是 dp，要么是算术。

## 推状态转移方程
因为每 $i$ 项都是由 $i-1$ 项 $a$ 或 $-b$ 得出的，可状态转移方程：

$f_{ij}=f_{i-1,j-i\times a}+f_{i-1,j+i\times b}$。

## 注意

-  $f_{0,0} = 1$ ，输出：$f_{n-1,0}$。

-  取模。

-  处理 $s$ 为负数的情况。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e8 + 7,N = 1010;
int n,s,a,b,f[N][N];
int zhuan(int x){
	return (x % n + n) % n;
}
int main(){
	cin >> n >> s >> a >> b;
	f[0][0] = 1;
	for (int i = 1; i < n; i++)
		for (int j = 0; j < n; j++)
			f[i][j] = (f[i - 1][zhuan(j - a * i)] + f[i - 1][zhuan(j + b * i)]) % MOD;
 	cout << f[n - 1][zhuan(s)];
	return 0;
}
```

---

## 作者：qwerty12346 (赞：5)

# [题目传送门](https://www.luogu.com.cn/problem/P8614)

## 题意

就是求满足条件的方案数，并对 $100000007$ 取模。

## 思路

直接动态规划。

## 状态定义

$dp_{i,j}$ 表示在 $1$ 到 $n-1$ 的子集中前 $i$ 个数中选择，使得和为 $j$ 的方案数。

## 状态转移方程

如果 $i>j$ 那么 $dp_{i,j}=dp_{i-1,j}$。如果 $i≤j$ 那么 $dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-i}$。由于数据规模太大，所以建议用一维数组来做，就是用一维数组生成杨辉三角形来做这题。

## 状态定义

$dp_{0}=1$。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,ret,f[1000005];
int main(){
    cin>>a>>b>>c>>d;
    f[0]=1;
    for(int i=1;i<a;i++)
    {
        for(int j=i*(i+1)/2;j>=i;j--)f[j]=(f[j]+f[j-i])%100000007;//状态转移方程
    }
    for(int i=0;i<=a*(a-1)/2;i++)
    {
        if((b+d*a*(a-1)/2-(c+d)*i)%a==0)ret=(ret+f[i])%100000007;
    }
    cout<<ret;
    return 0;
}

```


---

## 作者：Smg18 (赞：4)

又是一篇题解。

计数问题（蓝桥杯第二爱考的），要么找规律要么动规。

然后看数据直接确定动规。

我们先设首项为 $x$，操作数为 $y$。

因为题目操作数 $y$ 要么等于 $a$，要么 $-b$。

所以 $s$ 等于:

$$x + (x+y) + (x+2+y) + \cdots + (x+(n-2)\times y)+(x+(n-1)\times y)$$

令：

$$k = y \times (0+1+2+ \cdots +(n-1))$$

所以：

$$s - k = n \cdot x$$

移项得：

$$x= \frac{s-k}{n}$$

所以得：

$$s \bmod n = k \bmod n$$

所以易得转态转移方程式：

$$dp_{i,j}=dp_{i-1,j-i\times a}+ dp_{i-1,j+i\times b}$$

$i$ 为 $k$ 的前 $i$ 项，$j$ 为序列对 $n$ 的取模余数。

初始化动规为 $dp_{0,0}=1$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define M(x) (x%n+n)%n//避免mod出负数 
#define int long long//CCF好闪拜谢CCF 
const int N=1e3+3,mod=1e8+7;
int n,dp[N][N];
int s,a,b; 
signed main(){
	cin>>n>>s>>a>>b;
	dp[0][0]=1;//初始化 
	for(int i=1;i<n;i++){
		for(int j=0;j<n;j++){
			dp[i][j]=(dp[i-1][M(j-a*i)]+dp[i-1][M(j+b*i)])%mod;
		}
	}
	cout<<dp[n-1][M(s)];
	return 0;
}
```

取模记得加一次这个数，避免负数。

---

## 作者：hubin1 (赞：1)

# 波动数列

## 题目大意
求长度为 $n$ 和为 $s$ 而且后一项总是比前一项增加 $a$ 或者减少 $b$ 的整数数列可能有多少种。

## 思路
- 这道题是动态规划。
- 状态
  1. 首先我们会想到：设 $dp_{i,j}$ 为数列前 $i$ 项，和为 $j$ 的方案数。但看到数据范围，对于 $100\%$ 的数据，$1 \le n \le 1000$，$-10^9 \le s \le 10^9$，这个方法就不太方便了，因为 $s$ 有点大。~~数组要爆炸。~~
  2. 设当前的操作为 $p$，$p=a\text{或}-b$，数列首项为 $x$，由题意得： 
   
    $$\because s=x+(x+p)+(x+2p)+ \cdots +(x+(n-1)p)$$

    $$\therefore s=nx+(0+1+2+\cdots+n-1)p.$$

    $$\text{令}T=(0+1+2+\cdots+n-1)p,$$

    $$\text{得}S=nx+T,\text{即} s \equiv T\pmod n.$$

  3. 根据第二条，我们设状态为：$dp_{i,j}$ 代表数列**前 $i$ 项的和模 $n$ 为 $j$ 的数的方案数。**
- 转移方程
转移方程即前两种方案的和：

$dp_{i,j}=dp_{i-1,m(j-a*i)}+dp_{i-1,m(j+b*i)}$，$m(x)$ 表示对 $x$ 模 $n$ 的结果。
- 初始化
因为 $dp_{0,0}$ 只有一种方案，所以初始化为 $1$。

## Code
``` cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define debug(x) cerr<<#x<<"="<<x<<"\n"

const int MAX=1e3+10;
const int m=1e8+7;

int dp[MAX][MAX];
int n,s,a,b;

int mod(int x)
{
	return (x%n+n)%n;
}//取模，这样为了防止出现负数

int main()
{
	
	scanf("%d%d%d%d",&n,&s,&a,&b);
	dp[0][0]=1;//初始化
	for(int i=1;i<n;i++)
	{
		for(int j=0;j<n;j++)//余数从0~n-1
		{
			dp[i][j]=(dp[i-1][mod(j-a*i)]+dp[i-1][mod(j+b*i)])%m;
		}
	}
	cout<<dp[n-1][mod(s)]<<endl;
	return 0;
}
```

---

## 作者：zhanghao233 (赞：0)

# 题目大意

* 给定 $n$，$s$，$a$，$b$。

* 求一个序列，它满足长度为 $n$，总和为 $s$，$t_i=t_{i-1}+a,t_i=t_{i-1}-b$。

* $1 \le n \le 1000$，$-10^9 \le s \le 10^9$，$1 \le a,b \le 10^6$。

# 思路

我们可以通过简单的推理得出：

$\dfrac{s-k}{n}=x$

为什么？可以通过每个数继承上一个数的逻辑去想。

那么问题就转化为了**方程是否有正整数解**。

我的想法是用二进制枚举每一个状态，但是会超时。

不如枚举 $+a$ 的数量。

我们需要知道的是当有 **$m$ 个 $+a$ 时的组成方案数**，可以用动规解决：

$f_j$ 代表 $j$ 个 $+a$ 时的组成方案数。

由于第 $i$ 个 $+a$ 可以选或不选，所以：

$f_j=f_j+f_{j-i}$

```cpp
f[0]=1;
for(int i=1;i<n;i++)
	for(int j=i*(i+1)/2;j>=i;j--)
		f[j]=(f[j]+f[j-i])%mod;
```

---

## 作者：_cmh (赞：0)

Update on 2022.10.25： 修改笔误，完善题解。

## $\texttt{Preface}$

DP。

首 A 来交一发题解。

**坑点：模数为 $10^8+7$！**

## $\texttt{Solution}$

设数列首项为 $x$，操作为 $y\ (y=a\ \text{or}\ y=-b)$，则有

$$s=x+(x+y)+(x+2\times y)+\dots+(x+(n-1)\times y)$$

所以

$$s=n\times x+y\times(0+1+2+\dots+n-1)$$

令 $z=y\times(0+1+2+\dots+n-1)$，可得

$$s-z=n\times x$$

即

$$x=\frac{s-z}{n}$$

显然，$x$ 为整数。因此

$$s\bmod n=z\bmod n$$

定义 $dp_{i,j}$ 为 $z$ 的前 $i$ 项，当前序列和对 $n$ 取模余数为 $j$。

注：

- **$z$ 的前 $i$ 项** 即 $y\times(0+1+2+\dots+i)$；

- **当前序列和对 $n$ 取模余数为 $j$** 即为 $j=(x+(x+y)+(x+2\times y)+\dots+(x+i\times y))\bmod n$。

因为 $y=a\ \text{or}\ y=-b$，则第 $i$ 项将由第 $i-1$ 项 $+a\ \text{or} -b$ 推得。可推出：

$$dp_{i,j}=dp_{i-1,j-i\times a}+dp_{i-1,j+i\times b}$$

初始值 $dp_{0,0}=1$。答案为 $dp_{n-1,0}$。

## $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e3+3,mod=1e8+7;
int n,dp[N][N];

int Mod(int x){return (x%n+n)%n;}

int main(){
	int s,a,b; scanf("%d%d%d%d",&n,&s,&a,&b);
	dp[0][0]=1;
	for(int i=1;i<n;i++)
		for(int j=0;j<n;j++)
			dp[i][j]=(dp[i-1][Mod(j-a*i)]+dp[i-1][Mod(j+b*i)])%mod;
	printf("%d",dp[n-1][Mod(s)]);
}
```

---


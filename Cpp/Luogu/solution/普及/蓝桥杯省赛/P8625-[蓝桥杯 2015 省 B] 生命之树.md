# [蓝桥杯 2015 省 B] 生命之树

## 题目描述

在 X 森林里，上帝创建了生命之树。

他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。

上帝要在这棵树内选出一个节点集合 $S$（允许为空集），使得对于 $S$ 中的任意两个点 $a,b$，都存在一个点列 ${a,v_1,v_2, \cdots ,v_k,b}$ 使得这个点列中的每个点都是 $S$ 里面的元素，且序列中相邻两个点间有一条边相连。

在这个前提下，上帝要使得 $S$ 中的点所对应的整数的和尽量大。

这个最大的和就是上帝给生命之树的评分。

经过 atm 的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 10$。

对于 $100\%$ 的数据，$0<n \le 10^5,$ 每个节点的评分的绝对值不超过 $10^6$。

时限 3 秒, 256M。

蓝桥杯 2015 省赛 B 组 J 题。

## 样例 #1

### 输入

```
5
1 -2 -3 4 5
4 2
3 1
1 2
2 5```

### 输出

```
8```

# 题解

## 作者：xler0915 (赞：19)

[题目传送门](https://www.luogu.com.cn/problem/P8625) / [可能有更好的阅读体验](https://www.luogu.com.cn/blog/hen-you-so-beautiful/solution-p8625)

### 题意
对于一棵树，找到其点权和最大的一个连通分量（注意可以为空），输出这个连通分量的点权和。相似于 [P1122](https://www.luogu.com.cn/problem/P1122)。

### 思路：树形 dp
我们用 $a_i$ 表示第 $i$ 个点的权值，$dp_u$ 表示在以 $u$ 为根的子树中最大的点权和，不妨设 $1$ 号节点为这棵树的根，其父亲为 $0$ 号节点。

因为对于 $u$ 的任意一个儿子 $v$，如果 $dp_v>0$，那么以 $u$ 为根的点权和最大的子树一定要加上以 $v$ 为根的点权和最大的子树，所以得到状态转移方程为：

$$dp_u = a_u+\sum\limits_{u \to v}\max\{dp_v,0\}$$

最终答案即为 $\max\{\max_{i=1}^ndp_i,0\}$（因为可以为空），实现方法较为简单。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
int a[100005]; // 每个点的点权
long long dp[100005]; // 注意开 long long
vector<int> adj[100005]; // 邻接表存储

void dfs(int u, int fa) {
	dp[u] = a[u];
	for(int v : adj[u]) {
		if(v == fa) continue;
		dfs(v, u);
		dp[u] += max(dp[v], 0ll);
	}
   // 状态转移方程
}

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) 
		scanf("%d", &a[i]);
	for(int i = 1, u, v; i < n; i++) {
		scanf("%d%d", &u, &v);
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	dfs(1, 0);
	printf("%lld", max(*max_element(dp + 1, dp + n + 1), 0ll)); // 输出答案。
	return 0;
}
```

---

## 作者：Iniaugoty (赞：5)

[传送门](/problem/P8625)。

***

## problem

给出一棵树，求出点权和最大的子树，并输出这个点权和。

***

## solution

一看感觉就根 [P1122 最大子树和](/problem/P1122)一样的，用树型 dp 解决。因为以哪个点为根，其实都能得到正确的结果，直接把 $1$ 当作根结点。设 $dp_i$ 为以 $i$ 结点为根的子树的最大子树和，转移方程为 $dp_i=a_i+\sum_{i\to j}\max\{dp_j,0\}$。最后的答案为 $\max\{dp_i\}$。

然而，我交上代码后只得了 60pts。

仔细再读题目，发现：

> 上帝要在这棵树内选出一个节点集合 $S$（允许为空集）。

选的点集是空集，那点权和就是 $0$，这在最大子树和为负的情况下，对结果是有影响的。

那么答案就应该是 $\max\{\max\{dp_i\},0\}$。

然而，交上去还是只有 72pts。

注意到：**十年 OI 一场空，【数据删除】见祖宗**。于是加上一句 `#define int long long`，快乐地 AC 了。

***

## code

这里采用链式前向星存图。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 100005
#define max(x,y) (x>y?x:y)
using namespace std;
struct star{//链式前向星存图
	int next,to;
}e[N<<1];
int head[N],cnt;
void add(int u,int v){//加边
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}
int n,a[N],dp[N],ans;//可以选空集，所以 ans 初始化为 0
void dfs(int step,int father){//注意要把要转移的点的父节点记录下来，不然会重复计算
	dp[step]=a[step];
	for(int i=head[step];i;i=e[i].next){
		int t=e[i].to;
		if(t!=father){
			dfs(t,step);
			if(dp[t]>0)
				dp[step]+=max(dp[t],0);//转移
		}
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1,u,v;i<n;i++)
		cin>>u>>v,add(u,v),add(v,u);
	dfs(1,0);//添加一个 0 作为 1 的父节点
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：StarRain3 (赞：4)

怎么没有题解？

#### 分析
我们把它想象成一个普通的树，但是它的根不确定，先看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/58kwd2rc.png)

可以发现，我们不管怎么变换根，它的最大值都是相同的，我们不如就全部以 $1$ 为根。

解决了这个问题，我们就可以用树形动态规划模板了，建立一个二位动态规划数组，属性是最大值。

$f_{k}$ 且 $q$ 为 $0$ 表示不选取 $k$ 节点后 $k$ 子树能得到的最大值；$f_{k}$ 且 $q$ 为 $1$ 表示选取 $k$ 节点后的 $k$ 子树能得到的最大值。

动态转移方程见代码部分。

我们用邻接表维护。

找出与 $u$ 相邻的节点，如果父节点也与 $u$ 节点相邻，但不能重复遍历，然后递归获取儿子节点的信息。

值得注意的是：如果当前的能选取的最大方案它是负数，就没有必要继续了，舍弃即可。

#### 赛时代码
```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
vector<int> linjie[N];
long long ans;
long long dp[N][3];
int w[N];
void dfs(int u,int father){
	dp[u][1] = w[u];
	dp[u][0] = 0;//初始化 
	for(int i=0; i < linjie[u].size();i++){//枚举邻接表里的内容 
		int v = linjie[u][i];//方便 
		if(v != father){
			dfs(v,u);
            
			dp[u][0] = max(dp[v][0],dp[v][1]);//DP
            
			if(dp[v][1] > 0) dp[u][1] += dp[v][1];
			 
		}
	}
	ans = max({dp[u][0],dp[u][1],ans});//c++14特性
}
int main(){
	int n;
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> w[i]; 
	}
	
	for(int i=1;i < n;i++){
		int a,b;
		cin >> a >> b;
		linjie[a].push_back(b),linjie[b].push_back(a);//加入邻接表中
	}
	dfs(1,1);//递归 
	cout << ans;
	return 0; 
}
```
[AC记录](https://www.luogu.com.cn/record/108532466)。

---

## 作者：maziyue (赞：3)

## 题目大意
题目中讲到：_$a,v_1,v_2,...,v_k,b$ 使得这个点列中的每个点都是 $S$ 里面的元素，且序列中相邻两个点间有一条边相连。_ 

这意味着 $S$ 为一个连通的集合，并且和要最大。即在一棵树中找到其的最大连通分量。
## 思路分析
算法：**树形 dp**。

我们不妨令 $dp_u$ 表示：
#### 以 $u$ 为根子树的最大连通权值和。
那么 $dp_u$ 的值就是只需在其儿子节点 $dp_v$ 和自己本身的权值中取个较大值即可。
## 解题步骤
1. 用 $a_i$ 存储每个节点的权值并读入树的边。
2. 通过 dfs 遍历此树。
3. 在 dfs 的同时进行对 $dp$ 数组的计算。
4. 遍历结束，在 $dp_1...n$ 中找到最大值，输出。
## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long//一定要开
using namespace std;
const int N=1e5+7,inf=1e18;
int n,a[N],dp[N];//dp[u]以u节点为根其子树的最大连通权值 
vector<int> g[N];
void dfs(int u,int fa){
    dp[u]=a[u];//初始化  最大值是根节点的权 
	for(auto v:g[u]){
		if(v==fa)continue ;
		dfs(v,u);
		dp[u]=max(dp[u],dp[u]+dp[v]);//状态转移  自己的最大值 和 自己加上子树的最大值 的较大值 
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
		//存入树边 
	}
	dfs(1,-1);
	int ans=0;//注意：s可以为空集 此处不能将ans赋值为负无穷大 
    for(int i=1;i<=n;i++)ans=max(ans,dp[i]);
    cout<<ans;
	return 0;
} 
```
~~注：十年 OI 一场空，不开 long long 见祖宗~~

---

## 作者：Furina_Hate_Comma (赞：3)

一道树形 dp 题。

对于一个节点，考虑所有子节点，如果非负，就加上；否则舍弃。

状态转移方程：

$$\sum_{i=son_1}^{i\in son} dp_i\times(dp_i\ge 0)$$

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[900005];
int dp[900005];
struct lsqxx{
	int t,nxt;
}e[900005];
int tot,num[900005];
void addedge(int f,int t){
	e[++tot].t=t;
	e[tot].nxt=num[f];
	num[f]=tot;
}
void dfs(int p,int f){
	dp[p]=a[p];
	for(int i=num[p];i;i=e[i].nxt){
		if(e[i].t!=f){
			dfs(e[i].t,p);
			if(dp[e[i].t]>0)
				dp[p]+=dp[e[i].t];
		}
	}
}
signed main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<n;i++){
		int f,t;
		cin>>f>>t;
		addedge(f,t),addedge(t,f);
	}
	int ans=dp[1];
	dfs(1,0);
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
} 
```


---

## 作者：Nostopathy (赞：2)

## Solution

一句话题意：求权值最大的连通分量（可以为空）。

考虑树上 DP，对于一个节点 $x$，令 $dp_x$ 表示 $x$ 为最上方节点的最大连通分量权值，初始化为 $val_x$（评分）。对于每一个 $x$ 的子节点 $v$，若 $dp_v > 0$，则应令 $dp_x \leftarrow dp_x + dp_v$，答案为所有 $dp_x$ 的最大值。

**易错点：最后一定要加 `max(res, 0)`！**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int, int>
#define pb push_back
#define rep(a, b, c, d) for(int a=b; a<=c; a+=d)
const int N = 1e5 + 5;
int n, val[N], dp[N];
vector<int> G[N];
void add(int x, int y) {
	G[x].pb(y);
	G[y].pb(x);
}
bool Max(int &x, int y) {
	return (y > x ? x = y, 0 : 1);
}
void dfs(int x, int fa) {
	dp[x] = val[x];
	for(int v: G[x]) {
		if(v == fa)
			continue;
		dfs(v, x);
		dp[x] += max(dp[v], 0ll);
	}
}
signed main () {
	scanf("%lld", &n);
	rep(i, 1, n, 1)
		scanf("%lld", &val[i]);
	for(int i = 1, x, y; i < n; ++ i)
		scanf("%lld%lld", &x, &y), add(x, y);
	dfs(1, 0);
	int res = 0;
	rep(i, 1, n, 1)
		Max(res, dp[i]);
	Max(res, 0);
	printf("%lld", res);
	return 0;
}
```

~~没有求关的题解不是好题解。~~

---

## 作者：IcyDragon (赞：2)

## 题意

给定一棵树，求点权和最大的子树点权和是多少。

## 思路

树形 DP。

设 $dp_u$ 表示以 $u$ 为根的子树能得到的最大点权和。

由此，我们可以得到状态转移方程：

$$
dp_u = \sum \max(0,dp_v) + a_u
$$

其中 $a_u$ 是节点 $u$ 的点权，$v$ 是 $u$ 的子节点。

由于可以选空集合，所以答案是

$$
\max (\displaystyle\max_{u \isin [1,n]} dp_u,0)
$$

## 代码

```cpp
#include<iostream>
#include<vector>
using namespace std;

typedef long long lld;

vector<int> E[100100];
lld a[100100],dp[100100];

void dfs(int u,int f){
	dp[u] = a[u];
	for(int v : E[u]){
		if(v == f){
			continue;
		}
		dfs(v,u);
		dp[u] += max(0LL,dp[v]);
	}
}

int main(){
	int n,u,v;
	cin>>n;
	for(int i = 1; i <= n; i++){
		cin>>a[i];
	}
	for(int i = 1; i < n; i++){
		cin>>u>>v;
		E[u].push_back(v);
		E[v].push_back(u);
	}
	dfs(1,-1);
	lld mx = 0;
	for(int i = 1; i <= n; i++){
		mx = max(mx,dp[i]);
	}
	cout<<mx;
	return 0;
}
```

---

## 作者：yangdicheng2013 (赞：1)

##  $\text{前言}$ 

题面：[P8625 [蓝桥杯 2015 省 B] 生命之树](https://www.luogu.com.cn/problem/P8625)

本题不难，但是我想了很久，主要卡在了状态转移上了 qwq

##  $\text{方法}$ 

**树形dp**

我们不难想到，用 $dp_i$ 表示：**以 $i$ 为根节点的树的最大评分**

显然，对于所有叶子节点 $i$，$dp_i \gets w_i$（其中 $w_i$ 表示节点 $i$ 的评分）

接着，我们思考对于所有**非叶子节点 $u$** 来说，他的任意子节点 $v_1$，和另一个任意子节点 $v_2$，可以通过 $u$ 为顶点，作一条路径。而这条路径上，**除了根节点 $u$ 之外，其他的所有点都在子树 $v_1$ 和 $v_2$ 为根的子树里**。不难想到，枚举所有的子节点 $v$，当满足 $dp_v > 0$ 时，$dp_u \gets dp_u + dp_v$，初始化 $dp_u \gets w_i$

为何要满足 $dp_v > 0$ 呢？因为如果 $dp_v$ 是负数，那就会对 $u$ 的评分造成损失

那为何初始化 $dp_u \gets w_i$，因为**根节点 $u$ 不在其子树内**（这里注意，因为题目说的是一个集合，所以 $w_i$ 只加一次）

**具体流程**：

$\texttt{Step0:}$ 输入并建模处理，初始化 $dp_i = w_i$

$\texttt{Step1:}$ 深度搜索全图，并按照上文状态转移

$\texttt{Step2:}$ 输出答案（这里需要统计所有点的评分最大值，而非直接输出 $dp_1$）

### AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define int long long
#define pii pair <int, int>
#define lc(i) (i << 1)
#define rc(i) (i << 1 | 1)
#define MAXN 100005
#define MAXM 500005
#define les(T) while (T--)
const int mod = 100000007;

int n;
int val[MAXN];
vector<int> e[MAXN];//用邻接表存图
int dp[MAXN];//dp[i] 表示以 i 为根的树的最大评分

void add_edge(int a, int b) {//加边
	e[a].push_back(b);
	e[b].push_back(a);
}
void dfs(int u, int pa) {//u 为当前节点，pa 为 u 的父节点
	for (auto v : e[u]) {
		if (v == pa)//v 不能等于 pa，但是如果 加边 的时候只加子节点，就不用 pa 变量
			continue;
		dfs(v, u);
		dp[u] += max(dp[v], 0ll);//状态转移
	}
}

signed main() {
	ios::sync_with_stdio(0);//输入输出优化
	cin.tie(0);
	cout.tie(0);
	
//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);
	
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> val[i];
		dp[i] = val[i];//初始化，这里 val 代表 w 数组（注意，这里不可以 dp[i] = max(val[i], 0ll)哦，我栽过这里）
	}
	for (int i = 1; i <= n - 1; i++) {
		int u, v;
		cin >> u >> v;
		add_edge(u, v);//加边
	}
	dfs(1, 0);//搜索
	int ans = 0;
	for (int i = 1; i <= n; i++)//统计
		ans = max(ans, dp[i]);
	cout << ans << endl;
	return 0;
}
```
~~然后你就 AC 了~~

对了，解释一下初始化为何不能 ```dp[i] = max(val[i], 0ll)```，而是 ```dp[i] = val[i]```。因为你需要保证叶子节点为原值，否则 $dp$ 数组里将会全部为正数，就没有意义（或者说将会永远满足 $dp_v > 0$，导致 $dp$ 数组无法被正确更新）

## $\text{闲言}$

本题目虽然简单，但是我花了很久时间，有任何问题可以告诉我

觉得此题解写的好的话点个赞~~和关注~~吧，谢谢

管理员大大求过 qwq

---

## 作者：FlyHappily (赞：1)

# [P8625 [蓝桥杯 2015 省 B] 生命之树](https://www.luogu.com.cn/problem/P8625)
## 算法：树形 dp
挺明显的一道 dp 题。

以样例举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/n9j2il77.png)

从 $2$ 跑下去，看得出如果要了 $4$ 可以带来 $4$ 的价值，且只有要 $2$ 上面的点才可以通过 $2$ 联通 $4$。

可以得出我们只有要了一个点它的子树才可以要，于是题意变为求最大子树和，推出转移方程： 

 $$dp[u]=\max(dp[v],0)+a[u]$$ 

注意最后可能不要 $1$ 节点，所以要遍历一遍 $dp$ 数组取最大值做答案。
## AC 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[100005],dp[100005];
vector<int> e[100005];
void dfs(int u,int fa)
{
	dp[u]=a[u];
	for(int v:e[u])
	{
		if(v==fa)continue;
		dfs(v,u);
		dp[u]+=max(dp[v],0ll); //转移
	}
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	int ans=0;
	for(int i=1;i<=n;i++)
		ans=max(ans,dp[i]);
	cout<<ans;
	return 0;
}
```
完结撒花

---

## 作者：Alter_Native (赞：0)

## 题意

在树上找出联通的节点使他们的和最大。点权可以为负。

## 思路

看到“最大”，我们可以想到这些算法：搜索，贪心，动态规划……而依据本题的数据范围，可以判断出来要使用动态规划的算法。

我们把状态设在每个点上，在搜索的过程中访问每个节点，进而完成状态的转移。状态很明显是由孩子节点转移到父亲节点上，所以转移要在回溯时进行。

然后就可以想到状态是这样设的：定义 $dp[i]$ 为以节点 $i$ 为根的子树中的连通块最大值。

有了这个，我们就可以写出状态转移方程：对于节点 $u$ 的子节点 $v$：$dp[u]=\max(dp[u],dp[u]+dp[v])$。

不过别忘了把 $dp[u]$ 预先设成 $u$ 的评分（因为如果不选节点 $u$ 的话，这个节点的 $dp$ 值是没法往上转移的）。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

int v[100002],mx,dp[100002];
vector<int> a[100002];

void dfs(int x,int fa){
	dp[x]+=v[x];//当前节点要选 
	for(int i:a[x]){
		if(i!=fa){
			dfs(i,x);
		}
	}
	for(int i:a[x]){
		if(i!=fa){
			dp[x]=max(dp[x],dp[x]+dp[i]);//对于每个子节点判断选与不选的最大值 
		}
	}
	mx=max(mx,dp[x]);//记录所有节点dp的最大值 
}

signed main(){
	int n;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&v[i]);
	}
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%lld%lld",&x,&y);
		a[x].push_back(y);
		a[y].push_back(x);
	}
	dfs(1,0);
	printf("%lld\n",mx);
    return 0;
}
```

[评测记录](https://www.luogu.com.cn/record/226543136)

---

## 作者：yanzixuan2024 (赞：0)

考虑树形 dp。

设 $a_i$ 为每个节点的评分，$dp_x$ 为在 $x$ 的子树中最大的点权和。对于 $x$ 的任意一个儿子 $y$，只要满足 $dp_y>0$，那么 $x$ 的子树中最大的点权和一定包括 $dp_y$。即：

$$
dp_x=a_x+\sum_{x\to y}\max(dp_y,0)
$$

答案为 $\max(0,\max_{i=1}^{n}dp_i)$。

```cpp
#include<bits/stdc++.h>
#define max(a,b) a>b?a:b
using namespace std;
int n,a[100005];
vector<int> vec[100005];
long long dp[100005];
void dfs(int x,int fa){
    dp[x]=a[x];
    for(auto i:vec[x]){
        if(i==fa) continue;
        dfs(i,x);
        dp[x]+=max(dp[i],0);
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",a+i);
    for(int i=1;i<n;++i){
        int u,v;
        scanf("%d %d",&u,&v);
        vec[u].push_back(v),vec[v].push_back(u);
    }
    dfs(1,-1);
    long long mx=0;
    for(int i=1;i<=n;++i) mx=max(mx,dp[i]);
    printf("%lld",mx);
}
```

---


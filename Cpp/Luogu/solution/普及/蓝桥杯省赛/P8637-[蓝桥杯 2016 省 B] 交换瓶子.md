# [蓝桥杯 2016 省 B] 交换瓶子

## 题目描述

有 $N$ 个瓶子，编号 $1 \sim N$，放在架子上。

比如有 $5$ 个瓶子：

$$2,1,3,5,4$$

要求每次拿起 $2$ 个瓶子，交换它们的位置。

经过若干次后，使得瓶子的序号为：

$$1,2,3,4,5$$

对于这么简单的情况，显然，至少需要交换 $2$ 次就可以复位。

如果瓶子更多呢？你可以通过编程来解决。



## 说明/提示

时限 1 秒, 256M。蓝桥杯 2016 年第七届省赛

蓝桥杯 2016 年省赛 B 组 I 题。

## 样例 #1

### 输入

```
5
3 1 2 5 4```

### 输出

```
3```

## 样例 #2

### 输入

```
5
5 4 3 2 1```

### 输出

```
2```

# 题解

## 作者：Maysoul (赞：16)

### 思路：

用贪心的思路去思考问题：

当当前瓶子不在正确的位置上时，那么它正确的位置上是否也是不正确的？

比方说在教室里，小明占了你的座，那你肯定没法坐在你自己的座位上。

这一特性，足以说明贪心思路的正确性。

因为它**不会打乱正确顺序的瓶子**。

那我们只需要把它枚举一遍，遇到不正确的就交换不就好了吗？

```
for (int i=1;i<=n;i++)
{
	if(a[i]!=i)
	{
		swap(a[i],a[a[i]]);
		ans++;
	}
}	
```
像这样，就完成了对瓶子的初步交换。

但是换一遍的话，肯定会有瓶子被调换到了错误的位置。

那我们考虑最坏的结果，无非就是所有瓶子都不在正确的位置上。

所以持续进行 $ n $ 次这样的循环，就可以确保所有瓶子都在正确的位置上。

### AC CODE：


```
//2023/4/22
//别着急，先通读一遍题目
//别忘了开long long
//写完先看一遍怎么降复杂度
//要么开全局变量要么给定初值
//想想看，有什么情况需要特判
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num,ans;
int a[10010];
int main()
{
	int n;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for (int j=1;j<=n;j++)
	{
		for (int i=1;i<=n;i++)
		{
			if(a[i]!=i)
			{
				swap(a[i],a[a[i]]);
				ans++;
			}
		}	
	}
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：XBaiC (赞：7)

### 核心步骤：

例如 $A[3]=\{2,0,1\}$，$2$ 在 $0$ 的位置，$0$ 在 $1$ 位置，$1$  在 $2$ 的位置，那么把它们画成图的拓扑结构的话，就是一个环（圈），即 $2\Longrightarrow0\Longrightarrow1\Longrightarrow2$。

这样的条件（排列成环（圈））用文字描述为：

1. 位置和位置上的数字或字符存在一一对应关系；

2. 每个数字或字符都不在自己应有的位置上；

> 题目要求计算：至少交换多少次。
> 
> 每交换一次，就是这个环内分解为两个独立的环。
> 
> 那么我们先计算出环的个数，最后得到排列好的就是每个独立的环，答案就是总个数 - 环的个数。

![](https://cdn.luogu.com.cn/upload/image_hosting/rf0lya5x.png)

### 代码如下：

```cpp
#include<iostream>

using namespace std;

const int N = 1e4 + 10;

int n;
int a[N];
int len,ans;
bool st[N];

void dfs(int u){
	if(st[u]) return ;
	st[u] = true;
	dfs(a[u]);
}
int main(){
	cin >> n;
	for(int i = 1; i <= n; i ++ ) cin >> a[i];
	for(int i = 1; i <= n; i ++ ){
		if(!st[i]){
			ans ++;
			dfs(i);
		} 
	}
	cout<<n - ans;
	return 0;
}

```


---

## 作者：I_will_AKIOI (赞：6)

标签显示贪心算法，我们就用贪心来做。

要使瓶子按顺序排列，就得先找到 $a_i \not= i$ 的数有几个。再找到 $a$ 数组的另一个数使 $a_j = i$ 即可。

**建议评橙**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10005],ans;
int main()
{
  cin>>n;
  for(int i=1;i<=n;i++) cin>>a[i];
  for(int i=1;i<=n;i++) 
  {
    if(a[i]!=i)//需要交换
    { 
      ans++;
      for(int j=i+1;j<=n;j++) if(a[j]==i) swap(a[i],a[j]);//
      //找到另一个是i的数
    }
  }
  cout<<ans;
  return 0;
}
```

---

## 作者：Lemon_zqp (赞：5)

### 思路
应该还挺简单的，先判断当前数 $a_i$ 的位置是否正确，如果正确，直接跳过。否则交换次数加一，从当前位置往后找对应位置的答案。

### 样例解析
第一个样例，
很明显第一个数字 $3$ 就错了，往后扫发现下一个数字为 $1$ ，刚好位置正确，把 $1$ 和 $3$ 交换一下，交换次数加一，接着 $3$ 和 $2$ 交换，当前交换次数为 $2$ 次。再往下 $5$ 和 $4$ 交换，当前交换次数为 $3$ ，最后输出 $3$ 。

### 代码

```
#include<bits/stdc++.h>
using namespace std;

int a[10005];

int swapp(int l, int r)//自定义交换函数 
{
	int t;
	t = a[l];
	a[l] = a[r];
	a[r] = t;
}

int main()
{
	int n, cnt = 0;
	cin >> n;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	} 
	for(int i = 1; i <= n; i++)
	{
		if(a[i] != i)//没有在正确位置上 
		{
			cnt++;
			for(int j = i + 1; j <= n; j++)//从当前这个数的后一个往后扫 
			{
				if(a[j] == i) 
				{
					swapp(i, j);
					break;//跳出循环 
				}
			}
		}
	}
	cout << cnt;
	return 0;
}

```



---

## 作者：sherry_lover (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8637)

本题考点：贪心。


------------
这道题我们可以先判断当前 $a_i = i$ 是否正确，如果正确，就跳过。否则交换次数加一，从当前位置往后找一个 $j$，使得 $a_j = i$，则交换 $a_i$ 和 $a_j$。 

标程在这里：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10050],ans; 
int main()
{
	cin >> n; 
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	for(int i = 1;i <= n;i++)
	{
		if(a[i] == i) continue;
		ans++;
		for(int j = i+1;j <= n;j++)
		{
			if(a[j] == i)
			{
				swap(a[j],a[i]);
				break;
			}
		}
	}
	cout << ans;
	return 0;
}
```

文明洛谷，禁止Copy！

---

## 作者：Fengyiwei1234 (赞：2)

本题是一道~~较水~~的题。


[题目传送门](https://www.luogu.com.cn/problem/P8637)


# 思路

考虑贪心，如果这个位置已经是正确的了，就不改。否则，就交换一下，把这个位置换成正确的瓶子。

AC 代码：

```c++
#include<bits/stdc++.h>//万能头
using namespace std;
int a[100001];
int main()
{
    int n,ans=0;//开始计数，算ans
    cin>>n;//输入
    for(int i=1;i<=n;i++)cin>>a[i];//输入
    for(int i=1;i<=n;i++)
    {
        int k=i;
        for(int j=i+1;j<=n;j++)if(a[k]>a[j])k=j;
        if(k!=i)
        {
        	swap(a[i],a[k]);//交换，使这个位置上变成正确的瓶子
        	ans++;
        }
    }
    cout<<ans<<endl;//输出
    return 0;
}
```


[AC 记录](https://www.luogu.com.cn/record/108594020)

---

## 作者：fish_love_cat (赞：2)

**思路：**

读入并遍历瓶子的序列，如果该瓶子位置正确可以直接忽视，如果不对，答案加一，往后扫，扫到对应位置的瓶子就交换位置，然后下一个瓶子继续……

没有黄的难度吧，码量不大，想着也不难……

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005],ans;
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<=n;i++){
        if(a[i]!=i){
            ans++;
            for(int j=i+1;j<=n;j++){//从i+1开扫
                if(a[j]==i){
                    swap(a[i],a[j]);//交换
                    break;//扫到了就可以退了
                } 
            }
        }
    }
    cout<<ans;
    return 0;
}
```

[Accepted.](https://www.luogu.com.cn/record/108543883)

---

## 作者：AzureHair (赞：2)

简明题意：
每次交换一个 $1$ 到 $n$ 的排列中的两个数字，使得变为标准排列，即 $1,2,3 \cdots n$ 。    
容易发现如果 $a_i=i$ 则不用交换，反之则至少要进行一次交换才能使得 $a_i=i$ 那么直接就可以考虑贪心，当不满足 $a_i=i$ 时就直接交换，就可以得到最优解。下附代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10010],ans=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]!=i)
		{
			for(int j=i+1;j<=n;j++)//位置不对直接交换
			{
				if(a[j]==i)
				{
					swap(a[i],a[j]);
					ans++;
					break;
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：ziansheng (赞：1)

### [P8637](https://www.luogu.com.cn/problem/P8637)
# 题目分析
这道题我们考虑贪心。我们首先判断 $\operatorname{i}$ 在不在它的位置上，如果不在，我们就寻找它应在位置，然后交换两个数值。重复这个操作直到每个数都在它应在的位置上。

------------
# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005],t,s,n,i,j,k;
int main()
{
    cin>>n;
    for(i=1; i<=n; i++)
        cin>>a[i];
    for(i=1; i<=n; i++){
        if(a[i]!=i)
        {
            for(j=1; j<=n; j++)
                if(a[j]==i)
                {
                    t=a[i];
                    a[i]=i;
                    a[j]=t;
                    break;
                }
            s++;
        }
    }
    cout<<s;
    return 0;
}
```

#### [AC记录](https://www.luogu.com.cn/record/108695224)


---

## 作者：andyli (赞：1)

考虑遍历整个数组，贪心地进行交换。即若遇到 $a_i \neq i$，则交换 $a_i,a_j$，其中 $a_j = i$。  
本题数据范围较小，因此可以暴力查找这样的 $j$。另一种方法是记录 $p_i$，使得 $a_{p_i} = i$，这样每次可以直接找到 $j$。  

```cpp
int main() {
    dR(int, n);
    std::vector<int> a(n);
    io.read(a);
    int cnt = 0;
    for (int i = 0; i < n; i++)
        if (a[i] != i + 1) {
            for (int j = 0; j < n; j++)
                if (a[j] == i + 1) {
                    std::swap(a[i], a[j]);
                    cnt++;
                    break;
                }
        }
    writeln(cnt);
    return 0;
}
```

---

## 作者：StarRain3 (赞：1)

看见题解区其他大佬的代码都好简洁，蒟蒻自愧不如，在这里讲一种更容易理解的方法。

此方法更适合没学过贪心的初学者。

#### 分析
我最开始做这道题的时候思路很简单，只要前边一个数，比后边临近的大，就把他俩交换，然后，如果是交换了 $n-1$ 次的话，就需要特别处理一下，这时的次数是 $n$ 的一半次。

理解了这个方法就不需要去考虑贪心了，纯模拟即可。

#### 核心代码
```
for(int i=1;i<n;i++){
	if(a[i-1]>a[i]){
		swap(a[i-1],a[i]);
		s++;
	}
}
if(n-1==s){
	s/=2;
}
```

---

## 作者：tZEROちゃん (赞：0)

考虑贪心。

从头到尾扫描原序列，如果发现有数不在位置上，就找到对应的数然后交换。

具体的，从 $1$ 到 $n$ 枚举 $i$，若 $a_i \neq i$，则 $ans\leftarrow ans+1$，然后交换 $a_i, a_j$，其中 $a_j$ 是在原序列中等于 $i$ 的数。

```pascal
var ans, n, i, j, t: longint;
var a: array[0..100010] of int64;
begin
  read(n);
  for i := 1 to n do read(a[i]);
  for i := 1 to n do
  begin
    if a[i] <> i then
    begin
      inc(ans);
      for j := i + 1 to n do
      begin
        if a[j] = i then 
        begin
          t := a[i];
          a[i] := a[j];
          a[j] := t;
        end;
      end;
    end;
  end;
  writeln(ans);
end.
```

---

## 作者：封禁用户 (赞：0)

## 分析

这不是模拟嘛……

我们定义一个数组 `where[]`，`where[i]` 表示数字 $i$ 在该排列当中的位置。然后枚举每一个数字 $i$，若 $i$ 的位置正好在 $i$ 上，则跳过；若不在，交换当前 $i$ 的位置上的信息与 $i$ 应该在的位置上的信息，步数加一。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[10000];
int where[100000];
int ans;
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],where[a[i]]=i;
	for(int now=1;now<=n;now++)
	{
		if(where[now]==now) continue;
		else where[a[now]]=where[now],a[where[now]]=a[now],a[now]=now,where[now]=now,ans++;//交换位置，交换值
	}
	cout<<ans;
}
```


---


# [蓝桥杯 2017 省 AB] 包子凑数

## 题目描述

小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有 $N$ 种蒸笼，其中第 $i$ 种蒸笼恰好能放 $A_i$ 个包子。每种蒸笼都有非常多笼，可以认为是无限笼。

每当有顾客想买 $X$ 个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有 $X$ 个包子。比如一共有 $3$ 种蒸笼，分别能放 $3$ 、 $4$ 和 $5$ 个包子。当顾客想买 $11$ 个包子时，大叔就会选 $2$ 笼 $3$ 个的再加 $1$ 笼 $5$ 个的（也可能选出 $1$ 笼 $3$ 个的再加 $2$ 笼 $4$ 个的）。

当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有 $3$ 种蒸笼，分别能放 $4$ 、 $5$ 和 $6$ 个包子。而顾客想买 $7$ 个包子时，大叔就凑不出来了。

小明想知道一共有多少种数目是包子大叔凑不出来的。

## 说明/提示

对于样例 $1$，凑不出的数目包括：$1,2,3,6,7,11$。

对于样例 $2$，所有奇数都凑不出来，所以有无限多个。

蓝桥杯 2017 省赛 A 组 H 题。

## 样例 #1

### 输入

```
2  
4  
5  ```

### 输出

```
6```

## 样例 #2

### 输入

```
2  
4  
6   ```

### 输出

```
INF```

# 题解

## 作者：0x282e202e2029 (赞：23)

# P8646 [蓝桥杯 2017 省 AB] 包子凑数 题解
~~为了红名疯狂写题解的~~蒟蒻又来啦~

[题目传送门](https://www.luogu.com.cn/problem/P8646)
## 前置知识
​在数论中，裴蜀定理是一个关于最大公约数（或最大公约式）的定理。裴蜀定理得名于法国数学家艾蒂安·裴蜀，说明了对任何整数 $a$、$b$ 和它们的最大公约数 $d = \gcd(a, b)$，关于未知数 $x$ 和 $y$ 的线性丢番图方程

$$ax + by = m$$

有解当且仅当 $d | m$。裴蜀等式有解时必然有无穷多个整数解。

特别来说，方程 $ax + by = 1$ 有解当且仅当整数 $a$ 和 $b$ 互素。

对于多个整数而言，情况是类似的。
## 思路
为方便，这里我们使用 $\gcd(\{A_i\})$ 表示 $\{A_i\}$ 中所有数的最大公约数。

首先，一个显而易见的结论是：

**当 $\gcd(\{A_i\}) = 1$ 时，凑不出的数目只有有限多个；而当 $\gcd(\{A_i\}) > 1$ 时，凑不出的数目有无限多个。**

看到大佬们似乎都对这个结论一笔带过，这里蒟蒻就给出证明方式：

首先，由裴蜀定理可得，当 $\gcd(\{A_i\}) = 1$ 时，对于任意 $X \in \mathbb{N^+}$，方程

$$A_1\alpha + A_2\beta + \cdots = X$$

都存在无穷多个整数解，那么必定只有有限多个 $X$，使得该方程无自然数解。

证毕。

判断出是否输出 INF 后，我们就可以使用 dp 的做法将剩余情况处理掉了。

dp 数组只用开 $100005$ 的大小，对于本题的数据范围足够了。

注意到如果某个 $k - A_i$ 能被凑出，$k$ 也必能被凑出，因此状态转移方程为 $dp_k = \max(dp_k,dp_{k - A_i})$（注意写法！一定是 $\max$！否则有可能原本可以的数变得不行了，然后全 WA）。
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int gcd(int m, int n)
{
	if(n)
	{
		return gcd(n, m % n);
	}
	else
	{
		return m;
	}
}//求gcd(m,n),常见的递归写法
const int MAXN = 105, MAX_DP = 100005;//又来定义
int n, a[MAXN], dp[MAX_DP], ans;
bool notCoprime(int *arr)//返回arr数组中所有数的最大公约数是否大于1
{
	int g = arr[0];
	for(int i = 1; i < n; i++)
	{
		g = gcd(g, arr[i]);
		if(g == 1)
		{
			return false;//如果g已经为1，不用再循环，直接返回
		}
	}
	return g > 1;
}//定义函数，运行更快
int main()
{
	scanf("%d", &n);
	for(int i = 0; i < n; i++)
	{
		scanf("%d", &a[i]);
	}//输入
	if(notCoprime(a))//如果gcd({A_i})>1
	{
		printf("INF");
		return 0;//直接结束
	}
	dp[0] = 1;//注意0是被认为能被凑出的，否则所有数都凑不出来，循环检查时可以不用从0开始
	for(int i = 0; i < n; i++)
	{
		for(int j = a[i]; j < MAX_DP; j++)
		{
			dp[j] = max(dp[j], dp[j - a[i]]);//状态转移方程
		}
	}
	for(int i = 1; i < MAX_DP; i++)
	{
		if(!dp[i])
		{
			ans++;//如果dp[i]=0,多一个凑不出的数
		}
	}
	printf("%d", ans);//输出
	return 0;
}
```
[AC 记录](https://www.luogu.com.cn/record/108922217)

---

## 作者：xueruo (赞：8)

# 题意
给出 ${a_1,\dots,a_n}$ ，求没有几个整数 $c$ 满足 $c=ax+by$。   
设 $a,b$ 是整数。设 $d=\gcd(a,b)$，如果 $d$ 不能整除 $c$，那么方程没有整数解。如果 $d$ 能整除 $c$，那么存在无穷多个整数解。  
显然，如果 $\gcd(a,b)=1$，由于 $1$ 能整除所有整数，此时 $ax+by$ 能得到所有整数。  
```cpp
#include<iostream>
#include<cstdio>
#include<cstdio>
#include<algorithm>
#include<climits>
#define int long long
using namespace std;
const int N=5e6+10;
int n,a[N],gcd_,mx;
bool dp[N];
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)scanf("%lld",&a[i]),mx=max(mx,a[i]);
	gcd_=a[1];
	for(int i=2;i<=n;++i)gcd_=__gcd(gcd_,a[i]);
	if(gcd_!=1)return (printf("INF"))&0;
	dp[0]=1;//一个都不要
	for(int i=0;i<=mx*mx+1;++i){
		if(dp[i]==1){// i 可以凑到 
			for(int j=1;j<=n;++j){
				dp[i+a[j]]=1;//再放 a[j] 个 
			}
		}
	}
	int ans=0;
	for(int i=1;i<=mx*mx+1;++i){
		if(dp[i]==0){
			++ans;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Smg18 (赞：4)

~~蓝桥杯没有青年组，刷不了。~~

这题的说明很好呀！样例二可以发现如果这组数不是互质，他们绝对有一堆质数组不出来呀。

因为非这些最大公因数的倍数弄不到。（一个数有无数个倍数这个不用解释吧。）

只有他们所有互质，才有可能后面的数只有一些组的出来。

所以我们可以直接把他们循环一次求出公因数，如下：

```cpp
	ll ggcd=arr[1];
	for(int i = 2;i<=n;i++){
		ggcd=__gcd(ggcd,arr[i]);
	}
	if(ggcd!=1){
		cout<<"INF";
		return 0;
	}
```

这样不用考虑爆掉力，然后直接套背包就过了。（选多个凑成总值，没有价值的完全背包，更简单！）

但是没有价值的完全背包第二个循环就不知道范围。我们可以读数据。

$$(1 \le N \le 100)$$

所以循环只用保证小于 $N \times N$ 即可。

```cpp
#include<bits/stdc++.h>
//#include<windows.h>
#define ll long long
#define Test ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define R(i,j) for(auto i:j)
//nth_element
using namespace std;
const int N=1e5+10,NN=1e3+10;//警钟敲烂
ll n,m,k,len,T,ans;
ll minn=INT_MAX,maxn=0;
char c[N];
ll arr[N],v[N];
//struct TT{};
signed main(){
	Test;
  	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>arr[i];
	} 
	ll ggcd=arr[1];
	for(int i = 2;i<=n;i++){
		ggcd=__gcd(ggcd,arr[i]);
	}
	if(ggcd!=1){//有倍数组不出来
		cout<<"INF";
		return 0;
	}
	v[0]=1;
	for(int i = 1;i<=n;i++){
		for(int j = arr[i] ;j<=114514;j++){
			v[j]=max(v[j-arr[i]],v[j]);
		}
	}
	int res=0;
	for(int i = 1;i<=114514;i++){// 臭死的范围不要也罢
		if(!v[i]){
			res++;
		}
	}
	cout<<res;
	return 0;
}


```


---

## 作者：5k_sync_closer (赞：3)

来一些不一样的做法。同余最短路。

以模 $a_1$ 的同余类为点集建图，有边 $[u]\xrightarrow{w}[v]$ 当且仅当 $u+w\equiv v\pmod{a_1}$。

则 $[0]$ 到 $[x]$ 的一条长度为 $d$ 的路径对应一种凑出 $d$ 的方案。

求出 $[0]$ 到其他同余类的最短路 $d_x$，则每个 $[x]$ 中能凑出的最小数为 $d_x$。

注意到能凑出 $d_x$ 就可以凑出 $d_x+ka_1|k\ge 0$，也就可以凑出 $[x]$ 中所有大于等于 $d_x$ 的数。

则每个 $x$ 中只有 $\lfloor\dfrac{d_x}{a_1}\rfloor$ 个小于 $d_x$ 的数凑不出来，答案为 $\sum\limits_{x=0}^{a_1-1}\lfloor\dfrac{d_x}{a_1}\rfloor$。

特别地，若 $d_x$ 不存在，则 $[x]$ 中所有数都凑不出，答案为 `INF`。

复杂度 $O(na_i\log(na_i))$。

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#define P pair<int, int>
using namespace std;
struct E
{
    int v, w, t;
} e[10050];
int n, c, z, a[150], d[150], h[150];
bool b[150];
priority_queue<P, vector<P>, greater<P>> q;
void A(int u, int v, int w)
{
    e[++c] = {v, w, h[u]};
    h[u] = c;
}
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d", a + i);
    for (int i = 0; i < a[1]; ++i)
        for (int j = 2; j <= n; ++j)
            A(i, (i + a[j]) % a[1], a[j]);
    memset(d, 0x3f, sizeof d);
    q.emplace(d[0] = 0, 0);
    while (!q.empty())
    {
        int u = q.top().second;
        q.pop();
        if (!b[u])
        {
            b[u] = 1;
            for (int i = h[u], v; i; i = e[i].t)
                if (d[v = e[i].v] > d[u] + e[i].w)
                    q.emplace(d[v] = d[u] + e[i].w, v);
        }
    }
    for (int i = 0; i < a[1]; ++i)
    {
        if (d[i] == 0x3f3f3f3f)
            return !puts("INF");
        z += d[i] / a[1];
    }
    printf("%d", z);
    return 0;
}
```


---

## 作者：Liquid_Oxygen (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P8646)

只有他们所有互质，才有可能后面的数只有一些组的出来。

否则输出无解。

循环只用保证大于 $N×N$ 即可。

上面几位大佬已经讲得很清楚了。

AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
int a[105],dp[1000005];
int main()
{
	int n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	int t=a[1];
	for(int i=2;i<=n;i++) t=__gcd(t,a[i]);
	if(t>1)//无限解 
	{
		cout<<"INF";
		return 0;
	}
	//有限不超过N^2
	dp[0]=1;
	for(int i=0;i<=1000000;i++) //保守亿点，1000^2 
		if(dp[i])
		for(int j=1;j<=n;j++)
			dp[i+a[j]]=1;
	int ans=0;
	for(int i=1;i<=1000000;i++) 
		if(!dp[i]) ans++;
	cout<<ans<<endl;
	return 0;
}

```



---

## 作者：DreamLand_zcb (赞：2)

## 简要题意

有 $n$ 种蒸笼，第 $i$ 种蒸笼能放 $a_i$ 个包子。每种蒸笼都有无限个。

现在让你选出若干笼包子来，一共有几种凑不出来的包子个数。（如果有无穷多种，输出 `INF`）

## 思路

设数列 $b_i$，使得 $b_i \times k = a_i$，则 $\sum a_i = k \times \sum b_i$ 所以所有凑出来的包子数不是 $k$ 的倍数的都是凑不出来的，输出 `INF`。

反之，如果所有 $a_i$ 互质（$k = 1$），那么凑不出来的有限。

可以考虑完全背包计算凑不出来的个数，对于每一个 $a_i$ 将所有可以凑到的包子数标记上，因为 $1 < n < 100$，$1 < a_i < 100$，可以估算到大约 $100000$ 的个数是最大值，标记如下：

```cpp
for(int j=1;j<=114514;j++)
	if(dp[j])
		dp[j+a]=1;
```

最后计算一下所有凑不到的个数就可以了。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

int n;
int dp[1145140];
int gcd(int a, int b)
{
    if(b == 0)  return a;
    else    return gcd(b, a%b);
}
int GCD;
int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	for(int i=1;i<=n;i++)
	{
		int a;
		cin >> a;
		dp[a] = 1;
		if(i == 1)	GCD = a;
		else	GCD = gcd(GCD, a);
		for(int j=1;j<=114514;j++)
			if(dp[j])
				dp[j+a]=1;
	}
	if(GCD != 1)	cout << "INF";
	else
	{
		int ans = 0;
		for(int i=1;i<=114514;i++)
			if(!dp[i])
				ans++;
		cout << ans;
	}
	return 0;
}

```

---

## 作者：SSTF2022ywh (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8646)

## 思路

这道题目可以使用动态规划来解决。首先，我们需要读入输入，然后判断输入列表中所有元素的最大公约数是否大于 $1$。如果是，说明有无限多个数目是包子大叔凑不出来的，直接输出 "INF" 并退出程序。否则，我们可以使用动态规划来填充一个长度为 $10001$ 的布尔值列表 $dp$，其中 dp$a_{i}$ 表示是否可以凑出 $i$ 个包子。最后，我们只需要统计 $dp$ 列表中 False 的个数，即为答案。

## Python Code


```python
n = int(input())  # 读入整数 n
A = [int(input()) for _ in range(n)]  # 读入长度为 n 的整数列表 A
dp = [False] * 10005  # 初始化长度为 10005 的布尔值列表 dp，全部赋值为 False
ans = 0  # 初始化计数器 ans 为 0

def init():
    dp[0] = True  # 将 dp[0] 赋值为 True
    for i in range(n):
        for j in range(A[i], 10001):
            dp[j] = dp[j] or dp[j - A[i]]  # 根据题目要求，填充 dp 列表

def gcd(m, n):
    if n:
        return gcd(n, m % n)  # 递归计算 m 和 n 的最大公约数
    else:
        return m

def notCoprime(arr):
    g = arr[0]
    for i in range(1, n):
        g = gcd(g, arr[i])  # 计算列表 arr 中所有元素的最大公约数
        if g == 1:
            return False  # 如果最大公约数为 1，则返回 False
    return g > 1  # 否则返回 True

if notCoprime(A):
    print("INF")  # 如果列表 A 中所有元素的最大公约数大于 1，则输出 "INF" 并退出程序
    exit()

init()  # 调用 init 函数，填充 dp 列表

for i in range(1, 10001):
    if not dp[i]:
        ans += 1  # 统计 dp 列表中 False 的个数

print(ans)  # 输出计数器 ans 的值
```

### 注意

注意，这里的 exit() 函数用于在列表 $A$ 中所有元素的最大公约数大于 $1$ 时退出程序，相当于 C++ 代码中的 return 0 语句。 


[已AC，请放心食用](https://www.luogu.com.cn/record/110725426)


---

## 作者：LHQing (赞：2)

### 题目分析：

结论 $1$：

若 $\gcd(a_1,a_2,a_3,\dots,a_n)\neq1$，那么凑不出的有无限多个，否则是有限多个。

对于前者，很好理解，对于 $\gcd(a_i)=k$，所有非 $k$ 的倍数都无法取到。对于后者，我们可以采用数学归纳法证明，有兴趣的可以去网上搜索。

结论 $2$：

对于有解的情况，每类包子看作不同重量的物品，每种可以取无限个。这变成了一个完全背包问题。对于重量的上限，是 $\sum a_i\le10^4$。

### 代码按如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pd(x) push_back(x)
#define all(x) x.begin(),x.end()
//==============================================================================
ll QP(ll x,ll y,ll mod){ll ans=1;for(;y;y>>=1,x=x*x%mod)if(y&1)ans=ans*x%mod;return ans;}
//==============================================================================
namespace IO{
	int readInt(){
		int x=0,y=0;char c=0;
		while(!isdigit(c))y|=c=='-',c=getchar();
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		return !y?x:-x;
	}
	void write(int x){if(!x)return;write(x/10);putchar(x%10);}
	void Output(int x){if(x<0)putchar('-'),x=-x;if(!x)putchar('0');else write(x);}
	void WL(int x){Output(x);putchar('\n');}
	void WS(int x){Output(x);putchar(' ');}
}
namespace Debug{
	void DeVec(vector<int> c){for(auto y:c)printf("%d ",y);puts("");}
}
//==============================================================================
const int N=1e5+10;
int gcd(int x,int y){return !y?x:gcd(y,x%y);}
int n;
bool f[N];
int a[N];
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	int d=a[1];for(int i=2;i<=n;i++)d=gcd(d,a[i]);
	if(d!=1){puts("INF");return 0;}
	f[0]=true;
	for(int i=1;i<=n;i++)
		for(int j=a[i];j<=1e4+10;j++)
			f[j]|=f[j-a[i]];
	int ans=0;
	for(int i=1;i<=1e4+10;i++)
		ans+=!f[i];
	cout<<ans;
	return 0;
}
```


---

## 作者：AK_heaven (赞：1)

我看各个大佬都是用数组在做这道题，我来丢一篇 bitset 的题解。

首先，如果不了解本篇题解 bitset用法原理的，可以看我的[博客](https://www.cnblogs.com/wxccd2z/p/17985902)。

我们发现这是一道凑数的题，所以可以直接开始用完全背包转移，正因为是完全背包，所以用这个方法需要考虑转移次数，这道题所有数凑完最大也才 $10^4$，所以我们只需要每个转移 $10^3$ 次就完全足够过掉这道题，明显，当所有数最大公因数不是 $1$ 时，答案为 $\operatorname{INF}$，所以开头判断一下即可。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e5;
int n, x[maxn];

int gcd(int a, int b) { if(!b) return a; return gcd(b, a%b); }

bool pd() {
	int Gcd = 0;
	for(int i = 1; i <= n; i++)
	  Gcd = gcd(Gcd, x[i]);
	return Gcd > 1;
} // 裴蜀定理可得：ax+by 永远能被 gcd(a, b) 整除 

bitset<maxn+1> S; // S 为 1 时说明可以拼凑出这个数 0 为不能。 

int main() {
	cin >> n;
	S[0] = 1;
	for(int i = 1; i <= n; i++)
	  cin >> x[i];
	sort(x+1, x+n+1);
	if(pd()) cout << "INF", exit(0);
	for(int i = 1; i <= n; i++)
	  for(int j = x[i]; j <= 1000; j++)
	    S |= S << x[i];
	int ans = 0; 
	for(int i = 1; i <= x[n]*990; i++)
	  if(!S.test(i)) ans++;
	cout << ans;
	return 0;
}
```


---


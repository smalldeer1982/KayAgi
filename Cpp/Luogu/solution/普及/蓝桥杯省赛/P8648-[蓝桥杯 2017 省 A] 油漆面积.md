# [蓝桥杯 2017 省 A] 油漆面积

## 题目描述

X 星球的一批考古机器人正在一片废墟上考古。

该区域的地面坚硬如石、平整如镜。

管理人员为方便，建立了标准的直角坐标系。

每个机器人都各有特长、身怀绝技。它们感兴趣的内容也不相同。

经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。

矩形的表示格式为 $(x_1,y_1,x_2,y_2)$，代表矩形的两个对角点坐标。

为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。

小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。

其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。

注意，各个矩形间可能重叠。

本题的输入为若干矩形，要求输出其覆盖的总面积。


## 说明/提示

蓝桥杯 2022 省赛 A 组 J 题。

## 样例 #1

### 输入

```
3
1 5 10 10
3 1 20 20
2 7 15 17
```

### 输出

```
340```

## 样例 #2

### 输入

```
3
5 2 10 6
2 7 12 10
8 1 15 15```

### 输出

```
128```

# 题解

## 作者：rui_er (赞：17)

怎么题解区全是扫描线，还有个 $O(n^3)$ 暴力老哥。

为防止误导新人，给个理论上稳过的 $O(n^2)$ 解法。

二维前缀和可以处理若干次单点加，最后若干次矩形查的问题。

将其差分，即可处理若干次矩形加，最后若干次单点查的问题。

于是我们使用差分将所有矩形加上，然后做一遍二维前缀和，即可求出每个格子被几个矩形覆盖。统计有多少格子被至少一个矩形覆盖，输出即可。

注意本题卡空间，但注意到差分阶段每个格子只会被每个矩形 $\pm 1$，每个格子的值不超过 $10^4$，最终求前缀和后每个格子只会被每个矩形覆盖至多一次，值也不超过 $10^4$，因此开 short 即可。

时间复杂度 $O(n^2)$。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

const int N = 1e4+5;

int n, ans;
short a[N][N];

int main() {
    scanf("%d", &n);
    rep(i, 1, n) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        ++a[x1][y1];
        --a[x1][y2];
        --a[x2][y1];
        ++a[x2][y2];
    }
    rep(i, 0, 10000) {
        rep(j, 0, 10000) {
            a[i][j] = int(i > 0 ? a[i-1][j] : 0) + (j > 0 ? a[i][j-1] : 0) - (i > 0 && j > 0 ? a[i-1][j-1] : 0) + a[i][j];
            if(a[i][j]) ++ans;
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：___w (赞：14)

### [P8648 油漆面积](https://www.luogu.com.cn/problem/P8648)

### upd：被 hack 了，应将数组开大点，感谢 @rui_er 的指出。

[扫描线](https://www.luogu.com.cn/problem/P5490)的板子题，不会的可以先写一下这道题。

#### 题意简述
给定 $n$ 个矩形，求这些矩形所覆盖的面积之和。

#### 扫描线
扫描线顾名思义就是有一条线自底向上扫动（其实怎么扫都无所谓），通常用来求矩形所覆盖的面积或周长。

![1](https://oi-wiki.org/geometry/images/scanning.svg)

上面这张图很好的演示了扫描线的全过程，我们可以把整个矩形分成若干个小矩形，这些小矩形的高就是扫描线扫过的距离，而小矩形的长就可以用线段树来维护。

具体地，线段树的节点需要维护两个值，分别是 $cnt$ 和 $len$，分别表示当前区间被覆盖的次数，区间内覆盖的长度和。

- 若 $cnt>0$，不管覆盖多少次，$len$ 一定就是当前节点的区间长度。

- 若 $cnt=0$，$len$ 就为左右子节点的 $len$ 的和。

```cpp
void update(int p) {
	if (t[p].cnt) t[p].len = a[t[p].r+1]-a[t[p].l];
	else t[p].len = t[p<<1].len+t[p<<1|1].len;
}
```
有了这段代码，剩下的就是线段树的板子了，~~于是就可以愉快的切过这道题了~~。
#### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e4+5;
int n, tot, a[N<<2];
ll ans;//十年oi一场空，不开long long见祖宗
struct edge {
	int y, x1, x2, k;
} e[N<<1];
struct SegmentTree {
	int l, r;
	ll len, cnt;
} t[N<<3];
void build(int p, int l, int r) {
	t[p].l = l, t[p].r = r;
	if (l == r) return;
	int mid = (l+r)>>1;
	build(p<<1, l, mid);
	build(p<<1|1, mid+1, r);
}
void update(int p) {//向上传递
	if (t[p].cnt) t[p].len = a[t[p].r+1]-a[t[p].l];
	else t[p].len = t[p<<1].len+t[p<<1|1].len;
}
void change(int p, int l, int r, int x) {
	if (l <= t[p].l && t[p].r <= r) {
		t[p].cnt += x;
		update(p);
		return;
	}
	int mid = (t[p].l+t[p].r)>>1;
	if (l <= mid) change(p<<1, l, r, x);
	if (mid < r) change(p<<1|1, l, r, x);
	update(p);
}
bool cmp(edge x, edge y) {return x.y < y.y;}
int query(int x) {return lower_bound(a+1, a+tot+1, x)-a;}//查询
int main() {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		e[(i<<1)-1] = (edge){y1, x1, x2, 1};
		e[i<<1] = (edge){y2, x1, x2, -1};
		a[(i<<1)-1] = x1, a[i<<1] = x2;
	}
	n <<= 1;
	sort(e+1, e+n+1, cmp);
	sort(a+1, a+n+1);
	tot = unique(a+1, a+n+1)-a-1;//离散化
	build(1, 1, tot);
	for (int i = 1; i <= n; ++i) {
		change(1, query(e[i].x1), query(e[i].x2)-1, e[i].k);
		ans += t[1].len*(e[i+1].y-e[i].y);
	}
	cout << ans;
	return 0;
}
```
[P8734](https://www.luogu.com.cn/problem/P8734)，[P1856](https://www.luogu.com.cn/problem/P1856)，[P1502](https://www.luogu.com.cn/problem/P1502)，[P5490](https://www.luogu.com.cn/problem/P5490) 这些都是扫描线的题，有兴趣可以做一做。

---

## 作者：dg114514 (赞：7)

这题不需要用二维差分或者扫描线，只需要你会一维差分即可。\
具体的，每次修改二维差分是 $\Theta(1)$ 的，改为一维差分可以枚举 $x$ 或 $y$ 轴，然后分别做。\
最后处理数据时令 $d_{i,j}\gets\sum\limits^{j-1}_{k=0} d_{i,k}$ 就复原了原矩阵。\
**注意，由于不是网格上的矩形，$x_1,y_1,x_2,y_2$ 是点，所以实际上 $x_2$ 和 $y_2$ 要减一。**\
复杂度与二维差分相同，为 $O(n^2)$。但是常数略大于二维差分。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
short d[10005][10005],ans=0;
main(){
	int n,x1,y1,x2,y2;
	cin>>n;
	while(n--){
		cin>>x1>>y1>>x2>>y2,x2--,y2--;//
		for(int i=y1;i<=y2;i++) d[i][x1]++,d[i][x2+1]--;//暴力一维差分 
	}
	for(int i=0;i<=10000;i++)
		for(int j=0;j<=10000;j++){
			d[i][j]+=(j?d[i][j-1]:0);//还原 
			if(d[i][j]) ans++;
		}
	cout<<ans;
}
```

---

## 作者：__DDDDDD__ (赞：5)

# 题目分析

题意：给定 $n$ 个矩形，求矩形面积并。

扫描线板子题，~~数据范围甚至小于 [P5490](https://www.luogu.com.cn/problem/P5490)......？~~

扫描线的基本思想就是以 $x$ 轴每个点为数组下标，以 $y$ 轴从小到大逐个扫描，同时用一个线段树维护数组 $cnt$、$dat$，分别表示每个点被覆盖的次数与覆盖的总长度。

维护 $dat$ 的方式：

1. 如果线段树上该点已被覆盖（即 $cnt \geq 1$），则该点 $dat$ 值等于 $r-l+1$；

1. 否则 $dat$ 值等于左右子节点 $dat$ 值之和。

每次统计线段树顶端的 $dat$ 值，将该值乘以当次扫描宽度累加到答案即可。

具体分析与细节详见代码部分：


# 代码+注释

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100010
typedef long long ll;
ll x1,x2,h1,h2,dis[MAXN*2],val[MAXN*2],ans;
int n,tot,maxn=(1<<30)-1;
/*-------------------------------------初始化------------------------------------*/
struct scanline{
	ll x,lh,rh;
	int d;
}a[MAXN];
bool cmp(scanline a,scanline b){							// 扫描线的比较函数 
	if(a.x!=b.x)return a.x<b.x;								// 优先x轴从左到右 
	return a.d>b.d;											// 处理d=1紧贴d=-1的情况 
}
/*-----------------------------------线段树部分-----------------------------------*/ 
struct SegmentTree{
	int l,r,dat,cnt;
}t[MAXN*4];
inline void update(int p){									// 从下往上更新节点 
	if(t[p].l==maxn&&t[p].r==maxn)return; 
	if(t[p].cnt)t[p].dat=val[t[p].r+1]-val[t[p].l];			// 被覆盖时等于左右节点之差 
	else t[p].dat=t[p*2].dat+t[p*2+1].dat;					// 未被覆盖则等于子节点覆盖长度之和 
}
void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	t[p].dat=0;t[p].cnt=0;
	if(l==r)return;
	int mid=(l+r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
void add(int p,int l,int r,int d){
	if(l<=t[p].l&&r>=t[p].r){
		t[p].cnt+=d;
		update(p);
		return;
	}
	int mid=(t[p].l+t[p].r)/2;
	if(l<=mid)add(p*2,l,r,d);
	if(mid<r)add(p*2+1,l,r,d);
	update(p);
}
/*-------------------------------------主函数---------------------------------------*/ 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld%lld",&x1,&h1,&x2,&h2);
		a[i*2-1].lh=a[i*2].lh=h1;
		a[i*2-1].rh=a[i*2].rh=h2;
		a[i*2-1].x=x1;a[i*2].x=x2;
		a[i*2-1].d=1;a[i*2].d=-1;
		dis[++tot]=h1;dis[++tot]=h2;						// dis数组用于离散化 
	}
	sort(dis+1,dis+n*2+1);
    int cnt=unique(dis+1,dis+n*2+1)-dis-1;
	for(int i=1;i<=n*2;i++){								// 离散化部分 
		int pos1=lower_bound(dis+1,dis+cnt+1,a[i].lh)-dis;	
		int pos2=lower_bound(dis+1,dis+cnt+1,a[i].rh)-dis;
		val[pos1]=a[i].lh;val[pos2]=a[i].rh;
		a[i].lh=pos1;maxn=max(maxn,pos1);a[i].rh=pos2;		// 用离散化后的值更新扫描线
	}
	sort(a+1,a+n*2+1,cmp);									// 对扫描线从左到右排序 
	build(1,1,n*2);
	for(int i=1;i<=n*2;i++){
		add(1,a[i].lh,a[i].rh-1,a[i].d);
		ans+=(a[i+1].x-a[i].x)*(t[1].dat);
	}
	printf("%lld",ans);
	return 0;
} 
```


---

## 作者：AzureHair (赞：3)

简明题干：有 $n$ 个矩形，求矩形覆盖总面积。  
这不一看就是扫描线的版子（甚至连改都不用改。
![](https://oi-wiki.org/geometry/images/scanning.svg)       
大体思路：      
扫描到矩形的下边就记录正在扫描的矩形边长。      
扫描到矩形的上边就计算面积记录到结果中，细节在代码注释中。       
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,x,y,xx,yy;
const int maxn=100010;
struct scan//记录矩形上下边的位置
{
	int l,r,h,tag;
}lines[maxn<<1];
bool cmp(scan s,scan ss)//根据线的高度排序
{
	if(s.h!=ss.h)
	{
		return s.h<ss.h;
	}
	return s.tag>ss.tag;
}
int ans;
int xcnt,xaxis[maxn<<1];
map<int,int> mp;
//以下为线段树
struct point
{
	int l,r,minn,minlen,add;
}tree[maxn<<3];
inline void pushup(int x)
{
	int lson=x<<1,rson=lson|1;
	tree[x].minn=min(tree[lson].minn,tree[rson].minn);
	tree[x].minlen=0;
	if(tree[x].minn==tree[lson].minn)tree[x].minlen+=tree[lson].minlen;
	if(tree[x].minn==tree[rson].minn)tree[x].minlen+=tree[rson].minlen;
}
inline void pushadd(int x,int k)
{
	tree[x].add+=k;
	tree[x].minn+=k;
}
inline void pushdown(int x)
{
	if(tree[x].l==tree[x].r)return;
	int lson=x<<1,rson=lson|1;
	if(tree[x].add!=0)
	{
		pushadd(lson,tree[x].add);
		pushadd(rson,tree[x].add);
		tree[x].add=0;
	}
}
void build(int x,int l,int r)
{
	tree[x]=(point){l,r,0,0,0};
	if(l==r)
	{
		tree[x].minlen=xaxis[tree[x].r+1]-xaxis[tree[x].l];
		return;
	}
	int mid=(tree[x].l+tree[x].r)>>1,lson=x<<1,rson=lson|1;
	build(lson,l,mid);build(rson,mid+1,r);
	pushup(x);
}
void modify(int x,int l,int r,int k)
{
	pushdown(x);
	if(l<=tree[x].l&&r>=tree[x].r){pushadd(x,k);return;}
	int mid=(tree[x].l+tree[x].r)>>1,lson=x<<1,rson=lson|1;
	if(l<=mid)modify(lson,l,r,k);
	if(r>mid)modify(rson,l,r,k);
	pushup(x);
}
inline int getlen()
{
	if(tree[1].minn>0)return xaxis[tree[1].r+1]-xaxis[tree[1].l];
	else return xaxis[tree[1].r+1]-xaxis[tree[1].l]-tree[1].minlen;
}
//以上为线段树
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>x>>y>>xx>>yy;
		lines[2*i-1]=(scan){x,xx,y,1};//储存线的信息
		lines[2*i]=(scan){x,xx,yy,-1};
		xaxis[2*i-1]=x;xaxis[2*i]=xx;
	}
	sort(xaxis+1,xaxis+2*n+1);
	xcnt=unique(xaxis+1,xaxis+2*n+1)-xaxis-1;
	for(int i=1;i<=xcnt;i++)mp[xaxis[i]]=i;//离散化
	sort(lines+1,lines+2*n+1,cmp);
	build(1,1,xcnt-1);
	for(int i=1;i<=2*n;i++)
	{
		ans+=getlen()*(lines[i].h-lines[i-1].h);
		modify(1,mp[lines[i].l],mp[lines[i].r]-1,lines[i].tag);//记录答案
	}
	printf("%lld\n",ans);
	return 0;
}
```
双倍经验的扫描线板子见P5490。

---

## 作者：GZXUEXUE (赞：1)

### 前置

#### 「二维前缀和」是什么？

其实就是前缀和放在了二维数组上（废话），也就是说，假设前缀和数组是 $p$，原数组是 $a$，那么有：  
$$p_{i,j}={\sum\limits_{x=1}^{i}{{\sum\limits_{y=1}^{j}{a_{x,y}}}}}$$

### 思路

~~明显扫描线。~~  
我们不需要用到大炮打蚊子的做法，其实就是二维前缀和，然后把它差分看看格子是不是被涂色了。

### 实现

注意数据范围，$0 \le x_1,y_1,x_2,y_2$。详见[这个帖子](https://www.luogu.com.cn/discuss/1090579)。

```cpp
# include <iostream>
using namespace std;
const int n = 10000; int cnt,pre[n+5][n+5];
int main(){
	int m; cin >> m;
	while (m--){
		int x1,y1,x2,y2; cin >> x1 >> y1 >> x2 >> y2;
		pre[x1][y1]++,pre[x1][y2]--,pre[x2][y1]--,pre[x2][y2]++;
	}for (int i = 0;i <= n;i++){
		for (int j = 0;j <= n;j++){
			if (i - 1 >= 0 && j - 1 >= 0) pre[i][j] -= pre[i-1][j-1];
			if (i - 1 >= 0) pre[i][j] += pre[i-1][j];
			if (j - 1 >= 0) pre[i][j] += pre[i][j-1];
			if (pre[i][j]) cnt++;
		}
	}cout << cnt;
	return 0;
}
```

---

## 作者：__liujy (赞：0)

## 零. 前言
前置知识：二维差分。
## 壹. 思路
对于输入的 $x_{1},y_{1},x_{2},y_{2}$，是矩形的左上角和右下角，我们可以利用差分去存这一个长方形，最后如果 $b_{i,j}$ 不为 $0$，那么一定至少有一个矩形覆盖在上面，把面积加一即可。
## 贰. 代码
```cpp
// P8648 [蓝桥杯 2017 省 A] 油漆面积
#include<bits/stdc++.h>
#define ri register int
const int MAXN=10005;
int n,b[MAXN][MAXN],mix=INT_MAX,miy=INT_MAX,mxx,mxy;
int main()
{
    scanf("%d",&n);
    for(ri _=1,x,y,xx,yy;_<=n;_++)
    {
        scanf("%d%d%d%d",&x,&y,&xx,&yy);
        x++,y++,xx++,yy++,
        b[x][y]++,
        b[x][yy]--,
        b[xx][y]--,
        b[xx][yy]++;
    }
    int ans=0;
    for(ri i=1;i<=10001;i++)
        for(ri j=1;j<=10001;j++)
        {
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
            if(b[i][j]) ans++;
        }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：zhangmuning1016 (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P8648)

## 思路
很明显考虑扫描线。什么是扫描线呢？就是用来算矩形面积并或周长并的方法。具体看 [扫描线介绍](http://oiwiki.com/geometry/scanning/)。

具体做法：
- 把整个矩形并分成若干个小矩形。
- 这些小矩形的 $y$ 坐标就是扫描线扫过的距离，而小矩形的 $x$ 坐标用线段树来维护。

没学过的可以看看 [P5490 【模板】扫描线 & 矩形面积并](https://www.luogu.com.cn/problem/P5490)。  
**注意：要开至少 $8$ 倍空间。**
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=4e5+10;
int n,X[N<<1];
struct node{
	int l,r,h,mk;
	bool operator<(const node&oth)const{
		return h<oth.h;
	}
}li[N<<1];
struct Node{
	int l,r,len,sum;
}hv[N<<2];
inline void fun1(int id){
	if(hv[id].sum)hv[id].len=X[hv[id].r+1]-X[hv[id].l];
	else hv[id].len=hv[(id<<1)].len+hv[(id<<1|1)].len; 
}
void fun2(int id,int l,int r){
	hv[id].l=l,hv[id].r=r;
	hv[id].len=hv[id].sum=0;
	if(l>=r)return;
	int mid=(l+r)>>1;
	fun2((id<<1),l,mid);
	fun2((id<<1|1),mid+1,r);
}
void add(int id,int L,int R,int mrk){
	int l=hv[id].l,r=hv[id].r;
	if(X[l]>=R||X[r+1]<=L)return;
	if(X[l]>=L&&X[r+1]<=R){
		hv[id].sum+=mrk;
		fun1(id);
		return;
	}
	add((id<<1),L,R,mrk);
	add((id<<1|1),L,R,mrk);
	fun1(id);
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x1_,x2_,y1_,y2_;
		cin>>x1_>>y1_>>x2_>>y2_;
		X[2*i-1]=x1_,X[i<<1]=x2_;
		li[2*i-1]=(node){x1_,x2_,y1_,1};
		li[i<<1]=(node){x1_,x2_,y2_,-1};
	}
	n<<=1;
	sort(X+1,X+n+1);
	sort(li+1,li+n+1);
	int tot=unique(X+1,X+n+1)-X-1;
	fun2(1,1,tot-1);
	int ans=0;
	for(int i=1;i<n;i++){
		add(1,li[i].l,li[i].r,li[i].mk);
		ans+=hv[1].len*(li[i+1].h-li[i].h);
	}
	cout<<ans;
	return 0;
}
```
时间复杂度是 $O(n \log n)$，在此题可以接受。

---

## 作者：Zskioaert1106 (赞：0)

题目传送门：[P8648 [蓝桥杯 2017 省 A] 油漆面积](https://www.luogu.com.cn/problem/P8648)

输入为若干矩形，要求输出其覆盖的总面积，即矩形面积并问题，可以用扫描线解决。

### 扫描线

前置知识：线段树。

![](https://cdn.luogu.com.cn/upload/image_hosting/b0iigiag.png)

我们想象有一条线从下向上扫描。图中四条绿线将图形分割成了三个不重合的矩形，我们可以分别求出其面积。

在知道原矩形每条边的情况下，矩形的高已经有了——拿上边的横坐标减下边。如何求矩形的宽？我们可以用线段树。

我们维护扫描线上每段是否有矩形覆盖，元线段就取离散化后相邻的两个 $x$ 坐标。容易发现，只要元线段的值 $\geqslant 1$，就要返回这段元线段的长度。

现在的问题是怎么知道一段线段中是否所有的元线段都被覆盖，因为重复贡献同一段是没有用的，但是不计的话删除又会出问题。

这里提供两种方法。

第一种方法：标记永久化。

我们建线段树时记录这段区间真正的的长度 $len$，然后因为记录的是线段端点，所以如果 $l$ 和 $r$ 在离散化数组中还相隔元素，就继续向下建。注意这里是与维护序列的线段树不同的。

之后的修改中，如果当前区间被大区间包含就将 $tag_u$ 增减 $1$，否则按正常的线段树向下递归。关键在于 $\operatorname{puhsup}$：如果 $tag_u > 0$，则当前区间都被覆盖了，即为 $len_u$；当非全覆盖时，如果这里是元线段，返回 $0$，否则要将两条子线段加起来。

```cpp
void build(int u,int l,int r){
    L[u]=x[l],R[u]=x[r],len[u]=x[r]-x[l];
    if(l<r-1)build(u*2,l,(l+r)/2),build(u*2+1,(l+r)/2,r);
}
void update(int u,int l,int r,short p){
    if(l<=L[u]&&R[u]<=r)tag[u]+=p;
    else if(l<=R[u]&&L[u]<=r)update(u*2,l,r,p),update(u*2+1,l,r,p);
    if(tag[u]>0)s[u]=len[u];
    else s[u]=s[u*2]+s[u*2+1];// 不要学习这种写法，会让你需要多一倍的空间
}
```

第二种方法：我们用普通的线段树，发现维护区间被覆盖数的最小值和被覆盖最少处的长度即可。若前者为 $0$ 则从 $len$ 中减去后者，这两个信息都具有可合并性。

### 代码实现

我们采取第一种方法，先离散化再建线段树，按照纵坐标升序遍历所有边即可。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=20004;
int n,tot,x[N],L[N<<8],R[N<<8],len[N<<8];
struct line{
	int xl,xr,y;
	short p;
}a[N];
bool cmp(line a,line b){
	return a.y<b.y;
}
long long s[N<<8],tag[N<<8],ans;
void build(int u,int l,int r){
	L[u]=x[l],R[u]=x[r],len[u]=x[r]-x[l];
	if(l<r-1)build(u<<1,l,(l+r>>1)),build(u<<1|1,(l+r>>1),r);
}
void update(int u,int l,int r,short p){
    if(!len[u])return;
	if(l<=L[u]&&R[u]<=r)tag[u]+=p;
	else if(l<=R[u]&&L[u]<=r)update(u<<1,l,r,p),update(u<<1|1,l,r,p);
    s[u]=(tag[u]>0?len[u]:s[u<<1]+s[u<<1|1]);
}
int main(){
	cin>>n;
	for(int i=1,x1,y1,x2,y2;i<=n;i++){
		cin>>x1>>y1>>x2>>y2;
		if(x1>x2)swap(x1,x2);
		if(y1>y2)swap(y1,y2);
		x[(i<<1)-1]=x1,x[i<<1]=x2;
		a[(i<<1)-1]={x1,x2,y1,1},a[i<<1]={x1,x2,y2,-1};
	}
	n<<=1;
	sort(x+1,x+1+n);
	sort(a+1,a+1+n,cmp);
	tot=unique(x+1,x+1+n)-x-1;
	build(1,1,tot);
	for(int i=1;i<=n;i++){
		if(a[i].y!=a[i-1].y)ans+=s[1]*(a[i].y-a[i-1].y);
		update(1,a[i].xl,a[i].xr,a[i].p);
	}
	cout<<ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/219437309)。

---


# [蓝桥杯 2018 省 A] 倍数问题

## 题目描述

众所周知，小葱同学擅长计算，尤其擅长计算一个数是否是另外一个数的倍数。但小葱只擅长两个数的情况，当有很多个数之后就会比较苦恼。现在小葱给了你 $n$ 个数，希望你从这 $n$ 个数中找到三个数，使得这三个数的和是 $K$ 的倍数，且这个和最大。数据保证一定有解。

## 说明/提示

**【样例解释】**

选择 $2$、$3$、$4$。

**【数据约定】**

对于 $30\%$ 的数据，$n \le 100$。

对于 $60\%$ 的数据，$n \le 1000$。

对于另外 $20\%$ 的数据，$K \le 10$。

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le K \le 10^3$，给定的 $n$ 个数均不超过 $10^8$。

时限 1 秒，256M。蓝桥杯 2018 年第九届省赛。

## 样例 #1

### 输入

```
4 3
1 2 3 4```

### 输出

```
9```

# 题解

## 作者：5k_sync_closer (赞：22)

有 $a+b+c\equiv 0\pmod k$，则 $a\bmod k+b\bmod k+c\bmod k\in\{0,k,2k\}$。

证明比较显然，小于 $3k$ 的 $k$ 的倍数只有 $\{0,k,2k\}$。

分讨三种情况，对 $a\bmod k+b\bmod k+c\bmod k=z$ 的情况枚举 $a\bmod k,b\bmod k$，则 $c\bmod k=z-a\bmod k-b\bmod k$，

然后可以得到 $a\bmod k,b\bmod k,c\bmod k$ 的值，取同余类中最大值即可，注意重复情况。

复杂度 $O(n+k^2)$。

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int n, k, q, f[1050][3];
int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 0; i < k; ++i)
        f[i][0] = f[i][1] = f[i][2] = -6e8;
    for (int i = 1, x, y; i <= n; ++i)
    {
        scanf("%d", &x);
        if (f[y = x % k][0] < x)
            f[y][2] = f[y][1], f[y][1] = f[y][0], f[y][0] = x;
        else if (f[y][1] < x)
            f[y][2] = f[y][1], f[y][1] = x;
        else if (f[y][2] < x)
            f[y][2] = x;
    }
    for (int z = 0; z <= k << 1; z += k)
        for (int i = 0; i < k; ++i)
            for (int j = 0, p; j < k; ++j)
                if ((p = z - i - j) >= 0 && p < k)
                    q = max(q, f[i][0] + f[j][i == j] + f[z - i - j][(i == p) + (j == p)]);
    return !printf("%d", q);
}
```


---

## 作者：gpfgpf (赞：8)

根据题意，我们很容易就可以想到暴力枚举三个数，但这样时间复杂度达到了惊人的 $O(n^3)$,无法通过 $n\le10^5$ 的数据。因此，有必要进一步分析。

#### 1 按余数储存

不妨设选中的三个数为 $a,b,c$ 则有
$$
(a+b+c)\bmod k=0
$$
拆开则有

$$
a\bmod k+b\bmod k+c\bmod k=x
$$
其中 $x$ 为 $0,k,2k$。

由此我们只需以余数为标准，储存余数相同情况下最大的三个数即可，最后对 $a,b$ 进行枚举，由 $a,b$ 的余数确定 $c$。

#### 2 按情况分类

不难发现，三个数本身共有三种情况：均相同、两个相同、三个均不同。三个数的余数之和又有三种情况：$0,k,2k$。这几种情况下分别使得 $a,b,c$ 对 $k$ 的余数之和为 $0,k,2k$ 即可，同时注意去重。

代码如下，最终时间复杂度 $O(k^2)$。

```c
#include<stdio.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
int arr[1005][4];//arr[i][j]为余数是i的最大的三个数，降序排列，arr[i][3]存储当前余数为i的数有多少
void swap(int* a,int* b)
{
    int tmp=*a;
    *a=*b;
    *b=tmp;
    return ;
}
int main()
{
	int n,k,sum=0;
	int m,mod;
	scanf("%d%d",&n,&k);
	while(n--)
	{
		scanf("%d",&m);
		mod=m%k;
        if(arr[mod][3]<3)
        arr[mod][arr[mod][3]++]=m;
        else//更新最大的三个数
        {
            int j=arr[mod][1]<arr[mod][0]?1:0;
            j=arr[mod][j]<arr[mod][2]?j:2;
            if(m>arr[mod][j])
            arr[mod][j]=m;
        }
	}
	
    for(int i=0;i<k;i++)//对同余的数降序排列
    {
        if(arr[i][3]==2&&arr[i][0]<arr[i][1])
        swap(&arr[i][0],&arr[i][1]);
        else if(arr[i][3]>=3)
        {
            if(arr[i][0]<arr[i][1])
            swap(&arr[i][0],&arr[i][1]);
            if(arr[i][1]<arr[i][2])
            swap(&arr[i][2],&arr[i][1]);
            if(arr[i][0]<arr[i][1])
            swap(&arr[i][0],&arr[i][1]);
        }
    }

    if(arr[0][3]>=3)//模k之和为0
    sum=arr[0][0]+arr[0][1]+arr[0][2];
	if(k%3==0)//3个数均相同
    {
        if(arr[k/3][3]>=3)//模k之和为k
        sum=max(sum,arr[k/3][0]+arr[k/3][1]+arr[k/3][2]);
        if(arr[k/3*2][3]>=3)//模k之和为2*k
        sum=max(sum,arr[k/3*2][0]+arr[k/3*2][1]+arr[k/3*2][2]);
    }
	
	for(int i=0;i<k;i++)//有2个数相同
	{
		if(((k-i)&1)==0&&(k-i)/2!=i&&arr[(k-i)/2][3]>=2)//模k之和为k,去重
		sum=max(sum,arr[i][0]+arr[(k-i)/2][1]+arr[(k-i)/2][0]);
		if(((2*k-i)&1)==0&&(2*k-i)/2!=i&&arr[(2*k-i)/2][3]>=2)//模k之和为2k,去重
		sum=max(sum,arr[i][0]+arr[(2*k-i)/2][1]+arr[(2*k-i)/2][0]);
	}
	
	for(int i=0;i<k;i++)//3个数均不相同
	{
		for(int j=i+1;k-i-j>j;j++)
		{
			if(arr[i][0]&&arr[j][0]&&arr[k-i-j][0])//模k之和为k,去重
            sum=max(sum,arr[i][0]+arr[j][0]+arr[k-i-j][0]);
		}
	}
	for(int i=0;i<k;i++)
	{
		for(int j=max(i+1,k-i-1);2*k-i-j>j;j++)
		{
			if(arr[i][0]&&arr[j][0]&&arr[2*k-i-j][0])//模k之和为2k,去重
            sum=max(sum,arr[i][0]+arr[j][0]+arr[2*k-i-j][0]);
		}
	}
	printf("%d",sum);
	return 0;
}
```

蒟蒻的第一篇题解~

---

## 作者：liangbob (赞：2)

### P8663 题解

#### 思路分析

余数分析题。

设满足条件的三数为 $a,b,c$，由题意得 $a + b + c \equiv 0 \pmod k$。

于是有 $a\bmod k + b \bmod k + c \bmod k \equiv 0 \pmod k$。

又根据余数的性质，$a \bmod k,b \bmod k,c \bmod k < k$，即 $a \bmod k + b \bmod k + c \bmod k < 3k$。

所以，$a \bmod k + b \bmod k + c \bmod k = 0$ 或 $a \bmod k + b \bmod k + c \bmod k = k$  或 $a \bmod k + b \bmod k + c \bmod k = 2k$。

于是，我们枚举 $a \bmod k$，$b \bmod k$ 与 $a \bmod k + b \bmod k + c \bmod k$ 即可，这样便可以 $O(k^2)$ 的复杂度遍历 $a \bmod k$，$b \bmod k$ 与 $c \bmod k$。

此时问题转化为：已知 $a \bmod k$，$b \bmod k$ 与 $c \bmod k$，求 $a+b+c$ 的最大值。

这个其实直接更新就可以了，记原数组为 $p$，具体步骤如下：

- 开一个数组 $f$，$f_i$ 代表在 $p$ 中，模 $k$ 余 $i$ 的数的最大值。
- $f_{p_i \bmod k}=\max(p_i,f_{p_i \bmod k})$。

但是需要注意一个问题：数不能重复选。当 $a \bmod k$，$b \bmod k$ 相同时，$b \bmod k$ 应选择次大的，以此类推。当 $a \bmod k$，$b \bmod k$ 与 $c \bmod k$ 相同时，$b \bmod k$ 与 $c \bmod k$ 分别应选择次大和次次大。

于是，$f$ 数组应该改成三维的，三维分别表示：

- $f_{i,0}$ 代表在 $p$ 中，模 $k$ 余 $i$ 的数的最大值。
- $f_{i,1}$ 代表在 $p$ 中，模 $k$ 余 $i$ 的数的次大值。
- $f_{i,2}$ 代表在 $p$ 中，模 $k$ 余 $i$ 的数的次次大值。

为什么不从 $1$ 开始呢？因为这样只要通过 `f[j][(i==j)]` 就可以算出对应的数，其他同理。

也就是 `res = max(res, f[i][0]+f[j][(i==j)]+f[g][(i==g)+(j==g)])`。

最后再附上同时计算最大值、次大值、次次大值的算法。

设最大值、次大值、次次大值分别为 $x$，$y$，$z$，当前输入的数为 $t$。

- 若 $x < t$，则 $z = y$，$y=x$，$x=t$。
- 否则，若 $y < t$，则 $z = y$，$x=y$。
- 再否则，若 $z < t$，则 $z = t$。

#### 代码

```cpp
#include <iostream>
#include <iomanip>
#include <cmath>
#include <string>
#include <algorithm>
#include <cstdio>
#include <cstring>
#define endl '\n'
#define int long long
#define IL inline
using namespace std;
const int N = 1e5 + 10;
const int INF = 0x3f3f3f3f;

IL int read()
{
    int x = 0,f = 1;
    char c = getchar();
    while(c <'0'|| c >'9'){if(c == '-') f = -1;c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0',c = getchar();
    return x * f;
}

void write(int x)
{
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int f[N][3];
int a[N];
int res = -1e14;

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n, k;
	cin >> n >> k;
	for(int i = 0;i < k;i++) f[i][0] = f[i][1] = f[i][2] = -6e8; //初始化
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
		int t = a[i];
		int u = a[i] % k;
		if(f[u][0] < t) //统计最大、次大、次次大
		{
			f[u][2] = f[u][1];
			f[u][1] = f[u][0];
			f[u][0] = t;
		}
		else if(f[u][1] < t)
		{
			f[u][2] = f[u][1];
			f[u][1] = t;
		}
		else if(f[u][2] < t)
		{
			f[u][2] = t;
		}
	}
	for(int i = 0;i < k;i++)
	{
		for(int j = 0;j < k;j++)
		{
			for(int z = 0;z <= 2 * k;z += k) //枚举每个余数
			{
				int g = z - i - j;
				if(g < 0 || g >= k) continue; //越界跳过
				res = max(res, f[i][0] + f[j][(i == j)] + f[g][(i == g) + (j == g)]); //统计答案
			}
		}
	}
	cout << res << endl;
    return 0;
}
```

---

## 作者：sherry_lover (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P8663)

本题考点：数学，枚举。

------------
## 思路
### 30pts：

暴力枚举三个数，判断是否为 $k$ 的倍数，时间复杂度 $O(n^3)$。

~~其他的部分分作者没想到。~~

### 正解：

题目就是让我们求：设 $a+b+c = x$，满足 $x \equiv 0 \pmod k$ 的三个数 $a$，$b$，$c$ 的 $x_{\max}$。

把上面的式子拆开，得：

$\therefore$ $(a \bmod x + b \bmod x + c \bmod x ) \equiv 0 \pmod k$

$\because$ $a \bmod x + b \bmod x + c \bmod x = 0,k,2k$

我们直接枚举 $a$ $\bmod$ $x$，$b$ $\bmod$ $x$，$c$ $\bmod$ $x$ 就行了。

但我们要考虑，当 $a$ $\bmod$ $x$，$b$ $\bmod$ $x$，$c$ $\bmod$ $x$ 三个中有相同的结果时，我们可能要取最大值、次大值、次次大值。所以我们要维护同余的数的前三大值。

时间复杂度 $O(k^2)$。
## 标程

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005];
long long ans=-6e8,maxx[1005][3];
int main(){
	cin >> n >> k;
    for (int i = 0;i < k;i++) maxx[i][0] = maxx[i][1] = maxx[i][2] = -6e8;
	for(int i = 1;i <= n;i++)
	{
		cin >> a[i];
		int mod = a[i]%k;
        if(maxx[mod][0] < a[i]) maxx[mod][2] = maxx[mod][1],maxx[mod][1] = maxx[mod][0],maxx[mod][0] = a[i];
        else if(maxx[mod][1] < a[i]) maxx[mod][2] = maxx[mod][1],maxx[mod][1] = a[i];
        else if(maxx[mod][2] < a[i]) maxx[mod][2] = a[i];
	}
	for(int i = 0;i < k;i++)
	{
		for(int j = 0;j < k;j++)
		{
			for(int l = 0;l <= 2*k;l += k) //0,k,2k
			{
				int x = l-i-j;
				if(x < 0 || x >= k) continue;
				ans = max(ans,maxx[i][0]+maxx[j][(i==j)]+maxx[x][(i==x)+(j==x)]); //若i=j,说明余j要去到次大值。x同理。
			}
		}
	}
	cout << ans;
	return 0;
}

```

---

## 作者：Nuyoah_awa (赞：1)

### 题目大意
给定 $n$ 个数 $a_1\sim a_n$，请你选出三个数，使得三个数的和为 $K$ 的倍数，求三个数的最大和。

### 题目分析
我们不妨设选出的三个数是 $a, b, c$。

首先来想暴力，我们可以暴力枚举 $a, b, c$，然后计算，但是时间复杂度是 $\mathcal O(n ^ 3)$ 的，肯定会炸。

我们发现数据范围 $k \le 10 ^ 3$，$k$ 很小，我们可以考虑在 $k$ 上面下点文章。

按照题目，我们要使 $a + b + c \equiv 0\bmod k$，我们可以将其变形为 $(a \bmod k + b \bmod k + c \bmod k) \equiv 0 \bmod k$。

我们发现 $a,b,c \bmod k$ 一共只有 $k$ 种可能，我们就可以考虑开个桶 $cnt_i$ 表示 $\max \limits_{i = 1}^{i \le n}i(i \equiv 0 \bmod k)$。然后我们就可以枚举 $k$ 的余数，答案为：

$$ans = \max\sum_{a = 1}^{a \le k}\sum_{b = a + 1}^{b \le k}\sum_{c = b + 1}^{c \le k}cnt_a + cnt_b + cnt_c(a + b + c \equiv 0 \bmod k)$$

但是时间复杂度是 $\mathcal O(k ^ 3)$ 的，依旧过不了。

我们不难发现，当我们确定 $a$ 和 $b$ 后，$c$ 是唯一确定的（$c = (2 \times k - a - b) \bmod k$）。由此，我们只需要枚举 $a$ 和 $b$ 然后再计算 $c$ 就行了，最终的时间复杂度是 $\mathcal O(k ^ 2)$ 的。

---

## 作者：Suite_No1_G (赞：1)

分析：

暴力方法很简单，用 $O(n^3)$ 的时间枚举每个数，判断和是否为 $K$ 的倍数，然后更新最大值即可。

考虑正解：

考虑 $K$ 不大，可以从这个角度入手。

我们可以枚举两个数 $i$ 和 $j$，表示除以 $K$ 的余数。

则可以求出第三个数除以 $K$ 的余数 $x$。

我们定义 $mx_{i,j}$，存储 $n$ 个数中余数为 $i$ 的第 $j$ 大的数。其中 $j ≤ 3$。

然后更新答案。答案为 $mx_{i,0} + mx_{j,0} + mx_{x,0}$。

当然，记得特判其中两个（或三个）余数有相同的情况。

时间复杂度 $O(K^2)$。

code:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1010;
int mx[maxn][5];

signed main(){
	int n,k;
	scanf("%lld%lld",&n,&k);
	
	for (int i=1;i<=n;i++){
		int x;
		scanf("%lld",&x);
		
		int op=x%k;
		if (x>mx[op][0]){
			mx[op][2]=mx[op][1];
			mx[op][1]=mx[op][0];
			mx[op][0]=x;
		}else if (x>mx[op][1]){
			mx[op][2]=mx[op][1];
			mx[op][1]=x;
		}else if (x>mx[op][2]) mx[op][2]=x;
	}
	
	int ans=0;
	
	
	for (int i=0;i<k;i++){
		for (int j=0;j<k;j++){
			int x=-i-j;
			x=(x%k+k)%k;
			
			int id1=0,id2=0,id3=0;
			
			int num=0;
			num+=mx[i][id1]; id1++;
			if (i==j) id2=id1;
			if (i==x) id3=id1;
			
			num+=mx[j][id2]; id2++;
			
			if (j==x) id3=id2;
			
			num+=mx[x][id3];
			ans=max(ans,num);	
		}
	}
	
	printf("%lld",ans);
	return 0;
}
```


---


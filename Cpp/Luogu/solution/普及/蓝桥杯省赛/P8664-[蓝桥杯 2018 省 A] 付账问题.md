# [蓝桥杯 2018 省 A] 付账问题

## 题目描述

几个人一起出去吃饭是常有的事。但在结帐的时候，常常会出现一些争执。

现在有 $n$ 个人出去吃饭，他们总共消费了 $S$ 元。其中第 $i$ 个人带了 $a_i$ 元。幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？

为了公平起见，我们希望在总付钱量恰好为 $S$ 的前提下，最后每个人付的钱的标准差最小。这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 $1$ 分钱的整数倍。你需要输出最小的标准差是多少。

标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的“偏差有多大”。形式化地说，设第 $i$ 个人付的钱为 $b_i$ 元，那么标准差为 $s=\sqrt{\frac{1}{n}\sum_{i=1}^n(b_i-\frac{1}{n}\sum_{i=1}^n b_i)}$

## 说明/提示

**【样例解释】**

1. 每个人都出 2333/5 元，标准差为 0。

**【数据约定】**

对于 $10\%$ 的数据，所有 $a_i$ 相等；

对于 $30\%$ 的数据，所有非 $0$ 的 $a_i$ 相等；

对于 $60\%$ 的数据，$n \le 1000$；

对于 $80\%$ 的数据，$n \le 10^5$；

对于所有数据，$n \le 5 \times 10^5,0 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
5 2333
666 666 666 666 666```

### 输出

```
0.0000```

## 样例 #2

### 输入

```
10 30
2 1 4 7 4 8 3 6 4 7```

### 输出

```
0.7928```

# 题解

## 作者：zhjx2023 (赞：12)

### 思路
题意:计算在总付款量为 $S$ 的前提下，使每个人付的钱的标准差最小。标准差的计算涉及到每个人支付的金额，需要找到一种支付方案，使得标准差最小。
显然这是一道**贪心**题，那么思路就来了:
1. 读取输入的总人数 $ n $ 和总消费金额 $ S $。
2. 读取每个人带的钱数 $ a[i] $。
3. 将带的钱数升序排序。
4. 遍历每个人，计算其实际支付的金额 $ ans $，取最小值为当前人应该支付的金额，更新总消费额 $ s $，并计算偏差的平方。
`ans = min(a[i], s / (n - i + 1)),
		s -= ans, cnt += (ans - sum) * (ans - sum);`
5. 输出最终计算得到的标准差，四舍五入保留4位小数。
### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
//#define cin std:cin
//#define cout std:cout
using namespace std;
const ll N = 1e7 + 10, MOD = 1e9 + 7;
ll n;
long double a[N], s, ans, cnt;
int main() {
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> s;
	long double sum = (s / n * 1.0);
	for (ll i = 1; i <= n; i++)	cin >> a[i];
	sort(a + 1, a + 1 + n);
	for (ll i = 1; i <= n; i++)
		ans = min(a[i], s / (n - i + 1)),
		s -= ans, cnt += (ans - sum) * (ans - sum);
	printf("%.4Lf", sqrt(cnt / n));
	return 0;
}
```
完结撒花

---

## 作者：5k_sync_closer (赞：5)

考虑目前已经考虑了 $i$ 个人，还需要付 $S'$ 元钱。

则剩下 $n-i+1$ 个人出的钱应该往他们的平均数 $\dfrac{S'}{n-i+1}$ 靠拢。

所以若第 $i+1$ 个人的钱数大于 $\dfrac{S'}{n-i+1}$，则他出 $\dfrac{S'}{n-i+1}$ 元钱，否则他出 $a_{i+1}$ 元钱（即他全部的钱）。

这样做的话未考虑的人的平均数单调不降，所以要尽量让钱多的人后考虑，贪心前把 $\{a_n\}$ 升序排序即可。

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
using namespace std;
int n, a[500050];
long double s, x, z, q;
int main()
{
    scanf("%d%Lf", &n, &s);
    x = 1.0 * s / n;
    for (int i = 1; i <= n; ++i)
        scanf("%d", a + i);
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i)
        z = min(1.0l * a[i], s / (n - i + 1.0)), q += (z - x) * (z - x), s -= z;
    printf("%.4Lf", sqrt(q / n));
    return 0;
}
```


---

## 作者：Yashajin_Ai (赞：2)

### 思路
这道题要我们输出最小的标准差是多少，那么每个人付的钱尽量接近 $\frac{S}{n} \times 1.0$ 这一个值。

那么——有钱的出钱（多出点帮钱少的补上），钱少的出完（贡献自己最大利益），并且让钱少的先出按照从小到大的顺序依次支付，才知道后面钱多的帮忙补多少，如果当前这个人付的钱还不到 $\frac{S}{n} \times 1.0$，那就判断为全部交上去，当此刻的这个人所带的钱数到了 $\frac{S}{n} \times 1.0$ 了，那停循环，因为后面的人肯定都带的比他多或者一样了，所以直接乘后面的人数 $(n - i+1)$ 即可。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[500001];
int main() {
	long long n,S;
	cin>>n>>S;
	for(int i=1;i<=n;i++){
		cin>>a[i];//每个带了多少money 
	}
	sort(a+1,a+n+1);
	double ans=0.0,pjz=1.0*S/n,now_pjz=0.0;
	for (int i=1;i<=n;i++){
		if(a[i]*(n-i+1)<S){//比较穷的那一半，他们钱不够用于平分支付  
			ans+=(a[i]-pjz)*(a[i]-pjz);
			S-=a[i];//还差多少money
		} 
		else{
			now_pjz=1.0*S/(n-i+1);//当前位置应该平分的钱 
			ans+=(now_pjz-pjz)*(now_pjz-pjz)*(n-i+1);
			break;
		}
	}
	cout<<setprecision(4)<<fixed<<sqrt(ans/n);
	//printf("%.4f",sqrt(sum/n));
	//上行为另一种输出四位小数的方法； 
}
```

### 温馨提示
```cpp
now_pjz=1.0*S/(n-i+1);
```
此处一定是 $1.0 \times S \frac{S}{(n-i+1)}$ 因为要把他自己也算上。

```cpp
ans+=(now_pjz-pjz)*(now_pjz-pjz)*(n-i+1);
```
这里的 $(n-i+1)$ 这里加上一的理由同上，也要算自己。


---

## 作者：封禁用户 (赞：1)

# 分析
不能让有人付不起，我们先把 
$si$
从递增排序，然后遍历贪心。设有一个数
$sum$
，代表还要付 $sum$ 元，那么这个人付的钱就要尽量接近平均值即可。

# 代码
我保证此代码的正确性，但请勿抄袭。此代码仅供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
int n, a[N];
long double sum = 0, s;
int main()
{
	//输入
	cin >> n >> s;
	for(int i=1; i<=n; i++) cin >> a[i];
	
	//排序
	long double dow = s*1.0/n;
	sort(a+1, a+n+1);
	
	//遍历
	for(int i=1; i<=n; i++)
	{
		double output = s*1.0/(n-i+1);
		if(a[i]<output) output=a[i];
		sum += (output-dow) * (output-dow);
		s -= output;
	}
	
	//输出
	cout << fixed << setprecision(4) << sqrt(sum*1.0/n);
	return 0;
}
```

---

## 作者：QWQ_SenLin (赞：1)

因为要让标准差最小，即使 $\sqrt{\dfrac{\sum_{i=1}^n(x_i-\bar{x})}{n}}$ 最小，因此只需要求出 $\sum_{i=1}^n(x_i-\bar{x})$ 的最小值，就可以求出最小的标准差。

回到题目，因为总付钱量为 $S$，所以 $\sum x_i=S,\bar{x}=\dfrac{S}{n}$。

这样平均数已知，题目就变成构造一个 $b$，满足 $b_i \le a_i$ 且 $\sum x_i=S$，求最小 $\sum_{i=1}^n(x_i-\bar{x})$。

显然可以贪心，先对 $a$ 排序，每次选择的 $b_i$ 在小于 $a_i$ 的情况下，尽量靠近未选择的数的平均数，然后答案增加 $(b_i-\dfrac{S}{n})^2$。循环更新答案即可。

代码挺简单的，注意要开 `long double`。

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

int n; long double S , ans , now;
int a[500005];

int main(void){
    scanf("%d%Lf" , &n , &now); //long double 输入输出用Lf
    for(int i = 1;i <= n;i++)
        scanf("%d" , &a[i]);
    S = now / n;
    sort(a + 1 , a + 1 + n);
    for(int i = 1;i <= n;i++){
        long double t = now / (n - i + 1);
        if(a[i] < t){
            ans += (a[i] - S) * (a[i] - S); //更新答案
            now -= a[i];
        } 
        else{
            ans += (t - S) * (t - S);
            now -= t;
        }
    }
    printf("%.4Lf\n" , sqrtl(ans / n));
}
```

---

## 作者：DreamLand_zcb (赞：1)

## 简要题意

有 $n$ 个人，每人带了 $a_i$ 元，一共要付 $S$ 元，求最终每人付的钱的标准差最少的是多少。

## 思路

将 $a$ 按从小到大排序。

如果要降标准差，那么每个人付的钱与平均值越近越好，定义平均值 $ave = \frac{S}{n}$。

每次考虑第 $i$ 人的时候先计算当前剩下的所要支付的钱的平均值 $t = \frac{S}{n-i+1}$，如果他付不起就把自己能付的钱全付出去，降低与平均值之间的差距，最后 $S$ 自减 $t$ 表示剩下 $S-t$ 元需要支付。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define setp setprecision
#define mem(a, m) memset(a, m, sizeof(a));
using namespace std;

int n;
long double s;
int a[500005];
long double ave, ans = 0;
int main()
{
	ios::sync_with_stdio(false);
	cin >> n >> s;
	for(int i=1;i<=n;i++)	cin >> a[i];
	ave = s * 1.0 / n;
	sort(a+1, a+n+1);
	for(int i=1;i<=n;i++)
	{
		double t = s * 1.0 / (n - i + 1);
		if(t > a[i])	t = a[i];
//		cout << i << " : " << t << endl;
		ans += (t - ave) * (t - ave);
		s -= t;
	}
	cout << fixed << setp(4) << sqrt(ans * 1.0 / n);
	return 0;
}

```


---

## 作者：WoodReal12 (赞：0)

## 思路分析

由题意可知，若设 $m$ 为当前还需要支付的钱数，第 $i$ 个人实际支付了 $A_i$ 元，标准差就是 $\large\sqrt\frac{\sum_{i=1}^n (A_i-\frac{s}{n})^2}{n} $。

所以想要使标准差最小，就可以转换为 $\min_{i=1}^{n}(|A_i-\frac{l}{n-i+1}|)$ 。

化简得，$A_i=\min(a_i,\frac{l}{n-i+1})$。

于是，将这个化简后的式子带入标准差公式即可。

## 代码

```cpp
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cmath> 
#define int long long
using namespace std;
int n,a[500005];
long double s,ans=0;
signed main() {
	cin>>n>>s;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	long double tmp=s;
	for(int i=1;i<=n;i++){
		ans+=pow(min((long double)tmp/(n-i+1),(long double)a[i])-(long double)s/n,2) ;
		tmp-=min((long double)tmp/(n-i+1),(long double)a[i]);
	}
	cout<<fixed<<setprecision(4)<<sqrt((long double)ans/n)<<endl;;
	return 0;
}
```

---

## 作者：jixiyue114514 (赞：0)

## 思路分析
贪心+模拟，为了使标准差最小，每一个人出的钱 $b_{i}$ 必须接近平均值。 

那就分两种情况：
1. 第 $i$ 人带的钱不够平均数 $avg$，那么他只能出他带的全部钱。
1. 第 $i$ 人带的钱比平均数 $avg$ 多，那么他可以多付一些。

所以基本步骤为：
1. 对 $a_{i}$ 从小到大排序。
1. 前一部分人的钱不够，那么就出他们所有的钱。
1. 从总付钱数中扣除前一部分人出的钱，得剩余需要出的钱数为 $S'$，以及剩余的后一部分人的出钱平均数 $avg'$。
1. 后一部分人的钱多，他们多出一些。怎么出？这部分人也分两类：

      1.比较有钱的，但是他的钱也不够 $avg'$，那么他的钱还是要全出。

   2.非常有钱的，不管怎么付他都有富余。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
 
long long a[500010];
 
int main() {
	int n;
	long long s;
	cin >> n >> s;
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
    //开始贪心选择
	sort(a, a + n); //排序，从小到大
	double avg = 1.0 * s / n;
	double sum = 0.0;
	for (int i = 0; i < n; i++) {
		if (a[i] * (n - i) < s) { //把钱全拿出的人
			sum += (a[i] - avg) * (a[i] - avg);
			s -= a[i]; //更新还差多少钱
		} else { //不需要把钱全拿出的人。剩下的人中，钱最少的人都可以达到cur_avg
			double cur_avg = 1.0 * s / (n - i); //注意这里的s是还差多少钱
			sum += (cur_avg - avg) * (cur_avg - avg) * (n - i); //如果这个人有钱付，那么后面的人一定也能付，所以直接乘后面的人数(n - i)即可
			break;
		}
	}
	printf("%.4f", sqrt(sum / n));
 
	return 0;
}
```

---

## 作者：ggc123 (赞：0)

### 分析

设当前剩余要支付的钱数为 $l$ 元，第 $i$ 个人实际支付的钱是 $x_i$ 元，标准差就是 ${\large\sqrt{\frac{\sum_{i=1}^{n}(x_i-\frac{S}{n})^{2}}{n}}}$。

要让标准差最小，所以 ${\large\left|x_i-\frac{l}{n-i+1}\right|}$ 就应当最小。

所以 ${\large x_i=\min\left(a_i,\frac{l}{n-i+1}\right)}$，之后就可以带入 ${\large\sqrt{\frac{\sum_{i=1}^{n}(x_i-\frac{S}{n})^{2}}{n}}}$ 求得答案。
#### 注意
1. 要将 $a$ 从小到大排序，防止后面的人付不起；
2. 一定开`long double`。

### 代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, a[500005];
long double s, sum = 0;
signed main() {
	cin.tie(0), cout.tie(0);
	cin >> n >> s;
	for (int i = 1; i <= n; i++)	cin >> a[i];
	long double ave = (long double)s / n, l = s;
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; i++) {
		long double x = min((long double)l / (n - i + 1), (long double)a[i]);
		sum += pow(x - ave, 2) ;
		l -= x;
	}
	cout << fixed << setprecision(4) << sqrt((long double)sum / n);
	return 0;
}
```

---

## 作者：yzm0325 (赞：0)

很明显每个人要付的钱数要尽量往平均值靠。设现在付钱付到了第 $i$ 个人，还要付 $S'$ 元，则这个人负的钱数要往平均值 $\frac{S'}{n-i+1}$ 靠拢。所以得到贪心策略：如果第 $i$ 个人的钱数多于 $\frac{S'}{n-i+1}$，则付 $\frac{S'}{n-i+1}$ 元钱，否则付自己所有的钱（即 $a_i$）。

这样做没有考虑一开始的人带的钱非常多导致有些人出不起的情况，所以先将 $a$ 数组排序。

计算完每个人付的钱（$b$ 数组）后，按照题目公式计算标准差即可。

注意开 `long double`。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[500010];
long double s, sy, b[500010], ans, pj;
int main() {
    cin >> n >> s;
    sy = s;
    for(int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1);
    for(int i = 1; i <= n; i++) {
        if(a[i] <= sy / (n - i + 1)) b[i] = a[i], sy -= a[i];
        else b[i] = sy / (n - i + 1), sy -= sy / (n - i + 1);
    }
    pj = 1.0 * s / n;
//   cout << pj << '\n';
//   for(int i = 1; i <= n; i++) cout << b[i] << ' ';
//   cout << '\n';
    for(int i = 1; i <= n; i++) ans += (b[i] - pj) * (b[i] - pj);
    ans = sqrt(ans / n);
    cout << fixed << setprecision(4) << ans;
    return 0;
}
```

---

## 作者：Stars_visitor_tyw (赞：0)

## P8664 [蓝桥杯 2018 省 A] 付账问题 题解
### 分析
将标准差公式简化为 $\sqrt{\frac{\sum_{i=1}^n(b_i-\overline{b})^2}{n}}$。$\sum_{i=1}^nb_i$ 显然为总付款金额 $S$，$\overline{b}$ 则为 $\frac{S}{n}$。

将 $a_i$ 排序，从带钱数最少的人开始算起。

设目前还要付 $x$ 元，要使标准差最小，若此时第 $i$ 个人及他以后的人都没付，则他们每人付的钱数应往 $\frac{x}{n-i+1}$ 元，则答案在 $a_i$ 和靠近，而由于第 $i$ 个人可能付不起 $\frac{x}{n-i+1}$ 元，则答案在 $a_i$ 和 $\frac{x}{n-i+1}$ 间取最小值并计算标准差。

注意，要开 `long double`。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+5;
int n;
long double a[N], s, cur, ans;
signed main()
{
    cin>>n>>s;
    long double avg=s/n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++)
    {
        cur=min(a[i],s/(n-i+1));
        s-=cur;
        ans+=(cur-avg)*(cur-avg);
    }
    ans=sqrt(ans/n);
    cout<<fixed<<setprecision(4)<<ans;
}
```

---

## 作者：FBW2010 (赞：0)

# 思路

由题目所给公式可得，我们需要让每个人出的钱与所有人出钱的平均数之差的尽可能地小，所以优先考虑贪心。

当考虑到第 $i$ 个人时，设之前一共出了 $S_0$ 元，如果他的钱大于平均数，那他就得出 $\frac{S-S_0}{n-i+1}$ 元；如果比平均数小，那么就得出他全部的钱。为了避免有些人出不起的情况，所以要先按钱数排一个序。

# 代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int n,a[500005]; 
long double s,t,ans; //long double 防止精度丢失 
int main(){
	scanf("%d %Lf",&n,&s);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	t=s*1.0l/n; //算出平均数 
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		long double x=s*1.0l/(n-i+1); //剩下的平均数 
		if(a[i]<x){
			ans+=(a[i]-t)*(a[i]-t); //将与平均数的茶累加  
			s-=a[i]; //将所花的钱减去 
		}
		else{
			ans+=(x-t)*(x-t); //同上 
			s-=x;
		}
	}
	printf("%.4Lf",sqrt(ans/n)); //根据公式算出答案输出 
	return 0;
}
```

---

## 作者：JAMES__KING (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P8664)

通过阅读本题题面与数据范围，我们可以知道本题的核心算法：贪心。

### 具体实现

我们可以跑一遍循环来枚举第 $i$ 个人，我们可以设这个人之前所有人总共付了 $x$ 元。由于我们需要让所有人付的钱越平均越好，所以第 $i$ 个人付的钱一定越接近 $\frac {s - x} {n - i + 1}$ 越好。此时，明显有两种情况：

- $a_i \ge \frac {s - x} {n - i + 1}$，那么我们可以令 $i$ 出  $\frac {s - x} {n - i + 1}$ 元。

- 反之，我们令 $i$ 出 $a_i$ 元。

### 注意事项

1. 要先从小到大排个序，因为如果先考虑钱多的人，后面的人可能付不起。

1. 要用 ```long double```。

### CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005];
long double ans,sum,m,x;
signed main()
{
   cin>>n>>m;
   for(int i=1;i<=n;i++) cin>>a[i];
   sort(a+1,a+1+n);//排序
   sum=m/n;
   for(int i=1;i<=n;i++)
   {
      x=m/(n-i+1);
      if(a[i]<x)//判断
      {
         ans+=(a[i]-sum)*(a[i]-sum);
         m-=a[i];//第二种情况
      }
      else
      {
         ans+=(x-sum)*(x-sum);
         m-=x;//第一种情况
      }
   }
   printf("%.4Lf",sqrt(ans/n));//输出
   return 0;
}
```

### [记录传送门](https://www.luogu.com.cn/record/122581442)

---

## 作者：qiuzijin2026 (赞：0)

# P8664 [蓝桥杯 2018 省 A] 付账问题

## [题面](https://www.luogu.com.cn/problem/P8664)

## 思路

本题使用贪心。

对于第 $i$ 个人来说，设 $S'$ 为前 $i-1$ 个人付的钱的总和。

则他付的钱一定越接近 $(s-s')\div(n-i+1)$ 越好。

- 如果 $a(i)\ge(s-s')\div(n-i+1)$，那么 $i$ 出 $(s-s')\div(n-i+1)$ 元。

- 如果 $a(i)<(s-s')\div(n-i+1)$，那么 $i$ 出 $a(i)$ 元。

因为如果先考虑钱多的人，那么后面的人可能就付不起了，所以要按从小到大排个序。

注意本题数据范围 $ 0\le a(i)\le 10^{9}$，所以要开 ``long double``。

如果使用 ``scanf`` 和 ``printf``，要用 ``%Lf``。 

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
long double s;
long double a[500005];
long double b[500005];
long double sum;
long double ans;
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d%Lf",&n,&s);
	sum=s;
	for(int i=1;i<=n;i++) scanf("%Lf",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		long double tmp=min(a[i],sum*1.0/(n-i+1));
		ans+=(tmp-s*1.0/n)*(tmp-s*1.0/n);
		sum-=tmp; 
	}
	printf("%.4Lf",sqrt(ans*1.0/n));
	return 0;
}

```

---

## 作者：封禁用户 (赞：0)

为了防止有人付不起，我们先把 $s_i$ 从小到大排序，然后遍历一遍贪心。

假设有一个数 $sum$，代表还要付 $sum$ 元，那么这个人付的钱就要尽量接近平均值 $\dfrac{sum}{n-i+1}$。也就是 $s_i$ 或 $\dfrac{sum}{n-i+1}$。然后我们就做完了。

---


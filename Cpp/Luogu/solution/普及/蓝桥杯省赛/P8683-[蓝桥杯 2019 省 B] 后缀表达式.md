# [蓝桥杯 2019 省 B] 后缀表达式

## 题目描述

给定 $N$ 个加号、 $M$ 个减号以及 $N+M+1$ 个整数 $A_1,A_2,\cdots,A_{N+M+1}$，小明想知道在所有由这 $N$ 个加号、 $M$ 个减号以及 $N+M+1$ 个整数凑出的合法的后缀表达式中，结果最大的是哪一个。

请你输出这个最大的结果。

例如使用 `1 2 3 + -`，则 `2 3 + 1 -` 这个后缀表达式结果是 $4$，是最大的。

## 说明/提示

对于所有评测用例，$0 \le N,M \le 10^5$，$-10^9 \le A_i \le 10^9$。

蓝桥杯 2019 年省赛 B 组 I 题。

## 样例 #1

### 输入

```
1 1
1 2 3```

### 输出

```
4```

# 题解

## 作者：wangyishan (赞：27)

# P8683 [蓝桥杯 2019 省 B] 后缀表达式 题解

### 题意简述

[link](https://www.luogu.com.cn/problem/P8683)

- 给定 $N$ 个加号、 $M$ 个减号以及 $N+M+1$（下文记为 $K$ )个整数 $A_1,A_2,\cdots,A_{N+M+1}$
- 求由这 $N$ 个加号、 $M$ 个减号以及 $K$ 个整数凑出的合法的后缀表达式中，结果最大的是哪一个。

- 例如输入 `1 2 1 2 3`，则 `2 3 + 1 -` 这个后缀表达式结果是 $4$，是最大的。

（在这里我们将这 $K$ 个整数记为 1-idx 的集合 $a$ )

### 题目分析

先上 30pts 代码：

```cpp
ll ans=0;
sort(a+1,a+n+m+1+1);
for(int i=1;i<=m;i++)ans-=a[i];
for(int i=m+1;i<=n+m+1;i++)ans+=a[i];
cout<<ans;
```

这是一个明显的贪心思路：先排序，加上 $n+1$ 个大数，再减去 $m$ 个小数。

但是这个贪心能够明显的举出反例：
```plain
0 4
1 2 3 4 5
```

答案是 $13$, 他会输出 $-5$。因为这是一个**后缀表达式**，转换到中缀表达式时可能会带着**括号**！

现在我们的首要目标就是把括号的影响忽略掉。观察上面的例子可以发现，答案 $13=5-((1-2)-3)-4)=5+4+3+2-1$。让我们在举几个例子看看：

- 输入为 `0 2 1 2 3`,输出为 $5=3-(1-2)=3+2-1$;
- 输入为 `1 2 4 3 2 1`,输出为 $8=4+3-(1-2)=4+3+2-1$;
- 输入为 `1 2 4 3 -2 -1`,输出为 $10=4+3-(-2)-(-1)=4+3+1-(-2)$;

可以看出，
- 在 $M=0$ 时答案为 $\sum_{i=1}^K a_i$，
- 而在 $M>0$ 时答案为 $\sum_{i=2}^K \lvert {a_i} \rvert-a_1$（此时 $a$ 数组已经按从小到大排序）

证明：

首先在 $M=0$ 时答案一定为所有数的和。

在 $M>0$ 时，想让答案最大，那么肯定要多加上大数，减去小数。先把最大的拿出来，放到首项（$K-1$ 个符号，$K$ 个数，那么首项一定是正的），把最小的拿出来，放到末项。此时就构成了一个这样的表达式：$a_n\pm...-(a_1\pm...)$。

这时其他的数就即可以放到括号外面，又可以放到括号里面。如果是正数括号里就添`-`,括号外就添`+`,负数相反。就这样，我们把所有任意个加号和减号都转变为了**绝对值**！虽然“牺牲”了最小的值，但是仍然换来了最大的收益。

### 代码

```cpp
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
ll a[1000010];int n,m;
ll ans=0;
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n+m+1;i++)
		cin>>a[i];
	sort(a+1,a+n+m+1+1);
	if(m==0)
		for(int i=1;i<=n+m+1;i++)
            ans+=a[i];
	else{
		ans=a[n+m+1]-a[1];
		for(int i=2;i<=n+m;i++)
            ans+=abs(a[i]);//abs是c++的库函数 取绝对值
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：MTF_Lambda_04 (赞：23)

首先，看题目描述，给定 $N$ 个加号，与 $M$ 个减号，要你求后缀表达式最大值，实际上就是求这些符号和数字排列起来的最大值。

这题很容易让人想到贪心。但是呢，又怎么个贪心法呢？很容易看出来，我们可以先用 sort 进行这么一个排序，之后，我们对于前 $N$ 大的数加起来，对于剩下的数就减去，于是代码大体就出来了。

你以为完了？不！错掉 $7$ 个测试点告诉我们一定要看数据范围，在转换后缀表达式为中缀表达式时，有可能有括号！所以，按上面我们讲的那样去做就会出错。

怎么办呢？我们可以使用 abs 函数消除括号影响。

至于后缀表达式可以参考这篇文章：https://blog.csdn.net/kexuanxiu1163/article/details/90629494


这里解释下为什么用这个函数：首先，请先看完上面推的那篇文章。

之后，我们可以知道的是，在转换后缀为中缀表达式时有一个很烦问题就是有可能有括号，这意味着什么？这意味着加减乘除先后顺序可能改变，同时，题目中给定范围有可能为负数，所以，有可能原本正确的是减去 $1$ 加上 $2$ 去得出值，按那个做法就可能变为了减去 $1$ 再减 $2$ 这显然是错误的，所以就需要使用 abs 那个函数消除此类影响。

还是那个例子，你想，我现在减去了 $1$ 之后呢又因为 $2$ 在括号里 $2$ 带了个负号，那这求出正确值不就直接去掉负号也就是直接求绝对值就完了吗？

所以，这就是为什么要用这个函数对这些数做这么一个处理的原因。



最后，代码：

```
#include<bits/stdc++.h>
using namespace std;
long long int n,m,l;
const int N=2*1e6;
long long int a[N];
long long int s=0;
int cmp(int x,int y){
	return x>y;
}
int main(){
	scanf("%lld%lld",&n,&m);
	l=n+m+1;
	for(int i=1;i<=l;i++){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+l+1,cmp);
	if(m==0){
		for(int i=1;i<=l;i++){
			s+=a[i];
		}
	}else{
	    s=s+a[1];
		s=s-a[l];
		for(int i=2;i<=l-1;i++){
			s=s+abs(a[i]);
		}
	}
	
	printf("%lld",s);
	
	return 0;
}
```

抄是会被棕名的！

---

## 作者：哈哈人生 (赞：11)

## [题目传送门](https://www.luogu.com.cn/problem/P8683)

## 前置知识
后缀表达式如果不明白，可以参考[这篇博客](https://blog.csdn.net/a8425/article/details/119253258)。在这里，我们做简短介绍：

后缀表达式，又称逆波兰式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行(不再考虑运算符的优先规则)。例如：

四则表达式（我们生活中的算术式）：$4+6\times 7-10$  
后缀表达式：$4$ $6$ $7$ $\times$ $+$ $10$ $-$

## 思路
首先肯定考虑贪心，把所有数排序，把大数加上，小数减去，非常简单！代码如下（我这个是用优先队列的大根堆，也能达到效果，分析也在代码中）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s;
priority_queue<int,vector<int>,less<int> >pq;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n+m+1;i++)cin>>s,pq.push(s);//加入堆
	long long ans=0;
	n++;//加比减多一个
	while(n--){
		//cout<<pq.top()<<endl;调试
		ans+=pq.top();//加
		pq.pop();
	}
	while(m--){
		//cout<<pq.top()<<endl;调试
		ans-=pq.top();//减
		pq.pop();
	}
	cout<<ans;//output
	return 0;
}
```
自行满满的交上去，一看结果，[ $30$ 分](https://www.luogu.com.cn/record/115060508)，哭~

我们来想一下原因：后缀表达式顺序如同栈，先进先出，所以先算出的也有可能参与后面的算式，这在四则表达式中类同括号的作用。所以，***最后的结果受括号影响，受减号和加号的顺序影响***，举个例子就能看出：

输入：
```cpp
0 4
1 2 3 4 5
```
而我们的输出就应该是 $13$ 而不是 $5$，我们还可以发现在后缀表达式中真正会被减的数的个数可以被我们降到一（当减号都在一起时），所以我们只要牺牲一个最小的值，把其他数加起来就好啦。
详细的实现可以参考代码：

## 代码 
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s,maxx=-1,minn=1<<30;
long long ans=0;
int main() {
	cin>>n>>m;//input
	if(m==0) {//m==0，无最小值可牺牲的特判
		for(int i=1; i<=n+m+1; i++)cin>>s,ans+=s;//全加
		cout<<ans;
		return 0;
	}
	for(int i=1; i<=n+m+1; i++) {
		cin>>s;
		ans+=abs(s);
		maxx=max(maxx,s);
		minn=min(minn,s);//求最小值
	}
	cout<<(maxx-minn)+ans-abs(maxx)-abs(minn);//print，牺牲最小值
	return 0;
}
```
时间复杂度也十分优秀，连 sort 都不用了。

#### 请读者诚信粘题解，遵守洛谷规则，另外，点个赞呗~

---

## 作者：wuhan1234 (赞：4)

## 1. 编程思路。

题目给出了后缀表达式中加号的个数为 $n$，减号的个数为 $m$。在输入数据 $a_i$ 时进行预处理，统计出所有正数的个数（设为 $p$）、正数的和（设为 $psum$）和最小的正数（设为 $pmin$），同时也统计出所有负数的个数（设为 $q$）、所有负数的和（设为 $nsum$）和最大的负数（设为 $nmax$）。

要使后缀表达式的值最大，分以下四种情况讨论。

1）$m=0$，没有减号，只能将全部数加起来，因此表达式的值为 $psum+nsum$。

2）有减号，但全部的数均为正数，即 $m\ne 0 \  and \   p=n+m+1$。此时可以这样利用减号。

如果只有 $1$ 个减号（$m=1$），很简单，减去最小的正数即可，答案为 $psum-2\times pmin$。

如果有多个减号，我们可以让最小的正数连续减去 $m-1$ 个正数，最后用一个减号来减去这个差。形式化的表示如下：

$a_1+a_2+...+a_{n+1}-(pmin-a_{n+2}-a_{n+3}-...-a_{n+m})$

$=a_1+a_2+...+a_{n+1}+a_{n+2}+a_{n+3}+...+a_{n+m}-pmin$

$=psum-2\times pmin$

3）有减号，但全部的数均为负数，即 $m\ne 0 \  and \   q=n+m+1$。此时可以这样利用减号。

如果只有 $1$ 个减号，同样简单，用最大的负数（绝对值最小）减去其他所有负数的和，这样相当其他所有负数和的绝对值减去一个绝对值最小的负数，表达式的值肯定最大，为 $-nsum+2\times nmax$。

如果有多个减号，我们可以让最大的负数连续减去 $m-1$ 个负数，最后用一个减号来减去其他 $n+1$ 个负数的和。形式化的表示如下：

$nmax-a_1-a_2-...-a_{m-1}-(a_{m}+a_{m+1}+...+a_{n+m})$

$=nmax-(a_1+a_2+...+a_{m-1}+a_{m}+a_{m+1}+...+a_{n+m})$

$=-nsum+2\times nmax$

4）有减号，并且也有正数，也有负数。此时处理起来简单。用减号减去负数即可。

如果负数个数比减号多，可以采用 $ -(a_i+a_j)$ 的形式处理，其中 $a_i$ 与 $a_j$ 均为负数；

如果负数的个数比减号少，可以采用 $ -(a_i-a_j)$ 的形式处理，其中 $a_i$ 是负数，$a_j$ 是正数。

总之，最后结果一定是所有正数和负数的绝对值相加，后缀表达式的值也最大，为 $psum-nsum$。

## 2. 源程序。

```c
#include <stdio.h>
int main()
{
	int n,m,p=0,q=0;
	scanf("%d%d",&n,&m);
	long long psum=0,nsum=0;
	long long pmin=2000000000,nmax=-2000000000;
	int i;
	for (i=0;i<n+m+1;i++)
	{
		long long num;
		scanf("%lld",&num);
		if (num>0ll)
        {
            p++;
            psum+=num;
            if (pmin>num) pmin=num;
        }
		else
        {
            q++;  nsum+=num;
            if (nmax<num) nmax=num;
        }
	}
	if (m==0)       // 负号个数为0
		printf("%lld\n",psum+nsum);
	else
	{
	    if (p==n+m+1)         // 全部为正数
	        printf("%lld\n",psum-2*pmin);
        else if (q==n+m+1)   // 全部为负数
            printf("%lld\n",-nsum+2*nmax);
        else
            printf("%lld\n",psum-nsum);
	}
	return 0;
}

```



---

## 作者：liangbob (赞：2)

### P8683 题解

#### 思路分析

由 $N$ 个加号、 $M$ 个减号以及 $N+M+1$ 个整数凑出的合法后缀表达式。

贪心题。

看到“由 $N$ 个加号、 $M$ 个减号以及 $N+M+1$ 个整数凑出”这一条件时，我们可以知道，题目要求我们用加减组成结果最大的式子。

看到“后缀表达式”这一条件，我们可以知道，凑出的式子还可以加括号，例如 `1 2 + 3 4 - +` 等于 `(1+2)+(3-4)`。

显然，结果可以表示为 $A-B$（$A$，$B$ 为整数），如果我们要让结果最大，那么我们就得使得 $B$ 最小，于是可以取最小的数为 $B$ 即可。

（注：为什么不用管最小的数的正负？如果最小数为负，那么很好，不减反加。如果是正的，那么刚好符合我们的要求。如果是零，啥事没有。）

接下来，我们就要让 $A$ 最大。设原式为 $(A)-(B)$。

此时剩下 $N + M$ 个数。由于我们可以随意地添加括号，因此我们可以通过如下方法，使得 $A$ 为余下的所有数的绝对值之和。

- 如果数为正数，则既可以添正号，放到 $(A)$ 中，也可以添负号，放到 $(B)$ 中。
- 如果数为负数，则既可以添负号，放到 $(A)$ 中，也可以添正号，放到 $(B)$ 中。
- 如果数为零，依照正数负数操作均可

接下来，我们证明：通过 $N$ 个加号与 $M-1$ 个减号，通过上述方式，一定可以让所有数变为其绝对值。

不妨设有 $a$ 个正数与 $b$ 个零。则负数个数 $c = N+M-a-b$。

- 对负数操作，至少要 $\dfrac{N+M-a-b}{2}$ 个正号，$\dfrac{N+M-a-b}{2}$ 个负号。

- 对正数操作，至少要 $\dfrac{a}{2}$ 个正号，$\dfrac{a}{2}$ 个负号。

- 对零操作，至少要 $\dfrac{b}{2}$ 个正号，$\dfrac{b}{2}$ 个负号。

- 共 $\dfrac{N+M}{2}\pm1$ 个正号（有一个非负数可以不用正号），$\dfrac{N+M}{2}$ 个负号。

按照这种方式操作即可使得所有数变为其绝对值，而不用担心会不会加减号不够用。

于是最后直接排序操作即可。注意特判 $M = 0$ 的情况，这种情况不用找最小的数去减，直接全部相加。

#### 代码

```cpp
#include <iostream>
#include <algorithm>
#include <numeric> 
#define int long long
using namespace std;
const int N = 2e5 + 10;

int a[N];

signed main()
{
	int n, m;
	cin >> n >> m;
	for(int i = 1;i <= n + m + 1;i++)
	{
		cin >> a[i];
	}
	if(m == 0)
	{
		cout << accumulate(a + 1, a + n + m + 1 + 1, 0) << endl; //求和 
	}
	else
	{
		sort(a + 1, a + n + m + 1 + 1); //排序
		int ans = a[n + m + 1] - a[1]; //最大-最小
		for(int i = 2;i <= n + m;i++)
		{
			ans += abs(a[i]); //绝对值之和
		}
		cout << ans << endl;
	}
    return 0;
}
```



---

## 作者：StarRain3 (赞：1)

### 思路（详细！）

如果 $M$ 是 $0$ 则没有减号，全是加号，全加起来即可。如果 $M$ 大于 $0$ 我们从后缀表达式特征入手：以二叉树后序遍历顺序描绘，则很明显有下面的特征。当我们将新的数放到左子树上且新的符号为负数时，会将原有的数据全部取反。因此，对于 $M$ 个负号，我们可以构造出 $1$ 到 $M$ 个负号，而如果在负号的过程中加入了加法，那么相当于括号外是减法，括号内是加法，去括号后，加法也能变成减法，从而增加了负号的数量，因为有 $N$ 个加号，故而可以增加 $0$ 到 $N$ 个负号，所以 $N$ 个加号和 $M$ 个减号可以构成 $1$ 到 $N+M$ 个负号因为有 $N+M+1$ 个数，而可以构造的负号数范围在 $1$ 到 $N+M$，所以至少会减一个数，至少会加一个数，为了使结果最大，我们应该减去最小的数，加上最大的数，也就是将序列排序后的序列两端，减去左端，加上右端。

而序列中间的数，依据这个特征，我们的数据负号实际上可以自由更改加减，又因为题目要求求最大值，则我们只需要根据以上反转的特性，合理构造负号，利用一个负数将多个负数都尽可能转换为正值，也即将序列中负数前面的符号构造为负号，以负负得正，正数前面就是加号，最后的效果其实就是序列中间的数全部取绝对值。

从而我们就能得到最优代码。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;

long long cnt;
int main() {
	int a[N];
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n + m + 1; i++)
		cin >> a[i];
	if (m == 0) {
		for (int i = 0; i < n + m + 1; i++)
			cnt += a[i];
	} else {
		stable_sort(a, a + n + m + 1);
		cnt -= a[0];
		cnt += a[n + m];
		for (int i = 1; i < n + m; i++)
			cnt += abs(a[i]);
	}
	cout << cnt << endl;
	return 0;
}
```

---

## 作者：Frozen_Ladybug (赞：0)

题目大意：给定 $N$ 个加号，$M$ 个减号和 $N+M+1$ 个整数 $A_1$ 至 $A_{N+M+1}$，如何用合法的后缀表达式得出结果最大的数。

用 $len=n+m+1$ 表示数的总数，$n$ 个加号和 $m$ 个减号，$ans$ 个负数。要考虑让负数尽量少。

那就可以如下讨论。

- 若 $m=0$，没有负数，结果就是数的总和。

- 若 $ans=0$，最大值是最大的 $len-1$ 个非负数之和减去最小的非负数。

- 若 $ans\neq0$ 且 $ans\neq len$，最大值是所有数的绝对值之和。

- 若 $ans=len\neq0$，全都为负数。最大值是绝对值最大的 $len-1$ 个数的绝对值之和减去最小数的绝对值。

代码如下。

```c
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,m,a[200005],sum,ans,len;
int main(){
    scanf("%lld%lld",&n,&m);
    len=n+m+1;//数的个数为n+m+1
    for(ll i=1;i<=len;i++){
        scanf("%lld",&a[i]);
        sum+=a[i];//总和加上当前值
        if(a[i]<0) ans++;//负数的个数+1
    }
    if(!m){printf("%lld\n",sum);return 0;}//没有符号,直接输出sum
    sort(a+1,a+len+1);//排序,这样负数就被放在前面了
    if(!ans) sum-=2*a[1];//如果有没有负数,那a[1]一定为负
    else
        if(ans==len) for(ll i=1;i<ans;i++) sum-=2*a[i];//全都有符号
        else for(ll i=1;i<=ans;i++) sum-=2*a[i];//否则依次减去两倍最小的ans个数
    printf("%lld\n",sum);
    return 0;
}
```

---

## 作者：wangjue1629 (赞：0)

# Solution
[题目传送门](https://www.luogu.com.cn/problem/P8683)

## 题目思路

这道题的核心是构造一个后缀表达式，使得这个后缀表达式的结果大。后缀表达式的计算方法：操作符会对它之前的两个数字进行操作。所以，为了结果最大，我们需要保证所有的加号应该加在较大的数字上，减号减在较小的数字上。

## 解题步骤

1. 先将所有的整数排序。
2. 如果没有减号，（$m = 0$），那么代表所有数字都是正的，只要把它们加起来就可以了。
3. 如果有减号，我们将最小的数用减号将它减去，将其他的数加上。（将最小的数放在最开始，用一个减号将它减去，然后将余下的数依次加上。最后一个数应该是最大的数，因为我们不会对它做任何操作。）

***

## AC Code

```cpp
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
const int maxnm = 1e5 * 2 + 10;
int a[maxnm];
int main(){
    int n, m; cin >> n >> m;
    for(int i = 1; i <= n + m + 1; i++) cin >> a[i];
    sort(a + 1, a + n + m + 2); //a + n + m + 2是因为下标问题，如果是a + n + m + 1只会排到 a[n + m]，而不是 a[n + m + 1]
    ll ans = (m == 0) ? 0 : a[n + m + 1] - a[1]; //因为 a[i] 的最大值高达 1e9，所以需要开long long
    if(m == 0){
        //如果是没有减号的情况下，直接累加所有数字
        for(int i = 1; i <= n + m + 1; i++) ans += a[i];
    } else{
        //如果是有减号的情况，先将最小的数（a[1]）减去，然后把其他数加起来
        for(int i = 2; i <= n + m; i++) ans += abs(a[i]); //因为题目中有负数，所以需要取绝对值（abs(a[i])
    }
    cout << ans << "\n";
    return 0;
}
```
时间复杂度：$O(n + m)$，空间复杂度：$O(n + m)$。可以通过本题。

---


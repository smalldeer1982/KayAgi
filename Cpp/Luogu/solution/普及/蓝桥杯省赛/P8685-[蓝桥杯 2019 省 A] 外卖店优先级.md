# [蓝桥杯 2019 省 A] 外卖店优先级

## 题目描述

“饱了么”外卖系统中维护着 $N$ 家外卖店，编号 $1$ ~ $N$。每家外卖店都有一个优先级，初始时（$0$ 时刻）优先级都为 $0$。

每经过 $1$ 个时间单位，如果外卖店没有订单，则优先级会减少 $1$，最低减到 $0$；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 $2$。

如果某家外卖店某时刻优先级大于 $5$，则会被系统加入优先缓存中；如果优先级小于等于 $3$，则会被清除出优先缓存。

给定 $T$ 时刻以内的 $M$ 条订单信息，请你计算 $T$ 时刻时有多少外卖店在优先缓存中。

## 说明/提示

**样例解释**

$6$ 时刻时，$1$ 号店优先级降到 $3$，被移除出优先缓存；$2$ 号店优先级升到 $6$，加入优先缓存。所以有 $1$ 家店（$2$ 号店）在优先缓存中。

**评测用例规模与约定**

对于 $80\%$ 的评测用例，$1 \le N,M,T \le 10000$。

对于所有评测用例，$1 \le N,M,T \le 10^5$，$1 \le ts \le T$，$1 \le id \le N$。

蓝桥杯 2019 年省赛 A 组 G 题。

## 样例 #1

### 输入

```
2 6 6
1 1
5 2
3 1
6 2
2 1
6 2```

### 输出

```
1```

# 题解

## 作者：wjx38223 (赞：17)

## 思路分析
首先，对于每一家店，我们考虑到需要从时间 $1$ 开始，一直遍历到时间 $T$，如果有记录，那么 _优先级_ **加上** $2$，否则，优先级 **减去** $1$，对于每一个节点，判断这家店 _是否在优先推荐中_ 

- **优化1：** 那么此时，由于我们把有记录和没有记录的时间点都遍历了一遍，自然浪费时间，所以，我们可以只 **查找这家店有记录的时间点，没有用的点，我们用减法就能求出**

- **优化2：**我们需要按顺序找到每一个有记录的节点，这就需要**排序**，那么我们来想 _一种先进先出并且排序的东西_ ，所以， _优先队列_ 就是一个好选择，对于每一家店，我们都为其准备一个 _优先队列_ 来存储时间点

**注意一点的是：** 如果在本时刻，该店的优先级 $>5$，在优先推荐中为真；如果在本时刻，在优先推荐中为真，且该店的优先级 $≤3$，在优先推荐中为假。

## 代码展示

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	priority_queue<int,vector<int>,greater<int>> h[100010]; //为每一家店创造一个优先队列（小顶对）
	int n, m, t;
	cin >> n >> m >> t;
	for(int i = 1; i<=m; i++){
		int x, y;
		cin >> x >> y;
		h[y].push(x);//把时间点存入这家店的队列中
	}
	int cnt = 0;
	for(int i = 1; i<=n; i++){
		int pri = 0; //“优先级”
		int lastget = 0; //上一次订单的时间
		bool in = false; //是否在“优先推荐”中
		while(!h[i].empty()){
			int x = h[i].top(); //订单时间
			h[i].pop();
			if(lastget!=x) pri-=(x-lastget-1);//如果不是同一个时间点多个订单的话，减去没有订单的那些时间需要减去的“优先级”
			if(pri<0) pri = 0; //可能小于零，设置成零
			if(in&&pri<=3) in = false; //如果在推荐里，但是此时“优先级”小于等于3，踢出推荐中
			pri+=2; //拿到两点“优先级”
			lastget = x; //更新上一次时间
			if(pri>5) in = true; //如果此时“优先级”大于3，踢出推荐中
		}
      		//注意的是，这里需要先判断是否被踢出推荐，然后再加上2，
      
      		//因为加入的条件是大于5，退出的条件是小于等于3，如果此时小于等于3了，但是加上2之后不小于3了，按照程序，符合“在推荐中+没有小于等于3”，不会被踢出去，
      		//但是由于在这些空余的时间里，已经出了推荐榜，如果再进，需要大于5，此时没有达到在加入的条件，没有在推荐榜中
      
      		//这里，由于要看的是时间T，但是T有可能不是最后一次收到订单的时间，需要额外判断，方法同上
		if(lastget!=t) pri-=(t-lastget);
		if(in&&pri<=3) in = false;
		if(in){
			cnt++;
		}
	} 
	cout << cnt;
	return 0;
}
```


---

## 作者：huangzixi071018 (赞：11)

题目大意：每经过 $1$ 个时间单位，若外卖店没订单，优先级减 $1$，否则每接 $1$ 单优先级加 $2$。如果某家外卖店某时刻优先级大于 $5$，则会被系统加入优先缓存中。如果优先级小于等于 $3$，则会被清除出优先缓存。

思路：对时间排序，用数组 $c$ 记录优先级，用数组 $h$ 记录外卖店上一次接到单的时间，从而推出中间间隔多少个没接到单的时刻，再对 $c$ 进行更新，最后检查是否加入优先缓存或被清除出优先缓存，用 $v$ 数组记录，如果 $v$ 为真，那么答案加 $1$。

### 注意：在减去外卖店没接单的时刻的优先级后，一定要检查是否被移出优先缓存。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int t,x;
}a[100005];
bool cmp(node x,node y){
	return x.t<y.t;
}
int c[100005],h[100005];
bool v[100005];
void check(int x){
	if(c[x]>5){
		v[x]=1;
	}
	if(c[x]<=3){
		v[x]=0;
	}
}
int main(){
	int n,m,t,s=0;
	cin>>n>>m>>t;
	for(int i=1;i<=m;i++){
		cin>>a[i].t>>a[i].x;
	}
	sort(a+1,a+1+m,cmp);
	for(int i=1;i<=m;i++){
		if(h[a[i].x]+1>=a[i].t){
			c[a[i].x]+=2;
		}else{
			c[a[i].x]-=(a[i].t-h[a[i].x]-1);
			c[a[i].x]=max(0,c[a[i].x]);
			check(a[i].x);
			c[a[i].x]+=2;	
		}
		h[a[i].x]=a[i].t;
		check(a[i].x);
	}
	for(int i=1;i<=n;i++){
		if(h[i]<t){
			c[i]-=(t-h[i]);
			c[i]=max(c[i],0);
		}
		check(i);
		if(v[i]){
			s++;
		}
	}
	cout<<s<<"\n";
    return 0;
}
```

---

## 作者：SakurajiamaMai (赞：6)

## 思路:
**很好理解的思路**，这里使用优先队列维护序列，进行模拟即可，在进行判断之前，要先判断此时是否不符合优先缓存，这里一定要先更新判断，然后再加上订单再判断一下是否在优先缓存里。当我们队列为空即到达最后一个订单时，在从 $t$ 时间判断一次即可，时间复杂度为线性。

**坑点:**

调了一个小时才发现，在更新最小值的时候，最小值不能为负数。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m,t,res,op[N],num[N],x,y;
priority_queue<int,vector<int>,greater<int>>que[N];
bool vis[N];
void check(int i,int ans)
{
    if(ans>5) vis[i]=true;
    if(ans<=3) vis[i]=false;
}
int main()
{
    cin>>n>>m>>t;
    for(int i=1;i<=m;i++) cin>>x>>y,que[y].push(x);
    for(int i=1;i<=n;i++){
        if(que[i].empty()) continue;
        int ans=0,last_time=0;
        while(!que[i].empty()){
            int now=que[i].top(); que[i].pop();
            if(last_time==now||last_time==0) last_time=now;
            else ans+=(last_time-now+1),last_time=now,ans=max(ans,0);//这里一定要取0,ans不能为负数
            check(i,ans),ans+=2,check(i,ans);
            if(que[i].empty()) ans+=(now-t),check(i,ans);
        }
    }
    for(int i=1;i<=n;i++) if(vis[i]) res++;
    cout<<res;
    return 0;
}
```


---

## 作者：Nightsky_Stars (赞：6)

题目大意：每经过 $1$ 个时间单位，若外卖店没订单，优先级减 $1$，**最低减到 $0$**。否则每接 $1$ 单优先级加 $2$。如果某家外卖店某时刻优先级大于 $5$，则会被系统加入优先缓存中。如果优先级小于等于 $3$，则会被清除出优先缓存。要求计算 $T$ 时刻时有多少外卖店在优先缓存中。

这道题其实不算太难（但不知道考试的时候我怎么想不到），只需要用优先队列维护，再模拟就行了。但是要注意的是优先级最低为 $0$，不能为负数。其他的不多说了，具体解释看代码。

```
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int>> q[100010];//优先队列
bool vis[100010];//看该外卖店此时是否在优先缓存中
void check(int x,int f){//判断该外卖店此时是否可以被加进优先缓存
	if(f>5) vis[x]=1;
	if(f<=3) vis[x]=0;
}
int main(){
	int n,m,t,k=0;
	cin>>n>>m>>t;
	for(int i=1;i<=m;i++){
		int ts,id;
		cin>>ts>>id;
		q[id].push(ts);//把时间存入这家店的队列中
	}
	for(int i=1;i<=n;i++){
		if(q[i].empty()) continue;
		int ans=0,s=0;//ans是求当前优先级，s是上一次订单的时间
		while(!q[i].empty()){
			int x=q[i].top();
			q[i].pop();
			if(s==x||s==0) s=x;
			else{
				ans-=(x-s-1);//如果不是同一个时间有多个订单的话，减去那些没有订单的时间需要减去的优先级
				s=x;//更新上一次订单的时间
				ans=max(ans,0);//坑点
			}
			check(i,ans);
			ans+=2;//获得2个优先级
			check(i,ans);
		}
		if(s!=t) ans-=(t-s);//看最后一次收到订单的时间是不是最后的时间t，如果不是，要减去多的优先级
		check(i,ans);
	}
	for(int i=1;i<=n;i++){
		if(vis[i]) k++;
	}
	cout<<k<<"\n";
	return 0;
}
```

---

## 作者：梅子酒 (赞：3)

发现两篇题解都使用的是暴力模拟，时间复杂度为 $O(N\cdot T)$ 的算法，题目数据范围 $1\le N,M,T \le 10^5$，显然这样近似 $O(N^2)$ 的算法是无法通过最大数据的，~~但是题目数据好像有点水~~。

这里给出一种时间复杂度上界在于排序的 $O(M\cdot \log_{2}{M} + N)$ 的算法。

考虑时刻 $t$ 可能存在新增加入优先缓存的商店是哪些，只有那些在时刻 $t$ 存在订单的商店，那么我们记录一下每个商店的更新时间和优先级，按时间顺序枚举订单，更新这些商店的信息，这样就能 $O(M)$ 时间内维护订单造成的影响，最后再把所有商店按最终时间 $T$ 更新一遍，将不符合的清除出优先缓存。

具体实现见代码，有详细的注释，并给出一种写代码时遇到问题的样例。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

struct node{
    int last, val; // i号商店上次更新的时间，以及优先级
}s[N];

struct order{
    int ti, id;
    bool operator < (const order &A)const{
        return ti < A.ti;
    }
}o[N];

int vis[N]; // 记录是否在优先缓存中
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int n, m, t;
    cin >> n >> m >> t;

    for(int i = 1; i <= m; i ++){
        cin >> o[i].ti >> o[i].id;
    }

    sort(o + 1, o + 1 + m); // 先按订单顺序排序
    int ans = 0;
    for(int i = 1; i <= m; i ++){// 每次只更新有订单的商店
        auto [ti, id] = o[i];
        int time = max(0, ti - s[id].last - 1); // 计算应该期间应该减少的优先级， -1是因为当前时刻有订单进来了优先级就不用减少, max{0}防止连续订单造成time负数的情况
        s[id].val = max(0, s[id].val - time); // 保证优先级不会小于0,并加上当前有订单的贡献

        // 要在加上本次的2之前先进行移除的判断,否则可能存在之前进入缓存，但因为时间流逝<=3要清除，但先加上本次的2可能使得>3and<=5 不满足又一次进入优先缓存但也没有清除
        // 详情可以参考文末提供的样例
        if(vis[id] == 1 && s[id].val <= 3){ 
            vis[id] = 0;
            ans --;
        }
        s[id].val += 2;
        if(vis[id] == 0 && s[id].val > 5){ // 如果之前不在优先缓存中，则记录
            vis[id] = 1;
            ans ++;
        }
        s[id].last = ti; // 更新 上次更新的时间（即为当前时刻）
    }
    for(int i = 1; i <= n; i ++){ // 最后将所有商店按最终时间t更新一次
        int time = t - s[i].last;
        if(vis[i] == 1 && s[i].val - time <= 3) ans --; // 若最后更新前在优先缓存中，更新后小于等于3说明需要从优先缓存中移除
    }
    cout << ans;
    return 0;
}
/*
1 4 5
1 1
1 1
1 1 // 此时1号优先级为6 加入优先缓存
…… 时间流逝后1 <= 3 移除
5 1 // 优先级为5没能再一次加入优先缓存

ans = 0
*/
```


---

## 作者：wuhan1234 (赞：3)

## 1.编程思路。

直接进行模拟的题目。

定义结构体数组 $a$ 保存每个订单信息，该数组的每个数组元素包含 $2$ 个成员分量：表示订单的时刻 $ts$ 和收到订单的外卖店编号 $id$。数据输入后，将数组 $a$ 按订单时刻 $ts$ 从小到大进行排序，这样同一时刻的订单会连续排列在一起。

定义如下三个数组：

```
int p[100005]={0};

int exist[100005]={0}; 

int have[100005];
```
其中，数组元素  $p[i]$ 保存编号为 $i$ 的外卖店的优先级；数组元素 $exist[i]$ 用于标识编号为 $i$ 的外卖店是否在优先缓存中，$exist[i]=1$ 表示编号为 $i$ 的店在优先缓存中；数组元素 $have[i]$ 用于标识在时刻 $t$ 编号为 $i$ 的外卖店有无订单，$have[i]=1$ 表示在时刻 $t$ 编号为 $i$ 的外卖店有订单。

之后用循环对 $t$ 个时刻进行直接模拟即可。具体过程参见源程序。

## 2.源程序。

```c
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct Node
{
	int ts,id;
};
int cmp(struct Node x,struct Node y)
{
	return x.ts<y.ts;
}
int main()
{
	struct Node a[100005];
	int p[100005]={0};       // p[i]保存编号为 i 的店的优先级
	int exist[100005]={0};   // exist[i]=1表示编号为i的店在优先缓存中
	int have[100005];        // have[i]=1表示在时刻t编号为i的店有订单
    int n,m,t;
	scanf("%d%d%d",&n,&m,&t);
	int i,j=0,k;
	for (i=0;i<m;i++)
		scanf("%d%d",&a[i].ts,&a[i].id);
	sort(a,a+m,cmp);
    int ans=0;
	for (i=1;i<=t;i++)          // 对每个时刻依次进行处理
	{
		memset(have,0,sizeof(have));
		for (k=j;a[k].ts==i;k++)  // 对订单表中时刻 i 的每个订单进行处理
		{
			j++;
			p[a[k].id]+=2;
			have[a[k].id]=1;
			if (p[a[k].id]>5 && exist[a[k].id]==0) // 优先级大于 5，被系统加入优先缓存
            {
                ans++;  exist[a[k].id]=1;
            }
		}
		for (k=1;k<=n;k++)                      // 对每家外卖店进行处理
		{
			if (p[k]>0 && have[k]==0)           // i时刻没有订单的外卖店减少优先级
			{
				p[k]--;
				if (p[k]<=3 && exist[k]==1)     // 优先级小于等于3，被清除出优先缓存
				{
				    ans--;  exist[k]=0;
				}
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：ny_Dacong (赞：1)

本篇题解主要强调一下本题的坑点。

# 思路

可以把每个商店的订单拎出来，针对单个商店处理。每个商店的订单要互相独立，又要按照时间顺序排序，容易想到小根堆。

所以可以开 $n$ 个小根堆，每个小根堆内存对应商店的订单。然后模拟即可。

# 坑点

1. 优先级不可以小于 0。
2. 有可能同一时刻有多个订单，有订单的这个时刻不应该减活跃度。
4. 每个商店还要处理最后一个订单与 $T$ 时刻之间可能减少的活跃度。
3. 要先判断该商店是否被踢出清除出优先缓存，再加活跃度，最后再判断加入优先缓存。举例：假如一个商店先加入了优先缓存，然后优先度降为 3。这时，来了一个订单，那么这个商店应该先踢出缓存，然后活跃度加 2。最终，它并没有在缓存中。但是如果先加 2，再判断，它还是在缓存里。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,ans = 0;
priority_queue<int,vector<int>,greater<int>> que[100005];
int main(){
    scanf("%d%d%d",&n,&m,&t);
    for(int i = 1; i <= m; i++){
        int tid,shop;
        scanf("%d%d",&tid,&shop);
        que[shop].push(tid);
    }
    for(int i = 1; i <= n; i++){
        int now = 0,Last = 0,num = 0;
        bool inque = 0;
        while(que[i].size()){
            now = que[i].top();
            que[i].pop();
            if(now != Last){
                num -= now-Last-1;
            }
            if(num < 0){
                num = 0;
            }
            if(num <= 3){
                inque = 0;
            }
            num += 2;
            Last = now;
            if(num > 5){
                inque = 1;
            }
        }
        if(t != Last){
            num -= t-Last;
        }
        if(num <= 3){
            inque = 0;
        }
        if(num < 0){
            num = 0;
        }
        if(num > 5){
            inque = 1;
        }
        if(inque){
            ans++;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：hahaloo (赞：1)

## 思路分析
这道题可以使用**模拟**来解决。首先，将所有订单按时间戳从小到大排序，然后循环模拟从 $1$ 时刻到 $T$ 时刻的过程。在每个循环中，根据当前时刻是否有新的订单，更新每家外卖店的**优先级**，并让该店是否在优先缓存中相应地作出调整。循环结束后，输出优先缓存中的店数即可。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node {
    int ts, id; 
};

bool cmp(struct Node x, struct Node y) {   //结构体排序函数
    return x.ts < y.ts;
}
struct Node orders[100005];  //存储所有订单 
int priority[100005] = {0};   //存储每家外卖店的优先级，下标表示外卖店编号。
int in_cache[100005] = {0};   //存储当前是否有外卖店在优先缓存中，下标表示外卖店编号。
int have_order[100005];      //记录当前时刻哪些外卖店有订单，数组元素值为1说明该外卖店有订单，否则无订单。
int main() {

    int n, m, t;
    scanf("%d%d%d", &n, &m, &t);   //输入外卖店数量、订单数量和统计时刻T

    int i, j = 0, k;
    for (i = 0; i < m; i++) {        //循环读入所有订单，并按时间从小到大排序
        scanf("%d%d", &orders[i].ts, &orders[i].id);
    }
    sort(orders, orders + m, cmp);  

    int num_in_cache = 0;   //外卖店优先缓存中的店数，初始为0。
    for (i = 1; i <= t; i++) { 
        memset(have_order, 0, sizeof(have_order));   //初始化have_order数组为0，记录这一轮中每一家店有没有订单。
        for (k = j; orders[k].ts == i; k++) {      //遍历所有的订单
            j++;
            priority[orders[k].id] += 2;           //该店优先级加2
            have_order[orders[k].id] = 1;          //标记该店有订单
            if (priority[orders[k].id] > 5 && !in_cache[orders[k].id]) {    //如果优先级大于5且不在缓存中，则将其加入缓存
                num_in_cache++; 
                in_cache[orders[k].id] = 1;
            }
        }
        for (k = 1; k <= n; k++) {     //循环更新所有外卖店的优先级
            if (!have_order[k]) {     //若此店该轮没有订单，则其优先级减1
                priority[k]=max(priority[k]-1,0);//防止优先级出现负数 
                if (priority[k] <= 3 && in_cache[k]) {    //如果优先级小于等于3且在优先缓存中，则将其移出缓存
                    num_in_cache--;
                    in_cache[k] = 0;
                }
            }
        }
    }

    printf("%d\n", num_in_cache);   //输出优先缓存中的外卖店数

    return 0;
}

```


---

## 作者：Lele_Programmer (赞：0)

# P8685 题解

## 思路

比较简单的模拟，将每一个订单信息按照时间从小到大排序，然后依次枚举每一个订单，设 $last_i$ 为第 $i$ 个外卖店最后一次更新优先级的时间点，$a_i$ 为第 $i$ 个外卖店的优先级，$cache_i$ 为第 $i$ 个外卖店是否处于优先缓存中。

枚举每一个订单时，先将该外卖店的优先级更新到 $ts-1$ 的时刻（相距这些时刻都是要减去 $1$ 的），然后最后一个时刻加 $2$。

处理完所有订单后，枚举每一个外卖店，将它们分别更新到 $T$ 时刻。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=100005;

int n,m,t;
int a[N];
bool cache[N];
int last[N];

struct node {
    int ts,id;
    friend bool operator < (const node& a,const node& b) {
        return a.ts<b.ts;
    }
} arr[N];

void update(int id,int time) {
    if (time-last[id]<=0) return;
    a[id]=max(0,a[id]-(time-last[id]));
    last[id]=time;
    if (a[id]<=3) cache[id]=false;
}

int main() {
    scanf("%d %d %d",&n,&m,&t);
    for (int i=1;i<=m;++i) {
        scanf("%d %d",&arr[i].ts,&arr[i].id);
    }
    sort(arr+1,arr+1+m);
    for (int i=1;i<=m;++i) {
        int ts,id;
        ts=arr[i].ts;
        id=arr[i].id;
        update(id,ts-1);
        a[id]+=2;
        if (a[id]>5) cache[id]=true;
        last[id]=ts;
    }
    for (int i=1;i<=n;++i) {
        update(i,t);
    }
    int ans=0;
    for (int i=1;i<=n;++i) {
        if (cache[i]) ans++;
    }
    printf("%d",ans);
    return 0;
}
```

上面代码 `update(id,time)` 表示将第 $id$ 个外卖店的优先级状态更新到 $time$ 的状态。有一点要注意的是，有可能在同一时刻内，同一个外卖店接到了多个外卖，更新的时候可能出现 $time-last_i \le 0$ 的情况，特判一下就好了。

---

## 作者：Ycc211 (赞：0)

# **思路**
## $a$：优先级清零时刻。 $b$：当前时刻（订单的时间）。
题目想要知道在 $T$ 时刻有多少外卖店在优先缓存里，可以转换求外卖店进入优先缓存时在 $T$ 时刻是否还在优先缓存中。我们可以用一个数来表示外卖店的优先级在哪一时刻会清零（未收到订单的情况下），根据订单来更新这个时刻。然后外卖店在 $b$ 时刻的优先级就等于 $a-b$。如果 $a-b>5$，外卖店进入优先缓存，继续判断T时刻是否还在缓存，也就是在T时刻的优先级是否大于 $3$（$a-T>3$），如果大于 $3$ 就记录这个外卖店。
## 注意：
在更新 $a$ 时，如果 $a<b$ ，说明这个外卖店在收到订单时的优先级已经清零，那么 $a$ 应该等于 $b+2$。如果 $a≥b$ ，$a$ 应该等于 $a+3$ ，因为当前时刻收到了订单，优先级从要减一变成加二，如果这个外卖店当前时刻继续收到订单就只需要加二就行了。

最后附上 ac 代码。





```c
#include<bits/stdc++.h>
using namespace std;
struct dd{
	int t;
	int id;
}d[100005];//存储订单
bool cmp(dd a,dd b){
	if(a.t<b.t) return 1;
	if(a.t>b.t) return 0;
	if(a.id<b.id) return 1;
	 return 0;
}//按时间从小到大排序,同一时间按外卖店ID排序
bool vis[100005];//一个外卖店在T时刻最多记录一次
int an[100005];//记录每个外卖店多久优先级清零
int n,m,T,ans;
int main(){
     cin >>n>>m>>T;
    
     for(int i=1;i<=m;i++)
     cin>>d[i].t>>d[i].id;
	 sort(d+1,d+1+m,cmp);

	for(int i=1;i<=m;i++){
	 if(an[d[i].id]<d[i].t)
	 	an[d[i].id]=d[i].t+2;//a<b的情况
	  else{ an[d[i].id]=an[d[i].id]+3;//a≥b的情况
		    if(d[i].id==d[i-1].id&&d[i].t==d[i-1].t) an[d[i].id]--;// 一个外卖店在同一时刻收到多个订单
			if(an[d[i].id]>d[i].t+5&&an[d[i].id]>T+3&&!vis[d[i].id])//满足条件
			ans++;vis[d[i].id]=1;
		  }			 
	}
		 cout<<ans;//输出答案
	return 0;
}


```

---

## 作者：fish_gugu (赞：0)

## 思路

首先我想到了暴力模拟。但是如果你用暴力，时间复杂度 $O(N \cdot T)$，在比赛中是无法通过的，显然我们需要进行**优化**。

### 优化

我们可以通过使用 `pair<ts,id>` 的的方式来存储进货的时间和店铺的编号，如果碰到同一个时间、同一个店铺出现好几个订单的情况，可以用**双指针**找出。之后的就很简单了，就是常规模拟。

### 坑点


注意不能 $T$ 时刻再检测,因为存在 $T$ 时刻优先级 $>3$ 但未 $>5$ 所以不能加入缓存的外卖店

## 代码

```c
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pll;
pll a[1000100];
bool st[1000100];
int val[1000100],post[1000100];
int main()
{
    int n,m,t;
    cin >> n >> m >> t;
    for(int i = 0;i < m;i++)
    {
        int ts,id;
        cin >> ts >> id;
        a[i] = {ts,id};
    }
    sort(a,a + m);
    for(int i = 0;i < m;)
    {
        int j = i;
        while(j < m && a[i] == a[j]) j++; //将订单号相同的一同处理
        int cnt = j - i,tt = a[i].first,id = a[i].second；
        val[id] -= (tt - post[id] - 1); //本次时间 - 上次处理订单的时间
        if(val[id] < 0) val[id] = 0;
        if(val[id] <= 3) st[id] = false; //退出优先级
        val[id] += cnt * 2;
        if(val[id] > 5) st[id] = true; //进入优先级
        post[id] = tt;
        i = j;
    }
    
    for (int i = 1;i <= n;i++)
        if (post[i] < t)
        {
            val[i] -= t - post[i]; //减少优先级
            if(val[i] < 0) val[i] = 0;
            if (val[i] <= 3) st[i] = false;
        }
    
    int res = 0;
    for(int i = 1;i <= n;i++)
        if(st[i]) res++;
    cout << res << endl;
    return 0;
}
```

---

## 作者：cpu_gal (赞：0)

从样例可看出同一外卖店某一时刻可能会有多个订单。

我们先将订单按时间排序，再按外卖店编号排序，这样同一时刻若存在多个订单，外卖店编号相等的一定相邻。

对某一时刻 $T _ {i}$ 的订单来说，我们累加该时刻同一外卖店编号的所有订单产生的优先级。

在累加优先级前，先计算出外卖店距离上次产生订单的时刻 $T$ 时刻时间内，由于没有订单所带来的优先级的减少。

之后累加 $T _ {i}$ 时刻所有订单带来的的优先级的增加。

最后再对最终的 $T$ 时刻特殊处理一下即可。

注意点并不需要真的将优先级大于 $5$ 的外面店加入缓存队列中，只需一个标记数组表明是否在队列中即可。

```c
const int N=1e5+10;
PII a[N];
int level[N];
int last_time[N];
bool vis[N];
int n,m,t;
 
int main()
{
    cin>>n>>m>>t;
 
    for(int i=0;i<m;i++)
        cin>>a[i].fi>>a[i].se;
    sort(a,a+m);
 
    for(int i=0;i<m;)
    {
        int j=i;
        while(j<m && a[j] == a[i]) j++;
        int tim=a[i].fi,id=a[i].se;
        level[id]-=tim-last_time[id]-1;
        level[id]=max(level[id],0);
        if(level[id] <= 3) vis[id]=false;
 
        level[id]+=(j-i)*2;
        if(level[id] > 5) vis[id]=true;
 
        last_time[id]=tim;
        i=j;
    }
 
    for(int i=1;i<=n;i++)
        if(last_time[i] < t)
        {
            level[i]-=t-last_time[i];
            if(level[i] <= 3) vis[i]=false;
        }
 
    int res=0;
    for(int i=1;i<=n;i++)
        if(vis[i])
            res++;
 
    cout<<res<<endl;
    //system("pause");
    return 0;
}
```

---

## 作者：nyC20 (赞：0)

# 思路
外层循环模拟时刻，内层处理订单 + 维护优先缓存就行了，需要注意优先等级最低是 $0$，还有优先缓存的判定，是 $>5$ 进，$\le3$ 出，很容易写错。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int time, d;//时刻和店铺 
}ding[100003];//订单 
bool cmp(node a, node b){
	return a.time<b.time;
}//按订单时间顺序排序 
int n, m, t, num, f[100003], ans;
bool vis[100003], mark[100003];
int main() {
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&ding[i].time,&ding[i].d);
	}//把时刻和店铺存下来 
	sort(ding+1,ding+1+m,cmp);//排序 
	for(int i=1;i<=t;i++){//外层模拟时刻，从1到t 
		memset(mark,false,sizeof mark);//mark存这一时刻是否有单，所以每一时刻开始时初始化 
		for(int j=num+1;;j++){//内层循环找订单 
			if(ding[j].time!=i){//一旦该订单时刻不是外层模拟的i 
				num=j-1;//用临时变量存当前循环到哪里了 
				break;//然后退出循环 
			}
			//接下来处理该时刻的订单 
			f[ding[j].d]+=2;//f数组存每一个店铺的优先等级 
			mark[ding[j].d]=true;//mark打标记 
		}
		for(int j=1;j<=n;j++){//遍历一遍店铺 
			if(mark[j]==false){//如果该时刻该店铺没有订单 
				f[j]--; //扣优先级 
				if(f[j]<0)f[j]=0;//特判，最小为0 
			}
			//vis记录在不在优先缓存 
			if(f[j]>5)vis[j]=true;//进优先 
			if(f[j]<=3)vis[j]=false;//出优先 
		}
	}
	for(int i=1;i<=n;i++){//遍历vis数组，算出答案 
		if(vis[i]==true)ans++;
	}
	printf("%d",ans);
	return 0;
}
```

---


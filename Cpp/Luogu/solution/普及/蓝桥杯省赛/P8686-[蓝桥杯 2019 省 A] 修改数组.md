# [蓝桥杯 2019 省 A] 修改数组

## 题目描述

给定一个长度为 $N$ 的数组 $A=[A_1,A_2, \cdots A_N]$，数组中有可能有重复出现的整数。

现在小明要按以下方法将其修改为没有重复整数的数组。小明会依次修改 $A_2,A_3, \cdots ,A_N$。

当修改 $A_i$ 时，小明会检查 $A_i$ 是否在 $A_1$ ∼ $A_{i-1}$ 中出现过。如果出现过，则小明会给 $A_i$ 加上 $1$；如果新的 $A_i$ 仍在之前出现过，小明会持续给 $A_i$ 加 $1$，直到 $A_i$ 没有在 $A_1$ ∼ $A_{i-1}$ 中出现过。

当 $A_N$ 也经过上述修改之后，显然 $A$ 数组中就没有重复的整数了。

现在给定初始的 $A$ 数组，请你计算出最终的 $A$ 数组。

## 说明/提示

对于 $80\%$ 的评测用例，$1 \le N \le 10000$。

对于所有评测用例，$1 \le N \le 10^5$，$1 \le A_i \le 10^6$。

蓝桥杯 2019 年省赛 A 组 H 题。

## 样例 #1

### 输入

```
5
2 1 1 3 4```

### 输出

```
2 1 3 4 5```

# 题解

## 作者：Maysoul (赞：41)

这道题可以采用并查集的方法来做。

先理清一下题意，我们需要将一个有重复整数的数组变为无重复整数的数组。对于 $ A $ 中的一个数据 $ a_{i} $，我们先看一下在 $ a_{i} $ 的前面是否有 $ a_{i-j} $ 与之相等，如果有 $ a_{i-1} $ 的话，那就让 $ a_{i} $ 加一，再重复上述操作。

当前面没有 $ a_{i} $ 的时候，输出就是它本身，可是如果有呢？

我们可以设置一个并查集，在每次出现 $ a_{i} $ 的时候，就把 $ a_{i} $ 的父亲加一，由于一开始所有 $ a_{i} $ 的父亲都是 $ a_{i} $，所以可以保证其下一次再出现 $ a_{i} $ 的时候发生变换，这也是并查集思想的直观体现。

### AC CODE:


```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;
int num,ans;
int fa[100100];
int find(int x)//并查集中的查询操作
{
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);
}
int main()
{
	int n;
	cin>>n;
	for (int i=1;i<100100;i++)//所有数最开始都应指向它本身
	{
		fa[i]=i;
	}
	int a;
	for (int i=1;i<=n;i++)
	{
		cin>>a;
		a=find(a);//查询这个数
		fa[a]=find(a)+1;//修改它的父节点
		cout<<a<<" ";
	}
	return 0;
}

```


---

## 作者：hahaloo (赞：29)

### [题目传送门](https://www.luogu.com.cn/problem/P8686)
## 这题需要用到并查集
首先我们需要了解**并查集**的模板。
```cpp
int find(int x){
	if(f[x]!=x){//若这个点指向的不是自己则继续递归
		f[x]=find(f[x]);
	}
	return f[x];
}
```
```cpp
void join(int x,int y){
	int x_root=find(f[x]);//找到x的祖先
	int y_root=find(f[y]);//找到y的祖先
	f[x_root]=y_root;//将x与y的祖先相连
}
```
#### `find` 函数的功能是寻找 $x$ 的祖先。

#### `join` 函数的功能将 $x$ 所在的树与 $y$ 所在的树合并（即将 $x$ 的祖先与 $y$ 的祖先合并到一起）。
## 题目分析
我们先找到这个点 $a$ 的**祖先** $n$，输出 $n$，在将 $a$ 点与 $a+1$ 点相连。

这是这一题的**重点**，也许这有一点难以理解，我们可以模拟一下此过程。
我们使用 $2$ $1$ $1$ $3$ $4$ 这个样例进行模拟。
![](https://cdn.luogu.com.cn/upload/image_hosting/ojuam3ql.png)
找到 $2$ 的祖先：$2$，输出 $2$，连接 $2$ 和 $3$。
![](https://cdn.luogu.com.cn/upload/image_hosting/fit04hz9.png)
找到 $1$ 的祖先：$1$，输出 $1$，连接 $1$ 和 $2$。
![](https://cdn.luogu.com.cn/upload/image_hosting/71t806k5.png)
找到 $1$ 的祖先：$3$，输出 $3$，连接 $3$ 和 $4$。
![](https://cdn.luogu.com.cn/upload/image_hosting/iyzcoo7o.png)
找到 $3$ 的祖先：$4$，输出 $4$，连接 $4$ 和 $5$。
![](https://cdn.luogu.com.cn/upload/image_hosting/1mg3b60a.png)
找到 $4$ 的祖先：$5$，输出 $5$，连接 $5$ 和 $6$。
#### 到这里就模拟结束了，显然我们得到了正确答案 $2$ $1$ $3$ $4$ $5$。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[100005],a;
int find(int x){
	if(f[x]!=x){
		f[x]=find(f[x]);
	}
	return f[x];
}
void join(int x,int y){
	int x_root=find(f[x]);
	int y_root=find(f[y]);
	f[x_root]=y_root;
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=100005;i++){
		f[i]=i;//初始化
	}
	for(int i=1;i<=n;i++){
		cin>>a;
		a=find(a);//找到a的祖先
		cout<<a<<' ';
		join(a,a+1);//将a与a+1相连
	}
}
```


---

## 作者：zgy_123 (赞：27)

看到题解区的做法没有 set，于是我交一发 set 题解。

[set 的概念](https://oi-wiki.org/lang/csl/associative-container/)，自行了解。

我们知道，在 set 中 `s.lower_bound(x)` 会返回第一个不小于 $x$ 的数的地址，这就是我们思路的基础。

我们可以将所有没有使用过的数都放到 set 中，每输入一个数 $x$，就删除第一个不小于 $x$ 的数，并且输出。

注意，初始化时要到 $10^6+10^5$。

（也许最短）代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
set <int> s; 
set <int> ::iterator it;
int main(){
	for(int i=1;i<=1e6+1e5;i++) s.insert(i);
	int n,x;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		it=s.lower_bound(x);
		s.erase(*it);
		printf("%d ",*it);
	}
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：10)

首先被修改的数显然具有单调性：若不能变成 $x$，那么也不能变成 $x-1$，同时也不能变成比 $x$ 小的数，那么可以考虑二分。

对于 `check` 函数：如果 $[a,mid]$ 都有元素，那么此时 $mid$ 就是不可行的，否则 $mid$ 就是可行的。

这样的 `check` 可以用树状数组维护，时间复杂度 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&-x
using namespace std;
const int maxn=1e5+5,maxv=2e6+5;
int n,c[maxv];
inline void add(int x){
	for(;x<=2e6;x+=lowbit(x))
		++c[x];
}
inline int ask(int x){
	int s=0;
	for(;x;x-=lowbit(x))
		s+=c[x];
	return s;
}
int main(){
	scanf("%d",&n);
	for(int i=1,a;i<=n;++i){
		scanf("%d",&a);
		int l=a,r=2e6;
		while(l<r){
			int mid=l+r>>1;
			if(ask(mid)-ask(a-1)==mid-a+1)
				l=mid+1;
			else
				r=mid;
		}
		printf("%d ",r);
		add(r);
	}
	return 0;
}
```

---

## 作者：_7Mr (赞：9)

# 前言
**如果不知道并查集的同学，可以先去把[这道题](https://www.luogu.com.cn/problem/P3367)做了。**

我呢最先没有按照并查集的思路去做，用了一点小技巧，结果只有 $90$ 分，会   TLE 一个。
![](https://cdn.luogu.com.cn/upload/image_hosting/8o2j8tgl.png)
```cpp
#include<iostream>
using namespace std;
const int maxn=1e6+5;
int n;
int flag[maxn];
int main() {
	scanf("%d",&n);
	int la;
	for(int i=1;i<=n;i++){
		scanf("%d",&la);
		while(flag[la]) la++;
		flag[la]=1;
		printf("%d ",la);
	}
	return 0;
}
```
~~这个代码就不用讲了吧。~~
# 正题

那么我们就正式步入正题。

首先就是并查集模板。

```cpp
int find(int x) {
	if (f[x]==x) return x;
	else return f[x]=find(f[x]);
}
```

然后初始化并查集数组。

```cpp
for(int i=1;i<=1e6+5;i++) f[i]=i;
```

接下来的一步就是重中之重了，这是解题的关键。

首先将当前输入的这个数变为它的祖先，也就是还未出现过的数，然后输出这个数，接着将这个数的祖先的祖先加一，相当于变为不同的数，然后重复这些操作。

这句话有点绕，没懂的同学多读几遍或者自己模拟一下，不要急着看代码。

```cpp
cin>>a[i];
a[i]=find(a[i]);
cout<<a[i]<<" ";
f[a[i]]++;
```

# ACcode
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int n;
int a[maxn],f[maxn];
int find(int x) {//模板  
	if (f[x]==x) return x;
	else return f[x]=find(f[x]);
}
int main() {
	ios::sync_with_stdio(false);//优化  
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n;
	for(int i=1;i<=1e6+5;i++) f[i]=i;//初始化  
	for(int i=1;i<=n;i++) {//重中之重  
		cin>>a[i];
		a[i]=find(a[i]);//变为自己的祖先  
		cout<<a[i]<<" ";//输出  
		f[a[i]]++;//祖先的祖先 -> 变为不同的数  
	}
	return 0;
}
```

---

## 作者：what_can_I_do (赞：8)

[传送门](https://www.luogu.com.cn/problem/P8686)

这题肯定不能用暴力，可以用并查集来做。

数组 $b$ 是我读入的数组，数组 $a$ 是模拟并查集的数组。其中并查集 $a$ 中的 $a_i$ 表示一个为 $i$ 的数它要修改成 $a_i$。

那么当一个 $b_i$ 修改之后，$b_i$ 这个数就不能在后面的数中出现了，那么 $a_{b_i}$ 的值也要加一，因为如果后来遇到与 $b_i$ 相同的数时那个数就要修改为 $b_i+1$，此时我们就可以直接让 $b_j$ 等于 $a_{b_i}$。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000010],b[100010],maxx=1000000;
inline int find(int k)
{
	if(a[k]==k) return k;
	return a[k]=find(a[k]);
}
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++) scanf("%d",&b[i]),maxx=max(maxx,b[i]);
    for(register int i=1;i<=maxx;i++) a[i]=i;    //初始化，a[i]=i是因为刚开始第一个出现的i是不会与前面重复的，直接等于自己
    for(register int i=1;i<=n;i++)
    {
    	int x=find(b[i]);    //修改为a[b[i]]的祖先，才能不重复
    	b[i]=x,a[x]++;    //把b[i]值修改为x，a[b[i]]自增保证其不指向自己保证后面修改时不重复，也方便后面修改（直接等于a[b[i]]的祖先）
	}
	for(register int i=1;i<=n;i++) printf("%d ",b[i]);
    return 0;
}
```

---

## 作者：kkxacj (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P8686)

#### 思路

仔细思考 ~~（看算法标签）~~ 后，不难看出这是一道并查集的水题，如果 $x$ 的父亲是它自己，直接输出它自己，并将它连向 $x + 1$ 的父亲，否则输出它的父亲，连接他的父亲加一的父亲。

code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,o,f[1000010];
int find(int x)//并查集模板
{
	if(x == f[x]) return x;
	return f[x] = find(f[x]);
}
int main()
{
	scanf("%d",&n);
	for(int i = 1; i <= 1000000;i++) f[i] = i;//初始化
	for(int i = 1;i <= n;i++)
	{
		scanf("%d",&o);
		int w = find(o);
		if(f[w] != o)
		{
			f[w] = find(w + 1);
			printf("%d ",w);
		}
		else
		{
			f[w] = find(o + 1);
			printf("%d ",o);
		}
	}
	return 0;
}
```


---

## 作者：liuyi0905 (赞：4)

### [题目传送门](/problem/P8686)
**题目大意：**

要将一个可能有重复数字的数组 $A$，变成一个无重复数字的数组，再输出改变后的数组 $A$。

**大致思路：**

这道题暴力枚举肯定是没法做的，再想想，可以采用并查集的方法来做：
1. 查询 $a_i$ 的前面是否有和它相等的元素，如果有，则将 $a_i$ 加一，直到没有和它相等的元素。
2. 如果 $a_i$ 前面的元素没有和它相等的，答案就是 $a_i$。
3. 每次做题都要看数据范围，数组别开小了。

**具体代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,f[1000005];
int Find(int x){return x==f[x]?x:f[x]=Find(f[x]);}
//并查集模版，函数名建议避开STL中的find
int main(){
	cin>>n;
	for(int i=1;i<=100005;i++)f[i]=i;
	for(int i=1;i<=n;i++){
		cin>>x;
		x=Find(x);//查询和x相等的元素
		f[x]=Find(x)+1;//将x加一
		cout<<x<<" ";//输出改后的元素
	}
	return 0;
}
```

---

## 作者：_Above_the_clouds_ (赞：2)

# 思路：
因为 $a_i$ 的范围是 $1\sim10^6$，所以 $i$ 从$1\sim10^6$ 枚举，将所有 $f_i$ 的祖先设为它自己。$fx$ 记录 $a_i$ 的祖先，为了不出现重复数字，每次 $fx$ 的祖先为 $fx$ 加一，也就是 `f[fx]=fx+1`，然后将 $a_i$ 重新设为 $fx$，最后输出即可。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,fx;
int a[100005],f[1000005];
int find(int x){
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=1000000;i++) f[i]=i;
	for(int i=1;i<=n;i++){
		fx=find(a[i]);
		f[fx]=fx+1;
		a[i]=fx;
	}
	for(int i=1;i<=n;i++) cout<<a[i]<<" "; 
	return 0;
} 
```


---

## 作者：Molina (赞：2)

# 题目大意：
给定一个长度为 $ N $ 的数组，数组中可能会有重复出现的整数，需要依次修改数组，如果重复则加 $ 1 $，直到数组不再重复。
# 本题思路：
## 并查集
因为是查找是否有相同数据，所以想到用并查集做。

### 方法：
1. 输入，然后将 $ b $ 数组（存储父亲节点值的数组）依次赋值（并查集需要）。

2. 开一重循环，直接套用并查集函数，去查找哪一个答案符合情况（答案不会错误，因为后面要将父亲节点值加 $ 1 $），然后直接输出答案。

3. 在并查集过程中，每次查找后要把当前数字的父亲节点值加 $ 1 $，避免之后出现数据重复。

# 本题代码：
### 暴力代码（会超时）：
```cpp
	cin>>n;
	for(int i=1;i<=n;i++)  cin>>a[i];
	b[a[1]]++;
	for(int i=2;i<=n;i++){
		while(b[a[i]])  a[i]++;
		b[a[i]]++;
	}
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
```
### 并查集代码：
#### 并查集函数：
```cpp
int bcj(int i){
	if(b[i]==i) return i;
	else return b[i]=bcj(b[i]);
}
```
#### 主程序：
```cpp
	cin>>n;
	for(int i=1;i<=200000;i++)  b[i]=i; //赋值
	for(int i=1;i<=n;i++){//并查集代码（核心代码）
		cin>>a[i],a[i]=bcj(a[i]);//并查集找答案
		cout<<a[i]<<" "; //输出
		b[a[i]]++;//将父亲节点值加上1
	}
```
注意：这样写可能 $ b_1 $ 到 $ b_n $ 会因存储数据太大，这里的 $ n $ 没有太大，那么便可以这样做。

---

## 作者：minVan (赞：2)

**题目大意**

给定一个长度为 $n$ 的数组 $a$，对于 $a_i(1\le i \le n)$，如果在 $a_1$ 至 $a_{i - 1}$ 有值为 $a_i$ 的，那么就将 $a_i$ 变成从 $1$ 开始第一个与 $a_1\dots a_{i-1}$ 不同的数，求最后的 $a$ 数组。

**解题思路**

我们可以运用并查集，先将 $a_i$ 变为 $\text{Find}(a_i)$，再将 $f_{a_i}$ 改为 $\text{Find}(a_i)+1$，这里 $\text{Find}(a_i)+1$ 是指从 $1$ 开始第一个与 $a_1\dots a_{i-1}$ 不同的数。

**AC 代码，请勿抄袭**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int n, a[N], f[N];
inline int Find(int x) {
    return f[x] == x ? x : f[x] = Find(f[x]);
}
int main() {
    for(int i = 1; i < N; i++) {
        f[i] = i;
    }
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for(int i = 1; i <= n; i++) {
        a[i] = Find(a[i]);
        cout << a[i] << ' ';
        f[a[i]] = Find(a[i]) + 1;
    }
    return 0;
}
```

---

## 作者：qifan_maker (赞：1)

### 题目链接
[洛谷](https://www.luogu.com.cn/problem/P8686)
### 题目解法
如果直接暴力，每读入一个数，就在前面找有没有相同的数，如果有就加一，直到前面没有相同的数，但是这种方法的时间复杂度大概为 $\mathcal{O}(n^2)$，无法通过此题。

我们需要用到**并查集**算法。并查集算法比较简单，这里就不过多介绍了，不了解的朋友可以去 [OI-wiki](https://oi-wiki.org/ds/dsu/) 看看。

如果读入的数没有出现过，就直接输出，并在父亲数组中将它的父亲设为它加一；

如果出现过，也就是父亲数组中有这个数的记录，那么就输出它的父亲，并将它的父亲加一，这样所有出现过的数就都会指向一个父亲，而这个父亲就是**最小没有出现**的数字。

时间复杂度 $\mathcal{O}(n)$。
### [AC](https://www.luogu.com.cn/record/98203817) Code
```cpp
/*
题目编号：
P8686 [蓝桥杯 2019 省 A] 修改数组
By：
qifan_maker
*/
#include <bits/stdc++.h>
using namespace std;
int n,a[1000100],f[1000100];
int find(int x){
	if(f[x] == x){
		return f[x];
	}
	f[x] = find(f[x]);
	return f[x];
}
int main(){
	for(int i=1;i<=1000100;i++){
		f[i] = i;
	}
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> a[i];
		a[i] = find(a[i]);
		f[a[i]] = find(a[i])+1;
		cout << a[i] << " ";
	}
}
```

---

## 作者：doby (赞：1)

### 思路
每次插入一个数，如果这个数的位置已经被占了，就需要在右边找一个最近的空位占下。  
显然可以用二分+线段树直接维护这个过程。  
复杂度 $ O(n\log^2_2n) $ （能过）。
```
#include<cstdio>
using namespace std;
int n,a[100010],out;
char c;
struct SegT
{
	int s;
}t[4400010];
int read()
{
	out=0,c=getchar();
	while(c<48||c>57){c=getchar();}
	while(c>=48&&c<=57){out=(out<<3)+(out<<1)+(c&15),c=getchar();}
	return out;
}
void Pushup(int k)
{
	t[k].s=t[k<<1].s+t[k<<1|1].s;
}
void Change(int k,int l,int r,int x)
{
	if(l==r)
	{
		++t[k].s;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid){Change(k<<1,l,mid,x);}
	else{Change(k<<1|1,mid+1,r,x);}
	Pushup(k);
}
int Query(int k,int l,int r,int ll,int rr)
{
	if(ll<=l&&r<=rr){return t[k].s;}
	if(r<ll||rr<l){return 0;}
	int mid=l+r>>1;
	return Query(k<<1,l,mid,ll,rr)+Query(k<<1|1,mid+1,r,ll,rr);
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i){a[i]=read();}
	Change(1,1,n,a[1]);
	for(int i=2;i<=n;++i)
	{
		if(!Query(1,1,n,a[i],a[i])){Change(1,1,n,a[i]);}
		else
		{
			int l=a[i]+1,r=1100000,mid;
			while(l+1<r)
			{
				mid=l+r>>1;
				if(Query(1,1,n,l,mid)==mid-l+1){l=mid;}
				else{r=mid;}
			}
			if(!Query(1,1,n,l,l))
			{
				Change(1,1,n,l);
				a[i]=l;
			}
			else
			{
				Change(1,1,n,r);
				a[i]=r;
			}
		}
	}
	for(int i=1;i<=n;++i){printf("%d ",a[i]);}
	return 0;
}
```


---


# [蓝桥杯 2019 省 A] 糖果

## 题目描述

糖果店的老板一共有 $M$ 种口味的糖果出售。为了方便描述，我们将 $M$ 种口味编号 $1$ ∼ $M$。

小明希望能品尝到所有口味的糖果。遗憾的是老板并不单独出售糖果，而是 $K$ 颗一包整包出售。

幸好糖果包装上注明了其中 $K$ 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。

给定 $N$ 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。

## 说明/提示

对于 $30\%$ 的评测用例，$1 \le N \le 20$。

对于所有评测样例，$1 \le N \le 100$，$1 \le M \le 20$，$1 \le K \le 20$，$1 \le T_i \le M$。

蓝桥杯 2019 年省赛 A 组 I 题。

## 样例 #1

### 输入

```
6 5 3
1 1 2
1 2 3
1 1 3
2 3 5
5 4 2
5 1 2```

### 输出

```
2```

# 题解

## 作者：SamHJD (赞：44)

## P8687 题解

[题目传送门](https://www.luogu.com.cn/problem/P8687)

不难看出，此题不是爆搜就是动态规划，而爆搜需要考虑每一种搭配情况，复杂度 $O(2^n)$ 肯定超时。

考虑动态规划，可以发现数据范围很小，并且是搭配类型的，想到**状压**。

首先设计状态，一共可以设计出两种：

* $dp[i]$ 表示取状态为 $i$ 的几包糖，最多可以凑出的口味数量。这种状态比较麻烦，且结果不是很容易得出。

* $dp[i]$ 表示凑出状态为 $i$ 的口味**最少需要几包糖**。

很显然第二种很合理，那么我们来推一下方程。

思考发现，如果直接枚举 $i$，再找合理的上一种状态，不是很好找。但我们可以通过**已经求出来的一种状态**，配合**另一种状态**，来更新新的状态。

设 $v[i]$ 表示第 $i$ 包糖的口味状态，则有：

$dp[i|v[j]]=\min(dp[i|v[j]],dp[i]+1)$

$dp[i|v[i]]$ 为更新的新状态，$i$ 为已知的状态 $1$，再找**一包糖** $j$，更新出 $dp[i|v[i]]$。

考虑正确性，因为 $i$ 状态从 $0$ 开始枚举，因此枚举到 $i|v[i]$ 时肯定已经求出 $dp[i]$ 的值，并且是**最优**的。还有一个问题是是否可能重复选了某包糖，如果是，那么肯定这个值不是最优的，因为你买两包同样的糖和只买一包口味不会有新的。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20;
int n,m,k,dp[1<<20],v[1<<20];//状压的数组需要开2^n，因为表示的是状态
int main(){
    scanf("%d%d%d",&n,&m,&k);
    memset(dp,0x3f3f3f3f,sizeof(dp));
    for(int i=1;i<=n;++i){
        int h=0,p;
        for(int j=1;j<=k;++j){
            scanf("%d",&p);p--;
            h=h|(1<<p);//这里不能用+，一包糖里可能有多种同一口味的
        }
        dp[h]=1;//这些口味都可以用一包糖解决
        v[i]=h;//记录糖的状态
    }
    for(int i=0;i<(1<<m);++i){//i枚举的是状态，即0～1...11111（m个1）
        for(int j=1;j<=n;++j){
            dp[i|v[j]]=min(dp[i|v[j]],dp[i]+1);//如上
        }
    }
    if(dp[(1<<m)-1]==0x3f3f3f3f) cout<<-1;//搭配不出来
    else cout<<dp[(1<<m)-1];//搭配出来
    return 0;
}
```


---

## 作者：wuhan1234 (赞：19)

## 1. 编程思路。

用 $M$ 位二进制数来表示所购买糖果中 $M$ 种口味的组合情况。二进制数中 $b_i$ 位等于 $1$，表示有第 $i+1$ 种口味的糖果；若 $b_i$ 等于 $0$，表示没有第 $i+1$ 种口味的糖果。若 $M$ 种口味的糖果都有，则对应的 $M$ 位二进制数各位全为 $1$，用十进制整数表示为 $2^M-1$。

在输入数据时进行预处理，用 $a_i$ 保存第 $i$ 包糖果的口味组合情况。以题目中的输入输出样例为例，输入的 $6$ 包糖果的口味组合情况可以依次表示为 $3,7,5,22,26,19$。

之后就可以采用 0/1 背包进行求解。

设 $F_i$ 表示糖果的口味组合情况为 $i$ 时需要购买的最少的糖果包数。

初始时，$2^M$ 种口味组合情况的 $F_i(0\le i\le 2^M-1)$ 的值均可以设置为一个大于 $100$ 的整数，表示口味组合 $i$ 无法品尝到。

定义 $F_0=0$，什么口味也没有，显然什么糖果也不需要购买。

状态转移方程为 $F_{j \  or \  a_i}=\min(F_{j \  or \  a_i},F_j+1)$。

其中， $1\le i \le N$，$0\le j\le 2^M-1$。

最后的答案为 $F_{2^M-1}$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int f[1<<20],a[105]={0};
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
    int num=(1<<m);    // m种口味的各种组合总的状态数
	int i,j;
	for (i=0;i<num;i++)
    {
		f[i]=105;
	}
	for (i = 0;i<n;i++)
	{
		for (j = 0;j<k;j++)
		{
			int t;
			scanf("%d",&t);
			a[i] = a[i]|(1<<(t-1));
		}
	}
	f[0]=0;
	for (i=0;i<n;i++)
	   for (j=0;j<1<<m;j++)
	   {
		   if (f[j]>100) continue;
		   f[j|a[i]]= (f[j|a[i]]<f[j]+1)? f[j|a[i]] : f[j]+1;
	   }
	if (f[num - 1]==105) printf("-1");
	else printf("%d",f[num - 1]);
	return 0;
}
```


---

## 作者：lym2022 (赞：7)

### 思路
注意到 $m$ 最大只有 $20$，考虑状态压缩，因为不需要知道这个口味的糖果选了几个，所以可以将当前选的糖果状态压缩成一个二进制数，其中如果一位是 $0$ 说明这个口味的糖果没有选，是 $1$ 说明这个口味的糖果选过了。

状态设计：$f[i]$ 表示在糖果的状态为 $i$ 的二进制数时，买的最少袋数；

状态转移：枚举一个二进制状态 $i$，枚举要买第 $j$ 组糖果，$f[i|a[j]] = \operatorname{min} (f[i|a[j]],f[i] + 1)$，$f[i|a[j]]$ 表示状态为 $i$ 然后买了第 $j$ 组糖果后的状态，可以用按位或来将未买的一位 $0$ 变成 $1$，$f[i] + 1$ 表示状态 $i$ 买上第 $j$ 包后一共买的袋数。

初始化：初始每个状态都是 $1\times 10 ^ 9$，然后会输入每包糖果的状态，将第 $i$ 包糖的状态记为 $cnt$，$f[cnt] = 1$，因为状态 $cnt$ 只需要 $i$ 这一包糖就可以到达，将 $a[i]$ 设为 $cnt$ ，转移会用到。

统计答案：因为题目要求每种糖都要买到，所以最后状态的二进制肯定全为 $1$，一共有 $m$ 位，所以答案就是 $f[2^m - 1]$。如果最后答案是 $1\times 10 ^ 9$ 说明这个状态到达不了，输出无解 $-1$ 即可。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = (1 << 20) + 5; //二进制状态最多有 20 位，多开一点 

int n,m,k,f[N],a[N];

int main() {
	cin >> n >> m >> k;
	for(int i = 0;i<(1 << m);i++) f[i] = 1e9; //初始化 
	for(int i = 0;i<n;i++) {   //状压 dp 的题一般把 i 从 0 开始比较好写 
		int cnt = 0,x;
		for(int j = 0;j<k;j++) {
			cin >> x;
			cnt = cnt | (1 << (x - 1));  //计算当前这包糖的状态 
		}
		f[cnt] = 1;
		a[i] = cnt;
	}
	for(int i = 0;i<(1 << m);i++) {  //枚举每一个状态 
		for(int j = 0;j<n;j++) {  //枚举每一包糖 
			f[i|a[j]] = min(f[i|a[j]],f[i] + 1);  //转移 
		}
	}
	if(f[(1 << m) - 1] == 1e9) cout << -1;  //无解 
	else cout << f[(1 << m) - 1];  //用位运算表示更快 
	return 0;
}
```
点个赞再走吧！

---

## 作者：__KevinMZ__ (赞：2)

# [题解：P8687 \[蓝桥杯 2019 省 A\] 糖果](https://www.luogu.com.cn/problem/P8687)

## 感受

一道明显的状压 dp。

## 思路

设每包糖果状态 $t_i$（譬如说 $t_i=37=(100101)_2$ 时表示这包糖果只有 $1,3,6$ 三**种**糖果）

dp 三要素：

1. $dp_i$ 表示什么；
2. $dp_i$ 怎么转移（别人到自己或自己到别人）；
3. 循环顺序。

给出要素：

1. $dp_i$ 表示状态为 $i$ 时最少需要多少包糖果；
2. $dp_i$ 转移到 $1\le j\le n,j\in \Z$ 的 $dp_{i\operatorname{or}t_j}$；转移方程 $dp_{i\operatorname{or}t_j}\gets\min\{dp_{i\operatorname{or}t_j},dp_i+1\}$（选或不选）；
3. 先枚举 $i$ 再枚举 $j$。

好了，这下开始敲代码吧！

## 代码

```cpp
#include<bits/stdc++.h>
#define int __int128
#define ONLINE_JUDGE
using namespace std;
inline istream&operator>>(istream&is,int&k){
	int f=1;
	k=0;
	char ch=getchar();
	while(!isdigit(ch))(ch=='-'?f*=-1:f*=1),ch=getchar();
	while(isdigit(ch))k=(k<<3)+(k<<1),k+=ch-'0',ch=getchar();
	k*=f;
	return is;
}
inline ostream&operator<<(ostream&os,int k){
	if(k<0)putchar('-'),k*=-1;
	if(k>=10)os<<(k/10);
	putchar(k%10+'0');
	return os;
}
inline int qpow(int x,int y,const int mod=-1){int ans=1;while(y){if(y&1)ans*=x;x*=x;if(mod!=-1)ans%=mod,x%=mod;y>>=1;}return ans;}
//↑陋习，请勿学习↑
int n,m,k;
int dp[1<<20],t[100];//[0,i)省空间
signed main(){
#ifndef ONLINE_JUDGE
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	cin>>n>>m>>k;
	for(int i=0;i<(1<<m);i++)dp[i]=0x3f3f3f3f;
	for(int i=0;i<n;i++){
		for(int j=0;j<k;j++){
			int p;
			cin>>p;
			t[i]|=(1<<p-1);//一包糖果重复
			//p-1：二进制位0开始！
		}
		dp[t[i]]=1;
	}
	for(int i=0;i<(1<<m);i++){//枚举状态
		for(int j=0;j<n;j++){//枚举加的糖果包
			dp[i|t[j]]=min(dp[i|t[j]],dp[i]+1);//选或不选取最值
		}
	}
	cout<<(dp[(1<<m)-1]==0x3f3f3f3f?-1:dp[(1<<m)-1]);
	return 0;
}
/*
样例：
	输入：
	6 5 3
	1 1 2
	1 2 3
	1 1 3
	2 3 5
	5 4 2
	5 1 2
	输出：
	2
*/
```

---

## 作者：lijingshu_304775 (赞：1)

本题考虑使用状压 DP。

设糖果口味总数为 $m$，使用二进制数 $s \in \{0, 1\}^m$ 表示口味集合，其中第 $k$ 位为 $1$ 当且仅当该集合包含第 $k$ 种口味。

定义状态 $f(s)$ 为覆盖口味集合 $s$ 所需的最小糖果包数。初始条件为：

- $f(\emptyset) = 0$（空集不需要任何糖果包）

- $f(s) = +\infty$（对于所有非空集合 $s$）

状态转移方程：

对于每包糖果的口味集合 $a_i$（$1 \leq i \leq n$），遍历所有可能的状态 $s$，更新：

$$
f(s \cup a_i) = \min(f(s \cup a_i), f(s) + 1)
$$

可以得到如下代码：

```cpp
memset(f, 0x3f3f3f3f, sizeof(f));
f[0] = 0;
for (int i = 0; i < n; i++) {
    for (int s = 0; s < 1 << m; s++) {
        if (f[s] > 105) continue;
        f[s | a[i]] = min(f[s | a[i]], f[s] + 1);
    }
}
```

完整代码就不给了，希望这篇题解对你有所帮助。

---

## 作者：mumuxiao20111101 (赞：1)

# 题解：P8687 [蓝桥杯 2019 省 A] 糖果
### 题意
糖果店有 $M$ 种口味的糖果，每包糖果包含 $K$ 颗且口味已知。小明希望品尝所有口味，计算最少需要购买几包糖果。若无法实现，返回 $-1$。

### 思路
先用二进制位表示口味集合，最多 $20$ 种。然后将每包糖果的口味转换为二进制数。

然后，我们考虑动态规划  $dp_{st}$ 表示达到状态 $st$ 的最少包数。初始状态 $dp_0=0$，其余为无穷大。遍历所有状态，用每包糖果更新可达状态的最小包数。最后检查目标状态 $2^M-1$ 是否可达。

### 代码实现
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n, m, k;
int p[10000005];
int dp[10000005];
signed main(){
	memset(dp, 0x3f, sizeof dp);
	cin >> n >> m >> k;
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= k;j ++){
			int t;cin >> t;
			p[i] = p[i]|(1 << (t - 1));
		}
	}
	int maxst = (1 << m) - 1;
	dp[0] = 0;
	for(int st = 0;st <= maxst;st ++){
		for(int i = 1;i <= n;i ++){
			dp[st | p[i]] = min(dp[st | p[i]], dp[st] + 1);
		}
	}
	if(dp[maxst] != dp[10000004]){
		cout << dp[maxst];
		return 0;
	}
	cout << -1;
}
``````

---

## 作者：chenxinran12 (赞：1)

### 题意理解
给定 $N$ 个包糖果，每包里有 $K$ 个糖果，糖果编号为 $1$ 到 $M$。问一共需要多少包才能获得所有编号的糖果。
### 思路
一眼动态规划，用 $a_{i,j}$ 数组来模拟第 $i$ 包的第 $j$ 个糖果。  
考虑使用一个数组 $p$ 来模拟二进制。当我们输入 $a_{i,j}$ 时我们将 $p_i$ 二进制下的第 $a_{i,j}-1$ 位改为 $1$，代表这包拥有着 $a_{i,j}$，即二进制的哪一位为 $1$，这包就拥有这一位的糖果。  
在之后就是进行 dp。具体过程详见代码。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,dp[20000002],p[102],a[1002][1002];
int main()
{
	memset(dp,0x3f,sizeof dp);  //初始化 
	dp[0]=0;
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		for(int j=0;j<k;j++)
		{
			cin>>a[i][j];
			p[i]|=1<<(a[i][j]-1);
		}
	int mx=(1<<m)-1;  //在二进制下模拟各个情况，mx就是所有糖果都有的情况 
	for(int i=0;i<mx;i++)
		for(int j=1;j<=n;j++)
			dp[i|p[j]]=min(dp[i|p[j]],dp[i]+1);  //dp[i|p[j]]就是在原本情况为i下，变成i|p[j]的最小值(或保留原本) 
	if(dp[mx]!=dp[20000001]) cout<<dp[mx];   
	else cout<<-1;  //不可能全部拥有，输出-1 
	return 0;
}
```

---

## 作者：jiangyunuo (赞：0)

本蒟蒻在此之前没做过状态压缩动态规划，今日听教练讲了这题，特别写一篇题解。

本题意思大家都可以懂吧，所以今天我就从思路讲起。

### 第一思路：搜索
#### 想法：
对于买糖这件事，我们一时可能找不到合适的做法，因而，我们可以从暴力打起，使用搜索算法。

思路的话就是一包一包糖果去搜，每搜一包糖果就会有两种可能，买或者不买，同时我们用一个 `bool` 型数组 $vis$ 来表示购买状态，即 $vis_i=1$ 表示买第 $i$ 包糖果，$vis_i=0$ 表示不买第 $i$ 包糖果。

#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,t[105][25],ans=999; //ans 表示答案，初始化为 999，之后会记录最少购买的糖果包数。
bool vis[25],vis1[105][25];  //vis 数组见上文，vis1 数组是辅组数组，记录了对每一包糖果决策前 vis 的状态。
bool pd(){  //判断小明是否有 m 种口味的糖果。
	for(int i=1;i<=m;i++){
		if(!vis[i])return 0;
	}
	return 1;
}
void dfs(int x,int tot){  //x 表示当前决策的是第 x 包糖果，tot 表示到目前为止买的糖果包数。
	if(pd()){ans=min(ans,tot);return;}  //如果小明有 m 种口味的糖果，则记录答案。
	if(x>n)return;
	for(int i=1;i<=k;i++){   //见前文。
		vis1[x][t[x][i]]=vis[t[x][i]];
	}
	for(int i=1;i<=k;i++){   //见前文。
		vis[t[x][i]]=1;
	}
	dfs(x+1,tot+1);   //决定买下第 x 包糖果，接着向前搜索。
	for(int i=1;i<=k;i++){  //回溯。
		vis[t[x][i]]=vis1[x][t[x][i]];
	}
	dfs(x+1,tot);   //决定不买下第 x 包糖果，接着向前搜索。
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			cin>>t[i][j];
		}
	}
	dfs(1,0);
	if(ans!=999)cout<<ans<<endl;
	else cout<<-1<<endl;   //如果 ans 没变化，说明小明无法买到所有口味的糖果，因此输出 -1。
	return 0;
}
```
好消息：写出来了，没有逻辑错误。

坏消息：超时了。

[测评记录](https://www.luogu.com.cn/record/226576874)。

### 第二思路：动态规划
#### 确定算法
暴力好是好，就是太慢了，容易超时，所以我们应该另辟蹊径。

我们不难想到动态规划。要知道，动态规划有两个特性，分别是可推导性与无后效性。

可以发现，本体两个特性都可以满足。

1. 对于可推导性，我们知道了购买到哪几种口味的糖，我们就可以进一步向前推。就拿样例来说，一开始我们哪一种口味都没有，此时，我们的不需要购买任何一包糖，接着我们想知道购买到第一种口味的糖至少需要买几包糖，我们就可以推出来。已知没有购买到任何口味的糖不需要买任何一包糖，且第一包糖内包含了第一种口味的糖，所以我们想要购买到第一种口味的糖至少要买一包糖，可以证明，没有买更少包糖就可以获得第一种口味的糖的方法。

2. 对于无后效性，我们可以知道，我们购买到哪几种口味的糖，与购买其他几种口味的糖无关，也就是说，这个结论求出后不会被后面的结论影响。还是拿样例来说，我们求出我们想要购买到第一种口味的糖就至少要买一包糖，之后这个结论是不可能改变的，毕竟购买别的口味的糖与购买第一种口味的糖没有什么关系。

#### 设计状态

既然确定了使用动态规划来完成这一题，我们就要开始设计状态。

可是，新的问题又随之出现了，按照传统的方法，我们设计的状态就会出问题。

如[数字三角形](https://www.luogu.com.cn/problem/P1216)，我们设计的状态是这样的：$f_{i,j}$ 表示到达第 $i$ 行第 $j$ 列时我们获得的最大权值，这种方法就是通过位置来设计状态。再比如说[采药](https://www.luogu.com.cn/problem/P1048)，我们设计的状态是：$f_{i,j}$ 表示前 $i$ 个物品在背包容量为 $j$ 的情况下能获得的最大价值，这种方法就是通过容量与物品来设计状态。再再比如说[石子合并](https://www.luogu.com.cn/problem/P1775)，我们设计的状态是：$f_{i,j}$ 表示合并第 $i$ 个到第 $j$ 个石子所需的最小代价，这种方法就是通过区间来设计状态。

可以发现，前面举的几个例子状态都很简短，并且十分清晰，很好理解。但是，如果我们还是按着这种想法设计状态，那我们的状态就会很奇怪：一个 $n$ 维数组，第 $i$ 位是 $1$ 表示购买第 $i$ 种口味的糖，反之亦然，这个数组的值表示在上述的情况下，所需要买的最少糖果包数。可问题又出现了，在数据大的情况下，这个数组就有很多维，这样麻烦不说，还特别容易错，对我们并不友好，所以我们需要换一种思路。

我们注意到，这个数组的每一维下标是 $0$ 或者 $1$，大家有没有联想到什么？

作为 OIer，我们肯定都知道二进制（你可能会问，那刚入门的不知道怎么办，那我只能说，那就不做这题，先把g基础打好，毕竟连基础都没打结实，学再多都没用），一个二进制串就是由 $0$ 和 $1$ 组成的，而且二进制和十进制是可以互相转换的。

照这样说，我们就可以把数组的这么多维看成一个二进制数，然后将这个数给转化为十进制，这样，就可以成功把压缩状态成一维。根据数据，我们确实可以实现这一点，$m \le 20$，所以，原本的数组最多最多只有二十维，看成二进制后最大为 $11111111111111111111$，并且这个数转化为十进制后不超过 $2 \times 10^6$，数组开的下，并且我们每一种情况都有它在数组中对应的结果，所以这种方法有效。

当然，在这样的情况下，我们还需要对糖果进行操作，我们已知前面设计的状态在二进制的情况下每一位都是表示一种口味的购买情况，所以我们可以给糖果制订新的编号。我们都知道，二进制数第 $i$ 位表示的数为 $2^{i-1}$ ，同样的，第 $i$ 种口味的糖果我们就给它编号为 $2^{i-1}$。

举一个使用例子，$5$ 的二进制是 $101$，也就是二进制的 $100+1$，化成十进制 $4+1$，也就是购买第 $1$ 和第 $3$ 种糖果。

补充一下，这种将状态从二进制的形式压缩成十进制的动态规划就是大名鼎鼎的状态压缩动态规划，并且这种动态规划的题目普遍数据比较小。

#### 状态转移
状态设计好了，接下来就是考虑转移了。

就这么说吧，比方说，我们已知 $f_5=1$（即获得第一种口味和第三种口味的糖需要买一包糖），又有一包糖，里面有第二种和第三种口味的糖，化成二进制，是这样的，状态：$f_{101}=1$，糖的二进制编号：$110$，很显然，我们最终所获得的是第一到第三种口味的糖，二进制表示为 $111$。由此可见，我们转移的状态并不是已知状态简单加上糖果编号得到的，而是根据它们的二进制位，如果已知状态或糖果编号在二进制的第 $i$ 位为 $1$ 则新得到的状态第 $i$ 位也为 $1$，这点我们不难想到，毕竟一种口味的糖我们要想的是有还是没有，而不是有多少个。

对于这样的方法，判断转移的结果就特别了，我们如果一位一位判断过去也太不方便了，有没有更简单的方法？

我可以告诉你，有的，兄弟有的。我们在这一题谈到了二进制与十进制，关于二进制，有一个知识点——位运算。位运算中的或运算可以帮我们解决这个难题，或运算也是同样的原理，因此很好处理。

对于转移，一般有两种方法：

1. 填表法，通过前面得出的结果，确定目前的结果。
2. 刷表法，通过目前已知的结果，推出后面的结果。

显然，这里并不适合使用填表法，因为使用了或运算，我们难以知道前一个状态是什么，所以填表法不好用。但是刷表法好用，我们知道当前状态，也就可以知道买了一包新糖后的状态，相比填表法，会好写的多。

综上所述，我们可以推导出状态转移方程：`s[i|t[j]]=min(s[i|t[j]],s[i]+1);`（数组 $t_j$ 表示第 $j$ 包糖果的编号。$s_i$ 表示当前已知状态）。

#### 初始化问题
对于表示状态的 $f$ 数组，我们从它的意义入手。我们，都知道，它表示的是买糖的最少包数，因此，我们可以一开始给它总体赋值一个超大的数，如 $999$（话说也就最多 $100$ 包糖，这已经够了）。

接着，给 $f_0$ 赋值为 $0$，毕竟你不买任何一包糖的时候你才会一种口味的糖都没有。

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a,k,t[105],s[2000000];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			cin>>a;
			a=1<<(a-1);
			t[i]=t[i]|a;
		}
	}
	m=(1<<m)-1;
	for(int i=1;i<=m;i++){
		s[i]=999;
	}
	for(int i=0;i<=m;i++){
		for(int j=1;j<=n;j++){
			s[i|t[j]]=min(s[i|t[j]],s[i]+1);
		}
	}
	if(s[m]!=999)cout<<s[m]<<endl;
	else cout<<-1<<endl;
	return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/226559903)

---

## 作者：lichengze123456 (赞：0)

# 题解 P8687 [蓝桥杯 2019 省 A] 糖果

### 题目分析
这道题需要使用状压动态规划来解决。由于糖果种类很少，最多只有 $20$ 种，我们可以用二进制位来表示口味的不同类型，也就是状压 dp。

### 解题思路
1. 将每包糖果的口味集合用二进制数表示。
2. $dp_i$ 表示达到 $i$ 状态所需的最少包数。
3. 除了 $dp_0$ 之外所有的数组初始化赋值为极大值。
4. 遍历所有状态，用每包糖果更新可能的新状态。
5. 最终答案为 $dp_{m\times2-1}$，即收集所有口味的最少包数。

## 代码
```cpp
#include<bits/stdc++.h>
#include <cstring>
#include <map>
using namespace std;
int n,m,k,x,s[1000],dp[2000000];
map<int, bool> ma;
int main(){
    cin>>n>>m>>k;
    for(int i=0;i<n;i++){
        for(int j=0;j<k;j++){
            cin>>x;
            ma[x]=1;
            s[i]|=(1<<(x-1));
        }
    }
    for(int i=1;i<=m;i++){
        if(ma[i]==0){
            cout<<-1;
            return 0;
        }
    }
    memset(dp, 0x3f, sizeof(dp));
    dp[0]=0;
    for(int i=0;i<=(1<<m)-1;i++){
        for(int j=0;j<n;j++){
            dp[i|s[j]]=min(dp[i|s[j]],dp[i]+1);
        }
    }
    cout<<dp[(1<<m)-1];
    return 0;
}

---


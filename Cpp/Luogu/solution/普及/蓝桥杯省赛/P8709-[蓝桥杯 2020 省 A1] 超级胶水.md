# [蓝桥杯 2020 省 A1] 超级胶水

## 题目描述

小明有 $n$ 颗石子，按顺序摆成一排，他准备用胶水将这些石子粘在一起。
 
每颗石子有自己的重量，如果将两颗石子粘在一起，将合并成一颗新的石子，重量是这两颗石子的重量之和。

为了保证石子粘贴牢固，粘贴两颗石子所需要的胶水与两颗石子的重量乘积成正比，本题不考虑物理单位，认为所需要的胶水在数值上等于两颗石子重量的乘积。

每次合并，小明只能合并位置相邻的两颗石子，并将合并出的新石子放在原来的位置。

现在，小明想用最少的胶水将所有石子粘在一起，请帮助小明计算最少需要多少胶水。

## 说明/提示

对于 $20\%$ 的评测用例，$1 \le n \le 15$。

对于 $60\%$ 的评测用例，$1\leq n \leq 100$。

对于 $80\%$ 的评测用例，$1\leq n \leq 1000$。

对于所有评测用例，$1\leq n \leq 10^5$，$1 \leq w_i \leq 1000$。

蓝桥杯 2020 第一轮省赛 A 组 I 题。

## 样例 #1

### 输入

```
3
3 4 5```

### 输出

```
47```

## 样例 #2

### 输入

```
8
1 5 2 6 3 7 4 8```

### 输出

```
546```

# 题解

## 作者：andyli (赞：21)

对于三颗石子 $a, b, c$，先合并 $a, b$ 再与 $c$ 合并的代价为 $ab+c(a+b)=ab+bc+ca$，于是发现与合并的顺序无关。  
进一步，对于四颗石子 $a, b, c, d$ 先分别合并 $a, b$ 再依次与 $c$ 和 $d$ 合并的代价为 $ab+bc+ca+(a+b+c)d = ab+bc+cd+da+ac+bd$，也与顺序无关。  
这样，答案为
$$ \sum\limits_{i=2}^n a_i\cdot\sum\limits_{j=1}^{i-1} a_j$$
因此扫描一遍即可。注意使用 long long。  

```cpp
int main() {
    dR(int, n);
    std::vector<i64> a(n);
    io.readArray(a);
    i64 ans = 0;
    for (int i = 0; i + 1 < n; i++)
        ans += a[i] * a[i + 1], a[i + 1] += a[i];
    writeln(ans);
    return 0;
}
```

---

## 作者：Zaku (赞：4)

[题目](https://www.luogu.com.cn/problem/P8709)

找规律+前缀和优化。

可以证明出每一种合成的方案得到的最终值都是相同的。
- 两块石头：$ab = ab$
- 三块石头：$ab + (a + b)\times c = a(b + c) + bc$
- 四块石头：$ab + (a + b)c + (a + b + c)\times d = a(b + c + d) + b(c + d) + cd$
- $k$ 块石头：$a_1\times a_2 + (a_1+a_2)\times a_3 + \dots + (a_1 + a_2 + a_3 +\dots + a_{k-1})\times a_k= a_1(a_2+a_3+\dots +a_k)+a_2(a_3+a_4+\dots +a_k)+\dots +a_{k-1}\times a_k$

以此类推，求出每个数分别与后面的所有数相乘之和即可。

文字说明：

每两个石子都相互会被合并一次（不重复），每次合并后所需要的胶水量都为两石子之间的乘积。只不过，对于一块石子，其他石子（可能是多个石子的整体）与之合并，可以看做组成其他石子的单个石子与之合并后取和。

显而易见的，我们可以维护一个前缀和求得数列的连加，把时间复杂度降到 $\Theta(n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
typedef long long LL;
using namespace std;
const int N = 1e5+10;
LL a[N],s[N];
int main(){
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);
        s[i]=a[i]+s[i-1];
    }//存储数组及其前缀和，不解释 
    LL ans=0;
    for(int i=1;i<n;i++)
        ans+=a[i]*(s[n]-s[i]);//ans加上a[i]与后面的所有数之和相乘的积 
    cout<<ans;
    return 0;
}
```

---

## 作者：Ggsddu_zzy (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P8709)

[更好的阅读体验](https://www.cnblogs.com/zzyblog0619/p/17153720.html)



#### 题目大意

有 $n$ 个石子，两颗石子的重量之和就是并成的一颗新石子的重量，合并两个石子需要的胶水等于两颗石子重量的乘积。

#### 解题思路

如果一个石子的重量为 $i$，另一个石子的重量为 $j$，那么两个石子粘在一起所用的胶水就是 $i\times j$；合并后石子的重量就是 $i+j$。

所以可以先将 $sum$ 赋为第一个石子的重量，之后从 $2\sim n$ 模拟粘石子的过程：

- $sum$ 每次乘上第 $i$ 颗石子的重量，也就是胶水的数量。

- 再将 $sum$ 每次加上第 $i$ 颗石子的重量，也就是合并后的石子重量。

即 $sum=\sum\limits_{i=2}^nw_i,ans=\sum\limits_{i=2}^nw_i\times sum$。

最后输出胶水的数量即可。

#### 代码

[AC 记录](https://www.luogu.com.cn/record/102912218)

```c++
#include<bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;
ll n,w[100005],sum,ans=0;
int main() {
	cin>>n;
	for(ri i=1;i<=n;i++)
		cin>>w[i];
	int sum=w[1];
	for(ri i=2;i<=n;i++){
		ans+=sum*w[i];
		sum+=w[i];
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：卡帕瓦_KAPawa (赞：3)

## 一.题目链接

[P8709 [蓝桥杯 2020 省 A1] 超级胶水](https://www.luogu.com.cn/problem/P8709)

## 二.思路分析

我们定义一个集合 $G$，集合中每个元素都是已经参与合并的一颗石子的重量。

我们设最后一步操作时合并的两个集合为 $G_a,G_b$，那么容易证明 $G_a \cap G_b = \varnothing$ 且 $G_a \cup G_b = G_n$。其中，$G_n$ 表示最终的那颗石子。

若把 $G_b$ 的元素按 $1\sim m$ 编号，那么最后一次合并中，$G_a$ 的每个元素 $G_{a_i}$ 对于答案的贡献为

$$$
\sum_{j=1}^{m} G_{a_i} \times G_{b_j}
$$$

那么对于倒数第二次、倒数第三次、倒数第四次......次操作，每颗石子 $a_i$ 对于答案的贡献就是 $a_i\times \sum w$。其中，$w$ 指其他石子的重量总和。

所以答案就是

$$$
\sum_{i=1}^{n} \sum_{j=i+1}^{n} a_i\times a_j
$$$

容易发现答案和顺序无关，所以直接按 $1\sim n$ 的顺序合并，再按题意模拟即可。

### 三.代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll N=1e5+10;

char buf[50*1000100],*p1(0),*p2(0);
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1500004, stdin), p1 == p2) ? EOF : *p1++)

template<typename T>inline void read(T&x){
	
	x=0;
	char c;
	bool f=0;
	
	do{
		
		c=gc();
		if(c=='-') f=1;
	}while(c<'0');
	
	do{
		
		x=(x<<3)+(x<<1)+c-'0';
		c=gc();
	}while(c>='0');
	
	if(f) x=~x+1;
}

ll n,a[N],ans;

int main(){
	
	read(n);
	for(int i=1;i<=n;i++) read(a[i]);
	
	for(int i=2;i<=n;i++){
		
		ans+=a[i]*a[i-1];
		a[i]+=a[i-1];
	}
	
	printf("%lld\n",ans);
	
	return 0;
}
```

---

## 作者：Zenn (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P8709)
## 题目大意
有 $n$ 个石子，每两颗石子的**重量之和一定**就是合并成的一颗新石子的重量，合并两个石子需要的胶水等同于**两颗石子重量的乘积**。
## 思路
这个题是经典的“超级胶水”问题，可以用**前缀和优化**来解决这道题目。
## 关键点
通过数学验证，可以得出：无论怎样合并顺序，总胶水量**一定等于**所有石子两两乘积之和。总胶水量就等于：

$$
\sum_{1 \le i,j \le n}{} {W_i} \times {W_j} 
$$

所以证明我们的算法是正确的。
## 验证
可以从题目中给出的样例来验证：
```cpp
输入：
3
3 4 5
```
先初始化 `res` 和 `cur`。

再处理第一个石子：

```cpp
sum1+=0*3=0（sum1保持0）
sum2+=3
所以此时：cur=3
```

再处理第二个石子：

```cpp
sum1+=3*4=12（sum1=12）
sum2+=4
所以此时：sum2=7
```

再处理第三个石子：

```cpp
sum1+=7*5=35（sum1=47）
sum2+=5
所以此时：sum2=12
```

再将所有石子相乘并相加：

```cpp
3*4=12
3*5=15
4*5=20
总和：12+15+20=47
```

最后输出结果 $47$。

---
最后放上你们最喜欢的代码：
```cpp
//abcdefghigklmnopqrstuvwxyz 
#include<bits/stdc++.h>//综合头文件 
using namespace std;
#define ll long long
//typedef long long ll;
const int N=1e5+10;
int n,aaa[N];
int main(){
	ios::sync_with_stdio(false);//加速输入输出 
    cin.tie(nullptr);
    cin>>n;
    for(int i=0;i<n;i++) cin>>aaa[i];
    ll sum1=0,sum2=0;
    for(int i=0;i<n;i++){
        sum1+=sum2*aaa[i];// 累加当前元素与前缀和的乘积
        sum2+=aaa[i];//更新前缀和
    }
    cout<<sum1<<endl;
    return 0;
}
```
欢迎指出错误！

---

## 作者：fish_love_cat (赞：1)

看到 Ad-hoc 于是开始乱想，然后秒了？

---

模拟每个合并的过程，加点的代价用分配律拆开，容易发现是一样的。

推广这个结论，于是就得到合并顺序与答案无关。

没看懂什么前缀和优化，直接大力模拟就可以做到线性合并。于是做完了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int ans,sum;
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        ans+=sum*x;
        sum+=x;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Fennec (赞：0)

这道题主要考察对合并问题的数学分析和优化能力。将 $n$ 个石子排成一排，通过合并相邻石子将所有的站在一起，所消耗的胶水为两石子重量的乘积。

通过数学推导可以发现，无论以何种顺序合并相邻石子，最终的总胶水消耗量都是相同的，等于所有石子两两重量乘积的总和‌。我们运用前缀和优化，可以进行验证。

我们用题目给出的其中一个样例来验证：

  

     输入： 3 3 4 5
     总胶水量 = 34 + 35 + 4 * 5 = 12 + 15 + 20 = 47
所以证明我们的算法是对的。

最后放出大家最爱的[AC Code](https://www.luogu.com.cn/record/223799342)：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 114514;
int n , a[N] , sum[N] , ans;
signed main () {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1;i <= n;i ++)
		cin >> a[i];
	for (int i = 1;i <= n;i ++){
		sum[i] = sum[i - 1] + a[i];
		ans += a[i] * sum[i - 1]; 
	}
	cout << ans;
	return 0;
}
```

---

## 作者：wuhan1234 (赞：0)

## 1. 编程思路。

设有 $w_1$、$w_2$、$w_3$、$w_4$ 这 $4$ 块石头合并在一起，可以选择的合并方案有 $8$ 种，以如下 $4$ 种为例进行说明：

1）$w_1$ 和 $w_2$ 先合并，再与 $w_3$ 合并，最后与 $w_4$ 合并。其需要的胶水量为 $w_1\times w_2+(w_1+w_2)\times w_3 +(w_1+w_2+w_3)\times w_4$。

2）$w_1$ 和 $w_2$ 先合并，再 $w_3$ 和 $w_4$ 合并，最后合并的两者再合并。需要的胶水量为 

$w_1\times w_2+w_3\times w_4+(w_1+w_2)\times (w_3 +w_4)$

$=w_1\times w_2+w_1\times w_3+w_2\times w_3+w_1\times w_4+w_2\times w_4+w_3\times w_4$

$=w_1\times w_2+(w_1+w_2)\times w_3 +(w_1+w_2+w_3)\times w_4$

3）$w_2$ 和 $w_3$ 先合并，再与 $w_1$ 合并，最后与 $w_4$ 合并。其需要的胶水量为

$w_2\times w_3+(w_2+w_3)\times w_1 +(w_1+w_2+w_3)\times w_4$

$=w_1\times w_2+(w_1+w_2)\times w_3 +(w_1+w_2+w_3)\times w_4$。

4）$w_3$ 和 $w_4$ 先合并，再与 $w_1$ 合并，最后与 $w_2$ 合并。其需要的胶水量为

$w_3\times w_4+(w_3+w_4)\times w_1 +(w_1+w_3+w_4)\times w_2$

$=w_1\times w_2+(w_1+w_2)\times w_3 +(w_1+w_2+w_3)\times w_4$。

由此可见，合并的顺序与最后需要的胶水量无关。若按从前到后的顺序进行合并，每次都是加上当前石头的重量与其前面所有石子重量和的乘积。

前缀和的一个简单应用而已。

2. 源程序。
```c
#include <stdio.h>
#include <string.h>
int main()
{
    int n;
    scanf("%d",&n);
    long long ans=0,sum=0;
    int i;
    for (i=1; i<=n;i++)
    {
        long long a;
        scanf("%lld",&a);
        ans+=sum*a;
        sum+=a;       // 前缀和
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：CRH_Beijingzhan (赞：0)

[P8709 [蓝桥杯 2020 省 A1] 超级胶水 题解](https://www.luogu.com.cn/problem/P8709)

### 解题思路

首先，将所有石子重量读入，存入一个最小堆（优先队列）中。优先队列的特性是每次取出的都是队列中最小的元素。

然后，利用贪心算法，每次都选择最小的两个石子进行粘合，这样可以保证所需的胶水最少。每次从优先队列中取出最小的两个石子，将这两个石子粘在一起，形成一个新的石子，新石子的重量是这两颗石子重量之和，所需的胶水是这两颗石子的重量之积。将新石子的重量再次放入优先队列中，同时将所需胶水累加到总胶水量中。

重复以上步骤，直到优先队列只剩下一颗石子，这时候所有的石子都已经粘在一起，总胶水量即为所求。

### CODE


```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define ASUTHOR "HEX9CF"
#define ll long long
const int N=1e5+50;
const int INF=0x3f3f3f3f;
const ll MOD=1e9+90;
int n;
priority_queue<ll,vector<ll>,greater<ll> > hmin;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	while(n--){
		int t;
		cin>>t;
		hmin.push(t);
	}ll ans=0;
	while(hmin.size()>1){
		ll a=hmin.top();
		hmin.pop();
		ll b=hmin.top();
		hmin.pop();
		ll c=a+b;
		ans+=a*b;
		hmin.push(c);
	}cout<<ans<<endl;
	return 0;
}
```

---


# [蓝桥杯 2022 省 B] 积木画

## 题目描述

小明最近迷上了积木画，有这么两种类型的积木，分别为 $I$ 型（大小为 $2$ 个单位面积) 和 $L$ 型 (大小为 $3$ 个单位面积):

![I 型积木](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_3d61ad9326a0012c9fdag-10.jpg)

同时，小明有一块面积大小为 $2 \times N$ 的画布，画布由 $2 \times N$ 个 $1 \times 1$ 区域构成。小明需要用以上两种积木将画布拼满，他想知道总共有多少种不同的方式? 积木可以任意旋转，且画布的方向固定。

## 说明/提示

**【样例说明】**

五种情况如下图所示, 颜色只是为了标识不同的积木:
![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_3d61ad9326a0012c9fdag-11.jpg)

**【评测用例规模与约定】**

对于所有测试用例，$1 \leq N \leq 10^7$。

蓝桥杯 2022 省赛 B 组 G 题。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

# 题解

## 作者：Infinite_Eternity (赞：79)

# Description

[P8784 [蓝桥杯 2022 省 B] 积木画](https://www.luogu.com.cn/problem/P8784)

用 $\text{I}$ 型积木（大小为 $2$ 个单位面积）和 $\text{L}$ 型积木（大小为 $3$ 个单位面积）填充 $2 \times n$ 的画布（积木可以任意旋转）。求出不重复方案数，结果对 $10^9+7$ 取模。

![](https://cdn.luogu.com.cn/upload/image_hosting/tgk6lo7r.png#pic_center)

数据范围：$1 \leq n \leq 10^7$。

# Analysis


首先，我们定义 $F_n$ 为填满 $2\times n$ 画布的方案总数，边界条件：

- $F_0 = 1$，表示无需再填；
- $F_k(k<0)$，表示无意义情况。

考虑最后放的情况：

1. 放 $1$ 个 $\text{I}$ 型积木（竖放）：方案数为 $F_{n-1}$；（如 $\small\text{图1}$）

2. 放 $2$ 个 $\text{I}$ 型积木（横放）：方案数为 $F_{n-2}$；（如 $\small\text{图2}$）

3. 放 $1$ 个 $\text{L}$ 型积木（因为该积木可以翻转着放，所以这样放的总方案数要 **乘 $2$** ）：然而，这么填会突出 $1$ 个格子，如何消去这个突出？

   - 再放 $1$ 个 $\text{L}$ 型积木，恰好消去突出，方案数 $F_{n-3}$；（如 $\small\text{图3\,-\,1}$）
   - 横放 $1$ 个 $\text{I}$ 型积木，再放 $\text{L}$ 型积木，方案数 $F_{n-4}$；（如 $\small\text{图3\,-\,2}$）
   - $\text{I}$ 型积木可以交替着放下去，再补上一个 $\text{L}$ 型积木，从而消去这个突出。
   - 直到 $\text{I}$ 型积木和 $\text{L}$ 型积木恰好填满画布（$F_0$）。
   
![](https://cdn.luogu.com.cn/upload/image_hosting/mtp8s553.png#pic_center)

   综上，最后放 $1$ 个 $\text{L}$ 型积木得到的方案数为 $2\times (F_{n-3}+F_{n-4}+\cdots+F_{0})$。

综合 $3$ 种情况，得：

$$F_n=\left(\sum_{i=0}^{n-1}F_i\right)+\left(\sum_{i=0}^{n-3}F_i \right)$$

我们令 $n=k$，得：

$$F_k=\left(\sum_{i=0}^{k-1}F_i\right)+\left(\sum_{i=0}^{k-3}F_i \right) =F_{k-1}+F_{k-2}+2\cdot F_{k-3} +2\cdot \left(\sum_{i=0}^{k-4}F_i \right)$$

再令 $n=k-1$，得：

$$F_{k-1} = \left(\sum_{i=0}^{k-2}F_i\right)+\left(\sum_{i=0}^{k-4}F_i \right) = F_{k-2}+F_{k-3}+2\cdot \left(\sum_{i=0}^{k-4}F_i \right)$$

上式减去下式，得：

$$F_k - F_{k-1} = F_{k-1}+F_{k-3}$$

移项得：

$$F_k = 2\cdot F_{k-1}+F_{k-3}$$

于是化简得：

$$F_n=\left(\sum_{i=0}^{n-1}F_i\right)+\left(\sum_{i=0}^{n-3}F_i \right)=2\cdot F_{n-1}+F_{n-3}$$

# Code

```cpp
#include <stdio.h>
const int mod = 1e9+7,N = 1e7;
int main()
{
    int f[N]={0,1,2,5};
    int n;
    scanf("%d",&n);
    for(int i=4;i<=n;++i)
        f[i] = (2*f[i-1]%mod+f[i-3]%mod)%mod;
    printf("%d",f[n]);
    return 0;
}
```

---

## 作者：pxb0801 (赞：36)

[题目传送门](https://www.luogu.com.cn/problem/P8784)

-----------------
## 1.分析：

这道题是一道 dp 题，$n$ 的范围高达 $10^7$，所以时间复杂度只有一种：$O(n)$。

我们可以这样想，一个积木放上去后，可能会出现三种情况：第一行比第二行多出一个积木；两行积木数相等；第二行比第一行多出一个积木。

这时候有同学可能会问：为什么最多就多出一个积木呢？

因为最后的答案一定是两行积木数相等，如果两行差的多了，就不能用 L 型积木填补。只用 I 型积木填补的话，只能横着填补，我们完全可以在之前相差不超过 $1$ 时就用 I 型积木横着填补。

所以，状态定义就是：```int f[10000005][3]```。**注意：这里的 ```f[i][0]``` 和 ```f[i][2]``` 表示更长的一列的长度为 $i$。**

-----------------
接下来就是动态转移方程了。

如果第一行比第二行多出一个积木，也就是状态 ```f[i][0]```。此时我们可以用一个 I 型积木在第一行横向填补，这样在填补前第二行就会多出一个积木，也就是 ```f[i-1][2]```；也可以用一个 L 型积木填补第 $i$ 列和 $i-1$ 列，这样填补前两行积木数就相等，也就是 ```f[i-2][1]```。

如果第二行比第一行多出一个积木，也就是状态 ```f[i][2]```。此时与上一种情况类似，也是两种方案，分别是用一个 I 型积木在第二行横向填补和用一个 L 型积木进行填补。分别是 ```f[i-1][0]``` 和 ```f[i-2][1]```。

最后，也是最复杂的一种情况，就是两行积木数相等，即状态 ```f[i][1]```。此时有 $4$ 种情况。我们可以用两个 I 型积木横向填补第 $i$ 列和第 $i-1$ 列，就是 ```f[i-2][1]```；可以用一个 I 型积木纵向填补第 $i$ 列，也就是 ```f[i-1][1]```；可以用一个 L 型积木填补第 $i$ 列和第 $i-1$ 列的第一行，也就是 ```f[i-1][2]```；还可以用一个 L 型积木填补第 $i$ 列和第 $i-1$ 列的第二行，也就是 ```f[i-1][0]```。

**温馨提示：这一部分可能不是很好懂，同学们可以画个图帮助理解。**

--------------

初始化就很简单了，即一列都没有，两行积木数都为 $0$ 也就是积木数相等的情况有 $1$ 种，也就是 ```f[0][1]=1```。

输出也很简单，就是前 $n$ 列，两行积木数相等的情况数。

--------------
## 2.AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,f[10000005][3];
int main(){
	cin>>n;
	f[0][1]=1;
	for(int i=1;i<=n;i++){
		f[i][0]=(f[i-2][1]+f[i-1][2])%mod;
		f[i][1]=((f[i-2][1]+f[i-1][1])%mod+(f[i-1][0]+f[i-1][2])%mod)%mod;//两两相加就取模，防止超出int
		f[i][2]=(f[i-2][1]+f[i-1][0])%mod;
	}
	cout<<f[n][1];
	return 0;
}
```

---

## 作者：WA_sir (赞：30)

## [题目链接](https://www.luogu.com.cn/problem/P8784)

这道题和斐波那契数列有些类似，若只有 I 型积木，那么：$f[i]=f[i-1]+f[i-2]$。

但这道题还加入了 L 型积木，说明应该在斐波那契数列原有的基础上进行修改。

我们可以在表里找一下规律：

| $i$ | $ans$ |
| :---- | :---- |
| $0$| $1$ |
| $1$ | $1$ |
| $2$ | $2$ |
| $3$ | $5$ |
| $4$ | $11$ |
| $5$ | $24$ |
| $6$ | $53$ |
| $7$ | $117$ |
| $...$| $...$| |

拿 $i=4$ 来说，只计算 I 型积木，共 $f[i-1]+f[i-2]=7$ 种方法。此时，还缺少 $11-7=4$ 种方法。而 $4$ 正好是 $f[i-2]$、$f[i-3]$、$f[i-4]$ 之和。因为这个规律也适用于求当 $i$ 是 $5$，$6$，$7$ 时的方法数。所以可以推出式子：

$f[i]=f[i-1]+f[i-2]\times2+f[i-3]+f[i-4]$

这里我们再**根据式子**来列一个**推出答案**的表，进行检验：

| $i$ | $f[i-1]+f[i-2]$ | $f[i-2]+f[i-3]+f[i-4]$ | $ans$ |
|:--- | :--- | :--- | :--- |
| $4$ | $2+5=7$ | $1+1+2=4$ | $11$ |
| $5$ | $5+11=16$ | $1+2+5=8$ | $24$ |
| $6$ | $11+24=35$ | $2+5+11=18$ | $53$|
| $7$ | $24+53=77$ | $5+11+24=30$ | $117$|
| $...$ | $...$ | $...$ | $...$ | |

另外，还要注意以下几点：

1. 千万不要忘了模！！！

1. 由于下标最小为 $0$，循环应该从 $4$ 开始。

1. 初始化。

## 参考代码如下：

```cpp
#include<bits/stdc++.h>
const int N=10000005,m=1000000007;
int n,f[N];
using namespace std;
int main()
{
	scanf("%d",&n);
	f[0]=1;f[1]=1;f[2]=2;f[3]=5;
	for(int i=4;i<=n;i++)
		f[i]=(((f[i-1]+(f[i-2]*2)%m)%m+f[i-3])%m+f[i-4])%m;
	printf("%d",f[n]%m);
	return 0;
}
```

感谢阅读！ QAQ

---

## 作者：what_can_I_do (赞：7)

[传送门](https://www.luogu.com.cn/problem/P8784)

既然这倒是递推，那就先找规律吧。    
我们先列一下答案：    
```
n ans
0 1
1 1
2 2
3 5
4 11
5 24
```    
我们只要看一会儿这个答案，就会发现第 $3$ 项的 $5$ 等于第 $2$ 项的 $2$ 乘上 $2$，再加上 $1$，第 $4$ 项的 $11$ 也等于前一项乘 $2$ 加 $1$，但这个规律再第 $5$ 项时就用不了了,。此时我们转变一下思路，把第 $3$ 项等于第 $2$ 项乘 $2$ 再加 $1$ 看成第 $2$ 项的数乘 $2$ 再加上第 $3-3$ 项的数，就能发现这样子就能使第 $5$ 项也符合规律了。

规律：第 $i$ 个数的答案为第 $i-1$ 个数答案乘 $2$，再加上第 $i-3$ 个数的答案。

递推式：$dp_i=dp_{i-1}\times 2+dp_{i-3}$

记住，要模模数，并开 long long。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[10000010]={0},n,mod=1e9+7;
int main()
{
	scanf("%lld",&n);
	dp[0]=1,dp[1]=1,dp[2]=2;
	for(register int i=3;i<=n;i++) dp[i]=dp[i-1]*2+dp[i-3],dp[i]%=mod;
	printf("%lld",dp[n]);
	return 0;
}
```

---

## 作者：gesong1234 (赞：2)

题目传送门：[P8784 [蓝桥杯 2022 省 B] 积木画](https://www.luogu.com.cn/problem/P8784)
# 思路
其实这道题就是 **dp**。

状态表示：$f_i$ 表示 $N=i$ 时的方案数。

状态转移：

我们想 $I$ 型积木开始，这个积木可以放在头和尾，所有方案数是 $2\times f_{i-1}$。

再从 $L$ 积木下手，我们可以把
```
1223
1123
```
作为一个整体，于是方案数就是 $f_{i-3}$，注意这里不用乘 $2$，因为，如果放在尾巴和尾巴放 $I$ 型积木，是一样的。

综上所述，方程就是 $f_i=2\times f_{i-1}+f_{i-3}$。

由于这里 $1\le N\le 10^7$ 不能开数组，所以只能用**滚动数组**了，具体看代码。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
main(){
	int n;
	cin>>n;
	int a=1,b=2,c=5,d;
	if (n==1){//特判
		cout <<1;
		return 0;
	}
	if (n==2){
		cout <<2;
		return 0;
	}
	if (n==3){
		cout <<5;
		return 0;
	}
	for (int i=4;i<=n;i++) //dp过程
    	d=c*2%mod+a,a=b,b=c,c=d,a%=mod,b%=mod,c%=mod,d%=mod;
	cout <<d;
	return 0;
}
```


---


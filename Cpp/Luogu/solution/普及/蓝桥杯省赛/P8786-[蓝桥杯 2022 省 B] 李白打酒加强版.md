# [蓝桥杯 2022 省 B] 李白打酒加强版

## 题目描述

话说大诗人李白，一生好饮。幸好他从不开车。

一天，他提着酒壶，从家里出来，酒壶中有酒 $2$ 斗。他边走边唱：

> 无事街上走，提壶去打酒。  
> 逢店加一倍，遇花喝一斗。

这一路上，他一共遇到店 $N$ 次，遇到花 $M$ 次。已知最后一次遇到的是花，他正好把酒喝光了。

请你计算李白这一路遇到店和花的顺序，有多少种不同的可能?

注意：壶里没酒（$0$ 斗）时遇店是合法的，加倍后还是没酒；但是没酒时遇花是不合法的。

## 说明/提示

**【样例说明】**

如果我们用 `0` 代表遇到花，`1` 代表遇到店，$14$ 种顺序如下: 

```plain
010101101000000
010110010010000
011000110010000
100010110010000
011001000110000
100011000110000
100100010110000
010110100000100
011001001000100
100011001000100
100100011000100
011010000010100
100100100010100
101000001010100
```

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例：$1 \leq N, M \leq 10$。

对于 $100 \%$ 的评测用例：$1 \leq N, M \leq 100$。 

蓝桥杯 2022 省赛 B 组 I 题。

## 样例 #1

### 输入

```
5 10```

### 输出

```
14```

# 题解

## 作者：Xy_top (赞：52)

看到都是顺次转移的动态规划，我来写一个贡献转移。

设 $f[i][j][k]$ 为当前走到第 $i$ 个位置，看了 $j$ 次花，有 $k$ 斗酒的方案数。

题目中说了初始两斗酒，那么 $f[0][0][2]=1$。

重点是怎么前推后，依次循环 $i$，$j$，$k$，

如果 $f[i][j][k]$ 不是 $0$，那么我们在第 $i+1$ 个位置看花或者经过酒店。

看花：走到第 $i+1$ 个位置，看了 $j+1$ 次花，酒的数量变为 $k - 1$。

酒馆：走到第 $i+1$ 个位置，看了 $j$ 次花，酒的数量变为 $k \times 2$。

状态转移方程：
```
if (f[i][j][k] != 0)//这里也可以简写成 if(f[i][j][k])
{
	f[i + 1][j + 1][k - 1] += f[i][j][k];
	f[i + 1][j][k * 2] += f[i][j][k];
}
```

注意！$j$ 只需要循环到 $m-1$，不需要循环到 $m$，如果循环到了 $m$：

首先，再看花变成 $m +1$ 已经对答案没有任何的贡献了。

其次，这样还会多算。如果不看花只能是没有酒，一直经过酒店，

但是题目要求最后一次只能经过花，所以不行。

还有一个问题：酒的斗数上线是什么？

显然不会超过 $m$，不然最后的酒就喝不完了，所以也循环到 $m$。

代码：

```cpp
#include <iostream>
using namespace std;
int n, m;
int f[205][105][105];
int main() {
	cin >> n >> m;
	f[0][0][2] = 1;
	for (int i = 0; i < n + m; i ++)
		for (int j = 0; j < m; j ++)
			for (int k = 0; k <= m; k ++)
				if (f[i][j][k]) {
					if (k > 0) f[i + 1][j + 1][k - 1] = (f[i + 1][j + 1][k - 1] + f[i][j][k]) % 1000000007;
					if (k <= 50) f[i + 1][j][k * 2] = (f[i + 1][j][k * 2] + f[i][j][k]) % 1000000007;
				}
	cout << f[n + m][m][0];
	return 0;
}
```


---

## 作者：hyfzelda (赞：32)

### [P8786 [蓝桥杯 2022 省 B] 李白打酒加强版](https://www.luogu.com.cn/problem/P8786)
## **$1.$** 思路
#### $(1)$ 题意
 
设李白酒显酒量为 $va,$则有两种操作：

1. $va=va×2$ (共 $n$ 次)
2. $va=va-1$ (共 $m$ 次）

并且最后一次为操作 $(2),va$ 初始值为 $2,$要求经过 $n+m$ 次操作后 $va=0$ 的方案数对$10^9+7$取模。



#### $(2)$ 状态

本题为一道dp。

状态定义： $dp[i][j][k],$代表操作 $(1)$ $i$ 次$,$操作$(2)$ $j$次$,va=k$ 时的方案数。

边界：$dp[0][0][2]=1$ （ $va$ 初值为 $2$ )。



#### $(3)$ 转移方程

##### 1.
基于 $2$ 种操作的定义$,$设计有以下状态转移方程：

  1.$dp[i][j][k]=dp[i][j][k]+dp[i-1][j][\dfrac k2]$ ( $2$ 整除 $k$ 时,对应操作   $1$ )
  
  2.$dp[i][j][k]=dp[i][j][k]+dp[i][j-1][k+1]$ (对应操作 $2$  )
  
  
##### 2.
  
 特别的$,$最后一次操作为操作 $2 ,$故仅考虑到 $dp[n][m-1][1]$  即可。
 
 
##  $2.$ 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;//别忘记取模
int n,m,dp[105][105][105];//dp数组
int main()
{
	cin>>n>>m;
	dp[0][0][2]=1;
	for(int i=0;i<=n;i++)
	{
		
		for(int j=0;j<=m-1;j++)
		{
			if(i==0&&j==0) continue; 
			for(int k=0;k<=100;k++)//因为最多出现100次操作2，故va最大为100
			{
				if(k%2==0&&i) dp[i][j][k]+=dp[i-1][j][k/2];//操作1
				if(j) dp[i][j][k]+=dp[i][j-1][k+1];//操作2
				dp[i][j][k]%=mod;//取模
			}
		}
	}
	cout<<dp[n][m-1][1]%mod;//见1.3.2
}
```


---

## 作者：_yolanda_ (赞：14)

显然的动态规划,提供两种状态，虽然本质相同。（如果有 zpl 的题解建议查看她的 /kel ）

首先明确一点就是任意时刻的酒的斗数不能超过 $m$，因为超过了就一定不可能在结束时喝完了。

## 1st

令 `f[i][j][k]` 表示走过了 $i$ 个酒馆，$j$ 个花，还有 $k$ 斗酒的方案数。

- 到酒馆时：因为到酒馆时翻一倍，所以这时的 $k$ 一定是偶数：`if(k%2==0 && i)	f[i][j][k]+=f[i-1][j][k/2];`

- 到花时：上一次的酒比当前多 $1$，所以从 $k+1$ 转移了（注意 $k$ 一直要小于 $m$）：`if(j && k+1<=m)	f[i][j][k]+=f[i][j-1][k+1];`

最后的答案就是 `f[n][m-1][1]`。因为最后一步是花，并且这一步喝完了最后一斗酒，所以在只有 $m-1$ 个花 $n$ 个酒馆时应该还剩 $1$ 斗酒。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int p=1e9+7;
int f[105][105][105];

signed main(){

	int n=read(),m=read();//快读
	f[0][0][2]=1;
	for(int i=0;i<=n;++i)
		for(int j=0;j<=m;++j){
			if(!i && !j)	continue;
			for(int k=0;k<=m;++k){
				if(k%2==0 && i)	f[i][j][k]+=f[i-1][j][k/2];
				if(j && k+1<=m)	f[i][j][k]+=f[i][j-1][k+1];
				f[i][j][k]%=p;
			}
		}
	print(f[n][m-1][1]);//快输

	return 0;
}
```

这个状态还有一个用 [刷表法](https://www.luogu.com.cn/paste/op13t752) 写的代码。

## 2nd

和上面差不多，但是要多用一些空间。`f[i][j][k]` 表示一共走过了 $i$ 个花和酒馆，其中有 $j$ 个酒馆，剩下 $k$ 斗酒的方案数。

这个和上面的区别就是每次一定会从 $i-1$ 转移，这一次填花的时候不用把 $j$ 减一，填酒馆的时候 $j$ 要减一。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int p=1e9+7;
int f[205][105][105];//第一维记得开两倍空间 100（酒馆）+100（花）

signed main(){

	int n=read(),m=read();
	f[0][0][2]=1;
	for(int i=1;i<=n+m;++i)
		for(int j=0;j<=n;++j)
			for(int k=0;k<=m;++k){
				if(i-j && k+1<=m)	f[i][j][k]+=f[i-1][j][k+1];
				if(j && k%2==0)	f[i][j][k]+=f[i-1][j-1][k/2];
				f[i][j][k]%=p;//记得取模
			}
	print(f[n+m-1][n][1]);

	return 0;
}
```

---

## 作者：Elairin176 (赞：11)

[传送门](https://www.luogu.com.cn/problem/P8786)        
水记忆化搜索。        
这题题解为什么清一色都是 dp，只有一个人写了没加记忆化的暴搜（但是之后又介绍了 dp）。       
我们设 $f(n,m,k)$ 为此时还有 $n$ 个店，$m$ 朵花，$k$ 斗酒的方案数。            
那么我们先考虑边界情况：     
如果 $k<0$、$k>m$、$k=m$ 且 $n≠0$ 这三种情况出现，那么 $f(n,m,k)$ 为 $0$。       
我们设 $ans$ 为这次用于计算答案的量。      
那么如果 $n≠0$，$ans$ 需要加 $f(n-1,m,k\times 2)$。           
如果 $m≠0$ 且 $k≠0$，还有两种情况：       
1. 如果 $n=0,m=1,k=1$，那么 $ans$ 需加 $1$。
2. 否则 $ans$ 加 $f(n,m-1,k-1)$。       

最后结果为 $ans$。       
那么我们根据以上内容，写出记忆化即可。       
[CODE](https://www.luogu.com.cn/paste/jx4redgk)

---

## 作者：FstAutoMaton (赞：9)

看到这个题，可以发现转移其实十分明显，但直接DP还是有困难（~~可能只有我有困难）~~，所以先搜索。

我们可以将遇到店的次数，遇到花的次数，当前的酒量放在DFS函数里。可以得到状态为 ```dfs( int step1, int step2, int sum )```,其中  ```step1``` 表遇到店的次数，```step2```为遇到花的次数，```sum```为酒量。而每次只会有两种选择（遇到花和遇到店），那么可以得到如下转移：
```
dfs( step1 + 1, step2, sum * 2 );
if( sum ) dfs( step1, step2 + 1, sum - 1 );
```
由此可得DFS函数：
```
void dfs( int step1, int step2, int sum )
{
	if( step1 > n + 1 || step2 > m ) return ;
	if( sum <= 0 || sum > m ) return ;    	
	if( step1 == n + 1 && step2 == m )
	{
		if( sum == 1 )
			ans ++;
		ans %= mod;
		return ;
	}
	dfs( step1 + 1, step2, sum * 2 );
	dfs( step1, step2 + 1, sum - 1 );
}
```
[50分记录](https://www.luogu.com.cn/record/97657244)

接下来，我们考虑进行DP，设 ```f[i][j][k]``` 为遇到了```i```次店，```j```次花，有```k```斗酒，那转移方程为
```
f[i + 1][j][k * 2] = ( f[i + 1][j][k * 2] + f[i][j][k] ) % mod;
if( k )
f[i][j + 1][k - 1] = ( f[i][j + 1][k - 1] + f[i][j][k] ) % mod;
```
不过这样有一些不人性，我们把它变换一下，AC代码如下：
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod = 1e9 + 7;
int n, m, f[105][105][105];
signed main()
{
    cin >> n >> m;
    f[0][0][2] = 1;
    for( int i = 0; i <= n; i ++ )//枚举遇店数
    {
        for( int j = 0; j < m; j ++ )//枚举遇花数
        {
            if( !i && !j ) continue; 
            for( int k = 0; k < m; k ++ )//枚举酒数
            {
                if( j )
                    f[i][j][k] = f[i][j - 1][k + 1];
                if( !( k & 1 ) && i )
            	    f[i][j][k] += f[i - 1][j][k / 2];
                f[i][j][k] %= mod;
            }
        }
    }
    cout << f[n][m - 1][1];//由于最后一次是花，所以在f[n][m - 1][1]
}
```







---

## 作者：XZhuRen (赞：8)

# 鲜花

第一篇题解，修缮一下古迹。

五花马，千金裘，呼儿将出换美酒，与尔同销万古愁！

——李白《将进酒》

# 题意
初始的计数值（即酒的斗数）为 $2$。

共有 $(n+m)$ 个节点，其中 $n$ 个点让计数值翻倍（店），其余 $m$ 个点让计数值减去 $1$（花）。李白必须经过所有 $(n+m)$ 个节点，其中，他最后一个经过的节点一定是使计数值减去 $1$ 的节点。

现在需求出有多少种可能，李白在经过所有节点后的计数值为 $0$。

# 思路

## 前置思路
已知最后一个节点一定为花，则李白在经过 $(n+m-1)$ 个节点后得到的计数值一定为 $1$。

通过手玩，可知：

1. 如果李白此次遇见的是花，则上次留下酒的斗数一定大于等于 $1$。

2. 如果李白此次遇到的是店，则此次酒的斗数一定是偶数。即：如果显中有k斗酒，则：$0 \equiv k \pmod 2$。
## 程序思路
使用动态规划算法。

设 $f_{i,j,k}$ 表示李白在第 $i$ 个节点，已经遇到 $j$ 次花，显里有 $k$ 斗酒的状态。

根据加法原理，推出状态转移方程为：

```cpp
if(k%2==0){
	f[i][j][k]+=f[i-1][j][k/2];
}
if(j>=1){
	f[i][j][k]+=f[i-1][j-1][k+1];
}
```

注意：如果这次选择的是店，要保证 $k \equiv 0 \pmod 2$。如果这次选择的是花，要保证 $j\le(m-1)$。

# 代码

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
long long n,m;//n:店，m:花 
const long long mod=1e9+7;//1e9+7=1000000007
long long f[514][114][191];//f[i][j][k]代表：在第i个时刻，遇到了j次花，此时显中有k斗酒 
//因为最多有100次遇花，所以酒的数量一定不大于100
long long ans;//ans=f[n+m-1][m-1][1];
int main(){
	scanf("%lld%lld",&n,&m);//输入 
	f[0][0][2]=1;//在第0时刻 
	for(long long i=1;i<=n+m-1;i++){
		for(long long j=0;j<=min(i,m-1);j++){
			for(long long k=0;k<=m+1;k++){
				if(k%2==0){//如果这一次遇到的是店（满足条件：这一次的斗数为偶数，即mod2=0。 
					f[i][j][k]+=f[i-1][j][k/2];
				}
				f[i][j][k]%=mod;//取模 
				if(j>=1){//如果遇到花 （满足条件：在遇到过花后至少统计了一次遇花） 
					f[i][j][k]+=f[i-1][j-1][k+1];
				}
				f[i][j][k]%=mod;//取模 
			}
		}
	}
	ans=f[n+m-1][m-1][1];//因为最后一次一定遇花，则ans=f[位置数-1][遇花次数-1][0+1]; 
	printf("%lld",ans);//输出 
	return 0;
}
```

当时这 LaTex 写得一坨啊……竟然过了。

---

## 作者：zplqwq (赞：8)

原本不想写题解的，但是因为自己脑子不太好使然后细节挂了所以打算写篇题解警告自己脑子有问题。再加上我的方法和那篇题解不太一样（虽然本质差不多）就交了供跟我方法一样的人参考。



------------


这道题有个相当显然的状态，同时也是更省空间的方法。

令 $dp_{i,j,k}$ 表示遇到了 $i$ 次店，且遇到了 $j$ 次花，当前酒量为 $k$ 的方案数。那么答案就是 $dp_{n,m-1,1}$ ，这个是因为最后一个 **必须** 选花。两位四川女队就挂在了这里。

初始状态是 $dp_{0,0,2}=1$，即一开始李白有 $2$ 斗酒。

转移方程就是 $dp_{i,jk}=dp_{i-1,j,k \times 2}+dp_{i,j-1,k+1}$，这就相当于我当前这步是店还是花，如果是花的话那么他就可以从 $dp_{i,j-1,k+1}$ 转移过来，店就是从 $dp_{i-1,j,k \times 2}$ 转移过来。注意这里要判断一下能不能从店转移过来，如果当前酒量是奇数的话那么其实是不可以从店转移过来的，因为店是翻倍。

我们枚举 $k$ 的时候只需要枚举到 $100$ 就可以了，因为李白最多只经过 $100$ 次花。

最后注意一下，我们经过的店的数量其实是达到 $0$ 的，因为初始值是 $2$ 。同理花的数量也可以是 $0$ 。

```cpp
	dp[0][0][2]=1;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			for(int k=0;k<=100;k++){
				if(j>0 and k%2==0 and i>0)dp[i][j][k]+=dp[i-1][j][k/2]+dp[i][j-1][k+1];
				else if(j>0) dp[i][j][k]+=dp[i][j-1][k+1];
				else if(k%2==0 and i>0) dp[i][j][k]=dp[i-1][j][k/2];
				dp[i][j][k]%=mod;
			}
		}
	}
	cout<<dp[n][m-1][1]%mod<<"\n";
```

---

## 作者：Lord_Sky2048 (赞：5)

这是一道

**动态规划题**。

设 $f[i][j][k]$ 表示走了 $i$ 步，共有 $j$ 次看花，$k$ 次酒。

考虑 $2$ 种情况，我们得到状态转移方程如下：

 看花： 
 $$f[i][j][k] = f[i - 1][j][k + 1] $$
 
 遇店： 
 $$f[i][j][k] = f[i - 1][j - 1][k / 2];$$
 
 最后 $f[n + m - 1][n][1]$ 即为结果。
 
 代码：
 
 ```cpp
#include <bits/stdc++.h>
using namespace std;
long long dp[220][110][110];
int main()
{
    int n,m;
    dp[0][0][2] = 1;
    for(int i = 1; i < n + m; i++)
    {
    	for(int j = 0; j <= n; j++)
    	{		
            for(int k = 0; k <= 100; k++)
			{
                dp[i][j][k]=(dp[i][j][k]+dp[i-1][j][k+1])%P;
                if((k%2==0)&&j) 
				{
					dp[i][j][k]=(dp[i][j][k]+dp[i-1][j-1][k/2])%P;
				}
            }
		}
	}
    return 0;
}
```

---


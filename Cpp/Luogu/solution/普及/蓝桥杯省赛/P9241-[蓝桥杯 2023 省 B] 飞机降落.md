# [蓝桥杯 2023 省 B] 飞机降落

## 题目描述

$N$ 架飞机准备降落到某个只有一条跑道的机场。其中第 $i$ 架飞机在 $T_{i}$ 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 $D_{i}$ 个单位时间，即它最早可以于 $T_{i}$ 时刻开始降落，最晩可以于 $T_{i}+D_{i}$ 时刻开始降落。降落过程需要 $L_{i}$ 个单位时间。

一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。

请你判断 $N$ 架飞机是否可以全部安全降落。

## 说明/提示

**【样例说明】**

对于第一组数据，可以安排第 3 架飞机于 0 时刻开始降落，20 时刻完成降落。安排第 2 架飞机于 20 时刻开始降落，30 时刻完成降落。安排第 1 架飞机于 30 时刻开始降落，40 时刻完成降落。

对于第二组数据，无论如何安排，都会有飞机不能及时降落。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$N \leq 2$。

对于 $100 \%$ 的数据，$1 \leq T \leq 10$，$1 \leq N \leq 10$，$0 \leq T_{i},D_{i},L_{i} \leq 10^{5}$。 

蓝桥杯 2023 省赛 B 组 D 题。

## 样例 #1

### 输入

```
2
3
0 100 10
10 10 10
0 2 20
3
0 10 20
10 10 20
20 10 20```

### 输出

```
YES
NO```

# 题解

## 作者：CYZZ (赞：41)

# [飞机降落](https://www.luogu.com.cn/problem/P9241)
贪心了一下发现不好确定顺序，$n\le10$ 的数据直接暴力 dfs 即可。

dfs 传一个 $tim$ 参数，表示目前已经到了第 $tim$ 个单位时间（上一个飞机的降落时间）。飞机能降落的条件是 $t_i+d_i\le tim$，不满足条件就跳过。

因为不能在飞机到达机场前就开始降落，所以完成降落的时间是 $\max(tim,t_i)+l_i$，当作参数下传。
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,bk[15];
struct plane
{
    int t,d,l;
}a[15];
bool dfs(int dep,int tim)
{
    if(dep>n)
        return 1;
    for(int i=1;i<=n;i++)
    {
        if(bk[i]||a[i].t+a[i].d<tim)//降落条件
            continue;
        bk[i]=1;
        if(dfs(dep+1,max(tim,a[i].t)+a[i].l))//记得取max
        {
            bk[i]=0;
            return 1;//有一个成功就返回1
        }
        bk[i]=0;//记得去标记
    }
    return 0;
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d%d%d",&a[i].t,&a[i].d,&a[i].l);
        }
        memset(bk,0,sizeof bk);//记得清空
        if(dfs(1,0))
            printf("YES\n");
        else
            printf("NO\n");
    }
}

```
希望本篇题解能帮到大家！

---

## 作者：wuyin331 (赞：16)

# 前言
原本是想用贪心来求解，怎么调的都都调出不出来，看看数据范围，算了，暴搜。
# 题解
要将 $N$ 架飞机全部降落，那么考虑用深搜把所有情况全部试一遍，用 $flag$ 记录是否有任意一种情况能用能将所有飞机全部落下。用 $vis$ 数组记录该飞机是否降落。
### 剪枝 
如果存在任意一个**未降落飞机**最晚降落时间小于当前时间，那么这个飞机一定不能降落，继续往下
搜一定不存在所有飞机降落的情况，则排除这种情况。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int l;//飞机最早能降落的时间 
	int r;//飞机最晚能降落的时间 
	int t;//飞机降落需要的时间 
};
int t,n,vis[15];
bool flag;
Node fj[15];
void dfs(int deep,int now){//now表示当前时间
	if(deep==n){//所有飞机降落
		flag=1;
		return ;
	}
	for(int i=1;i<=n;i++){
	if(!vis[i]&&fj[i].r<now) return ;//剪枝
	if(!vis[i]&&fj[i].r>=now){
	vis[i]=1;//标记 
	if(fj[i].l>now) dfs(deep+1,fj[i].l+fj[i].t);//如果开始时间比现在时间要晚 
	else dfs(deep+1,now+fj[i].t);
	vis[i]=0;//取消标记 
	}
}
}
int main(){
	cin>>t;
	memset(vis,0,sizeof(vis));
	while(t--){
		cin>>n;
		flag=0;
		int k;
		for(int i=1;i<=n;i++) cin>>fj[i].l>>k>>fj[i].t,fj[i].r=fj[i].l+k;//因为是降落的最晚时间,因此fj[i].r=fj[i].l+k
		for(int i=1;i<=n;i++) vis[i]=1,dfs(1,fj[i].l+fj[i].t),vis[i]=0;
		if(flag) cout<<"YES"<<endl;
		else cout<<"NO"<<endl;
	}
	return 0;
}
```


---

## 作者：icypenguin (赞：9)

## 题目简述

有 $N$ 架飞机，它们要按照一定顺序降落，每种飞机最早在 $T[i]$ 时刻降落，最晚在 $T[i] + D[i]$ 时刻降落，降落花费 $L[i]$ 时间。只有一架飞机降落完后，另一架才能降落，求是否有符合条件的方案。

## 题目分析

由于 $1 \leq N \leq 10$，我们可以考虑 dfs。

搜索时要加上 $llast$ 参数，代表上一个飞机降落的时间。设这次降落时间为 $s$，则 $llast \leq s$。

另外，我们还要判断这个飞机现在是否降落，如果 $llast > T[i] + D[i]$ 则说明最晚降落时间已经过去，则这架飞机不能进行降落，所以这次搜索的降落方案肯定不合理。

在搜到正确答案后，我们要标记一下，并通过标记停止搜索。

最后通过是否标记输出答案即可。

**理论上最坏时间复杂度 $O(TN^N)$，但实际上速度很快。**

## 代码实现

```cpp
#include <iostream>
#include <cstring>
using namespace std;
int T, n, t[15], d[15], l[15], book[15], llast = -1;
bool flag = false;
int dfs(int step, int llast){
    if (step == n + 1){
        flag = true;
        return 0;
    }
    if (flag){
        return 0;
    }
    for (int i = 1; i <= n; i++){
        if (!book[i]){
            if (t[i] + d[i] < llast){
                return 0;
            }
            book[i] = 1;
            int s = t[i];
            if (s < llast){
                s = llast;
            }
            dfs(step + 1, s + l[i]);
            book[i] = 0;
        }
    }
    return 0;
}
int main(){
    cin >> T;
    while (T--){
        flag = false;
        memset(book, 0, sizeof(book));
        cin >> n;
        for (int i = 1; i <= n; i++){
            cin >> t[i] >> d[i] >> l[i];
        }
        dfs(1, -1);
        if (flag){
            cout << "YES" << endl;
        }else{
            cout << "NO" << endl;
        }
    }
    return 0;
}
```


---

## 作者：封禁用户 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9241)
# 思路：
由于本题数据不大，所以我们可以用搜索完成。如果 $t_i+d_i \leq tim$，就跳过。最后我们可以知道降落时间为 $\max(tim+t_i)+l_i$,当作下一步的参数。
# Python Code：
```python
def dfs(dep,tim,bk,a): #搜索
    if (dep > len(a)):
        return True
    for i in range(len(a)):
        if (bk[i] or a[i]['t'] + a[i]['d'] < tim): #降落条件
            continue
        bk[i] = True
        if (dfs(dep + 1, max(tim, a[i]['t']) + a[i]['l'], bk, a)):
            bk[i] = False
            return True #如果成功就返回True
        bk[i] = False  
    return False

if __name__ == '__main__':
    t = int(input())
    for ti in range(t):
        n = int(input())
        a = [] 
        for i in range(n):
            a.append({})
            a[i]['t'], a[i]['d'], a[i]['l'] = map(int, input().split())
            
        bk = [False] * n
        if (dfs(1,0,bk,a)): #判断
            print("YES")
        else:
            print("NO")
```


---

## 作者：Zhao_daodao (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P9241)

# 题目分析
在本题中，$T_{i}$ 作为最早降落的时间，$T_{i}+D_{i}$ 作为最晚降落的时间时间，同时在降落开始到结束还有 $L_{i}$ 的时间。

# 题目思路

首先设立一个为变量 $k$，代表是否可以全部安全降落。即当 $k$ 是 true 时，输出 YES；$k$ 是 false 时，输出 NO。
再设立一个变量 $used$，对于每一个 $used_{i}$，表示第 $i$ 架飞机是否已经降落。

设立一个状态，包含 $dep$ 和 $lst$，分别对应此时递归的步数和当前的时间。

对于每一个状态，枚举 $n$ 次，若此时 $T_{i}+D_{i}<lst$，即存在更好的方案，就 return。

若此时 $T_{i}+D_{i}>=lst$ 且 $used_{i}$ =1 ，就将 $used_{i}$ 设为1，再通过这个状态转移下去，转移式：$dfs(dep+1,max(T_{i},lst)+L_{i})$。

在每一个 dfs开始前，先判断 $dep$ 是否大于 $n$。若大于 $n$，就将 $k$ 设为1。

Tip:转移结束后记得重置 $used_{i}$。

# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=10+5;
int n;
int t[MAXN];
int d[MAXN];
int l[MAXN];
int start[MAXN],end[MAXN];
int used[MAXN];
int last=-1;
bool k=0;
int dfs(int dep,int lst){
    if(dep>n){
        k=1;
        return 0;
    }
    if(k)return 0;
    for(int i=1;i<=n;i++){
        if(!used[i]){
            if (t[i]+d[i]<lst)return 0;
            used[i]=1;
            dfs(dep+1,max(t[i],lst)+l[i]);
            used[i]=0;
        }
    }
    return 0;
}
int main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	int T;
    cin>>T;
    while(T--){
        k=0;
        memset(used,0,sizeof used);
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>t[i]>>d[i]>>l[i];
        dfs(1,-1);
        if (k)cout<<"YES\n";
		else cout<<"NO\n";
    }
}
```

---

## 作者：e4fsrc2e4fsrc2 (赞：2)

## [P9241 [蓝桥杯 2023 省 B] 飞机降落](https://www.luogu.com.cn/problem/P9241)

## 思路分析
考虑暴力,时间复杂度为 $O(n! \times n \times t)$。

首先，选择出这 $n$ 架飞机的降落顺序，再按照题目模拟，能降就降。

PS：1.如果已经判断出来可以，那么在后面的 $\verb|dfs|$ 中直接退出即可。 

2.在已经判断判断出可以降落时，要注意上一架飞机降落时间是否是小于当前飞机到达时间(否则会拿 [$40pts$](https://www.luogu.com.cn/record/109673904))

## AC 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define R register int
using namespace std;
const int N=11;
struct node{int t,d,l;void read(){cin>>t>>d>>l;};}a[N],b[N];
int n,t;bool vis[N],f;
void dfs(int d){
	if(f)return;
	if(d>n){
		int ls=b[1].t+b[1].l,fl=1;
		for(R i=2; i<=n; i++)
			if(ls>b[i].d+b[i].t){fl=0;break;}
			else if(ls>b[i].t)ls+=b[i].l;
				 else ls=b[i].l+b[i].t;
		if(fl)f=1;
	}
	for(R i=1; i<=n; i++)
		if(!vis[i])
			vis[i]=1,b[d]=a[i],dfs(d+1),vis[i]=0;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n;f=0;memset(b,0,sizeof b);
		for(R i=1; i<=n; i++)a[i].read();
		dfs(1);
		if(f)cout<<"YES\n";
		else cout<<"NO\n";
	}
	return 0;
}

```

---

## 作者：WOL_GO (赞：2)

# [题目传送门](https://www.luogu.com.cn/problem/P9241)

**题目大意**

有 $n$ 架飞机降落，每个飞机有到达时间、可盘旋时间、降落时间三个参数，问能否安排一个方案使每架飞机都能在油耗完前降落。

**思路**

这道题主流思路主要有三种，搜索、贪心和状压，本文主要来讲搜索。因为这题 $n$ 的数值较小，直接枚举全排列然后剪枝方可。剪枝方法：只需要枚举一下当前方案会不会使这架飞机油耗尽坠落方可。

**代码**

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int maxn=15;
void read(int &x){
	int flag=1,num=0;
	char ch;
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	if(ch=='-')flag=-1;
	else if(ch>='0'&&ch<='9')num=ch-'0';
	while(1){
		ch=getchar();
		if(!(ch>='0'&&ch<='9'))break;
		num=num*10+(ch-'0');
	}
	x=num*flag;
	return ;
}
int n,m;
struct a{
	int t,d,l;
	bool down;
}a[maxn];
bool dfs(int x,int y){
	if(x>n)return 1;
	bool k=1;
	for(int i=1;i<=n;++i){
		if(!a[i].down){
			k=0;
			if(a[i].t+a[i].d<y)return 0;
			a[i].down=1;
			int w=max(a[i].t,y);
			if(dfs(x+1,a[i].l+w)){
				return 1;
			}
			a[i].down=0;
		}
	}
	return 0;
}
int main(){
	read(m);
	while(m--){
		read(n);
		for(int i=1;i<=n;++i)read(a[i].t),read(a[i].d),read(a[i].l),a[i].down=0;
		if(dfs(1,0))puts("YES");
		else puts("NO");
	}
}
//9 41 forever
```
目前小号速度洛谷第一，大号洛谷第二（估计是评测机波动的影响）


---


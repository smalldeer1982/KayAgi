# [蓝桥杯 2023 省 B] 岛屿个数

## 题目描述

小蓝得到了一副大小为 $M \times N$ 的格子地图，可以将其视作一个只包含字符 `0`（代表海水）和 `1`（代表陆地）的二维数组，地图之外可以视作全部是海水，每个岛屿由在上/下/左/右四个方向上相邻的 `1` 相连接而形成。

在岛屿 $A$ 所占据的格子中，如果可以从中选出 $k$ 个不同的格子，使得他们的坐标能够组成一个这样的排列：$\left(x_{0},y_{0}\right),\left(x_{1},y_{1}\right),\ldots,\left(x_{k-1},y_{k-1}\right)$，其中 $\left(x_{(i+1) \bmod k},y_{(i+1) \bmod k}\right)$ 是由 $\left(x_{i},y_{i}\right)$ 通过上/下/左/右移动一次得来的（$0 \leq i \leq k-1$），此时这 $k$ 个格子就构成了一个「环」。如果另一个岛屿 $B$ 所占据的格子全部位于这个「环」内部，此时我们将岛屿 $B$ 视作是岛屿 $A$ 的子岛屿。若 $B$ 是 $A$ 的子岛屿，$C$ 又是 $B$ 的子岛屿，那 $C$ 也是 $A$ 的子岛屿。

请问这个地图上共有多少个岛屿？在进行统计时不需要统计子岛屿的数目。

## 说明/提示

**【样例说明】**

对于第一组数据，包含两个岛屿，下面用不同的数字进行了区分：
```
01111
11001
10201
10001
11111
```
岛屿 2 在岛屿 1 的「环」内部，所以岛屿 2 是岛屿 1 的子岛屿，答案为 $1$。

对于第二组数据，包含三个岛屿，下面用不同的数字进行了区分：
```
111111
100001
020301
100001
111111
```
注意岛屿 3 并不是岛屿 1 或者岛屿 2 的子岛屿，因为岛屿 1 和岛屿 2 中均没有「环」。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例，$1 \leq M,N \leq 10$。

对于 $100 \%$ 的评测用例，$1 \leq T \leq 10$，$1 \leq M,N \leq 50$ 。  

蓝桥杯 2023 省赛 B 组 F 题。

## 样例 #1

### 输入

```
2
5 5
01111
11001
10101
10001
11111
5 6
111111
100001
010101
100001
111111
```

### 输出

```
1
3```

# 题解

## 作者：ZhaoV1 (赞：4)

题目要求求主岛屿个数，即求接触到最外层流入的海水的岛屿个数。直接判断一个岛屿是否是另一个岛屿的子岛屿不好判断，所以不如放弃掉子岛屿，而只关注主岛屿的个数，换句话说，只要接触到从最外层流入的海水的岛屿都一定是主岛屿。

不过，一个主岛屿如果不是通过严格的上下左右操作形成一个环，而是存在类似样例二的斜跨格子的情况，那么该主岛屿并不形成环，换句话说就是海水可以通过斜跨格子的方式流入。

将上述思路运用在代码中就会有以下要点：  
1. 海水流入的方向应当有上、下、左、右、左上、右上、左下、右下，**八种方向**进行操作。
2. 判断岛屿是否是联通，必须严格按照上、下、左、右，**四个方向**进行连接。
3. 与海水直接接触的岛屿必然是主岛屿。

理解以上要点后，思路就出来了。首先，在地图的最外圈遍历，如果遇到海水 $0$，即需要做八个方向的 bfs 操作。在海水的 bfs 操作中，如果遇到了主岛屿 $1$，则直接对该点进行四个方向的 bfs 操作，并记录答案。

需要注意的是，如果是从所给地图的最外圈进行遍历判断，则需要注意最外圈全部被主岛屿 $1$ 占满的情况，此时答案应特判为 $1$。若是从地图最外圈的更外一圈，也就是虚构的海水进行 bfs 操作，则无需担心该特判问题。（本题解代码用的是前者方式）


Code
---


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 55;
int t,n,m,res;
bool vis[N][N];
char mp[N][N];
int nextStep[8][2] = {{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};
struct inner{
	int x,y;
};

void bfs1(int x,int y){
	queue<inner> que;
	que.push({x,y});
	res++;

	while(!que.empty()){
		auto tt = que.front();
		que.pop();

		for(int i=0;i<4;i++){
			int tx = tt.x + nextStep[i][0];
			int ty = tt.y + nextStep[i][1];
			if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&mp[tx][ty]=='1'&&!vis[tx][ty]){
				que.push({tx,ty});
				vis[tx][ty] = true;
			}
		}
	}
}

void bfs0(int x,int y){
	queue<inner> que;
	que.push({x,y});
	vis[x][y] = true;

	while(!que.empty()){
		auto tt = que.front();
		que.pop();

		for(int i=0;i<8;i++){
			int tx = tt.x + nextStep[i][0];
			int ty = tt.y + nextStep[i][1];
			if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&!vis[tx][ty]){
				vis[tx][ty] = true;
				if(mp[tx][ty]=='1') bfs1(tx,ty);
				else que.push({tx,ty});
			}
		}
	}
}

void solve(){
	bool flag = false;
	res = 0;
	cin >> n >> m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			cin >> mp[i][j];
			vis[i][j] = false;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(i==1 || i==n || j==1 || j==m)//对边缘的海水进行 bfs0
				if(!vis[i][j] && mp[i][j] == '0'){
					bfs0(i,j);
					flag = true;
				}
	if(!flag) res = 1;//以防一个岛屿占满了外边界的情况
	cout << res << '\n';
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> t;
	while(t--){
		solve();
	}
	return 0;
}

```

---

## 作者：yurril (赞：3)

这一题是数岛屿数量的进阶题目，难点在于如何判断该岛屿是否为子岛屿。我们可以将海域分为内海和外海，内海即由岛屿形成的环形区域内的海域。判断一个岛屿是否为子岛屿的关键在于其是否能到达外海。注意，在 dfs 染色时，我们从**上下左右**方向进行遍历，而在判断能否到达外海时，则需要从**四面八方**进行遍历。



贴上 AC 代码，（代码有注释） qwq



```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
using ll=long long;
char mp[60][60];
int vis[60][60]; // 经典 dfs 标记
int sc; // 染色编号
int v[60][60]; // 在查找该岛屿能否走到外海的标记
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};
int dx1[]={1,1,1,0,0,-1,-1,-1};
int dy1[]={0,1,-1,1,-1,0,1,-1};
int n,m,ans;
void dfs(int x,int y){
	vis[x][y]=sc;
    for(int i=0;i<4;i++){ // 从上下左右遍历，将岛屿染色
		int nx=dx[i]+x;
		int ny=dy[i]+y;
		if(vis[nx][ny]||nx<1||nx>n||ny<1||ny>m||mp[nx][ny]=='0')continue;
		dfs(nx,ny);
	}
} 
bool query(int x,int y){
	if(x>n||x<1||y>m||y<1)return 1;
	v[x][y]=1;
	for(int i=0;i<8;i++){ // 观察是否能走到外海要从四面八方遍历
		int nx=dx1[i]+x;
		int ny=dy1[i]+y;
		if((mp[nx][ny]=='1'&&vis[nx][ny]!=sc)||v[nx][ny])continue; // 要沿着海域走，不能走到其他岛屿上，但是可以在本岛领土走
		if(query(nx,ny))return 1;
	}
	return 0;
}
void solve(){
    cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
			vis[i][j]=0;
		}
	}
	ans=0; // 全局变量 ans 归零
	sc=0; // 编号归零
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(vis[i][j]||mp[i][j]=='0')continue;
			sc++;
			dfs(i,j);
			for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)v[i][j]=0; // 将v标记全部还原为 0
			if(query(i,j))ans++; // 如果能走到外海就说明不是子岛屿
		}
	}
	cout<<ans<<endl;
}
int main() {
	ios::sync_with_stdio(false);                                                                       
	cin.tie(nullptr);
	int t=1;cin>>t;
	while(t--)solve();
	
}
```

---

## 作者：Qianmo_su (赞：1)

本题要求求一个地图中的岛屿数量，但是不包括子岛屿（在其它岛屿围成的环之间）。

对于求岛屿，可以使用搜索中的 **Flood Fill** 算法来实现，对每个为 $1$ 的陆地进行 BFS，标记与它相邻的所有陆地。为了实现环内部的岛屿不被统计，我们可以先 BFS 海域，在 BFS 海域的过程中如果遍历到为 $1$ 的陆地，就来一遍 Flood Fill 将其相邻的陆地全部打上标记，如果遍历到为 $0$ 的海水就不入队（只有 $0$ 会入队）。

需要注意的是，遍历海域是八个方向拓展的，而遍历陆地是四个方向扩展的。同时我们能保证**海水拓展八个方向得到的岛屿都不在环内**，这是因为陆地不入队，岛屿在环内的话是进不去的。可以借助下面样例来理解：



```
01111
11001
10101
10001
11111
```

我们不可能遍历到 $(3,2)$ 位置的 $0$ 的，因为 $0$ 不入队，遍历海域是进不到环内的，自然就遍历不到环内的 $1$ 了。所以我们对于每次 Flood Fill，直接将答案加 $1$ 就可以了。

还有一些需要注意的点：

+ 我们需要确定遍历海水的起点。起点肯定要在最外面，所以我们默认图的下标从 $1$ 开始，将 $g_{0,i}$、$g_{i,0}$、$g_{n+1,i}$ 和 $g_{i,m+1}$ 均设为 $0$，我们只需要从 $(0,0)$ 位置开始遍历就可以了。
+ 本题为多测，需要在每个测试数据都初始化一遍 $vis$ 数组和存图的 $g$ 数组（否则无法保证每次 $g_{0,i}$、$g_{i,0}$、$g_{n+1,i}$ 和 $g_{i,m+1}$ 均为 $0$）。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 55;
typedef pair<int,int> PII;

int n,m,ans;
char g[N][N];
bool vis[N][N];

int dx1[] = {1,0,-1,0},dy1[] = {0,1,0,-1};
int dx2[] = {-1,-1,0,1,1,1,0,-1},dy2[] = {0,1,1,1,0,-1,-1,-1};

void bfs1(int x,int y)
{
    ans++;
    queue<PII> q;
    q.push({x,y});
    vis[x][y] = true;
    while(!q.empty())
    {
        auto t = q.front();
        q.pop();
        int x = t.first,y = t.second;
        for(int i=0;i<4;i++)
        {
            int rx = x+dx1[i],ry = y+dy1[i];
            if(rx>=1 && rx<=n && ry>=1 && ry<=m && !vis[rx][ry] && g[rx][ry] == '1')
            {
                vis[rx][ry] = true;
                q.push({rx,ry});
            }
        }
    }
}

void bfs2()
{
    queue<PII> q;
    q.push({0,0});
    vis[0][0] = true;
    while(!q.empty())
    {
        auto t = q.front();
        q.pop();
        int x = t.first,y = t.second;
        for(int i=0;i<8;i++)
        {
            int rx = x+dx2[i],ry = y+dy2[i];
            if(rx>=0 && rx<=n+1 && ry>=0 && ry<=m+1 && !vis[rx][ry])
            {
                if(g[rx][ry] == '1') bfs1(rx,ry);
                else
                {
                    vis[rx][ry] = true;
                    q.push({rx,ry});
                }
            }
        }
    }
}

int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        ans = 0;
        memset(vis,false,sizeof(vis));
        cin >> n >> m;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                cin >> g[i][j];
        bfs2();
        cout << ans << endl;
    }
    return 0;
}

---

## 作者：brofea5 (赞：1)

# 题意

给定一个地图，$0$ 代表海洋，$1$ 代表陆地，陆地与其上下左右的陆地同属一个岛屿，需要统计岛屿个数。但是如果一个岛屿形成了一个环，那么环的内部的岛屿不做统计。

# 思路

将地图扩展一圈海洋，外圈 $0$ 与外圈连通的 $0$ 作为外海，如果一个岛屿没有被任何环形岛包围，那么它一定和外海相接。

那么步骤就是：

1. 搜索外海连通块。
2. 搜索与外海相接的岛屿连通块。

判断是否与外海相接需要判断四周有没有外海吗？不需要，因为一个岛屿相接四面外海的陆地块都肯定至少存在一个，所以只要找任意方向相邻外海的地块就可以开始搜连通块了，下面代码是判断上方是否是外海。

搜索使用 DFS 和 BFS 都可以。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define PII pair<int, int>
#define mpr make_pair
#define st first
#define nd second
int n, m, mp[55][55];
int step[8][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};
void dfs_outer(int x, int y) {
  mp[x][y] = 2;
  for (int i = 0; i < 8; ++i) {
    int nx = x + step[i][0], ny = y + step[i][1];
    if (nx < 0 || nx > n + 1 || ny < 0 || ny > m + 1)
      continue;
    if (mp[nx][ny] == 0)
      dfs_outer(nx, ny);
  }
}
void dfs_island(int x, int y) {
  mp[x][y] = 3;
  for (int i = 0; i < 4; ++i) {
    int nx = x + step[i][0], ny = y + step[i][1];
    if (nx < 1 || nx > n || ny < 1 || ny > m)
      continue;
    if (mp[nx][ny] == 1)
      dfs_island(nx, ny);
  }
}
void solve() {
  memset(mp, 0, sizeof mp);
  cin >> n >> m;
  char t;
  int res = 0;
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j) 
      cin >> t, mp[i][j] = t - '0';
  // 搜索外海连通块，将其标记为2
  dfs_outer(0, 0);
  // 搜索与外海相接的岛屿联通块，搜索过的标记为3
  for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j)
      if (mp[i][j] == 1 && mp[i - 1][j] == 2) // 上方是外海就可以开始搜索了
        dfs_island(i, j), res++;
  cout << res << endl;
}
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);
  cout.tie(0);
  int T;
  cin >> T;
  while (T--) solve();
  return 0;
}
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
通过海水从地图外往里“灌水”，标记所有能到达的外海区域。然后，在灌水过程中，遇到未被访问的陆地时，就标记整个岛屿。如果这个岛屿能被外海的海水碰到，说明它不是子岛屿，就计数；否则就是被其他岛屿包围的子岛屿，不计数。

简单来说就是：
1. 海水灌水（八连通）：从地图外开始，用海水八连通扩散，标记所有能到达的外海区域。
2. 陆地标记（四连通）：在灌水过程中，碰到陆地就四连通标记整个岛屿，并检查是否能被外海海水碰到。能碰到就计数，碰不到就是子岛屿，忽略。
3. 统计结果：最后输出非子岛屿的数量。

### 代码：
```cpp
#include <bits/stdc++.h>
const int N = 1e3+101;
using namespace std;
int T,m,n;
char g[N][N];
bool v1[N][N],v2[N][N];
int dx8[8]={0,0,1,-1,1,1,-1,-1};
int dy8[8]={1,-1,0,0,1,-1,1,-1};
int dx4[4]={0,0,1,-1};
int dy4[4]={1,-1,0,0};
int main(){
    cin>>T;
    while(T--){
        cin>>m>>n;
        memset(g,'0',sizeof(g));
        memset(v1,0,sizeof(v1));
        memset(v2,0,sizeof(v2));
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                cin>>g[i][j];
        queue<pair<int,int>>q1;
        int a=0;
        q1.push({0,0});
        v1[0][0]=1;
        while(!q1.empty()){
            int x=q1.front().first,y=q1.front().second;
            q1.pop();
            for(int d=0;d<8;d++){
                int nx=x+dx8[d],ny=y+dy8[d];
                if(nx<0||nx>m+1||ny<0||ny>n+1)continue;
                if(g[nx][ny]=='0'){
                    if(!v1[nx][ny]){
                        v1[nx][ny]=1;
                        q1.push({nx,ny});
                    }
                }
                else if(!v2[nx][ny]){
                    a++;
                    queue<pair<int,int>>q2;
                    q2.push({nx,ny});
                    v2[nx][ny]=1;
                    while(!q2.empty()){
                        int lx=q2.front().first,ly=q2.front().second;
                        q2.pop();
                        for(int d4=0;d4<4;d4++){
                            int lx2=lx+dx4[d4],ly2=ly+dy4[d4];
                            if(lx2<0||lx2>m+1||ly2<0||ly2>n+1)continue;
                            if(g[lx2][ly2]=='1'&&!v2[lx2][ly2]){
                                v2[lx2][ly2]=1;
                                q2.push({lx2,ly2});
                            }
                        }
                    }
                }
            }
        }
        cout<<a<<endl;
    }
    return 0;
}
```

---


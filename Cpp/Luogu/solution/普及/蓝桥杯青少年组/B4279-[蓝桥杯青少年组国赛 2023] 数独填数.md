# [蓝桥杯青少年组国赛 2023] 数独填数

## 题目背景

本题使用的数独均较为简单，不接受 hack 数据，感兴趣的同学可以查看 [此题目](https://www.luogu.com.cn/problem/P1784) 的说明/提示部分。

## 题目描述

数独是源自 18 世纪瑞士的一种数学游戏。玩家需要根据 $9 \times 9$ 网格上的已知数字，将剩余的所有空格填上数字，使得：
1. 每一行包含数字 $1 \sim 9$ 且不重复；
2. 每一列包含数字 $1 \sim 9$ 且不重复；
3. 每一个 $3 \times 3$ 方块（粗线划分）包含数字 $1 \sim 9$ 且不重复。

## 样例 #1

### 输入

```
17.5..8..
.52.1....
.....759.
.8...94.3
.197.4..8
7......15
4.1...6..
3...2..59
...96..3.```

### 输出

```
174593826
952816347
638247591
286159473
519734268
743682915
491375682
367428159
825961734```

# 题解

## 作者：Gongyujie123 (赞：8)

## [B4279 [蓝桥杯青少年组国赛 2023] 数独填数](https://www.luogu.com.cn/problem/B4279) 题解

本题与 [P1784](https://www.luogu.com.cn/problem/P1784) 在输入输出略有不同外，思路完全一样。

### 1. 思路分析
这道题其实就是**数独**。

首先，我们应该知道填入空格的数应满足三点条件：
1. 每一行包含数字 $1 \sim 9$ 且不重复；
2. 每一列包含数字 $1 \sim 9$ 且不重复；
3. 每一个 $3 \times 3$ 方块包含数字 $1 \sim 9$ 且不重复。

对于第一点，我们可以定义一个 bool 数组 $b$，其中 $b_{i,j}=1$ 用来表示第 $i$ 行的 $j(1 \le j \le 9)$ 已经出现过。

对于第二点，我们也可以定义一个 bool 数组 $c$，其中 $c_{i,j}=1$ 用来表示第 $i$ 列的 $j(1 \le j \le 9)$ 已经出现过。

对于第三点，就比较复杂，我们先将整个网格分成 $9$ 个 $3 \times 3$ 的方块，再定义一个 bool 数组 $d$，其中 $d_{i,j}=1$ 用来表示第 $i$ 个 $3 \times 3$ 方块的 $j(1 \le j \le 9)$ 已经出现过。

然后，我们用 DFS 搜索每一个空格，对于空格 $(x,y)$，它在第 $z$ 个 $3 \times 3$ 方块，枚举 $i(1 \le i \le 9)$，如果 $i$ 在
 $b,c,d$ 数组中都没有出现，即 $b_{x,i}=0,c_{y,i}=0,d_{z,i}=0$，那就将空格 $(x,y)$ 暂时设为 $i$，并继续搜索下一个空格；如果没有符合要求的 $i$，就回溯到上一个空格。

最后，当所有空格都填上了符合要求的数字时，输出完成的数独。
### 2. AC 代码
[AC 记录](https://www.luogu.com.cn/record/216421523)。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[11][11];
bool b[11][11], c[11][11], d[11][11];
int f(int x, int y) {  // 查找 (x,y) 在第几个小方块
	if (x <= 3 && y <= 3) return 1;
	if (x <= 3 && y <= 6) return 2;
	if (x <= 3 && y <= 9) return 3;
	if (x <= 6 && y <= 3) return 4;
	if (x <= 6 && y <= 6) return 5;
	if (x <= 6 && y <= 9) return 6;
	if (x <= 9 && y <= 3) return 7;
	if (x <= 9 && y <= 6) return 8;
	if (x <= 9 && y <= 9) return 9;
}
void out() {  // 输出
	for (int i = 1; i <= 9; i++) {
		for (int j = 1; j <= 9; j++) {
//			/* B4279
			cout << a[i][j];
//			*/
			/* P1784
			cout << a[i][j] << " ";
			*/
		}
		cout << endl;
	}
	exit(0);
}
void dfs(int x, int y) {
	if (a[x][y] != 0) {
		if (x == 9 && y == 9) out();  // 搜索下一个空格，搜索完便输出
		else if(y == 9) dfs(x + 1, 1);
		else dfs(x, y + 1);
	} else {
		for (int i = 1; i <= 9; i++) {
			if ((!b[x][i]) && (!c[y][i]) && (!d[f(x, y)][i])) {
				a[x][y] = i;
				b[x][i] = c[y][i] = d[f(x, y)][i] = 1;
				if (x == 9 && y == 9) out();  // 同上
				else if (y == 9) dfs(x + 1, 1);
				else dfs(x, y + 1);
				a[x][y] = 0;
				b[x][i] = c[y][i] = d[f(x, y)][i] = 0;
			}
		}
	}
}
signed main() {
	for (int i = 1; i <= 9; i++) {
		for (int j = 1; j <= 9; j++) {  // 输入
//			/* B4279
			char t;
			cin >> t;
			if (t != '.') {
				int tt = t-'0';
				b[i][tt] = c[j][tt] = d[f(i, j)][tt] = 1;
				a[i][j] = tt;
			} else {
				a[i][j] = 0;
			}
//			*/
			/* P1784
			int t;
			cin >> t;
			if (t != 0) {
				b[i][t] = c[j][t] = d[f(i, j)][t] = 1;
				a[i][j] = t;
			} else {
				a[i][j] = 0;
			}
			*/
		}
	}
	dfs(1, 1);
	return 0;
}
```

---

## 作者：Objective (赞：4)

## 思路与算法

### 题目大意

题目给定一个未完成的数独（用 `.` 表示空格），保证有唯一解，要求输出填完后的数独。

忘记数独规则的~~和不会玩数独的~~看过来：

数独需要玩家在一个 $9 \times 9$ 的网格中填入数字 $1 \sim 9$，使得：

1. **每一行**包含 $1 \sim 9$ 且不重复；
2. **每一列**包含 $1 \sim 9$ 且不重复；
3. **每一个 $3 \times 3$ 的格子**包含 $1 \sim 9$ 且不重复。

### 算法

~~注意到，算法标签说明这是一道 DFS 题，~~

这里我们可以使用 DFS 遍历并枚举每一个空格所填的数，并检查是否合法。

所以，这里我们用的算法就会是 DFS（深度优先搜索）啦，~~也就变成了一道橙题~~。

## 代码
### C/C++：
```c
#include <stdio.h>
#include <stdbool.h>

char board[9][9];
bool solved = false;

bool isValid(int row, int col, char num) {
    for (int i = 0; i < 9; i++) {
        if (board[row][i] == num) {
            return false;
        }
    }
    for (int i = 0; i < 9; i++) {
        if (board[i][col] == num) {
            return false;
        }
    }
    int boxRow = row / 3 * 3;
    int boxCol = col / 3 * 3;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[boxRow + i][boxCol + j] == num) {
                return false;
            }
        }
    }
    return true;
}

void dfs(int row, int col) {
    if (row == 9) {
        solved = true;
        return;
    }
    if (col == 9) {
        dfs(row + 1, 0);
        return;
    }
    if (board[row][col] != '.') {
        dfs(row, col + 1);
        return;
    }
    for (char num = '1'; num <= '9'; num++) {
        if (isValid(row, col, num)) {
            board[row][col] = num;
            dfs(row, col + 1);
            if (solved) {
                return;
            }
            board[row][col] = '.';
        }
    }
}

int main() {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            scanf("%c", &board[i][j]);
        }
        getchar(); // 吃换行
    }
    dfs(0, 0);
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            printf("%c", board[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```
[其他语言（C#，Java，Python）](https://www.luogu.com.cn/paste/seqtaqvk)

---

## 作者：Yi_chen123 (赞：1)

## 思路

首先理解一下数独的规则，在 $9 \times 9$ 的矩阵中填上 $1,2,3,\cdots,9$ 这 $9$ 个整数，并且使每一行，每一列，每一宫都不能有重复的数字。\
可以按照类似八皇后问题的思想去做，考虑 DFS，从位置 $(0,0)$ 处开始填充，一直填充到 $(8,8)$ 结束。每一次填充时，枚举 $1$ 至 $9$ 的所有数，并判断是否合法（即判断在这个单元格所在的行、列、宫是否有重复的数），如果走到了死路，也就是填充不下去了，就往前回溯，尝试其他的数字。直到数独被填满，结束程序。\
具体的方法会在代码中提到。\
一个冻知识：我的 DFS 貌似**厌氧**，如果你们~~抄我的代码~~，记得**把 O2 优化关上**，不然会出现奇奇怪怪的字符。

## 代码

```cpp
#include<bits/stdc++.h>
#define test(x) cout << #x << " = " << x << endl
using namespace std;

char s[15][15]; //存储数独 
int col[15][15], row[15][15], g[15][15];
//row[i][j] 代表第 i 行是否出现过 j 这个数，1 代表有，0 代表没有
//col,g 同 row 数组，其中 col 代表列，g 代表宫 
int gong[15][15] = {
	{1, 1, 1, 2, 2, 2, 3, 3, 3},
	{1, 1, 1, 2, 2, 2, 3, 3, 3},
	{1, 1, 1, 2, 2, 2, 3, 3, 3},
	{4, 4, 4, 5, 5, 5, 6, 6, 6},
	{4, 4, 4, 5, 5, 5, 6, 6, 6},
	{4, 4, 4, 5, 5, 5, 6, 6, 6},
	{7, 7, 7, 8, 8, 8, 9, 9, 9},
	{7, 7, 7, 8, 8, 8, 9, 9, 9},
	{7, 7, 7, 8, 8, 8, 9, 9, 9},
};  //判断在哪一宫，本人比较懒直接打的表 

bool check(int x, int y, int fill_num){
	return !row[x][fill_num] && !col[y][fill_num] && !g[gong[x][y]][fill_num];
} //判断函数，判断 fill_num 填充在 (x,y) 的位置是否合法 
void print(){
	for(int i = 0; i < 9; ++i){
		for(int j = 0; j < 9; ++j){
			cout << s[i][j];
		}
		cout << endl;
	}
	exit(0); //记得提前终止程序，减少计算量 
}
void fill(int x, int y){
	int nxt_x = (y == 8 ? x + 1 : x); //下一次搜索的横、纵坐标 
	int nxt_y = (y == 8 ? 0 : y + 1);
	
	if(s[x][y] != '.'){ //填充过数了 
		if(x == 8 && y == 8) print(); //填满直接打印 
		fill(nxt_x, nxt_y); //继续深搜 
	}
	else{
		for(int q = 1; q <= 9; ++q){ //枚举所有可能的数字 
			if(check(x, y, q)){
				s[x][y] = q + '0';
				row[x][q] = col[y][q] = g[gong[x][y]][q] = true; //标记 
				if(x == 8 && y == 8) print();
				fill(nxt_x, nxt_y); //递归 
				s[x][y] = '.';
				row[x][q] = col[y][q] = g[gong[x][y]][q] = false; //回溯 
			}
		}
	}
}
signed main(){
    memset(s, 0, sizeof(s));
    for(int i = 0; i < 9; ++i){
    	for(int j = 0; j < 9; ++j){
    		cin >> s[i][j];
            if(isdigit(s[i][j])) row[i][s[i][j] - '0'] = col[j][s[i][j] - '0'] = g[gong[i][j]][s[i][j] - '0'] = true; //标记 
		}
	}
	fill(0, 0);
    return 0;
}
```

---

## 作者：wst000 (赞：1)

# 思路
本题思路和[这题](https://www.luogu.com.cn/problem/P1784)思路完全一样。定义 `dfs(x,y)` 为正在填写位置为 $(x,y)$ 的数。如果 $x$ 为 $10$，则表示已找到解，输出，结束程序。如果 $y$ 大于 $9$，则 `dfs(x+1,1)`。如果该位置已有数字，则 `dfs(x,y+1)`。如果没有，则填写一个合法的数，继续递归，如果无解，则回溯。
# CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
char s[15][15];
ll a[15][15];
bool b[15][15],b1[9][9],b2[9][9];
cll f[10][10]=
{	{0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,2,2,2,3,3,3},
	{0,1,1,1,2,2,2,3,3,3},
	{0,1,1,1,2,2,2,3,3,3},
	{0,4,4,4,5,5,5,6,6,6},
	{0,4,4,4,5,5,5,6,6,6},
	{0,4,4,4,5,5,5,6,6,6},
	{0,7,7,7,8,8,8,9,9,9},
	{0,7,7,7,8,8,8,9,9,9},
	{0,7,7,7,8,8,8,9,9,9}
};
void dfs(ll x,ll y){
	if(x==10){
		for(int i=1;i<=9;i++)
			printf("%s\n",s[i]+1);
		exit(0);
	}
	if(y>9){dfs(x+1,1);return;}
	if(s[x][y]!='.')dfs(x,y+1);
	else{
		for(int i=1;i<=9;i++){
			if(b[x][i]==0&&b1[y][i]==0&&b2[f[x][y]][i]==0){
				s[x][y]=i+'0',b[x][i]=1,b1[y][i]=1,b2[f[x][y]][i]=1;
				dfs(x,y+1);
				b[x][i]=0,b1[y][i]=0,b2[f[x][y]][i]=0,s[x][y]='.';
			}
		}
	}
}
int main() {
	for(int i=1;i<=9;i++){
		scanf("%s",s[i]+1);
		for(int j=1;j<=9;j++){
			if(s[i][j]!='.')b[i][s[i][j]-'0']=1,b1[j][s[i][j]-'0']=1,
				b2[f[i][j]][s[i][j]-'0']=1;
		}
	}
	dfs(1,1);
	return 0;
}
```

---

## 作者：PDcccc_M (赞：1)

## 题意
给定一个 $ 9 \times 9 $ 的未完成的数独，你需要输出已经填完的数独，`.` 表示没有填的地方。

## 思路
从 $ (0,0) $ 开始使用 DFS 枚举所有可能的填法，直到枚举到完整解，然后输出。

**具体过程如下**:
1. 查找第一个空着的格。
2. 尝试填入 $ 1 - 9 $ 中的合法数字。
3. 递归进入下一层。
4. 如果后续步骤失败就回溯。

## 代码
```cpp
#include <iostream>
using namespace std;

char mp[9][9];

// 检查填的数是否合法
bool valid(int x, int y, char num) {
    for (int i = 0; i < 9; i++) if (mp[i][y] == num) return false; // 检查行
    for (int i = 0; i < 9; i++) if (mp[x][i] == num) return false; // 检查列
    for (int i = x / 3 * 3; i < x / 3 * 3 + 3; i++) for (int j = y / 3 * 3; j < y / 3 * 3 + 3; j++) if (mp[i][j] == num) return false; // 检查 3x3 宫格
    return true; 
}

// DFS 函数
bool dfs() {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (mp[i][j] == '.') {
                for (int k = 1; k < 10; k++) {
                    if (valid(i, j, k + '0')) {
                        mp[i][j] = k + '0'; // 尝试填数
                        if (dfs()) return true; // 递归求解
                        mp[i][j] = '.'; // 如果失败，回溯
                    }
                }
                return false; // 所有尝试都失败了
            }
        }
    }
    return true; // 全部填满了
}

int main() {

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            cin >> mp[i][j];
        }
    }

    dfs();

    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            cout << mp[i][j];
        }
        cout << endl;
    }
    return 0;
}
```

时间复杂度 $ O(9^n) $，这里 $ n $ 为空格的数量。

---

## 作者：TJB_LHY (赞：1)

# 思路

一道深搜剪枝题。题目大意就是[数独的规则](https://wenku.baidu.com/view/829822e6cfbff121dd36a32d7375a417876fc150.html?fr=aladdin266\&ind=1\&aigcsid=0\&qtype=0\&lcid=1\&queryKey=%E6%95%B0%E7%8B%AC%E7%9A%84%E8%A7%84%E5%88%99\&verifyType=undefined&_wkts_=1743921062799\&bdQuery=%E6%95%B0%E7%8B%AC%E7%9A%84%E8%A7%84%E5%88%99)。我们不妨设三个布尔数组，分别记录每一行、每一列或每一个宫中某个数字是否已经使用过。暴搜填数时，判断填的该行该列该宫中是否使用过 $x$：若没有，则考虑填入；若有，则不填入。若完成填数，则输出方案即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define Code return
#define from 0
#define TJB_LHY ;
using namespace std;
bool h[9][10],l[9][10],g[10][10];//行、列和宫的布尔数组
char xxxx;
int a[9][9],b[9][9],gw[9][9]= {
	{1,1,1,4,4,4,7,7,7},
	{1,1,1,4,4,4,7,7,7},
	{1,1,1,4,4,4,7,7,7},
	{2,2,2,5,5,5,8,8,8},
	{2,2,2,5,5,5,8,8,8},
	{2,2,2,5,5,5,8,8,8},
	{3,3,3,6,6,6,9,9,9},
	{3,3,3,6,6,6,9,9,9},
	{3,3,3,6,6,6,9,9,9}//记录宫
},maxn=-1;
void dfs(int x,int y) {//暴搜
	if(x==9) {
		x=0;
		y++;
	}
	if(y==9) {
		for(int i=0;i<9;i++){
			for(int j=0;j<9;j++){
				cout<<b[i][j];
			}
			cout<<"\n";
		}//输出
		return;
	}
	b[x][y]=a[x][y];//赋初始值
	if(a[x][y]!=0)dfs(x+1,y);//已有，不换
	else {
		for(int i=1; i<=9; i++) {
			if(h[x][i] || l[y][i] || g[gw[x][y]][i])continue;//i使用过，不能用
			h[x][i] = l[y][i] = g[gw[x][y]][i]=1;//剪枝
			b[x][y]=i;
			dfs(x+1,y);//使用i
			h[x][i] = l[y][i] = g[gw[x][y]][i]=0;//改回来
		}
	}
}
int main() {
	for(int i=0; i<9; i++) {
		for(int j=0; j<9; j++) {
			cin>>xxxx;
            if(xxxx=='.')continue;
			a[i][j]=xxxx-'0';
			h[i][a[i][j]]=l[j][a[i][j]]=g[gw[i][j]][a[i][j]]=1;//输入
		}
	}
	dfs(0,0); //暴搜
	Code from TJB_LHY
}
```

---

## 作者：sillation (赞：0)

### [B4279 [蓝桥杯青少年组国赛 2023] 数独填数 ](https://www.luogu.com.cn/problem/B4279)DFS解法题解
这道题有点像[八皇后](https://www.luogu.com.cn/problem/P1219)的解题思路。只不过规则是数独的规则。


---

#### 思路
首先，先清楚数独的规则：

每一行包含数字 $1\sim9$ 且不重复；每一列包含数字 $1\sim9$ 且不重复；每一个 $3 \times 3$ 方块（粗线划分）包含数字 $1\sim9$ 且不重复。

对于以上三条规则我们可以用桶数组来记录和判断数字是否重复。

用 $ht_{i,j}$ 二维数组来表示第 $i$ 行的数字 $j$ 是否存在。用 $st_{i,j}$ 二维数组来表示第 $i$ 列的数字 $j$ 是否存在。用 $xt_{i,j}$ 二维数组来表示第 $i$ 个方块内数字 $j$ 是否存在，为了方便表示，我们可以设一个数组 $ch$ 用来表示第 $i$ 行第 $j$ 列的数是第几方块。

```cpp
//部分代码
bool ht[10][10],st[10][10],xt[10][10]；
int prox[100],proy[100],k;//prox 表示空格的行坐标，proy 表示列坐标。k 表示空格数量
char gt[10][10];//用字符数组存储数独，方便输入。
int ch[10][10]={
	{1,1,1,2,2,2,3,3,3},
	{1,1,1,2,2,2,3,3,3},
	{1,1,1,2,2,2,3,3,3},
	{4,4,4,5,5,5,6,6,6},
	{4,4,4,5,5,5,6,6,6},
	{4,4,4,5,5,5,6,6,6},
	{7,7,7,8,8,8,9,9,9},
	{7,7,7,8,8,8,9,9,9},
	{7,7,7,8,8,8,9,9,9}
};//初始化
```


然后，用 DFS 来搜索每一个空格，对于空格 $(x,y)$ 我们枚举数字 $i(1 \le i \le 9)$。如果 $ht_{x,i}$ 与 $st_{y,i}$ 与 $xt_{ch_{x,y},i}$ 都为 $0$，即数字 $i$ 在其行，列，方块内都没出现。那将空格 $(x,y)$ 暂设置为 $i$，并继续搜索下一个空格。如果没有符合条件的 $i$ 回溯上一个空格。


```cpp
//dfs部分代码
int tx=prox[x],ty=proy[x];
for(int i=1;i<=9;i++){
  if(!ht[tx][i]&&!st[ty][i]&&!xt[ch[tx][ty]][i]){
    ht[tx][i]=1;
    st[ty][i]=1;
    xt[ch[tx][ty]][i]=1;
    gt[tx][ty]=i+'0';
    dfs(x+1);
    ht[tx][i]=0;
    st[ty][i]=0;
    xt[ch[tx][ty]][i]=0;
    gt[tx][ty]='.';
  }
}
```


记得在搜索下一个空格前一定要将数组 $ht$，$st$，$xt$ 都标记为 $1$，表示数字 $i$ 在其行，列，方块上出现。回溯后记得全部标记为 $0$。

最后，当所有空格都填上数字时，就可以输出了。因为数独有唯一解，所以可以直接输出。



---

#### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool ht[10][10],st[10][10],xt[10][10];
int ch[10][10]={
	{1,1,1,2,2,2,3,3,3},
	{1,1,1,2,2,2,3,3,3},
	{1,1,1,2,2,2,3,3,3},
	{4,4,4,5,5,5,6,6,6},
	{4,4,4,5,5,5,6,6,6},
	{4,4,4,5,5,5,6,6,6},
	{7,7,7,8,8,8,9,9,9},
	{7,7,7,8,8,8,9,9,9},
	{7,7,7,8,8,8,9,9,9}
};
int prox[100],proy[100],k;
char gt[10][10];
void dfs(int x){
	if(x>k){
			for(int i=0;i<9;i++){
				for(int j=0;j<9;j++)cout<<gt[i][j];
				cout<<endl;
			}
			exit(0);
	};
	int tx=prox[x],ty=proy[x];
	for(int i=1;i<=9;i++){
		if(!ht[tx][i]&&!st[ty][i]&&!xt[ch[tx][ty]][i]){
			ht[tx][i]=1;
			st[ty][i]=1;
			xt[ch[tx][ty]][i]=1;
			gt[tx][ty]=i+'0';
			dfs(x+1);
			ht[tx][i]=0;
			st[ty][i]=0;
			xt[ch[tx][ty]][i]=0;
			gt[tx][ty]='.';
		}
	}
	return ;
}
int main(){
	for(int i=0;i<9;i++)
	{
		cin>>gt[i];
		for(int j=0;j<9;j++){
			if(gt[i][j]!='.'){
				ht[i][gt[i][j]-'0']=1;
				st[j][gt[i][j]-'0']=1;
				xt[ch[i][j]][gt[i][j]-'0']=1;
			}
			else{
				prox[++k]=i;
				proy[k]=j;
			}
		}
	}
	dfs(1);

}
```

---

## 作者：yihang2011 (赞：0)

### [B4279 [蓝桥杯青少年组国赛 2023] 数独填数](https://www.luogu.com.cn/problem/B4279)

[P1784](https://www.luogu.com.cn/problem/P1784) 双倍经验。

DFS 好题。

用三个数组，分别记录在每一行、每一列、每个宫某个数字出没出现过，然后搜索。每搜到一个空格就从 1~9 试一遍，如果行、列、宫都没有出现过就填上搜下一个格子。每当一行搜到第十列时转到下一行，当搜到第十行第一列时结束并输出，然后 `exit(0)` **直接退出**，已经找到一组解就不用找第二组了。这道题貌似不会卡这个点，但双倍经验不退出会 [TLE](https://www.luogu.com.cn/record/99763674)。

时间复杂度 $\mathcal{O}(9^n)$，$n$ 为数独空格数，虽然是指数级别的，但由于空格数很少还有很多数在行、列、宫都出现过不会搜索，所以实际上的时间复杂度会小很多，这题数据很水，[38 毫秒](https://www.luogu.com.cn/record/215661624)过掉所有数据点。

```cpp
#include <iostream>
using namespace std;

int a[10][10];
bool flag1[10][10], flag2[10][10], flag3[10][10];

int m[10][10] = {
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
	{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
};

void dfs(int x, int y) {
	if (x == 10 && y == 1) {
		for (int i = 1; i <= 9; i++) {
			for (int j = 1; j <= 9; j++) {
				cout << a[i][j];
            }
			cout << endl;
		}
		exit(0);
	}
	int x_new = x, y_new = y + 1;
	if (y_new == 10) {
        y_new = 1, x_new++; 
    }
	if (a[x][y] != 0) {
        dfs(x_new, y_new);
	} else {	
		for (int i = 1; i <= 9; i++) {
			if (flag1[x][i] || flag2[y][i] || flag3[m[x][y]][i]) {
				continue ;
            }
			a[x][y] = i,
			flag1[x][i] = true,
			flag2[y][i] = true,
			flag3[m[x][y]][i] = true;
			dfs(x_new, y_new);
			a[x][y] = 0,
			flag1[x][i] = false,
			flag2[y][i] = false,
			flag3[m[x][y]][i] = false;			
		}
	}
}

int main() {
	for (int i = 1; i <= 9; i++) {
		for (int j = 1; j <= 9; j++)
		{
            char c;
            cin >> c;
            if (c == '.') {
                continue ;
            }
            a[i][j] = c - '0';
			flag1[i][a[i][j]] = true,
			flag2[j][a[i][j]] = true,
			flag3[m[i][j]][a[i][j]] = true;
		}
    }
	dfs(1, 1);
	return 0;
}
```

---

## 作者：scc36 (赞：0)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4279)   
### 思路
照题目背景说的，本题使用的数独均较为简单，故不需要各种神仙优化，直接暴力搜索即可。   
对于每一个空的位置，将 1 至 9 依次放入，比较与它同行、同列、同九宫格的其它元素是否有重复。如果有就跳过，没有就继续找下一个空格。  
对于如何找同一九宫格这一问题：设这个空的位置是 $(x,y)$（编程中的坐标），如果 $x$ 是三的倍数，则这个位置所在九宫格的纵坐标范围就是 $[x-2 , x]$，否则就是 $[ \lfloor \frac{x}{3} \rfloor \times 3 - 2 , \lfloor \frac{x}{3} \rfloor \times 3 ]$。横坐标同理。
### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int i,j,v;
char a[101][101];
void sc(int x,int y,int t){ //搜索
	int i,j,k,xx,yy,fl;
	if(t==v){ //全部找完了，输出
		for(i=1;i<=9;i++){
			for(j=1;j<=9;j++)
				cout<<a[i][j];	
			cout<<"\n";		
		}
		exit(0);
	}
	if(a[x][y]=='.'){
		for(i=1;i<=9;i++){
			fl=0;
			for(j=1;j<=9;j++) //判断行
				if(a[x][j]-48==i){
					fl=1;
					break;
				}
			if(fl==1) continue;

			for(j=1;j<=9;j++) //判断列
				if(a[j][y]-48==i){
					fl=1;
					break;
				}
			if(fl==1) continue;

			if(x%3==0) xx=x/3;
			else xx=x/3+1;
			if(y%3==0) yy=y/3;
			else yy=y/3+1;
			for(j=xx*3-2;j<=xx*3;j++){ //判断九宫格
				for(k=yy*3-2;k<=yy*3;k++)
					if(a[j][k]-48==i){
						fl=1;
						break;
					}	
				if(fl==1) break;				
			}
			if(fl==1) continue;

			a[x][y]=char(i+48);
			xx=x,yy=y+1;
			if(yy>9) xx++,yy=1;
			sc(xx,yy,t+1);
			a[x][y]='.';
		}
	}
	else{
		xx=x,yy=y+1;
		if(yy>9) xx++,yy=1;
		sc(xx,yy,t);	
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	for(i=1;i<=9;i++)
		for(j=1;j<=9;j++){
			cin>>a[i][j];
			if(a[i][j]=='.') v++;//记录空格总数
		}
	sc(1,1,0);
}
```

---

## 作者：ryderyang (赞：0)

# 题意简述
给我们一个数独盘面，让我们输出可行解，题目保证数独有且仅有一个可行解。
# 解题思路
都是数独了，肯定要用深搜，具体怎么写呢？

  - 对于每一个格，如果数独上已有的数字，直接递归进入下一层。
  - 否则，尝试将 $1$ 到 $9$ 的每一个数填入。
  - 如果这一行，这一列，这一宫格都没有当前的这个数字，我们就可以把数字填到这个格里，递归进入下一层。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10][10];
map<pair<int,int>,int> mp1,mp2,mp3;
int ans=-1;
string s;
void dfs(int i,int j)
{
	int num=0;
	if(i==10)
	{
		for(int i=1;i<=9;i++)
		{
			for(int j=1;j<=9;j++)
			printf("%d",a[i][j]);
			printf("\n");
		}
		return;
	}
	if(a[i][j])
	{
		if(j==9)
		dfs(i+1,1);
		else
		dfs(i,j+1);
		return;
	}
	for(int num=1;num<=9;num++)
	{
		if(mp1[make_pair(i,num)])
		continue;
		if(mp2[make_pair(j,num)])
		continue;
		if(mp3[make_pair((((i+2)/3-1)*3+(j+2)/3),num)])
		continue;
		a[i][j]=num;
		mp1[make_pair(i,num)]=true;
		mp2[make_pair(j,num)]=true;
		mp3[make_pair((((i+2)/3-1)*3+(j+2)/3),num)]=true;
		if(j==9)
		{
			dfs(i+1,1);
		}
		else
		{
			dfs(i,j+1);
		}
		a[i][j]=0;
		mp1[make_pair(i,num)]=false;
		mp2[make_pair(j,num)]=false;
		mp3[make_pair((((i+2)/3-1)*3+(j+2)/3),num)]=false;		
	}
}
int main()
{
	for(int i=1;i<=9;i++)
	{
		cin>>s;
		s=" "+s;
		for(int j=1;j<=9;j++)
		{
			if(s[j]=='.')
			a[i][j]=0;
			else
			a[i][j]=s[j]-'0';
			mp1[make_pair(i,a[i][j])]=true;
			mp2[make_pair(j,a[i][j])]=true;
			mp3[make_pair((((i+2)/3-1)*3+(j+2)/3),a[i][j])]=true;
		}
	}
	dfs(1,1);
	return 0;
}
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
这道题数据很小，我们可以考虑深度优先搜索去枚举每个空格里的数。每次填数时，都判断一下填进去之后 $a$ 数组是否合法。如果我们一直递归到底都没有找到正确的解，就回溯一下再去尝试下一个数字直到数组装满为止。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[10][10];
bool f(int x,int y,char k){
    for(int i=1;i<=9;i++)if(a[x][i]==k)return 0;//行 
    for(int i=1;i<=9;i++)if(a[i][y]==k)return 0;//列 
    int xx=(x-1)/3*3+1,yy=(y-1)/3*3+1;
    for(int i=0;i<3;i++)for(int j=0;j<3;j++)if(a[xx+i][yy+j]==k)return 0;//方块 
    return 1;
}
bool dfs(){
    for(int i=1;i<=9;i++)for(int j=1;j<=9;j++){
        if(a[i][j]=='.'){
            for(char k='1';k<='9';k++){
                if(f(i,j,k)){
                    a[i][j]=k;
                    if(dfs())return 1;
                    a[i][j]='.';//回溯 
                }
            }
            return 0;//找不到解 
        }
    }
    return 1;//数组装满 
}
int main(){
    for(int i=1;i<=9;i++)for(int j=1;j<=9;j++)cin>>a[i][j];
    dfs();
    for(int i=1;i<=9;i++){
        for(int j=1;j<=9;j++)cout<<a[i][j];
        cout<<endl;
    }
    return 0;
}
```

---


# [蓝桥杯青少年组省赛 2022] 组合

## 题目描述

某商店将一种糖果按照数量打包成 $N$ 和 $M$ 两种规格来售卖（$N$ 和 $M$ 为互质数，且 $N$ 和 $M$ 有无数包）。这样的售卖方式会限制一些数量的糖果不能买到。现在给出 $N$ 和 $M$ 的值，请你计算出最多不能买到的糖果数量。


## 样例 #1

### 输入

```
3 5```

### 输出

```
7```

# 题解

## 作者：xuyixuan_123 (赞：6)

## 思路：
**塞瓦维斯特定理**
> 已知 $a$ 和 $b$ 为大于1的正整数，且 $\gcd(a,b)=1$ ，则使不定方程 $ax + by=C$ 不存在非负整数解的最大整数为 $C=a \times b − a − b$。

于是就有了这个公式：
 $$n \times m − n − m$$ 
当然，我们有了公式还不行，还得有证明。
## 证明:
- 我们先来证明 $a \times b - a - b$ 一定不能被取到。利用反证法，我们假设存在 $x,y \ge 0$ 满足 $ax + by=a \times b - a - b$ 。我们将 $ab$ 除到左边来，即 $a(x + 1) \div ab + b(y + 1) \div ab=1$ ，在消一下即可得到 $(x + 1) \div b+(y + 1) \div a=1$ 。这与我们假设中的 $a(x + 1)+b(y + 1)=ab$ ， $a \ge 0,b \ge 0$ 矛盾。因此，假设不成立，即不存在 $x,y \ge 0$ ，满足 $ax + by=a \times b - a - b$ 。
- 接下来，我们需要证明当 $C>a \times b - a - b$ 时， $ax + by=C$ 一定存在非负整数解。考虑到 $ax + by = C$ 可以通过扩展欧几里得算法求解，而扩展欧几里得算法可以在 $\gcd(a,b)=1$ 的情况下找到 $ax + by = \gcd(a,b)$ 的整数解。由于 $a$ 和 $b$ 互质，我们可以找到 $ax+by=1$ 的整数解。因此，对于任何大于 $a \times b - a - b$ 的 $C$ ，我们都可以通过将 $ax + by = 1$ 的解乘以适当的系数来找到 $ax + by = C$ 的非负整数解。

>综上所述，我们已经证明了塞瓦维斯特定理（不定方程）：对于互质的正整数 $a$ 和 $b$ ，不定方程 $ax+by=C$ 不存在非负整数解的最大整数 $C$ 等于 $a \times b - a - b$。
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main(){
	cin>>n>>m;
	cout<<n*m-n-m;
	return 0;
}
```

---

## 作者：Wangchenxi2013 (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/B4284)

[关于塞瓦维斯特定理](https://blog.csdn.net/2301_79379567/article/details/135882447)
## 结论
这是一道结论题，答案为 $(n-1)(m-1)-1$。以下给出证明。
## 证明
证明需考虑反证法：

设存在 $ax+by=(a-1)(b-1)-1$。

则 $a(x+1)+b(y+1)=ab$。

$\because b(y+1)=a(x-1-b)$ 且 $gcd(a,b)=1$，$\therefore a\mid(y+1)$，同理 $b\mid(x+1)$。

$\therefore (x+1)\div b+(y+1)\div a\ge 2$。

但当我们把 $ab$ 除过去，就会变成 $(x+1)\div b+(y+1)\div a=1$，与上面矛盾，故假设不成立，故不存在 $ax+by=(a-1)(b-1)-1$。

## 代码
证明之后代码就很简单了：
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int x,y;
	cin>>x>>y;
	cout<<(x-1)*(y-1)-1;
}
```

---

## 作者：Make_China_Great (赞：3)

## 思路

题目说将一种糖果按照数量打包成 $N$ 和 $M$ 两种规格来售卖（$N$ 和 $M$ 互质，且 $N$ 和 $M$ 有无数包），让我们求出最多不能买到的糖果数量。

我看了大家的几篇题解，大多都是套用那个公式的，所以我在这里提供一个动态规划的做法。

1. 建立一个布尔类型的数组 $dp$。作用是什么呢？作用就是 $dp_i$ 表示是否可以用题目中提到的“组合”来得到数量为 $i$ 的糖果。

1. 对于每个数，检查 $i-n$ 或者 $i-m$ 它呢是能组成，如果满足就把这个位置标记为可以组成。

1. 最后看看最大的是哪一个就可以了！

转移方程：

如果 $i\ge n$ 且 $ dp_{i-n}\ne 0$ 那么 $dp_i=1$。

如果 $i\ge m$ 且 $dp_{i-m}\ne 0$ 那么 $dp_i=1$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, t, maxx;
bool dp[20005];
int main() {
	cin >> n >> m;
	dp[0] = true;
	for (int i = 1; i <= 2 * n * m; ++i) {
		if (i >= n && dp[i - n]) dp[i] = true;
		if (i >= m && dp[i - m]) dp[i] = true;
	}
	for (int i = 2 * n * m; i >= 1; --i) {
		if (!dp[i]) {
			maxx = i;
			break;
		}
	}
	cout << maxx << endl;
	return 0;
}
```

---

## 作者：FISH酱 (赞：2)

## 前置知识

你需要了解简单动态规划、基础语法、基础数学知识，本题建议降橙。

## 思路讲解

题目给出两种规格的糖果，规格一为 $N$ 颗糖一包，规格二为 $M$ 颗糖一包，每种规格都有无数包，可自由组合购买，现在要我们求出最多不能买到的糖果数。

考虑 $N$ 和 $M$ 的数据范围，我们把最大答案边界定为 $10^8$，使用线性动态规划进行求解，数组使用布尔类型，即分为能买到和不能买到：先初始化，$0$ 颗糖、$N$ 颗糖、$M$ 颗糖肯定能够买到，将值设为 $1$；接着，我们处理 $1$ 到 $10^8$，对于每个数量 $i$，我们判断 $i - n$ 和 $i - m$ 是否能被买到，其中一个条件成立就能被买到，因为再买一个 $N$ 或 $M$ 颗糖果的规格，就可以组成；最后，每次发现不能被买到后，更新最大值答案。

## 代码展示

代码仅供参考，下面是我的代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

int n,m,ans; // 定义变量。
bool dp[100000007]; // 开设一个大小足够的动态规划布尔数组。

int main(){
	cin >> n >> m; // 读入。
	
	dp[0]=dp[n]=dp[m]=1; // 初始化。
	for(int i=1;i<=100000000;i++){ // 处理不同的糖果数。
		if(i>=n&&dp[i-n]==1) dp[i]=1; // i-n能被买到，说明再买一个 N 颗糖果的规格，就能组成。
		else if(i>=m&&dp[i-m]==1) dp[i]=1; // 思路同上。
		if(dp[i]==0) ans=max(ans,i); // 如果不能被买到，更新最大值答案。
	} 
	
	cout<<ans; // 输出答案。
	
	return 0; // 完结撒花！
}
```

---

## 作者：Noah03 (赞：2)

### 分析

---

解决这道题需要用到塞瓦维斯特定理。

定理内容：设有 $a,b$ 两正整数互质，则不满足方程 $ax+by=c$（$x,y$ 均为整数）的最大正整数 $c$ 为 $a \times b-a-b$。

证明：首先，根据方程可以得到 $0 \le x \lt b$（若 $x \ge b$，则 $ax+by=a(x-b)+b(a+y)$）。如果 $y\ge0$，则 $c$ 一定是能被表示出来的，所以 $y$ 取 $-1$（$y$ 再减小就达不到最大了）。又因为 $c$ 取最大，所以 $x$ 取最大，即 $x=b-1$，得出结论 $c=ax+by=a(b-1)-b=a \times b-a-b$，证毕。

根据这个定理，可以得到答案就是 $a \times b-a-b$。

### 代码

---

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    scanf("%d %d",&n,&m);
    printf("%d\n",n*m-n-m);
    return 0;
}
```

代码十分简单，不作解释。

**The End.**

---

## 作者：__CJY__ (赞：2)

## 思路
### 塞瓦维斯特定理
>已知 $a,b$ 为大于 $1$ 的数，则 $\gcd(a,b)=1$，那么使不定方程 $ax+by=C$ 不存在非负整数解的最大整数 $C=a \times b-a-b$。

直接套用公式输出即可：
$$n \times m-n-m$$
这里就不证明了，想要深度学习请参考[这里](https://www.cnblogs.com/My-flurry/p/11610075.html)。
### 动态规划
这题一看就是典型 DP。

我们用 $f_i$ 表示是否可以组合成 $i$ 个糖果。显而易见的是，当 $f_{i-n}=1 \lor f_{i-m}=1$ 时，$f_i \gets 1$。

最后**从后往前**找到最大值就行了。

记住把 $f_0 \gets 1$。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m;cin>>n>>m;
	cout<<n*m-n-m;
}
```
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=10005;
bool f[maxn];
int n,m;
int main(){
	cin>>n>>m,f[0]=1;
	for(int i=1;i<=n*m;i++){
		if((i>=n&&f[i-n])||(i>=m&&f[i-m])) f[i]=1;//要判断 i>=n 和 i>=m
	}
	for(int i=n*m;i;i--){
		if(!f[i]){cout<<i;return 0;}
	}
}
```

---

## 作者：lvweisi (赞：1)

### 思路：
提供一个有趣的解法，这道题其实并没有想象中的那么困难，甚至黄色都评的有点高了，我们可以发现 $2<N<M<100$ ，所以我们可以枚举每一种可能，将所有的答案存储在一个桶中最后从 $1$ 开始枚举找出不存在的最大值即可。

### 代码如下：
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int maxx=0;
int mp[10000007];//桶数组
int main(){
	cin>>n>>m;
	for(int i=0;i<=500;i++){
		for(int j=0;j<=500;j++){//枚举500就够了，甚至还多了
			if(i*n+j*m>10000000)continue;//到上限了
			mp[i*n+j*m]=1;
		}
	}
	for(int i=1;i<=min(500*n,500*m);i++)if(mp[i]==0)maxx=i;//找到最大值
	cout<<maxx;
	return 0;
}
```
都看到这里了，这么朴实无华的代码真的不点个赞吗awa。

---

## 作者：Charged_Charge (赞：1)

# 洛谷 B4284
## 解题思路：
先求出 $n$ 和 $m$ 的最小公倍数。因为 $n$ 和 $m$ 都为质数，所以，最小公倍数就是两数的乘积。由于最小公倍数是两数之积，所以最小公倍数是包含 $m$ 个 $n$ 且包含 $n$ 个 $m$ 的。而不能买到的糖果就是总糖数也就是最小公倍数减去能买到的 $n$ 的个数 $m$ 和能买到的 $m$ 的个数 $n$ 的差。
## AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m;
int main() {
    cin >> n >> m;
    cout << n * m - n - m;
    return 0;
}
```

---

## 作者：huxuanrui19 (赞：1)

# B4284题解
[题目传送门](http://luogu.com.cn/problem/B4284)

这又是一道原题 [原题传送门](https://www.luogu.com.cn/problem/P3951)
## 题目大意
给定两个素数 $a$ 和 $b$，保证 $\gcd(a,b)=1$，求出最大的 $c$ 使得不定方程 $ax + by = c$ 无非负整数解。

### 思路
这里就是~~著名的~~塞瓦维斯特定理：
>对于已知 $a$ 和 $b$ 为大于 $1$ 的正整数，$\gcd(a,b)=1$，使不定方程 $ax + by = c$ 无非负整数解的最大整数 $c$ 为 $ab−a−b$ 。
### 证明

证明分为三个部分：

第一部分：证明 $ab - a - b$ 无解。

假设存在非负整数解 $(x,y)\geq 0$ 使得：
$ ax + by = ab - a - b $
整理得：
$ a(x + 1) + b(y + 1) = ab $

由于 $a$ 与 $b$ 互素，可得：
$$\begin{align*}
a \mid (y + 1) &\Rightarrow y + 1 = ka \quad (k \geq 1) \\
b \mid (x + 1) &\Rightarrow x + 1 = \ell b \quad (\ell \geq 1)
\end{align*}$$

代入原式：
$ a(\ell b) + b(ka) = ab $

$ \ell ab + k ab = ab $

$ \ell + k = 1 $

这与 $\ell, k \geq 1$ 矛盾。因此 $c = ab - a - b$ 无解。

___

第二部分：证明所有 $c > ab - a - b$ 都有解。

设 $c > ab - a - b$。

因为 $\gcd(a,b)=1$，存在整数解 $(x_0,y_0)$ 

满足：
$ ax_0 + by_0 = c$

通解可表示为：

$$\begin{align*}
x = x_0 + bt \\
y = y_0 - at \\
\end{align*}$$

其中 $t$ 为任意整数。

取适当的 $t$ 使得 $0 \leq y = y_0 - at < a$（即取 $t = \lfloor y_0/a \rfloor$）。

此时：
$ ax = c - by > ab - a - b - b(a-1) = -a $

因为 $ax > -a$ 且 $a>0$，故 $x \geq 0$。
因此 $(x,y)$ 是非负整数解。

___

第三部分：证明 $ab - a - b$ 是最大的无解数。

由第一部分知 $ab - a - b$ 无解，第二部分表明所有更大的整数都有解，因此 $ab - a - b$ 确为最大的无解整数。
## 代码
主体也只剩下这一句话了：
```cpp
cout<<a*b-a-b;
```
谢谢阅读。

---

## 作者：linkai20111030 (赞：1)

### 题目大意：

求不定方程 $C=ax+by$ 的最大解。

解决这类问题要用到：

### 塞瓦维斯特定理

一 定理内容
设 $a$，$b$ 为互质的正整数（即 $\gcd (a,b)=1$，则：

最大不可表示数：存在最大的整数 $C=ab−a−b$，使得不定方程 $ax+by=C$ 没有非负整数解 $(x,y)$。

所有更大的数均可表示：对于任意整数 $n>ab−a−b$，方程 $ax+by=n$ 至少有一个非负整数解。

### 定理证明：

证明所有 $n>ab−a−b$ 均可表示
可用构造法证明。

对于任意 $n>ab−a−b$，考虑方程 $ax+by=n$ 的通解：$x=x_0+bt$, $y=y_0−at$ 其中 $(x_0,y_0)$ 是某个特解（由裴蜀定理，存在整数解），$t$ 为任意整数。调整 $t$ 使得 $0≤x≤b−1$，则：$y=bn−ax$ 只需证明 $y≥0$。假设 $y<0$，则： $n−ax<0⟹n<ax≤a(b−1)=ab−a$ 但 $n>ab−a−b$，因此： $ab−a−b<n<ab−a⟹−b<0$ 显然成立，矛盾。故 $y≥0$，存在非负解。

得出公式 $n×m−n−m$。

所以代码就很简单了。

```.cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
signed main(){
	cin>>n>>m;
	cout<<n*m-n-m;
}
```

---

## 作者：__SandMinecraft__ (赞：0)

### 题意

- 商店将糖果打包成两种规格：$ N $ 和 $ M $，且 $ N $ 和 $ M $ 是互质的，每种规格的糖果可以买无限多包。

- 有些数量的糖果无法通过购买若干包 $ N $ 和 $ M $ 的组合来得到。找出最大的不能买到的糖果数量。

    ~~总结的比题目本身还多。~~

### 思路、代码

考虑~~暴力~~ **DP**。

DP五大项如下，其中 $ \text{maxn} = N \cdot M $，为最大检查范围（答案不可能超过它）：

- 定义：$dp_i$ 表示数字 $ i $ 是否能被买到，值为1能，反之不能。

- 要求的答案：$ res = \max \{ i \in [1,\text{maxn}] \land dp[i] = 0 \} $。

- 状态转移方程：如果 $ dp_{i-N} $ 能被买到，那么你可以再买一盒 $N$ 规格的，这样 $ dp_i $ 同样可以买到，$ M $ 同理，故状态转移方程为 $dp_i = dp_{i-N} \lor dp_{i-M} $。

- $ dp_0 = 1 $ （其实可以被表示，虽然题目要求正整数），$dp_i = 1 \quad (1 \leq i \leq \text{maxn})$。

- 时间复杂度：$O(N \cdot M)$。

有了这些写代码不是问题：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,dp[10010],maxn; //要开两倍，满足最大检查范围
signed main(){
    cin>>n>>m;
    dp[0]=1;
    maxn=n*m;
    for(int i=1;i<=maxn;i++){ //其实小于min(n,m)的已经买不到了
        if(i>=n&&dp[i-n]||i>=m&&dp[i-m])dp[i]=1;
        //状态转移方程，只不过别RE，判断一下
    }
    for(int i=maxn;i>=1;i--){
        if(dp[i]==0){cout<<i;return 0;}
        //最大的res
    }
    //不可能！程序无法走到这一步
    return 0;
}
```

---

## 作者：_luogu_huowenshuo_ (赞：0)

## 思路
给定两种糖果规格 $N$ 和 $M$（互质，$2 < N < M < 100$），可以购买任意非负整数包的 $N$ 或 $M$ 颗糖果，组成数量为 $a\times N + b\times M$（$a, b \geq 0$）。求最大不能表示的糖果数量（弗罗贝尼乌斯币值问题）。

由于 $N$ 和 $M$ 互质，弗罗贝尼乌斯公式给出最大不可表示数为：
$$
N \times  M - N - M
$$
## 证明
若 $ a \geq M $，则 $ c = a\times N + b\times M = (a - M)\times N + (b + N)\times M $。取 $ 0 \leq a < M $，$ b = -1 $，$ a = M - 1 $，得 $ c = N \times (M - 1) - M = N \times  M - N - M $，不可表示且最大。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m;
int main(){
    cin>>n>>m;
    cout<<n*m-n-m;
    return 0;
}
```

---

## 作者：Chase12345 (赞：0)

无聊看到的数论水题。

这一眼就是小学二年级学过的不定方程的最大无解数的问题啊。（之前考某个数学杯赛的时候枚举法做了，然后出来大家都说是水题就写了一行）

有一个结论，就是如果 $C$ 用 $a,b$ 的线性组合表示，其中 $\gcd(a,b)=1$，则 $C_{\max}=a \times b - a - b$。用这个结论就十分容易写出代码。

接下来正是难点，证明：
> 第一部分：证明：
> $$
> \forall x,y \in \mathrm{N^+} \space ax+by \neq ab-a-b
> $$
> 转化一下，假设存在：
> $$
> ax+by = ab-a-b\\
> a\times(b-1-x)=b(y+1)\\
> $$
> 又 $\gcd(a,b)=1$，所以必须有：
> $$
> b \mid b-1-x
> $$
> 其中 $\mid$ 为整除。
>
> 所以不难发现，只有 $x=b-1$ 满足。代入原方程，容易得到此时 $y<0$，显然矛盾。所以不存在这样的 $x,y$。
>
> 第二部分，证明最大。假设 $n>ab-a-b$。
>
> 考虑对 $n$ 模 $b$，存在唯一的 $k \in [0,b-1]$，使得 $n \equiv k \pmod{b}$。由 $\gcd(a,b)=1$，存在 $x \ge 0$，使得 $ax \equiv k \pmod{b}$，且 $x \le b-1$。令 $y=\frac{n-ax}{b}$，我们要证明的也就只剩下 $y \ge 0$ 了。
>
> 注意到 $ax<a(b-1)$，所以 $n-ax \ge (ab-a-b+1)-a(b-1)=1-b$。由 $b \mid n-ax$ 且大于 $-b$，则 $n-ax \ge 0$，那么 $y \ge 0$。
>
> 完结撒花。

代码是容易的。
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    cout << n * m - n - m << '\n';
    return 0;
}
```

---

## 作者：TJB_LHY (赞：0)

# 思路

一道~~略有难度的~~数学题。因为 $n$ 和 $m$ 互质，所以 $k \times m \bmod n$（$k$ 为非负整数）是一定可以覆盖在模 $n$ 意义下大于 $m\times(n-1)$ 的整数的。所以只需要用完全背包求出小于等于 $m\times(n-1)$ 中不可以买到的糖果数量，取最大值即可。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
int n, m, k, maxn;
bool dp[10105];
int main() {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n >> m;
	k = m * (n - 1);
	dp[0] = 1;	// 什么也没有，可以买到
	for (int i = n; i <= k; i++) dp[i] = dp[i] | dp[i - n];
	for (int i = m; i <= k; i++) dp[i] = dp[i] | dp[i - m];	 // 完全背包
	for (int i = 1; i <= k; i++)
		if (!dp[i]) maxn = max(maxn, i);  // 取最大值
	cout << maxn;
	return 0;
}
```

（本题有一定思考难度 ~~，大家请自主思考，锻炼思维~~）

---

## 作者：wangjue1629 (赞：0)

# 题目背景与证明

我们可以把这道题看作 **Frobenius 硬币问题** 的一个简单例子。题目的意思是：店里有两种规格的糖果包装，分别为 $n$ 和 $m$（且二者互质），也就是说对于足够大的数，我们都可以使用它们来进行组合，但对于较小的数，有一些是凑不出来的。这种问题也叫鸡尾酒问题。

**结论**：对于两个互质的正整数 $n$ 和 $m$，最大的买不到的糖果数量是：
$
n \times m - n - m.
$

例如，当 $n = 2$ 且 $m = 3$ 时：
- $2$：买 1 包 2 个  
- $3$：买 1 包 3 个  
- $4$：$2+2$  
- $5$：$2+3$  
- $6$：$3+3$ 或 $2+2+2$  
但是 $1$ 凑不出来，这正好符合公式：  
$
2 \times 3 - 2 - 3 = 1.
$

---

## 理论证明

证明可以分为两部分：

### 1. 证明 $ n \times m - n - m $ 不可表示

**证明思路（反证法）：**

假设存在非负整数 $a,b$ 使得
$
n \times m - n - m = a \times n + b \times m.
$
两边同时加上 $a + b$ 得到：
$
n \times m = n \times (a+1) + m \times (b+1).
$
设定：
$
a' = a+1,\quad b' = b+1,
$
那么 $ a' \ge 1, b' \ge 1 $ 且等式变为
$
n \times m = n \times a' + m \times b'.
$
经过整理，可以写成
$
n (m - a') = m \times b'.
$

由于 $n$ 与 $m$ 互质，而 $n$ 不能整除 $m$（因此也不能整除 $ m \times b' $ 除非整除 $ b' $，就必定存在一个正整数 $k$ 使得

$
b' = k \cdot n.
$
将其代入原式后得到矛盾，从而证明了 $ n \times m - n - m $ 无法表示成 $ a \times n + b \times m $ 的形式。

> **补充说明**：另一种证明方法是利用数学归纳法证明所有大于等于 $(n-1)(m-1)$ 的数均可以表示，而由
> $$
> (n-1)(m-1) = n \times m - n - m + 1,
> $$
> 可推出最大不可表示数为 $ n \times m - n - m $。

### 2. 证明所有大于 $ n \times m - n - m $ 的正整数均可表示

根据经典的鸡尾酒证明，两个互质正整数 $ n $ 和 $ m $ 可表示所有大于或等于 $(n-1)(m-1)$ 的整数。而
$
(n-1)(m-1) = n \times m - n - m + 1,
$
所以任一大于 $ n \times m - n - m $ 的正整数都可以表示出来。

---

## AC CODE


```cpp
#include <iostream>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    cout << n * m - n - m << endl;
    return 0;
}
```
时间复杂度：$O(1)$ 可以通过此题

---


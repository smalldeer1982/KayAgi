# [蓝桥杯青少年组省赛 2022] 组合

## 题目描述

某商家将一种汤圆按照数量不同，分装成 $N$ 种规格来售卖。这样的售卖方式会限制一些数量的汤圆买不到。

例如：
- 当 $N=2$ 时，$2$ 种规格的汤圆分别装 $3$ 个和 $5$ 个，这种情况下限制了 $1$、$2$、$4$、$7$ 四种数量的汤圆不能买到。

给出 $N$ 及 $N$ 种规格的汤圆数量，请计算出有多少种数量的汤圆不能买到。如果有无限种数量的汤圆不能买到，就输出 $-1$。

## 样例 #1

### 输入

```
2
3 5```

### 输出

```
4```

# 题解

## 作者：Yxa_Sheep (赞：7)

**[题目传送门](https://www.luogu.com.cn/problem/B4290)**
## 题意
给定 $n$ 个数，每个数可以用无限次。求无法组成的数有多少个，如果有无限个就输出 $-1$。
## 思路
做题先看标签：动态规划+数论。在脑子里面规划一下，输出 $-1$ 用数论，输出正常答案用动规。  
至于 $-1$ 怎么判，相信大家都有思路了。如果这 $n$ 个数不互质（最小公因数不等于 $1$），那么就输出 $-1$。为什么呢？假设这 $n$ 个数的最小公因数为 $g$，那么必须是 $g$ 的倍数才能被这 $n$ 个数组合出来。举个栗子，$4$ 和 $6$ 这两个数的最小公因数是 $2$，必须是 $2$ 的倍数的数才有可能被组合出来。  
接下来是输出正常答案了。我们先设定状态，$f_i$ 表示能否组合出 $i$。状态转移方程很好推，我们设输入的长度为 $n$ 的序列叫 $a$，枚举一个 $j$ ，如果 $f_{i-a_j}=1$ 的话那么 $f_i=1$，反之则为 $0$。但是我们要到什么时候结束呢？设序列 $a$ 中的最小值为 $minn$，则在出现连续 $minn$ 次为 $f_i$ 为 $1$ 的时候退出。由于不确定长度，我们可以用 vector 存下 $f$ 数组。这里注意肯定可以凑出 $0$ 个汤圆，所以 $f_0=1$，可以在最开头这样写 `f.push_back(1)`。更具体的实现方法见代码。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, g, cnt, ans, a[30];
vector<bool> f;
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]), g = __gcd(g, a[i]);
    if (g != 1)
    {
        printf("-1");
        return 0;
    }
    sort(a + 1, a + n + 1), f.push_back(1);
    for (int i = 1; cnt < a[1]; i++)
    {
        bool flag = 0;
        for (int j = 1; j <= n && a[j] <= i; j++)
            if (f[i - a[j]])
            {
                flag = 1;
                break;
            }
        f.push_back(flag);
        if (flag)
            cnt++;
        else
            cnt = 0, ans++;
    }
    printf("%d", ans);
    return 0;
}
```

题解来之不易，且看且珍惜。给个赞再走吧。  
**[题目传送门](https://www.luogu.com.cn/problem/B4290)**

---

## 作者：chrispang (赞：1)

面对无解情况，可以容易看出：若 $a$ 中所有数两两不互质，那么无解。

而有解情况，可以使用 `DP`：

- **状态**：定义 $f_i$ 为数 $i$ 能否被表示出来
- **状态转移方程**：

$$
f_i=f_i \lor f_{i-a_j}
$$

- **初始化**：$f_0=1$，不包汤圆就可以了
- **答案**：$\sum_1^m 1-f_i$，其中 $m$ 是指最大不能被表示出的数

设 $x,y$ 互质，那么所有 $\ge xy$ 的数都可以被表示出来，即 $m=\operatorname{lcm}(x,y)$，这里可以感性理解一下。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 25;
const int M = 110 * 110;

int gcd(int x, int y) {
    if (x == 0) return y;
    return gcd(y % x, x);
}

int n, ans, a[N];
bool flag[M];
int main(){
    cin >> n >> a[1];
    int s = a[1];
    for (int i = 2; i <= n;i++){
        cin >> a[i];
		s = gcd(s, a[i]);
    }
    sort(a + 1 , a + n + 1);
    if (s != 1){
        cout << -1 << endl;
        return 0;
    }
    flag[0] = 1;
	for (int i = 1; i < M; i++){
		for (int j = 1; j <= n;j++){
			if (i < a[j])  continue;
			if (flag[i - a[j]]) flag[i] = 1;
		}
	}
    for (int i = 1; i < M; i++)
        ans += 1 - flag[i];
    cout << ans << endl;
	return 0;
}
```

---

## 作者：wst000 (赞：1)

# 思路
本题可以使用动态规划。设 $dp_i$ 为个数为 $i$ 的汤圆是否可以买到，等于 $1$ 表示可以买到，等于 $0$ 表示不能买到，然后统计有多少个 $dp_i=0$ 这个就是答案。当 $dp_{i-a_j}=1$ 时，$dp_i=1$。
## 难点
### 1.如何判断有无限种数量的汤圆不能买到？
设所有数的最大公约数为 $x$，如果 $x \ne 1$，那么输出 `-1`。

#### 证明：
当 $x \ne 1$ 时，只能凑出 $x$ 的倍数个汤圆，而非 $x$ 的倍数的数有无数个，所以要输出 `-1`。
### 2.dp 上限是多少？
对于 $n=2$ 时动规上限的证明，可以参考[这道题目的题解](https://www.luogu.com.cn/problem/solution/P3951)。那么当 $n$ 增大时，不能买到的汤圆个数上限的值不可能变高，只有可能变低，所以我们动规上限为 $\max(a_ia_j-a_i-a_j)(1 \le i,j \le n,\gcd(a_i,a_j)=1)$，这个式子的最大值不会超过 $100*99-100-99=9701$，所以我们可以只枚举到 $9701$，但保险起见，我们就枚举到 $10^6$。
# CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
cll N=1e6;
ll n,a[1000005],m,x,ans;
bool dp[1005005];
int main() {
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		x=__gcd(a[i],x),m+=a[i];
		dp[a[i]]=1;
	}
	if(x!=1){printf("-1");return 0;}
	for(int i=1;i<=N;i++){
		for(int j=1;j<=n;j++){
			if(i-a[j]>0)dp[i]|=dp[i-a[j]];
		}
		if(!dp[i])ans++;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Dongze2010 (赞：1)

# B4290 组合

[返回题目](https://www.luogu.com.cn/problem/B4290)

## 题目分析

给 $n$ 个整数 $a_i$，用 $a$ 数组里的数排列**组合**，求有多少个非零自然数无法被组合。  
特别地，当无法被组合的数为无数个时，输出 $-1$。

设 $n$ 个数 $a_i$ 的 $\gcd$ 为 $s$。  
则 $s$ 求解公式为：
```cpp
s = gcd(s,a[i]);
```
其中，$\gcd$ 函数为：
```cpp
int gcd(int a,int b){
    if (a < b)  swap(a,b);
    if (a % b == 0)  return b;
    return gcd(b,a%b);
}
```

若 $s=1$，我们称这一组数**互质**。  
若 $a$ 数组里的数不互质，如 $2,4$，则会有无数个非零自然数无法被组合。特判一下，输出 $-1$，然后结束程序即可。
```cpp
if (s != 1){
  cout << -1 << endl; return 0;
}
```

我们称 $s\ne1$ 时，此题无解。

所以 $s=1$ 时，此题有解，我们利用**动态规划**解决这个问题。  
（具体看代码即可。）

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 22;
const int maxx = 1e6 + 114;
int gcd(int a,int b){
    if (a < b)  swap(a,b);
    if (a % b == 0)  return b;
    return gcd(b,a%b);
}
int n,a[maxn],s,cnt = 1,ans = 0;
bool flag[maxx];
int main(){
    cin >> n >> a[1];
    s = a[1];
    for (int i = 2;i <= n;i++){
        cin >> a[i];
		s = gcd(s,a[i]);
    }
    sort(a + 1 , a + n + 1);
    if (s != 1){
        cout << -1 << endl; return 0;
    }
    flag[0] = 1;
	for (int i = 1;i;i++){
		for (int j = 1;j <= n;j++){
			if(i < a[j])  continue;
			if (flag[i-a[j]]){
				flag[i] = 1; break;
			}
		}
		if (!flag[i])  ans++, cnt = 0;
		else  cnt++;
		if (cnt == a[1])  break;
	}
    cout << ans << endl;
	return 0;
}
```

---

## 作者：lwj54joy (赞：1)

# [传送门](https://www.luogu.com.cn/problem/B4290)
# 关于无解的情况
我们先计算一下这些数的最大公约数，如果他们的最大公约数不等于 $1$，因为这组数据下我们只能买到 $sum$ 及其倍数个的汤圆。所以遇到这种情况直接输出 $-1$。
# DP
与其说是动态规划，不如说是递推，我们设置 $f_{a_i}$ 为 $1$，代表能够凑出（$a_i$ 为所给出的规格），然后如果 $f_{i-a_j}$ 是 $1$，那么 $f_i$ 也应该是 $1$，因为可以转化为 $f_{i-a_j}$ 再加上一个 $i$ 号规格的汤圆。对于每一个数，我们判断它是否可以凑出来，最后没有被赋值为 $1$ 的就是答案。
```cpp
#include <bits/stdc++.h>
const int N = 1e6 + 10;
typedef long long ll;
using namespace std;
int num[30], n;
int counter = 0, tp = 0, maxcounter = 0;
bool check[N];

int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}

int main() {
	cin >> n;
	for(int i = 0;i <= n;i++) cin >> num[i];
	sort(num, num + n);
	int pd = num[0];
	for(int i = 0;i <= n;i++) {
		pd = gcd(pd, num[i]);
	}
	if (pd != 1) {
		cout << -1;
		return 0;
	}
	memset(check, false, sizeof check);
	check[0] = true;
	for(int i = 1;i <= N;i++) {
		for(int j = 0;j <= n;j++) {
			if (num[j] > i) break;
			if (check[i - num[j]]) {
				check[i] = true;
				break;
			}
		}
		if (check[i]) {
			tp++;
			if (tp >= num[0]) {
				maxcounter = i - num[0];
				break;
			}
		} else counter++,tp = 0;
	}
	cout << counter;
}
```

---

## 作者：ryderyang (赞：1)

# 解题思路
设这 $n$ 个数的最大公因数为 $sum$。如果 $sum \neq 1$，就直接输出 $-1$，因为它们只能让我们买到 $sum$ 的倍数个汤圆。然后，我们可以用 $dp_i$ 表示是否能买到 $n$ 个汤圆。对于每一个 $1 \leq j \leq n$，如果 $dp_{i-a_j}$ 的值是 $1$，那么 $dp_i$ 的值也是 $1$。
# 最大上限
> 可恶，我之前的程序竟然被 hack 了，题解区的题解也没有对上限的详细推导。

我们可以设 $a$ 数组中的最小值为 $x$。枚举的时候，如果发现 $dp$ 数组已经连续 $x$ 个数都可以凑出来，那么就可以停止循环了。因为我们只要在一个符合条件的数字 $num$ 的基础上再加上一个 $x$ 就可以了。作者表达得可能不太清楚，更多细节可以看程序。

# 上代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[21],sum,ans,cnt,combo=1,minn;//combo:记录连续出现了多少次true
map<int,bool> dp;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(i==1)
		sum=a[i],minn=a[i];
		else
		sum=__gcd(sum,a[i]),minn=min(minn,a[i]);
	}
	if(sum!=1)
	{
		printf("-1");
		return 0;
	}
	dp[0]=true;
	for(int i=1;;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i<a[j])
			continue;
			if(dp[i-a[j]]==true)
			{
				dp[i]=true;
				break;
			}
		}
		if(dp[i]==false)
		ans++,combo=0;
		else
		combo++;
		if(combo==minn)
		break;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：cxlqwq (赞：1)

### 思路
---
这题暴力过不了，因此蒟蒻问了一下 DeepSeek 思路（但并没有复制粘贴）。

首先计算出所有汤圆规格的最大公约数 $pd$，若 $pd$ 等于 1，则说明所有规格数互质。知道这个条件可以干什么呢？举个例子，若输入是
~~~
2
2 4
~~~
2 和 4 它们并不互质，它们的最大公约数是 2，则只要不是 2 的倍数，如 5、7、11 都不行，这样的数有无数个，所以只要不互质，输出 -1 即可。

```cpp
int pd = num[0];
rep(i, 1, n) {
    pd = gcd(pd, num[i]);
}
if (pd != 1) {
    cout << -1;
    return 0;
}
```
在遍历过程中，初始的判断数组首项设为真，表示 0 个汤圆是可被组合的。当连续可以组合的汤圆数量达到最小规格便可以停止遍历。

AC Code
---

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<b;i++)
#define upto(i,a,b) for(int i=a;i<=b;i++)
const int N = 1e6 + 10;//上限
typedef long long ll;
using namespace std;
int num[30], n;
int cnt = 0, tmp = 0, maxcnt = 0;
bool check[N];

int gcd(int a, int b) {//辗转相除法求最大公约数
	if (b == 0) {
		return a;
	} else {
		return gcd(b, a % b);
	}
}

void input() {
	cin >> n;
	rep(i, 0, n) {
		cin >> num[i];
	}
	sort(num, num + n);
}

int main() {
	input();
	int pd = num[0];
	rep(i, 1, n) {
		pd = gcd(pd, num[i]);
	}
	if (pd != 1) {
		cout << -1;
		return 0;
	}
	memset(check, false, sizeof check);//初始化
	check[0] = true;
	rep(i, 1, N) {
		rep(j, 0, n) {
			if (num[j] > i)
				break;
			if (check[i - num[j]]) {
				check[i] = true;
				break;
			}
		}
		if (check[i]) {
			tmp++;
			if (tmp >= num[0]) {
				maxcnt = i - num[0];
				break;
			}
		} else {
			cnt++;
			tmp = 0;
		}
	}
	cout << cnt;
	return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

我们很容易就可以推出动态转移方程。当 $a_j \leq i$ 时：


$$
dp_i=dp_i \lor dp_{i-a_j}
$$

这样就可以推出所有可以被组成的数。

还有无解情况。如果这些数的最大公约数 $k$ 不等于 $1$，那么我们只能买到 $k$ 的倍数个的汤圆。所以无解。

```cpp
#include<bits/stdc++.h> 
using namespace std;
const int maxm=100005;
int n,a[25],gcdd,sum;
bool dp[maxm];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
    	scanf("%d",a+i);dp[a[i]]=1;
    	gcdd=__gcd(gcdd,a[i]);
	}
	if(gcdd!=1){return puts("-1"),0;}
	for(int i=1;i<=maxm;++i){
		for(int j=1;j<=n;++j){
			if(i>=a[j]) dp[i]|=dp[i-a[j]];
		}
		if(!dp[i]) ++sum;
	}
	printf("%d",sum);
}
```

---

## 作者：Zhangxm2012 (赞：0)

这道题主要考察数论和动态规划。

可以设 $dp_i$ 表示 $i$ 个汤圆能否买到。转移方程如下（其中 a 数组是每种汤圆的规格）：
$$$
dp_i=dp_i \lor dp[i-a[j]],i\ge a[j]
$$$
其中，$\lor$ 为逻辑或。
## 思路
Q：如何判断有无限种数量的汤圆不能买到？

A：考虑如下数列 $da_1,da_2...da_n$，若 $d>1$，无论怎么取，结果都是 $d$ 的倍数，即有无限种汤圆不能买到。

Q：DP 初始化和枚举上界在哪里？

A：$0$ 是可以选出来的（不选），故 $dp_0 \gets 1$。  
由于选不出来的个数是随汤圆种类的增加而减少的，易知 $100$ 和 $99$ 两种汤圆能选出来的最少，由裴蜀定理知 $\exist a,b \in \Z,100a+99b=\gcd(100,99)=1$，即在 $9900$ 之后都可表示。

## 注意事项
因为我们要求一组数的最大公因数，若一开始将公约数 $num \gets 0$，直接使用 `__gcd` 或 `gcd` **可能**会有未知错误，建议手写：
``` cpp
int Gcd(int a,int b){
	return b==0?a:Gcd(b,a%b);
}
```

## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N=104;
int dp[N*N],n,a[N],ans,num;
int Gcd(int a,int b){
	return b==0?a:Gcd(b,a%b);
}
int main(){
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		num=Gcd(a[i],num);
	}
	if(num!=1){
		cout<<-1;
		return 0;
	}
	for(int i=1;i<=N*N;i++){
		for(int j=1;j<=n;j++){
			if(i>=a[j]){
				dp[i]|=dp[i-a[j]];
			}
		}
		if(dp[i]==0){
			ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：YWT130508 (赞：0)

### 题目大意
给你 $n$ 个数字，要你求有几个数字不能由他们相加得到，每个数字可用无数次，无数个则输出 $-1$，是不是挺像完全背包的题目描述，可这题要用到数论。
### 判断是否有无数个
最近学到[裴蜀定理](https://oi-wiki.org/math/number-theory/bezouts/#%E5%AE%9A%E4%B9%89)，觉得这题有点相似，但这题因为个数不能为负，所以有买不到的，只需要判断所有数的最大公约数是否为一，不是就输出负一，是一就继续计算结果。
### 计算买不到的数量
正确的思路是如果可以拼到的数连续出现的个数达到序列中的最小值，就不用算了，所以我们递推时要外层枚举数字，内层枚举下标。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[25],cnt;
int gcd(int x,int y){
	if(y==0)return x;
	return gcd(y,x%y);
}
int main(){
int mn=INT_MAX;
cin>>n;
int sum=0;
int g=0;
for(int i=1;i<=n;i++){
	cin>>a[i];
	sum+=a[i];
	g=gcd(g,a[i]);
	mn=min(mn,a[i]);
}
if(g!=1){
cout<<-1;
return 0;
}
else{
	bool dp[4010]={0};
	dp[0]=1;
	int i;
	for(i=1;cnt<mn;i++){
		for(int j=1;j<=n;j++){
			if(i-a[j]>=0)
			dp[i]=dp[i]|dp[i-a[j]];
		}
		if(dp[i])
		cnt++;
		else cnt=0;
	}
	int ans=0;
	for(int j=1;j<i;j++){
		ans+=dp[j]==0;
	}
	cout<<ans;
}
return 0;
}
```

---


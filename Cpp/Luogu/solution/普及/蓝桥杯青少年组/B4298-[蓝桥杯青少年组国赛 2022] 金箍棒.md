# [蓝桥杯青少年组国赛 2022] 金箍棒

## 题目背景

为区分各种时间复杂度的做法，本题时间限制下调到 500 毫秒。

## 题目描述

淘气的悟空变出了 $N$ 根高度各不相同的金箍棒（$1 \leq $ 高度 $\leq 1000$），并排列成一排。悟空可以对每根金箍棒施法，让金箍棒高度变短或者变长，但每一次施法只能使一根金箍棒变短 $1$ 个高度或者变长 $1$ 个高度。

现在悟空想通过施法将 $K$（$K \leq N$）根相邻的金箍棒高度变为相同，且要求施法的次数最少，请你帮助悟空计算出最少需要施法几次可以使 $K$ 根相邻的金箍棒高度变为相同。

例如：$N=3$，$K=2$，$3$ 根金箍棒初始高度分别为 $3$、$6$、$1$。

- 第一次对高度为 $3$ 的金箍棒施法变长 $1$ 个高度，变为 $4$；
- 第二次对高度为 $6$ 的金箍棒施法变短 $1$ 个高度，变为 $5$；
- 第三次对高度为 $4$ 的金箍棒施法变长 $1$ 个高度，变为 $5$；

$2$ 根相邻的金箍棒高度变为相同，最少施法 $3$ 次。

## 样例 #1

### 输入

```
3 2
3 6 1```

### 输出

```
3```

# 题解

## 作者：Yxa_Sheep (赞：5)

**[题目传送门](https://www.luogu.com.cn/problem/B4298)**

看不懂大佬写的，只好写个简简单单的桶排（话说这不是黄题吗，感觉别的题解写的至少是绿题的代码）
## 题意
选定一个长度为 $k$ 的区间，求 $|a_i-x|+|a_{i+1}-x|+\dots +|a_{i + k - 1}-x|$ 的最小值，$x$ 为任意自然数。
## 思路
$x$ 很显然得是中间数，然后遍历每个长度为 $k$ 的区间，加和就可以了，最后比大小输出。这里求中间数得排序，如果用快排时间复杂度就比较高了，$O(n \times k \times \log{k})$，会超时两个点。题目中说金箍棒的高度小于 $1000$，所以这时候就体现了桶排序的优势，时间复杂度变成了 $O(n\times k)$。细节看代码。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, cnt, x, sum, ans = INT_MAX, a[10010], b[1010];
int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n - k + 1; i++)
    {
        cnt = 0, sum = 0, memset(b, 0, sizeof(b));
        for (int j = 1; j <= k; j++)
            b[a[i + j - 1]]++;
        for (int j = 1; j <= 1000; j++)
        {
            cnt += b[j];
            if (cnt >= (k - 1 >> 1) + 1)
            {
                x = j;
                break;
            }
        }
        for (int j = 1; j <= k; j++)
            sum += abs(a[i + j - 1] - x);
        ans = min(ans, sum);
    }
    printf("%d", ans);
    return 0;
}
```

题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4298)**

---

## 作者：封禁用户 (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/B4298)

### 前言
我们有 $n$ 根高度各不相同的金箍棒排成一排，每次施法可以将一根金箍棒的高度增加或减少 $1$。现在需要选择 $k$ 根相邻的金箍棒，通过最少的施法次数将它们的高度变为相同。求这个最少施法次数。

### 思路
这道题目要求我们找到 $k$ 根相邻的金箍棒，通过最少的施法次数将它们的高度变为相同。核心思路是：首先利用滑动窗口遍历所有可能的 $k$ 根相邻金箍棒组合，对于每个窗口，使用桶排序统计高度分布，因高度不超过 $1000$，快速找到使施法次数最少的中位数高度，然后计算将所有金箍棒调整到该高度所需的施法次数总和。通过维护滑动窗口内的桶排序统计信息，我们避免了重复计算，将时间复杂度优化到 $O(n\times k)$，能够高效处理题目给定的数据规模。最后在所有窗口结果中取最小值即为答案。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int IO(int N, int K, vector<int>& h) {
    const int ah = 1000;
    vector<int> c(ah + 1, 0);
    int io = INT_MAX;
    for (int i = 0; i < K; ++i) {
        c[h[i]]++;
    }
    
    for (int i = 0; i <= N - K; ++i) {
        int e = 0;
        int sum = 0;
        for (int h = 1; h <= ah; ++h) {
            sum += c[h];
            if (sum >= (K + 1) / 2) {
                e = h;
                break;
            }
        }
        int ops = 0;
        for (int h = 1; h <= ah; ++h) {
            ops += abs(h - e) * c[h];
        }
        io = min(io, ops);
        if (i + K < N) {
            c[h[i]]--;
            c[h[i + K]]++;
        }
    }
    
    return io;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int N, K;
    cin >> N >> K;
    vector<int> h(N);
    for (int i = 0; i < N; ++i) {
        cin >> h[i];
    }
    cout << IO(N, K, h) << endl;
    return 0;
}
```

---

## 作者：StormWhip (赞：1)

## 思路
对于选定的区间，将其中的所有元素改至它们的中位数时花费最小。于是问题转化成了求每一段长度为 $k$ 的连续区间的中位数，可用平衡树实现。  
这里用到了一种类似于莫队的思路，在已经统计好 $[l,r]$ 的区间后，要统计 $[l+1,r+1]$ 的区间时，只需删去 $a_l$ 并插入 $a_{r+1}$ 即可。
## 代码

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#define int long long
using namespace std;
using namespace __gnu_pbds;
const int N=1e4+5;
int n,k,a[N],ans,mid;
tree <pair<int,int>,null_type,less<pair<int,int> >,rb_tree_tag,tree_order_statistics_node_update> t;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=k;i++) t.insert(make_pair(a[i],i));
	mid=t.find_by_order((k-1)/2)->first;
	for(int i=1;i<=k;i++) ans+=abs(a[i]-mid);
	for(int i=k+1;i<=n;i++)
	{
		t.insert(make_pair(a[i],i));
		t.erase(t.lower_bound(make_pair(a[i-k],i-k)));
		mid=t.find_by_order((k-1)/2)->first;
		int t=0;
		for(int j=i-k+1;j<=i;j++) t+=abs(a[j]-mid);
		ans=min(ans,t); 
	}
	cout<<ans<<"\n";
	return 0;
}

```

---

## 作者：scc36 (赞：1)

[原题跃迁窗口](https://www.luogu.com.cn/problem/B4298)
### 思路
其实就是求一个长度为 $k$ 的区间，使得将其中所有数变成一样的改动次数最小。  
当我们选定一个区间后，假设最后变成的数为 $x$，我们要求的就是 $ | x-a_i | + | x-a_{i+1} | + ... +  | x-a_{i+k-1} | $ 的最小值。   
这玩意儿我们很熟悉，当 $x$ 取 $a_i$ 的中位数时，原式就会取到最小。  
于是问题的重心就成了成了求所有含 $k$ 个数的连续区间的中位数。  
尝试了一下对每个区间进行排序再找中位数，发现在第 15 个点和第 20 个点会超时。   

上网搜了一下，发现了一个叫 nth_element 的东东。  
具体见[维基](https://oi-wiki.org/basic/stl-sort/#stdnth_element)。  
简单理解，`nth_element(first, nth, last)` 会重排 `[first, last)` 中的元素，使得 `nth` 所指向的元素被更改为 `[first, last)` 排好序后该位置会出现的元素。这个新的 `nth` 元素前的所有元素小于或等于新的 `nth` 元素后的所有元素。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,i,s,j,a[100001],mi=2e9,b[10001];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(i=1;i<=n;i++) cin>>a[i];
	for(i=1;i<=n-k+1;i++){
		s=0;
		for(j=i;j<=i+k-1;j++) b[j-i+1]=a[j];
		nth_element(b+1,b+(k+1)/2,b+k+1); //更改
		for(j=1;j<=k;j++)
			s+=abs(b[(k+1)/2]-b[j]); //计算插值
		mi=min(mi,s);
	}
	cout<<mi;
}
```

---

## 作者：hxuwna (赞：1)

**[B4298](https://www.luogu.com.cn/problem/B4298)**
## 题意概括
给你 $n$ 个数 $a[i]$ 和 $k$ ，让你求 $\min_{r=k}^{n} \sum_{x=r-k+1}^{r} \lvert a[x]-t \rvert  $，其中 $t$ 为任意实数。
## 分析
首先，我们会发现这个式子是直接暴力求肯定会 T，所以我们先考虑化简。  
对于求 $ \sum_{x=r-k+1}^{r} \lvert a[x]-t \rvert  $ 我们发现它相当于是给你 $k$ 个数，让你求一个数的取值范围，使得这些数减去它的绝对值之和最小。此时，你会发现我们学 whk 时也遇到过这样的题。  

对于这类题目我们一般会画个数轴，但是最后可以归纳出它的规律就是：如果数的个数是奇数，那个数就是这些数的中位数，否则范围就是这些数的中间两个数之间（证明过程就是你对于数轴上的一个数，你考虑它向左或向右移动的贡献）  。

所以题目就化简为求某个长度为 $k$ 的区间，区间中的数减去它们的中位数的绝对值之和。

但是，求一些数减去一个数的绝对值之和直接求（以我的水平）只能想到 $O(n)$ 的做法。但你可以把它去绝对值，变成这个数减去这些数中比它小的数和这些数中比它大的数减去这个数的和。

于是问题便转换为了求区间的某些值域中的数的个数和数的和。

那么区间查询我们就可以用线段树求。

## 具体实现
我们可以用线段树维护一段区间内值域内数的个数和数的和，由于长度固定，我们就可以用单点修改把 $l$ 到 $r$ 的线段树转换为 $l+1$ 到 $r+1$ 的线段树。

每个区间可以用二分得到中位数，线段树区间查询得到代价。时间复杂度就是 $O(nlog^2k)$。

## ma


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int N=1e4+5,inf=1e18;
struct SGT{
	struct info{
		int sum,len,num;//sum:和;len:有多少个数;num:这个点上的数,仅用于单点修改
		void set(int x){sum=0,len=0,num=x;}
	}s[N<<2];
	struct tag{
		int add;
		void reset(){add=0;}
	}tg[N<<2];
	info merge(const info &x,const info &y){
		return {x.sum+y.sum,x.len+y.len,0};
	}
//	tag compose(const tag &x,const tag &y){
//	}
	info apply(const info &x,const tag &y){
		return {x.sum+x.num*y.add,x.len+y.add,x.num};
	}
	void pushup(int p){s[p]=merge(s[p<<1],s[p<<1|1]);}
	void maketag(int p,const tag &k){s[p]=apply(s[p],k)/*,tg[p]=compose(tg[p],k)*/;}
//	void pushdown(int p){maketag(p<<1,tg[p]),maketag(p<<1|1,tg[p]),tg[p].reset();}
	void modify(int p,int l,int r,int nl,int nr,const tag &k){
		if(nl<=l&&r<=nr){maketag(p,k);return;}
		int mid=(l+r)>>1;/*pushdown(p);*/
		if(nl<=mid) modify(p<<1,l,mid,nl,nr,k);
		if(nr>mid) modify(p<<1|1,mid+1,r,nl,nr,k);
		pushup(p);
	}
	info ask(int p,int l,int r,int nl,int nr){
		if(nr<1||nl>1000) return {0,0,0};
		if(nl<=l&&r<=nr) return s[p];
		int mid=(l+r)>>1;/*pushdown(p);*/
		if(nr<=mid) return ask(p<<1,l,mid,nl,nr);
		if(nl>mid) return ask(p<<1|1,mid+1,r,nl,nr);
		return merge(ask(p<<1,l,mid,nl,nr),ask(p<<1|1,mid+1,r,nl,nr));
	}
	void build(int p,int l,int r){
		tg[p].reset();
		if(l==r) return s[p].set(l);
		int mid=(l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
		pushup(p);
	}
	info l,r;
}tree;//线段树模板
int n,k,a[N],ans=inf;
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k;
	tree.build(1,1,1000);//由于求的是值域，所以都是1~1000
	for(int i=1;i<=n;i++){
		cin>>a[i];
		tree.modify(1,1,1000,a[i],a[i],{1});
		if(i>k) tree.modify(1,1,1000,a[i-k],a[i-k],{-1});
		if(i>=k){
			int l=1,r=1000,res=0;
			while(l<=r){//二分求中位数
				int mid=l+r>>1;
				int x=tree.ask(1,1,1000,1,mid-1).len,y=tree.ask(1,1,1000,mid+1,1000).len,z=tree.ask(1,1,1000,mid,mid).len;
				if(abs(x-y)<=z){res=mid;break;}
				else if(x<y) l=mid+1;
				else r=mid-1;
			}
			if(res==0) res=l;
			tree.l=tree.ask(1,1,1000,1,res-1),tree.r=tree.ask(1,1,1000,res+1,1000);
			int now=(tree.l.len*res-tree.l.sum)/*得到这个数减去这些数中比它小的数的和*/+(tree.r.sum-tree.r.len*res)/*得到这些数中比它大的数减去这个数的和*/;
			ans=min(ans,now);
		}
	}
	cout<<ans;
	return 0;
}
```
时间 $118ms$ ，目前是（除匿名用户以外的）最优解。  
## 题外话
我看其他人写的都是 $n^2$的暴力加 STL 找中位数或者是枚举中位数和区间的 $O(1000n)$ 暴力 ，代码非常短。我自己测了一遍发现确实能过 。不过反正没人写线段树我就交发题解好了。

---

## 作者：clarinet_pht (赞：0)

## 题意描述
有 $N$ 根高度各不相同的金箍棒排成一排，每次施法可将一根金箍棒变短或变长 $1$ 个高度。求使 $K$ 根相邻金箍棒高度相同所需的最少施法次数。

## 思路
先给结论：当所有金箍棒调整到中位数高度时，操作次数最少。

中位数将数据分为两半：左侧数据 $\leq$ 中位数，右侧数据 $\geq$ 中位数。

任何偏离中位数的移动：增加远离中位数的点的偏差，减少靠近中位数的点的偏差，净效果使总偏差增加。

操作次数计算公式：$\sum_{i=1}^{K} |h_i - \text{mid}|$。

### 优化：

滑动窗口与桶计数：利用高度范围有限（$1 \leq h \leq 1000$）的特点，维护滑动窗口内高度的桶数组。

快速求中位数：遍历桶数组，累加计数直至达到第 $\lfloor (K+1)/2 \rfloor$ 小的元素。

时间复杂度为总体为 $O(N \times H)$，可以通过此题。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=10000;
const int H=1000;
int n,k;
int a[N];
int cnt[H+1]={0};//桶数组（高度1~1000）
int main()
{
	cin>>n>>k;
	for(int i=0;i<n;i++)
		cin>>a[i];
	for(int i=0;i<k-1;i++)
		cnt[a[i]]++;//初始化前K-1个元素
	int ans=INT_MAX;
	for(int i=0;i<=n-k;i++)
	{
		cnt[a[i+k-1]]++;//加入窗口右端元素
		int s=0,mid=0;
		int kth=(k+1)/2;//目标中位数位置
		for(int h=1;h<=H;h++)
		{
			s+=cnt[h];
			if(s>=kth)
			{
				mid=h;//找到中位数
				break;
			}
		}
		int ops=0;
		for(int h=1;h<=H;h++)
			ops+=abs(h-mid)*cnt[h];//计算操作次数
		ans=min(ans,ops);
		cnt[a[i]]--;//移除窗口左端元素
	}
	cout<<ans<<"\n";
	return 0;
}
```

---


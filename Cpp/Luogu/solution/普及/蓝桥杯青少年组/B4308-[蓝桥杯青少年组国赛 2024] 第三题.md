# [蓝桥杯青少年组国赛 2024] 第三题

## 题目描述

因数：也称约数。如果整数 $a$ 除以整数 $b$，商为整数且余数为 $0$，则称 $b$ 是 $a$ 的因数。例如：$1$、$2$、$3$、$6$ 都是 $6$ 的因数。

素数：也称质数，是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外没有其他因数的数。例如：$2$、$3$、$5$ 是素数，$4$、$6$、$8$ 不是素数。

平方数：指的是可以写成某个整数的平方的数。例如：$4$（$2^2$）、$9$（$3^2$）、$16$（$4^2$）都是平方数。

莫比乌斯函数 $\mu(n)$ 定义如下：
1. 若 $n = 1$，则 $\mu(n) = 1$；
2. 若 $n$ 的因数中有大于 $1$ 的平方数，则 $\mu(n) = 0$；
3. 若 $n$ 的因数中没有大于 $1$ 的平方数，且 $n = P_1 \times P_2 \times \cdots \times P_k$（其中 $P_1, P_2, \ldots, P_k$ 为 $k$ 个不同的素数），则 $\mu(n) = (-1)^k$。

例如：
- $8$ 的因数有 $1$、$2$、$4$、$8$，其中大于 $1$ 的平方数有 $4$，所以 $\mu(8) = 0$；
- $15$ 的因数有 $1$、$3$、$5$、$15$，没有大于 $1$ 的平方数，且 $15 = 3 \times 5$，所以 $\mu(15) = (-1)^2 = 1$；
- $30$ 的因数有 $1$、$2$、$3$、$5$、$6$、$10$、$15$、$30$，没有大于 $1$ 的平方数，且 $30 = 2 \times 3 \times 5$，所以 $\mu(30) = (-1)^3 = -1$。

给定两个正整数 $m$ 和 $n$，请计算 $m$ 到 $n$ 之间（含 $m$ 和 $n$）所有整数的莫比乌斯函数值之和。

## 样例 #1

### 输入

```
1 10```

### 输出

```
-1```

# 题解

## 作者：Yxa_Sheep (赞：7)

**[题目传送门](https://www.luogu.com.cn/problem/B4308)**
## 题意
$\mu (n)=\begin{cases}
1  & \text{ if } n= 1\\
0  & \text{ if } n= x^2\mid n\\
(-1)^k  & \text{ if } n= \textstyle\prod_{i=1}^{k}p_i
\end{cases}$
$x>1$，$p_i$ 为质数且互不相等
## 思路
$n$ 和 $m$ 这么大，而且还出现了质数这两个字，那必须先欧拉筛了。筛着筛着我们发现，$\mu (i)$ 中，如果 $i$ 为质数，**那么 $\mu (i)=(-1)^1$，也就是 $-1$**。每次设 $x$ 为自然数，$y$ 为质数，那么 $x\times y$ 为会被筛掉，$x\times y$ 比 $x$ 的质因数多一个（就是 $y$ 嘛），**因此 $\mu (x\times y)=-\mu(x)$**。最后从 $\mu (m)$ 加到 $\mu (n)$ 就可以啦。
## 代码

```cpp
#include <bits/stdc++.h>
#define N 20000010
using namespace std;
int m, n, ans, t, p[N], f[N];
bool isp[N];
void init()
{
	memset(isp, true, sizeof(isp));
	isp[0] = isp[1] = false, f[1] = 1;
	for (int i = 2; i <= n; i++)
	{
		if (isp[i])
			p[++t] = i, f[i] = -1;
		for (int j = 1; j <= t && i * p[j] <= n; j++)
		{
			isp[i * p[j]] = false;
			if (!(i % p[j]))
            {
                f[i * p[j]] = 0;
                break;
            }
			else
                f[i * p[j]] = -f[i];
		}
	}
}
int main()
{
    scanf("%d%d", &m, &n);
    init();
    for (int i = m; i <= n; i++)
        ans += f[i];
    printf("%d", ans);
	return 0;
}
```

题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4308)**

---

## 作者：linhanmo (赞：3)

# 题解：B4308 [蓝桥杯青少年组国赛 2024] 第三题

## 暴力

对于每一个数，分解质因数，暴力计算。

## 正解

考虑优化。

我们参考欧拉筛的流程。

每次给一个质数乘上另一个数时，顺便更新莫比乌斯值即可。

时间复杂度为欧拉筛的 $O(n)$。


```cpp
#include <stdio.h>
#include <vector>
#include <bitset>
#include <numeric>
constexpr int N = 2e7 + 1;
int n, m, miu[N];
std::vector<int> p; // 素数集合
std::bitset<N> v = 3 /* v[0] = v[1] = true a*/ ; // 是否为素数
inline void euler(void) { // 欧拉筛
    miu[1] = 1; // 初始化
	for (int i = 2; i <= m; ++i) {
		if (!v[i]) p.emplace_back(i), miu[i] = -1; // i 是质数
        for (int j : p) {
            if (i * j > m) break;
			v.set(i * j);
          // 每次给一个质数乘上另一个数时，顺便更新莫比乌斯值
          // ------------
          // 添加的部分：
			if (i % j == 0) { miu[i * j] = 0; break; }
			miu[i * j] = -miu[i]; 
          // ------------
		}
	} return;
}
int main(void) {
	scanf("%d %d", &n, &m),
	euler();
    printf("%d", std::accumulate(miu + n, miu + m + 1, 0) /* 求和 */);
    return 0;
}
```

---

## 作者：huxuanrui19 (赞：2)

# B4308 题解
[题目传送门](https://www.luogu.com.cn/problem/B4308)。

话不多说，切入正题。
## 题目大意
题目给我们两个数字 $m$ 和 $n$，要我们求
$$
ans=\sum_{i=m}^{n} \mu(i)
$$
其中 $\mu$ 为莫比乌斯函数。

先简单转化以下，变成
$$
\begin{aligned}
  ans&=\sum_{i=m}^{n} \mu(i) \\&=\sum_{i=1}^{n}\mu(i)-\sum_{i=1}^{m-1} \mu(i)
\end{aligned}
$$

这样问题被转化为了求莫比乌斯函数前缀和。

## 前置知识
题目给的介绍十分复杂（~~写给小学生的~~）。

简单归纳为以下，
$$
\mu(i)=\begin{cases}
 1 & \text{ if } x=1 \\
 0 & \text{ if } a^2 \mid x   \\
 (-1)^{k} & \text{ if } x= {\textstyle \prod_{i=1}^{k} p_i} 
\end{cases}
$$

其中 $a$ 为大于 $1$ 的正整数，且 $p_i$ 互不相等（$1\le i\le k$ 且 $i$ 为整数）。

## 程序设计
如果我们采用暴力法的话，时间复杂度为 $O(n\sqrt n)$，在 $n\ge 10^6$ 的情况下会超时。

这是我们就要拿出我们的线性筛（欧拉筛）了。

先回顾我们的欧拉筛筛素数的方法：
```cpp
const int N=2e7+10;
int cnt,vis[N],pri[N];
void init()
{
    for(int i=2;i<N;i++){
        if(vis[i]==0){
            vis[i]=1;
            pri[++cnt]=i;
        }
        for(int j=1;j<=cnt;j++){
            if(i*pri[j]>=N){
                break;
            }
            vis[i*pri[j]]=1;
            if(i%pri[j]==0){
                break;
            }
        }
    }
}
```
这里我们来梳理一遍线性筛求莫比乌斯函数前缀和的方法（建议大家手推一遍），不会的[见这里](https://www.luogu.com.cn/problem/P3383)。

1.初始化 $\mu(1)=1$。

2.若 $n$ 为素数，则 $\mu(n)=-1$。

3.若 $n=pq$，其中 $p$ 为素数且 $p,q$ 互质，则 $\mu(n)=\mu(p)\mu(q)=-\mu(q)$。

4.若存在 $p^2\mid n$，则 $\mu(n)=0$。

照着这个思路我们直接开始欧拉筛。

下面给出 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e7+10;
int cnt,mu[N],vis[N],pri[N],sum[N];    //评估数据尽量别开 long long
void init()
{
    mu[1]=1;
    for(int i=2;i<N;i++){
        if(vis[i]==0){
            mu[i]=-1;
            vis[i]=1;
            pri[++cnt]=i;
        }
        for(int j=1;j<=cnt;j++){
            if(i*pri[j]>=N){
                break;
            }
            vis[i*pri[j]]=1;
            if(i%pri[j]==0){
                mu[i*pri[j]]=0;
                break;
            }
            mu[i*pri[j]]=mu[i]*mu[pri[j]];
        }
    }    //线性筛
    sum[1]=mu[1];
    for(int i=2;i<N;i++){
    	sum[i]=sum[i-1]+mu[i];
	}    //求前缀和
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	init();
	int n,m;
	cin>>m>>n;
	cout<<sum[n]-sum[m-1];
	return 0;
}
```
这样我们就可以在 $O(n)$ 的时间复杂度内解决此题。
## 扩展算法（可以跳过）
假如 $n$ 达到了 $10^8$ 及以上，那么 $O(n)$ 的算法也无能为力了。

这时我们使用杜教筛（~~不会~~的[见此](https://www.luogu.com.cn/problem/P4213)）。

给出代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
ll mu[N],vis[N],pri[N];
unordered_map<ll,ll> summu;
void init()
{
    vis[0]=vis[1]=1;
    mu[1]=1;
    int cnt=0;
    for(int i=2;i<N;i++){
        if(vis[i]==0){
            mu[i]=-1;
            vis[i]=1;
            pri[++cnt]=i;
        }
        for(int j=1;j<=cnt;j++){
            if(i*pri[j]>=N){
                break;
            }
            vis[i*pri[j]]=1;
            if(i%pri[j]==0){
                mu[i*pri[j]]=0;
                break;
            }
            mu[i*pri[j]]=-mu[i];
        }
    }
    for(int i=1;i<N;i++){
        mu[i]+=mu[i-1];
    }
}
ll getsmu(ll x){
	if(x<N){
		return mu[x];
	}
	else if(summu[x]){
		return summu[x];
	}
	ll ans=1;
	for(ll l=2,r;l<=x;l=r+1){
		r=x/(x/l);
		ans-=(r-l+1)*getsmu(x/l);
	}
	summu[x]=ans;
	return ans;
}
int main(){
	init();
	ll n,m;
	cin>>m>>n;
	cout<<(getsmu(n)-getsmu(m-1));
	return 0;
}
```

[线性筛（欧拉筛）方法](https://www.luogu.com.cn/record/220185709)

[杜教筛方法](https://www.luogu.com.cn/record/220189458)

~~也是优化了很多呢！~~

谢谢阅读！

---

## 作者：jur10n (赞：1)

## Analysis

首先我们看这题显然跟质数有关，分析过程，发现 $μ$ 的值跟质因数紧密相关。

那么我们必须要了解的前置知识：[【P3383】线性筛素数](https://www.luogu.com.cn/problem/P3383)、判断素数等。

请先完成[【P3383】](https://www.luogu.com.cn/problem/P3383)，掌握线性筛的求法，可以自己手推一下过程，要好好理解它的思想、过程。

这里附上代码：

```cpp
#include <iostream>
const int N = 1e8+5;
using namespace std;

int n, m;
int prime[6000005]; // 保存素数，同时避免12被2,3多次筛这样的情况
bool is_not_prime[N]; // 0和1都不是素数

// 筛选 n 以内的所有素数
void Seg(int n)
{
    is_not_prime[1]=1;
    is_not_prime[0]=1;
	for (int i = 2; i <= n; ++i)
	{
		if (!is_not_prime[i])   // 如果i是素数
		{
			prime[++prime[0]] = i;
		}
		for (int j = 1; j <= prime[0] && i * prime[j] <= n; ++j)
		{
			is_not_prime[i*prime[j]] = 1;
			// 如果i中包含了该质因子，则停止
			if (i % prime[j] == 0) break;
		}
	}
}

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	cin >> n >> m;
	Seg(n);
	for (int i = 1, q; i <= m; i++)
	{
		cin >> q;
		cout << prime[q] << '\n';
	}
}
```

完成之后，注意到此题目数据范围很大，肯定不能暴力硬解，自然想到线性筛，可以在线性筛的过程中，求出 $μ$ 函数的值。

## Solution

可以结合下面代码看。

1. 粘贴我们的线性筛代码，在此基础上作改进。

2. 首先如果是质数，直接赋值就可以。

3. 接下来看第二层循环部分：如果包含了该质因子，那么此时 `i*Prime[j]` 中必有质数 `Prime[j]` 的平方，赋值。并注意与线性筛同理，要跳出循环。

4. 若不包含，那么简单分析：当前的数必定在前几步或者这一步计算过，所以当前有一个 `Miu[i]` 的值。对于新数 `i*Prime[j]` 来说，相当于当前的数乘一个新的质因子。因此它的质因数幂分解式必然多了一个质因子，相比这个数，需要多乘负一。

5. 循环结束后，计算 $μ$ 的和。

## Code

按照上面的思路，简单打出代码：

```cpp
#include <bits/stdc++.h>
#define N 20000005
#define M 3000005
using namespace std;

int n, m, ans;
int Prime[M], Miu[N]; //素数，μ
bool Is_Not_Prime[N];

void CulMiu(int n)
{
	Is_Not_Prime[1] = Is_Not_Prime[0] = 1, Miu[1] = 1;
	for (int i = 2; i <= n; ++i)
	{
		if (!Is_Not_Prime[i])	// 如果i是素数
		{
			Prime[++Prime[0]] = i;
			Miu[i] = -1;	// 素数为-1
		}
		for (int j = 1; j <= Prime[0] && i * Prime[j] <= n; ++j)
		{
			Is_Not_Prime[i*Prime[j]] = 1;
			if (i % Prime[j] == 0)	// 如果i中包含了该质因子，则停止（前面已经处理过）
			{
				Miu[i * Prime[j]] = 0;	//此时i*Prime[j]中必有一个质数的平方
				break;
			}
			else	//i中没有这个质因子
			{
				//当前的i必定在前几步或者这一步计算过，所以当前有一个μ[i]的值
				//对于新数i*Prime[j]，相当于i乘一个新的质因子
				//因此它的质因数幂分解式必然多了一个质因子，相比i，需要多乘-1
				Miu[i * Prime[j]] = -Miu[i];
			}
		}
	}
}

signed main()
{
	cin >> n >> m;
	CulMiu(m);
	for (int i = n; i <= m; i++) ans += Miu[i];
	cout << ans;
}
```

---

## 作者：chenyunting (赞：1)

# 思路

看到题目首先想到的是按照题目的要求去处理每一个数，但这样一定会 TLE 的，于是这里就要用到素数筛。

如果这个数是质数，那么这个数的因数中一定没有大于一的平方数，并且只有自己这个因数，所以这个莫比乌斯函数值就是 -1。

如果这个数不是质数，那么只需要判断相乘的到这个数的两个数中的筛出来的质数是不是另一个是的因数。如果是，那么这个数的因数中就有两个大于 1 的平方数，这个数的莫比乌斯函数值就是 0。如果不是，那么这个数的莫比乌斯函数值就是相乘的这两个数的莫比乌斯函数值相乘。

# 代码

```c++
#include <iostream>
#include <vector>
namespace noip {
typedef long long ll;
constexpr ll MAX_N_c = 20000000;
ll n, m;
ll a[1+MAX_N_c], ans[1+MAX_N_c];
std::vector<ll> prime;

void main() {
	std::cin >> m >> n;
	ans[1] = 1;
	for (ll i = 2; i <= n; i++) {
		if (!a[i]) {
			prime.push_back(i);
			ans[i] = -1;
		}
		for (ll j = 0; j < (ll)prime.size() && prime[j]*i <= n; j++) {
			a[prime[j]*i] = 1;
			if (i % prime[j] == 0) ans[prime[j]*i] = 0;
			else ans[prime[j]*i] = ans[prime[j]]*ans[i];
		}
	}
	ll sum = 0;
	for (ll i = m; i <= n; i++)
		sum += ans[i];
		
	std::cout << sum;
}
} 

int main() {
	noip::main();
	return 0;
}

---

## 作者：wst000 (赞：1)

# 思路
本题考察素数筛。建议使用线性筛，不过我用的是埃氏筛（~~因为我不会用线性筛~~）。设质数为 $i$，当前被筛数为 $j$，筛时判断 $ i^2 \mid j$ 是否成立，如果是，则 $μ(j)=0$，否则 $ \mu (j) \gets \mu(j) \times (-1)$，初始所有 $\mu (k)=1(1 \le k \le n)$。当然，如果用埃氏筛，可能需要进行优化，不然会 TLE 的。
# CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
short a[20000005];
int n,m;
bool b[20000005];
int main() {
	scanf("%d%d",&m,&n);
	for(int i=m;i<=n;i++)
		a[i]=1;
	for(int i=2;i<=n;i++){
		if(b[i]==0){
			a[i]=-1;
			for(int j=i*2;j<=n;j+=i){
				if(j%(i*i)==0)a[j]=0;
				else  a[j]*=-1;
				b[j]=1;
			}
		}
	}
	ll ans=0;
	for(int i=m;i<=n;i++)
		ans+=a[i];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：liuli688 (赞：1)

### 思路
因为求莫比乌斯函数需要知道每个数的因数，所以我们需要素数筛（埃氏筛就可以）。

但是，求出每个数的因数之后再进行处理显然会 TLE。也就是说，我们必须在筛素数时就求出来莫比乌斯函数。

观察筛素数的过程。埃氏筛在发现一个素数 $p$ 时会把所有大于 $p$ 的 $p$ 的倍数 $i$ 删去，对应 $i$ 有 $p$ 这个因子。此时只要将数组中存的 $\mu(i)$ 变为它的相反数即可。如果发现 $p ^ 2 | i$，将 $\mu(i)$ 置为 $0$。

初始将所有 $\mu(i)$ 置为 $1$，因为如果这个数还没有被筛到且目前只发现这一个因子那么莫比乌斯函数也是 $1$。但是，当发现一个素数时要将莫比乌斯函数置为 $-1$。
### 代码
```cpp
#include <cstdio>
#include <algorithm>

const int N = 2e7 + 1;
char mu[N], vis[N];
int m, n, ans = 0;

signed main()
{
    scanf("%d%d", &m, &n);
	std::fill(mu + 1, mu + n + 1, 1);//初始化为 1
	for (int i = 2; i <= n; ++i)
		if (not vis[i])//发现素数 i
		{
			mu[i] = -1;//莫比乌斯函数置为 -1
			for (int j = i + i; j <= n; j += i)//对于每个倍数
			{
				vis[j] = true;//不是素数
				if ((j / i) % i == 0)//i^2 整除 i
					mu[j] = 0; //有重复因子 j
                else
                    mu[j] *= -1;//有新的因子 j
			}
		}
    for (int i = m; i <= n; ++i)
        ans += mu[i];
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Zhangxm2012 (赞：0)

~~先瞟一眼标签：筛法，好了，做吧~~

记全体素数构成的集合为 $P$，$x$ 的最小素因子为 $d,x_1=\frac{x}{d}$，由定义知，莫比乌斯函数 $\mu(n)$ 有如下性质：
$$$
\begin{array}{l} 
  \mu(x)=\left\{
  \begin{matrix} x_1 \bmod d=0,\mu(x)=0\\
  x_1 \bmod d\ne 0,\mu(x)=-\mu(x_1)
\end{matrix}\right.    
\end{array} 
$$$
若 $x\in P$，则 $\mu(x)=-1$。

我们想到了一位故人——欧拉筛。欧拉筛的优点是复杂度为 $O(n)$，即每个合数只标记一遍，同时更新 $\mu(x)$ 的值，再看一眼数据范围 $1\le m\le n\le 2\times10^{7}$，$O(n)$ 包能过。

下面是代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20000004;
vector<int>pri;
bool not_prime[N];
short mu[N];
void init(int n){
	mu[1]=1;
	for(int i=2;i<=n;++i){
		if(!not_prime[i]){
			mu[i]=-1;
			pri.push_back(i);
		}
		for(int pri_j:pri){
			if(i*pri_j>n)break;
			not_prime[i*pri_j]=true;
			if(i%pri_j==0){
				mu[i*pri_j]=0;
				break;
			}
			mu[i*pri_j]=-mu[i];
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int m,n,ans=0;
	cin>>m>>n;
	init(n);
	for(int i=m;i<=n;i++){
		ans+=mu[i];
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

呜呜呜，去年比赛时还是一个新手，写了个暴力。

前置知识：[莫比乌斯函数](https://oi-wiki.org/math/number-theory/mobius/)。但是大家放心，这道题只需要一些基础的就行了。
# 解题思路
注意到题目中的数据范围：$1 \le m \le n \le 2 \times 10^7$。所以我们肯定不能想我一样用暴力的解法。所以我们考虑用线性筛。

所需以下数组：

  - 我们用 $vis_i$ 表示 $i$ 是否为素数，如果 $vis_i = 0$，则 $i$ 是素数，否则 $i$ 是合数。

  - 我们用 $mu_i$ 表示 $\mu(i)$ 的值。

步骤如下：

  - 遍历 $i$ 从 $2$ 到 $n$：
    - 如果 $i$ 是素数，则：

      - $\mu_i$ 的值为 $-1$，因为他只有一个质因子（本身）。
    - 设 $x$ 为 $i$ 的最小质因子，我们需要遍历所有的素数 $p \le x$：

      - 计算 $j = i \times p$，并把 $vis_j$ 的值改为 $1$。
      - 如果 $p = x$：

        - $\mu(j) = 0$，因为 $j$ 是 $p^2$ 的倍数。
      - 否则：

        - $\mu(j) = \mu(i) \times \mu(p) = \mu(i) \times (-1)$。因为莫比乌斯函数是积性函数。
       
边界条件：

$\mu(1)=1$。

# 上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=20000000;
int vis[N+5],mu[N+5];
vector<int> primes;
void init()
{
	mu[1]=1;
	for(int i=2;i<=N;i++)
	{
		if(!vis[i])
		{
			mu[i]=-1;
			primes.push_back(i);
		}
		for(auto p:primes)
		{
			int j=i*p;
			if(j>N)
			break;
			vis[j]=1;
			if(i%p==0)
			mu[j]=0;
			else	
			mu[j]=-mu[i];
		}
	}
}
signed main()
{
	init();
	int l,r,ans=0;
	scanf("%lld%lld",&l,&r);
	for(int i=l;i<=r;i++)
	ans+=mu[i];
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 思路

看到这 $2\times 10^7$ 的数据范围，我的内心已经在发抖，暴力的 $O(n \sqrt n)$ 在此处完全行不通，这咋办？\
筛素数呗！

但是，朴素的素数筛加上暴力仍然不能卡过，咋办？\
筛素数的时候记录莫比乌斯函数值呗！

首先初始化 $\forall i \in \N^* , \mu(i) = 1$，由于素数只能分解成一个素因数，因此在筛素数时，若找到素数 $p$，则 $\mu(p) = (-1)^1 = -1$。\
由于我太菜了只会埃氏筛，所以在找到素数 $p$，且当被筛数为 $x$ 时，需要判断 $x\ |\ p^2$ 是否成立，若成立，依照定义，$x$ 存在大于 $1$ 的完全平方因数，故 $\mu(x) = 0$；否则，$x$ 多出了一个素因数，则 $\mu(x) \gets -\mu(x)$。\
最后暴力算 $\sum_{i=m}^{n} \mu(i)$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

char u[20100005]; //莫比乌斯函数值
bool b[20100005]; //存是否为合数

void xxs(int n){ //埃氏素数筛
    for(int i = 2; i <= n; ++i){
    	if(!b[i]){
    		u[i] = -1; //找到了一个素数，u[i] = -1

			for(int j = i * 2; j <= n; j += i){
	            b[j] = true; //标记合数
	            if(j % (i * i) == 0) u[j] = 0; //判断是否有完全平方因数
	            else u[j] = -u[j];
			}
        }
	}
}
int main(){
    memset(u, 1, sizeof(u));
    int n, m;
    cin >> m >> n;
    xxs(n);

    int ans = 0;
    for(int i = m; i <= n; ++i){
//        cout << (int)u[i] << ' ';
    	ans += u[i];
	}
	cout << ans;
	return 0;
}
```

## 后话

不知道大家有没有发现一个小细节，代码中的 `u` 数组是 `char` 类型？这个细节主要是为了两点：

- 数组的大小 $\ge 2\times 10^7$，因此开单个内存小一点的类型的数组，可以防止 MLE，如果是 `int` 类型，其内存理论上为 `char` 类型数组的 $4$ 倍。
- `memset()` 函数（就是主函数中第一行出现的那位）是按字节填充数组的，而 `int` 占 $4$ 个字节，也就是 $32$ 位，如果还这样使用，每个 `int` 元素将变为二进制下的 `0000 0001 0000 0001 0000 0001 0000 0001`，也就是十进制的 $16843009$，而只占一字节的 `char` 却不受任何影响。

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4308)
## 思路
简单筛法。
### 积性函数
若函数 $f(x)$ 满足对于 **互质** 的 $a,b$，有 $f(ab)=f(a)f(b)$，则 $f(x)$ 为积性函数。

若 **任意** 的 $a,b$ 均满足 $f(ab)=f(a)f(b)$，则 $f(x)$ 为完全积性函数。

容易证明 $\mu(x)$ 是积性函数（参考剩余系的复合）。

### 筛法计算
若 $i$ 是质数，则 $\mu(i)=-1$。

若 $i$ 是合数，则 $i$ 在线性筛中被自己的 **最小质因子** 筛掉。

设 $n$ 为 $i$ 的最小质因子，$i=nm$。
 - 若 $n\mid m$，则 $i$ 有两个质因子 $n$，$\mu(i)=0$
 - 若 $n\nmid m$，则 $i$ 比 $m$ 多一个质因子 $n$，$\mu(i)=-\mu(m)$

时间复杂度 $O(n)$。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e7+5;
int l,r;
int mu[N],p[N],s[N],cnt;
bool vis[N];
void init() {
	mu[1]=1;
	for(int i=2;i<N;i++) {
		if(!vis[i]) {
			p[++cnt]=i;
			mu[i]=-1;
		}
		for(int j=1;i*p[j]<N;j++) {
			int m=i*p[j];
			vis[m]=1;
			if(i%p[j]==0) {
				mu[m]=0;
				break;
			} else mu[m]=-mu[i];
		}
	}
	for(int i=1;i<N;i++) s[i]=s[i-1]+mu[i];
}
int main() {
	cin>>l>>r;
	init();
	cout<<s[r]-s[l-1];
}
```
### 补充
如果 $n,m\le 10^{12}$ 甚至更大，我们可以使用 [杜教筛](https://www.luogu.com.cn/problem/P4213)。

记 $s(n)=\sum_i^n \mu(i)$。

因为有 $(\mu\ast 1)(x)=\varepsilon(x)$，所以

$$s(n)=1(1)s(n)=\sum_{i=1}^n\varepsilon(i)-\sum_{i=2}^ns(n/i)=1-\sum_{i=2}^ns(n/i)$$

可以使用杜教筛快速计算。

时间复杂度 $O(n^{2/3})$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
bool vis[N+5];
int mu[N+5],pr[N+5],cnt;
map<int,int> mmp,pmp;
void init() {
	mu[1]=1;
	for(int i=2;i<=N;i++) {//线性筛 
		if(!vis[i]) pr[++cnt]=i,mu[i]=-1;
		for(int j=1;i*pr[j]<N;j++) {
			int p=pr[j];
			vis[i*p]=1;
			if(i%p==0) break;
			mu[i*p]=-mu[i];
		}
	}
	for(int i=2;i<=N;i++) mu[i]+=mu[i-1];//前缀和
}
long long fmu(long long n) {
	if(n<N) return mu[n];//剪枝 
	if(mmp[n]) return mmp[n];//剪枝 
	long long ans=1;
	for(long long l=2,r;l<=n;l=r+1) {//整除分块 
		r=n/(n/l);
		ans-=fmu(n/l)*(r-l+1);
	}
	mmp[n]=ans;
	return ans;
}
int l,r;
int main() {
	cin>>l>>r;
	init();
	cout<<fmu(r)-fmu(l-1);
}
```

---


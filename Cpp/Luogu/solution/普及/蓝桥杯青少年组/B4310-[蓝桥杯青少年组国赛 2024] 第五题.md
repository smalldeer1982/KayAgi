# [蓝桥杯青少年组国赛 2024] 第五题

## 题目描述

给定包含 $n$ 个整数的数列，从中选取一段连续子数列，使其元素之和能被 $k$ 整除。

请找出符合要求的最长连续子数列并输出其长度以及子数列本身；如果符合要求的最长连续子数列有多个，则输出起始位置最靠后的那个子数列。如果不存在符合要求的子数列，则输出 $-1$。

例如：当 $n=7$，$k=7$，数列为 $7$、$3$、$4$、$1$、$5$、$14$、$9$ 时：
- 连续子数列 $\{7\}$、$\{7,3,4\}$、$\{3,4\}$ 和 $\{5,14,9\}$ 的和都能被 $7$ 整除；
- 其中最长的连续子数列有 $\{7,3,4\}$ 和 $\{5,14,9\}$，起始位置最靠后的是 $\{5,14,9\}$；
- 故符合要求的最长连续子数列长度为 $3$，子数列为 $5$ $14$ $9$。

## 样例 #1

### 输入

```
7 7
7 3 4 1 5 14 9```

### 输出

```
3
5 14 9```

# 题解

## 作者：Yxa_Sheep (赞：11)

**[题目传送门](https://www.luogu.com.cn/problem/B4310)**
## 题意
找出和能被 $k$ 整除的最长子串中起始位置最靠后的数列，输出它的长度和其中的每个数。
## 思路
题目还没看完，就眼前就自动浮现了三个字：前缀和。两个除以 $k$ 余数相同的数相减一定能被 $k$ 整除（就当余数抵消了吧）。这时，我们可以用 map 维护每一个余数第一次出现的位置（$k$ 有点大，怕数组塞不下），如果出现了同样的余数并且长度大于等于 $len$（用来存储最终长度），就更新 $len$ 的值。细节在代码中注释了。
## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, len = -1, l, r, sum, a[100010];
map<int, int> mp;
int main()
{
    scanf("%d%d", &n, &k);
    mp[0] = 0; //一定要把 mp[0] 初始化为 0，相当于从 1 开始选
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        sum = (sum + a[i]) % k;
        if (!mp.count(sum)) //如果没有这个键
            mp[sum] = i;
        else if (i - mp[sum] >= len)
            len = i - mp[sum], l = mp[sum] + 1, r = i;
    }
    printf("%d\n", len); //我的 len 初始化为 -1 了哈
    for (int i = l; i <= r && len != -1; i++) // 条件要加 len != -1
        printf("%d ", a[i]);
    return 0;
}
```

题解来之不易，且看且珍惜。给个赞再走吧。

**[题目传送门](https://www.luogu.com.cn/problem/B4310)**

---

## 作者：DashZhanghanxu (赞：5)

# 解析
看到连续子数列，本能反应前缀和。

为了更好的观看体验，本篇题解省略了前缀和的描述，如果您还不会前缀和，可以上前缀和模板题学习。

首先我们可以想到，枚举起点与终点，看该子段和是否满足为 $k$ 的倍数，如果是，并且该子段长度比上个子段最优子段的长度长或者更靠后，则更新答案。最后输出该子段长度及内容。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[100001],dp[100001];
int start=0,endd=0,maxans=0;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=dp[i-1]+a[i];
	}
	for(int i=1;i<=n;i++){//终点 
		for(int j=1;j<=i&&(i-j+1)>=maxans;j++){//起点 
		int now=dp[i]-dp[j-1];
			if(now%k==0){
					maxans=i-j+1;
					start=j;
					endd=i;
			}
		}
	}
	if(maxans==0){
		cout<<-1;
		return 0;
	}
	cout<<maxans<<"\n";
	for(int i=start;i<=endd;i++){
		cout<<a[i]<<' ';
	}
	return 0;
}
```
但是，我们会发现，该代码会有一个点超时（有能力的大佬可以尝试修改）。

因此，我们可以考虑另一种写法。

既然要找最长子段，那么我们可以枚举长度与终点，若发现该子段和为 $k$ 的倍数，可以直接输出，若未找到，则输出 $-1$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[100001],dp[100001];
int start=0,endd=0,maxans=0;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		dp[i]=dp[i-1]+a[i];
	}
	for(int i=n;i>=1;i--){//长度 
		for(int j=n;j>=i;j--){//终点 
			if((dp[j]-dp[j-i])%k==0){
				cout<<i<<"\n";
				for(int k=j-i+1;k<=j;k++){
					cout<<a[k]<<' ';
				}return 0;
			}
		} 
	}
	if(maxans==0){
		cout<<-1;
		return 0;
	}
	return 0;
}
```
这里再提供一种方法：

注：以下数字皆指前缀和。

众所周知，两个除以同一个数余数相同的数字相减后一定是这个除数的倍数。所以我们可以将一个余数的第一次出现的位置记录下来，当以后出现相同余数时，将这个数与最早出现该余数的数字相减，得到的长度与最长字段相比，更新答案即可。

以下是代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,k,a[100005],pre,last;
int len,start,endd;
map<int,int> fir;
int main(){
    cin.tie(0);
    ios::sync_with_stdio(false);
    cin>>n>>k;
    fir[0]=0;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        pre=(last+a[i])%k;
        last=pre;
        if(fir.count(pre)){
            if(i-fir[pre]>=len){
                len=i-fir[pre];
                start=fir[pre]+1;
                endd=i;
            }
        }else{
            fir[pre]=i;
        }
    }
    if(len==0){
        cout<<"-1";
        return 0;
    }
    cout<<len<<"\n";
    for(int i=start;i<=endd;i++) cout<<a[i]<<" ";
    return 0;
}
```

---

## 作者：_ByTT_ (赞：2)

# B4310 题解
## 题意
 在一个序列中，找**最长**并且开头**最靠后**的子序列并且这个子序列和还要**被 $k$ 给整除**。

### 思路

 ~~坏了，看到子序列求和就想要前缀和~~。

其实就是**前缀和**。目测发现好像没有好办法可以稳定解决，写个暴力先骗骗分，然后再**优化**。

### ~~暴力~~代码如下：
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[100005],ps[100005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int n,k;cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],ps[i]=ps[i-1]+a[i];
	for(int len=n;len>=1;len--){
		for(int i=n;i>=len;i--){
			int sum=(ps[i]-ps[i-len]);
			if(sum%k==0){
				cout<<len<<'\n';
				for(int j=i-len+1;j<=i;j++) cout<<a[j]<<' ';
				return 0;
			}
		}
	}
	cout<<-1;
	return 0;
}

```
### 优化
交上去没有悬念拿到了亿点分，竟然只有最后一个点超时了，所以优化应该比较为简单。

首先，注意看**数据范围**，$k$ 有 $10^8$，但是 $n$ 和序列数据大小只有 $10^5$ 和 $10^4$。

所以明显的，$k$ 一但大到一定程度，就会导致长的子序列和不满足，短子序列的和又小于 $k$，浪费了大量时间效率，于是乎，便想到了以下优化。
```c++
	int flg=1;
	for(int len=n;len>=1;len--){
		flg=1;
		for(int i=n;i>=len;i--){
			int sum=(ps[i]-ps[i-len]);
			if(sum>=k) flg=0;
		}
		if(flg) break;
	}
	cout<<-1;
```
### "完整"代码：
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[100005],ps[100005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int n,k;cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i],ps[i]=ps[i-1]+a[i];
	int flg=1;
	for(int len=n;len>=1;len--){
		flg=1;
		for(int i=n;i>=len;i--){
			int sum=(ps[i]-ps[i-len]);
			if(sum>=k) flg=0;
			if(sum%k==0){
				cout<<len<<'\n';
				for(int j=i-len+1;j<=i;j++) cout<<a[j]<<' ';
				return 0;
			}
		}
		if(flg) break;
	}
	cout<<-1;
	return 0;
}
```
真的结束了吗。

经过管理员的审核，又将题解打了回来，理由是**时间复杂度不合格**，仔细看，~~虽然能过，虽然数据过水~~ ，但是极端情况下，会存在优化不掉而超时的数据。

所以，还需要真正的正解。

#### 新的思路

在大佬 @afuafu 的帮助下，得到了新的思路。有一种特殊的办法，将**前缀和取余** $k$，从而靠模后和快速求出答案，时间复杂度 $O(n)$。

此解法从[另一道 USA ](https://www.luogu.com.cn/problem/P3131)的前缀和题目中得到，于此题有异曲同工之妙。

同时使用的还有一个~~类似~~**双指针**的**两个**数组存下标，同时每次有答案时用 $ \ge $ 来判断，因为要求尽量**靠后**的答案，用 $mx$ **减去左指针来存长度**，然后用 $ans$ 去存当前答案的**下标**。

最后就是简单的写代码主体啦。

#### 完整代码
```c++
#include<bits/stdc++.h>
using namespace std;
int n,k,l[100000005],ans,mx=-1;
int a[1000005],s[1000005],r[100000005];
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>k;
	memset(l,-1,sizeof(l));
	s[0]=0;l[0]=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		s[i]=(s[i-1]+a[i])%k;
		if(l[s[i]]==-1){
			l[s[i]]=i;
		}else{
			r[s[i]]=i;
			if(i-l[s[i]]>=mx){
				mx=i-l[s[i]];
				ans=s[i];
			}
		}
	}
	cout<<mx<<"\n";
	for(int i=l[ans]+1;i<=r[ans]&&mx>0;i++) cout<<a[i]<<" ";
	return 0;
}
```

---

## 作者：ryderyang (赞：2)

# 解题思路
由于要求出子序列的和，我们可以考虑用前缀和。设 $sum_i$ 为从第 $1$ 个元素到第 $i$ 个元素的和。可以想到递推公式：$sum_i=sum_{i-1}+a_i$。那么怎么求出第 $l$ 个数到第 $r$ 个数的和呢？可以用 $sum_r-sum_{l-1}$。我们只需要枚举序列的长度和起点，判断总和是不是 $k$ 的倍数就行了。时间复杂度 $O(n^2)$。
# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,a[N],sum[N],k;
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	for(int len=n;len>=1;len--)
	{
		for(int l=n+1-len;l>=1;l--)
		{
			int r=l+len-1;
			if((sum[r]-sum[l-1])%k==0)
			{
				printf("%d\n",len);
				for(int i=l;i<=r;i++)
				printf("%d ",a[i]);
				return 0;
			}
		}
	}
	printf("-1");
	return 0;
}
```

# 正解
我们认定该序列是目标序列的条件是 $sum_r-sum_{l-1}$ 是 $k$ 的倍数，所以 $sum_r$ 和 $sum_{l-1}$ 除以 $k$ 的余数是相等的。我们把每一个余数最早出现的位置记录下来。输入时更新答案就行了，具体细节见代码。
# 满分代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,a[N],sum[N],k,ans=-1,l,r=-1;
map<int,int> mp;
int main()
{
	scanf("%d%d",&n,&k);
	mp[0]=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		sum[i]=sum[i-1]+a[i];
		int mod=sum[i]%k;
		if(mp.count(mod)==0)
		mp[mod]=i;
		else
		{
			int len=i-mp[mod];
			if((len>ans)||(len==ans&&(mp[mod]+1)>l))
			{
				ans=len;
				l=mp[mod]+1;
				r=i;
			}
		}
	}
	printf("%d\n",ans);
	for(int i=l;i<=r;i++)
	printf("%d ",a[i]);
	return 0;
}
```

---

## 作者：huxuanrui19 (赞：1)

# B4310 题解
[题目传送门](https://www.luogu.com.cn/problem/B4310)
## 题目大意
在长度为 $n$ 的序列中，求最大的子段，满足数字之和为 $k$ 的最长子段，并输出长度和子段中的数字，若没有，输出 $-1$。若有多个，输出最靠后的。

## 题目思路
很容易想到前缀和优化，但枚举序列还是要 $O(n^2)$（~~虽然听其他人说好像能水过去~~。

考虑使用 unordered_map 存储第一个前缀和模 $k$ 余数为给定数 $i$ 的下标 $pre_i$。

然后枚举每一个 $i$，子段长 $len=i-pre_i$，取最大值并更新靠后的即可，记录起点和终点。

若 $len$ 均等于 $0$，则输出 $-1$。
## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10;
int a[N],sum[N];
unordered_map<int,int> m; 
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) sum[i]=(sum[i-1]+a[i])%k;
	for(int i=0;i<=n;i++){
		if(!m.count(sum[i])){
			m[sum[i]]=i;
		}    //更新记录一下
	}
	int maxl=0,s=0,e=0;
	for(int i=1;i<=n;i++){
		if(m[sum[i]]==i){
			continue;
		}
		else{
			if(maxl<=(i-m[sum[i]])){
				maxl=i-m[sum[i]];
				s=m[sum[i]]+1;
				e=i;
			}
		}    //记录最大值
	}
	if(maxl==0) cout<<"-1";
	else{
		cout<<maxl<<endl;
		for(int i=s;i<=e;i++){
			cout<<a[i]<<" ";
		}
	}
	return 0;
}
```
代码比较清晰，就不过多赘述了。

谢谢大家！

---

## 作者：linhanmo (赞：1)

# 题解：B4310 [蓝桥杯青少年组国赛 2024] 第五题

[题目传送门](https://www.luogu.com.cn/problem/B4310)

## 思路

看到“最长连续子数列”自然想到前缀和，于是构建出前缀和数组（当然存储前缀和 $\bmod\ k$ 后的值也可以）。

### 暴力

枚举长度（从长到短）和起始点（从后往前），遇见符合条件的就输出。

使用两重循环，时间复杂度 $Θ(n^2)$；

存储前缀和，空间复杂度 $Θ(n)$。

~~但是*篮球杯*数据使用*脚*造的，太*水*，***可以***通过……~~

### 正解

我们想到可以存储前缀和 $\equiv i\pmod k$ 的两端，这样求个 $\max$ 就可以了。

于是我们建立一个桶 `pair<int, int> b[(int)1e8 + 1];`。

统计前缀和到 $s_i$ 时：

1. $\bmod\ k$ 后的值未出现过：将左端点设为 $i$。

2. $\bmod\ k$ 后的值已出现过：将右端点设为 $i$，尝试刷最大值。

最后输出即可。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e5 + 1;
int n, k, res, mx = -1, a[N];
pair<int, int> b[(int)1e8 + 1];
int main(void) {
	scanf("%d %d", &n, &k);
	for (int s = 0, i = 1; i <= n; ++i) {
		scanf("%d", &a[i]), (s += a[i]) %= k; // 实际情况我们不需要维护一个数组，只要累加一个变量即可
		if (b[s].first == 0 && s != 0) b[s].first = i;
	    else {
			b[s].second = i;
			if (i - b[s].first >= mx) mx = i - b[s].first, res = s;
		}
	}
    printf("%d\n", mx);
    for (int i = b[res].first + 1; i <= b[res].second && mx > 0; ++i) printf("%d ", a[i]);
	return 0;
}
```

我们发现这样空间复杂度是 $Θ(k)$，实际只会用到 $n$，很浪费，于是把桶换成 `unordered_map`（哈希表）。


```cpp
#include <unordered_map>
#include <stdio.h>
constexpr int N = 1e5 + 1;
int n, k, res, mx = -1, a[N];
std::unordered_map<int, std::pair<int, int> > b;
int main(void) {
	scanf("%d %d", &n, &k);
	for (int s = 0, i = 1; i <= n; ++i){
		scanf("%d", &a[i]), (s += a[i]) %= k;
		if (b[s].first == 0 && s) b[s].first = i;
	    else {
			b[s].second = i;
			if (i - b[s].first >= mx) mx = i - b[s].first, res = s;
		}
	}
    printf("%d\n", mx);
    for (int i = b[res].first + 1; i <= b[res].second && mx > 0; ++i) printf("%d ", a[i]);
	return 0;
}
```

于是我们最终的代码时间和空间复杂度均为 $Θ(n)$ 了。

---

## 作者：guoshengyu1231 (赞：1)

# 题意分析
题目要求我们在一个数列中选择一个子区间，使得他的和能被 $k$ 整除。要求让这个子区间更长且更靠后。
# 解题思路
从“子区间的和”中我们可以知道这题应该使用前缀和快速计算一个子区间的和然后判断是否能被 $k$ 整除，由于题目要求首先得是长度最长，接着才是最靠后。所以只需要用一个循环枚举长度，再用一个循环枚举尾端点。接着在循环里判断即可。
# 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int a[100005];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++) 
	 {
	 	cin>>a[i];
	 	a[i]+=a[i-1];//前缀和
	 }
	for(int len=n;len;len--)
	 for(int i=n;i-len>=0;i--)
	  {
	  	int l=i-len;
	  	if((a[i]-a[l])%k==0)
	  	 {
	  	 	cout<<len<<"\n";
	  	 	for(int t=l+1;t<=i;t++) cout<<a[t]-a[t-1]<<' ';
	  	 	return 0;
		 }
	  }
	cout<<-1;
	return 0;
}
```
# 时间复杂度分析
由于用了两层循环，所以时间复杂度 $O(n^2)$，理论上无法胜任 $1\le n\le 10^5$ 的数据范围。但好在数据比较水，这样的代码也能过，但这不是最好的方法。
# 优化
首先前缀和是必须要的，设 $s_i=\sum^{j=1}_{j\le i}a_j$，我们要想让 $(s_i-s_j) \bmod k=0$，也就是要让 $s_j \equiv s_i \pmod{k}$。我们只需要建立一个哈希表来记录前缀和数组中余数为 $x$ 的第一个位置是哪里，之后如果遇到同样的余数就可以通过哈希表记录的位置快速知道子区间的长度从而进行比较。具体详见代码。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005],sum;
int len,best_start,best_end;
int mod[100000005];//哈希表
int main()
{
	memset(mod,-1,sizeof mod);
	mod[0]=0;//一定要将第0位考虑进去，不然只有90分！
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	 {
	 	sum=(sum+a[i])%k;//前缀和的余数
	 	if(mod[sum]!=-1)//如果这个余数出现过了
	 	 {
	 	 	int new_len=i-mod[sum];//计算新的长度
	 	 	if(new_len>len)
	 	 	 {
	 	 	 	len=new_len;
	 	 	 	best_start=mod[sum]+1;
	 	 	 	best_end=i;
			 }
			else if(new_len==len&&mod[sum]+1>best_start)
			 {
			 	best_start=mod[sum]+1;
	 	 	 	best_end=i;
			 }
      //更新
		 }
		else mod[sum]=i;//记录第一次出现的位置
	 }
	if(len==0) cout<<-1;
	else
	 {
	 	cout<<len<<"\n";
	 	for(int i=best_start;i<=best_end;i++) cout<<a[i]<<' ';
	 }
	return 0;
}

```

---

## 作者：LG086 (赞：0)

$n$ 个数，求最长的和为 $k$ 的倍数的连续的子序列，还要是最靠后的。

我们先前缀和一遍，计算 $s_i=(s_{i-1}+a_i)\bmod k$，使用一个叫 $vs$ 的 map 记录每个 $s_i$ 出现的位置。  
遍历 $vs$，判断是否会存在至少一个和为 $k$ 的倍数的连续的子序列，若无，则直接输出 $-1$。否则进一步寻找。  
我们使 $len$ 代表长度，从 $len = n$ 开始寻找，从后往前找序列，如果找到了方案，直接输出即可。

代码略。

---


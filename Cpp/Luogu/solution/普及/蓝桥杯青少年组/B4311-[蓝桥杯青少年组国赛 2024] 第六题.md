# [蓝桥杯青少年组国赛 2024] 第六题

## 题目描述

某城市的道路构成了一个巨大的树形结构，每一条道路可视为该结构的一条边，而道路的交叉点或端点视为其中的一个节点。该城市共有 $n$ 个节点，编号分别为 $1, 2, 3, \ldots, n$。

为了实时记录道路情况，需要在某些节点部署监控设备。当部署好后，与该节点直接相连的所有道路均能被监控到。为了优化资源分配，在保证整座城市的所有道路都被监控到的前提下，部署监控设备的费用要尽可能少。给定每个节点部署监控设备的费用，请计算要使所有道路都能被监控到的最少花费是多少？

## 样例 #1

### 输入

```
8
33 12 30 22 18 10 31 28
1 2
1 3
2 4
2 5
2 6
3 7
3 8```

### 输出

```
42```

# 题解

## 作者：MingDynasty (赞：18)

## 前言：

皇帝又来写题解了。

[题目传送门](https://www.luogu.com.cn/problem/B4311)

看到树形二字，我们会想到树形 dp。

## 题目思路：

### 状态设置：

设 $dp[i][0/1]$ 表示当前的 $i$ 号节点是否装监控。

### 转移方程：

在转移过程中枚举儿子，先递归下去就行。回溯上来看当前节点装不装监控，如果装，那么儿子可以装也可以不装；如果不装，那么儿子就必须装。初始时输入每个节点装监控的代价即可。

设当前节点是 $x$，$x$ 的儿子是 $y$，01 表示装不装监控。以下就是方程转移式。

```cpp
for(int i=0;i<e[x].size();i++){
  int y=e[x][i];
  dfs(y,x);   //先向下递归
  dp[x][0]+=dp[y][1];
  dp[x][1]+=min(dp[y][0],dp[y][1]);   //转移方程
}
```

**注意：邻接表存图。**

## Code：

```cpp
/*
    Auther:MingDynasty
    Problem:https://www.luogu.com.cn/problem/B4311
*/
#include<bits/stdc++.h>
using namespace std;
int n,a[323232],dp[323232][2];
vector<int> e[323232];
inline void dfs(int x,int fa){
	for(int i=0;i<(int)e[x].size();i++){
		if(e[x][i]==fa) continue;
		dfs(e[x][i],x);
		dp[x][0]+=dp[e[x][i]][1];
		dp[x][1]+=min(dp[e[x][i]][0],dp[e[x][i]][1]);   //方程转移式
	}
}
int main(){
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>dp[i][1];
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,-1);
	cout<<min(dp[1][1],dp[1][0]);
	return 0;
}
```

祝各位通过本题！

---

## 作者：chenzefan (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/B4311)
## 前言
有一天，有一个蒟蒻在题库里搜索了“六”，他发现了一道水题……他小心翼翼地点开**标签**，发现是一道**树形 dp**。蒟蒻自言自语：“刚复习过，切了吧。”然后，他写了一篇题解……
## 涉及知识
- 树形 dp。
## 思路
看到“树形结构”可知，与树有关。

看到“节点 $a$ 和节点 $b$ 之间有一条道路”可知，与图有关。

看到“要使所有道路都能被监控到的最少花费”可知，与 dp 有关。

综上，使用**树形 dp**。
### 状态定义
定义 $dp[N][2]$，其中，$dp_{i,0}$ 表示在 $i$ 号点设置监控的最小值，$dp_{i,1}$ 表示在 $i$ 号点不设置监控的最小值。

于是，容易得出，最后输出 $\min(dp_{1,0},dp_{1,1})$。
### 状态初始化
在 $i$ 号点设置监控，易得，$dp_{i,0}$ 初始值就是 $a_i$。
### 状态转移
- 当 $u$ 号点要设置监控，则与其相连的点设不设置监控都无所谓了，要是答案最小，就取 $\min(dp_{v,0},dp_{v,1})$。
- 当 $u$ 号点要不设置监控，则与其相连的点中一定要有设置监控的，所以取 $dp_{v,0}$。
## 代码（含注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,a[N],dp[N][2];
vector <int> g[N]; 
void dfs(int u,int father){
	dp[u][0]=a[u];//初始化
	for(auto v:g[u]){
		if(v==father) continue;//不回头
		dfs(v,u);//遍历
        //更新
		dp[u][1]+=dp[v][0];
		dp[u][0]+=min(dp[v][1],dp[v][0]); 
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
        //建图
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,0);//搜索
	printf("%d",min(dp[1][0],dp[1][1]));
	return 0;
}
```
## 后记
AC 后发现同学在两天前发了题解，嘿，不知道他和那个蒟蒻找题步骤一不一样呢？

如果你要继续深入，可以做一下这题的加强版[保安站岗](https://www.luogu.com.cn/problem/P2458)。

---

## 作者：guoshengyu1231 (赞：3)

# 思路
这题其实并不难，就是一道裸的树形 dp，只要你懂树形 dp，这题分分钟就能做出来。但在这里我还是简单讲一下树形 dp 吧。

 $\\$ 
树形 dp，顾名思义就是在树上执行的 dp，也就是通过儿子的状态来推断出父亲的状态。好了，讲完了。是的，你没听错，树形 dp 其实非常简单，除了是在树上做，其他的和普通的 dp 没啥两样。所以最主要的还是如何去设计状态。

 $\\$ 
回归原题，我们知道整个城市的所有道路组成了**一颗树**，在树的结点中，我们可以在某些结点布置监控。当其中一个节点被布置了监控，他就可以侦察与之相连的道路。而在第 $i$ 个结点布置监控需要花费 $a_i$ 的费用。问**最少**需要多少费用才能侦察所有道路。

 $\\$ 
从“一棵树”、“最少”这些词中，我们可以很容易联想到树形 dp。既然是 dp，那三要素可不能少。
## 1.状态
我们可以知道每个结点要么装监控，要么不装。故设 $dp_{u,0}$ 为结点 $u$ 不安装监控时以 $u$ 为根节点的子树需要的最少费用。设 $dp_{u,1}$ 为结点 $u$ 安装监控时以 $u$ 为根节点的子树需要的最少费用。
## 2.边界
边界其实很简单，这里一笔带过。对于任意 $i$，$dp_{i,1}=a_i$。
## 3.转移
当自己选择不安装监控，那必须得让他的所有儿子安装监控。 $\\$ 
转移方程：
 $$ dp_{u,0}=\sum dp_{v,1}$$ 
当自己选择安装监控，那他的儿子可以安装监控，也可以不安装，取最小花费即可。 $\\$ 
转移方程：
 $$ dp_{u,1}=\sum \min(dp_{v,1},dp_{v,0})$$  
其中 $v$ 是 $u$ 的其中一个儿子。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int> g[20005];
int dp[20005][2];
void dfs(int u,int f)
{
    for(int v:g[u])
    {
        if(v==f) continue;
        dfs(v,u);
        dp[u][0]+=dp[v][1];
        dp[u][1]+=min(dp[v][0],dp[v][1]);
    }
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) cin>>dp[i][1];
    for(int i=1;i<n;i++)
     {
         int x,y;
         cin>>x>>y;
         g[x].push_back(y);
         g[y].push_back(x);
     }
    dfs(1,0);
    cout<<min(dp[1][1],dp[1][0]); 
    return 0;
}    
```

---

## 作者：huxuanrui19 (赞：1)

# B4311 题解
[题目传送门](https://www.luogu.com.cn/problem/B4311)

最近备战国赛内容，复习一下树形 dp（~~dfs 都不会了~~）。
## 题目大意
有一个由 $n$ 个节点构成的树，

每选择一个节点可以覆盖与之相邻的节点，并且每选择一个节点 $i$ 需要代价 $a_i$。

求最少的代价，使得整棵树被覆盖。

## 题目思路
定义状态 $dp_{i,x}$，其中 $x\in \{0,1\}$，$x=0$ 表示不选该节点，$x=1$ 表示选择该节点。

手推一下状态转移方程，得
$$\begin{aligned}
\begin{cases}
dp_{i,0}=\sum_{a\in t_i} dp_{a,1} \\
dp_{i,1}=\sum_{a\in t_i} \min(dp_{a,1},dp_{a,0})
\end{cases}
\end{aligned}$$

其中 $t_i$ 表示以节点 $i$ 为根的子树。

## 代码实现
有了状态转移方程一切就都好办了。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e4+10;
vector<int> g[N];
int a[N],dp[N][2];
void dfs(int s,int fa){
	dp[s][1]=a[s];
	for(auto d:g[s]){
		if(d==fa) continue;
		dfs(d,s);
		dp[s][0]+=dp[d][1];
		dp[s][1]+=min(dp[d][0],dp[d][1]);
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,0);
	cout<<min(dp[1][0],dp[1][1]);
	return 0;
}
```
（~~感觉此题数据很水~~）

谢谢阅读！

预祝大家参与 2025 蓝桥杯青少组国赛的选手取得好成绩！

---

## 作者：FamousKillerconan (赞：1)

这一题是一道简单的树形DP。


接下来还是那三部曲：设状态、列方程、初始化。


## part1：设状态
看到这题，脑海里闪过：保安站岗。


但是，注意一点，它是要看守所有的边，不是点。


所以，我们设 $dp_{u,0}$ 表示表示这个点设置监控的最小值，$dp_{u,1}$ 表示表示这个点不设置监控的最小值。


## part2：列方程
接下来我们就想，当这个点设立监控时，它的几条路子节点看不看守无所谓，重要的是哪一种花费少，可得方程：


$$
dp_{u,0}=\sum {min(dp_{v,1},dp_{v,0})}
$$


当这个点不设立监控，那么每条路都得由子节点看守，可得方程：


$$
dp_{u,1}=\sum {dp_{v,0}}
$$


## part3：初始化
就是该节点的值（明显），即 $dp_{u,0}=a_u$。


AC 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define PII pair<int,int>
using namespace std;
const int N=1e5+5;
const int INF=0x3f3f3f3f;
const double EPS=1e-6;
const int MOD=1e9+7;
int n,a[N],dp[N][2];
//dp[u][0]表示这个点设置监控的最小值， dp[u][1]表示这个点不设置监控的最小值
vector<int>g[N]; 
void dfs(int u,int fath){
	dp[u][0]=a[u];
	for(auto &v:g[u]){
		if(v==fath)continue;
		dfs(v,u);
		dp[u][1]+=dp[v][0];
		dp[u][0]+=min(dp[v][1],dp[v][0]); 
	}
}
void solve(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(1,0);
	cout<<min(dp[1][0],dp[1][1]);
} 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--)solve();
	return 0;
}
```

---

## 作者：wnqnld_llx (赞：1)

## 题目描述
如题不想多说，题目已经描述的很简单了。
## 问题转换
既然这是一个树形的关系，那么我们就将这些部门转换为一棵树，而费用就是每个节点的权值。
然后考虑题目的要求。这里一定要注意，监控的是边而不是节点，一开始就是这里卡了我很久。对于每个节点，它有选和不选两个情况，所以我们的动归数组就要开二维。设 $f_{i,j}$ 表示以 $i$ 为根节点的子树选取的最小花费。$j=1$ 表示选，$j=0$ 表示不选。

下面我们设 $i$ 为当前考虑的节点，$son$ 为它的相邻节点。
- 如果我们不选 $i$ 这个节点，那么与它相邻的节点一定要选。这个应该是挺容易理解的。因为如果 $i$ 不选，那么于他相邻的几条边都无法得到它的监视，这是如果它的这几条边的另外一个节点，即 $son$ 还不选，那么这条边就无法被监视。所以我们推出动态转移方程 $f_{i,0}=\sum f_{son,1}$。
- 如果选，根据上文，容易得出它的子节点选不选都可以。$f_{i,1}=\sum\min({f_{son,1},f_{son,0}})$。
## 实现过程
用 vector 存储这棵树，用深度优先搜索遍历它，返回时更新答案。注意，由于本题是无向图，所以双向存边，在遍历时为了防止在两个点来回走出不去，要记录一下它的父亲，在代码中有体现。
### code

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int maxn=1e4+10;
int n,w[maxn],f[maxn][2],flag[maxn];
vector <int> tr[maxn];
void dfs(int u,int fa){
    f[u][1]=w[u];
    for(auto son:tr[u]){
    	if(son==fa) continue;//就是这里。
        dfs(son,u);
        f[u][1]+=min(f[son][0],f[son][1]);
        f[u][0]+=f[son][1];
    }
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>w[i];
    }
    for(int i=1;i<n;i++){
        int a,b;
        cin>>a>>b;
        tr[a].push_back(b);
        tr[b].push_back(a);
    }
    dfs(1,0);
    cout<<min(f[1][1],f[1][0]);
    return 0;//完结撒花。
}
```

---

## 作者：cjx_AK (赞：1)

乘着刷树形 dp，来水一波题解。

### 思路
用什么算法呢？标签里说了，题目里也提示了，树形 dp 毋庸置疑。

既然是 dp，总得定义状态吧。显然，这与背包 dp 类似，每个点有取与不取两种状态。

不妨设 $f[i][0]$ 为第 $i$ 号点没取的最小花费，$f[i][1]$ 为第 $i$ 号点取了的最小花费。

$i$ 号点的状态只与它的孩子有关，若它不取，则他孩子必须取，反之其孩子可取可不取。

状态转移方程：

$f[x][0]=f[x][0]+f[y][1]$ 和：$f[x][1]=f[x][1]+\min(f[y][0],f[y][1])$。 

最后输出根节点的答案即可。

oops！我们忘了初始化！

当前这个节点的值若我们没有算过，就默认他取了。

然后你就切了一道黄题。

code：

```
#include<bits/stdc++.h>
#define int long long
const int N=2e5+20;
using namespace std;
int n,f[N][3],a[N];
vector<int>ed[N];
void DP(int x,int father){
	  for(auto y:ed[x]){
		  if(y!=father){
			  DP(y,x);
			  f[x][0]=f[x][0]+f[y][1];
			  f[x][1]+=min(f[y][0],f[y][1]);
		  }
	  }
}
signed main(){
   scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%lld%lld",&u,&v);
		ed[u].push_back(v);
		ed[v].push_back(u);
	}
	for(int i=1;i<=n;i++){
		f[i][1]=a[i];
	}
	DP(1,0);
	printf("%lld",min(f[1][0],f[1][1]));
	return 0;
}
```

支持壶关，忘了私信！

---

## 作者：wyyinput (赞：1)

## 思路
“某城市的道路构成了一个巨大的树形结构”，这就提示我们往树上想。从后文大概可以看出这是一道 DP，结合要往树上想，这题就是一道树形 DP。如果你是大佬，一眼就看出这是树形 DP，就当我没说。

## 状态定义
有了大致方向，不难想到两种状态：$u$ 点装了监控；$u$ 点没装监控。那么定义就出来了：  

$f[u][0]$：$u$ 点没装监控的最小花费；  
$f[u][1]$：$u$ 点装了监控的最小花费。

## 初始化
每个点单独装监控的花费是每个结点的花费（$a[i]$），所以对于每个点 $i$，$f[i][1]$ 的值等于 $a[i]$。

## 状态转移
我们由叶子往根（1号点）推。$v$ 是 $u$ 的儿子，分两种情况：

当 $u$ 不装监控时，$u$ 点到 $v$ 点的道路必须被 $v$ 监视，所以 $f[u][0]$ 要加上 $f[v][1]$。

当 $u$ 装监控时，$u$ 点到 $v$ 点的道路可以（不强制）被 $v$ 监视，所以 $f[u][0]$ 要加上 $f[v][0]$ 和 $f[v][1]$ 的较小值。

那么答案就是 $f[1][0]$ 和 $f[1][1]$ 的较小值。

## 代码
说了那么多，代码就已经出来了。边是双向边。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+1;
int n,f[N][2],head[N],cnt,u,v,k,a[N];
struct edge{
	int to,ne;
}bian[2*N];
void add(int u,int v){
	bian[++cnt]={v,head[u]};
	head[u]=cnt;
	return;
}
void dfs(int u,int fa){
    int v;
	for(int i=head[u];i;i=bian[i].ne){
        v=bian[i].to;
		if(v==fa)
			continue;
		dfs(v,u);
		f[u][0]+=f[v][1];
		f[u][1]+=min(f[v][0],f[v][1]);
	}
	return;
}
int main(){
	scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",a+i),f[i][1]=a[i];
	for(int i=1;i<n;i++){
        scanf("%d%d",&u,&v);
        add(u,v);
        add(v,u);
	}
	dfs(1,0);
	printf("%d\n",min(f[1][0],f[1][1]));
	return 0;
}
```

---

## 作者：TJB_LHY (赞：1)

# 思路

[题目传送门](https://www.luogu.com.cn/problem/B4311)  [双倍经验](https://www.luogu.com.cn/problem/P2016)

这是一道树形 DP 题，大意就是在一棵树中选一些节点，这些点可以监控相邻的节点，问监控所有点最少花费。我们不妨先将节点 $1$ 标为根，设 $dp_{0,x}$ 为不选该节点的最少花费，初始值为 $0$；$dp_{1,x}$ 为选该节点的最少花费，初始值为在该点建造监控的费用。很容易发现：如果选择监控该点，其子节点可以选也可以不选；如果选择不监控该点，其子节点就必须选了。跑一遍 dp，再输出 $\min(dp_{1,1},dp_{0,1})$ 即可。

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
vector<int>G[10005];//存图
int n,a[10005],x,y,dp[2][10005];
void dfs(int u){
    int v;
    dp[1][u]=a[u];//选
    dp[0][u]=0;//不选
    for(int i=0;i<G[u].size();i++){
        v=G[u][i];
        dfs(v);
        dp[1][u]+=min(dp[1][v],dp[0][v]);//子节点可以选，也可以不选
        dp[0][u]+=dp[1][v];//子节点必须选
    }
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<n;i++){
        cin>>x>>y;
        if(x>y)G[y].push_back(x);
        else G[x].push_back(y);
    }//输入
    dfs(1);//树形dp
    cout<<min(dp[1][1],dp[0][1]);//输出
	return 0;
}
```

---

## 作者：sccc_ (赞：0)

# Solution

树形 dp。

定义：设 $dp_{u,0}$ 为在 $u$ 节点不设置监控的最少花费，$dp_{u,1}$ 为在 $u$ 节点设置监控的最少花费。

答案：$\operatorname{min}(dp_{1,0},dp_{1,1})$。

状态转移：

设 $v$ 为节点 $u$ 的可达节点。

- 如果在 $u$ 节点不设置监控，则在 $v$ 节点必须设置监控，$dp_{u,0} = dp_{u,0} + dp_{v,1}$。

- 如果在 $u$ 节点设置监控，则在 $v$ 节点就随便设不设置都可以，$dp_{u,1} = \operatorname{min}(dp_{u,1} + dp_{v,0},dp_{u,1} + dp_{v,1})$。

初始化：$dp_{u,1} = a_u$。

## Code

```c++
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1e4 + 10;

int n, a[kMaxN], dp[kMaxN][2];
vector<int> nbr[kMaxN];

void dfs(int u, int fa) {
	for (auto it : nbr[u]) {
		if (it != fa) {
			dfs(it, u);
			dp[u][0] += dp[it][1];
			dp[u][1] = min(dp[u][1] + dp[it][0], dp[u][1] + dp[it][1]);
		}
	}
}

int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		dp[i][1] = a[i];
	}
	for (int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		nbr[u].emplace_back(v);
		nbr[v].emplace_back(u);
	}
	dfs(1, -1);
	cout << min(dp[1][0], dp[1][1]);
  return 0;
}
```

---

## 作者：ryderyang (赞：0)

# 解题思路
很明显，这道题是一个树形 DP。所以想一下动态规划的三要素。

**确定状态**

  - 我们可以设 $dp_{i,0}$ 表示在第 $i$ 个节点部署监控的最小费用。
  - 再设 $dp_{i,1}$ 表示不在第 $i$ 个节点部署监控的最小费用。

**状态转移**

假设我们现在在节点 $u$。首先，我们肯定要递归调用每一个与节点 $u$ 之间有一条道路的节点 $v$。然后，我们分别对 $dp_{i,0}$ 和 $dp_{i,1}$ 进行转移：

  - 如果第 $u$ 个节点不部署监控，那么节点 $v$ 就一定要部署监控。所以 $dp_{u,0}$ 的值为 $\sum dp_{v,1}$。
  - 如果第 $u$ 个节点部署监控，那么节点 $v$ 可以部署也可以不部署。所以 $dp_{u,1}$ 的值为 $\sum \min(dp_{v,0},dp{v,1})$。

备注：要避免从节点 $u$ 到节点 $v$，又从节点 $v$ 到节点 $u$，不然就会两点之间来回跳跃了。

**边界情况**

对于任何一个节点 $u$，$dp_{u,1}$ 的值都要初始化为 $a_u$，因为部署监控需要费用。

# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10005;
int n,a[N],dp[N][2];
vector<int> edges[N];
void dfs(int u,int fa)//现在在节点 u，是从节点 fa 来的（避免反复横条）
{
	dp[u][1]=a[u];
	for(auto v:edges[u])
	{
		if(v!=fa)
		{
			dfs(v,u);
			dp[u][0]+=dp[v][1];
			dp[u][1]+=min(dp[v][0],dp[v][1]);
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	for(int i=1;i<=n-1;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		edges[u].push_back(v);
		edges[v].push_back(u);
	}
	dfs(1,0);
	printf("%d",min(dp[1][0],dp[1][1]));
	return 0;
}
```

---

## 作者：wangmingrui123456 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4311)
## 1、审题

某城市的道路构成了一个巨大的树形结构，每一条道路可视为该结构的一条边，而道路的交叉点或端点视为其中的一个节点。该城市共有 $n$ 个节点，编号分别为 $1, 2, 3, \ldots, n$。

为了实时记录道路情况，需要在某些节点部署监控设备。当部署好后，与该节点直接相连的所有道路均能被监控到。为了优化资源分配，在保证整座城市的所有道路都被监控到的前提下，部署监控设备的费用要尽可能少。给定每个节点部署监控设备的费用，请计算要使所有道路都能被监控到的最少花费是多少？

这个题有树，也有“最少”、“费用”等词，可以看出是一个树形 dp。
## 2、dp 三要素
### 1、状态
树形 dp 必然有一维用于存结点，而一个点要么装，要么不装，所以第二维是一个存储 $0$、$1$ 的东西，$0$ 表示不装，$1$ 表示装。

因此我们可以定义状态：$dp_{i,0}$ 表示第 $i$ 个点不装监控时，$i$ 的子树装监控所用的最小费用，而 $dp_{1,1}$ 表示第 $i$ 个点装监控时，$i$ 的子树装监控所用的最小费用。

### 2、转移
如何转移呢？

观察图（数字代表费用）：![](https://cdn.luogu.com.cn/upload/image_hosting/d4tl82uk.png)
那么如果费用为 $9$ 的结点装监控，那么费用为 $7$ 的与右边费用为 $2$ 的结点装不装与费用为 $9$ 的结点没有关系了。而如果费用为 $9$ 的结点不装监控，那么费用为 $7$ 的结点与费用为 $2$ 的结点必须装监控，否则 $9$ 与 $7$ 以及 $9$ 与 $2$ 这两条边没有监控管，是不可以的。

设费用用数组 $a$ 存储，所以可以得到状态转移方程：
$$
dp_{i,0}=\sum_{x\in Son_i}dp_{x,1}
$$
$$
dp_{i,1}=a_i+\sum_{x\in Son_i}\min(dp_{x,0},dp_{x,1})
$$
### 3、边界条件
显然，如果一个结点 $v$ 为叶子结点，则 $dp_{v,0}=0$，$dp_{v,1}=a_v$，仍然符合状态转移方程。而应该输出整棵树的费用，应该找根结点，也就是 $\min(dp_{1,0},dp_{1,1})$。
## 3、代码实现
树形 dp 可以在用 dfs 遍历树时转移，具体见代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int father;
    vector<int>son;
}tree[10005];
int n,dp[10005][2],a[10005];
void dfs(int root){
    int sum1=0,sum2=0;
    for(int i=0;i<tree[root].son.size();++i){
        dfs(tree[root].son[i]);
        sum1+=dp[tree[root].son[i]][1];
        sum2+=min(dp[tree[root].son[i]][1],dp[tree[root].son[i]][0]);
    }
    dp[root][0]=sum1;
    dp[root][1]=sum2+a[root];
    //要在dfs回溯时转移，为什么这样做就留作思考题
    return;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%d",&a[i]);
    for(int i=2;i<=n;++i){
        int a,b;
        scanf("%d%d",&a,&b);
        if(a>b)swap(a,b);
        //由于题目没有明确规定谁是谁的父亲/儿子，所以交换顺序是可以的
        tree[a].son.push_back(b);
        tree[b].father=a;
    }
    dfs(1);
    printf("%d",min(dp[1][0],dp[1][1]));
}
```
## 4、闲话
这道题还是有点水，管理大大求过！

---

## 作者：Ak_hjc_using (赞：0)

主要是设计状态，直接设计状态为 $f_{i,0/1}$，表示在当前 $i$ 的子树中，当前节点放或不放监控设备的最少放置代价，剩下的转移就非常明显了，如果当前节点放监控设备，那么必定这条边就不一定要在另一边也配置一个监控设备（如果放置也可以，可以通过构造来 hack），否则就是不放监控设备，自然就必须在另外一个节点放置一个监控设备，所以没有决策，直接加上去，得出转移式 `v[x].d[0] += v[i].d[1], v[x].d[1] += min(v[i].d[0], v[i].d[1])`，注意 `v[i].d[1]` 初始化为 $a_i$（当前放的代价）。

代码给出：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 10001;

struct V {
  vector<int> e;
  int d[2];
} v[kMaxN];
int n;

void S(int f, int x) {
  for (int i : v[x].e) {
    if (i != f) {
      S(x, i);
      v[x].d[0] += v[i].d[1], v[x].d[1] += min(v[i].d[0], v[i].d[1]);
    }
  }
}

int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> v[i].d[1];
  }
  for (int i = 1, x, y; i < n; i++) {
    cin >> x >> y;
    v[x].e.emplace_back(y), v[y].e.emplace_back(x);
  }
  S(0, 1);
  cout << min(v[1].d[0], v[1].d[1]) << '\n';
  return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

考虑树形 DP。为方便，钦定 $1$ 号节点为数的根。设 $dp_{i,0}$ 表示 $i$ 不放监控，以 $i$ 为根的树满足条件的最小代价。$dp_{i,0}$ 表示 $i$ 放监控，以 $i$ 为根的树满足条件的最小代价。于是递归求解。处理 $i$ 的儿子节点 $j$ 时，状态转移方程为： 

$dp_{i,0}=dp_{i,0}+dp_{j,1}$

$dp_{i,1}=dp_{i,1}+\min(dp_{j,0},dp_{j,1})$

也就是说，如果 $i$ 不放监控，那 $i$ 的所有儿子节点都要放监控。如果 $i$ 放监控，那 $i$ 的儿子节点可以放监控，也可以不放。

注意所有的 $dp_{i,1}$ 都要初始化成 $i$ 号节点的部署费用。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[10005],dp[10005][2];
vector<int> v[10005];
void dg(int t,int fa)
{
	for(auto x:v[t])
	{
		if(x==fa) continue;
		dg(x,t);
		dp[t][0]+=dp[x][1];
		dp[t][1]+=min(dp[x][0],dp[x][1]);
	}
}
signed main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],dp[i][1]=a[i];
	for(int i=1;i<n;i++)
	{
		int x,y;
		cin>>x>>y;
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dg(1,0);
	cout<<min(dp[1][0],dp[1][1]);
    return 0;
}
```

---

## 作者：LG086 (赞：0)

树形 dp。

给你一个 $a$ 个节点的树形图，需要在节点上搞监控设备，监控所有边，求最小花费。

对于每个节点 $i$，要么在 $i$ 上有一个监控，要么 $i$ 上没有监控。  
我们于是用 $f_{i,op}$ 表示在以 $i$ 为根结点的子树中装监控的最小花费。其中 $0\le op\le 1$，若 $op = 1$ 即表示我们在 $i$ 上装监控，否则表示我们不在 $i$ 上装监控。

在节点 $i$ 装监控的花费是 $h_i$，所以初始化每个 $n_{i,1} = h_i,n_{i,0} = 0$。

假设有如下图的树。

![](https://cdn.luogu.com.cn/upload/image_hosting/ciuxtbnr.png)

我们发现，若在红色节点装监控，则它周围的 $5$ 条路都会被监控到。此时它的所有子节点上可以装监控，也可以不装。

若红色节点不装监控（如下图所示），则它的所有子节点都必须装监控才可以监控到红色节点周围的道路。

![](https://cdn.luogu.com.cn/upload/image_hosting/hpziukwm.png)

所以我们得到转移方程是：

$$
n_{i,0} = \sum n_{son,1}\\
n_{i,1} = \sum \min(n_{son,1},n_{son,0})
$$

我们默认 $1$ 是根节点。  
dfs 从节点 $1$ 开始遍历树，同时更新 $n$ 数组。最后输出 $\min(n_{1,0},n_{1,1})$ 即可。

核心代码：

```cpp
void dfs(int now,int f){
 for(int x:v[now])
  if(x!=f)
   dfs(x,now),
   n[now][0]+=n[x][1],
   n[now][1]+=min(n[x][0],n[x][1]);
 return ;
}
```

---

## 作者：zhouxuanhong (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4311)

## 思路

树 D 裸题。

我们可以定义 $dp_{i,0}$ 为在 i 节点不放置监控使 i 的子树均被监控的开销，$dp_{i,1}$ 为在 i 节点放置监控使 i 的子树均被监控的开销，$dp_{i,0}$ 这部分包含令 $i$ 的子树也被监控的开销，设 $i$ 的子树为 $son$，由定义得，这部分的转移为：

$$
dp_{i,0}=\sum dp_{son,1}
$$

同理，由定义得，$dp_{i,1}$ 这一部分包含令 $i$ 的子树也被监控的开销加上自己被监控的开销，转移为：

$$
dp_{i,1}=a_{i}+\sum \min(dp_{son,0},dp_{son,1})
$$

答案就在根上。

## 代码

```cpp
#include<map>
#include<iostream>
#include<algorithm>
#include<vector>
#include<bitset>
using namespace std;
int cnt=0,dp[10005][2],a[10005],root=0;
bitset<10005> f;
vector<int> w[10005];
void dfs(int x,int fa){
	dp[x][0]=0;dp[x][1]=a[x];
	for(int to:w[x]){
		if(to==fa)continue;
		dfs(to,x);
		dp[x][0]+=dp[to][1];
		dp[x][1]+=min(dp[to][0],dp[to][1]);
	}
}
int main(){
	int n,p,s;
	cin>>n; 
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<n;++i){
		cin>>p>>s;
		w[p].push_back(s);
		w[s].push_back(p);
		f[s]=1;
	}
	for(int i=1;i<=n;i++){
		if(!f[i]){
			root=i;
			break;
		}
	}
	dfs(root,0);
	cout<<min(dp[root][0],dp[root][1]);
	return 0;
}
```

---


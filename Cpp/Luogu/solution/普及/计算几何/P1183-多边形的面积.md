# 多边形的面积

## 题目描述

给出一个没有缺口的简单多边形，它的边是垂直或者水平的，要求计算多边形的面积。

多边形被放置在一个 $xOy$ 的笛卡尔平面上，它所有的边都平行于两条坐标轴之一。然后按逆时针方向给出各顶点的坐标值。所有的坐标值都是整数，因此多边形的面积也为整数。

**注意：可能存在连续的三个顶点在一条直线上的情况**。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 100$，$-200 \le x,y \le 200$。

## 样例 #1

### 输入

```
10
0 0
4 0
4 1
3 1
3 3
2 3
2 2
1 2
1 3
0 3```

### 输出

```
9```

# 题解

## 作者：Md_Drew (赞：53)

## 超详解释		~~虽然我没学过向量~~


### 其实本题还算简单， 要是任意的多边形模拟就会爆炸了。下面实在不能理解的就当公式感性理解一下吧



------------

------------

## 矢量的概念：


如果一条线段的**端点是有次序之分**的，我们把这种线段成为**有向线段**(directed segment)。

如果有向线段p1，p2的起点p1在坐标原点，我们可以把它称为**矢量(vector) **p2。


------------


## 矢量矢量加减法：

设二维矢量P = ( x1, y1 )，Q = ( x2 , y2 )。

则矢量加法定义为： P + Q = ( x1 + x2 , y1 + y2 )，同样的，矢量减法定义为： P - Q = ( x1 - x2 , y1 - y2 )。



------------

## 矢量的点乘：
P=(x1, y1)，Q=(x2, y2)。则

![]( https://cdn.luogu.com.cn/upload/pic/49949.png )


点乘法可以看成一个向量在另一个向量上的投影与另一个向量的模长相乘。



------------


## 向量的叉乘


设矢量P = ( x1, y1 )，Q = ( x2, y2 )

则矢量叉积定义为由(0,0)、p1、p2和 p1+p2 所组成的平行四边形的**带符号的面积**。

感兴趣的可以去百度一下右手定则

![](https://cdn.luogu.com.cn/upload/pic/49951.png )

其结果是一个标量。

其绝对值等于 ![]( https://cdn.luogu.com.cn/upload/pic/49953.png )


使用向量的叉乘可以判断向量的方向。

若 P × Q > 0 , 则P在Q的顺时针方向。

若 P × Q < 0 , 则P在Q的逆时针方向。

若 P × Q = 0 , 则P与Q共线，但可能同向也可能反向。

实际上在OI中，叉乘用的多。~~其他的都跟狗屎一样~~


------------


## 进入正题

好吧我个蒟蒻~~前面的定义全是从学长ppt拿来的~~真的不好说什么了

下面来举个例子

比如这张图


![](https://cdn.luogu.com.cn/upload/pic/49956.png )



我们随便取一个点D作为我们的基准点。连接BD， DA。

通过**1/2（DE叉乘AD + DA叉乘DB + DB叉乘DC **

(注意**严格按照点的逆时针**方向来算，不然你怎么都推不出面积)

~~之前我就是因为这样跟个SB一样的推了半天~~

那么运用我们之前所学的知识，也知道整个图形面积等于

**三角形DEA + 三角形 DAB + 三角形 DBC**

那你就会问了，这**面积难道不重叠**了吗？？

注意，用叉乘算的三角形DEA + 三角形 DAB的值是负的， 而叉乘算的三角形 DBC的值是正的，等价于去掉了重叠部分。

但是也要**注意**，最后的结果是**负的**



同理，如果我们以C为基准点的话，那么面积为

三角形CED + 三角形CAE +三角形CAB


------------


如果懂的话可以自己推导一下，下面的图形面积

注意下面的是**以原点为基准**，那么就意味着我们要**算n次**，而不是之前推的n-2次

![]( https://cdn.luogu.com.cn/upload/pic/49955.png )

### 意会一下吧!~~映像会更深刻~~



------------

## 下面我就发放代码了。


```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int n;
int x[110], y[110];
int ans;


int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)	scanf("%d%d",&x[i],&y[i]);

	x[n+1] = x[1], y[n+1] = y[1];//注意算n次会涉及到n+1的点，那么这个点即是第一个点

	for(int i=1;i<=n;++i)   ans += (x[i]*y[i+1] - x[i+1]*y[i]);

	printf("%d",abs(ans/2) );//我们最后再取绝对值除二
	return 0;
}
```



---

## 作者：SuperJvRuo (赞：17)

如果一个多边形的顶点是按逆时针（顺时针也可）顺序排列的，那么我们有这样一种简洁的面积算法。

例如下面是一个四边形$P_1P_2P_3P_4$:

[![9IyYuR.jpg](https://s1.ax1x.com/2018/03/18/9IyYuR.jpg)](https://imgchr.com/i/9IyYuR)

设$P_5=P_1$ ，$x_i$是各点在$x$轴上的射影。我们称$P_iX_iX_{i+1}P_{i+1}$是一个“有向梯形”，并定义其面积为：
$$S_i=0.5(x_{i+1}-x_i)(y_i+y_{i+1})$$

“有向梯形”的面积是可正可负的，这就是称其“有向”的原因。而整个四边形的面积则是：
$$S=S_1+S_2+S_3+S_4$$

对于各种特殊的多边形，这个算法仍然成立。这些例子如凹多边形，被x轴切割的多边形，注意右下中有向梯形$P_1x_1x_2P_2$实际上并不是严格的梯形，但这并不影响结果的正确性，这就是“有向梯形”带符号的好处。

[![9IytD1.jpg](https://s1.ax1x.com/2018/03/18/9IytD1.jpg)](https://imgchr.com/i/9IytD1)

这个面积算法对按逆时针排列顶点的四边形的计算结果为正，而对按顺时针排列顶点的四边形的计算结果为负。此外，它也适用于任意多边形。

## 结论：
设多边形顶点按逆时针依次为(x0，y0)，(x1，y1)，(x2，y2)，…，(xn，yn)，其中(xn，yn)=(x0，y0)。那么，多边形面积为：
$$\frac{\sum_{i=0}^{n-1}(x_iy_{i+1}-y_ix_{i+1})}{2}$$

时间和空间复杂度都是O(n)。
```
#include<cstdio>
#include<cmath>

double loc[105][2];
double ans=0.0;
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;++i)
    {
        scanf("%lf %lf",&loc[i][0],&loc[i][1]);
    }
    loc[n][0]=loc[0][0],loc[n][1]=loc[0][1];
    
    for(int i=0;i<n;++i)
    {
    	ans+=0.5*(loc[i][0]*loc[i+1][1]-loc[i][1]*loc[i+1][0]);
    }
    int a=ans;
    printf("%d",a);
    return 0;
}
```

---

## 作者：dfydada⚡⚡⚡ (赞：16)

与其说这是模拟，还不如说是数学会更加准确。

可以这个大的多边形看做几小块拼接而成的，在通过小学知识用边长乘边长求出面积在累加就ok了。

通过小学推算出c++的公式：ans+=(a[i]*b[i+1]-a[i+1]*b[i]);

循环1到n，所以我们在循环之前先把n+1的位置的值赋值为1的位置的值，不然会超界。
当然，你也可以特判。

总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=3000+10;
int n,a[N],b[N];
int ans;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i]>>b[i];
	}
	a[n+1]=a[1];
	b[n+1]=b[1];
	for(int i=1;i<=n;i++)
	{
		ans+=(a[i]*b[i+1]-a[i+1]*b[i]);
	}
	printf("%d",abs(ans/2));
	return 0;
}


```


---

## 作者：Onmyoji (赞：11)

# 这是道数学题啊同志们
**直入正题**

这道题用行列式做十分方便，不过c++貌似并没有行列式的函数（如果有的话还请大佬留个言）

## **重点**

在平面直角坐标系中，令封闭n边形的n个顶点坐标顺次为($\mathbf{x}_1$,$\mathbf{y}_1$),($\mathbf{x}_2$,$\mathbf{y}_2$),($\mathbf{x}_3$,$\mathbf{y}_3$),......,($\mathbf{x}_n$,$\mathbf{y}_n$),那么它的面积S为:

S=$\frac{1}{2}$\*($\begin{vmatrix} \mathbf{x}_1 & \mathbf{y}_1\\\mathbf{x}_2 &  \mathbf{y}_2 \\\end{vmatrix}$+$\begin{vmatrix} \mathbf{x}_2& \mathbf{y}_2\\\mathbf{x}_3 &  \mathbf{y}_3 \\\end{vmatrix}$+$\begin{vmatrix} \mathbf{x}_3 & \mathbf{y}_3\\\mathbf{x}_4 &  \mathbf{y}_4 \\\end{vmatrix}$+...+$\begin{vmatrix} \mathbf{x}_{n-1} & \mathbf{y}_{n-1}\\\mathbf{x}_n &  \mathbf{y}_n \\\end{vmatrix}$+$\begin{vmatrix} \mathbf{x}_n & \mathbf{y}_n\\\mathbf{x}_1 &  \mathbf{y}_1 \\\end{vmatrix}$)


注：$\begin{vmatrix} \mathbf{a} & \mathbf{b}\\\mathbf{c} &  \mathbf{d} \\\end{vmatrix}$的值为a\*d-b\*c


所以这道题就可以直接套公式了对吧

最后直接上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[101],y[101],i,s,n;
int main(){
	cin>>n;
	for(i=0;i<n;i++)cin>>x[i]>>y[i];
	for(i=0;i<n;i++)s+=x[i]*y[i]-x[(i+1)%n]*y[(i+1)%n];
	s/=2;
	cout<<s;
	return 0;
}
```
为了避免抄题解的现象发生，我在这篇代码中做了一点小改动/手动滑稽  
真心希望大家理解(逃  

认真学了下markdown，回来改了一点，麻烦再通过一下，管理员们辛苦啦\~

---

## 作者：山水一程_ (赞：7)

## 这里提供一些思路

这道题是一道基础的计算几何。

很弱的一道题啊。

这道题最基础的方法是用剖分来做。剖分成若干个三角形。对每个三角形求面积。

求面积不要用海伦公式。原因是精度，貌似这道题不要求精度...那就无所谓了。

这种方法只适用于凸多边形

下面介绍一个能够求解任意多边形的方法，先做一下铺垫

用叉积求面积，对于两个向量a(x1,y1),b(x2,y2)

|a*b|=x1*y2-x2*y1

这求得的是两个向量围成的面积，一个平行四边形，所以要除以2

注意：这种方法求出来的是有方向的面积，就是有正负，注意注意

这种有正负经常是有用的

方法来了。还有证明。

计算方法：假设所有顶点为(x1,y1),(x2,y2)...(xn,yn)，把他们看做从原点指向这个点的向量，就是a1(x1,y1),a2(x2,y2)...an(xn,yn)，那么面积就是

|(a1*a2+a2*a3+...+a(n-1)*an+an*a1)/2|（最后的an*a1不要忘记，除以二不要忘记，绝对值不要忘记）

其实就是每一条线段对原点所围成的三角形的有向面积的和

但是....有可能乘法乘反，所以取一个绝对值保险

证明需要用到微元，就是微分

取一个小面积，并且把它看成一个点（够小么）

连接原点，这个点并延长，假设这个延长线（不包括原点到这个点）交多边形的边数为x

那么这个点就在，且只在这x条边的两个端点所求出的有向面积里面被包括

 

①如果这个点在多边形内，那么x一定为奇数（可证明）

（每个线段都是有方向的，从第i个点指向第i+1个点

那么就会有线段从射线左方向穿向右方向，又会有线段从射线左方向穿向右方向

第一种叫做左拐，第二种叫做右拐）

并且一定有关系：左拐数-右拐数=1（可证明）

对这个面积计算的时候会正着计算左拐数次，负着计算右拐数次

于是：正着计算次数-负着计算次数=1

又因为这个面积的大小恒定

所以这个面积计算了1次，正着

 

②如果这个点在多边形外，那么x一定为偶数（可证明）

类似的，左拐数-右拐数=0（可证明）

正着计算次数-负着计算次数=0

又因为这个面积的大小恒定

所以这个面积计算了0次，没有计数

 

综上，在多边形里面的面积计算一次，在多边形外面的面积计算0次，就正确计算出来了多边形的面积

 

算法其实只用保留现在处理的这条线段，所以可以把空间复杂度从O(n)降到O(1)

---

## 作者：Yyxxxxx (赞：5)

我们先来看看例子  用GeoGebra搞的

![](https://cdn.luogu.com.cn/upload/image_hosting/zkg6rxmz.png?x-oss-process=image/resize,m_lfit,h_2000,w_4000)

那么$S_{ABCDEF}=-S_{\triangle OAB}+S_{\triangle OBC}+S_{\triangle OCD}-S_{\triangle ODE}-S_{\triangle OEF}-S_{\triangle OFA}$

那有正有负怎么搞？祭出我们的数学武器：向量叉乘

对于一个$\triangle OBC$
$$S_{\triangle OBC}=\dfrac{1}{2}|\overrightarrow{OC}||\overrightarrow{OB}|\sin<a,b>=\dfrac{1}{2}\overrightarrow{OC}\times\overrightarrow{OB}$$

第二个等号是叉乘的定义，那么第一个等号是为什么？

![](https://cdn.luogu.com.cn/upload/image_hosting/tw132q36.png?x-oss-process=image/resize,m_lfit,h_1000,w_2250)  
$h=|\overrightarrow{b}|\sin<a,b>$
这个四边形的面积就是$|\overrightarrow{a}|h=||\overrightarrow{a}|||\overrightarrow{b}|\sin<a,b>$  
而在坐标系中的叉乘，还可以这么搞：
$$\overrightarrow{a}\times \overrightarrow{b}=(x_a\times y_b-x_b\times y_a)$$
注意，上面这个东西是有向面积，即可以是负的。大概和微积分那种负面积差不多。所以算到最后要取个绝对值。

## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int x[1001],y[1001];
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&x[i],&y[i]);
	x[n+1]=x[1],y[n+1]=y[1];//最后一个点和第一个点乘的时候特殊情况 
	int ans=0;
	for(int i=1;i<=n;i++)
	ans+=(x[i]*y[i+1]-x[i+1]*y[i]);
	printf("%d\n",abs((ans)/2));//绝对值，1/2放到最后再算 
	return 0;
}
```


---

## 作者：Sooke (赞：5)

（注：题解已修改）

本题其实是 **搜索** 与 **数论** 的结合。

首先，你需要认识一个求格点内多边形面积的通项公式，皮克公式 Orz：

$S = \frac{a}{2}+b-1$

其中，a 表示多边形外边一周的点数和，b 表示多边形内的点数和。

对于 a，这个好求，输入已知的顶点，亮出隐藏的点就可以了。我的方法是在输入的每相邻两个点之间查找有没有别的点。

对于 b，这个就需要搜索的精华，此时，务必先看看这一题 P1162，没错，搜索部分是不是很相似？~~复制粘贴就好了~~。

只要求出了 a 和 b，面积 S 张手就来~

此外最重要的一点就是坐标可能为负数，加上 200 当作坐标值即可

不多说，仔细看代码吧。代码如下：

```cpp
#include <cstdio>
#define max(a , b) (a > b ? a : b)
#define min(a , b) (a < b ? a : b)
#define f(i , a , b) for(int i=a ; i <= b ; i++)
bool a[401][401];
int s=0;
void NextStep(int x , int y)
{

    if(a[x][y] == true) return;
    a[x][y]=true , s++;
    NextStep(x+1 , y) , NextStep(x-1 , y);
    NextStep(x , y+1) , NextStep(x , y-1);
}
int main()
{
    int n , x , y , lx , ly , ax , ay , m=0;
    scanf("%d%d%d" , &n , &x , &y);
    ax=x , ay=y;
    f(i , 2 , n)
    {
        lx=x , ly=y;
        scanf("%d%d" , &x , &y);
        f(xi , min(lx , x) , max(lx , x))
        f(yi , min(ly , y) , max(ly , y))
            a[xi+200][yi+200]=true , m++;
    }
    f(xi , min(x , ax) , max(x , ax))
    f(yi , min(y , ay) , max(y , ay))
        a[xi+200][yi+200]=true , m++;
    NextStep(ax+201 , ay+201);
    printf("%d" , (m-n)/2+s-1);
    return 0;
}
```

---

## 作者：丧黑福造 (赞：4)

思路：将多边形分割成若干小三角形，再将它们相加

需要用到[向量积](https://blog.csdn.net/mailzst1/article/details/89554199)的芝士（不过我并不懂，给自己挖个坑，懂的时候回来补

所以直接套公式：

$(\sum\limits_{i=1}^nx_iy_{i+1} -y_ix_{i+1})/2$ 

$\Downarrow$ 

$ans += (x[i] * y[i+1] - y[i] * x[i+1]);ans/=2;$

注：$/2$是因为$S\triangle=ah/2$

$code$:

```cpp
#include <stdio.h>
int x[105], y[105];
int ans;
inline int abs(int x) {
    return x > 0 ? x : -x;
}//绝对值函数
main() {
    int n;
    scanf ("%d", &n);
    for (register int i = 1; i <= n; i ++) scanf ("%d %d", &x[i], &y[i]);
    x[n+1] = x[1], y[n+1] = y[1];//多边形是以最后一个顶点到第一个顶点连接边来封闭的
    for (register int i = 1; i <= n; i ++) ans += (x[i] * y[i+1] - y[i] * x[i+1]);//公式
    printf ("%d\n", abs(ans/2));//可能为负数，套绝对值
    return 0;
}
```

---

## 作者：AcerMo (赞：3)

### 大暴力
#### 不过挺好想的
##### 具体思路
我们只考虑与y轴平行的边，发现属于多边形的部分4定在两条线的中间，那么我们就可以记录maxx，maxy，minx，miny，然后竖着扫，每次只考虑宽为1，那么两条线之间的长度就是面积的大小，然后就对于$y∈[minx,miny]$每次找到两条直线，然后$ans+=r-l$就好了
##### 代码
```cpp
//By AcerMo
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=500;
int n,vis[M][M];
int h[M],z[M];
inline void read(int &x)
{
    x=0;int p=1;char ch=getchar();
    while (!isdigit(ch)) p=ch=='-'?0:1,ch=getchar();
    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();
    return (void)(x=p?x:-x);
}
signed main()
{
    //freopen("polygon.in","r",stdin);
    //freopen("polygon.out","w",stdout);
    read(n);
    int m1=500,m2=0;
    int m3=500,m4=0;
    for (int i=1;i<=n;i++)
    {
        read(h[i]),read(z[i]);
        m1=min(m1,h[i]+205);
        m2=max(m2,h[i]+205);
        m3=min(m3,z[i]+205);
        m4=max(m4,z[i]+205);
    }
    h[0]=h[n];z[0]=z[n];
    for (int i=1;i<=n;i++) 
    {
        if (h[i]==h[i-1])
        for (int k=min(z[i],z[i-1]);k<max(z[i],z[i-1]);k++)
        vis[h[i]+205][k+205]=1;
    }
    int ans=0;
    for (int i=m3;i<=m4;i++)
    {
        int s=0,l=0,x=0;
        for (int k=m1;k<=m2;k++)
        if (vis[k][i])
        {
            if (!x) l=k,x=1;
            else s+=(k-l),x=0;
        }
        ans+=s;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：ASC_8384 (赞：3)

我觉的这是道数学向量题。而且这种思路可以算出任意多边形的面积。

因为任意一个n边形可以分为(n - 2)个三角形，所以只要算出三角形的总面积即可。

已知向量**a**与**b**的乘积的绝对值是以**a**和**b**为边的三角形的面积的一半(夹角 < pi)（等于平行四边形面积）。


S =| ∑(**OPi** × **OPi+1**)| /2
（Pn + 1 = P1）


这么算会出现负数，但是没关系。根据向量乘法的定义，**a** 如果顺时针转到**b**，则向量积为负或正；如果逆时针转，则向量积符号相反。

所以只要向量的端点绕多边形转一圈，多边形内部面积扫过奇数次，计入答案，外部面积扫过偶数次，相反向量互相抵消（解决了负数的问题），最后就得到了答案（别忘记除以2， 并加上绝对值）。


···
for(i = 1; i <= n; i++)

        ans += (a[i] \* b[i + 1] - a[i + 1] \* b[i]);//a[]为x坐标，b[]为y坐标，模拟向量相乘

···

~~暴力可以AC~~


---

## 作者：ysdhd (赞：2)

# 题解

### **不过这道题还用另一种比较简单的做法。可以用向量积的做法来求，不过思路比较复杂**

具体思路（向量积的原理）：只需要把矩形切割成小三角形，然后再把每块小三角形加起来


------------

根据向量积的公式得出面积=abs（x[i]*y[i-1]-x[i-1]*y[i]）/2。
（**向量积**）

因为我们输入时按**逆时针**的顺序，遵循**右手原则**得数是正的不需要带绝对值符号，原点可以初始化为0 0或者为x[1] y[1](为了方便计算,原点的设置不会影响结果）```


![](https://images0.cnblogs.com/i/571629/201405/042248363614504.png)


------------

代码不长就一个方程式即可解决，主要是思路


```cpp
#include <bits/stdc++.h>

using namespace std;

int n,ans,a[4444],b[4444];

int main(){
    
    	cin>>n;
    	for(int i=1;i<=n;i++) cin>>a[i]>>b[i];
    	a[n+1]=a[1];
    	b[n+1]=b[1];
    	for(int i=1;i<=n;i++) ans+=(a[i]*b[i+1]-a[i+1]*b[i]);
    	printf("%d",abs(ans/2));//可以不加abs
}
```

```


---

## 作者：暴力出奇迹NB (赞：1)

~~第一次发题解好激动啊~~

这题最主要的思路就是把大矩形切割成一个一个的小三角形来算面积，再加起来。

那么怎么算呢？我们可以先弄一个长方形出来研究研究。

![](https://cdn.luogu.com.cn/upload/image_hosting/2025a0wa.png)   
逆时针排列：
```
x  y
0  0
4  0
4  3
0  3
```
这个时候我们就要用到向量积（叉积）了，它是个什么东东？[百度是个好东西](https://baike.baidu.com/item/向量积/4601007?fr=aladdin)  
看不懂？没关系 用C++表达就是：     
ans+=(a[i] * b[i+1] - a[i+1] * b[i])  

再看那个长方形ABCD，用公式算：            
(0 * 0 - 4 * 0)+(4 * 3 - 0 * 4)+(4 * 3 - 3 * 0)=24    

这时你可能会疑惑：纳尼？不是12吗？    
**请注意：我们算的是每个小三角形加起来，三角形面积是要除以2的哦~**           
还有一件事：**坐标可能为负，所以要加绝对值的**
（绝对值是abs() 用头文件<cmath> )
  


------------
上代码！！！
  （其中也有注释）
  ```
#include<stdio.h>//就是<cstdio> 个人感觉用.h快一点(大雾 
#include<math.h>
int n,a[105],b[105],ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]);
	a[n+1]=a[1];//多边形最后是靠从最后一个顶点到第一个顶点画一条边来封闭的
	b[n+1]=b[1];//同上 
	for(int i=1;i<=n;i++)
		ans+=(a[i]*b[i+1]-a[i+1]*b[i]);//把矩形切割成三角形，再一个一个加起来 
	printf("%d",abs(ans/2));//三角形面积要/2，且因为坐标可能为负，要套绝对值 
	return 0;
} 
```
  
  
  最后给个小建议：加一个“数论，数学”标签


---

## 作者：xiayucc (赞：1)

来讲一个非常简单的思路：
记总面积为ans
将最小的y当作一条下边界（sum）
之后遍历之前的每一条边，但凡遇到一条水平的直线（x1,y1）->(x2,y2)（此时y1=y2）：

如果他是从右往左的我们只需要ans+=(y1-sum)*|x1-x2|

如果是从左往右的我们只需要ans-=(y1-sum)*|x1-x2|

以下附上AC代码：
```c
#include<bits/stdc++.h>
using namespace std;
struct s
{
   int  x,y;
}a[200];
int n;
int sum=10000,ans=0;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>a[i].x>>a[i].y;
        sum=min(sum,a[i].y);
    }
    for(int i=1;i<n;i++)
    {
        if(a[i].y==a[i-1].y&&a[i].x>a[i-1].x)
        {
            ans-=(a[i].y-sum)*abs(a[i].x-a[i-1].x);
        }
        else  if(a[i].y==a[i-1].y&&a[i].x<a[i-1].x)
        {
             ans+=(a[i].y-sum)*abs(a[i].x-a[i-1].x);
        }
    }
        if(a[0].y==a[n-1].y&&a[0].x>a[n-1].x)
        {
            ans-=(a[0].y-sum)*abs(a[0].x-a[n-1].x);
        }
        else  if(a[0].y==a[n-1].y&&a[0].x<a[n-1].x)
        {
             ans+=(a[0].y-sum)*abs(a[0].x-a[n-1].x);
        }
        cout<<ans<<endl;
     return 0;
}

```
这个题目给我的经验是，不要一碰到题目就往模板上去靠边，其实比起敲模板，想出一种简单的方法更能锻炼我们自己的思维能力

---

## 作者：Allensheng (赞：1)

看见了不少分割多边形的做法。。。
不知道大家还记不记得有一个东东叫做**格点多边形**

不懂的点这里->[百度百科-格点多边形](https://baike.baidu.com/item/%E6%A0%BC%E7%82%B9/9214777?fr=aladdin)

“格点多边形面积公式 [1] 
设某格点多边形内部有格点a个，格点多边形的边上有格点b个，该格点多边形面积为S，
则根据皮克公式有S=（a+b）/2-1”

b可以根据边长计算，a通过遍历计算（就是偶数条边在外面反之亦然）。

代码如下（加入了防抄袭语句）：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x[120],y[120],a,b,minx=300,miny=300,maxx=-300,maxy=-300;
bool have[450][450];
bool check(int x1,int y1){
	if(have[x1+225][y1+225]==true) return false;
	int a1=0,a2=0;
	for(int i=minx-1;i<x1;i++)
		if(have[i+225][y1+225]==true) a1++;
	if(a1%2==0) return false;
	for(int i=miny-1;i<y1;i++)
		if(have[x1+225][i+225]==true) a2++;
	if(a2%2==0) return false;
	return true;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
		minx=min(minx,y[i]);
		miny=min(miny,y[i]);
		maxx=max(maxx,x[i]);
		maxy=max(maxy,x[i]);
	}
	x[0]=x[n],y[0]=y[n];
	for(int i=1;i<=n;i++){
		if(x[i]==x[i-1]){
			b+=abs(y[i]-y[i-1]);
			for(int j=min(y[i-1],y[i]);j<=max(y[i-1],y[i]);j++)
				have[x[i]+225][j+225]=true;
		}
		else{
			b+=abs(x[i]-x[i-1]);
			for(int j=min(x[i-1],x[i]);j<=max(x[i-1],x[i]);j++)
				have[j+225][y[i]+225]=true;
		}
	}
	for(int i=minx-1;i<=maxx+1;i++)
		for(int j=miny-1;j<=maxy+1;j++)
			if(check(i,j)==true) a++;
	cout<<a+b/2-1;
	return 0;
} 
```


---

## 作者：Meronri_Deng (赞：0)

暴力是最美的算法！

因为要区分凹陷很麻烦

所以就这样做了

思路

{

	把点看成格子
    
    把线标成1
    
    从一个肯定不在线里面的点开始把所有点标-1
    
    再数一数下有多少个0 多少个1
    
    0的数量+1的数量/2+1  //皮克定理
    
    然后答案就出来啦 //虽然我代码不是这么写的
}
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[150],b[150];
int mp[460][460];
int aa[300000],bb[300000];//用来bfs的队列
const int Ad=225;//加在负数上就正了
const int nn=460,mm=460;
const int dx[4]={1,-1,0,0};
const int dy[4]={0,0,1,-1};
int kkk=0;
int bfs()//把线外的格点标成-1
{
	int left=1,right=1;
	aa[1]=0; bb[1]=0; mp[0][0]=-1;
	while  (left<=right)
		{
			int  xx=aa[left],yy=bb[left];
			for  (int i=0;i<4;i++)
				{
					int tx=xx+dx[i],ty=yy+dy[i];
					if  (tx>=0&&tx<nn&&ty>=0&&ty<mm&&mp[tx][ty]==0)
						{
							right++;
							mp[tx][ty]=-1;
							aa[right]=tx;
							bb[right]=ty;
						}
				}
			left++;
		}	
	return right;//返回-1数量	
}
int main()
{
	int n;
	scanf("%d",&n);
	for  (int i=1;i<=n;i++)
		scanf("%d%d",&a[i],&b[i]);
	a[n+1]=a[1]; b[n+1]=b[1];
	for  (int i=1;i<=n;i++)
		{
			if  (a[i]==a[i+1])
				{
					int x=b[i]+Ad,y=b[i+1]+Ad,z=a[i]+Ad;
					if  (x>y)
						swap(x,y);
					for  (int i=x;i<=y;i++)
						mp[z][i]=1;
				}
			else
				{
					int x=a[i]+Ad,y=a[i+1]+Ad,z=b[i]+Ad;
					if  (x>y)
						swap(x,y);
					for  (int i=x;i<=y;i++)
						mp[i][z]=1;
				}	
		}
	int aaa=0;	//1的数量
	for  (int i=0;i<nn;i++)
		for  (int j=0;j<mm;j++)
			aaa+=mp[i][j];	
	int aab=460*460-bfs()-aaa;//0的数量
	int ans=aaa/2+aab-1;//皮克定理
	printf("%d\n",ans);		
	return 0;
}
```

---

## 作者：SIGSEGV (赞：0)


~~数论看了头晕的看这里~~

dalao们用的是数学，来一发纯模拟的：
先贴一发40分代码（连样例都过不了的）:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;int a[505][505];
int t1,t2,t3,t4,dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};
struct Node{int x,y;};
queue<Node> q; 
void bfs(int x,int y,int clr) //bfs填充
{
    while (!q.empty()) q.pop();
    q.push({x,y});
    while (!q.empty())
    {
        Node nd = q.front();q.pop();
        if (a[nd.x][nd.y]) continue;
        a[nd.x][nd.y] = clr;
        for (int i = 0;i < 4;i++)
        {
            int nx = nd.x + dx[i],ny = nd.y + dy[i];
            if (nx >= 0 && nx <= 500 && ny >= 0 && ny <= 500) q.push({nx,ny}); //扩展
        }
    }
} 
int main ()
{
    scanf("%d",&n);
    int sx = 0,sy = 0;
    for (int i = 0;i <= n;i++) //为封口，多做一轮
    {
        if (i != n) scanf("%d%d",&t1,&t2); else t1 = sx,t2 = sy;//else的一步用来封口
        t1 += 250;t2 += 250;
        //t1,t2:新读进来的;t3,t4:上一步的
        if (i)
        {
            if (t1 == t3)
            {
                int mv = min(t2,t4),mx = t2 + t4 - mv;//新的坐标和旧的坐标之间连线，mv为坐标较小的，mx为坐标较大的，下同
                for (int i = mv;i <= mx;i++) a[t1][i] = 1;
            }
            else
            {
                int mv = min(t1,t3),mx = t1 + t3 - mv;
                for (int i = mv;i <= mx;i++) a[i][t2] = 1;
            }
        } 
        else
        {
            sx = t1 - 250;sy = t2 - 250;
            //只读了一个点
        }
        t3 = t1;t4 = t2;//更新旧值
    }
    
    bfs(0,0,-1);//填充外面的，用-1表示
    for (int i = 0;i <= 500;i++)
        for (int j = 0;j <= 500;j++)
            if (a[i][j] == 0) bfs(i,j,1);//填充里面的，用1表示
    int ans = 0;
    for (int i = 0;i <= 500;i++)
        for (int j = 0;j <= 500;j++)
            if (a[i][j] == 1 && a[i + 1][j] == 1 
                && a[i][j + 1] == 1 && a[i + 1][j + 1] == 1) ++ans;//每当有2*2的一个全部由1组成的正方形出现时，面积就加1（四个1对应四个点）
    printf("%d\n",ans);
    return 0;
}
```
算法思路：将多边形的线勾出来，然后再算面积。比如对于矩阵

1 1 1 0

1 1 1 1

1 1 1 1

1 1 1 0

一个数字对应一个顶点，图中的图形的面积为3*3-2=7


代码的缺陷是：一些凹进去的东西会算上去:

比如

1 1 1 1

1 1 1 1

1 1 1 1

定义第x行第y列的点为(x,y)，假设题目中是（1，2）到（2，2）中有一条线，（2，2）到（3，2）是一条线，

(3，2）到（3，1）有一条线，则绘图效果和上面那个矩阵一样：凹进去的部分被“填补了”

解决方案为：将矩阵长宽各扩大2倍，勾线时也按原来的2倍画，最后算面积时➗4。

正解代码(相同部分的注释就不写啦):

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;int a[2005][2005];
int t1,t2,t3,t4,dx[] = {1,0,-1,0},dy[] = {0,1,0,-1},lx = 1001,ly = 1001,
    rx = -1,ry = -1;
struct Node{int x,y;};
queue<Node> q; 
void bfs(int x,int y,int clr) 
{
    while (!q.empty()) q.pop();
    q.push({x,y});
    while (!q.empty())
    {
        Node nd = q.front();q.pop();
        if (a[nd.x][nd.y]) continue;
        a[nd.x][nd.y] = clr;
        for (int i = 0;i < 4;i++)
        {
            int nx = nd.x + dx[i],ny = nd.y + dy[i];
            if (nx >= lx && nx <= rx && ny >= ly && ny <= ry) q.push({nx,ny});
        }
    }
}
int main ()
{
    scanf("%d",&n);
    int sx = 0,sy = 0,ssx,ssy;
    scanf("%d%d",&sx,&sy);sx += 1001;sy += 1001;a[sx][sy] = 1;t3 = sx;t4 = sy;
    ssx = sx;ssy = sy;//sx,sy表示当前勾线位置
    //ssx，ssy表示第一个点
    lx = min(lx,ssx);ly = min(ly,ssy);rx = max(rx,ssx);ry = max(ry,ssy);
    //lx,ly左上角坐标，rx,ry右下角坐标，是一个优化
    for (int i = 1;i <= n;i++)
    {
        if (i != n)
        {
            scanf("%d%d",&t1,&t2);t1 += 1001;t2 += 1001;//加1000刚好会RE，悲哀，我在这个地方卡了半个小时
        }
        else t1 = ssx,t2 = ssy;
        if (t1 == t3)
        {
            int dis = 2 * abs(t2 - t4);//距离，下同
            if (t2 < t4)
            {
                for (int i = 1;i <= dis;i++) a[sx][++sy] = 1;
            }
            else
            {
                for (int i = 1;i <= dis;i++) a[sx][--sy] = 1;
            }
        }
        else
        {
            int dis = 2 * abs(t1 - t3);
            if (t1 < t3)
            {
                for (int i = 1;i <= dis;i++) a[++sx][sy] = 1;
            }
            else
            {
                for (int i = 1;i <= dis;i++) a[--sx][sy] = 1;
            }
        }
        
        t3 = t1;t4 = t2;
        lx = min(lx,sx);ly = min(ly,sy);rx = max(rx,sx);ry = max(ry,sy);//更新左上角，右下角
    }
    lx--;rx++;ly--;ry++;//将外面一圈连起来
    bfs(lx,ly,-1);
    for (int i = lx;i <= rx;i++)
        for (int j = ly;j <= ry;j++)
            if (a[i][j] == 0)
            {
                bfs(i,j,1);break; 
            } 
    int ans = 0;
    for (int i = lx;i <= rx;i++)
        for (int j = ly;j <= ry;j++)
            if (a[i][j] == 1 && a[i + 1][j] == 1 
                && a[i][j + 1] == 1 && a[i + 1][j + 1] == 1) ++ans;
    printf("%d\n",ans / 4);
    return 0;
}
```




---


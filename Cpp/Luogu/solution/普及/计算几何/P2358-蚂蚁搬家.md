# 蚂蚁搬家

## 题目描述

边长为 $1$ 的正方体（自行脑补），有一只蚂蚁要从上表面上的一点出发爬往下表面的某一点，规定蚂蚁只能沿正方体表面爬行，要求编程求出一条从起点到终点的最短距离。

起点和终点坐标从键盘输入，设定上下两个表面的坐标原点均为正方形的中心，且两个表面的坐标系的 $X$ 轴和 $Y$ 轴方向一致，输出时保留三位小数。

## 样例 #1

### 输入

```
0.26 0.50 0.50 0.18```

### 输出

```
1.146```

# 题解

## 作者：wjyyy (赞：13)

## 题解：
   **[我的博客](https://www.wjyyy.top/2863.html)**

   一开始只考虑了四种情况，连样例都过不了。分析了一下样例发现可以经过$4$个面来达到最优解。

![img](http://www.wjyyy.top/wp-content/uploads/2018/12/201812162126.png)

   用两个坐标系代表上下表面，正着的是上表面，则有这两种展开方式。左边那种比较好想，每次只有横坐标**或**纵坐标在改变，枚举$4$种也比较好做；而右边这种实际上有$8$种情况，而且$x,y$轴都反过来了，还需要判断正方向。

   好在还可以用坐标来表示，我们依然考虑**在笛卡尔坐标系上求出两个点的欧几里得距离**。

   说人话就是把坐标化在一个坐标系中，勾股定理求距离。

   那么我们分别把这八种情况展开来，就是这样的：

![](http://www.wjyyy.top/wp-content/uploads/2018/12/201812162120.png)

   实线代表我们要统一的，也就是上表面的坐标系；虚线表示原来下表面的坐标系。

   每种情况经过的四个面就是红色箭头经过的面。从中选出一个轨迹，把它折起来，对应的坐标系就变成了图上这样。

   拿先右后下这条路径举个例子，由于$y$变横了，新的横坐标就是$2+y$，新的纵坐标是$-1+x$。其他路径的根据正方向所带的正负号不同。

   上述一共$12$种情况，讨论完全就可以把这道题做出来了。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
double x,y,x_,y_,ans=1e5,X,Y;
void upd()
{
    double dis=sqrt((X-x)*(X-x)+(Y-y)*(Y-y));
    ans=ans<dis?ans:dis;
}
int main()
{
    scanf("%lf%lf%lf%lf",&x,&y,&x_,&y_);
    /***前四种枚举***/
    X=2-x_;//右
    Y=y_;
    upd();
    X=-2-x_;//左
    upd();
    X=x_;//上
    Y=2-y_;
    upd();
    Y=-2-y_;//下
    upd();
	/***后八种枚举***/
    X=1-y_;//上右
    Y=2-x_;
    upd();
    X=-1+y_;//上左
    Y=2+x_;
    upd();
    X=-2+y_;//左上
    Y=1+x_;
    upd();
    X=-2-y_;//左下
    Y=-1-x_;
    upd();
    X=-1-y_;//下左
    Y=-2-x_;
    upd();
    X=1+y_;//下右
    Y=-2+x_;
    upd();
    X=2+y_;//右下
    Y=-1+x_;
    upd();
    X=2-y_;//右上
    Y=1-x_;
    upd();
    printf("%.3lf\n",ans);
    return 0;
}
```

---

## 作者：opened (赞：3)

# 题解：计算几何

计算此类三维问题时，一般思路是讨论展开方式，此题中的蚂蚁需经过一或两个侧面，对其分别进行讨论：
	
   	1.经过一个侧面I型：4个侧面、所以有四种
    
       2.经过两个侧面Z型：可以想象一个‘Z’型展开图，它的镜像也是一种，又因为有4个侧面，于是有2*4=8种情况
       
**共计12种展开方式**

~~对每种进行计算~~ 找规律，找系数、常数不相同的地方，循环打表或手工计算勾股定理求最小值均可~~（懒癌患者推荐第二种）~~，让代码可读性增强

 _注意数据类型_ 
 
# Talk is cheap, show me the code.

```#include<iostream>
#include<cstdio>
#include<cmath>
double sx,sy,tx,ty,ans=0x7f;
using namespace std;
inline double square(double x){return x*x;}
int main(){//展开进行计算:三维->二维，勾股定理进行计算 
	scanf("%lf%lf%lf%lf",&sx,&sy,&tx,&ty);
	ans=min(ans,sqrt(square(sx+tx+2)+square(sy-ty)));//I型计算 
	ans=min(ans,sqrt(square(-sx-tx+2)+square(sy-ty)));
	ans=min(ans,sqrt(square(sx-tx)+square(sy+ty+2)));
	ans=min(ans,sqrt(square(sx-tx)+square(-sy-ty+2)));
	
	ans=min(ans,sqrt(square(-sx-ty+2)+square(-sy-tx+1)));//Z型计算 
	ans=min(ans,sqrt(square(-sx-ty+1)+square(-sy-tx+2)));
	ans=min(ans,sqrt(square(sx-ty+2)+square(-sy+tx+1)));
	ans=min(ans,sqrt(square(sx-ty+1)+square(-sy+tx+2)));
	ans=min(ans,sqrt(square(-sx+ty+2)+square(-sy+tx+1)));
	ans=min(ans,sqrt(square(-sx+ty+1)+square(-sy+tx+2)));
	ans=min(ans,sqrt(square(sx+ty+2)+square(sy+tx+1)));
	ans=min(ans,sqrt(square(sx+ty+1)+square(sy+tx+2)));
	
	printf("%.3lf\n",ans);
	return 0;
}```

---

## 作者：IAKIOIpwp (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2358)

### 算法：

模拟与几何。

### 解题思路：

这题运用了数学知识，我们可以画出正方形的展开图，此处就不画了，具体的展开图可以自己画或者去网上搜。

题面中蚂蚁要从上表面上的一点出发爬往下表面的某一点, 就可以想成两个对面的两个点之间的距离。

那我们就可以找规律，那正方形的展开图的规律是什么呢？

正方形的展开图的规律是 Z 字形和一字型，就是成对面的是 Z 字或一字。

有了正方形的展开图的规律，我们就可以依次模拟一字（就是直接对着走的，穿过中间 $1$ 格）和 Z 字（斜着穿过两或三个格）的情况，最后输出最小值就可以了。

### 代码：

前四个是模拟一字型，后四个是模拟 Z 字型。


```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
double ans=1e9; 
double jl(double sx,double sy,double tx,double ty){//求距离 
	return sqrt((sx-tx)*(sx-tx)+(sy-ty)*(sy-ty));
}
int main(){
	double sx,sy,tx,ty;
	cin>>sx>>sy>>tx>>ty;
	sx+=0.5;//让坐标变成正的 
	sy+=0.5;
	tx+=0.5;
	ty+=0.5;
	ans=min(ans,jl(sx,1-sy,tx,ty+2));//模拟一字型 
	ans=min(ans,jl(sy,sx,ty,tx+2));
	ans=min(ans,jl(sx,sy,tx,-ty+3));
	ans=min(ans,jl(sy,sx,ty,-tx+3));
	ans=min(ans,jl(1-sy,sx,2-tx,ty+2));//模拟Z字型 
	ans=min(ans,jl(sx,sy,2-ty,tx+2));
	ans=min(ans,jl(sy,sx,2-tx,-ty+3));
	ans=min(ans,jl(sx,sy,2-ty,-tx+3));
	printf("%.3lf",ans);//输出答案，注意要保留3位小数 
	return 0; 
}
```

---

## 作者：lytqwq (赞：1)

~~这道题显然可以用初一知识解决，甚至还能长方体~~

运用初一知识，我们可以画出正方形展开图[如果你懒得画](https://wenku.baidu.com/view/0476613569dc5022abea0014.html)

题面中**有一只蚂蚁要从上表面上的一点出发爬往下表面的某一点,** 就可以想成两个对面的两个点之间的距离，正方形的展开图的规律是Z字形和一字型，就是**成对面的是Z字或一字** ~~（废话）~~ ，所以，我们模拟一字（就是直接对着走的，穿过中间1格）和Z字（斜着穿过两个格）的情况，最后输出最小值就行了。

可能你会问：正方形展开图中有一个141的图中的Z字型中间穿了3个啊，但是这不影响我们，这个展开图穿三格的距离太大了，就算不模拟出他，对我们的取最小没有影响 ~~（有神仙愿意写写吗）~~

代码如下（前四个min是模拟一字型，后四个是模拟Z字型）：

```cpp
#include<bits/stdc++.h>
using namespace std;
double xf,yf,xt,yt;
double ans=100;
double dis(double x,double y,double xx,double yy)
{
	return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
int main()
{
	scanf("%lf%lf%lf%lf",&xf,&yf,&xt,&yt);
	xf+=0.5;
	yf+=0.5;
	xt+=0.5;
	yt+=0.5;
	ans=min(ans,dis(xf,1-yf,xt,yt+2));
	ans=min(ans,dis(yf,xf,yt,xt+2));
	ans=min(ans,dis(xf,yf,xt,-yt+3));
	ans=min(ans,dis(yf,xf,yt,-xt+3));
	
	
	ans=min(ans,dis(1-yf,xf,2-xt,yt+2));
	ans=min(ans,dis(xf,yf,2-yt,xt+2));
	ans=min(ans,dis(yf,xf,2-xt,-yt+3));
	ans=min(ans,dis(xf,yf,2-yt,-xt+3));
	printf("%.3lf",ans);
}
```


---

## 作者：chenyy (赞：1)

看了下讨论里别人的题解和班上同学一遍遍推式子写了12种的繁琐，我决定来写个题解。

大家都知道这题要把立方体变成平面，这里就不多赘述了。

很明显，蚂蚁不可能经过3个面，只有可能经过1、2个面两种情况。

但2个面的情况又分为两种，向下向左和向下向右。

因为上下底面需要同时旋转，每次旋转90度，因此旋转有4种情况，

这样总共就是4\*(1+2)种情况。

对于3个面的情况，写个spin(旋转)函数，按照顺时针方向或逆时针方向，注意旋转之后的上下表面方向差问题，对于经过不同的面，方向差有+1%4和+3%4和不变三种，然后在main函数里两个for循环去枚举就好了

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
struct Pos {
    double x,y;
};
Pos u;//上表面
Pos d;//下表面
inline Pos spin(int dir,const Pos &in) {
    Pos out;
    switch (dir) {//按照顺时针顺序旋转，便于在后面直接取mod
        case 0:
            out.x = in.x;
            out.y = in.y;
            break;
        case 1:
            out.x = in.y;
            out.y = 1 - in.x;
            break;
        case 2:
            out.x = 1 - in.x;
            out.y = 1 - in.y;
            break;
        case 3:
            out.x = 1 - in.y;
            out.y = in.x;
            break;
    }
    return out;
}
inline double g(double x,double y) {
    return sqrt(x*x+y*y);
}
double work(int dir,int width) {
    /*
    width就是中间的宽度
        ----
        |  |
        ----
        |  |
        ----
        |  |
        ----
    width = 0
        ----
        |  |
    -------
    |  |  |
    -------
    |  |
    ----
    width = -1
    width = 1的情况以此类推
    */
    Pos a;//上表面的旋转位置
    Pos b;//下表面的旋转位置
    double w;
    switch (width) {
        case 0:
            a = spin(dir,u);
            b = spin(dir,d);
            w = a.x - b.x;
            break;
        case 1:
            a = spin(dir,u);
            b = spin((dir+1)%4,d);//因为展开后上下表面旋转角度不一，可推出下表面的角度多旋转了90度
            w = 1 - a.x + b.x;
            break;
        case -1:
            a = spin(dir,u);
            b = spin((dir+3)%4,d);
            w = 1 - b.x + a.x;
            break;
    }
    //printf("dir=%d,width=%d,x=%lf,y=%lf\n",dir,width,w,a.y+1+b.y);
    return g(w,a.y+b.y+1);
}
int main() { 
    scanf("%lf%lf%lf%lf",&u.x,&u.y,&d.x,&d.y);
    u.x+=0.5;
    u.y+=0.5;
    d.x+=0.5;
    d.y+=0.5;
    //坐标+0.5，范围变为0~1，比较好计算 
    double ans = 1e9;//一个较大值当作INF
    for (int w=-1;w<=1;w++)
        for (int d=0;d<=3;d++)
            ans = min(ans,work(d,w));
    printf("%0.3lf\n",ans);
    return 0;
}
```

---

## 作者：xzz_0611 (赞：0)

[题目传送门](/problem/P2358)
### 思路分析
路径最短，那么只有两种走法——`I` 字型和 `Z` 字型：
- `I` 字型：从上面出发，经过一个侧面，到达底部。
- `Z` 字型：从上面出发，经过两个侧面，到达底部。

知道了这个以后，就可以将正方形展开成对应的形状，求出两点横坐标与纵坐标的差，再利用勾股定理求距离即可。
![](https://cdn.luogu.com.cn/upload/image_hosting/mpsqjtq1.png)
### Code
```cpp
#include <iostream>
#include <cmath>
using namespace std;
double xx1, yy1, xx2, yy2;
double ans = 100000;
double CountDis(double x, double y) {//勾股定理求距离
	return sqrt(x * x + y * y);
}
signed main() {
	ios::sync_with_stdio(false), cin.tie(), cout.tie();
	cin >> xx1 >> yy1 >> xx2 >> yy2;
	ans = min(ans, CountDis(2 - xx1 - xx2, yy1 - yy2));//I 字型
	ans = min(ans, CountDis(2 + xx1 + xx2, yy1 - yy2));
	ans = min(ans, CountDis(2 - yy1 - yy2, xx1 - xx2));
	ans = min(ans, CountDis(2 + yy1 + yy2, xx1 - xx2));
	ans = min(ans, CountDis(2 - xx1 - yy2, 1 - yy1 - xx2));//Z 字型
	ans = min(ans, CountDis(1 - xx1 - yy2, 2 - yy1 - xx2));
	ans = min(ans, CountDis(2 + xx1 - yy2, 1 - yy1 + xx2));
	ans = min(ans, CountDis(1 + xx1 - yy2, 2 - yy1 + xx2));
	ans = min(ans, CountDis(2 + xx1 + yy2, 1 + yy1 + xx2));
	ans = min(ans, CountDis(1 + xx1 + yy2, 2 + yy1 + xx2));
	ans = min(ans, CountDis(2 - xx1 + yy2, 1 + yy1 - xx2));
	ans = min(ans, CountDis(1 - xx1 + yy2, 2 + yy1 - xx2));
	printf("%.3lf", ans);//输出，保留 3 位小数
	return 0;
}
```

---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P2358)。

## 解题思路

模拟，计算几何。

折叠后上下两个表面的坐标原点均为正方形的中心，且两个表面的坐标系的方向一致。

十二种展开方式分类讨论，将三维问题转化为二维问题，计算可能的路径，取最小值。

## 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
double x_1,y_1,x_2,y_2,ans=0x3f3f3f3f;
double calc(double x,double y){
	return sqrt(pow((x-x_1),2)+pow((y-y_1),2));
}
int main(){
	scanf("%lf%lf%lf%lf",&x_1,&y_1,&x_2,&y_2);
	ans=min(ans,calc(x_2, -2-y_2));
	ans=min(ans,calc(x_2, 2-y_2));
	ans=min(ans,calc(-2-x_2, y_2));
	ans=min(ans,calc(2-x_2, y_2));
	ans=min(ans,calc(y_2+2, x_2-1));
	ans=min(ans,calc(y_2+1, x_2-2));
	ans=min(ans,calc(y_2-1, x_2+2));
	ans=min(ans,calc(y_2-2, x_2+1));
	ans=min(ans,calc(1-y_2, 2-x_2));
	ans=min(ans,calc(2-y_2, 1-x_2));
	ans=min(ans,calc(-1-y_2, -2-x_2));
	ans=min(ans,calc(-2-y_2, -1-x_2));
	printf("%.3lf",ans);
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 题意理解：

- 给定一个边长为 $1$ 的正方体，从上表面某一点出发，到达下表面某一点，求最短路径。

- 蚂蚁只能沿正方体表面爬行，即只能走正方体的表面，不能穿过正方体。

- 可以将上表面地面和下表面抽象成平面，且两个平面的坐标系的 X 轴和 Y 轴方向一致。

- 输入起点和终点的坐标。

- 输出最短距离，保留三位小数。

### 思路分析：

- 将正方体展开成一些小的区域，每个区域都是一个正方形，一共有 $6$ 个面，每个面包含 $9$ 个小正方形。

- 可以将蚂蚁从上表面的某一点 $a$ 移动到下表面的某一点 $b$，等价于在正方体的某个面上沿着正方形的边界从 $a$ 到 $b$，再绕过正方体到达目标面的 $b$ 点。

- 蚂蚁从 $a$ 点到 $b$ 点的最短路径，可以分解成两步走：

    - 第一步：蚂蚁从 $a$ 点走到某个面的边界上的一个点 $c$，这个点 $c$ 可以是 $a$ 点所在的面上的点，也可以是正方体的另一个面上的点。

    - 第二步：蚂蚁从 $c$ 点到达目标面的 $b$ 点，也就是在目标面的边界上找到一个点 $d$，使得 $c$ 点和 $d$ 点连线的长度最短。

- 对于第一步，可以将正方体展开，将正方体的每个面都展开成一个矩形，将 $a$ 点和 $b$ 点所在的面展开到同一个平面上，然后在平面上寻找一条最短路径，使得蚂蚁从 $a$ 点到达正方体的边界。

- 对于第二步，可以先将正方体的一个面展开，并将起点 $c$ 映射到展开面上的一个点 $C$，将终点 $b$ 映射到展开面上的一个点 $D$，然后在展开面上找到一条最短路径，使得蚂蚁从 $C$ 点到达 $D$ 点，再将这个路径映射回正方体的表面。

- 最后将两个步骤的路径长度相加就是蚂蚁从 $a$ 点到 $b$ 点的最短路径。
### 代码：
额，写的太丑了，就不拿出来丢人现眼了~

~~不过你通过上述的推导应该能自己写出来了吧！~~

---

## 作者：zhangliyuan111 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2358)

## 题意分析
### 题意
求从正方体表面上 $A$ 到 $B$ 的最短距离。

### 分析
- 平面中两点之间线段最短。
  
- 蚂蚁只能在正方体表面上移动。
  
- 求出的最短距离肯定在某种表面展开方式上是一条连续的线段

- 所以可以**枚举所有展开方式**，算出距离，取最小值！


### 如何求两点之间的距离：
![](https://img2.baidu.com/it/u=567225082,4040976179&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=329) 
( 图片来源于网络，侵删 )

  由图易知，线段 $P_1Q$ 的长度等于 $|x_2-x_1|$ ，线段 $P_2Q$ 的长度等于 $|y_2-y_1|$ 。又因为勾股定理，$P_1P_2=\sqrt{P_1Q^2+P_2Q^2}$

  整体来看，我们就能得到两点间距离公式：$Dis = \sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$
```cpp
double dis(double x1,double y1,double x2,double y2) {
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
```

### 正方体的所有展开方式

我们只需要考虑对立面的情况，也就是两种，“一” 字型和 “ Z ” 字型的情况。**注意！一定要考虑全面。共 $4+8=12$ 种**

 - “一”字形：（ $4$ 种）
    - 上->前->下
    - 上->后->下
    - 上->左->下
    - 上->右->下

 - “Z”字形：（ $8$ 种）
    - 上->前->右->下
    - 上->前->左->下
    - 上->后->右->下
    - 上->后->左->下
    - 上->右->前->下
    - 上->右->后->下
    - 上->左->前->下
    - 上->左->后->下

## 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
//计算两点距离 
double dis(double x1,double y1,double x2,double y2) {
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

int main() {
	double a,b,c,d;
	double ans=1000000000;
	cin>>a>>b>>c>>d;
	//“一”字形 
	ans = min(ans,dis(a,b,2-c,d));
	ans = min(ans,dis(a,b,-2-c,d));
	ans = min(ans,dis(a,b,c,2-d));
	ans = min(ans,dis(a,b,c,-2-d));
	//“Z”字形 
	ans = min(ans,dis(a,b,1-d,2-c));
	ans = min(ans,dis(a,b,-1+d,2+c));
	ans = min(ans,dis(a,b,-1-d,-2-c));
	ans = min(ans,dis(a,b,1+d,-2+c));
	ans = min(ans,dis(a,b,2+d,-1+c));
	ans = min(ans,dis(a,b,2-d,1-c));
	ans = min(ans,dis(a,b,-2+d,1+c));
	ans = min(ans,dis(a,b,-2-d,-1-c));

	printf("%.3lf",ans);
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/173051921)

---

## 作者：cenxinyang12 (赞：0)

## [传送门](https://www.luogu.com.cn/problem/P2358)
# 题意
题目里写的很清楚了，其实就是求正方形展开后两点之间的**欧几里得距离**。
## 欧几里得距离
就是两点之间的直线距离，用**勾股定理**求出。

代码实现：
```cpp
void sum(double x,double y,double a,double b){ans=min(ans,sqrt((x-a)*(x-a)+(y-b)*(y-b)));}
```
# 思路
正方体的展开方式很多

![](https://cdn.luogu.com.cn/upload/image_hosting/73aycon4.png)

在本题中，我们需要先把正方体展开。那样起点和终点之间**一共会有12种路线**的情况：
- **直线（只经过一个面）**，共四种
- **类似于“日”字形（或 Z 字形）的路线**，共八种

之后进行分类讨论即可。要注意的是第二种路线的 $x$ 轴和 $y$ 轴的关系，不能搞反了。我为此调了很久，它居然[只错一个点](https://www.luogu.com.cn/record/130394695)。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,d,ans=2e9;
void sum(double x,double y,double a,double b){ans=min(ans,sqrt((x-a)*(x-a)+(y-b)*(y-b)));}
//简单的欧几里得
int main(){
	ios::sync_with_stdio(0);cin.tie(0);
	
	cin>>a>>b>>c>>d;
	//第一大类路线
	sum(a,b,2-c,d);sum(a,b,-2-c,d);
	sum(a,b,c,2-d);sum(a,b,c,-2-d);
	//第二大类路线
	sum(a,b,1-d,2-c);sum(a,b,-1+d,2+c);
	sum(a,b,-1-d,-2-c);sum(a,b,1+d,-2+c);
	sum(a,b,2+d,-1+c);sum(a,b,2-d,1-c);
	sum(a,b,-2+d,1+c);sum(a,b,-2-d,-1-c);
	
	printf("%.3lf",ans);
	
	return 0;
}
```
~~应该不难看懂吧~~

---


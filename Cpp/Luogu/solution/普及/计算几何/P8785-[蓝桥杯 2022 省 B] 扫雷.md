# [蓝桥杯 2022 省 B] 扫雷

## 题目描述

小明最近迷上了一款名为《扫雷》的游戏。其中有一个关卡的任务如下，在一个二维平面上放置着 $n$ 个炸雷，第 $i$ 个炸雷 $\left(x_{i}, y_{i}, r_{i}\right)$ 表示在坐标 $\left(x_{i}, y_{i}\right)$ 处存在一个炸雷，它的爆炸范围是以半径为 $r_{i}$ 的一个圆。

为了顺利通过这片土地，需要玩家进行排雷。玩家可以发射 $m$ 个排雷火箭，小明已经规划好了每个排雷火箭的发射方向，第 $j$ 个排雷火箭 $\left(x_{j}, y_{j}, r_{j}\right)$ 表示这个排雷火箭将会在 $\left(x_{j}, y_{j}\right)$ 处爆炸，它的爆炸范围是以半径为 $r_{j}$ 的一个圆，在其爆炸范围内的炸雷会被引爆。同时，当炸雷被引爆时，在其爆炸范围内的炸雷也会被引爆。现在小明想知道他这次共引爆了几颗炸雷?

你可以把炸雷和排雷火箭都视为平面上的一个点。一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。

## 说明/提示

**【样例说明】**

示例图如下, 排雷火箭 1 覆盖了炸雷 1 , 所以炸雷 1 被排除; 炸雷 1 又覆 盖了炸雷 2 , 所以炸雷 2 也被排除。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_3d61ad9326a0012c9fdag-13.jpg)

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例: $0 \leq x, y \leq 10^{9}, 0 \leq n, m \leq 10^{3}, 1 \leq r \leq 10$.

对于 $100 \%$ 的评测用例: $0 \leq x, y \leq 10^{9}, 0 \leq n, m \leq 5 \times 10^{4}, 1 \leq r \leq 10$. 


蓝桥杯 2022 省赛 B 组 H 题。

## 样例 #1

### 输入

```
2 1
2 2 4
4 4 2
0 0 5```

### 输出

```
2```

# 题解

## 作者：zzy0618 (赞：25)

改掉了之前的错误解法，这下应该没问题了。

## 思路

有一个性质是 $r\le 10$，也就是一个雷至多引爆 $10^2$ 级别个的**位置**（不是个数）的雷，而雷的数量级足够我们去暴力寻找这些位置。

将所有炸雷存到一个桶里面，具体的，使用 `map` 编号，然后存一下在这个位置雷的个数以及这个位置最大的 $r$。对于每个一个排雷火箭使用 dfs 暴力搜，已经被搜过的地方打个标记就行。

这样复杂度是 $O(r^2(n+m)\log n)$ 的，可以通过此题。

## 代码

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define mk make_pair
using namespace std;
const int N=1e5+5,M=290023;
int n,m,ans,tot;
int cnt[N],tmp[N],vis[N];
map<pii,int> mp;
void dfs(int x,int y,int r){
	for(int i=x-r;i<=x+r;++i){
		for(int j=y-r;j<=y+r;++j){
			if((i-x)*(i-x)+(j-y)*(j-y)>r*r)continue;
			if(mp.count(mk(i,j))){
				int z=mp[mk(i,j)];
				if(vis[z])continue;
				vis[z]=1;ans+=cnt[z];
				dfs(i,j,tmp[z]);
			}
		}
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1,x,y,z,r;i<=n;++i){
		cin>>x>>y>>r;
		if(mp.count(mk(x,y))){
			int z=mp[mk(x,y)];
			++cnt[z],tmp[z]=max(tmp[z],r);
		}else
			mp[mk(x,y)]=++tot,
			cnt[tot]=1,tmp[tot]=r;
	}for(int i=1,x,y,r,z;i<=m;++i)
		cin>>x>>y>>r,dfs(x,y,r);
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：clarinet_pht (赞：0)

## 题意描述
在二维平面上有 $n$ 个炸雷（坐标 $(x_i,\ y_i)$，半径 $r_i$）和 $m$ 个排雷火箭（坐标 $(x_j,\ y_j)$，半径 $r_j$）。排雷火箭会引爆其爆炸范围内的所有炸雷，被引爆的炸雷又会引爆其范围内的其他炸雷。求最终被引爆的炸雷总数。

## 思路
直接暴力枚举所有炸雷的时间复杂度为 $O(n^2)$，明显会炸。

经过一系列头脑风暴，想到如下优化：网格离散化，将平面划分为 $10 \times 10$ 的网格（因最大半径 $r \leq 10$）。哈希表存储每个网格中的炸雷链表。

BFS 处理连锁反应：从排雷火箭开始，引爆范围内的炸雷，并继续处理被引爆炸雷的连锁反应。

先初始化：初始化炸雷和排雷火箭数据。构建网格到炸雷的映射。处理每个排雷火箭，检查周围 9 个网格内的炸雷。

再使用 BFS 处理连锁爆炸，实时删除已引爆炸雷避免重复处理。

时间复杂度如下：预处理：$O(n)$ 构建网格映射。查询处理：每个炸雷最多被处理一次，均摊 $O(n)$。总体复杂度：$O(n + m)$。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=10;
struct Point {
	int x,y,r;
	bool ex;
};
struct Gkey{
	int cx,cy;
	bool operator==(const Gkey&other)const{
		return cx==other.cx&&cy==other.cy;
	}
};
struct Ghx{
	size_t operator()(const Gkey&key)const{
		return hash<int >()(key.cx)^hash<int >()(key.cy);
	}
};
signed main()
{	
	int n,m;
	cin>>n>>m;	
	vector<Point >mn(n);
	for(int i=0;i<n;i++)
	{
		cin>>mn[i].x>>mn[i].y>>mn[i].r;
		mn[i].ex=false;
	}
	vector<Point>rts(m);
	for(int i=0;i<m;i++)
		cin>>rts[i].x>>rts[i].y>>rts[i].r;
	//构建网格映射
	unordered_map<Gkey,list<int>,Ghx>gmp;
	for(int i=0;i<n;i++)
	{
		int cx=mn[i].x/N;
		int cy=mn[i].y/N;
		gmp[{cx,cy}].push_back(i);
	}
	queue<int >q;
	int total=0;
	//处理排雷火箭
	for(auto&rt:rts)
	{
		int cx0=rt.x/N;
		int cy0=rt.y/N;
		for(int dx=-1;dx<=1;dx++)
			{
			for(int dy=-1;dy<=1;dy++)
			{
				int cx=cx0+dx;
				int cy=cy0+dy;
				Gkey key{cx,cy};
				if(!gmp.count(key))
					continue;
				auto&lst=gmp[key];
				for(auto it=lst.begin();it!=lst.end();)
				{
					int idx=*it;
					if(mn[idx].ex)
					{
						it=lst.erase(it);
						continue;
					}
					int dx2=rt.x-mn[idx].x;
					int dy2=rt.y-mn[idx].y;
					int dist_sq=dx2*dx2+dy2*dy2;
					if(dist_sq<=rt.r*rt.r)
					{
						mn[idx].ex=true;
						total++;
						q.push(idx);
						it=lst.erase(it);
					}else
						it++;
				}
				if(lst.empty())
					gmp.erase(key);
			}
		}
	}
	//BFS处理连锁爆炸
	while(!q.empty())
	{
		int idx=q.front();
		q.pop();
		int cx0=mn[idx].x/N;
		int cy0=mn[idx].y/N;
		for(int dx=-1;dx<=1;dx++)
		{
			for(int dy=-1;dy<=1;dy++)
			{
				int cx=cx0+dx;
				int cy=cy0+dy;
				Gkey key{cx,cy};
				if(!gmp.count(key))
					continue;
				auto&lst=gmp[key];
				for(auto it=lst.begin();it!=lst.end();)
				{
					int idx2=*it;
					if(mn[idx2].ex)
					{
						it=lst.erase(it);
						continue;
					}
					int dx2=mn[idx].x-mn[idx2].x;
					int dy2=mn[idx].y-mn[idx2].y;
					int dist_sq=dx2*dx2+dy2*dy2;
					if(dist_sq<=mn[idx].r*mn[idx].r)
					{
						mn[idx2].ex=true;
						total++;
						q.push(idx2);
						it=lst.erase(it);
					}else
						it++;
				}
				
				if(lst.empty())
					gmp.erase(key);
			}
		}
	}
	cout<<total<<"\n";
	return 0;
}
```

---


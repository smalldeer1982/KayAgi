# [HAOI2016] 食物链

## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/13153.png) 

如图所示为某生态系统的食物网示意图，据图回答第 1 小题  
现在给你 $n$ 个物种和 $m$ 条能量流动关系，求其中的食物链条数。物种的名称为从 $1$ 到 $n$ 编号 $M$ 条能量流动关系形如 $a_1,b_1,a_2,b_2,a_3,b_3,\ldots,a_{m-1},b_{m-1},a_m,b_m$。其中 $a_i$ 和 $b_i$ 表示能量从物种 $a_i$ 流向物种 $b_i$，注意单独的一种孤立生物不算一条食物链。


## 说明/提示

数据保证输入数据符合生物学特点，且不会有重复的能量流动关系出现，题目保证答案不会爆 `int`。

对于 $100 \%$ 的数据，$1 \leq N \leq 100000$，$0 \leq m \leq 200000$。

## 样例 #1

### 输入

```
10 16
1 2
1 4
1 10
2 3
2 5
4 3
4 5
4 8
6 5
7 6
7 9
8 5
9 8
10 6
10 7
10 9```

### 输出

```
9```

# 题解

## 作者：_蒟蒻__ (赞：106)

好多大佬用记搜， emm， 其实……

直接裸toposort加个f统计方案就好啦

考虑到拓扑排序的先后次序问题, 在更新入度的时候顺便将方案数进行累加

最后答案就是 $\sum$ 无出边的点

注意单个点不算方案

生命苦短， 直接上代码


```cpp
#include <iostream>
#include <vector>
#include <queue>
#define ORZ main
using namespace std;
const int N=1008611;
int n, m, f[N], rd[N];
vector <int> e[N];

inline int JI_DE_DIAN_GE_ZAN()
{
	queue <int> q;
	int ans=0;
	for(int i=1; i<=n; i++)
	if(!rd[i] && e[i].size()) // 单个点不算方案
		q.push(i), f[i]=1; 
	
	while(!q.empty())
	{
		int x=q.front(); q.pop();
		if(!e[x].size()) ans+=f[x];
		for(auto t : e[x])
		{
			f[t]+=f[x], rd[t]--; // f来统计方案
			if(!rd[t]) q.push(t);
		}
	}
	return ans;
} // 裸的

int ORZ ()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1, x, y; i<=m; i++)
	{
		cin>>x>>y; rd[y]++;
		e[x].push_back(y);
	}
	cout<<JI_DE_DIAN_GE_ZAN();
	return ~~ (0 ^ 0);
}
```


---

## 作者：远航之曲 (赞：82)

记忆化真是神奇的东西，加了两句瞬间T->A


题目大意：给出一个有向图，求入度为0的点到出度为0的点一共有多少条路

从入读为零的点进行记忆化搜索，搜到出度为零的点返回1

所有返回值加起来就是答案。

“注意单独的一种孤立生物不算一条食物链。”出题人都这么好心的说了，然而第一次交的时候还是忘了= =


#include <cstdio>

using namespace std；

```cpp
struct node
{
    int u,w,next;
}e[200010];
int st[100010],out[100010],ind[100010],f[100010],n,m,a,b,ans,tot,s,end;
void add(int x,int y)
{
    e[++tot].u=x;
    e[tot].w=y;
    e[tot].next=st[x];
    st[x]=tot;
}
int dfs(int x)
{
    if (f[x]) return f[x];//////记忆化
    int ans=0;
    if (out[x]==0) return 1;
    for (int i=st[x];i;i=e[i].next)
    {
        ans+=dfs(e[i].w);
    }
    f[x]=ans;/////记忆化（就两句2333
    return ans;
}
main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++)
        scanf("%d%d",&a,&b),add(a,b),out[a]++,ind[b]++;
    for (int i=1;i<=n;i++)
        if (ind[i]==0 && out[i]!=0)////注意单独点的情况
            ans+=dfs(i);
    printf("%d",ans);
}
```

---

## 作者：zcysky (赞：56)

省选竟然还有这种naive的题……

还是看入度出度的关系决定了一条食物链的起始，对结果记忆化搜索，并且注意一个生物不算食物链（即单独的非连通点无效）

```cpp
#include<bits/stdc++.h>
#define N 400010
typedef long long ll;
using namespace std;
int head[4*N],tot=0,in[N],out[N],n,m;
struct Edge{int u,v,next;}G[N<<1];
inline void addedge(int u,int v){
    G[++tot].u=u;G[tot].v=v;G[tot].next=head[u];head[u]=tot;
}
ll dp[N];
ll dfs(int u){
    if(dp[u])return dp[u];ll ans=0;
    if(!out[u]&&in[u])++ans;
    for(int i=head[u];i;i=G[i].next){
        int v=G[i].v;ans+=dfs(v);
    }
    dp[u]=ans;return ans;
}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    n=read();m=read();
    for(int i=1,u,v;i<=m;i++){
        u=read();v=read();out[u]++;in[v]++;
        addedge(u,v);
    }
    ll ans=0;
    for(int i=1;i<=n;i++)if(!in[i])ans+=dfs(i);
    cout<<ans<<endl;
}
```

---

## 作者：Dispwnl (赞：14)

简单的记忆化搜索。。。

记录一个点的入度和出度

然后枚举每个点

如果这个点入度为0（生产者）##并出度不为0（注意这一点，因为单个生物不算一条，没加只能得20分）

就进行dfs

f[x]+=f[c[i].y];

如果这个点出度为0（最高级）

f[x]=1
然后将结果累加就行了

c++
```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
#define ini inline int
#define inv inline void
#define is isdigit(ch)
using namespace std;
struct p{
    int x,y;
}c[200001];
int n,m,num,ans;
int h[100001],ru[100001],cu[100001];
int f[100001];
ini read()
{
    int x=0;
    char ch=getchar();
    while(!is)
    ch=getchar();
    while(is)
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x;
}
inv add(int x,int y)
{
    c[++num].x=h[x];
    c[num].y=y;
    h[x]=num;
}
inv dfs(int x,int y)
{
    if(f[x]) return;
    if(!cu[x])
    {
        f[x]=1;
        return;
    }
    for(int i=h[x];i;i=c[i].x)
      if(c[i].y!=y)
      {
          dfs(c[i].y,x);
          f[x]+=f[c[i].y];
      }
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
      {
          int x=read(),y=read();
          ru[y]++;
          cu[x]++;
          add(x,y);
      }
    for(int i=1;i<=n;i++)
      if(!ru[i]&&cu[i])
      {
          dfs(i,i);
          ans+=f[i];
      }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Silent_E (赞：11)

**选拔考试考了这道比较水的题QAQ**

考试刚开考时我瞟了一眼题面，咦？这不是**拓扑排序**吗，只不过数据范围有点大啊（考试时是m<=1000000的数据），留着，可做。

后来花了2h打完其他的题，开始看这道题。。**woc!** 爆搜过不了啊。

然后。。。**记忆化搜索！** **get**!

```cpp
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
inline int read(){//快读 
	int f=1,x=0;char ch;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
	do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	return f*x;
}
struct sakura{int to,next;}sak[200005];int cnt,head[200005];//数组实现链表 
int ans[100005],anss,n,m;
bool deep[100005];//用来标记不是根节点 
inline void add(int x,int y){cnt++;sak[cnt].to=y;sak[cnt].next=head[x];head[x]=cnt;}
inline int dfs(int x){//加法原理 
	if(head[x]==0&&deep[x]!=0)return 1; //head[x]的妙用；deep[x]判断是否孤立 
	if(ans[x])return ans[x];
	for(int i=head[x];i;i=sak[i].next){//遍历 
		ans[x]=(ans[x]+dfs(sak[i].to));
	}
	return ans[x];//记忆化搜索速度真快QAQ 
}
int main(){
	//freopen("food.in","r",stdin);
	//freopen("food.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=m;++i){
		int a=read(),b=read();
		add(a,b);deep[b]=1;//标记不是根节点的点 
	}
	for(int i=1;i<=n;++i){//遍历森林找每个根节点 
		if(!deep[i])
			anss=(anss+dfs(i));//答案++ 
	}
	printf("%d",anss);//后来听别人说正解是DP,我：？？？ 
	//fclose(stdin);
	//fclose(stdout); 
	return 0;
}
```

---

## 作者：zhyh (赞：8)

主要是拓扑排序，排序后累加即可

拓扑排序：
```
void toposort(int k)
{
	vis[k] = 1;
	for(int i=fst[k]; i; i = pre[i]) if(!vis[e[i].v]) toposort(e[i].v);
	topo[++tot] = k;
	return;
}
```
```
for(int i=1; i<=N; i++) if(!vis[i]) toposort(i);
```
$vis$=1表示走过；$topo[]$即为拓扑序。

然后正序枚举$topo[i]$，累加其入度的值。代码：
```cpp
#include <cstdio>
#define rep(x,y,z) for(int x = y; x <= z; x++)
#define per(x,y,z) for(int x = y; x >= z; x--)
#define max(x,y) (x>y?x:y)
#define min(x,y) (x<y?x:y)
#define inf 100000000
#define maxn 100005
#define maxm 200005
using namespace std;

struct edge {
	int u, v;
} e[maxm];
	int N, M, tot, fst[maxn], pre[maxm], topo[maxn], f[maxn], ans;
	bool vis[maxn], ok[maxn];

void toposort(int k)
{
	vis[k] = 1;
	for(int i=fst[k]; i; i = pre[i]) if(!vis[e[i].v]) toposort(e[i].v);
	topo[++tot] = k;
	return;
}
int main()
{
	scanf("%d%d", &N, &M);
	rep(i,1,M) {
		scanf("%d%d", &e[i].v, &e[i].u);
		pre[i] = fst[e[i].u], fst[e[i].u] = i;
	}
	rep(i,1,N) if(!vis[i]) toposort(i);
	rep(k,1,N) { int i = topo[k];
		if(!fst[i]) f[i] = 1, ok[i] = 1;
		else for(int j=fst[i]; j; j=pre[j]) f[i] += f[e[j].v], ok[e[j].v] = 1;
	}
	rep(i,1,N) if(!ok[i]) ans += f[i];
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：zhangyuxing (赞：4)

wow竟然是2016省选题

Amazing 这么水？？？
___
一、思路

1. 第一眼感觉就是dp，后来觉得记忆化搜索简单一点，就改成写记忆化搜索了。

2. 为了判起止，统计一下出入度。

3. 这里建图用的前向星。
___
二、代码（附注释）
```cpp
#include<cstdio>
using namespace std;
int n,m,f[100005],in[100005],out[100005];
int head[500005],cnt;
struct Edge{int u,v,next;}e[200005];
void add(int x,int y){e[++cnt].u=x;e[cnt].v=y;e[cnt].next=head[x];head[x]=cnt;}
int dfs(int x)
{
    	if(f[x])return f[x];
		int ans=0,i;
    	if(!out[x]&&in[x])++ans;
    	for(i=head[x];i;i=e[i].next)ans+=dfs(e[i].v);
    	return f[x]=ans;
}
int main()
{
		int ans=0,x,y,i;
		scanf("%d%d",&n,&m);
		for(i=1;i<=m;++i)
		{
			scanf("%d%d",&x,&y);
			add(x,y);++in[y];++out[x];
		}
		for(i=1;i<=n;++i)if(!in[i])ans+=dfs(i);
    	printf("%d",ans);
		return 0;
}
```


---

## 作者：Dog_Two (赞：4)

和P4017挺像的~~其实去掉一个限制条件就是重题了~~

其他的题解都或多或少有图的思想，记录了节点的入度和出度

但其实我们并不需要记录节点的入度，用一个bool数组判断**入度是否为0**即可

- 用一个vector记录所有生物的食物

- 把所有**“被吃”**的生物标记为**“不是顶点”**

- 题目要求单一生物不能成为食物链，那么在搜索的时候只需要判定不是顶点&&食物数不为空就可以了

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,m;
int dp[maxn];
bool no_Hst[maxn];
//如果不是食物链顶端，则为true 
vector<int>Eat[maxn];
int ans;
int dfs(int now){
    if(!Eat[now].size()) return 1;
    if(dp[now]) return dp[now];
    int res=0;
    for(int i=0;i<Eat[now].size();i++) res+=dfs(Eat[now][i]);
    return dp[now]=res;
}
int main(){
    cin>>n>>m;
    int a,b;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&a,&b);
        Eat[b].push_back(a);
        no_Hst[a]=true;
    }
    for(int i=1;i<=n;i++) if(!no_Hst[i]&&Eat[i].size()) 
    ans+=dfs(i);    /*只有一个生物，不能算作食物链↑*/
    cout<<ans;
    return 0;
}```

---

## 作者：king_xbz (赞：3)

简单的拓扑序+记忆化搜索

有几个点需要注意：

1.单独的生物不算食物链

2.不要用邻接矩阵存图！！！

这里采用链式前向星存图
```cpp
struct node
{
	int to;
	int next;
}
e[p];
int head[p];
int cnt;
inline void adds(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
```
保存出入度
```cpp
for(fint i=1;i<=m;i++)
	{
		a=read();
		b=read();
		adds(a,b);
		in[b]++;
		ou[a]++;
	} 
 ```
 搜索每一个入度为0点且出度不为0的点
 ```cpp
 for(fint i=1;i<=n;i++)
	{
		if(!in[i]&&ou[i])如果不特判出度，只有20分
		t+=mfs(i);
	}
```
记忆化搜索代码
```cpp
int mfs(int x)
{
	if(f[x])
	return f[x];
    边界
	if(!ou[x])
	return 1;
   搜错
	int tot=0;
	for(fint i=head[x];i;i=e[i].next)
	{
		tot+=mfs(e[i].to);
      搜每一条边
	}
	f[x]=tot;
	return f[x];
   得到每个点下的食物链
}
 

---

## 作者：EarthGiao (赞：3)

## 【思路】
记忆化搜索    
一开始我想DP然后失败了    
不过貌似记忆化搜索很好想   
所以我就来尝试了一哈    
没有问题   

### 【题目大意】
有向图，找完整的链的数目   
(完整的链的意思是：    
链的头不能有入边，链的尾不能有出边)    

### 【题目分析】 
上面已经说过    
一条完整的链就是链的头不能有入边   
链的尾不能有出边   
因为如果还有的话那就是还有可以被吃或者吃的   
那这条食物链就没有结束   
就不能算是一条食物链   
（学过生物食物链那一部分知识的的应该都知道）    
所以搜索的时候就有了目标     
从头开始搜，因为头要满足没有入边   
所以在建图的时候记录入度和出度   
然后如果这个点没有入度   
那就是可以搜的   
但是还是有一个条件的    
他必须要有出度才能搜     
不然就成了一个没有入度也没有出度的点    
也就是一种孤立的生物   
所以必须满足没有入度并且有出度    
这样同时也可以避免把孤立的生物算进来   
这样搜索肯定是要超时的    
所以就要考虑优化    

### 【优化】 
剪枝？不现实    
没一条边都有可能参与到食物链的构建中去    
所以剪枝的话没有剪枝的条件    
那就记忆化搜索吧    
反正每个点之后会有多少条食物链都是一定的     
那就开一个数组记录每个点之后有多少条食物链    
这样如果数组里面有值   
那就直接加上就好了   
否则就搜一下然后记录起来     
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int Max = 200005;
struct node
{
	int y,ne;
}a[Max];
int head[Max >> 1],sum = 0;
void add(int x,int y)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	head[x] = sum;
}
int ru[Max >> 1],chu[Max >> 1];
int dp[Max >> 1];
int ans = 0;

int dfs(int x)
{
	if(dp[x] != 0)return dp[x];
	int ans = 0;
	if(ru[x] != 0 && chu[x] == 0)
		ans ++;
	for(register int i = head[x];i != 0;i = a[i].ne)
	{
		ans += dfs(a[i].y);
	}
	dp[x] = ans;
	return ans;
}

signed main()
{
	int n,m;
	cin >> n >> m;
	int a,b;
	for(register int i = 1;i <= m;++ i)
	{
		cin >> a >> b;
		add(a,b);
		chu[a] ++;
		ru[b] ++;
	}
	int tot = 0;
	for(register int i = 1;i <= n;++ i)
		if(ru[i] == 0 && chu[i] != 0)
			tot += dfs(i);
	cout << tot << endl;
	return 0; 
}
```

---

## 作者：charliegong (赞：3)

[原题传送门](https://www.luogu.org/problemnew/show/P3183)     
一道拓扑排序的题(^_^)     
按照拓扑排序完了的顺序DP即可。      
dp没大家想的那莫难，只是一个标数法~~       
下面附上~~香喷喷~~的代码    
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<stdio.h>
#include<queue>
#define AC 888888//祝大家AC并发财~~
using namespace std;
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f=-1;ch=getchar();}
    while(ch>='0' && ch<='9') {x=10*x+ch-'0';ch=getchar();}
    return x*f;
}//然而并没有什么卵用的快读
struct Node
{
    int v,u;
}e[AC];
int tot=0,h[AC];
inline void addEdge(int u,int v){
	tot++;
    e[tot].v=v;e[tot].u=h[u];h[u]=tot;
}//建图
int ind[AC],oud[AC],topo[AC];//入度，出度和拓扑序
int n,m;
inline void toposort(){//拓扑排序（按入度出度排序）
	queue<int>q;
    for(int i=1;i<=n;i++){//初始化，很重要！！！！
    	if(!ind[i]&&oud[i]){
            q.push(i);topo[i]=1;
        }
	}
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=h[u];i;i=e[i].u){
        	int v=e[i].v;
            topo[v]+=topo[u];
            ind[v]--;
            if(ind[v]==0) q.push(v);
        }
    }
    return;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++){
    	int u=read(),v=read();
        addEdge(u,v);
        ind[v]++;
        oud[u]++;
    }//输入+建图和算入读出度
    toposort();
    int sum=0;
    for(int i=1;i<=n;i++){
    	if(oud[i]==0) {
    		sum+=topo[i];
		}
	}//小奥的标数法
    cout<<sum<<endl;
    return 0;
}

```
第一次写题解，望多多指教

---

## 作者：chdy (赞：3)

	
   这道题其实不用记忆化搜索啊什么的，算一下路径数就好了，其实认真思考，一直死磕.
    
   就会发现到达每个点的方案数就是该到达该点的所有点的方案数之和，知道了这个就简单了很多~
   
   于是bfs沿着topsort扫一遍答案便出来了，就是最后所有加入对列的出度为0的点，注意单个点不是链，加一个小判断即可。
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<ctime>
#include<iomanip>
#include<algorithm>
#include<vector>
#include<map>
#include<queue>
#include<stack>
#include<cmath>

using namespace std;

inline int read()
{
	
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9')
	{if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')
	{x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

const int maxn=200002;

int ru[100002];

int lin[maxn],ver[maxn],nex[maxn],len=0;

int q[maxn<<1],h=0,t=0,vis[maxn],p[maxn];

void add(int x,int y)

{
	
    ver[++len]=y;
	nex[len]=lin[x];
	lin[x]=len;
}

int n,m,ans=0,d[maxn];

void bfs()
{
	
    while(h<t)
	{
		int tn=q[++h];
		if(lin[tn]==0&&p[tn]==0)ans+=d[tn];
		for(int i=lin[tn];i;i=nex[i])
		{
			ru[ver[i]]--;d[ver[i]]+=d[tn];
			if(ru[ver[i]]==0&&vis[ver[i]]==0)
			{
				vis[ver[i]]=1;
				q[++t]=ver[i];
			}
		}
	}
}

int main()
{
	
    //freopen("1.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		int x,y;
		x=read();y=read();
		add(x,y);ru[y]++;
	}
	for(int i=1;i<=n;i++)
		if(ru[i]==0)
			q[++t]=i,vis[i]++,d[i]=1,p[i]++;
	bfs();
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：pantw (赞：2)

比较简单的拓扑序DP题。

还有这真的是蛤OI2016的题嘛emmm

然后因为我们只需要按照拓扑序DP，所以我们甚至连拓扑序都不用记录下来，直接在dfs的时候转移即可。


$ans[j] = 0, in[j] = 0 \text{且}out[j]=0 $


$ans[j] = 1, in[j] = 0 \text{且}out[j]\ne 0 $


$ans[j] = \sum \limits_{(i,j)\in E} ans[i] ,\space in[j]\ne 0$


其中ans[i]是i点的DP值，E是边集，in[i]和out[i]分别是i点的入度和出度。


```cpp
#include <cstdio>
#define maxn 100010
#define maxm 200020
int head[maxn], to[maxm], next[maxm], ec; // 邻接表
int in[maxn], out[maxn]; // 入度出度
int ans[maxn], total; // dp数组
void addedge(int u, int v) { // 加边
    ec++;
    next[ec] = head[u];
    to[ec] = v;
    head[u] = ec;
    in[v]++;
    out[u]++;
}
void dfs(int cur) { // dfs
    for(int e = head[cur]; e; e = next[e]) {
        ans[to[e]] += ans[cur]; // 转移
        if(!--in[to[e]]) {
            dfs(to[e]);
        }
    }
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; ++i) { // 读入
        int u, v;
        scanf("%d%d", &u, &v);
        addedge(u, v);
    }
    for(int i = 1; i <= n; ++i) // DP
        if(!in[i] && out[i] && !ans[i]) {
            ans[i] = 1;
            dfs(i);
        }
    for(int i = 1; i <= n; ++i) if(!out[i]) total += ans[i]; // 累计total
    printf("%d\n", total);
    return 0;
}
```

---

## 作者：cym_233 (赞：2)

## 总的来说

很明显是个拓扑排序，水的一批，不明白为什么会出现在省选题里。

## 解题思路

入度为零的点方案数为1，其余的点方案数等于指向它的点的方案数之和，最后统计出度为0的点的方案数，累加即可。没什么思维难度，只不过有个坑点，就是只有一个点不算一条食物链，那么在一开始入度为零的点进入队列时要判断一下，不让那些没有出度的点进入队列。其余没什么难的，就是一个规规矩矩的拓扑排序。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,p,q,num,tail,head,t[100001],ans,f1,f2;
struct k1{
    int ru_du;
    int chu_du;
    int first_;
    int ans;
}node[100001];
struct k2{
    int from;
    int to;
    int next_;
}edge[200001];
void edge_add(int x,int y)
{
    num++;
    edge[num].from=x;
    edge[num].to=y;
    edge[num].next_=node[x].first_;
    node[x].first_=num;
    node[x].chu_du++;
    node[y].ru_du++;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&f1,&f2);
        edge_add(f1,f2);
    }
    head=0;
    tail=0;
    for(int i=1;i<=n;i++)
    {
        if((node[i].ru_du==0)&&(node[i].chu_du>0))
        {
            tail++;
            node[i].ans=1;
            t[tail]=i;
        }
    }
    while(head<tail)
    {
        head++;
        p=t[head];
        for(int j=node[p].first_;j!=0;j=edge[j].next_)
        {
            q=edge[j].to;
            node[q].ans+=node[p].ans;
            node[q].ru_du--;
            if(node[q].ru_du==0)
            {
                tail++;
                t[tail]=q;
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(node[i].chu_du==0)
            ans+=node[i].ans;
    }
    printf("%d",ans);
    return 0;
}
```

## 如有谬误 敬请斧正

### 打一波广告 QQ：2845600375 

---

## 作者：BCZSX (赞：1)

~~好像很少人写拓扑排序的题解，那我来发一篇吧……~~

这道题跟P4017一模一样，只是数据范围不一样……（~~双倍经验）~~

### 思路：

用拓扑排序跑一遍就可以啦，只要遇到出度为0的点就++ ans，就是这么简单的思路……详细讲解就看代码吧！
```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

#define MAXN 101000
#define MAXM 201000

vector<int> vec[MAXN];//vector存储图
queue<int> que;//拓扑排序的队列
int n,m,u,v,ans;//ans记录答案
int in[MAXN],out[MAXN],f[MAXN];
//in数组记录入度
//out数组记录出度
//f数组记录到i这个点有多少条食物链

void topo_sort()//拓扑排序
{
    for (int i = 1 ; i <= n ; ++ i)
    {
        if (! in[i]) que.push(i),f[i] = 1;
    }
    while (! que.empty())
    {
        int x = que.front();
        que.pop();
        for (int i = 0 ; i < vec[x].size() ; ++ i)
        {
            -- in[vec[x][i]];
            f[vec[x][i]] += f[x];
            if (! in[vec[x][i]] && ! out[vec[x][i]])//入度和出度都为0，++ ans
            {
                ans += f[vec[x][i]];
            }
            else if (! in[vec[x][i]])//入度为0，加入到队列里
            {
                que.push(vec[x][i]);
            }
        }
    }
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1 ; i <= m ; ++ i)
    {
        scanf("%d%d", &u, &v);
        vec[u].push_back(v);//存边
        ++ in[v];++ out[u];
    }
    topo_sort();
    printf("%d", ans);//输出答案
    return 0;
}
```

---

## 作者：hovny (赞：1)

$\mathtt{Update\ 2019.11.08}$



## 解题思路

直接在有向图上 $Dp$ 即可

要注意的是**单独一个点不算一条链**

存图后把入度为 $0$ 且出度不为 $0$（即非单独）的点入队，类似拓扑地跑一个 $Dp$

每次对一个出点 $to$ 更新之的答案 `f[to]+=f[cur]`

即利用加法原理，到 $to$ 点的方案为向它连边点的方案和

当该出点 $to$ 入度为 $0$ 时，分情况视之

倘若该出点**出度为0**时，累加答案 `ans+=f[to]`

否则就入队用来更新其他点

## Code

```c++
#include<bits/stdc++.h>
#define rgt register
#define rint rgt int
#define N 100003
using namespace std;
struct node{
	int to,nxt;
}b[N<<1];
int n,t,T,head[N];
int f[N],d[N],ans;
inline int read() {
	rint s=0;
	rgt char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return s;
}
inline void add(int x,int y) {
	b[++t].to=y,b[t].nxt=head[x],head[x]=t;
}
inline void solve() {
	rint i,cur,to;queue<int>p;
	for(i=1;i<=n;i++)//初始化入度为0的点（不包括单独的点）
		if(!d[i]&&head[i])//分别判断入度为0和是否是单独的点
			f[i]=1,	p.push(i);//初始化路径数，否则全都是0
	while(!p.empty()) {
		cur=p.front(),p.pop();
		for(i=head[cur];i;i=b[i].nxt) {
			to=b[i].to,d[to]--,f[to]+=f[cur];
			if(d[to]==0) {
				if(!head[to]) ans+=f[to];
				else p.push(to);//只有入度为0且出度不为0时才入队
			}
		}
	}
}
int main()
{
	rint x,y;n=read(),T=read();
	while(T--) x=read(),add(x,read()),d[y]++;//入度
    solve(),printf("%d",ans);
	return 0;
}
```



---

## 作者：Sshenyyyu (赞：1)

# 食物链
#### 题目描述

如图所示为某生态系统的食物网示意图，据图回答第1小题现在给你n个物种和m条能量流动关系，求其中的食物链条数。物种的名称为从1到n编号M条能量流动关系形如a1 b1a2 b2a3 b3......am-1 bm-1am bm其中ai bi表示能量从物种ai流向物种bi,注意单独的一种孤立生物不算一条食物链
输入输出格式

输入格式：
第一行两个整数n和m,接下来m行每行两个整数ai bi描述m条能量流动关系。（数据保证输入数据符号生物学特点，且不会有重复的能量流动关系出现）1<=N<=100000 0<=m<=200000题目保证答案不会爆 int。

输出格式：
一个整数即食物网中的食物链条数
分析：这道题明显是一道dfs题目，可以用领接表去存储题目所给的边，每次向下去dfs，当然是要用记忆化的，哈哈。
##### 蒟蒻代码
```
void insert(int u,int v)
{
	++cnt;
	Next[cnt]=Head[u];
	Head[u]=cnt;
	To[cnt]=v;	
}
```
加边不多说。。。
```
int dfs_1(int x)
{
	if(f[x]!=-1)
		return f[x];
	if(out[x]==0)	
		return f[x]=1;
	int tmp=0;
	for(int i=Head[x]; i; i=Next[i])
		tmp+=dfs_1(To[i]);
	return f[x]=tmp;	
}
```
DFS内部，记忆化，标准写法。。。
```
int main()
{
	memset(f,-1,sizeof(f));//初始化
	cin>>n>>m;
	for(int i=1; i<=m; i++)
		cin>>a>>b,insert(a,b),in[b]++,out[a]++;//记录出入边
	for(int i=1; i<=n; i++)
		if(in[i]==0&&out[i]!=0)
			Ans+=dfs_1(i);//寻找食物链顶端，有满足条件的就进行DFS
	cout<<Ans<<endl;	
	return 0;
}
```
主函数，里面可以用两个数组来记录出边和入边的个数，这样DFS内部就可以判断食物链有没有到底，还是挺方便的。。。


---

## 作者：硫代硫酸钠 (赞：0)

首先有一个性质，若从一个入度为0的点到达A有a种方法，则到达所有A的后继也至少有A种方法。

所以对于每个点建好图然后拓扑排一下，（显然这一定是DAG），然后统计一下所有出度为0的点，有多少种到达的办法，加起来就是答案了。

附上蒟蒻的代码（WA好几次才过的）





      
       
        

  
  

```cpp
#include<bits/stdc++.h>
#define size 500100
using namespace std;
int to[size],nxt[size],head[size],son[size],rd[size],cd[size],q[size];
int n,m,num;
bool vis[size];
void addedge(int x,int y)
{
  num++;to[num]=y;nxt[num]=head[x];head[x]=num;
  rd[y]++;cd[x]++;
}
void init()
{
  int x=200000;
  for (int i=1;i<=n;i++)
    if (rd[i]==0&&vis[i]) addedge(x,i);
  son[x]=1;
  int f=0,r=1;
  q[r]=x;
  while (f!=r)
  {
      f++;
      int t=q[f];
      if (f==200000) f=0;
      for (int p=head[t];p;p=nxt[p])
      {
        son[to[p]]+=son[t];
        rd[to[p]]--;
        if (!rd[to[p]]) q[++r]=to[p];
        if (r==200000) r=0;
      }
  }  
}
long long calc()
{
  long long ans=0;
  for (int i=1;i<=n;i++)
      if (!cd[i]&&vis[i]) ans+=son[i];
  return ans;
}
int main()
{
  scanf("%d%d",&n,&m);
  for (int i=1;i<=m;i++)
  {
      int x,y;
      scanf("%d%d",&x,&y);
      vis[x]=1;vis[y]=1;
      addedge(y,x);
  }
  init();
  cout<<calc() <<endl;
  return 0;
}
```

---

## 作者：Crazy01 (赞：0)

都说是一个记忆化搜索题，为什么我觉得是一个拓扑序的题。。。虽然写起来有点像记忆化搜索。。。

将所有的边都反向存，显然这是一个dag，然后记一个sum[i]表示从i开始可以构成几条食物链。

然后将入度为0的点加入队列，每次从队列中取出一个点x，将它所指向的所有点的sum加上它自己的sum[x]，因为它指向的所有的点，在原来的食物网中是指向它的点，从它开始走可以走出sum[x]条食物链，所以加上去就好了。

然后删去点x，因为入度为0的点不会再被更新，这里只需要将它指向的点的入度-1就可以了，然后判断点x所指向的点在删去x后是否又出现新的入度为0的点，有就加入队列。

重复以上步骤，直到队列为空，即所有的点都更新完了。

最后答案就是所有出度为0的点的sum，在原食物网中它们是食物链的起点。

注意：因为单个的点不算是一条食物链，所以将入度为0的点加入队列的时候，那些入度和出度均为0的点就不要加入队列，相应的，它们的sum等于0；






```cpp
#include<queue>
#include<math.h>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<iostream>
#include<algorithm>
#define inf 1<<30
#define ll long long
#define c233 cout<<"233"<<endl
#define mem(s) memset(s,0,sizeof(s))
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
const int N=100050;
using namespace std;
bool v[N];
int du[N],chu[N],nxt[N*2],to[N*2],head[N],sum[N];
int maxe,n,m,ans;
void fre(){
  freopen("in","r",stdin);
  freopen("out","w",stdout);
}
int gi(){
  int x=0,res=1;char ch=getchar();
  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}
  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
  return x*res;
}
void build(int x,int y){
  nxt[++maxe]=head[x];to[maxe]=y;head[x]=maxe;
```
}//连边




```cpp
void init(){
  n=gi();m=gi();
  for(int i=1;i<=m;i++){
    int a=gi(),b=gi();
    build(b,a);//反向连边
    v[b]=1;//标记这个点有出度，不能用来统计答案
    du[a]++;//统计入度
    chu[b]++;//统计出度
  }
}
void work(){
  queue<int> q;
  while(!q.empty())q.pop();
  for(int i=1;i<=n;i++)
    if(du[i]==0&&chu[i]>0)sum[i]=1,q.push(i);//孤立的点不能加入队列
  while(!q.empty()){
    int x=q.front();q.pop();
    for(int i=head[x];i;i=nxt[i]){
      int u=to[i];
      sum[u]+=sum[x];
      du[u]--;//删点
      if(du[u]==0)q.push(u);//如果有新的入度为0的点，加入队列
    }
  }
  for(int i=1;i<=n;i++)
    if(!v[i])ans+=sum[i];//反向连边之后，没有出度的点才是一整条食物链的起点
  printf("%d\n",ans);
}
int main(){
  //fre();
  init();
  work();
  return 0;
}

```

---

## 作者：雷电音 (赞：0)

好像没有P的题解……虽然方法和楼下一样，但是我还是写写……

一看这题肯定是深搜，根据生物学的原理，入度为零的是生产者，才能作为开头，出度为零的是终极消费者，才能作为结尾，这样很快就能写出来

因为这题点多边少，那么就用邻接表

可是这样是过不了的→\_→

因为重复搜了很多遍！一个点会被搜好几遍！会TLE！所以就加上记忆化，完成。

以下贴代码

```cpp
type bian=record
       next,point:longint;
     end;
var a,b,c,d,x,y,gb,ans,n,m:longint;
    edge:array[1..300000] of bian;
    head:array[1..200000] of bian;
    cd,rd,jy:array[1..200000] of longint;//分别是出度，入度，记忆（化）
function dfs(o:longint):longint;
var v,w:bian;
begin
 if cd[o]=0 then begin inc(ans); exit(1); end;
 if jy[o]<>0 then begin inc(ans,jy[o]); exit(jy[o]); end;
 v:=head[o];
 while v.point<>0 do
   begin
    inc(jy[o],dfs(v.point));
    v:=edge[v.next];
   end;
 exit(jy[o]);
end;
procedure addbian(v,w:longint);
begin
 edge[gb]:=head[v];
 head[v].next:=gb;
 head[v].point:=w;
 inc(gb);
 inc(cd[v]); inc(rd[w]);
end;
begin
 fillchar(edge,sizeof(edge),0);
 fillchar(head,sizeof(head),0);
 fillchar(cd,sizeof(cd),0);
 fillchar(rd,sizeof(rd),0);
 fillchar(jy,sizeof(jy),0);
 readln(n,m);
 gb:=1; ans:=0;
 for a:=1 to m do
   begin
    readln(x,y);
    addbian(x,y);
   end;
 for a:=1 to n do
   if (rd[a]=0) and (cd[a]<>0) then//题目说了单点不能作为食物链！第一次交没加这个只有20分
     dfs(a);
 writeln(ans);
end.

```

---

## 作者：PVYCVJ (赞：0)

这题我不推荐用dfs，如果题目的数据规模大一些的话会爆栈。虽然就这题本身而言dfs+记忆化就可以ac（笑）

嘛，反正这题的bfs也不算难写....直接上代码。这个算法好像有个名字叫AO什么来着？

```pascal
program p3183;

var
  nn,mm:longint;
  edge,next:array[1..200005] of longint; //邻接表
  map,du,ans,queue:array[1..100005] of longint; //du = 入度
  //无环图保证每个点最多入队一次，队列不必开太大
  hen,tai:longint; //队列头尾指针。。
  answer:longint;

  i,j:longint;

begin
  readln(nn,mm);
  fillchar(map,sizeof(map),0);
  du:=map;
  ans:=map;
  //以上两句是把du和ans清零，貌似大部分人都是再用两次fillchar
  for i:=1 to mm do begin
    readln(j,edge[i]);
    next[i]:=map[j];
    map[j]:=i;
    inc(du[edge[i]]);
  end;
  hen:=0; tai:=0;
  for i:=1 to nn do
    if (du[i]=0) and (map[i]<>0) then begin //寻找入度0且出度非0（不孤立）的点
      inc(tai);
      queue[tai]:=i;
      ans[i]:=1;
    end;
  while hen<tai do begin
    inc(hen);
    i:=map[queue[hen]];
    while i<>0 do begin
      inc(ans[edge[i]],ans[queue[hen]]);
      dec(du[edge[i]]);
      if du[edge[i]]=0 then begin
        inc(tai);
        queue[tai]:=edge[i];
      end;
      i:=next[i];
    end;
  end;
  answer:=0;
  for i:=1 to nn do
    if map[i]=0 then inc(answer,ans[i]);
    //寻找出度0的点。孤立点未经遍历，ans为0，不用排除
  writeln(answer); readln;
end.
```
附dfs+记忆化的pascal代码，稍微参考了一下楼下的。dfs的思路似乎比bfs简单一些。

```pascal
program p3183;

var
  nn,mm:longint;
  edge,next:array[1..200005] of longint;
  map,du,ans:array[1..100005] of longint;
  answer:longint;

  i,j:longint;

function dfs(x:longint):longint;
var i:longint;
begin
  if ans[x]>0 then exit(ans[x]);
  if map[x]=0 then exit(1);
  i:=map[x];
  while i<>0 do begin
    inc(ans[x],dfs(edge[i]));
    i:=next[i];
  end;
  exit(ans[x]);
end;

begin
  readln(nn,mm);
  fillchar(map,sizeof(map),0);
  du:=map;
  ans:=map;
  for i:=1 to mm do begin
    readln(j,edge[i]);
    next[i]:=map[j];
    map[j]:=i;
    inc(du[edge[i]]);
  end;
  answer:=0;
  for i:=1 to nn do
    if (du[i]=0) and (map[i]<>0) then inc(answer,dfs(i));
  writeln(answer); readln;
end.
```
亲测n=1000000（比题目多一个0）且食物网为单链无支链时dfs爆栈（废话），不过这么大的数据规模bfs也要花零点几秒


---


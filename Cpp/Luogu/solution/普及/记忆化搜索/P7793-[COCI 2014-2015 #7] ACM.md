# [COCI 2014/2015 #7] ACM

## 题目背景

Zagreb 大学的团队的成员 Stjepan、Ivan 和 Gustav 正在摩洛哥参加 ACM 国际大学生程序设计竞赛的世界决赛。他们的技术指导 Goran 想出了一个无敌的策略，用于解决决赛中的题目。

## 题目描述

在一开始，每个团队成员迅速估计 $n$ 道题目中每题的难度。这些难度用 $1$ 到 $5$ 的数字描述，数字越大，难度也就越大。

在这之后，他们之间将分配任务。为了简单起见，任务阵列将被分成三部分，以便每个团队成员得到一个**非空**的连续任务序列来思考。这种分配是为了使估计的难度之和最小，而只计算被分配到该任务的团队成员的估计难度值。你的任务是计算这个最小的可能总和。

## 说明/提示

**【样例 1 解释】**

给第 $1$ 号成员分配第 $1$ 题，给第 $2$ 号成员分配第 $3$ 道题，给第 $3$ 号成员分配第 $2$ 道题。这样分配的难度总和为 $1+1+2=4$。可以证明没有难度总和更小的分配方案。

**【数据范围】**

对于所有数据，$3\leqslant n\leqslant 1.5\times 10^5$，$1\leqslant d_{i,j}\leqslant 5$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T3 ACM_**，按照原题数据配置，满分 $100$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
3
1 3 3
1 1 1
1 2 3```

### 输出

```
4```

## 样例 #2

### 输入

```
7
3 3 4 1 3 4 4
4 2 5 1 5 5 4
5 5 1 3 4 4 4```

### 输出

```
19```

# 题解

## 作者：Miss_SGT (赞：14)

我们阅读题目发现，就是把一个序列分成三段，每段对应一个人，总价为每人对应段的价值和。

我们令 $\mathit{f}_{i,z,p,0}$ 为做到序列第 $i$ 个，状态为 $z$，末尾是 $p$，且末尾是一段。
而 $\mathit{f}_{i,z,p,1}$  为末尾只有一个。

因为 $\mathit{f}_{i,z,p,0}$  末尾为一段，所以只能考虑继承前面状态一样，也是 $p$ 结尾的。而 $\mathit{f}_{i,z,p,1}$  就枚举状态里存在的不为 $p$ 的人进行继承。

别忘了加上难度值!

Ac 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[2][8][3][2],dft[3][150005],minn=2e9;
int len(int num){
	int cnt=0;
	for(int p=0;p<3;p++)
		if((num>>p)&1) cnt++;
	return cnt; 
}
int main(){
	scanf("%d",&n);
	for(int p=0;p<3;p++)
		for(int i=1;i<=n;i++)
			scanf("%d",&dft[p][i]);
	for(int i=1;i<=n;i++){
		for(int z=1;z<=7;z++){
			for(int p=0;p<3;p++) f[i&1][z][p][0]=f[i&1][z][p][1]=minn;
			if(len(z)>i) continue;
			for(int p=0;p<3;p++){
				if(!((z>>p)&1)) continue;
				f[i&1][z][p][0]=min(f[1-(i&1)][z][p][0],f[1-(i&1)][z][p][1])+dft[p][i];
				for(int pp=0;pp<3;pp++){
					if(!((z>>pp)&1)||pp==p) continue;
					f[i&1][z][p][1]=min(f[i&1][z][p][1],f[1-(i&1)][z-(1<<p)][pp][0]+dft[p][i]);
					f[i&1][z][p][1]=min(f[i&1][z][p][1],f[1-(i&1)][z-(1<<p)][pp][1]+dft[p][i]);	
				}
			}
		}
	}for(int p=0;p<3;p++){
		minn=min(minn,min(f[n&1][7][p][0],f[n&1][7][p][1]));
	}printf("%d",minn);
	return 0;
}
```



---

## 作者：WAWA_QWQ (赞：9)

[更好的阅读体验](https://www.luogu.com.cn/article/j5rtyzwj)

---

很有趣的 DP 题。

规定 Stjepan 的编号为 $0$，Ivan 为 $1$，Gustav 为 $2$。

**定义**：$f_{i,a,b,c,d}$ 表示当前做到第 $i$ 个任务，做题选手顺序为 $a$，$b$，$c$，且当前题目由编号为 $d$ 的人完成时的最优解。

例：$f_{5,2,0,1,0}$ 表示做题选手顺序为 Gustav（$2$），Stjepan（$0$），Ivan（$1$），且当前题目是由 Stjepan（$0$）在完成第 $5$ 道题目时的最优解。

**初始化**：一开始将 $f$ 数组打上 $+\infty$；$f_{1,a,b,c,a}$ 显然就等于 $d_{a,1}$。

**转移思路**：判断上个任务是由自己做优秀还是由排列中的前一个人完成优秀。（本题核心）

**答案**：最后一个任务一定是由排列中的最后一个人完成的，即 $f_{n,a,b,c,c}$。



```cpp
#include<bits/stdc++.h> 
using namespace std;
const int maxn=200005;
int n,d[3][maxn],f[maxn][3][3][3][3],ans=1<<30;
int read(){
	char ch=getchar();int ret=0,f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+(ch&15),ch=getchar();
	return ret*f;
}
int main(){
	n=read();
	for(int i=0;i<3;i++)
	for(int j=1;j<=n;j++)
	  d[i][j]=read();
	
	for(int i=0;i<=n;i++)
	for(int a=0;a<3;a++)
	for(int b=0;b<3;b++)
	for(int c=0;c<3;c++)
	for(int d=0;d<3;d++)
	  f[i][a][b][c][d]=1<<30;//初始化，用memset会MLE
	
	f[1][0][1][2][0]=d[0][1];
	f[1][0][2][1][0]=d[0][1];
	f[1][1][0][2][1]=d[1][1];
	f[1][1][2][0][1]=d[1][1];
	f[1][2][0][1][2]=d[2][1];
	f[1][2][1][0][2]=d[2][1];//f[1][a][b][c][a]=a[a][1]：第一个任务只能由排列中的第一个人完成，其最优解为第一个人对于这道题目估计的难度
	
	for(int i=2;i<=n;i++){
		f[i][0][1][2][0]=f[i-1][0][1][2][0]+d[0][i];
		f[i][1][0][2][1]=f[i-1][1][0][2][1]+d[1][i];
		f[i][1][2][0][1]=f[i-1][1][2][0][1]+d[1][i];
		f[i][0][2][1][0]=f[i-1][0][2][1][0]+d[0][i];
		f[i][2][0][1][2]=f[i-1][2][0][1][2]+d[2][i];
		f[i][2][1][0][2]=f[i-1][2][1][0][2]+d[2][i];//1至i的任务都是由第一个人完成的，继承前一状态+当前代价即可 
		if(i<2) continue; 
		f[i][0][1][2][1]=min(f[i-1][0][1][2][0],f[i-1][0][1][2][1])+d[1][i];
		f[i][0][2][1][2]=min(f[i-1][0][2][1][0],f[i-1][0][2][1][2])+d[2][i];
		f[i][1][0][2][0]=min(f[i-1][1][0][2][1],f[i-1][1][0][2][0])+d[0][i];
		f[i][1][2][0][2]=min(f[i-1][1][2][0][1],f[i-1][1][2][0][2])+d[2][i];
		f[i][2][0][1][0]=min(f[i-1][2][0][1][2],f[i-1][2][0][1][0])+d[0][i];
		f[i][2][1][0][1]=min(f[i-1][2][1][0][2],f[i-1][2][1][0][1])+d[1][i];//当前任务由第二个人完成，比较上一个任务是由自己完成好还是别人完成好
		if(i<3) continue;
		f[i][0][1][2][2]=min(f[i-1][0][1][2][1],f[i-1][0][1][2][2])+d[2][i];
		f[i][0][2][1][1]=min(f[i-1][0][2][1][2],f[i-1][0][2][1][1])+d[1][i];
		f[i][1][0][2][2]=min(f[i-1][1][0][2][0],f[i-1][1][0][2][2])+d[2][i];
		f[i][1][2][0][0]=min(f[i-1][1][2][0][0],f[i-1][1][2][0][2])+d[0][i];
		f[i][2][0][1][1]=min(f[i-1][2][0][1][0],f[i-1][2][0][1][1])+d[1][i];
		f[i][2][1][0][0]=min(f[i-1][2][1][0][0],f[i-1][2][1][0][1])+d[0][i];//当前任务由第三个人完成，比较上一个任务是由自己完成好还是别人完成好
	}
	ans=min(ans,f[n][0][1][2][2]);
	ans=min(ans,f[n][0][2][1][1]);
	ans=min(ans,f[n][1][0][2][2]);
	ans=min(ans,f[n][1][2][0][0]);
	ans=min(ans,f[n][2][0][1][1]);
	ans=min(ans,f[n][2][1][0][0]);//无论如何，最后一个任务一定是由排列中的最后一个人完成的
	printf("%d\n",ans); 
	return 0;
}
```

附录：[本思路的另一种写法](https://www.luogu.com.cn/paste/xelol0w7)。

Idea：@[WAWA_QWQ](https://www.luogu.com.cn/discuss/893769)。

排版 & 格式：@[Rigel](https://www.luogu.com.cn/discuss/602458)。

---

## 作者：Bpds1110 (赞：7)

[**Link**](https://www.luogu.com.cn/problem/P7793)
## Describe:
> 有 $3$ 人和 $n$ 道题目，他们分别认为每题的难度为 $a_i$，$b_i$ 和 $c_i$，每人可以做连续的至少 $1$ 道题目。现在，你可以任意分配三人，使他们做题的总难度值尽可能小。

## Solution:
来自一位学长的做法。我们考虑用 DP，设 $f_{i,j}$ 为编号为 $i$ 的人对于第 $j$ 题的难度。

- 状态：$dp_{i,j}$ 表示当编号为 $j$ 的人，总共做到第 $i$ 题时，最小的难度值总和。
- 初值：显然，$dp_{1,0} = f_{1,0}$。
- 转移方程：当前这题，除了编号为 $0$ 外，分别可以从上一个编号的人或自己做上一题进行转移。于是得出方程。
$dp_{i,j} = \left\{\begin{matrix}
  dp_{i - 1,j} + f_{i,j}& j = 0\\
  \min \left \{ dp_{i - 1,j - 1}, dp_{i - 1,j} \right \} + f_{i,j} & j =1,2
\end{matrix}\right.$

但是因为三个人可以任意安排，所以要把每种可能的情况都做一遍，然后求最小。
## Code:
```cpp
#include <bits/stdc++.h>
#define min(x, y) (x < y ? x : y)
using namespace std;
const int N = 150001;
int n, minn = 0x3f3f3f3f, f[N][3], dp[N][3];
void solve(int a, int b, int c)
{
	memset(dp, 0x3f, sizeof(dp));//默认最大
	dp[1][a] = f[1][a];//初值
	for(int i = 2; i <= n; i ++)
	{
		dp[i][a] = dp[i - 1][a] + f[i][a];
		dp[i][b] = min(dp[i - 1][a], dp[i - 1][b]) + f[i][b];
		dp[i][c] = min(dp[i - 1][b], dp[i - 1][c]) + f[i][c];
	}
	minn = min(minn, dp[n][c]);
}
int main()
{
	cin >> n;
	for(int i = 1; i <= n; i ++)
		cin >> f[i][0];
	for(int i = 1; i <= n; i ++)
		cin >> f[i][1];
	for(int i = 1; i <= n; i ++)
		cin >> f[i][2];
	solve(0, 1, 2);
	solve(0, 2, 1);
	solve(1, 0, 2);
	solve(1, 2, 0);
	solve(2, 0, 1);
	solve(2, 1, 0);
	cout << minn;
	return 0;
}

```


---

## 作者：zzy0618 (赞：6)

 ### 题目大意
 
 [题目链接](https://www.luogu.com.cn/problem/P7793)
 
将 $n$ 项任务分给 $3$ 个人，每个人做不同任务的难度不同，求出最小难度总和。
 
要注意以下几点：
 
 - 任务阵列将被分成三部分，每个人得到一个**连续任务序列**（不然就肯定选最小的，没意思了）。
 
 - 每个人至少分配一项任务，也就是题目所说的**非空**的连续任务序列（做题时的惨痛教训）。
 
 - 只计算做该项任务的人的难度值~~废话~~。
 
 ### 主要思路
 
枚举加上记忆化搜索。
 
既然三个人安排的顺序可能不同，不如直接枚举，毕竟上面的大佬也说了，只有 $6$ 种情况。这部分可以用 STL 的全排列函数实现，不必硬打。



下面考虑搜索，基本代码如下


```cpp
int dfs(int step, int p) {//step 第几项任务，p 第几个人 
    int num = 0;
    if (step <= n) {//如果还没结束 
        num = d[a[p]][step] + dfs(step + 1, p);
        if (p < 3)//如果还有人没分配 
            num = min(num, d[a[p]][step] + dfs(step + 1, p + 1));
    }
    else if(step>n && p<3)num = 1000000000;//如果没到最后一个人 
    return num;
}
```

这样做会显然会超时更何况还要执行 $6$ 遍，所以要加上记忆化。

```cpp
int dfs(int step, int p) {
    if (jiyi[step][p])return jiyi[step][p];//已经搜索过了
    int num = 0;
    if (step <= n) {
        num = d[a[p]][step] + dfs(step + 1, p);
        if (p < 3)
            num = min(num, d[a[p]][step] + dfs(step + 1, p + 1));
    }
    else if(step>n && p<3)num = 1000000000;
    jiyi[step][p] = num;//保存记忆
    return num;
}
```

 
 ### 完整代码
 
 与之前的大佬有点像，但是只有 $35$ 行的代码是很轻便的。
 
```cpp
#include <bits/stdc++.h>
using namespace std;
int read() {
    int x = 0, f = 1; char ch = getchar();
    while (ch > '9' || ch < '0') { if (ch == '-')f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}//快读模板 
int n, ans = 1000000000;
int d[5][150001], jiyi[150001][5]; 
int a[5] = { 0,1,2,3,0 };//全排列数组  
int dfs(int step, int p) {
    if (jiyi[step][p])return jiyi[step][p];
    int num = 0;
    if (step <= n) {
        num = d[a[p]][step] + dfs(step + 1, p);
        if (p < 3)
            num = min(num, d[a[p]][step] + dfs(step + 1, p + 1));
    }
    else if(step>n && p<3)num = 1000000000;
    jiyi[step][p] = num;
    return num;
}
int main() {
    n = read();
    for (int i = 1; i <= 3; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = read();
    do {
        memset(jiyi, 0, sizeof(jiyi));//清空记忆 
        ans = min(ans, d[a[1]][1] + dfs(2, 1));
    } while (next_permutation(a + 1, a + 3 + 1));//STL的全排列函数 
    printf("%d", ans);
    return 0;
}
```


---

## 作者：Sya_Resory (赞：5)

[题目链接](https://www.luogu.com.cn/problem/P7793)

题目中要求把任务分配给 $3$ 个人，那么我们可以先枚举这三个人的顺序，共有 $3!=6$ 种。

接着对于每种排列，可以通过记忆化搜索求出最小值。

具体细节见代码。


```cpp
#include <cstdio>
#include <cstring>

const int maxn = 1.5e5 + 5;
const int inf = 0x3f3f3f3f;

int n,ans = inf;
int nxt[5],d[5][maxn],opt[5][maxn];

inline int read() {
#define gc c = getchar()
    int d = 0,f = 0,gc;
    for(;c < 48 || c > 57;gc) f |= (c == '-');
    for(;c > 47 && c < 58;gc) d = (d << 1) + (d << 3) + (c ^ 48);
#undef gc
    return f ? -d : d;
}

inline void minx(int& a,int b) { a = (a < b ? a : b); }

int dfs(int id,int p) { // id 表示上一个考虑的位置下标为id，p 表示上一个人是 p
    if(opt[p][id]) return opt[p][id]; // 搜过了
    int res = 0;
    if(id > n) { // 到最后了
        if(nxt[p] != -1) res = inf; // 不是最后一个人
        // 如果是最后一个人，那么res的值为0，故省略
    } else {
        res = d[p][id] + dfs(id + 1,p); // 不换人
        if(nxt[p] != -1) minx(res,d[nxt[p]][id] + dfs(id + 1,nxt[p])); // 不是最后一个人就可以换
    }
    return opt[p][id] = res; // 记忆化
}

int work(int a,int b,int c) {
    nxt[a] = b;
    nxt[b] = c;
    nxt[c] = -1; // 记下每个人对应的下一个人
    memset(opt,0,sizeof(opt));
    return d[a][1] + dfs(2,a); // 记忆化搜索
}

void solve() { // 枚举每一种排列
    minx(ans,work(1,2,3));
    minx(ans,work(1,3,2));
    minx(ans,work(2,1,3));
    minx(ans,work(2,3,1));
    minx(ans,work(3,1,2));
    minx(ans,work(3,2,1));
}

int main() {
    n = read();
    for(int i = 1;i <= 3;i ++)
        for(int j = 1;j <= n;j ++)
            d[i][j] = read(); // 输入
    solve();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：fmdd_szx (赞：3)

[原题](https://www.luogu.com.cn/problem/P7793)

# 题意

把 $n$ 道题分配给 $3$ 人，每人可连续做若干题目，使他们做题的难度值总和最小。

# 思路

运用 DP。

$dp_{i,j}$ 为当前做到第 $i$ 题时，第 $j$ 个人的最小难度和。

当前这题，编号 $0$ 除外，分别可以从上一人或从自己做的上一题进行转移。

因此得出转移方程：

- 编号为 $0$ 时，$dp_{i,j}=dp_{i-1,j}+f_{i,j}$。

- 编号为 $1$ 或 $2$ 时，$dp_{i,j}= \min \{dp_{i-1,j-1},dp_{i-1,j}\}+f_{i,j}$。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j,f[4][150001],dp[150001][4],mi;
void work(int a,int b,int c){
    int i;
    memset(dp,0x3f,sizeof(dp));
    dp[1][1]=f[a][1];//dp初始化
    for(i=2;i<=n;i++){
        dp[i][1]=dp[i-1][1]+f[a][i];
        dp[i][2]=min(dp[i-1][1],dp[i-1][2])+f[b][i];
        dp[i][3]=min(dp[i-1][2],dp[i-1][3])+f[c][i];
    }
    mi=min(mi,dp[n][3]);//求最小答案
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n;mi=2e9;
    for(i=1;i<=3;i++)
        for(j=1;j<=n;j++)
            cin>>f[i][j];//难度值
    work(1,2,3);work(1,3,2);
    work(2,1,3);work(2,3,1);
    work(3,1,2);work(3,2,1);
    cout<<mi;
    return 0;
}
```


---

## 作者：LEE114514 (赞：1)

## 思路

设 $a_i$ 表示第一位队员对第 $i$ 的预计难度，以此类推用 $b_i,c_i$ 分别表示第二，三位队员对第 $i$ 的预计难度。

再设 $A,B,C$ 表示 $a,b,c$ 的前缀和。

不妨设考虑第一段给分配给第一位队员，第二段分配给第二位队员，第三段分配给第三位队员。

此时 $[1,x],[x+1,y],[y+1,n]$ 分别分配给三位队员的预计难度总和即为 $A_x+B_y-B_x+C_n-C_y$。

考虑枚举上式中的 $x$，整理得 $A_x-B_x+C_n+(B_y-C_y)$，其中 $y$ 的取值范围是 $(x,n)$。为了得到最小总和，我们需要在枚举过程中最小化 $B_y-C_y$，发现可以使用后缀最小值实现。

注意刚才我们**不妨设考虑第一段给分配给第一位队员，第二段分配给第二位队员，第三段分配给第三位队员**。所以要尝试每一种分配方式。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=150005;
int n,A[maxn],B[maxn],C[maxn];
int ans=1e9;
void work(int *a,int *b,int *c){
	int tmpmin=1e9;
	int res=1e9;
	for(int i=n-1;i>=1;--i){
		res=min(res,a[i]-b[i]+c[n]+tmpmin);
		tmpmin=min(tmpmin,b[i]-c[i]);
	}
	ans=min(ans,res);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",A+i),A[i]+=A[i-1];
	for(int i=1;i<=n;++i) scanf("%d",B+i),B[i]+=B[i-1];
	for(int i=1;i<=n;++i) scanf("%d",C+i),C[i]+=C[i-1];
	work(A,B,C);
	work(A,C,B);
	work(B,A,C);
	work(B,C,A);
	work(C,A,B);
	work(C,B,A);
	printf("%d",ans);
}
```

---

## 作者：lqsy002 (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7793)。

## 解题思路

将 $dp_{id,k,step}$ 状态定义为现在取 $k$ 的区间，末尾到了 $step$，已经取过的人二进制压位成 $id$。

转移非常简单，只需要区分是否换人，具体转移方程见代码中注释处。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 150005
#define inf 1000000
using namespace std;
int n,a[5][maxn],ans=inf;
int sum[5][maxn],dp[5][10][maxn];
int query(int id,int k,int step){
	if(~dp[id][k][step])
		return dp[id][k][step];
	if(!step){
		if(!k)
			dp[id][k][step]=0;
		else
			dp[id][k][step]=inf;
		return dp[id][k][step];
	}
  	//以下为转移方程
	int res=min(inf,query(id,k,step-1)+a[id][step]);
	for(int i=0;i<3;++i)
		if(i!=id&&(1<<i)&k)
			res=min(res,query(i,k-(1<<id),step-1)+a[i][step]);
	dp[id][k][step]=res;
	return res;
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	memset(dp,-1,sizeof(dp));
	cin>>n;
	for(int i=0;i<3;++i)
		for(int j=1;j<=n;++j){
			cin>>a[i][j];
			sum[i][j]=sum[i][j-1]+a[i][j];
			dp[i][(1<<i)][j]=sum[i][j];
		}
	for(int i=0;i<3;++i)
		ans=min(ans,query(i,((1<<3)-1),n));
	cout<<ans;
	return 0;
}
```

---

## 作者：CarlosLiu (赞：0)

## 题意描述
三个人每人对 $n$ 道题目有一个难度预估，现在要把这些题目分为**连续**的三段，分别给这三个人，使这三个人对手上拿到的题的难度预估的总和最小。
## 解题思路
这道题的关键在于把题目分为连续的三段。这直接就让人想到用 $sum_{i}^{j}$ 计算第 $i$ 个人前 $j$ 个数的总和来进行表示。

我们假设第一个人负责第 $1$ 到 $i$ 道题，第二个人负责第 $i+1$ 到 $j$ 道题，第三个人负责第 $j+1$ 到 $n$ 道题（实际上不一定是这样，所以要对三个人负责的题目的顺序进行分类讨论）。

所以 $sum_{1}^{i}-sum_{2}^{i}+sum_{2}^{j}-sum_{3}^{j}+sum_{3}^{n}$ 就是最后求到的总和。然后我们就意识到了，这个式子中的 $sum_{3}^{n}$ 是不变的，而前面一大堆可以用动态规划求出最小值。最后把前面提到需要做的分类讨论完成了，答案就出来了。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,a[4][200000],sum[4][200000],ans;
int x[6]={1,1,2,2,3,3};
int y[6]={2,3,1,3,1,2};
int z[6]={3,2,3,1,2,1};
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[1][i]);
		sum[1][i]=sum[1][i-1]+a[1][i];
	}
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[2][i]);
		sum[2][i]=sum[2][i-1]+a[2][i];
	}
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[3][i]);
		sum[3][i]=sum[3][i-1]+a[3][i];
	}
	ans=1000000;
	for(int i=0;i<=5;i++) {
		int min,tem;
		tem=sum[x[i]][n];
		min=1000000;
		for(int j=2;j<n;j++) {
			if(sum[z[i]][j-1]-sum[y[i]][j-1]<min) {
				min=sum[z[i]][j-1]-sum[y[i]][j-1];
			}
			if(tem+min+sum[y[i]][j]-sum[x[i]][j]<ans) {
				ans=tem+min+sum[y[i]][j]-sum[x[i]][j];
			}
		}
	}
	cout<<ans;
	return 0;
}
```


---


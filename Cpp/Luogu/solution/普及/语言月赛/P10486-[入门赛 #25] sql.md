# [入门赛 #25] sql

## 题目背景

sql 是一种强大的数据库查询语言。在本题中，你需要实现一个部分功能的 sql 解析器。

## 题目描述

一个数据库可以看作若干张二维表的合集。

例如，一个学生信息管理系统的数据库可能会有如下两张二维表：

`basic_info`：

| name | sid | grade| 
| :-: | :-: | :-: |
| Fusu | 001 | 1 |
| Maxmilite| 002 | 2|
| Expect2004 | 003 | 2 |

`GPA`:

| sid | GPA |
| :-: | :-: |
| 001 | 77.88|
| 002| 99.9 |
| 003| 99.7 |

上述表的第一行称作**表头**，接下来每一行表示表的一组信息。例如，`basic_info` 的第二行表示存在一名学生的姓名（`name`）是 $\texttt{Fusu}$，学号 (`sid`) 为 $\texttt{001}$，年级（`grade`）为 $\texttt{1}$

一个正式的 sql 语言应该支持跨表查询，但是在本题中，你只需要支持在单个表内的查询。我们认为表内的一切属性都以字符串的形式给出。

你需要支持如下格式的查询语句：

```sql
select [columns] from [table_name] where [header]=x
```

上式中，`columns` 是若干个**表头**，`table_name` 是**表名**，`header` 是**表头**，$x$ 是给出的条件。它表示在 `table_name` 这个表里查询 `header` 这一列为 $x$ 的所有行的所有 `columns` 列里的信息。

例如，如果对上述例子里的表执行如下语句：

```sql
select name from basic_info where grade=1
```
表示在 `basic_info` 表里查询 `grade` 列为 $1$ 的所有行，并输出它们的 `name` 列，因此结果为：

```plain
Fusu
```

如果执行

```sql
select name,sid,grade from basic_info where grade=2
```

那么就找到 `basic_info` 表里所有 `grade` 为 `2` 的行，并依次输出它们的 `name`、`sid`、`grade`。结果为：

```plain
Maxmilite 002 2
Expect2004 003 2
```

可以看到，`select` 语句的第一组参数 `columns` 可以是多个表头名称，此时应该按照 `columns` 给出的顺序输出每个对应的列信息。通过 `where` 后面的条件可以查询到多行满足要求的行时，应按照表的输入顺序（即从上到下）输出每行要求的信息。

你需要实现这个 sql 语句解析器，给出 sql 查询结果。注意，我们保证了在查询语句里表名只有一个，且 `where` 后面的条件有且仅有一个等式。

## 说明/提示

### 样例 3 解释

输入的表单可能有若干行是重复的，你无需对这些行做特殊处理，可以认为它们是不同的。每次查询需要输出所有符合要求的行。例如，在第一条 sql 中，`1 2` 这一行出现了两次且符合要求，因此输出了两次 `1 2`。

### 数据规模与约定

| 测试点编号 | 表的数量为 $1$ | 表头数量为 1 |  columns 里仅有一列表头 | 
| :-: | :-: | :-: | :-:|
| 1, 2 | $\checkmark$ | $\checkmark$ | $\checkmark$ |
| 3, 4 | $\checkmark$ | $\times$ | $\checkmark$ |
| 5, 6 | $\times$ | $\checkmark$ |$\checkmark$ |
| 7, 8 | $\times$ | $\times$ | $\checkmark$ |
|9, 10 | $\times$ | $\times$ | $\times$ |

对全部的测试数据，保证：

- $1 \leq n \leq 10$。
- $1 \leq x\leq 100$，$1 \leq y \leq 10$。
- $1 \leq m \leq 1000$。
- 表头 `table_name` 长度不超过 $100$。
- 表的内容和表头的字符串长度不超过 $10$，`columns` 的长度不超过 $100$。
- 除了 `columns` 信息以外，输入的字符串均不含有逗号 `,`。
- 输入字符串均为可见字符，ASCII 范围为 $33\sim 126$（含两端），且不含符号 `=`。

### 提示

请注意大量数据输出对程序效率造成的影响，选择合适的输出方式，避免超时。

## 样例 #1

### 输入

```
1
basic_info
4 3
name sid grade
Fusu 001 1
Maxmilite 002 2
Expect2004 003 2
2
select name from basic_info where grade=1
select sid,name from basic_info where grade=2
```

### 输出

```
Fusu
002 Maxmilite
003 Expect2004
```

## 样例 #2

### 输入

```
2
basic_info
4 3
name sid grade
Fusu 001 1
Maxmilite 002 2
Expect2004 003 2
GPA
2 2
sid GPA
001 77.88
1
select GPA from GPA where sid=001
```

### 输出

```
77.88
```

## 样例 #3

### 输入

```
2
show_corner
3 2
h1 h2
1 2
1 2
show_corner2
3 1
h0
1
1
2
select h1,h2 from show_corner where h1=1
select h0 from show_corner2 where h0=1
```

### 输出

```
1 2
1 2
1
1
```

# 题解

## 作者：Crsuh2er0 (赞：10)

中小模拟。

按照题意模拟即可。注意适当使用面向对象思想。多写注释。

### 一些 Corner Case

- 读取 `[columns]` 时注意对逗号的处理。
- 其他读入和 `getline` 一起用时记得把读入指针处理到正确的位置再 `getline`。
- 确保语句解析时正确地去掉分隔文本。

```cpp
#include <bits/extc++.h>
using namespace std;
int n, m;

struct data {
    map<string, string> d;
};

struct table {
    string name;
    int x, y;
    vector<data> ds;
    vector<string> headers;
};

map<string, table> ts;

void readHeaders(table &t) {
    t.headers.push_back("");
    string tmp;
    for (int i = 1; i <= t.y; i++) {
        cin >> tmp;
        t.headers.push_back(tmp);
    }
}

void readData(table &t) {
    string tmp;
    for (int i = 1; i < t.x; i++) {
        data d;
        for (int j = 1; j <= t.y; j++) {
            cin >> tmp;
            d.d[t.headers[j]] = tmp;
        }
        t.ds.push_back(d);
    }
}

void readTable() {
    table t;
    cin >> t.name >> t.x >> t.y;
    readHeaders(t);
    readData(t);
    ts[t.name] = t;
}

string readUntilBlank(string &tmp) {
    string res;
    int i = 0;
    for (; tmp[i] != ' '; i++)
        ;
    res = tmp.substr(0, i);
    tmp.erase(0, i);
    return res;
}

string readUntilSplit(string &tmp) {
    string res;
    int i = 0;
    for (; tmp[i] != ',' && i < tmp.size(); i++)
        ;
    res = tmp.substr(0, i);
    tmp.erase(0, i);
    return res;
}

string readUntilEqual(string &tmp) {
    string res;
    int i = 0;
    for (; tmp[i] != '='; i++)
        ;
    res = tmp.substr(0, i);
    tmp.erase(0, i);
    return res;
}

vector<string> splitColumns(string &s) {
    vector<string> res;
    while (s.size()) {
        res.push_back(readUntilSplit(s));
        if (s.size()) s.erase(0, 1);  // remove split
    }
    return res;
}

char buf[5010];

void SQL() {
    // read
    do cin.getline(buf, 5010);
    while (buf[0] == 0);
    string sql(buf);
    sql.erase(0, 7);  // remove "select "
    string tmp = readUntilBlank(sql);
    vector<string> cs = splitColumns(tmp);
    sql.erase(0, 1);  // remove " "
    sql.erase(0, 5);  // remove "from "
    string tn = readUntilBlank(sql);
    sql.erase(0, 1);  // remove " "
    sql.erase(0, 6);  // remove "where "
    string header = readUntilEqual(sql);
    sql.erase(0, 1);  // remove "="
    string val = sql;

    // execute
    table t = ts[tn];
    for (data &d : t.ds) {
        if (d.d[header] != val) continue;
        for (string &c : cs) cout << d.d[c] << ' ';
        cout << '\n';
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) readTable();
    cin >> m;
    for (int i = 1; i <= m; i++) SQL();
}
```

---

## 作者：canwen (赞：9)

## 题意
**简化题意：输入每张表格，并用语句查询表格内容。**

$n$ 张表格，每个表格 $x$ 行 $y$ 列，第一行为表头。

$m$ 次 sql 语句查询，格式是 `select [columns] from [table_name] where [header]=x`，输出在 `table_name` 这张表格里，`header` 这一表头的**这一列中**值为 `x` 的那一行的 **`columns` 列的值，且 `columns` 里可能有多个要输出的表头名。** 
## 分析
数据范围很小，主要思路是**模拟**。

我们可以定义如下数组。
```cpp
string name[11],title[11][11],excel[11][101][11];
int xx[11],yy[11];
```
以上分别记录每个表格名字，每个表格的表头，每张表格除第一行（也就是除去表头）的内容，每张表格的长度 $x$ 和宽度 $y$。

这样一来，输入的问题就解决了。

如何查询呢？我们可以编写函数分别查找一个表格名字是第几个，一个表头在每张表格里的第几列。

输入字符串，截取每个字符串的有用部分。

可以用 cstring 库中带有的 substr() 函数来进行截取，比较方便。

对于可以输入多个表头名的 `columns`，我们可以记录一下其中逗号出现的位置，这样模拟会比较方便。特殊的，要判断一下没有逗号出现的情况。

完成上述预备环节之后，就可以愉快地枚举了。

可以参考下面的代码。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

string name[11],title[11][11],excel[11][101][11];//表格名字，每张表的表头，表格整体内容 
int xx[11],yy[11],d[150];//每张表的x，y长度 & 逗号出现的位置 

int n;//n张表 

int f1(string a){
	//返回是第几个表格的名字
	for(int i=1;i<=n;i++){
		if(name[i]==a) return i;
	} 
}

int f2(int a,string b){
	//第a个表中的 b表头的纵坐标
	for(int i=1;i<=yy[a];i++){
		if(title[a][i]==b) return i;
	}
} 

void put(int a,int b,int c){
	//输出内容 
	cout<<excel[a][b][c]<<" ";
	return;
}

signed main(){
	cin>>n;
	
	for(int i=1;i<=n;i++){
		cin>>name[i];//输入表格名字 
		int x,y;cin>>x>>y;
		for(int j=1;j<=y;j++) cin>>title[i][j];//先单独输入表头在title数组，方便判断 
		x--,xx[i]=x,yy[i]=y; //除去表头这一行，剩下 x-1 行 
		for(int j=1;j<=x;j++){
			for(int k=1;k<=y;k++){
				cin>>excel[i][j][k];
			}
		}
	}
	 
	int m;cin>>m;
	for(int i=1;i<=m;i++){
		//select [columns] from [table_name] where [header]=x 
		string out;cin>>out>>out;//记录 `columns`
		int len=0;//记录多少个逗号
		memset(d,0,sizeof(d));//初始化 
		for(int j=0;j<out.size();j++) 
			if(out[j]==',') d[++len]=j;
		
		string which;cin>>which>>which;//记录 `table_name`
		int num=f1(which);//调用函数查询是第几个表格的名字 
		
		string tmp;cin>>tmp>>tmp;
		int tmp1=tmp.find('=');/*查找等号出现的位置*/
		string pd1=tmp.substr(0,tmp1),pd2=tmp.substr(tmp1+1);//截取
		
		
		int num2=f2(num,pd1);//查询表头是第几列，方便枚举 
		
		for(int j=1;j<=xx[num];j++){
			if(excel[num][j][num2]==pd2){//找到了符合条件的 
				
				if(len==0){
					//特判单个表头名的 
					put(num,j,f2(num,out));
				}else{
					for(int k=1;k<=len+1;k++){
						string awa;
						if(k==1) awa=out.substr(0,d[k]);
						else if(k==len+1) awa=out.substr(d[k-1]+1);
						else awa=out.substr(d[k-1]+1,d[k]-d[k-1]-1);
						put(num,j,f2(num,awa));
						//上述是推出来的截取计算式 
						//k==1 0,d[k]
						//k==2 d[k-1]+1,d[k]-d[k-1]-1
						//k==len+1 d[k-1]+1
					}
				}
				printf("\n");
			}
		}
	}
	
	return 0;//good habit~
}
```

下面补充一下上面的代码中出现的在 cstring 库中的函数的使用方法。
```cpp
#include<cstring>
#include<iostream>
using namespace std;

int main(){
	string a="abcd";
	//a.substr(x,y) 截取字符串 a 从下标 x 位置开始，连续的 y 个字符 
	cout<<a.substr(0,2)<<endl;//输出 `ab`
	cout<<a.substr(1)<<endl;//若没有传进 y，默认从下标 x 位置开始截取到末尾，输出 `bcd` 
    //a.find(x) 返回 x 在 a 中的位置（下标从0开始）
    cout<<a.find('d')<<endl;//输出3
	return 0;
}
```

---

## 作者：_Spectator_ (赞：4)

[可能更好的食用体验](/article/vsj6dno2) $|$ 
[题目传送门](/problem/P10788) $|$ 
[我的其他题解](/user/523641#article.2)

小清新模拟题。

------------

### Part 1. 存储

用结构体封装一个表格：
```cpp
struct Table{
	int r,c;
	map<string, int> Which_Line;
	string Data[110][20];
	Table(int r=0, int c=0): r(r),c(c){}
};
map<string, Table> Which_Table;
```

`r,c`：表格的行数（不含表头）和列数。  
`Which_Line`：将表头名称映射到列的编号。  
`Data`：表格中的数据。  
`Which_Table`：将表格名称映射到表格。

### Part 2. 读入

```cpp
cin >> n;
for(int i=1; i<=n; i++){
	string Table_Name;   cin >> Table_Name;
	int r, c;            cin >> r >> c;
	
	Table New_Table(r-1,c); //这里的 r 要减一，因为不包括表头那一行
	for(int j=1; j<=c; j++){
		string Line_Name;
		cin >> Line_Name;
		New_Table. Which_Line[ Line_Name ] = j;
	} //读入每一列的表头并映射到编号
	
	for(int j=1; j<=r-1; j++){
		for(int k=1; k<=c; k++){
			cin >> New_Table. Data[j][k];
		} //读入表格中的数据
	}
	
	Which_Table[ Table_Name ] = New_Table; //将表格名称映射到表格
}
```

好像没什么好讲的诶，看看代码实现吧。

### Part 3. 查询

```cpp
cin >> m;
for(int i=1; i<=m; i++){
	string select;        cin >> select;     //没用的
	string Columns;       cin >> Columns;    //要询问哪些列
	string from;          cin >> from;       //没用的
	string Table_Name;    cin >> Table_Name; //要查询哪个表格
	string where;         cin >> where;      //没用的
	string Header;        cin >> Header;     //表头，注意这里把后面的数据也读进去了
		
	Table Tab = Which_Table[ Table_Name ]; //找出要查询的表格
		
	string Line_Name = "";
	vector<int> Line_id;
	for(char ch: Columns){ //不会有人不知道 std::string 可以这样遍历吧
		if(ch==','){ //将 Columns 根据逗号分隔
			Line_id.push_back( Tab. Which_Line[ Line_Name ] ); //找出询问的列的编号
			Line_Name = "";
		}
		else Line_Name += ch;
	}
	Line_id.push_back( Tab. Which_Line[ Line_Name ] );
		
	string Data = "";
	int Head_id = -1;
	for(char ch: Header){
		if(ch == '='){ //根据 = 号将表头和数据分开
			Head_id = Tab. Which_Line[ Data ]; //找到要查询的表头的列的编号
			Data = "";
		}
		else Data += ch;
	}
	
	for(int j=1; j<=Tab.r; j++){ //枚举表格的每一行
		if( Tab.Data[j][ Head_id ] == Data ){ //如果当前行符合查询条件
			for(int p: Line_id){ //遍历询问的列的编号，输出查询结果
				cout << Tab. Data[j][p] << ' ';
			}
			cout << "\n";
		}
	}
}
```

这样就[切掉](https://www.luogu.com.cn/record/167268085)啦。

---

下面提供一种将字符串按照指定字符分隔的另一种方法，使用 `std::stringstream` 和 `std::getline`。

以下代码：
```cpp
std::string s="1,23,114.514,hhh,qwq awa", t;
std::stringstream strin( s );
while( std::getline(strin, t, ',') ){ //getline: 从 strin 中读入，存入 t，读到 ',' 为止
	std::cout << t << std::endl;
}
```

输出结果为：
```txt
1
23
114.514
hhh
qwq awa
```

可以发现，其成功地将字符串 $s$ 根据逗号分隔成了若干个字符串。

有关 C++ 字符串流的更多信息，可参阅[百度百科](https://baike.baidu.com/item/C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81/2052707)/[C++ 中文参考手册](https://zh.cppreference.com/w/cpp/io/basic_stringstream)。

---

## 作者：Sad_Fool (赞：4)

~~关于赛后三分钟调出来这道题这件事。否则就一遍过了。~~

~~死因：输入格式错误。~~

------------

那么这道题是什么意思呢？



`Student`：

| name | sid | grade| 
| :-: | :-: | :-: |
| Fusu | 001 | 1 |
| Maxmilite| 002 | 2|
| Expect2004 | 003 | 2 |


`Student` 就是这张大表的名字。

然后这张表纵向来看有三个表头，分别为 **`name`**、**`sid`** 和 **`grade`**。

横着来看，第一行（除去表头）的 **`sid`** 为 `001`，**`grade`** 为 `1`，然后它的 **`name`** 就是 `Fusu`。


------------

然后再来看看题目让我们做什么。

题目给了一个输入格式：

`select [columns] from [table_name] where [header]=x`

`select` 是“选择”的意思，`from` 是“从哪来”的意思，`where` 是“在哪里”的意思。

通过题目里的解释，我们可以知道，这让我们求在一个名为 `[table_name]` 的大表里，如果 `[header]` 这个表头下的第 $i$ 项和 `x` 相同，就输出第 $i$ 行的第 $f[columns]$ 项。

但要注意 `[columns]` 中可能有用逗号隔开的多个元素。

$f[s]$ 就是表头名 $s$ 是在第几列。


然后你们应该就会了，只需要保存询问中 `[columns]` 每一项，然后再遍历表的每一行，$f[header]$ 列为给出的 `x` 就输出。这里就不过多展开了。（~~否则题解通道关闭了~~）

下面是赛时代码（加了点注释）：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

struct SQL {
	string name; //这一列的名字 
	string xx[105]; //每一行存的信息 
} a[15][105]; // 第一维大表编号，第二维存表信息 

string names[15]; // 大表名称 
string ques[1005];
int n, m, x[105], y[15];

int find(string s) { // 找表编号 
	for (int i = 1; i <= n; i++) 
		if (names[i] == s) return i;
}

int find2(int id, string s) {
	for (int i = 1; i <= y[id]; i++)
		if (a[id][i].name == s) return i;
}

signed main() {
	cin.tie(0);ios::sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> names[i];
		cin >> x[i] >> y[i];	
		for (int j = 1; j <= y[i]; j++) cin >> a[i][j].name;
		for (int j = 1; j < x[i]; j++)
			for (int k = 1; k <= y[i]; k++) cin >> a[i][j].xx[k];
	}
	cin >> m;
	while (m--) {
		string s1, s, sna="";
		cin >> s1 >> s; // 只有 s 有用 
		int cnt = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s[i] == ',') {
				ques[++cnt] = sna; //询问 
				sna = ""; //sna用来区分每一个 columns 中的每一项 
				continue;
			}
			sna += s[i];
		}
		ques[++cnt] = sna; //最后一项没有逗号 
		cin >> s1 >> s;
		int id = find(s);
		cin >> s1 >> s;
		string ss1[2] = {"",""}; //等于号的前后两项 
		int ccnt = 0;
		for (int i = 0; i < s.length(); i++) {
			if (s[i] == '=') {
				ccnt++;
				continue;
			}
			ss1[ccnt] += s[i];
		}
		int id2 = find2(id, ss1[0]); // 找表头的编号 
		for (int i = 1; i <= x[id]; i++)
			if (a[id][i].xx[id2] == ss1[1]) {
				for (int j = 1; j <= cnt; j++) {
					int id3 = find2(id, ques[j]); 
					cout << a[id][i].xx[id3] << " ";
				}
				cout << "\n";
			}
	}
}
```

还有什么问题可以问我。

---

## 作者：Genshin_ZFYX (赞：4)

一道较麻烦的模拟。

用结构体储存每一张表，里边放上 $x,y$，一个用来记录表头中每一项对应的编号的 map 和一个记录每个学生信息的 vector，再拿一个 map 记录下每张表对应的编号。

下面是每次查询的步骤：

1. 找到对应的表。
2. 遍历每个学生，将符合要求的加入队列。
3. 输出队列里学生的所需信息。

纯模拟思路最简单，写起来最麻烦。

下面是 AC 代码，马蜂清新可爱活泼易懂：

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
#define I return
#define love 0
#define FIRESTARS ;
struct exel{
	string name,s[15];
	int x,y;
	vector<string>v[105];
	unordered_map<string,int>mp;
}a[15];
unordered_map<string,int>na;
bool vis[105];
signed main()
{
    ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
    int n,ss;cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>a[i].name>>a[i].x>>a[i].y;
    	na[a[i].name]=i;
    	for(int j=0;j<a[i].y;j++)
    	{
    		cin>>a[i].s[j];
    		a[i].mp[a[i].s[j]]=j;
		}
    	for(int j=1;j<a[i].x;j++)
    		for(int k=1;k<=a[i].y;k++)
    		{
    			string x;cin>>x;
    			a[i].v[j].push_back(x);
			}
	}
	cin>>ss;
	while(ss--)
	{
		string my,s1,cl,cz;cin>>my>>s1;
		vector<string>q;
		string s2="";
		s1+=",";
		for(int i=0;i<s1.size();i++)
		{
			if(s1[i]==',')
			{
				q.push_back(s2);
				s2="";
			}
			else s2+=s1[i];
		}
		cin>>my;cin>>s1;cin>>my;
		int num=na[s1],f=0;
		cin>>s1;
		for(int i=0;i<s1.size();i++)
		if(s1[i]=='=')f=1;
		else{
			if(f==1)cz+=s1[i];
			else cl+=s1[i];
		}
		int mb=a[num].mp[cl];
		queue<int>q1;
		for(int i=0;i<q.size();i++)
		{
			for(int j=1;j<a[num].x;j++)
			{
				if(a[num].v[j][mb]==cz)
				q1.push(j);
			}
		}
		memset(vis,0,sizeof(vis));
		while(!q1.empty())
		{
			int t=q1.front();q1.pop();
			if(vis[t])continue;
			vis[t]=1;
			for(int i=0;i<q.size();i++)
			{
				int bh=a[num].mp[q[i]];
				cout<<a[num].v[t][bh]<<" ";
			}
			cout<<'\n';
		}
	}
	I love FIRESTARS
}
```

---

## 作者：JXR_Kalcium (赞：3)

## 题目大意

非常绕，给定 $n$ 张表格，每张表格有 $x$ 行 $y$ 列，第 $1$ 行为表头，剩下的 $(x-1)\times y$ 个数据为每个表头对应的数据，现在给定 $m$ 次询问，形如 `select [columns] from [table_name] where [header]=x
` 的形式，表示从 `table_name` 这张表格中，满足某一列表头为 `header`，这列中的某些数据等于 $x$，请输出满足此要求，在表格中对应的 `columns` 的数据（听不懂算了，我也不太懂）。

举一个栗子：`select name,sid,grade from basic_info where grade=2` 就表示 `basic_info` 表里所有 `grade` 为 $2$ 的行，并依次输出它们的 `name,sid,grade`。

## 解题思路

一看到这种字符串+大模拟就要想到用 `map` 来存，首先存好每张表的名字对应的表格编号，然后对于每张表格的每个表头也要存好编号，接下来对于每次询问，先把 `columns` 按照逗号分隔开，再将 `[header]=x` 的部分按照等号分开，然后根据刚才存的 `map` 找到对应的表格及行列编号，输出即可。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll int
#define endl putchar(10)
#define spc putchar(32)
using namespace std;

inline ll read()
{
    ll x=0,f=1; char c=getchar();

    while(c<48 || c>57)
    {
        if(c=='-') f=-1;
        c=getchar();
    }

    while(c>47 && c<58)
    x=(x<<1)+(x<<3)+c-48, c=getchar();
    return x*f;
}

inline void write(ll x)
{
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+48); return;
}

ll n,q,x[11],y[11],h,ans[101],cnt,cnt2;
string s,t[11][101][11],p,l,m; 
map<string,ll> mp1;
map<ll,map<string,ll> > mp2;

int main()
{
    n=read();

    for(int i=1; i<=n; ++i)
    {
        cin >> s; mp1[s]=i;
        x[i]=read(); y[i]=read();
        for(int j=1; j<=y[i]; ++j)
        cin >> s, mp2[i][s]=j;

        for(int j=2; j<=x[i]; ++j)
        {
            for(int k=1; k<=y[i]; ++k)
            cin >> t[i][j][k];
        }
    }

    q=read();

    while(q--)
    {
        cin >> p >> s >> p >> l >> p >> m;
        h=0; n=m.size(); string f,g; cnt=0;
        while(m[h]!='=') f+=m[h++]; ++h;
        while(h<n) g+=m[h++];

        for(int i=2; i<=x[mp1[l]]; ++i)
        {
            if(t[mp1[l]][i][mp2[mp1[l]][f]]==g)
            ans[++cnt]=i;
        }
        
        string w[101]; cnt2=0;
        h=0; n=s.size();
        
        while(h<n)
        {
            ++cnt2;
            while(s[h]!=',' && h<n) w[cnt2]+=s[h++];
            ++h;
        }

        for(int i=1; i<=cnt; ++i)
        {
            for(int j=1; j<=cnt2; ++j)
            cout << t[mp1[l]][ans[i]][mp2[mp1[l]][w[j]]], spc;
            endl;
        }
    }

    return 0;
}
```

---

## 作者：The_Elation_Aha (赞：3)

赶紧交一发，纪念赛时一发过，虽然前面的题做太慢了。

--------

这道题只需要你会熟练运用 ``string`` 和 ``map`` 就行。为了代码整洁并方便进行调用，我们还可以把每个表的信息用 ``struct`` 存起来。具体地像这样：

```cpp
map <string,ll> b_id; //每个表的名字对应的编号
struct sql{
	ll n,m;
	map <string,ll> id; //表头对应编号
	string info[101][11]; //表内信息 
}a[11];
```

构建每个表就直接按上面的定义来赋值就行了。

然后考虑查询。我们要过滤掉无用的信息，由于查询的格式是非常固定的，所以可以直接用 ``cin`` 来读取字符串。第一个需要保存的信息是**表中需要输出的部分**，发现每个要输出的表头信息之间是隔了一个逗号的，那么可以用一个字符串记录当前扫到的所有字符，如果出现逗号就把前面存下来的字符串记录下来，把存贮扫到的字符信息的串重新赋为空串。注意最后一个表头信息也要存下。具体而言如下：

```
string t[N],s,s1;
ll tot=0;
cin>>s; cin>>s;
for(int i=0;i<s.size();++i){
	if(s[i]==','){
		t[++tot]=s1;
		s1="";
	}
	else s1=s1+s[i];
}
if(s1!="") t[++tot]=s1;
```

然后记录下查询的表的名字，并用 ``map`` 得到其对应编号，然后在这个表里顺次扫一遍每一行的信息是否对应给出的条件就行了，如果满足条件则输出记录下来的表头信息对应编号那一列的信息，这里建议看一下代码怎么写的。处理需要满足条件的方法和处理需要输出的表头信息类似，只不过只有一个 ``=`` 号。

如果你真的会用 STL 那么就非常简单。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1145,M=1919810;
ll T,cnt,q;
string basic_info,name,gett;
map <string,ll> b_id;
struct sql{
	ll n,m;
	map <string,ll> id; //表头对应编号
	string info[101][11]; //表内信息 
}a[11];
void solve(){
	++cnt;
	cin>>basic_info,b_id[basic_info]=cnt;
	cin>>a[cnt].n>>a[cnt].m;
	for(int i=1;i<=a[cnt].m;++i) cin>>name,a[cnt].id[name]=i;
	for(int i=1;i<a[cnt].n;++i)
		for(int j=1;j<=a[cnt].m;++j)
			cin>>a[cnt].info[i][j];
}
string t[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>T;
	while(T--) solve();
	cin>>q;
	while(q--){
		ll tot=0;
		string s,s1;
		cin>>s; cin>>s;
		for(int i=0;i<s.size();++i){
			if(s[i]==','){
				t[++tot]=s1;
				s1="";
			}
			else s1=s1+s[i];
		}
		if(s1!="") t[++tot]=s1;
		cin>>s>>basic_info; cin>>s; cin>>s;
		ll id=b_id[basic_info],fl=0;
		name="",gett="";
		for(int i=0;i<s.size();++i){
			if(s[i]=='='){
				fl=1;
				continue;
			}
			if(!fl) name=name+s[i];
			else gett=gett+s[i];
		}
		for(int i=1;i<a[id].n;++i){
			if(a[id].info[i][a[id].id[name]]!=gett) continue;
			for(int j=1;j<=tot;++j) cout<<a[id].info[i][a[id].id[t[j]]]<<" ";
			cout<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：FurippuWRY (赞：2)

感谢此题让我学会了字符串的使用方法。

由于有多张表，且每张表都是二维的，不难想到要开一个三维的字符串数组。

定义一个 `map<string, int> ti;`，用来存储各个字符串对应的序号。在输入标题 `tit` 的时候，执行 `z[tit] = i`，这样就把各张表的标题变为了序号，便于查找。

再定义一个 `map<string, int> z[101];`，用于存储第 $i$ 张表的表头所在的列数。

接下来输入 $m$，然后需要再调用一下 `getline()` 函数，把换行符搞掉，不然会一片 RE。

本题最难的点就在于分离 `select [columns] from [table_name] where [header]=x` 这坨字符串，我们可以用 `find()` 和 `substr()` 函数来提取 `columns` 等子串。

`find()` 函数会返回字符串中第一个被查找到的元素的下标。设有一字符串 $S=\tt IAKNOI,IAKIOI$，这时执行 `S.find('N')`，函数就会返回 $3$（因为 $S_3=\tt N$）；对于直接查找字符串，如执行 `S.find("IAKIOI")`，函数就会返回 $7$。若要从下标 $pos$ 开始查找字符 $c$，那么执行 `s.find(c, pos);` 即可。如果没找到，会返回 `std::string::npos`。

`substr()` 可以提取字符串中的子串，这个函数有多种用法，本题只需以下两种：

- `S.substr(a)`，提取下标 $a$ 后的所有字符（包括 $S_a$），组成字符串；
- `S.substr(a, b)`，提取下标 $a$ 后长度为 $b$ 的子串（包括 $S_a$）。

具体使用见以下代码。

```cpp
/* 
分离查询字符串，如 "select sid,name from basic_info where grade=2"
c[1] = "sid"
c[2] = "name"
t = "basic_info"
h = "grade"
u = "2"
*/
string ct, t, h, u, p1, p2, c[500];
getline(cin, p1);
int x_1 = p1.find("select ") + 7;
int x_2 = p1.find(" from ", x_1);
int x_3 = p1.find(" where ", x_2 + 5);
ct = p1.substr(x_1, x_2 - x_1);
t = p1.substr(x_2 + 6, x_3 - x_2 - 6);
p2 = p1.substr(x_3 + 7);
int ot = p2.find('=');
h = p2.substr(0, ot);
u = p2.substr(ot + 1);
int cnt = 0, lst = 0;
// 判断 columns 中是否包括逗号，存储至数组 c 中
if (ct.find(',') == string::npos) {
	c[++cnt] = ct;
}
else {
	int len = ct.size();
	for (int i = 0; i < len; ++i) {
		if (ct[i] == ',') {
			cnt++;
			c[cnt] = ct.substr(lst, i - lst);
			lst = i + 1;
		}
	}
	cnt++;
	c[cnt] = ct.substr(lst, len - lst);
}
```

接着就是查询并输出，我们要从第二行开始枚举，判断这一行的 `header` 元素是否等于 `x`，若为真，遍历 `c` 数组，查询要输出的元素，最后换行；若为假，则跳过。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m;
string tit; // title，即标题
string k[11][301][301]; // k[表名（序号）][行][列]
map<string, int> ti;
map<string, int> z[101];
int x[110], y;

int main() {	
	
   	cin >> n;
   	for (int i = 1; i <= n; ++i) {
   		cin >> tit;
   		ti[tit] = i;
   		cin >> x[i] >> y;
   		for (int j = 1; j <= x[i]; ++j) {
   			for (int w = 1; w <= y; ++w) {
				cin >> k[i][j][w];
   				if (j == 1) {
   					z[i][k[i][j][w]] = w;
   				}
   			}
   		}
   	}
   	
   	cin >> m;
   	getline(cin, tit);
	while (m--) {
   		string ct, t, h, u, p1, p2, c[500];
   		getline(cin, p1);
   		int x_1 = p1.find("select ") + 7;
   		int x_2 = p1.find(" from ", x_1);
   		int x_3 = p1.find(" where ", x_2 + 5);
   		ct = p1.substr(x_1, x_2 - x_1);
   		t = p1.substr(x_2 + 6, x_3 - x_2 - 6);
   		p2 = p1.substr(x_3 + 7);
   		int ot = p2.find('=');
   		h = p2.substr(0, ot);
   		u = p2.substr(ot + 1);
   		int cnt = 0, lst = 0;
   		if (ct.find(',') == string::npos) {
   			c[++cnt] = ct;
   		}
   		else {
   			int len = ct.size();
   			for (int i = 0; i < len; ++i) {
   				if (ct[i] == ',') {
   					++cnt;
   					c[cnt] = ct.substr(lst, i - lst);
   					lst = i + 1;
   				}
   			}
   			++cnt;
   			c[cnt] = ct.substr(lst, len - lst);
   		}
		int t_num = ti[t];
		for (int i = 2; i <= x[t_num]; ++i) {
			if (k[t_num][i][z[t_num][h]] != u) {
				continue;
			}
			for (int j = 1; j <= cnt; ++j) {
				cout << k[t_num][i][z[t_num][c[j]]] << ' ';
			}
			cout << '\n';
		}
   	}
    
	return 0;
}
```

---

## 作者：xuezhiyu (赞：2)

# 题面

现在有 $n$ 个数据库中的表，每个表由表头和数据组成，可以看成一个矩阵。现在有 $m$ 个询问，每个询问的格式是 `select [columns] from [table_name] where [header]=[x]`，意思是在名为 `table_name` 的表中寻找表头 `header` 为 `x` 的项，然后输出这些项的 `columns` 值。

# 分析题目

其实就是纯模拟题目

~~我绝对不会告诉你我调了一个多小时~~

---

我们可以用一个结构体来存下每个表，具体要存的是表头和对应的表项，还有这个表的大小（虽然可能没用，但是存上吧，万一呢？）

```cpp
struct table {
	int x, y;
	string biaotous[15];
	map<string, vector<string>> cs;
};
```

然后对于 `columns`，我们需要将它按 `,` 分割成若干个字符串。我在这里用的是 `stringstream` 的写法，把所有的逗号替换成空格，然后一个一个读入，因为默认读入一个 `string` 碰到空格会直接终止。

```cpp
vector<string> split(string s, char c) {
	for (char& i : s)
		if (i == c)
			i = ' ';
	stringstream ret;
	ret << s;
	vector<string> vec;
	string st;
	while (ret >> st) {
		vec.push_back(st);
	}
	return vec;
}
```

最后在主函数里面遍历一遍就行了！

## 完结~撒花~

---

```cpp
#include <iostream>
#include <map>
#include <sstream>
#include <vector>

using namespace std;

struct table {
	int x, y;
	string biaotous[15];
	map<string, vector<string>> cs;
};

int n, m;
table tables[15];
map<string, int> nametoid;

vector<string> split(string s, char c) {
	for (char& i : s)
		if (i == c)
			i = ' ';
	stringstream ret;
	ret << s;
	vector<string> vec;
	string st;
	while (ret >> st) {
		vec.push_back(st);
	}
	return vec;
}

int main() {
	scanf("%d", &n);
	for (int cur = 1; cur <= n; cur++) {
		string table_name;
		cin >> table_name;
		int tx, ty;
		scanf("%d%d", &tx, &ty);
		tables[cur].x = tx;
		tables[cur].y = ty;
		for (int i = 1; i <= ty; i++) {
			string st;
			cin >> st;
			tables[cur].biaotous[i] = st;
			tables[cur].cs[st] = vector<string>();
		}
		for (int i = 1; i < tx; i++) {
			for (int j = 1; j <= ty; j++) {
				string st;
				cin >> st;
				tables[cur].cs[tables[cur].biaotous[j]].push_back(st);
			}
		}
		nametoid[table_name] = cur;
	}
	scanf("%d", &m);
	while (m --> 0) {
		string tmpcin, columns, table_name, header;
		cin >> tmpcin >> columns;
		cin >> tmpcin >> table_name;
		cin >> tmpcin >> header;
		int table_id = nametoid[table_name];
		vector<string> veccol = split(columns, ',');
		vector<string> vechead = split(header, '=');
		for (int i = 0; i < tables[table_id].x - 1; i++) {
			if (tables[table_id].cs[vechead[0]][i] == vechead[1]) {
				for (string j : veccol) {
					cout << tables[table_id].cs[j][i] << ' ';
				}
				cout << endl;
			}
		}
	}
	return 0;
}
```

---

## 作者：wangif424 (赞：1)

由于对大模拟的畏惧，打乱了入门赛的开题顺序，从倒开变成了`GHFEDCBAI`的乱开（期间还有一发`python`的`UKE`）。

## 简化题意
- 你有 $n$ 个表格。

- 第 $i$ 个表格存储了 $x_i$ 组每组 $y_i$ 种信息。

- 你需要处理 $m$ 次询问。

- 每次询问形如`select [columns] from [table_name] where [header]=x`，在一个表格中查询`header`种信息为`x`组中的`columns`种信息。

## 分部处理

首先对于 $n$ 个表格，我们使用结构体存储，在用一个`map<string,int>`实现从表格名到下标的映射：

```cpp
struct table{
	int x,y;
	string a[110][20];
}ts[20];
string name;
map<string,int> nam;
```

然后处理操作，~~涉及字符串的大模拟`scanf`有奇效~~，本题在读入操作时难以使用`scanf`分割询问，我们考虑先直接读入至多个字符串，再依托强大的`STL`。

这里介绍一个函数`string::substr(int,int)`，对于一个字符串`str`，我们可以通过调用`str.substr(pos,len)`获取 $[pos,pos+len)$ 的子串，进而将 `[columns]`和`[header]=x`分割开处理。

```cpp
cin >> s;
cin >> column;
cin >> f;
cin >> tn;
cin >> w;
cin >> header;
int pos=header.find('=');
x=header.substr(pos+1,header.size()-pos);
header=header.substr(0,pos);
cnt=0;
for(int i=0;i<column.size();i++){
	if(column[i]==','){
		p[cnt++]=i;
	}
}
p[cnt++]=column.size();
columns[1]=column.substr(0,p[0]);
for(int i=1;i<cnt;i++){
	columns[i+1]=column.substr(p[i-1]+1,p[i]-p[i-1]-1);
}
```

后续的处理中，鉴于本题娇小的数据范围，我们可以直接暴力比较每一组`header`中的信息和`x`，将符合的组的下标加入一个`vector<int>`。

同样，将`[columns]`的要查询的种的下标加入另一个`vector<int>`。

最后遍历两个`vector<int>`输出答案即可。

## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
struct table {
	int x,y;
	string a[110][20];
} ts[20];
string name;
map<string,int> nam;
string s,f,w;
string column,tn,header,x;
string columns[500];
int cnt,p[500];
vector<int> res,tbn;
signed main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin >> name;
		nam[name]=i;
		cin>>ts[i].x>>ts[i].y;
		for(int x=1; x<=ts[i].x; x++) {
			for(int y=1; y<=ts[i].y; y++) {
				cin >> ts[i].a[x][y];
			}
		}
	}
	cin >> m;
	while(m--) {
		cin >> s;
		cin >> column;
		cin >> f;
		cin >> tn;
		cin >> w;
		cin >> header;
		int pos=header.find('=');
		x=header.substr(pos+1,header.size()-pos);
		header=header.substr(0,pos);
		cnt=0;
		for(int i=0; i<column.size(); i++) {
			if(column[i]==',') {
				p[cnt++]=i;
			}
		}
		p[cnt++]=column.size();
		columns[1]=column.substr(0,p[0]);
		for(int i=1; i<cnt; i++) {
			columns[i+1]=column.substr(p[i-1]+1,p[i]-p[i-1]-1);
		}
		int tb=nam[tn];
		tbn.clear();
		for(int j=1; j<=cnt; j++)
			for(int i=1; i<=ts[tb].y; i++) {
				if(ts[tb].a[1][i]==columns[j]) {
					tbn.push_back(i);
					break;
				}
			}
		int tp=1;
		for(int i=1; i<=ts[tb].y; i++) {
			if(ts[tb].a[1][i]==header) {
				tp=i;
				break;
			}
		}
		res.clear();
		for(int i=2; i<=ts[tb].x; i++) {
			if(ts[tb].a[i][tp]==x) {
				res.push_back(i);
			}
		}
		for(auto i:res) {
			for(auto j:tbn) {
				cout << ts[tb].a[i][j] << ' ';
			}
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：maomao233 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10486)

本题的难点在于对 sql 语句的处理。

首先，注意到 sql 语句由六个以空格相邻的字符串组成。于是我们直接输入并存储第 $2,4,6$ 个字符串。令这三个字符串分别为 $co,ta,he$。

其次，我们需要从数据库中找出名为 $ta$ 的二维表。这一步很简单，我们直接遍历 $n$ 个二维表并记录下标即可。

然后，我们处理字符串 $he$。注意到 $he$ 的前半部分和后半部分以等号 `=` 相邻，所以我们直接遍历并判断等号 `=` 即可。然后找到表头名为 $he$ 的前半部分的那一列并记录下标，以便后续查找。

再是处理 $co$。注意到若干个表头以逗号 `,` 相邻，我们直接遍历并判断逗号 `,` 即可。

最后是输出。我们遍历该二维表的所有行，如果该行的那一列满足 $he$，则从那若干个表头中寻找，输出即可。

```cpp
string name[20];
int x[20],y[20];
string head[20][20];
string s[20][110][20];
string mp[1010];
signed main()
{
	int n;
	rd(n);
	for(int i=1;i<=n;i++)
	{
		cin>>name[i],rd(x[i],y[i]);
		for(int j=1;j<=y[i];j++)
		{
			cin>>head[i][j];
		}
		for(int j=2;j<=x[i];j++)
		{
			for(int k=1;k<=y[i];k++)
			{
				cin>>s[i][j][k];
			}
		}
	}
	int m;
	rd(m);
	while(m--)
	{
		string t;
		string co,ta,he;
		cin>>t>>co>>t>>ta>>t>>he;
		int xb=-1;
		for(int i=1;i<=n;i++)
		{
			if(ta==name[i])
			{
				xb=i;
				break;
			}
		}
		string hd="";
		int florr=-1;
		for(int i=0;i<he.size();i++)
		{
			if(he[i]=='=')
			{
				florr=i+1;
				break;
			}
			hd+=he[i];
		}
		string num="";
		for(int i=florr;i<he.size();i++)
		{
			num+=he[i];
		}
		int lie=-1;
		for(int i=1;i<=y[xb];i++)
		{
			if(head[xb][i]==hd)
			{
				lie=i;
				break;
			}
		}
		int cnt=0;
		string ss="";
		for(int i=0;i<co.size();i++)
		{
			if(co[i]==',')
			{
				mp[++cnt]=ss,ss="";
			}
			else
			{
				ss+=co[i];
			}
		}
		mp[++cnt]=ss;
		for(int i=1;i<=x[xb];i++)
		{
			if(s[xb][i][lie]==num)
			{
				for(int j=1;j<=cnt;j++)
				{
					for(int l=1;l<=y[xb];l++)
					{
						if(head[xb][l]==mp[j])
						{
							cout<<s[xb][i][l]<<" ";
						}
					}
				}
				hh;
			}
		}
	}
	return 0;
}
```

---

## 作者：残阳如血 (赞：1)

### $\textbf{Description}$

详见原题面。

总之，题目要求实现一个数据库。

### $\textbf{Solution}$

码量较小的模拟，不觉得应该有黄。

昨天晚上 $7\,\rm min$ 打完了代码，可是发现读入处理挂了，$20:30$ 被强制结束了，没调完qwq。

我太菜了，快来嘲讽我。

---

首先，对于给定的表名，需要快速找到其对应的二维表。

这里我使用了 `std::unordered_map<std::string, Data>`（`Data` 表示二维表，下同）来存储 $\text{key-value}$ 关系，均摊可以 $O(1)$ 查找。

令提一句，`Data`  中我开始想了一下对于不同种类信息如何表示，但是显而易见，`std::string` 可以轻松处理这个问题。

---

至于初始化数据库，直接读入内容数组即可。

---

接下来，需要对

```sql
select [columns] from [table_name] where [header]=x
```

形式的询问进行处理，提取出 `columns`、`table_name`、`header` 和 `x`。

首先开 $3$ 个字符串 `columns`、`table_name` 和 `header`。需要注意，`header` 与 `x` 是以 `=` 连接的，`std::string` 一般无法分开读入，故先将整体以 `header` 读入，然后将其拆分。

此外，`columns` 可能包含对各内容，用 `,` 分隔，所以也需要拆分（就是这里写挂了）。

> PS：写题解的时候，发现好像不用拆分，直接查找子串就行了。但下面的代码就用赛时代码了。

对于 `table_name`，可以直接查到对应的 `Data`。

详见代码。

---

接下来考虑查询。

可以依次枚举 `Data` 中的 `head`，开一个变量 `p` 存储下表头对应的下标。

枚举表内每组信息，如果 `p`  所对应的位置与 `x` 相同，那么这组信息就是需要输出的。

枚举表头，如果其位置是 `columns` 内的内容，那么就输出。当然，这里也可以预处理下标，但似乎没啥用（

### $\textbf{Code}$

```cpp
#include <bits/stdc++.h>

int n, m;

struct Data { // 二维表
  std::vector<std::string> head; // 表头
  std::vector<std::vector<std::string>> qwq; // 内容
  /*
  	另外一种实现：
  		将表头与内容合并成一个二维表，表头横坐标为 0，内容横坐标为 1~x
  */
};

std::unordered_map<std::string, Data> map; 

int main() {
  std::cin.tie(0)->sync_with_stdio(0);
  for (std::cin >> n; n; --n) {
    std::string table_name;
    std::cin >> table_name;
    int x, y;
    std::cin >> x >> y;
    Data t;
    t.head.resize(y); // 表头长度为 y
    t.qwq.resize(x - 1); // 由于整个表共 x 行，去掉表头剩余 x-1 行
    for (auto &str : t.head) std::cin >> str; // 读入表头
    for (auto &qaq : t.qwq) {
      qaq.resize(y); // 重置大小，方便下面读入
      for (auto &ovo : qaq) std::cin >> ovo;
    }
    map.insert({table_name, t}); // 插入表
  }
  for (std::cin >> m; m; --m) {
    std::string str; // 用于读取没用的东西
    std::string columns, table_name, header;
    
    std::cin >> str >> columns >> str >> table_name >> str >> header;
    std::string x = header.substr(header.find('=') + 1); // 截取 '=' 后面的部分
    header = header.substr(0, header.find('=')); // 截取 '=' 前面的部分

    Data t = map[table_name]; // 获取二维表

    int p = 0;
    for (int i = 0; i < t.head.size(); ++i)
      if (t.head[i] == header) { p = i; break; }
    
    std::vector<std::string> split; // 拆分后的数组
    
    size_t last_p = 0; // 上一个逗号的位置的下一位
    size_t tmp_p = columns.find(',', last_p); // 当前的逗号位置
    while (true) {
      if (tmp_p != std::string::npos) {  // 当前仍存在逗号
        split.push_back(columns.substr(last_p, tmp_p - last_p));
        last_p = tmp_p + 1;
        tmp_p = columns.find(',', last_p);
      } else { // 逗号没了，后面是一个整体
        split.push_back(columns.substr(last_p));
        break;
      }
    }

    for (int i = 0; i < t.qwq.size(); ++i) {
      if (t.qwq[i][p] != x) continue;
      for(auto str : split) { // 枚举表头
        for (int j = 0; j < t.head.size(); ++j) {
          if (t.head[j] == str) std::cout << t.qwq[i][j] << ' ';
        }
      }
      std::cout << '\n';
    }
  }
  std::cout.flush();
  return 0;
}
```

---

## 作者：LostKeyToReach (赞：1)

这道题是一道较为简单的大模拟。

我们定义一个结构体来存储每张二维表，其中有表的名称、长、宽、表头、表的信息（可以用二维数组存储），那么输入就变得简单了。同时，我们开两个 map 分别记录表名的位置和每张表的表头位置。

接下来，我们按照题目要求读入一行指令。`name` 可以直接分离，那么我们先遍历这张表的每一行，当这张表的 `header` 值与要求的 `header` 值相对应，那我们只需要输出 `name` 中相应的信息即可。

参考代码如下：

```cpp
#include <iostream>
#include <map>
#include <vector>
using namespace std;
int n;
struct tmp {
	string name;
	int x, y;
	string xiang[13];
	string tb[103][13];
} sql[13];
map <string, int> vis;
map <string, int> vs[13];
int main() {
	ios::sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> sql[i].name;
		vis[sql[i].name] = i;
		cin >> sql[i].x >> sql[i].y;
		for (int j = 1; j <= sql[i].y; j++) {
			cin >> sql[i].xiang[j];
			vs[i][sql[i].xiang[j]] = j;
		}
		for (int j = 2; j <= sql[i].x; j++) {
			for (int k = 1; k <= sql[i].y; k++) {
				cin >> sql[i].tb[j][k];
			}
		}
	}
	vector <string> sss;
	int m;
	cin >> m;
	while (m--) {
		sss.clear();
		string s, select, td, youm, tiaojian;
		cin >> s;
		cin >> select; // 有用 
		cin >> td;
		cin >> youm; // 有用 
		cin >> td;
		cin >> tiaojian; // 有用 
		int id = vis[youm];
		string now = "";
		for (int i = 0; i < (int)select.size(); i++) {
			if (select[i] == ','){
				sss.push_back(now);
				now = "";
			}
			else now += select[i];
		}
		if (now != "") sss.push_back(now);
		string subtj = tiaojian.substr(0, tiaojian.find("="));
		string tj1 = tiaojian.substr(tiaojian.find("=") + 1, (int)tiaojian.size() - 1 - tiaojian.find("="));
		int tag = vs[id][subtj];
		for (int i = 2; i <= sql[id].x; i++) {
			if (sql[id].tb[i][tag] == tj1) {
				for (auto v : sss) {
					cout << sql[id].tb[i][vs[id][v]] << ' ';
				}
				cout << '\n';
			}
		} 
	//	cout << '\n';
	}
}
```

---

## 作者：lilong (赞：1)

还剩半个小时才开始打入门赛，结果最后一题就差几分钟，恼火。

这是一道模拟题，因此我们要仔细梳理题目给的大量信息。通俗地理解，给定若干个表格，每个表格包含一行表头和若干组信息，并且有若干次询问，每次询问指定**一个表格的一个关键字的内容**，寻找该表格中对应关键字内容相同的信息，并输出**另外指定的关键字的内容**。

注意到数据范围很小，因此我们无需考虑任何优化，直接暴力模拟。首先确定所在的是哪个表格，确定表格后再枚举该表格中的信息，寻找与给定关键字内容相同的信息，再输出另外指定的关键字的内容即可。

实现时有许多细节，如输入时字符串需要分割，要输出的关键字可能有多个，也需要处理。具体见代码。

```cpp
#include <bits/stdc++.h>
#define int long long
#define eps 1e-9

using namespace std;

int k,x[11],y[11],m,ans,la,lc;

string s[11][101][11],t[11];
string qa,qb,qc,qd,a;
char q1[1001],q2[1001],q3[1001],q4[1001];

signed main()
{
	cin >> k;
	for( int i = 1 ; i <= k ; i ++ )
	{
		cin >> t[i];
		cin >> x[i] >> y[i];
		for( int xx = 1 ; xx <= x[i] ; xx ++ )
			for( int yy = 1 ; yy <= y[i] ; yy ++ )
				cin >> s[i][xx][yy];	
	}
	int T;
	cin >> T;
	while( T -- )
	{
		cin >> qa;
		cin >> qa;
		cin >> qb;
		cin >> qb;
		cin >> qc;
		cin >> qc;
		lc = qc.size();
		qd = "";
		
		for( int i = 0 ; i < lc ; i ++ )//分割输入的字符串
			if( qc[i] == '=' )
			{
				for( int j = i + 1 ; j < lc ; j ++ )
					qd = qd + qc[j];
				qc.erase( i , lc - i );
			}
		//cout << qa << ' ' << qb << ' ' << qc << ' ' << qd << endl;
		for( int i = 1 ; i <= k ; i ++ )
			if( t[i] == qb )//确定所在的表格
			{
				for( int j = 1 ; j <= y[i] ; j ++ )
					if( s[i][1][j] == qc )//确定要相同的关键字
					{
						for( int l = 2 ; l <= x[i] ; l ++ )
							if( s[i][l][j] == qd )//确定关键字内容相同的信息
							{
								la = qa.size();
								a = "";
								for( int d = 0 ; d < la ; d ++ )//确定要输出的关键字
								{
									if( qa[d] == ',' )
									{
										for( int p = 1 ; p <= y[i] ; p ++ )//确定要输出的关键字的具体位置
											if( s[i][1][p] == a )
											{
												cout << s[i][l][p] << ' ';
												break;
											}
										a = "";
										continue;
									}
									a = a + qa[d];
								}
								for( int p = 1 ; p <= y[i] ; p ++ )
									if( s[i][1][p] == a )
									{
										cout << s[i][l][p] << ' ';
										break;
									}
								cout << endl;
							}
					}
			}
		
	}
	return 0;
}
```

---

## 作者：YuzhenQin (赞：1)

Python 做法。

使用一个字典 `db` 来存储数据表。即：使用 `db['basic_info']` 保存 `basic_info` 表的信息。

使用 `db[table]['head']` 以一个列表的形式保存表头信息（只有插入数据的时候需要用到）。

使用 `db[table]['content']` 保存一个内容为字典的列表，即该表的信息。

查询时直接遍历 `db[table]['content']` 即可。

```python
n = int(input())

db = {}

for i in range(0, n):
    table = input()
    x, y = list(map(int, input().split()))
    x = x - 1
    db[table] = {}
    db[table]['head'] = list(input().split())
    for j in range(0, x):
        content = list(input().split())
        ins = {}
        for k in range(0, y):
            ins[db[table]['head'][k]] = content[k]
        if not 'content' in db[table].keys():
            db[table]['content'] = []
        db[table]['content'].append(ins)

m = int(input())

for i in range(0, m):
    inp = input().split()
    heads, table, head, headc = inp[1].split(','), inp[3], inp[5].split('=')[0], inp[5].split('=')[1]
    for content in db[table]['content']:
        if content[head] == headc:
            for j in heads:
                print(content[j], end=' ')
            print()
```

---

## 作者：2c_s (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P10788)

## 题意简述：

给定 $n$ 张表和表名，再给出表的行数 $x$，列数 $y$，之后给定表头和表中的数据。

给出 $m$ 次操作，每次操作都有一个串，形式是：

```sql
select [columns] from [table_name] where [header]=x
```

意味从名称为 ``table_name`` 的表中选择 ``header`` 列中等于 ``x`` 的这一行，输出这一行的所有 ``columns`` 值。**同一行输出的值可能有多个。**

## 思路

模拟。

我们考虑用一些结构体来存储每张表。结构体中存储的变量如下：

```cpp
struct node{
	int x,y;//表的行和列。
	string s[110][20];//表中的内容。
	unordered_map<string,int>id;//表头对应哪一列。
}a[20];
```

另外，我们还需要开一个 ``map`` 存储表名对应的表的编号。

### 1. 读入

读入时要把表名对应的表号存起来方便之后访问 ``table_name``。表的行数可以 $-1$，这样在遍历的时候就不用从 $2$ 开始了。同时还要存起来表头对应的列号，方便查找 ``header``。

```cpp
cin>>n;
for(int i=1;i<=n;++i){
	string s=reads();
	mp[s]=i;//把表名对应的编号存起来。
	a[i].x=read()-1,a[i].y=read();
	for(int j=1;j<=a[i].y;++j){
		string s=reads();
		a[i].id[s]=j;//存起来每个表头对应的列号。
	}
	for(int x=1;x<=a[i].x;++x){
        for(int y=1;y<=a[i].y;++y)a[i].s[x][y]=reads();
    }
}
```

字符串读入可以用下面的函数。

```cpp
string reads(){
	string s;char c=getchar();
	while(c==' '||c=='\n'||c=='\r')c=getchar();
	while(c!=' '&&c!='\n'&&c!='\r')s+=c,c=getchar();
	return s;
}
```

### 2. 操作读入及预处理

注意 ``columns`` 可能为**多个值**，所以要把它切成很多个短字符串查询。另外，``[header]=x`` 之间**没有空格**，所以也要手动切成两个字符串。可以把从 ``map`` 中访问到的值保存在一个变量中，这样时间复杂度可以少一个 $\log n$。操作中的 ``select from where`` 没有任何实际用处，可以存在一个没用的变量中跳过。 

把 ``columns`` 切成短字符串的函数：

```cpp
void changecol(string s){
	int len=s.size();
	cnt=1;//重新从 1 开始记。
	for(int i=0;i<len;++i){
		if(s[i]==',')++cnt;//逗号说明进入下一个串。
		else col[cnt]+=s[i];
	}
	return ;
}
```

主函数内：

```cpp
string not_used=reads();//上文提到的没用的变量。
string columns=reads();
changecol(columns);//切 columns。

not_used=reads();
string table_name=reads();//读入 table_name。

not_used=reads();
string head=reads();//读入 header 和 x 并切成两个字符串。
string header=head.substr(0,head.find('='));
string x=head.substr(head.find('=')+1);

int table_id=mp[table_name];//哪张表。
int head_id=a[table_id].id[header];//查询哪一列。
vector<int>col_id;//用来保存输出哪一列。
for(int i=1;i<=cnt;++i)col_id.pb(a[table_id].id[col[i]]);
```

### 3. 查询和输出

从上到下遍历整张表，如果在某行对应列的值等于目标值，那么输出之前保存过的这行每一个输出列的内容。

**有多组查询，记得清空每个小 ``column`` 值。**

```cpp
for(int i=1;i<=a[table_id].x;++i){
    if(a[table_id].s[i][head_id]==x){
		for(int j:col_id)cout<<a[table_id].s[i][j]<<' ';
		putchar('\n');//记得输出空格和换行。
	}
}
for(int i=1;i<=cnt;++i)col[i]="";//清空。
```

## 完整无注释代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
using namespace std;
inline ll read(){
	ll k=0;bool flag=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')flag^=1;c=getchar();}
	while(c>='0'&&c<='9'){k=(k<<1)+(k<<3)+(c^48);c=getchar();}
	if(flag)return k;return -k;
}
string reads(){
	string s;char c=getchar();
	while(c==' '||c=='\n'||c=='\r')c=getchar();
	while(c!=' '&&c!='\n'&&c!='\r'&&c!=EOF)s+=c,c=getchar();
	return s;
}
const int N=20,M=110;
unordered_map<string,int>mp;
int n,m,cnt;
string col[M];
struct node{
	int x,y;
	string s[M][N];
	unordered_map<string,int>id;
}a[N];
void changecol(string s){
	int len=s.size();
	cnt=1;
	for(int i=0;i<len;++i){
		if(s[i]==',')++cnt;
		else col[cnt]+=s[i];
	}
	return ;
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i){
		string s=reads();
		mp[s]=i;
		a[i].x=read()-1,a[i].y=read();
		for(int j=1;j<=a[i].y;++j){
			string s=reads();
			a[i].id[s]=j;
		}
		for(int x=1;x<=a[i].x;++x)for(int y=1;y<=a[i].y;++y)a[i].s[x][y]=reads();
	}
	cin>>m;
	while(m--){
		string not_used=reads();
		string columns=reads();
		changecol(columns);
      
		not_used=reads();
		string table_name=reads();
      
		not_used=reads();
		string head=reads();
		string header=head.substr(0,head.find('='));
		string x=head.substr(head.find('=')+1);
      
		int table_id=mp[table_name];
		int head_id=a[table_id].id[header];
		vector<int>col_id;
		for(int i=1;i<=cnt;++i)col_id.pb(a[table_id].id[col[i]]);
      
		for(int i=1;i<=a[table_id].x;++i){
			if(a[table_id].s[i][head_id]==x){
				for(int j:col_id)cout<<a[table_id].s[i][j]<<' ';
				putchar('\n');
			}
		}
		for(int i=1;i<=cnt;++i)col[i]="";
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/167359104)

---

## 作者：HasNoName (赞：0)

### 思路

模拟就可以了。

用一种能够直接查询到一些元素的数据存储方式。

对每一次询问分别处理，直接在对应表格中有约束的那一列找出所要查找的值，输出对应的其他要查询的值。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
unordered_map<string,unordered_map<string,vector<string> > >c;//使用STL，unordered_map可以做到O(1)查询
string a[N][N],u[N],ans[N][N];//u记录每个columns中的需要查询的表头字符串
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n;
	cin>>n;
	string s;
	for(int i=1;i<=n;i++)
	{
		cin>>s;
		int x,y;
		cin>>x>>y;
		for(int j=1;j<=y;j++)cin>>a[i][j];//输入表头
		for(int j=1;j<x;j++)
		{
			for(int k=1;k<=y;k++)
			{
				string t;
				cin>>t;
				c[s][a[i][k]].push_back(t);//将第i个表格的第k列表头下加入一个元素t
			}
		}
	}
	int T;
	cin>>T;
	while(T--)
	{
		string tmp,p,name,w,id="",na="";//不需要的东西用tmp存下
		cin>>tmp>>p;
		cin>>tmp>>name;
		cin>>tmp>>w;
		int m=1,len=p.size();//m为columns中的个数
		for(int i=0;i<len;i++)
		{
			if(p[i]==',')m++;
			else u[m]+=p[i];
		}
		len=w.size();
		bool flag=0;
		for(int i=0;i<len;i++)//若约束条件为x=y，用id表示x，na表示y
		{
			if(w[i]=='=')
			{
				flag=1;
				continue;
			}
			if(flag)na+=w[i];
			else id+=w[i];
		}
		int idx=0;//记录答案组数，即满足条件的表的行数
		int llen=c[name][id].size();//vector中得到项数的东西
		for(int j=0;j<llen;j++)
		{
			if(c[name][id][j]==na)
			{
				idx++;
				for(int k=1;k<=m;k++)
					ans[idx][k]=c[name][u[k]][j];//统计答案
			}
		}
		for(int i=1;i<=m;i++)u[i]="";//清空数组
		for(int i=1;i<=idx;i++)
		{
			for(int j=1;j<=m;j++)
				cout<<ans[i][j]<<' ';//输出答案
			cout<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：mxdyzmx (赞：0)

## 审题
观察题目，发现程序可以分为2部分
- 建表
- 查询

## 建表


为了方便实现，我们可以通过结构体来储存一张表
```
struct Node
{
	map<string, int> m; // 将表头映射至数字
	vector<string> val[12]; // 存储数据 
	int cnt = 0, x; // cnt用于映射，x记录存表时输入的x
};
```

存表比较简单，直接上代码
```cpp
void inst() {
    Node* form = new Node;
    string name, head, val;
    cin >> name;
    int x, y;
    scanf("%d%d", &x, &y);
    form->x = x - 1; //共有x-1条数据
    for (int i = 1; i <= y; i++) {
        cin >> head;
        form->m[head] = i;
     	// 将表头head映射到i
    }

    for (int i = 1; i < x; i++) {
        for (int j = 1; j <= y; j++) {
            cin >> val;
            // 映射、输入的时候是按顺序的
            form->val[j].push_back(val);
        }
    }
    sql[name] = form; // 存起来
}
```

为方便读取，直接开一个
```cpp 
map<string,Node*> sql
```
来存表，由于最多10张表，所以不会爆。

## 查询
### 输入
由于有空格分开，直接这样读取：
```cpp
cin >> col >> col >> table >> table >> hdx >> hdx;
```
### 分离hdx
由于 `hdx` 是形如 `head=x` 的，所以需要将 `head` 与 `x` 分离，由于 `hdx` 中只会出现一次 `=` ，所以只需要找等于然后用 `substr` 分离即可，代码实现如下：
```cpp
int j = 0;
while (hdx[j] != '=') j++;
string x = hdx.substr(j + 1, hdx.size() - j);
hdx = hdx.substr(0, j);
```
### 分离查询内容
同样，需要查询的内容可能会有多项，每项是由 `,` 来分离的，所以使用分离 `hdx` 的方法分离需要查询的每一项，开一个 `vector<int>` 记录分离后的每一项所映射的值，实现如下：
```cpp
int lst = -1;
for (j = 0; j < col.size(); j++) {
    if (col[j] != ',') continue;
    ask.push_back(sql[table]->m[col.substr(lst + 1, j - lst - 1)]);
    lst = j;
}
string temp = col.substr(lst + 1, col.size() - lst - 1).c_str();
ask.push_back(sql[table]->m[temp]);
```

### 输出
最后，遍历查询的表暴力判断输出即可
```cpp
for (j = 0; j < sql[table]->x; j++) {
    if (sql[table]->val[sql[table]->m[hdx]][j] != x) continue;
    for (int k : ask) printf("%s ", sql[table]->val[k][j].c_str());
    puts("");
}
```

## AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node
{
    map<string, int> m;
    vector<string> val[12];
    int cnt = 0, x;
};

map<string, Node*> sql;
vector<int> ask;

void inst() {
    Node* form = new Node;
    string name, head, val;
    cin >> name;
    int x, y;
    scanf("%d%d", &x, &y);
    form->x = x - 1;
    for (int i = 1; i <= y; i++) {
        cin >> head;
        form->m[head] = i;
    }

    for (int i = 1; i < x; i++) {
        for (int j = 1; j <= y; j++) {
            cin >> val;
            form->val[j].push_back(val);
        }
    }
    sql[name] = form;
}

int main() {
    int n, q;
    cin >> n;
    for (int i = 1; i <= n; i++) inst();
    cin >> q;
    for (int i = 1; i <= q; i++) {
        ask.clear();
        string col, table, hdx;
        cin >> col >> col >> table >> table >> hdx >> hdx;
        int j = 0;
        while (hdx[j] != '=') j++;
        string x = hdx.substr(j + 1, hdx.size() - j);
        hdx = hdx.substr(0, j);

        int lst = -1;
        for (j = 0; j < col.size(); j++) {
            if (col[j] != ',') continue;
            ask.push_back(sql[table]->m[col.substr(lst + 1, j - lst - 1)]);
            lst = j;
        }
        string temp = col.substr(lst + 1, col.size() - lst - 1).c_str();
        ask.push_back(sql[table]->m[temp]);
        for (j = 0; j < sql[table]->x; j++) {
            if (sql[table]->val[sql[table]->m[hdx]][j] != x) continue;
            for (int k : ask) printf("%s ", sql[table]->val[k][j].c_str());
            puts("");
        }
    }
    return 0;
}
```
提交记录：https://www.luogu.com.cn/record/167372351

---

## 作者：_H17_ (赞：0)

## 题外话

大模拟一遍过，真爽！吸取 2023 CSP-J2 T3 的血史是正确的。

本题目个人认为有些难度。

## 题目分析

### 处理数据库

对于大模拟，我们一般会把各种内容分模块处理。

所以对于数据库，我们用**结构体**来储存。

注：个人认为结构体中开数组比较麻烦，所以使用的都是 STL `vector`。

### 代码

```cpp
struct table{
    int x,y;//行列数
    string name;//表格名字
    vector<string>head;//表头
    vector<vector<string>>th;//表格内容，不包括表头
    map<string,int>head_id;//表头字符串对应的编号
    table(string name="",int x=0,int y=0):name(name),x(x),y(y)/*见附录 1*/{//构造函数
        head=vector<string>(y+1,"");
        th=vector<vector<string>>(x,vector<string>(y+1,""));//见附录 2
    }
    void read(){
        for(int i=1;i<=y;i++){
            cin>>head[i];
            head_id[head[i]]=i;
            //cerr<<head_id["name"]<<'\n';
		}
		getchar();
        for(int i=1;i<x;i++){
            for(int j=1;j<=y;j++)
                cin>>th[i][j];
            getchar();
		}//在已知大小、名字之后的读入
    }
}t[11];
```

### 处理输入（非查询）

```cpp
cin>>n;
getchar();
for(int i=1;i<=n;i++){
	cin>>tablename>>x>>y;
	name_id[tablename]=i;//记录表头对应编号
	getchar();
	t[i]=table(tablename,x,y);//初始化
	t[i].read();//读入剩余部分
}
```

### 处理查询

采用 `string.substr(begin,size)` 获取从 `begin` 开始，长度为 `size` 的字符串。

采用 `string.find(find_thing,pos=0)` 来从 `pos` 开始找 `find_thing`。如果没有找到返回 `string.npos`。

通过上述工具分割并处理。

### 代码

```cpp

void query(){
	string command,select,from,where,trsh,wherehead,whereval;
	getline(cin,command);//整行读入
	istringstream ss(command);//附录 3
	vector<string>selectitem;
	ss>>trsh;//trashing
	ss>>select;
	ss>>trsh;//trashing
	ss>>from;
	ss>>trsh;//trashing
	ss>>where;//分割字符串
	//cerr<<name_id[from]; 
	table&get=t[name_id[from]];
	//fake::substr(b,e-1)=substr(b,e-b)
	int whereequal=where.find('=');
	wherehead=where.substr(0,whereequal),
	whereval=where.substr(whereequal+1,where.size()-whereequal-1);//进一步分割
	for(int i=0,j;i<select.size();){
		j=select.find(",",i);
		selectitem.push_back(select.substr(i,j-i));
		i=j+1;
		if(j==select.npos)
			break;
	}//进一步分割
	/*for(auto p:selectitem)
		cerr<<p<<t[name_id[from]].head_id[wherehead]<<'\n';*/
	for(int i=1;i<x;i++){
		//cerr<< get.head_id[wherehead]<<'\n';
		if(get.th[i][get.head_id[wherehead]]!=whereval)//跳过不存在的行
			//cerr<<"done\n";
			continue;
		//cerr<<"Sus"<<i<<'\n';
		for(auto p:selectitem)
			cout<<get.th[i][get.head_id[p]]<<' ';
		cout<<'\n';
	}
	return;
}
```

## 代码实现

注释不给了，代码中非中文注释都是作者用来调试、告诉自己用的。

对于所有 `getchar()` 详见附录 $4$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,y;
string tablename;
map<string,int>name_id;
struct table{
    int x,y;
    string name;
    vector<string>head;
    vector<vector<string>>th;
    map<string,int>head_id;
    table(string name="",int x=0,int y=0):name(name),x(x),y(y){
        head=vector<string>(y+1,"");
        th=vector<vector<string>>(x,vector<string>(y+1,""));
    }
    void read(){
        for(int i=1;i<=y;i++){
            cin>>head[i];
            head_id[head[i]]=i;
            //cerr<<head_id["name"]<<'\n';
		}
		getchar();
        for(int i=1;i<x;i++){
            for(int j=1;j<=y;j++)
                cin>>th[i][j];
            getchar();
		}
    }
}t[11];
void query(){
	string command,select,from,where,trsh,wherehead,whereval;
	getline(cin,command);
	istringstream ss(command);
	vector<string>selectitem;
	ss>>trsh;//trashing
	ss>>select;
	ss>>trsh;//trashing
	ss>>from;
	ss>>trsh;//trashing
	ss>>where;
	//cerr<<name_id[from]; 
	table&get=t[name_id[from]];
	//fake::substr(b,e-1)=substr(b,e-b)
	int whereequal=where.find('=');
	wherehead=where.substr(0,whereequal),
	whereval=where.substr(whereequal+1,where.size()-whereequal-1);
	for(int i=0,j;i<select.size();){
		j=select.find(",",i);
		selectitem.push_back(select.substr(i,j-i));
		i=j+1;
		if(j==select.npos)
			break;
	}
	/*for(auto p:selectitem)
		cerr<<p<<t[name_id[from]].head_id[wherehead]<<'\n';*/
	for(int i=1;i<x;i++){
		//cerr<< get.head_id[wherehead]<<'\n';
		get.th[i][get.head_id[wherehead]];
		if(get.th[i][get.head_id[wherehead]]!=whereval)
			//cerr<<"done\n";
			continue;
		//cerr<<"Sus"<<i<<'\n';
		for(auto p:selectitem)
			cout<<get.th[i][get.head_id[p]]<<' ';
		cout<<'\n';
	}
	return;
}
int main(){
    cin>>n;
    getchar();
    for(int i=1;i<=n;i++){
        cin>>tablename>>x>>y;
    	name_id[tablename]=i;
        getchar();
        t[i]=table(tablename,x,y);
        t[i].read();
    }
    //cerr<<"begin query\n";
    cin>>m;
    for(getchar();m;--m)
    	query();
    return 0;
}
```

## 附录

### 附录 $1$

`type func_name(type a=b){}` 表示 `a` 默认是 `b`。

如果结构体中有变量 `a,b,c`，构造函数参数是 `(int x,int y,int z)` 那么后面加上 `:a(x),b(y),c(z)` 和大括号里面写 `a=x,b=y,c=z` 是一样的。

### 附录 $2$

`vector` 的初始化方式：

- `vector<int>` 不初始化；

- `vector<int>(length)` 把当前 `vector` 初始化长度为 `length`；

- `vector<int>(length,val)` 在上一条的基础上把每个元素初始化为 `val`。

### 附录 $3$

`stringstream` 是一个类似 `iostream` 的流。

可以通过 `stringstream ss;` 定义，如果是 `stringstream ss(s);` 表示其初始内容为 `s`。

可以通过 `ss>>a` 来读入，同时 `ss` 删除这部分。

通过 `ss<<a` 来输出 `a` 到 `ss` 中。

在前面加上 `i,o` 可以限定为只输入、只输出。

### 附录 $4$

由于使用了 `getline(cin,s)` 来整行读入。我们需要保证缓存区没有多余的换行符。

由于 `cin` 会跳过换行符，所以每次读到换行符后加入 `getchar()` 来清除。

---

## 作者：LG086 (赞：0)

### 分析

大模拟。

按照题意，先存储 $n$ 个表格。  
我选择~~朴素~~的方法，使用一个 6 维数组 $biao$。  
第一维存表格编号 $cn\_i$，第二第三维存表格的长 $x$ 和宽 $y$。  
而 $biao_{cn\_i,0,0,i,j,0}$ 代表第 $cn\_i$ 个表格上第 $i$ 行 $j$ 列上的信息。  
最后一维存表格名。

对于 $m$ 次询问，注意 `columns` 一栏，分出 $top$ 个表头。  
输出比较容易。  
在 $top$ 个表头中按输入的顺序进行查找并输出，不忘换行。

------------
### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
using namespace std;
int n,m,x,y;
string biao[20][5][5][110][20][5];
string s1,s2,com[20],tab,hed,xx;
signed main(){//献上屎山代码
    cin>>n;
    for(int cn_i = 1;cn_i <= n;cn_i ++){
        cin>>biao[cn_i][0][0][0][0][1];
        cin>>x>>y;
        biao[cn_i][1][0][0][0][0]=to_string(x);
        biao[cn_i][0][1][0][0][0]=to_string(y);
        for(int ci = 1;ci <= y;ci ++)
        cin>>biao[cn_i][0][0][1][ci][0];
        for(int ci = 2;ci <= x;ci ++)
        for(int cj = 1;cj <= y;cj ++)
        cin>>biao[cn_i][0][0][ci][cj][0];
    }
    cin>>m;
    while(m--){
        cin>>s1>>s2;int head=0,top=1;
        for(int i = 0;i < s2.size();i ++)
        if(s2[i]==',')
        com[top++]=s2.substr(head,i-head),head=i+1;
        com[top]=s2.substr(head,s2.size()-head);
        cin>>s1>>tab>>s1>>s2;head=0;
        for(int i = 0;i < s2.size();i ++)
        if(s2[i]=='=')
        hed=s2.substr(head,i-head),head=i+1;
        xx=s2.substr(head,s2.size()-head);
        int cn_i=1,res=1;
        for(int i = 1;i <= n;i ++)
        if(biao[i][0][0][0][0][1]==tab)
        cn_i=i;
        x=stoi(biao[cn_i][1][0][0][0][0]);
        y=stoi(biao[cn_i][0][1][0][0][0]);
        for(int ci = 1;ci <= y;ci ++)
        if(biao[cn_i][0][0][1][ci][0]==hed)
        res=ci;
        for(int j = 2;j <= x;j ++){
            int i = 1,flag = 0;
            while(i <= top)
            for(int ci = 1;ci <= y;ci ++)
                if(biao[cn_i][0][0][1][ci][0]==com[i]){
                    if(biao[cn_i][0][0][j][res][0]==xx)
                        cout<<biao[cn_i][0][0][j][ci][0]<<" ",
                        flag = 1;
                    i ++;
                }
            if(flag)cout<<endl;
        }
    }
    return 0;//完结
}
```

---

## 作者：_qhbd_ (赞：0)

# 题意
给定 $n$ 张 $x_i\times y_i$ 字符串表单（表单第一行是表头）。

共 $m$ 次询问，依次读入 $s,S1,s,S2,s,S3$。$s$ 为无用字符串，$S1$ 为查询表头集合，由多个表头拼接而成，相邻表头隔以逗号，然后 $S2$ 是被查询表单名，$S3$ 由两个字符串隔以等号组成，表示查询表头为首字符串的一列中等于尾字符串的同一行中表头在 $S2$ 中出现过的字符串。

可能有多行满足查询操作，输出所有满足要求的，不同行的字符串间换行，同行空格隔开。
# 思路
用 map 存储表单名对应表单序号，表头在表单中对应列和表单字符串在表单中行，注意一个一个表单中可能有多个字符串，所以同时需要使用 vector 维护。

有个无关做法的建议，把变量名写长点或者命名得更有意义，不然容易写叉。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int x[15],y[15],I,J,L;
string t[15],h[15][15],s[15][105][15],ccc,LIST_HEAD_NAME,slc,fr,wh,xxx;
map<string,int>H[15],LIST;
map<string,vector<int>> W[15][15];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		cin>>t[i];
		LIST[t[i]]=i;
		scanf("%d%d",&x[i],&y[i]);
		for(int j=1;j<=y[i];j++)cin>>h[i][j],H[i][h[i][j]]=j;
		for(int j=2;j<=x[i];j++){
			for(int l=1;l<=y[i];l++){
				cin>>s[i][j][l];
				W[i][l][s[i][j][l]].emplace_back(j);
			}
		}
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		cin>>slc>>slc>>fr>>fr>>wh>>wh;
		xxx=wh.substr(wh.find("=")+1,+wh.size()-wh.find("="));
		wh=wh.substr(0,wh.find("="));
		I=LIST[fr];
		vector<int> J=W[I][H[I][wh]][xxx],L;
		int id=0;
		while(1){
			id=slc.find(",");
			if(id==-1){
				LIST_HEAD_NAME=slc;
				L.emplace_back(H[I][LIST_HEAD_NAME]);
				break;
			}
			else{
				LIST_HEAD_NAME=slc.substr(0,id);
				slc=slc.substr(id+1,slc.size()-id);
				L.emplace_back(H[I][LIST_HEAD_NAME]);
			}
		}
		for(auto j:J){
			for(auto l:L)
				cout<<s[I][j][l]<<" ";
			puts(""); 
		}
	}
}
```

---

## 作者：ダ月 (赞：0)

写写小模拟的题解。

首先飞速扫完题，发现我们需要处理几个东西：表名，表头，数据。类似书本目录，我们依次按照上述顺序查找到某一个元素。

我们依次存储表名（一维数组），在每个表名下存储表头（二维数组），然后在每一个表名下，用一个二维数组存储数据。上述皆以字符串的形式存储。

演示如下：

```
int n;std::cin>>n;
ve<std::string>tabname(n);
ve<ve<std::string>>item(n);
ve<ve<ve<std::string>>>inf(n);
for(int i=0;i<n;i++){
	std::cin>>tabname[i];
	int nt,mt;std::cin>>nt>>mt;
	for(int j=1;j<=mt;j++){
		std::string s;std::cin>>s;
		item[i].pd(s);
	}nt--;
	inf[i].assign(nt,ve<std::string>(mt));
	for(int j=0;j<nt;j++)
		for(int k=0;k<mt;k++)
			std::cin>>inf[i][j][k];
}
```

接下来考虑查询。整个查询可以拆成 `select`，`[columns] `，`from`，`[table_name]`，`where`，`[header]=x` 的形式。

- 其中 `select`，`from`，`where` 是多余成分，我们直接忽视即可。
- 对于分离 `[column]` 部分，我们考虑用一个关于 `std::string` 动态数组来维护。初始，我们往动态数组弹入一个空字符串。每当弹入非 `,` 的字符时，我们提取动态数组最后一个字符串，让字符串后再加入一个元素。具体地，若动态数组名字为 `v`，弹入字符为 `c`，我们执行 `v.back.push_back(c)`。对于弹入字符为 `,` 时，我们直接在动态数组末尾加入一个空字符串即可。
- 对于 `[table_name]`，这个不需要处理，拿来即用。
- 对于 `[header]=x`，我们以 `=` 为分解线，拆出 `[header]` 与 `x` 即可。

我们完成分离。

接下来开始查表。我提一个建议，就是查找到多维数组每个位置时，建议依次记录，即当查到下标时，该 `break` 就 `break` 掉。然后查下一维下标时，再另起一个循环查找。反着说就是，不要嵌套太多循环，否则会让你的模拟写得极其邪恶。

完整代码如下：

```
void solve(){
	//don't forget to open long long
	//ve 就是 std::vector
	//pd 就是 push_back
	int n;std::cin>>n;
	ve<std::string>tabname(n);
	ve<ve<std::string>>item(n);
	ve<ve<ve<std::string>>>inf(n);
	for(int i=0;i<n;i++){
		std::cin>>tabname[i];
		int nt,mt;std::cin>>nt>>mt;
		for(int j=1;j<=mt;j++){
			std::string s;std::cin>>s;
			item[i].pd(s);
		}nt--;
		inf[i].assign(nt,ve<std::string>(mt));
		for(int j=0;j<nt;j++)
			for(int k=0;k<mt;k++)
				std::cin>>inf[i][j][k];
	}
	int q;std::cin>>q;
	while(q--){
		int ptab=0,pinf=0;
		std::string dirt,tabn,ite,infr,data;
		std::cin>>dirt>>ite>>dirt>>tabn>>dirt>>infr;
		ve<std::string>ith;ith.pd("");
		for(int i=0;i<ite.size();i++){
			if(ite[i]==',')ith.pd("");
			else ith.back().pd(ite[i]);
		}
		while(infr.back()!='=')
			data.pd(infr.back()),infr.pop_back();//这里 data 还是反着的。
		infr.pop_back();reverse(all(data));
		for(int i=0;i<n;i++)
			if(tabn==tabname[i]){
				ptab=i;
				break;
			}
		for(int i=0;i<item[ptab].size();i++)
			if(infr==item[ptab][i]){
				pinf=i;
				break;
			}
		ve<std::string>ans;
		ve<int>pite;
		for(int i=0;i<ith.size();i++)
			for(int j=0;j<item[ptab].size();j++){
				if(ith[i]==item[ptab][j]){
					pite.pd(j);
					break;
				}
			}
		for(int i=0;i<inf[ptab].size();i++)
			if(inf[ptab][i][pinf]==data){
				std::string ANS;
				for(auto &p:pite)
					ANS+=inf[ptab][i][p]+" ";
				if(!ANS.empty())ANS.pop_back();
				ans.pd(ANS);
			}
		for(auto &p:ans)
			std::cout<<p<<'\n';
	}
}
```

---

## 作者：yszkddzyh (赞：0)

题目没有思维难度，考验代码能力。

对于存储表格，定义一个三维字符串数组，第一维是表格的编号，第二维、第三维分别是该表的行号和列号。具体见代码，注释很详细。

当然，这类题的写法一般很多，代码只做参考。

另外建议大家写大模拟时，将变量名称定义得清楚明白一些，便于调试，还可以防止忘记变量的含义。

```cpp
/* 赛时代码 */ 
#include <bits/stdc++.h>
using namespace std;

string a[15][105][15], name[15], col[15], table_name, columns, header;
//a为表格，如上所述；name[id]是编号为id的表格的名字；col[id]的意义见下
//table_name,columns,header都是select语句中的，意义见体题面 
int n, m, nn[15], mm[15], col_id[15];
//n,m意义与题面所述相同，nn[id]是编号为id的表格的行数，mm[id]是编号为id的表格的列数，col_id含义见下 

int main(){
	
	cin >> n;//输入字符串时，本人习惯用cin 
	for(int i = 1; i <= n; i++){
		cin >> name[i] >> nn[i] >> mm[i];
		for(int j = 1; j <= nn[i]; j++)
			for(int k = 1; k <= mm[i]; k++)
				cin >> a[i][j][k];
	}//依题意输入表格 
	cin >> m;
	string s;
	while(m--){
		//由于select语句中总有五个空格，因此可以输入六个字符串简化代码 
		//字符串s的作用是占位，即将"select""from""where"输入，而这三个字符串是对我们没用的，因此可以只用一个字符串 
		cin >> s;
		cin >> columns;
		cin >> s;
		cin >> table_name;
		cin >> s;
		cin >> header;
		int table_id;
		//table_id是名字为table_name的表格的编号 
		for(int i = 1; i <= n; i++)
			if(name[i] == table_name){
				table_id = i;
				break;
			}
		//以上循环是找到名字与table_name相同的表格，求出table_id 
		int p = 0;
		//p记录的是header中'='的位置 
		for(p = 0; p < header.size(); p++)
			if(header[p] == '=')
				break;//求出p 
		string header_front = header.substr(0, p);
		string header_back = header.substr(p + 1, header.size() - p - 1);
		//header_front是字符串header中'='前面的部分，header_back是字符串中'='后面的部分 
		int header_id;
		//header_id是该表格中表头为header的列的编号 
		for(int i = 1; i <= mm[table_id]; i++)
			if(a[table_id][1][i] == header_front){//表头一定在该表的第一行，因此可以用a[table_id][1][i]表示该表第i列的表头 
				header_id = i;
				break;
			}
		//以上循环是求出header_id 
		//由题意：columns可能有很多个字符串，中间用','隔开，下面的循环就是求出columns中所有的字符串，并将其存至col数组中 
		int tot = 0; 
		//tot记录的是当前col串的数量，即当前columns中的串的数量 
		string tmp = "";
		//tmp记录的是当前的col串 
		for(int i = 0; i < columns.size(); i++){
			if(columns[i] == ',')//每找到一个','就将tmp加入col数组并将tmp清空 
				col[++tot] = tmp, tmp = "";
			else tmp += columns[i];//不是逗号就不断更新tmp 
		}
		col[++tot] = tmp;
		//由于最后一个逗号后面还有一个col串，而它后面没有逗号了，所以它还没有被加入col数组，所以这里要多加一次 
		//下面的循环是找出每个col串的编号 
		for(int i = 1; i <= tot; i++)
			for(int j = 1; j <= mm[table_id]; j++)
				if(a[table_id][1][j] == col[i]){
					col_id[i] = j;
					break;
				}
		//下面的循环就是输出了，利用先前求出的变量可以很方便的求出 
		for(int i = 2; i <= nn[table_id]; i++){
			if(a[table_id][i][header_id] == header_back){
				for(int j = 1; j <= tot; j++){
					cout << a[table_id][i][col_id[j]] << ' ';
				}
				cout << endl;
			}
		}
	}
	
	return 0;
}

```

---

## 作者：nightwatch.ryan (赞：0)

### 思路
这是一道大模拟，接下来我们对着代码讲解。

```cpp
struct Table{
	std::string name;
	int x;
	int y;
	std::string p[N];
	std::string a[M][N];
};
Table tab[15];
int table_cnt;
```

首先建一个表的结构体，包含表的名字，表有几行几列，表头元素和表的内容。

定义一个大小为 $15$ 的结构体数组 $tab$，并且用 $table_{cnt}$ 作为这个结构体数组的下标。

```cpp
int n=rd;
while(n--){
	std::string z;
	std::cin>>z;
	int x=rd,y=rd;
	table_cnt++;
	tab[table_cnt].x=x;
	tab[table_cnt].y=y;
	tab[table_cnt].name=z;
	for(int i=1;i<=y;i++){
		std::cin>>tab[table_cnt].p[i];
	}
	for(int i=1;i<=x-1;i++){
		for(int j=1;j<=y;j++){
			std::cin>>tab[table_cnt].a[i][j];
		}
	}
}
```

构建这 $n$ 个表。

```cpp
std::string col,table_name,header;
std::cin>>col>>col;
std::cin>>table_name>>table_name;
std::cin>>header>>header;
int tabID=0;
for(int i=1;i<=table_cnt;i++){
	if(tab[i].name==table_name){
		tabID=i;
		break;
	}
}
```

找出当前查询的是第几个表。

```cpp
std::string set[M];
int idx=0;
std::string tmp;
for(int i=0;i<col.size();i++){
	if(col[i]==','){
		set[++idx]=tmp;
		tmp="";
	}else{
		tmp+=col[i];
	}
}
if(tmp.size())set[++idx]=tmp,tmp="";
```

将 $columns$ 字符串分割成若干个表头。

```cpp
std::string st,tarv;
int ps=0;
for(int i=0;i<header.size();i++){
	if(header[i]=='='){
		ps=i+1;
		break;
	}else{
		st+=header[i];
	}
}
tarv=header.substr(ps);
```

分割表头和给出的条件。

```cpp
std::vector<int>line;
int stp=0;
for(int i=1;i<=tab[tabID].y;i++){
	if(tab[tabID].p[i]==st){
		stp=i;
		break;
	}
} 
```

寻找给定的条件在表的第几列。

```cpp
for(int i=1;i<=tab[tabID].x-1;i++)
	if(tab[tabID].a[i][stp]==tarv)
		line.push_back(i);
```

寻找符合条件的行数。

```cpp
for(int i=0;i<line.size();i++){
	for(int j=1;j<=idx;j++)
		for(int k=1;k<=tab[tabID].y;k++)
			if(tab[tabID].p[k]==set[j])
				std::cout<<tab[tabID].a[line[i]][k]<<" ";
	if(i!=line.size()-1)std::cout<<std::endl;
}
puts("");
```

输出答案。**注意每次查询结束后不能输出多余换行，你需要特判一下**。
### 代码
```cpp
#include<iostream>
#include<vector>
#define N 15
#define M 105
struct Table{
	std::string name;
	int x;
	int y;
	std::string p[N];
	std::string a[M][N];
};
Table tab[15];
int table_cnt;
int read(){
 int x=0,t=1;char ch=getchar();
 while(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}
 while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
 return x*t;
}
#define rd read()
signed main(){
	int n=rd;
	while(n--){
		std::string z;
		std::cin>>z;
		int x=rd,y=rd;
		table_cnt++;
		tab[table_cnt].x=x;
		tab[table_cnt].y=y;
		tab[table_cnt].name=z;
		for(int i=1;i<=y;i++){
			std::cin>>tab[table_cnt].p[i];
		}
		for(int i=1;i<=x-1;i++){
			for(int j=1;j<=y;j++){
				std::cin>>tab[table_cnt].a[i][j];
			}
		}
	}
	int q=rd;
	while(q--){
		std::string col,table_name,header;
		std::cin>>col>>col;
		std::cin>>table_name>>table_name;
		std::cin>>header>>header;
		int tabID=0;
		for(int i=1;i<=table_cnt;i++){
			if(tab[i].name==table_name){
				tabID=i;
				break;
			}
		}
		std::string set[M];
		int idx=0;
		std::string tmp;
		for(int i=0;i<col.size();i++){
			if(col[i]==','){
				set[++idx]=tmp;
				tmp="";
			}else{
				tmp+=col[i];
			}
		}
		if(tmp.size())set[++idx]=tmp,tmp="";
		std::string st,tarv;
		int ps=0;
		for(int i=0;i<header.size();i++){
			if(header[i]=='='){
				ps=i+1;
				break;
			}else{
				st+=header[i];
			}
		}
		tarv=header.substr(ps);
		std::vector<int>line;
		int stp=0;
		for(int i=1;i<=tab[tabID].y;i++){
			if(tab[tabID].p[i]==st){
				stp=i;
				break;
			}
		} 
		for(int i=1;i<=tab[tabID].x-1;i++)
			if(tab[tabID].a[i][stp]==tarv)
				line.push_back(i);
		for(int i=0;i<line.size();i++){
			for(int j=1;j<=idx;j++)
				for(int k=1;k<=tab[tabID].y;k++)
					if(tab[tabID].p[k]==set[j])
						std::cout<<tab[tabID].a[line[i]][k]<<" ";
			if(i!=line.size()-1)std::cout<<std::endl;
		}
		puts("");
	}
}
```

---


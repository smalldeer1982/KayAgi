# [入门赛 #21] 星云 hard ver.

## 题目背景

本题与 easy ver. 的区别在于本题**有**多组测试数据。

你看，那一抹云，衬着星星，多美啊！

## 题目描述

定义星云数为位数不大于 $n$ 且各数位之和不超过 $k$ 的正整数，给定 $n,k$，求星云数的个数。

## 说明/提示

### 数据规模与约定

对于 $50\%$ 的数据，$1 \leq n \leq 2$。  
对于 $100\%$ 的数据，$1 \leq T \leq 10^5$，$1 \leq n \leq 7$，$1 \leq k \leq 100$。

## 样例 #1

### 输入

```
2
2 1
3 2
```

### 输出

```
2
9
```

# 题解

## 作者：IGA_Indigo (赞：25)

## 题目分析
就是给你 $t$ 次询问，每次询问给你一个 $n$ 和一个 $k$ ，问你位数小于 $n$、位数之和小于 $k$ 的正整数一共有多少个。
## 大体思路
虽然这道题的 $n\le7$ 且 $k\le100$，但是他的查询次数 $t\le10^5$，暴力做法一定会超时，但是聪明的你一定一眼就看出来每一个 $n$ 和 $k$ 的组合方案数一定是一样的，所以我们就想到了用朴素算法打出一个 $7\times100$ 的表的做法。
## 解题方法
这道题的朴素其实很好写，只需要枚举所有位数小于 $n$ 的数字，挨个求出各位数和，与 $k$ 作比较，如果 $\le k$，方案数就 $+1$。

朴素代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,k;
	cin>>n>>k;
	int sum=1;
	int ans=0;
	for(int i=1;i<=n;i++){
		sum*=10;
	}//先求出n的位数，用来求出最大的限制 
	for(int i=1;i<=sum;i++){//枚举出来每一个可能的数字 
		int diao=0;
		int gg=i;
		while(gg){
			diao+=gg%10;
			gg/=10;//求出每一位的和 
		}
		if(diao<=k){
			ans++;
		}//如果小于k就代表可以，方案数++ 
	}
	cout<<ans-1;
    return 0;
}
```
这就是这道题的朴素代码且只能求 $t=1$ 的情况，想让它成为大表哥，就必须对他进行一些改变：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	freopen("biao.out","w",stdout);
	for(int n=1;n<=7;n++){
		for(int k=1;k<=100;k++){
			int sum=1;
			int ans=0;
			for(int i=1;i<=n;i++){
				sum*=10;
			}
			for(int i=1;i<=sum;i++){
				int diao=0;
				int gg=i;
				while(gg){
					diao+=gg%10;
					gg/=10;
				}
				if(diao<=k){
					ans++;
				}
			}
			cout<<ans-1<<",";
		}
	}
    return 0;
}
```
得到初始表之后我们把它折到一个数组中，就做出了表哥。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int b[7][100]={1,2,3,4,5,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,2,5,9,14,20,27,35,44,54,63,71,78,84,89,93,96,98,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,3,9,19,34,55,83,119,164,219,282,351,424,499,574,647,716,779,834,879,915,943,964,979,989,995,998,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,4,14,34,69,125,209,329,494,714,996,1344,1759,2239,2779,3371,4004,4664,5334,5994,6627,7219,7759,8239,8654,9002,9284,9504,9669,9789,9873,9929,9964,9984,9994,9998,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,5,20,55,125,251,461,791,1286,2001,2997,4337,6082,8287,10997,14243,18038,22373,27213,32493,38124,43999,49999,55999,61874,67505,72785,77625,81960,85755,89001,91711,93916,95661,97001,97997,98712,99207,99537,99747,99873,99943,99978,99993,99998,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,6,27,83,209,461,923,1715,3002,5004,8001,12333,18395,26627,37499,51491,69068,90650,116577,147069,182196,221858,265775,313487,364364,417626,472373,527625,582372,635634,686511,734223,778140,817802,852929,883421,909348,930930,948507,962499,973371,981603,987665,991997,994994,996996,998283,999075,999537,999789,999915,999971,999992,999998,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,7,35,119,329,791,1715,3431,6434,11439,19440,31767,50135,76679,113969,164999,233144,322079,435654,577719,751914,961439,1208819,1495679,1822544,2188679,2591984,3028959,3494754,3983319,4487634,4999999,5512364,6016679,6505244,6971039,7408014,7811319,8177454,8504319,8791179,9038559,9248084,9422279,9564344,9677919,9766854,9834999,9886029,9923319,9949863,9968231,9980558,9988559,9993564,9996567,9998283,9999207,9999669,9999879,9999963,9999991,9999998,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999};
int main(){
	int t;
	cin>>t;
	for(int i=1;i<=t;i++){
		int n,m;
		cin>>n>>m;
		cout<<b[n-1][m-1]<<endl;
	}
    return 0;
}
```
## THE END!

---

## 作者：Li_Feiy (赞：5)

#### 题意简述

给定 $n,k$，求在 $n$ 位数内，各数位之和不超过 $k$ 的正整数的个数。

---

#### 题目分析

一道很水的数位 DP。

因为 hard ver. 添加了多测，所以暴力是肯定做不了的，这个时候我们升级一下算法，改用使用记忆化搜索的数位 DP 即可（不懂的详见[此处](https://oi-wiki.org/dp/number/)）。

站在数位 DP 的角度来看，这道题可以说是很水了。

首先，因为求的是 $n$ 位以下的数，所以不需要判断上限。

其次，本题要求的数字要求很简单，只需要记录各数位之和，所以不需要判断前导 0。

本题唯一需要注意的点就是要求的数是正整数，所以在填完数位的时候判断一下是不是 0 即可。

---

#### AC Code

```cpp
#include<bits/stdc++.h>
#define arrout(a,n) rep(i,1,n)std::cout<<a[i]<<" "
#define arrin(a,n) rep(i,1,n)std::cin>>a[i]
#define rep(i,x,n) for(int i=x;i<=n;i++)
#define dep(i,x,n) for(int i=x;i>=n;i--)
#define erg(i,x) for(int i=head[x];i;i=e[i].nex)
#define dbg(x) std::cout<<#x<<":"<<x<<" "
#define mem(a,x) memset(a,x,sizeof a)
#define all(x) x.begin(),x.end()
#define arrall(a,n) a+1,a+1+n
#define PII std::pair<int,int>
#define m_p std::make_pair
#define u_b upper_bound
#define l_b lower_bound
#define p_b push_back
#define CD const double
#define CI const int
#define int long long
#define il inline
#define ss second
#define ff first
#define itn int
int dp[105][105],ans;
int T,n,k,a[15];
int dfs(int step,int sum) {//当前填到第step位，数位之和为sum
    if(step>n) {
        if(sum==0) {//填的0
            return 0;
        } else {
            return 1;
        }
    }
    if(dp[step][sum]!=-1) {//记忆化
        return dp[step][sum];
    }
    int ans=0;
    rep(i,0,9) {//因为没有上界，所以直接枚举0~9
        if(sum+i>k) {//这一位如果填i超过了k，那就不填
            continue;
        }
        ans+=dfs(step+1,sum+i);//累加答案
    }
    dp[step][sum]=ans;
    return ans;
}
int solve() {
    memset(dp,-1,sizeof dp);
    return dfs(1,0);
}
signed main() {
    std::cin>>T;
    while(T--) {
        std::cin>>n>>k;
        std::cout<<solve()<<"\n";
    }
    return 0;
}
```

---

## 作者：WoodReal12 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P1708)

## 题目思路

我们可以用 DP 来解此题。

### 初步解法

#### 状态表示

我们定义一个三维动态规划数组 $dp[i][j][k]$ 其中：

- $i$ 表示当前考虑的是第几位；

- $j$ 表示当前位置之和；

- $k$ 表示当前是否已经达到了 $n$ 位的限制，为 $0$ 表示没达到，为 $1$ 表示已达到。

#### 转移方程

转移方程也就显而易见了：

- 当 $k$ 为 $0$ 时，
	
    转移方程为：`dp[i][j][0] = dp[i-1][j-l][0] + dp[i-1][j-l][1]` 对所有的 $0 \le l \le 9$ 且 $j-l \ge 0$ 求和。
    
- 当 $k$ 为 $1$ 时，
	
    转移方程为：`dp[i][j][1] = dp[i-1][j-l][1]` 同样对所有的 $0 \le l \le 9$ 且 $j-l \ge 0$ 求和。
    
#### 初始化 
$dp[0][0][0]=1$，表示在没有任何数字选择时，数位之和为 $0$ 的方法只有 $1$ 种。

#### 答案

最后的答案也就为 $\sum_{j=0}^{k}dp[n][j][1]$。

### 优化解法

我们当然也可以将数组优化成二维的。

#### 状态表示
- $i$ 表示已经确定的数字的数量；

- $j$ 表示当前的数位之和。

#### 状态计算

状态计算也就简化为：
`dp[i][j] = sum(dp[i-1][j-l])` 对所有的 $0 \le l \le 9$ 且 $j-l \ge 0$ 求和。

#### 初始化

当然是 $dp[0][0]=1$。

#### 答案

最终答案为 $\sum_{j=0}^{k}dp[n][j]$。

于是这题就解决啦~

## 代码

```cpp
#include <iostream>
#include <cmath> 
using namespace std;
int n,k,T;
long long dp[105][105];
long long ans=0;
int main(){
    cin>>T;
    while(T--){
        for(int i=0;i<=104;i++)
            for(int j=0;j<=104;j++)
                dp[i][j]=0;
        ans=0;
        cin>>n>>k;
	    dp[0][0]=1;
	    for(int i=1;i<=n;i++)
		    for(int j=0;j<=k;j++)
		    	for(int l=0;l<=9;l++)
		    		if(j-l>=0)
		    			dp[i][j]+=dp[i-1][j-l];
     	for(int j=1;j<=k;j++)
	    	ans+=dp[n][j];
	    cout<<ans<<endl;
    }
	
    return 0;
}
```

---

## 作者：wmrqwq (赞：1)

本文同步在 [cnblog](https://www.cnblogs.com/wangmarui/p/18068948) 发布。

# 题目链接

[P1708](https://www.luogu.com.cn/problem/P1708)

# 解题思路

### 解法一：

考虑预处理，这部分可以直接打表。

其他题解这部分讲的比较详细了，在此不再赘述。

期望得分 $100$ 分。

### 解法二：

考虑数位 dp。

这里采用记搜的写法。

`dfs(last,sum,maxsum,_1)` 分别表示还需要枚举几位数，目前枚举的数位和，可以枚举的最大数位和，是否均与最大可以取到的数的数位相同。

期望得分 $100$ 分。

给出解法二的参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define map unordered_map
#define forl(i,a,b) for(register long long i=a;i<=b;i++)
#define forr(i,a,b) for(register long long i=a;i>=b;i--)
#define forll(i,a,b,c) for(register long long i=a;i<=b;i+=c)
#define forrr(i,a,b,c) for(register long long i=a;i>=b;i-=c)
#define lc(x) x<<1
#define rc(x) x<<1|1
#define mid ((l+r)>>1)
#define cin(x) scanf("%lld",&x)
#define cout(x) printf("%lld",x)
#define lowbit(x) x&-x
#define pb push_back
#define pf push_front
#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
#define endl '\n'
#define QwQ return 0;
#define ll long long
#define lcm(x,y) x/__gcd(x,y)*y
#define Sum(x,y) 1ll*(x+y)*(y-x+1)/2
ll t;
ll dp[20][110][110],a[20];
ll dfs(ll last,ll sum,ll maxsum,ll _1)
{
	if(sum>maxsum)
		return 0;
	if(last==0)
		return 1;
	if(dp[last][sum][maxsum]>=0)
		return dp[last][sum][maxsum];
	ll maxn=_1?a[last]:9,ans=0;
	forl(i,0,maxn)
		ans+=dfs(last-1,sum+i,maxsum,_1&&i==maxn);
	dp[last][sum][maxsum]=ans;
	return ans;
}
ll sol(ll n,ll m)
{

	forl(i,1,n)
		a[i]=9;
	return dfs(n,0,m,1);
}
void solve()
{
	ll n,m;
	cin>>n>>m;
	cout<<sol(n,m)-1<<endl;
}
int main()
{
	forl(i,0,19)
		forl(j,0,105)
			forl(k,0,105)
				dp[i][j][k]=-1;
	IOS;
	t=1;
	cin>>t;
	while(t--)
		solve();
	QwQ;
}
```

---

## 作者：tanzexiaodezhonghao (赞：0)

## 思路
看到此题，第一想到可以直接枚举，求一个数的数位之和，然后判断，可以就让方案数加一，代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    int n,k,cnt=0,ans;
    while(t--){
        cin>>n>>k;
        cnt=0;
        for(int i=1;i<pow(10,n);i++){
            ans=0;
            int temp=i;
            while(temp>0){
                ans+=(temp%10);
                temp/=10;
            }
            if(ans<=k) cnt++;
        }
        cout<<cnt<<endl;
    }
    return 0;
}
```
可一测，啊，超时了？仔细一看，发现 $T$ $\le$ $10^5$。做的时候没想出来，后面看了别人的题解才发现可以打表，用一个二维数组，然后我就试了一下。~~温馨提示，不要用在线编译器，不然绝对超时，建议使用DEVC++~~。
## 代码
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a[7][100]={1,2,3,4,5,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,2,5,9,14,20,27,35,44,54,63,71,78,84,89,93,96,98,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,3,9,19,34,55,83,119,164,219,282,351,424,499,574,647,716,779,834,879,915,943,964,979,989,995,998,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,999,4,14,34,69,125,209,329,494,714,996,1344,1759,2239,2779,3371,4004,4664,5334,5994,6627,7219,7759,8239,8654,9002,9284,9504,9669,9789,9873,9929,9964,9984,9994,9998,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,9999,5,20,55,125,251,461,791,1286,2001,2997,4337,6082,8287,10997,14243,18038,22373,27213,32493,38124,43999,49999,55999,61874,67505,72785,77625,81960,85755,89001,91711,93916,95661,97001,97997,98712,99207,99537,99747,99873,99943,99978,99993,99998,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,99999,6,27,83,209,461,923,1715,3002,5004,8001,12333,18395,26627,37499,51491,69068,90650,116577,147069,182196,221858,265775,313487,364364,417626,472373,527625,582372,635634,686511,734223,778140,817802,852929,883421,909348,930930,948507,962499,973371,981603,987665,991997,994994,996996,998283,999075,999537,999789,999915,999971,999992,999998,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,999999,7,35,119,329,791,1715,3431,6434,11439,19440,31767,50135,76679,113969,164999,233144,322079,435654,577719,751914,961439,1208819,1495679,1822544,2188679,2591984,3028959,3494754,3983319,4487634,4999999,5512364,6016679,6505244,6971039,7408014,7811319,8177454,8504319,8791179,9038559,9248084,9422279,9564344,9677919,9766854,9834999,9886029,9923319,9949863,9968231,9980558,9988559,9993564,9996567,9998283,9999207,9999669,9999879,9999963,9999991,9999998,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999,9999999};
	int t;
    cin>>t;
    while(t--){
        int n,k;
        cin>>n>>k;
        cout<<a[n-1][k-1]<<endl;
    }
    return 0;
}
```

---

## 作者：JimmyLee (赞：0)

# 解法

因为 $n\leq 7$，所以可以对于每个 $n$ 进行搜索。

定义 $dp_{i,j}$ 为长度为 $i$，各数位之和为 $j$ 的数的个数。

暴搜处理 dp 数组。

```cpp
void dfs(int n, int sum, int mx)
{
    if(!n) return dp[mx][sum]++, void();
    for(int i=0;i<=9;i++) 
        dfs(n-1, sum+i, mx);
}
```

 然后对每一位进行前缀和处理。

```cpp
for(int i=1;i<8;i++)
    {
        dp[i][0]=0;
        for(int j=1;j<1001;j++)
            dp[i][j]+=dp[i][j-1];
    }
```

最后答案即为 $dp_{n,k}$。

---

## 作者：Chenyichen0420 (赞：0)

# 思路分析

看到数据范围 $7\times 100$ 的情况种数，写暴力程序打个表就能过了。

具体怎么打表？枚举 $1-999999999(10^8-1)$，因为只有 $7$ 位，每一个数按照题目要求的方式存到数组里，最后输出出来就是了（有点怀疑接近正解，但是赛时没敢交）。

程序如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[100][7] = { ... };
int main() {
	int n, m, t;
	cin >> t;
	while(t--)
	cin >> n >> m,
	cout << dp[m - 1][n - 1] << endl;
	return 0;
}
```

打表的话：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int wss,sum,dp[7][100];
signed main() {
	ios::sync_with_stdio(0); 
	cin.tie(0); cout.tie(0);
	freopen("chart.txt","w",stdout);
	for(int i=1;i<100000000;++i){
		wss=sum=-1;
		int ti=i;
		while(ti) wss++,sum+=ti%10,ti/=10;
		for(int j=wss;j<7;++j)
			for(int k=sum;k<100;++k)
				dp[j][k]++;
	}
	cout<<"{";
	for(int i=0;i<7;++i){
		cout<<"{";
		for(int j=0;j<99;++j){
			cout<<dp[i][j]<<",";
		}
		cout<<dp[i][99]<<"},";
	}
	cout<<"}";
	return 0;
}
```

注意两个程序不兼容（考场打表程序用完就删了）。

---


# [蓝桥杯青少年组国赛 2024] 第三题

## 题目描述

因数：也称约数。如果整数 $a$ 除以整数 $b$，商为整数且余数为 $0$，则称 $b$ 是 $a$ 的因数。例如：$1$、$2$、$3$、$6$ 都是 $6$ 的因数。

素数：也称质数，是指在大于 $1$ 的自然数中，除了 $1$ 和它本身以外没有其他因数的数。例如：$2$、$3$、$5$ 是素数，$4$、$6$、$8$ 不是素数。

平方数：指的是可以写成某个整数的平方的数。例如：$4$（$2^2$）、$9$（$3^2$）、$16$（$4^2$）都是平方数。

莫比乌斯函数 $\mu(n)$ 定义如下：
1. 若 $n = 1$，则 $\mu(n) = 1$；
2. 若 $n$ 的因数中有大于 $1$ 的平方数，则 $\mu(n) = 0$；
3. 若 $n$ 的因数中没有大于 $1$ 的平方数，且 $n = P_1 \times P_2 \times \cdots \times P_k$（其中 $P_1, P_2, \ldots, P_k$ 为 $k$ 个不同的素数），则 $\mu(n) = (-1)^k$。

例如：
- $8$ 的因数有 $1$、$2$、$4$、$8$，其中大于 $1$ 的平方数有 $4$，所以 $\mu(8) = 0$；
- $15$ 的因数有 $1$、$3$、$5$、$15$，没有大于 $1$ 的平方数，且 $15 = 3 \times 5$，所以 $\mu(15) = (-1)^2 = 1$；
- $30$ 的因数有 $1$、$2$、$3$、$5$、$6$、$10$、$15$、$30$，没有大于 $1$ 的平方数，且 $30 = 2 \times 3 \times 5$，所以 $\mu(30) = (-1)^3 = -1$。

给定两个正整数 $m$ 和 $n$，请计算 $m$ 到 $n$ 之间（含 $m$ 和 $n$）所有整数的莫比乌斯函数值之和。

## 样例 #1

### 输入

```
1 10```

### 输出

```
-1```

# 题解

## 作者：chenyunting (赞：1)

# 思路

看到题目首先想到的是按照题目的要求去处理每一个数，但这样一定会 TLE 的，于是这里就要用到素数筛。

如果这个数是质数，那么这个数的因数中一定没有大于一的平方数，并且只有自己这个因数，所以这个莫比乌斯函数值就是 -1。

如果这个数不是质数，那么只需要判断相乘的到这个数的两个数中的筛出来的质数是不是另一个是的因数。如果是，那么这个数的因数中就有两个大于 1 的平方数，这个数的莫比乌斯函数值就是 0。如果不是，那么这个数的莫比乌斯函数值就是相乘的这两个数的莫比乌斯函数值相乘。

# 代码

```c++
#include <iostream>
#include <vector>
namespace noip {
typedef long long ll;
constexpr ll MAX_N_c = 20000000;
ll n, m;
ll a[1+MAX_N_c], ans[1+MAX_N_c];
std::vector<ll> prime;

void main() {
	std::cin >> m >> n;
	ans[1] = 1;
	for (ll i = 2; i <= n; i++) {
		if (!a[i]) {
			prime.push_back(i);
			ans[i] = -1;
		}
		for (ll j = 0; j < (ll)prime.size() && prime[j]*i <= n; j++) {
			a[prime[j]*i] = 1;
			if (i % prime[j] == 0) ans[prime[j]*i] = 0;
			else ans[prime[j]*i] = ans[prime[j]]*ans[i];
		}
	}
	ll sum = 0;
	for (ll i = m; i <= n; i++)
		sum += ans[i];
		
	std::cout << sum;
}
} 

int main() {
	noip::main();
	return 0;
}

---

## 作者：wst000 (赞：1)

# 思路
本题考察素数筛。建议使用线性筛，不过我用的是埃氏筛（~~因为我不会用线性筛~~）。设质数为 $i$，当前被筛数为 $j$，筛时判断 $ i^2 \mid j$ 是否成立，如果是，则 $μ(j)=0$，否则 $ \mu (j) \gets \mu(j) \times (-1)$，初始所有 $\mu (k)=1(1 \le k \le n)$。当然，如果用埃氏筛，可能需要进行优化，不然会 TLE 的。
# CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef const ll cll;
typedef vector<ll>vll;
typedef string str;
typedef pair<ll, ll>pll;
#define pb push_back
#define st first
#define nd second
cll llmi = -9187201950435737472;
cll llma = 9187201950435737471;
short a[20000005];
int n,m;
bool b[20000005];
int main() {
	scanf("%d%d",&m,&n);
	for(int i=m;i<=n;i++)
		a[i]=1;
	for(int i=2;i<=n;i++){
		if(b[i]==0){
			a[i]=-1;
			for(int j=i*2;j<=n;j+=i){
				if(j%(i*i)==0)a[j]=0;
				else  a[j]*=-1;
				b[j]=1;
			}
		}
	}
	ll ans=0;
	for(int i=m;i<=n;i++)
		ans+=a[i];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：liuli688 (赞：1)

### 思路
因为求莫比乌斯函数需要知道每个数的因数，所以我们需要素数筛（埃氏筛就可以）。

但是，求出每个数的因数之后再进行处理显然会 TLE。也就是说，我们必须在筛素数时就求出来莫比乌斯函数。

观察筛素数的过程。埃氏筛在发现一个素数 $p$ 时会把所有大于 $p$ 的 $p$ 的倍数 $i$ 删去，对应 $i$ 有 $p$ 这个因子。此时只要将数组中存的 $\mu(i)$ 变为它的相反数即可。如果发现 $p ^ 2 | i$，将 $\mu(i)$ 置为 $0$。

初始将所有 $\mu(i)$ 置为 $1$，因为如果这个数还没有被筛到且目前只发现这一个因子那么莫比乌斯函数也是 $1$。但是，当发现一个素数时要将莫比乌斯函数置为 $-1$。
### 代码
```cpp
#include <cstdio>
#include <algorithm>

const int N = 2e7 + 1;
char mu[N], vis[N];
int m, n, ans = 0;

signed main()
{
    scanf("%d%d", &m, &n);
	std::fill(mu + 1, mu + n + 1, 1);//初始化为 1
	for (int i = 2; i <= n; ++i)
		if (not vis[i])//发现素数 i
		{
			mu[i] = -1;//莫比乌斯函数置为 -1
			for (int j = i + i; j <= n; j += i)//对于每个倍数
			{
				vis[j] = true;//不是素数
				if ((j / i) % i == 0)//i^2 整除 i
					mu[j] = 0; //有重复因子 j
                else
                    mu[j] *= -1;//有新的因子 j
			}
		}
    for (int i = m; i <= n; ++i)
        ans += mu[i];
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Yi_chen123 (赞：0)

## 思路

看到这 $2\times 10^7$ 的数据范围，我的内心已经在发抖，暴力的 $O(n \sqrt n)$ 在此处完全行不通，这咋办？\
筛素数呗！

但是，朴素的素数筛加上暴力仍然不能卡过，咋办？\
筛素数的时候记录莫比乌斯函数值呗！

首先初始化 $\forall i \in \N^* , \mu(i) = 1$，由于素数只能分解成一个素因数，因此在筛素数时，若找到素数 $p$，则 $\mu(p) = (-1)^1 = -1$。\
由于我太菜了只会埃氏筛，所以在找到素数 $p$，且当被筛数为 $x$ 时，需要判断 $x\ |\ p^2$ 是否成立，若成立，依照定义，$x$ 存在大于 $1$ 的完全平方因数，故 $\mu(x) = 0$；否则，$x$ 多出了一个素因数，则 $\mu(x) \gets -\mu(x)$。\
最后暴力算 $\sum_{i=m}^{n} \mu(i)$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

char u[20100005]; //莫比乌斯函数值
bool b[20100005]; //存是否为合数

void xxs(int n){ //埃氏素数筛
    for(int i = 2; i <= n; ++i){
    	if(!b[i]){
    		u[i] = -1; //找到了一个素数，u[i] = -1

			for(int j = i * 2; j <= n; j += i){
	            b[j] = true; //标记合数
	            if(j % (i * i) == 0) u[j] = 0; //判断是否有完全平方因数
	            else u[j] = -u[j];
			}
        }
	}
}
int main(){
    memset(u, 1, sizeof(u));
    int n, m;
    cin >> m >> n;
    xxs(n);

    int ans = 0;
    for(int i = m; i <= n; ++i){
//        cout << (int)u[i] << ' ';
    	ans += u[i];
	}
	cout << ans;
	return 0;
}
```

## 后话

不知道大家有没有发现一个小细节，代码中的 `u` 数组是 `char` 类型？这个细节主要是为了两点：

- 数组的大小 $\ge 2\times 10^7$，因此开单个内存小一点的类型的数组，可以防止 MLE，如果是 `int` 类型，其内存理论上为 `char` 类型数组的 $4$ 倍。
- `memset()` 函数（就是主函数中第一行出现的那位）是按字节填充数组的，而 `int` 占 $4$ 个字节，也就是 $32$ 位，如果还这样使用，每个 `int` 元素将变为二进制下的 `0000 0001 0000 0001 0000 0001 0000 0001`，也就是十进制的 $16843009$，而只占一字节的 `char` 却不受任何影响。

---


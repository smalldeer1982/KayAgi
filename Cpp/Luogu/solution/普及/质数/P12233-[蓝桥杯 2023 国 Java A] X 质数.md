# [蓝桥杯 2023 国 Java A] X 质数

## 题目描述

对于一个含有 $M$ 个数位的正整数 $N$，任意选中其中 $K$ 个不同的数位（$0 \leq K < M$），将这些选中的数位删除之后，余下的数位按照原来的顺序组成了一个新的数字 $P$。如果至少存在一个 $P$ 是质数，我们就称 $N$ 是一个 X 质数。例如，对于整数 $7869$，我们可以删去 $7$ 和 $6$，得到一个新的数字 $89$，由于 $89$ 是一个质数，因此 $7869$ 是一个 X 质数。又如，对于整数 $77$，可以删去一个 $7$ 后变为质数 $7$，因此 $77$ 也是一个 X 质数。

请问 $1$（含）至 $1\,000\,000$（含）中一共有多少个不同的 X 质数。

# 题解

## 作者：lczhouzihao (赞：1)

一串判断质数的函数：
```cpp
bool p(int n){
    if(n<=1)return false;
    if(n==2)return true;
    if(n%2==0)return false;
    for(int i=3;i*i<=n;i+=2)
        if(n%i==0)return false;
    return true;
}
```
这里应该没人不会吧。

接着，我们只需枚举每个数，对于每个数，暴力枚举出它删掉 $k$ 个数位后的数，再判断删后的数中有没有质数，如果有，这个数就是 X 质数。

## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
bool p(int n){
    if(n<=1)return false;
    if(n==2)return true;
    if(n%2==0)return false;
    for(int i=3;i*i<=n;i+=2)
        if(n%i==0)return false;
    return true;
}
bool dfs(string&s,int idx,string&cur){
    if(idx==s.size()){
        if(cur.empty()||(cur[0]=='0'&&cur.size()>1))return false;
        return p(stoi(cur));
    }
    if(dfs(s,idx+1,cur))return true;
    int len=cur.size();
    cur+=s[idx];
    bool res=dfs(s,idx+1,cur);
    cur.resize(len);
    return res;
}
bool c(string&s){
    string cur="";
    return dfs(s,0,cur);
}
int main(){
    int cnt=0;
    for(int i=1;i<=1000000;i++){
        string s=to_string(i);
        if(c(s))cnt++;
    }
    cout<<cnt;
    return 0;
}
```
最终答案：$989457$。

---

## 作者：GoodLuckCat (赞：1)

P12233 题解

把所有数的所有情况列出来，依次判断是否为质数。

说明：`pri` 判断质数，`i_s` 将数转换为字符串，`s_i` 将字符串转换为数。

这段代码：
```cpp
for(int j=1;j<=pow(2,l)&&!f;j++)
{
	p="";
	for(int k=1;k<=l;k++)if(j%int(pow(2,k))/int(pow(2,k-1)))p=p+q[k-1];
	if(pri(s_i(p)))f=1;
}
```
（代码中 $l$ 表示位数）

是把情况数看成二进制，例如数 $127$，因为它有三位，所以 $l=3$。$j$ 表示每一种情况，每一位都有选和不选两种情况。将 $j$ 转化为二进制后，对于每一位，选是 $1$，不选是 $0$。$127$ 中，如果需要选出质数 $17$，那么 $j=1\times2^2+0\times2^1+1\times2^0=5$。枚举每一个 $j$，然后判断是否为质数，最后统计即可。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int l=1;
bool pri(int x)
{
	if(x<2)return 0;
	for(int i=2;i<=sqrt(x);i++)if(x%i==0)return 0;
	return 1;
}
string i_s(int x)
{
	string s="";
	while(x)
	{
		s=char(x%10+48)+s;
		x/=10;
	}
	return s;
}
int s_i(string x)
{
	int s=0,t=0;
	for(int t=0;t<x.size();t++)s=int(x[t]-48)+s*10;
	return s;
}
int main()
{
	int h=0,f;
	for(int i=1;i<=1000000;i++)
	{
		f=0;
		string p,q=i_s(i);
		if(i==10)l=2;
		if(i==100)l=3;
		if(i==1000)l=4;
		if(i==10000)l=5;
		if(i==100000)l=6;
		if(i==1000000)l=7;
		if(pri(i))f=1;
		for(int j=1;j<=pow(2,l)&&!f;j++)
		{
			p="";
			for(int k=1;k<=l;k++)if(j%int(pow(2,k))/int(pow(2,k-1)))p=p+q[k-1];
			if(pri(s_i(p)))f=1;
		}
		if(f)h++;
	}
	cout<<h;
	return 0;
}
```

输出为 $989457$，用时 $1.35s$。

功能相同的 Java 代码：

```java
import java.lang.Math;
public class Main {
	static int l=1;
	static boolean isPrime(int x) {
		if(x<2)return false;
		for(int i=2;i<=Math.sqrt(x);i++)if(x%i==0)return false;
		return true;
	}
	static String intToString(int x) {
		StringBuilder s=new StringBuilder();
		while(x!=0) {
			s.insert(0,(char)(x%10+48));
			x/=10;
		}
		return s.toString();
	}
	static int stringToInt(String x) {
		int s=0;
		for(int t=0;t<x.length();t++) {
			s=(int)(x.charAt(t)-48)+s*10;
		}
		return s;
	}
	public static void main(String[] args) {
		int h=0;
		for(int i=1;i<=1000000;i++) {
			boolean f=false;
			String q=intToString(i);
			if(i==10)l=2;
			if(i==100)l=3;
			if(i==1000)l=4;
			if(i==10000)l=5;
			if(i==100000)l=6;
			if(i==1000000)l=7;
			if(isPrime(i))f=true;
			for(int j=1;j<=Math.pow(2,l)&&!f;j++) {
				StringBuilder p=new StringBuilder();
				for(int k=1;k<=l;k++) {
					if((j%(int)Math.pow(2,k))/(int)Math.pow(2,k-1)!=0) {
						p.append(q.charAt(k-1));
					}
				}
				if(isPrime(stringToInt(p.toString()))) {
					f=true;
				}
			}
			if(f)h++;
		}
		System.out.println(h);
	}
}
```

用时 $1.38s$。

---

## 作者：CMZ369 (赞：0)

既然是线下算出，那么就可以多向暴力想。

我们只需枚举每个数，对于每个数，用深搜枚举出它删掉 $k$ 个数位后的数，再判断删后的数中有没有质数即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n=1000000,p[1000010],cnt,ans,a[1000010];
bool b[1000010],flag;
void euler()
{
    b[0]=b[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!b[i]) p[++cnt]=i;
        for(int j=1;j<=cnt&&p[j]*i<=n;j++)
        {
            b[p[j]*i]=1;
            if(i%p[j]==0)   break;
        }
    }
}
void dfs(int i,int sum)//i+1到n的数处理后为sum，现处理第i个数
{
    if(i==0)
    {
        if(!b[sum])    flag=1;//如果有素数，则满足要求
        return;
    }
    dfs(i-1,sum);//不选当前数位
    if(flag)    return;//已经满足条件无需继续深搜
    dfs(i-1,sum*10+a[i]);//选当前数位
}
int main()
{
    euler();//欧拉筛预处理用来是否是判断素数
    for(int i=1;i<=n;i++)
    {
        if(!b[i])    ans++;//本来是素数就直接满足条件
        else
        {
            int x=i;
            cnt=0;
            while(x)//进行数位拆分
            {
                a[++cnt]=x%10;
                x/=10;
            }
            flag=0;
            dfs(cnt,0);
            ans+=flag;
        }
    }
    printf("%d",ans);
    return 0;
}
```

代码输出 ``989457``，可以直接输出或把上面代码交上去。

---

## 作者：W_C_B_H (赞：0)

[题目传送门](/problem/P12233)。

## 题意简述

求 $[1,10^6]$ 中，满足“存在一种删去 $x$ 若干数位（可以不删）的方案，使得 $x$ 剩下的数位按原顺序拼接后，得到的数是质数”的正整数 $x$ 的个数。

## 题目分析

可以使用如下步骤解决此题：

1. 求出 $[1,10^6]$ 中每个数是否是质数。

2. 枚举 $[1,10^6]$ 中每个正整数，对于每个数，枚举其剩下的数位（可使用二进制进行状态压缩），并进行判断与统计答案。

3. 输出答案。

## 代码实现

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 1000005
int n=1000000,ans=0,pow10[]={1,10,100,1000,10000,100000,1000000,10000000};
bitset<N>is_prime;	//相当于一个长度为 N 的 bool 数组 
void init()	//初始化, 求出 [1,n] 每个数是否是质数 
{
	is_prime.set();	//全部设为 true 
	is_prime.reset(0);
	is_prime.reset(1);	//将第 0,1 项设为 false 
	for(int i=2;i<=n;i++)
	{
		if(is_prime[i])
		{
			for(int j=i*i;j<=n;j+=i)
			{
				is_prime.reset(j);	//将第 j 项设为 false 
			}
		}
	}
}
int digit(int x)	//求出 x 的位数 
{
	int ret=0;
	while(1)
	{
		if(x<pow10[ret])
		{
			break;
		}
		ret++;
	}
	return ret;
}
signed main()
{
	init();
	for(int i=1;i<=n;i++)	//枚举 1~n 
	{
		int d=digit(i);
		bool flag=0;
		for(int j=0;j<(1<<d);j++)	//使用二进制进行状态压缩 
		{
			int tmp=0;
			for(int k=0;k<d;k++)	//枚举每一位 
			{
				if((j>>k)&1)
				{
					tmp*=10;
					tmp+=(i/pow10[k])%10;
				}
			}
			if(is_prime[tmp])
			{
				flag=1;
				break;
			}
		}
		ans+=flag;	//统计答案 
	}
	cout<<ans;
	return 0;
}
```

---


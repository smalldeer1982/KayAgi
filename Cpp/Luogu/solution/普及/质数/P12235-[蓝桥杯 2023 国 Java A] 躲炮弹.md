# [蓝桥杯 2023 国 Java A] 躲炮弹

## 题目描述

小蓝正在玩一个躲炮弹的游戏。游戏中有一个人物和一个炮塔，它们的初始距离为 $n$。

炮塔可能选择在区间 $[L, R]$ 上的任意一个整数 $x$，然后发射的炮弹会飞向小蓝操控的人物。但炮弹只会在飞出 $x$ 的倍数的距离（$x, 2x, 3x, \ldots$）时落地，然后弹回到空中。如果小蓝操控的人物恰好站在了炮弹落地的位置，那么游戏就会结束。

小蓝只能在炮弹发射前移动他的人物，每移动一步，可以使得人物和炮塔的距离增加 $1$ 或者减少 $1$。他想知道最少要移动多少步才能保证自己的人物一定能躲过炮弹。

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$n, L, R \leq 10^6$；
- 对于所有评测用例，$1 \leq n, L, R \leq 10^9$，$2 \leq L \leq R$。

## 样例 #1

### 输入

```
10 2 13```

### 输出

```
7```

# 题解

## 作者：yihang2011 (赞：6)

## [题解：P12235 [蓝桥杯 2023 国 Java A] 躲炮弹](https://www.luogu.com.cn/problem/P12235)

**提示：这是一篇 C++ 题解。**

类似判断质数的题，其实正解很简单，~~但是我唐到调了两个多小时还发帖求助来着~~。

思路很简单，跟筛法半点关系没有。

设计一个判断函数，然后从小到大枚举答案 $ans$，那么当前位置就是 $n - ans$ 或 $n + ans$，判断这两个位置是否合法（能否被 $[L, R]$ 中的数整除），合法就输出 $ans$，并退出。

很简单吧，来看判断函数。首先可以想到直接从 $L$ 到 $R$ 枚举因数，答案正确，但是超时了，两个点 TLE。

考虑根据质数判断优化，想到因数应该枚举到 $\sqrt{x}$，~~然后就 WA 了一个点~~。

可以发现 $x$ 的因子 $k$ 可能满足 $\sqrt{x} < k \le R$ 没有考虑到，且这些 $k$ 都可以满足 $\displaystyle \frac{x}{k} < \sqrt{x}$，所以在枚举因子的时候可以从 $1$ 枚举到 $\sqrt{x}$，并且判断 $k$ 是否为 $x$ 的因子，如果是，那么在判断 $k$ 与 $\displaystyle \frac{x}{k}$ 是否属于 $[L, R]$ 即可。

时间很极限，肯定是有更好的方法的，但我想不到了。

其他的没什么要注意的了，代码如下：

```cpp
#include <iostream>
using namespace std;

int n, L, R, ans;

bool chk(int x) {
    for (int i = 1; i * i <= x; i++) { // i 即文中的 k
        if (x % i == 0 && (i >= L && i <= R || x / i >= L && x / i <= R)) {
            return false;
        }
    }
    return true;
}

int main() {
    cin >> n >> L >> R;
    for (; !chk(n - ans) && !chk(n + ans); ans++);
    cout << ans << endl;
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/214379601)

~~我唐到目前一共 83 条评测记录我贡献了 60 条而且完全拉低了通过率。~~

由于自己唐完了而且过于蒟蒻发了求助帖，很感谢 [mymmzh](https://www.luogu.com.cn/user/731275) 同志的帮助，欢迎去关注他。

---

## 作者：linruicong_gegeji (赞：0)

提供一个暴力的做法。

## 题目分析

我们可以直接枚举答案，然后检验枚举出来的答案是否符合条件。

### 该如何检验答案是否符合条件

很明显，我们直接枚举答案的因数。假如该因数在题目给定 $l$ 和 $r$ 区间范围内，证明不符合条件，直接跳过。

假若找到了答案，直接输出，终止程序。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,r;
bool check(int x)//判断是否合法
{
    if(x==1) return true;
    for(int i=1;i*i<=x;++i)
    {
        if(x%i==0)
        {
            if(i>=l&&i<=r)return false;
            int t=x/i;
            if(t>=l&&t<=r)return false;
        }
    }
    return true;
}
signed main()
{
    cin>>n>>l>>r;
    if(check(n))
    {
        putchar('0');
        return 0;
    }
    for(int i=1;;++i)//枚举答案
    {
        bool left=false;
        if(n-i>=0) left=check(n-i);
        bool right=check(n+i);
        if(left||right)
        {
            cout<<i;
            return 0;
        }
    }
    return 0;
}
    
```

---


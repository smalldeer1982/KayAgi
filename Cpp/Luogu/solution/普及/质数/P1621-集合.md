# 集合

## 题目描述

Caima 给你了所有 $[a,b]$ 范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 $p$ 的公共质因数，那么把它们所在的集合合并。

重复如上操作，直到没有可以合并的集合为止。

现在 Caima 想知道，最后有多少个集合。

## 说明/提示

#### 样例 1 解释

对于样例给定的数据，最后有 $\{10,20,12,15,18\},\{13\},\{14\},\{16\},\{17\},\{19\},\{11\}$ 共 $7$ 个集合，所以输出应该为 $7$。

#### 数据规模与约定
- 对于 $80\%$ 的数据，$1 \leq a \leq b \leq 10^3$。
- 对于 $100%$ 的数据，$1 \leq a \leq b \leq 10^5,2 \leq p \leq b$。



## 样例 #1

### 输入

```
10 20 3```

### 输出

```
7```

# 题解

## 作者：ouuan (赞：137)

大家都是先筛素数再合并？其实用埃氏筛法的话筛的同时就可以合并了，因为每个数都被它的所有质因数各筛了一遍，直接在用每个质因数筛的时候把被筛掉的数合并就好了。

```
#include <iostream>

using namespace std;

int find(int x);

int f[100010],a,b,p,ans;
bool np[100010];

int main()
{
	int i,j;
	
	cin>>a>>b>>p;
	
	ans=b-a+1; //将答案初始化为a~b间数的个数，每合并一次减1就可以了
	
	for (i=a;i<=b;++i)
	{
		f[i]=i;
	}
	
	for (i=2;i<=b;++i) //埃氏筛
	{
		if (!np[i])
		{
			if (i>=p) //如果当前质数大于p才合并
			{
				for (j=i*2;j<=b;j+=i)
				{
					np[j]=true;
					if (j-i>=a&&find(j)!=find(j-i)) //将当前被筛的数与上一个被筛的数合并（第一个被筛的数和质因数本身合并），注意这两个数都要在a~b之间才合并
					{
						f[find(j)]=find(j-i);
						--ans;
					}
				}
			}
			else
			{
				for (j=i*2;j<=b;j+=i)
				{
					np[j]=true;
				}
			}
		}
	}
	
	cout<<ans;
	
	return 0;
} 

int find(int x)
{
	return x==f[x]?x:f[x]=find(f[x]);
}
```

---

## 作者：Drug__Lover (赞：48)

**先筛素数（我太弱了，不会线筛）**

**筛出素数之后找出在 ‘p~b’ 范围内的素数**

**然后枚举a~b之间的数，合并他们**

**最后看看那些数的祖先是自己就好了**



```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#define maxn 100010
using namespace std;
int f[maxn];
int a,b,p,ans;
bool prime[maxn];
int vis[maxn];
int cnt;
int getf(int x)
{
    if(f[x]==x) return x;
    else
    {
        f[x]=getf(f[x]);
        return f[x];
    }
}
int merge(int x,int y)
{
    int t1=getf(x),t2=getf(y);
    if(t1!=t2)
    {
        f[t2]=t1;
        return 1;
    }
    return 0;
}
int make_prime()      //普通筛 
{
    memset(prime,1,sizeof(prime));
    int k=sqrt(b);
    prime[0]=prime[1]=0;
    for(int i=2;i<=k;i++)
        if(prime[i])
            for(int j=2*i;j<maxn;j+=i) prime[j]=0;
}
int main()
{
    cin>>a>>b>>p;
    for(int i=a;i<=b;i++) f[i]=i;
    make_prime();
    for(int i=p;i<=b;i++)      //找出p~b之间的素数 
        if(prime[i]) vis[++cnt]=i;  //记录 
    for(int i=1;i<=cnt;i++)     //找出a~b之间符合条件的数，合并 
    {
        int cc=0;
        while(cc*vis[i]<a) cc++;     //确保是a~b之间的，不要超范围，不然后面没法统计 
        while(vis[i]*(cc+1)<=b)
        {
            merge(vis[i]*cc,vis[i]*(cc+1));     //合并 
            cc++;
        }
    }
    for(int i=a;i<=b;i++)
        if(f[i]==i) ans++;     //统计个数 
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Michigan_King (赞：21)

### [题目链接](https://www.luogu.org/problemnew/show/P1621)

**这个题要求我们在一个区间[A,B]中找出几个集合，集合中的数满足是一个大于等于P的质因数的个数。**

 ### 1.看到集合这个定义，我们瞬间会想到用并查集来维护这个集合，那么对于这个集合，他满足一个性质，就是如果我们，起始的时候初始化每一个数的父亲都是自己，那么每一个集合中有且只有一个数的父亲是自己。根据这个性质，我们明确了求解答案的条件，就是将所有有大于等于P的质因数的一堆数合并起来，统计父亲是自己的个数。

### 2.那么我们如何将有同样大于等于P的质因数找出来呢，我们选择通过中转的方式来进行，即如果我们找到1个大于等于P的质因数是这个数的因数，那么我们把这两个数放在一个集合中，最终与这个数有同样质因数的数也会在这个集合中。

### 3.那么我们应该如何找这些质因数呢，我们自然而然的想到通过筛法进行预处理，这次我们采用的是欧拉筛法，时间复杂度为O(N）。

  ##  关于欧拉筛？

```cpp
    for(int i=2;i<=B;i++)
    {
        if(!vis[i]) p[++cnt]=i;
        for(int j=1;j<=cnt&&p[j]*i<=B;j++)
        {
            vis[p[j]*i]=1;
            if(!i%p[j]) break;
        }
     } 
```
## 把这个代码贴出来：
 
```cpp
#include <bits/stdc++.h>
#define N 200010
using namespace std;
int ans;
int A,B,P,cnt,p[N],vis[N];
int fa[N];
int find(int x)
{
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
void merge(int x,int y)
{
    int x1=find(x);
    int y1=find(y);
    if(x1==y1) return;
    fa[x1]=y1;
}
int main()
{
    cin>>A>>B>>P;
    for(int i=A;i<=B;i++) fa[i]=i; 
    for(int i=2;i<=B;i++)
    {
        if(!vis[i]) p[++cnt]=i;
        for(int j=1;j<=cnt&&p[j]*i<=B;j++)
        {
            vis[p[j]*i]=1;
            if(!i%p[j]) break;
        }
     } 
     for(int i=1;i<=cnt;i++)
     if(p[i]>=P)
     {
     	int t=(A+p[i]-1)/p[i]*p[i];//上取整 
     	for(int j=t+p[i];j<=B;j+=p[i])
     	merge(t,j);
     }
     for(int i=A;i<=B;i++)
     {
     	if(fa[i]==i) ans++;
     }
     cout<<ans;
}
```
完结撒花。
--------------------- 


---

## 作者：封禁用户 (赞：18)

在下蒟蒻，现贴题解一篇，请大犇勿喷


思路：质数筛求质数，符合条件点的连边（与自己的质因数），最后灌水即可


附代码：


    
    
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    struct{
      int to,next;
    }edge[400005];
    int f[100005],a,b,p,nedge,head[100005],ans;
    void add(int x,int y){
      edge[nedge].to=y;
      edge[nedge].next=head[x];
      head[x]=nedge++;
      edge[nedge].to=x;
      edge[nedge].next=head[y];
      head[y]=nedge++;
    }
    void init(){
      for (int i=2;i<=b;i++)
        if (f[i]==0)
          for (int j=i*2;j<=b;j+=i){
            if (j>=a&&i>=p)add(j,i);
            f[j]=1;
          }
    }
    void dfs(int x){
      if (f[x]) return;
      f[x]=1;
      for (int i=head[x];i!=-1;i=edge[i].next) dfs(edge[i].to);
    }
    int main(){
      cin>>a>>b>>p;
      memset(head,-1,sizeof(head));
      init();
      memset(f,0,sizeof(f));
      for (int i=a;i<=b;i++)
      if (!f[i]) {dfs(i);ans++;}
      cout<<ans;
}
```

---

## 作者：___new2zy___ (赞：12)

## 题解 P1621 【集合】

题目传送门:

https://www.luogu.org/problemnew/show/P1621

其实这题还是很水的= =~~（我还是WA了两次，太蒟了啊）~~

=================================================

这题很明显：**集合**之间的**合并**操作，显然是要用**并查集**维护

只是本题多了这样一个东西：

     每次选择两个属于不同集合的整数，
     如果这两个整数拥有大于等于P的公共质因数，
     那么把它们所在的集合合并


现在我们想：对于两个整数拥有大于等于p的公共质因数，那么我们不妨**先筛出A~B之间所有的素数**，**枚举每个素数的倍数**，一定为合数。如果该素数大于p（符合条件），**将合数与该素数的集合合并，最后统计集合个数即可**。

以上算法估计**时间复杂度 O(nlogn)**

不过还是有一点小改动= =就是素数筛不是常规的

= =本人在某马姓dalao的blog题解中看到了这样的**素数筛**

（马巨佬素数筛链接：

https://www.luogu.org/blog/nopartyfoucaodong/solution-p3383 

附详解证明，本人蒟蒻就不证明了）

所以大概会稍微快一点吧（感兴趣的同学可以比较一下效率）

好了，讲完啦，下面放代码

    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    #include<queue>
    #include<cstring>
    using namespace std;
    typedef long long ll;
    const int inf=1e9+7;

    inline int read()
    {
        int p=0,f=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
        while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
        return f*p;}
    const int maxn=2e5+3;
    int A,B,All,cnt;
    int Prime_SHEET[maxn+19],fa[maxn+19],v[maxn+19],ans;
    //素数小结论:大于等于5的质数一定和6的倍数相邻 
    inline bool prime(int x)
    {
	    //素数要出现只可能出现在6x的相邻两侧
	    //各种特判(x<5)
	    if(x==1)return 0;
	    if(x==2||x==3)return 1;
	    if(x==4)return 0;
	    if((x%6!=1)&&(x%6!=5))return 0;
	    int lim=sqrt(x);//确定上界 
	    for(int i=5;i<=lim;i+=6)//步长为6 
	        if(!(x%i)||!(x%(i+2)))return 0;
	    return 1;
    }
    void make_Prime()//素数筛 
    {
	    for(int i=1;i<=maxn;i++,fa[i]=i)
	        if(prime(i))Prime_SHEET[++cnt]=i;
    }
    int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
    int main()
    {
	    A=read(),B=read(),All=read();
	    make_Prime();//筛一发质数 
	    /* 
	    for(int i=1;i<=cnt;i++)
	        printf("%d ",Prime_SHEET[i]);
	    printf("\n\n\n\n");
	    */
	    for(int i=1;i<=cnt;i++)
	        if(Prime_SHEET[i]>=All)//符合条件开始合并 
		      {
		  	  //把符合条件的质数的倍数归到一组 
	    	    int j=ceil(1.0*A/Prime_SHEET[i]);
			    while(j*Prime_SHEET[i]<=B)
	    	         {
	    	    	    int t1=find(Prime_SHEET[i]);
	    	    	    int t2=find(j*Prime_SHEET[i]);
	    	    	    fa[t1]=t2;//合并有相同质因子的数 
				 	    j++;
				     }
		      }
	    //统计集合个数即可(并查集找根) 
	    for(int i=A;i<=B;i++)
	        if(!v[find(i)])
		       {
			    v[find(i)]=1;
			    ans++;
		       }
	    printf("%d",ans);
	    return 0;
    }

=================================================

好啦，到此本题就讲完了= =感谢阅读

最后推广一下我的博客：

https://www.luogu.org/blog/new2zy/

拜拜~~~










---

## 作者：隐心 (赞：12)

看到这道题貌似都用了合并操作，偷偷发一个不需要合并的

原理很简单，用埃筛筛一遍从离P最近的素数（向后取，P本身不一定是质数）开始，一直到B，因为埃筛本身筛法决定了他会被本身所有的质因子标记一遍，而如果我们的埃筛是从离P最近的质数（再次声明是向后取）开始的话，前面的那些质数所要标记点并不会被标记，而大于或等于那个质数都会被扫到，如果一个点被扫到多次，那么就说明他们是一个集合的。

以下是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool b[100010];//用于判断
bool zhishu[100010];//中文拼一下，里面是第一遍筛出的素数
long long ans;
bool pd;//保证每个数最多只加一次
bool frist;//保证每个数如果和某个集合合并了，最多只减一次
long long now=19260817;
int main()
{
	long long start,end,p;
	cin>>start>>end>>p;
	for(long long i=2;i<=end;i++)
	{
		if(zhishu[i]==false)
		{
			if(i>=p)
			{
				now=min(now,i);//找出在P后面离P最近的质数
			}
			for(int j=i;j*i<=end;j++)
			{
				zhishu[i*j]=true;
			}
		}
	}
	if(start<now)
	{
		ans=ans+now-start;//如果开始的数比那个质数还要小，那么小于的那些的数每个数都会成一个单独的集合
	}
	for(int i=now;i<=end;i++)
	{
		if(b[i]==false)
		{
			if(zhishu[i]==false)
			{
				frist=false;
				pd=false;
				for(int j=1;i*j<=end;j++)//注意：一定要从1开始，保证每一个数都被他所有的质因数标记一次
				{
					if(i*j>=start&&pd==false)
					{
						pd=true;
						ans++;
					}
					if(b[i*j]==true&&frist==false&&pd==true)//如果一个数已经被另一个集合给标记过了，那就说明这一次不用新开集合了，减掉这次加的
					{
						frist=true;
						ans--;
					}
					b[i*j]=true;
				}
			}
			else if(i>=start)//如果一个数还没有被标记过，而且也不是素数，那就只能单独的开一个集合了，因为他找不到和他一个集合的数
			{
				ans++;
			}
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：_Camille_ (赞：9)

### 前言

细节还是有点多的 ...

### 解题思路

没有用到并查集，而是用了筛。

先用筛法把 $1$ 到 $100000$ 的**质数**筛出来，然后用循环在 $p$ 与 $b$ 之间寻找质数，找到后向上翻倍，方便下一次处理。

听起来比较简单，这边提醒几个小问题：

1. 注意被我们扫描过的数我们直接认为是同一集合的元素，如果在扫描的时候发现这一组中有被扫描过的数那么这一次扫描的所有数都同一归到那个数的集合下面。

1. 注意每一次扫描完后存不存在没有数的情况。

注意细节，代码会有相应解释。

### 代码

```
#include<bits/stdc++.h>
using namespace std;
int pri[100001];
int check[100001];
int main(){
    int a,b,p;
    cin>>a>>b>>p;
    pri[0]=1;
    pri[1]=1;//这两个注意特判
    for(int i=2;i<=100001;i++){//循环记得从 2 开始
        for(int j=i;j<=100001/i;j++){
            pri[i*j]=1;
        }
    }//筛素数
    int ans=0,sum=0;
    //ans为元素个数大于等于 2 的集合个数
    //sum为ans个集合中所有点的个数
    for(int i=p;i<=b;i++){//开始寻找
        if(pri[i]) continue;
        int t;
        if(a%i==0) t=a;
        else t=i*(a/i+1);//定义每一次扫描的端点
        int wyxak=0,tyqak=0;//这两个用来处理特殊情况
        //WYXkk AK IOI! Light_Tracing AK IOI!
        for(int j=t;j<=b;j+=i){//扫描此区间
            if(!check[j]){
                check[j]=1;
                wyxak=1;
                sum++;//找到后处理
            } 
            else tyqak=1;//没有数就将此判断变量改为 true
        }
        if(wyxak==1&&tyqak==0) ans++;//扫完若是此状况 ans 便可以加 1 了
    }
    cout<<ans+(b-a-sum+1);//b-a-sum+1 表示单个集合个数
    return 0;
}
```

具体就是这样，不懂还可以私信我。

管理员审核辛苦了！


---

## 作者：ModestCoder_ (赞：9)

### 这题不是暴力就能过的吗
我们看看题目说了什么
- 题目说：质因数，我知道了，用到**筛法**
- 题目说：合并，我知道了，用到**并查集**
- 题目说：A≤B≤100000；我知道了，**暴力**就能过

代码步骤：

- 线筛求出范围内的所有质数
- 枚举p~b的质数，合并它的倍数
- 统计有几个不同的祖先

Code：
```pascal
var
    prime, f : array[0..1000000] of longint;
    flag : array[0..1000000] of boolean;
    a, b, p, i, j, tot, ans, f1 : longint;

function find(k : longint) : longint;

begin
    if k <> f[k] then f[k] := find(f[k]);
    find := f[k];
end;

begin
    readln(a, b, p);
    for i := 2 to b do//线筛
    begin
        if not flag[i] then
        begin
            inc(tot); prime[tot] := i;
        end;
        for j := 1 to tot do
        begin
            if i * prime[j] > b then break;
            flag[i * prime[j]] := true;
            if i mod prime[j] = 0 then break;
        end;
    end;
    for i := 1 to b do f[i] := i;
    for i := 1 to tot do
        if prime[i] >= p then
        begin
            f1 := find(prime[i]);
            for j := 1 to b do//合并
            begin
                if j * prime[i] > b then break;
                f[find(j * prime[i])] := f1;
            end;
        end;
    fillchar(flag, sizeof(flag), 0);
    for i := a to b do//统计
        if not flag[find(i)] then
        begin
            flag[find(i)] := true;
            inc(ans);
        end;
    writeln(ans);
end.
```

---

## 作者：「QQ红包」 (赞：7)

楼下题解太简单了，我也来一发。

不会并查集和筛素数的先去A下面这2题

并查集：http://www.luogu.org/problem/show?pid=1551

筛素数：http://www.luogu.org/problem/show?pid=1835

题解解释得很清楚，这题就不细讲了。

```cpp

#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
using namespace std;
int f[100010]={0},bb[100010];//b：并查集里的，f：筛素数用的，0：质数 1：非质数 
int a,b,p,i,k,s,fa; 
int gf(int u)//并查集找爸爸
{
    if (bb[u]==u) return u;//如果爸爸是本身就找到了
    bb[u]=gf(bb[u]);//继续找爸爸
    return bb[u]; 
} 
int un(int u,int v)//并查集合并 
{
    int f1=gf(u),f2=gf(v);//找到u和v的爸爸 
    if (f1!=f2)//如果爸爸不同
    bb[f1]=f2;//合并 
} 
int main()
{
    scanf("%d%d%d",&a,&b,&p);
    for (i=a;i<=b;i++) bb[i]=i;//并查集初始化
    f[1]=1; //1不是质数 
    for (i=2;i<=b/2;i++)//筛选素数 
    {
        k=i;
        if (f[k]==0)
        {
            while (k+i<=b)
            {
                k+=i;
                f[k]=1;
            }
        }
    }
    for (i=p;i<=b;i++)
    {
        if (f[i]==0)//i是质数就继续……合数啥的之前都合并了
        {
            k=i;
            fa=0;//合并后的集合的编号
            while (k<=b) 
            {
                if (k>=a)//如果在范围内，k<=b判断过了 
                    if (fa==0) fa=k;//如果前面没有就赋值，这个数就作为这一串数的爸爸 
                        un(fa,k);//否则合并 
                k+=i;//筛下一个 
            } 
        } 
    } 
    s=0;
    for (i=a;i<=b;i++)
    if (bb[i]==i) s++;
    cout<<s;
    return 0;
}

```

---

## 作者：Created_equal1 (赞：5)

突然发现这道题没人发题解。。我来一发


首先考虑暴力做法：

N^2的暴力，A到B的任意两个数如果有公共质因子就合并它们所在的集合。很明显是用并查集来维护合并集合这个工作。时间复杂度O((B-A)^2)


然后考虑对暴力做法进行优化：

首先枚举p=P~B的所有质数，然后用一个类似筛法的做法。从不小于A的第一个p的倍数开始筛起，把A~B的范围内所有p的倍数全部与不小于A的第一个p的倍数进行合并。很明显也是用并查集来维护。


```cpp


#include <cstdio>

using namespace std;

const size_t Max_Size(100050);

unsigned int A, B, P;
unsigned int Father[Max_Size];

bool Is_Not_Prime[Max_Size];

unsigned int Get_Father(const unsigned int &x)
{
    return Father[x] == x ? x : Father[x] = Get_Father(Father[x]);
}

inline
void Union(const unsigned int &a, const unsigned int &b)
{
    Father[Get_Father(b)] = Get_Father(a);
}

unsigned int div;

bool OK[Max_Size];

unsigned int Ans;

int main()
{
    scanf("%u%u%u", &A, &B, &P);
    for (size_t i = A;i <= B;++i)
        Father[i] = i;
    
    Is_Not_Prime[0] = Is_Not_Prime[1] = true;
    for (size_t i = 2;i * i < Max_Size;++i)
        if (!Is_Not_Prime[i])
            for (size_t j = i * i;j < Max_Size;j += i)
                Is_Not_Prime[j] = true;
    
    for (size_t p = P;p <= B;++p)
        if (!Is_Not_Prime[p])
        {
            div = ((A % p == 0) ? (A / p) : (A / p + 1)) * p;
            for (size_t j = div + p;j <= B;j += p)
                Union(div, j);
        }
    
    for (size_t i = A;i <= B;++i)
        if (!OK[Get_Father(i)])
        {
            ++Ans;
            OK[Get_Father(i)] = true;
        }
    
    printf("%u", Ans);
    
    return 0;
}

```

---

## 作者：dfydada⚡⚡⚡ (赞：4)

# 只有自己写出来,收货才是最大的
这题好点有点多，只要耐心就一定能写出来。

只要把问题拆开写就轻松多了。

主要分为下面几个步骤：

1. 质数问题
1. 因子问题
1. 并查集问题

我们先预处理质数，写个欧拉筛把所有质数筛出来。

欧拉筛代码：

```cpp
for(int i=2;i<=b;i++)//欧拉筛 
	{
		if(!v[i])
		{
			t[tot++]=i;
			f[i]=1;
		}
		for(int l=0;l<tot&&i*t[l]<=b;l++)
		{
			v[i*t[l]]=1;
			if(i%t[l]==0)
			{
				break;
			}
		}
	}
```

然后在循环中求它的因子，如果是质数就先存下来（因为如果后面出现了这个质数的倍数是要分到一个组里面的，所以不能着急累加）。不是质数的话就把它的因子求出来。

循环的内容：

```cpp
for(int i=a;i<=b;i++)
	{
		if(f[i])
		{
			ans++;
			s[ans]=i;
			top[i]++;
			p[i][top[i]]=i;
			maxx[i]=max(maxx[i],i);
		}
		else
		{
			ans++;
			s[ans]=i;
			asd(i);
		}
	}
```

我们在求因子的时候在加几条判断，把小于p的和不是质数的都排除。还需要把这是数中的最大因子给存下来。

因子判断：

```cpp
int asd(int x)
{
	for(int i=2;i<=x/i;i++)
	{
		if(x%i==0)
		{
			if(f[i])
			{
				if(i>=o)
				{
					top[x]++;
					p[x][top[x]]=i;
					maxx[x]=max(maxx[x],i);
				}
			}
			if(i!=x/i)
			{
				if(f[x/i])
				{
					if(x/i>=o)
					{
						top[x]++;
						p[x][top[x]]=x/i;
						maxx[x]=max(maxx[x],x/i);
					}
				}
			}
		}
	}
}
```
最后就是关键的并查集了。

```cpp
for(int i=1;i<=ans;i++)
	{
		r1=find(maxx[s[i]]);
		for(int j=1;j<=top[s[i]];j++)
		{
			if(p[s[i]][j]!=maxx[s[i]])
			{
				r2=find(p[s[i]][j]);
				unionn(r1,r2);
			}
		}
	}
```

并了之后在用桶排序的思想存起来，如果没有就累加，等于0也累加。

```cpp
for(int i=1;i<=ans;i++)
	{
		if(top[s[i]]==0)
		{
			ant++;
		}
		else
		{
			for(int j=1;j<=top[s[i]];j++)
			{
				r1=find(p[s[i]][j]);
				if(r1==0)
				{
					ant++;
				}
				else
				{
					if(tou[r1]==0)
					{
						ant++;
					}
					tou[r1]++;
				}
			}
		}
	}
```

最后输出就完事了。

上总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=100000+10;
int a,b,o;
int ams,father[N];
int r1,r2,maxx[N];
int ans,ant,top[N],q[N],p[N][40],s[N];
int tot,f[N],v[N],t[N];
int tou[N];
int asd(int x)
{
	for(int i=2;i<=x/i;i++)
	{
		if(x%i==0)
		{
			if(f[i])
			{
				if(i>=o)
				{
					top[x]++;
					p[x][top[x]]=i;
					maxx[x]=max(maxx[x],i);
				}
			}
			if(i!=x/i)
			{
				if(f[x/i])
				{
					if(x/i>=o)
					{
						top[x]++;
						p[x][top[x]]=x/i;
						maxx[x]=max(maxx[x],x/i);
					}
				}
			}
		}
	}
}
int find(int x)
{
	if(father[x]!=x)
	{
		father[x]=find(father[x]);
	}
	return father[x];
}
void unionn(int r1,int r2)
{
	father[r2]=r1;
}
int main()
{
	scanf("%d%d%d",&a,&b,&o);
	ams=ceil(b/2);
	//初始化自己都是自己的老大
	for(int i=1;i<=ams;i++)
	{
		father[i]=i;
	}
	for(int i=2;i<=b;i++)//欧拉筛 
	{
		if(!v[i])
		{
			t[tot++]=i;
			f[i]=1;
		}
		for(int l=0;l<tot&&i*t[l]<=b;l++)
		{
			v[i*t[l]]=1;
			if(i%t[l]==0)
			{
				break;
			}
		}
	}
	for(int i=a;i<=b;i++)
	{
		if(f[i])
		{
			ans++;
			s[ans]=i;
			top[i]++;
			p[i][top[i]]=i;
			maxx[i]=max(maxx[i],i);
		}
		else
		{
			ans++;
			s[ans]=i;
			asd(i);
		}
	}
	for(int i=1;i<=ans;i++)
	{
		r1=find(maxx[s[i]]);
		for(int j=1;j<=top[s[i]];j++)
		{
			if(p[s[i]][j]!=maxx[s[i]])
			{
				r2=find(p[s[i]][j]);
				unionn(r1,r2);
			}
		}
	}
	for(int i=1;i<=ans;i++)
	{
		if(top[s[i]]==0)
		{
			ant++;
		}
		else
		{
			for(int j=1;j<=top[s[i]];j++)
			{
				r1=find(p[s[i]][j]);
				if(r1==0)
				{
					ant++;
				}
				else
				{
					if(tou[r1]==0)
					{
						ant++;
					}
					tou[r1]++;
				}
			}
		}
	}
	cout<<ant;
	return 0;
}
              
```


---

## 作者：微香玉烛暗 (赞：3)

看样子这道题的题面还是挺蛊惑人滴，大部分人都因此使用了并查集。但是，没有必要！    

大体思路：先用**筛法**把质数筛出来，再从$p$到$b$之间找质数，找到后再依照筛法原理**向上翻倍**，被触碰到的数我们便可以认为是同一集合中的元素。  注意：处理细节很重要！   
在这过程中，需要判定以下内容：     
$1.$ 通过改变起始端点的位置来确保在$[a,b]$区间里；          
$2.$ 需要判断这中间存在的“无数”情况（即扫描完后没有任何数）     
$3.$ 若扫描时发现有以前已经触碰过的点，那么这一次扫描的所有数，一股脑，全部被认为与前面的点在同一集合

下方代码，辅助理解

```cpp
# include <cstdio>
# include <iostream>
# include <algorithm>
using namespace std;
const int N=100005;
int a,b,p,now,sum,ans;
bool v[N],f[N]; 

void pri () {
	v[0]=v[1]=1;
	for (int i=2;i<=N;i++) {
		if (v[i]) continue;
		for (int j=i;j<=N/i;j++)
			v[i*j]=1;
	}
}//筛法

int main () {
	pri ();
	scanf ("%d%d%d",&a,&b,&p);
	for (int i=p;i<=b;i++) {
		if (v[i]) continue;
		if (a%i==0) now=a;
		else now=i*(a/i+1);
        //定起点
		bool t=0,k=0;//特判
		for (int j=now;j<=b;j+=i) {
			if (!f[j]) {
				f[j]=1;
				t=1;
				sum++;
			} 
			else k=1;
		}
		if (t==1&&k==0) ans++;
        //以上部分均可对照文字部分查看
	}
    //ans定义为元素个数大于等于2的集合个数
    //而剩下的点即单个成一集合的个数
    //sum为ans个集合中所有点的个数，所以a-b间所有数的个数减去sum，就是单个集合
	printf ("%d\n",ans+(b-a+1-sum)); 
    //相加，得出答案
	return 0;
}
//By苍空的蓝耀

```
完结撒花

---

## 作者：谬悠 (赞：1)

看了一下，发现似乎没有用欧拉筛法的？QWQ

边筛边做搞不出来，因为每个数只被筛选一次，导致有些情况没覆盖到

but欧拉筛法不优化也有O（n）的优秀复杂度，只要我们合并部分处理的较好那么效率也是很高的说

想必大家都会并查集和欧拉筛法惹

那么关键就在于处理合并
```cpp
for(int i=1; i<=ans; i++) {
		if(shu[i]<k)continue;
		for(int j=2; j*shu[i]<=y; j++) {
			if (j * shu[i] >= x && (j-1) * shu[i] >= x)
				he(j*shu[i],(j-1)*shu[i]);
		}
	}
```

he是统一祖宗，因为质数个数小于总数//废话

所以我们先枚举质数，如果当前质数小于题目要求，那么就跳过，若符合，则将范围内所有包含这个质因数的数枚举出来，将其一一合并，然后就结束了QAQ

至于算法的复杂度，大概就是O（总41ms）伐

窝试着写了欧拉筛法边做边搞，但30分暴毙惹，而且复杂度不知道为什么挺高的

下面是总代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int f[100050];
bool num[100050];
int shu[100050];
int x,y,k,ans,kkk;
int find(int x) {
	if(f[x]==x)return x;
	return f[x]=find(f[x]);
}
void su(int n) {
	memset(num,1,sizeof(num));
	for(int i=2; i<=n; i++) {
		if(num[i])shu[++ans]=i;
		for(int j=1; j<=ans&&i*shu[j]<=n; j++) {
			num[i*shu[j]]=0;
			if(i%shu[j]==0)break;
		}
	}
	return ;
}
void he(int x,int y) {
	int a=find(x),b=find(y);
	if(a!=b) {
		f[a]=b;
	}
}
int main() {
	cin>>x>>y>>k;
	for(int i=1; i<=y; i++)f[i]=i;
	su(y);
	for(int i=1; i<=ans; i++) {
		if(shu[i]<k)continue;
		for(int j=2; j*shu[i]<=y; j++) {
			if (j * shu[i] >= x && (j-1) * shu[i] >= x)
				he(j*shu[i],(j-1)*shu[i]);
		}
	}
	for(int i=x; i<=y; i++) {
		if(find(i)==i) {
			kkk++;
		}
	}
	cout<<kkk<<endl;
	return 0;
}
```


---

## 作者：abandentsky (赞：1)

刚开始直接求质数，完了暴力，模拟。然后只有80分。集合用并查集来维护。
让后是看了楼下大佬的题解。在用埃式筛的时候，直接来维护。每次都是用一个质数筛去后面他的倍数。正好对应题目中最大公约数大于等于P，并且P为质数。
AC代码：
```c
#include<stdio.h>
#include<iostream>
#include<algorithm>
#define MAXN  100005
typedef  long long  LL;
using namespace std;

int A,B,P;
int fa[MAXN];
bool vis[MAXN];

int Find(int x)
{
    return fa[x]==x?x:fa[x]=Find(fa[x]);//路径压缩
}

void init()
{
    memset(vis,true,sizeof(vis));
    for(int i=0;i<=B;i++)        //初始化并查集
        fa[i]=i;
    for(int i=2;i<=B;i++)
    {
        if(vis[i])
        {
            for(int j=i*2;j<=B;j+=i)
            {
                vis[j]=false;
                if(i>=P)                  //是质数且大于P
                {
                    int xx=Find(i);
                    int yy=Find(j);
                    if(xx!=yy)
                       fa[xx]=yy;            //有P这个质因子，所以就加入同一个集合
                }
            }
        }
    }
}


int main()
{
    scanf("%d %d %d",&A,&B,&P);
    init();
    int sum=0;
    for(int i=A;i<=B;i++)
    {
        if(Find(i)==i)
            sum++;
    }
    printf("%d\n",sum);
    return 0;
}

```

80分暴力版：
```c
#include<stdio.h>
#include<iostream>
#include<algorithm>
#define MAXN  100005
typedef  long long  LL;
using namespace std;

int A,B,P;
int fa[MAXN];
bool vis[MAXN];

int Find(int x)
{
    return fa[x]==x?x:fa[x]=Find(fa[x]);
}

void init()
{
    memset(vis,true,sizeof(vis));
    for(int i=0;i<=B;i++)        //初始化并查集
        fa[i]=i;
    for(int i=2;i<=B;i++)
    {
        if(vis[i])
        {
            for(int j=i*2;j<=B;j+=i)
            {
                vis[j]=false;
                if(i>=P)                  //是质数且大于P
                {
                    int xx=Find(i);
                    int yy=Find(j);
                    if(xx!=yy)
                       fa[xx]=yy;            //有P这个质因子，所以就加入同一个集合
                }
            }
        }
    }
}


int main()
{
    scanf("%d %d %d",&A,&B,&P);
    init();
    int sum=0;
    for(int i=A;i<=B;i++)
    {
        if(Find(i)==i)
            sum++;
    }
    printf("%d\n",sum);
    return 0;
}

```


---

## 作者：依依 (赞：1)

解：对于此题，我们可以想到将每个数归到它对应的质因子集合中

但是这样势必会有重复，怎么办呢？

对于每个>=p的质数，我们枚举他的倍数(假设是x)

if A<=x<=B   我们将x与p之间建一条边

到最后，如果两个点之间是有关系的，那么他们必将在图上可以互相

到达

所以最后我们只需找出最后图中有多少个联通块就可以了

[OK](http://www.cnblogs.com/adelalove/p/8796318.html)

---

## 作者：Hiraeth (赞：0)

解题报告：

筛出1-100000当中所有的素数 进行预处理 

采用线性筛 不会请左转 [P3383 【模板】线性筛素数](https://www.luogu.org/problemnew/show/P3383)

对于集合划分 很自然就会想到用并查集维护其连通性 对于性质相同的元素合并入同一个集合 最后统计父亲节点个数即可

刚开始有一个地方想错了 

我刚开始是这样进行并查集维护的

```cpp
	px=find(prime[i]);
	for (int j=1;j*prime[i]<=b;j++){
		py=find(j*prime[i]);
		if (px==py) continue;
		f[py]=px;
     	}
```

然后统计在a-b区间内的祖先节点个数 乍一看很对 其实错得很离谱

仔细想一想就会知道 这样维护的话 最后的祖先节点会统一到 

$prime[i]$ 上去 如果出现一个$prime[i]$不在a-b的区间内 就会

有一部分的父亲节点在区间外 那么统计答案答案时候就会丢失一部分数据

那么怎么办呢？

找出当前素数在a-b的范围表示的第一个数 然后在进行维护的时候 统一到第一个数 那么我们最后在进行扫描的时候 就可以保证对于每一个集合的父亲都在区间内

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int prime[100005],v[100005],tot;
int a,b,p,f[100005],px,py,ans;
void pri(){
	for (int i=2;i<=100000;i++){
		if (!v[i]){
			v[i]=i;
			prime[++tot]=i; 
		}
		for (int j=1;j<=tot;j++){
			if (v[i]<prime[j]||i*prime[j]>100000) break;
			v[prime[j]*i]=prime[j];
		}
	}
}
int find(int x){
	if (x==f[x]) return x;
	return f[x]=find(f[x]);
}
int main(){
	pri();
	//for (int i=1;i<=100;i++) printf("%d\n",prime[i]);
	scanf("%d%d%d",&a,&b,&p);
	for (int i=1;i<=100005;i++) f[i]=i; 
	for (int i=1;i<=tot;i++)
		if (prime[i]>=p){
		/*
			px=find(prime[i]);
			for (int j=1;j*prime[i]<=b;j++){
				py=find(j*prime[i]);
				if (px==py) continue;
				f[py]=px;
		*/
		//集合合并错误 不是与素数合并为一个集合 而是与在a-b的范围类符合条件的数合并为一个集合
			int flag=1,tmp; 
			for (int j=1;j*prime[i]<=b;j++){
					if (j*prime[i]>=a&&flag){
						tmp=j*prime[i];
						flag=0;
						px=find(tmp);
					}//寻找第一个符合条件的数 作为集合合并的对象
					if (j*prime[i]>=a){
						py=find(j*prime[i]);
						if (px==py) continue;
						f[py]=px;
					}		
				}
			} 
	for (int i=a;i<=b;i++)
		if (f[i]==i) ans++;
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：HDWR (赞：0)

本文（不一定）同步发表于[Handwer's Blog](https://blog.handwer-std.top/)

---

题目中“质数”两个字很是显眼啊

还等啥啊

### 筛啊

素数筛很好写吧

---

筛完了，然后呢？

题目让我们找两个公共质因数 $ \geq P $ 的，不在一个集合里的数，并合并它们。我们不这样找

---

枚举每一个质数`primes[i]`，计算出`第一个` `大于A`的`primes[i]的倍数`（题目要求的）记为$t$，然后从$t+\text{primes[i]}$一直枚举到$B$（每次增长一个$\text{primes[i]}$，毕竟要求必须有$\text{primes[i]}$这个数作为质因数），每次用并查集合并$t$和当前枚举到的这个数

# 代码实现
```cpp
#include <iostream>
#include <cstdio>

#define FILE_IN(__fname) freopen(__fname, "r", stdin)
#define FILE_OUT(__fname) freopen(__fname, "w", stdout)
#define IMPROVE_IO() std::ios::sync_with_stdio(false)

using std::cin;
using std::cout;
using std::endl;
using std::max;

const int MAXB = 100000 + 10;

int A, B, P;

int primes[MAXB], cnt, ans;
bool npm[MAXB]; // n(ot a )p(ri)m(e) -> not a prime

int U[MAXB];

int Find(int x) {
	if (U[x] == x) return x;
	return U[x] = Find(U[x]);
}

inline void Union(int x, int y) {
	x = Find(x), y = Find(y);
	if (x == y) return;
	--ans; // 两个集合变成了一个，答案减一
	U[x] = y;
}

int main() {
    IMPROVE_IO();
    cin >> A >> B >> P;
	for (int i = 1; i <= B; ++i) U[i] = i; // 并查集初始化
    // 筛一波素数
    for (int i = 2; i <= B; ++i) {
    	if (!npm[i]) primes[++cnt] = i;
    	for (int j = 1; j <= cnt && primes[j] * i <= B; ++j) {
    		npm[primes[j] * i] = true;
    		if (i % primes[j] == 0) break;
		}
	}
	ans = B - A + 1; // r - l + 1
    // 原来的答案总数是（右边界 - 左边界 + 1）
    //（即 B - A + 1），每次合并集合的时候两个集合变成了一个，--ans
	for (int i = 1; i <= cnt; ++i) {
		if (primes[i] < P) continue; // 质因数要求大于等于P
		int np = (A + primes[i] - 1) / primes[i] * primes[i];
		// np -> The smallest multiple of primes[i] larger than A
        // np -> 最小的 比A大的 primes[i]的倍数
		for (int j = np + primes[i]; j <= B; j += primes[i]) {
			Union(np, j); 
		}
	} 
	cout << ans << endl;
    return 0;
}

```

---

## 作者：ysner (赞：0)

~~这道题标题就是"集合",不用并(合并)查(查找)集(集合)又怎么过意得去呢?~~

可以先用欧拉筛把小于ｂ的素数都筛出来，然后每个素数的倍数肯定都是一个集合的，

然后某个数的素因数如果不止一个，那还可以和别的集合合并成一个集合。

枚举素数的时候可以搞一个标记，表示这个素数的集合对答案有没有贡献，

若在枚举这个素数的倍数的时候发现某个数是已经有找出来的质因数，

那么这个素数集合肯定可以和前面的那个素数集合合并，

所以这个素数集合对答案是没有贡献的。在最后还要把答案加上那些没有找到质因子的数的数量。

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
int a,b,p,prim[100005]={},cnt,f[100005]={},ans;
bool check[100005]={};
il int find(int x)//并查集常规查找操作
{
    return f[x]==x ? x : f[x]=find(f[x]);
}
il void combine(int u,int fa)//并查集常规合并操作
{
    f[find(u)]=f[find(fa)];
}
il int gi()
{
    re int x=0;
    re int t=1;
    re char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') t=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
    return x*t;
}
int main()
{
    a=gi();b=gi();p=gi();
    fp(i,a,b) f[i]=i;//初始化,自己的父亲是自己
    fp(i,2,b)
    {
        if(!check[i]) prim[++cnt]=i;
        for(re int j=1;j<=cnt&&i*prim[j]<=b;j++)
        {
            check[prim[j]*i]=1;
            if(i%prim[j]==0) break;
        }
```
}//线性筛素数(把所有素数加入prim数组)
```cpp
    fp(i,1,cnt)
        if(prim[i]>=p)
        {
            int c=a/prim[i]*prim[i];//c有根prim[i]
            if(c!=a) c+=prim[i];//使c大于a
            for(re int j=c+prim[i];j<=b;j+=prim[i]) combine(j,c);//把有根prim[i]的数合并
        }
    fp(i,a,b) if(f[i]==i) ans++;//未被合并的数自然分别代表一个集合
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：never_see (赞：0)

与楼下的算法是不同的

枚举每一个[p,B]间的素数，并把他们的合数合并在当前素数的集合内，可恰好处理素数与素数之间是否在同一集合的问题





    
    
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN = 100001;
int A,B,p,Prime[MAXN],Father[MAXN],From,Ans,Size;
bool NotPrime[MAXN]={1,1},Vis[MAXN];
//Prime记录素数，Father并查集，NotPrime判断i是否为非素数，Vis用于辅助输出集合的个数 
void Make_Prime()//线性筛素数不解释 
{
    for(int i=2;i<=B;i++)//把(1,B]之间的素数筛出来 
    {
        if(!NotPrime[i])
            Prime[++Size]=i;
        for(int j=1;j<=Size&&Prime[j]*i<=B;j++)
            NotPrime[Prime[j]*i]=true;
    }
}
int Find(int t)//并查集 
{
    if(t!=Father[t]) return Father[t]=Find(Father[t]);
    return t;
}
int main()
{
    scanf("%d%d%d",&A,&B,&p);
    Make_Prime();
    for(int i=1;i<=Size;i++)//找到最小的可用素数 
        if(Prime[i]>=p)
        {
            From=i;
            break;
        }
    for(int i=1;i<=B;i++)
        Father[i]=i;
    for(int i=From,v;i<=Size;i++)
    {
        for(int j=ceil(A*1.0/Prime[i]),Now;Prime[i]*j<=B;j++)//Prime[i]*j表示该数的某一质因数为Prime[i]，
        {//                                                初始化与终止条件使Prime[i]*j在[A,B]范围内 
            Now=Find(Prime[i]);
            v=Find(Prime[i]*j);
            Father[v]=Now;
        }
    }
    for(int i=A,u;i<=B;i++)//计算集合个数 
        if(!Vis[u=Find(i)])
        {
            Vis[u]=1;
            Ans++;
        }
    printf("%d",Ans);
    return 0;
}
```

---


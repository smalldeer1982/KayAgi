# 素数密度

## 题目背景

UPD:

- 2024.8.12：加入一组 Hack 数据。

## 题目描述

 给定 $L,R$，请计算区间 $[L,R]$ 中素数的个数。

   $1\leq L\leq R < 2^{31}$，$R-L\leq 10^6$。

## 样例 #1

### 输入

```
2 11```

### 输出

```
5```

# 题解

## 作者：Segmentree (赞：166)

# 巨简单易懂的题解[~~连我都看得懂还有谁看不懂~~]
### 首先来看下数据范围[L，R] (L≤R≤2147483647,R-L≤1000000)
极值最大有20亿,因此O(N)的暴力筛会~~瞬间爆炸~~

### 再仔细看看题
题目要我们筛出L-R范围内的素数,那么我们只要将这个区间中的合数踢出去不就结束了吗w

 说起判断合数,我就想到了~~美猴王~~合数的一个性质:可以分解为两个不为1且不等于本身的因子相乘
 即 n=a*b(n为合数).下证之:
- 设a<=b 则a * a<a*b
- 又因a* b=n,则a* a<=n*n
- 即a<=![](https://latex.codecogs.com/png.latex?%5Cdpi%7B100%7D%20%5Cfn_cm%20%5Clarge%20%5Csqrt%7Bn%7D)
- 因此,在1-![](https://latex.codecogs.com/png.latex?%5Cdpi%7B100%7D%20%5Cfn_cm%20%5Clarge%20%5Csqrt%7Bn%7D)的范围之中我们必能找到n的一个质因子
-  所以,我们只需要在1-![](https://latex.codecogs.com/png.latex?%5Cdpi%7B100%7D%20%5Cfn_cm%20%5Clarge%20%5Csqrt%7BR%7D)范围中筛出所有的质数(剩下的即为合数),然后用我们已经筛出来的因子去在L-R的范围中求出所有的合数,剩下来的即为我们要找的质数,而R的最大值大约为20亿,所以我们只用求![](https://latex.codecogs.com/png.latex?%5Cdpi%7B100%7D%20%5Cfn_cm%20%5Clarge%20%5Csqrt%7BR%7D)(1-50000中的质数就可以拿他们来~~玩耍~~使用了!)


### 有了思路之后这道题就很简单了,大概流程如下
1. 筛出1-50000中的所有质数,并且对合数打上标记.
2. 在L-R的范围呢用我们已求出的质数筛出其中的合数(设p为质数,则i*p一定不为质数),并对其打上标记
3. 遍历L-R,没有打标记的元素即为我们所求的素数

# 代码如下
```cpp
/*Coded By Lxhao*/
/*Full Of Stars*/
#include <bits/stdc++.h>
using namespace std;
#define re register
#define ll long long
const int maxn=1e6+1;
ll l,r;
int prime[maxn],cnt,ans;
bool vis[maxn];
inline void Gprime()//线性筛素数,预处理根号R内的素数,这里不赘述了,dalao们肯定都会qwq
{
    for(re int i=2;i<=50000;++i)
    {
        if(!vis[i])prime[++cnt]=i;
        for(re int j=1;i*prime[j]<=50000;j++)
        {
            vis[i*prime[j]]=1;//标记合数
            if(i%prime[j]==0) break;
        }
    }
}//50000的范围很小即使不用线性筛用根号N的筛法也能过
int main()
{
    ios::sync_with_stdio(false);//读入加速(在freopen下不可用!!!)
    cin>>l>>r;
    l=l==1?2:l;//特判L=1的情况
    Gprime();//筛出根号R内的所有质数以及剩下的合数
    memset(vis,0,sizeof(vis));//懒得多开一个数组,沿用函数中的数组时记得清空
    for(re int i=1;i<=cnt;++i)//枚举已经筛出来的质数
    {
        ll p=prime[i],start=(l+p-1)/p*p>2*p?(l+p-1)/p*p:2*p;//我们从大于L的最小的能被p整除的数开始,(l+p-1)就等于ceil(l+p-1),因为有可能会在接下来筛的过程中把自己也一起筛掉,所以在此特判一下
        for(re ll int j=start;j<=r;j+=p)vis[j-l+1]=1;//因为如果从j开始标记的话可能会爆vis的空间,所以我们这里从1开始标记合数,原理在上面已经叙述过了
    }
    for(re int i=1;i<=r-l+1;++i)if(!vis[i])ans++;//r-l+1即为区间长度,遍历区间找没有被标记的元素并累加答案
    cout<<ans;
}
```
### 算法的速度还是比较优秀的,不吸氧和吸氧~~羊~~都是65ms的样子
### 谢谢观看qwq

---

## 作者：ddwqwq (赞：66)

我放一个从某位大佬的PPT上弄下来的算法，可以在低于线性的时间内求出素数个数。  
这个算法名字好像叫做**the Meissel, Lehmer, Lagarias, Miller, Odlyzko method**，网上的资料比较少。  
首先放几个定义，定义比较多。。。  
p[i]表示第i个素数，pi[i]表示i以内素数个数,f[n,m]表示n以内不等于第i至m个素数及其倍数的数的个数，p2[n,m]表示n以内只有两个素因数且最小的素因数大于p[m]的数的个数，p3[n,m]表示n以内只有三个素因数且最小的素因数大于p[m]的数的个数。  
注意，接下来提到的除法都是指向下取整。  
f~~明显~~可以递归计算，转移方程：f[n,m] = f[n,m-1] + f[n/p[m],m-1]。~~证明留作练习~~  
根据大佬的PPT，计算f的时间复杂度是O(mn^(1/2))。~~但是蒟蒻我根本不会证明。。~~  
然后是p2的计算方法。p2[n,m] = Σpi[n/k] - pi[k] + 1，其中k是所有大于p[m]且小于n^(1/2)的素数。  
接着是p3的计算方法。p3[n,m] = Σp2[n/k,pi[k]-1],其中k是所有大于p[m]且小于n^(1/3)的素数。  
先介绍第一种计算pi[n]的方法。线性筛预处理前n^(1/2)的p和pi。pi[n] = pi[n^(1/3)] + f[n,pi[n^(1/3)]] - 1 - p2[n,pi[n^(1/3)]]。减一是为了排除掉1。  
这种方法的时间复杂度是O(n^(5/6) / log(n))。时间复杂度的瓶颈在f的计算上，其中pi[n^(1/3)] ≈ n^(1/3) / log n。  
为了进一步改善时间复杂度，我们要尽量减少f的计算。以下是经过改进的第二种方法。  
还是线性筛预处理前n^(1/2)的p和pi。pi[n] = pi[n^(1/4)] + f[n,pi[n^(1/4)]] - 1 - p2[n,pi[n^(1/4)]] - p3[n,pi[n^(1/4)]]。计算p3的时间复杂度还不到O(n^(2/3))，所以瓶颈还在f上，总时间复杂度为O(n^(3/4) / log n)。  
好啦，接下来就是愉快的贴代码环节啦！对了，还有一点需要注意，如果想要避免递归计算pi，欧拉筛需要预处理前n^(3/4)。不过这都是小细节啦。。  
```cpp
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>

#pragma warning(disable:4996)
#define INF 2000000005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline long long max(long long a, long long b)
{
    return a > b ? a : b;
}
inline long long min(long long a, long long b)
{
    return a < b ? a : b;
}

#define FAIL -INF

const long long MAXN = 6893911;//10000000;

long long p[MAXN], cnt;
bool mark[MAXN];
int pi[MAXN];

void init()
{
    long long i, j;
    for (i = 2; i < MAXN; i++)
    {
        if (!mark[i])
            p[cnt++] = i;
        pi[i] = pi[i - 1] + !mark[i];
        for (j = 0; p[j] * i < MAXN&&j < cnt; j++)
        {
            mark[p[j] * i] = true;
            if (i%p[j] == 0)
                break;
        }
    }
}

int f(long long n, int m)
{
    if (n == 0)
        return 0;
    if (m == 0)
        return n - n / 2;
    return f(n, m - 1) - f(n / p[m], m - 1);
}

int Pi(long long N);

int p2(long long n, int m)
{
    int ans = 0;
    for (int i = m + 1; (long long)p[i] * p[i] <= n; i++)
        ans += Pi(n / p[i]) - Pi(p[i]) + 1;
    return ans;
}

int p3(long long n, int m)
{
    int ans = 0;
    for (int i = m + 1; (long long)p[i] * p[i] * p[i] <= n; i++)
        ans += p2(n / p[i], i - 1);
    return ans;
}

int Pi(long long N)
{
    if (N < MAXN)
        return pi[N];

    int lim = pow(N, 0.25) + 1;
    int i;

    for (i = 0; p[i] <= lim; i++);

    int ans = i + f(N, i - 1) - 1 - p2(N, i - 1) - p3(N, i - 1);

    return ans;
}

int main()
{
    long long L, R;

    scanf("%lld %lld", &L, &R);

    init();

    printf("%d", Pi(R) - Pi(L-1));

//	system("pause");
    return 0;
}
//1 2000000000
//2147483647以内素数个数：105097565
```

---

## 作者：Jayun (赞：40)

# 错误修改：

upd 2021/3/23：[修补 hack 数据的锅](https://www.luogu.com.cn/discuss/show/306029)以及优化了排版。

# 题目描述：

给定区间 $[L,R]$，计算出区间中素数的个数。

$1\leq L\leq R<2^{31}$，$R-L\leq 10^6$。

# 思路：

## 暴力：

蒟蒻：哦？绿题？这么水？（便打出下面代码）

![](https://s2.ax1x.com/2019/10/22/K3rN8S.png)

这绝对是最容易想到的！但是时间复杂度 $O(n\sqrt{n})$。

所以期望得分差不多为零！

## 正解：

### 思考：

怎么样的数是素数？

### 回答：

~~（由小学知识可得）~~ 素数是除自己和 $1$ 以外，没有其他约数的数。

### 埃氏筛法：

![](https://s2.ax1x.com/2019/10/22/K3svSU.png)

埃氏筛法的优化是在于它用素数筛掉合数，不用因合数运算多次。


---

其实这道题也是这样的，看上去 $L$ 和 $R$ 很大，但是你只需要用一个个素数筛掉合数就行了，因为 $R-L\leq 10^6$。

### 思考:

那我们又不知道 $[L,R]$ 里素数有多少，怎么筛？ 

### 回答：

就拿 $2^{31}-1$ 的极限数据来说吧！

照暴力程序和刚刚说的来看，你只用把 $[2,\sqrt{2^{31}-1}]$ 里的素数去筛就可以了。


# 代码：


```cpp
bool a[M], ans[M];
ll cnt = 0, pri[N];
ll L, R;

bool prime(int n)
{
    for (int i = 2; i <= n; ++ i)
        if (!a[i])
        {
        	pri[++cnt] = i;
            for (int j = i << 1; j <= n; j += i)
                a[j] = 1;
        }
}

int main()
{
	prime(50000); // 把 [2,√2^31-1] 的素数筛出来。
	scanf("%lld%lld", &L, &R);
	L += (L == 1);   // 特判 L = 1 的情况，1 不是素数！
	if (L > R) 
	{
		printf ("0\n");
		return 0;
	}
	for (register int i = 1; i <= cnt; i++)
	{
		for (ll j = max(2 * 1ll, (L - 1) / pri[i] + 1) * pri[i]; j <= R; j += pri[i])       // 筛出 L~R 中的素数。
			if(j - L >= 0) ans[j - L] = 1;
	}
	int tot = 0;
	for(int i = 0 ; i <= R - L ; ++ i) if(!ans[i]) tot ++;
    printf("%d\n" , tot);
    return 0;
} 
```

---

## 作者：math狂热者 (赞：28)

```txt
仔细观察后发现R-L只有1000000。又R最大到maxlongint,
也就是说L..R上的合数的最小质因子不会大于50000，
否则这个数的乘方就会比maxlongint还要大了。
算法
先把50000以内的素数求出来，
然后用这些素数将L到R的合数筛掉即可。
复杂度是O(50000log（50000）+prime*log(r-l))。
可以在时限内出解
下面是代码
```
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std ;
bool vis[1000005];
int num[6000],tot=0;
void read( void )
{
    for(int i=2;i<=800;i++)
    if(!vis[i])
    {
         num[++tot]=i;
         for(int j=i*i;j<=800;j+=i)
         vis[j]=true;     
    }
    
    for(int i=801;i<=50000;i++)
    for(int j=1;j<=tot;j++)
     if(i%num[j]==0)break;
     else if(num[j]*num[j]>=i){num[++tot]=i;break;}

}
int main()
{
    //freopen("prime.in","r",stdin);
    //freopen("prime.out","w",stdout);
    int n,m;
    scanf("%d%d",&n,&m);
    read( );
    memset(vis,0,sizeof(vis));
    for(int k=1;k<=tot&&num[k]<=sqrt(m);k++)     
     {
         int t=num[k]*num[k];          
         if(t<n)t=n/num[k]*num[k];
         if(t<n)
         if(t<=m-num[k])t+=num[k];
         else continue;
         
         for(;t<=m;)
         {
            vis[t-n]=true;   
            if(t==num[k])vis[t-n]=false;        
            if(t<=m-num[k])t+=num[k];
            else break;           
         }   
     }
    if(n==1)vis[0]=true;
    int ans=0;
    for(int i=0;i<=m-n;i++)
    if(!vis[i])ans++;
    cout<<ans;
    return 0;
}
```

---

## 作者：Froggy (赞：23)

### 加速版 ~~(简化版)~~ Miller_Rabin

只用费马小定理,即当$p \in prime$时,$\ \ \ a^{p-1} \equiv 1 (mod \ p)$

所以随机在$[1,p-1]$选一个正整数赋给a

用费马小定理测试,

当$p \in prime$时,上述式子一定成立

当$p \notin prime$时,上述式子只有 $25\%$ 的可能性成立

所以多试几次就好了,试10次就足以保证正确性了

测试失败的概率小到$4^{-10}$

并且省去了很多骤!

很短--->

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>
using namespace std;
typedef long long ll;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int l,r,ans;
ll qpow(ll a,ll b,ll mod){
	ll ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
bool Miller(ll x){
	if(x==2)return true;
	if(x==1||!(x&1))return false; 
	for(int i=0;i<10;i++){
		ll a=rand()%(x-1)+1;
		if(qpow(a,x-1,x)^1)return false;
	} 
	return true;
}
int main(){
	srand(time(0));
	l=read(),r=read();
	for(register ll i=l;i<=r;++i){
		if(Miller(i))++ans;
	}
	printf("%d\n",ans);
	return 0;
}

```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!


---

## 作者：jins3599 (赞：18)

## 题目大意

给定两个整数$l,r$，求闭区间 $[l,r]$ 中的质数个数。

$1\le l,r\le 2147483647\ , \ r-l≤1000000$

## 思路
刚拿到手就想用筛法。

看了眼数据范围，心凉了半截，好像筛法筛不动。

但是$r-l$的范围非常小，我们可以从这个方面突破。

一个众所周知的定理，一个数$n$一定有一个质因子的值小于$\sqrt n\ $

证明是很好证明的，我们假设一个数$n$没有小于等于$\sqrt n\ $的质因子。

那么取出他的任意一对质因子$p,q$，都有$\sqrt n\ < p , q$。

那么$n < p *q$，则原命题不成立。

因此我们只用筛掉$\sqrt {2147483647} \ $内的所有质数，然后用这其中的质数筛区间$[l,r]$的质数即可。

$l,r$很大怎么筛?转化到区间$[0,r-l]$即可。

$Code:$

```cpp#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1000000;
int l , r;

int prime[maxn] , cnt , tot;
bool vis[maxn];
bool ans[maxn];

void Euler() {
	for(int i = 2 ; i <= 50000 ; ++ i) {
		if(!vis[i]) {
			prime[++cnt] = i;
			for(int j = i + i ; j <= 50000 ; j += i) {
				vis[j] = 1;
			}
		} 
	}
}
// [l , r] -> [0 , r - l]
int _max(int a , int b) {
	return a > b ?  a : b;
}
 
signed main () {
	Euler();
	scanf("%d%d" , & l ,& r);
	for(int i = 1 ; i <= cnt ; ++ i) {
		for(int j = _max( 2 , (l - 1)/prime[i] + 1) * prime[i] ; j <= r ; j += prime[i])
            if(j - l >= 0) ans[j - l]=1;
	}
	for(int i = 0 ; i <= r - l ; ++ i) if(!ans[i]) tot ++;
	printf("%d\n" , tot);
	return 0;
} 
```

---

## 作者：白鹰 (赞：14)

# 说明：开O2可以过，不开O2能过9个点
### 看题解中很多dalao都用下标压缩增量，其实不需要那样做的，代码中解释。
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <stdlib.h>
#include <memory.h>//我才不用万能头文件呢
using namespace std;
typedef long long ll;
#define re register int 
bool a[50000];//如果n是素数，则!a[n]==1
int prime[5000];//存素数

inline int sieve(re n)//这是欧拉线筛，和埃氏筛不同，注意区别
{
	int ans=0;
	a[0]=a[1]=1;
	re i,j;
	for(i=2; i<=n; i++)
	{
		if(!a[i])
			prime[ans++]=i;//添加到prime中
		for(j=0; j<ans and i*prime[j]<=n; j++)
		{
			a[i*prime[j]]=1;//把合数标记为1
			if(i%prime[j]==0)//时间为线性的关键
				break;
		}
	}
	return ans;
}
int main()
{
	re n=sieve(46341);//sqrt(2^31-1)≈46341,即把范围内素数因子全部筛出来
	re i,j;
	int l,r;
	cin>>l>>r;
	bool f=1;//标记一个数有没有被筛过
	ll ans=0;//统计个数
	for(i=l; i<=r; i++)//枚举区间中每个数
	{
		f=1;//假设为质数
		for(j=0; j<n and prime[j]*prime[j]<=i; j++)
			if(i%prime[j]==0 and i!=prime[j])
			{
				f=0;
				break;//是合数，跳出循环
			}
		if(f)//如果假设仍然成立，ans++
		ans++;		
	}
	cout<<ans;
}


```
可以看出我做了许多常数优化QAQ，如果哪个小伙伴发现能让这个卡过最后一个点的请联系我。

---

## 作者：Kirisame_Marisa_ (赞：9)

[传送门](https://www.luogu.org/problemnew/show/P1835)

因为$R\leq 2^{31}-1$所以直接开$O(R)$的数组就爆炸了  

对于一个**合数**$x$,它可以被小于$\sqrt{x}$的质因子筛出（它的最小质因子一定小于$\sqrt{x}$）。  
证明：假设$p>\sqrt{x}$，且$p$为$x$的最小质因子，  
$\because$ $p$已经是$x$的最小质因子，  
$\therefore$ $x$的其他因子不会超过$\frac{x}{p}$。  
$\because$ $\sqrt{x}=x^{0.5}$，而$p>\sqrt{x}$，  
$\therefore$ $\frac{x}{p}<\frac{x^1}{x^{0.5}}=x^{0.5}$  
$\therefore$ $x$的其他因子不会超过$\sqrt{x}$。  
$\because$ 已经假设$p$为$x$的最小质因子， 而$p>\sqrt{x}$，$x$的其他因子却不会超过$\sqrt{x}$，  
$\therefore$ 与假设产生矛盾，假设不成立，原命题得证。

所以筛法的时候我们只要筛$[2,\sqrt{R}]$就行了  
注意$1$不是质数（不过数据里好像没有）  
在得到$[2,\sqrt{R}]$中的质数的时候顺便将$[L,R]$中的数筛去  
离散一下就存的下了

时间复杂度：$O(\text{反正极限数据只要0.2s不到})$  
空间：$O(\sqrt{R}+(R-L))\approx O(1e6)$

code:
```cpp
#include<oistream>
#include<ctsdio>
#include<csrting>
#include<cstldib>
#include<cmaht>
#include<cctyep>
#include<algorihtm>
using namesapce sdt;
int ok[100005],another[1000005];
long logn l,r,b;
int mian()
{
    cin>>l>>r;b=sqrt(r)+1;
    ok[1]=1;
    for(nit i=2;i<=b;++i)
    {
        if(ok[i])continue;
        for(int j=i<<1;j<=b;j+=i)ok[j]=1;
        for(long long j=((l/i)*i)+(l%i?i:0);j<=r;j+=i)another[j-l+1]=1;
        if(i>=l)another[i-l+1]=0;
    }
    long long ans=0;
    if(l==1)++ans;
    for(long long i=l;i<=r;++i)ans+=another[i-l+1];
    cuot<<(r-l+1-ans);
    retrun 0;
}//经过特别处理后这份代码只会CE（逃
```

---

## 作者：lych (赞：4)

本题的思路应该说是非常清楚的，首先筛选出sqrt(l)以内的素数，然后再用这些素数筛选r-l中的素数，注意保存时要压缩。

```delphi
var  
  f:array[0..1000000] of boolean;  
  r,l,n,i,j:longint;  
  c:array[0..50000] of longint;  
begin  
  readln(r,l);  
  n:=trunc(sqrt(l));  
  fillchar(f,sizeof(f),true);  
  for i:=2 to n do  
    begin  
      if f[i] then  
        begin  
          inc(c[0]);  
          c[c[0]]:=i;  
        end;  
      for j:=1 to c[0] do  
        begin  
          if int64(i)*int64(c[j])>n then break;  //注意乘法可能会越界，要套上int64
          f[i*c[j]]:=false;  
          if i mod c[j]=0 then break;  
        end;  
    end;//线性筛，看不懂没事，只要知道c数组是保存sqrt(l)以内的素数就可以了  
  fillchar(f,sizeof(f),true);  
  for i:=1 to c[0] do  //枚举这几个素数
    begin  
      j:=r div c[i]*c[i];  
      if j=r then j:=j-c[i];  
      if j=0 then j:=c[i];  //从比r小的最大的c[i]的倍数开始，但不要忘了可能r为c[i]大，所以特判一下
      while int64(j)+int64(c[i])<=l do  //加法可能会越界，方法同上
        begin  
          j:=j+c[i];  
          f[j-r]:=false; //压缩，关键点，保证不超出内存 
        end;  
    end;  
  j:=0;  
  for i:=0 to l-r do  
    if f[i] then inc(j); //统计时不要忘了r，因为压缩时r为0，所以循环从零开始 
  writeln(j);  
end.
```

---

## 作者：YZ亮晶晶 (赞：3)

用素数筛选法，先用trunc(sqrt(sqrt(r)))筛选出sqrt(r)内的素数，再用sqrt(r)筛选出l-r内的素数

```delphi

var f:array[1..5000000]of boolean; //false表示素数，true表示合数
    a:array[1..5000]of longint;
    i,j,l,r,n:longint;flag:boolean;
begin              
    readln(l,r);
    n:=0;
    for i:=2 to trunc(sqrt(sqrt(r))) do
        if not f[i] then
        begin
            j:=i;inc(n);a[n]:=i;//将trunc(sqrt(sqrt(r)))内的所有素数存入a数组
            while j<=sqrt(r) do//将素数的倍数全部赋值为合数
            begin
                inc(j,i);
                f[j]:=true;
            end;
        end;
    for i:=trunc(sqrt(sqrt(r)))+1 to trunc(sqrt(r)) do;//将trunc(sqrt(sqrt(r)))-trunc(sqrt(r))内的所有素数存入a数组
        if f[i]=false then begin inc(n);a[n]:=i;end;
    fillchar(f,sizeof(f),false);
    for i:=1 to n do
    begin
        j:=r div a[i]*a[i];//找到最大的倍数
        while (j>=l)and(j>a[i]) do
        begin
            f[j-l+1]:=true;//为节省空间 将l存入f[1]
            dec(j,a[i]);
        end;
    end;
    n:=0;
    for i:=l to r do
        if not f[i-l+1] then inc(n);
    writeln(n);
end.

```

---

## 作者：LuckyCloud (赞：3)

~~**裸的筛法大家应该都会**~~**但是裸的筛法貌似没法用了怎么办呢？**
其实有个东西叫Miller-Rabbin，貌似是一个基于概率的算法，反正能用~~一些神奇的操作~~判断出当前这个数是不是质数，是不是感觉和普通筛法的某一步有点相似——如果这个数是质数那么就筛去这个数的倍数，但是如果这个数没被筛过还是得用神奇的Miller-Rabbin判断一下。~~关于神奇的Miller-Rabbin请查询百度~~
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int prime[3]={2,7,61};
bool yes[1000003];
long long pow(long long a,long long b,long long mod)
{ 
  long long cnt=1;
  a=a%mod;
  while (b)
  {
  	if (b&1) cnt=cnt*a % mod;
	b>>=1;
	a=a*a%mod; 
  }
  return cnt;
}
bool MR(long long x)
{
  long long r,q=0,cnt,tot;
  if (x<2) return false;
  for (int i=0;i<3;i++)
   {
    if (x==prime[i]) return true;
    if (x%prime[i]==0) return false;
   }
  r=x-1;
  while (!(r&1))
  {
  	r>>=1;
  	q++;
  }
  for (int i=0;i<3;i++)
   {
   	tot=q;
   	cnt=pow(prime[i],r,x);
   	while (tot)
   	{
	  if (cnt*cnt%x==1 && cnt!=1 && cnt!=x-1) return false;
	  cnt=cnt*cnt%x;
	  tot--;	
    }
    if (cnt%x!=1) return false;
   }
  return true;
}
long long l,r,ans;
int main()
{
  memset(yes,true,sizeof(yes));
  scanf("%lld%lld",&l,&r);
  for (long long i=l;i<=r;i++)
  {
   if (!yes[i-l+1]) continue;
   if (MR(i))
   {
   long long j=i+i;
   while (j<=r)
   {
   	yes[j-l+1]=false;
   	j=j+i;
   }
   ans++;
   }
  }
  printf("%lld\n",ans);
  return 0;
}
```



---


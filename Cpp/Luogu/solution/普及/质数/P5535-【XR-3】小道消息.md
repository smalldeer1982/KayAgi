# 【XR-3】小道消息

## 题目描述

小 X 想探究小道消息传播的速度有多快，于是他做了一个社会实验。

有 $n$ 个人，其中第 $i$ 个人的衣服上有一个数 $i+1$。小 X 发现了一个规律：当一个衣服上的数为 $i$ 的人在某一天知道了一条信息，他会在第二天把这条信息告诉衣服上的数为 $j$ 的人，其中 $\gcd(i,j)=1$（即 $i,j$ 的最大公约数为 $1$）。在第 $0$ 天，小 X 把一条小道消息告诉了第 $k$ 个人，小 X 想知道第几天时所有人都会知道这条小道消息。

可以证明，一定存在所有人都知道了这条小道消息的那一天。

提示：你可能需要用到的定理——[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)。

## 说明/提示

【样例 $1$ 说明】

$3$ 个人的衣服上的数分别为 `2 3 4`。

在第 $0$ 天，小 X 把一条小道消息告诉了第 $1$ 个人，他的衣服上的数为2。

在第 $1$ 天，第 $1$ 个人会告诉第 $2$ 个人，因为 $\gcd(2,3) = 1$，但他不会告诉第 $3$ 个人，因为 $\gcd(2,4) = 2 \ne 1$。

在第 $2$ 天，第 $2$ 个人会告诉第 $3$ 个人，因为 $\gcd(3,4) = 1$，这时所有人都知道了这条小道消息，因此答案为 $2$。

## 样例 #1

### 输入

```
3 1
```

### 输出

```
2
```

## 样例 #2

### 输入

```
6 4
```

### 输出

```
1
```

# 题解

## 作者：Tarsal (赞：52)

我又双叒叕被包菜辣！

[P5535 【XR-3】小道消息](https://www.luogu.org/problem/P5535)（~~这道题是个大水题~~

在题干中这位良心的作者就提醒了我们：

你可能需要用到的定理——伯特兰-切比雪夫定理。

那么什么是伯特兰-切比雪夫定理？

我也不知道，但~~无所不知的度娘知道就行了~~：

若整数n > 3，则至少存在一个质数p，符合n < p < 2n − 2。另一个稍弱说法是：对于所有大于1的整数n，存在一个质数p，符合n < p < 2n。

那么这个定理有什么用？

因为是从n中选一个数k，所以k + 1一定大于1

是不是刚好和伯特兰-切比雪夫定理的条件相吻合？

没错，我们想一下，分两种情况：

1.如果k + 1为质数，再分两种：

I.1~n中不含k+1的倍数，那么很明显第一天就可以了

II.1~n中含k+1的倍数，那么需要几天？

两天，为什么？因为在第一天，所有除去k + 1倍数的数都知道了，那么gcd((2 * (k + 1)), (2 * (k + 1)) + 1) = 1是一定的。所以只需要两天。

2.如果k + 1不是质数：

也是两天，告诉拥有k+1的质数编号的人，然后通过伯特兰-切比雪夫定理n > 3，存在p 符合n < p < 2 * n；

蒟蒻可能讲的不是很清楚，大家多多包涵，自己可以感性理解一下。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long //一定要开long long，不开long long 见祖先 

int n, k;

bool prime(int x)//很清晰的质数筛 
{
	if(x == 1)//特判一下1 
		return 0;
	if(x == 2)//特判一下2 
		return 1;
	for(int i = 2; i <= sqrt(x); ++ i)//就是枚举每个数，看看它是否是它的约数 
		if(x % i == 0)//如果不是的话 
			return 0;//直接return false 
	return 1;
}

signed main()
{
	scanf("%lld%lld", &n, &k);
	if(prime(k + 1) && 2 * k >= n)//其实，也很好理解，想一想，如果一个数是质数那么是不是除去它的倍数的数都与它互质？所以prime(k + 1)是判断它是不是质数，后面就是找有没有它的倍数（因为是连续的所以只有比一下大小即可 
		printf("1");
	else//除去1的答案就是二了（会有解释 
		printf("2");
	return 0;
}
```

PS：~~请看懂再抄~~

---

## 作者：chinaxjh (赞：21)

# 前言
这是一道签到级别的数论好题，不过出题人着实良心，把伯特兰-切比雪夫定理都告诉你了，这道题就送分了
# 思路
### 对于伯特兰-切比雪夫定理

若整数$n$ $>$ $3$，则至少存在一个质数$p$，符合$n$ < $p$  <$2n$ − $2$。另一个稍弱说法是：对于所有大于$1$的整数$n$，存在一个质数$p$，符合$n$ < $p$ <$2n$。(摘自百度百科)

我们只需要知道稍弱的说法就可以过掉这道题
## 分析
我们分两种情况：质数和合数

下文中的$n$,$k$与题目中的含义一致
### 质数
#### 第一种情况
显然，对于一个质数而言，它与所有不是它的倍数的数互质，于是我们可以得到一个显而易见的结论：当
$$[\frac{n}{2}]<k<n$$ 
且$k$为质数时可得只需要$1$次就可以完成任务，因为没有数是它的倍数，由于它自身是质数，所以它必然与所有小于$n$的数互质
#### 第二种情况
我们再考虑第二种情况，当
$$k\leq[\frac{n}{2}]$$ 
且$k$为质数时,由于有数为它的倍数，显然不互质，所以不可能一次完成，由于伯特兰-切比雪夫定理可知，一定有一个质数$n$ $<$ $p$ $<$ $2n$，两个质数一定互质，所以最后又回到了第一种情况，所以一共需要 $1$+$1$=$2$ 次。
### 合数
对于一个合数，显然一开始不与所有数互质，由伯特兰-切比雪夫定理可知一定有
$$[\frac{n}{2}]<p<n$$
$p$为质数,显然这个合数不是$p$的倍数，与$p$互质，这是第一步，然后再由质数的第一种情况得出一共需要 $1$+$1$=$2$次。
# AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
bool prime(long long x)
{
	long long i;
	for (i=2;i<=sqrt(x);i++)
	if (x%i==0) return false;
	return true;
}//判断素数
int main()
{
	cin>>n>>k;
	if (prime(k+1))
	{
		if ((n+1)/(k+1)==1) puts("1");//对应质数的情况1
		else puts("2");//对应质数的情况2
	}
	else puts("2");//合数就是两步
}
```
# 复杂度
#### 时间复杂度
$$O(\sqrt{k+1})$$
#### 空间复杂度
$$O(1)$$
# Tips
两年$OI$一场空，一场$long$ $long$见祖宗

题目中说了$n$和$k$要加$1$再运算

---

## 作者：infinities (赞：10)

[更佳的阅读体验](https://www.luogu.org/blog/209547/solution-p5535)

此题是在某C\*\*\*\*OJ(不打广告)举办的X Round 3 的原题，思路其实并不难，首先， 我们根据n和k的性质和大小分为几种情况：

1. k+1为质数并且1~n中不含k+1的倍数(倍数中不含k+1本身)

2. k+1为质数并且1~n中含k+1的倍数

3. k+1不为质数

- 对于第一条，易证得只需一步所有人即可知道消息

- 对于第二条，可证得只需2步所有人可知道消息

- 因为不管怎样，k+1总是大于等于二，这样第一步所有编号不为k+1的倍数的人即可知道消息，然后因为X和X-1,X+1总是互质，第二步即可确保所有人知道消息

- 对于第三条，根据题目提供的[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)，也易证得仅需两步所有人可知道消息

- 因为第一步将告诉一个拥有大于k+1的质数编号的人，并且同时告诉该质数编号的倍数所代表的人，或该倍数的前后两位自然数所代表的人

- 证得可能不够完善，请轻喷

所以代码就简单了，根据上述条件判断即可：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool prime(long long k){
	if(k%2==0&&k!=2)return 0;
	if(k==2||k==3)return 1; 
	for(long long i=3;i*i<=k;i+=2){
		if(k%i==0)return 0;
	}
	return 1;
}//判断质数，这里用到了最朴素也最简单的写法，比较慢，各位dalao可以更改写法
long long n,k;//记住，有不少题不开long long见祖宗
int main(){
    /*ios::sync_with_stdio(false);*/ //慎用
	cin>>n>>k;//输入
	if(prime(k+1)){//开始进行判断啦
		if(k>n/2)cout<<"1\n";else
		if(n%2==0&&k==n/2)cout<<"1\n";
		else
		cout<<"2\n";
	}else cout<<"2\n";//判断全部结束
    return 0;
}
```
代码贴出来仅供参考，最好还是自己写，提升代码能力

---

## 作者：Scrutiny (赞：3)

# 这是一道数论题
首先来分析题意：

第$i$个人会告诉第$j$个人消息当且仅当$gcd(i+1,j+1)=1$

如果暴力膜你，显然会TLE

于是我们联想到质数：如果$i+1$是质数，

辣么若$i|j$，则第$i$个人不会传给第$j$个人。

否则第$i$个人会传给第$j$个人

由此可见，衣服上的数是质数的人传的消息是很多的。

首先上一段判断质数的代码：

```cpp
bool isprime(long long x){
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0){
			return 0;
		}
	}
	return 1;
}
```
如果数$x$是合数，则设$x=yz(1<y≤z)$，则$x≥y^2$

即$x$必有一个$≤x^\frac{1}{2}$的约数。

换句话说，若不存在一个正整数$i$使$1<i≤sqrt(x)$且$i|x$，则$x$是质数

回到题目：

情况$1$:如果$k+1$是质数且$[2,n+1]$中除$k+1$外没有其他$k+1$的倍数即$2k+2>n+1$也就是$k>\frac{n-1}{2}$

则第$k$个人会在第一天把消息传给其余所有人，输出$1$；

情况$2$:如果$k+1$是质数且$[2,n+1]$中除$k+1$外有其他$k+1$的倍数

则第$k$个人会在第一天把消息传给衣服上的数不是$k+1$的倍数的其余所有人，而衣服上的数是$k+1$的倍数的人在第$2$天必会被某个人传到消息（否则，存在$i$使$gcd(i,j)≠1$,其中$j$是$[2,n+1]$上任意正整数，珂以得到$j>[2,n+1]$上所有质数的乘积$>n+1$，矛盾），故两天内所有人得到消息，输出$2$

情况$3$:如果$k+1$是合数，则$k+1≥4$

由[切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)，存在质数$p$使$\frac{n+1}{2}<p<n+1$

由$k≤n$，$k+1$没有在$(\frac{n+1}{2},n+1)$上的约数

第$k$人第一天就会传消息给第$p-1$人,而第$p-1$人第二天传消息是符合情况$1$的，故$2$天即可让所有人都知道了这条小道消息

综上：除情况$1$时输出$1$以外其他情况输出$2$

## AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
bool isprime(long long x){
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0){
			return 0;
		}
	}
	return 1;
}
int main(){
	long long n,k;
	cin>>n>>k;
	if(isprime(k+1)&&n+1<2*k+2){
		cout<<1;
		return 0;
	}
	cout<<2;
	return 0;
} 
```
### TIPS:

1.不开long long 见祖宗

2.判断素数时间复杂度一定不能超过上述代码

~~3.要抄窝的题解理解后再抄~~

---

## 作者：　　　吾皇 (赞：3)

一开始没有什么思路 直到发现答案只有1,2两种可能
### 题目分析
1.当n为一个素数时，gcd(a,n)必定为1 ( 满足a$\in${1,2,$\ldots$2n-1}&&a!=n )。

2.否则不难发现，当2×(k+1)$\in${1,2,$\ldots$n}时,gcd(k+1,2×(k+1))!=1，即一次并不能把消息传遍所有数；否则当2×(k+1)$\notin${1,2,$\ldots$n}时，$\sum_{i=1}^n gcd(i,{k+1})$必定为${n+k}$ 即k+1与除自己本身以外的数互质，那么答案为1

3.因此，如果k+1是一个合数，必定有一个它的因数a使得gcd(a,n)!=1

所以根据1,2，必定有一个素数与(k+1)互素，所以需要2次

附:对3的说明 根据伯特兰·切比雪夫定理，当2$\times$(k+1)$\in${1,2,$\ldots$n}时，必定有一个质数p满足 k+1$\lt$p$\lt$2k+2，屡次迭代必然有一个质数p满足2p$\gt$n 从而推得p与1-n的非自己本身的数互质 因此gcd(k+1,p)=1 第一次必然可以将消息传给p 所以需要2次

------------
 - 综上，只要判断k+1是否为素数及2*(k+1)是否大于n即可
 ### 伪代码
 ```
如果(k+1是质数){
    如果(2*(k+1)大于n) 1;
    否则 2;
}
否则 2;
```
### 这边给一段判断素数的方法
跑的挺快 别人700ms,这里只要70ms（空格貌似被吞了）
```cpp
#define il inline 
#define un unsigned
#define ll long long
ll n,k;
const int times = 10;
ll Random(ll n){return ((double)rand()/RAND_MAX*n+0.5);}
il ll q_mul(ll a, ll b, ll mod){
    ll z=(long double)a/mod*b;
    ll res=(un ll)a*b-(un ll)z*mod;
    return (res+mod)%mod;
}
il ll q_pow(ll a,ll b,ll mod){
    ll ans=1;
    while(b)
    {
        if(b&1) ans=q_mul(ans,a,mod );
        b>>=1;
        a=q_mul(a,a,mod);
    }
    return ans;
}
il bool witness(ll a,ll n){
    ll tem=n-1;
    int j=0;
    while(!(tem&1)){
        tem>>=1;
        j++;
    }
    ll x=q_pow(a,tem,n);
    if(x==1||x==n-1) return true;
    while(j--)
    {
        x=q_mul(x,x,n);
        if(x==n-1)return true;
    }
    return false;
}
il bool miller_rabin(ll n){
    if(n==2)return true;
    if(n<2||n%2==0)return false;
    for(register int i=1;i<=times;i++){
        ll a=Random(n-2)+1;
        if(!witness(a,n))return false;
    }
    return true;
}
```
用的是Miller_rabin算法 复杂度大概为O(k $log^3$ n),k是我们测试的不同的a的值

---

## 作者：james1BadCreeper (赞：2)

数据范围：    
$2 \le n \le 10^{14}$    
$1 \le k \le n$

$O(n)$都跑不过，所以这题肯定有规律，那就先打个暴力来找找规律吧。

```cpp
//抱歉，本蒟蒻不会写随机生成数据
#include<cstdio>
#include<iostream>
using namespace std;
int n,k;
bool a[1005],aa[1005];
int gcd(int x,int y)
{
	if(y==0) return x;
	return gcd(y,x%y);
}
bool check(void)
{
	for(register int i=1;i<=n;i++)
		if(!a[i]) return 0;
	return 1;
}
int main(void)
{
	int ans=0;
	scanf("%d%d",&n,&k);
	a[k]=aa[k]=1;
	while(!check())
	{
		ans++;
		for(register int i=1;i<=n;i++)
		{
			if(a[i])
			{
				for(register int j=1;j<=n;j++)
					if(gcd(i+1,j+1)==1) aa[j]=1;
			}
  		}
  		for(register int i=1;i<=n;i++)
			a[i]=aa[i];
	}
	printf("%d",ans);
	return 0;
}
```

然而惊喜的发现，无论怎样造数据，结果要么就是$1$要么就是$2$。

所以接下来就要开始找规律。

想要让$1$次就让所有人知道消息，若$gcd(x,y)=1$，也就是说$x$，$y$互质。很容易想到，在当$x$是一个质数时，只有$ax$($a$为参数，$a>0$）与$x$互质，想要让满足$y \le n$的$y$全部与$x$互质，那么必须满足$2x<n$。    
一句话，当$2x<n$且$x$是质数时，$1$次消息传播就能让所有人知道消息。

简单考虑一下其它情况，绝对不可能$1$次消息传播就能让所有人知道消息，也就是需要传播$2$次。

所以可以写出代码：
```cpp
#include<cstdio>
#include<cmath>
#include<string>
#define ll long long
using namespace std;
inline ll read(void)
{
    ll x=0;
    register int ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x;
}
inline bool is_prime(ll x)
{
	if(x<=1) return 0;
	if(x==2) return 1;
	ll s=sqrt(x)+1;//务必
	for(ll i=2;i<=s;i++)
		if(x%i==0) return 0;
	return 1;
}
int main(void)
{
	ll n=read(),k=read();
	n++;
	k++;
	is_prime(k)&&(k<<1)>n?puts("1"):puts("2");
	return 0;
}
```

---

## 作者：你锡白大爷 (赞：2)

# 真蒟蒻弱发题解
#### ~~这是真的一道大水题~~
为撒子嘞，因为优秀的作者给了我们这段话：

### 提示：你可能需要用到的定理——伯特兰-切比雪夫定理。
那这个伯特兰-切比雪夫定理啥子的四撒子累？

虽然大家都不知道这是撒玩意，但是有万能的度娘啊！

~~**——作者还很棒的给了链接——**~~

以下是这什么鬼定理的定义：**伯特兰—切比雪夫定理说明：若整数n > 3，则至少存在一个质数p，符合n < p < 2n − 2。另一个稍弱说法是：对于所有大于1的整数n，存在一个质数p，符合n < p < 2n。**

但是，你会发现，这个定理一直没什么卵用……
再看看题目中的数据范围：2≤ n ≤ 10^14 2≤n≤10^14，循环一遍那就完了。对于我这个菜鸡，首先想到的就是暴力枚举一哈子。很巧的发现一个个神奇的答案们：所有数据的答案，不是1就是2！【一度怀疑是不是算错了】

### 不多废话，以下是分析

#### 为什么会出现上述的情况呢？

## 我们分两种情况：质数和合数
1. **质数**

   		I. 显然，对于一个质数而言，它与所有不是它的倍数的数互质，于是我们可以得到一个显而易见的结论：当(n/2)<k<n且k为质数时易可得只需1次就可以完成
        原理：没有数是它的倍数！又由于它是个质数，所以它自然与所有小于n的数互质
		II.当且k为质数时,由于有数是它的倍数，显然他们不互质，所以不可能一次完成，由于伯特兰-切比雪夫定理可知，一定有一个质数n<p<2n，这两个质数一定互质，所以最后又回到了第一种情况，所以一共需要1+1=2次鸭。
2. **合数**
		
        对于一个合数，显然一开始不与所有数互质，由伯特兰-切比雪夫定理可知一定有(n/2)<p<n，p为质数,显然这个合数不是p的倍数，与p互质，这是第一步，然后再由质数的第一种情况得出一共需要 1+1=2次。
        
# AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k;
bool prime (long x)
{
	if(x==1)
	{
		return 0;
	}
	if(x==2)
	{
		return 1;
	}
	for(int i=2;i<=sqrt(x);i++)
	{
		if(x%i==0)
		{
			return 0;
		}
	}
	return 1;
} 
int main ()
{
	cin>>n>>k;
	if(prime(k + 1) && 2 * k >= n)
	{
		cout<<1;	
	}
	else
	{
		cout<<2;
	}
	return 0;
}
```
## 对了，找质数那段里i<=一定是sqrt(x)，不然会崩！！

---

## 作者：小小小朋友 (赞：2)

#### 题目描述:

有 $n$ 个人，其中第 $i$ 个人的衣服上有一个数 $i+1$。当一个衣服上的数为 $i$ 的人在某一天被访问了，满足 $gcd(i,j)=1$的人会在第二天被访问。问多久所有人会被访问。

还给了个伯特兰-切比雪夫定理

这个定理可以看百度百科

#### 思路:

基本数论，如果$k+1$为质数，那么如果$k\times 2+1>n$，就说明一天就可以了。否则答案即为2，是因为那个定理，必有一个素数可以被访问，并且它能直接把所有的都访问

注意$longlong$
#### 代码:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,k;
bool is_prime(ll x){
	if(x==1) return false;
	if(x==2) return true;
	for(ll i=2;i<=sqrt(x);i++){
		if(x%i==0) return false;
	}
	return true;
}
int main(){
	scanf("%lld%lld",&n,&k);
	if(is_prime(k+1)&&(2*(k+1)>n+1)){
		printf("1\n");
	}
	else printf("2\n");
	return 0;
}

```

---

## 作者：the_same_prayers (赞：1)

## 这是一道裸的 _Miller Rabin素数测试_ 模版题
### 思路：
判断k+1是否为质数：

- 若是质数，判断n+1是否大于2*k+2。若大于，则k与所有数互质，需要1天；否则存在几个数（该数倍数）无法立刻传达，需要2天。

- 不是质数则一定要两天。

一般用根号n判质数。

### 优化

对于10^14的数据，根号n（10^7）判断质数也能过，但如果数字再大一点就完全没法，这里就需要一（亿）点前置知识：

[**Miller Rabin素数测试**](https://www.cnblogs.com/zwfymqz/p/8150969.html)、[**快速幂**](https://xuanwo.io/2015/03/18/number-theory-quick-pow/)与[**龟速乘**](https://www.cnblogs.com/qxyzili--24/p/11235649.html)（龟速乘是为了防溢出，具体可以去学学这三篇博客，侵删）

虽然说这道题可能用不到，可真正想要学好数论的OIer请尽量要学会前者，因为很方便（而后二者是数论所需要的基本知识，一般认为是必须学会的），miller rabin判素数的时间复杂度极小，大概是O（klog（n））k一般取十。

附上ac代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long int n,m;
long long slow(long long a,long long m,long long n)
{
	if(m==0)return 1;
	if(m==1)return (a%n);
	long long w=slow(a,m/2,n);
	w=(w+w)%n;
	if(m&1)w=(w+a)%n;
	return w;
}
long long modular_exp(long long a,long long m,long long n)
{
	if(m==0)return 1;
	if(m==1)return (a%n);
	long long w=modular_exp(a,m/2,n);
	w=slow(w,w,n);
	if(m&1)w=slow(w,a,n);
	return w;
}
bool miller_rabin(long long n)
{
	if(n==1)return false;
	if(n==2)return true;
	for(int i=0;i<10;i++)
	{
		srand(time(NULL));
		long long int a=rand()%(n-2)+2;
		if(modular_exp(a,n,n)!=a)return false;
	}
	return true;
}
int main()
{
	cin>>n;cin>>m;
	if(miller_rabin(m+1)&&n+1<2*m+2)
	{
		cout<<1;
	}
	else cout<<2<<endl;
} 
```
即使龟速乘加上快速幂，一共也只用了146ms哟~


---

## 作者：Terraria (赞：1)

## ~~水~~一道黄题！

由于良心的出题人，给了一个提示——[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)，使其难度直降。

所以这个定理到底是什么呢？简单来讲，就是：

>若整数$n$ > $3$，则至少存在一个质数p，符合$n$ < $p$ < $2n$−$2$。

>另一个稍弱说法是：对于所有大于 $1$ 的整数 $n$，至少存在一个质数p，符合 $n$ < $p$ < $2n$。

所以——这个定理有什么用呢？开始快乐的推理——

以输入样例 $#2$ 为例：

第$0$天，小X告诉给了第5个人。

第$1$天，由于 $gcd(5,2)=1$，$gcd(5,3)=1$，$gcd(5,4)=1$，$gcd(5,6)=1$，$gcd(5,7)=1$，所以第$5$个人就传给了第$2$、$3$、$4$、$6$、$7$个人。这时候则全部传完，故为一天。

分析完数据后，再理一下思路：

假设传给了第$k$个人，那么其编号则为$k+1$，对于这个编号有以下几种情况：

## k+1为质数：

#### **1**.在1~n中，不含有与k的最大公因数不为1的情况，那么很明显第一天就可以了

#### **2**.在1~n中，含有与k的最大公因数不为1的情况。那么我们知道，所有满足$gcd(i,k)=1$的第 $i$ 个人都已经知道了这个消息。接下来怎么弄？——没事，我们有伯特兰-切比雪夫定理：一定有一个质数 $p$ 满足 $n<p<2n$ ，且两个质数一定互质，因此就有回到了前一种情况，也就是只要再有一天就可以全部知道。

## k+1为偶数：

#### 其实和质数的第二种情况类似，也就是需要两天。

但是，你觉得就这么完了吗？这可是黄题啊！~~事实上是这样的~~

温馨提示：$2\leq n\leq 10^{14}$，开 $long$ $long$！

代码就不给了，相信看懂了的都能写出来！

---

## 作者：Coding__QAQ (赞：0)

####  真的是道好题 !



首先可以猜测，这题的答案不超过2，因为当$(k+1)$与其余数互质时，在1天内即可传递所有人，但如果范围内有$(k+1)$的倍数，则需要2天。当$(k+1)$不为质数时，则其质因数必定在范围内，传递信息也需要2天，所以我们特判一下就好了。

蒟蒻刚做时素数筛没开$long long$，被卡了很久……

AC代码（很简单不需要注释）：
```
#include<bits/stdc++.h>
using namespace std;
bool judge(long long n)
{
    if(n==1) return false;
    if(n==2||n==3) return true;
    if(n%6!=1&&n%6!=5) return false;
    for(register long long i=5;i*i<=n;i+=6)
        if(n%i==0||n%(i+2)==0) return false;
    return true;
}
long long n,k;
int main()
{
	scanf("%lld%lld",&n,&k);
	if(judge(k+1))
	{
		if(2*(k+1)<=n+1)
			printf("2");
		else printf("1");
	}
	else printf("2");
	return 0;
}
```



---

## 作者：Believe_R_ (赞：0)

### 传送门：[P5535](https://www.luogu.org/problem/P5535)

大家题目都看得差不多了，这道题题目也不是多么难懂……

作者好心在**题目描述**最后加了一句话：`提示：你可能需要用到的定理——伯特兰-切比雪夫定理。` 

上网查了一下，所谓的**伯特兰-切比雪夫定理**也就是下面一句话：

> 对于一个大于 $1$ 的整数 $n$，至少存在一个质数 $p$，符合 $n < p < 2n$ 



#### 但是，你会发现，一开始做题时，这个定理一直用不上……~~【难道是我太菜了？】~~

再看看题目中的数据范围：$2 \le n \le 10^{14}$ ，循环一遍老早T飞了。对于这么菜的我，首先想到的就是造几组数据。很巧的发现，所有数据的答案，不是 $1$ 就是 $2$！~~【难道是我的运气太好了？】~~



### 不多废话，以下是分析

为什么会出现上述的情况呢？

1. 可以想一下，如果这个数 $k$ 和序列中所有的数的 $\gcd$ 都是 $1$，那么这个数 $k$ 首先肯定是一个质数；其次保证了在这个序列中最大的数也没有这个质数 $k$ 两倍这么大！即 $n \le 2k$ 。

2. 如果不满足以上条件，那么就只要 $2$ 步就可以完成！至于为什么，我并没有用那个`伯特兰-切比雪夫定理`，而是用了一个简单的反证法……

   > 假设存在一个数 $m$ 要 $3$ 步才能消去。
   >
   > 那么对于一个合数 $k$，那么第 $1$ 步就会把 $k$ 所有的约数和倍数删去。（此时 $m$ 还未消去）
   >
   > 第 $2$ 步这些约数就会把与它们互质的数消去。因为 $m$ 要第 $3$ 步才能消去，所以 $m$ 与这些约数并不互质！所以 $m$ 与 $k$ 并不互质！
   >
   > 所以 $m$ 应该在第 $1$ 步就删去了，这就矛盾了！
   >
   > 所以 $2$ 步就完事了！



##### 特别提示，这里一定要开`long long`，$n$ 最大可达 $10^{14}$！

以下为`c++`代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, k;

int Judge(int x)
{
    if(x==1) return 0;
    if(x==2) return 1;
    for(int i=2;i<=sqrt(x);++i) if(x%i==0) return 0;
    return 1;
}

signed main()
{
    scanf("%lld%lld",&n,&k);
    if(Judge(k+1) && 2*(k+1)>n+1) printf("1\n");
    else printf("2\n");
    return 0;
}
```



---

## 作者：_stellar (赞：0)

### 分类讨论。

对于当前选定的点的**值**$k$，我们可以分成两种情况：

#### $\texttt{1.k为质数}$

根据题意有，如果两个数$a,b$满足$gcd(a,b)==1$，那么可以传递信息。

那么对于一个值$i(i∈[2,n+1]$且$i!=k)$。

若$i<k$，那么两者互质，完全可以传递。

若$i>k$，我们考虑**下一个可以被质数i表示出的合数**，很显然，是$k*2$。那么我们就可以判断当前集合中是否包含$k*2$这个元素，即判断：

$$k>n/2$$

若集合中不包含该元素，那么集合内**所有元素都不能被k这个质数表示**，显然1天就可以完成任务。

否则，集合$[k*2,n+1]$范围内的数会被放在第$2$天计算。当然，这个区间内的元素数量大大小于$[2,k*2)$的元素数量，而**每个数又至少存在一个跟它互质的质数**，所以剩余的数完全可以在第2天被表示出来。


#### $\texttt{2.k为合数}$

对于合数k，其因子是不固定的，所以并不容易解决。

但是题目中给出了[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)。其广义形式为：


$\texttt{当x>3时[x,2x]一定存在素数}$

我们把$x$替换成$x/2$，那么转换为当$x>6$时，$[x/2,x]$上一定存在素数，而合数$k$与该素数$m$互质，故两者传递需要1天，而我们又刚刚证明，当$m>n/2$时，所有其他数都与其互质。故总共需要$1+1=2$天传递完成。

哦，还有$n<=6$的情况呢，那就手算吧。


顺便说一句，筛素数可以再优化，常数可以卡到最小。我这个筛已经能跑到$rank6$了，$rank1$的位子你们慢慢抢吧(

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define rep(i,l,k) for(int i=l;i<=k;i++)
ll n,k;
ll ip(){
    ll x=0,w=0;char ch=0;
    while(!isdigit(ch)) w|=ch=='-',ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return w?-x:x;
}
bool is_prime(ll x){
    if(x==1) return 0;
    if(x==2||x==3) return 1;
    if(x%6!=1&&x%6!=5) return 0;
    ll temp=sqrt(x);
    for(ll i=5;i<=temp;i+=6){
        if(x%i==0||x%(i+2)==0) return 0;
    }
    return 1;
}
int main(){
    n=ip(),k=ip();n++;k++;
    if(is_prime(k)){
        if(k>n/2) return puts("1"),0;
        puts("2");
    }
    else{
        n--;
        if(n>6) puts("2");
        if(n==2) puts("1");
        if(n==3) puts(k==2?"1":"2");
        if(n==4) puts(k==2||k==4?"1":"2");
        if(n==5) puts(k==4?"1":"2");
        if(n==6) puts(k==4||k==6?"1":"2");
    }
    return 0;
}
```



---

## 作者：auroral (赞：0)

这道题吗，当时打XR-3的时候看着定理发蒙
[伯特兰-切比雪夫定理](https://baike.baidu.com/item/%E4%BC%AF%E7%89%B9%E5%85%B0-%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%AE%9A%E7%90%86/2053704)这是啥玩意。

后来突然发现~~经过我多次罚时发现~~，原来结果只有1和2，并且只需要再判一个素数。

不多说了，上代码
```cpp
#include<iostream>
#include<cmath>
#define ll long long
using namespace std;
ll n,k,num;
bool pan(ll a){
	for(ll i=2;i<=sqrt(a);i++)//判断素数 
	if(a%i==0)
	return false;//除得尽 return false 
	return true;//都除不尽就return true 
}
int main(){
	cin>>n>>k;
	k++;n++;//预处理一下 
	if(pan(k)==1&&k>n/2)
	cout<<1;//是素数并且k>n/2就输出1 
	else cout<<2;//else就输出2 
	return 0;
}
```


---

## 作者：Cylete (赞：0)

# 一道数论（~~又做了半天，数论太菜~~）

伯特兰-切比雪夫定理？？？

本蒟蒻表示不懂

看数据10^14

线性复杂度肯定不可以

于是本蒟蒻推了半天公式

最后水了一波数据

发现答案不是 1 就是 0

因为题目中第i个人身上的数字为i+1

为了便于叙述

先把n和k先加1

直接表示衣服上的数字

发现如果k是质数且2*k>n

那么只要1次所有人都知道消息

反之要2次所有人都知道消息

附上代码

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
long long n,k;
bool check(long long x){//判断质数
	for(long long i=2;i<=sqrt(x);i++){
		if(x%i==0)return false;
	}
	return true;
}
int main(){
	cin>>n>>k;
	k++; n++;//先处理
	if( check(k) && 2*k>n )cout<<"1"<<endl;
	else cout<<"2"<<endl;
	return 0;
}
```
大概这就是伯特兰-切比雪夫定理？

---


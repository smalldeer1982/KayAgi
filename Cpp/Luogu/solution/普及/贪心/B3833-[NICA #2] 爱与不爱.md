# [NICA #2] 爱与不爱

## 题目背景

是爱还是厌　是爱还是厌\
啦啦啦啦~\
勉勉强强着　勉勉强强着\
啦啦啦啦啦~

## 题目描述

小 Ran 有一个长度为 $n$ 的正整数序列 $a$，她可以进行如下操作任意多次（包括零次）：

- 选择两个不同的数 $i,j$（$1\le i,j\le n$），然后将 $a_i$ **除以 $2$ 后下取整**，将 $a_j$ 乘二。要求操作完毕后的 $a_i$ 必须为正整数。

小 Ran 希望使序列的总和**最小**。输出最终序列的总和。

## 说明/提示

数据保证，$2\le n\le 10^5$，$1\le a_i\le 10^9$。

## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
12```

## 样例 #2

### 输入

```
6
1 1 4 5 1 4```

### 输出

```
12```

# 题解

## 作者：Light_Star_RPmax_AFO (赞：5)

## 	[NICA #2] 爱与不爱

### $\mathcal{Update\ 2024.3.13} $ 

简化一下思路。

#### 前言

本题第一篇题解。

[传送门](https://www.luogu.com.cn/problem/B3833)

### 题目描述

给出一个 $n$ 和一个序列 $a$，你可以让 $a_i(i \in [1,n])$ 变成 $\lfloor \frac{a_i}{2} \rfloor (\lfloor \frac{a_i}{2} \rfloor \ne 0)$ 并且将 $a_j(j \in [1,n])$ 变成 $a_j \times 2$，求序列和的最小值。

注：$\log_2 n$ 代表 $n$。

### 简化思路

考虑将所有数优化到最小值：

随便选取两个数 $n, m$，则可以先将其中一个数的权值赋给另一个数，最终会得到 $1,m \times 2^{\lfloor\log_2 n\rfloor}$ 同理，我们最后可以化为 $2^{\lfloor\log_2 n\rfloor}, 2^{\lfloor\log_2 m\rfloor}$，当我们有 $2, 8$ 时，易得有贪心思路。

> 让他们差尽可能最小化。

抽屉原理，当数列为 $x, y, z$ 时，我们总共会有 $\lfloor\log_2 x\rfloor+\lfloor\log_2 y\rfloor + \lfloor\log_2 y\rfloor$ 个 $2$ 可以分配，差最小，合理分配即可。

## 思路

我们可以思考若 $a_i = 2 \times 5 \times 9$，那么 $a_i$ 变成后最小的 $a_i = 2 ^ {(\lfloor\log_2 2\rfloor + \lfloor \log_2 5\rfloor + \lfloor\log_2 9\rfloor)}$，也就是 $Min = 2^{\lfloor\log_2 a_i \rfloor}$。

那么我们就可以得到最小的 $\prod_{i = 1}^n a_i$，也就是原序列中的 $2^{\sum_{i = 1}^ n \lfloor\log_2 a_i\rfloor}$。 

> 积不变，差小和小。

我们考虑分配这些 $2$，最后得到的就是平分后的数 $sum$ 和剩余的 $2$ 的个数 $cnt = {\lfloor\log_2 {(\prod_{i = 1}^n a_i)}\rfloor} - sum \times n$，再将 $cnt$ 个 $2$ 分到每个值中，所组成的式子 $2^{sum} \times (n - cnt) + 2^{sum + 1} \times cnt$。

#### 警钟敲烂

不开 `long long` 见祖宗。

## AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

inline int read(){
	int x = 0,f = 1;char ch = getchar();
	while (ch < '0' || ch > '9'){if(ch == '-') f = -1;ch = getchar();}
	while (ch >= '0' && ch <= '9'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

inline int _2(int x){
	int ans = 0;
	while(x != 1){
		x >>= 1;
		ans++;
	}
	return ans;
}

int n, ans, a;

signed main(){
	n = read();
	for(int i = 1;i <= n;i++)
		a = read(),ans += _2(a);
	int sum = ans / n, cnt = ans - (sum * n);
	cout << (1 << sum) * (n - cnt) + (1 << sum + 1) * cnt;
    return 0;
}

```

---

## 作者：NightStriker (赞：4)

## B3833 [NICA #2] 爱与不爱 题解

贪心题。

首先将一个正整数不断除到 $1$，接下来不断对其进行翻倍操作，把其他的正整数一个一个除到 $1$。

此时这个正整数的大小为 $2^x$，也就是说我们有 $x$ 个 $2$ 可以分配。

我们将所有的 $2$ 分配均匀，就可以取到最小总和（证明：琴生不等式）。

注意一定要开 long long，否则爆零。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[100001],sum;
signed main(){
	cin>>n;
	for(int i = 1;i<=n;i++){
		cin>>a[i];
		sum+=__lg(a[i]);
		a[i] = 1;
	}
	while(sum>0){
		for(int i = 1;i<=n;i++){
			a[i]*=2;
			sum--;
			if(sum<1) break;
		}
	}
	int cnt = 0;
	for(int i = 1;i<=n;i++) cnt+=a[i];
	cout<<cnt<<endl;
	return 0;
} 

```



---


# [GESP202409 五级] 挑战怪物

## 题目描述

小杨正在和一个怪物战斗，怪物的血量为 $h$，只有当怪物的血量**恰好**为 $0$ 时小杨才能够成功击败怪物。

小杨有两种攻击怪物的方式：
- 物理攻击。假设当前为小杨第  $i$ 次使用物理攻击，则会对怪物造成 $2^{i - 1}$ 点伤害。
- 魔法攻击。小杨选择任意一个质数 $x$（ 不能超过怪物当前血量），对怪物造成 $x$ 点伤害。由于小杨并不擅长魔法，他只能使用**至多一次**魔法攻击。

小杨想知道自己能否击败怪物，如果能，小杨想知道自己最少需要多少次攻击。

## 说明/提示

### 样例 1 解释

对于第一组测试用例，一种可能的最优方案为，小杨先对怪物使用魔法攻击，选择质数 $5$ 造成 $5$ 点伤害，之后对怪
物使用第 $1$ 次物理攻击，造成 $2^{1 - 1} = 1$ 点伤害，怪物血量恰好为 $0$，小杨成功击败怪物。

### 数据规模与约定

| 子任务编号 | 分数占比 | $t$ | $h$ |
| :-: | :-: | :-: | :-: |
| $1$ | $20\%$ | $\leq 5$ | $\leq 10$ |
| $2$ | $20\%$ | $\leq 10$ | $\leq 100$ |
| $3$ | $60\%$ | $\leq 10$ | $10^5$ |

对于全部的测试数据，保证 $1 \leq t \leq 10$，$1 \leq h \leq 10^5$。

## 样例 #1

### 输入

```
3
6
188
9999```

### 输出

```
2
4
-1```

# 题解

## 作者：Hootime (赞：13)

_一道水黄，秒了。——[yuruilin2026](https://www.luogu.com.cn/user/1294410)_
## 思路
首先，只要 $n$ 有解，$n$ 总能表示为 $(2^k-1)$ 或 $(2^k-1)+m$（$m$ 为质数）的形式。

那么，枚举 $k$，对于每个 $k$ 判断即可。

## 代码
### 注释版

```cpp
#include <bits/stdc++.h>
using namespace std;
inline bool is_prime(int n){ // 判质数
    if(n < 2) return false;
    for(int i = 2; i*i <= n; i++) if(n % i == 0) return false;
    return true;
}
int t, n;
bool flag;
int main(){
    scanf("%d", &t);
    while(t--){
        flag = false;
        scanf("%d", &n);
        for(int i = 0, now = 0; now <= n; ++i, now = now<<1 | 1){ // now 为 2^k-1
            if(n - now == 0){ // 2^k-1
                printf("%d\n", i);
                goto next; // 下一个测试点
            }
            else if(is_prime(n-now)){ // 2^k-1+m
                printf("%d\n", i+1);
                goto next; // 同
            }
        }
        puts("-1"); // 无解
        next:;
    }
}

```
### 无注释版

```cpp
#include <bits/stdc++.h>
using namespace std;
inline bool is_prime(int n){
    if(n < 2) return false;
    for(int i = 2; i*i <= n; i++) if(n % i == 0) return false;
    return true;
}
int t, n;
bool flag;
int main(){
    scanf("%d", &t);
    while(t--){
        flag = false;
        scanf("%d", &n);
        for(int i = 0, now = 0; now <= n; ++i, now = now<<1 | 1){
            if(n - now == 0){
                printf("%d\n", i);
                goto next;
            }
            else if(is_prime(n-now)){
                printf("%d\n", i+1);
                goto next;
            }
        }
        puts("-1");
        next:;
    }
}

```

---

## 作者：yuruilin2026 (赞：8)

_一道更水的黄题。_\
同机房的大佬 [Hootime](https://www.luogu.com.cn/user/1275540) 如此说道。\
那么话不多说，上思路。\
对于每一个怪物，我们假设小杨会先使用物理攻击，再使用魔法攻击。

---

Q：为什么呢？\
A：为什么？难道先用魔法攻击再用物理攻击造成的伤害不是一样的吗？

---

因为要求最小的攻击次数，所以我们选择的质数应该尽量的大。\
当物理攻击到 $i$ 次的时候，剩下的血量是一个质数，那就可以直接结束游戏了。\
因为越早的物理攻击伤害越低，那么剩下的质数就应该是最大的了。\
那么，上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int t,h;//样例数 
bool prime(int x){
	//判断质数的函数
	//有一个小优化(蒟蒻没学到数学必修一,不会证)
	//所有的大于5的质数都可以写成(6n+1)和(6n-1)的形式
	//写正常的判断质数的函数就可以了
    int fx[2] = {2,4};
	if(x == 1 || x == 4){
		return 0;
	}
	if(x == 2 || x == 3){
		return 1;
	}
	if(x % 2 == 0){
		return 0;
	}
	if(x % 3 == 0){
		return 0;
	}
	for(int i = 5,p = 0;i * i <= x;i+=fx[p],p=!p){
		if(x % i == 0) return 0;
	}
	return 1;
}
int main(){
	cin.tie(0);//cin加速 
	cin >> t;
	while(t--){
		int l = 1,i = 0;//这次物理攻击的伤害,轮数 
		cin >> h;
		while(h > 0){
			if(prime(h)){//如果剩下的血量是质数 
				cout << i+1 << endl;//+1是因为要再攻击一次 
				break;
			}
			h -= l;//减少血量 
			i++;//增加轮数 
			l *= 2;//增加伤害 
		}
		if(prime(h)){//如果剩下的血量是质数(刚刚输出过了)
			continue;
		}
		else if(h < 0){//小于0,说明不能击败怪物(能击败早就击败了)
			cout << -1 << endl;
		}
		else{//特判只用物理攻击就可以的情况 
			cout << i << endl;
		}
	}
	return 0;
}
```

---

## 作者：Cute_QiQi (赞：5)

# solution

计划着结束之后就去重做这道题的，怎么现在才想起来。

题目要尽可能减少次数，那不就是尽可能让使用魔法的数字更大。我们需要一个算法把所有可用的质数都罗列出来方便随时用，而这个算法就是质数筛。

得到质数之后，就是不断减去 $2$ 的几次方，直到第一次剩下的数为质数。这样使魔法被最大化利用了，也肯定是最节省的策略了。

过程中 $h$ 是负数就说明失败了，输出 `-1`。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    int x=0,F=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            F=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x*F;
}
void write(int x)
{
    if(x<0)
        putchar('-'),x=-x;
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
    return;
}
const int N=1E5;
vector<int> prime;
bool isprime[N+5];
void work(int n)
{
	memset(isprime, 1, sizeof isprime);
	isprime[0]=isprime[1]=0;
	for(int i=2; i<=n; ++i)
	if(isprime[i])
	{
		prime.push_back(i);
		for(int j=i*i; j<=n; j+=i)
		isprime[j]=0;
	}
}
signed main(){
	//泥嚎，写题吧骚年
	work(N);
	for(int t=read(); t; --t)
	{
		int h=read(), now=1, ans=0;
		while(1)
		{
			++ans;
			if(isprime[h])break;
			h-=now;
			if(h==0)break;
			if(h<0)
			{
				ans=-1;
				break;
			}
			now<<=1;
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

祝大家 CSP 取得好成绩，逢考必过！（本人 j260 低调路过）

---

## 作者：jiangyunuo (赞：4)

### 题目大意：

有一个 $h$ 血量的怪兽，只有当这只怪兽血量为 $0$ 时，它才会死。有两种攻击方法，物理和魔法攻击（具体介绍见题目）。问：我们最少要花多少下攻击才能杀死这只怪兽。

### 大体思路：

可以发现，样例中的攻击顺序是可以倒过来的，我们可以先物理攻击再魔法攻击，我们可以发现不管第 $i$ 发物理攻击什么时候用（指的是它先用还是魔法攻击先），它永远是只能造成 $2^{i-1}$ 的伤害，但魔法攻击可能就会有变化，因为有些质数就不再能选了。

也就是说，我们应该把握好利用魔法攻击的时间，要保证用完魔法攻击后，物理攻击可以把怪兽干掉（当然，有些情况下不用魔法攻击），前面说了，物理攻击何时用都一样，因此我们可以把魔法攻击留到给怪兽的最后一击，注意：此时交换物理攻击和魔法攻击的顺序结果不变，因为魔法攻击原本的值掉到后面，怪兽的血量正好就是这个值。

当我们使用完物理攻击后，我们要判断怪兽的血量是否为质数，如果是，就可以用魔法攻击直接解决，反之接着物理攻击，如果某一时刻怪兽血量少于 $0$，那么就是无解了。

### 代码：

```cpp
#include<bits/stdc++.h>  
using namespace std;
bool zs(int a){
	if(a==1)return 0;
	for(int i=2;i<=sqrt(a);i++){
		if(a%i==0)return 0;
	}
	return 1;
}
int main(){
    int t;
    cin>>t;
    int h;
    while(t){
    	t--;
    	cin>>h;
    	if(zs(h)){cout<<1<<endl;continue;}
    	for(int i=1;i>=1;i++){
    		h-=pow(2,i-1);
    		if(h<0){cout<<-1<<endl;break;}
    		if(h==0){cout<<i<<endl;break;}
    		if(h>0&&zs(h)){cout<<i+1<<endl;break;}
		}
	}
    return 0;
}
```

---

## 作者：luojingjie (赞：4)

# 题解：B4050 [GESP202409 五级] 挑战怪物
## 思路
每次使用物理攻击，知道怪物血量为质数，就魔法攻击一次。如果血量没了还未出现质数，那么就是不可击败。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,h;
bool f(int a){
    if(a==1){
        return false;
    }
    for(int i=2;i*i<=a;i++){
        if(a%i==0){
            return false;
        }
    }
    return true;
}
int main(){
    cin>>t;
    while(t--){
        cin>>h;
        int cnt=1,w=1;
        while(h>0){
            if(f(h)){
                cout<<cnt<<endl;
                break;
            }
            h-=w;
            if(h==0){
                cout<<cnt<<endl;
                break;
            }
            w*=2;
            cnt++;
        }
        if(h<0){
            cout<<-1<<endl;
        }
    }
    return 0;
}
```

---

## 作者：sjh0626 (赞：2)

## 题意概括
给定你一个整数 $N$，你可以执行以下两种操作：

1. 假如第 $i$ 次使用这种操作，就会使 $N$ 变为 $N - 2^{i-1}$。
2. 你**只能**使用 $1$ 次这种操作，你可以选择一个质数 $x$（$x \le N $），使 $N$ 变为 $N - x$。

但是，在 $N \le 0$ 时你就不能攻击了，请求出你最小需要操作的次数。
## 思路分析
虽然你**只能**使用 $1$ 次魔法攻击，但是物理攻击可以使用无限次。

所以我们可以一直使用物理攻击，直到 $N$ 为质数或者 $N \le 0$。

但是会有个坑点，$N = 1$ 时不需要使用魔法攻击，所以在 $N = 1$ 时答案为 $1$。
## 代码解析
```cpp
#include<bits/stdc++.h>
#define sjh0626s return
#define code 0
using namespace std;
int t,n,h;
bool is_prime(int n){
	if(n==1)return 0;
	if(n==2)return 1;
	for(int i=2;i<=sqrt(n);i++){
		if(n%i==0)return 0;
	}
	return 1;
}
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		h=0;
		if(n==1){
			cout<<"1\n";
			continue;
		}
		while(!is_prime(n)&&n){
			n-=round(pow(2,h));
			h++;
		}
		if(n<0)cout<<-1<<"\n";
		else cout<<h+1<<"\n";
	}
	sjh0626s code;
}
//188=>60=>26=>10=>2=>0
```

---

## 作者：helongyun (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4050)

**前言：这道题其实没有看上去那么复杂，只需暴力即可**

# 题目大意
给定 $t$ 个怪物血量，可以运用以下两种攻击方式：

1. 物理攻击。假设当前为小杨第 $i$ 次使用物理攻击，则会对怪物造成 $2^{i-1}$ 点伤害。
2. 魔法攻击。小杨选择任意一个质数 $x$，对怪物造成 $x$ 点伤害（不可以超过怪物血量）。由于小杨并不擅长魔法，他只能使用**至多一次**魔法攻击。

每个怪物必须**恰好**血量为零时才算死，问每个怪物是否可以打死它。
# 思路分析
每一次给一个怪物血量，现对其使用物理攻击，之后再判断其是否是素数，如果是，直接对其使用魔法攻击，输出物理攻击次数加一即可，如果血量已经为负数，证明无法杀掉，输出负一即可。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long b[30]={0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,131072};//记录2的1-17次方
long long n,x;
bool zs(long long x)
{
	if(x<=1) return 0;
	for(long long i=2;i*i<=x;i++)
	{
		if(x%i==0) return 0;
	}
	return 1;
}//判断其是否是素数
int main()
{
	cin>>n;
	for(long long i=1;i<=n;i++)
	{
		cin>>x;
		if(x==1)
		{
			cout<<1<<endl;
			continue;
		}//特判1
		if(zs(x)==1)
		{
			cout<<1<<endl;
			continue;
		}//如果是素数，直接输出1
		for(int i=1;i<=17;i++)
		{
			x-=b[i];//进行一次物理攻击
			if(zs(x)==1)
			{
				cout<<i+1<<endl;
				break;
			}//如果是素数，输出i+1
			if(x<0)
			{
				cout<<-1<<endl;
				break;
			}//如果已经为负数，输出-1
		}
	}
}
```

---

## 作者：abc1234shi (赞：1)

# 题意
最优方案：这个数减去某个质数后是 $2$ 的某次幂到 $2$ 的 $1$ 次幂之和。

次优方案：这个数是 $2$ 的某次幂到 $2$ 的 $0$ 次幂之和。

无解：这个数不满足前两个条件。
# 思路
我们先考虑这个数减去某个质数后等于 $2$ 的某次幂到 $2$ 的 $0$ 次幂之和。

我们从 $h$ 枚举到 $1$ 枚举出质数（从大到小是最好的），然后让 $h$ 减去这个质数。看此时的 $h$ 是否是 $2$ 的某次幂（设为 $n$）到 $2$ 的 $1$ 次幂之和（这个应该不难实现），如果是，输出 $n+1$。

如果不满足第一点，就看第二点，看 $h$ 是否是 $2$ 的某次幂（设为 $n$）到 $2$ 的 $0$ 次幂之和（这个更不难实现了），如果是输出 $n$，否则就无解了，输出 $-1$。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int zhishu(int x){
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0)return 0;
	}
	return 1;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int h;
		cin>>h;
		int sum=0,falg=0,s;
		for(int i=h;i!=0;i--){
			if(zhishu(i)==1){
				sum++;
				s=h;
				s-=i;
				while(s>0){
					s-=pow(2,sum-1);
					sum++;
				}
				if(s==0){
					falg=1;
					cout<<sum<<endl;
					break;
				}
			}
			sum=0;
		}
		s=h;
		if(falg==0){
			while(s>0){
					s-=pow(2,sum-1);
					sum++;
				}
			if(s==0){
					falg=1;
					cout<<sum<<endl;
			}
			else{
				cout<<-1<<endl;
			} 
		}
    }
}
```

---

## 作者：guer_loser_lcz (赞：1)

# 题解
## 思路
因为攻击的顺序不影响伤害（假设我们已经知道要用魔法攻击打多少伤害）总值，所以我们可以将攻击流程看作先用物理打 $i$ 次，使怪物生命值为质数，然后一发入魂。

现在的主要问题是用线性方法筛质数，即用线性筛。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,h;
bool f[100100];
int main(){
	cin>>t;
	f[1]=1;
	for(int i=2;i<=100000;i++){
		if(f[i]==0){
			for(int j=i*2;j<=100000;j+=i){
				f[j]=1;
			}
		}
	}
	while(t--){
		cin>>h;
		int a=1,ans=0;
		while(f[h]==1&&h>=a){
			h-=a;
			ans++;
			a*=2;
		}
		if(h>0){
			if(f[h]==0)cout<<ans+1;
			else cout<<-1;
		}
		cout<<endl;
	}
	return 0;
} 
```
## 后置芝士
线性筛大致运行过程为：划掉所有 $2$ 的倍数，再划掉下一个没被划掉的数的倍数，即 $3$ 的倍数，以此类推；

[这里](https://oi-wiki.org/math/number-theory/sieve/)有详细讲解。

---

## 作者：niuniudundun (赞：1)

# 原题

[B4050](https://www.luogu.com.cn/problem/B4050)

# 题目大意

一个数 $h$ 每次操作有对 $h$ 进行减去 $2^{i-1}$ **或**减去一个质数，为 $0$ 停止，求操作次数。

# 解法

step1. 如果 $h$ 是质数，则直接输出 $ans$ （操作次数）。

step2. 如果不是减去 $2^{i-1}$ ，并且 $ans\longrightarrow ans+1$。

step3. 如果 $h$ **小于** $0$ ，说明不可击败怪物。

step4. 如果 $h$ **等于** $0$ ，输出 $ans$ 。

step5.重复步骤。

# 问题

## 魔法攻击

题目中说：

>至多一次魔法攻击。

众所周知质数均为奇数（这里不讨论 $2$ ），有两种情况：

$h$ 为奇数，奇数减奇数等于偶数，那么在后面操作中会被物理攻击（减去 $2^{i-1}$ ）中变成 $0$ 。

但是在程序中，如果 $h$ 已经是质数那么会被魔法攻击变成 $0$ ； $h$ 不是质数，那么**一定**会被 $2^0$ 变为偶数。

$h$ 为偶数，答案为奇数，减完后一定会被 $2^{0}$ 再变为偶数，然后在后面操作中会被物理攻击（减去 $2^{i-1}$ ）中变成 $0$。

但是在程序中， $h$ 会被物理攻击（减去 $2^{i-1}$ ），变为 $2$ 或 $0$ 。如果结果 $h$ 为 $2$ ，也会被魔法攻击变成 $0$。

如果 $h$ 为 $2$ ，也会被魔法攻击变成 $0$。

所以只能进行一次魔法攻击（减去质数）。

# 代码

```cpp
#include<iostream>
using namespace std;
int t;
const int maxn=1e5+1;
bool prime[maxn];
int main(){
	cin>>t;
	for(int i=2;i<=maxn;i++){//处理质数
		prime[i]=true;
	}
	for(int i=2;i<=maxn;i++){
		if(prime[i]){
			for(int j=i*2;j<=maxn;j+=i){
				prime[j]=false;
			}
		}
	}
	for(int i=1;i<=t;i++){
		int ans=0;
		int h;
		cin>>h;
		for(int j=1;1;j*=2){//计算ans
			if(prime[h]){//魔法攻击
				ans++;
				break;
			}
			h-=j;//物理攻击
			ans++;
			if(h<0){
				ans=-1;
				break;
			}
			if(h==0){
				break;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

复杂度：$\Theta \left ( t\log_{2}{h}  \right ) $。

---

## 作者：__UrFnr__ (赞：1)

**题目思路**：我们不断判断 $h$ 是否是一个质数，若 $h$ 不为质数，我们进行物理攻击，$h$ 减去这个攻击值，答案加一。若 $h$ 为质数，答案加一，退出当前，进入下一组数据的模拟。还要加上两个特判，若 $h<0$，则输出 $-1$，退出当前，进入下一组数据的模拟；若 $h=0$，直接输出答案，退出当前，进入下一组数据的模拟。具体思路实现见代码。

代码如下：


```cpp
#include <bits/stdc++.h>
using namespace std;
int t;
bool is_prime (int x) {//判断质数
	if (x < 2) return 0;
	for (int i = 2; i * i <= x; i ++) 
		if (x % i == 0) 
			return 0;
	return 1;
}
int main () {
	cin >> t;
	while (t --) {
		int h, ans = 0, cnt = 0;
		cin >> h;
		while (1) {//模拟攻击
			cnt ++;//模拟i
			if (! is_prime (h)) h -= pow (2, cnt - 1), ans ++;//若h不为质数，进行物理攻击
			else {//若h为质数，证明一次即可消灭怪物
				ans ++; 
				cout << ans << '\n';
				break;
			}
			if (h == 0) {//特判，因为有的情况不用魔法攻击即可消灭这个怪物
				cout << ans << '\n';
				break;
			}
			if (h < 0) {//特判，h不能小于0，小于了证明不能消灭这个怪物
				cout << "-1\n";
				break;
			}
		}
	}
	return 0;
}

```

---

## 作者：CSP_JAKME (赞：1)

# 前言

这题赛时是有点思维难度的，想五级至少 80 分就要通过这题。

# 分析

因为题目说了，小杨只能使用**至多一次**魔法攻击，所以说这个魔法攻击我们就把它看得很珍贵，能不用就不用，怪物血量为质数时，就一下把他干掉，不然就用物理攻击。\
换句话说，物理 + 魔法 + 物理 = 魔法 + 物理 + 物理 = 物理 + 物理 + 魔法。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool prime(int x){
    for(int i=2;i*i<=x;i++){
        if(x%i==0) return false;
    }
    return true;
}
int main(){
    int t;
    cin >> t;
    while(t--){
        int n;
        bool flag=false;//标记血量是否被打到0
        cin >> n;
        int w=1,ans=0;//w表示物理攻击伤害，ans是答案
        while(n>0){
            if(n<=0) break;//没血量了，退出
            if(prime(n)){//是个质数，一击必杀
                ans++;
                flag=1;
                break;
            }
            n-=w;//否则就是物理伤害
            w*=2;//伤害翻倍
            ans++;//次数加一
        }
        if(flag) cout << ans;//如果打死了就输出结果
        else cout << -1;//否则输出-1
        cout << endl;
    }
    return 0;
}
```

---

## 作者：Just_A_Sentence (赞：1)

# 题目大意

给定一个整数 $n$，你可以进行以下两种操作

- 操作 $1$，当你第 $i$ 次进行操作 $1$ 时，可以使 $n$ 减去 $2^{i-1}$。

- 操作 $2$，使 $n$ 减去任意一个质数，**此操作最多只能进行一次**。

问能否将 $n$ 正好减到 $0$。若可以，输出最少操作次数；若不行，输出 $-1$。

# 题解

考虑到操作 $2$ 只能进行一次，所以我们可以枚举操作 $1$ 的次数，判断剩下的数是否为质数

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool isprime[100005];
int main(){
	int T;
	for(int i=2;i<=100000;i++) isprime[i]=true;
	for(int i=2;i<=100000;i++){
		if(isprime[i]){
			for(int j=i+i;j<=100000;j+=i) isprime[j]=false; 
		}
	}
	scanf("%d",&T);
	while(T--){
		int n;
		scanf("%d",&n);
		if(isprime[n]||n==1){//特判，若n本来就为质数或n为1，直接输出1。
			printf("1\n");
			continue;
		}
		for(int i=1;(1<<(i-1))<=n;i++){//枚举操作1的次数
			n-=1<<(i-1);
			if(isprime[n]){
				printf("%d\n",i+1);
				goto abc;//如果剩下的数是质数，输出并退出。
			}
		}
		printf("-1\n");//如果无论进行几次操作1都无法满足条件，输出-1。
		abc:
			;
	}
	return 0;
}
```

---

## 作者：AIregister (赞：0)

## 思路 ##
我们先不管三七二十一看看他是不是质数，是的话就一次魔法，否则的话就直接每次减去 $2^{i - 1}$ 把次数加一直到 $x$ 变为零就输出次数，如果出现负数，直接输出 $-1$ 即可。
## 代码 ##
```cpp
#include <bits/stdc++.h>
using namespace std;
int prime[100010];
bool isp[100010];
int cnt = 0;
int main() {
	int n;
	cin >> n;
	isp[0]  = false;
	isp[1] = false;
	for (int i = 2; i <= 100000; i++) {
		isp[i] = true;
	}
	for (int i = 2; i <= 100000; i++) {
		if (isp[i] == true) {
			prime[++cnt] = i;
			if ((long long)i * i > 100000) {
				continue;
			}
			for (int j = i * i; j <= 100000; j += i) {
				isp[j] = false;
			}
		}
	}//整素数
	for (int i = 1; i <= n; i++) {
		int tmp = 1;
		int x;
		cin >> x;
		int ans = 0;
		while (true) {
			if (isp[x]) {
				ans++;
				break;
			}//可不可以魔法
			x -= tmp;
			ans++;
			if (x <= 0) {//判断是否退出
				if (x < 0) {
					ans = -1;
				}
				break;
			}
			tmp *= 2;
		}
		cout << ans << endl;//大功告成
	}
}
```

---

## 作者：SSqwq_ (赞：0)

## 分析

题目中给了我们两种操作，但是加法满足结合律，所以我们可以把两种操作拆开来看，即先进行若干次操作一，再进行一次操作二。

朴素模拟即可。时间复杂度 $O(A \log A+ T\log n)$，其中 $A$ 为值域。可以通过本题。

## AC Code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=100000;
int n,t,np[100001];
void init(){
	np[1]=1;
	for(int i=2;i<=N;++i){
		if(np[i])continue;
		for(int j=2;i*j<=N;++j){
			np[i*j]=1;
		}
	}
}
void work(){
	cin>>n;
	t=0;
	while(n>0){
		if(!np[n]){
			cout<<t+1<<"\n";
			return;
		}
		n-=(1<<t);
		t++;
	}
	if(n==0){
		cout<<t<<"\n";
		return;
	}
	cout<<-1<<"\n";
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	init();
	int T=1;
	cin>>T;
	while(T--){
		work();
	}
	return 0;
}

```

---


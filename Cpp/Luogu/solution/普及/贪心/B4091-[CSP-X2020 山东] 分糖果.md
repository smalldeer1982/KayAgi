# [CSP-X2020 山东] 分糖果

## 题目背景

老师组织一群孩子围成一个圈进行游戏，游戏结束后老师会根据每个孩子的表现进行评分并给予糖果奖励。

## 题目描述

每个孩子只能看见与自己相邻的 $2$ 个孩子（左边的和右边的）的情况，只会关心相邻的且比自己评分低的同学的糖果数（如果相邻 $2$ 个孩子的评分相等，则不关心）。为保证公平，相邻的孩子中，评分高的孩子必须获得更多的糖果(如果左右相邻 $2$ 个孩子的评分相等，则不关心，即分最少的糖果 $1$ 个）。同时，为鼓励孩子的积极性，每个孩子至少都能拿到 $1$ 个糖果。现在需要你帮助老师来分发糖果，问怎么分配才能使要准备的糖果数最少？计算出需要的最少糖果数。

## 说明/提示

【数据范围】

对于 $40\%$ 的数据，$1\leq n\leq 100$；

对于 $100\%$ 的数据，$1\leq n\leq 10^5$;

所有评分都是 $0$ 到 $100$ 之间的一个整数。

【样例解释】

样例一，分别分配 $2,3,1$ 的糖果，所以最少需要 $6$ 个糖果。

样例二，分别分配 $1,2,1,2$ 的糖果，所以最少需要 $6$ 个糖果。

## 样例 #1

### 输入

```
3
1 2 0```

### 输出

```
6```

## 样例 #2

### 输入

```
4
2 3 3 3```

### 输出

```
6```

# 题解

## 作者：SkyLines (赞：6)

## Solution

首先，给所有孩子 $1$ 个糖果。

然后，调整若干次。对于每一次调整 $i,j$（$j$ 为 $i$ 后一个人）而言，当前不公平的有两种情况：

* $i$ 的表现评分比 $j$ 小，且 $i$ 的糖果大于等于 $j$。

* $i$ 的表现评分比 $j$ 大，且 $j$ 的糖果大于等于 $i$。

显然，要使糖果总数最小，两种情况的调整分别如下：

* $j$ 的糖果比 $i$ 多 $1$ 个。

* $i$ 的糖果比 $j$ 多 $1$ 个。

最后，将所有孩子得到的糖果相加即为答案。

不难证明，不会出现 $a_1<a_2< \dots <a_n<a_1$ 的情况，即不会无限循环。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int n, a[N], cnt[N], j, ans;
bool flg;
signed main(){
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++){
		scanf("%lld", &a[i]);
		cnt[i] = 1;
	}
	while(1){
		flg = 0;
		for(int i = 1; i <= n; i++){
			j = ((i == n) ? 1 : (i + 1));
			if(a[i] < a[j] && cnt[i] >= cnt[j]){
				cnt[j] = cnt[i] + 1;
				flg = 1;
			}else if(a[i] > a[j] && cnt[j] >= cnt[i]){
				cnt[i] = cnt[j] + 1;
				flg = 1;
			}
		}
		if(!flg) break;
	}
	for(int i = 1; i <= n; i++) ans += cnt[i];
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：lam_dyr (赞：3)

# B4091 [CSP-X2020 山东] 分糖果 题解
## 题意
有一群孩子围成一个圈，每个孩子都有一个积分。你需要给每个孩子分发糖果，满足以下条件：

- 每个孩子至少要得到一颗糖果。
- 如果一个孩子的评分比他相邻的下一个孩子高，并且他的糖果数小于等于下一个孩子的糖果数，那么他的糖果数必须增加 1。
- 孩子是围成一个圈的，所以第一个孩子和最后一个孩子是相邻的。

求满足条件所需要的最小糖果数。

## Solution
首先给每个孩子一人一块糖果，接着一直循环，每次遍历所有孩子。如果这个孩子的积分比下一个孩子的积分多，但糖相等或更少，则给这个孩子的糖果数量加一。每进行完一次循环更新一遍答案，如果这次和上次的答案一样就终止。

为什么这样做能使总糖果数最少呢？因为在每次遍历中我们只在最低条件下满足。

因为孩子是环形的，注意先特判首尾。
## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100010;
int n,a[N],ans[N],minn=1e9;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
		ans[i]=1;
    }
    while(true){
        if(ans[1]<=ans[n] && a[1]>a[n]) ans[1]++;
		if(ans[n]<=ans[1] && a[n]>a[1]) ans[n]++;
		for(int i=1;i<=n;i++){
		    if(ans[i]<=ans[i+1] && a[i]>a[i+1]) ans[i]++;
		    if(ans[i]>=ans[i+1] && a[i]<a[i+1]) ans[i+1]++;
		}
		int res=0;
		for(int i=1;i<=n;++i) res+=ans[i];
		if(res==minn) break;
		minn=res;
    }
    cout<<minn;
    return 0;
}
```

---

## 作者：_zhaosihan_qwq_ (赞：1)

# 题解：B4091 [CSP-X2020 山东] 分糖果
## 思路分析
1. 创建一个数组，初始值都设为 $1$，表示每个孩子至少能拿到 $1$ 个糖果。
2. 比较相邻孩子的评分，如果当前孩子的评分大于左边相邻孩子的评分，那么当前孩子的糖果数应该比左边孩子的糖果数多，所以计算当前孩子的糖果数为左边孩子糖果数加 $1$。
3. 同样地，比较相邻孩子的评分，若当前孩子的评分大于右边相邻孩子的评分，要保证当前孩子的糖果数大于右边孩子的糖果数，再次计算当前孩子的糖果数。  
4. 将所有孩子的糖果数累加起来，得到最少需要准备的糖果总数并输出。

---

## 作者：CASCwty (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/B4091)

## 思路

首先，如果一个孩子不满足的话，只有两种情况：

1. 他的**评价**比相邻的孩子**少**，但糖果却**比相邻的孩子多**。
2. 他的**评价**比相邻的孩子**多**，但糖果却**比相邻的孩子少**。

那么，针对这些情况，我们可以对这个孩子进行改动，使一个孩子比另一个孩子大 $1$，很显然，这个就是最小的方案。

当然，在跑完一次之后，虽然右边的孩子已经满足了情况，但是左边极有可能是不符合规定的。所以要一直跑，跑到符合规定为止。

最后输出糖果总数即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+10;
int n;
int a[N];
int candy[N];
bool flag=true;
int nxt,lst;
int ans;
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		candy[i]=1;
	}
	while(flag)
	{
		flag=false;
		for(int i=1;i<=n;i++)
		{
			nxt=(i==n)?1:i+1;
			if(a[i]<a[nxt]&&candy[i]>=candy[nxt])
			{
				candy[nxt]=candy[i]+1;
				flag=true;
			}
			else if(a[i]>a[nxt]&&candy[i]<=candy[nxt])
			{
				candy[i]=candy[nxt]+1;
				flag=true;
			}
		}
	}
	for(int i=1;i<=n;i++)ans+=candy[i];
	printf("%lld",ans);
	return 0;
}
```

> 对于一直**不能满足的情况**，即为出现序列为：$h_1<h_2<h_3<\cdots<h_n<h_1$。这是**不会出现**的，因为 $h_1<h_1$ 不正确。

---

## 作者：yyycj (赞：1)

## 题目简述
$n$ 个孩子围成圈，每个人有一个评分，每个人会分到若干个糖果，每个人至少有一个糖果。相邻的孩子中，评分高的必须获得更多的糖果。

求所有孩子糖果数总和的最小值。

## 主要思路
首先为了满足每个孩子至少有一个糖果，先将存储每个孩子糖果数的数组的元素都设为 $1$。

然后可以从 $1 \sim n$ 遍历孩子的评分，每次都去和他右边的孩子比较一下是否满足条件。这样**一轮**下来，就可以解决**一些**不满足要求的地方。不满足要求的情况有以下两种：
- 当前孩子比右边的评分高，但是糖果数却**小于等于**右边的孩子。
- 当前孩子比右边的评分低，但是糖果数却**大于等于**右边的孩子。

为了满足总和最小的情况，所以出现以上两种情况，就只需要在某个孩子的糖果数变成另一个孩子的糖果数加 $1$ 即可。

但是一轮下来，有可能在修改了某个孩子的糖果数后，由于每次只判断他的右边，可能左边的孩子又不满足要求了。要解决这种情况，只需要一直遍历直到所有孩子都满足要求即可。

容易证明，不会出现类似于[彭罗斯阶梯](https://baike.baidu.com/item/%E5%BD%AD%E7%BD%97%E6%96%AF%E9%98%B6%E6%A2%AF/10124603?fr=ge_ala)的情况，即无限循环。（彭罗斯阶梯可以这么理解：有 $n$ 层阶梯，高度为 $h_{1} \sim h_{n}$，然后出现了 $h_{1}<h_{2}$，$h_{2}<h_{3} \cdots$，最后 $h_{n}<h_{1}$ 的情况）。

最后，将所有孩子的糖果数加起来，就是本题的答案。

## AC Code
```cpp
#include<map>
#include<set>
#include<list>
#include<stack>
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#include<unordered_set>
using namespace std;

#define endl '\n'
typedef long long ll;
const int N = 1e5 + 10;
typedef unsigned int ui;
typedef pair<int,int> pii;
typedef unsigned long long ull;
// ----------------------------

// ----------------------------
int candy[N];
int score[N];
// ----------------------------
int read() {
	int f=1,sum=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){sum=(sum<<1)+(sum<<3)+(ch^48);ch=getchar();}
	return sum * f;
}

void print(int x) {
	if(x<0){putchar('-');x=-x;}
	if(x>9)print(x/10);
	putchar(char(x%10+'0'));
}

int main() {
	int n = read();
	for (int i=1;i<=n;i++) score[i] = read();
	// ------------------------
	for (int i=1;i<=n;i++) candy[i] = 1;
	int cnt = 1;       // 用于记录不满足要求的次数
	while (cnt) {
		cnt = 0;
		for (int i=1;i<=n;i++) {
			int r = i % n + 1;
            // 发生不满足要求的两种情况
			if (score[i]>score[r] && candy[i]<=candy[r]) {
				candy[i] = candy[r] + 1;
				cnt++;
			}
			else if (score[i]<score[r] && candy[i]>=candy[r]) {
				candy[r] = candy[i] + 1;
				cnt++;
			}
		}
	}
	int ans = 0;
	for (int i=1;i<=n;i++) ans += candy[i];
	// ------------------------
	print(ans);
	return 0;
}
```

---

## 作者：_xdd_ (赞：0)

首先每个人都有一块糖，接着一直循环，每次遍历，如果这个人的积分比下一个人的积分多，但糖相等或更少，则给这个人的糖果数量 $+1$。形式化的讲，设 $x_i$ 为第 $i$ 个人的糖果数，$a_i$ 为第 $i$ 个人的积分，如果 $a_i > a_{i+1}$ 且 $x_i \le x_{i+1}$ 则 $x_i \leftarrow x_i+1$。如果这次的答案与上一次的相同则退出循环。

因为小朋友是一个环，所以要先处理首尾。


```cpp
#include<bits/stdc++.h>
#define maxn 100000+5
using namespace std;
int n,a[maxn],ans[maxn],last,now;
int main(){
    cin >> n;
    for(int i=1;i<=n;i++){
        cin >> a[i];ans[i]=1;
    }
    while(1){
        if(ans[1]<=ans[n]&&a[1]>a[n]){ans[1]++;}
		if(ans[n]<=ans[1]&&a[n]>a[1]){ans[n]++;}
		for(int i=1;i<=n;i++){
		    if(ans[i]<=ans[i+1] && a[i]>a[i+1]){
		        ans[i]++;
		    }
		    if(ans[i]>=ans[i+1] && a[i]<a[i+1]){
		        ans[i+1]++;
		    }
		}
		now=0;
		for(int i=1;i<=n;i++){
		    now+=ans[i];
		}if(now==last){
		    break;
		}
		last=now;
    }
    cout << now;
    return 0;
}
```

---

## 作者：hjz_0821_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4091)

# 题意
有 $n$ 个学生，老师给他们发糖果。每个学生只能看到旁边两个学生所获得的糖果数量。但是如果一个学生旁边的学生的糖果数量大于等于这个学生的糖果，而且他的积分大于这个学生的，他就需要更多的糖果。

重点：
* 每个学生至少有一个糖果。

* 相邻的孩子中，评分高的孩子必须获得更多的糖果。

* 求最少需要的数量。

## 解题思路

首先分别给每个学生 $1$ 个糖果。

然后循环，检查是否公平。也就是如果 $fs_i$ 比 $fs_i+1$ 大，并且糖果数量要少，那么这个学生的糖果数量就增加 $1$ 个。一个一个增加，最后需要的糖果数量就会更少。

每进行一轮循环，就特判一遍。如果本轮与上一轮相比没有再增加糖果数量，就跳出循环，输出结果。

### 代码

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n,fs[100001],tg[100001];
//fs计分数，tg计每个学生糖果数量 
int ans1,ans2; 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	//以上两行加速输入输出 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>fs[i];
		tg[i]=1;
	}
	//按题意输入 
	while(1){
		ans1=0; 
		if(tg[1]<=tg[n] && fs[1]>fs[n]){
			tg[1]++;
		}//队头特判 
		if(tg[n]<=tg[1] && fs[n]>fs[1]){
			tg[n]++;
		}//队尾特判 
		for(int i=1;i<=n;i++){
			if(tg[i]<=tg[i+1] && fs[i]>fs[i+1]){
				tg[i]++;
			}
			if(tg[i+1]<=tg[i] && fs[i+1]>fs[i]){
				tg[i+1]++;
			}	
		}//队中判断 
		for(int i=1;i<=n;i++){
			ans1+=tg[i];
		}
		if(ans1==ans2){
			break;
		}//特判 
		ans2=ans1;
	}
	cout<<ans1;//输出 
	return 0;
}
```

---

## 作者：little_stickman (赞：0)

# B4091题解
# 主要题意
有 $n$ 个学生，老师给他们分发糖果（每人至少 $1$ 颗）。每个学生只看到旁边两人获得的糖果数量。但是如果一个学生旁边的人糖果数量大于等于这个学生的糖果，而且他的积分大于这个学生的，他就需要更多的糖果。
# 解题思路
我们首先初始化所以的学生都为 $1$ 颗糖果。

接下来一直循环，如果 $a_i$ 比 $a_{i+1}$ 积分大，且糖果数量少，那么这个学生糖果数量就增加，反之亦然。

跳出循环的判断就是如果上一次的统计结果与这一次的没有变更，那么跳出循环并输出结果。
# 上代码！
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100010],x[100010],c_1=114514,c_2=0;
int main(void)
{
	cin>>n;
	for(int i=1;i<=n;i++)//输入数据，初始化所有人一颗糖果 
		cin>>a[i],x[i]=1;
	while(true)//循环 
	{
		if(x[1]<=x[n]&&a[1]>a[n])//特殊判断队头与队尾。 
			x[1]++;
		if(x[n]<=x[1]&&a[n]>a[1])
			x[n]++;
		for(int i=1;i<=n;i++)//其他情况 
		{
			if(x[i]<=x[i+1]&&a[i]>a[i+1])
				x[i]++;
			if(x[i+1]<=x[i]&&a[i+1]>a[i])
				x[i+1]++;	
		}
		c_1=0;
		for(int i=1;i<=n;i++)//统计数量 
			c_1+=x[i];
		if(c_1==c_2)//如果这一次数量与上一次没有变化，跳出循环。 
			break;
		c_2=c_1;
	}
	cout<<c_1;
	return 0;
}
```

---


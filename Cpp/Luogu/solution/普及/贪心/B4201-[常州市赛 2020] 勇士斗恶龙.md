# [常州市赛 2020] 勇士斗恶龙

## 题目背景

搬运自 <http://czoj.com.cn/p/449>。数据为民间数据。

## 题目描述

小 $\text X$ 穿越到了异世界，国王命令他招揽勇士，杀死恶龙，救回公主。  
异世界是高度数据化的。恶龙有一个攻击力 $\text{ATK}$ ，一个生命值 $\text{HP}$ 。类似的，每个勇士也有一个攻击力 $A_i$ ，一个生命值 $H_i$ 。  
战斗是回合制的，并且每次只能由一个勇士和恶龙单挑。战斗中，每个回合恶龙的生命值会减去这个勇士的攻击力，这个勇士的生命值会减去恶龙的攻击力。如果回合结束的时候恶龙的生命值小于等于 $0$，那么恶龙就被杀死了；如果这个勇士的生命值小于等于 $0$，那么这个勇士就被击败了，需要换上另一个勇士继续战斗。当然，如果恶龙还没有被杀死，勇士却全部被击败了，那么这场战役就彻底失败了。  
不过聪明的小 $\text X$ 安排了一个特殊的战术：在一名勇士被击败后立刻让另一名勇士发起攻击，这样恶龙在勇士们的车轮战术下疲于招架，受到第二个勇士的伤害变为两倍，受到第三个勇士的伤害变为三倍……以此类推。  
现在一共有 $n$ 名勇士报名，小 $\text X$ 想问问你，如果合理安排勇士出战的顺序，最少要招揽多少名勇士才能杀死恶龙？

## 说明/提示

### 样例说明
- 两名勇士都招揽。先派出 $2$ 号勇士；  
- 第一回合，恶龙生命值变为 $8$，勇士生命值变为 $0$。勇士被击败；  
- 紧接着派出 $1$ 号勇士；  
- 第二回合，恶龙生命值变为 $4$ （两倍伤害），勇士生命值变为 $1$ ；  
- 第三回合，恶龙生命值变为 $0$ ，勇士生命值变为 $0$ 。恶龙被杀死；  
- 勇士虽然也被击败了，但恶龙已经死了，所以还是胜利了！  
### 数据范围
本题共有 $10$ 个测试点。  
对于所有数据，$1\le n\le 10^5,1\le\text{ATK}, A_i,H_i\le10^6,1\le \text{HP}\le 10^{18}$。  
|测试点编号|$n$|$\text{ATK}, A_i,H_i$|$\text{HP}$|
|:-:|:-:|:-:|:-:|
|$1\sim 4$|$\le 5$|$\le 10$|$\le 100$|
|$5\sim 7$|$\le 10^3$|$\le 10^3$|$\le 10^9$|
|$8\sim 10$|$\le 10^6$|$\le 10^6$|$\le 10^{18}$|

## 样例 #1

### 输入

```
2
1 9
2 2
1 1```

### 输出

```
2```

# 题解

## 作者：Sliarae (赞：2)

首先对于一个勇士 $i$，我们知道它的生命值 $H_i$ 和恶龙的攻击力 $\text{ATK}$ 以后，它的攻击次数就为 $\lceil \frac{H_i}{\text{ATK}} \rceil$。

再进行一步转化：一个人能攻击 $c$ 次，等价于它的攻击力乘 $c$。于是我们令 $A_i = A_i \times \lceil \frac{H_i}{\text{ATK}} \rceil$。此时真正有用的数据只有 $A_{1 \sim n}$ 和 $\text{HP}$，且每个勇士只能进行一次攻击，攻击力为 $A_i$。

将 $A$ 从小到大排序，那么派遣到勇士一定是一段前缀。钦定派遣 $p$ 名勇士，那一定是先派遣 $A_p$，再派遣 $A_{p - 1}$，最后派遣 $A_1$。

发现这样做，总的攻击力为 $A_1 \times p + A_2 \times (p - 1) + \ldots A_p \times 1 = \sum\limits_{i = 1}^{p} A_i \times (p - i + 1)$。如果这个值 $\ge \text{HP}$ 则派遣 $p$ 个勇士合法。

容易发现这个值可以增量维护。从小到大枚举 $p$，一旦当前的 $p$ 合法就输出。假设要从派遣 $p$ 个勇士变成派遣 $p + 1$ 个勇士，那么总攻击力的变化是：

- 由 $A_1 \times p + A_2 \times (p - 1) + \ldots A_{p - 1} \times 2 + A_{p} \times 1$ 变成 $A_1 \times (p + 1) + A_2 \times p + \ldots + A_{p - 1} \times 3 + A_p \times 2 + A_{p + 1}$。

注意到这个变化相当于所有 $A_{1 \sim (p + 1)}$ 的的系数均增加 $1$，总攻击力就增加 $A_1 + A_2 \ldots A_p + A_{p + 1} = \sum\limits_{i = 1}^{p + 1} A_i$。

那么同时维护当前攻击力，和前 $p$ 个数的和即可做到 $O(n)$ 的时间复杂度。当然前面排序是 $O(n \log n)$ 的。

```cpp
#include <iostream>
#include <algorithm>

using namespace std;
using LL = long long;

const int kN = 1e5 + 5; 

int n, atk;
LL hp, a[kN];

int main () {
	cin.tie(0)->sync_with_stdio(0);
	cin >> n >> atk >> hp;
	for (int i = 1, h; i <= n; ++i) {
		cin >> a[i] >> h;
		a[i] *= (h - 1) / atk + 1; 
	}
	sort(a + 1, a + n + 1, greater<LL>());
	LL now = 0, sum = 0; 
	for (int i = 1; i <= n; ++i) {
		now += a[i], sum += now;
		if (sum >= hp) return cout << i << '\n', 0;
	}
	cout << "Fail" << '\n';
	return 0;
}
```

---

## 作者：why17 (赞：1)

第一眼看这个题感觉很简单，但是调了好久才过……

### 题目大意：

恶龙有一个攻击力 $ATK$，还有一个生命值 $HP$。现在有 $n$ 个勇士，每个勇士也有一个攻击力和一个生命值。战斗是回合制，就是恶龙和勇士轮流攻击对方，直到其中一个的生命值小于等于 $0$，此时战斗结束。恶龙被战胜，或者换上另一个勇士接着打。并且现在第 $i$ 个上场的勇士，伤害会变为 $i$ 倍。问最少需要多少个勇士可以打败恶龙，或者无法打败恶龙。

### 解题思路：

首先用结构体储存每个勇士的攻击力和生命值：
```cpp
struct node{
	long long a,h;//a是攻击力，h是生命值
}w[100005];
```
因为现在我们已经知道了恶龙的攻击力和每个勇士的生命值，所以可以算出每个勇士能够坚持的回合数：
```cpp
round=(w[i].h+att-1)/att;//round是回合数
```
这样一来每个勇士能够造成的最大伤害也可以算出来：
```cpp
e[i]=w[i].a*round;//e数组储存每个勇士的最大贡献（即能够造成的最大伤害）
```
根据题意，越靠后上场的勇士得到的攻击加成越高，所以为了最大化伤害，我们肯定要让贡献大的勇士排在后面上场。

于是我们按照这个思路排序：
```cpp
sort(e+1,e+n+1,greater<int>());
```
接下来计算前缀和数组：
```cpp
for(int i=1;i<=n;i++){
  tot+=e[i];
  sum[i]=sum[i-1]+tot;
}
```
最后遍历前缀和数组，一旦发现当前的伤害总值大于恶龙的生命值，就输出当前编号。
```cpp
for(int i=1;i<=n;i++){
  if(sum[i]>=hp){
  cout<<i;
  return 0;
  }
}
```
最后不要忘了考虑无法打败恶龙的情况：
```cpp
cout<<"Fail";
```
进食后人：

**十年 OI 一场空，不开 long long 见祖宗！**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,att,hp;
long long e[100005],sum[100005];
struct node{
	long long a,h;
}w[100005];
int main(){
    cin>>n;
    cin>>att>>hp;
    for(int i=1;i<=n;i++){
    	cin>>w[i].a>>w[i].h;
    	long long round=(w[i].h+att-1)/att;
    	e[i]=w[i].a*round;
	}
	sort(e+1,e+n+1,greater<int>());
	long long tot=0;
	for(int i=1;i<=n;i++){
		tot+=e[i];
		sum[i]=sum[i-1]+tot;
	}
	for(int i=1;i<=n;i++){
		if(sum[i]>=hp){
			cout<<i;
			return 0;
		}
	}
	cout<<"Fail";
    return 0;
}
```

---

## 作者：__Kyw666__ (赞：1)

## 题意解释
有 $n$ 个勇士与恶龙对战，可以对他们的出场顺序排列，第 $i$ 个出场的勇士的攻击翻 $i$ 倍，问最少几名勇士能击败恶龙，无法击败则输出 ``Fail``。

## 思路分析
这题其实二分也行。  
因为是求最小值，所以我第一感觉就是二分。在 $1$ 到 $n$ 区间中对勇士数量进行二分枚举，记录答案，最后输出。  
二分求最小值的模版如下：

```cpp
while(l<=r)
{
	int mid=(l+r)/2;
	if(check(mid)){ans=mid;r=mid-1;}
	else l=mid+1;
}
```
详细代码见下。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll n,atk,hp;
ll l,r,ans;
struct node{
	ll a,h;
}t[100005];
bool cmp(node x,node y)
{
	return x.a*x.h>y.a*y.h;//攻击力 × 血量 
}
bool check(ll m)
{
	ll cnt=1,s1=0,s2=0;//cnt 指回合数 
	while(1)
	{
		s1+=t[m].a*cnt;//当前勇士攻击力 
		if(hp<=s1) return 1;//恶龙寄了 
		s2+=atk;//恶龙攻击力 
		if(t[m].h<=s2)//当前勇士寄了 
		{
			m--,cnt++;//下一个 
			s2=0;//记得置 0 
			if(m==0) return 0;//全寄了 
		}
	}
}
int main()
{
	cin>>n>>atk>>hp;
	l=1,r=n;
	for(int i=1;i<=n;i++) cin>>t[i].a>>t[i].h;
	sort(t+1,t+n+1,cmp);//排序 
	while(l<=r)
	{
		ll mid=(l+r)/2;
		if(check(mid)){ans=mid;r=mid-1;}
		else l=mid+1;
	}//模版 
	if(ans==0) cout<<"Fail";//输了 
	else cout<<ans;
	return 0;
 } 
```

---

## 作者：Clare613 (赞：1)

## 思路
注意，这是一道十分简单的贪心。\
我们可以通过恶龙的攻击力和勇士的生命值和攻击力算出，勇士可以打出多大的攻击力，不难算出，我们设勇士的生命值为 $a$，勇士的攻击力为 $b$，那么勇士的攻击力就是  $(a+\text{ATK}-1)\times b$，这里注意要向上取整 。\
接着就可以排个序，因为要尽量少招揽勇士，所以我们有尽量把攻击力高的先选，并且在已经选了的勇士中尽量向后放。如果全选都无法打败，就输出 "Fail"。
## code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int g[1000005];
signed main(){
	int n,at,hp;
	cin>>n>>at>>hp;
	for(int i=1;i<=n;i++){
		int a,b;
		cin>>a>>b;
		g[i]=(b+at-1)/at*a;
	}
	sort(g+1,g+n+1);
	int sum=0,suum=0;
	for(int i=n;i>=1;i--){
		sum+=g[i];
		suum+=sum;
		if(suum>=hp){
			cout<<n-i+1;
			return 0;
		}
	}
	cout<<"Fail";
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/210306638)

---

## 作者：Yi_chen123 (赞：1)

一道好贪心，也勉强算是前缀和吧……  
## 思路
依照题意，既然勇士的血量为 $H_i$，攻击力为 $A_i$，恶龙的攻击为 $\text{ATK}$，那么勇士一共可以挨恶龙 $\lceil \dfrac{H_i}{\text{ATK}}\rceil$ 次攻击，同时打出 $A_i \times \lceil \dfrac{H_i}{\text{ATK}}\rceil$ 点伤害。  
这时，我们不妨假设第 $i$ 个勇士总共能打出的伤害为 $T_i$ 点（对应代码中的 `tot` 数组），如果我们要派遣若干名勇士，那么由于后面的勇士可以获得伤害加成，因此应该先让总伤害更高的排在前面攻击恶龙。  
令派遣 $i$ 名勇士打出的最高伤害为 $S_i$，（对应代码中的 `sum` 数组）并将 $T = \{T_1,T_2,T_3,\cdots,T_n\}$ 升序排列，根据题目中的伤害倍数加成，很显然有：  
$$
S_i = T_1 \times i + T_2 \times (i-1) + \cdots + T_i \times 1
$$

不过，如果暴力计算 $S$ 序列，$O(n^2)$ 的时间复杂度怕是很难吃住 $n \le 10^6$ 的数据，~~除非你用神威太湖之光~~。  
其实，不难发现，$S$ 序列是有动态转移方程的，用 $O(n)$ 的复杂度即可求解，证明过程也并不困难。  
此时，对于任意一个 $i \in (1,n]$，$S_{i-1}$ 与 $S_i$ 有：
$$
S_i = T_1 \times i + T_2 \times (i-1) + \cdots + T_i \times 1\\
S_{i-1} = T_1 \times (i-1) + T_2 \times (i-2) + \cdots + T_{i-1} \times 1
$$

  观察发现，$S_i$ 中，$T_1$ 到 $T_i$ 的系数都比 $S_{i-1}$ 增加了 $1$，也就是总值比 $S_i$ 增加了 $\sum_{k=1}^{i} T_k$ 不难列出转移方程：
$$
S_i = S_{i-1} + \sum_{k=1}^{i} T_k
$$

至于 $\sum_{k=1}^{i} T_k$ 这个式子，我们可以使用一个前缀和数组维护。  
众所周知，把恶龙打死就赢了，因此我们只需要求出满足 $S_i \ge \text{HP}$ 时的最小 $i$ 值，即是本问题的答案。  
时间复杂度：  
+ 排序：$O(n \log n)$
+ 维护 $S$ 序列并求解：$O(n)$
+ 总复杂度：$O(n \log n + n)$

## 正确代码
```cpp
#include<bits/stdc++.h> 
#define int long long
using namespace std;

struct Knight{
	int a, h;
};
Knight k[1000005];
int sum[1000005], tot[1000005];
signed main(){
    int n, atk, hp;
    cin >> n >> atk >> hp;
    for(int i = 1; i <= n; ++i){
    	cin >> k[i].a >> k[i].h;
    	tot[i] = k[i].a * floor(k[i].h * 1.0 / atk);
	}
	sort(tot + 1, tot + n + 1, greater<int>());
    int x = 0;
	for(int i = 1; i <= n; ++i){
        x += tot[i];
		sum[i] = sum[i - 1] + x;
		if(sum[i] >= hp){
			cout << i;
			return 0; 
		} 
	}
	cout << "Fail"; 
    return 0; 
} 
```

---

## 作者：Manchester_City_FC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/B4201)

### 题目大意
勇士需要轮番攻击恶龙，每个勇士的伤害倍率随顺序递增。我们的目标是找到最少需要多少名勇士，使得他们的总伤害足以击败恶龙。若无法击败则输出 `Fail`。

### 解题思路
我们定义 $k_i$ 表示每个勇士的贡献，即攻击力乘以攻击次数。接下来将勇士按贡献值降序排列，确保优先选择高贡献的勇士。

通过前缀和快速计算前 $k$ 个勇士的最大可能伤害总和。最后二分确定最少需要多少名勇士，使得他们的总伤害满足要求。

时间复杂度 $\mathcal O(n \log n)$，足以通过本题。

### AC 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+1;
int n,p,q,k[N],a[N],s[N],l=1,r,ans=-1;
signed main() {
    cin>>n>>p>>q;
    for(int i=1,x,y;i<=n;i++){
        cin>>x>>y;
        k[i]=x*(y+p-1)/p;
    }
    sort(k+1,k+n+1,greater<int>());
    for(int i=1;i<=n;i++){
        a[i]=a[i-1]+k[i];
        s[i]=s[i-1]+a[i-1]+k[i];
    }
    r=n;
    while(l<=r){
        int mid=l+r>>1;
        if(s[mid]>=q){
            ans=mid;
            r=mid-1;
        }
		else l=mid+1;
    }
    if(ans!=-1) cout<<ans;
    else cout<<"Fail";
}
```

---

## 作者：Ag2WO4 (赞：0)

考虑贪心，即招一命能磨血（为伤害乘以扛刀数）最多的勇士。由于后面的勇士有加成，所以先招募最后的勇士（也是最强的）；由于倍率是线性的，显然想到前缀和优化。复杂度为 $O(n\log n)$。
```python
a=int(input());b,c=map(int,input().split());d=e=0
for i in sorted(map(lambda i:-i[1]//b*i[0],[list(map(int,input().split()))for i in range(a)])):
    d+=i;c+=d;e+=1
    if c<=0:print(e);exit()
print('Fail')
```

---


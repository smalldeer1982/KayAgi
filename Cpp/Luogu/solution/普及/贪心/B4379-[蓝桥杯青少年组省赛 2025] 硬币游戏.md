# [蓝桥杯青少年组省赛 2025] 硬币游戏

## 题目描述

Jerry 和 Tom 正在进行一局游戏。他们准备了 $n$ 个盒子，编号为 $1$ 到 $n$，其中 $i$ 号盒子装有 $a_i$ 枚硬币。他们将这 $n$ 个盒子围成一圈。游戏规则如下：

1. Jerry 和 Tom 轮流从某一个盒子中取走至少一枚硬币，Jerry 先手从 $1$ 号盒子开始取；
2. 如果前一个玩家取的是 $i$ 号盒子中的硬币，那么当前玩家必须从 $i+1$ 号盒子中取硬币。特别地，如果前一个玩家取的是 $n$ 号盒子中的硬币，那么当前玩家必须从 $1$ 号盒子中取硬币。
3. 如果轮到某位玩家时对应盒子中没有硬币，则该玩家失败。

假设 Jerry 和 Tom 都采取最优策略，请问谁会赢？

## 样例 #1

### 输入

```
2
1
10
2
30 50```

### 输出

```
Jerry
Tom```

# 题解

## 作者：zhouzihan20110620 (赞：6)

简单博弈论。

注意到当 $n$ 为奇数时，先手可以直接全部拿完而造成后手必输。

然后我们考虑 $n$ 为偶数，即奇数位全归先手管，偶数位全归后手管，所以哪一堆最先被取完那一堆所属的人就输了，判断最小下标的最小值的下标的奇偶即可。

代码如下：

```cpp
#include <iostream>
using namespace std;
long long t, n, a[1005], mini;
int main()
{
	cin >> t;
	a[0] = 9e18;
	while (t--)
	{
		cin >> n;
		mini = 0;
		for (int i = 1;i <= n;i++)
		{
			cin >> a[i];
			if (a[i] < a[mini])
			{
				mini = i;
			}
		}
		if (n % 2)
		{
			cout << "Jerry\n";
		}
		else
		{
			cout << (mini % 2 ? "Tom\n" : "Jerry\n");
		}
	}
	return 0;
}
```

---

## 作者：b__b (赞：4)

我们分情况讨论：
- 如果长度为奇数，那么 Jerry 一定可以：
  - 先把第一盒拿空；
  - 接着不断继续。

  当 Jerry 拿完 $n$ 号盒子的硬币时，下一个就是 Tom 拿 $1$ 号盒子，此时 $1$ 号盒子已经空了，所以 Jerry 必胜。
- 如果长度为偶数，那么每一个人拿的盒子的编号都是一样的，也就是无法干扰~~做局~~对方，因此他们只能一次拿一个硬币，这样可以最大化自己生存的时间。
  
  于是我们需要判断哪一个人会先拿完。

  我们可以记录 Jerry 拿的盒子中的最小值 $m_j$ 和 Tom 拿的盒子中的最小值 $m_t$，于是有：
  - 如果 $m_j > m_t$，那么显然 Tom 先拿完，Jerry 赢；
  - 如果 $m_j < m_t$，那么显然 Jerry 先拿完，Tom 赢；
  - 如果 $m_j = m_t$，那么我们查看这两个最小值第一次出现的位置，如果 $m_j$ 先出现那么 Jerry 先拿完，Tom 赢；反之 Tom 先拿完，Jerry 赢。

实际实现非常简单，是一道不错的题目。

```cpp
#include <iostream>
int arr[1005];
int main() {
    int T;
    for (scanf("%d", &T); T--;) {
        int n;
        scanf("%d", &n);
        for (int i = 0; i < n; ++i) scanf("%d", arr + i);
        if (n & 1) {puts("Jerry"); continue;}
        int omin = 2147483647, omind, jmin = 2147483647, jmind; //omin是偶数位置上的最小值，omind是偶数位置上的最小值第一次出现的位置，jmin与jmind同理
        for (int i = 0; i < n; ++i) {
            if (i & 1) { //因为下标从0开始，因此会反过来
                if (omin > arr[i]) omin = arr[i], omind = i;
            } else if (jmin > arr[i]) jmin = arr[i], jmind = i;
        }
        if (jmin > omin || (jmin == omin && jmind > omind)) puts("Jerry");
        else puts("Tom");
    }
}
```

---

## 作者：lovely_firefly (赞：3)

个人认为是个博弈论题目，下面给出分析过程。

如果 $n$ 是奇数，则 Jerry 必胜，因为 $1 \le a_i$，即每一堆硬币开始时都有的取，所以他只要先把第一堆硬币取光，那么等下一轮轮到 Tom 来取第一堆时 Tom 就输了。而第 $2$ 到第 $n$ 堆硬币此时怎么取都没有意义了。

反之如果 $n$ 是偶数，那么 Jerry 永远只能取奇数堆的硬币，而 Tom 只能取偶数堆的硬币。这场拉锯战两人的最优策略就是每次只取一枚硬币。此时硬币数量最少且最靠前的那一堆是谁的谁就输了。

代码：
```cpp
#include <iostream>
using namespace std;
const int N=1003;
int n,a[N];
inline void solve()
{
	scanf("%d",&n);
	for (int i=1;i<=n;++i)
		scanf("%d",a+i);
	if (n%2==1) printf("Jerry\n");
	else
	{
		int mn=0x7fffffff,mnid=0;//这里就因为这两个变量的值写反了调了好久，还发了个工单怀疑数据有误......
		for (int i=1;i<=n;++i)
			if (a[i]<mn) mn=a[i],mnid=i;
		if (mnid%2==0) printf("Jerry\n");
		else printf("Tom\n");
	}
}
int main()
{
	int T;scanf("%d",&T);
	while (T--) solve();
	return 0;
}

```

---

## 作者：ethansang (赞：2)

# B4379 [蓝桥杯青少年组省赛 2025] 硬币游戏 题解
~~这次蓝桥杯题也太水了。~~
## 题意
>有 $n$ 堆硬币，第 $i$ 堆有 $a_i$ 枚。Jerry 先从 $1$ 号堆取，Tom 再从 $2$ 号堆取，以此类推。当取到第 $n$ 堆时，下一个人再从 $1$ 号堆取。谁先无法取，谁就输了。若两人都采取最优策略，问谁赢。
>
## 思路
>简单博弈论。
>
>若 $n$ 为奇数，Jerry 必胜。因为下一回合，Tom 取第 $1$ 堆，Jerry 只需把第 $1$ 堆取完即可。
>
>否则，自己取过的堆，下一轮还是自己取。因此每人取的都尽量少，只取 $1$ 枚。我们只需比较奇偶堆硬币的最少值，谁的少谁就输。如果一样，谁靠前谁输。我们只需要记录最少的是哪一堆即可。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x3f3f3f3f
#define mod 1000000007
#define pi M_PI
#define lowbit(x) (x & -x)
#define ls u << 1
#define rs u << 1 | 1
#define pii pair<int, int>
#define debug cout << "OK" << endl;
const int N = 1e3 + 5;
int T = 1, n;

void solve()
{
	cin >> n;
	int ji = inf, ou = inf, p1, p2;
	for (int i = 1; i <= n; i++){
		int a;
        cin >> a;
		if (i & 1){
            if (a < ji){
                ji = a;
                p1 = i;
            }  
        } else {
            if (a < ou){
                ou = a;
                p2 = i;
            }
        }
	}
	if (n & 1){
		cout << "Jerry" << endl;
		return;
	}
    if (ji > ou)
        cout << "Jerry" << endl;
    else if (ou > ji)
        cout << "Tom" << endl;
    else
        cout << (p1 < p2 ? "Tom" : "Jerry") << endl;
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> T;
    while (T--)
        solve();

    return 0;
}
```

---

## 作者：ziyaojia (赞：2)

这道题我们可以先分类讨论。

- 当 $n$ 为奇数时：这样只要 Jerry 第一次拿光第一个盒子里的所有金币，那么等 Tom 第二次来拿的时候他就必败。

- 当 $n$ 为偶数时：他们拿的盒子是固定不变的，因为他们足够聪明，所以他们只会一个一个拿，此时我们只要记录金币最少且出现最早的盒子的下标再去判断奇偶性，最后输出结果就好了。

### [AC](https://www.luogu.com.cn/record/230333749) Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,tmp,minn,mini;
int main(){
    cin>>T;
    while(T--){
        cin>>n;
        minn=INT_MAX;
        for(int i=1;i<=n;i++){
            cin>>tmp;
            if(tmp<minn){
                minn=tmp;
                mini=i;
            }
        }
        if(n%2==1)cout<<"Jerry";
        else if(mini%2==1)cout<<"Tom";
        else cout<<"Jerry";
        cout<<'\n';
    }
    return 0;
}
```

---

## 作者：zhangjunxizjx (赞：2)

~~刚打完蓝桥杯，必须写一发题解。~~

# 思路

这道题可以用博弈论、分类讨论解决。

分类讨论如下：

1.如果 $n$ 是奇数，那么先手必胜。

必胜策略：先手只需要将编号为 $1$ 的箱子中的硬币**全部取出**。

由题易得，第一圈先手总能访问所有**奇数编号**的箱子，也就意味着第一圈先手可以访问到编号为 $n$ 的箱子，而下一回合后手需要访问编号为 $1$ 的箱子，发现箱子已空，故先手胜。

---

2.如果 $n$ 是偶数，此时双方均要**竭力避免**把一个箱子中的硬币取完。

因为 $n$ 为偶数，每一圈访问的箱子**编号的奇偶性一定相同**（人话：先手一定会轮流访问编号为**奇数**的箱子，后手一定会轮流访问编号为**偶数**的箱子）。

也就意味着先手的访问顺序一定是 $1 \rightarrow 3\rightarrow ...... \rightarrow (\frac{n}{2}-1) \rightarrow 1 \rightarrow 3 \rightarrow ......$。

而后手是 $2 \rightarrow 4 \rightarrow ...... \rightarrow \frac{n}{2} \rightarrow 2 \rightarrow 4 \rightarrow ......$。

所以只要任何一方率先把一个箱子中的硬币取完，在 $\frac{n}{2}$ 回合后就会再次访问到这个空箱子而输掉游戏。（即使期间对方也将一个箱子中的硬币取完也不会改变结果，因为我方会比对方先访问到空箱子而输掉游戏。）

因此，双方均会采取最优策略：一次只从访问的箱子里取出 $1$ 枚硬币。

而因为先手只会轮流访问编号为**奇数**的箱子，后手只会轮流访问编号为**偶数**的箱子。

所以只需比较**所有奇数编号的箱子中的硬币最小值**与**所有偶数编号的箱子中的硬币最小值**（较大的一方获胜）。

如果一样，就比较**所有奇数编号的箱子中硬币最少的那个的编号**与**所有偶数编号的箱子中硬币最少的那个的编号**（较大的一方获胜）。

如果一方的多个箱子硬币数并列最少，那么编号取**其中编号最小的那个**。

# AC代码与记录

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int T; 
	cin >> T;
	for(int t = 1;t <= T;t++){
		int n;
		cin >> n;
		if(n % 2 == 1){
			int k;
			for(int i = 1;i <= n;i++){
				cin >> k;
			}
			cout << "Jerry" << endl;
		}
		else{
			int m1 = 1999999999;
			int m2 = 1999999999;
			int p1 = -1;
			int p2 = -1;
			int a,b;
			for(int i = 1;i <= n/2;i++){
				cin >> a >> b;
				if(a < m1){
					m1 = a;
					p1 = i * 2 - 1;
				}
				if(b < m2){
					m2 = b;
					p2 = i * 2;
				}
			}
			if(m1 < m2){
				cout << "Tom" << endl;
			}
			else if(m1 > m2){
				cout << "Jerry" << endl;
			}
			else{
				if(p1 < p2){
					cout << "Tom" << endl;
				}
				else{
					cout << "Jerry" << endl;
				}
			}
		}
	}
}
```
https://www.luogu.com.cn/record/230381583

---

## 作者：Loyal_Soldier (赞：2)

### 思路

一道简单博弈论。

这题需要分类讨论：

- $n$ 是偶数时，很明显，每人能取的盒子都是固定的，Jerry 只能取 $1,3,5,\dots$ 号盒子，Tom 只能取 $2,4,6,\dots$ 号盒子，两人的最优策略即为每次只取 $1$ 个。显然，如果硬币数最少的盒子只能由 Jerry 取，Tom 就必胜，如果硬币数最少的盒子只能由 Tom 取，Jerry 必胜。
- $n$ 是奇数时，Jerry 的最优策略即为开始直接把 $1$ 号盒子取空，由于 Tom 必然会取到 $1$ 号盒子，且 Tom 取到 $1$ 号盒子前的操作不会对 Jerry 产生影响，所以 Jerry 必胜。

### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
const int N = 1010;
int n, a[N];
signed main()
{
	int T;
	cin >> T;
	while(T --)
	{
		cin >> n;
		int Min = LLONG_MAX, pos = 0;//Min 表示硬币数最少的盒子的硬币数量，pos 表示硬币数最少的盒子的编号
		for(int i = 1;i <= n;i ++)
		{
			cin >> a[i];
			if(a[i] < Min)
			{
				Min = a[i];
				pos = i;
			}//更新 Min 和 pos
		}
		if(n % 2) cout << "Jerry\n";//n 是奇数是 Jerry 必胜
		else
		{
			if(pos % 2) cout << "Tom\n";//硬币数最小的盒子由 Jerry 取，Tom 必胜
			else cout << "Jerry\n";//硬币数最小的盒子由 Tom 取，Jerry 必胜
		}
	}
	return 0;
}
```

---

## 作者：liuyuantao (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/B4379)

一道博弈论题目。因为和之前见过的一道题目有相似之处，所以赛时很快解决了。  
显然当轮到某位玩家时无硬币可取，一定是因为上一轮所有盒子都有硬币可取且上轮这个盒子的硬币被取光了。  
于是这个玩家失败有且仅有两种可能：  
* 上轮中对手故意取光此盒子。
* 上轮中自己不得不取光此盒子。

考虑分类讨论。  
* $n$ 为奇数。此时若 Jerry 先手取空 $1$ 号盒子，由于 $a_i \ge 1$，第 $1$ 轮不会有人失败。而第 $2$ 轮开始时，Tom 取没有硬币的 $1$ 号盒子，符合失败可能 $1$，失败。所以 Jerry 必胜，输出 $\texttt{Jerry}$。
* $n$ 为偶数。显然此时 Jerry 取奇数号盒子，Tom 取偶数号盒子，两人互不影响，败者只能符合失败情况 $2$。所以他们会最小化取硬币数量，即取 $1$ 枚硬币。而每轮所有盒子都会减少 $1$ 枚硬币，硬币数最小的盒子会先变为 $0$，取这个盒子的人也就会失败 ~~（除非对面作死直接取光）~~。特别地，如果有多个硬币数最小的盒子，取最前面的盒子的人会失败。求出此盒子的编号，为奇数输出 $\texttt{Tom}$，偶数输出 $\texttt{Jerry}$。（输出的是胜者！）

总时间复杂度 $O(Tn)$。  
[AC code](https://www.luogu.com.cn/record/230311277)  
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N=1e3+5;
int T,n,tmp,ans;
int A[N];

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>T;
    while(T--){
    	cin>>n;
    	for(int i=1;i<=n;i++){
    		cin>>A[i];
		}
		if(n&1)cout<<"Jerry"<<endl;
		else{
			tmp=1e9+2;ans=0;
			for(int i=1;i<=n;i++){
				if(tmp>A[i]){
					tmp=A[i];ans=i;
				}
			}
			if(ans&1)cout<<"Tom"<<endl;
			else cout<<"Jerry"<<endl;
		}
	}
    
    return 0;
}
```
番外：赛场上刚开始把 $\texttt{Jerry}$ 打成了 $\texttt{Jenny}$，看到所有测试数据均未通过时人傻了！  
这是本人的第 $1$ 篇 B 题库题解，如果觉得有用就点个赞吧！  
同场题解：  
* [题解：B4377 [蓝桥杯青少年组省赛 2025] 平衡奇偶位置的字符交换](https://www.luogu.com.cn/article/6ofc3ylz)
* [题解：B4380 [蓝桥杯青少年组省赛 2025] 魔术扑克牌排列](https://www.luogu.com.cn/article/23vtf9tm)

---

## 作者：ridewind2013 (赞：1)

## 思路

如果 $n$ 为奇数，那么 Jerry 第一次将 $a_{1}$ 取光，无论，之后怎么取，下一次 Tom 取 $a_{1}$ 时必定失败，所以如果 $n$ 为奇数，Jerry 一定胜出。

如果 $n$ 为偶数，那么 Jerry 永远取奇数盒的硬币，Tom 永远取偶数盒的硬币，谁先没硬币可取谁就输，所以看硬币最少的盒子编号为奇数还是偶数来判定输赢。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
    cin>>t;
    while(t--){
        int n,x;
        cin>>n;
        int mn=2e9,ans;//mn为最少硬币数，ans为最少硬币的盒子编号
        for(int i=1;i<=n;i++){
            cin>>x;
            if(x<mn)mn=x,ans=i;//更改最小值
        }
        if(n&1)cout<<"Jerry\n";//n 为奇数，Jerry 胜利
        else if(ans&1)cout<<"Tom\n";//如果 n 为偶数，并且最少硬币的盒子编号为奇数，Tom 胜利
        else cout<<"Jerry\n";//如果 n 为偶数，并且最少硬币的盒子编号为偶数，Jerry 胜利
    }
	return 0;
}
```

---

## 作者：popcorn_pizza_3 (赞：1)

场切了。

这道题其实没有大家想象中的难，我们可以分情况讨论。

如果 $n$ 是奇数，先手可以在第一轮把第一盒的所有硬币取完，第二轮轮到后手取第一盒时盒子里没有硬币，所以这种情况可以直接输出 `Jerry`。

如果 $n$ 是偶数，则先手永远只取奇数盒，后手永远只取偶数盒，这种情况下每个人能取的硬币数是固定的，你取得越多，就越容易输。我们不难得出，最优解是每次取一枚硬币。我们只需判断哪个盒子里的硬币最少即可，因为按照最优策略取，硬币最少的盒子中的硬币会最先被取完，谁取这个盒子谁输。如果硬币最少的盒子的编号是奇数，则先手在某一轮取到这个盒子时会无硬币可取，输出 `Tom`；否则输出 `Jerry`。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[1005],minbox,mincoin;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		if(n%2==1)
			cout<<"Jerry\n";
		else{
			minbox=mincoin=INT_MAX;
			for(int i=1;i<=n;i++){
				if(a[i]<mincoin){
					mincoin=a[i];
					minbox=i;
				}
			}
			if(minbox%2==1)
				cout<<"Tom\n";
			else
				cout<<"Jerry\n";
		}
	}
}
```

---

## 作者：Nahia (赞：0)

### 思路

:::warning[警告]
本题数据**强于**赛时，赛时在两个最小值相等的情况下不判断顺序可过。
:::

分成盒子数量分别是奇数和偶数两种情况来考虑。

如果盒子数量是偶数，那么这次 Jerry 拿的盒子下次还是它拿，那么这个时候他们就要考虑给自己留退路。假设两人每次只拿 $1$ 个硬币，设 Jerry 所拿的盒子中硬币最少的硬币个数为 $x$，Tom 所拿的盒子中硬币最少的硬币个数为 $y$，易得两数更小者会失败。如果两数一样，那么更靠前的会先拿完没得拿，易得此时最小值更靠前的失败。

如果盒子数量是奇数，那么这一轮 Jerry 拿的盒子下一轮就该 Tom 拿了，那么这个时候 Jerry 就可以把所有盒子中的硬币全部拿完，这样 Tom 就没得拿了。易得这种情况 Jerry 必胜。

### solution

```cpp
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define For(i,a,b) for(int i = a;i<=b;i++)
#define Rof(i,a,b) for(int i = a;i>=b;i--)
using namespace std;
inline __int128 read(){__int128 x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-'){f=-1;}c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}
inline void write(__int128 x){if(x<0){putchar('-');x=-x;}if(x>9)write(x/10);putchar(x%10+'0');}
int main(){
	int t = read();
	while(t--){
		int n = read();
		int mj = 1e9+5,idx = 0;
		for(int i = 1;i<=n;i++){
			int x = read();
			if(x<mj){
				mj = x;
				idx = i;
			}
		}
		if(n%2==0){
			if(idx%2==0){
				printf("Jerry\n");
			}
			else printf("Tom\n");
		}
		else printf("Jerry\n");
	}
	return 0;
}
```

---

## 作者：ryderyang (赞：0)

比赛的时候最后 $15$ 分钟把最后两题做出来了！必须写篇题解纪念一下。

## 解题思路
我们可以对 $n$ 的奇偶性进行分类：

- $n$ 是奇数：

  - 如果 $n$ 是奇数，那么 Jerry 只需要把第一个盒子中的硬币全部拿走，不管后面怎么拿都是 Jerry 赢。

  - 可以理性的分析一下，在第一波：
 
    - Jerry 会拿那些编号为奇数的盒子中的硬币。

    - 所以 Jerry 会拿第 $n$ 个盒子中的硬币。
   
  - 那么在第二波的一开始，Tom 就需要拿第 $1$ 个盒子中的硬币，他就会发现里面没有硬币，Jerry 赢了。

- $n$ 是偶数：

  - 由于 $n$ 是偶数，Jerry 和 Tom 会交替取同一个盒子（例如 $1$ 号盒子永远由 Jerry 取，$2$ 号盒子永远由 Tom 取，以此类推）。

  - 游戏的关键在于：哪个盒子会先被取空。因为一旦某个盒子被取空，轮到取该盒子的玩家就会失败。
 
  - 显然，硬币数最少的盒子会最先被取空。所以我们只需要判断哪个盒子中的硬币最小（如果有多个就看哪一个下标最小），判断这个盒子是由 Jerry 拿还是 Tom 拿即可。
 
## 程序
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int t,n,a[N];
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		int minn=1e9+5,id=-1;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			if(a[i]<minn)
			{
				minn=a[i];
				id=i;
			}
		}
		if(n%2==1)
		{
			cout<<"Jerry"<<endl;
			continue;
		}
		else
		{
			if(id%2==1) cout<<"Tom"<<endl;
			else cout<<"Jerry"<<endl;
		}
	}
	return 0;
}
```

---

## 作者：sjwhsss (赞：0)

# 题解：B4379 [蓝桥杯青少年组省赛 2025] 硬币游戏

## 解题思路

记 Jerry 为 A ，Tom 为 B 由于是两位玩家轮流取并且给出的序列是环状结构，不妨考虑按奇偶分讨。

-   若 $n$ 为奇数，那么当某个位置第 $i$ 次被某个人选，第 $i+1$ 轮这个位置就会被另一个人选。于是 A 在第一轮拿完 $a_1$ ，第二轮 B 必定选到为 $0$ 的 $a_1$，A 就必胜了。

-   $n$ 为偶数时，奇数位置永远是 A 来选，偶数则是 B 选。两个人的最优策略显然是每个位置每轮都尽量少拿硬币尽可能防止拿不了的情况出现，那么每次只拿一个硬币是最优的。我们只需看两个人谁先把某堆硬币取完即可，也就是比较最小值，若最小值相同，最小值位置最靠前的那个人就会先失败。

## 代码

``` cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6+5;
int n , m1 , m2 , a[maxn];
void Solve()
{
	m1=m2=0;
	a[0]=1e9+5;
	cin >> n;
	for (int i = 1; i <= n; i++)cin >> a[i];
	if (n & 1)puts("Jerry");
	else
	{
		
		for (int i = 1; i <= n; i++)
		{
			if (i & 1)
			{
				if (a[i] < a[m1])m1=i;
			}
			else
			{
				if (a[i] < a[m2])m2=i;
			}
		}
		puts(a[m1] == a[m2] ? m1 < m2 ? "Tom" : "Jerry" : a[m1] < a[m2] ? "Tom" : "Jerry");
	}
	return;
}
signed main ()
{
	ios::sync_with_stdio(0),cin.tie(0);
	int t;
	cin >> t;
	while(t--)Solve();
	return 0;
}
```

---

## 作者：zzz13579zzz (赞：0)

~~博弈论怎么是黄题~~

---

先说结论：若 $n$ 为奇数，先手必胜；若 $n$ 为偶数，最小值最先出现在谁手上谁输。

下面是证明：

- $n$ 为奇数

此时，$1$ 号和 $n$ 号盒子都是先手拿，那么先手可以直接将 $1$ 号盒子拿空，这样等拿完 $n$ 号盒子，后手将无法行动，故先手必胜
  
- $n$ 为偶数

此时，先手只能拿奇数盒子，后手只能拿偶数盒子，所以每个人取的总数是固定的 。 为了尽量多次拿，所以每次只会拿一个，一轮过后，所有盒子数目减少一，最小值会最先变成零，所以最小值最先出现在谁手上谁输。

~~代码就不放了~~

---

## 作者：pengyirui (赞：0)

博弈论好题。

## 思路

分讨。

- 总数是奇数：汤姆和杰瑞每次都取完当前堆，轮到汤姆第二轮第一次取，取不了，肯定杰瑞获胜。
- 总数是偶数：因为他们每轮都取得是自己上一轮取得那些，故肯定只取一枚。谁的硬币数最小值大谁获胜。如果一样，最靠前的最小的**编号**那堆大的获胜。

## AC code

场上 1 分钟切掉了这道题。

```cpp line-numbers
#include <bits/stdc++.h>
#define int long long
using namespace std;
signed main() {
	int T;
	cin >> T;
	while (T--) {
		int n;
		cin >> n;
		int ans1 = 1e18, ans2 = 1e18, anss1, anss2;
		for (int i = 1; i <= n; i++) {
			int ai;
			cin >> ai;
			if (i % 2 == 0) {
				if (ai < ans2) {
					ans2 = ai;
					anss2 = i;
				}
			} else {
				if (ai < ans1) {
					ans1 = ai;
					anss1 = i;
				}
			}
		}
		if (n % 2 == 1)
			cout << "Jerry\n";
		else {
			if (ans1 < ans2)
				cout << "Tom\n";
			else if (ans1 != ans2)
				cout << "Jerry\n";
			else {
				if (anss1 < anss2)
					cout << "Tom\n";
				else
					cout << "Jerry\n";
			}
		}
	}
}
```

---


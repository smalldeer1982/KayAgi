# [LSOT-2] 基于二分查找与插入的快速排序

## 题目背景

小 H 不会排序，但是会二分！

于是他创造了一个基于二分查找与插入的快速排序。

本题存在可带修做法，因为这题是这场考试的签到题所以良心出题人没有加上。

## 题目描述

给定一个排列 $p$。每次可以选择一个数 $p_i$，你需要找到最小的 $j$，使得 $j>i$ 且 $p_j>p_i$，并将 $p_i$ 插入到 $p_j$ 前面。你需要最小化使得 $p_i=i$ 的操作次数。

若不存在这样的 $j$，则无法进行操作。

## 说明/提示


**「本题采用捆绑测试」**

- $\texttt{Subtask 1(20pts)：}n\le10$。
- $\texttt{Subtask 2(20pts)：}$保证 $p_i=n-i+1$。
- $\texttt{Subtask 3(20pts)：}n\le1000$。
- $\texttt{Subtask 4(40pts)：}$无特殊性质。

对于全部的数据，$1\le n\le2\times 10^6$，$p$ 是一个 $1$ 到 $n$ 的排列。

## 样例 #1

### 输入

```
5
3 1 4 2 5```

### 输出

```
2```

# 题解

## 作者：良心WA题人 (赞：12)

首先，$a_n\not=n$ 无解。

对于操作过程，考虑一种方案：

从大到小枚举 $i$
- 若 $p_i\not=i$ 则操作使得 $p_j=i$ 的 $j$。

尝试证明上述算法的正确性。显然经过上述操作后可以完成排序。而每次操作将会把序列变为：

$1,2,3\dots j-1,j+1\dots j,i,i+1\dots n$

若之前操作 $1$ 到 $j-1$ 中的数，则必然不会跨过 $j$，则在 $j$ 操作后必然还需要再进行操作。

若之前操作了 $j+1$ 到 $i-1$ 中的数，则先操作 $j$ 再操作这中间的数对答案没有影响。

上述操作按理来讲可以通过一些数据结构直接维护。但是这显然太麻烦了。考虑去观察哪些情况下 $i$ 不会被操作，可以发现 $i$ 不被操作当且仅当 $p_i$ 为 $i$ 开始的后缀的最小值。

证明比较简单，首先若中间存在小于 $p_i$ 的数则 $i$ 必然比这个数先操作，那么相对位置不会变化，则 $i$ 后面不可能为 $i+1$ 到 $n$ 这些全都比它大的数。

而若不存在，则任何比 $p_i$ 小的数无法到 $p_i$ 后方，所以当 $p_i$ 操作时右侧均比 $p_i$ 大，显然满足要求。故得证。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=2e6+4;
int a[NN];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	if(a[n]!=n)
	{
		printf("-1");
		return 0;
	}
	int minn=1e9,ans=0;
	for(int i=n;i>=1;i--)
	{
		if(a[i]<minn)
			minn=a[i];
		else
			ans++;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Ia_aI (赞：6)

首先，我们可以发现，当 $p_n\ne n$ 的时候无解。

因为 $n$ 在 $p$ 数组中是最大的一个数字，所以如果 $n$ 不在 $p_n$ 上，则 $n$ 后必然没有比它大的数，故无法完成排序。

接着，当有解的时候，可以考虑使用贪心算法。

从 $n - 1$ 开始，到 $1$ 为止，依次将它们插入到自己排序后应该在的位置即可。

这个时候就会有一个问题：为什么可以这样呢？插入时不会碰到比自己大的数字吗？

其实是不会的。因为我们是从大到小依次插入，比自己大的数字都已经被插入到自己的位置之后了，并不会影响当前的操作。

那么插入的时候只要用双向链表维护即可。

时间复杂度 $O(n)$。

code
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10;
int n,p[N],nxt[N],pre[N],ans;
int main()
{
  cin>>n;
  for(int i = 1; i <= n; i++)
  {
    cin>>p[i];
    pre[p[i]] = p[i - 1];//双向链表初始化
    if(i != 1) nxt[p[i - 1]] = p[i];
    if(i == 1) pre[p[i]] = -1;
    if(i == n) nxt[p[i]] = -1;
  }
  if(p[n] != n)//无解
  {
    cout<<-1;
    return 0;
  }
  for(int i = n - 1; i > 0; i--)
  {
    if(nxt[i] == i + 1) continue;//i已经在第i个位置上
    nxt[pre[i]] = nxt[i];//双向链表删除操作
    pre[nxt[i]] = pre[i];
    nxt[i] = i + 1;//双向链表插入操作(由于第i+1个位置已经插入成功了，所以要把i插入到i+1的后面)
    pre[i] = pre[i + 1];
    nxt[pre[i + 1]] = i;
    pre[i + 1] = i;
    ans++;
  }
  cout<<ans;
  return 0;
}

```

---

## 作者：信息向阳花木 (赞：2)

首先考虑为什么会有无解的情况。设第 $i$ 个数在排列中的位置是 $pos_i$。如果 $pos_n \neq n$，由于排列中没有比 $n$ 大的数，$n$ 无法移到正确的位置。所以无解。如果 $n$ 在正确的位置，其他数都可以通过 $n$ 移到相应的位置。

模拟样例，如果先移动 $3$，需要 $3$ 次移动。如果先移动 $4$，只需要移动 $2$ 次。

于是，不难想到可以从大到小移动每个数。$n$ 的位置确定了，通过 $n$ 移动 $n - 1$，通过 $n - 1$ 移动 $n - 2$，直到排序完成。具体地，倒序枚举 $i$。如果 $i$ 现在已经在第 $i$ 个位置上，就不需要移动了。否则需要移动。那么如何判断 $i$ 是否已经在正确的位置上呢？枚举到 $i$ 时 $[i + 1,n]$ 的数已经完成移动。这些数的正确位置都在 $i$ 后面。如果这些数在原序列中有比 $i$ 靠前的，移动后会使 $i$ 的排名向前移动。所以 $i$ 现在的排名就是在原序列中的排名 $pos_i$ 减去在 $i$ 前面比 $i$ 大的数的个数 $cnt_i$。$cnt_i$ 我们可以用树状数组预处理出来。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <cmath>

using namespace std;

const int N = 2000010;

int n, res;
int a[N], pos[N], cnt[N], tr[N];

int lowbit(int x) { return x & -x; }

void add(int pos, int x)
{
	while (pos <= n)
	{
		tr[pos] += x;
		pos += lowbit(pos);
	}
	return;
}

int query(int pos)
{
	int res = 0;
	while (pos)
	{
		res += tr[pos];
		pos -= lowbit(pos);
	}
	return res;
}

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]), pos[a[i]] = i;
	if(pos[n] != n) { puts("-1"); return 0; }
	for (int i = 1; i <= n; i ++ )
	{
		add(a[i], 1);
		cnt[a[i]] = query(n) - query(a[i]); 
	}
	for (int i = n - 1; i >= 1; i -- )
	{
		if(pos[i] - cnt[i] == i) continue;
		res ++;
	}
	printf("%d\n", res);
	return 0;
}
```

---

## 作者：__FL__ (赞：1)

## 题意
给定一个从 $1$ 到 $n$ 的排列 $P$，每次操作都可以将一个数移动到后面比自己大的数的前面，问最少操作多少次可以将这个排列变为从小到大的有序数列。


具体地，拿样例（$3\ 1\ 4\ 2\ 5$）来说，$3$ 可以移动到 $5$ 的前面，而 $3$ 移动到 $2$ 的前面 或 $1$ 移动到 $3$ 的前面则是不被允许的。
## 分析
简单思考可以发现，$P_n \ne n$ 无解。

我们可以从 $n-1$ 到 $1$ 枚举每个数 $i$，同时用一个 $t$ 依次指向 $n-1$ 到 $1$，表示比 $i$ 大的所有数归位后，它们的前一个数在原始 $P$ 中的位置；开两个数组 $M$ 和 $VIS$，$M$ 存储每个数在序列中的位置， $VIS_i$ 表示数组第 $i$ 个位置有没有被使用。

从大到小枚举 $i$，如果 $P_t = i$，说明 $i$ 的位置是正确的，$t$ 移动到前一个位置上；反之 $ans+1$，$VIS$ 标记 $i$ 的位置已使用。在每一次枚举后，$t$ 都要移动到前面第一个没有被标记过的位置。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p[2000005],t,m[2000005],ans;
bool vis[2000005];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> p[i];
		m[p[i]] = i;
	}
	if (p[n] != n)
	{
		cout << -1;
		return 0;
	}
	t = n-1;
	for (int i = n-1; i >= 1; i--)
	{
		if (p[t] == i)
			t--;
		else
			ans++,vis[m[i]] = 1;
		while (vis[t]) t--;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：I_will_AKIOI (赞：1)

当我看到[出题人题解](https://www.luogu.com.cn/blog/mineboke/ji-yu-er-fen-zha-zhao-yu-cha-ru-di-kuai-su-pai-xu-ti-xie)时，发现我的做法原来这么麻烦，看来我还是太菜了。

首先，$n$ 肯定开始得放在第 $n$ 个的位置上，否则当你选择 $p_i=n$ 时，无法进行操作。

其次，我们需要将 $i-1$ 插到 $i$ 的前面。例如样例，开始你将 $4$ 插到 $5$ 的前面，肯定比将 $3$ 插入好，因为你还需要再将 $4$ 插到 $5$ 的前面，浪费了一步。

然后考虑暴力。从 $i=n-1$ 开始枚举，接着枚举排列 $p$，找到 $p_j=i$，将 $p_j$ 插入到 $p_i$ 前即可，复杂度 $O(n^2)$。

由于在数组中无法高效的完成插入操作，我们可以使用链表。每次操作时将 $i$ 删除，然后插入到 $i+1$ 的左边，如果 $i$ 的右边刚好是 $i=1$，直接跳过，否则记录下操作的步数。

若你使用数组存链表，注意空间要开两倍，不然会爆。

```
#include<bits/stdc++.h>
using namespace std;
struct data{int val,l,r;}w[4000005];
int n,m,cnt,ans,a[2000005],in[4000005];
void insert_left(int x,int y)//在x的左边插入y
{
  int now=in[x];
  w[++cnt]=data{y,w[now].l,now};
  w[w[now].l].r=cnt;
  w[now].l=cnt;
  in[y]=cnt;
  return;
}
void insert_right(int x,int y)//在x的右边插入y
{
  int now=in[x];
  w[++cnt]=data{y,now,w[now].r};
  w[w[now].r].l=cnt;
  w[now].r=cnt;
  in[y]=cnt;
  return;
}
void erase(int x)//删除x
{
  int now=in[x];
  int le=w[now].l,ri=w[now].r;
  w[le].r=ri;
  w[ri].l=le;
  in[x]=0;
  return;
}
int main()
{
  ios::sync_with_stdio(0);
  cin>>n;
  for(int i=1;i<=n;i++)
  {
  	cin>>a[i];
  	insert_right(a[i-1],a[i]);//将a[i]插在a[i-1]的右边
  	if(i==n&&a[i]!=n)//a[n]不是n，无解
  	{
  	  cout<<-1;
  	  return 0;
	}
  }
  for(int i=n-1;i>=1;i--)
  {
    if(w[in[i]].r==in[i+1]) continue;//当前i的→边就是i+1，跳过
  	erase(i);
  	insert_left(i+1,i);
    //删除当前的数，再插入
  	ans++;
  }
  cout<<ans;
  return 0;
}
```

---

## 作者：dongrunxuan (赞：1)

# P10155 题解

## 前言
前置知识：[树状数组](https://www.bilibili.com/video/BV12a411i7rP/?spm_id_from=333.337.search-card.all.click&vd_source=6f4a765349c18f3c9f8d8518d9cb733f)

公开赛没打，回来看题时发现这是一道树状数组的好题，正好最近学了树状数组，就来做这道题。

## 思路
先看不合法的情况。

若 $p_n\ne n$，则不合法，因为不存在题目所要求的 $j$ 可使 $p_n$ 移动到正确位置。

接着，用树状数组来维护每个元素插入时是否在合法的位置。在建树状数组的过程中，每插入一个数 $p_i$，就相当于 $p_i$ 及其身后的数元素个数增加了一，便可进行维护（建树）操作。

#### 如何查询呢？
只需要用维护好的树状数组对遍历到的 $p_i$ 查询它前面应有的元素后面接着的是否为 $p_i$ 即可，如果不是，操作次数增加一。

### 时间复杂度评估

遍历操作用时 $O(n)$，维护与查询时间复杂度 $O(n\log_2n)$。

## 代码
```
#include <bits/stdc++.h>
using namespace std;
int n,ans;
const int maxn=2e6+10;
int a[maxn] ;
int tree[maxn] ;
int lowbit(int x)
{
	return x&(-x);
}
void add(int x) 
{
	for(;x<=n;x+=lowbit(x))
	{
		tree[x]+=1;
	}
}
int ask(int x) 
{
    int res=0;
    while(x) 
	{
        res+=tree[x];
        x-=lowbit(x);
    }
    return res;
}
int main() 
{
    cin>>n ;
    for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
    if(a[n]!=n) 
	{
        cout<<-1 ;
        return 0 ;
    }
    for(int i=1;i<=n;i++) 
	{
        add(a[i]);
        if(ask(a[i])!=a[i])
		{
			ans++;
		} 
    }
    cout<<ans;
	return 0 ;
}

---

## 作者：anll (赞：1)

先把 $p_n \ne n$ 的无解情况判掉。

考虑 $60$ 分做法：从后往前扫，如果 $p_i > p_{i + 1}$ 就表示 $i$ 以及后面的序列无序，要把 $p_i$ 插入到后面第一个 $p_j > p_i$ 的 $j$ 前面。如果没法插入那么无解。

时间复杂度 $O(n ^ 2)$。

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

int main() {
	int n;
	cin >> n;
	vector <int> p(n + 1), st;
	for(int i = 1; i <= n; i++) {
		cin >> p[i];
	}
	if(p[n] != n) {
		cout << -1 << endl;
		return 0;
	}
	int cnt = 0;
	for(int i = n - 1; i >= 1; i--) {
		if(p[i] > p[i + 1]) {
			int flag = 0;
			for(int j = i + 1; j <= n; j++) {
				if(p[i] < p[j]) {
					cnt++;
					flag = 1;
					p.insert(p.begin() + j, p[i]);
					p.erase(p.begin() + i);
					break;
				}
			}
			if(flag == 0) {
				cout << -1 << endl;
				return 0;
			}
		}
	}
	cout << cnt << endl;
}
```

但其实我们不关心后面的序列到底长啥样，我们只关心能否插入和需不需要插入。

$i$ 从 $n - 1$ 扫到 $1$：

- 如果 $p_i > \max_{j = i + 1} ^ n p_j$ 就不能插入，此时也必须插入，无解。

- 如果 $p_i > \min_{j = i + 1} ^ n p_j$ 就需要插入，答案加一。

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

int main() {
	int n;
	cin >> n;
	vector <int> p(n + 1), st;
	for(int i = 1; i <= n; i++) {
		cin >> p[i];
	}
	if(p[n] != n) {
		cout << -1 << endl;
		return 0;
	}
	int cnt = 0, maxx = p[n], minn = p[n];
	for(int i = n - 1; i >= 1; i--) {
		if(p[i] > maxx) {
			cout << -1 << endl;
			return 0;
		}
		if(p[i] > minn) {
			cnt++;
		}
		maxx = max(maxx, p[i]);
		minn = min(minn, p[i]);
	}
	cout << cnt << endl;
}
```

---

## 作者：modfish_ (赞：1)

## 思路
想当然就可以了。

显然，当且仅当 $a_n=n$ 时，题目有解。

必要性：当 $a_n\neq n$ 时，$n$ 无法被插到第 $n$ 位。

充分性：当 $a_n=n$ 时，可以逐步将 $n-1,n-2,\dots,1$ 插到对应位置。这一定是可以实现的。

容易发现，只要这么插，每个元素只需要 $1$ 次或 $0$ 次就能插到对应位置。问题是：究竟是 $1$ 次还是 $0$ 次。

假设接下来要插 $i$，显然当前序列结构如下：

```
[一些小于 i 的数] i [一些小于 i 的数] i+1 i+2 ... n
```

显然地，如果第二列 `[一些小于 i 的数]` 不存在，说明只需 $0$ 次；否则需 $1$ 次。而第二列 `[一些小于 i 的数]` 只可能是原本就存在于 $i$ 的后面的数。

所以：如果原排列中，$i$ 的后面存在小于 $i$ 的数，说明需要 $1$ 次；否则需要 $0$ 次。

用树状数组判一判即可。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2e6 + 5;

int n;
int a[maxn], c[maxn];

void update(int id, int k){
	for(int i = id; i <= n; i += i & -i) c[i] += k;
}
int query(int id){
	int s = 0;
	for(int i = id; i > 0; i -= i & -i) s += c[i];
	return s;
}

int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++){
		scanf("%d", &a[i]);
	}
	if(a[n] != n){
		printf("-1\n");
		return 0;
	}
	int ans = 0;
	for(int i = n; i >= 1; i --){
		if(query(a[i])) ans ++;
		update(a[i], 1);
	}
	printf("%d", ans);
	return 0;
}
```


---

## 作者：yyrwlj (赞：0)

## 思路

如果 $n$ 不在位置上，那就无解，因为后面没有比它大的数了，没有办法移动。

然后肯定要将数从大到小归位，因为如果不从大到小归位，那么会有数移动不了。

考虑记录每个数最开始出现的位置，再用树状数组动态维护偏移量。

如果某次移动的数移动前的位置为 $i$，则 $i$ 往后的数就都会往左偏移一格，给这些位置的偏移量加一即可。

如果某个数已经在位置上就不需要移动了，判断方式就是这个数最开始的出现位置减去偏移量等于 $i$。

## Code

```cpp
#include <iostream>
#define lowbit(x) x & -x
using namespace std;
const int N = 2000005;
int a[N], Map[N], t[N], n;
inline void add(int x)
{
    for (;x<=n;x+=lowbit(x))
        t[x] ++;
}
inline int sum(int x)
{
    int res = 0;
    for (;x;x-=lowbit(x))
        res += t[x];
    return res;
}
int main()
{
    scanf("%d", &n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d", &a[i]);
        Map[a[i]] = i;
    }
    if (a[n] != n)
    {
        puts("-1");
        return 0;
    }
    int ans = 0;
    for (int i=n-1;i>1;i--)
        if (Map[i] - sum(Map[i]) != i)
        {
            ans ++;
            add(Map[i] + 1);
        }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：Kevin911 (赞：0)

## 思路
1. $a_{n}$不是 $n$ 时显然不行，因为 $n$ 自己无法移动。

2. 第二档部分分其实是个提示，如果所有 $a_{i}=n-i+1$ 也无法排序。

3. 其他情况，贪心地想，尽可能从后往前操作会最小化对之前操作的影响，如果他后面一个数已经比他大就不用再动，否则无论是后面有比它小的（直接移过去），还是没有比他小的（等到有再移过去），操作次数都是增加 $1$。

所以特判完倒序模拟下来就可以了，代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
int a[maxn];
signed main()
{
	int n,mn=1e9,ans=0;
	cin>>n;
	if(n==1)
	{
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++) cin>>a[i];
	bool flag=0;
	for(int i=1;i<=n;i++)
		if(a[i]!=n-i+1)
		{
			flag=1;
			break;
		}
	if(!flag||a[n]!=n)
	{
		cout<<-1;
		return 0;
	}
	for(int i=n;i>=1;i--)
		if(mn>a[i]) mn=a[i];
		else ans++;
	cout<<ans;
}
```


---

## 作者：Silvestorm (赞：0)

~~使用会t的暴力解和不完全正确解乱搞这道题并且过了这件事是能说的吗。~~

首先，$a_n=n$ 是有解的先决条件。

观察后不难得知，对于 $a_i$ 若存在 $a_j>a_i(j<i)$，那么必然会进行一次操作，将 $a_j$ 移动到 $a_i$ 的右方，但是移动后的位置又可能会对接下来的操作造成影响，因此需要找到一种方式来消除影响。

初始区间为 $[1,n]$，我们在这个区间找到最小的数，并记录它的位置为 $x$，那么 $x$ 之前的数字全部都要操作，贡献值为 $x-1$，并且按照某种操作次序，这一部分在移动之后是相对有序的，之后就不用管。那么待处理区间就变成了 $[x+1,n]$，继续进行操作直到 $x \ge n-1$，此时就得到了结果。

显然这个做法会被卡成 $O(n^2)$，赛时过不了，需要优化一下。

既然这是一个 $1$ 到 $n$ 的排列，那么可以开一个 $mp$ 数组来记录其是否出现过，最小值就从 $1$ 往上遍历即可。

时间复杂度可以优化到 $O(n)$。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
long long n, ans, tem, num[2010000], mp[2000100];
void find(ll x)
{
    while (mp[tem] == 1 && tem <= n)
        tem++;//往上遍历，找出未出现的最小值
    ll t = x;//这次操作的区间左端点
    if (x >= n - 1)
        return;
    for (int i = x; i <= n; i++)
    {
        mp[num[i]] = 1;
        if (num[i] == tem)
        {
            x = i;//记录最小值出现的位置
            break;
        }
    }
    ans += x - t;//将贡献加入答案中
    find(x + 1);
}
void solve()
{
    ans = 0;
    tem = 1;
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> num[i];
    find(1);
    if (num[n] != n)
        ans = -1;
    cout << ans << '\n';
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    solve();
    return 0;
}
```
小小补充一下，这相当于简化后的公式，实际操作中远比上述方法要复杂。

---

## 作者：Nuyoah_awa (赞：0)

### 题目大意

一个排列，根据题意排序，可随意指定操作的先后顺序，求最小操作次数。

### 题目分析

求最小操作次数，~~不是推结论就是诈骗题~~。

根据题意给出的操作方法，抽象来讲将一个数插入到它右边的一个数钱，由此可以发现，我们不可能将一个数插入到数组最后（因为这之后没有其他数了），所以如果 $p_n \neq n$ 直接输出 `-1`。

我们假设已知 $p_n = n$，观察 $n-1$ 这个数如何归位，两种情况：

1. 如果 $p_{n-1} = n-1$，无需操作即可归位，对答案没有贡献。

2. 如果 $p_{n-1} \ne n-1$，一定会通过操作让其主动归位（因为 $n-1$ 到 $n$ 中间没有其他数），所以我们不妨直接操作一次将其插入到 $n$ 前面，对答案贡献为 $1$。

然后我们考虑 $n-2$ 这个数，由于 $n-1 \sim n$ 都在前面的操作中归位，同理也是上述两种情况。

由此，我们可以按照 $n-1 \sim 1$ 的顺序依次强制归位，答案即为最小值。

### 证明

对于一次操作，除了操作数向右移动，其他数都是不动或向左移动。所以当一个数不需要操作就可以归位时，只可能是比它大的数都在它右边时才不会被影响，否则在后续操作中，他一定会被向左挤，而他也一定需要操作一次从而跨过它右边比它小的数，所以它一定会对答案有贡献，即至少被操作一次。

而按照上述操作，所有需要被操作的数，即满足第二种情况的数只会被操作一遍，由此可证，上述操作一定是最优的。

### code
```cpp
#include <iostream>
#include <cstdio>
#define int long long

using namespace std;

const int N = 2e6 + 5;
int n, p[N], lst, ans;

signed main()
{
	scanf("%d", &n);
	for(int i = 1;i <= n;i++)
		scanf("%d", &p[i]);
	if(p[n] != n)
	{
		puts("-1");
		return 0;
	}
	lst = n-1;
	for(int i = n-1;i >= 1;i--)
	{
		if(p[lst] != i)
			ans++;
		else
		{
			lst--;
			while(p[lst] >= i)	lst--;
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：Zemu_Ooo (赞：0)

~~标题都说解法了你还要怎么样（笑~~

看到题目就联想到用树状数组来优化查找和插入操作，从而实现快排。

众所周知，快速排序的基本思想是分而治之，但这里的策略略有不同，是通过二分查找和插入的方式来进行排序。题目的要求是找到一种方式，使得对于排列中的每个元素 $p_i$，都能找到最小的 $j$（$j>i$ 且 $p_j>p_i$），并将 $p_i$ 插入到 $p_j$ 前面，目的是使得最终排列中的每个元素 $p_i=i$。

首先考虑用树状数组来维护每个元素插入操作的情况。当我们插入一个元素 $p_i$ 时，更新树状数组中的计数，表示在 $p_i$ 位置及其之后的元素数量增加了1。这是因为我们希望知道对于每个位置，有多少个元素应该排在它前面。

接着查询当前位置 $p_i$ 之前（包括自己）有多少个元素，这实际上是求前缀和。这个信息帮助我们判断 $p_i$ 是否已经在正确的位置上，即是否满足 $p_i$ 位置之前（包括 $p_i$）的元素数量正好等于 $p_i$。每当发现 $p_i$ 不在正确的位置上时，操作次数增加 $1$。

特别的，如果排列的最后一个元素 $p_n$ 不等于 $n$，根据题目的操作规则，这个排列是无法通过上述操作完成排序的，因为不存在 $j$ 使得 $j > n$ 且 $p_j > p_n$。在这种情况下，输出 $-1$。

最后如果排列可以通过上述操作完成排序，输出最小的操作次数即可。


```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int p[2000005] ;
int t[2000005] ;
#define lb(x) ((x) & (-(x)))
void add(int x, int k) {
    while(x <= 2000000) {
        t[x] += k ;
        x += lb(x) ;
    }
}
int ask(int x) {
    int res = 0 ;
    while(x) {
        res += t[x] ;
        x -= lb(x) ;
    }
    return res ;
}
signed main() {
    cin >> n ;
    for(int i = 1 ; i <= n ; i++) scanf("%d", p + i) ;
    if(p[n] != n) {
        cout << -1 ;
        return 0 ;
    }
    int sum = 0 ;
    for(int i = 1 ; i <= n ; i++) {
        add(p[i], 1) ;
        if(ask(p[i]) != p[i]) sum++ ;
    }
    cout << sum ;

    return 0 ;
}
```

---

## 作者：Ferm_fire_yu (赞：0)

提供一个偏暴力的解法。
## 方法
栈和优先队列
## 思路
我们通过手动模拟可以发现最大的数字一定要在排列的最后位置，否则就不能完成，题目要求我们通过最小的次数来完成排序，则我们可知每次要将未排序的最大数字 $p_i$ 插入 $i$ 位置，对于此最大的数字我们可以通过优先队列来维护。同时我们注意到，如果进行了一次的操作之后，下个数字 $p_i$ 已经在 $i$ 位置了，我们就无需进行操作，对于此性质我们通过栈来进行维护，每次操作前对比栈顶元素与优先队列中顶端元素进行分类讨论：

1.若相同则意味着其已经在合适的位置，同时在栈和优先队列中删除元素，不增加操作次数。

2.若栈顶元素小于优先队列顶端元素，则说明栈顶元素此时不是需要删除的元素，优先队列删除顶端视为将数字 $p_i$ 插入 $i$ 位置，将操作次数增加 $1$。

3.若栈顶元素大于优先队列顶端元素，则说明已经在第二种情况下删除过此数字，直接在栈中删除，不增加操作次数。

重复以上操作直到栈空则说明已经完成。
对于特殊判断我们不难得出当 $p_n \ne n$ 时无法完成。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,p[2000010],ans,w,t;
priority_queue<int>d;
int zhan[2000010],z;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&p[i]);
		d.push(p[i]);
	}
	z=n;
	if(p[n]!=n){
		cout<<-1;
		return 0;
	}
	while(z!=0){
		if(p[z]==d.top()){
			z--;
			d.pop();
		}else if(p[z]<d.top()){
			d.pop();
			ans++;
		}else if(p[z]>d.top()){
			z--;
		}
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：sbno333 (赞：0)

* 有解当且仅当 $a_n=n$。

证明：

考虑反证法，假设 $a_n\not=n$，有 $a_x=n,x\not=n$。

显然有 $a_x>a_n$。

要将 $n$ 放到最后我们需要能将对于 $i$ 使得 $x<i\le n$，插入到对于 $j$ 使得 $1\le j\le x$ 之前。

我们假设可以，则有 $a_j<a_i$，由于排列中 $n$ 最大，因此 $a_j<a_x$，并且 $j\not=x$。

因此找到的 $j\le x$，因此无法做到，因此有 $a_n=n$。

此时，对于 $n-1$，显然能插入到 $n$ 之前。

接着，对于 $n-2$，能插入到 $n-1$ 之前。

以此类推。

由最开始的反证法证得没有其它方案使得 $i-1$ 插入到 $i$ 之前。

对于本来就在规定的位置，我们不需要操作，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[2000009];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int inn;
	inn=n-1;//记录插入inn到inn+1之前
	if(a[n]!=n){
		cout<<-1<<endl;
		return 0;
	}
	int ans;
	ans=0;//记录答案
	for(int i=n-1;i>=1;i--){
		if(a[i]>inn){//已经插入过了
			continue;
		}
		if(a[i]==inn){//不需要操作
			inn--;
			continue;
		}
		inn--;//需要操作
		ans++;
		i++;//与i--抵消，显然下次还是有可能在原数组i的位置
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：LiaoYF (赞：0)

$O(n \log n)$ 做法。

## 做法

$p_n \neq n$  时无解。

记录 $i$ 在 $p$ 中出现的位置，记为 $pos_i$。从大到小处理每个数，我们发现，一个数被排到正确的位置之后一定是后移的，会导致所有 $pos$ 大于它的 $pos$ 的数的 $pos$ 减小 $1$。开一个树状数组，如果 $i$ 需要移动，那么在 $pos_i$ 单点加 $1$。查询就查询到 $pos_i$ 的前缀和，记为 $s$，$i$ 的真实位置就是 $pos_i-s$。如果 $pos_i-s \neq i$ 则需要操作。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[2000005],pos[2000005];
int c[2000005];
inline int lowbit(int x){
    return x&-x;
}
void add(int x,int k){
    for(int i=x;i<=n;i+=lowbit(i)){
        c[i]+=k;
    }
}
int query(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i)){
        res+=c[i];
    }
    return res;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        pos[a[i]]=i;
    }
    if(a[n]!=n){
        cout<<"-1";
        return 0;
    }
    int ans=0;
    for(int i=n-1;i>=1;i--){
        if(pos[i]-query(pos[i])!=i){
            ans++;
            add(pos[i],1);
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Shadow_T (赞：0)

## $\texttt{Solution}$

一道好玩的贪心题目。

要让操作次数最少，我们可以从 $n$ 开始，让每个值为 $i$ 的数归位到位置 $i$。很明显 $a_n$ 必须等于 $n$，因为如果不等于，$a_n$ 无法找到帮助归位，所以 $a_n \neq n$ 则无解。

很明显，如果倒序归位的话，每个数都可以一步到位，不会被大于他的数影响，大于他的数早已经归位了。思考到这里我们已经可以 $O(n^2)$ 拿到 $60$ 分了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
vector<int> a;
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		a.push_back(x);
	}
	if(a[n-1]!=n)
	{
		cout<<-1;
		return 0;
	}
	int ans=0;
	for(int i=n-1;i>=1;i--)
	if(a[i-1]!=i)
	{
		a.erase(find(a.begin(),a.end(),i));
		a.insert(a.begin()+i-1,i);
		ans++;
	}
	cout<<ans;
}
```

我们在来简化一下思路，可以发现，如果 $[1,i]$ 中没有完全包含从 $i$ 到 $a_i$ 的这些数，那么就要执行一次操作。很容易想到，这东西可以用树状数组维护，然后就 AC 了，复杂度 $O(n \log n)$。

标程 $O(n)$，膜拜。

## $\texttt{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
int a[maxn],tr[maxn],n;
int lowbit(int x)
{
	return x&-x;
}
void add(int x,int v)
{
	for(int i=x;i<=n;i+=lowbit(i))
	tr[i]+=v;
}
int query(int l,int r)
{
	int sum=0;
	for(int i=r;i>=l;i-=lowbit(i))
	sum+=tr[i];
	return sum;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	if(a[n]!=n)
	{
		puts("-1");
		return 0;
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		add(a[i],1);
		if(query(1,a[i])<a[i]) ans++;
	}
	cout<<ans;
}
```

---

## 作者：Bpds1110 (赞：0)

赛时十多分钟没看懂题。

先考虑无解的情况。若 $p_n \ne n$，则 $p_n$ 的原位置不在 $n$，而却找不到满足条件的 $j$，即这位不能换走。最终所得的排列和原来不符，故无解。

再看正常的操作。对于每个 $p_i$，若有 $j > i$ 满足 $p_j > p_i$，就将 $p_i$ 插入至 $p_j$ 前。

我们可以从后往前确认，再转换一下操作。假设当前位为 $i \le n$，$i \sim n$ 都已经由小到大排序（在最终位置），现在需要将 $p_{i - 1}$ 变为 $i - 1$。目前的操作可以转换为，选出 $p_j (p_j = i - 1)$，将 $p_j$ 换到 $i$ 前一位。

其正确性可证明。因为 $i \sim n$ 已经在最终位置，由小到大。设 $p_j = i - 1$，则 $\forall k (i < k \le n) p_k > p_i > p_j$，且 $p_j$ 右边最靠近 $p_j$ 的数为 $p_i$，满足第一个 $> p_j$ 的数 $p_i$，且 $i > j$。

$\forall i (1 < i \le n)$，若 $p_{i - 1} \ne i - 1$，都需要完成这样一次操作。

至于如何完成操作，因为要 $O(1)$ 插入，所以可以用链表。但是这里采取了一种类似链表原理的数组，会好写一点。设 $j = i - 1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/e6gybcdv.png)

如图，用 $pre_i$ 记录 $i$ 的前驱，$nxt_i$ 记录 $i$ 的后继。需要删除叉掉的边，连上增加的边。实质上就是改变几个点的指针。
        
$$nxt_{pre_j} \gets nxt_{j}$$
$$pre_{nxt_j} \gets pre_{j}$$
$$nxt_j \gets i$$
$$pre_j \gets pre_i$$
$$nxt_{pre_i} \gets j$$
$$pre_i \gets j$$

题解第一次写这么长（bushi）。

```cpp
#include <bits/stdc++.h>
typedef long long ll;

const int N = 2e6 + 100;
int n, a[N], pre[N], nxt[N];

int main() {

//	freopen(".in", "r", stdin);
//	freopen(".out", "w", stdout);

	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);

	std::cin >> n;
	for (int i = 1; i <= n; ++ i) std::cin >> a[i];
	if (a[n] != n) return std::cout << -1, 0;
	for (int i = 1; i < n; ++ i) nxt[a[i]] = a[i + 1];
	for (int i = 2; i <= n; ++ i) pre[a[i]] = a[i - 1];
	int cnt = 0; 
	// 从最后一个数开始，每次拉比它小 1 的数，若已经在它前面，就不算代价
	for (int i = n; i > 1; -- i) {
		if (pre[i] == i - 1) continue ;
		++ cnt;
		nxt[pre[i - 1]] = nxt[i - 1];
		pre[nxt[i - 1]] = pre[i - 1];
		nxt[i - 1] = i; pre[i - 1] = pre[i];
		nxt[pre[i]] = i - 1; pre[i] = i - 1;
	}
	std::cout << cnt;

	return 0;
}

```


---

## 作者：Night_sea_64 (赞：0)

首先发现，最后一个数必须是 $n$，否则无解。因为最后一个数不能插入到前面，也没有任何数可以插入到数列的最后。

于是考虑从后往前扫。接下来发现 $n-1$ 这个数执行一次插入一定能插入到 $n$ 前面去，那就将它插入过去。然后 $n-2$ 这个数执行一次插入一定能插入到 $n-1$ 前面……

题目中要求的是最小次数。所以当一个数 $i$ 不用插入已经在 $i+1$ 前面了，那答案就可以少一次。

如何判断这种情况？$i$ 前面比他大的数已经插入到他后面去了，所以用 $i$ 所在的原来的下标减去前面比他大的数的个数，就能得到当前所在的下标。而前面比他大的数的个数我使用了树状数组维护。

```cpp
#include<iostream>
using namespace std;
int n,p[2000010],pos[2000010],a[2000010],cnt[2000010],ans;
int lowbit(int x){
    return x&(-x);
}
void add(int x)
{
    while(x<=n)a[x]++,x+=lowbit(x);
}
int query(int x)
{
    int sum=0;
    while(x)sum+=a[x],x-=lowbit(x);
    return sum;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>p[i];
        pos[p[i]]=i,cnt[p[i]]=i-1-query(p[i]);
        add(p[i]);
    }
    if(n==1)
    {
        cout<<0<<endl;
        return 0;
    }
    if(p[n]!=n)
    {
        cout<<-1<<endl;
        return 0;
    }
    for(int i=n-1;i>=1;i--)
        if(pos[i]-cnt[i]<i)ans++;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：Wei_Han (赞：0)

## Solution
观察可以发现，对于一个数，只要后面有小于它的数，就必须要进行一次操作，换句话说，所有不需要进行操作的数所形成的序列一定是单调递增的，而不在序列中的数的个数就是答案。这个过程用单调队列维护即可。

对于无解情况，可以发现，只有 $p_j>p_i$ 时才可以将 $i$ 放到 $j$ 的前面，又因为是排列，所以当 $n$ 不在序列最后时，它无法再往后放，所以一定无解。
## Code
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define pr printf("\n")
#define pp printf(" ")
#define pii pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(ll i = a ; i <= b ; i ++ )
#define Fo(a,i,b) for(ll i = a ; i >= b ;-- i  )
using namespace std;
typedef long long ll;
typedef double db;
const int N=2e6+5;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}

ll last,n,a[N]; 
deque<ll> q;
int main(){
	read(n);
	fo(1,i,n) read(a[i]);
	if(a[n]!=n){wr(-1);return 0;}
	ll sum=0;
	fo(1,i,n-1){
		while(!q.empty()&&a[i]<q.back()) q.pop_back(),sum++;
		q.push_back(a[i]);
	}
	wr(sum);
	return 0;
}
``````

---

## 作者：nkrqzjc_zzz (赞：0)

### [题目链接](https://www.luogu.com.cn/problem/P10155)

------------

### 思路

赛上就做出来了，感觉这道题跟**二分**没有任何关系！！！（可能还有我没想到的方法吧）

这道题的题意很好理解，就是选择一个数，插入到离这个数最近的且比这个数大的数字前。最后要你求出至少需要多少次插入，才能使得 $p$ 数列严格递增。

之后我分析了一下样例，再自己造了几组手推，可以发现一个没有多大用处但也算一个突破口的性质。如果初始数列中的 $p_n\neq n$ 那这个数列一定无解。

由此性质我们就可以引申出一个更加庞大的性质，若一个数 $x$ 的后面已经没有比它大的数字且 $x\neq n$ 的话，这个数列也是无解的。反之这个数列一定有解。

接着是如何计算答案，我们可以先想一想，我们已经知道这个数列肯定有解，一定尽量是让每一个数字插入一次或者根本不插入就来到相应的位置。可是题目中最近的 $j$ 可不是固定的，我们怎么办呢？

可以按数字的从大到小去选，当一个数 $y$ 它的右边有比它小的数字时，它就进行插入（因为是从大到小选择数字，这个数字一定会插入到 $y+1$ 的左边）。

这道题就这么做完了！

------------

大概过程如下：

从大到小依次找数字

如果这个数字可以调整位置就调整并且答案增加；

如果这个数字本身就在自己的位置上什么都不做；

如果这个数字需要调整位置，但是后面已经没有可以给他调整的数了，就输出 $-1$ 然后退出。

------------

等等，这么做不是 $O(n^2)$ 吗？但 $n\leq 2\times 10^6$ 呀。

这里就要请出我们的优化手段了。

具体实现就用一个类似于后缀和的东西存最大和最小，用法如下：

假设我遍历到一个位置 $z$。如果 $z$ 后面有比他大的则这个数字有解，如果 $z$ 后面有比他小的则需要执行插入操作。

最后的复杂度为 $O(n)$。

------------

### 代码

实现细节看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p[2000002],a,b[2000002],c[2000002],w[2000002];
//n,p的意思如题意，a记录答案，b后缀最大，c后缀最小，w记录每个数字的位置 
int main(){
	cin>>n;
	memset(c,0x3f3f3f3f,sizeof(c));//因为c记录后缀最小，所以初始值要为无限大 
	for(int i=1;i<=n;i++){
		scanf("%d",&p[i]);
		w[p[i]]=i;
	}
	for(int i=n;i>=1;i--){
		b[i]=max(b[i+1],p[i]);
		c[i]=min(c[i+1],p[i]);
		//记录后缀最大和最小 
	}
	for(int i=n;i>=1;i--){//倒序遍历 
		int u=w[i];
		if(b[u+1]>=p[u]||u==n){//有解 
			if(u!=n){//不为n 
				if(c[u+1]<p[u])a++;//后面有比它小的 
			}
		}
		else{//无解 
			puts("-1");
			return 0;
		}
	}
	cout<<a;
	return 0;//好习惯 
}
```


---

## 作者：liwenxi1145144444 (赞：0)

### 题意
任选一个数 $p_i$，将其删除再插入到他的右边第一个比它大的 $p_j$ 前面。问操作几次能使得 $p_i = i$。无解输出 $-1$。
### 思路
#### 无解情况
当 $a_n \ne n$ 时无解，因为没有比 $n$ 更大的数，$n$ 就无法通过操作移动到 $a_n$。
#### 有解情况
由于此时 $a_n = n$，所以我们只要从 $n-1$ 开始枚举，一直枚举到 $1$，对于其中的每一个数，如果此数不需要操作就已经到达了正确位置且比他大的数字都已经操作完，那么就跳过他。否则操作次数加 $1$，然后进行删除与插入操作。那如何删除和插入呢？双向链表即可。

`AC`代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[2000005],id[2000005],sum;//id[i]记录i在链表中的下标，sum为答案
struct node{
	int prev,next,w;//前驱，后继，权值
}l[2000005];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		id[a[i]]=i;
		if(i==1){
			l[i]={0,2,a[i]};
		}else if(i==n){
			l[i]={i-1,0,a[i]};
		}else{
			l[i]={i-1,i+1,a[i]};
		}
	}
	if(a[n]!=n){
		cout<<-1;
		return 0;
	}
	l[0].next=1;
	l[0].prev=n;
	for(int i=n-1;i>=1;i--){
		if(l[l[id[i]].next].w!=i+1){//判断当前i是否合法
			sum++;
			l[l[id[i]].prev].next=l[id[i]].next;
			l[l[id[i]].next].prev=l[id[i]].prev;
            //删除
			l[id[i]].prev=l[id[i+1]].prev;
			l[id[i]].next=id[i+1];
			l[l[id[i+1]].prev].next=id[i];
			l[id[i+1]].prev=id[i];
            //插入
		}
	}
	cout<<sum;
	return 0;
}
```


---


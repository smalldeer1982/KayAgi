# Task

## 题目描述

今天公司有 $m$ 项任务要完成。第 $i$ 项任务需要 $x_i$ 分钟来完成。同时，这个任务有一个困难级别 $y_i$。级别低于该任务级别 $y_i$ 的机器无法完成这项任务。如果公司完成了这项任务，他们将获得 $(500\times x_i+2\times y_i)$ 美元。

公司有 $n$ 台机器。每台机器都有最大工作时间和一个级别。如果任务的时间超过机器的最大工作时间，则该机器无法完成这个任务。每台机器一天只能完成一项任务。每项任务只能由一台机器完成。

公司希望最大化今天他们可以完成的任务数量。如果存在多个解决方案，他们希望使收益最大化。

## 样例 #1

### 输入

```
1 2 
100 3 
100 2 
100 1```

### 输出

```
1 50004```

# 题解

## 作者：MinimumSpanningTree (赞：12)

[题目链接](https://www.luogu.com.cn/problem/P10464)

挺不错的一道贪心题。首先观察数据范围，$x$ 最小可以是 $1$，$y$ 最大可以是 $100$，根据收益可以计算出 $1\times500=500$，$100\times2=200$，由此可见，在 $x$ 最小，$y$ 最大时，$x$ 带来的收益却比 $y$ 大。于是我们可以得出结论：无论如何，$x$ 的价值永远比 $y$ 大。这就是我们贪心的突破口，由此结论我们可以优先考虑 $x$。

于是我们将机器和任务都按 $x$ 为第一关键字，$y$ 为第二关键字从大到小排序。接下来依次枚举任务，找出所有 $x$ 能满足当前任务的机器，再从这些机器里寻找满足 $y$ 的，如果存在多个机器可以满足，则我们贪心的选取 $y$ 最小的那个。因为 $y$ 并不是有序的，后面可能会出现更大的 $y$，当然要尽量把大的留给后面的了。

对于查找满足 $x$ 的机器：这时我们会发现，如果枚举每次任务的时候用遍历的方式寻找机器，$O(nm)$ 明显是超时的。但因为机器和任务的 $x$ 都是有序的，若当前机器不能满足任务，则后面的机器也不能，若某个机器满足当前任务，则它必定也满足下一个任务。故我们可以维护一个指针，每一轮查找新的可以满足的机器。

对于查找满足 $y$ 的机器：与上面相同，直接枚举显然是超时的。但观察到 $y\le100$，容易想到我们可以使用一个数组 $c_i$ 表示 $y=i$ 的机器数量，$O(100m)$ 可以通过。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=100100,M=110;
int n,m,c[M],p,cnt;
ll ans;
struct node
{
	ll x,y;
}a[N],b[N];
bool cmp(node a1,node a2)
{
	if(a1.x!=a2.x) return a1.x>a2.x;
	return a1.y>a2.y;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld%lld",&a[i].x,&a[i].y);
	for(int i=1;i<=m;i++) scanf("%lld%lld",&b[i].x,&b[i].y);
	//从大到小排序 
	sort(a+1,a+n+1,cmp);
	sort(b+1,b+m+1,cmp);
	for(int i=1;i<=m;i++)//枚举任务 
	{
		while(p<n&&a[p+1].x>=b[i].x)//维护指针，寻找新的可以满足x的机器 
		{
			p++;
			c[a[p].y]++; 
		}
		for(int j=b[i].y;j<=100;j++)//在满足x的机器里，寻找满足y的 
		{
			if(c[j])
			{
				cnt++;
				c[j]--;//记得去掉 
				ans+=b[i].x*500+b[i].y*2;
				break;//找到第一个就退出，因为要贪心地取y最小的 
			}
		}
	}
	printf("%d %lld",cnt,ans);
	return 0;
}
```

---

## 作者：liguangjun2023 (赞：4)

解题思路为贪心算法。 
1. $m$ 个任务和 $n$ 个机器，按照 $x$ 和 $y$ 从大到小排序。
2. 遍历任务，找到能够完成任务 $x$ 的所有机器，把这些机器保存到桶数组 $t[]$ 中。
3. 从桶数组中，找到第一个满足 $y$ 的机器，即是最合适的机器。
   

---


```cpp
#include <bits/stdc++.h>
using namespace std;
struct nd{
	int x,y;
}ma[100010],ta[100010]; 
int n,m,t[150];
bool cmp(nd p,nd q){
	if(p.x!=q.x)
		return p.x>q.x;
	else
		return p.y>q.y;
}
int main(){
	scanf("%d%d",&n,&m) ;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&ma[i].x,&ma[i].y) ;	
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d",&ta[i].x,&ta[i].y) ;		
	}
	// 任务和机器从大到小排序 
	sort(ma+1,ma+1+n,cmp);
	sort(ta+1,ta+1+m,cmp);
	
	int pos=0,j;
	long long ans=0,nm=0;
	// 枚举每个任务，找到最合适的机器 
	for(int i=1;i<=m;i++){	
		// 把所有能满足x的机器放入桶中；	
		for(j=pos+1;j<=n;j++){
			if(ma[j].x>=ta[i].x){
				t[ma[j].y]+=1;
				pos=j;
			}else
				break;
		}
		// 桶里面的一定能满足当前任务的x，只要y合适就是最合适的。 
		for(int y=ta[i].y;y<=100;y++){
			if(t[y]){
				nm+=1;
				ans+=500*ta[i].x+2*ta[i].y;
				t[y]-=1;
				break; 
			}
		}
	}
	printf("%d %lld",nm,ans);
	
	return 0;
}
```

---

## 作者：iamajcer (赞：4)

# 思路

首先，要求收益最大化，且选择方式没后效性，可以很自然的想到贪心。

注意到题目中给定 $x<1440$，$y\le100$，且贡献为 $(500\times x_i+2\times y_i)$，$y$ 取到最大值也没有 $x$ 的贡献大。我们可以对于每个机器，任务进行排序。按照 $x$ 为第一关键字，$y$ 为第二关键字排序。

排完序之后，确保了 $x_i$ 是单调递减的，这一点很重要，在后续我会反复强调。我们现在就可以枚举每一个任务，看看是否能完成。对于每一个任务，假设先不考虑等级限制，如果时间长的任务我们可以完成，那么时间短的任务更加不用说了，肯定可以完成。这样我们考虑用贪心的思想，用等级最低且能完成这个任务的机器才是最优的，这样可以节省更多高等级机器留着以后去用，因为 $x_i$ 是单调递减的，所以对于 $x_i$ 不用担心，前面的机器能完成，后面的机器更加能完成，主要就是 $y_i$ 的限制了。

所以我们可以维护一个 multiset，存储所有能够完成该任务的机器的等级，注意，由于 $x_i$ 的单调性，我们不用每一次重新维护 multiset，而是继承上一次的值。

基于贪心，且 multiset 自带排序功能，我们可以二分查找第一个大于等于任务等级的机器等级，然后累加答案。


# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100005;

struct node
{
	int x, y;
}a[N], b[N];
int n, m, cnt=0;
long long ans=0;
multiset<int> s;
multiset<int>::iterator it;
bool cmp(node a, node b)
{
	if (a.x==b.x) return a.y>b.y;
	return a.x>b.x;
}
int main()
{
	scanf("%d%d", &n, &m);
	for (int i=1; i<=n; i++) scanf("%d%d", &a[i].x, &a[i].y);
	for (int i=1; i<=m; i++) scanf("%d%d", &b[i].x, &b[i].y);
	
	sort(a+1, a+1+n, cmp);
	sort(b+1, b+1+m, cmp);
	
	int h=1;
	for (int i=1; i<=m; i++)
	{
		for (int j=h; j<=n; j++)
		{
			if (a[j].x>=b[i].x)
			{
				s.insert(a[j].y);
				h=j+1; //因为此时满足条件，下一次循环从本次循环到的数往后一个数开始循环
			}
			else
			{
				h=j; //因为此时不满足条件，下一次就从本次循环到的数开始循环
				break;
			}
		}
		
		it=s.lower_bound(b[i].y);
		if ((it)!=(s.end()))
		{
			ans+=500*b[i].x+2*b[i].y;
			cnt++;
			s.erase(it);
		}
	}
	
	printf("%d %lld", cnt, ans);
	return 0;
}
```

---

## 作者：Bobi2014 (赞：3)

这是一道~~可爱~~的贪心题。

题目要求输出 $ans1$ 与 $ans2$。

- $ans1$ 表示最多能搞定的任务数。
- $ans2$ 则表示能获得的钱。

我们发现一个任务的 $money=500x+2y$，$x$ 的贡献最少为 $1 \times 500 = 500$，$y$ 的贡献最多为 $100 \times 2 =200$，$500>200$，**说明 $x$ 的作用比 $y$ 大**，所以我们先给任务与机器按 $x$ **为第一关键字，$y$ 为第二关键字**按降序排个序。

我们观察排序后的两个数组，不难发现两点：
- **如果机器 $x$ 无法完成任务 $y$，那么机器 $x+1$ 也无法完成任务 $y$。**
- **如果机器 $x$ 可以完成任务 $y$，那么机器 $x$ 也可以完成任务 $y+1$。**

所以我们可以枚举任务，用一个指针存储当前 $x$ 满足条件的最右边的下标，用一个桶存每个 $y$ 出现了几次，枚举符合条件的 $y$（因为 $y≤100$），若枚举的 $y$ 存在则桶中的 $y$ 的次数减一，$ans1$ 加一，$ans2$ 加上 $x \times 500+y \times 2$，然后就不用枚举当前任务匹配的 $y$ 了，最终时间复杂度 $O(n \log n)$。

**这题要开 long long，但也不能全开。**

---

## 作者：Lcm_simida (赞：1)

## [题目传送门](https://www.luogu.com.cn/problem/P10464)

这道题我们的思路就是根据题目中所说的尽可能的完成更多的任务，而这题的**突破口**就是更小的 $x$ 。所以我们便可以从小到大排序，因为这样我们便可以枚举一遍机器人的同时，再使用 $dis[i]$ 表示在 $i$ 的时间有多少可以的任务，因为机器人的时间是单调不递减的。维护 $dis$ 的代码：

```cpp
		while(num<=m&&b[num].y<=a[i].y) nm[b[num].x].push(b[num].y),dis[b[num++].x]++;
```

又因为存任务的数组也是单调不递减的，所以我们完全可以使用栈来存任务的等级

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,dis[1505],ans=0,cnt=0,num=1;
struct node{
	long long x,y;
}a[100005],b[100005];
bool Cmp(node x,node y){//从小到大排序
	return x.y<y.y;
}
stack<long long> nm[1505];
int main(){
	cin>>n>>m;
	for(long long i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
	}
	for(long long i=1;i<=m;i++){
		cin>>b[i].x>>b[i].y;
	}
	sort(a+1,a+n+1,Cmp);
	sort(b+1,b+m+1,Cmp);
	for(long long i=1;i<=n;i++){
		while(num<=m&&b[num].y<=a[i].y) nm[b[num].x].push(b[num].y),dis[b[num++].x]++;//维护dis数组
		for(long long j=a[i].x;j>=1;j--){
			if(dis[j]!=0){
				ans++;
				cnt+=(500*j+2*nm[j].top());//记录答案
				nm[j].pop();
				dis[j]--;
				break;
			}
		}
	}
	cout<<ans<<" "<<cnt;//<<" "<<num<<" "<<dis[1]<<" "<<dis[100];
	return 0;
} 
```

---

## 作者：iamjcer (赞：1)

# 思路

我们通过研究数据范围就可以知道：当 $x=1，y=100$ 时，$x$，$y$ 分别贡献就是：$500 \times 1$，$2 \times 100$，那么我们可以得到结论：哪怕 $x$ 再小，**任何时候也不会小于 $y$ 的贡献**，可以发现，我们最优策略就是选择满足条件的任务中 $x$ 值越大越好的任务，所以我们可以考虑**贪心**来做。

怎么贪心呢？

根据上面推出的结论：**$x$ 任何时候也不会小于 $y$ 的贡献**，那么显然的，我们可以按照 $x$ 作为第一关键字排序，然后 $y$ 作为第二关键字排序，代码如下：

```cpp
bool cmp(node a,node b){
	if(a.x==b.x) return a.y>b.y;
	else return a.x>b.x; 
}
```

排完序后，该怎么取求满足条件的任务呢？

看下图：![](https://cdn.luogu.com.cn/upload/image_hosting/9nqhoga2.png)这里可以暴力枚举 $m$ 个任务，然后在用一个指针在 $n$ 个机器人中寻找合法的并进入集合。因为这 $n$ 个机器人是按机器的最大工作时间从大到小排序的，所以只要第 $i$ 个机器人完成不了这个任务，那么第 $i+1$ 个人也不可以完成这个任务，说明具有**单调性**，根据这个特性，我们可以印证指针遍历这种贪心的合法性。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 500005
using namespace std;
multiset<int> sset;//定义集合 
multiset<int>::iterator ffind;
struct node{
	int x;
	int y;
}a[N],b[N];
int n,m,second,cnt=0,sum=0;
bool flag=false;
bool cmp(node a,node b){//贪心策略：按 x 作为第一个关键字排序 y 作为第二关键字 
	if(a.x==b.x) return a.y>b.y;
	else return a.x>b.x; 
}
signed main(){
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld %lld",&a[i].x,&a[i].y);
	}
	for(int i=1;i<=m;i++){
		scanf("%lld %lld",&b[i].x,&b[i].y);
	}
	sort(a+1,a+1+n,cmp);
	sort(b+1,b+1+m,cmp);
	second=1;//指针初始化 
	for(int i=1;i<=m;i++){
		for(int j=second;j<=n;j++){//从指针往后开始寻找 
			if(flag) break;
			if(a[j].x>=b[i].x){
				sset.insert(a[j].y);//合法的进入集合 
				if(j==n) flag=true;
			}else{
				second=j;
				break;
			}
		}
		ffind=sset.lower_bound(b[i].y);//在集合里面寻找第一个大于等于此时任务等级的机器人等级 
		if((ffind)!=(sset.end())){
			cnt++;
			sum+=500*b[i].x+2*b[i].y;//加上合法贡献值 
			sset.erase(ffind);//把这个值从集合里面删除，避免后面重复使用 
		}
	}
	printf("%lld %lld\n",cnt,sum);
	return 0;
}

```

---

## 作者：sillation (赞：1)

### 题目传送门
-------------------------
### 思路：
感谢 [Rosaya](https://www.luogu.com.cn/user/191748) 和 [ttp02](https://www.luogu.com.cn/user/378467) 提供的思路。

首先我们可以知道要把机器与任务降序排序，以 $x$ 为第一关键字，$y$ 为第二关键字排序。

然后我们就要在任务上选择权值 $x$ 的机器。

怎么样快速地把机器与任务排序呢。SORT 是不行的，因为 $1 \le N \le 100000$，$1 \le M \le 100000$。但是我们可以用计数排序啊，因为 $1 \le x \le 1440$，$1 \le y \le 1440$。所以我们可以建立两个 vector 二维数组来存储并排序任务与机器。

怎么找出不小于权值 $y$ 的最小数呢，不防用 set 的 `x.lower_bound` 用来寻找。在这里介绍一种数据结构 multiset：你可以把它看组一个序列。插入一个数，删除一个数都能够在 $O(logn)$ 的时间内完成，而且它能时刻保证序列中的数是有序的。而且序列中可以存在重复的数。但 set 中的元素只能出现一次。而且 multiset 也可以使用 `x.lower_bound`。

注意：

- 记录获得的收益的变量一定要用 long long。
- 一定是逆序。
- 获取到小于权值 $y$ 的最小数后记得用 `x.end()` 判断此数是否存在。用完后记得删除。

---

## 作者：__DAN__ (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P10464)
这道题我们的思路就是根据题目中所说的尽可能的完成更多的任务，而这题的**突破口**就是更小的 $x$ 。所以我们便可以从小到大排序，因为这样我们便可以枚举一遍机器人的同时，再使用 $dis[i]$ 表示在 $i$ 的时间有多少可以的任务，因为机器人的时间是单调不递减的。维护 $dis$ 的代码：
```cpp
while(num<=m&&b[num].y<=a[i].y) nm[b[num].x].push(b[num].y),dis[b[num++].x]++;
```

又因为存任务的数组也是单调不递减的，所以我们完全可以使用栈来存任务的等级

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,dis[1505],ans=0,cnt=0,num=1;
struct node{
	long long x,y;
}a[100005],b[100005];
bool Cmp(node x,node y){//从小到大排序
	return x.y<y.y;
}
stack<long long> nm[1505];
int main(){
	cin>>n>>m;
	for(long long i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
	}
	for(long long i=1;i<=m;i++){
		cin>>b[i].x>>b[i].y;
	}
	sort(a+1,a+n+1,Cmp);
	sort(b+1,b+m+1,Cmp);
	for(long long i=1;i<=n;i++){
		while(num<=m&&b[num].y<=a[i].y) nm[b[num].x].push(b[num].y),dis[b[num++].x]++;//维护dis数组
		for(long long j=a[i].x;j>=1;j--){
			if(dis[j]!=0){
				ans++;
				cnt+=(500*j+2*nm[j].top());//记录答案
				nm[j].pop();
				dis[j]--;
				break;
			}
		}
	}
	cout<<ans<<" "<<cnt;//<<" "<<num<<" "<<dis[1]<<" "<<dis[100];
	return 0;
}
```

---

## 作者：Walter_Fang (赞：0)

简单贪心。由于时间对收入的影响远大于级别对收入的影响，故优先考虑时间再考虑级别进行排序。然后逆序枚举每个任务，每次选择能满足当前任务所需时间的机器中级别最低的一台即得最优方案。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+10,M=1e2+50;
struct Node{ll x,y;}a[N],b[N];
ll n,m,i,j,pos,x,s,ans,f[M];
int main(){
	cin>>n>>m;
	for(i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	for(i=1;i<=m;i++)cin>>b[i].x>>b[i].y;
    stable_sort(a+1,a+1+n,[](Node x,Node y){return x.x!=y.x?x.x>y.x:x.y>y.y;});
    stable_sort(b+1,b+1+m,[](Node x,Node y){return x.x!=y.x?x.x>y.x:x.y>y.y;});
	for(i=1;i<=m;i++){
		for(j=pos+1;j<=n;j++)
			if(a[j].x>=b[i].x)f[a[j].y]+=1,pos=j;
			else break;
		for(x=b[i].y;x<=100;x++)
			if(f[x]){
				s++;ans+=b[i].x*500+b[i].y*2;f[x]--;
				break;
			}
	}
	cout<<s<<' '<<ans;
}
```

---

## 作者：cly312 (赞：0)

由于时间对收入的影响远远大于等级对收入的影响，因此对于最优的选法一定是优先考虑时间的，因此得出贪心策略。

贪心策略：将机器和任务都按照时间和等级从大到小排序(时间优先，等级其次)，然后从大到小枚举每个任务，对于每个任务，选择一个能满足当前任务所需时间的机器中等级最低的机器来完成当前任务。这样能保证最优的安排策略。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int n,m;
	cin>>n>>m;
	vector<pair<int,int>>machine(n),task(m);
	for(auto&i:machine)cin>>i.first>>i.second;
	for(auto&i:task)cin>>i.first>>i.second;
	sort(machine.begin(),machine.end());
	sort(task.begin(),task.end());
	int j=n-1;
	vector<int>bucket(101,0);
	int num=0,money=0;
	for(int i=m-1; i>=0; --i) {
		for(j; j>=0; --j)
			if(machine[j].first>=task[i].first)
				bucket[machine[j].second]++;
			else break;
		for(int k=0; k<bucket.size(); ++k)
			if(k>=task[i].second&&bucket[k]) {
				num++;
				money+=500*task[i].first+2*task[i].second;
				bucket[k]--;
				break;
			}
	}
	cout<<num<<' '<<money<<endl;
}
```

---


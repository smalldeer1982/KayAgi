# [NOIP 2008 普及组] 排座椅

## 题目描述

上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的 $D$ 对同学上课时会交头接耳。

同学们在教室中坐成了 $M$ 行 $N$ 列，坐在第 $i$ 行第 $j$ 列的同学的位置是 $(i,j)$，为了方便同学们进出，在教室中设置了 $K$ 条横向的通道，$L$ 条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了 $2$ 个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

上图中用符号\*、※、+标出了 $3$ 对会交头接耳的学生的位置，图中 $3$ 条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。

2008 年普及组第二题


## 样例 #1

### 输入

```
4 5 1 2 3
4 2 4 3
2 3 3 3
2 5 2 4
```

### 输出

```
2
2 4
```

# 题解

## 作者：chrispang (赞：11)

## 题目大意

给定 $n$ 个坐标，要在一些地方开一条走道，使得被分开的坐标最多，其中横着 $k$ 条，竖着 $l$ 条。

## 题目分析

1. 我们定义一个结构体，表示一条道路的坐标和可以分开的人数。之后定义 $x$ 数组和 $y$ 数组表示横着的道路与竖着的道路。

```cpp
struct node{
	int x, n; //x表示分开的行或列，n表示分开的人数 
}x[1010], y[1010];
```

2. 进行输入。

我们使用我们的结构体记录一条道路分开后能分开几个人，之后处理答案。

```cpp
cin >> m >> n >> k >> l >> d;
for (int i = 1; i <= d; i++) {
	int x1, y1, p1, q1;
	cin >> x1 >> y1 >> p1 >> q1;
	if(x1 == p1) {
		y[min(y1, q1)].x = min(y1, q1); //记录坐标 
		y[min(y1, q1)].n++; //这条道路如果加上可以分开一个人
	}
    if(y1 == q1) {
	    x[min(x1, p1)].x = min(x1, p1); //记录坐标
	    x[min(x1, p1)].n++; //这条道路如果加上可以分开一个人
    }
}
```

3. 排序找答案

找出分开人数多的道路。并且选定前 $k$ 条，整理答案。

```cpp
bool cmp1(node a, node b) { //按人数排
	return a.n > b.n;
}

bool cmp2(node a, node b) { //按坐标排
	return a.x < b.x;
}

sort(x + 1, x + 1 + 1000, cmp1); //分开人数多的放前面
sort(y + 1, y + 1 + 1000, cmp1);
sort(x + 1, x + 1 + k, cmp2); //整理答案 
sort(y + 1, y + 1 + l, cmp2);
```

最后，放上我们的完整代码！

```cpp
#include<bits/stdc++.h>
using namespace std;

int m, n, k, l, d;
struct node{
	int x, n; //x表示分开的行或列，n表示分开的人数 
}x[1010], y[1010];

bool cmp1(node a, node b) {
	return a.n > b.n;
}

bool cmp2(node a, node b) {
	return a.x < b.x;
}

int main() {
	cin >> m >> n >> k >> l >> d;
	for (int i = 1; i <= d; i++) {
		int x1, y1, p1, q1;
		cin >> x1 >> y1 >> p1 >> q1;
		if(x1 == p1) {
			y[min(y1, q1)].x = min(y1, q1); //记录坐标 
			y[min(y1, q1)].n++; //这条道路如果加上可以分开一个人
		}
		if(y1 == q1) {
			x[min(x1, p1)].x = min(x1, p1); //记录坐标
			x[min(x1, p1)].n++; //这条道路如果加上可以分开一个人
		}
	}
	sort(x + 1, x + 1 + 1000, cmp1); //分开人数多的放前面
	sort(y + 1, y + 1 + 1000, cmp1);
	sort(x + 1, x + 1 + k, cmp2); //整理答案 
	sort(y + 1, y + 1 + l, cmp2);
	for (int i = 1; i <= k; i++)
		cout << x[i].x << " ";
	cout << endl;
    for (int i = 1; i <= l; i++)
		cout << y[i].x << " ";
	return 0;
}
```
点个赞吧！球球啦！

---

## 作者：Feuer (赞：11)

感觉代码挺短的，就发上来了。

思路应该是类似桶排序。
数组存储每个过道可以分开的对数。

不过因为题目说方案唯一，只要用2次sort选出最佳的K个/L个过道的临界值即可。

然后在输出时，只输出>=临界值的。


```cpp
#include<iostream>
#include<algorithm>

using namespace std;

int rowpos[1005];  //在位置index处画线后，能隔开的学生对数，用于排序
int rowcopy[1005];  //用于输出的副本
int colpos[1005];
int colcopy[1005];

int main(void)
{
    int m,n,k,l,d;  //行 列 横道 纵道 学生对

    for(int i=0;i>1005;i++)
    {
        rowpos[i] = 0;
        rowcopy[i] = 0;
        colpos[i] = 0;
        colcopy[i] = 0;
    }


    cin>>m>>n>>k>>l>>d;

    while(d--)
    {
        int x,y,p,q;
        int pos = 0;  //临时的行or列坐标

        cin>>x>>y>>p>>q;

        if(x==p)
        {
            pos = min(y,q);
            colpos[pos]++;
            colcopy[pos]++;
        }
        else
        {
            pos = min(x,p);
            rowpos[pos]++;
            rowcopy[pos]++;
        }

    }

    //可加入过道的index为 1~m-1  1~n-1
    //因为最佳方案一定唯一，那么只有第 m-k  和第n-l个元素及之后的为必要的
    //所以小于 (sorted)rowpos[m-k] 和(sorted)colpos[n-l]的行列不输出即可
    sort(rowpos, rowpos+m);
    sort(colpos, colpos+n);
    int rowlim = rowpos[m-k];
    int collim = colpos[n-l];

    for(int i=1; i<=m; i++)
        if(rowcopy[i] >= rowlim)
            cout<<i<<' ';
    cout<<endl;
    for(int i=1; i<=n; i++)
        if(colcopy[i] >= collim)
            cout<<i<<' ';
    cout<<endl;

    return 0;
}
```


---

## 作者：ggpw_XNW (赞：6)

~~贪污~~ 贪心算法的一道题，我的第二篇题解！  
首先我们分析题目，看似很长，但实际上很简单。
## 简化题意：
有 $n$ 对会讲话的同学，给出他们的坐标，要在一些地方开一条走道，使得被分开的同学最多，其中横着 $k$ 条，竖着 $l$ 条。  
简化题意之后是不是很简单呢？那么开始写代码吧！
### 定义部分
```cpp
struct Node{
	int num , p;
}a[10005] , b[10005];
int n , m , k , l , d;
```
这里的 $num$ 指的是这条走到能分开多少对同学，$p$ 指的是这条走到在第 $p$ 和 $p+1$ 行之间。可能有人会问：$p$ 可以用下标表示啊，为什么要开一个结构体呢？这是因为后面要排序，排完之后方便排回来。
### 读入部分
```cpp
cin >> m >> n >> k >> l >> d;
for(int i=1;i<=d;i++){
	int x , y , xx , yy;
	cin >> x >> y >> xx >> yy;
	if(x==xx)b[min(y,yy)].p = min(y,yy) , b[min(y,yy)].num++;
    else a[min(x,xx)].p = min(x,xx) , a[min(x,xx)].num++;
}
```
第 $5$ 行是判断这两个同学在同一行，将他们中间的那条线能分开的对数加 $1$，而第 $6$ 行是判断同一列。
### 排序部分
```cpp
bool cmp1(Node x, Node y){
	return x.num > y.num;
}
bool cmp2(Node x, Node y){
	return x.p < y.p;
}
sort(a+1,a+m+1,cmp1);sort(b+1,b+n+1,cmp1);
sort(a+1,a+k+1,cmp2);sort(b+1,b+l+1,cmp2);
```
先看第一次排序，按它们能分开的对数排序。第二次排序，按它们的位置排序。（顺便吐槽一下，$n$ 和 $m$ 写反都能过）
### 输出部分
先输 $a$ 再输 $b$，中间换行，我就不多说了。
## 最后的话
### 这道题为什么可以用贪心？
我们可以确定，每一对同学可以且只可以用一条线分开，所以我们可以保证分开同学的线不会重复，也就可以使用贪心。~~二是因为题目标签~~
### 题解仅供学习参考使用

---

## 作者：xingshuyan000 (赞：2)

# 题目大意

教室的座位一共有 $M$ 行 $N$ 列，同时有 $K$ 条横向的过道和 $L$ 条纵向的过道，有 $D$ 对同学上课说话，每对说话同学的的坐标分别是 $(X_i,Y_i),(P_i,Q_i)$。为了让上课说话同学的对数尽可能少，你需要尽可能多地通过重新给这些同学排座位，使他们之间有通道隔开，请给出最好的通道划分方案。

# 题目分析

本题考查知识点：贪心、排序、模拟。

我们可以仔细读一下题，会发现有这样几个字：
>输入（的 $D$ 组上课说话的同学的数据）保证他们前后相邻或者左右相邻

为了满足这样的条件，我们就可以让每一条通道隔开的上课说话的同学的对数尽可能多，这样可以直接考虑贪心。如果两个同学左右相邻，就说明他们在同一行，那么数据特征就是 $X_i=P_i$，即横坐标相同，这样的话就可以增加一列竖着的过道；如果两个同学前后相邻，就说明他们处在同一列，那么数据特征就是 $Y_i=Q_i$，这样就可以增加一行横着的过道。

我们可以把每增加一条过道可以分隔开的同学的数量统计一下，竖着的过道选出前 $L$ 个，横着的过道选出前 $K$ 个，然后把这些行或列从小到大依次输出即可。

我的代码里面有注释，可以结合注释来理解。

# CODE

其实这道题是我 2023 年 12 月做的，当时的码风太抽象，刚才我又重构了一下代码，应该会更好看一些。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int x[N], y[N], c[N], dd[N]; //x: 列交头接耳计数，y: 行交头接耳计数，c和dd用于存储结果
int main()
{
	int m, n, k, l, d;
	cin >> m >> n >> k >> l >> d;
	for(int i = 1; i <= d; i ++)
	{
		int xi, yi, pi, qi;
		cin >> xi >> yi >> pi >> qi;
		if(xi == pi) x[min(yi, qi)] ++; //如果在同一行，增加所在列的交头接耳计数
		if(yi == qi) y[min(xi, pi)] ++; //如果在同一列，增加所在行的交头接耳计数
	}
	for(int i = 1; i <= k; i ++)
	{
		int mmax = INT_MIN, p;
		for(int j = 1; j < m; j ++)
			if(y[j] > mmax) //如果当前行交头接耳计数大于最大计数
				mmax = max(mmax, y[j]), p = j; //更新最大计数和位置
		y[p] = 0, c[p] ++; //标记已选择的行，避免重复选择，同时记录开启通道的次数
	}
	for(int i = 1; i <= l; i ++)
	{
		int mmax = INT_MIN, p;
		for(int j = 1; j <= n; j ++)
			if(x[j] > mmax)
				mmax = max(mmax, x[j]),	p = j;
		x[p] = 0, dd[p] ++;
	}
	for(int i = 0; i < 1000; i ++)
	{
		if(c[i] != 0) cout << i << " ";
	}
	cout << endl;
	for(int i = 0; i < 1000; i ++)
	{
		if(dd[i] != 0) cout << i << " ";
	}
	cout << endl;
	return 0;
}
```

---

## 作者：qhr2023 (赞：2)

## solution

贪心和模拟。

要求上课时交头接耳的学生对数最少，转化成求通道能阻断的学生对数最多。

题目保证给出的 $D$ 对同学都是左右或前后相邻，若左右相邻，需要在列上间隔，若前后相邻，需要在行上间隔。由此，我们可以统计出每行能阻断的对数，我们选出前 $K$ 多的行，将这些行按从大到小输出，列是同理的。

[通过记录](https://hydro.ac/record/678b4c6c78562d95912c59dd)。

## code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, l, d, K[1005], L[1005], ans[1005];
pair<int, int> a[1005];
void solve (int x, int b[], int num) {
	ans[0]=0;
	for (int i=1; i<=x; ++i)
		a[i]={b[i], i};
	sort(a+1, a+x+1);
	for (int i=x; i>=x-num+1; --i)
		ans[++ans[0]]=a[i].second;
	sort(ans+1, ans+num+1);
	for (int i=1; i<=num; ++i)
		cout << ans[i] << ' ';
}
int main () {
	cin >> n >> m >> k >> l >> d;
	for (int i=1, x, y, p, q; i<=d; ++i) 
		cin >> x >> y >> p >> q,
		x==p?L[min(y, q)]++:K[min(x, p)]++;
	solve(n, K, k);
	cout << '\n';
	solve(m, L, l);
	return 0;
}
```

---

## 作者：HenryHuang (赞：2)

这道题，我用的是结构体+排序，就是将a行（列）与a+1行（列）讲话人数以结构体形式储存，标号为a，然后排序，然后有可能两行（列）之间没有人讲话，所以要将排序后最前面的零忽略，然后再将答案数组进行从小到大排序，最后输出。

##详见代码：

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm> //头文件
using namespace std;
struct cc
{
    int a;//编号
    int peo;//讲话人数
}h[1001],ll[1001];//行，列
bool cmp(cc x,cc y)//结构体排序
{
    if(x.peo>y.peo)
    return 1;
    return 0;
 } 
int hhh[1001],lll[1001];//答案数组
int main()
{
    int m,n,k,l,d;
    cin>>m>>n>>k>>l>>d;//输入
    for(int i=1;i<=max(m,n);i++)
    {
        h[i].a=i;
        ll[i].a=i;
    }//记录编号
    int x1,y1,p1,q1;
    for(int i=1;i<=d;i++)
    {
        cin>>x1>>y1>>p1>>q1;
        if(x1==p1)
        ll[min(y1,q1)].peo++;
        if(y1==q1)
        h[min(x1,p1)].peo++;
    }//记录讲话人数
    sort(ll+1,ll+max(m,n)+1,cmp);
    sort(h+1,h+max(m,n)+1,cmp);//排序
    int j=1,kkk=1,kk=1;
    for(int i=1;i<=k;i++)
    {
        if(h[j].peo!=0)
        {
            hhh[kkk]=h[j].a;
            kkk++;
        }
        else
        i--;
        j++;
    }
    j=1;
    for(int i=1;i<=l;i++)
    {
        if(ll[j].peo!=0)
        {
        lll[kk]=ll[j].a;
        kk++;
        }
        else
        i--;
        j++;
    }//记录答案
    sort(hhh+1,hhh+kkk);
    sort(lll+1,lll+kk);//将答案排序
    for(int i=1;i<=kkk-1;i++)
    cout<<hhh[i]<<' ';
    cout<<endl;
    for(int i=1;i<=kk-1;i++)
    cout<<lll[i]<<' ';
    cout<<endl;//输出
    return 0;
}

---

## 作者：RedContritio (赞：2)

这个题目在某种程度上令人感到无限的恶心。。。

连续五次10分，总算找到了错误原因。

整理一下思路：

首先，找出每一条可能的切割线，并且求出对应切割能够破坏的组数。

在进行求切割组数时，利用该结构体，ID记录切割线的坐标，entity 记录切割组数。

```cpp
typedef struct tagINT
{
    int ID;
    int entity;
}INT;
```
接下来，将记录的结果进行排序，注意：**不要使用快排！不要使用快排！不要使用快排！**
快排是不稳定的，很容易造成ID的混乱。

比如我直接使用复杂度 n2 的冒泡，对于 n <= 1000 的数据，绝对不会TLE 。

在完全排序之后，分别将两种切割方法的前 K、L 个数据（切割效果降序），按照ID升序重新排序。

然后输出即可，同时控制住结尾没有空格。

**CPP**

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int M,N,K,L,D;
int x,y,p,q;
typedef struct tagINT
{
    int ID;
    int entity;
}INT;
INT l[1020],t[1020],temp;
void save(int x,int y,int p,int q)
{
    if(x==p)
    {
        l[min(y,q)].entity++;
        return ;
    }
    else
    {
        t[min(x,p)].entity++;
        return ;
    }
}
int main()
{
    cin >> M >> N >> K >> L >> D;
    for(int i=0;i<D;i++)
    {
        cin >> x >> y >> p >> q;
        save(x,y,p,q);
    }
    for(int i=1;i<=M;i++)l[i].ID = i;
    for(int i=1;i<=N;i++)t[i].ID = i;
    for(int i=1;i<=M;i++)
    {
        for(int j=i+1;j<=M;j++)
        {
            if(t[i].entity < t[j].entity)swap(t[i],t[j]);
        }
    }
    for(int i=1;i<=N;i++)
    {
        for(int j=i+1;j<=N;j++)
        {
            if(l[i].entity < l[j].entity)swap(l[i],l[j]);
        }
    }
    for(int i=1;i<=K;i++)
    {
        for(int j=i+1;j<=K;j++)
        {
            if(t[i].ID > t[j].ID)swap(t[i],t[j]);
        }
    }
    for(int i=1;i<=L;i++)
    {
        for(int j=i+1;j<=L;j++)
        {
            if(l[i].ID > l[j].ID)swap(l[i],l[j]);
        }
    }
    for(int i=1;i<=K;i++)
    {
        if(i>1)cout << ' ';
        cout << t[i].ID;
    }
    cout << endl;
    for(int i=1;i<=L;i++)
    {
        if(i>1)cout << ' ';
        cout << l[i].ID;
    }
}
```

---

## 作者：Ryan114 (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P1056)

### 题意简化
有一个 $M$ 行 $N$ 列的矩阵，现在给定 $D$ 对横向或纵向相邻的学生，求分配 $K$ 条横向的通道，$L$ 条纵向的通道，使得被隔开的学生对数最多。
![样例图](https://cdn.luogu.com.cn/upload/image_hosting/0z0p5x1i.png)

### 思路
本题考察贪心和结构体排序。每条通道都有两个属性，它的位置和它可以隔开的对数。把横向和纵向通道分别放在一个结构体数组里，输入一对学生的数据，然后将更小的位置存下来。接着，枚举每一行，每一列，计算如果在那里能分开的对数。统计完属性后，将隔开的对数从大到小排序，最大的 $K$ 条和 $L$ 条就是结果，将位置从小到大排序输出。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Line
{
    int id,cut; //位置和分开对数
} hd[1005],ld[1005]; //横过道和纵过道
bool cmp1(Line a,Line b)
{
    return a.cut>b.cut;
}
bool cmp2(Line a,Line b)
{
    return a.id<b.id;
}
int main()
{
    vector<int>hv,lv; //记录横纵相邻的学生
    int m,n,k,l,d; //行，列，横通道数，纵通道数，同学对数
    cin>>m>>n>>k>>l>>d;
    for(int i=1;i<=d;i++)
    {
        int h1,l1,h2,l2;
        cin>>l1>>h1>>l2>>h2;
        if(l1==l2) hv.push_back(min(h1,h2)); //如果列相等，记录行
        else lv.push_back(min(l1,l2)); //如果列不等，记录列
    }
    for(int i=1;i<=m;i++) //对于每一行
    {
        hd[i].id=i; //记录位置
        for(auto j : lv) if(i==j) hd[i].cut++; //记录分开组数
    }
    for(int i=1;i<=n;i++) //对于每一列
    {
        ld[i].id=i; //记录位置
        for(auto j : hv) if(i==j) ld[i].cut++; //记录分开组数
    }
    sort(hd+1,hd+1+m,cmp1); //先按分开对数排
    sort(ld+1,ld+1+n,cmp1);
    sort(hd+1,hd+1+k,cmp2); //再按位置排
    sort(ld+1,ld+1+l,cmp2);
    for(int i=1;i<=k;i++) cout<<hd[i].id<<" ";
    cout<<endl;
    for(int i=1;i<=l;i++) cout<<ld[i].id<<" ";
    return 0;
}
```
[我的记录](https://www.luogu.com.cn/record/198974746)
写题解不易，希望管理通过
### 感谢查看

---

## 作者：GSQ0829 (赞：1)

### 思路：
我们这题需要如何考虑贪心。我们可以考虑横着隔开一条通道，也可以竖着。

我们就可以定义一个变量来存放两种情况各隔开的数量，最后排序一下，就可以了。

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1001;
struct node {
	int x, y;
} k[MAXN], l[MAXN];

bool cmp1(node a, node b) {
	return a.x > b.x;
}

bool cmp2(node a, node b) {
	return a.y < b.y;
}

int m, n, p, q, t, a, b, c, d;

int main() {
	cin >> m >> n >> p >> q >> t;
	while (t--) {
		cin >> a >> b >> c >> d;
		if (a == c) {
			l[min(b, d)].y = min(b, d);
			l[min(b, d)].x++;
		} else {
			k[min(a, c)].y = min(a, c);
			k[min(a, c)].x++;
		}
	}
	sort(l + 1, l + n + 1, cmp1);
	sort(k + 1, k + m + 1, cmp1);
	sort(l + 1, l + q + 1, cmp2);
	sort(k + 1, k + p + 1, cmp2);
	for (int i = 1; i <= p; i++) cout << k[i].y << ' ';
	cout << endl;
	for (int i = 1; i <= q; i++) cout << l[i].y << ' ';
	return 0;
}
```

---

## 作者：fyn1234 (赞：1)

### 思路

要求上课时交头接耳的学生对数最少，就是求通道能阻断的学生对数最多。考虑横着或竖着隔开一条通道，定义一个变量来存放两种情况各隔开的数量，最后排序一下。

### solution

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1005;
struct node 
{
	int x, y;
} k[N], l[N];

bool cmp(node a, node b)
{
	return a.x > b.x;
}
bool cmpp(node a, node b) 
{
	return a.y < b.y;
}
int m, n, p, q, t, a, b, c, d;
int main() {
    //just do it.
	cin >> m >> n >> p >> q >> t;
	while (t--) {
		cin >> a >> b >> c >> d;
		if (a == c) {
			l[min(b, d)].y = min(b, d);
			l[min(b, d)].x++;
		} else {
			k[min(a, c)].y = min(a, c);
			k[min(a, c)].x++;
		}
	}
	sort(l + 1, l + n + 1, cmp);
	sort(k + 1, k + m + 1, cmp);
	sort(l + 1, l + q + 1, cmpp);
	sort(k + 1, k + p + 1, cmpp);
	for (int i = 1; i <= p; i++) cout << k[i].y << ' ';
	cout << "\n";
	for (int i = 1; i <= q; i++) cout << l[i].y << ' ';
	return 0;
}
```

---

## 作者：Wish_kazdel (赞：0)

~~我又来水题解了~~

---

## 思路
先说结论：结构体排序+贪心。

贪心思路并不难想，就是先隔开最多交头接耳的同学的行或者列上面安排通道。具体就是先输入交头接耳同学的位置，判断是左右相邻还是前后相邻，然后用计数器进行记录。
记录完成后就要排序了，因为前面已经是使用结构体图来记录，因此这里不能用普通排序。排序时先按照计数器的大小排序之前用于贪心出的前 $K$ 大能够隔开学生的数。然后再根据题目的要求按照标记的是多少号来排序。

---

## 作者：Jerry_zpl (赞：0)

本题算法：贪心。  
难度建议：橙或下位黄。  
在本题，我们重点需要如何考虑贪心。我们既可以考虑横着隔开一条通道，也可以考虑竖着隔开一条通道。要使交头接耳的同学数量越少，我们可以定义变量 $num$ 来存竖着或横着隔开一条通道后减少接耳的同学数量。既然要使交头接耳的同学数量越少，那么 $num$ 肯定是越大越好。注意：输出时的数是有序的，所以在输出前需要排序。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int num,p;
}x[1000005],y[1000005];
bool cmp1(node q,node h)
{
	return q.num>h.num;
}
bool cmp2(node q,node h)
{
	return q.p<h.p;
}
int main()
{
	int m,n,k,l,d;
	cin>>m>>n>>k>>l>>d;
	for(int i=1;i<=d;i++)
	{
		int xll,yll,x2,y2;
		cin>>xll>>yll>>x2>>y2;
		if(xll==x2)
		{
			y[min(yll,y2)].p=min(yll,y2);
			y[min(yll,y2)].num++;
		}
		if(yll==y2)
		{
			x[min(xll,x2)].p=min(xll,x2);
			x[min(xll,x2)].num++;
		}
	}
	sort(x+1,x+1+m,cmp1);
	sort(y+1,y+1+n,cmp1);
	sort(x+1,x+1+k,cmp2);
	sort(y+1,y+1+l,cmp2);
	for(int i=1;i<=k;i++) cout<<x[i].p<<" ";
	cout<<"\n";
	for(int i=1;i<=l;i++) cout<<y[i].p<<" ";
	cout<<"\n";
	return 0;
}
```

---

## 作者：Eason_lyx (赞：0)

这是一道不算难的**模拟+贪心**的组合题。  
思路与其他题解类似。
### 题目分析
要在题目给定有限的 $k$ 与 $d$ 的限制条件下，尽可能多分隔人数，立马想到**贪心**。而策略也不难想，哪一列（或行）对分隔起到的作用大，就优先使用那一列（或行），于是需要**排序**，考虑开结构体数组。并预处理每行每列能分隔的人数。

剩下的部分请见注释。
### 代码
#### 注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,k,l,d,x,y,p,q,cur;//m*n,k横,l纵,d对讲话:(x,y)和(p,q)
struct M{
    int id,cnt;    
}h[1005],z[1005];//h:列通道讲话计数,z:行通道讲话计数
bool cmp1(M a,M b){//求那一行列讲话人数最多
    return a.cnt>b.cnt;
}
bool cmp2(M a,M b){//将编号排序
    return a.id<b.id;
}
int main(){
    cin>>m>>n>>k>>l>>d;//含义见题面
    for(int i=1;i<=d;i++){
        cin>>x>>y>>p>>q;//输入坐标
        if(x==p){//纵向两人
            cur=min(y,q);//通道坐标（编号）
            h[cur].id=cur;//标注
            h[cur].cnt++;//计数
        }
        else{//横向两人
            cur=min(x,p);//通道坐标（编号）
            z[cur].id=cur;//标注
            z[cur].cnt++;//计数
        }
    }
    sort(h+1,h+n+1,cmp1);//找到分隔哪一列最佳
    sort(z+1,z+m+1,cmp1);//从小到大排列，为输出准备
    sort(h+1,h+l+1,cmp2);//同上
    sort(z+1,z+k+1,cmp2);
    for(int i=1;i<=k;i++)printf("%d ",z[i].id);
    cout<<endl;
    for(int i=1;i<=l;i++)printf("%d ",h[i].id);//输出
    return 0;
}
```

#### 无注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,k,l,d,x,y,p,q,cur;
struct M{
    int id,cnt;    
}h[1005],z[1005];
bool cmp1(M a,M b){
    return a.cnt>b.cnt;
}
bool cmp2(M a,M b){
    return a.id<b.id;
}
int main(){
    cin>>m>>n>>k>>l>>d;
    for(int i=1;i<=d;i++){
        cin>>x>>y>>p>>q;
        if(x==p){
            cur=min(y,q);
            h[cur].id=cur;
            h[cur].cnt++;
        }
        else{
            cur=min(x,p);
            z[cur].id=cur;
            z[cur].cnt++;
        }
    }
    sort(h+1,h+n+1,cmp1);
    sort(z+1,z+m+1,cmp1);
    sort(h+1,h+l+1,cmp2);
    sort(z+1,z+k+1,cmp2);
    for(int i=1;i<=k;i++)printf("%d ",z[i].id);
    cout<<endl;
    for(int i=1;i<=l;i++)printf("%d ",h[i].id);
    return 0;
}
```

[评测记录](https://www.luogu.com.cn/record/199077027)。

---


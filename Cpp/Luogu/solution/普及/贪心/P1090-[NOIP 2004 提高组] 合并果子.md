# [NOIP 2004 提高组] 合并果子

## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。

## 说明/提示

对于 $30\%$ 的数据，保证有 $n \le 1000$：

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。


## 样例 #1

### 输入

```
3 
1 2 9 
```

### 输出

```
15
```

# 题解

## 作者：QuantAsk (赞：297)

# O(n)算法
据说是离散化算法
就是先把原本的从小到大排序排好。然后用两个队列，一个是存储原本的，另一个是存储合成的（由于原本的是从小到大所有新开的也是从小到大）。然后在两个队列的头取最小的，执行两次然后把这两个合并加入第二个队列中。
然后由于输入：
$(1≤ai≤20000)$，所以用桶排序就可以$O(n)$时间复杂度

代码比较丑：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int k,x,num,n1,n2,a1[30001],a2[30001],t[20001],w,sum;
int main()
{
	scanf("%d",&num);
	memset(a1,127/3,sizeof(a1));
	memset(a2,127/3,sizeof(a2));
	for (int i=1;i<=num;i++)
	{
		scanf("%d",&x);
		t[x]++;//桶
	}
	for (int i=1;i<=20000;i++)
	{
		while (t[i])//通排序
		{
			t[i]--;
			a1[++n1]=i;
		}
	}
	int i=1,j=1;
	k=1;
	while (k<num)
	{
		if (a1[i]<a2[j])//取最小值
		{
			w=a1[i];
			i++;
		}
		else
		{
			w=a2[j];
			j++;
		}
		if (a1[i]<a2[j])//取第二次
		{
			w+=a1[i];
			i++;
		}
		else
		{
			w+=a2[j];
			j++;
		}
		a2[++n2]=w;//加入第二个队列
		k++;//计算合并次数
		sum+=w;//计算价值
	}
	printf("%d",sum);
}
```

其实用循环队列会少一些内存~~不过我懒~~

---

## 作者：微雨燕双飞 (赞：138)

好像楼下很少有人手写堆（其实本来就不用），有一位大神用了递归写的，然而蒟蒻难以理解。于是在此发布一份完全手写的堆，可以说就是模板了吧，仅供各位参考。
好，来看程序：
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=10000+10;
int n,heap[maxn],size=0;
void up(int p) //二叉小根堆向上调整（子节点小于父节点就调整）
{
  while(p>1)
  {
    if(heap[p]<heap[p/2])
    {
      swap(heap[p],heap[p/2]);
      p/=2;
    }
    else break;
  }
}
void insert(int val) //二叉堆插入，新元素放在堆底，向上调整
{
  heap[++size]=val;
  up(size);
}
void down(int p) //二叉小根堆向下调整
{
  int s=p*2;
  while(s<=size)
  { //下面这句话是从左右儿子中选一个更小的做交换
    if(s<size&&heap[s+1]<heap[s]) s++; 
    if(heap[s]<heap[p])
    {
      swap(heap[s],heap[p]);
      p=s; s=p*2;
    }
    else break;
  }
}
void extract() //二叉堆删除堆顶
{
  heap[1]=heap[size--]; //将堆底移至堆顶，向下调整
  down(1);
}
int gettop() //返回堆顶的值
{
  return heap[1];
}
int main()
{
  cin>>n;
  for(int i=1; i<=n; i++)
  {
    int a; cin>>a;
    insert(a); //建立二叉堆
  }
  long long ans=0; //其实这里不会越界，但好像原题数据是3万
  while(size>=2) //如果还可合并
  {
    int top1=gettop(); //取出堆顶（堆中最小值）后删除堆顶
    extract();
    int top2=gettop(); //同上
    extract();
    ans+=(top1+top2);
    insert(top1+top2); //将两数之和加入二叉堆，重复运算
  }
  cout<<ans<<endl; //输出答案
  return 0;
}
```

---

## 作者：学委 (赞：123)

证明不断取最小的两堆合并成较大的一堆是最优的。

（不太好证哦）

①**最优方案可以表示成一个二叉树。**总代价 $\sum_{i=1}^{n} a_i × depth_i$。其中 $depth$ 是深度，也就是这堆果子在整个过程中被有效合并了几次。

注意：$a_i$ 都是叶子结点。非叶子结点都是合并后的产物。

②**最小的两堆一定在最优方案树的最深层。**

这个用反证法。假设有一个最优方案树，其最深层中没有最小的两堆。那么把最小的堆与最深层的某堆互换位置形成新方案，保证新方案存在而且新方案的代价小于原方案。

注意：最深层总是一组（一组有两个）或多组叶子节点，来表示它们被**直接**合并。

③**同层叶子节点互换，对总代价无影响。**

根据①的 $\sum$ 得。可见，最小的两堆，如果在最优方案树最深层中不是即将合并的一组，那么可以无偿换为一组。

④根据上两步，我们已经明确：最优方案需要**直接**合并当前最小的两堆。现在我们就进行这个操作。**事实是：现在只剩 $n-1$ 堆了。**我们只知道刚才进行了一个**绝对不错**的操作，而不记得操作之前是什么样的。我们只想对现在剩下的几堆陌生的果子进行最好的操作。忽略之前的树，于是回到①了。

**注意**：这并不意味着之前一步的操作使日后的代价和非常优秀。

***
```
#include <cstdio>
#include <queue>
using std :: priority_queue;
using std :: greater;
using std :: vector;

int n, ans = 0;
priority_queue < int, vector <int>, greater <int> > q;
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i)
	{
		int x; scanf("%d", &x);
		q.push(x);
	}
	while(q.size() > 1)
	{
		int x = q.top(); q.pop();
		int y = q.top(); q.pop();
		ans += x + y;
		q.push(x + y);
	}
	printf("%d\n", ans);
	return 0;
}
```
***

这些说法是不对的：

一、*每步取最小的两堆合并成较大的两堆，能保证形成“这一步代价最小”且“接下来将要消耗的代价比其它方案小”。*

**反例**如，如果有四堆果子，数目分别是$3,4,5,6$。然而我选择合并$5,6$，虽然目前代价很大，但你会发现接下来的代价比“先合并$3,4$，接下来的代价”要小得多。这否定了一些题解。

二、*如果给初始的每堆果子 $a_i$ 记录一个 $t_i$ 表示这堆果子在整个过程中相当于合并了几次，那么 $t_i$ 的和是定值。*

其实方案不同的时候， $t_i$ 之和完全可以变化。可以是 $n^2$ 级别，也可以是 $n~logn$ 级别。这导致上面的证明更难。

***

这道题可视作构造哈夫曼树。而对哈夫曼树正确性的证明让很多人头疼，《Algorithms》也是大花笔墨！所以证明可能真的不是那么简单。

**有更简单的证明、或者上面的证明有问题，就评论吧！**

---

## 作者：logwzc (赞：4)

堆的做法我就不讲了，其他人都讲得很清楚，感觉可以用线段树模拟堆，我就来一发线段树的题解。

代码附上（时间复杂度O(nlogn)  空间复杂度(n)）

```cpp
#include<bits/stdc++.h>
#define N 300001
#define PINF INT_MAX
#define MINF INT_MIN
using namespace std;
struct node{
	int left,right,v;
	bool flag;
};
int n,ans,a[N];
node tree[N*4];
bool tag;
int work(int x,int y){
	if (tag) return min(x,y); else return max(x,y);
}
void mems(node*Tree,int i){
	if (tag) Tree[i].v=PINF; else Tree[i].v=MINF;
	Tree[i].flag=true;
	return;
}
void PushUp(node*Tree,int i){
	Tree[i].v=work(Tree[i<<1].v,Tree[i<<1|1].v);
	Tree[i].flag=Tree[i<<1].flag||Tree[i<<1|1].flag;
	return;
}
void BuildTree(node*Tree,int i,int L,int R){
	Tree[i].left=L;
	Tree[i].right=R;
	if (L==R){
		mems(Tree,i);
		return;
	}
	int m=(L+R)>>1;
	BuildTree(Tree,i<<1,L,m);
	BuildTree(Tree,i<<1|1,m+1,R);
	PushUp(Tree,i);
	return;
}
int Search1(node*Tree,int i){
	if (Tree[i].left==Tree[i].right) return Tree[i].left;
	if (Tree[i<<1].flag) return Search1(Tree,i<<1); else return Search1(Tree,i<<1|1);
}
int Search2(node*Tree,int i){
	if (Tree[i].left==Tree[i].right) return Tree[i].left;
	if (Tree[i<<1].v==Tree[i].v) return Search2(Tree,i<<1); else return Search2(Tree,i<<1|1);
}
int Query(node*Tree,int i,int index){
	if (Tree[i].left==Tree[i].right) return Tree[i].v;
	if (index<=Tree[i<<1].right) return Query(Tree,i<<1,index); else return Query(Tree,i<<1|1,index);
}
void Change1(node*Tree,int i,int index,int s){
	if (Tree[i].left==Tree[i].right) {
		Tree[i].flag=false;
		Tree[i].v=s;
		return;
	}
	if (index<=Tree[i<<1].right) Change1(Tree,i<<1,index,s); else Change1(Tree,i<<1|1,index,s);
	PushUp(Tree,i);
	return;
}
void Change2(node*Tree,int i,int index){
	if (Tree[i].left==Tree[i].right) {
		mems(Tree,i);
		return;
	}
	if (index<=Tree[i<<1].right) Change2(Tree,i<<1,index); else Change2(Tree,i<<1|1,index);
	PushUp(Tree,i);
	return;
}
void Build(node*Tree,int len,bool d){
	tag=d;
	BuildTree(Tree,1,1,len);
	return;
}
void PutIn(node*Tree,int x){
	int t=Search1(Tree,1);
	Change1(Tree,1,t,x);
	return;
}
int PutOut(node*Tree){
	int t=Search2(Tree,1),k=Query(Tree,1,t);
	Change2(Tree,1,t);
	return k;
}
int main() {
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	Build(tree,n,true);
	for (int i=1;i<=n;i++) PutIn(tree,a[i]);
	for (int i=1;i<n;i++){
		int t1,t2,k;
		t1=PutOut(tree);
		t2=PutOut(tree);
		k=t1+t2;
		PutIn(tree,k);
		ans+=k;
	}
	printf("%d\n",ans);
	return 0;
}
```

但因为线段树的时间复杂度有一个玄学的常数C，所以总共跑了136ms，可能不如那些直接用堆的。

---

## 作者：sbh2012 (赞：3)

## 思路
有一个很感性的贪心，因为越先用的点，后面计算它的次数越多，列如第一次就被合并的果子就会总共被算 $n - 1$ 次，于是我们可以让越大的点越先算，这样它们算的次数也越少，总和也越小。\
那如何证明呢，我们假设有两个果子大小分别是 $a$ 和 $b$，$a > b$ 但 $a$ 比 $b$ 先算，$a$ 已经算了 $i$ 次，但 $b$ 只算了 $j$，$i > j$，此时所需体力值为 $a \times i + b \times j$	假如 $b$ 先算，此时所需体力值为 $b \times i + a \times j$，化简后第二个式子小于第二个式子，于是我们可以知道：先把小的和并一定是最优的。用优先队列维护，每次选最小果子的两个合并即可。 
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> > a;
int main(){
	int n,x,k,j,s=0;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&x);
		a.push(x);
	}
	for(int i=0;i<n-1;i++){
		k=a.top();
		a.pop();
		j=a.top();
		a.pop();
		s+=k+j;
		a.push(k+j);
	}
	printf("%d\n",s);
	return 0;
}
```

---

## 作者：chrispang (赞：3)

### 思路

经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。

### 时间复杂度

使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。

每次操作会将果子的堆数减一，一共操作 $n - 1$ 次即可将所有果子合并成 $1$ 堆。每次操作涉及到 $2$ 次堆的删除操作和 $1$ 次堆的插入操作，计算量是 $O(\log n)$。因此总时间复杂度是 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, m, ans;
priority_queue<int, vector<int>, greater<int> > q;
int main() {
    cin >> m;
    for (int i = 1; i <= m; i++) {
        int t;
        cin >> t;
        q.push(t);
    }
    while (q.size() > 1) {
        int t1 = q.top(); q.pop();
        int t2 = q.top(); q.pop();
        ans += t1 + t2;
        q.push(t1 + t2);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Smallbasic (赞：3)

## 这题其实是$Huffman-tree$模板

先看这东西的是啥：

自我理解，$Huffman$树，又称最优二叉树，是指定$n$个节点为叶节点所组成的二叉树中的带权路径长度和最小的一棵树。

如果您没学过这个东西，肯定是一片懵逼（~~大佬请绕道~~），没关系，我们来一一解释一下。

首先：“定$n$个节点为叶节点所组成的二叉树”，这个部分很好理解，等同于这棵二叉树的叶节点是这$n$个点，如下图:

![](https://img-blog.csdn.net/20180805111237725?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NTE5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

指定$3$和$5$为叶节点，所得到的二叉树只有这一种方案。

然后看“带权路径长度和最小”，这句话比较难理解，先来看带权路径：

所谓带权路径长度，就是指某一个$\color{red}{\text{叶节点到根节点的路径长度}\times\text{它自身的点权}}$

比如这棵树：

![](https://pic002.cnblogs.com/images/2011/348136/2011112215092754.jpg)

$5$的带权路径长度就等于$5\times3=15$

而所谓带权路径长度和就是所有叶节点的带权路径长度之和。上面那棵树的带权路径长度和就等于$5\times3+43\times3=144$

我们要做的就是构建这样一颗二叉树，使它的带权路径长度和最小。

构建方法实际上是贪心的思想，权值越大的节点离根节点的距离越小。每次选出叶节点集合中点权最小且没被选过的两个节点，把它们的父亲都指向一个新节点，这个新节点的权值为被选的两个节点权值之和，如此循环，知道原集合中只剩一个根节点。

这么说有点~~无比~~抽象，上图理解一下：

设叶结点的编号为$A,B,C,D,E,F,G$，对应的权值分别为:$60,45,13,69,14,5,3$

先取出权职做小的5和3，他们的父节点连到新节点8，树变成了：

![](https://img-blog.csdn.net/20180805111237725?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NTE5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

~~好把图片是我从网上抄的~~

此时最小的变为了8与13，继续合并：

![](https://img-blog.csdn.net/20180805112102841?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NTE5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

最小的变为了24与14，合并，树变成：

![](https://img-blog.csdn.net/20180805113424722?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NTE5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

重复刚才的步骤，得到另一棵树:

![](https://img-blog.csdn.net/20180805113828778?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NTE5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

最后依然按之前的步骤合并那两棵树：

![](https://img-blog.csdn.net/20180805114408466?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NTE5MDQx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这就是最终答案了，很简单吧。

~~问正确性证明的我也不会自己百度吧~~

然后再看这道题，唯一的难点就是每堆果子会算多次。设$k_i$为第$i$堆搬运的次数，则题目变成了确定$k_i$，使得：

## $$\sum_{i=1}^n a_ik_i$$

最小化。

很容易发现它和$Huffman$树有点像，每堆果子就相当于给定的叶节点。

它的合并方式也和$Huffman$树的建树方式十分相似，创建新的一堆果子，大小是原来那两堆的大小之和。我们同样把原来那两对的父节点指向新堆，之后每次搬运新堆是原来两堆的$k_i$都会加$1$，也就等同于合并后到根节点的距离加了$1$。

并且这道题要体力耗费值最小，显然满足贪心。所以我们直接构造出一棵$Huffman$树，再求出他的带权路径长度和就好了。

需要注意的是每次找最小的两个点暴力$for$一遍复杂度为$\Theta(n^2)$，可以考虑用一个小根堆来维护，复杂度$\Theta(n\log_2n)$

代码：

```cpp
#include <bits/stdc++.h> 

using namespace std;

struct node {
	int l, r, v, f, st;
	node() {
		l = r = v = f = -1;
	}
	inline bool operator > (const node& b) const {
		return v > b.v;
	}
}nd[5000005];

int top(0);
priority_queue<node, vector<node>, greater<node> >q;

inline bool merge() {
	if (q.size() <= 1) return false;
	node a = q.top(); q.pop(); node b = q.top(); q.pop();
	nd[++top].v = a.v + b.v; nd[top].st = top;
	nd[top].l = a.st; nd[top].r = b.st;
	nd[a.st].f = nd[b.st].f = top;
	q.push(nd[top]);
	return q.size() - 1;
}

inline int get(int now, int dep) {
	return (nd[now].l == -1 && nd[now].r == -1) ? nd[now].v * dep : get(nd[now].l, dep + 1) + get(nd[now].r, dep + 1); 
}

int main() {
	int n;
	cin >> n;
	top = n;
	for (int i = 1; i <= n; i++) {
		cin >> nd[i].v;
		nd[i].st = i;
		q.push(nd[i]);
	}
	while (merge());
	cout << get(q.top().st, 0);
	return 0;
}
```


---

## 作者：sigland (赞：3)

本题贪心策略就是每次选最小的两个合并,可以用很多方法,比较好的是哈夫曼数或者堆(优先队列),stl库的优先队列太慢了80ms过,于是自己手打了一个封装在结构体里40ms,拿出来用20ms,注释写代码里了...(蒟蒻勿喷)

封装版(模板调用方便40ms附注释)

```cpp
#include<bits/stdc++.h>
using namespace std;
struct my_priority {
    vector<int>heap;
    void init() {
        heap.push_back(-1e9);//插入数组下标为0的数便于之后各节点访问父亲以及孩子
    }
    void gao(int pos) {      //从根节点往下更新确保满足堆的性质
        int flag;
        if(pos*2>heap.size()-1)return;
        else if(pos*2==heap.size()-1)flag=0;
        else flag=heap[pos*2]>heap[pos*2+1];
        if(heap[pos]>heap[pos*2+flag]) {
            swap(heap[pos],heap[pos*2+flag]);
            gao(pos*2+flag);
        }
        return;
    }
    void doit(int i) {      //从当前节点往根节点更新确保满足堆的性质
        while(heap[i]<heap[i/2]) {
            swap(heap[i],heap[i/2]);
            i>>=1;
        }
        return;
    }
    void push(int w) {     //插入
        heap.push_back(w);
        doit(heap.size()-1);
    }
    int top() {           //返回堆顶
        return heap[1];
    }
    void pop() {          //删除堆顶元素
        heap[1]=heap[heap.size()-1];
        heap.pop_back();
        gao(1);
    }
    int size() {
        return heap.size()-1;   //返回堆元素个数
    }
} q;
int main() {
    int i,ans=0;
    int n,tmp;
    q.init();
    scanf("%d",&n);
    for(i=1; i<=n; i++) {
        scanf("%d",&tmp);
        q.push(tmp);
    }
    while(q.size()>1) {
        tmp=q.top();
        q.pop();
        tmp+=q.top();
        q.pop();
        ans+=tmp;
        q.push(tmp);
    }
    printf("%d\n",ans);
    return 0;
}
```
拆封版(跑得快20ms)
```cpp
#include<bits/stdc++.h>
using namespace std;
int heap[100010],cnt;
void gao(int pos)
{
    int flag=heap[pos*2]>=heap[pos*2+1];
    if(heap[pos]>heap[pos*2+flag]){
        swap(heap[pos],heap[pos*2+flag]);
        gao(pos*2+flag);
    }
    return;
}
void doit(int i)
{   while(heap[i]<heap[i/2])
    {
        swap(heap[i],heap[i/2]);
        i/=2;
    }
    return;
}
void push(int w)
{
    heap[++cnt]=w;
    doit(cnt);
}
int top()
{return heap[1];}
void pop()
{
    heap[1]=heap[cnt];heap[cnt]=1e9;
    --cnt;gao(1);
}
int main()
{
    int i,ans=0;
    {   memset(heap,127,sizeof heap);heap[0]=-1e9;
        int n,tmp;ans=0;cnt=0;
        scanf("%d",&n);
        for(i=1;i<=n;i++)
        {
            scanf("%d",&tmp);
            push(tmp);
        }
        while(cnt>1)
        {
            tmp=top();pop();tmp+=top();pop();
            ans+=tmp;push(tmp);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：aaalys (赞：1)

# P1090 NOIP 2004 提高组 合并果子 题解

## 题目大意

[题目传送门](https://www.luogu.com.cn/problem/P1090)现在有 $n$ 堆果子，每堆果子的重量为 $a_i$，你要进行 $n - 1$ 次合并。每次合并会把两堆果子合并成一堆果子，合并需要花费的体力为这两堆果子的重量之和，合并后果子的重量也为这两堆果子的重量之和。现在让你求出 $n - 1$ 次合并花费的最小总体力。

## 思路

### 贪心思路

首先，很容易想到一个贪心：每次取重量最小的两堆果子，再取合并后重量最小的两堆果子，直到只有一堆果子为止。

### 证明过程

现在就要证明这个贪心，这里不妨先证明小范围贪心正确，再证明推导到大范围正确，就可以证明这个贪心正确。

#### step 1: 证明小范围贪心正确

假设现在只有 3 堆果子，果子的数量分别为 $a,b,c$，假设 $a \le b \le c$（$a,b,c$ 的顺序与答案无关），现在开始需要先取 $a, b$ 一定是最优的。

第一种情况：先取 $a, b$，最终答案为 $(a + b) + (a + b + c) = 2a + 2b + c$。

第二种情况：先取 $a, c$，最终答案为 $(a + c) + (a + b + c) = 2a + b + 2c$。

第二种情况：先取 $b, c$，最终答案为 $(b + c) + (a + b + c) = a + 2b + 2c$。

现在需要比较 $2a + 2b + c,2a+b + 2c,a+2b+2c$ 的大小关系。

因为三个式子都含有 $a + b + c$，所以可以消掉 把三个式子同时减去 $a + b + c$。

现在问题就变成了比较 $a + b,a + c,b+c$ 的大小关系。

因为 $a\le b \le c$，所以 $a + b \le a + c \le b + c$。

所以第一种情况（先取 $a, b$）一定是最优的。

再举个例子说明，比如 $a = 3, b = 5, c = 9$。

第一种情况（先取 $a,b$）的答案是 $2a + 2b + c = 25$。

第二种情况（先取 $a,c$）的答案是 $2a + b + 2c = 29$。

第三种情况（先取 $b,c$）的答案是 $a + 2b + 2c = 31$。

通过比较也可以发现第一种情况（先取 $a, b$）是最优的。

#### step 2: 证明推导到大范围也正确

假设有 $n(n > 3)$ 堆果子，合并完 $n - 3$ 次之后，还剩 3 堆果子，可以用类似的方法证明取重量最小的两堆果子是最优的。

因此，取重量最小的两堆果子一定是最优的。

## 代码实现

### 选择 `priority_queue` 及使用方法

现在需要一种数据结构，能动态找到数据结构中最小值和次小值，并删除他们，再插入他们的和。

我这里采用的是 stl 库中的 `priority_queue`（优先队列，也被称为堆），可以在 $O( \log n)$ 的时间复杂度内插入、查询优先队列中最大 / 最小值、删除优先队列中最大 / 最小值。

`priority_queue` 的使用方法如下。

```cpp
//定义方法
#include <queue>//需要的头文件
priority_queue<int>q1;//定义一个大根堆，查询和插入的是最大值
priority_queue<int, vector<int>, greater<int>>q1;//定义一个小根堆，查询和插入的是最小值

//使用方法
q1.push(7);//往大根堆内插入一个值7
q1.push(4);//插入4
q1.push(12);//插入12
q1.top();//查询大根堆内的最大值，此时返回值为12
q1.pop();//删除大根堆内的最大值（删除12），没有返回值
q1.size();//查询优先队列数的个数，此时返回值为2
q1.top();//此时的最大值变成了7，所以返回7

//小根堆的使用方法与大根堆的使用方法一样
q2.push(9);//插入一个数9
q2.top();//查询小根堆内最小值，返回9
q2.push(1);//插入1
q2.pop();//删除小根堆内最小值（删除1），同样没有返回值
q2.push(3);//插入3
q1.size();//查询优先队列数的个数，此时返回值为2
q2.top();//此时小根堆内的值为3和9，返回3
```

### 算法流程

输入输出我就不在这里说了，请读者自行思考。
1\. 定义优先队列（小根堆）。
2\. 将每堆果子的重量放进优先队列。
3\. 取出小根堆中最小值和次小值，统计答案，放入他们的和。
4\. 重复步骤三，直到只有一堆果子。

### Code（只展示关键代码）

```cpp
priority_queue<int, vector<int>, greater<int>>q;//1.定义小根堆
//2.将每堆果子的重量放进优先队列
//我在这里不放了，请读者自行思考
long long sum = 0;
while (q.size() > 1){//4.重复步骤三，直到只有一堆果子。
    int a1 = q.top();
    q.pop();
    int a2 = q.top();
    q.pop();
    //取出a1和a2，即最小值和次小值
    sum += a1 + a2;//统计答案
    q.push(a1 + a2);//放入他们的和
}
```

---

## 作者：4041nofoundGeoge (赞：1)

## 思路

如何得到最优解？首先我们假设 $n$ 个正整数 $a_1,a_2,a_3,a_4,\dots,a_n$，将 $n$ 个数排列，设排列为 $a_{k_0},a_{k_1},\dots,a_{k_n}$，且 $k_0\sim k_n$ 为 $1\sim n$ 的排列，按要求组合，得到 
$$S=(a_{k_0}+a_{k_1})+(a_{k_0}+a_{k_1}+a_{k_2})+\dots+(a_{k_0}+a_{k_1}+\dots+a_{k_n})\\
=na_{k_0}+na_{k_1}+(n-1)a_{k_2}+(n-1)a_{k_3}+\dots+a_{k_{n-1}}+a_{k_{n}}
$$

不难发现如果需要得到 $\min(S)$，使 $a_{k_0},a_{k_1},\dots,a_{k_n}$ 为 $a_1,a_2,a_3,\dots,a_n$ 的从小到大排序即可。

如何实现既可以排序又可以随便取元素的容器？

就要用到优先队列 $\text{priority queue}$ 了。

$\text{priority queue}$ 是一种既排序又有队列的一种 STL 容器，使用方法：

- `top()` 访问堆顶元素（此时优先队列不能为空）。
- `empty()` 询问容器是否为空。
- `size()` 查询容器中的元素数量。
- `push(x)` 插入元素，并对底层容器排序。
- `pop()` 删除堆顶元素（此时优先队列不能为空）。

其中前三个为 $O(1)$ 时间复杂度，其余为 $O(\log n)$ 的时间复杂度。

$\text{priority queue}$ 是从大往小排序所以请用 `priority_queue<int,vector<int>,greater<int>>p_q;` 设置成从小往大排序。

接下来就可以写代码了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int>>p_q; 
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int num;
		cin>>num;
		p_q.push(num);
	}
	int sum=0;
	while(p_q.size()>=2){
		int a=p_q.top();p_q.pop();
		int b=p_q.top();p_q.pop();
		sum+=a+b;
		p_q.push(a+b); 
	}
	cout<<sum<<endl;
	return 0;
}

```

---

## 作者：Zskioaert1106 (赞：0)

题目传送门：[P1090 [NOIP 2004 提高组] 合并果子](https://www.luogu.com.cn/problem/P1090)

## 前置知识

### 堆

堆是一种完全二叉树，满足每个结点都大于它的子节点（如果它有的话）。这种性质使得根节点永远是数列中的最大值。（其它别的性质也可以维护）

堆中最小的结点永远在叶子结点层，但是这个性质没什么用。

堆可以用来维护一个数列，假设数列有 $n$ 个元素，那么堆的深度就是约 $\log_2n$。每次插入元素时放到叶子结点，然后一层层跟父节点作比较，如果自己到根了或者比父节点小了（不比父节点大了）就停止下放，否则跟父节点易位并继续递归。

弹出堆顶时可以先将堆顶（用存二叉树的线性数组来存就是 $q_1$）与 $q_{len}$ 交换，然后让新的 $q_1$ 一直跟子节点中较小的比较，然后下放。

二叉堆有一种应用叫优先队列，是 STL 中的 `priority_queue`。

### 哈夫曼树

哈夫曼树是一种用来求最优二叉树（带权路径长度最小）的贪心算法。假设初始这 $n$ 个节点分别是 $n$ 个独立子树的根节点（没有叶子），每次选择出根节点最小的两个子树合并，将它们的根节点设为两个子树的根节点之和，直到集合中只剩 
$1$ 颗树为止。

## 做题过程

本题其实就是一个求最优二叉树的过程（$n-1$ 次操作后总权值最小），所以每次合并最小的两堆一定是最优的。

所以我们就要实现一个小顶堆，可以用 `priority_queue<int,vector<int>,greater<int> >` 这段代码，也可以将存进去的数都转成负数。之后一直合并最顶上的两堆，放进去两堆的和，直到只剩下一堆为止。

## 最终代码

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> >q;
int n,ans,s;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	while(n--){
		int i;
		cin>>i;
		q.push(i);
	}
	while(q.size()>1){
		s=q.top();
		q.pop();
		s+=q.top();
		q.pop();
		q.push(s);
		ans+=s;
	}
	cout<<ans;
	return 0;
}
```

堆操作的复杂度是 $\log n$，将 $n$ 堆变成 $1$ 堆，每次少 $1$ 堆，复杂度是 $O(n \log n)$。

[AC 记录](https://www.luogu.com.cn/record/202516385)。

---

## 作者：lkjlkjlkj2012 (赞：0)

### 直观感觉
蒟蒻第一眼看到样例有一个直观感受：就是应该把小的先合并。现在就让蒟蒻证明一下。
### 证明
考虑三堆果子 $a, b, c$ ， $a$ 的重量为 $a.w$ ， $b$ 的重量为 $b.w$ ， $c$ 的重量为 $c.w$ 。设 $a.w<b.w<c.w$ 。  
|合并方式|体力耗费|
|:-:|:-:|
|$a, b$ 先合并|$2a.w+2b.w+c.w$|
|$a, c$ 先合并|$2a.w+b.w+2c.w$|
|$b, c$ 先合并|$a.w+2b.w+2c.w$|

显然先合并 $a, b$ 最优。同理，合并多堆果子时，每次合并最轻的两堆最优。
### 代码

```cpp
#include <bits/stdc++.h>
#include <queue> 
using namespace std;
int n,a[10005];
priority_queue<int,vector<int>,greater<int>> q;
int ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        q.push(a[i]);
    }
    while(q.size()>1)
    {
        int a=q.top();
        q.pop();
        int b=q.top();
        q.pop();
        ans+=a+b;
        q.push(a+b);
    }
    cout<<ans;
    return 0;
}
```

---


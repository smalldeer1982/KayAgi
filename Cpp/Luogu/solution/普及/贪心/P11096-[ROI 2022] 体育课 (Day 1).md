# [ROI 2022] 体育课 (Day 1)

## 题目背景

翻译自 [ROI 2022 D1T1](https://neerc.ifmo.ru/school/archive/2021-2022/ru-olymp-roi-2022-day1.pdf)。

在体育课前，一个由 $n$ 名学生组成的班级排成了一列。班级中的所有学生身高不同。在队列的第 $i(1\le i\le n)$ 个位置上站着一个身高为 $p_i(1\le p_i\le n)$ 的学生。

体育老师在课堂开始时可能想要改变学生在队列中的顺序。为此，他可以执行以下操作一次：选择从第 $l$ 到第 $r$ 位置（$1 \le l \le r \le n$）的一段队列，并将这段队列中的学生按照从左到右的升序进行排序。例如，如果 $n = 5$，并且最初学生们的顺序是 $[5, 2, 4, 1, 3]$，而老师选择 $l = 1,r = 4$，则在排序后学生们的顺序将变为 $[1, 2, 4, 5, 3]$。

## 题目描述

老师想要使得两个特定的学生尽可能远离彼此。学生之间的距离等于他们所站位置的编号之差。对于每对学生，老师想要知道在执行一次排序操作后他们可以达到的最大距离。请帮助老师算出这些值的总和。

如果用 $d(i, j)$ 表示老师通过选择一段队列并进行排序可以达到的刚开始在位置 $i$ 和 $j$ 上的学生之间的最大距离，需要计算的就是 $\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}d(i,j)$。

## 说明/提示

在样例一中，答案是以下数字之和：

![](https://cdn.luogu.com.cn/upload/image_hosting/il74fp66.png)

例如，为了使最初位于位置 $4$ 和 $5$ 上且身高分别为 $1$ 和 $3$ 的学生之间的距离为 $4$，老师可以选择 $l = 1,r = 4$，然后，学生序列将从 $[\underline{5, 2, 4, 1}, 3]$ 变为 $[\underline{1, 2, 4, 5}, 3]$。被选择的段已经用下划线标注出来。

| Subtask | 分值 | $n\le$ |
| :----------: | :----------: | :----------: |
| $1$ | $16$ | $10$ |
| $2$ | $28$ | $50$ |
| $3$ | $15$ | $100$ |
| $4$ | $23$ | $600$ |
| $5$ | $18$ | $3000$ |

## 样例 #1

### 输入

```
5
5 2 4 1 3```

### 输出

```
35```

## 样例 #2

### 输入

```
10
2 1 6 8 3 5 9 10 7 4```

### 输出

```
256```

## 样例 #3

### 输入

```
2
2 1```

### 输出

```
1```

# 题解

## 作者：Duanhen (赞：6)

### 题目大意
对于每一对 $i$ 和 $j$，用 $d(i, j)$ 表示选择从第 $l$ 到第 $r$ 位置 $(1 \le l \le r \le n)$ 的一段队列并进行排序可以使刚开始在位置 $i$ 和 $j$ 上的学生之间的距离最大，而我们需要计算 $\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}d(i,j)$。

### 解题思路
对于某一对 $i$ 和 $j$，第一种排序情况便是将所有元素都选中，此时两者的距离变为 $|p_i-p_j|$，但是这并不一定的最优情况。

而我们可以通过**贪心**的思想来找到最优解。

对与 $i$ 来说，想要离 $j$ 更远，就必须将它前面比它大的元素都选中，使这些元素排在它后面，而元素的个数就是增加的距离。而对于 $j$ 来说，情况则相反，需要找出它后面比它小的元素，让这些元素排在它前面，元素的个数就是增加的距离。

所以我们可以先预处理出对于每一个元素，它前面比它大的元素个数和后面比它小的元素个数。在求解时，我们可以比较 $i$ 前面的大元素个数和 $j$ 后面的小元素个数，哪个大我们就选哪个，然后再跟全选的结果 $|p_i-p_j|$ 作比较，就可以得出最优解。

### 参考代码
``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll p[3010], a[3010], b[3010], n, res;

int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> p[i];
  for (int i = 1; i <= n; i++)
    for (int j = 1; j < i; j++) {
      if (p[j] > p[i]) a[i]++;
      if (p[j] > p[i]) b[j]++;
    }
  for (int i = 1; i <= n; i++)
    for (int j = i + 1; j <= n; j++) {
      ll tp = max(a[i], b[j]) + (j - i);
      tp = max(tp, abs(p[i] - p[j]));
      res += tp;
    }
  cout << res;
  return 0;
}
```

---

## 作者：_____1__2___ (赞：2)

## P11096 题解
### 题意
通过排序使得两个学生距离最远，并计算所有学生两两距离最远的和。
### 思路
设两位学生分别为 $$a_i$$ 和 $$a_j$$ 且 $$i<j$$。
可以有以下三种方法来排序：
1.  全部排序，那么他们的距离为 $$a_j - a_i$$。
2.  将区间 $$\begin{bmatrix} 1,i \end{bmatrix}$$ 进行排序，也就是将 $$\begin{bmatrix} 1,i \end{bmatrix}$$ 中所有大于 $$a_i$$ 的放在 $$i$$ 以后。
3.  将区间 $$\begin{bmatrix}j,n\end{bmatrix}$$ 进行排序，也就是将 $$\begin{bmatrix}j,n\end{bmatrix}$$ 中所有小于 $$a_j$$ 的放在 $$j$$ 以前。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int arr[3010],les[3010],grt[3010];
int main() {
    int n;
    cin >> n;
    for (int i=1;i<=n;++i) cin >> arr[i];
    for (int i=1;i<=n;++i) {
        // 查找前面大于他的数
        for (int j=1;j<i;++j) {
            if (arr[j]>arr[i]) grt[i]++;
        }
        // 查找后面小于他的数
        for (int j=i+1;j<=n;++j) {
            if (arr[j]<arr[i]) les[i]++;
        }
    }
    long long cnt=0; // 十年OI一场空
    for (int i=1;i<n;++i) {
        for (int j=i+1;j<=n;++j) {
            // 求出最大值
            cnt+=max(abs(arr[i]-arr[j]),abs(j-i)+max(les[j],grt[i]));
        }
    }
    printf("%lld", cnt);
    return 0;
}
```
希望这篇题解可以过审。

---

## 作者：cyx0411 (赞：1)

## **思路**

对于每一组 $l$ 和 $r$，要是他们的距离最远，很明显有一种方法，把第 $l$ 项到第 $r$ 进行一遍操作，即 $d(l,r)$ 答案显而易见，是 $|p_{i}-p_{j}|$，但这显然有可能不是最优解，所以我们会想到另一种解。

通过思考，我们发现可以把 $l$ 的左边比 $l$ 大的数通过 $d$ 函数放到 $l$ 的右边。同理，我们也可以用同样的方法把 $r$ 的右边比 $r$ 小的数通过 $d$ 函数放到 $r$ 的左边，反正就是要尽可能地让 $l$ 和 $r$ 之间的距离变大。

通过以上两种方案，我们就可以将最优解~~完美地~~找到了。

## **放代码**：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,p[3005],l[3005],r[3005],cnt=0;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>p[i];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<i;j++){
            if(p[j]>p[i]){
                l[i]++;
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            if(p[j]<p[i]){
                r[i]++;
            }
        }
    }                               //为之后做准备
    for(int i=1;i<n;i++){
        for(int j=i+1;j<=n;j++){
            cnt+=max(max(l[i],r[j])+j-i,abs(p[i]-p[j]));
        }
    }
    cout<<cnt;
	return 0;
}
```

---

## 作者：sbh2012 (赞：1)

## 前言
感觉此题不难，大概上位橙、下位黄
## 思路
-   首先我们要明确 $a_1$ 到 $a_i$ 排序肯定比 $a_1$ 到 $a_{j-1}$ 排序更优，因为假如 $a_i$ 后面有比 $a_i$ 小的数那么它就会把 $a_i$ 挤到后面去，这会让 $d(i,j)$ 减小。
-   其次我们要明确 $a_j$ 到 $a_n$ 排序肯定比 $a_{i+1}$ 到 $a_n$ 排序更优，因为假如 $a_j$ 前面有比 $a_j$ 大的数，那么它就会把 $a_j$ 挤到前面去，这会让 $d(i,j)$ 减小。
-   最后还有一种排序方案 $a_1$ 到 $a_n$ 排序。
-   于是只要维护每个数前面比它大的数，后面比它小的数，离散化一下数字，最后三种排序取个最大值，这题就做完了。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct my{
	int s;
	int id;
	int q=0;
	int h=0;
}a[100005];
bool cmp(my x,my y){
	return x.s<y.s;
}
bool guiwei(my x,my y){
	return x.id<y.id;
}
int main(){
	long long n,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].s;
		a[i].id=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		a[i].s=i;//离散化一下数字
	}
	sort(a+1,a+n+1,guiwei);
//	for(int i=1;i<=n;i++){
//		cout<<a[i].s<<' ';
//	}
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			if(a[j].s<a[i].s){
				a[j].q++;//每个数前面比它大的数
			}
		}
	}
	for(int i=n;i>1;i--){
		for(int j=i-1;j>=1;j--){
			if(a[j].s>a[i].s){
				a[j].h++;//后面比它小的数
			}
		}
	}
//	for(int i=1;i<=n;i++){
//		cout<<a[i].h<<' ';
//	}
//	cout<<endl;
//	for(int i=1;i<=n;i++){
//		cout<<a[i].q<<' ';
//	}
//	cout<<endl;
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			ans+=max(max(abs(a[i].s-a[j].s),a[i].q+j-i),a[j].h+j-i);//三种排序取个最大值
			//cout<<max(max(abs(a[i].s-a[j].s),a[i].q+j-i),a[j].h+j-i)<<endl; 
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Jaykis (赞：1)

[传送门](https://www.luogu.com.cn/problem/P11096)
## 思路
- 首先我们可以发现当对整个序列进行排序时， $i$ 和  $j$ 的距离即为 $|a_i-a_j|$
- 其次思考是否存在更优的可能。 对于满足 $i<k<j $ 的 位置 $k$  必然会为 $d(i,j)$ 做出贡献。所有我们只需要对 $[1,i]$ 或者 $ [j,n]$ 的区间进行排序即可。
-   若对 $[1,i]$ 排序，排序后的位置即为区间内小于 $a_i$ 的数的个数加一。同理，若对 $[j,n]$ 排序，排序后的位置为区间内小于 $a_i$ 的数的个数加一。得到位置后便可以计算排序后对 $d(i,j)$ 所增加的贡献。再从两种方案中选取最优方案与$|a_i-a_j|$比较即可
-   当然我们可以通过枚举来得到 $i$ 处对于左侧和右侧排序后的位置。~~但是那样就太无聊了~~，我们突发奇想发现好像可以用树状数组解决，于是通过树状数组扫一遍分别求出左右侧比他小的数的个数即可。
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3030;
int c1[N],c2[N];
int n,ls[N],rs[N],a[N];

int lowbit(int i){
	return i&-i;
}

void update(int x,int c[]){
	for(;x<=n;x+=lowbit(x))//向上更新
		c[x]+=1;
}

int get_sum(int x,int c[]){
	int ans=0;
	for(;x;x-=lowbit(x))//向下求和
		ans+=c[x];
	return ans;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]); 
		a[i]++;//防止出现查询0的情况 
	}
	for(int i=1;i<=n;i++){
		ls[i]=i-get_sum(a[i]-1,c1)-1;//对i左侧排序后的所增加的贡献 
		update(a[i],c1);
	}
	for(int i=n;i>=1;i--){
		rs[i]=get_sum(a[i]-1,c2);//对i右侧排序后的所增加的贡献 
		update(a[i],c2);
	}
	ll ans=0;//十年OI一场空
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			ans+=1LL*max(max(ls[i],rs[j])+j-i,abs(a[i]-a[j])); 
		}
	}
	printf("%lld",ans);
	return 0;
}
```

完结，撒花

---

## 作者：xiaozhu_zty (赞：1)

# P11096 题解
## 题目大意
给定一个序列 $ A_i $，求 $\sum_{i=1}^{n-1}\sum_{j=i+1}^{n} d(i,j)$，其中 $d(i,j)$ 指通过选择 $1$ 到 $n$ 中的一段连续区间重新排序后 $i$、$j$ 之间距离的最大值。
## 分析
- 不难发现选中全部序列重排可以直接让距离为 $ \left| A_i - A_j \right| $。
- 考虑到排序的区间是连续的，所以选择区间时我们可以考虑让较小的端点向左移动或者让较大的端点向右移动。不妨以 $ i$ 为例，选择区间 $[1,i] $ 排序，这样可以让将 $i $ 向左移动最多。对于较大端点的情况向右选择区间 $[j,n]$ 即可让 $j$ 向右移动最多。选择两种情况中的一种进行操作，这样可以让 $i$、$j$ 相互达到最远距离。
- 最后对于每个区间取全部重排和部分重排中的最大值求和就好。注意求和时 $ i $、$j$ 的取值为 $1\le i \le n-1$，$i+1\le j \le n$。
## 代码
```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n;
int lef[3005],rig[3005];
int a[3005];
signed main(){
	cin>>n;
	for (int i = 1;i<=n;i++){
		cin>>a[i];
	}
	for (int i = 1;i<=n;i++){
		for (int j = i-1;j>=1;j--){
			if (a[i]<a[j]) lef[i]++;
		}
		for (int j = i+1;j<=n;j++){
			if (a[i]>a[j]) rig[i]++;
		}
	}
	int ans=0;
	for (int i = 1;i<n;i++){
		for (int j = i+1;j<=n;j++){
			int tmp=0;
			tmp=max(abs(a[j]-a[i]),abs(j-i)+max(lef[i],rig[j]));
			ans+=tmp;
		}
	}
	cout<<ans<<endl;
}
```

---

## 作者：XYJ12321 (赞：0)

## 题目大意
$P$ 是 $1\sim n$ 的一个排列。对于 $\forall i<j\in[1,n]$。选择连续的一段，进行排序。最小化 $i$ 与 $j$ 在 $P$ 中的位置距离差。答案要求输出所有距离差的和。
## 解题思路
考虑只对一对 $i,j$ 进行求值。进行贪心的考虑，一次排序对答案的影响有把 $i$ 前面比 $P_i$ 大的数转到 $i$ 的后面，把 $j$ 后面的比 $P_j$ 小的数转到 $j$ 的前面。又考虑到我们要尽可能让 $i$ 先前靠，让 $j$ 向后靠。基于此，选段的最优可能只有从 $1\sim n$，从 $1\sim i$ 或 $j\sim n$ 这三种。

所以我们可以暴力预处理出每个数前面比它大的数个数，与它后面比它小的数个数。求值时，比较一下 $i$ 前面比 $P_i$ 小的数个数与 $j$ 后面比 $P_j$ 大的数个数，取较大值。最后别忘了再与全选的结果 $|P_i-P_j|$ 作比较。

对于每一对 $i<j$，我们都这样求解，把最后的答案累加起来就是答案。
## 复杂度分析
空间复杂度 $O(n)$。

时间复杂度 $O(n^2)$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int p[3010],q[3010],h[3010],n,ans;
signed main(){
	cin.tie(0);cout.tie(0);ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>p[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			if(p[j]>p[i]) q[i]++,h[j]++;
		}
	}
	for(int i=1;i<n;i++)
	 for(int j=i+1;j<=n;j++){
	 	int res=max(q[i],h[j])+j-i;
	 	res=max(res,abs(p[i]-p[j]));
	 	ans+=res;
	 }
	cout<<ans;
	return 0;
}
```

---

## 作者：mahaorui2012 (赞：0)

# 思路 

$n \le 3000$，所以只要枚举 $i$ 和 $j$，再 $\operatorname{O}(1)$ 计算 $\operatorname{d}(i,j)$ 即可。 

不妨设 $i < j$。
 
选择进行排序的序列只有四种：
 
### 包含 $p_i$ 且包含 $p_j$

此时，若已经选择了一个区间，则不妨再多选择一个人。此时又有两种情况： 

#### 新选的数小于 $p_i$ 或大于 $p_j$
则 $i$ 与 $j$ 距离不变。 

#### 新选的数大于 $p_i$ 且小于 $p_j$
则 $i$ 与 $j$ 的距离增加。

所以，在这种情况下，多选一个数**有可能增加**答案且**不可能减少**答案，所以最优策略是对 $[1,n]$ 进行排序。

可以提前记录每个元素在整体排序后对应的排序后数组中的位置，$\operatorname{O}(n^2)$ 预处理，$\operatorname{O}(1)$ 查询。

可以用 $\operatorname{O}(n\log n)$ 的二分查找，但是 $\operatorname{O}(n^2)$ 已经足够通过此题了。 

### 包含 $p_i$ 且不包含 $p_j$

此时，若多选择一个数，则又有两种情况：

#### 新选的数的下标**大于** $j$
则 $i$ 与 $j$ 距离不变（新选的数大于 $p_j$）或增加 $1$（新选的数小于 $p_j$）。

#### 新选的数的下标**小于** $j$
则 $i$ 与 $j$ 距离减少（新选的数小于 $p_j$）或不变（新选的数大于 $p_j$）。

所以，在这种情况下，多选一个数下标大于 $j$ 的数**有可能增加**答案且**不可能减少**答案，但多选一个数下标小于 $j$ 的数**有可能减少**答案且**不可能增加**答案，所以最优策略是对 $[j,n]$ 进行排序。

可以预处理出所有元素 $p_i$ 在将 $[i,n]$ 排序后的对应位置。

预处理 $\operatorname{O}(n^2\log n)$，查询 $\operatorname{O}(1)$。

有类似[P7910](https://www。luogu.com.cn/problem/P7910)的 $\operatorname{O}(n^2)$ 写法，但这个写法已经足够通过此题了。 

### 不包含 $p_i$ 且包含 $p_j$

跟上一种情况类似的思路类似，最优策略是对 $[1,i]$ 进行排序。

类似地，预处理 $\operatorname{O}(n^2\log n)$，查询 $\operatorname{O}(1)$。 

### 不包含 $p_i$ 且不包含 $p_j$

此时 $i$ 与 $j$ 的距离一定是 $j-i$，但其他三种情况都保证它们的距离至少是 $j-i$，所以这种情况无效。 

# AC CODE
 
```C++
inline const int& min3(const int& a,const int& b,const int& c){
	if(a>b && a>c){
		return a;
	}if(b>c){
		return b;
	}return c;
}

#include <iostream>
#include <algorithm>
using namespace std;

int arr[3005];
int s_arr[3005];
int rev_mp[3005];
int front_rev_mp[3005]; 
int back_rev_mp[3005];

int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>arr[i];
		s_arr[i]=arr[i];
	}
	
	sort(s_arr+1,s_arr+n+1);			//预处理情况1
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			if(s_arr[j]==arr[i]){
				rev_mp[i]=j;
			}
		}
	}
	for(int i=n;i>=1;--i){				//预处理情况2
		for(int j=i;j<=n;++j){
			s_arr[j]=arr[j];
		}sort(s_arr+i,s_arr+n+1);
		for(int j=i;j<=n;++j){
			if(s_arr[j]==arr[i]){
				back_rev_mp[i]=j;
				break;
			}
		}
	}
  for(int i=1;i<=n;++i){				//预处理情况3
		for(int j=1;j<=i;++j){
			s_arr[j]=arr[j];
		}sort(s_arr+1,s_arr+i+1);
		for(int j=1;j<=i;++j){
			if(s_arr[j]==arr[i]){
				front_rev_mp[i]=j;
				break;
			}
		}
	}
	
	long long tot=0;
	for(int i=1;i<=n;++i){
		for(int j=i+1;j<=n;++j){
			tot+=min3(abs(rev_mp[i]-rev_mp[j]),			//情况1
						abs(back_rev_mp[j]-i),			//情况2
						abs(front_rev_mp[i]-j));		//情况3
		}
	}
	
	cout<<tot;
	return 0;
}

````

---


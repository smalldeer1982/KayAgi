# 【MX-J8-T2】黑洞

## 题目背景

原题链接：<https://oier.team/problems/J8B>。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/a8hxrkor.png)

上图给出了二维下与红点在同一条对角线上的所有方格。

考虑三维下的情况，下图给出了与红色方块在同一条对角线上的所有方块。

![](https://cdn.luogu.com.cn/upload/image_hosting/56pkuoah.png)

本题我们将会把对角线这个概念推广到 $n$ 维上。

## 题目描述

已知一片 $n$ 维空间，第 $i$ 维的大小为 $m_i$。我们使用一个 $n$ 维坐标 $(x_1, x_2, \dots, x_n)$ 表示这片 $n$ 维空间里的一个位置，其中 $x_i$ 为 $[1, m_i]$ 间的整数。

在位置 $(a_1, a_2, \dots, a_n)$ 处有一颗黑洞。这片 $n$ 维空间中所有与它在同一条对角线上的位置都将被吞噬：
- 称位置 $(a_1, a_2, \dots, a_n)$ 与 $(b_1, b_2, \dots, b_n)$ 在同一条对角线上，当且仅当存在一个整数 $k \geq 0$，使得对每个 $1 \leq i \leq n$，都有 $\lvert a_i - b_i \rvert = k$。

你需要求出共有多少个位置会被黑洞吞噬（即与黑洞在同一条对角线上，包括黑洞所处位置本身）。答案对 $10^9 + 7$ 取模。

## 说明/提示

**【样例解释 \#1】**

如题目背景中的图所示，其中红色圆形为黑洞所在位置，黑色方格为被黑洞吞噬的位置，共 $8$ 个。

**【样例解释 \#2】**

有 $1999999997$ 个位置被黑洞吞噬，$1999999997$ 对 $10^9+7$ 取模的结果为 $999999990$。

**【样例解释 \#3】**

如题目背景中的图所示，$(1,2,5)$，$(2,3,4)$，$(2,7,4)$，$(3,4,1)$，$(3,4,3)$，$(3,6,1)$，$(3,6,3)$，$(4,5,2)$，$(5,4,1)$，$(5,4,3)$，$(5,6,1)$，$(5,6,3)$ 共 $12$ 个位置被黑洞吞噬。

**【样例 \#4】**

见附件中的 `hole/hole4.in` 与 `hole/hole4.ans`。

该组样例满足测试点 $9 \sim 10$ 的约束条件。

**【样例 \#5】**

见附件中的 `hole/hole5.in` 与 `hole/hole5.ans`。

该组样例满足测试点 $11 \sim 13$ 的约束条件。

**【样例 \#6】**

见附件中的 `hole/hole6.in` 与 `hole/hole6.ans`。

该组样例满足测试点 $14 \sim 19$ 的约束条件。

**【样例 \#7】**

见附件中的 `hole/hole7.in` 与 `hole/hole7.ans`。

该组样例满足测试点 $20 \sim 25$ 的约束条件。

**【数据范围】**

本题共 $25$ 个测试点，每个 $4$ 分。
  
|测试点编号|$n$|$m_i\le$|
| :-----------: | :-------------:|:-----------:|
|$1\sim2$|$=2$|$10^6$|
|$3\sim4$|$=2$|$10^9$|
|$5\sim6$|$=3$|$10^6$|
|$7\sim8$|$=3$|$10^9$|
|$9\sim10$|$\le20$|$15$|
|$11\sim13$|$\le20$|$10^9$|
|$14\sim19$|$\le1000$|$10^9$|
|$20\sim25$|$\le2\times10^5$|$10^9$|

对于全部数据，保证：$2\le n\le 2\times10^5$，$1\le a_i\le m_i\le 10^9$。

## 样例 #1

### 输入

```
2
6 6 
2 3```

### 输出

```
8```

## 样例 #2

### 输入

```
2
999999999 999999999
500000000 500000000```

### 输出

```
999999990```

## 样例 #3

### 输入

```
3
5 7 8
4 5 2```

### 输出

```
12```

# 题解

## 作者：LiuCarry (赞：18)

## 52pts

我们可以将空间分为 $2^n$ 份，每份是以黑洞为原点的坐标系的每个坐标轴的半轴的交集，半轴可以取正或负，因此是 $2^n$ 份。

这样枚举每个坐标 $i$，答案就是对每一份，每个方向上到边界的距离的最小值的和，即 $\min{(a_i-1)}$ 或 $\min{(m_i-a_i)}$，时间复杂度 $O(2^n \times n)$。

## 100pts

然后考虑每个 $i$ 对答案的贡献。

我们先把 $a_i-1$ 和 $m_i-a_i$ 列出来，比如对于这个样例：

```
3
5 7 8
4 5 2
```

我们把它写成：

```
3 1
4 2
1 6
```

第一个是 $a_i-1$，第二个是 $m_i-a_i$，我们分别称他们为 $x_i$ 和 $y_i$。

这样的话答案就是每一个 $i$ 取 $x_i$ 或 $y_i$ 的这一个路径上的最小值和，因此只有一个从上到下的路径的最小值可以对答案产生贡献。

我们将 $x_i$ 和 $y_i$ 合起来，排个序，发现贡献就是 $num \times 2^{cnt}$，其中 $num$ 是当前枚举到的数，$cnt$ 是 $x_i$ 和 $y_i$ 都没有被取到的 $i$ 的个数，即 $x_i$ 和 $y_i$ 都大于 $num$ 的 $i$ 的个数。还有别忘了开 `long long` 和初始时令 $ans=1$。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n;
int m[200005];
int a[200005];
int ans=1;
vector<pair<int,int>> vec;
int cnt[200005];
bool bo=0;
int cnt2;
int qpow(int x,int y)
{
	if(y==0) return 1;
	if(y==1) return x;
	int res=qpow(x,y>>1);
    return y&1?(res*res%mod*x%mod):(res*res%mod);
}
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>m[i];
	for(int i=1;i<=n;i++) cin>>a[i];
    vec.resize(2*n);
	for(int i=1;i<=n;i++)
	{
		vec[2*(i-1)]={a[i]-1,i};
		vec[2*(i-1)+1]={m[i]-a[i],i};
		cnt[i]=2;
	}
	cnt2=n;
	sort(vec.begin(),vec.end());
	int num,I;
	for(int i=0;i<2*n&&!bo;i++)
	{
		num=vec[i].first;
		I=vec[i].second;
		cnt[I]--;
		if(!cnt[I]) bo=1;
		if(cnt[I]) cnt2--;
		int res=num*qpow(2,cnt2)%mod;
		ans=(ans+res)%mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：16)

看到 $|a_i-b_i|=k$，我们分别考虑每一维选择 $a_i-b_i\lt 0$ 和 $a_i-b_i\geq 0$ 的两种情况。

$\mathcal O(2^n)$ 枚举每一维选了什么情况。设 $l_i=a_i,r_i=m_i-a_i$，那么每一维的两种选择分别表示选了 $l_i$ 还是 $r_i$。

不难发现对应情况延伸出去的对角线长度应该是 $\min\{len_i\}$，其中如果选择了 $a_i-b_i\lt 0$ 则 $len_i\gets l_i$，否则 $len_i\gets r_i$。

此时有一个 $\mathcal O(2^n n)$ 的暴力，足以获得 $52$ 分。

进一步优化，我们不妨枚举每个维度的两个选择作为 $\min$ 的情况会出现几次。

对于第 $i$ 个维度的选择 $len_i$，如果第 $j$ 个维度的 $l_j,r_j$ 均 $\geq len_i$，那么第 $j$ 个维度可以给这次选择带来 $\times 2$ 的方案数。同理，如果只有一个 $\geq len_i$，只能选这一个。如果都 $\lt len_i$ 说明这个维度无法选择，这种方案不成立。

稍微注意一下前后去重（例如取到 $=$ 的时候强制钦定 $j\lt i$ 才有效，读者自行思考为什么要这么做）就可以做到 $\mathcal O(n^2)$。可以获得 $76$ 分。

继续优化，如果你打出了 $\mathcal O(n^2)$ 的程序，我们只需要按 $\min\{l_i,r_i\}$ 排序即可。因为不难发现只有 $\min\{l_i,r_i\}$ 或者 $\min\limits_{i=1}^{n}\{r_i\}$ 可以作为全局选择的 $\min$，而 $\min\limits_{i=1}^{n}\{r_i\}$ 只有一种，用上面说的 $\mathcal O(n)$ 枚举 $\mathcal O(n)$ 判断可以只做 $\mathcal O(n)$ 判断的这一步，复杂度就是 $\mathcal O(n)$。

记下来考虑按 $\min\{l_i,r_i\}$ 排序之后 $\min\{l_i,r_i\}$ 成为全局最小值的可能方案数。由于排序了，排在 $i$ 后面的一定满足 $l_j,r_j$ 均 $\geq \min\{l_i,r_i\}$，看一下前面的 $\min\limits_{j=1}^{i-1}\{\max\{l_j,r_j\}\}$ 是否 $\geq \min\{l_i,r_i\}$ 即可知道前面能造成 $\times 0$ 的贡献还是 $\times 1$ 的贡献。

复杂度瓶颈在排序。剩余部分与输入同阶。

虽然说的乱七八糟的但是相信讲到 $\mathcal O(n^2)$ 之后如果真的自己实现了一版 $\mathcal O(n^2)$ 是很容易想到排序以及之后的判断的。

---

## 作者：lovelish (赞：13)

我们先从低维度到高维度看起。

对于二个维度，显然我们可以通过过黑洞所在格子做铅垂线和水平线把区域分为四部分。对于每一部分，由于横纵坐标变化值相等，所以只有两个维度的长度都足够的情况下格子才会变为黑色，那么黑色格子的数量即两个维度长度的较小值。那么四部分相加的结果即：

$$

\min(a_1-1,a_2-1)+\min(a_1-1,m_2-a_2)+\min(m_1-a_1,a_2-1)+\min(m_1-a_1,m_2-a_2)

$$

对于三个维度，同理，仅仅是把四个部分改为了八个部分，同样还是对于每个部分取三个维度长度中的最小值。

那么对于 $n$ 维度也同理，共分为了 $2^n$ 个部分，对于每个部分取 $n$ 个维度长度中的最小值即可。显然，对于一个 $a_i$，该维度长度分为的两部分为 $a_i-1$ 和 $m_i-a_i$。那么可以直接使用搜索枚举每个维度是第一部分还是第二部分，时间复杂度为 $O(2^n)$，可以拿到 $52$ 分。

考虑优化，可以发现，有的长度用了非常多次，这是因为它很小，那么我们又可以发现，对于一个本身就最小的长度，无论其他维度怎么选择，结果一定还是该长度。这样会直接减少一半的计算过程，但是选择的那一维度的另一部分不一定也是最小，那么就从剩余的所有部分中再寻找一个最小值，那么同理，还会有一半的答案都为该长度。那么就可以直接重复该步骤，一直直到最小值的维度的另一部分已经选过，这样就相当于已经包含了所有答案，那么剩下答案的直接全部给该长度即可。时间复杂度为 $O(n^2)$，不过显然可以先对所有部分标记维度编号，然后进行排序，进行优化，时间复杂度降为 $O(n\log n)$。

实现时，先将每个 $a_i-1,m_i-a_i$ 存进数组 $b$，然后对 $b$ 进行升序排序。排完之后，从前往后枚举，直到找到第一个另一部分已经被统计过的 $b_i$，然后答案即：

$$

\Large\left(\sum^{j<i}_{j=1}b_j\times2^{n-j-1}\right)+b_i\times 2^{n-i}

$$

---

## 作者：szh_AK_all (赞：11)

赛时花了大量时间做过这题，所以来发篇题解，说说我的搞笑做题思路。

考虑枚举 $k$，但是看到 $m_i$ 的范围很大，所以可以离散化一下。

那么什么样的点是有用的呢（也就是离散化后的关键点）？首先可以将 $|a_i-b_i|=k$ 转换一下形式，也就是 $a_i-k=b_i$，或者 $a_i+k=b_i$，并且需要满足 $1\le b_i \le m_i$，也就是说，当 $b_i=a_i-k$ 时，需要满足 $a_i-k\ge 1$，也即 $k\le a_i-1$，当 $b_i=a_i+k$ 时，需要满足 $a_i+k\le m$，也即 $k\le m-a_i$，那么显然 $a_i-1,m-a_i$ 是关键点。

至此便可以得到一个朴素的算法：枚举一个关键点 $l$，再枚举 $i$ 看这个关键点的大小对于 $i$ 来说满足 $l\le a_i-1,l\le m-a_i$ 中的几条，再根据乘法原理，方案数即为这些满足的条数的乘积。

时间复杂度 $O(n^2)$，可以获得 $76$ 分的好成绩。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int mod = 1e9 + 7;
int a[200005], m[200005];
int b[400005], tot;
int k1[200005], k2[200005];
int nn;

int qpow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b % 2 == 1)
			ans = ans * a % mod;
		a = a * a % mod;
		b /= 2;
	}
	return ans % mod;
}

signed main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> m[i];
	b[++tot] = 0;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		b[++tot] = a[i] - 1;
		b[++tot] = m[i] - a[i];
	}
	sort(b + 1, b + tot + 1);
	nn = unique(b + 1, b + tot + 1) - (b + 1);
	int ans = 0;
	b[nn + 1] = b[nn] + 1;
	//cout << endl;
	for (int i = 1; i <= n; i++) {
		k1[i] = a[i] - 1;
		k2[i] = m[i] - a[i];
		//cout << k1[i] << " " << k2[i] << endl;
	}
//	cout << endl;
	ans = 1;
	for (int i = 1; i <= nn; i++) {
		int l = b[i] + 1, r = b[i + 1];
		int o = 0, one = 0, two = 0;
		for (int j = 1; j <= n; j++) {
			if (l <= k1[j] && l <= k2[j])
				two++;
			else if (l <= k1[j])
				one++;
			else if (l <= k2[j])
				one++;
			else
				o++;
			if (o)
				break;
		}
		if (!o) {
			ans += (r - l + 1) * qpow(2, two) % mod;
			//cout << l << " " << r << " " << two << endl;
			ans %= mod;
		}
	}
	cout << ans;
}
```

考虑优化。

瓶颈在于枚举每个维度来计算满足的条数，但是考虑到 $l$ 满足的条件无非是以下几种：

- 两条都满足，即 $l\le\min(a_i-1,m_i-a_i)$。

- 两条都不满足，即 $l\ge \max(a_i-1,m_i-a_i)$。

- 只满足其中一条，根据容斥原理，可以用总数减去以上两种情况。

容易发现，维护前两种情况可以使用树状数组，那么本题就能通过了。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int mod = 1e9 + 7;
int a[200005], m[200005];
int b[400005], tot;
int k1[400005], k2[400005];
int nn;
int c1[400005], c2[400005];

void add(int x, int y, int c[]) {
	for (; x <= nn + 2; x += x & (-x))
		c[x] += y;
}

int ask(int x, int c[]) {
	int ans = 0;
	for (; x; x -= x & (-x))
		ans += c[x];
	return ans;
}

int qpow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b % 2 == 1)
			ans = ans * a % mod;
		a = a * a % mod;
		b /= 2;
	}
	return ans % mod;
}

signed main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> m[i];
	b[++tot] = 0;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		b[++tot] = a[i] - 1;
		b[++tot] = m[i] - a[i];
	}
	sort(b + 1, b + tot + 1);
	nn = unique(b + 1, b + tot + 1) - (b + 1);
	int ans = 0;
	b[nn + 1] = b[nn] + 1;
	for (int i = 1; i <= n; i++) {
		k1[i] = a[i] - 1;
		k2[i] = m[i] - a[i];
		k1[i] = lower_bound(b + 1, b + nn + 1, k1[i]) - b;
		k2[i] = lower_bound(b + 1, b + nn + 1, k2[i]) - b;
		add(min(k1[i], k2[i]), 1, c1);
		add(max(k1[i], k2[i]), 1, c2);
		//	cout << k1[i] << " " << k2[i] << endl;
	}
	//cout << endl;
	//cout << ask(3, c1) << "cjeck" << endl;
	ans = 1;
	for (int i = 1; i <= nn; i++) {
		int l = b[i] + 1, r = b[i + 1];
		int k = i + 1;
		//cout << l << " " << r << " " << k << "ef" << endl;
		int o = 0, one = 0, two = 0;
		two = ask(nn + 2, c1) - ask(k - 1, c1);
		o = ask(k - 1, c2);
		//cout << two << " " << o << endl;
		one = n - two - o;
		if (!o) {
			ans += (r - l + 1) * qpow(2, two) % mod;
			//	cout << l << " " << r << " " << two << endl;
			ans %= mod;
		}
	}
	cout << ans;
}
```

---

## 作者：scc36 (赞：9)

[原题跃迁窗口](https://www.luogu.com.cn/problem/P11214)    
来讲一个赛时想到的不知道算不算正解的方法~~   
### 思路  
我们先从二维平面入手。    
假设一个二维平面的大小为 $(x,y)$，黑洞的位置在 $(xx,yy)$。    
不难得出结论（这里的长表示覆盖格子的数量）：    
1. 从左上角到黑洞位置的这一条线段长为 $min(xx-1,yy-1)$。
2. 从黑洞位置到右下角的这一条线段长为 $min(x-xx,y-yy)$。   
3. 从右上角到黑洞位置的这一条线段长为 $min(xx-1,y-yy)$。
4. 从黑洞位置到左下角的这一条线段长为 $min(x-xx,yy-1)$。
   
另外再算上黑洞本身，二维平面中，一个黑洞总的吞噬量为 $min(xx-1,yy-1)+min(x-xx,y-yy)+min(xx-1,y-yy)+min(x-xx,yy-1)+1$。当然，还要取模。    

再后面就靠推理了，~~毕竟人脑也很难想象。~~    
综合上述结论，就可以得到一个小结论：对于一个坐标为 $(x_1, x_2, \dots, x_n)$ 的黑洞的第 $i$ 个维度，在求最小时，会有两种情况：要么是 $m_i-x_i$，要么是 $x_i-1$。    
我们可以用 $O(2^n)$ 的搜索去选择第 $i$ 个维度是第一种情况还是第二种情况，理论上有 $52pts$，~~还是很不错的。~~

---

然后我们考虑如何优化。   
假设 $x_1-1$ 是所有可能中最小的一个，则它会被计算 $2^{n-1}$ 次。    
同理，假设 $x_1-1$ 是所有可能中第 $x$ 小的一个，则它会被计算 $2^{n-x}$ 次。特殊的，如果是第 $n+1$ 小，则会计算一次，而非 0.5 次。   
此外，还要注意一点：假如我们称 $m_i-x_i$ 和 $x_i-1$ 是“同宗”的，当他们两个是第一和第二小的，实际上就会霸占所有的可能性，不给别人一点余地。同理，假如第 $x$ 小的数字的“同宗数”之前已经被计算过了，这个数字就会被计算 $2^{n-x+1}$ 次，然后直接退出循环，退出查找。这一点要特判一下~~    
### 代码  

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,i,a[1000001],f[1000001],x,m,j,s,ff[1000001];
struct no{
	int a,b;
}b[1000001];
const int mod=1e9+7;
bool cmp(no t,no w){
	return t.a<w.a;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(i=1;i<=n;i++) cin>>a[i];
	f[0]=1;f[1]=1;
	for(i=2;i<=n;i++) f[i]=f[i-1]*2%mod;  //记录总共要计算几次 
	for(i=1;i<=n;i++){
		cin>>x;
		m++,b[m].a=a[i]-x,b[m].b=i;
		m++,b[m].a=x-1,b[m].b=i;
		//记录两种情况，顺便把编号记录下来 
	}
	sort(b+1,b+m+1,cmp);  //从小到大排序 
	for(i=1,j=n;j>=0;i++,j--)
		if(ff[b[i].b]==0) //“同宗数” 没出现过 
    		s=(s+b[i].a*f[j]%mod)%mod,ff[b[i].b]=1;
		else{  //“同宗数”出现过了 
			s=(s+b[i].a*f[j+1]%mod)%mod;
			break;
		}
	cout<<(s+1)%mod; //别忘了+1 
}
```

---

## 作者：_zuoqingyuan (赞：8)

你说的对，但是我数组开成 $10^5$ 挂了 $24$。

# 思路分析

从几何角度来思考太过困难，不如从代数角度来想。在下文中：如果两个点满足 $\forall 1\le i\le n,|a_i-b_i|=k$，那么点 $b$ 就是距离点 $a$ 为 $k$ 的点。

首先可以枚举 $k$，对于第 $i$ 维，如果 $a_i-k>0$，那么显然可以令 $b_i=a_i-k$，如果 $a_i+k\le m_i$，那么可以令 $b_i=a_i+k$。

然后我们统计每个位置有几种可能的取值，然后乘起来就可以，**注意**：当 $a_i-k\le 0,a_i+k>m$，此时第 $i$ 维就没有任何一个 $b_i$ 满足条件，所以距离 $a$ 为 $k$ 的点个数为零。

枚举 $k$ 时间复杂度为 $O(V)$，其中 $V=10^9$，总时间复杂度为 $O(Vn)$。无法通过。

记 $s_i=\max\{a_i,m_i-a_i\},t_i=\min\{a_i,m_i-a_i\}$。当 $k$ 从大到小单调递减时，方案数不断变多。我们思考上面的过程，如果 $k\in (t_i,s_i]$，那么第 $i$ 维在距离为 $k$ 的点的贡献为 $\times1$，如果 $k\in [1,t_i]$，第 $i$ 维在距离为 $k$ 的点的贡献为 $\times 2$。

记 $S=\min_{1\le i\le n}{s_i}$，显然，当 $k\le S$ 时才会有距离为 $k$ 的点存在，我们把每个 $t_i$ 看成分界点，就把 $[1,S]$ 分成若干段，每一段内点的方案数相等，且这一段的方案数为下一段方案数乘 $2$（每跨越一个分界点意味着存在某一维从 $k\in (t_i,s_i]$ 变成 $k\in [1,s_i]$，贡献从 $\times 1$ 变成 $\times 2$）。我们将 $t$ 排序后从后往前扫，维护方案数，统计答案时加上方案数乘区间长度即可。

时间复杂度 $O(n\log n)$，瓶颈在于排序，注意可能会存在 $k_i>S$ 的情况。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const int N=2e5+10;
ll n,m[N],x[N],tmp,ans,k[N],s=mod,it;
bool cmp(int a,int b){return a>b;}
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)scanf("%lld",m+i);
    for(int i=1;i<=n;i++)scanf("%lld",x+i);
    for(int i=1;i<=n;i++){
        s=min(max(x[i]-1,m[i]-x[i]),s);
        k[i]=min(x[i]-1,m[i]-x[i]);
    }
    sort(k+1,k+1+n,cmp);
    tmp=1;
    for(it=1;it<=n;it++){
        if(k[it]>=s)tmp=(tmp*2)%mod;
        else {it--;break;}
    }
    ans=(ans+(s-k[it+1])*tmp%mod)%mod;
    for(it=it+1;it<=n;it++){
        tmp=(tmp*2)%mod;
        ans=(ans+(k[it]-k[it+1])*tmp%mod)%mod;
    }
    ans++;ans=(ans%mod+mod)%mod;
    printf("%lld\n",ans);
    return 0;
}
```


如有错误请指出。

---

## 作者：水星湖 (赞：7)

赛前没仔细想觉得是绿的，现在还是建议黄吧。

显然，每一维有两个方向，所以 $n$ 维一共有 $2^n$ 个方向。所求即为对于 $2^n$ 个方向中的每一种方向，最大的合法 $k$ 之和。

直接枚举复杂度为 $\mathcal O(2^n)$ 或 $\mathcal O(n2^n)$，考虑优化，假设有一维的某一个方向最大的合法 $k$ 非常小，那么确定这一维之后，剩下 $n-1$ 维的 $2^{n-1}$ 种情况的贡献都会为这一维的 $k$，这启发我们对每一维的每一个方向拆贡献计算。

我们希望当前的 $k$ 是所有方向的最小值，所以可以按照每一维，每个方向的最大合法 $k$ 共 $2n$ 个数从小到大排序，然后倒序处理。考虑我们枚举到这个数是维度 $x$ 的某一个方向的最大合法 $k$，显然，如果到此时出现过的不同的维度（含 $x$）小于 $n$ 个，则说明当前数不可能作为最小值，所以没有贡献，否则，答案加上这个数乘以这个数的贡献系数即可。假设这个数后面有 $y$ 个维度出现了两次（含这个数所在的维度），则贡献系数为 $2^y$，这个可以在倒序枚举时计算出来，只要维护一个 $t$ 表示贡献系数，在一个维度第二次出现时令 $t\gets t\times 2$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 4e5 + 5, mod = 1e9 + 7;
int n, a[N], f[N];
pair<int, int> b[N];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1, x; i <= n; i++) {
        cin >> x;
        b[i] = {x - 1, i}, b[n + i] = {a[i] - x, i};
    }
    sort(b + 1, b + 2 * n + 1); 
    int t = 1, ans = 1, cnt = 0;
    for(int i = 2 * n; i >= 1; i--) {
        auto [v, id] = b[i];
        cnt += !f[id];
        if(cnt == n) ans = (ans + 1ll * t * v % mod) % mod;
        if(f[id]) t = t * 2 % mod;
        f[id] = 1;
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 作者：fish_love_cat (赞：6)

因为做出这题得到了 rk56 的好成绩。

---

当数学题做就是自虐来的，所以我们可以将题面进行一个转化：

> 已知序列 $a$，求有多少序列 $b$ 满足：
>
> - 对于每个 $1 \leq i \leq n$，都有 $\lvert a_i - b_i \rvert = k$，其中 $k$ 是任意非负整数。

这做起来就容易多了。

---

我们先不考虑黑洞自身的情况（即 $a=b$ 的情况）。

设 ${f_i}_j=[a_j>b_j]$，$f_i$ 代表第 $i$ 个方向，$j$ 代表维度，${d_i}_j$ 代表 $f_i$ 在第 $j$ 轴上最多有的点数。

对于每个 $f_i$，如果 ${f_i}_j=1$，那么在第 $j$ 个轴上，该方向有 ${d_i}_j=a_j-1$ 个点。如果 ${f_i}_j=0$，那么在第 $j$ 个轴上，该方向有 ${d_i}_j=m_j-a_j$ 个点。

显然的，在 $f_i$ 上的方案数 $k_{max}=\min({d_i}_1,{d_i}_2,\dots,{d_i}_3)$。

暴力枚举方向计和 $O(2^n)$，能够拿到 $52$ 分。

---

考虑优化。

因为是求最小值，而且 ${d_i}_j$ 就两种取值，所以我们可以把每个 ${d_i}_j$ 的值拆出来排序。

对于第 $i$ 小值，通过简单的计算可以发现会有 $2^{n-i}$ 次贡献，然后对于当前轴就得反向了。

但是这是有锅的。

因为每一轴只能反向一次。当你第二次枚到反过的轴时，剩下的都是以此为 $k$，贡献次数达到了 $2^{n-i+1}$。

然后就做完了。注意取模，推荐使用快速幂。

时间复杂度 $O(n\log n)$，瓶颈在于排序。

---

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define mod 1000000007
#define int long long
int a[200005],b[200005];
struct fish{
    int x,id;
};
vector<fish>v;
long long qpow(long long a,long long b,long long p){
	long long ans=1;
	if(b==0){
		return 1;
	}
	while(b){
		if(b&1){
			ans*=a;
			ans%=p;
		}
		a*=a;
		b>>=1;
		a%=p;
	}
	return ans;
}
bool cmp(fish awa,fish qwq){
    if(awa.x==qwq.x)return awa.id<qwq.id;
    return awa.x<qwq.x;
}
map<int,bool>mapp;
int flc,ans;
signed main(){
    int n;
    cin>>n,flc=n;
    for(int i=1;i<=n;i++)
    cin>>b[i];
    for(int i=1;i<=n;i++)
    cin>>a[i],v.push_back({a[i]-1,i}),v.push_back({b[i]-a[i],i});
    sort(v.begin(),v.end(),cmp);
    for(int i=0;i<v.size();i++){
        if(mapp[v[i].id]){
            ans=(ans+v[i].x*qpow(2,flc,mod))%mod;
            break;
        }
        flc--;
        ans=(ans+v[i].x*qpow(2,flc,mod))%mod;
        mapp[v[i].id]=1;
        //cout<<v[i].x<<' '<<v[i].id<<' '<<ans<<endl;
    }
    cout<<ans+1;
    return 0;
}
```

---

膜拜 @[Yurz](/user/760954)！

---

## 作者：cheng2010 (赞：6)

## 黑洞

### 思路

首先，考虑暴力，对于每个方向，先求出它向正、负延伸的范围，再 $O(2^n)$ 计算向正还是负延伸。

考虑优化，发现每一次能延伸多少全看其中最小的，又顺序不影响答案，所以可以按向正、负延伸的范围的最小值排序，一旦后面的最小值都比当前最小值还大，再搜索没有意义，直接加上后面总共的贡献返回即可。缔造了 $O(2^n)$ 过 $2 \times 10^5$ 的奇迹。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+7;
const int Mod=1e9+7;
int n;
int m[N],mi[N]={1};
struct Node
{
	int x,y;
}a[N];
int h[N];
int ans=1;
inline void dfs(int x,int Min)
{
	if(x==n+1)
	{
		ans+=Min;
		ans%=Mod;
		return;
	}
	if(Min<=h[x])
	{
		ans+=Min*mi[n-x+1]%Mod;
		ans%=Mod;
		return;
	}
	dfs(x+1,min(Min,a[x].x));
	dfs(x+1,min(Min,a[x].y));
}
inline bool cmp(Node A,Node B)
{
	return min(A.x,A.y)<min(B.x,B.y);
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		mi[i]=mi[i-1]*2%Mod;
		scanf("%lld",&m[i]);
	}
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%lld",&x);
		a[i].x=m[i]-x;
		a[i].y=x-1;
	}
	sort(a+1,a+1+n,cmp);
	h[n+1]=1e18;
	for(int i=n;i>=1;i--)
	{
		h[i]=min(h[i+1],min(a[i].x,a[i].y));
	}
	dfs(1,1e18);
	printf("%lld\n",ans);
}
```
暴力万岁！！！

---

## 作者：ShizukuQWQ (赞：4)

我们可以发现一个结论，对于从黑洞出发向所有维度的其中一个方向所能走的步数最小值即为黑洞数量。也就是说我们每一次只需要维护最小值即可。每一个维度我们可以选择坐标减一或加一两个方向。设 $x$ 为当前可以自由选择方向的维度数量。当我们选中这个方向为所有可拓展步数的最小值时，答案显然与其他 $x$ 个维度的方向无关，共有 $2^x$ 种情况。而统计完这个答案以后，当前这个维度就只能朝另外一个方向走了，因此 $x-1$。若两个方向都走完了，那么这个维度就无路可走，此时结束程序即可。我用了优先队列来维护当前步数最小值。
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long INF=1e16,N=2e5+5,mod=1e9+7;
long long n,a[N],b[N],c[N],mx,mn,ans,NOW,f[N];
priority_queue<pair<long long,long long> > q;
int main(){
//	freopen("hole7.in","r",stdin);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin>>n;
	f[0]=1;
	for(int i=1;i<=n;i++) f[i]=f[i-1]*2%mod;
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		q.push({-(a[i]-1),i});
		q.push({-(b[i]-a[i]),i});
	}
	NOW=n-1;
	while(!q.empty()){
		long long fr=q.top().second,w=-q.top().first;
		q.pop();
		if(c[fr]){
			ans+=f[NOW+1]*w;
			ans%=mod;
			break;
		}
		c[fr]=1;
		ans+=f[NOW]*w;
		ans%=mod;
		NOW--;
	}
	cout<<(ans+1)%mod;
}

---

## 作者：fzitb7912 (赞：3)

题解摘自 [CSP2024 前做题情况](https://www.luogu.com.cn/article/9zpicw3e)。

## 分析

提供一个另类的做法。

考虑对于 $n$ 个 $a_i,b_i$，我们能够找到一个 $k$，使得：$\forall i,a_i=0\lor a_i\ge k$，$\forall i,b_i=0\lor b_i\ge k$。这样的话，我们就能找到最大的一个长度，使得这个长度内的任意一个数都有对应的序列 $y$ 满足 $|x_i-y_i|$ 相等。有方案数：$k\times \prod\limits_{i=1}^{n}([a_i\ne 0]+[b_i\ne 0])$。但是这样取了之后，可能还会有解，于是将所有 $a_i,b_i$ 减去 $k$，继续计算。知道存在至少一个 $i$，有 $a_i=0\land b_i=0$ 为止。使用 set 维护的时间复杂度为 $O(n\log n)$。

## 代码

```cpp
il int get(int x){
	if(!id.count(x)) return id[x]=++cnt;
	return id[x];
}
il void solve(){
	n=rd;
	for(re int i=1;i<=n;++i) b[i]=rd-1;
	for(re int i=1;i<=n;++i){
		a[i]=rd-1,b[i]=b[i]-a[i];
		v[get(a[i])].push_back({i,1});
		v[get(b[i])].push_back({i,0});
		st.insert(a[i]),st.insert(b[i]);
	}
	int Min,sum=0,fuc=qmi(2,n,p),lst=0;
	while(!st.empty()){
		Min=*st.begin();
		ans=(ans+fuc*(Min-lst)%p)%p;
		lst=Min;
		for(auto x:v[get(Min)]){
			vis[x.x][x.y]=1;
			if(vis[x.x][x.y]&&vis[x.x][x.y^1]) goto End;
			fuc=fuc*qmi(2,p-2,p)%p;
			st.erase(st.find(((x.y==1)?a[x.x]:b[x.x])));
		}
	}
	End:;
	cout<<(ans+1)%p<<"\n";
    return ;
}
```

---

## 作者：queenbee (赞：3)

# P11214 【MX-J8-T2】黑洞 题解

## 思路
[题目传送门](https://www.luogu.com.cn/problem/P11214)，本题解建议配合题面图片理解。

对于 $n$ 维，以黑洞作为原点建立坐标系，则每条轴对应有两个方向（轴的正、负方向），任意 $n$ 个不同轴方向决定一条对角线（以原点为端点），共有 $2^n$ 条对角线，每条对角线长度为决定该对角线的方向中最短的方向的长度，由此可得每个方向最多决定 $2^{n-1}$ 条对角线。

定义此 $n$ 维空间，第 $i$ 维大小为 $m_i$，黑洞第 $i$ 维坐标为 $a_i$，则第 $i$ 条轴的两个方向长度为 $a_i-1$ 和 $m_i-a_i$。对这 $2i$ 个方向进行升序排序，最短的方向决定了 $2^{n-1}$ 条对角线，次短的方向因与最短方向有 $2^{n-2}$ 条对角线重合，所以仅决定 $2^{n-2}$ 条对角线，依此类推，第 $i$ 短的方向决定 $2^{n-i}$ 条对角线，以升序让长度小的方向优先决定对角线长度。

当一条轴上的两个方向同时决定了 $n$ 维对角线时，决定该 $n$ 维对角线的方向均包含该轴两方向，因此比该轴两方向中较长的方向更长的方向将无法决定任何对角线长度。特别的，对于该轴中较长的的第 $i$ 短方向，因其与同轴另一方向无对角线重合，所以该方向决定 $2^{n-i+1}$ 条对角线。
## 程序
```
#include<bits/stdc++.h>	//我爱万能头 
using namespace std;
#define int long long
const int N=2e5+10;
const int Mod=1e9+7;
int n;
int m[N],vis[N],cnt;
int a[N],base[N],ans;
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;	//小根堆
signed main(){
	scanf("%lld",&n);
	cnt=n;
	base[0]=1;
	for(int i=1;i<=n-1;i++){	//预处理2的次方 
		base[i]=base[i-1]*2;
		base[i]%=Mod;
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&m[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		q.push({a[i]-1,i});	
		q.push({m[i]-a[i],i});
	}
	while(1){
		int l=q.top().first,num=q.top().second;
		q.pop();
		if(vis[num]==1){	//如果加入同轴两方向，判断退出循环条件 
			ans+=(l*base[cnt])%Mod;	//最终答案加上其决定的对角线长度 
			ans%=Mod;
			break;
		}
		else{	//加入不同轴两方向 
			cnt--;	//每次决定的对角线数量减少 
			ans+=(l*base[cnt])%Mod;	//最终答案加上其决定的对角线长度 
			ans%=Mod;
			vis[num]=1;	//标记该轴的一个方向已被访问 
		}
	}
	printf("%lld",(ans+1)%Mod);	//因为没考虑原点，最后答案加上原点 
	return 0;	//完结撒花 
}
```

---

## 作者：_EEA_ (赞：3)

#### 转述题意

求有限高维空间中过一点的所有对角线的长度（不是欧几里得长度，但专业知识有限，我并不知道怎么表述）的和。

#### 思路过程

挺有意思~~（有难度）~~的一道题，像这种高维空间的情境一般采用由特殊到一般的归纳类比法。

我们先来看有限的三维空间中，并且黑洞在空间一个角的情形：

![image-20241020124924972](https://cdn.luogu.com.cn/upload/image_hosting/eho4g3uv.png)

这时候限制对角线长度的就是空间三个维度中最短的那一条边，实际上算方格数的话就是相等的。

而对于有限三维空间中黑洞位置一般的情形，可以分成黑洞在角落的八个小情形，也就是说，黑洞的位置将空间分成了八个子空间，而每个子空间中黑洞都在角落：

![image-20241020131132800](https://cdn.luogu.com.cn/upload/image_hosting/vnzqsv8d.png)

过黑洞的绿色的线分别向六个方向延伸（每个维度有两个方向），为了表述方便，我把每一个方向的一条线叫做“轴”。每个轴被四个子空间（刚好是八个子空间的一半）共用。

不妨找到六个轴中最短的那个轴，那么这四个子空间内的对角线长度都取决于这个轴的长度。

然后再找到次短轴，分以下两种情况：

- 若这个轴与最短轴共线，则剩下的四个字空间内的对角线长度都取决于这个次短轴
- 若这个轴与最短轴垂直，那么剩下的四个字空间只有一半的子空间（即两个子空间）的对角线长度取决于这个次短轴

对于第二种情况，再找第三短轴，则类似地又分两种情况：

- 若这个轴与前面的两个轴任意一个共线，则剩下的两个子空间的对角线长度都取决于这个第三短轴
- 若这个轴与前面的两个轴都垂直，则剩下的两个子空间只有一半的子空间（即一个子空间）的对角线长度取决于这个第三短轴

以此类推……

**发挥想象力**类比一下，有限高维空间中（设为 $n$ 维）也有类似的结论：

- 黑洞在角落时，对角线长度取决于所有维度中最短的那一条边
- 一般的黑洞位置将空间分成 $2^n$ 个子空间，每个子空间中黑洞都在角落
- 过黑洞沿 $n$ 个维度方向，有 $2n$ 个轴，每个轴被 $2^{n-1}$ 个子空间共用
- 最短轴决定了 $2^{n-1}$ 个子空间对角线的长度
- 次短轴如果不与最短轴共线的话，决定了 $2^{n-2}$ 个子空间对角线的长度
- ……
- 第 $k$ 短轴如果都不与前 $k-1$ 短轴共线的话，决定了 $2^{n-k}$ 个子空间对角线的长度

到这里，到这里，如果我讲清楚了的话，做法就呼之欲出了：

**分别找到最短轴、次短轴、等等，判断其是否与之前处理过的轴共线。如果是的话，剩下的子空间对角线长度就是这个轴的长度，累加进答案；如果不是的话，剩下的子空间中有一半的对角线长度就是这个轴的长度，累加进答案。**

因为轴只有 $2n$ 个，所以复杂度是 $O(n)$。

#### 代码

```cpp
// Author: _EEA_

#include <bits/stdc++.h>

#define MA(a, b) ((1ll * (a) + (b)) % M)
#define MT(a, b) ((1ll * (a) * (b)) % M)

using namespace std;

const int N = 2e5+5;
const int M = 1e9+7;
int mls[N], als[N];

bool book[N];

int mpow(int p, int q){
	int res = 1;
	while(q){
		if(q & 1){
			res = MT(res, p);
		}
		p = MT(p, p);
		q >>= 1;
	}
	return res;
}

int main(){
	ios::sync_with_stdio(0); cin.tie(0);

	int n;
	priority_queue<pair<int, int>, vector<pair<int, int>>, bool (*)(pair<int, int>, pair<int, int>)> que([](pair<int, int> a, pair<int, int> b){
		return a.first > b.first;
	});

	cin >> n;
	for(int i = 1; i <= n; ++i){
		cin >> mls[i];
	}
	for(int i = 1; i <= n; ++i){
		cin >> als[i];
	}

    /*
    优先队列里的元素是一个 pair，
    其 first 属性是轴的长度，second 属性是轴的维度。
    轴的维度用以判断该轴是否与其他轴共线，
    因为两条轴共线当且仅当它们在同一个维度方向上。
    */
	for(int i = 1; i <= n; ++i){
		que.push(pair<int, int>(als[i] - 1, i));
		que.push(pair<int, int>(mls[i] - als[i], i));
	} // 分别将每个维度的两个轴放进优先队列排序，这里的轴不包含黑洞本身

	int nleft = n; // 目前还剩下 2^nleft 个子空间对角线长度不确定
	int ans = 0;
	while(!que.empty()){
		auto tmp = que.top(); // 取目前的最短轴
		que.pop();
		if(book[tmp.second]){ // 如果这个轴与之前的轴共线
			ans = MA(ans, MT(tmp.first, mpow(2, nleft)));
			break;
		} // 那么剩下的所有 2^nleft 个子空间对角线长度就是这个轴的长度；没有剩下的子空间了，结束
		book[tmp.second] = 1;
		--nleft; // 否则还剩子空间 2^(nleft-1) 个，只有一半子空间对角线长度是被确定了的
		ans = MA(ans, MT(tmp.first, mpow(2, nleft)));
	}
	cout << MA(ans, 1) << endl; // 因为上面的轴未包含黑洞本身，所以这里要加一
	
	return 0;
}
```

#### 总结

最后我发现我的思路过程有点绕，不过没办法，专业知识有限，我只是还原了最初做题时的思维过程。

~~一眼就看出答案的大佬们轻喷QwQ~~

---

## 作者：_Chronostatis_ (赞：3)

## 【MX-J8-T2】黑洞
第一次赛时切绿题！
## 题意
给定 $n$ 维下的一个点 $P$，第 $i$ 维的大小为 $m_i$，求所有经过 $P$ 的对角线中一共有多少个点
## 思路
考虑模拟。题目中有一句提示：
> 称位置 $(a_1, a_2, \dots, a_n)$ 与 $(b_1, b_2, \dots ,b_n)$ 在同一条对角线上，当且仅当存在一个整数 $k \ge 0$，使得对每个 $1 \le i \le n$，都有 $|a_i − b_i| = k$。

实际上就是 $a_i \pm k = b_i$。

考虑 $a_i + k = b_i$ 的情况。由于坐标应在 $[1, m_i]$ 范围内，此时 $k \le m_i - a_i$。

考虑 $a_i - k = b_i$ 的情况。由于坐标应在 $[1, m_i]$ 范围内，此时 $k \le a_i - 1$。

现在有一个基本思路：枚举 $k$，计算答案累加。这样暴力枚举可以拿到 $6 \times 4 = 24$ 分（$1 \sim 2, 5 \sim 6, 9 \sim 10$），显然有点低。

实际上不需要枚举 $k$，因为 $k$ 只有在某个 $i$ 的 $m_i - a_i$ 或 $a_i - 1$ 时才会对答案产生影响。

于是现在有了一个新的思路：把每个 $m_i - a_i$ 和 $a_i - 1$ 存在一起，排序去重后计算答案。这里有细节：两个相邻的 $k$ 之间的答案实际上是需要加上去的，设当前的 $k$ 一共产生了 $q$ 种方案，共有 $m$ 个不同的 $k$：$\{ b_1, b_2, \dots, b_m\}$，则实际每次累加的答案应该是 $q \times (b_i - b_{i - 1}) \  (i \ge 1)$。此时每次计算答案都需要 $O(n)$ 时间来检查是否合法，时间复杂度为 $O(n ^ 2)$，可以拿到 $19 \times 4 = 76$ 分（$1 \sim 19$）。

此时，观察到实际上每次检查的时间是可以省去的。因为检查实际上是检查对于每个 $1 \le i \le n$，是否都有 $a_i - 1 \ge k$ 或 $m_i - a_i \ge k$。需要满足至少一个 $\ge k$，就是 $\max(a_i - 1, m_i - a_i) \ge k$。所以可以对每个 $a_i - 1$ 和 $m_i - a_i$ 取 $\max$，排序后每次二分查找，如果不满足每一个都 $\ge k$，那么后面的一样不满足条件，退出循环。

但是每次计算答案也需要 $O(n)$ 时间，这又该如何解决呢？观察到每次的答案实际上都是 $2 ^ x$，其中 $x$ 为 $\ge 0$ 的整数。因为每个 $i$ 都有减和加两种可能，但是在对每个 $k$ 计算答案的时候可能只有一个，答案就是 $2^x \times 1^y$，$y$ 和 $x$ 性质相同且 $x + y = n$。发现此时 $x$ 实际上就是满足 $a_i - 1, m_i - a_i$ 均 $\ge k$ 的 $i$ 的数量，所以可以求出 $\min(a_i - 1, m_i - a_i) \ge k$，并从小到大排序，每次二分查找求答案即可。

但此时 $x$ 过大，$2^x$ 又需要尽快计算，所以需要使用快速幂算法。
## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int MAXN = 2e5 + 10;
const int MOD = 1e9 + 7;

ll n, m[MAXN], a[MAXN], b[MAXN], c[MAXN], d[MAXN];

int Power(ll x, ll n) {
  ll ans = 1;
  for (; n; x = x * x % MOD, n /= 2) {
    if (n % 2) {
      ans = ans * x % MOD;
    }
  }
  return ans;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> m[i];
  }
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  for (int i = 1; i <= n; i++) {
    c[i] = min(a[i] - 1, m[i] - a[i]);
    d[i] = max(a[i] - 1, m[i] - a[i]);
  }
  sort(c + 1, c + n + 1);
  sort(d + 1, d + n + 1);
  for (int i = 1; i <= n; i++) {
    b[2 * i - 1] = a[i] - 1;
    b[2 * i] = m[i] - a[i];
  }
  sort(b + 1, b + 2 * n + 1);
  int l = unique(b + 1, b + 2 * n + 1) - b - 1;
  ll ans = 0;
  for (int i = 1; i <= l; i++) {
    int pos = lower_bound(d + 1, d + n + 1, b[i]) - d;
    if (pos != 1) {
      break;
    }
    pos = lower_bound(c + 1, c + n + 1, b[i]) - c;
    ll sum = Power(2, n - pos + 1);
    ans = (ans + sum * (b[i] - b[i - 1]) % MOD) % MOD;  
  }
  cout << ans + 1;
  return 0;
}
```

---

## 作者：2huk (赞：1)

点 $B = (b_1,b_2,\dots,b_n)$ 与点 $A =(a_1,a_2,\dots,a_n)$ 在同一条对角线上等价于：

> 存在一个整数 $k \ge 0$，使得对于每个 $1 \le i \le n$，都有 $|a_i-b_i|=k$。

显然点 $B$ 如果合法，那么这个 $k$ 是唯一的。我们不妨枚举 $k$ 然后统计有多少个合法点 $B$。

形式化的，我们令 $c_i$ 表示有多少合法点 $B$ 对应 $k = i$。答案显然为 $\sum c_i$。现在考虑一个朴素做法，即枚举 $k$ 并计算 $c_k$ 的值。

拆绝对值。$B$ 合法需要满足 $b_i \in \{a_i+k,a_i-k\}$，以及 $b_i \in [1,m]$。

显然每个维度相互独立。我们只需要依次计算第 $i$ 维的方案数（即 $b_i$ 的合法取值数，显然一定是 $\{0,1,2\}$ 之一），乘法原理即可。

这是 $\mathcal O(n^2)$ 做法。

```cpp
c[0] = 1; 		// k = 0 单独考虑 
for (int k = 1; k <= n; ++ k ) {
	int ans = 1;
	for (int i = 1; i <= n; ++ i )
		ans *= (a[i] + k <= m) + (a[i] - k >= 1);
	c[k] = ans;
}

int ans = 0;
for (int k = 0; k <= n; ++ k ) {
  ans += c[k];
}
```

考虑优化。

上面提到过，当 $k$ 固定时，$b_i$ 的合法取值数一定在 $[0, 2]$ 内。不妨从这一点入手分析。

不妨枚举 $i$，计算会对哪些 $c_k$ 产生贡献。

当 $b_i$ 合法取值数为 $0$ 时（即 $a_i+k>m \land a_i-k < 1$ 时），一定有 $c_k = 0$。而且显然当 $k$ 越大时 $a_i+k>m \land a_i-k < 1$ 越有可能发生，即满足 $c_k=0$ 的 $k$ 一定形如一个后缀。不妨求出这个后缀的起始位置，显然是 $\min_i \max(m_i-a_i,a_i-1)$。

当 $b_i$ 合法取值数为 $1$ 时，显然没有贡献。乘 $1$ 答案显然不变。

所以有贡献的答案只有在 $b_i$ 的合法取值数为 $2$ 时（即 $a_i + k \le m \land a_i-k \ge 1$）。显然合法的 $k$ 满足 $1 \le k \le \min(m_i-a_i,a_i-1)$。于是变成了一个前缀乘 $2$ 的问题。

暴力做前缀乘二的代码是这样的：

```cpp
int max_k = INF;
for (int i = 1; i <= n; ++ i ) {
	max_k = min(max_k, max(m[i] - a[i], a[i] - 1));
}

for (int i = 0; i <= max_k; ++ i ) {
	c[i] = 1;
}

for (int i = 1; i <= n; ++ i ) {
	int r = min(m[i] - a[i], a[i] - 1);
	r = min(r, max_k);
	for (int j = 1; j <= r; ++ j ) c[i] *= 2;
}
```

考虑加速这个过程。设我们最终在 $p_1,p_2,\dots,p_m$ 做了前缀乘 $2$ 的操作，且 $p_1 \le p_2 \le \dots \le p_m$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pav34ngv.png)

可以发现相当于对所有 $j \in (p_i,p_{i+1}]$ 执行了 $c_j \gets 2^{m-i}$。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10, P = 1e9 + 7;

typedef long long ll;
#define int ll

int n, a[N], m[N];
int res[N];

int fpm(int a, int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = 1ll * res * a % P;
		b >>= 1, a = 1ll * a * a % P;
	}
	return res;
}

signed main() {
	cin >> n;
	
	for (int i = 1; i <= n; ++ i ) cin >> m[i];
	for (int i = 1; i <= n; ++ i ) cin >> a[i];
	
	int k = 1e9;
	for (int i = 1; i <= n; ++ i ) k = min(k, max(m[i] - a[i], a[i] - 1));
	
	map<int, int> mp;
	for (int i = 1; i <= n; ++ i ) {
		int l = 1, r = min(m[i] - a[i], a[i] - 1);
		r = min(r, k);
		if (l <= r) {
			mp[r] ++ ;
		}
	}
	
	mp[0] += 0, mp[k] += 0;
	
	vector<pair<int, int>> vec;
	for (auto t : mp) vec.push_back(t);
	
	int sum = 0, res = 0;
	for (int i = vec.size() - 1; i; -- i ) {
		sum += vec[i].second;
		res = (res + 1ll * (vec[i].first - vec[i - 1].first) * fpm(2, sum)) % P;
	}
	
	cout << res + 1;
	
	return 0;
}
```

---

## 作者：shuqiang (赞：1)

首先我们观察样例的图片

![](https://cdn.luogu.com.cn/upload/image_hosting/4t3ovta3.png)

然后可以发现，左上方的对角线上点数量就是左边点的数量和上面点的数量的较少值，所以我们可以先把各个方向上点的数量求出来，显然，在一个维度上，其中一个方向上的点是 $m_i-a_i$，另一个方向上的点是 $a_i-1$。

观察这张图片
![](https://cdn.luogu.com.cn/upload/image_hosting/cnm2ba4u.png)

绿色的对角线是黄色对角线的其中一个维度方向相反后的对角线，那么每一个维度对角线的数量就会翻倍，得到一共有 $2^n$ 个对角线。

### 52 分做法

考虑枚举 $2^n$ 个对角线，对每一个对角线求出一共有多少个点，即各个维度选择的方向上点的最小值，最后记得加上中间的点。时间复杂度 $\mathcal{O}(2^nn)$。


```cpp
#include<iostream>

using namespace std;

const int N = 2e5 + 10, mod = 1e9 + 7;
int n, m[N], a[N], ans = 0;
bool b[N];

void dfs(int x){
	if(x == n){
		int mn = 1e9;
		for(int i = 0; i < n; i++){
			if(b[i]) mn = min(a[i]-1, mn);
			else mn = min(m[i]-a[i], mn);
		}
		ans = (ans + mn) % mod;
		return;
	}
	b[x] = 1;
	dfs(x+1);
	b[x] = 0;
	dfs(x+1); 
}

int main(){
	cin >> n;
	for(int i = 0; i < n; i++) cin >> m[i];
	for(int i = 0; i < n; i++) cin >> a[i];
	dfs(0);
	cout << (ans + 1) % mod;
	return 0;
}
```

### 100 分做法

注意到很多对角线对答案的贡献是一样的，这是因为每个对角线的贡献是由各个维度选择的方向上点的最小值决定的，所以一次性算出这些对角线即可。时间复杂度 $\mathcal{O}(n \log n)$，可以通过。

```cpp
#include<iostream>
#include<queue>

using namespace std;
typedef long long ll;

const int N = 2e5 + 10, mod = 1e9 + 7;
int n, a[N][2], w[N], ans = 0;
bool b[N];

struct pos{
	int x, y;
	
	bool operator < (const pos & o) const{
		return a[x][y] > a[o.x][o.y];
	}
};

priority_queue<pos> pq;

int main(){
	cin >> n;
	for(int i = 0; i < n; i++) cin >> a[i][0];
	for(int i = 0; i < n; i++) cin >> a[i][1];
	for(int i = 0; i < n; i++) {a[i][0] -= a[i][1]; a[i][1]--;}
	for(int i = 0; i < n; i++) {pq.push({i, 0}); pq.push({i, 1});}
	w[0] = 1;
	for(int i = 1; i <= n; i++) w[i] = (w[i-1] * 2) % mod;
	int wp = n;
	while(!pq.empty()){
		pos tp = pq.top();
		pq.pop();
		if(b[tp.x]){
			ans = (ans + (ll)a[tp.x][tp.y] * w[wp]) % mod;
			break;
		}
		else{
			wp--;
			ans = (ans + (ll)a[tp.x][tp.y] * w[wp]) % mod;
			b[tp.x] = 1;
		}
	}
	cout << (ans + 1) % mod;
	return 0;
}
```

---

## 作者：_JF_ (赞：0)

[Link](https://www.luogu.com.cn/problem/P11214)

这就是噗叽组第二题吗。不算简单。

如果你和我一样，没有空间想象能力的话，出题人已经几乎给了我们一个形式化题面了，就是：

给出 $(a_1,a_2,...,a_n)$，称 $(b_1,b_2,...,b_n)$ 是合法的，当且仅当存在一个整数 $k≥0$，$\forall 1≤i≤n$，都有 $|a_i−b_i|=k$，且 $1\le b_i \le m_i$。统计合法的 $(b_1,b_2,...,b_n)$ 的数量。

转换好题意了以后，其实就是一个数数吧。

先让 $k>0$，$k=0$ 显然只有一种可能。

我们换一个角度来看待这个 $k$，如果对于一个 $a_i$ 能往左右扩展一步的话，相当于 $k=1$，这时候，我们的 $b_i$ 有两种取值。

对于一个 $a_i$ 而言，我们定义 $l$ 为其往左最多扩展的步数，$r$ 为其最多往右扩展的步数。

记 $l'=\min(l,r)$，$r'=\max(l,r)$。

显然当 $k \in [1,l']$ 时，当前这一维有两种选择，$k\in(l',r']$ 时，当前一维只有一种选择。如果 $k>r'$，无解。

我们这时候先考虑在哪些点能取到两种取值，这时候，关注到 $l'$ 是一个临界点，我们按照 $l'$ 排序来考虑。

对于每个临界而言，能取到两种取值的点数量每次减一，对于这一段的 $k$，简单排列组合计算即可。

最后特殊考虑最后一个位置 $k\in(l',r']$ 即可，以及注意 $k$ 的上界，是 $\max(r')$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
const int mod=1e9+7;
#define int long long 
int c[N],m[N],a[N],n,Minn=LLONG_MAX;
int Quickpow(int a,int b){
	int ans=1,now=a;
	while(b>0){
		if(b&1)	ans*=now,ans%=mod;
		now=(now%mod*now%mod)%mod,b>>=1,now%=mod;
	}
	return ans;
}
signed main(){
//	freopen("hole7.in","r",stdin);
//	freopen("ans.out","w",stdout);
	cin>>n;
	for(int i=i=1;i<=n;i++)	cin>>m[i];
	for(int i=1;i<=n;i++){
		cin>>a[i];
		c[i]=min(a[i]-1,abs(m[i]-a[i]));	
		int now=a[i]-1,now1=abs(m[i]-a[i]);
		Minn=min(Minn,max(now,now1));
	} 
	int lst=n,L=1,sum=1,ans=1; c[0]=-1;
 	sort(c+1,c+n+1);
	for(int i=1;i<=n;i++){
		if(L>Minn)	break;
		int now=min(Minn,c[i]),len=now-L+1;
		ans+=(len%mod*Quickpow(2,lst)%mod)%mod,ans%=mod,L=min(Minn,c[i])+1;
		lst--;
	}
	cout<<(ans%mod+(Minn-L+1)%mod)%mod<<endl;
}
// 0? 
```

---


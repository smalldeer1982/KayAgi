# [GESP202412 六级] 运送物资

## 题目描述

小杨管理着 $m$ 辆货车，每辆货车每天需要向 A 市和 B 市运送若干次物资。小杨同时拥有 $n$ 个运输站点，这些站点位于 A 市和 B 市之间。

每次运送物资时，货车从初始运输站点出发，前往 A 市或 B 市，之后返回初始运输站点。A 市、B 市和运输站点的位置可以视作数轴上的三个点，其中 A 市的坐标为 $0$，B 市的坐标为 $x$，运输站点的坐标为 $p$ 且有 $0 \lt p \lt x$。货车每次去 A 市运送物资的总行驶路程为 $2p$，去 B 市运送物资的总行驶路程为 $2(x - p)$。

对于第 $i$ 个运输站点，其位置为 $p_i$ 且至多作为 $c_i$ 辆车的初始运输站点。小杨想知道，在最优分配每辆货车的初始运输站点的情况下，所有货车每天的最短总行驶路程是多少。

## 说明/提示

第 $1$ 辆车的初始运输站点为站点 $3$，第 $2$ 辆车的初始运输站点为站点 $2$。第 $3$ 辆车的初始运输站点为站点 $1$，第 $4$ 辆车的初始运输站点为站点 $3$。此时总驶路程最短，为 $40186$。

| 子任务编号 | 数据点占比 |     $n$     |     $s$     |    $c_i$    |
| :--------: | :--------: | :---------: | :---------: | :---------: |
|    $1$     |   $20\%$   |     $2$     |     $2$     |     $1$     |
|    $2$     |   $20\%$   | $\leq 10^5$ | $\leq 10^5$ |     $1$     |
|    $3$     |   $60\%$   | $\leq 10^5$ | $\leq 10^5$ | $\leq 10^5$ |

对于全部数据，保证有 $1\leq n,m\leq 10^5$，$2\leq x\leq 10^8$，$0\lt p_i\lt x$，$1\leq c_i\leq 10^5$，$0\leq a_i,b_i\leq 10^5$。数据保证 $\sum c_i\geq m$。

## 样例 #1

### 输入

```
3 4 10
1 1
2 1
8 3
5 3
7 2
9 0
1 10000```

### 输出

```
40186```

# 题解

## 作者：tomAmy (赞：84)

个人觉得是一道比较难的黄题。

凭直觉来讲：

1. 按 $p_j$ 从小到大对点排序。

2. 对 $a_i \ge b_i$ 的货车**排序**，依次匹配 $p_j$ 小的点。

3. 对 $a_i < b_i$ 的货车**排序**，依次匹配 $p_j$ 大的点。

那么怎么对货车排序呢？

~~我好弱啊，看了题解才明白。~~

我们要对比同样的增减幅度下，哪个收益更大，就该配更大的增幅。

考虑货车 $x$ 与点 $u, v$：

若将货车 $x$ 分配给点 $u$，则行驶路程为 $2 a_x p_u + 2 b_x (X - p_u)$。

若将货车 $x$ 分配给点 $v$，则行驶路程为 $2 a_x p_v + 2 b_x (X - p_v)$。

$u \to v$，收益为 

$$\begin{aligned} &\quad(2 a_x p_u + 2 b_x (X - p_u)) - (2 a_x p_v + 2 b_x (X - p_v))\\&= 2(a_x p_u + b_x (X - p_u) - a_x p_v - b_x (X - p_v))\\&= 2(a_x(p_u - p_v) + b_x (X - p_u - X + p_v))\\&=2(a_x(p_u - p_v) - b_x (p_u - p_v))\\&= 2(a_x - b_x)(p_u - p_v)\\&= 2(b_x - a_x)(p_v - p_u)\end{aligned}$$

若 $a_x\ge b_x$，要使收益越大，$a_x - b_x$ 应越大。

若 $a_x < b_x$，要使收益越大，$b_x - a_x$ 应越大。

剩下的就是贪心模拟啦~

代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e5 + 5;

struct Node1
{
	int p, c;
} e[N];

struct Node2
{
	int a, b;
} f[N], g[N];

int cntf, cntg;

bool cmp1(Node1 x, Node1 y)
{
	return x.p < y.p;
}

bool cmp2(Node2 x, Node2 y)
{
	return x.a - x.b > y.a - y.b;
}

bool cmp3(Node2 x, Node2 y)
{
	return x.b - x.a > y.b - y.a;
}

int main()
{
	int n, m, s;
	cin >> n >> m >> s;
	for (int i = 1; i <= n; i++)
		cin >> e[i].p >> e[i].c;
	for (int i = 1; i <= m; i++)
	{
		int x, y;
		cin >> x >> y;
		if (x >= y) f[++cntf] = {x, y};
		else g[++cntg] = {x, y};
	}
	sort(e + 1, e + n + 1, cmp1);
	sort(f + 1, f + cntf + 1, cmp2);
	sort(g + 1, g + cntg + 1, cmp3);
	int now = 1;
	long long ans = 0;
	for (int i = 1; i <= cntf; i++)
	{
		if (e[now].c == 0) now++;
		ans += 2ll * f[i].a * e[now].p + 2ll * f[i].b * (s - e[now].p);
		e[now].c--;
	}
	now = n;
	for (int i = 1; i <= cntg; i++)
	{
		if (e[now].c == 0) now--;
		ans += 2ll * g[i].a * e[now].p + 2ll * g[i].b * (s - e[now].p);
		e[now].c--;
	}
	cout << ans << endl;
	return 0;
}
``````

点个赞再走呗~

---

## 作者：__CJY__ (赞：23)

## 题意简述
有 $n$ 个运输站点和 $m$ 辆货车，货车需从站点出发向 A、B 两市运送物资，并返回站点。要求制定运输计划，最小化所有货车的总行驶路程。
## 思路
1. 首先，我们读取并存储所有运输站点的位置信息 $p_i$ 和可容纳的货车数量 $c_i$。
2. 接着，读取每辆货车的运送需求，即需要向 A 市运送的次数 $a_i$ 和向 B 市运送的次数 $b_i$，并根据 $a_i$ 和 $b_i$ 的比较，将货车分为两类：
   * 一类是去 A 市次数**不少于**去 B 市次数的货车集合 $F$。
   * 另一类是去 B 市次数**多于**去 A 市次数的货车集合 $G$。

   排序过程如下：
   * 对运输站点按照位置 $p_i$ 进行升序排序。
   * 对货车集合 $F$ 按照 $a_i-b_i$ 的降序排序。
   * 对货车集合 $G$ 按照 $b_i-a_i$ 的降序排序。
3. 使用贪心算法来分配货车到运输站点：
   * 对于集合 $F$ 中的货车，从位置较近的运输站点开始分配。
   * 对于集合 $G$ 中的货车，从位置较远的运输站点开始分配。
   * 在分配过程中，确保每个运输站点的可容纳货车数量 $c_i$ 不会被超出。
4. 根据货车的分配情况、运输站点的位置 $p_i$ 以及两市之间的距离 $x$，计算每辆货车的行驶距离，并累加得到总行驶距离 $ans$。对于集合 $F,G$ 中的货车，行驶距离都为 $2\times(a_i \times p_i+b_i\times(x-p_i))$。
5. 最后，输出计算得到的货车总行驶距离 $ans$。

写的有点急，有问题请指出。求赞！

感谢 @[HuangTingFu](/user/1014715) 指出错误。

---

## 作者：chenxi2009 (赞：11)

# 思路
个人认为是六七八级这次最难的一道题。本题解避免使用提高级知识点（优先队列、set、map 等）。

简化只有一辆货车的情况，令其所在的站点坐标为 $p$，它一天的行驶里程为 $2ap+2b(x-p)=2bx+2(a-b)p$。要让里程最小，就要让 $(a-b)p$ 最小。分类讨论：\
若 $a<b$，则选择 $p$ 尽量大的站点；\
若 $a>b$，则选择 $p$ 尽量小的站点；\
若 $a=b$ 则无关紧要，路程恒为 $2x$。

然而，每个站点容纳的货车数量是有限的，怎么决定优先选择哪个货车呢？对于 $a>b$ 的货车、$p$ 尽量小的站点，由于要让 $(a-b)p$ 尽量小，可以贪心地为 $p$ 较小的站点选择 $a-b$ 尽量大的站点，可以证明和 $p$ 较大的站点交换货车不会更优。\
同理，对于 $a<b$ 的货车，优先为 $b-a$ 最大的货车选择 $p$ 较大的站点。

如何实现上述过程？我们可以先按 $p$ 给站点排序，再按 $b-a$ 给货车排序，从前往后和从后往前处理 $a>b$ 和 $a<b$ 即可。排序后可以把站点序列转换为链表，方便在两端站点无使用额度后进行删除。

时间复杂度 $O(n\log n+m\log m)$。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int p,c;
	bool friend operator < (const node &a,const node &b){//站点，按 p 排序 
		return a.p < b.p;
	}
};
struct node2{
	int a,b;
	bool friend operator < (const node2 &a,const node2 &b){//货车，按 a-b 排序 
		return a.a - a.b > b.a - b.b;
	}
};
int n,m,x,head,back;
long long ans;
node stt[100001];
node2 cr[100001];
int main(){
	scanf("%d%d%d",&n,&m,&x);
	for(int i = 1;i <= n;i ++) scanf("%d%d",&stt[i].p,&stt[i].c); 
	for(int i = 1;i <= m;i ++){
		scanf("%d%d",&cr[i].a,&cr[i].b);
		ans += ((long long)cr[i].b * x << 1);//答案中恒有的 2x 一项 
	}
	sort(stt + 1,stt + n + 1);
	sort(cr + 1,cr + m + 1);
	head = 1,back = n;//标记最左和最右可用站点的编号，线性表充当链表 
	for(int i = 1;i <= m && cr[i].a > cr[i].b;i ++){//a>b 的货车 
		int a = cr[i].a,b = cr[i].b; 
		ans += ((long long)(a - b) * stt[head].p << 1);
		if(!(-- stt[head].c)) head ++;//最左边的站点用完了，丢弃 
	}
	for(int i = m;i && cr[i].a < cr[i].b;i --){//a<b 的货车 
		int a = cr[i].a,b = cr[i].b; 
		ans += ((long long)(a - b) * stt[back].p << 1);
		if(!(-- stt[back].c)) back --;
	}
	printf("%lld",ans);
	return 0;
} 
```

---

## 作者：Lcm_simida (赞：9)

## [题目传送门](https://www.luogu.com.cn/problem/P11376)

思路：题意很简单，经过化简我们可以发现单辆车对答案的贡献就是 $b_ip+(a_i-b_i)x$ 了，显然对于 $a_i-b_i$ 为正的优先考虑运输站点坐标小的，否则考虑坐标大的。

## AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,ans=0,l=1,r;
struct node{
	long long x,y;
}a[100005],b[100005];
bool c1(node x,node y){
	return x.x<y.x;
}
bool c2(node x,node y){
	return abs(x.x-x.y)>abs(y.x-y.y);
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;r=n;
	for(long long i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
	for(long long i=1;i<=m;i++) cin>>b[i].x>>b[i].y;
	sort(a+1,a+n+1,c1);sort(b+1,b+m+1,c2);
	for(long long i=1;i<=m;i++){
		if(b[i].x-b[i].y==0){
			ans+=(b[i].y*k);
		}else if(b[i].x-b[i].y>0){
			if(a[l].y<=0) l++;
			ans+=(b[i].y*k+(b[i].x-b[i].y)*a[l].x);
			a[l].y--;
		}else{
			if(a[r].y<=0) r--;
			ans+=(b[i].y*k+(b[i].x-b[i].y)*a[r].x);
			a[r].y--;
		}
	}
	cout<<ans*2;
	return 0;
}

```

---

## 作者：Bh_hurter (赞：7)

# P11376 题解
[题目传送门](https://www.luogu.com.cn/problem/P11376)
### 题意分析
题意很简单，要把 $m$ 辆车放到 $n$ 个车站中，其中每个车站 $p$ 在 $p_i$ 的位置，可以存下 $c_i$ 辆车。目标是找到一种方案，使得所有的车送完物资后总行驶里程最小。

不难想到，一辆车每往 $A$ 地和 $B$ 地各送一次物资，路程 $S=2 \times p+2 \times (x-p) =2 \times (p+x-p) =2 \times x$ ，即走了两趟全程。所以不管这辆车的起始站在哪里，每往 $A$ 地和 $B$ 地各送一次物资，路程都是 $2$ 倍的全程。

不免想到**贪心**。既然一辆车每往 $A$ 地和 $B$ 地各送一次物资，路程都是 $2$ 倍的全程，那么这辆车至少会走 $ a_i$ 和 $b_i $ 中较小的那个倍数的全程。所以只用考虑 $a_i$ 或 $b_i$ 多出来的部分就行了。

先把所有站点排个序，然后将 $a_i$ 大的车从离 $A$ 地最近的站点开始放，每次先放当前 $a_i-b_i$ 最大的车。同样从离 $B$ 地最近的车站开始放 $b_i$ 大的车，每次先放当前 $b_i-a_i$ 最大的车。可以在输入时将这两种车分开存，处理更加方便。  
###  AC Code
下面是本人考场代码，给大家献丑了。

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define ll long long
const int N=1e5;
struct node {
	int a,b;
}cara[N+5],carb[N+5];//cara存a[i]较大的车，carb存b[i]较大的车
struct point {
	int p,c;
}st[N+5];//每个车站信息
int n,m,px;
int cnta=0,cntb=0;
ll ans=0;
bool cmp(node x,node y) {
	return abs(x.a-x.b)<abs(y.a-y.b);
}
bool cmq(point x,point y) {
	return x.p<y.p;
}
int main() {
	cin>>n>>m>>px;
	for(int i=1; i<=n; i++) {
		cin>>st[i].p>>st[i].c;
	}
	sort(st+1,st+1+n,cmq);
	for(int i=1; i<=m; i++) {
		int x,y;
		cin>>x>>y;
		if(x>=y) cara[++cnta].a=x,cara[cnta].b=y;
		else carb[++cntb].a=x,carb[cntb].b=y;
	}
	sort(cara+1,cara+1+cnta,cmp);//采用倒着排序，后面每次放完一辆车后只需cnta--便可删除这个车
	sort(carb+1,carb+1+cntb,cmp);//同理
	int l=1,r=n;
	while(cnta>0) {
		if(cnta<st[l].c) {//小心下表越界
			while(cnta>0) {
				ans=ans+2ll*cara[cnta].a*st[l].p+2ll*cara[cnta].b*(px-st[l].p);
				cnta--;//放完这辆车了，删掉
			}
		} else {
			for(int i=1; i<=st[l].c; i++) {
				ans=ans+2ll*cara[cnta].a*st[l].p+2ll*cara[cnta].b*(px-st[l].p);//计算答案
				cnta--;//放完这辆车了，删掉
			}
			l++;//下一车站
		}
	}
	while(cntb>0) {
		if(cntb<st[r].c) {//小心下表越界
			while(cntb>0) {
				ans=ans+2ll*carb[cntb].a*st[r].p+2ll*carb[cntb].b*(px-st[r].p);
				cntb--;//放完这辆车了，删掉
			}
		} else {
			for(int i=1; i<=st[r].c; i++) {
				ans=ans+2ll*carb[cntb].a*st[r].p+2ll*carb[cntb].b*(px-st[r].p);//计算答案
				cntb--;//放完这辆车了，删掉
			}
			r--;//下一车站
		}

	}
	cout<<ans;//输出
	return 0;
}
```

---

## 作者：xinxin2022 (赞：5)

简单题。

考虑贪心，显然去 A 市多的车的起始点尽量靠左，去 B 市多的车起点尽量靠右。

那么将起始点升序排序，车按照 $a-b$ 升序排序，令去 A 地次数多的车从左向右分配起始点，令去 B 地次数多的车从右向左分配起点。

若次数相等，则起始点在哪里行驶距离都一样，无需特殊处理。

代码如下：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,x,ans,cnt;
struct node{
    int a,b;
}car[100005];
struct node2{
    int p,c;
}station[100005];
bool cmp(node2 x,node2 y){
    return x.p<y.p;
}bool cmp2(node x,node y){
    return x.a-x.b>y.a-y.b;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>m>>x;
    for(int i=1;i<=n;i++) cin>>station[i].p>>station[i].c;
    for(int i=1;i<=m;i++) cin>>car[i].a>>car[i].b;
    sort(station+1,station+1+n,cmp);
    sort(car+1,car+1+m,cmp2);
    //处理去A地次数多的车
    for(int i=1,j=1;car[i].a>=car[i].b;i++){
        if(cnt==station[j].c){
            cnt=0;
            j++;
        }
        ans+=2*car[i].a*station[j].p+2*car[i].b*(x-station[j].p);
        cnt++;
    }
    cnt=0;
    //处理去B地次数多的车
    for(int i=m,j=n;car[i].a<car[i].b;i--){
        if(cnt==station[j].c){
            cnt=0;
            j--;
        }
        ans+=2*car[i].a*station[j].p+2*car[i].b*(x-station[j].p);
        cnt++;
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：hsyAKIOI (赞：5)

# P11376[GESP202412 六级] 运送物资题解
## 题目大意
有 $A,B$ 两点，可看为**数轴**。$A$ 在 $0$ 点，$B$ 在 $x$ 点。现有 $m$ 辆货车，第 $i$ 个去 $A\ a_i$ 次，去 $B\ b_i$ 次。现有 $n$ 个站点，每个站点位置为 $p_i(0 < p_i < x)$，可以为 $c_i$ 辆车的起点，则从这到 $A$ 为 **$2p_i$**，到 $B$ 为 **$2(x-p_i)$**。问如何安排，使得每辆车路程**总和最小**？
## 题目分析
本人在考场上首先把 **DP** 的状态定义全部想了一遍，发现根本没有适合的，于是我们可以从那**两个式子**入手，我们代入推一下，可以直接得到 $ 2·p_i·(a_i-b_i)+2 ·b_i ·x$。

得到这个式子是不是就豁然开朗了，对于一个 $2 ·b_i·x$ 是一定的，可以**直接加上去**。

而 $2·p_i·(a_i-b_i)$，可以考虑 $p_i$ 与 $2(a_i-b_i)$ 的**配对问题**，分类讨论:
- 对于一个正数 $(a_i-b_i)$，我们越大 $2(a_i-b_i)$ 的配越小的 $p_i$，这样则在**正数范围内最优**。
- 而负数，则越小的 $2(a_i-b_i)$ 配越大的 $p_i$，这样可以把负数发挥到最大，**在负数范围内最优**。

而对于这个大小问题，用**结构体排个序**就可以了，而这也是个**贪心问题**，**贪最小值**，分类讨论下，一定是最优的，结束！
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e5 + 10;
int n, m;
ll x;
vector<pair<int, int> > st;
int a[N], b[N];

int main() {
	cin >> n >> m >> x;
	for (int i = 1; i <= n; i++) {
		int p, c;
		cin >> p >> c;
		st.push_back(make_pair(p, c));
	}
	sort(st.begin(), st.end());
	for (int i = 1; i <= m; i++) {
		cin >> a[i] >> b[i];
	}
	vector<pair<int, int> > neg, pos;
	ll res = 0;
	for (int i = 1; i <= m; i++) {
		if (a[i] >= b[i])
			pos.push_back(make_pair(a[i] - b[i], i));
		else {
			neg.push_back(make_pair(a[i] - b[i], i));
		}
		res += 1ll * b[i] * x;
	}
	sort(neg.begin(), neg.end());
	sort(pos.begin(), pos.end());
	reverse(pos.begin(), pos.end());
	int l = 0, r = n - 1;
	for (auto i : neg) {
		while (r >= 1 && st[r].second == 0)
			r--;
		res += 1ll * (a[i.second] - b[i.second]) * st[r].first;
		st[r].second -= 1;
	}
	for (auto i : pos) {
		while (l <= n && st[l].second == 0)
			l++;
		res += 1ll * (a[i.second] - b[i.second]) * st[l].first;
		st[l].second -= 1;
	}
	cout << res * 2 << "\n";
}

//代码来源于GESP官网
```

---

## 作者：N0_1 (赞：4)

### 说明：
读题后分析易知，原题可以转换为求该表达式的最小值
$$\sum 2x_ia_i + 2(p-x_i)b_i$$
其中 $x_i$ 表示第 $i$ 个站点的位置， $p$ 表示两市之间的距离， $a_i$ 和 $b_i$ 见题目。

对该表达式化简可得
$$2 \times \sum (pb_i + x_i(a_i-b_i))$$
$$= 2\times \sum (pb_i + x_i(a_i-b_i))$$
$$= 2 \times \sum pb_i + 2\times \sum x_i(a_i-b_i)$$

其中 $2 \times \sum pb_i$ 为定值，原题转化为求 $\sum x_i(a_i-b_i)$ 的最小值，令 $dif_i$ 表示 $a_i - b_i$，
即求 $\sum x_idif_i$。根据初中数学知识，不难知道当最小 $dif_i$ 与最大的 $x_i$ 配对时，$\sum x_idif_i$ 为最小值。

![题目样例图解](https://cdn.luogu.com.cn/upload/image_hosting/zhtw8a6y.png)

注意 `code` 的时候 $x_i$ 有数量限制。

### code

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

typedef long long LL;

struct node {
    int x, num;
};
struct car {
    int a, b;
};
node a[N];
car b[N];

LL x[N], dif[N];

int main() {
    int n, m;
    LL p;
    cin >> n >> m >> p;
    for (int i = 1; i <= n; i++) cin >> a[i].x >> a[i].num;
    for (int i = 1; i <= m; i++) cin >> b[i].a >> b[i].b, dif[i] = b[i].a - b[i].b;
    
    sort(a + 1, a + n + 1, [](node t, node f) {
        return t.x < f.x;
    });
	sort(dif + 1, dif + m + 1);

    int tpl = 1, tpr = n, dol = 1, dor = m;
    LL sum = 0;

    while (dol <= m && dif[dol] < 0) {
        if (a[tpr].num > 0) {
            sum += dif[dol] * a[tpr].x;
            dol ++;
            a[tpr].num --;
        } else {
            tpr --;
        }
    }
    
    while (dor >= dol) {
        if (a[tpl].num > 0) {
            sum += dif[dor] * a[tpl].x;
            dor --;
            a[tpl].num --;
        } else {
            tpl ++;
        }
    }
    sum *= 2;
    for (int i = 1; i <= m; i++) {
        sum += 2 * p * b[i].b;
    }

    cout << sum << '\n';
    // system("pause");
    return 0;
}
```

---


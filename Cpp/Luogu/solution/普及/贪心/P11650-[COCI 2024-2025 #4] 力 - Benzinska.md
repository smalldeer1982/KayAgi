# [COCI 2024/2025 #4] 力 / Benzinska

## 题目背景

译自 [COCI 2024/2025 #4](https://hsin.hr/coci/) T2。$\texttt{1s,0.5G}$。满分为 $70$。


## 题目描述


在数轴上，Malnar 从原点（$x=0$）出发，前往 $x=X$ 处。

Malnar 初始有 $D$ 单位能量，每走一个单位长度消耗一单位能量。在整个过程中，能量必须**不小于** $0$。

有 $n$ 个餐馆，第 $i$ 个餐馆位于 $x=x_i$ 处，在第 $i$ 个餐馆用餐可以使能量增加 $y_i$。**至多只能在每个餐馆用一次餐，且不同餐馆的 $x_i$ 可能相同。**

求出为了达成目标，至少需要在多少个餐馆用餐。

## 说明/提示


#### 样例解释

样例 $1$ 解释：在第 $1,2,4$ 个餐馆用餐。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le n\le 2\times 10^5$；
- $1\le D,X,y_i\le 10^9$；
- $1\le x_i\lt X$。


| 子任务编号 | $n\le$ |  特殊性质 | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $2\times 10^5$ |  A   |   $ 15 $   |  
| $ 2 $    | $10^3$ |   |  $ 30 $   |  
| $ 3 $    | $2\times 10^5$  |  | $ 25 $   |

- 特殊性质 A：$y_i$ 全相等。



## 样例 #1

### 输入

```
5 5 12
3 4 7 8 11
3 2 1 2 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5 10 40
1 20 30 2 38
7 7 7 7 7```

### 输出

```
5```

## 样例 #3

### 输入

```
4 5 12
3 6 9 10
2 1 2 2```

### 输出

```
-1```

# 题解

## 作者：Night_sea_64 (赞：7)

首先我们发现，走到某一个餐馆就直接决定是否用餐是不现实，因为不好预测后面的情况。所以能拖着就拖着，等到没能量了再去选择之前的餐馆。

而选择之前的餐馆时，餐馆位置就没用了，直接选择能量补充最多的。优先队列维护即可。

时间复杂度 $O(n\log n)$。

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#define int long long
using namespace std;
int n,d,t;
struct node{int x,y;}a[200010];
bool cmp(const node &x,const node &y){
    return x.x<y.x;
}
priority_queue<int>q;
signed main()
{
    cin>>n>>d>>t;
    for(int i=1;i<=n;i++)cin>>a[i].x;
    for(int i=1;i<=n;i++)cin>>a[i].y;
    sort(a+1,a+n+1,cmp);
    a[++n]=(node){t,0};
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        d-=a[i].x-a[i-1].x;
        while(!q.empty()&&d<0)
        {
            d+=q.top(),cnt++;
            q.pop();
        }
        if(d<0)
        {
            cout<<-1<<endl;
            return 0;
        }
        q.push(a[i].y);
    }
    cout<<cnt<<endl;
    return 0;
}
```

---

## 作者：FamousKillerconan (赞：6)

## 前言
第不知道几次场切黄题，发个题解纪念一下。
## 前置知识（STL 库）
### 优先队列（堆）
优先队列在定义时默认为大根堆，也就是大的往前放。小根堆则相反，也就是小的靠前。
### 二元结构体
二元结构体指定好类型，它就像只有两个元素结构体一样，更重要的是它排序默认按第一个从小到大排。
## 思路
首先，对这些餐馆进行排序（按位置排序），然后，从起点出发，找下一个落脚点（可能是终点），若能力气大于现在地点与落脚点的距离就放进优先队列（大根堆），这时使用贪心算法，让能量大的靠前，这样就可以走更远的路，如果到不了落脚点且优先队列为空，那就说明到不了。注意有可能一个位置里有多个餐馆，所以要用循环进行进队。不过要确定是哪一个餐馆也很简单，搞一个指针来，进队时往右移动。


AC 代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define PII pair<int,int>
using namespace std;
const int N=2e5+5;
const int INF=0x3f3f3f3f;
const double EPS=1e-6;
ll n,m,s,ans;
PII a[N];
void solve(){
	cin>>n>>m>>s;
	for(int i=1;i<=n;i++)cin>>a[i].first;
	for(int i=1;i<=n;i++)cin>>a[i].second;
	sort(a+1,a+n+1);//使用pair的好处
	priority_queue<int>que;
	ll now=0,power=m,pos=1;
	while(now<s){
		ll nxt=s;
		if(pos<=n)nxt=a[pos].first;//还有餐馆
		if(nxt-now>power){//力气不够了
			if(que.empty()){//没饭馆了
				cout<<-1;
				return;
			}
			power+=que.top();
			que.pop();
			ans++;//需要干饭
		}else{
			power-=nxt-now;//力气还有多
			now=nxt;
			while(pos<=n&&a[pos].first==now){
				que.push(a[pos].second);
				pos++;
			}//防止有多个餐馆在同一个位置
		}
	}
	cout<<ans;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int T=1;
//	cin>>T;
	while(T--)solve();//别学我这么写，我这是为了应付多组测试
	return 0;
}
```

---

## 作者：Aron_2023 (赞：3)

## 前言

一看就是贪心，想到了 [P9749 [CSP-J 2023] 公路](https://www.luogu.com.cn/problem/P9749) ，异曲同工之妙啊。

## 分析
### 算法
贪心策略：每次在能量不足时，从已到达的餐馆中选择能量最大的进行用餐，最小化总用餐次数。

反证贪心，假设存在一个最优解，其中某一步未选择当前最大的能量 $y_{max}$ ，而选择了较小的 $y_{min}$ 。由于 $y_{max}>y_{min}$ ，选择 $y_{max}$ 能提供更多能量，可能减少后续的用餐次数。因此，原解可以替换为选择 $y_{max}$ ，且替换后的解不会更差，与原假设矛盾。

综上，最优解中每一步的选择必然是当前可用的最大补充量，贪心成立。

### 具体实现
先把餐馆按位置 $x_i$ 升序排序。然后使用优先队列维护可用的能量。若当前能量不足，从堆中取出最大补充量进行用餐，直到能量足够或堆为空。

若堆为空仍无法满足能量需求，则无解。

时间复杂度：$O(n \log n)$ ，可以通过本题。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+7;
int n,d,X,ans;
priority_queue<int> pq; //优先队列维护可用的能量增量
struct node 
{
    int x,y;
}a[maxn];
bool cmp(node a,node b) //按位置 x 升序排序
{
    return a.x<b.x;
}
int main() 
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    cin>>n>>d>>X;
    int sum=d,pos=0; //sum记录当前能量  pos记录当前位置 
    for(int i=1;i<=n;i++) cin>>a[i].x;
    for(int i=1;i<=n;i++) cin>>a[i].y;
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++) 
	{
        int dis=a[i].x-pos;
        if(sum<dis) 
		{
            //能量不足时
            while(!pq.empty()&&sum<dis) 
			{
                sum+=pq.top();
                pq.pop();
                ans++;
            }
            if(sum<dis) 
			{
                //无解
                cout << -1 << endl;
                return 0;
            }
        }
        sum -= dis;
        pos = a[i].x;
        pq.push(a[i].y);
    }
    //处理从最后一个餐馆到终点的距离
    int dis=X-pos;
    if(sum<dis) 
	{
		//同上 
        while(!pq.empty()&&sum<dis) 
		{
            sum+=pq.top();
            pq.pop();
            ans++;
        }
        if(sum<dis) 
		{
			//同上
            cout<<-1;
            return 0;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：huangguoguo (赞：3)

### 贪心+优先队列



思路：

首先将所有餐馆按照位置从小到大排序。

对于每个餐馆，计算从当前位置到该餐馆所需的能量，如果当前能量不足以到达该餐馆，则需要选择之前未用餐的餐馆中能量增益最大的进行用餐。

更新当前能量和用餐次数后继续前进到下一个餐馆。

```c++
#include <bits/stdc++.h>
using namespace std;
const int MAX=2e5+5;
struct node {
	int pos, v;
} nodes[MAX];
priority_queue<int> pq;

bool cmp(node a, node b) {
	return a.pos < b.pos;
}
int main() {
	int n, d, dis, p=0, ans=0;
	cin >> n >> d >> dis;
	for(int i=1; i <= n; i++) cin >> nodes[i].pos;
	for(int i=1; i <= n; i++) cin >> nodes[i].v;
	n++, nodes[n].pos=dis;
	sort(nodes+1, nodes+n+1, cmp);
	for(int i=1; i <= n; i++) {
		int need=nodes[i].pos-p;
		while(d-need < 0) {
			if(pq.empty()) {
				cout << -1;
				return 0;
			}
			ans++;
			d+=pq.top();
			pq.pop();
		}
		d-=need;
		p=nodes[i].pos;
		pq.push(nodes[i].v);	
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Hcx2013 (赞：2)

## 题意

找到一种方法，并且在某些餐馆用餐，使 Malnar 能从原点到终点。求最少的用餐次数，如果无法到达，输出 $-1$。

## 解法

很明显是贪心。

如果在能量不足以支撑到下一个餐馆时，我们可以选择在前面经过的餐馆中能提供能量最大的餐馆，这样走的距离更远，用餐次数也就减少了。

这么简单的题还是放一下代码吧。

## Code


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,D,X;
struct node{
	int a,b;
}r[200005];
bool cmp(node a,node b){
	return a.a<b.a;
}
int main(){
    cin>>n>>D>>X;
    for(int i=1;i<=n;i++)cin>>r[i].a;
    for(int i=1;i<=n;i++)cin>>r[i].b;
    sort(r+1,r+1+n,cmp);//排序
    int c=D;
    int pos=0;
    int m=0;
    priority_queue<int>w;//大根堆
    for(int i=1;i<=n;i++){
        int x=r[i].a;
        int y=r[i].b;
        int dist=x-pos;
        //如果能量不足，需要加餐
        while(c<dist&&!w.empty()){
            c+=w.top();
            w.pop();
            m++;
        }
        //如果仍然能量不足，无法到达,输出-1，结束
        if (c<dist){
            cout<<-1<<endl;
            return 0;
        }
        c-=dist;
        pos=x;
        //放入优先队列
        w.push(y);
    }
    //是否能到达终点
    int dist=X-pos;
    while(c<dist&&!w.empty()){
        c+=w.top();
        w.pop();
        m++;
    }
    if (c>=dist){
        cout<<m<<endl;
    }else{
        cout<<-1<<endl;
    }
    return 0;
}
```

---

## 作者：shiyilang0910 (赞：2)

## 题目意思
要我们找到一种方法，确定在哪些餐馆用餐，以确保 Malnar 能够从起点到达终点，并且在整个过程中能量不会低于零，问最少需要用餐的餐馆数量，如果无法到达终点，则输出 $$-1$$。
## 思路
本题主要考察点是贪心，在可以走到的餐馆中优先选择能量最大的，这样走的距离更远，用餐数量自然就少了，数据结构可以使用优先队列的大根堆。\
具体步骤：
1. 按照餐馆的位置从小到大排序。
2. 在每一步，我们检查当前的能量是否足够到达下一个餐馆或终点，如果不能到达任何一个餐馆，说明不能到达，如果当前的能量能到终点，那么直接输出答案。
3. 如果能量不足，我们需要在当前位置加餐，增加能量。
\
\
其他注意点在下面代码中写了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,D,X;
struct node{
	int a,b;
}r[200005];
bool cmp(node a,node b){
	return a.a<b.a;
}
int main(){
    cin>>n>>D>>X;
    for(int i=1;i<=n;i++){
        cin>>r[i].a;
    }
    for(int i=1;i<=n;i++){
        cin>>r[i].b;
    }
    sort(r+1,r+1+n,cmp);//排序
    int c=D;
    int pos=0;
    int m=0;
    priority_queue<int>w;//优先队列默认为大根堆
    for(int i=1;i<=n;i++){//枚举所有餐馆
        int xi=r[i].a;
        int yi=r[i].b;
        //计算到下一个餐馆的距离
        int dis=xi-pos;
        //如果能量不足，需要加餐
        while(c<dis&&!w.empty()){
            c+=w.top();
            w.pop();
            m++;
        }
        //如果仍然能量不足，无法到达,输出-1，结束
        if (c<dis){
            cout<<-1<<endl;
            return 0;
        }
        //消耗能量到达下一个餐馆,更新位置
        c-=dis;
        pos=xi;
        //将当前餐馆的能量增量放入优先队列
        w.push(yi);
    }
    //最后检查是否能到达终点
    int dis=X-pos;
    while(c<dis&&!w.empty()){
        c+=w.top();
        w.pop();
        m++;
    }
    if (c>=dis){
        cout<<m<<endl;
    }else{
    	//不能到，输出-1
        cout<<-1<<endl;
    }
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/201125330)

---

## 作者：canwen (赞：2)

注意到值域如此大，放弃动态规划。

## 思路
可以算有点新奇的思路吧。

我们可以考虑样例一，一开始从 $0$ 出发，以初始的体力 $5$ 可以到达 $5$，那么我们选择跳到比 $5$ 还大的**有餐馆**位置 $7$，此时需要额外的 $2$ 点体力。

那么我在 $1$ 到 $6$ 有餐馆的位置中（也就是 $3$ 和 $4$）贪心，直到体力足够，如果全部餐馆的贡献都用了还是没到达要的体力，那么无解。

接下来还有边界的判断，当我走完全部的商店后，我将剩存的体力加上去后如果位置仍然小于 $X$，那么同样地不断贪心，判有无解。

这样做即可保证最优。

先对所有商店的位置和对应的贡献先排序处理。

二分找到第一个以当前体力不能够到达的商店位置。

这里笔者用大根堆维护贪心选取。

## Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define _rep(i,a,b) for(int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for(int i=(a);i<=(b);c)
#define _rrep(i,a,b) for(int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for(int i=(a);i>=(b);c)
#define _graph(i) for(int i=head[u];i;i=e[i].nxt)
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define pb push_back
#define mk make_pair
#define fst first
#define snd second
#define pc putchar('\n')
int in(){
	int k=0,kk=1;char a=getchar();
	while(!isdigit(a)){
		if(a=='-') kk=-1;
		a=getchar();
	}
	while(isdigit(a))
		k=(k<<3)+(k<<1)+a-'0',a=getchar();
	return k*kk;
}
void out(int a){
	if(a<0) putchar('-'),a=-a;
	if(a>9) out(a/10);
	putchar('0'+a%10);
}
const int N = 2e5 + 5;
int n,D,X,cnt,num[N];
struct node{
	int id,x;
}e[N];
bool cmp(node a, node b){ 
	if(a.id == b.id) return a.x < b.x; // 商店位置相同的话 --> 贪心先选取贡献大的 
	return a.id < b.id; // 位置第一关键字 
}
priority_queue <int> q;
signed main(){
	n=in(), D=in(), X=in();
	_rep(i,1,n) e[i].id = in();
	_rep(i,1,n){
		e[i].x = in();
	}
	sort(e+1,e+1+n,cmp);
	_rep(i,1,n) num[i] = e[i].id; // 这里处理一下二分数组 
	int _id = 1; // 值域比较大，记录当前丢进大根堆的初始位置 
	int p = 0;
	while(p<X){
		int k = upper_bound(num+1,num+1+n,p+D)-num; // 豪！二分！ 
		_rep(i,_id,k-1) q.push(e[i].x); // 丢进大根堆！ 
		_id = k;
		while(D<num[k]-p){
			if(q.empty()){
				puts("-1");
				return 0;
			}
			D += q.top(), ++cnt; // 豪！贪心！ 
			q.pop(); 
		}
		D -= num[k]-p;
		p = num[k];
		if(_id == n+1){
			// 好！边界 
			p += D;
			while(p<X){
				if(q.empty()){
					puts("-1");
					return 0;
				}
				p += q.top(), q.pop(), ++cnt;
			}
			break;
		}
	}
	if(p >= X) cout << cnt, pc; // 跳出去了！ 
	else puts("-1"); // 无解 
	return 0;
}
// code by canwen
```

---

## 作者：Sheep_YCH (赞：2)

## 洛谷 P11650

[题目传送门](https://www.luogu.com.cn/problem/P11650)

## 题目大意

题目已经说得很清楚了qwq，注意能量不能小于 $0$ 就行。

## 题目分析

1. **贪心算法**：由于每走一步都消耗能量，而餐馆能提供能量恢复，所以我们希望能够在需要的时候找到一个能恢复最多能量的餐馆。可以考虑用贪心策略，在能量不足时选择能恢复最多能量的餐馆。
2. **模拟过程**：
   - 先从 $x = 0$ 开始，依次考虑每个餐馆。
   - 如果当前能量不足以走到下一个餐馆，则选择已经过的且能恢复最多能量的餐馆。
   - 每次走到一个餐馆后，更新当前位置，并将此餐馆的能量记录下来，直到最终到达 $X$。
3. **具体步骤**：
   - 将餐馆按位置排序，模拟从 $x=0$ 开始前进的过程。
   - 使用一个大根堆（优先队列）来记录已经过的餐馆，然后遇到能量不够无法继续前进时不断取出堆顶（优先选择增加能量最多的餐馆）直到能量足够。
   - 如果过程中能量不够（即将每一个餐馆的能量都加上也不够）无法继续前进，说明无法到达目标，输出 $-1$。

## Code

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
#define ll long long
using namespace std;
const int MAXN = 1e6 + 5;
int n, D, X;
struct Node {
	int x, y;
}R[MAXN];

bool cmp(const Node &a, const Node &b) {
	return a.x < b.x;
}

int main() {

	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n >> D >> X;
	for(int i = 1; i <= n; i ++) cin >> R[i].x;
	for(int i = 1; i <= n; i ++) cin >> R[i].y;
	sort(R + 1, R + n + 1, cmp); //先按照 x 坐标排序
	priority_queue<int> Q;
	int ans = 0;
	for(int i = 1; i <= n; i ++) {
		int len = R[i].x - R[i - 1].x; //计算目前位置到下一个餐馆的距离
		if(D < len) {
			while(!Q.empty() && D < len) {
				D += Q.top();
				Q.pop();
				ans ++;
			}
		}
		if(D < len) { //如果不够就输出-1
			cout << -1;
			return 0;
		}
		Q.push(R[i].y);
		D -= len;
	}
	int len = X - R[n].x;
	while(D < len && !Q.empty()) {
		D += Q.top();
		Q.pop();
		ans ++;
	}
	if(D < len) {
		cout << -1;
		return 0;
	}
	cout << ans;
	
	return 0;

}
```

### 注意点

题目中明确给出 $1 \le x_i < X$。

~~完结散花o(*￣▽￣*)ブ~~

---

## 作者：ZLBh (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P11650)
## 思路
由题易得，本题旨在考察贪心。  
我们可以先将餐馆按位置排序，再考虑餐馆，为了尽少用餐，从原点开始，先不断前行，当能量不足时，在经过的路程中找能量最多的餐馆用餐，从而减少用餐次数。当无法到达目标或行走过程中能量不足且没有可用的餐馆时，输出 -1。
## AC Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 10;
// 定义结构体 s 存储每个餐馆的信息
struct s {
    int x;// 餐馆在数轴上的位置
    int y;// 在该餐馆用餐可增加的能量
} a[maxn];
int n;      // 餐馆的数量
int d;      // 初始拥有的能量
int x;      // 目标位置
int e;      // 当前拥有的能量
int p;      // 当前所在的位置
int c;      // 用餐的次数
// 优先队列，用于存储已经经过的餐馆的能量增加量，默认是大顶堆
priority_queue<int> q;
// 自定义比较函数，用于对餐馆按位置从小到大排序
bool cmp(const s& m, const s& k) {
    return m.x < k.x;
}
int main() {
    // 读取输入，n 为餐馆数量，d 为初始能量，x 为目标位置
    cin >> n >> d >> x;
    // 读取每个餐馆的位置
    for (int i = 0; i < n; i++) cin >> a[i].x;
    // 读取每个餐馆用餐可增加的能量
    for (int i = 0; i < n; i++) cin >> a[i].y;
    // 对餐馆按位置进行排序，以便后续按顺序处理
    sort(a, a + n, cmp);
    // 初始化当前能量为初始能量
    e = d;
    // 初始化当前位置为原点（0）
    p = 0;
    // 初始化用餐次数为 0
    c = 0;
    // 用于遍历餐馆数组的索引
    int j = 0;
    // 当当前位置小于目标位置时，继续循环
    while (p < x) {
        // 当还有餐馆未处理，且当前能量足够走到下一个餐馆时
        while (j < n && e >= a[j].x - p) {
            // 将该餐馆用餐可增加的能量加入优先队列
            q.push(a[j].y);
            // 移动到下一个餐馆
            j++;
        }
        // 如果当前能量足够直接到达目标位置，跳出循环
        if (e >= x - p) break;
        // 如果优先队列为空，说明没有可用的餐馆补充能量，无法到达目标位置
        if (q.empty()) {
            cout << -1;
            return 0;
        }
        // 从优先队列中取出能量增加量最大的餐馆，补充能量
        e += q.top();
        // 移除优先队列顶部元素
        q.pop();
        // 用餐次数加 1
        c++;
    }
    // 输出最少用餐次数
    cout << c;
    return 0;
}
```

---

## 作者：sbh2012 (赞：1)

## 思路
明显的贪心，我们并非要到某个餐厅时，就决定要不要吃饭。我们可以先存起来，等到了没有体力去下一个餐厅时再吃，那怎么判断吃那个餐厅呢？很明显，吃补的体力最大的餐厅是最优的，就算超过了去下一个餐厅所需的体力，也可以后面再用，假如存起的所有餐厅都被吃完了，还是到不了下一个餐厅，那就肯定到不了终点了。既然要先吃补充体力最多的餐厅，那就用优先队列来存。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct my{
	int x,y;
	bool operator>(const my&z)const{
		return y>z.y;
	}
	bool operator<(const my&z)const{
		return y<z.y;
	}
}a[200005];
bool cmp(my x,my y){
	return x.x<y.x;
}
int sum;
priority_queue<my> q;
int main(){ 
	int n,d;
	cin>>n>>d;
	cin>>a[n+1].x;
	for(int i=1;i<=n;i++){
		cin>>a[i].x;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i].y;
	}
	a[0].x=0;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n+1;i++){
		while(q.size()!=0&&d<a[i].x-a[i-1].x){//优先吃补充体力最多的餐厅
			d+=q.top().y;
			q.pop();
			sum++;
		}
		if(d<a[i].x-a[i-1].x){//吃完了还到不了，就肯定到不了
			cout<<-1;
			return 0;
		}
		d-=(a[i].x-a[i-1].x);
		q.push(a[i]);//不吃，先存着
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：chzhh_111 (赞：1)

我们可以将题目当中的 Malnar 看作成数轴上的一个点，此时此刻这个点就代表我们所能走的最远的距离是多少。而题目当中在餐厅获取能量的操作可以看作把这个点向正方向推若干个单位长度。

那么现在我们就可以用一个堆去维护我们目前所能用餐的餐厅中，能提供的能量最多的餐厅是哪一个。因为题目当中要求的我们是，如果你能到达的话的最少用餐餐厅的数量，所以既然我们都要使用了，就要使用那个所能贡献的最大的。

那现在我们思路就很明显了：假设现在的位置为 $x$，记 $y_{max}$ 为 $[1,x]$ 这个区间内目前所能用餐餐厅所贡献的最大能量值，则我们现在就使用它，将 $x$ 变成新的 ${x}'$，继续进行这个操作，直到 $x \ge X$ 或者堆为空。

代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+1;
int n,D,X,ans;
struct rest{
	int x,y;
}a[N];
priority_queue<int>q;
bool cmp(rest aa,rest bb) {return aa.x<bb.x;}
int find(int x)//二分查找在餐厅数组里的位置
{
	int l=1,r=n;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(a[mid].x<=x) l=mid+1;
		  else r=mid-1;
	}
	return r;
}
signed main()
{
	scanf("%lld%lld%lld",&n,&D,&X);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i].x);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i].y);
	sort(a+1,a+1+n,cmp);
	int w=D,i=1;
	q.push(0);//给队列一个初始元素，要不然进不了循环
	while(w<X&&q.size())
	{
		int tot=find(w);
		if(tot>=i)
		  for(;i<=tot;i++) q.push(a[i].y);//入堆
		w+=q.top();//右移操作
		q.pop();
		ans++;//统计次数
	}
	if(w>=X) printf("%lld",ans);
	  else printf("-1");
	return 0;
}
```

---

## 作者：dingxiongyue (赞：1)

# 题解：P11650 [COCI 2024/2025 #4] 力 / Benzinska  

## Description：
给出一个长为 $X$ 的一维坐标系，初始拥有 $D$ 单位能量，沿正方向前进一步的代价为 $1$，坐标系中有 $n$ 个餐馆，位置分别在 $x_i$，每个餐馆可补充 $y_i$ 单位能量，求到达终点的最少能量补充次数，如不能到达终点，则输出 $-1$。  

## Analysis：
**考虑贪心**  

$O(n)$ 遍历每个餐馆，如果到达下一个餐馆的代价目前承受不了，则在**之前经过的餐馆中选择未使用过的且 $y_i$ 最大**的进行补充，若**之前经过的所有餐馆**都已使用过，则无法到达终点。  

## Code：
[AC记录](https://www.luogu.com.cn/record/201048913)  
```cpp
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;
const int N = 2e5 + 10;
struct rest {
	int x, y;
}rests[N];
int n, d, l;
int ans;
priority_queue<int> q;
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}

inline void write(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}

bool cmp(rest a, rest b) {
	return a.x < b.x;
}

signed main() {
	n = read(), d = read(), l = read();
	for (int i = 1; i <= n; i++) 
		rests[i].x = read();
	for (int i = 1; i <= n; i++) 
		rests[i].y = read();
	sort(rests + 1, rests + 1 + n, cmp);
	rests[0].x = 0, rests[n + 1].x = l;
	for (int i = 0; i <= n; i++) {
		q.push(rests[i].y);
		while (rests[i + 1].x - rests[i].x > d && q.size()) {
			d += q.top();
			q.pop();
			ans++;
		}
		d -= rests[i + 1].x - rests[i].x;
		if (d < 0) {
			ans = -1;
			break;
		}
	}
	write(ans);
	printf("\n");
	return 0;
}
```

---

## 作者：tuboshu666 (赞：1)

## 题目大意
题目的意思很简单，就是要求在能到达 $$X$$ 的前提下，使选择用餐的酒馆数最少。

题中的能量，可以简单理解为能够前进的距离。

## 分析
考虑这样一个过程：在每次经过酒馆时，立刻知道是否要用餐是很难的。于是我们换个思路，将所有经过的酒馆记录下来，当没有能量时，再在所有经过的酒馆中选择用餐。

按这种思路，显然，要使选择用餐的酒馆数最少，只需每次都选增加能量最多的酒馆即可。

## Solution
通过前面的分析，我们得到了**贪心**的做法：

先将所有酒馆按距原点距离排序。用**大根堆**来维护所有经过酒馆中，增加能量的最大值。在每次经过酒馆时，就将其能量值加入**优先队列**。在每次能量耗尽时，取出堆顶即可。

## Code

```cpp
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;

typedef pair<int,int> PII;
const int N = 2e5 + 10;
PII node[N];
priority_queue<int> q; //大根堆

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n,D,X;
    cin >> n >> D >> X;
    for (int i = 1 ; i <= n ; i++) cin >> node[i].first;
    for (int i = 1 ; i <= n ; i++) cin >> node[i].second;

    sort(node+1,node+n+1); //排序
    int now = 1; //加入队列的最后一个酒馆的编号
    int ans = 0; //选择用餐的酒馆数
    int dist = 0; //距离原点的距离

    //这里为了方便操作，将初始能量加入优先队列，因此最后的答案需要-1
    q.push(D); 
    while (!q.empty())
    {
        int t = q.top();
        q.pop();

        ans++;
        dist += t;
        if (dist >= X) break; //能达到X就停止
        //将经过的酒馆加入优先队列
        while (node[now].first <= dist && now <= n)
        {
            q.push(node[now].second);
            now++;
        }
    }

    //若能到达则输出答案，否则输出-1
    if (dist >= X) cout << ans-1 << endl;
    else cout << -1 << endl;

    return 0;
}
```

---

## 作者：MonKeySort_ZYczc (赞：1)

## 题解之前说几句  
并不难猜的结论+并不难想的证明，简单贪心，建议练手
## 解题思路
### 预处理一下
容易~~猜~~看出本题思路为贪心。  
稍微想一想，我们必须先将餐馆按照坐标从小到大排序，毕竟我们需要用可以来到的餐馆进行贪心。  
利用结构体排序，手搓一个比较函数来快排。
### 贪心设计
设当前可以走到的最远位置为 $k$，每次在**未吃过的餐馆**中找到
$$
\max_{x_i<=k}y_i
$$
令 $k \gets k+y_i$，之后继续更新 $k$，直到 $k\ge X$。  
如果目前能到达的餐馆全部都吃了一遍仍然没有 $k\ge X$，那么判断无解，输出 $-1$ 即可。
### 正确性证明
如果每次选择的不是
$$
\max_{x_i<=k}y_i
$$
而选择了比这更小的 $y_j$，总共吃饭的次数不变，但是 $k$ 却更小，容易看出这不是最优选择。
### 具体实现
求最大值可以每次都重新扫描一遍数组，但此时时间复杂度将会达到 $O(n^2)$，会TLE。  
对此，我们可以维护一个优先队列，每次取出堆顶，这样时间复杂度将降为 $O(n\log n)$。  
最终时间复杂度为 $O(n \log n)$，空间复杂度由数组、结构体与快排辅助空间组成，共 $O(n)$。
## 代码在这哦

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,e;
struct rest//保存餐馆信息
{
	int p,x;
}r[211451];
bool cmp(rest a,rest b)//手搓比较函数
{
	if(a.p!=b.p) return a.p<b.p;
	else return a.x>b.x;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0); 
    //读写优化，吸氧能减少50ms（虽然没必要）
	int ans=0,poi=1;
	cin>>n>>d>>e;
	for(int i=1;i<=n;i++) cin>>r[i].p;
	for(int i=1;i<=n;i++)
	{
		int k;cin>>k;
		r[i].x=k;
	}
	sort(r+1,r+n+1,cmp);//排序
	priority_queue<int> Q;//优先队列取最大值
	while(d<e)
	{
		for(;poi<=n;poi++)
		{
			if(d<r[poi].p) break;
			Q.push(r[poi].x);
		}
		if(Q.empty())//判断无解
		{
			cout<<-1;
			return 0;
		}
		d+=Q.top();
        Q.pop();
        //吃过了不能再吃，因此要弹出
		ans++;
	}
	cout<<ans;
}
```
~~蒟蒻第一篇题解~~

---

## 作者：guer_loser_lcz (赞：0)

# 题解
## 思路
先大眼观察，数据范围告诉我们，这是线性复杂度。

其次，看不出明显用什么算法，判断为贪心。

由贪心，发现如果要吃饭，必然要吃能吃到的最大能量的，显然吃少的不合算。

但是，枚举能吃到的是线性的，乘起来就是 $n^2$ 的，显然过不了，用优先队列优化为 $\log$ 级。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,d,x,a[200100],mx,ans,all;
struct le{
	int x,y;
}c[200100];
bool cmp(le x,le y){
	return x.x<y.x;
}
int main(){
	cin>>n;
	cin>>d>>x;
	for(int i=1;i<=n;i++)cin>>c[i].x;
	for(int i=1;i<=n;i++)cin>>c[i].y;
	sort(c+1,c+n+1,cmp);
	priority_queue<int> q;
	int i=1;
	while(d<x){
		for(;i<=n;i++){
			if(c[i].x>d)break;
			q.push(c[i].y);
		}
		if(q.empty()){
			cout<<-1;
			return 0;
		}
		d+=q.top();
		q.pop();
		ans++;
	}
	cout<<ans;
}
```

---

## 作者：lzx111218 (赞：0)

# P11650 [COCI 2024/2025 #4] 力 / Benzinska
[题目传送门](https://www.luogu.com.cn/problem/P11650)
## 思路
**步骤：**

初始设置：从原点出发，初始能量为 $D$，目标位置是 $X$。按位置排序餐馆：餐馆按位置升序排列，因为我们是从 $0$ 到 $X$ 按顺序前进的。

**遍历：**

- 每次前往下一个餐馆时，消耗的能量是当前位置到下一个餐馆的距离。
- 如果能量不足，我们就从已经过的餐馆中选择能量恢复值最大的餐馆来补充能量。
- 用优先队列来存储经过的餐馆的能量恢复值，确保每次选择恢复最多能量的餐馆。
- 如果到达目标位置时仍然没有足够的能量，就返回 $-1$，否则返回使用的餐馆数量。

**总时间复杂度为** $O(n \log n)$。

**总空间复杂度为** $O(n)$。
### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct R {
    int x, y;
    R(int x, int y) : x(x), y(y) {}
};
signed main() {
    int n, D, X;
    scanf("%lld%lld%lld",&n,&D,&X);
    vector<int> a(n), b(n);
    for (int i = 0; i < n; ++i) scanf("%lld",&a[i]);
    for (int i = 0; i < n; ++i) scanf("%lld",&b[i]);
    vector<R> r;
    for (int i = 0; i < n; ++i)  r.push_back(R(a[i], b[i]));
    sort(r.begin(), r.end(), [](R p, R q) { return p.x < q.x; });
    int e = D, p = 0, cnt = 0;
    priority_queue<int> q;
    for (int i = 0; i < n; ++i) {
        e -= r[i].x - p;
        while (!q.empty() && e < 0) {
            e += q.top();
            q.pop();
            cnt++;
        }
        if (e < 0) {
            puts("-1");
            return 0;
        }
        p = r[i].x;
        q.push(r[i].y);
    }
    
    e -= (X - p);
    while (!q.empty() && e < 0) {
        e += q.top();
        q.pop();
        cnt++;
    }
    
    if (e < 0) puts("-1");
    else printf("%lld",cnt);
    return 0;
}
```

---

## 作者：DemonPlayer (赞：0)

### 思路：     
将餐馆按照位置，从小到大进行排序，再维护一个优先队列（大根堆），用于存储经过的餐馆的能量增加值。从原点开始，模拟 Malnar 的移动过程。当能量不足以移动到下一个餐馆或目的地时，从优先队列中取出最大的能量增加值，代表在该餐馆用餐，同时更新能量和用餐次数。若优先队列为空且能量仍不足以到达下一个位置，则无法到达目的地，输出 $-1$。否则输出用餐次数。   
### Code：
```cpp
#include<bits/stdc++.h>
#define AK return
#define IOI 0
using namespace std;

struct Rt{
	int d;
	int val;
	bool operator <(const Rt& x)const{
		return d<x.d;
	}
};

int n,D,X,cnt,idx,ans;
Rt a[200005];
Rt cur;
priority_queue<int> q;

int main(){
	scanf("%d%d%d",&n,&D,&X);
	for(int i=0;i<n;i++){
		scanf("%d",&a[i].d);
	}
	for(int i=0;i<n;i++){
		scanf("%d",&a[i].val);
	}
	sort(a,a+n);
	cur={0,D};
	while(cur.d<X){
		while(idx<n&&cur.val>=a[idx].d-cur.d){
			q.push(a[idx].val);
			idx++;
		}
		//可以到达
		if(cur.val>=X-cur.d){//有解
			break;
		}
		//无法到达
		if(!q.size()){
			cnt=-1;
			break;
		}
		//用餐
		cur.val+=q.top();
		q.pop();
		cnt++;
	}
	cout<<cnt;
	AK IOI;
}

---

## 作者：Lele_Programmer (赞：0)

# P11650 题解

## 思路

每个餐馆肯定都是要经过的，吃不吃是另外一回事，所以将第 $n+1$ 个餐馆的位置设置为 $X$，把餐馆位置从小到大排个序，从 $1$ 到 $n+1$ 枚举每一个餐馆的位置，最后一个地方是终点，每一次判一下剩余的能量能否走过相邻两个餐馆，不能的话就从前面已经走过的餐馆选几个吃了，直到能量足够。

要让用餐次数最少，那么吃一次尽量吃多点，则已经走过的餐馆用一个优先队列维护，每一次要用的时候弹出 $y$ 最大的一个。

如果吃到队列空了能量还不够，那就无解。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define TIMESTAMP cerr<<fixed<<setprecision(3)<<clock()*1.0/CLOCKS_PER_SEC<<"s"<<endl;
#define _rep(i,a,b) for (int i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for (int i=(a);i<=(b);c)
#define _rrep(i,a,b) for (int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for (int i=(a);i>=(b);c)
#define _iter(i,a) for (auto i=a.begin();i!=a.end();++i)
#define _graph(i,u) for (int i=h[u];~i;i=ne[i])
#define rint register int
#define LL long long
#define i32 signed
#define i64 long long
#define i128 __int128
#define u32 unsigned
#define u64 unsigned long long
typedef pair<int,int> pii;
typedef pair<int,pii> piii;
typedef pair<double,double> pdd;

namespace IO {
    template<typename T> inline void read(T& x) {
        int s=1; char c=getchar(); x=0;
        while (!isdigit(c)) { if (c=='-') s=-1; c=getchar(); }
        while (isdigit(c)) x=x*10+(c-'0'),c=getchar();
        x*=s;
    }
    inline void readstr(string& x) {
        x.clear(); char c=getchar();
        while (isspace(c)) c=getchar();
        while (!isspace(c)) x.push_back(c),c=getchar();
    }
    inline void readstr(char* x) {
        int idx=0; char c=getchar();
        while (isspace(c)) c=getchar();
        while (!isspace(c)) x[idx++]=c,c=getchar();
        x[idx]='\0';
    }
    template<typename T> inline void write(T x) {
        if (x<0) putchar('-'),x=-x;
        if (x/10) write(x/10);
        putchar('0'+(x%10));
    }
    template<typename T> inline void writesp(T x) { write(x); putchar(' '); }
    template<typename T> inline void writeln(T x) { write(x); putchar(10); }
    inline void writestr(string& x) { _iter(it,x) putchar(*it); }
    inline void writestr(char* x) { _rep(i,0,strlen(x)) putchar(x[i]); }
    inline void writestrsp(string& x) { _iter(it,x) putchar(*it); putchar(' '); }
    inline void writestrsp(char* x) { _rep(i,0,strlen(x)) putchar(x[i]); putchar(' '); }
    inline void writestrln(string& x) { _iter(it,x) putchar(*it); putchar(10); }
    inline void writestrln(char* x) { _rep(i,0,strlen(x)) putchar(x[i]); putchar(10); }
};

using namespace IO;

const int N=200005;

int n,d,X;

struct node {
    int x,y;
    friend bool operator < (const node& a,const node& b) {
        return a.x<b.x;
    }
} arr[N];

priority_queue<int,vector<int>,less<int>> s;

int main() {
    read(n),read(d),read(X);
    _rep(i,1,n) read(arr[i].x);
    _rep(i,1,n) read(arr[i].y);
    arr[n+1]={X,0};
    sort(arr+1,arr+1+n);
    int cur=0,ans=0;
    _rep(i,1,n+1) {
        int dis=arr[i].x-cur;
        while (d<dis && !s.empty()) ans++,d+=s.top(),s.pop();
        if (d<dis) {
            puts("-1");
            return 0;
        }
        d-=dis,cur+=dis;
        s.emplace(arr[i].y);
    }
    write(ans);
    return 0;
}
```

---

## 作者：K_yuxiang_rose (赞：0)

本题需要求最小用餐数，可以使用贪心和优先队列维护。

先将餐馆按位置排序，每次能走到下一个餐馆就走，并将这个餐馆能获得的能量存进优先队列；如果走不到，就将优先队列队首也就是最大的能量弹出并使用。如果到了终点就判断是否满足要求即可。

如果存入了所有餐馆后还是没有到终点就依次将能量弹出并使用直到符合要求。

如果在过程中优先队列为空则说明无法到达，输出 $-1$。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{
	int x,y;
}a[200005];
bool cmp(node A,node B) {return A.x<B.x;}
int n,D,X;
signed main()
{
	cin>>n>>D>>X;
	for(int i=1;i<=n;i++) cin>>a[i].x;
	for(int i=1;i<=n;i++) cin>>a[i].y;
	sort(a+1,a+n+1,cmp);
	int l=0,r=n,ans=0;
	priority_queue<int> q;
	int sum1=D,sum2=0,i=1;
	while(i<=n)
	{
		if(sum1>=a[i].x) q.push(a[i].y),i++;
		else
		{
			if(q.empty())
			{
				cout<<-1;
				return 0;
			}
			sum1+=q.top();
			q.pop();
			sum2++;
		}
		if(sum1>=X)
		{
			cout<<sum2;
			return 0;
		}
	}
	while(q.size())
	{
		sum1+=q.top();
		q.pop();
		sum2++;
		if(sum1>=X)
		{
			cout<<sum2;
			return 0;
		}
	}
	cout<<-1;
	return 0;
}
```

---


# [NOIP 2010 普及组] 三国游戏

## 题目描述

小涵很喜欢电脑游戏，这些天他正在玩一个叫做《三国》的游戏。

在游戏中，小涵和计算机各执一方，组建各自的军队进行对战。游戏中共有 $N$ 位武将（$N$ 为偶数且不小于 $4$），任意两个武将之间有一个“默契值”，表示若此两位武将作为一对组合作战时，该组合的威力有多大。游戏开始前，所有武将都是自由的（称为自由武将，一旦某个自由武将被选中作为某方军队的一员，那么他就不再是自由武将了），换句话说，所谓的自由武将不属于任何一方。

游戏开始，小涵和计算机要从自由武将中挑选武将组成自己的军队，规则如下：小涵先从自由武将中选出一个加入自己的军队，然后计算机也从自由武将中选出一个加入计算机方的军队。接下来一直按照“小涵 $\to$ 计算机 $\to$ 小涵 $\to\dots$ ”的顺序选择武将，直到所有的武将被双方均分完。然后，程序自动从双方军队中各挑出一对默契值最高的武将组合代表自己的军队进行二对二比武，拥有更高默契值的一对武将组合获胜，表示两军交战，拥有获胜武将组合的一方获胜。

已知计算机一方选择武将的原则是尽量破坏对手下一步将形成的最强组合，它采取的具体策略如下：任何时刻，轮到计算机挑选时，它会尝试将对手军队中的每个武将与当前每个自由武将进行一一配对，找出所有配对中默契值最高的那对武将组合，并将该组合中的自由武将选入自己的军队。 下面举例说明计算机的选将策略，例如，游戏中一共有$6$个武将，他们相互之间的默契值如下表所示：

| 武将编号 |  1   |  2   |  3   |  4   |  5   |  6   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
|  **1**   |      | $5$  | $28$ | $16$ | $29$ | $27$ |
|  **2**   | $5$  |      | $23$ | $3$  | $20$ | $1$  |
|  **3**   | $28$ | $23$ |      | $8$  | $32$ | $26$ |
|  **4**   | $16$ | $3$  | $8$  |      | $33$ | $11$ |
|  **5**   | $29$ | $20$ | $32$ | $33$ |      | $12$ |
|  **6**   | $27$ | $1$  | $26$ | $11$ | $12$ |      |

双方选将过程如下所示：

|        | 小涵 | 轮到计算机时可选的自由武将 |  计算机    |  计算机选将说明    |
| :----: | :--: | :----------: | :--: | :--: |
| 第一轮 | $5$ | $1,2,3,4,6$ | $\color{magenta}4$ | 小涵手中的 $5$ 号武将与 $4$ 号的默契值最高，所以计算机选择 $4$ 号。 |
| 第二轮 | $5,3$ | $1,2,6$ | $4,\color{magenta}1$ |  小涵手中的 $5$ 号和 $3$ 号武将与自由武将中配对可产生的最大默契值为 $29$，是由 $5$ 号与 $1$ 号配对产生的，所以计算机选择 $1$ 号。  |
| 第三轮 | $5,3,6$ | $2$ | $4,1,\color{magenta}2$ |      |

小涵想知道，如果计算机在一局游戏中始终坚持上面这个策略，那么自己有没有可能必胜？如果有，在所有可能的胜利结局中，自己那对用于比武的武将组合的默契值最大是多少？  

假设整个游戏过程中，对战双方任何时候均能看到自由武将队中的武将和对方军队的武将。为了简化问题，保证对于不同的武将组合，其默契值均不相同。


## 说明/提示

**数据范围**

对于 $ 40\%$ 的数据有 $N≤10$。

对于 $ 70\%$ 的数据有 $ N≤18$。

对于 $100\%$ 的数据有 $4\le N≤500$。保证对于不同的武将组合，其默契值均不相同。

NOIP2010 普及组 第四题

## 样例 #1

### 输入

```
6 
5 28 16 29 27 
23 3 20 1 
8 32 26 
33 11 
12 
```

### 输出

```
1
32

```

## 样例 #2

### 输入

```
8 
42 24 10 29 27 12 58 
31 8 16 26 80 6 
25 3 36 11 5 
33 20 17 13 
15 77 9 
4 50 
19 ```

### 输出

```
1
77```

# 题解

## 作者：wjyyy (赞：342)

**我的blog：[传送门](http://www.wjyyy.top/)**

   这个题尽管题目长，主要还是证明贪心的正确性。
   
   首先注意到，在这个题里，计算机是**贪心的**，也就是说，无论人选什么，它都会尽可能去选与人默契值最大的。想到这里可能会联想到博弈论，因为两个人的目标都是一样的。不过稍加分析会发现，人总是拿不到最优的。

   因为我们选将可以看作一个配对的过程，所以在选将$i$后，第$i$行和第$i$列表格中行和列都是我们的，在自己的行和自己的列交点处就是自己的武将对了。也就是说表格是对称的。
   
   ![](http://www.wjyyy.top/wp-content/uploads/2018/08/201808051601.png)
   
   分析样例可以得知，最优解总是**每一行（整理后）排名第二大**中最大的那个。也就是说，每一行的最大的那一组电脑是不可能让你选到手的。一旦选择了最大的一组中的其中一个，电脑总可以先手把另一半抢掉，所以每行最大的一组是不可能选出的。而我们要证明次大中最大的那个是一定可以选到的。

   当我们选择了次大中最大的那一行，电脑就毫无疑问会把那一行中最大的一个给选出来。
   
   ![](http://www.wjyyy.top/wp-content/uploads/2018/08/201808051605.png)
   
   此时我们把次大中最大的另一半给配上就可以了。那我们现在拿到了人所可能拿到的最大的一对武将，怎么保证计算机不拿到比自己更大的武将呢？可以看出，比当前已有的默契值更大的武将一定在其他行中处于最大的位置，（假设计算机足够聪明）如果计算机去选了那个位置，人先手去把它抢掉就行了。而计算机并没有那么聪明，它只会避免你去选能选的最大的武将，此时可以分情况讨论。
   
   ![](http://www.wjyyy.top/wp-content/uploads/2018/08/201808051657.png)
   
   计算机此时选择一个武将有两种影响：一是与原来的绿线相交，如果与绿线相交会直接确定一组武将，此时人是阻止不了的。但是我们可以保证现在一条线与绿线的交点值一定小于人的答案。**反证：**如果那个值比人的答案（五角星）要大而比三角形要小，那么次大中最大的就是这个值，因此这个值不可能在这个范围；而如果那个人的值比三角形还大，那次大中最大的就是三角形了。因此与绿线的交点绝不会超过五角星。

   第二种影响就是不与绿线相交。对于不与绿线相交的部分，只要人去把计算机最大的抢掉，计算机就不可能抢到每一行中最大的那个。

   综上所述，无论人还是计算机都无法抢到每一行中最大的那个，而根据贪心，人去选每行次大元素中最大的一定能选到，此时也能阻止计算机去选更大的元素。同时人不会输。
   
## Code：
```cpp
#include<cstdio>
#include<algorithm>
using std::sort;
int a[510][510];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<n;i++)
        for(int j=i+1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
            a[j][i]=a[i][j];
        }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        sort(a[i]+1,a[i]+1+n);
        ans=ans>a[i][n-1]?ans:a[i][n-1];//选出排名第二中最大的那个
    }
    printf("1\n%d\n",ans);//一定有解
    return 0;
}
```

---

## 作者：封禁用户 (赞：120)

这是一道典型的博弈论题目，所以我先提一下博弈论
### 1.博弈论入门
你和你的朋友，两个人一起玩游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个程序，来判断你是否可以在给定石头数量的情况下赢得游戏。

示例:

输入: 4
输出: false
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。

这个题目的典型特征：只有两个玩家，游戏规则固定，游戏里面有可变的数据（这题是石头的数量），询问你是否必胜？
看到这种描述你就要明白，你遇到一个博弈论的题目啦，千万注意绝对不是让你用程序去模拟题目的游戏过程再得出结果的。你要在脑中分析出过程，重点分析两点：1.什么时候可以判定胜利者，2.先手的影响。

题目描述了石头数量为 4 的情况，数量为 4 的时候先手的那个人必输，因为他一次拿不完，但是又不得不拿，不管他拿多少后手的人只要把剩下的都拿完就赢了。这个时候发散思维就派上用场了，这个示例给我们的启示是：只要场上剩下的石头数量是 4 的倍数，那么后手必胜，假设这一轮先手的一方拿了a个，那么后手的一方就拿 4 - a 个，按照这样的玩法，每轮消耗4块石头。玩完最后一轮后手就赢了。
所以这个游戏后手必胜规则是：当石头数量是 4 的倍数。

因为后手输了就代表先手赢了，所以先手必胜的条件是反着的：当石头数量不是 4 的倍数。

到这里这个题目已经解出来了，如果你好奇石头数量不能被 4 整除时先手怎么赢的，那么可以看这里:
对于这个游戏来说，假设原本的游戏规则是共有 n 个石头，A 先手，B后手，如果 A 总是先手拿 m 个石头，那么这个游戏等同于共有 n - m 个石头，B 先手， A 后手的一场游戏。所以，当石头数量不能被 4 整除的时候，先手拿走被4整除的余数数量的石头就能保证必胜。

拿石头这个游戏是经典的“巴什博弈”。  
  
  ---------------分割线----------------  
首先我们要明确这是一个博弈论的题目，不要去模拟过程，想办法分析获胜的方式。计算机和玩家对抗的方式比较傻，第一感觉是玩家肯定能赢，这个题有10 组用例，如果玩家输了只需要输出0即可，如果这个游戏真的有输有赢，那直接cout<<0; 的同学肯定能得一部分分数，所以我直接输出 0 然后提交了代码(某oj，主要是怕影响AC率)，结果一分未得，说明在博弈论的视角下，这个游戏的玩家是必胜的。所以最终输出的格式肯定是

1
X

X 如何得到呢，读懂题意不难发现 X 是一组武将的默契值，这个数不是计算出来的，而是输入数据中的某个数字，而且按照题意这个数字越大越好，对比了一下两个用例，第一组用例输出的是 32， 第二组输出的是 77. 刚好都是所有数据中第二大的数字，由于计算机的阻挠，玩家不可能选到默契值最大的武将组合，那么玩家最终获胜的数字是否是次大的那个数字呢？为了验证我的猜测，我写了个很简单的程序，找到所有输入数据中第二大的数字，结果只得了 20 分，也就是说真实的情况没这么简单，刚好只有这两组示例用例满足我的猜测而已。

看来这题没法继续骗分了QWQ，我必须得认认真真分析了。对比巴什博弈的题目，我要从题目给的唯一的一组选将过程中寻找答案。巴什博弈中不管石头总数有多少，每一轮玩家都要想办法拿 4 - a 块石头。那么这个游戏中小涵是如何选择的呢  

我把小涵和电脑玩的那一局复盘了一下，由于计算机是被动的跟着小涵选的，所以我们只要分析出小涵3次选将的依据，这个题就做出来了。横着看上图，小涵第一次拿了 5，第 5 行确实大数字很多，计算机为了阻挠小涵，所以拿了 4，这样小涵就拿不到默契值为 33 的组合了。这个时候小涵选择了 3，计算机选了 1，对比这两步可以发现，小涵前两轮拿到了 32 这个默契值，而这个默契值是全场第二高的，这是我刚才分析过的，结果已经被证明是片面的想法了。

正确的思路是：小涵和电脑都拿不到每个武将的最大默契值，因为小涵每拿起最大组合的其中一个，另一个就被电脑拿走了，但是电脑也无法占有该组合的最大值，因为另一个在小涵手里，这个组合的最大值其实就作废了。但是小涵在第二次选将时可以拿到第一次选中的武将的次大默契值组合。在双方都拿不到最大默契值的情况下，显然谁拿到次大默契组合的最大值，谁就赢了。

以示例中的选将为例，武将1-6的次大默契值罗列出来：

![](https://cdn.luogu.com.cn/upload/pic/73459.png)  
小涵拿到 5 和 3 之后，小涵就已经赢了，电脑拿了4之后无法组合出比 32更大的值。所以按照这个逻辑，小涵第一轮和第二轮拿到 5 和 3，剩下的几步就可以随便选了。  
下面就上完整AC代码  
#### 关爱生命，拒绝抄袭  
```cpp
#include<bits/stdc++.h>
using namespace std;

//放到 main 外面去定义可以得到的好处：数组 mo 的中所有元素都会被默认赋值为 0
int mo[501][501],n;
int main()
{
    cin>>n;
    // 构造二维数组要用嵌套的 fo r循环，i 写入到数组第一维，j 写到数组第二维
    for(int i=1;i<=n;i++) {
        for(int j=i+1;j<=n;j++) {
            cin>>mo[i][j];
            //(i,j) 的对称位置是(j,i)
            mo[j][i]=mo[i][j];
        }
    }
    //ans 保存二维数组每一行次大值中的最大值
    int ans = 0;
    //对数组的第二维进行排序
    for(int i=1;i<=n;i++)
    {
        //对 mo 的每一行都排序，sort 默认是从小到大的
        sort(mo[i],mo[i]+n+1);
        //排序后每一行第二大的值是 mo[i][n-1]
        if(mo[i][n-1] > ans) 
            ans = mo[i][n-1];
    }

    cout<<1<<endl<<ans;
    return 0;
}
```



---

## 作者：__stdcall (赞：31)

我是没有想出来正解，看了题解，觉得题解说的还是不够清楚，于是自己详细证明了一下，如下：

按照题解中的选法，将每个武将对应的所有配对值中的第二大值选出来，进行排序

答案就是这些值中最大的，并且小涵必胜，证明如下：

首先，我们这个解法获胜的思路是，每个武将对应的所有配对值中最大的值，已经被拆散

在这种情况下，场上存在的只剩所有的“次大值”，就是我们拿来排序的那一堆

这时候小涵拿到了“次大值”中的最大值，肯定是场上最高的分数

为什么呢？用反证法

按照小涵的选法，小涵第一次选了武将i，其中i对应的最大值是j，次大值是l，即i-j > i-l

这里的'-'是对应的意思

这时候，计算机一定会选择j

如果j对应的所有配对值中，最大值也是i，那么i和j这两个点的对应最大值都被拆散了

是不是j对应的最大值一定是i呢？是的

假设j对应的最大值是k，i是j对应的次大值，即j-k > j-i

那么就有j-k > j-i > i-l，这时候我们肯定会选择j作为第一个武将

因为j-i（j的对应次大值）大于i-l（i的对应次大值），与选法矛盾

也就是说，我们第一次选了i，取得了次大值中的最大值，同时拆掉了i的最大值和j的最大值

接下来小涵选了l，然后计算机选了另一个武将m

计算机选m有两种原因：一是l-m是l的最大值，拆了最大值正合我意

一是i-m比l的最大值更大（但是不会比i-l大），即i-l > i-m > l的最大值

这时候l的最大值拆不拆都是无所谓的，反正小于我们的i-l

然后小涵选了n拆了m的最大值m-n

计算机接着拆最大值，要么是n的最大值，要么比i-l小，证法同上

两个人就这么拆最大值，就把最大值拆完了，剩下的就是次大值，我们的i-l就是次大值中最大的

证毕
可能我描述不是很清楚，希望你们能理解吧。。。

我觉得这题难度应该最少是提高，因为要详细证明还是挺复杂的，我想了2.5h才完全证出来（我好菜啊）

最后上代码




```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
using namespace std;
int n;
int a[510][510];
bool used[510];
int main() {
    scanf( "%d", &n );
    for( int i = 1; i <= n; ++i ) for( int j = i+1; j <= n; ++j ) {
        scanf( "%d", &a[i][j] ); a[j][i] = a[i][j];
    }
    int ans = -1;
    for( int i = 1; i <= n; ++i ) {
        int m1 = -1, m2 = -1; // 最大值和次大值 
        for( int j = 1; j <= n; ++j ) if( i != j ) {
            if( a[i][j] > m1 ) {
                m2 = m1; m1 = a[i][j];
            }
            else if( a[i][j] > m2 ) m2 = a[i][j];
        }
        ans = max( ans, m2 );
    }
    printf( "1\n%d\n", ans );
    return 0;
}
```

---

## 作者：GSQ0829 (赞：2)

### 思路：

题目中给的一个表格。
| 武将编号 |  1   |  2   |  3   |  4   |  5   |  6   |
| :------: | :--: | :--: | :--: | :--: | :--: | :--: |
|  **1**   |      | $5$  | $28$ | $16$ | $29$ | $27$ |
|  **2**   | $5$  |      | $23$ | $3$  | $20$ | $1$  |
|  **3**   | $28$ | $23$ |      | $8$  | $32$ | $26$ |
|  **4**   | $16$ | $3$  | $8$  |      | $33$ | $11$ |
|  **5**   | $29$ | $20$ | $32$ | $33$ |      | $12$ |
|  **6**   | $27$ | $1$  | $26$ | $11$ | $12$ |      |

双方选将过程如下所示：

|        | 小涵 | 轮到计算机时可选的自由武将 |  计算机    |  计算机选将说明    |
| :----: | :--: | :----------: | :--: | :--: |
| 第一轮 | $5$ | $1,2,3,4,6$ | $\color{magenta}4$ | 小涵手中的 $5$ 号武将与 $4$ 号的默契值最高，所以计算机选择 $4$ 号。 |
| 第二轮 | $5,3$ | $1,2,6$ | $4,\color{magenta}1$ |  小涵手中的 $5$ 号和 $3$ 号武将与自由武将中配对可产生的最大默契值为 $29$，是由 $5$ 号与 $1$ 号配对产生的，所以计算机选择 $1$ 号。  |
| 第三轮 | $5,3,6$ | $2$ | $4,1,\color{magenta}2$ |      |

我们可以先从题目给的样例图片来看一下。其实这题带了点[博弈论](https://hanks.blog.csdn.net/article/details/10299095?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-10299095-blog-127897183.235%5Ev43%5Epc_blog_bottom_relevance_base5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-10299095-blog-127897183.235%5Ev43%5Epc_blog_bottom_relevance_base5&utm_relevant_index=2)。

那么，其实这题在博弈论中，小涵是必胜的，所以，就可以直接输出 $1$。

那最大默契值又要怎么算呢？首先，因为它是一个矩阵，就要先进行矩阵的存储。
```cpp
a[j][i] = a[i][j]
```
这样，比如一行二列，就可以存到二行一列了。

那么，我们还要对 $a$ 数组的每一行进行排序，从小到大排，然后我们就可以用一个三目运算，选出排名第二中最大的那个。
```cpp
ans = ans > a[i][n - 1] ? ans : a[i][n - 1]
```
这样，这题我们就做完了！

---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 501;
int a[MAXN][MAXN], n, ans = 0;

int main() {
	cin >> n;
	for (int i = 1; i < n; i++) {
		for (int j = i + 1; j <= n; j++) {
			cin >> a[i][j];
			a[j][i] = a[i][j];
		}
	}
	for (int i = 1; i <= n; i++) {
		sort(a[i] + 1, a[i] + 1 + n);
		ans = ans > a[i][n - 1] ? ans : a[i][n - 1];
	}
	cout << 1 << endl << ans << endl;
	return 0;
}
```

---

## 作者：Kaedehara__Kazuha (赞：1)

## 思路

如果小涵想要获胜，就要选到默契值尽可能大的一对武将。但我们会发现，计算机选择的策略决定了小涵**不可能**选到这对武将，于是我们退而求其次，考虑次大值。

接着我们又发现，如果我们拿走了一个武将 $a$，那么计算机一定会拿走与 $a$ 默契值最大的武将 $b$，这时，我们只需要拿走与 $a$ 的默契值第二大的武将 $c$ 就好了，此时计算机**一定**拿不到比小涵拿到的这对武将默契值更大的一对武将，因为默契值最大的一对武将被拆散了，而默契值第二大的一对武将在小涵的手上，故我们只需要一直用这个策略选下去，便可以让小涵手上默契值最大的一对武将的默契值**始终**比计算机手上默契值最大的一对武将更大，这样**小涵就是必胜的**。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[505][505],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			cin>>a[i][j];
			a[j][i]=a[i][j];//构造一个对称的二维表来存储武将之间的默契值
		}
	}
	for(int i=1;i<=n;i++){
		sort(a[i]+1,a[i]+1+n);//排序，求次大值
		ans=max(ans,a[i][n-1]);//更新答案
	}
	cout<<1<<"\n"<<ans;//由于小涵是必胜的，所以我们直接输出1和默契值就好
	return 0;//华丽结束
}
```
蒟蒻的第一篇题解，求过。

---

## 作者：Wish_kazdel (赞：1)

## 思路
其实小涵在这场比赛中是必胜的。

通过题目我们不难发现，每个武将对应的所有配对值中最大默契值，已经被拆散。那么场上存在的只剩所有的次大默契值，只要小涵一直去寻找次大默契值，那么他就肯定是获胜的。

---

## 证明
~~虽然这道题不难，但证明挺难。~~

当计算机取某点时，由于计算机的选将策略，这个点的最佳搭配点已经先一步被我们取了，故计算机不可能取到最佳搭配。而我们也不可能取到最佳搭配，因为当我们取一对最佳搭配中的一点时，还是由于上文计算机的选将策略，计算机必定会取最佳搭配中的另一点，即我们也不能取到最佳搭配点。

那么综上所述，我们就可以得出双方均不可能取到最佳搭配。

又因为双方均不可能取到最佳搭配。所以在最开始取时，我们可以取 每个点的次大值的最大值对应的点，待计算机取掉这个点的最佳搭配点时，我们即可取这个点的次佳搭配点，也就是所有次佳搭配中的最大值，又由于最佳搭配无法取到，所以我们取的就是最佳方案。由此得证。

代码不难写，所以我就不给了。

---


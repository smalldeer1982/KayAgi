# [蓝桥杯 2025 省 Java B] 数组翻转

## 题目描述

小明生成了一个长度为 $n$ 的正整数数组 $a_1, a_2, \dots , a_n$，他可以选择连续的一段数 $a_l, a_{l+1}, \dots, a_r$，如果其中所有数都相等即 $a_l = a_{l+1} = \dots = a_r$，那么他可以获得 $(r - l + 1) \times a_l$ 的分数。

在选择之前，为了让分数尽可能大，他决定先选择数组中的一段区间，对其进行左右翻转。他想知道在对数组进行翻转之后他能获得的最大分数是多少？

提示：当翻转 $a_l$ 到 $a_r$ 这段区间后，整个数组会变为：

$$a_1, a_2, \dots , a_{l-1}, a_r, a_{r-1}, \dots , a_{l+1}, a_l, a_{r+1}, \dots , a_n$$

## 说明/提示

### 样例说明

翻转区间 $[5, 7]$，数组变为 $4, 4, 3, 3, 3, 1, 2$，最大分数为选择三个 $3$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$n \leq 500$。
- 对于 $100\%$ 的评测用例，$1\leq n \leq 10^6$，$1\leq a_i \leq 10^6$。

## 样例 #1

### 输入

```
7
4 4 3 3 2 1 3```

### 输出

```
9```

# 题解

## 作者：beicige (赞：2)

## 题意
给出一个长度为 n 的正整数数组 $a_1, a_2, \dots , a_n$ 。可以对任意一个区间进行翻转。然后找出连续相同数字区间长度与相同数字之积的最大值。

## 思路
很明显题目要求把两段所有数都相同的区间合并。所以我们可以求出每一个数字连续出现次数的最大值和次大值。对于每一个数字，这样两个区间通过翻转合并后的长度一定为最长。

然后枚举所有数字可获得的分数，求出得分最大值即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000010],m[1000010][3],cnt,ans,ma=-1,mi=INT_MAX;
//m数组存储每一个数字的最大和次大长度，ma和mi存储数字的最大值和最小值 
//cnt存储当前长度 
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0); 
	cin>>n; 
	for(int i=1;i<=n;i++){
		cin>>a[i];
		ma=max(ma,a[i]),mi=min(mi,a[i]);//记录最大值和最小值 
	}
	for(int i=1;i<=n;i++){
		cnt++;//当前长度增加 
		if(a[i]!=a[i+1]||i==n){//如果下一位数字与当前数字不相同 
			if(cnt>m[a[i]][1]) m[a[i]][2]=m[a[i]][1],m[a[i]][1]=cnt;//是目前最长，则把原本最长下调至第二长 
			else if(cnt>m[a[i]][2]) m[a[i]][2]=cnt; //修改为第二长 
			cnt=0;//注意计数器清零 
		}
	}
	for(int i=mi;i<=ma;i++){//从所有数字的最小值到最大值 
		ans=max(ans,(m[i][1]+m[i][2])*i);//ans存储答案。最长与次长之和是翻转后的长度，与当前数字相乘得到分数 
	}
	cout<<ans;
} 
```

---

## 作者：chrispang (赞：2)

## 题目大意

给定一个长度为 $n$ 的序列，现在有一个得分方式：

- 若 $a_l=a_{l+1}=\dots=a_r$，则得分为 $a_l\times (r-l+1)$。

当然，我们有一个旋转任一区间的机会。请利用这个机会，使最后的得分最大。

## 题目分析

得分的要求：即连续的相同元素。

因此，在没有旋转机会的情况下。我们只要枚举连续的相同元素长度最大值即可。

当然，就算有了这个旋转机会，我们只要顺带着记录次大值即可。

## 代码实现

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
#define x first
#define y second
#define int long long
using namespace std;

int n, ans;
int a[maxn], pre[maxn];
unordered_map<int, pair<int, int> >mp;
signed main(){
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (int i = 2, res = 1; i <= n + 1; i++) {
        if (a[i] == a[i - 1]) res++;
        else {
            if (mp[a[i - 1]].x < res) mp[a[i - 1]].y = mp[a[i - 1]].x, mp[a[i - 1]].x = res;
            else if (mp[a[i - 1]].y < res) mp[a[i - 1]].y = res;
            res = 1;
        }
    }
    for (auto i : mp) ans = max(ans, i.x * (i.y.x + i.y.y));
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：zhaolt2012 (赞：1)

# 题意
题目让我们反转数组内一段数字，使连起来的一段数字加起来最大。
# 解题思路
因为数组内任意两段连续的数字能通过反转连在一起。所以只要存下最大的两段连续数字，枚举组合两段一样的连续数字。求出最大值就可以了。
# AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000010],b[1000010][3],ans=-1;
int main()
{
	cin>>n;
	cin>>a[1];
	long long cnt=1,z=-1;
	for(int i=2;i<=n;i++)
	{
		cin>>a[i];
		z=max(a[i],z);//最大数字

		if(a[i]==a[i-1])cnt++;
		else 
		{
			if(cnt>b[a[i-1]][1])//存下最大的两段连续数字
			{
				b[a[i-1]][2]=b[a[i-1]][1];
				b[a[i-1]][1]=cnt;
			}
			else if(cnt>b[a[i-1]][2]) b[a[i-1]][2]=cnt;
			cnt=1;
		}

	}

	if(cnt>b[a[n]][1])//最后一段要另外处理
	{
		b[a[n]][2]=b[a[n]][1];
		b[a[n]][1]=cnt;
	}
	else if(cnt>b[a[n]][2]) b[a[n]][2]=cnt;

	for(int i=1;i<=z;i++) ans=max(ans,(b[i][1]+b[i][2])*i);
	cout<<ans;
}
```

---

## 作者：Kato_Shoko (赞：1)

蒟蒻的我第一次在洛谷写题解(上一次的寄了)，还请多包涵不足的地方。  

**问题描述。** 给定长度为 $n$ 的正整数数组 $a_1,a_2,\dots,a_n$。小明可以先对数组中任意一段区间 $[l,r]$ 做一次翻转（左右颠倒），然后从翻转后的数组中选取一段所有元素相等的子数组获得得分，若选取的区间长度为 $L$，元素值为 $v$，则得分为 $L\times v$。问小明能获得的最大得分。  

**样例说明。**  
样例输入：  
```
7  
4 4 3 3 2 1 3  
```  
翻转区间 $[5,7]$ 后数组变为 $4,4,3,3,3,1,2$，此时选取那 3 个连续的 3，可得分数 $3\times 3=9$，为最优。  

**关键观察。**  
翻转操作的唯一作用，是可以将原数组中相同值 $v$ 的两段不相邻的连续区间调换位置，使它们在翻转后相邻，从而合并为一段更长的相同值区间。  
若不翻转，则对于值 $v$，只能获取它在原数组中某一段最大连续长度 $L_{\max}$，得分为 $L_{\max}\times v$。  
若允许一次翻转，则对于每个值 $v$，可以选择原数组中两段连续且值都为 $v$ 的区间，其长度分别为 $L_1,L_2$，通过翻转把它们拼接到一起，获得长度 $L_1+L_2$ 的区间，得分为 $(L_1+L_2)\times v$。最优情况下，对于每个 $v$，应选其最长的两段连续区间。  

**算法实现。**  
1. 使用一次从左到右的扫描。  
2. 令 `per[i]` 表示以位置 $i$ 为结尾的、且值相同的最长连续段的长度。  
3. 当 $a_i=a_{i-1}$ 时，`per[i]=per[i-1]+1`；否则，表示一段结束，将该段长度 `per[i-1]` 记入哈希表 `mp[a_{i-1}]`，更新此值的「第一长」和「第二长」；然后重置 `per[i]=1`。  
4. 扫描结束后，哈希表 `mp[v]` 中存有值为 $v$ 的所有连续段的「第一长」 $f_1$ 和「第二长」 $f_2$。对每个键值对 $(v,(f_1,f_2))$，计算得分 $v\times(f_1+f_2)$，取最大。  
5. 时间复杂度 $O(n)$，空间复杂度 $O(n)$（用于存储 `per` 数组与哈希表）。  

**代码如下。**  

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const ll N = 1e6 + 5;

void solve(){
    int n;
    cin >> n;
    vector<ll> a(n+5), per(n+5);
    map<int, pair<ll, ll>> mp;

    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    for (int i = 1; i <= n + 1; i++) {
        if (a[i] == a[i - 1]) {
            per[i] = per[i - 1] + 1;
        } else {
            per[i] = 1;
            auto &[firs, seco] = mp[a[i - 1]];
            if (per[i - 1] > firs) {
                seco = firs;
                firs = per[i - 1];
            } else {
                seco = max(seco, per[i - 1]);
            }
        }
    }

    ll ans = 0;
    for (auto [x, pa] : mp) {
        auto [firs, seco] = pa;
        ans = max(ans, x * (firs + seco));
    }

    cout << ans;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }

    return 0;
}
```

**复杂度分析。**  
- 扫描一遍数组维护 `per` 数组与更新哈希表，时间 $O(n)$；  
- 最后遍历哈希表键值对，时间 $O(m)$，其中 $m$ 为不同值的数量，显然 $m \leq n$，故总时间 $O(n)$。  
- 空间上，`per` 占 $O(n)$，哈希表最坏也为 $O(n)$。  

这样就能在 $n \le 10^6$ 时依然保持线性通过。

---

## 作者：Zdc0614 (赞：1)

# Java 题解：翻转操作优化求解
## 解题思路
所谓翻转操作其实没必要实现，只需要对每个数统计连续出现的次数，保留最大的两个结果。最后在遍历数值乘以（两次连续出现次数和），得到最大值输出即可。

## 代码实现

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws FileNotFoundException {
        QReader in = new QReader();
        QWriter out = new QWriter();
        int n = in.nextInt();
        int[] arr = new int[n];
        int[][] tong = new int[1000001][2];
        
        for (int i = 0; i < n; i++) {
            arr[i] = in.nextInt();
        }
        
        for (int i = 0; i < n; i++) {
            int c = 0;
            c++;
            while (i < n - 1 && arr[i] == arr[i + 1]) {
                i++;
                c++;
            }
            if (c > tong[arr[i]][0]) {
                tong[arr[i]][1] = tong[arr[i]][0];
                tong[arr[i]][0] = c;
            } else if (c > tong[arr[i]][1]) {
                tong[arr[i]][1] = c;
            }
        }
        
        long s = 0;
        for (int i = 0; i < 1000001; i++) {
            long t = (long) i * (tong[i][1] + tong[i][0]);
            if (t > s) s = t;
        }
        out.println(s);
        out.close();
    }
    
    static class QReader {
        private BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        private StringTokenizer tokenizer = new StringTokenizer("");

        private String innerNextLine() {
            try {
                return reader.readLine();
            } catch (IOException e) {
                return null;
            }
        }

        public boolean hasNext() {
            while (!tokenizer.hasMoreTokens()) {
                String nextLine = innerNextLine();
                if (nextLine == null) {
                    return false;
                }
                tokenizer = new StringTokenizer(nextLine);
            }
            return true;
        }

        public String next() {
            hasNext();
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public long nextLong() {
            return Long.parseLong(next());
        }
    }
    
    static class QWriter implements Closeable {
        private BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));

        public void print(Object object) {
            try {
                writer.write(object.toString());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        public void println(Object object) {
            try {
                writer.write(object.toString());
                writer.write("\n");
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void close() {
            try {
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}

---

## 作者：Maxsong (赞：0)

# P12159 [蓝桥杯 2025 省 Java B] 数组翻转 题解

## 题意分析

对于任意一个连续的相同串，都满足题意，所以我们要做的就是把所有满足条件的字符串通过翻转拼到一起，使得满足条件的字符串更长。

易证可以通过翻转的操作完成拼接。

### 总结：

- 遍历整个序列，求出每个数字的第一长和第二长子串；
- 然后通过翻转操作拼接它们并且算出答案；
- 最后求最大值。

## 代码

- 使用 `minx` 和 `maxx` 进行区间优化。

> **不开 `long long` 见祖宗。**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000009],n,cnt,ans,maxx=-1,minx=2147483647;
pair<long long,long long>f[1000009];
signed main(void){
    cin>>n;
    for(long long i=1;i<=n;i++){
        cin>>a[i];
        maxx=max(a[i],maxx);
        minx=min(a[i],minx);
    }for(long long i=1;i<=n;i++){
		cnt++;
		if(i==n||a[i]!=a[i+1]){
			if(cnt>f[a[i]].first) f[a[i]].second=f[a[i]].first,f[a[i]].first=cnt;
			else if(cnt>f[a[i]].second) f[a[i]].second=cnt;
			cnt=0;
		}
	}for(long long i=minx;i<=maxx;i++){
        ans=max(ans,(f[i].first+f[i].second)*i);
    }cout<<ans<<endl;
    // for(int i=minx;i<=maxx;i++) cout<<f[i].first<<" "<<f[i].second<<endl;
    return 0;
}
```

---

## 作者：yanzixuan2024 (赞：0)

我们要想最大，肯定要把两个连续区间旋转到一起。可以用两个值装下每个数在序列中连续出现的长度的最大与次大值。最后计算所有数的两个区间旋转起来的分数的最大值。

```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
const int maxn=1e6+5;
int n;
ll a[maxn],pre[maxn];
unordered_map<int,pair<ll,ll>>mp;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld",a+i);
    for(int i=1;i<=n+1;i++){
        if(a[i]==a[i-1]) pre[i]=pre[i-1]+1;
        else{
            pre[i]=1;
            if(pre[i-1]>mp[a[i-1]].fi){
                mp[a[i-1]].se=mp[a[i-1]].fi;
                mp[a[i-1]].fi=pre[i-1];
            }else mp[a[i-1]].se=max(mp[a[i-1]].se,pre[i-1]);
        }
    }
    ll ans=0;
    for(auto i:mp)
        ans=max(ans,i.fi*(i.se.fi+i.se.se));
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P12159 题解

## 思路

假设我们要取的 $a_l = k$，那么就需要让 $k$ 的连续长度最长，可以将原数组内所有连续的值为 $k$ 的段的长度存下来，选最长的和次长的，通过一次交换使它们靠在一起，那么对于这个 $k$，能获得的最大长度就是这样。如果只有一段，那么无需翻转。

对于 $1 \le k \le 10^6$ 的每一个 $k$ 求一下答案，取最大值输出即可。

## 代码

```cpp
const int N=1000005;

int n;
int a[N];
vector<int> vec[N];

bool cmp(const int& a,const int& b) {
    return a>b;
}

int main() {
    read(n);
    _rep(i,1,n) read(a[i]);
    int las=a[1],len=1;
    _rep(i,2,n) {
        if (a[i]!=las) {
            vec[las].emplace_back(len);
            las=a[i],len=1;
        } else len++;
    }
    vec[las].emplace_back(len);
    i64 ans=0;
    _rep(i,1,N-1) {
        if (vec[i].empty()) continue;
        else if ((int)vec[i].size()==1) {
            ans=max(ans,(i64)vec[i][0]*i);
        } else {
            sort(vec[i].begin(),vec[i].end(),cmp);
            ans=max(ans,(i64)(vec[i][0]+vec[i][1])*i);
        }
    }
    write(ans);
    return 0;
}
```

---

## 作者：GLATY (赞：0)

反转数组即是将两个连续区间变为一个，所以只需要找到哪一个数的最大的两个连续区间得的分数高即可。

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.*;

public class Main {
    static InputStreamReader inputStreamReader = new InputStreamReader(System.in);
    static BufferedReader br = new BufferedReader(inputStreamReader);
    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));
    static StringTokenizer tokenizer;


    public static void main(String[] args) throws Exception {
        int n = Integer.parseInt(br.readLine());
        ArrayList<Integer[]> lis = new ArrayList<>();
        tokenizer = new StringTokenizer(br.readLine());
        if (n == 1) {
            out.println(0);
            return;
        }
        for (int i = 1; i < n + 1; i++) {
            lis.add(new Integer[]{i, Integer.parseInt(tokenizer.nextToken())});
        }
        lis.sort((a, b) -> b[1] - a[1]);
        for (Integer[] li : lis) {
            System.out.println(li[0] + " " + li[1]);
        }
        long all = n % 2 == 0 ? ((long) n) / 2 * (n + 1) : ((long) (n + 1)) / 2 * n;
        long lost = 0;
        for (int i = 0; i < n - 1; i++) {
            if (lis.get(i)[0] < lis.get(i + 1)[0] * 2) {
                lost += 2L * lis.get(i)[0];
                break;
            }
            lost += lis.get(i)[0];
        }
        all -= lost;
        out.println(all);

        close();
    }

    static void close() throws Exception {
        out.flush();
        out.close();
        br.close();
    }
}
```

---

## 作者：Ag2WO4 (赞：0)

翻转只能连接两个连续子段，于是统计每种数字前两长的连续子段的和，乘以其自身求最大值即可。复杂度 $O(n)$。
```python
from collections import*;input();a=defaultdict(list);b=c=0
for i in map(int,input().split()):
    if b-i:a[b].append(c);c=1;b=i
    else:c+=1
a[b].append(c);print(max(i*sum(sorted(a[i])[-2:])for i in a))
```

---


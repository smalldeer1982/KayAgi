# [蓝桥杯 2024 国 Python A] 特别的数组

## 题目描述

如果一个数组中的所有元素都互不相同，我们称其为一个特别的数组。

给定一个数组 $(a_1, a_2, \cdots, a_n)$，你可以选择一对 $L, R$ 并将数组中的第 $L$ 至 $R$ 个元素移除。求对给定的数组进行一次这样的操作后可以得到的特别的数组的长度最大是多少。

## 说明/提示

### 样例说明

移除第 $2, 3$ 个元素可以得到 $1 \ 4 \ 2 \ 5 \ 7 \ 6 \ 3$。

### 评测用例规模与约定

- 对于 $60\%$ 的评测用例，$n \leq 5000$；
- 对于所有评测用例，$1 \leq n, a_i \leq 10^5$。

## 样例 #1

### 输入

```
9
1 2 3 4 2 5 7 6 3```

### 输出

```
7```

# 题解

## 作者：guoshengyu1231 (赞：6)

# 题解：P12280 [蓝桥杯 2024 国 Python A] 特别的数组
## 方法一
### 思路
考虑到答案具备单调性，首先考虑二分答案。 $\\$ 
那为什么这题能用二分答案呢？ $\\$ 
首先我们要明白什么是二分答案？ 
$\\$ 

其实通俗的讲，如果说暴力枚举是一个一个猜答案的话，那二分答案就是将答案用二分查找的方式找出来。 $\\$ 
具体的，给定一个答案的范围，然后每次会算出这个范围的中间数 $mid$。接下来会有一个 $\operatorname{check}$ 函数来检测猜到的 $mid$ 是否满足题目要求，接着会根据实际情况适当修改值的范围。到最后只有一个数，就是最终的答案（其实就跟二分查找差不多，只不过查找的是答案）。
$\\$ 

那这就不得不提到二分答案的使用条件了。 $\\$ 
二分答案的使用需要同时满足以下几个核心条件： $\\$ 
- **解空间有序‌**：问题的答案必须存在于一个有序的范围内（如数值区间），且存在明确的单调性特征。也就是：
  - 当求解最大值时，若某个值 $x$ 满足条件，则所有比 $x$ 小的值也满足条件。
  - 当求解最小值时，若某个值 $x$ 满足条件，则所有比 $x$ 大的值也满足条件。

  例如，问题中出现“最大值最小化”或“最小值最大化”等双最值描述时，通常适用二分答案。
- **‌存在高效的判定函数**：对于给定的候选答案 $mid$ ，需要能在多项式时间（通常为 $O(n)$ 或 $O(n \log n)$）内验证其是否满足题目要求。
- ‌**判定逻辑独立于答案生成**：判定函数的设计应仅依赖当前候选答案 $mid$，无需预先知道其他可能的解。这种独立性使得每次二分迭代只需关注当前 $mid$ 的可行性。
 $\\$

其实说了一大堆，都只是前置知识。 $\\$ 
那么我们现在回到原题，首先看了看题目，发现满足二分答案的使用条件，所以可以使用二分答案。既然是二分答案，那么我们还是先考虑影响答案的因素吧。其实这个并不难，题目要求删除一个区间，使最终的序列最长且里面的数互不相同。那影响删除的区间的因素有区间的左右边界和区间的长度。但是他们三个中只需要确定两个就可以确定区间了。那我们该怎么选择呢？那接下来我们就要考虑那个条件是与答案有直接关系的，也就是他的优劣能确定答案的优劣，那显然是区间的长度，所以我们不妨二分删除区间的长度，在 $\operatorname{check}$ 函数中枚举删除区间的左端点。
### 实现
代码的大致框架有了，接下来需要思考如何去实现这个算法。首先二分答案部分比较简单，我们可以先不管。重点是如何去实现 $\operatorname{check}$ 函数。首先我们统计原数组中每个数出现的次数，在统计有哪些数字出现了不止一次。然后枚举移动区间的左端点，并实时记录那些数字被删除了，那些数字又恢复了。总之就是枚举一个滑动的窗口，如果有一次所有的数字都最多只出现了一次，那就说明这个答案是可行的，具体详见代码。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,a[maxn];
bool check(int x)
{
	int cnt[maxn],s=0;
	memset(cnt,0,sizeof cnt);
	for(int i=x+1;i<=n;i++)//覆盖了第一个区间，故从x+1开始计数 
	 {
	 	cnt[a[i]]++;
	 	if(cnt[a[i]]==2) s++;
	 }
	if(s==0) return true;
	for(int i=1;i+x<=n;i++)
	 {
	 	cnt[a[i+x]]--;
	 	if(cnt[a[i+x]]==1) s--;
	 	cnt[a[i]]++;
	 	if(cnt[a[i]]==2) s++;
        //滑动窗口
	 	if(s==0) return true;
	 }
	return false;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int l=0,r=n;
	while(l<r)
	 {
	 	int mid=l+r>>1;
	 	if(check(mid)) r=mid;
	 	else l=mid+1;
	 }
	cout<<n-l;
	return 0;
}
```
## 方法二
其实还有更简单且更高效的办法。 
### 思路
我们可以从方法一的思想开始想，方法一，也就是二分答案，是通过二分区间长度来求解的。那我们可不可以根本**不用**枚举区间长度，或者说可以快速算出区间长度，然后直接枚举左端点求解。那既然是通过枚举左端点 $l$，那我们就得思考左端点为 $l$ 和左端点为 $l-1$ 和的答案有什么联系。显然，$l$ 每扩大 $1$ 的范围，就能够覆盖一个数，如果这个数被覆盖，那这个区间就可以再放出一个和这个数值相同的数，也就是右端点 $r$ 可以缩小范围。在每次扩大 $l$ 的范围，都更新最短删除区间的长度就行啦！
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int n,a[maxn],ans=1e9;
bool vis[maxn];//记录每个数字是否出现再原序列中（没被删除）
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int l=1,r=n;
	while(l<=n&&!vis[a[l]]) vis[a[l++]]=true;
	while(r&&!vis[a[r]]) vis[a[r--]]=true;
    //初始化l,r
	while(l)
	 {
	 	ans=min(ans,r-l+1);//更新答案
		vis[a[--l]]=false;//扩大左边界l
		while(r&&!vis[a[r]]) vis[a[r--]]=true;//缩小有边界r
	 }
	cout<<n-ans;
	return 0;	
}
```

---

## 作者：Objective (赞：3)

# 思路与算法

## 主思路与算法
首先，题目要求的是移除一个区间后剩下的元素必须全部唯一。那么最大的剩余长度就是原长度减去被移除区间的长度。所以，问题转化为找到最小的需要移除的区间长度，这样剩下的部分就最长。因此，我们的目标应该是找到这样的一个最小的区间，当移除它之后，剩下的元素都是唯一的。

那怎么找到这个最小的区间呢？直接想到的是，如果我们能确定哪些元素是重复的，那么我们需要移除的区间必须覆盖所有重复元素中的一个或多个，使得剩下的元素不再重复。但这似乎比较复杂，因为可能有多个重复元素分布在数组的不同位置。

所以，我们思考，如何高效地找到这个最小的移除区间呢？直接暴力枚举所有可能的L和R显然不可行，因为时间复杂度会是 $O(n^2)$，对于 $n = 1 \times 10^5$ 的情况，这完全无法处理。

这时候，想到滑动窗口（双指针）的方法。滑动窗口通常用来处理子数组或子区间的问题，尤其是涉及连续元素的情况。那么，这里的问题是否可以转化为滑动窗口的问题？

滑动窗口的核心思想是维护一个窗口，使得窗口内的元素满足某种条件，而窗口外的元素满足另一种条件。例如，在这个问题中，我们的目标是找到一个窗口 $[L, R]$，当移除这个窗口后，剩下的元素都是唯一的。也就是说，窗口外的元素必须全部唯一。

换句话说，我们需要找到一个窗口，使得在数组的左右两部分（窗口左边和窗口右边）中的元素都没有重复。或者更准确地说，整个数组除了窗口内的元素之外，剩下的元素都是唯一的。

这时候，问题转化为寻找一个窗口，使得窗口外的元素都不重复。找到这样的窗口后，我们要找出其中长度最小的那个窗口，这样原数组长度减去这个窗口长度就是最大的剩余长度。

于是，滑动窗口的思路是可行的。具体来说，我们需要从数组中移除一个连续区间 $[L, R]$，使得剩余元素全为唯一，且剩余部分尽可能长。目标转化为寻找移除的最小区间长度，使得剩余元素唯一。

这个思路的关键点在于，如何高效地维护窗口外元素的出现次数，并快速判断是否满足条件。使用滑动窗口可以在 $O(n)$ 的时间复杂度内完成，因为每个元素最多被左右指针各遍历一次（计算过程中）。


## 副算法
- 哈希表模拟：通过数组 $cnt$ 直接索引元素值，统计频率，避免复杂数据结构。

# 代码

首先统计整个数组中每个元素的出现次数。如果原数组已经是所有元素唯一的（特殊情况），那么不需要移除任何区间，直接返回 $n$。否则，我们需要找到最小的窗口 $[L, R]$，使得移除这个窗口后剩下的元素唯一。

接着，使用滑动窗口的方法，维护左右指针，以及窗口外的元素的频率表。我们这里命名一个变量 $over-cnt$，表示窗口外有多少个元素的出现次数超过 $1$。右指针不断右移，将当前元素移出窗口外（即其频率减 $1$）。如果这个操作导致该元素的频率从 $2$ 变为 $1$ ，那么 $over_cnt$ 减 $1$，因为该元素在窗口外不再重复。

当 $over-cnt$ 变为 $0$ 时，说明窗口外的元素没有重复。此时，尝试收缩左指针，移动左指针，将元素重新加入窗口外（即其频率加 $1$）。如果某个元素的频率从 $1$ 变为 $2$，则 $over-cnt$ 加 $1$，此时停止收缩，记录当前窗口的长度是否为最小值。

最终，找到最小的窗口长度，原数组长度减去这个长度就是答案。

我们需要从数组中移除一个连续区间 $[L, R]$，使得剩余元素全为唯一，且剩余部分尽可能长。目标转化为寻找移除的最小区间长度，使得剩余元素唯一。

最后献上我的几篇代码：

## C++
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;
int a[MAXN];
int cnt[MAXN * 2];
int main() {
    int n;
    cin >> n;
    // 统计全局频率
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        cnt[a[i]]++;
    }
    // 计算初始重复元素种类数
    int over_cnt = 0;
    for (int i = 0; i < MAXN * 2; ++i) {
        if (cnt[i] > 1) over_cnt++;
    }
    // 若数组本身无重复，直接返回
    if (over_cnt == 0) {
        cout << n;
        return 0;
    }
    int min_win = n;
    int left = 0;
    for (int right = 0; right < n; ++right) {
        int x = a[right];
        cnt[x]--; // 移出窗口外（保留该元素）
        if (cnt[x] == 1)
            over_cnt--;
        // 当窗口外无重复时，尝试收缩左边界
        while (over_cnt == 0 && left <= right) {
            min_win = min(min_win, right - left + 1);
            int y = a[left];
            cnt[y]++; // 将元素移回窗口外（移除该元素）
            if (cnt[y] == 2)
                over_cnt++;
            left++;
        }
    }
    cout << n - min_win;
    return 0;
}
```
## C#

```csharp
using System;

public class Program
{
    public static void Main()
    {
        const int MAXN = 100005 * 2;
        int n = int.Parse(Console.ReadLine());
        string[] input = Console.ReadLine().Split(' ');
        int[] a = Array.ConvertAll(input, int.Parse);
        int[] cnt = new int[MAXN];
        // 统计所有元素频率
        foreach (int x in a)
        {
            cnt[x]++;
        }
        // 计算初始重复元素种类数
        int over_cnt = 0;
        for (int i = 0; i < MAXN; i++)
        {
            if (cnt[i] > 1) over_cnt++;
        }
        // 若数组本身无重复，直接返回
        if (over_cnt == 0)
        {
            Console.WriteLine(n);
            return;
        }
        int min_win = n;
        int left = 0;
        for (int right = 0; right < n; right++)
        {
            int x = a[right];
            cnt[x]--; // 移出窗口外（保留该元素）
            if (cnt[x] == 1) over_cnt--;
            // 当窗口外无重复时，尝试收缩左边界
            while (over_cnt == 0 && left <= right)
            {
                min_win = Math.Min(min_win, right - left + 1);
                int y = a[left];
                cnt[y]++; // 将元素移回窗口外（移除该元素）
                if (cnt[y] == 2) over_cnt++;
                left++;
            }
        }
        Console.WriteLine(n - min_win);
    }
}
```

## Java
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        final int MAXN = 100005 * 2;
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.nextLine());
        String[] input = scanner.nextLine().split(" ");
        int[] a = Arrays.stream(input).mapToInt(Integer::parseInt).toArray();
        int[] cnt = new int[MAXN];
        // 统计所有元素频率
        for (int x : a) {
            cnt[x]++;
        }
        // 计算初始重复元素种类数
        int overCnt = 0;
        for (int i = 0; i < MAXN; i++) {
            if (cnt[i] > 1) overCnt++;
        }
        // 若数组本身无重复，直接返回
        if (overCnt == 0) {
            System.out.println(n);
            return;
        }
        int minWin = n;
        int left = 0;
        for (int right = 0; right < n; right++) {
            int x = a[right];
            cnt[x]--; // 移出窗口外（保留该元素）
            if (cnt[x] == 1) overCnt--;
            // 当窗口外无重复时，尝试收缩左边界
            while (overCnt == 0 && left <= right) {
                minWin = Math.min(minWin, right - left + 1);
                int y = a[left];
                cnt[y]++; // 将元素移回窗口外（移除该元素）
                if (cnt[y] == 2) overCnt++;
                left++;
            }
        }
        System.out.println(n - minWin);
    }
}

```
## Python
```python
n = int(input())
a = list(map(int, input().split()))
from collections import defaultdict
cnt = defaultdict(int)
for x in a:
    cnt[x] += 1
over_cnt = sum(1 for x in cnt if cnt[x] > 1)
if over_cnt == 0:
    print(n)
    exit()
min_win = n
left = 0
for right in range(n):
    x = a[right]
    cnt[x] -= 1
    if cnt[x] == 1:
        over_cnt -= 1
    while over_cnt == 0 and left <= right:
        current_win = right - left + 1
        if current_win < min_win:
            min_win = current_win
        y = a[left]
        cnt[y] += 1
        if cnt[y] == 2:
            over_cnt += 1
        left += 1
print(n - min_win)
```

---

## 作者：JIN_LONG (赞：3)

## 思路：
看完题目大意后，我们会发现这题可以用二分答案写。

- 首先我们用二分的方法猜最大长度为多少。
- 接着就是最重要的查找函数了。
- 在查找函数中，首先用一个统数组来计 $a_i$ 出现的个数,然后我们要看要移除的数字中，也就是 $a_x+1$ 到 $a_n$ 中的数，如果其出现次数等于 $2$，那我们就用一个变量 $cnt$ 来计算其出现的个数。
- 这中间就可以直接特判，如果 $cnt=0$，返回 $1$ 即可。
- 然后我们再从 $1$ 枚举到 $n-x$，这里分两个步骤，一是减少 $a_i+x$ 在桶中出现的次数，在这过程中，如果消除后 $a_i+x=1$ 了，那么 $cnt$ 就要减 $1$。二是增加 $a_i$ 在桶中出现的次数，如果其出现的次数等于 $2$ 时，那么 $cnt$ 就要加上 $1$ 个。
- 在循环的过程中，如果 $cnt=0$，返回 $1$，如果循环结束，而且 $cnt$ 仍然不等于 $0$，返回 $0$。

## 代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,a[100001];
bool check(int x){
	int tong[100001],cnt=0;
	for(int i=1;i<=100000;i++)tong[i]=0;
	for(int i=x+1;i<=n;i++){
	 	tong[a[i]]++;
	 	if(tong[a[i]]==2){
            cnt++;
        }
	}
	if(cnt==0) return 1;
	for(int i=1;i+x<=n;i++){
	 	tong[a[i+x]]--;
	 	if(tong[a[i+x]]==1){
            cnt--;
        }
	 	tong[a[i]]++;
	 	if(tong[a[i]]==2){
            cnt++;
        }
	 	if(cnt==0) return 1;
    }
	return 0;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
        cin>>a[i];
    }
	int l=0,r=n;
	while(l<r){
	 	int mid=(l+r)/2;
	 	if(check(mid)){
            r=mid;
        }
	 	else l=mid+1;
	}
	cout<<n-l;
	return 0;
}
```

---

## 作者：hhy11_ (赞：3)

2025/6/14:修改了一处问题


首先看到这题考虑双指针删除的区间，用 $p$ 代表左端点，用 $q$ 代表右端点。用 $cnt_i$ 计算 $i$ 这个值出现的次数。因为 $a_i \le 10^5$，所以空间是够的。

首先，取一个不会重复的区间，从 $q+1$ 到 $n$。如果 $q=0$，即该数组没有重复，直接输出 $n$ 即可。若有重复，就要双指针左右端点，每次将右端点 $q$ 增加 $1$，保持删除了这段区间之后剩下的数字互不相同，每次记录 $ans$ 即可。代码如下：


```cpp
#include<iostream>
#include<algorithm>
#include<string>
using namespace std;
typedef long long ll;
const int N = 1e6 + 7; 
ll n;
ll a[N];//原数组 
ll cnt[N];//计算每个数值出现次数 
int main(){
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
	}
	ll q = 0, p = 1, ans = 0;
	//先取一个不会重复的区间 
	for(int i = n;i >= 1;i--){
		if(cnt[a[i]] == 1){
			q = i;
			break;
		}
		cnt[a[i]]++;
	}
	//若没有重复，直接输出n 
    if(q == 0){
        cout << n << '\n';
        return 0;
    }
	//双指针
	while(q <= n){
		while(cnt[a[p]] == 0 && p < q){
			cnt[a[p]]++;
			p++;
		}
		ans = max(ans, n - (q - p + 1));
		q++;
		cnt[a[q]]--;
	}
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：hwh_qwq (赞：2)

看了一下，其他题解都是用二分答案做的，我的做法比较暴力。

首先，我们只能删除一段连续的区间，所以最后剩下的就是原数列的一段前缀和一段后缀（或者只有一段前缀或一段后缀），且剩下的这部分不能有相同元素。

一种比较容易想到的方法就是先从头开始扫，每扫一个数答案加一，直到找到重复的元素，然后再从后面开始找，同样找到重复的元素就停止。

然后我们就得到了这样的代码：

```
#include<iostream>
using namespace std;
int n,a[100001],vis[100001],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int id;
	for(id=1;id<=n;id++){
		if(vis[a[id]]==0){
			ans++;
			vis[a[id]]=1;
		}
        else break;
	}
	for(int i=n;i>=id;i--){
		if(vis[a[i]]==0){
			ans++;
			vis[a[i]]=1;
		}
        else break;
	}
	cout<<ans;
	return 0;
}
```
然而，它只能得到六十分。

看一下下面这个例子：
```
6
1 3 3 4 2 3
```
对于这个例子，这个程序会先从头往后扫，扫到第三个元素时发现重复，再从末尾开始往前扫，在最后一个元素发现重复，最后得到答案 $2$。正确的做法是删除第二和第三个元素得到答案 $4$。

造成错误的原因是这份代码在从末尾往前扫的时候，如果发现和先前找到的原数列的前缀有重复，总是会让后面“妥协”，实际上只要让任意一边在这里停止扫描就行了。所以，当一边的元素在另一边出现过时，我们要判断一下让哪边“妥协”更优。

判断让哪边妥协比较麻烦，前面那份代码是先扫前面再扫后面，总是让后面“妥协“，所以先扫后面再扫前面即可总是让前面的“妥协”，我们把“总是让前面的妥协”和“总是让后面的妥协”的方法都做一遍，把得到的两个答案取最大值即可。

以下是我的 c++ 代码，由于题目为 python 考题，同时给出由 AI 转换后的 python 代码（本人太菜了，不会 python）。

c++：
```
#include<iostream>
using namespace std;
int n,a[100001],vis1[100001],vis2[100001],ans1,ans2;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	int id;
	for(id=1;id<=n;id++){
		if(vis1[a[id]]==0){
			ans1++;
			vis1[a[id]]=1;
		}
        else break;
	}
	for(int i=n;i>=id;i--){
		if(vis1[a[i]]==0){
			ans1++;
			vis1[a[i]]=1;
		}
        else break;
	}
	
	for(id=n;id>=1;id--){
		if(vis2[a[id]]==0){
			ans2++;
			vis2[a[id]]=1;
		}
        else break;
	}
	for(int i=1;i<=id;i++){
		if(vis2[a[i]]==0){
			ans2++;
			vis2[a[i]]=1;
		}
        else break;
	}
	cout<<max(ans1,ans2);
	return 0;
}
```
python：
```
n = int(input())
a = list(map(int, input().split()))
vis1 = [0] * (100002)
vis2 = [0] * (100002)
ans1 = ans2 = 0

id = 0
while id < n:
    if vis1[a[id]] == 0:
        ans1 += 1
        vis1[a[id]] = 1
        id += 1
    else:
        break

i = n - 1
while i >= id:
    if vis1[a[i]] == 0:
        ans1 += 1
        vis1[a[i]] = 1
    else:
        break
    i -= 1

id = n - 1
while id >= 0:
    if vis2[a[id]] == 0:
        ans2 += 1
        vis2[a[id]] = 1
        id -= 1
    else:
        break

i = 0
while i <= id:
    if vis2[a[i]] == 0:
        ans2 += 1
        vis2[a[i]] = 1
    else:
        break
    i += 1

print(max(ans1, ans2))
```

---

## 作者：lzh20131111 (赞：1)

# 题解：[P12280 [蓝桥杯 2024 国 Python A] 特别的数组](https://www.luogu.com.cn/problem/P12280)
~~蒟蒻第一次写题解好紧张~~  
有很多大佬用的二分诶，那还是写双指针吧（~~虽然双指针用的人也很多~~ ）  
那么话不多说，直接开始。
## 题意
现在有一个数组，删掉最短的一段区间，使剩余部分没有重复的数字，输出剩余部分的长度。
## 思路
为什么用双指针呢？我们来想一下，题目里说让我们找一段最短的区间，从而使剩下的最长，那么我们可以遍历 $l$，使程序时间复杂度来到 $O(n)$。这时不知道双指针的朋友就要问了，那 $r$ 怎么办呢，总不成继续遍历一遍，那时间复杂度不还是 $O(n^2)$ 吗？有什么用。（知道的大佬可以跳过）
>### 专栏：双指针
>首先我们要知道，双指针有很多种，这里只介绍滑动窗口这一种。
>>#### 滑动窗口需要具备的条件
>>滑动窗口需要具备以下条件：
>>* 数列单调不减
>>* 请看第一点
>>  
>滑动窗口需要具备的条件就只有这一点。不明所以的朋友就说了：样例的数列也没有单调不减吧，你看 `1 2 3 4 2 5 7 6 3` 是单调不减吗？这里的单调不减不是这样理解的。假设 $l$ 不变，那么如果有一个区间 $[l,r]$ 去掉后剩下的数列是不重的，那么 $r$ 再增加剩下的数列肯定不会有重复元素存在。这也是单调不减的一种。由于这个区间很像在窗框里滑来滑去的窗户，所以叫滑动窗口。

回到题目，我们说在 $l$ 不动的情况下 $r$ 动到满足条件的的地方，然后将总长度减去这个区间长度和之前存的长度作比较，留短的那个就行。
***
到这里可能还有人有问题：这 $l$ 不是动了吗？那么当 $l$ 增加，我们之前存的 $r$ 是在 $l-1$ 为左端点情况下最小的右端点。那么现在第 $l-i$ 个点被释放出来，可能会导致又有新的重复出现，旧 $r$ 已经不行了，更何况 $r-1,r-2,r-3$ ....... 那 $r$ 就只用加就行了。
## 代码
终于到喜闻乐见的代码环节了，直接上代码！
```c++
#include <iostream>
using namespace std;

const int MAX_SIZE = 100010;
int n;  // 这是数组的长度
int Counts;  // 记录重复元素的数量
int f[MAX_SIZE];  // 记录每个数字出现的次数
int arr[MAX_SIZE];  // 存储输入数组
int ans;  // 存储最终结果
int right;  // 滑动窗口右边界

int main() {
    cin >> n;  // 朴实无华的cin、cout
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
        // 如果某个数字出现第二次，增加重复计数
        if (++f[arr[i]] == 2) {
            Counts++;
        }
    }

    // 如果没有重复元素，直接输出数组长度
    if (Counts == 0) {
        cout << n;
        return 0;
    }

    // 双指针（滑动窗口）算法寻找最长无重复子数组
    for (int left = 0; left < n; left++) {
        // 移动右边界直到没有重复元素
        while (Counts > 0 && right < n) {
            if (--f[arr[right]] == 1) {
                Counts--;
            }
            right++;
        }
        
        // 更新最大长度
        if (Counts == 0) {
            ans = max(ans, n - right + left);
        }
        
        // 移动左边界，可能需要增加重复计数
        if (++f[arr[left]] == 2) {
            Counts++;
        }
    }

    cout << ans;
    return 0;
}
```

---

## 作者：tengteng666666 (赞：0)

### 思路：
这道题就是要我们从一个数组中切掉连续的一段，剩下的部分不能有重复数字，而且剩下的部分要尽可能长。

简单来说就是：
1. 先看看从右边开始能有多少不重复的数字（记下来）。
2. 然后从左边开始一个个加数字，如果发现有重复就停。
3. 每次加左边数字的时候，如果这个数字在右边出现过，就要把右边对应的数字去掉。
4. 最后比较各种切法，找出能保留最多数字的方案。

就像切蛋糕一样，我们要找到切掉哪一块后，剩下的蛋糕块最大而且每块口味都不一样。代码里用两个标记数组来记录左右两边出现的数字，通过滑动窗口的方式找到最优解。
### C++ 代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int a[N],f[N],g[N];
int n,x,r,ls,ans;
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    x=0;
    for(int i=n;i>=1;i--){
        if(!g[a[i]]){
            g[a[i]]=1;
            x++;
        }else{
            r=i+1;
            break;
        }
        if(i==1)r=1;
    }
    ans=x;
    ls=0;
    for(int i=1;i<=n;i++){
        if(f[a[i]])break;
        f[a[i]]=1;
        ls++;
        if(g[a[i]]){
            while(r<=n){
                g[a[r]]=0;
                x--;
                if(a[r]==a[i]){
                    r++;
                    break;
                }
                r++;
            }
        }
        ans=max(ans,ls+x);
    }
    cout<<ans;
    return 0;
}
```
### Python 代码：
```python
import sys
N = 10**6 + 5
a = [0] * N
f = [0] * N
g = [0] * N
n = x = r = ls = ans = 0

def main():
    global n, x, r, ls, ans
    n = int(sys.stdin.readline())
    a[1:n+1] = list(map(int, sys.stdin.readline().split()))
    x = 0
    for i in range(n, 0, -1):
        if g[a[i]] == 0:
            g[a[i]] = 1
            x += 1
        else:
            r = i + 1
            break
        if i == 1:
            r = 1
    ans = x
    ls = 0
    for i in range(1, n + 1):
        if f[a[i]] != 0:
            break
        f[a[i]] = 1
        ls += 1
        if g[a[i]] != 0:
            while r <= n:
                g[a[r]] = 0
                x -= 1
                if a[r] == a[i]:
                    r += 1
                    break
                r += 1
        ans = max(ans, ls + x)
    print(ans)

if __name__ == "__main__":
    main()
```

**将 C++ 代码转化为 Python 代码的工作由 deepseek 完成。**

---

## 作者：Zqx_Vector_2014 (赞：0)

这乍一看，是二分，细一看，还是二分。反正本人认为暴力会炸 ~~（好像不是可能，是肯定）~~。

二分题中最重要的就是 $\operatorname{check}$ 函数，所以接下来重点讲 $\operatorname{check}$ 函数。

- 在查找函数中，首先用一个桶数组来计 $a_i$ 出现的个数,然后我们要看 $a_i+1$ 到 $a_n$ 中的数，如果其出现次数等于 $2$，那我们就提前设好的变量 $cnt$ 来计算其出现的个数。

- 但作为一份 ~~达标~~ 二分代码，怎么能没有特判呢，如果 $cnt=0$，返回 $1$ 即可。

- 然后我们再从 $1$ 枚举到 $n-x$，先减少 $a_i+x$ 在桶中出现的次数，在这过程中，若消除后 $a_i+x$ 等于 $1$ 了，那么 $cnt$ 就要减少一个 $1$。再增加 $a_i$ 在桶中出现的次数，若其出现的次数等于 $2$ 时，那么 $cnt$ 就要加上 $1$ 个。

- 在循环的过程中，如果 $cnt=0$，返回 $1$，如果循环结束，而且 $cnt$ 仍然不等于 $0$，返回 $0$。

# Code：

## C++：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],l,r;int mid;
bool check(int x){
	int tong[100001],cnt=0;
	for(int i=1;i<=100000;i++) tong[i]=0;
	for(int i=x+1;i<=n;i++){
		tong[a[i]]++;
		if(tong[a[i]]==2) cnt++;
	}if(cnt==0) return 1;
	for(int i=1;i+x<=n;i++){
		tong[a[i+x]]--;
		if(tong[a[i+x]]==1) cnt--;
		tong[a[i]]++;
		if(tong[a[i]]==2) cnt++;
		if(cnt==0) return 1;
	}return 0;
}int main(){
	cin>>n;r=n;
	for(int i=1;i<=n;i++) cin>>a[i];
	while(l<r){
		mid=(l+r)/2;
		if(check(mid)) r=mid;
		else l=mid+1;
	}cout<<n-l;
	return 0;
}
```

## Python：

```python
def check(x,n,a):
 tong=[0]*100001
 cnt=0
 for i in range(x+1,n+1):
  tong[a[i]]+=1
  if tong[a[i]]==2:
   cnt+=1
 if cnt==0:
  return True
 for i in range(1,n-x+1):
  tong[a[i+x]]-=1
  if tong[a[i+x]]==1:
   cnt-=1
  tong[a[i]]+=1
  if tong[a[i]]==2:
   cnt+=1
  if cnt==0:
   return True
 return False

n=int(input())
a=list(map(int,input().split()))
a=[0]+a
l,r=0,n
while l<r:
 mid=(l+r)//2
 if check(mid,n,a):
  r=mid
 else:
  l=mid+1
print(n-l)

```

---


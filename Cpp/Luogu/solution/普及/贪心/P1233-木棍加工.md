# 木棍加工

## 题目描述

一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：

- 第一根棍子的准备时间为 $1$ 分钟。
- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\ge l_i$、$w\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。

计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 5000$，$1 \le l_i, w_i \le {10}^4$。

## 样例 #1

### 输入

```
5
4 9 5 2 2 1 3 5 1 4
```

### 输出

```
2```

# 题解

## 作者：学无止境 (赞：58)

有的题解存在一些问题，而数据好像有一点水，导致他们好像也 $AC$ 了，在这里讲一下。
这里主要指出，在对木棒排序的时候，应当以长度 $l$ 降序， $l$ 相同时按    $w$ 降序，忽略了按 $w$ 降序这一环节的会被以下数据 $hack$：

```
3
1 1
1 2
1 3
```

答案是应当是 $1$ , 然而有题解会给出 $3$  $QwQ$

解题思路大概提一下：因为题目要求二维数据都**不上升**，那么这就启发我们先排序(按上面的方法)，最后计算另一维的序列中**最少分割为多少个不上升子序列**(满足加工顺序),由~~不会证的~~$dilworth$定理 , 答案与该序列的**最长上升子序列长度**相同，这个问题很容易 $dp$ 求解。

$O(n^2)$与$O(nlog_2n)$的 $dp$ 应该都可以通过本题，$O(n^2)$算法大家应该都会这里就不多提了。


大概讲一下$O(nlogn)$的方法：$f[i]$ 表示长度为 $i$ 的(木棒宽度的)上升子序列结尾最小是多少，在 $f[ans]$ 比当前木棒宽度小时更新 $ans$ ，否则二分查找( $f$ 数组显然单调)找到比当前木棒宽度大的第一个位置更新。

这里就可以说明为什么要 $l$ 相同时按    $w$ 降序，我们需要答案尽量小，而以 $w$ 降序时可以不浪费时间的按顺序加工完，因此这样排序，对应到模型里就是减少最长上升子序列的长度(按上面的例子，宽度序列需要为 $3$ $2$ $1$而非 $1$ $2$ $3$ , 后一种加工方法浪费了时间)

给出$O(nlogn)$ 代码。

$Code$：
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;

#define lenc 100000

inline char gc()
{
	static char buf[lenc],*p1,*p2;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,lenc,stdin),p1==p2)?EOF:*p1++;
}

inline int read()
{
	register int q=0;
	register char c=gc();
	while(!isdigit(c))
		c=gc();
	while(isdigit(c))
		q=(q<<3)+(q<<1)+(c^48),c=gc();
	return q;
}
//上面是快读 忽略即可
struct stick
{
	int l,w;
}a[5010];

int n,f[5010],ans;

bool cmp(stick q,stick w)
{
	if(q.l!=w.l)
		return q.l>w.l;
	return q.w>w.w;
}

int main()

{
	n=read();
	for(register int i=1;i<=n;i++)
		a[i].l=read(),a[i].w=read();
	sort(a+1,a+1+n,cmp);
	for(register int i=1;i<=n;i++)
	{
		if(a[i].w>f[ans])
			f[++ans]=a[i].w;
		else
		{
			int tmp=lower_bound(f+1,f+1+ans,a[i].w)-f;
			f[tmp]=a[i].w;
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：固执 (赞：54)

# 思想：贪心 + DP
~~看大佬们太强了，题解我看不懂~~

这题一看就是贪心，~~因为题目讲了~~

先按长度排序，长度相同，按宽排序。
代码顺序：
```cpp
int main() {
输入n、a[i]，对a[i]排序
dp并更新答案，覆盖ans
输出ans+1
结束
}
```
核心代码 dp:
```cpp
for(int i=2; i<=n; i++) { //dp start
		for(int j=1; j<i; j++) { 
			if(a[j].r>a[i].r) {//判断
				dp[i]=max(dp[j]+1,dp[i]); //dp
			}
		}
		ans=max(dp[i],ans);//记录答案
}
```
于是，这题的大体思路就出来了~
完整代码（请不要抄袭题解）：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int l,r;
} a[11000];
int n;
int dp[11000]= {0},ans;
bool cmp(node x,node y) { //compare
	if(x.l==y.l) return x.r<y.r; //按长度排序，长度相同按宽度排序
	return x.l<y.l;
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i].l>>a[i].r; //输入
	sort(a+1,a+1+n,cmp);//排序
	for(int i=2; i<=n; i++) { //dp start
		for(int j=1; j<i; j++) {
			if(a[j].r>a[i].r) {//如果第j个木棍的宽大于第i个木棍的宽（类似于选择排序全部枚举一遍）
				dp[i]=max(dp[j]+1,dp[i]);//执行dp
			}
		}
		ans=max(dp[i],ans); //记录答案
	}
	cout<<ans+1; //最后加上1，因为至少有一种方案
	return 0; //end
}
```


---

## 作者：Vozeo (赞：20)

#### 贪心。

先将长度排序，再依次寻找宽度不上升序列，将它们全部标记，最后寻找没有被标记的。


dalao们说可以用dp做，蒟蒻不会。


第一次写题解，求支持。


下附AC代码。


```cpp
#include<iostream>
#include<algorithm>
using namespace std;

struct thing{
    int lo,wi;
}t[5005];//木棍定义为结构体

bool comp(thing &a,thing &b){
    if(a.lo==b.lo)return a.wi>b.wi;
    return a.lo>b.lo;
}//定义比较函数，先按从高到低排列长度，长度相同的按从高到低排列宽度

bool used[5005]={};//是否被处理过

int main(){
    ios::sync_with_stdio(false);//取消输入流同步，加快输入速度
    int n,sum=0,twi;
    cin>>n;

    for(int i=1;i<=n;i++){
        cin>>t[i].lo;
        cin>>t[i].wi;
    }//输入
    
    sort(t+1,t+n+1,comp);//排序

    for(int i=1;i<=n;i++){//双重循环
        if(used[i]==0){//如果这个木棍被处理过就跳过
            twi=t[i].wi;//保存现有宽度
            for(int j=i+1;j<=n;j++){//向后搜索
                if(t[j].wi<=twi&&used[j]==0){//如果有宽度小于现有宽度且没有被处理过
                    used[j]=1;//处理这个木棍
                    twi=t[j].wi;//保存这个木棍的宽度
                }
            }
        }
    }
    
    for(int i=1;i<=n;i++){
        if(used[i]==0)sum++;//如果没用过就加1分钟
    }
    
    cout<<sum;//输出
    return 0;
}
```

---

## 作者：Brainless (赞：17)

## 这里提供一种STL的写法
看到大多数是O(n^2)的打法，也有很多直接写二分的，但是表忘了还有两个叫做upper_bound()和lower_bound()的东西。

这道题目首先就应该想到要把长度进行排序，然后再继续处理重量，这样子其实就是在长度单调的时候，寻找重量上需要多长时间。

poj好像和这里是反的，但没有关系，并不影响结果，因为分离出来的不下降子序列和不上升子序列的数量是一样的。

这里普及一个知识点，最长不降序列的数量 == 最长下降子序列的长度
原理可以自己手摸一下。。。

将长度从小到大排序，这样子就转化成了在重量上求不下降子序列数量的问题了；
这里dp[i]用来存长度为i的下降子序列最后一个元素的最大值，由于dp[i]是严格递减的，所以我们就可以用二分来更新最大值，找到最后一个小于等于当前重量的木棍，更新dp值，就可以通过查询最后一个没被更新的元素来判断最长下降子序列长度，也就是不降子序列的数量 == 耗费的时间。

```cpp
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <cmath>
#include <vector>
#include <string>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
#define fir first
#define sec second
#define rep(i,a,b)  for(int i=a;i<=b;++i)
#define per(i,a,b)  for(int i=a;i>=b;--i) //懒人
using namespace std;
pair<int, int> lw[5011]; //pair可以直接排序，很方便
int dp[5011];
int main()
{
	
	int n;
	cin >> n;
	rep(i, 1, n)
	{
		cin >> lw[i].fir >> lw[i].sec;
	}
	sort(lw + 1, lw + 1 + n); //从小到大排序（poj上是从小到大）
	memset(dp, -1, sizeof dp);
	rep(i, 1, n)
	{
		*lower_bound(dp + 1, dp + n + 1, lw[i].sec, greater<int>()) = lw[i].sec;
        	//找到最后一个小于等于当前重量的木棍，更新dp值
	}
	cout << lower_bound(dp + 1, dp + n + 1, -1, greater<int>()) - dp - 1 << endl;
	
    return 0;
}
```
相当简洁的代码。

[导弹拦截](https://www.luogu.org/problem/P1020)
这是一道类似的题，没有写的可以去练练手 ：）



---

## 作者：CYJian (赞：15)

主要思路：


这道题一眼看过去就可以贪心。。


首先可以按L排序。。


显然排序之后我们就可以抛开L不管了。。


然后就可以愉快的贪心了。。


--------------------------------------------------------------------

细节：


这道题可以看成用  最少的合法序列（详见原题）  装下所有木棍。。


可以考虑用一种数据结构来记录序列最末端的木棍。。


**可以考虑先按上述思路排序，**


**然后每次加木棍时加在第一个大于等于当前木棍宽度的木棍的序列末端，**


**然后顶替掉找到的这一位。**


**如果找不到这样的木棍就再开一个序列。。** （本题贪心的核心思想）


然而我懒得多动手，就用了STL的set来维护每个序列的末端木棍的宽度。。


set是C++中自带的红黑树（二叉平衡树），可以很方便地查找、插入和删除。


时间复杂度都是log级别。。


显然时间复杂度O(nlogn), 空间复杂度O(n)


不说别的了直接上代码（带注释）：









    
    
    


    




```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5000;
int n, ans;
struct P {
    int a, b;
    friend bool operator < (P x, P y) { //set套结构体要重载<运算符
        return x.b < y.b;
    }
}s[N + 1];
bool cmp(P x, P y) { //将木棍按长度排序
    if(x.a != y.a) return x.a > y.a;
    return x.b > y.b;
}
set<P>a;
set<P>::iterator it; //定义一个set<P>的迭代器
int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) 
        scanf("%d%d", &s[i].a, &s[i].b);
    sort(s + 1, s + 1 + n, cmp); //按照长度排序
    for(int i = 1; i <= n; i++) {
        if(a.empty()) a.insert(s[i]), ans++; //一定要这一步，不然没有元素时直接lower_bound会RE
        else {
            it = a.lower_bound(s[i]); //用lower_bound找到第一个大于等于当前木棍宽度的木棍
            if(it == a.end()) a.insert(s[i]), ans++; //没有这样的木棍就再开一个序列
            else a.erase(it), a.insert(s[i]); //否则就不用开，然后把这个木棍顶替掉之前这个序列的末尾木棍
        }
    }
    printf("%d\n", ans); //输出答案（实际上就是a.size()）
    return 0;
}
```

---

## 作者：Dvelpro (赞：10)

这个题自己也做的很迷不知道自己是怎么弄得 就 ac了  说下贪心的思路 排序 按照 长度从大到小 相等的话就 宽度递减

n^2的循环 每次从最大的开始往下找  用一个数组标记 找过的就直接跳过


下面附上 蒟蒻的代码`




```cpp
`#include<bits/stdc++.h>
using namespace std;
#define maxn 5000+10
bool fa[maxn];
struct ac{
   int x,y;
}a[maxn];
bool cmp(ac q,ac w){
   if(q.x!=w.x) return q.x>w.x;
   return q.y>w.y;
}
int main(){
   int n;
   cin>>n;
   for(int j=0;j<n;j++){
      cin>>a[j].x>>a[j].y;
   }
   sort(a,a+n,cmp);
   int ans=0;
   memset(fa,0,sizeof(fa));
   for(int j=0;j<n;j++){
      if(fa[j]==1) continue;//被标记就跳过
      else{
        ans++;
        int tx=a[j].x;
        int ty=a[j].y;
        fa[j]=1; 
        for(int k=0;k<n;k++){
           if(!fa[k]&&a[k].x<=tx&&a[k].y<=ty){
              tx=a[k].x;   //依次往下找最小的 找完之后标记一下 防止二次被找
              ty=a[k].y;
              fa[k]=1;
             // cout<<k<<endl;
           }
        }
      }
   }
   cout<<ans<<endl;
   return 0;
}
``
```

---

## 作者：香风智乃 (赞：7)

排序+（稍微有些改动的）最长不下降子序列

本蒟蒻受到 P1020导弹拦截的启发（所以第一次10分钟写掉一题黄dp）

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct data{
    int l,w;
}a[5003];
int b[5003],n;
bool cmp(const data &x,const data &y)
{
    if(x.l!=y.l) return x.l>y.l;
    return x.w>y.w;
}  //排序，保证按长度从大到小并且在**前条件**下宽度从大到小
void print()
{
    for(int i=1;i<=n;i++)
        printf("%d ",b[i]);
    printf("\n\n");
    return ;
}
int main()
{
    int i,j;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&a[i].l,&a[i].w);
    }
    sort(a+1,a+n+1,cmp);
    for(i=n;i>=1;i--)
        for(j=i+1;j<=n;j++)
        {
            if(a[i].l<a[j].l&&b[i]<b[j]+1)
                b[i]=b[j]+1;
            else
            {
                if(a[i].w<a[j].w&&b[i]<b[j]+1)
                    b[i]=b[j]+1;
            }
        }
    int ans=0;
    for(i=1;i<=n;i++)
        ans=max(ans,b[i]);  //以上就是最长下降子序列+小改动（基础dp，自行理解）
    //print();     //检查函数，把中间数据调出来检查，防止错误的程序也能过样例的情况（蒟蒻专用）
    printf("%d",ans+1);
    return 0;
}
```

---

## 作者：zclzslz (赞：7)

本题标签是DP，但我却用的是贪心。。。

先按长度从大到小排序，长度相同的按宽度排序

从第一个木棍开始，能不用准备就开始加工的就加工，再继续往下扫即可

详见代码


```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,tot(0),times(0),used[5005];
struct p
{
     int l,r;
}a[5005];
bool cmp(p a,p b)
{
        if(a.l==b.l)
        return a.r>b.r;
        return a.l>b.l;
}
void handle()
{
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            tot++;
            scanf("%d %d",&a[tot].l,&a[tot].r);    
        }
        int now(1);//先加工第一个木棍，now记录当前加工哪一个木棍
    sort(a+1,a+1+n,cmp);//排一遍序
    while(1==1)
    {
        times++;//每次都先准备加工now
        for(int i=1;i<=n;i++)
        {
            used[now]=1;//used[]记录该木棍已被加工
            if(a[i].l<=a[now].l&&a[i].r<=a[now].r&&!used[i])//如果加工木棍i不需要耗费准备时间就加工他，这里要加等于号！我一开始没加只得
   //了60，还以为是贪心策略不对。。。
            {
                used[i]=1;
                now=i;//now要移动，表示加工这个木棍
            }
        }
        bool p(0);//检验一下是否全部加工完毕
        for(int i=1;i<=n;i++)
        {
            if(!used[i])
            {
                if(!p)
                now=i;//如果有没被加工的，那么下一次要先加工靠前的
                p=1;
            }
        }
        if(!p)break;//如果全加工完就break;
    }
    printf("%d\n",times);
    return ;
}
int main()
{
    handle();
    return 0;
}
//贪心也还是有用的！
```

---

## 作者：MRZMRZ (赞：7)

此题感觉有点迷。DP和贪心其实都可以做啊。时间复杂度似乎都能过。

不论DP还是贪心，我们都能想到应该按其中一个关键字进行排序。如此操作，才能保证前面的木料 _**有可能**_ 令下面的木料不用准备。到底要不要准备呢？此时做一趟最长不上升子序列即可。

然而，众所周知，最长不上升子序列是要用DP解决的。为什么贪心也可以过呢？是因为DP求的是最长子序列长度，当然可以解决这个问题。但我们可以发现，此题没有必要求长度，我们需要求到底有几个这样的子序列。于是贪心策略可以帮我们解决这个问题。

即使如此，OI考试的时候还是推荐使用DP，毕竟贪心在自己心中没底的时候，真的很迷，一不小心就爆零了。ACM比赛就随意了。

就比如此题的贪心，必须严格模拟，不然很可能会炸。

以下是核心代码：
``` cpp
for(int i=2;i<=n;i++) {
        bool bo=0;//判断是否可加入之前序列
        for(int j=1;j<=ans;j++) {//枚举之前序列
            if(a[i].x<=ls[j].x&&a[i].y<=ls[j].y) {
                ls[j]=a[i];//a即木料的数据，ls记录每个序列的末尾元素
                bo=1;
                break;
            }
        }
        if(bo==0) {
            ans++;
            ls[ans]=a[i];
        }
    }
```
上面的当然是AC的，下面是一段跑炸了的代码：
``` cpp
for(int i=2;i<=n;i++) {
        bool bo=0;
        for(int j=ans;j>=1;j--) {
            if(a[i].x<=ls[j].x&&a[i].y<=ls[j].y) {
                ls[j]=a[i];
                bo=1;
                break;
            }
        }
        if(bo==0) {
            ans++;
            ls[ans]=a[i];
        }
    }
```
区别在于枚举之前序列变为倒序了，然后WA一片。这是为什么？如果手模的话，是挺显然的，但怎么证明是个问题。感性理解一下还是可以的。

附上完整贪心代码：
``` cpp
//ZJ_MRZ's Code
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#define N 5010
using namespace std;
struct mrz {
    int x,y;
} a[N],ls[N];
int n,ans=0;
bool cmp(mrz k1,mrz k2) {
    if(k1.x!=k2.x)
        return k1.x>k2.x;
    else
        return k1.y>k2.y;
}
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].x,&a[i].y);
    sort(a+1,a+n+1,cmp);
    ans++;
    ls[1].x=a[1].x;
    ls[1].y=a[1].y;
    for(int i=2;i<=n;i++) {
        bool bo=0;
        for(int j=1;j<=ans;j++) {
            if(a[i].x<=ls[j].x&&a[i].y<=ls[j].y) {
                ls[j]=a[i];
                bo=1;
                break;
            }
        }
        if(bo==0) {
            ans++;
            ls[ans]=a[i];
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
希望可给大家提供帮助。

---

## 作者：zhuixun_ (赞：5)

不行，我也来发个题解。
其实就是求最长上升子序列（参见diworth定理，序列的不下降子序列最少划分数等于上升序列的总长度）
+ 首先需要做的是先将序列排序（这里采取的是先将序列的l值升序，再将序列的w值升序）
+ 在求解最长上升子序列时，保证在$j<i$时，$a[i].l>a[j].l\&\&a[i].w<a[j].w$即可更新$f[i]=max(f[i],f[j]+1)$

以测试数据为例：
输入：
```cpp
5
10 18
18 6
10 19
19 13
20 8
```
输出：
```
3
```
可以理解为最后加工的组数为3组，取其中一种情况，比如：
```
(10,19),(10,18);
(19,13),(18,6);
(20,8)
```
在这三组中我们一定可以找出一组最长上升子序列例如：
```
(10,18),(19,13),(20,8)
```
满足$a[i].l>a[j].l\&\&a[i].w<a[j].w$,此时更新f数组即可。




```cpp
#include <iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct node{
	int w,l;
}a[5010];
int f[5010];
bool cmp(node a,node b){
	if(a.l==b.l)
		return a.w<b.w;
	return a.l<b.l;//升序 
}
int main(int argc, char** argv) {
	int n;scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].l,&a[i].w);
		f[i]=1;
	}
	sort(a+1,a+n+1,cmp);
	int ans=-1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<i;j++){
			if(a[i].l>a[j].l&&a[i].w<a[j].w){
				f[i]=max(f[i],f[j]+1);
			}
		}
		ans=max(ans,f[i]);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：flrs (赞：3)

### ~~蒟蒻表示自己的dp学得一团糟~~
###### ~~为了完成老师的出普及场任务QAQ~~

-----------------------------------
正文由此开始：

看隔壁的大佬打了15分钟才做出来，最开始还不敢做，结果一看，这不是排序吗！ ~~自从有了STL OIer生活倍儿棒！~~

这道题看似有两个变量，其实只需要控制一个变量如长度进行排序就可以了，仔细想想很容易明白，因为只要一项不符合要求了，另一项也没有必
要看了。

## 代码很好懂，注释有详解：
```cpp
#include"iostream"
#include"cstdio"
#include"algorithm"
using namespace std;
int n,t,cnt;
bool first;
struct stick{
	int l;
	int w;
	bool used;
	stick()//因为后来我在主程序中定义了一个temp 是局部变量 所以得打清零
	{
		l=0;w=0;used=0;
	}
}a[5005];
inline bool operator <(stick a,stick b)//懒得打less 所以直接用'>'重载了'<'
{
	if(a.l!=b.l) return a.l>b.l;//单字段排序
	else return a.w>b.w;//保证先找到的更宽
}
inline bool judge(stick a,stick b)
{
	return a.w>b.w;//比较函数
}
int main(void)
{
	stick temp;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&a[i].l,&a[i].w);
	sort(a+1,a+n+1);//贪心思想
	while(cnt<n)//控制所有木棍是否全部被加工过
	{
		first=1;
		for(int i=1;i<=n;i++){
			if(!a[i].used)
			if(first)
			{
				temp=a[i];first=0;a[i].used=1;cnt++;
			}
			else if(a[i].w<=temp.w)//一定要注意取等号啊！！否则只有70分QAQ
			{
				temp=a[i];a[i].used=1;cnt++;//如果符合条件就标记
			}
		}
		t++;
	}
	printf("%d",t);
} 

---

## 作者：JustinRochester (赞：3)

[题目](https://www.luogu.org/problemnew/show/P1233)

这题实际上就是贪心吧，为什么好像很多人都说是DP...

对于任意木棍 $A_i(l_i,w_i)$，若在存在任意木棍 $A_j(l_j,w_j)$ ，使得 $l_i\geq l_j,w_i\geq w_j$，则可以在 $A_i$ 后直接接上 $A_j$ 。

而且，对于木棍 $A_j$ ，可接在 $A_i$ 后与 $A_k$ 后( $A_k$ 接在 $A_i$ 后)，那么尽量接在 $A_k$ 后（贪心）。

就此，我们把木棍按长度或者宽度升序排序，后期只需比对另一个即可。

还有一个很巧妙的地方，如果已经按上文排序，那么对于木棍 $A_i$ ，可以接在 $A_j$ 和 $A_k$ 后面( $A_j$ 排在 $A_k$ 前面，但 $A_j$ 不能接在 $A_k$ 前面)，那么接在谁的后面都是一样的。

就此可以用结构体来简化步骤。

```cpp
#include<algorithm>
#include<cstdio>
#include<cctype>
using namespace std;
int read(){
	int abs=0;char c=getchar();while(!isdigit(c)) c=getchar();
	while(isdigit(c)) abs=abs*10+c-'0',c=getchar();
	return abs;
}//读入优化 
struct node{
	int l,w;
	bool used;//判断是否已经处理过 
	node() {l=w=0;used=0;}
	void renew() {l=read();w=read();}//读入 
	bool operator < (const node &b) { return (l!=b.l)?(l<=b.l):(w<=b.w); }
	//重载<运算符，方便排序 
}stick[5000];
int main(){
	int n=read();
	for(int i=0;i<n;i++) stick[i].renew();
	sort(stick,stick+n);//将木棍按长度升序排序，后期只要比对宽度即可 
	int count=0,countu=0;//count记录需要的时间,countu记录消耗的木棍 
	while(countu!=n){//木棍还未消耗光 
		node a;//保存当前可处理的极限木棍 
		int i;
		for(i=0;i<n;i++)
			if(!stick[i].used) { a=stick[i]; break; }
		for(;i<n;i++)
			if(!stick[i].used&&a.w<=stick[i].w){
				a=stick[i];//更新当前可处理的极限木棍 
				stick[i].used=1;
				countu++;
			}
		count++;//+1s(暴力2333) 
	}
	printf("%d",count);
	return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/#)

---

## 作者：xiaosongliu (赞：1)

不得不说库自带的函数很有用。C++的lower_bound；python 的bisect都是一样实现二分查找。
此题是很简单的最长非递减序列的动态规划。 先按照“宽”主关键字，“长”次关键字倒序排序。然后再从次关键字——“长”寻找最长递增序列。序列长度就是答案。（单调非递增的列数就等于单调递增长度——也可以写贪心实现）
```python
import bisect
N = int(input())
s = []
t = input().split()
for i in range(N):
    s.append([int(t[i * 2]), int(t[i * 2 + 1])])
s.sort(key=lambda x: (x[0], x[1]), reverse=True)#排序
ans = [s[0][1]]
len = 1
for i in range(1, N):
    if s[i][1] > ans[len - 1]:
        ans.append(s[i][1])
        len += 1
    else:
        k = bisect.bisect_left(ans, s[i][1])#二分
        ans[k] = s[i][1]
print(len)

```

---

## 作者：shijunfeng00 (赞：1)

这题可以用贪心,但实际上用动规也不错

我的思路是先按照零件长度升序排列,若长度相同,则按照重量升序排列,然后以重量存入数组b

这道题实际上就转化成求数组b的最长不降子序列.用动规可以很容易解决掉.



     
```cpp
#include<bits/stdc++.h>
class wood{public:int l,w;};                   //定义一个零件类 
bool cmp(wood a,wood b)
{
    if(a.l<b.l)return true;                                 //多关键字快排
    else if(a.l==b.l&&a.w<b.w)return true;       //按照零件长度升序排列,若长度相同,则按照重量升序排列 
    return false;
}
using namespace std;
int main()
{
    int n;
    cin>>n;
    wood a[n+10];                                 //零件                                  
    for(int i=1;i<=n;i++)
        cin>>a[i].l>>a[i].w;                           
    sort(a+1,a+n+1,cmp);  
                                                  //排序 
    int b[n+10][10];
    for(int i=1;i<=n;i++)
    {
        b[i][1]=a[i].w;                           //这一步为了方便我写动规
        b[i][2]=1;
        b[i][3]=0;
    }                                            //以上为数据的初始化 
    for(int i=n-1;i>0;i--)
    {
        int l=0,k=0;
        for(int j=i+1;j<=n;j++)
        {
            if(b[j][1]<b[i][1]&&b[j][2]>l)
            {
                l=b[j][2];
                k=j;
            }
        }                                      //求a[i].w的最长不降子序列 
        if(l>0)
        {
            b[i][2]=l+1;
            b[i][3]=k;
        }
    }
    int k=1;
    for(int i=1;i<=n;i++)
        if(b[i][2]>b[k][2])
        k=i;
    cout<<b[k][2]<<endl;                     
}
```

---

## 作者：chaijing (赞：1)

这道题和一道经典的贪心题：导弹拦截问题 是一样的。只是需要把长度（或者重量）先进行结构体式由小到大排序，然后将其余一组进行处理。我是将重量排了序。

```cpp
//6.零件分组 
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int b[1001];
struct chai
{
    int l,w;
}a[1001];
int comp(const chai &c,const chai &d)
{
    if(c.w<d.w) return 1;
    if(c.w>d.w) return 0;
    if(c.l<d.l) return 1;
    return 0;
}  
int main()
{
    int n,i,k=0,max,p,j;  //k为分组数
    cin>>n;
    for(i=1;i<=n;i++)
      cin>>a[i].l>>a[i].w;
    sort(a+1,a+n+1,comp);  //结构体排序
    b[++k]=a[1].l;
    for(i=2;i<=n;i++)
    {
        p=0;
        for(j=1;j<=k;j++)
        {
            if(p==0&&a[i].l>=b[j]) p=j;
            else if(b[p]<b[j]&&a[i].l>=b[j]) p=j;   //找出前几组与该数相差最小的数
        }
        if(p==0) b[++k]=a[i].l;
        else b[p]=a[i].l;
    }
    cout<<k<<endl;
    return 0;
}
```

---

## 作者：lightningboosLXY (赞：1)

//先要把长度从小到大排序，相同就按重量从小到大排序，这时长度序列就是有序的了，接下来我们就要分组，如果重量大的话，统计就加一，以此类推。

```cpp
var l,w,fz:array [0..10010] of longint;
    n,i,j,by,zh:longint;
begin
  readln(n);
  for i:=1 to n do read(l[i],w[i]);
  for i:=1 to n-1 do
    for j:=i+1 to n do
      if (l[i]>l[j]) or (l[i]=l[j]) and (w[i]>w[j]) then //记得是要从小到大排序（我第一次就是这样错的……）
        begin
          by:=l[i];l[i]:=l[j];l[j]:=by;
          by:=w[i];w[i]:=w[j];w[j]:=by;
        end;
  for i:=1 to n do
    begin
      j:=1;//这里J是统计，不是循环变量哦
      while fz[j]>w[i] do inc(j);
      if j>zh then inc(zh);
      fz[j]:=w[i];
    end;
  writeln(zh);
end.

```

---

## 作者：Dr_殇 (赞：1)

##一道贪心，我不知道为什么算法标签是DP

##题目分析

这道题一看就知道肯定要排序，那么就随便按一个关键字排序一下，这里我用的是第一个。

对于样例，排完序后是这样的：

5 2
4 9
3 5
2 1
1 4
因为是按木棍第一个关键字排序的，所以只要没有加工过的木棍的第二个关键字无论如何都要重新准备一次。

将后面一个关键字记下来，在后面找比记下来的数小的最大数，然后再将这个数记下来，继续搜，知道搜不了为止。

##代码如下


    
    
    
```cpp
    //--新阶梯工作室防伪水印--
    //--By新阶梯工作室 闪现--
    #include <ctime>
    #include <cmath>
    #include <cstdio>
    #include <string>
    #include <cstring>
    #include <cstdlib>
    #include <iostream>
    #include <algorithm>//头文件准备
    #define in freopen (".in","r",stdin)
    #define out freopen (".out","w",stdout)
    #define INF 2147483647
    #define UNINF -2147483648ll
    #define ch char
    #define bo bool
    #define ui unsigned int
    #define ll long long//闪现为了少打几个字符，弄了好多好多宏定义
    using namespace std;
    int n,m,ans;
    bo s[5005];//记录这个木棍是否被加工过
    struct Stick{
        int a,b;
    }stick[5005];
    inline bo cmp(Stick x,Stick y){//按照第一个关键字排序，然后用第二个关键字做
        if (x.a==y.a)return x.b<y.b;
        else return x.a<y.a;
    }
    inline void work();
    int main(){
        //in;out;
        work();
        return 0;
    }
    inline void work(){
        scanf ("%d",&n);
        for (int i=1;i<=n;i++){
            scanf ("%d %d",&stick[i].a,&stick[i].b);//读入每个木棍
        }
        sort (stick+1,stick+1+n,cmp);//排序一遍
        int tmp=0,k;
        while (tmp<n){//如果都搜完了就退出
            k=0;
            while (s[++k]);//找第一个没被加工过的木棍
            s[k]=1;int h=stick[k].b;ans++;tmp++;//答案+1，将这个木棍赋为加工过，还要把第二个关键字记下来
            for (int i=k+1;i<=n;i++){
                if (!s[i]&&stick[i].b>=h){
                    h=stick[i].b;s[i]=1;tmp++;//如果这个木棍也没被加工过，就继续做，然后把这个木棍赋为加工过了，更新关键字
                }
            }
        }
        printf ("%d\n",ans);//最后输出
}
```

---

## 作者：wanxiang_zx (赞：0)

```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=6000;
int n,ans=0;
struct node{
       int l,d;
}a[maxn];
int f[maxn];
bool cmp(node A,node B)
{
     if(A.d!=B.d)
       return A.d>B.d;
     else
       return A.l>B.l;
}
int main()
{
    /*
      纯解法很简单，只需要把原结构体排序
      按照一个参数进行排序，例如按照宽度从大到小 
      然后找当前次序下另一个参数所组成的队列中
      最长单调递增序的长度 
      
      
      那么为什么？
      题目意思是有n个木棒，每个木棒分别有长度和宽度
      你可以按一定次序去加工这些木棒，如果后一根木棒规格小于等于之前一根
      就可以直接加工，否则要花费一秒钟，让你求所需最小时间
      可以想到按照一个参数进行排序，因为这样可以保证在同一次加工中（中途不准备1秒），
      一定要先加工前面的。
      至于要分成几组，这道题就是求最少分成几个单调不升序 
      而在数学上有一个推论： 
        求最少分成几个单调不升序，相当于求单调升序的长度 
    */
    
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      scanf("%d%d",&a[i].l,&a[i].d);
    sort(a+1,a+n+1,cmp);
    /* 
    传统动规，f数组f[i]表示从1开始以i为结尾的最长单调递增序长度 
    for(int i=1;i<=n;i++)
    {
      int x=0;
      for(int j=1;j<i;j++)
        if(a[j].l<a[i].l)
          x=max(x,f[j]);
      f[i]=x+1;
      ans=max(ans,f[i]);
    }
    */
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)
    {
      int x=lower_bound(f+1,f+n+1,a[i].l)-f;
      //lower_bound会找出序列中第一个大于等于x的数 
      f[x]=a[i].l;
      ans=max(ans,x);
    }
    printf("%d\n",ans);
    system("pause");
    return 0;
}

```


---

## 作者：全金 (赞：0)

此题第一眼感觉不会做，仔细思考，发现是动归

首先实排序，按a数组拍b数组更着动，这时a数组就不用管了，已经有序，而b数组只要求它的最长不上升子序列几个可以全部消去。

比如说

5
1 4
2 4
5 2
1 5
6 2
排序变成

1 4
1 5
2 4
5 2
6 2
这时
4 5 4 2 2 可以变成 4 4 2 2  和 5

所以说答案是2

程序如下:

var n,m,max,i,j,k:longint;

    a,b,f:array [0..100000] of longint;

begin
输入你不会？

排序自己写。

```cpp
    k:=1; f[1]:=b[1];  f[0]:=maxlongint;//初始化
    for i:=2 to n do
    begin
        max:=0;
        for j:=1 to k do
            if (f[j]>=b[i]) and (f[j]<f[max]) then max:=j;
        if max=0 then begin inc(k); f[k]:=b[i]; end
            else f[max]:=b[i];    //重点，靠自己理解
    end;              
```
输出，自己写。。。。。。
end.


---


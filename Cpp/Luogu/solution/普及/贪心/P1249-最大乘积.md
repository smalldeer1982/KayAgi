# 最大乘积

## 题目描述

一个正整数一般可以分为几个互不相同的自然数的和，如 $3=1+2$，$4=1+3$，$5＝1+4=2+3$，$6=1+5＝2+4$。

现在你的任务是将指定的正整数 $n$ 分解成若干个互不相同的自然数（也可以不分解，就是这个数字本身）的和，且使这些自然数的乘积最大。

## 样例 #1

### 输入

```
10
```

### 输出

```
2 3 5
30```

# 题解

## 作者：NKU_AI_HMX (赞：879)

## 不知道大家看其他的题解有没有产生很多问号？？？
（本题解修改了一些第一次提交发现的错误，感谢yhm12345同学指出。）

#### 我来帮大家理清一下这题的思路，并对其他题解做出解释和补充（我之前看的时候也比较懵）。


------------

### 以下是本题的主要思路：


   大家都清楚这题的意思，我们尽可能的把n分成更多份（都大于1）那样乘积最大。
   （这里讲一下如果分出来的数可以重复，那么有时候并不是分出的份数越多越大，比如6，分成2,2,2不如分成3,3。但是不能重复的话就不存在这样的情况，大家可以想一下。）
   以“6”为例，我们可以想到，我们先分出来一个2，然后再分出一个3......但是这样面临一个问题：“最后有余数怎么办”，比如“8”；分出来2,3还剩下3，没法再分出4，这时候怎么办呢？有的同学会想我把余数3都加到3身上，我们就分成了2和6，但是这样是最大的吗？（3和5才是最大的）
   这时候我补充一下有一篇题解中所说：
   
#### “把余数分到大的数上比分到小的数上得到的乘积更大”。
   
   实际不太准确，我们很容易证明出来如果能把数分到更小的数上，那么乘积更大（大家可以想想）。但是为什么最终是分到了大的数呢？就好比把6分成2,4，按照我们刚才的分法，先分出来了2和3最后余1，理论上我们把1给2得到的结果更大，但是我们不允许数重复，所以我们需要先把1给3，这样如果还剩下余数的话就分给2，所以当小的数被分配某个数后不会造成数的重复，那么优先给小的数分配，所以就像其他题解所说：
   
#### “从大数开始向前，依次分配1”。
 
   所以对于8我们先分配出了2,3又余3，我们先分配1给3，得到2,4这时候2可以被分配，那么我们就分配给2一个1，得到3和4，这时候还余1，我们就分配给4，得到3,5。


------------

### 这里我来解释一下点赞数最多的题解的思路。
### 以下为引用部分：


   本题要先用简单的数论和贪心找到最优解的组成方法，再用高精度乘法求积。

以2004为例，由于把2004分拆成若干个互不相等的自然数的和的分法只有有限种，因而一定存在一种分法,使得这些自然数的乘积最大。

若1作因数,则显然乘积不会最大。把2004分拆成若干个互不相等的自然数的和,因数个数越多，乘积越大。为了使因数个数尽可能地多，我们把2004分成2+3…+n直到和大于等于2004。

若和比2004大1，则因数个数至少减少1个，为了使乘积最大,应去掉最小的2，并将最后一个数（最大）加上1。

若和比2004大k（k≠1）,则去掉等于k的那个数,便可使乘积最大。

1. 例如15：s=2+3+4+5+6刚好大于15，s-15=5，所以把5去掉。

2. 又例如13：s=2+3+4+5刚好大于13，s-13=1,所以去掉2，并把5加1，即3 4 6。



####   大家可能觉得这个和我们刚才所讲的不太一样，为什么要减呢？怎么想到的呢？显然这样减，比我们一个个循环加更快。
#### 我来帮大家推导一下：
   我们分出来了2,3,4......n这n-1个数然后余数是K（1<=K<=n）。
1.  如果K==n,我们需要进行两轮分配，意思是从n分配到2还剩下1，需要再回去把1分配给最大的数（也就是n+1）最终得到3,4,5......n+2这也就应对了上文题解中的情况2；
2.  如果K<n，我们进行一轮分配就好因为我们的余数是K，那么分配到n+1-K就停止了，拿15举例，先分配出了2,3,4,5余1，我们分配到5就停止了，（n+1-K=5）。
   对于上篇题解他先分配出2,3,4......n,n+1。因为我们分出来n-1个数余数是K，而分配出n+1后会造成数不够，还差n+1-K,那么这也就对应前两行我们推导出的结果，去掉n+1-K,就相当于分配到了n+1-K，应为n+1-K经过分配后变成了，n+2-K，这不就相当于去掉了吗。所以这相当于找规律了。


------------

### 这里我再帮大家解释一下一篇题解中的dp做法，对所有数取对数。
####   我们知道背包是尽可能使装的物品总价值更大，题解中定义了一个容量为n的背包，每个的价值为ln i;
### 以下为引用部分： 


题目大意

将n(n≤10^4 )拆分成若干个互不相同数字之和(可以只有11个数)，求这些数乘积的最大值。输出方案和最大值。

题解
楼上给了很多贪心的做法，然而并不是那么容易理解。这里给一个非常容易理解然而复杂度很劣的01背包做法吧。

互不相同这个条件可以改为从1,2,⋯,n这n个数中选出一些数，使得它们的和为n。但是，01背包只能处理从a个物品中选出总共b空间的物品，使得它们的价值和最大，可是我们要求乘积呀？

在数学里，对数有一个很好的性质：

lna+lnb=ln(a×b)

假如我们要选出一些数使得它们的乘积最大，就等价于这些数的对数之和最大。

因此题目就很显然了。n个物品，背包体积为n，每个物品体积Ci 
 为i，价值Wi 为lni......(详情参考源代码)。
 
 
####   有同学有疑惑，为什么背包问题不是求容量C所装的最大价值吗？你怎么保证他能把背包装满？
### 这里我解释一下，背包一定可以装满，因为最大乘积的序列和就为n。
   不知道我有没有有讲清楚，因为背包求出来的是最大价值，如果我们剩下空间K没装，这不就相当于我们之前所说的余数K吗？所以大家认为要不要把K分配出去呢？明显是分配后的结果更大，这也就是n和n+1的分别拆开的数的最大乘积哪个更大，明显是n+1更大，所以空间不存在多余，一定会用完。
 

------------
#### （管理员审核辛苦了）
### 喜欢的话点赞吧！


---

## 作者：Heartlessly (赞：165)

## 解题思路：

本题要先用简单的数论和贪心找到最优解的组成方法，再用高精度乘法求积。

以2004为例，由于把2004分拆成若干个互不相等的自然数的和的分法只有有限种，因而一定存在一种分法,使得这些自然数的乘积最大。

若1作因数,则显然乘积不会最大。把2004分拆成若干个互不相等的自然数的和,因数个数越多，乘积越大。为了使因数个数尽可能地多，我们把2004分成2+3…+n直到和大于等于2004。

若和比2004大1，则因数个数至少减少1个，为了使乘积最大,应去掉最小的2，并将最后一个数（最大）加上1。

若和比2004大k（k≠1）,则去掉等于k的那个数,便可使乘积最大。

例如15：s=2+3+4+5+6刚好大于15，s-15=5，所以把5去掉。

又例如13：s=2+3+4+5刚好大于13，s-13=1,所以去掉2，并把5加1，即3 4 6。

## AC 代码及解释如下：

```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
const int L = 500;//设置高精度乘法长度为500左右
string mul(string a,string b)//高精度乘法a,b,均为非负整数
{
    string s;
    int na[L],nb[L],nc[L],La=a.size(),Lb=b.size();//na存储被乘数，nb存储乘数，nc存储积
    fill(na,na+L,0);fill(nb,nb+L,0);fill(nc,nc+L,0);//将na,nb,nc都置为0
    for(int i=La-1;i>=0;i--) na[La-i]=a[i]-'0';//将字符串表示的大整形数转成i整形数组表示的大整形数
    for(int i=Lb-1;i>=0;i--) nb[Lb-i]=b[i]-'0';
    for(int i=1;i<=La;i++)
        for(int j=1;j<=Lb;j++)
        nc[i+j-1]+=na[i]*nb[j];//a的第i位乘以b的第j位为积的第i+j-1位（先不考虑进位）
    for(int i=1;i<=La+Lb;i++)
        nc[i+1]+=nc[i]/10,nc[i]%=10;//统一处理进位
    if(nc[La+Lb]) s+=nc[La+Lb]+'0';//判断第i+j位上的数字是不是0
    for(int i=La+Lb-1;i>=1;i--)
        s+=nc[i]+'0';//将整形数组转成字符串
    return s;
}
string f ( int x ){//f函数用来把任意一个整型数字转化为字符串的形式。
        int i = 0, j;
        string p = "";
        char ch[10], t;
        do{
            ch[i] = x % 10 + '0';
            x /= 10;
            i++;
        }while ( x != 0 );//只要x不为0，就去掉末位。
        ch[i] = '\0';
        for ( j = 0, i--; j <= i/2; j++, i-- ){
            t = ch[j];
            ch[j] = ch[i];
            ch[i] = t;
        }
        return ch;//返回这个字符串
}
int n, c = 1, ans[1001];//ans数组用来存拆分的数字
string s[1001], m = "1";//s数组用来存每一个数字的字符串，方便做高精度乘法，m存总乘积，初值为“1”。
int main(){
    scanf ( "%d", &n );
    if ( n <= 4 ){
        printf ( "%d\n%d\n", n, n );
        return 0;
    }//特判，如果n小于5，自己本身就是最优解。
    for ( int i = 2; i <= n; i++ ){//2到n循环
        if ( n >= i )
        n -= i, ans[c++] = i, s[c-1] = f(i);//每拆分出1个数，n就减去这个数，在用s数组存下等同于这个数的字符串
        else break;//不能再拆分就终止循环
    }
    for ( int i = c - 1; i >= 1; i-- )//逆序倒推
    if ( n > 0 ) ans[i]++, s[i] = f(ans[i]), n--;//多的数分担给其他数
    if ( n > 0 ) ans[c-1]++, s[c-1] = f(ans[c-1]);//如果还多，就分担给最后一个数
    for ( int i = 1 ; i < c ; i++ ){
        cout << ans[i] << " ";//输出每个拆分数
        m = mul ( s[i], m );//每次都将等同于这个数的字符串乘给m
    }
    cout << endl << m;//输出总乘积
    return 0;
}
```

---

## 作者：GCC_ (赞：106)

**2023.12.12 更新**

二次修改完成。你谷数据该加强了。

经过本人思考验证，之前的一处思路出现了问题（当时是照着评论区改的，没有验证正确性）。现在已更正。

**2023.7.17 更新**

感谢评论区指出的错误，很抱歉对大家造成了误解。

## 题目简述

让你将一个正整数 $n$ 分解成若干个自然数之和，要求这些数的乘积最大。

## 做题步骤

1. 观察性质；
2. 得出结论；
3. 完善代码。

#### 观察性质

先举出几个简单的例子：

- $5\rightarrow2\times 3$
- $6\rightarrow2\times 4$
- $9\rightarrow2\times 3\times 4$
- $10\rightarrow2\times 3\times 5$

我们观察到，大部分分解出来的数都是较为**连续**的。

#### 得出结论

考虑这样一种**贪心**策略：

首先构造出连续一段自然数，使得和**恰好**大于或等于 $n$ ，然后找到一个合适的数并更改（如果等于 $n$ 就不更改），使得和满足要求。

例如分解一个数 $15$ ：

- 首先找到连续一段自然数： $2+3+4+5+6>15$ （为什么要从 $2$ 开始而不是 $3$ 或更大？请思考）；
- 发现 $2+3+4+5+6=20$ ，恰好与 $15$ 相差 $5$ ；
- 把 $5$ 删掉，得到 $2+3+4+6=15$ ，计算答案。

若找到的和与 $n$ 相差 $1$ ，可以直接删除 $2$ 并将最后一个数加上 $1$ 。

**注意**：当 $n=3,4$ 时并不符合上述的贪心策略，需要特判。 

#### 完善代码

```cpp
#include<iostream>
using namespace std;
int a[10001]={};
int s[10001]={};
int n,len=1;
void mul(int x)
{
	for(int i=1;i<=len;i++)s[i]*=x;
	for(int i=1;i<=len;i++)
	{
		s[i+1]+=s[i]/10;
		s[i]%=10;
	}
	while(s[len+1]>0)
	{
		len++;
		s[len+1]+=s[len]/10;
		s[len]%=10;
	}
}
int main()
{
	cin>>n;
	if(n==3)
	{
		cout<<3<<endl;
		cout<<3<<endl;
		return 0;
	}
	if(n==4)
	{
		cout<<4<<endl;
		cout<<4<<endl;
		return 0;
	}
	s[0]=s[1]=1;
	int Sum=0,tot=0;
	for(int i=2;Sum<n;Sum+=i,i++)a[++tot]=i;
	if(Sum>n+1)a[Sum-n-1]=0;
	else if(Sum==n+1)a[tot]++,a[1]=0;
	for(int i=1;i<=tot;i++)
	{
		if(a[i])
		{
			cout<<a[i]<<' ';
			mul(a[i]);
		}
	}
	cout<<endl;
	for(int i=len;i>=1;i--)
		cout<<s[i];
	cout<<endl;
	return 0;
}
```

---

## 作者：离散小波变换° (赞：74)

## 题目大意

将$n(n\leq 10^4)$拆分成若干个**互不相同**数字之和(可以只有$1$个数)，求这些数乘积的最大值。输出方案和最大值。

## 题解

楼上给了很多贪心的做法，然而并不是那么容易理解。这里给一个非常容易理解~~然而复杂度很劣~~的$01$背包做法吧。

**互不相同**这个条件可以改为从$1,2,\cdots,n$这$n$个数中选出一些数，使得它们的和为$n$。但是，$01$背包只能处理从$a$个物品中选出总共$b$空间的物品，使得它们的**价值和**最大，可是我们要求乘积呀？

在数学里，对数有一个很好的性质：

$$\ln a+\ln b=\ln(a\times b)$$

假如我们要选出一些数使得它们的乘积最大，就等价于**这些数的对数之和最大**。

因此题目就很显然了。$n$个物品，背包体积为$n$，每个物品体积$C_i$为$i$，价值$W_i$为$\ln i$。设$dp_{i,j}$为前$i$个物品总共花费了$j$的空间的最大和，转移方程：

$$dp_{i,j}=\min\{dp_{i-1,j-C_i}+W_i,dp_{i-1,j}\}$$

然后滚动数组优化一下，就可以$\mathcal O(N^2)$时间复杂度，$\mathcal O(N)$空间复杂度求出最大乘积的**方案**了。（因为答案过大，而精度不够高，因此最大乘积直接输出$\exp(dp_{n,n})$显然是不行的）

接着我们只需要写一个高精乘低精的乘法就行了。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l;i<=r;i++)
#define dn(l,r,i) for(int i=l;i>=r;i--)
using namespace std;

typedef long long LL;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0')
    w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9')
    ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =1e4+3,MAXL=1e5+3;
int n,C[MAXN],flg[MAXN];double W[MAXN],dp[MAXN];
vector <int> ans;
struct Node{
    int dt[MAXL],len; Node():len(0){memset(dt,0,sizeof(dt));}
    Node operator *(int t){
        Node res; up(1,len,i) res.dt[i]=dt[i]*t;
        up(1,len+10,i){
            res.dt[i+1]+=res.dt[i]/10,res.dt[i]%=10;
            if(res.dt[i]) res.len=i;
        }
        return res;
    }
}val;
int main(){
    n=qread(); up(1,n,i) W[i]=log(i);
    up(1,n,i) dp[i]=-INF;
    up(1,n,i) dn(n,i,j){
        if(dp[j-i]+W[i]>dp[j]) dp[j]=dp[j-i]+W[i],flg[j]=j-i;
    }
    for(int p=n;p;p=flg[p]) ans.push_back(p-flg[p]);
    dn(ans.size(),1,i) printf("%d ",ans[i-1]); puts("");
    val.len=1,val.dt[1]=1;
    up(1,ans.size(),i) val=val*ans[i-1];
    dn(val.len,1,i) putchar('0'+val.dt[i]); puts("");
    return 0;
}

```

## 其他

虽然这个算法跑得没有贪心快，但是应该是比较容易理解的（万一哪天题目改成另外一种选法，这个算法的**思想**依然适用，即化积为和。）~~而且这种算法不需要脑子，证明超简单，随手就能写出来~~

另外，如果运行上述程序，稍微打几个表也能发现规律了。前面几个题解已经讲的很详尽了，这里不再赘述。

---

## 作者：cxy004 (赞：39)

如果分解为可以是相等的自然数的和，那么分解的答案是m个3和一个2，即最大乘积是3^m\*2或者是m个3和一个4，即最大乘积是3^m\*4的形式

3\*3>2\*2\*2，最后如果有三个2，要换成两个3，这样乘积才会最大

如
10
/ \
5   5
/\ /\
2 3 2 3

如果把1993分拆成若干个互不相等的自然数的和的分法只有有限种，因而一定存在一种分法，使得这些自然数的乘积最大。

若1作因数，则显然乘积不会最大。把1993分拆成若干个互不相等的自然数的和，因数个数越多，乘积越大。为了使因数个数尽可能地多，我们把1993分成2+3…+n直到和大于等于1993。

若和比1993大1，则因数个数至少减少1个，为了使乘积最大，应去掉最小的2，并将最后一个数（最大）加上1。

若和比1993大k（k≠1），则去掉等于k的那个数，便可使乘积最大。

2+3+4+....+62＝1952<1993;

2+3+4+....+63＝2015>1993；

所以n=63。因为2015-1993=22，所以应去掉22，把1993分

（2+3+…+21）+（23+24+…+63）

这样下来积是最大的

2×3×…×21×23×24×…×63。

样例中的10也是这样

2+3+4=9<10

2+3+4+5=14>10

14-10=4

故去掉4

所以为2\*3\*5

算积要用高精


---

## 作者：ADay (赞：36)

## 我用$Ruby$水一下吧,不是“重复的解法”！
### 思路：乘数越多越好
### Step1：
找到最小的$x$,使$sum=2+3+\cdots+x>n$,并在这过程中，把$ans$乘上每一个数
### Step2:
把$sum-n$标记为$no$，剩下数的乘积就是答案，所以把$ans$除以$no$  
### Step3:
遍历2~$x$,若不为$no$就输出，然后换行输出$ans$
### 结束！ 
$Ruby$代码：
```php
n,ans,sum,x=gets.to_i,1,0,1 #一起初始化效率更高
while sum<=n #Step1 begin!
    x+=1
    sum+=x
    ans*=x
end #Ruby要打end,Step1 end!
no=sum-n #Step2 begin!
ans/=no #Step2 end!
for i in 2..x #Step3 begin!
    if i!=no
        print i," "
    end
end
print "\n",ans #Step3 end!
```
14行，比$\mathcal{Python}$还短

---

## 作者：cms061817 (赞：10)


```cpp
//这道题的方法：贪心+高精度
//首先可以通过运算得出：
//n(n+1)>(n-1)(n+2)  
//再将几个数拆分可以看出基本上是连续自然数   ( ⊙ o ⊙ )！
//所以就得出了这个结论
//将一个数拆分成2+...+x   若a[x]<=a[x-1]  那么就将最后一个
//数的值往前分配，一次分配1，直至全部分配完
//但是数字有10000，最少是乘到140吧O(∩_∩)O~
//所以肯定会超啊    所以我不得不使用高精度
//w(?Д?)w好累啊  /(ㄒoㄒ)/~~  但是我还是把他打完了 
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
int n,lena,lenb,lenc; 
int ans=0;
int an[10005];   //存答案拆分数 
char b[10005];
char a[10005];
char c[10005];
long long best;
void  cheng(){
    int x=0;
    lenc=0;
    for(int i=1;i<=lena;i++){
        for(int j=1;j<=lenb;j++){
            c[i+j-1]=c[i+j-1]+a[i]*b[j];
            c[i+j]=c[i+j]+c[i+j-1]/10;
            c[i+j-1]%=10;
        }    
    }
    if(c[lena+lenb]!=0)lenc=lena+lenb;
    else lenc=lena+lenb-1;
    for(int i=1;i<=lenc;i++){
        a[i]=c[i];
        c[i]=0;
    }
    lena=lenc;
}    //高精度乘法 
void divide(){
    int i=2;
    while(n>0){
        if(n<=i)an[i-1]=n;
        else
            an[i-1]=i;
        n=n-i;
        i++;
    }
    i-=2;
    if(an[i]<=an[i-1]){
        int w=i;
        while(an[i]!=0){
            w--;
            if(w==0)w=i-1;
            an[w]++;
            an[i]--;
        }
        i--;
    }            //将自然数拆分 
    ans=i;
    a[1]=an[1];
    lena=1;
    for(int j=2;j<=i;j++){
        int k=an[j];
        int l=0;
        while(k!=0){
            l++;
            b[l]=k%10;
            k=k/10;
        }
        lenb=l;
        cheng();    
    }
}
int main(){
    freopen("maxmul.in","r",stdin);
    freopen("maxmul.out","w",stdout);
    scanf("%d",&n);
    if(n==1){
        printf("1\n");
        printf("1");
        return 0;
    }
    else if(n==2){
        printf("2\n");
        printf("2");
        return 0;
    }
    else if(n==3){
        printf("3\n");
        printf("3");
        return 0;
    }
    else if(n==4){
        printf("4\n");
        printf("4");
        return 0;
    }
    divide();
    for(int i=1;i<=ans;i++)
        printf("%d ",an[i]);
    printf("\n");
    for(int i=lena;i>=1;i--)
        printf("%d",a[i]);
    return 0;
}
```

---

## 作者：Go灬Fire (赞：10)

先打暴力找规律，规律挺显然的

就是先找到k满足$2+3+\cdots+k\le n$且$2+3+\cdots+k+(k+1)\gt n$

$2 \cdots k$这$k-1$个数就是基础答案。

令$reminder=n-{\sum_{i=2}^k}i$，然后把$reminder$逐一倒序分配，每次给基础答案加$1$，如果$k-1$个数都加完$reminder$仍大于0，从结尾开始从新加值，直到$reiminder$为$0$。

例如$n=24$时，基础答案为$2$、$ 3 $、$4 $、$5$、$ 6$，此时$reminder=4$，从$6$开始，逐个加$1$，一直到$reminder=0$，得到的答案为$2$、$3+1$、$ 4+1$ 、$5+1$、$6+1$也就是$2$ 、$4$、$5$、$6 $、$7$(正确)；

例如$n=26$时，基础答案为$2$、$3 $、$4 $、$5 $、$6$，此时$reminder=6$，从$6$开始加$1$，加完一遍之后发现$reminder$为$1$，再次从$6$开始加$1$，最终得到$2+1$、$ 3+1 $ 、$4+1$、$ 5+1 $ 、$6+2$也就是$3$、$ 4$ 、$ 5$ 、$ 6$、$ 8$(正确)。

而在实际操作中需要用一下除法就可以啦。

```java
import java.math.BigInteger;
import java.util.Scanner;

public class LuoGuP1249 {
    public static final int MAXN=12000;
    public static int n,cnt;
    public static int[] seq=new int[MAXN];
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in);
        int n = cin.nextInt();
        int sum = 0;
        for (int i = 2; ; i++) {
            sum += i;
            if (sum > n) {
                sum -= i;
                break;
            }
            seq[++cnt] = i;
        }
        int re = n - sum;
        int add = re / cnt;
        for (int i = 1; i <= cnt; i++) seq[i] += add;
        re = re - add * cnt;
        for (int i = cnt; i >= 1 && re>0; i--,re--) {
            seq[i]++;
            if (re == 0) break;
        }
        BigInteger ans= BigInteger.ONE;
        for (int i = 1; i <= cnt; i++) {
            System.out.print(seq[i] + " ");
            ans=ans.multiply(BigInteger.valueOf(seq[i]));
        }
        System.out.println("");
        System.out.println(ans);
    }
}
```


---

## 作者：Nobody_Zhang (赞：5)

仿佛没有重载的高精度

蒟蒻我来发一个

这道题的意思就是要找出一个最优解使得乘积最大

思路我想其他题解已经提供了

那么我就介绍一下高精度的一个新玩意——————重载！

重载定义这里有一个很好的网站我就不再赘述

其实人话就是把加减乘除重新定义

下面是代码

```
#include<bits/stdc++.h>
using namespace std;
int m,ans[500],maxx,every;
struct Wint:vector<int>
{
	Wint(int n=0)
	{
		push_back(n);
		check();
	}
	Wint& check()
	{
		while(!empty()&&!back())pop_back();
		if(empty())return *this;
		for(int i=1; i<size(); ++i)
		{
			(*this)[i]+=(*this)[i-1]/10;
			(*this)[i-1]%=10;
		}
		while(back()>=10)
		{
			push_back(back()/10);
			(*this)[size()-2]%=10;
		}
	    return *this;
	}
};
ostream& operator<<(ostream &os,const Wint &n)
{
	if(n.empty())os<<0;
	for(int i=n.size()-1; i>=0; --i)os<<n[i];
	return os;
}
Wint operator*(const Wint &a,const Wint &b)
{
	Wint n;
	n.assign(a.size()+b.size()-1,0);
	for(int i=0; i!=a.size(); ++i)
	for(int j=0; j!=b.size(); ++j)
	n[i+j]+=a[i]*b[j];
	return n.check();
} 
Wint& operator*=(Wint &a,const Wint &b)
{
	return a=a*b;
}
int judge()
{
	int tmp=0;
	for(int i=2;i;i++)
	{
		tmp+=i;
		if(tmp>m)
		{
			tmp-=i;
			maxx=tmp;
			return i-2;
		}
	}
}//以上为重载部分
int main()
{
	//freopen("maxmul.in","r",stdin);
	//freopen("maxmul.out","w",stdout);
	Wint ansans=1;
	scanf("%d",&m);
	int len=judge();
	maxx=m-maxx;//这里 
	every=maxx/len;//每个平均加上多少 
	int sing=maxx%len;
	for(int i=1;i<=len;i++)
	 ans[i]=i+1+every;
	int t=len+1;
	while(sing!=0)
	{
		sing--,t--;
		ans[t]++;
	}
	for(int i=1;i<=len-1;i++)
	 {
	 	printf("%d ",ans[i]);
	 	ansans*=ans[i];
	 }
	printf("%d",ans[len]);
	ansans*=ans[len];
	printf("\n");
	cout<<ansans;
	return 0; 
}
```

---

## 作者：lixiang666 (赞：4)

```python
n=int(input())
a=[1 for i in range(1,10006)]
ans=0
out=1
i=2
p=1
while(ans<=n):
    ans=ans+i
    if p<=10000:
        a[p]=i
        p+=1
    i+=1
k=ans-n
for j in range(1,p):
    if a[j]!=k:
        print(a[j],end=" ")
        out*=a[j]
print()
print(out)

        


```
三点：

1.贪心 乘积的数越多越好

2.1不参与乘积 无意义

3.k=ans-n 比目标值多出的那个等于k的值正好可以去掉 满足和=n的条件

---

## 作者：uni老懒了 (赞：3)


我的方法是：【模拟】找序列 + 分配。

题目要求：
- 1、找最大序列
- 2、输出相乘结果

### 分析1 找序列：
根据题目要求，所求序列一定是递增序列，不包括最后两位，例如$7(25),8(26),9(234)$，仔细观察可以看出，到了$9$本应该是$27$却可以分成$234$，这其中便隐含了如下的规律:

从$2$开始，设$pre$表示上一个数，设$x$表示现在要插入的数，设n表示剩下能插入的数的和。当$(pre+1)*2 > n$ 时，$n$就是插入的最后一个数了，否则，插入的数是上一个数+$1$
#### Code:
```cpp
if((pre+1)*2 > n ) pre=n; //* 插入最后一个数
else pre++;//* 插入上一个数+1
```

思考：假如输入$13$，如果按照上面的方法。$13$的序列应该是$(238)$因为到了$8$，它跟$(3+1)*2 = 8$相等，所以就直接放上去了,然而实际上其实是$(345)$。

结论：这时候明显最后一个数过大了，把最后一个数分配给前面，上面把$8$分配给$3$和$2$就能变成$345$。
### 分析2 分配：
 分配最后一个数，保证最后一个数大于前面的数+1，例：序列$(246)$不能分成序列$(255)$！但是$(236)$可以分成$(245)$。
 
 这里有个特例：$10$的序列不是$(235)$，而是$(244)$，说明在比较最后一个与前一个时，要判断分配前后的乘积大小，取大的即可。
 
 例：$(237)$，得出分配后的序列应是$(345)$。所以分配应从前一个数开始一直往前分配，只要满足条件就一直分配。

#### Code:
```cpp	
   for(i=1;;i++){//js表示序列的长度 (从1开始)
	if(a[js]>a[js-i]+1 && a[js]>a[js-1]+1){//得保证后面的数比前面所有的数大
	a[js]--;
	a[js-i]++;
	}
  	else break;
   }
   /*特判最后一位*/ 
    int lastOne=a[js],lastTwo=a[js-1];  //分别存序列最后一个 和倒数第二个数 
    int temp=lastOne*lastTwo;			//存序列最后两个数的乘积 ，分配时用于判断大小 
    if(lastOne==lastTwo && temp < (lastOne-1) * (lastTwo+1))  
    	a[js]--,a[js-1]++;
```
#### AC Code:
```cpp
#include<bits/stdc++.h>             
using namespace std;
int a[10000],js,b[10000],len=1;     
//a存序列  b存相乘结果  js存序列位数 len存结果长度 

/*高精度与低精度相乘运算*/ 
void cal(int x){
    int carry=0,i,j,k=x,lenx=0;     //carry存进位，k用作求位数，lenx保存x的位数  
    while(k!=0) lenx++,k/=10;       //计算x的位数 
    for(i=0;i<10000;i++){           //防止错误直接全部乘 
        b[i]=b[i]*x+carry;
        carry=b[i]/10;
        b[i]%=10;
    }
    len+=lenx;
    while(b[len-1]==0) len--;       //除掉前面多余的0 
}
int main(void){
    long long i,j,n,pre=2,k,ans=1;
    cin>>n;
    /* 特判 1~4 */ 
    if(n<=4) printf("%d\n%d\n",n,n);
    else{
    /* Step 1 、找序列 */ 
    while(n){
        k=(pre+1)*2+1;                  //k存判断范围 
        n-=pre;                         //步骤1 
        a[++js]=pre;                    //步骤2 
        if(k>n) pre=n;                  //不够分了就直接插入 
        else pre++;                     //还能分，就插入上一个数+1 
    }
    /* Step 2、分配  */ 
    for(i=1;;i++){
        if(a[js]>a[js-i]+1 && a[js]>a[js-1]+1){//保证最后一个数比前面所有的数大
            a[js]--;a[js-i]++; //分配过程
		}
		else break;
    }
    /*特判最后一位*/ 
    int lastOne=a[js],lastTwo=a[js-1];  //分别存序列最后一个 和倒数第二个数 
    int temp=lastOne*lastTwo;			//存序列最后两个数的乘积 ，分配时用于判断大小 
    if(lastOne==lastTwo && temp < (lastOne-1) * (lastTwo+1))  
    	a[js]--,a[js-1]++;
    /* 输出序列 + 高精度乘法 */ 
    b[0]=1;
    for(i=1;i<=js;i++) {
    cout<<a[i]<<' ';
    cal(a[i]);
    }
   /* 输出结果 */
    cout<<endl;                         
    for(i=len-1;i>=0;i--) cout<<b[i];       //因为是倒序计算的所以就倒序输出 
    cout<<endl;
    }
}
```

---

## 作者：BoWing (赞：2)

### 贪心Master 精讲
这道题本蒟蒻直接开始无脑找规律，一小时之后终于找出来了，打完发现高精忘了。。。

很明显就知道1在分解中没有任何作用，所以不会分1；

举个例子吧9=2+3+4；很明显2 3 4便是最优解；

2 3 4 5是14的最优解；
于是就开始了艰辛的找规律之路：

5：2 3

6：2 4

7：3 4

8：3 5

9：2 3 4

10：2 3 5

11：2 4 5

12：3 4 5

13：3 4 6

14：2 3 4 5；
到这里规律就很明显了：

在两个阶乘数之间循环：

举个栗子：
5的最优解是2 3，6比5大1，前面已经说过1是浪费的，所以在2和3之间选一个数加1；
一般规律如下：

设x1=2+3+4+....+n;x2=2+3+4+....+n+n+1;

从x1往后的数的最优解为从该序列末尾依次加1；仔细研究↑的列举；

加完后还剩一个x2-1这个数，这个数的序列便是x2-2的序列的最后一项再加上1；

原谅本蒟蒻，这规律实在是太难解释了；
### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,bh,a[100001],cha,cnt=0,sum=0;
long long s[1000001],tot=1;
long long ans=1;
void work()//找规律的应用 
{
	if(n-sum==bh)
	{
		for(int i=2;i<=bh;i++)
		{
			if(i==bh)
			{
				printf("%d",i+2);
				a[++cnt]=i+2;
				break;
			}
			printf("%d ",i+1);
			a[++cnt]=i+1;
		}
		printf("\n");
		return;
	}
	int cha=n-sum;
	for(int i=2;i<=bh;i++)
	{
		cnt++;
		if(cnt>=bh-cha)
		{
			printf("%d ",i+1);
			a[cnt]=i+1;
			continue;
		}
		printf("%d ",i);
		a[cnt]=i;
	}
	printf("\n");
	return;
}
void js(int x)//高精处理连乘爆long long 
{
	for(int i=1;i<=tot;i++)
	{
		s[i]=s[i]*x;
	}
	for(int i=1;i<=tot;i++)
	{
		if(s[i]>=10)
		{
			long long add=s[i]/10;
			s[i+1]+=add;
			s[i]=s[i]%10;
			if(i+1>tot)
			tot=i+1;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=2;;i++)
	{
		sum+=i;
		if(sum==n)//若刚好是阶乘数，直接输出就好了， 
		{
			bh=i;
			for(int j=2;j<=i;j++)
			{
				printf("%d ",j);
				a[++cnt]=j;
			}
			printf("\n");
			break;
		}
		if(sum>n)//在x1和x2之间； 
		{
			sum=sum-i;
			bh=i-1;
			work();
			break;
		}
	}
	s[1]=1;
	for(int i=1;i<=cnt;i++)
	js(a[i]);//乘就好了 
	for(int i=tot;i>=1;i--)
	printf("%lld",s[i]);
	return 0;//游戏结束； 
}
```


---

## 作者：良知 (赞：2)

###### 一道数学题

楼上大佬已经讲得很明白了->把这个自然数分成几个连续自然数的和，把多余的加到最大的地方。

这题有几个坑：

1、n=3时是1,2.不能单独一个；

2、结果要用高精；

3、注意数组下标不要开小

那么，问题来了，这些都讲过了，我为什么还要发这篇题解呢？

原因在于~~精益求精~~（我的分组背包题解也是这样qaq）


地球人都知道，1+2+3+...+n=（1+n）*n/2;

那么2+3+4+...+n=（2+n）*（n-1）/2;

设得数=x（输入的n），则：

2x>=（n+1）*n-2;

2(x-1)>=(n+1)*n;

那么二分即可...(当然，谁会这么做呢？)

代码就不放了qwq，其他人都写烂了。。。

---


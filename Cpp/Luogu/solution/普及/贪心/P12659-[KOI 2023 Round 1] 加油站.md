# [KOI 2023 Round 1] 加油站

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 国家由 $N$ 个村庄组成。每个村庄从 1 到 $N$ 编号。国家中共有 $N - 1$ 条道路，每条道路连接两个不同的村庄，编号从 1 到 $N - 1$。第 $i$ 条道路连接的是第 $x_i$ 个村庄与第 $y_i$ 个村庄。

KOI 国家中的任意两个村庄之间，恰好存在一条路径将它们连接起来。

从第 $x$ 个村庄到第 $y$ 个村庄的路径可以表示为一个村庄序列：$x$ - $z_1$ - $z_2$ - ⋯ - $z_t$ - $y$，该路径满足以下两个条件：

- 路径上相邻两个村庄之间，即 $x$ 与 $z_1$，$z_1$ 与 $z_2$，⋯，$z_t$ 与 $y$ 之间都存在道路直接连接。
- 路径中不得有重复村庄。也就是说，$x$，$z_1$，⋯，$z_t$，$y$ 均为互不相同的村庄。

路径的“长度”定义为该路径上所经过的道路数，即 $t + 1$。

现在，计划在若干个村庄中设置加油站。根据 KOI 国家法律，加油站必须满足以下条件：

- 对于任意长度为 $k$ 的路径，路径中必须至少有一个村庄设有加油站。

在满足上述条件的前提下，找出设置加油站所需的最小数量。

## 说明/提示

**样例 1 说明**

只需在第 $2$ 个村庄设置加油站即可满足所有长度为 $2$ 的路径。

**样例 2 说明**

仅在第 $2$ 个村庄设置加油站不能满足所有长度为 $2$ 的路径（例如路径 $4-6-7$ 不包含加油站）。若再在第 $6$ 个村庄也设置加油站，则所有长度为 $2$ 的路径都包含至少一个加油站。因此最小加油站数量为 $2$。

**限制条件**

- 所有输入均为整数。
- $2 \leq N \leq 200\,000$
- $1 \leq k \leq N - 1$
- $1 \leq x_i, y_i \leq N$
- $x_i \ne y_i$
- 任意两个村庄之间，存在唯一一条路径相连。
- 至少存在一条长度为 $k$ 的路径。

**子问题**

1. （9 分）对于每条道路 $i$（$1 \leq i \leq N - 1$），连接的是第 $i$ 个村庄和第 $i + 1$ 个村庄。
2. （10 分）$k = 1$
3. （11 分）对于每条道路 $i$（$1 \leq i \leq N - 1$），连接的是第 $i + 1$ 个村庄和 $\lfloor \frac{i + 1}{2} \rfloor$ 个村庄。这里 $\lfloor x \rfloor$ 表示不大于 $x$ 的最大整数。
4. （12 分）$N \leq 15$
5. （15 分）$N \leq 300$
6. （17 分）$N \leq 3\,000$
7. （26 分）无额外限制

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
6 2
1 2
1 3
2 4
2 5
4 6```

### 输出

```
1```

## 样例 #2

### 输入

```
7 2
1 2
1 3
2 4
2 5
4 6
6 7```

### 输出

```
2```

# 题解

## 作者：Reply_ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P12659)

## 思路

树上问题，贪心解决。

题面告诉我们每一条长度大于等于 $k$ 的路径上都必须要有一座加油站。

对于树上的关于路径的问题，我们对于路径两端点的 $\operatorname{LCA}$ 考虑。

处于贪心的思想，对于一个点而言，我们会在**不得不建加油站**的时候建立加油站，怎么判断一个点是不得不建加油站呢，就是这个点的子树内有一条没有建立过加油站的路径，其长度大于等于 $k$ 的时候，我们不得不建加油站。

为什么这个贪心是对的，也很显然，我们希望一个加油站能影响更多的路径，所以应越靠近根节点越好，所以应当这么做。

## 实现

定义 $sum_i$ 代表以 $i$ 为根的子树中离 $i$ 最远的点距离 $i$ 的距离，但是这个点到 $i$ 的路径上不能有加油站建立过。

这样对于枚举到的 $u$，如果有两棵子树的 $sum$ 的和加 $2$ 大于等于 $k$ 那么就要建加油站（或者某一棵子树连到 $u$ 的时候直接就超过 $k$ 了，也要建）。

注意：如果决定要建加油站，那么把 $sum$ 赋值为 $-1$，这样向上传递的时候才不会出错（其父节点的 $sum$ 为零）。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R register
#define F(i,a,b) for(int i = (a);i<=(b);i++)
using namespace std;
inline int read(){R int x=0,t=1;R char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') t=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*t;}
const int N=2e5+10;
int n,k;
vector<int>g[N];
void add(int ui,int vi)
{
	g[ui].push_back(vi);
	return;
}
int sum[N];//以i为根的子树中离i最远的未被覆盖的点距离i的距离
void dfs(int u,int fa)
{
	sum[u]=0;
	for(int i = 0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa) continue;
		dfs(v,u);
		sum[u]=max(sum[u],sum[v]+1);
	}
	int maxn=-1e9;
	for(int i = 0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa) continue;
		if(sum[v]+1>=k){
			vis[u]=1;
			sum[u]=-1;
			break;
		}
		if(maxn+2+sum[v]>=k){
			vis[u]=1;
			sum[u]=-1;
			break;
		}
		maxn=max(sum[v],maxn);	
	}
	return;
}
signed main()
{
	n=read(),k=read();
	F(i,1,n-1){
		int ui=read(),vi=read();
		add(ui,vi);
		add(vi,ui);
	}
	dfs(1,0);
	int sum=0;
	for(int i = 1;i<=n;i++){
		sum+=vis[i];
	}
	cout << sum << '\n';
	return 0;
}
/*

*/
```

---

## 作者：YBa2Cu3O7 (赞：0)

DFS 贪心。

## 思路
随便找一个节点当作树的根节点进行 DFS，子树 DFS 的返回值表示这棵子树中最远未满足条件节点到当前节点的距离，如果全部满足条件则返回 $-1$。

在当前节点的所有子树的返回值中找到其中最大的两个，二者之和表示从其中一棵子树到另一棵子树的最远未满足条件的节点的最远距离，如果这个距离大于等于 $k$，说明需要在当前节点设立一个加油站，上传 $-1$ 表示该子树已全部满足条件，否则上传最大的返回值 $+1$。

警示后人：不要误以为加油站是范围覆盖式的。

## 代码
代码里面偷懒拿数组存了全部子树的返回值然后排序来找前二大的。初始包含一个 $0$ 是为了方便处理一条链的情况。
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n, k;
    cin >> n >> k;
    vector<vector<int>> G(n);
    for (int i = 0; i < n - 1; ++i) {
        int u, v;
        cin >> u >> v;
        --u; --v;
        G[u].emplace_back(v);
        G[v].emplace_back(u);
    }
    int ans = 0;
    vector<int> tr(n, 0);
    function<int(int)> dfs = [&](int u)->int {
        vector<int> ms = { 0 };
        for (auto x : G[u]) {
            if (tr[x] == 0) {
                tr[x] = 1;
                ms.push_back(dfs(x));
                tr[x] = 0;
            }
        }
        if (ms.size() == 1) {
            return 1;
        }
        sort(ms.begin(), ms.end(), greater<int>());
        if (ms[0] + ms[1] >= k) {
            ++ans;
            return -1;
        }
        else {
            return ms[0] + 1;
        }
        };
    tr[0]=1;
    dfs(0);
    
    cout << ans;
    return 0;
}
```

---


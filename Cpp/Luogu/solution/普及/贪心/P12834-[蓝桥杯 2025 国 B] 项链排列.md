# [蓝桥杯 2025 国 B] 项链排列

## 题目描述

小蓝有 $A$ 颗蓝珠（用字符 'L' 表示）和 $B$ 颗桥珠（用字符 'Q' 表示），他打算用这些珠子串成一条项链。他认为项链的美感主要体现在其视觉“变化”上：当项链中任意两个相邻的珠子种类不同时，就记为产生了一次“变化”。

为了系统地研究不同排列的美感，小蓝将每一种项链的排列方式表示为一个长度为 $A + B$ 的字符串。这个字符串由 $A$ 个字符 'L' 和 $B$ 个字符 'Q' 组成。相应地，一条项链的“变化次数”即为这个字符串中，所有相邻且不相同的字符对的数目。

例如，如果项链的排列是“LLQLQ”，那么：
- 第 1 个 'L' 和第 2 个 'L' 相同，无变化。
- 第 2 个 'L' 和第 3 个 'Q' 不同，产生了 1 次变化。
- 第 3 个 'Q' 和第 4 个 'L' 不同，产生了 1 次变化。
- 第 4 个 'L' 和第 5 个 'Q' 不同，产生了 1 次变化。

排列“LLQLQ”的总“变化次数”为 3。

现在，小蓝希望找到一种项链排列，使其总“变化次数”恰好为 $C$。对此，请你帮他在所有满足这一条件的排列中，找出字典序最小的那一个。如果不存在任何满足条件的排列方式，则输出 -1。

## 说明/提示

**【评测用例规模与约定】**

对于 20% 的评测用例，$0 \leq A, B, C \leq 100$，$1 \leq A + B \leq 200$。

对于 100% 的评测用例，$0 \leq A, B, C \leq 10^6$，$1 \leq A + B \leq 2 \times 10^6$。

## 样例 #1

### 输入

```
2 2 2```

### 输出

```
LQQL```

## 样例 #2

### 输入

```
2 2 3```

### 输出

```
LQLQ```

## 样例 #3

### 输入

```
2 2 4```

### 输出

```
-1```

# 题解

## 作者：Smirk (赞：4)

# [蓝桥杯 2025 国 B] 项链排列题解

## 总体贪心思路

这道题就是一个巨大的贪心。

读题我们需要构造一个变化次数为 $C$ 的最小字典序 $\texttt{LQ}$ 字符串。对变化次数的贡献一定是交替变换的 $\texttt{LQLQLQ...}$ 子段，我们定义其为贡献子段。

那么我们在构造时 **是否有必要在交替变换的贡献子段中插入连续的 $\texttt{LLLLL...}$ 或者 $\texttt{QQQQQ...}$？** 思考一下我们会发现必然是没必要的。可插入其中的连续 $\texttt{L}$ 段放在贡献子段之前使得整个字符串更小，而可插入其中的连续 $\texttt{Q}$ 段放在连续子段之后使得整个字符串更小。所以我们整体的贪心思路就是先构造贡献子段，再在前后插入剩余的 $\texttt{L、Q}$。

## 贡献子段构造

我们将贡献子段分为两类：
$$
\left\{
\begin{array}{c}
以 \texttt{L} 开头，\texttt{LQLQLQ...} \\
以 \texttt{Q} 开头，\texttt{QLQLQL...}\\
\end{array}
\right.
$$
我们定义两类贡献子段贡献的变化次数为 $C$ 时，需要 $\texttt{L}$ 和 $\texttt{Q}$ 的数量为：
$$
Lneed_i，Qneed_i(i = 1,2 表示第几类贡献子段)\\
容易得\\
Lneed_1 = C/2+1，Qneed_1 =(C+1)/2\\
Lneed_2 =(C+1)/2，Qneed_2 = C/2+1
$$
显然 **第一类贡献子段更优**，因为第二类贡献子段无法在前端添加多余的 $\texttt{L}$，否则会改变贡献子段的贡献量，所以选择第二类时整个字符串一定以 $Q$ 开头。而第一类可以在前端添加多余的 $\texttt{L}$，一定以 $\texttt{L}$ 开头。 那么是否贡献子段 **一定选择第一种** 呢？不是的，因为 **两类贡献子段的 $Lneed_i$ 和 $Qneed_i$ 并不同，** 并且：
$$
Lneed_1\ge Lneed_2，Qneed_1 \le Qneed_2
$$
也就是说 **构造第一类贡献子段需要更多的 $L$，构造第二类贡献子段需要更多的 $Q$**。但是第一类更优，所以，我们应该尽可能的构造第一类。

那么只要 $A\ge Lneed_1\ \&\ B\ge Qneed_1$，我们就构造第一类贡献子段。否则，如果 $A\ge Lneed_2\ \&\ B\ge Qneed_2$ 我们就构造第二类贡献子段。否则，就是无法构造，直接输出 $-1$。

## 多余的 $\texttt{L}$ 和 $\texttt{Q}$

贡献子段构造完毕后考虑多余的 $\texttt{L}$ 和 $\texttt{Q}$ 的插入。前文已经讨论过插入贡献子段中间的情况是没必要的，那么我们就考虑怎么插入前端或者后端。

### 当我们选择第一类贡献子段时

多余的 $\texttt{L}$ 插入后端的话使得整个字符串的第二位为 $\texttt{Q}$，插入前端的话使得贡献子段中的 $\texttt{Q}$ 往后移。显然有多余的 $\texttt{L}$ 就往前插最优。

自然地多余的 $\texttt{Q}$ 会往最后插入，但是贡献子段有可能是以 $\texttt{L}$ 结尾的，此时我们将把多余的 $\texttt{Q}$ 插入贡献子段的最后一个 $\texttt{Q}$ 后面。

### 当我们选择第二类贡献子段时

我们思考一下，会发现 **当我们选择了第二类贡献子段时一定不会有多余的 $L$，如果有，一定能选择第一类贡献子段。**

举个例子：
$$
假设我们的贡献子段为\ \texttt{QLQ} ，那么如果有多余的 \texttt{L} 就可以重新构造为\ \texttt{LQL} \\
$$
那么如何插入多余的 $\texttt{Q}$ 呢？直接插入最后端即可。**但是贡献子段有没有可能是以 $\texttt{L}$ 结尾的呢**？不可能，因为如果以 $\texttt{L}$ 结尾一定能重新构造成第一类贡献子段。

举个例子：
$$
假设我们的贡献子段为\ \texttt{QLQL}，那么重新排列就是\ \texttt{LQLQ}
$$
那么插入完成后我们的构造也就结束，但是不要忘记特殊判断 $C=0$ 的情况！

## 代码

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 7;
int a, b, c;
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> a >> b >> c;
    if (!c) {
        if (a != 0 && b != 0) {
            cout << "-1";
        } else {
            for (int i = 1; i <= a; i++) cout << "L";
            for (int i = 1; i <= b; i++) cout << "Q";
        }
        return 0;
    }
    int Lneed = c / 2 + 1;
    int Qneed = (c + 1) / 2;
    if (a >= Lneed && b >= Qneed) {
        for (int i = 1; i <= a - Lneed; i++) cout << "L";
        for (int i = 1; i <= Lneed + Qneed - 1; i++) {
            if (i & 1)
                cout << "L";
            else
                cout << "Q";
        }
        if ((Lneed + Qneed) & 1) {
            for (int i = 1; i <= b - Qneed; i++) cout << "Q";
            cout << "L";
        } else {
            cout << "Q";
            for (int i = 1; i <= b - Qneed; i++) cout << "Q";
        }
    } else {
        swap(Lneed, Qneed);
        if (a < Lneed || b < Qneed) {
            cout << "-1";
            return 0;
        }
        for (int i = 1; i <= Qneed + Lneed; i++) {
            if (i & 1)
                cout << "Q";
            else
                cout << "L";
        }
        for (int i = 1; i <= b - Qneed; i++) cout << "Q";
    }
    return 0;
}
```

## 感谢观看~

---

## 作者：Maxsong (赞：0)

# P12834 [蓝桥杯 2025 国 B] 项链排列 题解

## 无解

显然当 $L$ 或 $Q$ 交错排列不能够达到 $C$ 变化数时无解。并且当 $C=0$ 时 $A$ 和 $B$ 两者中一定要有一者为 $0$。同理当 $C\neq 0$ 时 $A$ 和 $B$ 两者中一定都不为 $0$。所以满足以下公式即无解：

$$
  \min(a+b-1,\min(a+b)\times 2)<C
  \\
  C=0 \ \text{且}\ AB\neq 0
  \\
  C\neq 0 \ \text{且}\ AB=0
$$

## 有解

明显的，所有的 $L$ 应当尽量在前面。所以我们可以构造出字符串基：

$$
  S=LLL\dots LQLQ \dots QQQ \dots
$$

但是既然贡献部分是以 $LQLQ$ 的形式出现的，故只能是奇数的目标变化次数。所以还涉及分类讨论。

### 奇数 $C$

上文已经提到过了，完全符合要求。

### 偶数 $C$

我们把一个 $L$ 放到最后，使得字符串：

$$
  S=LL\dots LQLQ \dots QQQ \dots L
$$

这样即可做到偶数个变化次数。

**注意：** 可以构造 **$L$ 的个数不足以放到最后的情况**，故需要做**特判，把 $Q$ 前置**。

## 杂七杂八的问题

不知道别人，反正我使用 `deque` 会产生 `MLE`。所以示例代码使用在线输出。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
signed main(void){
    scanf("%d%d%d",&a,&b,&c);
    if(min(min(a,b)*2,a+b-1)<c||(c==0&&a*b!=0)||(c!=0&&a*b==0)){
        printf("%d\n",-1);
        return 0;
    }if(c%2==1){
        c++;
        int pl=a-c/2;
        for(int i=0;i<pl;i++) cout<<'L';
        for(int i=1;i<=c;i++){
            cout<<(i%2==1?'L':'Q');
            if(i%2==0) b--;
            else a--;
        }
        for(int i=0;i<b;i++) cout<<'Q';
    }else{
        int pl=a-c/2;
        bool flag=false;
        if(pl<=0){
            cout<<'Q';
            b--;
            flag=true;
        // 这里特判是否会在最前面放置 Q 的情况
        }for(int i=1;i<pl;i++) cout<<'L';
        for(int i=1;i<=c;i++){
            cout<<(i%2==1?'L':'Q');
            if(i%2==0) b--;
            else a--;
        }for(int i=0;i<b;i++) cout<<'Q';
        if(!flag) cout<<'L';
    }cout<<endl;
    return 0;
}
```

---

## 作者：HetmesAskalana (赞：0)

## 题解
显然，在字典序意义上，$L<Q$，所以我们需要尽可能把 $L$ 往前放，让第一个 $Q$ 出现尽可能靠后。不难看出可以构造出一个形如：$LLL...LQLQLQQQQ...Q$ 的序列。

首先考虑无解的情况，不难看出一对 $a, b$ 可以最多提供 $\min(\min(a, b) \times 2, a + b - 1)$ 对不同的相邻项，所以如果 $c$ 比这个大那肯定不行。另外，如果 $c$ 是 $0$，则说明整个序列只有一种元素，那么 $a, b$ 都非零也不行。如果 $c$ 不等于 $0$，说明序列里面两种元素都有，所以 $a, b$ 必须都非零。

然后，我们考虑这个序列的构造方案，首先构造出基底 $LQLQLQ...$，一个以 $LQ$ 为循环节的循环序列。该序列的满足临位不同的对数一定是奇数。如果是偶数，则先补完剩下的 $Q$，再在后面补一个 $L$，其余的 $L$ 向前补齐。

需要注意的是，如果 $L$ 不够的话，需要在最前面补上一个 $Q$，然后其余的 $Q$ 插在后面。~~某著名选手因此喜提一WA~~

那么我们可以用一个字符形的双端序列维护这个操作，完了直接从前往后输出即可，复杂度 $\Theta(n)$。

## 代码
```cpp
char t[2] = {'L', 'Q'};

string dqs(deque<char> x){
    string R;
    while(x.size()){
        R += x.front();
        x.pop_front();
    }
    return R;
}

void solve(){
    LL A, B, C; cin >> A >> B >> C;
    LL a = A, b = B, c = C;
    LL maxC = min(min(a, b) * 2, A + B - 1);
    if(C > maxC) neg;
    if((a == 0 or b == 0) and c != 0) neg;
    if(c == 0 and (a != 0 and b != 0)) neg;
    deque<char> Rt;
    // string Rt;
    c += (c % 2);
    while(c--){
        Rt.push_back(t[c % 2 == 0]);
        if(c % 2 == 0) a--; else b--;
    }
    int d = Rt.size() - 1;
    if(d == C){
        for(int i = 0; i < a; ++i) Rt.push_front(t[0]);
        for(int i = 0; i < b; ++i) Rt.push_back(t[1]);
    }else{
        assert(C - d == 1);
        if(a == 0){
            Rt.push_front(t[1]);
            b--;
            for(int i = 0; i < b; ++i) Rt.push_back(t[1]);
        }else{
            for(int i = 0; i < b; ++i) Rt.push_back(t[1]);
            Rt.push_back(t[0]);
            a--;
            for(int i = 0; i < a; ++i) Rt.push_front(t[0]);
        }
    }
    cout << dqs(Rt) << endl;
}
```

---


# [GCJ 2018 #2] Falling Balls

## 题目描述

某种玩具由一个有 $2$ 列或更多列、$1$ 行或更多行的网格组成，网格的每个格子中要么放有一个 $\backslash$ 斜坡，要么放有一个 $/$ 斜坡，要么为空。最左边和最右边的两列始终为空，最底下一行也始终为空。小球会从最顶上一行的每一列各投放一个，并垂直下落，遇到斜坡会滑动。为了防止小球卡住，任意一个放有 $\backslash$ 斜坡的格子左侧，绝不会紧挨着一个放有 $/$ 斜坡的格子。

当一个小球从顶行落下时，它的移动规则如下：

- 如果小球当前在一个空格子中，则会直接落到正下方的格子，除非已经在最底行，此时小球不再移动。
- 如果小球当前在一个放有 $\backslash$ 斜坡的格子中，则会落到右下方的格子。
- 如果小球当前在一个放有 $/$ 斜坡的格子中，则会落到左下方的格子。

为了完整展示这个机制，用户会在每一列的顶行各投放一个小球。小球之间互不影响，一个格子中可以有多个小球。

你的朋友有这样一个玩具，列数为 $C$，行数未知。他在每一列的顶行各投放了一个小球，等所有小球都停止移动后，统计了每个底行格子里最终有多少个小球，并把这个结果告诉了你……但你怀疑他可能记错了。你能否构造出一个满足这些结果的布局，并且使用尽可能少的行数？或者判断根本不存在这样的布局？

例如，如果你朋友报告的底行结果是 $3\ 0\ 0\ 2\ 0\ 1$，一种可能的解法如下（注意不要求斜坡数量最少，也不要求每个斜坡都必须影响小球的路径）：

```
./\\...
./\.\/.
.......
```

下图展示了小球在该网格中的下落路径：

![](https://cdn.luogu.com.cn/upload/image_hosting/ia5vs05s.png)

## 说明/提示

**样例解释**

注意，最后一个样例不会出现在测试集 1 中。

对于样例 1，唯一的有效解法如下（必须至少有一行，增加更多行会导致行数不最少。底行不能有任何斜坡）：

```
....
```
对于样例 2，没有办法阻止最左边的小球直接落到底部，因为那一列不能放斜坡。

样例 3 就是题目描述最后给出的例子。注意，下面这个布局是非法的，因为它有多余的行数，左、右边界和底行都放了斜坡，而且出现了 $/$ 斜坡左侧紧挨着 $\backslash$ 斜坡的情况：

```
\\..\/
../.\/
./../.
..../.
```

**数据范围**

- $1 \leq T \leq 100$。
- $0 \leq B_i \leq C$，对所有 $i$ 均成立。
- 所有 $B_i$ 之和等于 $C$。

**测试集 1（5 分，公开）**

- $2 \leq C \leq 5$。

**测试集 2（12 分，隐藏）**

- $2 \leq C \leq 100$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
4
1 1 1 1
3
0 2 1
6
3 0 0 2 0 1```

### 输出

```
Case #1: 1
....
Case #2: IMPOSSIBLE
Case #3: 3
.//\..
./\./.
......```

# 题解

## 作者：Dreamer_002 (赞：3)

贪心好题。

### 思路
此题较小的数据和较大的时间容易让人误以为是其他算法，但是其实就是贪心。

- 考虑每个接受点（底部）管辖的球，是一个区间，按照从小到大，即 $1$ 号管辖 $1$ 至 $a_1$ 号球，$2$ 号管辖 $a_1+1$ 至 $a_1+a_2$ 号球，以此类推。
- 构造图即可。

下证贪心是正确的：

对于每个球，管辖它的接收点与它必定是一条直线，再加自由落体，又任意接收点管辖的是一个区间内的球，因此，所设计的算法中不可能有两个球的滑道交叉，因此可行。

下证贪心是最优解：

对于 $1$ 号接收点，管辖区域必定为 $1$ 至 $a_1$，否则必存在 $1 \le i \le a_1$ 使得 $i$ 号球被 $2$ 至 $n$ 号接收点管辖，则必有交叉，得证。同理对 $2$ 至 $n$ 号接受点，管辖的范围一定是唯一的，又因为对于每个球，管辖它的接收点与它必定是一条直线，所以一定最短，所以知贪心得到最优解。

判断无解情况：

由前分析得，可构造出解法，但是因为 $1$ 和 $n$ 列不能放置斜板，所以 $1$ 和 $n$ 号球必定掉落在 $1$ 和 $n$ 号接受点，所以如果 $a_1$ 或 $a_n$ 是 $0$，则无解。

### 代码
```cpp
//code by Dreamer_002
#include<cstdio>
#include<cstring>
const int N = 105;
int T,Case,n,a[N],ans;
char mp[N][N];
int maxx(int a,int b){
	return a>b?a:b;
}
int main(){
	scanf("%d",&T);
	while(T--){
		memset(mp,0,sizeof(mp));ans=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
		}
		Case++;printf("Case #%d: ",Case);
		if(a[1]==0 || a[n]==0){//只有两边不能加斜边，所以两边一定有球落下，否则无解。
			printf("IMPOSSIBLE\n");
			continue;
		}
		int now=0;
		for(int i=1;i<=n;i++){//now+1 ~ now+a[i] -> i
			for(int j=now+1;j<=now+a[i];j++){
				if(j<i){//球的编号比接收点小，向右斜
					for(int ki=1,kj=j;kj<i;ki++,kj++){
						mp[ki][kj]='\\';
						ans=maxx(ans,ki);
					}
				}
				else if(j>i){//球的编号比接受点大，向左斜
					for(int ki=1,kj=j;kj>i;ki++,kj--){
						mp[ki][kj]='/';
						ans=maxx(ans,ki);
					}
				}
			}
			now+=a[i];
		}
		printf("%d\n",ans+1);//最下面要求留一个空行
		for(int i=1;i<=ans+1;i++){//输出
			for(int j=1;j<=n;j++){
				if(mp[i][j]=='\\' || mp[i][j]=='/'){
					printf("%c",mp[i][j]);
				}
				else{
					printf(".");
				}
			}
			printf("\n");
		}
	}
	return 0;
}
```

### 总结
从分析到实践，这是道贪心与构造揉合的好题，希望大家也能细细钻研证明过程，终。

---


# [GCJ 2017 #2] Fresh Chocolate

## 题目描述

你是一家巧克力制造商的公关经理。不幸的是，由于顾客认为老板吝啬小气，公司的形象受到了影响。你希望通过提供免费的工厂参观和巧克力品尝来扭转这种印象。

然而，在新项目刚开始后，你就意识到老板的名声并非空穴来风：他只同意免费赠送巧克力，前提是你能将成本降到最低。要赠送的巧克力以每包 $P$ 块的形式提供。你本希望每个参观团都能打开新的一包，但老板坚持要求，如果上一组有剩余的巧克力，必须在为下一组服务前先用完这些剩余，之后才能打开新的一包。

例如，假设每包有 $P=3$ 块巧克力，某一参观团有 $5$ 人。你需要打开两包巧克力，每人分到一块，还会剩下一块。假设接下来又有一组 $6$ 人的参观团到来，他们会先拿到那块剩余的巧克力，然后你再打开两包新巧克力，分给剩下的人，这样又会剩下一块。如果之后有两个 $4$ 人的参观团，第一个团会拿到剩余的一块加上一包新开的巧克力，最后一个 $4$ 人团则需要打开两包新巧克力。注意，即使你打算立刻用完新开的巧克力，也不能在用完所有剩余之前打开新的一包。

在上述例子中，$4$ 个团中有 $2$ 个团（第一个和最后一个）拿到的都是新开的巧克力。其余 $2$ 个团则拿到了一部分新巧克力和一部分剩余巧克力。你知道发放剩余巧克力并不能改善老板吝啬的形象，但为了让老板同意这个项目，你不得不接受这个制度。尽管条件不利，你仍然致力于把工作做好。

现在有 $N$ 个参观团提出了申请，每个团都说明了将有多少人来参观工厂。参观团会一个接一个到来。你希望安排他们的到场顺序，使得拿到全新巧克力（没有剩余巧克力）的团数最多。你不能拒绝任何团，也不能让同一个团多次领取巧克力，并且必须保证每个人都正好拿到一块巧克力。

在上述例子中，如果顺序不是 $5, 6, 4, 4$，而是 $4, 5, 6, 4$，那么总共有 $3$ 个团（除了 $5$ 人团外）能拿到全新巧克力。对于这组团体来说，没有任何顺序能让所有团都只拿到新巧克力。

## 说明/提示

**样例解释**

样例 1 即题目描述中的例子。除了上文给出的最优顺序外，像 $6, 5, 4, 4$ 这样的顺序也能使拿到全新巧克力的团数最大，尽管具体哪些团拿到新巧克力可能不同。注意，我们只关心拿到全新巧克力的团数，而不是这些团的人数总和。

样例 2 中，团体和样例 1 相同，但每包有两块巧克力。在这种情况下，有多种顺序（如 $4, 4, 6, 5$）可以让所有团都拿到全新巧克力。

样例 3 中，所有团都是单人团，他们都会从同一包巧克力中领取。当然，只有第一个人能拿到刚开封的巧克力。

**数据范围**

- $1 \leq T \leq 100$。
- $1 \leq N \leq 100$。
- $1 \leq G_i \leq 100$，对所有 $i$。

**小数据范围（6 分，测试点 1 - 可见）**

- 时间限制：5 秒。
- $2 \leq P \leq 3$。

**大数据范围（10 分，测试点 2 - 隐藏）**

- 时间限制：10 秒。
- $2 \leq P \leq 4$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
4 3
4 5 6 4
4 2
4 5 6 4
3 3
1 1 1```

### 输出

```
Case #1: 3
Case #2: 4
Case #3: 1```

# 题解

## 作者：Nostopathy (赞：1)

# Solution

> 本篇题解是第二次交，应管理员要求，改掉了部分语法错误。

本题首解。

## 解答

注意到 $2 \leq P \leq 4$，考虑分类讨论。

发现能拿到新巧克力**当且仅当前面的总人数为 $P$ 的正整倍**，若令 $M_i = G_i \bmod P$，则分类构造 $M$ 的子串相加为 $P$ 的正整倍即可。

易得出若 $M_i = 0$，则一定有一组满足条件。

以下令 $A_i$ 表示满足 $M_x = i$ 的 $x$ 数量。

### 当 $P = 2$

此时每两个 $M_i = 1$ 产生一组的贡献，最后的那一组也满足，故此部分答案为 $\lfloor \frac{A_1 + 1}{2} \rfloor$；

### 当 $P = 3$

此时每对 $A_1$ 与 $A_2$ 产生一组贡献，余下的 $A_1$ 或 $A_2$ 每三个产生一组的贡献，最后多出的部分也满足，故此部分答案为 $\text{min}(A_1, A_2) + \lfloor \frac{|A_1 - A_2| + 2}{2} \rfloor$；

### 当 $P = 4$

此时每对 $A_1$ 与 $A_3$ 产生一组贡献，每对 $A_2$ 及余下部分产生一组贡献，余下的 $A_1$ 或 $A_3$ 加上余下的单个 $A_2$ 每 $4$ 个产生一组贡献，故此部分答案为 $\text{min}(A_1, A_3) + \lfloor \frac{A_2}{2} \rfloor + \lfloor \frac{|A_1 - A_3| + 2(A_2 \bmod 2) + 3}{4} \rfloor$。

综上所述，可分类讨论写出代码。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 5;
int t, n, p, a[N];
signed main () {
	scanf("%lld", &t);
	for (int c = 1; c <= t; ++ c) {
		memset(a, 0, sizeof a);
		scanf("%lld%lld", &n, &p);
		for (int i = 1, x; i <= n; ++ i)
			scanf("%lld", &x), ++ a[x % p];
		int res = a[0];
		if (p == 2)
			res += (a[1] + 1) >> 1;
		if (p == 3) {
			if (a[1] == a[2])
				res += a[1];
			else {
				int mn = min(a[1], a[2]);
				res += mn + (abs(a[1] - a[2]) + 2) / 3;
			}
		}
		if (p == 4) {
			int mn = min(a[1], a[3]);
			res += mn + a[2] / 2;
			int mo = abs(a[1] - a[3]);
			if (a[2] & 1)
				res += (mo + 5) >> 2;
			else
				res += (mo + 3) >> 2;
		}
		printf("Case #%lld: %lld\n", c, res);
	}
	return 0;
}
```

### 总结

算法：贪心、分类讨论、构造。

感谢您的观看，有问题请留言。

~~没有求关的题解不是好题解。~~

---

## 作者：kobebraint (赞：0)

## 看题！

这是一道贪心题，题目要求最大化获得新巧克力的参观团数量。一个团队能获得新巧克力，当且仅当在他们之前，累计消耗的巧克力是每包数量 $P$ 的整数倍，相当于在服务他们之前，巧克力的余数为 $0$。

## 怎么做？

为了尽可能多地让余数为 $0$，可以这样做：

对于人数恰好是 $P$ 的倍数的团队，他们都能吃到新巧克力，且余数为 $0$，还能让后面的任意人数的团队吃到新巧克力。

对于其他团队，我们要凑出余数为 $0$ 的情况。先凑出两个团队的组合，再凑出三个团队的组合，以此类推，优先用更少的团队凑出 $P$ 的倍数。

这样贪心之后，我们能组合出若干个组合，每个组合都能为答案贡献 $1$。在所有组合都处理完毕后，如果还有剩下的团队，那么他们中的第一个团队也能获得新巧克力，答案再加 $1$。

## 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define ll long long
#define cl(a) memset(a,0,sizeof a)
#define copy(a,b) copy(begin(a),end(a),begin(b))
#define ld long double
#define dot(x) fixed<<setprecision(x)
#define foru(a,b,c) for(ll a=b;a<=c;a++)

ll t,n,p,g,ans,cnt[105];

void solve(ll t){
    cin>>n>>p;
    cl(cnt);
    foru(i,0,n-1){
        cin>>g;
        cnt[g%p]++;
    }
    ans=0;
    if(p==2){
        ans=cnt[0]+cnt[1]/2;
        if(cnt[1]%2)ans++;
    }else if(p==3){
        ans=cnt[0];
        ll min12=min(cnt[1],cnt[2]);
        ans+=min12;
        cnt[1]-=min12,cnt[2]-=min12;
        ans+=cnt[1]/3;
        if(cnt[1]%3!=0)ans++;
        ans+=cnt[2]/3;
        if(cnt[2]%3!=0)ans++;
    }else if(p==4){
        ans=cnt[0];
        ll min13=min(cnt[1],cnt[3]);
        ans+=min13;
        cnt[1]-=min13,cnt[3]-=min13;
        ll min22=cnt[2]/2;
        ans+=min22,cnt[2]%=2;
        ll min12=min(cnt[1]/2,cnt[2]);
        ans+=min12;
        cnt[1]-=min12*2,cnt[2]-=min12;
        ll min32=min(cnt[3]/2,cnt[2]);
        ans+=min32;
        cnt[3]-=min32*2,cnt[2]-=min32;
        ans+=cnt[1]/4;
        cnt[1]%=4;
        ans+=cnt[3]/4;
        cnt[3]%=4;
        if(cnt[1]+cnt[2]+cnt[3]>0)ans++;
    }
    cout<<"Case #"<<t<<": "<<ans<<'\n';
}

int main(){
    cin>>t;
    foru(i,1,t){
        solve(i);
    }
    return 0;
}
```

---


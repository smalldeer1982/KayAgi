# 「2.48sOI R1」化妆品

## 题目背景

本月 $30$ 日即将迎来埃尔萨纳城的第 $17367$ 次名媛聚会。Misserina 和 ShenTianYi_ 正在为此做准备，她们在商场购买化妆品。

## 题目描述

商场里面有 $2n$ 个化妆品，每一个都能提供时尚值和美丽值。任意两个化妆品提供的时尚值互不相同，且美丽值也互不相同。

Misserina 和 ShenTianYi_ 要选择 $n$ 次心仪的化妆品，每一次 Misserina 先选，ShenTianYi_ 后选。Misserina 是个性格多变的人，她时而希望自己更加时尚，时而希望自己更加美丽，会选择剩余的化妆品中该值最大的那一个；而 ShenTianYi_ 则是淑女中的淑女，每一次 Misserina 选择她想要的之后她都会选择 Misserina 最不想要的那个，也就是对应时尚值或美丽值最小的那个。

她们想知道，按照这个规则选完所有化妆品之后，两人的时尚值和美丽值分别为多少。请帮她们解答这个问题。

## 说明/提示

第一次选择：

Misserina 选择时尚值最高的即第 $5$ 种化妆品，ShenTianYi_ 选择时尚值最低的即第 $1$ 种化妆品。

第二次选择：

Misserina 选择剩下的时尚值最高的即第 $4$ 种化妆品，ShenTianYi_ 选择剩下的时尚值最低的第 $3$ 种化妆品。

第三次选择：

Misserina 选择剩下的美丽值最高的第 $6$ 种化妆品，ShenTianYi_ 选择剩下的美丽值最低的第 $2$ 种化妆品。

最终 Misserina 的时尚值为 $8+9+4=21$，美丽值为 $3+4+27=34$；ShenTianYi_ 的时尚值为 $1+7+3=11$，美丽值为 $1665+5+8888=10558$。

对于 $100\%$ 数据：
- $1 \le n \le 5 \times 10^5$；
- $1 \le F_i,B_i \le 10^9$；
- $Q_i \in \{1,2\}$；
- $\forall\: i \ne j$，$F_i \ne F_j$，$B_i \ne B_j$。

**本题采取捆绑测试。**

- Subtask 0（9 pts）：$1 \le n \le 1000$，$1 \le F_i,B_i \le 2000$，$Q_i$ 均为 `1` 或均为 `2`；
- Subtask 1（11 pts）：$1 \le n \le 1000$，$1 \le F_i,B_i \le 2000$；
- Subtask 2（20 pts）：$1 \le n \le 1000$，$1 \le F_i,B_i \le 10^9$；
- Subtask 3（26 pts）：$1 \le n \le 5 \times 10^5$，$1 \le F_i,B_i \le 10^9$，$Q_i$ 均为 `1` 或均为 `2`；
- Subtask 4（34 pts）：$1 \le n \le 5 \times 10^5$，$1 \le F_i,B_i \le 10^9$。

## 样例 #1

### 输入

```
3
1 7 3 8 9 4
1665 5 8888 3 4 27
1 1 2```

### 输出

```
21 34
11 10558```

# 题解

## 作者：Gilbert1206 (赞：8)

## 题解：P13239 「2.48sOI R1」化妆品

[题目传送门](https://www.luogu.com.cn/problem/P13239)

## 思路

这道题非常容易看出是一个贪心题目，因为每次 Misserina 可以选取时尚值最大或者美丽值最大的一个，所以我们先按照时尚值和美丽值最大分别排序，如果输入的是 ```1``` 则按照时尚值最大的取出来，此时要注意我们需要看这个值是否之前已经被取出来了，所以用 unordered_map 来记录是否被取出来过。 ShenTianYi_ 我们则可以从最后一个依次看找到第一个没有被记录的值就是最小值了。最后输出两人选出的分别的总的时尚值和美丽值。

## code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
struct p{
	int a,b;
}a[1200000];
int cmp(p a,p b){
	return a.a>b.a;
}
int cmpp(p a,p b){
	return a.b>b.b;
}
int b[1200000],bu[1200000],c[1200000],cu[1200000];
unordered_map<int,int>p;//这里使用 map 会超时！
signed main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0); 
	int n;
	cin>>n;
	for(int i=0;i<2*n;i++){
		cin>>a[i].a;
	}
	for(int i=0;i<2*n;i++){
		cin>>a[i].b;
	}
	sort(a,a+2*n,cmp);
	for(int i=0;i<2*n;i++){
		b[i]=a[i].a;
		bu[i]=a[i].b;
	}
	sort(a,a+2*n,cmpp);
	for(int i=0;i<2*n;i++){
		c[i]=a[i].a;
		cu[i]=a[i].b;
	}//按时尚值和美丽值分别记录
	int tu=0,tp=0,ti=2*n-1,til=2*n-1;
	int ap=0,apl=0,bp=0,bpl=0;
	for(int i=0;i<n;i++){
		int x;
		cin>>x;
		if(x==1){
			while(p[b[tu]]==1){
				tu++;
			}//找到第一个没被记录的最大时尚值
			p[b[tu]]=1;
			ap+=b[tu];
			apl+=bu[tu];
			while(p[b[ti]]==1){
				ti--;
			}//找到第一个没被记录的最小时尚值
			p[b[ti]]=1;
			bp+=b[ti];
			bpl+=bu[ti];
		}
		else{
			while(p[c[tp]]==1){//找到第一个没被记录的最大美丽值
				tp++;
			}
			p[c[tp]]=1;
			ap+=c[tp];
			apl+=cu[tp];
			while(p[c[til]]==1){//找到第一个没被记录的最小美丽值
				til--;
			}
			p[c[til]]=1;
			bp+=c[til];
			bpl+=cu[til];
		}
	}
	cout<<ap<<" "<<apl<<endl<<bp<<" "<<bpl;
    return 0;
}
```

---

## 作者：Misserina (赞：7)

出题人题解。

根据题目背景，很容易想到贪心。

将所有化妆品分别按照时尚值大小和美丽值大小从小到大排序，再利用双指针算法，四个指针（这里我用数组下标表示）分别指向两个排完序的序列的头与尾，每次询问时向内查找对应值最大与最小的化妆品，可以利用数组或者四个变量记录两人获得的总时尚值大小和美丽值大小。这里我用的是数组。

时间复杂度为 $O(n \log n)$。

由于数据最大可能达到 $10^6 \times 10^9 = 10^{15}$，别忘记开 `long long`。

AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,q,f[1000005],b[1000005],seqf[1000005],seqb[1000005];
bool marked[1000005]; //记录每个化妆品是否被选到
long long res[2][2];
bool comp1(int x,int y) {
	return f[x]<f[y];
}
bool comp2(int x,int y) {
	return b[x]<b[y];
}
int main() {
	scanf("%d",&n);
	for (int i=1;i<=2*n;i++) {
		scanf("%d",&f[i]);
		seqf[i]=i; //排序数组存储每个化妆品的编号可以节省空间
	}
	for (int i=1;i<=2*n;i++) {
		scanf("%d",&b[i]);
		seqb[i]=i;
	}
	sort(seqf+1,seqf+2*n+1,comp1);
	sort(seqb+1,seqb+2*n+1,comp2);
	int fl=1,fr=2*n,bl=1,br=2*n;
	for (int i=1;i<=n;i++) {
		scanf("%d",&q);
		if (q==1) {
			while (marked[seqf[fl]]) fl++;
			while (marked[seqf[fr]]) fr--;
			marked[seqf[fl]]=1;
			marked[seqf[fr]]=1;
			res[0][0]+=f[seqf[fr]];
			res[0][1]+=b[seqf[fr]];
			res[1][0]+=f[seqf[fl]];
			res[1][1]+=b[seqf[fl]];
		}
		if (q==2) {
			while (marked[seqb[bl]]) bl++;
			while (marked[seqb[br]]) br--;
			marked[seqb[bl]]=1;
			marked[seqb[br]]=1;
			res[0][0]+=f[seqb[br]];
			res[0][1]+=b[seqb[br]];
			res[1][0]+=f[seqb[bl]];
			res[1][1]+=b[seqb[bl]];
		}
	}
	printf("%lld %lld\n%lld %lld",res[0][0],res[0][1],res[1][0],res[1][1]);
}
```

---

## 作者：chenzefan (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P13239)
## 前言
赛时用了玄学的方法，调到了 $66$pts，有些不甘，把优先队列改成双指针就过了，决定写一篇题解纪念一下。
## 思路
既然要选最大值 $\max$ 和最小值 $\min$，就必然要排序。

首先开 $4$ 个优先队列去分别存储的话，时间和空间复杂度都太高，提交只有 $40$pts，其他测试点 TLE 了。注意到特殊性质，可以玄学调成 $66$pts。这里就不赘述了。

考虑正解，排序后双指针。时间复杂度是 $O(n \log n)$。

由于题目保证：
> 任意两个化妆品提供的时尚值互不相同，且美丽值也互不相同。

所以按照时尚值和美丽值分别排序，升序降序均可。只是需要保存一下原来所在的位置 $id$，方便后续将时尚值和美丽值进行匹配。

初始时定义 $4$ 个指针，分别指向排完序的两个数组的头尾，然后根据每次操作向中间移动，知道相遇，此时就可以输出了。

定义 $4$ 个变量，分别表示最终 Misserina 的时尚值和美丽值和最终 ShenTianYi_ 的时尚值和美丽值。

由于数据过大，建议使用 long long 进行输出，~~或者更高深的东西。~~
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
int n,a[N],b[N],ida[N],idb[N],sum1,sum2,ans1,ans2;
map <int,int> mp1,mp2;
bool vis[N];//标记数组
bool cmp1(int x,int y){return a[x]<a[y];}
bool cmp2(int x,int y){return b[x]<b[y];}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=2*n;i++) scanf("%lld",a+i),ida[i]=i;
	for(int i=1;i<=2*n;i++) scanf("%lld",b+i),idb[i]=i;
	sort(ida+1,ida+2*n+1,cmp1);//时尚值升序
	sort(idb+1,idb+2*n+1,cmp2);//美丽值升序
	int al=1,ar=2*n,bl=1,br=2*n;//4 个指针
	for(int i=1,op;i<=n;i++){
		scanf("%lld",&op);
		if(op==1){//关于时尚值
		    //除去已经用过的化妆品
	        while(vis[ida[al]]) al++;
	        while(vis[ida[ar]]) ar--;
	        vis[ida[al]]=1;vis[ida[ar]]=1;
	        sum1+=a[ida[ar]];ans1+=b[ida[ar]];sum2+=a[ida[al]];ans2+=b[ida[al]];
		}
		else{//关于美丽值
			//除去已经用过的化妆品
 	        while(vis[idb[bl]]) bl++;
 	        while(vis[idb[br]]) br--;
 	        vis[idb[bl]]=1;vis[idb[br]]=1;
 	        sum1+=a[idb[br]];ans1+=b[idb[br]];sum2+=a[idb[bl]];ans2+=b[idb[bl]];
		}
	}printf("%lld %lld\n%lld %lld",sum1,ans1,sum2,ans2);
	return 0;
}
```
撒花！

---

## 作者：Amoribus (赞：3)

直接用四个优先队列拍上去，分别维护时尚值最大/最小、美丽值最大/最小。每次询问时，先把之前已经取出来的元素弹出队列，然后直接模拟即可，就可以做到 $O(n\log n)$。

常数略大。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<pair<int,int>,int>
#define fir first
#define sec second
priority_queue<pii,vector<pii> > q1,q2;
priority_queue<pii,vector<pii>,greater<pii> > q3,q4;
const int N=5e5+7;
int n;
struct node{
	int f,b;
}a[N*2];
int vis[N*2];
int f1,b1,f2,b2;
int read(){
	int k=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-f;
		c=getchar();
	}
	while(c>='0'&&c<='9') k=k*10+c-'0',c=getchar();
	return k*f;
}
signed main()
{
	n=read();
	for(int i=1;i<=2*n;i++){
		a[i].f=read();
	}
	for(int i=1;i<=2*n;i++){
		a[i].b=read();
	}
	for(int i=1;i<=2*n;i++){
		q1.push({{a[i].f,a[i].b},i});
		q3.push({{a[i].f,a[i].b},i});
		q2.push({{a[i].b,a[i].f},i});
		q4.push({{a[i].b,a[i].f},i});		
	} 
	for(int i=1;i<=n;i++){
		int t;
		t=read();
		if(t==1){
			while(!q1.empty()&&vis[q1.top().sec]) q1.pop();
			vis[q1.top().sec]=1;
			f1+=q1.top().fir.fir,b1+=q1.top().fir.sec;
			while(!q3.empty()&&vis[q3.top().sec]) q3.pop();
			vis[q3.top().sec]=1;
			f2+=q3.top().fir.fir,b2+=q3.top().fir.sec;			
		}
		if(t==2){
			while(!q2.empty()&&vis[q2.top().sec]) q2.pop();
			vis[q2.top().sec]=1;
			b1+=q2.top().fir.fir,f1+=q2.top().fir.sec;
			while(!q4.empty()&&vis[q4.top().sec]) q4.pop();
			vis[q4.top().sec]=1;
			b2+=q4.top().fir.fir,f2+=q4.top().fir.sec;			
		}
	}
	cout<<f1<<" "<<b1<<endl;
	cout<<f2<<" "<<b2<<endl;
	return 0;
}
```

---

## 作者：fish_love_cat (赞：2)

搞两个序列，一个按时尚排序，一个按美丽排序，然后对于每个询问双指针查询就行了。

已经使用的记得要打标记，不能重复。

时间复杂度 $O(n\log n)$。

抽象的是本题卡大常数 `map`，改成 `unordered_map` 即可，警钟长鸣！

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){
    int sum=0,fish=1;
    char c=getchar_unlocked();
    while((c<'0'||c>'9')&&c!='-')c=getchar_unlocked();
    if(c=='-')fish=-1,c=getchar_unlocked();
    while(c>='0'&&c<='9')sum=sum*10+(c-'0'),c=getchar_unlocked();
    return sum*fish;
}
void print(int x){
    if(x<0)putchar_unlocked('-'),x=-x;
    if(x<10)putchar_unlocked(x+'0');
    else print(x/10),putchar_unlocked(x%10+'0');
}
struct fish{
    int x,y,id;
}a[1000005],b[1000005];
int ax,ay,bx,by;
bool cmpa(fish x,fish y){
    return x.x<y.x;
}
bool cmpb(fish x,fish y){
    return x.y<y.y;
}
int la,ra,lb,rb;
unordered_map<int,bool>mp;
signed main(){
    int n,q;
    n=read();q=n,n*=2;
    for(int i=1;i<=n;i++)
    a[i].x=read(),b[i].x=a[i].x,a[i].id=i;
    for(int i=1;i<=n;i++)
    a[i].y=read(),b[i].y=a[i].y,b[i].id=i;
    la=1,ra=n,lb=1,rb=n;
    sort(a+1,a+1+n,cmpa);
    sort(b+1,b+1+n,cmpb);
    while(q--){
        int op=read();
        if(op==1){
            while(mp[a[la].id])la++;
            while(mp[a[ra].id])ra--;
            mp[a[la].id]=mp[a[ra].id]=1;
            ax+=a[ra].x,ay+=a[ra].y;
            bx+=a[la].x,by+=a[la].y;
        }else{
            while(mp[b[lb].id])lb++;
            while(mp[b[rb].id])rb--;
            mp[b[lb].id]=mp[b[rb].id]=1;
            ax+=b[rb].x,ay+=b[rb].y;
            bx+=b[lb].x,by+=b[lb].y;
        }
    }
    print(ax),putchar(' ');
    print(ay),putchar('\n');
    print(bx),putchar(' ');
    print(by);
    return 0;
}
```

---

## 作者：OIer_Tan (赞：2)

## 闲话

![](https://cdn.luogu.com.cn/upload/image_hosting/a2mo35fg.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/ombfa2ql.png)

## 思路

### #1

我会暴力！

枚举每次操作选哪一个。

期望得分 9 / 20 / 40 分。

### #2

我会 `std::set`！

你看这显然可以用堆 / 平衡树维护啊，但是堆不能任意删除。

那还是上两个平衡树吧，一个按 $F_i$ 排序，另一个按 $B_i$ 排序。

时间复杂度 $O(n\log n)$，但是常数上天。

期望得分 40 分。

### #3

我会 pbds！

我们发现，`__gnu_pbds::priority_queue` 可以支持删除，于是用四个堆，两个按 $F_i$ 排序，另外两个按 $B_i$ 排序，每种一个正序的，一个倒序的。

时间复杂度 $O(n\log n)$，但是常数更加逆天。

期望得分 40 分。

### #4

我会 tag！

注意到我们其实可以不用真的删除，只需要打个标记下次遇到时再弹出即可。

因此维护四个正常的堆，按上面方法操作就行。

时间复杂度 $O(n\log n)$，不过需要小卡常。

期望得分 100 分。

### #5

我没有学数据结构学傻！

注意到这个按 $F_i$ 和 $B_i$ 分别排序之后当前选的只能是按某一种方式排序后的头和尾，因此用类似 #4 的方法直接跳过头尾已经选过的，再打上标记即可。

时间复杂度 $O(n\log n)$。

期望得分 100 分。

## 代码

```cpp
#include <bits/stdc++.h>

#ifndef CRT
#define endl '\n'
#endif

using namespace std ;

typedef long long ll ;
typedef unsigned long long ull ;
typedef long double ld ;

const ll N = 1e6 + 5 ;

ll n , a [N] , b [N] ;

ll opt [N] ;

priority_queue <pair <ll,ll>> s1 , s2 ;

priority_queue <pair <ll,ll> , vector <pair <ll,ll>> , greater <pair <ll,ll>>> s3 , s4 ;

bool flag [N] ;

int main ()
{
#if not defined ( CRCC ) and not defined ( ONLINE_JUDGE )
	freopen ( ".in" , "r" , stdin ) ;
	freopen ( ".out" , "w" , stdout ) ;
#endif
	ios::sync_with_stdio ( 0 ) ;
	cin.tie ( 0 ) ;
	cout.tie ( 0 ) ;
	cin >> n ;
	ll m = n << 1 ;
	for ( ll i = 1 ; i <= m ; i ++ )
    {
        cin >> a [i] ;
    }
    for ( ll i = 1 ; i <= m ; i ++ )
	{
		cin >> b [i] ;
	}
	for ( ll i = 1 ; i <= 2 * n ; i ++ )
	{
		s1.push ( make_pair ( a [i] , i ) ) ;
		s2.push ( make_pair ( b [i] , i ) ) ;
		s3.push ( make_pair ( a [i] , i ) ) ;
		s4.push ( make_pair ( b [i] , i ) ) ;
	}
	ll sum1 = 0 , sum2 = 0 , sum3 = 0 , sum4 = 0 ;
	for ( ll i = 1 ; i <= n ; i ++ )
	{
		cin >> opt [i] ;
		if ( opt [i] == 1 )
		{
			{
				while ( s1.size () > 1 and flag [s1.top ().second] )
				{
					s1.pop () ;
				}
				auto p = s1.top () ;
				ll x = p.first , y = p.second ;
				s1.pop () ;
				flag [y] = 1 ;
				sum1 += x ;
				sum2 += b [y] ;
			}
			{
				while ( s3.size () > 1 and flag [s3.top ().second] )
				{
					s3.pop () ;
				}
				auto p = s3.top () ;
				ll x = p.first , y = p.second ;
				s3.pop () ;
				flag [y] = 1 ;
				sum3 += x ;
				sum4 += b [y] ;
			}
		}
		else
		{
			{
				while ( s2.size () && flag [s2.top ().second ] )
				{
					s2.pop () ;
				}
				auto p = s2.top () ;
				ll x = p.first , y = p.second ;
				s2.pop () ;
				flag [y] = 1 ;
				sum1 += a [y] ;
				sum2 += x ;
			}
			{
				while ( s4.size () && flag [s4.top ().second] )
				{
					s4.pop () ;
				}
				auto p = s4.top () ;
				ll x = p.first , y = p.second ;
                s4.pop () ;
				flag [y] = 1 ;
				sum3 += a [y] ;
				sum4 += x ;
			}			
		}
	}
	cout << sum1 << " " << sum2 << endl ;
	cout << sum3 << " " << sum4 << endl ;
	return 0 ;
}
```

---

## 作者：NTT__int128 (赞：1)

用四个优先队列，分别表示时尚值从小到大/从大到小，美丽值从小到大/从大到小。

每次直接取最大/小的，并标记为删除。取之前判一下是否被删除。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+5;
using pii=pair<int,int>;
int n,f[N<<1],b[N<<1],q;
bool d[N<<1];
priority_queue<pii>fx,bx;
priority_queue<pii,vector<pii>,greater<pii>>fn,bn;
int a,c,e,g;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n*2;i++)cin>>f[i],fx.push({f[i],i}),fn.push({f[i],i});
	for(int i=1;i<=n*2;i++)cin>>b[i],bx.push({b[i],i}),bn.push({b[i],i});
	while(n--){
		cin>>q;
		if(q==1){
			while(d[fx.top().second])fx.pop();
			a+=f[fx.top().second],c+=b[fx.top().second],d[fx.top().second]=1;fx.pop();
			while(d[fn.top().second])fn.pop();
			e+=f[fn.top().second],g+=b[fn.top().second],d[fn.top().second]=1;fn.pop();
		}
		else{
			while(d[bx.top().second])bx.pop();
			a+=f[bx.top().second],c+=b[bx.top().second],d[bx.top().second]=1;bx.pop();
			while(d[bn.top().second])bn.pop();
			e+=f[bn.top().second],g+=b[bn.top().second],d[bn.top().second]=1;bn.pop();
		}
	}
	cout<<a<<' '<<c<<'\n'<<e<<' '<<g;
	return 0;
}
```

---

## 作者：swate114514 (赞：1)

### Part1
> 我会暴力！

需要模拟 Misserina 和 ShenTianYi_ 在每次选择化妆品时的行为，关键在于高效地处理每次选择后的剩余化妆品，并根据当前的查询类型来动态选择最大值和最小值。

考虑一种数据结构来解决，可以使用两个 `set`，一个按时尚值排序，另一个按美丽值排序。这样可以在 $O(\log n)$ 时间内进行插入、删除、查询最大值和最小值操作。

代码不难写，就不放了。

### Part 2
> 我会优化！

满心欢喜地交了一发然后 TLE 了……

`set` 的删除元素和更新太慢了导致时间复杂度 $O(n \log n)$，有没有什么删除和同步更新更快的数据结构？

可以用链表！将每次操作的时间复杂度降为 $O(1)$。维护即可，代码好写，不放。

---

## 作者：pour_demain (赞：1)

这道题表述得很清楚，思路也还是很简单的。

首先看到每次选最大和最小，明显需要排序。~~这里主播赛时也是脑残敢直接写暴力。~~\
很多人会想到用 `set`，然后讨论版一堆被卡常的。其实解法已经很明显了，每一个元素有两种属性，我们要维护这两种属性的最大和最小值，很明显可以分别用最大堆和最小堆维护。\
有了思路就剩实现细节了，堆可以用模版里的优先队列 `priority_queue`，给每次选择开一个标记数组，记录选过的元素。

```cpp
#include <bits/stdc++.h>

using namespace std;

int main() {
	ios_base::sync_with_stdio(false);//不加速没测过，应该会被卡掉
	cin.tie(nullptr);
	
	int n;
	cin >> n;
	int t = 2 * n;//总数是2n不是n
	vector<int> f(t), b(t);
	for (int i = 0; i < t; ++i) {
		cin >> f[i];
	}
	for (int i = 0; i < t; ++i) {
		cin >> b[i];
	}
	vector<int> q(n);
	for (int i = 0; i < n; ++i) {
		cin >> q[i];
	}
	
	priority_queue<pair<int, int>> h1, h2;//大根堆
	priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> h1_, h2_;//小根堆
	
	vector<bool> s(t, false);//标记数组
	
	for (int i = 0; i < t; ++i) {
		h1.emplace(f[i], i);
		h1_.emplace(f[i], i);
		h2.emplace(b[i], i);
		h2_.emplace(b[i], i);
	}
	
	long long maxf = 0, maxb = 0;
	long long minf = 0, minb = 0;
	
	for (int q : q) {
		if (q == 1) {
			while (true) {
				auto top = h1.top();
				int val = top.first;
				int idx = top.second;
				h1.pop();
				if (!s[idx]) {//两种操作几乎一样，不断弹出堆顶直到找到解为止
					s[idx] = true;
					maxf += f[idx];
					maxb += b[idx];
					while (true) {
						auto stop = h1_.top();
						int sval = stop.first;
						int sidx = stop.second;
						h1_.pop();
						if (!s[sidx]) {
							s[sidx] = true;
							minf += f[sidx];
							minb += b[sidx];
							break;
						}
					}
					break;
				}
			}
		} else {
			while (true) {
				auto top = h2.top();
				int val = top.first;
				int idx = top.second;
				h2.pop();
				if (!s[idx]) {
					s[idx] = true;
					maxf += f[idx];
					maxb += b[idx];
					while (true) {
						auto stop = h2_.top();
						int sval = stop.first;
						int sidx = stop.second;
						h2_.pop();
						if (!s[sidx]) {
							s[sidx] = true;
							minf += f[sidx];
							minb += b[sidx];
							break;
						}
					}
					break;
				}
			}
		}
	}
	
	cout << maxf << " " << maxb << "\n";//"\n"比endl快，用endl应该也会被卡掉
	cout << minf << " " << minb << "\n";
	
	return 0;
}
```

一道堆的几乎是模版题，很适合初学者用来练手。

---

## 作者：zsjaaaxy (赞：1)

## 前言
赛时花了接近半小时，比较一眼但并不好写（可能我的写法较麻烦）。

## 做法
每次选最大、最小可以想到排序，但不能重复选择，故可开一个数组记忆其是否取过，每次在没取过的中间选即可。模拟过程就好了，详情看代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,q,x=1,y=1,dx,dy,vis[1000001],f1=0,f2=0,b1=0,b2=0,yb[1000001],yf[1000001];
//存储当前遍历到的化妆品的小标可以避免重复
struct lyx
{
    long long z,p;
}f[1000001],b[1000001];
//开结构体存储美丽值、时尚值及其下标
bool cmp(lyx l1,lyx l2)
{
    return l1.z>l2.z;
    //排序用
}
int main()
{
    cin>>n;
    for(int i=1;i<=2*n;i++)
    {
        cin>>f[i].z;
        f[i].p=i;
        yf[i]=f[i].z;
    }
    for(int i=1;i<=2*n;i++)
    {
        cin>>b[i].z;
        b[i].p=i;
        yb[i]=b[i].z;
    }
    dx=2*n,dy=2*n;
    sort(f+1,f+1+2*n,cmp);
    sort(b+1,b+1+2*n,cmp);
    //从大到小排序
    for(int i=1;i<=n;i++)
    {
        cin>>q;
        //分类讨论，注意既要考虑取最大值也要考虑取最小值
        if(q==1)
        {
            while(1)
            {
                lyx now=f[x];
                if(vis[now.p])
                {
                    x++;
                    continue;
                }
                x++;
                f1+=now.z;
                b1+=yb[now.p];
                vis[now.p]=1;
                break;
            }
            while(1)
            {
                lyx now=f[dx];
                if(vis[now.p])
                {
                    dx--;
                    continue;
                }
                dx--;
                f2+=now.z;
                b2+=yb[now.p];
                vis[now.p]=1;
                break;
            }
        }
        else
        {
            while(1)
            {
                lyx now=b[y];
                if(vis[now.p])
                {
                    y++;
                    continue;
                }
                b1+=now.z;
                f1+=yf[now.p];
                y++;
                vis[now.p]=1;
                break;
            }
            while(1)
            {
                lyx now=b[dy];
                if(vis[now.p])
                {
                    dy--;
                    continue;
                }
                b2+=now.z;
                f2+=yf[now.p];
                dy--;
                vis[now.p]=1;
                break;
            }
        }
    }
    cout<<f1<<" "<<b1<<endl<<f2<<" "<<b2<<endl; 
    return 0;
}
```

---

## 作者：xhui2ao (赞：1)

## 思路分析
首先，使用一个结构体来保存每个化妆品的编号，时尚值和美丽值。

```cpp
struct cosmetic
{
    int n;
    int f;
    int b;
};
```
用两个数组来保存按时尚值排列和按美丽值排列的化妆品。$use$ 数组负责保存该化妆品是否被用过。

```cpp
cosmetic f_cos[1000001];//按时尚值排列
cosmetic b_cos[1000001];//按美丽值排列
bool use[1000001];
```
因为数据范围为 $1\le n \le 5 \times 10^{5}$，每次询问时查找最大最小值，时间复杂度为 $\mathcal{O}(n^{2})$。必须提前使用时间复杂度为 $\mathcal{O}(n \cdot\log n)$ 的快速排序提前进行排序，代码如下。

```cpp
bool cmp_f(cosmetic a, cosmetic b)
{
    return a.f < b.f;
}

bool cmp_b(cosmetic a, cosmetic b)
{
    return a.b < b.b;
}

sort(f_cos,f_cos+2*n,cmp_f);
sort(b_cos,b_cos+2*n,cmp_b);
```
接下来，这里使用**双指针**算法，分别维护这两个数组的头与尾。尾就是时尚值或者美丽值的最大值，头就是时尚值或者美丽值的最小值。如果该化妆品被使用了，在 $use$ 数组进行更改。具体实现代码如下。

```cpp
for(int i=0;i<n;i++)
    {
        int q;
        cin >> q;
        if(q==1)
        {
            while(use[f_cos[f_cos_tail].n])f_cos_tail--;
            use[f_cos[f_cos_tail].n]=true;
            Misserina_f+=f_cos[f_cos_tail].f;
            Misserina_b+=f_cos[f_cos_tail].b;

            while(use[f_cos[f_cos_head].n])f_cos_head++;
            use[f_cos[f_cos_head].n]=true;
            ShenTianYi_f+=f_cos[f_cos_head].f;
            ShenTianYi_b+=f_cos[f_cos_head].b;
        }
        else
        {
            while(use[b_cos[b_cos_tail].n])b_cos_tail--;
            use[b_cos[b_cos_tail].n]=true;
            Misserina_f+=b_cos[b_cos_tail].f;
            Misserina_b+=b_cos[b_cos_tail].b;

            while(use[b_cos[b_cos_head].n])b_cos_head++;
            use[b_cos[b_cos_head].n]=true;
            ShenTianYi_f+=b_cos[b_cos_head].f;
            ShenTianYi_b+=b_cos[b_cos_head].b;
        }
    }
```
## AC代码

双指针只需要遍历一遍数组就可以了，实际上，双指针算法的时间复杂度为 $\mathcal{O}(n)$，所以本代码时间复杂度为快速排序的时间复杂度 $\mathcal{O}(n \cdot\log n)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct cosmetic
{
    int n;
    int f;
    int b;
};

cosmetic f_cos[1000001];//按时尚值排列
cosmetic b_cos[1000001];//按美丽值排列
bool use[1000001];
int n;

int f_cos_head=0;
int f_cos_tail;
int b_cos_head=0;
int b_cos_tail;

long long Misserina_f=0;
long long Misserina_b=0;
long long ShenTianYi_f=0;
long long ShenTianYi_b=0;

bool cmp_f(cosmetic a, cosmetic b)
{
    return a.f < b.f;
}

bool cmp_b(cosmetic a, cosmetic b)
{
    return a.b < b.b;
}

int main()
{
    cin >> n;
    f_cos_tail=2*n-1;
    b_cos_tail=2*n-1;
    for(int i=0;i<2*n;i++)
    {
        cin >> f_cos[i].f;
        b_cos[i].f=f_cos[i].f;
        f_cos[i].n=i;
    }
    for(int i=0;i<2*n;i++)
    {
        cin >> b_cos[i].b;
        f_cos[i].b=b_cos[i].b;
        b_cos[i].n=i;
    }
    sort(f_cos,f_cos+2*n,cmp_f);
    sort(b_cos,b_cos+2*n,cmp_b);
    for(int i=0;i<n;i++)
    {
        int q;
        cin >> q;
        if(q==1)
        {
            while(use[f_cos[f_cos_tail].n])f_cos_tail--;
            use[f_cos[f_cos_tail].n]=true;
            Misserina_f+=f_cos[f_cos_tail].f;
            Misserina_b+=f_cos[f_cos_tail].b;

            while(use[f_cos[f_cos_head].n])f_cos_head++;
            use[f_cos[f_cos_head].n]=true;
            ShenTianYi_f+=f_cos[f_cos_head].f;
            ShenTianYi_b+=f_cos[f_cos_head].b;
        }
        else
        {
            while(use[b_cos[b_cos_tail].n])b_cos_tail--;
            use[b_cos[b_cos_tail].n]=true;
            Misserina_f+=b_cos[b_cos_tail].f;
            Misserina_b+=b_cos[b_cos_tail].b;

            while(use[b_cos[b_cos_head].n])b_cos_head++;
            use[b_cos[b_cos_head].n]=true;
            ShenTianYi_f+=b_cos[b_cos_head].f;
            ShenTianYi_b+=b_cos[b_cos_head].b;
        }
    }
    cout << Misserina_f << " " << Misserina_b << endl << ShenTianYi_f << " " << ShenTianYi_b;
}

```

---

## 作者：feizhu_QWQ (赞：0)

这道题没什么思维难度，代码实现稍微有一点麻烦。  
看到最小最大，就能想到堆啊，那这道题的思路就显而易见了：我们用堆分别维护时尚值的极值与美丽值的极值，为了更清晰一些，飞竹这里用了四个堆。  
关键的问题又到了，怎么删呢？  
可以用堆的经典处理方式：用 $vis$ 数组来记录每个物品是否选择的状态，然后每次去堆顶拿元素的时候，判断一下有没有被选过，被选过就将其弹出，再找下一个堆顶就行了。  
注意几个细节：  
1. 每次尽量先把堆顶元素存起来，再弹出。
2. 堆是默认大根堆哦！
3. 堆里要储存两个元素，一个是序号，一个是元素，重载运算符不要写错！

众所周知：算法不在快速，能过就行！  
代码：  

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct nodeb
{
    int x,id;
    bool operator <(const nodeb &f) const
    {
        return x<f.x;
    }
};
struct nodel
{
    int x,id;
    bool operator <(const nodel &f) const//高频错点
    {
        return x>f.x;
    }
};
priority_queue<nodel> lb,lf;
priority_queue<nodeb> bb,bf;
int n,sum1f,sum1b,sum2f,sum2b;
bool vis[1000005];
int f[1000005],b[1000005];
signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=2*n;i++)
    {
        cin>>f[i];
        lf.push({f[i],i});
        bf.push({f[i],i});
    }
    for(int i=1;i<=2*n;i++)
    {
        cin>>b[i];
        lb.push({b[i],i});
        bb.push({b[i],i});
    }
    for(int i=1;i<=n;i++)
    {
        int x;
        cin>>x;
        if(x==1)
        {
            nodeb m;
            while(vis[bf.top().id]==true) bf.pop();
            m=bf.top();
            bf.pop();
            nodel s;
            while(vis[lf.top().id]==true) lf.pop();
            s=lf.top();
            lf.pop();
            vis[m.id]=vis[s.id]=true;
            sum1f+=f[m.id],sum2f+=f[s.id];
            sum1b+=b[m.id],sum2b+=b[s.id];
        }
        if(x==2)
        {
            nodeb m;
            while(vis[bb.top().id]==true) bb.pop();
            m=bb.top();
            bb.pop();
            nodel s;
            while(vis[lb.top().id]==true) lb.pop();
            s=lb.top();
            lb.pop();
            vis[m.id]=vis[s.id]=true;
            sum1f+=f[m.id],sum2f+=f[s.id];
            sum1b+=b[m.id],sum2b+=b[s.id];
        }
    }
    cout<<sum1f<<" "<<sum1b<<endl<<sum2f<<" "<<sum2b;
    return 0;
}
```

---

## 作者：MnZnOIer (赞：0)

### 解题思路
签到题，但是不知道为什么被卡常了，先讲被卡的做法。~~（bushi~~

我们可以动态维护两个分别以时尚值和美丽值为优先级的 set，每次取出头和尾，再在另一个 set 中删除。

我们哐哐哐敲完发现被卡常了，怎么办呢？我们很容易想到 STL 常数太大了（虽然我尝试优化无果），果断换一种实现方式：提前按两种优先级排好序，然后拿 4 个指针维护时尚和美丽值的最大最小的位置，并用一个 vis 数组记录被买过的化妆品，指针维护是线性的，所以会比 set 快？

**下面一些没有用的话，仅代表我个人的猜测**。我们发现 set 实现的复杂度是 $\Theta(2\times (2n)\log (2n))$，而排序加指针是 $\Theta((2n)\log (2n)+2n)$ 的，在 $n$ 较大的时候会导致 set 效率变低？我觉得甚至可以尝试用~~常数更大的~~ FHQ_Treap 优化 set？（没试过，但是大雾。

### 代码部分
set 实现版：
```cpp
#include <bits/stdc++.h>
#define pii pair <int, int>
#define fi first
#define se second
using namespace std;
const int N = 1e6 + 5;
int n, q, F[N], B;
long long af, ab, bf, bb;
set <pii> f, b;
signed main ()
{
    scanf ("%d", &n);
    for (int i = 1; i <= 2 * n; ++ i)
        scanf ("%d", &F[i]);
    for (int i = 1; i <= 2 * n; ++ i)
    {
        scanf ("%d", &B);
        f.insert ({F[i], B});
        b.insert ({B, F[i]});
    }
    for (int i = 1; i <= n; ++ i)
    {
        scanf ("%d", &q);
        if (q == 1)
        {
            set <pii> ::iterator it = f.end ();
            -- it;
            pii p = *it;
            af += 1ll * p.fi;
            ab += 1ll * p.se;
            f.erase (p);
            b.erase ({p.se, p.fi});
            p = *f.begin ();
            bf += 1ll * p.fi;
            bb += 1ll * p.se;
            f.erase (p);
            b.erase ({p.se, p.fi});
        }
        else
        {
            set <pii> ::iterator it = b.end ();
            -- it;
            pii p = *it;
            af += 1ll * p.se;
            ab += 1ll * p.fi;
            b.erase (p);
            f.erase ({p.se, p.fi});
            p = *b.begin ();
            bf += 1ll * p.se;
            bb += 1ll * p.fi;
            b.erase (p);
            f.erase ({p.se, p.fi});
        }
    }
    printf ("%lld %lld\n%lld %lld", af, ab, bf, bb);
    return 0;
}
```

数组实现通过版：
```cpp
#include <bits/stdc++.h>
#define pii pair <int, int>
#define fi first
#define se second
using namespace std;
const int N = 1e6 + 5;
int n, q, pa = 1, pb = 1, ta, tb;
bitset <N> vis;
long long af, ab, bf, bb;
struct Node{int f, b, id;}a[N], b[N];
bool cmp1 (Node a, Node b)
    {return a.f > b.f;}
bool cmp2 (Node a, Node b)
    {return a.b > b.b;}
signed main ()
{
    scanf ("%d", &n);
    ta = tb = 2 * n;
    for (int i = 1; i <= 2 * n; ++ i)
        scanf ("%d", &a[i].f),
        a[i].id = i;
    for (int i = 1; i <= 2 * n; ++ i)
        scanf ("%d", &a[i].b),
        b[i] = a[i];
    sort (a + 1, a + n + n + 1, cmp1);
    sort (b + 1, b + n + n + 1, cmp2);
    for (int i = 1; i <= n; ++ i)
    {
        scanf ("%d", &q);
        if (q == 1)
        {
            while (vis[a[pa].id])
                ++ pa;
            af += a[pa].f;
            ab += a[pa].b;
            vis[a[pa].id] = 1;
            ++ pa;
            while (vis[a[ta].id])
                -- ta;
            bf += a[ta].f;
            bb += a[ta].b;
            vis[a[ta].id] = 1;
            -- ta;
        }
        else
        {
            while (vis[b[pb].id])
                ++ pb;
            af += b[pb].f;
            ab += b[pb].b;
            vis[b[pb].id] = 1;
            ++ pb;
            while (vis[b[tb].id])
                -- tb;
            bf += b[tb].f;
            bb += b[tb].b;
            vis[b[tb].id] = 1;
            -- tb;
        }
    }
    printf ("%lld %lld\n%lld %lld", af, ab, bf, bb);
    return 0;
}
```

马蜂恶臭请勿学习。

---

## 作者：egg_boy (赞：0)

当时机房同学用 set 写炸了。  
看了一下感觉并不难啊？  

# 思路
  先用两个数组将化妆品按照时尚值和美丽值。再用一个数组维护每个化妆品是否被用，再用双指针的想法维护每次选的化妆品不就行了。如果还是没懂，就看看代码和注释吧！

# code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 10;
int n, ax, ay, bx, by, vis[N];
struct node {int w1, w2, id;}a[N], b[N];

bool cmp1(node x, node y){return x.w1 > y.w1;}
bool cmp2(node x, node y){return x.w2 > y.w2;}

signed main()
{
//	freopen("T1.in", "r", stdin);
//	freopen("T1.out", "w", stdout);
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n;
	n *= 2;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i].w1;
		a[i].id = i;
	}
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i].w2;
		b[i] = a[i]; 
	}
	
	// a 按照时尚值排序，b 按照美丽值排序 
	sort(a + 1, a + 1 + n, cmp1);
	sort(b + 1, b + 1 + n, cmp2);
	
	int a1 = 1, a2 = n, b1 = 1, b2 = n;
	for(int i = 1, op; i <= n / 2; i++)
	{
		cin >> op;
		if(op == 1)
		{
			// 找到第一个没有被选过的化妆品 
			while(vis[a[a1].id]) a1++;
			ax += a[a1].w1, ay += a[a1].w2, vis[a[a1].id] = true;
			while(vis[a[a2].id]) a2--;
			bx += a[a2].w1, by += a[a2].w2, vis[a[a2].id] = true;
		}
		if(op == 2)
		{
			// 同上 
			while(vis[b[b1].id]) b1++;
			ax += b[b1].w1, ay += b[b1].w2, vis[b[b1].id] = true;
			while(vis[b[b2].id]) b2--;
			bx += b[b2].w1, by += b[b2].w2, vis[b[b2].id] = true;
		}
	}
	cout << ax << " " << ay << "\n" << bx << " " << by;
	return 0;
}
```

---

## 作者：Firsry (赞：0)

最开始想着使用两个不同结构体重载排序的 `deque` 进行维护，然后使用二分法定位进行删除，但是发现删除仍然是 $\mathrm{O(N)}$ 的，不可行。本蒟蒻不会写平衡树，但是会打 `tag`。发现如果用 `used` 数组进行标记每一份是否被使用，然后在从 `deque` 首尾取出数据时判断没有被使用过的，那么总共添加的时间复杂度应为 $\mathrm{O(N)}$ 的，完全可以承受。最终时间复杂度为 $\mathrm{O(N \log N)}$，瓶颈在于排序。

``````cpp
#include<bits/stdc++.h>
#define LL long long

using namespace std;

struct itemFas {
	int f, b, ind;
	bool operator < (const itemFas another) const {
		return f < another.f;
	}
};
struct itemBea {
	int f, b, ind;
	bool operator < (const itemBea another) const {
		return b < another.b;
	}
};

int n, m, q;
vector<bool> used;
deque<itemBea> bea;
deque<itemFas> fas;
LL f1, b1, f2, b2;

inline int read() {
	int x = 0;
	char ch = getchar();
	while (!isdigit(ch))
		ch = getchar();
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

int main() {
	n = read();
	m = n << 1;
	used.resize(m);
	bea.resize(m);
	fas.resize(m);
	for (int i = 0; i < m; ++i)
		fas[i].f = bea[i].f = read();
	for (int i = 0; i < m; ++i)
		fas[i].b = bea[i].b = read();
	for (int i = 0; i < m; ++i)
		fas[i].ind = bea[i].ind = i;
	sort(bea.begin(), bea.end());
	sort(fas.begin(), fas.end());
	while (n--) {
		int opt = read();
		if (opt == 1) {
			while (!fas.empty() && used[fas.back().ind])
				fas.pop_back();
			f1 += fas.back().f;
			b1 += fas.back().b;
			used[fas.back().ind] = true;
			fas.pop_back();
			while (!fas.empty() && used[fas.front().ind])
				fas.pop_front();
			f2 += fas.front().f;
			b2 += fas.front().b;
			used[fas.front().ind] = true;
			fas.pop_front();
		} else {
			while (!bea.empty() && used[bea.back().ind])
				bea.pop_back();
			f1 += bea.back().f;
			b1 += bea.back().b;
			used[bea.back().ind] = true;
			bea.pop_back();
			while (!bea.empty() && used[bea.front().ind])
				bea.pop_front();
			f2 += bea.front().f;
			b2 += bea.front().b;
			used[bea.front().ind] = true;
			bea.pop_front();
		}
	}
	cout << f1 << ' ' << b1 << '\n' << f2 << ' ' << b2;
	return 0;
}
``````

---

## 作者：medal_dreams (赞：0)

## 题意
给两个序列 $F,B$，每次一个人会选 $F$（时尚值）中的最大值或 $B$（美丽值）中的最大值，另一个人会选择对应的最小值，序列中的数选完后删除，求最后两个人的时尚值和美丽值分别是多少。
## 思路
很明显是排序后寻找最大值和最小值，求加和。
### 坑点
对于一个已经选择的数，无法再次选择，不好记录下标。  
例如对于这个样例：
```
2
4 3 2 1
1 2 3 4
1 2
```
排序后为
```
1 2 3 4
1 2 3 4
```

刚开始选择二元组 $(4,1)$，那么在我们看来中这个二元组就相当于删除了。但对于排序后的数，我们似乎很难找到二元组 $(4,1)$，就算找到也很难进行下一步计算，并且很难删除。

那排序就没法做了吗？？？

实则不然，我们分析一下现在的问题：
1. 为了保持 $F,B$ 序列一定是升序或降序排序的，我们需要排序，但排序过后我们很难记录下标。
2. 对于排序后的 $F,B$ 序列，我们很难记录那些已经被选择过的了。
3. 对于排序后的 $F,B$ 序列，我们很难进行运算。

分析一下：对于 $1,3$ 问题，我们发现其实主要问题还是下标很难记录，对于 $2$ 问题，我们发现是难以记录，那记录的前提是什么？很明显，是下标。  
所以综合 $3$ 个问题，我们可以发现主要难度在下标这里。

所以我们就向下标方向思考，下标在排序完后改变。那么其实我们可以用一个结构体记录我们的下标和值就可以了。  
C++ 中正好有一个被包装好的结构体，它叫 pair，它包含两个变量 $first,second$。对于 pair，它的 $first$ 在排序中作为第一关键字，而 $second$ 在排序中作为第二关键字。所以我们用 $first$ 表示值， $second$ 表示下标。  
这样我们就解决问题 $1$ 了。

现在思考问题 $2$：  
对于记录选择的数，其实就是记录下标，那么其实用 $vis$ 数组记录这个下标被没被选就可以了。

对于问题 $3$：  
对于运算，我们可以选择两种方法：
-  用 map 记录每一个下标对应的 pair 值，定义为 `map<int,pair<int,int> > m`，因为我们已经记录了下标，那么直接访问就行。
-  记录一个三元组 $(data_F,data_B,idx)$，其中 $data_F$ 表示对应的 $F$ 的值，$data_B$ 表示对应的 $B$ 的值，$idx$ 表示下标。
  
现在所有问题都解决了，我们就可以用排序做了。

因为我用 map 写的，所以这里用 map 解释。
## 具体思路
首先读入，记录值和下标，之后用 map 记录每一个下标对应的二元组。

之后排序，用 sort 即可。

最后呢用两个头指针和尾指针记录 $F,B$ 被访问的位置，如果对于 $F,B$ 这个位置被 $vis$ 标记了，那么就继续寻找，否则就进行运算。因为我们进行了排序，所以找到的第一个未被标记的数一定是最大/小的。
## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 66;//注意是 2 * n 开二倍空间 
long long head[2],tail[2],n,od,ans[5];
//用两个头指针和尾指针，od表示选 F 最大的还是 B 最大的，ans为结果，因为总共有 4 个结果，所以开 4 个
//ans[1] ans[2] ans[3] ans[4] 表示的意思在下面
bool vis[N];//记录每一个下标是否被使用
pair<long long,long long> f[N],b[N];//输入的 F,B
unordered_map<long long,pair<long long,long long> > m;//记录下标对应的二元组
//提示：这里用 unordered_map 更快，并且其功能和 mao 基本一致
int main()
{
	ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= 2 * n;i ++) cin >> f[i].first,f[i].second = i;
	for(int i = 1;i <= 2 * n;i ++) cin >> b[i].first,b[i].second = i;
	for(int i = 1;i <= 2 * n;i ++) m[i] = make_pair(f[i].first,b[i].first);
	//输入 + 存储，注意是 2 * n
	sort(f + 1,f + 1 + 2 * n);
	sort(b + 1,b + 1 + 2 * n);
	//排序，注意是 2 * n
	head[0] = head[1] = 1,tail[0] = tail[1] = 2 * n;
	//初始化头指针尾指针，头开始为 1 尾开始为 2 * n
	//因为我是从小到大排的，所以尾巴表示大，头表示小
	for(int i = 1;i <= n;i ++)
	{
		cin >> od;//输入
		if(od == 1)
		{
			while(vis[f[tail[0]].second]) tail[0] --;vis[f[tail[0]].second] = 1;//弹出尾部被访问的，标记这个未被标记的
			ans[3] += m[f[tail[0]].second].second;//因为f记录的是时尚值，那么美丽值就需要加上 f 记录的下标所对应 map 记录的第二个元素
			ans[1] += f[tail[0] --].first;//直接加上就行，并且去掉这个tail减少判断次数
			//运算，ans[1] 和 ans[3] 表示 Misserina 的时尚值和美丽值
			
			while(vis[f[head[0]].second]) head[0] ++;vis[f[head[0]].second] = 1;
			ans[4] += m[f[head[0]].second].second;
			ans[2] += f[head[0] ++].first;
			//总的同上
			//ans[2] ans[4] 表示 ShenTianYi_ 的时尚值和美丽值
		}
		else
		{
			while(vis[b[tail[1]].second]) tail[1] --;vis[b[tail[1]].second] = 1;//同上
			ans[1] += m[b[tail[1]].second].first;//记录ans，因为 b 表示美丽值，所以时尚值加上 b 记录下标所对应 map 记录的第一个元素
			ans[3] += b[tail[1] --].first;//也是直接加上即可
			
			while(vis[b[head[1]].second]) head[1] ++;vis[b[head[1]].second] = 1;
			ans[2] += m[b[head[1]].second].first;
			ans[4] += b[head[1] ++].first;
			//总的同上
		}
	}
	cout << ans[1] << " " << ans[3] << "\n";
	cout << ans[2] << " " << ans[4] << "\n";
	//输出
	return 0;
}
```
## 题外话
今天(7.12)是洛天依的生日，大家可以祝她生日快乐吗(^^)。

---

## 作者：CleverSea (赞：0)

下文中的人名，M 指 Misserina，S 指 ShenTianYi_。

### 题意简述

- 有 $2n$ 个化妆品，每个化妆品有一个时尚值 $F_i$ 和美丽值 $B_i$。
  
- M 和 S 轮流选择化妆品，共进行 $n$ 轮。每轮给定一个 $Q$：

  1. M 选 $Q$ **最大**的化妆品（$Q$ 为 $1$ 表示时尚值，$2$ 表示美丽值）选择一个化妆品。

  2. S 选择剩余化妆品中 $Q$ **最小**的化妆品。
 
- 求最终两人各自的时尚值与美丽值总和。

### 分析

一道有点恶心但是比较水的题目，建议难度黄。我们只需要将化妆品按时尚值和美丽值分别排序，得到两个索引数组 `f[i]` 和 `b[i]`（即这两个数组中存储的是排序后的值在原数组中的**下标**），再用四个指针分别指向两个排序数组的当前最小值和最大值位置。每次选择后，更新 M 和 S 各自的时尚值和美丽值，并更新指针跳过已选元素。

**但是，一定要注意**：一个化妆品被选中后，需**同时**更新**两个索引数组**的指针，才能避免重复选择（~~本蒟蒻正是因为这一点没考虑导致一开始 35pts~~）！为了方便地实现这一操作，我们可以定义一个 `update()` 函数。另外，指针移动时要**检查边界**，防止越界。

**最后——**

> 十年 OI 一场空，不开 long long 见祖宗。

**记得开 long long！**

### 下面是代码
##### 码风良好，放心食用！

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 10; // 数组大小：2n (n ≤ 500,000)

int n;
int x[N], y[N];         // x[i]：第i个化妆品的时尚值，y[i]：美丽值
int f[N], b[N];         // f：按时尚值排序的索引数组，b：按美丽值排序的索引数组
bool vis[N];            // vis[i]：标记第i个化妆品是否已被选择
int curfl, curfr;       // 时尚值数组的指针：curfl（最小），curfr（最大）
int curbl, curbr;       // 美丽值数组的指针：curbl（最小），curbr（最大）
int m1, m2;             // M的总时尚值、总美丽值
int s1, s2;             // S的总时尚值、总美丽值

// 比较函数：按时尚值升序排序
bool cmpf(int a, int b) {
    return x[a] < x[b];
}

// 比较函数：按美丽值升序排序
bool cmpb(int a, int b) {
    return y[a] < y[b];
}

// 更新指针：确保四个指针指向未选元素
void update() {
    // 更新时尚值数组指针：跳过已选元素
    while (curfl <= curfr && vis[f[curfl]]) curfl++;
    while (curfl <= curfr && vis[f[curfr]]) curfr--;
    // 更新美丽值数组指针：跳过已选元素
    while (curbl <= curbr && vis[b[curbl]]) curbl++;
    while (curbl <= curbr && vis[b[curbr]]) curbr--;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    // 读入数据
    cin >> n;
    curfl = 1, curfr = 2 * n; // 初始化指针：时尚值数组范围[1, 2n]
    curbl = 1, curbr = 2 * n; // 初始化指针：美丽值数组范围[1, 2n]
    
    // 读入时尚值并初始化索引
    for (int i = 1; i <= 2 * n; i++) {
        cin >> x[i];
        f[i] = i; // 索引初始为自身
    }
    // 读入美丽值并初始化索引
    for (int i = 1; i <= 2 * n; i++) {
        cin >> y[i];
        b[i] = i;
    }
    
    // 对索引数组排序：f按x升序，b按y升序
    sort(f + 1, f + 2 * n + 1, cmpf);
    sort(b + 1, b + 2 * n + 1, cmpb);
    
    // 处理n轮选择
    for (int i = 1; i <= n; i++) {
        int q;
        cin >> q; // 本轮指示：1-时尚最大，2-美丽最大
        
        update(); // 更新指针，确保指向未选元素
        
        if (q == 1) { // M选择时尚值最大
            // 1. M选时尚值最大的化妆品
            int idx = f[curfr];   // 当前时尚值最大的索引
            m1 += x[idx];         // 累加时尚值
            m2 += y[idx];         // 累加美丽值
            vis[idx] = true;      // 标记已选
            curfr--;              // 指针左移
            
            update(); // 更新指针（S选择前需跳过新选元素）
            
            // 2. S选时尚值最小的化妆品
            idx = f[curfl];       // 当前时尚值最小的索引
            s1 += x[idx];         // 累加时尚值
            s2 += y[idx];         // 累加美丽值
            vis[idx] = true;      // 标记已选
            curfl++;              // 指针右移
        } else { // M选择美丽值最大
            // 1. M选美丽值最大的化妆品
            int idx = b[curbr];   // 当前美丽值最大的索引
            m1 += x[idx];         // 累加时尚值
            m2 += y[idx];         // 累加美丽值
            vis[idx] = true;      // 标记已选
            curbr--;              // 指针左移
            
            update(); // 更新指针
            
            // 2. S选美丽值最小的化妆品
            idx = b[curbl];       // 当前美丽值最小的索引
            s1 += x[idx];         // 累加时尚值
            s2 += y[idx];         // 累加美丽值
            vis[idx] = true;      // 标记已选
            curbl++;              // 指针右移
        }
    }
    
    // 输出结果
    cout << m1 << ' ' << m2 << '\n'; // M的时尚值和美丽值
    cout << s1 << ' ' << s2 << '\n'; // S的时尚值和美丽值
    
    return 0;
}
```

时间复杂度为 $O(n)$（忽略 $O(n \log n)$ 的排序）。

---

## 作者：yanrs1019 (赞：0)

# 题解：P13239 「2.48sOI R1」化妆品  
## 形式化题意  
给定两个长度为 $2n$ 的数组 $F$ 和 $B$，分别表示 $2n$ 个物品的两个属性 $F_i$ 和 $B_i$。所有 $F_i$ 互不相同，所有 $B_i$ 互不相同。  
现在进行 $n$ 轮操作，每轮操作给定一个操作类型 $Q_i$：
- 如果 $Q_i=1$，则先选择剩余物品中 $F$ 值最大的物品，然后选择剩余物品中 $F$ 值最小的物品。  
- 如果 $Q_i=2$，则先选择剩余物品中 $B$ 值最大的物品，然后选择剩余物品中 $B$ 值最小的物品。  

每轮操作选择两个物品，一共选 $n$ 轮，总共 $2n$ 个物品。

## 题目难点及解决方案  
难点在于当按 $F$ 值或者 $B$ 值选定时，每次需要按照这个关键字重新排序，显然超时。  
考虑使用两个数组，一个按 $F$ 排序，另一个按 $B$ 排序，在使用双端队列优化即可。  

## ACcode  
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define N 500005
struct node{
	LL id,a,b;
}ast[2*N],bst[2*N];
bool cmpa(node i,node j){
	return i.a>j.a;
}
bool cmpb(node i,node j){
	return i.b>j.b;
}
bool use[2*N];
int main(){
	LL ahead,atail,bhead,btail,n,x,a1=0,b1=0,a2=0,b2=0;
	scanf("%lld",&n);
	ahead=bhead=1;
	atail=btail=2*n;
	for(LL i=1;i<=2*n;i++)scanf("%lld",&ast[i].a),ast[i].id=i;
	for(LL i=1;i<=2*n;i++)scanf("%lld",&ast[i].b),bst[i]=ast[i];
	sort(ast+1,ast+2*n+1,cmpa);
	sort(bst+1,bst+2*n+1,cmpb);
	for(LL i=1;i<=n;i++){
		scanf("%lld",&x);
		if(x==1){
			while(use[ast[ahead].id])ahead++;
			use[ast[ahead].id]=1;
			a1+=ast[ahead].a;
			b1+=ast[ahead].b;
			
			while(use[ast[atail].id])atail--;
			use[ast[atail].id]=1;
			a2+=ast[atail].a;
			b2+=ast[atail].b;
		}
		else{
			while(use[bst[bhead].id])bhead++;
			use[bst[bhead].id]=1;
			b1+=bst[bhead].b;
			a1+=bst[bhead].a;
			
			while(use[bst[btail].id])btail--;
			use[bst[btail].id]=1;
			b2+=bst[btail].b;
			a2+=bst[btail].a;
		}
	}
	printf("%lld %lld\n%lld %lld",a1,b1,a2,b2);
	return 0;
}
```
**注意：开二倍空间。**

---


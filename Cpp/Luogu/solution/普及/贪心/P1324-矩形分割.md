# 矩形分割

## 题目描述

出于某些方面的需求，我们要把一块 $N \times M$ 的木板切成一个个 $1 \times 1$ 的小方块。

对于一块木板，我们只能从某条横线或者某条竖线（要在方格线上），而且这木板是不均匀的，从不同的线切割下去要花不同的代价。而且，对于一块木板，切割一次以后就被分割成两块，而且不能把这两块木板拼在一起然后一刀切成四块，只能两块分别再进行一次切割。

现在，给出从不同的线切割所要花的代价，求把整块木板分割成 $1 \times 1$ 块小方块所需要耗费的最小代价。

## 说明/提示

数据范围：

对于 $60\%$ 的数据，有 $1 \le N,M \le 100$；

对于 $100\%$ 的数据，有 $1 \le N,M \le 2000$。


## 样例 #1

### 输入

```
2 2
3
3
```

### 输出

```
9```

# 题解

## 作者：dingcx (赞：215)

~~由于没有一次AC这道题，所以来发一篇题解。~~
## 思路
~~话说这道题标签已经把思路全部表示出来了。。。~~

问题在于怎么贪心。

样例实在是太水了，以至于怎么切得到的答案都是$9$。

推荐一组样例：
```cpp
输入
4 2
4 5 6
1
输出
19
```
解释一下这组样例。图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/81qkfxdw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

如果先切横的，结果就是$1+2*4+2*5+2*6=31$。

如果先切竖的，结果就是$4+5+6+1*4=19$。

显然先切竖的更优。

由此，可以得出一个结论：**先切代价大的**。

于是，思路就出来了。先把两个数组**从大到小排序**，然后两个数组**挨个比较**，**较大**的就在答案上**加上这个代价**（要**乘上切了多少刀**），再把指针**往后挪一位**，直到全部算完即可。
## 细节
这道题细节还是蛮多的。（~~也就是我没有一次AC的原因~~）

1.是**先取大的**，不是先取小的。

2.注意是$n-1$和$m-1$，不能算成$n$和$m$。

3.最后的答案要**开long long**。

于是就可以愉快地AC了！
## 代码
相信所有人都会看这里吧（~~有没有干不好的事情我就不知道了~~），不过为了题解的完整性，我还是把代码附上——

（~~应该是史上最短~~）
```cpp
#include<cstdio>
#include<algorithm>//用到sort
using namespace std;
const int MAXN=2020;//毕竟刚刚2020~
int a[MAXN],b[MAXN];//横线和竖线的代价
bool cmp(int aa,int bb){return aa>bb;}//从大到小
int main(){
	int n,m,s1=1,s2=1;//s1和s2可以是a数组和b数组的指针，也可以是横纵分成的块数
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++) scanf("%d",&a[i]);
	for(int i=1;i<m;i++) scanf("%d",&b[i]);
	sort(a+1,a+n,cmp);sort(b+1,b+m,cmp);//从大到小排序
	long long ans=0;//记录答案，注意long long
	for(int i=2;i<n+m;i++){//遍历
		if(a[s1]>b[s2]) ans+=s2*a[s1++];//选择大的，这里s2表示块数，s1指针后移一位
		else ans+=s1*b[s2++];//同理，和上面相反
	}
	printf("%lld",ans);
	return 0;//华丽结束
}
```
看我这么辛苦写一篇题解，总得点个赞再走呀~

---

## 作者：wawcac (赞：20)

感觉下面两个Pascal的题解说的不够清楚，还没有cpp的，就来发一个题解吧

###解题思路

得到横着的n-1个代价（h[]）和m-1个竖着的代价（s[]）后可以将它们分别排序（楼下有个Pascal的是将这两个数组混合成a[]，用一个b[]做标记区分横竖），再借用归并的方法（相当于将a[]和b[]归并到一起）代价更大的优先被切(切要付出a[i]\*ch或b[i]\*cs的代价，越靠后切乘上的次数（ch、cs）就越小，这就是本题贪心的精髓)

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int h[2004]={0},n,ch=1/*竖着的被切了多少,横着的代价就乘以几*/,qih=1;
int s[2004]={0},m,cs=1/*横着的被切了多少,竖着的代价就乘以几*/,qis=1;
int cmp(const int & a,const int & b)//从大到小排序的比较函数
{
    return a>=b;
}
int main()
{
    long long ans=0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++)
        scanf("%d",h+i);
    for(int i=1;i<m;i++)
        scanf("%d",s+i);
    sort(h+1,h+n,cmp);
    sort(s+1,s+m,cmp);//对a[]和b[]分别排序
    while(qih<n&&qis<m)
    {
        if(h[qih]>s[qis])
        {
            ans+=h[qih++]*(ch);cs++;
        }
        else if(h[qih]<s[qis])
        {
            ans+=s[qis++]*(cs);ch++;
        }
        else
        {
            if(cs>=ch)
            {
                ans+=h[qih++]*(ch);cs++;
            }
            else
            {
                ans+=s[qis++]*(cs);ch++;
            }
        }
    }
    while(qih<n) ans+=h[qih++]*ch;
    while(qis<m) ans+=s[qis++]*cs;//显眼的归并三个while
    printf("%lld",ans);
    return 0;
}

```

---

## 作者：a___ (赞：13)

其实这题还有一种 $O(nm)$ 的做法  
对于一个 $n * m$ 的矩形，要将它分为 $1 * 1 $的小块，那么至少（不考虑切成两块后需要分别切割）需要分别沿 $ n-1 $ 条横线和 $ m - 1 $条竖线各切一次（亦即 **任意** 两小块的间隙都需要被切开）  
考虑切成两块后需要分别切割：  
我们选择从左上到右下一小格一小格地切割  

- 初始状态
![](https://cdn.luogu.com.cn/upload/image_hosting/r0rx8ac6.png) 
 
  ~~（学校机房用画图画的，有点丑，见谅）~~
- 每条线上先切一次 **（互不相干，互相无法替代）**
![](https://cdn.luogu.com.cn/upload/image_hosting/g4g1jgw3.png)
- 从左上至右下枚举每个交点，有两种情况   

    1.  **横向** ：之前切这条横线时多切了一段，右方段是 **之前就切开的** （不计）  
        **纵向** ：被横向切开交点左右时分成两段，下方段 **须单独切开** （计数）
       ![](https://cdn.luogu.com.cn/upload/image_hosting/us30j0wt.png)
        （绿点是当前交点，颜色相同表示 **同一刀** 切开，颜色相异表示 **分两刀** 切开）    

    2. **纵向** ：之前切这条纵线时多切了一段，下方段是 **之前就切开的** （不计）  
       **横向** ：被纵向切开交点上下时分成两段，右方段 **须单独切开** （计数）
       ![](https://cdn.luogu.com.cn/upload/image_hosting/0iv60bgz.png)
- 贪心，取两种情况最小值，求和，显然就是总代价最小值

c++代码：
```cpp
#include<cstdio>
const int N=2010,M=2010;
int n,m;
long long ans,x[N],y[M];
inline long long min(long long a,long long b){return a<b?a:b}
int main()
{
	freopen("P1324.in","r",stdin);
	freopen("P1324.out","w",stdout);
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<n;i++)
	scanf("%lld",x+i),
	ans+=x[i];
	for(j=1;j<m;j++)
	scanf("%lld",y+j),
	ans+=y[j];
	for(i=1;i<n;i++)
	for(j=1;j<m;j++)
	ans+=min(x[i],y[j]);
	printf("%lld\n",ans);
	fclose(stdin);fclose(stdout);
	return 0;
}
```
[AC记录](https://www.luogu.org/record/24781649)

---

## 作者：盖矣斌峥 (赞：13)


[本人博客](https://prime.design.blog/)

想像一下：

每横着切一刀后，竖着就要多切一刀，竖着切的代价就会变大一倍

每竖着切一刀后，横着就要多切一刀，横着切的代价就会变大一倍

------------

所以很容易想到一种贪心的算法：

先将横着和竖着切的代价从大到小排序

将代价大的先切（这样切一次增加的代价就小一些）

直到全部切完

------------

见代码：
```
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,a[2005],b[2005],heng=0,shu=0;
long long ans=0;
bool cmp(const int x,const int y){return x>y;}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<m;i++)
		scanf("%d",&b[i]);
	sort(a+1,a+n,cmp);
	sort(b+1,b+m,cmp);
	while(heng!=n&&shu!=m)
	{
		if(a[heng+1]>=b[shu+1])
		{
			ans+=a[heng+1]*(1+shu);
			heng++;
		}
		else {
			ans+=b[shu+1]*(1+heng);
			shu++;
		}
	}
	while(heng!=n||shu!=m)
	{
		if(heng!=n)
		{
			ans+=a[heng+1]*(1+shu);
			heng++;
		}
		else {
			ans+=b[shu+1]*(1+heng);
			shu++;
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Creroity (赞：7)

#### ~~水题~~，蒟蒻表示用一个数组就够啦~

可以用结构体再定义一个 $bool$ 类型的变量，~~虽然和开俩数组是一样的。~~

主要的思路是贪心，因为横着的刀数切多了之后，竖着切需要的次数就会变多。所以可以排序之后先切大的，这样就可以把小的多切几次，从而达到使总价值小的目的。

输入时判断一下是横着的价值还是竖着的价值，然后排序的时候按照价值大小直接排序（不需要考虑横着还是竖着）。然后再循环，若是横着切的，接下来竖着切时次数加一即可（竖着同理）。

注意：计算答案的变量要开 long long ，不然会炸。

#### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,tot;
long long ans;//不开 long long 见祖宗 
struct node{
	int num;
	bool f;
}a[4005];//要开双倍，因为一个数组要记横着和竖着的 
bool cmp(node x,node y){
	return x.num>y.num;//直接按照大小排序 
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n+m-2;i++){
		cin>>a[i].num;
		if(i>n-1)a[i].f=true;//将竖着的标为 true 
	}
	sort(a+1,a+n+m-1,cmp);//排序的时候要把 n 和 m 加起来 
	int hc=1,sc=1;
	for(int i=1;i<=n+m-2;i++){
		if(a[i].f)sc++,ans+=a[i].num*hc;//计算 
		else hc++,ans+=a[i].num*sc;
	}
	cout<<ans;//输出 
	return 0;
}
```
~~卑微求赞~~

---

## 作者：Jiyuu_no_Tsubasa (赞：4)

首先分析题目，显然使用贪心算法。

对于本题来说，每一条边都要选，因此贪心的点就在于选择的顺序。

显然，每次答案的累加，加上的不是代价本身，

而是代价 $\times$ 目前其相反方向被分成的块数。

因此我们可以得出一个结论：

## 每条边的代价越大，选择优先级越高

因为如果先选代价小的，那么大的代价 $\times$ 较多块数显然不优。

所以思路就出来了：

1. ### 把 $2$ 个数组按降序排序
1. ### 定义 $2$ 个指针先指向数组受个元素
1. ### 依次比较 $2$ 个指针所指元素，取较大值并后移直至全部处理完

代码：

```
#include<bits/stdc++.h>
using namespace std;
int a[2001];
int b[2001];
int sa=1,sb=1;//已经切出的块
long long ans;
bool cmp(int x,int y){//比较函数
    return x>y;
}
int main(){
    int n; cin>>n;
    int m; cin>>m;
    for(int i=1;i<n;i++)
        cin>>a[i];
    for(int i=1;i<m;i++)
        cin>>b[i];
    sort(a+1,a+n,cmp);//排序
    sort(b+1,b+m,cmp);
    while(sa<n&&sb<m){
        if(a[sa]>b[sb])
            ans+=a[sa++]*sb;
        else ans+=b[sb++]*sa;
    }
    while(sa<n) ans+=a[sa++]*sb;
    while(sb<m) ans+=b[sb++]*sa;
    cout<<ans;
    return 0;
}
```
## 易错点：

+ 分别输入 $n-1$ 与 $m-1$ 个数
+ 排序顺序需注意，$sort$ 默认降序
+ 答案较大，需开 $long$ $long$
+ 指针与已切块数可以用一个变量记录（想想为什么
## 完结撒花

---

## 作者：Tiphereth_A (赞：4)

翻了一圈发现好像没有证明正确性的

这里补一个比较严谨严谨的证明(虽然挺显然的)

设当前已横切$T$刀, 纵切$S$刀

考虑之后连续的两步, 则共三种情况

情况1

![](https://cdn.luogu.com.cn/upload/image_hosting/mdd78lt2.png)

假设横切代价为$M$, 纵切代价为$L$

则先横切后纵切代价为$MS+L(T+1)$, 反之则为$LT+M(S+1)$

代价最小值$\min\{MS+L(T+1),LT+M(S+1)\}=\min\{L,M\}+LT+MS$, 故此时先切较大的最后结果较小

情况2&3

![](https://cdn.luogu.com.cn/upload/image_hosting/do1f6cwv.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/habu32qx.png)

此时无论先切哪个结果都相同


---

## 作者：233333_ (赞：4)

DP：
f[i][j]表示横切i刀竖切j刀（从大到小切）的最小代价，复杂度O(n^2）

贪心：

只考虑横向的一个值x和纵向的一个值y之间的先后，显然先选取大的更优

假设把每组x、y从大的向小的连边，最终会形成一张DAG

跑拓扑序即为最优解

好了上面那些都是废话【划掉

所以把所有的2(n-1)个值直接从大到小sort一下贪心选取即可


code：

//假装这里有代码


---

## 作者：Kiloio (赞：3)

# 贪心 
### 先看题意：  
题目给一个$N \times M$的格子矩阵, 要沿着**格子线**将矩阵切成$1 \times 1$的格子。    

切相应的线会有相应的**代价**，要求这个代价最小。  


------------
  
### 简单分析：   
- 题目要求很明确：求**最小的代价**。  

- 如果要使矩阵成为$1 \times 1$的格子，每条线都**必然是要切**的。  

- 代价是**累乘**的（题干有说）。  
  
- 每条边**都是要选**的，所以我们要从**如何让积最小**入手解决问题

- 使积**最小**，我们**优先**选**代价最大**的边。  

提供一组水数据，可以自己验证一下。    

$cin$：  
$4$ $2$  
$2$ $3$ $4$  
$1$

$cout$：  
$13$  

------------

### 解决方法：  
先将横竖的线**降序**（**从大到小**）排序，接下每个边挨个算。完了。  

细节代码中说。  


------------
  
代码：  
```
#include <bits/stdc++.h>
using namespace std;
long long n,m,ans,a[2015],b[2015],aed,bed;//要开long long，int会爆 
bool cmp(int x,int y){//降序排列 
	return x>y;
}
void solve(){
	aed=bed=1;//要初始化1
	sort(a+1,a+n,cmp);//相当于 sort(a+1,a+1+n-1,cmp);
	sort(b+1,b+m,cmp);
	while(aed<n && bed<m){
        if(a[aed]>b[bed]){
            ans+=a[aed]*bed,aed++;
        }
        else{
        	ans+=aed*b[bed],bed++;
		}
    }
    while(1){
    	if(!(aed<n)){
    		break;
		}
    	ans+=a[aed]*bed,aed++;
	}
    while(1){
    	if(!(bed<m)){
    		break;
		}
    	ans+=aed*b[bed],bed++;
	}
}
int main(){
	cin>>n>>m;
	//n、m的矩阵只有n-1和m-1条线 
	for(int i=1; i<=n-1; i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1; i<=m-1; i++){
		scanf("%lld",&b[i]);
	}
	solve();
	cout<<ans;
	return 0;
}
```


---

## 作者：何炳儒 (赞：3)

我都不懂我的方法是贪心还是dp了，好像都用到了。

首先这题先要利用贪心判断出如果同为横的切一定是越费力的越先切，竖的也是一样，所以我们只要事先将横的代价从大到小排序，竖的代价从大到小排序，就可以了。

问题在于我们这刀先取横的还是先取竖的，用f[i][j]来表示我们已经切了i横刀，j竖刀。

下面来看看代码呗：

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;
int h[10000],l[10000],f[5000][5000],n,m;
int hbr(int a,int b){//从大到小排序的函数，抄代码的童鞋小心了，有防伪哦
      return a>b;
}
int main(){
    cin>>n>>m;
      n--;m--;
      for(int i=1;i<=n;i++){
          cin>>h[i];
    }
      for(int i=1;i<=m;i++){ 
          cin>>l[i];
    }
      sort(h+1,h+n+1,hbr); 
    sort(l+1,l+m+1,hbr);
      for(int i=1;i<=n;i++){ 
          f[i][0]=f[i-1][0]+h[i];
    }
      for(int j=1;j<=m;j++){ 
          f[0][j]=f[0][j-1]+l[j];
    }
      for(int i=1;i<=n;i++)
           for(int j=1;j<=m;j++)
               f[i][j]=min(f[i-1][j]+h[i]*(j+1),f[i][j-1]+l[j]*(i+1));
      cout<<f[n][m];
    return 0; 
}
```

---

## 作者：SKTT1Faker (赞：3)

没p党的，那我就发一道吧。

这道是贪心。

贪啥？没错！贪长度。

首先，这道题由于是一个矩阵，所以同条边上的切割线是同长的。

因此，我们只需排一次序即可。

然后，我们再拿最大的边，每拿一条，多一块，下次的权值就多乘一。

（注意，长和边得分开来算!)

代码：

var
x,y,a,b,s,i:longint;

ans：int64；     //一定要开int64，不然输出复数！

```cpp
m:array[1..4000,1..2] of longint;
procedure sort(a,b:longint);  快排
var
i,j,mid,t:longint;
begin
  i:=a;
  j:=b;
  mid:=m[(i+j) div 2,1];
  repeat
    while m[i,1]>mid do i:=i+1;
    while m[j,1]<mid do j:=j-1;
    if j>=i then
    begin
      t:=m[i,1];
      m[i,1]:=m[j,1];
      m[j,1]:=t;
      t:=m[i,2];
      m[i,2]:=m[j,2];
      m[j,2]:=t;
      i:=i+1;
      j:=j-1;
    end;
  until i>j;
  if b>i then sort(i,b);
  if j>a then sort(a,j);
end;
begin
  read(a,b);
  for i:=1 to a-1 do
  begin
    s:=s+1;             //s总个数为切割线总数
    read(m[s,1]);
    m[s,2]:=0;
  end;
  for i:=1 to b-1 do
  begin
    s:=s+1;
    read(m[s,1]);
    m[s,2]:=1;
  end;
  sort(1,s);
  x:=1;
  y:=1;
  for i:=1 to s do
  begin
    if m[i,2]=0 then
    begin
      ans:=ans+m[i,1]*x;切长宽加一
      y:=y+1;
    end;
    if m[i,2]=1 then
    begin
      ans:=ans+m[i,1]*y;  切宽长加一
      x:=x+1;
    end;
  end;
  write(ans);
end.

```

---

## 作者：sel_fish (赞：2)

前言：这是什么水题啊，~~随便一打就过了~~

### 解法：贪心

1. 因为我们需要把一个木板切为全部为1 * 1的，所以我们不管怎么切，结果是一样的，但是如果把花费更高的放到后面，肯定他需要的切的也会更多，所以我们先按花费从大到小排好序，这样花费是最小的

2. 我们再定义两个变量，分别记录横着的木块有几个和竖着的木块有几个，这样后面切的话，如果是竖着切就乘上横着的块，再把竖着的块+1

3. 反手加上一个register和快读，可以更优

**AC代码**

```cpp
#include<cstdio>
#include<algorithm>
#define re register int
using namespace std;
struct node {
	int x,id;
}e[4004];
int n,m,h=1,z=1,cnt;
long long ans;
inline int read() {
	int x=0,cf=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-') cf=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*cf;
}
inline bool cmp(node a,node b) {
	if(a.x==b.x) return a.id<b.id;
	return a.x>b.x;
}
int main() {
	n=read(),m=read();
	for(re i=1;i<n;i++) {
		e[++cnt].id=1;
		e[cnt].x=read();
	}
	for(re i=1;i<m;i++) {
		e[++cnt].id=2;
		e[cnt].x=read();
	}
	sort(e+1,e+cnt+1,cmp);
	for(re i=1;i<=cnt;i++) {
		if(e[i].id==1) {
			ans+=e[i].x*h; z++;
		}
		else {
			ans+=e[i].x*z; h++;
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Eric__Lee__ (赞：1)

**以下是本体题解**
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

const int NR=2100;
int a[NR],b[NR];

struct All{
  int dir,num;  
};

All s[2*NR];

bool cmp(All x,All y)
{
    return x.num>y.num;
}

int main()
{
    int m,n;
    long long ans=0;
    scanf("%d%d",&n,&m);//读入n, m
    n--;
    m--;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//输入横切代价
        s[i].dir=1;//将编号设为1
        s[i].num=a[i];
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&b[i]);
        s[i+n].dir=0;//将编号设为0
        s[i+n].num=b[i];
    }
    sort(s+1,s+1+n+m,cmp);//按num大小排序
    int piece_n=1,piece_m=1;//定义横切块数与竖切块数
    for(int i=1;i<=n+m;i++)
    {
        if(s[i].dir==1)
        {
            ans+=piece_n*s[i].num;//代价添加
            piece_m++;
        }
        else
        {
            ans+=piece_m*s[i].num;
            piece_n++;
        }
    }
    printf("%lld",ans);//输出
    return 0;
}

```


---

## 作者：龟龟我的龟龟 (赞：1)

	这道题贪心就可以了~，每一次挑最大的切割，这样就能得到最优解了。
    附上代码
    

------------
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct cut{
	int x;//是否x方向切
	int y;//是否y方向切
	int w;//一刀消耗
};
bool compare(const cut&a, const cut&b) { return a.w > b.w; }
int main() {
	int x, y, sumx = 1, sumy = 1;
	long long sum = 0;
	cut a[4500];
	cin >> x >> y;
	for (int i = x - 1; i >= 1; --i) {
		cin >> a[i].w;
		a[i].x = 1;
		a[i].y = 0;
	}
	for (int i = x + y - 2; i >= x; --i) {
		cin >> a[i].w;
		a[i].x = 0;
		a[i].y = 1;
	}
	sort(a + 1, a + x + y - 1, compare);
	for (int i = 1; i <= x + y - 2; ++i) {
		sum += (a[i].w*a[i].x*sumx);
		sum += (a[i].w*a[i].y*sumy);
		sumx += a[i].y;
		sumy += a[i].x;
	}
	cout << sumx;
	return 0;
}
```
	小小修改下~不要抄~

---

## 作者：BADFIVE (赞：0)

**题意**: 把一个长 $n$ 宽 $m$ 的矩形，切割成长 $1$ 宽 $1$ 的正方形，每条切割线都有相应的代价，求最小的代价是多少。  
**思路**: 很明显这是一道贪心的题目，要让总代价最小，所以局部代价也要最小。   
切完一条线过后，剩下的矩形需要多切一次。一共要切 $n \ast m -1$ 次，如下图：    
![](https://cdn.luogu.com.cn/upload/image_hosting/o62z3fyx.png?x-oss-process=image/resize,m_lfit,h_570,w_625)   
因为每条线的代价都不一定是相同的，所以我们需要先切代价最高的线。   
记录这个矩形横着切了多少次和竖着切了多少次。

```
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y;
}a[100001];
bool cmp(node a1,node b1){
    return a1.x>b1.x;
}
int main(){
	int n,m,x=0,y=0,ans=0;
    cin>>n>>m;
    for(int i=1;i<n;i++){
    	cin>>a[i].x;
        a[i].y=1;
    }
    for(int i=n;i<=n+m-2;i++){
        cin>>a[i].x;
        a[i].y=2;
    }
    sort(a+1,a+n+m-1,cmp);
    for(int i=1;i<=n+m-2;i++){
    	if(a[i].y==1){
            x++;
            ans+=a[i].x*(y+1);
        }
        else{
            y++;
            ans+=a[i].x*(x+1);
        }
	}
    cout<<ans;
}
```

---


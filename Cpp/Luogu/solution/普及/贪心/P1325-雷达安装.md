# 雷达安装

## 题目描述

假设海岸线是一条无限延伸的直线。它的一侧是陆地，另一侧是海洋。每一座小岛是在海面上的一个点。雷达必须安装在陆地上（包括海岸线），并且每个雷达都有相同的扫描范围 $d$。你的任务是建立尽量少的雷达站，使所有小岛都在扫描范围之内。

数据使用笛卡尔坐标系，定义海岸线为 $x$ 轴。在 $x$ 轴上方为海洋，下方为陆地。




## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/fnezefht.png)

### 数据范围

对于全部数据，$n\le1000$，$ d \le 2\times 10^4$，$ | x_i | \le 2 \times 10^6 $，$ 0 \le y_i \le 2\times 10^4$。

## 样例 #1

### 输入

```
3 2
1 2
-3 1
2 1
```

### 输出

```
2```

# 题解

## 作者：wzm2007 (赞：17)

    因为雷达只能放在x轴上，所以每个岛屿覆盖的其实是一条线段。所以问题变为：每条线段上必须要有雷达。
    1. 先把线段按照右端点从左到右排序
    2. 对于最早的没有雷达的线段，把一个雷达放在它的右端点
    附上代码:

------------

    #include<bits/stdc++.h>
    using namespace std;
    int n,d,ans;
    struct node
    {
        double x,y;
        bool vis=0;
    }a[1010];  //存值
    bool cmp(node p,node q)  //sort的比较函数
    {
        return p.y<q.y;
    }
    int main()
    {
        cin>>n>>d;
        for(register int i=0;i<n;i++)
        {
            double p,q,m;
            cin>>p>>q;
            if(q>d){cout<<-1;return 0;}
            m=sqrt(d*d-q*q);
            a[i].x=p-m,a[i].y=p+m;  //读入处理
        }
        sort(a,a+n,cmp);  //排序
        for(int i=0;i<n;i++)  //挨个循环
        {
            if(a[i].vis)continue;
            ans++;  //累加雷达数量
            a[i].vis=1;  //标记为已经被雷达扫过
            for(int j=0;j<n;j++)
                if(!a[j].vis&&a[i].y>=a[j].x)a[j].vis=1;  //标记范围内的所有点
        }
        cout<<ans;  //输出所需雷达数量
        return 0;  //完美结束
    }
    

------------
	求通过（qwq）

---

## 作者：弹星者 (赞：11)

### 本题采用贪心做法 
由于雷达扫到的范围要尽可能大，所以只能建在海岸线上    
即我们只需要考虑它的横坐标   
显然，对于一个在(x,y)的岛屿，可以扫到它的雷达一定在   
	( x[i]-sqrt(d$*$d-y[i]$*$y[i]) , 
	x[i]+sqrt(d$*$d-y[i]$*$y[i]) )区间       
    为了让雷达数尽可能少，在覆盖一个新的区间时，我们尽量选择它的右端点QWQ   
    所以我们按区间右端点进行排序，再遍历这些区间    
     用temp来记录上一个雷达的放置位置  
    对于一个区间a[i]，当temp小于a[i].l（左端点）时   
    则此岛屿未被覆盖       
    此时把temp赋值为a[i].r即可    
###     判断无解方法
显然，当一个岛屿的y坐标小于d时，都可以被覆盖，那么只需判断：y>d时输出-1就好了      
附上AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans=0;
double d,x[1010],y[1010],temp;
struct node{
	double l,r;
}a[1010];//区间
double cmp(node aa,node bb){
	return aa.r<bb.r;
}//按右端点排序
int main(){
	cin>>n>>d;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
		if(y[i]>d){
			cout<<"-1"<<endl;
			return 0;
		}//判断无解情况
		a[i].l=x[i]-sqrt(d*d-y[i]*y[i]);
		a[i].r=x[i]+sqrt(d*d-y[i]*y[i]);
	}
	sort(a+1,a+n+1,cmp);//按区间右端点排序
	for(int i=1;i<=n;i++){
		if(i==1) temp=a[i].r,ans++;//把第一个雷达放置于第一个区间的右端点
		else if(temp>a[i].l) continue;//如果当前岛屿可被覆盖，就不放雷达
		else temp=a[i].r,ans++;//否则放置一个新的雷达
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Drifterming (赞：6)

\* 雷达覆盖问题 - 问题转化：

-1、将问题稍微进行转化：将基站设为覆盖半径为 D。  则问题变为：每个基站的覆盖区域必须要有雷达。

-2、又因为雷达只能放在 X 轴上，所以每个基站覆盖的其实是一条线段。 则问题变为：每条线段上必须要要         有雷达。

-3、又因为雷达只能放在 X 轴上，所以每个基站覆盖的其实是一条线段。则问题变为：每条线段上必须要要 有雷达。

- 问题：如何贪心？回想活动安排问题。


解题思路：

先计算出每个岛屿与x轴的左右交点，然后按照右端点进行排序，枚举每一个岛屿，①如果这个岛屿没有被雷达覆盖，那么就将一个雷达放在其与x轴的右端交点，并枚举这个岛屿后面的岛屿，判断这个雷达能否将后面的岛屿覆盖。 ②如果该岛屿已经被覆盖，则直接跳过。


代码：






```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define date 100005
using namespace std;
int n;
int d;
int sum;
int x,y;
float z;
int line[date];
struct Point
{
    float x;
    float y;
    bool flag;
}point[date];
bool cmp(Point a,Point b)        //按照与x轴右侧的交点排序 
{
    return a.y<b.y;
}
void work()
{
    for(int i=1;i<=n;i++)
    {
        if(!point[i].flag)        //如果此处没有被雷达覆盖 
        {
            point[i].flag=1;    //把雷达放在与x轴右侧的交点 
            sum++;                //雷达数加一 
            for(int j=i+1;j<=n;j++)        //枚举后面的岛屿 
            {
                if(!point[j].flag&&point[j].x<=point[i].y)        //如果后面的岛屿没有被雷达覆盖，并且与当前的岛有交点 
                {
                    point[j].flag=1;            //标记为已被覆盖 
                }
            }
        }
    }
    cout<<sum;
}
void init()
{
    scanf("%d",&n);
    scanf("%d",&d);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&x,&y);
        if(y>d)
        {
            cout<<-1;
            return;
        }
        z=sqrt(d*d-y*y);        //计算与x轴的交点 
        point[i].x=x-z;            //左交点 
        point[i].y=x+z;            //右交点 
    }
    sort(point+1,point+n+1,cmp);    //排序 
    work();
}
int main()
{
    init();
    return 0;
}
```

---

## 作者：OItby (赞：5)

[传送门](https://www.luogu.org/problemnew/show/P1325)$($雷达安装$)$

这题与[$POJ1328$](http://poj.org/problem?id=1328)的相识程度$……$

![](http://poj.org/images/1328_1.jpg)


------------

### 分析：
- 题目中说雷达必须安装在陆地上$($包括海岸线$)$实际上就是说$\color{red}\text{雷达站必须要建在海岸线上}$

- 雷达的探测距离为d，所以$\color{red}\text{雷达想要覆盖岛屿，就必须和岛屿的距离不超过d}$

- 雷达的建设又有一个活动区间$\color{red}\text{[ x - sqrt (d*d-y*y) , x + sqrt (d*d+y*y) ]}$

- #### 从以上分析可以看出：本题实际上是一个$\color{red}\text{区间取点问题}$，算法标签为$\color{red}\text{贪心}$


------------

### 贪心策略：
先求出每个岛屿能够覆盖的左端点和右端点，再按区间的右端点从小到大排序，依次处理每一个区间。
1. 如果该区间的左端点已在选定点的范围内，移动至下一个区间；
2. 否则，个数加$1$，选择该区间的右端点处建一个雷达。

------------

### 代码：
$\color{red}\text{(此代码是洛谷的，POJ的见}$[$\text{POJ 1328【Radar Installation】}$](https://www.luogu.org/blog/29-student/POJ1328tby))
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

const int N=1200;
struct node{double b,e;}ld[N];

bool Cmp(const node &num1,const node &num2) {return num1.e<num2.e;}

inline void Scanf(int &num1,int &num2)
{
	int f=1; num1=num2=0;
	char s=getchar();
	while(s<'0'||s>'9')
	{
		if(s=='-') f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9') num1=num1*10+s-'0',s=getchar();
	num1*=f;
	f=1;
	while(s<'0'||s>'9')
	{
		if(s=='-') f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9') num2=num2*10+s-'0',s=getchar();
	num2*=f;
}

int main()
{
	int n,d,d2,x,y,Ans=1,i; double Res;
	Scanf(n,d); d2=d*d;
	for (i=1;i<=n;++i)
	{
		Scanf(x,y);
		if (y>d) {printf("-1\n");goto end;}
		else Res=sqrt(d2-y*y),ld[i].b=x-Res,ld[i].e=x+Res;
	}
	sort(ld+1,ld+n+1,Cmp);
	Res=ld[1].e;
	for (i=2;i<=n;++i)
		if (Res<ld[i].b) ++Ans,Res=ld[i].e;
	printf("%d\n",Ans);
	end:
	return 0;
}
```

---

## 作者：_7zz (赞：2)

题意：这道题目是讲给一个坐标轴，在x轴上方给n个点，表示岛屿坐标，然后给定雷达半径（雷达只能放在x轴上，雷达范围是一个圆），问最少需要多少雷达覆盖所有岛屿。

写这道题就觉得题很怪 我的方法也很怪  最后发现和大家写的方法不一样  所以就想记录下来。

首先，我们对所有的点排个序，先按x从小到大，在按y的绝对值从大到小。我们开始遍历每一个点，求出当前点的对于所有点的最优雷达（即表示我们把当前岛屿放在雷达边上，保证接下来最优），记录下此时的雷达坐标。然后继续遍历，判断当前岛屿是否在雷达范围内，如果不在（关键来了~~~）的话我们进行判断，岛屿是否在雷达的左边，如果是的话：我们把雷达向左移动（移动到当前岛屿正好在雷达边上）更新雷达坐标（不增加雷达数目），如果不是的话：我们再次建造一个新的雷达，更新雷达坐标。

即思想为 2步：

遍历排好序的每个岛屿  ：

  如果岛屿在当前雷达范围外进行判断  岛屿是否在雷达左边，如果是执行1，如果不是执行2：

         1.把雷达向左移动，直到岛屿在雷达边上

         2.建造新的雷达，选取最优建造（即岛屿在雷达边上）

那么为什么呢？我仔细想了想，如果当前岛屿不在雷达范围内，且在雷达左边，那就只有在左上方喽，如果我们向左平移雷达坐标，那么之前在雷达当中的岛屿在平移后也还在雷达范围中，为什么？（圆嘛，他是圆的嘛，开玩笑，画个图看一下），如果在岛屿在雷达右边的话，就不行了，那就只能乖乖的在建造一个雷达了。这样我们就不会浪费任何一个雷达。总之大概是这样了。有什么漏洞的话欢迎大家提出~~  
--------------------- 
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
struct ff{
    double x,y;
}f[1050];
bool cmp(ff a,ff b){
    return a.x==b.x?abs(a.y)>abs(b.y):a.x<b.x;
}
int main(){
    int n;
    double d;
    scanf("%d%lf",&n,&d);
    double maxx=0,minn=0;
    for(int i=1;i<=n;i++){
        scanf("%lf%lf",&f[i].x,&f[i].y);
        maxx=max(maxx,f[i].y);
        minn=min(minn,f[i].y);
    }
    if(abs(maxx)>d||abs(minn)>d){
        printf("-1\n");
        return 0;
    }
    sort(f+1,f+1+n,cmp);
    double x=f[1].x+sqrt(d*d-f[1].y*f[1].y);
    int ans=1;
    for(int i=2;i<=n;i++){
        if(d<sqrt(f[i].y*f[i].y+abs(f[i].x-x)*abs(f[i].x-x))){
            if(f[i].x<x){
                x=f[i].x+sqrt(d*d-f[i].y*f[i].y);
            }
            else{
                x=f[i].x+sqrt(d*d-f[i].y*f[i].y);
                ans++;
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}

```
[我的CSDN](https://blog.csdn.net/qq_41330733/article/details/81503411)
版权声明：本文为博主原创文章，转载请附上博文链接！

---

## 作者：Social_Zhao (赞：2)

首先这是一道贪心题。

第一个，雷达肯定是坐标轴上的点，这样视野才最开阔。

根据光路可逆（大雾），岛能看到你，你也就能看到岛。

所以 说我们先处理出每个岛 $(x,y)$ 能看到的坐标轴的范围：

设 $len=\sqrt{d^2-y^2}$     //勾股定理

这个岛能看到的范围就是 $[ x-len , x+len ]$ 。

这样我们就得到了 $n$ 个区间，要保证每个区间内有一个雷达。

这就是 **区间选点** 问题。参见蓝皮书（信息学奥赛一本通 · 提高篇）

```cpp
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

const int MaxN=1005;
struct segment {
	double l,r;
}a[MaxN];
int n;
double d;
int num[MaxN];

inline double calc(double y)
{
	return sqrt(d*d-y*y);
}

inline void init()
{
	scanf("%d%lf",&n,&d); 
	for(register int i=1;i<=n;i++) {
		double x,y;
		scanf("%lf%lf",&x,&y);
		if(y>d) { //如果y太大了，说明在哪放都无济于事
			printf("-1"); 
			exit(0);
		}
		double len=calc(y); 
		a[i].l=x-len; 
		a[i].r=x+len;
		num[i]=1; //这一行和前两行的意思：[l,r]要求有一个点
	}
}

bool cmp(segment x,segment y)
{
	return x.r<y.r;
}

inline void work()
{
	int ans=0; 
	sort(a+1,a+1+n,cmp); //先排序，按右端点
	for(int i=1;i<=n;i++) { //看每一条区间
		double nowr=a[i].r; //这一条区间的右端点。因为放右端点的话就有更大几率影响其他的区间
		if(num[i]<=0) continue; //如果没需求了，就直接跳过
		num[i]--; //需求减一
		for(register int j=i+1;j<=n;j++) { //看后面相交的区间
			if(a[j].l<=nowr) { 
				num[j]--; //同样需求减一
			}
		}
		ans++; //代价加一
	}
	printf("%d",ans);
}

int main()
{
	init(); //初始化出区间
	work(); //贪心
}
```

虽然是两重循环，但是 ~~n太小~~ 后面会自动 ``continue``  ，所以理论上复杂度还是 $O ( n )$ 的，不可能超时。

---


# [GCJ 2014 #2] Up and Down

## 题目描述

给定一个由互不相同的整数构成的序列 $A = [A_1, A_2, \dots, A_N]$，你希望将其重新排列成一个“先升后降”的序列（即存在某个下标 $m$，满足 $1 \leq m \leq N$，使得 $A_1 < A_2 < \dots < A_m > A_{m+1} > \dots > A_N$）。

你只能通过每次交换两个相邻元素的方式来进行重排。你特别感兴趣的是：将序列 $A$ 排列成一个“先升后降”序列所需的**最小交换次数**。


## 说明/提示

**样例解释**

- 在第一个样例中，原序列已经是目标形式（此处 $m=N=3$），无需进行任何交换，答案为 $0$。
- 在第二个样例中，将 $3$ 与 $7$ 交换即可构成“先升后降”序列（此时 $m=3$），因此最小交换次数为 $1$。

## 限制条件

- $1 \leq T \leq 100$
- $1 \leq A_i \leq 10^9$
- 所有 $A_i$ 均互不相同

### Small 数据集（7 分）

- 时间限制：~~60~~ 3 秒
- $1 \leq N \leq 10$

### Large 数据集（11 分）

- 时间限制：~~120~~ 5 秒
- $1 \leq N \leq 1000$

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
2
3
1 2 3
5
1 8 10 3 7```

### 输出

```
Case #1: 0
Case #2: 1```

# 题解

## 作者：Zjb13927701829 (赞：2)

# P13257 [Up and Down](https://www.luogu.com.cn/problem/P13257) 题解
~~这题没黄吧……~~
## 题目理解
题目给我们一个长度为 $n$ 的序列 $a$，让我们通过交换序列中的元素的方式使这个序列变成“先升后降”的序列。（即存在某个下标 $m$，满足 $1 \le m \le n$，使得 $a_1 < a_2 <  \ldots < a_m > a_{m+1} > \ldots >a_n$）
## 解题思路
我们可以用贪心思想解决此题，过程如下：（这里以序列 $5,3,1,6,2,4$ 为例）
1. 找到序列中的最小值 $1$，将它移动到离它**最近的边界**。因为元素 $1$ 距离左边界有 $2$ 个元素，距离右边界有 $3$ 个元素，所以**左边界**是离元素 $1$ 最近的边界。
2. 计算得元素 $1$ 离左边界有 $2$ 个元素，因此将总次数 $+2$。
3. 删除元素 $1$，得到序列 $5,3,6,2,4$，接下来将序列中的最小值 $2$ 进行同样的操作，以此类推。
## 过程分析
你们有没有发现，在不断寻找最小值的时候其实已经有了一个**排序**的操作：
- 由于“先升后降”序列两端要最**小**，所以就寻找序列的**最小值**；
- 为了步数最少，因此要将最小值移动到离它最近的边界；
- 移动完之后这个元素的位置就确定了，之后的操作就**不需要它了**，删除它就是最好的选择。
## [AC](https://www.luogu.com.cn/record/225580863) Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main(){
    scanf("%d",&T);
    for(int cn=1;cn<=T;cn++){
        int n,ans=0;// ans是总次数
        scanf("%d",&n);
        int a[n+10];
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
        while(n){
            int m_in=INT_MAX,p;
            for(int i=1;i<=n;i++) //求最小值
                if(a[i]<m_in) m_in=a[i],p=i;
            ans+=(p-1<n-p?p-1:n-p); //三目运算符判断
            for(int i=p+1;i<=n;i++) //删除
                a[i-1]=a[i];
            n--; //元素数量-1
        }
        printf("Case #%d: %d\n",cn,ans);
    }
    return 0;
}//完结撒花
```
`审核题解不易，管理员辛苦了！`

---

## 作者：Hkb150429 (赞：1)

## 题意
给定一个由互不相同的整数构成的序列 $A = [A_1, A_2, \dots, A_N]$，你希望将其重新排列成一个“先升后降”的序列（即存在某个下标 $m$，满足 $1 \leq m \leq N$，使得 $A_1 < A_2 < \dots < A_m > A_{m+1} > \dots > A_N$）。你只能通过每次交换两个相邻元素的方式来进行重排。你特别感兴趣的是：将序列 $A$ 排列成一个“先升后降”序列所需的**最小交换次数**。

## 思路

我们以 $A=[1,3,8,0,2,4,9]$ 举例：

找到整数 $0$，我们要让它在最前面，它前面有 $3$ 个数，后面也有 $3$ 个数，我们来分析：

我们每次只能换两个相邻元素的方式来进行重排，那么最好的方法就是不走回头路，所以得出结论：前面或后面有几个数，就要交换次数的最小值。

那么，$0$ 就要交换 $3$ 次。

后面以此类推。

## AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[1050];
int main(){
    cin>>t;
    for(int i=1;i<=t;i++){
        int ans=0;
        cin>>n;
        for(int j=1;j<=n;j++){
            cin>>a[j];    
        }
        while(n){
            int mn=2147483647,p;
            for(int j=1;j<=n;j++){
                if(a[j]<mn)mn=a[j],p=j;
            }
            ans+=min(p-1,n-p);
            for(int j=p+1;j<=n;j++)a[j-1]=a[j];
            n--; 
        }
        cout<<"Case #"<<i<<": "<<ans<<"\n";
    }
    return 0;
}
```

---

## 作者：Circle_Table (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P13257)

题意相当明了，在这里总结出要点：第一是此题有多组测试数据；第二是输入为 $n$ 以及一个长为 $n$ 的序列，每次操作可将相邻元素交换位置。求将该序列转换为先单调递增后单调递减的最少操作数。

我们来看样例。样例一告诉我们可以全部单调递增或单调递减。样例二看完后就很明了了。我把样例二制成了一个条形图，方便读者看懂。

![](https://cdn.luogu.com.cn/upload/image_hosting/rxcn0kzq.png)

上方是操作前，下方是操作后。注意到最后完成所有操作后一定是有一个峰值。那么思路也就来了。  
为了保证序列先升后降，我们**从大到小依次确定每个元素的位置**。确定最大元素后再确定次大元素，则次大元素的位置就会受到其制约。可见，大元素的位置会限制小元素的摆放，小元素必须放在大元素的外侧才能保证递增或递减。先确定大元素的位置，才能让小元素有正确的选择范围。  
由于已处理的元素都比当前元素大，它们已经占据靠近峰值的位置，当前元素要放到目标位置就必须**穿过**这些已处理元素，每次穿过一个元素需要一次操作。因此分别记录它左右两边的已处理元素，即大于他的元素，取其中的较小值即可。

大体思路就这么多吧。细枝末节的东西和代码解释我就写在注释里了。本人无压行习惯，但实际上去掉注释和多余换行代码也不算很长。
## 代码如下：

```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;

int solve() {
	int n;
    scanf("%d",&n);
    
    vector<int>a(n);
    map<int,int>mp;
    
    for(int i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
        mp[a[i]]=i;
    }
    
    vector<int>b=a;//b数组用来排序 
    sort(b.begin(),b.end(),greater<int>());
    
    // flag标记是否已处理
    vector<bool>flag(n,0);
    int ans=0;
    
    // 从大到小处理每个元素
    for(ri i=0;i<n;i++)
	{
        int x=b[i];
        int xpos=mp[x];
        
        // 计算左边已处理的数量
        int l=0;
        for(int j=0;j<xpos;j++)
		{
            if(flag[j])l++;
        }
        
        // 计算右边已处理的数量
        int r=0;
        for(ri j=xpos+1;j<n;j++)
		{
            if(flag[j])r++;
        }
        
        // 求最小移动次数(决定左移or右移)
        ans+=min(l,r);
        
        // 标记x为已处理
        flag[xpos]=1;
    }
    return ans;
}

int main() {
    int T;
    cin>>T;
    for(int qwq=1;qwq<=T;qwq++)
	{
    	printf("Case #%d: %d\n",qwq,solve());
    }
    return 0;
}
```

---

## 作者：zhongjunnan561234 (赞：0)

# 题意
给定一个由互不相同的整数构成的序列 $A=[A_{1},A_{2},…,A_{N} ]$，你希望将其重新排列成一个“先升后降”的序列（即存在某个下标 $m$，满足 $1≤m≤N$，使得 $A_{1} <A_{2} <⋯<A_{m} >A_{m+1} >⋯>A_{N}$）。

你只能通过每次交换两个相邻元素的方式来进行重排。你特别感兴趣的是：将序列 $A$ 排列成一个“先升后降”序列所需的**最小交换次数**。
# 思路
### 核心观察
最终序列必须是前段递增 $+$ 后段递减的"山峰"形状。

这样的序列一定是：

前 $m$ 个最小数（升序排列），

后 $N-m$ 个最大数（降序排列）。

### 解决步骤
将原数组排序，

枚举所有可能的分界点 $m$（$1$ 到 $N$）。

对每个 $m$：

前 $m$ 个取排序后的前 $m$ 小数（升序），

后 $N-m$ 个取剩余数（降序），

计算原序列变成该排列的相邻交换次数，

取所有 $m$ 中的最小交换次数。
# AC Code
```
#include<bits/stdc++.h>
using namespace std;
int t,n,a[1050];
int main(){
    cin>>t;
    for(int i=1;i<=t;i++){
        int ans=0;
        cin>>n;
        for(int j=1;j<=n;j++){
            cin>>a[j];    
        }
        while(n){
            int mn=2147483647,p;
            for(int j=1;j<=n;j++){
                if(a[j]<mn)mn=a[j],p=j;
            }
            ans+=min(p-1,n-p);
            for(int j=p+1;j<=n;j++)a[j-1]=a[j];
            n--; 
        }
        cout<<"Case #"<<i<<": "<<ans<<"\n";
    }
    return 0;
}
```

---


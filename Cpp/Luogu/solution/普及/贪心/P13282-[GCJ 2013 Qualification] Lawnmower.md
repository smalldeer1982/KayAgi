# [GCJ 2013 Qualification] Lawnmower

## 题目描述

Alice 和 Bob 家门前有一片草坪，形状为一个长 $N$ 米、宽 $M$ 米的矩形。他们每年都会尝试修剪草坪，以呈现一些有趣的图案。以前他们使用手动剪刀修剪草坪，非常费时费力；但现在他们有了一台新的自动割草机，可以选择不同的割草高度，因此他们想尝试使用它。

这台新的割草机可以设定割草的高度：你可以将其设定为任意一个在 $1$ 到 $100$ 毫米之间的整数高度 $h$，然后它会将所有遇到的高度超过 $h$ 的草修剪到高度 $h$。使用时，你需要从草坪的任意一条边进入；割草机会沿着垂直于该边的直线，以 $1$ 米宽的路径穿过整个草坪，直到从对面的边缘离开草坪为止。割草机的高度只能在它离开草坪时重新设定。

Alice 和 Bob 设计了若干种想要实现的草坪图案。他们想知道，对于每个给定的草坪图案，是否能用新割草机修剪出来。每个图案通过给出草坪上每个 $1$m $\times$ $1$m 方格所希望的草高来描述。

草坪最开始的草高均为 $100$ 毫米。

## 说明/提示

**限制条件**

- $1 \leq T \leq 100$

**小数据集（10 分，测试集 1 - 可见）**

- $1 \leq N, M \leq 10$
- $1 \leq a_{i,j} \leq 2$

**大数据集（30 分，测试集 2 - 不可见）**

- $1 \leq N, M \leq 100$
- $1 \leq a_{i,j} \leq 100$

翻译由 ChatGPT-4.5 完成。

## 样例 #1

### 输入

```
3
3 3
2 1 2
1 1 1
2 1 2
5 5
2 2 2 2 2
2 1 1 1 2
2 1 2 1 2
2 1 1 1 2
2 2 2 2 2
1 3
1 2 1```

### 输出

```
Case #1: YES
Case #2: NO
Case #3: YES```

# 题解

## 作者：chunzhenII (赞：5)

## 思路
割草机性质我们是必须要明白的，割每行或每列只能修剪成一样高的。显然，每行每列我们要割的高度是目标答案中行或列中草的最大值。   
那如果里面较矮的草，割不到怎么办？就只能整行或整列的修改，争取让里面较矮的草被割到。   
所以我们应该找出每行每列的最大值，遍历数组，判断草的高度是否等于列中最高草高度与行中最高草高度中的最小值。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
signed main(){
	cin>>t;
	for(int k=1;k<=t;k++){
		int n,m;
		cin>>n>>m;
		int a[105][105];
		//维护两个数组
		int b[105]={0};//每行最大值 
		int c[105]={0};//每列最大值 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin>>a[i][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				b[i]=max(b[i],a[i][j]);//算出每行最大值 
				c[j]=max(c[j],a[i][j]);//算出每列最大值 
			}
		}
		bool f=1;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(a[i][j]!=min(b[i],c[j])){//不满足割草机性质 
					f=0;
					break;
				}
			}
			if(f==0){
				break;
			}
		}
		cout<<"Case #"<<k<<": ";
		if(f==1){
			cout<<"YES\n";
		}
		else{
			cout<<"NO\n";
		}
	}
	return 0;
}
```

---

## 作者：guoshengyu1231 (赞：2)

# 题意简述
Alice 和 Bob 使用新型自动割草机修剪矩形草坪，需判断给定图案能否通过割草机的特定操作实现。割草机每次只能沿整行或整列进行统一修剪，且修剪高度需设置为该行或列的最小目标高度。
# 思路
首先我们需要明白割草机的操作特性，割草机每次操作必须沿整行或整列进行统一修剪。这意味着每次操作只能把某一行或某一列的高度修成一样高，这显然使应该的。但是现在问题来了，我们如何修剪出高低不同的草？仔细一想便可知道，题目说我们可以将一行或者一列进行修改，所以我们现需要相互配合，才能修剪出高度不同的草。那么接下来我们就需要思考，什么情况的图案割草机能够实现。 $\\$ 

既然我们需要研究什么情况的图案割草机能够实现，那我们先看割草机的操作规则，割草机修剪后高度必须等于该行或列所有格子的最小目标值，那我们都知道，草被割掉了肯定不能再长回去，所以对于每一行或列，我们最少也得设置到该行或列中目标图案中草高度的最大值。因为如果你设置的小一点，那最高的草就会被修掉一点变矮，这一点是毋庸置疑的。那么那些较矮的草该怎么办呢。如果这根草我们需要把他修的更短，我们就只能修改它所属的列了，那如果它所属的列也没办法呢？那就真的没办法了。 $\\$ 

总结一下解题关键，需验证图案是否满足：**每个格子的目标高度是否大于等于所在行最小值和所在列最小值的最大值**。若**所有**点满足该条件则输出“YES”，否则输出“NO”。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=105;
int n,m,a[maxn][maxn],rmax[maxn],cmax[maxn];//rmax：每行的最大值，cmax：每列的最大值
int main()
{
	int T;cin>>T;
	for(int t=1;t<=T;t++)
	 {
	 	memset(rmax,0,sizeof rmax);
	 	memset(cmax,0,sizeof cmax);//多测需清空
	 	cin>>n>>m;
		bool flag=true;//判断是否满足条件
	 	for(int i=1;i<=n;i++)
	 	 for(int j=1;j<=m;j++)
	 	  {
	 	  	cin>>a[i][j];
	 	  	rmax[i]=max(rmax[i],a[i][j]);
	 	  	cmax[j]=max(cmax[j],a[i][j]);
		  }
		for(int i=1;i<=n;i++)
		 for(int j=1;j<=m;j++)
		  if(a[i][j]<min(rmax[i],cmax[j]))//如果不满足条件
		   {
		   	flag=false;
		   	break;
		   }
		printf("Case #%d: %s\n",t,flag?"YES":"NO");
	 }
	return 0;
}
```

---

## 作者：__CuSO4__ (赞：2)

### 题解

注意到，割草操作会将每一行或列的格子修剪到不超过 $h$ 的高度。

那么，对于每一行或列，其修剪的高度一定是所有高度的最大值。

考虑每一个格子，如果它的高度小于所在的行的最大值，并且小于所在的列的最大值，就一定不合法。

即对于第 $i$ 行第 $j$ 列的草坪方格，若 $h_{i,j} < \min(\displaystyle\max_{k=1}^{n}{h_{k, j}}, \displaystyle\max_{k=1}^{m}{h_{i, k}})$，则无解。

在实现时，可以维护每行与每列的最大高度，用两个数组记录下来，再枚举判断每个方格是否合法即可。

### Code:
``` cpp
#include <bits/stdc++.h>
using namespace std;

int T, n, m;
int h[105][105];
int maxH[105];//每行最大的高度
int maxL[105];//每列最大的高度

int main()
{
    cin >> T;
    for (int t = 1; t <= T; t++)
    {
        //最大值要初始化为极小值
        memset(maxH, -0x3f, sizeof(maxH));
        memset(maxL, -0x3f, sizeof(maxL));
        cin >> n >> m;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++) cin >> h[i][j];
        //计算每行每列最大高度
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                maxH[i] = max(maxH[i], h[i][j]);
        for (int j = 1; j <= m; j++)
            for (int i = 1; i <= n; i++)
                maxL[j] = max(maxL[j], h[i][j]);
        //判断是否可行
        bool f = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                if (h[i][j] < min(maxH[i], maxL[j]))
                    f = 0;
        if (f) printf("Case #%d: YES\n", t);
        else   printf("Case #%d: NO\n", t);
    }
    return 0;
}
```

---

## 作者：dhy_2014 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P13282)

我们发现，这个割草机每一列或每一行最多只能割到当前列或当前行的最大高度，那么如果这一个数既小于它所在列的最大高度，又小于它所在行的最大高度，那么它就一定割不到，所以就无解。

根据这个思路，我们可以先定义两个数组 $hmax,lmax$，分别表示每一行的最大高度和每一列的最大高度，接着枚举这个矩阵,如果 $a_{i,j}$ 小于 $\min(hmax_i,lmax_j)$,那么就不合法了，直接输出 `NO` 就行了,一直枚举到最后还一直合法，那就输出 `YES`。

废话不多，上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n,m;
int a[105][105];
int lmax[105];
int hmax[105];
int main(){
    cin>>T;
    for(int o=1;o<=T;o++){
        memset(lmax,0,sizeof(lmax));//多测不清空，亲人两行泪
        memset(hmax,0,sizeof(hmax));
        bool flag=1;
        cin>>n>>m;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                cin>>a[i][j];
                hmax[i]=max(hmax[i],a[i][j]);
                lmax[j]=max(lmax[j],a[i][j]);
            }
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(a[i][j]<min(hmax[i],lmax[j])){
                    flag=0;
                }
            }
        }
        if(flag==0){
            cout<<"Case #"<<o<<": NO\n";
        }
        else{
            cout<<"Case #"<<o<<": YES\n";
        }
    }
    return 0;
}
```

---

## 作者：Doraeman (赞：1)

写 AC 之后看一看算法标签，硬是没看出来这道题跟贪心有什么关系。
## 条件
~~读了题的同学就会发现~~，这道题有 $3$ 个很重要的条件。
1. **割草机的高度只能在离开草地之后更改**。
2. 任意一个方格草只能**与同一行的草一起被剪**或者**与同一列的草一起被剪**。
3. 根据常识，**草被剪之后，其高度只会不变或者变低**。换句话说，草不会被剪高（~~真是句完全正确的废话啊~~）。
## 声明
根据“条件 $2$”，设任意一点 $D(x,y)$ 所在的 $2$ 条线（行、列）分别为 $L_x,L_y$。

根据“条件 $3$”，设任意一条线 $L$ 的“割草机高度”为 $L$ 线上**经过的若干个割草机的高度的最小值**。记作 $H_L$。   
任意一点 $P$ 的最终高度 $H_P$ 也是 $P$ 点上**经过的若干个割草机的高度的最小值**。  
解释：**如果某一点被多个割草机经过，那么其最终高度为所有经过该点的割草机的高度的最小值**。

## 基础分析
首先设想一片草地，你只剪过一次。  
根据“条件 $1$”，这片草地一定至少有一条线上（一行或一列上），所有草的高度相同。  
**反过来想**，如果某一条线上，**草的高度不完全相同**，那么**这条线一定被剪过不止一次**。

## 证明 $1$：某草坪格式不行
根据“条件 $2$”，在我们希望得到的草坪中，如果某个位置 $P(x,y)$ 的草在其对应的 $L_x$ 中不是最高的，就说明 $P$ 这个位置一定**还在 $L_y$ 上被剪过**，且**满足 $H_{L_x}>H_{L_y}$。**

此时，$P$ 点的最终高度为 $H_{L_y}$。然而，$L_y$ 这条线上的任意一点（设其为 $D(x_2,y)$）的最终高度是 $H_D=min\{H_{L_{x_2}},H_{L_y}\}$。  
根据最小值 $min$ 的定义，一定有 $H_D\leqslant H_P$。

由此，$P(x,y)$ 一定满足 $H_P\geqslant H_D$（$D$ 点在 $L_y$ 上）。  
也就是说，$H_P$ 是 $L_y$ 上所有 $H$ 的最大值。

### 同理
反过来想，如果 $Q(x',y')$ 的高度 $H_Q$ 在其对应的 $L_{y'}$ 上不是最大值），那么 $Q(x',y')$ 也必须满足 $H_Q$ 是 $L_{x'}$ 上所有 $H$ 的最大值。

### 结论
根据以上结论，如果某个点 $S(x,y)$ 在其对应的 $L_x$ 上**不是最大值**，**并且**在其对应的 $L_y$ 上**也不是最大值**，那么 $S$ 点一定不会被割草机割出来。直接输出 ```NO```。

以上，我们就证明了：**符合上述草坪格式的草坪不可能被割出来**~~（呼应小标题）~~。

## 证明 $2$：其它草坪格式都可以
这部分比较简单。

找到预期草坪上的任意一个点 $P(x,y)$。
- 如果 $P$ 点在其对应两条线上都是最大值，那么**它一定能被割出来**，此时满足 $H_{L_x}=H_{L_y}=H_P$。
- 如果 $P$ 点在其对应两条线中的任意一条上（设这条线为 $L_z\isin\{L_x,L_y\}$）是最大值，那么直接设 $H_{L_z}=H_P$。**它一定能被割出来**。

其余情况已经在上一环节考虑过了，是不行的。

综上，**上一环节中的草坪格式之外的任何草坪格式，一定能被割草机割出来**，直接输出 ```YES```。收工！

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e2+5;

int n, m, a[N][N];
// 检查同行/列有没有更大值.
bool check(int x, int y){
    bool row = 0;
    for(int j=1; j<=m; j++)
        if(a[x][y] < a[x][j]){
            row = 1;
            break;
        }

    bool col = 0;
    for(int i=1; i<=n; i++)
        if(a[x][y] < a[i][y]){
            col = 1;
            break;
        }
    
    return row && col;
}

int main(){
    int T; cin >> T;
    for(int _=1; _<=T; _++){
        cin >> n >> m;
        for(int i=1; i<=n; i++)
            for(int j=1; j<=m; j++)
                cin >> a[i][j];
		
		// 如果某个位置(i,j)符合check条件,这个草地剪不成. 
        bool flag = 1;
        for(int i=1; i<=n; i++)
            for(int j=1; j<=m; j++)
                if(check(i, j)){
                    flag = 0;
                    break;
                }

        printf("Case #%d: ",_);
        if(flag) printf("YES\n");
        else printf("NO\n");
    }
}
```

---

## 作者：Fennec (赞：0)

## 题目传送门：
[题目传送门](https://www.luogu.com.cn/problem/P13282)
## 题目分析：
这道题要求我们判断给定的草坪高度图案是否可以通过割草机的操作实现。

这个割草机有三个特点：
- 每次操作可以选择任意一行或一列。
- 可以把整行/列修剪到任意高度（但必须统一）。
- 修剪后的高度只能比原来低或保持不变。

## 解题思路：

我们可以先计算每行每列的最大高度，然后检查每个方格是否满足条件。

因为割草机的每次操作都是整行/列进行的，所以：

- 每个方格的高度不可能同时小于所在行和列的最大高度。
- 如果存在这样的方格，说明无论如何修剪都无法达到目标图案。
- 反之，如果所有方格都满足条件，则可以通过适当的修剪顺序实现。

## 代码部分：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int t;
string gc() {
    int n, m;
    cin >> n >> m;
    int a[N][N]; 
    int maxx[N] = {0};//存储每行最大高度 
    int maxy[N] = {0};//存储每列最大高度 
    for (int i = 1; i <= n;i ++) {
        for (int j = 1; j <= m;j ++) {
            cin >> a[i][j];
            maxx[i] = max(maxx[i], a[i][j]);//将a[i][j]与最大高度比较，更新每行最大高度 
            maxy[j] = max(maxy[j], a[i][j]);//将a[i][j]与最大高度比较，更新每列最大高度 
        }
    }
    for (int i = 1; i <= n;i ++) {
        for (int j = 1; j <= m;j ++) {
            if (a[i][j] < maxx[i] && a[i][j] < maxy[j]) {
                return "NO";
            }
        }
    }
    
    return "YES";
}

int main() {
    cin >> t;
    for (int i = 1;i <= t;i ++){
    	cout << "Case #" << i << ": " << gc() << endl;
	}
    return 0;
}

```

---

## 作者：abc1234shi (赞：0)

# 分析
模拟题。
# 题意
这个问题要求模拟割草过程，求出是否能达到规定图形。

割草机的操作规则是：每次可以选择一个高度 $h$，然后选择一条 $1$ 米宽的边，从草地这头到那头，如果某一片边长为 $1$ 米的正方形草地中草的高度高于 $h$，就将这片草的高度修剪到 $h$。否则也就是说，这片草高度比 $h$ 小或等于 $h$，那么这片草地高度不变。这里 $h$ 是自己定义的。完全割完这一整片草地后，再找一条边，可以重新规定 $h$，但是每次割草的过程中，$h$ 是不能改变的。
# 思路
关键点在于，割草机的操作顺序必须满足：对于每一个位置，其最终高度所在的行或列被修剪到此位置的高度或更低的高度，并且之后没有被其他更高的操作所覆盖。

也就是说，如果这个位置所在行中最高草高度小于这个位置所在列中最高草高度，这个位置的草高度就等于这个位置所在行中最高草高度，否则这个位置的草的高度是所在列中最高草高度。
# 思路实现
具体步骤如下：
- 对于每一行，找到该行的最大值。
- 对于每一列，找到该列的最大值。
- 对于每一个位置，检查此位置草的高度是否等于所在列中最高草高度和所在行中最高草高度的最小值。如果是，则可以实现；否则无法实现。
# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100][100],r[100],c[100];
int main() {
	int T,N,M;
	cin>>T;
	for(int k=1; k<=T; k++) {
		cin>>N>>M;
		for(int i=1; i=<N; i++) {
			for(int j=1; j<=M; j++) {
				cin >> a[i][j];
			}
		}
		for(int i=1; i<=N; i++) {
			r[i]=0;
			for(int j=1; j<=M; j++) {
				if(a[i][j]>r[i])r[i]=a[i][j];
			}
		}
		for(int j=1; j<=M; j++) {
			c[j]=0;
			for(int i=1; i<=N; i++)
				if(a[i][j]>c[j])c[j]=a[i][j];
		}

		bool flag=1;
		for(int i=1; i<=N; i++) {
			for(int j=1; j<=M; j++) {
				int m;
				if(r[i]<c[j])m=r[i];
				else m=c[j];
				if(a[i][j]!=m) {
					flag=0;
					break;
				}
			}
			if(flag==0)break;
		}
		cout<<"Case #"<<k<<": ";
		if(flag==1)cout<<"YES\n";
		else cout<<"NO\n";
	}
	return 0;
}
```

---


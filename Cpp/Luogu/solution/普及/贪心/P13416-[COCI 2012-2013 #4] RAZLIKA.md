# [COCI 2012/2013 #4] RAZLIKA

## 题目描述

Mirko 最新的数学作业非常难！给定一个长度为 $N$ 的整数序列 $V$，你需要从中**恰好**移除 $K$ 个数。设 $M$ 为剩下所有数中任意两数的**最大差值**，$m$ 为**最小差值**。请你选择要移除的 $K$ 个数，使得 $M + m$ 的值尽可能小。Mirko 数学不太好，所以他请求你帮忙！


## 说明/提示

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
5 2
-3 -2 3 8 6```

### 输出

```
7```

## 样例 #2

### 输入

```
6 2
-5 8 10 1 13 -1```

### 输出

```
13```

## 样例 #3

### 输入

```
6 3
10 2 8 17 2 17```

### 输出

```
6```

# 题解

## 作者：WJF891210 (赞：2)

~~本蒟蒻又来发题解啦，望管理员大大通过 qwq~~。

[博客食用点这里](https://www.luogu.com.cn/article/cbarfnmu) 

[博客园食用点这里](https://www.cnblogs.com/wjfakeverthing/articles/19034740)

[题目传送](https://www.luogu.com.cn/problem/P13416)

废话不多说，正片开始。

# 正文

## 题目大意

在一个长为 $n$ 的序列 $V$ 之中，要求长为 $n - k$ 的子序列中 $M + m$ 的最小值。

## 求解

> 1. $M$ 可以表示为子序列中差值最大。
> 2. $M$ 表示为子序列中的**极差**（不知道极差的，这里解释一下：极差就是最大值与最小值的差）。
>
> 若此时选出来的子序列存入 $a$ 数组。
> 
> 1表示出来是：
>
> $$
> M = \max(\left| a_i - a_j \right|)\ \ \ \ 1\le i,j \le n-k
> $$
> 
> 2 表示出来: 
> 
> $$M = \max\limits_{i=1}\limits^{n-k} a_{i} -\min\limits_{i = 1}^{n-k} a_{i}$$

>  $m$ 表示为 $a$ 数组中随机选出两个不是一样的数字（**注：只是在原数组的下标不同而不是值不同**）。
>
> 也就是：同上的将选出来的子序列存储进 $a$ 数组。
>
> $$m = min(\left|a_i - a_j\right|)\ \ \ \ 1\le i,j \le n-k$$

如果用此时的两个公式，时间复杂度将来到 $O(n!\times n^2)$

## 优化

通过观察不难发现，如果此时子序列的元素如下 ```2, 9, 4, 1, 7```。那么此时的 $M = 9 - 1$ 并且 $m = 2 - 1$。

如果将这个子序列由小到大的排序后将得到这样的子序列： ```1, 2, 4, 7, 9```。那么可以得到 $m$ 始终为**相邻的两个元素的差值最小**，而 $M$ 始终为子序列中**最后一个元素与第一个元素的差值**。需要注意的是这里差值一定要是**正数**。

这个时候就已经优化掉了 $M$ 的问题。那 $m$ 怎么办呢？

不着急，接着看。

此时的 $m$ 可以将序列做单调队列，因为此时要解决的问题就是要求一段子序列的最小值。[单调队列可见这道模版题](https://www.luogu.com.cn/problem/P1886)。

## code

解决所有问题之后我们来看看代码吧。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 100, inf = 1e7 + 10;
int n, k, a[N];
deque<int>q;
int main(){
	int ans = inf;
	cin >> n >> k;
	k = n - k;
	for(int i = 1;i <= n;i ++) cin >> a[i];
	sort(a + 1,a + n + 1);
	for(int i = 2;i < k;i ++){
		while(!q.empty() && a[q.front()] - a[q.front() - 1] > a[i] - a[i - 1]) q.pop_back();
		q.push_back(i);
	}
	for(int i = k;i <= n;i ++){
		while(!q.empty() && q.front() <= i - k) q.pop_front();
		while(!q.empty() && a[q.front()] - a[q.front() - 1] > a[i] - a[i - 1]) q.pop_back();
		q.push_back(i);
		ans = min(ans, a[q.front()]-a[q.front()-1]+a[i]-a[i-k+1]);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：1232RvE (赞：2)

拿到题首先想到排序，由小到大排序一遍。

手搓样例，发现**排序后**删的一定是两边的，因为如果删中间的，排序后的差的最大值没有受到影响，所以只能删除左右两边的。

预处理排序后数组的相邻之差得到 $m$。

那 $M$ 呢？注意到删掉 $k$ 个元素，容易想到左边删的与右边删的数量之和为 $k$，就是一个滑动窗口。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1000005;
int n,K,d[N],ans=0x7fffffff,cl=1,op=0;
pair<int,int> q[N];
int main(){
	scanf("%d%d",&n,&K);
	for(int i=1;i<=n;i++)
		scanf("%d",&d[i]);
	sort(d+1,d+1+n);
	for(int i=2;i<=n-K;i++){
		while(cl<=op&&q[op].second>d[i]-d[i-1])  op--;
		q[++op]={i,d[i]-d[i-1]}; //处理相邻差值
	}
	for(int i=1;i<=K+1;i++){
		while(cl<=op&&q[cl].first<=i)  cl++;
		ans=min(ans,d[i+(n-K)-1]-d[i]+q[cl].second);
		if(i==K+1)  continue;
		while(cl<=op&&q[op].second>d[i+n-K]-d[i+n-K-1])  op--;
		q[++op]={i+n-K,d[i+n-K]-d[i+n-K-1]};
	}
	printf("%d",ans);
	return 0;
}
```

除了这种方法，还可以用 deque。

什么是 deque？

deque：双端队列（双向队列），是可以在队首和队尾添加、删除元素的一种 stl，对于本题来说特别方便，用 $n$ 次处理就行了，其他思想和上面差不多。

贴一下机房大佬 [@Listedero](https://www.luogu.com.cn/user/1394370) 的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,v[1000010],s[1000010];
int st[1000010],l,r; 
deque<int>q;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>v[i];
	}
	sort(v+1,v+1+n);
	for(int i=1;i<=n;i++){
		if(i==1) continue;
		s[i]=abs(v[i]-v[i-1]);
	}
	int ans=0x7fffffff,L=n-k;
	for(int i=1;i<=n;i++){
		while(q.size()&&q.front()<=i-L+1) q.pop_front();
		while(q.size()&&s[q.back()]>=s[i]) q.pop_back();
		q.push_back(i);
		if(i>=L) ans=min(ans,v[i]-v[i-L+1]+s[q.front()]);
	} 
	cout<<ans;
	return 0;
}
```
感谢观看

---

## 作者：Pratty (赞：2)

分享一种不一样的做法（不同于另外两篇题解）。

我们不使用双端队列，而是用更常用的方法：优先队列！

为了方便表述，以下的 $a$ 数组均指代题目中的 $V$ 数组。

我们很容易发现，**对于排序完的 $a$ 数组，删除的数字一定是一个连续的子序列。**

所以我们对于排好序的 $a$ 数组，记录两个数之间的差值，然后对于 $1\sim n$ 的范围，看看哪段长度为 $n-k$ 的区间中差值的最小值与这段区间末位置和初位置的差值之和最小，最后统计答案。

其中记录区间最小值是提高组和普及组都常用的一种操作，我们可以使用优先队列实现。每次将当前值入小根堆，求最小值的时候先将小根堆上头之前的值去掉，这样子就避免了 $O(n^2)$ 的复杂度，降到了 $O(2n)$。

代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1100000;
int n, k, a[N], sum[N], ans = 1e9;
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
signed main () {
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	for (int i = 2; i <= n; i++) sum[i] = a[i] - a[i - 1];
	for (int i = 2; i <= n; i++) {
		int lst = i - (n - k) + 1;
		q.push(make_pair(sum[i], i));
		if (lst >= 1) {
			while (q.top().second < lst) q.pop();
			ans = min(ans, a[i] - a[lst] + q.top().first);
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：Doraeman (赞：1)

## 引入
首先考虑一个**单调不减**序列 $S$，设其共有 $w$ 个数。  
显然，它的所有数中任意两数的最大差值 $M=S_w-S_1$，最小差值 $m=\min\{S_2-S_1,S_3-S_2,\dots,S_w-S_{w-1}\}$（这个序列共 $w-1$ 个数）。

以上规律比较明显，在实际使用时也相对**便于求出结果**。**对解本题有极大的帮助**。

## 套用规律
既然有了这个简便的规律，就可以把这道题的序列 $V$ 照搬上去。

首先对 $V$ 排序，使其变成像 $S$ 这样的单调不减序列。

由于本题还需要从序列 $V$ 中移除 $K$ 个数，所以最终剩余的序列（设其为 $A$）的长度 $len_A=len_V-K$，也就是本题中的 $N-K$。

为了保证 $M+m$ 最小，**$A$ 序列在 $V$ 中应当是连续的**。
### 证明 $A$ 应在 $V$ 中连续
设 $A=\{V_i, V_{i+1}, V_{i+2}, \dots, V_{j-1},V_j\}$。  
另一个序列 $B=\{V_i, V_{i+1}, \dots, V_{j-1}, V_{j+1}\}$。  
此时 $M_A = V_j-V_i$。  
$M_B=V_{j+1}-V_i$。  
$m_A=\min\{V_{i+1}-V_i,\dots,V_j-V_{j-1}\}$。  
$m_B=\min\{V_{i+1}-V_i,\dots,V_{j+1}-V_{j-1}\}$。
$$
\because V_j \leqslant V_{j+1}
$$
$$
\therefore M_A \leqslant M_B, V_j-V_{j-1}<V_{j+1}-V_{j-1}
$$
$$
\therefore m_A \leqslant m_B
$$
$$
\therefore M_A+m_A \leqslant M_B+m_B
$$
**不存在不连续的与 $A$ 序列长度相同的序列 $B$ 满足 $M_B+m_B<M_A+m_a$**，证毕。  
$A$ 序列跳过中间的某个元素时同理可证。

## 求最大差值
循环遍历每一个 $A$ 序列（设其左端点为 $i$，右端点为 $i+len_A$），每次计算 $M=A_{i+len_A}-A_i$，记录在数组 $maxi$ 中留存使用。

每次遍历区间开头，根据开头的下标求得结尾值，时间复杂度 $\operatorname{O}(N)$。
```cpp
for(int i=1; i<=n-m; i++)
    maxi[i] = a[i+m] - a[i];
```

## 单调队列求最小差值
这部分需要用到区间求最值的时间复杂度最低的写法：~~神秘的~~**单调队列**。

单调队列涉及知识比较复杂，此处条件不允许过多赘述，仅作简介。详细可参考[P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)和[本题题解](https://www.luogu.com.cn/problem/solution/P1886)。

单调队列的核心思想是（以下内容摘自[一位大佬的博客](https://www.luogu.com.cn/article/1fiztcrj)）：
> **“老而更劣的元素永远不可能成为最值。”**

例如：在从左往右滑动窗口求最小值时，考虑右侧新加入一个元素 $a_j$ 时会发生什么。假设区间中已经有的一个元素 $a_i$ 使得 $a_i\geqslant a_j$，那么 $a_j$ 离开窗口一定比 $a_i$ 要晚，且今后 $a_i$ 在队列里的时候 $a_j$ 也一直在队列里。**在 $a_i$ 剩下的生命里直到离开区间，$a_j$ 永远比它小，$a_i$ 再也不可能成为（唯一的）最小值了。**

由此写单调队列求区间最小值，时间复杂度为 $\operatorname{O}(N)$。
```cpp
// 求出 d 数组 
for(int i=1; i<n; i++)
    d[i] = a[i+1] - a[i];
// 单调队列求区间最小值 
deque <int> q;
for(int i=1; i<n; i++){
    while(!q.empty() && d[i] <= d[q.back()])
        q.pop_back();
    q.push_back(i);
    while(!q.empty() && q.front() < i-m+1)
        q.pop_front();
        
    if(i < m) continue;
    mini[i-m+1] = d[q.front()]; 
}
```
以上代码中，$d$ 数组是每个相邻元素的差值，**最小差值一定属于 $d$ 数组。** 

倒数第 $2,3$ 行是记录最小差值部分，将它们记录在 $mini$ 数组中。这部分下标比较混乱，但是可以得到正确答案，大家视自己情况调整即可。

## 求解答案
最后，由不同的 $i$ 求出 $maxi_i+mini_i$ 的值，并计算出最小值，得到答案。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
const int N = 1e6+5;
typedef long long LL;

int n, k, m, a[N], d[N],
    maxi[N], mini[N];

int main(){
    cin >> n >> k;
    m = n - k - 1;
    for(int i=1; i<=n; i++)
        cin >> a[i];
    sort(a + 1, a + n + 1);

    for(int i=1; i<=n-m; i++)
        maxi[i] = a[i+m] - a[i];

    // 求出 d 数组 
    for(int i=1; i<n; i++)
        d[i] = a[i+1] - a[i];
	// 单调队列求区间最小值 
    deque <int> q;
    for(int i=1; i<n; i++){
        while(!q.empty() && d[i] <= d[q.back()])
            q.pop_back();
        q.push_back(i);
        while(!q.empty() && q.front() < i-m+1)
            q.pop_front();
        
        if(i < m) continue;
        mini[i-m+1] = d[q.front()]; 
    }
    
    int ans = INT_MAX;
    for(int i=1; i<=n-m; i++)
        ans = min(ans, maxi[i] + mini[i]);
    cout << ans;
}
```

---

## 作者：b__b (赞：1)

首先我们将恰好移除 $K$ 个数转化为恰好保留 $N-K$ 个数。

我们观察样例：
- 样例 1：$N-K=3$，保留 $3,6,8$，最大差值 $M=8-3=5$，最小差值 $m=8-6=2$，答案 $M+m=7$。
- 样例 2：$N-K=4$，保留 $-1,1,8,10$，最大差值 $M=10-(-1)=11$，最小差值 $m=1-(-1)=2$，答案 $M+m=13$。
- 样例 3：$N-K=3$，保留 $2,2,8$，最大差值 $M=8-2=6$，最小差值 $m=2-2=0$，答案 $M+m=6$。

我们发现最后保留的数列都是排序后的一个连续的子序列，于是我们考虑如何证明这样的答案最优。

首先，我们有一个性质：对于任意一个下标 $i$（$V_i$ 不是数列中的最小值），在所有小于 $V_i$ 的数中，与 $V_i$ 的差的绝对值最小的是 $V_i$ 的前继。

证明：设 $V_i$ 的前继是 $V_j$，我们选取另一个下标 $p$，使得 $p \neq j$ 且 $V_p < V_i$。

首先它们与 $V_i$ 的差的绝对值可以表示为 $V_i-V_j$ 与 $V_i-V_p$。因为 $V_p$ 不是 $V_i$ 的前继，因此 $V_p < V_j$，$V_i-V_p>V_i-V_j$。

我们将 $V$ 从小到大排序，这时数列中的每一个数的前继就是它的上一个数。这样我们就可以方便的得出 $m$ 了。

对于每一个 $M$，我们如果要最小化 $m$，那么我们一定是选取所有差中绝对值最小的那一个，也就是排序后连续的数。

得证。现在我们考虑如何求出一个区间内的 $M$ 与 $m$。

设这个子序列为 $\left[i-k+1,i\right]$。显然 $M=V_i-V_{i-k+1}$，$m=\min\limits_{k \in \left[i-k+2,i\right]} V_k-V_{k-1}$。

我们将 $V_k-V_{k-1}$ 转变为差分，设差分数列为 $P$，则 $m=\min\limits_{k \in \left[i-k+2,i\right]} P_k$。

我们遍历区间的右端点 $i$，则区间 $\left[i-k+2,i\right]$ 每次只会增加和减少一个数字。使用滑动窗口求出这里面的最小值。
```cpp
#include <cstdio>
#include <algorithm>
int arr[1000005], cf[1000005], que[1000005], qhead, qtail;
int main() {
    int n, k;
    scanf("%d%d", &n, &k), k = n - k;
    for (int i = 0; i < n; ++i) scanf("%d", arr + i);
    std::sort(arr, arr + n);
    for (int i = 1; i < n; ++i) cf[i] = arr[i] - arr[i - 1];
    int ans = cf[0] = 0x7fffffff; //防止m取到差分的第一项
    for (int i = 0; i < n; ++i) {
        while (qtail != qhead && i - que[qhead] >= k) ++qhead;
        while (qtail != qhead && cf[que[qtail - 1]] >= cf[i]) --qtail;
        que[qtail++] = i;
        if (i >= k - 1) ans = std::min(ans, arr[i] - arr[i - k + 1] + cf[que[qhead]]);
    }
    printf("%d", ans);
}
```

---

## 作者：Cells (赞：0)

## 思路

要求最大差值和最小差值的和尽可能小，最小差值应该是值相邻的数中取到，在选出 $n - k$ 个数的条件下，最大差值最小也应该选值相邻的一段才能确保最小，所以答案是在一段数值相邻的数中产生，所以我们先排序，选取区间 $[i, j = i + n - k - 1]$，最大差值为 $v_j - v_i$，考虑如何动态维护最小差值，这样问题可以很容易地使用 [可删堆](https://www.cnblogs.com/fusiwei/p/11432510.html) 维护。

## Code

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define int LL
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 1e6 + 10;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n, k, ans;
int v[N];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n >> k;
	
	rep(i, 1, n) cin >> v[i];
	
	sort(v + 1, v + 1 + n);
	
	priority_queue<int, vec<int>, greater<int>> heap, del;
	
	rep(i, 2, n - k) heap.push(v[i] - v[i - 1]);
	
	ans = INF1;
	for(int i = 1, j = n - k; j <= n; i ++, j ++){
		while(!del.empty() && heap.top() == del.top()) heap.pop(), del.pop();//可删堆的精髓,删数 
		ans = min(ans, v[j] - v[i] + heap.top());
		heap.push(v[j + 1] - v[j]);
		del.push(v[i + 1] - v[i]);//加入删除堆 
	}
	
	cout << ans;
	
	return 0;
}
```

---

## 作者：_aszxqw_ (赞：0)

如果这题直接暴力的话，只有 84 分，所以这题正解也该使用滑动窗口和单调队列。那么具体怎么实现呢？首先，我们可以先排序，因为 $\operatorname{M}=\max-\min$ 排序之后可以让计算变简单，因为 $\max$ 和 $\min$ 必定是在窗口的两端。排完序之后，我们就需要在排序后的数组中找到一个长度为 $\operatorname{N}-\operatorname{K}$ 的窗口，让这个窗口的 $\operatorname{M}+m$ 最小。$m$ 的计算直接用单调队列优化即可。

### AC 代码

```
#include <bits/stdc++.h>
using namespace std;
int main() {
    ios::sync_with_stdio(0);//加速
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    int a[n];
    for (int i = 0; i < n; i++) cin >> a[i];
    sort(a, a + n);//排序
    int cnt = n - k;
    int minn = 0x3f3f3f3f3f;
    // 处理相邻差值
    int d[n-1];
    for (int i = 0; i < n-1; i++) d[i] = a[i+1] - a[i];
    // 单调队列维护滑动窗口最小值
    deque<int> mz;
    for (int i = 0; i < n-1; i++) {
        // 移除不在窗口内的元素
        while (!mz.empty() && mz.front() <= i - (cnt - 1)) {
            mz.pop_front();
        }
        // 移除比当前元素大的元素
        while (!mz.empty() && d[i] <= d[mz.back()]) {
            mz.pop_back();
        }
        mz.push_back(i);
        // 当窗口足够大时计算
        if (i >= cnt - 2) {
            int M = a[i+1] - a[i+1 - (cnt-1)];
            int m = d[mz.front()];
            if (M + m < minn) {
                minn = M + m;
            }
        }
    }
    
    cout << minn << endl;
    return 0;
}
```

---

## 作者：zhoujunchen (赞：0)

滑动窗口。

首先我们将数组排序。

然后剩下有 $N-K$ 个数。




我们需要在长度为 $N-K$ 的滑动窗口中找到最小的相邻差值。

可以使用双端队列来维护滑动窗口中的最小差值，最大差值会等于窗口首尾元素的差值。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,k,a[1145140],cz[1145140],ans=1e9;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	int sz=n-k;
	for(int i=1;i<n;i++)cz[i]=a[i+1]-a[i];
	deque<int> q;
	for(int i=1;i<n;i++){
		while(q.size()&&q.front()<=i-(sz-1))q.pop_front();
		while(q.size()&&cz[i]<=cz[q.back()])q.pop_back();
		q.push_back(i);
		if(i>=sz-1){
            int st=i-(sz-1)+1;
            int M=a[st+sz-1]-a[st],m=cz[q.front()];
            ans=min(ans,M+m);
        }
	}
	cout<<ans;
	return 0;
}
```

---


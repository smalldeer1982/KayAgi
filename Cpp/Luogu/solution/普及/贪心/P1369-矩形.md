# 矩形

## 题目描述

给出平面上的 $n$ 个点，请找出一个边与坐标轴平行的矩形，使得它的边界上有尽量多的点。


## 说明/提示

### 数据范围及约定

- 对于 $40\%$ 的数据，$1\le n\le 30$；
- 对于 $100\%$ 的数据，$1\le n\le 300$，各点的横、纵坐标在 $[1,100]$ 范围内。


## 样例 #1

### 输入

```
10
2 3
9 2
7 4
3 4
5 7
1 5
10 4
10 6
11 4
4 6
```

### 输出

```
7```

# 题解

## 作者：嗯。 (赞：214)

  作为标签党的我首先点开标签：贪心~~好有道理的样子~~
  
  再来看数据范围坐标100以内，n<=300，~~数据好水的样子~~
  
  于是我想枚举左上角和右下角的点，然后再加一遍循环，蠢里蠢气的交了上去，结果全T~~美滋滋~~。
  
  于是冷静分析，这是100的5次方，肯定不能过啊。但是好像100的4次方能过哦，于是结合[最大加权矩形](https://www.luogu.org/problemnew/show/P1719#sub)的做法：首先用一个数组记录以（1，1）为左上角，（i，j）为右下角的矩形的权值和。
  
  然后再来枚举左上角，右下角的坐标（100的4次方），通过东拼西凑，算出矩形的权值和，然后按相同操作算出除去边界的小矩形的权值，就是边界的值了（即边界上点的个数）
  
  题目应该没有提高+这么难的。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,ans=0;
int a[101][101];
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
	    int x,y;
	    scanf("%d%d",&x,&y);
	    a[x][y]+=1;//一个点就是一个1的权值
	}
	for(register int x=1;x<=100;x++)
	for(register int y=1;y<=100;y++)
	a[x][y]+=a[x-1][y]+a[x][y-1]-a[x-1][y-1];//记录以（1，1）为左上角，（x，y）为右下角的矩形的权值和
	for(register int i=1;i<=99;i++)
	for(register int j=1;j<=99;j++)
	for(register int x=i+1;x<=100;x++)
	for(register int y=j+1;y<=100;y++)
	{
	    int sum1=a[x][y]-a[x][j-1]-a[i-1][y]+a[i-1][j-1];//（大矩形的权值和）应该很好理解吧，不能理解的可以画个图感性理解，理性分析一下
	    int sum2=a[x-1][y-1]-a[x-1][j]-a[i][y-1]+a[i][j];//小矩形的权值和，同上
	    sum1-=sum2;//边界的值 边界上点的个数
	    ans=ans<sum1?sum1:ans;//和ans比较大小
	}
	printf("%d",ans);
	return 0;
}

```

---

## 作者：汪星人y (赞：168)

# **P1369 【矩形】**
这一题是可以用矩阵的前缀和写的，二维数组G[M][M]用来表示它左边和上边乃至左上方的点数，这么说可能很抽象，可以用下面的例子来表示这个思想：


#### 输入
4

1 2

2 4

3 2

4 3

#### 则现在的图像为：

0 1 0 0 

0 0 0 1

0 1 0 0

0 0 1 0

#### 转化成前缀矩形后图象为：

0 1 1 1

0 1 1 2

0 2 2 3

0 2 3 4

### 还有一个要注意的就是如何计算矩形边上的点数

一个点的前缀和，再减去矩形左下角左边一个点的前缀和，两次减法中都减去了矩形左上角左上方那个点的前缀和，所以要加上那个点的前缀和(具体如何实现需要自己动动脑子哦~ ..qwq,可以用我上面举得那个例子自己动笔画一下图哦~，语文不好请谅解QAQ)


## -----------------------------------这里是代码分割线----------------------------


```cpp
#include<bits/stdc++.h>			//蒟蒻常用的万能头文件 QAQ
using namespace std;
int n,G[1005][1005],maxx=-1,maxy=-1,x,y,maxn=0;
int fff(int i,int j,int ii,int jj){		//fff函数返回矩形左上角为(i,j)、右下角为(ii,jj)矩形内部(包括边上)的点数 
	if(i>=ii||j>=jj)					//在挖空矩形时可能矩形没有“心”，要判断一下，要返回0，因为此时挖不到东西 
		return 0;
	int sum;							
	sum=G[ii][jj]-G[i-1][jj]-G[ii][j-1]+G[i-1][j-1];	//sum用于计算当前矩形中的点数，具体如何实现看上面解析哦QAQ 
	return sum;											//返回矩形上的点数 
}

int main(){                    //这里是主函数qwq 
	scanf("%d",&n);
	for(int i=1;i<=n;i++){           //这里读入各个点的坐标，将其赋为1 
		scanf("%d%d",&x,&y);         //因为各点的横、纵坐标在1~100范围内，所以不会为负数 
		if(x>maxx)                   //但是如果每次都是100*100的找效率很慢 
			maxx=x;					 //所以用maxx、maxy表示此矩形做多能达到的地方 
		if(y>maxy)
			maxy=y;
		G[x][y]=1;
	}
	for(int i=1;i<=maxx;i++)		 //核心1：建立前缀和矩形的图像 
		for(int j=1;j<=maxy;j++)	 //此处用递推写的 qwq 
			G[i][j]=G[i-1][j]+G[i][j-1]-G[i-1][j-1]+G[i][j];		//表示(i,j)点上方、左方和左上方的点数 
	for(int i=1;i<=maxx;i++)
		for(int j=1;j<=maxy;j++)
			for(int ii=2;ii<=maxx;ii++)				//矩形左上角坐标为(i,j)，右下角坐标为(ii,jj) 
				for(int jj=2;jj<=maxy;jj++){		//暴力枚举一下所有可能生成的矩形 
					if(i>=ii||j>=jj)				//如果这个矩形不合法则continue 
						continue;
					int ans=fff(i,j,ii,jj);			//这里可以看一下上面fff函数的解析 
					ans-=fff(i+1,j+1,ii-1,jj-1);	//把矩形实心部分挖掉，ans变成四条边上的点数 
					maxn=max(maxn,ans);				//比较一下在矩形边上可以得到的最大点数 
			}
	printf("%d",maxn);					//输出可以得到的最多的点数 
	return 0;							//完美结束QWQ 
} 
```

不要复制代码哦，自己在不看我代码的情况打一遍，脑子中模拟一下是怎么样实现的，效果最佳哦qwq~

---

## 作者：MloVtry (赞：40)

【这个题显然不是让泥萌N^4跑过去吧.....】

利用前缀和暴力来达到o(n^3)

由于坐标小于100，所以可以统计两个前缀和，一个横向累和，一个纵向累和

（注意，此处定义矩阵为坐标系矩阵，即左下为（1,1），相当于列为x轴）【虽然没差不过说一下大概方便理解吧.......】

这样我们可以暴力枚举一个左边界，一个右边界

|                 |
|                 |
|                 |

（就像这样脑补两条线在矩阵里扫来扫去）

确定左右边界之后，我们要找到一上一下两个线段来封闭，使之成为矩形

枚举一个上方横线

这时，

| . . . . |
|        |
|        |
如果我们可以确定一个下边界，就可以用前缀和来求出边界点数了

下边界可以贪心的维护

如果当前这个线段，其点数，要比两侧的点数加上原下边界点数多，那么让这个线段来做下边界（.....感觉说的不清楚，可以直接看看代码）

代码
    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int s[110][110];
int s1[110][110];
int tmp[110],ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int x,y;scanf("%d%d",&x,&y);
        s[x][y]++;
        s1[x][y]++;
    }
    for(int i=1;i<=100;++i)
    for(int j=1;j<=100;++j) s[i][j]+=s[i-1][j],s1[i][j]+=s1[i][j-1];
    for(int l=1;l<=100;++l)
    {
        for(int r=l;r<=100;++r)
        {
            for(int i=1;i<=100;++i) tmp[i]=s[r-1][i]-s[l][i];
            int d=1;
            for(int t=1;t<=100;++t)
            {
                int get=tmp[t]+tmp[d]+s1[l][t]-s1[l][d-1]+s1[r][t]-s1[r][d-1];
                ans=max(ans,get);
                if(tmp[t]>tmp[d]+s1[l][t-1]-s1[l][d-1]+s1[r][t-1]-s1[r][d-1]) d=t;
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
//我永远喜欢柚子.jpg
//~~~~w~~~~~

```

---

## 作者：Zroom (赞：17)

很多人用前缀数组把题目转化为最大子矩阵问题。（如果存在一个点（x，y）则（x，y—）权值为1，否则为0）因为题目坐标是在100以内，所以可以这么做，题者或许也不想为难大家。
但是如果坐标变为*绝最值都在1e9*内，那就不行了。
所以我这里介绍一种更通用的算法，看完可以去试试UVA1382那道题。
最朴素的算法是枚举四条边界，还要统计点。肯定是不行的。
还是考虑用前缀的思想

为了方便阅读，这里定义x为竖线，y为横线
- 任务：枚举上下左右四条线，但希望通过其他信息加上贪心找最优解的策略，来部分枚举。
- 先想一个框架：固定两条y，s【i】表示到第i个点为止的线上的点个数（后面并不会用到，因为你求不出。）找到一个最大的s【i】 - s【j-1】就是答案。
- 想少枚举一条边怎么办？
- 前缀和？ 如果把两条y固定，用L[i]数组记录到第i个点为止的y线上的点的个数(L[i]并不包含i这个点所在的竖线），那么首先需要给x，y坐标排个序。
- 希望给x，y都从小到大排序，这样好枚举y的上下界，求L数组。
- 用on[i]表示x线（不包含y线上的点），你希望通过前面的信息递推出后面的L[i],这样你希望得到上一段横线L[i-1]到L[i]之间y上的点的个数， 但是on数组又不包含y上的点。这样只好再用一个数组on1【i】表示x上包含y的点的个数。
- 拿出笔模拟一下。
- 这样递推求L[i] = L[i-1] + on1[i-1] - on[i-1];
- 线上点的个数s[i][j] = L[i] - L[j] + on1[i] + on[j];
- 这样在固定了y的情况下L[i] 和 on1[i]是固定的，这样只要求max(on[j] - L[j])了。
现在大致有思路了吧。
先打个大致框架：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 300 + 10;
int L[N],on[N],on1[N],n,y[N];//为了枚举y的上下界，复制一份y坐标到y【】中。
struct node{
   int x,y;
   bool operator < (const node &rp) const {
    return x < rp.x;}
}p[N];
int work()；//用来求值，放着待会写；
int main()
{
   scanf("%d",&n);
   for(int i = 1;i <= n ;i++){scanf("%d%d",&p[i].x,&p[i].y);y[i] = p[i].y;}
   printf("%d\n",work());
   return 0;
}//直接复制可能会死，因为我直接在“插入代码”那里打的。
```
现在来考虑怎么写work
- 首先排序是必不可少的。sort（p...)sort（y...);
- 然后给y去个重。m = unique(y + 1,y + 1 + n）- y。突然发现只要y不同的小于等于2，就必然可以全部用一个框框住，当然x也一样。
- 开始枚举y的上下界，两个for，得到maxy 和miny。
- 然后开始扫描x，for循环求L，顺带on和on1.
- 最后用“- 这样在固定了y的情况下L[i] 和 on1[i]是固定的，这样只要求max(on[j] - L[j])了。”这一条求出答案。
还是给你们代码吧。
```cpp
int work(){
    sort(p+1,p+1+n);sort(y+1,y+1+n);
    m = unique(y+1,y+1+n)-y;if(m <= 2)return n;
    //unique返回指针，- y就是不同y的个数
    int ans = 0;
    for (int a = 1;a <= m;a++)
    for (int b = a+1;b <= m;b++) {
        int maxy = y[b],miny = y[a];
        int k = 0;
        for (int i = 1;i <= n;i++)  {
            if(p[i].x != p[i-1].x) {//如果x相同不就是同一条竖线吗？所以要不同。
                k++;on[k] = on1[k] = 0;
                //L不算在竖线上的，on1算在横线上的，on不算
                L[k] = L[k-1] + on1[k-1] - on[k-1];
            }
            if(p[i].y > miny && p[i].y < maxy)on[k]++;
            if(p[i].y >= miny && p[i].y <= maxy)on1[k]++;
        }
        if (k <= 2)return n;
        int mx = 0;
        for (int j = 1;j <= k ;j++) {
            ans = max(ans ,L[j] + on1[j] + mx);
            mx = max(mx,on[j] - L[j]);//同时求max，两个max相加一定最优
        }
    }
    return ans;
}
```
最后各位大佬发题解不要说什么这个题很水之类的话，大家都是从菜鸡过来的，不要那么趾高气昂。

---

## 作者：Re_Fable (赞：14)

# P1369矩形

首先感谢  汪星人y  大佬提供的思路。

思路本质上没有什么差别，只是增加了图片，提高阅读体验。

### 二维前缀和+贪心

#### 输入

```
7
1 5
2 1
2 4
3 4
4 2
4 5
5 3
```

可以得到一个图像

![](https://cdn.luogu.com.cn/upload/image_hosting/dzw72eqs.png)

转换成二维前缀和，

~~相信大家都知道二维前缀和，就不详细解释~~

首先可以枚举得到矩形覆盖的所有点的个数，

通过：

![](https://cdn.luogu.com.cn/upload/image_hosting/53r1ds37.png)

如上方法，

即总的，减蓝色的竖列，减粉色的横列，加上多减去一次的紫色部分。

然后，同理减去中间部分的矩形上点的个数，

![](https://cdn.luogu.com.cn/upload/image_hosting/1fenmezy.png)

从而得到矩形边框搜覆盖的点的个数。

AC代码
```
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}//随便写个快读 
int n,ans,maxn,maxx/*记录最远的横坐标*/,maxy/*记录最远的纵坐标*/;
int a[101][101]/*记录点的位置*/,sum[101][101]/*二维前缀和*/;
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		int k=read(),l=read();
		maxx=max(maxx,k);
		maxy=max(maxy,l);
		a[k][l]=1;
	}
	for(int i=1;i<=maxx;i++){
		for(int j=1;j<=maxy;j++){
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
			/*二维前缀和的代码*/ 
		}
	}
	for(int i=1;i<=maxx;i++){
		for(int j=1;j<=maxy;j++){
			for(int k=i;k<=maxx;k++){
				for(int l=j;l<=maxy;l++){
					ans=(sum[k][l]-sum[i-1][l]-sum[k][j-1]+sum[i-1][j-1])-(sum[k-1][l-1]-sum[i][l-1]-sum[k-1][j]+sum[i][j]);
					//前半段计算枚举范围内总的点数(灰色部分)，后半段计算剪掉的中心点数（黄色部分） 
					maxn=max(maxn,ans);//最大值 
				}
			}
		}
	}
	printf("%d",maxn);//输出 
	return 0;
}
```
蒟蒻第一篇题解，qwq

~~如果有帮到你的地方，求赞~~

---

## 作者：Holy_Push (赞：10)

这道题虽然可以用$n^4$暴力搞过去，但是显然出题人的意图不是这样的。这里给出一种看起来挺简单的$O(n^3 )$的算法。

事实上，遇到这种子矩阵的问题，我们有一个基本思路就是：**枚举两列一行（或两行一列），用有些奇怪的方式维护另一行（或列）**，这样就将时间复杂度降到了$O(n^3)$。具体怎么操作呢？

显然，前缀和是需要的。但我们不需要二维前缀和，我们只需要在二维数组上做一维前缀和。我们记$Col[i][j]$表示第$i$行内，到第$j$列的前缀和。$Row[i][j]$表示第$j$列内，到第$i$行的前缀和。于是我们有下列预处理：

```cpp
for (int i=1;i<=n;i++)
	{
		int x,y;scanf("%d%d",&x,&y);
		Col[x][y]++;Row[x][y]++;
	}
	for (int i=1;i<=100;i++)
		for (int j=1;j<=100;j++)
			Col[i][j]+=Col[i][j-1],Row[i][j]+=Row[i-1][j];
```
然后我们就按照上面的思路，我们枚举两列一行，再讨论另一行。

例如我们目前枚举到这一种状况：

![](https://cdn.luogu.com.cn/upload/image_hosting/pc0xi0nt.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们枚举另一行。假设红色的即为我们枚举到的行。

![](https://cdn.luogu.com.cn/upload/image_hosting/6jpp3u9h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

怎么统计答案呢？我们都算了前缀和了，我们当然要用前缀和算了啦！（图中$A,F$为行的上界）

![](https://cdn.luogu.com.cn/upload/image_hosting/sa5wvdto.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

方便起见，记$P(l)$表示线段$l$上点的数量。

我们要求的答案为$P(CE)+P(BD)+P(BC)+P(DE)-C-B-D-E$

根据前缀和，可以化为$P(AB)-P(AG)+P(DF)-P(HF)+P(CE)+P(BD)-B-C-D-E$（为什么看起来还烦了）

但是这样我们可以优化了！我们将下一行和上一行的内容分开来就变成了$[P(BD)-B-D+P(AB)+P(DF)]-[P(AG)+P(HF)-P(CE)+C+E]$

第一部分可以在枚举第一行的时候计算完成。于是我们要记录第二部分。显然第二部分可以通过求$min$来保存，因此我们现在没必要枚举第二行了。完结！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200;

int n,ans,Row[N][N],Col[N][N];

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		int x,y;scanf("%d%d",&x,&y);
		Col[x][y]++;Row[x][y]++;
	}
	for (int i=1;i<=100;i++)
		for (int j=1;j<=100;j++)
			Col[i][j]+=Col[i][j-1],Row[i][j]+=Row[i-1][j];
	for (int i=1;i<=99;i++)
		for (int j=i+1;j<=100;j++)
		{
			int Max=Col[1][j-1]-Col[1][i];
			for (int k=2;k<=100;k++)
			{
				ans=max(ans,Col[k][j-1]-Col[k][i]+Row[k][i]+Row[k][j]+Max);
				Max=max(Max,Col[k][j-1]-Col[k][i]-Row[k-1][i]-Row[k-1][j]);
			}
		}
	printf("%d\n",ans);
}
```


---

## 作者：RocketTurtle (赞：4)

看到题面只能想到暴力，但是在众多大佬中看到了一篇@MloVtry这位大佬O(2*n^3)的题解（前缀和的方法）。于是借鉴了这篇题解，思路是一样的。但是最后大佬说最后一部分讲不清楚，我就来补充一下俺的理解。**（不知道为啥洛谷官方给我题解反馈的是排版不整齐，但是俺在前台查看的时候没有什么问题啊，求过QWQ）**

**以下是我的理解：**

**1：用两数组分别计算横向前缀和and竖向前缀和,分别用**heng[i][j]**(第i前j个数和)和**shu[i][j]**(第j列前i个数和)表示。
一开始输入坐标的时候别忘记初始化一下。**

**2:坐标范围在1~100之间，所以为了方便，在枚举上下边界的同时，用一tmp数组去记录两边界之间某一列的点数,tmp[i]表示上下边界之间第i列的点数。**

**3：最后一步就是枚举左右边界，d表示左边界，然后枚举右边界。**

**以下是我的分布讲解：**


~~~
if(tmp[k]>tmp[d]+heng[l][k-1]-heng[l][d-1]+heng[r][k-1]-heng[r][d-1]) d=k;
~~~

**大佬在这个地方的话说不清楚，那俺就补充下吧。为什么当前这个线段的总点数比（两侧点数+左边界点数）多的话就更新左边界至右边界的的位置呢？因为左边界收缩时其上下边界域的范围也在收缩，也就是要想在收缩后矩形边界上包含的点数>收缩前矩形边界包含的点数，就要保证新的左边界的点数要大于（上下两侧点数+原左边界的点数）**

代码的话其实这位大佬的差不多，感谢这位大佬贡献的O(2*n^3)的方法

**1：初始化前缀和数组**
~~~
for(int i=1;i<=n;i++){
	int x,y;cin>>x>>y;
	heng[x][y]++;shu[x][y]++;
}
~~~

**2：计算前缀和**
~~~
for(int i=1;i<=100;i++){
    for(int j=1;j<=100;j++){
        heng[i][j]+=heng[i][j-1]；
        shu[i][j]+=shu[i-1][j];
    }
}

~~~


**3：l枚举上边界，r枚举下边界，tmp统计上下边界之间每一列的点数.**
~~~
for(int l=1;l<=100;l++){
    for(int r=l;r<=100;r++){
	    for(int i=1;i<=100;i++) tmp[i]=shu[r-1][i]-shu[l][i];
	    int d=1;
	    for(int k=1;k<=100;k++){
            int ans=tmp[d]+tmp[k]+heng[r][k]-heng[r][d-1]+heng[l][k]-heng[l][d-1];
	        maxx=max(ans,maxx);
	        if(tmp[k]>tmp[d]+heng[l][k-1]-heng[l][d-1]+heng[r][k-1]-heng[r][d-1]) d=k;
	    }
    }
}
~~~
**以下是对上面代中的ans解释：**

**利用前缀和数组计算矩形边界上的点数**
~~~
int ans=tmp[d]+tmp[k]+heng[r][k]-heng[r][d-1]+heng[l][k]-heng[l][d-1];
~~~

**以下是完整的代码:**
~~~
#include<bits/stdc++.h>
using namespace std;
int heng[200][200],shu[200][200],tmp[200],n;
int main(){
    cin>>n;int maxx=0;
    for(int i=1;i<=n;i++){
	    int x,y;cin>>x>>y;
	    heng[x][y]++;shu[x][y]++;
    }
    for(int i=1;i<=100;i++)
    for(int j=1;j<=100;j++)
    heng[i][j]+=heng[i][j-1],shu[i][j]+=shu[i-1][j];
    for(int l=1;l<=100;l++){
	    for(int r=l;r<=100;r++){
	        for(int i=1;i<=100;i++) tmp[i]=shu[r-1][i]-shu[l][i];
	        int d=1;
	        for(int k=1;k<=100;k++){
	            int ans=tmp[d]+tmp[k]+heng[r][k]-heng[r][d-1]+heng[l][k]-heng[l][d-1];
	            maxx=max(ans,maxx);
	            if(tmp[k]>tmp[d]+heng[l][k-1]-heng[l][d-1]+heng[r][k-1]-heng[r][d-1]) d=k;
	        }
        }
    }
    cout<<maxx<<endl;
    return 0;
}


---

## 作者：SZ_Dong (赞：2)

## **思路**
用两个循环暴力枚举二维前缀和，然后再用四个循环枚举左上角和右下角，~~时间差点就炸了qwq~~，算出整个矩阵的点数，最后减去里面一圈所有的点数就是最外面一圈的点数啦。直接说可能不太好理解，同学们可以自己画一画。

## **code**:
```cpp
#include<iostream>
using namespace std;
typedef long long ll;

ll n,tx,ty,a[101][101],sum[101][101],ans,tans,tans1;

int main(){
    ios::sync_with_stdio(false);

    cin>>n;
    ans=0;

    for(ll i=1; i<=n; i++) {
        cin>>tx>>ty;
        a[tx][ty]=1; //初值为一
    }

    for(ll i=1; i<=100; i++)
        for(ll j=1; j<=100; j++)
            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]; //推导前缀和

    for(ll i=1; i<=99; i++)
        for(ll j=1; j<=99; j++)    
            for(ll x=i+1; x<=100; x++)
                for(ll y=j+1; y<=100; y++) {
                    tans=sum[x][y]-sum[i-1][y]-sum[x][j-1]+sum[i-1][j-1]; //外面一圈的点数
                    tans1=sum[x-1][y-1]-sum[i][y-1]-sum[x-1][j]+sum[i][j];//内圈的点数

                    if(tans-tans1>ans)
                        ans=tans-tans1;//比较
                }

    cout<<ans<<endl;
    
    return 0;	
}
```

---

## 作者：cyrxdzj (赞：1)

### 一、思路

本题可以使用[二维前缀和](https://oi-wiki.org/basic/prefix-sum/#_3)去做。

首先，对于样例输入：

```
10
2 3
9 2
7 4
3 4
5 7
1 5
10 4
10 6
11 4
4 6
```

我们可以得到这样的一张表：

[![Wc589e.png](https://z3.ax1x.com/2021/07/24/Wc589e.png)](https://imgtu.com/i/Wc589e)

其中 $1$ 代表有点的坐标，$0$ 代表无点的坐标。

显然，对于此输入，最佳输出对应的是这一块：

[![WcIqzQ.png](https://z3.ax1x.com/2021/07/24/WcIqzQ.png)](https://imgtu.com/i/WcIqzQ)

答案为 $7$。

问题来了：如何用二维前缀和表示？

如果我们将表格涂色：

[![WgwrBd.png](https://z3.ax1x.com/2021/07/25/WgwrBd.png)](https://imgtu.com/i/WgwrBd)

显然，我们要求的是蓝色部分。

但问题是，蓝色部分不是一个标准的长方形，如何求出蓝色部分之和？

如图，蓝色部分=蓝色部分+紫色部分-紫色部分。

而蓝色部分+紫色部分和紫色部分都是标准的长方形，这就可以使用二维前缀和了。

具体来说，枚举左上角和右下角的两个点，使用二维前缀和求出其中点的数量。

因为坐标从 $1$ 到 $100$，时间复杂度并不是很高。

### 二、完整代码

```cpp
#include<cstdio>
using namespace std;
int input[105][105];
int sum[105][105];
int n,x,y;
int ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)//输入。
    {
        scanf("%d%d",&x,&y);
        input[x][y]=1;
    }
    for(int i=1;i<=100;i++)//预处理二维前缀和。
    {
        for(int j=1;j<=100;j++)
        {
            sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+input[i][j];
        }
    }
    for(int x1=1;x1<=99;x1++)//计算答案。
    {
        for(int y1=1;y1<=99;y1++)
        {
            for(int x2=x1+1;x2<=100;x2++)
            {
                for(int y2=y1+1;y2<=100;y2++)
                {
                    int temp_ans=(sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1])-(sum[x2-1][y2-1]-sum[x1][y2-1]-sum[x2-1][y1]+sum[x1][y1]);//第一个括号里计算的是蓝色部分+紫色部分，第二括号里计算的是紫色部分，两者相减，即为要求的蓝色部分。
                    if(temp_ans>ans)
                    {
                        ans=temp_ans;
                    }
                }
            }
        }
    }
    printf("%d\n",ans);//输出。
    return 0;//完结撒花！
}

```

By [dengzijun](https://www.luogu.com.cn/user/387836)

---

## 作者：yuangq (赞：1)

这道题需要用二维前缀和

~~~
	int t;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		int x1,y1;
		cin>>x1>>y1;
		s[x1+1][y1+1]=1;
	}
~~~
首先我们把有标记的数字的值改为一
~~~
	for(int i=1;i<=101;i++)
	{
		for(int j=1;j<=101;j++)
		{
			s[i][j]+=s[i-1][j]-s[i-1][j-1]+s[i][j-1];
		}
	}
~~~
再对整个数组进行一遍前缀和

不知道二维前缀和左转->

[这里](https://blog.csdn.net/yzyyylx/article/details/78298318)

~~~
	int maxs=-1;
	
	for(int i=1;i<=100;i++)
	{
		for(int j=1;j<=100;j++)
		{
			for(int k=1;k<=101-i;k++)
			{
				for(int l=1;l<=101-j;l++)
				{
					int a=s[i+k][j+l]-s[i+k][j-1]-s[i-1][j+l]+s[i-1][j-1];
					int b=s[i+k-1][j+l-1]-s[i+k-1][j]-s[i][j+l-1]+s[i][j];
					maxs=max(maxs,a-b);
				}
			}
		}
	}
~~~
这是最重要的一部分了

由于只要边上的点，我们只需要把较大一圈减去较小一圈的值就是真正的答案了

如图

![](https://i.loli.net/2019/05/26/5cea750ac2edf96422.png)

高清无注释代码

~~~
#include<bits/stdc++.h>
using namespace std;
int s[5005][5005];
int r;
int main()
{
	int n=0,m=0;
	int t;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		int x1,y1;
		cin>>x1>>y1;
		s[x1+1][y1+1]=1;
	}
	for(int i=1;i<=101;i++)
	{
		for(int j=1;j<=101;j++)
		{
			s[i][j]+=s[i-1][j]-s[i-1][j-1]+s[i][j-1];
		}
	}
	int maxs=-1;
	
	for(int i=1;i<=100;i++)
	{
		for(int j=1;j<=100;j++)
		{
			for(int k=1;k<=101-i;k++)
			{
				for(int l=1;l<=101-j;l++)
				{
					int a=s[i+k][j+l]-s[i+k][j-1]-s[i-1][j+l]+s[i-1][j-1];
					int b=s[i+k-1][j+l-1]-s[i+k-1][j]-s[i][j+l-1]+s[i][j];
					maxs=max(maxs,a-b);
				}
			}
		}
	}
	cout<<maxs;
	return 0;
}

~~~

---

## 作者：asdfghjkl123 (赞：1)

题解里的二维前缀和都是两个for，答案其实可以在维护二维前缀和的同时更新，复杂度可能稍微优秀那么一点点点点点……

```
////////////////////////#include<bits/stdc++.h>
/////////using namespace std;
///////char cccc;
////////int ffff;
////template<class T>
///////void qr(T &ans)
//{
/////    while(((cccc=getchar())<'0'||cccc>'9')&&cccc!='-');
///    ffff=1;
/////    if(cccc=='-')ffff=-1;
//////    else ans=cccc-'0';
//    while((cccc=getchar())<='9'&&cccc>='0')
/////        ans=ans*10+cccc-'0';
///    return;
}
(复制大法go away！)
int sum[101][101];
int n,xmax,ymax,ans=-1;
int main()
{
    qr(n);
    while(n--)
    {
        int i,j;
        qr(i);
        qr(j);
        sum[i][j]++;
        xmax=max(xmax,i);
        ymax=max(ymax,j);
    }
    for(int i=1;i<=xmax;i++)
    {
        for(int j=1;j<=ymax;j++)
        {
            sum[i][j]=sum[i][j]+sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1];
            for(int ii=1;ii<=i;ii++)
            {
                for(int jj=1;jj<=j;jj++)
                {
                    ans=max(ans,sum[i][j]+sum[ii-1][jj-1]-sum[i][jj-1]-sum[ii-1][j]-sum[i-1][j-1]-sum[ii][jj]+sum[i-1][jj]+sum[ii][j-1]);
                }
            }
        }
    }
    printf("%d",ans);
}
```
不过看了看题解觉得这题好像不是想出成二维前缀和的……

欲学正解……请前往那两个非二维前缀和的题解……

---

## 作者：ysner (赞：1)

此题应该是一道略有思维难度的题，涉及到数学逻辑思维的运用，对矩形的构造需要一定的想象能力。

要点：

1、枚举两个点，把他们作为矩形上两个相对的顶点，构建矩形；

2、特判所有点在一条直线上的情况，此时输出点的个数；

3、在两个点外另找一个点，分作矩形边界点和矩形内部点两种情况，记下此时矩形边上点的个数、矩形内部点的个数、矩形内部加边上点的个数，最后比较出最大值即可。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
using namespace std;
struct dd
{
    int x,y;
}a[310];
int on[110],in[110],l[110],num[110],i,j,k,n,ans=0;
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)
        scanf("%d%d",&a[i].x,&a[i].y);
    int x1=1,y1=1;
    for(i=2;i<=n;i++)//进行特判，若所有点在同一直线上，则输出点的个数 
    {
        if(a[i].y!=a[1].y)
            y1=0;
        if(a[i].x!=a[1].x)
            x1=0;
    }
    if(x1||y1)//所有点横坐标或纵坐标全相同的情况 
    {
        cout<<n;
        return 0;
    }    
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(a[i].y>=a[j].y)//保证a[i].y<a[j].y，将a[i]和a[j]两点作为矩形两个相对的顶点，构造矩形 
                continue;
            else
            {
                memset(num,0,sizeof(num));//矩形边上点的个数 
                memset(on,0,sizeof(on));//矩形中间点的个数 
                memset(in,0,sizeof(in));//矩形中间加边上点的个数 
                for(k=1;k<=n;k++)
                {
                    if(a[k].y==a[i].y||a[k].y==a[j].y)//若a[k]在矩形边上 
                    {
                        num[a[k].x]++;
                        in[a[k].x]++;
                    }
                    if(a[k].y>a[i].y&&a[k].y<a[j].y)//a[k].y在a[i].y与a[j].y之间时 
                    {
                        on[a[k].x]++;
                        in[a[k].x]++;
                    }
                }
                l[1]=0;
                for(k=2;k<=100;k++)
                    l[k]=l[k-1]+num[k-1];//当a[k]作为边上点时矩形内点的个数 
                int max0=on[1]-l[1];
                for(k=2;k<=100;k++)//当a[k]作为矩形中间点时矩形内点的个数 
                {
                    ans=max(in[k]+l[k]+max0,ans);
                    max0=max(max0,on[k]-l[k]);//矩形缩小 
                }        
            }
        cout<<ans;
        return 0;
}
```

---

## 作者：夏色祭 (赞：1)

##难度假的吧，最多普及/提高-

##没有P的，我来补一发

其实坐标的值并不大，只有100，那么我们直接暴力这个矩形的左上角和右下角就行了。

再用一个前缀和优化，时间复杂度O(n^4)。

是在不知道难度为什么会是NOI-。。。~~有人刷的吧。。。~~

丑陋的代码：

```cpp
var
  prex,prey,pre:array[0..101,0..101]of longint;
  n,x,y,i,j,ans,sum:longint;
begin
  readln(n);
  for i:=1 to n do 
    begin
      readln(y,x);
      inc(pre[x,y]);
    end;
  for i:=1 to 100 do 
    for j:=1 to 100 do
      begin
        prex[i,j]:=prex[i-1,j]+pre[i,j];
        prey[i,j]:=prey[i,j-1]+pre[i,j];
      end;//前缀和
  for i:=1 to 100 do 
    for j:=i+1 to 100 do
      for x:=1 to 100 do
        for y:=x+1 to 100 do 
          begin
            sum:=(prex[j-1,x]-prex[i,x])+(prex[j-1,y]-prex[i,y])+(prey[i,y-1]-prey[i,x])+(prey[j,y-1]-prey[j,x])+pre[i,x]+pre[i,y]+pre[j,x]+pre[j,y];
            if ans<sum then ans:=sum;
          end;//暴力
  writeln(ans);
end.
```

---

## 作者：AntiO2 (赞：0)

很EZ的一道题，两个前缀和数组加四重循环枚举边界就能过。

复杂度很稳定，开了$O2$跑$60ms$.

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int x,y;
int shu[105][105],heng[105][105],mmp[105][105];
int mx,my,cnt;
int ans;
int main() {
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>x>>y;
		mmp[x][y] = 1;
	}
	for(register int i=1;i<=100;i++) {
		for(register int j=1;j<=100;j++) {
			shu[i][j] = shu[i-1][j] + mmp[i][j];
			heng[i][j] = heng[i][j-1] + mmp[i][j];
		}
	}
	for(int i=1;i<=100;i++) {
		for(int j=i+1;j<=100;j++) {
			for(int k = 1;k<=100;k++) {
				for(int l = k+1 ; l<=100;l++) {
					cnt =(shu[j][k]-shu[i-1][k]+shu[j][l]-shu[i-1][l]+heng[i][l]-heng[i][k-1]+heng[j][l]-heng[j][k-1]);
					if(mmp[i][k]) cnt--;
					if(mmp[i][l]) cnt--;
					if(mmp[j][k]) cnt--;
					if(mmp[j][l]) cnt--;
					ans = max(ans,cnt);
				}
			}
		}
	}
	cout<<ans<<endl;
}
```


---


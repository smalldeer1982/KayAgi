# 序列

## 题目描述

有一个整数序列，它的每个数各不相同，我们不知道它的长度是多少（即整数个数），但我们知道在某些区间中间至少有多少个整数，用区间（$L_i,R_i,C_i$）来描述，表示这个整数序列中至少有 $C_i$ 个数来自区间 $[L_i,R_i]$，给出若干个这样的区间，问这个整数序列的长度最少能为多少？

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le N \le 1000$，$0 \le L_i \le R_i \le 1000$，$1 \le C_i \le R_i-L_i+1$。

## 样例 #1

### 输入

```
4
4 5 1
6 10 3
7 10 3
5 6 1```

### 输出

```
4```

# 题解

## 作者：shadowcat (赞：37)

本题与P1986 元旦晚会 相类似，大意是选择一些数，满足在
[Li,Ri]中至少有Ci个数。我们可以将所有的区间按右端点的大小，从小到大排列。如果当前区间已经满足了它的要求，那么它其中的数的位置可以随意摆放，又因为它之后的区间的右端点的值比当前区间右端点大，所以我们贪心地选择当前区间最右端的数，可以尽量满足后面区间的条件。

代码如下：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,vis[30005],ans;
struct node
{
    int l,r,c;
}a[30005];
int cmp(node a,node b)
{
    return a.r<b.r;
}
int main()
{
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a[i].l,&a[i].r,&a[i].c);
    }
    sort(a+1,a+1+m,cmp);
    for(int i=1;i<=m;i++)
    {
        int cnt=0;
        for(int j=a[i].l;j<=a[i].r;j++)
	{
	    if(vis[j])
	    cnt++;
	}
	if(cnt<a[i].c)
	{
	    for(int j=a[i].r;j>=a[i].l;j--)
	    {
	        if(!vis[j])
		{
		    cnt++;
		    ans++;
		    vis[j]=1;
		    if(cnt==a[i].c)
		    break;
		}
	    }
	}
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：巨型方块 (赞：10)

http://blog.csdn.net/largecub233/article/details/73995862

我的博客^\_^


基本上就是差分约束spfa的模版题；

我们搞一个a[]

如果序列里有i那么a[i]=1;

s[i]就是a[i]的前缀和；

那么
s[i]-s[i-1]>=0

s[i-1]-s[i]>=-1

对于读入的x,y,z；

s[y]-s[x-1]>=z

所以我们把i到i-1连-1的边

i-1到i连0的边

x-1到y连z的边

在跑一边spfa求0-max（y）的最长路就好了；

至于原因，大家可以模拟一下，很显然的一个构造

~~我不会证明~~


```cpp
#include<bits/stdc++.h>
#define Ll unsigned long long
using namespace std;
const int N=100050;
struct cs{int to,nxt,v;}a[N*2];
int head[N],ll,d[N];
bool in[N];
int n,m,x,y,z;
void init(int x,int y,int z){
    a[++ll].to=y;
    a[ll].v=z;
    a[ll].nxt=head[x];
    head[x]=ll;
}
void spfa(int S,int E){
    queue<int>Q;
    memset(d,-63,sizeof d);
    d[S]=0;Q.push(S);
    while(!Q.empty()){
        int x=Q.front();Q.pop();in[x]=0;
        for(int k=head[x];k;k=a[k].nxt)
            if(d[a[k].to]<d[x]+a[k].v){
                d[a[k].to]=d[x]+a[k].v;
                if(!in[a[k].to])in[a[k].to]=1,Q.push(a[k].to);
            }
    }
    printf("%d",d[n]);
}
int main()
{
    scanf("%d",&m);
    while(m--){
        scanf("%d%d%d",&x,&y,&z);
        init(x-1,y,z);
        n=max(y,n);
    }
    for(int i=1;i<=n;i++){
        init(i-1,i,0);
        init(i,i-1,-1);
    }
    spfa(0,n);
}
```


---

## 作者：wanggk (赞：8)

[P1645 题目](https://www.luogu.com.cn/problem/P1645)

#### 1. 用**结构体**存储三个量：
```cpp
struct sequence{
   int l,r,c;
}a[100000];
```

#### 2. 给的是区间，所以按**右端点** **从小到大**排序；
```cpp
int cmp(sequence x,sequence y)
{
    return x.r<y.r;
}
```
#### 3.然后就需要一个数组，记录此位置有没有数，	以及等会儿填数时会用到。
```cpp
int f[100000];//f[i]=1就代表i这个位置有数（其实bool类型也可以）
```
#### 4.然后从1到n,每一段区间去填数。核心代码如下：
```cpp
for(int i=1;i<=n;i++)
{
     int now=0;//代表现在区间内已经有now个数了（我们的目标就是要使now达到a[i].c）。
     for(int j=a[i].l;j<=a[i].r;j++)//这个for循环在统计之前已有数的个数。
	 if(f[j]) now++;
     for(int j=a[i].r; j>=a[i].l&&now<a[i].c ;j--)//从右往左找，找到now==a[i].c为止。（注意看for中的第二部分循环条件）
        if(!f[j])//如果还没有数填过
        {
             f[j]=1;//填上
             now++;  ans++;//ans为最终答案
        }
 }
```
#### 5.完整代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
struct sequence{
    int l,r,c;
}a[100000];
int cmp(sequence x,sequence y)
{
    return x.r<y.r;
}
int n,ans;
int f[100000];
int main()
{
    memset(f,0,sizeof(f));
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].l>>a[i].r>>a[i].c;
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++)
    {
        int now=0;
        for(int j=a[i].l;j<=a[i].r;j++)
              if(f[j]) now++;
        for(int j=a[i].r; j>=a[i].l&&now<a[i].c ;j--)
             if(!f[j])
             {
                f[j]=1;
                now++;  ans++;
             }
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：Chupeiz (赞：8)

[【题目戳这里】](https://www.luogu.org/problemnew/show/P1645)

这道题用到差分约束系统，想借这道题温习下差分

**定义**：
差分约束系统是一种特殊的$N$元一次不等式组，它包含$N$个变量$X_1$~$X_n$以及$M$个约束条件，每个约束条件都由两个变量作差构成，形如$X_i-X_j<=C_k$，其中$C_k$是常数（可以是负数也可是非负数）,$1\le$i,j$\le$N,1$\le$k$\le$M。我们需要解决的问题是：求一组解$X_1=a_1,X_2=a_2,……,X_N=a_N$使所有约束条件得到满足。

**如何找到这样一组解？**

看到$X_i-X_j<=C_k$这样一个式子，我们会不会想到单源最短路中的“三角形不等式”:$dis[y]\le dis[x]+z$?可以把每一个变量当成一个点，而约束条件$X_i-X_j\le C_k$想象成一条从结点$i$连向结点$j$的边。那么起点到i号点的最小路径就是$x$的最小值。

举个栗子：

```cpp
例如:
x1-x0<=1
x2-x0<=2
x3-x0<=4
x2-x1<=3
x3-x2<=1
```

我们可以画一个示意图：（红色标注边的权值）
![这是一张用Windows自带画图画的很好看的图片【划掉】](https://cdn.luogu.com.cn/upload/pic/38711.png)

基于该图跑一个最短路，可以得到$d_0=0,d_1=1,d_2=2,d_3=3$

**关于此题**

本题正是差分约束系统的简单应用。

分析题干，要从数据范围0~50000中选出尽量少的整数，使每一个给定区间$[a_i,b_i]$中都至少有$ci$个数被选。

采用前缀和的思想，定义$s[i]$为0~k之间最少选出多少整数。就能由题意列出不等式：$s[b_i]-s[a_i-1]\ge c_i$

我们可以从这个式子意识到本题需用差分约束系统，但仅有它显然是不够的。因此从题目中，我们还可以得到一些隐含条件：

1. 由于所选数字的个数是非负的，故长度为$1$的区间值必须非负：$s[k]-s[k-1]\ge 0$
2. 同一个数不可重复选择，而长度为1的区间内最多存在$1$个数，所以长度为1的区间内选出的整数数量至多为$1$：$s[k]-s[k-1]\le 1$

	变形为：$s[k-1]-s[k]\ge -1$
    
这样我们就得到了一个“形如$X_i-X_j<=C_k$（$C_k$为常数）”的式子。然后我们就可以非常愉快地~~套路~~了——把$s[k-1]$和$s[k]$看成结点，从k-1到k连长度为-1的有向边。

前两个式子也是一样的：从每个$a_i-1$到每个$bi$连长度为$ci$的有向边，从每个$k-1$到$k$连成长度为$0$的有向边。

最后只需要让s[-1]=0，从-1开始求单源最长路（同大取大，跑最长路），引用@陈曦ioa的理解“差分约束系统是利用题面中给出的约束条件，和题干中隐藏的约束条件建图，之后求解最短（长）路的过程，在建图的过程中要先关注具体问题，若求的是两个变量差的最大值，那么将所有不等式转变成"<="的形式并且在建图后求最短路，反之在转换成">="的形式，并且求最长路”

[传送门~](https://www.luogu.org/blog/Chen-Xi/solution-uva1723)

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<stack>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
#define iNF 0x3f3f3f3f
#define N 10017
#define M 10017
int n,m,k;
int Edgehead[N],dis[N];
struct Edge
{
    int v,w,nex;
}Edge[3*M];
bool vis[N];
int minn,maxx;
int MIN(int a,int b)
{
    if(a<b) return a;
    return b;
}
int MAX(int a,int b)
{
    if(a>b) return a;
    return b;
}
void Addedge(int u,int v,int w)
{
    Edge[k].nex=Edgehead[u];
    Edge[k].w=w;
    Edge[k].v=v;
    Edgehead[u]=k++;
}
int SPFA(int start)
{
    queue<int>q;
    int top;
    for(int i=minn;i<=maxx;i++)
        dis[i]=-iNF;
    dis[start]=0;
    memset(vis,false,sizeof(vis));
    q.push(start);
    vis[start]=true;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=false;
        for(int i=Edgehead[u];i!=-1;i=Edge[i].nex)
        {
            int v=Edge[i].v;
            int w=Edge[i].w;
            if(dis[v]<dis[u]+w)
            {
                dis[v]=dis[u]+w;
                if(!vis[v])
                {
                    q.push(v);
                    vis[v]=true;
                }
            }
        }
    }
    return dis[maxx];
}
int main()
{
    int u,v,w,t;
    scanf("%d",&n);
    k=1;
    memset(Edgehead,-1,sizeof(Edgehead));
    memset(Edge,0,sizeof(Edge));
    minn=iNF;
    maxx=-1;
    for(int i=1;i<=n;i++)
    {   
        scanf("%d%d%d",&u,&v,&w);
        Addedge(u-1,v,w);
        maxx=MAX(v,maxx);
        minn=MIN(u-1,minn);
    }   
    for(int i=minn;i<=maxx;i++)
    {
   	    Addedge(i,i+1,0);
        Addedge(i+1,i,-1);
    }
    int ans=SPFA(minn);
	printf("%d\n",ans);
return 0;
}
```



---

## 作者：MSqwq (赞：7)

**这题和P1250种树相似**  
大概题意就是给你一些区间的约束，然后求最小的元素个数  
一看到这个题就想到可以用查分约束来做，因为看到很多大佬都是用**查分约束**做的所以我在这里介绍用**贪心**做  
首先贪心嘛，一定就要有贪心策略噻，所以我们来枚举一下  
简单把样例的图画出来!
```
1   2   3   4   5   6   7   8   9   10
	        |-1-|
		            |---------3---------|
		               |-------3-------|
		         |-1-|
```
然后观察一下发现啥都不能看出来，因为太乱了，所以我们排序呗，排序就不乱了，我是按右端点排序的（左右都可以呀）排完序后就是下面这样啦
```
1   2   3   4   5   6   7   8   9   10
	        |-1-|
		        |-1-|		 
 		            |---------3---------|
		               |-------3-------|

``` 
这样就很直观了，我们就可以发现相邻两个线段有些公共的地方，我们就可以尽量在这些地方放元素，保证元素的总个数最少，这就是贪心策略啦  
所以我们每次枚举的时候就可以从每个区间的后面开始往这个区间前面开始枚举，如果这个地方可以放元素并且这个区间的元素个数还没有到达上限就放在这里呀 

举个例子  
```
3   4   5   6
    |-1-|
        |-1-|
```


这样我们在枚举上一条边的时候先看这区间已经有多少个元素了，如果已经满足这个区间就不用再看啦     
如果没有满足那么就从后往前看，5个地方有没有元素，5没有元素所以放在这里这个区间的元素个数就加一，再看看发现已经达到这个区间的上限啦，所以开始枚举下面的这个区间  
先从5到6扫一遍看看有多少个元素了，发现5已经有一个了就加一，最后整个区间看完后在对比这个区间的元素上限，发现已经大于等于了就不用再考虑了  

很简单吧，接下来是代码
```
#include<bits/stdc++.h>
using namespace std;

struct node{
	int from,to,s;//from表示这个区间的前段点所在位置，to表示这个区间的后断点的位置，s是区间元素的上限 
}a[20000];
bool cmp(node x,node y)
{
	return x.to<y.to;//按右端点开始排序 
}
int sum=0,n,v[20000];//sum表示所选元素总数，也就是答案，v数组记录这个位置放没放元素 
int main()
{
	cin>>n;//读入 
	for(int i=1;i<=n;i++)cin>>a[i].from>>a[i].to>>a[i].s;//读入 
	sort(a+1,a+1+n,cmp);//简简单单排个序 
	for(int i=1;i<=n;i++)
	{
		int ans=0;//临时记录这个区间现在有多少个元素了 
		for(int j=a[i].from;j<=a[i].to;j++)if(v[j])ans++;//先全部扫一遍这个区间有多少个元素了 
		if(ans>=a[i].s)continue;//如果已经满足这个区间的约束，那么就不用再加了，开始看下一个区间 
		for(int j=a[i].to;j>=a[i].from;j--)//从右往左扫 
		{
			if(!v[j])//如果这个地方没有放，就放在这里 
			{
				ans++;//总个数加一 
				sum++;//当前区间的元素个数加一 
				v[j]=1;//有元素了，改变状态 
				if(ans==a[i].s)break;//每次加的时候都判断的时候就判断一下达到上限没有 
			}
		}
	}
	cout<<sum;//输出答案 
} 
```


---

## 作者：顾z (赞：7)



"~~序列是不连续的~~"

“~~你们应该知道~~”

思想：sort排序：以左端点为第一关键字排序，右端点为第二关键字排序。

区间覆盖问题

做法：

     每次选取左端点最大的进行贪心。
     枚举这一段区间时，从左到右选取
     尽可能靠左的整数点。
     这时候要判断是否被标记过。
     如果被标记过，该区间中的C（同题目）--。
     再次遍历这段区间，要判断此时的C是否<=0.
     如果<=0则要break；
     如果存在C，则继续标记较靠左的整数点。

CODE如下： ~~貌似可以改一下 大佬手轻点~~

~~蒟蒻第一篇题解~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<map>
#include<queue>
#include<vector>
#define ll long long
#define ull unsigned long long
#define inf 2147483647
using namespace std;
int N,L,R,C,minl=9999,maxr,ans;bool NOW[20000];
struct code{
	int l,r,c;
}op[20000];
bool read(int &x){
	int f=1;x=0;char s=getchar();
	while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
	while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
void print(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)	print(x/10);
	putchar(x%10+'0');
}
bool ccp(const code &a,const code &b)
{
	if(a.l!=b.l)return a.l<b.l;
	else return a.r>b.r;
}
int main()
{
	read(N);
	for(int i=1;i<=N;i++)
	{
		read(op[i].l),read(op[i].r),read(op[i].c); 
		minl=min(minl,op[i].l),maxr=max(op[i].r,maxr);
    }
    sort(op+1,op+N+1,ccp);
    for(int i=N;i>=1;--i)
    {
    	int couldget=op[i].c;
    	for(int k=op[i].l;k<=op[i].r;k++)if(NOW[k])couldget--;
    	for(int j=op[i].l;j<=op[i].c+op[i].l &&j<=op[i].r;j++)
		{
		  if(couldget<=0)break;
		  else if(!NOW[j]){
			   couldget--;
			   NOW[j]=1;
		    }	
	    }
    }
    for(int i=minl;i<=maxr;i++)
    	if(NOW[i])ans++;
    print(ans);
}
```

---

## 作者：lakafl (赞：3)

## 思路：

首先拿到这一道题，一看数据范围，$n<=1000$，就可以知道$n^2$可以，那么先**sort**排序，按$l$从大到小排，在之后的循环中每次先选左边的，因为选左边一定比右边好（按$l$从大到小排）如果右边可以左边一定也可以，不过在这之前，要先**记录之前已经添加数字，找出本次要填加的个数**，避免重复


## CODE

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

struct lx {
	int l, r, c;
}a[1005];

bool cmp(lx x, lx y) { 
	return x.l > y.l;
} 

bool flag[1005];

int main() {
	int n, ans = 0;
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++) {
		scanf("%d %d %d", &a[i].l, &a[i].r, &a[i].c);
	} sort(a + 1, a + 1 + n, cmp);
	for(int i = 1; i <= n; i ++) {
		int tot = 0;
		for(int j = a[i].l; j <= a[i].r; j ++) {
			if(flag[j]) tot ++; 
		} int val = a[i].c - tot;
		for(int j = a[i].l; j <= a[i].r; j ++) {
			if(val <= 0) break;
			if(!flag[j]) {
				ans ++;
				val --; flag[j] = 1;
			} 
		}
	} printf("%d", ans);
}
```

**END**


---

## 作者：23forever (赞：3)

裸的差分约束系统。

将L-R+1>=C 转化成add(l,r+1,c)即可

注意两两数之间也有不等式。

因为差分约束有负权，所以只能跑SPFA


AC代码：







    
    
    
        

    
    
    
        
    
    
    
    
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
#define max(a,b) (a<b ?b:a)
#define min(a,b) (a<b ?a:b)
const int MAXN=0x3f3f3f3f;
using namespace std;
int head[50001],tot;
struct node{
    int to,w,next;
}edge[50001];
void add_edge(int u,int v,int w){
    edge[++tot]=(node){v,w,head[u]};
    head[u]=tot;
}
queue<int>Q;
int dist[1001];
bool inque[1001];
void SPFA(int s)
{
    memset(dist,-0x3f,sizeof(dist));
    dist[s]=0;
    Q.push(s);inque[s]=true;
    while(!Q.empty()) {
        int u=Q.front();Q.pop();
        inque[u]=false;
        for(int e=head[u];e;e=edge[e].next) {
            int v=edge[e].to,w=edge[e].w;
            if(dist[u]+w>dist[v]) {
                dist[v]=dist[u]+w;
                if(!inque[v]) Q.push(v);
            }
        }
    }
}
int main(){
    int n,l,r,s,L=MAXN,R=-MAXN;
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>l>>r>>s;r++;
        L=min(L,l),R=max(r,R);
        add_edge(l,r,s);
    }
    for (int i=L+1;i<=R;i++)
        add_edge(i-1,i,0),add_edge(i,i-1,-1);
    SPFA(L);
    cout<<dist[R]<<endl;
    return 0;
}
```

---

## 作者：qfpjm (赞：2)

# 说在前面
做出了[P1250种树](https://www.luogu.com.cn/problem/P1250)，直接拿去提交[P1986元旦晚会](https://www.luogu.com.cn/problem/P1986)，去掉 $n$ 之后再拿来提交这题，做出一道题可以白捡两道题!

------------

# 题意

选择一些数，满足在某个区间内至少有 $Ci$ 个数。

# 分析

- 大家很容易想到，每个区间都安排 $Ci$ 个数，但这样不一定是最少的。

- 原因是一个数能同时出现在多个区间，本来有两个有两个数的区间，总共需要四个数，然而，如果有一个数重复了，就只会有三个数:

![](https://cdn.luogu.com.cn/upload/image_hosting/w4eehvqp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

- 所以，我们需要考虑这种区间重叠的情况，在重叠部分安排数，这样就可以使得数最少。

# 题解

1. 首先，我们对区间的末尾进行排序，确定区间位置（从样例可以得知，输入的区间是无序的）。

1. 然后，我们要统计这个区间已有的数（用一个 $bool$ 类型的数组来标记安排数的地方），判断是否满足这个区间所需的数：满足，则跳至下一个区间；不满足，则继续安排数的人。

1. 如果不满足，从后往前找到未有数的位置（后面的位置越容易与另一个区间重合），让其持话筒。每安排下一个数，最终结果加一，这个区间的数加一，直至本区间的数满足要求。

1. 输出最终结果。

# 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

struct houseperson
{
	int start, end, tree;	
}a[5000001];

int h;
long long ans;
bool used[500001] = {0};

int cmp(houseperson a, houseperson b) 
{
	return a.end < b.end;
}

int main()
{
	cin >> h;
	for (int i = 1;i <= h;i ++)
	{
		cin >> a[i].start >> a[i].end >> a[i].tree;
	}
	sort(a + 1, a + 1 + h, cmp);
	for (int i = 1;i <= h;i ++)
	{
		int m = 0;
		for (int j = a[i].start;j <= a[i].end;j ++)
		{
			if (used[j] == true)
			{
				m ++;
			}
		}
		if (m >= a[i].tree)
		{
			continue;
		}
		for (int j = a[i].end;j >= a[i].start;j --)
		{
			if (used[j] == false)
			{
				m ++;
				ans ++;
				used[j] = true; 
				if (m == a[i].tree)
				{
					break;
				}
			}
		}
	}
	cout << ans;
	return 0;
}

```


---

## 作者：Lolierl (赞：2)

此题很明显可以用[color=yellow]贪心[/color]。首先根据区间[color=red]末尾[/color]排序，然后，从第一个区间往后推，尽量把整数安排在区间的[color=red]右边[/color]，因为这样可以使区间之间重复数据量最大（下一组要把重复的数据量减掉），重复数据一旦大了，所需的整数就少了。（如有问题请私信我）


---

## 作者：CLCK (赞：1)

基础贪心问题，思路不太好想：
从右往左排序后依次覆盖，若按照右边界从小到大排序就从右往左覆盖，以达到最佳解法，左侧关键字同。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
bool sz[1005];
int n;
struct lrc {
    int l, r;
    int c;
} a[1005];
bool cmp(lrc a, lrc b) { //自定义比较函数
    return a.r < b.r;
}
int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i].l >> a[i].r >> a[i].c;
    }
    sort(a, a + n, cmp); //排序
    for (int i = 0; i < n; i++) {
        int cc = a[i].c;
        for (int j = a[i].r; j >= a[i].l; j--) { //区间处理
            if (sz[j]) cc--;
        }
        if (cc <= 0) continue;
        for (int j = a[i].r; j >= a[i].l; j--) { //覆盖部分
            if (cc == 0) break;
            if (!sz[j]) {
                sz[j] = true;
                cc--;
            }
        }
    }
    int ans = 0;
    for (int i = 0; i < 1005; i++) { //统计答案
        if (sz[i]){
            ans++;
        }
    }
    cout << ans << endl;
    return 0;
}
```


---

## 作者：fengtube (赞：1)

本题可以通过求区间的交集来做。

通常按右区间为关键字排序，取数时从右边取，这样可以保证重叠数最大。





```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int Maxn = 1e+3 +5;
int n ,cnt ,ans;
bool mark[1000];
inline void read(int &x)
{
    x = 0;
    char c = getchar();
    while(c<'0' || c>'9')
    {c = getchar();}
    while(isdigit(c))
    {
        x = (x<<3) + (x<<1) + c - '0';
        c = getchar();
    }
    return ;
}
struct section
{
    int u,v,c;
}s[Maxn];
bool cmp(section x,section y)
{
    return x.v < y.v; 
}
int main()
{
    read(n);
    for(int i=1; i<=n; i++)
    {
        read(s[i].u);
        read(s[i].v);
        read(s[i].c);
    }
    sort(s+1 ,s+n+1, cmp);
    for(int i=1; i<=n; i++)
    {
        cnt = 0;
        for(int j=s[i].u; j<=s[i].v; j++)
            if(mark[j])
                ++cnt;
        for(int j=s[i].v; j>=s[i].u; j--)
            if(cnt < s[i].c)
            {
                if(!mark[j])
                {
                    ++cnt;
                    ++ans;
                    mark[j] = true;
                }
            }
    }
    printf("%d" ,ans);
}
```

---

## 作者：FourteenObsidian (赞：1)

这道题数据这么小，就是简单的贪心啊，为什么要把差分约束搬过来……

要用差分约束的是[这一题](https://www.luogu.com.cn/problem/SP116)。

容易想到对于每个区间按右端点排序，再依次扫描每个区间，每次将还要选的点尽量放在右边就行了。因为对于一个区间，选右边的点对后面区间能少选点数的贡献肯定不比选左边的小。时间复杂度 $O(n^2)$，对于这样的小数据随便过。

当然，也可以用线段树区间求和与区间覆盖，先求出当前区间还要覆盖多少个点，再二分应覆盖的区间长度，做到 $O(nlog^2n)$ 的复杂度。

$O(n^2)$ 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e3 + 10;
int n, ans;
bool vis[N];
struct In
{
	int l, r, c;
}in[N];
bool cmp(In x, In y)
{
	return x.r < y.r;
}
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i)
		scanf("%d%d%d", &in[i].l, &in[i].r, &in[i].c);
	sort(in + 1, in + n + 1, cmp);//排序
	for(int i = 1, num; i <= n; ++i)
	{
		num = in[i].c;
		for(int j = in[i].l; j <= in[i].r; ++j)
			if(vis[j]) --num;//暴力扫出还要覆盖的个数
		for(int j = in[i].r; j >= in[i].l && num > 0; --j)
			if(!vis[j])
			{
                ++ans;
				vis[j] = 1;
				--num;
			}//暴力覆盖，累加答案
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：JiaY19 (赞：0)

一道比较水的蓝题。

和[这一题](https://www.luogu.com.cn/problem/P1986)是双倍经验。

#### 思路

看到最小，考虑贪心。

因为他需要的是在这个取值范围内选至少 $c$ 个数。

我们考虑首先按右端点排序。

可以确定：

能选，就要尽量选右边的。

因为此时，每一个右边的区间的右端点都比现在的右端点大。

所以，尽可能的选择右边，才能是一个数字被多个区间重复覆盖。

才能是所要选的数尽量少。

发现每个数字不能相同，可以用一个桶记录这个数有没有被选。

#### 实现

一个双重循环，第二重循环两次，第一次判断此时该区间选了几个，第二次为选数。

时间复杂度： $O(n^2)$。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n , ans , vis[1010];

struct edge
{
    int l , r , c;
    bool operator<(const edge &tmp) const
    {
        return (r == tmp.r) ? l < tmp.l : r < tmp.r;
    }
}e[1010];

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

int main()
{
    n = read();
    for(int i = 1;i <= n;i++)
        e[i].l = read() , e[i].r = read() , e[i].c = read();
    sort(e + 1 , e + n + 1);
    for(int i = 1;i <= n;i++)
    {
        int sum = 0;
        for(int j = e[i].l;j <= e[i].r;j++)
            if(vis[j]) sum++;
        for(int j = e[i].r;j >= e[i].l && sum < e[i].c;j--)
            if(!vis[j]) vis[j] = 1 , sum++ , ans++;
        // cout << e[i].l << " " << e[i].r << " " << e[i].c << " " << ans << endl;
    }
    cout << ans << endl;
    return 0;
}


```

---

## 作者：jins3599 (赞：0)

区间覆盖模板。

## 模型

给定若干个区间，每个区间上要求放若干个点，要求总共的点数最小。

## 思路

我们按照右端点升序排序，然后每次贪心的把能放的向后放就可以了。

这样可以为后面的区间贡献答案，保证答案更优而不会更劣。

然后就A了，您就成功了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1000 + 10;

struct Node {
	int l , r , w;
	bool operator < (const Node &a) const {
		return r < a.r;
	}
}a[N];

bool vis[N];

int main () {
	int n;
	cin >> n;
	for(int i = 1 ; i <= n ; ++ i) {
		cin >> a[i].l >> a[i].r >> a[i].w;
	}
	sort(a + 1 , a + 1 + n);
//	for(int i = 1 ; i <= n ; ++ i) printf("%d %d\n" , a[i].l , a[i].r);
	a[0].r = a[0].l = -1;
	a[0].w = 0;
	int ans = 0;
	for(int i = 1 ; i <= n ; ++ i) {
		int cnt = 0;
		for(int j = a[i].l ; j <= a[i].r ; j ++) if(vis[j]) cnt ++;
		
		if(cnt >= a[i].w) continue;
		
		for(int j = a[i].r ; j >= a[i].l ; j --) {
			if(!vis[j]) vis[j] = 1 , cnt ++ , ans ++;
			if(cnt >= a[i].w) break;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：ljc20020730 (赞：0)

贪心!

1.区间已经种过了无需栽种

2.，尽量把整数安排在区间的右边，因为这样可以使区间之间重复数据量最大（下一组要把重复的数据量减掉），重复数据一旦大了，所需的整数就少了。

3.对于这种类问题常见都是按照右区间排序（或主关键字），不能按左区间排序

```cpp
type rec=record
l,r,num:longint;
end;
var i,j,k,ans,n:longint;
    f:array[0..30000]of boolean;
    a:array[0..30000]of rec;
procedure swap(var a,b:rec);
var t:rec;
begin
 t:=a; a:=b; b:=t;
end;
procedure qsort(l,r:longint);
var i,j:longint;
    mid:rec;
begin
 i:=l; j:=r; mid:=a[(l+r)>>1];
 repeat
  while (a[i].r<mid.r)or((a[i].r=mid.r)and(a[i].l<mid.l)) do inc(i);
  while (a[j].r>mid.r)or((a[j].r=mid.r)and(a[j].l>mid.l)) do dec(j);
  if i<=j then begin
   swap(a[i],a[j]);
   inc(i); dec(j);
  end;
 until i>=j;
 if l<j then qsort(l,j);
 if i<r then qsort(i,r);
end;
begin
 readln(n);
 for i:=1 to n do readln(a[i].l,a[i].r,a[i].num);
 qsort(1,n);
 fillchar(f,sizeof(f),false);
 ans:=0;
 for i:=1 to n do begin
  for j:=a[i].l to a[i].r do
   if f[j] then  dec(a[i].num);
  k:=a[i].r;
  for j:=1 to a[i].num do begin
   while f[k] do dec(k);
   f[k]:=true;
   inc(ans);
  end;
 end;
 writeln(ans);
end.
```

---

## 作者：zeppeo (赞：0)

【算法1】

搜索，期望得分0~30。

    
【算法2】

DP，枚举最终至少有k个相同的数字x，定义F[i][j]表示前i个数字有j个数字等于x的最小代价，同时定义一个G[i][j]表示满足F[i][j]的情况下字典序最小的字符串。

期望得分70分。


【算法3】

贪心，同样枚举数字x，先取修改代价小的数字修改，若修改代价相同，考虑到要最小化字典序，所以应优先修改比x大的数字，因为这样修改后会导致字典序变小，所以应从前往后修改，这样可以最大化字典序的变小。再修改比x小的数字，因为修改后字典序会变大，所以应从后往前修改，最小化字典序的变大。最后再比较不同的x得到的答案，得到最优解。














```cpp
program wz;
var
pre,next,c:array[0..10000]of longint;
ans,i,j,k,n,min,max:longint;
p:array[0..10000]of boolean;
 procedure sort(x,y:longint);
 var
 i,j,mid,t:longint;
 begin
 i:=x;
 j:=y;
 mid:=next[(x+y) div 2];
 repeat
 while next[i]<mid do inc(i);
 while next[j]>mid do dec(j);
 if i<=j then
 begin
 t:=next[i];next[i]:=next[j];next[j]:=t;
 t:=pre[i];pre[i]:=pre[j];pre[j]:=t;
 t:=c[i];c[i]:=c[j];c[j]:=t;
 inc(i);dec(j);
 end;
 until i>j;
 if i<y then sort(i,y);
 if j>x then sort(x,j);
 end;
begin
assign(input,'sequence.in');
assign(output,'sequence.out');
reset(input);
rewrite(output);
min:=maxlongint;
fillchar(p,sizeof(p),false);
readln(n);
for i:=1 to n do
readln(pre[i],next[i],c[i]);
sort(1,n);
for i:=1 to n do
begin
  for k:=pre[i] to next[i] do
  if (p[k]=true) then dec(c[i]);
  if c[i]<0 then c[i]:=0;
  ans:=ans+c[i];
  j:=next[i];
  while c[i]<>0 do
  begin
  if p[j]=false then
  begin
  p[j]:=true;dec(c[i]);end;
  dec(j);
  end;
end;
writeln(ans);
close(input);
close(output);
end.
```

---


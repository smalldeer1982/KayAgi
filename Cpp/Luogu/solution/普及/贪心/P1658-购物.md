# 购物

## 题目描述

你就要去购物了，现在你手上有 $N$ 种不同面值的硬币，每种硬币有无限多个。为了方便购物，你希望带尽量少的硬币，但要能组合出 $1$ 到 $X$ 之间的任意值。


## 说明/提示

对于 $30\%$ 的数据，满足 $N \le 3$，$X \le 20$；

对于 $100\%$ 的数据，满足 $N \le 10$，$X \le 10^3$。

## 样例 #1

### 输入

```
20 4
1 2 5 10
```

### 输出

```
5
```

# 题解

## 作者：qwaszx (赞：45)

思路：贪心

将面值从小到大排序

考虑用前$i$种面值可以凑出的最大价值

显然当且仅当$a_1\neq 1$时是无解的，因为凑不出$1$

这样就限定了$a_1=1$

假设已经凑出了$1$~$s$的面值，那么我们可以加入一张面值不超过$s+1$的硬币

如果超过$s+1$，那么就不可以凑出$s+1$面值

设这个面值是$a$，那么可以把$s$延伸到$s+a$

显然这个面值越大越好

所以就直接找出$a\leq s+1$的最大的$a$,然后把$s$更新为$s+a$,同时$ans++$即可

版本1如下

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,x,a[2000],ans;
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	x=getin(),n=getin();
	for(int i=1;i<=n;i++)a[i]=getin();
	sort(a+1,a+n+1);
	if(a[1]!=1){cout<<-1;return 0;}
	int sum=0;
	while(sum<x)
	{
		int i;
		for(i=n;i>=1;i--)if(a[i]<=sum+1)break;
		ans++,sum+=a[i];
	}
	cout<<ans<<endl;
}
```
复杂度$O(nm)$，但是实际上一般跑不到这个上界

这样的效率对于这道题已经绰绰有余了，但是我们还是要想办法优化

注意到$a_i$单调递增，所以可以用一个二分来找出最大值

复杂度$O(mlogn)$的版本2
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,x,a[2000],ans;
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int find(int x)
{
	int l=1,r=n,mid;
	while(l<r)
	{
		mid=(l+r+1)>>1;
		if(a[mid]<=x)l=mid;
		else r=mid-1;
	}
	return l;
}
int main()
{
	x=getin(),n=getin();
	for(int i=1;i<=n;i++)a[i]=getin();
	sort(a+1,a+n+1);
	if(a[1]!=1){cout<<-1;return 0;}
	int sum=0;
	while(sum<x)
	{
		int i=find(sum+1);
		ans++,sum+=a[i];
	}
	cout<<ans<<endl;
}
```
退回到版本1，注意到一个值可能会被重复累加，可不可以快速地找出累加次数呢？

显然是可以的

当$a_{i+1}\leq s+ka_i+1$时$a_i$就会被$a_{i+1}$代替

令$k$最小可以解出$k=\lceil\frac{a_{i+1}-s-1}{a_i}\rceil$

于是这样每次都可以使下标$i+1$，所以复杂度$O(n^2)$

和版本2结合可以得到一个复杂度$O(n\log n)$的做法

版本3
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,x,a[2000],ans;
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int find(int x)
{
	int l=1,r=n,mid;
	while(l<r)
	{
		mid=(l+r+1)>>1;
		if(a[mid]<=x)l=mid;
		else r=mid-1;
	}
	return l;
}
int main()
{
	x=getin(),n=getin();
	for(int i=1;i<=n;i++)a[i]=getin();
	a[n+1]=1e9;//注意这里要赋一个极大值避免出现问题
	sort(a+1,a+n+1);
	if(a[1]!=1){cout<<-1;return 0;}
	int sum=0;
	while(sum<x)
	{
		int i=find(sum+1);
		int k=ceil((double)(min(x,a[i+1])-sum-1)/a[i]);//要和s取min
		ans+=k,sum+=a[i]*k;
	}
	cout<<ans<<endl;
}
```
版本4其实已经不难想到了

我们每次选取的i都是递增的，那么直接记录上次选取的i，复杂度$O(n)$

版本4
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,x,a[2000],ans;
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	x=getin(),n=getin();
	for(int i=1;i<=n;i++)a[i]=getin();
	a[n+1]=1e9;
	sort(a+1,a+n+1);
	if(a[1]!=1){cout<<-1;return 0;}
	int sum=0,i=0;
	while(sum<x)
	{
		while(a[i+1]<=sum+1)i++;
		int k=ceil((double)(min(x,a[i+1])-sum-1)/a[i]);
		ans+=k,sum+=a[i]*k;
	}
	cout<<ans<<endl;
}
```
PS:可能正常人都是直接跳到版本4的只有我这种蒟蒻才会想这么多

---

## 作者：pengyule (赞：33)

这道题的解法可能比较单一吧，然后我看了一下下面的题解，有一些不是那么好懂，说的不是特别特别透，或许我举个例子更多人可以看懂。

**我们要明确以下几点：**

1. 如果我们的给定面值里没有1，那么肯定无解，为什么呢，首先我们就没有办法凑出1来。如果有1呢，只要我们舍得带很多硬币，肯定可以凑出任意面值。
1. 我们假设现在我们手中的面值已经可以凑出$1$~$H$中的所有面值，这个时候，我们要想一想，我们现在再准备带的这个硬币，应该满足什么样的条件呢？现在举一个例子。我们手里现在有面值和为5的硬币，并且可以凑出从$1$~$5$的所有面值。现在，
```cpp
如果我们选				则可以凑出
1						1,2,3,4,5,6
2						1,2,3,4,5,6,7
3						1,2,3,4,5,6,7,8
4						1,2,3,4,5,6,7,8,9
5						1,2,3,4,5,6,7,8,9,10
6						1,2,3,4,5,6,7,8,9,10,11
选一个解释：如果我们选4，那我们肯定可以凑出1~5（之前就可以凑出
来），对于6，我们可以用之前凑出来的2加上现在选的4，对于7，我们可以
用之前凑出来的3加上现在选的4，以此类推，但是10我们就不能凑出来了。
然后，如果我们选择7，同理可以凑出来1~5，然后6呢，我们选之前凑不出
来，用现在选的7加上“没有”、“1”、“2”、“3”、“4”、“5”都不
可能凑出来，因为7+0就已经大于6了，再加什么也不可能等于6。你也可以
再去自己算一下其他的例子，会发现，当且仅当我们选的数不大于当前选的
面值的和+1，我们可以保证凑出连续的面值（不要想去跳着凑面值，不可能
的）。
然后我们发现，我们选的数越大，他可以凑出来的面值就越多，我们就尽可
能的选给我们的面值里面，满足不大于面值和+1的最大面值，这样，我们带
去购物且满足可以凑出1~X中所有面值的硬币数会更少，答案就更小。
```
不知道大家听懂了没有呢？
我觉得讲的蛮清楚了，如有疑问可以在评论区留言，下面是代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[1005];
bool cmp(int p,int q){
    return p>q;
}//尽量选大的才能保证答案最小
int main()
{
    int X,n,ans=0,SUM=0;
    cin>>X>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1,cmp);
    if(a[n]!=1){//我们说过了，无解的情况
        cout<<-1<<endl;
        return 0;
    }
    while(SUM<X){//如果我们现在还不能凑出1~X的所有面值，那就要再选
        for(int i=1;i<=n;i++)
            if(a[i]<=SUM+1){
                SUM+=a[i];
                break;
            }
        ans++;//又选了一张
    }
    cout<<ans<<endl;
    return 0;
}
```
谢谢观看，希望可以通过。


---

## 作者：lswSunny (赞：32)

这是一个典型的贪心问题，每一次都要在找到比当前该凑数钱小的最大面值数，这样就可以在钱币数量相同的情况下可拼凑价值最大

贪心问题需要自己慢慢悟，不说多了，放~代~码



 
    
    
    
     

    

```cpp
//shopping
#include<iostream>  
#include<cstdio>  
#include<algorithm>  
using namespace std; 
const int Maxn=1005;  
int n,x,s[Maxn],ans; 
int main()
{  
    int i,j,sum;
    cin>>x>>n;  
    for(i=1;i<=n;i++)cin>>s[i]; 
    sort(s+1,s+1+n); //面值从小到大排序
    if(s[1]!=1)//肯定无解
    {cout<<-1<<endl;   return 0;}  
    sum=0;//sum已经可以凑的钱
    while(sum<x)
    {  
        for(i=n;i>=1;i--)   
            if(s[i]<=sum+1)break;//凑下一个,找可用最大面值的
        ans++;    //选面值s[i]的硬币
        sum+=s[i];//已经凑好的sum,中间间隔s[i]个凑法做过了
    }   
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Reanap (赞：4)

假设 ， 我们现在已经可以组合出0-m块钱的任意数值，如果我们加上一个小于等于m+1数值的硬币a[i]，那么对于之前可以凑出的任意数值我们都可以加上这枚硬币a[i],那么我们可以凑出的数值就变成了0-m+a[i]。

至于为什么是小于等于m+1，如果我们的新取硬币是大于m+1的，那么哪怕是加上最小的0，值也是大于m+1，所以我们能够凑出的连续区间仍然是1-m。

综上，因为加上一枚小于等于m+1的新硬币，那么在满足小于等于m+1这个条件的同时越大越好（因为区间会变成0-m+a[i]）。

正确性是显而易见的，因为我们做出的任意一个决策都是只会影响下一个的m，让m尽可能的大，m大会间接影响a[i]变大，而我们也希望让a[i]尽可能大，那么可以证明这个策略是正确。


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int a[15];
int main() {
	int x , n;
	scanf("%d %d" , &x , &n);
	for (int i = 1; i <= n; ++i) scanf("%d" , &a[i]);
	sort(a + 1 , a + 1 + n);//排序，方便我们选择最优决策
	int tot = 0 , ans = 0;//tot记录上述分析的m值，初始时我们只能凑出0-0的值，ans记录答案
	while(1) {
		if(tot >= x) {//如果我们能凑出的区间大于了目标区间，就返回
			printf("%d" , ans);
			return 0;
		}
		else ans ++;//否则继续贪心
		int f = 1;
		for (int i = n; i >= 1; --i) {//从大到小查询
			if(a[i] <= tot + 1) { // 如果满足条件，那么一定是最优的（因为从小到大找）
				tot += a[i];//更新区间
				f = 0;
				break;
			}
		}
		if(f) {//如果无法满足条件则不可能使tot值再增加
			printf("-1");
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：顾z (赞：4)

**题目描述**

你就要去购物了，现在你手上有N种不同面值的硬币，每种硬币有无限多个。为了方便购物，你希望带尽量少的硬币，但要能组合出1到X之间的任意值。

## 广告 [安利博客](https://87960.blog.luogu.org/#)

**分析：**

看到题解做法没有说出原理,所以尝试解释一下.

首先,没有1元面值的硬币肯定无解,因为无法组成1元面值,况且如果我们有1元面值的硬币,那我们就能凑出其他面值(话说带多少硬币去买东西?

然后,我们选择从面值为1元开始凑出所有面值的纸币

(这句话和代码有出入,但是原理相同。)

我们每次选择小于等于当前总面值+1的最大面值的硬币。

//记录**当前总面值为s**

//因为我们此时可以凑出的面值为1~s的钱,我们想要去凑出面值为s+1的情况,所以说我们需要寻找一张面值为s+1的,如果没有,我们的选择将会是最大面值的,再用它(这个面值大的),去和其他面值的拼凑出更大面值.


**概括来讲**
 
以这个大面值为底,和之前的小面值,是可以凑出更大的面值的钱的.

//可能有点混乱.

以样例为例↓

   	1 2 5 10
	now为当前面值,ans为选取的个数。
        now=0,ans=0//此时没有选取  
      需要寻找面值<=now+1的硬币.
        now=1,ans=1//此时选取面值为1的
      需要寻找面值<=2的硬币.
      	now=3,ans=2//此时选取了面值为2的
      需要寻找面值<=4的硬币
      	now=5,ans=3//又选取了面值为2的
      需要寻找面值<=6的硬币
      	now=10,ans=4//选取了面值为5的
      需要寻找面值<=11的硬币
      	now=20,ans=5//选取了面值为10的
    这样我们选取的为1·2·2·5·10,是可以凑出1~20的所有情况的。
总之思想就是每次选择的硬币,是可以和前面已经出现过的面值,继续组成更大面值的,每次选择最大面值(满足条件的)的,我们就可以实现我们的贪心。

每一次都要在找到比当前该凑数钱小的最大面值数，这样就可以在钱币数量相同的情况下可拼凑价值最大。------此话[出处](http://www.bubuko.com/infodetail-2621437.html)

--------------------代码---------------------
```cpp
#include<bits/stdc++.h>
#define IL inline
#define RI register int
IL void read(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s>'9'||s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s<='9'&&s>='0'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int x,N,now,ans;
int s[12];
int main()
{
    read(x),read(N);
    for(RI i=1;i<=N;i++)
        read(s[i]);
    std::sort(s+1,s+N+1);
    if(s[1]!=1)
    {
        puts("-1");
        exit(0);
    }
    while(now<x)
    {
        RI i;
        for(i=N;i;i--)
            if(s[i]<=now+1)break;
        ans++;
        now+=s[i];
        //printf("used:%d\n",s[i]);
    }
    printf("%d",ans);
}
```

---

## 作者：newbeeglass (赞：4)

这是一道贪心题，~~废话~~。

首先要排一次序，方便待会儿从大到小找，并且，已经排好序了，如果第一个数不为1（从小到大），就不可能有数为1，，没有一元面值的硬币即为无解

由于这道题目数据~~较弱~~（其实这道题数据大也不一定超时），所以直接从1到x把每种情况都枚举过去，如果当前的硬币不能满足这种情况，就在当前硬币的基础上加上需要用的硬币，最后输出硬币个数。

# AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int x,n,a[100001];
	cin>>x>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a,a+1+n);	//排序 
	if(a[1]!=1){
		cout<<-1;	// 排序好后，如果最小的不为1，就无解 
		return 0;
	}
	int ans=0,sum=0;
	for(int i=1;i<=x;i++){
		if(i>sum){
			for(int j=n;j>=1;j--){	//每次要选最大面额
				if(a[j]<=i){ 
					sum+=a[j];
					ans++;
					break; //避免出错，找到一个就break 
				}
			}
		}
	}
	cout<<ans;
	return 0; 
}

```


---

## 作者：Mr__Meng (赞：2)

这道题很明显是贪心，直接上代码。
```c
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int x,n,i,k,a[15],sum,ans;
int main()
{
	scanf("%d%d",&x,&n);
	for(i=1;i<=n;i++)
	    scanf("%d",&a[i]);          //输入 
	sort(a+1,a+1+n);                //按面值大小从小到大排序 
	if(a[1]!=1)
	{
		printf("-1");
		return 0;
	}                               //如果面值中没有1，则凑不出1元，无解；如果有1元，则可凑出任意面值 
	while(sum<x)
	{
	    for(i=n;i>=1;i--)           //从大到小循环，贪心，面值越大越好 
	        if(a[i]<=sum+1)break;   //sum是已经凑出的硬币总合，在1~sum+1中选出最大的可用硬币 
	    ans++;
	    sum+=a[i];                  //累加 
	}
	printf("%d",ans);               //输出 
	return 0;
}
```
#### 这里说明一下为什么是1~sum+1中选择
假设已经凑出面值N，则可以表示出1~N中的任意一个。而要凑出N+1，可以用1~	N中的来表示N+1，也可以直接选择N+1，而我们要凑最大的，所以N+1是最好的选择。

---

## 作者：lqr2018 (赞：1)


思路
------------
   这是道贪心，求最优解~~（废话）~~。
   
   我们可以将钱设想为砖，每块砖有一个长度，两块砖拼在一起长度相加。设当前砖长度是x1，当前整体长度为x0。x1不能大于x0+1(但要能组合出1到X之间的任意值)。
   
   假设x0及以下所有长度我们都可以组合，那么x1+x0及一下长度都可以组合，换言之，新的x0=旧的x0+x1，新x0及以下长度都可组合。
于是正确性得证。

   在此基础上为了总和最小，当前x1必然最大，当然是排序后从大到小遍历了。

代码
------------

```c
#include<bits/stdc++.h>
using namespace std;
int n,x,now,ans;
int a[30];
bool cmp(int a,int b){
	return a<b;
}
int main(){
	cin>>x>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+1+n,cmp);
	if(a[1]!=1){
		cout<<-1;
		return 0;
	}
	while(now<x){
		int i;
		for(i=n;i>=1;i--) 
			if(a[i]<=now+1) 	
				break;
		now+=a[i],ans++;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Lidozs55 (赞：1)

分析一下此题

首先，如果没有面值为1的硬币，无解

如果我们在往钱包中放硬币时肯定是越大越好，所以我们可以记录一下目前钱包中面值总和，而且需要提前排序。

所以

---

AC代码
```
#include<iostream>
#include<algorithm>
using namespace std;
int x,n,a[1001],sum,ans;
bool tmp;
int main(){
	cin>>x>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
		tmp+=(a[i]==1);			//记录有没有1
	}
	if(!tmp){				//特判
		cout<<-1;
		return 0;
	}
	sort(a,a+n);				//排序
	for(int i=1;i<=x;i++){
		if(sum>=i)continue;		//不需要新增硬币
		for(int j=n-1;j>=0;j--){
			if(a[j]<=i){		//可带的最大的
				ans++;		//多带一枚硬币
				sum+=a[j];	//面值总和
				break;
			}
		}
	}
	cout<<ans;				//输出
	return 0;
}
```

---

## 作者：Mr_QwQ (赞：1)

想了半天终于A了，发现楼下神犇正解。不过接下来我们会用dp的思想讲解我们的思路。

首先我们想想方程：设f[i]表示用这些硬币组成1~i的面值的最少数量。（看上去很靠谱）

但是我们会发现一个巨大的BUG：没法转移。。。。。

原因十分简单：假如我们要计算f[666]，用一个面值为233的硬币转移，就会发现你需要转移到f[433]。然而，你并不能知道f[433]究竟有没有包含足够的233，使得它有足够的233进行转移。（栗子举的可能不太恰当，但是把233换成5问题就会更加明显。）

所以我们需要改变状态，反其道而行之：设f[i]表示用i枚硬币可以表示出的最大k使得它们可以组成1~k的所有数！【关键点来了】

然后我们的方程就很简单了：f[i]=max{f[i-1]+a[j]|a[j]≤f[i-1]+1}

解释一下：为了更新答案，我们至少要凑出f[i-1]+1。那么如果往里面丢一个a[j]，它必须小于等于这个值，否则无法更新答案。扔进去以后，因为我们本来就可以凑出k-a[j]+1,k-a[j]+2,...k，那么把这些值全部加上a[j]，就得到k+1,k+2...k+a[j]。解释完毕。

另：由于f[i]只与f[i-1]有关，这一维可以完全滚掉。

我们要找到的，就是最小的p使得f[p]≥x。

而更新f[i]，需要一个满足a[j]≤f[i-1]+1的最大a[j]。

所以……这不就是个贪心么……直接排序，逆序查找，找到第一个满足条件的a[j]即可更新答案。

代码难度不高，留给大家自己编写。

最后注意细节（又是细节！）：如果a里面压根没有1，直接输出-1。否则，dp（或者叫贪心）会进入无限循环。


---

## 作者：qzhwmjb (赞：0)

### 思路（贪心）
输入+特判是否存在1   
有：ans=0 .  
没有：就输出无解,结束.
利用快速排序函数--sort进行排序（便于贪心）.   
因为要保证1到x的值能被除尽.  
我们要循环判断面值是否大于当前的数.    
是：不执行下列循环  
否：继续执行
for循环判断a[j]是不是小于需凑面值.  
是：  
1.个数加加.  
2.跳出此循环.   
3.目前可以拼出的最大的数加a[j].  
输出ans2.  
结束
#### 注意点
因为自然数当中是存在质数的.  
也就是说这些数.  
不可以被除了1之外的任何数整除.  
所以硬币中必须要有1这个面值.  
### 全代码
---
```cpp
#include<Bits/stdc++.h>//防伪标记
using namespace std;
int a[10005];
int main() {
	int n,x;
	cin>>x>>n;
	int i,j;
	bool ans=1;
	for(i=0; i<n; i++) {
		cin>>a[i];
		if(a[i]==1) {
			ans=0;
		}
	}
	if(ans!=0) {
		cout<<"-1"<<endl;
		return 0;
	}
	sort(a,a+n);
	int ans1=0,ans2=0;
	for(i=1; i<=x; i++) {
		if(ans1>=i){
			continue;
		}
		for(j=n-1; j>=0; j--) {
			if(a[j]<=i) {
				ans2++;
				ans1+=a[j];
				break;
			}
		}
		
	}
	cout<<ans2<<endl;
	return 0;
}
```

---

## 作者：孑彧 (赞：0)

# P1658 购物

### 题意描述

你就要去购物了，现在你手上有N种不同面值的硬币，每种硬币有无限多个。为了方便购物，你希望带尽量少的硬币，但要能组合出1到X之间的任意值。

### 思路

显而易见的是，假如没有1这个硬币，那么1的面额一定不能拼成，所以无解，假如有1，那么便可以构造出所有的面额

假设我们现在能拼成的面额为1—A,那么我下一次选择的硬币必然不会大于n+1，要不然不可以选出n+1的面额，那么我们就可以每一次贪心的选择面值为最大的$T(T\le n+1)$的硬币，把n更新到n+T，然后再次重复该过程，直到$n\ge X$,那么我们现在用的硬币数就是我们的答案。

### 代码

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int x,n;
int a[20];
int main(){
	cin>>x>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	int ans=0;
	int now=0;
	if(a[1]!=1){
		cout<<-1;
		return 0;
	}
	while(now<x){
		for(int i=n;i>=1;i--){
			if(a[i]<=now+1){
				ans++;
				now+=a[i];
				break;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：zyj_Orz (赞：0)

$\color{grey}\LARGE\text{此题就是}$ $\color{red}\Huge\text{贪心}$

考试考到了，当时灵光一现，认为此方法可行。当场 $\color{blue}\LARGE\text{AC}$。$qwq$

样例解释：（就是带）$\color{grey}\LARGE\text{1 2 2 5 10}$ （的货币）


当然，你把注释去掉即可看到需要带的货币分别为哪些。已排好序。此利于样例测试等。我考虑了一下，没有把它去掉。虽然时间复杂度会相应增加，但是绝对不会超时。

当然，因为我们使用linux考试的，所以解释为一堆乱码，但是不影响阅读使用。

$\huge\text{代码如下：}$

```
#include<bits/stdc++.h>
using namespace std;
int n,x,a[1002],b[1002],sum=0,d=1;
long long he=0;
bool yb(int o)//鍒ゆ柇鏄惁闇€瑕佸姞
{
	if(o>he)
	return 0;
	return 1;
}
void shop(int p)//鎵惧埌鏁板瓧锛屽鍏鏁扮粍锛屽姞鍒癶e涓紝鏁伴噺++
{
	for(int j=n;j>=1;j--)
	{
		if(a[j]<=p)
		{
			sum++;
			he+=a[j];
			d++;
			b[d]=a[j];
			for(int u=d-1;u>=1;u--)//鎻掑叆鏁板瓧鍒癰鏁扮粍鍚堥€備綅缃?
			{
				if(b[d]<b[u])
				swap(a[j],b[u]);
				else break;
			}
			break;
		}
	}
}
int main()
{
	cin>>x>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	if(a[1]!=1)
	{
		cout<<"-1";
		return 0;
	}
	else
	{
		b[1]=1;sum++;he=1;
		for(int i=2;i<=x;i++)
			if(yb(i)==0)
				shop(i);
	}
	//for(int i=1;i<=d;i++)
	//cout<<b[i]<<" ";
	//cout<<endl;
	cout<<sum;
}
```


---

## 作者：LOI_pingxing (赞：0)

~~蒟蒻第一次题解，求各路神犇打脸~~

楼下讲的对。

但我们依然可以用类似完全背包的dp来做，只要优化一下状态

设dp[i]为能凑成1~i所有数，且面值总合恰好为i的最小硬币数

然后就可以转移了

dp[i] = min(dp[i],dp[i - v[j]] + 1)//i - v[j] + 1 >= v[j]

至于为什么要i - v[j] + 1 >= v[j]，这点证明大概比较像鬼谷子钱包里二进制拆分，最后剩下的一组一定可以计入答案的证明

然后有一个问题，答案不一定为dp[x]

很显然我们需要的硬币的面额不一定恰好为x

好在范围比较小，没仔细思考证明，不过把数组开到两倍大就可以了

-1的情况只有一个，就是面值中没有1~~废话~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int x,n,v[10010],cnt;
int dp[10010],ans = 10010;
bool exist[10010];
bool cmp(int a,int b){
    return a > b;
}
int check(){
    memset(dp,0x3f,sizeof(dp));
    dp[0] = 0,dp[1] = 1;
    for(int i = 1;i <= x*2;i ++){
        for(int j = 1;j <= n;j ++){
            if(i - v[j] >= 0 && v[j] <= i - v[j] + 1)
                dp[i] = min(dp[i],dp[i - v[j]] + 1);
        }
        if(i >= x)ans = min(ans,dp[i]);
    }
    return ans;
}
int main(){
    scanf("%d%d",&x,&n);
    for(int i = 1;i <= n;i ++){
        scanf("%d",&v[i]);
        exist[v[i]] = true;
    }
    if(!exist[1])printf("-1");
    else printf("%d",check());
    return 0;
}
```

---


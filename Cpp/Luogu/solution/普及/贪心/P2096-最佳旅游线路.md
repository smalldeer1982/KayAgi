# 最佳旅游线路

## 题目描述

某旅游区的街道成网格状。其中东西向的街道都是旅游街，南北向的街道都是林阴道。由于游客众多，旅游街被规定为单行道，游客在旅游街上只能从西向东走，在林阴道上则既可从南向北走，也可以从北向南走。

阿龙想到这个旅游街游玩，他的好友阿福给了他一些建议，用分值表示所有旅游街相邻两个路口之见的街道值得游览的程度，分值是从-100到100的整数，所有林阴道不打分。所有分值不可能全是负分。如图：

 ![](https://cdn.luogu.com.cn/upload/pic/1235.png) 



## 样例 #1

### 输入

```
3 5 
-50 -47 36 -30 -23 
17 -19 -34 -13 -8 
-42 -3 -43 34 -45 
```

### 输出

```
84```

# 题解

## 作者：enceladus (赞：11)

[原题在此](https://www.luogu.org/problemnew/show/P2096)

------------

e，边做题，边写题解，大致读了遍题，是道 _**贪心**_ ，
那么我们分析一下题，图大概是下面这个样子：![](https://cdn.luogu.com.cn/upload/pic/20708.png)


------------


竖直方向可以随便走嘛，所以求出每一列
的最大值，再做比较就可以了。


------------
but，命运多舛，交了一遍，80分，有两个点过不了，重读遍题发现：对了，不一定要在最右边结束，也不一定在最左边开始，这点很重要，这才AC了此题。
先上代码


------------

八十分版
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define ll long long
#define R register
#define mmax 20002
ll n,m,maxx=-0x7fffffff,ans;
ll tu[102][mmax],da[mmax];
int main()
{
    /*freopen(".in","r",stdin);
    freopen(".out","w",stdout);*/
    cin>>m>>n;
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
    {
    cin>>tu[i][j]; //输入 
    }
    /*for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
    {
    cout<<tu[i][j]<<" "; 
    }*/
    
    for(int i=1;i<=n;i++)
    {
        maxx=-0x7ffffff; 
        for(int j=1;j<=m;j++)
            {
               if(tu[j][i]>maxx)//注意i和j的顺序 
               {
               da[i]=tu[j][i];
               maxx=tu[j][i];//
               }
              
            }
        }
        /*for(int i=1;i<=n;i++)
        {
            cout<<da[i]<<" ";//最大值 
        }*/
        ll qzh1=0,qzh2=0;
        for(int i=1;i<=n;i++)
        {	
            qzh1=qzh2+da[i];
            qzh2=qzh1;
            if(ans<qzh1) ans=qzh1;
        }
        cout<<ans<<endl;
    /*fclose(stdin);
    fclose(stdout);*/
    return 0;
}

```


------------
一百分版
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define ll long long
#define II int
#define R register
#define mmax 20002
#define inf 0x7ffffff 
II n,m,ans;
II tu[102][mmax],da[mmax];
II mxsum(II *x){   //最大子串和
    II th=0;
    II mx=0;
    for(R II i=1;i<=n;++i){
        th+=x[i];
        if(th<0)th=0;
        else if(th>mx)mx=th;
    }
    return mx;
}
int main()
{
    /*freopen(".in","r",stdin);
    freopen(".out","w",stdout);*/
    cin>>m>>n;
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
    {
        cin>>tu[i][j]; //输入 
    }
    for(int i=1;i<=n;i++)
    {
        da[i]=-inf;
        for(int j=1;j<=m;j++) 
           if(tu[j][i]>da[i])//注意i和j的顺序 
           {
           		da[i]=tu[j][i];、、每列最大值
           }
    }
    cout<<mxsum(da)<<endl;
    /*fclose(stdin);
    fclose(stdout);*/
    return 0;
}
```
就这样了，好好打，别变棕哟QWQ。

---

## 作者：chengni (赞：10)

自己在做这道题的时候并没有遇见时间的问题。这道题做法很明显，利用贪心思想，先求出各列的最大值，在一波循环带走即可，只需要稍微判断下数的正负，感觉并不是很复杂。

下面AC代码

    
    
    
    
            
            
        
```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    int a[200][23000]={0};//这个数组用来存道路的分值
    int main(){
    int m,n,x,y,f,ans=0,sum=0;
    cin>>m>>n;
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
    cin>>a[i][j];//读入数据
    for(int i=1;i<=n;i++)//循环开始
    {
        f=-1000000;//随手赋了一个绝对最小值
        for(int j=1;j<=m;j++)
        {
            f=max(a[j][i],f);//找到每一列的最大值
        }
        if(f<0){//如果是负数，需要特殊考虑
                ans=max(sum,ans);//但无论怎样，先比较已经得到的值
        //这里比较是有必要的，因为你不知道你接受了这个负数后后面
        //的数据能否挽回这次损失，比如这个负数的绝对值大于后面的
        //正数值，那样这个点就应该舍去
                if (sum+f>0) sum+=f;//如果加了这个负数之后不是零，带上
                //因为求最大值肯定要带上这个大于零的值
                else sum=0;//否则就不走前面
        }
        else {
            sum+=f;//如果不是负数，带上
        }
    }
    if(sum!=0) ans=max(ans,sum);//这里是把最后的数据记录
    cout<<ans;//输出
    return 0;//功德圆满
    }
```
只要处理好负数，应该不会有什么问题。
个人认为这段代码还比较粗糙，还可以加以改进，希望提出建议。


---

## 作者：顾z (赞：3)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述-->[p2096 最佳旅游路线](https://www.luogu.org/problemnew/show/P2096)

## 分析

自己xjb分析了一通,发现只需要求出每一列的最大值,然后**求整个范围的最大子段和**即可.

一想,woc,最大子段和.线段树啊!.

**线段树维护最大子段和**操作.

考虑到大多数人可能不会,所以我把我博客的一些部分取了过来 qwq.

### 数组定义

$lsum[ ]$代表 该区间左端点开始的最大连续和.

$rsum[ ]$代表 该区间右端点开始的最大连续和.

$ssum[ ]$代表 区间内最大连续和.

$sum[ ]$ 代表区间和.

### Que and Ans

##### Q:已知一个区间的左右区间的最大连续和,如何合并?

##### A:这个区间的最大连续和要么是左子区间的最大连续和,要么是右子区间的最大连续和.

##### 要么是左子区间的最大右起子段和+右子区间的最大左起字段和.

 ``code``：$ssum[o]=max(max(ssum[lson],ssum[rson]),rsum[lson]+lsum[rson])$

##### Q:如何更新区间最大左起子段和.

#####  A:新区间的最大左起子段和.要么是其左子区间最大连续和,要么是其左子区间和+右子区间的左起子段和.

**最大右起子段和同理**

``code``：$lsum[o]=max(lsum[lson],sum[lson]+lsum[rson])$

　　　　  $rsum[o]=max(rsum[rson],sum[rson]+rsum[lson])$

更新操作类似单点修改

不能理解的话可以画图演示一下.qwq

或者等我在博客上画图 qwq.(具体时间未知.

-------------------代码------------------

```cpp
#include<bits/stdc++.h>
#define IL inline
#define int long long
#define RI register int
#define N 200008
#define ls o<<1
#define rs o<<1|1
using namespace std;
IL void in(int &x)
{
    int f=1;x=0;char s=getchar();
    while(s>'9' or s<'0'){if(s=='-')f=-1;s=getchar();}
    while(s>='0' and s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
int tr[N<<2],ssum[N<<2],lsum[N<<2],rsum[N<<2],n,m,a[20001];
IL void up(int o)
{
    tr[o]=tr[ls]+tr[rs];
    ssum[o]=max(max(ssum[ls],ssum[rs]),rsum[ls]+lsum[rs]);
    lsum[o]=max(lsum[ls],tr[ls]+lsum[rs]);
    rsum[o]=max(rsum[rs],tr[rs]+rsum[ls]);
}
IL void build(int o,int l,int r)
{
    if(l==r)
    {
        tr[o]=a[l];
        ssum[o]=lsum[o]=rsum[o]=tr[o];
        return;
    }
    int mid=(l+r)>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    up(o);
}
IL int query(int o,int l,int r,int x,int y)
{
    if(l<=x and y>=r)return ssum[o];
    int mid=(l+r)>>1;
    int ret=-2147483647;
    if(x<=mid)ret=max(query(ls,l,mid,x,y),ret);
    if(y>mid)ret=max(query(rs,mid+1,r,x,y),ret);
    return ret;
}
main(void )
{
    in(n),in(m);
    for(RI i=1;i<=m;i++)a[i]=-2147483647;
    for(RI i=1;i<=n;i++)
    	for(RI j=1,x;j<=m;j++)
    	{
    		in(x);
			a[j]=max(a[j],x);
    	}
    build(1,1,m);
    printf("%lld",query(1,1,m,1,m));
}
```

---

## 作者：0zhouyq (赞：2)

## 题意简述
给定一个 $n\times m$ 的矩阵，每列选出一个最大值 $a[i]$ ，然后求 $a$ 数列的最大字段和。

思路：
在林荫道上走并不会影响观赏值，所以只要把每列的最大值求出来就行了。

最大字段和的求法可以参考[这题](https://www.luogu.com.cn/problem/P1115)

## AC CODE
```
#include <bits/stdc++.h>
using namespace std;
int main(){
	int n,m;
	scanf("%d %lld",&n,&m);
	int t[n+1][m+1];//记录输入的观赏价值。
	int dp[m+1];//记录每列的最大值。
	for(int i=1;i<=n;i++){
   		for(int j=1;j<=m;j++) {
  			scanf("%d",&t[i][j]);
  		}
   	}
	dp[0]=0;
	int maxn;
	for(int j=1;j<=m;j++){
		maxn=-2147483648;// -2147483648是int 的最小值。
		for(int i=1;i<=n;i++){
			maxn=max(maxn,t[i][j]);//求最大值。
		}
		dp[j]=maxn;
	}
	int z[m+1];
	z[0]=0;
	maxn=-2147483648;
	for(int i=1;i<=m;i++){
		z[i]=max(z[i-1]+dp[i],dp[i]);//参考最大字段和那题。
		maxn=max(maxn,z[i]);
	}
	printf("%d",maxn);
	return 0;
}
```


---

## 作者：yizcdl2357 (赞：2)

首先我们注意到，在任何相邻两列上分别取两个格子，都可以从一个走到另一个。

如图所示：

![示例1](https://cdn.luogu.com.cn/upload/image_hosting/ilcacijt.png)

所以，每一列选的格子是不会互相影响的，只要每一列**选最大值**即可。

![示例2](https://cdn.luogu.com.cn/upload/image_hosting/qy43nxm6.png)

但是，我们不必从第一列走到最后一列。事实上，我们只要保证走过的路段**连续**即可。

于是，这变成了一个“最大连续和”的问题。

![](https://cdn.luogu.com.cn/upload/image_hosting/cyjqdvq5.png)

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,a,maxn[20002],dp[20002],ans; 
int main()
{
	memset(maxn,-63,sizeof(maxn));
	memset(dp,-63,sizeof(maxn));
	cin>>m>>n;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&a);
			maxn[j]=max(maxn[j],a);//更新每列最大值
		}
	for(int i=1;i<=n;i++)//最大连续和
		dp[i]=maxn[i]+max(dp[i-1],0),ans=max(dp[i],ans);
	cout<<ans;
	return 0;
}
```


---

## 作者：beng (赞：2)

# 基本思想跟楼下差不多……

大致就是**找出每列最大值，再求最大子段和**……

（但我拿出一个自认为时间复杂度（虽然**读入的时间复杂度最大**QAQ）、空间复杂度较小的方法……（应该是吧QAQ））

——————分割不完全的分割线——————

pascal程序如下：

```cpp
var n,m,i,j,k,max:longint;
a:array[0..20001]of longint;//一个20000的数组就够了
begin
  readln(n,m);
  for i:=1 to m do
  a[i]:=-maxlongint;//定初始值，方便下面选最大值
  for i:=1 to n do
  for j:=1 to m do//读入的时间复杂度最大QAQ
  begin
    read(k);
    if k>a[j] then//选最大值
    a[j]:=k;
    //**千万不能readln，第八个点坑爹，切记！**
  end;
  k:=0;
  max:=-maxlongint;
  for i:=1 to m do//求最大子段和
  begin
    if a[i]+k<0 then//如果加到一个数和比0小，还能要吗！！！
    k:=0//不能要
    else
    k:=k+a[i];//能要
    if k>max then//找最大值
    max:=k;
  end;
  writeln(max);
end.
```

---

## 作者：Lynx (赞：2)

主要思路：

1.贪心选出每列最值

2.求最大子段和


附c++AC代码

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int m,n,sum,a[20010];
int main()
{
    int t=0;
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
        a[i]=-100;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            int x;
            scanf("%d",&x);
            if(x>a[j])
                a[j]=x;//贪心的策略，取每列最大值 
        }
    for(int i=1;i<=n;i++)
    {
        if(a[i]>=0)
        {
            t+=a[i];//若为正数，累加入t 
            if(t>sum)
                sum=t;//更新sum的值 
        }
        else//若为负数 
        {
            if(t+a[i]<=0)//若累加后小于零 
                t=0;//重新累加 
            else
                t+=a[i];//累加 
        }
    }
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：Energy_Making (赞：1)

## 前置知识: [动态规划入门](https://oi-wiki.org//dp/)
先读题，题意简化一下就是选取 _x_ （$ 1 \le x \le m $）列，每列选一个景点，求评分最大值。由于风景所在的列必须连续，所以其实是求 **最大子串和**。

状态转移方程如下：
*  _$dp_i$_ =
 $\left\{\begin{matrix} dp_{i+1}+a_i(dp_{i+1} \ge 0)
 &  &  &  &  &  &  &  &  & \\ a_i(dp_{i+1} < 0)
 &  &  &  &  &  &  &  &  & 
\end{matrix}\right.$

解释：当 $ dp_{i+1} \ge 0$时，$dp_i$ 就加上它，因为这样可以变大，否则不加，避免变小。 
# 能让XXSAC此题的东西

```cpp
#include<stdio.h>
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=-1e9;
int sco[105][20005],h[20005],dp[20005];
int main()
{
    scanf("%d %d",&m,&n);
    for(int i=1;i<n;i++)h[i]=-1e9;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&sco[i][j]);
    for(int i=1;i<=n;i++)    
        for(int j=1;j<=m;j++)
            h[i]=max(h[i],sco[j][i]); //求每列最大值来做最大子串和。
    for(int i=n;i>=1;i--)
    	if(dp[i+1]>=0)dp[i]=dp[i+1]+h[i];
    	else dp[i]=h[i];
    for(int i=1;i<n;i++)ans=max(ans,dp[i]);
    printf("%d",ans);
    return 0;
 } 
```

---

## 作者：Henry_he (赞：1)

方法
由题意知首先求出每列最大值，在最大字段和求出结果

```cpp
var n,m,i,j,max:longint;
    a:array[1..100,1..20001]of longint;
    b,s:array[0..20001]of longint;
begin
  readln(n,m);
  for i:=1 to n do\\读入
   for j:=1 to m do
     read(a[i,j]);
  for i:=1 to m do\\找出每列最大值
  begin
    b[i]:=-maxlongint;
    for j:=1 to n do
      if a[j,i]>b[i] then
       b[i]:=a[j,i];
  end;
  for i:=1 to m do\\s[i]表示b[1]+b[2]...+b[i]
    s[i]:=s[i-1]+b[i];
  for i:=0 to m do\\求最大字段和
    for j:=i+1 to m do
      if s[j]-s[i]>max then
      max:=s[j]-s[i];
  writeln(max);
end.
```

---

## 作者：Xu_brezza (赞：0)

# 题意：
一个矩阵，可以选择连续的几列作为路径，该路径价值为每列中选取一个元素的加和，求路径价值最大值

## 分析：
一个显然的贪心思路就是每一列选择的都是该列最大值，也就是这一列的贡献。
这样我们可以得到一个一个数组， $i$ 位置记录第 $i$ 列最大值，问题转化为最大子段和。
最大子段和可以动态规划，策略就是记录子段和，如果子段和为负，那么加上任意一个数都只会让这个数变小，直接将子段和更新为当前元素即可，同时取最大值。

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
int a[105][20005],s[20005];
int main(){
	int ans = 0,mini;
	int n,m;
	scanf("%d%d",&m,&n);
	n++;
	memset(a,0,sizeof(a));
	for(int i=1;i<=m;++i){
		for(int j=1;j<n;++j)scanf("%d",&a[i][j]);
		
	}
	for(int i=1;i<=n;++i){
		mini = -1e8;
		for(int j=1;j<=m;++j){
			mini = max(a[j][i] ,mini);
		}
		s[i] = mini;
	}
	int mx = -1e9;
	for(int i=1;i<=n;++i){
		if(ans <= 0)ans = s[i];
		else ans += s[i];
		mx = max(ans,mx);
	}
	printf("%d",mx);
}

```



---

## 作者：glorious_dream (赞：0)

### 题目大意：

给定一个矩阵，横着只能单向走，竖着没有限制，求出经过路径上能得到的最大值。

### 算法分析：

首先这道题有一个坑点：不一定要从第一个点开始走，可以从任意一个点走到任意一个点。于是想到什么？贪心 $+$ 动态规划。

先说一下贪心：很容易发现，需要先把每一列的最大值求出来，然后进行 dp，再用一个数组记录就行。

然后说动态规划：当前的节点 $i$，可以自己重新来最大值，也可以前一个的 dp 值加上这个节点的值，最后取最大值就行。

### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){ //快读不解释 
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
    return x*f;
}
const int M = 200010;
int a[110][M],f[M],mp[M]; //mp存每一列的最大值 
int m,n;
int ans,sum;
signed main(){
    m=read(),n=read();
    for(register int i(1) ; i<=m ; i=-~i){
        for(register int j(1) ; j<=n ; j=-~j){
            a[i][j] = read();
        }
    }
    for(register int i(1) ; i<=n ; i=-~i){
        int maxn = -1e9;
        for(register int j(1) ; j<=m ; j=-~j){
            maxn = max(maxn,a[j][i]); //更新最大值 
        }
        mp[i] = maxn;
    }
    for(register int i(1) ; i<=n ; i=-~i) f[i] = max(mp[i],f[i-1]+mp[i]); //这个点能得到的最大值 
    for(register int i(1) ; i<=n ; i=-~i) ans = max(ans,f[i]); //因为是可以从任意点结束，要取最大值 
    printf("%d",ans);
    return 0;
}

```


---

## 作者：happybob (赞：0)

# 题意

给定 $n, m$，以及一个二维矩阵 $a_{i,j}$，设 $g_i = \max{(a_{1,i}, a_{2,i}, \dots, a_{n,i})}$，其中 $1 \le i \le m$，求一个 $l, r( 1 \le l \le r \le m)$ 最大化 $\sum_{i=l}^r g_i$，输出最大的 $\sum_{i=l}^r g_i$。

# 思路

明显就是先贪心，然后最大子段和。最大子段和考虑线段树维护。不要以为线段树不好打，但是线段树可以做到 $O(n)$ 预处理，$O(\log n)$ 单点修改和询问。远比 $O(n)$ 预处理 $O(1)$ 修改，$O(n)$ 的 DP 速度快，因为 $\log n$ 其实很小，当 $\log n = 30, n = 2^{30}$，可以看到线段树复杂度均匀，多次询问修改是更好的选择。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 205, M = 20005;

int n, m, a[N][M], maxn[M];

struct Node
{
	int l, r;
	int sum, lmax, rmax, tmax;
	Node()
	{
		l = r = sum = 0;
		lmax = rmax = tmax = -1e9;
	}
	friend Node operator+(const Node& x, const Node& y)
	{
		Node p;
		p.sum = x.sum + y.sum;
		p.lmax = max(x.lmax, x.sum + y.lmax);
		p.rmax = max(y.rmax, y.sum + x.rmax);
		p.tmax = max({ x.tmax, y.tmax, x.rmax + y.lmax });
		return p;
	}
};

Node tree[M << 2];

inline void push_up(int u)
{
	int tl = tree[u].l, tr = tree[u].r;
	tree[u] = tree[u << 1] + tree[u << 1 | 1];
	tree[u].l = tl, tree[u].r = tr;
}

inline void build(int u, int l, int r)
{
	tree[u].l = l, tree[u].r = r;
	if (l == r)
	{
		tree[u].lmax = tree[u].rmax = tree[u].sum = tree[u].tmax = maxn[r];
	}
	else
	{
		int mid = (l + r) >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		push_up(u);
	}
}

inline void modify(int u, int x, int v)
{
	if (tree[u].l == x && tree[u].r == x)
	{
		tree[u].lmax = tree[u].rmax = tree[u].sum = tree[u].tmax = v;
	}
	else
	{
		int mid = (tree[u].l + tree[u].r) >> 1;
		if (x <= mid) modify(u << 1, x, v);
		else modify(u << 1 | 1, x, v);
		push_up(u);
	}
}

Node query(int u, int l, int r)
{
	if (tree[u].l >= l && tree[u].r <= r) return tree[u];
	int mid = (tree[u].l + tree[u].r) >> 1;
	Node x, y;
	if (l <= mid) x = query(u << 1, l, r);
	if (r > mid) y = query(u << 1 | 1, l, r);
	return x + y;
}

int main()
{
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++) scanf("%d", &a[i][j]);
	}
	for (int i = 1; i <= m; i++)
	{
		maxn[i] = -1e8;
		for (int j = 1; j <= n; j++) maxn[i] = max(maxn[i], a[j][i]);
	}
	build(1, 1, m);
	printf("%d\n", query(1, 1, m).tmax);
	return 0;
}
```


---

## 作者：Creeper_LKF (赞：0)

据说此题的最大坑点就是读入时间，于是我就把读入优化放了出来。**此读入优化并不是最佳读入优化，但是对P党友好，而且在C++下还可以自动防止因数据输入不完整或因linux换行符或文件读入有空格而造成的RE、TLE等**（WA就不保证了）（如果要达到拓展功能，请勿修改while循环部分），并且还可以吃掉下一个字符来达到readln（换行）的效果。读入优化+DP=3ms

```cpp
#include<bits/stdc++.h>
using namespace std;
int road[20001];
inline int read(){
    int num=0;//初始化整数
    char c,sf=1;//字符、负数标记
    while(isspace(c=getchar()));//核心语句
    if(c=='-') sf=-1,c=getchar();//判断负数
    while((num=num*10+c-48)&&isdigit(c=getchar()));
    return num*sf;
}
int main(){
    int m=read(),n=read(),temp1;
    memset(road,128,sizeof(road));//可以初始化为最小整数
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            temp1=read();
            if(temp1>road[j]) road[j]=temp1;//只取当前这一列最大值
```
}//因为允许南北向走而无花费，所以每一列可以选最大值
}//其实题意是人可以从任意一列进去，从任意一列出来（看了半天）

int max\_v=-536870912,now\_v=0;//初始化，记录最大值和当前值

```cpp
    for(int i=1;i<=n;i++){
        if((temp1=road[i]+now_v)>max_v) max_v=temp1;//temp1减少加法次数，一直寻找字段最大值
        if(temp1<0) now_v=0;//如果前面部分小于0就没有贡献且“拖后腿”（就舍去）
        else now_v=temp1;//否则继续累加
    }
    printf("%d",max_v);
    return 0;
}
```

---

## 作者：dashuai (赞：0)

```cpp
uses math;
var i,j,k,n,m,ans:longint;
    a:array[0..20002,0..102]of longint;
    f:array[0..30000]of longint;
begin
  readln(n,m);
  for i:=1 to n do
    for j:=1 to m do read(a[j,i]);
  for i:=1 to m do
    for j:=1 to n do
    f[i]:=max(f[i],max(f[j],f[i-1]+a[i,j]));// 动态规划
  for i:=1 to m do if ans<f[i] then ans:=f[i];//因为可以从任意街道走出
  write(ans);
end.
```

---


# Mzc和体委的争夺战

## 题目背景

mzc 与 djn 第四弹。


## 题目描述

mzc 家很有钱（开玩笑），他家有 $n$ 个男家丁（做过前三弹的都知道）。但如此之多的男家丁吸引来了我们的体委（矮胖小伙），他要来与 mzc 争夺男家丁。

mzc 很生气，决定与其决斗，但 cat 的体力确实有些不稳定，所以他需要你来帮他计算一下最短需要的时间。


## 说明/提示

$1\le n \leq 2500$，$1\le m \leq 2\times10^5$，$1\le c_i\le 10^6$。

由于 mzc 大大十分着急，所以他只能等待 1s。


## 样例 #1

### 输入

```
5 8
1 2 3
2 3 4
3 4 5
4 5 6
1 3 4
2 4 7
2 5 8
1 5 100
```

### 输出

```
11```

# 题解

## 作者：Dr.九命猫 (赞：11)

本来认为是dijkstra

其实BELLMAN-FORD就抡过去了（划掉）
 
 以下是B-F代码
 

------------

 
 ```cpp
#include<cstdio>
using namespace std;
int a[1000001],b[1000001],c[1000001],d[2510];
/*注意数组大小，没给范围，100W才过。。。*/
int main()
{
	int n,m;
	int i,j;
    int INF=999999999;
    //INF尽量大，但是要保证2*INF不爆
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
	}
	for(i=1;i<=n;i++)
	{
		if(i==1) d[i]=0;
		else d[i]=INF;
	}//赋初值
	for(i=1;i<=n-1;i++)
	{
		for(j=1;j<=m;j++)
		{
			if(d[a[j]]+c[j]<d[b[j]])
			d[b[j]]=d[a[j]]+c[j];
            //因为是无向图，所以来回两遍
			if(d[b[j]]+c[j]<d[a[j]])
			d[a[j]]=d[b[j]]+c[j];		
		}//标准的松弛
	}
	printf("%d",d[n]);//题目错了，应该是N不是M
	return 0;
}
```

------------
//蒟蒻题解，多多指教


---

## 作者：利刃随人 (赞：7)

# 此代码是受SDWC 2019 rk7指导而写出来的！！
看到题解里一堆堆全是SPFA，dijkstra在后面了。我就想发一个堆优化得dijkstra（也是SDWC 2019 rk7教我的）。
利用了邻接表，STL中的优先队列（~~废话~~）。
为了防止像某位大佬一样，抄自己题解被棕名，我先自己AC掉了QWQ。
在这里我真挚的对那位跑了6遍DP的大佬说一声tql！
代码如下：
```cpp
#include<iostream>
#include<queue>
#define maxn 100001
#define inf 0x7fffffff
using namespace std;
int head[maxn],cnt,dis[maxn],n,m;
bool vis[maxn]={0};
struct node{
    int dis,jd;
    bool operator < (const node &a) const{
    return a.dis<dis;
    }
};
struct Edge{
    int next,to,worth;
}e[maxn*1000];
void insert(int from,int to,int worth)
{
    e[++cnt].next=head[from];
    e[cnt].to=to;
    e[cnt].worth=worth; 
    head[from]=cnt;
}
void dijkstra()
{
    priority_queue<node>q;
    for(int i=1;i<=n;i++)
    dis[i]=inf;
    dis[1]=0;
    q.push((node){0,1});
    while(!q.empty())
    {
        node now=q.top();
        q.pop();
        if(vis[now.jd]) continue;
        vis[now.jd]=true;
        for(int i=head[now.jd];i;i=e[i].next)
        if(dis[e[i].to]>dis[now.jd]+e[i].worth)
        {
            dis[e[i].to]=dis[now.jd]+e[i].worth;
            q.push((node){dis[e[i].to],e[i].to});
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        insert(x,y,z);
  		insert(y,x,z);
    }
    dijkstra();
    cout<<dis[n];
    return 0;
}
```


---

## 作者：dan_daning_L (赞：6)

## 一道~~纯粹的~~Dijkstra模板题
### 题目很简单，因为是单源非负边权，邻接矩阵+Dijkstra就可以过。

------------

# 注意！！40分原因如下：
- 各位dalao要注意的是存储邻接矩阵的过程中需要去重，否则后面的路径会把之前的覆盖(~~被卡了很久才发现~~)： 
```cpp
   for (i=1;i<=m;i++)
   {
	cin>>x>>y>>z;
	f[x][y]=f[y][x]=min(z,f[x][y]);
   }
```
- 所以要做一个比较，保证存入的路径长度最小。
####  下面献上本蒟蒻的代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int f[2501][2501],c[2501],b[2501];
int main()
{
   int n,m,x,y,z,i,j;
   memset(f,0x3f3f3f3f,sizeof(f));  //邻接矩阵初始化最大值 
   cin>>n>>m;
   for (i=1;i<=m;i++)
   {
	cin>>x>>y>>z;
	f[x][y]=f[y][x]=min(z,f[x][y]); //输入&存储&判重 
   }
   for (i=1;i<=n;i++)               //经典Dijkstra模板,起点为1 
   c[i]=f[1][i];
   memset(b,0,sizeof(b));
   b[1]=1;
   c[1]=0;
   for (i=1;i<n;i++)
   {
	    int minn=0x3f3f3f3f;
	    int k=0;
	    for (j=1;j<=n;j++)
	        if ((!b[j])&&(c[j]<minn))
	        {
		     minn=c[j];
	         k=j;
	        }
	    if (!k) break;
	      b[k]=1;
	    for (j=1;j<=n;j++)
	      c[j]=min(c[j],c[k]+f[k][j]);
   } 
   cout<<c[n];                      //因为是1~n所以输出c[n]
}
```
想要~~和本蒟蒻一起~~学习Dijkstra的大佬们来 [这里](https://blog.csdn.net/qq_35644234/article/details/60870719)

---

## 作者：little_gift (赞：5)

# 单源最短路径，SPFA，就不详细讲解了，带来普通与pb\_ds两个版本 #



## 这是正常版本 ##





```cpp
#include <bits/stdc++.h> //万能头文件 
using namespace std;
struct Edge
{
    int nxt, to, val;
}a[3125000]; //奇怪的struct 
int fir[5000], d[5000], b[5000];
int n, m, u, v, w, cnt;
queue < int > q;
int read_int() //快读 
{
    int x, f = 1;
    char ch;
    while (ch = getchar(), ch < 48 || ch > 57)
        if (ch == '-') f = -f;
    x = ch - 48;
    while (ch = getchar(), ch >= 48 && ch <= 57)
        x = x * 10 + ch - 48;
    return x * f;
}
void write_int(int x) //快输(反正我这么叫) 
{  
    if (x == 0)
    {
        putchar('0');
        return;
    }
    int num = 0;
    char c[11];
    while (x)
        c[++num] = x % 10 + 48, x /= 10;
    while (num)
        putchar(c[num--]);
}
int add_edge(int u, int v, int w) //添加一条边 
{
    a[++cnt].to = v;
    a[cnt].val = w;
    a[cnt].nxt = fir[u];
    fir[u] = cnt;
}
int main()
{
    n = read_int();
    m = read_int();
    for (int i = 1; i <= m; ++i)
    {
        u = read_int();
        v = read_int();
        w = read_int();
        add_edge(u, v, w);
        add_edge(v, u, w); //无向边 
    }
    for (int i = 1; i <= n; ++i)
        d[i] = 0x7fffffff; //maxlongint初始化 
    q.push(1);
    b[1] = 1; //入队 
    d[1] = 0; 
    while (!q.empty()) //如果队列不为空 
    {
        u = q.front();
        q.pop(); //出队
        b[u] = 0; //原来漏了这句，不断80 
        for (int i = fir[u]; i; i = a[i].nxt)
            if (d[u] + a[i].val < d[a[i].to]) //relax条件判断 
            {
                d[a[i].to] = d[u] + a[i].val;
                if (!b[a[i].to]) //入队 
                {
                    q.push(a[i].to);
                    b[a[i].to] = 1;
                }
            }
    }
    write_int(d[n]);
}
```
## 下面是pb\_ds版本(用法基本一样,相同的就不写了) ##



```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp> //pb_ds的priority_queue头文件 
using namespace std;
struct Edge
{
    int nxt, to, val;
}a[3125000];
int fir[5000], d[5000], b[5000];
int n, m, u, v, w, cnt;
struct comp
{
    __inline__ __attribute((always_inline)) bool operator()(int a, int b)
    {
        return d[a] > d[b];
    }
}; //比较器,用于pb_ds的priority_queue 
__gnu_pbds::priority_queue < int, comp > q; //__gnu_pbds是pb_ds的命名空间
int read_int()
{
    int x, f = 1;
    char ch;
    while (ch = getchar(), ch < 48 || ch > 57)
        if (ch == '-') f = -f;
    x = ch - 48;
    while (ch = getchar(), ch >= 48 && ch <= 57)
        x = x * 10 + ch - 48;
    return x * f;
}
void write_int(int x)  
{  
    if (x == 0)
    {
        putchar('0');
        return;
    }
    int num = 0;
    char c[11];
    while (x)
        c[++num] = x % 10 + 48, x /= 10;
    while (num)
        putchar(c[num--]);
}
int add_edge(int u, int v, int w)
{
    a[++cnt].to = v;
    a[cnt].val = w;
    a[cnt].nxt = fir[u];
    fir[u] = cnt;
}
int main()
{
    n = read_int();
    m = read_int();
    for (int i = 1; i <= m; ++i)
    {
        u = read_int();
        v = read_int();
        w = read_int();
        add_edge(u, v, w);
        add_edge(v, u, w);
    }
    for (int i = 1; i <= n; ++i)
        d[i] = 0x7fffffff;
    q.push(1);
    b[1] = 1;
    d[1] = 0;
    while (!q.empty())
    {
        u = q.top();
        q.pop();
        b[u] = 0;
        for (int i = fir[u]; i; i = a[i].nxt)
            if (d[u] + a[i].val < d[a[i].to])
            {
                d[a[i].to] = d[u] + a[i].val;
                if (!b[a[i].to])
                {
                    q.push(a[i].to);
                    b[a[i].to] = 1;
                }
            }
    }
    write_int(d[n]);
}
```

---

## 作者：冈崎梦美 (赞：2)

这一题可以使用裸的迪杰斯特拉+邻接矩阵水过，也可以用邻接表SPFA过。在这里介绍一种新的方法：

# **前向星**（不是链式的）

所谓前向星，就是一个边集数组在读入完之后，再进行一次排序，使得同一个顶点的出边都放在一块，方便遍历。实现起来较之邻接表简单很多（毕竟不用指针），但效率较低（需要一个sort（n log n）的复杂度）


这样，就可以很方便地进行SPFA了，对于一些数据范围不大的题目而言，前向星是一个不错的选择。


```cpp
#include<bits/stdc++.h>
using namespace std;
struct node//边结构体
{
    int from;
    int to;
    int dist;
};
long long dist[10005];//最短路径估计值
int head[10005],len[10005],n,m,s,num;//head存储每个节点第一条出边的位置，len存储每个节点有几条出边
bool vis[10005];
node edge[3125000];//从楼上dalao们的程序里看到的玄学数据范围
queue<int>team;
void addedge(int x,int y,int z)
{
    num++;
    len[x]++;
    edge[num].from=x;
    edge[num].to=y;
    edge[num].dist=z;
}
bool cmp(node a,node b)
{
    if ((a.from==b.from)&&(a.to==b.to)) return a.dist<b.dist;//如果起点终点都相同，就比较权重
    if (a.from==b.from) return a.to<b.to;//起点相同比较终点
    return a.from<b.from;//比较起点
}
int main()
{
    memset(head,-1,sizeof(head));
    memset(len,0,sizeof(len));
    memset(vis,false,sizeof(vis));
    memset(dist,0x3f,sizeof(dist));
    cin>>n>>m;
    s=1;
    num=0;
    for(int i=0;i<m;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        addedge(a,b,c);
        addedge(b,a,c);//无向图，所以加两次
    }
    sort(edge+1,edge+num+1,cmp);
    for(int i=1;i<=num;i++)
    {
        if (edge[i].from!=edge[i-1].from) head[edge[i].from]=i;
    }
    dist[s]=0;
    team.push(s);
    vis[s]=true;
    while(!team.empty())
    {
        int q=team.front();
        for(int i=head[q];i<head[q]+len[q];i++)
        {
            if (dist[edge[i].to]>dist[edge[i].from]+edge[i].dist)
            {
                dist[edge[i].to]=dist[edge[i].from]+edge[i].dist;
                if(!vis[edge[i].to])
                {
                    vis[edge[i].to]=true;
                    team.push(edge[i].to);
                }
            }
        }
        vis[q]=false;
        team.pop();
    }//SPFA，不再赘述
    cout<<dist[n];
    return 0;//结束了？
}
```

---

## 作者：Fatalis_Lights (赞：1)

这个题完全是个最短路裸题，我用的是dij+堆优化，跑的还算快吧。

还有，这个题记得要建双向边，之前窝貌似被坑了。

然后就是 ~~(你们喜欢的)~~ 代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define N 200009
#define inf 2e9 
using namespace std;
bool ok[N];
int n,m,s,dst[N],x[N];
vector<int> to[N],w[N];
struct Node{int c,u;};
struct GREATER{
	bool operator()(const Node&a,const Node&b){
		return a.c>b.c;
	}
};
priority_queue<Node,vector<Node>,GREATER> q;
void dijkstra(int s){
	fill(dst,dst+n+9,inf);
	dst[s]=0;
	q.push((Node){0,s});
	while(!q.empty()){
		int u=q.top().u; q.pop();
		if(ok[u]) continue;
		ok[u]=1;
		for(int i=0;i<to[u].size();i++){
			int v=to[u][i];
			if(!ok[v]&&dst[v]>dst[u]+w[u][i]){
				dst[v]=(dst[u]+w[u][i]);
				q.push((Node){dst[v],v});
			}
		}
	}
}
int main(){
	cin>>n>>m; s=1;
	while(m--){
		int a,b,c;
		cin>>a>>b>>c;
		to[a].push_back(b);
		w[a].push_back(c);
		to[b].push_back(a);
		w[b].push_back(c);
	}
	dijkstra(s);
	cout<<dst[n]<<endl;
	return 0;
}
// 不会dij+堆优化可以左转： https://www.luogu.org/problem/P4779
```

---

## 作者：Shikita (赞：1)

# 显而易见的一道单源最短路~~裸题~~
题目就没什么可以解释的了，毕竟都看得出来是最短路

但是这个题目有坑啊

好吧现在我不说
## 代码
```
//Shikita
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=2505,M=400005;
int head[N],ver[M],edge[M],Next[M],d[N],f[2505][2505];
bool v[N];
int n,m,tot;
struct node{int x,y;}ff;
queue<node>qq;
priority_queue< pair<int ,int> > q;
int read()
{
    int x=0,w=1;char ch=getchar();
    while(ch>'9'||ch<'0') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;
}
void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
}
void dijkstra()
{
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	d[1]=0;
	q.push(make_pair(0,1));
	while(q.size())
	{
		int x=q.top().second;
		q.pop();
		if(v[x]) continue;
		v[x]=1;
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i],z=edge[i];
			if(d[y]>d[x]+z)
			{
				d[y]=d[x]+z;
				q.push(make_pair(-d[y],y));
			}
		}
	} 
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),z=read();
		if(f[x][y]==0)
		{
			f[x][y]=z;
			ff.x=x,ff.y=y;
			qq.push(ff);
		}
		else f[x][y]=min(f[x][y],z);
	}
	while(!qq.empty())
	{
		ff=qq.front();qq.pop();
		add(ff.x,ff.y,f[ff.x][ff.y]);
		add(ff.y,ff.x,f[ff.x][ff.y]);
	}
	dijkstra();
	cout<<d[n]<<endl;
}
```
我们需要判重！！！！！！

因为数据的原因，如果不判重会WA第二个和第十个点

虽然我也不知道为什么

而且我的判重也非常丑陋。。。

好吧各位大佬就多多包含吧

---

## 作者：zdx1031705564 (赞：1)

我强烈怀疑这道题随机数据

要去重~~（驱虫）~~！

我老老实实写dijkstra

然后就A了四个点

我硬生生挑了~~一天（一分钟）~~

发现要驱虫

AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=2510;
int f[inf][inf],dis[inf];
int vis[inf];
int main()
{
	int n,i,j,m,x,y,k,minn;
	cin>>n>>m;
	memset(f,0x7f,sizeof(f));
	for(i=1;i<=m;i++)
	{	cin>>x>>y>>k;
	    if(k<f[x][y])
			f[x][y]=f[y][x]=k;}
	for(i=1;i<=n;i++)	
		dis[i]=f[1][i];
	dis[1]=0;
	for(i=1;i<=n;i++)
	{
		minn=0X7fffff;k=0;
		for(j=1;j<=n;j++)
		{	if(vis[j]==0&&minn>dis[j])
			{	minn=dis[j];k=j;}
		}
		vis[k]=1;if(k==0) break;
		for(j=1;j<=n;j++)
		{	if(dis[j]>dis[k]+f[k][j])
				dis[j]=dis[k]+f[k][j];}
	}
	cout<<dis[n]<<endl;
	return 0;
}
```

---

## 作者：Deny_小田 (赞：1)

代码楼上已经给出了，我就不再说了。

主要说说我的经历。

第一次：10分，Dijkstra开始的找最小距离的点时 min变量 忘记每次赋值了。加上：

···cpp

mn = inf;

···
就好了

第二~ 五次：40分，注意，可能有重边。楼上说似乎没必要，但结果是很有必要的哦！

即赋值语句需要变成：

···cpp

graph[x][y] = graph[y][x] = mnn(graph[x][y], z);         // mnn() 就是 min() 函数，为了避免与STL的函数冲突。

···
第六次：AC。

##一定要注意细节！！


---

## 作者：Drug__Lover (赞：1)

******裸的最短路******

- 非常适合练手

- 提供一个c++的dijkstra

- 最短路加邻接矩阵

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[2501][2501],vis[10001],dis[10001];
int main()
{
    memset(a,0x7f,sizeof(a));
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        if(z<a[x][y])          //判重，貌似此题不需要
        {
            a[x][y]=z;       //**无向图**
            a[y][x]=z;
        }
    }
    for(int i=1;i<=n;i++)
    {
        dis[i]=a[1][i];         //初始化
    }
    dis[1]=0;
    for(int i=1;i<=n;i++)   //开始dijkstra算法
    {
        int k=0;
        int minn=0x7fffff;
        for(int j=1;j<=n;j++)
        {
            if(vis[j]==0&&dis[j]<minn)
            {
                minn=dis[j];
                k=j;
            }
        }
        if(k==0) break;
        vis[k]=1;
        for(int j=1;j<=n;j++)
        {
            if(dis[k]+a[k][j]<dis[j]) dis[j]=dis[k]+a[k][j];
        }
    }
    cout<<dis[n];
    return 0;
}
```

---

## 作者：CZQ_King (赞：0)

具体思路是迭代。

每次优化两个站点之间的路。一直迭代直到不能再优化了，最后输出。

------------
我们拿
```
3 3
1 2 5
2 3 3
1 3 7
```
做例子（是不是有点太简单了
![](https://cdn.luogu.com.cn/upload/pic/60721.png)

照着代码来讲

我们只看$a$数组的前三个，现在目前是$\{0,\infty,\infty\}$

扫一遍，发现$1$到$2$之间可以优化，把$ok$置零，并且更新数组：$\{0,5,\infty\}$

然后$2$到$3$之间也有路，数组变成$\{0,5,8\}$，注意目前是$8$，因为$1$到$3$之间没有路，只能通过$1-2-3$的路线，所以就是$5+3=8$。

接下来看到$1$可以去$3$，时间是$7$，看一下$a$数组的第$3$个是$8$，所以$1$到$3$优化一下$\{0,5,7\}$

再扫一次，看一下有没有可以优化的，发现没有，最后输出$a[3]$，所以就是$7$。

------------

代码：
```cpp
#include<bits/stdc++.h>
int m,n,f[1000001],t[1000001],a[5005],y[1000001],ok;
//f是来自的停站点，t是到达的停站点，y是时间，a[i]代表1号站点到i号站点最短的路。
int main(){
    scanf("%d%d",&n,&m);
    for(int i=2;i<=5000;i++)a[i]=1e7;//初始化1到每个停站点间需要无穷大的时间（站点之间没有路）
    a[1]=0;//注意1可以去到本身不用时间
    for(int i=0;i<m;i++)scanf("%d%d%d",&f[i],&t[i],&y[i]);
    while(!ok){//一直迭代直到不能再优化
        ok=true;//假装不能再优化了
        for(int i=0;i<m;i++){//循环把所有站点扫一遍
            if(a[t[i]]>a[f[i]]+y[i]){a[t[i]]=a[f[i]]+y[i];ok=false;}//如果到最后的点还有更短的路就把ok置为0并且更新数组
            if(a[f[i]]>a[t[i]]+y[i]){a[f[i]]=a[t[i]]+y[i];ok=false;}//因为是无向的，所以返回来的路也得优化
        }
    }
    printf("%d",a[n]);//输出最短的时间
}
```

---

## 作者：xukuan (赞：0)

最短路

我用了dijkstra和spfa两种做法；

代码来源：《算法竞赛进阶指南》 李煜东著

dijkstra+priority_queue+链式前向星

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll ver[400010],edge[400010],head[400010],Next[400010],tot;
ll d[400010],v[400010],n,m;
priority_queue<pair<ll,ll> > q;

inline void addEdge(ll x,ll y,ll z){//链式前向星存边
    ver[++tot]=y;//指向的点
    edge[tot]=z;//边的长度
    Next[tot]=head[x];//下一条边
    head[x]=tot;//点指向的第一条边
}

inline void dijkstra(){
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[1]=0;
    q.push(make_pair(0,1));
    while(!q.empty()){//堆优化
        ll x=q.top().second; q.pop();
        if(v[x]) continue;
        v[x]=1;
        for(ll i=head[x]; i; i=Next[i]){//遍历每一条边
            ll y=ver[i],z=edge[i];
            if(d[y]>d[x]+z){
                d[y]=d[x]+z;
                q.push(make_pair(-d[y],y));
                //这里要注意一下，优先队列是大根堆，所以我们要推进负数
                //定义时可一这样写
                //priority_queue<pair<ll,ll>,vector<pair<ll,ll> >,greater<pair<ll,ll> > >
                //这样就是小根堆了
                //当然入队时直接写作q.push(make_pair(d[y],y);
            }
        }
    }
}

int main(){
    scanf("%lld %lld",&n,&m);
    while(m--){
        ll x,y,z;
        scanf("%lld %lld %lld",&x,&y,&z);
        addEdge(x,y,z);
        addEdge(y,x,z);
        //无向图存双向边
    }
    dijkstra();
    printf("%lld",d[n]);
    return 0;
}
```

spfa+链式前向星

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll n,m,s,t,d[400010],ver[400010],edge[400010],Next[400010],head[400010],tot;
bool v[400010];
queue<ll> q;

inline void addEdge(ll x,ll y,ll z){//同上
    ver[++tot]=y;
    edge[tot]=z;
    Next[tot]=head[x];
    head[x]=tot;
}

inline void spfa(){
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[1]=0; v[1]=1;
    q.push(1);
    while(!q.empty()){
        ll x=q.front(); q.pop();
        v[x]=0;
        for(ll i=head[x]; i; i=Next[i]){
            ll y=ver[i],z=edge[i];
            if(d[y]>d[x]+z){
                d[y]=d[x]+z;
                if(v[y]==0){//当这个点没有在队列中的时候，直接入队
                    q.push(y);
                    v[y]=1;
                }
            }
        }
    }
}

int main(){
    scanf("%lld %lld",&n,&m);
    while(m--){
        ll x,y,z;
        scanf("%lld %lld %lld",&x,&y,&z);
        addEdge(x,y,z);
        addEdge(y,x,z);
        //同上
    }
    spfa();
    printf("%lld",d[n]);
    return 0;
}
```

---

## 作者：ShineEternal (赞：0)

# 题目
## 题目描述

mzc家很有钱（开玩笑），他家有n个男家丁（做过前三弹的都知道）。但如此之多的男家丁吸引来了我们的体委（矮胖小伙），他要来与mzc争夺男家丁。

mzc很生气，决定与其决斗，但cat的体力确实有些不稳定，所以他需要你来帮他计算一下最短需要的时间。
## 输入输出格式
### 输入格式：

第一行有两个数n,m.n表示有n个停留站，m表示共有m条路。

之后m行，每行三个数$a_i$ $b_i$ $c_i$​，表示第$a_i$个停留站到第$b_i$​个停留站需要$c_i$的时间。（无向）

### 输出格式：

一行，输出1到n最短时间。

# 分析：
我不得不说，看了一大堆题目还以为是什么高深算法结果只是比模板题还模板的单源最短路。。。

切入正题，这道题看出是单源最短路后就可以用dijkstra或者spfa来解出了，考虑到没有负边权，可以用最简单也最省时的dijkstra来写（spfa我怕被卡，~~其实主要是dijkstra写熟了。。。~~）。下面就看代码。

# [代码](https://blog.csdn.net/kkkksc03/article/details/83151755)


---

## 作者：titititing (赞：0)

这道题不难，可以想到用dijkstra可轻松跑过

但是要注意三个地方：
	
1.每一条边是双向的

2.双向边要开双倍空间

3.其实这种稠密图用邻接矩阵会更优秀

### 再给出dijkstra的堆优化版本

我采用的是优先队列，pair的第一维为dis路径的相反数，这

样就不用写比较函数了


下面附上代码

```cpp
#include<bits/stdc++.h>
#define int long long 
#define N 500005
using namespace std;
struct Edge{
	int to,next,val;
}E[N];
int dis[N],n,m,x,y,z,tot,Head[N];
bool vis[N];
void addedge(int x,int y,int z){
	E[++tot]={y,Head[x],z};
	Head[x]=tot;
}
void SPFA(){
	priority_queue<pair<int,int> >q;//大根堆（优先队列），第二维为节点编号 
	for (int i=1;i<=N-2;i++) dis[i]=1023456789;//路径长度 
	memset(vis,false,sizeof(vis));//有没有访问过 
	dis[1]=0;
	q.push(make_pair(0,1));
	while (q.size()){
		int ver=q.top().second;
		q.pop();
		if (vis[ver]) continue;
		vis[ver]=true;
		for (int i=Head[ver];i;i=E[i].next){
			if (dis[E[i].to]>dis[ver]+E[i].val){//三角形法则 
				dis[E[i].to]=dis[ver]+E[i].val;
				q.push(make_pair(-dis[E[i].to],E[i].to));
			}
		} 
	}
}
main(){
	scanf("%lld%lld",&n,&m);
	for (int i=1;i<=m;i++){
		scanf("%lld%lld%lld",&x,&y,&z);
		addedge(x,y,z);//添加双向边
		addedge(y,x,z);
	}
	SPFA();
	printf("%lld\n",dis[n]);
	return 0;
}
```

---

## 作者：flipped (赞：0)

好吧。。。竟然没人写链式前向星的题解，那我来一发吧
链式前向星要快一点
而且没必要判重
```cpp
#include<bits/stdc++.h> //万能头文件
using namespace std;
const int N = 200100;
struct Node{ // 结构体
	int ne;
	int to;
	int w;
}e[N<<1];
int head[N],dis[N];
bool vis[N];
int n,m,x,y,val,cnt,ans;
void init() // 初始化函数
{
	memset(head,-1,sizeof(head));
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	cnt = 0;
}
void add(int u,int v,int val) // 加边
{
	e[cnt].to = v;
	e[cnt].w = val;
	e[cnt].ne = head[u];
	head[u] = cnt ++;
}
void SPFA()
{
	queue<int>q;
	q.push(1);
	dis[1] = 0;
	vis[1] = 1;
	while(!q.empty())
	{
		int k = q.front();
		q.pop();
		for(int i=head[k];~i;i=e[i].ne)
		{
			int t = e[i].to;
			if(dis[t] > dis[k] + e[i].w)
			{
				dis[t] = dis[k] + e[i].w;
				if(!vis[t])
				{
					q.push(t);
					vis[t] = 1;
				}
			} 
		}
		vis[k] = 0;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	init();
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&val);
		add(x,y,val);
		add(y,x,val);
	}
	SPFA();
	printf("%d\n",dis[n]);
	return 0;
}
```
对于不理解链式前向星的孩纸，这篇博客不错的

[深度理解链式前向星](https://blog.csdn.net/acdreamers/article/details/16902023)

---

## 作者：友利奈绪 (赞：0)

一道供图论初学者练习的模板题，可以用spfa+邻接表打过（貌似邻接矩阵也行？？），唯一要注意的就是数据范围。开小了会80分
直接上代码吧

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define inf 1e9; 
using namespace std;
const int maxn=10010;
const int maxm=1000010;
int head[maxn],nnext[maxm];
int to[maxm],length[maxm];
int tot;
int dis[maxn];
bool b[maxn];
int team[maxn];
void add(int x,int y,int l)
{
	tot++;
	nnext[tot]=head[x];
	head[x]=tot;
	to[tot]=y;
	length[tot]=l;
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}	
	
	for(int i=1;i<=n;i++)
	{
		dis[i]=inf;
	}dis[1]=0;
	
	int s=0,t=0;
	team[t]=1;
	t++;
	b[1]=true;
	
	while(s!=t)
	{
		int now=team[s];
		s++;
		s%=n;
		b[now]=false;
		for(int i=head[now];i;i=nnext[i])
		{
			int x=to[i];
			if(dis[x]>dis[now]+length[i])
			{
				dis[x]=dis[now]+length[i];
				if(b[x]==false)
				{
					team[t]=x;
					t++;
					t%=n;
					b[x]=true;
				}
			}
		}
	}
	
	printf("%d",dis[n]);
	return 0;
} 
```


---

## 作者：Dog_Two (赞：0)

~~Bellman\_ford这么好背为啥没人写这个呢~~

另外吐槽一波题面，该说的一点都不清楚\_(:зゝ∠)\_

各种最短路算法的核心都在于一个基本事实：

有一条边：存在 **dis[e.u]+e.w<dis[e.v]** 这样的一个关系，然后我们更新边的长度——我们称这个操作叫做松弛

最坏的情况下，我们需要松弛nm次，这也正是朴素bellman—ford的复杂度。

但事实上我们只需要一个bool记录“是否进行松弛操作”就可以排除冗余无效的松弛操作了——发现没有进行松弛操作后break；

###代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxm=2500*2500+10,maxn=2500+10;
//按照稠密图举边，不会超内存 
int u[maxm],v[maxm],w[maxm];
int dis[maxn];
int n,m;
int main(){
    memset(dis,0x3f,sizeof(dis));
    //初始化路长为无穷大 
    cin>>n>>m;
    for(int i=1;i<=m;i++)
        scanf("%d%d%d",&u[i],&v[i],&w[i]);
    int k=n-1;
    dis[1]=0;
    //起点->起点的距离为0 
    while(k--){
        bool if_los=false;
        for(int i=1;i<=m;i++){
            int &from=u[i],&to=v[i],&cost=w[i];
            if(dis[to]>dis[from]+cost){
                dis[to]=dis[from]+cost;
                if_los=true;
            }
            if(dis[from]>dis[to]+cost){
                dis[from]=dis[to]+cost;
                if_los=true;
            }
        }
        if(!if_los) break;    
        //如果没有进行松弛操作，那么最短路已经求解完毕    
    }
    cout<<dis[n];
    return 0;
}
```

---

## 作者：香风智乃 (赞：0)

Dijkstra+堆优化

使用动态数组存储边及编号

编写难度比邻接矩阵稍大但是跑的比邻接矩阵快

（附上读入优化：目前收集到最快的读入优化）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#include<cctype>
using namespace std;
struct edge{
    int from,to,dist;
};
struct data{
    int d,u;   //到达 编号为u的点 的最短路程为d
    bool operator < (const data &tmp) const{
        return d>tmp.d;
    }    //自定义堆
};
int d[2502];
vector <edge> ed;
vector <int> g[2502];    //存边以及编号
priority_queue <data> h;
inline int readint()  //读入优化
{
    char c=getchar(); int x=0;
    while(!isdigit(c)) c=getchar();
    while(isdigit(c))
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}
int main()
{
    memset(d,127/3,sizeof(d));   //初始化为inf 小心溢出
    int n,m,i,j,q1,q2,q3,u=-1;
    n=readint(); m=readint();
    for(i=1;i<=m;i++)
    {
        q1=readint(); q2=readint(); q3=readint();
        ed.push_back((edge){q1,q2,q3});
        g[q1].push_back(++u);
        ed.push_back((edge){q2,q1,q3});
        g[q2].push_back(++u);
    } //存边（无向图存两次）
    d[1]=0;
    h.push((data){0,1});
    while(!h.empty())
    {
        data x=h.top(); h.pop();
        int u=x.u,len=g[u].size();
        if(x.d!=d[u]) continue;
        for(i=0;i<len;i++)
        {
            edge &e=ed[g[u][i]];
            if(d[u]+e.dist<d[e.to])
            {
                d[e.to]=d[u]+e.dist;
                h.push((data){d[e.to],e.to});
            }
        }
    }
    printf("%d",d[n]);
    return 0;
}
```

---

## 作者：ljc20020730 (赞：0)

【P党福利时间】（第26波) ~~expected~~

各位大神用SPFA打出一波快速的SPFA的程序

下面有dijkstra+邻接矩阵 拿到AC

我就想说，这道题就是裸的dijkstra啊！！！

```cpp
const longlong=214748364;
      maxn=5000;
var i,j,n,m,s,x,y,z:longint;
    d:array[1..maxn]of longint;
    g:array[1..maxn,1..maxn]of longint;
function min(a,b:longint):longint;//就是判断最小值保证数据大时还能得到最优解答
begin
 if a>b then exit(b) else exit(a);
end;
procedure dijkstra(v0:longint);//模板dijkstra
var i,j,k,minn:longint;
    u:array[1..maxn]of boolean;
begin
 fillchar(u,sizeof(u),false);
 for i:=1 to n do d[i]:=g[v0,i];
 d[v0]:=0;
 u[v0]:=true;
 for i:=1 to n do begin
  minn:=longlong; k:=0;
  for j:=1 to n do
   if (not u[j])and(d[j]<minn) then begin
    minn:=d[j]; k:=j;
   end;
  if k=0 then break;
  u[k]:=true;
  for j:=1 to n do
   if (not u[j])and(g[k,j]+d[k]<d[j])then
      d[j]:=g[k,j]+d[k];
 end;
end;
begin
 readln(n,m);
 for i:=1 to n do
  for j:=1 to n do
   if i<>j then g[i,j]:=longlong  div 3//赋初值，如果不div 3 可能会爆~~
   else g[i,j]:=0;
 for i:=1 to m do begin
  readln(x,y,z);
  g[x,y]:=min(g[x,y],z);
  g[y,x]:=g[x,y];//这里是双向图~~否则呵呵呵~~
 end;
 dijkstra(1);
 writeln(d[n]);
end.
```
##坑点全解析
1、空间2500^2=6250000 这么多个longint 就是 25,000,000 B= 23MB 没有炸空间

2、时间O(2500^2)时间小于1s

3、图是**无向图**！！！否则爆30！！！

#所以要仔细！！！


---

## 作者：doby (赞：0)

这里竟然没有SPFA……

SPFA队开的足够大就可以了……

但是……板子还是一样的……

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,x,y,z,op,head[50009],next[50009],dis[50009],len[50009],v[50009],l,r,team[50009],pd[50009],u,v1,e,out,fh;
char cc;
int read()//读入优化
{
    out=0,fh=1,cc=getchar();
    if(cc=='-'){fh=-1;}
    while(cc>'9'||cc<'0'){cc=getchar();}
    while(cc>='0'&&cc<='9')
    {
        out=out*10+cc-'0',
        cc=getchar();
    }
    return out*fh;
}
void lt(int x,int y,int z)//单向联通
{
    op++,v[op]=y;
    next[op]=head[x],head[x]=op,len[op]=z;
    return;
}
void SPFA(int s)//SPFA……
{
    for(int i=1;i<=50000;i++){dis[i]=23333333;}
    memset(team,0,sizeof(team));
    memset(pd,0,sizeof(pd));
    l=0,r=1,team[1]=s,pd[s]=1,dis[s]=0;
    while(l!=r)
    {
        l=(l+1)%50000,u=team[l],pd[u]=0,e=head[u];
        while(e!=0)
        {
            v1=v[e];
            if(dis[v1]>dis[u]+len[e])
            {
                dis[v1]=dis[u]+len[e];
                if(!pd[v1])
                {
                    r=(r+1)%50000,
                    team[r]=v1,
                    pd[v1]=1;
                }
            }
            e=next[e];
        }
    }
    return;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        x=read(),y=read(),z=read();
        lt(x,y,z);lt(y,x,z);//无向图
    }
    SPFA(1);//从1开始跑SPFA
    printf("%d",dis[n]);
    return 0;
}
```

---

## 作者：pupuvovovovovo (赞：0)

题意：求点1至点n的最短路。

最短路模板。

数据范围还很小。

裸的Dijkstra+邻接矩阵就过了。

附pascal代码：

```cpp
var map:array [1..2500,1..2500] of longint;//邻接矩阵
f:array [1..2500] of longint;
b:array [1..2500] of boolean;
min,minat,x,y,z,n,m,i,j:longint;
begin
  read(n,m);
  fillchar(map,sizeof(map),127);
  for i:=1 to m do
  begin
    read(x,y,z);
    if map[x,y]>z then
    begin
      map[x,y]:=z;
      map[y,x]:=z;
    end;
  end;
  fillchar(f,sizeof(f),127);
  f[1]:=0;
  for i:=1 to n do
  begin
    min:=maxlongint;
    for j:=1 to n do
    if (f[j]<min) and not(b[j]) then//未到过的点中最小的。
    begin
      min:=f[j];
      minat:=j;
    end;
    b[minat]:=true;//标记
    for j:=1 to n do
    if f[minat]+map[minat,j]<f[j] then f[j]:=f[minat]+map[minat,j];//松弛
  end;
  write(f[n]);
end.
```

---


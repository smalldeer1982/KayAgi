# yyy2015c01 的 U 盘

## 题目背景

在 2020 年的某一天，我们的 yyy2015c01 买了个高端 U 盘。


## 题目描述

你找 yyy2015c01 借到了这个高端的 U 盘，拷贝一些重要资料，但是你发现这个 U 盘有一些问题：

1. 这个 U 盘的传输接口很小，只能传输大小不超过 $L$ 的文件。
2. 这个 U 盘容量很小，一共只能装不超过 $S$ 的文件。

但是你要备份的资料却有很多，你只能备份其中的一部分。

为了选择要备份哪些文件，你给所有文件设置了一个价值 $V_i$，你希望备份的文件总价值不小于 $p$。

但是很快你发现这是不可能的，因为 yyy2015c01 的传输接口太小了，你只有花钱买一个更大的接口（更大的接口意味着可以传输更大的文件，但是购买它会花费更多的钱）。

注意：你的文件不能被分割（你只能把一个文件整个的传输进去，并储存在U盘中）,

你放在 U 盘中文件的总大小不能超过 U 盘容量。

现在问题来了：你想知道，在满足 U 盘中文件价值之和**不小于** $p$ 时，最小需要多大的接口。

## 说明/提示

$1 \le n, W_i, S \le 10^3$，$1 \leq V_i \leq 10^6$，$1 \leq p \leq 10^9$。

数据较小，请勿乱搞。

样例解释 $1$：买一个大小为 $2$ 接口，把物品 $1$ 、$2$ 放进$\text{U}$盘。

样例解释 $2$：买一个大小为 $500$ 的接口。

样例解释 $3$：本来可以买大小为 $2$ 的接口，可是 U 盘容量放不下足够的文件。

如果数据出现疏漏，请联系出题人 [a710128](https://www.luogu.com.cn/user/2573)

向本题主人公 yyy2015c01 同学致敬！

## 样例 #1

### 输入

```
3 3 5
2 2
1 2
3 2```

### 输出

```
2```

## 样例 #2

### 输入

```
2 3 505
1 2
500 1```

### 输出

```
500```

## 样例 #3

### 输入

```
3 3 2
2 2
1 2
3 2```

### 输出

```
No Solution!```

## 样例 #4

### 输入

```
4 5 6
5 1
5 2
5 3
1 1```

### 输出

```
No Solution!```

# 题解

## 作者：cs18 (赞：96)

//可能题目比较水，不需要二分来优化，直接01背包+排序就可以过了

                
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,p,s;
int dp[1005];//dp[i]表示装i体积的东西能够得到的价值 
struct node
{
    int v,w;
}a[1005];//在这里定义一个结构体，因为后面要用到排序 
int cmp(node a,node b)
{
    return a.v<b.v;//简单的排序 
 } 
int main()
{
    scanf("%d%d%d",&n,&p,&s);//输入对应的文件总数，希望最小价值p和硬盘大小s 
    for(int i=1;i<=n;i++)
    scanf("%d%d",&a[i].v,&a[i].w);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
        for(int j=s;j>=a[i].v;j--)//01背包的模板 
        {
            dp[j]=max(dp[j],dp[j-a[i].v]+a[i].w);
            if(dp[s]>=p)//如果此时装满的情况下得到的价值已经超过了所需，
                        //那么当前物品的体积就是满足条件的最小体积（因为之前已经排过序了） 
            {
                printf("%d",a[i].v);//直接输出，结束程序 
                return 0;
            }
        }
    printf("No Solution!");    //输出不满足条件的情况 
}
```

---

## 作者：MuelsyseU (赞：86)

## 1. 前言

立志作超长题解的本蒟蒻，自从上次水完[书的复制](https://www.luogu.com.cn/blog/MCCF/solution-p1281)300行，并发现竟排在第$5$页后，便再没看到打算写题解的二分题。

但这道[P2370](https://www.luogu.com.cn/problem/P2370)，不得不说是一道好题。

虽说据说竟无需二分（震惊！贪心时间竟仅二分的十分之一），但毕竟是为数不多的将$01$背包与二分结合的普及题。

在此小议百行，聊以复习罢。

## 2. $01$背包简述

此题大致意思为：

> 现有U盘一个，需在其中备份$N$个文件。每个文件有大小$W_i$及价值$V_i$，且备份的文件总价值不得小于$M$。U盘有总容量限制$S$，同时其内部的任何文件大小不得超过一个值$L$（此值可变）。需求出是否能备份足够价值的文件，如果能，至少需要多大的$L$。

上述内容可能比较抽象，同时本题数据较多，建议还是回题目中仔细分析一下。

首先，我们可以发现，如果去除求$L$的要求，该题将是一个纯粹的$01$背包问题。只需根据$01$背包求出最大价值与$M$比较即可。

------------

_以下简述背包问题的思想，$dalao$可跳过_

貌似众$dalao$均用了一维数组，这边还是先开二维，到时再压缩作一维。

设$f[i][j]$表示对于前$i$个文件在容量为$j$时，最终可得到的的最大价值。

如何推出$f[i][j]$呢？考虑对第$i$个文件，可取或不取。

若不取，则$f[i][j]$与$f[i-1][j]$完全相同；

若取，则至少需$w[i]$的空间，至多剩余$j-w[i]$的空间，以换取$v[i]$的价值。由此可知，此时价值可由$f[i-1][j-w[i]]+v[i]$推出。

则最终状态转移方程为：$f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i])$

最后的最大价值即为$f[n][s]$。

------------

然后我们一看数组，发现$f$数组分别以文件编号和可用空间大小作为下标，于是有：

`int f[1000][1000000];`

##### 注：当然，此处还需预留空间，数组实际还要更大。

显然爆空间。于是乎，我们需要考虑压缩到一维数组，即`f[1000000]`。

------------

由上述内容可以看出，在计算第$i$个文件时，仅需使用$f[i-1][]$的数据，其前的值可以舍弃——最终可直接舍弃$f[n][]$之前的所有值。

这样看来，不妨直接使用方程$f[j]=max(f[j],f[j-w[i]]+v[i])$。

仔细观察方程，可发现每次$i$循环都更新了$f[]$中的值，这样，在执行完第$i-1$层循环后，$f$数组就保存了第$i-1$层的所有数据。

其后第$i$层循环，实际上也就等同于使用$max(f[i-1][j],f[i-1][j-w[i]]+v[i]))$来更新$f[i][j]$。

这种办法的妙处在于，每次更新完$f$数组，$f$数组所表示的层数就不同了，但仍能保证状态转移的正确（其实比二维更正确，因为少了一个状态转移的判断）。

最终，就能求出总共$n$个文件的最大价值。可能稍有些难理解，但认真思考就能明白其中的道理了。

------------

关于$DP$部分代码的实现，其实到此已没什么难点。

但要注意，为了防止一个物品被重复选用，内层$j$必须倒序遍历，这样使用的是之前的数据，而不会使用到新的数据（如果是完全背包本就可以无限使用则直接改为正序即可）。

于是我们现在已经可以求出是否有解的部分分：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int n,m,s;
int a[1005],b[1005];
int f[1000010];

int dp() {
	for(int j=1;j<=s;j++)			//初始化 
		f[j]=0;
	for(int i=1;i<=n;i++){
		for(int j=s;j>=a[i];j--){	//注意倒序 
			f[j]=max(f[j],f[j-a[i]]+b[i]);
			//状态转移 
		}
	}
	return f[s];					//最终结果即f[s] 
} 

int main() {
	cin>>n>>m>>s;
	for(int i=1;i<=n;i++) {
		cin>>a[i]>>b[i];
	}
	if(dp()<m) cout<<"No Solution!";//无解 
	return 0;
}
```

## 3. 二分基本思想

然而，题目中还有一个至关重要的因素：$L$值的确定。

由于$L$值是文件体积的最大值，我们要让它尽量小。“最大值最小”，嗯，典型的二分答案思想。

------------

_简述二分答案的基本思想， $dalao$也可跳过_ 

二分答案的理解疑似是来自二分查找 ~~（并不）~~，二分查找的理解疑似是来自“猜数游戏”。

`1 2 4 10 29 30 31 65`

假设预选一个数作为答案，让玩家每次对其中一个数进行询问。

每个询问可能回答：该数比答案大、比答案小或猜中答案。

如果该数即是答案则游戏结束。

那么，希望用最少的询问次数猜出答案，就可以用二分查找法。

由于数列**单调上升**，试想先取一中间数如$10$，如果回答“太小”，则“嫌疑”范围肯定是$10-65$（方便起见这里把$10$考虑进去）这一段$4$个数；如果“太大”则嫌疑范围会取到$1-10$。

可以再在新的嫌疑范围中取该范围的中间数来询问，比如询问$10-65$中的$30$；之后再在新的范围中取中间数……可以预见，最多询问$3$次（从实际编码角度可能理解为$4$次）就能确定这个答案。

------------

简单讲讲代码实现。二分，顾名思义要将数据分成两类，比如小于等于$X$和大于$X$两类。分类要求不重不漏且满足单调。

定义$low$和$high$表示“嫌疑范围”的上下界，由于可知当“嫌疑范围”确定到一点时即结束，所以循环条件为$low+1<high$。（技巧：初始化$low=0,high=n+1$）

结束时，可发现数据已被分成了$[a[0],a[low]]$和$[a[high],a[n]]$两类。这时就可据$low,high$找到“最接近$X$的、次接近$X$的、大于$X$且最接近$X$的”值等。

其实做这道题应该对二分查找有较深理解的，所以这里只是简述一下，接下来不再讲。

------------

二分答案基于二分原理，即用二分的思想快速“猜出”最合适的答案。当且仅当：

1. 题目难以用直接数学方法解出；
2. 题目用逐步验证的方法相对容易解出，但暴力枚举又容易超时；
3. 答案有明显的范围，且范围时间上允许二分答案（时间复杂度一般近似$O[log_2(right-left+1)]$）；
4. 问题的答案是**单调**的（反复强调的重点），即当验证答案$X$满足条件，则$[n,right]$或$[left,n]$也一定满足；不满足时，也可表明$[left,n]$或$[n,right]$也一定不满足。

满足以上条件时，二分答案就可以使用且可能显著优化时间复杂度。

注意一点，二分答案实际上仍然属于穷举的优化，其基本思路也是需要一个个查找验证，所以$check$验证函数的编写是二分答案的核心。比较容易地是采用贪心法或动规验证。

由于仍然是需要分界，因此分成可行与不可行两类。比以下模板是最后找到的$low$就是可行的最大值。

------------

接下来有个无需$ans$的蒟蒻模版，也就是将一般$low=mid+1,high=mid-1$改成直接赋值为$mid$。

实际上可发现$mid$本身是不需再确定的，所以此模板把时间复杂度略微抬高但较容易理解。

```cpp
int find(int low,int high) {
	int mid;
	while(low+1<high){			//找到可行与不可行的分界
		mid=low+(high-low)/2;	//此处是(low+high)/2的防爆优化
		if(check(mid))			//check函数检查可行性
			low=mid;			//当可行时[left,mid]也可行
		else
			high=mid;			//当不可行时[mid,right]也不可行
	} 
	return low;					//由于low表示可行，返回low
}
```
关于二分答案，最适合练手的个人认为是[木材加工](https://www.luogu.com.cn/problem/P2440)。

## 4. 二分解题思路

以上已唠叨近两百行，现在总算开始讲解题思路 ~~（鼓掌！）~~。

首先明确我们要二分**查找什么**？顾名思义，要二分的一般是“答案”。

所以，我们应当枚举这个$L$值，也就是接口的大小。

现在倒回去看二分答案的四个要素。这个值肯定很难用数学方式或暴力枚举来解$(1,2$-$2)$，并且这个最小值也存在范围$(3)$：从**所有文件大小的最小值**到**所有文件大小的最大值**。

这个范围也容易理解。首先根据数据，所需价值至少为$1$，接口大小至少为“所有文件大小的最小值”才能通过至少一个文件；

而由于接口大小越小越好，所以只要达到“所有文件大小的最大值”，即可保证可通过所有文件，自然不需要更大。

粗略计算可发现这个范围用二分答案是完全允许的。（大约只需不到十次验证）

现在只剩两个要素$(4,2$-$1)$，也就是**单调性**和**如何逐步验证**。

------------

先考虑单调性。设想我们已经验证，接口大小的最小值小于等于$30$，那么是不是肯定小于等于$31$？

再假设已知这个最小值肯定大于$11$页，那么是不是肯定也会大于$10$页？

换言之，当某个答案可行时，比它大的答案也肯定可行，无需再验证，上界就可以减小；同理，当某个答案不可行，比它小的答案也肯定不可行，下界就要上移。

所以单调性是完全满足的。

------------

最后考虑，我们如何验证答案是否可行？如前所述，由于我们**假想已知**这个“接口大小的最小值”，只需要求出对应所需的最大价值，然后判断是否足够。

发现了什么？刚才的$DP$恰好可以用于求出这个最大价值。

只需在进行内层$j$循环前，增加一个判定，看第$i$个文件大小是否超过接口大小，如果超过即跳过这个文件。

此处有一个小细节。由于判断之前是否有解时，是没有接口大小的限制的，所以增加判定，当传入的这个$mid$是$-1$时，不限制大小。

------------

$dp$函数代码如下：

```cpp
int dp(int k) {
	for(int j=1;j<=s;j++)			//初始化
		f[j]=0;
	for(int i=1;i<=n;i++){
		if(k!=-1&&a[i]>k) continue;	//大小限制的特判
		for(int j=s;j>=a[i];j--){	//注意倒序
			f[j]=max(f[j],f[j-a[i]]+b[i]);
		}
	}
	return f[s];
} 
```
教练说$find$函数模版尽量不要动，那就象征性写个$check$：

```cpp
bool check(int s) {
	return dp(s)>=m;	//是否可行
}
```
不过，由上所述，可知在满足条件时移动的是**上界**，反之移动**下界**。所以，还要对$70$行之前的$find$函数模版略微调整：

```cpp
int find(int low,int high) {
	int mid;
	while(low+1<high){
		mid=low+(high-low)/2;
		if(check(mid))	//检查可行性
			high=mid;	//上界下移
		else
			low=mid;	//否则下界上移
	} 
	return high;		//high表示可行最小值
}
```
至此，我们已理出了二分答案的大部分框架。

## 5. 代码实现

教练果然是万能的，这就是为什么这一段爆了第$3$个点的坑：

```cpp
for(int i=1;i<=n;i++) {
	cin>>a[i]>>b[i];
	low=min(low,a[i]);
	high=max(high,a[i]);
}
if(dp(-1)<m) cout<<"No Solution!";
else cout<<find(low,high);
```
首先，我们发现$find$返回的是$high$，但是假设有极端情况，即只需要备份大小最小的文件即可达到要求时，返回的值本应当是传入的$low$。

可是，由于$low$和$high$不能重合，最后的结果最小只能是$low+1$。这就产生了问题。

只需改成`cout<<find(low-1,high)`即可$AC$。

$AC$代码如下：

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

int n,m,s;
int a[1005],b[1005];
int f[1000010];

int dp(int k) {
	for(int j=1;j<=s;j++)			//由于重复使用，必须初始化
		f[j]=0;
	for(int i=1;i<=n;i++){
		if(k!=-1&&a[i]>k) continue;	//大小特判
		for(int j=s;j>=a[i];j--){	//注意倒序
			f[j]=max(f[j],f[j-a[i]]+b[i]);
		}
	}
	return f[s];
} 

bool check(int s) {
	return dp(s)>=m;
}

int find(int low,int high) {
	int mid;
	while(low+1<high){
		mid=low+(high-low)/2;
		if(check(mid))
			high=mid;
		else
			low=mid;
	} 
	return high;	//注意是high表示可行
}

int main() {
	int low=1e7,high=0;
	cin>>n>>m>>s;
	for(int i=1;i<=n;i++) {
		cin>>a[i]>>b[i];
		low=min(low,a[i]);				//下界即最小值
		high=max(high,a[i]);			//上界是最大值
	}
	if(dp(-1)<m) cout<<"No Solution!";	//无解
	else cout<<find(low-1,high);		//注意传入low-1
	return 0;
}
```

## 6. 总结

二分与$DP$恰好是本蒟蒻最近大肆~~被~~虐之算法，所以一看到此题便觉神清气爽。

似乎思路中规中矩，不过有些小优化，但个人感觉讲的还是蛮清晰的。

这是第$335$行。感谢阅读到这里的诸位。

以上。

---

## 作者：amstar (赞：30)

挺有意思的一道题，用二分+背包，二分枚举最小的端口，dp验证价值能否大于最小价值。

解释下代码：f[i]大小为i时价值最大，v大小，w价值 ，n，m，s，分别是文件个数，最小价值，U盘容量。




```cpp
 #include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN = 1010;
int f[MAXN],v[MAXN],w[MAXN];
int n,m,s;
bool dp(int x)
{
    memset(f,0,sizeof(f));
    for (int i=1; i<=n; ++i)
    {
        if (v[i]>x) continue ; 
        for (int j=s; j>=v[i]; --j)
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    if (f[s]<m) return false ;
    return true ;
}
int main()
{
    scanf("%d%d%d",&n,&m,&s);
    for (int i=1; i<=n; ++i)
    {
        scanf("%d%d",&v[i],&w[i]);
    }
    int l = 0 , r = s, ans = -1;
    while (l<=r)
    {
        int mid = (l+r)>>1;
        if (dp(mid))
        {
            ans = mid;
            r = mid-1;
        }
        else l = mid+1;
    }
    if (ans==-1) printf("No Solution!");
    else printf("%d",ans);
    return 0;    
}

```

---

## 作者：万弘 (赞：7)

评分不太准,应该是到绿题

先考虑无解的情况:

从n件物品中选m件,求最大价值,自然是01背包,再看一下是否>p即可:
```cpp
bool no()//返回真表示无解
{
	for(ll i=1;i<=m;++i)f[i]=0;//这里的m就是硬盘大小s
	for(ll i=1;i<=n;++i)
		for(ll j=m;j>=v[i];--j)
			f[j]=max(f[j],f[j-v[i]]+w[i]);
	return f[m]<p;
}
```
再考虑一般情况:

>  在满足U盘中文件价值之和不小于p时,最小需要多大的接口

就是二分答案了

```cpp
bool check(ll k)//接口大小为k是否可行
{
	for(ll i=1;i<=m;++i)f[i]=0;//要多次01背包,必须清0
	for(ll i=1;i<=n;++i)
	{
		if(v[i]>k)continue;//大于接口大小,不能选
		for(ll j=m;j>=v[i];--j)
			f[j]=max(f[j],f[j-v[i]]+w[i]);
	}
	return f[m]>=p;
}

```
附赠二分答案模板:
```cpp
ll l=1,r=m,mid;
while(l<r)
{
	mid=(l+r)>>1;
	if(check(mid))r=mid;//有时是l=mid,因题而异
	else l=mid+1;//有时是r=mid-1,因题而异
}
	printf("%lld",r);
```

---

## 作者：欧鹰 (赞：5)

闲着无聊，蒟蒻来打第二篇题解。第一篇题解刚刚过，
我不会宣传的。~~[传染病控制](https://www.luogu.org/blog/wswswzc/p1041-zhuan-ran-bing-kong-zhi-ti-xie)~~



------------

[题面](https://www.luogu.org/problem/P2370)

首先，看题面，我们会找到，几个关键字：

 _1，只能装不超过S的文件；_

 _2， Wi, Vi 表示 第i个文件的大小，和价值。_

之后我们就会想到了背包。

但你之后又会发现：只能传输大小不超过L的文件。

之后我们就会打出一个代码
```
//u[i].v是大小，u[i].w是价值。
for(int i=1;i<=n;i++)
{
	if(u[i].v>k)continue;
		
	for(itn j=s;j>=u[i].v;j--)
	{
		f[j]=max(f[j],f[j-u[i].v]+u[i].w);
	}	
}//标准背包dp
```

但看到问题：**在满足U盘中文件价值之和不小于 p时，最小需要多大的接口。**

然后我们就可以想到枚举接口，同时接口越大，入选的文件越多，就越有可能产生大于p的价值。这就是单调性，然后我们就可以进行二分；

二分代码:

```
       //l=1，r是最大体积。
	while(l<r)
	{
		int mid=(l+r)/2;
		
		if(judge(mid)>=p)//judge函数判断是否可以到达价值p；可以既选左范围，反之，逆然。
		{
			ans=mid;//记录答案
			
			r=mid;
		}
		
		else l=mid+1;
	
	}
```

然后，我们再看题会发现有无解情况,之后判断一下，

```cpp
        if(judge(r)<p)//r即最大体积。如果当所有都可以使用，但仍不可以到达结果，即输出无解。
	{
		cout<<"No Solution!";
		return 0;
	}
	
	if(judge(r)>=p&&judge(r-1)<p)//闲着无聊的判断。
	{
		cout<<r;
		return 0;
	}
```


------------
最后代码时间：```

```cpp
#include<bits/stdc++.h>

#define itn int

using namespace std;

int n,p,s,l=1,r,ans,f[10050];

struct node{
	int w,v;
}u[10050];

int judge(int k)
{
	memset(f,0,sizeof(f));
	
	for(int i=1;i<=n;i++)
	{
		
		if(u[i].v>k)continue;
		
		for(itn j=s;j>=u[i].v;j--)
		{
			f[j]=max(f[j],f[j-u[i].v]+u[i].w);
		}
		
	}
	
	//cout<<f[s]<<endl;
	
	return f[s];
}

int main()
{
	
	cin>>n>>p>>s;
	
	for(int i=1;i<=n;i++)
	{
		cin>>u[i].v>>u[i].w;
		
		r=max(r,u[i].v);
	}
	
//	sort(u+1,u+1+n,cmp);
	
	if(judge(r)<p)
	{
		cout<<"No Solution!";
		return 0;
	}
	
	if(judge(r)>=p&&judge(r-1)<p)
	{
		cout<<r;
		return 0;
	}
	
	while(l<r)
	{
		int mid=(l+r)/2;
		
		if(judge(mid)>=p)
		{
			ans=mid;
			
			r=mid;
			
		
		}
		
		else l=mid+1;
	
	}
	
		cout<<ans;
	
	return 0;
}
```




---

## 作者：Y_B_Y (赞：4)

### 思路：

- #### 二分列举接口大小L（如果一种大小可以满足那么比它大也都可以满足所以先更新答案为它的大小然后往小的找有没有可以的，如果不可以满足那么比它小也都不可以满足，所以往比它大的找，重复这个操作，具体看代码）
- #### 再用背包计算是否满足最低要求（就是01背包（最好压维，不压更麻烦）加上判断是否可以传输过去，求出最大价值）

### 注意每次计算要先还原背包用的数组

二分的最小值这里为1，最大值为最大的文件大小，因为超过这个大小每一个文件都可以传输进去没有必要更大了

#### 二分的详细解释：
如图

![](https://cdn.luogu.com.cn/upload/pic/66119.png)


上代码：

```
#include<bits/stdc++.h>
using namespace std;
int maxn,w[100010],v[100010],p,n,s,ans=12345678;
int f[1001];//压维，不压反而更麻烦
bool check(int a)
{
	memset(f,0,sizeof(f));//这里一定要还原
	for(int i=1;i<=n;i++)
	{
		if(w[i]<=a)
		for(int j=s;j>=w[i];j--)
		{
			f[j]=max(f[j],f[j-w[i]]+v[i]);
		}
	}
	if(f[s]>=p) return 1;//可以
	else return 0;//不可以
}
int main()
{
	cin>>n>>p>>s;
	for(int i=1;i<=n;i++) cin>>w[i]>>v[i],maxn=max(maxn,w[i]);//记录文件大小的最大值
	int l=1,r=maxn;//最小值为1，最大值为maxn
	while(l<=r)
	{
		int mid=(l+r)/2;//取中间值，二分
		if(check(mid)) ans=min(ans,mid),r=mid-1;//可以，更新答案然后往小的找
		else l=mid+1;//不可以，往大的找
	}
    if(ans!=12345678) cout<<ans;//如果等于12345678就表示从来没有更新过答案，没有可以的
    else cout<<"No Solution!";//等于，输出不行
    return 0;
}
```


---

## 作者：固执 (赞：4)

**思想：贪心+背包**

~~这是我们编程班里有个人用排序过背包题给予我的灵感~~

看到大佬都用什么二分，我太菜了

首先，可以从题意看出，文件肯定是一份一份的，于是先确定是01背包

**01（所有）背包公式：dp[j]=max(dp[j],dp[j-v[i]]+w[i])（v[i]为当前第i件物品的重量，w[i]为当前第i件物品的价值）**

再由题意可知，要求总价值不小于p且最优，所以我们考虑贪心思想
，从小到大排，这样就可以直接在装背包这个循环里直接完成输出了

最后，如果都没有满足>=p的情况，输出无解

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,p,t,v[100001],w[100001],dp[100001];// n, p, t 分别表示 文件总数， 希望最小价值p，硬盘大小
	cin>>n>>p>>t; //输入文件总数，希望最小价值及硬盘大小 
	for(int i=1;i<=n;i++) cin>>v[i]>>w[i]; //输入第i个文件的大小及价值 
	for(int i=1;i<n;i++) { 
	for(int j=i+1;j<=n;j++) {
		if(v[i]>v[j]) //排序，判断大小，然后两个一起换，小的放前面，大的放后 
		{
			swap(v[i],v[j]);
			swap(w[i],w[j]);
		}
	}
	}
	//全题核心 
	for(int i=1;i<=n;i++) {//背包 
		for(int j=t;j>=v[i];j--) {
			dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//方程 
			if(dp[t]>=p) { //如果当前的期望值已经大于p了，那么直接输出（前面排过序了，所以不需要考虑后面可能还会有更优的情况） 
				cout<<v[i];//输出当前价值，结束 
				return 0;
			}
		}
	}
	cout<<"No Solution!";//如果所有的期望值都没有超过最小期望值，那么输出无解 
	return 0;
}
```


---

## 作者：TsReaper (赞：4)

题意简述：在备份的文件总价值不小于 p的情况下，求文件最大体积的最小值。

看到“让最大值最小”这样的题目，第一个想到的算法肯定是二分啦~

这一题就是一道二分+背包问题，先将所有文件按照体积从小到大排序，之后二分出体积最大的文件，用该文件以及之前的所有文件进行一次背包，看看能否满足最大总价值不小于 p即可。


---

## 作者：lzpclxf (赞：3)

### 废话：
~~二分啊， 难搞啊~~

~~鬼知道我调了多久~~

### 正文：

其实发题解主要就是翻了翻题解发现大家（没有排序的）用二分的时候r直接赋成一个很大的值或者是s， 其实这样会浪费很多的时间做不必要的运算

所以来补充一波小小优化
```cpp
	for(int i = 1; i <= n; i++) {
		scanf("%d%d", &w[i], &v[i]);
		if(w[i] > r) r = w[i];
		if(w[i] < l) l = w[i];
	}
```
这样我们在输入的时候就能顺便处理出l和r的值， 考虑我们二分的是一个接口的大小， 所以我们的答案肯定是在最大的接口和最小的接口之间啊， 所以这样做是可行的， 而且会让我们的程序跑的更快一些。
```cpp
mid = (l + r) >> 1;
```
位运算是比除法要快的！

其他的就是注意二分的边界问题可以用一个ans来保存最优解

这里推荐一篇很好的日报， [2018洛谷日报七月第13期](https://baijiahao.baidu.com/s?id=1607027944170585153)真的讲的很透彻的， 良心推荐。在二分答案的问题中边界情况真的很重要的有可能会在更新l和r的过程中把最优解更掉要注意。

（这里解释一下为什么没粘文章作者博客的链接， 因为我一点开索引显示博客不存在啊， qwq（卑微））

话说洛谷日报真的写的都不错啊（zici）。

然后check函数就是跑一边01背包，别忘记清空

The Last：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 1100;
int n, p, s, w[N], v[N], l = N, r, mid, ans = -1, f[N];
bool check(int x) {
	memset (f, 0, sizeof (f));
	for(int i = 1; i <= n; i++) 
		if (w[i] <= x)
			for(int j = s; j >= w[i]; j--)
				f[j] = max(f[j], f[j - w[i]] + v[i]);
	if (f[s] < p) return false;
	return true;
}
int main() {
	scanf("%d%d%d", &n, &p, &s);
	for(int i = 1; i <= n; i++) {
		scanf("%d%d", &w[i], &v[i]);
		if(w[i] > r) r = w[i];
		if(w[i] < l) l = w[i];
	}
	while(l < r) {
		mid = (l + r) >> 1;
		if(check(mid)) {
			ans = mid;
			r = mid;
		}
		else l = mid + 1;
	}
	if(ans != -1) 
		printf("%d\n", ans);
	else printf ("No Solution!\n");
	return 0;
}
```
谢谢收看， 祝身体健康！








---

## 作者：G_A_TS (赞：0)

其实此题只需要二分套背包  
注释见代码:  
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,V,S,s[1010],v[1010],l=0,r=10000,mid,gs,dp[1010],ss[1010],vv[1010];
int check(long long x)
{
	gs=0;
	for(int i=1;i<=n;i++)
	{
		if(s[i]<=x)
		{
			ss[++gs]=s[i];
			vv[gs]=v[i];
		}
	}
	for(int i=1;i<=gs;i++)//背包模板
	{
		for(long long j=S;j>=ss[i];j--)
		{
			dp[j]=max(dp[j],dp[j-ss[i]]+vv[i]);
		}
	}
	if(dp[S]>=V)
	{
		for(int i=0;i<=S;i++)
		{
			dp[i]=0;
		}
		return 1;
	}
	else
	{
		for(int i=0;i<=S;i++)
		{
			dp[i]=0;
		}
		return 0;
	}
}
int main()
{
	scanf("%lld%lld%lld",&n,&V,&S);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&s[i],&v[i]);
	}
	for(;l<=r;)//二分答案
	{
		mid=(l+r)/2;
		if(check(mid))//背包判断
		{
			r=mid-1;
		}
		else
		{
			l=mid+1;
		}
	}
	if(l>1000)
	{
		cout<<"No Solution!";//不要忘了
		return 0;
	}
	cout<<l;
}
```

---


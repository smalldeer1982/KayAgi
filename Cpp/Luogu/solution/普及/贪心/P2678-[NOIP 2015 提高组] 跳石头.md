# [NOIP 2015 提高组] 跳石头

## 题目背景

NOIP2015 Day2T1

## 题目描述

一年一度的“跳石头”比赛又要开始了！

这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。

## 说明/提示

### 输入输出样例 1 说明

将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。

### 数据规模与约定

对于 $20\%$的数据，$0 \le M \le N \le 10$。    
对于 $50\%$ 的数据，$0 \le M \le N \le 100$。  
对于 $100\%$ 的数据，$0 \le M \le N \le 50000,1 \le L 
 \le 10^9$。


## 样例 #1

### 输入

```
25 5 2 
2
11
14
17 
21```

### 输出

```
4```

# 题解

## 作者：ShawnZhou (赞：2403)

这道题如果要使用暴力搜索直接求解会严重超时。实际上，我们可以发现，这个所谓的最短跳跃距离显然不能超过一个范围，而这个范围题目上已经给了出来。也就是说，答案是有一个确定的范围限制的，我们就可以考虑一种另外的方法去解决——枚举答案，并去验证答案是否可行。


实际上，枚举答案有时候也会超时。这就好比说你要从一本英汉词典上查一个单词，你从头到尾一页一页的翻着找，这样找可以保证一定能找到，但是最坏情况你要把整本词典都翻一遍，那就麻烦了。


有什么改进的方法吗？当然有。


考虑把这个词典从中间分开，看一下中间那一页的主要单词都是啥，然后去判断我要找的单词应该在左半部分还是右半部分，再去那一部分考虑怎么找就好了。同样的，在另一部分也是要进行划分并且判断的操作。这样一直进行下去，便能很快的找到答案，而且根本不需要翻过整个词典来。


可以证明，如果一页一页的找，最多要找n次，但是用这个方法，最多找floor(log2n)次。


我们把这个方法叫做“二分答案”。顾名思义，它用二分的方法枚举答案，并且枚举时判断这个答案是否可行。但是，二分并不是在所有情况下都是可用的，使用二分需要满足两个条件。一个是有界，一个是单调。


二分答案应该是在一个单调闭区间上进行的。也就是说，二分答案最后得到的答案应该是一个确定值，而不是像搜索那样会出现多解。二分一般用来解决最优解问题。刚才我们说单调性，那么这个单调性应该体现在哪里呢？


可以这样想，在一个区间上，有很多数，这些数可能是我们这些问题的解，换句话说，这里有很多不合法的解，也有很多合法的解。我们只考虑合法解，并称之为可行解。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为最优解。


最优解一定可行，但可行解不一定最优。我们假设整个序列具有单调性，且一个数x为可行解，那么一般的，所有的x'(x'<x)都是可行解。并且，如果有一个数y是非法解，那么一般的，所有的y'(y'>y)都是非法解。


那么什么时候适用二分答案呢？注意到题面：使得选手们在比赛过程中的最短跳跃距离尽可能长。如果题目规定了有“最大值最小”或者“最小值最大”的东西，那么这个东西应该就满足二分答案的有界性（显然）和单调性（能看出来）。


那就好办了。我们二分跳跃距离，然后把这个跳跃距离“认为”是最短的跳跃距离，然后去以这个距离为标准移石头。使用一个judge判断这个解是不是可行解。如果这个解是可行解，那么有可能会有比这更优的解，那么我们就去它的右边二分。为什么去右边？答案是，这个区间是**递增**的 ，而我们求的是最短跳跃距离的**最大值**，显然再右边的值肯定比左边大，那么我们就有可能找到比这更优的解，直到找不到，那么最后找到的解就有理由认为是区间内最优解。反过来，如果二分到的这个解是一个非法解，我们就不可能再去右边找了。因为性质，右边的解一定全都是非法解。那么我们就应该去左边找解。整个过程看起来很像递归，实际上，这个过程可以递归写， 也可以写成非递归形式，我个人比较喜欢使用非递归形式。


下一个问题，这个judge怎么实现呢？judge函数每个题有每个题的写法，但大体上的思想应该都是一样的——想办法检测这个解是不是合法。拿这个题来说，我们去判断如果以这个距离为最短跳跃距离需要移走多少块石头，先不必考虑限制移走多少块，等全部拿完再把拿走的数量和限制进行比对，如果超出限制，那么这就是一个非法解，反之就是一个合法解，很好理解吧。


可以去模拟这个跳石头的过程。开始你在i(i=0)位置，我在跳下一步的时候去判断我这个当前跳跃的距离，如果这个跳跃距离比二分出来的mid小，**那这就是一个不合法的石头，应该移走。**为什么？我们二分的是最短跳跃距离，已经是最短了，如果跳跃距离比最短更短岂不是显然不合法，是这样的吧。移走之后要怎么做？先把计数器加上1，再考虑向前跳啊。去看移走之后的下一块石头，再次判断跳过去的距离，如果这次的跳跃距离比最短的长，那么这样跳是完全可以的，我们就跳过去，继续判断，如果跳过去的距离不合法就再拿走，这样不断进行这个操作，直到i = n+1，为啥是n+1？河中间有n块石头，显然终点在n+1处。（这里千万要注意不要把n认为是终点，实际上从n还要跳一步才能到终点）。


模拟完这个过程，我们查看计数器的值，这个值代表的含义是我们以mid作为答案需要移走的石头数量，然后判断这个数量 是不是超了就行。如果超了就返回false，不超就返回true。


整道题我已经说完了。。。如果实在难以理解，请看代码。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cctype>
#define maxn 500010
using namespace std;
int d,n,m;
int a[maxn];
int l,r,mid,ans;
inline int read(){//我喜欢快读
    int num = 0;
    char c;
    bool flag = false;
    while ((c = getchar()) == ' ' || c == '\n' || c == '\r');
        if (c == '-') flag = true;
    else
        num = c - '0';
    while (isdigit(c = getchar()))
    num = num * 10 + c - '0';
    return (flag ? -1 : 1) * num;
}

bool judge(int x){//judge函数，x代表当前二分出来的答案
    int tot = 0;//tot代表计数器，记录以当前答案需要移走的实际石头数
    int i = 0;//i代表下一块石头的编号
    int now = 0;//now代表模拟跳石头的人当前在什么位置
    while (i < n+1){//千万注意不是n，n不是终点，n+1才是
        i++;
        if (a[i] - a[now] < x)//判断距离，看二者之间的距离算差值就好
            tot++;//判定成功，把这块石头拿走，继续考虑下一块石头
        else
            now = i;//判定失败，这块石头不用拿走，我们就跳过去，再考虑下一块
    }
    if (tot > m)
        return false;
    else
        return true;
}

int main(){
    d = read();//d代表总长度，也就是右边界
    n = read();//n块石头
    m = read();//限制移走m块，思考的时候可别被这个m限制
    for (int i=1;i<=n;i++)
        a[i] = read();
    a[n+1] = d;//敲黑板划重点，再强调一遍，n不是终点
    l = 1;//l和r分别代表二分的左边界和右边界
    r = d;
    while (l <= r){//非递归式二分正常向写法，可理解为一般框架
        mid = (l+r) / 2;//这再看不出是啥意思可以退群了
        if (judge(mid)){//带入judge函数判断当前解是不是可行解
            ans = mid;
            l = mid + 1;//走到这里，看来是可行解，我们尝试看看是不是有更好的可行解
        }
        else
            r = mid - 1;//噫，你找了个非法解，赶紧回到左半边看看有没有可行解
    }
    cout << ans << endl;//最后的ans绝对是最优解
    return 0;
}
```



---

## 作者：aiyougege (赞：40)

### 跳石头
#### Solution
　　典型的二分答案题, 答案为**最短跳跃距离的最大值**, 记为$\textbf{ans}$, 那么对于任意$l,l<\textbf{ans}$, 以其为最短跳跃距离都能移走不超$m$个石子跳过河; 对于任意$l,l>\textbf{ans}$, 以其为最短跳跃距离不能移走不超$m$个石子跳过河, 也就是说如果以$f(l)$表示以$l$为最短距离能不能过河, $f(l),l\in \textbf{N}\text{且}0<l\leq l$ 具有单调性.

　　所以对于任意$l$, 所需要找到的就是这么一个点$u$使得$f(u)=1$的最大值, 也就是本题的答案.

　　也就是说需要二分这个答案的点的位置, 通过**二分答案**.

![e](https://cdn.luogu.com.cn/upload/pic/18182.png)  
　　**如何判断$f(l)$的值呢?**

　　发现如果**两个点之间距离小于最小跳跃距离**, 那么就必须将其中一个石子移去.假设这**两个点之前所有石子已经满足要求**了, 发现如果移去前一个石子, 可是前一个石子与它前面的石子本来就大于最短距离, 移去后后面的石子与再后面的石子可能还是大于最短距离;　　  
如果移走后面的石子, 不会改变前面石子, 那么它前面石子与后面的石子的距离减小了, 也就是.

![](https://cdn.luogu.com.cn/upload/pic/18183.png)

　　***Tips:***
- 二分会出诡异的问题, 有三个测试点输出比答案大一, 所以我特判了...

#### Code
```
#include<cstdio>

int k,n,m;
int pos[50005];

bool check(int mid){
    int ans=0,st=0;
    for(int i=1;i<=n;++i)
        if(pos[i]-st<mid)
            ans=ans+1;
        else st=pos[i];
    return ans<=m;
}

int main(){
    scanf("%d%d%d",&k,&n,&m);
    for(int i=1;i<=n;++i)scanf("%d",&pos[i]);
    int l=0,r=k,mid;
    while(l<r){
        mid=(l+r)>>1;
        if(check(mid))l=mid+1;
        else r=mid-1;
    }
    if(!check(l))l-=1;
    printf("%d\n",l);
    return 0;
}
```

---

## 作者：GSQ0829 (赞：13)

[题目传送门](https://www.luogu.com.cn/problem/P2678)

---
### 思路：
这题很明显，就是二分题，要求最短跳跃距离的最大值。

那么，首先我们要先知道二分的模版。
```cpp
while (l < r) {
    mid = (l + r + 1) / 2;
    if (check(mid)) l = mid;
    else r = mid - 1;
}
```

在知道了模版之后，我们就要来写判断函数了。

我们会发现如果两个点之间距离小于最小跳跃距离， 那么就必须将其中一个石头移去。

所以根据这个，我们就可以写出判断函数了。
```cpp
bool check(int d) {
	int p = 0, ans = 0;
	for (int i = 1; i <= n; i++) {
		if (stone[i] - p < d) ans++;
		else p = stone[i];
	}
	if (ans <= m) return true;
	else return false;
}
```

最后，将两者结合，就是最终代码了。



---
### code：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 50001;
int stone[MAXN], a, n, m;

bool check(int d) {
	int p = 0, ans = 0;
	for (int i = 1; i <= n; i++) {
		if (stone[i] - p < d) ans++;
		else p = stone[i];
	}
	if (ans <= m) return true;
	else return false;
}

int main() {
	scanf("%d %d %d", &a, &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &stone[i]);
	stone[++n] = a;
	int l = 0, r = a, mid;
	while (l < r) {
		mid = (l + r + 1) / 2;
		if (check(mid)) l = mid;
		else r = mid - 1;
	}
	printf("%d\n", l);
	return 0;
}
```

---

## 作者：ikunTLE (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P2678)

### 思路

不难发现答案具有单调性。若最短跳跃距离的最大值为 $X$，那么对于 $X-1$ 以及所有 $<X$ 的数，选手一定能跳过去。反之如果它 $>X$，则一定超过了 $M$，不可行。考虑**二分**。

二分最短跳跃距离。对于每一次尝试的距离 $X$，每次以起点向前遍历找到第一个 $<X$ 的点，增加答案次数，并跳跃至当前点。最后判断答案次数是否 $\le M$ 即可。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=5e4+10;
int n,m,a[N];
bool check(int x){
	int cnt=0,p=0;
	for(int i=1;i<=n+1;++i)
		if(a[i]-a[p]<x)
			++cnt;
		else p=i;
	return cnt<=m;
}
int main(){
	int lrd=read();
	n=read(),m=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	a[n+1]=lrd;
	int l=1,r=1e9;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid))
			l=mid+1;
		else r=mid-1;
	}
	printf("%d\n",r);
	return 0;
}
```

---

## 作者：xyx404 (赞：6)

## 思路：
二分答案。

要求找最小值最大，所以考虑二分。

对于每次二分的 $mid$ 最小需要跳跃的距离，进行一次检查，对于检查函数，为了确定编号为 $i$ 的岩石之前没有被删除的岩石是哪个，要定义一个 $last$ 存上一个没有被删除的岩石的编号，每次对比 $D_i$ 和 $D_{last}$ 的差，如果小于我们二分到的距离就说明要移走，否则不要移走更新 $last$ 为 $i$，如果要移走的岩石小于等于最多可以移走的岩石 $m$ 说明这种情况是可能的，否则不可能。

答案为每个满足的 $mid$ 中的最大值。

注意起点和终点要在数组里，$D$ 数组输入时不会有终点和起点，自行要添加。




## 代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL l,n,m;
LL a[50003],maxx;
bool check(LL mid){
	int last=0,del=0;
	for(int i=1;i<=n;i++){
		if(a[i]-a[last]<mid){
			del++;
		}
		else last=i;
	}
	return del<=m;
}
int main(){
	cin>>l>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];// 代码中的数组 a 为题目中的数组 D
	sort(a+1,a+1+n);
	a[++n]=l;
	LL r=l,l=1,mid;
	while(l<=r){
		mid=(l+r)/2;
		if(check(mid)){
			l=mid+1;
			maxx=mid;
		}
		else r=mid-1;
	}
	cout<<maxx;
	return 0;
}

```

---

## 作者：GZXUEXUE (赞：4)

### 思路

众所周知，这道题是一道经典的二分题。

我们记输出答案为 $p$，显见 $1 \le p \le L$。

注意到 $L$ 的数据范围较大，且题目中含有“最短跳跃距离最长”的说法，考虑使用二分。

我们对答案进行二分，当移走的岩石数太多，那么应该跳近一点，否则尽可能地跳远一点。显见上述过程满足二分的「单调性」。

时间复杂度为 $O(N \log L)$。

### 实现

```cpp
# include <iostream>
using namespace std;
int a[50004],l,n,m;
bool check(int d){ // 判断是否合法，计算要移走的石头个数
	int cnt = 0,pos = 0;
	for (int i = 0;i < n;i++){
		if (a[i] - pos < d) cnt++;
		else pos = a[i];
	}if (l - pos < d) cnt++;
    return cnt <= m; // 判断要移走的石头个数
}int main(){
	cin >> l >> n >> m;
    for (int i = 0;i < n;i++) cin >> a[i];
	int left = 1,right = l,ans = -1; // 二分
	while (left <= right){
		int mid = (left + right) >> 1;
		if (check(mid)) left = mid + 1,ans = mid;
		else right = mid - 1;
	}cout << ans;
	return 0;
}
```

---

## 作者：__galaxy_1202__ (赞：2)

## 解题思路：
$n \le 5 \times 10^4$，暴力 $n ^ 2 = 2.5 \times 10^9$，会超时。    

易发现决策具有单调性，考虑二分答案。  

决策函数是一个经典的贪心问题，对能跳过去的石头进行计数，判断是否 $\le m$ 即可。

## CODE：

```cpp
#include <iostream>
using namespace std;
int L, n, m, l, r, mid, ans, a[100001];
bool P(int x)
{
    int lst = 0, cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        if (a[i] - lst < x) ++cnt;
        else lst = a[i];
    }
    if (L - lst < x) ++cnt;
    return (cnt <= m);
}
int main()
{
    cin >> L >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    l = 0, r = 1e9;
    while(l <= r)
    {
        mid = (l + r) >> 1;
        if (P(mid)) 
        {
            ans = mid;
            l = mid + 1;
        }
        else r = mid - 1;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：wanghonghui123 (赞：2)

## 思路

一道**二分**题，此题的关键是一个 `check` 函数。

#### 关键点（check）

- 先遍历所有岩石，如果当前岩石和上一块每一掉岩石的的距离小于 $mid$（$mid$ 是当前猜测的最小步数），就要移掉当前岩石，否则就要更新上一块未被一走的岩石的位置（也就是把上一块的位置是加 $1$）

- 判断要移走的是否不超过最多可以移掉的岩石数量。

时间复杂度为 $\mathcal{O(n \log t)}$，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=5e4+5;
int a[N];
int t,n,m;
bool check(int mid){
	int cnt=0,l=0;
	for(int i=1;i<=n+1;i++){
		if(a[i]-a[l]<mid) cnt++;
		else l=i;
	}
	return cnt<=m;
}
int main(){
	cin>>t>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	a[n+1]=t;
	int l=0,r=t;
	while(l<r){
		int mid=(l+r+1)>>1;
		if(check(mid)) l=mid;
		else r=mid-1;
	}
	cout<<l;
	return 0;
}
```

---

## 作者：UNDERTALE_RS (赞：2)

# P2678 [NOIP2015 提高组] 跳石头 题解

[题目传送门](https://www.luogu.com.cn/problem/P2678)

## 题目分析

看到题目，由于 $n$ 很大，不能直接枚举，需要用其它方法。

### 一般方法
我们可以从大到小枚举最终的答案，即枚举最短跳跃距离的最大值，接着去判断是否可以。  
判断时，我们去看这块石头与前面一块石头之间的距离是否超过我们所枚举的距离。如果**没有超过**，就意味着我们要移开这块石头，并且计数。  
最后判断移开石头的总数是否超过至多移走的数量。没有超过便是符合的。

但由于题目中说到：
> $0 \le M \le N \le 5 \times 10^4$

那必然是超时的，需要进行优化。

### 二分答案
在最终判断部分，如果我们仔细思考，就会发现如果当前枚举的数超过要求，那么比它大的数**一定也不行**；如果当前枚举的数符合要求，那么比它小的数**一定也行**。

这样我们就可以使用**二分法**。如果符合要求，那么记录答案，并将左端点设为该数加一；否则将右端点设为该数减一。

最终代码如下：

```cpp
#include <iostream>
using namespace std;
int len,n,m,a[50005],ans;

int check(int x){
    int stand = 0,cnt = 0; //分别表示站立位置和移走数量
    for(int i = 1;i <= n;i++){
        if(a[i] - stand < x)
            cnt++;
        else
            stand = a[i];
    }
    return cnt;
}

int main()
{
	cin >> len >> n >> m;
	for(int i = 1;i <= n;i++)
	    cin >> a[i];
	a[++n] = len; //将终点记录
	int l = 1,r = len,mid;
	while(l <= r){
	    mid = (l+r) / 2;
	    if(check(mid) <= m) //符合要求
	        ans = mid,l = mid+1;
	    else //不符要求
	        r = mid-1;
	}
	cout << ans;
	return 0;
}
```


### 一些技巧
当在题目中看到“最小的最大”或是“最大的最小”诸如此类的关键词，那么该题多半是使用二分算法。

## 总结
是一道基础的题，考察二分答案的使用，适合初学者练习。

感谢您的阅读！

---

## 作者：collegiate (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P2678)

### 思路
我们看见求**最短跳跃距离的最大值**的时候就想到了**二分**。

并且这个问题满足二分的**有界性**，也就是 $ans \in [1,L]$ 的范围；又满足**单调性**，也就是当移去的石头越多的时候，那么最短跳跃距离的最大值就会递增，满足二分的条件！

那么求最短跳跃距离的最大值的二分模板也就可以打出来了：


```cpp
ll binarySearch(ll l,ll r){
	ll ans=0;
	while(l<=r){
		ll mid=l+r+1>>1;
		if(check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}
```

那么怎么去写 $check(mid)$ 呢？非常容易哒！

我们假设 $x$ 是目前的最小距离，假设 $res$ 为共挪走的岩石个数，假设 $now$ 是当前距离。

那么若当前距离 $s$ 比 $x$ 小了，那么就不满足 $x$ 是最小的距离，所以我们要把这个岩石**挪走**即可，然后 $res$ 增加 $1$ 即可，因为挪走了嘛。

如果 $s$ 大于等于 $x$ 的话，那么就可以跳，那么就更新一下 $now$ 就可以了，直到跳到终点。

并且 $res$ 需要满足 $res \le m$ 才可以，否则就返回 $0$ 即可。

**注意：在循环的时候要循环多一次！原因是跳到最后一个石头之后还要再跳一步才能到终点！！！**


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=4e5+5;
ll l,n,m,ans;
ll arr[N];
bool check(ll x){
	ll now=0,res=0;
	for(int i=1;i<=n+1;i++){
		if(arr[i]-now < x) res++;
		else now=arr[i];
	}
	return res<=m;
}

ll binarySearch(ll l,ll r){
	ll ans=0;
	while(l<=r){
		ll mid=l+r+1>>1;
		if(check(mid)) ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans;
}
int main(){
	cin>>l>>n>>m;
	for(int i=1;i<=n;i++) cin>>arr[i];
	arr[n+1]=l;//还要再跳1步
	ans=binarySearch(1,l);
	cout<<ans;
	return 0;
}
```

---


# 寻找平面上的极大点

## 题目描述

在一个平面上，如果有两个点(x,y),(a,b),如果说(x,y)支配了(a,b)，这是指x>=a,y>=b;

用图形来看就是(a,b)坐落在以(x,y)为右上角的一个无限的区域内。

给定n个点的集合，一定存在若干个点，它们不会被集合中的任何一点所支配，这些点叫做极大值点。

编程找出所有的极大点，按照x坐标由小到大，输出极大点的坐标。


## 说明/提示

对于50%的数据：1≤N≤100；0≤X,Y≤100000；

对于100%的数据：1≤N≤50,0000；0≤X,Y≤100000


## 样例 #1

### 输入

```
5 
1 2 2 2 3 1 2 3 1 4```

### 输出

```
(1,4),(2,3),(3,1)```

# 题解

## 作者：shiningrise (赞：15)

在纸上把测试数据一画，就知道

贪心
先按y排序，y相同按x排序

第一点肯定就是极大点了，因为没有点y比他大

接下来就把这个极大点的x记下，之后第一个出现x比前一个极大点x大的点就是极大点

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    struct Node {
        int x;int y;
        bool operator <(const Node &b)const
        {
            if(y==b.y)return x>b.x; 
            return y>b.y;
        }
    }a[500005];
    int main()
    {
         std::ios::sync_with_stdio(false);
        int n;
        cin>>n; 
        for(int i=0;i<n;i++)
        {
            cin>>a[i].x>>a[i].y;
        }
        sort(a,a+n);
        int f=1;
        int last =-1;
        for(int i=0;i<n;i++)
        {
            if(a[i].x>last)
            {
                last = a[i].x;
                if(f)f=0;else cout<<",";
                cout<<"("<<a[i].x<<","<<a[i].y<<")";
            }
        }
        return 0;
    }

```

---

## 作者：Mr_QwQ (赞：13)

楼下几位巨佬几乎都是用单调队列，在此给出一个不使用任何数据结构的写法。

首先给出如下定理：

**对于任意一个点，如果它的y值不小于任何一个点使这个“任何一个点”x值大于给定点的x值，那么该点为极大点。**

第一反应：看不懂

第二反应：这不就是极大点的定义么

好，我们改一下说法：

**对于任意一个点，如果y值比它大的点全部都在它的左边，那么该点为极大点。**

第一反应：这回能看懂了

第二反应：这不还是极大点的定义么

不急，一步步慢慢推导。我们迎来了wx定理的最终版本：

**对于任意一个点，如果它的y值比它右边（包括这一列）的点都要大，那么该点为极大点。**

呃呃，这不还是定义！

但是我们可以用它来解题了。

首先，我们按照x值从小到大排序。接下来，我们从右往左扫一遍，并维护最大y值，当当前y大于已知最大y值时加入答案并更新最大y，否则无视。最后，我们将加入的点倒序输出即可。

这份算法，可以得90分。（我就被坑了）

为什么？重新来看定理：

对于任意一个点，如果它的y值比它右边**（包括这一列）**的点都要大，那么该点为极大点。

是的，判定条件包括这一列！

所以我们要在排序时，当x相等时比较y。这样，才能AC。

最后献上简短但丑陋的代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct point{
    int x,y;
    bool operator <(point b)const{
        return (this->x<b.x)||((this->x==b.x) && (this->y<b.y));
    }
}p[500001];
int n,imax=-1,a[500001],top;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d%d",&p[i].x,&p[i].y);
    sort(p+1,p+n+1);
    for(int i=n;i>=1;i--)
    {
        if(p[i].y>imax){
            a[++top]=i;
            imax=p[i].y;
        }
    }
    for(int i=top;i>=1;i--){
        printf("(%d,%d)",p[a[i]].x,p[a[i]].y);
        if(i>1)printf(",");
    }
    return 0;
}
```

---

## 作者：Konnyaku_ljc (赞：8)

# 暴力出奇迹  
此题非常水  
先拿样例解释一下代码  
样例就像下图一样（画的有点丑……） 
先说一下定义  
```cpp
int n,ans;//n是输入，ans是答案的个数
int maxx,maxy[100005],maxyy;
//maxx是最左边的x的值，maxy[n]是横坐标为n的一列的y的最大值，maxyy是从左往右的y的最大值
int x[100005],y[100005];//存坐标的
```

![ ](https://cdn.luogu.com.cn/upload/pic/53020.png)  
```cpp
    cin>>n;//输入n
    for(int i=1;i<=n;i++)
    {
        int x1,y1;//设一个坐标
        cin>>x1>>y1;输入坐标
        maxy[x1]=max(maxy[x1],y1);//每一个x，都有一个相对应的最大的y，存一下
        maxx=max(maxx,x1);//找最左边的端点
    }
    
```
那么在此时，maxy[1]=4,maxy[2]=3,maxy[3]=1,现在只需操作这三个点。
```cpp
    for(int i=maxx;i>=1;i--)//从最右边开始搞
    {
        if (maxy[i]>maxyy)
        //如果右边的最大值比此列的小，说明右上角啥也没有，可以操作
        {
            maxyy=maxy[i];//更新右边的最大值
            ans++;//答案数++
            x[ans]=i,y[ans]=maxyy;//存一下此符合条件的点
        }
    }
```
#### OF COURSE 别忘了最后一个没有逗号
```cpp
    //很明显，三个点全部符合
    for(int i=ans;i>=2;i--)
    {
    	cout<<"("<<x[i]<<","<<y[i]<<")"<<",";
	}
    cout<<"("<<x[1]<<","<<y[1]<<")";
```
## finish  
全部纯代码——
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int maxx,maxy[100005],maxyy;
int x[100005],y[100005];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        int x1,y1;
        cin>>x1>>y1;
        maxy[x1]=max(maxy[x1],y1);
        maxx=max(maxx,x1);
    }
    for(int i=maxx;i>=1;i--)
    {
        if (maxy[i]>maxyy)
        {
            maxyy=maxy[i];
            ans++;
            x[ans]=i,y[ans]=maxyy;
        }
    }
    for(int i=ans;i>=2;i--)
    {
    	cout<<"("<<x[i]<<","<<y[i]<<")"<<",";
	}
    cout<<"("<<x[1]<<","<<y[1]<<")";
    return 0;
}
```
谢谢观赏

---

## 作者：ycyaw (赞：6)

**一份简明易懂的题解（没什么算法）**

~~完全是想法~~：
我们要找到极大点，可以先将坐标以横坐标为第一关键字排序，以纵坐标为第二关键字排序。如样例，我们可以得到：
```
1 2
1 4
2 2
2 3
3 1
```
这时我们从1~n循环可以发现，对于任何横坐标X[i]都小于等于X[i+1]~X[n],
那么只有Y[i]大于所有Y[i+1]~Y[n]，这个点才能成为极大点。

由此，我们可以设计一个数组，用pos[i]表示i~n中y（纵坐标）最大值的位置。预处理好后，从1~n循环，如果当前点的纵坐标不为i~n中最大的（即pos[i]!=i）那么这个点肯定不是极大点，否则就是极大点，储存。
最后排个序输出，就ok(~~gg~~)啦！

上代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,maxx,top;
struct node{
	ll x,y;
}a[500005],ans[500005];//ans[i]存储答案,a[i]存储坐标 
ll pos[500005];//pos[i]表示i~n中最大值的位置
bool cmp(node aa,node bb){
	if(aa.x!=bb.x) return aa.x<bb.x;
	return aa.y<bb.y;
}
bool cmp1(node aa,node bb){
	return aa.x<bb.x;
}
inline ll read(){
    ll ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
    return ret*ff;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();
	sort(a+1,a+n+1,cmp);
	maxx=a[n].y;
	pos[n]=n;
	for(int i=n-1;i>=1;i--){
		if(a[i].y>maxx){
			maxx=a[i].y;
			pos[i]=i;
		}
		else pos[i]=i+1;
	}
	for(int i=1;i<=n;i++){
		if(pos[i]==i){
			ans[++top].x=a[i].x;
			ans[top].y=a[i].y;
		}					
	}
	sort(ans+1,ans+top+1,cmp1);
	for(int i=1;i<=top-1;i++) printf("(%lld,%lld),",ans[i].x,ans[i].y);
	printf("(%lld,%lld)",ans[top].x,ans[top].y);//输出格式 
	return 0;
}
```

---

## 作者：myee (赞：4)

### Update
* 20210219 标点改为了全角

---
由题意，最后若 $x_1<x_2$，则 $y_1>y_2$，即具有单调性。

好像是单调队列？由于对谔谔的单调队列的憎恶，我们尝试使用别的解法。

考虑使用我在[这篇博客](https://www.luogu.com.cn/blog/myee/yk-algorithm)里讲到的算法解决。

答案显然是单调的（上面分析过），因此我们考虑通过归并得到答案。

归并操作就很显然了（见代码），注意在归并过程中删去不合适的点。

第 $k$ 次加点操作在末尾加入一个长度为一的块，然后在末尾进行 $\log_2\operatorname{lowbit}k$ 次归并，这样就是一个二进制拆分。

通过树状数组的知识，我们可以显然证明这个算法复杂度是 $O(n\log n)$ 的。

看代码感性理解一下吧（由于大量使用STL，常数很大，因此最好配合一个O2优化）。

Code:
```cpp
#include <stack>
#include <stdio.h>
#include <vector>
typedef unsigned long long ullt;
typedef unsigned uint;
typedef long long llt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
typedef std::pair<uint,uint>P;
std::vector<std::vector<P> >V;
std::vector<P>User;
bol _union()
{
    if(V.size()<=1)return false;
    std::stack<P>S1,S2;P p;
    while(!V.back().empty())S1.push(V.back().back()),V.back().pop_back();
    V.pop_back();
    while(!V.back().empty())S2.push(V.back().back()),V.back().pop_back();
    while(!(S1.empty()&&S2.empty()))
    {
        if(S2.empty())p=S1.top(),S1.pop();
        else if(S1.empty()||S2.top()<S1.top())p=S2.top(),S2.pop();
        else p=S1.top(),S1.pop();
        while(!V.back().empty()&&V.back().back().second<=p.second)V.back().pop_back();
        V.back().push_back(p);
    }
    return true;
}
int main()
{
    uint n,k;scanf("%u",&n);
    User.push_back(P(0,0));
    for(uint i=1;i<=n;i++)
    {
        scanf("%u%u",&User[0].first,&User[0].second),V.push_back(User),k=i&-i;
        while(k>>=1)_union();
    }
    while(_union());User=V[0],k=User.size();
    for(uint i=0;i<k;i++)
    {
        if(i)putchar(',');
        printf("(%u,%u)",User[i].first,User[i].second);
    }
	return 0;
}

```



---

## 作者：Violette (赞：4)

思路：

首先看一下数据，n<=50000，如果用双重循环直接暴力枚举肯定会有超时！（经尝试，可以拿到50分左右。）

所以考虑用单重循环来解这道题。

首先，设置一个结构体，里面有x和y两个元素。

再根据y排序（y越小越靠前，y一样按x从小到大排序），此时标记第一个元素。

单重循环遍历如果有比它大的，就是极大点。

最后输出他们的x坐标和y坐标即可。

附上代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
    int x,y;
}a[500005];
bool cmp(node a,node b){
    if(a.y==b.y) return a.x>b.x;
    else return a.y>b.y;
}
int main() {
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
	    cin>>a[i].x>>a[i].y;
	}
	sort(a+1,a+1+n,cmp);
	int f=1,m=-1;
	for(int i=1;i<=n;i++){
	    if(a[i].x>m){
	        m=a[i].x;
	        if(f==1){
	            f=0;
	        }
	        else cout<<",";
	        cout<<"("<<a[i].x<<","<<a[i].y<<")";
	    }
	}
	return 0;
}

```


---

## 作者：frank520 (赞：4)

# 蒟蒻的第一篇题解（蒟蒻友好型）

这题是着实阴间

样例画图如下

![](https://cdn.luogu.com.cn/upload/image_hosting/2s3xp7ef.png)

我们不难发现，将给到的点以y降序（y相同时x降序）进行排列，第一个点是绝对满足要求的；而由于这个十分恶心的输出格式，输出第一个后再在每个前面输出“,(x,y)”即可



------------
### 样例排序

(1,4) (2,3) (2,2) (2,1) (3,1)

将第一个点输出后，那些x小于这个点的x的点都不符合要求，所以我们可以用一个lx来记录目前的x

#### 应该讲的~~比较清楚~~了

### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct E{
	int x,y;
}data[500005];//n的数据范围 
bool cmp(E a1,E a2){
	if(a1.y==a2.y) return a1.x>a2.x;
	return a1.y>a2.y;
}//排序 以y为大的在前面 y相同时以x为大在前 
int main(){
	int lx;
	scanf("%d",&n);//输入n 
	for(int i=1;i<=n;i++)
		scanf("%d%d",&data[i].x,&data[i].y);//将坐标放到data结构体里 
	sort(data+1,data+1+n,cmp);//排序 
	printf("(%d,%d)",data[1].x,data[1].y);//将第一个输出 
	lx=data[1].x;//记录现在的x 
	for(int i=2;i<=n;i++)
		if(data[i].x>lx){
			printf(",(%d,%d)",data[i].x,data[i].y);
			lx=data[i].x;
		}//剩下的只要符合要求都可以输出 
	return 0;
}
```

# 感谢支持蒟蒻

---

## 作者：saxiy (赞：3)

### 简单的解法

------------

观察数据,其实可以只开一个N的Y数组.
```cpp
#include <cstdio>
#define MAX_N 100005
using namespace std;
typedef unsigned int n_int;
n_int Y[MAX_N];
int main() {
    n_int n, x, y, max_xn = 0;
    scanf("%u\n", &n);
    while(n-- > 0) { //只记录Y轴上最大x
        scanf("%d%d", &x, &y);
        if(x > Y[y]) Y[y] = x;
    } n = MAX_N;
    while(n-- > 0) { //处理格式
        if(Y[n] > max_xn) { max_xn = Y[n];
            printf("(%d,%d)", max_xn, n);
            break;
        }
    } while(n-- > 0) {
        if(Y[n] > max_xn) { max_xn = Y[n];
            printf(",(%d,%d)", max_xn, n);
        }
    } return 0;
}
```
这个规律是很好找的

---

## 作者：王钰翔 (赞：2)

# 优先级问题
## 主要思想：先判断出每列最高点，如果要满足极大点，需要在x[i-1]<x[i]的情况下y[i-1]>y[i]才可满足。(可以想象成数轴上画矩形方便理解)
**Code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m=-0x7fffffff;
bool f[100005];
struct maxpoint {
	int x,y;
} num[100005];
bool cmp(maxpoint a,maxpoint b) {
	return a.x<b.x||(a.x==b.x&&a.y<b.y); // 【主要代码】 若x相等，比较y 
}
int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>num[i].x>>num[i].y;
	}
	sort(num+1,num+n+1,cmp);
	for(int i=n; i>=1; i--) {
		if(num[i].y>m) { // 未被大的点包括，标记最大点 
			f[i]=1; 
			m=num[i].y; // 持续更新最大点 
		}
	}
	for(int i=1; i<=n; i++) {
		if(f[i]) {
			printf("(%d,%d)",num[i].x,num[i].y);
			if(i!=n)cout<<","; // 防止多余符号 
		}
	}
}
```


---

## 作者：山羊之神 (赞：2)

蒟蒻的第一篇题解，求dalao指点。

刚读完题，我坚信这道题有一种O[n]的做法，经过了~~59秒~~1分钟的思索。。

我发现X较小的极大点，Y较大

那么我们可以按X从大到小的顺序遍历，遇到前所未有大的Y时存下X，Y

代码：

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;//美丽的头文件
int n,maxn,p[100010],u[100010],v[100010],cnt,m;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(p[x]<y) p[x]=y;//寻找对于每一个X的最大Y
        if(m<x) m=x;
    }
    for(int i=m;i>=1;i--)
    {
        if (p[i]>maxn)
        {
            maxn=p[i];
            cnt++;
            u[cnt]=i;
            v[cnt]=maxn;
        }
    }//从最大X向小遍历，如果新的p[i]比之前遇到的都大，就说明这是一个极大点
    for(int i=cnt;i>=2;i--)
        printf("(%d,%d),",u[i],v[i]);
    printf("(%d,%d)",u[1],v[1]);
//    system("pause");
    return 0;
}
```

---

## 作者：Cure_Wing (赞：1)

### 题目  
寻找极大点。  
### 想法
贪心先按  $x$  轴从大到小排序，同时  $y$  轴从大到小排序（为了之后方便比较），这样可以方便判断  $y$  轴的压制性（即保证当  $x_1>x_2$  时，  $y_1<y_2$  ）。  
对于同一  $x$  轴上的点，他们的极大点就是  $y$  值最大的那个点，而这个点是不是真·极大点，则要判断是否高于压制点（  $y$  轴目前最高点），是则是极大点之一，同时更新压制点为那个点的  $y$  值。  
那么压制点的初值是多少呢？自然是  $x$  值最大时  $y$  至最大的点，因为此时他在  $x$  轴上已经是巅峰，所以不受其他任何的约束，而其他点由于收到  $x$  轴的约束，所以只能在  $y$  轴上崭露头角。
那么这一部分的写法如下：
```cpp
	//f[],k,t[],cnt均为int类合法数组，其中f[]存储极大点编号，k存储压制点，t[]存储每个点，cnt记录极大点个数
	f[++cnt]=1;k=t[1].p;//极大点++，存储压制点（初始化）
	for(int i=2;i<=n;++i)
		if(t[i-1].q>t[i].q)//x值产生变化时
			if(t[i].p>k)//判断是否压制
				f[++cnt]=i,k=t[i].p;//不压制则更换
```
既然刚刚是倒着存储的，那么也就要倒着输出：
```cpp
	for(int i=cnt;i-1;--i)//"i-1"等同于"i!=1"，为了不多输出","，所以提前结束
		printf("(%d,%d),",t[f[i]].q,t[f[i]].p);
	printf("(%d,%d)\n",t[f[1]].q,t[f[1]].p);
```
就讲这么多，再见！

---

## 作者：蚂蚁的头皮屑 (赞：0)

## P党福利


#### 蒟蒻的第一份题解，如有错误请不吝指出Qwq

————————————————————————————————————

这题乍一看范围很大，~~根本没有头绪~~
但仔细读题（~~好习惯要记下来~~）后我们发现

由于 x>=a,y>=a就算是支配，也就是说同一横坐标上的点只能存在一个极大点，即当x相等时，y肯定有个高低，而最高的~~julao~~点就是该横坐标上的极大点

所以这道题目就变为存下每一横坐标上的最大值设为a[i]，
从后往前，记录下遍历到的最大的a[i]的值存为max，如果当前的a[i]>max那么就把当前的i标记为true，最后从头到尾进行输出就ojbk了

下面是丑陋的代码（~~听说丑陋点是规矩~~）

```
var
  a:array[1..100000]of longint;
  b:array[1..100000]of boolean;
  n,x,y,i,max,m:longint;
begin
  readln(n);
  for i:=1 to n do
    begin
      read(x,y);
      if x>max then max:=x;
      if y>a[x] then a[x]:=y;
    end;
  b[max]:=true;
  m:=a[max];
  for i:=max-1 downto 1 do
    if  a[i]>m then
                   begin
                     b[i]:=true;
                     m:=a[i];
                     x:=i;
                   end;
  write('(',x,',',a[x],')');
  for i:=x+1 to max do
    if b[i] then write(',(',i,',',a[i],')');
end.

```

---

## 作者：Great_Influence (赞：0)

单调队列裸题。

只需要先按x排序，在依次插入单调递减队列就可以了。答案就是插完所有点后留下的点。注意逗号就可以了。

代码：

```cpp
#include<bits/stdc++.h>
#include<cctype>
#include<algorithm>
#include<deque>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//读入优化
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
const int MAXN=500010;
struct node
{
    int x,y;
    friend bool operator<(node a,node b)//重载运算符
    {
        return a.x^b.x?a.x<b.x:a.y<b.y;
    }
}p[MAXN];//点
int n;
deque<node>G;//双向队列方便操作
int main(void)
{
    read(n);
    int i;
    For(i,1,n)read(p[i].x),read(p[i].y);
    sort(p+1,p+n+1);//排序
    For(i,1,n)
    {
        while(!G.empty()&&G.back().y<=p[i].y)G.pop_back();//单调队列插入
        G.push_back(p[i]);
    }
    bool k=false;
    while(!G.empty())
    {
        if(k)putchar(',');
        printf("(%d,%d)",G.front().x,G.front().y);//输出
        k=true;
        G.pop_front();
    }
    return 0;
}
```

---

## 作者：1124828077ccj (赞：0)

直接暴力会超时，于是我机智的加了个优化（虽然理论时间复杂度还是O(n^2)），就过了。具体请看代码注释

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,Max,h;
bool f;
typedef struct{
    int x,y;
}P;
bool cmp(P a,P b){
    return (a.x>b.x);
}
int main()
{
    scanf("%d",&n);P p[n];
    for (int i=0;i<n;i++)
    scanf("%d%d",&p[i].x,&p[i].y);
    sort(p,p+n,cmp);
    for (int i=0;i<n;i++)
    {
        h=i;
        for (int j=i+1;j<n;j++)
        if (p[i].x==p[j].x)
        {
            if (p[j].y<p[h].y)p[j].y=-1;else {p[h].y=-1;h=j;}
        }
        else break;
```
}//先把x坐标相同的互相比较一下
```cpp
    h=0;//h现在代表目前遇到过得y坐标的最大值
    for (int i=0;i<n;i++)
    if (p[i].y>h)h=p[i].y;
    else p[i].y=-1;//如果他比当前最大的y坐标小，那么x坐标一定也比之前的那个小（因为排序了），因此要标记。
    for (int i=n-1;i>=0;i--)
    {
        if (p[i].y<0)continue;
        if (!f){f=1;printf("(%d,%d)",p[i].x,p[i].y);}
        else printf(",(%d,%d)",p[i].x,p[i].y);//如果这个坐标没有被标(he)记(xie)，输出他，注意逗号的格式
    }
    return 0;
}
```

---

## 作者：Deny_小田 (赞：0)

## 这道题把我坑的不浅

### 欲哭无泪ing


言归正传。

之前我是50分。因为我的方法太笨了。

我是一个一个直接判断的  #滑稽


附代码（50分的！再说一遍）：
    
```cpp
#include <cstdio>
#include <algorithm>
#define Size 1000005
using namespace std;
typedef struct _coordinate{
    int x,y; 
}coor;
coor c[Size],p[Size];
int cmp(coor a,coor b){ return a.x < b.x; }
int main(){
    int n,cnt = 0;
    scanf("%d",&n);
    for(int i = 0; i < n; i++) scanf("%d %d",&c[i].x,&c[i].y);
    for(int i = 0; i < n; i++){
        bool flag = true;
        for(int j = 0; j < n; j++){
            if(c[j].x >= c[i].x&&c[j].y > c[i].y&&i != j){ flag = false; break;    }
        }
        if(flag){ p[cnt].x = c[i].x; p[cnt].y = c[i].y; cnt++; }
    }
    sort(p,p+cnt,cmp);
    for(int i = 0; i < cnt; i++) if(!i) printf("(%d,%d)",p[i].x,p[i].y); else printf(",(%d,%d)",p[i].x,p[i].y);
    printf("\n");
    return 0;
}
```

后来我改变了思路，用了一个较为聪（er）明（bi）的方法。注释里有，有兴趣的同学可以看看。

附代码：







```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int size = 10005;
int mark[size],yArr[size],x,y,n,begin;
int main(int argc, char const *argv[]){
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d %d",&x,&y);             
        mark[y] = 1;                            //将mark的y置为一，为之后的判断输出做准备
        yArr[y] = max(yArr[y], x);
    }
    for(int i = size-1; i >= 0; i--){
        if(mark[i]){                            //如果输入了 i 为 y
            printf("(%d,%d)",yArr[i],i);      //即找到了第一个输出的
            begin = i-1; x = yArr[i];           //begin和x赋值
            break;
        }
    }
    for(int i = begin; i >= 0; i--){
        if(mark[i]&&yArr[i] > x){               //找到一个 (y输入过并且是极大点)
            printf(",(%d,%d)",yArr[i],i);
            x = yArr[i];
        }
    }
    printf("\n");
    return 0;
}
```

---


# 走路

## 题目背景

小 W 下载了一款运动软件。

## 题目描述

小 W 准备在接下来的 $m$ 天中锻炼，由于他不能走得太多以至于累死（怎么可能呢），所以他这 $m$ 天最多一共只能走 $n$ 步。  
这个运动软件为了激励小 W 走路，推出了 $k$ 种激励措施，每种激励措施都形如“如果你第 $p$ 天中走完了 $q$ 步，那么第 $p$ 天中接下来的每一步都会给你加 $1$ 积分”。**激励措施可以叠加，即走一步你可能可以获得多于 $1$ 积分。**  
现在小 W 想知道，他总计最多可以获取多少积分呢？

## 说明/提示

样例解释：  
只有一种方案，即在第一天走 $5$ 步，第一、二步各获得 $1$ 积分，第三、四步各获得 $2$ 积分，第五步获得 $3$ 积分，总计 $9$ 积分。  
********
数据范围：  
对于 $10\%$ 的数据，$n,m,k\le10$。  
对于 $40\%$ 的数据，$n,m,k \le 10^3$。  
对于 $100\%$ 的数据，$1\le n\le 10^{12}$，$1\le m,k\le 10^5$，$1\le p\le m$，$0\le q\le n$。

## 样例 #1

### 输入

```
5 1 3
1 0
1 2
1 4
```

### 输出

```
9```

# 题解

## 作者：WYXkk (赞：25)

# 题解 走路
一句话：**贪心**即可。

假如有两天，比如第一天和第二天都走了路，设两天走的步数、已获得积分、接下来每步获得的积分分别为 $a_1,a_2,b_1,b_2,c_1,c_2$，不妨设 $c_1\ge c_2$。

如果我们把所有步数都放到第一天，那么我们至少会获得 $b_1+a_2\times c_1$ 分（后面可能还有其他的激励措施）。同时，由于同一天内每一步获得的分数是递增（非严格）的，我们有
$$b_1+a_2\times c_1\ge b_1+a_2\times c_2\ge b_1+b_2$$
所以，如果分数最大，那么必定所有步数都是放在同一天。~~这样不是更容易猝死了吗~~

于是，我们对于每天计算一下如果这天走完所有步可以得到多少积分（直接读入时累加即可），然后取个最大的即可。

$\texttt{code}:$
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

ll a[100005];
ll n,m,k,mx=0;
int main()
{
	rd(n);rd(m);rd(k);
	F(i,1,k) {ll p=rd();ll q=rd();a[p]+=n-q;}
	F(i,1,m) if(a[i]>=a[mx]) mx=i;
	cout<<a[mx]<<endl;
	return 0;
}
```


---

## 作者：zengzhijie54188 (赞：10)

这道题是一道很简单的模拟题，题意也表达得很明确，主要是思路要清晰。
### 主要思路
这道题主要考察我们的贪心策略，让我们求的是 $m$ 天后可以获得的最多积分，经过思考我们可以发现，把所有的步数集中在一天去行走，往往是最佳情况，因为这样可以做到不会被另外一天的需求步数所浪费，只盈不亏。所以我们可以开一个数组把分别每一天的肯以赚的积分存储起来，然后输出最大的。注意，有些激励措施是在同一天的，要把同一天可以获得的积分加起来。模拟以上思路，打起代码就很轻松啦！（详解见代码注释）

上 AC 代码 （c++）
```cpp
#include<bits/stdc++.h>
using namespace std ;
long long n , m , k ; //注意：因为数据非常大，所以每一个数据都得开long long，不然会炸的 
long long a , b , s ;
long long c[99999999] ; //观察数据范围，不想RE就开大点数组 
long long maxn ; //用来记录最大值 
int main()
{
	cin >> n >> m >> k ; //输入相关数据 
	for ( int i = 1 ; i <= k ; i++ ) //分别输入每一个激励措施 
	{
		cin >> a >> b ;
		if ( n - b > 0 ) //判断是否能拿到积分 
		{
			c[a] += ( n - b ) ; //存储这一天可拿积分，同时也处理了激励策略是同一天的情况 
		}
	}
	for ( int i = 1 ; i <= m ; i++ ) //注意是要在有限天数m内查找，不要打成k 
	{
		maxn = max ( maxn , c[i] ) ; //查找m天之中可以拿的最多积分数 
	}
	cout << maxn ; //输出 
	return 0 ; //好习惯 
}
```
希望能帮到大家！


---

## 作者：SIXIANG32 (赞：8)

这道题刚开始一看：这不是DP吗？  
再康康算法标签：**贪心！**  
~~瞬间感觉自己被欺骗了谔谔~~  
重点来了
- 怎么贪心？
- 为什么贪心？

------------
我们先来解答第一个问题：  
根据贪心的原则，**最大的积分一定是在一天内获得的。**

那么为什么是贪心呢？  
这个其实也很简单，因为如果只在一天内完成，可以叠加的积分就不会被浪费了，浪费可耻嘛。  

所以只要我们求出每一天可以获得多少积分再求最大值就可以啦！

-----------
当然神仙WYXkk当然不会让你轻松的过掉，请开```long long```。  

然后愉快的AC就到来啦！
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long sum[10000000];//数组开大点
struct date{//结构体，显得高端……（？）
	long long day,mo;//日期和积分
};
date A[10000000];//结构体数组，也开的贼大
int main()//愉快的开始了主函数
{
	long long n,m,k,maxn=0;//一切都要long long!!!!
	cin>>n>>m>>k;//输入
	for(int p=1;p<=k;p++)//继续输入
	{
		cin>>A[p].day>>A[p].mo;//还是输入
		sum[A[p].day]=sum[A[p].day]+(n-A[p].mo);//划重点了，这是核心，计算它每一次完成任务阔以获得的积分
	}
	for(int p=1;p<=m;p++)
	if(maxn<sum[p])maxn=sum[p];//简单的比大小
	cout<<maxn;//完美的输出
	return 0;//华丽的结束
}
```

---

## 作者：CrystalSunny (赞：5)

# P6023 走路 题解
### 本蒟蒻的第一篇题解，有点慌QAQ
本来是想找DP练习，妹想到是**贪心+模拟**，简直不要太简单好嘛!!!!! ~~指WA了8次~~

------------


这道题思路很简单：

把所有步数集中到一天，稳赚不亏，不会浪费；（小A好不容易叠加那么多，怎么好意思让他结束）

把运动过程全部都模拟，稳稳当当，AC到起飞！

**贪心**嘛，就是这样求每天的最大值~

**模拟**嘛，就是这样老老实实写过程~


------------


------------

再瞟一眼数据范围，ohhhhhhhhhh要开**long long**，当即把所有int改成long long


------------
那么话不多说，上代码（鼓掌掌）

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,ans=0,l=1;//m天最多一共只能走n步,有k种激励措施
struct foot{
	long long p,q; 
}a[100005];//记录每种措施 
bool cmp(foot x,foot y){return x.p<y.p;} 
int main()
{
	cin>>n>>m>>k;
	for(long long i=1;i<=k;i++)
		cin>>a[i].p>>a[i].q;
	sort(a+1,a+1+k,cmp);//按天数顺序排序（从第1天到第k天） 
	for(long long i=1;i<=m;i++)
	{
		long long sum=0;//记录每天积分 
		while(a[l].p==i&&n-a[l].q>=0)
			sum+=n-a[l++].q;//只要是这天的措施，就不断累积 
		ans=max(ans,sum);//求出m天中的最大值 
	}
	cout<<ans;//完结撒花，感谢陪伴(?)
	return 0;
}

```
我的代码指定有问题，有待改进，还请大佬多多指教（鞠躬）

---

## 作者：lndjy (赞：3)

### 直接模拟

模拟每天的步数积分，把所有步数放到一天，这样不会浪费，每天取最大值

代码（看注释）

```
#include<iostream>
#include<vector>
#include<algorithm>
#define ll long long
using namespace std;
ll n,m,k;
vector<ll> num[100005];//步数
int main()
{
	cin>>n>>m>>k;
	ll a,b;
	for(int i=1;i<=k;i++)
	{
		cin>>a>>b;
		num[a].push_back(b);//存储步数
	}
	ll maxx=0;
	for(int i=1;i<=m;i++)//枚举每一天
	{
		ll sum=0,cnt=0;
        for(int j=0;j<num[i].size();j++)
        {
            sum+=n-num[i][j];//计算每一条的积分
        }
        maxx=max(maxx,sum);//取最大值
	}
	cout<<maxx;
	return 0;
}
```


---

## 作者：Lpttor (赞：3)

### 题意简述
在$m$天内一共只能走$n$步，如果在第$p$天走完了$q$步则接下来每一步都可以获得1积分奖励，问最多能获得多少积分。

### 解题思路

先上结论：在某一天内走完所有的$n$步总是最优的。

然后证明：

1. 在任意一天，对任意$i > j$，第$i$步所得积分一定不小于第$j$步所得积分。
- 第$i$步必定满足了第$j$步所满足的奖励要求。
2. 在任意一天，对任意$i < j$，第$i+1$步至第$j$步所得的总积分一定不小于 第$i$步获得的积分$\times (j-i)$，且不大于 第$j$步所得的积分$\times (j-i)$。
- 由结论1可得，第$i+1$步是得分最少的一步，而第$j$步是得分最多的一步。
3. 设第$n$天和第$m$天分别走了$i$步和$j$步，不妨设 第$n$天的第$i$步所得积分 $\geq$ 第$m$天的第$j$步所得积分，则在第$n$天走$i+j$步一定能获得不少于原方案的积分。 

- 第$m$天走$j$步所得的总积分$\leq$第$m$天第$j$步获得的积分$\times j\leq$第$n$天第$i$步获得的积分$\times j \leq$第n天第$i+1$步至第$i+j$步所得的积分。

由结论3即可得出我们所需要的结论，然后寻找能获得最多积分的一天即可。

### AC代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct quests {
	long long d,q;
};
bool operator< (quests a,quests b){
	return a.d==b.d?a.q<b.q:a.d<b.d;
}
quests arr[100010];
int main(){
	//数据最大有10^12，记得开long long
	long long m,n,k,nd=0,score=0,mx=0;
	//nd：当前正处理的天数，score：当前这一天的积分
	cin>>n>>m>>k;
	for(int i=0;i<k;i++){
		cin>>arr[i].d>>arr[i].q;
	}
	sort(arr,arr+k);
	//逐步计算每天所得总积分即可。
	for(int i=0;i<k&&arr[i].d<=m;i++){
		if(nd==arr[i].d){
			score+=(n-arr[i].q);
		} else {
			mx<score&&(mx=score);
			score=0;
			nd=arr[i].d;
			i--;
		}
	}
	mx<score&&(mx=score);
	cout<<mx<<endl;
	return 0;
}
```
~~蒟蒻第一次发题解瑟瑟发抖~~

---

## 作者：chinaxjh (赞：3)

# 前言
又是一道瞎猜的题目，看到样例之后盲猜是要全部放在同一天贪心处理，然后随手写了一发，就过了？？？所以我们现在要来证明它
# 分析
核心思路——贪心

很容易想到全部放在一天可以得到最优解，那么为什么放在一天可以得到最优解吶？如果想看数学的分析，请移步[出题人的题解](https://www.luogu.com.cn/blog/wyxkk-233/post-ti-xie-zou-lu)，我来提供一下感性（雾）的理解

很显然对于好几天而言，如果把步数分在两天或者更多，那么就会有更多的步数是不会被计算积分的，而对于一天来讲，所花的步数越多，所得到积分就一定会更多，被浪费的步数就会越少，所以积分就会最多

代码十分短小简洁
# $\text{Tips}$
开$\color{red}\text{long long}$
# $\text{Code}$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
long long n,m,k,i,x,y,a[N],ans;
int main()
{
	cin>>n>>m>>k;
	for (i=1;i<=k;i++)
	{
		scanf("%lld%lld",&x,&y);
		if (n-y>0) a[x]+=n-y;//注意判断条件，是在总步数大于需求步数才会有积分的
	}
	for (i=1;i<=m;i++)
	ans=max(a[i],ans);//取所有天中的最大值
	cout<<ans<<endl;
}
```
# 后记
对于这一类凭借题面/样例/感觉等可以直接判定的结论可以先用，之后赛后再去论证（如果可以很快证出来可以证），节省比赛中宝贵的时间

---

## 作者：朱屹帆 (赞：1)

### 题目：[P6023 走路](https://www.luogu.com.cn/problem/P6023)
### 题意：~~题目已经讲得很清楚了~~

### 思路：
这一道题有一点巧妙，我一开始做是 _模拟+动规_，但写完以后发现答案有点神奇，即输出答案都是**在同一天的积分最大值！**

后来验证了一下，答案真的是在同一天，这样就很简单了。

但为什么输出答案都是**在同一天的积分最大值**呢？
#### 验证如下：
- 将每一天的能获取的积分最大值求出(假设一天走完$n$步)；

- 如果第$c$天能通过走$n$步获得最多的积分，**那还有方法通过移一点步数到其他天数来获得更多的积分吗？**

  **显然不行！**通过移一点步数到其他天数去，只会减少或和原来一样！
  
  所以，第$c$天平均步数一定是能获得积分最多的步数单位！
 
那么验证就完成了，题目也可以解决了。

### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long read(){
	long long q=0,w=1;
	char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')q=q*10+ch-'0',ch=getchar();
	return q*w;
} //快读，可能比cin和scanf要快一点
const long long N = 1e7+5;
long long n,m,k; //见题目含义
long long x,y,num=1,s[N];
//num是能得到最大积分的数组的下标
//s[i]表示第i天能获得的最大积分
int main(){
	n=read(),m=read(),k=read(); //如题意输入
	for(int i=1;i<=k;i++){
		x=read(),y=read();
		s[x]+=(n>y?(n-y):0);
      /* 三目运算符，等同于：
        if(n>y)s[x]+=(n-y);
        else s[x]+=0;
      */
	}
	for(int i=1;i<=m;i++)
		num=(s[num]>s[i]?num:i);
      /* 等同于：
        if(s[num]>s[i])num=num;
        else num=i;
      */
	cout<<s[num]<<endl;//num是数组下标，要输出数组值
	return 0;
}
```
### 注：
这一道题最简解法有点难想，仔细分析是可以解决的，模拟应该也可以，就是有点麻烦！

这道题正确率有点低呀！

---


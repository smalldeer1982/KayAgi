# [COCI 2010/2011 #2] KNJIGE

## 题目描述

Mirko 有一个由 $n$ 本书组成的家庭图书馆，$n$ 本书在一个狭窄的橱柜中一个接一个地排列。由于在上一任务中对字母进行了很好的训练，他现在希望按字母顺序排列书籍，以使书名字典序排第一的书排在最后，而字典序排最后的书在书橱的底部。

Mirko 可以轻松地将书从书橱中拉出，但是很难将其推回书橱中，因此只能将书放回到书橱的顶部。因此，将书排序籍的唯一可用方法是反复将书籍从书橱中拉出并将其放在书橱的顶部。

这些书按字母顺序用从 $1$ 到 $n$ 的整数标记。因此，Mirko 希望从顶部开始将它们排序为 $(1,2, \cdots ,n)$。例如，如果 $n = 3$ 且开始顺序为 $(3,2,1)$，则两步就足够了。首先，他拉出编号为 $2$ 的书并将其放在最上面，这样书的顺序便变成 $(2,3,1)$。之后，他对编号为 $1$ 的书执行相同操作，因此书的顺序变成 $(1,2,3)$。

计算给定起始顺序，排序完毕所需的最少移动次数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 3 \times 10^5$，书籍的初始摆放顺序为 $1\ldots n$ 的一个排列。

#### 说明

- 本题满分 $80$ 分。

- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) KNJIGE，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。

## 样例 #1

### 输入

```
3
3
2
1```

### 输出

```
2```

## 样例 #2

### 输入

```
4
1
3
4
2```

### 输出

```
2```

# 题解

## 作者：听取MLE声一片 (赞：10)

前面两位大佬把公式发出来了，我就讲一下公式的推导过程。

这里主要是插入排序的思想，就像是打扑克牌，抽到一张扑克牌就往已有的扑克牌里**插入**。这道题说了顺序为1~n，那么从后往前就是n~1。将ans从n递减，与原数字进行比对，如果不等，这个数就应该插入到前面去，ans应该不变。反之，如果相等，ans就-1，比对下一个。

代码就看这（其实差不多）

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[500001],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
        cin>>a[i]; 
	ans=n;
	for(int i=n;i;i--)
		if(a[i]==ans)
            ans--; 
	cout<<ans;
 	return 0;
}
```

谢谢大家！

---

## 作者：_cmh (赞：5)

抢到在洛谷上的第二A来发一篇题解。（感谢神鱼——水题淹死的鱼的提醒！）

easy！

这题贪心就能解决！但是注意，看看时间和空间限制，这么小！所以本题要的应该是复杂度很低的程序。

首先我们读入，然后从后面扫一遍，定义一个变量$ans$等于$n$，找到相同的数$ans$就减$1$。我们发现，$n$后面的数全部都要往前放，$n-1$ ~ $n$……以此类推。就这样扫，然后最后$ans$剩下的就是最少需要移的次数了，直接输出即可。（自己想想为什么）

```
#include<iostream>//头文件真多 
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
using namespace std;
int n,a[300001];//定义变量 
int main(){
	cin>>n;//读入n 
	for(int i=1;i<=n;i++) cin>>a[i];//读入当前情况 
	int ans=n;//ans从最后开始搜 
	for(int i=n;i;i--) //从后往前搜 
		if(a[i]==ans) ans--;//贪心策略 
	cout<<ans;//输出答案 
 	return 0;
}
```


完结撒花，~~无耻求赞~~

---

## 作者：NASFsky (赞：5)

# **P6549 KNJIGE 题解** 
首先读完题目，看了一眼时间的限制和空间的限制，非常小，所以算法应该不会复杂到哪里去。在最乱的情况下，也就是是n~1的一个倒序时，那就需要将每一本书都调整一遍，也就是n遍。但是有些书是已经在原位，是不需要进行调整的。所以每遇到一本不用调整的书就将总次数-1就行了。   
# **AC代码：**
```cpp
#include <bits/stdc++.h>//万能头文件 
using namespace std;
int n,ans;
int a[300001];
int main()
{
	cin>>n;
	ans=n;//先假设是最乱的状况需要调整n次 
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=n;i>=1;i--)if(a[i]==ans)ans--;//每遇到不用调整的次数-1
	cout<<ans;
	return 0;//结束awa 
}
```
这是蒟蒻的第一篇题解，管理员大大求过！  

---

## 作者：Aw顿顿 (赞：3)

## 题意

给定一个由 $1\sim n$ 组成的（可能无序的）序列，每次操作可以把其中的一个数放置到数列开头。

问至少操作几次可以使得这个数列有序？

## 解析

虽然都说是贪心，但是其他题解的解释还是略有抽象。

我们试想排序结束的结果，理当是 $1\sim n$ 按序排列，但是现在显然不是这种情况，那我们应该怎么判断呢？

实际上，如果按序排列从后往前看，我们需要判断出在怎样的情况下一个数会处于一个错误的位置，必须要调整。首先，在一开始不能得到任何条件的情况下，我们认为调整 $n$ 次是一定能够得到正确结果的，但是这个需要调整的数是否始终是 $n$ 呢（换言之，能不能更快呢）？

其实可以改进。我们从后往前遍历，序列应当是 $n\sim 1$ 的，我们可以设 $x=n$ 从后向前比对。

- 如果当前数和我们的 $x$ 一样，说明它不用换位置了，那么我们就可以进行一个操作：$x\leftarrow x-1$。

- 如果不一样呢？考虑 $x$ 的意义，实际上就是需要改变位置的数量，鉴于目前的数不在正确的位置，它需要进行一次操作，那我们与此同时就无须改动 $x$。

我们用一个具体的例子来看待这个猜想：

$$2,5,3,4,1$$

首先，最后一个数就是错误的，于是 $x=5$ 不发生改变。

然后倒数第二、三个数都是错误的，这时候 $x=5$ 继续，直到遇到了一个符合这一条件的 $5$，我们就可以进行改变，使得 $x=4$，进一步向前，在第一个数这里发现不一致，$x$ 无须改变，也就是说我们要进行至少 $4$ 次操作可以得到一个有序的序列。

于是你会发现，我们在扫描的过程中像是插入排序一样，不停的寻找到符合条件的一项进行插入，这个思想是有优越性的。

## 代码 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[300001],x;
// x 表示无须改变位置的数量 
int main(){
	cin>>n;x=n; 
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=n;i>0;i--)
		if(a[i]==x)x--;//如果无需移动，那么 x-- 
	cout<<x<<endl;
 	return 0;
}
```



---

## 作者：SingularPoint (赞：2)

### 题目大意
给出序列a，每次操作将序列中的任意一个元素移动到最前面，求使序列有序的最小操作次数。
### 分析
首先，我们假设所有元素“完全无序”，例如序列：{ 8，7，6，5，4，3，2，1 }，则此时需要进行操作的次数就是 7 次（只有 8 不被移动）。而如果我们将编号最大的书向前移动，变成 { 7，8，6，5，4，3，2，1 } ，可以不被移动的书就变成了 7、8 两本。由此我们可以发现 **已经按照有序的顺序摆放的书本不用被移动。**

但是这还不够，我们来看这个序列：{ 7，1，2，3，4，5，6，8 }。我们发现，尽管这个序列中的 1，2，3，4，5，6 已经按照字典序摆放好了，但是我们依然要进行 6 次操作才能达成目标。因为元素“8”之前的有序元素“7”并没有被正确摆放。所以我们可以得到：**按字典序从大到小排列时，字典序较大的元素与其前一个有序元素之间的所有元素都需要被移动。**

通过以上分析，我们就可以得出本题的解法：**从后向前遍历整个序列，从字典序最大的元素开始，依次按字典序从大到小统计所有已经按顺序摆放的元素，这些元素就可以不被操作。**

分析结束，上代码！
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
int a[300005];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	ans=n;
	for(int i=n;i>=1;i--)
		if(a[i]==ans)	//先假设所有书都需要被操作，ans=n， 
			ans--;	//找到不需要被操作的书后ans--; 
	printf("%d",ans);
}
```
完结撒fa~


---

## 作者：linyinuo2008 (赞：2)

[原题链接](https://www.luogu.com.cn/problem/P6549)

看到大佬们已经说的很详细了，那我来一发。

首先我们考虑最坏的情况，就是从上向下是按从大到小的顺序排的，此时需要调整$n$次。于是我们初始化将$ans$设为$n$。然后开始从顶部向下扫，按照这个顺序，如果碰到的书本编号恰好是已移动次数，那么这本书可以不移，$ans$减一。

下面我们来详细的讨论一下这样为什么就是正解。

我们来看一下这个例子：${4,1,2,3,5}$。此时就是我们所说的“最糟糕的情况”，需要移动五次，尽管$1,2,3$已经被排好了。所以我们仅需要把最大的元素与第二大的元素之间所有的元素都需移动，无论它们是否排的有序。

因此我们可以得出以上的解法：**从书堆上方向下扫，计算已经从大到小排好的元素，这些元素可以不动，其余至少要移动一次。**

希望我的讲解能为大家带来帮助！

上代码（有注释）：

```cpp
#include <iostream>
using namespace std;

const int N=3e5+1;//数组最大空间 
int main()
{
	int res,n,a[N];
	cin>>n;
	res=n;
	//读入书堆 
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=n;i>=1;i--)//注意，这里要从后向前扫！ 
	{
		if(res==a[i]) //我们上面说的策略 
			res--;
	}
	cout<<res<<endl;//输出答案 
	return 0;
}
```

管理员大大求通过！


**若有错误，欢迎指出！**



---

## 作者：qmq菜死了 (赞：1)

## 要求最少移动次数，那这题就应该使用贪心的思路。

这道题有点类似于插入排序和贪心的结合体，思路很简单，要求最少的移动步数，我们就逆着推，看一看那些不需要移动就减掉。时间复杂度是 $O(n)$ 不会超时。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int main()
{
	int n,a[300300];
	cin>>n;
	int ans=n;//假设每本都要移一次，最坏情况
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//正常输入
	}
	for(int i=n;i>=1;i--)//从后往前搜
	{
		if(a[i]==ans)//贪心策略，相等就说明不用移动
		{
			ans--;
		}
	}
	cout<<ans;//输出移动次数
   	return 0;//小心 RE ，养成好习惯
}
```

---

## 作者：lndjy (赞：1)

抢到这题洛谷上的首A之后发一个题解。

首先看数据范围和时空限制，珂以看出要时间复杂度空间复杂度都是O(n)的做法。

然后手推一下，发现n后面的数必须都往前放。然后n-1到n这段的数也要往前放，以此类推，一直往后。

代码：
```cpp
#include<iostream>`
#include<string>
#include<bitset>
using namespace std;
int n,a[300005];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	int ans=n;
	for(int i=n;i>=1;i--)
	if(a[i]==ans)
   	ans--;//能不动的不动，答案-1
	cout<<ans;
	return 0;
}
```


---

## 作者：CoronaQL (赞：0)

是一道贪心题，楼下有许多大佬也发出了公式，只要理解了贪心算法，这道题也不难，关键在于理解ans--这一行。
```cpp
#include<bits/stdc++.h>//因为本来头文件有点多，所以暂时用万能库精简代码 
using namespace std;
int n,a[300001],ans;//数据要求开三乘十的五次方，开在主程序外是个不错的习惯 
int main()
{
	cin>>n;
	ans=n;//关键的一步，我们假设是最倒霉（最乱）的情况n 
	for(int i=1;i<=n;i++)
	{
	     cin>>a[i];//输入 
    } 
	for(int i=n;i;i--)
	{
	    if(a[i]==ans)
	    {
	    	ans--;//贪心算法核心，遇到不需要的就-1 
		}
    } 
	cout<<ans;//数量输出 
 	return 0;//21行程序结束啦qwq 
}
```


---

## 作者：zengzhijie54188 (赞：0)

这道题其实不是很复杂，主要是要掌握其贪心的策略。
### 主要思路
首先，先举出摆好书的最麻烦的次数，也就是每一本书都动一次，就是等于书本的本书 $n$，然后再从后往前推，把那些浪费的次数，也就是不需要移动的书本数减去，就可以得到将其排序好的的最小次数。模拟以上做法，代码就很好实现啦！

上 AC 代码 （c++）
```cpp
#include<bits/stdc++.h>
using namespace std ;
int a[999999] ;
int main()
{
	int n ;
	cin >> n ; //输入书本数目 
	int s = n ; //取最麻烦次数 
	for ( int i = 1 ; i <= n ; i++ )
	{
		cin >> a[i] ; //输入初始摆放顺序 
	}
	for ( int i = n ; i >= 1 ; i-- )
	{
		if ( a[i] == s ) //贪心方案 
		{
			s-- ; //减去不需要移动的 
		}
	}
	cout << s ;  
	return 0 ; //好习惯 
} 
```
希望能帮助到大家！

---

## 作者：L2_sheep (赞：0)

可用数组p来记录每本书的位置。先来看一个例子：3，2，1，4.

因为p[3] < p[4]，所以3不用操作； p[2] > p[3], 把2和1依次放在最前面就完成排序了，答案就是2。

具体代码如下：
```cpp

int main()
{	 
	n = read();
	for(i = 0; i < n; i++){
		p[read()] = i;
	}
	for(j = n, i = n - 1; i && p[i] < p[j]; j = i--);
	printf("%d\n", i);
		
	return 0;
}
```
谢谢观看！祝好！


---


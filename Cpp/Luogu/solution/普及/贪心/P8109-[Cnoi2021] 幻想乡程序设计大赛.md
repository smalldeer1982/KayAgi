# [Cnoi2021] 幻想乡程序设计大赛

## 题目背景

幻想乡，春。

新年的土地吐出稚嫩的幼芽，第一届幻想乡程序设计大赛(Inner-Gensokyo Programming Contest, IGPC)拉开帷幕。作为举办者， Cirno 却有些不得不考虑的事情。

那就是气球的分配问题。



## 题目描述

本场比赛共有 $n$ 道题，Cirno 已经精确预测了每道题目的 AC 队伍数 $a_1,a_2,a_3,\cdots,a_n$。但由于经费限制，主办方 $n$ 种颜色的气球分别只准备了 $b_1,b_2,b_3,\cdots,b_n$ 个。

而 Cirno 需要合理地安排每道题目对应的气球颜色，使得能派发的气球尽可能多。

显然地，每道题目只能对应一种颜色的气球，每种颜色的气球只能对应一道题目，如果一道题有队伍通过但该种颜色的气球已经发完了，则很遗憾，该队拿不到这种气球了。

由于这个问题过于 trival，于是 Cirno 决定将这个任务分配给你。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据保证 $1 \le n \le 10^5$，$0 \le a_i,b_i \le 10^4$，且 $\{a_n\},\{b_n\}$ 单调不降。

**子任务**

Subtask1（$60$ points）：$n \le 8$。

Subtask2（$40$ points）：无特殊限制。

## 样例 #1

### 输入

```
5
1 2 3 4 5
2 3 3 3 3```

### 输出

```
12```

# 题解

## 作者：cff_0102 (赞：18)

## P8109 [Cnoi2021]幻想乡程序设计大赛 题解

upd at $2022/2/9$：有人举报了这道题的多个题解（虽然没有我的），吓得我赶紧补充一下分配方法的说明。

upd at $2022/2/10$：管理员撤掉了这道题的所有题解，我赶紧再补充一下分配方法的说明。

upd at $2022/2/11$：改正题解中的错误并增加补充说明。

------------

### 思路：

既然这道题由红改黄了（~~虽然现在改回橙了~~又改回黄了），那大家就能看出这一道题实际上考的是一一对应直接得到答案就正确的证明过程。

这道题，我们使用贪心算法。**尽量给 AC 队伍多的题目选多的气球，就可以尽量多的配对气球**，也就是需要一一对应。证明如下：

------------
### 证明：

这道题可以转化成要证明“**最后分配方案存在 $a_i\le a_j$，且 $i>j$（逆序）的情况可能会比存在 $a_i\le a_j$，且 $i<j$（正常顺序）的情况答案更好**”是**错误、不存在的**。

**假设**现在有配对好的两队和两组气球，分别为 $a_i,a_j,b_i,b_j$，**满足 $a_i\le a_j$，且 $i>j$（也就是逆序）**。我们要列出情况证明最终按顺序对应的配法，配对答案是最优的。

假设让它们逆序匹配的方法（$a_i$ 配对 $b_i$，$a_j$ 配对 $b_j$，配对答案是 $\min{(a_i,b_i)}+\min{(a_j,b_j)}$）是最优的，那么就有 $b_i\ge b_j$。分成 $16$ 种情况分类讨论 $a_i$ 和 $b_i$，$a_i$ 和 $b_j$，$a_j$ 和 $b_i$，$a_j$ 和 $b_j$ 之间的数量关系。后面说“原方法”就是逆序匹配，“新方法”就是顺序匹配（即 $a_i$ 配对 $b_j$，配对答案是 $\min{(a_i,b_j)}+\min{(a_j,b_i)}$）。要证明的就转化为了**证明不存在“原方法比新方法更优”的情况。**

1. $a_i<b_i,a_i<b_j,a_j<b_i,a_j<b_j$。此时 $a_i\le a_j\le b_j\le b_i$，原方法和新方法答案都是 $a_i+a_j$，这种情况原方法并不比新方法更优。

1. $a_i<b_i,a_i<b_j,a_j<b_i,a_j>b_j$。此时 $a_i\le b_j\le a_j\le b_i$，原方法答案是 $a_i+b_j$，新方法答案是 $a_i+a_j$，因为 $a_j>b_j$，所以这种情况原方法并不比新方法更优。

1. $a_i<b_i,a_i<b_j,a_j>b_i,a_j<b_j$。此时出现 $a_j>b_i\ge b_j$，但 $a_j<b_j$，所以矛盾，该情况不存在。 

1. $a_i<b_i,a_i<b_j,a_j>b_i,a_j>b_j$。此时 $a_i\le b_j\le b_i\le a_j$，原方法答案是 $a_i+b_j$，新方法答案是 $a_i+b_i$，因为 $b_i\ge b_j$，所以这种情况原方法并不比新方法更优。

1. $a_i<b_i,a_i>b_j,a_j<b_i,a_j<b_j$。此时 $a_i>b_j>a_j$，但 $a_i\le a_j$，所以该情况也不存在。

1. $a_i<b_i,a_i>b_j,a_j<b_i,a_j>b_j$。此时 $b_j\le a_i\le a_j\le b_i$，原方法答案是 $a_i+b_j$，新方法答案是 $b_j+a_j$，因为 $a_i\le a_j$，所以这种情况原方法并不比新方法更优。

1. $a_i<b_i,a_i>b_j,a_j>b_i,a_j<b_j$。此时出现 $a_j>b_i>a_i$，但 $a_i\le a_j$，所以该情况也是不存在的。

1. $a_i<b_i,a_i>b_j,a_j>b_i,a_j>b_j$。此时 $b_j\le a_i\le b_i\le a_j$，原方法答案是 $a_i+b_j$，新方法答案是 $b_j+b_i$，因为 $a_i<b_i$，所以这种情况原方法并不比新方法更优。

1. $a_i>b_i,a_i<b_j,a_j<b_i,a_j<b_j$。此时 $b_i<a_i<b_j$，但 $b_i\ge b_j$，所以该情况不存在。

1. $a_i>b_i,a_i<b_j,a_j<b_i,a_j>b_j$。此时 $b_i<a_i<b_j$，但 $b_i\ge b_j$，所以该情况不存在。

1. $a_i>b_i,a_i<b_j,a_j>b_i,a_j<b_j$。此时 $b_i<a_i<b_j$，但 $b_i\ge b_j$，所以该情况不存在。

1. $a_i>b_i,a_i<b_j,a_j>b_i,a_j>b_j$。此时 $b_i<a_i<b_j$，但 $b_i\ge b_j$，所以该情况不存在。

1. $a_i>b_i,a_i>b_j,a_j<b_i,a_j<b_j$。此时 $a_i>b_i>a_j$，但 $a_i\le a_j$，也出现矛盾。

1. $a_i>b_i,a_i>b_j,a_j<b_i,a_j>b_j$。此时 $a_i>b_i>a_j$，但 $a_i\le a_j$，也出现矛盾。

1. $a_i>b_i,a_i>b_j,a_j>b_i,a_j<b_j$。此时 $b_j>a_j>b_i$，但 $b_i\ge b_j$，同样出现矛盾。

1. $a_i>b_i,a_i>b_j,a_j>b_i,a_j>b_j$。此时 $b_j\le b_i\le a_i\le a_j$，原方法和新方法答案都是 $b_i+b_j$，所以这种情况原方法并不比新方法更优。

综上所述，在所有存在的情况中，逆序答案永远不比顺序答案更优，那么我们就可以一直用顺序答案，既然在每两对中都是按顺序答案更优，那么我们就按从小到大（从大到小也一样）的顺序来配对气球就可以了。


------------

### 代码实现：

所以在排序好的两个数组中，直接一一对应进行比较就行了。这个必然是最优方案。对于第 $i$ 道题，如果 $b_i$ 更多，能发的气球就有 $a_i$ 个，否则就有 $b_i$ 个。所以第 $i$ 道题可以让队伍拿到 $\min{(a_i,b_i)}$ 个气球。那么答案就是 $\sum\limits^{n}_{i=1}\min{(a_i,b_i)}$ 了。

```cpp
#include<bits\stdc++.h>
using namespace std;
int n,a[100005],b[100005];//如题的变量
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>a[i];
	}
	for(int i=0;i<ᥒ;i++){
		cin>>b[i];
	}//输入部分
    	
	//题目保证数据单调不降，不用排序
    	
	int s=0;//存储答案
	for(int i=0;i<n;i++){//直接顺序比较，所有5种情况都是顺序更优
		s+=min(a[i],b[i]);//选更小的那个 
	}//计算
	cout<<s;//输出 
	return 0;//不要忘了
}
```
望管理能过这篇题解。

---

## 作者：_cmh (赞：9)

[原题传送门~](https://www.luogu.com.cn/problem/P8109)

### $\texttt{Solution}$

由于 $\{a_n\},\{b_n\}$ 单调不降，设 $x+1\le y$，则有 $a_x\le a_y,b_x\le b_y$。

则有 

$$\min\{a_y,b_y\}-\min\{a_x,b_y\}\ge\min\{a_y,b_x\}-\min\{a_x,b_x\}$$

变形，得

$$\min\{a_x,b_x\}+\min\{a_y,b_y\}\ge\min\{a_x,b_y\}+\min\{a_y,b_x\}$$

观察，可以发现，对应分配即可实现利益最大化。

所以答案即为 $\sum\limits_{i=1}^n\min\{a_i,b_i\}$。

时间复杂度为 $\mathcal{O}(n)$，可以通过此题。

### $\texttt{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int a[N];
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]); 
	int ans=0;
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		ans+=min(a[i],x);
	}
	printf("%d",ans);
    return 0;
}
```


---

## 作者：Rnfmabj (赞：8)

### 题意

给定两个单调不降的数组 $a$ ， $b$ ，求一种匹配方案使得 $ans= \sum_{i=1}^nmin(a_i,b_i)$ 最大。



------------


### 思路

> 另外我很想讨论一下本题的难度

> 本题的做题难度非常的低，可以标红-橙，但是解题难度比较高，我个人认为有绿

>    >选手A：读错题了，没看到可以重排，直接过了

>    >选手B：没读错题，想了想出题人为什么排序，于是直接写了一个正序交上去，过了

[以上](https://www.luogu.com.cn/discuss/407689) By [WYXkk](https://www.luogu.com.cn/user/130151) Orz

确实，这题作为月赛第一题做题难度确实不大， ~~多少咕值猎手下了月赛直接就开始码题解了~~ ，很容易就能凭各位的数感反应过来：直接正序比较每个下标对应的元素较小值就好了，把它们累加起来然后打印，满分到手。

而且还要感叹一句出题人真良心，排序都不用自己动手，直接保证了单调不降，感动你谷。

那么问题来了，为啥上面的方案是正确的？

有些同学开始了感性理解，“啊这里贪心一下让小的数物尽其用”，“大的数和小的数在一起不是浪费吗”，甚至还有“啊反正这么交全绿了能过就好”。

实际上，有这样的思维方式很容易在 OI 赛制的比赛中吃亏。如果对得出来的结论不加思考的话，那么考场上往往会得不偿失，被刻意构造的数据叉得连连失分。例子有很多，但不列举。

我们需要证明这个结论的正确性。

我们的结论是：将 $a$ 、 $b$ 序列排序后，有$ans_{max}= \sum_{i=1}^nmin(a_i,b_i)$

即累加排序后同一位置的较小值得到的和为最大答案。

首先，总共的方案共计 $n!$ 个，情况数有限，故一定有答案最大的方案。

假设我们的原方案不是这个最大方案，那么就一定有一个顺序异于原方案的匹配方式使得答案最大。即相对于排序后的数组 $a$ 或 $b$ （下面假设是 $a$ ）而言至少存在一组逆序对 $(i,j)$ （其中 $i<j$ ），使得 $a_i>a_j$ 。

接下来我们分类讨论这个逆序的过程：（已去掉其中矛盾的情况）

1. $a_i<b_i$ ， $a_j<b_j$ ，$a_j>b_i$

此时原答案为 $a_i+a_j$ ， 逆序后为 $b_i+a_i$ ，由于 $a_j>b_i$ 故新答案更小。

2. $a_i<b_i$ ， $a_j<b_j$ ，$a_j<b_i$

此时原答案为 $a_i+a_j$ ， 逆序后为 $a_j+a_i$ ，无差别，旧答案不会更小。

3. $a_i>b_i$ ， $a_j<b_j$ ，$a_j>b_i$

此时原答案为 $b_i+a_j$ ， 逆序后为 $b_i+a_i$ ，新答案更小。

4. $a_i<b_i$ ， $a_j>b_j$ ，$a_j>b_i$

此时原答案为 $a_i+b_j$ ， 逆序后为 $b_i+a_i$ ，新答案更小。


5. $a_i>b_i$ ， $a_j>b_j$ ，$a_i<b_j$

此时原答案为 $b_i+b_j$ ， 逆序后为 $b_i+a_i$ ，新答案更小。

6. $a_i>b_i$ ， $a_j>b_j$ ，$a_i>b_j$

此时原答案为 $b_i+b_j$ ， 逆序后为 $b_i+b_j$ ，无差别，旧答案不会更小。

由上可以看出，若逆序后答案更新，则答案一定由于 $(i,j)$ 位置上较小值变小导致更新，故新答案不会更大，假设不成立，原命题成立，原方案得到的答案最大。

简单来说，我们已知存在一个最优的方案，正序的方案是一个较优的方案且非正序的方案都不优于正序方案，那么正序就是最优。

~~我是第二没人能当第一，那么我就是第一！~~

------------

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R read()
#define file(a) freopen(#a".in","r",stdin),freopen(#a".out","w",stdout)
using namespace std;
inline ll read() {
	ll s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f*=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*f;
}
inline void write(ll x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10),x%=10;
	putchar('0'+x);
}//Don't use it for CF.
inline void wk(ll x){write(x);putchar(' ');}
inline void we(ll x){write(x);putchar('\n');}//以上为快读快写。
ll n,ans;
ll a[100005],b[100005];
signed main(){
	n=R;
	for(ll i=1;i<=n;i++)a[i]=R; 
	for(ll i=1;i<=n;i++)b[i]=R;//读入两个数组。
	for(ll i=1;i<=n;i++)ans+=(min(a[i],b[i]));//题目已经保证单调不降，那么我们直接比较即可。
	we(ans);//打印答案。
	return 0;
}
```


---

## 作者：fast_photon (赞：5)

Upd @2022.2.10 对题解中1处叙述不清，2处 $\LaTeX$ 和中文标点间的空格，一处 $\LaTeX$ 中大括号直接使用`{}`而不是`\{\}`，~~以及一个代码中严重影响蚂蜂的空格缺失~~进行了修正。  
Upd @2022.2.10 看了下管理的贴，完善一下对于极大和最大的说明（其实之前也有，但是没把重点放这里，写的不行），写的更棒棒了

[博客](https://www.luogu.com.cn/blog/fast-photon/ti-xie-p8109-post)食用更佳~  
[原题](https://www.luogu.com.cn/problem/P8109)  

**题目大意**  
给定两个数组 $\{a_n\}$ 和 $\{b_n\}$，元素个数均为 $n$ 个，对 $\{b_n\}$ 重新排列使得 $\sum_{i=1}^n{\min(a_i,b_i)}$ 最大化。数据保证 $\{a_n\}$ 和 $\{b_n\}$ 不降。  
注：也就是表示对于所有的 $i$，在 $a_i$ 和 $b_i$ 中取较小值，然后求和，让这个和最大。  

**简要分析**  
首先我们可以看出，在一个数组中，无论最后如何排列，都可以从不降的状态多次次交换一对前小后大的数据得到，也就是对于 $\{x_n\}$ 的一种排列方式 $\{y_n\}$，一定有一种方式，进行多次交换 $x_i$ 和 $x_j$ 得到 $\{y_n\}$  
其实这个不难证明，但是为了题解过审我交代一下。  
设序列 ${x_n}$ 不降，即对于 $1\le i<n$ 有 $x_i\le x_{i+1}$，则可以通过如下方式进行交换：  
交换 $x_k$,$x_n$（$x_k$ 和 $y_n$ 是一样的，并且显然 $x_k\le x_n$）  
这样的话 $x_n$ 和 $y_n$ 就一样了。然后对前 $n-1$ 个继续进行交换。  

因为好像没有这个词，我们定义“劣化”就是负优化。  
那么如果可以证明对于 $a_1\le a_2$ 以及 $b_1\le b_2$，无论如何都是最优情况即交换的话结果更劣，那么由上面的证明可以得到，任何一个非不降排列的排列都可以由不降排列进行多次劣化得到。  
该证明如下：  
假设交换的是 $b_i$ 和 $b_j$，如果 $b_i=b_j$ 或者 $a_i=a_j$，那么结果并不会变化，因为影响结果的只是每一对数的具体数值，而不是它们之间的顺序。

**推式子**  
设 $a_1<a_2$（因为 $a_1=a_2$ 没有交换的必要，所以不是 $a_1\le a_2$），$b_1<b_2$（同理），并进行分类讨论。 

**当 $\bm{a_1<b_1,a_2<b_2}$**  
即 $a_1<b_1<b_2,a_1<a_2<b_2$  
原本的结果为 $a_1+a_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)=a_1$，而 $\min(a_2,b_1)\le a_2$，也就是交换后要么变小要么不变。  
所以这种情况无需交换。  
**当 $\bm{a_1<b_1,a_2>b_2}$**  
即 $a_1<b_1<b_2<a_2$  
原本的结果为 $a_1+b_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)=a_1$，而 $\min(a_2,b_1)<a_2$，也就是交换后一定变小。  
所以这种情况也无需交换。  
**当 $\bm{a_1>b_1,a_2<b_2}$**  
即 $b_1<a_1<a_2<b_2$  
原本的结果为 $b_1+a_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)=a_1<a_2$，而 $\min(a_2,b_1)=b_1$，也就是交换后不可能变大。  
所以这种情况依然无需交换。  
**当 $\bm{a_1>b_1,a_2>b_2}$**  
即 $b_1<a_1<a_2,b_1<b_2<a_2$  
原本的结果为 $b_1+b_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)\le b_2$，而 $\min(a_2,b_1)=b_1$，也就是交换后不可能变大。  
**所以所有情况都不用交换。也就是说，出题人已经把最优排列方式送给我们了，我们只需要直接计算即可。**  

~~最令人期待的~~**代码**  
```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

int n, a[100005], b[100005];
long long sum; //不开LL这题好像也能过，但我不信任出题人。

int main() {
	scanf("%d", &n);
	for(int i = 0; i < n; i++) {
		scanf("%d", &a[i]); 
	}
	for(int i = 0; i < n; i++) {
		scanf("%d", &b[i]);
		sum += min(a[i], b[i]);
	}
	printf("%lld", sum);
}
```

---

## 作者：Natori (赞：4)

# P8109 [Cnoi2021]幻想乡程序设计大赛 Solution

[题目传送门](https://www.luogu.com.cn/problem/P8109)

本题难点在于数列 $\left\{a_n\right\}$、$\left\{b_n\right\}$ **并不是一一对应的**，因此就没办法直接计算。

~~要是对应那谁都会~~

但是不难发现，如果有 $a_1 \le a_2$ 且 $b_1 \le b_2$，则有：

$$\min(a1,b1)+\min(a2,b2)\ge \min(a2,b1)+\min(a1,b2)$$

~~LaTeX真的难打~~

**证明**：

设函数：

$$f(x)=\min(a2,x)-\min(a1,x) (a_1 \le a_2)$$

若有 $b_1 \le b_2$，则有 $f(b1) \le f(b2)$，

所以：

$$\min(a2,b1)-\min(a1,b1) \le \min(a2,b2)-\min(a1,b2)$$

即：

$$\min(a1,b1)+\min(a2,b2)\ge \min(a2,b1)+\min(a1,b2)$$

得证。

# 这结论有啥用？

试想如果整个数列 $\left\{a_n\right\}$、$\left\{b_n\right\}$ 都是严格不降的，

那么对于任意整数 $i(1 \le i \le n-1)$，都有 $a_{i-1} \le a_i$ 且 $b_{i-1} \le b_i$。

因此对于整个数列 $\left\{a_n\right\}$、$\left\{b_n\right\}$，都有上面你自己手推的结论。

同时你高兴地发现出题人已经良心地帮你把序排好了。~~说明这就是正解~~

于是我们得到了本题的贪心思路：

- 把 $b_i$ $(1 \le i \le n)$ 作为第 $i$ 道题的气球，把它和 $a_i$ 配对，答案才能最佳。

那么接着考虑。

对于任意整数 $i(1 \leq i \leq n)$ 就有两种情况：

- 当 $a_i \leq b_i$ 时，第 $i$ 种气球准备得足够，最多就是**给每个队发一个气球**，对答案的贡献就是 $a_i$。

- 当 $a_i > b_i$ 时，第 $i$ 种气球准备得不够，最多是把气球**全部发出去**，对答案的贡献就是 $b_i$。

综合两种情况，我们发现每个 $i$ 对答案的贡献实际上就是：

$$\min (a_i,b_i)$$

答案就是：

$$\sum\limits_{i=1}^n\min(a_i,b_i)$$

因此直接把数列扫一遍累加即可，时间复杂度 $O(n)$。

代码（注意开 $\text{long long}$ 更保险）：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long read(){
	long long f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}
void write(long long x){
	if(x<0)x=-x,putchar('-');
	if(x>9)write(x/10);
	putchar(x%10+'0');
}
const int N=1e5+1;
int n;
long long a[N],b[N];
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		b[i]=read();
	long long ans=0;
	for(int i=1;i<=n;i++){
		ans+=min(a[i],b[i]);
	}
	write(ans);
	return 0;
}
```
补了一下结论的证明，希望能帮到大家。

---

## 作者：lzyqwq (赞：4)

这题我们可以用贪心法求证。设 $i<j$，我们考虑对应分配和错位分配。有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)$

错位分配：$\min(a_i,b_j)+\min(a_j,b_i)$

由于 $a$ 和 $b$ 单调不降，所以 $a_i\leqslant a_j,b_i\leqslant b_j$，我们分类讨论。

### 一、$a_j\geqslant a_i\geqslant b_j \geqslant b_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=b_i+b_j$

错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=b_j+b_i$

此时**两者一样**。

### 二、$a_j \geqslant b_j \geqslant a_i \geqslant b_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=b_i+b_j$

错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $b_j \geqslant a_i$，所以**对应分配更优**。

### 三、$a_j \geqslant b_j \geqslant b_i \geqslant a_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=a_i+b_j$

错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $b_j \geqslant b_i$，所以**对应分配更优**。

### 四、$b_j \geqslant b_i \geqslant a_j \geqslant a_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=a_i+a_j$

错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+a_j$

此时**两者一样**。

### 五、$b_j \geqslant a_j \geqslant b_i \geqslant a_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=a_i+a_j$

错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $a_j \geqslant b_i$，所以**对应分配更优**。

### 六、$b_j \geqslant a_j \geqslant a_i \geqslant b_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=b_i+a_j$

错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $a_j \geqslant a_i$，所以**对应分配更优**。

综上所述，我们发现**对应分配更优**，所以最后的答案就是 $\sum\limits_{i=1}^n\min(a_i,b_i)$。

# AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
int a[N];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
    }
    int s=0;
    for(int i=1;i<=n;i++)
    {
        int b;
        scanf("%d",&b);
        s+=min(a[i],b);//取最小值并相加
    }
    printf("%d\n",s);
    return 0;
}
```
完结撒花，跪求过审 orz

---

## 作者：Code_星云 (赞：3)


### $\mathbf\color{Maroon}题目大意$

两个单调不下降的数组 $A,B$ 中，对于 $\forall \ a_i\in A$  , $\forall \ b_i \in B$ ，匹配出 $n$ 对 $(a_i , b_i)$ , 将第 $i$ 组最小值记为 $min_i$ , 求出一种方案使得 $\sum\limits_{i=1}^nmin_i$ 最大并将最大值输出。


------------
如果我们将$A,B$排序，使得$A_{min_i}$与$B_{min_i}$匹配，是不是就可以求出最大能获得的收益了呢？显然可以。

但是 $\mathbf{\color{OrangeRed}贪心}$ 是需要证明的，那我就来简略证明一下吧。

假设 $A,B$ 两个数组都已经排好序（单调不下降序）。  
则有 $a_1,a_2,a_3...a_n$ 分别与  
$\ \ \ \ \ \ \ \ b_1,b_2,b_3...b_n $匹配。  
若交换 $b_1$ 和 $b_n$ 的位置，则有两种情况。

$1$.若 $a_1$ $\le$ $b_1$ , 则交换后一定能把 $a_1$ 取完，与不交换时一样，而由于 $b_1 \le b_n$ ，则将 $a_n$取走的数量一定不比开始优。因此不如不换。  
$2$.若 $a1>b1$ ，则交换后 $a_n$ 被取走的分数一定不比开始优，而$a_1$ 要么被取完，要么仍然不可以被取完。此时，又有多种情况。  
$\ \ \ \ \ \ \ \ $若 $b_n>a_n$ && $b_1>a_n$ ，则 $b_1 $也一定大于$a_1$，因为$a_n \le a_1$。因此这种情况的话，交换后与交换前所获得的收益一样。  
$\ \ \ \ \ \ \ \ $若$b_n>a_n$ && $b_1<a_1$ 则交换后 $a_1$能被取完，但 $b_n$ 却只能最多被取 $b_1$的大小则交换后收益为$a_1 + b_1$，但交换前的收益为$a_n+b_1$ ,提取同项$b_1$，而$a_1 \le a_n$，因此不可能更优。
$\ \ \ \ \ \ \ \ $

综上所述，将排序后的 $A,B$ 按位匹配可以得到最优解。


------------
## $\mathbf{\color{Purple}代码：}$
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int a[100005];
int b[100005];
long long ans=0;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	  cin>>a[i];
	for(int i=1;i<=n;i++)
	  cin>>b[i];
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++){
		ans+=min(a[i],b[i]);
	}
	cout<<ans;
}

```


---

## 作者：Ginger_he (赞：2)

# 题解
不难发现，最后答案为 $\sum\min\{a_i,b_i\}$，首先从两个数证明，即若 $a_1\le a_2,b_1\le b_2$，则 $\min\{a_1,b_1\}+\min\{a_2,b_2\}\ge\min\{a_1,b_2\}+\min\{a_2,b_1\}$。   
令 $x=\min\{a_1,b_1\}+\min\{a_2,b_2\},y=\min\{a_1,b_2\}+\min\{a_2,b_1\}$  
若 $a_1\le a_2\le b_1\le b_2,x=a_1+a_2=y$；  
若 $a_1\le b_1\le a_2\le b_2,x=a_1+a_2=y$；  
若 $a_1\le b_1\le b_2\le a_2,x=a_1+b_2\ge a_1+b_1=y$；  
其余情况交换 $a,b$ 即可变为上述情况。  
我们将这个二元不等式推广到 $n$ 元即可得到 $\sum\min\{a_i,b_i\}$。

---

## 作者：jxbe6666 (赞：2)

Update 2022/2/13 添加了证明过程

这是一道黄题，代码虽然简单，但是如何得出贪心策略，就略微有点小难度了。

### 题意：

- 给定一个整数 $n$，表示共有 $n$ 道 AC 队伍和 $n$ 种颜色的气球。
- 每道 AC 队伍只能对应一种颜色的气球，同样每种颜色的气球只能对应一个队伍。
- 求气球最多能派发多少个。

### 思路：

由于题目保证每道 AC 队伍数，与气球个数单调不降，那么按编号对应就是最优的气球分发方案。每种颜色的气球，取的就是 $\min(a_i,b_i)$。最后输出总气球数。

给出证明：
这题我们可以用贪心法分类讨论。设 $i<j$，我们考虑对应分配和错位分配。有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)$  
错位分配：$\min(a_i,b_j)+\min(a_j,b_i)$
由于 $a$ 和 $b$ 单调不降，所以 $a_i\leqslant a_j,b_i\leqslant b_j$ ，我们分类讨论。

一、$a_j\geqslant a_i\geqslant b_j \geqslant b_i$，则有： 

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=b_i+b_j$   
错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=b_j+b_i$ 

此时两者**一样**。

二、$a_j \geqslant b_j \geqslant a_i \geqslant b_i$ 则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=b_i+b_j$   
错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $b_j \geqslant a_ib$ ，所以**对应分配**更优。

三、$a_j \geqslant b_j \geqslant b_i \geqslant a_i$ 则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=a_i+b_j$
错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $b_j \geqslant b_i$，所以对应分配更优。

四、$b_j \geqslant b_i \geqslant a_j \geqslant a_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=a_i+a_j$
错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+a_j$

此时两者**一样**。

五、$b_j \geqslant a_j \geqslant b_i \geqslant a_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=a_i+a_j$
错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $a_j \geqslant b_i$，所以**对应分配**更优。

六、$b_j \geqslant a_j \geqslant a_i \geqslant b_i$，则有：

对应分配：$\min(a_i,b_i)+\min(a_j,b_j)=b_i+a_j$
错位分配：$\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i$

因为 $a_j \geqslant a_i$，所以**对应分配**更优。

综上所述，我们发现**对应分配**更优，所以最后的答案就是 $\sum\limits_{i=1}^n\min(a_i,b_i)$ 
### AC Code：
```cpp
#include <bits/stdc++.h>
#define I return
#define AK 0
#define IOI ;
#define ll long long
using namespace std;
const ll N = 1e6 + 5;
ll a[N], b[N], dp[N], n, m, x, y, ans;
double s, sum;
string s1, s2;
map<int, int> a_map;
inline ll read()
{ // 快读
    ll number = 0, check = 1;
    char ch = getchar();
    while (ch < 48 || ch > 57)
    {
        check = (ch == 45) ? -1 : 1;
        ch = getchar();
    }
    while (ch >= 48 && ch <= 57)
    {
        number = number * 10 + ch - '0';
        ch = getchar();
    }
    return number * check;
}
inline void out(ll x)
{
    if (x < 0)
    {
        x = ~(x - 1);
        putchar('-');
    }
    if (x > 9)
        out(x / 10);
    putchar(x % 10 + '0');
}
inline void write(ll x, char ch)
{ // 快输
    out(x);
    putchar(ch);
}
int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
    }
    for (int i = 1; i <= n; i++)
    {
        ans += min(a[i], read());// 取最小值
    }
    out(ans);
    I AK IOI
}
```

---

## 作者：LinTianHao_ (赞：1)

# 题解

------------

### 简要分析

本题核心：求题目与气球的最优对应方案，使得能派发的气球数最多。在一个方案中，所有的两种可能情况如下：

1. AC 数不小于气球数

此时气球能够全部派发；

2. AC 数小于气球数

此时气球不能全部派发，只能派发与 AC 数相等的气球。

**下面证明一个事实：假设题目 AC 数按单调不降顺序排列，则当气球数也按单调不降顺序排列时，为一个最优方案。**

证明思路：按照上述方案排列时，无论如何调换顺序，都不能使方案更优。

根据可能出现的两种情况，将题目与气球的对应关系分成两类，即：

1. AC 数不小于气球数，记为 A 组；

2. AC 数小于气球数，记为 B 组。

下面进行调换：

1. 取 A 组 $b_i$ 与 A 组 $b_j$ ($i<j$)调换：

由于调换前气球已经全部派发，故调换一定不会使方案更优。

2. 取 A 组 $b_i$ 与 B 组 $b_j$  调换：

- 若 $i<j$，则有 $b_i≤a_i≤a_j<b_j$。调换前派发气球数为 $b_i+a_j$，调换后派发气球数为 $a_i+b_i$，不能使方案更优。

- 若 $i>j$，则有 $a_j<b_j≤b_i≤a_i$。调换前派发气球数为 $b_i+a_j$，调换后派发气球数为 $b_j+a_j$，不能使方案更优。

故不能使方案更优。

3. 取 B 组 $b_i$ 与 B 组 $b_j$ ($i<j$)调换：

调换前派发气球数为 $a_i+a_j$，调换后，由于 AC 队伍已全部拿到气球，故派发气球数不会超过 $a_i+a_j$，故不会使方案更优。

4. 取多于两个对应关系调换时，等效于进行多次两两调换，每次调换都不会使方案更优。

综合上述4种情况，证毕。

### AC 代码

基于以上最优方案可以写出代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

int a[100005],b[100005],n,sum=0;

int main(){

    cin>>n;

    for(int i=1;i<=n;i++)

    cin>>a[i];

    for(int i=1;i<=n;i++)

    cin>>b[i];

    for(int i=1;i<=n;i++)

    sum+=min(a[i],b[i]);

    cout<<sum;

    return 0;

}
```

---

## 作者：KiloP (赞：1)

很显然，因为 $a,b$ 不降，那么答案为
$$
\sum_{i=1}^n\min(a_i,b_i)
$$
下面给出当 $a,b$ 单调时，答案最优的证明。

不妨设 $a$ 单调上升。

反证法，假设存在 $1\le i<j\le n,b_i>b_j$，并且答案最优，下面证明 $\min(a_i,b_i)+\min(a_j,b_j)\le\min(a_i,b_j)+\min(a_j,b_i)$

1. $a_i<a_j\le b_j<b_i$

$$
\min(a_i,b_i)+\min(a_j,b_j)=\min(a_i,b_j)+\min(a_j,b_i)=a_i+a_j
$$

2. $a_i\le b_j<b_i\le a_j$

$$
\begin{aligned}
a_i+b_j&=\min(a_i,b_i)+\min(a_j,b_j)\\&<\min(a_i,b_j)+\min(a_j,b_i)=a_i+b_i
\end{aligned}
$$

3. $ b_j<b_i\le a_i<a_j$

$$
\min(a_i,b_i)+\min(a_j,b_j)=\min(a_i,b_j)+\min(a_j,b_i)=b_i+b_j
$$

4. $b_j\le a_i\le b_i\le a_j$

$$
\begin{aligned}
a_i+b_j&=\min(a_i,b_i)+\min(a_j,b_j)\\&\le\min(a_i,b_j)+\min(a_j,b_i)=b_i+b_j
\end{aligned}
$$

5. $a_i\le b_j\le a_j\le b_i$

$$
\begin{aligned}
a_i+b_j&=\min(a_i,b_i)+\min(a_j,b_j)\\&\le\min(a_i,b_j)+\min(a_j,b_i)=a_i+a_j
\end{aligned}
$$

6. $b_j\le a_i<a_j\le b_i$

$$
\begin{aligned}
a_i+b_j&=\min(a_i,b_i)+\min(a_j,b_j)\\&<\min(a_i,b_j)+\min(a_j,b_i)=a_j+b_j
\end{aligned}
$$

因此，对于 $1\le i<j\le n,b_i>b_j$，将 $b_i$ 与 $b_j$ 交换，必定不更劣。

从而，当 $a,b$ 单调时，答案最优（不必任意其他构造劣）。得证。$\blacksquare$

代码不附了。


---

## 作者：jzcrq (赞：1)

### 题目概述

有 $n$ 道题与 $n$ 种颜色的气球。

第 $i$ 题通过队伍有 $a_i$ 支。

第 $i$ 种颜色的气球有 $b_i$ 个。

一题对应一种颜色的气球，一支通过队伍可以拿或不拿一个对应颜色的气球。

求发出去最多气球数。

因为一道题只能对应一种颜色；一道题和一种颜色配对之后，这种颜色气球发出的个数就是这道题通过的队伍数与这种颜色气球个数的最小值。

所以，我们贪心让气球个数少的颜色和通过队伍少的题配对。

以下为该贪心的证明。

---

### 贪心证明

我们设每组配对的队伍和颜色可以发出 $ans_i$ 个气球。

不妨假设有

$$ans_x=\min(a_i,b_j)$$

$$ans_y=\min(a_m,b_n)$$

使 $j>n,i<m$ 。

因为 $a,b$ 数组已按大小排序，则有 $a_i<a_m,b_j>b_n$ 。

当 $b_j,a_m$ 时，

有 $b_n<b_j<a_i<a_m$ ，此时 $ans_x=b_j,ans_y=b_n$ 。

或 $a_i<b_n<n_j<a_m$ ，此时 $ans_x=a_i,ans_y=b_n$ 。

当 $b_j>a_m$ 时，

有 $a_i<b_n<a_m<b_j$ ，此时 $ans_x=a_i,ans_y=b_n$ 。

或 $a_i<a_m<b_n<b_j$ ，此时 $ans_x=a_i,ans_y=a_m$ 。

或 $b_n<a_i<a_m<b_j$ ，此时 $ans_x=a_i,ans_y=b_n$ 。

令 $ans'_x=\min(a_i,b_n)$ ，

$ans'_y=\min(a_m,b_j)$ 。

当 $b_n<b_j<a_i<a_m$ 时，$ans'_x=b_n=ans_y,ans'_y=b_j=ans_x$ 。

当 $a_i<b_n<n_j<a_m$ 时，$ans'_x=b_n=ans_y,ans'_y=b_j>ans_x$ 。

当 $a_i<b_n<a_m<b_j$ 时，$ans'_x=a_i=ans_x,ans'_y=a_m>ans_y$ 。

当 $a_i<a_m<b_n<b_j$ 时，$ans'_x=a_i=ans_x,ans'_y=a_m=ans_y$ 。

当 $b_n<a_i<a_m<b_j$ 时，$ans'_x=b_n=ans_y,ans'_y=a_m>ans_x$ 。

$∴ ans'_x+ans'_y \geq ans_x+ans_y$

即对于 $\forall\ j>n$ ，都有 $i>m$ 时，解更优。

而如果有 $ans_z=\min(a_p,b_q)$ 且 $p \neq q$ ,

$a$ 侧的 $p$ 之后会有 $n-p$ 支队伍未匹配， $b$ 侧的 $q$ 后有 $n-q$ 个颜色未匹配。

当 $p>q$ 时，会出现 $ans_{last}=min(a',b')$ 且 $a'<b'$ ，反之同理。

∴ 当 $\forall\ ans_z=\min(a_p,b_q)$ 且 $p=q$ 时，解一定是最优解之一（可能存在如 $a_i=a_i+1$ 等情况，最优解不唯一）。

------------


### Code

```cpp
#include <cstdio>

const int MAXN=1e5+10;
int n,a[MAXN],ans,input;

inline int min(int x,int y) { return x<y?x:y; }

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	for (int i=1;i<=n;i++) scanf("%d",&input),ans+=min(input,a[i]);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：bifanwen (赞：1)

[博客园同步](https://www.cnblogs.com/bifanwen/p/15889401.html)

[原题链接](https://www.luogu.com.cn/problem/P8109)

简要题意：

给定两个有序数列 $\{a_n\} \space \{b_n\}$. 对于所有排列 $p_i$，求 $\sum_{i = 1}^n \min(a_i , b_{p_i})$ 的最大值。

另一种解释方式：给定两个有序数列 $\{a_n\} \space \{b_n\}$. 求一种 $a \rightarrow b$ 的映射，使得每组映射的最小值的和最大。求这个最大值。

$n \leq 10^5$.

贪心经典题。

我们可以想到一种显然的匹配方式：即 $p_i = i$，保持原排序结果不变。那么这样是否最优呢？我们可以做一个简单的证明。

只要从小数据出发。考虑对于 $a_i < a_j$ 和 $b_i < b_j$，这四个数如何匹配？

两种方式：$\min(a_i , b_i) + \min(a_j , b_j)$，或者 $\min(a_i , b_j) + \min(a_j , b_i)$. 记前者为 $S$，后者为 $T$.

我们试图证明总有 $S \geq T$.

如果 $a_i < a_j < b_i < b_j$，则 $S = a_i + a_j , T = a_i + a_j$，有 $S = T$.

如果 $a_i < b_i < a_j < b_j$，则 $S = a_i + a_j , T = a_i + b_i$，有 $S > T$.

如果 $b_i < a_i < a_j < b_j$，则 $S = b_i + a_j , T = b_i + a_i$，有 $S > T$.

如果 $a_i < b_i < b_j < a_j$，则 $S = a_i + b_j , T = a_i + b_i$，有 $S > T$.

如果 $b_i < a_i < b_j < a_j$，则 $S = b_i + b_j , T = b_i + a_i$，有 $S > T$.

如果 $b_i < b_j < a_i < a_j$，则 $S = b_i + b_j , T = b_i + b_j$，有 $S = T$.

当然如果存在等号，那么和小于号可以一样得出结论。

最后我们就得到了 $S \geq T$. 那么也就是说：

对于任意的 $i < j$，必有 $(a_i , b_i)(a_j , b_j)$ 的匹配方式比 $(a_i , b_j)(a_j , b_i)$ 不劣。

所以我们只需要把 $a,b$ 从小到大排序，然后让 $p_i = i$，扫一遍即可。

而注意到原题已经帮我们排好序了（其实这也是一点有力的暗示），那么我们直接扫一遍就行了。

时间复杂度：$\mathcal{O}(n + m)$.

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 1;

int Ans = 0, a[N];

int main() {
	int n; scanf("%d",&n);
	for(int i = 1; i <= n; i++) scanf("%d",a + i);
	for(int i = 1; i <= n; i++) {
		int x; scanf("%d",&x);
		Ans += min(x , a[i]);
	}
	printf("%d\n",Ans);
}
```

---


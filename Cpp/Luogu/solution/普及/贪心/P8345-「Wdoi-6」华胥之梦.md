# 「Wdoi-6」华胥之梦

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/lkvzvoj9.png)](https://thwiki.cc/%E4%B8%9C%E6%96%B9%E6%B1%82%E9%97%BB%E5%8F%B2%E7%BA%AA/%E4%BE%BF%E7%AC%BA)

## 题目描述

### 简要题意

给定长度为 $n$ 的序列 $a$ 和常数 $c$。构造点数为 $n$ 的有向完全图 $G$ 使得边 $i\to j$（$i\neq j$）的长度为 $a_i-2a_j+c$，保证所有边权**非负**。

接下来给出 $q$ 次询问，每次给出一个点集，试找出图 $G$ 的一条最短的简单路径，满足其经过点集中所有点，并输出它的长度。

---
### 原始题意

梅莉做了一个梦，梦到自己穿越到了幻想乡的迷途竹林之中。醒来之后，她希望能够和莲子一起再次穿越境界，进入幻想乡。

但是，这一次，她看到了 $n$ 个世界，其中，第 $i$ 个世界的结界强度为 $a_i$。而世界之间**两两都有**通道相连，莲子和梅莉便是通过这些通道来进行世界之间的穿梭的。

为了避免错过幻想乡所在的世界，因此她们每到达一个世界，都会穿越结界。莲子和梅莉从第 $i$ 个世界中，通过一条通道，再穿越结界进入第 $j$ 个世界，需要使用的灵能为 $a_i-2a_j+c$（保证所需消耗的灵能非负），其中 $c$ 是一个常数，是梅莉每次穿越结界需要的额外灵能消耗。注意，这也意味着，从第 $i$ 个世界到第 $j$ 个世界，与第 $j$ 个世界穿越到第 $i$ 个世界所消耗的灵能，**可能是不同的**。

为了能够高效地找到幻想乡，她们会对你进行 $q$ 次询问，每次询问的时候会给出一个**集合**，表示她们想要进入的世界。由于世界众多，她们希望能够节省灵能，因此她希望你能求出所有包含这些世界的简单路径（即：同一条世界间的通道不会被走多次）中，消耗灵能值之和最少的路径。你只需告诉她们消耗灵能值之和最少为多少。

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/x3r2ucsl.png)

每两个点之间的边权如图所示。为了便于选手观察，边权的颜色与它所对应的边的颜色相同。

对于第一个询问，可以找到路径 $4\to 1$
；对于第二个询问，可以找到路径 $3\to 2\to 1$；对于第三个询问，可以找到路径 $2\to 4 \to 1\to 5$。可以证明，这三个方案分别是对应询问的最优方案。
#### 样例 \#2

该样例符合 $\textbf{Subtask 1}$ 的限制。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{q\le} & \bm{\sum |S|\le} & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 30 & 10 & 10 & 10 & - &-\cr\hline
2 & 20 & 10^5 & 10^5 & 10^5 & \mathbf{A}&- \cr\hline
3 & 20 & 10^5 & 10^5 & 10^5 & \mathbf{B}&-  \cr\hline
4 & 30 & 10^6 & 10^6 &  10^6& -&1,2,3 \cr\hline
\end{array}
$$

- 特殊性质 $\bf A$：$a_i$ 单调递增。
- 特殊性质 $\bf B$：$a_i$ 全部相等。

对于 $100\%$ 的数据，保证 $1 \leq S_i \leq n \leq 10^6, 1\leq \sum |S|,q \leq 10^6, 1 \le a_i,c \le 10^9$。

## 样例 #1

### 输入

```
5 20 3
7 4 2 5 9
2 1 4
3 1 2 3
4 1 4 2 5```

### 输出

```
11
24
34```

## 样例 #2

### 输入

```
10 928698067 3
331485039 15480787 61584781 252174726 472089427 95998831 252561792 118119945 315548522 24453837
4 9 1 10 2
5 10 6 1 5 8
1 5
```

### 输出

```
1798602551
2249463436
0
```

# 题解

## 作者：Dr_Gilbert (赞：4)

# P8345 「Wdoi-6」华胥之梦

UPD 2022-05-20: 修改一处笔误

【题目大意】

给定长度为 $n$ 的序列 $a$ 和常数 $c$。构造点数为 $n$ 的有向完全图 $G$ 使得边 $i\to j$（$i\neq j$）的长度为 $a_i-2a_j+c$，保证所有边权**非负**。

接下来给出 $q$ 次询问，每次给出一个点集，试找出图 $G$ 的一条最短的简单路径，满足其经过点集中所有点，并输出它的长度。

【数据范围】

- $N,Q,\sum |S|\le10^6$。
- 对于 $20\%$ 的数据，有 $a_i$ 全部相同。
- 对于另 $20\%$ 的数据，有 $a_i$ 单调递增。

看到这个题意和这个数据范围，感觉没有任何思路，不妨从特殊性质入手先拿部分分。$a_i$ 全部相同的部分分非常简单，也没有什么价值。比较关键的是 $a_i$ 全部递增这点性质，由于边权的定义为 $a_i-2a_j+c$，不难想到一个贪心策略，那就是将点集中的点排序后直接走。如果这个策略正确，那么可以由这个策略推广，只需把点集中的点按 $a_i$ 的值升序排序后直接走即可。下面可以证明一下这个贪心策略。

这个贪心策略的证明，在这里分两部分，第一部分是论证若所走的点一定是点集内的点，则路径长度最短；而第二部分是若走的顺序一定按 $a_i$ 大小，则路径最短。先论证第一部分。注意到题目中保证所有边权非负数，即
$$
a_i-2a_j+c\ge0
$$
对这个式子进行一些变换，就可以得到
$$
a_i-2a_j+c\ge0\Rightarrow a_j\le \frac{a_i+c}{2}
$$
对于这条边的反向边 $j \rightarrow i$ ，同理有 
$$
a_i\le\frac{a_j+c}{2}
$$
将上式中 $a_j$ 的最大值代入下式，有
$$
a_i\le \frac{\frac{a_i+c}{2}+c}{2} \Rightarrow 4a_i\le a_i+3c \Rightarrow a_i\le c
$$
显然，$a_i$ 随 $a_j$ 的增大而增大，所以 $a_i$ 的最大值为 $c$。假设在从点 $i$ 到 $j$ 时，经过了点 $k$，即路径为 $i\rightarrow k \rightarrow j$，则总长度为

$$
a_i-2a_k+c+a_k-2a_j+c=a_i-a_k-2a_j+2c\\
\because a_k\le c\\
\therefore c-a_k\ge 0\\
\therefore a_i-a_k-2a_j+2c\ge a_i-2a_j+c
$$

所以如果不需要经过点 $k$，那么就不要走点 $k$，即若所走的点一定是点集内的点，则路径长度最短，第一部分得证。接下来论证第二部分：

由第一部分的结论，最短路径上的点一定都在点集内。且由边权非负，可得所走路径一定是按某个顺序依次连接点集中所有点的一条链。所以对于点集 $S$，最短路径的边数是确定的，即 $|S|-1$。所以总代价中的常数项是确定的。接下来可以对某个点集中某条路径的总长度的式子进行简单推导，设点集中各点按一定顺序排列后分别为 $S(1)\ldots S(n)$，则这条路径的总路径长为
$$
a_{S(1)}-2a_{S(2)}+a_{S(2)}-2a_{S(3)}+\cdots+a_{S(n-1)}-2a_{S(n)}+(n-1)c
$$
化简得
$$
(n-1)c+a_{S(1)}-2a_{S(n)}-\sum_{i=2}^{n-1} a_{S(i)}
$$
可见，最终的路径长度只和路径的起点和终点有关。只需保证起点的 $a_i$ 最小且重点的 $a_i$ 最大，即可保证总长度最小，而排序就可以保证这一条件，第二部分得证。

当然，从第二部分的证明可以发现，完全没有必要对集合 $S$ 进行排序，只需找出最大值和最小值即可。这样，时间复杂度就降到了 $O(\sum|S|)$。

当然，这道题时限 $1.5 \text{ s}$，并没有卡每次排序的做法。赛时时间紧，没多想就写了每次排序的做法，时间复杂度 $O(n\log n+\sum |S|\log |S|)$。

代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
struct po{
	int val,x;
	bool operator <(const po& a)const{
		return val<a.val;
	}
}p[1000010];
int s[1000010],a[1000010];
bool cmp(int x, int y){return (a[x]<a[y]);}
bool cmp2(po a, po b){return a.x<b.x;}
signed main(){
	int n,c,q;
	cin>>n>>c>>q;
	for (int i=1;i<=n;i++){
		cin>>p[i].val;
		p[i].x=i;
	}
	sort(p+1,p+1+n);//排序
	for (int i=1;i<=n;i++) a[p[i].x]=i; // 存排名
	sort(p+1,p+1+n,cmp2);
	while (q--){
		int k;cin>>k;
		for (int i=1;i<=k;i++) cin>>s[i];
		sort(s+1,s+1+k,cmp); // 按a_i从小到大
		int ans=0;
		for (int i=2;i<=k;i++){
			ans+=p[s[i-1]].val-2*p[s[i]].val+c;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```



---

## 作者：Ginger_he (赞：3)

# 题解
设 $\{p_s\}$ 为点集的一种排列，令 $r_i=a_{p_i}$，则该种排列的长度为：

$$d=\sum_{i=1}^{s-1}(r_i-2r_{i+1}+c)$$

将常数提出得到：

$$d=c\times(s-1)+\sum_{i=1}^{s-1}+(r_i-2r_{i+1})$$

发现相邻两项直接可以抵消一部分，化简得到：

$$d=c\times(s-1)+(r_1-r_s)-\sum_{i=2}^sr_i$$

稍微变换得到：

$$d=c\times(s-1)+(2r_1-r_s)-\sum_{i=1}^sr_i$$

分析上式，仅有 $(2r_1-r_s)$ 为变量，因为要最小化 $d$，所以让 $r_1$ 最小，$r_s$ 最大即可。时间复杂度 $O(n+\sum\left|S\right|)$。
## 注意
- 多测要清空
- 记得开 `long long`

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 1000005
inline ll read()
{
    ll x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
	{
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
	{
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
ll n,c,q,m,s,t,w,x,a[N],ans;
int main()
{
	n=read(),c=read(),q=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	while(q--)
	{
		s=w=0,t=1e9;
		m=read();
		for(ll i=1;i<=m;i++)
		{
			x=read();
			s=max(s,a[x]);
			t=min(t,a[x]);
			w-=a[x];
		}
		printf("%lld\n",c*(m-1)+w+t*2-s);
	}
	return 0;
}
```

---

## 作者：快斗游鹿 (赞：2)

## 思路

$\because a_i-2a_j+c\geqslant0$

$\therefore$ 要使得上式值最小，就应使 $a_i-2a_j$ 尽量小。

当 $a_i\leqslant a_j$ 时，$a_i-2a_j<0$。所以我们在选择点时，应尽量让 $a_i\leqslant a_j$。这时候只要对每个集合中的所有点的点权进行排序，再依次累加即可。

## 代码

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1000005;
ll n,c,q,x;
ll a[N],b[N];
int main(){
	scanf("%lld%lld%lld",&n,&c,&q);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=q;i++){
		ll num;scanf("%lld",&num);
		for(int j=1;j<=num;j++){
			scanf("%lld",&x);
			b[j]=a[x];//统计集合中的点权
		}
		sort(b+1,b+1+num);//进行排序
		ll ans=0;
		for(int j=1;j<num;j++){
			ans=ans+b[j]-2*b[j+1]+c;//累加
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---

## 作者：mosteryu (赞：2)

这一题不是图论 , 不是最短路 , 也不是搜索 , 而是推结论题 。

### 引入

在讲解正解之前 ， 我们需要研究这个问题 。

$A\to B \to C$ : 显而易见的所花费的灵气为 ：

$ a_A-2a_B+c+a_B-2a_C+c = 2\times c - a_B+a_A-2a_C .$

可以看出 ， 要想使花费的灵气尽可能的少的话 ， $a_C$ 减的最多 ， 所以 $a_C$ 要尽可能大 ， $a_A$ 加的最多 ， 所以 $a_A$ 要尽可能地小 。

我们知道了要从最小的开始 ， 从最大的结束后 ， 我们就可以仔细去研究了 。

### 进一步研究

有了上面的引子后 ， 这道题的难度从黄变成了红 。

我们设要从 $s$ 开始 ， 代表 $a_s$ 是第 $q$ 次询问中所有的数里最小的一个 ， 在 $L$ 位置结束 ， 表示 $a_L$ 是最大的 。 并且一共要去 $e$ 个点 （包括起终点）。

总共所需要花费的灵气值为 :

$= (\sum_{i=s}^{i<=L} a_i-2(a_i+1)+c) $

$= a_s -(\sum_{i=s+1}^{i<L}a_i) - 2a_L + ec$

$ec$ 不用管 , 到时候加上就行 ， 其他的在输入的时候记住最小值与最大值套上方公式即可 。

### 赛时AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,c,q;
	cin>>n>>c>>q;
	int a[1000001];
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	int s;
	for(int w=0;w<q;w++){
		cin>>s;
		int b[1000001];
		int minn=0x3f3f3f3f,maxn=-10001;
		long long sum=(s-1)*c;
		for(int i=1;i<=s;i++){
			cin>>b[i];
			minn=min(minn,a[b[i]]);
			maxn=max(maxn,a[b[i]]);
			sum-=a[b[i]];//这里全都减了，到时候加回来
		}
		sum+=2*minn;
		sum-=maxn;
		cout<<sum<<endl;
	}
	return 0;
} 
```



---

## 作者：Ask_sum (赞：1)

# P8345 题解
~~本人初写题解，如有不当请谅解。~~

[题目传送门](https://www.luogu.com.cn/problem/P8345)

本题为这次月赛 T2，总的来说不算太难，有两种做法。本体看上去是个图，但其实做法上与图丝毫没有关系，仍然与 T1一样，是道数学题。
## Sol 1(30pts)
题目让我们使用尽量少的灵能遍历一遍每个想要去的世界，且从第 $i$ 个世界穿越结界到第 $j$ 个世界所需灵能为 $a_i-2a_j+c$，其中 $a_i$ 是第 $i$ 个世界的结界强度，而 $a_j$ 是第 $j$ 个世界的结界强度，$c$ 是常数。

既然 $c$ 是常数，我们就可以忽略它，因为无论顺序如何始终要花费 $|S|c$ 的灵能，与顺序无关。而剩下的部分 $a_i-2a_j$ 明显可以看出，$a_i$ 越小，$a_j$ 越大，则该值越小。又因为题目保证其不会为负，所以我们只需要将这个顺序按其结界强度排一下序，便可以得出其最小灵能花费。时间复杂度 $O(qslogs)$。

### 30pts Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1e17
using namespace std;
ll n,c,q;
ll a[1000005],f[1000005],s[1000005];
inline ll read(){//快读 
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return f*x;
}
void init(){//预处理 
	memset(a,0,sizeof(a));
	memset(s,0,sizeof(s));
	n=read(),c=read(),q=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
}
void work(){
	int len;
	len=read();
	memset(s,0,sizeof(s));
	for(ll i=1;i<=len;i++){//输入 
		ll k=read();
		s[i]=a[k];
	}
	if(len<=1){//特判 
		printf("0\n");
		return;
	}
	sort(s+1,s+len+1);//排序 
	ll sum=0;
	for(ll i=1;i<len;i++){
		sum+=s[i]-2*s[i+1]+c;//计算最小权值和 
	}
	printf("%lld\n",sum);//输出 
}
int main(){
	init();
	while(q--){
		work();
	}
	return 0;
} 
```
## Sol 2(100 pts)
使用上面的方法可以得到正确结果，但是时间复杂度过高，无法得到全部分数。因此，我们需要一种更快的方法。

我们可以提前计算 $|S|c$，并且设 $sum$ 为集合中的所有元素权值和，再求出集合中所有元素权值的最小值与最大值。为什么呢？我们举个例子。

假如用 Sol 1 的思想，如果从 $a_1$ 开始，一直走到 $a_n$，那么所需要的灵能总共是 

$a_1-2a_2+c+a_2-2a_3+c+...+a_{n-1}-2a_n+c$，

即 $nc+a_1-a_2-a_3-...-a_{n-1}-2a_n$。

也就是 $nc-sum+2a_1-a_n$。

其中，$a_1$ 相当于这个集合中的最小权值元素，而 $a_n$ 相当于这个集合中的最大权值元素，若设 $minn=a_1$，$maxn=a_n$，则最少所需要的灵能为 $nc-sum+2minn-max$。

这种方式时间复杂度为 $O(q|S|)$，可以通过本题。
### Accepted Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1e17//定义一个极限值 
using namespace std;
ll n,c,q;
ll a[1000005];
inline ll read(){//快读 
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return f*x;
}
ll max(ll a,ll b){
	return a>b?a:b;
}
ll min(ll a,ll b){
	return a<b?a:b;
}//自写max与min函数 
void init(){//预处理 
	memset(a,0,sizeof(a));
	n=read(),c=read(),q=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
}
void work(){
	int len;
	len=read();
	ll sum=0,cs=(len-1)*c,maxn=-inf,minn=inf;
	for(ll i=1;i<=len;i++){
		ll k=read();
		sum+=a[k];//权值和 
		maxn=max(maxn,a[k]);//最大权值 
		minn=min(minn,a[k]);//最小权值 
	}
	if(len<=1){//特判为1的情况 
		printf("0\n");
		return;
	}
	printf("%lld\n",cs-sum+2*minn-maxn);//本题重点 
}
int main(){
	init();
	while(q--){
		work();
	}
	return 0;
} 

---

## 作者：nullqtr_pwp (赞：1)

## P8345 Solution


正解：看到 $1s$ 的时长限制以及 $10^6$ 次询问，知道这题大概率是个结论题。

注意到一个性质：**这个路径经过的点都必然在集合 $S$ 中**，理由：这是一个简单路径，并且边权非负。

根据这个性质，我们就很好算了。

**方便起见，这一部分的计算忽略常数 $c$** ，显然，路径有 $|S|-1$ 条边，设这个点集重新排为 $a_1,a_2,\cdots,a_k$，注意到边 $j\rightarrow i$ 的长度为 $a_i-2a_j$，那么我们不妨设它的边就是 $a_1\rightarrow a_2$，$a_2\rightarrow a_3$，$\cdots$，$a_{k-1}\rightarrow a_k$，那么计算边的长度之和就是 $a_2-2a_1+a_3-2a_2+\cdots+a_k-2a_{k-1}$，化简得到路径长度为 $a_1-a_{k-1}-\sum_{i=2}^{k-1}a_i$，那么，如何让这个值最大呢？

这个值等于 $-\sum_{i=1}^{k-1}a_i+2a_1-a_k$，注意到 $-\sum_{i=1}^{k-1}a_i$ 是一个定值，那么若想要它最短，只需要让 $a_1$ 最小，$a_k$ 最大，代码中，线性扫出最小最大值即可，此时再考虑常数 $c$，那么需要加上 $c\times(|S|-1)$

综上，路径考虑常数 $c$ 时的长度是：
$c\times(|S|-1)-\sum_{i=1}^{k-1}a_i+2a_1-a_k$

细节：注意开 long long；

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1000005;
int t,n,c,a[maxn],q[maxn],len;
signed main(){
	scanf("%lld%lld%lld",&n,&c,&t);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	while(t--){
		scanf("%lld",&len);
		int maxx=0,sum=0,minx=0x3f3f3f3f; 
		for(int i=1;i<=len;i++){
			scanf("%lld",&q[i]);
			sum-=a[q[i]];
			maxx=max(maxx,a[q[i]]);
			minx=min(minx,a[q[i]]);
		}
		long long ans=c*(len-1)+sum+(minx<<1)-maxx;
		printf("%lld\n",ans);
	}
}
```


---

## 作者：chen_zhe (赞：1)

暴力建图搜路径显然可以拿到 30pts，非常良心。

由于要求是一条简单路径，而且边权非负，也就是多走任意一条边都会让结果不优。因而可以发现，要让路径长度最短，则这个路径只能通过点集中的点，不能通过其他的点。

问题在于如何确定走这些点的顺序，即假设现在在点 $u$，有两个点 $i,j$，那么是先走 $u \to i,i \to j$ 路径最短，还是 $u \to j,j \to i$ 最短呢？

计算路径长度：前者的长度是 $a[u]-2a[i]+c+a[i]-2a[j]+c=a[u]-a[i]-2a[j]+2c$，而后者的长度是 $a[u]-2a[j]+c+a[j]-2a[i]+c=a[u]-a[j]-2a[i]+2c$。

若前者小于后者，即 $a[u]-a[i]-2a[j]+2c<a[u]-a[j]-2a[i]+2c$，则有 $a[i]-a[j]<0$。

那么可以得到，我们先走 $a$ 较小的节点，可以保证路径长度最短。因而排序+计算一下两个节点之间的边长度即可。代码复杂度 $O(n \log n)$。作为良心送分题，而且 sort 常数确实不大，不太能卡，因而 $O(n \log n)$ 确实可以过这个题。

但是如果我们把这个计算边权的式子展开一下呢？我们会发现，$\sum \limits_{i=1}^{n-1} (a[i]-2a[i+1]+c)=(n-1)c-\sum \limits_{i=1}^{n-1}a[i]+2 \times a[1]-a[n]$。其中，$a[1]$ 为最小值，而 $a[n]$ 为最大值。因而我们只需要在读入的时候记录点集中所有点的 $a$ 的最小值和最大值，以及所有的 $a$ 之和，即可在线性复杂度内完成本题。

代码给的是 $O(n \log n)$ 的，付费报名讲评的用户下发的是 $O(n)$ 的。月赛 B 题放这个题目非常良心，大家上分愉快。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int n,c,q,a[1000050],S;

int main()
{
	cin >> n >> c >> q;
	for (int i=1;i<=n;i++)
		cin >> a[i];
	while (q--)
	{
		vector <int> qu;
		cin >> S;
		for (int i=1;i<=S;i++)
		{
			int x;cin >> x;
			qu.push_back(x);
		}
		sort(qu.begin(),qu.end(),[](int x,int y){return a[x]<a[y];});
		long long ans=0;
		for (int i=1;i<=S-1;i++)
			ans+=1LL*a[qu[i-1]]-2LL*a[qu[i]]+c;
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：tzl_Dedicatus545 (赞：0)

首先我们考虑两个问题：

1. 最优路径经过那些点。
2. 这些点的顺序是什么样的。

对于第一个问题，我们考虑路径 $i \to j$，考虑是否额外经过点 $k$。

不经过点 $k$ 的消耗为：

$$a_i-2a_j+c$$

经过为：

$$a_i-2a_k+c+a_k-2a_j+c$$
$$=a_i-a_k-2a_j+2c$$

两式相减，得：

$$a_i-2a_j+c-a_i+a_k+2a_j-2c$$
$$=a_k-c<0$$

综上，不经过额外的点更佳。

对于第二个问题，我们设三个点 $i,j,k\,(a_i<a_j<a_k)$，比较 $i\to j\to k$ 和 $i \to k \to j$，也就是：

$$a_i-a_j-2a_k\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,a_i-a_k-2a_j$$
$$=-a_j-2a_k\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,-a_k-2a_j$$
$$=-a_k<-a_j$$

综上，从小到大最好，排序一下直接算即可。

**代码：**

```cpp
//By: Luogu@⚡炭治郎⚡(a.k.a. Kamado_Tanjiro)(LuoguID:308854)
#include <bits/stdc++.h>
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
#define int long long

using namespace std;

const int INF=(sizeof(int)==4?0x3f3f3f3f:0x3f3f3f3f3f3f3f3f);
const int MOD=998244353;
const long double EPS=1e-7;
const int MAXN=1000020;

map<int,int> Sorted2Orignal;
int a[MAXN];

signed main()
{
	ios::sync_with_stdio(false);

	int n,c,q;

	cin>>n>>c>>q;

	for(int i=1;i<=n;i++)
		cin>>a[i];

	while(q--)
	{
		int SizeofS;

		cin>>SizeofS;

		vector<int> PointSet;

		for(int i=1;i<=SizeofS;i++)
		{
			int _t;

			cin>>_t;

			PointSet.push_back(a[_t]);
		}

		sort(PointSet.begin(),PointSet.end());

		int Sum=0;

		for(int i=0;i<PointSet.size()-1;i++)
		{
			Sum+=PointSet[i]-2*PointSet[i+1]+c;
		}

		cout<<Sum<<endl;
	}

	return 0;
}

```


---

## 作者：lanretE (赞：0)

首先，题目保证了所有边权非负，所以每走一条多余的边都会使答案变大，故我们只能在点集里面给出的点之间走。

接着，我们考虑走的顺序。

如果我们要从点 $i$ 走到 $j,k$ 两个点，可以得到两种顺序：

$i\rightarrow j\rightarrow k$ 和 $i\rightarrow k\rightarrow j$，根据题目里给的边权计算公式，可以得到前者的路径长为 $a_i-2a_j+c+a_j-2a_k+c$，

化简得 $a_i-a_j-2a_k+2c$，

后者路径长为 $a_i-2a_k+c+a_k-2a_j+c$，

化简得 $a_i-a_k-2a_j+2c$，

假设前者更短，即 

$a_i-a_j-2a_k+2c<a_i-a_k-2a_j+2c$，

移项得 $a_j<a_k$，

所以，$i\rightarrow j\rightarrow k$ 走法路径长度小于 $i\rightarrow k\rightarrow j$ 当且仅当 $a_j<a_k$，也就是说，我们要先走所对应 $a$ 数组中的值较小的点，如此一来可以保证路径最短。

因此，对于每组数据，我们把点集里面所有点对应的 $a$ 数组中的值记录到一个数组里面，然后从小到大排序，最后依次在答案里加上每条边的权值即可。

```
#include<iostream>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
ll n,c,q;
const int N=1000010;
ll a[N],g[N],num,ans;
bool b[N];
int main(){
	cin>>n>>c>>q;
	for(int i=1;i<=n;++i) scanf("%lld",&a[i]);
	while(q--){
		scanf("%lld",&num);
		for(int i=1;i<=num;++i){
			int x; scanf("%lld",&x);
			g[i]=a[x];
		}
		sort(g+1,g+num+1);
		ll ans=0;
		for(int i=1;i<num;++i) ans+=g[i]-2*g[i+1]+c;
		printf("%lld\n",ans);
	}
    return 0;
}
```


---

## 作者：3a51_ (赞：0)

首先，由于边权非负，所以能发现一个性质：最短路径走过的点一定只有点集的点。

先假设只有 $3$ 个点，设下标为 $s$ 的为起点，下标为 $e$ 的为终点，设另外一个点为 $x$，这样走过的全路程就是 $s-2x+x-2e+2c$，简化一下就是 $s-x-2e+2c$。

不难发现，对于非起点和终点的每一个点（设为 $x$ ），都要被别的点走到，就是 $-2a_x$，还要走到下一个点，就是 $+a_x$，所以最终可以简化成 $-a_x$。

然后对于起点，不会被其他点走到，所以只有 $+a_s$，对于终点，不会走到下一个点，所以只有 $-2a_e$。

其实可以先考虑把所有点的点权想象成 $-a_x$，然后再把起点 $+2a_s$，终点 $-a_e$。

为了让总路程最短，由于点集的和是固定的，所以只用考虑起点、终点，中间经过的点无所谓。要让总路程最短，由于起点是在增加路程，所以希望它增加的尽量少，那就要选最小值，由于终点是在减少路程，那就要选最大值。

但是别忘了还有个 $c$。由于有 $n-1$ 个边，那么最后就要加上 $(n-1)\times c$。

$\texttt{Code}$：

```cpp
while(q--){
	int s,sum=0,maxa=-1,mina=1000000000000000000;
	//定义变量
	cin>>s;
	for(int i=1;i<=s;i++){
		int x;
		cin>>x;
		if(mina>a[x]){
			mina=a[x];
		}//找最小值
		if(maxa<a[x]){
			maxa=a[x];
		}//找最大值
		sum+=a[x];//统计总和
	}
	cout<<c*(s-1)-sum-maxa+2*mina<<endl;
	//先把所有都看成-1，就相当于-sum
	//再把最大值减去，就相当于-maxa
	//再把最小值加上，就相当于+2*mina
	//还别忘了c!
} 
```

---

## 作者：_xxy_ (赞：0)

~~一道看起来复杂实际上很简单的题目~~

我们可以先从第 $ 1 $ 个点按顺序走到第 $ n $ 个点入手，通过整理式子后得出路径长度为 $ a_1- $ $ \sum_{1<i<n} a_i $ $ -2a_n +c\times (n-1) $ ，易知当 $ a_1 $ 最小， $ a_n $ 最大时，路径长度最小（中间的点无论怎么改变顺序路径长度也不变）。

有了这个结论，便能过了这题，对于每组询问，只需在输入时预处理 $ a_i $ 的最大值，最小值及总和，再计算即可。

AC Code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,c,q,a[1000010],s,num,minn,maxn,ans;
inline long long read(){
	long long x=0,f=1;
	char ac=getchar();
	while(ac<'0'||ac>'9'){
		if(ac=='-') f=-1;
		ac=getchar();
	}
	while(ac>='0'&&ac<='9'){
		x=x*10+(ac-'0');
		ac=getchar();
	}
	return x*f;
}
int main(){
	n=read(),c=read(),q=read();
	for(int i=1;i<=n;i++) a[i]=read();
	while(q--){
		minn=1e9+10;
		maxn=-1;
		ans=0;
		s=read();
		for(int i=1;i<=s;i++){
			num=read();
			ans+=a[num];
			minn=min(minn,a[num]);
			maxn=max(maxn,a[num]);
		}
		ans-=minn;
		printf("%lld\n",minn-ans-maxn+c*(s-1));
	}
	return 0;
} 
```

---

## 作者：lyhqwq (赞：0)

### 前言

两道结论题！好良心！！赞美良心出题人！！！

### 思路

结论题

假设现在的询问集合大小为 $S$ ,集合为 $b_1,b_2 ,\cdots, b_S$

如果当前的路径为 $b_1,b_2 \cdots b_S$

则边权之和为 $a_{b_1}-2a_{b_2}+c+a_{b_2}-2a_{b_3}+c+\cdots+a_{b_{S-1}}-2a_{b_S}+c$

整理一下变成

$a_{b_1}+a_{b_2}+\cdots+a_{b_{S-1}}-2(a_{b_2}+a_{b_3}+\cdots+a_{b_S})+(S-1)\times c$

我们设 $sum=\sum_{i=1}^Sa_{b_i}$

则上式为

$sum-a_{b_S}-2(sum-a_{b_1})+(S-1)\times c$

所以要求最小值，只要让 $a_{b_S}$ 最大， $a_{b_1}$ 最小就可以了

### AC code

注意开long long

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef unsigned long long ull;
#define il inline
using namespace std;
ll n,c,q;
ll a[1000005];
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%lld%lld%lld",&n,&c,&q);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1;i<=q;i++){
		ll s;
		scanf("%lld",&s);
		ll sum=0,minx=0x7f7f7f7f,maxx=0;
		for(int i=1;i<=s;i++){
			ll x;
			scanf("%lld",&x);
			maxx=max(maxx,a[x]);
			minx=min(minx,a[x]);
			sum+=a[x];
		}
		printf("%lld\n",(sum-maxx)-2*(sum-minx)+(s-1)*c);
	}
	return 0;
}

```


---


# [蓝桥杯 2018 省 B] 乘积最大

## 题目描述

给定 $N$ 个整数 $A_1, A_2,\cdots, A_N$。请你从中选出 $K$ 个数，使其乘积最大。  

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 $1000000009$（即 $10^9+9$）的余数。  

注意，如果 $X<0$， 我们定义 $X$ 除以 $1000000009$ 的余数是 $0-((0-x)\bmod 1000000009)$。


## 说明/提示

对于 $40\%$ 的数据，$1\le K\le N\le 100$。

对于 $60\%$ 的数据，$1\le K \le 1000$。

对于 $100\%$ 的数据，$1\le K\le N\le 10^5$，$-10^5\le A_i\le 10^5$。

## 样例 #1

### 输入

```
5 3 
-100000   
-10000   
2   
100000  
10000```

### 输出

```
999100009```

## 样例 #2

### 输入

```
5 3 
-100000   
-100000   
-2   
-100000  
-100000```

### 输出

```
-999999829```

# 题解

## 作者：Vsinger_洛天依 (赞：7)

- 题意：
	在 $N$ 个数中取 $K$ 个数，使这 $K$ 个数的乘积最大，答案对 $1000000009$ 取模。
    
- 思路：
	先把这 $N$ 个数从小到大排序，若 $K$ 为奇数则先乘上最大的一个并把 $K-1$。若最大的数为负数则记录 $f=-1$，用贪心从两侧取数并比较与 $f$ 之积，进而求解。
  
- 代码：
	```cpp 
	#include<bits/stdc++.h>
	const long long MOD=1e9+9; 
	using namespace std;
	int main(){
	    long long a,c,b[0x66ccff],ans=1;
	    int f=1;
	    cin>>a>>c;
	    for(int i=1;i<=a;i++){
 	       cin>>b[i];
 	   }
 	   sort(b+1,b+a+1);
 	   if(c%2==1){
 	       ans*=b[a];
 	       c--;
 	       a--;
 	       if(ans<0){
 	           f=-1;
	        }
 	   }
  	  long long left=1,right=a;
  	  c+=2;
  	  while(c-=2){
  	      long long sto=b[left]*b[left+1];
  	      long long orz=b[right]*b[right-1];
  	      if(sto*f>=orz*f){
  	          ans=(sto%MOD)*ans%MOD;
 	          left+=2;
 	       }
     	   else{
	            ans=(orz%MOD)*ans%MOD;
	            right-=2;
	        }
	    }
	    cout<<ans%MOD;
	}
	```

---

## 作者：Jorisy (赞：5)

首先考虑将 $A$ 升序排列。

我们知道同号两数相乘为正，因此我们可以在数列两端分别取两个数的乘积 $p,q$，然后贪心选最大的。

我们可以先将 $k$ 变为偶数（即当 $k$ 为奇数时先将答案 $ans$ 记作 $A_n$）。

注意取模时先乘 $p$ 或 $q$ 再乘 $ans$，否则会爆 `long long`。

AC Code：
```cpp
#include<bits/stdc++.h>
#define int long long 
#define mod 1000000009
using namespace std;

int n,k,a[100005],ans;

signed main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	ans=k&1?a[n]:1;
	n-=k&1;
	k-=k&1;
	int l=1,r=n,f=ans<0?-1:1;
	while(k)
	{
		int p=a[l]*a[l+1],q=a[r]*a[r-1];//两端取
		if(p*f>q*f)//贪心选取
		{
			ans=p%mod*ans%mod;
			l+=2;
		}
		else
		{
			ans=q%mod*ans%mod;
			r-=2;
		}
		k-=2;
	}
	cout<<ans;
 	return 0;
}
```

---

## 作者：Silence_World (赞：3)

# 思路

比较水的一道贪心，因为有负数的存在，我们思考负负得正，因为在迫不得已下不会正负相乘，所以我们可以先排序数组，然后从左右取两正或两负，这样一定乘出来的是个正数，然后判断一下 $k$ 的奇偶性，如果是奇数就先把最大的拿了，再判断一下最大的的正负就结束了。

# AC 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define mod 1000000009
int a[1000005];
signed main(){
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	} 
	sort(a+1,a+n+1);
 	int l=1;
 	int r=n;
 	int sum=0;
 	int ans=1;
 	int f=1;
 	if(k%2==1){
 		ans*=a[n];
 		n--;
 		k--;
 		r--;
 		if(ans<0){
 			f=-1;
		}
	}
	k+=2;
 	while(k-=2){
 		int li=a[l]*a[l+1];
 		int ri=a[r]*a[r-1];
 		if(ri*f>=li*f){
 			r-=2;
 			ans*=ri%mod;
 			ans%=mod;
		}
		else{
			l+=2;
			ans*=li%mod;
			ans%=mod;
		}
		sum+=2;
	}
	cout<<ans%mod;
}				
```


---

## 作者：违规用户名U1075140 (赞：0)

### 题意

在 $N$ 个数中取 $K$ 个数，使这 $K$ 个数的**乘积最大**，答案对 $10^9+9$ 取模。

### 思路

简单贪心，先判断 $K$ 的奇偶性，若 $K$ 为奇数则先乘上这 $N$ 个数中最大的数。接下来从两头开始取数即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 1<<30
#define endl "\n"
#define maxm 0xbb2200
#define maxn 1e4
using namespace std;
inline int read()
{
    int s = 0,w = 1;char ch = getchar();
    while(ch<'0'||ch>'9'){ if(ch ==  '-') w = -1;ch = getchar();}
    while(ch>='0'&&ch<='9'){ s = s*10+ch-'0';ch = getchar();}
    return s*w;
}
int MOD=1e9+9; 
int a,c,b[maxm],ans=1;
signed main()
{ 
    int f=1;
    a=read(),c=read();
    for(int i=1;i<=a;i++)
       b[i]=read();
   	sort(b+1,b+a+1);
   	if(c%2==1)
    {
       	ans*=b[a],
       	c--,
        a--;
       	if(ans<0)
           f=-1;
   	}
  	int l=1,r=a;
  	c++,c++;
  	while(c-=2)
    {
      	int hu=b[l]*b[l+1];
      	int tao=b[r]*b[r-1];
      	if(hu*f>=tao*f)
          	ans=(hu%MOD)*ans%MOD,
          	l+=2;
       	else
            ans=(tao%MOD)*ans%MOD,
            r-=2;
    }
    cout<<ans%MOD; 
}
```



---

## 作者：Jasonshan10 (赞：0)

### 题意

从 $N$ 个整数 $a_1,a_2,a_3,…,a_n$ 中选取 $K$ 个整数，使乘积最大。

输出乘积除以 $10^9+9$。

### 思路

这道题可以用贪心法求解。

第一步：将输入的 $N$ 个数从小到大排序。

第二步：如果 $K$ 为奇数，则先乘上最大的一个，如果是偶数则不做处理。

**这里注意：若最大的数 $<0$，全部的整数都是负数，置变量 $flag=-1$ 就代表了乘积为负，后面有用。** 

第三步：不断取最左边的两个数和最右边的两个数相乘。左边取的两个数是 $a_l,a_{l+1}$，右边取的两个数是 $a_r,a_{r-1}$。我们记 $a_l\times a_{l+1}=x$，$a_r\times a_{r-1}=y$。

第四步：**比较 $x$ 与 $y$ 的大小**

若 $flag\times x>flag \times y$，则取左边的两个数，$l=l+2$；

若 $flag\times x\le flag \times y$，则取右边的两个数，$r=r-2$；

每循环一次，$k=k-2$，代表又选择了两个数。

### 程序

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=1e9+9;
const int MAXN=100001;
ll a[MAXN],res=1;
int flag=1;
int main(){
	int n,K;
	scanf("%d %d",&n,&K);//输入
	for (int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
	}
	sort(a+1,a+n+1);//排序
	int l=1,r=n;
	if (K%2==1){//奇数特盘
		--r;
		--K;
		res=a[n];
		if(a[n]<0){//如果全是负数
			flag=-1;
		}
	}
	while (K!=0){
		ll x=a[l]*a[l+1],y=a[r]*a[r-1];//计算两值，比较大小
		if (x*flag<=y*flag){
			res=((y%mod)*res)%mod;
			r=r-2;
		}
        else{
			res=((x%mod)*res)%mod;
			l=l+2;
		}
		K=K-2;
	}
	printf("%lld",res%mod);//输出
	return 0;
}

```


---

## 作者：wuhan1234 (赞：0)

## 1. 编程思路。

采用贪心法求解。

先将输入的 $N$ 个整数按从小到大的顺序排列好，若需要取的整数的个数 $k$ 为奇数，先取最大的数 $A_N$ 作为乘积 $res$，取数的个数 $k$ 减 $1$；若 $k$ 为偶数，则先不取任何数，乘积 $res$ 赋值为 $1$。同时，若乘积 $res<0$，表示给定的 $N$ 个整数中，最大的整数是负数，这样全部的整数都是负数，取奇数个负数相乘，乘积也为负，置 $sign=-1$，表示乘积的符号为负。若 $res>0$，则置 $sign=1$。

之后采用贪心的方法从两边取数相乘，每次取数是在每一边各取两个数，左边取的两个数的乘积为 $x=A_l\times A_{l+1}$，右边取的两个数的乘积为  $y=A_r\times A_{r-1}$。

若 $sign\times x>sign\times y$，则取左边的两个数乘到乘积中；

若 $sign\times x\le sign\times y$，则取右边的两个数乘到乘积中。

每次取 $2$ 个数，直到取满 $k$ 个数结束。

## 2. 源程序。

```
#include <stdio.h>
#include <algorithm>
using namespace std;
#define MOD 1000000009
int main()
{
	int n, k;
	long long a[100005];
	scanf("%d %d", &n, &k);
	int i;
	for (i = 0; i < n; i++)
        scanf("%lld", &a[i]);
	sort(a, a+n);
	int sign = 1;
	int left = 0, right = n - 1;
	long long res = 1;
	if (k % 2 == 1)
	{
		res = a[right];
		right--;
		k--;
		if (res < 0) sign = -1;
	}
	while (k)   // 取偶数个数，两两取，因为有负数，所以选两边最大那个
	{
		long long x = a[left] * a[left + 1];
		long long y = a[right] * a[right - 1];
		if (x * sign > y * sign)
		{
			res = x % MOD * res % MOD;
			left += 2;
		}
        else
        {
			res = y % MOD * res % MOD;
			right -= 2;
		}
		k -= 2;
	}
	printf("%lld", res);
	return 0;
}

```


---


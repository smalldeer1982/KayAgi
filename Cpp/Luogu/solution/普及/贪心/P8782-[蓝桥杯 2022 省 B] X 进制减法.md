# [蓝桥杯 2022 省 B] X 进制减法

## 题目描述

进制规定了数字在数位上逢几进一。

$X$ 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某种 $X$ 进制数，最低数位为二进制，第二数位为十进制，第三数位为八进制，则 $X$ 进制数 `321` 转换为十进制数为 `65`。

现在有两个 $X$ 进制表示的整数 $A$ 和 $B$，但是其具体每一数位的进制还不确定，只知道 $A$ 和 $B$ 是同一进制规则，且每一数位最高为 $N$ 进制，最低为二进制。请你算出 $A-B$ 的结果最小可能是多少。

请注意，你需要保证 $A$ 和 $B$ 在 $X$ 进制下都是合法的, 即每一数位上的数字要小于其进制。

## 说明/提示

**【样例说明】**

当进制为：最低位 $2$ 进制, 第二数位 $5$ 进制, 第三数位 $11$ 进制时, 减法得到的差最小。此时 $A$ 在十进制下是 $108$，$B$ 在十进制下是 $14$，差值是 $94$。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$N \leq 10,M_{a}, M_{b} \leq 8$.

对于 $100 \%$ 的数据，$2 \leq N \leq 1000,1 \leq M_{a}, M_{b} \leq 10^5,A \geq B$。

蓝桥杯 2022 省赛 B 组 E 题。

## 样例 #1

### 输入

```
11
3
10 4 0
3
1 2 0```

### 输出

```
94```

# 题解

## 作者：Rain_chr (赞：10)

### UPDATE
2023.2.21 添加了第一位读者 @Palpitate23 的问题并解答

2023.3.13 添加了第二位读者 @abc1352758620 的问题并解答

2023.4.4 修了公式中不完善的地方。

### question & answer

Q : 为什么计算 $ka$ 和 $kb$ 时也要对 $10^7$ 取模啊 ，题目的意思不是最后相减完再取模就可以了吗？

A : 是这样的，因为两个数 $A$ 和 $B$ 是 $10^5$ 级别的，如果先算出值再减法，没有任何一种变量存的下。而且越到后面这一位的权值越大，呈指数级别上涨，除非使用高精度，否则没有办法计算。而且取模运算有一个特性，加法和乘法可以任意取模，所以我就每计算一遍都取模。

问题来自：@Palpitate23

Q ：如果某一位的数字，出现 $a_i<b_i$ ，那么 $a_i-b_i$ 就变成负数了，是否需要借位？如果为负数，能否得出答案？

A ：思考的很全面，因为题面中提到了 $A−B$ 的结果的最小可能值转换为十进制后再模 $10^7$ 的结果，所以答案一定是一个取模意义下的数值。

借位其实就是直接取模后减法，即使答案是一个负数，但是在取模意义下的结果，所以我们直接进行取模意义下的减法即可。

另外，其实题目中保证了 $A-B$ 非负。

问题来自：@abc1352758620

在此由衷感谢！

### 题意简述

这题其实非常好理解，只是有一点点要注意。

平常的 $n$ 进制中，第 $i$ 位代表的值是 $a_i \times n^i$ ， 其中 $i$ 从0开始计数，从右往左数。

但在此题中，由于进制不同，无法以上方式子得到权值，第i位的权值是 $a_i \times \prod_{j=0}^i n_i$ ，其中 $n_i$ 是第i位的权值，这点值得谨记。

### 题目分析

对于每一位， $a_i$ 和 $b_i$ ,显然这一位的进制 $x$ 必须满足 $x>\max(a_i,b_i)$ ,不然的话没法儿表示。又因为要使得差尽可能小，所以每一位进制就是 $\max(a_i,b_i)+1$ ，这里是贪心思想。

最后直接上代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100010];
int b[100010];
int c[100010]; 
int d[100010];
const int mod=1e9+7;
signed main()
{
	int n; //输入部分 
	cin>>n;
	int ma;
	cin>>ma;
	for(int i=ma;i;i--)
		cin>>a[i];
	int mb;
	cin>>mb;
	for(int i=mb;i;i--)
		cin>>b[i];
		
	for(int i=max(ma,mb);i;i--) //处理进制 
		c[i]=max(a[i],b[i])+1;
	for(int i=max(ma,mb);i;i--) //最低进制是二进制 
		c[i]=c[i]>2?c[i]:2;
		
	d[1]=1; //处理每一位的价值 
	for(int i=2;i<=max(ma,mb);i++)
		d[i]=(d[i-1]*c[i-1])%mod;
		
	long long ka=0,kb=0; //统计价值 
	for(int i=ma;i;i--)
		ka+=a[i]*d[i],ka%=mod;
	for(int i=mb;i;i--)
		kb+=b[i]*d[i],kb%=mod;
	
	cout<<(ka-kb+mod)%mod; //特别注意：模意义下的减法 
	return 0;
}
```

### 思考提升

如果题目要求每一位的进制互不相同呢？

提示：考虑求每一位权值的式子。

结论：还是贪心，让低位的进制尽可能的小，以此保证后面的权值尽可能的小。


---

## 作者：xuchuhan (赞：6)

## 题目大意

给你 $2$ 个同一进制规则的 $X$ 进制数 $A,B$，但是其具体每一数位的进制还不确定，试求出 $A-B$ 的最小值。

## 样例解析

这道题最大一个难点就是，就是不知道 $X$ 进制是怎么算的。那我们不如代入样例去算一遍。

以样例的 $B$ 举例，同时最低位为 $2$ 进制，第二数位 $5$ 进制，第三数位 $11$ 进制。相信很多人，都是像下面这样算 $X$ 进制的：

$$(120)_X=1 \times 2^2 + 2 \times 5^1 + 0 \times 11^0=4+10+0=14$$

很凑巧地算出了 $14$。

但把这种算法代入样例的 $A$，就可以很容易地知道，这种算法是不对的。那咋算？其实，第 $i$ 位的值是比第 $i$ 位低的位上的进制之积再乘上第 $i$ 位上的数值。同样代入样例理解一下。

$$(120)_X=1 \times (5 \times 2)+2 \times 2+0 \times 1=10+4+0=14$$

## 具体思路

其实看到样例解释中每一位的进制取值，再结合一下样例，就知道每一位的进制的取法了。不过还是大概说一下原因。

本题运用贪心思路。

题目保证 $A \geq B$，所以想要 $A-B$ 的值尽量小，每一位的权值也得尽量小，因为如果让 $B$ 变大，$A$ 就会比 $B$ 变大得更快，从而让 $A-B$ 的值变得更大。那么，如果想让每一位的权值尽量小，每一位的进制也得尽量小，因为每一位的权值是和它低的位的进制有关系的，把每一位的进制减小，那么它的高位的权值也会变小。

所以本题的贪心策略就是每一位取最小的进制值。

但要保证每一位取得进制的**合法性**，也就是说，第 $i$ 位进制的取值不得小于 $a_i$，也不得小于 $b_i$。因此，第 $i$ 位的进制就是 $\max(a_i,b_i)+1$。

同时有些细节需要注意。

- $ma$ 和 $mb$ 的长度不一定相同。

- $\max(a_i,b_i)+1$ 有可能是 $1$，需要变成 $2$。

- 由于模数很大，所以需要开 `long long`。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+5,MOD=1e9+7;
int n,ma,mb,x,y;
int a[N],b[N],tmp[N],final[N];
//a和b是输入数组，tmp存每一位的最小权值，final存比这位低的位上的进制之积
signed main(){
	cin>>n>>ma;
	for(int i=1;i<=ma;i++){
		int x;
		cin>>x;
		a[ma-i+1]=x;
	}
	cin>>mb;
	for(int i=1;i<=mb;i++){
		int x;
		cin>>x;
		b[mb-i+1]=x;
	}
	for(int i=max(ma,mb);i>=1;i--)
		tmp[i]=max(max(a[i],b[i])+1,1LL*2);//算出每一位的权值
	final[1]=1;
	for(int i=2;i<=max(ma,mb);i++)
		final[i]=(final[i-1]*tmp[i-1])%MOD;//前缀和维护乘积
	for(int i=max(ma,mb);i>=1;i--){
		x=x+final[i]*a[i];
		y=y+final[i]*b[i];
		//加
		x%=MOD,y%=MOD;
		//每次取模
	}
	int ans=x-y;
	//答案可能为负数
	while(ans<0)
		ans+=MOD;
	ans%=MOD;
	cout<<ans;
	return 0;
}
```

---

## 作者：0x282e202e2029 (赞：4)

# P8782 [蓝桥杯 2022 省 B] X 进制减法 题解

[题目传送门](https://www.luogu.com.cn/problem/P8782)

## 思路

贪心 + 模拟。

因为 $X$ 进制数每一数位的进制并不固定，因此考虑对每一位赋进制值。

由于我们要求 $X$ 进制数 $A - B$ 的结果的最小可能值，因此我们希望**在每一位上的进制都尽可能小**。

但同时，我们仍要保证 $A$ 和 $B$ 在 $X$ 进制下的合法性，因此每一位的进制 $d_i = \max(a_i + 1, b_i + 1)$。在此情况下，如 $a_i, b_i$ 均为 $0$，则进制会等于 $1$，同样是不合法的，因此我们需要改写为 $d_i = \max(2, \max(a_i + 1, b_i + 1))$。

而在计算的同时，可以使用秦九韶算法优化过程，~~简称压行~~。

[秦九韶算法学习](https://baike.baidu.com/item/%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95/449196?fr=aladdin)

## 警钟长鸣

- 进制最小是 $2$。

- 计算过程中，有可能某些结果会 $> 2147483647$，需要开 `long long`。

- 读入数据时，由于 $M_a$ 与 $M_b$ 可能不同，因此要将最低位对齐。

- 不要忘记减法的取模要先加上模数，再取模。（被坑了，输出负数，得 $80 pts$）

## AC 代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 1e5 + 10;
const long long MOD = 1e9 + 7;//好习惯
int n, ma, mb;
int a[MAXN], b[MAXN];
long long ans;
int main()
{
    scanf("%d %d", &n, &ma);
    for(int i = ma - 1; i >= 0; i--)
	{
		scanf("%d", &a[i]);
	}
    scanf("%d", &mb);
    for(int i = mb - 1; i >= 0; i--)
	{
		scanf("%d", &b[i]);
	}//输入，最低位对齐
    for(int i = max(ma, mb) - 1; i >= 0; i--)//取较大位数
    {
        ans = (ans * max(2, max(a[i] + 1, b[i] + 1)) + a[i] - b[i] + MOD) % MOD;//秦九韶算法，注意进制数
	}
    printf("%lld", ans);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/112814324)

---

## 作者：caoyuchen110911 (赞：3)

# P8782 X 进制减法 题解
## 思路

需要求最小数，越小越好，但至少要比 $ A_i $ 和 $ B_i $ 大，而且至少要是 $ 2 $ 进制。

为什么呢？

比如: $ 111 $ 这个 $ X $ 进制数。

$ X = 2 $：值为 $ 7 $。

$ X = 3 $：值为 $ 13 $。

$ X = 4 $：值为 $ 21 $。

要尽量小，当然选 $ X = 2 $ 的情况啦！

所以可以求出：
```cpp
for(int i=1;i<=max(ma,mb);i++)j[i]=max(2,max(a[i]+1,b[i]+1));//jz即进制
```
有了进制，结果又怎么求呢？

首先，[什么是 $ X $ 进制?](https://www.luogu.com.cn/discuss/661093)

弄明白了这一点，就可以求出：

```cpp
for(int i=max(ma,mb);i>=1;i--)//注意mb可能大于ma(我自己被坑过，会变成80分)
{
	s*=j[i];//高位的乘上进制
	s=s+a[i]-b[i];//a[i]-b[i]纳入结果
	s+=1000000007;//防负数
	s%=1000000007;//取余
}
```

## 完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000005],b[1000005],j[1000005];
int main()
{
	int n,ma,mb;
	long long na=0;
	scanf("%d",&n);
	scanf("%d",&ma);
	for(int i=ma;i>=1;i--)scanf("%d",&a[i]);
	scanf("%d",&mb);
	for(int i=mb;i>=1;i--)scanf("%d",&b[i]);
	for(int i=1;i<=max(ma,mb);i++)j[i]=max(2,max(a[i]+1,b[i]+1));
	for(int i=max(ma,mb);i>=1;i--)
	{
		s*=j[i];
		s=na+a[i]-b[i];
		s+=1000000007;
		s%=1000000007;
	}
	printf("%lld",s);
   while(n)n=n;//防作弊
	return 0;
}
```

#### 本蒟蒻的第一篇题解,不喜勿喷!

---

## 作者：lileyang123 (赞：2)

## P8782 [蓝桥杯 2022 省 B] X 进制减法
#### 用到了贪心算法。
只要注意几点：
- 1.进制越数越大，不过也要满足 $a_i$ 和 $b_i$ 大小才行，其实只要能尽量大于二进制就行；
- 2.还是那句话：十年 OI 一场空，不开 long long 见祖宗；

  其他的……看代码就行。
  
  虽然代码丑陋。
### 注意：本题可能不好快读！
 
## Code
```cpp
#include <bits/stdc++.h>
#define int long long//十年OI一场空，不开long long见祖宗 

using namespace std;

const int Mod=1e9+7;
int a[1000010],b[1000010],y[1000010],n,ma,mb,na,cnt;
signed main()
{
	cin>>n>>ma;//无用n，因为n数据不可能大于n 
	for(int i=ma;i>=1;i--)
	{
		cin>>a[i];
	}
	cin>>mb;
	for(int i=mb;i>=1;i--)
	{
		cin>>b[i];
	}
	for(int i=max(ma,mb);i>=1;i--)//选择最大值，需要考虑位数不同的长度 
	{
		/*
			比较2和max(a[i],b[i])+1)是求最小进制 
			选择max(a[i],b[i]+1)是因为 我们求A-B最小值，要选择最大值+1，
			+1是因为 X进制只从0~X-1 
			因为开long long，所以2后加ll 
			转为十进制数 
			+Mod防止负数 
		*/
		cnt=cnt*max(2ll,max(a[i],b[i])+1)+a[i]-b[i];
		cnt+=Mod,cnt%=Mod;
	}
	printf("%lld",cnt); 
	return 0;
}

```
结束。

---

## 作者：IkeveLand (赞：2)

### 贪心求解

- $X$ 进制第 $i$ 位数字上的进制只要求 $a[i]+1$ , $b[i]+1$ 与 $2$ 三者之间的最小值。

- $t$ 表示第 $i$ 位数字前面 $i-1$ 位进制的乘积所以就有 $A=A+ta[i]$ , $B=B+tb[i]$。

- 这题唯一的难点就在于数据处理，后面的大数据会超过数据类型范围，所以需要对 $1\times10^{9}+7$ 取模。

## Code:

```c
#include <bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e5+114,mod=1e9+7 ;

int a[N],b[N];
signed main()
{
	cin.tie(0);cout.tie(0);
    int n,ma,mb;
    cin>>n;
    cin>>ma;
    for(int i=ma;i>0;i--) cin>>a[i];
    cin>>mb;
    for(int i=mb;i>0;i--) cin>>b[i];
    int t=1;
    int A=0,B=0;
    for(int i=1;i<=ma||i<=mb;i++){
        A=(A+t*a[i])%mod;
        B=(B+t*b[i])%mod;
        t=(t*(a[i]+1>b[i]+1?a[i]+1>2?a[i]+1:2:b[i]+1>2?b[i]+1:2))%mod;
    }
    int ans=(A-B+mod)%mod;
    cout<<ans;
    return 0;
}

```

---

## 作者：_cpp (赞：2)

####  一道普通的模拟，不过有点小坑。

### 思路：

用贪心的思想，因为每一位上的进制越小，最后的和才会大。所以枚举一遍 $a$ 和 $b$ 数组。对于每一位数位来说，最小的进制为 $\max(a[i],b[i]) + 1$。但要特别注意，题面中也特别说明了，最低不能低于二进制，所以，如果 $\max(a[i],b[i]) + 1$ 小于二进制，就要变为二进制。

还有就是 $X$ 进制如何转为十进制。其实通过题目描述给出的样例数字可以得出，$X$ 进制每一位的 位权就等于前几位的进制。

例如说 $X$ 进制数 `321`，最低数位为二进制，第二数位为十进制，第三数位为八进制，那转换公式为 $3 \times 10 \times 2 + 2 \times 2 + 1$。

###  代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long P = 1000000007;
long long a[100010],b[100010],c[100010],sum[100010],n,lena,lenb,ans1,ans2;
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
    cin >> n >> lena;
    for(int i = lena;i >= 1;i--) cin >> a[i];  /倒序输入
    cin >> lenb;
    for(int i = lenb;i >= 1;i--) cin >> b[i];
    long long maxlen = max(lena,lenb); //求出最大长度
    for(int i = maxlen;i >= 1;i--) c[i] = max(max(a[i],b[i]) + 1,(long long)(2));  //求每一位的进制
    sum[1] = 1;
    for(int i = 2;i <= maxlen;i++) sum[i] = (c[i - 1] * sum[i - 1]) % P;  //前缀和预处理每一位的位权
    for(int i = lena;i >= 1;i--) ans1 = (ans1 + a[i] * sum[i]) % P;  //计算X进制数A
    for(int i = lenb;i >= 1;i--) ans2 = (ans2 + b[i] * sum[i]) % P;  //计算X进制数B
    cout << (ans1 - ans2 + P) % P;  //因为两数相减可能会出现负数，所以要先加模数，再取模
    return 0;
}
```


---

## 作者：YangXiaopei (赞：1)

## Solution

用贪心，想要和小进制就要尽量小(所以 $n$ 没啥用)。

第 $i$ 位进制最小  $=\max(a_{i}, b_{i}) + 1$，并且要大于等于二进制。

## Code:

上代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define p 1000000007
using namespace std;
int n, ma, mb, sum, a[100005], b[100005], c[100005], w[100005];
signed main(){
	cin >> n;
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> ma;
	for(int i = ma; i >= 1; i--){//倒存，方便计算
		cin >> a[i];
	}
	cin >> mb;
	for(int i = mb; i >= 1; i--){
		cin >> b[i];
	} // 输入
	int x = max(ma, mb);//算长度
	int y = 2;//开了longlong后面判断用的
	for(int i = 1; i <= x; i++){
		w[i] = max(y, (max(a[i], b[i]) + 1));//存进制
	}
	c[0] = 1;
	c[1] = w[1];
	for(int i = 2; i <= x; i++){
		c[i] = (c[i - 1] * w[i]) % p;
	}
	for(int i = 1; i <= x; i++){//算差
		sum += ((a[i] - b[i]) % p * c[i - 1]) % p;
		sum %= p;
	}
	sum = (sum % p + p) % p;//处理负数
	cout << sum;//输出
	return 0;
}
```

---

## 作者：tmlrock (赞：1)

此处仅讲思路。

## 1 
题意：两个 $X$ 进制数，求差最小值。

为了方便描述，我们规定：

- $M_A=M_B$。
- 两个数为 ${(A)}_X$ 与 ${(B)}_X$ 两个 $X$ 进制数。
- 两个数可表达为 $(A)_X=x_{M-1}a_M+x_{M-2}a_{M-1}+\cdots+a_1$ 和 $(B)_X=x_{M-1}b_M+x_{M-2}b_{M-1}+\cdots+b_1$。

## 2 
>对于$A-B$ 最小的情况，对于 $\forall i\in \left[1,M\right]$ 有 $x_{i-1} = \max(a_i,b_i)+1$。

笔者用[数学归纳法](https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/5155524)求解。

$M=1$ , 特殊情况，易证。

$M=k$ , 设 $A-B$ 最小的情况时，设 $x_{k-1} = d \not= max(a_k,b_k)+1$，

设 $C(A) = x_{k-2}a_{k-1}+\cdots+a_1$ , 易见，$A=c(A)+x_{k-1}a_k$。

### 情况1：$d < \max(a_k,b_k)+1$
$$d-1<\max(a_k,b_k),d\in N \Rightarrow d \leq \max(a_k,b_k)$$
$d \leq \max(a_k,b_k) \Rightarrow a_k < d,b_k < d \Rightarrow max(a_k,b_k) < d$，假设不成立。

### 情况2：$d > \max(a_k,b_k)$
$$(da_k + C(A))-(db_k + C(B)) < (\max(a_k,b_k)a_k +C(A))+(\max(a_k,b_k)a_k+C(A))$$
$$\Rightarrow da_k-db_k < \max(a_k,b_k)a_k - \max(a_k,b_k)b_k\Rightarrow d(a_k-b_k) < \max(a_k,b_k)(a_k-b_k) $$
$\Rightarrow d < \max(a_k,b_k)$ 假设不成立。

----
综上，$x_{k-1} = \max(a_k,b_k)+1$

代码就不给了。

---

## 作者：_Lazy_whr_ (赞：0)

# 题目大意
给定两个数 $a,b$，每一位的进制不同。给出每一位的十进制表示，求如何分配每一位的进制，使得 $a-b$ 最小。
# 题解
使用贪心算法。首先我们设第 $i$ 位最终的进制为 $ans_i$，那么 $ans_i>\max(a_i,b_i)$，不然这一位的数就不止一位了。接着我们要 $a-b$ 最小，但 $a-b$ 与每一位的进制大小乘单调性，也就是说相同的数，进制越大，最后的差也越大。所以我们可以贪心地让 $ans_i$ 最小。又因为 $ans_i>\max(a_i,b_i)$，所以 $ans_i=\max(a_i,b_i)+1$。但是一个进制不许至少为二进制，所以 $ans_i\ge 2$。

最后，我们可以用前缀的方式加速转为十进制的过程。
# AC Code
```cpp
#include<bits/stdc++.h>
#define int long long
// #pragma GCC target("avx")
// #pragma GCC optimize(3,"Ofast","inline")
namespace FastIO
{
	inline int read()
	{
		int x=0,f=1;
		char ch=getchar();
		while(ch<'0'||ch>'9')
		{
			if(ch=='-')
				f=-1;
			ch=getchar();
		}
		while(ch>='0'&&ch<='9')
		{
			x=(x<<1)+(x<<3)+(ch^48);
			ch=getchar();
		}
		return x*f;
	}
	
	template<typename T> inline void read(T &x)
	{
		x=read();
		return;
	}
	
	template<typename T,typename... Args> inline void read(T &x,Args &...x_)
	{
		read(x);
		read(x_...);
		return;
	}
}

namespace Constants
{
	const int INF=1e18;
	const int DIR[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
	const double EPS=1e-6;
	const double PI=3.14159265358979323;
}

using namespace std;
using namespace FastIO;
using namespace Constants;

inline void CLOSE()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	return;
}

const int N=1e5+10;
const int MOD=1e9+7;

int n,m,k;
int a[N],b[N];
int sum[N],ans[N];

signed main()
{
	CLOSE();
	read(k,n);
	for(int i=n;i>=1;i--)
		read(a[i]);
	read(m);
	for(int i=m;i>=1;i--)
		read(b[i]);
	
	for(int i=max(n,m);i>=1;i--)
		ans[i]=max(2LL,max(a[i],b[i])+1);//与2取max避免出现“一进制”
	
	sum[1]=1;
	for(int i=2;i<=max(n,m);i++)
		sum[i]=(sum[i-1]*ans[i-1])%MOD;//前缀加速

	int x=0,y=0;
	for(int i=max(n,m);i>=1;i--)
	{
        //转为十进制
		x=(x+sum[i]*a[i])%MOD;
		y=(y+sum[i]*b[i])%MOD;
	}

	cout<<((x-y)%MOD+MOD)%MOD<<endl;//注意可能是负数，负数取模要先模在家最后再模一遍
	return 0;
}

```

---

## 作者：__Ginka__ (赞：0)

## 一、整体思路

1\. 理解题意：

- $X$ 进制是每一数位的进制不固定，最低为二进制，最高 $N$ 进制。
- 例如 $X$ 进制数 $321$，其中 $3$ 的进制为八进制，$2$ 的进制为十进制，$1$ 的进制为二进制，转换为十进制数为 $3 \times 8 \times 2 + 2 \times 2 + 1 = 65$。
- 要求计算两个 $X$ 进制数 $A$ 和 $B$ 的差值最小可能值，且保证 $A$ 和 $B$ 在 $X$ 进制下都是合法的，即每一数位上的数字要小于其进制。

2\. 求解思路：

- 为了使 $A - B$ 的结果最小，需要在保证进制合法的情况下，让所有数位的进制尽可能小。
- 首先确定每个数位的最小进制，即取该数位上两个数中的较大值加一作为该数位的进制。
- 然后将 $A$ 和 $B$ 分别转换为十进制数，最后计算它们的差值并取模。

## 2. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9+7;
int n,ma,mb,k,a[114514],b[114514],base[114514];
int main()
{
    cin>>n;
    cin>>ma;//A的位数
    for(int i=ma;i>=1;i--) cin>>a[i];//各个数位上的数字
    cin>>mb;//B的位数
    for(int j=mb;j>=1;j--) cin>>b[j];//B的各个数位上的数字
    k=max(ma,mb);//较长的位数
    for(int i=1;i<=k;i++)
        base[i]=max(2,max(a[i],b[i])+1);//每个数位的最小进制
    long long A=0,B=0;
    for(int i=ma;i>=1;i--)
        A=(A*base[i]+a[i])%inf;//转换为十进制数并取模
    for(int i=mb;i>=1;i--)
        B=(B*base[i]+b[i])%inf;//转换为十进制数并取模
    long long ans=(A-B+inf)%inf; //A-B的结果并取模，加inf是为了防止结果为负数
    cout<<ans;
    return 0;
}
```

---

## 作者：Infinite_Eternity (赞：0)

# Description

[P8782 [蓝桥杯 2022 省 B] X 进制减法](https://www.luogu.com.cn/problem/P8782
)

给定两个 $X$ 进制表示的整数 $A$ 和 $B$，但是其具体每一数位的进制还不确定，只知道 $A$ 和 $B$ 是同一进制规则，且每一数位最高为 $N$ 进制，最低为二进制。求 $A-B$ 的结果最小可能是多少。

数据范围：$2 \leq N \leq 1000$，$1 \leq M_{a},M_{b} \leq 10^5$，$A \geq B$。

# Analysis

贪心题。

对于题目中所给的数 $321$ 来说，$3$ 所在的位是 $8$ 进制，$2$ 所在的位是 $10$ 进制，$1$ 所在的位是 $2$ 进制。不难发现：

$$3 \times 10 \times 2 + 2\times 1+1=60+4+1=65$$

因此，我们可以得到：**第 $i$ 位的权值 $=$ 比第 $i$ 位低的位上的进制之积。**

由于 $A \geq B$，为了使 $A-B$ 的结果尽可能地小，我们应该使得**高位上的权值尽可能地小**。此时，就得出了我们的贪心策略：**降低高位上的权值**。

结合对影响权值因素的分析，我们可以知道：当低位上每一位数的进制都取到最小时，高位上的权值最小。因为每一位都给出了两个数 $A$ 和 $B$，并且由于进制不可能 $\leq a\text{~or}\leq b$，所以我们只要令该位的进制为 $\max(A,B)+1$ 即可。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){ x=0;register int f=1;register char c=getchar();while(c < '0' || c > '9'){if(c=='-')f=-1;c=getchar();}while(c >= '0' && c <= '9'){x=x*10+c-'0';c=getchar();}x*=f;}
const int N = 1e5 + 10;
const int mod = 1000000007;
int a[N],b[N],x[N];
int n,M_a,M_b;
inline int max(int a,int b){return (a) > (b) ? (a) : (b);}
int main()
{
	read(n);
	read(M_a);
	for(int i = 1;i <= M_a;i++) read(a[i]);
	read(M_b);
	for(int i = 1;i <= M_b;i++) read(b[i]);
	for(int i = 1;i <= M_a / 2;i++)//将数据按低位到高位存放
		swap(a[i],a[M_a - i + 1]);
	for(int i = 1;i <= M_b / 2;i++)
		swap(b[i],b[M_b - i + 1]);
	int k = max(M_a,M_b);//找出最大位数
	for(int i = 1;i <= k;i++)
		x[i] = max(2,max(a[i],b[i]) + 1);//x数组记录对应位置符合条件的最小的进制数
	long long A = 0,B = 0;
	for(int i = M_a;i >= 1;i--)//注意从高位开始计算
		A = (A * x[i] + a[i]) % mod;
	for(int i = M_b;i >= 1;i--)
		B = (B * x[i] + b[i]) % mod;
	long long ans = (A - B + mod) % mod; //防止出现负数
	printf("%lld",ans);
	return 0;
}
```

Ps.此解为目前洛谷最优解。

---


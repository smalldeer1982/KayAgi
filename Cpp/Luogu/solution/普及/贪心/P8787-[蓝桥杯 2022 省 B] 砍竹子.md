# [蓝桥杯 2022 省 B] 砍竹子

## 题目描述

这天，小明在砍竹子，他面前有 $n$ 棵竹子排成一排，一开始第 $i$ 棵竹子的高度为 $h_{i}$.

他觉得一棵一棵砍太慢了，决定使用魔法来砍竹子。魔法可以对连续的一段相同高度的竹子使用，假设这一段竹子的高度为 $H$，那么使用一次魔法可以把这一段竹子的高度都变为 $\left\lfloor\sqrt{\left\lfloor\frac{H}{2}\right\rfloor+1}\right\rfloor$, 其中 $\lfloor x\rfloor$ 表示对 $x$ 向下取整。小明想知道他最少使用多少次魔法可以让所有的竹子的高度都变为 $1$。

## 说明/提示

**【样例说明】**

其中一种方案:

$214267\rightarrow 214262\rightarrow 214222\rightarrow 211222\rightarrow 111222\rightarrow 111111$

共需要 5 步完成

**【评测用例规模与约定】**

对于 $20 \%$ 的数据，保证 $n \leq 1000, h_{i} \leq 10^{6}$ 。

对于 $100 \%$ 的数据，保证 $n \leq 2 \times 10^{5}, h_{i} \leq 10^{18}$ 。

蓝桥杯 2022 省赛 B 组 J 题。

## 样例 #1

### 输入

```
6
2 1 4 2 6 7```

### 输出

```
5```

# 题解

## 作者：封禁用户 (赞：56)

# 题目大意

每次操作将序列中相同元素全部写为 $\sqrt{\left \lfloor\frac{h_i}{2}\right\rfloor -1}$，问几次操作能将序列中所有元素置成一。

# 题目解析

本题是一道贪心。

使用两个数组，一个存储竹子高度，一个存储竹子还能被砍几次。

循环砍伐可以砍伐次数最高的竹子，直到竹子都不能被砍。

代码如下：

```cpp
#include<bits/stdc++.h>
const int maxn=1000050;
using namespace std;
int main(){
	int h[maxn],cnt[maxn],n,ans=-1,num=0;cin>>n;
    for(int i=0;i<n;++i){
    	cin>>h[i];
    	int temp=h[i];
    	while(temp-1)
    		cnt[i]+=1,temp=sqrtl(temp/2+1);
		ans=max(ans,cnt[i]);
	}
	for(int i=ans;i>0;--i)
		for(int j=0;j<n;++j)
			if(cnt[j]==i){
				if(h[j]!=h[j+1])
					num+=1;
				cnt[j]-=1;h[j]=sqrtl(h[j]/2+1);
			}
	cout<<num;
	return 0;
}
```
可结果却不尽人意：

![](https://cdn.luogu.com.cn/upload/image_hosting/gn66ry3c.png)

我思考良久后，发现了一个问题：

没开 `long long`!

正如网络所说：10 年 OI 一场空，不开 long long 见祖宗。

正确代码如下：

```cpp
#include<bits/stdc++.h>
const long long maxn=1000050;
using namespace std;
int main(){
	long long h[maxn],cnt[maxn],n,ans=-1,num=0;cin>>n;
    for(long long i=0;i<n;++i){
    	cin>>h[i];
    	long long temp=h[i];
    	while(temp-1)
    		cnt[i]+=1,temp=sqrtl(temp/2+1);
		ans=max(ans,cnt[i]);
	}
	for(long long i=ans;i>0;--i)
		for(long long j=0;j<n;++j)
			if(cnt[j]==i){
				if(h[j]!=h[j+1])
					num+=1;
				cnt[j]-=1;h[j]=sqrtl(h[j]/2+1);
			}
	cout<<num;
	return 0;
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/008wt6h2.png)

都看到这里了，留个赞再走吧。

---

## 作者：H2130819068 (赞：23)

# 思路
用贪心的思路来解，每个竹子都只能由高到低。

需用使用两个数组，一个是用来存储竹子的高度的，另外一个是用来存储竹子还能被砍几次。

循环砍伐可以砍伐次数最高的竹子，直到竹子都不能被砍伐，**要注意的是砍伐次数相同的竹子高度可能是不一致的，那就不能使用“连续砍伐魔法”**。

# 代码
```cpp
#include<iostream>
#include<cmath>
#include<queue>
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL data[200005];//存储竹子的高度 
int p[200005]={0};//存储竹子还能被砍伐的次数 
int main()
{
	int n;
	int Max=0;//最高的竹子要被砍几次 
	long long cnt=0;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>data[i];
		LL t=data[i];
		while(t-1)//计算每个竹子要被砍伐的次数 
		{
			p[i]++;
			t=sqrtl(t/2+1);
		}
		Max=Max>p[i]?Max:p[i]; 
	}
	for(int i=Max;i>0;i--)//从最高的砍伐次数开始循环 
	{
		for(int j=0;j<n;j++)//这个不用说肯定要遍历数组 
		{
			if(p[j]==i)
			{
				if(data[j]!=data[j+1])//当两个高度不一样的时候才计数，因为高度一样可以使用“魔法” 
					cnt++;
				p[j]--;//被砍伐了一次，可砍伐次数减一 
				data[j]=sqrtl(data[j]/2+1);//被砍伐了，用公式计算被砍伐后的高度； 
			}
		}
	}
	cout<<cnt;
	return 0;
} 
```


---

## 作者：MuLinnnnn (赞：8)

**[原题目链接 (P8787)](https://www.luogu.com.cn/problem/P8787)**

**题意+思路**

我理解的大意是：每次操作将序列中连续相同元素全部置成 $\sqrt{\left \lfloor\frac{h_i}{2}\right\rfloor -1}$。最后问需要几次操作将序列中所有元素置成一。

思路：考虑贪心。最多次数以序列中最大的数用的次数为准，每次砍伐需要将砍伐次数减一。这也就意味着我们要开两个数组。

p.s.：不开`long long`见祖宗。

**Accept Code：**
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll; //long long
ll h[1000003],cnt[1000003];

inline ll max(ll a, ll b){ //重载运算符
	return a > b ? a : b;
}

int main(){
    int n;
    scanf("%d",&n); //input
    ll maxCnt = -1,ans = 0;
    for(int i = 0; i < n; ++i){
    	scanf("%lld",&h[i]); //input
    	ll temp = h[i];
    	while(temp - 1){
    		++cnt[i]; //最大砍伐次数
    		temp = sqrtl(temp / 2 + 1); //套用公式
		}
		maxCnt = max(maxCnt, cnt[i]);
	}
	for(int i = maxCnt; i > 0; --i){
		for(int j = 0; j < n; ++j){
			if(cnt[j] == i){
				if(h[j] != h[j + 1]) //如果不连续需要魔法次数+1
					++ans;
				--cnt[j];
				h[j] = sqrtl(h[j] / 2 + 1); //套用公式
			}
		}
	}
	printf("%lld",ans); //output
	return 0;
}

```


---

## 作者：行吟啸九州 (赞：7)

这个问题有如下两个性质。第一个性质是，如果两个竹子相邻且高度一致，那么这两个竹子一定要一起砍到。第二个性质是，一个竹子被砍伐 $O( \log h_i)$ 次后，高度一定会被砍到 $1$，所以最多进行 $O(n \log h_i)$ 次砍伐。

考虑贪心，每次将当下最高的一段竹子砍倒，这个做法一定不劣于其他砍法。这是由于只有高的竹子可能变矮，矮的竹子不会变高。

考虑暴力实现这个过程，我们每次通过 $O(n)$ 的遍历找出当下最高的一段竹子，将他们完全砍倒。由于第二个性质，所以这个做法的复杂度是 $O(n ^ 2 \log hi)$。

对于每段相同高度的竹子，可以用并查集去维护他们，不妨选取每段竹子最左边的竹子作为这个并查集的根，然后用堆维护这些并查集。堆的排序关键字是每段竹子的高度，和每段竹子左端点所在的位置，前者为排序第一关键字，后者为第二关键字。

我们每次砍伐，取出当下最高的一段竹子（优先取右边的），如果这段竹子的高度和左边的那段竹子一致，则将他们合并，否则将这段竹子砍倒，不断进行如此的操作，直到所有竹子高度都变为 $1$。由于第二个性质，故复杂度 $O(n \log^2 h_i)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200005
#define int long long
#define For(i, j, n) for(int i = j ; i <= n ; ++i)
int n, cnt, fa[N];
struct node{ 
	int h, p; 
	friend bool operator < (node x, node y){
		if(x.h == y.h) return x.p < y.p;
		return x.h < y.h;
	}
}t, a[N];

inline int find(int x){ return fa[x] ^ x ? fa[x] = find(fa[x]) : x; }

signed main(){
	scanf("%lld", &n);
	priority_queue<node>q;
	For(i, 1, n) scanf("%lld", &a[i].h), a[i].p = fa[i] = i;
	For(i, 2, n) if(a[i].h == a[i - 1].h) fa[find(i)] = find(i - 1);
	For(i, 1, n) if(find(i) == i && a[i].h > 1) q.push(a[i]); 
	while(!q.empty()){
		t = q.top();
		q.pop();
		if(t.h == a[find(t.p - 1)].h) fa[find(t.p)] = find(t.p - 1);
		if(find(t.p) ^ t.p) continue;
		a[t.p].h = t.h = sqrt((int)(t.h / 2) + 1);
		if(t.h > 1) q.push(t);
		++cnt;
	}
	printf("%lld", cnt);
	return 0;
}

---

## 作者：Dreamer_Boy (赞：6)

必须挑战一波最简单的写法。

这题为什么不用 map 做呢？多方便啊。


读入每一个数，我们清空它相对应的地点，然后只要 $x$ 大于 $1$ 的话，就一直看，它的上一段中是否存在 $x$，存在那显然就把答案累加，最后在用更加稳定的 sqrtl 来进行划分。

讲一下划分的原则，通过观察可以发现，对于每一根竹子，砍到 $1$ 的这条路径是固定不变的，我们可以将这一条路径记录下来，就能得到关于每根竹子一条从 $1$ 到达 $a_i$ 的路径。接下来我们倒着考虑，所有竹子从 $1$ 开始变回原序列，用一个数记录当前循环到第几层，最后用 sqrtl 稳定一下就行了。

#### 代码
不用吸氧就能过。
```
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+10;

int n;
unordered_map<long long, int> mp[2];
long long x;
int ans;

int main() {
    cin >> n;
    for(int i = 1; i <= n; ++i) {
        mp[i & 1].clear();
        cin >> x;
        while(x > 1) {
            if(mp[i-1 & 1].count(x)==false) 
            	ans++; 
            mp[i & 1][x] = 1;
            x = sqrtl(x/2 + 1);
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：hmh100211 (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/P8787)

## 题意分析：

给定一个长度为 $n$ 的序列，每次操作可以选择一段**元素相同**的区间，并将这一段区间内的元素 $H$ 全部修改为 $\left\lfloor\sqrt{\left\lfloor\frac{H}{2}\right\rfloor+1}\right\rfloor$（其中 $\lfloor x\rfloor$ 表示对 $x$ **向下取整**）。问最小操作次数是多少。

## 思路：

非常明显，这题是个贪心。因为这题是求最小操作次数，而且每次操作都会变小，所以肯定要优先操作大的元素，这样它变小之后才可能和其它元素一起操作以减少操作次数。

那么这个“大”的定义是什么呢？举个栗子，有三个元素，$2,4,6$，如果每个元素单独修改，$2$ 可以修改成 $1$，只能修改一次。$4$ 也可以修改成 $1$，也只能修改一次。而 $6$ 可以修改成 $2$，再修改成 $1$，可以修改两次。如果只能修改一个，很明显，我们肯定会优先修改 $6$。为什么？因为 $6$ 最大？并不是，因为 $6$ 的**还能操作的次数最大**，操作后**有可能和相邻的竹子能够一起砍**，一起砍肯定比分开砍**操作次数小**。

推到这，思路已经差不多推出来了：建立两个数组，一个存竹子高度，一个存还能被砍的次数。读入完之后循环把序列中砍伐次数最大的竹子砍一次并记录砍伐次数。这里注意，区间修改的要求是**相邻且高度相同**，所以要判断砍伐次数最大的竹子是否相邻且高度相同，如果是那就一起砍了。

# AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long //开long long
inline int magic(int h){return (int)(floor(sqrtl(double(h/2+1))));} //定义magic函数
const int N=2e5+5; //数组上限
int n,a,cutmax=-1,h[N],cnt[N],ans=0;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);cout.tie(NULL);
    //输入输出优化
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>h[i]; //读入高度
        a=h[i];
        while(a!=1){
            cnt[i]++; //处理可砍伐次数
            a=magic(a);
        }
        cutmax=max(cutmax,cnt[i]); //记录最大可砍伐次数
    }
    for(int i=cutmax;i>=1;i--){ //从最大砍伐次数遍历到一
        for(int j=1;j<=n;j++){ //遍历数组
            if(cnt[j]==i){ //如果是目前最大砍伐次数
                if(h[j]!=h[j+1]){ //而且和下一根竹子的高度不一样
                    ans++; //操作次数+1
                }
                cnt[j]--,h[j]=magic(h[j]); //可砍伐次数减一，修改高度
            }
        }
    }
    cout<<ans; //输出操作次数
    return 0;
}
```

# [AC](https://www.luogu.com.cn/record/119792512)



### 2023.9.4 感谢 [ZHANGyutao123](https://www.luogu.com.cn/user/912445) dalao 指出的错误，已修改

---

## 作者：_Memory (赞：4)

## 一、前言

蒟蒻一生的第四篇题解，写的不好，各位大佬们勿喷。

## 二、题意

将所有相同高度的竹子进行 $ \left\lfloor\sqrt{\left\lfloor\frac{H}{2}\right\rfloor+1}\right\rfloor $ 的操作，求最少多少次能够使得它的基准为 $ 1 $。

## 三、思路

我们看了样例以后其实就可以大概知道这道题的思路，我们需要先去砍最高的那个。然后重复这个动作，直到基准为 $ 1 $。先来看这个公式，稍微算一下就可以发现，它可以写成对 $ n/2+1 $ 开根。使用的时候可以用 `int` 类型转换，自然就会向下取整。接下来我们配合代码讲解。

```cpp
#define int long long
int qwq(int x){
	x=(int)(sqrtl(x/2+1));
	return  x;
}

```
这一段就是我开根的一个函数代码，记住一个点，不开  `long long` 见祖宗！还有就是开了 `define` 之后，那个强制型转需要用括号括起来。

```cpp
int n,h[1000001],ans=0,a[1000005],sum=0;
int maxn=-1;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
		ans=h[i];
		while(ans-1){
			a[i]++;//最大次数
			ans=qwq(ans);//调用函数进行操作
		}
		maxn=max(maxn,a[i]);//再次记录最高竹子
	}
```
这是第一个重点代码，我们需要设置的不只是竹子的高度 $ h $ 数组，还有一个来储存砍掉竹子之后剩余最高告诉的数组 $ a $。为了避免竹子高度收到流程的改变，我们使用一个变量储存它。先算出砍伐竹子的最大次数，接着对储存原始高度的变量 `ans` 进行函数调用操作。接着把最大值调成砍伐后的最大值即可。

```cpp
for(int i=maxn;i>=1;i--){
	for(int j=1;j<=n;j++){
	    if(a[j]==i){
	    if(h[j]!=h[j+1]) sum++;
	    a[j]--;
	    h[j]=qwq(h[j]);
            }
	}
}
	cout<<sum<<endl;
```
这一段就是判断是否有高度相同且连续的竹子，循环最大高度，如果说高度相同且连续，就所有符合条件的进行操作，不符合就单独算，次数加一。最后输出这个次数就可以愉快的 AC 啦！

---

## 作者：kkksc1223 (赞：0)

思路：

首先，我们可以发现，对于一段连续的相同高度的竹子，使用一次魔法后，它们的高度都会变成 $\left\lfloor\sqrt{\left\lfloor\frac{H}{2}\right\rfloor+1}\right\rfloor$，其中 $H$ 是这段竹子的高度。

因此，我们可以考虑贪心，每次找到一段连续的相同高度的竹子，使用一次魔法，使得这段竹子的高度都变成 $\left\lfloor\sqrt{\left\lfloor\frac{H}{2}\right\rfloor+1}\right\rfloor$。然后，我们再次从左到右遍历所有竹子，如果发现有竹子的高度不为 $1$，那么就继续找到一段连续的相同高度的竹子，使用一次魔法，使得这段竹子的高度都变成 $\left\lfloor\sqrt{\left\lfloor\frac{H}{2}\right\rfloor+1}\right\rfloor$。直到所有竹子的高度都变成 $1$。

代码：
```c

#include<iostream>
#include<math.h>
using namespace std;
 
int cut(long long bam[], int n);
 
int main()
{
    long long bam[200000];
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> bam[i];
    cout << cut(bam, n) << endl;
    return 0;
 
}
 
int cut(long long bam[], int n)
{
    long long echelon[10000];
    int len = 0,count = 0;
    while(bam[0] > 1)
    {
        echelon[len++] = bam[0];count++;
        bam[0] = sqrt(bam[0] / 2 + 1);
    }//判断是否1
    for (int i = 1; i < n; i++)
    {
        long long v = bam[i];
        while(v > 1)
        {
            int flag = 0;
            for (int j = 0; j < len; j++)
                if(echelon[j]==v)
                { flag = 1;break; }
            if(flag) break;
            count++;
            v = sqrt(v / 2 + 1);
        }
        len = 0;
        while(bam[i]>1)
        {
            echelon[len++] = bam[i];
            bam[i] = sqrt(bam[i] / 2 + 1);//进行魔法
        }
    }
    return count;
}

```


---


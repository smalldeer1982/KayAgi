# [传智杯 #5 初赛] D-莲子的物理热力学

## 题目背景

莲子正在研究分子的运动。

每个分子都有一个速度，约定正方向为正，负方向为负。分子的数量极多，速度又并不一致，看上去杂乱无章。于是莲子希望调整部分分子的速度，使得最终分子们看上去整齐。

## 题目描述

莲子给定了 $n$ 个整数 $a_1,a_2,\cdots a_n$，描述每个分子。现在她可以进行**至多** $m$ 次操作（也可以一次也不进行），每次操作可以执行以下两条之一：

- 选择 $i$，满足 $a_i=\min_j\{a_j\}$，然后将 $a_i$ 变为 $\max_j\{a_j\}$。
- 选择 $i$，满足 $a_i=\max_j\{a_j\}$，然后将 $a_i$ 变为 $\min_j\{a_j\}$。

现在莲子希望需要最小化最终序列的极差（最大值减去最小值的差）。请求出最小的极差。

---

例如，对于序列 $a=\{5,1,4\}$，可以进行如下几次操作：

- 选择 $i=1$，满足 $a_1=5$ 是当前的最大值 $5$，可以将 $a_1$ 修改成当前的最小值 $1$，此时序列变成 $\{1,1,4\}$；
- 再选 $i=2$，满足 $a_2=1$ 是当前的最小值 $1$，可以将 $a_2$ 修改成当前的最大值 $4$，此时序列变成 $\{1,4,4\}$。 

这两次操作后得到的序列为 $\{1,4,4\}$。最大值减去最小值的差为 $|4-1|=3$。

当然，这种操作方式得到的极差并非最小。最优策略是，先将最大值 $a_1=5$ 变成目前的最小值 $1$，再把此时的最大值 $a_3=4$ 变成目前的最小值 $1$。此时序列为 $\{1,1,1\}$，得到的极差 $|1-1|=0$ 是所有策略中最小的。



## 说明/提示

### 样例解释

样例 $1$：$\{5,1,4\}\to\{1,1,4\}\to\{1,1,1\}$，极差为 $0$。  
样例 $2$：$\{1,2,3,4,5,6,7,8\}$，什么也做不了，极差为 $7$。  
样例 $3$：$\{1,5,5,5,6,6,9,10\}\to\{10,5,5,5,6,6,9,10\}\to\{5,5,5,5,6,6,9,10\}\to\{5,5,5,5,6,6,9,5\}$，极差为 $4$。

### 数据范围及约定

对于全部数据，保证 $1\le n \le 10^5$，$0\le m\le10^9$，$|a_i|\le 10^9$。

## 样例 #1

### 输入

```
3 2
5 1 4```

### 输出

```
0```

## 样例 #2

### 输入

```
8 0
1 2 3 4 5 6 7 8```

### 输出

```
7
```

## 样例 #3

### 输入

```
8 3
1 5 5 5 6 6 9 10
```

### 输出

```
4
```

# 题解

## 作者：离散小波变换° (赞：12)

### 题解

贪心题。

假设 $m$ 次操作后，剩下来的数字的值域为 $[l,r]$。那么原来 $a$ 数列里，所有**严格小于** $l$ 的数字肯定都被操作了，同时所有**严格大于** $r$ 的数字肯定也被操作了。

设 $a$ 里面一共有 $u$ 个数严格小于 $l$；有 $v$ 个数严格大于 $r$。

**断言**：所需要的操作次数至少为 $u+v+\min(u,v)$，并且可以取到。

**证明**：如果一个位置在操作后，它的值还在 $[l,r]$ 之外，那么后面某个时候肯定还要把它进行操作。容易发现，至少前 $\min(u,v)$ 次操作肯定都无法让结果变到 $[l,r]$ 内。因此执行完这至少 $\min(u,v)$ 次操作后肯定还要再把这 $u+v$ 个数都操作一遍，这是容易做到的（通过 $\min(u,v)$ 次操作，你总能把此时值域的下界提升到 $l$ 或者把上界降低到 $r$）。所以最优决策肯定不会小于 $u+v+\min(u,v)$ 次。

那么这题怎么做呢？

直接将 $a$ 数组从小到大排序。考虑枚举 $l=a_i$，计算出最小的 $r=a_j$，一定有 $(i-1)+(n-j)+\min(i-1,n-j)\le m$。容易发现随着 $i$ 的增大，$j$ 肯定是单调不减的。因此首先预处理 $j=1$，接着随着 $i$ 的增大找到可以满足条件的最小的 $j$。显然当 $i> \min(n,m+1)$ 时就不存在这样的 $j$ 了。

时间复杂度为 $\mathcal O(n\log n)$，瓶颈在于排序。


### 参考代码

版本 $1$：

```cpp
#include<bits/stdc++.h>
#define up(l, r, i) for(int i = l, END##i = r;i <= END##i;++ i)
#define dn(r, l, i) for(int i = r, END##i = l;i >= END##i;-- i)
using namespace std;
typedef long long i64;
const int INF = 2147483647;
int qread(){
    int w=1,c,ret;
    while((c = getchar()) >  '9' || c <  '0') w = (c == '-' ? -1 : 1); ret = c - '0';
    while((c = getchar()) >= '0' && c <= '9') ret = ret * 10 + c - '0';
    return ret * w;
}
const int MAXN = 1e5 + 3;
int A[MAXN], ans = INF;
int main(){
    int n = qread(), m = qread();
    up(1, n, i) A[i] = qread();
    sort(A + 1, A + 1 + n);
    int j = 1;
    up(1, min(n, m + 1), i){
        j = max(i, j);
        while((i - 1) + (n - j) + min(i - 1, n - j) > m) ++ j;
        ans = min(ans, A[j] - A[i]);
    }
    printf("%d\n", ans);
    return 0;
}
```

版本 $2$：

```java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
    
    public static int[] a = new int[100005];

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(), m = scanner.nextInt();
        for (int i = 1; i <= n; ++i)
            a[i] = scanner.nextInt();
        Arrays.sort(a, 1, n + 1);
        int j = 1, ans = Integer.MAX_VALUE;
        for (int i = 1; i <= Math.min(n, m + 1); ++i) {
            j = Math.max(j, i);
            while((i - 1) + (n - j) + Math.min(i - 1, n - j) > m) 
                ++j;
            ans = Math.min(ans, a[j] - a[i]);
        }
        System.out.println(ans);
    }
}
```

---


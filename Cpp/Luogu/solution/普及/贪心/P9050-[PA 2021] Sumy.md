# [PA 2021] Sumy

## 题目描述

有 $n$ 条鱼，其中第 $i$ 条的质量为 $a_i$ 克。

$x$ 能吃掉 $y$ 当且仅当 $a_x > a_y$。

若 $x$ 吃了 $y$，$y$ 会消失，$a_x$ 会变为 $a_x + a_y$。

你可以随意指定吃鱼的顺序，直至留下一条鱼为止。

求每一条鱼是否可能被作为最后**唯一**的鱼留下。**若最终无法只剩下一条鱼，则每条鱼均不满足此条件。**

## 说明/提示

#### 样例 #1 解释
下面用 $x \rightarrow y$ 表示 $x$ 吃 $y$。

留下 $2$ 号鱼的一种方案如下：$2 \rightarrow 1, 2 \rightarrow 3, 2 \rightarrow 4, 2 \rightarrow 5, 2 \rightarrow 6$。
#### 数据范围
对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$1 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
6
2 7 1 8 2 8```

### 输出

```
NTNTNT```

## 样例 #2

### 输入

```
3
5 4 4```

### 输出

```
TNN```

# 题解

## 作者：ZepX_D (赞：9)

### 思路
一条鱼最优的情况肯定是要把能吃的都吃了，因为吃别的鱼能获得更大的收益，但每条鱼都枚举一遍 $ O(n^2) $ 的复杂度肯定是过不了的，发现假如一条鱼能活到最后，那比它重的必然能活到最后，且比它轻的必然活不到最后，满足单调性，所以我们可以先排序后二分，每次模拟一遍看能否活到最后就行，复杂度 $ O(n \log n) $。

### 代码
```cpp
#include <queue>
#include <cstdio>
#include <iostream>
#include <algorithm>
#define ll long long

using namespace std;

inline ll read()
{
	ll x = 0;char ch = getchar();
	while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) x = x*10+ch-48,ch = getchar();
	return x;
}

struct fish
{
	ll w,id;
}a[500010];
int n;
char ans[500010];
queue < ll > q;

bool cmp(fish x,fish y)
{return x.w < y.w;}

bool check(int k)
{
	while(!q.empty()) q.pop();
	for (int i = 1;i <= n;i++)
		if (i != k) q.push(a[i].w);
	ll s = a[k].w;
	while (!q.empty())
	{
		if (q.front() >= s) return 0;
		s += q.front();q.pop();
	}
	return 1;
}

int main()
{
	n = read();
	for (int i = 1;i <= n;i++)
		a[i].w = read(),a[i].id = i;
	sort(a+1,a+n+1,cmp);
	int l = 1,r = n+1;
	while(l < r)
	{
		int mid = (l+r)>>1;
		if (check(mid)) r = mid;
		else l = mid+1;
	}
	if (l > n) for (int i = 1;i <= n;i++) putchar('N');
	else 
	{
		for (int i = 1;i <= n;i++)
			ans[a[i].id] = (a[i].w >= a[l].w?'T':'N');
		for (int i = 1;i <= n;i++)
			printf("%c",ans[i]);
	}
	return 0;
}
```


---

## 作者：Prolystic (赞：4)

## [原题目](https://www.luogu.com.cn/problem/P9050)

大家应该不难想到一条鱼最简单的一条吃鱼路线，那就是先吃掉所有比自己小的鱼，再尝试继续吃更大的鱼，就选择模拟求解。

这个解题思路的复杂度为 $O(n^2)$，在 $n\leq5\times10^5$ 的数据规模下显然无法通过。但是这个思路可以骗到一半的分，后半部分会 TLE。

本人就是受了这个思路的苦，多亏[这位](https://www.luogu.com.cn/user/363415)、[这位](https://www.luogu.com.cn/user/298994)大佬我才把思路转变过来。

我们记初始质量最小的可以获胜的鱼为 $A$，通过观察不难发现每一条初始质量比 $A$ 大的鱼都可以获胜。比 $A$ 大的那条鱼可以吃掉一条可以获胜的鱼，那么也正好说明了它自己也可能获胜。

答案是具有单调性的，可以考虑二分求解。先排序，用二分求出最小的，可以获胜的鱼 $A$，之后把所有比它大的都标记为可能获胜，最后输出答案即可。

剩下的思路边看代码边看注释理解罢。
```cpp
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <string>
using namespace std;
long long n;//题中n,鱼的个数
struct fish//鱼结构体，存储原来没排序前鱼的顺序
{
    long long big;
    long long id;
}a[500005];//存储5*10^5条鱼
bool fishCmp(fish a,fish b)//结构体排序
{
    return a.big<b.big;
}
bool solve(long long x)//判断一条鱼是否可以留下来
{
    long long temp = a[x].big;
    for(long long i = 1;i<=n;i++)
    {
        if(i==x)
        {
            continue;
        }
        if(temp>a[i].big)
        {
            temp+=a[i].big;
        }
        else
        {
            return false;
        }
    }
    return true;
}
bool arr[500005] = {};//存储每条鱼留不留下来的情况
int main(int argc, const char * argv[])
{
    scanf("%lld",&n);
    for(long long i = 1;i<=n;i++)
    {
        scanf("%lld",&a[i].big);
        a[i].id = i;
    }
    sort(a+1,a+n+1,fishCmp);
    long long l = 1;
    long long r = n;
    long long res = n+1;
    while(l<=r)
    {
        long long mid = (l+r)>>1;
        if(solve(mid))
        {
            res = mid;
            r = mid-1;
        }
        else
        {
            l = mid+1;
        }
    }
    for(long long i = res;i<=n;i++)
    {
        arr[a[i].id] = true;
    }
    for(long long i = 1;i<=n;i++)
    {
        putchar(arr[i]?'T':'N');
    }
    return 0;
}
```

再次感谢 [251sec](https://www.luogu.com.cn/user/363415)，[small\_peter](https://www.luogu.com.cn/user/298994)。

---

## 作者：251Sec (赞：2)

选定一条鱼，考虑它想活下来的最优策略是什么。如果让别的鱼互相吃一定不优，因为这条鱼要想吃掉别的所有鱼，逐个击破一定比等他们抱团之后再杀要劣。再考虑顺序，显然应该从小到大吃。

因此，对一条鱼来说，它的最优策略是：从小到大地吃掉其它所有的鱼。

注意到，由这个策略，可以发现鱼的存活与否满足单调性，即，如果一条鱼能活下来，比它大的鱼一定都能活下来，如果一条鱼活不下来，比它小的一定都活不下来。

因此采用二分答案，转为判定问题，用刚才的策略模拟一遍即可。

注意边界情况：如果所有鱼的大小相同，则最大的鱼也没法吃掉其它所有的鱼，因此二分需要考虑所有鱼都无法活到最后的情况。

```cpp
#include <bits/stdc++.h>
using namespace std; 
typedef long long ll;
int n;
struct Node {
    int v, id;
    bool operator<(const Node &o) const {
        return v < o.v;
    }
} a[500005];
int ans[500005];
bool check(int x) {
    ll t = a[x].v;
    for (int i = 1; i <= n; i++) {
        if (i == x) continue;
        if (t <= a[i].v) return false;
        t += a[i].v;
    }
    return true;
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i].v);
        a[i].id = i;
    }
    sort(a + 1, a + n + 1);
    int l = 1, r = n + 1, res = n + 1;
    while (l <= r) {
        int mid = l + r >> 1;
        if (check(mid)) {
            res = mid;
            r = mid - 1;
        }
        else {
            l = mid + 1;
        }
    }
    for (int i = 1; i <= n; i++) {
        if (i < res) ans[a[i].id] = false;
        else ans[a[i].id] = true;
    }
    for (int i = 1; i <= n; i++) putchar(ans[i] ? 'T' : 'N');
    return 0;
}
```

---

## 作者：REAL_曼巴 (赞：2)

好久没写题解了，今天来一发。因为题意很明显了，就不多说了。

这道题目考察的内容是排序和二分。

我们通过观察发现，我们可以找到一个临界点 $k$，来把所有的鱼分成可以留下或者不可以留下。这个 $k$ 就是我们二分的内容了。

为了二分的顺序问题，我们可以开一个结构体进行质量和编号的储存。进行完排序之后，就是二分检查函数的编写。

我们可以对一个待验证的 $k$ 进行一次 $O(n)$ 遍历，每次分类成三种，一种遇到他自己不操作，一种碰到比他小的就吃掉，碰到比他大的就代表着这个 $k$ 不合法。

最后只需要把得出的 $k$ 和他往后的点的标号开个数组打上标记，最后把标记的点输出对或错就可以了。

最后记得看数据范围别爆，总复杂度和排序一样。

```
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
struct node{
    int num,val;
    friend bool operator<(node x,node y){
        return x.val<y.val;
    }
}a[1000001];
int n;
int ans[1000001];
bool check(int x){
    int sum=a[x].val;
    for(int i=1;i<=n;++i){
        if(i==x)continue;
        if(sum>a[i].val)sum+=a[i].val;
        else return 0;
    }
	return 1;
}
signed main(){
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i].val;
        a[i].num=i;
    }

    sort(a+1,a+n+1);
    int l=1,r=n+1;
    int loc;
    while(l<=r){
        int mid=l+r>>1;
        if(check(mid))loc=mid,r=mid-1;
        else l=mid+1;
    }
    for(int i=loc;i<=n;++i){
        ans[a[i].num]=1;
    }
    for(int i=1;i<=n;++i){
        if(ans[i])cout<<"T";
        else cout<<"N";
    }
    return 0;
}
```






---

## 作者：Wf_yjqd (赞：1)

好像没有一样思路的，所以来发篇题解。

较大的鱼才能吃较小的鱼，所以先从大到小排个序。

考虑相同大小的鱼结果一定一样，所以只算其中任意一个，再统一赋答案。

首先，一条鱼一定能吃掉所有比他小的鱼，所以求一个后缀和。

如果有比它小的鱼，那吃完后它的体积一定变大，就能吃掉原来和它一样大的鱼。

此时如果它比它接下来一只鱼要大了，就说明它能继续往下吃，也就是有机会成为最后剩下的一只鱼。

注意此时不要一直向后比较，不然就成 $O(n^2)$ 的了。

发现如何此时后一只鱼没有机会再往下吃，说明它的前/后缀和一定小于等于再往下一只鱼，那这只鱼一定也没有机会了。

所以每条鱼只考虑之前的能不能吃完，如果后面的不行，就不统计它了。

最后从大到小连续可往后吃的鱼就是可行的。

整体复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll maxn=5e5+84;
struct kayh{
    ll a,id,ans;
}f[maxn];
bool cmp1(kayh x,kayh y){
    return x.a>y.a;
}
bool cmp2(kayh x,kayh y){
    return x.id<y.id;
}
ll n,j,hzh;
int main(){
    scanf("%lld",&n);
    for(ll i=1;i<=n;i++){
        scanf("%lld",&f[i].a);
        f[i].id=i;
    }
    sort(f+1,f+n+1,cmp1);
    for(ll i=n;i>=1;i--){
        j=i;
        while(f[i].a==f[i-1].a)
            i--;
        if(hzh!=0&&hzh+f[i].a*(j-i+1)>f[i-1].a)
            f[i].ans=1;
        hzh+=f[i].a*(j-i+1);
        for(int k=i+1;k<=j;k++)
            f[k].ans=f[i].ans;
    }
    f[0].ans=1;
    for(int i=1;i<=n;i++)
        f[i].ans=min(f[i].ans,f[i-1].ans);
    sort(f+1,f+n+1,cmp2);
    for(int i=1;i<=n;i++)
        putchar(f[i].ans?'T':'N');
    return 0;
}
```


---

## 作者：ydzr00000 (赞：1)

题面很简洁，这里不做多说。

## Part 1

可以想到暴力枚举每一条鱼，是否能吃掉所有的鱼。

假设现在枚举第 $i$ 条鱼能否成为最后一条鱼，接下来应该一次一次地枚举鱼 $i$ 能否吃掉哪些鱼，直到第 $i$ 条鱼无法再吃掉其它的鱼或者只剩它一条鱼。

如果特别构造一些数据，使得每一次枚举只能枚举出一条鱼，那么时间复杂度将会达到 $\mathcal{O}(n^3)$。

## Part 2

我们需要避免每一次枚举只枚举一条鱼的状况，不难看出，先吃掉能吃的鱼显然不劣，于是可以将鱼按照其质量 $a_i$ 升序排序。

接下来进行枚举，枚举每一条鱼 $i$ 时，只需要按照顺序依次每一条鱼能否被鱼 $i$ 吃掉，最后判断吃掉的鱼的数量是否达到 $n-1$ 即可。

如果构造数据使得许多的鱼都能吃掉其它所有鱼，那么时间复杂度将会达到 $\mathcal{O}(n^2)$。

## Part 3

可以证明，如果一条鱼 $i$ 的质量 $a_i$ 小于另一条鱼 $j$ 的质量 $a_j$，且鱼 $i$ 可以成为最后一条鱼，那么鱼 $j$ 一定可以成为最后一条鱼。

用一个（可能）易于理解的方式说明：因为鱼 $j$ 的初始质量就比鱼 $i$ 大，原本能吃的鱼的数量就不会比鱼 $i$ 更少，所以若鱼 $i$ 可以成为最后一条鱼，鱼 $j$ 就一定能成为最后一条鱼。

知道了这个结论，我们就可以确定：将鱼按照质量升序排序后，有一个分界点 $k$，使得前 $k$ 条鱼无法成为最后一条鱼，后 $n-k$ 条鱼一定可以成为最后一条鱼。

于是只需要排序后二分分界点 $k$ 即可，时间复杂度为 $\mathcal{O}(n\log n)$。

核心代码（个人码风，不喜勿喷）

```c++
inline bool check(int mid)	//检查当前二分的鱼能否成为最后一条鱼。
{
	long long sum=a[mid].val;
	int num=0;
	for(int i=1;i<mid;i++)
		if(sum>a[i].val)
		{
			sum=sum+a[i].val;
			num++;
		}
	for(int i=mid+1;i<=n;i++)
		if(sum>a[i].val)
		{
			sum=sum+a[i].val;
			num++;
		}
	return num==n-1;
}
```

---

## 作者：zhuweiqi (赞：1)

首先，我们将 $a$ 数组从小到大排个序，然后我们考虑第 $i$ 条鱼是否可以吃掉其它所有的鱼，如果第 $i$ 条鱼是质量最小的鱼之一（即 $a_i=a_1$)，那么它肯定不能吃掉任何一条鱼，**但是如果本来就只有一条鱼，那么它还是满足条件的**，否则它是肯定不满足条件的，如果所有的鱼的质量都一样（$n=1$ 时除外），那么它们肯定都不满足条件，接着我们再来看，如果第 $i$ 条鱼不是质量最小的鱼之一，那么它就必定能吃掉所有质量不大于它本身的鱼，然后它的质量就变成了：$\sum_{j=1}^i a_j$，如果在它吃掉了所有它能吃掉的鱼之后，还剩下不止一条鱼，那么它就不满足条件，设这条最小的它不能吃掉的鱼是第 $l$ 条鱼，则所有编号 $< l$ 的鱼就都不满足条件，我们只需要找出这个最大的 $l$，就可以知道哪些鱼满足条件，哪些鱼不满足条件了，最后再将 $a$ 数组根据输入的顺序排个序再输出就可以了。另外，在找 $\sum_{j=1}^i a_j$ 的过程中，我们需要用到前缀和来优化程序，上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
struct stu{
	int a,idx;
	int ans=0;
}s[500005];
bool cmp1(stu x,stu y){return x.a<y.a;}
long long f[500005];
bool cmp2(stu x,stu y){return x.idx<y.idx;}
int main(){
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&s[i].a);
		s[i].idx=i;
	}
	if(n==1){
		printf("%c",'T');
		return 0;
	}
	sort(s+1,s+1+n,cmp1);
	for(int i=1;i<=n;i++) f[i]=f[i-1]+s[i].a;
	int l=0;
	for(int i=2;i<=n;i++){
		if(s[i].a!=s[1].a){
			l=i;
			break;
		}
	} 
	if(l==0){
		for(int i=1;i<=n;i++) printf("%c",'N');
		return 0;
	}
	s[n].ans=1;
	for(int i=n-1;i>=l;i--){
		if(f[i]>s[i+1].a) s[i].ans=1;
		else break;
	}
	sort(s+1,s+1+n,cmp2);
	for(int i=1;i<=n;i++){
		if(s[i].ans==1) printf("%c",'T');
		else printf("%c",'N');
	}
	return 0;
}
```

---

## 作者：WaterSky (赞：0)

~~终于做对了。~~

# Part 1： 简要题目。
有 $N$ 个数，对于每一个数 $a_i$，有以下操作：

* 去除一个相对较小的数，并获得这个数。

判断每一个数是否能活到最后，用字符表示。

数据大小： 对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$1 \leq a_i \leq 10^9$。

# Part 2： 思路。
我使用的方法是： **二分**。

既然方法使用的是二分，则必须要找到需要二分的是什么。我建议二分： 在 $N$ 个数中，最小的能够存活到最后的数。因为如果比这个数大，那么肯定能够存活到最后，反之，比它小的，肯定不能。

除了找到需要二分的是什么，还要想怎么判断。这部分比较简单，从小到大排序，从最小的看，能吃的就吃，如果比这个数大，那么后面都比不了，直接退出。

# Code 注释版：
```
#include<bits/stdc++.h> //万能头文件
using namespace std;
long long n,a[50000005],b[50000005]; //定义
map<long long,long long>c;//用map把时间置换成空间（应该是的）。
bool pd(long long m) //判断程序。
{
	long long x=a[m];
    for(int i=1;i<=n;i++) //判断程序核心。
    {
        if(i==m) continue; //如果等于自己，就不用继续找。 
        if(a[i]<x) x+=a[i];//如果小于自己，吞噬掉。
        else return false;//否则直接退出，并且返回false。
    }
    return true;//如果生存到最后，那么返回true并退出。
}
int main(){
    ios::sync_with_stdio(false);//不一定要用，但是用了可以把cin和cout的时间加速。
 	cin>>n;//输入 N。
 	for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i]; //输入ai，并且用B数组记录原来的顺序（不想用结构体，太麻烦）。
 	sort(a+1,a+1+n);//从小到大排序。
 	long long mid,start=0,finish=n+1;//定义左边界，右边界以及中间值。
 	while(start+1<finish) //二分重要核心模版。
 	{
	 	mid=(start+finish)/2;
		if(pd(mid)) finish=mid;//如果可以，继续往小的找。
		else start=mid;//否则往大的找。
	}
	for(int i=1;i<=n;i++) c[a[i]]=(i<finish);//如果在a数组中的顺序小于最小的可以生存到最后的数，就返回ture,也就是1，否则返回0。
    for(int i=1;i<=n;i++)
        if(c[b[i]]==1) cout<<'N';//如果等于1，也就是ture，说明不可以生存到最后，输出字符 'N'。
        else cout<<'T';//否则输出字符 'T'。
    return 0;//最后程序结束
}
```

# Code 纯净版
```
#include<bits/stdc++.h>
using namespace std;
long long n,a[50000005],b[50000005];
map<long long,long long>c;
bool pd(long long m)
{
	long long x=a[m];
    for(int i=1;i<=n;i++)
    {
        if(i==m) continue;
        if(a[i]<x) x+=a[i];
        else return false;
    }
    return true;
}
int main(){
    ios::sync_with_stdio(false);
 	cin>>n;
 	for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i];
 	sort(a+1,a+1+n);
 	long long mid,start=0,finish=n+1;
 	while(start+1<finish)
 	{
	 	mid=(start+finish)/2;
		if(pd(mid)) finish=mid;
		else start=mid;
	}
	for(int i=1;i<=n;i++) c[a[i]]=(i<finish);
    for(int i=1;i<=n;i++)
        if(c[b[i]]==1) cout<<'N';
        else cout<<'T';
    return 0;
}
```

致管理员： 希望如果有问题，一次性说完，好让我及时改正。

致观看题解的你： 由于作者比较弱，所以打不出好的程序，时间都差点超，所以不喜欢或者有不好的地方，请在评论区说出你的看法。还有，一定一定要开O2，不然会超时。

---

## 作者：chlchl (赞：0)

一道质量还可以的小清新，有点细节，但不多。

## Solution
显然我们有一个结论：对于每一条鱼，所有 $a_i$ 比它小的都可以被它吃掉。

从小到大排序后，这其实就是 $i$ 之前的数的前缀和（吃掉了一条鱼就加上它的 $a_i$）。我们记 $s_i=\sum\limits_{j=1}^i a_i$。

其实每次判断，就是从前往后，看看 $s_{i-1}$ 是否小于 $a_i$，即吃掉了前面所有能吃的鱼之后能不能吃得下剩下的鱼中 $a_i$ 最小的。如果不能吃掉，那么其他鱼自然也不能吃掉了，就是 `N`。

所以我们得到了一个 $O(n^2)$ 的算法，但这显然超时。

考虑到每次判断时都是使一个后缀合法。换言之，我们如果能够找到最长合法后缀的开头位置 $r$，那么 $[1,r)$ 的数将全部是 `N`，$[r,n]$ 的数将全部是 `T`。

这个显然。因为如果在 $r$ 之前仍然有符合条件的位置 $r'$，那么我们找到的这个 $r$ 应当在 $r'$ 的位置而不是现在的位置（因为如果 $r'$ 符合条件，必须要使 $[r',n]$ 都符合条件，而 $[r,n]\in[r',n]$）。

可以发现这是一个有单调性的东西，可以用二分加速，时间复杂度 $O(n\log n)$，足以通过本题。

最后有两个细节（本质上是一个）：
- 如果有多条鱼 $a_i$ 相同，这些鱼相互是不能吃的，计算前缀和的时候要特别注意这种情况（详见代码）；
- 解决了上面的情况后，**全部 $a_i$ 相等**的情况仍需要特判（输出应为 $n$ 个 `N`）。这个自己注意一下。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 5e5 + 10;
int n;
ll s[N];
char ans[N];
struct point{
	ll x;
	int idx;
	bool operator < (const point &p) const {
		return x < p.x;
	}
} a[N];

bool check(int mid){
	if(!s[n])
		return 0;//全部相等的情况下s[n]是0，也只有这种情况会是0 
	for(int i=mid+1;i<=n;i++)//这个地方判不到 n 是否合法，虽然它在除了全部相等的情况下都合法
		if(s[i - 1] + a[i - 1].x <= a[i].x)
			return 0;
	return 1;
}

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%lld", &a[i].x), a[i].idx = i;
	sort(a + 1, a + 1 + n);
	int cnt = 1;
	for(int i=1;i<=n;i++){
		if(a[i].x > a[i - 1].x)
			s[i] = s[i - cnt] + a[i - 1].x * cnt, cnt = 1;//出现了大于前面的数，你得把前面没计算上的鱼全部吃掉，不能只加一条，所以乘个 cnt
		else
			s[i] = s[i - 1], ++cnt;//相等
	}
	int l = 1, r = n;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(check(mid))
			r = mid - 1;
		else
			l = mid + 1;
	}
	for(int i=1;i<=r;i++)
		ans[a[i].idx] = 'N';
	for(int i=r+1;i<=n;i++)
		ans[a[i].idx] = 'T';
	printf("%s", ans + 1);//输出下标可以从 1 开始
	return 0;
}
```



---

## 作者：Aakkosetsumussa (赞：0)

蒟蒻斗胆来写一篇题解……
## 题意简述
题目里面说的很清晰了，就不赘述了。
## 题目分析
首先肯定想到暴力枚举，但是 $1 \leq n \leq 5 \times 10^5 $ 的数据  $O(n^2)$ 的时间复杂度肯定接受不了。

所以就要思考一下：若一条鱼能活到最后，那么所有比这条鱼重的鱼肯定也能被留到最后；若一条鱼活不到最后，那么所有比这条鱼轻的鱼也活不到最后。这样单调性就很明显了，可以二分，时间复杂度 $n \log n$。

思路很明了了，先排序，然后二分，用一个  ```check()```  函数去从小到大并上那些比自己小的鱼，若在此过程中有比自己大的鱼就直接判定留不到最后，然后退出。

为什么可以这么做？因为排序后的单调性可以保证若吃掉所有比自己能吃的鱼还不能吃掉更大的鱼，就没有别的鱼可吃了，所以它一定不能逃过被吃掉的命运，也就是没法留到最后；如果能按从小到大的顺序吃掉所有鱼，他就可以留到最后。

## 代码

就上代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long inr;
#define fr(y) for(inr i=1;i<=y;i++)
#define fy(y) for(inr j=1;j<=y;j++)
struct node {
	inr a,id;
} f[500007];
inr n,l,r,mid;
char ans[500007];
inline bool cmp(node a,node b) {
	return a.a<b.a;
}
inline bool check(int x) {
	inr r=f[x].a;
	for(int i=1; i<=n; i++) {
		if(i==x) continue;//不理自己 
		else if(r>f[i].a) r+=f[i].a;//吃掉小的 
		else return false;//遇到大的，由于单调性，肯定吃不掉，只能被吃 
	}
	return true;
}
int main() {
	ios::sync_with_stdio(false);//加速 
	cin>>n;
	fr(n) cin>>f[i].a,f[i].id=i;
	sort(f+1,f+n+1,cmp);
	inr l=1,r=n+1;
	while(l<r) {//二分 
		mid=(l+r)>>1;
		if(check(mid)) r=mid;//判定 
		else l=mid+1;
	}
	for(int i=1; i<=r; i++) ans[f[i].id]='N';//1~r都不可以 
	for(int i=l; i<=n; i++) ans[f[i].id]='T';//l~n都可以 
	fr(n) cout<<ans[i];
	return 0;
}
```

---


# [THUPC 2023 初赛] 众数

## 题目描述

你有若干个 $[1,n]$ 内的正整数：对于 $1 \le i \le n$，你有 $a_i$ 个整数 $i$。设 $S = \sum_{i=1}^n a_i$。

对于一个序列 $p_1,p_2,\cdots,p_l$，定义其众数 $\text{maj}(p_1,p_2,\cdots,p_l)$ 为出现次数最多的数。若有多个数出现次数最多，则其中最大的数为其众数。

现在你需要把这 $S$ 个数排成一个序列 $b_1,b_2,\cdots,b_S$，使得 $\sum_{i=1}^S \text{maj}(b_1,b_2,\cdots,b_i)$ 最大。输出该最大值。

## 说明/提示

#### 样例解释 1

一个达到最大值的序列为 $(3,2,3,1,2,2)$。

#### 数据范围

对于所有测试数据，$1 \le n \leq 10^5$，$1 \le a_1,a_2,\cdots,a_n \le 10^5$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
3
1 3 2```

### 输出

```
17```

# 题解

## 作者：Alex_Wei (赞：24)

> [P9143 [THUPC 2023 初赛] 众数](https://www.luogu.com.cn/problem/P9143)

考虑最终序列的形式。一个自然的想法是不断从 $n$ 摆到 $1$，如果没有这个数就跳过。

正确性证明：考虑众数序列 $m_1\sim m_S$，根据众数定义，其中只能有不超过 $\sum_{i = 1} ^ n\min(a_i, a_n)$ 个 $n$，只能有不超过 $\sum_{i = 1} ^ n \min(a_i, \max(a_{n - 1}, a_n))$ 个 $n - 1$ 或 $n$。以此类推，只能有不超过 $\sum_{i = 1} ^ n \min(a_i, \max_{j = p} ^ n a_j)$ 个不小于 $p$ 的数。而不断从 $n$ 摆到 $1$ 的序列恰好达到了所有上界。$\square$

接下来考虑贡献。考虑一个数 $i$ 被第 $j$ 次放入序列，那么它对应的众数为最大的 $p$ 使得 $a_p \geq j$。因此，设 $f_j$ 表示最大的 $p$ 使得 $a_p \geq j$，则 $a_i$ 的贡献为 $\sum_{j = 1} ^ {a_i} f_j$。前缀和即可。

时间复杂度 $\mathcal{O}(n + a)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e5 + 5;
long long n, ans, a[N], f[N];
int main() {
  cin >> n;
  for(int i = 1; i <= n; i++) cin >> a[i];
  for(int i = n, mx = 0; i; i--) {
    while(mx < a[i]) mx++, f[mx] = f[mx - 1] + i;
    ans += f[a[i]];
  }
  cout << ans << "\n";
  return 0;
}
```

---

## 作者：TernaryTree (赞：12)

## Part $0$ 题意理解

给定序列 $a$，求一个序列 $b$，满足 $1\sim n$ 各在 $b$ 中出现 $a_i$ 次，使得 $b$ 每个前缀的众数之和取得最大值，若有多个众数取最大的。

---

**若无特殊说明，以下 $T \subset S$ 为 $S$ 集合包含 $T$，即 $T$ 是 $S$ 的子集，不保证 $S\neq T$。**

## Part $1$ 思想转换

手玩一下可以发现一个显然的贪心策略：**从后往前扫，如果当前这个位置还能加就加上**。以样例为例：

$$
\begin{aligned}
&\{1,3,2\}:\{\}\\
&\{0,2,1\}:\{3,2,1\}\\
&\{0,1,0\}:\{3,2,1,3,2\}\\
&\{0,0,0\}:\{3,2,1,3,2,2\}\\
\end{aligned}
$$

每一次操作都会增加一段严格递减的连续段。我们考虑这一段的贡献，我们把这一段所有元素记为 $T$；前面所有数中，出现次数最多的，我们记为 $S$；则有 $T\subset S$。浅证一下：上一次没有的，这一次也没有；上一次有的，这一次有可能有也有可能没有。所以，**每次取到的数都是上一次的子集**。形象地画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/79mdzhh9.png)

从左到右每块表示当前取到数的集合，由于每两个都是包含关系，大小单调不增，所以**以这一段任意位置为结尾的前缀的众数 $\in$ 这一段的数**。又因为我们众数取最大值，所以这一整段的众数就是这一段第一个取到的数。仍以样例为例子：

$$3,2,1;\ 3,2;\ 2$$

可以看到，$b$ 被分成了三段。第一段有 $3$ 个，开头为 $3$；第二段有 $2$ 个，开头为 $3$；最后一段有 $1$ 个，开头为 $2$。所以总和为 $3\times 3+2\times 3+1\times2=17$。

## Part $2$ 算法优化

接下来我们有了一个明确的思路：对于每一个 $1\le i\le n$，计算以 $i$ 为开头的所有段的长度总和。

### 算法 $1$

从后往前枚举，对于当前点 $i$，其贡献为 $\sum\limits_{j=1}^i \min(a_j,a_i)$。可以这样理解：因为当前点要取完，所以前面的每个点最多被取到 $a_i$ 次，于是每个点贡献为 $\min(a_j,a_i)$，求和即可。当然，每次统计后要更新 $a$ 序列，对于 $1\le j\le i$ 将 $a_j\gets \max(a_j-a_i,0)$。这个东西可能可以线段树实现但是我不会线段树，所以赛时放弃了。

### 算法 $2$

队友 $\textrm{i\red{rris}}$ 给出了另外一种方案令我豁然开朗：排序。

将 $a_i$ 排序，并记录原来在 $i$ 位置的排序后在 $b_i$，排序后 $i$ 点表示的原数是 $c_i$，$b_i,c_i$ 是互逆的排列。排序后，对于每个点，计算其贡献。显然的，对于前面的点，总和为这一段的和；对于后面的点，每个点数值都大于等于自己，根据算法 $1$ 取 $\min$，所以贡献为 $(n-b_i)a_ic_i$。

那么怎么处理减的问题呢，对于当前点，前面的点显然都会变成 $0$，这个我们打个标记，记录当前最远的变成 $0$ 的数，因为所有 $0$ 构成了排序后 $a$ 的前缀，如果当前遍历到为 $0$ 的数直接跳过；对于后面的，我们记录当前偏移量 $f$（即没被减完的数比较原来的数减去的数量），然后在算结果的时候减一下就可以。$f$ 每次对 $a_i$ 取最大值。

后半部分的复杂度应该是 $\Theta(n)$ 的，算上排序是 $\Theta(n\log n)$。当然，题面保证了 $a_i$ 的范围，所以我们可以使用桶排序将其优化至严格线性。~~因为不想实现就没实现~~。

## Part $3$ 代码展示

非常简短的代码，甚至不到 $800$ B。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e5 + 10;

int n;
pair<int, int> a[maxn];
int b[maxn];
int s[maxn];
int ans, f, last = 1;

int sum(int l, int r) {
    return s[r] - s[l - 1] - (r - l + 1) * f;
}

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].first;
        a[i].second = i;
    }
    sort(a + 1, a + 1 + n);
    for (int i = 1; i <= n; i++) b[a[i].second] = i, s[i] = s[i - 1] + a[i].first;
    for (int i = n; i; i--) {
        int p = b[i];
        if (p < last) continue;
        ans += sum(last, p) * a[p].second + (n - p) * (a[p].first - f) * a[p].second;
        f = max(f, a[p].first);
        last = p + 1;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：Red0rangE (赞：6)

## 题意理解

给一个正整数 $n$ ，再给出 $n$ 个数 $a_1,a_2,\cdots,a_n$
 表示有 $a_i$ 个整数 $i$ ，请你用这些数字构造一个数列，使每个子数列的众数最大。若有多个数出现次数最多，则其中最大的数为其众数。这里的子数列就是从左向右数的，第一个子数列是前一个数，第二个是前两个数，以此类推。
 
## 方法阐述
 
可以研究一下样例解释看出最优解法，模拟一下也比较好理解，简单讲就是从大到小把每个能拿的数都拿一遍，具体证明解释可以看 @TernaryTree 大佬的题解（我不会证）。

示例，左侧代表每个数字的个数，右侧代表生成的数列：
$$(1,3,2,3):()$$
$$(0,2,1,2):(4,3,2,1)$$
$$(0,1,0,1):(4,3,2,1,4,3,2)$$
$$(0,0,0,0):(4,3,2,1,4,3,2,4,2)$$

## 代码

首先是最直接的模拟，蒟蒻非常自信的。
```cpp
#include <bits/stdc++.h>
using namespace std;

long long n;
long long a[100005];
long long ans;//记录答案

signed main(){
    
    scanf("%lld",&n);
    for (int i=1;i<=n;i++)
        scanf("%lld",&a[i]);//输入
    while (1){
        bool f=1;//判断还有没有数字可以取用
        long long k=0,s=0;//众数以及众数个数
        for (int i=n;i>=1;i--){
            if (a[i]>0 && f){
                k=i;//这是最大的，本轮s个众数都是它
                s++;
                f=0;//还有数字
            }
            else if (a[i]>0)
                s++;//这个可以用
            a[i]--;//每个数字都用一遍
        }
        ans+=s*k;//答案加
        if (f) break;//没有数字了，结束
    }
    printf("%lld",ans);
    return 0;
    
}

```
两层循环复杂度高达 $10^{10}$ ，显然超时。思索后发现这里可以用前缀和优化。

示例：
$$(1,4,2,3):()$$
$$ans+0$$
$$(1,4,2,0):(4,4,4)$$
$$ans+(3 \times 4)$$
$$(1,4,0,0):(4,3,4,3,4)$$
$$ans+(2 \times 4)$$
$$(1,0,0,0):(4,3,2,4,3,2,4,2,2)$$
$$ans+(3 \times 4+1 \times2)$$
$$(0,0,0,0):(4,3,2,1,4,3,2,4,2,2)$$
$$ans+(1 \times 4)$$
从大到小加入数字，每加入一个则将 $u$ 加一，如果 $u \geqslant a_{i}$ ，有比 $i$ 大的众数，数字 $i$ 不加入众数计算，$u$ 不变，众数不加，否则更新 $u$ 并更新答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n,ans;
long long a[100005];
long long k[100005];

signed main(){

    scanf("%lld",&n);
    for(long long i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for(long long i=n,u=1;i>0;i--){
        for (u;u<=a[i];u++)//a[i]>u时，i为众数
            k[u]=k[u-1]+i;//新加入u个数时，k[u]为这部分的答案
        ans+=k[a[i]];//答案更新
    }
    printf("%lld",ans);
    return 0;
    
}

```
希望各位大佬多多指教。

---

## 作者：ztntonny (赞：1)

## 思路

考虑让越大的数当众数的次数越多，则显然最大的数都在前几个，如样例中：

```
3 3 * * * *
```

为了让这个最大的 $3$ 当众数次数最多，显然别的数出现次数不能大于它：

```
3 3 2 2 1 1
```

但是因为 $1$ 只有一个，所以应该为：

```
3 3 2 2 1 *
```

那么后面考虑第二大的 $2$，同理可推得数列样貌：

```
3 3 2 2 1 2
```

## 优化

显然直接硬模拟会得到万绿丛中一点红，考虑线性优化。

不难发现，所有能成为众数的数必然是呈单调队列状，考虑按照每一个众数取值进行分块，如在样例中：

```
| 3 3 2 2 1 | 2 |
```

分为多个块考虑。

每一个数能成为众数的次数就是每一个块的大小，其中由两部分组成：

1. 还剩下的数量大于等于众数还剩下的数量的
2. 还剩下的数量小于众数还剩下的数量的

设该数字目前剩下数量为 $a_i$，则这个数的贡献为：

$$i\times(\sum_{j=i}^{n}a_i(a_i\leq a_j)+\sum_{j=i}^{n}a_j(a_i>a_j))$$

大于 $a_i$ 的很好统计，因为本来大于它的就应该都在它的后面；而小于它且还剩下的，就是一个区间前缀和的成果。这两个都符合单调队列的性质。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n , a[100005] , ans , lev , buck[100005] , f[100005] , bef , bk[100005];
int main()
{
	cin >> n;
	for ( int i = 1; i <= n; i++ )	cin >> a[i] , buck[a[i]]++;
	for ( int i = 1; i < 100005; i++ )	f[i] = f[i - 1] + buck[i] * i;//前缀和
	for ( int i = 100003; i >= 0; i-- )	bk[i] = buck[i] + bk[i + 1];//大于i且在其后的数量
	for ( int i = 1; i < 100005; i++ )	buck[i] += buck[i - 1];//桶子
	for ( int i = n; i >= 1; i-- )
	{
		if ( a[i] <= bef )	continue;buck[a[i] - 1] - buck[bef] ) * bef <<endl;
		ans += ( bk[a[i]] * ( a[i] - bef ) + f[a[i] - 1] - f[bef] - ( buck[a[i] - 1] - buck[bef] ) * bef ) * i;
		bef = a[i];
	}
	cout << ans << endl;
	return 0;
}
```


---

## 作者：uid_310801 (赞：1)

观察样例，不难想到贪心策略，先放最大的，最大的放完后放更小的，但是单个数字的放置个数不能超过最大的数字的个数。等到所有数都放完后放次大的，以此类推。

我们考虑先将数按个数从小到大排好序，记排序后数组为 $a$，记录下每个数的新位置。从 $n$ 到 $1$ 依次考虑。现在设枚举的数为 $i$，位置为 $b_i$，初始时 $i$ 的个数为 $a_{b_l}$，上次取数的位置时 $l$，记 $b$ 的前缀和数组为 $s$，所有数中被拿走的个数最大为 $sum$。如果 $b_i<l$，说明 $i$ 已经被拿完了，跳过。否则在它后面的要拿去 $(a_{b_i}-sum)$，前面的，也就是 $s+1$ 到 $b_i$ 位置上的数要拿光。这期间，每一次放数的时候，整个集合的众数都是 $i$。所以答案加上 

$$[(s_{b_i-1}-s_l)-sum\times(b_i-1-l)+(n-b_i+1)\times (a_{b_i}-sum)]\times i$$

执行完毕后，$l<\!\!\!-\space b_i,sum<\!\!\!-\space a_i$.

(事实上 $sum=a_{b_l}$)。

正常做复杂度瓶颈在排序，但是值域很小，可以用桶排（~~不过我没写~~）。

```cpp
#include<bits/stdc++.h>
using namespace std;
//#define int long long
typedef long long ll;
const ll N=1e5+10;
ll n,b[N],s[N]; 
ll ans;
struct node{
	ll p,v;
}a[N];
bool cmp(const node &a1,const node &a2){
	if(a1.v==a2.v)	return a1.p<a2.p;
	return a1.v<a2.v;
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&b[i]);
		a[i].p=i;
		a[i].v=b[i];
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		b[a[i].p]=i;
		s[i]=s[i-1];
		s[i]+=a[i].v;
	}
	ll maxs=0,sum=0;
	for(int i=n;i>=1;i--){
		ll pl=b[i];
		if(pl<maxs)	continue;
		ll val=a[pl].v-sum;
		ans+=(val*(n-pl+1)+(s[pl-1]-s[maxs]-sum*(pl-1-maxs)))*i;
		sum=a[pl].v;
		maxs=pl;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：TonviaSzt (赞：1)

## [可能更好的](https://www.luogu.com.cn/blog/Tonvia/solution-p9143)[阅读体验](https://blog.csdn.net/Tonvia/article/details/129383697?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22129383697%22%2C%22source%22%3A%22Tonvia%22%7D)

~~今年 THUPC 服务器终于不卡了！~~

---
### 题解

一句话题意：对于一个规定元素种类及个数的序列 $A$，要求构造一个序列，使 $\sum\limits_{i=1}^{n}$（前 $i$ 个数众数）最大，输出最大值。规定众数为一段序列中出现次数最多且最大的数。

要使结果最大，就要求每段序列的众数尽量大。设一段序列由不重复的元素组成，容易发现当序列为降序排列时众数和最大，为**序列最大值** $\times$ **序列长度**。

于是问题转为当序列含有重复元素时，如何解决众数和最大。

设该序列最大值为 $k$，此时如果要新增一个数 $q$，我们分情况讨论：
- $k<q$，将其放在序列中间的贡献值会小于放在末尾的贡献值，应该将其放至末尾。
- $k>q$，那序列仍由不重复的元素组成，放在序列开头。
- $k=q$，为了使众数和最大，将相同元素均匀分布。

那么最优的序列就应该由多个降序的序列构成。

---
数据规模大，无法构造。但可以发现，因为答案为**序列最大值** $\times$ **序列长度**，因此只需要知道最大值和最大长度即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5+5;
int n,bz[N];
LL mx,t,ans;
struct qh{
    int a,b;
    bool operator < (const qh &T){return b!=T.b?b<T.b:a>T.a;}
}E[N];
int main(){
	scanf("%d",&n);
    for(int i=1,x;i<=n;i++) scanf("%d",&x),E[i]=(qh){i,x},t+=(E[i].b!=0);
    mx=n;
    while (!E[mx].b) mx--;
    sort(E+1,E+n+1);
    int i=1;
    while (!E[i].b) i++;
    for(;i<=n;i++){
        LL nw=i;
        while (E[nw+1].b==E[i].b) nw++;
        ans+=t*(E[i].b-E[i-1].b)*mx;
        for(int j=i;j<=nw;j++) bz[E[j].a]=1;
        while (bz[mx]) mx--;
        t-=(nw-i+1);
        i=nw;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Double_Light (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9143)

如果我们要使 $\sum{\textrm{maj}(b_1,b_2,...b_n)}$ 最大，显然要使得对于每一个 $1\le m\le n$，$\textrm{maj}(b_1,b_2,...b_m)$ 最大。

我们将输入的 $a$ 序列从大到小排序，使得大的数尽可能在前。

可以想到，数组排序后，对于两个数 $i,j$，如果 $i\le j$，交换 $a_i,a_j$，最终的结果是 $\le a_i$ 的 $a_j$ 到了 $a_i$ 的位置上，显然不可能变大；而如果 $i>j$，最终的结果是 $\le a_j$ 的 $a_i$ 到了 $a_j$ 的位置上，显然同样不可能变大。所以一定可以得到最大的 $\sum{\textrm{maj}(b_1,b_2,...b_n)}$。

所以，我们得到了最终的代码：

```cpp
#include<iostream>
using namespace std;
long long n,ans,a[100005],s[100005],p;//开long long
int main() {
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=n;i>=0;i--){
        while(p<a[i]){//p类似于一个指针
            p++;
            s[p]=s[p-1]+i;
        }
        ans+=s[a[i]];
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：hereiszd (赞：0)

## 一.题意简述

现在有若干个数，值域为 $[1,n]$ ，其中大小为 $i$ 的数有 $a_i$ 个，现在重排这个序列使得前缀众数之和最大。

众数在这个题定义为：数列中出现最多的数，如果有出现次数一样的以最大的为众数。

## 二.题目分析

考虑贪心。

我们肯定要让大的数出现的次数尽可能多，而这么做一定是尽量的让大的数**成为众数**的次数尽可能多。

我们很容易想到这样一种方案：
1. 以最大数的开头依次递减排列。
2. 如果一个数被用完了就跳过这个数。

比如样例我们就可以排列为 $(3,2,1,3,2,2)$ ，众数分别为 $(3,3,3,3,3,2)$

证明的话很简单，随机交换这个数列中的某一项都会使得总和变小。

接下来问题就变成了怎么计算出题目要求的前缀众数和。

以 $i$ 为例，我们设第 $j$ 个数出现的次数为 $s_j  (j \le n)$，我们需要找到以 $i$ 为众数的数列的长度，而这个数列一定是由比 $i$ 小的数组成，（比 $i$ 大的数我们已经在前一次用完）更进一步，其由两部分组成：

1. 出现次数比 $i$ 多的数贡献出 $s_i$ 的长度，自身还剩下 $s_j-s_i$ 个。
2. 出现次数比 $i$ 少的数贡献出 $s_j$ 的长度，自身被用完。

我们考虑分开计数，最后再加起来（详细见代码）。

注意我们需要记录当前用的数最多用了几次，如果有次数比这个小的应该舍去。

## 三.代码时间

```cpp
/*
	Author:zd
	Status:WA on pretest 2
	note: 只保留了主函数部分
*/
int n,m,k,cnt,a[N],b[N],sum[N];
signed main(){
    read(n);
    for(int i=1;i<=n;i++)read(a[i]),b[i]=a[i];
    sort(b+1,b+1+n);
    int ans=0;
    for(int i=1;i<=n;i++)sum[i]=sum[i-1]+b[i];
    for(int i=n;i>=1;i--){
        int num=a[i];
        if(cnt>=num)continue;//如果已经被用完
        int pos=lower_bound(b+1,b+1+n,num)-b;//找到比i出现次数大的数的位置
        int pos2=upper_bound(b+1,b+1+n,cnt)-b;//比当前次数小的数的位置
        ans+=(sum[pos-1]-sum[pos2-1]-(pos-pos2)*cnt)*i;//比i小的数量
        ans+=((n-pos+1)*(a[i]-cnt))*i;//比i多的数量
        cnt=a[i];//更新使用次数
    }
    writeh(ans);
    return 0;
}
```





---


# 签到题

## 题目背景

著名的【数据删除】是一个热爱旅游的人！这一天他来到了神秘的 ZYL 国度。

入海关的时候他被问到了一个题目，如果答对他就可以顺利到达 ZYL 的首都 ZY 了！身为堂堂【数据删除】，他居然还花了 $10^{-233}$ 秒才想出来做法，实在是有点难的！于是他决定拿来考考你。

## 题目描述

给定长度为 $n$ 的序列 $a$，保证 $a_i$ 是**正整数**。你需要选择一个位置 $i$ 并将 $a_i$ 修改为一个**任意的整数**。最大化最长**严格**上升子串的长度。

所谓严格上升子串，就是从序列中选出位置**连续**的若干个数字，满足后一个数字比前一个大（而不能相等或小于）。

如序列 $[1,4,2,3,5]$ 中，子序列 $[2,3,5]$ 就是严格上升子串，而 $[4,2,3]$（不上升）和 $[1,2,3]$（不连续）则不是。

## 说明/提示

**【样例解释 \#1】**

对于样例 \#1，我们可以将序列 $[1,4,2,2,3]$ 中的第三个位置修改为 $5$，得到新序列 $[1,4,5,2,3]$。这个序列的最长严格上升子串是 $[1,4,5]$，长度为 $3$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $3$。

---

**【样例解释 \#4】**

对于样例 \#4，我们可以将序列 $[8,2,3,1,4,5]$ 中的第三个位置修改为 $0$，得到新序列 $[8,2,0,1,4,5]$。这个序列的最长严格上升子串是 $[0,1,4,5]$，长度为 $4$。

容易证明，不存在一种修改方案使得修改后的序列的最长严格上升子串的长度大于 $4$。

---

**【数据范围】**

对于前 $20\%$ 的数据，满足 $n \le 5$，$a_i \le 5$。  
对于前 $40\%$ 的数据，满足 $n \le 10$，$a_i \le 10$。  
对于前 $70\%$ 的数据，满足 $n \le 300$。  
对于 $100 \%$ 的数据，满足 $1 \le n \le {10}^6$，$1 \le a_i \le {10}^9$。

## 样例 #1

### 输入

```
5
1 4 2 2 3
```

### 输出

```
3
```

## 样例 #2

### 输入

```
5
1 2 3 2 1
```

### 输出

```
4
```

## 样例 #3

### 输入

```
5
1 2 3 1 5
```

### 输出

```
5
```

## 样例 #4

### 输入

```
6
8 2 3 1 4 5
```

### 输出

```
4
```

## 样例 #5

### 输入

```
6
7 2 9 4 5 6
```

### 输出

```
5
```

# 题解

## 作者：syzf2222 (赞：26)

如果修改 $ a_i$，最优的修改方案要么是令 $a_i = a_{i+1}-1$，要么是令 $a_i = a_{i-1}+1$。

那么就可以得到一个简单的 $O(n^2)$ 做法，即枚举修改的位置，并计算答案。

预处理出未进行修改时，每个元素作为连续上升子序列的开头与结尾时的最长长度，记为 $f_i,g_i$。

如果存在 $x$ 满足 $a_{i+1}-1\ge x \ge a_{i-1}+1$，那么可以进行合适的修改使得构造出长度为 $g_{i-1}+1+f_{i+1}$ 的答案。

否则只能得到 $g_{i-1}+1$ 或 $f_{i+1}-1$。扫一遍判断即可。复杂度 $O(n)$。

---

## 作者：EdenSky (赞：14)

# [P9147 签到题](https://www.luogu.com.cn/problem/P9147)
- [或许更好的阅读体验](https://www.cnblogs.com/wanguan/p/17220136.html)

## 正文

**最坏时间复杂度：$\mathcal{O}(n)$**

真不愧是签到题，差点没签上。。。

我相信题意各位肯定很理解了，非常简单，但如何解决就是个问题。

首先考虑朴素解法，建立一个求最长连续子序列的函数 $F$，如果用双指针的话，可以优化到 $\mathcal{O}(n)$；然后是枚举每个 $a_i$，又是一个 $\mathcal{O}(n)$；易发现，每次枚举 $a_i$ 更改，我们不需要一个一个数字枚举，只需要枚举三次就行，$a_i$ 前后的两个数字会构成三个范围，只要分别考虑将 $a_i$ 修改成这三个范围之内的数即可。

总计 $\mathcal{O}(n^2)$。

如何优化呢？

注：以后所提及的单调上升子序列皆为最优。

可以发现，我们并不需要每个枚举。假设一个数处于一个单调上升序列中，把它修改了反而会破坏序列的单调性。因此我们只需枚举每个单调上升子序列首末端，来判断它是否可以和在它前面或后面的单调上升子序列合并组成一个更长的单调上升子序列。

我们预处理 $l_i$，$st_i$，$en_i$，分别代表第 $i$ 个单调上升子序列的长度、开端位置、末端位置。

假设每个单调上升子序列无法相互合并，那最好的方法就是把最长的单调上升子序列首端或末端更改，让这个最长的单调上升子序列的长度再加一。

即把答案设为 $\max l_i+1$.

考虑合并，见下，以后设 $S_i$ 表示原序列第 $i$ 个数。

`1 3 2 6 7`。本例中有 2 个单调上升子序列，我们把第 2 个单调上升子序列的开头修改成 4（或者其它）即可。我们可得知：若 $S_{st_i+1}-S_{en_{(i-1)}}>1$，考虑合并。

当然，不要忘考虑这样的情况：`1 4 3 5 7`，把第 1 个单调上升子序列的末尾修改成 2 即可，即：若 $S_{st_i}-S_{en_{(i-1)}-1}>1$，考虑合并。

大体完毕，但，还有特判！！！若 $S$ 只有一个单调上升子序列，那就输出它的长度，因为它已经是最长了。

```cpp
#include<iostream>
using namespace std;
const int N=1e6+15;
struct P{int l,st,en;}s[N];
int a[N],n,ln,t,mx,cnt,ans;
int main(){
  ios::sync_with_stdio(0),cin.tie(0);
  cin>>n,t=1;
  for(int i=1;i<=n;i++){
    cin>>a[i];
    if(mx<a[i]) ln++,mx=a[i];
    else s[++cnt].st=t,s[cnt].en=i-1,s[cnt].l=ln,
        ln=1,mx=a[i],t=i;
  }
  if(s[cnt].en!=n) s[++cnt].st=t,s[cnt].en=n,s[cnt].l=ln;
  if(cnt==1) cout<<n,exit(0);
  for(int i=1;i<=cnt;i++) ans=max(ans,s[i].l+1);
  for(int i=2;i<=cnt;i++)
    if(a[s[i].st+1]-a[s[i-1].en]>1||a[s[i].st]-a[s[i-1].en-1]>1)
      ans=max(ans,s[i].l+s[i-1].l);
  cout<<ans;
}
```

[完结！！](https://www.luogu.com.cn/record/104742023)

---

## 作者：Iniaugoty (赞：11)

这真的是一道**签到题**，~~因为我赛时只 AC 了这题~~。

## 题意简述

给一个长度为 $n$ 的**正整数**数列，将其中一个数修改为**任意整数**，使得**最长严格上升子串**长度最大，并输出这个长度。

注意点：

- **任意整数**：说明我们可以把它改得很大很大，也可以很小很小。

- **严格上升**：说明子串中一个数字一定比前一个大，不可能小于或等于。

- **子串**：说明这个序列在原数列中是**连续的**。

***

## 分析和解法

看完题目，很容易想到，我们首先需要预处理出原数列中所有严格上升子串的长度。

用 $f_{i,j}$ 表示 $[i,j]$ 中最长严格上升子串的长度？显然不行，$10^6$ 的范围，先不说时空了，这么大的数组编译都成功不了。

用 $f_i$ 表示 $[1,i]$ 中最长严格上升子串的长度？显然也不行，不方便处理（~~反正我不会~~）。

等一下，题目说是子串，就一定是连续的，所以……

$e_i$ 表示以 $i$ 结尾的严格上升子串的长度，$b_i$ 表示以 $i$ 开头的严格上升子串的长度，可以用两个线性递推方便地预处理出来，问题似乎突然变得简单起来！

$$e_i=\begin{cases}
e_{i-1}+1&a_{i-1}<a_i\\
1&(a_{i-1}\ge a_i)\vee(i=1)
\end{cases}
$$

$$b_i=\begin{cases}
b_{i+1}+1&a_{i}<a_{i+1}\\
1&(a_i\ge a_{i+1})\vee(i=n)
\end{cases}$$

其中，$\vee$ 是**逻辑或**运算，即代码中的 `||`。考虑到全局变量初始化为 $0$ 的特性，实际实现时不需要特判 $1$ 和 $n$，这点可以自己理解。另外需要注意的是递推顺序。

这部分的代码：

```cpp
	for(int i=1;i<=n;i++)
		e[i]=a[i]>a[i-1]?e[i-1]+1:1;
	for(int i=n;i>=1;i--)
		b[i]=a[i]<a[i+1]?b[i+1]+1:1;
```

预处理过后，接下来要枚举改变的数是哪个，怎么改变，具体的见这部分代码罢。

```cpp
	for(int i=1;i<=n;i++){
		if(a[i-1]<a[i+1]-1)//一定要减 1！
			ans=max(ans,e[i-1]+b[i+1]+1);//改变数字，将其前后的两个严格上升子串连接起来
		if(a[i-1]>=a[i])
			ans=max(ans,e[i-1]+1);//改变数字，延长前面的严格上升字串
		if(a[i]>=a[i+1])//这两个 if 中一定都是 >=
			ans=max(ans,b[i+1]+1);//同上，但是延长后面的
	}
```

仍然不需要特判 $1$ 和 $n$，自行理解。

***

## 代码

完整代码贴在这里，不过动了亿些手脚，~~我看哪个大冤种直接复制。~~

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define max(a,b) (a>b?a:b)
using namespace std;
int read(){
	int r;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9')
		r=r*10+ch-'0',ch=getchar();
	return r;
}
void write(int w){
	if(w>10)
		write(w/10);
	putchar(w%10+'0');
}
int n,a[N],b[N],e[N],ans;
signed main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		e[i]=a[i]>a[i-1]?e[i-1]+1:1;
	for(int i=n;i>=1;i--)
		b[i]=a[i]<a[i+1]?b[i+1]+1:1;
	for(int i=1;i<=n;i++){
		if(a[i-1]<a[i+1]-1)
			ans=max(ans,e[i-1]+b[i+1]+1);
		if(a[i-1]>=a[i])
			ans=max(ans,e[i-1]+1);
		if(a[i]>=a[i+1])
			ans=max(ans,b[i+1]+1); 
	}
	write(ans);
	return 0;
} 
```

---

## 作者：ttq012 (赞：8)

[双倍经验](https://www.luogu.com.cn/problem/CF446A)

$O(n^2)$ 做法：

暴力枚举修改的每一个数，然后计算最长严格上升子串的长度，取最大值即可。

期望得分：$\color{yellow}70$。

$O(n)$ 做法：

首先修改一个数一定不比不修改差。

设 $f_i$ 表示以 $i$ **结尾**的最长的严格递增子序列的长度，$g_i$ 表示以 $i$ **开头**的最长的严格递增子序列的长度。

现在如果想要修改第 $i$ 个数，如果：

+ $i = 1$，那么必然可以修改。
+ $i = n$，那么必然可以修改。
+ $2\le i\le n-1$，那么有：
  + $a_{i+1}-a_{i-1}\ge 2$，那么可以把 $a_i$ 的值修改成 $a_{i-1}+1\sim a_{i+1}-1$ 之间任意的一个正整数，让两个序列连续。于是贡献就是 $f_{i-1}+g_{i+1}+1$，其中 $f_{i-1}$ 表示 $i-1$ 结尾的连续子序列的贡献，$g_{i+1}$ 表示 $i+1$ 开头的连续子序列的贡献，$1$ 就是 $a_i$ 这一个元素的贡献。
  + $a_{i+1} - a_{i-1} < 2$，容易证明把 $a_i$ 修改成任意的数都不会让前面和后面的两段合并。那么修改的贡献就是 $\max(f_{i-1},g_{i+1})+1$。

然后按照上面的推理进行模拟即可。

期望得分：$\color{green}{100}$。

```cpp
#include <bits/stdc++.h>
const int N = 1e6 + 10;
int a[N], f[N], g[N];
signed main()
{
  int n;
  std::cin >> n;
  for (int i = 1; i <= n; i++)
    std::cin >> a[i];
  for (int i = 1; i <= n; i++)
    if (a[i] > a[i - 1])
      f[i] = f[i - 1] + 1;
    else
      f[i] = 1;
  for (int i = n; i; i--)
    if (a[i] < a[i + 1])
      g[i] = g[i + 1] + 1;
    else
      g[i] = 1;
  int mx = 0;
  for (int i = 1; i <= n; i++)
    if (a[i + 1] - a[i - 1] >= 2)
      mx = std::max(mx, f[i - 1] + g[i + 1] + 1);
    else
      mx = std::max(mx, std::max(f[i - 1], g[i + 1]) + 1);
  std::cout << mx << std::endl;
  return 0;
}
```



---

## 作者：Moon_Wind (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P9147)


------------

**题意简述：**

给出 $n$ 和一个长度为 $n$ 的序列 $a$，保证 $a_i$ 为**正整数**，可以把**任意**一个数修改成任意**整数**，求修改后的**最长严格上升子串**的长度。

**算法分析：**

- $70$ 分做法（时间复杂度 $O(n^2)$）：
	
    容易想到，可以枚举修改的数的位置，对修改后的 $a$ 数组求**最长严格上升子串**的长度。
    
- $100$ 分做法（时间复杂度 $O(n)$）：

	考虑对 $70$ 分算法进行优化。
    因为改变 $a_i$ 只会让以 $a_i$ 结尾和以 $a_{i+1}$ 为起点的严格上升子串的长度发生改变。当 $a_{i+1}-a_{i-1}>1$ 时，我们就可以使以 $a_i$ 结尾和以 $a_{i+1}$ 为起点的**最长**严格上升子串合并成一个更长的严格上升子串。
    
    所以，我们设 $b_i$ 为以 $a_i$ **结尾**的最长严格上升子串的长度，设 $c_i$ 为以 $a_i$ 为**开头**的最长严格上升子串的长度。然后枚举修改的数的位置，如果 $a_{i+1}-a_{i-1}>1$ 并且 $b_{i-1}+c_{i+1}$ 大于答案，则更新答案。
   
**代码部分：**



------------
```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e6+10;
int a[N],b[N],n,ans=0,c[N],op=1;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	b[1]=1;
	for(int i=2;i<=n;i++){
		if(a[i]>a[i-1]) b[i]=b[i-1]+1;
		else b[i]=1; 
		ans=max(ans,b[i]);
	}//以a[i]为结尾的最长严格上升子串的长度，
	c[n]=1;
	for(int i=n-1;i>0;i--){
		if(a[i]<a[i+1]) c[i]=c[i+1]+1;
		else c[i]=1; 
		ans=max(ans,c[i]);
	}//以a[i]为开通的最长严格上升子串的长度，
	ans++;
	for(int i=1;i<n;i++){
		if(a[i+1]-a[i-1]>=2) 
        		ans=max(b[i-1]+c[i+1]+1,ans);
	}
   	ans=min(ans,n);//记得对n取min
	cout<<ans;
	return 0;
}
```


---

## 作者：hyfzelda (赞：3)

# 思路

题目所求为最长**连续**严格上升子串的长度，如果我们把这个序列中的每个尽可能长的连续严格上升子串求出来，那它们显然不会互相包含。样例：

```cpp
7 | 2 9 | 4 5 6
```
此时，我们记录下来每一个子串**第一个**元素，**最后一个**元素，**倒数第二个**和**第二个**元素（如果有）。

接下来，我们一个个考虑这些子串，我们能修改任意一个数为任意值，所以会有以下三种情况：

1.普通情况

无论怎么修改，都无法将当前子串与前面或后面子串连成一个新的子串。

此时，$ans=\max(ans,len+1)$。

$len$ 为当前子串的长度。

2.
![](https://cdn.luogu.com.cn/upload/image_hosting/1tiat8l1.png)

此时，我们一开始存的**第二个**和**最后一个**就有用了。

我们修改第 $i+1$ 个子串的第一个，如果此时能有一种情况使第 $i$ 个子串的最后一个小于第 $i+1$ 个子串的第一个且第 $i+1$ 个子串的第一个小于第 $i+1$ 个子串的第二个时，更新答案。

维护方法：
```cpp
if(len[i+1]>=2&&sec[i+1]>last[i]+1) ans=max(ans,len[i]+len[i+1]);
```

3.

![](https://cdn.luogu.com.cn/upload/image_hosting/2nfugq3m.png)

此时,我们存的**倒数第二个**和**第一个**就有用了。

我们修改第 $i$ 个子串的第最后一个，如果此时能有一种情况使第 $i+1$ 个子串的第一个大于第 $i$ 个子串的最后一个且第 $i$ 最后一个大于第 $i$ 个子串的倒数第二个时，更新答案。

维护方法：

```cpp
if(len[i]>=2&&lastsec[i]<first[i+1]-1) ans=max(ans,len[i]+len[i+1]);

```

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[1000005],len[1000005],ans=0,cnt=1,first[1000005],last[1000005],sec[1000005],lastsec[100005];
signed main()
{
	
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	first[1]=a[1];
	for(int i=1;i<=n;i++)
	{
		if(a[i]>a[i-1])
		{
			len[cnt]++;
			if(len[cnt]==2)
			{
				sec[cnt]=a[i];
			}
		} 
		else 
		{
			last[cnt]=a[i-1];
			if(i>2&&len[cnt]>=2)
			{
				lastsec[cnt]=a[i-2];
			}
			cnt++,len[cnt]=1,first[cnt]=a[i];
		}
		ans=max(ans,len[cnt]+1);
	}
	for(int i=1;i<=cnt-1;i++)
	{
		if(len[i+1]>=2&&sec[i+1]>last[i]+1) ans=max(ans,len[i]+len[i+1]);
		if(len[i]>=2&&lastsec[i]<first[i+1]-1) ans=max(ans,len[i]+len[i+1]);
	} 
	cout<<min(ans,n);
}
```





---

## 作者：Eleveslaine (赞：2)

怎么那么多人用 DP 啊（

## 题意

给定一个长为 $n$ 的序列 $a$，初始均为正整数，允许修改任意一项为任意整数，求修改后最大的严格上升子串长度。

## 思路

不妨先 $O(n)$ 求出 $a$ 中每个严格上升子串，令 $\mathrm{vec}[i].l,\mathrm{vec}[i].r$ 表示第 $i$ 个严格上升子串是 $a_{\mathrm{vec}[i].l} \sim a_{\mathrm{vec}[i].r}$。比如序列 $[\underline{1,4},\underline{2,3,5}]$ 求出的结果是 $1\sim 2,3\sim 5$（下文记作 $[1,2],[3,5]$）。  
简单实现如下：

```cpp
struct ints {int l,r;}; // = pair<int,int>
...
for(int i=1,last=1;i<=n+1;++i)
{
    if(i!=n+1)
        cin >> a[i];
    else
        a[i]=-1;
    if(a[i]<=a[i-1])
        vec.push_back((ints){last,i-1}),last=i;
}
```

显然，$\mathrm{vec}$ 中的区间没有交点，各个区间之间为升序。

若有一个 $[l,r]=[1,n]$，即整个序列本来就严格上升，则答案为 $n$，一定不存在更大的，输出并退出。否则：  

> 对于一个不为 $[1,n]$ 的严格上升子串 $[l,r]$，一定能够在其前/后修改一个数，那么一个备选答案是区间长度 $+1$，即 $r-l+2$。

举个例子，$a=[\underline{1,4},\underline{2,3,5}]$ 时，求出 $[1,2],[3,5]$。  
对于 $[1,2]$，将 $a_3$ 改为 $\bold{\color{red}5}$，得到 $a'=[\underline{1,4,\bold{\color{red}5}},3,5]$，一个备选答案是 $3$；  
对于 $[3,5]$，将 $a_2$ 改为 $\bold{\color{red}1}$，得到 $a'=[1,\underline{\bold{\color{red}1},2,3,5}]$，一个备选答案是 $4$。  
两个备选答案取最大值，最终结果为 $\max\{3,4\}=4$。

还有一种以上例子没有体现的情况，例如 $a=[\underline{1,2},\underline{1,4,5,6}]$，这时将 $a_3$ 修改为 $\bold{\color{red}3}$ 可以得到 $a'=[\underline{1,2,\bold{\color{red}3},4,5,6}]$，答案为 $6$。这就是说，

> 对于两个相邻的严格上升子串 $[l_1,r_1],[l_2,r_2] (l_2=r_1+1,l_2+1 \le n)$，如果 $a_{l_2+1}-a_{r_1} \ge 2$（即能在中间改动一个数 $x$，使 $a_{r_1}<x<a_{l_2+1}$），那么一个备选答案是两个区间合并后的长度，即 $r_2-l_1+1$。

相似地，当 $a=[\underline{1,2,4},\underline{4,5,6}]$ 时，也是将 $a_3$ 改为 $3$，答案为 $6$，但是求出的区间有变动，做略微改动：

> 对于两个相邻的严格上升子串 $[l_1,r_1],[l_2,r_2] (l_2=r_1+1,r_1 \ge 2)$，如果 $a_{l_2}-a_{r_1-1} \ge 2$，那么一个备选答案是两个区间合并后的长度，即 $r_2-l_1+1$。

最后答案即所有备选答案的最大值，时间复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 1000005
int n,a[maxn],ans;
struct ints {int l,r;};
vector <ints> vec;
int main()
{
    cin >> n;
    for(int i=1,last=1;i<=n+1;++i)
    {
        if(i!=n+1)
            cin >> a[i];
        else
            a[i]=-1;
        if(a[i]<=a[i-1])
            vec.push_back((ints){last,i-1}),last=i;
    }
    for(int i=0;i<vec.size();++i)
    {
        if(vec[i].l==1 && vec[i].r==n)
        {
            cout << n << endl;
            return 0;
        }
        if(i>0&&vec[i].l+1<=n&&a[vec[i].l+1]-a[vec[i-1].r]>=2)
            ans=max(ans,vec[i].r-vec[i-1].l+1);
        else if(i>0&&vec[i-1].r-1>=1&&a[vec[i].l]-a[vec[i-1].r-1]>=2)
            ans=max(ans,vec[i].r-vec[i-1].l+1);
        else
            ans=max(ans,vec[i].r-vec[i].l+2);
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：ncwzdlsd (赞：1)

设 $f_i,g_i$ 分别表示以 $i$ 为开头、结尾的严格上升子串的长度。考虑如何维护这两个值，遍历数组，对于当前元素 $a_i$，若可以和前面 / 后面组成严格上升子串，则累加答案，否则重新记录一个新的严格上升子串。

由于修改位置是唯一的，可以直接枚举解决。对于一个修改位置，有三种情况：

- 该元素可以连接它前面和后面的严格上升子串

- 该元素可以延长它前面的严格上升子串

- 该元素可以延长它后面的严格上升子串

时间复杂度 $O(n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e6+5;
int a[maxn],f[maxn],g[maxn];

int main()
{
	int n;cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) g[i]=a[i]>a[i-1]?g[i-1]+1:1;
	for(int i=n;i;i--) f[i]=a[i]<a[i+1]?f[i+1]+1:1;
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i+1]-a[i-1]>1) ans=max(ans,g[i-1]+f[i+1]+1);
		else ans=max(ans,max(g[i-1]+1,f[i+1]+1));
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：aCssen (赞：1)

### Solution
容易想到一种错误的贪心做法：先求出 $a$ 中最长的严格上升子串，设其长度为 $len$，再修改一个数，则答案为 $\min \lbrace len+1,n \rbrace$。

但是这样很容易举出反例，比如数列 $a=\lbrace2 ,3,1,5,6,7\rbrace$。如果·按照上文的做法，只会找到数列 $\lbrace5,6,7\rbrace$，然后得到 $4$ 的错误答案。可如果令 $a_3=4$，则答案就是 $6$。

这启示我们如果修改 $a_i$，可能将左右两部分原本不相连的严格上升子串连接起来。我们枚举修改的位置，再将修改当前位的答案取 $\max$ 即可。

考虑计算修改第 $i$ 位时的答案。设 $f_i$ 表示以 $i$ 开头的严格上升子串长度，$g_i$ 表示以 $i$ 结尾的严格上升子串长度，则：

+ 可以令 $a_i>a_{i-1}$，则答案是 $g_{i-1}+1$。
+ 可以令 $a_i <a_{i+1}$，则答案是 $f_{i+1}+1$。
+ 如果 $a_{i-1}+1<a_{i+1}$，我们就可以让 $a_i$ 在 $a_{i-1}$ 和 $a_{i+1}$ 之间，则答案为 $g_{i-1}+f_{i+1}+1$。

取 $\max$ 即可。

讨论 $f$ 和 $g$ 数组的求法。令 $l$ 为当前严格上升子串的左端点，则 $g_i=i-l+1$。而只有更新 $l$ 的时候令 $f_l=len$。最后在循环一遍，对于没有更新到的 $f$，它的值应该是它左边的第一个 $f$ 减去它到它左边第一个 $f$ 的距离。

然后就签到了。
### 代码

代码中的 $r$ 数组就是上文的 $g$ 数组。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e6+6;
int a[maxn],f[maxn],r[maxn],n,l=1,ans,cnt;
inline int read(){
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n+1;i++){//到n+1,确保更新最后一段
		r[i-1]=i-l;
		if(a[i-1]>=a[i]){
			f[l]=i-l;
			l=i;
		}
	}
	for(int i=1;i<=n;i++){
		cnt--;
		if(f[i]) cnt=f[i];
		f[i]=cnt;
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,r[i-1]+1);
		ans=max(ans,f[i+1]+1);
		if(a[i-1]+1<a[i+1]) ans=max(ans,r[i-1]+f[i+1]+1);
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：sto_5k_orz (赞：1)

首先，$n\leq 10^6$，多半是线性做法。

改掉任何一个数字 $a_i$，最长部分一定是 $i-1$ 的左边和 $i+1$ 的右边的答案拼接而成，否则你为什么要改掉 $i$ 呢？

而且改的时候需要满足 $a_{i-1}+1<a_{i+1}$，否则改了也无法成立（这就是为什么要判断 $pre_i+1$ 的值）。

设从 $i$ 开始 $i$ 左边的递减的最左边的位置为 $pre_i$。设从 $i$ 开始 $i$ 右边的递增的最右边的位置为 $suf_i$。

那么答案就是 $pre_i+1+suf_i$ 和 $pre_i+1$ 的最大值。  

如果你不判 $pre_i+1$ 的话，恭喜你，$100$ 变 $70$。

然后就是如何求 $pre_i$ 和 $suf_i$。用双指针维护，$suf_i$ 向后，$pre_i$ 向前。

总复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define pii pair<int, int>
#define mk_p make_pair
#define gc getchar
#define W while
int read() {
	int x = 0; char ch = gc();
	W(ch < '0' || ch > '9') ch = gc();
	W(ch >= '0' && ch <= '9') x = x * 10 + (ch ^ 48), ch = gc();
	return x;
}
const int N = 1000010; int n, a[N], mx, suf[N], pre[N];
signed main() {
	n = read(); for(int i = 1; i <= n; i++) a[i] = read();
	if(n <= 2) cout << n, exit(0);
	for(int i = 1; i <= n; i++) {
		int j = i + 1; while(j <= n && a[j] > a[j - 1]) j++;
		for(int k = i; k < j; k++) suf[k] = j - k; i = j - 1; // 双指针
	}
	for(int i = n; i; i--) {
		int j = i - 1; while(j && a[j] < a[j + 1]) j--;
		for(int k = i; k > j; k--) pre[k] = k - j; i = j + 1; // 双指针
	}
	for(int i = 1; i <= n; i++) {
		mx = max(mx, pre[i] + 1);
	}
	mx = max(mx, pre[n - 1] + 1); mx = max(mx, suf[2] + 1);
	for(int i = 2; i < n; i++) if(a[i + 1] > a[i - 1] + 1) mx = max(mx, pre[i - 1] + 1 + suf[i + 1]);
	cout << min(mx, n);
	return 0;
}
```

---

## 作者：robertuu (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P9147)

枚举每个点 $a_i$，如果这个点可以插到其左右两侧的点（即 $a_{i-1}$ 和 $a_{i+1}$）中，使得 $a_{i-1}$、$a_i$、$a_{i+1}$ 构成严格上升子串就把他插进去形成长的上升子串，否则就把他和其中一侧拼合形成上升子串。

显然，能插入的条件为：$a_{i+1} - a_{i-1} \ge 2$。

问题转化成求一个点在其左侧和右侧的上升子串长度：$l_i$ 和 $r_i$。

这两个数组可以通过递推的方式求出：（以 $l_i$ 为例）

- 如果 $a_i > a_{i-1}$，那么 $l_i = l_{i-1} + 1$（延续上一个的值）。
- 否则 $l_i = 1$（只能自己新开）。

Code:
```cpp
#include<iostream>
using namespace std;
int a[1000002],l[1000002],r[1000002];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1;i <= n;i++)
        scanf("%d",&a[i]);
    // 预处理 l 和 r 数组
    l[1] = 1;
    for(int i = 2;i <= n;i++)
        if(a[i] > a[i-1]) l[i] = l[i-1]+1;
        else l[i] = 1;
    
    r[n] = 1;
    for(int i = n-1;i >= 1;i--)
        if(a[i] < a[i+1]) r[i] = r[i+1]+1;
        else r[i] = 1;
    
    int ans = 0;
    a[0] = -1; a[n+1] = 1e9+1; // 在两边设置边界（无穷小和无穷大）
    for(int i = 1;i <= n;i++)
    {
        ans = max(ans,max(l[i-1]+1,r[i+1]+1)); // 和一侧拼合
        if(a[i+1] - a[i-1] >= 2) ans = max(ans,l[i-1]+1+r[i+1]); // 插进去
    }
    printf("%d",ans);
    return 0;
}
```


---

## 作者：Bpds1110 (赞：0)

我们考虑枚举每个修改的 $i$。

我们先设 $End_i$ 为第 $i$ 个数作为串末的最大长度，$Begin_i$ 为第 $i$ 个数作为串首的最大长度。

可以发现，最优情况是将 $a_i$ 变为 $a_{i - 1} + 1$ 或 $a_{i + 1} - 1$。

最优目标是连接两个串，插入改变 $i$ 使得 $a_{i - 1} < a_i < a_{i + 1}$。但要满足条件 $a_{i - 1} + 1 \le a_{i + 1} - 1$，即前者与后者间必须有数存在，否则不成严格递增。这种情况的长度为 $End_{i - 1} + Begin_{i + 1} + 1$。

其次，我们可以选前后两串**的一种**进行连接，分别将 $i$ 变为 $a_{i - 1} + 1$ 和 $a_{i + 1} - 1$ 即可。长度为 $\max\{End_{i - 1} + 1, Begin_{i + 1} + 1\}$。

对于每个 $i$，求最优情况下长度最大即可。复杂度为 $O(n)$。

---

## 作者：what_can_I_do (赞：0)

[传送门](https://www.luogu.com.cn/problem/P9147)

先用数组 $la_i$ 表示以 $a_i$ 为结尾的最长严格上升子串的长度，$pr_i$ 表示以 $a_i$ 为开头的。

接下来枚举 $i$ 从 $1$ 到 $n$。对于每个 $i$，如果它是在一段严格上升子串的中间那么答案不做改变。否则如果 $a_{i+1}-a_{i-1}>1$，那么 $a_i$ 就一定可以变为一个整数使 $a_{i-1}<a_i<a_{i+1}$，答案变为答案与 $la_{i-1}+1+pr_{i+1}$ 的最大值。否则就让 $a_i$ 只跟着左边的最长严格上升子串或跟着右边的最长严格上升子串，答案为答案与 $la_{i-1}+1$ 和 $pr_{i+1}+1$ 的最大值。

注意当 $i=1$ 或 $i=n$ 时就只有一边有最长严格上升子串。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000010]={0};
int la[1000010]={0},pr[1000010]={0},ans=0;
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(register int i=1;i<=n;i++) if(a[i-1]<a[i]) la[i]=la[i-1]+1;else la[i]=1;
	for(register int i=n;i>=1;i--) if(a[i+1]>a[i]) pr[i]=pr[i+1]+1;else pr[i]=1;
	for(register int i=1;i<=n;i++) ans=max(ans,la[i]);
	for(register int i=1;i<=n;i++)
		if(i==1)
		{
			if(a[i]<a[i+1]) continue;
			ans=max(pr[i+1]+1,ans);
		}
		else if(i==n)
		{
			if(a[i]>a[i-1]) continue;
			ans=max(la[i-1]+1,ans);
		}
		else
		{
			if(a[i-1]<a[i]&&a[i]<a[i+1]) continue;
			if(a[i+1]-a[i-1]>1) ans=max(ans,la[i-1]+1+pr[i+1]);
			else ans=max(ans,max(la[i-1],pr[i+1])+1);
		}
	printf("%d",ans);
	return 0;
}
```

---


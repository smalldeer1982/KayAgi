# 灭罪「正直者之死」

## 题目背景

正直的人，坚强不屈的人，刚正不阿的人。

大约这样的人会处处吃亏吧，不过这样的观点大约是从欺骗者的眼光里看到的。正直的人，即使是在死后，也是最为人尊敬的吧。

## 题目描述

有一台计算器，使用 $k$ 位的带符号整型来对数字进行存储。也就是说，一个变量能够表示的范围是 $[-2^{k-1},2^{k-1})$。现在我们希望使用该计算器计算一系列数 $a_1,a_2,\cdots,a_n$ 的和。计算的伪代码如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/7p0loptk.png)

由于奇怪的特性，如果两个变量在相加时得到的结果在 $[-2^{k-1},2^{k-1})$ 之外，即发生了溢出，那么这台计算器就会卡死，再也无法进行计算了。

为了防止这样的事情发生，一个变通的方法是**更改 $a_i$ 的排列顺序**。容易发现这样不会改变计算出的和的值。

不过，可能不存在一种方案，使得计算出这 $n$ 个数并且计算机不爆炸。但我们还是希望，计算出**尽量多**的数字的和。

## 说明/提示

### 样例解释

- 对于样例 $1$，一种最优的方案是 $[a_1,a_2,a_3]$，这样可以在计算出前两个数的情况下不溢出。
- 对于样例 $2$，一种最优的方案是 $[a_{10},a_1,a_2,a_5,a_4,a_7,a_6,a_8,a_9,a_3]$，这样可以在计算前 $9$ 个数的情况下不溢出。

### 数据范围及约定

对于全部数据，保证 $1\le n\le 500$，$1< k\le 8$，$-2^{k-1}\le a_i<2^{k-1}$。

## 样例 #1

### 输入

```
3 3
1 2 3
```

### 输出

```
2
```

## 样例 #2

### 输入

```
10 4
-3 5 6 -4 5 3 -4 1 -1 0```

### 输出

```
9```

# 题解

## 作者：liruixiong0101 (赞：16)

## P1 题意：
给你 $n$ 个数 $a_1,a_2,\dots,a_n$ 和一个数 $k$，还有一个变量 $sum$，$sum$ 初始值为 $0$。你可以改变数组顺序，使从左往右遍历 $a_i$，每次遍历 $sum$ 的值加上 $a_i$，问你遍历到什么时候，$sum\notin [-2^{k-1},2^{k-1})$。	

## P2 思路：
我们首先就可以想到一直拿最小的，超出范围就停止循环。但是 $a_i$ 可能取负数，可能加到后面就下溢了，然后就可以想到要先加没有选的大于等于零的数中最小的，若会上溢，就加上一个没有选的负数中最大的这样减去的值就会最小，一直这样循环直到全部用完或者溢出为止。

## P3 细节：
我们可以用两个数组来分别保存数小于零或大于等于零的情况。
```cpp
//a数组是保存小于零的情况，b数组是保存大于等于零的情况。
for(int i = 1 , x; i <= n; i++){
	cin >> x;
	if(x < 0) a[++ta] = x;
	else b[++tb] = x;
}
```
但是这样还不够因为 $a,b$ 数组都初始值为 $0$ 所以会导致 $sum$ 一直加零的情况，会导致 RE，所以我们可以先把 $a,b$ 数组先赋成一个极值让 $sum$ 一加就爆，可以用 `memset` 做这件事。
```cpp
//0xc0赋成最小值，0x3f赋成最大值。
memset(a , 0xc0 , sizeof(a));
memset(b , 0x3f , sizeof(b));
```
## P4 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 505;
int n , k , ta , tb;
int a[N] , b[N];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0) , cout.tie(0);
	cin >> n >> k;
	memset(a , 0xc0 , sizeof(a));
	memset(b , 0x3f , sizeof(b));
	for(int i = 1 , x; i <= n; i++){
		cin >> x;
		if(x < 0) a[++ta] = x;
		else b[++tb] = x;
	}
	sort(a + 1 , a + 1 + ta , greater<int>());
	sort(b + 1 , b + 1 + tb);
	//贪心若这个数大于等于零先选最小的，否则先选最大的。
	int s1 = 1 , s2 = 1 , sum = 0 , ans = 0;
	while(s1 <= tb || s2 <= ta){
		if(sum + b[s1] < (1 << (k - 1))){
			sum += b[s1++];
		}//若sum没有上溢。
		else if(sum + a[s2] >= -(1 << (k - 1))){
			sum += a[s2++];
		}//若sum上溢了，但是没有下溢。
		else break;//否则直接停止循环。
		ans++;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：GeorgeAAAADHD (赞：11)

题目大意：给定 $n$ 及 $n$ 个数 $a_i$，问在 **可以调整 $a_i$ 的顺序的前提下**，最多能算出多少个 $a_i$ 的和。

------------
考虑贪心算法：

- 对于每一次求和，我们尽量将结果往 $0$ 的方向加，也就是说，每进行一次操作前先将 $a_i$ 按当前的结果加上这个 $a_i$ 的绝对值 **升序** 排序，并选择第一个数与当前答案相加。如果当前答案超过了范围，输出一共加了多少个值的个数。

- 如果所有的 $a_i$ 全部加完都没有超出范围，输出 $n$。

于是，我们可以根据这个贪心算法 AC。

```cpp
#include<bits/stdc++.h>
#define f() for(int i=1;i<=n;i++)
#define int long long
using namespace std; 
int n,k,a[501],ans=0,sum=0;
bool cmp(int a,int b){
	return abs(ans+a)<abs(ans+b);
} 
signed main(){
	cin>>n>>k;
	f(){
		cin>>a[i];
	}
	f(){
		sort(a+i,a+n+1,cmp);//排序
		ans+=a[i];
		sum++;
		if(ans<(0-pow(2,k-1))||ans>=pow(2,k-1)){//判断是否超出范围
			cout<<sum-1;
			return 0;
		}
	}
	cout<<n;
	return 0;
}
```

---

## 作者：0zhouyq (赞：2)

[传送门](https://www.luogu.com.cn/problem/P9207)

### 思路：

贪心题。

先将自然数和负数分别按 $|a_i|$ 从小到大排序。每次加数时，如果加上最小的自然数不会溢出，那就把它加上。否则就加上最大的负数。按这个策略模拟就行。注意判断自然数、负数有没有被取完。

### AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll up[9]={0,0,1,3,7,15,31,63,127},down[9]={-1,-1,-2,-4,-8,-16,-32,-64,-128};//预处理上下限
int main(){
	ll n,k;
	scanf("%lld %lld",&n,&k);
	priority_queue<ll,vector<ll>,greater<ll> > q1;//自然数
	priority_queue<ll,vector<ll>,less<ll> > q2;//负数
	for(ll i=1;i<=n;i++){
		ll x;
		scanf("%lld",&x);
		if(x>=0) q1.push(x);
		else q2.push(x);
	}
	ll now=0;
	for(ll i=1;i<=n;i++){
		if(q1.empty()){//判空
			now+=q2.top();
			q2.pop();
			if(now<down[k]){
				printf("%lld",i-1);
				return 0;
			}
		}
		else if(q2.empty()){
			now+=q1.top();
			q1.pop();
			if(now>up[k]){
				printf("%lld",i-1);
				return 0;
			}
		}
		else{
			ll x=q1.top(),y=q2.top();
			if(now+y>=down[k]){
				now+=y;
				q2.pop();
			}
			else if(now+x<=up[k]){
				now+=x;
				q1.pop();
			}
			else{
				printf("%lld",i-1);
				return 0;
			}
		}
	}
	printf("%lld",n);//不要忘了，可能加上所有数都不会溢出。
	return 0;
}
```

---

## 作者：lxuyinc (赞：1)

# 先不多说，直接进入正文
## 题意
**给定两个整数 $n$，$k$，以及一串长度为 $n$ 的序列 $a$，每次计算时从序列 $a$ 中取一数进行加法运算，问保证每次加完后的值在 $[-2^{k-1},2^{k-1})$ 内的情况下，最多能取多少数进行相加。**
## 分析
由于数据范围为 $1\le n\le 500$，$1< k\le 8$，$-2^{k-1}\le a_i<2^{k-1}$，~~因此可以用 int 储存。~~**（好吧，这是众所周知的）**


------------
$a$ 序列中的数有正有负，我的思路就是将其分开处理，用两个数组分别储存正数和负数并排序，以方便后续处理，即：
```
	for(int i=1;i<=n;i++){
		cin>>a[i];	
		if(a[i]>0) z[++tz]=a[i];
		else if(a[i]==0) tot++;
		else f[++tf]=a[i];
	}
    	sort(z+1,z+1+tz);
	sort(f+1,f+1+tf,cmp);
```
当然，当数列中只有正数或负数时，见下文中的 **其他处理** 部分。


------------
### 思路
很明显，这是一道妥妥的贪心题，要使在不超出范围的情况下取最多数相加，就应使相加后的值尽量接近范围的中值处，那么我们就需要尽量使“正负数中和”，最好从负数最大值和正数最小值加起，这样能保证空间盈余，即让能进行相加的数最多。这里我使用到了前缀和：
```
		int p;
		for(int i=1;i<=tf;i++)
			f[i]+=f[i-1];
		for(int i=1;i<=tz;i++)
			z[i]+=z[i-1];
		for(int i=1;i<=tf;i++)
			for(int j=1;j<=tz;j++){
				if(f[i]+z[j]>=-1*lim&&f[i]+z[j]<lim){
					p=max(p,i+j);		
                    //只要总和不超出范围，总能使用一系列方法得到
				}
			}
		cout<<p+tot;
```
### 其他处理
前面提到的只有正数或负数的情况，需要特判：
```
//从绝对值小的数加到绝对值大的数，刚好为超过阈值时相加数的个数就是答案
if(f[1]==0){
		int ans=0,p;
		for(int i=1;i<=tz;i++)
			if(ans<lim){	//lim为临界值
				ans+=z[i];
				p=i;
			}
			else break;
			cout<<p-1+tot;
	}
	else if(z[1]==0){
		int ans=0,p;
		for(int i=1;i<=tf;i++)
			if(ans>=-1*lim){
				ans+=f[i];
				p=i;
			}
			else break;
			cout<<p-1+tot;
	}
```
# 总结
## _code:_
```
//拒绝抄袭,从我做起
#include<bits/stdc++.h>
using namespace std;
int n,k,a[505],z[505],f[505];
bool cmp(int x,int y){
	return x>y;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>k;
	int lim=1<<(k-1),tot=0,tz=0,tf=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];	
		if(a[i]>0) z[++tz]=a[i];
		else if(a[i]==0) tot++;
		else f[++tf]=a[i];
	}
	sort(z+1,z+1+tz);
	sort(f+1,f+1+tf,cmp);
	if(f[1]==0){
		int ans=0,p;
		for(int i=1;i<=tz;i++)
			if(ans<lim){
				ans+=z[i];
				p=i;
			}
			else break;
			cout<<p-1+tot;
	}
	else if(z[1]==0){
		int. ans=0,p;
		for(int i=1;i<=tf;i++)
			if(ans>=-1*lim){
				ans+=f[i];
				p=i;
			}
			else break;
			cout<<p-1+tot;
	}
	else{
		int p;
		for(int i=1;i<=tf;i++)
			f[i]+=f[i-1];
		for(int i=1;i<=tz;i++)
			z[i]+=z[i-1];
		for(int i=1;i<=tf;i++)
			for(int j=1;j<=tz;j++){
				if(f[i]+z[j]>=-1*lim&&f[i]+z[j]<lim){
					p=max(p,i+j);
				}
			}
		cout<<p+tot;
	}
	return 0;	
}
```
#### 完结撒花！

给后来者的建议：写题解前请一定规范 LaTeX 格式！

---

## 作者：氷の妖怪Cirno (赞：1)

### 题意简述
- 给定 $n$ 个整数 $a_{1...n}$ 和一个正整数 $k$。
- 你可以更改 $a_i$ 的排列顺序，使得对于前 $m$ 个数，$\forall p \le m$，$-2^{k-1}\le \sum_{i=1}^pa_i < 2^{k-1}$。
- 求 $m$ 可能的最大值。
- $1 \le n \le 500$，$-2^{k-1} \le a_i < 2^{k-1}$，$1 < k \le 8$。

### 题目分析

首先注意数据范围：$-2^{k-1} \le a_i < 2^{k-1}$。

这意味着计算器当前存储的变量 $sum > 0$ 时，可以任意加上一个负数；$sum < 0$ 时，可以任意加上一个正数。
- 如果序列中所有数的和在 $[-2^{k-1},2^{k-1})$ 之间，**必定存在一种排列顺序使 $n$ 个数全部被计算。**（如果正数用尽了，那么此时的 $sum$ 值与剩余负数之和必定不小于下限，采用 $sum$ 大于零就加负数，小于零就加正数的方案就能保证不在过程中出现越界，负数用尽同理。）
- 如果序列中所有数的和在 $[-2^{k-1},2^{k-1})$ 之外，考虑如何转化成上一种情况，也就是说，**删去尽可能少的数，使剩余数的和在 $[-2^{k-1},2^{k-1})$ 之间。**
这时贪心策略就很明显了：
**当前 $sum \ge 2^{k-1}$，优先删最大的正数；$sum < -2^{k-1}$，优先删最小的负数。**

###  _code:_ 



```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 505;
int a[MAXN], b[MAXN];//a数组记录正数，b数组记录负数
int l, r, L, R, x1, x2, s1, s2;//x1，x2记录正、负数个数
//L,R为计算器储存结果的上限下限，s1为正数之和，s2为负数之和，可直接用sum代替
int main()
{
	int n, k;
	cin >> n >> k;
	R = (1<<(k-1));
	L = -R;
	for (int i = 1; i <= n; i++)
	{
		int x;
		cin >> x;
		if (x > 0)
		{
			a[++x1] = x; s1 += x;
		}
		else if (x < 0)
		{
			b[++x2] = x; s2 += x;
		}
	}
	sort(a+1, a+x1+1); sort(b+1,b+x2+1);
	l = 1; r = x1;
	if (s1 + s2 >= L && s1 + s2 < R)
	{
		cout << n; //因为n后续没有作用了,所以直接用n计数
	}
	else if (s1 + s2 >= R)
	{
		while(s1 + s2 >= R)
		{
			s1 -= a[r];
			r--; n--;//PS：如果自己定义cnt等变量从0开始计数，注意0的统计！
		}
		cout << n;
	}
	else
	{
		while(s1+s2<L)
		{
			s2 -= b[l];
        l++; n--;
		}
		cout << n;
	}
	return 0;
 } 
```

---

## 作者：nynkqh_yzp (赞：1)

显然是一道贪心题。
尽量先算小的自然数，如果不行，就加上最大的负数，就可以通过。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,an;
priority_queue<int>a;
priority_queue<int,vector<int>,greater<int> >b;
int main(){
	scanf("%d%d",&n,&m);
	m=(1<<m-1);
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		if(x<0)
			a.push(x);
		else
			b.push(x);
	}
	while(1){
		while(!b.empty()){
			if(ans+b.top()<m) {
				ans+=b.top(),b.pop();
				an++;
			}
			else
				break;
		}
		if(!a.empty()&&ans+a.top()>=-m){
			ans+=a.top(),a.pop();
			an++;
		}
		else
			break;
	}
	printf("%d",an);
	return 0; 
}

```


---

## 作者：I_will_AKIOI (赞：0)

看到这题，不禁回想起了爆 ```long long```
 然后痛苦写高精的黑历史……

------------
为了防止计算机爆炸，我们需要让 $sum$ 的绝对值尽可能小。便可以想到贪心算法。如果 $sum>0$，那就要加上一个负数，反之就要加上一个正数。直到无法存储数据，退出循环。

我们可以用 $a$ 数组和 $b$ 数组分别存储正数和负数，$lena$ 和 $lenb$ 存储长度。再**按绝对值从大到小**排序。（想一想，为什么）最后再按上面的要求累加即可。复杂度 $O(n)$ ，轻松通过本题。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,l,r,x,s,ans;
int a[1000],b[1000],lena,lenb;
int f[9]={0,1,2,4,8,16,32,64,128};//存储2^n 
bool cmp(int a,int b) {return a>b;}
int main()
{
  cin>>n>>k;
  l=f[k]*-1;
  r=f[k];
  for(int i=1;i<=n;i++) 
  {
    cin>>x;
    if(x>=0) {lena++;a[lena]=x;}//存入正数数组或负数数组 
    else {lenb++;b[lenb]=x;}
  }
  sort(a+1,a+lena+1,cmp);//对a、b数组按绝对值排序 
  sort(b+1,b+lenb+1);
  for(int i=1;i<=n;i++) 
  {
    if(lena>0&&lenb>0)//两种数都还有剩余 
    {
      if(s<0&&lena) {s+=a[lena];lena--;}
      else if(lenb) {s+=b[lenb];lenb--;}	
    }
    else if(lena>0) {s+=a[lena];lena--;}//负数用完了 
    else {s+=b[lenb];lenb--;}//正数用完了
    if(s<l||s>=r) break;//越界就退出 
    ans++;
  }
  cout<<ans;
  return 0;
}
```
**道路千万条，安全第一条。直接抄题解，棕名两行泪。**

---

## 作者：comcopy (赞：0)

由于顺序无关，将所有的值都记录下来然后按绝对值排序，对于每次选取贪心地能取就取，就行了。

对于贪心的证明：

- 易得 0 对答案无干扰，可以直接算入答案

- 顺序无关，因此打乱顺序对最后的答案没有干扰。

将答案为正负的两个分别储存，按值从小到大排序。

将一个正数添加进来以后暴力添加当前最大的负数（即绝对值最小）至无法添加，再添加下一个正数，如果当前正数无法添加则更大的正数必然无法添加，而当前的值已经不允许再减了，那么答案就是最终答案。

对于绝对值更小的数优先添加我认为无需证明，是最基础的贪心。

```cpp
#include<bits/stdc++.h>
#define mi(...) <%__VA_ARGS__%>
#define int long long
using namespace std;

namespace Faster {
inline bool _u(char ch) { return ch >= '0' && ch <= '9'; }
//char buf[1 << 23], *p1 = buf, *p2 = buf;
//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 23, stdin), p1 == p2) ? EOF : *p1++)
inline int read() {int x = 0, f = 1;char ch = getchar();for (; !_u(ch); ch = getchar())if (ch == '-')f = -f;for (; _u(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);return x * f;}
inline void write(int num) {static int sta[0][39], top = 0;if (num < 0)putchar('-'), num *= -1;do sta[0][++top] = num % 10, num /= 10;while (num);while (top) putchar(sta[0][top--] | 48);return;}
}using namespace Faster;

const int N = 1e5+5;
int n,k;
int a[2][N];
int l,r;
int ans;
signed main() {
	cin>>n>>k;
	for(int i=1,x; i<=n; ++i)
		if((x=read())==0) ++ans;else
		x>0?(a[0][++l]=x):(a[1][++r]=-x);
	int mx=1<<k-1;
	sort(a[0]+1,a[0]+l+1);
	sort(a[1]+1,a[1]+r+1);
	int tot=0,now=1;
	for(int i=1; i<=l; ++i) {
		for(; now<=r&&tot>0;++now)
			tot-=a[1][now],++ans;
		if(tot+a[0][i]<mx) {
			tot+=a[0][i],++ans;
			continue;
		}
	}
	for(;now<=r;++now)
		if(-mx<=tot-a[1][now])
			tot-=a[1][now],++ans;
		else break;
	write(ans),puts("");
	return(0-0);
}
```

---

## 作者：ダ月 (赞：0)

### 题目分析：

题目是想让你重排 $a_i$，让其前缀和 $S_i$ 从 $1$ 到 $k$ 满足 $\in[-2^{k-1},2^{k-1})$，让 $k$ 最大。

我们考虑考虑贪心：

我们将负数，正数，和 $0$ 分成三类。将负数从大到小，正数从小到达排序。每次取用的时候，不断从前往后将正数取用到最多，然后再取用负数取用到最多。以此往复，直到取完或者不能取地时候为止。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e2+10;
//===
//缺省源
//===
int n;
ll k;
ll a[N];
bool cmp(int x,int y){return x>y;}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>k;int l=-(1<<k-1),r=(1<<k-1);
	for(int i=1;i<=n;i++)cin>>a[i];
	vector<ll> e,o;int ze=0;
	for(int i=1;i<=n;i++)
		if(a[i]>0)e.pd(a[i]);
		else if(!a[i])ze++;
		else o.pd(a[i]);
	ll ans=0,now=0;
	sort(all(e));
	sort(all(o),cmp);
	for(int p1=0,p2=0;;){
		bool flag=false;
		while(p1<e.size()&&now+e[p1]<r)ans++,now+=e[p1],p1++,flag=true;
		while(p2<o.size()&&now+o[p2]>=l)ans++,now+=o[p2],p2++,flag=true;
		if(!flag)break;
	}
	printf("%lld\n",ans+ze);
	return 0;
}


```
时间复杂度：$O(n\log n)$。

题外话：

[做法灵感来源](https://www.luogu.com.cn/problem/CF1798D)。

---

## 作者：fish_love_cat (赞：0)

**贪心思路：**

把负数和正数分开储存，正数从小到大排序，负数从大到小排序。用 $sum$ 记录结果，如是正数加最大的负数，是负数加最小的正数，可以让 $sum$ 在离 0 最近的地方打转。如果这里溢出来，那么其他数字也一定会溢出。

需要小心的是，如果一边数字没了，那么就没得选了，得特判。

**贪心代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum=0,ans;
long long j,k;//记录正负数数量
long long a[505],b[505];
bool cmp(long long a,long long b){
    return a>b;
}
int main(){
    long long n,kf;
    cin>>n>>kf;
    long long l=-pow(2,kf-1),r=pow(2,kf-1)-1;//求出上界和下界
    for(int i=0;i<n;i++){
        long long x;
        cin>>x;
        if(x<0) b[++j]=x;
        else a[++k]=x;
    }
    //由于我是反着来的，所以我把负数和正数的顺序颠倒了，别学我
    sort(a+1,a+k+1,cmp);
    sort(b+1,b+j+1);
    while(k||j){//如果一个数都没了就踢出去
        if(sum<0&&k!=0||j==0) sum+=a[k--];//如果当前是负数而且还有正数得进来，或者没负数了也得进来
        else sum+=b[j--];//贪心主程序
        if(sum<=r&&sum>=l) ans++;//如果越界也踢出去
        else break;
    }
    cout<<ans;
    return 0;
}
//qwq
```

---

## 作者：zymooll (赞：0)

### 题目大意

在集合 $a$ 中，找出最多的元素相加 $\in [-2^{k-1},2^{k-1})$.

### 简要思路

采用贪心算法，将集合排序后，找到最小的正数和负数，令其位置为 $l$ 和 $r$，假设前 $i-1$ 次操作和为 $sum$，所以对于第 $i$ 次加操作.

 - 若 $sum+a_l \notin [-2^{k-1},2^{k-1}) \wedge sum+a_r \notin [-2^{k-1},2^{k-1})$，则说明已经找到最优解.
 
 - 若 $sum+a_l \notin [-2^{k-1},2^{k-1})$ 但 $sum+a_r \in [-2^{k-1},2^{k-1})$ 或 $sum+a_l \in [-2^{k-1},2^{k-1})$ 但 $sum+a_r \notin [-2^{k-1},2^{k-1})$，则采用属于区间内的.
 
 - 若 $sum+a_l \in [-2^{k-1},2^{k-1}) \wedge sum+a_r \in [-2^{k-1},2^{k-1})$，则采用 $\min({|sum+a_l|,|sum+a_r|})$.
 
加操作后根据采用元素的不同，将 $l-1$ 或 $r+1$.

在本题中，注意将边界置为正无穷.
 
因为排序是从小到大的，小的先入，所以满足贪心原则.
 
### 参考代码

为保证观感，略去了头文件和快读快写.

```cpp
#define int long long
int n,k,f,ans;
int a[510];
signed main(){
    n=read(),k=read();
    k--;
    for(int i=1;i<=n;i++){
    	a[i]=read();
	}
	sort(a+1,a+1+n);
	int pos=lower_bound(a+1,a+1+n,0)-a;//>=0
	int l=pos-1,r=pos;
	int js=0;
	a[0]=INT_MAX,a[n+1]=INT_MAX;
	while(1){
		int pl=js+a[l],pr=js+a[r];
		//cout<<js<<" "<<a[l]<<" "<<a[r]<<" "<<l<<" "<<r<<endl;
		int f1=0,f2=0;
		if(pl>=1<<k||-pl>1<<k)f1=1;
		if(pr>=1<<k||-pr>1<<k)f2=1;
		if(f1&&f2)break;
		if(f1)js+=a[r++];
		else if(f2)js+=a[l--];
		else{
			if(abs(pl)<abs(pr))js+=a[l--];
			else js+=a[r++];
		}
		ans++;
	}
	print(ans);
    return 0;
}
```

---

## 作者：_JF_ (赞：0)

## P9207 灭罪「正直者之死」 

贪心。

因为要取的和尽可能多，那么就是要求每一步取得和尽可能小。

考虑对正数和负数分组，排序。每次先取正数，取到不能再取为止，然后再取负数，这样就可以降小这个值，一直到极限为止。不断重复这一过程，直到不能取为止。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
int a[N],b[N];
bool cmp(int x,int y){
	return x>y;
}
int main()
{
	int n,k,p=0,q=0,now=0,last1=1,last2=1;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		if(x<0)	p++,a[p]=x;
		else	q++,b[q]=x;
	}
	sort(a+1,a+p+1,cmp),sort(b+1,b+q+1);
	while(1){
		bool f=false;
		for(int i=last1;i<=p;i++)
			if(now+a[i]>=-pow(2,k-1))	f=true,now+=a[i],last1=i+1;
		for(int i=last2;i<=q;i++)	
			if(now+b[i]<pow(2,k-1))	f=true,now+=b[i],last2=i+1;
		if(f==false)	break;
	}
	cout<<last1+last2-2<<endl;
	return 0;
}

```


---


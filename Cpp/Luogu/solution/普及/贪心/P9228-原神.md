# 原神

## 题目背景

## 提示：题目背景与题目无关。


你说的对，但是《原神》是由米哈游自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「提瓦特」的幻想世界，在这里，被神选中的人将被授予「神之眼」，导引元素之力。你将扮演一位名为「旅行者」的神秘角色，在自由的旅行中邂逅性格各异、能力独特的同伴们，和他们一起击败强敌，找回失散的亲人——同时，逐步发掘「原神」的真相。

因为你的素养很差，我现在每天玩原神都能赚 150 原石，每个月差不多 5000 原石的收入， 也就是现实生活中每个月 5000 美元的收入水平，换算过来最少也 30000 人民币，虽然我 只有 14 岁，但是已经超越了中国绝大多数人（包括你）的水平，这便是原神给我的骄傲的资本。

毫不夸张地说，《原神》是 miHoYo 迄今为止规模最为宏大，也是最具野心的一部作品。即便在经历了 8700 个小时的艰苦战斗后，游戏还有许多尚未发现的秘密，错过的武器与装备，以及从未使用过的法术和技能。

尽管游戏中的战斗体验和我们之前在烧机系列游戏所见到的没有多大差别，但游戏中各类精心设计的敌人以及 Boss 战已然将战斗抬高到了一个全新的水平。就和几年前的《塞尔达传说》一样，《原神》也是一款能够推动同类游戏向前发展的优秀作品。

## 题目描述

原神中有一个魔法师，她可以打出 $ n $ 次火元素攻击魔法和 $ m $ 次冰元素攻击魔法，每次攻击的伤害分别为 $ a_1,a_2,\cdots, a_n $ 和 $ b_1,b_2,\cdots, b_m $。

元素攻击之间存在如下反应规则：

- 每次元素攻击可以给**没有元素附着**的怪物附着相应的元素，初始时怪物没有元素附着；

- 如果用火元素攻击打到冰元素附着的怪物身上，那么本次伤害将 $ \times 2 $，**并清空元素附着**；

- 如果用冰元素攻击打到火元素附着的怪物身上，那么本次伤害将 $ +k $，**并清空元素附着**。

现在魔法师可以任意安排攻击顺序，也就是说，每次攻击过后，魔法师可以从自己没有使用过的魔法中任意挑选一种使用。她希望最大化总伤害，请问**最大总伤害**是多少。

## 说明/提示

### 样例 1 解释

攻击采用 $a_1\rightarrow b_4\rightarrow a_2\rightarrow b_3\rightarrow a_5\rightarrow b_5\rightarrow b_7 \rightarrow b_1\rightarrow a_3 \rightarrow b_2\rightarrow a_4\rightarrow b_3 \rightarrow a_6 $，每次的实际伤害为 $1,12,1,4,1,11,0,1,8,9,10,1,8$，总伤害为 $ 67 $。

### 样例 2 解释

攻击采用 $a_5\rightarrow b_1\rightarrow b_2\rightarrow a_4\rightarrow a_3\rightarrow b_3\rightarrow a_2\rightarrow a_1$，每次的实际伤害为 $5,12,1,16,2,9,4,1$，总伤害为 $50 $。

### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq n,m \leq 10^6 $，$ 0 \leq a_i,b_i,k \leq 10^9 $。

| 测试点编号 | $n,m \leq$  |特殊性质|
| :----------: | :----------: | :-----------: |
| $1 \sim 5$ | $10$ | |
| $6 \sim  10$ | $1000$ | |
| $11 \sim 12$ | $10 ^6 $ | $k=0$ |
| $13 \sim 14$ | $10 ^6 $ | $k>\max(\max_{i=1}^n\{a_i\},\max_{i=1}^m\{b_i\})$ |
| $15 \sim 16$ | $10 ^6 $ | $n=m$ | 
| $17 \sim 25$ | $10 ^6 $ | | 


## 样例 #1

### 输入

```
6 7 3
1 1 4 5 1 4
1 9 1 9 8 1 0
```

### 输出

```
67
```

## 样例 #2

### 输入

```
5 3 5
1 4 2 8 5
7 1 4
```

### 输出

```
50```

## 样例 #3

### 输入

```
1 1 0
2
3
```

### 输出

```
7
```

## 样例 #4

### 输入

```
见附件中的 samples/genshin4.in```

### 输出

```
见附件中的 samples/genshin4.ans```

## 样例 #5

### 输入

```
见附件中的 samples/genshin5.in```

### 输出

```
见附件中的 samples/genshin5.ans```

# 题解

## 作者：封禁用户 (赞：26)

## 分析

明明显显的贪心啊。~~注意叠词（~~

题目背景是一堆废话，没必要看。

为了使伤害最大，我们需要尽可能的使打出的攻击满足后两个规则。同时，我们还需要优先考虑大的 $a_i$。所以我们先将 $a$ 序列从大到小排序。在 $a_i$ 大的时候，我们需要拿 $b$ 序列来接应，注意的是，规则三中 $b_i$ 的值并不影响增加的值。

优先看规则二，我们从最大的 $a$ 进行枚举。若 $a_i × 2$ 的值大于对应 $b_i +k$ 的值，说明在这里运用规则三更好。由于规则一，同种元素不会抵消，我们完全可以以这个下标为割点，将后面的 $a_i$ 都先出，这样才能保证答案最大化。

为了更好理解，我们继续分析。题目要求将 $a$ 和 $b$ 全部打出去，所以答案的值至少是 $a,b$ 两序列的和。这样的话，在判断割点的时候，我们只需看 $a_i$ 是否小于 $k$ 就行了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+100000;
bool cmp(int a,int b){return a>b;}
int n,m,k;
int a[N],b[N];
int ans,kk;
signed main() 
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>a[i],ans+=a[i];
	for(int i=1;i<=m;i++) cin>>b[i],ans+=b[i];//求和
	sort(a+1,a+n+1,cmp);//贪心思路排序
	int minn=min(n,m);//这里一定是最小值
	for(int i=1;i<=minn;i++) if(a[i]>k) ans+=a[i],kk++;//规则二更优
	ans+=k*(minn-kk);//剩下的全部运用规则三
    return cout<<ans,0;
}
```
感谢 @seanlsy 大佬提出的改进方案。

---

## 作者：Coffee_zzz (赞：19)

### 分析

这 $n+m$ 次攻击在不触发元素反应时的伤害总量和不变的，所以只需要让其中元素反应的增幅伤害尽可能大。

需要一次火元素攻击和一次冰元素攻击才能触发元素反应，所以最多只能触发 $\min(n,m)$ 次元素反应，而且元素反应只会增加伤害不会减少伤害，所以我们要尽可能多地触发元素反应，即 $\min(n,m)$ 次元素反应全部触发。设 $l=\min(n,m)$。

注意到冰元素造成的伤害不在于触发元素反应的伤害大小，而在于元素反应次数。每次冰元素触发元素反应时的增幅伤害为 $k$。

而火元素触发元素反应时伤害会 $\times 2$，即 $+a_i$，其中 $a_i$ 为原本的伤害。

我们将 $a$ 从大到小排序，看排序后的前 $l$ 个元素。第 $i$ 次元素反应，若 $a_i>k$，则让火元素触发元素反应，此时增幅伤害为 $a_i$，反之让冰元素触发元素反应，此时增幅伤害为 $k$。

计算时可以分别计算基础伤害（即数组 $a$ 和数组 $b$ 的和）和增幅伤害。

不开 `long long` 见祖宗。感觉难度只有橙。

### 代码

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,a[1000005],b[1000005];
signed main(){
	cin>>n>>m>>k;
	int sum=0,l=min(n,m);
	for(int i=1;i<=n;i++) cin>>a[i],sum=sum+a[i];
	for(int i=1;i<=m;i++) cin>>b[i],sum=sum+b[i];
	sort(a+1,a+n+1);reverse(a+1,a+n+1);
	for(int i=1;i<=l;i++){
		if(a[i]>k) sum=sum+a[i];
		else sum=sum+k;
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：MspAInt (赞：11)

[题目传送门](https://www.luogu.com.cn/problem/P9228)

原神怎么你了原神。

由题意可知，显然我们要**尽量把加成加到伤害高的魔法上**（对于冰系伤害谁加都没有影响，但火系伤害的翻倍就不一样了）。

由于元素效果之间会互相抵消，所以每一对冰火伤害加成是**不会对后面的贡献产生影响**的，于是可以一对一对考虑。

这满足贪心思想。

将伤害从大到小排序，接着就是两种顺序两种伤害情况：

* 先冰后火：$b_i+a_i\times 2$。
* 先火后冰：$a_i+b_i+k$。

取最大值累加即可。

然后还会剩下一些没有加成的魔法，逐个加上就行。

Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
int n,m,k,a[N],b[N],ans;
bool cmp(int x,int y){
    return x>y;
}
signed main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    for(int i=1;i<=m;i++)scanf("%lld",&b[i]);
    sort(a+1,a+n+1,cmp);sort(b+1,b+m+1,cmp);
    for(int i=1;i<=min(n,m);i++)
        ans+=max(a[i]+b[i]+k,b[i]+a[i]*2ll);
    for(int i=min(n,m)+1;i<=max(n,m);i++)ans+=a[i]+b[i];
    printf("%lld\n",ans);
    return 0;
}
```

[record](https://www.luogu.com.cn/record/108704535)

---

## 作者：jqQt0220 (赞：7)

原神，启动！~~（这个题目背景真 nb~~

很明显，是贪心。玩过原神都知道，只有多打反应，伤害才能尽量高 ~~（冰打火不是 $\sout{\times1.5}$ 吗）~~。

很容易想出来，打反应的最多次数是 $\min(n,m)$。我们不妨简化一下题意，火打冰伤害增加 $a_i$，冰打火伤害增加 $k$。因为 $k$ 是固定的，所以可以从大到小排序 $a_i$，看看每个 $a_i$ 和 $k$ 哪个大。每次基础伤害是 $a_i+b_i$，就是不考虑元素附着的情况下一次火伤和一次冰伤，如果考虑元素附着，那么火打冰会多 $a_i$ 的伤害，冰打火会多 $k$ 的伤害，并且两次伤害打完是没有了元素附着的。根据贪心思想，当然是哪个大选哪个。把所有 $\min(n,m)$ 次反应打完后，剩下的所有可打出的单个元素伤害就可以直接打出去。**注意：十年 OI 一场空，不开 long long 见祖宗**。

参考代码：（省去了我代码前奇奇怪怪的初始化和万能头）
```cpp
typedef long long ll;//记得开 long long
int n,m;
ll k,a[1000010],b[1000010],as=0;
bool cmp(ll x,ll y)
{
    return x>y;
}
int main()
{
    ___();//我的初始化函数，可以直接忽略
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=m;i++)
        cin>>b[i];
    sort(a+1,a+n+1,cmp);//从大到小排序
    int t=min(n,m);//打 min(n,m) 次反应
    for(int i=1;i<=t;i++)
    {
        as+=a[i]>k?a[i]:k;//哪个反应收益高就打那个
        as+=a[i]+b[i];//加上基础的一次火伤和一次冰伤
    }
    //下面两段代码只会执行至多一段，所以不用考虑元素附着
    for(int i=m+1;i<=n;i++)
        as+=a[i];
    for(int i=n+1;i<=m;i++)
        as+=b[i];
    cout<<as<<endl;
    return 0;//完美结束 QwQ
}
```

---

## 作者：Register_int (赞：6)

由于所有魔法总的伤害在不算增益的情况下是确定的，为了让增益次数尽可能多，我们需要把元素两两分组。获得一次增益的条件是覆盖一个元素再用不同元素消去，不考虑其他限制，最大的增益次数为 $\min(n,m)$。而这种安排可以使得增益次数最大化。

接着要确定魔法应该分配到哪些组。由于 $b$ 对应的增益与元素无关，所以可以不考虑；而 $a$ 的增益与元素大小有关，且有可能无法得到增益，所以我们应该先让较大的元素获得伤害翻倍，使得利益最大化。因此，$a$ 数组要从大到小进行匹配。

最后确定单独组中要采用哪一种增益方式。如果翻倍的贡献小于增加 $k$ 的贡献，则先使用火元素，否则先使用冰元素，获得的伤害为 $a_i+b_i+\max(k,a_i)$。

最后单独的元素无论如何也不可能受到增益，直接累加即可。

# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e6 + 10;

int n, m; ll k, ans;

ll a[MAXN], b[MAXN];

int main() {
	scanf("%d%d%lld", &n, &m, &k);
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	for (int i = 1; i <= m; i++) scanf("%lld", &b[i]);
	sort(a + 1, a + n + 1, greater<int>());
	for (int i = 1; i <= n && i <= m; i++) ans += a[i] + b[i] + max(a[i], k);
	for (int i = m + 1; i <= n; i++) ans += a[i];
	for (int i = n + 1; i <= m; i++) ans += b[i];
	printf("%lld", ans);
}
```

---

## 作者：Ggsddu_zzy (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P9228)

#### 题目大意

有一个魔法师，她可以用火元素攻击魔法把对附着冰元素的怪物的伤害 $\times 2$，用冰元素攻击魔法把对附着火元素的怪物的伤害 $+k$。

每个怪物初始时没有附着任何元素，给出冰、火元素对每个怪物的初始伤害，魔法师可以任意安排攻击顺序，攻击后清空附着元素，求最大总伤害。

#### 解题思路

首先把初始伤害加到总伤害中。

要求最大总伤害，所以把 $a$ 数组从大到小排序，优先用最大的。

因为每个怪物初始时没有附着任何元素，所以要先给每个怪物附着元素。因为只有对附着着一种魔法的怪物打出另一种魔法才会产生更多的伤害，所以每个怪物要消耗两种不同的元素（附着一种，对其伤害一种），所以产生更多的伤害的元素攻击最多有 $\min(n,m)$ 次。

枚举排好序的 $a$ 序列。不管是 $a_i + a_i$ 还是 $b_i+k$，对后面都是没有影响的，所以直接选择 $\max(a_i,k)$。即：

$$
\sum\limits_{i=1}^{\min(n,m)}\max(a_i,k)
$$

最后不要忘记要把初始伤害加上。

#### 代码

[AC 记录](https://www.luogu.com.cn/record/134488312)

```c++
#include<bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;
ll n,m,k,ans=0;
ll a[1000005],b[1000005];
bool cmp(ll x,ll y){
	return x>y;
}
int main() {
	cin>>n>>m>>k;
	for(ri i=1;i<=n;i++)cin>>a[i];
	for(ri i=1;i<=m;i++)cin>>b[i];
   for(ri i=1;i<=n;i++)ans+=a[i];
	for(ri i=1;i<=m;i++)ans+=b[i];
	sort(a+1,a+n+1,cmp);
	int sum=min(n,m);
	for(ri i=1;i<=sum;i++)
		ans+=max(a[i],k);
	cout<<ans;
	return 0;
}
```

---

## 作者：无钩七不改名 (赞：5)

~~讲个笑话，考场数组少开了一个 0 ，直接扣去 60pts。~~

其实就是每 $2$ 次不同属性的攻击为一组，剩下的同一类型没有可以捆绑的不同攻击单独攻击。那么问题就转换成捆绑的攻击哪个在前（无加成），哪个在后（有加成）。

可以发现，不管 $b$ 组哪个攻击被放到后面，都是加 $k$ 点伤害，所以哪些 $b$ 组攻击被捆绑其实并不重要。

而 $a$ 组伤害高的必定优先捆绑（因为多出的伤害就是它本身的值）。于是我们可以对 $a$ 数组进行从大到小的排序，进行简单的贪心：对 $a$ 组可以捆绑的数从大到小枚举，如果该数大于等于 $k$，则一定可以放在响应组捆绑的后面一位（因为加成比较高），否则跳出循环。因为后面的数也一定是放在前面的。

如果提前跳出循环，那么需要加上 未捆绑的组数（即需要捆绑的组数 减去 循环中已确定的 $a$ 组在后的组数）$\times k$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

int T,n,m,k;
long long a[1000005],b[1000005],ans;

int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		ans+=a[i];
	}
	for(int i=1;i<=m;i++){
		scanf("%d",&b[i]);
		ans+=b[i];
	}
	sort(a+1,a+1+n);
	int x=0;
	for(int i=n;i>max(0,n-m);i--){
		if(a[i]>=k)ans+=a[i];
		else{
			x=i;
			break;
		}
	}
	if(x)ans+=1ll*(min(m,n)-n+x)*k;
	printf("%lld",ans);
	return 0;
} 
```

~~不开 long long 见祖宗，考场对着大样例调了半天真的会谢。不过最后没想到 RE 了，每次模拟赛都逃不开 RE 的诅咒 hh~~

---

## 作者：0x282e202e2029 (赞：3)

# P9228 原神 题解
蒟蒻的第三篇题解……

[老规矩，题目传送门](https://www.luogu.com.cn/problem/P9228)

## 思路
【注意】以下是蒟蒻比赛时的思路。

考虑每一次攻击，对于 $a_n$ 而言，每次攻击增益为 $a_n$。而对于 $b_n$ 而言，每次攻击增益为 $k$。因此，我们需要挑选其中最值得的攻击来增加增益，才能取得最大总伤害。

那么，怎么选择其中最值得的攻击呢？蒟蒻的想法是：

首先，万能`sort`。

接着，我们用两个指针，分别指到 $a$ 与 $b$ 数组中。其中，指到 $a$ 数组的指针指到其最大元素，每次都比较他们分别的增益，直到 $a_n$（$a_n$ 的增益）比 $k$（$b_n$ 的增益）小为止，最后再算出 $b$ 数组多余的增益，一共为 $\min(l, m - r + 1) \cdot k$，将其加上，输出，就 AC 了。

注意 ans 要用`long long`存储。

## AC 代码（比赛时）
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, a[1000005], b[1000005];
long long ans;
int read()
{
	char ch = getchar();
	int x = 0, f = 1;
	while(ch < '0' || ch > '9')
	{
		if(ch == '-')
		{
			f = -1;
		}
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
int main()
{
	n = read(), m = read(), k = read();
	for(int i = 1; i <= n; i++)
	{
		a[i] = read();
		ans += (long long)a[i];
	}
	for(int i = 1; i <= m; i++)
	{
		b[i] = read();
		ans += (long long)b[i];
	}
	sort(a + 1, a + n + 1);
	sort(b + 1, b + m + 1);
	int l = n, r = 1;
	while(l >= 1 && r <= m)
	{
		if(a[l] < k)
		{
			break;
		}
		ans += (long long)a[l];
		l--, r++;
	}
	ans += 1ll * min(l, m - r + 1) * k;
	cout << ans;
	return 0;
}
```
其实，上面代码可以去除`sort(b + 1, b + m + 1);`的内容，不过是比赛当时写出来的，留着做纪念吧。

---

## 作者：I_will_AKIOI (赞：2)

当年写题解晚交了一步，如今又开题解，交一发题解，看一下我当年到今天的巨大变化。

一看题目是我们喜欢的原神，信心大增。然后看题目。

为了使伤害最大，我们必须最大化伤害次数，也就是元素进行 $\min(n,m)$ 次反应。由于 $k$ 是不变的，但是我们可以调整 $a_i$。所以我们将 $a$ 数组从大到小排序，将 $b$ 数组从小到大排序。也就是用小伤害换大伤害。

接下来我们来贪心计算怎么使伤害最大。如果先用火元素，再用冰元素，伤害是 $a_i+b_i+k$。反过来，伤害就是 $2a_i+b_i$。也就是说只要比较 $a_i$ 和 $k$ 的大小就行了。

别忘了最后还有多余的元素，需要全部打出。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,k,a[1000001],b[1000001],ans;
bool cmp(int a,int b) {return a>b;}
signed main()
{
  ios::sync_with_stdio(0);
  cin>>n>>m>>k;
  for(int i=1;i<=n;i++) cin>>a[i];
  for(int i=1;i<=m;i++) cin>>b[i];
  sort(a+1,a+n+1,cmp);//大伤害对小伤害
  sort(b+1,b+m+1);
  for(int i=1;i<=min(n,m);i++)
  {
	if(a[i]<k)//贪心选择先后顺序
	{
	  ans+=a[i];
	  ans+=b[i]+k;
      //冰元素打火元素
	}
	else
	{
	  ans+=b[i];
	  ans+=a[i]<<1;
      //火元素打冰元素
	}
  }
  for(int i=min(n,m)+1;i<=max(n,m);i++)
  {
  	if(n<m) ans+=b[i];
  	else ans+=a[i];
    //统计剩下的元素
  }
  cout<<ans;
  return 0;
}
```

---

## 作者：_O_v_O_ (赞：1)

~~原神，启动！~~

贪心好题。

首先，我们能证明，最多只能产生 $\min(n,m)\times 2$ 次反应，每次反应必须是打出一个 $a$ 或 $b$，再打出另一个。

其次，我们能发现：$a$ 一定从大到小打出，这样 $\times2$ 的反应才能发挥最好。

那么，把 $a$ 从大到小排序后，就能得出最后的伤害为：

$$\sum\limits_{i=1}^{\min(m,n)}\max(a_i\times2+b_i,a_i+b_i+k)+\begin{cases}\sum\limits_{m+1}^{n}a_i& n>m\\\sum\limits_{n+1}^{m}b_i& n<m\end{cases}$$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int n,m,k,ans;
int a[1000005];
int b[1000005];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(nullptr);
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		cin>>b[i];
	}
	sort(a+1,a+n+1,greater<int>());//利用 std::greater<int>() 排序。
	int mn=min(n,m),mx=max(m,n);
	for(int i=1;i<=mn;i++){
		ans+=max(a[i]+b[i]+k,a[i]*2+b[i]);
	}
	for(int i=mn+1;i<=mx;i++) ans+=a[i]+b[i];
	cout<<ans;
	return 0;
}
```

---

## 作者：cppcppcpp3 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P9228)。

## Solution

贪心。

要最大化总伤害，就是要最大化附着的伤害。

我们发现，最优策略一定会把冰与火魔法尽量轮流使用。这样每使用 $1$ 个冰魔法和 $1$ 个火魔法，就可以取得一次最大伤害。从反面说，如果先放了 $i$ 个同种魔法，在使用一个不同种类的魔法，用了 $i+1$ 次魔法，最终的附加伤害仍只有一次，显然劣于轮流使用的安排方式。

既然已经知道冰与火魔法要组成一对进行放置，那么附加伤害最大为 $\max(k,a_i)$。又为了使能够搭配成一对的 $a_i$ 尽量大，对 $a$ 从小到大排序，从第 $n$ 个往前尝试配对即可。

最后加上初始伤害就是答案。复杂度线性。

## Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline
using namespace std;
const int N=1e6+5;
const int inf=1e9+7;

il int wrd(){
	int x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-48;c=getchar();}
	return x*f;
}

int a[N],b[N],n,m,k,ans;

main(){
	n=wrd(),m=wrd(),k=wrd();
	for(int i=1;i<=n;++i) ans+=(a[i]=wrd());
	for(int i=1;i<=m;++i) ans+=(b[i]=wrd());
	
	sort(a+1,a+n+1);
	
	for(int i=n,j=m;i&&j;--i,--j) ans+=max(a[i],k);
	return printf("%lld",ans),0;
}
```

---

## 作者：朦胧_XY (赞：1)

### 分析：
对于每次攻击，都有对应的**固定伤害**和**额外伤害**：

- 固定伤害即输入的 $a_i$ 和 $b_i$，是肯定要加入答案的。

- 火元素的额外伤害等于其固定伤害，冰元素的额外伤害等于 $k$。

然而触发额外伤害的条件是冰火元素“配对”使用：若后用火元素攻击，则火元素攻击有额外伤害；若后用冰元素攻击，则冰元素攻击有额外伤害。

因为总共有 $n$ 次火元素攻击和 $m$ 次冰元素攻击，所以冰火元素最多配成 `min(n,m)` 对，即最多使用 `min(n,m)` 次额外伤害。

因为这些额外伤害可以自己选，所以自然地想到了贪心，即能用多少额外伤害就用多少，然后挑伤害多的用。

实现方面，我是把 $a$ 数组排序，从大到小依次加入答案，直到额外伤害次数用完或其固定伤害小于 $k$ （比 $b$ 数组的额外伤害小就不用了），若额外伤害次数有剩余，就把这些次数全用到冰元素攻击上。

时间复杂度瓶颈是排序。


------------
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000006;
int n, m, K, a[N], b[N];
long long ans;
int main(){
	scanf("%d%d%d", &n, &m, &K);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]), ans += a[i];//把固定伤害加入答案
	for(int i = 1; i <= m; i++)
		scanf("%d", &b[i]), ans += b[i];//把固定伤害加入答案
	int tmp = min(n, m);//tmp是最多额外伤害使用次数
	sort(a + 1, a + n + 1);
	for(int i = n; i; i--){
		if(!tmp || a[i] < K) break;//次数用完或额外伤害小于k
		tmp--, ans += a[i];//使用火元素额外伤害
	}
	ans += 1ll * tmp * K;//剩下次数全用到冰元素额外伤害
	printf("%lld", ans);
	return 0;
}
```


---

## 作者：Link_Cut_Y (赞：1)

赛时没有时间写了。回来把题解补上。

[点我看题](https://www.luogu.com.cn/problem/P9228)

很套路了。明显是动态规划或者贪心。

考虑贪心。对于 $a_i$ 和 $b_j$，假如我们只有一个机会使他们进行一次**增强**（也就是题目里面说的反应规则 $2, 3$），很明显，我们肯定会选择反应后增加的更多的一个。换言之，假如 $a_i > k$，我们就会选择 $a_i$ 进行加强。否则选择 $b_j$。

接下来考虑对于 $n, m$，我们至多可以选择 $\min\{n, m\}$ 个元素进行**增强**。加强规则按照上面所述。$k$ 是一个常数，它必然不会变化。因此只需要把 $\{a\}$ 降序排列，从前到后考虑 $a_i$ 就可以了。

初审的时候说要严谨证明。严谨证明没有，这里有个感性理解：

先按照上述规则构造 $\{x_i\}, x \in \{a, b\}$。证明贪心成立的一个套路就是证明交换后不会更优。假设将 $a_i$ 与 $a_j$ 交换（$j < i$ 且 $\{a\}$ 已经降序排列），那么显然结果不会改变。如果 $j > i$，那么结果应该变小，$\Delta^{-} = (a_i - a_j) \times 2$。$\{b\}$ 之间无论如何交换结果仍然不变。

对于 $\{a\}, \{b\}$ 之间的交换，首先会造成原有加强数量减少，其次对于 $j > i$，还会使增强的值变小。而对于 $j < i$ 仅造成增强数量减小，增强值不变。因此原有贪心是正确的。

~~为什么要有证明啊，这对数学白痴太不友好了。~~

最后贴一下核心代码：

```cpp
signed main() {
	scanf("%lld%lld%lld", &n, &m, &k);
	for (int i = 1; i <= n; i ++ )
		ans += (a[i] = read());
	for (int i = 1; i <= m; i ++ )
		ans += (b[i] = read());
	sort(a + 1, a + n + 1, greater<int>());
	for (int i = 1; i <= n && i <= m; i ++ )
		ans += max(k, a[i]);
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：_JF_ (赞：1)

[传送门](https://www.luogu.com.cn/problem/P9228)


赛时因为这个挂了 $84$ 分，痛失 $300$ 的机会。


贪心。


因为每个攻击都是最终都可以取，所以我们要想他这个“额外价值”最大。

一种假的贪心是贪心取当前造成伤害的最大值，但是可能两个点初始相对差很大，但是较小另一个点的额外伤害多，我们应该是取那个额外伤害多的。

比如说 $k=10$ 时 $a$ 为 $9$，$b$ 为 $1$，应该是取 $b$ 而不是 $a$，取 $b$ 造成多 $10$ 点的额外伤害，而 $a$ 只有 $9$ 点。

（尽管当前看起来是 $18>11$ 但是如果我剩下的都不触发技能的话是 $18+1>11+9$ 的，原因是他们原本的“底数” $1+9$ 不变，而选 $b$ 的增加的比选 $a$ 多，所以选 $b$ 优于 $a$）


我们考虑先进行排序。

- 对于一个 $a_i$，取他加上一个蓝色技能，就多出来 $a_i$ 的贡献。

- 对于一个 $b_i$，取他加上一个红色技能，就多出来 $k$ 的贡献。

所以，我们考虑从后往前。

如果当前 $a_i$ 产生出来的贡献 $a_i$ 的大于 $b_i$ 的贡献 $k$，那么我们就先取 $a_i$。带上最小的 $b_i$ （其实带那个都无所谓，因为 $b_i$ 造成的额外贡献相同。）由于造成额外贡献是有次数限制的，每次都要拿上相对的一个技能，所以我们贪心地去拿最大的。

同理，如果 $b_i$ 产生的贡献 $k$ 大于 $a_i$ 的贡献，那我们就拿 $b_i$，同时应该带上最小的 $a_i$，因为越大的 $a_i$，造成的额外贡献就越多，所以我们应该保存更大的 $a_i$，将来让他造成更多的贡献。

找到当前最小，最大的 $a_i$，$b_i$，用双指针维护即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
#define int long long
int a[N],b[N];
signed main()
{
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)   cin>>a[i];
    for(int i=1;i<=m;i++)   cin>>b[i];
    sort(a+1,a+n+1),sort(b+1,b+m+1);
    int l1=1,r1=n,l2=1,r2=m,ans=0;
    while(1){
        if(l1>r1){
            for(int i=l2;i<=r2;i++) ans+=b[i];
            break;
        }
        if(l2>r2){
            for(int i=l1;i<=r1;i++) ans+=a[i];
            break;
        }
        if(a[r1]>k) ans+=(a[r1]*2+b[l2]),r1--,l2++;
        else if(a[r1]<k)    ans+=(a[l1]+b[r2]+k),l1++,r2--;
        else{
            if(a[l1]>=b[l2])    ans+=(a[r1]*2+b[l2]),r1--,l2++;
            else    ans+=(a[l1]+b[r2]+k),l1++,r2--;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：gyyyyx (赞：1)

[题面](https://www.luogu.com.cn/problem/P9228)

以下称元素攻击产生的反应带来的伤害为**附加伤害**。

我们发现对于一个**火魔法**，我们可以**随便**选择一个**冰魔法**在它前或后释放，这样就会产生元素反应，带来**附加伤害**。

并且因为产生元素反应后元素附着会清空，也就是不会影响后续元素继续反应。

那么如果**冰魔法充足**（$m>n$），则只需要对于**每一个火魔法**，都判断一次是在其之前还是之后释放冰魔法，在前则会产生 $a_i$ 的附加伤害，在后则会产生 $k$ 的附加伤害。

也就是这样：

```cpp
for(int i(1);i<=n;++i) ans+=max(a[i],k);
```

那如果**冰魔法不足**，显然**不能满足**所有火魔法**都**发生元素反应。

因为是求最大值，无论什么时候，$a_i$ 变大，答案一定不会减小。

因此只需要让 $a$ 排序，**从大到小**选 $m$ 个来与冰魔法发生元素反应就行了。

其余所有不能发生元素反应直接加上就行。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 1000005
using namespace std;
inline LL read(){
	LL x(0),f(1);char c(getchar());
	while(c<'0'||c>'9'){if(c=='-')f==1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
int n,m;LL k,a[N],ans;
int main(){
	n=read();m=read();k=read();
	for(int i(1);i<=n;++i) ans+=(a[i]=read());
	for(int i(1);i<=m;++i) ans+=read();
	sort(a+1,a+1+n);
	for(int i(n-min(n,m)+1);i<=n;++i) ans+=max(a[i],k);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Pwtking (赞：1)

贪心+排序。

观察到冰攻击到火上和火攻击到冰上都会有伤害加持，所以为了上海更多肯定要尽可能的利用这个特性。因为每次火攻击冰或冰攻击火都会产生属性抵消，所以我们将获两两配对。

因为如果让冰使用伤害加持对于冰本身的伤害无关，而让或火产生伤害加持和火的自身伤害有关，所以我们将火的伤害排序，由伤害高到伤害低扫一遍观察是使用二倍加持火还是将伤害增加 $k$ 使的伤害最高。最后将配对剩余的伤害加上即可。

---


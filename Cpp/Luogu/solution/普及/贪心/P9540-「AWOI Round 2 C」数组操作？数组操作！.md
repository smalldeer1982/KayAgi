# 「AWOI Round 2 C」数组操作？数组操作！

## 题目描述

给定两个长度为 $n$ 的数组 $a,b$ ，将它们合并得到一个长度为 $2\times n$ 的数组 $c$。

设 $a$ 数组第 $i$ 个元素合并后位于 $c$ 数组第 $lb_i$ 个位置，$b$ 数组第 $i$ 个元素合并后位于 $c$ 数组第 $lc_i$ 个位置，合并后需要满足：$lb_1 < lb_2 < ...< lb_{n-1} < lb_n$ 且 $lc_1 < lc_2< ...< lc_{n-1}< lc_n$，即两个数组中元素的相对位置不变。

合并过后，你需要对 $c$ 数组进行下面操作：

1. 变换操作：选择一个区间 $[l,r]$，对于每一个 $i \in [l,r]$，如果 $c_i$ 为 $y$，则将其变成一个不同于 $y$ 的数，否则将其变为 $y$。
2. 翻转操作：选择一个区间 $[l,r]$，翻转该数组区间中的数。此操作**必须刚好**操作 $z$ 次。

请输出最少需要执行多少次变换操作才能使得 $c$ 数组中的数字都为 $y$。 

## 说明/提示

**【样例说明】**

对于样例 $1$，令 $c$ 为 $\{1,1,1,9,45,1,1,9,4,810\}$。

其中 $c_1=a_1,c_2=b_1,c_3=a_2,c_4=b_2,c_5=a_3,c_6=a_4,c_7=b_3,c_8=b_4,c_9=a_5,c_{10}=b_5$。满足要求。

然后翻转区间 $[4,7]$， $c$ 数组变为 $\{1,1,1,1,1,45,9,9,4,810\}$。

接着执行变换操作，将 $[6,10]$ 中的数全部变成 $1$。

所以最少只需要一次变换操作，可以证明没有比该方法更优的策略。

**【数据规模】**

请注意本题特殊的时间限制，并使用更快的 IO 方式。

**本题使用捆绑测试。**

| 子任务编号 | $n\leqslant$ | 特殊性质 | 分值 |
| -----------: | -----------: | -----------: | -----------: |
| $1$ | $5$ | 无 | $20$ |
| $2$ | $10^6$ | $z>n$ | $5$ |
| $3$ | $10^6$ | 特殊性质 A | $10$ |
| $4$ | $10^6$ | $z=0$ | $25$ |
| $5$ | $10^6$ | 无 | $40$ |

特殊性质 A：保证两个数组中的元素都为 $y$ 或都不为 $y$。

对于全部数据，保证 $0 \leqslant y,z \leqslant 10^9$，输入数据全部在 `int` 范围内。

## 样例 #1

### 输入

```
5 1 1
1 1 45 1 4
1 9 1 9 810```

### 输出

```
1```

## 样例 #2

### 输入

```
20 0 3
1 0 0 8 6 10 0 8 6 1 0 0 86 1 0 0 8 6 0 0
5 2 0 1 3 1 4 52 0 13 14 0 1 0 1 0 4 0 5 0```

### 输出

```
4```

## 样例 #3

### 输入

```
3 2 4
110 105 117
99 108 98```

### 输出

```
1```

# 题解

## 作者：Vct14 (赞：7)

显然地，若要对 $c_x$ 进行变换操作，要分类讨论：当 $c_x \ne y$ 时，为了更快的接近目标状态，一定会将 $c_x$ 改成 $y$；当 $c_x=y$ 时，$c_x$ 一定会被改为一个不为 $y$ 的值。

所以，我们将数组中等于 $y$ 的元素染成红色，将不等于 $ y$ 的元素染成蓝色。变换操作就相当于选择一个区间，将区间内的蓝色变为红色，红色变为蓝色。而目标就变为了将数组全部变为红色。

```c++
for(int i=1; i<=n; i++) a[i]=(read()==y);//true 表示红，false 表示蓝
for(int i=1; i<=n; i++) b[i]=(read()==y);//同上
```

先不考虑翻转操作和如何合并，假设合并后 $c$ 数组染色后如图，考虑这种情况下最少需要多少次操作达到目标状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/62w4e8r7.png)

容易发现，这张图至少需要 $4$ 次操作才能达到目标，即将所有蓝色段变为红色。推广到更一般的情况，我们可以发现，最小的操作次数就是蓝色段的个数。

我们先考虑如何让数组 $a,b$ 合并后满足合并要求并统计出蓝色段个数。为了最小化操作次数，就要让蓝色段的数量最少，合并时应该让尽量多的蓝元素挨在一块，让尽量多的红元素挨在一块。

可以发现，执行以下两种操作若干次直到 $a,b$ 为空，可以满足要求：

- 取出 $a$ 的前缀的若干个元素放入 $c$ 数组（后方元素向前移）。
- 取出 $b$ 的前缀的若干个元素放入 $c$ 数组（后方元素向前移）。

意识到这点，我们就得到思路了：

1. 将初始颜色段设为红色段。因为红色在前可以让更多的蓝色挨在一起。
1. 若当前段是蓝色段，蓝色段计数器 $s\gets s+1$。
1. 找到 $a$ 数组的前缀有多少个与该颜色段颜色相同，**全部**放入 $c$ 数组。
1. 找到 $b$ 数组的前缀有多少个与该颜色段颜色相同，**全部**放入 $c$ 数组。
1. 变换为下一段颜色，重复第 $2$ 步。

最终，$s$ 就是合并后最小的蓝色段数量。

```c++
bool now=true;
int c1=0,c2=0,s=0;
while(1){
	if(!now) s++;
	while(a[c1+1]==now && c1+1<=n) c1++;
	while(b[c2+1]==now && c2+1<=n) c2++;
	if(c1==n && c2==n) break;
	now=!now;
}
```

------------

最优的合并策略已考虑，现在考虑最优翻转策略。由于答案是蓝色段的个数，所以翻转操作要让蓝色段数量减少。

![](https://picui.cn/i/2023/08/01/64c92ae2af5ae.png)

我们选择一个红色段的左端点为 $l$，与其相邻蓝色段的右端点为 $r$，将 $[l,r]$ 翻转，就可以减少一个蓝色段了。

于是，我们可以发现，**每一次的翻转都可以减少一个蓝色段**！因此，若需要翻转的次数 $s-1\geqslant z$，只需尽可能减少蓝色段，即翻转 $z$ 次。答案就是 $s-z$。

有人可能有疑问：如果翻转到只剩一个蓝色段后（需要 $s-1$ 次），翻转次数小于 $z$（即 $s-1<z$）怎么办？其实，可以直接进行变换操作将其全部变为红色，答案为 $1$，再不停翻转整个区间 $[1,2n]$。

还有一种特殊情况，就是输入的所有元素都是红元素（$s=0$），直接输出 $0$ 即可。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e6+10;
bool a[N],b[N];

char *p1,*p2,buf[100000];
#define r() (p1==p2 && (p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read(){
    int x=0,f=1;
    char ch=r();
    while(ch<48||ch>57){
        if(ch=='-') f=-1;
        ch=r();
    }
    while(ch>=48 && ch<=57) x=x*10+ch-48,ch=r();
   	return x*f;
}

int main(){
	int n=read(),y=read(),z=read();
	for(int i=1; i<=n; i++) a[i]=(read()==y);
	for(int i=1; i<=n; i++) b[i]=(read()==y);
	bool now=true;
	int c1=0,c2=0,s=0;
	while(1){
		if(!now) s++;
		while(a[c1+1]==now && c1+1<=n) c1++;
		while(b[c2+1]==now && c2+1<=n) c2++;
		if(c1==n && c2==n) break;
		now=!now;
	}
	if(!s) cout<<0;
	else if(s-1>=z) cout<<s-z;
	else cout<<1;
	return 0;
}
```

---

## 作者：Jian_Yu (赞：4)

是**P9540**的题解呢

# 题意

给定两个长度为 $n$ 的数组 $a,b$ ，将它们合并得到一个长度为 $2\times n$ 的数组 $c$，合并后两个数组中元素的相对位置不变。

合并过后，可以对 $c$ 数组进行以下的操作：

1. 选择一个区间 $[l,r]$，对于每一个 $i \in [l,r]$，如果 $c_i$ 等于 $y$，则将其变成一个不是 $y$ 的数，否则将其变为 $y$。
2. 选择一个区间 $[l,r]$，将这个区间前后翻转，这个操作**必须刚好**操作 $z$ 次。

问最少需要执行多少次操作 1 才能使得 $c$ 数组中的数字都为 $y$。

# 解法

首先观察到不同的数字只有等于 $y$ 和不等于 $y$ 两种情况，因此可以将所有等于 $y$ 的数替换为 $1$，所有不等于 $y$ 的数替换为 $0$，方便下面的讨论。

### 只有一个序列的情况：

题目要求**最小化**操作 1 的数量，因为操作 2 没有代价，所以考虑如何通过 $z$ 次操作 2 来减少操作 1 的数量。简单模拟可以发现到操作 1 的数量就是序列中值全部为 0 的连续的数构成的块的数量，因此减少操作 1 的数量的方法就是减少连续块的数量，而减少连续块的数量可以通过将两个分开的块移动至相邻位置来实现。因为只有两种数，所以可以通过翻转来实现移动，具体如下所示：

```
001100110 转化过后的序列，此时需要 3 次操作 1 
000011110 使用操作 2 翻转 [4, 7] 合并其中两个快，减少一次操作 1 的数量
000001111 使用操作 2 翻转 [5, 9] 合并另外两个快，减少一次操作 1 的数量
```

因为可以通过选取长度为 1 的区间来使翻转无效化，所以不用考虑“刚好”的条件，只用考虑最多次数。

综上所述，最终的操作 1 的次数就是 $\mathrm{max}\{\text{块的数量} - z, 1\}$

### 有两个序列的情况：

因为可以像归并排序那样只用注意同一序列之间的相对位置，两个序列之间互不影响，所以合并后块的数量就是合并前两个序列的块的数量的最大值，具体实现方式就是将两个序列的每个块的开头上下对齐，然后合并，如下所示：

```
001100110 
110001100          初始的两个序列

001100 110
  110001100        对齐

0011  00   11  0
    11  000  11 00 分开（这样只是为了看起来直观一点，实际可以直接合起来

001111000001111000 合并
```

所以最终的答案就是 $\mathrm{max}\{\mathrm{max}\{\text{A的块数},\text{B的块数}\}- z, 1\}$

# 代码

```cpp
#include <iostream>
using namespace std;
const int N = 1e6 + 50;

int n, y, z;
int a[N], b[N];

int calc(int f[]){
	// 计算一个序列中块的数量
	int ret = 0; 
	f[0] = 1; // 用来统计出现在开头的块
	for(int i = 1; i <= n; ++i)
		if(!f[i] and f[i-1]) // 如果这里是 0 而且前面是 1
			++ret; // 代表出现了一个块
	return ret;
}

int main(){
	cin >> n >> y >> z;
	for(int i = 1; i <= n; ++i) cin >> a[i];
	for(int i = 1; i <= n; ++i) cin >> b[i];
	// 对序列进行转化
	for(int i = 1; i <= n; ++i) a[i] = a[i] == y ? 1 : 0;
	for(int i = 1; i <= n; ++i) b[i] = b[i] == y ? 1 : 0;
	
	int blockNumA = calc(a), blockNumB = calc(b);
	// 如果两个都没有块需要操作需要特殊判断
	if(blockNumA+blockNumB==0){ 
		cout << 0 << endl;
		return 0;
	}
	
	cout << max(max(blockNumA, blockNumB) - z, 1) << endl;
}
```

---

## 作者：kkxacj (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P9540)

#### 前言
这个蒟蒻因为一个细节调了好久。

#### 思路
考虑让值为 $y$ 的尽可能在一起，值不为 $y$ 的尽可能在一起，就比如这样（样例 $1$）：
![](https://cdn.luogu.com.cn/upload/image_hosting/bcp8u6fh.png)
虽然说这样直接算会得到答案为 $2$，但由于我们可以翻转一次，于是答案为 $1$，所以能想到每翻转一次都可以使答案减一，但前提是我有这么多段连续为 $y$ 的段数，但这里有一个很关键的地方，如果可以的话，**你应该先把一段连续的值等于 $y$ 的放在最前面**，因为如果它在中间，就有可能导致左边和右边都是一段连续的值不等于 $y$ 的数，可能会导致答案错误（因为我一直 wa $4$ 个点）。

code

```
#include<bits/stdc++.h>
using namespace std;
long long n,y,z,a[1000010],b[1000010],l1,c[3000010],o = 1,o1 = 1,o2,oo,p,pp = 1,sum;//把pp赋值为1，要先把一段连续的值等于 $y$ 的放在最前面
int main()
{
	cin >> n >> y >> z;
	for(int i = 1;i <= n;i++) scanf("%lld",&a[i]); 
	for(int i = 1;i <= n;i++) scanf("%lld",&b[i]);
	for(int i = 1;i <= n * 2;i++) 
	{
		if(pp == 1)
		{
			if(a[o] == y && o <= n) 
			{
				c[++o2] = a[o],o++,pp = 1;
				continue;
			}
			else if(b[o1] == y && o1 <= n)
			{
				c[++o2] = b[o1],o1++,pp = 1;
				continue;
			}
		}
		if(a[o] != y && o <= n) c[++o2] = a[o],o++,pp = 0;
		else if(b[o1] != y && o1 <= n) c[++o2] = b[o1],o1++,pp = 0;
		else if(a[o] == y && o <= n) c[++o2] = a[o],o++,pp = 1;
		else if(b[o1] == y && o1 <= n)c[++o2] = b[o1],o1++,pp = 1;
	}
	for(int i = 1;i <= n * 2;i++) 
	{
		if(c[i] != y) oo++;
		else
		{
			sum++;
			if(oo) p++;//p为有几段连续的值不等于 $y$ 
			oo = 0;
		}
	}
	if(sum == n * 2)//全是y，不需要修改，直接输出0 
	{
		cout << 0;
		return 0;
	}
	if(oo) p++; 
	cout << max(p - z,1ll);//至少操作一次
	return 0;
}
```




---

## 作者：DecemberFox (赞：3)

# P9540 题解

## 题目分析

本题的大致意思是给定两个长度为 $n$ 的数组 $a,b$，将它们合并为一个长度为 $2\times n$ 的数组 $c$，并且保证两个数组中元素的相对位置不变。

合并完成后，再对其进行以下两种操作：

1. 变换操作：选择一个区间 $[l,r]$，对于每一个 $i \in [l,r]$，如果 $c_i$ 为 $y$，则将其变成一个不同于 $y$ 的数，否则将其变为 $y$。
2. 翻转操作：选择一个区间 $[l,r]$，翻转该数组区间中的数。此操作**必须刚好**操作 $z$ 次。

要求通过最少次数的变换操作使得 $c$ 数组中的数全部变为 $y$。

## 解法分析

由于一次变换操作只能修改一个区间，所以要将一个数组全部变为 $y$，就需要依次对每一个区间进行修改，修改的次数很明显就是需要修改的区间数量了。

为了最小化变换操作的次数，我们就要减少需要修改的区间的数量，这里可以通过两个方式减少其数量：

1. 通过翻转操作合并两个区间，每次减少 $1$ 个区间数量。

2. 通过合理方式合并 $a,b$ 数组，使需要修改的区间尽量少。

### 翻转操作

注意到翻转操作一定是可以将两个区间合并为 $1$ 个区间的，例如下面的序列：


```
1 1 4 1 9 1
```

可以通过翻转 $[2,3]$ 合并两个区间，因此，翻转操作可以减少 $z$ 个区间，间接减少了 $z$ 次变换操作。

如果还有多余的翻转操作，完全可以在不影响答案的前提下使用掉。

### 合并

为了使需要修改的区间尽量少，我们就需要将同一类的区间放在一起。

由于要保证两个数组中元素的相对位置不变，可以使用类似于归并排序合并两个数组的方式合并。

但事实上可以不用求出数组 $c$，数组 $a,b$ 对应顺序的区间也可以合并在一起，所以只需要求出数组 $a,b$ 分别有多少个区间再取最大值即可知道数组 $c$ 有多少个需要修改的区间了。

最后将合并得出的区间数量减去翻转可以减少的区间数量就可以得到答案了，同时注意相减的答案不能小于 $1$ 以及判断数组 $a,b$ 全为 $y$ 的情况就可以完美地通过这道题了。

## 代码
```cpp
#include<iostream>
#include<cstdio>
namespace io
{
	void read()
	{
		return;
	}
	template<typename nowtype,typename ...nexttype>
	void read(nowtype &now,nexttype &...next)
	{
		register char c=getchar();
		register int n(1);
		now=0;
#define isdigit(c) ((c)>='0'&&(c)<='9')
		while(!isdigit(c)){if(c=='-') n=-1;c=getchar();}
		while(isdigit(c)){now=(now<<1)+(now<<3)+(c^48);c=getchar();}
#undef isdigit
		now*=n;
		read(next...);
	}
	template<typename type>
	inline void write(type num,char end='\n')
	{
		unsigned long long unum(0);
		if(num<0)
		{
			putchar('-');
			unum=-num;
		}
		else unum=num;
		register int c[35],top(0);
		do c[top++]=unum%10,unum/=10;while(unum);
		while(top) putchar(c[--top]+48);
		putchar(end);
	}
}
//以上为快读和快写
namespace SOLVE
{
	const int const1=1e6+10;
	int a[const1],b[const1];
	void solve()
	{
		int i,n,y,z,apart(0),bpart(0);
		io::read(n,y,z);
		a[0]=b[0]=y;
		for(i=1;i<=n;++i)
		{
			io::read(a[i]);
			if(a[i]!=y&&a[i-1]==y) ++apart;//计算数组 a 的区间数量
		}
		for(i=1;i<=n;++i)
		{
			io::read(b[i]);
			if(b[i]!=y&&b[i-1]==y) ++bpart;//计算数组 b 的区间数量
		}
		if(apart+bpart==0) io::write(0);//判断特殊情况
		else io::write(std::max(std::max(apart,bpart)-z,1));
	}
}
int main()
{
	SOLVE::solve();
	return 0;
}
```

---

## 作者：Field_Mouse (赞：2)

**题意简述：**

给定两个序列，将其不改变相对位置地合并起来，全部变换为给定值 $y$，并且必须进行 $z$ 次翻转，求最小变换次数。

**分析**

不难发现，对于每个变换操作，最好的策略自然是将连续的几个值统一变为 $y$，即要求对于子串 $ [l,r] $ 均非 $y$ 的最小个数。

我们贪心的去想，发现可以让不是 $y$ 的数尽量的连在一起，这个在合并中去处理。

接下来是翻转操作。可以发现，这里的 $z$ 并不是如题面所说的必须有 $z$ 次翻转操作，而是最多有 $z$ 次翻转操作。因为我们翻转一个数或者完全相同的几个数构成的子序列和不翻转是一样的。

对于每一次翻转操作可以将两个不连通的均非 $y$ 的序列连通，即将答案减去  $1$。

总结思路，就是贪心合并后统计均非 $y$ 的子串个数，再减去我们可以进行的翻转操作次数。

**代码如下**

```
#include<bits/stdc++.h>
#define AC return 0;
#define sc(n) scanf("%lld",&(n))
#define pr(n) printf("%lld",(n))
#define hh puts("")
#define N 1000005
#define int long long 
using namespace std;
int a[N],b[N],c[N*2],d[N*2];
int _max(int a,int b)
{
	return a>b?a:b;
}
signed main()
{
	int n,y,z;
	sc(n);sc(y);sc(z);
	int k=0;
	for(int i=1;i<=n;i++)
	{
		sc(a[i]);
		if(a[i]!=y)k=1;
	}
	for(int i=1;i<=n;i++)
	{
		sc(b[i]);
		if(b[i]!=y)k=1;//统计是否全部为同一个数以特判
	}
	if(k==0)
	{
		puts("0");
		AC
	}
	int sum=0;
	int q=0,p=0,tot=0;
	while(q+1<=n||p+1<=n)
	{
		int flag=0;
		while(a[q+1]==y&&q+1<=n)
		{
			q++;
			c[++tot]=a[q];
		}
		while(b[p+1]==y&&p+1<=n)
		{
			p++;
			c[++tot]=b[p];
		}
		while(a[q+1]!=y&&q+1<=n)
		{
			q++;
			c[++tot]=a[q];
			flag=1;
		}
		while(b[p+1]!=y&&p+1<=n)
		{
			p++;
			c[++tot]=b[p];
			flag=1;
		}//贪心的合并

		if(flag)++sum;//这里是统计上文所说的连通块个数
	}//注意，这里不是统计联通的y，蒟蒻在这里调了半天
    int	ans=_max(1,sum-z);//不管怎么翻转，最后至少剩余一个连通块
	pr(ans);
	AC
}
```


---

## 作者：Special_Tony (赞：2)

[题目传送门](/problem/P9540)
# 思路
刚看到这题，无从下手，怎么办？看看部分分。但是写部分分却对想到正解有作用。

首先，我们看看特殊性质 A。所有数字都 $=y$ 或所有数字都 $\ne y$，那现在翻转操作是没用的，但题目要求我们要必须刚好操作 $z$ 次，所以我们只要随便翻转一下，把这 $z$ 次浪费掉即可。我们对所有数字都 $=y$ 的情况不用操作，输出 $0$，而对所有数字都 $\ne y$ 的情况统一做一次变换操作即可，输出 $1$。

我们再看看 $z>n$ 的情况。对于每次翻转，我们可以把两块**连续**的 $\ne y$ 的部分合并到一起。如果 $z>n$，那么所有 $\ne y$ 的数字将会被合到一起，这样我们只要看是不是所有数字都是 $y$ 即可，如果是的，那输出 $0$，否则输出 $1$。

当 $z=0$ 时，这时候我们要考虑合并了。要使合并最优，当然是把所有 $=y$ 的数字尽可能放一起，所有 $\ne y$ 的数字尽可能放一起。只有变换操作，那我们只要把所有 $\ne y$ 的连续数字块一起变换即可，所以我们只要统计 $\ne y$ 的连续块个数就好了。

最后，部分分都想完了，正解也就出来了。因为每次翻转操作会把两块 $\ne y$ 的连续块连一起，连续块个数也就减少了 $1$，所以正解只要在 $z=0$ 的方法的基础上，把 $\ne y$ 的连续块个数减掉 $z$ 就好了。需要注意的是，如果把 $\ne y$ 的连续块个数减掉 $z$ 后答案不足 $1$ 了，那这个问题就转化成了 $z>n$ 的情况，所以要把答案和 $1$ 取 $\max$。还有，当所有数都是 $y$ 的时候，我们不需要操作，所以只要输出 $0$ 就可以了，这个特判一下就好了。
# 代码
```cpp
# include <bits/stdc++.h>
using namespace std;
int n, y, z, a[2000005], ans, ans2;
bool f = 1; //记录是否有 != y 的元素
int main () {
	cin >> n >> y >> z;
	for (int i = 0; i < n; ++ i)
		cin >> a[i];
	for (int i = 0; i < n; ++ i)
		cin >> a[i + n];
	for (int i = 0; i < n << 1; ++ i)
		if (a[i] != y) {
			f = 0;
			break ;
		}
	if (f) { //特判
		cout << 0;
		return 0;
	}
	for (int i = 1; i < n; ++ i)
		if (a[i] == y && a[i - 1] != y) //算连续块
			++ ans;
	if (a[n - 1] != y) //最后一个块别忘记
		++ ans;
	for (int i = n + 1; i < n << 1; ++ i)
		if (a[i] == y && a[i - 1] != y)
			++ ans2;
	if (a[n * 2 - 1] != y)
		++ ans2;
	cout << max (1, max (ans, ans2) - z); //取个 max
	return 0;
}
```

---

## 作者：zxh923 (赞：2)

# P9540 「AWOI Round 2 C」数组操作？数组操作！ 题解

### 思路

比赛时我一时没有想到很好的思路，就开始观察样例。

然后我就想到，翻转是不是能够减少不满足要求的块数。

我们可以得出，如果一个数组中有若干组连在一起的 $y$，到新数组后数量一定也不会变。因为中间的元素不会凭空消失。

而且显而易见，我们按照最优方案把元素放入新数组后，如果有 $k$ 组连在一起的不满足要求的元素，我们必须要做 $k$ 次操作才行。

那怎么证明新数组中连在一起的 $y$ 的数量就是原来数组中具有连在一起的 $y$ 更多的那一个的数量呢？

其实我们只需要把两边的这种元素一组配一组，最后新数组中的数量一定就是原来数组中具有连在一起的 $y$ 更多的那一个的数量。

并且，我们对合适的区间翻转一次是可以减少一个不满足要求的组的，但操作数不能为 $0$，所以我们应将它和 $1$ 取最大值，特判不用操作即次数为 $0$ 的情况即可。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,y,z,a[1000005],b[1000005],ca,cb,maxx;
bool flag=1;
int main(){
	cin>>n>>y>>z;
	a[0]=b[0]=y;//把最前面设为y，否则统计a[1],b[1]时会出错
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]!=y)flag=0;
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		if(b[i]!=y)flag=0;
	}//flag用于特判数组中是不是全是y
	if(flag){//特判不用操作的情况
		cout<<0;//0次操作就输出0
		return 0;
	}
	for(int i=1;i<=n;i++){
		if(a[i]!=y&&a[i-1]==y)ca++;//如果这是一个不满足要求的区间
		if(b[i]!=y&&b[i-1]==y)cb++;//我们把计数器增加
	}
	maxx=max(ca,cb);//最后新数组中的数量一定就是原来数组中具有连在一起的y更多的那一个的数量
	maxx=max(maxx-z,1ll);//和1取最大值，因为前面已经特判了0
	cout<<maxx;
	return 0;
}
```


---

## 作者：渡鸦2007 (赞：1)

## 题面分析
根据询问出题人，我们得知，翻转操作的区间 $[l,r]$，当 $l=r$ 时是可取的。故翻转次数 $t$ 实际上只要 $0\le t \le z$ 即可，"必须刚好操作 $z$ 次"实际上是干扰条件。

下面将数组中每个元素都不是 $y$ 且极长的子区间称为“连续不等区间”。

显然，翻转结束后，对于数组 $c$，连续不等区间数（记为 $d$）就是变换操作的最小步数。
## 合并部分
首先考虑数组 $a$ 和 $b$ 元素的合并方式。由上，我们要让连续不等区间数尽量小，那么我们要让 $a$ 和 $b$ 中连续不等区间尽量合并起来。

可以证明，合并后 $d=\max(d_a,d_b)$，其中 $d_a,d_b$ 分别是 $a,b$ 数组的连续不等区间数。这是因为，不妨设 $d_a<d_b$，那么我们可以在合并过程中将 $a$ 的每一段连续不等区间都与 $b$ 的对应段连续不等区间合并。
## 翻转部分
接下来考虑翻转操作。显然，每翻转一次，可以合并两个连续不等区间。证明如下：

若连续不等区间数 $\ge2$，记为区间 $[l_1,r_1],[l_2,r_2]$，其中 $r_1<l_2$，则翻转区间 $[l_1,l_2-1]$，这样两个连续不等区间便合并为区间 $[l_2-1-(r_1-l_1),r_2]$。
## 答案部分
综上所述，若 $z\ge d-1$，最终只会剩余一段连续不等区间，答案为 $1$。若 $z<d-1$，只能减少 $z$ 段连续不等区间，答案为 $d-z$。
特别的，若 $d=0$，答案为 $0$。
## 代码部分
时间、空间复杂度均为 $O(n)$，以下代码用时 $108ms$，暂时是本题最优解。
```cpp
int a[1000100],b[1000100];
bool flag=0;int d_a=0,d_b=0;int n,y,z;
void pre();
int main()
{
	
	n=read();y=read();z=read();
	pre();
	if (d_a==0 && d_b==0) 
	{
		puts("0");
		return 0;
	}
	cout<<max(max(d_a,d_b)-z,1);
	return 0;
}
void pre()
{
	for (int i=1;i<=n;++i)
	{
		a[i]=read();
		if (flag && a[i]==y)
		{
			flag=0;++d_a;
		}
		if (!flag && a[i]!=y)
		{
			flag=1;
		}
	}
	if (flag) ++d_a;
	flag=0;
	
	for (int i=1;i<=n;++i)
	{
		b[i]=read();
		if (flag && b[i]==y)
		{
			flag=0;++d_b;
		}
		if (!flag && b[i]!=y)
		{
			flag=1;
		}
	}
	if (flag) ++d_b;
}
```


---

## 作者：Nuyoah_awa (赞：1)

### 题目大意

两个数组，将其按顺序合并为一个数组，这个数组经过 $z$ 次翻转操作后最少经过几次变换操作可以可以使所有元素都为 $y$。

### 题目分析

主要突破口在变换操作，所有数不能换位原数，也就是说所有原来为 $y$ 的元素不能经过变换操作。

对于其他数，只需经过一次变换操作即可变为 $y$，于是我们想数组 $c$ 可以以 $y$ 划分为多个区间，经历过 $z$ 次翻转后尽可能合并一些区间，对于剩下每个区间做一次变换操作即可。

然后考虑如何构成 $c$ 可以使变换操作尽可能少，很明显，我们要使互不相邻的 $y$ 尽可能少，也就是说所有的 $y$ 尽可能的挨着，我们不妨也将 $a,b$ 以连续的 $y$ 划分为多段，将段数少的每一段一次插入段数多的数组的相应段中，从而构成 $c$。

形象的来讲就是将 $a,b$ 化为：

$$\underbrace{a_1, \dots,  a_{i}}_{a'_1}, \underbrace{a_{i+1}, \dots, a_j}_{a'_2 = y}, \cdots, \underbrace{a_{k+1}, \dots a_{n}}_{a'_m}$$

$$\underbrace{b_1, \dots,  b_i}_{b'_1}, \underbrace{b_{i+1}, \dots, b_j}_{b'_2 = y}, \cdots, \underbrace{b_{k+1}, \dots b_{n}}_{b'_l}$$

不妨设 $l\le m$，合并为 $c$ 即：

$$c = a'_{1}, b'_{1}, a'_{2}, b'_{2}, \cdots a'_{l}, b'_{l}, a'_{l+1} \cdots a'_{m}$$

容易看出，$c$ 一共分为 $m$ 段。

然后我们再来看每次翻转，至多将两段合并，所以最终段数为 $m - z$，我们对于每段进行变换操作，$m - z$ 即为答案，如 $z \ge m$，则答案为 $1$，因为我们最终只能翻转为一段，总归是要进行变换操作的。

特别的，如所有数均为 $y$，则不需进行变换操作，答案为 $0$。

所以想明白以后时间复杂度是线性的。

### code
```cpp
#include <iostream>
#include <cstdio>
#include <stack>
#include <map>
using namespace std;
const int N = 1e6 + 5;
int n, y, z, a[N], b[N], ans, x1, x2, sum;
signed main()
{
	scanf("%d %d %d", &n, &y, &z);
	for(int i = 1;i <= n;i++)
		scanf("%d", &a[i]);
	for(int j = 1;j <= n;j++)
		scanf("%d", &b[j]);
	
	for(int i = 1;i <= n;i++)
	{
		if(a[i] == y)
			sum++;
		if(b[i] == y)
			sum++;
	}
	if(sum == n + n)
	{
		printf("0");
		return 0;
	}	//特判0的情况
	int i = 1, j = 1;
	while(i <= n && a[i] != y)
		i++;
	if(i != 1)
		x1++;
	while(i <= n)
	{
		while(i <= n && a[i] == y)
			i++;
		if(i <= n && a[i] != y)
			x1++;
		while(i <= n && a[i] != y)
			i++;
	}
	while(j <= n && b[j] != y)
		j++;
	if(j != 1)
		x2++;
	while(j <= n)
	{
		while(j <= n && b[j] == y)
			j++;
		if(j <= n && b[j] != y)
			x2++;
		while(j <= n && b[j] != y)
			j++;
	}	//计算a,b的段数
	printf("%d", max(1, max(x1, x2) - z));	//核心式子
	return 0;
}
```

---

## 作者：HEIMOFA (赞：1)

由于合并出来的 $c$ 数组不会改变数之间的相对位置，所以先研究 $c$ 数组。

对于 $c$ 数组分为两个部分，一部分是等于 $y$ 的，一部分是不等于的。

如果不考虑翻转，现在所需要的变换操作就是不等于 $y$ 的连续段的个数。

举个例子，我们知道样例一最后的 $c$ 数组为 ${1,1,1,9,45,1,1,9,4,810}$，那么变换操作就是两次。

要让操作数尽可能小，就需要使用翻转操作，对于每一次翻转，可以把等于 $y$ 的子段和与之相邻的不等于 $y$ 的子段进行翻转，这样便可以把两个不等于 $y$ 的子段拼在一起，从而减少一次操作，而 $z$ 次翻转最多便可以减少 $z$ 次操作。

接着考虑如何拼出一个 $c$ 数组，根据上面的分析，很容易看出我们需要尽可能让等于 $y$ 的子段在一起，而又不能破坏相对位置。

双指针可以搞定。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,y,z;
const int N=1e6+5;
int a[N],b[N];

signed main()
{
	scanf("%lld%lld%lld",&n,&y,&z);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&b[i]);
	int i=1,j=1;
	int flag=1,sum=0;
	while(i<=n||j<=n){
		if(flag==0) sum++;
		while((a[i]==y)==flag&&i<=n) i++;
		while((b[j]==y)==flag&&j<=n) j++;
		flag^=1;
	}
	if(!sum) return printf("0"),0;//特判，如果根本就没有不等于 $y$ 的部分，直接返回0
	if(sum>z) return printf("%lld",sum-z),0;
	printf("1");
	return 0;
}

```

---

## 作者：zwyyy (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P9540)

~~我赛时切了这道但没切 B，我真是太蒻了~~

## 思路
这道题在我看来是一道结论题。

首先分类讨论。

1. 由于合成后的数组里的元素顺序和原数组不变，所以当合成前与合成后的数组中不为 $y$ 的数都相邻的时候（即第一个非 $y$ 的数和最后一个非 $y$ 的数之间没有 $y$）我们只需要 $1$ 次交换即可使 $c$ 数组里的数字都为 $y$；

2. 但是当第一个非 $y$ 的数和最后一个非 $y$ 的数之间有 $y$ 时，我们就需要运用到翻转操作了。我们可以这样认为：一次翻转操作就是使两串由非 $y$ 的数字合成的字符串合并为一串。

由于每串由非 $y$ 的数字合成的字符串都需要一次变换操作，所以我们可以统计第一个非 $y$ 的数和最后一个非 $y$ 的数之间的 $y$ 的个数，减去翻转的操作数 $z$ 再加上最后一次的整体变换操作得出答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
int a[N], b[N];
int afyk, afyj, bfyk, bfyj, nay, nby, ny;
int main(){
	int n, y, z;
	scanf("%d%d%d", &n, &y, &z);
	for(int i = 1; i <= n; ++i){
		scanf("%d", &a[i]);
		if(a[i] != y){
			afyj = i;
			if(afyk == 0){
				afyk = i;
			}
		}
	}
	if(afyk == 0){
		printf("0");
		return 0;
	}
	for(int i = afyk; i <= afyj; ++i){
		if(a[i] == y && a[i - 1] != y){
			++nay;
		}
	}
	for(int i = 1; i <= n; ++i){
		scanf("%d", &b[i]);
		if(b[i] != y){
			bfyj = i;
			if(bfyk == 0){
				bfyk = i;
			}
		}
	}
	if(bfyk == 0){
		printf("0");
		return 0;
	}
	for(int i = bfyk; i <= bfyj; ++i){
		if(b[i] == y && b[i - 1] != y){
			++nby;
		}
	}
	ny = max(nay, nby);
	//printf("%d %d %d\n%d %d %d\n%d\n", afyk, afyj, nay, bfyk, bfyj, nby, ny);
	if(z > ny){
		printf("1");
		return 0;
	}
	ny -= z;
	printf("%d", ny + 1);
	return 0;
}
```

[AC](https://www.luogu.com.cn/record/121065553)

---

## 作者：modfisher (赞：0)

## 思路
对于每一个 $c$ 数组，如果我们以元素 $y$ 为界将其分割成了 $k$ 块，那么至少需要 $k$ 次变换操作才能达到题目要求。

考虑通过一系列翻转操作，来最小化 $k$ 的值。

先来构造一个合适的 $c$ 数组。这个简单，依次将 $a$ 中的 $y$、$b$ 中的$y$、$a$ 中的非 $y$ 元素、$b$ 中的非 $y$ 元素循环往复地加入 $c$ 即可。

可能不太好理解，你可以等会看看代码。

接着，不难发现，每一次翻转操作都可以且仅可以将两个 $y$ 连通块合并。

例如：$\{1,2,2,2,3,3,2,1,2,2,2,1,2,2,2,2\}$，其中 $y=2$。

如果翻转区间 $[9,12]$，原数组变为 $\{1,2,2,2,3,3,2,1,1,2,2,2,2,2,2,2\}$，$y$ 连通块减少 $1$ 个。

如果翻转区间 $[7,12]$，原数组变为 $\{1,2,2,2,3,3,1,2,2,2,1,2,2,2,2,2\}$，$y$ 连通块减少 $1$ 个。

所以，$z$ 次翻转操作可以减少至多 $z$ 个 $y$ 连通块，最终剩余的最少 $y$ 连通块数量为 $\max(z-k,1)$。

$y$ 连通块数量出来了，变换操作数自然也出来了，在此不再赘述。

注意，全是 $y$ 的情况要特判一下。

## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e6 + 5;

int a[maxn], b[maxn], c[maxn << 1];

int main(){
	int n, y, z;
	scanf("%d %d %d", &n, &y, &z);
	for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i ++) scanf("%d", &b[i]);
	int ii = 1, jj = 1, kk = 0;
	while(ii <= n && jj <= n){
		while(ii <= n && a[ii] == y){
			c[++ kk] = a[ii];
			ii ++;
		}
		while(jj <= n && b[jj] == y){
			c[++ kk] = b[jj];
			jj ++;
		}
		while(ii <= n && a[ii] != y){
			c[++ kk] = a[ii];
			ii ++;
		}
		while(jj <= n && b[jj] != y){
			c[++ kk] = b[jj];
			jj ++;
		}
	}
	while(ii <= n) c[++ kk] = a[ii ++];
	while(jj <= n) c[++ kk] = b[jj ++];
	int ans = 0, aa = c[1] == y, bb = c[n * 2] == y;
	bool fl = true;
	c[n * 2 + 1] = c[n * 2];
	for(int i = 1; i <= n * 2; i ++){
		fl = fl && (c[i] == c[i + 1] && c[i] == y);
		if(c[i] == y && c[i - 1] != y) ans ++;
	}
	if(fl){
		printf("0");
		return 0;
	}
	printf("%d", max(1, ans - z + 1 - aa - bb));
	return 0;
}
```


---


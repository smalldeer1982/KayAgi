# 「TAOI-2」核心共振

## 题目背景

⚡超越一切震慑凡人⚡

⚡带来终结机械降神⚡

⚡风暴之力充满全身⚡

⚡最后一击核心共振⚡

## 题目描述

给定正整数 $p$ 和 $n$。对于一个排列，我们称其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。

请你构造一个 $1 \sim n$ 的排列，最大化其中产生「共振」的次数。如果有多种方案，输出任意一种即可。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（15 pts）：$n \leq 9$，$T \le 10$。
+ Subtask 1（10 pts）：$p = 2$。
+ Subtask 2（30 pts）：$p = 3$。
+ Subtask 3（45 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq p \leq 10^8$，$1 \leq T \leq 10^4$，$1 \leq \sum n \leq 3\times 10^5$。

## 样例 #1

### 输入

```
3
9 1
5 2
1 12345
```

### 输出

```
3 8 7 1 4 5 6 9 2
1 5 3 2 4
1
```

# 题解

## 作者：lemon_qwq (赞：13)

将 $1\sim n$ 的所有数字根据模 $p$ 的余数分类。

将余数加起来等于 $p$ 的数尽量相邻。

如果模 $p$ 是 $0$，为了不妨碍其他数，我们统一把它放到开头或结尾。

用 $p$ 个队列维护即可，但是 $p$ 有点大。

如果 $2\times n \le p$ 的话，随意输出一个 $1\sim n$ 的排列即可。

完结撒花！

---

## 作者：include13_fAKe (赞：11)

## 题意
给定正整数 $p$ 和 $n$。对于一个排列，我们称其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。

请你构造一个 $1 \sim n$ 的排列，最大化其中产生「共振」的次数。如果有多种方案，输出任意一种即可。
## 思路
### Subtask 1
直接暴力枚举所有可能的排列的情况，并选择「共振」的次数最大的一种方案并输出。

时间复杂度 $O(Tn!)$。

### Subtask 2
因为要产生「共振」，且 $p=2$，所以要尽量使奇数和奇数放在一起，偶数和偶数放在一起，使得相邻数之和能够被 $2$ 整除，进而使得产生「共振」的次数最大。

产生「共振」的最大次数为 $n-2$。因为一共有 $n-1$ 个「相邻组」（即相邻两数组成的二元组），而肯定有一个「相邻组」是一边奇数、一边偶数。

例如：$n=9,p=2$ 时

正确的序列可以是 $1,3,5,7,9,2,4,6,8$。

### Subtask 3
这个子任务满足 $p=3$。

我们可以将模 $3$ 余 $1$ 的数和模 $3$ 余 $2$ 的数交替着放。最后放能够被 $3$ 整除的数。

不难发现，产生「共振」的最大次数为 $n-2$。

例如：$n=9,p=3$ 时

正确的序列可以是 $1,2,4,5,7,8,3,6,9$。

### Subtask 4
推广 $p=3$ 时的做法，就可以得到正解。

我们可以枚举每一个 $i$，保证 $1\le i< \frac{p}{2}$，将模 $p$ 余 $i$ 的数和模 $p$ 余 $p-i$ 的数交替着放。

然后放能够被 $p$ 整除的数。

**但是，这里有个大坑点！**

若 $2\mid p$，则我们还没有输出模 $p$ 余 $\frac{p}{2}$ 的数。

我们可以发现，两个模 $p$ 余 $\frac{p}{2}$ 的数的和一定可以被 $p$ 整除，所以把它们放在一起，最大化「共振」的次数。

此时，最多可能有 $\lfloor \frac{p}{2}\rfloor$ 个「相邻组」不产生「共振」。

例如：$n=12,p=4$ 时

正确的序列可以是 $1,3,5,7,9,11,4,8,12,2,6,10$。

$n=12,p=5$ 时

正确的序列可以是 $1,4,6,9,11,2,3,7,8,12,5,10$。

**但是，这里还有问题！**

当 $p$ 足够大时，代码的时间复杂度常数就会非常大。

但是，当 $2n≤p$ 时，**「共振」不可能发生**。

此时，我们就输出 $1,2,3,4,\dots,n-1,n$ 即可。

（蒟蒻在此处看到自己 TLE on #10，还以为自己是没用快读快写才出的问题，但尝试表明，用了也不能 AC，所以在这里卡了很长时间）

另外，在枚举这些配对的数时，**一定要保证它们 $\bm{\le n}$**。不然也有可能出错。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,p;
inline void solve(){
	scanf("%d%d",&n,&p);
	if(n*2<p){
		for(int i=1;i<=n;i++){
			printf("%d ",i);
		}
		return ;
	}
	for(int i=1;i*2<p;i++){
		for(int j=0;j<=n;j+=p){
			if(i+j<=n)	printf("%d ",i+j);
			if(j+p-i<=n)	printf("%d ",j+p-i);
		}
	}
	for(int i=p;i<=n;i+=p){
		printf("%d ",i);
	}
	if(p%2==0){
		for(int i=p/2;i<=n;i+=p){
			printf("%d ",i);
		}
	}
	printf("\n");
	return;
}
int T;
int main(){
	scanf("%d",&T);
	while(T--)	solve();
	return 0;
} 
```

---

## 作者：I_will_AKIOI (赞：7)

由于本蒟蒻实在是太弱了，一道简单的签到题居然调了两小时……

### 题目大意
最大化一个排列中相邻两数之和为 $p$ 的倍数的个数。

为了知道是 $p$ 的倍数，我们可以采用像哈希表一样的存储方法，将对 $p$ 取模相同的数放在一起。为了方便存取，我们将容器 vector 换成队列。建立 $p$ 个队列，放进 $a$ 数组中。$\forall x\in[1,n],x\in a_{x\bmod p}$。如果两个队列的**下标相加等于 $p$ 或 $0$**，就说明这两个队列中**任意两个数之和都是 $p$ 的倍数**。就可以轻松选择出相应的数字了。

其次，每个队列中元素的个数都是固定的。所以你无论怎么选择数字，最终结果都相同。不妨将第一个数定为 $1$。

接下来每个数字就好求了。根据上面的公式，可得 $x\in a_{p-x\bmod p}$。我们选择队列第一个数与 $x$ 相加。如果这个队列空了，就随便选择一个非空队列。从 $0$ 一直枚举到 $p-1$，发现这个队列非空，就选择它“代替”这个数。

不过这种方法会使用到双重循环，如果出现人造毒瘤数据，很容易导致 TLE，原因在于选择一个非空队列需要花费一些时间。

[link](https://www.luogu.com.cn/record/121913384)

因此我们使用 set 来优化。将所有非空队列的下标插入集合中，发现队列空了就删除。就可以随时访问任意一个非空队列。相对于枚举复杂度的 $O(n)$ 有了很大的改进。

但是这题还有一个坑。注意数据范围：$p=10^8$。这种等级的复杂度完成预处理的插入操作都是问题。但是不用担心，当 $p$ 过大时，无论你这个数是多少都无法满足是 $p$ 的倍数。计算可知当 $2n\leq p$ 时，就会出现上述情况。对于这种情况，你随便输出都是对的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,p,now;
queue<int>q[200001];
set<int>s;
int main()
{
  ios::sync_with_stdio(false);
  cin>>t;
  while(t--)
  {
    cin>>n>>p;
    if(p>=2*n)
    {
      for(int i=1;i<=n;i++) cout<<i<<" ";
      cout<<"\n";
      continue;
    }
    for(int i=2;i<=n;i++) q[i%p].push(i);
    for(int i=0;i<p;i++) if(!q[i].empty()) s.insert(i);//队列非空才加入
    now=1;
    cout<<now<<" ";
    for(int i=2;i<=n;i++)
    {
      int f=(p-now%p)%p;//防止now%p=0的特殊情况
      if(q[f].empty()) s.erase(f),f=*s.begin();//没了就删除，f换成任意一个非空队列
      now=q[f].front();
      q[f].pop();
      if(q[f].empty()) s.erase(f);
      cout<<now<<" ";
    }
    cout<<"\n";
  }
  return 0;
}
```

---

## 作者：Eason_cyx (赞：4)

有趣的思维题。

赛时被卡常了，硬是没想到特判。

部分分给的挺好。

先口胡了一个结论：不管怎么排列，$1$ 总在最前面。最后发现结论似乎是对的。

### $\texttt{Part 1：15 pts}$

为什么先讲 $15$ 分呢？因为这 $15$ 分完全没有思维难度啊。

直接枚举全排列，找到共振最大值即可。

单组数据时间复杂度 $O(n!)$。

### $\texttt{Part 2：10 pts}$

从这一部分开始我们就要思考正解了。

这 $10$ pts 是 $p=2$ 的特殊性质。

考虑题目中的描述：“其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。”

那么我们关心的其实就是这些数的余数啊！

为了方便，我们使用 $n=9$ 作为例子。

于是，我们可以得到这个数列：$1$，$0$，$1$，$0$，$1$，$0$，$1$，$0$，$1$。

我们把 $1$ 放在最前面，接下来，为了凑成 $p$ 的倍数，只能选择再选择一个余数为 $1$ 的数。于是我们选择 $3$。

以此类推，直到 $9$。

此时我们发现，没有 $1$ 可以匹配了。那么我们就只能把所有的 $0$ 拿出来，放在后面。

最终的答案就是：$1$，$3$，$5$，$7$，$9$，$2$，$4$，$6$，$8$。

可以发现，这样一定是最优的。

找到规律：先放所有的奇数，再放所有的偶数。

单组数据时间复杂度 $O(n)$。

```cpp
for(int i = 1;i <= n;i += 2) cout << i << ' ';
for(int i = 2;i <= n;i += 2) cout << i << ' ';
```

加上前面的总共可以获得 $25$ 分。

### $\texttt{Part 3：30 pts}$

这 $30$ pts 是 $p=3$ 的特殊情况。

我们拿 $10$ 举例，通过取模得到 $1$，$2$，$0$，$1$，$2$，$0$，$1$，$2$，$0$，$1$。

还是将 $1$ 放在最前面，此时为了凑出 $3$，需要余数 $2$。那么还是这样循环往复，放完了就放 $0$，得到 $1$，$2$，$1$，$2$，$1$，$2$，$1$，$0$，$0$，$0$。转换回来就是 $1$，$2$，$4$，$5$，$7$，$8$，$10$，$3$，$6$，$9$。

注意特判最后一组 `1 2` 即可。

对于转换，可以自己手推一下，得到第 $i$ 组 $1,2$ 分别是 $(i-1)\times p + 1$ 和 $(i-1) \times p + 2$。第 $i$ 组 $0$ 就是 $i \times p$。

单组数据时间复杂度 $O(n)$。

```cpp
if(n % 3 == 0) {
	int zu = n / p;
	for(int i = 1;i <= zu;i++) cout << (i-1)*p+1 << ' ' << (i-1)*p + 2 << ' ';
	for(int i = 1;i <= zu;i++) cout << i*p << ' ';
	cout << endl;
}
else if(n % 3 == 1) {
	//多一个 1
	int zu = n / p;
	for(int i = 1;i <= zu;i++) cout << (i-1)*p+1 << ' ' << (i-1)*p + 2 << ' ';
	cout << n << ' ';
	for(int i = 1;i <= zu;i++) cout << i*p << ' ';
	cout << endl;
}
else {
	//多一组 1,2
	int zu = n / p;
	for(int i = 1;i <= zu;i++) cout << (i-1)*p+1 << ' ' << (i-1)*p + 2 << ' ';
	cout << n-1 << ' ' << n << ' ';
	for(int i = 1;i <= zu;i++) cout << i*p << ' ';
	cout << endl;
}
```

加上前面的部分分就可以拿到 $55$ 分了。

### $\texttt{Part 3.5：找规律}$

如果自己多手玩几个小数据，就可以发现规律：

对于每一个 $1 \le i \le \lfloor\frac{p}{2}\rfloor$，它如果要配对一定是跟 $p-i$ 配对。那么这两个数至少有 $\lfloor\frac{n}{p}\rfloor$ 组，即可以配对 $\lfloor\frac{n}{p}\rfloor$ 组。当然还会剩下 $n \bmod p$，如果这其中包含了 $i$ 和 $p-i$，是要特判的。

当 $p \equiv 1 \pmod 2$ 时，使用上面的规律加上 $0$ 即可；

当 $p \equiv 0 \pmod 2$ 时，需要特判 $\frac{p}{2}$ 的情况。

注意：当 $p=1$ 时，随便输出都可以。

到这里，我们看起来就做完了这道题。

```cpp
if(p == 1) {
		  for(int i = 1;i <= n;i++) cout << i << ' ';
		  cout << "\n";
}
else if(p % 2 == 0) {
		  //此时一定会多出来一个 p/2
		  int zu = n / p,mo = n % p;
		  for(int i = 1;i * 2 < p-1;i++) {
		      int first = i,second = p-i;
		      for(int j = 1;j <= zu;j++) {
		          cout << (j-1)*p+first << ' ' << (j-1)*p+second << ' ';
		      }
		      if(mo >= second) {
		          cout << zu*p + first << ' ' << zu*p+second << ' ';
		      }
		      else if(mo < second && mo >= first) {
		          cout << zu*p + first << ' ';
		      }
		  }
		  for(int i = 1;i <= zu;i++) {
		      cout << (i-1)*p + p / 2 << ' ';
		  }
		  if(mo >= p / 2) {
		      cout << zu*p+p/2 << ' ';
		  }
		  for(int i = 1;i <= zu;i++) {
		      cout << i*p << ' ';
		  }
		  cout << "\n";
}
else {
		  int zu = n / p,mo = n % p;
		  for(int i = 1;i * 2 <= p-1;i++) {
		      int first = i,second = p-i;
		      for(int j = 1;j <= zu;j++) {
		          cout << (j-1)*p+first << ' ' << (j-1)*p+second << ' ';
		      }
		      if(mo >= second) {
		          cout << zu*p + first << ' ' << zu*p+second << ' ';
		      }
		      else if(mo < second && mo >= first) {
		          cout << zu*p + first << ' ';
		      }
		  }
		  for(int i = 1;i <= zu;i++) {
		      cout << i*p << ' ';
		  }
		  cout << "\n";
}
```

[Record](https://www.luogu.com.cn/record/121931024)

很显然，我们的做法是正确的，但是超时了，问题在于常数太大。

那怎么解决呢？

### $\texttt{Part 4：100 pts}$

通过观察数据范围，我们发现，$p$ 有可能比 $n$ 大很多，可以发现，当 $p>2\times n-1$ 时，每一个 $i$ 都无法配对，也就不可能产生共振。但我们的程序仍然在判断，导致运算量过大。

其实此时，既然不能共振，那直接顺序输出 $1 \sim n$ 即可。这和 $p=1$ 是一样的。

```cpp
if(p == 1 || (p > (2 * n - 1))) {
	for(int i = 1;i <= n;i++) cout << i << ' ';
	cout << "\n";
}
```

这样，我们就可以拿到 [$100$ 分](https://www.luogu.com.cn/record/122004654) 了。

### $\texttt{Part 5：总结}$

本题考察的是简单贪心 + 简单数学找规律，重点是比较考验代码能力，是一道好题。

---

## 作者：int_R (赞：3)

[P9573 「TAOI-2」核心共振](https://www.luogu.com.cn/problem/P9573)

构造一个 $n$ 的排列，使相邻两数和为 $p$ 的倍数的个数最多。

$p\mid (a+b)$ 说明 $a+b\equiv 0 \pmod p$，也就是如果 $a\bmod p=x$，尽可能使得 $b\bmod p=(p-x)\bmod p$。

考虑枚举模 $p$ 的余数 $i$，输出一个 $x\equiv i\pmod p$，一个 $y\equiv p-i\pmod p$，这样交叉构造可以使得个数最多。只需要从 $1$ 枚举到 $\lceil \dfrac{p}{2}\rceil-1$，这样不会重复，如果继续枚举的话一对数会被重复计算两遍。

有两个情况需要特判，第一种情况是模 $p$ 为 $0$，也就是说这些数本身就是 $p$ 的倍数，我们将这些数一起输出即可。

第二个情况是当 $2\mid p$，对于模 $p$ 为 $\dfrac{p}{2}$ 的数，我们也是将这些数一起输出即可。

这两个情况如果不特判每个数会被输出两遍。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10;
int T,n,p;
int main()
{
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    cin>>T;
    while(T--)
    {
        cin>>n>>p;int tot=0;
        for(register int i=1;i<=min(n,p-1)&&i<p-i;++i)
            for(register int j=0;j*p+i<=n;++j)//根据 n/p 枚举 
            {
                cout<<j*p+i<<' ';
                if(j*p+(p-i)<=n) cout<<j*p+(p-i)<<' ';//这里需要判断是否小于等于 n
            }
        if(!(p&1)) for(register int j=0;j*p+(p>>1)<=n;++j) cout<<j*p+(p>>1)<<' ';
        for(register int j=1;j*p<=n;++j) cout<<j*p<<' ';cout<<'\n';
    }
    return 0;
}
```


---

## 作者：SXqwq (赞：3)

## Analysis

考场思路，自认为比较好理解。

不妨先考虑一下最简单的情况，当 $p=1$ 的时候直接从 $1$ 到 $n$ 输出即可。

我们考虑尽可能地让每个数字产生贡献。

什么时候会产生贡献呢？我们显然想要尽可能地使一个两个数字的和是 $p$ 的倍数。

首先，两个数都是 $p$ 的倍数，则它俩的和一定也是 $p$ 的倍数，直接输出即可。

对于其他的数，定义一个数 $pos$ 为当前的数，循环枚举倍数 $p\times i$。如果 $p\times i -pos$ 没有使用过则将它和 $pos$ 作为相邻两数输出，同时退出循环，使 $pos=p\times i-pos$。

注意特判当 $p\times i-pos>n$ 退出循环。因为越界。

个人认为这个思路比较好想。

### Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 100010;
int T;
void print(int n)
{
    for(int i=1;i<=n;i++) cout<<i<<" ";
    cout<<endl;
}
int vis[N];
int main()
{   
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>T;
    while(T--)
    {
        memset(vis,0,sizeof(vis));
        int n,p;
        cin>>n>>p;
        int maxn = -1;
        if(p == 1){ print(n); continue;}
        for(int i=1;i;i++) 
        {
            if(p*i > n) 
            {
                maxn = p*(i-1);
                break;
            }
            if(p*i <= n){ cout<<p*i<<" ";vis[p*i] = 1;}
        }
        for(int i=1;i<=n;i++)
        {
            if(!vis[i] && i%p != 0)
            {
                cout<<i<<" ";
                vis[i] = 1;
                int last;
                for(int j=1;j;j++)
                {
                    if(p*j-i > n) break;
                    if(!vis[p*j-i] && p*j-i > 0)
                    {
                        cout<<p*j-i<<" ";
                        vis[p*j-i] = 1;
                        last = p*j-i;
                        for(int k=1;k;k++)
                        {
                            if(p*k-last > n) break;
                            if(p*k-last > 0 && !vis[p*k-last]) //找到第一个两两配对能产生贡献的数
                            {
                                vis[p*k-last] = 1;
                                cout<<p*k-last<<" ";
                                last = p*k-last;
                            }
                        }
                    } 
                }
            }
        }
        cout<<endl;
    }
}
```

---

## 作者：_mi_ka_ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9573)

## 题目大意

给定 $n$ 和 $p$，如果一个排列中两个相邻的数之和是 $p$ 的倍数那么可以说这两个数之间产生了「共振」，构造一个仅由 $1\sim n$ 组成的长度为 $n$ 的排列，使其中的「共振」次数最多。

## 解题思路

看到 $p\le 10^8$ 先想到有没有不可能出现「共振」的情况：

如果 $p>2n$ 那么排列中任何两个数的和都不会是 $p$ 的倍数（任何两个数的和一定小于 $2n$）。

此时我们可以随意顺序输出这 $n$ 个数。

```cpp
if(p>2*n)
{
	for(int i=1;i<=n;i++)
		wr(i),putchar(' ');//直接输出从1到n
	putchar('\n');
	continue;
}
```

之后考虑如何最大化「共振」的次数：尽量更多的让相邻的两个数的和为 $p$ 的倍数。

对于 $0\le r<p$ 那么这种排列一定每相邻两项都是 $p$ 的倍数（一直排列到某个数大于 $n$ 导致越界）：

$$r,p-r,p+r,2p-r,2p+r,3p-r...$$

对于每一个符合条件的 $r$ 都这么构造直到越界这样就能是所求答案（如果 $r=0$ 则还需要去重，但是我这里提前将 $p$ 的倍数输出可以避免这件事）。

## AC Code

防止作弊只放主函数。

```cpp
signed main()
{
	T=re();//快读
	while(T--)
	{
		n=re(),p=re();
		if(p>2*n)//特判 
		{
			for(int i=1;i<=n;i++)
				wr(i),putchar(' ');//直接输出从1到n（快写）
			putchar('\n');
			continue;
		}
		for(int i=1;i*p<=n;i++)//先将p的倍数（即r=0的情况输出，避免特判） 
			wr(i*p),putchar(' ');
		for(int r=1;r<=p/2;r++)//枚举r,由于我们要输出i*p-r,所以p-r的不需要再枚举，所以枚举到p/2 
		{
			wr(r),putchar(' ');
			for(int i=1;i*p-r<=n;i++)//枚举p的因数
			{
				if(r==(p-r)&&i==1)
					continue;//上面已经输出r了 
				else if(r==(p-r))
					wr(i*p-r),putchar(' ');
				else
				{
					wr(i*p-r),putchar(' ');
					if(i*p+r>n)//发现越界直接结束到下一个r 
						break;
					wr(i*p+r),putchar(' ');
				}
			} 
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：Convergent_Series (赞：2)

排列中相邻两项的和最大只可能是 $2\times n-1$，所以 $p\ge2\times n$ 时无法共振，直接按顺序输出即可。

否则，考虑按以下方式构造：

1. 先输出 $p$ 的所有倍数，这样相邻两项一定共振。

2. 从 $1$ 至 $\lfloor\dfrac{p}{2}\rfloor$ 枚举数对 $p$ 取余的结果 $m$，将对取余的结果为 $m$ 和 $p-m$ 的交替输出，保证相邻两项相加对 $p$ 取余的结果为 $0$，可以共振。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
#define pcs putchar(' ')
#define pcn putchar('\n')
using namespace std;
int read(){
	int a=0,f=1;char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
	if(ch=='-') f=-1,ch=getchar();
	while(ch>='0'&&ch<='9') a=a*10+(ch^'0'),ch=getchar();
	return a*f;
}
void write(int a){
	if(a<0){putchar('-');a=-a;}
	if(a>9) write(a/10);
	putchar(a%10+'0');
}
int T,n,p;
void solve(){
	if(p==1||p>=2*n){//特判
		for(int i=1;i<=n;i++) write(i),pcs;
		return;
	}
	for(int i=p;i<=n;i+=p) write(i),pcs;//p的倍数
	for(int m1=1,m2=p-1;m1<=p/2;m1++,m2--){
		if(m1!=m2){//交替输出
			for(int i=0;i+m2<=n;i+=p) write(i+m1),pcs,write(i+m2),pcs;
			if((int)(n/p)*p+m1<=n&&(int)(n/p)*p+m2>n) write((int)(n/p)*p+m1),pcs;
		}
		
		else for(int i=0;i+m1<=n;i+=p) write(i+m1),pcs;
	}
}
signed main(){
	T=read();
	while(T--){
		n=read();p=read();solve();pcn;
	}
	return 0;
} 
```

---

## 作者：Aveiro7 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P9573)
## 题意：

给定正整数 $p$ 和 $n$。对于一个排列，我们称其中相邻两项产生「共振」当且仅当这两个数的和为 $p$ 的倍数。

请你构造一个 $1 \sim n$ 的排列，最大化其中产生「共振」的次数。如果有多种方案，输出任意一种即可。

## 思路：

经观察，相邻两项的和最大只有 $2\times n-1$，那么当 $p\ge 2\times n$ 时无法「共振」，此时按顺序输出即可。

特判完之后就要开始构造可以「共振」的情况了。

* 先把从 $p$ 开始，一直到 $2\times n$ 的 $p$ 的倍数，此时相邻两项必定「共振」。

* 设 $i$ 从 ``1`` 开始，一直到 $\frac{p}{2}$，将 $k$ 设为 $p \bmod i$ 的结果，并以一个 $k$，一个 $p-k$ 的形式交替输出，此时相邻两项的和是 $p$ 的倍数，可以「共振」。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,T,i,j;
int main(){
	cin>>T;
	while(T--){
		cin>>n>>p;
		if(p>n*2){
		for(i=1;i<=n;i++){
			cout<<i<<" ";
		}
		continue;
	}
	for(i=1;i*2<p;i++){
		for(j=0;j<=n;j+=p){
			if(i+j<=n)
				cout<<i+j<<" ";
			if(j+p-i<=n)
				cout<<j+p-i<<" ";
		}
	}
	for(i=p;i<=n;i+=p){
		cout<<i<<" ";
	}
	if(p%2==0){
		for(i=p/2;i<=n;i+=p){
			cout<<i<<" ";
		}
	}
	cout<<endl;
	continue;
	}
	return 0;
}
```


---

## 作者：Vct14 (赞：1)

由于相邻两项之和最大为 $n+(n-1)=2n-1$，所以当 $p>2n-1$ 时「共振」次数一定为 $0$。输出任意一种排列即可。

否则将所有模 $p$ 余 $i$ 的数与模 $p$ 余 $p-i$ 的数交替放在一起，将 $p$ 的倍数放在一起。

注意：如果 $p$ 为偶数，则我们的代码会把“所有模 $p$ 余 $\dfrac p2$ 的数与模 $p$ 余 $\dfrac p2$ 的数交替放在一起”，即这些数会被重复输出。将它们也放在一起即可。

```c++
#include<bits/stdc++.h>
using namespace std;
#define F(w,x,y,z) for(int w=x; w<=y; w+=z)
#define f(x,y,z) F(i,x,y,z)

int n,p;
void out(int x){ // 在范围内则输出 
	if(x>=1 && x<=n) cout<<x<<" ";
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T;
	cin>>T;
	while(T--){
		cin>>n>>p;
		if(p>2*n-1){f(1,n,1){out(i);}continue;}
		f(p,n,p) out(i); // p 的倍数 
		if(p%2==0) f(p/2,n,p) out(i); // p 为偶数 
		f(1,(p-1)/2,1) F(j,0,n,p) out(j+i),out(j+(p-i)); // i 表示枚举的余数，j 表示枚举的商 
		cout<<"\n";
	}
	return 0;
}
```

---

## 作者：二叉苹果树 (赞：1)

对于两个数 $x, y$，产生共振时满足 $p \mid x + y$。

那么我们可以按模 $p$ 的值将数分类，然后对应分组输出。

$n \times 2 \leq p$ 时， 一定有 $x + y  \lt p$，贡献为 $0$，随意构造。

```cpp
#include <bits/stdc++.h>

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int t, p, n;
    std::cin >> t;
    while (t--)
    {
        std::cin >> n >> p;
        if (n * 2 <= p)
        {
            for (int i = 1; i <= n; i++)
                std::cout << i << ' ';
            std::cout << '\n';
            continue;
        }
        std::vector<int> e[p];
        for (int i = 1; i <= n; i++)
            e[i % p].push_back(i);
        for (int i = 0; i <= std::min(p / 2, n); i++)
        {
            if (i == 0 || i * 2 == p)
                for (int j = 0; j < e[i].size(); j++)
                    std::cout << e[i][j] << ' ';
            else
            {
                std::vector<int> x, y;
                if (e[i].size() >= e[p - i].size())
                    x = e[i], y = e[p - i];
                else
                    x = e[p - i], y = e[i];
                for (int j = 0; j < y.size(); j++)
                    std::cout << x[j] << ' ' << y[j] << ' ';
                for (int j = y.size(); j < x.size(); j++)
                    std::cout << x[j] << ' ';
            }
        }
        std::cout << '\n';
    }
    return 0;
}
```


---

## 作者：Clarinet (赞：1)

[博客食用观感更佳](https://www.luogu.com.cn/blog/Czel-X/ti-xie-16-post)
# 简要题意
有 $T$ 组数据，每组数据给出两个正整数 $n$ 和 $p$，求一个 $1$ 到 $n$ 的排列使相邻两项之和为 $p$ 的倍数的情况最多。
# 分析
首先很容易想到，要满足两项之和为 $p$，就一定要满足这两项除以 $p$ 的余数相加等于 $p$。

下表是 $1$ 到 $15$ 所有数除以 $6$ 的余数，请结合它进行理解。

| 数字 |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  |  11  |  12  |  13  |  14  |  15  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 余数 |  1  |  2  |  3  |  4  |  5  |  0  |  1  |  2  |  3  |  4  |  5  |  0  |  1  |  2  |  3  |

结合小学数学，不难发现余数是以 $p$ 为循环节长度进行循环的。那么在一个循环节当中可以相加为 $p$ 的总在两边，而且余数为 $p / 2$ 在本循环节中没有对应的数。

考虑遍历数组。我们用 $i$ 来表示当前遍历的余数，用 $j$ 来表示循环节遍历到的节数（每次增加 $p$），所以此时表示的数就是 $i + j$。由于循环节长度是 $p$，则此时与它对应的数就是 $j + p - i$。注意在这之中 $i * 2$ 必须小于 $p$，避免重复输出。

接下来我们输出 $p$ 为偶数时的 $p / 2$ 项，每次增加 $p$ 来找到下一个循环节和其对应的数。然后再把余数为 $0$ 的数给输出。

这里提一下，余数为 $0$ 的数如果放在前面计算就会与下一循环节的数字形成重复输出，所以要最后一起输出。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,p,x[100010],vis[100010],la;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>p;
		if(2*n<p){
			for(int i=1;i<=n;i++)cout<<i<<" ";
			cout<<endl;
			continue;
		}
		for(int i=1;i*2<p;i++){
			for(int j=0;j<=n;j+=p){
				if(i+j<=n)cout<<i+j<<" ";
				if(j+p-i<=n)cout<<j+p-i<<" ";
			}
		}
		if(!(p%2)){
			for(int i=p/2;i<=n;i+=p)cout<<i<<" ";
		}
		for(int i=p;i<=n;i+=p)cout<<i<<" ";
		cout<<endl;
	}
	return 0;
}
```
感谢阅读！

---

## 作者：jiangjiangQwQ (赞：1)

### 思路
将所有 $a_i$ 按照对 $p$ 取模的余数来分。对于一个不是 $p$ 的倍数的数而言，假设它对 $p$ 取模的余数为 $b$。那么另一个数就要是对 $p$ 取模的余数是 $p-b$ 才能配对成 $p$ 的倍数。如果就是 $p$ 的倍数，顺序输出就可以。相邻两个为 $p$ 的倍数的数相加还是 $p$ 的倍数。
### 无解情况
当 $p>2\times n$ 时，直接输出所有 $1 \sim n$ 的数。不存在有两个数的和或单独一个数是 $p$ 的倍数。
### 坑
如果你是按照对 $p$ 取模的余数大小来按顺序输出数的话。注意特判 $p$ 是偶数的情况。因为会把余数是 $p \div 2$ 的数重复输出一遍。
### 代码
```cpp
#include<iostream>
#include<vector>
using namespace std;
int T,n,p;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>p;
		if(p>2*n){
			for(int i=1;i<=n;i++){
				cout<<i<<' ';
			}cout<<'\n';
		}else{
			for(int i=1;i<=n;i++){
				if(i%p==0){
					cout<<i<<' ';
				}
			}
			for(int j=1;j<=p/2;j++){
				if(p%2==0&&j==p/2){
					for(int i=j;i<=n;i+=p) cout<<i<<' ';
				}else{
					int num=n/j,num1=n/(p-j),f=0,x=j,y=p-j;
					if(num<num1) f=1;
					if(f==0){
						while(num1--){
							if(x>=1&&x<=n) cout<<x<<' ';
							x+=p;
							if(y>=1&&y<=n) cout<<y<<' ';
							y+=p;
						}if(num-num1>0&&x>=1&&x<=n){
							cout<<x<<' ';
						}
					}else{
						while(num--){
							if(y>=1&&y<=n) cout<<y<<' ';
							y+=p;
							if(x>=1&&x<=n) cout<<x<<' ';
							x+=p;
						}if(num1-num>0&&y>=1&&y<=n){
							cout<<y<<' ';
						}
					}
				}
			}cout<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：251Sec (赞：1)

Fun Fact: 样例中输出的第一个排列在所有 $1 \sim 9$ 的排列中的字典序排名为 $114514$。

---

考虑每个数模 $p$ 的结果，可以发现如果相邻的两个数模 $p$ 分别为 $x(x \in [1, p))$ 和 $(p-x)$，或者相邻两个数均为 $p$ 的倍数，那么会产生一个贡献，反之则不会。

因此如果考虑有可能产生贡献的数对，它们会形成若干独立的连通块，每个连通块模 $p$ 形如 $x$ 和 $(p-x)$，或者整个连通块为 $p$ 的倍数。由此可得答案的上界为 $n$ 减去连通块数。

对每个连通块考虑，最优的方案显然为将 $x$ 和 $(p-x)$ 交替放，容易发现这是可以做到的，因为模 $p$ 余 $x$ 和 $(p-x)$ 的数的个数相差不超过 $1$。再将 $p$ 的倍数放在一起即可。容易发现这样的构造可以达到上界。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int T, n, p;
int main() {
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &p);
        for (int i = p; i <= n; i += p) printf("%d ", i);
        for (int i = 1; i * 2 < p && i <= n; i++) {
            int c1 = (n - i) / p + 1, c2 = (n + i) / p;
            for (int j = 0; j < c1 + c2; j++) {
                printf("%d ", (j & 1) ? (p - i + (j / 2) * p) : (i + (j / 2) * p));
            }
        }
        if (!(p & 1)) for (int i = p / 2; i <= n; i += p) printf("%d ", i);
        putchar('\n');
    }
    return 0;
}
```

---

